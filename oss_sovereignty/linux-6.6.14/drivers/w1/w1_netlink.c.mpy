{
  "module_name": "w1_netlink.c",
  "hash_id": "2dcb1fe4e3c5d8b7a0de9ec77b8c4c2ed7ee07cab268656c7c3942775030ad9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/w1_netlink.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n\n#include \"w1_internal.h\"\n#include \"w1_netlink.h\"\n\n#if defined(CONFIG_W1_CON) && (defined(CONFIG_CONNECTOR) || (defined(CONFIG_CONNECTOR_MODULE) && defined(CONFIG_W1_MODULE)))\n\n \nstruct w1_cb_block {\n\tatomic_t refcnt;\n\tu32 portid;  \n\t \n\tu16 maxlen;\n\t \n\tstruct cn_msg *first_cn;  \n\tstruct cn_msg *cn;  \n\tstruct w1_netlink_msg *msg;  \n\tstruct w1_netlink_cmd *cmd;  \n\tstruct w1_netlink_msg *cur_msg;  \n\t \n\tstruct cn_msg request_cn;\n\t \n};\nstruct w1_cb_node {\n\tstruct w1_async_cmd async;\n\t \n\tstruct w1_cb_block *block;\n\tstruct w1_netlink_msg *msg;\n\tstruct w1_slave *sl;\n\tstruct w1_master *dev;\n};\n\n \nstatic u16 w1_reply_len(struct w1_cb_block *block)\n{\n\tif (!block->cn)\n\t\treturn 0;\n\treturn (u8 *)block->cn - (u8 *)block->first_cn + block->cn->len;\n}\n\nstatic void w1_unref_block(struct w1_cb_block *block)\n{\n\tif (atomic_sub_return(1, &block->refcnt) == 0) {\n\t\tu16 len = w1_reply_len(block);\n\t\tif (len) {\n\t\t\tcn_netlink_send_mult(block->first_cn, len,\n\t\t\t\t\t     block->portid, 0,\n\t\t\t\t\t     GFP_KERNEL, NULL, NULL);\n\t\t}\n\t\tkfree(block);\n\t}\n}\n\n \nstatic void w1_reply_make_space(struct w1_cb_block *block, u16 space)\n{\n\tu16 len = w1_reply_len(block);\n\tif (len + space >= block->maxlen) {\n\t\tcn_netlink_send_mult(block->first_cn, len, block->portid,\n\t\t\t\t     0, GFP_KERNEL, NULL, NULL);\n\t\tblock->first_cn->len = 0;\n\t\tblock->cn = NULL;\n\t\tblock->msg = NULL;\n\t\tblock->cmd = NULL;\n\t}\n}\n\n \nstatic void w1_netlink_check_send(struct w1_cb_block *block)\n{\n\tif (!(block->request_cn.flags & W1_CN_BUNDLE) && block->cn)\n\t\tw1_reply_make_space(block, block->maxlen);\n}\n\n \nstatic void w1_netlink_setup_msg(struct w1_cb_block *block, u32 ack)\n{\n\tif (block->cn && block->cn->ack == ack) {\n\t\tblock->msg = (struct w1_netlink_msg *)(block->cn->data + block->cn->len);\n\t} else {\n\t\t \n\t\tif (block->cn)\n\t\t\tblock->cn = (struct cn_msg *)(block->cn->data +\n\t\t\t\tblock->cn->len);\n\t\telse\n\t\t\tblock->cn = block->first_cn;\n\n\t\tmemcpy(block->cn, &block->request_cn, sizeof(*block->cn));\n\t\tblock->cn->len = 0;\n\t\tblock->cn->ack = ack;\n\t\tblock->msg = (struct w1_netlink_msg *)block->cn->data;\n\t}\n}\n\n \nstatic void w1_netlink_queue_cmd(struct w1_cb_block *block,\n\tstruct w1_netlink_cmd *cmd)\n{\n\tu32 space;\n\tw1_reply_make_space(block, sizeof(struct cn_msg) +\n\t\tsizeof(struct w1_netlink_msg) + sizeof(*cmd) + cmd->len);\n\n\t \n\tw1_netlink_setup_msg(block, block->request_cn.seq + 1);\n\tmemcpy(block->msg, block->cur_msg, sizeof(*block->msg));\n\tblock->cn->len += sizeof(*block->msg);\n\tblock->msg->len = 0;\n\tblock->cmd = (struct w1_netlink_cmd *)(block->msg->data);\n\n\tspace = sizeof(*cmd) + cmd->len;\n\tif (block->cmd != cmd)\n\t\tmemcpy(block->cmd, cmd, space);\n\tblock->cn->len += space;\n\tblock->msg->len += space;\n}\n\n \nstatic void w1_netlink_queue_status(struct w1_cb_block *block,\n\tstruct w1_netlink_msg *req_msg, struct w1_netlink_cmd *req_cmd,\n\tint error)\n{\n\tu16 space = sizeof(struct cn_msg) + sizeof(*req_msg) + sizeof(*req_cmd);\n\tw1_reply_make_space(block, space);\n\tw1_netlink_setup_msg(block, block->request_cn.ack);\n\n\tmemcpy(block->msg, req_msg, sizeof(*req_msg));\n\tblock->cn->len += sizeof(*req_msg);\n\tblock->msg->len = 0;\n\tblock->msg->status = (u8)-error;\n\tif (req_cmd) {\n\t\tstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)block->msg->data;\n\t\tmemcpy(cmd, req_cmd, sizeof(*cmd));\n\t\tblock->cn->len += sizeof(*cmd);\n\t\tblock->msg->len += sizeof(*cmd);\n\t\tcmd->len = 0;\n\t}\n\tw1_netlink_check_send(block);\n}\n\n \nstatic void w1_netlink_send_error(struct cn_msg *cn, struct w1_netlink_msg *msg,\n\tint portid, int error)\n{\n\tstruct {\n\t\tstruct cn_msg cn;\n\t\tstruct w1_netlink_msg msg;\n\t} packet;\n\tmemcpy(&packet.cn, cn, sizeof(packet.cn));\n\tmemcpy(&packet.msg, msg, sizeof(packet.msg));\n\tpacket.cn.len = sizeof(packet.msg);\n\tpacket.msg.len = 0;\n\tpacket.msg.status = (u8)-error;\n\tcn_netlink_send(&packet.cn, portid, 0, GFP_KERNEL);\n}\n\n \nvoid w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)\n{\n\tstruct {\n\t\tstruct cn_msg cn;\n\t\tstruct w1_netlink_msg msg;\n\t} packet;\n\tmemset(&packet, 0, sizeof(packet));\n\n\tpacket.cn.id.idx = CN_W1_IDX;\n\tpacket.cn.id.val = CN_W1_VAL;\n\n\tpacket.cn.seq = dev->seq++;\n\tpacket.cn.len = sizeof(*msg);\n\n\tmemcpy(&packet.msg, msg, sizeof(*msg));\n\tpacket.msg.len = 0;\n\n\tcn_netlink_send(&packet.cn, 0, 0, GFP_KERNEL);\n}\n\nstatic void w1_send_slave(struct w1_master *dev, u64 rn)\n{\n\tstruct w1_cb_block *block = dev->priv;\n\tstruct w1_netlink_cmd *cache_cmd = block->cmd;\n\tu64 *data;\n\n\tw1_reply_make_space(block, sizeof(*data));\n\n\t \n\tif (!block->cmd) {\n\t\tcache_cmd->len = 0;\n\t\tw1_netlink_queue_cmd(block, cache_cmd);\n\t}\n\n\tdata = (u64 *)(block->cmd->data + block->cmd->len);\n\n\t*data = rn;\n\tblock->cn->len += sizeof(*data);\n\tblock->msg->len += sizeof(*data);\n\tblock->cmd->len += sizeof(*data);\n}\n\nstatic void w1_found_send_slave(struct w1_master *dev, u64 rn)\n{\n\t \n\tw1_slave_found(dev, rn);\n\n\tw1_send_slave(dev, rn);\n}\n\n \nstatic int w1_get_slaves(struct w1_master *dev, struct w1_netlink_cmd *req_cmd)\n{\n\tstruct w1_slave *sl;\n\n\treq_cmd->len = 0;\n\tw1_netlink_queue_cmd(dev->priv, req_cmd);\n\n\tif (req_cmd->cmd == W1_CMD_LIST_SLAVES) {\n\t\tu64 rn;\n\t\tmutex_lock(&dev->list_mutex);\n\t\tlist_for_each_entry(sl, &dev->slist, w1_slave_entry) {\n\t\t\tmemcpy(&rn, &sl->reg_num, sizeof(rn));\n\t\t\tw1_send_slave(dev, rn);\n\t\t}\n\t\tmutex_unlock(&dev->list_mutex);\n\t} else {\n\t\tw1_search_process_cb(dev, req_cmd->cmd == W1_CMD_ALARM_SEARCH ?\n\t\t\tW1_ALARM_SEARCH : W1_SEARCH, w1_found_send_slave);\n\t}\n\n\treturn 0;\n}\n\nstatic int w1_process_command_io(struct w1_master *dev,\n\tstruct w1_netlink_cmd *cmd)\n{\n\tint err = 0;\n\n\tswitch (cmd->cmd) {\n\tcase W1_CMD_TOUCH:\n\t\tw1_touch_block(dev, cmd->data, cmd->len);\n\t\tw1_netlink_queue_cmd(dev->priv, cmd);\n\t\tbreak;\n\tcase W1_CMD_READ:\n\t\tw1_read_block(dev, cmd->data, cmd->len);\n\t\tw1_netlink_queue_cmd(dev->priv, cmd);\n\t\tbreak;\n\tcase W1_CMD_WRITE:\n\t\tw1_write_block(dev, cmd->data, cmd->len);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int w1_process_command_addremove(struct w1_master *dev,\n\tstruct w1_netlink_cmd *cmd)\n{\n\tstruct w1_slave *sl;\n\tint err = 0;\n\tstruct w1_reg_num *id;\n\n\tif (cmd->len != sizeof(*id))\n\t\treturn -EINVAL;\n\n\tid = (struct w1_reg_num *)cmd->data;\n\n\tsl = w1_slave_search_device(dev, id);\n\tswitch (cmd->cmd) {\n\tcase W1_CMD_SLAVE_ADD:\n\t\tif (sl)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = w1_attach_slave_device(dev, id);\n\t\tbreak;\n\tcase W1_CMD_SLAVE_REMOVE:\n\t\tif (sl)\n\t\t\tw1_slave_detach(sl);\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int w1_process_command_master(struct w1_master *dev,\n\tstruct w1_netlink_cmd *req_cmd)\n{\n\tint err = -EINVAL;\n\n\t \n\tswitch (req_cmd->cmd) {\n\tcase W1_CMD_SEARCH:\n\tcase W1_CMD_ALARM_SEARCH:\n\tcase W1_CMD_LIST_SLAVES:\n\t\tmutex_unlock(&dev->bus_mutex);\n\t\terr = w1_get_slaves(dev, req_cmd);\n\t\tmutex_lock(&dev->bus_mutex);\n\t\tbreak;\n\tcase W1_CMD_READ:\n\tcase W1_CMD_WRITE:\n\tcase W1_CMD_TOUCH:\n\t\terr = w1_process_command_io(dev, req_cmd);\n\t\tbreak;\n\tcase W1_CMD_RESET:\n\t\terr = w1_reset_bus(dev);\n\t\tbreak;\n\tcase W1_CMD_SLAVE_ADD:\n\tcase W1_CMD_SLAVE_REMOVE:\n\t\tmutex_unlock(&dev->bus_mutex);\n\t\tmutex_lock(&dev->mutex);\n\t\terr = w1_process_command_addremove(dev, req_cmd);\n\t\tmutex_unlock(&dev->mutex);\n\t\tmutex_lock(&dev->bus_mutex);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int w1_process_command_slave(struct w1_slave *sl,\n\t\tstruct w1_netlink_cmd *cmd)\n{\n\tdev_dbg(&sl->master->dev, \"%s: %02x.%012llx.%02x: cmd=%02x, len=%u.\\n\",\n\t\t__func__, sl->reg_num.family, (unsigned long long)sl->reg_num.id,\n\t\tsl->reg_num.crc, cmd->cmd, cmd->len);\n\n\treturn w1_process_command_io(sl->master, cmd);\n}\n\nstatic int w1_process_command_root(struct cn_msg *req_cn, u32 portid)\n{\n\tstruct w1_master *dev;\n\tstruct cn_msg *cn;\n\tstruct w1_netlink_msg *msg;\n\tu32 *id;\n\n\tcn = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!cn)\n\t\treturn -ENOMEM;\n\n\tcn->id.idx = CN_W1_IDX;\n\tcn->id.val = CN_W1_VAL;\n\n\tcn->seq = req_cn->seq;\n\tcn->ack = req_cn->seq + 1;\n\tcn->len = sizeof(struct w1_netlink_msg);\n\tmsg = (struct w1_netlink_msg *)cn->data;\n\n\tmsg->type = W1_LIST_MASTERS;\n\tmsg->status = 0;\n\tmsg->len = 0;\n\tid = (u32 *)msg->data;\n\n\tmutex_lock(&w1_mlock);\n\tlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\n\t\tif (cn->len + sizeof(*id) > PAGE_SIZE - sizeof(struct cn_msg)) {\n\t\t\tcn_netlink_send(cn, portid, 0, GFP_KERNEL);\n\t\t\tcn->len = sizeof(struct w1_netlink_msg);\n\t\t\tmsg->len = 0;\n\t\t\tid = (u32 *)msg->data;\n\t\t}\n\n\t\t*id = dev->id;\n\t\tmsg->len += sizeof(*id);\n\t\tcn->len += sizeof(*id);\n\t\tid++;\n\t}\n\tcn_netlink_send(cn, portid, 0, GFP_KERNEL);\n\tmutex_unlock(&w1_mlock);\n\n\tkfree(cn);\n\treturn 0;\n}\n\nstatic void w1_process_cb(struct w1_master *dev, struct w1_async_cmd *async_cmd)\n{\n\tstruct w1_cb_node *node = container_of(async_cmd, struct w1_cb_node,\n\t\tasync);\n\tu16 mlen = node->msg->len;\n\tu16 len;\n\tint err = 0;\n\tstruct w1_slave *sl = node->sl;\n\tstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)node->msg->data;\n\n\tmutex_lock(&dev->bus_mutex);\n\tdev->priv = node->block;\n\tif (sl && w1_reset_select_slave(sl))\n\t\terr = -ENODEV;\n\tnode->block->cur_msg = node->msg;\n\n\twhile (mlen && !err) {\n\t\tif (cmd->len + sizeof(struct w1_netlink_cmd) > mlen) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sl)\n\t\t\terr = w1_process_command_slave(sl, cmd);\n\t\telse\n\t\t\terr = w1_process_command_master(dev, cmd);\n\t\tw1_netlink_check_send(node->block);\n\n\t\tw1_netlink_queue_status(node->block, node->msg, cmd, err);\n\t\terr = 0;\n\n\t\tlen = sizeof(*cmd) + cmd->len;\n\t\tcmd = (struct w1_netlink_cmd *)((u8 *)cmd + len);\n\t\tmlen -= len;\n\t}\n\n\tif (!cmd || err)\n\t\tw1_netlink_queue_status(node->block, node->msg, cmd, err);\n\n\t \n\tif (sl)\n\t\tw1_unref_slave(sl);\n\telse\n\t\tatomic_dec(&dev->refcnt);\n\tdev->priv = NULL;\n\tmutex_unlock(&dev->bus_mutex);\n\n\tmutex_lock(&dev->list_mutex);\n\tlist_del(&async_cmd->async_entry);\n\tmutex_unlock(&dev->list_mutex);\n\n\tw1_unref_block(node->block);\n}\n\nstatic void w1_list_count_cmds(struct w1_netlink_msg *msg, int *cmd_count,\n\tu16 *slave_len)\n{\n\tstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)msg->data;\n\tu16 mlen = msg->len;\n\tu16 len;\n\tint slave_list = 0;\n\twhile (mlen) {\n\t\tif (cmd->len + sizeof(struct w1_netlink_cmd) > mlen)\n\t\t\tbreak;\n\n\t\tswitch (cmd->cmd) {\n\t\tcase W1_CMD_SEARCH:\n\t\tcase W1_CMD_ALARM_SEARCH:\n\t\tcase W1_CMD_LIST_SLAVES:\n\t\t\t++slave_list;\n\t\t}\n\t\t++*cmd_count;\n\t\tlen = sizeof(*cmd) + cmd->len;\n\t\tcmd = (struct w1_netlink_cmd *)((u8 *)cmd + len);\n\t\tmlen -= len;\n\t}\n\n\tif (slave_list) {\n\t\tstruct w1_master *dev = w1_search_master_id(msg->id.mst.id);\n\t\tif (dev) {\n\t\t\t \n\t\t\t*slave_len += sizeof(struct w1_reg_num) * slave_list *\n\t\t\t\t(dev->slave_count + dev->max_slave_count);\n\t\t\t \n\t\t\tatomic_dec(&dev->refcnt);\n\t\t}\n\t}\n}\n\nstatic void w1_cn_callback(struct cn_msg *cn, struct netlink_skb_parms *nsp)\n{\n\tstruct w1_netlink_msg *msg = (struct w1_netlink_msg *)(cn + 1);\n\tstruct w1_slave *sl;\n\tstruct w1_master *dev;\n\tu16 msg_len;\n\tu16 slave_len = 0;\n\tint err = 0;\n\tstruct w1_cb_block *block = NULL;\n\tstruct w1_cb_node *node = NULL;\n\tint node_count = 0;\n\tint cmd_count = 0;\n\n\t \n\tif (cn->flags & ~(W1_CN_BUNDLE)) {\n\t\tw1_netlink_send_error(cn, msg, nsp->portid, -EINVAL);\n\t\treturn;\n\t}\n\n\t \n\tmsg_len = cn->len;\n\twhile (msg_len && !err) {\n\t\tif (msg->len + sizeof(struct w1_netlink_msg) > msg_len) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msg->type == W1_MASTER_CMD || msg->type == W1_SLAVE_CMD) {\n\t\t\t++node_count;\n\t\t\tw1_list_count_cmds(msg, &cmd_count, &slave_len);\n\t\t}\n\n\t\tmsg_len -= sizeof(struct w1_netlink_msg) + msg->len;\n\t\tmsg = (struct w1_netlink_msg *)(((u8 *)msg) +\n\t\t\tsizeof(struct w1_netlink_msg) + msg->len);\n\t}\n\tmsg = (struct w1_netlink_msg *)(cn + 1);\n\tif (node_count) {\n\t\tint size;\n\t\tint reply_size = sizeof(*cn) + cn->len + slave_len;\n\t\tif (cn->flags & W1_CN_BUNDLE) {\n\t\t\t \n\t\t\treply_size += 2 * cmd_count * (sizeof(struct cn_msg) +\n\t\t\t\tsizeof(struct w1_netlink_msg) +\n\t\t\t\tsizeof(struct w1_netlink_cmd));\n\t\t}\n\t\treply_size = min(CONNECTOR_MAX_MSG_SIZE, reply_size);\n\n\t\t \n\t\tsize =   \n\t\t\tsizeof(struct w1_cb_block) + sizeof(*cn) + cn->len +\n\t\t\t \n\t\t\tnode_count * sizeof(struct w1_cb_node) +\n\t\t\t \n\t\t\tsizeof(struct cn_msg) + reply_size;\n\t\tblock = kzalloc(size, GFP_KERNEL);\n\t\tif (!block) {\n\t\t\t \n\t\t\tw1_netlink_send_error(cn, msg, nsp->portid, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\t\tatomic_set(&block->refcnt, 1);\n\t\tblock->portid = nsp->portid;\n\t\tblock->request_cn = *cn;\n\t\tmemcpy(block->request_cn.data, cn->data, cn->len);\n\t\tnode = (struct w1_cb_node *)(block->request_cn.data + cn->len);\n\n\t\t \n\t\tblock->maxlen = reply_size;\n\t\tblock->first_cn = (struct cn_msg *)(node + node_count);\n\t\tmemset(block->first_cn, 0, sizeof(*block->first_cn));\n\t}\n\n\tmsg_len = cn->len;\n\twhile (msg_len && !err) {\n\n\t\tdev = NULL;\n\t\tsl = NULL;\n\n\t\tif (msg->len + sizeof(struct w1_netlink_msg) > msg_len) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msg->type == W1_LIST_MASTERS) {\n\t\t\terr = w1_process_command_root(cn, nsp->portid);\n\t\t\tgoto out_cont;\n\t\t}\n\n\t\t \n\t\tif (!msg->len) {\n\t\t\terr = -EPROTO;\n\t\t\tgoto out_cont;\n\t\t}\n\n\t\t \n\t\tif (msg->type == W1_MASTER_CMD) {\n\t\t\tdev = w1_search_master_id(msg->id.mst.id);\n\t\t} else if (msg->type == W1_SLAVE_CMD) {\n\t\t\tsl = w1_search_slave((struct w1_reg_num *)msg->id.id);\n\t\t\tif (sl)\n\t\t\t\tdev = sl->master;\n\t\t} else {\n\t\t\tpr_notice(\"%s: cn: %x.%x, wrong type: %u, len: %u.\\n\",\n\t\t\t\t__func__, cn->id.idx, cn->id.val,\n\t\t\t\tmsg->type, msg->len);\n\t\t\terr = -EPROTO;\n\t\t\tgoto out_cont;\n\t\t}\n\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_cont;\n\t\t}\n\n\t\terr = 0;\n\n\t\tatomic_inc(&block->refcnt);\n\t\tnode->async.cb = w1_process_cb;\n\t\tnode->block = block;\n\t\tnode->msg = (struct w1_netlink_msg *)((u8 *)&block->request_cn +\n\t\t\t(size_t)((u8 *)msg - (u8 *)cn));\n\t\tnode->sl = sl;\n\t\tnode->dev = dev;\n\n\t\tmutex_lock(&dev->list_mutex);\n\t\tlist_add_tail(&node->async.async_entry, &dev->async_list);\n\t\twake_up_process(dev->thread);\n\t\tmutex_unlock(&dev->list_mutex);\n\t\t++node;\n\nout_cont:\n\t\t \n\t\tif (err)\n\t\t\tw1_netlink_send_error(cn, msg, nsp->portid, err);\n\t\tmsg_len -= sizeof(struct w1_netlink_msg) + msg->len;\n\t\tmsg = (struct w1_netlink_msg *)(((u8 *)msg) +\n\t\t\tsizeof(struct w1_netlink_msg) + msg->len);\n\n\t\t \n\t\tif (err == -ENODEV)\n\t\t\terr = 0;\n\t}\n\tif (block)\n\t\tw1_unref_block(block);\n}\n\nint w1_init_netlink(void)\n{\n\tstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\n\n\treturn cn_add_callback(&w1_id, \"w1\", &w1_cn_callback);\n}\n\nvoid w1_fini_netlink(void)\n{\n\tstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\n\n\tcn_del_callback(&w1_id);\n}\n#else\nvoid w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *cn)\n{\n}\n\nint w1_init_netlink(void)\n{\n\treturn 0;\n}\n\nvoid w1_fini_netlink(void)\n{\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}