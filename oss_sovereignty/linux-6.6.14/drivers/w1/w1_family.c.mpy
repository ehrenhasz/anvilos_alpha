{
  "module_name": "w1_family.c",
  "hash_id": "f528554962172ac3fa73316cff2e0067367c9d13499080a1e731edd40d621ca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/w1_family.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/sched/signal.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n\n#include \"w1_internal.h\"\n\nDEFINE_SPINLOCK(w1_flock);\nstatic LIST_HEAD(w1_families);\n\n \nint w1_register_family(struct w1_family *newf)\n{\n\tstruct list_head *ent, *n;\n\tstruct w1_family *f;\n\tint ret = 0;\n\n\tspin_lock(&w1_flock);\n\tlist_for_each_safe(ent, n, &w1_families) {\n\t\tf = list_entry(ent, struct w1_family, family_entry);\n\n\t\tif (f->fid == newf->fid) {\n\t\t\tret = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\tatomic_set(&newf->refcnt, 0);\n\t\tlist_add_tail(&newf->family_entry, &w1_families);\n\t}\n\tspin_unlock(&w1_flock);\n\n\t \n\tw1_reconnect_slaves(newf, 1);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(w1_register_family);\n\n \nvoid w1_unregister_family(struct w1_family *fent)\n{\n\tstruct list_head *ent, *n;\n\tstruct w1_family *f;\n\n\tspin_lock(&w1_flock);\n\tlist_for_each_safe(ent, n, &w1_families) {\n\t\tf = list_entry(ent, struct w1_family, family_entry);\n\n\t\tif (f->fid == fent->fid) {\n\t\t\tlist_del(&fent->family_entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&w1_flock);\n\n\t \n\tw1_reconnect_slaves(fent, 0);\n\n\twhile (atomic_read(&fent->refcnt)) {\n\t\tpr_info(\"Waiting for family %u to become free: refcnt=%d.\\n\",\n\t\t\t\tfent->fid, atomic_read(&fent->refcnt));\n\n\t\tif (msleep_interruptible(1000))\n\t\t\tflush_signals(current);\n\t}\n}\nEXPORT_SYMBOL(w1_unregister_family);\n\n \nstruct w1_family * w1_family_registered(u8 fid)\n{\n\tstruct list_head *ent, *n;\n\tstruct w1_family *f = NULL;\n\tint ret = 0;\n\n\tlist_for_each_safe(ent, n, &w1_families) {\n\t\tf = list_entry(ent, struct w1_family, family_entry);\n\n\t\tif (f->fid == fid) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (ret) ? f : NULL;\n}\n\nstatic void __w1_family_put(struct w1_family *f)\n{\n\tatomic_dec(&f->refcnt);\n}\n\nvoid w1_family_put(struct w1_family *f)\n{\n\tspin_lock(&w1_flock);\n\t__w1_family_put(f);\n\tspin_unlock(&w1_flock);\n}\n\n#if 0\nvoid w1_family_get(struct w1_family *f)\n{\n\tspin_lock(&w1_flock);\n\t__w1_family_get(f);\n\tspin_unlock(&w1_flock);\n}\n#endif   \n\nvoid __w1_family_get(struct w1_family *f)\n{\n\tsmp_mb__before_atomic();\n\tatomic_inc(&f->refcnt);\n\tsmp_mb__after_atomic();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}