{
  "module_name": "w1.c",
  "hash_id": "ef01e9386e6e6f696951908ccbcd7bd1c66e6491ea4df243b206531303a19da0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/w1.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/hwmon.h>\n#include <linux/of.h>\n\n#include <linux/atomic.h>\n\n#include \"w1_internal.h\"\n#include \"w1_netlink.h\"\n\n#define W1_FAMILY_DEFAULT\t0\n#define W1_FAMILY_DS28E04       0x1C  \n\n\nstatic int w1_timeout = 10;\nmodule_param_named(timeout, w1_timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"time in seconds between automatic slave searches\");\n\nstatic int w1_timeout_us;\nmodule_param_named(timeout_us, w1_timeout_us, int, 0);\nMODULE_PARM_DESC(timeout_us,\n\t\t \"time in microseconds between automatic slave searches\");\n\n \nint w1_max_slave_count = 64;\nmodule_param_named(max_slave_count, w1_max_slave_count, int, 0);\nMODULE_PARM_DESC(max_slave_count,\n\t\"maximum number of slaves detected in a search\");\n\nint w1_max_slave_ttl = 10;\nmodule_param_named(slave_ttl, w1_max_slave_ttl, int, 0);\nMODULE_PARM_DESC(slave_ttl,\n\t\"Number of searches not seeing a slave before it will be removed\");\n\nDEFINE_MUTEX(w1_mlock);\nLIST_HEAD(w1_masters);\n\nstatic int w1_master_probe(struct device *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic void w1_master_release(struct device *dev)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\n\tdev_dbg(dev, \"%s: Releasing %s.\\n\", __func__, md->name);\n\tmemset(md, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));\n\tkfree(md);\n}\n\nstatic void w1_slave_release(struct device *dev)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\n\tdev_dbg(dev, \"%s: Releasing %s [%p]\\n\", __func__, sl->name, sl);\n\n\tw1_family_put(sl->family);\n\tsl->master->slave_count--;\n}\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\n\treturn sprintf(buf, \"%s\\n\", sl->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t id_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\tssize_t count = sizeof(sl->reg_num);\n\n\tmemcpy(buf, (u8 *)&sl->reg_num, count);\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic struct attribute *w1_slave_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(w1_slave);\n\n \n\nstatic ssize_t rw_write(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\tsize_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\n\tmutex_lock(&sl->master->mutex);\n\tif (w1_reset_select_slave(sl)) {\n\t\tcount = 0;\n\t\tgoto out_up;\n\t}\n\n\tw1_write_block(sl->master, buf, count);\n\nout_up:\n\tmutex_unlock(&sl->master->mutex);\n\treturn count;\n}\n\nstatic ssize_t rw_read(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t       size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\n\tmutex_lock(&sl->master->mutex);\n\tw1_read_block(sl->master, buf, count);\n\tmutex_unlock(&sl->master->mutex);\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(rw, PAGE_SIZE);\n\nstatic struct bin_attribute *w1_slave_bin_attrs[] = {\n\t&bin_attr_rw,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_slave_default_group = {\n\t.bin_attrs = w1_slave_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_slave_default_groups[] = {\n\t&w1_slave_default_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_default_fops = {\n\t.groups\t\t= w1_slave_default_groups,\n};\n\nstatic struct w1_family w1_default_family = {\n\t.fops = &w1_default_fops,\n};\n\nstatic int w1_uevent(const struct device *dev, struct kobj_uevent_env *env);\n\nstatic struct bus_type w1_bus_type = {\n\t.name = \"w1\",\n\t.uevent = w1_uevent,\n};\n\nstruct device_driver w1_master_driver = {\n\t.name = \"w1_master_driver\",\n\t.bus = &w1_bus_type,\n\t.probe = w1_master_probe,\n};\n\nstruct device w1_master_device = {\n\t.parent = NULL,\n\t.bus = &w1_bus_type,\n\t.init_name = \"w1 bus master\",\n\t.driver = &w1_master_driver,\n\t.release = &w1_master_release\n};\n\nstatic struct device_driver w1_slave_driver = {\n\t.name = \"w1_slave_driver\",\n\t.bus = &w1_bus_type,\n};\n\n#if 0\nstruct device w1_slave_device = {\n\t.parent = NULL,\n\t.bus = &w1_bus_type,\n\t.init_name = \"w1 bus slave\",\n\t.driver = &w1_slave_driver,\n\t.release = &w1_slave_release\n};\n#endif   \n\nstatic ssize_t w1_master_attribute_show_name(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%s\\n\", md->name);\n\tmutex_unlock(&md->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_store_search(struct device * dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char * buf, size_t count)\n{\n\tlong tmp;\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tint ret;\n\n\tret = kstrtol(buf, 0, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&md->mutex);\n\tmd->search_count = tmp;\n\tmutex_unlock(&md->mutex);\n\t \n\tif (tmp)\n\t\twake_up_process(md->thread);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_search(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%d\\n\", md->search_count);\n\tmutex_unlock(&md->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_store_pullup(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tlong tmp;\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tint ret;\n\n\tret = kstrtol(buf, 0, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&md->mutex);\n\tmd->enable_pullup = tmp;\n\tmutex_unlock(&md->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_pullup(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%d\\n\", md->enable_pullup);\n\tmutex_unlock(&md->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_pointer(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"0x%p\\n\", md->bus_master);\n\tmutex_unlock(&md->mutex);\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_timeout(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", w1_timeout);\n}\n\nstatic ssize_t w1_master_attribute_show_timeout_us(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", w1_timeout_us);\n}\n\nstatic ssize_t w1_master_attribute_store_max_slave_count(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint tmp;\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\n\tif (kstrtoint(buf, 0, &tmp) || tmp < 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&md->mutex);\n\tmd->max_slave_count = tmp;\n\t \n\tclear_bit(W1_WARN_MAX_COUNT, &md->flags);\n\tmutex_unlock(&md->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_max_slave_count(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%d\\n\", md->max_slave_count);\n\tmutex_unlock(&md->mutex);\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_attempts(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%lu\\n\", md->attempts);\n\tmutex_unlock(&md->mutex);\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_slave_count(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tssize_t count;\n\n\tmutex_lock(&md->mutex);\n\tcount = sprintf(buf, \"%d\\n\", md->slave_count);\n\tmutex_unlock(&md->mutex);\n\treturn count;\n}\n\nstatic ssize_t w1_master_attribute_show_slaves(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tint c = PAGE_SIZE;\n\tstruct list_head *ent, *n;\n\tstruct w1_slave *sl = NULL;\n\n\tmutex_lock(&md->list_mutex);\n\n\tlist_for_each_safe(ent, n, &md->slist) {\n\t\tsl = list_entry(ent, struct w1_slave, w1_slave_entry);\n\n\t\tc -= snprintf(buf + PAGE_SIZE - c, c, \"%s\\n\", sl->name);\n\t}\n\tif (!sl)\n\t\tc -= snprintf(buf + PAGE_SIZE - c, c, \"not found.\\n\");\n\n\tmutex_unlock(&md->list_mutex);\n\n\treturn PAGE_SIZE - c;\n}\n\nstatic ssize_t w1_master_attribute_show_add(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tint c = PAGE_SIZE;\n\tc -= snprintf(buf+PAGE_SIZE - c, c,\n\t\t\"write device id xx-xxxxxxxxxxxx to add slave\\n\");\n\treturn PAGE_SIZE - c;\n}\n\nstatic int w1_atoreg_num(struct device *dev, const char *buf, size_t count,\n\tstruct w1_reg_num *rn)\n{\n\tunsigned int family;\n\tunsigned long long id;\n\tint i;\n\tu64 rn64_le;\n\n\t \n\tconst char *error_msg = \"bad slave string format, expecting \"\n\t\t\"ff-dddddddddddd\\n\";\n\n\tif (buf[2] != '-') {\n\t\tdev_err(dev, \"%s\", error_msg);\n\t\treturn -EINVAL;\n\t}\n\ti = sscanf(buf, \"%02x-%012llx\", &family, &id);\n\tif (i != 2) {\n\t\tdev_err(dev, \"%s\", error_msg);\n\t\treturn -EINVAL;\n\t}\n\trn->family = family;\n\trn->id = id;\n\n\trn64_le = cpu_to_le64(*(u64 *)rn);\n\trn->crc = w1_calc_crc8((u8 *)&rn64_le, 7);\n\n#if 0\n\tdev_info(dev, \"With CRC device is %02x.%012llx.%02x.\\n\",\n\t\t  rn->family, (unsigned long long)rn->id, rn->crc);\n#endif\n\n\treturn 0;\n}\n\n \nstruct w1_slave *w1_slave_search_device(struct w1_master *dev,\n\tstruct w1_reg_num *rn)\n{\n\tstruct w1_slave *sl;\n\tmutex_lock(&dev->list_mutex);\n\tlist_for_each_entry(sl, &dev->slist, w1_slave_entry) {\n\t\tif (sl->reg_num.family == rn->family &&\n\t\t\t\tsl->reg_num.id == rn->id &&\n\t\t\t\tsl->reg_num.crc == rn->crc) {\n\t\t\tmutex_unlock(&dev->list_mutex);\n\t\t\treturn sl;\n\t\t}\n\t}\n\tmutex_unlock(&dev->list_mutex);\n\treturn NULL;\n}\n\nstatic ssize_t w1_master_attribute_store_add(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tstruct w1_reg_num rn;\n\tstruct w1_slave *sl;\n\tssize_t result = count;\n\n\tif (w1_atoreg_num(dev, buf, count, &rn))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&md->mutex);\n\tsl = w1_slave_search_device(md, &rn);\n\t \n\tif (sl) {\n\t\tdev_info(dev, \"Device %s already exists\\n\", sl->name);\n\t\tresult = -EINVAL;\n\t} else {\n\t\tw1_attach_slave_device(md, &rn);\n\t}\n\tmutex_unlock(&md->mutex);\n\n\treturn result;\n}\n\nstatic ssize_t w1_master_attribute_show_remove(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tint c = PAGE_SIZE;\n\tc -= snprintf(buf+PAGE_SIZE - c, c,\n\t\t\"write device id xx-xxxxxxxxxxxx to remove slave\\n\");\n\treturn PAGE_SIZE - c;\n}\n\nstatic ssize_t w1_master_attribute_store_remove(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct w1_master *md = dev_to_w1_master(dev);\n\tstruct w1_reg_num rn;\n\tstruct w1_slave *sl;\n\tssize_t result;\n\n\tif (w1_atoreg_num(dev, buf, count, &rn))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&md->mutex);\n\tsl = w1_slave_search_device(md, &rn);\n\tif (sl) {\n\t\tresult = w1_slave_detach(sl);\n\t\t \n\t\tif (result == 0)\n\t\t\tresult = count;\n\t} else {\n\t\tdev_info(dev, \"Device %02x-%012llx doesn't exists\\n\", rn.family,\n\t\t\t(unsigned long long)rn.id);\n\t\tresult = -EINVAL;\n\t}\n\tmutex_unlock(&md->mutex);\n\n\treturn result;\n}\n\n#define W1_MASTER_ATTR_RO(_name, _mode)\t\t\t\t\\\n\tstruct device_attribute w1_master_attribute_##_name =\t\\\n\t\t__ATTR(w1_master_##_name, _mode,\t\t\\\n\t\t       w1_master_attribute_show_##_name, NULL)\n\n#define W1_MASTER_ATTR_RW(_name, _mode)\t\t\t\t\\\n\tstruct device_attribute w1_master_attribute_##_name =\t\\\n\t\t__ATTR(w1_master_##_name, _mode,\t\t\\\n\t\t       w1_master_attribute_show_##_name,\t\\\n\t\t       w1_master_attribute_store_##_name)\n\nstatic W1_MASTER_ATTR_RO(name, S_IRUGO);\nstatic W1_MASTER_ATTR_RO(slaves, S_IRUGO);\nstatic W1_MASTER_ATTR_RO(slave_count, S_IRUGO);\nstatic W1_MASTER_ATTR_RW(max_slave_count, S_IRUGO | S_IWUSR | S_IWGRP);\nstatic W1_MASTER_ATTR_RO(attempts, S_IRUGO);\nstatic W1_MASTER_ATTR_RO(timeout, S_IRUGO);\nstatic W1_MASTER_ATTR_RO(timeout_us, S_IRUGO);\nstatic W1_MASTER_ATTR_RO(pointer, S_IRUGO);\nstatic W1_MASTER_ATTR_RW(search, S_IRUGO | S_IWUSR | S_IWGRP);\nstatic W1_MASTER_ATTR_RW(pullup, S_IRUGO | S_IWUSR | S_IWGRP);\nstatic W1_MASTER_ATTR_RW(add, S_IRUGO | S_IWUSR | S_IWGRP);\nstatic W1_MASTER_ATTR_RW(remove, S_IRUGO | S_IWUSR | S_IWGRP);\n\nstatic struct attribute *w1_master_default_attrs[] = {\n\t&w1_master_attribute_name.attr,\n\t&w1_master_attribute_slaves.attr,\n\t&w1_master_attribute_slave_count.attr,\n\t&w1_master_attribute_max_slave_count.attr,\n\t&w1_master_attribute_attempts.attr,\n\t&w1_master_attribute_timeout.attr,\n\t&w1_master_attribute_timeout_us.attr,\n\t&w1_master_attribute_pointer.attr,\n\t&w1_master_attribute_search.attr,\n\t&w1_master_attribute_pullup.attr,\n\t&w1_master_attribute_add.attr,\n\t&w1_master_attribute_remove.attr,\n\tNULL\n};\n\nstatic const struct attribute_group w1_master_defattr_group = {\n\t.attrs = w1_master_default_attrs,\n};\n\nint w1_create_master_attributes(struct w1_master *master)\n{\n\treturn sysfs_create_group(&master->dev.kobj, &w1_master_defattr_group);\n}\n\nvoid w1_destroy_master_attributes(struct w1_master *master)\n{\n\tsysfs_remove_group(&master->dev.kobj, &w1_master_defattr_group);\n}\n\nstatic int w1_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct w1_master *md = NULL;\n\tconst struct w1_slave *sl = NULL;\n\tconst char *event_owner, *name;\n\tint err = 0;\n\n\tif (dev->driver == &w1_master_driver) {\n\t\tmd = container_of(dev, struct w1_master, dev);\n\t\tevent_owner = \"master\";\n\t\tname = md->name;\n\t} else if (dev->driver == &w1_slave_driver) {\n\t\tsl = container_of(dev, struct w1_slave, dev);\n\t\tevent_owner = \"slave\";\n\t\tname = sl->name;\n\t} else {\n\t\tdev_dbg(dev, \"Unknown event.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"Hotplug event for %s %s, bus_id=%s.\\n\",\n\t\t\tevent_owner, name, dev_name(dev));\n\n\tif (dev->driver != &w1_slave_driver || !sl)\n\t\tgoto end;\n\n\terr = add_uevent_var(env, \"W1_FID=%02X\", sl->reg_num.family);\n\tif (err)\n\t\tgoto end;\n\n\terr = add_uevent_var(env, \"W1_SLAVE_ID=%024LX\",\n\t\t\t     (unsigned long long)sl->reg_num.id);\nend:\n\treturn err;\n}\n\nstatic int w1_family_notify(unsigned long action, struct w1_slave *sl)\n{\n\tconst struct w1_family_ops *fops;\n\tint err;\n\n\tfops = sl->family->fops;\n\n\tif (!fops)\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\t \n\t\tif (fops->add_slave) {\n\t\t\terr = fops->add_slave(sl);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&sl->dev,\n\t\t\t\t\t\"add_slave() call failed. err=%d\\n\",\n\t\t\t\t\terr);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (fops->groups) {\n\t\t\terr = sysfs_create_groups(&sl->dev.kobj, fops->groups);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&sl->dev,\n\t\t\t\t\t\"sysfs group creation failed. err=%d\\n\",\n\t\t\t\t\terr);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (IS_REACHABLE(CONFIG_HWMON) && fops->chip_info) {\n\t\t\tstruct device *hwmon\n\t\t\t\t= hwmon_device_register_with_info(&sl->dev,\n\t\t\t\t\t\t\"w1_slave_temp\", sl,\n\t\t\t\t\t\tfops->chip_info,\n\t\t\t\t\t\tNULL);\n\t\t\tif (IS_ERR(hwmon)) {\n\t\t\t\tdev_warn(&sl->dev,\n\t\t\t\t\t \"could not create hwmon device\\n\");\n\t\t\t} else {\n\t\t\t\tsl->hwmon = hwmon;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tif (IS_REACHABLE(CONFIG_HWMON) && fops->chip_info &&\n\t\t\t    sl->hwmon)\n\t\t\thwmon_device_unregister(sl->hwmon);\n\t\tif (fops->remove_slave)\n\t\t\tsl->family->fops->remove_slave(sl);\n\t\tif (fops->groups)\n\t\t\tsysfs_remove_groups(&sl->dev.kobj, fops->groups);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int __w1_attach_slave_device(struct w1_slave *sl)\n{\n\tint err;\n\n\tsl->dev.parent = &sl->master->dev;\n\tsl->dev.driver = &w1_slave_driver;\n\tsl->dev.bus = &w1_bus_type;\n\tsl->dev.release = &w1_slave_release;\n\tsl->dev.groups = w1_slave_groups;\n\tsl->dev.of_node = of_find_matching_node(sl->master->dev.of_node,\n\t\t\t\t\t\tsl->family->of_match_table);\n\n\tdev_set_name(&sl->dev, \"%02x-%012llx\",\n\t\t (unsigned int) sl->reg_num.family,\n\t\t (unsigned long long) sl->reg_num.id);\n\tsnprintf(&sl->name[0], sizeof(sl->name),\n\t\t \"%02x-%012llx\",\n\t\t (unsigned int) sl->reg_num.family,\n\t\t (unsigned long long) sl->reg_num.id);\n\n\tdev_dbg(&sl->dev, \"%s: registering %s as %p.\\n\", __func__,\n\t\tdev_name(&sl->dev), sl);\n\n\t \n\tdev_set_uevent_suppress(&sl->dev, true);\n\n\terr = device_register(&sl->dev);\n\tif (err < 0) {\n\t\tdev_err(&sl->dev,\n\t\t\t\"Device registration [%s] failed. err=%d\\n\",\n\t\t\tdev_name(&sl->dev), err);\n\t\tof_node_put(sl->dev.of_node);\n\t\tput_device(&sl->dev);\n\t\treturn err;\n\t}\n\tw1_family_notify(BUS_NOTIFY_ADD_DEVICE, sl);\n\n\tdev_set_uevent_suppress(&sl->dev, false);\n\tkobject_uevent(&sl->dev.kobj, KOBJ_ADD);\n\n\tmutex_lock(&sl->master->list_mutex);\n\tlist_add_tail(&sl->w1_slave_entry, &sl->master->slist);\n\tmutex_unlock(&sl->master->list_mutex);\n\n\treturn 0;\n}\n\nint w1_attach_slave_device(struct w1_master *dev, struct w1_reg_num *rn)\n{\n\tstruct w1_slave *sl;\n\tstruct w1_family *f;\n\tint err;\n\tstruct w1_netlink_msg msg;\n\n\tsl = kzalloc(sizeof(struct w1_slave), GFP_KERNEL);\n\tif (!sl) {\n\t\tdev_err(&dev->dev,\n\t\t\t \"%s: failed to allocate new slave device.\\n\",\n\t\t\t __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tsl->owner = THIS_MODULE;\n\tsl->master = dev;\n\tset_bit(W1_SLAVE_ACTIVE, &sl->flags);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmemcpy(&sl->reg_num, rn, sizeof(sl->reg_num));\n\tatomic_set(&sl->refcnt, 1);\n\tatomic_inc(&sl->master->refcnt);\n\tdev->slave_count++;\n\tdev_info(&dev->dev, \"Attaching one wire slave %02x.%012llx crc %02x\\n\",\n\t\t  rn->family, (unsigned long long)rn->id, rn->crc);\n\n\t \n\tmutex_unlock(&dev->mutex);\n\trequest_module(\"w1-family-0x%02X\", rn->family);\n\tmutex_lock(&dev->mutex);\n\n\tspin_lock(&w1_flock);\n\tf = w1_family_registered(rn->family);\n\tif (!f) {\n\t\tf= &w1_default_family;\n\t\tdev_info(&dev->dev, \"Family %x for %02x.%012llx.%02x is not registered.\\n\",\n\t\t\t  rn->family, rn->family,\n\t\t\t  (unsigned long long)rn->id, rn->crc);\n\t}\n\t__w1_family_get(f);\n\tspin_unlock(&w1_flock);\n\n\tsl->family = f;\n\n\terr = __w1_attach_slave_device(sl);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"%s: Attaching %s failed.\\n\", __func__,\n\t\t\t sl->name);\n\t\tdev->slave_count--;\n\t\tw1_family_put(sl->family);\n\t\tatomic_dec(&sl->master->refcnt);\n\t\tkfree(sl);\n\t\treturn err;\n\t}\n\n\tsl->ttl = dev->slave_ttl;\n\n\tmemcpy(msg.id.id, rn, sizeof(msg.id));\n\tmsg.type = W1_SLAVE_ADD;\n\tw1_netlink_send(dev, &msg);\n\n\treturn 0;\n}\n\nint w1_unref_slave(struct w1_slave *sl)\n{\n\tstruct w1_master *dev = sl->master;\n\tint refcnt;\n\tmutex_lock(&dev->list_mutex);\n\trefcnt = atomic_sub_return(1, &sl->refcnt);\n\tif (refcnt == 0) {\n\t\tstruct w1_netlink_msg msg;\n\n\t\tdev_dbg(&sl->dev, \"%s: detaching %s [%p].\\n\", __func__,\n\t\t\tsl->name, sl);\n\n\t\tlist_del(&sl->w1_slave_entry);\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmemcpy(msg.id.id, &sl->reg_num, sizeof(msg.id));\n\t\tmsg.type = W1_SLAVE_REMOVE;\n\t\tw1_netlink_send(sl->master, &msg);\n\n\t\tw1_family_notify(BUS_NOTIFY_DEL_DEVICE, sl);\n\t\tdevice_unregister(&sl->dev);\n\t\t#ifdef DEBUG\n\t\tmemset(sl, 0, sizeof(*sl));\n\t\t#endif\n\t\tkfree(sl);\n\t}\n\tatomic_dec(&dev->refcnt);\n\tmutex_unlock(&dev->list_mutex);\n\treturn refcnt;\n}\n\nint w1_slave_detach(struct w1_slave *sl)\n{\n\t \n\tint destroy_now;\n\tmutex_lock(&sl->master->list_mutex);\n\tdestroy_now = !test_bit(W1_SLAVE_DETACH, &sl->flags);\n\tset_bit(W1_SLAVE_DETACH, &sl->flags);\n\tmutex_unlock(&sl->master->list_mutex);\n\n\tif (destroy_now)\n\t\tdestroy_now = !w1_unref_slave(sl);\n\treturn destroy_now ? 0 : -EBUSY;\n}\n\nstruct w1_master *w1_search_master_id(u32 id)\n{\n\tstruct w1_master *dev = NULL, *iter;\n\n\tmutex_lock(&w1_mlock);\n\tlist_for_each_entry(iter, &w1_masters, w1_master_entry) {\n\t\tif (iter->id == id) {\n\t\t\tdev = iter;\n\t\t\tatomic_inc(&iter->refcnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&w1_mlock);\n\n\treturn dev;\n}\n\nstruct w1_slave *w1_search_slave(struct w1_reg_num *id)\n{\n\tstruct w1_master *dev;\n\tstruct w1_slave *sl = NULL, *iter;\n\n\tmutex_lock(&w1_mlock);\n\tlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\n\t\tmutex_lock(&dev->list_mutex);\n\t\tlist_for_each_entry(iter, &dev->slist, w1_slave_entry) {\n\t\t\tif (iter->reg_num.family == id->family &&\n\t\t\t    iter->reg_num.id == id->id &&\n\t\t\t    iter->reg_num.crc == id->crc) {\n\t\t\t\tsl = iter;\n\t\t\t\tatomic_inc(&dev->refcnt);\n\t\t\t\tatomic_inc(&iter->refcnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dev->list_mutex);\n\n\t\tif (sl)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&w1_mlock);\n\n\treturn sl;\n}\n\nvoid w1_reconnect_slaves(struct w1_family *f, int attach)\n{\n\tstruct w1_slave *sl, *sln;\n\tstruct w1_master *dev;\n\n\tmutex_lock(&w1_mlock);\n\tlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\n\t\tdev_dbg(&dev->dev, \"Reconnecting slaves in device %s \"\n\t\t\t\"for family %02x.\\n\", dev->name, f->fid);\n\t\tmutex_lock(&dev->mutex);\n\t\tmutex_lock(&dev->list_mutex);\n\t\tlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {\n\t\t\t \n\t\t\tif ((attach && sl->family->fid == W1_FAMILY_DEFAULT\n\t\t\t\t&& sl->reg_num.family == f->fid) ||\n\t\t\t\t(!attach && sl->family->fid == f->fid)) {\n\t\t\t\tstruct w1_reg_num rn;\n\n\t\t\t\tmutex_unlock(&dev->list_mutex);\n\t\t\t\tmemcpy(&rn, &sl->reg_num, sizeof(rn));\n\t\t\t\t \n\t\t\t\tif (!w1_slave_detach(sl))\n\t\t\t\t\tw1_attach_slave_device(dev, &rn);\n\t\t\t\tmutex_lock(&dev->list_mutex);\n\t\t\t}\n\t\t}\n\t\tdev_dbg(&dev->dev, \"Reconnecting slaves in device %s \"\n\t\t\t\"has been finished.\\n\", dev->name);\n\t\tmutex_unlock(&dev->list_mutex);\n\t\tmutex_unlock(&dev->mutex);\n\t}\n\tmutex_unlock(&w1_mlock);\n}\n\nstatic int w1_addr_crc_is_valid(struct w1_master *dev, u64 rn)\n{\n\tu64 rn_le = cpu_to_le64(rn);\n\tstruct w1_reg_num *tmp = (struct w1_reg_num *)&rn;\n\tu8 crc;\n\n\tcrc = w1_calc_crc8((u8 *)&rn_le, 7);\n\n\t \n\tif (crc != tmp->crc && tmp->family == W1_FAMILY_DS28E04) {\n\t\tu64 corr_le = rn_le;\n\n\t\t((u8 *)&corr_le)[1] |= 0x7f;\n\t\tcrc = w1_calc_crc8((u8 *)&corr_le, 7);\n\n\t\tdev_info(&dev->dev, \"DS28E04 crc workaround on %02x.%012llx.%02x\\n\",\n\t\t\ttmp->family, (unsigned long long)tmp->id, tmp->crc);\n\t}\n\n\tif (crc != tmp->crc) {\n\t\tdev_dbg(&dev->dev, \"w1 addr crc mismatch: %02x.%012llx.%02x != 0x%02x.\\n\",\n\t\t\ttmp->family, (unsigned long long)tmp->id, tmp->crc, crc);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid w1_slave_found(struct w1_master *dev, u64 rn)\n{\n\tstruct w1_slave *sl;\n\tstruct w1_reg_num *tmp;\n\n\tatomic_inc(&dev->refcnt);\n\n\ttmp = (struct w1_reg_num *) &rn;\n\n\tsl = w1_slave_search_device(dev, tmp);\n\tif (sl) {\n\t\tset_bit(W1_SLAVE_ACTIVE, &sl->flags);\n\t} else {\n\t\tif (rn && w1_addr_crc_is_valid(dev, rn))\n\t\t\tw1_attach_slave_device(dev, tmp);\n\t}\n\n\tatomic_dec(&dev->refcnt);\n}\n\n \nvoid w1_search(struct w1_master *dev, u8 search_type, w1_slave_found_callback cb)\n{\n\tu64 last_rn, rn, tmp64;\n\tint i, slave_count = 0;\n\tint last_zero, last_device;\n\tint search_bit, desc_bit;\n\tu8  triplet_ret = 0;\n\n\tsearch_bit = 0;\n\trn = dev->search_id;\n\tlast_rn = 0;\n\tlast_device = 0;\n\tlast_zero = -1;\n\n\tdesc_bit = 64;\n\n\twhile ( !last_device && (slave_count++ < dev->max_slave_count) ) {\n\t\tlast_rn = rn;\n\t\trn = 0;\n\n\t\t \n\t\tmutex_lock(&dev->bus_mutex);\n\t\tif (w1_reset_bus(dev)) {\n\t\t\tmutex_unlock(&dev->bus_mutex);\n\t\t\tdev_dbg(&dev->dev, \"No devices present on the wire.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dev->max_slave_count == 1) {\n\t\t\tint rv;\n\t\t\tw1_write_8(dev, W1_READ_ROM);\n\t\t\trv = w1_read_block(dev, (u8 *)&rn, 8);\n\t\t\tmutex_unlock(&dev->bus_mutex);\n\n\t\t\tif (rv == 8 && rn)\n\t\t\t\tcb(dev, rn);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tw1_write_8(dev, search_type);\n\t\tfor (i = 0; i < 64; ++i) {\n\t\t\t \n\t\t\tif (i == desc_bit)\n\t\t\t\tsearch_bit = 1;\t   \n\t\t\telse if (i > desc_bit)\n\t\t\t\tsearch_bit = 0;\t   \n\t\t\telse\n\t\t\t\tsearch_bit = ((last_rn >> i) & 0x1);\n\n\t\t\t \n\t\t\ttriplet_ret = w1_triplet(dev, search_bit);\n\n\t\t\t \n\t\t\tif ( (triplet_ret & 0x03) == 0x03 )\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (triplet_ret == 0)\n\t\t\t\tlast_zero = i;\n\n\t\t\t \n\t\t\ttmp64 = (triplet_ret >> 2);\n\t\t\trn |= (tmp64 << i);\n\n\t\t\tif (test_bit(W1_ABORT_SEARCH, &dev->flags)) {\n\t\t\t\tmutex_unlock(&dev->bus_mutex);\n\t\t\t\tdev_dbg(&dev->dev, \"Abort w1_search\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dev->bus_mutex);\n\n\t\tif ( (triplet_ret & 0x03) != 0x03 ) {\n\t\t\tif ((desc_bit == last_zero) || (last_zero < 0)) {\n\t\t\t\tlast_device = 1;\n\t\t\t\tdev->search_id = 0;\n\t\t\t} else {\n\t\t\t\tdev->search_id = rn;\n\t\t\t}\n\t\t\tdesc_bit = last_zero;\n\t\t\tcb(dev, rn);\n\t\t}\n\n\t\tif (!last_device && slave_count == dev->max_slave_count &&\n\t\t\t!test_bit(W1_WARN_MAX_COUNT, &dev->flags)) {\n\t\t\t \n\t\t\tdev_info(&dev->dev, \"%s: max_slave_count %d reached, \"\n\t\t\t\t\"will continue next search.\\n\", __func__,\n\t\t\t\tdev->max_slave_count);\n\t\t\tset_bit(W1_WARN_MAX_COUNT, &dev->flags);\n\t\t}\n\t}\n}\n\nvoid w1_search_process_cb(struct w1_master *dev, u8 search_type,\n\tw1_slave_found_callback cb)\n{\n\tstruct w1_slave *sl, *sln;\n\n\tmutex_lock(&dev->list_mutex);\n\tlist_for_each_entry(sl, &dev->slist, w1_slave_entry)\n\t\tclear_bit(W1_SLAVE_ACTIVE, &sl->flags);\n\tmutex_unlock(&dev->list_mutex);\n\n\tw1_search_devices(dev, search_type, cb);\n\n\tmutex_lock(&dev->list_mutex);\n\tlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {\n\t\tif (!test_bit(W1_SLAVE_ACTIVE, &sl->flags) && !--sl->ttl) {\n\t\t\tmutex_unlock(&dev->list_mutex);\n\t\t\tw1_slave_detach(sl);\n\t\t\tmutex_lock(&dev->list_mutex);\n\t\t}\n\t\telse if (test_bit(W1_SLAVE_ACTIVE, &sl->flags))\n\t\t\tsl->ttl = dev->slave_ttl;\n\t}\n\tmutex_unlock(&dev->list_mutex);\n\n\tif (dev->search_count > 0)\n\t\tdev->search_count--;\n}\n\nstatic void w1_search_process(struct w1_master *dev, u8 search_type)\n{\n\tw1_search_process_cb(dev, search_type, w1_slave_found);\n}\n\n \nint w1_process_callbacks(struct w1_master *dev)\n{\n\tint ret = 0;\n\tstruct w1_async_cmd *async_cmd, *async_n;\n\n\t \n\twhile (!list_empty(&dev->async_list)) {\n\t\tlist_for_each_entry_safe(async_cmd, async_n, &dev->async_list,\n\t\t\tasync_entry) {\n\t\t\t \n\t\t\tmutex_unlock(&dev->list_mutex);\n\t\t\tasync_cmd->cb(dev, async_cmd);\n\t\t\tret = 1;\n\t\t\tmutex_lock(&dev->list_mutex);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint w1_process(void *data)\n{\n\tstruct w1_master *dev = (struct w1_master *) data;\n\t \n\tconst unsigned long jtime =\n\t  usecs_to_jiffies(w1_timeout * 1000000 + w1_timeout_us);\n\t \n\tunsigned long jremain = 0;\n\n\tatomic_inc(&dev->refcnt);\n\n\tfor (;;) {\n\n\t\tif (!jremain && dev->search_count) {\n\t\t\tmutex_lock(&dev->mutex);\n\t\t\tw1_search_process(dev, W1_SEARCH);\n\t\t\tmutex_unlock(&dev->mutex);\n\t\t}\n\n\t\tmutex_lock(&dev->list_mutex);\n\t\t \n\t\tif (!w1_process_callbacks(dev) && jremain) {\n\t\t\t \n\t\t\tjremain = 1;\n\t\t}\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\t \n\t\tmutex_unlock(&dev->list_mutex);\n\n\t\tif (kthread_should_stop()) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dev->search_count) {\n\t\t\tif (!jremain)\n\t\t\t\tjremain = jtime;\n\t\t\tjremain = schedule_timeout(jremain);\n\t\t}\n\t\telse\n\t\t\tschedule();\n\t}\n\n\tatomic_dec(&dev->refcnt);\n\n\treturn 0;\n}\n\nstatic int __init w1_init(void)\n{\n\tint retval;\n\n\tpr_info(\"Driver for 1-wire Dallas network protocol.\\n\");\n\n\tw1_init_netlink();\n\n\tretval = bus_register(&w1_bus_type);\n\tif (retval) {\n\t\tpr_err(\"Failed to register bus. err=%d.\\n\", retval);\n\t\tgoto err_out_exit_init;\n\t}\n\n\tretval = driver_register(&w1_master_driver);\n\tif (retval) {\n\t\tpr_err(\"Failed to register master driver. err=%d.\\n\",\n\t\t\tretval);\n\t\tgoto err_out_bus_unregister;\n\t}\n\n\tretval = driver_register(&w1_slave_driver);\n\tif (retval) {\n\t\tpr_err(\"Failed to register slave driver. err=%d.\\n\",\n\t\t\tretval);\n\t\tgoto err_out_master_unregister;\n\t}\n\n\treturn 0;\n\n#if 0\n \nerr_out_slave_unregister:\n\tdriver_unregister(&w1_slave_driver);\n#endif\n\nerr_out_master_unregister:\n\tdriver_unregister(&w1_master_driver);\n\nerr_out_bus_unregister:\n\tbus_unregister(&w1_bus_type);\n\nerr_out_exit_init:\n\treturn retval;\n}\n\nstatic void __exit w1_fini(void)\n{\n\tstruct w1_master *dev, *n;\n\n\t \n\tlist_for_each_entry_safe(dev, n, &w1_masters, w1_master_entry)\n\t\t__w1_remove_master_device(dev);\n\n\tw1_fini_netlink();\n\n\tdriver_unregister(&w1_slave_driver);\n\tdriver_unregister(&w1_master_driver);\n\tbus_unregister(&w1_bus_type);\n}\n\nmodule_init(w1_init);\nmodule_exit(w1_fini);\n\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"Driver for 1-wire Dallas network protocol.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}