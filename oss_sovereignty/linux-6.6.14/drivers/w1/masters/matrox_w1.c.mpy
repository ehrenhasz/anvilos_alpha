{
  "module_name": "matrox_w1.c",
  "hash_id": "b586979385fd9a580a635f6b34cdc882a14c8b7adf874b298d358c9daccb7542",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/matrox_w1.c",
  "human_readable_source": "\n \n\n#include <asm/types.h>\n#include <linux/atomic.h>\n#include <linux/io.h>\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/pci_ids.h>\n#include <linux/pci.h>\n\n#include <linux/w1.h>\n\n \n\n#define MATROX_G400_DDC_CLK\t\t(1<<4)\n#define MATROX_G400_DDC_DATA\t\t(1<<1)\n\n#define MATROX_BASE\t\t\t0x3C00\n#define MATROX_STATUS\t\t\t0x1e14\n\n#define MATROX_PORT_INDEX_OFFSET\t0x00\n#define MATROX_PORT_DATA_OFFSET\t\t0x0A\n\n#define MATROX_GET_CONTROL\t\t0x2A\n#define MATROX_GET_DATA\t\t\t0x2B\n#define MATROX_CURSOR_CTL\t\t0x06\n\nstruct matrox_device {\n\tvoid __iomem *base_addr;\n\tvoid __iomem *port_index;\n\tvoid __iomem *port_data;\n\tu8 data_mask;\n\n\tunsigned long phys_addr;\n\tvoid __iomem *virt_addr;\n\tunsigned long found;\n\n\tstruct w1_bus_master *bus_master;\n};\n\n \nstatic inline u8 matrox_w1_read_reg(struct matrox_device *dev, u8 reg)\n{\n\tu8 ret;\n\n\twriteb(reg, dev->port_index);\n\tret = readb(dev->port_data);\n\tbarrier();\n\n\treturn ret;\n}\n\nstatic inline void matrox_w1_write_reg(struct matrox_device *dev, u8 reg, u8 val)\n{\n\twriteb(reg, dev->port_index);\n\twriteb(val, dev->port_data);\n\twmb();\n}\n\nstatic void matrox_w1_write_ddc_bit(void *data, u8 bit)\n{\n\tu8 ret;\n\tstruct matrox_device *dev = data;\n\n\tif (bit)\n\t\tbit = 0;\n\telse\n\t\tbit = dev->data_mask;\n\n\tret = matrox_w1_read_reg(dev, MATROX_GET_CONTROL);\n\tmatrox_w1_write_reg(dev, MATROX_GET_CONTROL, ((ret & ~dev->data_mask) | bit));\n\tmatrox_w1_write_reg(dev, MATROX_GET_DATA, 0x00);\n}\n\nstatic u8 matrox_w1_read_ddc_bit(void *data)\n{\n\tu8 ret;\n\tstruct matrox_device *dev = data;\n\n\tret = matrox_w1_read_reg(dev, MATROX_GET_DATA);\n\n\treturn ret;\n}\n\nstatic void matrox_w1_hw_init(struct matrox_device *dev)\n{\n\tmatrox_w1_write_reg(dev, MATROX_GET_DATA, 0xFF);\n\tmatrox_w1_write_reg(dev, MATROX_GET_CONTROL, 0x00);\n}\n\nstatic int matrox_w1_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct matrox_device *dev;\n\tint err;\n\n\tif (pdev->vendor != PCI_VENDOR_ID_MATROX || pdev->device != PCI_DEVICE_ID_MATROX_G400)\n\t\treturn -ENODEV;\n\n\tdev = kzalloc(sizeof(struct matrox_device) +\n\t\t       sizeof(struct w1_bus_master), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->bus_master = (struct w1_bus_master *)(dev + 1);\n\n\t \n\n\tdev->phys_addr = pci_resource_start(pdev, 1);\n\n\tdev->virt_addr = ioremap(dev->phys_addr, 16384);\n\tif (!dev->virt_addr) {\n\t\tdev_err(&pdev->dev, \"%s: failed to ioremap(0x%lx, %d).\\n\",\n\t\t\t__func__, dev->phys_addr, 16384);\n\t\terr = -EIO;\n\t\tgoto err_out_free_device;\n\t}\n\n\tdev->base_addr = dev->virt_addr + MATROX_BASE;\n\tdev->port_index = dev->base_addr + MATROX_PORT_INDEX_OFFSET;\n\tdev->port_data = dev->base_addr + MATROX_PORT_DATA_OFFSET;\n\tdev->data_mask = (MATROX_G400_DDC_DATA);\n\n\tmatrox_w1_hw_init(dev);\n\n\tdev->bus_master->data = dev;\n\tdev->bus_master->read_bit = &matrox_w1_read_ddc_bit;\n\tdev->bus_master->write_bit = &matrox_w1_write_ddc_bit;\n\n\terr = w1_add_master_device(dev->bus_master);\n\tif (err)\n\t\tgoto err_out_free_device;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tdev->found = 1;\n\n\tdev_info(&pdev->dev, \"Matrox G400 GPIO transport layer for 1-wire.\\n\");\n\n\treturn 0;\n\nerr_out_free_device:\n\tif (dev->virt_addr)\n\t\tiounmap(dev->virt_addr);\n\tkfree(dev);\n\n\treturn err;\n}\n\nstatic void matrox_w1_remove(struct pci_dev *pdev)\n{\n\tstruct matrox_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev->found) {\n\t\tw1_remove_master_device(dev->bus_master);\n\t\tiounmap(dev->virt_addr);\n\t}\n\tkfree(dev);\n}\n\nstatic struct pci_device_id matrox_w1_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MATROX, PCI_DEVICE_ID_MATROX_G400) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, matrox_w1_tbl);\n\nstatic struct pci_driver matrox_w1_pci_driver = {\n\t.name = \"matrox_w1\",\n\t.id_table = matrox_w1_tbl,\n\t.probe = matrox_w1_probe,\n\t.remove = matrox_w1_remove,\n};\nmodule_pci_driver(matrox_w1_pci_driver);\n\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"Driver for transport(Dallas 1-wire protocol) over VGA DDC(matrox gpio).\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}