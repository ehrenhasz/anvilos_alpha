{
  "module_name": "ds2482.c",
  "hash_id": "693a758f84cee3256a580021775479c7480cc0edb4c94df2227c6610f938fd5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/ds2482.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n\n#include <linux/w1.h>\n\n \nstatic int ds2482_active_pullup = 1;\nmodule_param_named(active_pullup, ds2482_active_pullup, int, 0644);\nMODULE_PARM_DESC(active_pullup, \"Active pullup (apply to all buses): \" \\\n\t\t\t\t\"0-disable, 1-enable (default)\");\n\n \nstatic int extra_config;\nmodule_param(extra_config, int, 0644);\nMODULE_PARM_DESC(extra_config, \"Extra Configuration settings 1=APU,2=PPM,3=SPU,8=1WS\");\n\n \n#define DS2482_CMD_RESET\t\t0xF0\t \n#define DS2482_CMD_SET_READ_PTR\t\t0xE1\t \n#define DS2482_CMD_CHANNEL_SELECT\t0xC3\t \n#define DS2482_CMD_WRITE_CONFIG\t\t0xD2\t \n#define DS2482_CMD_1WIRE_RESET\t\t0xB4\t \n#define DS2482_CMD_1WIRE_SINGLE_BIT\t0x87\t \n#define DS2482_CMD_1WIRE_WRITE_BYTE\t0xA5\t \n#define DS2482_CMD_1WIRE_READ_BYTE\t0x96\t \n \n#define DS2482_CMD_1WIRE_TRIPLET\t0x78\t \n\n \n#define DS2482_PTR_CODE_STATUS\t\t0xF0\n#define DS2482_PTR_CODE_DATA\t\t0xE1\n#define DS2482_PTR_CODE_CHANNEL\t\t0xD2\t \n#define DS2482_PTR_CODE_CONFIG\t\t0xC3\n\n \n#define DS2482_REG_CFG_1WS\t\t0x08\t \n#define DS2482_REG_CFG_SPU\t\t0x04\t \n#define DS2482_REG_CFG_PPM\t\t0x02\t \n#define DS2482_REG_CFG_APU\t\t0x01\t \n\n\n \nstatic const u8 ds2482_chan_wr[8] = { 0xF0, 0xE1, 0xD2, 0xC3, 0xB4, 0xA5, 0x96, 0x87 };\nstatic const u8 ds2482_chan_rd[8] = { 0xB8, 0xB1, 0xAA, 0xA3, 0x9C, 0x95, 0x8E, 0x87 };\n\n\n \n#define DS2482_REG_STS_DIR\t\t0x80\n#define DS2482_REG_STS_TSB\t\t0x40\n#define DS2482_REG_STS_SBR\t\t0x20\n#define DS2482_REG_STS_RST\t\t0x10\n#define DS2482_REG_STS_LL\t\t0x08\n#define DS2482_REG_STS_SD\t\t0x04\n#define DS2482_REG_STS_PPD\t\t0x02\n#define DS2482_REG_STS_1WB\t\t0x01\n\n \n\nstruct ds2482_data;\n\nstruct ds2482_w1_chan {\n\tstruct ds2482_data\t*pdev;\n\tu8\t\t\tchannel;\n\tstruct w1_bus_master\tw1_bm;\n};\n\nstruct ds2482_data {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\taccess_lock;\n\n\t \n\tint\t\t\tw1_count;\t \n\tstruct ds2482_w1_chan\tw1_ch[8];\n\n\t \n\tu8\t\t\tchannel;\n\tu8\t\t\tread_prt;\t \n\tu8\t\t\treg_config;\n};\n\n\n \nstatic inline u8 ds2482_calculate_config(u8 conf)\n{\n\tconf |= extra_config;\n\n\tif (ds2482_active_pullup)\n\t\tconf |= DS2482_REG_CFG_APU;\n\n\treturn conf | ((~conf & 0x0f) << 4);\n}\n\n\n \nstatic inline int ds2482_select_register(struct ds2482_data *pdev, u8 read_ptr)\n{\n\tif (pdev->read_prt != read_ptr) {\n\t\tif (i2c_smbus_write_byte_data(pdev->client,\n\t\t\t\t\t      DS2482_CMD_SET_READ_PTR,\n\t\t\t\t\t      read_ptr) < 0)\n\t\t\treturn -1;\n\n\t\tpdev->read_prt = read_ptr;\n\t}\n\treturn 0;\n}\n\n \nstatic inline int ds2482_send_cmd(struct ds2482_data *pdev, u8 cmd)\n{\n\tif (i2c_smbus_write_byte(pdev->client, cmd) < 0)\n\t\treturn -1;\n\n\tpdev->read_prt = DS2482_PTR_CODE_STATUS;\n\treturn 0;\n}\n\n \nstatic inline int ds2482_send_cmd_data(struct ds2482_data *pdev,\n\t\t\t\t       u8 cmd, u8 byte)\n{\n\tif (i2c_smbus_write_byte_data(pdev->client, cmd, byte) < 0)\n\t\treturn -1;\n\n\t \n\tpdev->read_prt = (cmd != DS2482_CMD_WRITE_CONFIG) ?\n\t\t\t DS2482_PTR_CODE_STATUS : DS2482_PTR_CODE_CONFIG;\n\treturn 0;\n}\n\n\n \n\n#define DS2482_WAIT_IDLE_TIMEOUT\t100\n\n \nstatic int ds2482_wait_1wire_idle(struct ds2482_data *pdev)\n{\n\tint temp = -1;\n\tint retries = 0;\n\n\tif (!ds2482_select_register(pdev, DS2482_PTR_CODE_STATUS)) {\n\t\tdo {\n\t\t\ttemp = i2c_smbus_read_byte(pdev->client);\n\t\t} while ((temp >= 0) && (temp & DS2482_REG_STS_1WB) &&\n\t\t\t (++retries < DS2482_WAIT_IDLE_TIMEOUT));\n\t}\n\n\tif (retries >= DS2482_WAIT_IDLE_TIMEOUT)\n\t\tpr_err(\"%s: timeout on channel %d\\n\",\n\t\t       __func__, pdev->channel);\n\n\treturn temp;\n}\n\n \nstatic int ds2482_set_channel(struct ds2482_data *pdev, u8 channel)\n{\n\tif (i2c_smbus_write_byte_data(pdev->client, DS2482_CMD_CHANNEL_SELECT,\n\t\t\t\t      ds2482_chan_wr[channel]) < 0)\n\t\treturn -1;\n\n\tpdev->read_prt = DS2482_PTR_CODE_CHANNEL;\n\tpdev->channel = -1;\n\tif (i2c_smbus_read_byte(pdev->client) == ds2482_chan_rd[channel]) {\n\t\tpdev->channel = channel;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\n \nstatic u8 ds2482_w1_touch_bit(void *data, u8 bit)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\tint status = -1;\n\n\tmutex_lock(&pdev->access_lock);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\tif (pdev->w1_count > 1)\n\t\tds2482_set_channel(pdev, pchan->channel);\n\n\t \n\tif (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_SINGLE_BIT,\n\t\t\t\t  bit ? 0xFF : 0))\n\t\tstatus = ds2482_wait_1wire_idle(pdev);\n\n\tmutex_unlock(&pdev->access_lock);\n\n\treturn (status & DS2482_REG_STS_SBR) ? 1 : 0;\n}\n\n \nstatic u8 ds2482_w1_triplet(void *data, u8 dbit)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\tint status = (3 << 5);\n\n\tmutex_lock(&pdev->access_lock);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\tif (pdev->w1_count > 1)\n\t\tds2482_set_channel(pdev, pchan->channel);\n\n\t \n\tif (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_TRIPLET,\n\t\t\t\t  dbit ? 0xFF : 0))\n\t\tstatus = ds2482_wait_1wire_idle(pdev);\n\n\tmutex_unlock(&pdev->access_lock);\n\n\t \n\treturn (status >> 5);\n}\n\n \nstatic void ds2482_w1_write_byte(void *data, u8 byte)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\n\tmutex_lock(&pdev->access_lock);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\tif (pdev->w1_count > 1)\n\t\tds2482_set_channel(pdev, pchan->channel);\n\n\t \n\tds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_WRITE_BYTE, byte);\n\n\tmutex_unlock(&pdev->access_lock);\n}\n\n \nstatic u8 ds2482_w1_read_byte(void *data)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\tint result;\n\n\tmutex_lock(&pdev->access_lock);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\tif (pdev->w1_count > 1)\n\t\tds2482_set_channel(pdev, pchan->channel);\n\n\t \n\tds2482_send_cmd(pdev, DS2482_CMD_1WIRE_READ_BYTE);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\n\t \n\tds2482_select_register(pdev, DS2482_PTR_CODE_DATA);\n\n\t \n\tresult = i2c_smbus_read_byte(pdev->client);\n\n\tmutex_unlock(&pdev->access_lock);\n\n\treturn result;\n}\n\n\n \nstatic u8 ds2482_w1_reset_bus(void *data)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\tint err;\n\tu8 retval = 1;\n\n\tmutex_lock(&pdev->access_lock);\n\n\t \n\tds2482_wait_1wire_idle(pdev);\n\tif (pdev->w1_count > 1)\n\t\tds2482_set_channel(pdev, pchan->channel);\n\n\t \n\terr = ds2482_send_cmd(pdev, DS2482_CMD_1WIRE_RESET);\n\tif (err >= 0) {\n\t\t \n\t\terr = ds2482_wait_1wire_idle(pdev);\n\t\tretval = !(err & DS2482_REG_STS_PPD);\n\n\t\t \n\t\tif (err & DS2482_REG_STS_RST)\n\t\t\tds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,\n\t\t\t\t\t     ds2482_calculate_config(0x00));\n\t}\n\n\tmutex_unlock(&pdev->access_lock);\n\n\treturn retval;\n}\n\nstatic u8 ds2482_w1_set_pullup(void *data, int delay)\n{\n\tstruct ds2482_w1_chan *pchan = data;\n\tstruct ds2482_data    *pdev = pchan->pdev;\n\tu8 retval = 1;\n\n\t \n\tif (delay) {\n\t\t \n\t\tds2482_wait_1wire_idle(pdev);\n\t\t \n\t\tretval = ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,\n\t\t\tds2482_calculate_config(DS2482_REG_CFG_SPU |\n\t\t\t\t\t\tDS2482_REG_CFG_APU));\n\t\tds2482_wait_1wire_idle(pdev);\n\t}\n\n\treturn retval;\n}\n\n\nstatic int ds2482_probe(struct i2c_client *client)\n{\n\tstruct ds2482_data *data;\n\tint err = -ENODEV;\n\tint temp1;\n\tint idx;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE))\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(struct ds2482_data), GFP_KERNEL);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\t \n\tif (ds2482_send_cmd(data, DS2482_CMD_RESET) < 0) {\n\t\tdev_warn(&client->dev, \"DS2482 reset failed.\\n\");\n\t\tgoto exit_free;\n\t}\n\n\t \n\tndelay(525);\n\n\t \n\ttemp1 = i2c_smbus_read_byte(client);\n\tif (temp1 != (DS2482_REG_STS_LL | DS2482_REG_STS_RST)) {\n\t\tdev_warn(&client->dev, \"DS2482 reset status \"\n\t\t\t \"0x%02X - not a DS2482\\n\", temp1);\n\t\tgoto exit_free;\n\t}\n\n\t \n\tdata->w1_count = 1;\n\tif (ds2482_set_channel(data, 7) == 0)\n\t\tdata->w1_count = 8;\n\n\t \n\tds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG,\n\t\tds2482_calculate_config(0x00));\n\n\tmutex_init(&data->access_lock);\n\n\t \n\tfor (idx = 0; idx < data->w1_count; idx++) {\n\t\tdata->w1_ch[idx].pdev = data;\n\t\tdata->w1_ch[idx].channel = idx;\n\n\t\t \n\t\tdata->w1_ch[idx].w1_bm.data       = &data->w1_ch[idx];\n\t\tdata->w1_ch[idx].w1_bm.read_byte  = ds2482_w1_read_byte;\n\t\tdata->w1_ch[idx].w1_bm.write_byte = ds2482_w1_write_byte;\n\t\tdata->w1_ch[idx].w1_bm.touch_bit  = ds2482_w1_touch_bit;\n\t\tdata->w1_ch[idx].w1_bm.triplet    = ds2482_w1_triplet;\n\t\tdata->w1_ch[idx].w1_bm.reset_bus  = ds2482_w1_reset_bus;\n\t\tdata->w1_ch[idx].w1_bm.set_pullup = ds2482_w1_set_pullup;\n\n\t\terr = w1_add_master_device(&data->w1_ch[idx].w1_bm);\n\t\tif (err) {\n\t\t\tdata->w1_ch[idx].pdev = NULL;\n\t\t\tgoto exit_w1_remove;\n\t\t}\n\t}\n\n\treturn 0;\n\nexit_w1_remove:\n\tfor (idx = 0; idx < data->w1_count; idx++) {\n\t\tif (data->w1_ch[idx].pdev != NULL)\n\t\t\tw1_remove_master_device(&data->w1_ch[idx].w1_bm);\n\t}\nexit_free:\n\tkfree(data);\nexit:\n\treturn err;\n}\n\nstatic void ds2482_remove(struct i2c_client *client)\n{\n\tstruct ds2482_data   *data = i2c_get_clientdata(client);\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < data->w1_count; idx++) {\n\t\tif (data->w1_ch[idx].pdev != NULL)\n\t\t\tw1_remove_master_device(&data->w1_ch[idx].w1_bm);\n\t}\n\n\t \n\tkfree(data);\n}\n\n \nstatic const struct i2c_device_id ds2482_id[] = {\n\t{ \"ds2482\", 0 },\n\t{ \"ds2484\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds2482_id);\n\nstatic struct i2c_driver ds2482_driver = {\n\t.driver = {\n\t\t.name\t= \"ds2482\",\n\t},\n\t.probe\t\t= ds2482_probe,\n\t.remove\t\t= ds2482_remove,\n\t.id_table\t= ds2482_id,\n};\nmodule_i2c_driver(ds2482_driver);\n\nMODULE_AUTHOR(\"Ben Gardner <bgardner@wabtec.com>\");\nMODULE_DESCRIPTION(\"DS2482 driver\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}