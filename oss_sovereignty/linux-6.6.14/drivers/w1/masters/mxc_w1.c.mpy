{
  "module_name": "mxc_w1.c",
  "hash_id": "6507684f4a2fe971c445e005b2a7a1da5361c9cee1d26eac45881c989df1cdb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/mxc_w1.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#include <linux/w1.h>\n\n \n#define MXC_W1_CONTROL\t\t0x00\n# define MXC_W1_CONTROL_RDST\tBIT(3)\n# define MXC_W1_CONTROL_WR(x)\tBIT(5 - (x))\n# define MXC_W1_CONTROL_PST\tBIT(6)\n# define MXC_W1_CONTROL_RPP\tBIT(7)\n#define MXC_W1_TIME_DIVIDER\t0x02\n#define MXC_W1_RESET\t\t0x04\n# define MXC_W1_RESET_RST\tBIT(0)\n\nstruct mxc_w1_device {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct w1_bus_master bus_master;\n};\n\n \nstatic u8 mxc_w1_ds2_reset_bus(void *data)\n{\n\tstruct mxc_w1_device *dev = data;\n\tktime_t timeout;\n\n\twriteb(MXC_W1_CONTROL_RPP, dev->regs + MXC_W1_CONTROL);\n\n\t \n\ttimeout = ktime_add_us(ktime_get(), 1500);\n\n\tudelay(511 + 512);\n\n\tdo {\n\t\tu8 ctrl = readb(dev->regs + MXC_W1_CONTROL);\n\n\t\t \n\t\tif (!(ctrl & MXC_W1_CONTROL_RPP))\n\t\t\treturn !(ctrl & MXC_W1_CONTROL_PST);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\treturn 1;\n}\n\n \nstatic u8 mxc_w1_ds2_touch_bit(void *data, u8 bit)\n{\n\tstruct mxc_w1_device *dev = data;\n\tktime_t timeout;\n\n\twriteb(MXC_W1_CONTROL_WR(bit), dev->regs + MXC_W1_CONTROL);\n\n\t \n\ttimeout = ktime_add_us(ktime_get(), 200);\n\n\tudelay(60);\n\n\tdo {\n\t\tu8 ctrl = readb(dev->regs + MXC_W1_CONTROL);\n\n\t\t \n\t\tif (!(ctrl & MXC_W1_CONTROL_WR(bit)))\n\t\t\treturn !!(ctrl & MXC_W1_CONTROL_RDST);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\treturn 0;\n}\n\nstatic int mxc_w1_probe(struct platform_device *pdev)\n{\n\tstruct mxc_w1_device *mdev;\n\tunsigned long clkrate;\n\tunsigned int clkdiv;\n\tint err;\n\n\tmdev = devm_kzalloc(&pdev->dev, sizeof(struct mxc_w1_device),\n\t\t\t    GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mdev->clk))\n\t\treturn PTR_ERR(mdev->clk);\n\n\terr = clk_prepare_enable(mdev->clk);\n\tif (err)\n\t\treturn err;\n\n\tclkrate = clk_get_rate(mdev->clk);\n\tif (clkrate < 10000000)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Low clock frequency causes improper function\\n\");\n\n\tclkdiv = DIV_ROUND_CLOSEST(clkrate, 1000000);\n\tclkrate /= clkdiv;\n\tif ((clkrate < 980000) || (clkrate > 1020000))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Incorrect time base frequency %lu Hz\\n\", clkrate);\n\n\tmdev->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->regs)) {\n\t\terr = PTR_ERR(mdev->regs);\n\t\tgoto out_disable_clk;\n\t}\n\n\t \n\twriteb(MXC_W1_RESET_RST, mdev->regs + MXC_W1_RESET);\n\twriteb(0, mdev->regs + MXC_W1_RESET);\n\n\twriteb(clkdiv - 1, mdev->regs + MXC_W1_TIME_DIVIDER);\n\n\tmdev->bus_master.data = mdev;\n\tmdev->bus_master.reset_bus = mxc_w1_ds2_reset_bus;\n\tmdev->bus_master.touch_bit = mxc_w1_ds2_touch_bit;\n\n\tplatform_set_drvdata(pdev, mdev);\n\n\terr = w1_add_master_device(&mdev->bus_master);\n\tif (err)\n\t\tgoto out_disable_clk;\n\n\treturn 0;\n\nout_disable_clk:\n\tclk_disable_unprepare(mdev->clk);\n\treturn err;\n}\n\n \nstatic int mxc_w1_remove(struct platform_device *pdev)\n{\n\tstruct mxc_w1_device *mdev = platform_get_drvdata(pdev);\n\n\tw1_remove_master_device(&mdev->bus_master);\n\n\tclk_disable_unprepare(mdev->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mxc_w1_dt_ids[] = {\n\t{ .compatible = \"fsl,imx21-owire\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxc_w1_dt_ids);\n\nstatic struct platform_driver mxc_w1_driver = {\n\t.driver = {\n\t\t.name = \"mxc_w1\",\n\t\t.of_match_table = mxc_w1_dt_ids,\n\t},\n\t.probe = mxc_w1_probe,\n\t.remove = mxc_w1_remove,\n};\nmodule_platform_driver(mxc_w1_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Freescale Semiconductors Inc\");\nMODULE_DESCRIPTION(\"Driver for One-Wire on MXC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}