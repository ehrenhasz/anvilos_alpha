{
  "module_name": "sgi_w1.c",
  "hash_id": "253f353acbfa72c27b2b620a1bdef2a41b82c07d32ce0e3e4c6b1316dcfd4add",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/sgi_w1.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/sgi-w1.h>\n\n#include <linux/w1.h>\n\n#define MCR_RD_DATA\tBIT(0)\n#define MCR_DONE\tBIT(1)\n\n#define MCR_PACK(pulse, sample) (((pulse) << 10) | ((sample) << 2))\n\nstruct sgi_w1_device {\n\tu32 __iomem *mcr;\n\tstruct w1_bus_master bus_master;\n\tchar dev_id[64];\n};\n\nstatic u8 sgi_w1_wait(u32 __iomem *mcr)\n{\n\tu32 mcr_val;\n\n\tdo {\n\t\tmcr_val = readl(mcr);\n\t} while (!(mcr_val & MCR_DONE));\n\n\treturn (mcr_val & MCR_RD_DATA) ? 1 : 0;\n}\n\n \nstatic u8 sgi_w1_reset_bus(void *data)\n{\n\tstruct sgi_w1_device *dev = data;\n\tu8 ret;\n\n\twritel(MCR_PACK(520, 65), dev->mcr);\n\tret = sgi_w1_wait(dev->mcr);\n\tudelay(500);  \n\treturn ret;\n}\n\n \nstatic u8 sgi_w1_touch_bit(void *data, u8 bit)\n{\n\tstruct sgi_w1_device *dev = data;\n\tu8 ret;\n\n\tif (bit)\n\t\twritel(MCR_PACK(6, 13), dev->mcr);\n\telse\n\t\twritel(MCR_PACK(80, 30), dev->mcr);\n\n\tret = sgi_w1_wait(dev->mcr);\n\tif (bit)\n\t\tudelay(100);  \n\treturn ret;\n}\n\nstatic int sgi_w1_probe(struct platform_device *pdev)\n{\n\tstruct sgi_w1_device *sdev;\n\tstruct sgi_w1_platform_data *pdata;\n\n\tsdev = devm_kzalloc(&pdev->dev, sizeof(struct sgi_w1_device),\n\t\t\t    GFP_KERNEL);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\tsdev->mcr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sdev->mcr))\n\t\treturn PTR_ERR(sdev->mcr);\n\n\tsdev->bus_master.data = sdev;\n\tsdev->bus_master.reset_bus = sgi_w1_reset_bus;\n\tsdev->bus_master.touch_bit = sgi_w1_touch_bit;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\tstrscpy(sdev->dev_id, pdata->dev_id, sizeof(sdev->dev_id));\n\t\tsdev->bus_master.dev_id = sdev->dev_id;\n\t}\n\n\tplatform_set_drvdata(pdev, sdev);\n\n\treturn w1_add_master_device(&sdev->bus_master);\n}\n\n \nstatic int sgi_w1_remove(struct platform_device *pdev)\n{\n\tstruct sgi_w1_device *sdev = platform_get_drvdata(pdev);\n\n\tw1_remove_master_device(&sdev->bus_master);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sgi_w1_driver = {\n\t.driver = {\n\t\t.name = \"sgi_w1\",\n\t},\n\t.probe = sgi_w1_probe,\n\t.remove = sgi_w1_remove,\n};\nmodule_platform_driver(sgi_w1_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Thomas Bogendoerfer\");\nMODULE_DESCRIPTION(\"Driver for One-Wire IP in SGI ASICs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}