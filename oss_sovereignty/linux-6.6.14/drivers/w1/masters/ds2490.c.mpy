{
  "module_name": "ds2490.c",
  "hash_id": "75e89c07cb34631a250810e8c12e8ec8f7827ff9e6cb182c605ffde9eba6212e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/ds2490.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n\n#include <linux/w1.h>\n\n \n \n#define VENDOR\t\t\t\t0x40\n\n \n#define CONTROL_CMD\t\t\t0x00\n#define COMM_CMD\t\t\t0x01\n#define MODE_CMD\t\t\t0x02\n\n \n#define CTL_RESET_DEVICE\t\t0x0000\n#define CTL_START_EXE\t\t\t0x0001\n#define CTL_RESUME_EXE\t\t\t0x0002\n#define CTL_HALT_EXE_IDLE\t\t0x0003\n#define CTL_HALT_EXE_DONE\t\t0x0004\n#define CTL_FLUSH_COMM_CMDS\t\t0x0007\n#define CTL_FLUSH_RCV_BUFFER\t\t0x0008\n#define CTL_FLUSH_XMT_BUFFER\t\t0x0009\n#define CTL_GET_COMM_CMDS\t\t0x000A\n\n \n#define MOD_PULSE_EN\t\t\t0x0000\n#define MOD_SPEED_CHANGE_EN\t\t0x0001\n#define MOD_1WIRE_SPEED\t\t\t0x0002\n#define MOD_STRONG_PU_DURATION\t\t0x0003\n#define MOD_PULLDOWN_SLEWRATE\t\t0x0004\n#define MOD_PROG_PULSE_DURATION\t\t0x0005\n#define MOD_WRITE1_LOWTIME\t\t0x0006\n#define MOD_DSOW0_TREC\t\t\t0x0007\n\n \n#define COMM_ERROR_ESCAPE\t\t0x0601\n#define COMM_SET_DURATION\t\t0x0012\n#define COMM_BIT_IO\t\t\t0x0020\n#define COMM_PULSE\t\t\t0x0030\n#define COMM_1_WIRE_RESET\t\t0x0042\n#define COMM_BYTE_IO\t\t\t0x0052\n#define COMM_MATCH_ACCESS\t\t0x0064\n#define COMM_BLOCK_IO\t\t\t0x0074\n#define COMM_READ_STRAIGHT\t\t0x0080\n#define COMM_DO_RELEASE\t\t\t0x6092\n#define COMM_SET_PATH\t\t\t0x00A2\n#define COMM_WRITE_SRAM_PAGE\t\t0x00B2\n#define COMM_WRITE_EPROM\t\t0x00C4\n#define COMM_READ_CRC_PROT_PAGE\t\t0x00D4\n#define COMM_READ_REDIRECT_PAGE_CRC\t0x21E4\n#define COMM_SEARCH_ACCESS\t\t0x00F4\n\n \n#define COMM_TYPE\t\t\t0x0008\n#define COMM_SE\t\t\t\t0x0008\n#define COMM_D\t\t\t\t0x0008\n#define COMM_Z\t\t\t\t0x0008\n#define COMM_CH\t\t\t\t0x0008\n#define COMM_SM\t\t\t\t0x0008\n#define COMM_R\t\t\t\t0x0008\n#define COMM_IM\t\t\t\t0x0001\n\n#define COMM_PS\t\t\t\t0x4000\n#define COMM_PST\t\t\t0x4000\n#define COMM_CIB\t\t\t0x4000\n#define COMM_RTS\t\t\t0x4000\n#define COMM_DT\t\t\t\t0x2000\n#define COMM_SPU\t\t\t0x1000\n#define COMM_F\t\t\t\t0x0800\n#define COMM_NTF\t\t\t0x0400\n#define COMM_ICP\t\t\t0x0200\n#define COMM_RST\t\t\t0x0100\n\n#define PULSE_PROG\t\t\t0x01\n#define PULSE_SPUE\t\t\t0x02\n\n#define BRANCH_MAIN\t\t\t0xCC\n#define BRANCH_AUX\t\t\t0x33\n\n \n#define ST_SPUA\t\t\t\t0x01   \n#define ST_PRGA\t\t\t\t0x02   \n#define ST_12VP\t\t\t\t0x04   \n#define ST_PMOD\t\t\t\t0x08   \n#define ST_HALT\t\t\t\t0x10   \n#define ST_IDLE\t\t\t\t0x20   \n#define ST_EPOF\t\t\t\t0x80\n \n#define ST_SIZE\t\t\t\t0x20\n\n \n#define RR_DETECT\t\t\t0xA5  \n#define RR_NRS\t\t\t\t0x01  \n#define RR_SH\t\t\t\t0x02  \n#define RR_APP\t\t\t\t0x04  \n#define RR_VPP\t\t\t\t0x08  \n#define RR_CMP\t\t\t\t0x10  \n#define RR_CRC\t\t\t\t0x20  \n#define RR_RDP\t\t\t\t0x40  \n#define RR_EOS\t\t\t\t0x80  \n\n#define SPEED_NORMAL\t\t\t0x00\n#define SPEED_FLEXIBLE\t\t\t0x01\n#define SPEED_OVERDRIVE\t\t\t0x02\n\n#define NUM_EP\t\t\t\t4\n#define EP_CONTROL\t\t\t0\n#define EP_STATUS\t\t\t1\n#define EP_DATA_OUT\t\t\t2\n#define EP_DATA_IN\t\t\t3\n\nstruct ds_device {\n\tstruct list_head\tds_entry;\n\n\tstruct usb_device\t*udev;\n\tstruct usb_interface\t*intf;\n\n\tint\t\t\tep[NUM_EP];\n\n\t \n\tint\t\t\tspu_sleep;\n\t \n\tu16\t\t\tspu_bit;\n\n\tu8\t\t\tst_buf[ST_SIZE];\n\tu8\t\t\tbyte_buf;\n\n\tstruct w1_bus_master\tmaster;\n};\n\nstruct ds_status {\n\tu8\t\t\tenable;\n\tu8\t\t\tspeed;\n\tu8\t\t\tpullup_dur;\n\tu8\t\t\tppuls_dur;\n\tu8\t\t\tpulldown_slew;\n\tu8\t\t\twrite1_time;\n\tu8\t\t\twrite0_time;\n\tu8\t\t\treserved0;\n\tu8\t\t\tstatus;\n\tu8\t\t\tcommand0;\n\tu8\t\t\tcommand1;\n\tu8\t\t\tcommand_buffer_status;\n\tu8\t\t\tdata_out_buffer_status;\n\tu8\t\t\tdata_in_buffer_status;\n\tu8\t\t\treserved1;\n\tu8\t\t\treserved2;\n};\n\nstatic LIST_HEAD(ds_devices);\nstatic DEFINE_MUTEX(ds_mutex);\n\nstatic int ds_send_control_cmd(struct ds_device *dev, u16 value, u16 index)\n{\n\tint err;\n\n\terr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\n\t\t\tCONTROL_CMD, VENDOR, value, index, NULL, 0, 1000);\n\tif (err < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to send command control message %x.%x: err=%d.\\n\",\n\t\t\tvalue, index, err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int ds_send_control_mode(struct ds_device *dev, u16 value, u16 index)\n{\n\tint err;\n\n\terr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\n\t\t\tMODE_CMD, VENDOR, value, index, NULL, 0, 1000);\n\tif (err < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to send mode control message %x.%x: err=%d.\\n\",\n\t\t\tvalue, index, err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int ds_send_control(struct ds_device *dev, u16 value, u16 index)\n{\n\tint err;\n\n\terr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\n\t\t\tCOMM_CMD, VENDOR, value, index, NULL, 0, 1000);\n\tif (err < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to send control message %x.%x: err=%d.\\n\",\n\t\t\tvalue, index, err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic void ds_dump_status(struct ds_device *ds_dev, unsigned char *buf, int count)\n{\n\tstruct device *dev = &ds_dev->udev->dev;\n\tint i;\n\n\tdev_info(dev, \"ep_status=0x%x, count=%d, status=%*phC\",\n\t\tds_dev->ep[EP_STATUS], count, count, buf);\n\n\tif (count >= 16) {\n\t\tdev_dbg(dev, \"enable flag: 0x%02x\", buf[0]);\n\t\tdev_dbg(dev, \"1-wire speed: 0x%02x\", buf[1]);\n\t\tdev_dbg(dev, \"strong pullup duration: 0x%02x\", buf[2]);\n\t\tdev_dbg(dev, \"programming pulse duration: 0x%02x\", buf[3]);\n\t\tdev_dbg(dev, \"pulldown slew rate control: 0x%02x\", buf[4]);\n\t\tdev_dbg(dev, \"write-1 low time: 0x%02x\", buf[5]);\n\t\tdev_dbg(dev, \"data sample offset/write-0 recovery time: 0x%02x\", buf[6]);\n\t\tdev_dbg(dev, \"reserved (test register): 0x%02x\", buf[7]);\n\t\tdev_dbg(dev, \"device status flags: 0x%02x\", buf[8]);\n\t\tdev_dbg(dev, \"communication command byte 1: 0x%02x\", buf[9]);\n\t\tdev_dbg(dev, \"communication command byte 2: 0x%02x\", buf[10]);\n\t\tdev_dbg(dev, \"communication command buffer status: 0x%02x\", buf[11]);\n\t\tdev_dbg(dev, \"1-wire data output buffer status: 0x%02x\", buf[12]);\n\t\tdev_dbg(dev, \"1-wire data input buffer status: 0x%02x\", buf[13]);\n\t\tdev_dbg(dev, \"reserved: 0x%02x\", buf[14]);\n\t\tdev_dbg(dev, \"reserved: 0x%02x\", buf[15]);\n\t}\n\n\tfor (i = 16; i < count; ++i) {\n\t\tif (buf[i] == RR_DETECT) {\n\t\t\tdev_dbg(dev, \"New device detect.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(dev, \"Result Register Value: 0x%02x\", buf[i]);\n\t\tif (buf[i] & RR_NRS)\n\t\t\tdev_dbg(dev, \"NRS: Reset no presence or ...\\n\");\n\t\tif (buf[i] & RR_SH)\n\t\t\tdev_dbg(dev, \"SH: short on reset or set path\\n\");\n\t\tif (buf[i] & RR_APP)\n\t\t\tdev_dbg(dev, \"APP: alarming presence on reset\\n\");\n\t\tif (buf[i] & RR_VPP)\n\t\t\tdev_dbg(dev, \"VPP: 12V expected not seen\\n\");\n\t\tif (buf[i] & RR_CMP)\n\t\t\tdev_dbg(dev, \"CMP: compare error\\n\");\n\t\tif (buf[i] & RR_CRC)\n\t\t\tdev_dbg(dev, \"CRC: CRC error detected\\n\");\n\t\tif (buf[i] & RR_RDP)\n\t\t\tdev_dbg(dev, \"RDP: redirected page\\n\");\n\t\tif (buf[i] & RR_EOS)\n\t\t\tdev_dbg(dev, \"EOS: end of search error\\n\");\n\t}\n}\n\nstatic int ds_recv_status(struct ds_device *dev, struct ds_status *st)\n{\n\tint count, err;\n\n\tif (st)\n\t\tmemset(st, 0, sizeof(*st));\n\n\tcount = 0;\n\terr = usb_interrupt_msg(dev->udev,\n\t\t\t\tusb_rcvintpipe(dev->udev,\n\t\t\t\t\t       dev->ep[EP_STATUS]),\n\t\t\t\tdev->st_buf, sizeof(dev->st_buf),\n\t\t\t\t&count, 1000);\n\tif (err < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to read 1-wire data from 0x%x: err=%d.\\n\",\n\t\t\tdev->ep[EP_STATUS], err);\n\t\treturn err;\n\t}\n\n\tif (st && count >= sizeof(*st))\n\t\tmemcpy(st, dev->st_buf, sizeof(*st));\n\n\treturn count;\n}\n\nstatic void ds_reset_device(struct ds_device *dev)\n{\n\tds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);\n\t \n\tif (ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_SPUE))\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"%s: Error allowing strong pullup\\n\", __func__);\n\t \n\tif (dev->spu_sleep) {\n\t\t \n\t\tu8 del = dev->spu_sleep>>4;\n\n\t\tif (ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del))\n\t\t\tdev_err(&dev->udev->dev,\n\t\t\t\t\"%s: Error setting duration\\n\", __func__);\n\t}\n}\n\nstatic int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)\n{\n\tint count, err;\n\n\t \n\tcount = 0;\n\terr = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]),\n\t\t\t\tbuf, size, &count, 1000);\n\tif (err < 0) {\n\t\tint recv_len;\n\n\t\tdev_info(&dev->udev->dev, \"Clearing ep0x%x.\\n\", dev->ep[EP_DATA_IN]);\n\t\tusb_clear_halt(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]));\n\n\t\t \n\t\trecv_len = ds_recv_status(dev, NULL);\n\t\tif (recv_len >= 0)\n\t\t\tds_dump_status(dev, dev->st_buf, recv_len);\n\n\t\treturn err;\n\t}\n\n#if 0\n\t{\n\t\tint i;\n\n\t\tprintk(\"%s: count=%d: \", __func__, count);\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tprintk(\"%02x \", buf[i]);\n\t\tprintk(\"\\n\");\n\t}\n#endif\n\treturn count;\n}\n\nstatic int ds_send_data(struct ds_device *dev, unsigned char *buf, int len)\n{\n\tint count, err;\n\n\tcount = 0;\n\terr = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, dev->ep[EP_DATA_OUT]), buf, len, &count, 1000);\n\tif (err < 0) {\n\t\tdev_err(&dev->udev->dev, \"Failed to write 1-wire data to ep0x%x: \"\n\t\t\t\"err=%d.\\n\", dev->ep[EP_DATA_OUT], err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n#if 0\n\nint ds_stop_pulse(struct ds_device *dev, int limit)\n{\n\tstruct ds_status st;\n\tint count = 0, err = 0;\n\n\tdo {\n\t\terr = ds_send_control(dev, CTL_HALT_EXE_IDLE, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = ds_send_control(dev, CTL_RESUME_EXE, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = ds_recv_status(dev, &st);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif ((st.status & ST_SPUA) == 0) {\n\t\t\terr = ds_send_control_mode(dev, MOD_PULSE_EN, 0);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t} while (++count < limit);\n\n\treturn err;\n}\n\nint ds_detect(struct ds_device *dev, struct ds_status *st)\n{\n\tint err;\n\n\terr = ds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = ds_send_control(dev, COMM_SET_DURATION | COMM_IM | COMM_TYPE, 0x40);\n\tif (err)\n\t\treturn err;\n\n\terr = ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_PROG);\n\tif (err)\n\t\treturn err;\n\n\terr = ds_dump_status(dev, st);\n\n\treturn err;\n}\n\n#endif   \n\nstatic int ds_wait_status(struct ds_device *dev, struct ds_status *st)\n{\n\tint err, count = 0;\n\n\tdo {\n\t\tst->status = 0;\n\t\terr = ds_recv_status(dev, st);\n#if 0\n\t\tif (err >= 0) {\n\t\t\tint i;\n\t\t\tprintk(\"0x%x: count=%d, status: \", dev->ep[EP_STATUS], err);\n\t\t\tfor (i = 0; i < err; ++i)\n\t\t\t\tprintk(\"%02x \", dev->st_buf[i]);\n\t\t\tprintk(\"\\n\");\n\t\t}\n#endif\n\t} while (!(st->status & ST_IDLE) && !(err < 0) && ++count < 100);\n\n\tif (err >= 16 && st->status & ST_EPOF) {\n\t\tdev_info(&dev->udev->dev, \"Resetting device after ST_EPOF.\\n\");\n\t\tds_reset_device(dev);\n\t\t \n\t\tcount = 101;\n\t}\n\n\t \n\tif (err > 16 || count >= 100 || err < 0)\n\t\tds_dump_status(dev, dev->st_buf, err);\n\n\t \n\tif (count >= 100 || err < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nstatic int ds_reset(struct ds_device *dev)\n{\n\tint err;\n\n\t \n\terr = ds_send_control(dev, COMM_1_WIRE_RESET | COMM_IM, SPEED_NORMAL);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#if 0\nstatic int ds_set_speed(struct ds_device *dev, int speed)\n{\n\tint err;\n\n\tif (speed != SPEED_NORMAL && speed != SPEED_FLEXIBLE && speed != SPEED_OVERDRIVE)\n\t\treturn -EINVAL;\n\n\tif (speed != SPEED_OVERDRIVE)\n\t\tspeed = SPEED_FLEXIBLE;\n\n\tspeed &= 0xff;\n\n\terr = ds_send_control_mode(dev, MOD_1WIRE_SPEED, speed);\n\tif (err)\n\t\treturn err;\n\n\treturn err;\n}\n#endif   \n\nstatic int ds_set_pullup(struct ds_device *dev, int delay)\n{\n\tint err = 0;\n\tu8 del = 1 + (u8)(delay >> 4);\n\t \n\tint ms = del<<4;\n\n\t \n\tdev->spu_bit = delay ? COMM_SPU : 0;\n\t \n\tif (delay == 0 || ms == dev->spu_sleep)\n\t\treturn err;\n\n\terr = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del);\n\tif (err)\n\t\treturn err;\n\n\tdev->spu_sleep = ms;\n\n\treturn err;\n}\n\nstatic int ds_touch_bit(struct ds_device *dev, u8 bit, u8 *tbit)\n{\n\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_control(dev, COMM_BIT_IO | COMM_IM | (bit ? COMM_D : 0),\n\t\t0);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\terr = ds_recv_data(dev, tbit, sizeof(*tbit));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#if 0\nstatic int ds_write_bit(struct ds_device *dev, u8 bit)\n{\n\tint err;\n\tstruct ds_status st;\n\n\t \n\terr = ds_send_control(dev, COMM_BIT_IO | COMM_IM | COMM_ICP |\n\t\t(bit ? COMM_D : 0), 0);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\treturn 0;\n}\n#endif\n\nstatic int ds_write_byte(struct ds_device *dev, u8 byte)\n{\n\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM | dev->spu_bit, byte);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->spu_bit)\n\t\tmsleep(dev->spu_sleep);\n\n\terr = ds_wait_status(dev, &st);\n\tif (err)\n\t\treturn err;\n\n\terr = ds_recv_data(dev, &dev->byte_buf, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn !(byte == dev->byte_buf);\n}\n\nstatic int ds_read_byte(struct ds_device *dev, u8 *byte)\n{\n\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM, 0xff);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\terr = ds_recv_data(dev, byte, sizeof(*byte));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ds_read_block(struct ds_device *dev, u8 *buf, int len)\n{\n\tstruct ds_status st;\n\tint err;\n\n\tif (len > 64*1024)\n\t\treturn -E2BIG;\n\n\tmemset(buf, 0xFF, len);\n\n\terr = ds_send_data(dev, buf, len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM, len);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\tmemset(buf, 0x00, len);\n\terr = ds_recv_data(dev, buf, len);\n\n\treturn err;\n}\n\nstatic int ds_write_block(struct ds_device *dev, u8 *buf, int len)\n{\n\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_data(dev, buf, len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM | dev->spu_bit, len);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->spu_bit)\n\t\tmsleep(dev->spu_sleep);\n\n\tds_wait_status(dev, &st);\n\n\terr = ds_recv_data(dev, buf, len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn !(err == len);\n}\n\nstatic void ds9490r_search(void *data, struct w1_master *master,\n\tu8 search_type, w1_slave_found_callback callback)\n{\n\t \n\tstruct ds_device *dev = data;\n\tint err;\n\tu16 value, index;\n\tstruct ds_status st;\n\tint search_limit;\n\tint found = 0;\n\tint i;\n\n\t \n\tconst unsigned long jtime = msecs_to_jiffies(1000*8/75);\n\t \n\tconst size_t bufsize = 2 * 64;\n\tu64 *buf, *found_ids;\n\n\tbuf = kmalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t \n\tfound_ids = kmalloc_array(master->max_slave_count, sizeof(u64), GFP_KERNEL);\n\tif (!found_ids) {\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tmutex_lock(&master->bus_mutex);\n\n\t \n\tif (ds_send_data(dev, (u8 *)&master->search_id, 8) < 0)\n\t\tgoto search_out;\n\tmaster->search_id = 0;\n\n\tvalue = COMM_SEARCH_ACCESS | COMM_IM | COMM_RST | COMM_SM | COMM_F |\n\t\tCOMM_RTS;\n\tsearch_limit = master->max_slave_count;\n\tif (search_limit > 255)\n\t\tsearch_limit = 0;\n\tindex = search_type | (search_limit << 8);\n\tif (ds_send_control(dev, value, index) < 0)\n\t\tgoto search_out;\n\n\tdo {\n\t\tschedule_timeout(jtime);\n\n\t\terr = ds_recv_status(dev, &st);\n\t\tif (err < 0 || err < sizeof(st))\n\t\t\tbreak;\n\n\t\tif (st.data_in_buffer_status) {\n\t\t\t \n\t\t\terr = ds_recv_data(dev, (u8 *)buf, bufsize);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tfor (i = 0; i < err/8; ++i) {\n\t\t\t\tfound_ids[found++] = buf[i];\n\t\t\t\t \n\t\t\t\tif (found == search_limit) {\n\t\t\t\t\tmaster->search_id = buf[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (test_bit(W1_ABORT_SEARCH, &master->flags))\n\t\t\tbreak;\n\t} while (!(st.status & (ST_IDLE | ST_HALT)));\n\n\t \n\tif (found <= search_limit) {\n\t\tmaster->search_id = 0;\n\t} else if (!test_bit(W1_WARN_MAX_COUNT, &master->flags)) {\n\t\t \n\t\tdev_info(&dev->udev->dev, \"%s: max_slave_count %d reached, \"\n\t\t\t\"will continue next search.\\n\", __func__,\n\t\t\tmaster->max_slave_count);\n\t\tset_bit(W1_WARN_MAX_COUNT, &master->flags);\n\t}\n\nsearch_out:\n\tmutex_unlock(&master->bus_mutex);\n\tkfree(buf);\n\n\tfor (i = 0; i < found; i++)  \n\t\tcallback(master, found_ids[i]);\n\tkfree(found_ids);\n}\n\n#if 0\n \nstatic int ds_match_access(struct ds_device *dev, u64 init)\n{\n\tint err;\n\tstruct ds_status st;\n\n\terr = ds_send_data(dev, (unsigned char *)&init, sizeof(init));\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\terr = ds_send_control(dev, COMM_MATCH_ACCESS | COMM_IM | COMM_RST, 0x0055);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\treturn 0;\n}\n\nstatic int ds_set_path(struct ds_device *dev, u64 init)\n{\n\tint err;\n\tstruct ds_status st;\n\tu8 buf[9];\n\n\tmemcpy(buf, &init, 8);\n\tbuf[8] = BRANCH_MAIN;\n\n\terr = ds_send_data(dev, buf, sizeof(buf));\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\terr = ds_send_control(dev, COMM_SET_PATH | COMM_IM | COMM_RST, 0);\n\tif (err)\n\t\treturn err;\n\n\tds_wait_status(dev, &st);\n\n\treturn 0;\n}\n\n#endif   \n\nstatic u8 ds9490r_touch_bit(void *data, u8 bit)\n{\n\tstruct ds_device *dev = data;\n\n\tif (ds_touch_bit(dev, bit, &dev->byte_buf))\n\t\treturn 0;\n\n\treturn dev->byte_buf;\n}\n\n#if 0\nstatic void ds9490r_write_bit(void *data, u8 bit)\n{\n\tstruct ds_device *dev = data;\n\n\tds_write_bit(dev, bit);\n}\n\nstatic u8 ds9490r_read_bit(void *data)\n{\n\tstruct ds_device *dev = data;\n\tint err;\n\n\terr = ds_touch_bit(dev, 1, &dev->byte_buf);\n\tif (err)\n\t\treturn 0;\n\n\treturn dev->byte_buf & 1;\n}\n#endif\n\nstatic void ds9490r_write_byte(void *data, u8 byte)\n{\n\tstruct ds_device *dev = data;\n\n\tds_write_byte(dev, byte);\n}\n\nstatic u8 ds9490r_read_byte(void *data)\n{\n\tstruct ds_device *dev = data;\n\tint err;\n\n\terr = ds_read_byte(dev, &dev->byte_buf);\n\tif (err)\n\t\treturn 0;\n\n\treturn dev->byte_buf;\n}\n\nstatic void ds9490r_write_block(void *data, const u8 *buf, int len)\n{\n\tstruct ds_device *dev = data;\n\tu8 *tbuf;\n\n\tif (len <= 0)\n\t\treturn;\n\n\ttbuf = kmemdup(buf, len, GFP_KERNEL);\n\tif (!tbuf)\n\t\treturn;\n\n\tds_write_block(dev, tbuf, len);\n\n\tkfree(tbuf);\n}\n\nstatic u8 ds9490r_read_block(void *data, u8 *buf, int len)\n{\n\tstruct ds_device *dev = data;\n\tint err;\n\tu8 *tbuf;\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\ttbuf = kmalloc(len, GFP_KERNEL);\n\tif (!tbuf)\n\t\treturn 0;\n\n\terr = ds_read_block(dev, tbuf, len);\n\tif (err >= 0)\n\t\tmemcpy(buf, tbuf, len);\n\n\tkfree(tbuf);\n\n\treturn err >= 0 ? len : 0;\n}\n\nstatic u8 ds9490r_reset(void *data)\n{\n\tstruct ds_device *dev = data;\n\tint err;\n\n\terr = ds_reset(dev);\n\tif (err)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic u8 ds9490r_set_pullup(void *data, int delay)\n{\n\tstruct ds_device *dev = data;\n\n\tif (ds_set_pullup(dev, delay))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ds_w1_init(struct ds_device *dev)\n{\n\tmemset(&dev->master, 0, sizeof(struct w1_bus_master));\n\n\t \n\tds_reset_device(dev);\n\n\tdev->master.data\t= dev;\n\tdev->master.touch_bit\t= &ds9490r_touch_bit;\n\t \n\tdev->master.read_byte\t= &ds9490r_read_byte;\n\tdev->master.write_byte\t= &ds9490r_write_byte;\n\tdev->master.read_block\t= &ds9490r_read_block;\n\tdev->master.write_block\t= &ds9490r_write_block;\n\tdev->master.reset_bus\t= &ds9490r_reset;\n\tdev->master.set_pullup\t= &ds9490r_set_pullup;\n\tdev->master.search\t= &ds9490r_search;\n\n\treturn w1_add_master_device(&dev->master);\n}\n\nstatic void ds_w1_fini(struct ds_device *dev)\n{\n\tw1_remove_master_device(&dev->master);\n}\n\nstatic int ds_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *udev_id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_host_interface *iface_desc;\n\tstruct ds_device *dev;\n\tint i, err, alt;\n\n\tdev = kzalloc(sizeof(struct ds_device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->udev = usb_get_dev(udev);\n\tif (!dev->udev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\tmemset(dev->ep, 0, sizeof(dev->ep));\n\n\tusb_set_intfdata(intf, dev);\n\n\terr = usb_reset_configuration(dev->udev);\n\tif (err) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to reset configuration: err=%d.\\n\", err);\n\t\tgoto err_out_clear;\n\t}\n\n\t \n\talt = 3;\n\terr = usb_set_interface(dev->udev,\n\t\tintf->cur_altsetting->desc.bInterfaceNumber, alt);\n\tif (err) {\n\t\tdev_err(&dev->udev->dev, \"Failed to set alternative setting %d \"\n\t\t\t\"for %d interface: err=%d.\\n\", alt,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber, err);\n\t\tgoto err_out_clear;\n\t}\n\n\tiface_desc = intf->cur_altsetting;\n\tif (iface_desc->desc.bNumEndpoints != NUM_EP-1) {\n\t\tdev_err(&dev->udev->dev, \"Num endpoints=%d. It is not DS9490R.\\n\",\n\t\t\tiface_desc->desc.bNumEndpoints);\n\t\terr = -EINVAL;\n\t\tgoto err_out_clear;\n\t}\n\n\t \n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tdev->ep[i+1] = endpoint->bEndpointAddress;\n#if 0\n\t\tprintk(\"%d: addr=%x, size=%d, dir=%s, type=%x\\n\",\n\t\t\ti, endpoint->bEndpointAddress, le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t(endpoint->bEndpointAddress & USB_DIR_IN)?\"IN\":\"OUT\",\n\t\t\tendpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\n#endif\n\t}\n\n\terr = ds_w1_init(dev);\n\tif (err)\n\t\tgoto err_out_clear;\n\n\tmutex_lock(&ds_mutex);\n\tlist_add_tail(&dev->ds_entry, &ds_devices);\n\tmutex_unlock(&ds_mutex);\n\n\treturn 0;\n\nerr_out_clear:\n\tusb_set_intfdata(intf, NULL);\n\tusb_put_dev(dev->udev);\nerr_out_free:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void ds_disconnect(struct usb_interface *intf)\n{\n\tstruct ds_device *dev;\n\n\tdev = usb_get_intfdata(intf);\n\tif (!dev)\n\t\treturn;\n\n\tmutex_lock(&ds_mutex);\n\tlist_del(&dev->ds_entry);\n\tmutex_unlock(&ds_mutex);\n\n\tds_w1_fini(dev);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tusb_put_dev(dev->udev);\n\tkfree(dev);\n}\n\nstatic const struct usb_device_id ds_id_table[] = {\n\t{ USB_DEVICE(0x04fa, 0x2490) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, ds_id_table);\n\nstatic struct usb_driver ds_driver = {\n\t.name =\t\t\"DS9490R\",\n\t.probe =\tds_probe,\n\t.disconnect =\tds_disconnect,\n\t.id_table =\tds_id_table,\n};\nmodule_usb_driver(ds_driver);\n\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"DS2490 USB <-> W1 bus master driver (DS9490*)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}