{
  "module_name": "omap_hdq.c",
  "hash_id": "2132af6d4e8d8fdbe7c2937215174171857f08f0195811441b64bef042b99cac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/masters/omap_hdq.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/sched.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n\n#include <linux/w1.h>\n\n#define\tMOD_NAME\t\"OMAP_HDQ:\"\n\n#define OMAP_HDQ_REVISION\t\t\t0x00\n#define OMAP_HDQ_TX_DATA\t\t\t0x04\n#define OMAP_HDQ_RX_DATA\t\t\t0x08\n#define OMAP_HDQ_CTRL_STATUS\t\t\t0x0c\n#define OMAP_HDQ_CTRL_STATUS_SINGLE\t\tBIT(7)\n#define OMAP_HDQ_CTRL_STATUS_INTERRUPTMASK\tBIT(6)\n#define OMAP_HDQ_CTRL_STATUS_CLOCKENABLE\tBIT(5)\n#define OMAP_HDQ_CTRL_STATUS_GO                 BIT(4)\n#define OMAP_HDQ_CTRL_STATUS_PRESENCE\t\tBIT(3)\n#define OMAP_HDQ_CTRL_STATUS_INITIALIZATION\tBIT(2)\n#define OMAP_HDQ_CTRL_STATUS_DIR\t\tBIT(1)\n#define OMAP_HDQ_INT_STATUS\t\t\t0x10\n#define OMAP_HDQ_INT_STATUS_TXCOMPLETE\t\tBIT(2)\n#define OMAP_HDQ_INT_STATUS_RXCOMPLETE\t\tBIT(1)\n#define OMAP_HDQ_INT_STATUS_TIMEOUT\t\tBIT(0)\n\n#define OMAP_HDQ_FLAG_CLEAR\t\t\t0\n#define OMAP_HDQ_FLAG_SET\t\t\t1\n#define OMAP_HDQ_TIMEOUT\t\t\t(HZ/5)\n\n#define OMAP_HDQ_MAX_USER\t\t\t4\n\nstatic DECLARE_WAIT_QUEUE_HEAD(hdq_wait_queue);\n\nstatic int w1_id;\nmodule_param(w1_id, int, 0400);\nMODULE_PARM_DESC(w1_id, \"1-wire id for the slave detection in HDQ mode\");\n\nstruct hdq_data {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*hdq_base;\n\t \n\tstruct  mutex\t\thdq_mutex;\n\t \n\tu8\t\t\thdq_irqstatus;\n\tspinlock_t\t\thdq_spinlock;\n\t \n\tint                     mode;\n\n};\n\n \nstatic inline u8 hdq_reg_in(struct hdq_data *hdq_data, u32 offset)\n{\n\treturn __raw_readl(hdq_data->hdq_base + offset);\n}\n\nstatic inline void hdq_reg_out(struct hdq_data *hdq_data, u32 offset, u8 val)\n{\n\t__raw_writel(val, hdq_data->hdq_base + offset);\n}\n\nstatic inline u8 hdq_reg_merge(struct hdq_data *hdq_data, u32 offset,\n\t\t\tu8 val, u8 mask)\n{\n\tu8 new_val = (__raw_readl(hdq_data->hdq_base + offset) & ~mask)\n\t\t\t| (val & mask);\n\t__raw_writel(new_val, hdq_data->hdq_base + offset);\n\n\treturn new_val;\n}\n\n \nstatic int hdq_wait_for_flag(struct hdq_data *hdq_data, u32 offset,\n\t\tu8 flag, u8 flag_set, u8 *status)\n{\n\tint ret = 0;\n\tunsigned long timeout = jiffies + OMAP_HDQ_TIMEOUT;\n\n\tif (flag_set == OMAP_HDQ_FLAG_CLEAR) {\n\t\t \n\t\twhile (((*status = hdq_reg_in(hdq_data, offset)) & flag)\n\t\t\t&& time_before(jiffies, timeout)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\t\tif (*status & flag)\n\t\t\tret = -ETIMEDOUT;\n\t} else if (flag_set == OMAP_HDQ_FLAG_SET) {\n\t\t \n\t\twhile (!((*status = hdq_reg_in(hdq_data, offset)) & flag)\n\t\t\t&& time_before(jiffies, timeout)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\t\tif (!(*status & flag))\n\t\t\tret = -ETIMEDOUT;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\n \nstatic u8 hdq_reset_irqstatus(struct hdq_data *hdq_data, u8 bits)\n{\n\tunsigned long irqflags;\n\tu8 status;\n\n\tspin_lock_irqsave(&hdq_data->hdq_spinlock, irqflags);\n\tstatus = hdq_data->hdq_irqstatus;\n\t \n\thdq_data->hdq_irqstatus &= ~bits;\n\tspin_unlock_irqrestore(&hdq_data->hdq_spinlock, irqflags);\n\n\treturn status;\n}\n\n \nstatic int hdq_write_byte(struct hdq_data *hdq_data, u8 val, u8 *status)\n{\n\tint ret;\n\tu8 tmp_status;\n\n\tret = mutex_lock_interruptible(&hdq_data->hdq_mutex);\n\tif (ret < 0) {\n\t\tret = -EINTR;\n\t\tgoto rtn;\n\t}\n\n\tif (hdq_data->hdq_irqstatus)\n\t\tdev_err(hdq_data->dev, \"TX irqstatus not cleared (%02x)\\n\",\n\t\t\thdq_data->hdq_irqstatus);\n\n\t*status = 0;\n\n\thdq_reg_out(hdq_data, OMAP_HDQ_TX_DATA, val);\n\n\t \n\thdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS, OMAP_HDQ_CTRL_STATUS_GO,\n\t\tOMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_GO);\n\t \n\tret = wait_event_timeout(hdq_wait_queue,\n\t\t(hdq_data->hdq_irqstatus & OMAP_HDQ_INT_STATUS_TXCOMPLETE),\n\t\tOMAP_HDQ_TIMEOUT);\n\t*status = hdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_TXCOMPLETE);\n\tif (ret == 0) {\n\t\tdev_dbg(hdq_data->dev, \"TX wait elapsed\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(*status & OMAP_HDQ_INT_STATUS_TXCOMPLETE)) {\n\t\tdev_dbg(hdq_data->dev, \"timeout waiting for\"\n\t\t\t\" TXCOMPLETE/RXCOMPLETE, %x\\n\", *status);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tret = hdq_wait_for_flag(hdq_data, OMAP_HDQ_CTRL_STATUS,\n\t\t\tOMAP_HDQ_CTRL_STATUS_GO,\n\t\t\tOMAP_HDQ_FLAG_CLEAR, &tmp_status);\n\tif (ret) {\n\t\tdev_dbg(hdq_data->dev, \"timeout waiting GO bit\"\n\t\t\t\" return to zero, %x\\n\", tmp_status);\n\t}\n\nout:\n\tmutex_unlock(&hdq_data->hdq_mutex);\nrtn:\n\treturn ret;\n}\n\n \nstatic irqreturn_t hdq_isr(int irq, void *_hdq)\n{\n\tstruct hdq_data *hdq_data = _hdq;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&hdq_data->hdq_spinlock, irqflags);\n\thdq_data->hdq_irqstatus |= hdq_reg_in(hdq_data, OMAP_HDQ_INT_STATUS);\n\tspin_unlock_irqrestore(&hdq_data->hdq_spinlock, irqflags);\n\tdev_dbg(hdq_data->dev, \"hdq_isr: %x\\n\", hdq_data->hdq_irqstatus);\n\n\tif (hdq_data->hdq_irqstatus &\n\t\t(OMAP_HDQ_INT_STATUS_TXCOMPLETE | OMAP_HDQ_INT_STATUS_RXCOMPLETE\n\t\t| OMAP_HDQ_INT_STATUS_TIMEOUT)) {\n\t\t \n\t\twake_up(&hdq_wait_queue);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void omap_w1_search_bus(void *_hdq, struct w1_master *master_dev,\n\t\tu8 search_type, w1_slave_found_callback slave_found)\n{\n\tu64 module_id, rn_le, cs, id;\n\n\tif (w1_id)\n\t\tmodule_id = w1_id;\n\telse\n\t\tmodule_id = 0x1;\n\n\trn_le = cpu_to_le64(module_id);\n\t \n\tcs = w1_calc_crc8((u8 *)&rn_le, 7);\n\tid = (cs << 56) | module_id;\n\n\tslave_found(master_dev, id);\n}\n\n \nstatic int omap_hdq_break(struct hdq_data *hdq_data)\n{\n\tint ret = 0;\n\tu8 tmp_status;\n\n\tret = mutex_lock_interruptible(&hdq_data->hdq_mutex);\n\tif (ret < 0) {\n\t\tdev_dbg(hdq_data->dev, \"Could not acquire mutex\\n\");\n\t\tret = -EINTR;\n\t\tgoto rtn;\n\t}\n\n\tif (hdq_data->hdq_irqstatus)\n\t\tdev_err(hdq_data->dev, \"break irqstatus not cleared (%02x)\\n\",\n\t\t\thdq_data->hdq_irqstatus);\n\n\t \n\thdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS,\n\t\tOMAP_HDQ_CTRL_STATUS_INITIALIZATION | OMAP_HDQ_CTRL_STATUS_GO,\n\t\tOMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_INITIALIZATION |\n\t\tOMAP_HDQ_CTRL_STATUS_GO);\n\n\t \n\tret = wait_event_timeout(hdq_wait_queue,\n\t\t(hdq_data->hdq_irqstatus & OMAP_HDQ_INT_STATUS_TIMEOUT),\n\t\tOMAP_HDQ_TIMEOUT);\n\ttmp_status = hdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_TIMEOUT);\n\tif (ret == 0) {\n\t\tdev_dbg(hdq_data->dev, \"break wait elapsed\\n\");\n\t\tret = -EINTR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(tmp_status & OMAP_HDQ_INT_STATUS_TIMEOUT)) {\n\t\tdev_dbg(hdq_data->dev, \"timeout waiting for TIMEOUT, %x\\n\",\n\t\t\ttmp_status);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(hdq_reg_in(hdq_data, OMAP_HDQ_CTRL_STATUS) &\n\t\t\tOMAP_HDQ_CTRL_STATUS_PRESENCE)) {\n\t\tdev_dbg(hdq_data->dev, \"Presence bit not set\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tret = hdq_wait_for_flag(hdq_data, OMAP_HDQ_CTRL_STATUS,\n\t\t\tOMAP_HDQ_CTRL_STATUS_INITIALIZATION |\n\t\t\tOMAP_HDQ_CTRL_STATUS_GO, OMAP_HDQ_FLAG_CLEAR,\n\t\t\t&tmp_status);\n\tif (ret)\n\t\tdev_dbg(hdq_data->dev, \"timeout waiting INIT&GO bits\"\n\t\t\t\" return to zero, %x\\n\", tmp_status);\n\nout:\n\tmutex_unlock(&hdq_data->hdq_mutex);\nrtn:\n\treturn ret;\n}\n\nstatic int hdq_read_byte(struct hdq_data *hdq_data, u8 *val)\n{\n\tint ret = 0;\n\tu8 status;\n\n\tret = mutex_lock_interruptible(&hdq_data->hdq_mutex);\n\tif (ret < 0) {\n\t\tret = -EINTR;\n\t\tgoto rtn;\n\t}\n\n\tif (pm_runtime_suspended(hdq_data->dev)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(hdq_data->hdq_irqstatus & OMAP_HDQ_INT_STATUS_RXCOMPLETE)) {\n\t\thdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS,\n\t\t\tOMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_GO,\n\t\t\tOMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_GO);\n\t\t \n\t\twait_event_timeout(hdq_wait_queue,\n\t\t\t\t   (hdq_data->hdq_irqstatus\n\t\t\t\t    & (OMAP_HDQ_INT_STATUS_RXCOMPLETE |\n\t\t\t\t       OMAP_HDQ_INT_STATUS_TIMEOUT)),\n\t\t\t\t   OMAP_HDQ_TIMEOUT);\n\t\tstatus = hdq_reset_irqstatus(hdq_data,\n\t\t\t\t\t     OMAP_HDQ_INT_STATUS_RXCOMPLETE |\n\t\t\t\t\t     OMAP_HDQ_INT_STATUS_TIMEOUT);\n\t\thdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS, 0,\n\t\t\tOMAP_HDQ_CTRL_STATUS_DIR);\n\n\t\t \n\t\tif (!(status & OMAP_HDQ_INT_STATUS_RXCOMPLETE)) {\n\t\t\tdev_dbg(hdq_data->dev, \"timeout waiting for\"\n\t\t\t\t\" RXCOMPLETE, %x\", status);\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t} else {  \n\t\thdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_RXCOMPLETE);\n\t}\n\t \n\t*val = hdq_reg_in(hdq_data, OMAP_HDQ_RX_DATA);\nout:\n\tmutex_unlock(&hdq_data->hdq_mutex);\nrtn:\n\treturn ret;\n\n}\n\n \nstatic u8 omap_w1_triplet(void *_hdq, u8 bdir)\n{\n\tu8 id_bit, comp_bit;\n\tint err;\n\tu8 ret = 0x3;  \n\tstruct hdq_data *hdq_data = _hdq;\n\tu8 ctrl = OMAP_HDQ_CTRL_STATUS_SINGLE | OMAP_HDQ_CTRL_STATUS_GO |\n\t\t  OMAP_HDQ_CTRL_STATUS_INTERRUPTMASK;\n\tu8 mask = ctrl | OMAP_HDQ_CTRL_STATUS_DIR;\n\n\terr = pm_runtime_get_sync(hdq_data->dev);\n\tif (err < 0) {\n\t\tpm_runtime_put_noidle(hdq_data->dev);\n\n\t\treturn err;\n\t}\n\n\terr = mutex_lock_interruptible(&hdq_data->hdq_mutex);\n\tif (err < 0) {\n\t\tdev_dbg(hdq_data->dev, \"Could not acquire mutex\\n\");\n\t\tgoto rtn;\n\t}\n\n\t \n\thdq_reg_merge(_hdq, OMAP_HDQ_CTRL_STATUS,\n\t\t      ctrl | OMAP_HDQ_CTRL_STATUS_DIR, mask);\n\terr = wait_event_timeout(hdq_wait_queue,\n\t\t\t\t (hdq_data->hdq_irqstatus\n\t\t\t\t  & OMAP_HDQ_INT_STATUS_RXCOMPLETE),\n\t\t\t\t OMAP_HDQ_TIMEOUT);\n\t \n\thdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_RXCOMPLETE);\n\n\tif (err == 0) {\n\t\tdev_dbg(hdq_data->dev, \"RX wait elapsed\\n\");\n\t\tgoto out;\n\t}\n\tid_bit = (hdq_reg_in(_hdq, OMAP_HDQ_RX_DATA) & 0x01);\n\n\t \n\thdq_reg_merge(_hdq, OMAP_HDQ_CTRL_STATUS,\n\t\t      ctrl | OMAP_HDQ_CTRL_STATUS_DIR, mask);\n\terr = wait_event_timeout(hdq_wait_queue,\n\t\t\t\t (hdq_data->hdq_irqstatus\n\t\t\t\t  & OMAP_HDQ_INT_STATUS_RXCOMPLETE),\n\t\t\t\t OMAP_HDQ_TIMEOUT);\n\t \n\thdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_RXCOMPLETE);\n\n\tif (err == 0) {\n\t\tdev_dbg(hdq_data->dev, \"RX wait elapsed\\n\");\n\t\tgoto out;\n\t}\n\tcomp_bit = (hdq_reg_in(_hdq, OMAP_HDQ_RX_DATA) & 0x01);\n\n\tif (id_bit && comp_bit) {\n\t\tret = 0x03;   \n\t\tgoto out;\n\t}\n\tif (!id_bit && !comp_bit) {\n\t\t \n\t\tret = bdir ? 0x04 : 0;\n\t} else {\n\t\t \n\t\tbdir = id_bit;\n\t\tret = id_bit ? 0x05 : 0x02;\n\t}\n\n\t \n\thdq_reg_out(_hdq, OMAP_HDQ_TX_DATA, bdir);\n\thdq_reg_merge(_hdq, OMAP_HDQ_CTRL_STATUS, ctrl, mask);\n\terr = wait_event_timeout(hdq_wait_queue,\n\t\t\t\t (hdq_data->hdq_irqstatus\n\t\t\t\t  & OMAP_HDQ_INT_STATUS_TXCOMPLETE),\n\t\t\t\t OMAP_HDQ_TIMEOUT);\n\t \n\thdq_reset_irqstatus(hdq_data, OMAP_HDQ_INT_STATUS_TXCOMPLETE);\n\n\tif (err == 0) {\n\t\tdev_dbg(hdq_data->dev, \"TX wait elapsed\\n\");\n\t\tgoto out;\n\t}\n\n\thdq_reg_merge(_hdq, OMAP_HDQ_CTRL_STATUS, 0,\n\t\t      OMAP_HDQ_CTRL_STATUS_SINGLE);\n\nout:\n\tmutex_unlock(&hdq_data->hdq_mutex);\nrtn:\n\tpm_runtime_mark_last_busy(hdq_data->dev);\n\tpm_runtime_put_autosuspend(hdq_data->dev);\n\n\treturn ret;\n}\n\n \nstatic u8 omap_w1_reset_bus(void *_hdq)\n{\n\tstruct hdq_data *hdq_data = _hdq;\n\tint err;\n\n\terr = pm_runtime_get_sync(hdq_data->dev);\n\tif (err < 0) {\n\t\tpm_runtime_put_noidle(hdq_data->dev);\n\n\t\treturn err;\n\t}\n\n\tomap_hdq_break(hdq_data);\n\n\tpm_runtime_mark_last_busy(hdq_data->dev);\n\tpm_runtime_put_autosuspend(hdq_data->dev);\n\n\treturn 0;\n}\n\n \nstatic u8 omap_w1_read_byte(void *_hdq)\n{\n\tstruct hdq_data *hdq_data = _hdq;\n\tu8 val = 0;\n\tint ret;\n\n\tret = pm_runtime_get_sync(hdq_data->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(hdq_data->dev);\n\n\t\treturn -1;\n\t}\n\n\tret = hdq_read_byte(hdq_data, &val);\n\tif (ret)\n\t\tval = -1;\n\n\tpm_runtime_mark_last_busy(hdq_data->dev);\n\tpm_runtime_put_autosuspend(hdq_data->dev);\n\n\treturn val;\n}\n\n \nstatic void omap_w1_write_byte(void *_hdq, u8 byte)\n{\n\tstruct hdq_data *hdq_data = _hdq;\n\tint ret;\n\tu8 status;\n\n\tret = pm_runtime_get_sync(hdq_data->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(hdq_data->dev);\n\n\t\treturn;\n\t}\n\n\t \n\tif (byte == W1_SKIP_ROM)\n\t\tomap_hdq_break(hdq_data);\n\n\tret = hdq_write_byte(hdq_data, byte, &status);\n\tif (ret < 0) {\n\t\tdev_dbg(hdq_data->dev, \"TX failure:Ctrl status %x\\n\", status);\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tpm_runtime_mark_last_busy(hdq_data->dev);\n\tpm_runtime_put_autosuspend(hdq_data->dev);\n}\n\nstatic struct w1_bus_master omap_w1_master = {\n\t.read_byte\t= omap_w1_read_byte,\n\t.write_byte\t= omap_w1_write_byte,\n\t.reset_bus\t= omap_w1_reset_bus,\n};\n\nstatic int __maybe_unused omap_hdq_runtime_suspend(struct device *dev)\n{\n\tstruct hdq_data *hdq_data = dev_get_drvdata(dev);\n\n\thdq_reg_out(hdq_data, 0, hdq_data->mode);\n\thdq_reg_in(hdq_data, OMAP_HDQ_INT_STATUS);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_hdq_runtime_resume(struct device *dev)\n{\n\tstruct hdq_data *hdq_data = dev_get_drvdata(dev);\n\n\t \n\thdq_reg_out(hdq_data, OMAP_HDQ_CTRL_STATUS,\n\t\t    OMAP_HDQ_CTRL_STATUS_CLOCKENABLE |\n\t\t    OMAP_HDQ_CTRL_STATUS_INTERRUPTMASK |\n\t\t    hdq_data->mode);\n\thdq_reg_in(hdq_data, OMAP_HDQ_INT_STATUS);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_hdq_pm_ops = {\n\tSET_RUNTIME_PM_OPS(omap_hdq_runtime_suspend,\n\t\t\t   omap_hdq_runtime_resume, NULL)\n};\n\nstatic int omap_hdq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hdq_data *hdq_data;\n\tint ret, irq;\n\tu8 rev;\n\tconst char *mode;\n\n\thdq_data = devm_kzalloc(dev, sizeof(*hdq_data), GFP_KERNEL);\n\tif (!hdq_data)\n\t\treturn -ENOMEM;\n\n\thdq_data->dev = dev;\n\tplatform_set_drvdata(pdev, hdq_data);\n\n\thdq_data->hdq_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdq_data->hdq_base))\n\t\treturn PTR_ERR(hdq_data->hdq_base);\n\n\tmutex_init(&hdq_data->hdq_mutex);\n\n\tret = of_property_read_string(pdev->dev.of_node, \"ti,mode\", &mode);\n\tif (ret < 0 || !strcmp(mode, \"hdq\")) {\n\t\thdq_data->mode = 0;\n\t\tomap_w1_master.search = omap_w1_search_bus;\n\t} else {\n\t\thdq_data->mode = 1;\n\t\tomap_w1_master.triplet = omap_w1_triplet;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 300);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t\tdev_dbg(&pdev->dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_w1;\n\t}\n\n\trev = hdq_reg_in(hdq_data, OMAP_HDQ_REVISION);\n\tdev_info(&pdev->dev, \"OMAP HDQ Hardware Rev %c.%c. Driver in %s mode\\n\",\n\t\t(rev >> 4) + '0', (rev & 0x0f) + '0', \"Interrupt\");\n\n\tspin_lock_init(&hdq_data->hdq_spinlock);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq\t< 0) {\n\t\tdev_dbg(&pdev->dev, \"Failed to get IRQ: %d\\n\", irq);\n\t\tret = irq;\n\t\tgoto err_irq;\n\t}\n\n\tret = devm_request_irq(dev, irq, hdq_isr, 0, \"omap_hdq\", hdq_data);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"could not request irq\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tomap_hdq_break(hdq_data);\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tomap_w1_master.data = hdq_data;\n\n\tret = w1_add_master_device(&omap_w1_master);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"Failure in registering w1 master\\n\");\n\t\tgoto err_w1;\n\t}\n\n\treturn 0;\n\nerr_irq:\n\tpm_runtime_put_sync(&pdev->dev);\nerr_w1:\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int omap_hdq_remove(struct platform_device *pdev)\n{\n\tint active;\n\n\tactive = pm_runtime_get_sync(&pdev->dev);\n\tif (active < 0)\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\tw1_remove_master_device(&omap_w1_master);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tif (active >= 0)\n\t\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id omap_hdq_dt_ids[] = {\n\t{ .compatible = \"ti,omap3-1w\" },\n\t{ .compatible = \"ti,am4372-hdq\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, omap_hdq_dt_ids);\n\nstatic struct platform_driver omap_hdq_driver = {\n\t.probe = omap_hdq_probe,\n\t.remove = omap_hdq_remove,\n\t.driver = {\n\t\t.name =\t\"omap_hdq\",\n\t\t.of_match_table = omap_hdq_dt_ids,\n\t\t.pm = &omap_hdq_pm_ops,\n\t},\n};\nmodule_platform_driver(omap_hdq_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"HDQ-1W driver Library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}