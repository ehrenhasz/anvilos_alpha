{
  "module_name": "w1_ds2405.c",
  "hash_id": "126b47d3e05ff94013ab5da34ea2def0f55d24f333362e48b66610d469330359",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2405.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS2405\t0x05\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maciej S. Szmigiero <mail@maciej.szmigiero.name>\");\nMODULE_DESCRIPTION(\"Driver for 1-wire Dallas DS2405 PIO.\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2405));\n\nstatic int w1_ds2405_select(struct w1_slave *sl, bool only_active)\n{\n\tstruct w1_master *dev = sl->master;\n\n\tu64 dev_addr = le64_to_cpu(*(u64 *)&sl->reg_num);\n\tunsigned int bit_ctr;\n\n\tif (w1_reset_bus(dev) != 0)\n\t\treturn 0;\n\n\t \n\tw1_write_8(dev, only_active ? W1_ALARM_SEARCH : W1_SEARCH);\n\n\tfor (bit_ctr = 0; bit_ctr < 64; bit_ctr++) {\n\t\tint bit2send = !!(dev_addr & BIT(bit_ctr));\n\t\tu8 ret;\n\n\t\tret = w1_triplet(dev, bit2send);\n\n\t\tif ((ret & (BIT(0) | BIT(1))) ==\n\t\t    (BIT(0) | BIT(1)))  \n\t\t\treturn 0;\n\n\t\tif (!!(ret & BIT(2)) != bit2send)\n\t\t\t \n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int w1_ds2405_read_pio(struct w1_slave *sl)\n{\n\tif (w1_ds2405_select(sl, true))\n\t\treturn 0;  \n\n\tif (w1_ds2405_select(sl, false))\n\t\treturn 1;\n\n\treturn -ENODEV;\n}\n\nstatic ssize_t state_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct w1_master *dev = sl->master;\n\n\tint ret;\n\tssize_t f_retval;\n\tu8 state;\n\n\tret = mutex_lock_interruptible(&dev->bus_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!w1_ds2405_select(sl, false)) {\n\t\tf_retval = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tstate = w1_read_8(dev);\n\tif (state != 0 &&\n\t    state != 0xff) {\n\t\tdev_err(device, \"non-consistent state %x\\n\", state);\n\t\tf_retval = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t*buf = state ? '1' : '0';\n\tf_retval = 1;\n\nout_unlock:\n\tw1_reset_bus(dev);\n\tmutex_unlock(&dev->bus_mutex);\n\n\treturn f_retval;\n}\n\nstatic ssize_t output_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct w1_master *dev = sl->master;\n\n\tint ret;\n\tssize_t f_retval;\n\n\tret = mutex_lock_interruptible(&dev->bus_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = w1_ds2405_read_pio(sl);\n\tif (ret < 0) {\n\t\tf_retval = ret;\n\t\tgoto out_unlock;\n\t}\n\n\t*buf = ret ? '1' : '0';\n\tf_retval = 1;\n\nout_unlock:\n\tw1_reset_bus(dev);\n\tmutex_unlock(&dev->bus_mutex);\n\n\treturn f_retval;\n}\n\nstatic ssize_t output_store(struct device *device,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct w1_master *dev = sl->master;\n\n\tint ret, current_pio;\n\tunsigned int val;\n\tssize_t f_retval;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \" %u%n\", &val, &ret) < 1)\n\t\treturn -EINVAL;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tf_retval = ret;\n\n\tret = mutex_lock_interruptible(&dev->bus_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tcurrent_pio = w1_ds2405_read_pio(sl);\n\tif (current_pio < 0) {\n\t\tf_retval = current_pio;\n\t\tgoto out_unlock;\n\t}\n\n\tif (current_pio == val)\n\t\tgoto out_unlock;\n\n\tif (w1_reset_bus(dev) != 0) {\n\t\tf_retval = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tdo {\n\t\tu64 dev_addr = le64_to_cpu(*(u64 *)&sl->reg_num);\n\t\tu8 cmd[9];\n\n\t\tcmd[0] = W1_MATCH_ROM;\n\t\tmemcpy(&cmd[1], &dev_addr, sizeof(dev_addr));\n\n\t\tw1_write_block(dev, cmd, sizeof(cmd));\n\t} while (0);\n\nout_unlock:\n\tw1_reset_bus(dev);\n\tmutex_unlock(&dev->bus_mutex);\n\n\treturn f_retval;\n}\n\nstatic DEVICE_ATTR_RO(state);\nstatic DEVICE_ATTR_RW(output);\n\nstatic struct attribute *w1_ds2405_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_output.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(w1_ds2405);\n\nstatic const struct w1_family_ops w1_ds2405_fops = {\n\t.groups = w1_ds2405_groups\n};\n\nstatic struct w1_family w1_family_ds2405 = {\n\t.fid = W1_FAMILY_DS2405,\n\t.fops = &w1_ds2405_fops\n};\n\nmodule_w1_family(w1_family_ds2405);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}