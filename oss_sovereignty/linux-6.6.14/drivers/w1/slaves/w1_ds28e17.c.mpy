{
  "module_name": "w1_ds28e17.c",
  "hash_id": "28aaedfec37b1be3a6cc30a869e349967be564baa553b6cb0c0898acb3210bec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds28e17.c",
  "human_readable_source": "\n \n\n#include <linux/crc16.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#define CRC16_INIT 0\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS28E17 0x19\n\n \nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jan Kandziora <jjj@gmx.de>\");\nMODULE_DESCRIPTION(\"w1 family 19 driver for DS28E17, 1-wire to I2C master bridge\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS28E17));\n\n\n \nstatic int i2c_speed = 100;\nmodule_param_named(speed, i2c_speed, int, 0600);\nMODULE_PARM_DESC(speed, \"Default I2C speed to be set when a DS28E17 is detected\");\n\n \nstatic char i2c_stretch = 1;\nmodule_param_named(stretch, i2c_stretch, byte, 0600);\nMODULE_PARM_DESC(stretch, \"Default I2C stretch value to be set when a DS28E17 is detected\");\n\n \n#define W1_F19_WRITE_DATA_WITH_STOP      0x4B\n#define W1_F19_WRITE_DATA_NO_STOP        0x5A\n#define W1_F19_WRITE_DATA_ONLY           0x69\n#define W1_F19_WRITE_DATA_ONLY_WITH_STOP 0x78\n#define W1_F19_READ_DATA_WITH_STOP       0x87\n#define W1_F19_WRITE_READ_DATA_WITH_STOP 0x2D\n#define W1_F19_WRITE_CONFIGURATION       0xD2\n#define W1_F19_READ_CONFIGURATION        0xE1\n#define W1_F19_ENABLE_SLEEP_MODE         0x1E\n#define W1_F19_READ_DEVICE_REVISION      0xC4\n\n \n#define W1_F19_STATUS_CRC     0x01\n#define W1_F19_STATUS_ADDRESS 0x02\n#define W1_F19_STATUS_START   0x08\n\n \n#define W1_F19_WRITE_DATA_LIMIT 255\n\n \n#define W1_F19_READ_DATA_LIMIT 255\n\n \n#define W1_F19_BUSY_TIMEBASES { 90, 23, 10 }\n#define W1_F19_BUSY_GRATUITY  1000\n\n \n#define W1_F19_BUSY_CHECKS 1000\n\n\n \nstruct w1_f19_data {\n\tu8 speed;\n\tu8 stretch;\n\tstruct i2c_adapter adapter;\n};\n\n\n \nstatic int w1_f19_i2c_busy_wait(struct w1_slave *sl, size_t count)\n{\n\tconst unsigned long timebases[3] = W1_F19_BUSY_TIMEBASES;\n\tstruct w1_f19_data *data = sl->family_data;\n\tunsigned int checks;\n\n\t \n\tif (w1_touch_bit(sl->master, 1) == 0)\n\t\treturn 0;\n\n\t \n\tusleep_range(timebases[data->speed] * (data->stretch) * count,\n\t\ttimebases[data->speed] * (data->stretch) * count\n\t\t+ W1_F19_BUSY_GRATUITY);\n\n\t \n\tchecks = W1_F19_BUSY_CHECKS;\n\twhile ((checks--) > 0) {\n\t\t \n\t\tif (w1_touch_bit(sl->master, 1) == 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tudelay(timebases[data->speed]);\n\t}\n\n\t \n\tdev_warn(&sl->dev, \"busy timeout\\n\");\n\treturn -ETIMEDOUT;\n}\n\n\n \nstatic size_t w1_f19_error(struct w1_slave *sl, u8 w1_buf[])\n{\n\t \n\tif (w1_buf[0] & W1_F19_STATUS_CRC)\n\t\tdev_warn(&sl->dev, \"crc16 mismatch\\n\");\n\tif (w1_buf[0] & W1_F19_STATUS_ADDRESS)\n\t\tdev_warn(&sl->dev, \"i2c device not responding\\n\");\n\tif ((w1_buf[0] & (W1_F19_STATUS_CRC | W1_F19_STATUS_ADDRESS)) == 0\n\t\t\t&& w1_buf[1] != 0) {\n\t\tdev_warn(&sl->dev, \"i2c short write, %d bytes not acknowledged\\n\",\n\t\t\tw1_buf[1]);\n\t}\n\n\t \n\tif (w1_buf[0] & W1_F19_STATUS_ADDRESS)\n\t\treturn -ENXIO;\n\tif (w1_buf[0] & W1_F19_STATUS_START)\n\t\treturn -EAGAIN;\n\tif (w1_buf[0] != 0 || w1_buf[1] != 0)\n\t\treturn -EIO;\n\n\t \n\treturn 0;\n}\n\n\n \nstatic int __w1_f19_i2c_write(struct w1_slave *sl,\n\tconst u8 *command, size_t command_count,\n\tconst u8 *buffer, size_t count)\n{\n\tu16 crc;\n\tint error;\n\tu8 w1_buf[2];\n\n\t \n\tcrc = crc16(CRC16_INIT, command, command_count);\n\tw1_write_block(sl->master, command, command_count);\n\n\tw1_buf[0] = count;\n\tcrc = crc16(crc, w1_buf, 1);\n\tw1_write_8(sl->master, w1_buf[0]);\n\n\tcrc = crc16(crc, buffer, count);\n\tw1_write_block(sl->master, buffer, count);\n\n\tw1_buf[0] = ~(crc & 0xFF);\n\tw1_buf[1] = ~((crc >> 8) & 0xFF);\n\tw1_write_block(sl->master, w1_buf, 2);\n\n\t \n\tif (w1_f19_i2c_busy_wait(sl, count + 1) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tw1_read_block(sl->master, w1_buf, 2);\n\n\t \n\terror = w1_f19_error(sl, w1_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\treturn count;\n}\n\n\n \nstatic int w1_f19_i2c_write(struct w1_slave *sl, u16 i2c_address,\n\tconst u8 *buffer, size_t count, bool stop)\n{\n\tint result;\n\tint remaining = count;\n\tconst u8 *p;\n\tu8 command[2];\n\n\t \n\tif (count == 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (count <= W1_F19_WRITE_DATA_LIMIT) {\n\t\t \n\n\t\t \n\t\tcommand[0] = (stop ? W1_F19_WRITE_DATA_WITH_STOP\n\t\t\t: W1_F19_WRITE_DATA_NO_STOP);\n\t\tcommand[1] = i2c_address << 1;\n\t\tresult = __w1_f19_i2c_write(sl, command, 2, buffer, count);\n\t} else {\n\t\t \n\n\t\t \n\t\tp = buffer;\n\t\tcommand[0] = W1_F19_WRITE_DATA_NO_STOP;\n\t\tcommand[1] = i2c_address << 1;\n\t\tresult = __w1_f19_i2c_write(sl, command, 2, p,\n\t\t\tW1_F19_WRITE_DATA_LIMIT);\n\t\tif (result < 0)\n\t\t\treturn result;\n\n\t\t \n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tp += W1_F19_WRITE_DATA_LIMIT;\n\t\tremaining -= W1_F19_WRITE_DATA_LIMIT;\n\n\t\twhile (remaining > W1_F19_WRITE_DATA_LIMIT) {\n\t\t\t \n\t\t\tcommand[0] = W1_F19_WRITE_DATA_ONLY;\n\t\t\tresult = __w1_f19_i2c_write(sl, command, 1, p,\n\t\t\t\t\tW1_F19_WRITE_DATA_LIMIT);\n\t\t\tif (result < 0)\n\t\t\t\treturn result;\n\n\t\t\t \n\t\t\tif (w1_reset_resume_command(sl->master))\n\t\t\t\treturn -EIO;\n\n\t\t\t \n\t\t\tp += W1_F19_WRITE_DATA_LIMIT;\n\t\t\tremaining -= W1_F19_WRITE_DATA_LIMIT;\n\t\t}\n\n\t\t \n\t\tcommand[0] = (stop ? W1_F19_WRITE_DATA_ONLY_WITH_STOP\n\t\t\t: W1_F19_WRITE_DATA_ONLY);\n\t\tresult = __w1_f19_i2c_write(sl, command, 1, p, remaining);\n\t}\n\n\treturn result;\n}\n\n\n \nstatic int w1_f19_i2c_read(struct w1_slave *sl, u16 i2c_address,\n\tu8 *buffer, size_t count)\n{\n\tu16 crc;\n\tint error;\n\tu8 w1_buf[5];\n\n\t \n\tif (count == 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tw1_buf[0] = W1_F19_READ_DATA_WITH_STOP;\n\tw1_buf[1] = i2c_address << 1 | 0x01;\n\tw1_buf[2] = count;\n\tcrc = crc16(CRC16_INIT, w1_buf, 3);\n\tw1_buf[3] = ~(crc & 0xFF);\n\tw1_buf[4] = ~((crc >> 8) & 0xFF);\n\tw1_write_block(sl->master, w1_buf, 5);\n\n\t \n\tif (w1_f19_i2c_busy_wait(sl, count + 1) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tw1_buf[0] = w1_read_8(sl->master);\n\tw1_buf[1] = 0;\n\n\t \n\terror = w1_f19_error(sl, w1_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\treturn w1_read_block(sl->master, buffer, count);\n}\n\n\n \nstatic int w1_f19_i2c_write_read(struct w1_slave *sl, u16 i2c_address,\n\tconst u8 *wbuffer, size_t wcount, u8 *rbuffer, size_t rcount)\n{\n\tu16 crc;\n\tint error;\n\tu8 w1_buf[3];\n\n\t \n\tif (wcount == 0 || rcount == 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tw1_buf[0] = W1_F19_WRITE_READ_DATA_WITH_STOP;\n\tw1_buf[1] = i2c_address << 1;\n\tw1_buf[2] = wcount;\n\tcrc = crc16(CRC16_INIT, w1_buf, 3);\n\tw1_write_block(sl->master, w1_buf, 3);\n\n\tcrc = crc16(crc, wbuffer, wcount);\n\tw1_write_block(sl->master, wbuffer, wcount);\n\n\tw1_buf[0] = rcount;\n\tcrc = crc16(crc, w1_buf, 1);\n\tw1_buf[1] = ~(crc & 0xFF);\n\tw1_buf[2] = ~((crc >> 8) & 0xFF);\n\tw1_write_block(sl->master, w1_buf, 3);\n\n\t \n\tif (w1_f19_i2c_busy_wait(sl, wcount + rcount + 2) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tw1_read_block(sl->master, w1_buf, 2);\n\n\t \n\terror = w1_f19_error(sl, w1_buf);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\treturn w1_read_block(sl->master, rbuffer, rcount);\n}\n\n\n \nstatic int w1_f19_i2c_master_transfer(struct i2c_adapter *adapter,\n\tstruct i2c_msg *msgs, int num)\n{\n\tstruct w1_slave *sl = (struct w1_slave *) adapter->algo_data;\n\tint i = 0;\n\tint result = 0;\n\n\t \n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tif (w1_reset_select_slave(sl)) {\n\t\ti = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\twhile (i < num) {\n\t\t \n\t\tif (i < (num-1)\n\t\t\t&& msgs[i].addr == msgs[i+1].addr\n\t\t\t&& !(msgs[i].flags & I2C_M_RD)\n\t\t\t&& (msgs[i+1].flags & I2C_M_RD)\n\t\t\t&& (msgs[i].len <= W1_F19_WRITE_DATA_LIMIT)) {\n\t\t\t \n\t\t\tresult = w1_f19_i2c_write_read(sl, msgs[i].addr,\n\t\t\t\tmsgs[i].buf, msgs[i].len,\n\t\t\t\tmsgs[i+1].buf, msgs[i+1].len);\n\t\t\tif (result < 0) {\n\t\t\t\ti = result;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (msgs[i+1].flags & I2C_M_RECV_LEN) {\n\t\t\t\tresult = w1_f19_i2c_read(sl, msgs[i+1].addr,\n\t\t\t\t\t&(msgs[i+1].buf[1]), msgs[i+1].buf[0]);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\ti = result;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\ti++;\n\t\t} else if (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tresult = w1_f19_i2c_read(sl, msgs[i].addr,\n\t\t\t\tmsgs[i].buf, msgs[i].len);\n\t\t\tif (result < 0) {\n\t\t\t\ti = result;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (msgs[i].flags & I2C_M_RECV_LEN) {\n\t\t\t\tresult = w1_f19_i2c_read(sl,\n\t\t\t\t\tmsgs[i].addr,\n\t\t\t\t\t&(msgs[i].buf[1]),\n\t\t\t\t\tmsgs[i].buf[0]);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\ti = result;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tresult = w1_f19_i2c_write(sl,\n\t\t\t\tmsgs[i].addr,\n\t\t\t\tmsgs[i].buf,\n\t\t\t\tmsgs[i].len,\n\t\t\t\ti == (num-1));\n\t\t\tif (result < 0) {\n\t\t\t\ti = result;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti++;\n\n\t\t \n\t\tif (i < num) {\n\t\t\t \n\t\t\tif (w1_reset_resume_command(sl->master)) {\n\t\t\t\ti = -EIO;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\nerror:\n\t \n\tmutex_unlock(&sl->master->bus_mutex);\n\n\t \n\treturn i;\n}\n\n\n \nstatic u32 w1_f19_i2c_functionality(struct i2c_adapter *adapter)\n{\n\t \n\treturn I2C_FUNC_I2C |\n\t\tI2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_WRITE_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK |\n\t\tI2C_FUNC_SMBUS_PEC;\n}\n\n\n \nstatic const struct i2c_adapter_quirks w1_f19_i2c_adapter_quirks = {\n\t.max_read_len = W1_F19_READ_DATA_LIMIT,\n};\n\n \nstatic const struct i2c_algorithm w1_f19_i2c_algorithm = {\n\t.master_xfer    = w1_f19_i2c_master_transfer,\n\t.functionality  = w1_f19_i2c_functionality,\n};\n\n\n \nstatic int w1_f19_get_i2c_speed(struct w1_slave *sl)\n{\n\tstruct w1_f19_data *data = sl->family_data;\n\tint result = -EIO;\n\n\t \n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\tgoto error;\n\n\t \n\tw1_write_8(sl->master, W1_F19_READ_CONFIGURATION);\n\tresult = w1_read_8(sl->master);\n\tif (result < 0 || result > 2) {\n\t\tresult = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\tdata->speed = result;\n\nerror:\n\t \n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn result;\n}\n\n\n \nstatic int __w1_f19_set_i2c_speed(struct w1_slave *sl, u8 speed)\n{\n\tstruct w1_f19_data *data = sl->family_data;\n\tconst int i2c_speeds[3] = { 100, 400, 900 };\n\tu8 w1_buf[2];\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -EIO;\n\n\tw1_buf[0] = W1_F19_WRITE_CONFIGURATION;\n\tw1_buf[1] = speed;\n\tw1_write_block(sl->master, w1_buf, 2);\n\n\t \n\tdata->speed = speed;\n\n\tdev_info(&sl->dev, \"i2c speed set to %d kBaud\\n\", i2c_speeds[speed]);\n\n\treturn 0;\n}\n\nstatic int w1_f19_set_i2c_speed(struct w1_slave *sl, u8 speed)\n{\n\tint result;\n\n\t \n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tresult = __w1_f19_set_i2c_speed(sl, speed);\n\n\t \n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn result;\n}\n\n\n \n\n \nstatic ssize_t speed_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\tint result;\n\n\t \n\tresult = w1_f19_get_i2c_speed(sl);\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\treturn sprintf(buf, \"%d\\n\", result);\n}\n\nstatic ssize_t speed_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\tint error;\n\n\t \n\tif (count < 3 || count > 4 || !buf)\n\t\treturn -EINVAL;\n\tif (count == 4 && buf[3] != '\\n')\n\t\treturn -EINVAL;\n\tif (buf[1] != '0' || buf[2] != '0')\n\t\treturn -EINVAL;\n\n\t \n\tswitch (buf[0]) {\n\tcase '1':\n\t\terror = w1_f19_set_i2c_speed(sl, 0);\n\t\tbreak;\n\tcase '4':\n\t\terror = w1_f19_set_i2c_speed(sl, 1);\n\t\tbreak;\n\tcase '9':\n\t\terror = w1_f19_set_i2c_speed(sl, 2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(speed);\n\n\n \nstatic ssize_t stretch_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\tstruct w1_f19_data *data = sl->family_data;\n\n\t \n\treturn sprintf(buf, \"%d\\n\", data->stretch);\n}\n\nstatic ssize_t stretch_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(dev);\n\tstruct w1_f19_data *data = sl->family_data;\n\n\t \n\tif (count < 1 || count > 2 || !buf)\n\t\treturn -EINVAL;\n\tif (count == 2 && buf[1] != '\\n')\n\t\treturn -EINVAL;\n\tif (buf[0] < '1' || buf[0] > '9')\n\t\treturn -EINVAL;\n\n\t \n\tdata->stretch = buf[0] & 0x0F;\n\n\t \n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(stretch);\n\n\n \nstatic struct attribute *w1_f19_attrs[] = {\n\t&dev_attr_speed.attr,\n\t&dev_attr_stretch.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f19_group = {\n\t.attrs\t\t= w1_f19_attrs,\n};\n\nstatic const struct attribute_group *w1_f19_groups[] = {\n\t&w1_f19_group,\n\tNULL,\n};\n\n\n \nstatic int w1_f19_add_slave(struct w1_slave *sl)\n{\n\tstruct w1_f19_data *data = NULL;\n\n\t \n\tdata = devm_kzalloc(&sl->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tsl->family_data = data;\n\n\t \n\tswitch (i2c_speed) {\n\tcase 100:\n\t\t__w1_f19_set_i2c_speed(sl, 0);\n\t\tbreak;\n\tcase 400:\n\t\t__w1_f19_set_i2c_speed(sl, 1);\n\t\tbreak;\n\tcase 900:\n\t\t__w1_f19_set_i2c_speed(sl, 2);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdata->speed = 1;\n\t}\n\n\t \n\tdata->stretch = i2c_stretch;\n\n\t \n\tdata->adapter.owner      = THIS_MODULE;\n\tdata->adapter.algo       = &w1_f19_i2c_algorithm;\n\tdata->adapter.algo_data  = sl;\n\tstrcpy(data->adapter.name, \"w1-\");\n\tstrcat(data->adapter.name, sl->name);\n\tdata->adapter.dev.parent = &sl->dev;\n\tdata->adapter.quirks     = &w1_f19_i2c_adapter_quirks;\n\n\treturn i2c_add_adapter(&data->adapter);\n}\n\nstatic void w1_f19_remove_slave(struct w1_slave *sl)\n{\n\tstruct w1_f19_data *family_data = sl->family_data;\n\n\t \n\ti2c_del_adapter(&family_data->adapter);\n\n\t \n\tdevm_kfree(&sl->dev, family_data);\n\tsl->family_data = NULL;\n}\n\n\n \nstatic const struct w1_family_ops w1_f19_fops = {\n\t.add_slave = w1_f19_add_slave,\n\t.remove_slave = w1_f19_remove_slave,\n\t.groups = w1_f19_groups,\n};\n\nstatic struct w1_family w1_family_19 = {\n\t.fid = W1_FAMILY_DS28E17,\n\t.fops = &w1_f19_fops,\n};\n\nmodule_w1_family(w1_family_19);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}