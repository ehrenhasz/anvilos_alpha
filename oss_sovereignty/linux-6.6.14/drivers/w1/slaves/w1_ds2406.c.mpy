{
  "module_name": "w1_ds2406.c",
  "hash_id": "dd6ec5fb465aa28bfddd24426bf44f25063a5aa3456a7e3ab4620e818b52f738",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2406.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/crc16.h>\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS2406\t0x12\n\n#define W1_F12_FUNC_READ_STATUS\t\t   0xAA\n#define W1_F12_FUNC_WRITE_STATUS\t   0x55\n\nstatic ssize_t w1_f12_read_state(\n\tstruct file *filp, struct kobject *kobj,\n\tstruct bin_attribute *bin_attr,\n\tchar *buf, loff_t off, size_t count)\n{\n\tu8 w1_buf[6] = {W1_F12_FUNC_READ_STATUS, 7, 0, 0, 0, 0};\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu16 crc = 0;\n\tint i;\n\tssize_t rtnval = 1;\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl)) {\n\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\treturn -EIO;\n\t}\n\n\tw1_write_block(sl->master, w1_buf, 3);\n\tw1_read_block(sl->master, w1_buf+3, 3);\n\tfor (i = 0; i < 6; i++)\n\t\tcrc = crc16_byte(crc, w1_buf[i]);\n\tif (crc == 0xb001)  \n\t\t*buf = ((w1_buf[3]>>5)&3)|0x30;\n\telse\n\t\trtnval = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn rtnval;\n}\n\nstatic ssize_t w1_f12_write_output(\n\tstruct file *filp, struct kobject *kobj,\n\tstruct bin_attribute *bin_attr,\n\tchar *buf, loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu8 w1_buf[6] = {W1_F12_FUNC_WRITE_STATUS, 7, 0, 0, 0, 0};\n\tu16 crc = 0;\n\tint i;\n\tssize_t rtnval = 1;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl)) {\n\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\treturn -EIO;\n\t}\n\n\tw1_buf[3] = (((*buf)&3)<<5)|0x1F;\n\tw1_write_block(sl->master, w1_buf, 4);\n\tw1_read_block(sl->master, w1_buf+4, 2);\n\tfor (i = 0; i < 6; i++)\n\t\tcrc = crc16_byte(crc, w1_buf[i]);\n\tif (crc == 0xb001)  \n\t\tw1_write_8(sl->master, 0xFF);\n\telse\n\t\trtnval = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn rtnval;\n}\n\n#define NB_SYSFS_BIN_FILES 2\nstatic struct bin_attribute w1_f12_sysfs_bin_files[NB_SYSFS_BIN_FILES] = {\n\t{\n\t\t.attr = {\n\t\t\t.name = \"state\",\n\t\t\t.mode = 0444,\n\t\t},\n\t\t.size = 1,\n\t\t.read = w1_f12_read_state,\n\t},\n\t{\n\t\t.attr = {\n\t\t\t.name = \"output\",\n\t\t\t.mode = 0664,\n\t\t},\n\t\t.size = 1,\n\t\t.write = w1_f12_write_output,\n\t}\n};\n\nstatic int w1_f12_add_slave(struct w1_slave *sl)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < NB_SYSFS_BIN_FILES && !err; ++i)\n\t\terr = sysfs_create_bin_file(\n\t\t\t&sl->dev.kobj,\n\t\t\t&(w1_f12_sysfs_bin_files[i]));\n\tif (err)\n\t\twhile (--i >= 0)\n\t\t\tsysfs_remove_bin_file(&sl->dev.kobj,\n\t\t\t\t&(w1_f12_sysfs_bin_files[i]));\n\treturn err;\n}\n\nstatic void w1_f12_remove_slave(struct w1_slave *sl)\n{\n\tint i;\n\n\tfor (i = NB_SYSFS_BIN_FILES - 1; i >= 0; --i)\n\t\tsysfs_remove_bin_file(&sl->dev.kobj,\n\t\t\t&(w1_f12_sysfs_bin_files[i]));\n}\n\nstatic const struct w1_family_ops w1_f12_fops = {\n\t.add_slave      = w1_f12_add_slave,\n\t.remove_slave   = w1_f12_remove_slave,\n};\n\nstatic struct w1_family w1_family_12 = {\n\t.fid = W1_FAMILY_DS2406,\n\t.fops = &w1_f12_fops,\n};\nmodule_w1_family(w1_family_12);\n\nMODULE_AUTHOR(\"Scott Alfter <scott@alfter.us>\");\nMODULE_DESCRIPTION(\"w1 family 12 driver for DS2406 2 Pin IO\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}