{
  "module_name": "w1_therm.c",
  "hash_id": "ffb003c4fc3c250d706fa1bd42c80cbed663c981b34fc338356663e3d42b1402",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_therm.c",
  "human_readable_source": "\n \n\n#include <asm/types.h>\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n\n#include <linux/w1.h>\n\n#define W1_THERM_DS18S20\t0x10\n#define W1_THERM_DS1822\t\t0x22\n#define W1_THERM_DS18B20\t0x28\n#define W1_THERM_DS1825\t\t0x3B\n#define W1_THERM_DS28EA00\t0x42\n\n \nstatic int w1_strong_pullup = 1;\nmodule_param_named(strong_pullup, w1_strong_pullup, int, 0);\n\n \nstatic u16 bulk_read_device_counter;  \n\n \n#define W1_RECALL_EEPROM\t0xB8\n\n \n#define W1_THERM_MAX_TRY\t\t5\n\n \n#define W1_THERM_RETRY_DELAY\t\t20\n\n \n#define W1_THERM_EEPROM_WRITE_DELAY\t10\n\n#define EEPROM_CMD_WRITE    \"save\"\t \n#define EEPROM_CMD_READ     \"restore\"\t \n#define BULK_TRIGGER_CMD    \"trigger\"\t \n\n#define MIN_TEMP\t-55\t \n#define MAX_TEMP\t125\t \n\n \n#define CONV_TIME_DEFAULT 0\n#define CONV_TIME_MEASURE 1\n\n \n#define W1_THERM_CHECK_RESULT 1\t \n#define W1_THERM_POLL_COMPLETION 2\t \n#define W1_THERM_FEATURES_MASK 3\t\t \n\n \n#define W1_POLL_PERIOD 32\n#define W1_POLL_CONVERT_TEMP 2000\t \n#define W1_POLL_RECALL_EEPROM 500\t \n\n \n \n#define W1_THERM_RESOLUTION_MASK 0xE0\n \n#define W1_THERM_RESOLUTION_SHIFT 5\n \n#define W1_THERM_RESOLUTION_SHIFT 5\n \n#define W1_THERM_RESOLUTION_MIN 9\n \n#define W1_THERM_RESOLUTION_MAX 14\n\n \n\n \n#define SLAVE_SPECIFIC_FUNC(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->specific_functions)\n\n \n#define SLAVE_POWERMODE(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->external_powered)\n\n \n#define SLAVE_RESOLUTION(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->resolution)\n\n \n #define SLAVE_CONV_TIME_OVERRIDE(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->conv_time_override)\n\n \n #define SLAVE_FEATURES(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->features)\n\n \n#define SLAVE_CONVERT_TRIGGERED(sl) \\\n\t(((struct w1_therm_family_data *)(sl->family_data))->convert_triggered)\n\n \n#define THERM_REFCNT(family_data) \\\n\t(&((struct w1_therm_family_data *)family_data)->refcnt)\n\n \n\n \nstruct w1_therm_family_converter {\n\tu8\t\tbroken;\n\tu16\t\treserved;\n\tstruct w1_family\t*f;\n\tint\t\t(*convert)(u8 rom[9]);\n\tint\t\t(*get_conversion_time)(struct w1_slave *sl);\n\tint\t\t(*set_resolution)(struct w1_slave *sl, int val);\n\tint\t\t(*get_resolution)(struct w1_slave *sl);\n\tint\t\t(*write_data)(struct w1_slave *sl, const u8 *data);\n\tbool\t\tbulk_read;\n};\n\n \nstruct w1_therm_family_data {\n\tuint8_t rom[9];\n\tatomic_t refcnt;\n\tint external_powered;\n\tint resolution;\n\tint convert_triggered;\n\tint conv_time_override;\n\tunsigned int features;\n\tstruct w1_therm_family_converter *specific_functions;\n};\n\n \nstruct therm_info {\n\tu8 rom[9];\n\tu8 crc;\n\tu8 verdict;\n};\n\n \n\n \nstatic int reset_select_slave(struct w1_slave *sl);\n\n \nstatic int convert_t(struct w1_slave *sl, struct therm_info *info);\n\n \nstatic int read_scratchpad(struct w1_slave *sl, struct therm_info *info);\n\n \nstatic int write_scratchpad(struct w1_slave *sl, const u8 *data, u8 nb_bytes);\n\n \nstatic int copy_scratchpad(struct w1_slave *sl);\n\n \nstatic int recall_eeprom(struct w1_slave *sl);\n\n \nstatic int read_powermode(struct w1_slave *sl);\n\n \nstatic int trigger_bulk_read(struct w1_master *dev_master);\n\n \n\nstatic ssize_t w1_slave_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t w1_slave_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size);\n\nstatic ssize_t w1_seq_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t temperature_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t ext_power_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t resolution_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t resolution_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size);\n\nstatic ssize_t eeprom_cmd_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size);\n\nstatic ssize_t alarms_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size);\n\nstatic ssize_t alarms_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t therm_bulk_read_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size);\n\nstatic ssize_t therm_bulk_read_show(struct device *device,\n\tstruct device_attribute *attr, char *buf);\n\nstatic ssize_t conv_time_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf);\n\nstatic ssize_t conv_time_store(struct device *device,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t size);\n\nstatic ssize_t features_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf);\n\nstatic ssize_t features_store(struct device *device,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t size);\n \n\nstatic DEVICE_ATTR_RW(w1_slave);\nstatic DEVICE_ATTR_RO(w1_seq);\nstatic DEVICE_ATTR_RO(temperature);\nstatic DEVICE_ATTR_RO(ext_power);\nstatic DEVICE_ATTR_RW(resolution);\nstatic DEVICE_ATTR_WO(eeprom_cmd);\nstatic DEVICE_ATTR_RW(alarms);\nstatic DEVICE_ATTR_RW(conv_time);\nstatic DEVICE_ATTR_RW(features);\n\nstatic DEVICE_ATTR_RW(therm_bulk_read);  \n\n \n\n \nstatic int w1_therm_add_slave(struct w1_slave *sl);\n\n \nstatic void w1_therm_remove_slave(struct w1_slave *sl);\n\n \n\nstatic struct attribute *w1_therm_attrs[] = {\n\t&dev_attr_w1_slave.attr,\n\t&dev_attr_temperature.attr,\n\t&dev_attr_ext_power.attr,\n\t&dev_attr_resolution.attr,\n\t&dev_attr_eeprom_cmd.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_conv_time.attr,\n\t&dev_attr_features.attr,\n\tNULL,\n};\n\nstatic struct attribute *w1_ds18s20_attrs[] = {\n\t&dev_attr_w1_slave.attr,\n\t&dev_attr_temperature.attr,\n\t&dev_attr_ext_power.attr,\n\t&dev_attr_eeprom_cmd.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_conv_time.attr,\n\t&dev_attr_features.attr,\n\tNULL,\n};\n\nstatic struct attribute *w1_ds28ea00_attrs[] = {\n\t&dev_attr_w1_slave.attr,\n\t&dev_attr_w1_seq.attr,\n\t&dev_attr_temperature.attr,\n\t&dev_attr_ext_power.attr,\n\t&dev_attr_resolution.attr,\n\t&dev_attr_eeprom_cmd.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_conv_time.attr,\n\t&dev_attr_features.attr,\n\tNULL,\n};\n\n \n\nATTRIBUTE_GROUPS(w1_therm);\nATTRIBUTE_GROUPS(w1_ds18s20);\nATTRIBUTE_GROUPS(w1_ds28ea00);\n\n#if IS_REACHABLE(CONFIG_HWMON)\nstatic int w1_read_temp(struct device *dev, u32 attr, int channel,\n\t\t\tlong *val);\n\nstatic umode_t w1_is_visible(const void *_data, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel)\n{\n\treturn attr == hwmon_temp_input ? 0444 : 0;\n}\n\nstatic int w1_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t   u32 attr, int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn w1_read_temp(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const u32 w1_temp_config[] = {\n\tHWMON_T_INPUT,\n\t0\n};\n\nstatic const struct hwmon_channel_info w1_temp = {\n\t.type = hwmon_temp,\n\t.config = w1_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const w1_info[] = {\n\t&w1_temp,\n\tNULL\n};\n\nstatic const struct hwmon_ops w1_hwmon_ops = {\n\t.is_visible = w1_is_visible,\n\t.read = w1_read,\n};\n\nstatic const struct hwmon_chip_info w1_chip_info = {\n\t.ops = &w1_hwmon_ops,\n\t.info = w1_info,\n};\n#define W1_CHIPINFO\t(&w1_chip_info)\n#else\n#define W1_CHIPINFO\tNULL\n#endif\n\n \n\nstatic const struct w1_family_ops w1_therm_fops = {\n\t.add_slave\t= w1_therm_add_slave,\n\t.remove_slave\t= w1_therm_remove_slave,\n\t.groups\t\t= w1_therm_groups,\n\t.chip_info\t= W1_CHIPINFO,\n};\n\nstatic const struct w1_family_ops w1_ds18s20_fops = {\n\t.add_slave\t= w1_therm_add_slave,\n\t.remove_slave\t= w1_therm_remove_slave,\n\t.groups\t\t= w1_ds18s20_groups,\n\t.chip_info\t= W1_CHIPINFO,\n};\n\nstatic const struct w1_family_ops w1_ds28ea00_fops = {\n\t.add_slave\t= w1_therm_add_slave,\n\t.remove_slave\t= w1_therm_remove_slave,\n\t.groups\t\t= w1_ds28ea00_groups,\n\t.chip_info\t= W1_CHIPINFO,\n};\n\n \n\nstatic struct w1_family w1_therm_family_DS18S20 = {\n\t.fid = W1_THERM_DS18S20,\n\t.fops = &w1_ds18s20_fops,\n};\n\nstatic struct w1_family w1_therm_family_DS18B20 = {\n\t.fid = W1_THERM_DS18B20,\n\t.fops = &w1_therm_fops,\n};\n\nstatic struct w1_family w1_therm_family_DS1822 = {\n\t.fid = W1_THERM_DS1822,\n\t.fops = &w1_therm_fops,\n};\n\nstatic struct w1_family w1_therm_family_DS28EA00 = {\n\t.fid = W1_THERM_DS28EA00,\n\t.fops = &w1_ds28ea00_fops,\n};\n\nstatic struct w1_family w1_therm_family_DS1825 = {\n\t.fid = W1_THERM_DS1825,\n\t.fops = &w1_therm_fops,\n};\n\n \n\nstatic inline int w1_DS18B20_convert_time(struct w1_slave *sl)\n{\n\tint ret;\n\n\tif (!sl->family_data)\n\t\treturn -ENODEV;\t \n\n\tif (SLAVE_CONV_TIME_OVERRIDE(sl) != CONV_TIME_DEFAULT)\n\t\treturn SLAVE_CONV_TIME_OVERRIDE(sl);\n\n\t \n\tswitch (SLAVE_RESOLUTION(sl)) {\n\tcase 9:\n\t\tret = 95;\n\t\tbreak;\n\tcase 10:\n\t\tret = 190;\n\t\tbreak;\n\tcase 11:\n\t\tret = 375;\n\t\tbreak;\n\tcase 12:\n\t\tret = 750;\n\t\tbreak;\n\tcase 13:\n\t\tret = 850;   \n\t\tbreak;\n\tcase 14:\n\t\tret = 1600;  \n\t\tbreak;\n\tdefault:\n\t\tret = 750;\n\t}\n\treturn ret;\n}\n\nstatic inline int w1_DS18S20_convert_time(struct w1_slave *sl)\n{\n\tif (!sl->family_data)\n\t\treturn -ENODEV;\t \n\n\tif (SLAVE_CONV_TIME_OVERRIDE(sl) == CONV_TIME_DEFAULT)\n\t\treturn 750;  \n\telse\n\t\treturn SLAVE_CONV_TIME_OVERRIDE(sl);\n}\n\nstatic inline int w1_DS1825_convert_time(struct w1_slave *sl)\n{\n\tint ret;\n\n\tif (!sl->family_data)\n\t\treturn -ENODEV;\t \n\n\tif (SLAVE_CONV_TIME_OVERRIDE(sl) != CONV_TIME_DEFAULT)\n\t\treturn SLAVE_CONV_TIME_OVERRIDE(sl);\n\n\t \n\tswitch (SLAVE_RESOLUTION(sl)) {\n\tcase 9:\n\t\tret = 95;\n\t\tbreak;\n\tcase 10:\n\t\tret = 190;\n\t\tbreak;\n\tcase 11:\n\t\tret = 375;\n\t\tbreak;\n\tcase 12:\n\t\tret = 750;\n\t\tbreak;\n\tcase 14:\n\t\tret = 100;  \n\t\tbreak;\n\tdefault:\n\t\tret = 750;\n\t}\n\treturn ret;\n}\n\nstatic inline int w1_DS18B20_write_data(struct w1_slave *sl,\n\t\t\t\tconst u8 *data)\n{\n\treturn write_scratchpad(sl, data, 3);\n}\n\nstatic inline int w1_DS18S20_write_data(struct w1_slave *sl,\n\t\t\t\tconst u8 *data)\n{\n\t \n\treturn write_scratchpad(sl, data, 2);\n}\n\nstatic inline int w1_DS18B20_set_resolution(struct w1_slave *sl, int val)\n{\n\tint ret;\n\tstruct therm_info info, info2;\n\n\t \n\t \n\t \n\tif (val < W1_THERM_RESOLUTION_MIN || val > W1_THERM_RESOLUTION_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tval = (val - W1_THERM_RESOLUTION_MIN) << W1_THERM_RESOLUTION_SHIFT;\n\n\t \n\tret = read_scratchpad(sl, &info);\n\n\tif (ret)\n\t\treturn ret;\n\n\n\tinfo.rom[4] &= ~W1_THERM_RESOLUTION_MASK;\n\tinfo.rom[4] |= val;\n\n\t \n\tret = w1_DS18B20_write_data(sl, info.rom + 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = read_scratchpad(sl, &info2);\n\tif (ret)\n\t\t \n\t\treturn ret;\n\n\tif ((info2.rom[4] & W1_THERM_RESOLUTION_MASK) == (info.rom[4] & W1_THERM_RESOLUTION_MASK))\n\t\treturn 0;\n\n\t \n\treturn -EIO;\n}\n\nstatic inline int w1_DS18B20_get_resolution(struct w1_slave *sl)\n{\n\tint ret;\n\tint resolution;\n\tstruct therm_info info;\n\n\tret = read_scratchpad(sl, &info);\n\n\tif (ret)\n\t\treturn ret;\n\n\tresolution = ((info.rom[4] & W1_THERM_RESOLUTION_MASK) >> W1_THERM_RESOLUTION_SHIFT)\n\t\t+ W1_THERM_RESOLUTION_MIN;\n\t \n\tif (resolution > W1_THERM_RESOLUTION_MAX)\n\t\tresolution = W1_THERM_RESOLUTION_MAX;\n\n\treturn resolution;\n}\n\n \nstatic inline int w1_DS18B20_convert_temp(u8 rom[9])\n{\n\tu16 bv;\n\ts16 t;\n\n\t \n\tbv = le16_to_cpup((__le16 *)rom);\n\n\t \n\tif (rom[4] & 0x80) {\n\t\t \n\t\t \n\t\tbv = (bv << 2) | (rom[4] & 3);\n\t\tt = (s16) bv;\t \n\t\treturn (int)t * 1000 / 64;\t \n\t}\n\tt = (s16)bv;\t \n\treturn (int)t * 1000 / 16;\t \n}\n\n \nstatic inline int w1_DS18S20_convert_temp(u8 rom[9])\n{\n\tint t, h;\n\n\tif (!rom[7]) {\n\t\tpr_debug(\"%s: Invalid argument for conversion\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (rom[1] == 0)\n\t\tt = ((s32)rom[0] >> 1)*1000;\n\telse\n\t\tt = 1000*(-1*(s32)(0x100-rom[0]) >> 1);\n\n\tt -= 250;\n\th = 1000*((s32)rom[7] - (s32)rom[6]);\n\th /= (s32)rom[7];\n\tt += h;\n\n\treturn t;\n}\n\n \n\nstatic inline int w1_DS1825_convert_temp(u8 rom[9])\n{\n\tu16 bv;\n\ts16 t;\n\n\t \n\tbv = le16_to_cpup((__le16 *)rom);\n\n\t \n\tif (rom[4] & 0x80) {\n\t\t \n\t\t \n\t\tbv = (bv & 0xFFFC);  \n\t}\n\tt = (s16)bv;\t \n\treturn (int)t * 1000 / 16;\t \n}\n\n \n \n\nstatic struct w1_therm_family_converter w1_therm_families[] = {\n\t{\n\t\t.f\t\t\t\t= &w1_therm_family_DS18S20,\n\t\t.convert\t\t\t= w1_DS18S20_convert_temp,\n\t\t.get_conversion_time\t= w1_DS18S20_convert_time,\n\t\t.set_resolution\t\t= NULL,\t \n\t\t.get_resolution\t\t= NULL,\t \n\t\t.write_data\t\t\t= w1_DS18S20_write_data,\n\t\t.bulk_read\t\t\t= true\n\t},\n\t{\n\t\t.f\t\t\t\t= &w1_therm_family_DS1822,\n\t\t.convert\t\t\t= w1_DS18B20_convert_temp,\n\t\t.get_conversion_time\t= w1_DS18B20_convert_time,\n\t\t.set_resolution\t\t= w1_DS18B20_set_resolution,\n\t\t.get_resolution\t\t= w1_DS18B20_get_resolution,\n\t\t.write_data\t\t\t= w1_DS18B20_write_data,\n\t\t.bulk_read\t\t\t= true\n\t},\n\t{\n\t\t \n\t\t.f\t\t\t\t= &w1_therm_family_DS18B20,\n\t\t.convert\t\t\t= w1_DS18B20_convert_temp,\n\t\t.get_conversion_time\t= w1_DS18B20_convert_time,\n\t\t.set_resolution\t\t= w1_DS18B20_set_resolution,\n\t\t.get_resolution\t\t= w1_DS18B20_get_resolution,\n\t\t.write_data\t\t\t= w1_DS18B20_write_data,\n\t\t.bulk_read\t\t\t= true\n\t},\n\t{\n\t\t.f\t\t\t\t= &w1_therm_family_DS28EA00,\n\t\t.convert\t\t\t= w1_DS18B20_convert_temp,\n\t\t.get_conversion_time\t= w1_DS18B20_convert_time,\n\t\t.set_resolution\t\t= w1_DS18B20_set_resolution,\n\t\t.get_resolution\t\t= w1_DS18B20_get_resolution,\n\t\t.write_data\t\t\t= w1_DS18B20_write_data,\n\t\t.bulk_read\t\t\t= false\n\t},\n\t{\n\t\t \n\t\t.f\t\t\t\t= &w1_therm_family_DS1825,\n\t\t.convert\t\t\t= w1_DS1825_convert_temp,\n\t\t.get_conversion_time\t= w1_DS1825_convert_time,\n\t\t.set_resolution\t\t= w1_DS18B20_set_resolution,\n\t\t.get_resolution\t\t= w1_DS18B20_get_resolution,\n\t\t.write_data\t\t\t= w1_DS18B20_write_data,\n\t\t.bulk_read\t\t\t= true\n\t}\n};\n\n \n\n \nstatic struct w1_therm_family_converter *device_family(struct w1_slave *sl)\n{\n\tstruct w1_therm_family_converter *ret = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i) {\n\t\tif (w1_therm_families[i].f->fid == sl->family->fid) {\n\t\t\tret = &w1_therm_families[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic inline bool bus_mutex_lock(struct mutex *lock)\n{\n\tint max_trying = W1_THERM_MAX_TRY;\n\n\t \n\twhile (mutex_lock_interruptible(lock) != 0 && max_trying > 0) {\n\t\tunsigned long sleep_rem;\n\n\t\tsleep_rem = msleep_interruptible(W1_THERM_RETRY_DELAY);\n\t\tif (!sleep_rem)\n\t\t\tmax_trying--;\n\t}\n\n\tif (!max_trying)\n\t\treturn false;\t \n\n\treturn true;\n}\n\n \nstatic int check_family_data(struct w1_slave *sl)\n{\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(&sl->dev,\n\t\t\t \"%s: Device is not supported by the driver\\n\", __func__);\n\t\treturn -EINVAL;   \n\t}\n\treturn 0;\n}\n\n \nstatic inline bool bulk_read_support(struct w1_slave *sl)\n{\n\tif (SLAVE_SPECIFIC_FUNC(sl))\n\t\treturn SLAVE_SPECIFIC_FUNC(sl)->bulk_read;\n\n\tdev_info(&sl->dev,\n\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\n\treturn false;   \n}\n\n \nstatic inline int conversion_time(struct w1_slave *sl)\n{\n\tif (SLAVE_SPECIFIC_FUNC(sl))\n\t\treturn SLAVE_SPECIFIC_FUNC(sl)->get_conversion_time(sl);\n\n\tdev_info(&sl->dev,\n\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\n\treturn -ENODEV;   \n}\n\n \nstatic inline int temperature_from_RAM(struct w1_slave *sl, u8 rom[9])\n{\n\tif (SLAVE_SPECIFIC_FUNC(sl))\n\t\treturn SLAVE_SPECIFIC_FUNC(sl)->convert(rom);\n\n\tdev_info(&sl->dev,\n\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\n\treturn 0;   \n}\n\n \nstatic inline s8 int_to_short(int i)\n{\n\t \n\ti = clamp(i, MIN_TEMP, MAX_TEMP);\n\treturn (s8) i;\n}\n\n \n\nstatic int w1_therm_add_slave(struct w1_slave *sl)\n{\n\tstruct w1_therm_family_converter *sl_family_conv;\n\n\t \n\tsl->family_data = kzalloc(sizeof(struct w1_therm_family_data),\n\t\tGFP_KERNEL);\n\tif (!sl->family_data)\n\t\treturn -ENOMEM;\n\n\tatomic_set(THERM_REFCNT(sl->family_data), 1);\n\n\t \n\tsl_family_conv = device_family(sl);\n\tif (!sl_family_conv) {\n\t\tkfree(sl->family_data);\n\t\treturn -ENODEV;\n\t}\n\t \n\tSLAVE_SPECIFIC_FUNC(sl) = sl_family_conv;\n\n\tif (bulk_read_support(sl)) {\n\t\t \n\t\tif (!bulk_read_device_counter) {\n\t\t\tint err = device_create_file(&sl->master->dev,\n\t\t\t\t&dev_attr_therm_bulk_read);\n\n\t\t\tif (err)\n\t\t\t\tdev_warn(&sl->dev,\n\t\t\t\t\"%s: Device has been added, but bulk read is unavailable. err=%d\\n\",\n\t\t\t\t__func__, err);\n\t\t}\n\t\t \n\t\tbulk_read_device_counter++;\n\t}\n\n\t \n\tSLAVE_POWERMODE(sl) = read_powermode(sl);\n\n\tif (SLAVE_POWERMODE(sl) < 0) {\n\t\t \n\t\tdev_warn(&sl->dev,\n\t\t\t\"%s: Device has been added, but power_mode may be corrupted. err=%d\\n\",\n\t\t\t __func__, SLAVE_POWERMODE(sl));\n\t}\n\n\t \n\tif (SLAVE_SPECIFIC_FUNC(sl)->get_resolution) {\n\t\tSLAVE_RESOLUTION(sl) =\n\t\t\tSLAVE_SPECIFIC_FUNC(sl)->get_resolution(sl);\n\t\tif (SLAVE_RESOLUTION(sl) < 0) {\n\t\t\t \n\t\t\tdev_warn(&sl->dev,\n\t\t\t\t\"%s:Device has been added, but resolution may be corrupted. err=%d\\n\",\n\t\t\t\t__func__, SLAVE_RESOLUTION(sl));\n\t\t}\n\t}\n\n\t \n\tSLAVE_CONVERT_TRIGGERED(sl) = 0;\n\n\treturn 0;\n}\n\nstatic void w1_therm_remove_slave(struct w1_slave *sl)\n{\n\tint refcnt = atomic_sub_return(1, THERM_REFCNT(sl->family_data));\n\n\tif (bulk_read_support(sl)) {\n\t\tbulk_read_device_counter--;\n\t\t \n\t\tif (!bulk_read_device_counter)\n\t\t\tdevice_remove_file(&sl->master->dev,\n\t\t\t\t&dev_attr_therm_bulk_read);\n\t}\n\n\twhile (refcnt) {\n\t\tmsleep(1000);\n\t\trefcnt = atomic_read(THERM_REFCNT(sl->family_data));\n\t}\n\tkfree(sl->family_data);\n\tsl->family_data = NULL;\n}\n\n \n\n \nstatic int reset_select_slave(struct w1_slave *sl)\n{\n\tu8 match[9] = { W1_MATCH_ROM, };\n\tu64 rn = le64_to_cpu(*((u64 *)&sl->reg_num));\n\n\tif (w1_reset_bus(sl->master))\n\t\treturn -ENODEV;\n\n\tmemcpy(&match[1], &rn, 8);\n\tw1_write_block(sl->master, match, 9);\n\n\treturn 0;\n}\n\n \nstatic int w1_poll_completion(struct w1_master *dev_master, int tout_ms)\n{\n\tint i;\n\n\tfor (i = 0; i < tout_ms/W1_POLL_PERIOD; i++) {\n\t\t \n\t\tmsleep(W1_POLL_PERIOD);\n\n\t\t \n\t\tif (w1_read_8(dev_master) == 0xFF)\n\t\t\tbreak;\n\t}\n\tif (i == tout_ms/W1_POLL_PERIOD)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int convert_t(struct w1_slave *sl, struct therm_info *info)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint t_conv;\n\tint ret = -ENODEV;\n\tbool strong_pullup;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\tstrong_pullup = (w1_strong_pullup == 2 ||\n\t\t\t\t\t(!SLAVE_POWERMODE(sl) &&\n\t\t\t\t\tw1_strong_pullup));\n\n\tif (strong_pullup && SLAVE_FEATURES(sl) & W1_THERM_POLL_COMPLETION) {\n\t\tdev_warn(&sl->dev,\n\t\t\t\"%s: Disabling W1_THERM_POLL_COMPLETION in parasite power mode.\\n\",\n\t\t\t__func__);\n\t\tSLAVE_FEATURES(sl) &= ~W1_THERM_POLL_COMPLETION;\n\t}\n\n\t \n\tt_conv = conversion_time(sl);\n\n\tmemset(info->rom, 0, sizeof(info->rom));\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\n\t\tinfo->verdict = 0;\n\t\tinfo->crc = 0;\n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tunsigned long sleep_rem;\n\n\t\t\t \n\t\t\tif (strong_pullup)\n\t\t\t\tw1_next_pullup(dev_master, t_conv);\n\n\t\t\tw1_write_8(dev_master, W1_CONVERT_TEMP);\n\n\t\t\tif (SLAVE_FEATURES(sl) & W1_THERM_POLL_COMPLETION) {\n\t\t\t\tret = w1_poll_completion(dev_master, W1_POLL_CONVERT_TEMP);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_dbg(&sl->dev, \"%s: Timeout\\n\", __func__);\n\t\t\t\t\tgoto mt_unlock;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\t} else if (!strong_pullup) {  \n\t\t\t\tsleep_rem = msleep_interruptible(t_conv);\n\t\t\t\tif (sleep_rem != 0) {\n\t\t\t\t\tret = -EINTR;\n\t\t\t\t\tgoto mt_unlock;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\t} else {  \n\t\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\t\tsleep_rem = msleep_interruptible(t_conv);\n\t\t\t\tif (sleep_rem != 0) {\n\t\t\t\t\tret = -EINTR;\n\t\t\t\t\tgoto dec_refcnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = read_scratchpad(sl, info);\n\n\t\t\t \n\t\t\tif ((SLAVE_FEATURES(sl) & W1_THERM_CHECK_RESULT) &&\n\t\t\t\t(info->rom[6] == 0xC) &&\n\t\t\t\t((info->rom[1] == 0x5 && info->rom[0] == 0x50) ||\n\t\t\t\t(info->rom[1] == 0x7 && info->rom[0] == 0xFF))\n\t\t\t) {\n\t\t\t\t \n\t\t\t\tret = -EIO;\n\t\t\t}\n\n\t\t\tgoto dec_refcnt;\n\t\t}\n\n\t}\n\nmt_unlock:\n\tmutex_unlock(&dev_master->bus_mutex);\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int conv_time_measure(struct w1_slave *sl, int *conv_time)\n{\n\tstruct therm_info inf,\n\t\t*info = &inf;\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint ret = -ENODEV;\n\tbool strong_pullup;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\tstrong_pullup = (w1_strong_pullup == 2 ||\n\t\t(!SLAVE_POWERMODE(sl) &&\n\t\tw1_strong_pullup));\n\n\tif (strong_pullup) {\n\t\tpr_info(\"%s: Measure with strong_pullup is not supported.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(info->rom, 0, sizeof(info->rom));\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\t\tinfo->verdict = 0;\n\t\tinfo->crc = 0;\n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tint j_start, j_end;\n\n\t\t\t \n\t\t\tw1_write_8(dev_master, W1_CONVERT_TEMP);\n\n\t\t\tj_start = jiffies;\n\t\t\tret = w1_poll_completion(dev_master, W1_POLL_CONVERT_TEMP);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(&sl->dev, \"%s: Timeout\\n\", __func__);\n\t\t\t\tgoto mt_unlock;\n\t\t\t}\n\t\t\tj_end = jiffies;\n\t\t\t \n\t\t\t*conv_time = jiffies_to_msecs(j_end-j_start)*12/10;\n\t\t\tpr_debug(\"W1 Measure complete, conv_time = %d, HZ=%d.\\n\",\n\t\t\t\t*conv_time, HZ);\n\t\t\tif (*conv_time <= CONV_TIME_MEASURE) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto mt_unlock;\n\t\t\t}\n\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\tret = read_scratchpad(sl, info);\n\t\t\tgoto dec_refcnt;\n\t\t}\n\n\t}\nmt_unlock:\n\tmutex_unlock(&dev_master->bus_mutex);\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int read_scratchpad(struct w1_slave *sl, struct therm_info *info)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint ret = -ENODEV;\n\n\tinfo->verdict = 0;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\tmemset(info->rom, 0, sizeof(info->rom));\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tu8 nb_bytes_read;\n\n\t\t\tw1_write_8(dev_master, W1_READ_SCRATCHPAD);\n\n\t\t\tnb_bytes_read = w1_read_block(dev_master, info->rom, 9);\n\t\t\tif (nb_bytes_read != 9) {\n\t\t\t\tdev_warn(&sl->dev,\n\t\t\t\t\t\"w1_read_block(): returned %u instead of 9.\\n\",\n\t\t\t\t\tnb_bytes_read);\n\t\t\t\tret = -EIO;\n\t\t\t}\n\n\t\t\tinfo->crc = w1_calc_crc8(info->rom, 8);\n\n\t\t\tif (info->rom[8] == info->crc) {\n\t\t\t\tinfo->verdict = 1;\n\t\t\t\tret = 0;\n\t\t\t} else\n\t\t\t\tret = -EIO;  \n\t\t}\n\n\t}\n\tmutex_unlock(&dev_master->bus_mutex);\n\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int write_scratchpad(struct w1_slave *sl, const u8 *data, u8 nb_bytes)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint ret = -ENODEV;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tw1_write_8(dev_master, W1_WRITE_SCRATCHPAD);\n\t\t\tw1_write_block(dev_master, data, nb_bytes);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tmutex_unlock(&dev_master->bus_mutex);\n\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int copy_scratchpad(struct w1_slave *sl)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint t_write, ret = -ENODEV;\n\tbool strong_pullup;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\tt_write = W1_THERM_EEPROM_WRITE_DELAY;\n\tstrong_pullup = (w1_strong_pullup == 2 ||\n\t\t\t\t\t(!SLAVE_POWERMODE(sl) &&\n\t\t\t\t\tw1_strong_pullup));\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tunsigned long sleep_rem;\n\n\t\t\t \n\t\t\tif (strong_pullup)\n\t\t\t\tw1_next_pullup(dev_master, t_write);\n\n\t\t\tw1_write_8(dev_master, W1_COPY_SCRATCHPAD);\n\n\t\t\tif (strong_pullup) {\n\t\t\t\tsleep_rem = msleep_interruptible(t_write);\n\t\t\t\tif (sleep_rem != 0) {\n\t\t\t\t\tret = -EINTR;\n\t\t\t\t\tgoto mt_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = 0;\n\t\t}\n\n\t}\n\nmt_unlock:\n\tmutex_unlock(&dev_master->bus_mutex);\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int recall_eeprom(struct w1_slave *sl)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint ret = -ENODEV;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile (max_trying-- && ret) {  \n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\n\t\t\tw1_write_8(dev_master, W1_RECALL_EEPROM);\n\t\t\tret = w1_poll_completion(dev_master, W1_POLL_RECALL_EEPROM);\n\t\t}\n\n\t}\n\n\tmutex_unlock(&dev_master->bus_mutex);\n\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int read_powermode(struct w1_slave *sl)\n{\n\tstruct w1_master *dev_master = sl->master;\n\tint max_trying = W1_THERM_MAX_TRY;\n\tint  ret = -ENODEV;\n\n\tif (!sl->family_data)\n\t\tgoto error;\n\n\t \n\tatomic_inc(THERM_REFCNT(sl->family_data));\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto dec_refcnt;\n\t}\n\n\twhile ((max_trying--) && (ret < 0)) {\n\t\t \n\t\tif (!reset_select_slave(sl)) {\n\t\t\tw1_write_8(dev_master, W1_READ_PSUPPLY);\n\t\t\t \n\t\t\tret = w1_touch_bit(dev_master, 1);\n\t\t\t \n\t\t}\n\t}\n\tmutex_unlock(&dev_master->bus_mutex);\n\ndec_refcnt:\n\tatomic_dec(THERM_REFCNT(sl->family_data));\nerror:\n\treturn ret;\n}\n\nstatic int trigger_bulk_read(struct w1_master *dev_master)\n{\n\tstruct w1_slave *sl = NULL;  \n\tint max_trying = W1_THERM_MAX_TRY;\n\tint t_conv = 0;\n\tint ret = -ENODEV;\n\tbool strong_pullup = false;\n\n\t \n\tlist_for_each_entry(sl, &dev_master->slist, w1_slave_entry) {\n\t\tif (!sl->family_data)\n\t\t\tgoto error;\n\t\tif (bulk_read_support(sl)) {\n\t\t\tint t_cur = conversion_time(sl);\n\n\t\t\tt_conv = max(t_cur, t_conv);\n\t\t\tstrong_pullup = strong_pullup ||\n\t\t\t\t\t(w1_strong_pullup == 2 ||\n\t\t\t\t\t(!SLAVE_POWERMODE(sl) &&\n\t\t\t\t\tw1_strong_pullup));\n\t\t}\n\t}\n\n\t \n\tif (!t_conv)\n\t\tgoto error;\n\n\tif (!bus_mutex_lock(&dev_master->bus_mutex)) {\n\t\tret = -EAGAIN;\t \n\t\tgoto error;\n\t}\n\n\twhile ((max_trying--) && (ret < 0)) {  \n\n\t\tif (!w1_reset_bus(dev_master)) {\t \n\t\t\tunsigned long sleep_rem;\n\n\t\t\tw1_write_8(dev_master, W1_SKIP_ROM);\n\n\t\t\tif (strong_pullup)\t \n\t\t\t\tw1_next_pullup(dev_master, t_conv);\n\n\t\t\tw1_write_8(dev_master, W1_CONVERT_TEMP);\n\n\t\t\t \n\t\t\tlist_for_each_entry(sl,\n\t\t\t\t&dev_master->slist, w1_slave_entry) {\n\t\t\t\tif (bulk_read_support(sl))\n\t\t\t\t\tSLAVE_CONVERT_TRIGGERED(sl) = -1;\n\t\t\t}\n\n\t\t\tif (strong_pullup) {  \n\t\t\t\tsleep_rem = msleep_interruptible(t_conv);\n\t\t\t\tif (sleep_rem != 0) {\n\t\t\t\t\tret = -EINTR;\n\t\t\t\t\tgoto mt_unlock;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\t} else {\n\t\t\t\tmutex_unlock(&dev_master->bus_mutex);\n\t\t\t\tsleep_rem = msleep_interruptible(t_conv);\n\t\t\t\tif (sleep_rem != 0) {\n\t\t\t\t\tret = -EINTR;\n\t\t\t\t\tgoto set_flag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tgoto set_flag;\n\t\t}\n\t}\n\nmt_unlock:\n\tmutex_unlock(&dev_master->bus_mutex);\nset_flag:\n\t \n\tlist_for_each_entry(sl, &dev_master->slist, w1_slave_entry) {\n\t\tif (bulk_read_support(sl))\n\t\t\tSLAVE_CONVERT_TRIGGERED(sl) = 1;\n\t}\nerror:\n\treturn ret;\n}\n\n \n\nstatic ssize_t w1_slave_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct therm_info info;\n\tu8 *family_data = sl->family_data;\n\tint ret, i;\n\tssize_t c = PAGE_SIZE;\n\n\tif (bulk_read_support(sl)) {\n\t\tif (SLAVE_CONVERT_TRIGGERED(sl) < 0) {\n\t\t\tdev_dbg(device,\n\t\t\t\t\"%s: Conversion in progress, retry later\\n\",\n\t\t\t\t__func__);\n\t\t\treturn 0;\n\t\t} else if (SLAVE_CONVERT_TRIGGERED(sl) > 0) {\n\t\t\t \n\t\t\tret = read_scratchpad(sl, &info);\n\t\t\tSLAVE_CONVERT_TRIGGERED(sl) = 0;\n\t\t} else\n\t\t\tret = convert_t(sl, &info);\n\t} else\n\t\tret = convert_t(sl, &info);\n\n\tif (ret < 0) {\n\t\tdev_dbg(device,\n\t\t\t\"%s: Temperature data may be corrupted. err=%d\\n\",\n\t\t\t__func__, ret);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 9; ++i)\n\t\tc -= snprintf(buf + PAGE_SIZE - c, c, \"%02x \", info.rom[i]);\n\tc -= snprintf(buf + PAGE_SIZE - c, c, \": crc=%02x %s\\n\",\n\t\t      info.crc, (info.verdict) ? \"YES\" : \"NO\");\n\n\tif (info.verdict)\n\t\tmemcpy(family_data, info.rom, sizeof(info.rom));\n\telse\n\t\tdev_warn(device, \"%s:Read failed CRC check\\n\", __func__);\n\n\tfor (i = 0; i < 9; ++i)\n\t\tc -= snprintf(buf + PAGE_SIZE - c, c, \"%02x \",\n\t\t\t      ((u8 *)family_data)[i]);\n\n\tc -= snprintf(buf + PAGE_SIZE - c, c, \"t=%d\\n\",\n\t\t\ttemperature_from_RAM(sl, info.rom));\n\n\tret = PAGE_SIZE - c;\n\treturn ret;\n}\n\nstatic ssize_t w1_slave_store(struct device *device,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t size)\n{\n\tint val, ret = 0;\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tret = kstrtoint(buf, 10, &val);  \n\n\tif (ret) {\t \n\t\tdev_info(device,\n\t\t\t\"%s: conversion error. err= %d\\n\", __func__, ret);\n\t\treturn size;\t \n\t}\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn size;   \n\t}\n\n\tif (val == 0)\t \n\t\tret = copy_scratchpad(sl);\n\telse {\n\t\tif (SLAVE_SPECIFIC_FUNC(sl)->set_resolution)\n\t\t\tret = SLAVE_SPECIFIC_FUNC(sl)->set_resolution(sl, val);\n\t}\n\n\tif (ret) {\n\t\tdev_warn(device, \"%s: Set resolution - error %d\\n\", __func__, ret);\n\t\t \n\t\treturn ret;\n\t}\n\tSLAVE_RESOLUTION(sl) = val;\n\t \n\tSLAVE_CONV_TIME_OVERRIDE(sl) = CONV_TIME_DEFAULT;\n\n\treturn size;  \n}\n\nstatic ssize_t temperature_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct therm_info info;\n\tint ret = 0;\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn 0;   \n\t}\n\n\tif (bulk_read_support(sl)) {\n\t\tif (SLAVE_CONVERT_TRIGGERED(sl) < 0) {\n\t\t\tdev_dbg(device,\n\t\t\t\t\"%s: Conversion in progress, retry later\\n\",\n\t\t\t\t__func__);\n\t\t\treturn 0;\n\t\t} else if (SLAVE_CONVERT_TRIGGERED(sl) > 0) {\n\t\t\t \n\t\t\tret = read_scratchpad(sl, &info);\n\t\t\tSLAVE_CONVERT_TRIGGERED(sl) = 0;\n\t\t} else\n\t\t\tret = convert_t(sl, &info);\n\t} else\n\t\tret = convert_t(sl, &info);\n\n\tif (ret < 0) {\n\t\tdev_dbg(device,\n\t\t\t\"%s: Temperature data may be corrupted. err=%d\\n\",\n\t\t\t__func__, ret);\n\t\treturn 0;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", temperature_from_RAM(sl, info.rom));\n}\n\nstatic ssize_t ext_power_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tif (!sl->family_data) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn 0;   \n\t}\n\n\t \n\tSLAVE_POWERMODE(sl) = read_powermode(sl);\n\n\tif (SLAVE_POWERMODE(sl) < 0) {\n\t\tdev_dbg(device,\n\t\t\t\"%s: Power_mode may be corrupted. err=%d\\n\",\n\t\t\t__func__, SLAVE_POWERMODE(sl));\n\t}\n\treturn sprintf(buf, \"%d\\n\", SLAVE_POWERMODE(sl));\n}\n\nstatic ssize_t resolution_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn 0;   \n\t}\n\n\t \n\tSLAVE_RESOLUTION(sl) = SLAVE_SPECIFIC_FUNC(sl)->get_resolution(sl);\n\tif (SLAVE_RESOLUTION(sl) < 0) {\n\t\tdev_dbg(device,\n\t\t\t\"%s: Resolution may be corrupted. err=%d\\n\",\n\t\t\t__func__, SLAVE_RESOLUTION(sl));\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", SLAVE_RESOLUTION(sl));\n}\n\nstatic ssize_t resolution_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tint val;\n\tint ret = 0;\n\n\tret = kstrtoint(buf, 10, &val);  \n\n\tif (ret) {\t \n\t\tdev_info(device,\n\t\t\t\"%s: conversion error. err= %d\\n\", __func__, ret);\n\t\treturn size;\t \n\t}\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn size;   \n\t}\n\n\t \n\n\t \n\tret = SLAVE_SPECIFIC_FUNC(sl)->set_resolution(sl, val);\n\n\tif (ret)\n\t\treturn ret;\n\n\tSLAVE_RESOLUTION(sl) = val;\n\t \n\tSLAVE_CONV_TIME_OVERRIDE(sl) = CONV_TIME_DEFAULT;\n\n\treturn size;\n}\n\nstatic ssize_t eeprom_cmd_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tint ret = -EINVAL;  \n\n\tif (size == sizeof(EEPROM_CMD_WRITE)) {\n\t\tif (!strncmp(buf, EEPROM_CMD_WRITE, sizeof(EEPROM_CMD_WRITE)-1))\n\t\t\tret = copy_scratchpad(sl);\n\t} else if (size == sizeof(EEPROM_CMD_READ)) {\n\t\tif (!strncmp(buf, EEPROM_CMD_READ, sizeof(EEPROM_CMD_READ)-1))\n\t\t\tret = recall_eeprom(sl);\n\t}\n\n\tif (ret)\n\t\tdev_info(device, \"%s: error in process %d\\n\", __func__, ret);\n\n\treturn size;\n}\n\nstatic ssize_t alarms_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tint ret;\n\ts8 th = 0, tl = 0;\n\tstruct therm_info scratchpad;\n\n\tret = read_scratchpad(sl, &scratchpad);\n\n\tif (!ret)\t{\n\t\tth = scratchpad.rom[2];  \n\t\ttl = scratchpad.rom[3];  \n\t} else {\n\t\tdev_info(device,\n\t\t\t\"%s: error reading alarms register %d\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn sprintf(buf, \"%hd %hd\\n\", tl, th);\n}\n\nstatic ssize_t alarms_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct therm_info info;\n\tu8 new_config_register[3];\t \n\tint temp, ret;\n\tchar *token = NULL;\n\ts8 tl, th;\t \n\tchar *p_args, *orig;\n\n\tp_args = orig = kmalloc(size, GFP_KERNEL);\n\t \n\tif (!p_args) {\n\t\tdev_warn(device,\n\t\t\t\"%s: error unable to allocate memory %d\\n\",\n\t\t\t__func__, -ENOMEM);\n\t\treturn size;\n\t}\n\tstrcpy(p_args, buf);\n\n\t \n\ttoken = strsep(&p_args, \" \");\n\n\tif (!token)\t{\n\t\tdev_info(device,\n\t\t\t\"%s: error parsing args %d\\n\", __func__, -EINVAL);\n\t\tgoto free_m;\n\t}\n\n\t \n\tret = kstrtoint (token, 10, &temp);\n\tif (ret) {\n\t\tdev_info(device,\n\t\t\t\"%s: error parsing args %d\\n\", __func__, ret);\n\t\tgoto free_m;\n\t}\n\n\ttl = int_to_short(temp);\n\n\t \n\ttoken = strsep(&p_args, \" \");\n\tif (!token)\t{\n\t\tdev_info(device,\n\t\t\t\"%s: error parsing args %d\\n\", __func__, -EINVAL);\n\t\tgoto free_m;\n\t}\n\t \n\tret = kstrtoint (token, 10, &temp);\n\tif (ret) {\n\t\tdev_info(device,\n\t\t\t\"%s: error parsing args %d\\n\", __func__, ret);\n\t\tgoto free_m;\n\t}\n\n\t \n\tth = int_to_short(temp);\n\n\t \n\tif (tl > th)\n\t\tswap(tl, th);\n\n\t \n\tret = read_scratchpad(sl, &info);\n\tif (!ret) {\n\t\tnew_config_register[0] = th;\t \n\t\tnew_config_register[1] = tl;\t \n\t\tnew_config_register[2] = info.rom[4]; \n\t} else {\n\t\tdev_info(device,\n\t\t\t\"%s: error reading from the slave device %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto free_m;\n\t}\n\n\t \n\tif (!SLAVE_SPECIFIC_FUNC(sl)) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device not supported by the driver %d\\n\",\n\t\t\t__func__, -ENODEV);\n\t\tgoto free_m;\n\t}\n\n\tret = SLAVE_SPECIFIC_FUNC(sl)->write_data(sl, new_config_register);\n\tif (ret)\n\t\tdev_info(device,\n\t\t\t\"%s: error writing to the slave device %d\\n\",\n\t\t\t__func__, ret);\n\nfree_m:\n\t \n\tkfree(orig);\n\n\treturn size;\n}\n\nstatic ssize_t therm_bulk_read_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct w1_master *dev_master = dev_to_w1_master(device);\n\tint ret = -EINVAL;  \n\n\tif (size == sizeof(BULK_TRIGGER_CMD))\n\t\tif (!strncmp(buf, BULK_TRIGGER_CMD,\n\t\t\t\tsizeof(BULK_TRIGGER_CMD)-1))\n\t\t\tret = trigger_bulk_read(dev_master);\n\n\tif (ret)\n\t\tdev_info(device,\n\t\t\t\"%s: unable to trigger a bulk read on the bus. err=%d\\n\",\n\t\t\t__func__, ret);\n\n\treturn size;\n}\n\nstatic ssize_t therm_bulk_read_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_master *dev_master = dev_to_w1_master(device);\n\tstruct w1_slave *sl = NULL;\n\tint ret = 0;\n\n\tlist_for_each_entry(sl, &dev_master->slist, w1_slave_entry) {\n\t\tif (sl->family_data) {\n\t\t\tif (bulk_read_support(sl)) {\n\t\t\t\tif (SLAVE_CONVERT_TRIGGERED(sl) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto show_result;\n\t\t\t\t}\n\t\t\t\tif (SLAVE_CONVERT_TRIGGERED(sl) == 1)\n\t\t\t\t\t \n\t\t\t\t\tret = 1;\n\t\t\t}\n\t\t}\n\t}\nshow_result:\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t conv_time_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t\"%s: Device is not supported by the driver\\n\", __func__);\n\t\treturn 0;   \n\t}\n\treturn sprintf(buf, \"%d\\n\", conversion_time(sl));\n}\n\nstatic ssize_t conv_time_store(struct device *device,\n\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tint val, ret = 0;\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tif (kstrtoint(buf, 10, &val))  \n\t\treturn -EINVAL;\n\n\tif (check_family_data(sl))\n\t\treturn -ENODEV;\n\n\tif (val != CONV_TIME_MEASURE) {\n\t\tif (val >= CONV_TIME_DEFAULT)\n\t\t\tSLAVE_CONV_TIME_OVERRIDE(sl) = val;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t} else {\n\t\tint conv_time;\n\n\t\tret = conv_time_measure(sl, &conv_time);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tSLAVE_CONV_TIME_OVERRIDE(sl) = conv_time;\n\t}\n\treturn size;\n}\n\nstatic ssize_t features_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device,\n\t\t\t \"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn 0;   \n\t}\n\treturn sprintf(buf, \"%u\\n\", SLAVE_FEATURES(sl));\n}\n\nstatic ssize_t features_store(struct device *device,\n\t\t\t      struct device_attribute *attr, const char *buf, size_t size)\n{\n\tint val, ret = 0;\n\tbool strong_pullup;\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\n\tret = kstrtouint(buf, 10, &val);  \n\tif (ret)\n\t\treturn -EINVAL;   \n\n\tif ((!sl->family_data) || (!SLAVE_SPECIFIC_FUNC(sl))) {\n\t\tdev_info(device, \"%s: Device not supported by the driver\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((val & W1_THERM_FEATURES_MASK) != val)\n\t\treturn -EINVAL;\n\n\tSLAVE_FEATURES(sl) = val;\n\n\tstrong_pullup = (w1_strong_pullup == 2 ||\n\t\t\t (!SLAVE_POWERMODE(sl) &&\n\t\t\t  w1_strong_pullup));\n\n\tif (strong_pullup && SLAVE_FEATURES(sl) & W1_THERM_POLL_COMPLETION) {\n\t\tdev_warn(&sl->dev,\n\t\t\t \"%s: W1_THERM_POLL_COMPLETION disabled in parasite power mode.\\n\",\n\t\t\t __func__);\n\t\tSLAVE_FEATURES(sl) &= ~W1_THERM_POLL_COMPLETION;\n\t}\n\n\treturn size;\n}\n\n#if IS_REACHABLE(CONFIG_HWMON)\nstatic int w1_read_temp(struct device *device, u32 attr, int channel,\n\t\t\tlong *val)\n{\n\tstruct w1_slave *sl = dev_get_drvdata(device);\n\tstruct therm_info info;\n\tint ret;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tret = convert_t(sl, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!info.verdict) {\n\t\t\tret = -EIO;\n\t\t\treturn ret;\n\t\t}\n\n\t\t*val = temperature_from_RAM(sl, info.rom);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#endif\n\n#define W1_42_CHAIN\t0x99\n#define W1_42_CHAIN_OFF\t0x3C\n#define W1_42_CHAIN_OFF_INV\t0xC3\n#define W1_42_CHAIN_ON\t0x5A\n#define W1_42_CHAIN_ON_INV\t0xA5\n#define W1_42_CHAIN_DONE 0x96\n#define W1_42_CHAIN_DONE_INV 0x69\n#define W1_42_COND_READ\t0x0F\n#define W1_42_SUCCESS_CONFIRM_BYTE 0xAA\n#define W1_42_FINISHED_BYTE 0xFF\nstatic ssize_t w1_seq_show(struct device *device,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tssize_t c = PAGE_SIZE;\n\tint i;\n\tu8 ack;\n\tu64 rn;\n\tstruct w1_reg_num *reg_num;\n\tint seq = 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\t \n\tif (w1_reset_bus(sl->master))\n\t\tgoto error;\n\tw1_write_8(sl->master, W1_SKIP_ROM);\n\tw1_write_8(sl->master, W1_42_CHAIN);\n\tw1_write_8(sl->master, W1_42_CHAIN_ON);\n\tw1_write_8(sl->master, W1_42_CHAIN_ON_INV);\n\tmsleep(sl->master->pullup_duration);\n\n\t \n\tack = w1_read_8(sl->master);\n\tif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i <= 64; i++) {\n\t\tif (w1_reset_bus(sl->master))\n\t\t\tgoto error;\n\n\t\tw1_write_8(sl->master, W1_42_COND_READ);\n\t\tw1_read_block(sl->master, (u8 *)&rn, 8);\n\t\treg_num = (struct w1_reg_num *) &rn;\n\t\tif (reg_num->family == W1_42_FINISHED_BYTE)\n\t\t\tbreak;\n\t\tif (sl->reg_num.id == reg_num->id)\n\t\t\tseq = i;\n\n\t\tif (w1_reset_bus(sl->master))\n\t\t\tgoto error;\n\n\t\t \n\t\tw1_write_8(sl->master, W1_MATCH_ROM);\n\t\tw1_write_block(sl->master, (u8 *)&rn, 8);\n\t\tw1_write_8(sl->master, W1_42_CHAIN);\n\t\tw1_write_8(sl->master, W1_42_CHAIN_DONE);\n\t\tw1_write_8(sl->master, W1_42_CHAIN_DONE_INV);\n\n\t\t \n\t\tack = w1_read_8(sl->master);\n\t\tif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (w1_reset_bus(sl->master))\n\t\tgoto error;\n\tw1_write_8(sl->master, W1_SKIP_ROM);\n\tw1_write_8(sl->master, W1_42_CHAIN);\n\tw1_write_8(sl->master, W1_42_CHAIN_OFF);\n\tw1_write_8(sl->master, W1_42_CHAIN_OFF_INV);\n\n\t \n\tack = w1_read_8(sl->master);\n\tif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\n\t\tgoto error;\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\tc -= snprintf(buf + PAGE_SIZE - c, c, \"%d\\n\", seq);\n\treturn PAGE_SIZE - c;\nerror:\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn -EIO;\n}\n\nstatic int __init w1_therm_init(void)\n{\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i) {\n\t\terr = w1_register_family(w1_therm_families[i].f);\n\t\tif (err)\n\t\t\tw1_therm_families[i].broken = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit w1_therm_fini(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i)\n\t\tif (!w1_therm_families[i].broken)\n\t\t\tw1_unregister_family(w1_therm_families[i].f);\n}\n\nmodule_init(w1_therm_init);\nmodule_exit(w1_therm_fini);\n\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"Driver for 1-wire Dallas network protocol, temperature family.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_THERM_DS18S20));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_THERM_DS1822));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_THERM_DS18B20));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_THERM_DS1825));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_THERM_DS28EA00));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}