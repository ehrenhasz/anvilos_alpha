{
  "module_name": "w1_ds2408.c",
  "hash_id": "071edae2d81c04a5da46429f85fb399e91477f02663103396b7e3f675945523c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2408.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS2408\t0x29\n\n#define W1_F29_RETRIES\t\t3\n\n#define W1_F29_REG_LOGIG_STATE             0x88  \n#define W1_F29_REG_OUTPUT_LATCH_STATE      0x89  \n#define W1_F29_REG_ACTIVITY_LATCH_STATE    0x8A  \n#define W1_F29_REG_COND_SEARCH_SELECT_MASK 0x8B  \n#define W1_F29_REG_COND_SEARCH_POL_SELECT  0x8C  \n#define W1_F29_REG_CONTROL_AND_STATUS      0x8D  \n\n#define W1_F29_FUNC_READ_PIO_REGS          0xF0\n#define W1_F29_FUNC_CHANN_ACCESS_READ      0xF5\n#define W1_F29_FUNC_CHANN_ACCESS_WRITE     0x5A\n \n#define W1_F29_FUNC_WRITE_COND_SEARCH_REG  0xCC\n#define W1_F29_FUNC_RESET_ACTIVITY_LATCHES 0xC3\n\n#define W1_F29_SUCCESS_CONFIRM_BYTE        0xAA\n\nstatic int _read_reg(struct w1_slave *sl, u8 address, unsigned char *buf)\n{\n\tu8 wrbuf[3];\n\n\tdev_dbg(&sl->dev, \"Reading with slave: %p, reg addr: %0#4x, buff addr: %p\",\n\t\tsl, (unsigned int)address, buf);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"mutex locked\");\n\n\tif (w1_reset_select_slave(sl)) {\n\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\treturn -EIO;\n\t}\n\n\twrbuf[0] = W1_F29_FUNC_READ_PIO_REGS;\n\twrbuf[1] = address;\n\twrbuf[2] = 0;\n\tw1_write_block(sl->master, wrbuf, 3);\n\t*buf = w1_read_8(sl->master);\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"mutex unlocked\");\n\treturn 1;\n}\n\nstatic ssize_t state_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\t  size_t count)\n{\n\tdev_dbg(&kobj_to_w1_slave(kobj)->dev,\n\t\t\"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p\",\n\t\tbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj), W1_F29_REG_LOGIG_STATE, buf);\n}\n\nstatic ssize_t output_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t   loff_t off, size_t count)\n{\n\tdev_dbg(&kobj_to_w1_slave(kobj)->dev,\n\t\t\"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p\",\n\t\tbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj),\n\t\t\t\t\t W1_F29_REG_OUTPUT_LATCH_STATE, buf);\n}\n\nstatic ssize_t activity_read(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t     loff_t off, size_t count)\n{\n\tdev_dbg(&kobj_to_w1_slave(kobj)->dev,\n\t\t\"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p\",\n\t\tbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj),\n\t\t\t\t\t W1_F29_REG_ACTIVITY_LATCH_STATE, buf);\n}\n\nstatic ssize_t cond_search_mask_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t     loff_t off, size_t count)\n{\n\tdev_dbg(&kobj_to_w1_slave(kobj)->dev,\n\t\t\"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p\",\n\t\tbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj),\n\t\tW1_F29_REG_COND_SEARCH_SELECT_MASK, buf);\n}\n\nstatic ssize_t cond_search_polarity_read(struct file *filp,\n\t\t\t\t\t struct kobject *kobj,\n\t\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t\t char *buf, loff_t off, size_t count)\n{\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj),\n\t\tW1_F29_REG_COND_SEARCH_POL_SELECT, buf);\n}\n\nstatic ssize_t status_control_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t   loff_t off, size_t count)\n{\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\treturn _read_reg(kobj_to_w1_slave(kobj),\n\t\tW1_F29_REG_CONTROL_AND_STATUS, buf);\n}\n\n#ifdef CONFIG_W1_SLAVE_DS2408_READBACK\nstatic bool optional_read_back_valid(struct w1_slave *sl, u8 expected)\n{\n\tu8 w1_buf[3];\n\n\tif (w1_reset_resume_command(sl->master))\n\t\treturn false;\n\n\tw1_buf[0] = W1_F29_FUNC_READ_PIO_REGS;\n\tw1_buf[1] = W1_F29_REG_OUTPUT_LATCH_STATE;\n\tw1_buf[2] = 0;\n\n\tw1_write_block(sl->master, w1_buf, 3);\n\n\treturn (w1_read_8(sl->master) == expected);\n}\n#else\nstatic bool optional_read_back_valid(struct w1_slave *sl, u8 expected)\n{\n\treturn true;\n}\n#endif\n\nstatic ssize_t output_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu8 w1_buf[3];\n\tunsigned int retries = W1_F29_RETRIES;\n\tssize_t bytes_written = -EIO;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tdev_dbg(&sl->dev, \"locking mutex for write_output\");\n\tmutex_lock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"mutex locked\");\n\n\tif (w1_reset_select_slave(sl))\n\t\tgoto out;\n\n\tdo {\n\t\tw1_buf[0] = W1_F29_FUNC_CHANN_ACCESS_WRITE;\n\t\tw1_buf[1] = *buf;\n\t\tw1_buf[2] = ~(*buf);\n\n\t\tw1_write_block(sl->master, w1_buf, 3);\n\n\t\tif (w1_read_8(sl->master) == W1_F29_SUCCESS_CONFIRM_BYTE &&\n\t\t    optional_read_back_valid(sl, *buf)) {\n\t\t\tbytes_written = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\tgoto out;  \n\t\t \n\t} while (--retries);\n\nout:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\tdev_dbg(&sl->dev, \"%s, mutex unlocked retries:%d\\n\",\n\t\t(bytes_written > 0) ? \"succeeded\" : \"error\", retries);\n\n\treturn bytes_written;\n}\n\n\n \nstatic ssize_t activity_write(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr, char *buf,\n\t\t\t      loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tunsigned int retries = W1_F29_RETRIES;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl))\n\t\tgoto error;\n\n\twhile (retries--) {\n\t\tw1_write_8(sl->master, W1_F29_FUNC_RESET_ACTIVITY_LATCHES);\n\t\tif (w1_read_8(sl->master) == W1_F29_SUCCESS_CONFIRM_BYTE) {\n\t\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\t\treturn 1;\n\t\t}\n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\tgoto error;\n\t}\n\nerror:\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn -EIO;\n}\n\nstatic ssize_t status_control_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu8 w1_buf[4];\n\tunsigned int retries = W1_F29_RETRIES;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl))\n\t\tgoto error;\n\n\twhile (retries--) {\n\t\tw1_buf[0] = W1_F29_FUNC_WRITE_COND_SEARCH_REG;\n\t\tw1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;\n\t\tw1_buf[2] = 0;\n\t\tw1_buf[3] = *buf;\n\n\t\tw1_write_block(sl->master, w1_buf, 4);\n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\tgoto error;\n\n\t\tw1_buf[0] = W1_F29_FUNC_READ_PIO_REGS;\n\t\tw1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;\n\t\tw1_buf[2] = 0;\n\n\t\tw1_write_block(sl->master, w1_buf, 3);\n\t\tif (w1_read_8(sl->master) == *buf) {\n\t\t\t \n\t\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\t\treturn 1;\n\t\t}\n\t}\nerror:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn -EIO;\n}\n\n \nstatic int w1_f29_disable_test_mode(struct w1_slave *sl)\n{\n\tint res;\n\tu8 magic[10] = {0x96, };\n\tu64 rn = le64_to_cpu(*((u64 *)&sl->reg_num));\n\n\tmemcpy(&magic[1], &rn, 8);\n\tmagic[9] = 0x3C;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tres = w1_reset_bus(sl->master);\n\tif (res)\n\t\tgoto out;\n\tw1_write_block(sl->master, magic, ARRAY_SIZE(magic));\n\n\tres = w1_reset_bus(sl->master);\nout:\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn res;\n}\n\nstatic BIN_ATTR_RO(state, 1);\nstatic BIN_ATTR_RW(output, 1);\nstatic BIN_ATTR_RW(activity, 1);\nstatic BIN_ATTR_RO(cond_search_mask, 1);\nstatic BIN_ATTR_RO(cond_search_polarity, 1);\nstatic BIN_ATTR_RW(status_control, 1);\n\nstatic struct bin_attribute *w1_f29_bin_attrs[] = {\n\t&bin_attr_state,\n\t&bin_attr_output,\n\t&bin_attr_activity,\n\t&bin_attr_cond_search_mask,\n\t&bin_attr_cond_search_polarity,\n\t&bin_attr_status_control,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f29_group = {\n\t.bin_attrs = w1_f29_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_f29_groups[] = {\n\t&w1_f29_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_f29_fops = {\n\t.add_slave      = w1_f29_disable_test_mode,\n\t.groups\t\t= w1_f29_groups,\n};\n\nstatic struct w1_family w1_family_29 = {\n\t.fid = W1_FAMILY_DS2408,\n\t.fops = &w1_f29_fops,\n};\nmodule_w1_family(w1_family_29);\n\nMODULE_AUTHOR(\"Jean-Francois Dagenais <dagenaisj@sonatest.com>\");\nMODULE_DESCRIPTION(\"w1 family 29 driver for DS2408 8 Pin IO\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2408));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}