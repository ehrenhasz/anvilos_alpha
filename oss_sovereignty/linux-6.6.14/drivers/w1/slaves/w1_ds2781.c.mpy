{
  "module_name": "w1_ds2781.c",
  "hash_id": "2a3c6b46c538ee684f86dceb82cd3c38cdd7df5b86a65b9554a433f1e5c0c7fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2781.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n\n#include <linux/w1.h>\n\n#include \"w1_ds2781.h\"\n\n#define W1_FAMILY_DS2781\t0x3D\n\nstatic int w1_ds2781_do_io(struct device *dev, char *buf, int addr,\n\t\t\tsize_t count, int io)\n{\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\n\tif (addr > DS2781_DATA_SIZE || addr < 0)\n\t\treturn 0;\n\n\tcount = min_t(int, count, DS2781_DATA_SIZE - addr);\n\n\tif (w1_reset_select_slave(sl) == 0) {\n\t\tif (io) {\n\t\t\tw1_write_8(sl->master, W1_DS2781_WRITE_DATA);\n\t\t\tw1_write_8(sl->master, addr);\n\t\t\tw1_write_block(sl->master, buf, count);\n\t\t} else {\n\t\t\tw1_write_8(sl->master, W1_DS2781_READ_DATA);\n\t\t\tw1_write_8(sl->master, addr);\n\t\t\tcount = w1_read_block(sl->master, buf, count);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint w1_ds2781_io(struct device *dev, char *buf, int addr, size_t count,\n\t\t\tint io)\n{\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\tint ret;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tret = w1_ds2781_do_io(dev, buf, addr, count, io);\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(w1_ds2781_io);\n\nint w1_ds2781_eeprom_cmd(struct device *dev, int addr, int cmd)\n{\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl) == 0) {\n\t\tw1_write_8(sl->master, cmd);\n\t\tw1_write_8(sl->master, addr);\n\t}\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(w1_ds2781_eeprom_cmd);\n\nstatic ssize_t w1_slave_read(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t     loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\treturn w1_ds2781_io(dev, buf, off, count, 0);\n}\n\nstatic BIN_ATTR_RO(w1_slave, DS2781_DATA_SIZE);\n\nstatic struct bin_attribute *w1_ds2781_bin_attrs[] = {\n\t&bin_attr_w1_slave,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_ds2781_group = {\n\t.bin_attrs = w1_ds2781_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_ds2781_groups[] = {\n\t&w1_ds2781_group,\n\tNULL,\n};\n\nstatic int w1_ds2781_add_slave(struct w1_slave *sl)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_alloc(\"ds2781-battery\", PLATFORM_DEVID_AUTO);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\tpdev->dev.parent = &sl->dev;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto pdev_add_failed;\n\n\tdev_set_drvdata(&sl->dev, pdev);\n\n\treturn 0;\n\npdev_add_failed:\n\tplatform_device_put(pdev);\n\n\treturn ret;\n}\n\nstatic void w1_ds2781_remove_slave(struct w1_slave *sl)\n{\n\tstruct platform_device *pdev = dev_get_drvdata(&sl->dev);\n\n\tplatform_device_unregister(pdev);\n}\n\nstatic const struct w1_family_ops w1_ds2781_fops = {\n\t.add_slave    = w1_ds2781_add_slave,\n\t.remove_slave = w1_ds2781_remove_slave,\n\t.groups       = w1_ds2781_groups,\n};\n\nstatic struct w1_family w1_ds2781_family = {\n\t.fid = W1_FAMILY_DS2781,\n\t.fops = &w1_ds2781_fops,\n};\nmodule_w1_family(w1_ds2781_family);\n\nMODULE_AUTHOR(\"Renata Sayakhova <renata@oktetlabs.ru>\");\nMODULE_DESCRIPTION(\"1-wire Driver for Maxim/Dallas DS2781 Stand-Alone Fuel Gauge IC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2781));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}