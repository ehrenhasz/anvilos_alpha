{
  "module_name": "w1_ds250x.c",
  "hash_id": "8f253789816e2e099cb76125aee7866c4cd66f1ccba0b50a9b5a87a5a2f2e71e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds250x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/crc16.h>\n\n#include <linux/w1.h>\n#include <linux/nvmem-provider.h>\n\n#define W1_DS2501_UNW_FAMILY    0x91\n#define W1_DS2501_SIZE          64\n\n#define W1_DS2502_FAMILY        0x09\n#define W1_DS2502_UNW_FAMILY    0x89\n#define W1_DS2502_SIZE          128\n\n#define W1_DS2505_FAMILY\t0x0b\n#define W1_DS2505_SIZE\t\t2048\n\n#define W1_PAGE_SIZE\t\t32\n\n#define W1_EXT_READ_MEMORY\t0xA5\n#define W1_READ_DATA_CRC        0xC3\n\n#define OFF2PG(off)\t((off) / W1_PAGE_SIZE)\n\n#define CRC16_INIT\t\t0\n#define CRC16_VALID\t\t0xb001\n\nstruct w1_eprom_data {\n\tsize_t size;\n\tint (*read)(struct w1_slave *sl, int pageno);\n\tu8 eprom[W1_DS2505_SIZE];\n\tDECLARE_BITMAP(page_present, W1_DS2505_SIZE / W1_PAGE_SIZE);\n\tchar nvmem_name[64];\n};\n\nstatic int w1_ds2502_read_page(struct w1_slave *sl, int pageno)\n{\n\tstruct w1_eprom_data *data = sl->family_data;\n\tint pgoff = pageno * W1_PAGE_SIZE;\n\tint ret = -EIO;\n\tu8 buf[3];\n\tu8 crc8;\n\n\tif (test_bit(pageno, data->page_present))\n\t\treturn 0;  \n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl))\n\t\tgoto err;\n\n\tbuf[0] = W1_READ_DATA_CRC;\n\tbuf[1] = pgoff & 0xff;\n\tbuf[2] = pgoff >> 8;\n\tw1_write_block(sl->master, buf, 3);\n\n\tcrc8 = w1_read_8(sl->master);\n\tif (w1_calc_crc8(buf, 3) != crc8)\n\t\tgoto err;\n\n\tw1_read_block(sl->master, &data->eprom[pgoff], W1_PAGE_SIZE);\n\n\tcrc8 = w1_read_8(sl->master);\n\tif (w1_calc_crc8(&data->eprom[pgoff], W1_PAGE_SIZE) != crc8)\n\t\tgoto err;\n\n\tset_bit(pageno, data->page_present);  \n\tret = 0;\nerr:\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn ret;\n}\n\nstatic int w1_ds2505_read_page(struct w1_slave *sl, int pageno)\n{\n\tstruct w1_eprom_data *data = sl->family_data;\n\tint redir_retries = 16;\n\tint pgoff, epoff;\n\tint ret = -EIO;\n\tu8 buf[6];\n\tu8 redir;\n\tu16 crc;\n\n\tif (test_bit(pageno, data->page_present))\n\t\treturn 0;  \n\n\tepoff = pgoff = pageno * W1_PAGE_SIZE;\n\tmutex_lock(&sl->master->bus_mutex);\n\nretry:\n\tif (w1_reset_select_slave(sl))\n\t\tgoto err;\n\n\tbuf[0] = W1_EXT_READ_MEMORY;\n\tbuf[1] = pgoff & 0xff;\n\tbuf[2] = pgoff >> 8;\n\tw1_write_block(sl->master, buf, 3);\n\tw1_read_block(sl->master, buf + 3, 3);  \n\tredir = buf[3];\n\tcrc = crc16(CRC16_INIT, buf, 6);\n\n\tif (crc != CRC16_VALID)\n\t\tgoto err;\n\n\n\tif (redir != 0xff) {\n\t\tredir_retries--;\n\t\tif (redir_retries < 0)\n\t\t\tgoto err;\n\n\t\tpgoff = (redir ^ 0xff) * W1_PAGE_SIZE;\n\t\tgoto retry;\n\t}\n\n\tw1_read_block(sl->master, &data->eprom[epoff], W1_PAGE_SIZE);\n\tw1_read_block(sl->master, buf, 2);  \n\tcrc = crc16(CRC16_INIT, &data->eprom[epoff], W1_PAGE_SIZE);\n\tcrc = crc16(crc, buf, 2);\n\n\tif (crc != CRC16_VALID)\n\t\tgoto err;\n\n\tset_bit(pageno, data->page_present);\n\tret = 0;\nerr:\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn ret;\n}\n\nstatic int w1_nvmem_read(void *priv, unsigned int off, void *buf, size_t count)\n{\n\tstruct w1_slave *sl = priv;\n\tstruct w1_eprom_data *data = sl->family_data;\n\tsize_t eprom_size = data->size;\n\tint ret;\n\tint i;\n\n\tif (off > eprom_size)\n\t\treturn -EINVAL;\n\n\tif ((off + count) > eprom_size)\n\t\tcount = eprom_size - off;\n\n\ti = OFF2PG(off);\n\tdo {\n\t\tret = data->read(sl, i++);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while (i < OFF2PG(off + count));\n\n\tmemcpy(buf, &data->eprom[off], count);\n\treturn 0;\n}\n\nstatic int w1_eprom_add_slave(struct w1_slave *sl)\n{\n\tstruct w1_eprom_data *data;\n\tstruct nvmem_device *nvmem;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.dev = &sl->dev,\n\t\t.reg_read = w1_nvmem_read,\n\t\t.type = NVMEM_TYPE_OTP,\n\t\t.read_only = true,\n\t\t.word_size = 1,\n\t\t.priv = sl,\n\t\t.id = -1\n\t};\n\n\tdata = devm_kzalloc(&sl->dev, sizeof(struct w1_eprom_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsl->family_data = data;\n\tswitch (sl->family->fid) {\n\tcase W1_DS2501_UNW_FAMILY:\n\t\tdata->size = W1_DS2501_SIZE;\n\t\tdata->read = w1_ds2502_read_page;\n\t\tbreak;\n\tcase W1_DS2502_FAMILY:\n\tcase W1_DS2502_UNW_FAMILY:\n\t\tdata->size = W1_DS2502_SIZE;\n\t\tdata->read = w1_ds2502_read_page;\n\t\tbreak;\n\tcase W1_DS2505_FAMILY:\n\t\tdata->size = W1_DS2505_SIZE;\n\t\tdata->read = w1_ds2505_read_page;\n\t\tbreak;\n\t}\n\n\tif (sl->master->bus_master->dev_id)\n\t\tsnprintf(data->nvmem_name, sizeof(data->nvmem_name),\n\t\t\t \"%s-%02x-%012llx\",\n\t\t\t sl->master->bus_master->dev_id, sl->reg_num.family,\n\t\t\t (unsigned long long)sl->reg_num.id);\n\telse\n\t\tsnprintf(data->nvmem_name, sizeof(data->nvmem_name),\n\t\t\t \"%02x-%012llx\",\n\t\t\t sl->reg_num.family,\n\t\t\t (unsigned long long)sl->reg_num.id);\n\n\tnvmem_cfg.name = data->nvmem_name;\n\tnvmem_cfg.size = data->size;\n\n\tnvmem = devm_nvmem_register(&sl->dev, &nvmem_cfg);\n\treturn PTR_ERR_OR_ZERO(nvmem);\n}\n\nstatic const struct w1_family_ops w1_eprom_fops = {\n\t.add_slave\t= w1_eprom_add_slave,\n};\n\nstatic struct w1_family w1_family_09 = {\n\t.fid = W1_DS2502_FAMILY,\n\t.fops = &w1_eprom_fops,\n};\n\nstatic struct w1_family w1_family_0b = {\n\t.fid = W1_DS2505_FAMILY,\n\t.fops = &w1_eprom_fops,\n};\n\nstatic struct w1_family w1_family_89 = {\n\t.fid = W1_DS2502_UNW_FAMILY,\n\t.fops = &w1_eprom_fops,\n};\n\nstatic struct w1_family w1_family_91 = {\n\t.fid = W1_DS2501_UNW_FAMILY,\n\t.fops = &w1_eprom_fops,\n};\n\nstatic int __init w1_ds250x_init(void)\n{\n\tint err;\n\n\terr = w1_register_family(&w1_family_09);\n\tif (err)\n\t\treturn err;\n\n\terr = w1_register_family(&w1_family_0b);\n\tif (err)\n\t\tgoto err_0b;\n\n\terr = w1_register_family(&w1_family_89);\n\tif (err)\n\t\tgoto err_89;\n\n\terr = w1_register_family(&w1_family_91);\n\tif (err)\n\t\tgoto err_91;\n\n\treturn 0;\n\nerr_91:\n\tw1_unregister_family(&w1_family_89);\nerr_89:\n\tw1_unregister_family(&w1_family_0b);\nerr_0b:\n\tw1_unregister_family(&w1_family_09);\n\treturn err;\n}\n\nstatic void __exit w1_ds250x_exit(void)\n{\n\tw1_unregister_family(&w1_family_09);\n\tw1_unregister_family(&w1_family_0b);\n\tw1_unregister_family(&w1_family_89);\n\tw1_unregister_family(&w1_family_91);\n}\n\nmodule_init(w1_ds250x_init);\nmodule_exit(w1_ds250x_exit);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tbogendoerfe@suse.de>\");\nMODULE_DESCRIPTION(\"w1 family driver for DS250x Add Only Memory\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_DS2502_FAMILY));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_DS2505_FAMILY));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_DS2501_UNW_FAMILY));\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_DS2502_UNW_FAMILY));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}