{
  "module_name": "w1_ds2413.c",
  "hash_id": "c5ce517babff949269fd6258b9b06f9d94ee743f35029399852d1a71da0aa221",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2413.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS2413\t0x3A\n\n#define W1_F3A_RETRIES                     3\n#define W1_F3A_FUNC_PIO_ACCESS_READ        0xF5\n#define W1_F3A_FUNC_PIO_ACCESS_WRITE       0x5A\n#define W1_F3A_SUCCESS_CONFIRM_BYTE        0xAA\n#define W1_F3A_INVALID_PIO_STATE           0xFF\n\nstatic ssize_t state_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\t  size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tunsigned int retries = W1_F3A_RETRIES;\n\tssize_t bytes_read = -EIO;\n\tu8 state;\n\n\tdev_dbg(&sl->dev,\n\t\t\"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p\",\n\t\tbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"mutex locked\");\n\nnext:\n\tif (w1_reset_select_slave(sl))\n\t\tgoto out;\n\n\twhile (retries--) {\n\t\tw1_write_8(sl->master, W1_F3A_FUNC_PIO_ACCESS_READ);\n\n\t\tstate = w1_read_8(sl->master);\n\t\tif ((state & 0x0F) == ((~state >> 4) & 0x0F)) {\n\t\t\t \n\t\t\t*buf = state;\n\t\t\tbytes_read = 1;\n\t\t\tgoto out;\n\t\t} else if (state == W1_F3A_INVALID_PIO_STATE) {\n\t\t\t \n\t\t\tdev_warn(&sl->dev, \"slave device did not respond to PIO_ACCESS_READ, \" \\\n\t\t\t\t\t    \"reselecting, retries left: %d\\n\", retries);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\tgoto out;  \n\n\t\tdev_warn(&sl->dev, \"PIO_ACCESS_READ error, retries left: %d\\n\", retries);\n\t}\n\nout:\n\tmutex_unlock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"%s, mutex unlocked, retries: %d\\n\",\n\t\t(bytes_read > 0) ? \"succeeded\" : \"error\", retries);\n\treturn bytes_read;\n}\n\nstatic BIN_ATTR_RO(state, 1);\n\nstatic ssize_t output_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu8 w1_buf[3];\n\tunsigned int retries = W1_F3A_RETRIES;\n\tssize_t bytes_written = -EIO;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tdev_dbg(&sl->dev, \"locking mutex for write_output\");\n\tmutex_lock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"mutex locked\");\n\n\tif (w1_reset_select_slave(sl))\n\t\tgoto out;\n\n\t \n\t*buf = *buf | 0xFC;\n\n\twhile (retries--) {\n\t\tw1_buf[0] = W1_F3A_FUNC_PIO_ACCESS_WRITE;\n\t\tw1_buf[1] = *buf;\n\t\tw1_buf[2] = ~(*buf);\n\t\tw1_write_block(sl->master, w1_buf, 3);\n\n\t\tif (w1_read_8(sl->master) == W1_F3A_SUCCESS_CONFIRM_BYTE) {\n\t\t\tbytes_written = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (w1_reset_resume_command(sl->master))\n\t\t\tgoto out;  \n\n\t\tdev_warn(&sl->dev, \"PIO_ACCESS_WRITE error, retries left: %d\\n\", retries);\n\t}\n\nout:\n\tmutex_unlock(&sl->master->bus_mutex);\n\tdev_dbg(&sl->dev, \"%s, mutex unlocked, retries: %d\\n\",\n\t\t(bytes_written > 0) ? \"succeeded\" : \"error\", retries);\n\treturn bytes_written;\n}\n\nstatic BIN_ATTR(output, 0664, NULL, output_write, 1);\n\nstatic struct bin_attribute *w1_f3a_bin_attrs[] = {\n\t&bin_attr_state,\n\t&bin_attr_output,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f3a_group = {\n\t.bin_attrs = w1_f3a_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_f3a_groups[] = {\n\t&w1_f3a_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_f3a_fops = {\n\t.groups\t\t= w1_f3a_groups,\n};\n\nstatic struct w1_family w1_family_3a = {\n\t.fid = W1_FAMILY_DS2413,\n\t.fops = &w1_f3a_fops,\n};\nmodule_w1_family(w1_family_3a);\n\nMODULE_AUTHOR(\"Mariusz Bialonczyk <manio@skyboo.net>\");\nMODULE_DESCRIPTION(\"w1 family 3a driver for DS2413 2 Pin IO\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2413));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}