{
  "module_name": "w1_ds2433.c",
  "hash_id": "6769dd2e0c0b95301125a29194088e64b2b49bfc9696846876f757297af4073e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2433.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n#include <linux/crc16.h>\n\n#define CRC16_INIT\t\t0\n#define CRC16_VALID\t\t0xb001\n\n#endif\n\n#include <linux/w1.h>\n\n#define W1_EEPROM_DS2433\t0x23\n\n#define W1_EEPROM_SIZE\t\t512\n#define W1_PAGE_COUNT\t\t16\n#define W1_PAGE_SIZE\t\t32\n#define W1_PAGE_BITS\t\t5\n#define W1_PAGE_MASK\t\t0x1F\n\n#define W1_F23_TIME\t\t300\n\n#define W1_F23_READ_EEPROM\t0xF0\n#define W1_F23_WRITE_SCRATCH\t0x0F\n#define W1_F23_READ_SCRATCH\t0xAA\n#define W1_F23_COPY_SCRATCH\t0x55\n\nstruct w1_f23_data {\n\tu8\tmemory[W1_EEPROM_SIZE];\n\tu32\tvalidcrc;\n};\n\n \nstatic inline size_t w1_f23_fix_count(loff_t off, size_t count, size_t size)\n{\n\tif (off > size)\n\t\treturn 0;\n\n\tif ((off + count) > size)\n\t\treturn (size - off);\n\n\treturn count;\n}\n\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\nstatic int w1_f23_refresh_block(struct w1_slave *sl, struct w1_f23_data *data,\n\t\t\t\tint block)\n{\n\tu8\twrbuf[3];\n\tint\toff = block * W1_PAGE_SIZE;\n\n\tif (data->validcrc & (1 << block))\n\t\treturn 0;\n\n\tif (w1_reset_select_slave(sl)) {\n\t\tdata->validcrc = 0;\n\t\treturn -EIO;\n\t}\n\n\twrbuf[0] = W1_F23_READ_EEPROM;\n\twrbuf[1] = off & 0xff;\n\twrbuf[2] = off >> 8;\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_read_block(sl->master, &data->memory[off], W1_PAGE_SIZE);\n\n\t \n\tif (crc16(CRC16_INIT, &data->memory[off], W1_PAGE_SIZE) == CRC16_VALID)\n\t\tdata->validcrc |= (1 << block);\n\n\treturn 0;\n}\n#endif\t \n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t   loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\tstruct w1_f23_data *data = sl->family_data;\n\tint i, min_page, max_page;\n#else\n\tu8 wrbuf[3];\n#endif\n\n\tcount = w1_f23_fix_count(off, count, W1_EEPROM_SIZE);\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\n\tmin_page = (off >> W1_PAGE_BITS);\n\tmax_page = (off + count - 1) >> W1_PAGE_BITS;\n\tfor (i = min_page; i <= max_page; i++) {\n\t\tif (w1_f23_refresh_block(sl, data, i)) {\n\t\t\tcount = -EIO;\n\t\t\tgoto out_up;\n\t\t}\n\t}\n\tmemcpy(buf, &data->memory[off], count);\n\n#else\t \n\n\t \n\tif (w1_reset_select_slave(sl)) {\n\t\tcount = -EIO;\n\t\tgoto out_up;\n\t}\n\n\twrbuf[0] = W1_F23_READ_EEPROM;\n\twrbuf[1] = off & 0xff;\n\twrbuf[2] = off >> 8;\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_read_block(sl->master, buf, count);\n\n#endif\t \n\nout_up:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\n \nstatic int w1_f23_write(struct w1_slave *sl, int addr, int len, const u8 *data)\n{\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\tstruct w1_f23_data *f23 = sl->family_data;\n#endif\n\tu8 wrbuf[4];\n\tu8 rdbuf[W1_PAGE_SIZE + 3];\n\tu8 es = (addr + len - 1) & 0x1f;\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F23_WRITE_SCRATCH;\n\twrbuf[1] = addr & 0xff;\n\twrbuf[2] = addr >> 8;\n\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_write_block(sl->master, data, len);\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\tw1_write_8(sl->master, W1_F23_READ_SCRATCH);\n\tw1_read_block(sl->master, rdbuf, len + 3);\n\n\t \n\tif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\n\t    (rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0))\n\t\treturn -1;\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F23_COPY_SCRATCH;\n\twrbuf[3] = es;\n\tw1_write_block(sl->master, wrbuf, 4);\n\n\t \n\tmsleep(5);\n\n\t \n\tw1_reset_bus(sl->master);\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\tf23->validcrc &= ~(1 << (addr >> W1_PAGE_BITS));\n#endif\n\treturn 0;\n}\n\nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint addr, len, idx;\n\n\tcount = w1_f23_fix_count(off, count, W1_EEPROM_SIZE);\n\tif (!count)\n\t\treturn 0;\n\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\t \n\tif ((off & W1_PAGE_MASK) || (count & W1_PAGE_MASK)) {\n\t\tdev_err(&sl->dev, \"invalid offset/count off=%d cnt=%zd\\n\",\n\t\t\t(int)off, count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (idx = 0; idx < count; idx += W1_PAGE_SIZE) {\n\t\tif (crc16(CRC16_INIT, &buf[idx], W1_PAGE_SIZE) != CRC16_VALID) {\n\t\t\tdev_err(&sl->dev, \"bad CRC at offset %d\\n\", (int)off);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#endif\t \n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tidx = 0;\n\twhile (idx < count) {\n\t\taddr = off + idx;\n\t\tlen = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);\n\t\tif (len > (count - idx))\n\t\t\tlen = count - idx;\n\n\t\tif (w1_f23_write(sl, addr, len, &buf[idx]) < 0) {\n\t\t\tcount = -EIO;\n\t\t\tgoto out_up;\n\t\t}\n\t\tidx += len;\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(eeprom, W1_EEPROM_SIZE);\n\nstatic struct bin_attribute *w1_f23_bin_attributes[] = {\n\t&bin_attr_eeprom,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f23_group = {\n\t.bin_attrs = w1_f23_bin_attributes,\n};\n\nstatic const struct attribute_group *w1_f23_groups[] = {\n\t&w1_f23_group,\n\tNULL,\n};\n\nstatic int w1_f23_add_slave(struct w1_slave *sl)\n{\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\tstruct w1_f23_data *data;\n\n\tdata = kzalloc(sizeof(struct w1_f23_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tsl->family_data = data;\n\n#endif\t \n\treturn 0;\n}\n\nstatic void w1_f23_remove_slave(struct w1_slave *sl)\n{\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\n\tkfree(sl->family_data);\n\tsl->family_data = NULL;\n#endif\t \n}\n\nstatic const struct w1_family_ops w1_f23_fops = {\n\t.add_slave      = w1_f23_add_slave,\n\t.remove_slave   = w1_f23_remove_slave,\n\t.groups\t\t= w1_f23_groups,\n};\n\nstatic struct w1_family w1_family_23 = {\n\t.fid = W1_EEPROM_DS2433,\n\t.fops = &w1_f23_fops,\n};\nmodule_w1_family(w1_family_23);\n\nMODULE_AUTHOR(\"Ben Gardner <bgardner@wabtec.com>\");\nMODULE_DESCRIPTION(\"w1 family 23 driver for DS2433, 4kb EEPROM\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_EEPROM_DS2433));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}