{
  "module_name": "w1_ds2805.c",
  "hash_id": "702cdc3886122eea6ff1992bb5afcd2259a951bd3c01e35d86472a613cd3973d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2805.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/w1.h>\n\n#define W1_EEPROM_DS2805       0x0D\n\n#define W1_F0D_EEPROM_SIZE\t\t128\n#define W1_F0D_PAGE_BITS\t\t3\n#define W1_F0D_PAGE_SIZE\t\t(1<<W1_F0D_PAGE_BITS)\n#define W1_F0D_PAGE_MASK\t\t0x0F\n\n#define W1_F0D_SCRATCH_BITS  1\n#define W1_F0D_SCRATCH_SIZE  (1<<W1_F0D_SCRATCH_BITS)\n#define W1_F0D_SCRATCH_MASK  (W1_F0D_SCRATCH_SIZE-1)\n\n#define W1_F0D_READ_EEPROM\t0xF0\n#define W1_F0D_WRITE_EEPROM\t0x55\n#define W1_F0D_RELEASE\t\t0xFF\n\n#define W1_F0D_CS_OK\t\t0xAA  \n\n#define W1_F0D_TPROG_MS\t\t16\n\n#define W1_F0D_READ_RETRIES\t\t10\n#define W1_F0D_READ_MAXLEN\t\tW1_F0D_EEPROM_SIZE\n\n \nstatic inline size_t w1_f0d_fix_count(loff_t off, size_t count, size_t size)\n{\n\tif (off > size)\n\t\treturn 0;\n\n\tif ((off + count) > size)\n\t\treturn size - off;\n\n\treturn count;\n}\n\n \nstatic int w1_f0d_readblock(struct w1_slave *sl, int off, int count, char *buf)\n{\n\tu8 wrbuf[3];\n\tu8 cmp[W1_F0D_READ_MAXLEN];\n\tint tries = W1_F0D_READ_RETRIES;\n\n\tdo {\n\t\twrbuf[0] = W1_F0D_READ_EEPROM;\n\t\twrbuf[1] = off & 0x7f;\n\t\twrbuf[2] = 0;\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, sizeof(wrbuf));\n\t\tw1_read_block(sl->master, buf, count);\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, sizeof(wrbuf));\n\t\tw1_read_block(sl->master, cmp, count);\n\n\t\tif (!memcmp(cmp, buf, count))\n\t\t\treturn 0;\n\t} while (--tries);\n\n\tdev_err(&sl->dev, \"proof reading failed %d times\\n\",\n\t\t\tW1_F0D_READ_RETRIES);\n\n\treturn -1;\n}\n\nstatic ssize_t w1_f0d_read_bin(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint todo = count;\n\n\tcount = w1_f0d_fix_count(off, count, W1_F0D_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->mutex);\n\n\t \n\twhile (todo > 0) {\n\t\tint block_read;\n\n\t\tif (todo >= W1_F0D_READ_MAXLEN)\n\t\t\tblock_read = W1_F0D_READ_MAXLEN;\n\t\telse\n\t\t\tblock_read = todo;\n\n\t\tif (w1_f0d_readblock(sl, off, block_read, buf) < 0) {\n\t\t\tcount = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\ttodo -= W1_F0D_READ_MAXLEN;\n\t\tbuf += W1_F0D_READ_MAXLEN;\n\t\toff += W1_F0D_READ_MAXLEN;\n\t}\n\n\tmutex_unlock(&sl->master->mutex);\n\n\treturn count;\n}\n\n \nstatic int w1_f0d_write(struct w1_slave *sl, int addr, int len, const u8 *data)\n{\n\tint tries = W1_F0D_READ_RETRIES;\n\tu8 wrbuf[3];\n\tu8 rdbuf[W1_F0D_SCRATCH_SIZE];\n\tu8 cs;\n\n\tif ((addr & 1) || (len != 2)) {\n\t\tdev_err(&sl->dev, \"%s: bad addr/len -  addr=%#x len=%d\\n\",\n\t\t    __func__, addr, len);\n\t\treturn -1;\n\t}\n\nretry:\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F0D_WRITE_EEPROM;\n\twrbuf[1] = addr & 0xff;\n\twrbuf[2] = 0xff;  \n\n\tw1_write_block(sl->master, wrbuf, sizeof(wrbuf));\n\tw1_write_block(sl->master, data, len);\n\n\tw1_read_block(sl->master, rdbuf, sizeof(rdbuf));\n\t \n\tif ((rdbuf[0] != data[0]) || (rdbuf[1] != data[1])) {\n\n\t\tif (--tries)\n\t\t\tgoto retry;\n\n\t\tdev_err(&sl->dev,\n\t\t\t\"could not write to eeprom, scratchpad compare failed %d times\\n\",\n\t\t\tW1_F0D_READ_RETRIES);\n\t\tpr_info(\"%s: rdbuf = %#x %#x data = %#x %#x\\n\",\n\t\t    __func__, rdbuf[0], rdbuf[1], data[0], data[1]);\n\n\t\treturn -1;\n\t}\n\n\t \n\tw1_write_8(sl->master, W1_F0D_RELEASE);\n\n\t \n\tmsleep(W1_F0D_TPROG_MS);\n\n\t \n\tcs = w1_read_8(sl->master);\n\tif (cs != W1_F0D_CS_OK) {\n\t\tdev_err(&sl->dev, \"save to eeprom failed = CS=%#x\\n\", cs);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t w1_f0d_write_bin(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint addr, len;\n\tint copy;\n\n\tcount = w1_f0d_fix_count(off, count, W1_F0D_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->mutex);\n\n\t \n\taddr = off;\n\tlen = count;\n\twhile (len > 0) {\n\n\t\t \n\t\tif (len < W1_F0D_SCRATCH_SIZE || addr & W1_F0D_SCRATCH_MASK) {\n\t\t\tchar tmp[W1_F0D_SCRATCH_SIZE];\n\n\t\t\t \n\t\t\tif (w1_f0d_readblock(sl, addr & ~W1_F0D_SCRATCH_MASK,\n\t\t\t\t\tW1_F0D_SCRATCH_SIZE, tmp)) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\n\t\t\t \n\t\t\tcopy = W1_F0D_SCRATCH_SIZE -\n\t\t\t\t(addr & W1_F0D_SCRATCH_MASK);\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\n\t\t\tmemcpy(&tmp[addr & W1_F0D_SCRATCH_MASK], buf, copy);\n\t\t\tif (w1_f0d_write(sl, addr & ~W1_F0D_SCRATCH_MASK,\n\t\t\t\t\tW1_F0D_SCRATCH_SIZE, tmp) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t} else {\n\n\t\t\tcopy = W1_F0D_SCRATCH_SIZE;\n\t\t\tif (w1_f0d_write(sl, addr, copy, buf) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t}\n\t\tbuf += copy;\n\t\taddr += copy;\n\t\tlen -= copy;\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->mutex);\n\n\treturn count;\n}\n\nstatic struct bin_attribute w1_f0d_bin_attr = {\n\t.attr = {\n\t\t.name = \"eeprom\",\n\t\t.mode = 0644,\n\t},\n\t.size = W1_F0D_EEPROM_SIZE,\n\t.read = w1_f0d_read_bin,\n\t.write = w1_f0d_write_bin,\n};\n\nstatic int w1_f0d_add_slave(struct w1_slave *sl)\n{\n\treturn sysfs_create_bin_file(&sl->dev.kobj, &w1_f0d_bin_attr);\n}\n\nstatic void w1_f0d_remove_slave(struct w1_slave *sl)\n{\n\tsysfs_remove_bin_file(&sl->dev.kobj, &w1_f0d_bin_attr);\n}\n\nstatic const struct w1_family_ops w1_f0d_fops = {\n\t.add_slave      = w1_f0d_add_slave,\n\t.remove_slave   = w1_f0d_remove_slave,\n};\n\nstatic struct w1_family w1_family_0d = {\n\t.fid = W1_EEPROM_DS2805,\n\t.fops = &w1_f0d_fops,\n};\n\nmodule_w1_family(w1_family_0d);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrew Worsley amworsley@gmail.com\");\nMODULE_DESCRIPTION(\"w1 family 0d driver for DS2805, 1kb EEPROM\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}