{
  "module_name": "w1_ds2438.c",
  "hash_id": "e160f69f39b269cc0eb6e7268e3dbf2259a2d5c957b0b5b6532d7c818f5bb991",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2438.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS2438\t\t0x26\n\n#define W1_DS2438_RETRIES\t\t3\n\n \n#define W1_DS2438_READ_SCRATCH\t\t0xBE\n#define W1_DS2438_WRITE_SCRATCH\t\t0x4E\n#define W1_DS2438_COPY_SCRATCH\t\t0x48\n#define W1_DS2438_RECALL_MEMORY\t\t0xB8\n \n#define W1_DS2438_CONVERT_TEMP\t\t0x44\n#define W1_DS2438_CONVERT_VOLTAGE\t0xB4\n\n#define DS2438_PAGE_SIZE\t\t8\n#define DS2438_ADC_INPUT_VAD\t\t0\n#define DS2438_ADC_INPUT_VDD\t\t1\n#define DS2438_MAX_CONVERSION_TIME\t10\t\t \n\n \n#define DS2438_STATUS_REG\t\t0x00\t\t \n#define DS2438_STATUS_IAD\t\t(1 << 0)\t \n#define DS2438_STATUS_CA\t\t(1 << 1)\t \n#define DS2438_STATUS_EE\t\t(1 << 2)\t \n#define DS2438_STATUS_AD\t\t(1 << 3)\t \n#define DS2438_STATUS_TB\t\t(1 << 4)\t \n#define DS2438_STATUS_NVB\t\t(1 << 5)\t \n#define DS2438_STATUS_ADB\t\t(1 << 6)\t \n\n#define DS2438_TEMP_LSB\t\t\t0x01\n#define DS2438_TEMP_MSB\t\t\t0x02\n#define DS2438_VOLTAGE_LSB\t\t0x03\n#define DS2438_VOLTAGE_MSB\t\t0x04\n#define DS2438_CURRENT_LSB\t\t0x05\n#define DS2438_CURRENT_MSB\t\t0x06\n#define DS2438_THRESHOLD\t\t0x07\n\n \n#define DS2438_ETM_0\t\t\t0x00\n#define DS2438_ETM_1\t\t\t0x01\n#define DS2438_ETM_2\t\t\t0x02\n#define DS2438_ETM_3\t\t\t0x03\n#define DS2438_ICA\t\t\t0x04\n#define DS2438_OFFSET_LSB\t\t0x05\n#define DS2438_OFFSET_MSB\t\t0x06\n\nstatic int w1_ds2438_get_page(struct w1_slave *sl, int pageno, u8 *buf)\n{\n\tunsigned int retries = W1_DS2438_RETRIES;\n\tu8 w1_buf[2];\n\tu8 crc;\n\tsize_t count;\n\n\twhile (retries--) {\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_buf[0] = W1_DS2438_RECALL_MEMORY;\n\t\tw1_buf[1] = (u8)pageno;\n\t\tw1_write_block(sl->master, w1_buf, 2);\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_buf[0] = W1_DS2438_READ_SCRATCH;\n\t\tw1_buf[1] = (u8)pageno;\n\t\tw1_write_block(sl->master, w1_buf, 2);\n\n\t\tcount = w1_read_block(sl->master, buf, DS2438_PAGE_SIZE + 1);\n\t\tif (count == DS2438_PAGE_SIZE + 1) {\n\t\t\tcrc = w1_calc_crc8(buf, DS2438_PAGE_SIZE);\n\n\t\t\t \n\t\t\tif ((u8)buf[DS2438_PAGE_SIZE] == crc)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int w1_ds2438_get_temperature(struct w1_slave *sl, int16_t *temperature)\n{\n\tunsigned int retries = W1_DS2438_RETRIES;\n\tu8 w1_buf[DS2438_PAGE_SIZE + 1  ];\n\tunsigned int tm = DS2438_MAX_CONVERSION_TIME;\n\tunsigned long sleep_rem;\n\tint ret;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\twhile (retries--) {\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_write_8(sl->master, W1_DS2438_CONVERT_TEMP);\n\n\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\tsleep_rem = msleep_interruptible(tm);\n\t\tif (sleep_rem != 0) {\n\t\t\tret = -1;\n\t\t\tgoto post_unlock;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&sl->master->bus_mutex) != 0) {\n\t\t\tret = -1;\n\t\t\tgoto post_unlock;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (w1_ds2438_get_page(sl, 0, w1_buf) == 0) {\n\t\t*temperature = (((int16_t) w1_buf[DS2438_TEMP_MSB]) << 8) | ((uint16_t) w1_buf[DS2438_TEMP_LSB]);\n\t\tret = 0;\n\t} else\n\t\tret = -1;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\npost_unlock:\n\treturn ret;\n}\n\nstatic int w1_ds2438_change_config_bit(struct w1_slave *sl, u8 mask, u8 value)\n{\n\tunsigned int retries = W1_DS2438_RETRIES;\n\tu8 w1_buf[3];\n\tu8 status;\n\tint perform_write = 0;\n\n\twhile (retries--) {\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_buf[0] = W1_DS2438_RECALL_MEMORY;\n\t\tw1_buf[1] = 0x00;\n\t\tw1_write_block(sl->master, w1_buf, 2);\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_buf[0] = W1_DS2438_READ_SCRATCH;\n\t\tw1_buf[1] = 0x00;\n\t\tw1_write_block(sl->master, w1_buf, 2);\n\n\t\t \n\t\tstatus = w1_read_8(sl->master);\n\n\t\t \n\t\tif (value)\n\t\t\tvalue = mask;\n\n\t\tif ((status & mask) == value)\n\t\t\treturn 0;\t \n\n\t\t \n\t\tstatus ^= mask;\n\t\tperform_write = 1;\n\n\t\tbreak;\n\t}\n\n\tif (perform_write) {\n\t\tretries = W1_DS2438_RETRIES;\n\t\twhile (retries--) {\n\t\t\tif (w1_reset_select_slave(sl))\n\t\t\t\tcontinue;\n\t\t\tw1_buf[0] = W1_DS2438_WRITE_SCRATCH;\n\t\t\tw1_buf[1] = 0x00;\n\t\t\tw1_buf[2] = status;\n\t\t\tw1_write_block(sl->master, w1_buf, 3);\n\n\t\t\tif (w1_reset_select_slave(sl))\n\t\t\t\tcontinue;\n\t\t\tw1_buf[0] = W1_DS2438_COPY_SCRATCH;\n\t\t\tw1_buf[1] = 0x00;\n\t\t\tw1_write_block(sl->master, w1_buf, 2);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int w1_ds2438_change_offset_register(struct w1_slave *sl, u8 *value)\n{\n\tunsigned int retries = W1_DS2438_RETRIES;\n\tu8 w1_buf[9];\n\tu8 w1_page1_buf[DS2438_PAGE_SIZE + 1  ];\n\n\tif (w1_ds2438_get_page(sl, 1, w1_page1_buf) == 0) {\n\t\tmemcpy(&w1_buf[2], w1_page1_buf, DS2438_PAGE_SIZE - 1);  \n\t\tw1_buf[7] = value[0];  \n\t\tw1_buf[8] = value[1];\n\t\twhile (retries--) {\n\t\t\tif (w1_reset_select_slave(sl))\n\t\t\t\tcontinue;\n\t\t\tw1_buf[0] = W1_DS2438_WRITE_SCRATCH;\n\t\t\tw1_buf[1] = 0x01;  \n\t\t\tw1_write_block(sl->master, w1_buf, 9);\n\n\t\t\tif (w1_reset_select_slave(sl))\n\t\t\t\tcontinue;\n\t\t\tw1_buf[0] = W1_DS2438_COPY_SCRATCH;\n\t\t\tw1_buf[1] = 0x01;\n\t\t\tw1_write_block(sl->master, w1_buf, 2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int w1_ds2438_get_voltage(struct w1_slave *sl,\n\t\t\t\t int adc_input, uint16_t *voltage)\n{\n\tunsigned int retries = W1_DS2438_RETRIES;\n\tu8 w1_buf[DS2438_PAGE_SIZE + 1  ];\n\tunsigned int tm = DS2438_MAX_CONVERSION_TIME;\n\tunsigned long sleep_rem;\n\tint ret;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_ds2438_change_config_bit(sl, DS2438_STATUS_AD, adc_input)) {\n\t\tret = -1;\n\t\tgoto pre_unlock;\n\t}\n\n\twhile (retries--) {\n\t\tif (w1_reset_select_slave(sl))\n\t\t\tcontinue;\n\t\tw1_write_8(sl->master, W1_DS2438_CONVERT_VOLTAGE);\n\n\t\tmutex_unlock(&sl->master->bus_mutex);\n\t\tsleep_rem = msleep_interruptible(tm);\n\t\tif (sleep_rem != 0) {\n\t\t\tret = -1;\n\t\t\tgoto post_unlock;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&sl->master->bus_mutex) != 0) {\n\t\t\tret = -1;\n\t\t\tgoto post_unlock;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (w1_ds2438_get_page(sl, 0, w1_buf) == 0) {\n\t\t*voltage = (((uint16_t) w1_buf[DS2438_VOLTAGE_MSB]) << 8) | ((uint16_t) w1_buf[DS2438_VOLTAGE_LSB]);\n\t\tret = 0;\n\t} else\n\t\tret = -1;\n\npre_unlock:\n\tmutex_unlock(&sl->master->bus_mutex);\n\npost_unlock:\n\treturn ret;\n}\n\nstatic int w1_ds2438_get_current(struct w1_slave *sl, int16_t *voltage)\n{\n\tu8 w1_buf[DS2438_PAGE_SIZE + 1  ];\n\tint ret;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_ds2438_get_page(sl, 0, w1_buf) == 0) {\n\t\t \n\t\t*voltage = (((int16_t) w1_buf[DS2438_CURRENT_MSB]) << 8) | ((int16_t) w1_buf[DS2438_CURRENT_LSB]);\n\t\tret = 0;\n\t} else\n\t\tret = -1;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t iad_write(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\n\tif (count != 1 || off != 0)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_ds2438_change_config_bit(sl, DS2438_STATUS_IAD, *buf & 0x01) == 0)\n\t\tret = 1;\n\telse\n\t\tret = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t iad_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\tloff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tint16_t voltage;\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (w1_ds2438_get_current(sl, &voltage) == 0)\n\t\tret = snprintf(buf, count, \"%i\\n\", voltage);\n\telse\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic ssize_t page0_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf,\n\t\t\t  loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tu8 w1_buf[DS2438_PAGE_SIZE + 1  ];\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tif (count > DS2438_PAGE_SIZE)\n\t\tcount = DS2438_PAGE_SIZE;\n\n\tif (w1_ds2438_get_page(sl, 0, w1_buf) == 0) {\n\t\tmemcpy(buf, &w1_buf, count);\n\t\tret = count;\n\t} else\n\t\tret = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t page1_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr, char *buf,\n\t\t\t  loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tu8 w1_buf[DS2438_PAGE_SIZE + 1  ];\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\tif (count > DS2438_PAGE_SIZE)\n\t\tcount = DS2438_PAGE_SIZE;\n\n\tif (w1_ds2438_get_page(sl, 1, w1_buf) == 0) {\n\t\tmemcpy(buf, &w1_buf, count);\n\t\tret = count;\n\t} else\n\t\tret = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t offset_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_ds2438_change_offset_register(sl, buf) == 0)\n\t\tret = count;\n\telse\n\t\tret = -EIO;\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t temperature_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tint16_t temp;\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (w1_ds2438_get_temperature(sl, &temp) == 0)\n\t\tret = snprintf(buf, count, \"%i\\n\", temp);\n\telse\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic ssize_t vad_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\tloff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tuint16_t voltage;\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (w1_ds2438_get_voltage(sl, DS2438_ADC_INPUT_VAD, &voltage) == 0)\n\t\tret = snprintf(buf, count, \"%u\\n\", voltage);\n\telse\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic ssize_t vdd_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\tloff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\tuint16_t voltage;\n\n\tif (off != 0)\n\t\treturn 0;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (w1_ds2438_get_voltage(sl, DS2438_ADC_INPUT_VDD, &voltage) == 0)\n\t\tret = snprintf(buf, count, \"%u\\n\", voltage);\n\telse\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic BIN_ATTR_RW(iad, 0);\nstatic BIN_ATTR_RO(page0, DS2438_PAGE_SIZE);\nstatic BIN_ATTR_RO(page1, DS2438_PAGE_SIZE);\nstatic BIN_ATTR_WO(offset, 2);\nstatic BIN_ATTR_RO(temperature, 0 );\nstatic BIN_ATTR_RO(vad, 0 );\nstatic BIN_ATTR_RO(vdd, 0 );\n\nstatic struct bin_attribute *w1_ds2438_bin_attrs[] = {\n\t&bin_attr_iad,\n\t&bin_attr_page0,\n\t&bin_attr_page1,\n\t&bin_attr_offset,\n\t&bin_attr_temperature,\n\t&bin_attr_vad,\n\t&bin_attr_vdd,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_ds2438_group = {\n\t.bin_attrs = w1_ds2438_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_ds2438_groups[] = {\n\t&w1_ds2438_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_ds2438_fops = {\n\t.groups\t\t= w1_ds2438_groups,\n};\n\nstatic struct w1_family w1_ds2438_family = {\n\t.fid = W1_FAMILY_DS2438,\n\t.fops = &w1_ds2438_fops,\n};\nmodule_w1_family(w1_ds2438_family);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mariusz Bialonczyk <manio@skyboo.net>\");\nMODULE_DESCRIPTION(\"1-wire driver for Maxim/Dallas DS2438 Smart Battery Monitor\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2438));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}