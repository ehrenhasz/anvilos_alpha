{
  "module_name": "w1_ds2431.c",
  "hash_id": "198ce69162e259e9eaa6a1c83b49296296822f80964958c2b0a80152615b0406",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2431.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/w1.h>\n\n#define W1_EEPROM_DS2431\t0x2D\n\n#define W1_F2D_EEPROM_SIZE\t\t128\n#define W1_F2D_PAGE_COUNT\t\t4\n#define W1_F2D_PAGE_BITS\t\t5\n#define W1_F2D_PAGE_SIZE\t\t(1<<W1_F2D_PAGE_BITS)\n#define W1_F2D_PAGE_MASK\t\t0x1F\n\n#define W1_F2D_SCRATCH_BITS  3\n#define W1_F2D_SCRATCH_SIZE  (1<<W1_F2D_SCRATCH_BITS)\n#define W1_F2D_SCRATCH_MASK  (W1_F2D_SCRATCH_SIZE-1)\n\n#define W1_F2D_READ_EEPROM\t0xF0\n#define W1_F2D_WRITE_SCRATCH\t0x0F\n#define W1_F2D_READ_SCRATCH\t0xAA\n#define W1_F2D_COPY_SCRATCH\t0x55\n\n\n#define W1_F2D_TPROG_MS\t\t11\n\n#define W1_F2D_READ_RETRIES\t\t10\n#define W1_F2D_READ_MAXLEN\t\t8\n\n \nstatic inline size_t w1_f2d_fix_count(loff_t off, size_t count, size_t size)\n{\n\tif (off > size)\n\t\treturn 0;\n\n\tif ((off + count) > size)\n\t\treturn size - off;\n\n\treturn count;\n}\n\n \nstatic int w1_f2d_readblock(struct w1_slave *sl, int off, int count, char *buf)\n{\n\tu8 wrbuf[3];\n\tu8 cmp[W1_F2D_READ_MAXLEN];\n\tint tries = W1_F2D_READ_RETRIES;\n\n\tdo {\n\t\twrbuf[0] = W1_F2D_READ_EEPROM;\n\t\twrbuf[1] = off & 0xff;\n\t\twrbuf[2] = off >> 8;\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, 3);\n\t\tw1_read_block(sl->master, buf, count);\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, 3);\n\t\tw1_read_block(sl->master, cmp, count);\n\n\t\tif (!memcmp(cmp, buf, count))\n\t\t\treturn 0;\n\t} while (--tries);\n\n\tdev_err(&sl->dev, \"proof reading failed %d times\\n\",\n\t\t\tW1_F2D_READ_RETRIES);\n\n\treturn -1;\n}\n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t   loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint todo = count;\n\n\tcount = w1_f2d_fix_count(off, count, W1_F2D_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\twhile (todo > 0) {\n\t\tint block_read;\n\n\t\tif (todo >= W1_F2D_READ_MAXLEN)\n\t\t\tblock_read = W1_F2D_READ_MAXLEN;\n\t\telse\n\t\t\tblock_read = todo;\n\n\t\tif (w1_f2d_readblock(sl, off, block_read, buf) < 0)\n\t\t\tcount = -EIO;\n\n\t\ttodo -= W1_F2D_READ_MAXLEN;\n\t\tbuf += W1_F2D_READ_MAXLEN;\n\t\toff += W1_F2D_READ_MAXLEN;\n\t}\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\n \nstatic int w1_f2d_write(struct w1_slave *sl, int addr, int len, const u8 *data)\n{\n\tint tries = W1_F2D_READ_RETRIES;\n\tu8 wrbuf[4];\n\tu8 rdbuf[W1_F2D_SCRATCH_SIZE + 3];\n\tu8 es = (addr + len - 1) % W1_F2D_SCRATCH_SIZE;\n\nretry:\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F2D_WRITE_SCRATCH;\n\twrbuf[1] = addr & 0xff;\n\twrbuf[2] = addr >> 8;\n\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_write_block(sl->master, data, len);\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\tw1_write_8(sl->master, W1_F2D_READ_SCRATCH);\n\tw1_read_block(sl->master, rdbuf, len + 3);\n\n\t \n\tif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\n\t    (rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0)) {\n\n\t\tif (--tries)\n\t\t\tgoto retry;\n\n\t\tdev_err(&sl->dev,\n\t\t\t\"could not write to eeprom, scratchpad compare failed %d times\\n\",\n\t\t\tW1_F2D_READ_RETRIES);\n\n\t\treturn -1;\n\t}\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F2D_COPY_SCRATCH;\n\twrbuf[3] = es;\n\tw1_write_block(sl->master, wrbuf, 4);\n\n\t \n\tmsleep(W1_F2D_TPROG_MS);\n\n\t \n\tw1_reset_bus(sl->master);\n\n\treturn 0;\n}\n\nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint addr, len;\n\tint copy;\n\n\tcount = w1_f2d_fix_count(off, count, W1_F2D_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\taddr = off;\n\tlen = count;\n\twhile (len > 0) {\n\n\t\t \n\t\tif (len < W1_F2D_SCRATCH_SIZE || addr & W1_F2D_SCRATCH_MASK) {\n\t\t\tchar tmp[W1_F2D_SCRATCH_SIZE];\n\n\t\t\t \n\t\t\tif (w1_f2d_readblock(sl, addr & ~W1_F2D_SCRATCH_MASK,\n\t\t\t\t\tW1_F2D_SCRATCH_SIZE, tmp)) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\n\t\t\t \n\t\t\tcopy = W1_F2D_SCRATCH_SIZE -\n\t\t\t\t(addr & W1_F2D_SCRATCH_MASK);\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\n\t\t\tmemcpy(&tmp[addr & W1_F2D_SCRATCH_MASK], buf, copy);\n\t\t\tif (w1_f2d_write(sl, addr & ~W1_F2D_SCRATCH_MASK,\n\t\t\t\t\tW1_F2D_SCRATCH_SIZE, tmp) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t} else {\n\n\t\t\tcopy = W1_F2D_SCRATCH_SIZE;\n\t\t\tif (w1_f2d_write(sl, addr, copy, buf) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t}\n\t\tbuf += copy;\n\t\taddr += copy;\n\t\tlen -= copy;\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(eeprom, W1_F2D_EEPROM_SIZE);\n\nstatic struct bin_attribute *w1_f2d_bin_attrs[] = {\n\t&bin_attr_eeprom,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f2d_group = {\n\t.bin_attrs = w1_f2d_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_f2d_groups[] = {\n\t&w1_f2d_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_f2d_fops = {\n\t.groups\t\t= w1_f2d_groups,\n};\n\nstatic struct w1_family w1_family_2d = {\n\t.fid = W1_EEPROM_DS2431,\n\t.fops = &w1_f2d_fops,\n};\nmodule_w1_family(w1_family_2d);\n\nMODULE_AUTHOR(\"Bernhard Weirich <bernhard.weirich@riedel.net>\");\nMODULE_DESCRIPTION(\"w1 family 2d driver for DS2431, 1kb EEPROM\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_EEPROM_DS2431));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}