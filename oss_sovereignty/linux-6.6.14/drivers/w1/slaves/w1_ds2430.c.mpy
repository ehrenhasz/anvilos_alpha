{
  "module_name": "w1_ds2430.c",
  "hash_id": "09c7c31e751d6d5eef6bb4f5a0172396a4ba6870571cf327f0d5301c815f37bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2430.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/w1.h>\n\n#define W1_EEPROM_DS2430\t0x14\n\n#define W1_F14_EEPROM_SIZE\t32\n#define W1_F14_PAGE_COUNT\t1\n#define W1_F14_PAGE_BITS\t5\n#define W1_F14_PAGE_SIZE\t(1 << W1_F14_PAGE_BITS)\n#define W1_F14_PAGE_MASK\t0x1F\n\n#define W1_F14_SCRATCH_BITS\t5\n#define W1_F14_SCRATCH_SIZE\t(1 << W1_F14_SCRATCH_BITS)\n#define W1_F14_SCRATCH_MASK\t(W1_F14_SCRATCH_SIZE-1)\n\n#define W1_F14_READ_EEPROM\t0xF0\n#define W1_F14_WRITE_SCRATCH\t0x0F\n#define W1_F14_READ_SCRATCH\t0xAA\n#define W1_F14_COPY_SCRATCH\t0x55\n#define W1_F14_VALIDATION_KEY\t0xa5\n\n#define W1_F14_TPROG_MS\t\t11\n#define W1_F14_READ_RETRIES\t10\n#define W1_F14_READ_MAXLEN\tW1_F14_SCRATCH_SIZE\n\n \nstatic inline size_t w1_f14_fix_count(loff_t off, size_t count, size_t size)\n{\n\tif (off > size)\n\t\treturn 0;\n\n\tif ((off + count) > size)\n\t\treturn size - off;\n\n\treturn count;\n}\n\n \nstatic int w1_f14_readblock(struct w1_slave *sl, int off, int count, char *buf)\n{\n\tu8 wrbuf[2];\n\tu8 cmp[W1_F14_READ_MAXLEN];\n\tint tries = W1_F14_READ_RETRIES;\n\n\tdo {\n\t\twrbuf[0] = W1_F14_READ_EEPROM;\n\t\twrbuf[1] = off & 0xff;\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, 2);\n\t\tw1_read_block(sl->master, buf, count);\n\n\t\tif (w1_reset_select_slave(sl))\n\t\t\treturn -1;\n\n\t\tw1_write_block(sl->master, wrbuf, 2);\n\t\tw1_read_block(sl->master, cmp, count);\n\n\t\tif (!memcmp(cmp, buf, count))\n\t\t\treturn 0;\n\t} while (--tries);\n\n\tdev_err(&sl->dev, \"proof reading failed %d times\\n\",\n\t\t\tW1_F14_READ_RETRIES);\n\n\treturn -1;\n}\n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t   loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint todo = count;\n\n\tcount = w1_f14_fix_count(off, count, W1_F14_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\twhile (todo > 0) {\n\t\tint block_read;\n\n\t\tif (todo >= W1_F14_READ_MAXLEN)\n\t\t\tblock_read = W1_F14_READ_MAXLEN;\n\t\telse\n\t\t\tblock_read = todo;\n\n\t\tif (w1_f14_readblock(sl, off, block_read, buf) < 0)\n\t\t\tcount = -EIO;\n\n\t\ttodo -= W1_F14_READ_MAXLEN;\n\t\tbuf += W1_F14_READ_MAXLEN;\n\t\toff += W1_F14_READ_MAXLEN;\n\t}\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\n \nstatic int w1_f14_write(struct w1_slave *sl, int addr, int len, const u8 *data)\n{\n\tint tries = W1_F14_READ_RETRIES;\n\tu8 wrbuf[2];\n\tu8 rdbuf[W1_F14_SCRATCH_SIZE + 3];\n\nretry:\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F14_WRITE_SCRATCH;\n\twrbuf[1] = addr & 0xff;\n\n\tw1_write_block(sl->master, wrbuf, 2);\n\tw1_write_block(sl->master, data, len);\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\tw1_write_8(sl->master, W1_F14_READ_SCRATCH);\n\tw1_read_block(sl->master, rdbuf, len + 2);\n\n\t \n\tif ((memcmp(data, &rdbuf[2], len) != 0)) {\n\n\t\tif (--tries)\n\t\t\tgoto retry;\n\n\t\tdev_err(&sl->dev,\n\t\t\t\"could not write to eeprom, scratchpad compare failed %d times\\n\",\n\t\t\tW1_F14_READ_RETRIES);\n\n\t\treturn -1;\n\t}\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F14_COPY_SCRATCH;\n\twrbuf[1] = W1_F14_VALIDATION_KEY;\n\tw1_write_block(sl->master, wrbuf, 2);\n\n\t \n\tmsleep(W1_F14_TPROG_MS);\n\n\t \n\tw1_reset_bus(sl->master);\n\n\treturn 0;\n}\n\nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint addr, len;\n\tint copy;\n\n\tcount = w1_f14_fix_count(off, count, W1_F14_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\t \n\taddr = off;\n\tlen = count;\n\twhile (len > 0) {\n\n\t\t \n\t\tif (len < W1_F14_SCRATCH_SIZE || addr & W1_F14_SCRATCH_MASK) {\n\t\t\tchar tmp[W1_F14_SCRATCH_SIZE];\n\n\t\t\t \n\t\t\tif (w1_f14_readblock(sl, addr & ~W1_F14_SCRATCH_MASK,\n\t\t\t\t\tW1_F14_SCRATCH_SIZE, tmp)) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\n\t\t\t \n\t\t\tcopy = W1_F14_SCRATCH_SIZE -\n\t\t\t\t(addr & W1_F14_SCRATCH_MASK);\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\n\t\t\tmemcpy(&tmp[addr & W1_F14_SCRATCH_MASK], buf, copy);\n\t\t\tif (w1_f14_write(sl, addr & ~W1_F14_SCRATCH_MASK,\n\t\t\t\t\tW1_F14_SCRATCH_SIZE, tmp) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t} else {\n\n\t\t\tcopy = W1_F14_SCRATCH_SIZE;\n\t\t\tif (w1_f14_write(sl, addr, copy, buf) < 0) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t}\n\t\tbuf += copy;\n\t\taddr += copy;\n\t\tlen -= copy;\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(eeprom, W1_F14_EEPROM_SIZE);\n\nstatic struct bin_attribute *w1_f14_bin_attrs[] = {\n\t&bin_attr_eeprom,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f14_group = {\n\t.bin_attrs = w1_f14_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_f14_groups[] = {\n\t&w1_f14_group,\n\tNULL,\n};\n\nstatic const struct w1_family_ops w1_f14_fops = {\n\t.groups\t= w1_f14_groups,\n};\n\nstatic struct w1_family w1_family_14 = {\n\t.fid = W1_EEPROM_DS2430,\n\t.fops = &w1_f14_fops,\n};\nmodule_w1_family(w1_family_14);\n\nMODULE_AUTHOR(\"Angelo Dureghello <angelo.dureghello@timesys.com>\");\nMODULE_DESCRIPTION(\"w1 family 14 driver for DS2430, 256b EEPROM\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_EEPROM_DS2430));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}