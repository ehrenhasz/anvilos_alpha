{
  "module_name": "w1_ds2423.c",
  "hash_id": "5818b830cbe8ce13f214cdce313881d0674486f26a442fe50aee0683668fa511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds2423.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/crc16.h>\n\n#include <linux/w1.h>\n\n#define W1_COUNTER_DS2423\t0x1D\n\n#define CRC16_VALID\t0xb001\n#define CRC16_INIT\t0\n\n#define COUNTER_COUNT 4\n#define READ_BYTE_COUNT 42\n\nstatic ssize_t w1_slave_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *out_buf)\n{\n\tstruct w1_slave *sl = dev_to_w1_slave(device);\n\tstruct w1_master *dev = sl->master;\n\tu8 rbuf[COUNTER_COUNT * READ_BYTE_COUNT];\n\tu8 wrbuf[3];\n\tint rom_addr;\n\tint read_byte_count;\n\tint result;\n\tssize_t c;\n\tint ii;\n\tint p;\n\tint crc;\n\n\tc\t\t= PAGE_SIZE;\n\trom_addr\t= (12 << 5) + 31;\n\twrbuf[0]\t= 0xA5;\n\twrbuf[1]\t= rom_addr & 0xFF;\n\twrbuf[2]\t= rom_addr >> 8;\n\tmutex_lock(&dev->bus_mutex);\n\tif (!w1_reset_select_slave(sl)) {\n\t\tw1_write_block(dev, wrbuf, 3);\n\t\tread_byte_count = 0;\n\t\tfor (p = 0; p < 4; p++) {\n\t\t\t \n\t\t\tread_byte_count += w1_read_block(dev,\n\t\t\t\trbuf + (p * READ_BYTE_COUNT), READ_BYTE_COUNT);\n\t\t\tfor (ii = 0; ii < READ_BYTE_COUNT; ++ii)\n\t\t\t\tc -= snprintf(out_buf + PAGE_SIZE - c,\n\t\t\t\t\tc, \"%02x \",\n\t\t\t\t\trbuf[(p * READ_BYTE_COUNT) + ii]);\n\t\t\tif (read_byte_count != (p + 1) * READ_BYTE_COUNT) {\n\t\t\t\tdev_warn(device,\n\t\t\t\t\t\"w1_counter_read() returned %u bytes \"\n\t\t\t\t\t\"instead of %d bytes wanted.\\n\",\n\t\t\t\t\tread_byte_count,\n\t\t\t\t\tREAD_BYTE_COUNT);\n\t\t\t\tc -= snprintf(out_buf + PAGE_SIZE - c,\n\t\t\t\t\tc, \"crc=NO\\n\");\n\t\t\t} else {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tcrc = crc16(CRC16_INIT, wrbuf, 3);\n\t\t\t\t\tcrc = crc16(crc, rbuf, 11);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tcrc = crc16(CRC16_INIT,\n\t\t\t\t\t\t(rbuf + 11) +\n\t\t\t\t\t\t((p - 1) * READ_BYTE_COUNT),\n\t\t\t\t\t\tREAD_BYTE_COUNT);\n\t\t\t\t}\n\t\t\t\tif (crc == CRC16_VALID) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tfor (ii = 4; ii > 0; ii--) {\n\t\t\t\t\t\tresult <<= 8;\n\t\t\t\t\t\tresult |= rbuf[(p *\n\t\t\t\t\t\t\tREAD_BYTE_COUNT) + ii];\n\t\t\t\t\t}\n\t\t\t\t\tc -= snprintf(out_buf + PAGE_SIZE - c,\n\t\t\t\t\t\tc, \"crc=YES c=%d\\n\", result);\n\t\t\t\t} else {\n\t\t\t\t\tc -= snprintf(out_buf + PAGE_SIZE - c,\n\t\t\t\t\t\tc, \"crc=NO\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tc -= snprintf(out_buf + PAGE_SIZE - c, c, \"Connection error\");\n\t}\n\tmutex_unlock(&dev->bus_mutex);\n\treturn PAGE_SIZE - c;\n}\n\nstatic DEVICE_ATTR_RO(w1_slave);\n\nstatic struct attribute *w1_f1d_attrs[] = {\n\t&dev_attr_w1_slave.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(w1_f1d);\n\nstatic const struct w1_family_ops w1_f1d_fops = {\n\t.groups\t\t= w1_f1d_groups,\n};\n\nstatic struct w1_family w1_family_1d = {\n\t.fid = W1_COUNTER_DS2423,\n\t.fops = &w1_f1d_fops,\n};\nmodule_w1_family(w1_family_1d);\n\nMODULE_AUTHOR(\"Mika Laitio <lamikr@pilppa.org>\");\nMODULE_DESCRIPTION(\"w1 family 1d driver for DS2423, 4 counters and 4kb ram\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_COUNTER_DS2423));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}