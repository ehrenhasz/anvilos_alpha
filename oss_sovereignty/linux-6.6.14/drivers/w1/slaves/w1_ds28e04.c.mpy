{
  "module_name": "w1_ds28e04.c",
  "hash_id": "cb315c63aa8cac4e8abd00de1b928b35942c020f2d24131a1dec8d07c9128628",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/slaves/w1_ds28e04.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/crc16.h>\n#include <linux/uaccess.h>\n\n#define CRC16_INIT\t\t0\n#define CRC16_VALID\t\t0xb001\n\n#include <linux/w1.h>\n\n#define W1_FAMILY_DS28E04\t0x1C\n\n \nstatic int w1_strong_pullup = 1;\nmodule_param_named(strong_pullup, w1_strong_pullup, int, 0);\n\n \nstatic bool w1_enable_crccheck = true;\n\n#define W1_EEPROM_SIZE\t\t512\n#define W1_PAGE_COUNT\t\t16\n#define W1_PAGE_SIZE\t\t32\n#define W1_PAGE_BITS\t\t5\n#define W1_PAGE_MASK\t\t0x1F\n\n#define W1_F1C_READ_EEPROM\t0xF0\n#define W1_F1C_WRITE_SCRATCH\t0x0F\n#define W1_F1C_READ_SCRATCH\t0xAA\n#define W1_F1C_COPY_SCRATCH\t0x55\n#define W1_F1C_ACCESS_WRITE\t0x5A\n\n#define W1_1C_REG_LOGIC_STATE\t0x220\n\nstruct w1_f1C_data {\n\tu8\tmemory[W1_EEPROM_SIZE];\n\tu32\tvalidcrc;\n};\n\n \nstatic inline size_t w1_f1C_fix_count(loff_t off, size_t count, size_t size)\n{\n\tif (off > size)\n\t\treturn 0;\n\n\tif ((off + count) > size)\n\t\treturn size - off;\n\n\treturn count;\n}\n\nstatic int w1_f1C_refresh_block(struct w1_slave *sl, struct w1_f1C_data *data,\n\t\t\t\tint block)\n{\n\tu8\twrbuf[3];\n\tint\toff = block * W1_PAGE_SIZE;\n\n\tif (data->validcrc & (1 << block))\n\t\treturn 0;\n\n\tif (w1_reset_select_slave(sl)) {\n\t\tdata->validcrc = 0;\n\t\treturn -EIO;\n\t}\n\n\twrbuf[0] = W1_F1C_READ_EEPROM;\n\twrbuf[1] = off & 0xff;\n\twrbuf[2] = off >> 8;\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_read_block(sl->master, &data->memory[off], W1_PAGE_SIZE);\n\n\t \n\tif (crc16(CRC16_INIT, &data->memory[off], W1_PAGE_SIZE) == CRC16_VALID)\n\t\tdata->validcrc |= (1 << block);\n\n\treturn 0;\n}\n\nstatic int w1_f1C_read(struct w1_slave *sl, int addr, int len, char *data)\n{\n\tu8 wrbuf[3];\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -EIO;\n\n\twrbuf[0] = W1_F1C_READ_EEPROM;\n\twrbuf[1] = addr & 0xff;\n\twrbuf[2] = addr >> 8;\n\n\tw1_write_block(sl->master, wrbuf, sizeof(wrbuf));\n\treturn w1_read_block(sl->master, data, len);\n}\n\nstatic ssize_t eeprom_read(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t   loff_t off, size_t count)\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tstruct w1_f1C_data *data = sl->family_data;\n\tint i, min_page, max_page;\n\n\tcount = w1_f1C_fix_count(off, count, W1_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->mutex);\n\n\tif (w1_enable_crccheck) {\n\t\tmin_page = (off >> W1_PAGE_BITS);\n\t\tmax_page = (off + count - 1) >> W1_PAGE_BITS;\n\t\tfor (i = min_page; i <= max_page; i++) {\n\t\t\tif (w1_f1C_refresh_block(sl, data, i)) {\n\t\t\t\tcount = -EIO;\n\t\t\t\tgoto out_up;\n\t\t\t}\n\t\t}\n\t\tmemcpy(buf, &data->memory[off], count);\n\t} else {\n\t\tcount = w1_f1C_read(sl, off, count, buf);\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->mutex);\n\n\treturn count;\n}\n\n \nstatic int w1_f1C_write(struct w1_slave *sl, int addr, int len, const u8 *data)\n{\n\tu8 wrbuf[4];\n\tu8 rdbuf[W1_PAGE_SIZE + 3];\n\tu8 es = (addr + len - 1) & 0x1f;\n\tunsigned int tm = 10;\n\tint i;\n\tstruct w1_f1C_data *f1C = sl->family_data;\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F1C_WRITE_SCRATCH;\n\twrbuf[1] = addr & 0xff;\n\twrbuf[2] = addr >> 8;\n\n\tw1_write_block(sl->master, wrbuf, 3);\n\tw1_write_block(sl->master, data, len);\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\tw1_write_8(sl->master, W1_F1C_READ_SCRATCH);\n\tw1_read_block(sl->master, rdbuf, len + 3);\n\n\t \n\tif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\n\t    (rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0))\n\t\treturn -1;\n\n\t \n\tif (w1_reset_select_slave(sl))\n\t\treturn -1;\n\n\twrbuf[0] = W1_F1C_COPY_SCRATCH;\n\twrbuf[3] = es;\n\n\tfor (i = 0; i < sizeof(wrbuf); ++i) {\n\t\t \n\t\tif (w1_strong_pullup && i == sizeof(wrbuf)-1)\n\t\t\tw1_next_pullup(sl->master, tm);\n\n\t\tw1_write_8(sl->master, wrbuf[i]);\n\t}\n\n\tif (!w1_strong_pullup)\n\t\tmsleep(tm);\n\n\tif (w1_enable_crccheck) {\n\t\t \n\t\tf1C->validcrc &= ~(1 << (addr >> W1_PAGE_BITS));\n\t}\n\n\t \n\tw1_reset_bus(sl->master);\n\n\treturn 0;\n}\n\nstatic ssize_t eeprom_write(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint addr, len, idx;\n\n\tcount = w1_f1C_fix_count(off, count, W1_EEPROM_SIZE);\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (w1_enable_crccheck) {\n\t\t \n\t\tif ((off & W1_PAGE_MASK) || (count & W1_PAGE_MASK)) {\n\t\t\tdev_err(&sl->dev, \"invalid offset/count off=%d cnt=%zd\\n\",\n\t\t\t\t(int)off, count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (idx = 0; idx < count; idx += W1_PAGE_SIZE) {\n\t\t\tif (crc16(CRC16_INIT, &buf[idx], W1_PAGE_SIZE)\n\t\t\t\t!= CRC16_VALID) {\n\t\t\t\tdev_err(&sl->dev, \"bad CRC at offset %d\\n\",\n\t\t\t\t\t(int)off);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&sl->master->mutex);\n\n\t \n\tidx = 0;\n\twhile (idx < count) {\n\t\taddr = off + idx;\n\t\tlen = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);\n\t\tif (len > (count - idx))\n\t\t\tlen = count - idx;\n\n\t\tif (w1_f1C_write(sl, addr, len, &buf[idx]) < 0) {\n\t\t\tcount = -EIO;\n\t\t\tgoto out_up;\n\t\t}\n\t\tidx += len;\n\t}\n\nout_up:\n\tmutex_unlock(&sl->master->mutex);\n\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(eeprom, W1_EEPROM_SIZE);\n\nstatic ssize_t pio_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\tsize_t count)\n\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tint ret;\n\n\t \n\tif (off != 0 || count != 1 || buf == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->mutex);\n\tret = w1_f1C_read(sl, W1_1C_REG_LOGIC_STATE, count, buf);\n\tmutex_unlock(&sl->master->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t pio_write(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\t size_t count)\n\n{\n\tstruct w1_slave *sl = kobj_to_w1_slave(kobj);\n\tu8 wrbuf[3];\n\tu8 ack;\n\n\t \n\tif (off != 0 || count != 1 || buf == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->mutex);\n\n\t \n\tif (w1_reset_select_slave(sl)) {\n\t\tmutex_unlock(&sl->master->mutex);\n\t\treturn -1;\n\t}\n\n\t \n\t*buf = *buf | 0xFC;\n\n\twrbuf[0] = W1_F1C_ACCESS_WRITE;\n\twrbuf[1] = *buf;\n\twrbuf[2] = ~(*buf);\n\tw1_write_block(sl->master, wrbuf, 3);\n\n\tw1_read_block(sl->master, &ack, sizeof(ack));\n\n\tmutex_unlock(&sl->master->mutex);\n\n\t \n\tif (ack != 0xAA)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic BIN_ATTR_RW(pio, 1);\n\nstatic ssize_t crccheck_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", w1_enable_crccheck);\n}\n\nstatic ssize_t crccheck_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tint err = kstrtobool(buf, &w1_enable_crccheck);\n\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(crccheck);\n\nstatic struct attribute *w1_f1C_attrs[] = {\n\t&dev_attr_crccheck.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *w1_f1C_bin_attrs[] = {\n\t&bin_attr_eeprom,\n\t&bin_attr_pio,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_f1C_group = {\n\t.attrs\t\t= w1_f1C_attrs,\n\t.bin_attrs\t= w1_f1C_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_f1C_groups[] = {\n\t&w1_f1C_group,\n\tNULL,\n};\n\nstatic int w1_f1C_add_slave(struct w1_slave *sl)\n{\n\tstruct w1_f1C_data *data = NULL;\n\n\tif (w1_enable_crccheck) {\n\t\tdata = kzalloc(sizeof(struct w1_f1C_data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tsl->family_data = data;\n\t}\n\n\treturn 0;\n}\n\nstatic void w1_f1C_remove_slave(struct w1_slave *sl)\n{\n\tkfree(sl->family_data);\n\tsl->family_data = NULL;\n}\n\nstatic const struct w1_family_ops w1_f1C_fops = {\n\t.add_slave      = w1_f1C_add_slave,\n\t.remove_slave   = w1_f1C_remove_slave,\n\t.groups\t\t= w1_f1C_groups,\n};\n\nstatic struct w1_family w1_family_1C = {\n\t.fid = W1_FAMILY_DS28E04,\n\t.fops = &w1_f1C_fops,\n};\nmodule_w1_family(w1_family_1C);\n\nMODULE_AUTHOR(\"Markus Franke <franke.m@sebakmt.com>, <franm@hrz.tu-chemnitz.de>\");\nMODULE_DESCRIPTION(\"w1 family 1C driver for DS28E04, 4kb EEPROM and PIO\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS28E04));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}