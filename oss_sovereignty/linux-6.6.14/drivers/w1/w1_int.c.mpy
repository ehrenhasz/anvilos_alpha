{
  "module_name": "w1_int.c",
  "hash_id": "a5f6a0397da904e319cd95d9898dfdbea4fa858fbdf2c37eed02a5b80389e17f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/w1_int.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n\n#include \"w1_internal.h\"\n#include \"w1_netlink.h\"\n\nstatic int w1_search_count = -1;  \nmodule_param_named(search_count, w1_search_count, int, 0);\n\nstatic int w1_enable_pullup = 1;\nmodule_param_named(enable_pullup, w1_enable_pullup, int, 0);\n\nstatic struct w1_master *w1_alloc_dev(u32 id, int slave_count, int slave_ttl,\n\t\t\t\t       struct device_driver *driver,\n\t\t\t\t       struct device *device)\n{\n\tstruct w1_master *dev;\n\tint err;\n\n\t \n\tdev = kzalloc(sizeof(struct w1_master) + sizeof(struct w1_bus_master), GFP_KERNEL);\n\tif (!dev) {\n\t\tpr_err(\"Failed to allocate %zd bytes for new w1 device.\\n\",\n\t\t\tsizeof(struct w1_master));\n\t\treturn NULL;\n\t}\n\n\n\tdev->bus_master = (struct w1_bus_master *)(dev + 1);\n\n\tdev->owner\t\t= THIS_MODULE;\n\tdev->max_slave_count\t= slave_count;\n\tdev->slave_count\t= 0;\n\tdev->attempts\t\t= 0;\n\tdev->initialized\t= 0;\n\tdev->id\t\t\t= id;\n\tdev->slave_ttl\t\t= slave_ttl;\n\tdev->search_count\t= w1_search_count;\n\tdev->enable_pullup\t= w1_enable_pullup;\n\n\t \n\tatomic_set(&dev->refcnt, 1);\n\n\tINIT_LIST_HEAD(&dev->slist);\n\tINIT_LIST_HEAD(&dev->async_list);\n\tmutex_init(&dev->mutex);\n\tmutex_init(&dev->bus_mutex);\n\tmutex_init(&dev->list_mutex);\n\n\tmemcpy(&dev->dev, device, sizeof(struct device));\n\tdev_set_name(&dev->dev, \"w1_bus_master%u\", dev->id);\n\tsnprintf(dev->name, sizeof(dev->name), \"w1_bus_master%u\", dev->id);\n\tdev->dev.init_name = dev->name;\n\n\tdev->driver = driver;\n\n\tdev->seq = 1;\n\n\terr = device_register(&dev->dev);\n\tif (err) {\n\t\tpr_err(\"Failed to register master device. err=%d\\n\", err);\n\t\tput_device(&dev->dev);\n\t\tdev = NULL;\n\t}\n\n\treturn dev;\n}\n\nstatic void w1_free_dev(struct w1_master *dev)\n{\n\tdevice_unregister(&dev->dev);\n}\n\n \nint w1_add_master_device(struct w1_bus_master *master)\n{\n\tstruct w1_master *dev, *entry;\n\tint retval = 0;\n\tstruct w1_netlink_msg msg;\n\tint id, found;\n\n\t \n\tif (!(master->touch_bit && master->reset_bus) &&\n\t    !(master->write_bit && master->read_bit) &&\n\t    !(master->write_byte && master->read_byte && master->reset_bus)) {\n\t\tpr_err(\"w1_add_master_device: invalid function set\\n\");\n\t\treturn(-EINVAL);\n\t}\n\n\t \n\tmutex_lock(&w1_mlock);\n\t \n\tid = 0;\n\tdo {\n\t\t++id;\n\t\tfound = 0;\n\t\tlist_for_each_entry(entry, &w1_masters, w1_master_entry) {\n\t\t\tif (entry->id == id) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (found);\n\n\tdev = w1_alloc_dev(id, w1_max_slave_count, w1_max_slave_ttl,\n\t\t&w1_master_driver, &w1_master_device);\n\tif (!dev) {\n\t\tmutex_unlock(&w1_mlock);\n\t\treturn -ENOMEM;\n\t}\n\n\tretval =  w1_create_master_attributes(dev);\n\tif (retval) {\n\t\tmutex_unlock(&w1_mlock);\n\t\tgoto err_out_free_dev;\n\t}\n\n\tmemcpy(dev->bus_master, master, sizeof(struct w1_bus_master));\n\n\tdev->initialized = 1;\n\n\tdev->thread = kthread_run(&w1_process, dev, \"%s\", dev->name);\n\tif (IS_ERR(dev->thread)) {\n\t\tretval = PTR_ERR(dev->thread);\n\t\tdev_err(&dev->dev,\n\t\t\t \"Failed to create new kernel thread. err=%d\\n\",\n\t\t\t retval);\n\t\tmutex_unlock(&w1_mlock);\n\t\tgoto err_out_rm_attr;\n\t}\n\n\tlist_add(&dev->w1_master_entry, &w1_masters);\n\tmutex_unlock(&w1_mlock);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.id.mst.id = dev->id;\n\tmsg.type = W1_MASTER_ADD;\n\tw1_netlink_send(dev, &msg);\n\n\treturn 0;\n\n#if 0  \nerr_out_kill_thread:\n\tset_bit(W1_ABORT_SEARCH, &dev->flags);\n\tkthread_stop(dev->thread);\n#endif\nerr_out_rm_attr:\n\tw1_destroy_master_attributes(dev);\nerr_out_free_dev:\n\tw1_free_dev(dev);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(w1_add_master_device);\n\nvoid __w1_remove_master_device(struct w1_master *dev)\n{\n\tstruct w1_netlink_msg msg;\n\tstruct w1_slave *sl, *sln;\n\n\tmutex_lock(&w1_mlock);\n\tlist_del(&dev->w1_master_entry);\n\tmutex_unlock(&w1_mlock);\n\n\tset_bit(W1_ABORT_SEARCH, &dev->flags);\n\tkthread_stop(dev->thread);\n\n\tmutex_lock(&dev->mutex);\n\tmutex_lock(&dev->list_mutex);\n\tlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {\n\t\tmutex_unlock(&dev->list_mutex);\n\t\tw1_slave_detach(sl);\n\t\tmutex_lock(&dev->list_mutex);\n\t}\n\tw1_destroy_master_attributes(dev);\n\tmutex_unlock(&dev->list_mutex);\n\tmutex_unlock(&dev->mutex);\n\tatomic_dec(&dev->refcnt);\n\n\twhile (atomic_read(&dev->refcnt)) {\n\t\tdev_info(&dev->dev, \"Waiting for %s to become free: refcnt=%d.\\n\",\n\t\t\t\tdev->name, atomic_read(&dev->refcnt));\n\n\t\tif (msleep_interruptible(1000))\n\t\t\tflush_signals(current);\n\t\tmutex_lock(&dev->list_mutex);\n\t\tw1_process_callbacks(dev);\n\t\tmutex_unlock(&dev->list_mutex);\n\t}\n\tmutex_lock(&dev->list_mutex);\n\tw1_process_callbacks(dev);\n\tmutex_unlock(&dev->list_mutex);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.id.mst.id = dev->id;\n\tmsg.type = W1_MASTER_REMOVE;\n\tw1_netlink_send(dev, &msg);\n\n\tw1_free_dev(dev);\n}\n\n \nvoid w1_remove_master_device(struct w1_bus_master *bm)\n{\n\tstruct w1_master *dev, *found = NULL;\n\n\tlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\n\t\tif (!dev->initialized)\n\t\t\tcontinue;\n\n\t\tif (dev->bus_master->data == bm->data) {\n\t\t\tfound = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_err(\"Device doesn't exist.\\n\");\n\t\treturn;\n\t}\n\n\t__w1_remove_master_device(found);\n}\nEXPORT_SYMBOL(w1_remove_master_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}