{
  "module_name": "w1_io.c",
  "hash_id": "54e4e7b5fb57431ca734f3cbe89760b1db398ad91287e19f77138ee835b2547c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/w1/w1_io.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n\n#include \"w1_internal.h\"\n\nstatic int w1_delay_parm = 1;\nmodule_param_named(delay_coef, w1_delay_parm, int, 0);\n\nstatic int w1_disable_irqs = 0;\nmodule_param_named(disable_irqs, w1_disable_irqs, int, 0);\n\nstatic u8 w1_crc8_table[] = {\n\t0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,\n\t157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,\n\t35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,\n\t190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,\n\t70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,\n\t219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,\n\t101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,\n\t248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,\n\t140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205,\n\t17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,\n\t175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,\n\t50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,\n\t202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,\n\t87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,\n\t233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,\n\t116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53\n};\n\nstatic void w1_delay(unsigned long tm)\n{\n\tudelay(tm * w1_delay_parm);\n}\n\nstatic void w1_write_bit(struct w1_master *dev, int bit);\nstatic u8 w1_read_bit(struct w1_master *dev);\n\n \nu8 w1_touch_bit(struct w1_master *dev, int bit)\n{\n\tif (dev->bus_master->touch_bit)\n\t\treturn dev->bus_master->touch_bit(dev->bus_master->data, bit);\n\telse if (bit)\n\t\treturn w1_read_bit(dev);\n\telse {\n\t\tw1_write_bit(dev, 0);\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(w1_touch_bit);\n\n \nstatic void w1_write_bit(struct w1_master *dev, int bit)\n{\n\tunsigned long flags = 0;\n\n\tif(w1_disable_irqs) local_irq_save(flags);\n\n\tif (bit) {\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 0);\n\t\tw1_delay(6);\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 1);\n\t\tw1_delay(64);\n\t} else {\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 0);\n\t\tw1_delay(60);\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 1);\n\t\tw1_delay(10);\n\t}\n\n\tif(w1_disable_irqs) local_irq_restore(flags);\n}\n\n \nstatic void w1_pre_write(struct w1_master *dev)\n{\n\tif (dev->pullup_duration &&\n\t\tdev->enable_pullup && dev->bus_master->set_pullup) {\n\t\tdev->bus_master->set_pullup(dev->bus_master->data,\n\t\t\tdev->pullup_duration);\n\t}\n}\n\n \nstatic void w1_post_write(struct w1_master *dev)\n{\n\tif (dev->pullup_duration) {\n\t\tif (dev->enable_pullup && dev->bus_master->set_pullup)\n\t\t\tdev->bus_master->set_pullup(dev->bus_master->data, 0);\n\t\telse\n\t\t\tmsleep(dev->pullup_duration);\n\t\tdev->pullup_duration = 0;\n\t}\n}\n\n \nvoid w1_write_8(struct w1_master *dev, u8 byte)\n{\n\tint i;\n\n\tif (dev->bus_master->write_byte) {\n\t\tw1_pre_write(dev);\n\t\tdev->bus_master->write_byte(dev->bus_master->data, byte);\n\t}\n\telse\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tif (i == 7)\n\t\t\t\tw1_pre_write(dev);\n\t\t\tw1_touch_bit(dev, (byte >> i) & 0x1);\n\t\t}\n\tw1_post_write(dev);\n}\nEXPORT_SYMBOL_GPL(w1_write_8);\n\n\n \nstatic u8 w1_read_bit(struct w1_master *dev)\n{\n\tint result;\n\tunsigned long flags = 0;\n\n\t \n\tlocal_irq_save(flags);\n\tdev->bus_master->write_bit(dev->bus_master->data, 0);\n\tw1_delay(6);\n\tdev->bus_master->write_bit(dev->bus_master->data, 1);\n\tw1_delay(9);\n\n\tresult = dev->bus_master->read_bit(dev->bus_master->data);\n\tlocal_irq_restore(flags);\n\n\tw1_delay(55);\n\n\treturn result & 0x1;\n}\n\n \nu8 w1_triplet(struct w1_master *dev, int bdir)\n{\n\tif (dev->bus_master->triplet)\n\t\treturn dev->bus_master->triplet(dev->bus_master->data, bdir);\n\telse {\n\t\tu8 id_bit   = w1_touch_bit(dev, 1);\n\t\tu8 comp_bit = w1_touch_bit(dev, 1);\n\t\tu8 retval;\n\n\t\tif (id_bit && comp_bit)\n\t\t\treturn 0x03;   \n\n\t\tif (!id_bit && !comp_bit) {\n\t\t\t \n\t\t\tretval = bdir ? 0x04 : 0;\n\t\t} else {\n\t\t\t \n\t\t\tbdir = id_bit;\n\t\t\tretval = id_bit ? 0x05 : 0x02;\n\t\t}\n\n\t\tif (dev->bus_master->touch_bit)\n\t\t\tw1_touch_bit(dev, bdir);\n\t\telse\n\t\t\tw1_write_bit(dev, bdir);\n\t\treturn retval;\n\t}\n}\nEXPORT_SYMBOL_GPL(w1_triplet);\n\n \nu8 w1_read_8(struct w1_master *dev)\n{\n\tint i;\n\tu8 res = 0;\n\n\tif (dev->bus_master->read_byte)\n\t\tres = dev->bus_master->read_byte(dev->bus_master->data);\n\telse\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tres |= (w1_touch_bit(dev,1) << i);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(w1_read_8);\n\n \nvoid w1_write_block(struct w1_master *dev, const u8 *buf, int len)\n{\n\tint i;\n\n\tif (dev->bus_master->write_block) {\n\t\tw1_pre_write(dev);\n\t\tdev->bus_master->write_block(dev->bus_master->data, buf, len);\n\t}\n\telse\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tw1_write_8(dev, buf[i]);  \n\tw1_post_write(dev);\n}\nEXPORT_SYMBOL_GPL(w1_write_block);\n\n \nvoid w1_touch_block(struct w1_master *dev, u8 *buf, int len)\n{\n\tint i, j;\n\tu8 tmp;\n\n\tfor (i = 0; i < len; ++i) {\n\t\ttmp = 0;\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tif (j == 7)\n\t\t\t\tw1_pre_write(dev);\n\t\t\ttmp |= w1_touch_bit(dev, (buf[i] >> j) & 0x1) << j;\n\t\t}\n\n\t\tbuf[i] = tmp;\n\t}\n}\nEXPORT_SYMBOL_GPL(w1_touch_block);\n\n \nu8 w1_read_block(struct w1_master *dev, u8 *buf, int len)\n{\n\tint i;\n\tu8 ret;\n\n\tif (dev->bus_master->read_block)\n\t\tret = dev->bus_master->read_block(dev->bus_master->data, buf, len);\n\telse {\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tbuf[i] = w1_read_8(dev);\n\t\tret = len;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(w1_read_block);\n\n \nint w1_reset_bus(struct w1_master *dev)\n{\n\tint result;\n\tunsigned long flags = 0;\n\n\tif(w1_disable_irqs) local_irq_save(flags);\n\n\tif (dev->bus_master->reset_bus)\n\t\tresult = dev->bus_master->reset_bus(dev->bus_master->data) & 0x1;\n\telse {\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 0);\n\t\t \n\t\tw1_delay(500);\n\t\tdev->bus_master->write_bit(dev->bus_master->data, 1);\n\t\tw1_delay(70);\n\n\t\tresult = dev->bus_master->read_bit(dev->bus_master->data) & 0x1;\n\t\t \n\t\t \n\t\tmsleep(1);\n\t}\n\n\tif(w1_disable_irqs) local_irq_restore(flags);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(w1_reset_bus);\n\nu8 w1_calc_crc8(u8 * data, int len)\n{\n\tu8 crc = 0;\n\n\twhile (len--)\n\t\tcrc = w1_crc8_table[crc ^ *data++];\n\n\treturn crc;\n}\nEXPORT_SYMBOL_GPL(w1_calc_crc8);\n\nvoid w1_search_devices(struct w1_master *dev, u8 search_type, w1_slave_found_callback cb)\n{\n\tdev->attempts++;\n\tif (dev->bus_master->search)\n\t\tdev->bus_master->search(dev->bus_master->data, dev,\n\t\t\tsearch_type, cb);\n\telse\n\t\tw1_search(dev, search_type, cb);\n}\n\n \nint w1_reset_select_slave(struct w1_slave *sl)\n{\n\tif (w1_reset_bus(sl->master))\n\t\treturn -1;\n\n\tif (sl->master->slave_count == 1)\n\t\tw1_write_8(sl->master, W1_SKIP_ROM);\n\telse {\n\t\tu8 match[9] = {W1_MATCH_ROM, };\n\t\tu64 rn = le64_to_cpu(*((u64*)&sl->reg_num));\n\n\t\tmemcpy(&match[1], &rn, 8);\n\t\tw1_write_block(sl->master, match, 9);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(w1_reset_select_slave);\n\n \nint w1_reset_resume_command(struct w1_master *dev)\n{\n\tif (w1_reset_bus(dev))\n\t\treturn -1;\n\n\tw1_write_8(dev, dev->slave_count > 1 ? W1_RESUME_CMD : W1_SKIP_ROM);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(w1_reset_resume_command);\n\n \nvoid w1_next_pullup(struct w1_master *dev, int delay)\n{\n\tdev->pullup_duration = delay;\n}\nEXPORT_SYMBOL_GPL(w1_next_pullup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}