{
  "module_name": "sun4i-dma.c",
  "hash_id": "4e4c2b5f43268b76cfba054d82c0b28a7ee7419037cc4906b29c3513f236e144",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/sun4i-dma.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"virt-dma.h\"\n\n \n\n#define SUN4I_DMA_CFG_LOADING\t\t\tBIT(31)\n#define SUN4I_DMA_CFG_DST_DATA_WIDTH(width)\t((width) << 25)\n#define SUN4I_DMA_CFG_DST_BURST_LENGTH(len)\t((len) << 23)\n#define SUN4I_DMA_CFG_DST_ADDR_MODE(mode)\t((mode) << 21)\n#define SUN4I_DMA_CFG_DST_DRQ_TYPE(type)\t((type) << 16)\n#define SUN4I_DMA_CFG_SRC_DATA_WIDTH(width)\t((width) << 9)\n#define SUN4I_DMA_CFG_SRC_BURST_LENGTH(len)\t((len) << 7)\n#define SUN4I_DMA_CFG_SRC_ADDR_MODE(mode)\t((mode) << 5)\n#define SUN4I_DMA_CFG_SRC_DRQ_TYPE(type)\t(type)\n\n \n\n \n#define SUN4I_NDMA_DRQ_TYPE_SDRAM\t\t0x16\n#define SUN4I_NDMA_DRQ_TYPE_LIMIT\t\t(0x1F + 1)\n\n \n\n \n#define SUN4I_NDMA_ADDR_MODE_LINEAR\t\t0\n#define SUN4I_NDMA_ADDR_MODE_IO\t\t\t1\n\n \n#define SUN4I_NDMA_CFG_CONT_MODE\t\tBIT(30)\n#define SUN4I_NDMA_CFG_WAIT_STATE(n)\t\t((n) << 27)\n#define SUN4I_NDMA_CFG_DST_NON_SECURE\t\tBIT(22)\n#define SUN4I_NDMA_CFG_BYTE_COUNT_MODE_REMAIN\tBIT(15)\n#define SUN4I_NDMA_CFG_SRC_NON_SECURE\t\tBIT(6)\n\n \n\n \n#define SUN4I_DDMA_ADDR_MODE_LINEAR\t\t0\n#define SUN4I_DDMA_ADDR_MODE_IO\t\t\t1\n#define SUN4I_DDMA_ADDR_MODE_HORIZONTAL_PAGE\t2\n#define SUN4I_DDMA_ADDR_MODE_VERTICAL_PAGE\t3\n\n \n#define SUN4I_DDMA_DRQ_TYPE_SDRAM\t\t0x1\n#define SUN4I_DDMA_DRQ_TYPE_LIMIT\t\t(0x1F + 1)\n\n \n\n \n#define SUN4I_DDMA_CFG_BUSY\t\t\tBIT(30)\n#define SUN4I_DDMA_CFG_CONT_MODE\t\tBIT(29)\n#define SUN4I_DDMA_CFG_DST_NON_SECURE\t\tBIT(28)\n#define SUN4I_DDMA_CFG_BYTE_COUNT_MODE_REMAIN\tBIT(15)\n#define SUN4I_DDMA_CFG_SRC_NON_SECURE\t\tBIT(12)\n\n \n#define SUN4I_DDMA_PARA_DST_DATA_BLK_SIZE(n)\t(((n) - 1) << 24)\n#define SUN4I_DDMA_PARA_DST_WAIT_CYCLES(n)\t(((n) - 1) << 16)\n#define SUN4I_DDMA_PARA_SRC_DATA_BLK_SIZE(n)\t(((n) - 1) << 8)\n#define SUN4I_DDMA_PARA_SRC_WAIT_CYCLES(n)\t(((n) - 1) << 0)\n\n \n\n \n#define SUN4I_DMA_IRQ_ENABLE_REG\t\t0x0\n#define SUN4I_DMA_IRQ_PENDING_STATUS_REG\t0x4\n\n \n#define SUN4I_NDMA_CHANNEL_REG_BASE(n)\t\t(0x100 + (n) * 0x20)\n#define SUN4I_NDMA_CFG_REG\t\t\t0x0\n#define SUN4I_NDMA_SRC_ADDR_REG\t\t\t0x4\n#define SUN4I_NDMA_DST_ADDR_REG\t\t0x8\n#define SUN4I_NDMA_BYTE_COUNT_REG\t\t0xC\n\n \n#define SUN4I_DDMA_CHANNEL_REG_BASE(n)\t\t(0x300 + (n) * 0x20)\n#define SUN4I_DDMA_CFG_REG\t\t\t0x0\n#define SUN4I_DDMA_SRC_ADDR_REG\t\t\t0x4\n#define SUN4I_DDMA_DST_ADDR_REG\t\t0x8\n#define SUN4I_DDMA_BYTE_COUNT_REG\t\t0xC\n#define SUN4I_DDMA_PARA_REG\t\t\t0x18\n\n \n\n \n#define SUN4I_NDMA_NR_MAX_CHANNELS\t8\n#define SUN4I_DDMA_NR_MAX_CHANNELS\t8\n#define SUN4I_DMA_NR_MAX_CHANNELS\t\t\t\t\t\\\n\t(SUN4I_NDMA_NR_MAX_CHANNELS + SUN4I_DDMA_NR_MAX_CHANNELS)\n#define SUN4I_NDMA_NR_MAX_VCHANS\t(29 * 2 - 1)\n#define SUN4I_DDMA_NR_MAX_VCHANS\t21\n#define SUN4I_DMA_NR_MAX_VCHANS\t\t\t\t\t\t\\\n\t(SUN4I_NDMA_NR_MAX_VCHANS + SUN4I_DDMA_NR_MAX_VCHANS)\n\n \n#define SUN4I_DDMA_MAGIC_SPI_PARAMETERS \\\n\t(SUN4I_DDMA_PARA_DST_DATA_BLK_SIZE(1) |\t\t\t\\\n\t SUN4I_DDMA_PARA_SRC_DATA_BLK_SIZE(1) |\t\t\t\t\\\n\t SUN4I_DDMA_PARA_DST_WAIT_CYCLES(2) |\t\t\t\t\\\n\t SUN4I_DDMA_PARA_SRC_WAIT_CYCLES(2))\n\n \n#define SUN4I_NDMA_MAX_SEG_SIZE\t\tSZ_128K\n#define SUN4I_DDMA_MAX_SEG_SIZE\t\tSZ_16M\n#define SUN4I_DMA_MAX_SEG_SIZE\t\tSUN4I_NDMA_MAX_SEG_SIZE\n\nstruct sun4i_dma_pchan {\n\t \n\tvoid __iomem\t\t\t*base;\n\t \n\tstruct sun4i_dma_vchan\t\t*vchan;\n\t \n\tint\t\t\t\tis_dedicated;\n};\n\nstruct sun4i_dma_vchan {\n\tstruct virt_dma_chan\t\tvc;\n\tstruct dma_slave_config\t\tcfg;\n\tstruct sun4i_dma_pchan\t\t*pchan;\n\tstruct sun4i_dma_promise\t*processing;\n\tstruct sun4i_dma_contract\t*contract;\n\tu8\t\t\t\tendpoint;\n\tint\t\t\t\tis_dedicated;\n};\n\nstruct sun4i_dma_promise {\n\tu32\t\t\t\tcfg;\n\tu32\t\t\t\tpara;\n\tdma_addr_t\t\t\tsrc;\n\tdma_addr_t\t\t\tdst;\n\tsize_t\t\t\t\tlen;\n\tstruct list_head\t\tlist;\n};\n\n \nstruct sun4i_dma_contract {\n\tstruct virt_dma_desc\t\tvd;\n\tstruct list_head\t\tdemands;\n\tstruct list_head\t\tcompleted_demands;\n\tbool\t\t\t\tis_cyclic : 1;\n\tbool\t\t\t\tuse_half_int : 1;\n};\n\nstruct sun4i_dma_dev {\n\tDECLARE_BITMAP(pchans_used, SUN4I_DMA_NR_MAX_CHANNELS);\n\tstruct dma_device\t\tslave;\n\tstruct sun4i_dma_pchan\t\t*pchans;\n\tstruct sun4i_dma_vchan\t\t*vchans;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*clk;\n\tint\t\t\t\tirq;\n\tspinlock_t\t\t\tlock;\n};\n\nstatic struct sun4i_dma_dev *to_sun4i_dma_dev(struct dma_device *dev)\n{\n\treturn container_of(dev, struct sun4i_dma_dev, slave);\n}\n\nstatic struct sun4i_dma_vchan *to_sun4i_dma_vchan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct sun4i_dma_vchan, vc.chan);\n}\n\nstatic struct sun4i_dma_contract *to_sun4i_dma_contract(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct sun4i_dma_contract, vd);\n}\n\nstatic struct device *chan2dev(struct dma_chan *chan)\n{\n\treturn &chan->dev->device;\n}\n\nstatic int convert_burst(u32 maxburst)\n{\n\tif (maxburst > 8)\n\t\treturn -EINVAL;\n\n\t \n\treturn (maxburst >> 2);\n}\n\nstatic int convert_buswidth(enum dma_slave_buswidth addr_width)\n{\n\tif (addr_width > DMA_SLAVE_BUSWIDTH_4_BYTES)\n\t\treturn -EINVAL;\n\n\t \n\treturn (addr_width >> 1);\n}\n\nstatic void sun4i_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\n\tvchan_free_chan_resources(&vchan->vc);\n}\n\nstatic struct sun4i_dma_pchan *find_and_use_pchan(struct sun4i_dma_dev *priv,\n\t\t\t\t\t\t  struct sun4i_dma_vchan *vchan)\n{\n\tstruct sun4i_dma_pchan *pchan = NULL, *pchans = priv->pchans;\n\tunsigned long flags;\n\tint i, max;\n\n\t \n\tif (vchan->is_dedicated) {\n\t\ti = SUN4I_NDMA_NR_MAX_CHANNELS;\n\t\tmax = SUN4I_DMA_NR_MAX_CHANNELS;\n\t} else {\n\t\ti = 0;\n\t\tmax = SUN4I_NDMA_NR_MAX_CHANNELS;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tfor_each_clear_bit_from(i, priv->pchans_used, max) {\n\t\tpchan = &pchans[i];\n\t\tpchan->vchan = vchan;\n\t\tset_bit(i, priv->pchans_used);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn pchan;\n}\n\nstatic void release_pchan(struct sun4i_dma_dev *priv,\n\t\t\t  struct sun4i_dma_pchan *pchan)\n{\n\tunsigned long flags;\n\tint nr = pchan - priv->pchans;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpchan->vchan = NULL;\n\tclear_bit(nr, priv->pchans_used);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void configure_pchan(struct sun4i_dma_pchan *pchan,\n\t\t\t    struct sun4i_dma_promise *d)\n{\n\t \n\tif (pchan->is_dedicated) {\n\t\twritel_relaxed(d->src, pchan->base + SUN4I_DDMA_SRC_ADDR_REG);\n\t\twritel_relaxed(d->dst, pchan->base + SUN4I_DDMA_DST_ADDR_REG);\n\t\twritel_relaxed(d->len, pchan->base + SUN4I_DDMA_BYTE_COUNT_REG);\n\t\twritel_relaxed(d->para, pchan->base + SUN4I_DDMA_PARA_REG);\n\t\twritel_relaxed(d->cfg, pchan->base + SUN4I_DDMA_CFG_REG);\n\t} else {\n\t\twritel_relaxed(d->src, pchan->base + SUN4I_NDMA_SRC_ADDR_REG);\n\t\twritel_relaxed(d->dst, pchan->base + SUN4I_NDMA_DST_ADDR_REG);\n\t\twritel_relaxed(d->len, pchan->base + SUN4I_NDMA_BYTE_COUNT_REG);\n\t\twritel_relaxed(d->cfg, pchan->base + SUN4I_NDMA_CFG_REG);\n\t}\n}\n\nstatic void set_pchan_interrupt(struct sun4i_dma_dev *priv,\n\t\t\t\tstruct sun4i_dma_pchan *pchan,\n\t\t\t\tint half, int end)\n{\n\tu32 reg;\n\tint pchan_number = pchan - priv->pchans;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\treg = readl_relaxed(priv->base + SUN4I_DMA_IRQ_ENABLE_REG);\n\n\tif (half)\n\t\treg |= BIT(pchan_number * 2);\n\telse\n\t\treg &= ~BIT(pchan_number * 2);\n\n\tif (end)\n\t\treg |= BIT(pchan_number * 2 + 1);\n\telse\n\t\treg &= ~BIT(pchan_number * 2 + 1);\n\n\twritel_relaxed(reg, priv->base + SUN4I_DMA_IRQ_ENABLE_REG);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n \nstatic int __execute_vchan_pending(struct sun4i_dma_dev *priv,\n\t\t\t\t   struct sun4i_dma_vchan *vchan)\n{\n\tstruct sun4i_dma_promise *promise = NULL;\n\tstruct sun4i_dma_contract *contract = NULL;\n\tstruct sun4i_dma_pchan *pchan;\n\tstruct virt_dma_desc *vd;\n\tint ret;\n\n\tlockdep_assert_held(&vchan->vc.lock);\n\n\t \n\tpchan = find_and_use_pchan(priv, vchan);\n\tif (!pchan)\n\t\treturn -EBUSY;\n\n\t \n\tif (vchan->processing) {\n\t\tdev_dbg(chan2dev(&vchan->vc.chan),\n\t\t\t\"processing something to this endpoint already\\n\");\n\t\tret = -EBUSY;\n\t\tgoto release_pchan;\n\t}\n\n\tdo {\n\t\t \n\t\tvd = vchan_next_desc(&vchan->vc);\n\t\tif (!vd) {\n\t\t\tdev_dbg(chan2dev(&vchan->vc.chan),\n\t\t\t\t\"No pending contract found\");\n\t\t\tret = 0;\n\t\t\tgoto release_pchan;\n\t\t}\n\n\t\tcontract = to_sun4i_dma_contract(vd);\n\t\tif (list_empty(&contract->demands)) {\n\t\t\t \n\t\t\tlist_del(&contract->vd.node);\n\t\t\tvchan_cookie_complete(&contract->vd);\n\t\t\tdev_dbg(chan2dev(&vchan->vc.chan),\n\t\t\t\t\"Empty contract found and marked complete\");\n\t\t}\n\t} while (list_empty(&contract->demands));\n\n\t \n\tpromise = list_first_entry(&contract->demands,\n\t\t\t\t   struct sun4i_dma_promise, list);\n\tvchan->processing = promise;\n\n\t \n\tif (promise) {\n\t\tvchan->contract = contract;\n\t\tvchan->pchan = pchan;\n\t\tset_pchan_interrupt(priv, pchan, contract->use_half_int, 1);\n\t\tconfigure_pchan(pchan, promise);\n\t}\n\n\treturn 0;\n\nrelease_pchan:\n\trelease_pchan(priv, pchan);\n\treturn ret;\n}\n\nstatic int sanitize_config(struct dma_slave_config *sconfig,\n\t\t\t   enum dma_transfer_direction direction)\n{\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tif ((sconfig->dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED) ||\n\t\t    !sconfig->dst_maxburst)\n\t\t\treturn -EINVAL;\n\n\t\tif (sconfig->src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tsconfig->src_addr_width = sconfig->dst_addr_width;\n\n\t\tif (!sconfig->src_maxburst)\n\t\t\tsconfig->src_maxburst = sconfig->dst_maxburst;\n\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tif ((sconfig->src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED) ||\n\t\t    !sconfig->src_maxburst)\n\t\t\treturn -EINVAL;\n\n\t\tif (sconfig->dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tsconfig->dst_addr_width = sconfig->src_addr_width;\n\n\t\tif (!sconfig->dst_maxburst)\n\t\t\tsconfig->dst_maxburst = sconfig->src_maxburst;\n\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct sun4i_dma_promise *\ngenerate_ndma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,\n\t\t      size_t len, struct dma_slave_config *sconfig,\n\t\t      enum dma_transfer_direction direction)\n{\n\tstruct sun4i_dma_promise *promise;\n\tint ret;\n\n\tret = sanitize_config(sconfig, direction);\n\tif (ret)\n\t\treturn NULL;\n\n\tpromise = kzalloc(sizeof(*promise), GFP_NOWAIT);\n\tif (!promise)\n\t\treturn NULL;\n\n\tpromise->src = src;\n\tpromise->dst = dest;\n\tpromise->len = len;\n\tpromise->cfg = SUN4I_DMA_CFG_LOADING |\n\t\tSUN4I_NDMA_CFG_BYTE_COUNT_MODE_REMAIN;\n\n\tdev_dbg(chan2dev(chan),\n\t\t\"src burst %d, dst burst %d, src buswidth %d, dst buswidth %d\",\n\t\tsconfig->src_maxburst, sconfig->dst_maxburst,\n\t\tsconfig->src_addr_width, sconfig->dst_addr_width);\n\n\t \n\tret = convert_burst(sconfig->src_maxburst);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_SRC_BURST_LENGTH(ret);\n\n\t \n\tret = convert_burst(sconfig->dst_maxburst);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_DST_BURST_LENGTH(ret);\n\n\t \n\tret = convert_buswidth(sconfig->src_addr_width);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_SRC_DATA_WIDTH(ret);\n\n\t \n\tret = convert_buswidth(sconfig->dst_addr_width);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_DST_DATA_WIDTH(ret);\n\n\treturn promise;\n\nfail:\n\tkfree(promise);\n\treturn NULL;\n}\n\n \nstatic struct sun4i_dma_promise *\ngenerate_ddma_promise(struct dma_chan *chan, dma_addr_t src, dma_addr_t dest,\n\t\t      size_t len, struct dma_slave_config *sconfig)\n{\n\tstruct sun4i_dma_promise *promise;\n\tint ret;\n\n\tpromise = kzalloc(sizeof(*promise), GFP_NOWAIT);\n\tif (!promise)\n\t\treturn NULL;\n\n\tpromise->src = src;\n\tpromise->dst = dest;\n\tpromise->len = len;\n\tpromise->cfg = SUN4I_DMA_CFG_LOADING |\n\t\tSUN4I_DDMA_CFG_BYTE_COUNT_MODE_REMAIN;\n\n\t \n\tret = convert_burst(sconfig->src_maxburst);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_SRC_BURST_LENGTH(ret);\n\n\t \n\tret = convert_burst(sconfig->dst_maxburst);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_DST_BURST_LENGTH(ret);\n\n\t \n\tret = convert_buswidth(sconfig->src_addr_width);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_SRC_DATA_WIDTH(ret);\n\n\t \n\tret = convert_buswidth(sconfig->dst_addr_width);\n\tif (ret < 0)\n\t\tgoto fail;\n\tpromise->cfg |= SUN4I_DMA_CFG_DST_DATA_WIDTH(ret);\n\n\treturn promise;\n\nfail:\n\tkfree(promise);\n\treturn NULL;\n}\n\n \nstatic struct sun4i_dma_contract *generate_dma_contract(void)\n{\n\tstruct sun4i_dma_contract *contract;\n\n\tcontract = kzalloc(sizeof(*contract), GFP_NOWAIT);\n\tif (!contract)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&contract->demands);\n\tINIT_LIST_HEAD(&contract->completed_demands);\n\n\treturn contract;\n}\n\n \nstatic struct sun4i_dma_promise *\nget_next_cyclic_promise(struct sun4i_dma_contract *contract)\n{\n\tstruct sun4i_dma_promise *promise;\n\n\tpromise = list_first_entry_or_null(&contract->demands,\n\t\t\t\t\t   struct sun4i_dma_promise, list);\n\tif (!promise) {\n\t\tlist_splice_init(&contract->completed_demands,\n\t\t\t\t &contract->demands);\n\t\tpromise = list_first_entry(&contract->demands,\n\t\t\t\t\t   struct sun4i_dma_promise, list);\n\t}\n\n\treturn promise;\n}\n\n \nstatic void sun4i_dma_free_contract(struct virt_dma_desc *vd)\n{\n\tstruct sun4i_dma_contract *contract = to_sun4i_dma_contract(vd);\n\tstruct sun4i_dma_promise *promise, *tmp;\n\n\t \n\tlist_for_each_entry_safe(promise, tmp, &contract->demands, list)\n\t\tkfree(promise);\n\n\tlist_for_each_entry_safe(promise, tmp, &contract->completed_demands, list)\n\t\tkfree(promise);\n\n\tkfree(contract);\n}\n\nstatic struct dma_async_tx_descriptor *\nsun4i_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,\n\t\t\t  dma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tstruct dma_slave_config *sconfig = &vchan->cfg;\n\tstruct sun4i_dma_promise *promise;\n\tstruct sun4i_dma_contract *contract;\n\n\tcontract = generate_dma_contract();\n\tif (!contract)\n\t\treturn NULL;\n\n\t \n\tsconfig->src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tsconfig->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tsconfig->src_maxburst = 8;\n\tsconfig->dst_maxburst = 8;\n\n\tif (vchan->is_dedicated)\n\t\tpromise = generate_ddma_promise(chan, src, dest, len, sconfig);\n\telse\n\t\tpromise = generate_ndma_promise(chan, src, dest, len, sconfig,\n\t\t\t\t\t\tDMA_MEM_TO_MEM);\n\n\tif (!promise) {\n\t\tkfree(contract);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (vchan->is_dedicated) {\n\t\tpromise->cfg |= SUN4I_DMA_CFG_SRC_DRQ_TYPE(SUN4I_DDMA_DRQ_TYPE_SDRAM) |\n\t\t\t\tSUN4I_DMA_CFG_DST_DRQ_TYPE(SUN4I_DDMA_DRQ_TYPE_SDRAM);\n\t} else {\n\t\tpromise->cfg |= SUN4I_DMA_CFG_SRC_DRQ_TYPE(SUN4I_NDMA_DRQ_TYPE_SDRAM) |\n\t\t\t\tSUN4I_DMA_CFG_DST_DRQ_TYPE(SUN4I_NDMA_DRQ_TYPE_SDRAM);\n\t}\n\n\t \n\tlist_add_tail(&promise->list, &contract->demands);\n\n\t \n\treturn vchan_tx_prep(&vchan->vc, &contract->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\nsun4i_dma_prep_dma_cyclic(struct dma_chan *chan, dma_addr_t buf, size_t len,\n\t\t\t  size_t period_len, enum dma_transfer_direction dir,\n\t\t\t  unsigned long flags)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tstruct dma_slave_config *sconfig = &vchan->cfg;\n\tstruct sun4i_dma_promise *promise;\n\tstruct sun4i_dma_contract *contract;\n\tdma_addr_t src, dest;\n\tu32 endpoints;\n\tint nr_periods, offset, plength, i;\n\tu8 ram_type, io_mode, linear_mode;\n\n\tif (!is_slave_direction(dir)) {\n\t\tdev_err(chan2dev(chan), \"Invalid DMA direction\\n\");\n\t\treturn NULL;\n\t}\n\n\tcontract = generate_dma_contract();\n\tif (!contract)\n\t\treturn NULL;\n\n\tcontract->is_cyclic = 1;\n\n\tif (vchan->is_dedicated) {\n\t\tio_mode = SUN4I_DDMA_ADDR_MODE_IO;\n\t\tlinear_mode = SUN4I_DDMA_ADDR_MODE_LINEAR;\n\t\tram_type = SUN4I_DDMA_DRQ_TYPE_SDRAM;\n\t} else {\n\t\tio_mode = SUN4I_NDMA_ADDR_MODE_IO;\n\t\tlinear_mode = SUN4I_NDMA_ADDR_MODE_LINEAR;\n\t\tram_type = SUN4I_NDMA_DRQ_TYPE_SDRAM;\n\t}\n\n\tif (dir == DMA_MEM_TO_DEV) {\n\t\tsrc = buf;\n\t\tdest = sconfig->dst_addr;\n\t\tendpoints = SUN4I_DMA_CFG_DST_DRQ_TYPE(vchan->endpoint) |\n\t\t\t    SUN4I_DMA_CFG_DST_ADDR_MODE(io_mode) |\n\t\t\t    SUN4I_DMA_CFG_SRC_DRQ_TYPE(ram_type) |\n\t\t\t    SUN4I_DMA_CFG_SRC_ADDR_MODE(linear_mode);\n\t} else {\n\t\tsrc = sconfig->src_addr;\n\t\tdest = buf;\n\t\tendpoints = SUN4I_DMA_CFG_DST_DRQ_TYPE(ram_type) |\n\t\t\t    SUN4I_DMA_CFG_DST_ADDR_MODE(linear_mode) |\n\t\t\t    SUN4I_DMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |\n\t\t\t    SUN4I_DMA_CFG_SRC_ADDR_MODE(io_mode);\n\t}\n\n\t \n\n\t \n\tif (vchan->is_dedicated || period_len <= SUN4I_NDMA_MAX_SEG_SIZE / 2) {\n\t\tperiod_len *= 2;\n\t\tcontract->use_half_int = 1;\n\t}\n\n\tnr_periods = DIV_ROUND_UP(len, period_len);\n\tfor (i = 0; i < nr_periods; i++) {\n\t\t \n\t\toffset = i * period_len;\n\t\tplength = min((len - offset), period_len);\n\t\tif (dir == DMA_MEM_TO_DEV)\n\t\t\tsrc = buf + offset;\n\t\telse\n\t\t\tdest = buf + offset;\n\n\t\t \n\t\tif (vchan->is_dedicated)\n\t\t\tpromise = generate_ddma_promise(chan, src, dest,\n\t\t\t\t\t\t\tplength, sconfig);\n\t\telse\n\t\t\tpromise = generate_ndma_promise(chan, src, dest,\n\t\t\t\t\t\t\tplength, sconfig, dir);\n\n\t\tif (!promise) {\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\t\tpromise->cfg |= endpoints;\n\n\t\t \n\t\tlist_add_tail(&promise->list, &contract->demands);\n\t}\n\n\t \n\treturn vchan_tx_prep(&vchan->vc, &contract->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\nsun4i_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\t\tunsigned int sg_len, enum dma_transfer_direction dir,\n\t\t\tunsigned long flags, void *context)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tstruct dma_slave_config *sconfig = &vchan->cfg;\n\tstruct sun4i_dma_promise *promise;\n\tstruct sun4i_dma_contract *contract;\n\tu8 ram_type, io_mode, linear_mode;\n\tstruct scatterlist *sg;\n\tdma_addr_t srcaddr, dstaddr;\n\tu32 endpoints, para;\n\tint i;\n\n\tif (!sgl)\n\t\treturn NULL;\n\n\tif (!is_slave_direction(dir)) {\n\t\tdev_err(chan2dev(chan), \"Invalid DMA direction\\n\");\n\t\treturn NULL;\n\t}\n\n\tcontract = generate_dma_contract();\n\tif (!contract)\n\t\treturn NULL;\n\n\tif (vchan->is_dedicated) {\n\t\tio_mode = SUN4I_DDMA_ADDR_MODE_IO;\n\t\tlinear_mode = SUN4I_DDMA_ADDR_MODE_LINEAR;\n\t\tram_type = SUN4I_DDMA_DRQ_TYPE_SDRAM;\n\t} else {\n\t\tio_mode = SUN4I_NDMA_ADDR_MODE_IO;\n\t\tlinear_mode = SUN4I_NDMA_ADDR_MODE_LINEAR;\n\t\tram_type = SUN4I_NDMA_DRQ_TYPE_SDRAM;\n\t}\n\n\tif (dir == DMA_MEM_TO_DEV)\n\t\tendpoints = SUN4I_DMA_CFG_DST_DRQ_TYPE(vchan->endpoint) |\n\t\t\t    SUN4I_DMA_CFG_DST_ADDR_MODE(io_mode) |\n\t\t\t    SUN4I_DMA_CFG_SRC_DRQ_TYPE(ram_type) |\n\t\t\t    SUN4I_DMA_CFG_SRC_ADDR_MODE(linear_mode);\n\telse\n\t\tendpoints = SUN4I_DMA_CFG_DST_DRQ_TYPE(ram_type) |\n\t\t\t    SUN4I_DMA_CFG_DST_ADDR_MODE(linear_mode) |\n\t\t\t    SUN4I_DMA_CFG_SRC_DRQ_TYPE(vchan->endpoint) |\n\t\t\t    SUN4I_DMA_CFG_SRC_ADDR_MODE(io_mode);\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\t \n\t\tif (dir == DMA_MEM_TO_DEV) {\n\t\t\tsrcaddr = sg_dma_address(sg);\n\t\t\tdstaddr = sconfig->dst_addr;\n\t\t} else {\n\t\t\tsrcaddr = sconfig->src_addr;\n\t\t\tdstaddr = sg_dma_address(sg);\n\t\t}\n\n\t\t \n\t\tpara = SUN4I_DDMA_MAGIC_SPI_PARAMETERS;\n\n\t\t \n\t\tif (vchan->is_dedicated)\n\t\t\tpromise = generate_ddma_promise(chan, srcaddr, dstaddr,\n\t\t\t\t\t\t\tsg_dma_len(sg),\n\t\t\t\t\t\t\tsconfig);\n\t\telse\n\t\t\tpromise = generate_ndma_promise(chan, srcaddr, dstaddr,\n\t\t\t\t\t\t\tsg_dma_len(sg),\n\t\t\t\t\t\t\tsconfig, dir);\n\n\t\tif (!promise)\n\t\t\treturn NULL;  \n\n\t\tpromise->cfg |= endpoints;\n\t\tpromise->para = para;\n\n\t\t \n\t\tlist_add_tail(&promise->list, &contract->demands);\n\t}\n\n\t \n\treturn vchan_tx_prep(&vchan->vc, &contract->vd, flags);\n}\n\nstatic int sun4i_dma_terminate_all(struct dma_chan *chan)\n{\n\tstruct sun4i_dma_dev *priv = to_sun4i_dma_dev(chan->device);\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tstruct sun4i_dma_pchan *pchan = vchan->pchan;\n\tLIST_HEAD(head);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\tvchan_get_all_descriptors(&vchan->vc, &head);\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\t \n\tif (pchan) {\n\t\tif (pchan->is_dedicated)\n\t\t\twritel(0, pchan->base + SUN4I_DDMA_CFG_REG);\n\t\telse\n\t\t\twritel(0, pchan->base + SUN4I_NDMA_CFG_REG);\n\t\tset_pchan_interrupt(priv, pchan, 0, 0);\n\t\trelease_pchan(priv, pchan);\n\t}\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\t \n\tvchan->processing = NULL;\n\tvchan->pchan = NULL;\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\tvchan_dma_desc_free_list(&vchan->vc, &head);\n\n\treturn 0;\n}\n\nstatic int sun4i_dma_config(struct dma_chan *chan,\n\t\t\t    struct dma_slave_config *config)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\n\tmemcpy(&vchan->cfg, config, sizeof(*config));\n\n\treturn 0;\n}\n\nstatic struct dma_chan *sun4i_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct sun4i_dma_dev *priv = ofdma->of_dma_data;\n\tstruct sun4i_dma_vchan *vchan;\n\tstruct dma_chan *chan;\n\tu8 is_dedicated = dma_spec->args[0];\n\tu8 endpoint = dma_spec->args[1];\n\n\t \n\tif (is_dedicated != 0 && is_dedicated != 1)\n\t\treturn NULL;\n\n\t \n\tif ((is_dedicated && endpoint >= SUN4I_DDMA_DRQ_TYPE_LIMIT) ||\n\t    (!is_dedicated && endpoint >= SUN4I_NDMA_DRQ_TYPE_LIMIT))\n\t\treturn NULL;\n\n\tchan = dma_get_any_slave_channel(&priv->slave);\n\tif (!chan)\n\t\treturn NULL;\n\n\t \n\tvchan = to_sun4i_dma_vchan(chan);\n\tvchan->is_dedicated = is_dedicated;\n\tvchan->endpoint = endpoint;\n\n\treturn chan;\n}\n\nstatic enum dma_status sun4i_dma_tx_status(struct dma_chan *chan,\n\t\t\t\t\t   dma_cookie_t cookie,\n\t\t\t\t\t   struct dma_tx_state *state)\n{\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tstruct sun4i_dma_pchan *pchan = vchan->pchan;\n\tstruct sun4i_dma_contract *contract;\n\tstruct sun4i_dma_promise *promise;\n\tstruct virt_dma_desc *vd;\n\tunsigned long flags;\n\tenum dma_status ret;\n\tsize_t bytes = 0;\n\n\tret = dma_cookie_status(chan, cookie, state);\n\tif (!state || (ret == DMA_COMPLETE))\n\t\treturn ret;\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\tvd = vchan_find_desc(&vchan->vc, cookie);\n\tif (!vd)\n\t\tgoto exit;\n\tcontract = to_sun4i_dma_contract(vd);\n\n\tlist_for_each_entry(promise, &contract->demands, list)\n\t\tbytes += promise->len;\n\n\t \n\tpromise = list_first_entry_or_null(&contract->demands,\n\t\t\t\t\t   struct sun4i_dma_promise, list);\n\tif (promise && pchan) {\n\t\tbytes -= promise->len;\n\t\tif (pchan->is_dedicated)\n\t\t\tbytes += readl(pchan->base + SUN4I_DDMA_BYTE_COUNT_REG);\n\t\telse\n\t\t\tbytes += readl(pchan->base + SUN4I_NDMA_BYTE_COUNT_REG);\n\t}\n\nexit:\n\n\tdma_set_residue(state, bytes);\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\treturn ret;\n}\n\nstatic void sun4i_dma_issue_pending(struct dma_chan *chan)\n{\n\tstruct sun4i_dma_dev *priv = to_sun4i_dma_dev(chan->device);\n\tstruct sun4i_dma_vchan *vchan = to_sun4i_dma_vchan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\n\t \n\tif (vchan_issue_pending(&vchan->vc))\n\t\t__execute_vchan_pending(priv, vchan);\n\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n}\n\nstatic irqreturn_t sun4i_dma_interrupt(int irq, void *dev_id)\n{\n\tstruct sun4i_dma_dev *priv = dev_id;\n\tstruct sun4i_dma_pchan *pchans = priv->pchans, *pchan;\n\tstruct sun4i_dma_vchan *vchan;\n\tstruct sun4i_dma_contract *contract;\n\tstruct sun4i_dma_promise *promise;\n\tunsigned long pendirq, irqs, disableirqs;\n\tint bit, i, free_room, allow_mitigation = 1;\n\n\tpendirq = readl_relaxed(priv->base + SUN4I_DMA_IRQ_PENDING_STATUS_REG);\n\nhandle_pending:\n\n\tdisableirqs = 0;\n\tfree_room = 0;\n\n\tfor_each_set_bit(bit, &pendirq, 32) {\n\t\tpchan = &pchans[bit >> 1];\n\t\tvchan = pchan->vchan;\n\t\tif (!vchan)  \n\t\t\tcontinue;\n\t\tcontract = vchan->contract;\n\n\t\t \n\t\tif (bit & 1) {\n\t\t\tspin_lock(&vchan->vc.lock);\n\n\t\t\t \n\t\t\tlist_move_tail(&vchan->processing->list,\n\t\t\t\t       &contract->completed_demands);\n\n\t\t\t \n\t\t\tif (contract->is_cyclic) {\n\t\t\t\tpromise = get_next_cyclic_promise(contract);\n\t\t\t\tvchan->processing = promise;\n\t\t\t\tconfigure_pchan(pchan, promise);\n\t\t\t\tvchan_cyclic_callback(&contract->vd);\n\t\t\t} else {\n\t\t\t\tvchan->processing = NULL;\n\t\t\t\tvchan->pchan = NULL;\n\n\t\t\t\tfree_room = 1;\n\t\t\t\tdisableirqs |= BIT(bit);\n\t\t\t\trelease_pchan(priv, pchan);\n\t\t\t}\n\n\t\t\tspin_unlock(&vchan->vc.lock);\n\t\t} else {\n\t\t\t \n\t\t\tif (contract->is_cyclic)\n\t\t\t\tvchan_cyclic_callback(&contract->vd);\n\t\t\telse\n\t\t\t\tdisableirqs |= BIT(bit);\n\t\t}\n\t}\n\n\t \n\tspin_lock(&priv->lock);\n\tirqs = readl_relaxed(priv->base + SUN4I_DMA_IRQ_ENABLE_REG);\n\twritel_relaxed(irqs & ~disableirqs,\n\t\t       priv->base + SUN4I_DMA_IRQ_ENABLE_REG);\n\tspin_unlock(&priv->lock);\n\n\t \n\twritel_relaxed(pendirq, priv->base + SUN4I_DMA_IRQ_PENDING_STATUS_REG);\n\n\t \n\tif (free_room) {\n\t\tfor (i = 0; i < SUN4I_DMA_NR_MAX_VCHANS; i++) {\n\t\t\tvchan = &priv->vchans[i];\n\t\t\tspin_lock(&vchan->vc.lock);\n\t\t\t__execute_vchan_pending(priv, vchan);\n\t\t\tspin_unlock(&vchan->vc.lock);\n\t\t}\n\t}\n\n\t \n\tif (allow_mitigation) {\n\t\tpendirq = readl_relaxed(priv->base +\n\t\t\t\t\tSUN4I_DMA_IRQ_PENDING_STATUS_REG);\n\t\tif (pendirq) {\n\t\t\tallow_mitigation = 0;\n\t\t\tgoto handle_pending;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_dma_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_dma_dev *priv;\n\tint i, j, ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"No clock specified\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tspin_lock_init(&priv->lock);\n\n\tdma_set_max_seg_size(&pdev->dev, SUN4I_DMA_MAX_SEG_SIZE);\n\n\tdma_cap_zero(priv->slave.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, priv->slave.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, priv->slave.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, priv->slave.cap_mask);\n\tdma_cap_set(DMA_SLAVE, priv->slave.cap_mask);\n\n\tINIT_LIST_HEAD(&priv->slave.channels);\n\tpriv->slave.device_free_chan_resources\t= sun4i_dma_free_chan_resources;\n\tpriv->slave.device_tx_status\t\t= sun4i_dma_tx_status;\n\tpriv->slave.device_issue_pending\t= sun4i_dma_issue_pending;\n\tpriv->slave.device_prep_slave_sg\t= sun4i_dma_prep_slave_sg;\n\tpriv->slave.device_prep_dma_memcpy\t= sun4i_dma_prep_dma_memcpy;\n\tpriv->slave.device_prep_dma_cyclic\t= sun4i_dma_prep_dma_cyclic;\n\tpriv->slave.device_config\t\t= sun4i_dma_config;\n\tpriv->slave.device_terminate_all\t= sun4i_dma_terminate_all;\n\tpriv->slave.copy_align\t\t\t= 2;\n\tpriv->slave.src_addr_widths\t\t= BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tpriv->slave.dst_addr_widths\t\t= BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t\t\t\t  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tpriv->slave.directions\t\t\t= BIT(DMA_DEV_TO_MEM) |\n\t\t\t\t\t\t  BIT(DMA_MEM_TO_DEV);\n\tpriv->slave.residue_granularity\t\t= DMA_RESIDUE_GRANULARITY_BURST;\n\n\tpriv->slave.dev = &pdev->dev;\n\n\tpriv->pchans = devm_kcalloc(&pdev->dev, SUN4I_DMA_NR_MAX_CHANNELS,\n\t\t\t\t    sizeof(struct sun4i_dma_pchan), GFP_KERNEL);\n\tpriv->vchans = devm_kcalloc(&pdev->dev, SUN4I_DMA_NR_MAX_VCHANS,\n\t\t\t\t    sizeof(struct sun4i_dma_vchan), GFP_KERNEL);\n\tif (!priv->vchans || !priv->pchans)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < SUN4I_NDMA_NR_MAX_CHANNELS; i++)\n\t\tpriv->pchans[i].base = priv->base +\n\t\t\tSUN4I_NDMA_CHANNEL_REG_BASE(i);\n\n\tfor (j = 0; i < SUN4I_DMA_NR_MAX_CHANNELS; i++, j++) {\n\t\tpriv->pchans[i].base = priv->base +\n\t\t\tSUN4I_DDMA_CHANNEL_REG_BASE(j);\n\t\tpriv->pchans[i].is_dedicated = 1;\n\t}\n\n\tfor (i = 0; i < SUN4I_DMA_NR_MAX_VCHANS; i++) {\n\t\tstruct sun4i_dma_vchan *vchan = &priv->vchans[i];\n\n\t\tspin_lock_init(&vchan->vc.lock);\n\t\tvchan->vc.desc_free = sun4i_dma_free_contract;\n\t\tvchan_init(&vchan->vc, &priv->slave);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(0, priv->base + SUN4I_DMA_IRQ_ENABLE_REG);\n\twritel(0xFFFFFFFF, priv->base + SUN4I_DMA_IRQ_PENDING_STATUS_REG);\n\n\tret = devm_request_irq(&pdev->dev, priv->irq, sun4i_dma_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request IRQ\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = dma_async_device_register(&priv->slave);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"Failed to register DMA engine device\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = of_dma_controller_register(pdev->dev.of_node, sun4i_dma_of_xlate,\n\t\t\t\t\t priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"of_dma_controller_register failed\\n\");\n\t\tgoto err_dma_unregister;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Successfully probed SUN4I_DMA\\n\");\n\n\treturn 0;\n\nerr_dma_unregister:\n\tdma_async_device_unregister(&priv->slave);\nerr_clk_disable:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic int sun4i_dma_remove(struct platform_device *pdev)\n{\n\tstruct sun4i_dma_dev *priv = platform_get_drvdata(pdev);\n\n\t \n\tdisable_irq(priv->irq);\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&priv->slave);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_dma_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-dma\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sun4i_dma_match);\n\nstatic struct platform_driver sun4i_dma_driver = {\n\t.probe\t= sun4i_dma_probe,\n\t.remove\t= sun4i_dma_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"sun4i-dma\",\n\t\t.of_match_table\t= sun4i_dma_match,\n\t},\n};\n\nmodule_platform_driver(sun4i_dma_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A10 Dedicated DMA Controller Driver\");\nMODULE_AUTHOR(\"Emilio L\u00f3pez <emilio@elopez.com.ar>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}