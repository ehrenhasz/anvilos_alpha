{
  "module_name": "zynqmp_dma.c",
  "hash_id": "30140b81157b651d1976ba022fd88645d2fd34d4441cb0a722659840735419e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/xilinx/zynqmp_dma.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/pm_runtime.h>\n\n#include \"../dmaengine.h\"\n\n \n#define ZYNQMP_DMA_ISR\t\t\t0x100\n#define ZYNQMP_DMA_IMR\t\t\t0x104\n#define ZYNQMP_DMA_IER\t\t\t0x108\n#define ZYNQMP_DMA_IDS\t\t\t0x10C\n#define ZYNQMP_DMA_CTRL0\t\t0x110\n#define ZYNQMP_DMA_CTRL1\t\t0x114\n#define ZYNQMP_DMA_DATA_ATTR\t\t0x120\n#define ZYNQMP_DMA_DSCR_ATTR\t\t0x124\n#define ZYNQMP_DMA_SRC_DSCR_WRD0\t0x128\n#define ZYNQMP_DMA_SRC_DSCR_WRD1\t0x12C\n#define ZYNQMP_DMA_SRC_DSCR_WRD2\t0x130\n#define ZYNQMP_DMA_SRC_DSCR_WRD3\t0x134\n#define ZYNQMP_DMA_DST_DSCR_WRD0\t0x138\n#define ZYNQMP_DMA_DST_DSCR_WRD1\t0x13C\n#define ZYNQMP_DMA_DST_DSCR_WRD2\t0x140\n#define ZYNQMP_DMA_DST_DSCR_WRD3\t0x144\n#define ZYNQMP_DMA_SRC_START_LSB\t0x158\n#define ZYNQMP_DMA_SRC_START_MSB\t0x15C\n#define ZYNQMP_DMA_DST_START_LSB\t0x160\n#define ZYNQMP_DMA_DST_START_MSB\t0x164\n#define ZYNQMP_DMA_TOTAL_BYTE\t\t0x188\n#define ZYNQMP_DMA_RATE_CTRL\t\t0x18C\n#define ZYNQMP_DMA_IRQ_SRC_ACCT\t\t0x190\n#define ZYNQMP_DMA_IRQ_DST_ACCT\t\t0x194\n#define ZYNQMP_DMA_CTRL2\t\t0x200\n\n \n#define ZYNQMP_DMA_DONE\t\t\tBIT(10)\n#define ZYNQMP_DMA_AXI_WR_DATA\t\tBIT(9)\n#define ZYNQMP_DMA_AXI_RD_DATA\t\tBIT(8)\n#define ZYNQMP_DMA_AXI_RD_DST_DSCR\tBIT(7)\n#define ZYNQMP_DMA_AXI_RD_SRC_DSCR\tBIT(6)\n#define ZYNQMP_DMA_IRQ_DST_ACCT_ERR\tBIT(5)\n#define ZYNQMP_DMA_IRQ_SRC_ACCT_ERR\tBIT(4)\n#define ZYNQMP_DMA_BYTE_CNT_OVRFL\tBIT(3)\n#define ZYNQMP_DMA_DST_DSCR_DONE\tBIT(2)\n#define ZYNQMP_DMA_INV_APB\t\tBIT(0)\n\n \n#define ZYNQMP_DMA_OVR_FETCH\t\tBIT(7)\n#define ZYNQMP_DMA_POINT_TYPE_SG\tBIT(6)\n#define ZYNQMP_DMA_RATE_CTRL_EN\t\tBIT(3)\n\n \n#define ZYNQMP_DMA_SRC_ISSUE\t\tGENMASK(4, 0)\n\n \n#define ZYNQMP_DMA_ARBURST\t\tGENMASK(27, 26)\n#define ZYNQMP_DMA_ARCACHE\t\tGENMASK(25, 22)\n#define ZYNQMP_DMA_ARCACHE_OFST\t\t22\n#define ZYNQMP_DMA_ARQOS\t\tGENMASK(21, 18)\n#define ZYNQMP_DMA_ARQOS_OFST\t\t18\n#define ZYNQMP_DMA_ARLEN\t\tGENMASK(17, 14)\n#define ZYNQMP_DMA_ARLEN_OFST\t\t14\n#define ZYNQMP_DMA_AWBURST\t\tGENMASK(13, 12)\n#define ZYNQMP_DMA_AWCACHE\t\tGENMASK(11, 8)\n#define ZYNQMP_DMA_AWCACHE_OFST\t\t8\n#define ZYNQMP_DMA_AWQOS\t\tGENMASK(7, 4)\n#define ZYNQMP_DMA_AWQOS_OFST\t\t4\n#define ZYNQMP_DMA_AWLEN\t\tGENMASK(3, 0)\n#define ZYNQMP_DMA_AWLEN_OFST\t\t0\n\n \n#define ZYNQMP_DMA_AXCOHRNT\t\tBIT(8)\n#define ZYNQMP_DMA_AXCACHE\t\tGENMASK(7, 4)\n#define ZYNQMP_DMA_AXCACHE_OFST\t\t4\n#define ZYNQMP_DMA_AXQOS\t\tGENMASK(3, 0)\n#define ZYNQMP_DMA_AXQOS_OFST\t\t0\n\n \n#define ZYNQMP_DMA_ENABLE\t\tBIT(0)\n\n \n#define ZYNQMP_DMA_DESC_CTRL_STOP\t0x10\n#define ZYNQMP_DMA_DESC_CTRL_COMP_INT\t0x4\n#define ZYNQMP_DMA_DESC_CTRL_SIZE_256\t0x2\n#define ZYNQMP_DMA_DESC_CTRL_COHRNT\t0x1\n\n \n#define ZYNQMP_DMA_INT_ERR\t(ZYNQMP_DMA_AXI_RD_DATA | \\\n\t\t\t\tZYNQMP_DMA_AXI_WR_DATA | \\\n\t\t\t\tZYNQMP_DMA_AXI_RD_DST_DSCR | \\\n\t\t\t\tZYNQMP_DMA_AXI_RD_SRC_DSCR | \\\n\t\t\t\tZYNQMP_DMA_INV_APB)\n#define ZYNQMP_DMA_INT_OVRFL\t(ZYNQMP_DMA_BYTE_CNT_OVRFL | \\\n\t\t\t\tZYNQMP_DMA_IRQ_SRC_ACCT_ERR | \\\n\t\t\t\tZYNQMP_DMA_IRQ_DST_ACCT_ERR)\n#define ZYNQMP_DMA_INT_DONE\t(ZYNQMP_DMA_DONE | ZYNQMP_DMA_DST_DSCR_DONE)\n#define ZYNQMP_DMA_INT_EN_DEFAULT_MASK\t(ZYNQMP_DMA_INT_DONE | \\\n\t\t\t\t\tZYNQMP_DMA_INT_ERR | \\\n\t\t\t\t\tZYNQMP_DMA_INT_OVRFL | \\\n\t\t\t\t\tZYNQMP_DMA_DST_DSCR_DONE)\n\n \n#define ZYNQMP_DMA_NUM_DESCS\t32\n\n \n#define ZYNQMP_DMA_MAX_TRANS_LEN\t0x40000000\n\n \n#define ZYNQMP_DMA_MAX_DST_BURST_LEN    32768U\n#define ZYNQMP_DMA_MAX_SRC_BURST_LEN    32768U\n\n \n#define ZYNQMP_DMA_AXCACHE_VAL\t\t0xF\n\n#define ZYNQMP_DMA_SRC_ISSUE_RST_VAL\t0x1F\n\n#define ZYNQMP_DMA_IDS_DEFAULT_MASK\t0xFFF\n\n \n#define ZYNQMP_DMA_BUS_WIDTH_64\t\t64\n#define ZYNQMP_DMA_BUS_WIDTH_128\t128\n\n#define ZDMA_PM_TIMEOUT\t\t\t100\n\n#define ZYNQMP_DMA_DESC_SIZE(chan)\t(chan->desc_size)\n\n#define to_chan(chan)\t\tcontainer_of(chan, struct zynqmp_dma_chan, \\\n\t\t\t\t\t     common)\n#define tx_to_desc(tx)\t\tcontainer_of(tx, struct zynqmp_dma_desc_sw, \\\n\t\t\t\t\t     async_tx)\n\n \nstruct zynqmp_dma_desc_ll {\n\tu64 addr;\n\tu32 size;\n\tu32 ctrl;\n\tu64 nxtdscraddr;\n\tu64 rsvd;\n};\n\n \nstruct zynqmp_dma_desc_sw {\n\tu64 src;\n\tu64 dst;\n\tu32 len;\n\tstruct list_head node;\n\tstruct list_head tx_list;\n\tstruct dma_async_tx_descriptor async_tx;\n\tstruct zynqmp_dma_desc_ll *src_v;\n\tdma_addr_t src_p;\n\tstruct zynqmp_dma_desc_ll *dst_v;\n\tdma_addr_t dst_p;\n};\n\n \nstruct zynqmp_dma_chan {\n\tstruct zynqmp_dma_device *zdev;\n\tvoid __iomem *regs;\n\tspinlock_t lock;\n\tstruct list_head pending_list;\n\tstruct list_head free_list;\n\tstruct list_head active_list;\n\tstruct zynqmp_dma_desc_sw *sw_desc_pool;\n\tstruct list_head done_list;\n\tstruct dma_chan common;\n\tvoid *desc_pool_v;\n\tdma_addr_t desc_pool_p;\n\tu32 desc_free_cnt;\n\tstruct device *dev;\n\tint irq;\n\tbool is_dmacoherent;\n\tstruct tasklet_struct tasklet;\n\tbool idle;\n\tsize_t desc_size;\n\tbool err;\n\tu32 bus_width;\n\tu32 src_burst_len;\n\tu32 dst_burst_len;\n};\n\n \nstruct zynqmp_dma_device {\n\tstruct device *dev;\n\tstruct dma_device common;\n\tstruct zynqmp_dma_chan *chan;\n\tstruct clk *clk_main;\n\tstruct clk *clk_apb;\n};\n\nstatic inline void zynqmp_dma_writeq(struct zynqmp_dma_chan *chan, u32 reg,\n\t\t\t\t     u64 value)\n{\n\tlo_hi_writeq(value, chan->regs + reg);\n}\n\n \nstatic void zynqmp_dma_update_desc_to_ctrlr(struct zynqmp_dma_chan *chan,\n\t\t\t\t      struct zynqmp_dma_desc_sw *desc)\n{\n\tdma_addr_t addr;\n\n\taddr = desc->src_p;\n\tzynqmp_dma_writeq(chan, ZYNQMP_DMA_SRC_START_LSB, addr);\n\taddr = desc->dst_p;\n\tzynqmp_dma_writeq(chan, ZYNQMP_DMA_DST_START_LSB, addr);\n}\n\n \nstatic void zynqmp_dma_desc_config_eod(struct zynqmp_dma_chan *chan,\n\t\t\t\t       void *desc)\n{\n\tstruct zynqmp_dma_desc_ll *hw = (struct zynqmp_dma_desc_ll *)desc;\n\n\thw->ctrl |= ZYNQMP_DMA_DESC_CTRL_STOP;\n\thw++;\n\thw->ctrl |= ZYNQMP_DMA_DESC_CTRL_COMP_INT | ZYNQMP_DMA_DESC_CTRL_STOP;\n}\n\n \nstatic void zynqmp_dma_config_sg_ll_desc(struct zynqmp_dma_chan *chan,\n\t\t\t\t   struct zynqmp_dma_desc_ll *sdesc,\n\t\t\t\t   dma_addr_t src, dma_addr_t dst, size_t len,\n\t\t\t\t   struct zynqmp_dma_desc_ll *prev)\n{\n\tstruct zynqmp_dma_desc_ll *ddesc = sdesc + 1;\n\n\tsdesc->size = ddesc->size = len;\n\tsdesc->addr = src;\n\tddesc->addr = dst;\n\n\tsdesc->ctrl = ddesc->ctrl = ZYNQMP_DMA_DESC_CTRL_SIZE_256;\n\tif (chan->is_dmacoherent) {\n\t\tsdesc->ctrl |= ZYNQMP_DMA_DESC_CTRL_COHRNT;\n\t\tddesc->ctrl |= ZYNQMP_DMA_DESC_CTRL_COHRNT;\n\t}\n\n\tif (prev) {\n\t\tdma_addr_t addr = chan->desc_pool_p +\n\t\t\t    ((uintptr_t)sdesc - (uintptr_t)chan->desc_pool_v);\n\t\tddesc = prev + 1;\n\t\tprev->nxtdscraddr = addr;\n\t\tddesc->nxtdscraddr = addr + ZYNQMP_DMA_DESC_SIZE(chan);\n\t}\n}\n\n \nstatic void zynqmp_dma_init(struct zynqmp_dma_chan *chan)\n{\n\tu32 val;\n\n\twritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\n\tval = readl(chan->regs + ZYNQMP_DMA_ISR);\n\twritel(val, chan->regs + ZYNQMP_DMA_ISR);\n\n\tif (chan->is_dmacoherent) {\n\t\tval = ZYNQMP_DMA_AXCOHRNT;\n\t\tval = (val & ~ZYNQMP_DMA_AXCACHE) |\n\t\t\t(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_AXCACHE_OFST);\n\t\twritel(val, chan->regs + ZYNQMP_DMA_DSCR_ATTR);\n\t}\n\n\tval = readl(chan->regs + ZYNQMP_DMA_DATA_ATTR);\n\tif (chan->is_dmacoherent) {\n\t\tval = (val & ~ZYNQMP_DMA_ARCACHE) |\n\t\t\t(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_ARCACHE_OFST);\n\t\tval = (val & ~ZYNQMP_DMA_AWCACHE) |\n\t\t\t(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_AWCACHE_OFST);\n\t}\n\twritel(val, chan->regs + ZYNQMP_DMA_DATA_ATTR);\n\n\t \n\tval = readl(chan->regs + ZYNQMP_DMA_IRQ_SRC_ACCT);\n\tval = readl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\n\n\tchan->idle = true;\n}\n\n \nstatic dma_cookie_t zynqmp_dma_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(tx->chan);\n\tstruct zynqmp_dma_desc_sw *desc, *new;\n\tdma_cookie_t cookie;\n\tunsigned long irqflags;\n\n\tnew = tx_to_desc(tx);\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tcookie = dma_cookie_assign(tx);\n\n\tif (!list_empty(&chan->pending_list)) {\n\t\tdesc = list_last_entry(&chan->pending_list,\n\t\t\t\t     struct zynqmp_dma_desc_sw, node);\n\t\tif (!list_empty(&desc->tx_list))\n\t\t\tdesc = list_last_entry(&desc->tx_list,\n\t\t\t\t\t       struct zynqmp_dma_desc_sw, node);\n\t\tdesc->src_v->nxtdscraddr = new->src_p;\n\t\tdesc->src_v->ctrl &= ~ZYNQMP_DMA_DESC_CTRL_STOP;\n\t\tdesc->dst_v->nxtdscraddr = new->dst_p;\n\t\tdesc->dst_v->ctrl &= ~ZYNQMP_DMA_DESC_CTRL_STOP;\n\t}\n\n\tlist_add_tail(&new->node, &chan->pending_list);\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\n\treturn cookie;\n}\n\n \nstatic struct zynqmp_dma_desc_sw *\nzynqmp_dma_get_descriptor(struct zynqmp_dma_chan *chan)\n{\n\tstruct zynqmp_dma_desc_sw *desc;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tdesc = list_first_entry(&chan->free_list,\n\t\t\t\tstruct zynqmp_dma_desc_sw, node);\n\tlist_del(&desc->node);\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\n\tINIT_LIST_HEAD(&desc->tx_list);\n\t \n\tmemset((void *)desc->src_v, 0, ZYNQMP_DMA_DESC_SIZE(chan));\n\tmemset((void *)desc->dst_v, 0, ZYNQMP_DMA_DESC_SIZE(chan));\n\n\treturn desc;\n}\n\n \nstatic void zynqmp_dma_free_descriptor(struct zynqmp_dma_chan *chan,\n\t\t\t\t struct zynqmp_dma_desc_sw *sdesc)\n{\n\tstruct zynqmp_dma_desc_sw *child, *next;\n\n\tchan->desc_free_cnt++;\n\tlist_move_tail(&sdesc->node, &chan->free_list);\n\tlist_for_each_entry_safe(child, next, &sdesc->tx_list, node) {\n\t\tchan->desc_free_cnt++;\n\t\tlist_move_tail(&child->node, &chan->free_list);\n\t}\n}\n\n \nstatic void zynqmp_dma_free_desc_list(struct zynqmp_dma_chan *chan,\n\t\t\t\t      struct list_head *list)\n{\n\tstruct zynqmp_dma_desc_sw *desc, *next;\n\n\tlist_for_each_entry_safe(desc, next, list, node)\n\t\tzynqmp_dma_free_descriptor(chan, desc);\n}\n\n \nstatic int zynqmp_dma_alloc_chan_resources(struct dma_chan *dchan)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\tstruct zynqmp_dma_desc_sw *desc;\n\tint i, ret;\n\n\tret = pm_runtime_resume_and_get(chan->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchan->sw_desc_pool = kcalloc(ZYNQMP_DMA_NUM_DESCS, sizeof(*desc),\n\t\t\t\t     GFP_KERNEL);\n\tif (!chan->sw_desc_pool)\n\t\treturn -ENOMEM;\n\n\tchan->idle = true;\n\tchan->desc_free_cnt = ZYNQMP_DMA_NUM_DESCS;\n\n\tINIT_LIST_HEAD(&chan->free_list);\n\n\tfor (i = 0; i < ZYNQMP_DMA_NUM_DESCS; i++) {\n\t\tdesc = chan->sw_desc_pool + i;\n\t\tdma_async_tx_descriptor_init(&desc->async_tx, &chan->common);\n\t\tdesc->async_tx.tx_submit = zynqmp_dma_tx_submit;\n\t\tlist_add_tail(&desc->node, &chan->free_list);\n\t}\n\n\tchan->desc_pool_v = dma_alloc_coherent(chan->dev,\n\t\t\t\t\t       (2 * ZYNQMP_DMA_DESC_SIZE(chan) *\n\t\t\t\t\t       ZYNQMP_DMA_NUM_DESCS),\n\t\t\t\t\t       &chan->desc_pool_p, GFP_KERNEL);\n\tif (!chan->desc_pool_v)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ZYNQMP_DMA_NUM_DESCS; i++) {\n\t\tdesc = chan->sw_desc_pool + i;\n\t\tdesc->src_v = (struct zynqmp_dma_desc_ll *) (chan->desc_pool_v +\n\t\t\t\t\t(i * ZYNQMP_DMA_DESC_SIZE(chan) * 2));\n\t\tdesc->dst_v = (struct zynqmp_dma_desc_ll *) (desc->src_v + 1);\n\t\tdesc->src_p = chan->desc_pool_p +\n\t\t\t\t(i * ZYNQMP_DMA_DESC_SIZE(chan) * 2);\n\t\tdesc->dst_p = desc->src_p + ZYNQMP_DMA_DESC_SIZE(chan);\n\t}\n\n\treturn ZYNQMP_DMA_NUM_DESCS;\n}\n\n \nstatic void zynqmp_dma_start(struct zynqmp_dma_chan *chan)\n{\n\twritel(ZYNQMP_DMA_INT_EN_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IER);\n\twritel(0, chan->regs + ZYNQMP_DMA_TOTAL_BYTE);\n\tchan->idle = false;\n\twritel(ZYNQMP_DMA_ENABLE, chan->regs + ZYNQMP_DMA_CTRL2);\n}\n\n \nstatic void zynqmp_dma_handle_ovfl_int(struct zynqmp_dma_chan *chan, u32 status)\n{\n\tif (status & ZYNQMP_DMA_BYTE_CNT_OVRFL)\n\t\twritel(0, chan->regs + ZYNQMP_DMA_TOTAL_BYTE);\n\tif (status & ZYNQMP_DMA_IRQ_DST_ACCT_ERR)\n\t\treadl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\n\tif (status & ZYNQMP_DMA_IRQ_SRC_ACCT_ERR)\n\t\treadl(chan->regs + ZYNQMP_DMA_IRQ_SRC_ACCT);\n}\n\nstatic void zynqmp_dma_config(struct zynqmp_dma_chan *chan)\n{\n\tu32 val, burst_val;\n\n\tval = readl(chan->regs + ZYNQMP_DMA_CTRL0);\n\tval |= ZYNQMP_DMA_POINT_TYPE_SG;\n\twritel(val, chan->regs + ZYNQMP_DMA_CTRL0);\n\n\tval = readl(chan->regs + ZYNQMP_DMA_DATA_ATTR);\n\tburst_val = __ilog2_u32(chan->src_burst_len);\n\tval = (val & ~ZYNQMP_DMA_ARLEN) |\n\t\t((burst_val << ZYNQMP_DMA_ARLEN_OFST) & ZYNQMP_DMA_ARLEN);\n\tburst_val = __ilog2_u32(chan->dst_burst_len);\n\tval = (val & ~ZYNQMP_DMA_AWLEN) |\n\t\t((burst_val << ZYNQMP_DMA_AWLEN_OFST) & ZYNQMP_DMA_AWLEN);\n\twritel(val, chan->regs + ZYNQMP_DMA_DATA_ATTR);\n}\n\n \nstatic int zynqmp_dma_device_config(struct dma_chan *dchan,\n\t\t\t\t    struct dma_slave_config *config)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\n\tchan->src_burst_len = clamp(config->src_maxburst, 1U,\n\t\tZYNQMP_DMA_MAX_SRC_BURST_LEN);\n\tchan->dst_burst_len = clamp(config->dst_maxburst, 1U,\n\t\tZYNQMP_DMA_MAX_DST_BURST_LEN);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_dma_start_transfer(struct zynqmp_dma_chan *chan)\n{\n\tstruct zynqmp_dma_desc_sw *desc;\n\n\tif (!chan->idle)\n\t\treturn;\n\n\tzynqmp_dma_config(chan);\n\n\tdesc = list_first_entry_or_null(&chan->pending_list,\n\t\t\t\t\tstruct zynqmp_dma_desc_sw, node);\n\tif (!desc)\n\t\treturn;\n\n\tlist_splice_tail_init(&chan->pending_list, &chan->active_list);\n\tzynqmp_dma_update_desc_to_ctrlr(chan, desc);\n\tzynqmp_dma_start(chan);\n}\n\n\n \nstatic void zynqmp_dma_chan_desc_cleanup(struct zynqmp_dma_chan *chan)\n{\n\tstruct zynqmp_dma_desc_sw *desc, *next;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\n\tlist_for_each_entry_safe(desc, next, &chan->done_list, node) {\n\t\tstruct dmaengine_desc_callback cb;\n\n\t\tdmaengine_desc_get_callback(&desc->async_tx, &cb);\n\t\tif (dmaengine_desc_callback_valid(&cb)) {\n\t\t\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\t\t\tdmaengine_desc_callback_invoke(&cb, NULL);\n\t\t\tspin_lock_irqsave(&chan->lock, irqflags);\n\t\t}\n\n\t\t \n\t\tzynqmp_dma_free_descriptor(chan, desc);\n\t}\n\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n}\n\n \nstatic void zynqmp_dma_complete_descriptor(struct zynqmp_dma_chan *chan)\n{\n\tstruct zynqmp_dma_desc_sw *desc;\n\n\tdesc = list_first_entry_or_null(&chan->active_list,\n\t\t\t\t\tstruct zynqmp_dma_desc_sw, node);\n\tif (!desc)\n\t\treturn;\n\tlist_del(&desc->node);\n\tdma_cookie_complete(&desc->async_tx);\n\tlist_add_tail(&desc->node, &chan->done_list);\n}\n\n \nstatic void zynqmp_dma_issue_pending(struct dma_chan *dchan)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tzynqmp_dma_start_transfer(chan);\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n}\n\n \nstatic void zynqmp_dma_free_descriptors(struct zynqmp_dma_chan *chan)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tzynqmp_dma_free_desc_list(chan, &chan->active_list);\n\tzynqmp_dma_free_desc_list(chan, &chan->pending_list);\n\tzynqmp_dma_free_desc_list(chan, &chan->done_list);\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n}\n\n \nstatic void zynqmp_dma_free_chan_resources(struct dma_chan *dchan)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\n\tzynqmp_dma_free_descriptors(chan);\n\tdma_free_coherent(chan->dev,\n\t\t(2 * ZYNQMP_DMA_DESC_SIZE(chan) * ZYNQMP_DMA_NUM_DESCS),\n\t\tchan->desc_pool_v, chan->desc_pool_p);\n\tkfree(chan->sw_desc_pool);\n\tpm_runtime_mark_last_busy(chan->dev);\n\tpm_runtime_put_autosuspend(chan->dev);\n}\n\n \nstatic void zynqmp_dma_reset(struct zynqmp_dma_chan *chan)\n{\n\tunsigned long irqflags;\n\n\twritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tzynqmp_dma_complete_descriptor(chan);\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\tzynqmp_dma_chan_desc_cleanup(chan);\n\tzynqmp_dma_free_descriptors(chan);\n\n\tzynqmp_dma_init(chan);\n}\n\n \nstatic irqreturn_t zynqmp_dma_irq_handler(int irq, void *data)\n{\n\tstruct zynqmp_dma_chan *chan = (struct zynqmp_dma_chan *)data;\n\tu32 isr, imr, status;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tisr = readl(chan->regs + ZYNQMP_DMA_ISR);\n\timr = readl(chan->regs + ZYNQMP_DMA_IMR);\n\tstatus = isr & ~imr;\n\n\twritel(isr, chan->regs + ZYNQMP_DMA_ISR);\n\tif (status & ZYNQMP_DMA_INT_DONE) {\n\t\ttasklet_schedule(&chan->tasklet);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status & ZYNQMP_DMA_DONE)\n\t\tchan->idle = true;\n\n\tif (status & ZYNQMP_DMA_INT_ERR) {\n\t\tchan->err = true;\n\t\ttasklet_schedule(&chan->tasklet);\n\t\tdev_err(chan->dev, \"Channel %p has errors\\n\", chan);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status & ZYNQMP_DMA_INT_OVRFL) {\n\t\tzynqmp_dma_handle_ovfl_int(chan, status);\n\t\tdev_dbg(chan->dev, \"Channel %p overflow interrupt\\n\", chan);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void zynqmp_dma_do_tasklet(struct tasklet_struct *t)\n{\n\tstruct zynqmp_dma_chan *chan = from_tasklet(chan, t, tasklet);\n\tu32 count;\n\tunsigned long irqflags;\n\n\tif (chan->err) {\n\t\tzynqmp_dma_reset(chan);\n\t\tchan->err = false;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tcount = readl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\n\twhile (count) {\n\t\tzynqmp_dma_complete_descriptor(chan);\n\t\tcount--;\n\t}\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\n\tzynqmp_dma_chan_desc_cleanup(chan);\n\n\tif (chan->idle) {\n\t\tspin_lock_irqsave(&chan->lock, irqflags);\n\t\tzynqmp_dma_start_transfer(chan);\n\t\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\t}\n}\n\n \nstatic int zynqmp_dma_device_terminate_all(struct dma_chan *dchan)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\n\twritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\n\tzynqmp_dma_free_descriptors(chan);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_dma_synchronize(struct dma_chan *dchan)\n{\n\tstruct zynqmp_dma_chan *chan = to_chan(dchan);\n\n\ttasklet_kill(&chan->tasklet);\n}\n\n \nstatic struct dma_async_tx_descriptor *zynqmp_dma_prep_memcpy(\n\t\t\t\tstruct dma_chan *dchan, dma_addr_t dma_dst,\n\t\t\t\tdma_addr_t dma_src, size_t len, ulong flags)\n{\n\tstruct zynqmp_dma_chan *chan;\n\tstruct zynqmp_dma_desc_sw *new, *first = NULL;\n\tvoid *desc = NULL, *prev = NULL;\n\tsize_t copy;\n\tu32 desc_cnt;\n\tunsigned long irqflags;\n\n\tchan = to_chan(dchan);\n\n\tdesc_cnt = DIV_ROUND_UP(len, ZYNQMP_DMA_MAX_TRANS_LEN);\n\n\tspin_lock_irqsave(&chan->lock, irqflags);\n\tif (desc_cnt > chan->desc_free_cnt) {\n\t\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\t\tdev_dbg(chan->dev, \"chan %p descs are not available\\n\", chan);\n\t\treturn NULL;\n\t}\n\tchan->desc_free_cnt = chan->desc_free_cnt - desc_cnt;\n\tspin_unlock_irqrestore(&chan->lock, irqflags);\n\n\tdo {\n\t\t \n\t\tnew = zynqmp_dma_get_descriptor(chan);\n\n\t\tcopy = min_t(size_t, len, ZYNQMP_DMA_MAX_TRANS_LEN);\n\t\tdesc = (struct zynqmp_dma_desc_ll *)new->src_v;\n\t\tzynqmp_dma_config_sg_ll_desc(chan, desc, dma_src,\n\t\t\t\t\t     dma_dst, copy, prev);\n\t\tprev = desc;\n\t\tlen -= copy;\n\t\tdma_src += copy;\n\t\tdma_dst += copy;\n\t\tif (!first)\n\t\t\tfirst = new;\n\t\telse\n\t\t\tlist_add_tail(&new->node, &first->tx_list);\n\t} while (len);\n\n\tzynqmp_dma_desc_config_eod(chan, desc);\n\tasync_tx_ack(&first->async_tx);\n\tfirst->async_tx.flags = (enum dma_ctrl_flags)flags;\n\treturn &first->async_tx;\n}\n\n \nstatic void zynqmp_dma_chan_remove(struct zynqmp_dma_chan *chan)\n{\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->irq)\n\t\tdevm_free_irq(chan->zdev->dev, chan->irq, chan);\n\ttasklet_kill(&chan->tasklet);\n\tlist_del(&chan->common.device_node);\n}\n\n \nstatic int zynqmp_dma_chan_probe(struct zynqmp_dma_device *zdev,\n\t\t\t   struct platform_device *pdev)\n{\n\tstruct zynqmp_dma_chan *chan;\n\tstruct device_node *node = pdev->dev.of_node;\n\tint err;\n\n\tchan = devm_kzalloc(zdev->dev, sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\tchan->dev = zdev->dev;\n\tchan->zdev = zdev;\n\n\tchan->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chan->regs))\n\t\treturn PTR_ERR(chan->regs);\n\n\tchan->bus_width = ZYNQMP_DMA_BUS_WIDTH_64;\n\tchan->dst_burst_len = ZYNQMP_DMA_MAX_DST_BURST_LEN;\n\tchan->src_burst_len = ZYNQMP_DMA_MAX_SRC_BURST_LEN;\n\terr = of_property_read_u32(node, \"xlnx,bus-width\", &chan->bus_width);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"missing xlnx,bus-width property\\n\");\n\t\treturn err;\n\t}\n\n\tif (chan->bus_width != ZYNQMP_DMA_BUS_WIDTH_64 &&\n\t    chan->bus_width != ZYNQMP_DMA_BUS_WIDTH_128) {\n\t\tdev_err(zdev->dev, \"invalid bus-width value\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan->is_dmacoherent =  of_property_read_bool(node, \"dma-coherent\");\n\tzdev->chan = chan;\n\ttasklet_setup(&chan->tasklet, zynqmp_dma_do_tasklet);\n\tspin_lock_init(&chan->lock);\n\tINIT_LIST_HEAD(&chan->active_list);\n\tINIT_LIST_HEAD(&chan->pending_list);\n\tINIT_LIST_HEAD(&chan->done_list);\n\tINIT_LIST_HEAD(&chan->free_list);\n\n\tdma_cookie_init(&chan->common);\n\tchan->common.device = &zdev->common;\n\tlist_add_tail(&chan->common.device_node, &zdev->common.channels);\n\n\tzynqmp_dma_init(chan);\n\tchan->irq = platform_get_irq(pdev, 0);\n\tif (chan->irq < 0)\n\t\treturn -ENXIO;\n\terr = devm_request_irq(&pdev->dev, chan->irq, zynqmp_dma_irq_handler, 0,\n\t\t\t       \"zynqmp-dma\", chan);\n\tif (err)\n\t\treturn err;\n\n\tchan->desc_size = sizeof(struct zynqmp_dma_desc_ll);\n\tchan->idle = true;\n\treturn 0;\n}\n\n \nstatic struct dma_chan *of_zynqmp_dma_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t    struct of_dma *ofdma)\n{\n\tstruct zynqmp_dma_device *zdev = ofdma->of_dma_data;\n\n\treturn dma_get_slave_channel(&zdev->chan->common);\n}\n\n \nstatic int __maybe_unused zynqmp_dma_suspend(struct device *dev)\n{\n\tif (!device_may_wakeup(dev))\n\t\treturn pm_runtime_force_suspend(dev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_dma_resume(struct device *dev)\n{\n\tif (!device_may_wakeup(dev))\n\t\treturn pm_runtime_force_resume(dev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_dma_runtime_suspend(struct device *dev)\n{\n\tstruct zynqmp_dma_device *zdev = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(zdev->clk_main);\n\tclk_disable_unprepare(zdev->clk_apb);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused zynqmp_dma_runtime_resume(struct device *dev)\n{\n\tstruct zynqmp_dma_device *zdev = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(zdev->clk_main);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to enable main clock.\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(zdev->clk_apb);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to enable apb clock.\\n\");\n\t\tclk_disable_unprepare(zdev->clk_main);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops zynqmp_dma_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(zynqmp_dma_suspend, zynqmp_dma_resume)\n\tSET_RUNTIME_PM_OPS(zynqmp_dma_runtime_suspend,\n\t\t\t   zynqmp_dma_runtime_resume, NULL)\n};\n\n \nstatic int zynqmp_dma_probe(struct platform_device *pdev)\n{\n\tstruct zynqmp_dma_device *zdev;\n\tstruct dma_device *p;\n\tint ret;\n\n\tzdev = devm_kzalloc(&pdev->dev, sizeof(*zdev), GFP_KERNEL);\n\tif (!zdev)\n\t\treturn -ENOMEM;\n\n\tzdev->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&zdev->common.channels);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(44));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DMA not available for address range\\n\");\n\t\treturn ret;\n\t}\n\tdma_cap_set(DMA_MEMCPY, zdev->common.cap_mask);\n\n\tp = &zdev->common;\n\tp->device_prep_dma_memcpy = zynqmp_dma_prep_memcpy;\n\tp->device_terminate_all = zynqmp_dma_device_terminate_all;\n\tp->device_synchronize = zynqmp_dma_synchronize;\n\tp->device_issue_pending = zynqmp_dma_issue_pending;\n\tp->device_alloc_chan_resources = zynqmp_dma_alloc_chan_resources;\n\tp->device_free_chan_resources = zynqmp_dma_free_chan_resources;\n\tp->device_tx_status = dma_cookie_status;\n\tp->device_config = zynqmp_dma_device_config;\n\tp->dev = &pdev->dev;\n\n\tzdev->clk_main = devm_clk_get(&pdev->dev, \"clk_main\");\n\tif (IS_ERR(zdev->clk_main))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(zdev->clk_main),\n\t\t\t\t     \"main clock not found.\\n\");\n\n\tzdev->clk_apb = devm_clk_get(&pdev->dev, \"clk_apb\");\n\tif (IS_ERR(zdev->clk_apb))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(zdev->clk_apb),\n\t\t\t\t     \"apb clock not found.\\n\");\n\n\tplatform_set_drvdata(pdev, zdev);\n\tpm_runtime_set_autosuspend_delay(zdev->dev, ZDMA_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(zdev->dev);\n\tpm_runtime_enable(zdev->dev);\n\tret = pm_runtime_resume_and_get(zdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"device wakeup failed.\\n\");\n\t\tpm_runtime_disable(zdev->dev);\n\t}\n\tif (!pm_runtime_enabled(zdev->dev)) {\n\t\tret = zynqmp_dma_runtime_resume(zdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = zynqmp_dma_chan_probe(zdev, pdev);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"Probing channel failed\\n\");\n\t\tgoto err_disable_pm;\n\t}\n\n\tp->dst_addr_widths = BIT(zdev->chan->bus_width / 8);\n\tp->src_addr_widths = BIT(zdev->chan->bus_width / 8);\n\n\tret = dma_async_device_register(&zdev->common);\n\tif (ret) {\n\t\tdev_err(zdev->dev, \"failed to register the dma device\\n\");\n\t\tgoto free_chan_resources;\n\t}\n\n\tret = of_dma_controller_register(pdev->dev.of_node,\n\t\t\t\t\t of_zynqmp_dma_xlate, zdev);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"Unable to register DMA to DT\\n\");\n\t\tdma_async_device_unregister(&zdev->common);\n\t\tgoto free_chan_resources;\n\t}\n\n\tpm_runtime_mark_last_busy(zdev->dev);\n\tpm_runtime_put_sync_autosuspend(zdev->dev);\n\n\treturn 0;\n\nfree_chan_resources:\n\tzynqmp_dma_chan_remove(zdev->chan);\nerr_disable_pm:\n\tif (!pm_runtime_enabled(zdev->dev))\n\t\tzynqmp_dma_runtime_suspend(zdev->dev);\n\tpm_runtime_disable(zdev->dev);\n\treturn ret;\n}\n\n \nstatic int zynqmp_dma_remove(struct platform_device *pdev)\n{\n\tstruct zynqmp_dma_device *zdev = platform_get_drvdata(pdev);\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&zdev->common);\n\n\tzynqmp_dma_chan_remove(zdev->chan);\n\tpm_runtime_disable(zdev->dev);\n\tif (!pm_runtime_enabled(zdev->dev))\n\t\tzynqmp_dma_runtime_suspend(zdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zynqmp_dma_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-dma-1.0\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, zynqmp_dma_of_match);\n\nstatic struct platform_driver zynqmp_dma_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-zynqmp-dma\",\n\t\t.of_match_table = zynqmp_dma_of_match,\n\t\t.pm = &zynqmp_dma_dev_pm_ops,\n\t},\n\t.probe = zynqmp_dma_probe,\n\t.remove = zynqmp_dma_remove,\n};\n\nmodule_platform_driver(zynqmp_dma_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx ZynqMP DMA driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}