{
  "module_name": "pci.c",
  "hash_id": "862faa148104f953fdd249767c5e3938517d1a4aaa34bc9511cd36eb0f3e3c00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n\n#include \"internal.h\"\n\nstatic int dw_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)\n{\n\tconst struct dw_dma_chip_pdata *drv_data = (void *)pid->driver_data;\n\tstruct dw_dma_chip_pdata *data;\n\tstruct dw_dma_chip *chip;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I/O memory remapping failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tdata = devm_kmemdup(&pdev->dev, drv_data, sizeof(*drv_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &pdev->dev;\n\tchip->id = pdev->devfn;\n\tchip->regs = pcim_iomap_table(pdev)[0];\n\tchip->irq = pdev->irq;\n\tchip->pdata = data->pdata;\n\n\tdata->chip = chip;\n\n\tret = data->probe(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tdw_dma_acpi_controller_register(chip->dw);\n\n\tpci_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic void dw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct dw_dma_chip_pdata *data = pci_get_drvdata(pdev);\n\tstruct dw_dma_chip *chip = data->chip;\n\tint ret;\n\n\tdw_dma_acpi_controller_free(chip->dw);\n\n\tret = data->remove(chip);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"can't remove device properly: %d\\n\", ret);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int dw_pci_suspend_late(struct device *dev)\n{\n\tstruct dw_dma_chip_pdata *data = dev_get_drvdata(dev);\n\tstruct dw_dma_chip *chip = data->chip;\n\n\treturn do_dw_dma_disable(chip);\n};\n\nstatic int dw_pci_resume_early(struct device *dev)\n{\n\tstruct dw_dma_chip_pdata *data = dev_get_drvdata(dev);\n\tstruct dw_dma_chip *chip = data->chip;\n\n\treturn do_dw_dma_enable(chip);\n};\n\n#endif  \n\nstatic const struct dev_pm_ops dw_pci_dev_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(dw_pci_suspend_late, dw_pci_resume_early)\n};\n\nstatic const struct pci_device_id dw_pci_id_table[] = {\n\t \n\t{ PCI_VDEVICE(INTEL, 0x0827), (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x0f06), (kernel_ulong_t)&dw_dma_chip_pdata },\n\t{ PCI_VDEVICE(INTEL, 0x0f40), (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x11a2), (kernel_ulong_t)&idma32_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x2286), (kernel_ulong_t)&dw_dma_chip_pdata },\n\t{ PCI_VDEVICE(INTEL, 0x22c0), (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x4bb4), (kernel_ulong_t)&xbar_chip_pdata },\n\t{ PCI_VDEVICE(INTEL, 0x4bb5), (kernel_ulong_t)&xbar_chip_pdata },\n\t{ PCI_VDEVICE(INTEL, 0x4bb6), (kernel_ulong_t)&xbar_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x9c60), (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t \n\t{ PCI_VDEVICE(INTEL, 0x9ce0), (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, dw_pci_id_table);\n\nstatic struct pci_driver dw_pci_driver = {\n\t.name\t\t= \"dw_dmac_pci\",\n\t.id_table\t= dw_pci_id_table,\n\t.probe\t\t= dw_pci_probe,\n\t.remove\t\t= dw_pci_remove,\n\t.driver\t= {\n\t\t.pm\t= &dw_pci_dev_pm_ops,\n\t},\n};\n\nmodule_pci_driver(dw_pci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare DMA Controller PCI driver\");\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}