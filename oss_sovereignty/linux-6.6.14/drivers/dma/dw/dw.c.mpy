{
  "module_name": "dw.c",
  "hash_id": "d83bdc5256380870a695016f28904294bda110ab4b389c8b472cbb442662be3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/dw.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/dmaengine.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"internal.h\"\n\nstatic void dw_dma_initialize_chan(struct dw_dma_chan *dwc)\n{\n\tstruct dw_dma *dw = to_dw_dma(dwc->chan.device);\n\tu32 cfghi = is_slave_direction(dwc->direction) ? 0 : DWC_CFGH_FIFO_MODE;\n\tu32 cfglo = DWC_CFGL_CH_PRIOR(dwc->priority);\n\tbool hs_polarity = dwc->dws.hs_polarity;\n\n\tcfghi |= DWC_CFGH_DST_PER(dwc->dws.dst_id);\n\tcfghi |= DWC_CFGH_SRC_PER(dwc->dws.src_id);\n\tcfghi |= DWC_CFGH_PROTCTL(dw->pdata->protctl);\n\n\t \n\tcfglo |= hs_polarity ? DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL : 0;\n\n\tchannel_writel(dwc, CFG_LO, cfglo);\n\tchannel_writel(dwc, CFG_HI, cfghi);\n}\n\nstatic void dw_dma_suspend_chan(struct dw_dma_chan *dwc, bool drain)\n{\n\tu32 cfglo = channel_readl(dwc, CFG_LO);\n\n\tchannel_writel(dwc, CFG_LO, cfglo | DWC_CFGL_CH_SUSP);\n}\n\nstatic void dw_dma_resume_chan(struct dw_dma_chan *dwc, bool drain)\n{\n\tu32 cfglo = channel_readl(dwc, CFG_LO);\n\n\tchannel_writel(dwc, CFG_LO, cfglo & ~DWC_CFGL_CH_SUSP);\n}\n\nstatic u32 dw_dma_bytes2block(struct dw_dma_chan *dwc,\n\t\t\t      size_t bytes, unsigned int width, size_t *len)\n{\n\tu32 block;\n\n\tif ((bytes >> width) > dwc->block_size) {\n\t\tblock = dwc->block_size;\n\t\t*len = dwc->block_size << width;\n\t} else {\n\t\tblock = bytes >> width;\n\t\t*len = bytes;\n\t}\n\n\treturn block;\n}\n\nstatic size_t dw_dma_block2bytes(struct dw_dma_chan *dwc, u32 block, u32 width)\n{\n\treturn DWC_CTLH_BLOCK_TS(block) << width;\n}\n\nstatic u32 dw_dma_prepare_ctllo(struct dw_dma_chan *dwc)\n{\n\tstruct dma_slave_config\t*sconfig = &dwc->dma_sconfig;\n\tu8 smsize = (dwc->direction == DMA_DEV_TO_MEM) ? sconfig->src_maxburst : 0;\n\tu8 dmsize = (dwc->direction == DMA_MEM_TO_DEV) ? sconfig->dst_maxburst : 0;\n\tu8 p_master = dwc->dws.p_master;\n\tu8 m_master = dwc->dws.m_master;\n\tu8 dms = (dwc->direction == DMA_MEM_TO_DEV) ? p_master : m_master;\n\tu8 sms = (dwc->direction == DMA_DEV_TO_MEM) ? p_master : m_master;\n\n\treturn DWC_CTLL_LLP_D_EN | DWC_CTLL_LLP_S_EN |\n\t       DWC_CTLL_DST_MSIZE(dmsize) | DWC_CTLL_SRC_MSIZE(smsize) |\n\t       DWC_CTLL_DMS(dms) | DWC_CTLL_SMS(sms);\n}\n\nstatic void dw_dma_encode_maxburst(struct dw_dma_chan *dwc, u32 *maxburst)\n{\n\t \n\t*maxburst = *maxburst > 1 ? fls(*maxburst) - 2 : 0;\n}\n\nstatic void dw_dma_set_device_name(struct dw_dma *dw, int id)\n{\n\tsnprintf(dw->name, sizeof(dw->name), \"dw:dmac%d\", id);\n}\n\nstatic void dw_dma_disable(struct dw_dma *dw)\n{\n\tdo_dw_dma_off(dw);\n}\n\nstatic void dw_dma_enable(struct dw_dma *dw)\n{\n\tdo_dw_dma_on(dw);\n}\n\nint dw_dma_probe(struct dw_dma_chip *chip)\n{\n\tstruct dw_dma *dw;\n\n\tdw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);\n\tif (!dw)\n\t\treturn -ENOMEM;\n\n\t \n\tdw->initialize_chan = dw_dma_initialize_chan;\n\tdw->suspend_chan = dw_dma_suspend_chan;\n\tdw->resume_chan = dw_dma_resume_chan;\n\tdw->prepare_ctllo = dw_dma_prepare_ctllo;\n\tdw->encode_maxburst = dw_dma_encode_maxburst;\n\tdw->bytes2block = dw_dma_bytes2block;\n\tdw->block2bytes = dw_dma_block2bytes;\n\n\t \n\tdw->set_device_name = dw_dma_set_device_name;\n\tdw->disable = dw_dma_disable;\n\tdw->enable = dw_dma_enable;\n\n\tchip->dw = dw;\n\treturn do_dma_probe(chip);\n}\nEXPORT_SYMBOL_GPL(dw_dma_probe);\n\nint dw_dma_remove(struct dw_dma_chip *chip)\n{\n\treturn do_dma_remove(chip);\n}\nEXPORT_SYMBOL_GPL(dw_dma_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}