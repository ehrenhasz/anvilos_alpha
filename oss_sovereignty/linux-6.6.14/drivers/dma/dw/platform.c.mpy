{
  "module_name": "platform.c",
  "hash_id": "8ce45f4e69f4eecaeb082ee194982dd9483350219eefee45cee7ac2c858f8072",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/platform.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/acpi.h>\n\n#include \"internal.h\"\n\n#define DRV_NAME\t\"dw_dmac\"\n\nstatic int dw_probe(struct platform_device *pdev)\n{\n\tconst struct dw_dma_chip_pdata *match;\n\tstruct dw_dma_chip_pdata *data;\n\tstruct dw_dma_chip *chip;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tmatch = device_get_match_data(dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tdata = devm_kmemdup(&pdev->dev, match, sizeof(*match), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tif (chip->irq < 0)\n\t\treturn chip->irq;\n\n\tchip->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->regs))\n\t\treturn PTR_ERR(chip->regs);\n\n\terr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\tif (!data->pdata)\n\t\tdata->pdata = dev_get_platdata(dev);\n\tif (!data->pdata)\n\t\tdata->pdata = dw_dma_parse_dt(pdev);\n\n\tchip->dev = dev;\n\tchip->id = pdev->id;\n\tchip->pdata = data->pdata;\n\n\tdata->chip = chip;\n\n\tchip->clk = devm_clk_get_optional(chip->dev, \"hclk\");\n\tif (IS_ERR(chip->clk))\n\t\treturn PTR_ERR(chip->clk);\n\terr = clk_prepare_enable(chip->clk);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\terr = data->probe(chip);\n\tif (err)\n\t\tgoto err_dw_dma_probe;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdw_dma_of_controller_register(chip->dw);\n\n\tdw_dma_acpi_controller_register(chip->dw);\n\n\treturn 0;\n\nerr_dw_dma_probe:\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(chip->clk);\n\treturn err;\n}\n\nstatic int dw_remove(struct platform_device *pdev)\n{\n\tstruct dw_dma_chip_pdata *data = platform_get_drvdata(pdev);\n\tstruct dw_dma_chip *chip = data->chip;\n\tint ret;\n\n\tdw_dma_acpi_controller_free(chip->dw);\n\n\tdw_dma_of_controller_free(chip->dw);\n\n\tret = data->remove(chip);\n\tif (ret)\n\t\tdev_warn(chip->dev, \"can't remove device properly: %d\\n\", ret);\n\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(chip->clk);\n\n\treturn 0;\n}\n\nstatic void dw_shutdown(struct platform_device *pdev)\n{\n\tstruct dw_dma_chip_pdata *data = platform_get_drvdata(pdev);\n\tstruct dw_dma_chip *chip = data->chip;\n\n\t \n\tpm_runtime_get_sync(chip->dev);\n\tdo_dw_dma_disable(chip);\n\tpm_runtime_put_sync_suspend(chip->dev);\n\n\tclk_disable_unprepare(chip->clk);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dw_dma_of_id_table[] = {\n\t{ .compatible = \"snps,dma-spear1340\", .data = &dw_dma_chip_pdata },\n\t{ .compatible = \"renesas,rzn1-dma\", .data = &dw_dma_chip_pdata },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dw_dma_of_id_table);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id dw_dma_acpi_id_table[] = {\n\t{ \"INTL9C60\", (kernel_ulong_t)&dw_dma_chip_pdata },\n\t{ \"80862286\", (kernel_ulong_t)&dw_dma_chip_pdata },\n\t{ \"808622C0\", (kernel_ulong_t)&dw_dma_chip_pdata },\n\n\t \n\t{ \"80864BB4\", (kernel_ulong_t)&xbar_chip_pdata },\n\t{ \"80864BB5\", (kernel_ulong_t)&xbar_chip_pdata },\n\t{ \"80864BB6\", (kernel_ulong_t)&xbar_chip_pdata },\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int dw_suspend_late(struct device *dev)\n{\n\tstruct dw_dma_chip_pdata *data = dev_get_drvdata(dev);\n\tstruct dw_dma_chip *chip = data->chip;\n\n\tdo_dw_dma_disable(chip);\n\tclk_disable_unprepare(chip->clk);\n\n\treturn 0;\n}\n\nstatic int dw_resume_early(struct device *dev)\n{\n\tstruct dw_dma_chip_pdata *data = dev_get_drvdata(dev);\n\tstruct dw_dma_chip *chip = data->chip;\n\tint ret;\n\n\tret = clk_prepare_enable(chip->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn do_dw_dma_enable(chip);\n}\n\n#endif  \n\nstatic const struct dev_pm_ops dw_dev_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(dw_suspend_late, dw_resume_early)\n};\n\nstatic struct platform_driver dw_driver = {\n\t.probe\t\t= dw_probe,\n\t.remove\t\t= dw_remove,\n\t.shutdown       = dw_shutdown,\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t\t.pm\t= &dw_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(dw_dma_of_id_table),\n\t\t.acpi_match_table = ACPI_PTR(dw_dma_acpi_id_table),\n\t},\n};\n\nstatic int __init dw_init(void)\n{\n\treturn platform_driver_register(&dw_driver);\n}\nsubsys_initcall(dw_init);\n\nstatic void __exit dw_exit(void)\n{\n\tplatform_driver_unregister(&dw_driver);\n}\nmodule_exit(dw_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare DMA Controller platform driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}