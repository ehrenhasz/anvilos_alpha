{
  "module_name": "idma32.c",
  "hash_id": "62db5250e55fd71cc2740ee0572c2f919ee0e29ca5ecc75714e3250e56c7b33a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/idma32.c",
  "human_readable_source": "\n\n\n#include <linux/bitops.h>\n#include <linux/dmaengine.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"internal.h\"\n\n#define DMA_CTL_CH(x)\t\t\t(0x1000 + (x) * 4)\n#define DMA_SRC_ADDR_FILLIN(x)\t\t(0x1100 + (x) * 4)\n#define DMA_DST_ADDR_FILLIN(x)\t\t(0x1200 + (x) * 4)\n#define DMA_XBAR_SEL(x)\t\t\t(0x1300 + (x) * 4)\n#define DMA_REGACCESS_CHID_CFG\t\t(0x1400)\n\n#define CTL_CH_TRANSFER_MODE_MASK\tGENMASK(1, 0)\n#define CTL_CH_TRANSFER_MODE_S2S\t0\n#define CTL_CH_TRANSFER_MODE_S2D\t1\n#define CTL_CH_TRANSFER_MODE_D2S\t2\n#define CTL_CH_TRANSFER_MODE_D2D\t3\n#define CTL_CH_RD_RS_MASK\t\tGENMASK(4, 3)\n#define CTL_CH_WR_RS_MASK\t\tGENMASK(6, 5)\n#define CTL_CH_RD_NON_SNOOP_BIT\t\tBIT(8)\n#define CTL_CH_WR_NON_SNOOP_BIT\t\tBIT(9)\n\n#define XBAR_SEL_DEVID_MASK\t\tGENMASK(15, 0)\n#define XBAR_SEL_RX_TX_BIT\t\tBIT(16)\n#define XBAR_SEL_RX_TX_SHIFT\t\t16\n\n#define REGACCESS_CHID_MASK\t\tGENMASK(2, 0)\n\nstatic unsigned int idma32_get_slave_devfn(struct dw_dma_chan *dwc)\n{\n\tstruct device *slave = dwc->chan.slave;\n\n\tif (!slave || !dev_is_pci(slave))\n\t\treturn 0;\n\n\treturn to_pci_dev(slave)->devfn;\n}\n\nstatic void idma32_initialize_chan_xbar(struct dw_dma_chan *dwc)\n{\n\tstruct dw_dma *dw = to_dw_dma(dwc->chan.device);\n\tvoid __iomem *misc = __dw_regs(dw);\n\tu32 cfghi = 0, cfglo = 0;\n\tu8 dst_id, src_id;\n\tu32 value;\n\n\t \n\tvalue = readl(misc + DMA_REGACCESS_CHID_CFG);\n\n\tvalue &= ~REGACCESS_CHID_MASK;\n\tvalue |= dwc->chan.chan_id;\n\n\twritel(value, misc + DMA_REGACCESS_CHID_CFG);\n\n\t \n\tvalue = readl(misc + DMA_CTL_CH(dwc->chan.chan_id));\n\n\tvalue &= ~(CTL_CH_RD_NON_SNOOP_BIT | CTL_CH_WR_NON_SNOOP_BIT);\n\tvalue &= ~(CTL_CH_RD_RS_MASK | CTL_CH_WR_RS_MASK);\n\tvalue &= ~CTL_CH_TRANSFER_MODE_MASK;\n\n\tswitch (dwc->direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tvalue |= CTL_CH_TRANSFER_MODE_D2S;\n\t\tvalue |= CTL_CH_WR_NON_SNOOP_BIT;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tvalue |= CTL_CH_TRANSFER_MODE_S2D;\n\t\tvalue |= CTL_CH_RD_NON_SNOOP_BIT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\twritel(value, misc + DMA_CTL_CH(dwc->chan.chan_id));\n\n\t \n\tvalue = readl(misc + DMA_XBAR_SEL(dwc->chan.chan_id));\n\n\t \n\tvalue &= ~XBAR_SEL_DEVID_MASK;\n\tvalue |= idma32_get_slave_devfn(dwc);\n\n\tswitch (dwc->direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tvalue |= XBAR_SEL_RX_TX_BIT;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tvalue &= ~XBAR_SEL_RX_TX_BIT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\twritel(value, misc + DMA_XBAR_SEL(dwc->chan.chan_id));\n\n\t \n\tswitch (dwc->direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tdst_id = dwc->chan.chan_id;\n\t\tsrc_id = dwc->dws.src_id;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tdst_id = dwc->dws.dst_id;\n\t\tsrc_id = dwc->chan.chan_id;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tcfglo |= IDMA32C_CFGL_DST_BURST_ALIGN | IDMA32C_CFGL_SRC_BURST_ALIGN;\n\n\t \n\tcfghi |= IDMA32C_CFGH_DST_PER(dst_id & 0xf);\n\tcfghi |= IDMA32C_CFGH_SRC_PER(src_id & 0xf);\n\n\t \n\tcfghi |= IDMA32C_CFGH_DST_PER_EXT(dst_id >> 4 & 0x3);\n\tcfghi |= IDMA32C_CFGH_SRC_PER_EXT(src_id >> 4 & 0x3);\n\n\tchannel_writel(dwc, CFG_LO, cfglo);\n\tchannel_writel(dwc, CFG_HI, cfghi);\n}\n\nstatic void idma32_initialize_chan_generic(struct dw_dma_chan *dwc)\n{\n\tu32 cfghi = 0;\n\tu32 cfglo = 0;\n\n\t \n\tcfglo |= IDMA32C_CFGL_DST_BURST_ALIGN | IDMA32C_CFGL_SRC_BURST_ALIGN;\n\n\t \n\tcfghi |= IDMA32C_CFGH_DST_PER(dwc->dws.dst_id & 0xf);\n\tcfghi |= IDMA32C_CFGH_SRC_PER(dwc->dws.src_id & 0xf);\n\n\t \n\tcfghi |= IDMA32C_CFGH_DST_PER_EXT(dwc->dws.dst_id >> 4 & 0x3);\n\tcfghi |= IDMA32C_CFGH_SRC_PER_EXT(dwc->dws.src_id >> 4 & 0x3);\n\n\tchannel_writel(dwc, CFG_LO, cfglo);\n\tchannel_writel(dwc, CFG_HI, cfghi);\n}\n\nstatic void idma32_suspend_chan(struct dw_dma_chan *dwc, bool drain)\n{\n\tu32 cfglo = channel_readl(dwc, CFG_LO);\n\n\tif (drain)\n\t\tcfglo |= IDMA32C_CFGL_CH_DRAIN;\n\n\tchannel_writel(dwc, CFG_LO, cfglo | DWC_CFGL_CH_SUSP);\n}\n\nstatic void idma32_resume_chan(struct dw_dma_chan *dwc, bool drain)\n{\n\tu32 cfglo = channel_readl(dwc, CFG_LO);\n\n\tif (drain)\n\t\tcfglo &= ~IDMA32C_CFGL_CH_DRAIN;\n\n\tchannel_writel(dwc, CFG_LO, cfglo & ~DWC_CFGL_CH_SUSP);\n}\n\nstatic u32 idma32_bytes2block(struct dw_dma_chan *dwc,\n\t\t\t      size_t bytes, unsigned int width, size_t *len)\n{\n\tu32 block;\n\n\tif (bytes > dwc->block_size) {\n\t\tblock = dwc->block_size;\n\t\t*len = dwc->block_size;\n\t} else {\n\t\tblock = bytes;\n\t\t*len = bytes;\n\t}\n\n\treturn block;\n}\n\nstatic size_t idma32_block2bytes(struct dw_dma_chan *dwc, u32 block, u32 width)\n{\n\treturn IDMA32C_CTLH_BLOCK_TS(block);\n}\n\nstatic u32 idma32_prepare_ctllo(struct dw_dma_chan *dwc)\n{\n\tstruct dma_slave_config\t*sconfig = &dwc->dma_sconfig;\n\tu8 smsize = (dwc->direction == DMA_DEV_TO_MEM) ? sconfig->src_maxburst : 0;\n\tu8 dmsize = (dwc->direction == DMA_MEM_TO_DEV) ? sconfig->dst_maxburst : 0;\n\n\treturn DWC_CTLL_LLP_D_EN | DWC_CTLL_LLP_S_EN |\n\t       DWC_CTLL_DST_MSIZE(dmsize) | DWC_CTLL_SRC_MSIZE(smsize);\n}\n\nstatic void idma32_encode_maxburst(struct dw_dma_chan *dwc, u32 *maxburst)\n{\n\t*maxburst = *maxburst > 1 ? fls(*maxburst) - 1 : 0;\n}\n\nstatic void idma32_set_device_name(struct dw_dma *dw, int id)\n{\n\tsnprintf(dw->name, sizeof(dw->name), \"idma32:dmac%d\", id);\n}\n\n \nstatic void idma32_fifo_partition(struct dw_dma *dw)\n{\n\tu64 value = IDMA32C_FP_PSIZE_CH0(64) | IDMA32C_FP_PSIZE_CH1(64) |\n\t\t    IDMA32C_FP_UPDATE;\n\tu64 fifo_partition = 0;\n\n\t \n\tfifo_partition |= value << 0;\n\n\t \n\tfifo_partition |= value << 32;\n\n\t \n\tidma32_writeq(dw, FIFO_PARTITION1, fifo_partition);\n\tidma32_writeq(dw, FIFO_PARTITION0, fifo_partition);\n}\n\nstatic void idma32_disable(struct dw_dma *dw)\n{\n\tdo_dw_dma_off(dw);\n\tidma32_fifo_partition(dw);\n}\n\nstatic void idma32_enable(struct dw_dma *dw)\n{\n\tidma32_fifo_partition(dw);\n\tdo_dw_dma_on(dw);\n}\n\nint idma32_dma_probe(struct dw_dma_chip *chip)\n{\n\tstruct dw_dma *dw;\n\n\tdw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);\n\tif (!dw)\n\t\treturn -ENOMEM;\n\n\t \n\tif (chip->pdata->quirks & DW_DMA_QUIRK_XBAR_PRESENT)\n\t\tdw->initialize_chan = idma32_initialize_chan_xbar;\n\telse\n\t\tdw->initialize_chan = idma32_initialize_chan_generic;\n\tdw->suspend_chan = idma32_suspend_chan;\n\tdw->resume_chan = idma32_resume_chan;\n\tdw->prepare_ctllo = idma32_prepare_ctllo;\n\tdw->encode_maxburst = idma32_encode_maxburst;\n\tdw->bytes2block = idma32_bytes2block;\n\tdw->block2bytes = idma32_block2bytes;\n\n\t \n\tdw->set_device_name = idma32_set_device_name;\n\tdw->disable = idma32_disable;\n\tdw->enable = idma32_enable;\n\n\tchip->dw = dw;\n\treturn do_dma_probe(chip);\n}\nEXPORT_SYMBOL_GPL(idma32_dma_probe);\n\nint idma32_dma_remove(struct dw_dma_chip *chip)\n{\n\treturn do_dma_remove(chip);\n}\nEXPORT_SYMBOL_GPL(idma32_dma_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}