{
  "module_name": "of.c",
  "hash_id": "0192b9a0d601eb0ea54a73854fa062aa9563903679c31ea76d10a42e09e9fda8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/of.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n\n#include \"internal.h\"\n\nstatic struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tstruct dw_dma *dw = ofdma->of_dma_data;\n\tstruct dw_dma_slave slave = {\n\t\t.dma_dev = dw->dma.dev,\n\t};\n\tdma_cap_mask_t cap;\n\n\tif (dma_spec->args_count < 3 || dma_spec->args_count > 4)\n\t\treturn NULL;\n\n\tslave.src_id = dma_spec->args[0];\n\tslave.dst_id = dma_spec->args[0];\n\tslave.m_master = dma_spec->args[1];\n\tslave.p_master = dma_spec->args[2];\n\tif (dma_spec->args_count >= 4)\n\t\tslave.channels = dma_spec->args[3];\n\n\tif (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||\n\t\t    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||\n\t\t    slave.m_master >= dw->pdata->nr_masters ||\n\t\t    slave.p_master >= dw->pdata->nr_masters ||\n\t\t    slave.channels >= BIT(dw->pdata->nr_channels)))\n\t\treturn NULL;\n\n\tdma_cap_zero(cap);\n\tdma_cap_set(DMA_SLAVE, cap);\n\n\t \n\treturn dma_request_channel(cap, dw_dma_filter, &slave);\n}\n\nstruct dw_dma_platform_data *dw_dma_parse_dt(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct dw_dma_platform_data *pdata;\n\tu32 tmp, arr[DW_DMA_MAX_NR_MASTERS];\n\tu32 nr_masters;\n\tu32 nr_channels;\n\n\tif (of_property_read_u32(np, \"dma-masters\", &nr_masters))\n\t\treturn NULL;\n\tif (nr_masters < 1 || nr_masters > DW_DMA_MAX_NR_MASTERS)\n\t\treturn NULL;\n\n\tif (of_property_read_u32(np, \"dma-channels\", &nr_channels))\n\t\treturn NULL;\n\tif (nr_channels > DW_DMA_MAX_NR_CHANNELS)\n\t\treturn NULL;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->nr_masters = nr_masters;\n\tpdata->nr_channels = nr_channels;\n\n\tof_property_read_u32(np, \"chan_allocation_order\", &pdata->chan_allocation_order);\n\tof_property_read_u32(np, \"chan_priority\", &pdata->chan_priority);\n\n\tof_property_read_u32(np, \"block_size\", &pdata->block_size);\n\n\t \n\tif (!of_property_read_u32_array(np, \"data_width\", arr, nr_masters)) {\n\t\tfor (tmp = 0; tmp < nr_masters; tmp++)\n\t\t\tpdata->data_width[tmp] = BIT(arr[tmp] & 0x07);\n\t}\n\n\t \n\tof_property_read_u32_array(np, \"data-width\", pdata->data_width, nr_masters);\n\n\tmemset32(pdata->multi_block, 1, nr_channels);\n\tof_property_read_u32_array(np, \"multi-block\", pdata->multi_block, nr_channels);\n\n\tmemset32(pdata->max_burst, DW_DMA_MAX_BURST, nr_channels);\n\tof_property_read_u32_array(np, \"snps,max-burst-len\", pdata->max_burst, nr_channels);\n\n\tof_property_read_u32(np, \"snps,dma-protection-control\", &pdata->protctl);\n\tif (pdata->protctl > CHAN_PROTCTL_MASK)\n\t\treturn NULL;\n\n\treturn pdata;\n}\n\nvoid dw_dma_of_controller_register(struct dw_dma *dw)\n{\n\tstruct device *dev = dw->dma.dev;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn;\n\n\tret = of_dma_controller_register(dev->of_node, dw_dma_of_xlate, dw);\n\tif (ret)\n\t\tdev_err(dev, \"could not register of_dma_controller\\n\");\n}\n\nvoid dw_dma_of_controller_free(struct dw_dma *dw)\n{\n\tstruct device *dev = dw->dma.dev;\n\n\tif (!dev->of_node)\n\t\treturn;\n\n\tof_dma_controller_free(dev->of_node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}