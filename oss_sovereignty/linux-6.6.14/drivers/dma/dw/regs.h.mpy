{
  "module_name": "regs.h",
  "hash_id": "9e4fadfdc20ae25790c56a86a5f9b44c49dc88f31e00f76dc3d7ead6108375be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw/regs.h",
  "human_readable_source": " \n \n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n\n#include <linux/io-64-nonatomic-hi-lo.h>\n\n#include \"internal.h\"\n\n#define DW_DMA_MAX_NR_REQUESTS\t16\n\n \nenum dw_dma_fc {\n\tDW_DMA_FC_D_M2M,\n\tDW_DMA_FC_D_M2P,\n\tDW_DMA_FC_D_P2M,\n\tDW_DMA_FC_D_P2P,\n\tDW_DMA_FC_P_P2M,\n\tDW_DMA_FC_SP_P2P,\n\tDW_DMA_FC_P_M2P,\n\tDW_DMA_FC_DP_P2P,\n};\n\n \n#define DW_REG(name)\t\tu32 name; u32 __pad_##name\n\n \nstruct dw_dma_chan_regs {\n\tDW_REG(SAR);\t\t \n\tDW_REG(DAR);\t\t \n\tDW_REG(LLP);\t\t \n\tu32\tCTL_LO;\t\t \n\tu32\tCTL_HI;\t\t \n\tDW_REG(SSTAT);\n\tDW_REG(DSTAT);\n\tDW_REG(SSTATAR);\n\tDW_REG(DSTATAR);\n\tu32\tCFG_LO;\t\t \n\tu32\tCFG_HI;\t\t \n\tDW_REG(SGR);\n\tDW_REG(DSR);\n};\n\nstruct dw_dma_irq_regs {\n\tDW_REG(XFER);\n\tDW_REG(BLOCK);\n\tDW_REG(SRC_TRAN);\n\tDW_REG(DST_TRAN);\n\tDW_REG(ERROR);\n};\n\nstruct dw_dma_regs {\n\t \n\tstruct dw_dma_chan_regs\tCHAN[DW_DMA_MAX_NR_CHANNELS];\n\n\t \n\tstruct dw_dma_irq_regs\tRAW;\t\t \n\tstruct dw_dma_irq_regs\tSTATUS;\t\t \n\tstruct dw_dma_irq_regs\tMASK;\t\t \n\tstruct dw_dma_irq_regs\tCLEAR;\t\t \n\n\tDW_REG(STATUS_INT);\t\t\t \n\n\t \n\tDW_REG(REQ_SRC);\n\tDW_REG(REQ_DST);\n\tDW_REG(SGL_REQ_SRC);\n\tDW_REG(SGL_REQ_DST);\n\tDW_REG(LAST_SRC);\n\tDW_REG(LAST_DST);\n\n\t \n\tDW_REG(CFG);\n\tDW_REG(CH_EN);\n\tDW_REG(ID);\n\tDW_REG(TEST);\n\n\t \n\tDW_REG(CLASS_PRIORITY0);\n\tDW_REG(CLASS_PRIORITY1);\n\n\t \n\tu32\t__reserved;\n\n\t \n\tu32\tDWC_PARAMS[DW_DMA_MAX_NR_CHANNELS];\n\tu32\tMULTI_BLK_TYPE;\n\tu32\tMAX_BLK_SIZE;\n\n\t \n\tu32\tDW_PARAMS;\n\n\t \n\tu32\tCOMP_TYPE;\n\tu32\tCOMP_VERSION;\n\n\t \n\tDW_REG(FIFO_PARTITION0);\n\tDW_REG(FIFO_PARTITION1);\n\n\tDW_REG(SAI_ERR);\n\tDW_REG(GLOBAL_CFG);\n};\n\n \n#define DW_PARAMS_NR_CHAN\t8\t\t \n#define DW_PARAMS_NR_MASTER\t11\t\t \n#define DW_PARAMS_DATA_WIDTH(n)\t(15 + 2 * (n))\n#define DW_PARAMS_DATA_WIDTH1\t15\t\t \n#define DW_PARAMS_DATA_WIDTH2\t17\t\t \n#define DW_PARAMS_DATA_WIDTH3\t19\t\t \n#define DW_PARAMS_DATA_WIDTH4\t21\t\t \n#define DW_PARAMS_EN\t\t28\t\t \n\n \n#define DWC_PARAMS_MBLK_EN\t11\t\t \n#define DWC_PARAMS_HC_LLP\t13\t\t \n#define DWC_PARAMS_MSIZE\t16\t\t \n\n \nenum dw_dma_msize {\n\tDW_DMA_MSIZE_1,\n\tDW_DMA_MSIZE_4,\n\tDW_DMA_MSIZE_8,\n\tDW_DMA_MSIZE_16,\n\tDW_DMA_MSIZE_32,\n\tDW_DMA_MSIZE_64,\n\tDW_DMA_MSIZE_128,\n\tDW_DMA_MSIZE_256,\n};\n\n \n#define DWC_LLP_LMS(x)\t\t((x) & 3)\t \n#define DWC_LLP_LOC(x)\t\t((x) & ~3)\t \n\n \n#define DWC_CTLL_INT_EN\t\t(1 << 0)\t \n#define DWC_CTLL_DST_WIDTH(n)\t((n)<<1)\t \n#define DWC_CTLL_SRC_WIDTH(n)\t((n)<<4)\n#define DWC_CTLL_DST_INC\t(0<<7)\t\t \n#define DWC_CTLL_DST_DEC\t(1<<7)\n#define DWC_CTLL_DST_FIX\t(2<<7)\n#define DWC_CTLL_SRC_INC\t(0<<9)\t\t \n#define DWC_CTLL_SRC_DEC\t(1<<9)\n#define DWC_CTLL_SRC_FIX\t(2<<9)\n#define DWC_CTLL_DST_MSIZE(n)\t((n)<<11)\t \n#define DWC_CTLL_SRC_MSIZE(n)\t((n)<<14)\n#define DWC_CTLL_S_GATH_EN\t(1 << 17)\t \n#define DWC_CTLL_D_SCAT_EN\t(1 << 18)\t \n#define DWC_CTLL_FC(n)\t\t((n) << 20)\n#define DWC_CTLL_FC_M2M\t\t(0 << 20)\t \n#define DWC_CTLL_FC_M2P\t\t(1 << 20)\t \n#define DWC_CTLL_FC_P2M\t\t(2 << 20)\t \n#define DWC_CTLL_FC_P2P\t\t(3 << 20)\t \n \n#define DWC_CTLL_DMS(n)\t\t((n)<<23)\t \n#define DWC_CTLL_SMS(n)\t\t((n)<<25)\t \n#define DWC_CTLL_LLP_D_EN\t(1 << 27)\t \n#define DWC_CTLL_LLP_S_EN\t(1 << 28)\t \n\n \n#define DWC_CTLH_BLOCK_TS_MASK\tGENMASK(11, 0)\n#define DWC_CTLH_BLOCK_TS(x)\t((x) & DWC_CTLH_BLOCK_TS_MASK)\n#define DWC_CTLH_DONE\t\t(1 << 12)\n\n \n#define DWC_CFGL_CH_PRIOR_MASK\t(0x7 << 5)\t \n#define DWC_CFGL_CH_PRIOR(x)\t((x) << 5)\t \n#define DWC_CFGL_CH_SUSP\t(1 << 8)\t \n#define DWC_CFGL_FIFO_EMPTY\t(1 << 9)\t \n#define DWC_CFGL_HS_DST\t\t(1 << 10)\t \n#define DWC_CFGL_HS_SRC\t\t(1 << 11)\t \n#define DWC_CFGL_LOCK_CH_XFER\t(0 << 12)\t \n#define DWC_CFGL_LOCK_CH_BLOCK\t(1 << 12)\n#define DWC_CFGL_LOCK_CH_XACT\t(2 << 12)\n#define DWC_CFGL_LOCK_BUS_XFER\t(0 << 14)\t \n#define DWC_CFGL_LOCK_BUS_BLOCK\t(1 << 14)\n#define DWC_CFGL_LOCK_BUS_XACT\t(2 << 14)\n#define DWC_CFGL_LOCK_CH\t(1 << 15)\t \n#define DWC_CFGL_LOCK_BUS\t(1 << 16)\t \n#define DWC_CFGL_HS_DST_POL\t(1 << 18)\t \n#define DWC_CFGL_HS_SRC_POL\t(1 << 19)\t \n#define DWC_CFGL_MAX_BURST(x)\t((x) << 20)\n#define DWC_CFGL_RELOAD_SAR\t(1 << 30)\n#define DWC_CFGL_RELOAD_DAR\t(1 << 31)\n\n \n#define DWC_CFGH_FCMODE\t\t(1 << 0)\n#define DWC_CFGH_FIFO_MODE\t(1 << 1)\n#define DWC_CFGH_PROTCTL(x)\t((x) << 2)\n#define DWC_CFGH_PROTCTL_DATA\t(0 << 2)\t \n#define DWC_CFGH_PROTCTL_PRIV\t(1 << 2)\t \n#define DWC_CFGH_PROTCTL_BUFFER\t(2 << 2)\t \n#define DWC_CFGH_PROTCTL_CACHE\t(4 << 2)\t \n#define DWC_CFGH_DS_UPD_EN\t(1 << 5)\n#define DWC_CFGH_SS_UPD_EN\t(1 << 6)\n#define DWC_CFGH_SRC_PER(x)\t((x) << 7)\n#define DWC_CFGH_DST_PER(x)\t((x) << 11)\n\n \n#define DWC_SGR_SGI(x)\t\t((x) << 0)\n#define DWC_SGR_SGC(x)\t\t((x) << 20)\n\n \n#define DWC_DSR_DSI(x)\t\t((x) << 0)\n#define DWC_DSR_DSC(x)\t\t((x) << 20)\n\n \n#define DW_CFG_DMA_EN\t\t(1 << 0)\n\n \n\n \nenum idma32_msize {\n\tIDMA32_MSIZE_1,\n\tIDMA32_MSIZE_2,\n\tIDMA32_MSIZE_4,\n\tIDMA32_MSIZE_8,\n\tIDMA32_MSIZE_16,\n\tIDMA32_MSIZE_32,\n};\n\n \n#define IDMA32C_CTLH_BLOCK_TS_MASK\tGENMASK(16, 0)\n#define IDMA32C_CTLH_BLOCK_TS(x)\t((x) & IDMA32C_CTLH_BLOCK_TS_MASK)\n#define IDMA32C_CTLH_DONE\t\t(1 << 17)\n\n \n#define IDMA32C_CFGL_DST_BURST_ALIGN\t(1 << 0)\t \n#define IDMA32C_CFGL_SRC_BURST_ALIGN\t(1 << 1)\t \n#define IDMA32C_CFGL_CH_DRAIN\t\t(1 << 10)\t \n#define IDMA32C_CFGL_DST_OPT_BL\t\t(1 << 20)\t \n#define IDMA32C_CFGL_SRC_OPT_BL\t\t(1 << 21)\t \n\n \n#define IDMA32C_CFGH_SRC_PER(x)\t\t((x) << 0)\n#define IDMA32C_CFGH_DST_PER(x)\t\t((x) << 4)\n#define IDMA32C_CFGH_RD_ISSUE_THD(x)\t((x) << 8)\n#define IDMA32C_CFGH_RW_ISSUE_THD(x)\t((x) << 18)\n#define IDMA32C_CFGH_SRC_PER_EXT(x)\t((x) << 28)\t \n#define IDMA32C_CFGH_DST_PER_EXT(x)\t((x) << 30)\t \n\n \n#define IDMA32C_FP_PSIZE_CH0(x)\t\t((x) << 0)\n#define IDMA32C_FP_PSIZE_CH1(x)\t\t((x) << 13)\n#define IDMA32C_FP_UPDATE\t\t(1 << 26)\n\nenum dw_dmac_flags {\n\tDW_DMA_IS_CYCLIC = 0,\n\tDW_DMA_IS_SOFT_LLP = 1,\n\tDW_DMA_IS_PAUSED = 2,\n\tDW_DMA_IS_INITIALIZED = 3,\n};\n\nstruct dw_dma_chan {\n\tstruct dma_chan\t\t\tchan;\n\tvoid __iomem\t\t\t*ch_regs;\n\tu8\t\t\t\tmask;\n\tu8\t\t\t\tpriority;\n\tenum dma_transfer_direction\tdirection;\n\n\t \n\tstruct list_head\t*tx_node_active;\n\n\tspinlock_t\t\tlock;\n\n\t \n\tunsigned long\t\tflags;\n\tstruct list_head\tactive_list;\n\tstruct list_head\tqueue;\n\n\tunsigned int\t\tdescs_allocated;\n\n\t \n\tunsigned int\t\tblock_size;\n\tbool\t\t\tnollp;\n\tu32\t\t\tmax_burst;\n\n\t \n\tstruct dw_dma_slave\tdws;\n\n\t \n\tstruct dma_slave_config dma_sconfig;\n};\n\nstatic inline struct dw_dma_chan_regs __iomem *\n__dwc_regs(struct dw_dma_chan *dwc)\n{\n\treturn dwc->ch_regs;\n}\n\n#define channel_readl(dwc, name) \\\n\treadl(&(__dwc_regs(dwc)->name))\n#define channel_writel(dwc, name, val) \\\n\twritel((val), &(__dwc_regs(dwc)->name))\n\nstatic inline struct dw_dma_chan *to_dw_dma_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct dw_dma_chan, chan);\n}\n\nstruct dw_dma {\n\tstruct dma_device\tdma;\n\tchar\t\t\tname[20];\n\tvoid __iomem\t\t*regs;\n\tstruct dma_pool\t\t*desc_pool;\n\tstruct tasklet_struct\ttasklet;\n\n\t \n\tstruct dw_dma_chan\t*chan;\n\tu8\t\t\tall_chan_mask;\n\tu8\t\t\tin_use;\n\n\t \n\tvoid\t(*initialize_chan)(struct dw_dma_chan *dwc);\n\tvoid\t(*suspend_chan)(struct dw_dma_chan *dwc, bool drain);\n\tvoid\t(*resume_chan)(struct dw_dma_chan *dwc, bool drain);\n\tu32\t(*prepare_ctllo)(struct dw_dma_chan *dwc);\n\tvoid\t(*encode_maxburst)(struct dw_dma_chan *dwc, u32 *maxburst);\n\tu32\t(*bytes2block)(struct dw_dma_chan *dwc, size_t bytes,\n\t\t\t       unsigned int width, size_t *len);\n\tsize_t\t(*block2bytes)(struct dw_dma_chan *dwc, u32 block, u32 width);\n\n\t \n\tvoid (*set_device_name)(struct dw_dma *dw, int id);\n\tvoid (*disable)(struct dw_dma *dw);\n\tvoid (*enable)(struct dw_dma *dw);\n\n\t \n\tstruct dw_dma_platform_data\t*pdata;\n};\n\nstatic inline struct dw_dma_regs __iomem *__dw_regs(struct dw_dma *dw)\n{\n\treturn dw->regs;\n}\n\n#define dma_readl(dw, name) \\\n\treadl(&(__dw_regs(dw)->name))\n#define dma_writel(dw, name, val) \\\n\twritel((val), &(__dw_regs(dw)->name))\n\n#define idma32_readq(dw, name)\t\t\t\t\\\n\thi_lo_readq(&(__dw_regs(dw)->name))\n#define idma32_writeq(dw, name, val)\t\t\t\\\n\thi_lo_writeq((val), &(__dw_regs(dw)->name))\n\n#define channel_set_bit(dw, reg, mask) \\\n\tdma_writel(dw, reg, ((mask) << 8) | (mask))\n#define channel_clear_bit(dw, reg, mask) \\\n\tdma_writel(dw, reg, ((mask) << 8) | 0)\n\nstatic inline struct dw_dma *to_dw_dma(struct dma_device *ddev)\n{\n\treturn container_of(ddev, struct dw_dma, dma);\n}\n\n \nstruct dw_lli {\n\t \n\t__le32\t\tsar;\n\t__le32\t\tdar;\n\t__le32\t\tllp;\t\t \n\t__le32\t\tctllo;\n\t \n\t__le32\t\tctlhi;\n\t \n\t__le32\t\tsstat;\n\t__le32\t\tdstat;\n};\n\nstruct dw_desc {\n\t \n\tstruct dw_lli\t\t\tlli;\n\n#define lli_set(d, reg, v)\t\t((d)->lli.reg |= cpu_to_le32(v))\n#define lli_clear(d, reg, v)\t\t((d)->lli.reg &= ~cpu_to_le32(v))\n#define lli_read(d, reg)\t\tle32_to_cpu((d)->lli.reg)\n#define lli_write(d, reg, v)\t\t((d)->lli.reg = cpu_to_le32(v))\n\n\t \n\tstruct list_head\t\tdesc_node;\n\tstruct list_head\t\ttx_list;\n\tstruct dma_async_tx_descriptor\ttxd;\n\tsize_t\t\t\t\tlen;\n\tsize_t\t\t\t\ttotal_len;\n\tu32\t\t\t\tresidue;\n};\n\n#define to_dw_desc(h)\tlist_entry(h, struct dw_desc, desc_node)\n\nstatic inline struct dw_desc *\ntxd_to_dw_desc(struct dma_async_tx_descriptor *txd)\n{\n\treturn container_of(txd, struct dw_desc, txd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}