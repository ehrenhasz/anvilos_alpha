{
  "module_name": "mv_xor_v2.c",
  "hash_id": "5acdac0bf6767790655d8f514703f533ce523d8f75ebac0940dccb6e05d0d5e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/mv_xor_v2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include \"dmaengine.h\"\n\n \n#define MV_XOR_V2_DMA_DESQ_BALR_OFF\t\t\t0x000\n#define MV_XOR_V2_DMA_DESQ_BAHR_OFF\t\t\t0x004\n#define MV_XOR_V2_DMA_DESQ_SIZE_OFF\t\t\t0x008\n#define MV_XOR_V2_DMA_DESQ_DONE_OFF\t\t\t0x00C\n#define   MV_XOR_V2_DMA_DESQ_DONE_PENDING_MASK\t\t0x7FFF\n#define   MV_XOR_V2_DMA_DESQ_DONE_PENDING_SHIFT\t\t0\n#define   MV_XOR_V2_DMA_DESQ_DONE_READ_PTR_MASK\t\t0x1FFF\n#define   MV_XOR_V2_DMA_DESQ_DONE_READ_PTR_SHIFT\t16\n#define MV_XOR_V2_DMA_DESQ_ARATTR_OFF\t\t\t0x010\n#define   MV_XOR_V2_DMA_DESQ_ATTR_CACHE_MASK\t\t0x3F3F\n#define   MV_XOR_V2_DMA_DESQ_ATTR_OUTER_SHAREABLE\t0x202\n#define   MV_XOR_V2_DMA_DESQ_ATTR_CACHEABLE\t\t0x3C3C\n#define MV_XOR_V2_DMA_IMSG_CDAT_OFF\t\t\t0x014\n#define MV_XOR_V2_DMA_IMSG_THRD_OFF\t\t\t0x018\n#define   MV_XOR_V2_DMA_IMSG_THRD_MASK\t\t\t0x7FFF\n#define   MV_XOR_V2_DMA_IMSG_TIMER_EN\t\t\tBIT(18)\n#define MV_XOR_V2_DMA_DESQ_AWATTR_OFF\t\t\t0x01C\n   \n#define MV_XOR_V2_DMA_DESQ_ALLOC_OFF\t\t\t0x04C\n#define   MV_XOR_V2_DMA_DESQ_ALLOC_WRPTR_MASK\t\t0xFFFF\n#define   MV_XOR_V2_DMA_DESQ_ALLOC_WRPTR_SHIFT\t\t16\n#define MV_XOR_V2_DMA_IMSG_BALR_OFF\t\t\t0x050\n#define MV_XOR_V2_DMA_IMSG_BAHR_OFF\t\t\t0x054\n#define MV_XOR_V2_DMA_DESQ_CTRL_OFF\t\t\t0x100\n#define\t  MV_XOR_V2_DMA_DESQ_CTRL_32B\t\t\t1\n#define   MV_XOR_V2_DMA_DESQ_CTRL_128B\t\t\t7\n#define MV_XOR_V2_DMA_DESQ_STOP_OFF\t\t\t0x800\n#define MV_XOR_V2_DMA_DESQ_DEALLOC_OFF\t\t\t0x804\n#define MV_XOR_V2_DMA_DESQ_ADD_OFF\t\t\t0x808\n#define MV_XOR_V2_DMA_IMSG_TMOT\t\t\t\t0x810\n#define   MV_XOR_V2_DMA_IMSG_TIMER_THRD_MASK\t\t0x1FFF\n\n \n#define MV_XOR_V2_GLOB_BW_CTRL\t\t\t\t0x4\n#define   MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_RD_SHIFT\t0\n#define   MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_RD_VAL\t64\n#define   MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_WR_SHIFT\t8\n#define   MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_WR_VAL\t8\n#define   MV_XOR_V2_GLOB_BW_CTRL_RD_BURST_LEN_SHIFT\t12\n#define   MV_XOR_V2_GLOB_BW_CTRL_RD_BURST_LEN_VAL\t4\n#define   MV_XOR_V2_GLOB_BW_CTRL_WR_BURST_LEN_SHIFT\t16\n#define\t  MV_XOR_V2_GLOB_BW_CTRL_WR_BURST_LEN_VAL\t4\n#define MV_XOR_V2_GLOB_PAUSE\t\t\t\t0x014\n#define   MV_XOR_V2_GLOB_PAUSE_AXI_TIME_DIS_VAL\t\t0x8\n#define MV_XOR_V2_GLOB_SYS_INT_CAUSE\t\t\t0x200\n#define MV_XOR_V2_GLOB_SYS_INT_MASK\t\t\t0x204\n#define MV_XOR_V2_GLOB_MEM_INT_CAUSE\t\t\t0x220\n#define MV_XOR_V2_GLOB_MEM_INT_MASK\t\t\t0x224\n\n#define MV_XOR_V2_MIN_DESC_SIZE\t\t\t\t32\n#define MV_XOR_V2_EXT_DESC_SIZE\t\t\t\t128\n\n#define MV_XOR_V2_DESC_RESERVED_SIZE\t\t\t12\n#define MV_XOR_V2_DESC_BUFF_D_ADDR_SIZE\t\t\t12\n\n#define MV_XOR_V2_CMD_LINE_NUM_MAX_D_BUF\t\t8\n\n \n#define MV_XOR_V2_DESC_NUM\t\t\t\t1024\n\n \n#define MV_XOR_V2_DONE_IMSG_THRD  0x14\n#define MV_XOR_V2_TIMER_THRD      0xB0\n\n \nstruct mv_xor_v2_descriptor {\n\tu16 desc_id;\n\tu16 flags;\n\tu32 crc32_result;\n\tu32 desc_ctrl;\n\n\t \n#define DESC_NUM_ACTIVE_D_BUF_SHIFT\t22\n#define DESC_OP_MODE_SHIFT\t\t28\n#define DESC_OP_MODE_NOP\t\t0\t \n#define DESC_OP_MODE_MEMCPY\t\t1\t \n#define DESC_OP_MODE_MEMSET\t\t2\t \n#define DESC_OP_MODE_MEMINIT\t\t3\t \n#define DESC_OP_MODE_MEM_COMPARE\t4\t \n#define DESC_OP_MODE_CRC32\t\t5\t \n#define DESC_OP_MODE_XOR\t\t6\t \n#define DESC_OP_MODE_RAID6\t\t7\t \n#define DESC_OP_MODE_RAID6_REC\t\t8\t \n#define DESC_Q_BUFFER_ENABLE\t\tBIT(16)\n#define DESC_P_BUFFER_ENABLE\t\tBIT(17)\n#define DESC_IOD\t\t\tBIT(27)\n\n\tu32 buff_size;\n\tu32 fill_pattern_src_addr[4];\n\tu32 data_buff_addr[MV_XOR_V2_DESC_BUFF_D_ADDR_SIZE];\n\tu32 reserved[MV_XOR_V2_DESC_RESERVED_SIZE];\n};\n\n \nstruct mv_xor_v2_device {\n\tspinlock_t lock;\n\tvoid __iomem *dma_base;\n\tvoid __iomem *glob_base;\n\tstruct clk *clk;\n\tstruct clk *reg_clk;\n\tstruct tasklet_struct irq_tasklet;\n\tstruct list_head free_sw_desc;\n\tstruct dma_device dmadev;\n\tstruct dma_chan\tdmachan;\n\tdma_addr_t hw_desq;\n\tstruct mv_xor_v2_descriptor *hw_desq_virt;\n\tstruct mv_xor_v2_sw_desc *sw_desq;\n\tint desc_size;\n\tunsigned int npendings;\n\tunsigned int hw_queue_idx;\n\tunsigned int irq;\n};\n\n \nstruct mv_xor_v2_sw_desc {\n\tint idx;\n\tstruct dma_async_tx_descriptor async_tx;\n\tstruct mv_xor_v2_descriptor hw_desc;\n\tstruct list_head free_list;\n};\n\n \nstatic void mv_xor_v2_set_data_buffers(struct mv_xor_v2_device *xor_dev,\n\t\t\t\t\tstruct mv_xor_v2_descriptor *desc,\n\t\t\t\t\tdma_addr_t src, int index)\n{\n\tint arr_index = ((index >> 1) * 3);\n\n\t \n\tif ((index & 0x1) == 0) {\n\t\tdesc->data_buff_addr[arr_index] = lower_32_bits(src);\n\n\t\tdesc->data_buff_addr[arr_index + 2] &= ~0xFFFF;\n\t\tdesc->data_buff_addr[arr_index + 2] |=\n\t\t\tupper_32_bits(src) & 0xFFFF;\n\t} else {\n\t\tdesc->data_buff_addr[arr_index + 1] =\n\t\t\tlower_32_bits(src);\n\n\t\tdesc->data_buff_addr[arr_index + 2] &= ~0xFFFF0000;\n\t\tdesc->data_buff_addr[arr_index + 2] |=\n\t\t\t(upper_32_bits(src) & 0xFFFF) << 16;\n\t}\n}\n\n \nstatic void mv_xor_v2_add_desc_to_desq(struct mv_xor_v2_device *xor_dev,\n\t\t\t\t       int num_of_desc)\n{\n\t \n\twritel(num_of_desc, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_ADD_OFF);\n}\n\n \nstatic void mv_xor_v2_free_desc_from_desq(struct mv_xor_v2_device *xor_dev,\n\t\t\t\t\t  int num_of_desc)\n{\n\t \n\twritel(num_of_desc, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_DEALLOC_OFF);\n}\n\n \nstatic int mv_xor_v2_set_desc_size(struct mv_xor_v2_device *xor_dev)\n{\n\twritel(MV_XOR_V2_DMA_DESQ_CTRL_128B,\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_CTRL_OFF);\n\n\treturn MV_XOR_V2_EXT_DESC_SIZE;\n}\n\n \nstatic inline\nvoid mv_xor_v2_enable_imsg_thrd(struct mv_xor_v2_device *xor_dev)\n{\n\tu32 reg;\n\n\t \n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_THRD_OFF);\n\treg &= ~MV_XOR_V2_DMA_IMSG_THRD_MASK;\n\treg |= MV_XOR_V2_DONE_IMSG_THRD;\n\treg |= MV_XOR_V2_DMA_IMSG_TIMER_EN;\n\twritel(reg, xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_THRD_OFF);\n\n\t \n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_TMOT);\n\treg &= ~MV_XOR_V2_DMA_IMSG_TIMER_THRD_MASK;\n\treg |= MV_XOR_V2_TIMER_THRD;\n\twritel(reg, xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_TMOT);\n}\n\nstatic irqreturn_t mv_xor_v2_interrupt_handler(int irq, void *data)\n{\n\tstruct mv_xor_v2_device *xor_dev = data;\n\tunsigned int ndescs;\n\tu32 reg;\n\n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_DONE_OFF);\n\n\tndescs = ((reg >> MV_XOR_V2_DMA_DESQ_DONE_PENDING_SHIFT) &\n\t\t  MV_XOR_V2_DMA_DESQ_DONE_PENDING_MASK);\n\n\t \n\tif (!ndescs)\n\t\treturn IRQ_NONE;\n\n\t \n\ttasklet_schedule(&xor_dev->irq_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic dma_cookie_t\nmv_xor_v2_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tvoid *dest_hw_desc;\n\tdma_cookie_t cookie;\n\tstruct mv_xor_v2_sw_desc *sw_desc =\n\t\tcontainer_of(tx, struct mv_xor_v2_sw_desc, async_tx);\n\tstruct mv_xor_v2_device *xor_dev =\n\t\tcontainer_of(tx->chan, struct mv_xor_v2_device, dmachan);\n\n\tdev_dbg(xor_dev->dmadev.dev,\n\t\t\"%s sw_desc %p: async_tx %p\\n\",\n\t\t__func__, sw_desc, &sw_desc->async_tx);\n\n\t \n\tspin_lock_bh(&xor_dev->lock);\n\tcookie = dma_cookie_assign(tx);\n\n\t \n\tdest_hw_desc = xor_dev->hw_desq_virt + xor_dev->hw_queue_idx;\n\n\tmemcpy(dest_hw_desc, &sw_desc->hw_desc, xor_dev->desc_size);\n\n\txor_dev->npendings++;\n\txor_dev->hw_queue_idx++;\n\tif (xor_dev->hw_queue_idx >= MV_XOR_V2_DESC_NUM)\n\t\txor_dev->hw_queue_idx = 0;\n\n\tspin_unlock_bh(&xor_dev->lock);\n\n\treturn cookie;\n}\n\n \nstatic struct mv_xor_v2_sw_desc\t*\nmv_xor_v2_prep_sw_desc(struct mv_xor_v2_device *xor_dev)\n{\n\tstruct mv_xor_v2_sw_desc *sw_desc;\n\tbool found = false;\n\n\t \n\tspin_lock_bh(&xor_dev->lock);\n\n\tif (list_empty(&xor_dev->free_sw_desc)) {\n\t\tspin_unlock_bh(&xor_dev->lock);\n\t\t \n\t\ttasklet_schedule(&xor_dev->irq_tasklet);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(sw_desc, &xor_dev->free_sw_desc, free_list) {\n\t\tif (async_tx_test_ack(&sw_desc->async_tx)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tspin_unlock_bh(&xor_dev->lock);\n\t\treturn NULL;\n\t}\n\n\tlist_del(&sw_desc->free_list);\n\n\t \n\tspin_unlock_bh(&xor_dev->lock);\n\n\treturn sw_desc;\n}\n\n \nstatic struct dma_async_tx_descriptor *\nmv_xor_v2_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest,\n\t\t\t  dma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct mv_xor_v2_sw_desc *sw_desc;\n\tstruct mv_xor_v2_descriptor *hw_descriptor;\n\tstruct mv_xor_v2_device\t*xor_dev;\n\n\txor_dev = container_of(chan, struct mv_xor_v2_device, dmachan);\n\n\tdev_dbg(xor_dev->dmadev.dev,\n\t\t\"%s len: %zu src %pad dest %pad flags: %ld\\n\",\n\t\t__func__, len, &src, &dest, flags);\n\n\tsw_desc = mv_xor_v2_prep_sw_desc(xor_dev);\n\tif (!sw_desc)\n\t\treturn NULL;\n\n\tsw_desc->async_tx.flags = flags;\n\n\t \n\thw_descriptor = &sw_desc->hw_desc;\n\n\t \n\thw_descriptor->desc_id = sw_desc->idx;\n\n\t \n\thw_descriptor->desc_ctrl =\n\t\tDESC_OP_MODE_MEMCPY << DESC_OP_MODE_SHIFT;\n\n\tif (flags & DMA_PREP_INTERRUPT)\n\t\thw_descriptor->desc_ctrl |= DESC_IOD;\n\n\t \n\thw_descriptor->fill_pattern_src_addr[0] = lower_32_bits(src);\n\thw_descriptor->fill_pattern_src_addr[1] =\n\t\tupper_32_bits(src) & 0xFFFF;\n\n\t \n\thw_descriptor->fill_pattern_src_addr[2] = lower_32_bits(dest);\n\thw_descriptor->fill_pattern_src_addr[3] =\n\t\tupper_32_bits(dest) & 0xFFFF;\n\n\t \n\thw_descriptor->buff_size = len;\n\n\t \n\treturn &sw_desc->async_tx;\n}\n\n \nstatic struct dma_async_tx_descriptor *\nmv_xor_v2_prep_dma_xor(struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,\n\t\t       unsigned int src_cnt, size_t len, unsigned long flags)\n{\n\tstruct mv_xor_v2_sw_desc *sw_desc;\n\tstruct mv_xor_v2_descriptor *hw_descriptor;\n\tstruct mv_xor_v2_device\t*xor_dev =\n\t\tcontainer_of(chan, struct mv_xor_v2_device, dmachan);\n\tint i;\n\n\tif (src_cnt > MV_XOR_V2_CMD_LINE_NUM_MAX_D_BUF || src_cnt < 1)\n\t\treturn NULL;\n\n\tdev_dbg(xor_dev->dmadev.dev,\n\t\t\"%s src_cnt: %d len: %zu dest %pad flags: %ld\\n\",\n\t\t__func__, src_cnt, len, &dest, flags);\n\n\tsw_desc = mv_xor_v2_prep_sw_desc(xor_dev);\n\tif (!sw_desc)\n\t\treturn NULL;\n\n\tsw_desc->async_tx.flags = flags;\n\n\t \n\thw_descriptor = &sw_desc->hw_desc;\n\n\t \n\thw_descriptor->desc_id = sw_desc->idx;\n\n\t \n\thw_descriptor->desc_ctrl =\n\t\tDESC_OP_MODE_XOR << DESC_OP_MODE_SHIFT;\n\thw_descriptor->desc_ctrl |= DESC_P_BUFFER_ENABLE;\n\n\tif (flags & DMA_PREP_INTERRUPT)\n\t\thw_descriptor->desc_ctrl |= DESC_IOD;\n\n\t \n\tfor (i = 0; i < src_cnt; i++)\n\t\tmv_xor_v2_set_data_buffers(xor_dev, hw_descriptor, src[i], i);\n\n\thw_descriptor->desc_ctrl |=\n\t\tsrc_cnt << DESC_NUM_ACTIVE_D_BUF_SHIFT;\n\n\t \n\thw_descriptor->fill_pattern_src_addr[2] = lower_32_bits(dest);\n\thw_descriptor->fill_pattern_src_addr[3] =\n\t\tupper_32_bits(dest) & 0xFFFF;\n\n\t \n\thw_descriptor->buff_size = len;\n\n\t \n\treturn &sw_desc->async_tx;\n}\n\n \nstatic struct dma_async_tx_descriptor *\nmv_xor_v2_prep_dma_interrupt(struct dma_chan *chan, unsigned long flags)\n{\n\tstruct mv_xor_v2_sw_desc *sw_desc;\n\tstruct mv_xor_v2_descriptor *hw_descriptor;\n\tstruct mv_xor_v2_device\t*xor_dev =\n\t\tcontainer_of(chan, struct mv_xor_v2_device, dmachan);\n\n\tsw_desc = mv_xor_v2_prep_sw_desc(xor_dev);\n\tif (!sw_desc)\n\t\treturn NULL;\n\n\t \n\thw_descriptor = &sw_desc->hw_desc;\n\n\t \n\thw_descriptor->desc_id = sw_desc->idx;\n\n\t \n\thw_descriptor->desc_ctrl =\n\t\tDESC_OP_MODE_NOP << DESC_OP_MODE_SHIFT;\n\thw_descriptor->desc_ctrl |= DESC_IOD;\n\n\t \n\treturn &sw_desc->async_tx;\n}\n\n \nstatic void mv_xor_v2_issue_pending(struct dma_chan *chan)\n{\n\tstruct mv_xor_v2_device *xor_dev =\n\t\tcontainer_of(chan, struct mv_xor_v2_device, dmachan);\n\n\tspin_lock_bh(&xor_dev->lock);\n\n\t \n\tmv_xor_v2_add_desc_to_desq(xor_dev, xor_dev->npendings);\n\txor_dev->npendings = 0;\n\n\tspin_unlock_bh(&xor_dev->lock);\n}\n\nstatic inline\nint mv_xor_v2_get_pending_params(struct mv_xor_v2_device *xor_dev,\n\t\t\t\t int *pending_ptr)\n{\n\tu32 reg;\n\n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_DONE_OFF);\n\n\t \n\t*pending_ptr = ((reg >> MV_XOR_V2_DMA_DESQ_DONE_READ_PTR_SHIFT) &\n\t\t\tMV_XOR_V2_DMA_DESQ_DONE_READ_PTR_MASK);\n\n\t \n\treturn ((reg >> MV_XOR_V2_DMA_DESQ_DONE_PENDING_SHIFT) &\n\t\tMV_XOR_V2_DMA_DESQ_DONE_PENDING_MASK);\n}\n\n \nstatic void mv_xor_v2_tasklet(struct tasklet_struct *t)\n{\n\tstruct mv_xor_v2_device *xor_dev = from_tasklet(xor_dev, t,\n\t\t\t\t\t\t\tirq_tasklet);\n\tint pending_ptr, num_of_pending, i;\n\tstruct mv_xor_v2_sw_desc *next_pending_sw_desc = NULL;\n\n\tdev_dbg(xor_dev->dmadev.dev, \"%s %d\\n\", __func__, __LINE__);\n\n\t \n\tnum_of_pending = mv_xor_v2_get_pending_params(xor_dev, &pending_ptr);\n\n\t \n\tfor (i = 0; i < num_of_pending; i++) {\n\t\tstruct mv_xor_v2_descriptor *next_pending_hw_desc =\n\t\t\txor_dev->hw_desq_virt + pending_ptr;\n\n\t\t \n\t\tnext_pending_sw_desc =\n\t\t\t&xor_dev->sw_desq[next_pending_hw_desc->desc_id];\n\n\t\t \n\t\tif (next_pending_sw_desc->async_tx.cookie > 0) {\n\t\t\t \n\t\t\tdma_cookie_complete(&next_pending_sw_desc->async_tx);\n\n\t\t\tdma_descriptor_unmap(&next_pending_sw_desc->async_tx);\n\t\t\tdmaengine_desc_get_callback_invoke(\n\t\t\t\t\t&next_pending_sw_desc->async_tx, NULL);\n\t\t}\n\n\t\tdma_run_dependencies(&next_pending_sw_desc->async_tx);\n\n\t\t \n\t\tspin_lock(&xor_dev->lock);\n\n\t\t \n\t\tlist_add(&next_pending_sw_desc->free_list,\n\t\t\t &xor_dev->free_sw_desc);\n\n\t\t \n\t\tspin_unlock(&xor_dev->lock);\n\n\t\t \n\t\tpending_ptr++;\n\t\tif (pending_ptr >= MV_XOR_V2_DESC_NUM)\n\t\t\tpending_ptr = 0;\n\t}\n\n\tif (num_of_pending != 0) {\n\t\t \n\t\tmv_xor_v2_free_desc_from_desq(xor_dev, num_of_pending);\n\t}\n}\n\n \nstatic void mv_xor_v2_set_msi_msg(struct msi_desc *desc, struct msi_msg *msg)\n{\n\tstruct mv_xor_v2_device *xor_dev = dev_get_drvdata(desc->dev);\n\n\twritel(msg->address_lo,\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_BALR_OFF);\n\twritel(msg->address_hi & 0xFFFF,\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_BAHR_OFF);\n\twritel(msg->data,\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_IMSG_CDAT_OFF);\n}\n\nstatic int mv_xor_v2_descq_init(struct mv_xor_v2_device *xor_dev)\n{\n\tu32 reg;\n\n\t \n\twritel(MV_XOR_V2_DESC_NUM,\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_SIZE_OFF);\n\n\t \n\twritel(lower_32_bits(xor_dev->hw_desq),\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_BALR_OFF);\n\twritel(upper_32_bits(xor_dev->hw_desq),\n\t       xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_BAHR_OFF);\n\n\t \n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_ARATTR_OFF);\n\treg &= ~MV_XOR_V2_DMA_DESQ_ATTR_CACHE_MASK;\n\treg |= MV_XOR_V2_DMA_DESQ_ATTR_OUTER_SHAREABLE |\n\t\tMV_XOR_V2_DMA_DESQ_ATTR_CACHEABLE;\n\twritel(reg, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_ARATTR_OFF);\n\n\treg = readl(xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_AWATTR_OFF);\n\treg &= ~MV_XOR_V2_DMA_DESQ_ATTR_CACHE_MASK;\n\treg |= MV_XOR_V2_DMA_DESQ_ATTR_OUTER_SHAREABLE |\n\t\tMV_XOR_V2_DMA_DESQ_ATTR_CACHEABLE;\n\twritel(reg, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_AWATTR_OFF);\n\n\t \n\treg = ((MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_RD_VAL <<\n\t\tMV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_RD_SHIFT) |\n\t       (MV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_WR_VAL  <<\n\t\tMV_XOR_V2_GLOB_BW_CTRL_NUM_OSTD_WR_SHIFT) |\n\t       (MV_XOR_V2_GLOB_BW_CTRL_RD_BURST_LEN_VAL <<\n\t\tMV_XOR_V2_GLOB_BW_CTRL_RD_BURST_LEN_SHIFT) |\n\t       (MV_XOR_V2_GLOB_BW_CTRL_WR_BURST_LEN_VAL <<\n\t\tMV_XOR_V2_GLOB_BW_CTRL_WR_BURST_LEN_SHIFT));\n\twritel(reg, xor_dev->glob_base + MV_XOR_V2_GLOB_BW_CTRL);\n\n\t \n\treg = readl(xor_dev->glob_base + MV_XOR_V2_GLOB_PAUSE);\n\treg |= MV_XOR_V2_GLOB_PAUSE_AXI_TIME_DIS_VAL;\n\twritel(reg, xor_dev->glob_base + MV_XOR_V2_GLOB_PAUSE);\n\n\t \n\twritel(0, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_STOP_OFF);\n\n\treturn 0;\n}\n\nstatic int mv_xor_v2_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct mv_xor_v2_device *xor_dev = platform_get_drvdata(dev);\n\n\t \n\twritel(0x1, xor_dev->dma_base + MV_XOR_V2_DMA_DESQ_STOP_OFF);\n\n\treturn 0;\n}\n\nstatic int mv_xor_v2_resume(struct platform_device *dev)\n{\n\tstruct mv_xor_v2_device *xor_dev = platform_get_drvdata(dev);\n\n\tmv_xor_v2_set_desc_size(xor_dev);\n\tmv_xor_v2_enable_imsg_thrd(xor_dev);\n\tmv_xor_v2_descq_init(xor_dev);\n\n\treturn 0;\n}\n\nstatic int mv_xor_v2_probe(struct platform_device *pdev)\n{\n\tstruct mv_xor_v2_device *xor_dev;\n\tint i, ret = 0;\n\tstruct dma_device *dma_dev;\n\tstruct mv_xor_v2_sw_desc *sw_desc;\n\n\tBUILD_BUG_ON(sizeof(struct mv_xor_v2_descriptor) !=\n\t\t     MV_XOR_V2_EXT_DESC_SIZE);\n\n\txor_dev = devm_kzalloc(&pdev->dev, sizeof(*xor_dev), GFP_KERNEL);\n\tif (!xor_dev)\n\t\treturn -ENOMEM;\n\n\txor_dev->dma_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xor_dev->dma_base))\n\t\treturn PTR_ERR(xor_dev->dma_base);\n\n\txor_dev->glob_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(xor_dev->glob_base))\n\t\treturn PTR_ERR(xor_dev->glob_base);\n\n\tplatform_set_drvdata(pdev, xor_dev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(40));\n\tif (ret)\n\t\treturn ret;\n\n\txor_dev->reg_clk = devm_clk_get_optional_enabled(&pdev->dev, \"reg\");\n\tif (IS_ERR(xor_dev->reg_clk))\n\t\treturn PTR_ERR(xor_dev->reg_clk);\n\n\txor_dev->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(xor_dev->clk))\n\t\treturn PTR_ERR(xor_dev->clk);\n\n\tret = platform_msi_domain_alloc_irqs(&pdev->dev, 1,\n\t\t\t\t\t     mv_xor_v2_set_msi_msg);\n\tif (ret)\n\t\treturn ret;\n\n\txor_dev->irq = msi_get_virq(&pdev->dev, 0);\n\n\tret = devm_request_irq(&pdev->dev, xor_dev->irq,\n\t\t\t       mv_xor_v2_interrupt_handler, 0,\n\t\t\t       dev_name(&pdev->dev), xor_dev);\n\tif (ret)\n\t\tgoto free_msi_irqs;\n\n\ttasklet_setup(&xor_dev->irq_tasklet, mv_xor_v2_tasklet);\n\n\txor_dev->desc_size = mv_xor_v2_set_desc_size(xor_dev);\n\n\tdma_cookie_init(&xor_dev->dmachan);\n\n\t \n\txor_dev->hw_desq_virt =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t   xor_dev->desc_size * MV_XOR_V2_DESC_NUM,\n\t\t\t\t   &xor_dev->hw_desq, GFP_KERNEL);\n\tif (!xor_dev->hw_desq_virt) {\n\t\tret = -ENOMEM;\n\t\tgoto free_msi_irqs;\n\t}\n\n\t \n\txor_dev->sw_desq = devm_kcalloc(&pdev->dev,\n\t\t\t\t\tMV_XOR_V2_DESC_NUM, sizeof(*sw_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!xor_dev->sw_desq) {\n\t\tret = -ENOMEM;\n\t\tgoto free_hw_desq;\n\t}\n\n\tspin_lock_init(&xor_dev->lock);\n\n\t \n\tINIT_LIST_HEAD(&xor_dev->free_sw_desc);\n\n\t \n\tfor (i = 0; i < MV_XOR_V2_DESC_NUM; i++) {\n\t\tstruct mv_xor_v2_sw_desc *sw_desc =\n\t\t\txor_dev->sw_desq + i;\n\t\tsw_desc->idx = i;\n\t\tdma_async_tx_descriptor_init(&sw_desc->async_tx,\n\t\t\t\t\t     &xor_dev->dmachan);\n\t\tsw_desc->async_tx.tx_submit = mv_xor_v2_tx_submit;\n\t\tasync_tx_ack(&sw_desc->async_tx);\n\n\t\tlist_add(&sw_desc->free_list,\n\t\t\t &xor_dev->free_sw_desc);\n\t}\n\n\tdma_dev = &xor_dev->dmadev;\n\n\t \n\tdma_cap_zero(dma_dev->cap_mask);\n\tdma_cap_set(DMA_MEMCPY, dma_dev->cap_mask);\n\tdma_cap_set(DMA_XOR, dma_dev->cap_mask);\n\tdma_cap_set(DMA_INTERRUPT, dma_dev->cap_mask);\n\n\t \n\tINIT_LIST_HEAD(&dma_dev->channels);\n\n\t \n\tdma_dev->device_tx_status = dma_cookie_status;\n\tdma_dev->device_issue_pending = mv_xor_v2_issue_pending;\n\tdma_dev->dev = &pdev->dev;\n\n\tdma_dev->device_prep_dma_memcpy = mv_xor_v2_prep_dma_memcpy;\n\tdma_dev->device_prep_dma_interrupt = mv_xor_v2_prep_dma_interrupt;\n\tdma_dev->max_xor = 8;\n\tdma_dev->device_prep_dma_xor = mv_xor_v2_prep_dma_xor;\n\n\txor_dev->dmachan.device = dma_dev;\n\n\tlist_add_tail(&xor_dev->dmachan.device_node,\n\t\t      &dma_dev->channels);\n\n\tmv_xor_v2_enable_imsg_thrd(xor_dev);\n\n\tmv_xor_v2_descq_init(xor_dev);\n\n\tret = dma_async_device_register(dma_dev);\n\tif (ret)\n\t\tgoto free_hw_desq;\n\n\tdev_notice(&pdev->dev, \"Marvell Version 2 XOR driver\\n\");\n\n\treturn 0;\n\nfree_hw_desq:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  xor_dev->desc_size * MV_XOR_V2_DESC_NUM,\n\t\t\t  xor_dev->hw_desq_virt, xor_dev->hw_desq);\nfree_msi_irqs:\n\tplatform_msi_domain_free_irqs(&pdev->dev);\n\treturn ret;\n}\n\nstatic int mv_xor_v2_remove(struct platform_device *pdev)\n{\n\tstruct mv_xor_v2_device *xor_dev = platform_get_drvdata(pdev);\n\n\tdma_async_device_unregister(&xor_dev->dmadev);\n\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  xor_dev->desc_size * MV_XOR_V2_DESC_NUM,\n\t\t\t  xor_dev->hw_desq_virt, xor_dev->hw_desq);\n\n\tdevm_free_irq(&pdev->dev, xor_dev->irq, xor_dev);\n\n\tplatform_msi_domain_free_irqs(&pdev->dev);\n\n\ttasklet_kill(&xor_dev->irq_tasklet);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mv_xor_v2_dt_ids[] = {\n\t{ .compatible = \"marvell,xor-v2\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mv_xor_v2_dt_ids);\n#endif\n\nstatic struct platform_driver mv_xor_v2_driver = {\n\t.probe\t\t= mv_xor_v2_probe,\n\t.suspend\t= mv_xor_v2_suspend,\n\t.resume\t\t= mv_xor_v2_resume,\n\t.remove\t\t= mv_xor_v2_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mv_xor_v2\",\n\t\t.of_match_table = of_match_ptr(mv_xor_v2_dt_ids),\n\t},\n};\n\nmodule_platform_driver(mv_xor_v2_driver);\n\nMODULE_DESCRIPTION(\"DMA engine driver for Marvell's Version 2 of XOR engine\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}