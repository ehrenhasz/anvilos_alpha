{
  "module_name": "mv_xor.h",
  "hash_id": "f940ec488a680507b3405c697e3b60cf81ca6906b3607e797846165d04b91711",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/mv_xor.h",
  "human_readable_source": " \n \n\n#ifndef MV_XOR_H\n#define MV_XOR_H\n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n\n#define MV_XOR_POOL_SIZE\t\t(MV_XOR_SLOT_SIZE * 3072)\n#define MV_XOR_SLOT_SIZE\t\t64\n#define MV_XOR_THRESHOLD\t\t1\n#define MV_XOR_MAX_CHANNELS             2\n\n#define MV_XOR_MIN_BYTE_COUNT\t\tSZ_128\n#define MV_XOR_MAX_BYTE_COUNT\t\t(SZ_16M - 1)\n\n \n#define XOR_OPERATION_MODE_XOR\t\t0\n#define XOR_OPERATION_MODE_MEMCPY\t2\n#define XOR_OPERATION_MODE_IN_DESC      7\n#define XOR_DESCRIPTOR_SWAP\t\tBIT(14)\n#define XOR_DESC_SUCCESS\t\t0x40000000\n\n#define XOR_DESC_OPERATION_XOR          (0 << 24)\n#define XOR_DESC_OPERATION_CRC32C       (1 << 24)\n#define XOR_DESC_OPERATION_MEMCPY       (2 << 24)\n\n#define XOR_DESC_DMA_OWNED\t\tBIT(31)\n#define XOR_DESC_EOD_INT_EN\t\tBIT(31)\n\n#define XOR_CURR_DESC(chan)\t(chan->mmr_high_base + 0x10 + (chan->idx * 4))\n#define XOR_NEXT_DESC(chan)\t(chan->mmr_high_base + 0x00 + (chan->idx * 4))\n#define XOR_BYTE_COUNT(chan)\t(chan->mmr_high_base + 0x20 + (chan->idx * 4))\n#define XOR_DEST_POINTER(chan)\t(chan->mmr_high_base + 0xB0 + (chan->idx * 4))\n#define XOR_BLOCK_SIZE(chan)\t(chan->mmr_high_base + 0xC0 + (chan->idx * 4))\n#define XOR_INIT_VALUE_LOW(chan)\t(chan->mmr_high_base + 0xE0)\n#define XOR_INIT_VALUE_HIGH(chan)\t(chan->mmr_high_base + 0xE4)\n\n#define XOR_CONFIG(chan)\t(chan->mmr_base + 0x10 + (chan->idx * 4))\n#define XOR_ACTIVATION(chan)\t(chan->mmr_base + 0x20 + (chan->idx * 4))\n#define XOR_INTR_CAUSE(chan)\t(chan->mmr_base + 0x30)\n#define XOR_INTR_MASK(chan)\t(chan->mmr_base + 0x40)\n#define XOR_ERROR_CAUSE(chan)\t(chan->mmr_base + 0x50)\n#define XOR_ERROR_ADDR(chan)\t(chan->mmr_base + 0x60)\n\n#define XOR_INT_END_OF_DESC\tBIT(0)\n#define XOR_INT_END_OF_CHAIN\tBIT(1)\n#define XOR_INT_STOPPED\t\tBIT(2)\n#define XOR_INT_PAUSED\t\tBIT(3)\n#define XOR_INT_ERR_DECODE\tBIT(4)\n#define XOR_INT_ERR_RDPROT\tBIT(5)\n#define XOR_INT_ERR_WRPROT\tBIT(6)\n#define XOR_INT_ERR_OWN\t\tBIT(7)\n#define XOR_INT_ERR_PAR\t\tBIT(8)\n#define XOR_INT_ERR_MBUS\tBIT(9)\n\n#define XOR_INTR_ERRORS\t\t(XOR_INT_ERR_DECODE | XOR_INT_ERR_RDPROT | \\\n\t\t\t\t XOR_INT_ERR_WRPROT | XOR_INT_ERR_OWN    | \\\n\t\t\t\t XOR_INT_ERR_PAR    | XOR_INT_ERR_MBUS)\n\n#define XOR_INTR_MASK_VALUE\t(XOR_INT_END_OF_DESC | XOR_INT_END_OF_CHAIN | \\\n\t\t\t\t XOR_INT_STOPPED     | XOR_INTR_ERRORS)\n\n#define WINDOW_BASE(w)\t\t(0x50 + ((w) << 2))\n#define WINDOW_SIZE(w)\t\t(0x70 + ((w) << 2))\n#define WINDOW_REMAP_HIGH(w)\t(0x90 + ((w) << 2))\n#define WINDOW_BAR_ENABLE(chan)\t(0x40 + ((chan) << 2))\n#define WINDOW_OVERRIDE_CTRL(chan)\t(0xA0 + ((chan) << 2))\n\n#define WINDOW_COUNT\t\t8\n\nstruct mv_xor_device {\n\tvoid __iomem\t     *xor_base;\n\tvoid __iomem\t     *xor_high_base;\n\tstruct clk\t     *clk;\n\tstruct mv_xor_chan   *channels[MV_XOR_MAX_CHANNELS];\n\tint\t\t     xor_type;\n\n\tu32                  win_start[WINDOW_COUNT];\n\tu32                  win_end[WINDOW_COUNT];\n};\n\n \nstruct mv_xor_chan {\n\tint\t\t\tpending;\n\tspinlock_t\t\tlock;  \n\tvoid __iomem\t\t*mmr_base;\n\tvoid __iomem\t\t*mmr_high_base;\n\tunsigned int\t\tidx;\n\tint                     irq;\n\tstruct list_head\tchain;\n\tstruct list_head\tfree_slots;\n\tstruct list_head\tallocated_slots;\n\tstruct list_head\tcompleted_slots;\n\tdma_addr_t\t\tdma_desc_pool;\n\tvoid\t\t\t*dma_desc_pool_virt;\n\tsize_t                  pool_size;\n\tstruct dma_device\tdmadev;\n\tstruct dma_chan\t\tdmachan;\n\tint\t\t\tslots_allocated;\n\tstruct tasklet_struct\tirq_tasklet;\n\tint                     op_in_desc;\n\tchar\t\t\tdummy_src[MV_XOR_MIN_BYTE_COUNT];\n\tchar\t\t\tdummy_dst[MV_XOR_MIN_BYTE_COUNT];\n\tdma_addr_t\t\tdummy_src_addr, dummy_dst_addr;\n\tu32                     saved_config_reg, saved_int_mask_reg;\n\n\tstruct mv_xor_device\t*xordev;\n};\n\n \nstruct mv_xor_desc_slot {\n\tstruct list_head\tnode;\n\tstruct list_head\tsg_tx_list;\n\tenum dma_transaction_type\ttype;\n\tvoid\t\t\t*hw_desc;\n\tu16\t\t\tidx;\n\tstruct dma_async_tx_descriptor\tasync_tx;\n};\n\n \n#if defined(__LITTLE_ENDIAN)\nstruct mv_xor_desc {\n\tu32 status;\t\t \n\tu32 crc32_result;\t \n\tu32 desc_command;\t \n\tu32 phy_next_desc;\t \n\tu32 byte_count;\t\t \n\tu32 phy_dest_addr;\t \n\tu32 phy_src_addr[8];\t \n\tu32 reserved0;\n\tu32 reserved1;\n};\n#define mv_phy_src_idx(src_idx) (src_idx)\n#else\nstruct mv_xor_desc {\n\tu32 crc32_result;\t \n\tu32 status;\t\t \n\tu32 phy_next_desc;\t \n\tu32 desc_command;\t \n\tu32 phy_dest_addr;\t \n\tu32 byte_count;\t\t \n\tu32 phy_src_addr[8];\t \n\tu32 reserved1;\n\tu32 reserved0;\n};\n#define mv_phy_src_idx(src_idx) (src_idx ^ 1)\n#endif\n\n#define to_mv_sw_desc(addr_hw_desc)\t\t\\\n\tcontainer_of(addr_hw_desc, struct mv_xor_desc_slot, hw_desc)\n\n#define mv_hw_desc_slot_idx(hw_desc, idx)\t\\\n\t((void *)(((unsigned long)hw_desc) + ((idx) << 5)))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}