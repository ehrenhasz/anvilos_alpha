{
  "module_name": "dmatest.c",
  "hash_id": "b2c2d344669f286b8d920cd384a9aa5c7166d981410064b1a4e850b91a5cb196",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dmatest.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/freezer.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\nstatic unsigned int test_buf_size = 16384;\nmodule_param(test_buf_size, uint, 0644);\nMODULE_PARM_DESC(test_buf_size, \"Size of the memcpy test buffer\");\n\nstatic char test_device[32];\nmodule_param_string(device, test_device, sizeof(test_device), 0644);\nMODULE_PARM_DESC(device, \"Bus ID of the DMA Engine to test (default: any)\");\n\nstatic unsigned int threads_per_chan = 1;\nmodule_param(threads_per_chan, uint, 0644);\nMODULE_PARM_DESC(threads_per_chan,\n\t\t\"Number of threads to start per channel (default: 1)\");\n\nstatic unsigned int max_channels;\nmodule_param(max_channels, uint, 0644);\nMODULE_PARM_DESC(max_channels,\n\t\t\"Maximum number of channels to use (default: all)\");\n\nstatic unsigned int iterations;\nmodule_param(iterations, uint, 0644);\nMODULE_PARM_DESC(iterations,\n\t\t\"Iterations before stopping test (default: infinite)\");\n\nstatic unsigned int dmatest;\nmodule_param(dmatest, uint, 0644);\nMODULE_PARM_DESC(dmatest,\n\t\t\"dmatest 0-memcpy 1-memset (default: 0)\");\n\nstatic unsigned int xor_sources = 3;\nmodule_param(xor_sources, uint, 0644);\nMODULE_PARM_DESC(xor_sources,\n\t\t\"Number of xor source buffers (default: 3)\");\n\nstatic unsigned int pq_sources = 3;\nmodule_param(pq_sources, uint, 0644);\nMODULE_PARM_DESC(pq_sources,\n\t\t\"Number of p+q source buffers (default: 3)\");\n\nstatic int timeout = 3000;\nmodule_param(timeout, int, 0644);\nMODULE_PARM_DESC(timeout, \"Transfer Timeout in msec (default: 3000), \"\n\t\t \"Pass -1 for infinite timeout\");\n\nstatic bool noverify;\nmodule_param(noverify, bool, 0644);\nMODULE_PARM_DESC(noverify, \"Disable data verification (default: verify)\");\n\nstatic bool norandom;\nmodule_param(norandom, bool, 0644);\nMODULE_PARM_DESC(norandom, \"Disable random offset setup (default: random)\");\n\nstatic bool verbose;\nmodule_param(verbose, bool, 0644);\nMODULE_PARM_DESC(verbose, \"Enable \\\"success\\\" result messages (default: off)\");\n\nstatic int alignment = -1;\nmodule_param(alignment, int, 0644);\nMODULE_PARM_DESC(alignment, \"Custom data address alignment taken as 2^(alignment) (default: not used (-1))\");\n\nstatic unsigned int transfer_size;\nmodule_param(transfer_size, uint, 0644);\nMODULE_PARM_DESC(transfer_size, \"Optional custom transfer size in bytes (default: not used (0))\");\n\nstatic bool polled;\nmodule_param(polled, bool, 0644);\nMODULE_PARM_DESC(polled, \"Use polling for completion instead of interrupts\");\n\n \nstruct dmatest_params {\n\tunsigned int\tbuf_size;\n\tchar\t\tchannel[20];\n\tchar\t\tdevice[32];\n\tunsigned int\tthreads_per_chan;\n\tunsigned int\tmax_channels;\n\tunsigned int\titerations;\n\tunsigned int\txor_sources;\n\tunsigned int\tpq_sources;\n\tint\t\ttimeout;\n\tbool\t\tnoverify;\n\tbool\t\tnorandom;\n\tint\t\talignment;\n\tunsigned int\ttransfer_size;\n\tbool\t\tpolled;\n};\n\n \nstatic struct dmatest_info {\n\t \n\tstruct dmatest_params\tparams;\n\n\t \n\tstruct list_head\tchannels;\n\tunsigned int\t\tnr_channels;\n\tint\t\t\tlast_error;\n\tstruct mutex\t\tlock;\n\tbool\t\t\tdid_init;\n} test_info = {\n\t.channels = LIST_HEAD_INIT(test_info.channels),\n\t.lock = __MUTEX_INITIALIZER(test_info.lock),\n};\n\nstatic int dmatest_run_set(const char *val, const struct kernel_param *kp);\nstatic int dmatest_run_get(char *val, const struct kernel_param *kp);\nstatic const struct kernel_param_ops run_ops = {\n\t.set = dmatest_run_set,\n\t.get = dmatest_run_get,\n};\nstatic bool dmatest_run;\nmodule_param_cb(run, &run_ops, &dmatest_run, 0644);\nMODULE_PARM_DESC(run, \"Run the test (default: false)\");\n\nstatic int dmatest_chan_set(const char *val, const struct kernel_param *kp);\nstatic int dmatest_chan_get(char *val, const struct kernel_param *kp);\nstatic const struct kernel_param_ops multi_chan_ops = {\n\t.set = dmatest_chan_set,\n\t.get = dmatest_chan_get,\n};\n\nstatic char test_channel[20];\nstatic struct kparam_string newchan_kps = {\n\t.string = test_channel,\n\t.maxlen = 20,\n};\nmodule_param_cb(channel, &multi_chan_ops, &newchan_kps, 0644);\nMODULE_PARM_DESC(channel, \"Bus ID of the channel to test (default: any)\");\n\nstatic int dmatest_test_list_get(char *val, const struct kernel_param *kp);\nstatic const struct kernel_param_ops test_list_ops = {\n\t.get = dmatest_test_list_get,\n};\nmodule_param_cb(test_list, &test_list_ops, NULL, 0444);\nMODULE_PARM_DESC(test_list, \"Print current test list\");\n\n \n#define MAX_ERROR_COUNT\t\t32\n\n \n#define PATTERN_SRC\t\t0x80\n#define PATTERN_DST\t\t0x00\n#define PATTERN_COPY\t\t0x40\n#define PATTERN_OVERWRITE\t0x20\n#define PATTERN_COUNT_MASK\t0x1f\n#define PATTERN_MEMSET_IDX\t0x01\n\n \n#define FIXPT_SHIFT\t\t8\n#define FIXPNT_MASK\t\t0xFF\n#define FIXPT_TO_INT(a)\t((a) >> FIXPT_SHIFT)\n#define INT_TO_FIXPT(a)\t((a) << FIXPT_SHIFT)\n#define FIXPT_GET_FRAC(a)\t((((a) & FIXPNT_MASK) * 100) >> FIXPT_SHIFT)\n\n \nstruct dmatest_done {\n\tbool\t\t\tdone;\n\twait_queue_head_t\t*wait;\n};\n\nstruct dmatest_data {\n\tu8\t\t**raw;\n\tu8\t\t**aligned;\n\tunsigned int\tcnt;\n\tunsigned int\toff;\n};\n\nstruct dmatest_thread {\n\tstruct list_head\tnode;\n\tstruct dmatest_info\t*info;\n\tstruct task_struct\t*task;\n\tstruct dma_chan\t\t*chan;\n\tstruct dmatest_data\tsrc;\n\tstruct dmatest_data\tdst;\n\tenum dma_transaction_type type;\n\twait_queue_head_t done_wait;\n\tstruct dmatest_done test_done;\n\tbool\t\t\tdone;\n\tbool\t\t\tpending;\n};\n\nstruct dmatest_chan {\n\tstruct list_head\tnode;\n\tstruct dma_chan\t\t*chan;\n\tstruct list_head\tthreads;\n};\n\nstatic DECLARE_WAIT_QUEUE_HEAD(thread_wait);\nstatic bool wait;\n\nstatic bool is_threaded_test_run(struct dmatest_info *info)\n{\n\tstruct dmatest_chan *dtc;\n\n\tlist_for_each_entry(dtc, &info->channels, node) {\n\t\tstruct dmatest_thread *thread;\n\n\t\tlist_for_each_entry(thread, &dtc->threads, node) {\n\t\t\tif (!thread->done && !thread->pending)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool is_threaded_test_pending(struct dmatest_info *info)\n{\n\tstruct dmatest_chan *dtc;\n\n\tlist_for_each_entry(dtc, &info->channels, node) {\n\t\tstruct dmatest_thread *thread;\n\n\t\tlist_for_each_entry(thread, &dtc->threads, node) {\n\t\t\tif (thread->pending)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int dmatest_wait_get(char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\tstruct dmatest_params *params = &info->params;\n\n\tif (params->iterations)\n\t\twait_event(thread_wait, !is_threaded_test_run(info));\n\twait = true;\n\treturn param_get_bool(val, kp);\n}\n\nstatic const struct kernel_param_ops wait_ops = {\n\t.get = dmatest_wait_get,\n\t.set = param_set_bool,\n};\nmodule_param_cb(wait, &wait_ops, &wait, 0444);\nMODULE_PARM_DESC(wait, \"Wait for tests to complete (default: false)\");\n\nstatic bool dmatest_match_channel(struct dmatest_params *params,\n\t\tstruct dma_chan *chan)\n{\n\tif (params->channel[0] == '\\0')\n\t\treturn true;\n\treturn strcmp(dma_chan_name(chan), params->channel) == 0;\n}\n\nstatic bool dmatest_match_device(struct dmatest_params *params,\n\t\tstruct dma_device *device)\n{\n\tif (params->device[0] == '\\0')\n\t\treturn true;\n\treturn strcmp(dev_name(device->dev), params->device) == 0;\n}\n\nstatic unsigned long dmatest_random(void)\n{\n\tunsigned long buf;\n\n\tget_random_bytes(&buf, sizeof(buf));\n\treturn buf;\n}\n\nstatic inline u8 gen_inv_idx(u8 index, bool is_memset)\n{\n\tu8 val = is_memset ? PATTERN_MEMSET_IDX : index;\n\n\treturn ~val & PATTERN_COUNT_MASK;\n}\n\nstatic inline u8 gen_src_value(u8 index, bool is_memset)\n{\n\treturn PATTERN_SRC | gen_inv_idx(index, is_memset);\n}\n\nstatic inline u8 gen_dst_value(u8 index, bool is_memset)\n{\n\treturn PATTERN_DST | gen_inv_idx(index, is_memset);\n}\n\nstatic void dmatest_init_srcs(u8 **bufs, unsigned int start, unsigned int len,\n\t\tunsigned int buf_size, bool is_memset)\n{\n\tunsigned int i;\n\tu8 *buf;\n\n\tfor (; (buf = *bufs); bufs++) {\n\t\tfor (i = 0; i < start; i++)\n\t\t\tbuf[i] = gen_src_value(i, is_memset);\n\t\tfor ( ; i < start + len; i++)\n\t\t\tbuf[i] = gen_src_value(i, is_memset) | PATTERN_COPY;\n\t\tfor ( ; i < buf_size; i++)\n\t\t\tbuf[i] = gen_src_value(i, is_memset);\n\t\tbuf++;\n\t}\n}\n\nstatic void dmatest_init_dsts(u8 **bufs, unsigned int start, unsigned int len,\n\t\tunsigned int buf_size, bool is_memset)\n{\n\tunsigned int i;\n\tu8 *buf;\n\n\tfor (; (buf = *bufs); bufs++) {\n\t\tfor (i = 0; i < start; i++)\n\t\t\tbuf[i] = gen_dst_value(i, is_memset);\n\t\tfor ( ; i < start + len; i++)\n\t\t\tbuf[i] = gen_dst_value(i, is_memset) |\n\t\t\t\t\t\tPATTERN_OVERWRITE;\n\t\tfor ( ; i < buf_size; i++)\n\t\t\tbuf[i] = gen_dst_value(i, is_memset);\n\t}\n}\n\nstatic void dmatest_mismatch(u8 actual, u8 pattern, unsigned int index,\n\t\tunsigned int counter, bool is_srcbuf, bool is_memset)\n{\n\tu8\t\tdiff = actual ^ pattern;\n\tu8\t\texpected = pattern | gen_inv_idx(counter, is_memset);\n\tconst char\t*thread_name = current->comm;\n\n\tif (is_srcbuf)\n\t\tpr_warn(\"%s: srcbuf[0x%x] overwritten! Expected %02x, got %02x\\n\",\n\t\t\tthread_name, index, expected, actual);\n\telse if ((pattern & PATTERN_COPY)\n\t\t\t&& (diff & (PATTERN_COPY | PATTERN_OVERWRITE)))\n\t\tpr_warn(\"%s: dstbuf[0x%x] not copied! Expected %02x, got %02x\\n\",\n\t\t\tthread_name, index, expected, actual);\n\telse if (diff & PATTERN_SRC)\n\t\tpr_warn(\"%s: dstbuf[0x%x] was copied! Expected %02x, got %02x\\n\",\n\t\t\tthread_name, index, expected, actual);\n\telse\n\t\tpr_warn(\"%s: dstbuf[0x%x] mismatch! Expected %02x, got %02x\\n\",\n\t\t\tthread_name, index, expected, actual);\n}\n\nstatic unsigned int dmatest_verify(u8 **bufs, unsigned int start,\n\t\tunsigned int end, unsigned int counter, u8 pattern,\n\t\tbool is_srcbuf, bool is_memset)\n{\n\tunsigned int i;\n\tunsigned int error_count = 0;\n\tu8 actual;\n\tu8 expected;\n\tu8 *buf;\n\tunsigned int counter_orig = counter;\n\n\tfor (; (buf = *bufs); bufs++) {\n\t\tcounter = counter_orig;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tactual = buf[i];\n\t\t\texpected = pattern | gen_inv_idx(counter, is_memset);\n\t\t\tif (actual != expected) {\n\t\t\t\tif (error_count < MAX_ERROR_COUNT)\n\t\t\t\t\tdmatest_mismatch(actual, pattern, i,\n\t\t\t\t\t\t\t counter, is_srcbuf,\n\t\t\t\t\t\t\t is_memset);\n\t\t\t\terror_count++;\n\t\t\t}\n\t\t\tcounter++;\n\t\t}\n\t}\n\n\tif (error_count > MAX_ERROR_COUNT)\n\t\tpr_warn(\"%s: %u errors suppressed\\n\",\n\t\t\tcurrent->comm, error_count - MAX_ERROR_COUNT);\n\n\treturn error_count;\n}\n\n\nstatic void dmatest_callback(void *arg)\n{\n\tstruct dmatest_done *done = arg;\n\tstruct dmatest_thread *thread =\n\t\tcontainer_of(done, struct dmatest_thread, test_done);\n\tif (!thread->done) {\n\t\tdone->done = true;\n\t\twake_up_all(done->wait);\n\t} else {\n\t\t \n\t\tWARN(1, \"dmatest: Kernel memory may be corrupted!!\\n\");\n\t}\n}\n\nstatic unsigned int min_odd(unsigned int x, unsigned int y)\n{\n\tunsigned int val = min(x, y);\n\n\treturn val % 2 ? val : val - 1;\n}\n\nstatic void result(const char *err, unsigned int n, unsigned int src_off,\n\t\t   unsigned int dst_off, unsigned int len, unsigned long data)\n{\n\tif (IS_ERR_VALUE(data)) {\n\t\tpr_info(\"%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%ld)\\n\",\n\t\t\tcurrent->comm, n, err, src_off, dst_off, len, data);\n\t} else {\n\t\tpr_info(\"%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%lu)\\n\",\n\t\t\tcurrent->comm, n, err, src_off, dst_off, len, data);\n\t}\n}\n\nstatic void dbg_result(const char *err, unsigned int n, unsigned int src_off,\n\t\t       unsigned int dst_off, unsigned int len,\n\t\t       unsigned long data)\n{\n\tpr_debug(\"%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%lu)\\n\",\n\t\t current->comm, n, err, src_off, dst_off, len, data);\n}\n\n#define verbose_result(err, n, src_off, dst_off, len, data) ({\t\\\n\tif (verbose)\t\t\t\t\t\t\\\n\t\tresult(err, n, src_off, dst_off, len, data);\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tdbg_result(err, n, src_off, dst_off, len, data);\\\n})\n\nstatic unsigned long long dmatest_persec(s64 runtime, unsigned int val)\n{\n\tunsigned long long per_sec = 1000000;\n\n\tif (runtime <= 0)\n\t\treturn 0;\n\n\t \n\twhile (runtime > UINT_MAX) {\n\t\truntime >>= 1;\n\t\tper_sec <<= 1;\n\t}\n\n\tper_sec *= val;\n\tper_sec = INT_TO_FIXPT(per_sec);\n\tdo_div(per_sec, runtime);\n\n\treturn per_sec;\n}\n\nstatic unsigned long long dmatest_KBs(s64 runtime, unsigned long long len)\n{\n\treturn FIXPT_TO_INT(dmatest_persec(runtime, len >> 10));\n}\n\nstatic void __dmatest_free_test_data(struct dmatest_data *d, unsigned int cnt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tkfree(d->raw[i]);\n\n\tkfree(d->aligned);\n\tkfree(d->raw);\n}\n\nstatic void dmatest_free_test_data(struct dmatest_data *d)\n{\n\t__dmatest_free_test_data(d, d->cnt);\n}\n\nstatic int dmatest_alloc_test_data(struct dmatest_data *d,\n\t\tunsigned int buf_size, u8 align)\n{\n\tunsigned int i = 0;\n\n\td->raw = kcalloc(d->cnt + 1, sizeof(u8 *), GFP_KERNEL);\n\tif (!d->raw)\n\t\treturn -ENOMEM;\n\n\td->aligned = kcalloc(d->cnt + 1, sizeof(u8 *), GFP_KERNEL);\n\tif (!d->aligned)\n\t\tgoto err;\n\n\tfor (i = 0; i < d->cnt; i++) {\n\t\td->raw[i] = kmalloc(buf_size + align, GFP_KERNEL);\n\t\tif (!d->raw[i])\n\t\t\tgoto err;\n\n\t\t \n\t\tif (align)\n\t\t\td->aligned[i] = PTR_ALIGN(d->raw[i], align);\n\t\telse\n\t\t\td->aligned[i] = d->raw[i];\n\t}\n\n\treturn 0;\nerr:\n\t__dmatest_free_test_data(d, i);\n\treturn -ENOMEM;\n}\n\n \nstatic int dmatest_func(void *data)\n{\n\tstruct dmatest_thread\t*thread = data;\n\tstruct dmatest_done\t*done = &thread->test_done;\n\tstruct dmatest_info\t*info;\n\tstruct dmatest_params\t*params;\n\tstruct dma_chan\t\t*chan;\n\tstruct dma_device\t*dev;\n\tstruct device\t\t*dma_dev;\n\tunsigned int\t\terror_count;\n\tunsigned int\t\tfailed_tests = 0;\n\tunsigned int\t\ttotal_tests = 0;\n\tdma_cookie_t\t\tcookie;\n\tenum dma_status\t\tstatus;\n\tenum dma_ctrl_flags\tflags;\n\tu8\t\t\t*pq_coefs = NULL;\n\tint\t\t\tret;\n\tunsigned int\t\tbuf_size;\n\tstruct dmatest_data\t*src;\n\tstruct dmatest_data\t*dst;\n\tint\t\t\ti;\n\tktime_t\t\t\tktime, start, diff;\n\tktime_t\t\t\tfilltime = 0;\n\tktime_t\t\t\tcomparetime = 0;\n\ts64\t\t\truntime = 0;\n\tunsigned long long\ttotal_len = 0;\n\tunsigned long long\tiops = 0;\n\tu8\t\t\talign = 0;\n\tbool\t\t\tis_memset = false;\n\tdma_addr_t\t\t*srcs;\n\tdma_addr_t\t\t*dma_pq;\n\n\tset_freezable();\n\n\tret = -ENOMEM;\n\n\tsmp_rmb();\n\tthread->pending = false;\n\tinfo = thread->info;\n\tparams = &info->params;\n\tchan = thread->chan;\n\tdev = chan->device;\n\tdma_dev = dmaengine_get_dma_device(chan);\n\n\tsrc = &thread->src;\n\tdst = &thread->dst;\n\tif (thread->type == DMA_MEMCPY) {\n\t\talign = params->alignment < 0 ? dev->copy_align :\n\t\t\t\t\t\tparams->alignment;\n\t\tsrc->cnt = dst->cnt = 1;\n\t} else if (thread->type == DMA_MEMSET) {\n\t\talign = params->alignment < 0 ? dev->fill_align :\n\t\t\t\t\t\tparams->alignment;\n\t\tsrc->cnt = dst->cnt = 1;\n\t\tis_memset = true;\n\t} else if (thread->type == DMA_XOR) {\n\t\t \n\t\tsrc->cnt = min_odd(params->xor_sources | 1, dev->max_xor);\n\t\tdst->cnt = 1;\n\t\talign = params->alignment < 0 ? dev->xor_align :\n\t\t\t\t\t\tparams->alignment;\n\t} else if (thread->type == DMA_PQ) {\n\t\t \n\t\tsrc->cnt = min_odd(params->pq_sources | 1, dma_maxpq(dev, 0));\n\t\tdst->cnt = 2;\n\t\talign = params->alignment < 0 ? dev->pq_align :\n\t\t\t\t\t\tparams->alignment;\n\n\t\tpq_coefs = kmalloc(params->pq_sources + 1, GFP_KERNEL);\n\t\tif (!pq_coefs)\n\t\t\tgoto err_thread_type;\n\n\t\tfor (i = 0; i < src->cnt; i++)\n\t\t\tpq_coefs[i] = 1;\n\t} else\n\t\tgoto err_thread_type;\n\n\t \n\tif ((src->cnt + dst->cnt) >= 255) {\n\t\tpr_err(\"too many buffers (%d of 255 supported)\\n\",\n\t\t       src->cnt + dst->cnt);\n\t\tgoto err_free_coefs;\n\t}\n\n\tbuf_size = params->buf_size;\n\tif (1 << align > buf_size) {\n\t\tpr_err(\"%u-byte buffer too small for %d-byte alignment\\n\",\n\t\t       buf_size, 1 << align);\n\t\tgoto err_free_coefs;\n\t}\n\n\tif (dmatest_alloc_test_data(src, buf_size, align) < 0)\n\t\tgoto err_free_coefs;\n\n\tif (dmatest_alloc_test_data(dst, buf_size, align) < 0)\n\t\tgoto err_src;\n\n\tset_user_nice(current, 10);\n\n\tsrcs = kcalloc(src->cnt, sizeof(dma_addr_t), GFP_KERNEL);\n\tif (!srcs)\n\t\tgoto err_dst;\n\n\tdma_pq = kcalloc(dst->cnt, sizeof(dma_addr_t), GFP_KERNEL);\n\tif (!dma_pq)\n\t\tgoto err_srcs_array;\n\n\t \n\tif (params->polled)\n\t\tflags = DMA_CTRL_ACK;\n\telse\n\t\tflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\n\tktime = ktime_get();\n\twhile (!(kthread_should_stop() ||\n\t       (params->iterations && total_tests >= params->iterations))) {\n\t\tstruct dma_async_tx_descriptor *tx = NULL;\n\t\tstruct dmaengine_unmap_data *um;\n\t\tdma_addr_t *dsts;\n\t\tunsigned int len;\n\n\t\ttotal_tests++;\n\n\t\tif (params->transfer_size) {\n\t\t\tif (params->transfer_size >= buf_size) {\n\t\t\t\tpr_err(\"%u-byte transfer size must be lower than %u-buffer size\\n\",\n\t\t\t\t       params->transfer_size, buf_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = params->transfer_size;\n\t\t} else if (params->norandom) {\n\t\t\tlen = buf_size;\n\t\t} else {\n\t\t\tlen = dmatest_random() % buf_size + 1;\n\t\t}\n\n\t\t \n\t\tif (!params->transfer_size) {\n\t\t\tlen = (len >> align) << align;\n\t\t\tif (!len)\n\t\t\t\tlen = 1 << align;\n\t\t}\n\t\ttotal_len += len;\n\n\t\tif (params->norandom) {\n\t\t\tsrc->off = 0;\n\t\t\tdst->off = 0;\n\t\t} else {\n\t\t\tsrc->off = dmatest_random() % (buf_size - len + 1);\n\t\t\tdst->off = dmatest_random() % (buf_size - len + 1);\n\n\t\t\tsrc->off = (src->off >> align) << align;\n\t\t\tdst->off = (dst->off >> align) << align;\n\t\t}\n\n\t\tif (!params->noverify) {\n\t\t\tstart = ktime_get();\n\t\t\tdmatest_init_srcs(src->aligned, src->off, len,\n\t\t\t\t\t  buf_size, is_memset);\n\t\t\tdmatest_init_dsts(dst->aligned, dst->off, len,\n\t\t\t\t\t  buf_size, is_memset);\n\n\t\t\tdiff = ktime_sub(ktime_get(), start);\n\t\t\tfilltime = ktime_add(filltime, diff);\n\t\t}\n\n\t\tum = dmaengine_get_unmap_data(dma_dev, src->cnt + dst->cnt,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!um) {\n\t\t\tfailed_tests++;\n\t\t\tresult(\"unmap data NULL\", total_tests,\n\t\t\t       src->off, dst->off, len, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tum->len = buf_size;\n\t\tfor (i = 0; i < src->cnt; i++) {\n\t\t\tvoid *buf = src->aligned[i];\n\t\t\tstruct page *pg = virt_to_page(buf);\n\t\t\tunsigned long pg_off = offset_in_page(buf);\n\n\t\t\tum->addr[i] = dma_map_page(dma_dev, pg, pg_off,\n\t\t\t\t\t\t   um->len, DMA_TO_DEVICE);\n\t\t\tsrcs[i] = um->addr[i] + src->off;\n\t\t\tret = dma_mapping_error(dma_dev, um->addr[i]);\n\t\t\tif (ret) {\n\t\t\t\tresult(\"src mapping error\", total_tests,\n\t\t\t\t       src->off, dst->off, len, ret);\n\t\t\t\tgoto error_unmap_continue;\n\t\t\t}\n\t\t\tum->to_cnt++;\n\t\t}\n\t\t \n\t\tdsts = &um->addr[src->cnt];\n\t\tfor (i = 0; i < dst->cnt; i++) {\n\t\t\tvoid *buf = dst->aligned[i];\n\t\t\tstruct page *pg = virt_to_page(buf);\n\t\t\tunsigned long pg_off = offset_in_page(buf);\n\n\t\t\tdsts[i] = dma_map_page(dma_dev, pg, pg_off, um->len,\n\t\t\t\t\t       DMA_BIDIRECTIONAL);\n\t\t\tret = dma_mapping_error(dma_dev, dsts[i]);\n\t\t\tif (ret) {\n\t\t\t\tresult(\"dst mapping error\", total_tests,\n\t\t\t\t       src->off, dst->off, len, ret);\n\t\t\t\tgoto error_unmap_continue;\n\t\t\t}\n\t\t\tum->bidi_cnt++;\n\t\t}\n\n\t\tif (thread->type == DMA_MEMCPY)\n\t\t\ttx = dev->device_prep_dma_memcpy(chan,\n\t\t\t\t\t\t\t dsts[0] + dst->off,\n\t\t\t\t\t\t\t srcs[0], len, flags);\n\t\telse if (thread->type == DMA_MEMSET)\n\t\t\ttx = dev->device_prep_dma_memset(chan,\n\t\t\t\t\t\tdsts[0] + dst->off,\n\t\t\t\t\t\t*(src->aligned[0] + src->off),\n\t\t\t\t\t\tlen, flags);\n\t\telse if (thread->type == DMA_XOR)\n\t\t\ttx = dev->device_prep_dma_xor(chan,\n\t\t\t\t\t\t      dsts[0] + dst->off,\n\t\t\t\t\t\t      srcs, src->cnt,\n\t\t\t\t\t\t      len, flags);\n\t\telse if (thread->type == DMA_PQ) {\n\t\t\tfor (i = 0; i < dst->cnt; i++)\n\t\t\t\tdma_pq[i] = dsts[i] + dst->off;\n\t\t\ttx = dev->device_prep_dma_pq(chan, dma_pq, srcs,\n\t\t\t\t\t\t     src->cnt, pq_coefs,\n\t\t\t\t\t\t     len, flags);\n\t\t}\n\n\t\tif (!tx) {\n\t\t\tresult(\"prep error\", total_tests, src->off,\n\t\t\t       dst->off, len, ret);\n\t\t\tmsleep(100);\n\t\t\tgoto error_unmap_continue;\n\t\t}\n\n\t\tdone->done = false;\n\t\tif (!params->polled) {\n\t\t\ttx->callback = dmatest_callback;\n\t\t\ttx->callback_param = done;\n\t\t}\n\t\tcookie = tx->tx_submit(tx);\n\n\t\tif (dma_submit_error(cookie)) {\n\t\t\tresult(\"submit error\", total_tests, src->off,\n\t\t\t       dst->off, len, ret);\n\t\t\tmsleep(100);\n\t\t\tgoto error_unmap_continue;\n\t\t}\n\n\t\tif (params->polled) {\n\t\t\tstatus = dma_sync_wait(chan, cookie);\n\t\t\tdmaengine_terminate_sync(chan);\n\t\t\tif (status == DMA_COMPLETE)\n\t\t\t\tdone->done = true;\n\t\t} else {\n\t\t\tdma_async_issue_pending(chan);\n\n\t\t\twait_event_freezable_timeout(thread->done_wait,\n\t\t\t\t\tdone->done,\n\t\t\t\t\tmsecs_to_jiffies(params->timeout));\n\n\t\t\tstatus = dma_async_is_tx_complete(chan, cookie, NULL,\n\t\t\t\t\t\t\t  NULL);\n\t\t}\n\n\t\tif (!done->done) {\n\t\t\tresult(\"test timed out\", total_tests, src->off, dst->off,\n\t\t\t       len, 0);\n\t\t\tgoto error_unmap_continue;\n\t\t} else if (status != DMA_COMPLETE &&\n\t\t\t   !(dma_has_cap(DMA_COMPLETION_NO_ORDER,\n\t\t\t\t\t dev->cap_mask) &&\n\t\t\t     status == DMA_OUT_OF_ORDER)) {\n\t\t\tresult(status == DMA_ERROR ?\n\t\t\t       \"completion error status\" :\n\t\t\t       \"completion busy status\", total_tests, src->off,\n\t\t\t       dst->off, len, ret);\n\t\t\tgoto error_unmap_continue;\n\t\t}\n\n\t\tdmaengine_unmap_put(um);\n\n\t\tif (params->noverify) {\n\t\t\tverbose_result(\"test passed\", total_tests, src->off,\n\t\t\t\t       dst->off, len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstart = ktime_get();\n\t\tpr_debug(\"%s: verifying source buffer...\\n\", current->comm);\n\t\terror_count = dmatest_verify(src->aligned, 0, src->off,\n\t\t\t\t0, PATTERN_SRC, true, is_memset);\n\t\terror_count += dmatest_verify(src->aligned, src->off,\n\t\t\t\tsrc->off + len, src->off,\n\t\t\t\tPATTERN_SRC | PATTERN_COPY, true, is_memset);\n\t\terror_count += dmatest_verify(src->aligned, src->off + len,\n\t\t\t\tbuf_size, src->off + len,\n\t\t\t\tPATTERN_SRC, true, is_memset);\n\n\t\tpr_debug(\"%s: verifying dest buffer...\\n\", current->comm);\n\t\terror_count += dmatest_verify(dst->aligned, 0, dst->off,\n\t\t\t\t0, PATTERN_DST, false, is_memset);\n\n\t\terror_count += dmatest_verify(dst->aligned, dst->off,\n\t\t\t\tdst->off + len, src->off,\n\t\t\t\tPATTERN_SRC | PATTERN_COPY, false, is_memset);\n\n\t\terror_count += dmatest_verify(dst->aligned, dst->off + len,\n\t\t\t\tbuf_size, dst->off + len,\n\t\t\t\tPATTERN_DST, false, is_memset);\n\n\t\tdiff = ktime_sub(ktime_get(), start);\n\t\tcomparetime = ktime_add(comparetime, diff);\n\n\t\tif (error_count) {\n\t\t\tresult(\"data error\", total_tests, src->off, dst->off,\n\t\t\t       len, error_count);\n\t\t\tfailed_tests++;\n\t\t} else {\n\t\t\tverbose_result(\"test passed\", total_tests, src->off,\n\t\t\t\t       dst->off, len, 0);\n\t\t}\n\n\t\tcontinue;\n\nerror_unmap_continue:\n\t\tdmaengine_unmap_put(um);\n\t\tfailed_tests++;\n\t}\n\tktime = ktime_sub(ktime_get(), ktime);\n\tktime = ktime_sub(ktime, comparetime);\n\tktime = ktime_sub(ktime, filltime);\n\truntime = ktime_to_us(ktime);\n\n\tret = 0;\n\tkfree(dma_pq);\nerr_srcs_array:\n\tkfree(srcs);\nerr_dst:\n\tdmatest_free_test_data(dst);\nerr_src:\n\tdmatest_free_test_data(src);\nerr_free_coefs:\n\tkfree(pq_coefs);\nerr_thread_type:\n\tiops = dmatest_persec(runtime, total_tests);\n\tpr_info(\"%s: summary %u tests, %u failures %llu.%02llu iops %llu KB/s (%d)\\n\",\n\t\tcurrent->comm, total_tests, failed_tests,\n\t\tFIXPT_TO_INT(iops), FIXPT_GET_FRAC(iops),\n\t\tdmatest_KBs(runtime, total_len), ret);\n\n\t \n\tif (ret || failed_tests)\n\t\tdmaengine_terminate_sync(chan);\n\n\tthread->done = true;\n\twake_up(&thread_wait);\n\n\treturn ret;\n}\n\nstatic void dmatest_cleanup_channel(struct dmatest_chan *dtc)\n{\n\tstruct dmatest_thread\t*thread;\n\tstruct dmatest_thread\t*_thread;\n\tint\t\t\tret;\n\n\tlist_for_each_entry_safe(thread, _thread, &dtc->threads, node) {\n\t\tret = kthread_stop(thread->task);\n\t\tpr_debug(\"thread %s exited with status %d\\n\",\n\t\t\t thread->task->comm, ret);\n\t\tlist_del(&thread->node);\n\t\tput_task_struct(thread->task);\n\t\tkfree(thread);\n\t}\n\n\t \n\tdmaengine_terminate_sync(dtc->chan);\n\n\tkfree(dtc);\n}\n\nstatic int dmatest_add_threads(struct dmatest_info *info,\n\t\tstruct dmatest_chan *dtc, enum dma_transaction_type type)\n{\n\tstruct dmatest_params *params = &info->params;\n\tstruct dmatest_thread *thread;\n\tstruct dma_chan *chan = dtc->chan;\n\tchar *op;\n\tunsigned int i;\n\n\tif (type == DMA_MEMCPY)\n\t\top = \"copy\";\n\telse if (type == DMA_MEMSET)\n\t\top = \"set\";\n\telse if (type == DMA_XOR)\n\t\top = \"xor\";\n\telse if (type == DMA_PQ)\n\t\top = \"pq\";\n\telse\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < params->threads_per_chan; i++) {\n\t\tthread = kzalloc(sizeof(struct dmatest_thread), GFP_KERNEL);\n\t\tif (!thread) {\n\t\t\tpr_warn(\"No memory for %s-%s%u\\n\",\n\t\t\t\tdma_chan_name(chan), op, i);\n\t\t\tbreak;\n\t\t}\n\t\tthread->info = info;\n\t\tthread->chan = dtc->chan;\n\t\tthread->type = type;\n\t\tthread->test_done.wait = &thread->done_wait;\n\t\tinit_waitqueue_head(&thread->done_wait);\n\t\tsmp_wmb();\n\t\tthread->task = kthread_create(dmatest_func, thread, \"%s-%s%u\",\n\t\t\t\tdma_chan_name(chan), op, i);\n\t\tif (IS_ERR(thread->task)) {\n\t\t\tpr_warn(\"Failed to create thread %s-%s%u\\n\",\n\t\t\t\tdma_chan_name(chan), op, i);\n\t\t\tkfree(thread);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tget_task_struct(thread->task);\n\t\tlist_add_tail(&thread->node, &dtc->threads);\n\t\tthread->pending = true;\n\t}\n\n\treturn i;\n}\n\nstatic int dmatest_add_channel(struct dmatest_info *info,\n\t\tstruct dma_chan *chan)\n{\n\tstruct dmatest_chan\t*dtc;\n\tstruct dma_device\t*dma_dev = chan->device;\n\tunsigned int\t\tthread_count = 0;\n\tint cnt;\n\n\tdtc = kmalloc(sizeof(struct dmatest_chan), GFP_KERNEL);\n\tif (!dtc) {\n\t\tpr_warn(\"No memory for %s\\n\", dma_chan_name(chan));\n\t\treturn -ENOMEM;\n\t}\n\n\tdtc->chan = chan;\n\tINIT_LIST_HEAD(&dtc->threads);\n\n\tif (dma_has_cap(DMA_COMPLETION_NO_ORDER, dma_dev->cap_mask) &&\n\t    info->params.polled) {\n\t\tinfo->params.polled = false;\n\t\tpr_warn(\"DMA_COMPLETION_NO_ORDER, polled disabled\\n\");\n\t}\n\n\tif (dma_has_cap(DMA_MEMCPY, dma_dev->cap_mask)) {\n\t\tif (dmatest == 0) {\n\t\t\tcnt = dmatest_add_threads(info, dtc, DMA_MEMCPY);\n\t\t\tthread_count += cnt > 0 ? cnt : 0;\n\t\t}\n\t}\n\n\tif (dma_has_cap(DMA_MEMSET, dma_dev->cap_mask)) {\n\t\tif (dmatest == 1) {\n\t\t\tcnt = dmatest_add_threads(info, dtc, DMA_MEMSET);\n\t\t\tthread_count += cnt > 0 ? cnt : 0;\n\t\t}\n\t}\n\n\tif (dma_has_cap(DMA_XOR, dma_dev->cap_mask)) {\n\t\tcnt = dmatest_add_threads(info, dtc, DMA_XOR);\n\t\tthread_count += cnt > 0 ? cnt : 0;\n\t}\n\tif (dma_has_cap(DMA_PQ, dma_dev->cap_mask)) {\n\t\tcnt = dmatest_add_threads(info, dtc, DMA_PQ);\n\t\tthread_count += cnt > 0 ? cnt : 0;\n\t}\n\n\tpr_info(\"Added %u threads using %s\\n\",\n\t\tthread_count, dma_chan_name(chan));\n\n\tlist_add_tail(&dtc->node, &info->channels);\n\tinfo->nr_channels++;\n\n\treturn 0;\n}\n\nstatic bool filter(struct dma_chan *chan, void *param)\n{\n\treturn dmatest_match_channel(param, chan) && dmatest_match_device(param, chan->device);\n}\n\nstatic void request_channels(struct dmatest_info *info,\n\t\t\t     enum dma_transaction_type type)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(type, mask);\n\tfor (;;) {\n\t\tstruct dmatest_params *params = &info->params;\n\t\tstruct dma_chan *chan;\n\n\t\tchan = dma_request_channel(mask, filter, params);\n\t\tif (chan) {\n\t\t\tif (dmatest_add_channel(info, chan)) {\n\t\t\t\tdma_release_channel(chan);\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t} else\n\t\t\tbreak;  \n\t\tif (params->max_channels &&\n\t\t    info->nr_channels >= params->max_channels)\n\t\t\tbreak;  \n\t}\n}\n\nstatic void add_threaded_test(struct dmatest_info *info)\n{\n\tstruct dmatest_params *params = &info->params;\n\n\t \n\tparams->buf_size = test_buf_size;\n\tstrscpy(params->channel, strim(test_channel), sizeof(params->channel));\n\tstrscpy(params->device, strim(test_device), sizeof(params->device));\n\tparams->threads_per_chan = threads_per_chan;\n\tparams->max_channels = max_channels;\n\tparams->iterations = iterations;\n\tparams->xor_sources = xor_sources;\n\tparams->pq_sources = pq_sources;\n\tparams->timeout = timeout;\n\tparams->noverify = noverify;\n\tparams->norandom = norandom;\n\tparams->alignment = alignment;\n\tparams->transfer_size = transfer_size;\n\tparams->polled = polled;\n\n\trequest_channels(info, DMA_MEMCPY);\n\trequest_channels(info, DMA_MEMSET);\n\trequest_channels(info, DMA_XOR);\n\trequest_channels(info, DMA_PQ);\n}\n\nstatic void run_pending_tests(struct dmatest_info *info)\n{\n\tstruct dmatest_chan *dtc;\n\tunsigned int thread_count = 0;\n\n\tlist_for_each_entry(dtc, &info->channels, node) {\n\t\tstruct dmatest_thread *thread;\n\n\t\tthread_count = 0;\n\t\tlist_for_each_entry(thread, &dtc->threads, node) {\n\t\t\twake_up_process(thread->task);\n\t\t\tthread_count++;\n\t\t}\n\t\tpr_info(\"Started %u threads using %s\\n\",\n\t\t\tthread_count, dma_chan_name(dtc->chan));\n\t}\n}\n\nstatic void stop_threaded_test(struct dmatest_info *info)\n{\n\tstruct dmatest_chan *dtc, *_dtc;\n\tstruct dma_chan *chan;\n\n\tlist_for_each_entry_safe(dtc, _dtc, &info->channels, node) {\n\t\tlist_del(&dtc->node);\n\t\tchan = dtc->chan;\n\t\tdmatest_cleanup_channel(dtc);\n\t\tpr_debug(\"dropped channel %s\\n\", dma_chan_name(chan));\n\t\tdma_release_channel(chan);\n\t}\n\n\tinfo->nr_channels = 0;\n}\n\nstatic void start_threaded_tests(struct dmatest_info *info)\n{\n\t \n\tif (!info->did_init)\n\t\treturn;\n\n\trun_pending_tests(info);\n}\n\nstatic int dmatest_run_get(char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\n\tmutex_lock(&info->lock);\n\tif (is_threaded_test_run(info)) {\n\t\tdmatest_run = true;\n\t} else {\n\t\tif (!is_threaded_test_pending(info))\n\t\t\tstop_threaded_test(info);\n\t\tdmatest_run = false;\n\t}\n\tmutex_unlock(&info->lock);\n\n\treturn param_get_bool(val, kp);\n}\n\nstatic int dmatest_run_set(const char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = param_set_bool(val, kp);\n\tif (ret) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn ret;\n\t} else if (dmatest_run) {\n\t\tif (!is_threaded_test_pending(info)) {\n\t\t\t \n\t\t\tret = info->last_error;\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tpr_err(\"Channel misconfigured, can't continue\\n\");\n\t\t\t\tmutex_unlock(&info->lock);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpr_info(\"No channels configured, continue with any\\n\");\n\t\t\t\tif (!is_threaded_test_run(info))\n\t\t\t\t\tstop_threaded_test(info);\n\t\t\t\tadd_threaded_test(info);\n\t\t\t}\n\t\t}\n\t\tstart_threaded_tests(info);\n\t} else {\n\t\tstop_threaded_test(info);\n\t}\n\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic int dmatest_chan_set(const char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\tstruct dmatest_chan *dtc;\n\tchar chan_reset_val[20];\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = param_set_copystring(val, kp);\n\tif (ret) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn ret;\n\t}\n\t \n\tif (!is_threaded_test_run(info) && !is_threaded_test_pending(info))\n\t\tstop_threaded_test(info);\n\t \n\tif (is_threaded_test_pending(info)) {\n\t\tlist_for_each_entry(dtc, &info->channels, node) {\n\t\t\tif (strcmp(dma_chan_name(dtc->chan),\n\t\t\t\t   strim(test_channel)) == 0) {\n\t\t\t\tdtc = list_last_entry(&info->channels,\n\t\t\t\t\t\t      struct dmatest_chan,\n\t\t\t\t\t\t      node);\n\t\t\t\tstrscpy(chan_reset_val,\n\t\t\t\t\tdma_chan_name(dtc->chan),\n\t\t\t\t\tsizeof(chan_reset_val));\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto add_chan_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tadd_threaded_test(info);\n\n\t \n\tif (!list_empty(&info->channels)) {\n\t\t \n\t\tdtc = list_last_entry(&info->channels, struct dmatest_chan, node);\n\t\tif ((strcmp(dma_chan_name(dtc->chan), strim(test_channel)) != 0)\n\t\t    && (strcmp(\"\", strim(test_channel)) != 0)) {\n\t\t\tret = -EINVAL;\n\t\t\tstrscpy(chan_reset_val, dma_chan_name(dtc->chan),\n\t\t\t\tsizeof(chan_reset_val));\n\t\t\tgoto add_chan_err;\n\t\t}\n\n\t} else {\n\t\t \n\t\tstrscpy(chan_reset_val, \"\", sizeof(chan_reset_val));\n\t\tret = -EBUSY;\n\t\tgoto add_chan_err;\n\t}\n\n\tinfo->last_error = ret;\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n\nadd_chan_err:\n\tparam_set_copystring(chan_reset_val, kp);\n\tinfo->last_error = ret;\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic int dmatest_chan_get(char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\n\tmutex_lock(&info->lock);\n\tif (!is_threaded_test_run(info) && !is_threaded_test_pending(info)) {\n\t\tstop_threaded_test(info);\n\t\tstrscpy(test_channel, \"\", sizeof(test_channel));\n\t}\n\tmutex_unlock(&info->lock);\n\n\treturn param_get_string(val, kp);\n}\n\nstatic int dmatest_test_list_get(char *val, const struct kernel_param *kp)\n{\n\tstruct dmatest_info *info = &test_info;\n\tstruct dmatest_chan *dtc;\n\tunsigned int thread_count = 0;\n\n\tlist_for_each_entry(dtc, &info->channels, node) {\n\t\tstruct dmatest_thread *thread;\n\n\t\tthread_count = 0;\n\t\tlist_for_each_entry(thread, &dtc->threads, node) {\n\t\t\tthread_count++;\n\t\t}\n\t\tpr_info(\"%u threads using %s\\n\",\n\t\t\tthread_count, dma_chan_name(dtc->chan));\n\t}\n\n\treturn 0;\n}\n\nstatic int __init dmatest_init(void)\n{\n\tstruct dmatest_info *info = &test_info;\n\tstruct dmatest_params *params = &info->params;\n\n\tif (dmatest_run) {\n\t\tmutex_lock(&info->lock);\n\t\tadd_threaded_test(info);\n\t\trun_pending_tests(info);\n\t\tmutex_unlock(&info->lock);\n\t}\n\n\tif (params->iterations && wait)\n\t\twait_event(thread_wait, !is_threaded_test_run(info));\n\n\t \n\tinfo->did_init = true;\n\n\treturn 0;\n}\n \nlate_initcall(dmatest_init);\n\nstatic void __exit dmatest_exit(void)\n{\n\tstruct dmatest_info *info = &test_info;\n\n\tmutex_lock(&info->lock);\n\tstop_threaded_test(info);\n\tmutex_unlock(&info->lock);\n}\nmodule_exit(dmatest_exit);\n\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}