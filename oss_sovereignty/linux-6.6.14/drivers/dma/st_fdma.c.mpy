{
  "module_name": "st_fdma.c",
  "hash_id": "25efc467ed1c7b80778b91f0234e3054a886172e933f05424f0f66325ed50e41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/st_fdma.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/remoteproc.h>\n#include <linux/slab.h>\n\n#include \"st_fdma.h\"\n\nstatic inline struct st_fdma_chan *to_st_fdma_chan(struct dma_chan *c)\n{\n\treturn container_of(c, struct st_fdma_chan, vchan.chan);\n}\n\nstatic struct st_fdma_desc *to_st_fdma_desc(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct st_fdma_desc, vdesc);\n}\n\nstatic int st_fdma_dreq_get(struct st_fdma_chan *fchan)\n{\n\tstruct st_fdma_dev *fdev = fchan->fdev;\n\tu32 req_line_cfg = fchan->cfg.req_line;\n\tu32 dreq_line;\n\tint try = 0;\n\n\t \n\tdo {\n\t\tif (fdev->dreq_mask == ~0L) {\n\t\t\tdev_err(fdev->dev, \"No req lines available\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (try || req_line_cfg >= ST_FDMA_NR_DREQS) {\n\t\t\tdev_err(fdev->dev, \"Invalid or used req line\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tdreq_line = req_line_cfg;\n\t\t}\n\n\t\ttry++;\n\t} while (test_and_set_bit(dreq_line, &fdev->dreq_mask));\n\n\tdev_dbg(fdev->dev, \"get dreq_line:%d mask:%#lx\\n\",\n\t\tdreq_line, fdev->dreq_mask);\n\n\treturn dreq_line;\n}\n\nstatic void st_fdma_dreq_put(struct st_fdma_chan *fchan)\n{\n\tstruct st_fdma_dev *fdev = fchan->fdev;\n\n\tdev_dbg(fdev->dev, \"put dreq_line:%#x\\n\", fchan->dreq_line);\n\tclear_bit(fchan->dreq_line, &fdev->dreq_mask);\n}\n\nstatic void st_fdma_xfer_desc(struct st_fdma_chan *fchan)\n{\n\tstruct virt_dma_desc *vdesc;\n\tunsigned long nbytes, ch_cmd, cmd;\n\n\tvdesc = vchan_next_desc(&fchan->vchan);\n\tif (!vdesc)\n\t\treturn;\n\n\tfchan->fdesc = to_st_fdma_desc(vdesc);\n\tnbytes = fchan->fdesc->node[0].desc->nbytes;\n\tcmd = FDMA_CMD_START(fchan->vchan.chan.chan_id);\n\tch_cmd = fchan->fdesc->node[0].pdesc | FDMA_CH_CMD_STA_START;\n\n\t \n\tfnode_write(fchan, nbytes, FDMA_CNTN_OFST);\n\tfchan_write(fchan, ch_cmd, FDMA_CH_CMD_OFST);\n\twritel(cmd,\n\t\tfchan->fdev->slim_rproc->peri + FDMA_CMD_SET_OFST);\n\n\tdev_dbg(fchan->fdev->dev, \"start chan:%d\\n\", fchan->vchan.chan.chan_id);\n}\n\nstatic void st_fdma_ch_sta_update(struct st_fdma_chan *fchan,\n\t\t\t\t  unsigned long int_sta)\n{\n\tunsigned long ch_sta, ch_err;\n\tint ch_id = fchan->vchan.chan.chan_id;\n\tstruct st_fdma_dev *fdev = fchan->fdev;\n\n\tch_sta = fchan_read(fchan, FDMA_CH_CMD_OFST);\n\tch_err = ch_sta & FDMA_CH_CMD_ERR_MASK;\n\tch_sta &= FDMA_CH_CMD_STA_MASK;\n\n\tif (int_sta & FDMA_INT_STA_ERR) {\n\t\tdev_warn(fdev->dev, \"chan:%d, error:%ld\\n\", ch_id, ch_err);\n\t\tfchan->status = DMA_ERROR;\n\t\treturn;\n\t}\n\n\tswitch (ch_sta) {\n\tcase FDMA_CH_CMD_STA_PAUSED:\n\t\tfchan->status = DMA_PAUSED;\n\t\tbreak;\n\n\tcase FDMA_CH_CMD_STA_RUNNING:\n\t\tfchan->status = DMA_IN_PROGRESS;\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t st_fdma_irq_handler(int irq, void *dev_id)\n{\n\tstruct st_fdma_dev *fdev = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct st_fdma_chan *fchan = &fdev->chans[0];\n\tunsigned long int_sta, clr;\n\n\tint_sta = fdma_read(fdev, FDMA_INT_STA_OFST);\n\tclr = int_sta;\n\n\tfor (; int_sta != 0 ; int_sta >>= 2, fchan++) {\n\t\tif (!(int_sta & (FDMA_INT_STA_CH | FDMA_INT_STA_ERR)))\n\t\t\tcontinue;\n\n\t\tspin_lock(&fchan->vchan.lock);\n\t\tst_fdma_ch_sta_update(fchan, int_sta);\n\n\t\tif (fchan->fdesc) {\n\t\t\tif (!fchan->fdesc->iscyclic) {\n\t\t\t\tlist_del(&fchan->fdesc->vdesc.node);\n\t\t\t\tvchan_cookie_complete(&fchan->fdesc->vdesc);\n\t\t\t\tfchan->fdesc = NULL;\n\t\t\t\tfchan->status = DMA_COMPLETE;\n\t\t\t} else {\n\t\t\t\tvchan_cyclic_callback(&fchan->fdesc->vdesc);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!fchan->fdesc)\n\t\t\t\tst_fdma_xfer_desc(fchan);\n\t\t}\n\n\t\tspin_unlock(&fchan->vchan.lock);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tfdma_write(fdev, clr, FDMA_INT_CLR_OFST);\n\n\treturn ret;\n}\n\nstatic struct dma_chan *st_fdma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t struct of_dma *ofdma)\n{\n\tstruct st_fdma_dev *fdev = ofdma->of_dma_data;\n\tstruct dma_chan *chan;\n\tstruct st_fdma_chan *fchan;\n\tint ret;\n\n\tif (dma_spec->args_count < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (fdev->dma_device.dev->of_node != dma_spec->np)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = rproc_boot(fdev->slim_rproc->rproc);\n\tif (ret == -ENOENT)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\telse if (ret)\n\t\treturn ERR_PTR(ret);\n\n\tchan = dma_get_any_slave_channel(&fdev->dma_device);\n\tif (!chan)\n\t\tgoto err_chan;\n\n\tfchan = to_st_fdma_chan(chan);\n\n\tfchan->cfg.of_node = dma_spec->np;\n\tfchan->cfg.req_line = dma_spec->args[0];\n\tfchan->cfg.req_ctrl = 0;\n\tfchan->cfg.type = ST_FDMA_TYPE_FREE_RUN;\n\n\tif (dma_spec->args_count > 1)\n\t\tfchan->cfg.req_ctrl = dma_spec->args[1]\n\t\t\t& FDMA_REQ_CTRL_CFG_MASK;\n\n\tif (dma_spec->args_count > 2)\n\t\tfchan->cfg.type = dma_spec->args[2];\n\n\tif (fchan->cfg.type == ST_FDMA_TYPE_FREE_RUN) {\n\t\tfchan->dreq_line = 0;\n\t} else {\n\t\tfchan->dreq_line = st_fdma_dreq_get(fchan);\n\t\tif (IS_ERR_VALUE(fchan->dreq_line)) {\n\t\t\tchan = ERR_PTR(fchan->dreq_line);\n\t\t\tgoto err_chan;\n\t\t}\n\t}\n\n\tdev_dbg(fdev->dev, \"xlate req_line:%d type:%d req_ctrl:%#lx\\n\",\n\t\tfchan->cfg.req_line, fchan->cfg.type, fchan->cfg.req_ctrl);\n\n\treturn chan;\n\nerr_chan:\n\trproc_shutdown(fdev->slim_rproc->rproc);\n\treturn chan;\n\n}\n\nstatic void st_fdma_free_desc(struct virt_dma_desc *vdesc)\n{\n\tstruct st_fdma_desc *fdesc;\n\tint i;\n\n\tfdesc = to_st_fdma_desc(vdesc);\n\tfor (i = 0; i < fdesc->n_nodes; i++)\n\t\tdma_pool_free(fdesc->fchan->node_pool, fdesc->node[i].desc,\n\t\t\t      fdesc->node[i].pdesc);\n\tkfree(fdesc);\n}\n\nstatic struct st_fdma_desc *st_fdma_alloc_desc(struct st_fdma_chan *fchan,\n\t\t\t\t\t       int sg_len)\n{\n\tstruct st_fdma_desc *fdesc;\n\tint i;\n\n\tfdesc = kzalloc(struct_size(fdesc, node, sg_len), GFP_NOWAIT);\n\tif (!fdesc)\n\t\treturn NULL;\n\n\tfdesc->fchan = fchan;\n\tfdesc->n_nodes = sg_len;\n\tfor (i = 0; i < sg_len; i++) {\n\t\tfdesc->node[i].desc = dma_pool_alloc(fchan->node_pool,\n\t\t\t\tGFP_NOWAIT, &fdesc->node[i].pdesc);\n\t\tif (!fdesc->node[i].desc)\n\t\t\tgoto err;\n\t}\n\treturn fdesc;\n\nerr:\n\twhile (--i >= 0)\n\t\tdma_pool_free(fchan->node_pool, fdesc->node[i].desc,\n\t\t\t      fdesc->node[i].pdesc);\n\tkfree(fdesc);\n\treturn NULL;\n}\n\nstatic int st_fdma_alloc_chan_res(struct dma_chan *chan)\n{\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\n\t \n\tfchan->node_pool = dma_pool_create(dev_name(&chan->dev->device),\n\t\t\t\t\t    fchan->fdev->dev,\n\t\t\t\t\t    sizeof(struct st_fdma_hw_node),\n\t\t\t\t\t    __alignof__(struct st_fdma_hw_node),\n\t\t\t\t\t    0);\n\n\tif (!fchan->node_pool) {\n\t\tdev_err(fchan->fdev->dev, \"unable to allocate desc pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(fchan->fdev->dev, \"alloc ch_id:%d type:%d\\n\",\n\t\tfchan->vchan.chan.chan_id, fchan->cfg.type);\n\n\treturn 0;\n}\n\nstatic void st_fdma_free_chan_res(struct dma_chan *chan)\n{\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tstruct rproc *rproc = fchan->fdev->slim_rproc->rproc;\n\tunsigned long flags;\n\n\tdev_dbg(fchan->fdev->dev, \"%s: freeing chan:%d\\n\",\n\t\t__func__, fchan->vchan.chan.chan_id);\n\n\tif (fchan->cfg.type != ST_FDMA_TYPE_FREE_RUN)\n\t\tst_fdma_dreq_put(fchan);\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\tfchan->fdesc = NULL;\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n\n\tdma_pool_destroy(fchan->node_pool);\n\tfchan->node_pool = NULL;\n\tmemset(&fchan->cfg, 0, sizeof(struct st_fdma_cfg));\n\n\trproc_shutdown(rproc);\n}\n\nstatic struct dma_async_tx_descriptor *st_fdma_prep_dma_memcpy(\n\tstruct dma_chan *chan,\tdma_addr_t dst, dma_addr_t src,\n\tsize_t len, unsigned long flags)\n{\n\tstruct st_fdma_chan *fchan;\n\tstruct st_fdma_desc *fdesc;\n\tstruct st_fdma_hw_node *hw_node;\n\n\tif (!len)\n\t\treturn NULL;\n\n\tfchan = to_st_fdma_chan(chan);\n\n\t \n\tfdesc = st_fdma_alloc_desc(fchan, 1);\n\tif (!fdesc) {\n\t\tdev_err(fchan->fdev->dev, \"no memory for desc\\n\");\n\t\treturn NULL;\n\t}\n\n\thw_node = fdesc->node[0].desc;\n\thw_node->next = 0;\n\thw_node->control = FDMA_NODE_CTRL_REQ_MAP_FREE_RUN;\n\thw_node->control |= FDMA_NODE_CTRL_SRC_INCR;\n\thw_node->control |= FDMA_NODE_CTRL_DST_INCR;\n\thw_node->control |= FDMA_NODE_CTRL_INT_EON;\n\thw_node->nbytes = len;\n\thw_node->saddr = src;\n\thw_node->daddr = dst;\n\thw_node->generic.length = len;\n\thw_node->generic.sstride = 0;\n\thw_node->generic.dstride = 0;\n\n\treturn vchan_tx_prep(&fchan->vchan, &fdesc->vdesc, flags);\n}\n\nstatic int config_reqctrl(struct st_fdma_chan *fchan,\n\t\t\t  enum dma_transfer_direction direction)\n{\n\tu32 maxburst = 0, addr = 0;\n\tenum dma_slave_buswidth width;\n\tint ch_id = fchan->vchan.chan.chan_id;\n\tstruct st_fdma_dev *fdev = fchan->fdev;\n\n\tswitch (direction) {\n\n\tcase DMA_DEV_TO_MEM:\n\t\tfchan->cfg.req_ctrl &= ~FDMA_REQ_CTRL_WNR;\n\t\tmaxburst = fchan->scfg.src_maxburst;\n\t\twidth = fchan->scfg.src_addr_width;\n\t\taddr = fchan->scfg.src_addr;\n\t\tbreak;\n\n\tcase DMA_MEM_TO_DEV:\n\t\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_WNR;\n\t\tmaxburst = fchan->scfg.dst_maxburst;\n\t\twidth = fchan->scfg.dst_addr_width;\n\t\taddr = fchan->scfg.dst_addr;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfchan->cfg.req_ctrl &= ~FDMA_REQ_CTRL_OPCODE_MASK;\n\n\tswitch (width) {\n\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_OPCODE_LD_ST1;\n\t\tbreak;\n\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_OPCODE_LD_ST2;\n\t\tbreak;\n\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_OPCODE_LD_ST4;\n\t\tbreak;\n\n\tcase DMA_SLAVE_BUSWIDTH_8_BYTES:\n\t\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_OPCODE_LD_ST8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfchan->cfg.req_ctrl &= ~FDMA_REQ_CTRL_NUM_OPS_MASK;\n\tfchan->cfg.req_ctrl |= FDMA_REQ_CTRL_NUM_OPS(maxburst-1);\n\tdreq_write(fchan, fchan->cfg.req_ctrl, FDMA_REQ_CTRL_OFST);\n\n\tfchan->cfg.dev_addr = addr;\n\tfchan->cfg.dir = direction;\n\n\tdev_dbg(fdev->dev, \"chan:%d config_reqctrl:%#x req_ctrl:%#lx\\n\",\n\t\tch_id, addr, fchan->cfg.req_ctrl);\n\n\treturn 0;\n}\n\nstatic void fill_hw_node(struct st_fdma_hw_node *hw_node,\n\t\t\tstruct st_fdma_chan *fchan,\n\t\t\tenum dma_transfer_direction direction)\n{\n\tif (direction == DMA_MEM_TO_DEV) {\n\t\thw_node->control |= FDMA_NODE_CTRL_SRC_INCR;\n\t\thw_node->control |= FDMA_NODE_CTRL_DST_STATIC;\n\t\thw_node->daddr = fchan->cfg.dev_addr;\n\t} else {\n\t\thw_node->control |= FDMA_NODE_CTRL_SRC_STATIC;\n\t\thw_node->control |= FDMA_NODE_CTRL_DST_INCR;\n\t\thw_node->saddr = fchan->cfg.dev_addr;\n\t}\n\n\thw_node->generic.sstride = 0;\n\thw_node->generic.dstride = 0;\n}\n\nstatic inline struct st_fdma_chan *st_fdma_prep_common(struct dma_chan *chan,\n\t\tsize_t len, enum dma_transfer_direction direction)\n{\n\tstruct st_fdma_chan *fchan;\n\n\tif (!chan || !len)\n\t\treturn NULL;\n\n\tfchan = to_st_fdma_chan(chan);\n\n\tif (!is_slave_direction(direction)) {\n\t\tdev_err(fchan->fdev->dev, \"bad direction?\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn fchan;\n}\n\nstatic struct dma_async_tx_descriptor *st_fdma_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t buf_addr, size_t len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct st_fdma_chan *fchan;\n\tstruct st_fdma_desc *fdesc;\n\tint sg_len, i;\n\n\tfchan = st_fdma_prep_common(chan, len, direction);\n\tif (!fchan)\n\t\treturn NULL;\n\n\tif (!period_len)\n\t\treturn NULL;\n\n\tif (config_reqctrl(fchan, direction)) {\n\t\tdev_err(fchan->fdev->dev, \"bad width or direction\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (len % period_len != 0) {\n\t\tdev_err(fchan->fdev->dev, \"len is not multiple of period\\n\");\n\t\treturn NULL;\n\t}\n\n\tsg_len = len / period_len;\n\tfdesc = st_fdma_alloc_desc(fchan, sg_len);\n\tif (!fdesc) {\n\t\tdev_err(fchan->fdev->dev, \"no memory for desc\\n\");\n\t\treturn NULL;\n\t}\n\n\tfdesc->iscyclic = true;\n\n\tfor (i = 0; i < sg_len; i++) {\n\t\tstruct st_fdma_hw_node *hw_node = fdesc->node[i].desc;\n\n\t\thw_node->next = fdesc->node[(i + 1) % sg_len].pdesc;\n\n\t\thw_node->control =\n\t\t\tFDMA_NODE_CTRL_REQ_MAP_DREQ(fchan->dreq_line);\n\t\thw_node->control |= FDMA_NODE_CTRL_INT_EON;\n\n\t\tfill_hw_node(hw_node, fchan, direction);\n\n\t\tif (direction == DMA_MEM_TO_DEV)\n\t\t\thw_node->saddr = buf_addr + (i * period_len);\n\t\telse\n\t\t\thw_node->daddr = buf_addr + (i * period_len);\n\n\t\thw_node->nbytes = period_len;\n\t\thw_node->generic.length = period_len;\n\t}\n\n\treturn vchan_tx_prep(&fchan->vchan, &fdesc->vdesc, flags);\n}\n\nstatic struct dma_async_tx_descriptor *st_fdma_prep_slave_sg(\n\t\tstruct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct st_fdma_chan *fchan;\n\tstruct st_fdma_desc *fdesc;\n\tstruct st_fdma_hw_node *hw_node;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfchan = st_fdma_prep_common(chan, sg_len, direction);\n\tif (!fchan)\n\t\treturn NULL;\n\n\tif (!sgl)\n\t\treturn NULL;\n\n\tfdesc = st_fdma_alloc_desc(fchan, sg_len);\n\tif (!fdesc) {\n\t\tdev_err(fchan->fdev->dev, \"no memory for desc\\n\");\n\t\treturn NULL;\n\t}\n\n\tfdesc->iscyclic = false;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\thw_node = fdesc->node[i].desc;\n\n\t\thw_node->next = fdesc->node[(i + 1) % sg_len].pdesc;\n\t\thw_node->control = FDMA_NODE_CTRL_REQ_MAP_DREQ(fchan->dreq_line);\n\n\t\tfill_hw_node(hw_node, fchan, direction);\n\n\t\tif (direction == DMA_MEM_TO_DEV)\n\t\t\thw_node->saddr = sg_dma_address(sg);\n\t\telse\n\t\t\thw_node->daddr = sg_dma_address(sg);\n\n\t\thw_node->nbytes = sg_dma_len(sg);\n\t\thw_node->generic.length = sg_dma_len(sg);\n\t}\n\n\t \n\thw_node->control |= FDMA_NODE_CTRL_INT_EON;\n\n\treturn vchan_tx_prep(&fchan->vchan, &fdesc->vdesc, flags);\n}\n\nstatic size_t st_fdma_desc_residue(struct st_fdma_chan *fchan,\n\t\t\t\t   struct virt_dma_desc *vdesc,\n\t\t\t\t   bool in_progress)\n{\n\tstruct st_fdma_desc *fdesc = fchan->fdesc;\n\tsize_t residue = 0;\n\tdma_addr_t cur_addr = 0;\n\tint i;\n\n\tif (in_progress) {\n\t\tcur_addr = fchan_read(fchan, FDMA_CH_CMD_OFST);\n\t\tcur_addr &= FDMA_CH_CMD_DATA_MASK;\n\t}\n\n\tfor (i = fchan->fdesc->n_nodes - 1 ; i >= 0; i--) {\n\t\tif (cur_addr == fdesc->node[i].pdesc) {\n\t\t\tresidue += fnode_read(fchan, FDMA_CNTN_OFST);\n\t\t\tbreak;\n\t\t}\n\t\tresidue += fdesc->node[i].desc->nbytes;\n\t}\n\n\treturn residue;\n}\n\nstatic enum dma_status st_fdma_tx_status(struct dma_chan *chan,\n\t\t\t\t\t dma_cookie_t cookie,\n\t\t\t\t\t struct dma_tx_state *txstate)\n{\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tstruct virt_dma_desc *vd;\n\tenum dma_status ret;\n\tunsigned long flags;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret == DMA_COMPLETE || !txstate)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\tvd = vchan_find_desc(&fchan->vchan, cookie);\n\tif (fchan->fdesc && cookie == fchan->fdesc->vdesc.tx.cookie)\n\t\ttxstate->residue = st_fdma_desc_residue(fchan, vd, true);\n\telse if (vd)\n\t\ttxstate->residue = st_fdma_desc_residue(fchan, vd, false);\n\telse\n\t\ttxstate->residue = 0;\n\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n\n\treturn ret;\n}\n\nstatic void st_fdma_issue_pending(struct dma_chan *chan)\n{\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\n\tif (vchan_issue_pending(&fchan->vchan) && !fchan->fdesc)\n\t\tst_fdma_xfer_desc(fchan);\n\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n}\n\nstatic int st_fdma_pause(struct dma_chan *chan)\n{\n\tunsigned long flags;\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tint ch_id = fchan->vchan.chan.chan_id;\n\tunsigned long cmd = FDMA_CMD_PAUSE(ch_id);\n\n\tdev_dbg(fchan->fdev->dev, \"pause chan:%d\\n\", ch_id);\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\tif (fchan->fdesc)\n\t\tfdma_write(fchan->fdev, cmd, FDMA_CMD_SET_OFST);\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n\n\treturn 0;\n}\n\nstatic int st_fdma_resume(struct dma_chan *chan)\n{\n\tunsigned long flags;\n\tunsigned long val;\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tint ch_id = fchan->vchan.chan.chan_id;\n\n\tdev_dbg(fchan->fdev->dev, \"resume chan:%d\\n\", ch_id);\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\tif (fchan->fdesc) {\n\t\tval = fchan_read(fchan, FDMA_CH_CMD_OFST);\n\t\tval &= FDMA_CH_CMD_DATA_MASK;\n\t\tfchan_write(fchan, val, FDMA_CH_CMD_OFST);\n\t}\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n\n\treturn 0;\n}\n\nstatic int st_fdma_terminate_all(struct dma_chan *chan)\n{\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\tint ch_id = fchan->vchan.chan.chan_id;\n\tunsigned long cmd = FDMA_CMD_PAUSE(ch_id);\n\n\tdev_dbg(fchan->fdev->dev, \"terminate chan:%d\\n\", ch_id);\n\n\tspin_lock_irqsave(&fchan->vchan.lock, flags);\n\tfdma_write(fchan->fdev, cmd, FDMA_CMD_SET_OFST);\n\tfchan->fdesc = NULL;\n\tvchan_get_all_descriptors(&fchan->vchan, &head);\n\tspin_unlock_irqrestore(&fchan->vchan.lock, flags);\n\tvchan_dma_desc_free_list(&fchan->vchan, &head);\n\n\treturn 0;\n}\n\nstatic int st_fdma_slave_config(struct dma_chan *chan,\n\t\t\t\tstruct dma_slave_config *slave_cfg)\n{\n\tstruct st_fdma_chan *fchan = to_st_fdma_chan(chan);\n\n\tmemcpy(&fchan->scfg, slave_cfg, sizeof(fchan->scfg));\n\treturn 0;\n}\n\nstatic const struct st_fdma_driverdata fdma_mpe31_stih407_11 = {\n\t.name = \"STiH407\",\n\t.id = 0,\n};\n\nstatic const struct st_fdma_driverdata fdma_mpe31_stih407_12 = {\n\t.name = \"STiH407\",\n\t.id = 1,\n};\n\nstatic const struct st_fdma_driverdata fdma_mpe31_stih407_13 = {\n\t.name = \"STiH407\",\n\t.id = 2,\n};\n\nstatic const struct of_device_id st_fdma_match[] = {\n\t{ .compatible = \"st,stih407-fdma-mpe31-11\"\n\t  , .data = &fdma_mpe31_stih407_11 },\n\t{ .compatible = \"st,stih407-fdma-mpe31-12\"\n\t  , .data = &fdma_mpe31_stih407_12 },\n\t{ .compatible = \"st,stih407-fdma-mpe31-13\"\n\t  , .data = &fdma_mpe31_stih407_13 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st_fdma_match);\n\nstatic int st_fdma_parse_dt(struct platform_device *pdev,\n\t\t\tconst struct st_fdma_driverdata *drvdata,\n\t\t\tstruct st_fdma_dev *fdev)\n{\n\tsnprintf(fdev->fw_name, FW_NAME_SIZE, \"fdma_%s_%d.elf\",\n\t\tdrvdata->name, drvdata->id);\n\n\treturn of_property_read_u32(pdev->dev.of_node, \"dma-channels\",\n\t\t\t\t    &fdev->nr_channels);\n}\n#define FDMA_DMA_BUSWIDTHS\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_3_BYTES) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))\n\nstatic void st_fdma_free(struct st_fdma_dev *fdev)\n{\n\tstruct st_fdma_chan *fchan;\n\tint i;\n\n\tfor (i = 0; i < fdev->nr_channels; i++) {\n\t\tfchan = &fdev->chans[i];\n\t\tlist_del(&fchan->vchan.chan.device_node);\n\t\ttasklet_kill(&fchan->vchan.task);\n\t}\n}\n\nstatic int st_fdma_probe(struct platform_device *pdev)\n{\n\tstruct st_fdma_dev *fdev;\n\tconst struct of_device_id *match;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct st_fdma_driverdata *drvdata;\n\tint ret, i;\n\n\tmatch = of_match_device((st_fdma_match), &pdev->dev);\n\tif (!match || !match->data) {\n\t\tdev_err(&pdev->dev, \"No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrvdata = match->data;\n\n\tfdev = devm_kzalloc(&pdev->dev, sizeof(*fdev), GFP_KERNEL);\n\tif (!fdev)\n\t\treturn -ENOMEM;\n\n\tret = st_fdma_parse_dt(pdev, drvdata, fdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to find platform data\\n\");\n\t\tgoto err;\n\t}\n\n\tfdev->chans = devm_kcalloc(&pdev->dev, fdev->nr_channels,\n\t\t\t\t   sizeof(struct st_fdma_chan), GFP_KERNEL);\n\tif (!fdev->chans)\n\t\treturn -ENOMEM;\n\n\tfdev->dev = &pdev->dev;\n\tfdev->drvdata = drvdata;\n\tplatform_set_drvdata(pdev, fdev);\n\n\tfdev->irq = platform_get_irq(pdev, 0);\n\tif (fdev->irq < 0)\n\t\treturn -EINVAL;\n\n\tret = devm_request_irq(&pdev->dev, fdev->irq, st_fdma_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), fdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq (%d)\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tfdev->slim_rproc = st_slim_rproc_alloc(pdev, fdev->fw_name);\n\tif (IS_ERR(fdev->slim_rproc)) {\n\t\tret = PTR_ERR(fdev->slim_rproc);\n\t\tdev_err(&pdev->dev, \"slim_rproc_alloc failed (%d)\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&fdev->dma_device.channels);\n\tfor (i = 0; i < fdev->nr_channels; i++) {\n\t\tstruct st_fdma_chan *fchan = &fdev->chans[i];\n\n\t\tfchan->fdev = fdev;\n\t\tfchan->vchan.desc_free = st_fdma_free_desc;\n\t\tvchan_init(&fchan->vchan, &fdev->dma_device);\n\t}\n\n\t \n\tfdev->dreq_mask = BIT(0) | BIT(31);\n\n\tdma_cap_set(DMA_SLAVE, fdev->dma_device.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, fdev->dma_device.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, fdev->dma_device.cap_mask);\n\n\tfdev->dma_device.dev = &pdev->dev;\n\tfdev->dma_device.device_alloc_chan_resources = st_fdma_alloc_chan_res;\n\tfdev->dma_device.device_free_chan_resources = st_fdma_free_chan_res;\n\tfdev->dma_device.device_prep_dma_cyclic\t= st_fdma_prep_dma_cyclic;\n\tfdev->dma_device.device_prep_slave_sg = st_fdma_prep_slave_sg;\n\tfdev->dma_device.device_prep_dma_memcpy = st_fdma_prep_dma_memcpy;\n\tfdev->dma_device.device_tx_status = st_fdma_tx_status;\n\tfdev->dma_device.device_issue_pending = st_fdma_issue_pending;\n\tfdev->dma_device.device_terminate_all = st_fdma_terminate_all;\n\tfdev->dma_device.device_config = st_fdma_slave_config;\n\tfdev->dma_device.device_pause = st_fdma_pause;\n\tfdev->dma_device.device_resume = st_fdma_resume;\n\n\tfdev->dma_device.src_addr_widths = FDMA_DMA_BUSWIDTHS;\n\tfdev->dma_device.dst_addr_widths = FDMA_DMA_BUSWIDTHS;\n\tfdev->dma_device.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tfdev->dma_device.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\n\tret = dmaenginem_async_device_register(&fdev->dma_device);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register DMA device (%d)\\n\", ret);\n\t\tgoto err_rproc;\n\t}\n\n\tret = of_dma_controller_register(np, st_fdma_of_xlate, fdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register controller (%d)\\n\", ret);\n\t\tgoto err_rproc;\n\t}\n\n\tdev_info(&pdev->dev, \"ST FDMA engine driver, irq:%d\\n\", fdev->irq);\n\n\treturn 0;\n\nerr_rproc:\n\tst_fdma_free(fdev);\n\tst_slim_rproc_put(fdev->slim_rproc);\nerr:\n\treturn ret;\n}\n\nstatic int st_fdma_remove(struct platform_device *pdev)\n{\n\tstruct st_fdma_dev *fdev = platform_get_drvdata(pdev);\n\n\tdevm_free_irq(&pdev->dev, fdev->irq, fdev);\n\tst_slim_rproc_put(fdev->slim_rproc);\n\tof_dma_controller_free(pdev->dev.of_node);\n\n\treturn 0;\n}\n\nstatic struct platform_driver st_fdma_platform_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = st_fdma_match,\n\t},\n\t.probe = st_fdma_probe,\n\t.remove = st_fdma_remove,\n};\nmodule_platform_driver(st_fdma_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"STMicroelectronics FDMA engine driver\");\nMODULE_AUTHOR(\"Ludovic.barre <Ludovic.barre@st.com>\");\nMODULE_AUTHOR(\"Peter Griffin <peter.griffin@linaro.org>\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}