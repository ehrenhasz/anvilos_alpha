{
  "module_name": "sram.c",
  "hash_id": "e788e526dda4f77551f0c093f3040e7e40931007d01ea7256afa23e801aa096c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/bestcomm/sram.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include <asm/io.h>\n#include <asm/mmu.h>\n\n#include <linux/fsl/bestcomm/sram.h>\n\n\n \nstruct bcom_sram *bcom_sram = NULL;\nEXPORT_SYMBOL_GPL(bcom_sram);\t \n\n\n \n \n \n \n\nint bcom_sram_init(struct device_node *sram_node, char *owner)\n{\n\tint rv;\n\tconst u32 *regaddr_p;\n\tstruct resource res;\n\tunsigned int psize;\n\n\t \n\tif (bcom_sram) {\n\t\tprintk(KERN_ERR \"%s: bcom_sram_init: \"\n\t\t\t\"Already initialized !\\n\", owner);\n\t\treturn -EBUSY;\n\t}\n\n\tbcom_sram = kmalloc(sizeof(struct bcom_sram), GFP_KERNEL);\n\tif (!bcom_sram) {\n\t\tprintk(KERN_ERR \"%s: bcom_sram_init: \"\n\t\t\t\"Couldn't allocate internal state !\\n\", owner);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trv = of_address_to_resource(sram_node, 0, &res);\n\tif (rv) {\n\t\tprintk(KERN_ERR \"%s: bcom_sram_init: \"\n\t\t\t\"Invalid device node !\\n\", owner);\n\t\tgoto error_free;\n\t}\n\n\tbcom_sram->base_phys = res.start;\n\tbcom_sram->size = resource_size(&res);\n\n\t \n\tif (!request_mem_region(res.start, resource_size(&res), owner)) {\n\t\tprintk(KERN_ERR \"%s: bcom_sram_init: \"\n\t\t\t\"Couldn't request region !\\n\", owner);\n\t\trv = -EBUSY;\n\t\tgoto error_free;\n\t}\n\n\t \n\t\t \n\tbcom_sram->base_virt = (void *)ioremap(res.start, resource_size(&res));\n\n\tif (!bcom_sram->base_virt) {\n\t\tprintk(KERN_ERR \"%s: bcom_sram_init: \"\n\t\t\t\"Map error SRAM zone 0x%08lx (0x%0x)!\\n\",\n\t\t\towner, (long)bcom_sram->base_phys, bcom_sram->size );\n\t\trv = -ENOMEM;\n\t\tgoto error_release;\n\t}\n\n\t \n\tbcom_sram->rh = rh_create(4);\n\n\t \n#if 0\n\t \n\treg_addr_p = of_get_property(sram_node, \"available\", &psize);\n#else\n\tregaddr_p = NULL;\n\tpsize = 0;\n#endif\n\n\tif (!regaddr_p || !psize) {\n\t\t \n\t\trh_attach_region(bcom_sram->rh, 0, bcom_sram->size);\n\t} else {\n\t\t \n\t\twhile (psize >= 2 * sizeof(u32)) {\n\t\t\tphys_addr_t zbase = of_translate_address(sram_node, regaddr_p);\n\t\t\trh_attach_region(bcom_sram->rh, zbase - bcom_sram->base_phys, regaddr_p[1]);\n\t\t\tregaddr_p += 2;\n\t\t\tpsize -= 2 * sizeof(u32);\n\t\t}\n\t}\n\n\t \n\tspin_lock_init(&bcom_sram->lock);\n\n\treturn 0;\n\nerror_release:\n\trelease_mem_region(res.start, resource_size(&res));\nerror_free:\n\tkfree(bcom_sram);\n\tbcom_sram = NULL;\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(bcom_sram_init);\n\nvoid bcom_sram_cleanup(void)\n{\n\t \n\tif (bcom_sram) {\n\t\trh_destroy(bcom_sram->rh);\n\t\tiounmap((void __iomem *)bcom_sram->base_virt);\n\t\trelease_mem_region(bcom_sram->base_phys, bcom_sram->size);\n\t\tkfree(bcom_sram);\n\t\tbcom_sram = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(bcom_sram_cleanup);\n\nvoid* bcom_sram_alloc(int size, int align, phys_addr_t *phys)\n{\n\tunsigned long offset;\n\n\tspin_lock(&bcom_sram->lock);\n\toffset = rh_alloc_align(bcom_sram->rh, size, align, NULL);\n\tspin_unlock(&bcom_sram->lock);\n\n\tif (IS_ERR_VALUE(offset))\n\t\treturn NULL;\n\n\t*phys = bcom_sram->base_phys + offset;\n\treturn bcom_sram->base_virt + offset;\n}\nEXPORT_SYMBOL_GPL(bcom_sram_alloc);\n\nvoid bcom_sram_free(void *ptr)\n{\n\tunsigned long offset;\n\n\tif (!ptr)\n\t\treturn;\n\n\toffset = ptr - bcom_sram->base_virt;\n\n\tspin_lock(&bcom_sram->lock);\n\trh_free(bcom_sram->rh, offset);\n\tspin_unlock(&bcom_sram->lock);\n}\nEXPORT_SYMBOL_GPL(bcom_sram_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}