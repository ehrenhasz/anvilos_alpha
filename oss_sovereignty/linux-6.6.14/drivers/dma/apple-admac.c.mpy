{
  "module_name": "apple-admac.c",
  "hash_id": "5f7628ec8187b0972c0b2ec2ebbb41070f55c6e93ec811dc834a97f37056d2fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/apple-admac.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n\n#include \"dmaengine.h\"\n\n#define NCHANNELS_MAX\t64\n#define IRQ_NOUTPUTS\t4\n\n \n#define SRAM_BLOCK\t2048\n\n#define RING_WRITE_SLOT\t\tGENMASK(1, 0)\n#define RING_READ_SLOT\t\tGENMASK(5, 4)\n#define RING_FULL\t\tBIT(9)\n#define RING_EMPTY\t\tBIT(8)\n#define RING_ERR\t\tBIT(10)\n\n#define STATUS_DESC_DONE\tBIT(0)\n#define STATUS_ERR\t\tBIT(6)\n\n#define FLAG_DESC_NOTIFY\tBIT(16)\n\n#define REG_TX_START\t\t0x0000\n#define REG_TX_STOP\t\t0x0004\n#define REG_RX_START\t\t0x0008\n#define REG_RX_STOP\t\t0x000c\n#define REG_IMPRINT\t\t0x0090\n#define REG_TX_SRAM_SIZE\t0x0094\n#define REG_RX_SRAM_SIZE\t0x0098\n\n#define REG_CHAN_CTL(ch)\t(0x8000 + (ch) * 0x200)\n#define REG_CHAN_CTL_RST_RINGS\tBIT(0)\n\n#define REG_DESC_RING(ch)\t(0x8070 + (ch) * 0x200)\n#define REG_REPORT_RING(ch)\t(0x8074 + (ch) * 0x200)\n\n#define REG_RESIDUE(ch)\t\t(0x8064 + (ch) * 0x200)\n\n#define REG_BUS_WIDTH(ch)\t(0x8040 + (ch) * 0x200)\n\n#define BUS_WIDTH_8BIT\t\t0x00\n#define BUS_WIDTH_16BIT\t\t0x01\n#define BUS_WIDTH_32BIT\t\t0x02\n#define BUS_WIDTH_FRAME_2_WORDS\t0x10\n#define BUS_WIDTH_FRAME_4_WORDS\t0x20\n\n#define REG_CHAN_SRAM_CARVEOUT(ch)\t(0x8050 + (ch) * 0x200)\n#define CHAN_SRAM_CARVEOUT_SIZE\t\tGENMASK(31, 16)\n#define CHAN_SRAM_CARVEOUT_BASE\t\tGENMASK(15, 0)\n\n#define REG_CHAN_FIFOCTL(ch)\t(0x8054 + (ch) * 0x200)\n#define CHAN_FIFOCTL_LIMIT\tGENMASK(31, 16)\n#define CHAN_FIFOCTL_THRESHOLD\tGENMASK(15, 0)\n\n#define REG_DESC_WRITE(ch)\t(0x10000 + ((ch) / 2) * 0x4 + ((ch) & 1) * 0x4000)\n#define REG_REPORT_READ(ch)\t(0x10100 + ((ch) / 2) * 0x4 + ((ch) & 1) * 0x4000)\n\n#define REG_TX_INTSTATE(idx)\t\t(0x0030 + (idx) * 4)\n#define REG_RX_INTSTATE(idx)\t\t(0x0040 + (idx) * 4)\n#define REG_GLOBAL_INTSTATE(idx)\t(0x0050 + (idx) * 4)\n#define REG_CHAN_INTSTATUS(ch, idx)\t(0x8010 + (ch) * 0x200 + (idx) * 4)\n#define REG_CHAN_INTMASK(ch, idx)\t(0x8020 + (ch) * 0x200 + (idx) * 4)\n\nstruct admac_data;\nstruct admac_tx;\n\nstruct admac_chan {\n\tunsigned int no;\n\tstruct admac_data *host;\n\tstruct dma_chan chan;\n\tstruct tasklet_struct tasklet;\n\n\tu32 carveout;\n\n\tspinlock_t lock;\n\tstruct admac_tx *current_tx;\n\tint nperiod_acks;\n\n\t \n\tstruct list_head submitted;\n\tstruct list_head issued;\n\n\tstruct list_head to_free;\n};\n\nstruct admac_sram {\n\tu32 size;\n\t \n\tu32 allocated;\n};\n\nstruct admac_data {\n\tstruct dma_device dma;\n\tstruct device *dev;\n\t__iomem void *base;\n\tstruct reset_control *rstc;\n\n\tstruct mutex cache_alloc_lock;\n\tstruct admac_sram txcache, rxcache;\n\n\tint irq;\n\tint irq_index;\n\tint nchannels;\n\tstruct admac_chan channels[];\n};\n\nstruct admac_tx {\n\tstruct dma_async_tx_descriptor tx;\n\tbool cyclic;\n\tdma_addr_t buf_addr;\n\tdma_addr_t buf_end;\n\tsize_t buf_len;\n\tsize_t period_len;\n\n\tsize_t submitted_pos;\n\tsize_t reclaimed_pos;\n\n\tstruct list_head node;\n};\n\nstatic int admac_alloc_sram_carveout(struct admac_data *ad,\n\t\t\t\t     enum dma_transfer_direction dir,\n\t\t\t\t     u32 *out)\n{\n\tstruct admac_sram *sram;\n\tint i, ret = 0, nblocks;\n\n\tif (dir == DMA_MEM_TO_DEV)\n\t\tsram = &ad->txcache;\n\telse\n\t\tsram = &ad->rxcache;\n\n\tmutex_lock(&ad->cache_alloc_lock);\n\n\tnblocks = sram->size / SRAM_BLOCK;\n\tfor (i = 0; i < nblocks; i++)\n\t\tif (!(sram->allocated & BIT(i)))\n\t\t\tbreak;\n\n\tif (i < nblocks) {\n\t\t*out = FIELD_PREP(CHAN_SRAM_CARVEOUT_BASE, i * SRAM_BLOCK) |\n\t\t\tFIELD_PREP(CHAN_SRAM_CARVEOUT_SIZE, SRAM_BLOCK);\n\t\tsram->allocated |= BIT(i);\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\n\tmutex_unlock(&ad->cache_alloc_lock);\n\n\treturn ret;\n}\n\nstatic void admac_free_sram_carveout(struct admac_data *ad,\n\t\t\t\t     enum dma_transfer_direction dir,\n\t\t\t\t     u32 carveout)\n{\n\tstruct admac_sram *sram;\n\tu32 base = FIELD_GET(CHAN_SRAM_CARVEOUT_BASE, carveout);\n\tint i;\n\n\tif (dir == DMA_MEM_TO_DEV)\n\t\tsram = &ad->txcache;\n\telse\n\t\tsram = &ad->rxcache;\n\n\tif (WARN_ON(base >= sram->size))\n\t\treturn;\n\n\tmutex_lock(&ad->cache_alloc_lock);\n\ti = base / SRAM_BLOCK;\n\tsram->allocated &= ~BIT(i);\n\tmutex_unlock(&ad->cache_alloc_lock);\n}\n\nstatic void admac_modify(struct admac_data *ad, int reg, u32 mask, u32 val)\n{\n\tvoid __iomem *addr = ad->base + reg;\n\tu32 curr = readl_relaxed(addr);\n\n\twritel_relaxed((curr & ~mask) | (val & mask), addr);\n}\n\nstatic struct admac_chan *to_admac_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct admac_chan, chan);\n}\n\nstatic struct admac_tx *to_admac_tx(struct dma_async_tx_descriptor *tx)\n{\n\treturn container_of(tx, struct admac_tx, tx);\n}\n\nstatic enum dma_transfer_direction admac_chan_direction(int channo)\n{\n\t \n\treturn (channo & 1) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\n}\n\nstatic dma_cookie_t admac_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct admac_tx *adtx = to_admac_tx(tx);\n\tstruct admac_chan *adchan = to_admac_chan(tx->chan);\n\tunsigned long flags;\n\tdma_cookie_t cookie;\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tcookie = dma_cookie_assign(tx);\n\tlist_add_tail(&adtx->node, &adchan->submitted);\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n\n\treturn cookie;\n}\n\nstatic int admac_desc_free(struct dma_async_tx_descriptor *tx)\n{\n\tkfree(to_admac_tx(tx));\n\n\treturn 0;\n}\n\nstatic struct dma_async_tx_descriptor *admac_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct admac_chan *adchan = container_of(chan, struct admac_chan, chan);\n\tstruct admac_tx *adtx;\n\n\tif (direction != admac_chan_direction(adchan->no))\n\t\treturn NULL;\n\n\tadtx = kzalloc(sizeof(*adtx), GFP_NOWAIT);\n\tif (!adtx)\n\t\treturn NULL;\n\n\tadtx->cyclic = true;\n\n\tadtx->buf_addr = buf_addr;\n\tadtx->buf_len = buf_len;\n\tadtx->buf_end = buf_addr + buf_len;\n\tadtx->period_len = period_len;\n\n\tadtx->submitted_pos = 0;\n\tadtx->reclaimed_pos = 0;\n\n\tdma_async_tx_descriptor_init(&adtx->tx, chan);\n\tadtx->tx.tx_submit = admac_tx_submit;\n\tadtx->tx.desc_free = admac_desc_free;\n\n\treturn &adtx->tx;\n}\n\n \nstatic void admac_cyclic_write_one_desc(struct admac_data *ad, int channo,\n\t\t\t\t\tstruct admac_tx *tx)\n{\n\tdma_addr_t addr;\n\n\taddr = tx->buf_addr + (tx->submitted_pos % tx->buf_len);\n\n\t \n\tWARN_ON_ONCE(addr + tx->period_len > tx->buf_end);\n\n\tdev_dbg(ad->dev, \"ch%d descriptor: addr=0x%pad len=0x%zx flags=0x%lx\\n\",\n\t\tchanno, &addr, tx->period_len, FLAG_DESC_NOTIFY);\n\n\twritel_relaxed(lower_32_bits(addr), ad->base + REG_DESC_WRITE(channo));\n\twritel_relaxed(upper_32_bits(addr), ad->base + REG_DESC_WRITE(channo));\n\twritel_relaxed(tx->period_len,      ad->base + REG_DESC_WRITE(channo));\n\twritel_relaxed(FLAG_DESC_NOTIFY,    ad->base + REG_DESC_WRITE(channo));\n\n\ttx->submitted_pos += tx->period_len;\n\ttx->submitted_pos %= 2 * tx->buf_len;\n}\n\n \nstatic void admac_cyclic_write_desc(struct admac_data *ad, int channo,\n\t\t\t\t    struct admac_tx *tx)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (readl_relaxed(ad->base + REG_DESC_RING(channo)) & RING_FULL)\n\t\t\tbreak;\n\t\tadmac_cyclic_write_one_desc(ad, channo, tx);\n\t}\n}\n\nstatic int admac_ring_noccupied_slots(int ringval)\n{\n\tint wrslot = FIELD_GET(RING_WRITE_SLOT, ringval);\n\tint rdslot = FIELD_GET(RING_READ_SLOT, ringval);\n\n\tif (wrslot != rdslot) {\n\t\treturn (wrslot + 4 - rdslot) % 4;\n\t} else {\n\t\tWARN_ON((ringval & (RING_FULL | RING_EMPTY)) == 0);\n\n\t\tif (ringval & RING_FULL)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\n \nstatic u32 admac_cyclic_read_residue(struct admac_data *ad, int channo,\n\t\t\t\t     struct admac_tx *adtx)\n{\n\tu32 ring1, ring2;\n\tu32 residue1, residue2;\n\tint nreports;\n\tsize_t pos;\n\n\tring1 =    readl_relaxed(ad->base + REG_REPORT_RING(channo));\n\tresidue1 = readl_relaxed(ad->base + REG_RESIDUE(channo));\n\tring2 =    readl_relaxed(ad->base + REG_REPORT_RING(channo));\n\tresidue2 = readl_relaxed(ad->base + REG_RESIDUE(channo));\n\n\tif (residue2 > residue1) {\n\t\t \n\t\tnreports = admac_ring_noccupied_slots(ring1) + 1;\n\t} else {\n\t\t \n\t\tnreports = admac_ring_noccupied_slots(ring2);\n\t}\n\n\tpos = adtx->reclaimed_pos + adtx->period_len * (nreports + 1) - residue2;\n\n\treturn adtx->buf_len - pos % adtx->buf_len;\n}\n\nstatic enum dma_status admac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\n\t\t\t\t       struct dma_tx_state *txstate)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_data *ad = adchan->host;\n\tstruct admac_tx *adtx;\n\n\tenum dma_status ret;\n\tsize_t residue;\n\tunsigned long flags;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret == DMA_COMPLETE || !txstate)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tadtx = adchan->current_tx;\n\n\tif (adtx && adtx->tx.cookie == cookie) {\n\t\tret = DMA_IN_PROGRESS;\n\t\tresidue = admac_cyclic_read_residue(ad, adchan->no, adtx);\n\t} else {\n\t\tret = DMA_IN_PROGRESS;\n\t\tresidue = 0;\n\t\tlist_for_each_entry(adtx, &adchan->issued, node) {\n\t\t\tif (adtx->tx.cookie == cookie) {\n\t\t\t\tresidue = adtx->buf_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n\n\tdma_set_residue(txstate, residue);\n\treturn ret;\n}\n\nstatic void admac_start_chan(struct admac_chan *adchan)\n{\n\tstruct admac_data *ad = adchan->host;\n\tu32 startbit = 1 << (adchan->no / 2);\n\n\twritel_relaxed(STATUS_DESC_DONE | STATUS_ERR,\n\t\t       ad->base + REG_CHAN_INTSTATUS(adchan->no, ad->irq_index));\n\twritel_relaxed(STATUS_DESC_DONE | STATUS_ERR,\n\t\t       ad->base + REG_CHAN_INTMASK(adchan->no, ad->irq_index));\n\n\tswitch (admac_chan_direction(adchan->no)) {\n\tcase DMA_MEM_TO_DEV:\n\t\twritel_relaxed(startbit, ad->base + REG_TX_START);\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\twritel_relaxed(startbit, ad->base + REG_RX_START);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_dbg(adchan->host->dev, \"ch%d start\\n\", adchan->no);\n}\n\nstatic void admac_stop_chan(struct admac_chan *adchan)\n{\n\tstruct admac_data *ad = adchan->host;\n\tu32 stopbit = 1 << (adchan->no / 2);\n\n\tswitch (admac_chan_direction(adchan->no)) {\n\tcase DMA_MEM_TO_DEV:\n\t\twritel_relaxed(stopbit, ad->base + REG_TX_STOP);\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\twritel_relaxed(stopbit, ad->base + REG_RX_STOP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_dbg(adchan->host->dev, \"ch%d stop\\n\", adchan->no);\n}\n\nstatic void admac_reset_rings(struct admac_chan *adchan)\n{\n\tstruct admac_data *ad = adchan->host;\n\n\twritel_relaxed(REG_CHAN_CTL_RST_RINGS,\n\t\t       ad->base + REG_CHAN_CTL(adchan->no));\n\twritel_relaxed(0, ad->base + REG_CHAN_CTL(adchan->no));\n}\n\nstatic void admac_start_current_tx(struct admac_chan *adchan)\n{\n\tstruct admac_data *ad = adchan->host;\n\tint ch = adchan->no;\n\n\tadmac_reset_rings(adchan);\n\twritel_relaxed(0, ad->base + REG_CHAN_CTL(ch));\n\n\tadmac_cyclic_write_one_desc(ad, ch, adchan->current_tx);\n\tadmac_start_chan(adchan);\n\tadmac_cyclic_write_desc(ad, ch, adchan->current_tx);\n}\n\nstatic void admac_issue_pending(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_tx *tx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tlist_splice_tail_init(&adchan->submitted, &adchan->issued);\n\tif (!list_empty(&adchan->issued) && !adchan->current_tx) {\n\t\ttx = list_first_entry(&adchan->issued, struct admac_tx, node);\n\t\tlist_del(&tx->node);\n\n\t\tadchan->current_tx = tx;\n\t\tadchan->nperiod_acks = 0;\n\t\tadmac_start_current_tx(adchan);\n\t}\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n}\n\nstatic int admac_pause(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\n\tadmac_stop_chan(adchan);\n\n\treturn 0;\n}\n\nstatic int admac_resume(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\n\tadmac_start_chan(adchan);\n\n\treturn 0;\n}\n\nstatic int admac_terminate_all(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tadmac_stop_chan(adchan);\n\tadmac_reset_rings(adchan);\n\n\tif (adchan->current_tx) {\n\t\tlist_add_tail(&adchan->current_tx->node, &adchan->to_free);\n\t\tadchan->current_tx = NULL;\n\t}\n\t \n\tlist_splice_tail_init(&adchan->submitted, &adchan->to_free);\n\tlist_splice_tail_init(&adchan->issued, &adchan->to_free);\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n\n\treturn 0;\n}\n\nstatic void admac_synchronize(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_tx *adtx, *_adtx;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tlist_splice_tail_init(&adchan->to_free, &head);\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n\n\ttasklet_kill(&adchan->tasklet);\n\n\tlist_for_each_entry_safe(adtx, _adtx, &head, node) {\n\t\tlist_del(&adtx->node);\n\t\tadmac_desc_free(&adtx->tx);\n\t}\n}\n\nstatic int admac_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_data *ad = adchan->host;\n\tint ret;\n\n\tdma_cookie_init(&adchan->chan);\n\tret = admac_alloc_sram_carveout(ad, admac_chan_direction(adchan->no),\n\t\t\t\t\t&adchan->carveout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel_relaxed(adchan->carveout,\n\t\t       ad->base + REG_CHAN_SRAM_CARVEOUT(adchan->no));\n\treturn 0;\n}\n\nstatic void admac_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\n\tadmac_terminate_all(chan);\n\tadmac_synchronize(chan);\n\tadmac_free_sram_carveout(adchan->host, admac_chan_direction(adchan->no),\n\t\t\t\t adchan->carveout);\n}\n\nstatic struct dma_chan *admac_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct admac_data *ad = (struct admac_data *) ofdma->of_dma_data;\n\tunsigned int index;\n\n\tif (dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\tindex = dma_spec->args[0];\n\n\tif (index >= ad->nchannels) {\n\t\tdev_err(ad->dev, \"channel index %u out of bounds\\n\", index);\n\t\treturn NULL;\n\t}\n\n\treturn dma_get_slave_channel(&ad->channels[index].chan);\n}\n\nstatic int admac_drain_reports(struct admac_data *ad, int channo)\n{\n\tint count;\n\n\tfor (count = 0; count < 4; count++) {\n\t\tu32 countval_hi, countval_lo, unk1, flags;\n\n\t\tif (readl_relaxed(ad->base + REG_REPORT_RING(channo)) & RING_EMPTY)\n\t\t\tbreak;\n\n\t\tcountval_lo = readl_relaxed(ad->base + REG_REPORT_READ(channo));\n\t\tcountval_hi = readl_relaxed(ad->base + REG_REPORT_READ(channo));\n\t\tunk1 =        readl_relaxed(ad->base + REG_REPORT_READ(channo));\n\t\tflags =       readl_relaxed(ad->base + REG_REPORT_READ(channo));\n\n\t\tdev_dbg(ad->dev, \"ch%d report: countval=0x%llx unk1=0x%x flags=0x%x\\n\",\n\t\t\tchanno, ((u64) countval_hi) << 32 | countval_lo, unk1, flags);\n\t}\n\n\treturn count;\n}\n\nstatic void admac_handle_status_err(struct admac_data *ad, int channo)\n{\n\tbool handled = false;\n\n\tif (readl_relaxed(ad->base + REG_DESC_RING(channo)) & RING_ERR) {\n\t\twritel_relaxed(RING_ERR, ad->base + REG_DESC_RING(channo));\n\t\tdev_err_ratelimited(ad->dev, \"ch%d descriptor ring error\\n\", channo);\n\t\thandled = true;\n\t}\n\n\tif (readl_relaxed(ad->base + REG_REPORT_RING(channo)) & RING_ERR) {\n\t\twritel_relaxed(RING_ERR, ad->base + REG_REPORT_RING(channo));\n\t\tdev_err_ratelimited(ad->dev, \"ch%d report ring error\\n\", channo);\n\t\thandled = true;\n\t}\n\n\tif (unlikely(!handled)) {\n\t\tdev_err(ad->dev, \"ch%d unknown error, masking errors as cause of IRQs\\n\", channo);\n\t\tadmac_modify(ad, REG_CHAN_INTMASK(channo, ad->irq_index),\n\t\t\t     STATUS_ERR, 0);\n\t}\n}\n\nstatic void admac_handle_status_desc_done(struct admac_data *ad, int channo)\n{\n\tstruct admac_chan *adchan = &ad->channels[channo];\n\tunsigned long flags;\n\tint nreports;\n\n\twritel_relaxed(STATUS_DESC_DONE,\n\t\t       ad->base + REG_CHAN_INTSTATUS(channo, ad->irq_index));\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tnreports = admac_drain_reports(ad, channo);\n\n\tif (adchan->current_tx) {\n\t\tstruct admac_tx *tx = adchan->current_tx;\n\n\t\tadchan->nperiod_acks += nreports;\n\t\ttx->reclaimed_pos += nreports * tx->period_len;\n\t\ttx->reclaimed_pos %= 2 * tx->buf_len;\n\n\t\tadmac_cyclic_write_desc(ad, channo, tx);\n\t\ttasklet_schedule(&adchan->tasklet);\n\t}\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n}\n\nstatic void admac_handle_chan_int(struct admac_data *ad, int no)\n{\n\tu32 cause = readl_relaxed(ad->base + REG_CHAN_INTSTATUS(no, ad->irq_index));\n\n\tif (cause & STATUS_ERR)\n\t\tadmac_handle_status_err(ad, no);\n\n\tif (cause & STATUS_DESC_DONE)\n\t\tadmac_handle_status_desc_done(ad, no);\n}\n\nstatic irqreturn_t admac_interrupt(int irq, void *devid)\n{\n\tstruct admac_data *ad = devid;\n\tu32 rx_intstate, tx_intstate, global_intstate;\n\tint i;\n\n\trx_intstate = readl_relaxed(ad->base + REG_RX_INTSTATE(ad->irq_index));\n\ttx_intstate = readl_relaxed(ad->base + REG_TX_INTSTATE(ad->irq_index));\n\tglobal_intstate = readl_relaxed(ad->base + REG_GLOBAL_INTSTATE(ad->irq_index));\n\n\tif (!tx_intstate && !rx_intstate && !global_intstate)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < ad->nchannels; i += 2) {\n\t\tif (tx_intstate & 1)\n\t\t\tadmac_handle_chan_int(ad, i);\n\t\ttx_intstate >>= 1;\n\t}\n\n\tfor (i = 1; i < ad->nchannels; i += 2) {\n\t\tif (rx_intstate & 1)\n\t\t\tadmac_handle_chan_int(ad, i);\n\t\trx_intstate >>= 1;\n\t}\n\n\tif (global_intstate) {\n\t\tdev_warn(ad->dev, \"clearing unknown global interrupt flag: %x\\n\",\n\t\t\t global_intstate);\n\t\twritel_relaxed(~(u32) 0, ad->base + REG_GLOBAL_INTSTATE(ad->irq_index));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void admac_chan_tasklet(struct tasklet_struct *t)\n{\n\tstruct admac_chan *adchan = from_tasklet(adchan, t, tasklet);\n\tstruct admac_tx *adtx;\n\tstruct dmaengine_desc_callback cb;\n\tstruct dmaengine_result tx_result;\n\tint nacks;\n\n\tspin_lock_irq(&adchan->lock);\n\tadtx = adchan->current_tx;\n\tnacks = adchan->nperiod_acks;\n\tadchan->nperiod_acks = 0;\n\tspin_unlock_irq(&adchan->lock);\n\n\tif (!adtx || !nacks)\n\t\treturn;\n\n\ttx_result.result = DMA_TRANS_NOERROR;\n\ttx_result.residue = 0;\n\n\tdmaengine_desc_get_callback(&adtx->tx, &cb);\n\twhile (nacks--)\n\t\tdmaengine_desc_callback_invoke(&cb, &tx_result);\n}\n\nstatic int admac_device_config(struct dma_chan *chan,\n\t\t\t       struct dma_slave_config *config)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_data *ad = adchan->host;\n\tbool is_tx = admac_chan_direction(adchan->no) == DMA_MEM_TO_DEV;\n\tint wordsize = 0;\n\tu32 bus_width = 0;\n\n\tswitch (is_tx ? config->dst_addr_width : config->src_addr_width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\twordsize = 1;\n\t\tbus_width |= BUS_WIDTH_8BIT;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\twordsize = 2;\n\t\tbus_width |= BUS_WIDTH_16BIT;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\twordsize = 4;\n\t\tbus_width |= BUS_WIDTH_32BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (is_tx ? config->dst_port_window_size : config->src_port_window_size) {\n\tcase 0 ... 1:\n\t\tbreak;\n\tcase 2:\n\t\tbus_width |= BUS_WIDTH_FRAME_2_WORDS;\n\t\tbreak;\n\tcase 4:\n\t\tbus_width |= BUS_WIDTH_FRAME_4_WORDS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(bus_width, ad->base + REG_BUS_WIDTH(adchan->no));\n\n\t \n\twritel_relaxed(FIELD_PREP(CHAN_FIFOCTL_LIMIT, 0x30 * wordsize)\n\t\t       | FIELD_PREP(CHAN_FIFOCTL_THRESHOLD, 0x18 * wordsize),\n\t\t       ad->base + REG_CHAN_FIFOCTL(adchan->no));\n\n\treturn 0;\n}\n\nstatic int admac_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct admac_data *ad;\n\tstruct dma_device *dma;\n\tint nchannels;\n\tint err, irq, i;\n\n\terr = of_property_read_u32(np, \"dma-channels\", &nchannels);\n\tif (err || nchannels > NCHANNELS_MAX) {\n\t\tdev_err(&pdev->dev, \"missing or invalid dma-channels property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tad = devm_kzalloc(&pdev->dev, struct_size(ad, channels, nchannels), GFP_KERNEL);\n\tif (!ad)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ad);\n\tad->dev = &pdev->dev;\n\tad->nchannels = nchannels;\n\tmutex_init(&ad->cache_alloc_lock);\n\n\t \n\tfor (i = 0; i < IRQ_NOUTPUTS; i++) {\n\t\tirq = platform_get_irq_optional(pdev, i);\n\t\tif (irq >= 0) {\n\t\t\tad->irq_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (irq < 0)\n\t\treturn dev_err_probe(&pdev->dev, irq, \"no usable interrupt\\n\");\n\tad->irq = irq;\n\n\tad->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ad->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ad->base),\n\t\t\t\t     \"unable to obtain MMIO resource\\n\");\n\n\tad->rstc = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(ad->rstc))\n\t\treturn PTR_ERR(ad->rstc);\n\n\tdma = &ad->dma;\n\n\tdma_cap_set(DMA_PRIVATE, dma->cap_mask);\n\tdma_cap_set(DMA_CYCLIC, dma->cap_mask);\n\n\tdma->dev = &pdev->dev;\n\tdma->device_alloc_chan_resources = admac_alloc_chan_resources;\n\tdma->device_free_chan_resources = admac_free_chan_resources;\n\tdma->device_tx_status = admac_tx_status;\n\tdma->device_issue_pending = admac_issue_pending;\n\tdma->device_terminate_all = admac_terminate_all;\n\tdma->device_synchronize = admac_synchronize;\n\tdma->device_prep_dma_cyclic = admac_prep_dma_cyclic;\n\tdma->device_config = admac_device_config;\n\tdma->device_pause = admac_pause;\n\tdma->device_resume = admac_resume;\n\n\tdma->directions = BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\n\tdma->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tdma->src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tdma->dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\n\tINIT_LIST_HEAD(&dma->channels);\n\tfor (i = 0; i < nchannels; i++) {\n\t\tstruct admac_chan *adchan = &ad->channels[i];\n\n\t\tadchan->host = ad;\n\t\tadchan->no = i;\n\t\tadchan->chan.device = &ad->dma;\n\t\tspin_lock_init(&adchan->lock);\n\t\tINIT_LIST_HEAD(&adchan->submitted);\n\t\tINIT_LIST_HEAD(&adchan->issued);\n\t\tINIT_LIST_HEAD(&adchan->to_free);\n\t\tlist_add_tail(&adchan->chan.device_node, &dma->channels);\n\t\ttasklet_setup(&adchan->tasklet, admac_chan_tasklet);\n\t}\n\n\terr = reset_control_reset(ad->rstc);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"unable to trigger reset\\n\");\n\n\terr = request_irq(irq, admac_interrupt, 0, dev_name(&pdev->dev), ad);\n\tif (err) {\n\t\tdev_err_probe(&pdev->dev, err,\n\t\t\t\t\"unable to register interrupt\\n\");\n\t\tgoto free_reset;\n\t}\n\n\terr = dma_async_device_register(&ad->dma);\n\tif (err) {\n\t\tdev_err_probe(&pdev->dev, err, \"failed to register DMA device\\n\");\n\t\tgoto free_irq;\n\t}\n\n\terr = of_dma_controller_register(pdev->dev.of_node, admac_dma_of_xlate, ad);\n\tif (err) {\n\t\tdma_async_device_unregister(&ad->dma);\n\t\tdev_err_probe(&pdev->dev, err, \"failed to register with OF\\n\");\n\t\tgoto free_irq;\n\t}\n\n\tad->txcache.size = readl_relaxed(ad->base + REG_TX_SRAM_SIZE);\n\tad->rxcache.size = readl_relaxed(ad->base + REG_RX_SRAM_SIZE);\n\n\tdev_info(&pdev->dev, \"Audio DMA Controller\\n\");\n\tdev_info(&pdev->dev, \"imprint %x TX cache %u RX cache %u\\n\",\n\t\t readl_relaxed(ad->base + REG_IMPRINT), ad->txcache.size, ad->rxcache.size);\n\n\treturn 0;\n\nfree_irq:\n\tfree_irq(ad->irq, ad);\nfree_reset:\n\treset_control_rearm(ad->rstc);\n\treturn err;\n}\n\nstatic int admac_remove(struct platform_device *pdev)\n{\n\tstruct admac_data *ad = platform_get_drvdata(pdev);\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&ad->dma);\n\tfree_irq(ad->irq, ad);\n\treset_control_rearm(ad->rstc);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id admac_of_match[] = {\n\t{ .compatible = \"apple,admac\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, admac_of_match);\n\nstatic struct platform_driver apple_admac_driver = {\n\t.driver = {\n\t\t.name = \"apple-admac\",\n\t\t.of_match_table = admac_of_match,\n\t},\n\t.probe = admac_probe,\n\t.remove = admac_remove,\n};\nmodule_platform_driver(apple_admac_driver);\n\nMODULE_AUTHOR(\"Martin Povi\u0161er <povik+lin@cutebit.org>\");\nMODULE_DESCRIPTION(\"Driver for Audio DMA Controller (ADMAC) on Apple SoCs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}