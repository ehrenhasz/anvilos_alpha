{
  "module_name": "amba-pl08x.c",
  "hash_id": "3faa1bc038fb7af978ab0dc7c3152a81906e35fb6b361d774ef7ed68411a551a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/amba-pl08x.c",
  "human_readable_source": "\n \n#include <linux/amba/bus.h>\n#include <linux/amba/pl08x.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/amba/pl080.h>\n\n#include \"dmaengine.h\"\n#include \"virt-dma.h\"\n\n#define DRIVER_NAME\t\"pl08xdmac\"\n\n#define PL80X_DMA_BUSWIDTHS \\\n\tBIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES)\n\nstatic struct amba_driver pl08x_amba_driver;\nstruct pl08x_driver_data;\n\n \nstruct vendor_data {\n\tu8 config_offset;\n\tu8 channels;\n\tu8 signals;\n\tbool dualmaster;\n\tbool nomadik;\n\tbool pl080s;\n\tbool ftdmac020;\n\tu32 max_transfer_size;\n};\n\n \nstruct pl08x_bus_data {\n\tdma_addr_t addr;\n\tu8 maxwidth;\n\tu8 buswidth;\n};\n\n#define IS_BUS_ALIGNED(bus) IS_ALIGNED((bus)->addr, (bus)->buswidth)\n\n \nstruct pl08x_phy_chan {\n\tunsigned int id;\n\tvoid __iomem *base;\n\tvoid __iomem *reg_config;\n\tvoid __iomem *reg_control;\n\tvoid __iomem *reg_src;\n\tvoid __iomem *reg_dst;\n\tvoid __iomem *reg_lli;\n\tvoid __iomem *reg_busy;\n\tspinlock_t lock;\n\tstruct pl08x_dma_chan *serving;\n\tbool locked;\n\tbool ftdmac020;\n\tbool pl080s;\n};\n\n \nstruct pl08x_sg {\n\tdma_addr_t src_addr;\n\tdma_addr_t dst_addr;\n\tsize_t len;\n\tstruct list_head node;\n};\n\n \nstruct pl08x_txd {\n\tstruct virt_dma_desc vd;\n\tstruct list_head dsg_list;\n\tdma_addr_t llis_bus;\n\tu32 *llis_va;\n\t \n\tu32 cctl;\n\t \n\tu32 ccfg;\n\tbool done;\n\tbool cyclic;\n};\n\n \nenum pl08x_dma_chan_state {\n\tPL08X_CHAN_IDLE,\n\tPL08X_CHAN_RUNNING,\n\tPL08X_CHAN_PAUSED,\n\tPL08X_CHAN_WAITING,\n};\n\n \nstruct pl08x_dma_chan {\n\tstruct virt_dma_chan vc;\n\tstruct pl08x_phy_chan *phychan;\n\tconst char *name;\n\tstruct pl08x_channel_data *cd;\n\tstruct dma_slave_config cfg;\n\tstruct pl08x_txd *at;\n\tstruct pl08x_driver_data *host;\n\tenum pl08x_dma_chan_state state;\n\tbool slave;\n\tint signal;\n\tunsigned mux_use;\n\tunsigned long waiting_at;\n};\n\n \nstruct pl08x_driver_data {\n\tstruct dma_device slave;\n\tstruct dma_device memcpy;\n\tbool has_slave;\n\tvoid __iomem *base;\n\tstruct amba_device *adev;\n\tconst struct vendor_data *vd;\n\tstruct pl08x_platform_data *pd;\n\tstruct pl08x_phy_chan *phy_chans;\n\tstruct dma_pool *pool;\n\tu8 lli_buses;\n\tu8 mem_buses;\n\tu8 lli_words;\n};\n\n \n\n \n#define PL080_LLI_SRC\t\t0\n#define PL080_LLI_DST\t\t1\n#define PL080_LLI_LLI\t\t2\n#define PL080_LLI_CCTL\t\t3\n#define PL080S_LLI_CCTL2\t4\n\n \n#define PL080_LLI_WORDS\t\t4\n#define PL080S_LLI_WORDS\t8\n\n \n#define MAX_NUM_TSFR_LLIS\t512\n#define PL08X_ALIGN\t\t8\n\nstatic inline struct pl08x_dma_chan *to_pl08x_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct pl08x_dma_chan, vc.chan);\n}\n\nstatic inline struct pl08x_txd *to_pl08x_txd(struct dma_async_tx_descriptor *tx)\n{\n\treturn container_of(tx, struct pl08x_txd, vd.tx);\n}\n\n \nstatic int pl08x_request_mux(struct pl08x_dma_chan *plchan)\n{\n\tconst struct pl08x_platform_data *pd = plchan->host->pd;\n\tint ret;\n\n\tif (plchan->mux_use++ == 0 && pd->get_xfer_signal) {\n\t\tret = pd->get_xfer_signal(plchan->cd);\n\t\tif (ret < 0) {\n\t\t\tplchan->mux_use = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tplchan->signal = ret;\n\t}\n\treturn 0;\n}\n\nstatic void pl08x_release_mux(struct pl08x_dma_chan *plchan)\n{\n\tconst struct pl08x_platform_data *pd = plchan->host->pd;\n\n\tif (plchan->signal >= 0) {\n\t\tWARN_ON(plchan->mux_use == 0);\n\n\t\tif (--plchan->mux_use == 0 && pd->put_xfer_signal) {\n\t\t\tpd->put_xfer_signal(plchan->cd, plchan->signal);\n\t\t\tplchan->signal = -1;\n\t\t}\n\t}\n}\n\n \n\n \nstatic int pl08x_phy_channel_busy(struct pl08x_phy_chan *ch)\n{\n\tunsigned int val;\n\n\t \n\tif (ch->reg_busy) {\n\t\tval = readl(ch->reg_busy);\n\t\treturn !!(val & BIT(ch->id));\n\t}\n\tval = readl(ch->reg_config);\n\treturn val & PL080_CONFIG_ACTIVE;\n}\n\n \nstatic void pl08x_write_lli(struct pl08x_driver_data *pl08x,\n\t\tstruct pl08x_phy_chan *phychan, const u32 *lli, u32 ccfg)\n{\n\tif (pl08x->vd->pl080s)\n\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\"WRITE channel %d: csrc=0x%08x, cdst=0x%08x, \"\n\t\t\t\"clli=0x%08x, cctl=0x%08x, cctl2=0x%08x, ccfg=0x%08x\\n\",\n\t\t\tphychan->id, lli[PL080_LLI_SRC], lli[PL080_LLI_DST],\n\t\t\tlli[PL080_LLI_LLI], lli[PL080_LLI_CCTL],\n\t\t\tlli[PL080S_LLI_CCTL2], ccfg);\n\telse\n\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\"WRITE channel %d: csrc=0x%08x, cdst=0x%08x, \"\n\t\t\t\"clli=0x%08x, cctl=0x%08x, ccfg=0x%08x\\n\",\n\t\t\tphychan->id, lli[PL080_LLI_SRC], lli[PL080_LLI_DST],\n\t\t\tlli[PL080_LLI_LLI], lli[PL080_LLI_CCTL], ccfg);\n\n\twritel_relaxed(lli[PL080_LLI_SRC], phychan->reg_src);\n\twritel_relaxed(lli[PL080_LLI_DST], phychan->reg_dst);\n\twritel_relaxed(lli[PL080_LLI_LLI], phychan->reg_lli);\n\n\t \n\tif (phychan->ftdmac020) {\n\t\tu32 llictl = lli[PL080_LLI_CCTL];\n\t\tu32 val = 0;\n\n\t\t \n\t\twritel_relaxed(llictl & FTDMAC020_LLI_TRANSFER_SIZE_MASK,\n\t\t\t       phychan->base + FTDMAC020_CH_SIZE);\n\t\t \n\t\tif (llictl & FTDMAC020_LLI_TC_MSK)\n\t\t\tval |= FTDMAC020_CH_CSR_TC_MSK;\n\t\tval |= ((llictl  & FTDMAC020_LLI_SRC_WIDTH_MSK) >>\n\t\t\t(FTDMAC020_LLI_SRC_WIDTH_SHIFT -\n\t\t\t FTDMAC020_CH_CSR_SRC_WIDTH_SHIFT));\n\t\tval |= ((llictl  & FTDMAC020_LLI_DST_WIDTH_MSK) >>\n\t\t\t(FTDMAC020_LLI_DST_WIDTH_SHIFT -\n\t\t\t FTDMAC020_CH_CSR_DST_WIDTH_SHIFT));\n\t\tval |= ((llictl  & FTDMAC020_LLI_SRCAD_CTL_MSK) >>\n\t\t\t(FTDMAC020_LLI_SRCAD_CTL_SHIFT -\n\t\t\t FTDMAC020_CH_CSR_SRCAD_CTL_SHIFT));\n\t\tval |= ((llictl  & FTDMAC020_LLI_DSTAD_CTL_MSK) >>\n\t\t\t(FTDMAC020_LLI_DSTAD_CTL_SHIFT -\n\t\t\t FTDMAC020_CH_CSR_DSTAD_CTL_SHIFT));\n\t\tif (llictl & FTDMAC020_LLI_SRC_SEL)\n\t\t\tval |= FTDMAC020_CH_CSR_SRC_SEL;\n\t\tif (llictl & FTDMAC020_LLI_DST_SEL)\n\t\t\tval |= FTDMAC020_CH_CSR_DST_SEL;\n\n\t\t \n\t\tswitch (pl08x->pd->memcpy_burst_size) {\n\t\tdefault:\n\t\tcase PL08X_BURST_SZ_1:\n\t\t\tval |= PL080_BSIZE_1 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_4:\n\t\t\tval |= PL080_BSIZE_4 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_8:\n\t\t\tval |= PL080_BSIZE_8 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_16:\n\t\t\tval |= PL080_BSIZE_16 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_32:\n\t\t\tval |= PL080_BSIZE_32 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_64:\n\t\t\tval |= PL080_BSIZE_64 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_128:\n\t\t\tval |= PL080_BSIZE_128 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\tcase PL08X_BURST_SZ_256:\n\t\t\tval |= PL080_BSIZE_256 <<\n\t\t\t\tFTDMAC020_CH_CSR_SRC_SIZE_SHIFT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (pl08x->pd->memcpy_prot_buff)\n\t\t\tval |= FTDMAC020_CH_CSR_PROT2;\n\t\tif (pl08x->pd->memcpy_prot_cache)\n\t\t\tval |= FTDMAC020_CH_CSR_PROT3;\n\t\t \n\t\tval |= FTDMAC020_CH_CSR_PROT1;\n\n\t\twritel_relaxed(val, phychan->reg_control);\n\t} else {\n\t\t \n\t\twritel_relaxed(lli[PL080_LLI_CCTL], phychan->reg_control);\n\t}\n\n\t \n\tif (pl08x->vd->pl080s)\n\t\twritel_relaxed(lli[PL080S_LLI_CCTL2],\n\t\t\t\tphychan->base + PL080S_CH_CONTROL2);\n\n\twritel(ccfg, phychan->reg_config);\n}\n\n \nstatic void pl08x_start_next_txd(struct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_phy_chan *phychan = plchan->phychan;\n\tstruct virt_dma_desc *vd = vchan_next_desc(&plchan->vc);\n\tstruct pl08x_txd *txd = to_pl08x_txd(&vd->tx);\n\tu32 val;\n\n\tlist_del(&txd->vd.node);\n\n\tplchan->at = txd;\n\n\t \n\twhile (pl08x_phy_channel_busy(phychan))\n\t\tcpu_relax();\n\n\tpl08x_write_lli(pl08x, phychan, &txd->llis_va[0], txd->ccfg);\n\n\t \n\t \n\twhile (readl(pl08x->base + PL080_EN_CHAN) & BIT(phychan->id))\n\t\tcpu_relax();\n\n\t \n\tif (phychan->ftdmac020) {\n\t\tval = readl(phychan->reg_config);\n\t\twhile (val & FTDMAC020_CH_CFG_BUSY)\n\t\t\tval = readl(phychan->reg_config);\n\n\t\tval = readl(phychan->reg_control);\n\t\twhile (val & FTDMAC020_CH_CSR_EN)\n\t\t\tval = readl(phychan->reg_control);\n\n\t\twritel(val | FTDMAC020_CH_CSR_EN,\n\t\t       phychan->reg_control);\n\t} else {\n\t\tval = readl(phychan->reg_config);\n\t\twhile ((val & PL080_CONFIG_ACTIVE) ||\n\t\t       (val & PL080_CONFIG_ENABLE))\n\t\t\tval = readl(phychan->reg_config);\n\n\t\twritel(val | PL080_CONFIG_ENABLE, phychan->reg_config);\n\t}\n}\n\n \nstatic void pl08x_pause_phy_chan(struct pl08x_phy_chan *ch)\n{\n\tu32 val;\n\tint timeout;\n\n\tif (ch->ftdmac020) {\n\t\t \n\t\tval = readl(ch->reg_control);\n\t\tval &= ~FTDMAC020_CH_CSR_EN;\n\t\twritel(val, ch->reg_control);\n\t\treturn;\n\t}\n\n\t \n\tval = readl(ch->reg_config);\n\tval |= PL080_CONFIG_HALT;\n\twritel(val, ch->reg_config);\n\n\t \n\tfor (timeout = 1000; timeout; timeout--) {\n\t\tif (!pl08x_phy_channel_busy(ch))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (pl08x_phy_channel_busy(ch))\n\t\tpr_err(\"pl08x: channel%u timeout waiting for pause\\n\", ch->id);\n}\n\nstatic void pl08x_resume_phy_chan(struct pl08x_phy_chan *ch)\n{\n\tu32 val;\n\n\t \n\tif (ch->ftdmac020) {\n\t\tval = readl(ch->reg_control);\n\t\tval |= FTDMAC020_CH_CSR_EN;\n\t\twritel(val, ch->reg_control);\n\t\treturn;\n\t}\n\n\t \n\tval = readl(ch->reg_config);\n\tval &= ~PL080_CONFIG_HALT;\n\twritel(val, ch->reg_config);\n}\n\n \nstatic void pl08x_terminate_phy_chan(struct pl08x_driver_data *pl08x,\n\tstruct pl08x_phy_chan *ch)\n{\n\tu32 val;\n\n\t \n\tif (ch->ftdmac020) {\n\t\t \n\t\tval = readl(ch->reg_config);\n\t\tval |= (FTDMAC020_CH_CFG_INT_ABT_MASK |\n\t\t\tFTDMAC020_CH_CFG_INT_ERR_MASK |\n\t\t\tFTDMAC020_CH_CFG_INT_TC_MASK);\n\t\twritel(val, ch->reg_config);\n\n\t\t \n\t\tval = readl(ch->reg_control);\n\t\tval &= ~FTDMAC020_CH_CSR_EN;\n\t\tval |= FTDMAC020_CH_CSR_ABT;\n\t\twritel(val, ch->reg_control);\n\n\t\t \n\t\twritel(BIT(ch->id) | BIT(ch->id + 16),\n\t\t       pl08x->base + PL080_ERR_CLEAR);\n\t\twritel(BIT(ch->id), pl08x->base + PL080_TC_CLEAR);\n\n\t\treturn;\n\t}\n\n\tval = readl(ch->reg_config);\n\tval &= ~(PL080_CONFIG_ENABLE | PL080_CONFIG_ERR_IRQ_MASK |\n\t\t PL080_CONFIG_TC_IRQ_MASK);\n\twritel(val, ch->reg_config);\n\n\twritel(BIT(ch->id), pl08x->base + PL080_ERR_CLEAR);\n\twritel(BIT(ch->id), pl08x->base + PL080_TC_CLEAR);\n}\n\nstatic u32 get_bytes_in_phy_channel(struct pl08x_phy_chan *ch)\n{\n\tu32 val;\n\tu32 bytes;\n\n\tif (ch->ftdmac020) {\n\t\tbytes = readl(ch->base + FTDMAC020_CH_SIZE);\n\n\t\tval = readl(ch->reg_control);\n\t\tval &= FTDMAC020_CH_CSR_SRC_WIDTH_MSK;\n\t\tval >>= FTDMAC020_CH_CSR_SRC_WIDTH_SHIFT;\n\t} else if (ch->pl080s) {\n\t\tval = readl(ch->base + PL080S_CH_CONTROL2);\n\t\tbytes = val & PL080S_CONTROL_TRANSFER_SIZE_MASK;\n\n\t\tval = readl(ch->reg_control);\n\t\tval &= PL080_CONTROL_SWIDTH_MASK;\n\t\tval >>= PL080_CONTROL_SWIDTH_SHIFT;\n\t} else {\n\t\t \n\t\tval = readl(ch->reg_control);\n\t\tbytes = val & PL080_CONTROL_TRANSFER_SIZE_MASK;\n\n\t\tval &= PL080_CONTROL_SWIDTH_MASK;\n\t\tval >>= PL080_CONTROL_SWIDTH_SHIFT;\n\t}\n\n\tswitch (val) {\n\tcase PL080_WIDTH_8BIT:\n\t\tbreak;\n\tcase PL080_WIDTH_16BIT:\n\t\tbytes *= 2;\n\t\tbreak;\n\tcase PL080_WIDTH_32BIT:\n\t\tbytes *= 4;\n\t\tbreak;\n\t}\n\treturn bytes;\n}\n\nstatic u32 get_bytes_in_lli(struct pl08x_phy_chan *ch, const u32 *llis_va)\n{\n\tu32 val;\n\tu32 bytes;\n\n\tif (ch->ftdmac020) {\n\t\tval = llis_va[PL080_LLI_CCTL];\n\t\tbytes = val & FTDMAC020_LLI_TRANSFER_SIZE_MASK;\n\n\t\tval = llis_va[PL080_LLI_CCTL];\n\t\tval &= FTDMAC020_LLI_SRC_WIDTH_MSK;\n\t\tval >>= FTDMAC020_LLI_SRC_WIDTH_SHIFT;\n\t} else if (ch->pl080s) {\n\t\tval = llis_va[PL080S_LLI_CCTL2];\n\t\tbytes = val & PL080S_CONTROL_TRANSFER_SIZE_MASK;\n\n\t\tval = llis_va[PL080_LLI_CCTL];\n\t\tval &= PL080_CONTROL_SWIDTH_MASK;\n\t\tval >>= PL080_CONTROL_SWIDTH_SHIFT;\n\t} else {\n\t\t \n\t\tval = llis_va[PL080_LLI_CCTL];\n\t\tbytes = val & PL080_CONTROL_TRANSFER_SIZE_MASK;\n\n\t\tval &= PL080_CONTROL_SWIDTH_MASK;\n\t\tval >>= PL080_CONTROL_SWIDTH_SHIFT;\n\t}\n\n\tswitch (val) {\n\tcase PL080_WIDTH_8BIT:\n\t\tbreak;\n\tcase PL080_WIDTH_16BIT:\n\t\tbytes *= 2;\n\t\tbreak;\n\tcase PL080_WIDTH_32BIT:\n\t\tbytes *= 4;\n\t\tbreak;\n\t}\n\treturn bytes;\n}\n\n \nstatic u32 pl08x_getbytes_chan(struct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tconst u32 *llis_va, *llis_va_limit;\n\tstruct pl08x_phy_chan *ch;\n\tdma_addr_t llis_bus;\n\tstruct pl08x_txd *txd;\n\tu32 llis_max_words;\n\tsize_t bytes;\n\tu32 clli;\n\n\tch = plchan->phychan;\n\ttxd = plchan->at;\n\n\tif (!ch || !txd)\n\t\treturn 0;\n\n\t \n\tclli = readl(ch->reg_lli) & ~PL080_LLI_LM_AHB2;\n\n\t \n\tbytes = get_bytes_in_phy_channel(ch);\n\n\tif (!clli)\n\t\treturn bytes;\n\n\tllis_va = txd->llis_va;\n\tllis_bus = txd->llis_bus;\n\n\tllis_max_words = pl08x->lli_words * MAX_NUM_TSFR_LLIS;\n\tBUG_ON(clli < llis_bus || clli >= llis_bus +\n\t\t\t\t\t\tsizeof(u32) * llis_max_words);\n\n\t \n\tllis_va += (clli - llis_bus) / sizeof(u32);\n\n\tllis_va_limit = llis_va + llis_max_words;\n\n\tfor (; llis_va < llis_va_limit; llis_va += pl08x->lli_words) {\n\t\tbytes += get_bytes_in_lli(ch, llis_va);\n\n\t\t \n\t\tif (llis_va[PL080_LLI_LLI] <= clli)\n\t\t\tbreak;\n\t}\n\n\treturn bytes;\n}\n\n \nstatic struct pl08x_phy_chan *\npl08x_get_phy_channel(struct pl08x_driver_data *pl08x,\n\t\t      struct pl08x_dma_chan *virt_chan)\n{\n\tstruct pl08x_phy_chan *ch = NULL;\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < pl08x->vd->channels; i++) {\n\t\tch = &pl08x->phy_chans[i];\n\n\t\tspin_lock_irqsave(&ch->lock, flags);\n\n\t\tif (!ch->locked && !ch->serving) {\n\t\t\tch->serving = virt_chan;\n\t\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\t}\n\n\tif (i == pl08x->vd->channels) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\treturn ch;\n}\n\n \nstatic inline void pl08x_put_phy_channel(struct pl08x_driver_data *pl08x,\n\t\t\t\t\t struct pl08x_phy_chan *ch)\n{\n\tch->serving = NULL;\n}\n\n \nstatic void pl08x_phy_alloc_and_start(struct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_phy_chan *ch;\n\n\tch = pl08x_get_phy_channel(pl08x, plchan);\n\tif (!ch) {\n\t\tdev_dbg(&pl08x->adev->dev, \"no physical channel available for xfer on %s\\n\", plchan->name);\n\t\tplchan->state = PL08X_CHAN_WAITING;\n\t\tplchan->waiting_at = jiffies;\n\t\treturn;\n\t}\n\n\tdev_dbg(&pl08x->adev->dev, \"allocated physical channel %d for xfer on %s\\n\",\n\t\tch->id, plchan->name);\n\n\tplchan->phychan = ch;\n\tplchan->state = PL08X_CHAN_RUNNING;\n\tpl08x_start_next_txd(plchan);\n}\n\nstatic void pl08x_phy_reassign_start(struct pl08x_phy_chan *ch,\n\tstruct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\n\tdev_dbg(&pl08x->adev->dev, \"reassigned physical channel %d for xfer on %s\\n\",\n\t\tch->id, plchan->name);\n\n\t \n\tch->serving = plchan;\n\tplchan->phychan = ch;\n\tplchan->state = PL08X_CHAN_RUNNING;\n\tpl08x_start_next_txd(plchan);\n}\n\n \nstatic void pl08x_phy_free(struct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_dma_chan *p, *next;\n\tunsigned long waiting_at;\n retry:\n\tnext = NULL;\n\twaiting_at = jiffies;\n\n\t \n\tlist_for_each_entry(p, &pl08x->memcpy.channels, vc.chan.device_node)\n\t\tif (p->state == PL08X_CHAN_WAITING &&\n\t\t    p->waiting_at <= waiting_at) {\n\t\t\tnext = p;\n\t\t\twaiting_at = p->waiting_at;\n\t\t}\n\n\tif (!next && pl08x->has_slave) {\n\t\tlist_for_each_entry(p, &pl08x->slave.channels, vc.chan.device_node)\n\t\t\tif (p->state == PL08X_CHAN_WAITING &&\n\t\t\t    p->waiting_at <= waiting_at) {\n\t\t\t\tnext = p;\n\t\t\t\twaiting_at = p->waiting_at;\n\t\t\t}\n\t}\n\n\t \n\tpl08x_terminate_phy_chan(pl08x, plchan->phychan);\n\n\tif (next) {\n\t\tbool success;\n\n\t\t \n\t\tspin_lock(&next->vc.lock);\n\t\t \n\t\tsuccess = next->state == PL08X_CHAN_WAITING;\n\t\tif (success)\n\t\t\tpl08x_phy_reassign_start(plchan->phychan, next);\n\t\tspin_unlock(&next->vc.lock);\n\n\t\t \n\t\tif (!success)\n\t\t\tgoto retry;\n\t} else {\n\t\t \n\t\tpl08x_put_phy_channel(pl08x, plchan->phychan);\n\t}\n\n\tplchan->phychan = NULL;\n\tplchan->state = PL08X_CHAN_IDLE;\n}\n\n \n\nstatic inline unsigned int\npl08x_get_bytes_for_lli(struct pl08x_driver_data *pl08x,\n\t\t\tu32 cctl,\n\t\t\tbool source)\n{\n\tu32 val;\n\n\tif (pl08x->vd->ftdmac020) {\n\t\tif (source)\n\t\t\tval = (cctl & FTDMAC020_LLI_SRC_WIDTH_MSK) >>\n\t\t\t\tFTDMAC020_LLI_SRC_WIDTH_SHIFT;\n\t\telse\n\t\t\tval = (cctl & FTDMAC020_LLI_DST_WIDTH_MSK) >>\n\t\t\t\tFTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t} else {\n\t\tif (source)\n\t\t\tval = (cctl & PL080_CONTROL_SWIDTH_MASK) >>\n\t\t\t\tPL080_CONTROL_SWIDTH_SHIFT;\n\t\telse\n\t\t\tval = (cctl & PL080_CONTROL_DWIDTH_MASK) >>\n\t\t\t\tPL080_CONTROL_DWIDTH_SHIFT;\n\t}\n\n\tswitch (val) {\n\tcase PL080_WIDTH_8BIT:\n\t\treturn 1;\n\tcase PL080_WIDTH_16BIT:\n\t\treturn 2;\n\tcase PL080_WIDTH_32BIT:\n\t\treturn 4;\n\tdefault:\n\t\tbreak;\n\t}\n\tBUG();\n\treturn 0;\n}\n\nstatic inline u32 pl08x_lli_control_bits(struct pl08x_driver_data *pl08x,\n\t\t\t\t\t u32 cctl,\n\t\t\t\t\t u8 srcwidth, u8 dstwidth,\n\t\t\t\t\t size_t tsize)\n{\n\tu32 retbits = cctl;\n\n\t \n\tif (pl08x->vd->ftdmac020) {\n\t\tretbits &= ~FTDMAC020_LLI_DST_WIDTH_MSK;\n\t\tretbits &= ~FTDMAC020_LLI_SRC_WIDTH_MSK;\n\t\tretbits &= ~FTDMAC020_LLI_TRANSFER_SIZE_MASK;\n\n\t\tswitch (srcwidth) {\n\t\tcase 1:\n\t\t\tretbits |= PL080_WIDTH_8BIT <<\n\t\t\t\tFTDMAC020_LLI_SRC_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tretbits |= PL080_WIDTH_16BIT <<\n\t\t\t\tFTDMAC020_LLI_SRC_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tretbits |= PL080_WIDTH_32BIT <<\n\t\t\t\tFTDMAC020_LLI_SRC_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (dstwidth) {\n\t\tcase 1:\n\t\t\tretbits |= PL080_WIDTH_8BIT <<\n\t\t\t\tFTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tretbits |= PL080_WIDTH_16BIT <<\n\t\t\t\tFTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tretbits |= PL080_WIDTH_32BIT <<\n\t\t\t\tFTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\ttsize &= FTDMAC020_LLI_TRANSFER_SIZE_MASK;\n\t\tretbits |= tsize << FTDMAC020_LLI_TRANSFER_SIZE_SHIFT;\n\t} else {\n\t\tretbits &= ~PL080_CONTROL_DWIDTH_MASK;\n\t\tretbits &= ~PL080_CONTROL_SWIDTH_MASK;\n\t\tretbits &= ~PL080_CONTROL_TRANSFER_SIZE_MASK;\n\n\t\tswitch (srcwidth) {\n\t\tcase 1:\n\t\t\tretbits |= PL080_WIDTH_8BIT <<\n\t\t\t\tPL080_CONTROL_SWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tretbits |= PL080_WIDTH_16BIT <<\n\t\t\t\tPL080_CONTROL_SWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tretbits |= PL080_WIDTH_32BIT <<\n\t\t\t\tPL080_CONTROL_SWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (dstwidth) {\n\t\tcase 1:\n\t\t\tretbits |= PL080_WIDTH_8BIT <<\n\t\t\t\tPL080_CONTROL_DWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tretbits |= PL080_WIDTH_16BIT <<\n\t\t\t\tPL080_CONTROL_DWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tretbits |= PL080_WIDTH_32BIT <<\n\t\t\t\tPL080_CONTROL_DWIDTH_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\ttsize &= PL080_CONTROL_TRANSFER_SIZE_MASK;\n\t\tretbits |= tsize << PL080_CONTROL_TRANSFER_SIZE_SHIFT;\n\t}\n\n\treturn retbits;\n}\n\nstruct pl08x_lli_build_data {\n\tstruct pl08x_txd *txd;\n\tstruct pl08x_bus_data srcbus;\n\tstruct pl08x_bus_data dstbus;\n\tsize_t remainder;\n\tu32 lli_bus;\n};\n\n \nstatic void pl08x_choose_master_bus(struct pl08x_driver_data *pl08x,\n\t\t\t\t    struct pl08x_lli_build_data *bd,\n\t\t\t\t    struct pl08x_bus_data **mbus,\n\t\t\t\t    struct pl08x_bus_data **sbus,\n\t\t\t\t    u32 cctl)\n{\n\tbool dst_incr;\n\tbool src_incr;\n\n\t \n\tif (pl08x->vd->ftdmac020) {\n\t\tdst_incr = true;\n\t\tsrc_incr = true;\n\t} else {\n\t\tdst_incr = !!(cctl & PL080_CONTROL_DST_INCR);\n\t\tsrc_incr = !!(cctl & PL080_CONTROL_SRC_INCR);\n\t}\n\n\t \n\tif (!dst_incr) {\n\t\t*mbus = &bd->dstbus;\n\t\t*sbus = &bd->srcbus;\n\t} else if (!src_incr) {\n\t\t*mbus = &bd->srcbus;\n\t\t*sbus = &bd->dstbus;\n\t} else {\n\t\tif (bd->dstbus.buswidth >= bd->srcbus.buswidth) {\n\t\t\t*mbus = &bd->dstbus;\n\t\t\t*sbus = &bd->srcbus;\n\t\t} else {\n\t\t\t*mbus = &bd->srcbus;\n\t\t\t*sbus = &bd->dstbus;\n\t\t}\n\t}\n}\n\n \nstatic void pl08x_fill_lli_for_desc(struct pl08x_driver_data *pl08x,\n\t\t\t\t    struct pl08x_lli_build_data *bd,\n\t\t\t\t    int num_llis, int len, u32 cctl, u32 cctl2)\n{\n\tu32 offset = num_llis * pl08x->lli_words;\n\tu32 *llis_va = bd->txd->llis_va + offset;\n\tdma_addr_t llis_bus = bd->txd->llis_bus;\n\n\tBUG_ON(num_llis >= MAX_NUM_TSFR_LLIS);\n\n\t \n\toffset += pl08x->lli_words;\n\n\tllis_va[PL080_LLI_SRC] = bd->srcbus.addr;\n\tllis_va[PL080_LLI_DST] = bd->dstbus.addr;\n\tllis_va[PL080_LLI_LLI] = (llis_bus + sizeof(u32) * offset);\n\tllis_va[PL080_LLI_LLI] |= bd->lli_bus;\n\tllis_va[PL080_LLI_CCTL] = cctl;\n\tif (pl08x->vd->pl080s)\n\t\tllis_va[PL080S_LLI_CCTL2] = cctl2;\n\n\tif (pl08x->vd->ftdmac020) {\n\t\t \n\t\tbd->srcbus.addr += len;\n\t\tbd->dstbus.addr += len;\n\t} else {\n\t\tif (cctl & PL080_CONTROL_SRC_INCR)\n\t\t\tbd->srcbus.addr += len;\n\t\tif (cctl & PL080_CONTROL_DST_INCR)\n\t\t\tbd->dstbus.addr += len;\n\t}\n\n\tBUG_ON(bd->remainder < len);\n\n\tbd->remainder -= len;\n}\n\nstatic inline void prep_byte_width_lli(struct pl08x_driver_data *pl08x,\n\t\t\tstruct pl08x_lli_build_data *bd, u32 *cctl, u32 len,\n\t\t\tint num_llis, size_t *total_bytes)\n{\n\t*cctl = pl08x_lli_control_bits(pl08x, *cctl, 1, 1, len);\n\tpl08x_fill_lli_for_desc(pl08x, bd, num_llis, len, *cctl, len);\n\t(*total_bytes) += len;\n}\n\n#if 1\nstatic void pl08x_dump_lli(struct pl08x_driver_data *pl08x,\n\t\t\t   const u32 *llis_va, int num_llis)\n{\n\tint i;\n\n\tif (pl08x->vd->pl080s) {\n\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\"%-3s %-9s  %-10s %-10s %-10s %-10s %s\\n\",\n\t\t\t\"lli\", \"\", \"csrc\", \"cdst\", \"clli\", \"cctl\", \"cctl2\");\n\t\tfor (i = 0; i < num_llis; i++) {\n\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\"%3d @%p: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\ti, llis_va, llis_va[PL080_LLI_SRC],\n\t\t\t\tllis_va[PL080_LLI_DST], llis_va[PL080_LLI_LLI],\n\t\t\t\tllis_va[PL080_LLI_CCTL],\n\t\t\t\tllis_va[PL080S_LLI_CCTL2]);\n\t\t\tllis_va += pl08x->lli_words;\n\t\t}\n\t} else {\n\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\"%-3s %-9s  %-10s %-10s %-10s %s\\n\",\n\t\t\t\"lli\", \"\", \"csrc\", \"cdst\", \"clli\", \"cctl\");\n\t\tfor (i = 0; i < num_llis; i++) {\n\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\"%3d @%p: 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\ti, llis_va, llis_va[PL080_LLI_SRC],\n\t\t\t\tllis_va[PL080_LLI_DST], llis_va[PL080_LLI_LLI],\n\t\t\t\tllis_va[PL080_LLI_CCTL]);\n\t\t\tllis_va += pl08x->lli_words;\n\t\t}\n\t}\n}\n#else\nstatic inline void pl08x_dump_lli(struct pl08x_driver_data *pl08x,\n\t\t\t\t  const u32 *llis_va, int num_llis) {}\n#endif\n\n \nstatic int pl08x_fill_llis_for_desc(struct pl08x_driver_data *pl08x,\n\t\t\t      struct pl08x_txd *txd)\n{\n\tstruct pl08x_bus_data *mbus, *sbus;\n\tstruct pl08x_lli_build_data bd;\n\tint num_llis = 0;\n\tu32 cctl, early_bytes = 0;\n\tsize_t max_bytes_per_lli, total_bytes;\n\tu32 *llis_va, *last_lli;\n\tstruct pl08x_sg *dsg;\n\n\ttxd->llis_va = dma_pool_alloc(pl08x->pool, GFP_NOWAIT, &txd->llis_bus);\n\tif (!txd->llis_va) {\n\t\tdev_err(&pl08x->adev->dev, \"%s no memory for llis\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tbd.txd = txd;\n\tbd.lli_bus = (pl08x->lli_buses & PL08X_AHB2) ? PL080_LLI_LM_AHB2 : 0;\n\tcctl = txd->cctl;\n\n\t \n\tbd.srcbus.maxwidth = pl08x_get_bytes_for_lli(pl08x, cctl, true);\n\n\t \n\tbd.dstbus.maxwidth = pl08x_get_bytes_for_lli(pl08x, cctl, false);\n\n\tlist_for_each_entry(dsg, &txd->dsg_list, node) {\n\t\ttotal_bytes = 0;\n\t\tcctl = txd->cctl;\n\n\t\tbd.srcbus.addr = dsg->src_addr;\n\t\tbd.dstbus.addr = dsg->dst_addr;\n\t\tbd.remainder = dsg->len;\n\t\tbd.srcbus.buswidth = bd.srcbus.maxwidth;\n\t\tbd.dstbus.buswidth = bd.dstbus.maxwidth;\n\n\t\tpl08x_choose_master_bus(pl08x, &bd, &mbus, &sbus, cctl);\n\n\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\"src=0x%08llx%s/%u dst=0x%08llx%s/%u len=%zu\\n\",\n\t\t\t(u64)bd.srcbus.addr,\n\t\t\tcctl & PL080_CONTROL_SRC_INCR ? \"+\" : \"\",\n\t\t\tbd.srcbus.buswidth,\n\t\t\t(u64)bd.dstbus.addr,\n\t\t\tcctl & PL080_CONTROL_DST_INCR ? \"+\" : \"\",\n\t\t\tbd.dstbus.buswidth,\n\t\t\tbd.remainder);\n\t\tdev_vdbg(&pl08x->adev->dev, \"mbus=%s sbus=%s\\n\",\n\t\t\tmbus == &bd.srcbus ? \"src\" : \"dst\",\n\t\t\tsbus == &bd.srcbus ? \"src\" : \"dst\");\n\n\t\t \n\t\tif (!bd.remainder) {\n\t\t\tu32 fc;\n\n\t\t\t \n\t\t\tif (pl08x->vd->ftdmac020)\n\t\t\t\tfc = PL080_FLOW_MEM2MEM;\n\t\t\telse\n\t\t\t\tfc = (txd->ccfg & PL080_CONFIG_FLOW_CONTROL_MASK) >>\n\t\t\t\t\tPL080_CONFIG_FLOW_CONTROL_SHIFT;\n\t\t\tif (!((fc >= PL080_FLOW_SRC2DST_DST) &&\n\t\t\t\t\t(fc <= PL080_FLOW_SRC2DST_SRC))) {\n\t\t\t\tdev_err(&pl08x->adev->dev, \"%s sg len can't be zero\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!IS_BUS_ALIGNED(&bd.srcbus) ||\n\t\t\t\t!IS_BUS_ALIGNED(&bd.dstbus)) {\n\t\t\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\t\t\"%s src & dst address must be aligned to src\"\n\t\t\t\t\t\" & dst width if peripheral is flow controller\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tcctl = pl08x_lli_control_bits(pl08x, cctl,\n\t\t\t\t\tbd.srcbus.buswidth, bd.dstbus.buswidth,\n\t\t\t\t\t0);\n\t\t\tpl08x_fill_lli_for_desc(pl08x, &bd, num_llis++,\n\t\t\t\t\t0, cctl, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (bd.remainder < mbus->buswidth)\n\t\t\tearly_bytes = bd.remainder;\n\t\telse if (!IS_BUS_ALIGNED(mbus)) {\n\t\t\tearly_bytes = mbus->buswidth -\n\t\t\t\t(mbus->addr & (mbus->buswidth - 1));\n\t\t\tif ((bd.remainder - early_bytes) < mbus->buswidth)\n\t\t\t\tearly_bytes = bd.remainder;\n\t\t}\n\n\t\tif (early_bytes) {\n\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\"%s byte width LLIs (remain 0x%08zx)\\n\",\n\t\t\t\t__func__, bd.remainder);\n\t\t\tprep_byte_width_lli(pl08x, &bd, &cctl, early_bytes,\n\t\t\t\tnum_llis++, &total_bytes);\n\t\t}\n\n\t\tif (bd.remainder) {\n\t\t\t \n\t\t\tif (!IS_BUS_ALIGNED(sbus)) {\n\t\t\t\tdev_dbg(&pl08x->adev->dev,\n\t\t\t\t\t\"%s set down bus width to one byte\\n\",\n\t\t\t\t\t__func__);\n\n\t\t\t\tsbus->buswidth = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tmax_bytes_per_lli = bd.srcbus.buswidth *\n\t\t\t\t\t\tpl08x->vd->max_transfer_size;\n\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\"%s max bytes per lli = %zu\\n\",\n\t\t\t\t__func__, max_bytes_per_lli);\n\n\t\t\t \n\t\t\twhile (bd.remainder > (mbus->buswidth - 1)) {\n\t\t\t\tsize_t lli_len, tsize, width;\n\n\t\t\t\t \n\t\t\t\tlli_len = min(bd.remainder, max_bytes_per_lli);\n\n\t\t\t\t \n\t\t\t\twidth = max(mbus->buswidth, sbus->buswidth);\n\t\t\t\tlli_len = (lli_len / width) * width;\n\t\t\t\ttsize = lli_len / bd.srcbus.buswidth;\n\n\t\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\t\"%s fill lli with single lli chunk of \"\n\t\t\t\t\t\"size 0x%08zx (remainder 0x%08zx)\\n\",\n\t\t\t\t\t__func__, lli_len, bd.remainder);\n\n\t\t\t\tcctl = pl08x_lli_control_bits(pl08x, cctl,\n\t\t\t\t\tbd.srcbus.buswidth, bd.dstbus.buswidth,\n\t\t\t\t\ttsize);\n\t\t\t\tpl08x_fill_lli_for_desc(pl08x, &bd, num_llis++,\n\t\t\t\t\t\tlli_len, cctl, tsize);\n\t\t\t\ttotal_bytes += lli_len;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (bd.remainder) {\n\t\t\t\tdev_vdbg(&pl08x->adev->dev,\n\t\t\t\t\t\"%s align with boundary, send odd bytes (remain %zu)\\n\",\n\t\t\t\t\t__func__, bd.remainder);\n\t\t\t\tprep_byte_width_lli(pl08x, &bd, &cctl,\n\t\t\t\t\tbd.remainder, num_llis++, &total_bytes);\n\t\t\t}\n\t\t}\n\n\t\tif (total_bytes != dsg->len) {\n\t\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\t\"%s size of encoded lli:s don't match total txd, transferred 0x%08zx from size 0x%08zx\\n\",\n\t\t\t\t__func__, total_bytes, dsg->len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (num_llis >= MAX_NUM_TSFR_LLIS) {\n\t\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\t\"%s need to increase MAX_NUM_TSFR_LLIS from 0x%08x\\n\",\n\t\t\t\t__func__, MAX_NUM_TSFR_LLIS);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tllis_va = txd->llis_va;\n\tlast_lli = llis_va + (num_llis - 1) * pl08x->lli_words;\n\n\tif (txd->cyclic) {\n\t\t \n\t\tlast_lli[PL080_LLI_LLI] = txd->llis_bus | bd.lli_bus;\n\t} else {\n\t\t \n\t\tlast_lli[PL080_LLI_LLI] = 0;\n\t\t \n\t\tif (pl08x->vd->ftdmac020)\n\t\t\tlast_lli[PL080_LLI_CCTL] &= ~FTDMAC020_LLI_TC_MSK;\n\t\telse\n\t\t\tlast_lli[PL080_LLI_CCTL] |= PL080_CONTROL_TC_IRQ_EN;\n\t}\n\n\tpl08x_dump_lli(pl08x, llis_va, num_llis);\n\n\treturn num_llis;\n}\n\nstatic void pl08x_free_txd(struct pl08x_driver_data *pl08x,\n\t\t\t   struct pl08x_txd *txd)\n{\n\tstruct pl08x_sg *dsg, *_dsg;\n\n\tif (txd->llis_va)\n\t\tdma_pool_free(pl08x->pool, txd->llis_va, txd->llis_bus);\n\n\tlist_for_each_entry_safe(dsg, _dsg, &txd->dsg_list, node) {\n\t\tlist_del(&dsg->node);\n\t\tkfree(dsg);\n\t}\n\n\tkfree(txd);\n}\n\nstatic void pl08x_desc_free(struct virt_dma_desc *vd)\n{\n\tstruct pl08x_txd *txd = to_pl08x_txd(&vd->tx);\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(vd->tx.chan);\n\n\tdma_descriptor_unmap(&vd->tx);\n\tif (!txd->done)\n\t\tpl08x_release_mux(plchan);\n\n\tpl08x_free_txd(plchan->host, txd);\n}\n\nstatic void pl08x_free_txd_list(struct pl08x_driver_data *pl08x,\n\t\t\t\tstruct pl08x_dma_chan *plchan)\n{\n\tLIST_HEAD(head);\n\n\tvchan_get_all_descriptors(&plchan->vc, &head);\n\tvchan_dma_desc_free_list(&plchan->vc, &head);\n}\n\n \nstatic void pl08x_free_chan_resources(struct dma_chan *chan)\n{\n\t \n\tvchan_free_chan_resources(to_virt_chan(chan));\n}\n\n \nstatic enum dma_status pl08x_dma_tx_status(struct dma_chan *chan,\n\t\tdma_cookie_t cookie, struct dma_tx_state *txstate)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct virt_dma_desc *vd;\n\tunsigned long flags;\n\tenum dma_status ret;\n\tsize_t bytes = 0;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret == DMA_COMPLETE)\n\t\treturn ret;\n\n\t \n\tif (!txstate) {\n\t\tif (plchan->state == PL08X_CHAN_PAUSED)\n\t\t\tret = DMA_PAUSED;\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&plchan->vc.lock, flags);\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret != DMA_COMPLETE) {\n\t\tvd = vchan_find_desc(&plchan->vc, cookie);\n\t\tif (vd) {\n\t\t\t \n\t\t\tstruct pl08x_txd *txd = to_pl08x_txd(&vd->tx);\n\t\t\tstruct pl08x_sg *dsg;\n\n\t\t\tlist_for_each_entry(dsg, &txd->dsg_list, node)\n\t\t\t\tbytes += dsg->len;\n\t\t} else {\n\t\t\tbytes = pl08x_getbytes_chan(plchan);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\n\t \n\tdma_set_residue(txstate, bytes);\n\n\tif (plchan->state == PL08X_CHAN_PAUSED && ret == DMA_IN_PROGRESS)\n\t\tret = DMA_PAUSED;\n\n\t \n\treturn ret;\n}\n\n \nstruct burst_table {\n\tu32 burstwords;\n\tu32 reg;\n};\n\nstatic const struct burst_table burst_sizes[] = {\n\t{\n\t\t.burstwords = 256,\n\t\t.reg = PL080_BSIZE_256,\n\t},\n\t{\n\t\t.burstwords = 128,\n\t\t.reg = PL080_BSIZE_128,\n\t},\n\t{\n\t\t.burstwords = 64,\n\t\t.reg = PL080_BSIZE_64,\n\t},\n\t{\n\t\t.burstwords = 32,\n\t\t.reg = PL080_BSIZE_32,\n\t},\n\t{\n\t\t.burstwords = 16,\n\t\t.reg = PL080_BSIZE_16,\n\t},\n\t{\n\t\t.burstwords = 8,\n\t\t.reg = PL080_BSIZE_8,\n\t},\n\t{\n\t\t.burstwords = 4,\n\t\t.reg = PL080_BSIZE_4,\n\t},\n\t{\n\t\t.burstwords = 0,\n\t\t.reg = PL080_BSIZE_1,\n\t},\n};\n\n \nstatic u32 pl08x_select_bus(bool ftdmac020, u8 src, u8 dst)\n{\n\tu32 cctl = 0;\n\tu32 dst_ahb2;\n\tu32 src_ahb2;\n\n\t \n\tif (ftdmac020) {\n\t\tdst_ahb2 = FTDMAC020_LLI_DST_SEL;\n\t\tsrc_ahb2 = FTDMAC020_LLI_SRC_SEL;\n\t} else {\n\t\tdst_ahb2 = PL080_CONTROL_DST_AHB2;\n\t\tsrc_ahb2 = PL080_CONTROL_SRC_AHB2;\n\t}\n\n\tif (!(dst & PL08X_AHB1) || ((dst & PL08X_AHB2) && (src & PL08X_AHB1)))\n\t\tcctl |= dst_ahb2;\n\tif (!(src & PL08X_AHB1) || ((src & PL08X_AHB2) && !(dst & PL08X_AHB2)))\n\t\tcctl |= src_ahb2;\n\n\treturn cctl;\n}\n\nstatic u32 pl08x_cctl(u32 cctl)\n{\n\tcctl &= ~(PL080_CONTROL_SRC_AHB2 | PL080_CONTROL_DST_AHB2 |\n\t\t  PL080_CONTROL_SRC_INCR | PL080_CONTROL_DST_INCR |\n\t\t  PL080_CONTROL_PROT_MASK);\n\n\t \n\treturn cctl | PL080_CONTROL_PROT_SYS;\n}\n\nstatic u32 pl08x_width(enum dma_slave_buswidth width)\n{\n\tswitch (width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\treturn PL080_WIDTH_8BIT;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\treturn PL080_WIDTH_16BIT;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\treturn PL080_WIDTH_32BIT;\n\tdefault:\n\t\treturn ~0;\n\t}\n}\n\nstatic u32 pl08x_burst(u32 maxburst)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(burst_sizes); i++)\n\t\tif (burst_sizes[i].burstwords <= maxburst)\n\t\t\tbreak;\n\n\treturn burst_sizes[i].reg;\n}\n\nstatic u32 pl08x_get_cctl(struct pl08x_dma_chan *plchan,\n\tenum dma_slave_buswidth addr_width, u32 maxburst)\n{\n\tu32 width, burst, cctl = 0;\n\n\twidth = pl08x_width(addr_width);\n\tif (width == ~0)\n\t\treturn ~0;\n\n\tcctl |= width << PL080_CONTROL_SWIDTH_SHIFT;\n\tcctl |= width << PL080_CONTROL_DWIDTH_SHIFT;\n\n\t \n\tif (plchan->cd->single)\n\t\tmaxburst = 1;\n\n\tburst = pl08x_burst(maxburst);\n\tcctl |= burst << PL080_CONTROL_SB_SIZE_SHIFT;\n\tcctl |= burst << PL080_CONTROL_DB_SIZE_SHIFT;\n\n\treturn pl08x_cctl(cctl);\n}\n\n \nstatic void pl08x_issue_pending(struct dma_chan *chan)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&plchan->vc.lock, flags);\n\tif (vchan_issue_pending(&plchan->vc)) {\n\t\tif (!plchan->phychan && plchan->state != PL08X_CHAN_WAITING)\n\t\t\tpl08x_phy_alloc_and_start(plchan);\n\t}\n\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n}\n\nstatic struct pl08x_txd *pl08x_get_txd(struct pl08x_dma_chan *plchan)\n{\n\tstruct pl08x_txd *txd = kzalloc(sizeof(*txd), GFP_NOWAIT);\n\n\tif (txd)\n\t\tINIT_LIST_HEAD(&txd->dsg_list);\n\treturn txd;\n}\n\nstatic u32 pl08x_memcpy_cctl(struct pl08x_driver_data *pl08x)\n{\n\tu32 cctl = 0;\n\n\t \n\tswitch (pl08x->pd->memcpy_burst_size) {\n\tdefault:\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"illegal burst size for memcpy, set to 1\\n\");\n\t\tfallthrough;\n\tcase PL08X_BURST_SZ_1:\n\t\tcctl |= PL080_BSIZE_1 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_1 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_4:\n\t\tcctl |= PL080_BSIZE_4 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_4 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_8:\n\t\tcctl |= PL080_BSIZE_8 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_8 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_16:\n\t\tcctl |= PL080_BSIZE_16 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_16 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_32:\n\t\tcctl |= PL080_BSIZE_32 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_32 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_64:\n\t\tcctl |= PL080_BSIZE_64 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_64 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_128:\n\t\tcctl |= PL080_BSIZE_128 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_128 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\tcase PL08X_BURST_SZ_256:\n\t\tcctl |= PL080_BSIZE_256 << PL080_CONTROL_SB_SIZE_SHIFT |\n\t\t\tPL080_BSIZE_256 << PL080_CONTROL_DB_SIZE_SHIFT;\n\t\tbreak;\n\t}\n\n\tswitch (pl08x->pd->memcpy_bus_width) {\n\tdefault:\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"illegal bus width for memcpy, set to 8 bits\\n\");\n\t\tfallthrough;\n\tcase PL08X_BUS_WIDTH_8_BITS:\n\t\tcctl |= PL080_WIDTH_8BIT << PL080_CONTROL_SWIDTH_SHIFT |\n\t\t\tPL080_WIDTH_8BIT << PL080_CONTROL_DWIDTH_SHIFT;\n\t\tbreak;\n\tcase PL08X_BUS_WIDTH_16_BITS:\n\t\tcctl |= PL080_WIDTH_16BIT << PL080_CONTROL_SWIDTH_SHIFT |\n\t\t\tPL080_WIDTH_16BIT << PL080_CONTROL_DWIDTH_SHIFT;\n\t\tbreak;\n\tcase PL08X_BUS_WIDTH_32_BITS:\n\t\tcctl |= PL080_WIDTH_32BIT << PL080_CONTROL_SWIDTH_SHIFT |\n\t\t\tPL080_WIDTH_32BIT << PL080_CONTROL_DWIDTH_SHIFT;\n\t\tbreak;\n\t}\n\n\t \n\tif (pl08x->pd->memcpy_prot_buff)\n\t\tcctl |= PL080_CONTROL_PROT_BUFF;\n\tif (pl08x->pd->memcpy_prot_cache)\n\t\tcctl |= PL080_CONTROL_PROT_CACHE;\n\n\t \n\tcctl |= PL080_CONTROL_PROT_SYS;\n\n\t \n\tcctl |= PL080_CONTROL_SRC_INCR | PL080_CONTROL_DST_INCR;\n\n\tif (pl08x->vd->dualmaster)\n\t\tcctl |= pl08x_select_bus(false,\n\t\t\t\t\t pl08x->mem_buses,\n\t\t\t\t\t pl08x->mem_buses);\n\n\treturn cctl;\n}\n\nstatic u32 pl08x_ftdmac020_memcpy_cctl(struct pl08x_driver_data *pl08x)\n{\n\tu32 cctl = 0;\n\n\t \n\tswitch (pl08x->pd->memcpy_bus_width) {\n\tdefault:\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"illegal bus width for memcpy, set to 8 bits\\n\");\n\t\tfallthrough;\n\tcase PL08X_BUS_WIDTH_8_BITS:\n\t\tcctl |= PL080_WIDTH_8BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |\n\t\t\tPL080_WIDTH_8BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\tbreak;\n\tcase PL08X_BUS_WIDTH_16_BITS:\n\t\tcctl |= PL080_WIDTH_16BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |\n\t\t\tPL080_WIDTH_16BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\tbreak;\n\tcase PL08X_BUS_WIDTH_32_BITS:\n\t\tcctl |= PL080_WIDTH_32BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |\n\t\t\tPL080_WIDTH_32BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;\n\t\tbreak;\n\t}\n\n\t \n\tcctl |= FTDMAC020_LLI_TC_MSK;\n\n\t \n\tif (pl08x->vd->dualmaster)\n\t\tcctl |= pl08x_select_bus(true,\n\t\t\t\t\t pl08x->mem_buses,\n\t\t\t\t\t pl08x->mem_buses);\n\n\treturn cctl;\n}\n\n \nstatic struct dma_async_tx_descriptor *pl08x_prep_dma_memcpy(\n\t\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\n\t\tsize_t len, unsigned long flags)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_txd *txd;\n\tstruct pl08x_sg *dsg;\n\tint ret;\n\n\ttxd = pl08x_get_txd(plchan);\n\tif (!txd) {\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"%s no memory for descriptor\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tdsg = kzalloc(sizeof(struct pl08x_sg), GFP_NOWAIT);\n\tif (!dsg) {\n\t\tpl08x_free_txd(pl08x, txd);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&dsg->node, &txd->dsg_list);\n\n\tdsg->src_addr = src;\n\tdsg->dst_addr = dest;\n\tdsg->len = len;\n\tif (pl08x->vd->ftdmac020) {\n\t\t \n\t\ttxd->ccfg = 0;\n\t\ttxd->cctl = pl08x_ftdmac020_memcpy_cctl(pl08x);\n\t} else {\n\t\ttxd->ccfg = PL080_CONFIG_ERR_IRQ_MASK |\n\t\t\tPL080_CONFIG_TC_IRQ_MASK |\n\t\t\tPL080_FLOW_MEM2MEM << PL080_CONFIG_FLOW_CONTROL_SHIFT;\n\t\ttxd->cctl = pl08x_memcpy_cctl(pl08x);\n\t}\n\n\tret = pl08x_fill_llis_for_desc(plchan->host, txd);\n\tif (!ret) {\n\t\tpl08x_free_txd(pl08x, txd);\n\t\treturn NULL;\n\t}\n\n\treturn vchan_tx_prep(&plchan->vc, &txd->vd, flags);\n}\n\nstatic struct pl08x_txd *pl08x_init_txd(\n\t\tstruct dma_chan *chan,\n\t\tenum dma_transfer_direction direction,\n\t\tdma_addr_t *slave_addr)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_txd *txd;\n\tenum dma_slave_buswidth addr_width;\n\tint ret, tmp;\n\tu8 src_buses, dst_buses;\n\tu32 maxburst, cctl;\n\n\ttxd = pl08x_get_txd(plchan);\n\tif (!txd) {\n\t\tdev_err(&pl08x->adev->dev, \"%s no txd\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (direction == DMA_MEM_TO_DEV) {\n\t\tcctl = PL080_CONTROL_SRC_INCR;\n\t\t*slave_addr = plchan->cfg.dst_addr;\n\t\taddr_width = plchan->cfg.dst_addr_width;\n\t\tmaxburst = plchan->cfg.dst_maxburst;\n\t\tsrc_buses = pl08x->mem_buses;\n\t\tdst_buses = plchan->cd->periph_buses;\n\t} else if (direction == DMA_DEV_TO_MEM) {\n\t\tcctl = PL080_CONTROL_DST_INCR;\n\t\t*slave_addr = plchan->cfg.src_addr;\n\t\taddr_width = plchan->cfg.src_addr_width;\n\t\tmaxburst = plchan->cfg.src_maxburst;\n\t\tsrc_buses = plchan->cd->periph_buses;\n\t\tdst_buses = pl08x->mem_buses;\n\t} else {\n\t\tpl08x_free_txd(pl08x, txd);\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"%s direction unsupported\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tcctl |= pl08x_get_cctl(plchan, addr_width, maxburst);\n\tif (cctl == ~0) {\n\t\tpl08x_free_txd(pl08x, txd);\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"DMA slave configuration botched?\\n\");\n\t\treturn NULL;\n\t}\n\n\ttxd->cctl = cctl | pl08x_select_bus(false, src_buses, dst_buses);\n\n\tif (plchan->cfg.device_fc)\n\t\ttmp = (direction == DMA_MEM_TO_DEV) ? PL080_FLOW_MEM2PER_PER :\n\t\t\tPL080_FLOW_PER2MEM_PER;\n\telse\n\t\ttmp = (direction == DMA_MEM_TO_DEV) ? PL080_FLOW_MEM2PER :\n\t\t\tPL080_FLOW_PER2MEM;\n\n\ttxd->ccfg = PL080_CONFIG_ERR_IRQ_MASK |\n\t\tPL080_CONFIG_TC_IRQ_MASK |\n\t\ttmp << PL080_CONFIG_FLOW_CONTROL_SHIFT;\n\n\tret = pl08x_request_mux(plchan);\n\tif (ret < 0) {\n\t\tpl08x_free_txd(pl08x, txd);\n\t\tdev_dbg(&pl08x->adev->dev,\n\t\t\t\"unable to mux for transfer on %s due to platform restrictions\\n\",\n\t\t\tplchan->name);\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(&pl08x->adev->dev, \"allocated DMA request signal %d for xfer on %s\\n\",\n\t\t plchan->signal, plchan->name);\n\n\t \n\tif (direction == DMA_MEM_TO_DEV)\n\t\ttxd->ccfg |= plchan->signal << PL080_CONFIG_DST_SEL_SHIFT;\n\telse\n\t\ttxd->ccfg |= plchan->signal << PL080_CONFIG_SRC_SEL_SHIFT;\n\n\treturn txd;\n}\n\nstatic int pl08x_tx_add_sg(struct pl08x_txd *txd,\n\t\t\t   enum dma_transfer_direction direction,\n\t\t\t   dma_addr_t slave_addr,\n\t\t\t   dma_addr_t buf_addr,\n\t\t\t   unsigned int len)\n{\n\tstruct pl08x_sg *dsg;\n\n\tdsg = kzalloc(sizeof(struct pl08x_sg), GFP_NOWAIT);\n\tif (!dsg)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&dsg->node, &txd->dsg_list);\n\n\tdsg->len = len;\n\tif (direction == DMA_MEM_TO_DEV) {\n\t\tdsg->src_addr = buf_addr;\n\t\tdsg->dst_addr = slave_addr;\n\t} else {\n\t\tdsg->src_addr = slave_addr;\n\t\tdsg->dst_addr = buf_addr;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dma_async_tx_descriptor *pl08x_prep_slave_sg(\n\t\tstruct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_txd *txd;\n\tstruct scatterlist *sg;\n\tint ret, tmp;\n\tdma_addr_t slave_addr;\n\n\tdev_dbg(&pl08x->adev->dev, \"%s prepare transaction of %d bytes from %s\\n\",\n\t\t\t__func__, sg_dma_len(sgl), plchan->name);\n\n\ttxd = pl08x_init_txd(chan, direction, &slave_addr);\n\tif (!txd)\n\t\treturn NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, tmp) {\n\t\tret = pl08x_tx_add_sg(txd, direction, slave_addr,\n\t\t\t\t      sg_dma_address(sg),\n\t\t\t\t      sg_dma_len(sg));\n\t\tif (ret) {\n\t\t\tpl08x_release_mux(plchan);\n\t\t\tpl08x_free_txd(pl08x, txd);\n\t\t\tdev_err(&pl08x->adev->dev, \"%s no mem for pl080 sg\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tret = pl08x_fill_llis_for_desc(plchan->host, txd);\n\tif (!ret) {\n\t\tpl08x_release_mux(plchan);\n\t\tpl08x_free_txd(pl08x, txd);\n\t\treturn NULL;\n\t}\n\n\treturn vchan_tx_prep(&plchan->vc, &txd->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *pl08x_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tstruct pl08x_txd *txd;\n\tint ret, tmp;\n\tdma_addr_t slave_addr;\n\n\tdev_dbg(&pl08x->adev->dev,\n\t\t\"%s prepare cyclic transaction of %zd/%zd bytes %s %s\\n\",\n\t\t__func__, period_len, buf_len,\n\t\tdirection == DMA_MEM_TO_DEV ? \"to\" : \"from\",\n\t\tplchan->name);\n\n\ttxd = pl08x_init_txd(chan, direction, &slave_addr);\n\tif (!txd)\n\t\treturn NULL;\n\n\ttxd->cyclic = true;\n\ttxd->cctl |= PL080_CONTROL_TC_IRQ_EN;\n\tfor (tmp = 0; tmp < buf_len; tmp += period_len) {\n\t\tret = pl08x_tx_add_sg(txd, direction, slave_addr,\n\t\t\t\t      buf_addr + tmp, period_len);\n\t\tif (ret) {\n\t\t\tpl08x_release_mux(plchan);\n\t\t\tpl08x_free_txd(pl08x, txd);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tret = pl08x_fill_llis_for_desc(plchan->host, txd);\n\tif (!ret) {\n\t\tpl08x_release_mux(plchan);\n\t\tpl08x_free_txd(pl08x, txd);\n\t\treturn NULL;\n\t}\n\n\treturn vchan_tx_prep(&plchan->vc, &txd->vd, flags);\n}\n\nstatic int pl08x_config(struct dma_chan *chan,\n\t\t\tstruct dma_slave_config *config)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\n\tif (!plchan->slave)\n\t\treturn -EINVAL;\n\n\t \n\tif (config->src_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES ||\n\t    config->dst_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES)\n\t\treturn -EINVAL;\n\n\tif (config->device_fc && pl08x->vd->pl080s) {\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"%s: PL080S does not support peripheral flow control\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tplchan->cfg = *config;\n\n\treturn 0;\n}\n\nstatic int pl08x_terminate_all(struct dma_chan *chan)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tstruct pl08x_driver_data *pl08x = plchan->host;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&plchan->vc.lock, flags);\n\tif (!plchan->phychan && !plchan->at) {\n\t\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\t\treturn 0;\n\t}\n\n\tplchan->state = PL08X_CHAN_IDLE;\n\n\tif (plchan->phychan) {\n\t\t \n\t\tpl08x_phy_free(plchan);\n\t}\n\t \n\tif (plchan->at) {\n\t\tvchan_terminate_vdesc(&plchan->at->vd);\n\t\tplchan->at = NULL;\n\t}\n\t \n\tpl08x_free_txd_list(pl08x, plchan);\n\n\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic void pl08x_synchronize(struct dma_chan *chan)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\n\tvchan_synchronize(&plchan->vc);\n}\n\nstatic int pl08x_pause(struct dma_chan *chan)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&plchan->vc.lock, flags);\n\tif (!plchan->phychan && !plchan->at) {\n\t\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\t\treturn 0;\n\t}\n\n\tpl08x_pause_phy_chan(plchan->phychan);\n\tplchan->state = PL08X_CHAN_PAUSED;\n\n\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic int pl08x_resume(struct dma_chan *chan)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&plchan->vc.lock, flags);\n\tif (!plchan->phychan && !plchan->at) {\n\t\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\t\treturn 0;\n\t}\n\n\tpl08x_resume_phy_chan(plchan->phychan);\n\tplchan->state = PL08X_CHAN_RUNNING;\n\n\tspin_unlock_irqrestore(&plchan->vc.lock, flags);\n\n\treturn 0;\n}\n\nbool pl08x_filter_id(struct dma_chan *chan, void *chan_id)\n{\n\tstruct pl08x_dma_chan *plchan;\n\tchar *name = chan_id;\n\n\t \n\tif (chan->device->dev->driver != &pl08x_amba_driver.drv)\n\t\treturn false;\n\n\tplchan = to_pl08x_chan(chan);\n\n\t \n\tif (!strcmp(plchan->name, name))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(pl08x_filter_id);\n\nstatic bool pl08x_filter_fn(struct dma_chan *chan, void *chan_id)\n{\n\tstruct pl08x_dma_chan *plchan = to_pl08x_chan(chan);\n\n\treturn plchan->cd == chan_id;\n}\n\n \nstatic void pl08x_ensure_on(struct pl08x_driver_data *pl08x)\n{\n\t \n\tif (pl08x->vd->nomadik)\n\t\treturn;\n\t \n\tif (pl08x->vd->ftdmac020) {\n\t\twritel(PL080_CONFIG_ENABLE, pl08x->base + FTDMAC020_CSR);\n\t\treturn;\n\t}\n\twritel(PL080_CONFIG_ENABLE, pl08x->base + PL080_CONFIG);\n}\n\nstatic irqreturn_t pl08x_irq(int irq, void *dev)\n{\n\tstruct pl08x_driver_data *pl08x = dev;\n\tu32 mask = 0, err, tc, i;\n\n\t \n\terr = readl(pl08x->base + PL080_ERR_STATUS);\n\tif (err) {\n\t\tdev_err(&pl08x->adev->dev, \"%s error interrupt, register value 0x%08x\\n\",\n\t\t\t__func__, err);\n\t\twritel(err, pl08x->base + PL080_ERR_CLEAR);\n\t}\n\ttc = readl(pl08x->base + PL080_TC_STATUS);\n\tif (tc)\n\t\twritel(tc, pl08x->base + PL080_TC_CLEAR);\n\n\tif (!err && !tc)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < pl08x->vd->channels; i++) {\n\t\tif ((BIT(i) & err) || (BIT(i) & tc)) {\n\t\t\t \n\t\t\tstruct pl08x_phy_chan *phychan = &pl08x->phy_chans[i];\n\t\t\tstruct pl08x_dma_chan *plchan = phychan->serving;\n\t\t\tstruct pl08x_txd *tx;\n\n\t\t\tif (!plchan) {\n\t\t\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\t\t\"%s Error TC interrupt on unused channel: 0x%08x\\n\",\n\t\t\t\t\t__func__, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_lock(&plchan->vc.lock);\n\t\t\ttx = plchan->at;\n\t\t\tif (tx && tx->cyclic) {\n\t\t\t\tvchan_cyclic_callback(&tx->vd);\n\t\t\t} else if (tx) {\n\t\t\t\tplchan->at = NULL;\n\t\t\t\t \n\t\t\t\tpl08x_release_mux(plchan);\n\t\t\t\ttx->done = true;\n\t\t\t\tvchan_cookie_complete(&tx->vd);\n\n\t\t\t\t \n\t\t\t\tif (vchan_next_desc(&plchan->vc))\n\t\t\t\t\tpl08x_start_next_txd(plchan);\n\t\t\t\telse\n\t\t\t\t\tpl08x_phy_free(plchan);\n\t\t\t}\n\t\t\tspin_unlock(&plchan->vc.lock);\n\n\t\t\tmask |= BIT(i);\n\t\t}\n\t}\n\n\treturn mask ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void pl08x_dma_slave_init(struct pl08x_dma_chan *chan)\n{\n\tchan->slave = true;\n\tchan->name = chan->cd->bus_id;\n\tchan->cfg.src_addr = chan->cd->addr;\n\tchan->cfg.dst_addr = chan->cd->addr;\n}\n\n \nstatic int pl08x_dma_init_virtual_channels(struct pl08x_driver_data *pl08x,\n\t\tstruct dma_device *dmadev, unsigned int channels, bool slave)\n{\n\tstruct pl08x_dma_chan *chan;\n\tint i;\n\n\tINIT_LIST_HEAD(&dmadev->channels);\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\t\tif (!chan)\n\t\t\treturn -ENOMEM;\n\n\t\tchan->host = pl08x;\n\t\tchan->state = PL08X_CHAN_IDLE;\n\t\tchan->signal = -1;\n\n\t\tif (slave) {\n\t\t\tchan->cd = &pl08x->pd->slave_channels[i];\n\t\t\t \n\t\t\tchan->signal = i;\n\t\t\tpl08x_dma_slave_init(chan);\n\t\t} else {\n\t\t\tchan->cd = kzalloc(sizeof(*chan->cd), GFP_KERNEL);\n\t\t\tif (!chan->cd) {\n\t\t\t\tkfree(chan);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tchan->cd->bus_id = \"memcpy\";\n\t\t\tchan->cd->periph_buses = pl08x->pd->mem_buses;\n\t\t\tchan->name = kasprintf(GFP_KERNEL, \"memcpy%d\", i);\n\t\t\tif (!chan->name) {\n\t\t\t\tkfree(chan->cd);\n\t\t\t\tkfree(chan);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(&pl08x->adev->dev,\n\t\t\t \"initialize virtual channel \\\"%s\\\"\\n\",\n\t\t\t chan->name);\n\n\t\tchan->vc.desc_free = pl08x_desc_free;\n\t\tvchan_init(&chan->vc, dmadev);\n\t}\n\tdev_info(&pl08x->adev->dev, \"initialized %d virtual %s channels\\n\",\n\t\t i, slave ? \"slave\" : \"memcpy\");\n\treturn i;\n}\n\nstatic void pl08x_free_virtual_channels(struct dma_device *dmadev)\n{\n\tstruct pl08x_dma_chan *chan = NULL;\n\tstruct pl08x_dma_chan *next;\n\n\tlist_for_each_entry_safe(chan,\n\t\t\t\t next, &dmadev->channels, vc.chan.device_node) {\n\t\tlist_del(&chan->vc.chan.device_node);\n\t\tkfree(chan);\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic const char *pl08x_state_str(enum pl08x_dma_chan_state state)\n{\n\tswitch (state) {\n\tcase PL08X_CHAN_IDLE:\n\t\treturn \"idle\";\n\tcase PL08X_CHAN_RUNNING:\n\t\treturn \"running\";\n\tcase PL08X_CHAN_PAUSED:\n\t\treturn \"paused\";\n\tcase PL08X_CHAN_WAITING:\n\t\treturn \"waiting\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"UNKNOWN STATE\";\n}\n\nstatic int pl08x_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct pl08x_driver_data *pl08x = s->private;\n\tstruct pl08x_dma_chan *chan;\n\tstruct pl08x_phy_chan *ch;\n\tunsigned long flags;\n\tint i;\n\n\tseq_printf(s, \"PL08x physical channels:\\n\");\n\tseq_printf(s, \"CHANNEL:\\tUSER:\\n\");\n\tseq_printf(s, \"--------\\t-----\\n\");\n\tfor (i = 0; i < pl08x->vd->channels; i++) {\n\t\tstruct pl08x_dma_chan *virt_chan;\n\n\t\tch = &pl08x->phy_chans[i];\n\n\t\tspin_lock_irqsave(&ch->lock, flags);\n\t\tvirt_chan = ch->serving;\n\n\t\tseq_printf(s, \"%d\\t\\t%s%s\\n\",\n\t\t\t   ch->id,\n\t\t\t   virt_chan ? virt_chan->name : \"(none)\",\n\t\t\t   ch->locked ? \" LOCKED\" : \"\");\n\n\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\t}\n\n\tseq_printf(s, \"\\nPL08x virtual memcpy channels:\\n\");\n\tseq_printf(s, \"CHANNEL:\\tSTATE:\\n\");\n\tseq_printf(s, \"--------\\t------\\n\");\n\tlist_for_each_entry(chan, &pl08x->memcpy.channels, vc.chan.device_node) {\n\t\tseq_printf(s, \"%s\\t\\t%s\\n\", chan->name,\n\t\t\t   pl08x_state_str(chan->state));\n\t}\n\n\tif (pl08x->has_slave) {\n\t\tseq_printf(s, \"\\nPL08x virtual slave channels:\\n\");\n\t\tseq_printf(s, \"CHANNEL:\\tSTATE:\\n\");\n\t\tseq_printf(s, \"--------\\t------\\n\");\n\t\tlist_for_each_entry(chan, &pl08x->slave.channels,\n\t\t\t\t    vc.chan.device_node) {\n\t\t\tseq_printf(s, \"%s\\t\\t%s\\n\", chan->name,\n\t\t\t\t   pl08x_state_str(chan->state));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pl08x_debugfs);\n\nstatic void init_pl08x_debugfs(struct pl08x_driver_data *pl08x)\n{\n\t \n\tdebugfs_create_file(dev_name(&pl08x->adev->dev), S_IFREG | S_IRUGO,\n\t\t\t    NULL, pl08x, &pl08x_debugfs_fops);\n}\n\n#else\nstatic inline void init_pl08x_debugfs(struct pl08x_driver_data *pl08x)\n{\n}\n#endif\n\n#ifdef CONFIG_OF\nstatic struct dma_chan *pl08x_find_chan_id(struct pl08x_driver_data *pl08x,\n\t\t\t\t\t u32 id)\n{\n\tstruct pl08x_dma_chan *chan;\n\n\t \n\tif (!pl08x->has_slave)\n\t\treturn NULL;\n\n\tlist_for_each_entry(chan, &pl08x->slave.channels, vc.chan.device_node) {\n\t\tif (chan->signal == id)\n\t\t\treturn &chan->vc.chan;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct dma_chan *pl08x_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t       struct of_dma *ofdma)\n{\n\tstruct pl08x_driver_data *pl08x = ofdma->of_dma_data;\n\tstruct dma_chan *dma_chan;\n\tstruct pl08x_dma_chan *plchan;\n\n\tif (!pl08x)\n\t\treturn NULL;\n\n\tif (dma_spec->args_count != 2) {\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"DMA channel translation requires two cells\\n\");\n\t\treturn NULL;\n\t}\n\n\tdma_chan = pl08x_find_chan_id(pl08x, dma_spec->args[0]);\n\tif (!dma_chan) {\n\t\tdev_err(&pl08x->adev->dev,\n\t\t\t\"DMA slave channel not found\\n\");\n\t\treturn NULL;\n\t}\n\n\tplchan = to_pl08x_chan(dma_chan);\n\tdev_dbg(&pl08x->adev->dev,\n\t\t\"translated channel for signal %d\\n\",\n\t\tdma_spec->args[0]);\n\n\t \n\tplchan->cd->periph_buses = dma_spec->args[1];\n\treturn dma_get_slave_channel(dma_chan);\n}\n\nstatic int pl08x_of_probe(struct amba_device *adev,\n\t\t\t  struct pl08x_driver_data *pl08x,\n\t\t\t  struct device_node *np)\n{\n\tstruct pl08x_platform_data *pd;\n\tstruct pl08x_channel_data *chanp = NULL;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tpd = devm_kzalloc(&adev->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\t \n\tif (of_property_read_bool(np, \"lli-bus-interface-ahb1\"))\n\t\tpd->lli_buses |= PL08X_AHB1;\n\tif (of_property_read_bool(np, \"lli-bus-interface-ahb2\"))\n\t\tpd->lli_buses |= PL08X_AHB2;\n\tif (!pd->lli_buses) {\n\t\tdev_info(&adev->dev, \"no bus masters for LLIs stated, assume all\\n\");\n\t\tpd->lli_buses |= PL08X_AHB1 | PL08X_AHB2;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"mem-bus-interface-ahb1\"))\n\t\tpd->mem_buses |= PL08X_AHB1;\n\tif (of_property_read_bool(np, \"mem-bus-interface-ahb2\"))\n\t\tpd->mem_buses |= PL08X_AHB2;\n\tif (!pd->mem_buses) {\n\t\tdev_info(&adev->dev, \"no bus masters for memory stated, assume all\\n\");\n\t\tpd->mem_buses |= PL08X_AHB1 | PL08X_AHB2;\n\t}\n\n\t \n\tret = of_property_read_u32(np, \"memcpy-burst-size\", &val);\n\tif (ret) {\n\t\tdev_info(&adev->dev, \"no memcpy burst size specified, using 1 byte\\n\");\n\t\tval = 1;\n\t}\n\tswitch (val) {\n\tdefault:\n\t\tdev_err(&adev->dev, \"illegal burst size for memcpy, set to 1\\n\");\n\t\tfallthrough;\n\tcase 1:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_1;\n\t\tbreak;\n\tcase 4:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_4;\n\t\tbreak;\n\tcase 8:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_8;\n\t\tbreak;\n\tcase 16:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_16;\n\t\tbreak;\n\tcase 32:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_32;\n\t\tbreak;\n\tcase 64:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_64;\n\t\tbreak;\n\tcase 128:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_128;\n\t\tbreak;\n\tcase 256:\n\t\tpd->memcpy_burst_size = PL08X_BURST_SZ_256;\n\t\tbreak;\n\t}\n\n\tret = of_property_read_u32(np, \"memcpy-bus-width\", &val);\n\tif (ret) {\n\t\tdev_info(&adev->dev, \"no memcpy bus width specified, using 8 bits\\n\");\n\t\tval = 8;\n\t}\n\tswitch (val) {\n\tdefault:\n\t\tdev_err(&adev->dev, \"illegal bus width for memcpy, set to 8 bits\\n\");\n\t\tfallthrough;\n\tcase 8:\n\t\tpd->memcpy_bus_width = PL08X_BUS_WIDTH_8_BITS;\n\t\tbreak;\n\tcase 16:\n\t\tpd->memcpy_bus_width = PL08X_BUS_WIDTH_16_BITS;\n\t\tbreak;\n\tcase 32:\n\t\tpd->memcpy_bus_width = PL08X_BUS_WIDTH_32_BITS;\n\t\tbreak;\n\t}\n\n\t \n\tif (pl08x->vd->signals) {\n\t\tchanp = devm_kcalloc(&adev->dev,\n\t\t\t\t     pl08x->vd->signals,\n\t\t\t\t     sizeof(struct pl08x_channel_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!chanp)\n\t\t\treturn -ENOMEM;\n\n\t\tpd->slave_channels = chanp;\n\t\tfor (i = 0; i < pl08x->vd->signals; i++) {\n\t\t\t \n\t\t\tchanp->bus_id = kasprintf(GFP_KERNEL, \"slave%d\", i);\n\t\t\tchanp++;\n\t\t}\n\t\tpd->num_slave_channels = pl08x->vd->signals;\n\t}\n\n\tpl08x->pd = pd;\n\n\treturn of_dma_controller_register(adev->dev.of_node, pl08x_of_xlate,\n\t\t\t\t\t  pl08x);\n}\n#else\nstatic inline int pl08x_of_probe(struct amba_device *adev,\n\t\t\t\t struct pl08x_driver_data *pl08x,\n\t\t\t\t struct device_node *np)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int pl08x_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct pl08x_driver_data *pl08x;\n\tstruct vendor_data *vd = id->data;\n\tstruct device_node *np = adev->dev.of_node;\n\tu32 tsfr_size;\n\tint ret = 0;\n\tint i;\n\n\tret = amba_request_regions(adev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = dma_set_mask_and_coherent(&adev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto out_no_pl08x;\n\n\t \n\tpl08x = kzalloc(sizeof(*pl08x), GFP_KERNEL);\n\tif (!pl08x) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pl08x;\n\t}\n\n\t \n\tpl08x->adev = adev;\n\tpl08x->vd = vd;\n\n\tpl08x->base = ioremap(adev->res.start, resource_size(&adev->res));\n\tif (!pl08x->base) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_ioremap;\n\t}\n\n\tif (vd->ftdmac020) {\n\t\tu32 val;\n\n\t\tval = readl(pl08x->base + FTDMAC020_REVISION);\n\t\tdev_info(&pl08x->adev->dev, \"FTDMAC020 %d.%d rel %d\\n\",\n\t\t\t (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff);\n\t\tval = readl(pl08x->base + FTDMAC020_FEATURE);\n\t\tdev_info(&pl08x->adev->dev, \"FTDMAC020 %d channels, \"\n\t\t\t \"%s built-in bridge, %s, %s linked lists\\n\",\n\t\t\t (val >> 12) & 0x0f,\n\t\t\t (val & BIT(10)) ? \"no\" : \"has\",\n\t\t\t (val & BIT(9)) ? \"AHB0 and AHB1\" : \"AHB0\",\n\t\t\t (val & BIT(8)) ? \"supports\" : \"does not support\");\n\n\t\t \n\t\tif (!(val & BIT(8)))\n\t\t\tdev_warn(&pl08x->adev->dev,\n\t\t\t\t \"linked lists not supported, required\\n\");\n\t\tvd->channels = (val >> 12) & 0x0f;\n\t\tvd->dualmaster = !!(val & BIT(9));\n\t}\n\n\t \n\tdma_cap_set(DMA_MEMCPY, pl08x->memcpy.cap_mask);\n\tpl08x->memcpy.dev = &adev->dev;\n\tpl08x->memcpy.device_free_chan_resources = pl08x_free_chan_resources;\n\tpl08x->memcpy.device_prep_dma_memcpy = pl08x_prep_dma_memcpy;\n\tpl08x->memcpy.device_tx_status = pl08x_dma_tx_status;\n\tpl08x->memcpy.device_issue_pending = pl08x_issue_pending;\n\tpl08x->memcpy.device_config = pl08x_config;\n\tpl08x->memcpy.device_pause = pl08x_pause;\n\tpl08x->memcpy.device_resume = pl08x_resume;\n\tpl08x->memcpy.device_terminate_all = pl08x_terminate_all;\n\tpl08x->memcpy.device_synchronize = pl08x_synchronize;\n\tpl08x->memcpy.src_addr_widths = PL80X_DMA_BUSWIDTHS;\n\tpl08x->memcpy.dst_addr_widths = PL80X_DMA_BUSWIDTHS;\n\tpl08x->memcpy.directions = BIT(DMA_MEM_TO_MEM);\n\tpl08x->memcpy.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;\n\tif (vd->ftdmac020)\n\t\tpl08x->memcpy.copy_align = DMAENGINE_ALIGN_4_BYTES;\n\n\n\t \n\tif (vd->signals) {\n\t\tpl08x->has_slave = true;\n\t\tdma_cap_set(DMA_SLAVE, pl08x->slave.cap_mask);\n\t\tdma_cap_set(DMA_CYCLIC, pl08x->slave.cap_mask);\n\t\tpl08x->slave.dev = &adev->dev;\n\t\tpl08x->slave.device_free_chan_resources =\n\t\t\tpl08x_free_chan_resources;\n\t\tpl08x->slave.device_tx_status = pl08x_dma_tx_status;\n\t\tpl08x->slave.device_issue_pending = pl08x_issue_pending;\n\t\tpl08x->slave.device_prep_slave_sg = pl08x_prep_slave_sg;\n\t\tpl08x->slave.device_prep_dma_cyclic = pl08x_prep_dma_cyclic;\n\t\tpl08x->slave.device_config = pl08x_config;\n\t\tpl08x->slave.device_pause = pl08x_pause;\n\t\tpl08x->slave.device_resume = pl08x_resume;\n\t\tpl08x->slave.device_terminate_all = pl08x_terminate_all;\n\t\tpl08x->slave.device_synchronize = pl08x_synchronize;\n\t\tpl08x->slave.src_addr_widths = PL80X_DMA_BUSWIDTHS;\n\t\tpl08x->slave.dst_addr_widths = PL80X_DMA_BUSWIDTHS;\n\t\tpl08x->slave.directions =\n\t\t\tBIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\t\tpl08x->slave.residue_granularity =\n\t\t\tDMA_RESIDUE_GRANULARITY_SEGMENT;\n\t}\n\n\t \n\tpl08x->pd = dev_get_platdata(&adev->dev);\n\tif (!pl08x->pd) {\n\t\tif (np) {\n\t\t\tret = pl08x_of_probe(adev, pl08x, np);\n\t\t\tif (ret)\n\t\t\t\tgoto out_no_platdata;\n\t\t} else {\n\t\t\tdev_err(&adev->dev, \"no platform data supplied\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_no_platdata;\n\t\t}\n\t} else {\n\t\tpl08x->slave.filter.map = pl08x->pd->slave_map;\n\t\tpl08x->slave.filter.mapcnt = pl08x->pd->slave_map_len;\n\t\tpl08x->slave.filter.fn = pl08x_filter_fn;\n\t}\n\n\t \n\tpl08x->lli_buses = PL08X_AHB1;\n\tpl08x->mem_buses = PL08X_AHB1;\n\tif (pl08x->vd->dualmaster) {\n\t\tpl08x->lli_buses = pl08x->pd->lli_buses;\n\t\tpl08x->mem_buses = pl08x->pd->mem_buses;\n\t}\n\n\tif (vd->pl080s)\n\t\tpl08x->lli_words = PL080S_LLI_WORDS;\n\telse\n\t\tpl08x->lli_words = PL080_LLI_WORDS;\n\ttsfr_size = MAX_NUM_TSFR_LLIS * pl08x->lli_words * sizeof(u32);\n\n\t \n\tpl08x->pool = dma_pool_create(DRIVER_NAME, &pl08x->adev->dev,\n\t\t\t\t\t\ttsfr_size, PL08X_ALIGN, 0);\n\tif (!pl08x->pool) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_lli_pool;\n\t}\n\n\t \n\tpl08x_ensure_on(pl08x);\n\n\t \n\tif (vd->ftdmac020)\n\t\t \n\t\twritel(0x0000FFFF, pl08x->base + PL080_ERR_CLEAR);\n\telse\n\t\twritel(0x000000FF, pl08x->base + PL080_ERR_CLEAR);\n\twritel(0x000000FF, pl08x->base + PL080_TC_CLEAR);\n\n\t \n\tret = request_irq(adev->irq[0], pl08x_irq, 0, DRIVER_NAME, pl08x);\n\tif (ret) {\n\t\tdev_err(&adev->dev, \"%s failed to request interrupt %d\\n\",\n\t\t\t__func__, adev->irq[0]);\n\t\tgoto out_no_irq;\n\t}\n\n\t \n\tpl08x->phy_chans = kzalloc((vd->channels * sizeof(*pl08x->phy_chans)),\n\t\t\tGFP_KERNEL);\n\tif (!pl08x->phy_chans) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_phychans;\n\t}\n\n\tfor (i = 0; i < vd->channels; i++) {\n\t\tstruct pl08x_phy_chan *ch = &pl08x->phy_chans[i];\n\n\t\tch->id = i;\n\t\tch->base = pl08x->base + PL080_Cx_BASE(i);\n\t\tif (vd->ftdmac020) {\n\t\t\t \n\t\t\tch->reg_busy = ch->base + FTDMAC020_CH_BUSY;\n\t\t\tch->reg_config = ch->base + FTDMAC020_CH_CFG;\n\t\t\tch->reg_control = ch->base + FTDMAC020_CH_CSR;\n\t\t\tch->reg_src = ch->base + FTDMAC020_CH_SRC_ADDR;\n\t\t\tch->reg_dst = ch->base + FTDMAC020_CH_DST_ADDR;\n\t\t\tch->reg_lli = ch->base + FTDMAC020_CH_LLP;\n\t\t\tch->ftdmac020 = true;\n\t\t} else {\n\t\t\tch->reg_config = ch->base + vd->config_offset;\n\t\t\tch->reg_control = ch->base + PL080_CH_CONTROL;\n\t\t\tch->reg_src = ch->base + PL080_CH_SRC_ADDR;\n\t\t\tch->reg_dst = ch->base + PL080_CH_DST_ADDR;\n\t\t\tch->reg_lli = ch->base + PL080_CH_LLI;\n\t\t}\n\t\tif (vd->pl080s)\n\t\t\tch->pl080s = true;\n\n\t\tspin_lock_init(&ch->lock);\n\n\t\t \n\t\tif (vd->nomadik) {\n\t\t\tu32 val;\n\n\t\t\tval = readl(ch->reg_config);\n\t\t\tif (val & (PL080N_CONFIG_ITPROT | PL080N_CONFIG_SECPROT)) {\n\t\t\t\tdev_info(&adev->dev, \"physical channel %d reserved for secure access only\\n\", i);\n\t\t\t\tch->locked = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&adev->dev, \"physical channel %d is %s\\n\",\n\t\t\ti, pl08x_phy_channel_busy(ch) ? \"BUSY\" : \"FREE\");\n\t}\n\n\t \n\tret = pl08x_dma_init_virtual_channels(pl08x, &pl08x->memcpy,\n\t\t\t\t\t      pl08x->vd->channels, false);\n\tif (ret <= 0) {\n\t\tdev_warn(&pl08x->adev->dev,\n\t\t\t \"%s failed to enumerate memcpy channels - %d\\n\",\n\t\t\t __func__, ret);\n\t\tgoto out_no_memcpy;\n\t}\n\n\t \n\tif (pl08x->has_slave) {\n\t\tret = pl08x_dma_init_virtual_channels(pl08x, &pl08x->slave,\n\t\t\t\t\tpl08x->pd->num_slave_channels, true);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&pl08x->adev->dev,\n\t\t\t\t \"%s failed to enumerate slave channels - %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto out_no_slave;\n\t\t}\n\t}\n\n\tret = dma_async_device_register(&pl08x->memcpy);\n\tif (ret) {\n\t\tdev_warn(&pl08x->adev->dev,\n\t\t\t\"%s failed to register memcpy as an async device - %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto out_no_memcpy_reg;\n\t}\n\n\tif (pl08x->has_slave) {\n\t\tret = dma_async_device_register(&pl08x->slave);\n\t\tif (ret) {\n\t\t\tdev_warn(&pl08x->adev->dev,\n\t\t\t\"%s failed to register slave as an async device - %d\\n\",\n\t\t\t__func__, ret);\n\t\t\tgoto out_no_slave_reg;\n\t\t}\n\t}\n\n\tamba_set_drvdata(adev, pl08x);\n\tinit_pl08x_debugfs(pl08x);\n\tdev_info(&pl08x->adev->dev, \"DMA: PL%03x%s rev%u at 0x%08llx irq %d\\n\",\n\t\t amba_part(adev), pl08x->vd->pl080s ? \"s\" : \"\", amba_rev(adev),\n\t\t (unsigned long long)adev->res.start, adev->irq[0]);\n\n\treturn 0;\n\nout_no_slave_reg:\n\tdma_async_device_unregister(&pl08x->memcpy);\nout_no_memcpy_reg:\n\tif (pl08x->has_slave)\n\t\tpl08x_free_virtual_channels(&pl08x->slave);\nout_no_slave:\n\tpl08x_free_virtual_channels(&pl08x->memcpy);\nout_no_memcpy:\n\tkfree(pl08x->phy_chans);\nout_no_phychans:\n\tfree_irq(adev->irq[0], pl08x);\nout_no_irq:\n\tdma_pool_destroy(pl08x->pool);\nout_no_lli_pool:\nout_no_platdata:\n\tiounmap(pl08x->base);\nout_no_ioremap:\n\tkfree(pl08x);\nout_no_pl08x:\n\tamba_release_regions(adev);\n\treturn ret;\n}\n\n \nstatic struct vendor_data vendor_pl080 = {\n\t.config_offset = PL080_CH_CONFIG,\n\t.channels = 8,\n\t.signals = 16,\n\t.dualmaster = true,\n\t.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,\n};\n\nstatic struct vendor_data vendor_nomadik = {\n\t.config_offset = PL080_CH_CONFIG,\n\t.channels = 8,\n\t.signals = 32,\n\t.dualmaster = true,\n\t.nomadik = true,\n\t.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,\n};\n\nstatic struct vendor_data vendor_pl080s = {\n\t.config_offset = PL080S_CH_CONFIG,\n\t.channels = 8,\n\t.signals = 32,\n\t.pl080s = true,\n\t.max_transfer_size = PL080S_CONTROL_TRANSFER_SIZE_MASK,\n};\n\nstatic struct vendor_data vendor_pl081 = {\n\t.config_offset = PL080_CH_CONFIG,\n\t.channels = 2,\n\t.signals = 16,\n\t.dualmaster = false,\n\t.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,\n};\n\nstatic struct vendor_data vendor_ftdmac020 = {\n\t.config_offset = PL080_CH_CONFIG,\n\t.ftdmac020 = true,\n\t.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,\n};\n\nstatic const struct amba_id pl08x_ids[] = {\n\t \n\t{\n\t\t.id\t= 0x0a141080,\n\t\t.mask\t= 0xffffffff,\n\t\t.data\t= &vendor_pl080s,\n\t},\n\t \n\t{\n\t\t.id\t= 0x00041080,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_pl080,\n\t},\n\t \n\t{\n\t\t.id\t= 0x00041081,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_pl081,\n\t},\n\t \n\t{\n\t\t.id\t= 0x00280080,\n\t\t.mask\t= 0x00ffffff,\n\t\t.data\t= &vendor_nomadik,\n\t},\n\t \n\t{\n\t\t.id\t= 0x0003b080,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &vendor_ftdmac020,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl08x_ids);\n\nstatic struct amba_driver pl08x_amba_driver = {\n\t.drv.name\t= DRIVER_NAME,\n\t.id_table\t= pl08x_ids,\n\t.probe\t\t= pl08x_probe,\n};\n\nstatic int __init pl08x_init(void)\n{\n\tint retval;\n\tretval = amba_driver_register(&pl08x_amba_driver);\n\tif (retval)\n\t\tprintk(KERN_WARNING DRIVER_NAME\n\t\t       \"failed to register as an AMBA device (%d)\\n\",\n\t\t       retval);\n\treturn retval;\n}\nsubsys_initcall(pl08x_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}