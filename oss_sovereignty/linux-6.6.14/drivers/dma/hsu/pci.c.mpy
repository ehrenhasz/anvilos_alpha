{
  "module_name": "pci.c",
  "hash_id": "05fd5a4490984d4a81de241edeb1d47cf5905cc201b9fbc16731f91987d7e66f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/hsu/pci.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"hsu.h\"\n\n#define HSU_PCI_DMASR\t\t0x00\n#define HSU_PCI_DMAISR\t\t0x04\n\n#define HSU_PCI_CHAN_OFFSET\t0x100\n\n#define PCI_DEVICE_ID_INTEL_MFLD_HSU_DMA\t0x081e\n#define PCI_DEVICE_ID_INTEL_MRFLD_HSU_DMA\t0x1192\n\nstatic irqreturn_t hsu_pci_irq(int irq, void *dev)\n{\n\tstruct hsu_dma_chip *chip = dev;\n\tunsigned long dmaisr;\n\tunsigned short i;\n\tu32 status;\n\tint ret = 0;\n\tint err;\n\n\tdmaisr = readl(chip->regs + HSU_PCI_DMAISR);\n\tfor_each_set_bit(i, &dmaisr, chip->hsu->nr_channels) {\n\t\terr = hsu_dma_get_status(chip, i, &status);\n\t\tif (err > 0)\n\t\t\tret |= 1;\n\t\telse if (err == 0)\n\t\t\tret |= hsu_dma_do_irq(chip, i, status);\n\t}\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic void hsu_pci_dma_remove(void *chip)\n{\n\thsu_dma_remove(chip);\n}\n\nstatic int hsu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hsu_dma_chip *chip;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I/O memory remapping failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->dev = &pdev->dev;\n\tchip->regs = pcim_iomap_table(pdev)[0];\n\tchip->length = pci_resource_len(pdev, 0);\n\tchip->offset = HSU_PCI_CHAN_OFFSET;\n\tchip->irq = pci_irq_vector(pdev, 0);\n\n\tret = hsu_dma_probe(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, hsu_pci_dma_remove, chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, chip->irq, hsu_pci_irq, 0, \"hsu_dma_pci\", chip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_INTEL_MRFLD_HSU_DMA)\n\t\tdisable_irq_nosync(chip->irq);\n\n\tpci_set_drvdata(pdev, chip);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id hsu_pci_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_MFLD_HSU_DMA), 0 },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_MRFLD_HSU_DMA), 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, hsu_pci_id_table);\n\nstatic struct pci_driver hsu_pci_driver = {\n\t.name\t\t= \"hsu_dma_pci\",\n\t.id_table\t= hsu_pci_id_table,\n\t.probe\t\t= hsu_pci_probe,\n};\n\nmodule_pci_driver(hsu_pci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"High Speed UART DMA PCI driver\");\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}