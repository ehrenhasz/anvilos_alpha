{
  "module_name": "init.c",
  "hash_id": "80a3a8858d5fa5497d23e3c9c32009024d7b85d6a6dc7563f3387af4b2790437",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ioat/init.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/workqueue.h>\n#include <linux/prefetch.h>\n#include <linux/dca.h>\n#include <linux/sizes.h>\n#include \"dma.h\"\n#include \"registers.h\"\n#include \"hw.h\"\n\n#include \"../dmaengine.h\"\n\nMODULE_VERSION(IOAT_DMA_VERSION);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Intel Corporation\");\n\nstatic const struct pci_device_id ioat_pci_tbl[] = {\n\t \n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_TBG7) },\n\n\t \n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF7) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF8) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_JSF9) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB7) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB8) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB9) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB7) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB8) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_IVB9) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW7) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW8) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_HSW9) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX3) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX4) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX5) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX6) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX7) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX8) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX9) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SKX) },\n\n\t \n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD3) },\n\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDXDE0) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDXDE1) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDXDE2) },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDXDE3) },\n\n\t \n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_ICX) },\n\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ioat_pci_tbl);\n\nstatic int ioat_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id);\nstatic void ioat_remove(struct pci_dev *pdev);\nstatic void\nioat_init_channel(struct ioatdma_device *ioat_dma,\n\t\t  struct ioatdma_chan *ioat_chan, int idx);\nstatic void ioat_intr_quirk(struct ioatdma_device *ioat_dma);\nstatic void ioat_enumerate_channels(struct ioatdma_device *ioat_dma);\nstatic int ioat3_dma_self_test(struct ioatdma_device *ioat_dma);\n\nstatic int ioat_dca_enabled = 1;\nmodule_param(ioat_dca_enabled, int, 0644);\nMODULE_PARM_DESC(ioat_dca_enabled, \"control support of dca service (default: 1)\");\nint ioat_pending_level = 7;\nmodule_param(ioat_pending_level, int, 0644);\nMODULE_PARM_DESC(ioat_pending_level,\n\t\t \"high-water mark for pushing ioat descriptors (default: 7)\");\nstatic char ioat_interrupt_style[32] = \"msix\";\nmodule_param_string(ioat_interrupt_style, ioat_interrupt_style,\n\t\t    sizeof(ioat_interrupt_style), 0644);\nMODULE_PARM_DESC(ioat_interrupt_style,\n\t\t \"set ioat interrupt style: msix (default), msi, intx\");\n\nstruct kmem_cache *ioat_cache;\nstruct kmem_cache *ioat_sed_cache;\n\nstatic bool is_jf_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF4:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF5:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF6:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF7:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF8:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_JSF9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_snb_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB4:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB5:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB6:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB7:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB8:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_SNB9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_ivb_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB4:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB5:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB6:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB7:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB8:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_IVB9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\nstatic bool is_hsw_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW4:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW5:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW6:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW7:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW8:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_HSW9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\nstatic bool is_bdx_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX4:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX5:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX6:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX7:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX8:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDX9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool is_skx_ioat(struct pci_dev *pdev)\n{\n\treturn (pdev->device == PCI_DEVICE_ID_INTEL_IOAT_SKX) ? true : false;\n}\n\nstatic bool is_xeon_cb32(struct pci_dev *pdev)\n{\n\treturn is_jf_ioat(pdev) || is_snb_ioat(pdev) || is_ivb_ioat(pdev) ||\n\t\tis_hsw_ioat(pdev) || is_bdx_ioat(pdev) || is_skx_ioat(pdev);\n}\n\nbool is_bwd_ioat(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD3:\n\t \n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_bwd_noraid(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BWD3:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE0:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE1:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE2:\n\tcase PCI_DEVICE_ID_INTEL_IOAT_BDXDE3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\n \n#define IOAT_TEST_SIZE 2000\n\nstatic void ioat_dma_test_callback(void *dma_async_param)\n{\n\tstruct completion *cmp = dma_async_param;\n\n\tcomplete(cmp);\n}\n\n \nstatic int ioat_dma_self_test(struct ioatdma_device *ioat_dma)\n{\n\tint i;\n\tu8 *src;\n\tu8 *dest;\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tstruct device *dev = &ioat_dma->pdev->dev;\n\tstruct dma_chan *dma_chan;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_addr_t dma_dest, dma_src;\n\tdma_cookie_t cookie;\n\tint err = 0;\n\tstruct completion cmp;\n\tunsigned long tmo;\n\tunsigned long flags;\n\n\tsrc = kzalloc(IOAT_TEST_SIZE, GFP_KERNEL);\n\tif (!src)\n\t\treturn -ENOMEM;\n\tdest = kzalloc(IOAT_TEST_SIZE, GFP_KERNEL);\n\tif (!dest) {\n\t\tkfree(src);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < IOAT_TEST_SIZE; i++)\n\t\tsrc[i] = (u8)i;\n\n\t \n\tdma_chan = container_of(dma->channels.next, struct dma_chan,\n\t\t\t\tdevice_node);\n\tif (dma->device_alloc_chan_resources(dma_chan) < 1) {\n\t\tdev_err(dev, \"selftest cannot allocate chan resource\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdma_src = dma_map_single(dev, src, IOAT_TEST_SIZE, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_src)) {\n\t\tdev_err(dev, \"mapping src buffer failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_resources;\n\t}\n\tdma_dest = dma_map_single(dev, dest, IOAT_TEST_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dma_dest)) {\n\t\tdev_err(dev, \"mapping dest buffer failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto unmap_src;\n\t}\n\tflags = DMA_PREP_INTERRUPT;\n\ttx = ioat_dma->dma_dev.device_prep_dma_memcpy(dma_chan, dma_dest,\n\t\t\t\t\t\t      dma_src, IOAT_TEST_SIZE,\n\t\t\t\t\t\t      flags);\n\tif (!tx) {\n\t\tdev_err(dev, \"Self-test prep failed, disabling\\n\");\n\t\terr = -ENODEV;\n\t\tgoto unmap_dma;\n\t}\n\n\tasync_tx_ack(tx);\n\tinit_completion(&cmp);\n\ttx->callback = ioat_dma_test_callback;\n\ttx->callback_param = &cmp;\n\tcookie = tx->tx_submit(tx);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Self-test setup failed, disabling\\n\");\n\t\terr = -ENODEV;\n\t\tgoto unmap_dma;\n\t}\n\tdma->device_issue_pending(dma_chan);\n\n\ttmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));\n\n\tif (tmo == 0 ||\n\t    dma->device_tx_status(dma_chan, cookie, NULL)\n\t\t\t\t\t!= DMA_COMPLETE) {\n\t\tdev_err(dev, \"Self-test copy timed out, disabling\\n\");\n\t\terr = -ENODEV;\n\t\tgoto unmap_dma;\n\t}\n\tif (memcmp(src, dest, IOAT_TEST_SIZE)) {\n\t\tdev_err(dev, \"Self-test copy failed compare, disabling\\n\");\n\t\terr = -ENODEV;\n\t\tgoto unmap_dma;\n\t}\n\nunmap_dma:\n\tdma_unmap_single(dev, dma_dest, IOAT_TEST_SIZE, DMA_FROM_DEVICE);\nunmap_src:\n\tdma_unmap_single(dev, dma_src, IOAT_TEST_SIZE, DMA_TO_DEVICE);\nfree_resources:\n\tdma->device_free_chan_resources(dma_chan);\nout:\n\tkfree(src);\n\tkfree(dest);\n\treturn err;\n}\n\n \nint ioat_dma_setup_interrupts(struct ioatdma_device *ioat_dma)\n{\n\tstruct ioatdma_chan *ioat_chan;\n\tstruct pci_dev *pdev = ioat_dma->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct msix_entry *msix;\n\tint i, j, msixcnt;\n\tint err = -EINVAL;\n\tu8 intrctrl = 0;\n\n\tif (!strcmp(ioat_interrupt_style, \"msix\"))\n\t\tgoto msix;\n\tif (!strcmp(ioat_interrupt_style, \"msi\"))\n\t\tgoto msi;\n\tif (!strcmp(ioat_interrupt_style, \"intx\"))\n\t\tgoto intx;\n\tdev_err(dev, \"invalid ioat_interrupt_style %s\\n\", ioat_interrupt_style);\n\tgoto err_no_irq;\n\nmsix:\n\t \n\tmsixcnt = ioat_dma->chancnt;\n\tfor (i = 0; i < msixcnt; i++)\n\t\tioat_dma->msix_entries[i].entry = i;\n\n\terr = pci_enable_msix_exact(pdev, ioat_dma->msix_entries, msixcnt);\n\tif (err)\n\t\tgoto msi;\n\n\tfor (i = 0; i < msixcnt; i++) {\n\t\tmsix = &ioat_dma->msix_entries[i];\n\t\tioat_chan = ioat_chan_by_index(ioat_dma, i);\n\t\terr = devm_request_irq(dev, msix->vector,\n\t\t\t\t       ioat_dma_do_interrupt_msix, 0,\n\t\t\t\t       \"ioat-msix\", ioat_chan);\n\t\tif (err) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tmsix = &ioat_dma->msix_entries[j];\n\t\t\t\tioat_chan = ioat_chan_by_index(ioat_dma, j);\n\t\t\t\tdevm_free_irq(dev, msix->vector, ioat_chan);\n\t\t\t}\n\t\t\tgoto msi;\n\t\t}\n\t}\n\tintrctrl |= IOAT_INTRCTRL_MSIX_VECTOR_CONTROL;\n\tioat_dma->irq_mode = IOAT_MSIX;\n\tgoto done;\n\nmsi:\n\terr = pci_enable_msi(pdev);\n\tif (err)\n\t\tgoto intx;\n\n\terr = devm_request_irq(dev, pdev->irq, ioat_dma_do_interrupt, 0,\n\t\t\t       \"ioat-msi\", ioat_dma);\n\tif (err) {\n\t\tpci_disable_msi(pdev);\n\t\tgoto intx;\n\t}\n\tioat_dma->irq_mode = IOAT_MSI;\n\tgoto done;\n\nintx:\n\terr = devm_request_irq(dev, pdev->irq, ioat_dma_do_interrupt,\n\t\t\t       IRQF_SHARED, \"ioat-intx\", ioat_dma);\n\tif (err)\n\t\tgoto err_no_irq;\n\n\tioat_dma->irq_mode = IOAT_INTX;\ndone:\n\tif (is_bwd_ioat(pdev))\n\t\tioat_intr_quirk(ioat_dma);\n\tintrctrl |= IOAT_INTRCTRL_MASTER_INT_EN;\n\twriteb(intrctrl, ioat_dma->reg_base + IOAT_INTRCTRL_OFFSET);\n\treturn 0;\n\nerr_no_irq:\n\t \n\twriteb(0, ioat_dma->reg_base + IOAT_INTRCTRL_OFFSET);\n\tioat_dma->irq_mode = IOAT_NOIRQ;\n\tdev_err(dev, \"no usable interrupts\\n\");\n\treturn err;\n}\n\nstatic void ioat_disable_interrupts(struct ioatdma_device *ioat_dma)\n{\n\t \n\twriteb(0, ioat_dma->reg_base + IOAT_INTRCTRL_OFFSET);\n}\n\nstatic int ioat_probe(struct ioatdma_device *ioat_dma)\n{\n\tint err = -ENODEV;\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tstruct pci_dev *pdev = ioat_dma->pdev;\n\tstruct device *dev = &pdev->dev;\n\n\tioat_dma->completion_pool = dma_pool_create(\"completion_pool\", dev,\n\t\t\t\t\t\t    sizeof(u64),\n\t\t\t\t\t\t    SMP_CACHE_BYTES,\n\t\t\t\t\t\t    SMP_CACHE_BYTES);\n\n\tif (!ioat_dma->completion_pool) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tioat_enumerate_channels(ioat_dma);\n\n\tdma_cap_set(DMA_MEMCPY, dma->cap_mask);\n\tdma->dev = &pdev->dev;\n\n\tif (!ioat_dma->chancnt) {\n\t\tdev_err(dev, \"channel enumeration error\\n\");\n\t\tgoto err_setup_interrupts;\n\t}\n\n\terr = ioat_dma_setup_interrupts(ioat_dma);\n\tif (err)\n\t\tgoto err_setup_interrupts;\n\n\terr = ioat3_dma_self_test(ioat_dma);\n\tif (err)\n\t\tgoto err_self_test;\n\n\treturn 0;\n\nerr_self_test:\n\tioat_disable_interrupts(ioat_dma);\nerr_setup_interrupts:\n\tdma_pool_destroy(ioat_dma->completion_pool);\nerr_out:\n\treturn err;\n}\n\nstatic int ioat_register(struct ioatdma_device *ioat_dma)\n{\n\tint err = dma_async_device_register(&ioat_dma->dma_dev);\n\n\tif (err) {\n\t\tioat_disable_interrupts(ioat_dma);\n\t\tdma_pool_destroy(ioat_dma->completion_pool);\n\t}\n\n\treturn err;\n}\n\nstatic void ioat_dma_remove(struct ioatdma_device *ioat_dma)\n{\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\n\tioat_disable_interrupts(ioat_dma);\n\n\tioat_kobject_del(ioat_dma);\n\n\tdma_async_device_unregister(dma);\n}\n\n \nstatic void ioat_enumerate_channels(struct ioatdma_device *ioat_dma)\n{\n\tstruct ioatdma_chan *ioat_chan;\n\tstruct device *dev = &ioat_dma->pdev->dev;\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tu8 xfercap_log;\n\tint chancnt;\n\tint i;\n\n\tINIT_LIST_HEAD(&dma->channels);\n\tchancnt = readb(ioat_dma->reg_base + IOAT_CHANCNT_OFFSET);\n\tchancnt &= 0x1f;  \n\tif (chancnt > ARRAY_SIZE(ioat_dma->idx)) {\n\t\tdev_warn(dev, \"(%d) exceeds max supported channels (%zu)\\n\",\n\t\t\t chancnt, ARRAY_SIZE(ioat_dma->idx));\n\t\tchancnt = ARRAY_SIZE(ioat_dma->idx);\n\t}\n\txfercap_log = readb(ioat_dma->reg_base + IOAT_XFERCAP_OFFSET);\n\txfercap_log &= 0x1f;  \n\tif (xfercap_log == 0)\n\t\treturn;\n\tdev_dbg(dev, \"%s: xfercap = %d\\n\", __func__, 1 << xfercap_log);\n\n\tfor (i = 0; i < chancnt; i++) {\n\t\tioat_chan = kzalloc(sizeof(*ioat_chan), GFP_KERNEL);\n\t\tif (!ioat_chan)\n\t\t\tbreak;\n\n\t\tioat_init_channel(ioat_dma, ioat_chan, i);\n\t\tioat_chan->xfercap_log = xfercap_log;\n\t\tspin_lock_init(&ioat_chan->prep_lock);\n\t\tif (ioat_reset_hw(ioat_chan)) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tioat_dma->chancnt = i;\n}\n\n \nstatic void ioat_free_chan_resources(struct dma_chan *c)\n{\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\tstruct ioatdma_device *ioat_dma = ioat_chan->ioat_dma;\n\tstruct ioat_ring_ent *desc;\n\tconst int total_descs = 1 << ioat_chan->alloc_order;\n\tint descs;\n\tint i;\n\n\t \n\tif (!ioat_chan->ring)\n\t\treturn;\n\n\tioat_stop(ioat_chan);\n\n\tif (!test_bit(IOAT_CHAN_DOWN, &ioat_chan->state)) {\n\t\tioat_reset_hw(ioat_chan);\n\n\t\t \n\t\tif (ioat_dma->version >= IOAT_VER_3_4)\n\t\t\twriteb(IOAT_CHAN_LTR_SWSEL_IDLE,\n\t\t\t       ioat_chan->reg_base +\n\t\t\t       IOAT_CHAN_LTR_SWSEL_OFFSET);\n\t}\n\n\tspin_lock_bh(&ioat_chan->cleanup_lock);\n\tspin_lock_bh(&ioat_chan->prep_lock);\n\tdescs = ioat_ring_space(ioat_chan);\n\tdev_dbg(to_dev(ioat_chan), \"freeing %d idle descriptors\\n\", descs);\n\tfor (i = 0; i < descs; i++) {\n\t\tdesc = ioat_get_ring_ent(ioat_chan, ioat_chan->head + i);\n\t\tioat_free_ring_ent(desc, c);\n\t}\n\n\tif (descs < total_descs)\n\t\tdev_err(to_dev(ioat_chan), \"Freeing %d in use descriptors!\\n\",\n\t\t\ttotal_descs - descs);\n\n\tfor (i = 0; i < total_descs - descs; i++) {\n\t\tdesc = ioat_get_ring_ent(ioat_chan, ioat_chan->tail + i);\n\t\tdump_desc_dbg(ioat_chan, desc);\n\t\tioat_free_ring_ent(desc, c);\n\t}\n\n\tfor (i = 0; i < ioat_chan->desc_chunks; i++) {\n\t\tdma_free_coherent(to_dev(ioat_chan), IOAT_CHUNK_SIZE,\n\t\t\t\t  ioat_chan->descs[i].virt,\n\t\t\t\t  ioat_chan->descs[i].hw);\n\t\tioat_chan->descs[i].virt = NULL;\n\t\tioat_chan->descs[i].hw = 0;\n\t}\n\tioat_chan->desc_chunks = 0;\n\n\tkfree(ioat_chan->ring);\n\tioat_chan->ring = NULL;\n\tioat_chan->alloc_order = 0;\n\tdma_pool_free(ioat_dma->completion_pool, ioat_chan->completion,\n\t\t      ioat_chan->completion_dma);\n\tspin_unlock_bh(&ioat_chan->prep_lock);\n\tspin_unlock_bh(&ioat_chan->cleanup_lock);\n\n\tioat_chan->last_completion = 0;\n\tioat_chan->completion_dma = 0;\n\tioat_chan->dmacount = 0;\n}\n\n \nstatic int ioat_alloc_chan_resources(struct dma_chan *c)\n{\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\tstruct ioat_ring_ent **ring;\n\tu64 status;\n\tint order;\n\tint i = 0;\n\tu32 chanerr;\n\n\t \n\tif (ioat_chan->ring)\n\t\treturn 1 << ioat_chan->alloc_order;\n\n\t \n\twritew(IOAT_CHANCTRL_RUN, ioat_chan->reg_base + IOAT_CHANCTRL_OFFSET);\n\n\t \n\t \n\tioat_chan->completion =\n\t\tdma_pool_zalloc(ioat_chan->ioat_dma->completion_pool,\n\t\t\t\tGFP_NOWAIT, &ioat_chan->completion_dma);\n\tif (!ioat_chan->completion)\n\t\treturn -ENOMEM;\n\n\twritel(((u64)ioat_chan->completion_dma) & 0x00000000FFFFFFFF,\n\t       ioat_chan->reg_base + IOAT_CHANCMP_OFFSET_LOW);\n\twritel(((u64)ioat_chan->completion_dma) >> 32,\n\t       ioat_chan->reg_base + IOAT_CHANCMP_OFFSET_HIGH);\n\n\torder = IOAT_MAX_ORDER;\n\tring = ioat_alloc_ring(c, order, GFP_NOWAIT);\n\tif (!ring)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&ioat_chan->cleanup_lock);\n\tspin_lock_bh(&ioat_chan->prep_lock);\n\tioat_chan->ring = ring;\n\tioat_chan->head = 0;\n\tioat_chan->issued = 0;\n\tioat_chan->tail = 0;\n\tioat_chan->alloc_order = order;\n\tset_bit(IOAT_RUN, &ioat_chan->state);\n\tspin_unlock_bh(&ioat_chan->prep_lock);\n\tspin_unlock_bh(&ioat_chan->cleanup_lock);\n\n\t \n\tif (ioat_chan->ioat_dma->version >= IOAT_VER_3_4) {\n\t\tu32 lat_val;\n\n\t\tlat_val = IOAT_CHAN_LTR_ACTIVE_SNVAL |\n\t\t\tIOAT_CHAN_LTR_ACTIVE_SNLATSCALE |\n\t\t\tIOAT_CHAN_LTR_ACTIVE_SNREQMNT;\n\t\twritel(lat_val, ioat_chan->reg_base +\n\t\t\t\tIOAT_CHAN_LTR_ACTIVE_OFFSET);\n\n\t\tlat_val = IOAT_CHAN_LTR_IDLE_SNVAL |\n\t\t\t  IOAT_CHAN_LTR_IDLE_SNLATSCALE |\n\t\t\t  IOAT_CHAN_LTR_IDLE_SNREQMNT;\n\t\twritel(lat_val, ioat_chan->reg_base +\n\t\t\t\tIOAT_CHAN_LTR_IDLE_OFFSET);\n\n\t\t \n\t\twriteb(IOAT_CHAN_LTR_SWSEL_ACTIVE,\n\t\t       ioat_chan->reg_base +\n\t\t       IOAT_CHAN_LTR_SWSEL_OFFSET);\n\t}\n\n\tioat_start_null_desc(ioat_chan);\n\n\t \n\tdo {\n\t\tudelay(1);\n\t\tstatus = ioat_chansts(ioat_chan);\n\t} while (i++ < 20 && !is_ioat_active(status) && !is_ioat_idle(status));\n\n\tif (is_ioat_active(status) || is_ioat_idle(status))\n\t\treturn 1 << ioat_chan->alloc_order;\n\n\tchanerr = readl(ioat_chan->reg_base + IOAT_CHANERR_OFFSET);\n\n\tdev_WARN(to_dev(ioat_chan),\n\t\t \"failed to start channel chanerr: %#x\\n\", chanerr);\n\tioat_free_chan_resources(c);\n\treturn -EFAULT;\n}\n\n \nstatic void\nioat_init_channel(struct ioatdma_device *ioat_dma,\n\t\t  struct ioatdma_chan *ioat_chan, int idx)\n{\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\n\tioat_chan->ioat_dma = ioat_dma;\n\tioat_chan->reg_base = ioat_dma->reg_base + (0x80 * (idx + 1));\n\tspin_lock_init(&ioat_chan->cleanup_lock);\n\tioat_chan->dma_chan.device = dma;\n\tdma_cookie_init(&ioat_chan->dma_chan);\n\tlist_add_tail(&ioat_chan->dma_chan.device_node, &dma->channels);\n\tioat_dma->idx[idx] = ioat_chan;\n\ttimer_setup(&ioat_chan->timer, ioat_timer_event, 0);\n\ttasklet_setup(&ioat_chan->cleanup_task, ioat_cleanup_event);\n}\n\n#define IOAT_NUM_SRC_TEST 6  \nstatic int ioat_xor_val_self_test(struct ioatdma_device *ioat_dma)\n{\n\tint i, src_idx;\n\tstruct page *dest;\n\tstruct page *xor_srcs[IOAT_NUM_SRC_TEST];\n\tstruct page *xor_val_srcs[IOAT_NUM_SRC_TEST + 1];\n\tdma_addr_t dma_srcs[IOAT_NUM_SRC_TEST + 1];\n\tdma_addr_t dest_dma;\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct dma_chan *dma_chan;\n\tdma_cookie_t cookie;\n\tu8 cmp_byte = 0;\n\tu32 cmp_word;\n\tu32 xor_val_result;\n\tint err = 0;\n\tstruct completion cmp;\n\tunsigned long tmo;\n\tstruct device *dev = &ioat_dma->pdev->dev;\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tu8 op = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tif (!dma_has_cap(DMA_XOR, dma->cap_mask))\n\t\treturn 0;\n\n\tfor (src_idx = 0; src_idx < IOAT_NUM_SRC_TEST; src_idx++) {\n\t\txor_srcs[src_idx] = alloc_page(GFP_KERNEL);\n\t\tif (!xor_srcs[src_idx]) {\n\t\t\twhile (src_idx--)\n\t\t\t\t__free_page(xor_srcs[src_idx]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tdest = alloc_page(GFP_KERNEL);\n\tif (!dest) {\n\t\twhile (src_idx--)\n\t\t\t__free_page(xor_srcs[src_idx]);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (src_idx = 0; src_idx < IOAT_NUM_SRC_TEST; src_idx++) {\n\t\tu8 *ptr = page_address(xor_srcs[src_idx]);\n\n\t\tfor (i = 0; i < PAGE_SIZE; i++)\n\t\t\tptr[i] = (1 << src_idx);\n\t}\n\n\tfor (src_idx = 0; src_idx < IOAT_NUM_SRC_TEST; src_idx++)\n\t\tcmp_byte ^= (u8) (1 << src_idx);\n\n\tcmp_word = (cmp_byte << 24) | (cmp_byte << 16) |\n\t\t\t(cmp_byte << 8) | cmp_byte;\n\n\tmemset(page_address(dest), 0, PAGE_SIZE);\n\n\tdma_chan = container_of(dma->channels.next, struct dma_chan,\n\t\t\t\tdevice_node);\n\tif (dma->device_alloc_chan_resources(dma_chan) < 1) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\top = IOAT_OP_XOR;\n\n\tdest_dma = dma_map_page(dev, dest, 0, PAGE_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dest_dma)) {\n\t\terr = -ENOMEM;\n\t\tgoto free_resources;\n\t}\n\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST; i++) {\n\t\tdma_srcs[i] = dma_map_page(dev, xor_srcs[i], 0, PAGE_SIZE,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma_srcs[i])) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto dma_unmap;\n\t\t}\n\t}\n\ttx = dma->device_prep_dma_xor(dma_chan, dest_dma, dma_srcs,\n\t\t\t\t      IOAT_NUM_SRC_TEST, PAGE_SIZE,\n\t\t\t\t      DMA_PREP_INTERRUPT);\n\n\tif (!tx) {\n\t\tdev_err(dev, \"Self-test xor prep failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tasync_tx_ack(tx);\n\tinit_completion(&cmp);\n\ttx->callback = ioat_dma_test_callback;\n\ttx->callback_param = &cmp;\n\tcookie = tx->tx_submit(tx);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Self-test xor setup failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\tdma->device_issue_pending(dma_chan);\n\n\ttmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));\n\n\tif (tmo == 0 ||\n\t    dma->device_tx_status(dma_chan, cookie, NULL) != DMA_COMPLETE) {\n\t\tdev_err(dev, \"Self-test xor timed out\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST; i++)\n\t\tdma_unmap_page(dev, dma_srcs[i], PAGE_SIZE, DMA_TO_DEVICE);\n\n\tdma_sync_single_for_cpu(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);\n\tfor (i = 0; i < (PAGE_SIZE / sizeof(u32)); i++) {\n\t\tu32 *ptr = page_address(dest);\n\n\t\tif (ptr[i] != cmp_word) {\n\t\t\tdev_err(dev, \"Self-test xor failed compare\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto free_resources;\n\t\t}\n\t}\n\tdma_sync_single_for_device(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);\n\n\tdma_unmap_page(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t \n\tif (!dma_has_cap(DMA_XOR_VAL, dma_chan->device->cap_mask))\n\t\tgoto free_resources;\n\n\top = IOAT_OP_XOR_VAL;\n\n\t \n\tfor (i = 0; i < IOAT_NUM_SRC_TEST; i++)\n\t\txor_val_srcs[i] = xor_srcs[i];\n\txor_val_srcs[i] = dest;\n\n\txor_val_result = 1;\n\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST + 1; i++) {\n\t\tdma_srcs[i] = dma_map_page(dev, xor_val_srcs[i], 0, PAGE_SIZE,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma_srcs[i])) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto dma_unmap;\n\t\t}\n\t}\n\ttx = dma->device_prep_dma_xor_val(dma_chan, dma_srcs,\n\t\t\t\t\t  IOAT_NUM_SRC_TEST + 1, PAGE_SIZE,\n\t\t\t\t\t  &xor_val_result, DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(dev, \"Self-test zero prep failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tasync_tx_ack(tx);\n\tinit_completion(&cmp);\n\ttx->callback = ioat_dma_test_callback;\n\ttx->callback_param = &cmp;\n\tcookie = tx->tx_submit(tx);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Self-test zero setup failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\tdma->device_issue_pending(dma_chan);\n\n\ttmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));\n\n\tif (tmo == 0 ||\n\t    dma->device_tx_status(dma_chan, cookie, NULL) != DMA_COMPLETE) {\n\t\tdev_err(dev, \"Self-test validate timed out\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST + 1; i++)\n\t\tdma_unmap_page(dev, dma_srcs[i], PAGE_SIZE, DMA_TO_DEVICE);\n\n\tif (xor_val_result != 0) {\n\t\tdev_err(dev, \"Self-test validate failed compare\\n\");\n\t\terr = -ENODEV;\n\t\tgoto free_resources;\n\t}\n\n\tmemset(page_address(dest), 0, PAGE_SIZE);\n\n\t \n\top = IOAT_OP_XOR_VAL;\n\n\txor_val_result = 0;\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST + 1; i++) {\n\t\tdma_srcs[i] = dma_map_page(dev, xor_val_srcs[i], 0, PAGE_SIZE,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma_srcs[i])) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto dma_unmap;\n\t\t}\n\t}\n\ttx = dma->device_prep_dma_xor_val(dma_chan, dma_srcs,\n\t\t\t\t\t  IOAT_NUM_SRC_TEST + 1, PAGE_SIZE,\n\t\t\t\t\t  &xor_val_result, DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(dev, \"Self-test 2nd zero prep failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tasync_tx_ack(tx);\n\tinit_completion(&cmp);\n\ttx->callback = ioat_dma_test_callback;\n\ttx->callback_param = &cmp;\n\tcookie = tx->tx_submit(tx);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Self-test  2nd zero setup failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\tdma->device_issue_pending(dma_chan);\n\n\ttmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));\n\n\tif (tmo == 0 ||\n\t    dma->device_tx_status(dma_chan, cookie, NULL) != DMA_COMPLETE) {\n\t\tdev_err(dev, \"Self-test 2nd validate timed out\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tif (xor_val_result != SUM_CHECK_P_RESULT) {\n\t\tdev_err(dev, \"Self-test validate failed compare\\n\");\n\t\terr = -ENODEV;\n\t\tgoto dma_unmap;\n\t}\n\n\tfor (i = 0; i < IOAT_NUM_SRC_TEST + 1; i++)\n\t\tdma_unmap_page(dev, dma_srcs[i], PAGE_SIZE, DMA_TO_DEVICE);\n\n\tgoto free_resources;\ndma_unmap:\n\tif (op == IOAT_OP_XOR) {\n\t\twhile (--i >= 0)\n\t\t\tdma_unmap_page(dev, dma_srcs[i], PAGE_SIZE,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\tdma_unmap_page(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);\n\t} else if (op == IOAT_OP_XOR_VAL) {\n\t\twhile (--i >= 0)\n\t\t\tdma_unmap_page(dev, dma_srcs[i], PAGE_SIZE,\n\t\t\t\t       DMA_TO_DEVICE);\n\t}\nfree_resources:\n\tdma->device_free_chan_resources(dma_chan);\nout:\n\tsrc_idx = IOAT_NUM_SRC_TEST;\n\twhile (src_idx--)\n\t\t__free_page(xor_srcs[src_idx]);\n\t__free_page(dest);\n\treturn err;\n}\n\nstatic int ioat3_dma_self_test(struct ioatdma_device *ioat_dma)\n{\n\tint rc;\n\n\trc = ioat_dma_self_test(ioat_dma);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ioat_xor_val_self_test(ioat_dma);\n\n\treturn rc;\n}\n\nstatic void ioat_intr_quirk(struct ioatdma_device *ioat_dma)\n{\n\tstruct dma_device *dma;\n\tstruct dma_chan *c;\n\tstruct ioatdma_chan *ioat_chan;\n\tu32 errmask;\n\n\tdma = &ioat_dma->dma_dev;\n\n\t \n\tif (ioat_dma->cap & IOAT_CAP_DWBES) {\n\t\tlist_for_each_entry(c, &dma->channels, device_node) {\n\t\t\tioat_chan = to_ioat_chan(c);\n\t\t\terrmask = readl(ioat_chan->reg_base +\n\t\t\t\t\tIOAT_CHANERR_MASK_OFFSET);\n\t\t\terrmask |= IOAT_CHANERR_XOR_P_OR_CRC_ERR |\n\t\t\t\t   IOAT_CHANERR_XOR_Q_ERR;\n\t\t\twritel(errmask, ioat_chan->reg_base +\n\t\t\t\t\tIOAT_CHANERR_MASK_OFFSET);\n\t\t}\n\t}\n}\n\nstatic int ioat3_dma_probe(struct ioatdma_device *ioat_dma, int dca)\n{\n\tstruct pci_dev *pdev = ioat_dma->pdev;\n\tint dca_en = system_has_dca_enabled(pdev);\n\tstruct dma_device *dma;\n\tstruct dma_chan *c;\n\tstruct ioatdma_chan *ioat_chan;\n\tint err;\n\tu16 val16;\n\n\tdma = &ioat_dma->dma_dev;\n\tdma->device_prep_dma_memcpy = ioat_dma_prep_memcpy_lock;\n\tdma->device_issue_pending = ioat_issue_pending;\n\tdma->device_alloc_chan_resources = ioat_alloc_chan_resources;\n\tdma->device_free_chan_resources = ioat_free_chan_resources;\n\n\tdma_cap_set(DMA_INTERRUPT, dma->cap_mask);\n\tdma->device_prep_dma_interrupt = ioat_prep_interrupt_lock;\n\n\tioat_dma->cap = readl(ioat_dma->reg_base + IOAT_DMA_CAP_OFFSET);\n\n\tif (is_xeon_cb32(pdev) || is_bwd_noraid(pdev))\n\t\tioat_dma->cap &=\n\t\t\t~(IOAT_CAP_XOR | IOAT_CAP_PQ | IOAT_CAP_RAID16SS);\n\n\t \n\tif (dca_en && (ioat_dma->cap & (IOAT_CAP_XOR|IOAT_CAP_PQ)))\n\t\tioat_dma->cap &= ~(IOAT_CAP_XOR|IOAT_CAP_PQ);\n\n\tif (ioat_dma->cap & IOAT_CAP_XOR) {\n\t\tdma->max_xor = 8;\n\n\t\tdma_cap_set(DMA_XOR, dma->cap_mask);\n\t\tdma->device_prep_dma_xor = ioat_prep_xor;\n\n\t\tdma_cap_set(DMA_XOR_VAL, dma->cap_mask);\n\t\tdma->device_prep_dma_xor_val = ioat_prep_xor_val;\n\t}\n\n\tif (ioat_dma->cap & IOAT_CAP_PQ) {\n\n\t\tdma->device_prep_dma_pq = ioat_prep_pq;\n\t\tdma->device_prep_dma_pq_val = ioat_prep_pq_val;\n\t\tdma_cap_set(DMA_PQ, dma->cap_mask);\n\t\tdma_cap_set(DMA_PQ_VAL, dma->cap_mask);\n\n\t\tif (ioat_dma->cap & IOAT_CAP_RAID16SS)\n\t\t\tdma_set_maxpq(dma, 16, 0);\n\t\telse\n\t\t\tdma_set_maxpq(dma, 8, 0);\n\n\t\tif (!(ioat_dma->cap & IOAT_CAP_XOR)) {\n\t\t\tdma->device_prep_dma_xor = ioat_prep_pqxor;\n\t\t\tdma->device_prep_dma_xor_val = ioat_prep_pqxor_val;\n\t\t\tdma_cap_set(DMA_XOR, dma->cap_mask);\n\t\t\tdma_cap_set(DMA_XOR_VAL, dma->cap_mask);\n\n\t\t\tif (ioat_dma->cap & IOAT_CAP_RAID16SS)\n\t\t\t\tdma->max_xor = 16;\n\t\t\telse\n\t\t\t\tdma->max_xor = 8;\n\t\t}\n\t}\n\n\tdma->device_tx_status = ioat_tx_status;\n\n\t \n\tif (ioat_dma->cap & IOAT_CAP_RAID16SS) {\n\t\tchar pool_name[14];\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_SED_POOLS; i++) {\n\t\t\tsnprintf(pool_name, 14, \"ioat_hw%d_sed\", i);\n\n\t\t\t \n\t\t\tioat_dma->sed_hw_pool[i] = dmam_pool_create(pool_name,\n\t\t\t\t\t&pdev->dev,\n\t\t\t\t\tSED_SIZE * (i + 1), 64, 0);\n\t\t\tif (!ioat_dma->sed_hw_pool[i])\n\t\t\t\treturn -ENOMEM;\n\n\t\t}\n\t}\n\n\tif (!(ioat_dma->cap & (IOAT_CAP_XOR | IOAT_CAP_PQ)))\n\t\tdma_cap_set(DMA_PRIVATE, dma->cap_mask);\n\n\terr = ioat_probe(ioat_dma);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(c, &dma->channels, device_node) {\n\t\tioat_chan = to_ioat_chan(c);\n\t\twritel(IOAT_DMA_DCA_ANY_CPU,\n\t\t       ioat_chan->reg_base + IOAT_DCACTRL_OFFSET);\n\t}\n\n\terr = ioat_register(ioat_dma);\n\tif (err)\n\t\treturn err;\n\n\tioat_kobject_add(ioat_dma, &ioat_ktype);\n\n\tif (dca)\n\t\tioat_dma->dca = ioat_dca_init(pdev, ioat_dma->reg_base);\n\n\t \n\terr = pcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &val16);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\t \n\tval16 &= ~PCI_EXP_DEVCTL_RELAX_EN;\n\terr = pcie_capability_write_word(pdev, PCI_EXP_DEVCTL, val16);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\tif (ioat_dma->cap & IOAT_CAP_DPS)\n\t\twriteb(ioat_pending_level + 1,\n\t\t       ioat_dma->reg_base + IOAT_PREFETCH_LIMIT_OFFSET);\n\n\treturn 0;\n}\n\nstatic void ioat_shutdown(struct pci_dev *pdev)\n{\n\tstruct ioatdma_device *ioat_dma = pci_get_drvdata(pdev);\n\tstruct ioatdma_chan *ioat_chan;\n\tint i;\n\n\tif (!ioat_dma)\n\t\treturn;\n\n\tfor (i = 0; i < IOAT_MAX_CHANS; i++) {\n\t\tioat_chan = ioat_dma->idx[i];\n\t\tif (!ioat_chan)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&ioat_chan->prep_lock);\n\t\tset_bit(IOAT_CHAN_DOWN, &ioat_chan->state);\n\t\tspin_unlock_bh(&ioat_chan->prep_lock);\n\t\t \n\t\tdel_timer_sync(&ioat_chan->timer);\n\n\t\t \n\t\tioat_reset_hw(ioat_chan);\n\t}\n\n\tioat_disable_interrupts(ioat_dma);\n}\n\nstatic void ioat_resume(struct ioatdma_device *ioat_dma)\n{\n\tstruct ioatdma_chan *ioat_chan;\n\tu32 chanerr;\n\tint i;\n\n\tfor (i = 0; i < IOAT_MAX_CHANS; i++) {\n\t\tioat_chan = ioat_dma->idx[i];\n\t\tif (!ioat_chan)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&ioat_chan->prep_lock);\n\t\tclear_bit(IOAT_CHAN_DOWN, &ioat_chan->state);\n\t\tspin_unlock_bh(&ioat_chan->prep_lock);\n\n\t\tchanerr = readl(ioat_chan->reg_base + IOAT_CHANERR_OFFSET);\n\t\twritel(chanerr, ioat_chan->reg_base + IOAT_CHANERR_OFFSET);\n\n\t\t \n\t}\n}\n\n#define DRV_NAME \"ioatdma\"\n\nstatic pci_ers_result_t ioat_pcie_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\t pci_channel_state_t error)\n{\n\tdev_dbg(&pdev->dev, \"%s: PCIe AER error %d\\n\", DRV_NAME, error);\n\n\t \n\tioat_shutdown(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t ioat_pcie_error_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t result = PCI_ERS_RESULT_RECOVERED;\n\n\tdev_dbg(&pdev->dev, \"%s post reset handling\\n\", DRV_NAME);\n\n\tif (pci_enable_device_mem(pdev) < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable PCIe device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpci_set_master(pdev);\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\t\tpci_wake_from_d3(pdev, false);\n\t}\n\n\treturn result;\n}\n\nstatic void ioat_pcie_error_resume(struct pci_dev *pdev)\n{\n\tstruct ioatdma_device *ioat_dma = pci_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s: AER handling resuming\\n\", DRV_NAME);\n\n\t \n\tioat_resume(ioat_dma);\n}\n\nstatic const struct pci_error_handlers ioat_err_handler = {\n\t.error_detected = ioat_pcie_error_detected,\n\t.slot_reset = ioat_pcie_error_slot_reset,\n\t.resume = ioat_pcie_error_resume,\n};\n\nstatic struct pci_driver ioat_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= ioat_pci_tbl,\n\t.probe\t\t= ioat_pci_probe,\n\t.remove\t\t= ioat_remove,\n\t.shutdown\t= ioat_shutdown,\n\t.err_handler\t= &ioat_err_handler,\n};\n\nstatic void release_ioatdma(struct dma_device *device)\n{\n\tstruct ioatdma_device *d = to_ioatdma_device(device);\n\tint i;\n\n\tfor (i = 0; i < IOAT_MAX_CHANS; i++)\n\t\tkfree(d->idx[i]);\n\n\tdma_pool_destroy(d->completion_pool);\n\tkfree(d);\n}\n\nstatic struct ioatdma_device *\nalloc_ioatdma(struct pci_dev *pdev, void __iomem *iobase)\n{\n\tstruct ioatdma_device *d = kzalloc(sizeof(*d), GFP_KERNEL);\n\n\tif (!d)\n\t\treturn NULL;\n\td->pdev = pdev;\n\td->reg_base = iobase;\n\td->dma_dev.device_release = release_ioatdma;\n\treturn d;\n}\n\nstatic int ioat_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tvoid __iomem * const *iomap;\n\tstruct device *dev = &pdev->dev;\n\tstruct ioatdma_device *device;\n\tint err;\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pcim_iomap_regions(pdev, 1 << IOAT_MMIO_BAR, DRV_NAME);\n\tif (err)\n\t\treturn err;\n\tiomap = pcim_iomap_table(pdev);\n\tif (!iomap)\n\t\treturn -ENOMEM;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\treturn err;\n\n\tdevice = alloc_ioatdma(pdev, iomap[IOAT_MMIO_BAR]);\n\tif (!device)\n\t\treturn -ENOMEM;\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, device);\n\n\tdevice->version = readb(device->reg_base + IOAT_VER_OFFSET);\n\tif (device->version >= IOAT_VER_3_4)\n\t\tioat_dca_enabled = 0;\n\tif (device->version >= IOAT_VER_3_0) {\n\t\tif (is_skx_ioat(pdev))\n\t\t\tdevice->version = IOAT_VER_3_2;\n\t\terr = ioat3_dma_probe(device, ioat_dca_enabled);\n\t} else\n\t\treturn -ENODEV;\n\n\tif (err) {\n\t\tdev_err(dev, \"Intel(R) I/OAT DMA Engine init failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void ioat_remove(struct pci_dev *pdev)\n{\n\tstruct ioatdma_device *device = pci_get_drvdata(pdev);\n\n\tif (!device)\n\t\treturn;\n\n\tioat_shutdown(pdev);\n\n\tdev_err(&pdev->dev, \"Removing dma and dca services\\n\");\n\tif (device->dca) {\n\t\tunregister_dca_provider(device->dca, &pdev->dev);\n\t\tfree_dca_provider(device->dca);\n\t\tdevice->dca = NULL;\n\t}\n\n\tioat_dma_remove(device);\n}\n\nstatic int __init ioat_init_module(void)\n{\n\tint err = -ENOMEM;\n\n\tpr_info(\"%s: Intel(R) QuickData Technology Driver %s\\n\",\n\t\tDRV_NAME, IOAT_DMA_VERSION);\n\n\tioat_cache = kmem_cache_create(\"ioat\", sizeof(struct ioat_ring_ent),\n\t\t\t\t\t0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ioat_cache)\n\t\treturn -ENOMEM;\n\n\tioat_sed_cache = KMEM_CACHE(ioat_sed_ent, 0);\n\tif (!ioat_sed_cache)\n\t\tgoto err_ioat_cache;\n\n\terr = pci_register_driver(&ioat_pci_driver);\n\tif (err)\n\t\tgoto err_ioat3_cache;\n\n\treturn 0;\n\n err_ioat3_cache:\n\tkmem_cache_destroy(ioat_sed_cache);\n\n err_ioat_cache:\n\tkmem_cache_destroy(ioat_cache);\n\n\treturn err;\n}\nmodule_init(ioat_init_module);\n\nstatic void __exit ioat_exit_module(void)\n{\n\tpci_unregister_driver(&ioat_pci_driver);\n\tkmem_cache_destroy(ioat_cache);\n}\nmodule_exit(ioat_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}