{
  "module_name": "sysfs.c",
  "hash_id": "d8bbb612b94b25e2d8f7e2bc608041e69fa952345fcf4d79235c4ed0d5ba3a7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ioat/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dmaengine.h>\n#include <linux/pci.h>\n#include \"dma.h\"\n#include \"registers.h\"\n#include \"hw.h\"\n\n#include \"../dmaengine.h\"\n\nstatic ssize_t cap_show(struct dma_chan *c, char *page)\n{\n\tstruct dma_device *dma = c->device;\n\n\treturn sprintf(page, \"copy%s%s%s%s%s\\n\",\n\t\t       dma_has_cap(DMA_PQ, dma->cap_mask) ? \" pq\" : \"\",\n\t\t       dma_has_cap(DMA_PQ_VAL, dma->cap_mask) ? \" pq_val\" : \"\",\n\t\t       dma_has_cap(DMA_XOR, dma->cap_mask) ? \" xor\" : \"\",\n\t\t       dma_has_cap(DMA_XOR_VAL, dma->cap_mask) ? \" xor_val\" : \"\",\n\t\t       dma_has_cap(DMA_INTERRUPT, dma->cap_mask) ? \" intr\" : \"\");\n\n}\nstruct ioat_sysfs_entry ioat_cap_attr = __ATTR_RO(cap);\n\nstatic ssize_t version_show(struct dma_chan *c, char *page)\n{\n\tstruct dma_device *dma = c->device;\n\tstruct ioatdma_device *ioat_dma = to_ioatdma_device(dma);\n\n\treturn sprintf(page, \"%d.%d\\n\",\n\t\t       ioat_dma->version >> 4, ioat_dma->version & 0xf);\n}\nstruct ioat_sysfs_entry ioat_version_attr = __ATTR_RO(version);\n\nstatic ssize_t\nioat_attr_show(struct kobject *kobj, struct attribute *attr, char *page)\n{\n\tstruct ioat_sysfs_entry *entry;\n\tstruct ioatdma_chan *ioat_chan;\n\n\tentry = container_of(attr, struct ioat_sysfs_entry, attr);\n\tioat_chan = container_of(kobj, struct ioatdma_chan, kobj);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\treturn entry->show(&ioat_chan->dma_chan, page);\n}\n\nstatic ssize_t\nioat_attr_store(struct kobject *kobj, struct attribute *attr,\nconst char *page, size_t count)\n{\n\tstruct ioat_sysfs_entry *entry;\n\tstruct ioatdma_chan *ioat_chan;\n\n\tentry = container_of(attr, struct ioat_sysfs_entry, attr);\n\tioat_chan = container_of(kobj, struct ioatdma_chan, kobj);\n\n\tif (!entry->store)\n\t\treturn -EIO;\n\treturn entry->store(&ioat_chan->dma_chan, page, count);\n}\n\nconst struct sysfs_ops ioat_sysfs_ops = {\n\t.show\t= ioat_attr_show,\n\t.store  = ioat_attr_store,\n};\n\nvoid ioat_kobject_add(struct ioatdma_device *ioat_dma, struct kobj_type *type)\n{\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tstruct dma_chan *c;\n\n\tlist_for_each_entry(c, &dma->channels, device_node) {\n\t\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\t\tstruct kobject *parent = &c->dev->device.kobj;\n\t\tint err;\n\n\t\terr = kobject_init_and_add(&ioat_chan->kobj, type,\n\t\t\t\t\t   parent, \"quickdata\");\n\t\tif (err) {\n\t\t\tdev_warn(to_dev(ioat_chan),\n\t\t\t\t \"sysfs init error (%d), continuing...\\n\", err);\n\t\t\tkobject_put(&ioat_chan->kobj);\n\t\t\tset_bit(IOAT_KOBJ_INIT_FAIL, &ioat_chan->state);\n\t\t}\n\t}\n}\n\nvoid ioat_kobject_del(struct ioatdma_device *ioat_dma)\n{\n\tstruct dma_device *dma = &ioat_dma->dma_dev;\n\tstruct dma_chan *c;\n\n\tlist_for_each_entry(c, &dma->channels, device_node) {\n\t\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\n\t\tif (!test_bit(IOAT_KOBJ_INIT_FAIL, &ioat_chan->state)) {\n\t\t\tkobject_del(&ioat_chan->kobj);\n\t\t\tkobject_put(&ioat_chan->kobj);\n\t\t}\n\t}\n}\n\nstatic ssize_t ring_size_show(struct dma_chan *c, char *page)\n{\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\n\treturn sprintf(page, \"%d\\n\", (1 << ioat_chan->alloc_order) & ~1);\n}\nstatic struct ioat_sysfs_entry ring_size_attr = __ATTR_RO(ring_size);\n\nstatic ssize_t ring_active_show(struct dma_chan *c, char *page)\n{\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\n\t \n\treturn sprintf(page, \"%d\\n\", ioat_ring_active(ioat_chan));\n}\nstatic struct ioat_sysfs_entry ring_active_attr = __ATTR_RO(ring_active);\n\nstatic ssize_t intr_coalesce_show(struct dma_chan *c, char *page)\n{\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\n\treturn sprintf(page, \"%d\\n\", ioat_chan->intr_coalesce);\n}\n\nstatic ssize_t intr_coalesce_store(struct dma_chan *c, const char *page,\nsize_t count)\n{\n\tint intr_coalesce = 0;\n\tstruct ioatdma_chan *ioat_chan = to_ioat_chan(c);\n\n\tif (sscanf(page, \"%du\", &intr_coalesce) != -1) {\n\t\tif ((intr_coalesce < 0) ||\n\t\t    (intr_coalesce > IOAT_INTRDELAY_MASK))\n\t\t\treturn -EINVAL;\n\t\tioat_chan->intr_coalesce = intr_coalesce;\n\t}\n\n\treturn count;\n}\n\nstatic struct ioat_sysfs_entry intr_coalesce_attr = __ATTR_RW(intr_coalesce);\n\nstatic struct attribute *ioat_attrs[] = {\n\t&ring_size_attr.attr,\n\t&ring_active_attr.attr,\n\t&ioat_cap_attr.attr,\n\t&ioat_version_attr.attr,\n\t&intr_coalesce_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ioat);\n\nstruct kobj_type ioat_ktype = {\n\t.sysfs_ops = &ioat_sysfs_ops,\n\t.default_groups = ioat_groups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}