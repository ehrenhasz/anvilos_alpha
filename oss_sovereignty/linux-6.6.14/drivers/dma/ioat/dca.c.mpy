{
  "module_name": "dca.c",
  "hash_id": "99c4e1410ac3f0f154b6989c2b45e40267747ac3027674ec9e3417da69b5e10c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ioat/dca.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/smp.h>\n#include <linux/interrupt.h>\n#include <linux/dca.h>\n\n \n#ifndef CONFIG_SMP\n#include <asm/smp.h>\n#undef cpu_physical_id\n#define cpu_physical_id(cpu) (cpuid_ebx(1) >> 24)\n#endif\n\n#include \"dma.h\"\n#include \"registers.h\"\n\n \n#define DCA_TAG_MAP_VALID 0x80\n\n#define DCA3_TAG_MAP_BIT_TO_INV 0x80\n#define DCA3_TAG_MAP_BIT_TO_SEL 0x40\n#define DCA3_TAG_MAP_LITERAL_VAL 0x1\n\n#define DCA_TAG_MAP_MASK 0xDF\n\n \n#define DCA2_TAG_MAP_BYTE0 0x80\n#define DCA2_TAG_MAP_BYTE1 0x0\n#define DCA2_TAG_MAP_BYTE2 0x81\n#define DCA2_TAG_MAP_BYTE3 0x82\n#define DCA2_TAG_MAP_BYTE4 0x82\n\n \n\n#define APICID_BIT(x)\t\t(DCA_TAG_MAP_VALID | (x))\n#define IOAT_TAG_MAP_LEN\t8\n\n \nstatic inline u16 dcaid_from_pcidev(struct pci_dev *pci)\n{\n\treturn pci_dev_id(pci);\n}\n\nstatic int dca_enabled_in_bios(struct pci_dev *pdev)\n{\n\t \n\t \n\tunsigned long cpuid_level_9;\n\tint res;\n\n\tcpuid_level_9 = cpuid_eax(9);\n\tres = test_bit(0, &cpuid_level_9);\n\tif (!res)\n\t\tdev_dbg(&pdev->dev, \"DCA is disabled in BIOS\\n\");\n\n\treturn res;\n}\n\nint system_has_dca_enabled(struct pci_dev *pdev)\n{\n\tif (boot_cpu_has(X86_FEATURE_DCA))\n\t\treturn dca_enabled_in_bios(pdev);\n\n\tdev_dbg(&pdev->dev, \"boot cpu doesn't have X86_FEATURE_DCA\\n\");\n\treturn 0;\n}\n\nstruct ioat_dca_slot {\n\tstruct pci_dev *pdev;\t \n\tu16 rid;\t\t \n};\n\n#define IOAT_DCA_MAX_REQ 6\n#define IOAT3_DCA_MAX_REQ 2\n\nstruct ioat_dca_priv {\n\tvoid __iomem\t\t*iobase;\n\tvoid __iomem\t\t*dca_base;\n\tint\t\t\t max_requesters;\n\tint\t\t\t requester_count;\n\tu8\t\t\t tag_map[IOAT_TAG_MAP_LEN];\n\tstruct ioat_dca_slot\t req_slots[];\n};\n\nstatic int ioat_dca_dev_managed(struct dca_provider *dca,\n\t\t\t\tstruct device *dev)\n{\n\tstruct ioat_dca_priv *ioatdca = dca_priv(dca);\n\tstruct pci_dev *pdev;\n\tint i;\n\n\tpdev = to_pci_dev(dev);\n\tfor (i = 0; i < ioatdca->max_requesters; i++) {\n\t\tif (ioatdca->req_slots[i].pdev == pdev)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int ioat_dca_add_requester(struct dca_provider *dca, struct device *dev)\n{\n\tstruct ioat_dca_priv *ioatdca = dca_priv(dca);\n\tstruct pci_dev *pdev;\n\tint i;\n\tu16 id;\n\tu16 global_req_table;\n\n\t \n\tif (!dev_is_pci(dev))\n\t\treturn -ENODEV;\n\tpdev = to_pci_dev(dev);\n\tid = dcaid_from_pcidev(pdev);\n\n\tif (ioatdca->requester_count == ioatdca->max_requesters)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ioatdca->max_requesters; i++) {\n\t\tif (ioatdca->req_slots[i].pdev == NULL) {\n\t\t\t \n\t\t\tioatdca->requester_count++;\n\t\t\tioatdca->req_slots[i].pdev = pdev;\n\t\t\tioatdca->req_slots[i].rid = id;\n\t\t\tglobal_req_table =\n\t\t\t      readw(ioatdca->dca_base + IOAT3_DCA_GREQID_OFFSET);\n\t\t\twritel(id | IOAT_DCA_GREQID_VALID,\n\t\t\t       ioatdca->iobase + global_req_table + (i * 4));\n\t\t\treturn i;\n\t\t}\n\t}\n\t \n\treturn -EFAULT;\n}\n\nstatic int ioat_dca_remove_requester(struct dca_provider *dca,\n\t\t\t\t      struct device *dev)\n{\n\tstruct ioat_dca_priv *ioatdca = dca_priv(dca);\n\tstruct pci_dev *pdev;\n\tint i;\n\tu16 global_req_table;\n\n\t \n\tif (!dev_is_pci(dev))\n\t\treturn -ENODEV;\n\tpdev = to_pci_dev(dev);\n\n\tfor (i = 0; i < ioatdca->max_requesters; i++) {\n\t\tif (ioatdca->req_slots[i].pdev == pdev) {\n\t\t\tglobal_req_table =\n\t\t\t      readw(ioatdca->dca_base + IOAT3_DCA_GREQID_OFFSET);\n\t\t\twritel(0, ioatdca->iobase + global_req_table + (i * 4));\n\t\t\tioatdca->req_slots[i].pdev = NULL;\n\t\t\tioatdca->req_slots[i].rid = 0;\n\t\t\tioatdca->requester_count--;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic u8 ioat_dca_get_tag(struct dca_provider *dca,\n\t\t\t    struct device *dev,\n\t\t\t    int cpu)\n{\n\tu8 tag;\n\n\tstruct ioat_dca_priv *ioatdca = dca_priv(dca);\n\tint i, apic_id, bit, value;\n\tu8 entry;\n\n\ttag = 0;\n\tapic_id = cpu_physical_id(cpu);\n\n\tfor (i = 0; i < IOAT_TAG_MAP_LEN; i++) {\n\t\tentry = ioatdca->tag_map[i];\n\t\tif (entry & DCA3_TAG_MAP_BIT_TO_SEL) {\n\t\t\tbit = entry &\n\t\t\t\t~(DCA3_TAG_MAP_BIT_TO_SEL | DCA3_TAG_MAP_BIT_TO_INV);\n\t\t\tvalue = (apic_id & (1 << bit)) ? 1 : 0;\n\t\t} else if (entry & DCA3_TAG_MAP_BIT_TO_INV) {\n\t\t\tbit = entry & ~DCA3_TAG_MAP_BIT_TO_INV;\n\t\t\tvalue = (apic_id & (1 << bit)) ? 0 : 1;\n\t\t} else {\n\t\t\tvalue = (entry & DCA3_TAG_MAP_LITERAL_VAL) ? 1 : 0;\n\t\t}\n\t\ttag |= (value << i);\n\t}\n\n\treturn tag;\n}\n\nstatic const struct dca_ops ioat_dca_ops = {\n\t.add_requester\t\t= ioat_dca_add_requester,\n\t.remove_requester\t= ioat_dca_remove_requester,\n\t.get_tag\t\t= ioat_dca_get_tag,\n\t.dev_managed\t\t= ioat_dca_dev_managed,\n};\n\nstatic int ioat_dca_count_dca_slots(void *iobase, u16 dca_offset)\n{\n\tint slots = 0;\n\tu32 req;\n\tu16 global_req_table;\n\n\tglobal_req_table = readw(iobase + dca_offset + IOAT3_DCA_GREQID_OFFSET);\n\tif (global_req_table == 0)\n\t\treturn 0;\n\n\tdo {\n\t\treq = readl(iobase + global_req_table + (slots * sizeof(u32)));\n\t\tslots++;\n\t} while ((req & IOAT_DCA_GREQID_LASTID) == 0);\n\n\treturn slots;\n}\n\nstatic inline int dca3_tag_map_invalid(u8 *tag_map)\n{\n\t \n\treturn ((tag_map[0] == DCA_TAG_MAP_VALID) &&\n\t\t(tag_map[1] == DCA_TAG_MAP_VALID) &&\n\t\t(tag_map[2] == DCA_TAG_MAP_VALID) &&\n\t\t(tag_map[3] == DCA_TAG_MAP_VALID) &&\n\t\t(tag_map[4] == DCA_TAG_MAP_VALID));\n}\n\nstruct dca_provider *ioat_dca_init(struct pci_dev *pdev, void __iomem *iobase)\n{\n\tstruct dca_provider *dca;\n\tstruct ioat_dca_priv *ioatdca;\n\tint slots;\n\tint i;\n\tint err;\n\tu16 dca_offset;\n\tu16 csi_fsb_control;\n\tu16 pcie_control;\n\tu8 bit;\n\n\tunion {\n\t\tu64 full;\n\t\tstruct {\n\t\t\tu32 low;\n\t\t\tu32 high;\n\t\t};\n\t} tag_map;\n\n\tif (!system_has_dca_enabled(pdev))\n\t\treturn NULL;\n\n\tdca_offset = readw(iobase + IOAT_DCAOFFSET_OFFSET);\n\tif (dca_offset == 0)\n\t\treturn NULL;\n\n\tslots = ioat_dca_count_dca_slots(iobase, dca_offset);\n\tif (slots == 0)\n\t\treturn NULL;\n\n\tdca = alloc_dca_provider(&ioat_dca_ops,\n\t\t\t\t struct_size(ioatdca, req_slots, slots));\n\tif (!dca)\n\t\treturn NULL;\n\n\tioatdca = dca_priv(dca);\n\tioatdca->iobase = iobase;\n\tioatdca->dca_base = iobase + dca_offset;\n\tioatdca->max_requesters = slots;\n\n\t \n\tcsi_fsb_control = readw(ioatdca->dca_base + IOAT3_CSI_CONTROL_OFFSET);\n\tif ((csi_fsb_control & IOAT3_CSI_CONTROL_PREFETCH) == 0) {\n\t\tcsi_fsb_control |= IOAT3_CSI_CONTROL_PREFETCH;\n\t\twritew(csi_fsb_control,\n\t\t       ioatdca->dca_base + IOAT3_CSI_CONTROL_OFFSET);\n\t}\n\tpcie_control = readw(ioatdca->dca_base + IOAT3_PCI_CONTROL_OFFSET);\n\tif ((pcie_control & IOAT3_PCI_CONTROL_MEMWR) == 0) {\n\t\tpcie_control |= IOAT3_PCI_CONTROL_MEMWR;\n\t\twritew(pcie_control,\n\t\t       ioatdca->dca_base + IOAT3_PCI_CONTROL_OFFSET);\n\t}\n\n\n\t \n\n\t \n\ttag_map.low =\n\t\treadl(ioatdca->dca_base + IOAT3_APICID_TAG_MAP_OFFSET_LOW);\n\ttag_map.high =\n\t\treadl(ioatdca->dca_base + IOAT3_APICID_TAG_MAP_OFFSET_HIGH);\n\tfor (i = 0; i < 8; i++) {\n\t\tbit = tag_map.full >> (8 * i);\n\t\tioatdca->tag_map[i] = bit & DCA_TAG_MAP_MASK;\n\t}\n\n\tif (dca3_tag_map_invalid(ioatdca->tag_map)) {\n\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\tpr_warn_once(\"%s %s: APICID_TAG_MAP set incorrectly by BIOS, disabling DCA\\n\",\n\t\t\t     dev_driver_string(&pdev->dev),\n\t\t\t     dev_name(&pdev->dev));\n\t\tfree_dca_provider(dca);\n\t\treturn NULL;\n\t}\n\n\terr = register_dca_provider(dca, &pdev->dev);\n\tif (err) {\n\t\tfree_dca_provider(dca);\n\t\treturn NULL;\n\t}\n\n\treturn dca;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}