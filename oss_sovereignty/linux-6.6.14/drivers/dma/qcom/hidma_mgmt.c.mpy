{
  "module_name": "hidma_mgmt.c",
  "hash_id": "8369479ba862e71889708ae597747bfc3ce1e3609e49a938c71b313b10bc3d27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/qcom/hidma_mgmt.c",
  "human_readable_source": "\n \n\n#include <linux/dmaengine.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n\n#include \"hidma_mgmt.h\"\n\n#define HIDMA_QOS_N_OFFSET\t\t0x700\n#define HIDMA_CFG_OFFSET\t\t0x400\n#define HIDMA_MAX_BUS_REQ_LEN_OFFSET\t0x41C\n#define HIDMA_MAX_XACTIONS_OFFSET\t0x420\n#define HIDMA_HW_VERSION_OFFSET\t0x424\n#define HIDMA_CHRESET_TIMEOUT_OFFSET\t0x418\n\n#define HIDMA_MAX_WR_XACTIONS_MASK\tGENMASK(4, 0)\n#define HIDMA_MAX_RD_XACTIONS_MASK\tGENMASK(4, 0)\n#define HIDMA_WEIGHT_MASK\t\tGENMASK(6, 0)\n#define HIDMA_MAX_BUS_REQ_LEN_MASK\tGENMASK(15, 0)\n#define HIDMA_CHRESET_TIMEOUT_MASK\tGENMASK(19, 0)\n\n#define HIDMA_MAX_WR_XACTIONS_BIT_POS\t16\n#define HIDMA_MAX_BUS_WR_REQ_BIT_POS\t16\n#define HIDMA_WRR_BIT_POS\t\t8\n#define HIDMA_PRIORITY_BIT_POS\t\t15\n\n#define HIDMA_AUTOSUSPEND_TIMEOUT\t2000\n#define HIDMA_MAX_CHANNEL_WEIGHT\t15\n\nstatic unsigned int max_write_request;\nmodule_param(max_write_request, uint, 0644);\nMODULE_PARM_DESC(max_write_request,\n\t\t\"maximum write burst (default: ACPI/DT value)\");\n\nstatic unsigned int max_read_request;\nmodule_param(max_read_request, uint, 0644);\nMODULE_PARM_DESC(max_read_request,\n\t\t\"maximum read burst (default: ACPI/DT value)\");\n\nstatic unsigned int max_wr_xactions;\nmodule_param(max_wr_xactions, uint, 0644);\nMODULE_PARM_DESC(max_wr_xactions,\n\t\"maximum number of write transactions (default: ACPI/DT value)\");\n\nstatic unsigned int max_rd_xactions;\nmodule_param(max_rd_xactions, uint, 0644);\nMODULE_PARM_DESC(max_rd_xactions,\n\t\"maximum number of read transactions (default: ACPI/DT value)\");\n\nint hidma_mgmt_setup(struct hidma_mgmt_dev *mgmtdev)\n{\n\tunsigned int i;\n\tu32 val;\n\n\tif (!is_power_of_2(mgmtdev->max_write_request) ||\n\t    (mgmtdev->max_write_request < 128) ||\n\t    (mgmtdev->max_write_request > 1024)) {\n\t\tdev_err(&mgmtdev->pdev->dev, \"invalid write request %d\\n\",\n\t\t\tmgmtdev->max_write_request);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(mgmtdev->max_read_request) ||\n\t    (mgmtdev->max_read_request < 128) ||\n\t    (mgmtdev->max_read_request > 1024)) {\n\t\tdev_err(&mgmtdev->pdev->dev, \"invalid read request %d\\n\",\n\t\t\tmgmtdev->max_read_request);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mgmtdev->max_wr_xactions > HIDMA_MAX_WR_XACTIONS_MASK) {\n\t\tdev_err(&mgmtdev->pdev->dev,\n\t\t\t\"max_wr_xactions cannot be bigger than %ld\\n\",\n\t\t\tHIDMA_MAX_WR_XACTIONS_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mgmtdev->max_rd_xactions > HIDMA_MAX_RD_XACTIONS_MASK) {\n\t\tdev_err(&mgmtdev->pdev->dev,\n\t\t\t\"max_rd_xactions cannot be bigger than %ld\\n\",\n\t\t\tHIDMA_MAX_RD_XACTIONS_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mgmtdev->dma_channels; i++) {\n\t\tif (mgmtdev->priority[i] > 1) {\n\t\t\tdev_err(&mgmtdev->pdev->dev,\n\t\t\t\t\"priority can be 0 or 1\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (mgmtdev->weight[i] > HIDMA_MAX_CHANNEL_WEIGHT) {\n\t\t\tdev_err(&mgmtdev->pdev->dev,\n\t\t\t\t\"max value of weight can be %d.\\n\",\n\t\t\t\tHIDMA_MAX_CHANNEL_WEIGHT);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (mgmtdev->weight[i] == 0)\n\t\t\tmgmtdev->weight[i] = 1;\n\t}\n\n\tpm_runtime_get_sync(&mgmtdev->pdev->dev);\n\tval = readl(mgmtdev->virtaddr + HIDMA_MAX_BUS_REQ_LEN_OFFSET);\n\tval &= ~(HIDMA_MAX_BUS_REQ_LEN_MASK << HIDMA_MAX_BUS_WR_REQ_BIT_POS);\n\tval |= mgmtdev->max_write_request << HIDMA_MAX_BUS_WR_REQ_BIT_POS;\n\tval &= ~HIDMA_MAX_BUS_REQ_LEN_MASK;\n\tval |= mgmtdev->max_read_request;\n\twritel(val, mgmtdev->virtaddr + HIDMA_MAX_BUS_REQ_LEN_OFFSET);\n\n\tval = readl(mgmtdev->virtaddr + HIDMA_MAX_XACTIONS_OFFSET);\n\tval &= ~(HIDMA_MAX_WR_XACTIONS_MASK << HIDMA_MAX_WR_XACTIONS_BIT_POS);\n\tval |= mgmtdev->max_wr_xactions << HIDMA_MAX_WR_XACTIONS_BIT_POS;\n\tval &= ~HIDMA_MAX_RD_XACTIONS_MASK;\n\tval |= mgmtdev->max_rd_xactions;\n\twritel(val, mgmtdev->virtaddr + HIDMA_MAX_XACTIONS_OFFSET);\n\n\tmgmtdev->hw_version =\n\t    readl(mgmtdev->virtaddr + HIDMA_HW_VERSION_OFFSET);\n\tmgmtdev->hw_version_major = (mgmtdev->hw_version >> 28) & 0xF;\n\tmgmtdev->hw_version_minor = (mgmtdev->hw_version >> 16) & 0xF;\n\n\tfor (i = 0; i < mgmtdev->dma_channels; i++) {\n\t\tu32 weight = mgmtdev->weight[i];\n\t\tu32 priority = mgmtdev->priority[i];\n\n\t\tval = readl(mgmtdev->virtaddr + HIDMA_QOS_N_OFFSET + (4 * i));\n\t\tval &= ~(1 << HIDMA_PRIORITY_BIT_POS);\n\t\tval |= (priority & 0x1) << HIDMA_PRIORITY_BIT_POS;\n\t\tval &= ~(HIDMA_WEIGHT_MASK << HIDMA_WRR_BIT_POS);\n\t\tval |= (weight & HIDMA_WEIGHT_MASK) << HIDMA_WRR_BIT_POS;\n\t\twritel(val, mgmtdev->virtaddr + HIDMA_QOS_N_OFFSET + (4 * i));\n\t}\n\n\tval = readl(mgmtdev->virtaddr + HIDMA_CHRESET_TIMEOUT_OFFSET);\n\tval &= ~HIDMA_CHRESET_TIMEOUT_MASK;\n\tval |= mgmtdev->chreset_timeout_cycles & HIDMA_CHRESET_TIMEOUT_MASK;\n\twritel(val, mgmtdev->virtaddr + HIDMA_CHRESET_TIMEOUT_OFFSET);\n\n\tpm_runtime_mark_last_busy(&mgmtdev->pdev->dev);\n\tpm_runtime_put_autosuspend(&mgmtdev->pdev->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hidma_mgmt_setup);\n\nstatic int hidma_mgmt_probe(struct platform_device *pdev)\n{\n\tstruct hidma_mgmt_dev *mgmtdev;\n\tstruct resource *res;\n\tvoid __iomem *virtaddr;\n\tint irq;\n\tint rc;\n\tu32 val;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, HIDMA_AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tvirtaddr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(virtaddr)) {\n\t\trc = PTR_ERR(virtaddr);\n\t\tgoto out;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\trc = irq;\n\t\tgoto out;\n\t}\n\n\tmgmtdev = devm_kzalloc(&pdev->dev, sizeof(*mgmtdev), GFP_KERNEL);\n\tif (!mgmtdev) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmgmtdev->pdev = pdev;\n\tmgmtdev->addrsize = resource_size(res);\n\tmgmtdev->virtaddr = virtaddr;\n\n\trc = device_property_read_u32(&pdev->dev, \"dma-channels\",\n\t\t\t\t      &mgmtdev->dma_channels);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"number of channels missing\\n\");\n\t\tgoto out;\n\t}\n\n\trc = device_property_read_u32(&pdev->dev,\n\t\t\t\t      \"channel-reset-timeout-cycles\",\n\t\t\t\t      &mgmtdev->chreset_timeout_cycles);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"channel reset timeout missing\\n\");\n\t\tgoto out;\n\t}\n\n\trc = device_property_read_u32(&pdev->dev, \"max-write-burst-bytes\",\n\t\t\t\t      &mgmtdev->max_write_request);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"max-write-burst-bytes missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (max_write_request &&\n\t\t\t(max_write_request != mgmtdev->max_write_request)) {\n\t\tdev_info(&pdev->dev, \"overriding max-write-burst-bytes: %d\\n\",\n\t\t\tmax_write_request);\n\t\tmgmtdev->max_write_request = max_write_request;\n\t} else\n\t\tmax_write_request = mgmtdev->max_write_request;\n\n\trc = device_property_read_u32(&pdev->dev, \"max-read-burst-bytes\",\n\t\t\t\t      &mgmtdev->max_read_request);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"max-read-burst-bytes missing\\n\");\n\t\tgoto out;\n\t}\n\tif (max_read_request &&\n\t\t\t(max_read_request != mgmtdev->max_read_request)) {\n\t\tdev_info(&pdev->dev, \"overriding max-read-burst-bytes: %d\\n\",\n\t\t\tmax_read_request);\n\t\tmgmtdev->max_read_request = max_read_request;\n\t} else\n\t\tmax_read_request = mgmtdev->max_read_request;\n\n\trc = device_property_read_u32(&pdev->dev, \"max-write-transactions\",\n\t\t\t\t      &mgmtdev->max_wr_xactions);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"max-write-transactions missing\\n\");\n\t\tgoto out;\n\t}\n\tif (max_wr_xactions &&\n\t\t\t(max_wr_xactions != mgmtdev->max_wr_xactions)) {\n\t\tdev_info(&pdev->dev, \"overriding max-write-transactions: %d\\n\",\n\t\t\tmax_wr_xactions);\n\t\tmgmtdev->max_wr_xactions = max_wr_xactions;\n\t} else\n\t\tmax_wr_xactions = mgmtdev->max_wr_xactions;\n\n\trc = device_property_read_u32(&pdev->dev, \"max-read-transactions\",\n\t\t\t\t      &mgmtdev->max_rd_xactions);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"max-read-transactions missing\\n\");\n\t\tgoto out;\n\t}\n\tif (max_rd_xactions &&\n\t\t\t(max_rd_xactions != mgmtdev->max_rd_xactions)) {\n\t\tdev_info(&pdev->dev, \"overriding max-read-transactions: %d\\n\",\n\t\t\tmax_rd_xactions);\n\t\tmgmtdev->max_rd_xactions = max_rd_xactions;\n\t} else\n\t\tmax_rd_xactions = mgmtdev->max_rd_xactions;\n\n\tmgmtdev->priority = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t mgmtdev->dma_channels,\n\t\t\t\t\t sizeof(*mgmtdev->priority),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!mgmtdev->priority) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmgmtdev->weight = devm_kcalloc(&pdev->dev,\n\t\t\t\t       mgmtdev->dma_channels,\n\t\t\t\t       sizeof(*mgmtdev->weight), GFP_KERNEL);\n\tif (!mgmtdev->weight) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = hidma_mgmt_setup(mgmtdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"setup failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tval = readl(mgmtdev->virtaddr + HIDMA_CFG_OFFSET);\n\tval |= 1;\n\twritel(val, mgmtdev->virtaddr + HIDMA_CFG_OFFSET);\n\n\trc = hidma_mgmt_init_sys(mgmtdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"sysfs setup failed\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t \"HW rev: %d.%d @ %pa with %d physical channels\\n\",\n\t\t mgmtdev->hw_version_major, mgmtdev->hw_version_minor,\n\t\t &res->start, mgmtdev->dma_channels);\n\n\tplatform_set_drvdata(pdev, mgmtdev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\treturn 0;\nout:\n\tpm_runtime_put_sync_suspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn rc;\n}\n\n#if IS_ENABLED(CONFIG_ACPI)\nstatic const struct acpi_device_id hidma_mgmt_acpi_ids[] = {\n\t{\"QCOM8060\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, hidma_mgmt_acpi_ids);\n#endif\n\nstatic const struct of_device_id hidma_mgmt_match[] = {\n\t{.compatible = \"qcom,hidma-mgmt-1.0\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hidma_mgmt_match);\n\nstatic struct platform_driver hidma_mgmt_driver = {\n\t.probe = hidma_mgmt_probe,\n\t.driver = {\n\t\t   .name = \"hidma-mgmt\",\n\t\t   .of_match_table = hidma_mgmt_match,\n\t\t   .acpi_match_table = ACPI_PTR(hidma_mgmt_acpi_ids),\n\t},\n};\n\n#if defined(CONFIG_OF) && defined(CONFIG_OF_IRQ)\nstatic int object_counter;\n\nstatic int __init hidma_mgmt_of_populate_channels(struct device_node *np)\n{\n\tstruct platform_device *pdev_parent = of_find_device_by_node(np);\n\tstruct platform_device_info pdevinfo;\n\tstruct device_node *child;\n\tstruct resource *res;\n\tint ret = 0;\n\n\t \n\tres = kcalloc(3, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct platform_device *new_pdev;\n\n\t\tret = of_address_to_resource(child, 0, &res[0]);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = of_address_to_resource(child, 1, &res[1]);\n\t\tif (!ret)\n\t\t\tgoto out;\n\n\t\tret = of_irq_to_resource(child, 0, &res[2]);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\tmemset(&pdevinfo, 0, sizeof(pdevinfo));\n\t\tpdevinfo.fwnode = &child->fwnode;\n\t\tpdevinfo.parent = pdev_parent ? &pdev_parent->dev : NULL;\n\t\tpdevinfo.name = child->name;\n\t\tpdevinfo.id = object_counter++;\n\t\tpdevinfo.res = res;\n\t\tpdevinfo.num_res = 3;\n\t\tpdevinfo.data = NULL;\n\t\tpdevinfo.size_data = 0;\n\t\tpdevinfo.dma_mask = DMA_BIT_MASK(64);\n\t\tnew_pdev = platform_device_register_full(&pdevinfo);\n\t\tif (IS_ERR(new_pdev)) {\n\t\t\tret = PTR_ERR(new_pdev);\n\t\t\tgoto out;\n\t\t}\n\t\tnew_pdev->dev.of_node = child;\n\t\tof_dma_configure(&new_pdev->dev, child, true);\n\t\t \n\t\tof_msi_configure(&new_pdev->dev, child);\n\t}\n\n\tkfree(res);\n\n\treturn ret;\n\nout:\n\tof_node_put(child);\n\tkfree(res);\n\n\treturn ret;\n}\n#endif\n\nstatic int __init hidma_mgmt_init(void)\n{\n#if defined(CONFIG_OF) && defined(CONFIG_OF_IRQ)\n\tstruct device_node *child;\n\n\tfor_each_matching_node(child, hidma_mgmt_match) {\n\t\t \n\t\thidma_mgmt_of_populate_channels(child);\n\t}\n#endif\n\t \n\tplatform_driver_register(&hidma_mgmt_driver);\n\n\treturn 0;\n}\nmodule_init(hidma_mgmt_init);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}