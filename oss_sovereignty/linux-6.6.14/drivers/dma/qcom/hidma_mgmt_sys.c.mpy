{
  "module_name": "hidma_mgmt_sys.c",
  "hash_id": "1630c3507cc57e2bfcee4c075c43ed23dbb063602eb50e5a8728b3186d9fca93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/qcom/hidma_mgmt_sys.c",
  "human_readable_source": "\n \n\n#include <linux/sysfs.h>\n#include <linux/platform_device.h>\n\n#include \"hidma_mgmt.h\"\n\nstruct hidma_chan_attr {\n\tstruct hidma_mgmt_dev *mdev;\n\tint index;\n\tstruct kobj_attribute attr;\n};\n\nstruct hidma_mgmt_fileinfo {\n\tchar *name;\n\tint mode;\n\tint (*get)(struct hidma_mgmt_dev *mdev);\n\tint (*set)(struct hidma_mgmt_dev *mdev, u64 val);\n};\n\n#define IMPLEMENT_GETSET(name)\t\t\t\t\t\\\nstatic int get_##name(struct hidma_mgmt_dev *mdev)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn mdev->name;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int set_##name(struct hidma_mgmt_dev *mdev, u64 val)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tu64 tmp;\t\t\t\t\t\t\\\n\tint rc;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\ttmp = mdev->name;\t\t\t\t\t\\\n\tmdev->name = val;\t\t\t\t\t\\\n\trc = hidma_mgmt_setup(mdev);\t\t\t\t\\\n\tif (rc)\t\t\t\t\t\t\t\\\n\t\tmdev->name = tmp;\t\t\t\t\\\n\treturn rc;\t\t\t\t\t\t\\\n}\n\n#define DECLARE_ATTRIBUTE(name, mode)\t\t\t\t\\\n\t{#name, mode, get_##name, set_##name}\n\nIMPLEMENT_GETSET(hw_version_major)\nIMPLEMENT_GETSET(hw_version_minor)\nIMPLEMENT_GETSET(max_wr_xactions)\nIMPLEMENT_GETSET(max_rd_xactions)\nIMPLEMENT_GETSET(max_write_request)\nIMPLEMENT_GETSET(max_read_request)\nIMPLEMENT_GETSET(dma_channels)\nIMPLEMENT_GETSET(chreset_timeout_cycles)\n\nstatic int set_priority(struct hidma_mgmt_dev *mdev, unsigned int i, u64 val)\n{\n\tu64 tmp;\n\tint rc;\n\n\tif (i >= mdev->dma_channels)\n\t\treturn -EINVAL;\n\n\ttmp = mdev->priority[i];\n\tmdev->priority[i] = val;\n\trc = hidma_mgmt_setup(mdev);\n\tif (rc)\n\t\tmdev->priority[i] = tmp;\n\treturn rc;\n}\n\nstatic int set_weight(struct hidma_mgmt_dev *mdev, unsigned int i, u64 val)\n{\n\tu64 tmp;\n\tint rc;\n\n\tif (i >= mdev->dma_channels)\n\t\treturn -EINVAL;\n\n\ttmp = mdev->weight[i];\n\tmdev->weight[i] = val;\n\trc = hidma_mgmt_setup(mdev);\n\tif (rc)\n\t\tmdev->weight[i] = tmp;\n\treturn rc;\n}\n\nstatic struct hidma_mgmt_fileinfo hidma_mgmt_files[] = {\n\tDECLARE_ATTRIBUTE(hw_version_major, S_IRUGO),\n\tDECLARE_ATTRIBUTE(hw_version_minor, S_IRUGO),\n\tDECLARE_ATTRIBUTE(dma_channels, S_IRUGO),\n\tDECLARE_ATTRIBUTE(chreset_timeout_cycles, S_IRUGO),\n\tDECLARE_ATTRIBUTE(max_wr_xactions, S_IRUGO),\n\tDECLARE_ATTRIBUTE(max_rd_xactions, S_IRUGO),\n\tDECLARE_ATTRIBUTE(max_write_request, S_IRUGO),\n\tDECLARE_ATTRIBUTE(max_read_request, S_IRUGO),\n};\n\nstatic ssize_t show_values(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct hidma_mgmt_dev *mdev = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tbuf[0] = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(hidma_mgmt_files); i++) {\n\t\tif (strcmp(attr->attr.name, hidma_mgmt_files[i].name) == 0) {\n\t\t\tsprintf(buf, \"%d\\n\", hidma_mgmt_files[i].get(mdev));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t set_values(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct hidma_mgmt_dev *mdev = dev_get_drvdata(dev);\n\tunsigned long tmp;\n\tunsigned int i;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &tmp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(hidma_mgmt_files); i++) {\n\t\tif (strcmp(attr->attr.name, hidma_mgmt_files[i].name) == 0) {\n\t\t\trc = hidma_mgmt_files[i].set(mdev, tmp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic ssize_t show_values_channel(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tstruct hidma_chan_attr *chattr;\n\tstruct hidma_mgmt_dev *mdev;\n\n\tbuf[0] = 0;\n\tchattr = container_of(attr, struct hidma_chan_attr, attr);\n\tmdev = chattr->mdev;\n\tif (strcmp(attr->attr.name, \"priority\") == 0)\n\t\tsprintf(buf, \"%d\\n\", mdev->priority[chattr->index]);\n\telse if (strcmp(attr->attr.name, \"weight\") == 0)\n\t\tsprintf(buf, \"%d\\n\", mdev->weight[chattr->index]);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t set_values_channel(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tstruct hidma_chan_attr *chattr;\n\tstruct hidma_mgmt_dev *mdev;\n\tunsigned long tmp;\n\tint rc;\n\n\tchattr = container_of(attr, struct hidma_chan_attr, attr);\n\tmdev = chattr->mdev;\n\n\trc = kstrtoul(buf, 0, &tmp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (strcmp(attr->attr.name, \"priority\") == 0) {\n\t\trc = set_priority(mdev, chattr->index, tmp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (strcmp(attr->attr.name, \"weight\") == 0) {\n\t\trc = set_weight(mdev, chattr->index, tmp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn count;\n}\n\nstatic int create_sysfs_entry(struct hidma_mgmt_dev *dev, char *name, int mode)\n{\n\tstruct device_attribute *attrs;\n\tchar *name_copy;\n\n\tattrs = devm_kmalloc(&dev->pdev->dev,\n\t\t\t     sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tname_copy = devm_kstrdup(&dev->pdev->dev, name, GFP_KERNEL);\n\tif (!name_copy)\n\t\treturn -ENOMEM;\n\n\tattrs->attr.name = name_copy;\n\tattrs->attr.mode = mode;\n\tattrs->show = show_values;\n\tattrs->store = set_values;\n\tsysfs_attr_init(&attrs->attr);\n\n\treturn device_create_file(&dev->pdev->dev, attrs);\n}\n\nstatic int create_sysfs_entry_channel(struct hidma_mgmt_dev *mdev, char *name,\n\t\t\t\t      int mode, int index,\n\t\t\t\t      struct kobject *parent)\n{\n\tstruct hidma_chan_attr *chattr;\n\tchar *name_copy;\n\n\tchattr = devm_kmalloc(&mdev->pdev->dev, sizeof(*chattr), GFP_KERNEL);\n\tif (!chattr)\n\t\treturn -ENOMEM;\n\n\tname_copy = devm_kstrdup(&mdev->pdev->dev, name, GFP_KERNEL);\n\tif (!name_copy)\n\t\treturn -ENOMEM;\n\n\tchattr->mdev = mdev;\n\tchattr->index = index;\n\tchattr->attr.attr.name = name_copy;\n\tchattr->attr.attr.mode = mode;\n\tchattr->attr.show = show_values_channel;\n\tchattr->attr.store = set_values_channel;\n\tsysfs_attr_init(&chattr->attr.attr);\n\n\treturn sysfs_create_file(parent, &chattr->attr.attr);\n}\n\nint hidma_mgmt_init_sys(struct hidma_mgmt_dev *mdev)\n{\n\tunsigned int i;\n\tint rc;\n\tint required;\n\tstruct kobject *chanops;\n\n\trequired = sizeof(*mdev->chroots) * mdev->dma_channels;\n\tmdev->chroots = devm_kmalloc(&mdev->pdev->dev, required, GFP_KERNEL);\n\tif (!mdev->chroots)\n\t\treturn -ENOMEM;\n\n\tchanops = kobject_create_and_add(\"chanops\", &mdev->pdev->dev.kobj);\n\tif (!chanops)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < mdev->dma_channels; i++) {\n\t\tchar name[20];\n\n\t\tsnprintf(name, sizeof(name), \"chan%d\", i);\n\t\tmdev->chroots[i] = kobject_create_and_add(name, chanops);\n\t\tif (!mdev->chroots[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(hidma_mgmt_files); i++) {\n\t\trc = create_sysfs_entry(mdev, hidma_mgmt_files[i].name,\n\t\t\t\t\thidma_mgmt_files[i].mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < mdev->dma_channels; i++) {\n\t\trc = create_sysfs_entry_channel(mdev, \"priority\",\n\t\t\t\t\t\t(S_IRUGO | S_IWUGO), i,\n\t\t\t\t\t\tmdev->chroots[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = create_sysfs_entry_channel(mdev, \"weight\",\n\t\t\t\t\t\t(S_IRUGO | S_IWUGO), i,\n\t\t\t\t\t\tmdev->chroots[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hidma_mgmt_init_sys);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}