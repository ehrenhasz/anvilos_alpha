{
  "module_name": "stm32-dmamux.c",
  "hash_id": "0e19b00293199159b5686dde1ac56bb0e5d74fe3f1d2dbb82ff4897229c9785d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/stm32-dmamux.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define STM32_DMAMUX_CCR(x)\t\t(0x4 * (x))\n#define STM32_DMAMUX_MAX_DMA_REQUESTS\t32\n#define STM32_DMAMUX_MAX_REQUESTS\t255\n\nstruct stm32_dmamux {\n\tu32 master;\n\tu32 request;\n\tu32 chan_id;\n};\n\nstruct stm32_dmamux_data {\n\tstruct dma_router dmarouter;\n\tstruct clk *clk;\n\tvoid __iomem *iomem;\n\tu32 dma_requests;  \n\tu32 dmamux_requests;  \n\tspinlock_t lock;  \n\tDECLARE_BITMAP(dma_inuse, STM32_DMAMUX_MAX_DMA_REQUESTS);  \n\tu32 ccr[STM32_DMAMUX_MAX_DMA_REQUESTS];  \n\tu32 dma_reqs[];  \n};\n\nstatic inline u32 stm32_dmamux_read(void __iomem *iomem, u32 reg)\n{\n\treturn readl_relaxed(iomem + reg);\n}\n\nstatic inline void stm32_dmamux_write(void __iomem *iomem, u32 reg, u32 val)\n{\n\twritel_relaxed(val, iomem + reg);\n}\n\nstatic void stm32_dmamux_free(struct device *dev, void *route_data)\n{\n\tstruct stm32_dmamux_data *dmamux = dev_get_drvdata(dev);\n\tstruct stm32_dmamux *mux = route_data;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dmamux->lock, flags);\n\n\tstm32_dmamux_write(dmamux->iomem, STM32_DMAMUX_CCR(mux->chan_id), 0);\n\tclear_bit(mux->chan_id, dmamux->dma_inuse);\n\n\tpm_runtime_put_sync(dev);\n\n\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\n\tdev_dbg(dev, \"Unmapping DMAMUX(%u) to DMA%u(%u)\\n\",\n\t\tmux->request, mux->master, mux->chan_id);\n\n\tkfree(mux);\n}\n\nstatic void *stm32_dmamux_route_allocate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t struct of_dma *ofdma)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\n\tstruct stm32_dmamux_data *dmamux = platform_get_drvdata(pdev);\n\tstruct stm32_dmamux *mux;\n\tu32 i, min, max;\n\tint ret;\n\tunsigned long flags;\n\n\tif (dma_spec->args_count != 3) {\n\t\tdev_err(&pdev->dev, \"invalid number of dma mux args\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dma_spec->args[0] > dmamux->dmamux_requests) {\n\t\tdev_err(&pdev->dev, \"invalid mux request number: %d\\n\",\n\t\t\tdma_spec->args[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_irqsave(&dmamux->lock, flags);\n\tmux->chan_id = find_first_zero_bit(dmamux->dma_inuse,\n\t\t\t\t\t   dmamux->dma_requests);\n\n\tif (mux->chan_id == dmamux->dma_requests) {\n\t\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\t\tdev_err(&pdev->dev, \"Run out of free DMA requests\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_chan_id;\n\t}\n\tset_bit(mux->chan_id, dmamux->dma_inuse);\n\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\n\t \n\tfor (i = 1, min = 0, max = dmamux->dma_reqs[i];\n\t     i <= dmamux->dma_reqs[0];\n\t     min += dmamux->dma_reqs[i], max += dmamux->dma_reqs[++i])\n\t\tif (mux->chan_id < max)\n\t\t\tbreak;\n\tmux->master = i - 1;\n\n\t \n\tdma_spec->np = of_parse_phandle(ofdma->of_node, \"dma-masters\", i - 1);\n\tif (!dma_spec->np) {\n\t\tdev_err(&pdev->dev, \"can't get dma master\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tspin_lock_irqsave(&dmamux->lock, flags);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\t\tgoto error;\n\t}\n\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\n\tmux->request = dma_spec->args[0];\n\n\t \n\tdma_spec->args[3] = dma_spec->args[2] | mux->chan_id << 16;\n\tdma_spec->args[2] = dma_spec->args[1];\n\tdma_spec->args[1] = 0;\n\tdma_spec->args[0] = mux->chan_id - min;\n\tdma_spec->args_count = 4;\n\n\tstm32_dmamux_write(dmamux->iomem, STM32_DMAMUX_CCR(mux->chan_id),\n\t\t\t   mux->request);\n\tdev_dbg(&pdev->dev, \"Mapping DMAMUX(%u) to DMA%u(%u)\\n\",\n\t\tmux->request, mux->master, mux->chan_id);\n\n\treturn mux;\n\nerror:\n\tclear_bit(mux->chan_id, dmamux->dma_inuse);\n\nerror_chan_id:\n\tkfree(mux);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct of_device_id stm32_stm32dma_master_match[] __maybe_unused = {\n\t{ .compatible = \"st,stm32-dma\", },\n\t{},\n};\n\nstatic int stm32_dmamux_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct device_node *dma_node;\n\tstruct stm32_dmamux_data *stm32_dmamux;\n\tvoid __iomem *iomem;\n\tstruct reset_control *rst;\n\tint i, count, ret;\n\tu32 dma_req;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tcount = device_property_count_u32(&pdev->dev, \"dma-masters\");\n\tif (count < 0) {\n\t\tdev_err(&pdev->dev, \"Can't get DMA master(s) node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstm32_dmamux = devm_kzalloc(&pdev->dev, sizeof(*stm32_dmamux) +\n\t\t\t\t    sizeof(u32) * (count + 1), GFP_KERNEL);\n\tif (!stm32_dmamux)\n\t\treturn -ENOMEM;\n\n\tdma_req = 0;\n\tfor (i = 1; i <= count; i++) {\n\t\tdma_node = of_parse_phandle(node, \"dma-masters\", i - 1);\n\n\t\tmatch = of_match_node(stm32_stm32dma_master_match, dma_node);\n\t\tif (!match) {\n\t\t\tdev_err(&pdev->dev, \"DMA master is not supported\\n\");\n\t\t\tof_node_put(dma_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (of_property_read_u32(dma_node, \"dma-requests\",\n\t\t\t\t\t &stm32_dmamux->dma_reqs[i])) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Missing MUX output information, using %u.\\n\",\n\t\t\t\t STM32_DMAMUX_MAX_DMA_REQUESTS);\n\t\t\tstm32_dmamux->dma_reqs[i] =\n\t\t\t\tSTM32_DMAMUX_MAX_DMA_REQUESTS;\n\t\t}\n\t\tdma_req += stm32_dmamux->dma_reqs[i];\n\t\tof_node_put(dma_node);\n\t}\n\n\tif (dma_req > STM32_DMAMUX_MAX_DMA_REQUESTS) {\n\t\tdev_err(&pdev->dev, \"Too many DMA Master Requests to manage\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstm32_dmamux->dma_requests = dma_req;\n\tstm32_dmamux->dma_reqs[0] = count;\n\n\tif (device_property_read_u32(&pdev->dev, \"dma-requests\",\n\t\t\t\t     &stm32_dmamux->dmamux_requests)) {\n\t\tstm32_dmamux->dmamux_requests = STM32_DMAMUX_MAX_REQUESTS;\n\t\tdev_warn(&pdev->dev, \"DMAMUX defaulting on %u requests\\n\",\n\t\t\t stm32_dmamux->dmamux_requests);\n\t}\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tiomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iomem))\n\t\treturn PTR_ERR(iomem);\n\n\tspin_lock_init(&stm32_dmamux->lock);\n\n\tstm32_dmamux->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(stm32_dmamux->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(stm32_dmamux->clk),\n\t\t\t\t     \"Missing clock controller\\n\");\n\n\tret = clk_prepare_enable(stm32_dmamux->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"clk_prep_enable error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(rst)) {\n\t\tret = PTR_ERR(rst);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_clk;\n\t} else if (count > 1) {  \n\t\treset_control_assert(rst);\n\t\tudelay(2);\n\t\treset_control_deassert(rst);\n\t}\n\n\tstm32_dmamux->iomem = iomem;\n\tstm32_dmamux->dmarouter.dev = &pdev->dev;\n\tstm32_dmamux->dmarouter.route_free = stm32_dmamux_free;\n\n\tplatform_set_drvdata(pdev, stm32_dmamux);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\t \n\tfor (i = 0; i < stm32_dmamux->dma_requests; i++)\n\t\tstm32_dmamux_write(stm32_dmamux->iomem, STM32_DMAMUX_CCR(i), 0);\n\n\tpm_runtime_put(&pdev->dev);\n\n\tret = of_dma_router_register(node, stm32_dmamux_route_allocate,\n\t\t\t\t     &stm32_dmamux->dmarouter);\n\tif (ret)\n\t\tgoto pm_disable;\n\n\treturn 0;\n\npm_disable:\n\tpm_runtime_disable(&pdev->dev);\nerr_clk:\n\tclk_disable_unprepare(stm32_dmamux->clk);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int stm32_dmamux_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stm32_dmamux_data *stm32_dmamux = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(stm32_dmamux->clk);\n\n\treturn 0;\n}\n\nstatic int stm32_dmamux_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stm32_dmamux_data *stm32_dmamux = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = clk_prepare_enable(stm32_dmamux->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_dmamux_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stm32_dmamux_data *stm32_dmamux = platform_get_drvdata(pdev);\n\tint i, ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < stm32_dmamux->dma_requests; i++)\n\t\tstm32_dmamux->ccr[i] = stm32_dmamux_read(stm32_dmamux->iomem,\n\t\t\t\t\t\t\t STM32_DMAMUX_CCR(i));\n\n\tpm_runtime_put_sync(dev);\n\n\tpm_runtime_force_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int stm32_dmamux_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stm32_dmamux_data *stm32_dmamux = platform_get_drvdata(pdev);\n\tint i, ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < stm32_dmamux->dma_requests; i++)\n\t\tstm32_dmamux_write(stm32_dmamux->iomem, STM32_DMAMUX_CCR(i),\n\t\t\t\t   stm32_dmamux->ccr[i]);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops stm32_dmamux_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_dmamux_suspend, stm32_dmamux_resume)\n\tSET_RUNTIME_PM_OPS(stm32_dmamux_runtime_suspend,\n\t\t\t   stm32_dmamux_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id stm32_dmamux_match[] = {\n\t{ .compatible = \"st,stm32h7-dmamux\" },\n\t{},\n};\n\nstatic struct platform_driver stm32_dmamux_driver = {\n\t.probe\t= stm32_dmamux_probe,\n\t.driver = {\n\t\t.name = \"stm32-dmamux\",\n\t\t.of_match_table = stm32_dmamux_match,\n\t\t.pm = &stm32_dmamux_pm_ops,\n\t},\n};\n\nstatic int __init stm32_dmamux_init(void)\n{\n\treturn platform_driver_register(&stm32_dmamux_driver);\n}\narch_initcall(stm32_dmamux_init);\n\nMODULE_DESCRIPTION(\"DMA Router driver for STM32 DMA MUX\");\nMODULE_AUTHOR(\"M'boumba Cedric Madianga <cedric.madianga@gmail.com>\");\nMODULE_AUTHOR(\"Pierre-Yves Mordret <pierre-yves.mordret@st.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}