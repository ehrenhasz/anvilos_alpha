{
  "module_name": "acpi-dma.c",
  "hash_id": "d91a26eea76fe4bbbe46a4cbb04cd2e331cf98c5d3f11f1e43d05dc99308e5f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/acpi-dma.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/acpi.h>\n#include <linux/acpi_dma.h>\n#include <linux/property.h>\n\nstatic LIST_HEAD(acpi_dma_list);\nstatic DEFINE_MUTEX(acpi_dma_lock);\n\n \nstatic int acpi_dma_parse_resource_group(const struct acpi_csrt_group *grp,\n\t\tstruct acpi_device *adev, struct acpi_dma *adma)\n{\n\tconst struct acpi_csrt_shared_info *si;\n\tstruct list_head resource_list;\n\tstruct resource_entry *rentry;\n\tresource_size_t mem = 0, irq = 0;\n\tint ret;\n\n\tif (grp->shared_info_length != sizeof(struct acpi_csrt_shared_info))\n\t\treturn -ENODEV;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\n\tif (ret <= 0)\n\t\treturn 0;\n\n\tlist_for_each_entry(rentry, &resource_list, node) {\n\t\tif (resource_type(rentry->res) == IORESOURCE_MEM)\n\t\t\tmem = rentry->res->start;\n\t\telse if (resource_type(rentry->res) == IORESOURCE_IRQ)\n\t\t\tirq = rentry->res->start;\n\t}\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\t \n\tif (mem == 0 && irq == 0)\n\t\treturn 0;\n\n\tsi = (const struct acpi_csrt_shared_info *)&grp[1];\n\n\t \n\tif (si->mmio_base_low != lower_32_bits(mem) ||\n\t    si->mmio_base_high != upper_32_bits(mem))\n\t\treturn 0;\n\n\t \n\tret = acpi_register_gsi(NULL, si->gsi_interrupt, si->interrupt_mode, si->interrupt_polarity);\n\tif (ret < 0)\n\t\treturn 0;\n\n\t \n\tif (ret != irq)\n\t\treturn 0;\n\n\tdev_dbg(&adev->dev, \"matches with %.4s%04X (rev %u)\\n\",\n\t\t(char *)&grp->vendor_id, grp->device_id, grp->revision);\n\n\t \n\tif (si->base_request_line == 0 && si->num_handshake_signals == 0)\n\t\treturn 0;\n\n\t \n\tret = dma_coerce_mask_and_coherent(&adev->dev,\n\t\t\t\t\t   DMA_BIT_MASK(si->dma_address_width));\n\tif (ret)\n\t\treturn 0;\n\n\tadma->base_request_line = si->base_request_line;\n\tadma->end_request_line = si->base_request_line +\n\t\t\t\t si->num_handshake_signals - 1;\n\n\tdev_dbg(&adev->dev, \"request line base: 0x%04x end: 0x%04x\\n\",\n\t\tadma->base_request_line, adma->end_request_line);\n\n\treturn 1;\n}\n\n \nstatic void acpi_dma_parse_csrt(struct acpi_device *adev, struct acpi_dma *adma)\n{\n\tstruct acpi_csrt_group *grp, *end;\n\tstruct acpi_table_csrt *csrt;\n\tacpi_status status;\n\tint ret;\n\n\tstatus = acpi_get_table(ACPI_SIG_CSRT, 0,\n\t\t\t\t(struct acpi_table_header **)&csrt);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tdev_warn(&adev->dev, \"failed to get the CSRT table\\n\");\n\t\treturn;\n\t}\n\n\tgrp = (struct acpi_csrt_group *)(csrt + 1);\n\tend = (struct acpi_csrt_group *)((void *)csrt + csrt->header.length);\n\n\twhile (grp < end) {\n\t\tret = acpi_dma_parse_resource_group(grp, adev, adma);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&adev->dev,\n\t\t\t\t \"error in parsing resource group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tgrp = (struct acpi_csrt_group *)((void *)grp + grp->length);\n\t}\n\n\tacpi_put_table((struct acpi_table_header *)csrt);\n}\n\n \nint acpi_dma_controller_register(struct device *dev,\n\t\tstruct dma_chan *(*acpi_dma_xlate)\n\t\t(struct acpi_dma_spec *, struct acpi_dma *),\n\t\tvoid *data)\n{\n\tstruct acpi_device *adev;\n\tstruct acpi_dma\t*adma;\n\n\tif (!dev || !acpi_dma_xlate)\n\t\treturn -EINVAL;\n\n\t \n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\tadma = kzalloc(sizeof(*adma), GFP_KERNEL);\n\tif (!adma)\n\t\treturn -ENOMEM;\n\n\tadma->dev = dev;\n\tadma->acpi_dma_xlate = acpi_dma_xlate;\n\tadma->data = data;\n\n\tacpi_dma_parse_csrt(adev, adma);\n\n\t \n\tmutex_lock(&acpi_dma_lock);\n\tlist_add_tail(&adma->dma_controllers, &acpi_dma_list);\n\tmutex_unlock(&acpi_dma_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_dma_controller_register);\n\n \nint acpi_dma_controller_free(struct device *dev)\n{\n\tstruct acpi_dma *adma;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&acpi_dma_lock);\n\n\tlist_for_each_entry(adma, &acpi_dma_list, dma_controllers)\n\t\tif (adma->dev == dev) {\n\t\t\tlist_del(&adma->dma_controllers);\n\t\t\tmutex_unlock(&acpi_dma_lock);\n\t\t\tkfree(adma);\n\t\t\treturn 0;\n\t\t}\n\n\tmutex_unlock(&acpi_dma_lock);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(acpi_dma_controller_free);\n\nstatic void devm_acpi_dma_release(struct device *dev, void *res)\n{\n\tacpi_dma_controller_free(dev);\n}\n\n \nint devm_acpi_dma_controller_register(struct device *dev,\n\t\tstruct dma_chan *(*acpi_dma_xlate)\n\t\t(struct acpi_dma_spec *, struct acpi_dma *),\n\t\tvoid *data)\n{\n\tvoid *res;\n\tint ret;\n\n\tres = devres_alloc(devm_acpi_dma_release, 0, GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tret = acpi_dma_controller_register(dev, acpi_dma_xlate, data);\n\tif (ret) {\n\t\tdevres_free(res);\n\t\treturn ret;\n\t}\n\tdevres_add(dev, res);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_acpi_dma_controller_register);\n\n \nvoid devm_acpi_dma_controller_free(struct device *dev)\n{\n\tWARN_ON(devres_release(dev, devm_acpi_dma_release, NULL, NULL));\n}\nEXPORT_SYMBOL_GPL(devm_acpi_dma_controller_free);\n\n \nstatic int acpi_dma_update_dma_spec(struct acpi_dma *adma,\n\t\tstruct acpi_dma_spec *dma_spec)\n{\n\t \n\tdma_spec->dev = adma->dev;\n\n\t \n\tif (adma->base_request_line == 0 && adma->end_request_line == 0)\n\t\treturn 0;\n\n\t \n\tif (dma_spec->slave_id < adma->base_request_line ||\n\t    dma_spec->slave_id > adma->end_request_line)\n\t\treturn -1;\n\n\t \n\tdma_spec->slave_id -= adma->base_request_line;\n\n\treturn 1;\n}\n\nstruct acpi_dma_parser_data {\n\tstruct acpi_dma_spec dma_spec;\n\tsize_t index;\n\tsize_t n;\n};\n\n \nstatic int acpi_dma_parse_fixed_dma(struct acpi_resource *res, void *data)\n{\n\tstruct acpi_dma_parser_data *pdata = data;\n\n\tif (res->type == ACPI_RESOURCE_TYPE_FIXED_DMA) {\n\t\tstruct acpi_resource_fixed_dma *dma = &res->data.fixed_dma;\n\n\t\tif (pdata->n++ == pdata->index) {\n\t\t\tpdata->dma_spec.chan_id = dma->channels;\n\t\t\tpdata->dma_spec.slave_id = dma->request_lines;\n\t\t}\n\t}\n\n\t \n\treturn 1;\n}\n\n \nstruct dma_chan *acpi_dma_request_slave_chan_by_index(struct device *dev,\n\t\tsize_t index)\n{\n\tstruct acpi_dma_parser_data pdata;\n\tstruct acpi_dma_spec *dma_spec = &pdata.dma_spec;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct list_head resource_list;\n\tstruct acpi_dma *adma;\n\tstruct dma_chan *chan = NULL;\n\tint found;\n\tint ret;\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tpdata.index = index;\n\n\t \n\tdma_spec->chan_id = -1;\n\tdma_spec->slave_id = -1;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     acpi_dma_parse_fixed_dma, &pdata);\n\tacpi_dev_free_resource_list(&resource_list);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (dma_spec->slave_id < 0 || dma_spec->chan_id < 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&acpi_dma_lock);\n\n\tlist_for_each_entry(adma, &acpi_dma_list, dma_controllers) {\n\t\t \n\t\tfound = acpi_dma_update_dma_spec(adma, dma_spec);\n\t\tif (found < 0)\n\t\t\tcontinue;\n\t\tchan = adma->acpi_dma_xlate(dma_spec, adma);\n\t\t \n\t\tif (found > 0 || chan)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&acpi_dma_lock);\n\treturn chan ? chan : ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL_GPL(acpi_dma_request_slave_chan_by_index);\n\n \nstruct dma_chan *acpi_dma_request_slave_chan_by_name(struct device *dev,\n\t\tconst char *name)\n{\n\tint index;\n\n\tindex = device_property_match_string(dev, \"dma-names\", name);\n\tif (index < 0) {\n\t\tif (!strcmp(name, \"tx\"))\n\t\t\tindex = 0;\n\t\telse if (!strcmp(name, \"rx\"))\n\t\t\tindex = 1;\n\t\telse\n\t\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tdev_dbg(dev, \"Looking for DMA channel \\\"%s\\\" at index %d...\\n\", name, index);\n\treturn acpi_dma_request_slave_chan_by_index(dev, index);\n}\nEXPORT_SYMBOL_GPL(acpi_dma_request_slave_chan_by_name);\n\n \nstruct dma_chan *acpi_dma_simple_xlate(struct acpi_dma_spec *dma_spec,\n\t\tstruct acpi_dma *adma)\n{\n\tstruct acpi_dma_filter_info *info = adma->data;\n\n\tif (!info || !info->filter_fn)\n\t\treturn NULL;\n\n\treturn dma_request_channel(info->dma_cap, info->filter_fn, dma_spec);\n}\nEXPORT_SYMBOL_GPL(acpi_dma_simple_xlate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}