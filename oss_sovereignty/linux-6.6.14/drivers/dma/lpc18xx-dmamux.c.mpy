{
  "module_name": "lpc18xx-dmamux.c",
  "hash_id": "ffe341cb741aa85138299f489e3e640ed7537b2a0d1554127e92287a30769954",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/lpc18xx-dmamux.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n\n \n#define LPC18XX_CREG_DMAMUX\t\t0x11c\n#define LPC18XX_DMAMUX_VAL(v, n)\t((v) << (n * 2))\n#define LPC18XX_DMAMUX_MASK(n)\t\t(0x3 << (n * 2))\n#define LPC18XX_DMAMUX_MAX_VAL\t\t0x3\n\nstruct lpc18xx_dmamux {\n\tu32 value;\n\tbool busy;\n};\n\nstruct lpc18xx_dmamux_data {\n\tstruct dma_router dmarouter;\n\tstruct lpc18xx_dmamux *muxes;\n\tu32 dma_master_requests;\n\tu32 dma_mux_requests;\n\tstruct regmap *reg;\n\tspinlock_t lock;\n};\n\nstatic void lpc18xx_dmamux_free(struct device *dev, void *route_data)\n{\n\tstruct lpc18xx_dmamux_data *dmamux = dev_get_drvdata(dev);\n\tstruct lpc18xx_dmamux *mux = route_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dmamux->lock, flags);\n\tmux->busy = false;\n\tspin_unlock_irqrestore(&dmamux->lock, flags);\n}\n\nstatic void *lpc18xx_dmamux_reserve(struct of_phandle_args *dma_spec,\n\t\t\t\t    struct of_dma *ofdma)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\n\tstruct lpc18xx_dmamux_data *dmamux = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\tunsigned mux;\n\n\tif (dma_spec->args_count != 3) {\n\t\tdev_err(&pdev->dev, \"invalid number of dma mux args\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmux = dma_spec->args[0];\n\tif (mux >= dmamux->dma_master_requests) {\n\t\tdev_err(&pdev->dev, \"invalid mux number: %d\\n\",\n\t\t\tdma_spec->args[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dma_spec->args[1] > LPC18XX_DMAMUX_MAX_VAL) {\n\t\tdev_err(&pdev->dev, \"invalid dma mux value: %d\\n\",\n\t\t\tdma_spec->args[1]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tdma_spec->np = of_parse_phandle(ofdma->of_node, \"dma-masters\", 0);\n\tif (!dma_spec->np) {\n\t\tdev_err(&pdev->dev, \"can't get dma master\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tspin_lock_irqsave(&dmamux->lock, flags);\n\tif (dmamux->muxes[mux].busy) {\n\t\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\t\tdev_err(&pdev->dev, \"dma request %u busy with %u.%u\\n\",\n\t\t\tmux, mux, dmamux->muxes[mux].value);\n\t\tof_node_put(dma_spec->np);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tdmamux->muxes[mux].busy = true;\n\tdmamux->muxes[mux].value = dma_spec->args[1];\n\n\tregmap_update_bits(dmamux->reg, LPC18XX_CREG_DMAMUX,\n\t\t\t   LPC18XX_DMAMUX_MASK(mux),\n\t\t\t   LPC18XX_DMAMUX_VAL(dmamux->muxes[mux].value, mux));\n\tspin_unlock_irqrestore(&dmamux->lock, flags);\n\n\tdma_spec->args[1] = dma_spec->args[2];\n\tdma_spec->args_count = 2;\n\n\tdev_dbg(&pdev->dev, \"mapping dmamux %u.%u to dma request %u\\n\", mux,\n\t\tdmamux->muxes[mux].value, mux);\n\n\treturn &dmamux->muxes[mux];\n}\n\nstatic int lpc18xx_dmamux_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dma_np, *np = pdev->dev.of_node;\n\tstruct lpc18xx_dmamux_data *dmamux;\n\tint ret;\n\n\tdmamux = devm_kzalloc(&pdev->dev, sizeof(*dmamux), GFP_KERNEL);\n\tif (!dmamux)\n\t\treturn -ENOMEM;\n\n\tdmamux->reg = syscon_regmap_lookup_by_compatible(\"nxp,lpc1850-creg\");\n\tif (IS_ERR(dmamux->reg)) {\n\t\tdev_err(&pdev->dev, \"syscon lookup failed\\n\");\n\t\treturn PTR_ERR(dmamux->reg);\n\t}\n\n\tret = of_property_read_u32(np, \"dma-requests\",\n\t\t\t\t   &dmamux->dma_mux_requests);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing dma-requests property\\n\");\n\t\treturn ret;\n\t}\n\n\tdma_np = of_parse_phandle(np, \"dma-masters\", 0);\n\tif (!dma_np) {\n\t\tdev_err(&pdev->dev, \"can't get dma master\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(dma_np, \"dma-requests\",\n\t\t\t\t   &dmamux->dma_master_requests);\n\tof_node_put(dma_np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing master dma-requests property\\n\");\n\t\treturn ret;\n\t}\n\n\tdmamux->muxes = devm_kcalloc(&pdev->dev, dmamux->dma_master_requests,\n\t\t\t\t     sizeof(struct lpc18xx_dmamux),\n\t\t\t\t     GFP_KERNEL);\n\tif (!dmamux->muxes)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dmamux->lock);\n\tplatform_set_drvdata(pdev, dmamux);\n\tdmamux->dmarouter.dev = &pdev->dev;\n\tdmamux->dmarouter.route_free = lpc18xx_dmamux_free;\n\n\treturn of_dma_router_register(np, lpc18xx_dmamux_reserve,\n\t\t\t\t      &dmamux->dmarouter);\n}\n\nstatic const struct of_device_id lpc18xx_dmamux_match[] = {\n\t{ .compatible = \"nxp,lpc1850-dmamux\" },\n\t{},\n};\n\nstatic struct platform_driver lpc18xx_dmamux_driver = {\n\t.probe\t= lpc18xx_dmamux_probe,\n\t.driver = {\n\t\t.name = \"lpc18xx-dmamux\",\n\t\t.of_match_table = lpc18xx_dmamux_match,\n\t},\n};\n\nstatic int __init lpc18xx_dmamux_init(void)\n{\n\treturn platform_driver_register(&lpc18xx_dmamux_driver);\n}\narch_initcall(lpc18xx_dmamux_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}