{
  "module_name": "sun6i-dma.c",
  "hash_id": "7f7a233adb2c66e13a22222f4aee0f4be168aa6183f9fd28e13246b603705323",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/sun6i-dma.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"virt-dma.h\"\n\n \n#define DMA_IRQ_EN(x)\t\t((x) * 0x04)\n#define DMA_IRQ_HALF\t\t\tBIT(0)\n#define DMA_IRQ_PKG\t\t\tBIT(1)\n#define DMA_IRQ_QUEUE\t\t\tBIT(2)\n\n#define DMA_IRQ_CHAN_NR\t\t\t8\n#define DMA_IRQ_CHAN_WIDTH\t\t4\n\n\n#define DMA_IRQ_STAT(x)\t\t((x) * 0x04 + 0x10)\n\n#define DMA_STAT\t\t0x30\n\n \n#define DMA_MAX_CHANNELS\t(DMA_IRQ_CHAN_NR * 0x10 / 4)\n\n \n#define SUN8I_DMA_GATE\t\t0x20\n#define SUN8I_DMA_GATE_ENABLE\t0x4\n\n#define SUNXI_H3_SECURE_REG\t\t0x20\n#define SUNXI_H3_DMA_GATE\t\t0x28\n#define SUNXI_H3_DMA_GATE_ENABLE\t0x4\n \n#define DMA_CHAN_ENABLE\t\t0x00\n#define DMA_CHAN_ENABLE_START\t\tBIT(0)\n#define DMA_CHAN_ENABLE_STOP\t\t0\n\n#define DMA_CHAN_PAUSE\t\t0x04\n#define DMA_CHAN_PAUSE_PAUSE\t\tBIT(1)\n#define DMA_CHAN_PAUSE_RESUME\t\t0\n\n#define DMA_CHAN_LLI_ADDR\t0x08\n\n#define DMA_CHAN_CUR_CFG\t0x0c\n#define DMA_CHAN_MAX_DRQ_A31\t\t0x1f\n#define DMA_CHAN_MAX_DRQ_H6\t\t0x3f\n#define DMA_CHAN_CFG_SRC_DRQ_A31(x)\t((x) & DMA_CHAN_MAX_DRQ_A31)\n#define DMA_CHAN_CFG_SRC_DRQ_H6(x)\t((x) & DMA_CHAN_MAX_DRQ_H6)\n#define DMA_CHAN_CFG_SRC_MODE_A31(x)\t(((x) & 0x1) << 5)\n#define DMA_CHAN_CFG_SRC_MODE_H6(x)\t(((x) & 0x1) << 8)\n#define DMA_CHAN_CFG_SRC_BURST_A31(x)\t(((x) & 0x3) << 7)\n#define DMA_CHAN_CFG_SRC_BURST_H3(x)\t(((x) & 0x3) << 6)\n#define DMA_CHAN_CFG_SRC_WIDTH(x)\t(((x) & 0x3) << 9)\n\n#define DMA_CHAN_CFG_DST_DRQ_A31(x)\t(DMA_CHAN_CFG_SRC_DRQ_A31(x) << 16)\n#define DMA_CHAN_CFG_DST_DRQ_H6(x)\t(DMA_CHAN_CFG_SRC_DRQ_H6(x) << 16)\n#define DMA_CHAN_CFG_DST_MODE_A31(x)\t(DMA_CHAN_CFG_SRC_MODE_A31(x) << 16)\n#define DMA_CHAN_CFG_DST_MODE_H6(x)\t(DMA_CHAN_CFG_SRC_MODE_H6(x) << 16)\n#define DMA_CHAN_CFG_DST_BURST_A31(x)\t(DMA_CHAN_CFG_SRC_BURST_A31(x) << 16)\n#define DMA_CHAN_CFG_DST_BURST_H3(x)\t(DMA_CHAN_CFG_SRC_BURST_H3(x) << 16)\n#define DMA_CHAN_CFG_DST_WIDTH(x)\t(DMA_CHAN_CFG_SRC_WIDTH(x) << 16)\n\n#define DMA_CHAN_CUR_SRC\t0x10\n\n#define DMA_CHAN_CUR_DST\t0x14\n\n#define DMA_CHAN_CUR_CNT\t0x18\n\n#define DMA_CHAN_CUR_PARA\t0x1c\n\n \n#define SRC_HIGH_ADDR(x)\t\t(((x) & 0x3U) << 16)\n#define DST_HIGH_ADDR(x)\t\t(((x) & 0x3U) << 18)\n\n \n#define LLI_LAST_ITEM\t0xfffff800\n#define NORMAL_WAIT\t8\n#define DRQ_SDRAM\t1\n#define LINEAR_MODE     0\n#define IO_MODE         1\n\n \nstruct sun6i_dma_dev;\n\n \nstruct sun6i_dma_config {\n\tu32 nr_max_channels;\n\tu32 nr_max_requests;\n\tu32 nr_max_vchans;\n\t \n\tvoid (*clock_autogate_enable)(struct sun6i_dma_dev *);\n\tvoid (*set_burst_length)(u32 *p_cfg, s8 src_burst, s8 dst_burst);\n\tvoid (*set_drq)(u32 *p_cfg, s8 src_drq, s8 dst_drq);\n\tvoid (*set_mode)(u32 *p_cfg, s8 src_mode, s8 dst_mode);\n\tu32 src_burst_lengths;\n\tu32 dst_burst_lengths;\n\tu32 src_addr_widths;\n\tu32 dst_addr_widths;\n\tbool has_high_addr;\n\tbool has_mbus_clk;\n};\n\n \nstruct sun6i_dma_lli {\n\tu32\t\t\tcfg;\n\tu32\t\t\tsrc;\n\tu32\t\t\tdst;\n\tu32\t\t\tlen;\n\tu32\t\t\tpara;\n\tu32\t\t\tp_lli_next;\n\n\t \n\tstruct sun6i_dma_lli\t*v_lli_next;\n};\n\n\nstruct sun6i_desc {\n\tstruct virt_dma_desc\tvd;\n\tdma_addr_t\t\tp_lli;\n\tstruct sun6i_dma_lli\t*v_lli;\n};\n\nstruct sun6i_pchan {\n\tu32\t\t\tidx;\n\tvoid __iomem\t\t*base;\n\tstruct sun6i_vchan\t*vchan;\n\tstruct sun6i_desc\t*desc;\n\tstruct sun6i_desc\t*done;\n};\n\nstruct sun6i_vchan {\n\tstruct virt_dma_chan\tvc;\n\tstruct list_head\tnode;\n\tstruct dma_slave_config\tcfg;\n\tstruct sun6i_pchan\t*phy;\n\tu8\t\t\tport;\n\tu8\t\t\tirq_type;\n\tbool\t\t\tcyclic;\n};\n\nstruct sun6i_dma_dev {\n\tstruct dma_device\tslave;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*clk_mbus;\n\tint\t\t\tirq;\n\tspinlock_t\t\tlock;\n\tstruct reset_control\t*rstc;\n\tstruct tasklet_struct\ttask;\n\tatomic_t\t\ttasklet_shutdown;\n\tstruct list_head\tpending;\n\tstruct dma_pool\t\t*pool;\n\tstruct sun6i_pchan\t*pchans;\n\tstruct sun6i_vchan\t*vchans;\n\tconst struct sun6i_dma_config *cfg;\n\tu32\t\t\tnum_pchans;\n\tu32\t\t\tnum_vchans;\n\tu32\t\t\tmax_request;\n};\n\nstatic struct device *chan2dev(struct dma_chan *chan)\n{\n\treturn &chan->dev->device;\n}\n\nstatic inline struct sun6i_dma_dev *to_sun6i_dma_dev(struct dma_device *d)\n{\n\treturn container_of(d, struct sun6i_dma_dev, slave);\n}\n\nstatic inline struct sun6i_vchan *to_sun6i_vchan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct sun6i_vchan, vc.chan);\n}\n\nstatic inline struct sun6i_desc *\nto_sun6i_desc(struct dma_async_tx_descriptor *tx)\n{\n\treturn container_of(tx, struct sun6i_desc, vd.tx);\n}\n\nstatic inline void sun6i_dma_dump_com_regs(struct sun6i_dma_dev *sdev)\n{\n\tdev_dbg(sdev->slave.dev, \"Common register:\\n\"\n\t\t\"\\tmask0(%04x): 0x%08x\\n\"\n\t\t\"\\tmask1(%04x): 0x%08x\\n\"\n\t\t\"\\tpend0(%04x): 0x%08x\\n\"\n\t\t\"\\tpend1(%04x): 0x%08x\\n\"\n\t\t\"\\tstats(%04x): 0x%08x\\n\",\n\t\tDMA_IRQ_EN(0), readl(sdev->base + DMA_IRQ_EN(0)),\n\t\tDMA_IRQ_EN(1), readl(sdev->base + DMA_IRQ_EN(1)),\n\t\tDMA_IRQ_STAT(0), readl(sdev->base + DMA_IRQ_STAT(0)),\n\t\tDMA_IRQ_STAT(1), readl(sdev->base + DMA_IRQ_STAT(1)),\n\t\tDMA_STAT, readl(sdev->base + DMA_STAT));\n}\n\nstatic inline void sun6i_dma_dump_chan_regs(struct sun6i_dma_dev *sdev,\n\t\t\t\t\t    struct sun6i_pchan *pchan)\n{\n\tdev_dbg(sdev->slave.dev, \"Chan %d reg:\\n\"\n\t\t\"\\t___en(%04x): \\t0x%08x\\n\"\n\t\t\"\\tpause(%04x): \\t0x%08x\\n\"\n\t\t\"\\tstart(%04x): \\t0x%08x\\n\"\n\t\t\"\\t__cfg(%04x): \\t0x%08x\\n\"\n\t\t\"\\t__src(%04x): \\t0x%08x\\n\"\n\t\t\"\\t__dst(%04x): \\t0x%08x\\n\"\n\t\t\"\\tcount(%04x): \\t0x%08x\\n\"\n\t\t\"\\t_para(%04x): \\t0x%08x\\n\\n\",\n\t\tpchan->idx,\n\t\tDMA_CHAN_ENABLE,\n\t\treadl(pchan->base + DMA_CHAN_ENABLE),\n\t\tDMA_CHAN_PAUSE,\n\t\treadl(pchan->base + DMA_CHAN_PAUSE),\n\t\tDMA_CHAN_LLI_ADDR,\n\t\treadl(pchan->base + DMA_CHAN_LLI_ADDR),\n\t\tDMA_CHAN_CUR_CFG,\n\t\treadl(pchan->base + DMA_CHAN_CUR_CFG),\n\t\tDMA_CHAN_CUR_SRC,\n\t\treadl(pchan->base + DMA_CHAN_CUR_SRC),\n\t\tDMA_CHAN_CUR_DST,\n\t\treadl(pchan->base + DMA_CHAN_CUR_DST),\n\t\tDMA_CHAN_CUR_CNT,\n\t\treadl(pchan->base + DMA_CHAN_CUR_CNT),\n\t\tDMA_CHAN_CUR_PARA,\n\t\treadl(pchan->base + DMA_CHAN_CUR_PARA));\n}\n\nstatic inline s8 convert_burst(u32 maxburst)\n{\n\tswitch (maxburst) {\n\tcase 1:\n\t\treturn 0;\n\tcase 4:\n\t\treturn 1;\n\tcase 8:\n\t\treturn 2;\n\tcase 16:\n\t\treturn 3;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline s8 convert_buswidth(enum dma_slave_buswidth addr_width)\n{\n\treturn ilog2(addr_width);\n}\n\nstatic void sun6i_enable_clock_autogate_a23(struct sun6i_dma_dev *sdev)\n{\n\twritel(SUN8I_DMA_GATE_ENABLE, sdev->base + SUN8I_DMA_GATE);\n}\n\nstatic void sun6i_enable_clock_autogate_h3(struct sun6i_dma_dev *sdev)\n{\n\twritel(SUNXI_H3_DMA_GATE_ENABLE, sdev->base + SUNXI_H3_DMA_GATE);\n}\n\nstatic void sun6i_set_burst_length_a31(u32 *p_cfg, s8 src_burst, s8 dst_burst)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_BURST_A31(src_burst) |\n\t\t  DMA_CHAN_CFG_DST_BURST_A31(dst_burst);\n}\n\nstatic void sun6i_set_burst_length_h3(u32 *p_cfg, s8 src_burst, s8 dst_burst)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_BURST_H3(src_burst) |\n\t\t  DMA_CHAN_CFG_DST_BURST_H3(dst_burst);\n}\n\nstatic void sun6i_set_drq_a31(u32 *p_cfg, s8 src_drq, s8 dst_drq)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_DRQ_A31(src_drq) |\n\t\t  DMA_CHAN_CFG_DST_DRQ_A31(dst_drq);\n}\n\nstatic void sun6i_set_drq_h6(u32 *p_cfg, s8 src_drq, s8 dst_drq)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_DRQ_H6(src_drq) |\n\t\t  DMA_CHAN_CFG_DST_DRQ_H6(dst_drq);\n}\n\nstatic void sun6i_set_mode_a31(u32 *p_cfg, s8 src_mode, s8 dst_mode)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_MODE_A31(src_mode) |\n\t\t  DMA_CHAN_CFG_DST_MODE_A31(dst_mode);\n}\n\nstatic void sun6i_set_mode_h6(u32 *p_cfg, s8 src_mode, s8 dst_mode)\n{\n\t*p_cfg |= DMA_CHAN_CFG_SRC_MODE_H6(src_mode) |\n\t\t  DMA_CHAN_CFG_DST_MODE_H6(dst_mode);\n}\n\nstatic size_t sun6i_get_chan_size(struct sun6i_pchan *pchan)\n{\n\tstruct sun6i_desc *txd = pchan->desc;\n\tstruct sun6i_dma_lli *lli;\n\tsize_t bytes;\n\tdma_addr_t pos;\n\n\tpos = readl(pchan->base + DMA_CHAN_LLI_ADDR);\n\tbytes = readl(pchan->base + DMA_CHAN_CUR_CNT);\n\n\tif (pos == LLI_LAST_ITEM)\n\t\treturn bytes;\n\n\tfor (lli = txd->v_lli; lli; lli = lli->v_lli_next) {\n\t\tif (lli->p_lli_next == pos) {\n\t\t\tfor (lli = lli->v_lli_next; lli; lli = lli->v_lli_next)\n\t\t\t\tbytes += lli->len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bytes;\n}\n\nstatic void *sun6i_dma_lli_add(struct sun6i_dma_lli *prev,\n\t\t\t       struct sun6i_dma_lli *next,\n\t\t\t       dma_addr_t next_phy,\n\t\t\t       struct sun6i_desc *txd)\n{\n\tif ((!prev && !txd) || !next)\n\t\treturn NULL;\n\n\tif (!prev) {\n\t\ttxd->p_lli = next_phy;\n\t\ttxd->v_lli = next;\n\t} else {\n\t\tprev->p_lli_next = next_phy;\n\t\tprev->v_lli_next = next;\n\t}\n\n\tnext->p_lli_next = LLI_LAST_ITEM;\n\tnext->v_lli_next = NULL;\n\n\treturn next;\n}\n\nstatic inline void sun6i_dma_dump_lli(struct sun6i_vchan *vchan,\n\t\t\t\t      struct sun6i_dma_lli *v_lli,\n\t\t\t\t      dma_addr_t p_lli)\n{\n\tdev_dbg(chan2dev(&vchan->vc.chan),\n\t\t\"\\n\\tdesc:\\tp - %pad v - 0x%p\\n\"\n\t\t\"\\t\\tc - 0x%08x s - 0x%08x d - 0x%08x\\n\"\n\t\t\"\\t\\tl - 0x%08x p - 0x%08x n - 0x%08x\\n\",\n\t\t&p_lli, v_lli,\n\t\tv_lli->cfg, v_lli->src, v_lli->dst,\n\t\tv_lli->len, v_lli->para, v_lli->p_lli_next);\n}\n\nstatic void sun6i_dma_free_desc(struct virt_dma_desc *vd)\n{\n\tstruct sun6i_desc *txd = to_sun6i_desc(&vd->tx);\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(vd->tx.chan->device);\n\tstruct sun6i_dma_lli *v_lli, *v_next;\n\tdma_addr_t p_lli, p_next;\n\n\tif (unlikely(!txd))\n\t\treturn;\n\n\tp_lli = txd->p_lli;\n\tv_lli = txd->v_lli;\n\n\twhile (v_lli) {\n\t\tv_next = v_lli->v_lli_next;\n\t\tp_next = v_lli->p_lli_next;\n\n\t\tdma_pool_free(sdev->pool, v_lli, p_lli);\n\n\t\tv_lli = v_next;\n\t\tp_lli = p_next;\n\t}\n\n\tkfree(txd);\n}\n\nstatic int sun6i_dma_start_desc(struct sun6i_vchan *vchan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(vchan->vc.chan.device);\n\tstruct virt_dma_desc *desc = vchan_next_desc(&vchan->vc);\n\tstruct sun6i_pchan *pchan = vchan->phy;\n\tu32 irq_val, irq_reg, irq_offset;\n\n\tif (!pchan)\n\t\treturn -EAGAIN;\n\n\tif (!desc) {\n\t\tpchan->desc = NULL;\n\t\tpchan->done = NULL;\n\t\treturn -EAGAIN;\n\t}\n\n\tlist_del(&desc->node);\n\n\tpchan->desc = to_sun6i_desc(&desc->tx);\n\tpchan->done = NULL;\n\n\tsun6i_dma_dump_lli(vchan, pchan->desc->v_lli, pchan->desc->p_lli);\n\n\tirq_reg = pchan->idx / DMA_IRQ_CHAN_NR;\n\tirq_offset = pchan->idx % DMA_IRQ_CHAN_NR;\n\n\tvchan->irq_type = vchan->cyclic ? DMA_IRQ_PKG : DMA_IRQ_QUEUE;\n\n\tirq_val = readl(sdev->base + DMA_IRQ_EN(irq_reg));\n\tirq_val &= ~((DMA_IRQ_HALF | DMA_IRQ_PKG | DMA_IRQ_QUEUE) <<\n\t\t\t(irq_offset * DMA_IRQ_CHAN_WIDTH));\n\tirq_val |= vchan->irq_type << (irq_offset * DMA_IRQ_CHAN_WIDTH);\n\twritel(irq_val, sdev->base + DMA_IRQ_EN(irq_reg));\n\n\twritel(pchan->desc->p_lli, pchan->base + DMA_CHAN_LLI_ADDR);\n\twritel(DMA_CHAN_ENABLE_START, pchan->base + DMA_CHAN_ENABLE);\n\n\tsun6i_dma_dump_com_regs(sdev);\n\tsun6i_dma_dump_chan_regs(sdev, pchan);\n\n\treturn 0;\n}\n\nstatic void sun6i_dma_tasklet(struct tasklet_struct *t)\n{\n\tstruct sun6i_dma_dev *sdev = from_tasklet(sdev, t, task);\n\tstruct sun6i_vchan *vchan;\n\tstruct sun6i_pchan *pchan;\n\tunsigned int pchan_alloc = 0;\n\tunsigned int pchan_idx;\n\n\tlist_for_each_entry(vchan, &sdev->slave.channels, vc.chan.device_node) {\n\t\tspin_lock_irq(&vchan->vc.lock);\n\n\t\tpchan = vchan->phy;\n\n\t\tif (pchan && pchan->done) {\n\t\t\tif (sun6i_dma_start_desc(vchan)) {\n\t\t\t\t \n\t\t\t\tdev_dbg(sdev->slave.dev, \"pchan %u: free\\n\",\n\t\t\t\t\tpchan->idx);\n\n\t\t\t\t \n\t\t\t\tvchan->phy = NULL;\n\t\t\t\tpchan->vchan = NULL;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&vchan->vc.lock);\n\t}\n\n\tspin_lock_irq(&sdev->lock);\n\tfor (pchan_idx = 0; pchan_idx < sdev->num_pchans; pchan_idx++) {\n\t\tpchan = &sdev->pchans[pchan_idx];\n\n\t\tif (pchan->vchan || list_empty(&sdev->pending))\n\t\t\tcontinue;\n\n\t\tvchan = list_first_entry(&sdev->pending,\n\t\t\t\t\t struct sun6i_vchan, node);\n\n\t\t \n\t\tlist_del_init(&vchan->node);\n\t\tpchan_alloc |= BIT(pchan_idx);\n\n\t\t \n\t\tpchan->vchan = vchan;\n\t\tvchan->phy = pchan;\n\t\tdev_dbg(sdev->slave.dev, \"pchan %u: alloc vchan %p\\n\",\n\t\t\tpchan->idx, &vchan->vc);\n\t}\n\tspin_unlock_irq(&sdev->lock);\n\n\tfor (pchan_idx = 0; pchan_idx < sdev->num_pchans; pchan_idx++) {\n\t\tif (!(pchan_alloc & BIT(pchan_idx)))\n\t\t\tcontinue;\n\n\t\tpchan = sdev->pchans + pchan_idx;\n\t\tvchan = pchan->vchan;\n\t\tif (vchan) {\n\t\t\tspin_lock_irq(&vchan->vc.lock);\n\t\t\tsun6i_dma_start_desc(vchan);\n\t\t\tspin_unlock_irq(&vchan->vc.lock);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t sun6i_dma_interrupt(int irq, void *dev_id)\n{\n\tstruct sun6i_dma_dev *sdev = dev_id;\n\tstruct sun6i_vchan *vchan;\n\tstruct sun6i_pchan *pchan;\n\tint i, j, ret = IRQ_NONE;\n\tu32 status;\n\n\tfor (i = 0; i < sdev->num_pchans / DMA_IRQ_CHAN_NR; i++) {\n\t\tstatus = readl(sdev->base + DMA_IRQ_STAT(i));\n\t\tif (!status)\n\t\t\tcontinue;\n\n\t\tdev_dbg(sdev->slave.dev, \"DMA irq status %s: 0x%x\\n\",\n\t\t\ti ? \"high\" : \"low\", status);\n\n\t\twritel(status, sdev->base + DMA_IRQ_STAT(i));\n\n\t\tfor (j = 0; (j < DMA_IRQ_CHAN_NR) && status; j++) {\n\t\t\tpchan = sdev->pchans + j;\n\t\t\tvchan = pchan->vchan;\n\t\t\tif (vchan && (status & vchan->irq_type)) {\n\t\t\t\tif (vchan->cyclic) {\n\t\t\t\t\tvchan_cyclic_callback(&pchan->desc->vd);\n\t\t\t\t} else {\n\t\t\t\t\tspin_lock(&vchan->vc.lock);\n\t\t\t\t\tvchan_cookie_complete(&pchan->desc->vd);\n\t\t\t\t\tpchan->done = pchan->desc;\n\t\t\t\t\tspin_unlock(&vchan->vc.lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatus = status >> DMA_IRQ_CHAN_WIDTH;\n\t\t}\n\n\t\tif (!atomic_read(&sdev->tasklet_shutdown))\n\t\t\ttasklet_schedule(&sdev->task);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_config(struct sun6i_dma_dev *sdev,\n\t\t\tstruct dma_slave_config *sconfig,\n\t\t\tenum dma_transfer_direction direction,\n\t\t\tu32 *p_cfg)\n{\n\tenum dma_slave_buswidth src_addr_width, dst_addr_width;\n\tu32 src_maxburst, dst_maxburst;\n\ts8 src_width, dst_width, src_burst, dst_burst;\n\n\tsrc_addr_width = sconfig->src_addr_width;\n\tdst_addr_width = sconfig->dst_addr_width;\n\tsrc_maxburst = sconfig->src_maxburst;\n\tdst_maxburst = sconfig->dst_maxburst;\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tif (src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tsrc_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tsrc_maxburst = src_maxburst ? src_maxburst : 8;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tif (dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\n\t\t\tdst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdst_maxburst = dst_maxburst ? dst_maxburst : 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(BIT(src_addr_width) & sdev->slave.src_addr_widths))\n\t\treturn -EINVAL;\n\tif (!(BIT(dst_addr_width) & sdev->slave.dst_addr_widths))\n\t\treturn -EINVAL;\n\tif (!(BIT(src_maxburst) & sdev->cfg->src_burst_lengths))\n\t\treturn -EINVAL;\n\tif (!(BIT(dst_maxburst) & sdev->cfg->dst_burst_lengths))\n\t\treturn -EINVAL;\n\n\tsrc_width = convert_buswidth(src_addr_width);\n\tdst_width = convert_buswidth(dst_addr_width);\n\tdst_burst = convert_burst(dst_maxburst);\n\tsrc_burst = convert_burst(src_maxburst);\n\n\t*p_cfg = DMA_CHAN_CFG_SRC_WIDTH(src_width) |\n\t\tDMA_CHAN_CFG_DST_WIDTH(dst_width);\n\n\tsdev->cfg->set_burst_length(p_cfg, src_burst, dst_burst);\n\n\treturn 0;\n}\n\nstatic inline void sun6i_dma_set_addr(struct sun6i_dma_dev *sdev,\n\t\t\t\t      struct sun6i_dma_lli *v_lli,\n\t\t\t\t      dma_addr_t src, dma_addr_t dst)\n{\n\tv_lli->src = lower_32_bits(src);\n\tv_lli->dst = lower_32_bits(dst);\n\n\tif (sdev->cfg->has_high_addr)\n\t\tv_lli->para |= SRC_HIGH_ADDR(upper_32_bits(src)) |\n\t\t\t       DST_HIGH_ADDR(upper_32_bits(dst));\n}\n\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_dma_memcpy(\n\t\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\n\t\tsize_t len, unsigned long flags)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct sun6i_dma_lli *v_lli;\n\tstruct sun6i_desc *txd;\n\tdma_addr_t p_lli;\n\ts8 burst, width;\n\n\tdev_dbg(chan2dev(chan),\n\t\t\"%s; chan: %d, dest: %pad, src: %pad, len: %zu. flags: 0x%08lx\\n\",\n\t\t__func__, vchan->vc.chan.chan_id, &dest, &src, len, flags);\n\n\tif (!len)\n\t\treturn NULL;\n\n\ttxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\n\tif (!txd)\n\t\treturn NULL;\n\n\tv_lli = dma_pool_alloc(sdev->pool, GFP_DMA32 | GFP_NOWAIT, &p_lli);\n\tif (!v_lli) {\n\t\tdev_err(sdev->slave.dev, \"Failed to alloc lli memory\\n\");\n\t\tgoto err_txd_free;\n\t}\n\n\tv_lli->len = len;\n\tv_lli->para = NORMAL_WAIT;\n\tsun6i_dma_set_addr(sdev, v_lli, src, dest);\n\n\tburst = convert_burst(8);\n\twidth = convert_buswidth(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tv_lli->cfg = DMA_CHAN_CFG_SRC_WIDTH(width) |\n\t\tDMA_CHAN_CFG_DST_WIDTH(width);\n\n\tsdev->cfg->set_burst_length(&v_lli->cfg, burst, burst);\n\tsdev->cfg->set_drq(&v_lli->cfg, DRQ_SDRAM, DRQ_SDRAM);\n\tsdev->cfg->set_mode(&v_lli->cfg, LINEAR_MODE, LINEAR_MODE);\n\n\tsun6i_dma_lli_add(NULL, v_lli, p_lli, txd);\n\n\tsun6i_dma_dump_lli(vchan, v_lli, p_lli);\n\n\treturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\n\nerr_txd_free:\n\tkfree(txd);\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_slave_sg(\n\t\tstruct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction dir,\n\t\tunsigned long flags, void *context)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct dma_slave_config *sconfig = &vchan->cfg;\n\tstruct sun6i_dma_lli *v_lli, *prev = NULL;\n\tstruct sun6i_desc *txd;\n\tstruct scatterlist *sg;\n\tdma_addr_t p_lli;\n\tu32 lli_cfg;\n\tint i, ret;\n\n\tif (!sgl)\n\t\treturn NULL;\n\n\tret = set_config(sdev, sconfig, dir, &lli_cfg);\n\tif (ret) {\n\t\tdev_err(chan2dev(chan), \"Invalid DMA configuration\\n\");\n\t\treturn NULL;\n\t}\n\n\ttxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\n\tif (!txd)\n\t\treturn NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tv_lli = dma_pool_alloc(sdev->pool, GFP_DMA32 | GFP_NOWAIT, &p_lli);\n\t\tif (!v_lli)\n\t\t\tgoto err_lli_free;\n\n\t\tv_lli->len = sg_dma_len(sg);\n\t\tv_lli->para = NORMAL_WAIT;\n\n\t\tif (dir == DMA_MEM_TO_DEV) {\n\t\t\tsun6i_dma_set_addr(sdev, v_lli,\n\t\t\t\t\t   sg_dma_address(sg),\n\t\t\t\t\t   sconfig->dst_addr);\n\t\t\tv_lli->cfg = lli_cfg;\n\t\t\tsdev->cfg->set_drq(&v_lli->cfg, DRQ_SDRAM, vchan->port);\n\t\t\tsdev->cfg->set_mode(&v_lli->cfg, LINEAR_MODE, IO_MODE);\n\n\t\t\tdev_dbg(chan2dev(chan),\n\t\t\t\t\"%s; chan: %d, dest: %pad, src: %pad, len: %u. flags: 0x%08lx\\n\",\n\t\t\t\t__func__, vchan->vc.chan.chan_id,\n\t\t\t\t&sconfig->dst_addr, &sg_dma_address(sg),\n\t\t\t\tsg_dma_len(sg), flags);\n\n\t\t} else {\n\t\t\tsun6i_dma_set_addr(sdev, v_lli,\n\t\t\t\t\t   sconfig->src_addr,\n\t\t\t\t\t   sg_dma_address(sg));\n\t\t\tv_lli->cfg = lli_cfg;\n\t\t\tsdev->cfg->set_drq(&v_lli->cfg, vchan->port, DRQ_SDRAM);\n\t\t\tsdev->cfg->set_mode(&v_lli->cfg, IO_MODE, LINEAR_MODE);\n\n\t\t\tdev_dbg(chan2dev(chan),\n\t\t\t\t\"%s; chan: %d, dest: %pad, src: %pad, len: %u. flags: 0x%08lx\\n\",\n\t\t\t\t__func__, vchan->vc.chan.chan_id,\n\t\t\t\t&sg_dma_address(sg), &sconfig->src_addr,\n\t\t\t\tsg_dma_len(sg), flags);\n\t\t}\n\n\t\tprev = sun6i_dma_lli_add(prev, v_lli, p_lli, txd);\n\t}\n\n\tdev_dbg(chan2dev(chan), \"First: %pad\\n\", &txd->p_lli);\n\tfor (p_lli = txd->p_lli, v_lli = txd->v_lli; v_lli;\n\t     p_lli = v_lli->p_lli_next, v_lli = v_lli->v_lli_next)\n\t\tsun6i_dma_dump_lli(vchan, v_lli, p_lli);\n\n\treturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\n\nerr_lli_free:\n\tfor (p_lli = txd->p_lli, v_lli = txd->v_lli; v_lli;\n\t     p_lli = v_lli->p_lli_next, v_lli = v_lli->v_lli_next)\n\t\tdma_pool_free(sdev->pool, v_lli, p_lli);\n\tkfree(txd);\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_dma_cyclic(\n\t\t\t\t\tstruct dma_chan *chan,\n\t\t\t\t\tdma_addr_t buf_addr,\n\t\t\t\t\tsize_t buf_len,\n\t\t\t\t\tsize_t period_len,\n\t\t\t\t\tenum dma_transfer_direction dir,\n\t\t\t\t\tunsigned long flags)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct dma_slave_config *sconfig = &vchan->cfg;\n\tstruct sun6i_dma_lli *v_lli, *prev = NULL;\n\tstruct sun6i_desc *txd;\n\tdma_addr_t p_lli;\n\tu32 lli_cfg;\n\tunsigned int i, periods = buf_len / period_len;\n\tint ret;\n\n\tret = set_config(sdev, sconfig, dir, &lli_cfg);\n\tif (ret) {\n\t\tdev_err(chan2dev(chan), \"Invalid DMA configuration\\n\");\n\t\treturn NULL;\n\t}\n\n\ttxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\n\tif (!txd)\n\t\treturn NULL;\n\n\tfor (i = 0; i < periods; i++) {\n\t\tv_lli = dma_pool_alloc(sdev->pool, GFP_DMA32 | GFP_NOWAIT, &p_lli);\n\t\tif (!v_lli) {\n\t\t\tdev_err(sdev->slave.dev, \"Failed to alloc lli memory\\n\");\n\t\t\tgoto err_lli_free;\n\t\t}\n\n\t\tv_lli->len = period_len;\n\t\tv_lli->para = NORMAL_WAIT;\n\n\t\tif (dir == DMA_MEM_TO_DEV) {\n\t\t\tsun6i_dma_set_addr(sdev, v_lli,\n\t\t\t\t\t   buf_addr + period_len * i,\n\t\t\t\t\t   sconfig->dst_addr);\n\t\t\tv_lli->cfg = lli_cfg;\n\t\t\tsdev->cfg->set_drq(&v_lli->cfg, DRQ_SDRAM, vchan->port);\n\t\t\tsdev->cfg->set_mode(&v_lli->cfg, LINEAR_MODE, IO_MODE);\n\t\t} else {\n\t\t\tsun6i_dma_set_addr(sdev, v_lli,\n\t\t\t\t\t   sconfig->src_addr,\n\t\t\t\t\t   buf_addr + period_len * i);\n\t\t\tv_lli->cfg = lli_cfg;\n\t\t\tsdev->cfg->set_drq(&v_lli->cfg, vchan->port, DRQ_SDRAM);\n\t\t\tsdev->cfg->set_mode(&v_lli->cfg, IO_MODE, LINEAR_MODE);\n\t\t}\n\n\t\tprev = sun6i_dma_lli_add(prev, v_lli, p_lli, txd);\n\t}\n\n\tprev->p_lli_next = txd->p_lli;\t\t \n\n\tvchan->cyclic = true;\n\n\treturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\n\nerr_lli_free:\n\tfor (p_lli = txd->p_lli, v_lli = txd->v_lli; v_lli;\n\t     p_lli = v_lli->p_lli_next, v_lli = v_lli->v_lli_next)\n\t\tdma_pool_free(sdev->pool, v_lli, p_lli);\n\tkfree(txd);\n\treturn NULL;\n}\n\nstatic int sun6i_dma_config(struct dma_chan *chan,\n\t\t\t    struct dma_slave_config *config)\n{\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\n\tmemcpy(&vchan->cfg, config, sizeof(*config));\n\n\treturn 0;\n}\n\nstatic int sun6i_dma_pause(struct dma_chan *chan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct sun6i_pchan *pchan = vchan->phy;\n\n\tdev_dbg(chan2dev(chan), \"vchan %p: pause\\n\", &vchan->vc);\n\n\tif (pchan) {\n\t\twritel(DMA_CHAN_PAUSE_PAUSE,\n\t\t       pchan->base + DMA_CHAN_PAUSE);\n\t} else {\n\t\tspin_lock(&sdev->lock);\n\t\tlist_del_init(&vchan->node);\n\t\tspin_unlock(&sdev->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun6i_dma_resume(struct dma_chan *chan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct sun6i_pchan *pchan = vchan->phy;\n\tunsigned long flags;\n\n\tdev_dbg(chan2dev(chan), \"vchan %p: resume\\n\", &vchan->vc);\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\n\tif (pchan) {\n\t\twritel(DMA_CHAN_PAUSE_RESUME,\n\t\t       pchan->base + DMA_CHAN_PAUSE);\n\t} else if (!list_empty(&vchan->vc.desc_issued)) {\n\t\tspin_lock(&sdev->lock);\n\t\tlist_add_tail(&vchan->node, &sdev->pending);\n\t\tspin_unlock(&sdev->lock);\n\t}\n\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic int sun6i_dma_terminate_all(struct dma_chan *chan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct sun6i_pchan *pchan = vchan->phy;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock(&sdev->lock);\n\tlist_del_init(&vchan->node);\n\tspin_unlock(&sdev->lock);\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\n\tif (vchan->cyclic) {\n\t\tvchan->cyclic = false;\n\t\tif (pchan && pchan->desc) {\n\t\t\tstruct virt_dma_desc *vd = &pchan->desc->vd;\n\t\t\tstruct virt_dma_chan *vc = &vchan->vc;\n\n\t\t\tlist_add_tail(&vd->node, &vc->desc_completed);\n\t\t}\n\t}\n\n\tvchan_get_all_descriptors(&vchan->vc, &head);\n\n\tif (pchan) {\n\t\twritel(DMA_CHAN_ENABLE_STOP, pchan->base + DMA_CHAN_ENABLE);\n\t\twritel(DMA_CHAN_PAUSE_RESUME, pchan->base + DMA_CHAN_PAUSE);\n\n\t\tvchan->phy = NULL;\n\t\tpchan->vchan = NULL;\n\t\tpchan->desc = NULL;\n\t\tpchan->done = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\tvchan_dma_desc_free_list(&vchan->vc, &head);\n\n\treturn 0;\n}\n\nstatic enum dma_status sun6i_dma_tx_status(struct dma_chan *chan,\n\t\t\t\t\t   dma_cookie_t cookie,\n\t\t\t\t\t   struct dma_tx_state *state)\n{\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tstruct sun6i_pchan *pchan = vchan->phy;\n\tstruct sun6i_dma_lli *lli;\n\tstruct virt_dma_desc *vd;\n\tstruct sun6i_desc *txd;\n\tenum dma_status ret;\n\tunsigned long flags;\n\tsize_t bytes = 0;\n\n\tret = dma_cookie_status(chan, cookie, state);\n\tif (ret == DMA_COMPLETE || !state)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\n\tvd = vchan_find_desc(&vchan->vc, cookie);\n\ttxd = to_sun6i_desc(&vd->tx);\n\n\tif (vd) {\n\t\tfor (lli = txd->v_lli; lli != NULL; lli = lli->v_lli_next)\n\t\t\tbytes += lli->len;\n\t} else if (!pchan || !pchan->desc) {\n\t\tbytes = 0;\n\t} else {\n\t\tbytes = sun6i_get_chan_size(pchan);\n\t}\n\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n\n\tdma_set_residue(state, bytes);\n\n\treturn ret;\n}\n\nstatic void sun6i_dma_issue_pending(struct dma_chan *chan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vchan->vc.lock, flags);\n\n\tif (vchan_issue_pending(&vchan->vc)) {\n\t\tspin_lock(&sdev->lock);\n\n\t\tif (!vchan->phy && list_empty(&vchan->node)) {\n\t\t\tlist_add_tail(&vchan->node, &sdev->pending);\n\t\t\ttasklet_schedule(&sdev->task);\n\t\t\tdev_dbg(chan2dev(chan), \"vchan %p: issued\\n\",\n\t\t\t\t&vchan->vc);\n\t\t}\n\n\t\tspin_unlock(&sdev->lock);\n\t} else {\n\t\tdev_dbg(chan2dev(chan), \"vchan %p: nothing to issue\\n\",\n\t\t\t&vchan->vc);\n\t}\n\n\tspin_unlock_irqrestore(&vchan->vc.lock, flags);\n}\n\nstatic void sun6i_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\n\tstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sdev->lock, flags);\n\tlist_del_init(&vchan->node);\n\tspin_unlock_irqrestore(&sdev->lock, flags);\n\n\tvchan_free_chan_resources(&vchan->vc);\n}\n\nstatic struct dma_chan *sun6i_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct sun6i_dma_dev *sdev = ofdma->of_dma_data;\n\tstruct sun6i_vchan *vchan;\n\tstruct dma_chan *chan;\n\tu8 port = dma_spec->args[0];\n\n\tif (port > sdev->max_request)\n\t\treturn NULL;\n\n\tchan = dma_get_any_slave_channel(&sdev->slave);\n\tif (!chan)\n\t\treturn NULL;\n\n\tvchan = to_sun6i_vchan(chan);\n\tvchan->port = port;\n\n\treturn chan;\n}\n\nstatic inline void sun6i_kill_tasklet(struct sun6i_dma_dev *sdev)\n{\n\t \n\twritel(0, sdev->base + DMA_IRQ_EN(0));\n\twritel(0, sdev->base + DMA_IRQ_EN(1));\n\n\t \n\tatomic_inc(&sdev->tasklet_shutdown);\n\n\t \n\tdevm_free_irq(sdev->slave.dev, sdev->irq, sdev);\n\n\t \n\ttasklet_kill(&sdev->task);\n}\n\nstatic inline void sun6i_dma_free(struct sun6i_dma_dev *sdev)\n{\n\tint i;\n\n\tfor (i = 0; i < sdev->num_vchans; i++) {\n\t\tstruct sun6i_vchan *vchan = &sdev->vchans[i];\n\n\t\tlist_del(&vchan->vc.chan.device_node);\n\t\ttasklet_kill(&vchan->vc.task);\n\t}\n}\n\n \n\nstatic struct sun6i_dma_config sun6i_a31_dma_cfg = {\n\t.nr_max_channels = 16,\n\t.nr_max_requests = 30,\n\t.nr_max_vchans   = 53,\n\t.set_burst_length = sun6i_set_burst_length_a31,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(8),\n\t.dst_burst_lengths = BIT(1) | BIT(8),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n};\n\n \n\nstatic struct sun6i_dma_config sun8i_a23_dma_cfg = {\n\t.nr_max_channels = 8,\n\t.nr_max_requests = 24,\n\t.nr_max_vchans   = 37,\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_a23,\n\t.set_burst_length = sun6i_set_burst_length_a31,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(8),\n\t.dst_burst_lengths = BIT(1) | BIT(8),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n};\n\nstatic struct sun6i_dma_config sun8i_a83t_dma_cfg = {\n\t.nr_max_channels = 8,\n\t.nr_max_requests = 28,\n\t.nr_max_vchans   = 39,\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_a23,\n\t.set_burst_length = sun6i_set_burst_length_a31,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(8),\n\t.dst_burst_lengths = BIT(1) | BIT(8),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n};\n\n \n\nstatic struct sun6i_dma_config sun8i_h3_dma_cfg = {\n\t.nr_max_channels = 12,\n\t.nr_max_requests = 27,\n\t.nr_max_vchans   = 34,\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_h3,\n\t.set_burst_length = sun6i_set_burst_length_h3,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n};\n\n \nstatic struct sun6i_dma_config sun50i_a64_dma_cfg = {\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_h3,\n\t.set_burst_length = sun6i_set_burst_length_h3,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n};\n\n \nstatic struct sun6i_dma_config sun50i_a100_dma_cfg = {\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_h3,\n\t.set_burst_length = sun6i_set_burst_length_h3,\n\t.set_drq          = sun6i_set_drq_h6,\n\t.set_mode         = sun6i_set_mode_h6,\n\t.src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.has_high_addr = true,\n\t.has_mbus_clk = true,\n};\n\n \nstatic struct sun6i_dma_config sun50i_h6_dma_cfg = {\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_h3,\n\t.set_burst_length = sun6i_set_burst_length_h3,\n\t.set_drq          = sun6i_set_drq_h6,\n\t.set_mode         = sun6i_set_mode_h6,\n\t.src_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.dst_burst_lengths = BIT(1) | BIT(4) | BIT(8) | BIT(16),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_8_BYTES),\n\t.has_mbus_clk = true,\n};\n\n \n\nstatic struct sun6i_dma_config sun8i_v3s_dma_cfg = {\n\t.nr_max_channels = 8,\n\t.nr_max_requests = 23,\n\t.nr_max_vchans   = 24,\n\t.clock_autogate_enable = sun6i_enable_clock_autogate_a23,\n\t.set_burst_length = sun6i_set_burst_length_a31,\n\t.set_drq          = sun6i_set_drq_a31,\n\t.set_mode         = sun6i_set_mode_a31,\n\t.src_burst_lengths = BIT(1) | BIT(8),\n\t.dst_burst_lengths = BIT(1) | BIT(8),\n\t.src_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n\t.dst_addr_widths   = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\n\t\t\t     BIT(DMA_SLAVE_BUSWIDTH_4_BYTES),\n};\n\nstatic const struct of_device_id sun6i_dma_match[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-dma\", .data = &sun6i_a31_dma_cfg },\n\t{ .compatible = \"allwinner,sun8i-a23-dma\", .data = &sun8i_a23_dma_cfg },\n\t{ .compatible = \"allwinner,sun8i-a83t-dma\", .data = &sun8i_a83t_dma_cfg },\n\t{ .compatible = \"allwinner,sun8i-h3-dma\", .data = &sun8i_h3_dma_cfg },\n\t{ .compatible = \"allwinner,sun8i-v3s-dma\", .data = &sun8i_v3s_dma_cfg },\n\t{ .compatible = \"allwinner,sun20i-d1-dma\", .data = &sun50i_a100_dma_cfg },\n\t{ .compatible = \"allwinner,sun50i-a64-dma\", .data = &sun50i_a64_dma_cfg },\n\t{ .compatible = \"allwinner,sun50i-a100-dma\", .data = &sun50i_a100_dma_cfg },\n\t{ .compatible = \"allwinner,sun50i-h6-dma\", .data = &sun50i_h6_dma_cfg },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun6i_dma_match);\n\nstatic int sun6i_dma_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sun6i_dma_dev *sdc;\n\tint ret, i;\n\n\tsdc = devm_kzalloc(&pdev->dev, sizeof(*sdc), GFP_KERNEL);\n\tif (!sdc)\n\t\treturn -ENOMEM;\n\n\tsdc->cfg = of_device_get_match_data(&pdev->dev);\n\tif (!sdc->cfg)\n\t\treturn -ENODEV;\n\n\tsdc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sdc->base))\n\t\treturn PTR_ERR(sdc->base);\n\n\tsdc->irq = platform_get_irq(pdev, 0);\n\tif (sdc->irq < 0)\n\t\treturn sdc->irq;\n\n\tsdc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sdc->clk)) {\n\t\tdev_err(&pdev->dev, \"No clock specified\\n\");\n\t\treturn PTR_ERR(sdc->clk);\n\t}\n\n\tif (sdc->cfg->has_mbus_clk) {\n\t\tsdc->clk_mbus = devm_clk_get(&pdev->dev, \"mbus\");\n\t\tif (IS_ERR(sdc->clk_mbus)) {\n\t\t\tdev_err(&pdev->dev, \"No mbus clock specified\\n\");\n\t\t\treturn PTR_ERR(sdc->clk_mbus);\n\t\t}\n\t}\n\n\tsdc->rstc = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(sdc->rstc)) {\n\t\tdev_err(&pdev->dev, \"No reset controller specified\\n\");\n\t\treturn PTR_ERR(sdc->rstc);\n\t}\n\n\tsdc->pool = dmam_pool_create(dev_name(&pdev->dev), &pdev->dev,\n\t\t\t\t     sizeof(struct sun6i_dma_lli), 4, 0);\n\tif (!sdc->pool) {\n\t\tdev_err(&pdev->dev, \"No memory for descriptors dma pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, sdc);\n\tINIT_LIST_HEAD(&sdc->pending);\n\tspin_lock_init(&sdc->lock);\n\n\tdma_set_max_seg_size(&pdev->dev, SZ_32M - 1);\n\n\tdma_cap_set(DMA_PRIVATE, sdc->slave.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, sdc->slave.cap_mask);\n\tdma_cap_set(DMA_SLAVE, sdc->slave.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, sdc->slave.cap_mask);\n\n\tINIT_LIST_HEAD(&sdc->slave.channels);\n\tsdc->slave.device_free_chan_resources\t= sun6i_dma_free_chan_resources;\n\tsdc->slave.device_tx_status\t\t= sun6i_dma_tx_status;\n\tsdc->slave.device_issue_pending\t\t= sun6i_dma_issue_pending;\n\tsdc->slave.device_prep_slave_sg\t\t= sun6i_dma_prep_slave_sg;\n\tsdc->slave.device_prep_dma_memcpy\t= sun6i_dma_prep_dma_memcpy;\n\tsdc->slave.device_prep_dma_cyclic\t= sun6i_dma_prep_dma_cyclic;\n\tsdc->slave.copy_align\t\t\t= DMAENGINE_ALIGN_4_BYTES;\n\tsdc->slave.device_config\t\t= sun6i_dma_config;\n\tsdc->slave.device_pause\t\t\t= sun6i_dma_pause;\n\tsdc->slave.device_resume\t\t= sun6i_dma_resume;\n\tsdc->slave.device_terminate_all\t\t= sun6i_dma_terminate_all;\n\tsdc->slave.src_addr_widths\t\t= sdc->cfg->src_addr_widths;\n\tsdc->slave.dst_addr_widths\t\t= sdc->cfg->dst_addr_widths;\n\tsdc->slave.directions\t\t\t= BIT(DMA_DEV_TO_MEM) |\n\t\t\t\t\t\t  BIT(DMA_MEM_TO_DEV);\n\tsdc->slave.residue_granularity\t\t= DMA_RESIDUE_GRANULARITY_BURST;\n\tsdc->slave.dev = &pdev->dev;\n\n\tsdc->num_pchans = sdc->cfg->nr_max_channels;\n\tsdc->num_vchans = sdc->cfg->nr_max_vchans;\n\tsdc->max_request = sdc->cfg->nr_max_requests;\n\n\tret = of_property_read_u32(np, \"dma-channels\", &sdc->num_pchans);\n\tif (ret && !sdc->num_pchans) {\n\t\tdev_err(&pdev->dev, \"Can't get dma-channels.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"dma-requests\", &sdc->max_request);\n\tif (ret && !sdc->max_request) {\n\t\tdev_info(&pdev->dev, \"Missing dma-requests, using %u.\\n\",\n\t\t\t DMA_CHAN_MAX_DRQ_A31);\n\t\tsdc->max_request = DMA_CHAN_MAX_DRQ_A31;\n\t}\n\n\t \n\tif (!sdc->num_vchans)\n\t\tsdc->num_vchans = 2 * (sdc->max_request + 1);\n\n\tsdc->pchans = devm_kcalloc(&pdev->dev, sdc->num_pchans,\n\t\t\t\t   sizeof(struct sun6i_pchan), GFP_KERNEL);\n\tif (!sdc->pchans)\n\t\treturn -ENOMEM;\n\n\tsdc->vchans = devm_kcalloc(&pdev->dev, sdc->num_vchans,\n\t\t\t\t   sizeof(struct sun6i_vchan), GFP_KERNEL);\n\tif (!sdc->vchans)\n\t\treturn -ENOMEM;\n\n\ttasklet_setup(&sdc->task, sun6i_dma_tasklet);\n\n\tfor (i = 0; i < sdc->num_pchans; i++) {\n\t\tstruct sun6i_pchan *pchan = &sdc->pchans[i];\n\n\t\tpchan->idx = i;\n\t\tpchan->base = sdc->base + 0x100 + i * 0x40;\n\t}\n\n\tfor (i = 0; i < sdc->num_vchans; i++) {\n\t\tstruct sun6i_vchan *vchan = &sdc->vchans[i];\n\n\t\tINIT_LIST_HEAD(&vchan->node);\n\t\tvchan->vc.desc_free = sun6i_dma_free_desc;\n\t\tvchan_init(&vchan->vc, &sdc->slave);\n\t}\n\n\tret = reset_control_deassert(sdc->rstc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't deassert the device from reset\\n\");\n\t\tgoto err_chan_free;\n\t}\n\n\tret = clk_prepare_enable(sdc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't enable the clock\\n\");\n\t\tgoto err_reset_assert;\n\t}\n\n\tif (sdc->cfg->has_mbus_clk) {\n\t\tret = clk_prepare_enable(sdc->clk_mbus);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't enable mbus clock\\n\");\n\t\t\tgoto err_clk_disable;\n\t\t}\n\t}\n\n\tret = devm_request_irq(&pdev->dev, sdc->irq, sun6i_dma_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), sdc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request IRQ\\n\");\n\t\tgoto err_mbus_clk_disable;\n\t}\n\n\tret = dma_async_device_register(&sdc->slave);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"Failed to register DMA engine device\\n\");\n\t\tgoto err_irq_disable;\n\t}\n\n\tret = of_dma_controller_register(pdev->dev.of_node, sun6i_dma_of_xlate,\n\t\t\t\t\t sdc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"of_dma_controller_register failed\\n\");\n\t\tgoto err_dma_unregister;\n\t}\n\n\tif (sdc->cfg->clock_autogate_enable)\n\t\tsdc->cfg->clock_autogate_enable(sdc);\n\n\treturn 0;\n\nerr_dma_unregister:\n\tdma_async_device_unregister(&sdc->slave);\nerr_irq_disable:\n\tsun6i_kill_tasklet(sdc);\nerr_mbus_clk_disable:\n\tclk_disable_unprepare(sdc->clk_mbus);\nerr_clk_disable:\n\tclk_disable_unprepare(sdc->clk);\nerr_reset_assert:\n\treset_control_assert(sdc->rstc);\nerr_chan_free:\n\tsun6i_dma_free(sdc);\n\treturn ret;\n}\n\nstatic int sun6i_dma_remove(struct platform_device *pdev)\n{\n\tstruct sun6i_dma_dev *sdc = platform_get_drvdata(pdev);\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&sdc->slave);\n\n\tsun6i_kill_tasklet(sdc);\n\n\tclk_disable_unprepare(sdc->clk_mbus);\n\tclk_disable_unprepare(sdc->clk);\n\treset_control_assert(sdc->rstc);\n\n\tsun6i_dma_free(sdc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sun6i_dma_driver = {\n\t.probe\t\t= sun6i_dma_probe,\n\t.remove\t\t= sun6i_dma_remove,\n\t.driver = {\n\t\t.name\t\t= \"sun6i-dma\",\n\t\t.of_match_table\t= sun6i_dma_match,\n\t},\n};\nmodule_platform_driver(sun6i_dma_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A31 DMA Controller Driver\");\nMODULE_AUTHOR(\"Sugar <shuge@allwinnertech.com>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}