{
  "module_name": "fsl_raid.c",
  "hash_id": "07df64167c2350c54e19941586c250d66af484fadc1aa9e6d4df8c04ee39b978",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/fsl_raid.c",
  "human_readable_source": " \n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include \"dmaengine.h\"\n#include \"fsl_raid.h\"\n\n#define FSL_RE_MAX_XOR_SRCS\t16\n#define FSL_RE_MAX_PQ_SRCS\t16\n#define FSL_RE_MIN_DESCS\t256\n#define FSL_RE_MAX_DESCS\t(4 * FSL_RE_MIN_DESCS)\n#define FSL_RE_FRAME_FORMAT\t0x1\n#define FSL_RE_MAX_DATA_LEN\t(1024*1024)\n\n#define to_fsl_re_dma_desc(tx) container_of(tx, struct fsl_re_desc, async_tx)\n\n \nstatic dma_cookie_t fsl_re_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct fsl_re_desc *desc;\n\tstruct fsl_re_chan *re_chan;\n\tdma_cookie_t cookie;\n\tunsigned long flags;\n\n\tdesc = to_fsl_re_dma_desc(tx);\n\tre_chan = container_of(tx->chan, struct fsl_re_chan, chan);\n\n\tspin_lock_irqsave(&re_chan->desc_lock, flags);\n\tcookie = dma_cookie_assign(tx);\n\tlist_add_tail(&desc->node, &re_chan->submit_q);\n\tspin_unlock_irqrestore(&re_chan->desc_lock, flags);\n\n\treturn cookie;\n}\n\n \nstatic void fsl_re_issue_pending(struct dma_chan *chan)\n{\n\tstruct fsl_re_chan *re_chan;\n\tint avail;\n\tstruct fsl_re_desc *desc, *_desc;\n\tunsigned long flags;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\n\tspin_lock_irqsave(&re_chan->desc_lock, flags);\n\tavail = FSL_RE_SLOT_AVAIL(\n\t\tin_be32(&re_chan->jrregs->inbring_slot_avail));\n\n\tlist_for_each_entry_safe(desc, _desc, &re_chan->submit_q, node) {\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tlist_move_tail(&desc->node, &re_chan->active_q);\n\n\t\tmemcpy(&re_chan->inb_ring_virt_addr[re_chan->inb_count],\n\t\t       &desc->hwdesc, sizeof(struct fsl_re_hw_desc));\n\n\t\tre_chan->inb_count = (re_chan->inb_count + 1) &\n\t\t\t\t\t\tFSL_RE_RING_SIZE_MASK;\n\t\tout_be32(&re_chan->jrregs->inbring_add_job, FSL_RE_ADD_JOB(1));\n\t\tavail--;\n\t}\n\tspin_unlock_irqrestore(&re_chan->desc_lock, flags);\n}\n\nstatic void fsl_re_desc_done(struct fsl_re_desc *desc)\n{\n\tdma_cookie_complete(&desc->async_tx);\n\tdma_descriptor_unmap(&desc->async_tx);\n\tdmaengine_desc_get_callback_invoke(&desc->async_tx, NULL);\n}\n\nstatic void fsl_re_cleanup_descs(struct fsl_re_chan *re_chan)\n{\n\tstruct fsl_re_desc *desc, *_desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&re_chan->desc_lock, flags);\n\tlist_for_each_entry_safe(desc, _desc, &re_chan->ack_q, node) {\n\t\tif (async_tx_test_ack(&desc->async_tx))\n\t\t\tlist_move_tail(&desc->node, &re_chan->free_q);\n\t}\n\tspin_unlock_irqrestore(&re_chan->desc_lock, flags);\n\n\tfsl_re_issue_pending(&re_chan->chan);\n}\n\nstatic void fsl_re_dequeue(struct tasklet_struct *t)\n{\n\tstruct fsl_re_chan *re_chan = from_tasklet(re_chan, t, irqtask);\n\tstruct fsl_re_desc *desc, *_desc;\n\tstruct fsl_re_hw_desc *hwdesc;\n\tunsigned long flags;\n\tunsigned int count, oub_count;\n\tint found;\n\n\tfsl_re_cleanup_descs(re_chan);\n\n\tspin_lock_irqsave(&re_chan->desc_lock, flags);\n\tcount =\tFSL_RE_SLOT_FULL(in_be32(&re_chan->jrregs->oubring_slot_full));\n\twhile (count--) {\n\t\tfound = 0;\n\t\thwdesc = &re_chan->oub_ring_virt_addr[re_chan->oub_count];\n\t\tlist_for_each_entry_safe(desc, _desc, &re_chan->active_q,\n\t\t\t\t\t node) {\n\t\t\t \n\t\t\tif (desc->hwdesc.lbea32 == hwdesc->lbea32 &&\n\t\t\t    desc->hwdesc.addr_low == hwdesc->addr_low) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tfsl_re_desc_done(desc);\n\t\t\tlist_move_tail(&desc->node, &re_chan->ack_q);\n\t\t} else {\n\t\t\tdev_err(re_chan->dev,\n\t\t\t\t\"found hwdesc not in sw queue, discard it\\n\");\n\t\t}\n\n\t\toub_count = (re_chan->oub_count + 1) & FSL_RE_RING_SIZE_MASK;\n\t\tre_chan->oub_count = oub_count;\n\n\t\tout_be32(&re_chan->jrregs->oubring_job_rmvd,\n\t\t\t FSL_RE_RMVD_JOB(1));\n\t}\n\tspin_unlock_irqrestore(&re_chan->desc_lock, flags);\n}\n\n \nstatic irqreturn_t fsl_re_isr(int irq, void *data)\n{\n\tstruct fsl_re_chan *re_chan;\n\tu32 irqstate, status;\n\n\tre_chan = dev_get_drvdata((struct device *)data);\n\n\tirqstate = in_be32(&re_chan->jrregs->jr_interrupt_status);\n\tif (!irqstate)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (irqstate & FSL_RE_ERROR) {\n\t\tstatus = in_be32(&re_chan->jrregs->jr_status);\n\t\tdev_err(re_chan->dev, \"chan error irqstate: %x, status: %x\\n\",\n\t\t\tirqstate, status);\n\t}\n\n\t \n\tout_be32(&re_chan->jrregs->jr_interrupt_status, FSL_RE_CLR_INTR);\n\n\ttasklet_schedule(&re_chan->irqtask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic enum dma_status fsl_re_tx_status(struct dma_chan *chan,\n\t\t\t\t\tdma_cookie_t cookie,\n\t\t\t\t\tstruct dma_tx_state *txstate)\n{\n\treturn dma_cookie_status(chan, cookie, txstate);\n}\n\nstatic void fill_cfd_frame(struct fsl_re_cmpnd_frame *cf, u8 index,\n\t\t\t   size_t length, dma_addr_t addr, bool final)\n{\n\tu32 efrl = length & FSL_RE_CF_LENGTH_MASK;\n\n\tefrl |= final << FSL_RE_CF_FINAL_SHIFT;\n\tcf[index].efrl32 = efrl;\n\tcf[index].addr_high = upper_32_bits(addr);\n\tcf[index].addr_low = lower_32_bits(addr);\n}\n\nstatic struct fsl_re_desc *fsl_re_init_desc(struct fsl_re_chan *re_chan,\n\t\t\t\t\t    struct fsl_re_desc *desc,\n\t\t\t\t\t    void *cf, dma_addr_t paddr)\n{\n\tdesc->re_chan = re_chan;\n\tdesc->async_tx.tx_submit = fsl_re_tx_submit;\n\tdma_async_tx_descriptor_init(&desc->async_tx, &re_chan->chan);\n\tINIT_LIST_HEAD(&desc->node);\n\n\tdesc->hwdesc.fmt32 = FSL_RE_FRAME_FORMAT << FSL_RE_HWDESC_FMT_SHIFT;\n\tdesc->hwdesc.lbea32 = upper_32_bits(paddr);\n\tdesc->hwdesc.addr_low = lower_32_bits(paddr);\n\tdesc->cf_addr = cf;\n\tdesc->cf_paddr = paddr;\n\n\tdesc->cdb_addr = (void *)(cf + FSL_RE_CF_DESC_SIZE);\n\tdesc->cdb_paddr = paddr + FSL_RE_CF_DESC_SIZE;\n\n\treturn desc;\n}\n\nstatic struct fsl_re_desc *fsl_re_chan_alloc_desc(struct fsl_re_chan *re_chan,\n\t\t\t\t\t\t  unsigned long flags)\n{\n\tstruct fsl_re_desc *desc = NULL;\n\tvoid *cf;\n\tdma_addr_t paddr;\n\tunsigned long lock_flag;\n\n\tfsl_re_cleanup_descs(re_chan);\n\n\tspin_lock_irqsave(&re_chan->desc_lock, lock_flag);\n\tif (!list_empty(&re_chan->free_q)) {\n\t\t \n\t\tdesc = list_first_entry(&re_chan->free_q,\n\t\t\t\t\tstruct fsl_re_desc, node);\n\t\tlist_del(&desc->node);\n\n\t\tdesc->async_tx.flags = flags;\n\t}\n\tspin_unlock_irqrestore(&re_chan->desc_lock, lock_flag);\n\n\tif (!desc) {\n\t\tdesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\n\t\tif (!desc)\n\t\t\treturn NULL;\n\n\t\tcf = dma_pool_alloc(re_chan->re_dev->cf_desc_pool, GFP_NOWAIT,\n\t\t\t\t    &paddr);\n\t\tif (!cf) {\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdesc = fsl_re_init_desc(re_chan, desc, cf, paddr);\n\t\tdesc->async_tx.flags = flags;\n\n\t\tspin_lock_irqsave(&re_chan->desc_lock, lock_flag);\n\t\tre_chan->alloc_count++;\n\t\tspin_unlock_irqrestore(&re_chan->desc_lock, lock_flag);\n\t}\n\n\treturn desc;\n}\n\nstatic struct dma_async_tx_descriptor *fsl_re_prep_dma_genq(\n\t\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,\n\t\tunsigned int src_cnt, const unsigned char *scf, size_t len,\n\t\tunsigned long flags)\n{\n\tstruct fsl_re_chan *re_chan;\n\tstruct fsl_re_desc *desc;\n\tstruct fsl_re_xor_cdb *xor;\n\tstruct fsl_re_cmpnd_frame *cf;\n\tu32 cdb;\n\tunsigned int i, j;\n\tunsigned int save_src_cnt = src_cnt;\n\tint cont_q = 0;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\tif (len > FSL_RE_MAX_DATA_LEN) {\n\t\tdev_err(re_chan->dev, \"genq tx length %zu, max length %d\\n\",\n\t\t\tlen, FSL_RE_MAX_DATA_LEN);\n\t\treturn NULL;\n\t}\n\n\tdesc = fsl_re_chan_alloc_desc(re_chan, flags);\n\tif (desc <= 0)\n\t\treturn NULL;\n\n\tif (scf && (flags & DMA_PREP_CONTINUE)) {\n\t\tcont_q = 1;\n\t\tsrc_cnt += 1;\n\t}\n\n\t \n\tcdb = FSL_RE_XOR_OPCODE << FSL_RE_CDB_OPCODE_SHIFT;\n\tcdb |= (src_cnt - 1) << FSL_RE_CDB_NRCS_SHIFT;\n\tcdb |= FSL_RE_BLOCK_SIZE << FSL_RE_CDB_BLKSIZE_SHIFT;\n\tcdb |= FSL_RE_INTR_ON_ERROR << FSL_RE_CDB_ERROR_SHIFT;\n\tcdb |= FSL_RE_DATA_DEP << FSL_RE_CDB_DEPEND_SHIFT;\n\txor = desc->cdb_addr;\n\txor->cdb32 = cdb;\n\n\tif (scf) {\n\t\t \n\t\tfor (i = 0; i < save_src_cnt; i++)\n\t\t\txor->gfm[i] = scf[i];\n\t\tif (cont_q)\n\t\t\txor->gfm[i++] = 1;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < src_cnt; i++)\n\t\t\txor->gfm[i] = 1;\n\t}\n\n\t \n\tcf = desc->cf_addr;\n\tfill_cfd_frame(cf, 0, sizeof(*xor), desc->cdb_paddr, 0);\n\n\t \n\tfill_cfd_frame(cf, 1, len, dest, 0);\n\n\t \n\tfor (i = 2, j = 0; j < save_src_cnt; i++, j++)\n\t\tfill_cfd_frame(cf, i, len, src[j], 0);\n\n\tif (cont_q)\n\t\tfill_cfd_frame(cf, i++, len, dest, 0);\n\n\t \n\tcf[i - 1].efrl32 |= 1 << FSL_RE_CF_FINAL_SHIFT;\n\n\treturn &desc->async_tx;\n}\n\n \nstatic struct dma_async_tx_descriptor *fsl_re_prep_dma_xor(\n\t\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,\n\t\tunsigned int src_cnt, size_t len, unsigned long flags)\n{\n\t \n\treturn fsl_re_prep_dma_genq(chan, dest, src, src_cnt, NULL, len, flags);\n}\n\n \nstatic struct dma_async_tx_descriptor *fsl_re_prep_dma_pq(\n\t\tstruct dma_chan *chan, dma_addr_t *dest, dma_addr_t *src,\n\t\tunsigned int src_cnt, const unsigned char *scf, size_t len,\n\t\tunsigned long flags)\n{\n\tstruct fsl_re_chan *re_chan;\n\tstruct fsl_re_desc *desc;\n\tstruct fsl_re_pq_cdb *pq;\n\tstruct fsl_re_cmpnd_frame *cf;\n\tu32 cdb;\n\tu8 *p;\n\tint gfmq_len, i, j;\n\tunsigned int save_src_cnt = src_cnt;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\tif (len > FSL_RE_MAX_DATA_LEN) {\n\t\tdev_err(re_chan->dev, \"pq tx length is %zu, max length is %d\\n\",\n\t\t\tlen, FSL_RE_MAX_DATA_LEN);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (src_cnt == 1) {\n\t\tstruct dma_async_tx_descriptor *tx;\n\t\tdma_addr_t dma_src[2];\n\t\tunsigned char coef[2];\n\n\t\tdma_src[0] = *src;\n\t\tcoef[0] = *scf;\n\t\tdma_src[1] = *src;\n\t\tcoef[1] = 0;\n\t\ttx = fsl_re_prep_dma_genq(chan, dest[1], dma_src, 2, coef, len,\n\t\t\t\t\t  flags);\n\t\tif (tx)\n\t\t\tdesc = to_fsl_re_dma_desc(tx);\n\n\t\treturn tx;\n\t}\n\n\t \n\n\tif (flags & DMA_PREP_PQ_DISABLE_P)\n\t\treturn fsl_re_prep_dma_genq(chan, dest[1], src, src_cnt,\n\t\t\t\tscf, len, flags);\n\n\tif (flags & DMA_PREP_CONTINUE)\n\t\tsrc_cnt += 3;\n\n\tdesc = fsl_re_chan_alloc_desc(re_chan, flags);\n\tif (desc <= 0)\n\t\treturn NULL;\n\n\t \n\tcdb = FSL_RE_PQ_OPCODE << FSL_RE_CDB_OPCODE_SHIFT;\n\tcdb |= (src_cnt - 1) << FSL_RE_CDB_NRCS_SHIFT;\n\tcdb |= FSL_RE_BLOCK_SIZE << FSL_RE_CDB_BLKSIZE_SHIFT;\n\tcdb |= FSL_RE_BUFFER_OUTPUT << FSL_RE_CDB_BUFFER_SHIFT;\n\tcdb |= FSL_RE_DATA_DEP << FSL_RE_CDB_DEPEND_SHIFT;\n\n\tpq = desc->cdb_addr;\n\tpq->cdb32 = cdb;\n\n\tp = pq->gfm_q1;\n\t \n\tfor (i = 0; i < src_cnt; i++)\n\t\tp[i] = 1;\n\n\t \n\tgfmq_len = ALIGN(src_cnt, 4);\n\n\t \n\tp += gfmq_len;\n\tfor (i = 0; i < src_cnt; i++)\n\t\tp[i] = scf[i];\n\n\t \n\tcf = desc->cf_addr;\n\tfill_cfd_frame(cf, 0, sizeof(struct fsl_re_pq_cdb), desc->cdb_paddr, 0);\n\n\t \n\tfor (i = 1, j = 0; i < 3; i++, j++)\n\t\tfill_cfd_frame(cf, i, len, dest[j], 0);\n\n\t \n\tfor (i = 3, j = 0; j < save_src_cnt; i++, j++)\n\t\tfill_cfd_frame(cf, i, len, src[j], 0);\n\n\t \n\tif (flags & DMA_PREP_CONTINUE) {\n\t\tif (src_cnt - save_src_cnt == 3) {\n\t\t\tp[save_src_cnt] = 0;\n\t\t\tp[save_src_cnt + 1] = 0;\n\t\t\tp[save_src_cnt + 2] = 1;\n\t\t\tfill_cfd_frame(cf, i++, len, dest[0], 0);\n\t\t\tfill_cfd_frame(cf, i++, len, dest[1], 0);\n\t\t\tfill_cfd_frame(cf, i++, len, dest[1], 0);\n\t\t} else {\n\t\t\tdev_err(re_chan->dev, \"PQ tx continuation error!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\tcf[i - 1].efrl32 |= 1 << FSL_RE_CF_FINAL_SHIFT;\n\n\treturn &desc->async_tx;\n}\n\n \nstatic struct dma_async_tx_descriptor *fsl_re_prep_dma_memcpy(\n\t\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\n\t\tsize_t len, unsigned long flags)\n{\n\tstruct fsl_re_chan *re_chan;\n\tstruct fsl_re_desc *desc;\n\tsize_t length;\n\tstruct fsl_re_cmpnd_frame *cf;\n\tstruct fsl_re_move_cdb *move;\n\tu32 cdb;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\n\tif (len > FSL_RE_MAX_DATA_LEN) {\n\t\tdev_err(re_chan->dev, \"cp tx length is %zu, max length is %d\\n\",\n\t\t\tlen, FSL_RE_MAX_DATA_LEN);\n\t\treturn NULL;\n\t}\n\n\tdesc = fsl_re_chan_alloc_desc(re_chan, flags);\n\tif (desc <= 0)\n\t\treturn NULL;\n\n\t \n\tcdb = FSL_RE_MOVE_OPCODE << FSL_RE_CDB_OPCODE_SHIFT;\n\tcdb |= FSL_RE_BLOCK_SIZE << FSL_RE_CDB_BLKSIZE_SHIFT;\n\tcdb |= FSL_RE_INTR_ON_ERROR << FSL_RE_CDB_ERROR_SHIFT;\n\tcdb |= FSL_RE_DATA_DEP << FSL_RE_CDB_DEPEND_SHIFT;\n\n\tmove = desc->cdb_addr;\n\tmove->cdb32 = cdb;\n\n\t \n\tcf = desc->cf_addr;\n\tfill_cfd_frame(cf, 0, sizeof(*move), desc->cdb_paddr, 0);\n\n\tlength = min_t(size_t, len, FSL_RE_MAX_DATA_LEN);\n\n\t \n\tfill_cfd_frame(cf, 1, length, dest, 0);\n\n\t \n\tfill_cfd_frame(cf, 2, length, src, 1);\n\n\treturn &desc->async_tx;\n}\n\nstatic int fsl_re_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct fsl_re_chan *re_chan;\n\tstruct fsl_re_desc *desc;\n\tvoid *cf;\n\tdma_addr_t paddr;\n\tint i;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\tfor (i = 0; i < FSL_RE_MIN_DESCS; i++) {\n\t\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\t\tif (!desc)\n\t\t\tbreak;\n\n\t\tcf = dma_pool_alloc(re_chan->re_dev->cf_desc_pool, GFP_KERNEL,\n\t\t\t\t    &paddr);\n\t\tif (!cf) {\n\t\t\tkfree(desc);\n\t\t\tbreak;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&desc->node);\n\t\tfsl_re_init_desc(re_chan, desc, cf, paddr);\n\n\t\tlist_add_tail(&desc->node, &re_chan->free_q);\n\t\tre_chan->alloc_count++;\n\t}\n\treturn re_chan->alloc_count;\n}\n\nstatic void fsl_re_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct fsl_re_chan *re_chan;\n\tstruct fsl_re_desc *desc;\n\n\tre_chan = container_of(chan, struct fsl_re_chan, chan);\n\twhile (re_chan->alloc_count--) {\n\t\tdesc = list_first_entry(&re_chan->free_q,\n\t\t\t\t\tstruct fsl_re_desc,\n\t\t\t\t\tnode);\n\n\t\tlist_del(&desc->node);\n\t\tdma_pool_free(re_chan->re_dev->cf_desc_pool, desc->cf_addr,\n\t\t\t      desc->cf_paddr);\n\t\tkfree(desc);\n\t}\n\n\tif (!list_empty(&re_chan->free_q))\n\t\tdev_err(re_chan->dev, \"chan resource cannot be cleaned!\\n\");\n}\n\nstatic int fsl_re_chan_probe(struct platform_device *ofdev,\n\t\t      struct device_node *np, u8 q, u32 off)\n{\n\tstruct device *dev, *chandev;\n\tstruct fsl_re_drv_private *re_priv;\n\tstruct fsl_re_chan *chan;\n\tstruct dma_device *dma_dev;\n\tu32 ptr;\n\tu32 status;\n\tint ret = 0, rc;\n\tstruct platform_device *chan_ofdev;\n\n\tdev = &ofdev->dev;\n\tre_priv = dev_get_drvdata(dev);\n\tdma_dev = &re_priv->dma_dev;\n\n\tchan = devm_kzalloc(dev, sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\t \n\tchan_ofdev = of_platform_device_create(np, NULL, dev);\n\tif (!chan_ofdev) {\n\t\tdev_err(dev, \"Not able to create ofdev for jr %d\\n\", q);\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\t \n\trc = of_property_read_u32(np, \"reg\", &ptr);\n\tif (rc) {\n\t\tdev_err(dev, \"Reg property not found in jr %d\\n\", q);\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tchan->jrregs = (struct fsl_re_chan_cfg *)((u8 *)re_priv->re_regs +\n\t\t\toff + ptr);\n\n\t \n\tchan->irq = irq_of_parse_and_map(np, 0);\n\tif (!chan->irq) {\n\t\tdev_err(dev, \"No IRQ defined for JR %d\\n\", q);\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tsnprintf(chan->name, sizeof(chan->name), \"re_jr%02d\", q);\n\n\tchandev = &chan_ofdev->dev;\n\ttasklet_setup(&chan->irqtask, fsl_re_dequeue);\n\n\tret = request_irq(chan->irq, fsl_re_isr, 0, chan->name, chandev);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register interrupt for JR %d\\n\", q);\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tre_priv->re_jrs[q] = chan;\n\tchan->chan.device = dma_dev;\n\tchan->chan.private = chan;\n\tchan->dev = chandev;\n\tchan->re_dev = re_priv;\n\n\tspin_lock_init(&chan->desc_lock);\n\tINIT_LIST_HEAD(&chan->ack_q);\n\tINIT_LIST_HEAD(&chan->active_q);\n\tINIT_LIST_HEAD(&chan->submit_q);\n\tINIT_LIST_HEAD(&chan->free_q);\n\n\tchan->inb_ring_virt_addr = dma_pool_alloc(chan->re_dev->hw_desc_pool,\n\t\tGFP_KERNEL, &chan->inb_phys_addr);\n\tif (!chan->inb_ring_virt_addr) {\n\t\tdev_err(dev, \"No dma memory for inb_ring_virt_addr\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tchan->oub_ring_virt_addr = dma_pool_alloc(chan->re_dev->hw_desc_pool,\n\t\tGFP_KERNEL, &chan->oub_phys_addr);\n\tif (!chan->oub_ring_virt_addr) {\n\t\tdev_err(dev, \"No dma memory for oub_ring_virt_addr\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_1;\n\t}\n\n\t \n\tout_be32(&chan->jrregs->inbring_base_h,\n\t\t chan->inb_phys_addr & FSL_RE_ADDR_BIT_MASK);\n\tout_be32(&chan->jrregs->oubring_base_h,\n\t\t chan->oub_phys_addr & FSL_RE_ADDR_BIT_MASK);\n\tout_be32(&chan->jrregs->inbring_base_l,\n\t\t chan->inb_phys_addr >> FSL_RE_ADDR_BIT_SHIFT);\n\tout_be32(&chan->jrregs->oubring_base_l,\n\t\t chan->oub_phys_addr >> FSL_RE_ADDR_BIT_SHIFT);\n\tout_be32(&chan->jrregs->inbring_size,\n\t\t FSL_RE_RING_SIZE << FSL_RE_RING_SIZE_SHIFT);\n\tout_be32(&chan->jrregs->oubring_size,\n\t\t FSL_RE_RING_SIZE << FSL_RE_RING_SIZE_SHIFT);\n\n\t \n\tstatus = in_be32(&chan->jrregs->jr_config_1) & FSL_RE_REG_LIODN_MASK;\n\n\t \n\tout_be32(&chan->jrregs->jr_config_1,\n\t\t FSL_RE_CFG1_CBSI | FSL_RE_CFG1_CBS0 | status);\n\n\tdev_set_drvdata(chandev, chan);\n\n\t \n\tout_be32(&chan->jrregs->jr_command, FSL_RE_ENABLE);\n\n\treturn 0;\n\nerr_free_1:\n\tdma_pool_free(chan->re_dev->hw_desc_pool, chan->inb_ring_virt_addr,\n\t\t      chan->inb_phys_addr);\nerr_free:\n\treturn ret;\n}\n\n \nstatic int fsl_re_probe(struct platform_device *ofdev)\n{\n\tstruct fsl_re_drv_private *re_priv;\n\tstruct device_node *np;\n\tstruct device_node *child;\n\tu32 off;\n\tu8 ridx = 0;\n\tstruct dma_device *dma_dev;\n\tstruct resource *res;\n\tint rc;\n\tstruct device *dev = &ofdev->dev;\n\n\tre_priv = devm_kzalloc(dev, sizeof(*re_priv), GFP_KERNEL);\n\tif (!re_priv)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\t \n\tre_priv->re_regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!re_priv->re_regs)\n\t\treturn -EBUSY;\n\n\t \n\tout_be32(&re_priv->re_regs->global_config, FSL_RE_NON_DPAA_MODE);\n\n\t \n\tout_be32(&re_priv->re_regs->galois_field_config, FSL_RE_GFM_POLY);\n\n\tdev_info(dev, \"version %x, mode %x, gfp %x\\n\",\n\t\t in_be32(&re_priv->re_regs->re_version_id),\n\t\t in_be32(&re_priv->re_regs->global_config),\n\t\t in_be32(&re_priv->re_regs->galois_field_config));\n\n\tdma_dev = &re_priv->dma_dev;\n\tdma_dev->dev = dev;\n\tINIT_LIST_HEAD(&dma_dev->channels);\n\tdma_set_mask(dev, DMA_BIT_MASK(40));\n\n\tdma_dev->device_alloc_chan_resources = fsl_re_alloc_chan_resources;\n\tdma_dev->device_tx_status = fsl_re_tx_status;\n\tdma_dev->device_issue_pending = fsl_re_issue_pending;\n\n\tdma_dev->max_xor = FSL_RE_MAX_XOR_SRCS;\n\tdma_dev->device_prep_dma_xor = fsl_re_prep_dma_xor;\n\tdma_cap_set(DMA_XOR, dma_dev->cap_mask);\n\n\tdma_dev->max_pq = FSL_RE_MAX_PQ_SRCS;\n\tdma_dev->device_prep_dma_pq = fsl_re_prep_dma_pq;\n\tdma_cap_set(DMA_PQ, dma_dev->cap_mask);\n\n\tdma_dev->device_prep_dma_memcpy = fsl_re_prep_dma_memcpy;\n\tdma_cap_set(DMA_MEMCPY, dma_dev->cap_mask);\n\n\tdma_dev->device_free_chan_resources = fsl_re_free_chan_resources;\n\n\tre_priv->total_chans = 0;\n\n\tre_priv->cf_desc_pool = dmam_pool_create(\"fsl_re_cf_desc_pool\", dev,\n\t\t\t\t\tFSL_RE_CF_CDB_SIZE,\n\t\t\t\t\tFSL_RE_CF_CDB_ALIGN, 0);\n\n\tif (!re_priv->cf_desc_pool) {\n\t\tdev_err(dev, \"No memory for fsl re_cf desc pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tre_priv->hw_desc_pool = dmam_pool_create(\"fsl_re_hw_desc_pool\", dev,\n\t\t\tsizeof(struct fsl_re_hw_desc) * FSL_RE_RING_SIZE,\n\t\t\tFSL_RE_FRAME_ALIGN, 0);\n\tif (!re_priv->hw_desc_pool) {\n\t\tdev_err(dev, \"No memory for fsl re_hw desc pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_set_drvdata(dev, re_priv);\n\n\t \n\tfor_each_compatible_node(np, NULL, \"fsl,raideng-v1.0-job-queue\") {\n\t\trc = of_property_read_u32(np, \"reg\", &off);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Reg property not found in JQ node\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tfor_each_child_of_node(np, child) {\n\t\t\trc = of_device_is_compatible(child,\n\t\t\t\t\t     \"fsl,raideng-v1.0-job-ring\");\n\t\t\tif (rc) {\n\t\t\t\tfsl_re_chan_probe(ofdev, child, ridx++, off);\n\t\t\t\tre_priv->total_chans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tdma_async_device_register(dma_dev);\n\n\treturn 0;\n}\n\nstatic void fsl_re_remove_chan(struct fsl_re_chan *chan)\n{\n\ttasklet_kill(&chan->irqtask);\n\n\tdma_pool_free(chan->re_dev->hw_desc_pool, chan->inb_ring_virt_addr,\n\t\t      chan->inb_phys_addr);\n\n\tdma_pool_free(chan->re_dev->hw_desc_pool, chan->oub_ring_virt_addr,\n\t\t      chan->oub_phys_addr);\n}\n\nstatic int fsl_re_remove(struct platform_device *ofdev)\n{\n\tstruct fsl_re_drv_private *re_priv;\n\tstruct device *dev;\n\tint i;\n\n\tdev = &ofdev->dev;\n\tre_priv = dev_get_drvdata(dev);\n\n\t \n\tfor (i = 0; i < re_priv->total_chans; i++)\n\t\tfsl_re_remove_chan(re_priv->re_jrs[i]);\n\n\t \n\tdma_async_device_unregister(&re_priv->dma_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsl_re_ids[] = {\n\t{ .compatible = \"fsl,raideng-v1.0\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_re_ids);\n\nstatic struct platform_driver fsl_re_driver = {\n\t.driver = {\n\t\t.name = \"fsl-raideng\",\n\t\t.of_match_table = fsl_re_ids,\n\t},\n\t.probe = fsl_re_probe,\n\t.remove = fsl_re_remove,\n};\n\nmodule_platform_driver(fsl_re_driver);\n\nMODULE_AUTHOR(\"Harninder Rai <harninder.rai@freescale.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Freescale RAID Engine Device Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}