{
  "module_name": "virt-dma.h",
  "hash_id": "a33340fc7c96f706d999e3b35d617680e0ad9b522b2eeabfd17c999049d6c3ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/virt-dma.h",
  "human_readable_source": " \n \n#ifndef VIRT_DMA_H\n#define VIRT_DMA_H\n\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n\n#include \"dmaengine.h\"\n\nstruct virt_dma_desc {\n\tstruct dma_async_tx_descriptor tx;\n\tstruct dmaengine_result tx_result;\n\t \n\tstruct list_head node;\n};\n\nstruct virt_dma_chan {\n\tstruct dma_chan\tchan;\n\tstruct tasklet_struct task;\n\tvoid (*desc_free)(struct virt_dma_desc *);\n\n\tspinlock_t lock;\n\n\t \n\tstruct list_head desc_allocated;\n\tstruct list_head desc_submitted;\n\tstruct list_head desc_issued;\n\tstruct list_head desc_completed;\n\tstruct list_head desc_terminated;\n\n\tstruct virt_dma_desc *cyclic;\n};\n\nstatic inline struct virt_dma_chan *to_virt_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct virt_dma_chan, chan);\n}\n\nvoid vchan_dma_desc_free_list(struct virt_dma_chan *vc, struct list_head *head);\nvoid vchan_init(struct virt_dma_chan *vc, struct dma_device *dmadev);\nstruct virt_dma_desc *vchan_find_desc(struct virt_dma_chan *, dma_cookie_t);\nextern dma_cookie_t vchan_tx_submit(struct dma_async_tx_descriptor *);\nextern int vchan_tx_desc_free(struct dma_async_tx_descriptor *);\n\n \nstatic inline struct dma_async_tx_descriptor *vchan_tx_prep(struct virt_dma_chan *vc,\n\tstruct virt_dma_desc *vd, unsigned long tx_flags)\n{\n\tunsigned long flags;\n\n\tdma_async_tx_descriptor_init(&vd->tx, &vc->chan);\n\tvd->tx.flags = tx_flags;\n\tvd->tx.tx_submit = vchan_tx_submit;\n\tvd->tx.desc_free = vchan_tx_desc_free;\n\n\tvd->tx_result.result = DMA_TRANS_NOERROR;\n\tvd->tx_result.residue = 0;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tlist_add_tail(&vd->node, &vc->desc_allocated);\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\treturn &vd->tx;\n}\n\n \nstatic inline bool vchan_issue_pending(struct virt_dma_chan *vc)\n{\n\tlist_splice_tail_init(&vc->desc_submitted, &vc->desc_issued);\n\treturn !list_empty(&vc->desc_issued);\n}\n\n \nstatic inline void vchan_cookie_complete(struct virt_dma_desc *vd)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(vd->tx.chan);\n\tdma_cookie_t cookie;\n\n\tcookie = vd->tx.cookie;\n\tdma_cookie_complete(&vd->tx);\n\tdev_vdbg(vc->chan.device->dev, \"txd %p[%x]: marked complete\\n\",\n\t\t vd, cookie);\n\tlist_add_tail(&vd->node, &vc->desc_completed);\n\n\ttasklet_schedule(&vc->task);\n}\n\n \nstatic inline void vchan_vdesc_fini(struct virt_dma_desc *vd)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(vd->tx.chan);\n\n\tif (dmaengine_desc_test_reuse(&vd->tx)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&vc->lock, flags);\n\t\tlist_add(&vd->node, &vc->desc_allocated);\n\t\tspin_unlock_irqrestore(&vc->lock, flags);\n\t} else {\n\t\tvc->desc_free(vd);\n\t}\n}\n\n \nstatic inline void vchan_cyclic_callback(struct virt_dma_desc *vd)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(vd->tx.chan);\n\n\tvc->cyclic = vd;\n\ttasklet_schedule(&vc->task);\n}\n\n \nstatic inline void vchan_terminate_vdesc(struct virt_dma_desc *vd)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(vd->tx.chan);\n\n\tlist_add_tail(&vd->node, &vc->desc_terminated);\n\n\tif (vc->cyclic == vd)\n\t\tvc->cyclic = NULL;\n}\n\n \nstatic inline struct virt_dma_desc *vchan_next_desc(struct virt_dma_chan *vc)\n{\n\treturn list_first_entry_or_null(&vc->desc_issued,\n\t\t\t\t\tstruct virt_dma_desc, node);\n}\n\n \nstatic inline void vchan_get_all_descriptors(struct virt_dma_chan *vc,\n\tstruct list_head *head)\n{\n\tlist_splice_tail_init(&vc->desc_allocated, head);\n\tlist_splice_tail_init(&vc->desc_submitted, head);\n\tlist_splice_tail_init(&vc->desc_issued, head);\n\tlist_splice_tail_init(&vc->desc_completed, head);\n\tlist_splice_tail_init(&vc->desc_terminated, head);\n}\n\nstatic inline void vchan_free_chan_resources(struct virt_dma_chan *vc)\n{\n\tstruct virt_dma_desc *vd;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tvchan_get_all_descriptors(vc, &head);\n\tlist_for_each_entry(vd, &head, node)\n\t\tdmaengine_desc_clear_reuse(&vd->tx);\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tvchan_dma_desc_free_list(vc, &head);\n}\n\n \nstatic inline void vchan_synchronize(struct virt_dma_chan *vc)\n{\n\tLIST_HEAD(head);\n\tunsigned long flags;\n\n\ttasklet_kill(&vc->task);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tlist_splice_tail_init(&vc->desc_terminated, &head);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tvchan_dma_desc_free_list(vc, &head);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}