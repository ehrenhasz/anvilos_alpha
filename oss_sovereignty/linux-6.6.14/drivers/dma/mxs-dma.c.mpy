{
  "module_name": "mxs-dma.c",
  "hash_id": "3d3829eec2f79e53ffb30495ba7625b8aeac5e6e3f1fd422d9bad0dc90bfb275",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/mxs-dma.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/semaphore.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/dmaengine.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/stmp_device.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/list.h>\n#include <linux/dma/mxs-dma.h>\n\n#include <asm/irq.h>\n\n#include \"dmaengine.h\"\n\n \n\n#define dma_is_apbh(mxs_dma)\t((mxs_dma)->type == MXS_DMA_APBH)\n#define apbh_is_old(mxs_dma)\t((mxs_dma)->dev_id == IMX23_DMA)\n\n#define HW_APBHX_CTRL0\t\t\t\t0x000\n#define BM_APBH_CTRL0_APB_BURST8_EN\t\t(1 << 29)\n#define BM_APBH_CTRL0_APB_BURST_EN\t\t(1 << 28)\n#define BP_APBH_CTRL0_RESET_CHANNEL\t\t16\n#define HW_APBHX_CTRL1\t\t\t\t0x010\n#define HW_APBHX_CTRL2\t\t\t\t0x020\n#define HW_APBHX_CHANNEL_CTRL\t\t\t0x030\n#define BP_APBHX_CHANNEL_CTRL_RESET_CHANNEL\t16\n \n#define HW_APBHX_CHn_NXTCMDAR(d, n) \\\n\t(((dma_is_apbh(d) && apbh_is_old(d)) ? 0x050 : 0x110) + (n) * 0x70)\n#define HW_APBHX_CHn_SEMA(d, n) \\\n\t(((dma_is_apbh(d) && apbh_is_old(d)) ? 0x080 : 0x140) + (n) * 0x70)\n#define HW_APBHX_CHn_BAR(d, n) \\\n\t(((dma_is_apbh(d) && apbh_is_old(d)) ? 0x070 : 0x130) + (n) * 0x70)\n#define HW_APBX_CHn_DEBUG1(d, n) (0x150 + (n) * 0x70)\n\n \n#define BP_CCW_COMMAND\t\t0\n#define BM_CCW_COMMAND\t\t(3 << 0)\n#define CCW_CHAIN\t\t(1 << 2)\n#define CCW_IRQ\t\t\t(1 << 3)\n#define CCW_WAIT4RDY\t\t(1 << 5)\n#define CCW_DEC_SEM\t\t(1 << 6)\n#define CCW_WAIT4END\t\t(1 << 7)\n#define CCW_HALT_ON_TERM\t(1 << 8)\n#define CCW_TERM_FLUSH\t\t(1 << 9)\n#define BP_CCW_PIO_NUM\t\t12\n#define BM_CCW_PIO_NUM\t\t(0xf << 12)\n\n#define BF_CCW(value, field)\t(((value) << BP_CCW_##field) & BM_CCW_##field)\n\n#define MXS_DMA_CMD_NO_XFER\t0\n#define MXS_DMA_CMD_WRITE\t1\n#define MXS_DMA_CMD_READ\t2\n#define MXS_DMA_CMD_DMA_SENSE\t3\t \n\nstruct mxs_dma_ccw {\n\tu32\t\tnext;\n\tu16\t\tbits;\n\tu16\t\txfer_bytes;\n#define MAX_XFER_BYTES\t0xff00\n\tu32\t\tbufaddr;\n#define MXS_PIO_WORDS\t16\n\tu32\t\tpio_words[MXS_PIO_WORDS];\n};\n\n#define CCW_BLOCK_SIZE\t(4 * PAGE_SIZE)\n#define NUM_CCW\t(int)(CCW_BLOCK_SIZE / sizeof(struct mxs_dma_ccw))\n\nstruct mxs_dma_chan {\n\tstruct mxs_dma_engine\t\t*mxs_dma;\n\tstruct dma_chan\t\t\tchan;\n\tstruct dma_async_tx_descriptor\tdesc;\n\tstruct tasklet_struct\t\ttasklet;\n\tunsigned int\t\t\tchan_irq;\n\tstruct mxs_dma_ccw\t\t*ccw;\n\tdma_addr_t\t\t\tccw_phys;\n\tint\t\t\t\tdesc_count;\n\tenum dma_status\t\t\tstatus;\n\tunsigned int\t\t\tflags;\n\tbool\t\t\t\treset;\n#define MXS_DMA_SG_LOOP\t\t\t(1 << 0)\n#define MXS_DMA_USE_SEMAPHORE\t\t(1 << 1)\n};\n\n#define MXS_DMA_CHANNELS\t\t16\n#define MXS_DMA_CHANNELS_MASK\t\t0xffff\n\nenum mxs_dma_devtype {\n\tMXS_DMA_APBH,\n\tMXS_DMA_APBX,\n};\n\nenum mxs_dma_id {\n\tIMX23_DMA,\n\tIMX28_DMA,\n};\n\nstruct mxs_dma_engine {\n\tenum mxs_dma_id\t\t\tdev_id;\n\tenum mxs_dma_devtype\t\ttype;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*clk;\n\tstruct dma_device\t\tdma_device;\n\tstruct mxs_dma_chan\t\tmxs_chans[MXS_DMA_CHANNELS];\n\tstruct platform_device\t\t*pdev;\n\tunsigned int\t\t\tnr_channels;\n};\n\nstruct mxs_dma_type {\n\tenum mxs_dma_id id;\n\tenum mxs_dma_devtype type;\n};\n\nstatic struct mxs_dma_type mxs_dma_types[] = {\n\t{\n\t\t.id = IMX23_DMA,\n\t\t.type = MXS_DMA_APBH,\n\t}, {\n\t\t.id = IMX23_DMA,\n\t\t.type = MXS_DMA_APBX,\n\t}, {\n\t\t.id = IMX28_DMA,\n\t\t.type = MXS_DMA_APBH,\n\t}, {\n\t\t.id = IMX28_DMA,\n\t\t.type = MXS_DMA_APBX,\n\t}\n};\n\nstatic const struct of_device_id mxs_dma_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-dma-apbh\", .data = &mxs_dma_types[0], },\n\t{ .compatible = \"fsl,imx23-dma-apbx\", .data = &mxs_dma_types[1], },\n\t{ .compatible = \"fsl,imx28-dma-apbh\", .data = &mxs_dma_types[2], },\n\t{ .compatible = \"fsl,imx28-dma-apbx\", .data = &mxs_dma_types[3], },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_dma_dt_ids);\n\nstatic struct mxs_dma_chan *to_mxs_dma_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct mxs_dma_chan, chan);\n}\n\nstatic void mxs_dma_reset_chan(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint chan_id = mxs_chan->chan.chan_id;\n\n\t \n\tif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE &&\n\t\t\tmxs_chan->flags & MXS_DMA_SG_LOOP) {\n\t\tmxs_chan->reset = true;\n\t} else if (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma)) {\n\t\twritel(1 << (chan_id + BP_APBH_CTRL0_RESET_CHANNEL),\n\t\t\tmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\n\t} else {\n\t\tunsigned long elapsed = 0;\n\t\tconst unsigned long max_wait = 50000;  \n\t\tvoid __iomem *reg_dbg1 = mxs_dma->base +\n\t\t\t\tHW_APBX_CHn_DEBUG1(mxs_dma, chan_id);\n\n\t\t \n\t\twhile ((readl(reg_dbg1) & 0xf) == 0x8 && elapsed < max_wait) {\n\t\t\tudelay(100);\n\t\t\telapsed += 100;\n\t\t}\n\n\t\tif (elapsed >= max_wait)\n\t\t\tdev_err(&mxs_chan->mxs_dma->pdev->dev,\n\t\t\t\t\t\"Failed waiting for the DMA channel %d to leave state READ_FLUSH, trying to reset channel in READ_FLUSH state now\\n\",\n\t\t\t\t\tchan_id);\n\n\t\twritel(1 << (chan_id + BP_APBHX_CHANNEL_CTRL_RESET_CHANNEL),\n\t\t\tmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\n\t}\n\n\tmxs_chan->status = DMA_COMPLETE;\n}\n\nstatic void mxs_dma_enable_chan(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint chan_id = mxs_chan->chan.chan_id;\n\n\t \n\twritel(mxs_chan->ccw_phys,\n\t\tmxs_dma->base + HW_APBHX_CHn_NXTCMDAR(mxs_dma, chan_id));\n\n\t \n\tif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE &&\n\t\t\tmxs_chan->flags & MXS_DMA_SG_LOOP) {\n\t\t \n\t\twritel(2, mxs_dma->base + HW_APBHX_CHn_SEMA(mxs_dma, chan_id));\n\t} else {\n\t\twritel(1, mxs_dma->base + HW_APBHX_CHn_SEMA(mxs_dma, chan_id));\n\t}\n\tmxs_chan->reset = false;\n}\n\nstatic void mxs_dma_disable_chan(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\n\tmxs_chan->status = DMA_COMPLETE;\n}\n\nstatic int mxs_dma_pause_chan(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint chan_id = mxs_chan->chan.chan_id;\n\n\t \n\tif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\n\t\twritel(1 << chan_id,\n\t\t\tmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\n\telse\n\t\twritel(1 << chan_id,\n\t\t\tmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\n\n\tmxs_chan->status = DMA_PAUSED;\n\treturn 0;\n}\n\nstatic int mxs_dma_resume_chan(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint chan_id = mxs_chan->chan.chan_id;\n\n\t \n\tif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\n\t\twritel(1 << chan_id,\n\t\t\tmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_CLR);\n\telse\n\t\twritel(1 << chan_id,\n\t\t\tmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_CLR);\n\n\tmxs_chan->status = DMA_IN_PROGRESS;\n\treturn 0;\n}\n\nstatic dma_cookie_t mxs_dma_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\treturn dma_cookie_assign(tx);\n}\n\nstatic void mxs_dma_tasklet(struct tasklet_struct *t)\n{\n\tstruct mxs_dma_chan *mxs_chan = from_tasklet(mxs_chan, t, tasklet);\n\n\tdmaengine_desc_get_callback_invoke(&mxs_chan->desc, NULL);\n}\n\nstatic int mxs_dma_irq_to_chan(struct mxs_dma_engine *mxs_dma, int irq)\n{\n\tint i;\n\n\tfor (i = 0; i != mxs_dma->nr_channels; ++i)\n\t\tif (mxs_dma->mxs_chans[i].chan_irq == irq)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t mxs_dma_int_handler(int irq, void *dev_id)\n{\n\tstruct mxs_dma_engine *mxs_dma = dev_id;\n\tstruct mxs_dma_chan *mxs_chan;\n\tu32 completed;\n\tu32 err;\n\tint chan = mxs_dma_irq_to_chan(mxs_dma, irq);\n\n\tif (chan < 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tcompleted = readl(mxs_dma->base + HW_APBHX_CTRL1);\n\tcompleted = (completed >> chan) & 0x1;\n\n\t \n\twritel((1 << chan),\n\t\t\tmxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\t \n\terr = readl(mxs_dma->base + HW_APBHX_CTRL2);\n\terr &= (1 << (MXS_DMA_CHANNELS + chan)) | (1 << chan);\n\n\t \n\terr = (err >> (MXS_DMA_CHANNELS + chan)) + (err >> chan);\n\n\t \n\twritel((1 << chan),\n\t\t\tmxs_dma->base + HW_APBHX_CTRL2 + STMP_OFFSET_REG_CLR);\n\n\t \n\terr -= err & completed;\n\n\tmxs_chan = &mxs_dma->mxs_chans[chan];\n\n\tif (err) {\n\t\tdev_dbg(mxs_dma->dma_device.dev,\n\t\t\t\"%s: error in channel %d\\n\", __func__,\n\t\t\tchan);\n\t\tmxs_chan->status = DMA_ERROR;\n\t\tmxs_dma_reset_chan(&mxs_chan->chan);\n\t} else if (mxs_chan->status != DMA_COMPLETE) {\n\t\tif (mxs_chan->flags & MXS_DMA_SG_LOOP) {\n\t\t\tmxs_chan->status = DMA_IN_PROGRESS;\n\t\t\tif (mxs_chan->flags & MXS_DMA_USE_SEMAPHORE)\n\t\t\t\twritel(1, mxs_dma->base +\n\t\t\t\t\tHW_APBHX_CHn_SEMA(mxs_dma, chan));\n\t\t} else {\n\t\t\tmxs_chan->status = DMA_COMPLETE;\n\t\t}\n\t}\n\n\tif (mxs_chan->status == DMA_COMPLETE) {\n\t\tif (mxs_chan->reset)\n\t\t\treturn IRQ_HANDLED;\n\t\tdma_cookie_complete(&mxs_chan->desc);\n\t}\n\n\t \n\ttasklet_schedule(&mxs_chan->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxs_dma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint ret;\n\n\tmxs_chan->ccw = dma_alloc_coherent(mxs_dma->dma_device.dev,\n\t\t\t\t\t   CCW_BLOCK_SIZE,\n\t\t\t\t\t   &mxs_chan->ccw_phys, GFP_KERNEL);\n\tif (!mxs_chan->ccw) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tret = request_irq(mxs_chan->chan_irq, mxs_dma_int_handler,\n\t\t\t  0, \"mxs-dma\", mxs_dma);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tret = clk_prepare_enable(mxs_dma->clk);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tmxs_dma_reset_chan(chan);\n\n\tdma_async_tx_descriptor_init(&mxs_chan->desc, chan);\n\tmxs_chan->desc.tx_submit = mxs_dma_tx_submit;\n\n\t \n\tasync_tx_ack(&mxs_chan->desc);\n\n\treturn 0;\n\nerr_clk:\n\tfree_irq(mxs_chan->chan_irq, mxs_dma);\nerr_irq:\n\tdma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\n\t\t\tmxs_chan->ccw, mxs_chan->ccw_phys);\nerr_alloc:\n\treturn ret;\n}\n\nstatic void mxs_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\n\tmxs_dma_disable_chan(chan);\n\n\tfree_irq(mxs_chan->chan_irq, mxs_dma);\n\n\tdma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\n\t\t\tmxs_chan->ccw, mxs_chan->ccw_phys);\n\n\tclk_disable_unprepare(mxs_dma->clk);\n}\n\n \nstatic struct dma_async_tx_descriptor *mxs_dma_prep_slave_sg(\n\t\tstruct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tstruct mxs_dma_ccw *ccw;\n\tstruct scatterlist *sg;\n\tu32 i, j;\n\tu32 *pio;\n\tint idx = 0;\n\n\tif (mxs_chan->status == DMA_IN_PROGRESS)\n\t\tidx = mxs_chan->desc_count;\n\n\tif (sg_len + idx > NUM_CCW) {\n\t\tdev_err(mxs_dma->dma_device.dev,\n\t\t\t\t\"maximum number of sg exceeded: %d > %d\\n\",\n\t\t\t\tsg_len, NUM_CCW);\n\t\tgoto err_out;\n\t}\n\n\tmxs_chan->status = DMA_IN_PROGRESS;\n\tmxs_chan->flags = 0;\n\n\t \n\tif (idx) {\n\t\tBUG_ON(idx < 1);\n\t\tccw = &mxs_chan->ccw[idx - 1];\n\t\tccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\n\t\tccw->bits |= CCW_CHAIN;\n\t\tccw->bits &= ~CCW_IRQ;\n\t\tccw->bits &= ~CCW_DEC_SEM;\n\t} else {\n\t\tidx = 0;\n\t}\n\n\tif (direction == DMA_TRANS_NONE) {\n\t\tccw = &mxs_chan->ccw[idx++];\n\t\tpio = (u32 *) sgl;\n\n\t\tfor (j = 0; j < sg_len;)\n\t\t\tccw->pio_words[j++] = *pio++;\n\n\t\tccw->bits = 0;\n\t\tccw->bits |= CCW_IRQ;\n\t\tccw->bits |= CCW_DEC_SEM;\n\t\tif (flags & MXS_DMA_CTRL_WAIT4END)\n\t\t\tccw->bits |= CCW_WAIT4END;\n\t\tccw->bits |= CCW_HALT_ON_TERM;\n\t\tccw->bits |= CCW_TERM_FLUSH;\n\t\tccw->bits |= BF_CCW(sg_len, PIO_NUM);\n\t\tccw->bits |= BF_CCW(MXS_DMA_CMD_NO_XFER, COMMAND);\n\t\tif (flags & MXS_DMA_CTRL_WAIT4RDY)\n\t\t\tccw->bits |= CCW_WAIT4RDY;\n\t} else {\n\t\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\t\tif (sg_dma_len(sg) > MAX_XFER_BYTES) {\n\t\t\t\tdev_err(mxs_dma->dma_device.dev, \"maximum bytes for sg entry exceeded: %d > %d\\n\",\n\t\t\t\t\t\tsg_dma_len(sg), MAX_XFER_BYTES);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tccw = &mxs_chan->ccw[idx++];\n\n\t\t\tccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\n\t\t\tccw->bufaddr = sg->dma_address;\n\t\t\tccw->xfer_bytes = sg_dma_len(sg);\n\n\t\t\tccw->bits = 0;\n\t\t\tccw->bits |= CCW_CHAIN;\n\t\t\tccw->bits |= CCW_HALT_ON_TERM;\n\t\t\tccw->bits |= CCW_TERM_FLUSH;\n\t\t\tccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\n\t\t\t\t\tMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ,\n\t\t\t\t\tCOMMAND);\n\n\t\t\tif (i + 1 == sg_len) {\n\t\t\t\tccw->bits &= ~CCW_CHAIN;\n\t\t\t\tccw->bits |= CCW_IRQ;\n\t\t\t\tccw->bits |= CCW_DEC_SEM;\n\t\t\t\tif (flags & MXS_DMA_CTRL_WAIT4END)\n\t\t\t\t\tccw->bits |= CCW_WAIT4END;\n\t\t\t}\n\t\t}\n\t}\n\tmxs_chan->desc_count = idx;\n\n\treturn &mxs_chan->desc;\n\nerr_out:\n\tmxs_chan->status = DMA_ERROR;\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *mxs_dma_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tu32 num_periods = buf_len / period_len;\n\tu32 i = 0, buf = 0;\n\n\tif (mxs_chan->status == DMA_IN_PROGRESS)\n\t\treturn NULL;\n\n\tmxs_chan->status = DMA_IN_PROGRESS;\n\tmxs_chan->flags |= MXS_DMA_SG_LOOP;\n\tmxs_chan->flags |= MXS_DMA_USE_SEMAPHORE;\n\n\tif (num_periods > NUM_CCW) {\n\t\tdev_err(mxs_dma->dma_device.dev,\n\t\t\t\t\"maximum number of sg exceeded: %d > %d\\n\",\n\t\t\t\tnum_periods, NUM_CCW);\n\t\tgoto err_out;\n\t}\n\n\tif (period_len > MAX_XFER_BYTES) {\n\t\tdev_err(mxs_dma->dma_device.dev,\n\t\t\t\t\"maximum period size exceeded: %zu > %d\\n\",\n\t\t\t\tperiod_len, MAX_XFER_BYTES);\n\t\tgoto err_out;\n\t}\n\n\twhile (buf < buf_len) {\n\t\tstruct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];\n\n\t\tif (i + 1 == num_periods)\n\t\t\tccw->next = mxs_chan->ccw_phys;\n\t\telse\n\t\t\tccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * (i + 1);\n\n\t\tccw->bufaddr = dma_addr;\n\t\tccw->xfer_bytes = period_len;\n\n\t\tccw->bits = 0;\n\t\tccw->bits |= CCW_CHAIN;\n\t\tccw->bits |= CCW_IRQ;\n\t\tccw->bits |= CCW_HALT_ON_TERM;\n\t\tccw->bits |= CCW_TERM_FLUSH;\n\t\tccw->bits |= CCW_DEC_SEM;\n\t\tccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\n\t\t\t\tMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ, COMMAND);\n\n\t\tdma_addr += period_len;\n\t\tbuf += period_len;\n\n\t\ti++;\n\t}\n\tmxs_chan->desc_count = i;\n\n\treturn &mxs_chan->desc;\n\nerr_out:\n\tmxs_chan->status = DMA_ERROR;\n\treturn NULL;\n}\n\nstatic int mxs_dma_terminate_all(struct dma_chan *chan)\n{\n\tmxs_dma_reset_chan(chan);\n\tmxs_dma_disable_chan(chan);\n\n\treturn 0;\n}\n\nstatic enum dma_status mxs_dma_tx_status(struct dma_chan *chan,\n\t\t\tdma_cookie_t cookie, struct dma_tx_state *txstate)\n{\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tu32 residue = 0;\n\n\tif (mxs_chan->status == DMA_IN_PROGRESS &&\n\t\t\tmxs_chan->flags & MXS_DMA_SG_LOOP) {\n\t\tstruct mxs_dma_ccw *last_ccw;\n\t\tu32 bar;\n\n\t\tlast_ccw = &mxs_chan->ccw[mxs_chan->desc_count - 1];\n\t\tresidue = last_ccw->xfer_bytes + last_ccw->bufaddr;\n\n\t\tbar = readl(mxs_dma->base +\n\t\t\t\tHW_APBHX_CHn_BAR(mxs_dma, chan->chan_id));\n\t\tresidue -= bar;\n\t}\n\n\tdma_set_tx_state(txstate, chan->completed_cookie, chan->cookie,\n\t\t\tresidue);\n\n\treturn mxs_chan->status;\n}\n\nstatic int mxs_dma_init(struct mxs_dma_engine *mxs_dma)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(mxs_dma->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmp_reset_block(mxs_dma->base);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tif (dma_is_apbh(mxs_dma)) {\n\t\twritel(BM_APBH_CTRL0_APB_BURST_EN,\n\t\t\tmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\n\t\twritel(BM_APBH_CTRL0_APB_BURST8_EN,\n\t\t\tmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\n\t}\n\n\t \n\twritel(MXS_DMA_CHANNELS_MASK << MXS_DMA_CHANNELS,\n\t\tmxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_SET);\n\nerr_out:\n\tclk_disable_unprepare(mxs_dma->clk);\n\treturn ret;\n}\n\nstruct mxs_dma_filter_param {\n\tunsigned int chan_id;\n};\n\nstatic bool mxs_dma_filter_fn(struct dma_chan *chan, void *fn_param)\n{\n\tstruct mxs_dma_filter_param *param = fn_param;\n\tstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\n\tstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\n\tint chan_irq;\n\n\tif (chan->chan_id != param->chan_id)\n\t\treturn false;\n\n\tchan_irq = platform_get_irq(mxs_dma->pdev, param->chan_id);\n\tif (chan_irq < 0)\n\t\treturn false;\n\n\tmxs_chan->chan_irq = chan_irq;\n\n\treturn true;\n}\n\nstatic struct dma_chan *mxs_dma_xlate(struct of_phandle_args *dma_spec,\n\t\t\t       struct of_dma *ofdma)\n{\n\tstruct mxs_dma_engine *mxs_dma = ofdma->of_dma_data;\n\tdma_cap_mask_t mask = mxs_dma->dma_device.cap_mask;\n\tstruct mxs_dma_filter_param param;\n\n\tif (dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\tparam.chan_id = dma_spec->args[0];\n\n\tif (param.chan_id >= mxs_dma->nr_channels)\n\t\treturn NULL;\n\n\treturn __dma_request_channel(&mask, mxs_dma_filter_fn, &param,\n\t\t\t\t     ofdma->of_node);\n}\n\nstatic int mxs_dma_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct mxs_dma_type *dma_type;\n\tstruct mxs_dma_engine *mxs_dma;\n\tint ret, i;\n\n\tmxs_dma = devm_kzalloc(&pdev->dev, sizeof(*mxs_dma), GFP_KERNEL);\n\tif (!mxs_dma)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"dma-channels\", &mxs_dma->nr_channels);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read dma-channels\\n\");\n\t\treturn ret;\n\t}\n\n\tdma_type = (struct mxs_dma_type *)of_device_get_match_data(&pdev->dev);\n\tmxs_dma->type = dma_type->type;\n\tmxs_dma->dev_id = dma_type->id;\n\n\tmxs_dma->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mxs_dma->base))\n\t\treturn PTR_ERR(mxs_dma->base);\n\n\tmxs_dma->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mxs_dma->clk))\n\t\treturn PTR_ERR(mxs_dma->clk);\n\n\tdma_cap_set(DMA_SLAVE, mxs_dma->dma_device.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, mxs_dma->dma_device.cap_mask);\n\n\tINIT_LIST_HEAD(&mxs_dma->dma_device.channels);\n\n\t \n\tfor (i = 0; i < MXS_DMA_CHANNELS; i++) {\n\t\tstruct mxs_dma_chan *mxs_chan = &mxs_dma->mxs_chans[i];\n\n\t\tmxs_chan->mxs_dma = mxs_dma;\n\t\tmxs_chan->chan.device = &mxs_dma->dma_device;\n\t\tdma_cookie_init(&mxs_chan->chan);\n\n\t\ttasklet_setup(&mxs_chan->tasklet, mxs_dma_tasklet);\n\n\n\t\t \n\t\tlist_add_tail(&mxs_chan->chan.device_node,\n\t\t\t&mxs_dma->dma_device.channels);\n\t}\n\n\tret = mxs_dma_init(mxs_dma);\n\tif (ret)\n\t\treturn ret;\n\n\tmxs_dma->pdev = pdev;\n\tmxs_dma->dma_device.dev = &pdev->dev;\n\n\t \n\tdma_set_max_seg_size(mxs_dma->dma_device.dev, MAX_XFER_BYTES);\n\n\tmxs_dma->dma_device.device_alloc_chan_resources = mxs_dma_alloc_chan_resources;\n\tmxs_dma->dma_device.device_free_chan_resources = mxs_dma_free_chan_resources;\n\tmxs_dma->dma_device.device_tx_status = mxs_dma_tx_status;\n\tmxs_dma->dma_device.device_prep_slave_sg = mxs_dma_prep_slave_sg;\n\tmxs_dma->dma_device.device_prep_dma_cyclic = mxs_dma_prep_dma_cyclic;\n\tmxs_dma->dma_device.device_pause = mxs_dma_pause_chan;\n\tmxs_dma->dma_device.device_resume = mxs_dma_resume_chan;\n\tmxs_dma->dma_device.device_terminate_all = mxs_dma_terminate_all;\n\tmxs_dma->dma_device.src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tmxs_dma->dma_device.dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tmxs_dma->dma_device.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tmxs_dma->dma_device.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tmxs_dma->dma_device.device_issue_pending = mxs_dma_enable_chan;\n\n\tret = dmaenginem_async_device_register(&mxs_dma->dma_device);\n\tif (ret) {\n\t\tdev_err(mxs_dma->dma_device.dev, \"unable to register\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_dma_controller_register(np, mxs_dma_xlate, mxs_dma);\n\tif (ret) {\n\t\tdev_err(mxs_dma->dma_device.dev,\n\t\t\t\"failed to register controller\\n\");\n\t}\n\n\tdev_info(mxs_dma->dma_device.dev, \"initialized\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver mxs_dma_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mxs-dma\",\n\t\t.of_match_table = mxs_dma_dt_ids,\n\t},\n\t.probe = mxs_dma_probe,\n};\n\nbuiltin_platform_driver(mxs_dma_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}