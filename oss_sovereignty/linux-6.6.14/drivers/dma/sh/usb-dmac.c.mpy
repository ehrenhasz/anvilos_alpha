{
  "module_name": "usb-dmac.c",
  "hash_id": "d202a9d11801942ad6455fec801fa08a9605d30950643395ed9c15ca3f587dc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/sh/usb-dmac.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"../dmaengine.h\"\n#include \"../virt-dma.h\"\n\n \nstruct usb_dmac_sg {\n\tdma_addr_t mem_addr;\n\tu32 size;\n};\n\n \nstruct usb_dmac_desc {\n\tstruct virt_dma_desc vd;\n\tenum dma_transfer_direction direction;\n\tunsigned int sg_allocated_len;\n\tunsigned int sg_len;\n\tunsigned int sg_index;\n\tu32 residue;\n\tstruct list_head node;\n\tdma_cookie_t done_cookie;\n\tstruct usb_dmac_sg sg[];\n};\n\n#define to_usb_dmac_desc(vd)\tcontainer_of(vd, struct usb_dmac_desc, vd)\n\n \nstruct usb_dmac_chan {\n\tstruct virt_dma_chan vc;\n\tvoid __iomem *iomem;\n\tunsigned int index;\n\tint irq;\n\tstruct usb_dmac_desc *desc;\n\tint descs_allocated;\n\tstruct list_head desc_got;\n\tstruct list_head desc_freed;\n};\n\n#define to_usb_dmac_chan(c) container_of(c, struct usb_dmac_chan, vc.chan)\n\n \nstruct usb_dmac {\n\tstruct dma_device engine;\n\tstruct device *dev;\n\tvoid __iomem *iomem;\n\n\tunsigned int n_channels;\n\tstruct usb_dmac_chan *channels;\n};\n\n#define to_usb_dmac(d)\t\tcontainer_of(d, struct usb_dmac, engine)\n\n \n\n#define USB_DMAC_CHAN_OFFSET(i)\t\t(0x20 + 0x20 * (i))\n\n#define USB_DMASWR\t\t\t0x0008\n#define USB_DMASWR_SWR\t\t\t(1 << 0)\n#define USB_DMAOR\t\t\t0x0060\n#define USB_DMAOR_AE\t\t\t(1 << 1)\n#define USB_DMAOR_DME\t\t\t(1 << 0)\n\n#define USB_DMASAR\t\t\t0x0000\n#define USB_DMADAR\t\t\t0x0004\n#define USB_DMATCR\t\t\t0x0008\n#define USB_DMATCR_MASK\t\t\t0x00ffffff\n#define USB_DMACHCR\t\t\t0x0014\n#define USB_DMACHCR_FTE\t\t\t(1 << 24)\n#define USB_DMACHCR_NULLE\t\t(1 << 16)\n#define USB_DMACHCR_NULL\t\t(1 << 12)\n#define USB_DMACHCR_TS_8B\t\t((0 << 7) | (0 << 6))\n#define USB_DMACHCR_TS_16B\t\t((0 << 7) | (1 << 6))\n#define USB_DMACHCR_TS_32B\t\t((1 << 7) | (0 << 6))\n#define USB_DMACHCR_IE\t\t\t(1 << 5)\n#define USB_DMACHCR_SP\t\t\t(1 << 2)\n#define USB_DMACHCR_TE\t\t\t(1 << 1)\n#define USB_DMACHCR_DE\t\t\t(1 << 0)\n#define USB_DMATEND\t\t\t0x0018\n\n \n#define USB_DMAC_XFER_SHIFT\t5\n#define USB_DMAC_XFER_SIZE\t(1 << USB_DMAC_XFER_SHIFT)\n#define USB_DMAC_CHCR_TS\tUSB_DMACHCR_TS_32B\n#define USB_DMAC_SLAVE_BUSWIDTH\tDMA_SLAVE_BUSWIDTH_32_BYTES\n\n \n#define USB_DMAC_INITIAL_NR_DESC\t16\n#define USB_DMAC_INITIAL_NR_SG\t\t8\n\n \n\nstatic void usb_dmac_write(struct usb_dmac *dmac, u32 reg, u32 data)\n{\n\twritel(data, dmac->iomem + reg);\n}\n\nstatic u32 usb_dmac_read(struct usb_dmac *dmac, u32 reg)\n{\n\treturn readl(dmac->iomem + reg);\n}\n\nstatic u32 usb_dmac_chan_read(struct usb_dmac_chan *chan, u32 reg)\n{\n\treturn readl(chan->iomem + reg);\n}\n\nstatic void usb_dmac_chan_write(struct usb_dmac_chan *chan, u32 reg, u32 data)\n{\n\twritel(data, chan->iomem + reg);\n}\n\n \n\nstatic bool usb_dmac_chan_is_busy(struct usb_dmac_chan *chan)\n{\n\tu32 chcr = usb_dmac_chan_read(chan, USB_DMACHCR);\n\n\treturn (chcr & (USB_DMACHCR_DE | USB_DMACHCR_TE)) == USB_DMACHCR_DE;\n}\n\nstatic u32 usb_dmac_calc_tend(u32 size)\n{\n\t \n\treturn 0xffffffff << (32 - (size % USB_DMAC_XFER_SIZE ?\t:\n\t\t\t\t\t\tUSB_DMAC_XFER_SIZE));\n}\n\n \nstatic void usb_dmac_chan_start_sg(struct usb_dmac_chan *chan,\n\t\t\t\t   unsigned int index)\n{\n\tstruct usb_dmac_desc *desc = chan->desc;\n\tstruct usb_dmac_sg *sg = desc->sg + index;\n\tdma_addr_t src_addr = 0, dst_addr = 0;\n\n\tWARN_ON_ONCE(usb_dmac_chan_is_busy(chan));\n\n\tif (desc->direction == DMA_DEV_TO_MEM)\n\t\tdst_addr = sg->mem_addr;\n\telse\n\t\tsrc_addr = sg->mem_addr;\n\n\tdev_dbg(chan->vc.chan.device->dev,\n\t\t\"chan%u: queue sg %p: %u@%pad -> %pad\\n\",\n\t\tchan->index, sg, sg->size, &src_addr, &dst_addr);\n\n\tusb_dmac_chan_write(chan, USB_DMASAR, src_addr & 0xffffffff);\n\tusb_dmac_chan_write(chan, USB_DMADAR, dst_addr & 0xffffffff);\n\tusb_dmac_chan_write(chan, USB_DMATCR,\n\t\t\t    DIV_ROUND_UP(sg->size, USB_DMAC_XFER_SIZE));\n\tusb_dmac_chan_write(chan, USB_DMATEND, usb_dmac_calc_tend(sg->size));\n\n\tusb_dmac_chan_write(chan, USB_DMACHCR, USB_DMAC_CHCR_TS |\n\t\t\tUSB_DMACHCR_NULLE | USB_DMACHCR_IE | USB_DMACHCR_DE);\n}\n\n \nstatic void usb_dmac_chan_start_desc(struct usb_dmac_chan *chan)\n{\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&chan->vc);\n\tif (!vd) {\n\t\tchan->desc = NULL;\n\t\treturn;\n\t}\n\n\t \n\tlist_del(&vd->node);\n\n\tchan->desc = to_usb_dmac_desc(vd);\n\tchan->desc->sg_index = 0;\n\tusb_dmac_chan_start_sg(chan, 0);\n}\n\nstatic int usb_dmac_init(struct usb_dmac *dmac)\n{\n\tu16 dmaor;\n\n\t \n\tusb_dmac_write(dmac, USB_DMAOR, USB_DMAOR_DME);\n\n\tdmaor = usb_dmac_read(dmac, USB_DMAOR);\n\tif ((dmaor & (USB_DMAOR_AE | USB_DMAOR_DME)) != USB_DMAOR_DME) {\n\t\tdev_warn(dmac->dev, \"DMAOR initialization failed.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int usb_dmac_desc_alloc(struct usb_dmac_chan *chan, unsigned int sg_len,\n\t\t\t       gfp_t gfp)\n{\n\tstruct usb_dmac_desc *desc;\n\tunsigned long flags;\n\n\tdesc = kzalloc(struct_size(desc, sg, sg_len), gfp);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tdesc->sg_allocated_len = sg_len;\n\tINIT_LIST_HEAD(&desc->node);\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\tlist_add_tail(&desc->node, &chan->desc_freed);\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic void usb_dmac_desc_free(struct usb_dmac_chan *chan)\n{\n\tstruct usb_dmac_desc *desc, *_desc;\n\tLIST_HEAD(list);\n\n\tlist_splice_init(&chan->desc_freed, &list);\n\tlist_splice_init(&chan->desc_got, &list);\n\n\tlist_for_each_entry_safe(desc, _desc, &list, node) {\n\t\tlist_del(&desc->node);\n\t\tkfree(desc);\n\t}\n\tchan->descs_allocated = 0;\n}\n\nstatic struct usb_dmac_desc *usb_dmac_desc_get(struct usb_dmac_chan *chan,\n\t\t\t\t\t       unsigned int sg_len, gfp_t gfp)\n{\n\tstruct usb_dmac_desc *desc = NULL;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\tlist_for_each_entry(desc, &chan->desc_freed, node) {\n\t\tif (sg_len <= desc->sg_allocated_len) {\n\t\t\tlist_move_tail(&desc->node, &chan->desc_got);\n\t\t\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\t\t\treturn desc;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\n\t \n\tif (!usb_dmac_desc_alloc(chan, sg_len, gfp)) {\n\t\t \n\t\tspin_lock_irqsave(&chan->vc.lock, flags);\n\t\tdesc = list_last_entry(&chan->desc_freed, struct usb_dmac_desc,\n\t\t\t\t       node);\n\t\tlist_move_tail(&desc->node, &chan->desc_got);\n\t\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\t\treturn desc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void usb_dmac_desc_put(struct usb_dmac_chan *chan,\n\t\t\t      struct usb_dmac_desc *desc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\tlist_move_tail(&desc->node, &chan->desc_freed);\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n}\n\n \n\nstatic void usb_dmac_soft_reset(struct usb_dmac_chan *uchan)\n{\n\tstruct dma_chan *chan = &uchan->vc.chan;\n\tstruct usb_dmac *dmac = to_usb_dmac(chan->device);\n\tint i;\n\n\t \n\tfor (i = 0; i < dmac->n_channels; ++i) {\n\t\tif (usb_dmac_chan_is_busy(uchan))\n\t\t\treturn;\n\t}\n\n\tusb_dmac_write(dmac, USB_DMAOR, 0);\n\tusb_dmac_write(dmac, USB_DMASWR, USB_DMASWR_SWR);\n\tudelay(100);\n\tusb_dmac_write(dmac, USB_DMASWR, 0);\n\tusb_dmac_write(dmac, USB_DMAOR, 1);\n}\n\nstatic void usb_dmac_chan_halt(struct usb_dmac_chan *chan)\n{\n\tu32 chcr = usb_dmac_chan_read(chan, USB_DMACHCR);\n\n\tchcr &= ~(USB_DMACHCR_IE | USB_DMACHCR_TE | USB_DMACHCR_DE);\n\tusb_dmac_chan_write(chan, USB_DMACHCR, chcr);\n\n\tusb_dmac_soft_reset(chan);\n}\n\nstatic void usb_dmac_stop(struct usb_dmac *dmac)\n{\n\tusb_dmac_write(dmac, USB_DMAOR, 0);\n}\n\n \n\nstatic int usb_dmac_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tint ret;\n\n\twhile (uchan->descs_allocated < USB_DMAC_INITIAL_NR_DESC) {\n\t\tret = usb_dmac_desc_alloc(uchan, USB_DMAC_INITIAL_NR_SG,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tusb_dmac_desc_free(uchan);\n\t\t\treturn ret;\n\t\t}\n\t\tuchan->descs_allocated++;\n\t}\n\n\treturn pm_runtime_get_sync(chan->device->dev);\n}\n\nstatic void usb_dmac_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&uchan->vc.lock, flags);\n\tusb_dmac_chan_halt(uchan);\n\tspin_unlock_irqrestore(&uchan->vc.lock, flags);\n\n\tusb_dmac_desc_free(uchan);\n\tvchan_free_chan_resources(&uchan->vc);\n\n\tpm_runtime_put(chan->device->dev);\n}\n\nstatic struct dma_async_tx_descriptor *\nusb_dmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\t       unsigned int sg_len, enum dma_transfer_direction dir,\n\t\t       unsigned long dma_flags, void *context)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tstruct usb_dmac_desc *desc;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (!sg_len) {\n\t\tdev_warn(chan->device->dev,\n\t\t\t \"%s: bad parameter: len=%d\\n\", __func__, sg_len);\n\t\treturn NULL;\n\t}\n\n\tdesc = usb_dmac_desc_get(uchan, sg_len, GFP_NOWAIT);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->direction = dir;\n\tdesc->sg_len = sg_len;\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tdesc->sg[i].mem_addr = sg_dma_address(sg);\n\t\tdesc->sg[i].size = sg_dma_len(sg);\n\t}\n\n\treturn vchan_tx_prep(&uchan->vc, &desc->vd, dma_flags);\n}\n\nstatic int usb_dmac_chan_terminate_all(struct dma_chan *chan)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tstruct usb_dmac_desc *desc, *_desc;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\tLIST_HEAD(list);\n\n\tspin_lock_irqsave(&uchan->vc.lock, flags);\n\tusb_dmac_chan_halt(uchan);\n\tvchan_get_all_descriptors(&uchan->vc, &head);\n\tif (uchan->desc)\n\t\tuchan->desc = NULL;\n\tlist_splice_init(&uchan->desc_got, &list);\n\tlist_for_each_entry_safe(desc, _desc, &list, node)\n\t\tlist_move_tail(&desc->node, &uchan->desc_freed);\n\tspin_unlock_irqrestore(&uchan->vc.lock, flags);\n\tvchan_dma_desc_free_list(&uchan->vc, &head);\n\n\treturn 0;\n}\n\nstatic unsigned int usb_dmac_get_current_residue(struct usb_dmac_chan *chan,\n\t\t\t\t\t\t struct usb_dmac_desc *desc,\n\t\t\t\t\t\t unsigned int sg_index)\n{\n\tstruct usb_dmac_sg *sg = desc->sg + sg_index;\n\tu32 mem_addr = sg->mem_addr & 0xffffffff;\n\tunsigned int residue = sg->size;\n\n\t \n\tif (desc->direction == DMA_DEV_TO_MEM)\n\t\tresidue -= usb_dmac_chan_read(chan, USB_DMADAR) - mem_addr;\n\telse\n\t\tresidue -= usb_dmac_chan_read(chan, USB_DMASAR) - mem_addr;\n\n\treturn residue;\n}\n\nstatic u32 usb_dmac_chan_get_residue_if_complete(struct usb_dmac_chan *chan,\n\t\t\t\t\t\t dma_cookie_t cookie)\n{\n\tstruct usb_dmac_desc *desc;\n\tu32 residue = 0;\n\n\tlist_for_each_entry_reverse(desc, &chan->desc_freed, node) {\n\t\tif (desc->done_cookie == cookie) {\n\t\t\tresidue = desc->residue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn residue;\n}\n\nstatic u32 usb_dmac_chan_get_residue(struct usb_dmac_chan *chan,\n\t\t\t\t     dma_cookie_t cookie)\n{\n\tu32 residue = 0;\n\tstruct virt_dma_desc *vd;\n\tstruct usb_dmac_desc *desc = chan->desc;\n\tint i;\n\n\tif (!desc) {\n\t\tvd = vchan_find_desc(&chan->vc, cookie);\n\t\tif (!vd)\n\t\t\treturn 0;\n\t\tdesc = to_usb_dmac_desc(vd);\n\t}\n\n\t \n\tfor (i = desc->sg_index + 1; i < desc->sg_len; i++)\n\t\tresidue += desc->sg[i].size;\n\n\t \n\tresidue += usb_dmac_get_current_residue(chan, desc, desc->sg_index);\n\n\treturn residue;\n}\n\nstatic enum dma_status usb_dmac_tx_status(struct dma_chan *chan,\n\t\t\t\t\t  dma_cookie_t cookie,\n\t\t\t\t\t  struct dma_tx_state *txstate)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tenum dma_status status;\n\tunsigned int residue = 0;\n\tunsigned long flags;\n\n\tstatus = dma_cookie_status(chan, cookie, txstate);\n\t \n\tif (!txstate)\n\t\treturn status;\n\n\tspin_lock_irqsave(&uchan->vc.lock, flags);\n\tif (status == DMA_COMPLETE)\n\t\tresidue = usb_dmac_chan_get_residue_if_complete(uchan, cookie);\n\telse\n\t\tresidue = usb_dmac_chan_get_residue(uchan, cookie);\n\tspin_unlock_irqrestore(&uchan->vc.lock, flags);\n\n\tdma_set_residue(txstate, residue);\n\n\treturn status;\n}\n\nstatic void usb_dmac_issue_pending(struct dma_chan *chan)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uchan->vc.lock, flags);\n\tif (vchan_issue_pending(&uchan->vc) && !uchan->desc)\n\t\tusb_dmac_chan_start_desc(uchan);\n\tspin_unlock_irqrestore(&uchan->vc.lock, flags);\n}\n\nstatic void usb_dmac_virt_desc_free(struct virt_dma_desc *vd)\n{\n\tstruct usb_dmac_desc *desc = to_usb_dmac_desc(vd);\n\tstruct usb_dmac_chan *chan = to_usb_dmac_chan(vd->tx.chan);\n\n\tusb_dmac_desc_put(chan, desc);\n}\n\n \n\nstatic void usb_dmac_isr_transfer_end(struct usb_dmac_chan *chan)\n{\n\tstruct usb_dmac_desc *desc = chan->desc;\n\n\tBUG_ON(!desc);\n\n\tif (++desc->sg_index < desc->sg_len) {\n\t\tusb_dmac_chan_start_sg(chan, desc->sg_index);\n\t} else {\n\t\tdesc->residue = usb_dmac_get_current_residue(chan, desc,\n\t\t\t\t\t\t\tdesc->sg_index - 1);\n\t\tdesc->done_cookie = desc->vd.tx.cookie;\n\t\tdesc->vd.tx_result.result = DMA_TRANS_NOERROR;\n\t\tdesc->vd.tx_result.residue = desc->residue;\n\t\tvchan_cookie_complete(&desc->vd);\n\n\t\t \n\t\tusb_dmac_chan_start_desc(chan);\n\t}\n}\n\nstatic irqreturn_t usb_dmac_isr_channel(int irq, void *dev)\n{\n\tstruct usb_dmac_chan *chan = dev;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 mask = 0;\n\tu32 chcr;\n\tbool xfer_end = false;\n\n\tspin_lock(&chan->vc.lock);\n\n\tchcr = usb_dmac_chan_read(chan, USB_DMACHCR);\n\tif (chcr & (USB_DMACHCR_TE | USB_DMACHCR_SP)) {\n\t\tmask |= USB_DMACHCR_DE | USB_DMACHCR_TE | USB_DMACHCR_SP;\n\t\tif (chcr & USB_DMACHCR_DE)\n\t\t\txfer_end = true;\n\t\tret |= IRQ_HANDLED;\n\t}\n\tif (chcr & USB_DMACHCR_NULL) {\n\t\t \n\t\tmask |= USB_DMACHCR_NULL;\n\t\tchcr |= USB_DMACHCR_FTE;\n\t\tret |= IRQ_HANDLED;\n\t}\n\tif (mask)\n\t\tusb_dmac_chan_write(chan, USB_DMACHCR, chcr & ~mask);\n\n\tif (xfer_end)\n\t\tusb_dmac_isr_transfer_end(chan);\n\n\tspin_unlock(&chan->vc.lock);\n\n\treturn ret;\n}\n\n \n\nstatic bool usb_dmac_chan_filter(struct dma_chan *chan, void *arg)\n{\n\tstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\n\tstruct of_phandle_args *dma_spec = arg;\n\n\t \n\tif (uchan->index != dma_spec->args[0])\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct dma_chan *usb_dmac_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t  struct of_dma *ofdma)\n{\n\tstruct dma_chan *chan;\n\tdma_cap_mask_t mask;\n\n\tif (dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\t \n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tchan = __dma_request_channel(&mask, usb_dmac_chan_filter, dma_spec,\n\t\t\t\t     ofdma->of_node);\n\tif (!chan)\n\t\treturn NULL;\n\n\treturn chan;\n}\n\n \n\n#ifdef CONFIG_PM\nstatic int usb_dmac_runtime_suspend(struct device *dev)\n{\n\tstruct usb_dmac *dmac = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < dmac->n_channels; ++i) {\n\t\tif (!dmac->channels[i].iomem)\n\t\t\tbreak;\n\t\tusb_dmac_chan_halt(&dmac->channels[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_dmac_runtime_resume(struct device *dev)\n{\n\tstruct usb_dmac *dmac = dev_get_drvdata(dev);\n\n\treturn usb_dmac_init(dmac);\n}\n#endif  \n\nstatic const struct dev_pm_ops usb_dmac_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(usb_dmac_runtime_suspend, usb_dmac_runtime_resume,\n\t\t\t   NULL)\n};\n\n \n\nstatic int usb_dmac_chan_probe(struct usb_dmac *dmac,\n\t\t\t       struct usb_dmac_chan *uchan,\n\t\t\t       unsigned int index)\n{\n\tstruct platform_device *pdev = to_platform_device(dmac->dev);\n\tchar pdev_irqname[5];\n\tchar *irqname;\n\tint ret;\n\n\tuchan->index = index;\n\tuchan->iomem = dmac->iomem + USB_DMAC_CHAN_OFFSET(index);\n\n\t \n\tsprintf(pdev_irqname, \"ch%u\", index);\n\tuchan->irq = platform_get_irq_byname(pdev, pdev_irqname);\n\tif (uchan->irq < 0)\n\t\treturn -ENODEV;\n\n\tirqname = devm_kasprintf(dmac->dev, GFP_KERNEL, \"%s:%u\",\n\t\t\t\t dev_name(dmac->dev), index);\n\tif (!irqname)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(dmac->dev, uchan->irq, usb_dmac_isr_channel,\n\t\t\t       IRQF_SHARED, irqname, uchan);\n\tif (ret) {\n\t\tdev_err(dmac->dev, \"failed to request IRQ %u (%d)\\n\",\n\t\t\tuchan->irq, ret);\n\t\treturn ret;\n\t}\n\n\tuchan->vc.desc_free = usb_dmac_virt_desc_free;\n\tvchan_init(&uchan->vc, &dmac->engine);\n\tINIT_LIST_HEAD(&uchan->desc_freed);\n\tINIT_LIST_HEAD(&uchan->desc_got);\n\n\treturn 0;\n}\n\nstatic int usb_dmac_parse_of(struct device *dev, struct usb_dmac *dmac)\n{\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"dma-channels\", &dmac->n_channels);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to read dma-channels property\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dmac->n_channels <= 0 || dmac->n_channels >= 100) {\n\t\tdev_err(dev, \"invalid number of channels %u\\n\",\n\t\t\tdmac->n_channels);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_dmac_probe(struct platform_device *pdev)\n{\n\tconst enum dma_slave_buswidth widths = USB_DMAC_SLAVE_BUSWIDTH;\n\tstruct dma_device *engine;\n\tstruct usb_dmac *dmac;\n\tunsigned int i;\n\tint ret;\n\n\tdmac = devm_kzalloc(&pdev->dev, sizeof(*dmac), GFP_KERNEL);\n\tif (!dmac)\n\t\treturn -ENOMEM;\n\n\tdmac->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dmac);\n\n\tret = usb_dmac_parse_of(&pdev->dev, dmac);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdmac->channels = devm_kcalloc(&pdev->dev, dmac->n_channels,\n\t\t\t\t      sizeof(*dmac->channels), GFP_KERNEL);\n\tif (!dmac->channels)\n\t\treturn -ENOMEM;\n\n\t \n\tdmac->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dmac->iomem))\n\t\treturn PTR_ERR(dmac->iomem);\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"runtime PM get sync failed (%d)\\n\", ret);\n\t\tgoto error_pm;\n\t}\n\n\tret = usb_dmac_init(dmac);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to reset device\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&dmac->engine.channels);\n\n\tfor (i = 0; i < dmac->n_channels; ++i) {\n\t\tret = usb_dmac_chan_probe(dmac, &dmac->channels[i], i);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tret = of_dma_controller_register(pdev->dev.of_node, usb_dmac_of_xlate,\n\t\t\t\t\t NULL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tengine = &dmac->engine;\n\tdma_cap_set(DMA_SLAVE, engine->cap_mask);\n\n\tengine->dev = &pdev->dev;\n\n\tengine->src_addr_widths = widths;\n\tengine->dst_addr_widths = widths;\n\tengine->directions = BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\n\tengine->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\n\tengine->device_alloc_chan_resources = usb_dmac_alloc_chan_resources;\n\tengine->device_free_chan_resources = usb_dmac_free_chan_resources;\n\tengine->device_prep_slave_sg = usb_dmac_prep_slave_sg;\n\tengine->device_terminate_all = usb_dmac_chan_terminate_all;\n\tengine->device_tx_status = usb_dmac_tx_status;\n\tengine->device_issue_pending = usb_dmac_issue_pending;\n\n\tret = dma_async_device_register(engine);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpm_runtime_put(&pdev->dev);\n\treturn 0;\n\nerror:\n\tof_dma_controller_free(pdev->dev.of_node);\nerror_pm:\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void usb_dmac_chan_remove(struct usb_dmac *dmac,\n\t\t\t\t struct usb_dmac_chan *uchan)\n{\n\tusb_dmac_chan_halt(uchan);\n\tdevm_free_irq(dmac->dev, uchan->irq, uchan);\n}\n\nstatic int usb_dmac_remove(struct platform_device *pdev)\n{\n\tstruct usb_dmac *dmac = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < dmac->n_channels; ++i)\n\t\tusb_dmac_chan_remove(dmac, &dmac->channels[i]);\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&dmac->engine);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void usb_dmac_shutdown(struct platform_device *pdev)\n{\n\tstruct usb_dmac *dmac = platform_get_drvdata(pdev);\n\n\tusb_dmac_stop(dmac);\n}\n\nstatic const struct of_device_id usb_dmac_of_ids[] = {\n\t{ .compatible = \"renesas,usb-dmac\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, usb_dmac_of_ids);\n\nstatic struct platform_driver usb_dmac_driver = {\n\t.driver\t\t= {\n\t\t.pm\t= &usb_dmac_pm,\n\t\t.name\t= \"usb-dmac\",\n\t\t.of_match_table = usb_dmac_of_ids,\n\t},\n\t.probe\t\t= usb_dmac_probe,\n\t.remove\t\t= usb_dmac_remove,\n\t.shutdown\t= usb_dmac_shutdown,\n};\n\nmodule_platform_driver(usb_dmac_driver);\n\nMODULE_DESCRIPTION(\"Renesas USB DMA Controller Driver\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}