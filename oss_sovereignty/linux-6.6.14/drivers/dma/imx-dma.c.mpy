{
  "module_name": "imx-dma.c",
  "hash_id": "e786127a041dc64a4828d5cddab04d607095a09c16d32c8b8020cacaf4dab080",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/imx-dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n\n#include <asm/irq.h>\n#include <linux/dma/imx-dma.h>\n\n#include \"dmaengine.h\"\n#define IMXDMA_MAX_CHAN_DESCRIPTORS\t16\n#define IMX_DMA_CHANNELS  16\n\n#define IMX_DMA_2D_SLOTS\t2\n#define IMX_DMA_2D_SLOT_A\t0\n#define IMX_DMA_2D_SLOT_B\t1\n\n#define IMX_DMA_LENGTH_LOOP\t((unsigned int)-1)\n#define IMX_DMA_MEMSIZE_32\t(0 << 4)\n#define IMX_DMA_MEMSIZE_8\t(1 << 4)\n#define IMX_DMA_MEMSIZE_16\t(2 << 4)\n#define IMX_DMA_TYPE_LINEAR\t(0 << 10)\n#define IMX_DMA_TYPE_2D\t\t(1 << 10)\n#define IMX_DMA_TYPE_FIFO\t(2 << 10)\n\n#define IMX_DMA_ERR_BURST     (1 << 0)\n#define IMX_DMA_ERR_REQUEST   (1 << 1)\n#define IMX_DMA_ERR_TRANSFER  (1 << 2)\n#define IMX_DMA_ERR_BUFFER    (1 << 3)\n#define IMX_DMA_ERR_TIMEOUT   (1 << 4)\n\n#define DMA_DCR     0x00\t\t \n#define DMA_DISR    0x04\t\t \n#define DMA_DIMR    0x08\t\t \n#define DMA_DBTOSR  0x0c\t\t \n#define DMA_DRTOSR  0x10\t\t \n#define DMA_DSESR   0x14\t\t \n#define DMA_DBOSR   0x18\t\t \n#define DMA_DBTOCR  0x1c\t\t \n#define DMA_WSRA    0x40\t\t \n#define DMA_XSRA    0x44\t\t \n#define DMA_YSRA    0x48\t\t \n#define DMA_WSRB    0x4c\t\t \n#define DMA_XSRB    0x50\t\t \n#define DMA_YSRB    0x54\t\t \n#define DMA_SAR(x)  (0x80 + ((x) << 6))\t \n#define DMA_DAR(x)  (0x84 + ((x) << 6))\t \n#define DMA_CNTR(x) (0x88 + ((x) << 6))\t \n#define DMA_CCR(x)  (0x8c + ((x) << 6))\t \n#define DMA_RSSR(x) (0x90 + ((x) << 6))\t \n#define DMA_BLR(x)  (0x94 + ((x) << 6))\t \n#define DMA_RTOR(x) (0x98 + ((x) << 6))\t \n#define DMA_BUCR(x) (0x98 + ((x) << 6))\t \n#define DMA_CCNR(x) (0x9C + ((x) << 6))\t \n\n#define DCR_DRST           (1<<1)\n#define DCR_DEN            (1<<0)\n#define DBTOCR_EN          (1<<15)\n#define DBTOCR_CNT(x)      ((x) & 0x7fff)\n#define CNTR_CNT(x)        ((x) & 0xffffff)\n#define CCR_ACRPT          (1<<14)\n#define CCR_DMOD_LINEAR    (0x0 << 12)\n#define CCR_DMOD_2D        (0x1 << 12)\n#define CCR_DMOD_FIFO      (0x2 << 12)\n#define CCR_DMOD_EOBFIFO   (0x3 << 12)\n#define CCR_SMOD_LINEAR    (0x0 << 10)\n#define CCR_SMOD_2D        (0x1 << 10)\n#define CCR_SMOD_FIFO      (0x2 << 10)\n#define CCR_SMOD_EOBFIFO   (0x3 << 10)\n#define CCR_MDIR_DEC       (1<<9)\n#define CCR_MSEL_B         (1<<8)\n#define CCR_DSIZ_32        (0x0 << 6)\n#define CCR_DSIZ_8         (0x1 << 6)\n#define CCR_DSIZ_16        (0x2 << 6)\n#define CCR_SSIZ_32        (0x0 << 4)\n#define CCR_SSIZ_8         (0x1 << 4)\n#define CCR_SSIZ_16        (0x2 << 4)\n#define CCR_REN            (1<<3)\n#define CCR_RPT            (1<<2)\n#define CCR_FRC            (1<<1)\n#define CCR_CEN            (1<<0)\n#define RTOR_EN            (1<<15)\n#define RTOR_CLK           (1<<14)\n#define RTOR_PSC           (1<<13)\n\nenum  imxdma_prep_type {\n\tIMXDMA_DESC_MEMCPY,\n\tIMXDMA_DESC_INTERLEAVED,\n\tIMXDMA_DESC_SLAVE_SG,\n\tIMXDMA_DESC_CYCLIC,\n};\n\nstruct imx_dma_2d_config {\n\tu16\t\txsr;\n\tu16\t\tysr;\n\tu16\t\twsr;\n\tint\t\tcount;\n};\n\nstruct imxdma_desc {\n\tstruct list_head\t\tnode;\n\tstruct dma_async_tx_descriptor\tdesc;\n\tenum dma_status\t\t\tstatus;\n\tdma_addr_t\t\t\tsrc;\n\tdma_addr_t\t\t\tdest;\n\tsize_t\t\t\t\tlen;\n\tenum dma_transfer_direction\tdirection;\n\tenum imxdma_prep_type\t\ttype;\n\t \n\tunsigned int\t\t\tconfig_port;\n\tunsigned int\t\t\tconfig_mem;\n\t \n\tunsigned int\t\t\tx;\n\tunsigned int\t\t\ty;\n\tunsigned int\t\t\tw;\n\t \n\tstruct scatterlist\t\t*sg;\n\tunsigned int\t\t\tsgcount;\n};\n\nstruct imxdma_channel {\n\tint\t\t\t\thw_chaining;\n\tstruct timer_list\t\twatchdog;\n\tstruct imxdma_engine\t\t*imxdma;\n\tunsigned int\t\t\tchannel;\n\n\tstruct tasklet_struct\t\tdma_tasklet;\n\tstruct list_head\t\tld_free;\n\tstruct list_head\t\tld_queue;\n\tstruct list_head\t\tld_active;\n\tint\t\t\t\tdescs_allocated;\n\tenum dma_slave_buswidth\t\tword_size;\n\tdma_addr_t\t\t\tper_address;\n\tu32\t\t\t\twatermark_level;\n\tstruct dma_chan\t\t\tchan;\n\tstruct dma_async_tx_descriptor\tdesc;\n\tenum dma_status\t\t\tstatus;\n\tint\t\t\t\tdma_request;\n\tstruct scatterlist\t\t*sg_list;\n\tu32\t\t\t\tccr_from_device;\n\tu32\t\t\t\tccr_to_device;\n\tbool\t\t\t\tenabled_2d;\n\tint\t\t\t\tslot_2d;\n\tunsigned int\t\t\tirq;\n\tstruct dma_slave_config\t\tconfig;\n};\n\nenum imx_dma_type {\n\tIMX1_DMA,\n\tIMX21_DMA,\n\tIMX27_DMA,\n};\n\nstruct imxdma_engine {\n\tstruct device\t\t\t*dev;\n\tstruct dma_device\t\tdma_device;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*dma_ahb;\n\tstruct clk\t\t\t*dma_ipg;\n\tspinlock_t\t\t\tlock;\n\tstruct imx_dma_2d_config\tslots_2d[IMX_DMA_2D_SLOTS];\n\tstruct imxdma_channel\t\tchannel[IMX_DMA_CHANNELS];\n\tenum imx_dma_type\t\tdevtype;\n\tunsigned int\t\t\tirq;\n\tunsigned int\t\t\tirq_err;\n\n};\n\nstruct imxdma_filter_data {\n\tstruct imxdma_engine\t*imxdma;\n\tint\t\t\t request;\n};\n\nstatic const struct of_device_id imx_dma_of_dev_id[] = {\n\t{\n\t\t.compatible = \"fsl,imx1-dma\", .data = (const void *)IMX1_DMA,\n\t}, {\n\t\t.compatible = \"fsl,imx21-dma\", .data = (const void *)IMX21_DMA,\n\t}, {\n\t\t.compatible = \"fsl,imx27-dma\", .data = (const void *)IMX27_DMA,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imx_dma_of_dev_id);\n\nstatic inline int is_imx1_dma(struct imxdma_engine *imxdma)\n{\n\treturn imxdma->devtype == IMX1_DMA;\n}\n\nstatic inline int is_imx27_dma(struct imxdma_engine *imxdma)\n{\n\treturn imxdma->devtype == IMX27_DMA;\n}\n\nstatic struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct imxdma_channel, chan);\n}\n\nstatic inline bool imxdma_chan_is_doing_cyclic(struct imxdma_channel *imxdmac)\n{\n\tstruct imxdma_desc *desc;\n\n\tif (!list_empty(&imxdmac->ld_active)) {\n\t\tdesc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc,\n\t\t\t\t\tnode);\n\t\tif (desc->type == IMXDMA_DESC_CYCLIC)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\nstatic void imx_dmav1_writel(struct imxdma_engine *imxdma, unsigned val,\n\t\t\t     unsigned offset)\n{\n\t__raw_writel(val, imxdma->base + offset);\n}\n\nstatic unsigned imx_dmav1_readl(struct imxdma_engine *imxdma, unsigned offset)\n{\n\treturn __raw_readl(imxdma->base + offset);\n}\n\nstatic int imxdma_hw_chain(struct imxdma_channel *imxdmac)\n{\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\n\tif (is_imx27_dma(imxdma))\n\t\treturn imxdmac->hw_chaining;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline void imxdma_sg_next(struct imxdma_desc *d)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct scatterlist *sg = d->sg;\n\tsize_t now;\n\n\tnow = min_t(size_t, d->len, sg_dma_len(sg));\n\tif (d->len != IMX_DMA_LENGTH_LOOP)\n\t\td->len -= now;\n\n\tif (d->direction == DMA_DEV_TO_MEM)\n\t\timx_dmav1_writel(imxdma, sg->dma_address,\n\t\t\t\t DMA_DAR(imxdmac->channel));\n\telse\n\t\timx_dmav1_writel(imxdma, sg->dma_address,\n\t\t\t\t DMA_SAR(imxdmac->channel));\n\n\timx_dmav1_writel(imxdma, now, DMA_CNTR(imxdmac->channel));\n\n\tdev_dbg(imxdma->dev, \" %s channel: %d dst 0x%08x, src 0x%08x, \"\n\t\t\"size 0x%08x\\n\", __func__, imxdmac->channel,\n\t\t imx_dmav1_readl(imxdma, DMA_DAR(imxdmac->channel)),\n\t\t imx_dmav1_readl(imxdma, DMA_SAR(imxdmac->channel)),\n\t\t imx_dmav1_readl(imxdma, DMA_CNTR(imxdmac->channel)));\n}\n\nstatic void imxdma_enable_hw(struct imxdma_desc *d)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tint channel = imxdmac->channel;\n\tunsigned long flags;\n\n\tdev_dbg(imxdma->dev, \"%s channel %d\\n\", __func__, channel);\n\n\tlocal_irq_save(flags);\n\n\timx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);\n\timx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) &\n\t\t\t ~(1 << channel), DMA_DIMR);\n\timx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) |\n\t\t\t CCR_CEN | CCR_ACRPT, DMA_CCR(channel));\n\n\tif (!is_imx1_dma(imxdma) &&\n\t\t\td->sg && imxdma_hw_chain(imxdmac)) {\n\t\td->sg = sg_next(d->sg);\n\t\tif (d->sg) {\n\t\t\tu32 tmp;\n\t\t\timxdma_sg_next(d);\n\t\t\ttmp = imx_dmav1_readl(imxdma, DMA_CCR(channel));\n\t\t\timx_dmav1_writel(imxdma, tmp | CCR_RPT | CCR_ACRPT,\n\t\t\t\t\t DMA_CCR(channel));\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void imxdma_disable_hw(struct imxdma_channel *imxdmac)\n{\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tint channel = imxdmac->channel;\n\tunsigned long flags;\n\n\tdev_dbg(imxdma->dev, \"%s channel %d\\n\", __func__, channel);\n\n\tif (imxdma_hw_chain(imxdmac))\n\t\tdel_timer(&imxdmac->watchdog);\n\n\tlocal_irq_save(flags);\n\timx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) |\n\t\t\t (1 << channel), DMA_DIMR);\n\timx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) &\n\t\t\t ~CCR_CEN, DMA_CCR(channel));\n\timx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);\n\tlocal_irq_restore(flags);\n}\n\nstatic void imxdma_watchdog(struct timer_list *t)\n{\n\tstruct imxdma_channel *imxdmac = from_timer(imxdmac, t, watchdog);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tint channel = imxdmac->channel;\n\n\timx_dmav1_writel(imxdma, 0, DMA_CCR(channel));\n\n\t \n\ttasklet_schedule(&imxdmac->dma_tasklet);\n\tdev_dbg(imxdma->dev, \"channel %d: watchdog timeout!\\n\",\n\t\timxdmac->channel);\n}\n\nstatic irqreturn_t imxdma_err_handler(int irq, void *dev_id)\n{\n\tstruct imxdma_engine *imxdma = dev_id;\n\tunsigned int err_mask;\n\tint i, disr;\n\tint errcode;\n\n\tdisr = imx_dmav1_readl(imxdma, DMA_DISR);\n\n\terr_mask = imx_dmav1_readl(imxdma, DMA_DBTOSR) |\n\t\t   imx_dmav1_readl(imxdma, DMA_DRTOSR) |\n\t\t   imx_dmav1_readl(imxdma, DMA_DSESR)  |\n\t\t   imx_dmav1_readl(imxdma, DMA_DBOSR);\n\n\tif (!err_mask)\n\t\treturn IRQ_HANDLED;\n\n\timx_dmav1_writel(imxdma, disr & err_mask, DMA_DISR);\n\n\tfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\n\t\tif (!(err_mask & (1 << i)))\n\t\t\tcontinue;\n\t\terrcode = 0;\n\n\t\tif (imx_dmav1_readl(imxdma, DMA_DBTOSR) & (1 << i)) {\n\t\t\timx_dmav1_writel(imxdma, 1 << i, DMA_DBTOSR);\n\t\t\terrcode |= IMX_DMA_ERR_BURST;\n\t\t}\n\t\tif (imx_dmav1_readl(imxdma, DMA_DRTOSR) & (1 << i)) {\n\t\t\timx_dmav1_writel(imxdma, 1 << i, DMA_DRTOSR);\n\t\t\terrcode |= IMX_DMA_ERR_REQUEST;\n\t\t}\n\t\tif (imx_dmav1_readl(imxdma, DMA_DSESR) & (1 << i)) {\n\t\t\timx_dmav1_writel(imxdma, 1 << i, DMA_DSESR);\n\t\t\terrcode |= IMX_DMA_ERR_TRANSFER;\n\t\t}\n\t\tif (imx_dmav1_readl(imxdma, DMA_DBOSR) & (1 << i)) {\n\t\t\timx_dmav1_writel(imxdma, 1 << i, DMA_DBOSR);\n\t\t\terrcode |= IMX_DMA_ERR_BUFFER;\n\t\t}\n\t\t \n\t\ttasklet_schedule(&imxdma->channel[i].dma_tasklet);\n\n\t\tdev_warn(imxdma->dev,\n\t\t\t \"DMA timeout on channel %d -%s%s%s%s\\n\", i,\n\t\t\t errcode & IMX_DMA_ERR_BURST ?    \" burst\" : \"\",\n\t\t\t errcode & IMX_DMA_ERR_REQUEST ?  \" request\" : \"\",\n\t\t\t errcode & IMX_DMA_ERR_TRANSFER ? \" transfer\" : \"\",\n\t\t\t errcode & IMX_DMA_ERR_BUFFER ?   \" buffer\" : \"\");\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void dma_irq_handle_channel(struct imxdma_channel *imxdmac)\n{\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tint chno = imxdmac->channel;\n\tstruct imxdma_desc *desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\tif (list_empty(&imxdmac->ld_active)) {\n\t\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\t\tgoto out;\n\t}\n\n\tdesc = list_first_entry(&imxdmac->ld_active,\n\t\t\t\tstruct imxdma_desc,\n\t\t\t\tnode);\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\n\tif (desc->sg) {\n\t\tu32 tmp;\n\t\tdesc->sg = sg_next(desc->sg);\n\n\t\tif (desc->sg) {\n\t\t\timxdma_sg_next(desc);\n\n\t\t\ttmp = imx_dmav1_readl(imxdma, DMA_CCR(chno));\n\n\t\t\tif (imxdma_hw_chain(imxdmac)) {\n\t\t\t\t \n\t\t\t\tmod_timer(&imxdmac->watchdog,\n\t\t\t\t\tjiffies + msecs_to_jiffies(500));\n\n\t\t\t\ttmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;\n\t\t\t\timx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));\n\t\t\t} else {\n\t\t\t\timx_dmav1_writel(imxdma, tmp & ~CCR_CEN,\n\t\t\t\t\t\t DMA_CCR(chno));\n\t\t\t\ttmp |= CCR_CEN;\n\t\t\t}\n\n\t\t\timx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));\n\n\t\t\tif (imxdma_chan_is_doing_cyclic(imxdmac))\n\t\t\t\t \n\t\t\t\ttasklet_schedule(&imxdmac->dma_tasklet);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (imxdma_hw_chain(imxdmac)) {\n\t\t\tdel_timer(&imxdmac->watchdog);\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\timx_dmav1_writel(imxdma, 0, DMA_CCR(chno));\n\t \n\ttasklet_schedule(&imxdmac->dma_tasklet);\n}\n\nstatic irqreturn_t dma_irq_handler(int irq, void *dev_id)\n{\n\tstruct imxdma_engine *imxdma = dev_id;\n\tint i, disr;\n\n\tif (!is_imx1_dma(imxdma))\n\t\timxdma_err_handler(irq, dev_id);\n\n\tdisr = imx_dmav1_readl(imxdma, DMA_DISR);\n\n\tdev_dbg(imxdma->dev, \"%s called, disr=0x%08x\\n\", __func__, disr);\n\n\timx_dmav1_writel(imxdma, disr, DMA_DISR);\n\tfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\n\t\tif (disr & (1 << i))\n\t\t\tdma_irq_handle_channel(&imxdma->channel[i]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imxdma_xfer_desc(struct imxdma_desc *d)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tint slot = -1;\n\tint i;\n\n\t \n\tswitch (d->type) {\n\tcase IMXDMA_DESC_INTERLEAVED:\n\t\t \n\t\tfor (i = 0; i < IMX_DMA_2D_SLOTS; i++) {\n\t\t\tif ((imxdma->slots_2d[i].count > 0) &&\n\t\t\t((imxdma->slots_2d[i].xsr != d->x) ||\n\t\t\t(imxdma->slots_2d[i].ysr != d->y) ||\n\t\t\t(imxdma->slots_2d[i].wsr != d->w)))\n\t\t\t\tcontinue;\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (slot < 0)\n\t\t\treturn -EBUSY;\n\n\t\timxdma->slots_2d[slot].xsr = d->x;\n\t\timxdma->slots_2d[slot].ysr = d->y;\n\t\timxdma->slots_2d[slot].wsr = d->w;\n\t\timxdma->slots_2d[slot].count++;\n\n\t\timxdmac->slot_2d = slot;\n\t\timxdmac->enabled_2d = true;\n\n\t\tif (slot == IMX_DMA_2D_SLOT_A) {\n\t\t\td->config_mem &= ~CCR_MSEL_B;\n\t\t\td->config_port &= ~CCR_MSEL_B;\n\t\t\timx_dmav1_writel(imxdma, d->x, DMA_XSRA);\n\t\t\timx_dmav1_writel(imxdma, d->y, DMA_YSRA);\n\t\t\timx_dmav1_writel(imxdma, d->w, DMA_WSRA);\n\t\t} else {\n\t\t\td->config_mem |= CCR_MSEL_B;\n\t\t\td->config_port |= CCR_MSEL_B;\n\t\t\timx_dmav1_writel(imxdma, d->x, DMA_XSRB);\n\t\t\timx_dmav1_writel(imxdma, d->y, DMA_YSRB);\n\t\t\timx_dmav1_writel(imxdma, d->w, DMA_WSRB);\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase IMXDMA_DESC_MEMCPY:\n\t\timx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));\n\t\timx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));\n\t\timx_dmav1_writel(imxdma, d->config_mem | (d->config_port << 2),\n\t\t\t DMA_CCR(imxdmac->channel));\n\n\t\timx_dmav1_writel(imxdma, d->len, DMA_CNTR(imxdmac->channel));\n\n\t\tdev_dbg(imxdma->dev,\n\t\t\t\"%s channel: %d dest=0x%08llx src=0x%08llx dma_length=%zu\\n\",\n\t\t\t__func__, imxdmac->channel,\n\t\t\t(unsigned long long)d->dest,\n\t\t\t(unsigned long long)d->src, d->len);\n\n\t\tbreak;\n\t \n\tcase IMXDMA_DESC_CYCLIC:\n\tcase IMXDMA_DESC_SLAVE_SG:\n\t\tif (d->direction == DMA_DEV_TO_MEM) {\n\t\t\timx_dmav1_writel(imxdma, imxdmac->per_address,\n\t\t\t\t\t DMA_SAR(imxdmac->channel));\n\t\t\timx_dmav1_writel(imxdma, imxdmac->ccr_from_device,\n\t\t\t\t\t DMA_CCR(imxdmac->channel));\n\n\t\t\tdev_dbg(imxdma->dev,\n\t\t\t\t\"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (dev2mem)\\n\",\n\t\t\t\t__func__, imxdmac->channel,\n\t\t\t\td->sg, d->sgcount, d->len,\n\t\t\t\t(unsigned long long)imxdmac->per_address);\n\t\t} else if (d->direction == DMA_MEM_TO_DEV) {\n\t\t\timx_dmav1_writel(imxdma, imxdmac->per_address,\n\t\t\t\t\t DMA_DAR(imxdmac->channel));\n\t\t\timx_dmav1_writel(imxdma, imxdmac->ccr_to_device,\n\t\t\t\t\t DMA_CCR(imxdmac->channel));\n\n\t\t\tdev_dbg(imxdma->dev,\n\t\t\t\t\"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (mem2dev)\\n\",\n\t\t\t\t__func__, imxdmac->channel,\n\t\t\t\td->sg, d->sgcount, d->len,\n\t\t\t\t(unsigned long long)imxdmac->per_address);\n\t\t} else {\n\t\t\tdev_err(imxdma->dev, \"%s channel: %d bad dma mode\\n\",\n\t\t\t\t__func__, imxdmac->channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\timxdma_sg_next(d);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\timxdma_enable_hw(d);\n\treturn 0;\n}\n\nstatic void imxdma_tasklet(struct tasklet_struct *t)\n{\n\tstruct imxdma_channel *imxdmac = from_tasklet(imxdmac, t, dma_tasklet);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc, *next_desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\n\tif (list_empty(&imxdmac->ld_active)) {\n\t\t \n\t\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\t\treturn;\n\t}\n\tdesc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc, node);\n\n\t \n\tif (imxdma_chan_is_doing_cyclic(imxdmac))\n\t\tgoto out;\n\telse\n\t\tdma_cookie_complete(&desc->desc);\n\n\t \n\tif (imxdmac->enabled_2d) {\n\t\timxdma->slots_2d[imxdmac->slot_2d].count--;\n\t\timxdmac->enabled_2d = false;\n\t}\n\n\tlist_move_tail(imxdmac->ld_active.next, &imxdmac->ld_free);\n\n\tif (!list_empty(&imxdmac->ld_queue)) {\n\t\tnext_desc = list_first_entry(&imxdmac->ld_queue,\n\t\t\t\t\t     struct imxdma_desc, node);\n\t\tlist_move_tail(imxdmac->ld_queue.next, &imxdmac->ld_active);\n\t\tif (imxdma_xfer_desc(next_desc) < 0)\n\t\t\tdev_warn(imxdma->dev, \"%s: channel: %d couldn't xfer desc\\n\",\n\t\t\t\t __func__, imxdmac->channel);\n\t}\nout:\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\n\tdmaengine_desc_get_callback_invoke(&desc->desc, NULL);\n}\n\nstatic int imxdma_terminate_all(struct dma_chan *chan)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tunsigned long flags;\n\n\timxdma_disable_hw(imxdmac);\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\tlist_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);\n\tlist_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\treturn 0;\n}\n\nstatic int imxdma_config_write(struct dma_chan *chan,\n\t\t\t       struct dma_slave_config *dmaengine_cfg,\n\t\t\t       enum dma_transfer_direction direction)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tunsigned int mode = 0;\n\n\tif (direction == DMA_DEV_TO_MEM) {\n\t\timxdmac->per_address = dmaengine_cfg->src_addr;\n\t\timxdmac->watermark_level = dmaengine_cfg->src_maxburst;\n\t\timxdmac->word_size = dmaengine_cfg->src_addr_width;\n\t} else {\n\t\timxdmac->per_address = dmaengine_cfg->dst_addr;\n\t\timxdmac->watermark_level = dmaengine_cfg->dst_maxburst;\n\t\timxdmac->word_size = dmaengine_cfg->dst_addr_width;\n\t}\n\n\tswitch (imxdmac->word_size) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tmode = IMX_DMA_MEMSIZE_8;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tmode = IMX_DMA_MEMSIZE_16;\n\t\tbreak;\n\tdefault:\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tmode = IMX_DMA_MEMSIZE_32;\n\t\tbreak;\n\t}\n\n\timxdmac->hw_chaining = 0;\n\n\timxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |\n\t\t((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |\n\t\tCCR_REN;\n\timxdmac->ccr_to_device =\n\t\t(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |\n\t\t((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;\n\timx_dmav1_writel(imxdma, imxdmac->dma_request,\n\t\t\t DMA_RSSR(imxdmac->channel));\n\n\t \n\timx_dmav1_writel(imxdma, imxdmac->watermark_level *\n\t\t\t imxdmac->word_size, DMA_BLR(imxdmac->channel));\n\n\treturn 0;\n}\n\nstatic int imxdma_config(struct dma_chan *chan,\n\t\t\t struct dma_slave_config *dmaengine_cfg)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\n\tmemcpy(&imxdmac->config, dmaengine_cfg, sizeof(*dmaengine_cfg));\n\n\treturn 0;\n}\n\nstatic enum dma_status imxdma_tx_status(struct dma_chan *chan,\n\t\t\t\t\t    dma_cookie_t cookie,\n\t\t\t\t\t    struct dma_tx_state *txstate)\n{\n\treturn dma_cookie_status(chan, cookie, txstate);\n}\n\nstatic dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tdma_cookie_t cookie;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\tlist_move_tail(imxdmac->ld_free.next, &imxdmac->ld_queue);\n\tcookie = dma_cookie_assign(tx);\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\n\treturn cookie;\n}\n\nstatic int imxdma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imx_dma_data *data = chan->private;\n\n\tif (data != NULL)\n\t\timxdmac->dma_request = data->dma_request;\n\n\twhile (imxdmac->descs_allocated < IMXDMA_MAX_CHAN_DESCRIPTORS) {\n\t\tstruct imxdma_desc *desc;\n\n\t\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\t\tif (!desc)\n\t\t\tbreak;\n\t\tdma_async_tx_descriptor_init(&desc->desc, chan);\n\t\tdesc->desc.tx_submit = imxdma_tx_submit;\n\t\t \n\t\tdesc->desc.flags = DMA_CTRL_ACK;\n\t\tdesc->status = DMA_COMPLETE;\n\n\t\tlist_add_tail(&desc->node, &imxdmac->ld_free);\n\t\timxdmac->descs_allocated++;\n\t}\n\n\tif (!imxdmac->descs_allocated)\n\t\treturn -ENOMEM;\n\n\treturn imxdmac->descs_allocated;\n}\n\nstatic void imxdma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc, *_desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\n\timxdma_disable_hw(imxdmac);\n\tlist_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);\n\tlist_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);\n\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n\n\tlist_for_each_entry_safe(desc, _desc, &imxdmac->ld_free, node) {\n\t\tkfree(desc);\n\t\timxdmac->descs_allocated--;\n\t}\n\tINIT_LIST_HEAD(&imxdmac->ld_free);\n\n\tkfree(imxdmac->sg_list);\n\timxdmac->sg_list = NULL;\n}\n\nstatic struct dma_async_tx_descriptor *imxdma_prep_slave_sg(\n\t\tstruct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct scatterlist *sg;\n\tint i, dma_length = 0;\n\tstruct imxdma_desc *desc;\n\n\tif (list_empty(&imxdmac->ld_free) ||\n\t    imxdma_chan_is_doing_cyclic(imxdmac))\n\t\treturn NULL;\n\n\tdesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tdma_length += sg_dma_len(sg);\n\t}\n\n\timxdma_config_write(chan, &imxdmac->config, direction);\n\n\tswitch (imxdmac->word_size) {\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tif (sg_dma_len(sgl) & 3 || sgl->dma_address & 3)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tif (sg_dma_len(sgl) & 1 || sgl->dma_address & 1)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tdesc->type = IMXDMA_DESC_SLAVE_SG;\n\tdesc->sg = sgl;\n\tdesc->sgcount = sg_len;\n\tdesc->len = dma_length;\n\tdesc->direction = direction;\n\tif (direction == DMA_DEV_TO_MEM) {\n\t\tdesc->src = imxdmac->per_address;\n\t} else {\n\t\tdesc->dest = imxdmac->per_address;\n\t}\n\tdesc->desc.callback = NULL;\n\tdesc->desc.callback_param = NULL;\n\n\treturn &desc->desc;\n}\n\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc;\n\tint i;\n\tunsigned int periods = buf_len / period_len;\n\n\tdev_dbg(imxdma->dev, \"%s channel: %d buf_len=%zu period_len=%zu\\n\",\n\t\t\t__func__, imxdmac->channel, buf_len, period_len);\n\n\tif (list_empty(&imxdmac->ld_free) ||\n\t    imxdma_chan_is_doing_cyclic(imxdmac))\n\t\treturn NULL;\n\n\tdesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\n\n\tkfree(imxdmac->sg_list);\n\n\timxdmac->sg_list = kcalloc(periods + 1,\n\t\t\tsizeof(struct scatterlist), GFP_ATOMIC);\n\tif (!imxdmac->sg_list)\n\t\treturn NULL;\n\n\tsg_init_table(imxdmac->sg_list, periods);\n\n\tfor (i = 0; i < periods; i++) {\n\t\tsg_assign_page(&imxdmac->sg_list[i], NULL);\n\t\timxdmac->sg_list[i].offset = 0;\n\t\timxdmac->sg_list[i].dma_address = dma_addr;\n\t\tsg_dma_len(&imxdmac->sg_list[i]) = period_len;\n\t\tdma_addr += period_len;\n\t}\n\n\t \n\tsg_chain(imxdmac->sg_list, periods + 1, imxdmac->sg_list);\n\n\tdesc->type = IMXDMA_DESC_CYCLIC;\n\tdesc->sg = imxdmac->sg_list;\n\tdesc->sgcount = periods;\n\tdesc->len = IMX_DMA_LENGTH_LOOP;\n\tdesc->direction = direction;\n\tif (direction == DMA_DEV_TO_MEM) {\n\t\tdesc->src = imxdmac->per_address;\n\t} else {\n\t\tdesc->dest = imxdmac->per_address;\n\t}\n\tdesc->desc.callback = NULL;\n\tdesc->desc.callback_param = NULL;\n\n\timxdma_config_write(chan, &imxdmac->config, direction);\n\n\treturn &desc->desc;\n}\n\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(\n\tstruct dma_chan *chan, dma_addr_t dest,\n\tdma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc;\n\n\tdev_dbg(imxdma->dev, \"%s channel: %d src=0x%llx dst=0x%llx len=%zu\\n\",\n\t\t__func__, imxdmac->channel, (unsigned long long)src,\n\t\t(unsigned long long)dest, len);\n\n\tif (list_empty(&imxdmac->ld_free) ||\n\t    imxdma_chan_is_doing_cyclic(imxdmac))\n\t\treturn NULL;\n\n\tdesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\n\n\tdesc->type = IMXDMA_DESC_MEMCPY;\n\tdesc->src = src;\n\tdesc->dest = dest;\n\tdesc->len = len;\n\tdesc->direction = DMA_MEM_TO_MEM;\n\tdesc->config_port = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;\n\tdesc->config_mem = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;\n\tdesc->desc.callback = NULL;\n\tdesc->desc.callback_param = NULL;\n\n\treturn &desc->desc;\n}\n\nstatic struct dma_async_tx_descriptor *imxdma_prep_dma_interleaved(\n\tstruct dma_chan *chan, struct dma_interleaved_template *xt,\n\tunsigned long flags)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc;\n\n\tdev_dbg(imxdma->dev, \"%s channel: %d src_start=0x%llx dst_start=0x%llx\\n\"\n\t\t\"   src_sgl=%s dst_sgl=%s numf=%zu frame_size=%zu\\n\", __func__,\n\t\timxdmac->channel, (unsigned long long)xt->src_start,\n\t\t(unsigned long long) xt->dst_start,\n\t\txt->src_sgl ? \"true\" : \"false\", xt->dst_sgl ? \"true\" : \"false\",\n\t\txt->numf, xt->frame_size);\n\n\tif (list_empty(&imxdmac->ld_free) ||\n\t    imxdma_chan_is_doing_cyclic(imxdmac))\n\t\treturn NULL;\n\n\tif (xt->frame_size != 1 || xt->numf <= 0 || xt->dir != DMA_MEM_TO_MEM)\n\t\treturn NULL;\n\n\tdesc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);\n\n\tdesc->type = IMXDMA_DESC_INTERLEAVED;\n\tdesc->src = xt->src_start;\n\tdesc->dest = xt->dst_start;\n\tdesc->x = xt->sgl[0].size;\n\tdesc->y = xt->numf;\n\tdesc->w = xt->sgl[0].icg + desc->x;\n\tdesc->len = desc->x * desc->y;\n\tdesc->direction = DMA_MEM_TO_MEM;\n\tdesc->config_port = IMX_DMA_MEMSIZE_32;\n\tdesc->config_mem = IMX_DMA_MEMSIZE_32;\n\tif (xt->src_sgl)\n\t\tdesc->config_mem |= IMX_DMA_TYPE_2D;\n\tif (xt->dst_sgl)\n\t\tdesc->config_port |= IMX_DMA_TYPE_2D;\n\tdesc->desc.callback = NULL;\n\tdesc->desc.callback_param = NULL;\n\n\treturn &desc->desc;\n}\n\nstatic void imxdma_issue_pending(struct dma_chan *chan)\n{\n\tstruct imxdma_channel *imxdmac = to_imxdma_chan(chan);\n\tstruct imxdma_engine *imxdma = imxdmac->imxdma;\n\tstruct imxdma_desc *desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdma->lock, flags);\n\tif (list_empty(&imxdmac->ld_active) &&\n\t    !list_empty(&imxdmac->ld_queue)) {\n\t\tdesc = list_first_entry(&imxdmac->ld_queue,\n\t\t\t\t\tstruct imxdma_desc, node);\n\n\t\tif (imxdma_xfer_desc(desc) < 0) {\n\t\t\tdev_warn(imxdma->dev,\n\t\t\t\t \"%s: channel: %d couldn't issue DMA xfer\\n\",\n\t\t\t\t __func__, imxdmac->channel);\n\t\t} else {\n\t\t\tlist_move_tail(imxdmac->ld_queue.next,\n\t\t\t\t       &imxdmac->ld_active);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&imxdma->lock, flags);\n}\n\nstatic bool imxdma_filter_fn(struct dma_chan *chan, void *param)\n{\n\tstruct imxdma_filter_data *fdata = param;\n\tstruct imxdma_channel *imxdma_chan = to_imxdma_chan(chan);\n\n\tif (chan->device->dev != fdata->imxdma->dev)\n\t\treturn false;\n\n\timxdma_chan->dma_request = fdata->request;\n\tchan->private = NULL;\n\n\treturn true;\n}\n\nstatic struct dma_chan *imxdma_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tint count = dma_spec->args_count;\n\tstruct imxdma_engine *imxdma = ofdma->of_dma_data;\n\tstruct imxdma_filter_data fdata = {\n\t\t.imxdma = imxdma,\n\t};\n\n\tif (count != 1)\n\t\treturn NULL;\n\n\tfdata.request = dma_spec->args[0];\n\n\treturn dma_request_channel(imxdma->dma_device.cap_mask,\n\t\t\t\t\timxdma_filter_fn, &fdata);\n}\n\nstatic int __init imxdma_probe(struct platform_device *pdev)\n{\n\tstruct imxdma_engine *imxdma;\n\tint ret, i;\n\tint irq, irq_err;\n\n\timxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);\n\tif (!imxdma)\n\t\treturn -ENOMEM;\n\n\timxdma->dev = &pdev->dev;\n\timxdma->devtype = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\timxdma->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imxdma->base))\n\t\treturn PTR_ERR(imxdma->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\timxdma->dma_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(imxdma->dma_ipg))\n\t\treturn PTR_ERR(imxdma->dma_ipg);\n\n\timxdma->dma_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(imxdma->dma_ahb))\n\t\treturn PTR_ERR(imxdma->dma_ahb);\n\n\tret = clk_prepare_enable(imxdma->dma_ipg);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_prepare_enable(imxdma->dma_ahb);\n\tif (ret)\n\t\tgoto disable_dma_ipg_clk;\n\n\t \n\timx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);\n\n\tif (is_imx1_dma(imxdma)) {\n\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t       dma_irq_handler, 0, \"DMA\", imxdma);\n\t\tif (ret) {\n\t\t\tdev_warn(imxdma->dev, \"Can't register IRQ for DMA\\n\");\n\t\t\tgoto disable_dma_ahb_clk;\n\t\t}\n\t\timxdma->irq = irq;\n\n\t\tirq_err = platform_get_irq(pdev, 1);\n\t\tif (irq_err < 0) {\n\t\t\tret = irq_err;\n\t\t\tgoto disable_dma_ahb_clk;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, irq_err,\n\t\t\t\t       imxdma_err_handler, 0, \"DMA\", imxdma);\n\t\tif (ret) {\n\t\t\tdev_warn(imxdma->dev, \"Can't register ERRIRQ for DMA\\n\");\n\t\t\tgoto disable_dma_ahb_clk;\n\t\t}\n\t\timxdma->irq_err = irq_err;\n\t}\n\n\t \n\timx_dmav1_writel(imxdma, DCR_DEN, DMA_DCR);\n\n\t \n\timx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);\n\n\t \n\timx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);\n\n\tINIT_LIST_HEAD(&imxdma->dma_device.channels);\n\n\tdma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, imxdma->dma_device.cap_mask);\n\tdma_cap_set(DMA_INTERLEAVE, imxdma->dma_device.cap_mask);\n\n\t \n\tfor (i = 0; i < IMX_DMA_2D_SLOTS; i++)\n\t\timxdma->slots_2d[i].count = 0;\n\n\tspin_lock_init(&imxdma->lock);\n\n\t \n\tfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\n\t\tstruct imxdma_channel *imxdmac = &imxdma->channel[i];\n\n\t\tif (!is_imx1_dma(imxdma)) {\n\t\t\tret = devm_request_irq(&pdev->dev, irq + i,\n\t\t\t\t\tdma_irq_handler, 0, \"DMA\", imxdma);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(imxdma->dev, \"Can't register IRQ %d \"\n\t\t\t\t\t \"for DMA channel %d\\n\",\n\t\t\t\t\t irq + i, i);\n\t\t\t\tgoto disable_dma_ahb_clk;\n\t\t\t}\n\n\t\t\timxdmac->irq = irq + i;\n\t\t\ttimer_setup(&imxdmac->watchdog, imxdma_watchdog, 0);\n\t\t}\n\n\t\timxdmac->imxdma = imxdma;\n\n\t\tINIT_LIST_HEAD(&imxdmac->ld_queue);\n\t\tINIT_LIST_HEAD(&imxdmac->ld_free);\n\t\tINIT_LIST_HEAD(&imxdmac->ld_active);\n\n\t\ttasklet_setup(&imxdmac->dma_tasklet, imxdma_tasklet);\n\t\timxdmac->chan.device = &imxdma->dma_device;\n\t\tdma_cookie_init(&imxdmac->chan);\n\t\timxdmac->channel = i;\n\n\t\t \n\t\tlist_add_tail(&imxdmac->chan.device_node,\n\t\t\t      &imxdma->dma_device.channels);\n\t}\n\n\timxdma->dma_device.dev = &pdev->dev;\n\n\timxdma->dma_device.device_alloc_chan_resources = imxdma_alloc_chan_resources;\n\timxdma->dma_device.device_free_chan_resources = imxdma_free_chan_resources;\n\timxdma->dma_device.device_tx_status = imxdma_tx_status;\n\timxdma->dma_device.device_prep_slave_sg = imxdma_prep_slave_sg;\n\timxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;\n\timxdma->dma_device.device_prep_dma_memcpy = imxdma_prep_dma_memcpy;\n\timxdma->dma_device.device_prep_interleaved_dma = imxdma_prep_dma_interleaved;\n\timxdma->dma_device.device_config = imxdma_config;\n\timxdma->dma_device.device_terminate_all = imxdma_terminate_all;\n\timxdma->dma_device.device_issue_pending = imxdma_issue_pending;\n\n\tplatform_set_drvdata(pdev, imxdma);\n\n\timxdma->dma_device.copy_align = DMAENGINE_ALIGN_4_BYTES;\n\tdma_set_max_seg_size(imxdma->dma_device.dev, 0xffffff);\n\n\tret = dma_async_device_register(&imxdma->dma_device);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to register\\n\");\n\t\tgoto disable_dma_ahb_clk;\n\t}\n\n\tif (pdev->dev.of_node) {\n\t\tret = of_dma_controller_register(pdev->dev.of_node,\n\t\t\t\timxdma_xlate, imxdma);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"unable to register of_dma_controller\\n\");\n\t\t\tgoto err_of_dma_controller;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_of_dma_controller:\n\tdma_async_device_unregister(&imxdma->dma_device);\ndisable_dma_ahb_clk:\n\tclk_disable_unprepare(imxdma->dma_ahb);\ndisable_dma_ipg_clk:\n\tclk_disable_unprepare(imxdma->dma_ipg);\n\treturn ret;\n}\n\nstatic void imxdma_free_irq(struct platform_device *pdev, struct imxdma_engine *imxdma)\n{\n\tint i;\n\n\tif (is_imx1_dma(imxdma)) {\n\t\tdisable_irq(imxdma->irq);\n\t\tdisable_irq(imxdma->irq_err);\n\t}\n\n\tfor (i = 0; i < IMX_DMA_CHANNELS; i++) {\n\t\tstruct imxdma_channel *imxdmac = &imxdma->channel[i];\n\n\t\tif (!is_imx1_dma(imxdma))\n\t\t\tdisable_irq(imxdmac->irq);\n\n\t\ttasklet_kill(&imxdmac->dma_tasklet);\n\t}\n}\n\nstatic int imxdma_remove(struct platform_device *pdev)\n{\n\tstruct imxdma_engine *imxdma = platform_get_drvdata(pdev);\n\n\timxdma_free_irq(pdev, imxdma);\n\n        dma_async_device_unregister(&imxdma->dma_device);\n\n\tif (pdev->dev.of_node)\n\t\tof_dma_controller_free(pdev->dev.of_node);\n\n\tclk_disable_unprepare(imxdma->dma_ipg);\n\tclk_disable_unprepare(imxdma->dma_ahb);\n\n        return 0;\n}\n\nstatic struct platform_driver imxdma_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"imx-dma\",\n\t\t.of_match_table = imx_dma_of_dev_id,\n\t},\n\t.remove\t\t= imxdma_remove,\n};\n\nstatic int __init imxdma_module_init(void)\n{\n\treturn platform_driver_probe(&imxdma_driver, imxdma_probe);\n}\nsubsys_initcall(imxdma_module_init);\n\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>\");\nMODULE_DESCRIPTION(\"i.MX dma driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}