{
  "module_name": "tegra186-gpc-dma.c",
  "hash_id": "4605d0dc0a94963f64449fcecf99061dd9667dec43a314f49de0ed1ebada8a00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/tegra186-gpc-dma.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <dt-bindings/memory/tegra186-mc.h>\n#include \"virt-dma.h\"\n\n \n#define TEGRA_GPCDMA_CHAN_CSR\t\t\t0x00\n#define TEGRA_GPCDMA_CSR_ENB\t\t\tBIT(31)\n#define TEGRA_GPCDMA_CSR_IE_EOC\t\t\tBIT(30)\n#define TEGRA_GPCDMA_CSR_ONCE\t\t\tBIT(27)\n\n#define TEGRA_GPCDMA_CSR_FC_MODE\t\tGENMASK(25, 24)\n#define TEGRA_GPCDMA_CSR_FC_MODE_NO_MMIO\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_FC_MODE, 0)\n#define TEGRA_GPCDMA_CSR_FC_MODE_ONE_MMIO\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_FC_MODE, 1)\n#define TEGRA_GPCDMA_CSR_FC_MODE_TWO_MMIO\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_FC_MODE, 2)\n#define TEGRA_GPCDMA_CSR_FC_MODE_FOUR_MMIO\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_FC_MODE, 3)\n\n#define TEGRA_GPCDMA_CSR_DMA\t\t\tGENMASK(23, 21)\n#define TEGRA_GPCDMA_CSR_DMA_IO2MEM_NO_FC\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 0)\n#define TEGRA_GPCDMA_CSR_DMA_IO2MEM_FC\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 1)\n#define TEGRA_GPCDMA_CSR_DMA_MEM2IO_NO_FC\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 2)\n#define TEGRA_GPCDMA_CSR_DMA_MEM2IO_FC\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 3)\n#define TEGRA_GPCDMA_CSR_DMA_MEM2MEM\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 4)\n#define TEGRA_GPCDMA_CSR_DMA_FIXED_PAT\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_DMA, 6)\n\n#define TEGRA_GPCDMA_CSR_REQ_SEL_MASK\t\tGENMASK(20, 16)\n#define TEGRA_GPCDMA_CSR_REQ_SEL_UNUSED\t\t\\\n\t\t\t\t\tFIELD_PREP(TEGRA_GPCDMA_CSR_REQ_SEL_MASK, 4)\n#define TEGRA_GPCDMA_CSR_IRQ_MASK\t\tBIT(15)\n#define TEGRA_GPCDMA_CSR_WEIGHT\t\t\tGENMASK(13, 10)\n\n \n#define TEGRA_GPCDMA_CHAN_STATUS\t\t0x004\n#define TEGRA_GPCDMA_STATUS_BUSY\t\tBIT(31)\n#define TEGRA_GPCDMA_STATUS_ISE_EOC\t\tBIT(30)\n#define TEGRA_GPCDMA_STATUS_PING_PONG\t\tBIT(28)\n#define TEGRA_GPCDMA_STATUS_DMA_ACTIVITY\tBIT(27)\n#define TEGRA_GPCDMA_STATUS_CHANNEL_PAUSE\tBIT(26)\n#define TEGRA_GPCDMA_STATUS_CHANNEL_RX\t\tBIT(25)\n#define TEGRA_GPCDMA_STATUS_CHANNEL_TX\t\tBIT(24)\n#define TEGRA_GPCDMA_STATUS_IRQ_INTR_STA\tBIT(23)\n#define TEGRA_GPCDMA_STATUS_IRQ_STA\t\tBIT(21)\n#define TEGRA_GPCDMA_STATUS_IRQ_TRIG_STA\tBIT(20)\n\n#define TEGRA_GPCDMA_CHAN_CSRE\t\t\t0x008\n#define TEGRA_GPCDMA_CHAN_CSRE_PAUSE\t\tBIT(31)\n\n \n#define TEGRA_GPCDMA_CHAN_SRC_PTR\t\t0x00C\n\n \n#define TEGRA_GPCDMA_CHAN_DST_PTR\t\t0x010\n\n \n#define TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR\t\t0x014\n#define TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR\t\tGENMASK(7, 0)\n#define TEGRA_GPCDMA_HIGH_ADDR_DST_PTR\t\tGENMASK(23, 16)\n\n \n#define TEGRA_GPCDMA_CHAN_MCSEQ\t\t\t0x18\n#define TEGRA_GPCDMA_MCSEQ_DATA_SWAP\t\tBIT(31)\n#define TEGRA_GPCDMA_MCSEQ_REQ_COUNT\t\tGENMASK(30, 25)\n#define TEGRA_GPCDMA_MCSEQ_BURST\t\tGENMASK(24, 23)\n#define TEGRA_GPCDMA_MCSEQ_BURST_2\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_MCSEQ_BURST, 0)\n#define TEGRA_GPCDMA_MCSEQ_BURST_16\t\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_MCSEQ_BURST, 3)\n#define TEGRA_GPCDMA_MCSEQ_WRAP1\t\tGENMASK(22, 20)\n#define TEGRA_GPCDMA_MCSEQ_WRAP0\t\tGENMASK(19, 17)\n#define TEGRA_GPCDMA_MCSEQ_WRAP_NONE\t\t0\n\n#define TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK\tGENMASK(13, 7)\n#define TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK\tGENMASK(6, 0)\n\n \n#define TEGRA_GPCDMA_CHAN_MMIOSEQ\t\t\t0x01c\n#define TEGRA_GPCDMA_MMIOSEQ_DBL_BUF\t\tBIT(31)\n#define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH\t\tGENMASK(30, 28)\n#define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_8\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH, 0)\n#define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_16\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH, 1)\n#define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_32\t\\\n\t\tFIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH, 2)\n#define TEGRA_GPCDMA_MMIOSEQ_DATA_SWAP\t\tBIT(27)\n#define TEGRA_GPCDMA_MMIOSEQ_BURST_SHIFT\t23\n#define TEGRA_GPCDMA_MMIOSEQ_BURST_MIN\t\t2U\n#define TEGRA_GPCDMA_MMIOSEQ_BURST_MAX\t\t32U\n#define TEGRA_GPCDMA_MMIOSEQ_BURST(bs)\t\\\n\t\t(GENMASK((fls(bs) - 2), 0) << TEGRA_GPCDMA_MMIOSEQ_BURST_SHIFT)\n#define TEGRA_GPCDMA_MMIOSEQ_MASTER_ID\t\tGENMASK(22, 19)\n#define TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD\t\tGENMASK(18, 16)\n#define TEGRA_GPCDMA_MMIOSEQ_MMIO_PROT\t\tGENMASK(8, 7)\n\n \n#define TEGRA_GPCDMA_CHAN_WCOUNT\t\t0x20\n\n \n#define TEGRA_GPCDMA_CHAN_XFER_COUNT\t\t0x24\n\n \n#define TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS\t0x28\n\n \n#define TEGRA_GPCDMA_CHAN_ERR_STATUS\t\t0x30\n#define TEGRA_GPCDMA_CHAN_ERR_TYPE_SHIFT\t8\n#define TEGRA_GPCDMA_CHAN_ERR_TYPE_MASK\t0xF\n#define TEGRA_GPCDMA_CHAN_ERR_TYPE(err)\t(\t\t\t\\\n\t\t((err) >> TEGRA_GPCDMA_CHAN_ERR_TYPE_SHIFT) &\t\\\n\t\tTEGRA_GPCDMA_CHAN_ERR_TYPE_MASK)\n#define TEGRA_DMA_BM_FIFO_FULL_ERR\t\t0xF\n#define TEGRA_DMA_PERIPH_FIFO_FULL_ERR\t\t0xE\n#define TEGRA_DMA_PERIPH_ID_ERR\t\t\t0xD\n#define TEGRA_DMA_STREAM_ID_ERR\t\t\t0xC\n#define TEGRA_DMA_MC_SLAVE_ERR\t\t\t0xB\n#define TEGRA_DMA_MMIO_SLAVE_ERR\t\t0xA\n\n \n#define TEGRA_GPCDMA_CHAN_FIXED_PATTERN\t\t0x34\n\n#define TEGRA_GPCDMA_CHAN_TZ\t\t\t0x38\n#define TEGRA_GPCDMA_CHAN_TZ_MMIO_PROT_1\tBIT(0)\n#define TEGRA_GPCDMA_CHAN_TZ_MC_PROT_1\t\tBIT(1)\n\n#define TEGRA_GPCDMA_CHAN_SPARE\t\t\t0x3c\n#define TEGRA_GPCDMA_CHAN_SPARE_EN_LEGACY_FC\tBIT(16)\n\n \n#define TEGRA_GPCDMA_BURST_COMPLETE_TIME\t10\n#define TEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT\t5000  \n\n \n#define TEGRA_GPCDMA_CHANNEL_BASE_ADDR_OFFSET\t0x10000\n\n \n#define TEGRA_GPCDMA_DEFAULT_CHANNEL_MASK\t0xfffffffe\n\nstruct tegra_dma;\nstruct tegra_dma_channel;\n\n \nstruct tegra_dma_chip_data {\n\tbool hw_support_pause;\n\tunsigned int nr_channels;\n\tunsigned int channel_reg_size;\n\tunsigned int max_dma_count;\n\tint (*terminate)(struct tegra_dma_channel *tdc);\n};\n\n \nstruct tegra_dma_channel_regs {\n\tu32 csr;\n\tu32 src_ptr;\n\tu32 dst_ptr;\n\tu32 high_addr_ptr;\n\tu32 mc_seq;\n\tu32 mmio_seq;\n\tu32 wcount;\n\tu32 fixed_pattern;\n};\n\n \nstruct tegra_dma_sg_req {\n\tunsigned int len;\n\tstruct tegra_dma_channel_regs ch_regs;\n};\n\n \nstruct tegra_dma_desc {\n\tbool cyclic;\n\tunsigned int bytes_req;\n\tunsigned int bytes_xfer;\n\tunsigned int sg_idx;\n\tunsigned int sg_count;\n\tstruct virt_dma_desc vd;\n\tstruct tegra_dma_channel *tdc;\n\tstruct tegra_dma_sg_req sg_req[];\n};\n\n \nstruct tegra_dma_channel {\n\tbool config_init;\n\tchar name[30];\n\tenum dma_transfer_direction sid_dir;\n\tint id;\n\tint irq;\n\tint slave_id;\n\tstruct tegra_dma *tdma;\n\tstruct virt_dma_chan vc;\n\tstruct tegra_dma_desc *dma_desc;\n\tstruct dma_slave_config dma_sconfig;\n\tunsigned int stream_id;\n\tunsigned long chan_base_offset;\n};\n\n \nstruct tegra_dma {\n\tconst struct tegra_dma_chip_data *chip_data;\n\tunsigned long sid_m2d_reserved;\n\tunsigned long sid_d2m_reserved;\n\tu32 chan_mask;\n\tvoid __iomem *base_addr;\n\tstruct device *dev;\n\tstruct dma_device dma_dev;\n\tstruct reset_control *rst;\n\tstruct tegra_dma_channel channels[];\n};\n\nstatic inline void tdc_write(struct tegra_dma_channel *tdc,\n\t\t\t     u32 reg, u32 val)\n{\n\twritel_relaxed(val, tdc->tdma->base_addr + tdc->chan_base_offset + reg);\n}\n\nstatic inline u32 tdc_read(struct tegra_dma_channel *tdc, u32 reg)\n{\n\treturn readl_relaxed(tdc->tdma->base_addr + tdc->chan_base_offset + reg);\n}\n\nstatic inline struct tegra_dma_channel *to_tegra_dma_chan(struct dma_chan *dc)\n{\n\treturn container_of(dc, struct tegra_dma_channel, vc.chan);\n}\n\nstatic inline struct tegra_dma_desc *vd_to_tegra_dma_desc(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct tegra_dma_desc, vd);\n}\n\nstatic inline struct device *tdc2dev(struct tegra_dma_channel *tdc)\n{\n\treturn tdc->vc.chan.device->dev;\n}\n\nstatic void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)\n{\n\tdev_dbg(tdc2dev(tdc), \"DMA Channel %d name %s register dump:\\n\",\n\t\ttdc->id, tdc->name);\n\tdev_dbg(tdc2dev(tdc), \"CSR %x STA %x CSRE %x SRC %x DST %x\\n\",\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_DST_PTR)\n\t);\n\tdev_dbg(tdc2dev(tdc), \"MCSEQ %x IOSEQ %x WCNT %x XFER %x BSTA %x\\n\",\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_WCOUNT),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT),\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS)\n\t);\n\tdev_dbg(tdc2dev(tdc), \"DMA ERR_STA %x\\n\",\n\t\ttdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS));\n}\n\nstatic int tegra_dma_sid_reserve(struct tegra_dma_channel *tdc,\n\t\t\t\t enum dma_transfer_direction direction)\n{\n\tstruct tegra_dma *tdma = tdc->tdma;\n\tint sid = tdc->slave_id;\n\n\tif (!is_slave_direction(direction))\n\t\treturn 0;\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tif (test_and_set_bit(sid, &tdma->sid_m2d_reserved)) {\n\t\t\tdev_err(tdma->dev, \"slave id already in use\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tif (test_and_set_bit(sid, &tdma->sid_d2m_reserved)) {\n\t\t\tdev_err(tdma->dev, \"slave id already in use\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttdc->sid_dir = direction;\n\n\treturn 0;\n}\n\nstatic void tegra_dma_sid_free(struct tegra_dma_channel *tdc)\n{\n\tstruct tegra_dma *tdma = tdc->tdma;\n\tint sid = tdc->slave_id;\n\n\tswitch (tdc->sid_dir) {\n\tcase DMA_MEM_TO_DEV:\n\t\tclear_bit(sid,  &tdma->sid_m2d_reserved);\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tclear_bit(sid,  &tdma->sid_d2m_reserved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttdc->sid_dir = DMA_TRANS_NONE;\n}\n\nstatic void tegra_dma_desc_free(struct virt_dma_desc *vd)\n{\n\tkfree(container_of(vd, struct tegra_dma_desc, vd));\n}\n\nstatic int tegra_dma_slave_config(struct dma_chan *dc,\n\t\t\t\t  struct dma_slave_config *sconfig)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\n\tmemcpy(&tdc->dma_sconfig, sconfig, sizeof(*sconfig));\n\ttdc->config_init = true;\n\n\treturn 0;\n}\n\nstatic int tegra_dma_pause(struct tegra_dma_channel *tdc)\n{\n\tint ret;\n\tu32 val;\n\n\tval = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);\n\tval |= TEGRA_GPCDMA_CHAN_CSRE_PAUSE;\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);\n\n\t \n\tret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +\n\t\t\ttdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,\n\t\t\tval,\n\t\t\t!(val & TEGRA_GPCDMA_STATUS_BUSY),\n\t\t\tTEGRA_GPCDMA_BURST_COMPLETE_TIME,\n\t\t\tTEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT);\n\n\tif (ret) {\n\t\tdev_err(tdc2dev(tdc), \"DMA pause timed out\\n\");\n\t\ttegra_dma_dump_chan_regs(tdc);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_dma_device_pause(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!tdc->tdma->chip_data->hw_support_pause)\n\t\treturn -ENOSYS;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\tret = tegra_dma_pause(tdc);\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\n\treturn ret;\n}\n\nstatic void tegra_dma_resume(struct tegra_dma_channel *tdc)\n{\n\tu32 val;\n\n\tval = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);\n\tval &= ~TEGRA_GPCDMA_CHAN_CSRE_PAUSE;\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);\n}\n\nstatic int tegra_dma_device_resume(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned long flags;\n\n\tif (!tdc->tdma->chip_data->hw_support_pause)\n\t\treturn -ENOSYS;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\ttegra_dma_resume(tdc);\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic inline int tegra_dma_pause_noerr(struct tegra_dma_channel *tdc)\n{\n\t \n\n\ttegra_dma_pause(tdc);\n\treturn 0;\n}\n\nstatic void tegra_dma_disable(struct tegra_dma_channel *tdc)\n{\n\tu32 csr, status;\n\n\tcsr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);\n\n\t \n\tcsr &= ~TEGRA_GPCDMA_CSR_IE_EOC;\n\n\t \n\tcsr &= ~TEGRA_GPCDMA_CSR_ENB;\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);\n\n\t \n\tstatus = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);\n\tif (status & TEGRA_GPCDMA_STATUS_ISE_EOC) {\n\t\tdev_dbg(tdc2dev(tdc), \"%s():clearing interrupt\\n\", __func__);\n\t\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS, status);\n\t}\n}\n\nstatic void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)\n{\n\tstruct tegra_dma_desc *dma_desc = tdc->dma_desc;\n\tstruct tegra_dma_channel_regs *ch_regs;\n\tint ret;\n\tu32 val;\n\n\tdma_desc->sg_idx++;\n\n\t \n\tif (dma_desc->sg_idx == dma_desc->sg_count)\n\t\tdma_desc->sg_idx = 0;\n\n\t \n\tret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +\n\t\t\ttdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,\n\t\t\tval,\n\t\t\t(val & TEGRA_GPCDMA_STATUS_BUSY), 0,\n\t\t\tTEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT);\n\tif (ret)\n\t\treturn;\n\n\tch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;\n\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);\n\n\t \n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,\n\t\t  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);\n}\n\nstatic void tegra_dma_start(struct tegra_dma_channel *tdc)\n{\n\tstruct tegra_dma_desc *dma_desc = tdc->dma_desc;\n\tstruct tegra_dma_channel_regs *ch_regs;\n\tstruct virt_dma_desc *vdesc;\n\n\tif (!dma_desc) {\n\t\tvdesc = vchan_next_desc(&tdc->vc);\n\t\tif (!vdesc)\n\t\t\treturn;\n\n\t\tdma_desc = vd_to_tegra_dma_desc(vdesc);\n\t\tlist_del(&vdesc->node);\n\t\tdma_desc->tdc = tdc;\n\t\ttdc->dma_desc = dma_desc;\n\n\t\ttegra_dma_resume(tdc);\n\t}\n\n\tch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;\n\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, 0);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_FIXED_PATTERN, ch_regs->fixed_pattern);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ, ch_regs->mmio_seq);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, ch_regs->mc_seq);\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, ch_regs->csr);\n\n\t \n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,\n\t\t  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);\n}\n\nstatic void tegra_dma_xfer_complete(struct tegra_dma_channel *tdc)\n{\n\tvchan_cookie_complete(&tdc->dma_desc->vd);\n\n\ttegra_dma_sid_free(tdc);\n\ttdc->dma_desc = NULL;\n}\n\nstatic void tegra_dma_chan_decode_error(struct tegra_dma_channel *tdc,\n\t\t\t\t\tunsigned int err_status)\n{\n\tswitch (TEGRA_GPCDMA_CHAN_ERR_TYPE(err_status)) {\n\tcase TEGRA_DMA_BM_FIFO_FULL_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d bm fifo full\\n\", tdc->id);\n\t\tbreak;\n\n\tcase TEGRA_DMA_PERIPH_FIFO_FULL_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d peripheral fifo full\\n\", tdc->id);\n\t\tbreak;\n\n\tcase TEGRA_DMA_PERIPH_ID_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d illegal peripheral id\\n\", tdc->id);\n\t\tbreak;\n\n\tcase TEGRA_DMA_STREAM_ID_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d illegal stream id\\n\", tdc->id);\n\t\tbreak;\n\n\tcase TEGRA_DMA_MC_SLAVE_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d mc slave error\\n\", tdc->id);\n\t\tbreak;\n\n\tcase TEGRA_DMA_MMIO_SLAVE_ERR:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d mmio slave error\\n\", tdc->id);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(tdc->tdma->dev,\n\t\t\t\"GPCDMA CH%d security violation %x\\n\", tdc->id,\n\t\t\terr_status);\n\t}\n}\n\nstatic irqreturn_t tegra_dma_isr(int irq, void *dev_id)\n{\n\tstruct tegra_dma_channel *tdc = dev_id;\n\tstruct tegra_dma_desc *dma_desc = tdc->dma_desc;\n\tstruct tegra_dma_sg_req *sg_req;\n\tu32 status;\n\n\t \n\tstatus = tdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS);\n\tif (status) {\n\t\ttegra_dma_chan_decode_error(tdc, status);\n\t\ttegra_dma_dump_chan_regs(tdc);\n\t\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS, 0xFFFFFFFF);\n\t}\n\n\tspin_lock(&tdc->vc.lock);\n\tstatus = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);\n\tif (!(status & TEGRA_GPCDMA_STATUS_ISE_EOC))\n\t\tgoto irq_done;\n\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS,\n\t\t  TEGRA_GPCDMA_STATUS_ISE_EOC);\n\n\tif (!dma_desc)\n\t\tgoto irq_done;\n\n\tsg_req = dma_desc->sg_req;\n\tdma_desc->bytes_xfer += sg_req[dma_desc->sg_idx].len;\n\n\tif (dma_desc->cyclic) {\n\t\tvchan_cyclic_callback(&dma_desc->vd);\n\t\ttegra_dma_configure_next_sg(tdc);\n\t} else {\n\t\tdma_desc->sg_idx++;\n\t\tif (dma_desc->sg_idx == dma_desc->sg_count)\n\t\t\ttegra_dma_xfer_complete(tdc);\n\t\telse\n\t\t\ttegra_dma_start(tdc);\n\t}\n\nirq_done:\n\tspin_unlock(&tdc->vc.lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_dma_issue_pending(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned long flags;\n\n\tif (tdc->dma_desc)\n\t\treturn;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\tif (vchan_issue_pending(&tdc->vc))\n\t\ttegra_dma_start(tdc);\n\n\t \n\tif (tdc->dma_desc && tdc->dma_desc->cyclic)\n\t\ttegra_dma_configure_next_sg(tdc);\n\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n}\n\nstatic int tegra_dma_stop_client(struct tegra_dma_channel *tdc)\n{\n\tint ret;\n\tu32 status, csr;\n\n\t \n\tcsr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);\n\tcsr &= ~(TEGRA_GPCDMA_CSR_REQ_SEL_MASK);\n\tcsr |= TEGRA_GPCDMA_CSR_REQ_SEL_UNUSED;\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);\n\n\t \n\tudelay(TEGRA_GPCDMA_BURST_COMPLETE_TIME);\n\n\t \n\n\tret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +\n\t\t\t\ttdc->chan_base_offset +\n\t\t\t\tTEGRA_GPCDMA_CHAN_STATUS,\n\t\t\t\tstatus,\n\t\t\t\t!(status & (TEGRA_GPCDMA_STATUS_CHANNEL_TX |\n\t\t\t\tTEGRA_GPCDMA_STATUS_CHANNEL_RX)),\n\t\t\t\t5,\n\t\t\t\tTEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(tdc2dev(tdc), \"Timeout waiting for DMA burst completion!\\n\");\n\t\ttegra_dma_dump_chan_regs(tdc);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_dma_terminate_all(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\tint err;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\n\tif (tdc->dma_desc) {\n\t\terr = tdc->tdma->chip_data->terminate(tdc);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\t\t\treturn err;\n\t\t}\n\n\t\tvchan_terminate_vdesc(&tdc->dma_desc->vd);\n\t\ttegra_dma_disable(tdc);\n\t\ttdc->dma_desc = NULL;\n\t}\n\n\ttegra_dma_sid_free(tdc);\n\tvchan_get_all_descriptors(&tdc->vc, &head);\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\n\tvchan_dma_desc_free_list(&tdc->vc, &head);\n\n\treturn 0;\n}\n\nstatic int tegra_dma_get_residual(struct tegra_dma_channel *tdc)\n{\n\tstruct tegra_dma_desc *dma_desc = tdc->dma_desc;\n\tstruct tegra_dma_sg_req *sg_req = dma_desc->sg_req;\n\tunsigned int bytes_xfer, residual;\n\tu32 wcount = 0, status;\n\n\twcount = tdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT);\n\n\t \n\tstatus = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);\n\tif (status & TEGRA_GPCDMA_STATUS_ISE_EOC)\n\t\twcount = 0;\n\n\tbytes_xfer = dma_desc->bytes_xfer +\n\t\t     sg_req[dma_desc->sg_idx].len - (wcount * 4);\n\n\tresidual = dma_desc->bytes_req - (bytes_xfer % dma_desc->bytes_req);\n\n\treturn residual;\n}\n\nstatic enum dma_status tegra_dma_tx_status(struct dma_chan *dc,\n\t\t\t\t\t   dma_cookie_t cookie,\n\t\t\t\t\t   struct dma_tx_state *txstate)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tstruct tegra_dma_desc *dma_desc;\n\tstruct virt_dma_desc *vd;\n\tunsigned int residual;\n\tunsigned long flags;\n\tenum dma_status ret;\n\n\tret = dma_cookie_status(dc, cookie, txstate);\n\tif (ret == DMA_COMPLETE)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\tvd = vchan_find_desc(&tdc->vc, cookie);\n\tif (vd) {\n\t\tdma_desc = vd_to_tegra_dma_desc(vd);\n\t\tresidual = dma_desc->bytes_req;\n\t\tdma_set_residue(txstate, residual);\n\t} else if (tdc->dma_desc && tdc->dma_desc->vd.tx.cookie == cookie) {\n\t\tresidual =  tegra_dma_get_residual(tdc);\n\t\tdma_set_residue(txstate, residual);\n\t} else {\n\t\tdev_err(tdc2dev(tdc), \"cookie %d is not found\\n\", cookie);\n\t}\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\n\treturn ret;\n}\n\nstatic inline int get_bus_width(struct tegra_dma_channel *tdc,\n\t\t\t\tenum dma_slave_buswidth slave_bw)\n{\n\tswitch (slave_bw) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\treturn TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_8;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\treturn TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_16;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\treturn TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_32;\n\tdefault:\n\t\tdev_err(tdc2dev(tdc), \"given slave bus width is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned int get_burst_size(struct tegra_dma_channel *tdc,\n\t\t\t\t   u32 burst_size, enum dma_slave_buswidth slave_bw,\n\t\t\t\t   int len)\n{\n\tunsigned int burst_mmio_width, burst_byte;\n\n\t \n\tburst_byte = burst_size ? burst_size * slave_bw : len;\n\tburst_mmio_width = burst_byte / 4;\n\n\tif (burst_mmio_width < TEGRA_GPCDMA_MMIOSEQ_BURST_MIN)\n\t\treturn 0;\n\n\tburst_mmio_width = min(burst_mmio_width, TEGRA_GPCDMA_MMIOSEQ_BURST_MAX);\n\n\treturn TEGRA_GPCDMA_MMIOSEQ_BURST(burst_mmio_width);\n}\n\nstatic int get_transfer_param(struct tegra_dma_channel *tdc,\n\t\t\t      enum dma_transfer_direction direction,\n\t\t\t      u32 *apb_addr,\n\t\t\t      u32 *mmio_seq,\n\t\t\t      u32 *csr,\n\t\t\t      unsigned int *burst_size,\n\t\t\t      enum dma_slave_buswidth *slave_bw)\n{\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\t*apb_addr = tdc->dma_sconfig.dst_addr;\n\t\t*mmio_seq = get_bus_width(tdc, tdc->dma_sconfig.dst_addr_width);\n\t\t*burst_size = tdc->dma_sconfig.dst_maxburst;\n\t\t*slave_bw = tdc->dma_sconfig.dst_addr_width;\n\t\t*csr = TEGRA_GPCDMA_CSR_DMA_MEM2IO_FC;\n\t\treturn 0;\n\tcase DMA_DEV_TO_MEM:\n\t\t*apb_addr = tdc->dma_sconfig.src_addr;\n\t\t*mmio_seq = get_bus_width(tdc, tdc->dma_sconfig.src_addr_width);\n\t\t*burst_size = tdc->dma_sconfig.src_maxburst;\n\t\t*slave_bw = tdc->dma_sconfig.src_addr_width;\n\t\t*csr = TEGRA_GPCDMA_CSR_DMA_IO2MEM_FC;\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(tdc2dev(tdc), \"DMA direction is not supported\\n\");\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic struct dma_async_tx_descriptor *\ntegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,\n\t\t\t  size_t len, unsigned long flags)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned int max_dma_count = tdc->tdma->chip_data->max_dma_count;\n\tstruct tegra_dma_sg_req *sg_req;\n\tstruct tegra_dma_desc *dma_desc;\n\tu32 csr, mc_seq;\n\n\tif ((len & 3) || (dest & 3) || len > max_dma_count) {\n\t\tdev_err(tdc2dev(tdc),\n\t\t\t\"DMA length/memory address is not supported\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tcsr = TEGRA_GPCDMA_CSR_DMA_FIXED_PAT;\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_ONCE;\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_IRQ_MASK;\n\t \n\tif (flags & DMA_PREP_INTERRUPT)\n\t\tcsr |= TEGRA_GPCDMA_CSR_IE_EOC;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);\n\n\tmc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);\n\t \n\tmc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP0,\n\t\t\t\t\t\tTEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP1,\n\t\t\t\t\t\tTEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_REQ_COUNT, 1);\n\t \n\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_16;\n\n\tdma_desc = kzalloc(struct_size(dma_desc, sg_req, 1), GFP_NOWAIT);\n\tif (!dma_desc)\n\t\treturn NULL;\n\n\tdma_desc->bytes_req = len;\n\tdma_desc->sg_count = 1;\n\tsg_req = dma_desc->sg_req;\n\n\tsg_req[0].ch_regs.src_ptr = 0;\n\tsg_req[0].ch_regs.dst_ptr = dest;\n\tsg_req[0].ch_regs.high_addr_ptr =\n\t\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));\n\tsg_req[0].ch_regs.fixed_pattern = value;\n\t \n\tsg_req[0].ch_regs.wcount = ((len - 4) >> 2);\n\tsg_req[0].ch_regs.csr = csr;\n\tsg_req[0].ch_regs.mmio_seq = 0;\n\tsg_req[0].ch_regs.mc_seq = mc_seq;\n\tsg_req[0].len = len;\n\n\tdma_desc->cyclic = false;\n\treturn vchan_tx_prep(&tdc->vc, &dma_desc->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\ntegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,\n\t\t\t  dma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tstruct tegra_dma_sg_req *sg_req;\n\tstruct tegra_dma_desc *dma_desc;\n\tunsigned int max_dma_count;\n\tu32 csr, mc_seq;\n\n\tmax_dma_count = tdc->tdma->chip_data->max_dma_count;\n\tif ((len & 3) || (src & 3) || (dest & 3) || len > max_dma_count) {\n\t\tdev_err(tdc2dev(tdc),\n\t\t\t\"DMA length/memory address is not supported\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tcsr = TEGRA_GPCDMA_CSR_DMA_MEM2MEM;\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_ONCE;\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_IRQ_MASK;\n\t \n\tif (flags & DMA_PREP_INTERRUPT)\n\t\tcsr |= TEGRA_GPCDMA_CSR_IE_EOC;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);\n\n\tmc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);\n\t \n\tmc_seq &= (TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK) |\n\t\t  (TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP0,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP1,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_REQ_COUNT, 1);\n\t \n\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_16;\n\n\tdma_desc = kzalloc(struct_size(dma_desc, sg_req, 1), GFP_NOWAIT);\n\tif (!dma_desc)\n\t\treturn NULL;\n\n\tdma_desc->bytes_req = len;\n\tdma_desc->sg_count = 1;\n\tsg_req = dma_desc->sg_req;\n\n\tsg_req[0].ch_regs.src_ptr = src;\n\tsg_req[0].ch_regs.dst_ptr = dest;\n\tsg_req[0].ch_regs.high_addr_ptr =\n\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (src >> 32));\n\tsg_req[0].ch_regs.high_addr_ptr |=\n\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));\n\t \n\tsg_req[0].ch_regs.wcount = ((len - 4) >> 2);\n\tsg_req[0].ch_regs.csr = csr;\n\tsg_req[0].ch_regs.mmio_seq = 0;\n\tsg_req[0].ch_regs.mc_seq = mc_seq;\n\tsg_req[0].len = len;\n\n\tdma_desc->cyclic = false;\n\treturn vchan_tx_prep(&tdc->vc, &dma_desc->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\ntegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,\n\t\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\t\tunsigned long flags, void *context)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tunsigned int max_dma_count = tdc->tdma->chip_data->max_dma_count;\n\tenum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\tu32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0;\n\tstruct tegra_dma_sg_req *sg_req;\n\tstruct tegra_dma_desc *dma_desc;\n\tstruct scatterlist *sg;\n\tu32 burst_size;\n\tunsigned int i;\n\tint ret;\n\n\tif (!tdc->config_init) {\n\t\tdev_err(tdc2dev(tdc), \"DMA channel is not configured\\n\");\n\t\treturn NULL;\n\t}\n\tif (sg_len < 1) {\n\t\tdev_err(tdc2dev(tdc), \"Invalid segment length %d\\n\", sg_len);\n\t\treturn NULL;\n\t}\n\n\tret = tegra_dma_sid_reserve(tdc, direction);\n\tif (ret)\n\t\treturn NULL;\n\n\tret = get_transfer_param(tdc, direction, &apb_ptr, &mmio_seq, &csr,\n\t\t\t\t &burst_size, &slave_bw);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_ONCE;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_REQ_SEL_MASK, tdc->slave_id);\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_IRQ_MASK;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);\n\n\t \n\tif (flags & DMA_PREP_INTERRUPT)\n\t\tcsr |= TEGRA_GPCDMA_CSR_IE_EOC;\n\n\tmc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);\n\t \n\tmc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;\n\n\t \n\n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP0,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP1,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\tmmio_seq |= FIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD, 1);\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_REQ_COUNT, 1);\n\n\t \n\tif (burst_size == 64)\n\t\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_16;\n\telse\n\t\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_2;\n\n\tdma_desc = kzalloc(struct_size(dma_desc, sg_req, sg_len), GFP_NOWAIT);\n\tif (!dma_desc)\n\t\treturn NULL;\n\n\tdma_desc->sg_count = sg_len;\n\tsg_req = dma_desc->sg_req;\n\n\t \n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tu32 len;\n\t\tdma_addr_t mem;\n\n\t\tmem = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\n\t\tif ((len & 3) || (mem & 3) || len > max_dma_count) {\n\t\t\tdev_err(tdc2dev(tdc),\n\t\t\t\t\"DMA length/memory address is not supported\\n\");\n\t\t\tkfree(dma_desc);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);\n\t\tdma_desc->bytes_req += len;\n\n\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\tsg_req[i].ch_regs.src_ptr = mem;\n\t\t\tsg_req[i].ch_regs.dst_ptr = apb_ptr;\n\t\t\tsg_req[i].ch_regs.high_addr_ptr =\n\t\t\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));\n\t\t} else if (direction == DMA_DEV_TO_MEM) {\n\t\t\tsg_req[i].ch_regs.src_ptr = apb_ptr;\n\t\t\tsg_req[i].ch_regs.dst_ptr = mem;\n\t\t\tsg_req[i].ch_regs.high_addr_ptr =\n\t\t\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));\n\t\t}\n\n\t\t \n\t\tsg_req[i].ch_regs.wcount = ((len - 4) >> 2);\n\t\tsg_req[i].ch_regs.csr = csr;\n\t\tsg_req[i].ch_regs.mmio_seq = mmio_seq;\n\t\tsg_req[i].ch_regs.mc_seq = mc_seq;\n\t\tsg_req[i].len = len;\n\t}\n\n\tdma_desc->cyclic = false;\n\treturn vchan_tx_prep(&tdc->vc, &dma_desc->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\ntegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_len,\n\t\t\t  size_t period_len, enum dma_transfer_direction direction,\n\t\t\t  unsigned long flags)\n{\n\tenum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\tu32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0, burst_size;\n\tunsigned int max_dma_count, len, period_count, i;\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tstruct tegra_dma_desc *dma_desc;\n\tstruct tegra_dma_sg_req *sg_req;\n\tdma_addr_t mem = buf_addr;\n\tint ret;\n\n\tif (!buf_len || !period_len) {\n\t\tdev_err(tdc2dev(tdc), \"Invalid buffer/period len\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!tdc->config_init) {\n\t\tdev_err(tdc2dev(tdc), \"DMA slave is not configured\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = tegra_dma_sid_reserve(tdc, direction);\n\tif (ret)\n\t\treturn NULL;\n\n\t \n\tif (buf_len % period_len) {\n\t\tdev_err(tdc2dev(tdc), \"buf_len is not multiple of period_len\\n\");\n\t\treturn NULL;\n\t}\n\n\tlen = period_len;\n\tmax_dma_count = tdc->tdma->chip_data->max_dma_count;\n\tif ((len & 3) || (buf_addr & 3) || len > max_dma_count) {\n\t\tdev_err(tdc2dev(tdc), \"Req len/mem address is not correct\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = get_transfer_param(tdc, direction, &apb_ptr, &mmio_seq, &csr,\n\t\t\t\t &burst_size, &slave_bw);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\t \n\tcsr &= ~TEGRA_GPCDMA_CSR_ONCE;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_REQ_SEL_MASK, tdc->slave_id);\n\t \n\tcsr |= TEGRA_GPCDMA_CSR_IRQ_MASK;\n\t \n\tcsr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);\n\n\t \n\tif (flags & DMA_PREP_INTERRUPT)\n\t\tcsr |= TEGRA_GPCDMA_CSR_IE_EOC;\n\n\tmmio_seq |= FIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD, 1);\n\n\tmc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);\n\t \n\tmc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP0,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_WRAP1,\n\t\t\t     TEGRA_GPCDMA_MCSEQ_WRAP_NONE);\n\n\t \n\tmc_seq |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_REQ_COUNT, 1);\n\t \n\tif (burst_size == 64)\n\t\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_16;\n\telse\n\t\tmc_seq |= TEGRA_GPCDMA_MCSEQ_BURST_2;\n\n\tperiod_count = buf_len / period_len;\n\tdma_desc = kzalloc(struct_size(dma_desc, sg_req, period_count),\n\t\t\t   GFP_NOWAIT);\n\tif (!dma_desc)\n\t\treturn NULL;\n\n\tdma_desc->bytes_req = buf_len;\n\tdma_desc->sg_count = period_count;\n\tsg_req = dma_desc->sg_req;\n\n\t \n\tfor (i = 0; i < period_count; i++) {\n\t\tmmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);\n\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\tsg_req[i].ch_regs.src_ptr = mem;\n\t\t\tsg_req[i].ch_regs.dst_ptr = apb_ptr;\n\t\t\tsg_req[i].ch_regs.high_addr_ptr =\n\t\t\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));\n\t\t} else if (direction == DMA_DEV_TO_MEM) {\n\t\t\tsg_req[i].ch_regs.src_ptr = apb_ptr;\n\t\t\tsg_req[i].ch_regs.dst_ptr = mem;\n\t\t\tsg_req[i].ch_regs.high_addr_ptr =\n\t\t\t\tFIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));\n\t\t}\n\t\t \n\t\tsg_req[i].ch_regs.wcount = ((len - 4) >> 2);\n\t\tsg_req[i].ch_regs.csr = csr;\n\t\tsg_req[i].ch_regs.mmio_seq = mmio_seq;\n\t\tsg_req[i].ch_regs.mc_seq = mc_seq;\n\t\tsg_req[i].len = len;\n\n\t\tmem += len;\n\t}\n\n\tdma_desc->cyclic = true;\n\n\treturn vchan_tx_prep(&tdc->vc, &dma_desc->vd, flags);\n}\n\nstatic int tegra_dma_alloc_chan_resources(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\tint ret;\n\n\tret = request_irq(tdc->irq, tegra_dma_isr, 0, tdc->name, tdc);\n\tif (ret) {\n\t\tdev_err(tdc2dev(tdc), \"request_irq failed for %s\\n\", tdc->name);\n\t\treturn ret;\n\t}\n\n\tdma_cookie_init(&tdc->vc.chan);\n\ttdc->config_init = false;\n\treturn 0;\n}\n\nstatic void tegra_dma_chan_synchronize(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\n\tsynchronize_irq(tdc->irq);\n\tvchan_synchronize(&tdc->vc);\n}\n\nstatic void tegra_dma_free_chan_resources(struct dma_chan *dc)\n{\n\tstruct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);\n\n\tdev_dbg(tdc2dev(tdc), \"Freeing channel %d\\n\", tdc->id);\n\n\ttegra_dma_terminate_all(dc);\n\tsynchronize_irq(tdc->irq);\n\n\ttasklet_kill(&tdc->vc.task);\n\ttdc->config_init = false;\n\ttdc->slave_id = -1;\n\ttdc->sid_dir = DMA_TRANS_NONE;\n\tfree_irq(tdc->irq, tdc);\n\n\tvchan_free_chan_resources(&tdc->vc);\n}\n\nstatic struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct tegra_dma *tdma = ofdma->of_dma_data;\n\tstruct tegra_dma_channel *tdc;\n\tstruct dma_chan *chan;\n\n\tchan = dma_get_any_slave_channel(&tdma->dma_dev);\n\tif (!chan)\n\t\treturn NULL;\n\n\ttdc = to_tegra_dma_chan(chan);\n\ttdc->slave_id = dma_spec->args[0];\n\n\treturn chan;\n}\n\nstatic const struct tegra_dma_chip_data tegra186_dma_chip_data = {\n\t.nr_channels = 32,\n\t.channel_reg_size = SZ_64K,\n\t.max_dma_count = SZ_1G,\n\t.hw_support_pause = false,\n\t.terminate = tegra_dma_stop_client,\n};\n\nstatic const struct tegra_dma_chip_data tegra194_dma_chip_data = {\n\t.nr_channels = 32,\n\t.channel_reg_size = SZ_64K,\n\t.max_dma_count = SZ_1G,\n\t.hw_support_pause = true,\n\t.terminate = tegra_dma_pause,\n};\n\nstatic const struct tegra_dma_chip_data tegra234_dma_chip_data = {\n\t.nr_channels = 32,\n\t.channel_reg_size = SZ_64K,\n\t.max_dma_count = SZ_1G,\n\t.hw_support_pause = true,\n\t.terminate = tegra_dma_pause_noerr,\n};\n\nstatic const struct of_device_id tegra_dma_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra186-gpcdma\",\n\t\t.data = &tegra186_dma_chip_data,\n\t}, {\n\t\t.compatible = \"nvidia,tegra194-gpcdma\",\n\t\t.data = &tegra194_dma_chip_data,\n\t}, {\n\t\t.compatible = \"nvidia,tegra234-gpcdma\",\n\t\t.data = &tegra234_dma_chip_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, tegra_dma_of_match);\n\nstatic int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)\n{\n\tunsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);\n\n\treg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);\n\treg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);\n\n\treg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);\n\treg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);\n\n\ttdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);\n\treturn 0;\n}\n\nstatic int tegra_dma_probe(struct platform_device *pdev)\n{\n\tconst struct tegra_dma_chip_data *cdata = NULL;\n\tstruct iommu_fwspec *iommu_spec;\n\tunsigned int stream_id, i;\n\tstruct tegra_dma *tdma;\n\tint ret;\n\n\tcdata = of_device_get_match_data(&pdev->dev);\n\n\ttdma = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(tdma, channels, cdata->nr_channels),\n\t\t\t    GFP_KERNEL);\n\tif (!tdma)\n\t\treturn -ENOMEM;\n\n\ttdma->dev = &pdev->dev;\n\ttdma->chip_data = cdata;\n\tplatform_set_drvdata(pdev, tdma);\n\n\ttdma->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tdma->base_addr))\n\t\treturn PTR_ERR(tdma->base_addr);\n\n\ttdma->rst = devm_reset_control_get_exclusive(&pdev->dev, \"gpcdma\");\n\tif (IS_ERR(tdma->rst)) {\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tdma->rst),\n\t\t\t      \"Missing controller reset\\n\");\n\t}\n\treset_control_reset(tdma->rst);\n\n\ttdma->dma_dev.dev = &pdev->dev;\n\n\tiommu_spec = dev_iommu_fwspec_get(&pdev->dev);\n\tif (!iommu_spec) {\n\t\tdev_err(&pdev->dev, \"Missing iommu stream-id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstream_id = iommu_spec->ids[0] & 0xffff;\n\n\tret = device_property_read_u32(&pdev->dev, \"dma-channel-mask\",\n\t\t\t\t       &tdma->chan_mask);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Missing dma-channel-mask property, using default channel mask %#x\\n\",\n\t\t\t TEGRA_GPCDMA_DEFAULT_CHANNEL_MASK);\n\t\ttdma->chan_mask = TEGRA_GPCDMA_DEFAULT_CHANNEL_MASK;\n\t}\n\n\tINIT_LIST_HEAD(&tdma->dma_dev.channels);\n\tfor (i = 0; i < cdata->nr_channels; i++) {\n\t\tstruct tegra_dma_channel *tdc = &tdma->channels[i];\n\n\t\t \n\t\tif (!(tdma->chan_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttdc->irq = platform_get_irq(pdev, i);\n\t\tif (tdc->irq < 0)\n\t\t\treturn tdc->irq;\n\n\t\ttdc->chan_base_offset = TEGRA_GPCDMA_CHANNEL_BASE_ADDR_OFFSET +\n\t\t\t\t\ti * cdata->channel_reg_size;\n\t\tsnprintf(tdc->name, sizeof(tdc->name), \"gpcdma.%d\", i);\n\t\ttdc->tdma = tdma;\n\t\ttdc->id = i;\n\t\ttdc->slave_id = -1;\n\n\t\tvchan_init(&tdc->vc, &tdma->dma_dev);\n\t\ttdc->vc.desc_free = tegra_dma_desc_free;\n\n\t\t \n\t\ttegra_dma_program_sid(tdc, stream_id);\n\t\ttdc->stream_id = stream_id;\n\t}\n\n\tdma_cap_set(DMA_SLAVE, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_MEMSET, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, tdma->dma_dev.cap_mask);\n\n\t \n\ttdma->dma_dev.copy_align = 2;\n\ttdma->dma_dev.fill_align = 2;\n\ttdma->dma_dev.device_alloc_chan_resources =\n\t\t\t\t\ttegra_dma_alloc_chan_resources;\n\ttdma->dma_dev.device_free_chan_resources =\n\t\t\t\t\ttegra_dma_free_chan_resources;\n\ttdma->dma_dev.device_prep_slave_sg = tegra_dma_prep_slave_sg;\n\ttdma->dma_dev.device_prep_dma_memcpy = tegra_dma_prep_dma_memcpy;\n\ttdma->dma_dev.device_prep_dma_memset = tegra_dma_prep_dma_memset;\n\ttdma->dma_dev.device_prep_dma_cyclic = tegra_dma_prep_dma_cyclic;\n\ttdma->dma_dev.device_config = tegra_dma_slave_config;\n\ttdma->dma_dev.device_terminate_all = tegra_dma_terminate_all;\n\ttdma->dma_dev.device_tx_status = tegra_dma_tx_status;\n\ttdma->dma_dev.device_issue_pending = tegra_dma_issue_pending;\n\ttdma->dma_dev.device_pause = tegra_dma_device_pause;\n\ttdma->dma_dev.device_resume = tegra_dma_device_resume;\n\ttdma->dma_dev.device_synchronize = tegra_dma_chan_synchronize;\n\ttdma->dma_dev.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\n\tret = dma_async_device_register(&tdma->dma_dev);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret,\n\t\t\t      \"GPC DMA driver registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_dma_controller_register(pdev->dev.of_node,\n\t\t\t\t\t tegra_dma_of_xlate, tdma);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret,\n\t\t\t      \"GPC DMA OF registration failed\\n\");\n\n\t\tdma_async_device_unregister(&tdma->dma_dev);\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"GPC DMA driver register %lu channels\\n\",\n\t\t hweight_long(tdma->chan_mask));\n\n\treturn 0;\n}\n\nstatic int tegra_dma_remove(struct platform_device *pdev)\n{\n\tstruct tegra_dma *tdma = platform_get_drvdata(pdev);\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&tdma->dma_dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_dma_pm_suspend(struct device *dev)\n{\n\tstruct tegra_dma *tdma = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < tdma->chip_data->nr_channels; i++) {\n\t\tstruct tegra_dma_channel *tdc = &tdma->channels[i];\n\n\t\tif (!(tdma->chan_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (tdc->dma_desc) {\n\t\t\tdev_err(tdma->dev, \"channel %u busy\\n\", i);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_dma_pm_resume(struct device *dev)\n{\n\tstruct tegra_dma *tdma = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\treset_control_reset(tdma->rst);\n\n\tfor (i = 0; i < tdma->chip_data->nr_channels; i++) {\n\t\tstruct tegra_dma_channel *tdc = &tdma->channels[i];\n\n\t\tif (!(tdma->chan_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttegra_dma_program_sid(tdc, tdc->stream_id);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_dma_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_dma_pm_suspend, tegra_dma_pm_resume)\n};\n\nstatic struct platform_driver tegra_dma_driver = {\n\t.driver = {\n\t\t.name\t= \"tegra-gpcdma\",\n\t\t.pm\t= &tegra_dma_dev_pm_ops,\n\t\t.of_match_table = tegra_dma_of_match,\n\t},\n\t.probe\t\t= tegra_dma_probe,\n\t.remove\t\t= tegra_dma_remove,\n};\n\nmodule_platform_driver(tegra_dma_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra GPC DMA Controller driver\");\nMODULE_AUTHOR(\"Pavan Kunapuli <pkunapuli@nvidia.com>\");\nMODULE_AUTHOR(\"Rajesh Gumasta <rgumasta@nvidia.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}