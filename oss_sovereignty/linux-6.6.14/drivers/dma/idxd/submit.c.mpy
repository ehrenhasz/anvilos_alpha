{
  "module_name": "submit.c",
  "hash_id": "fec34406c5ae177b1aeb17fbd28279858042c969a5b530ab3c4ebe198cf70625",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/idxd/submit.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <uapi/linux/idxd.h>\n#include \"idxd.h\"\n#include \"registers.h\"\n\nstatic struct idxd_desc *__get_desc(struct idxd_wq *wq, int idx, int cpu)\n{\n\tstruct idxd_desc *desc;\n\tstruct idxd_device *idxd = wq->idxd;\n\n\tdesc = wq->descs[idx];\n\tmemset(desc->hw, 0, sizeof(struct dsa_hw_desc));\n\tmemset(desc->completion, 0, idxd->data->compl_size);\n\tdesc->cpu = cpu;\n\n\tif (device_pasid_enabled(idxd))\n\t\tdesc->hw->pasid = idxd->pasid;\n\n\treturn desc;\n}\n\nstruct idxd_desc *idxd_alloc_desc(struct idxd_wq *wq, enum idxd_op_type optype)\n{\n\tint cpu, idx;\n\tstruct idxd_device *idxd = wq->idxd;\n\tDEFINE_SBQ_WAIT(wait);\n\tstruct sbq_wait_state *ws;\n\tstruct sbitmap_queue *sbq;\n\n\tif (idxd->state != IDXD_DEV_ENABLED)\n\t\treturn ERR_PTR(-EIO);\n\n\tsbq = &wq->sbq;\n\tidx = sbitmap_queue_get(sbq, &cpu);\n\tif (idx < 0) {\n\t\tif (optype == IDXD_OP_NONBLOCK)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t} else {\n\t\treturn __get_desc(wq, idx, cpu);\n\t}\n\n\tws = &sbq->ws[0];\n\tfor (;;) {\n\t\tsbitmap_prepare_to_wait(sbq, ws, &wait, TASK_INTERRUPTIBLE);\n\t\tif (signal_pending_state(TASK_INTERRUPTIBLE, current))\n\t\t\tbreak;\n\t\tidx = sbitmap_queue_get(sbq, &cpu);\n\t\tif (idx >= 0)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\tsbitmap_finish_wait(sbq, ws, &wait);\n\tif (idx < 0)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\treturn __get_desc(wq, idx, cpu);\n}\n\nvoid idxd_free_desc(struct idxd_wq *wq, struct idxd_desc *desc)\n{\n\tint cpu = desc->cpu;\n\n\tdesc->cpu = -1;\n\tsbitmap_queue_clear(&wq->sbq, desc->id, cpu);\n}\n\nstatic struct idxd_desc *list_abort_desc(struct idxd_wq *wq, struct idxd_irq_entry *ie,\n\t\t\t\t\t struct idxd_desc *desc)\n{\n\tstruct idxd_desc *d, *n;\n\n\tlockdep_assert_held(&ie->list_lock);\n\tlist_for_each_entry_safe(d, n, &ie->work_list, list) {\n\t\tif (d == desc) {\n\t\t\tlist_del(&d->list);\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t \n\treturn NULL;\n}\n\nstatic void llist_abort_desc(struct idxd_wq *wq, struct idxd_irq_entry *ie,\n\t\t\t     struct idxd_desc *desc)\n{\n\tstruct idxd_desc *d, *t, *found = NULL;\n\tstruct llist_node *head;\n\tLIST_HEAD(flist);\n\n\tdesc->completion->status = IDXD_COMP_DESC_ABORT;\n\t \n\tspin_lock(&ie->list_lock);\n\thead = llist_del_all(&ie->pending_llist);\n\tif (head) {\n\t\tllist_for_each_entry_safe(d, t, head, llnode) {\n\t\t\tif (d == desc) {\n\t\t\t\tfound = desc;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d->completion->status)\n\t\t\t\tlist_add_tail(&d->list, &flist);\n\t\t\telse\n\t\t\t\tlist_add_tail(&d->list, &ie->work_list);\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = list_abort_desc(wq, ie, desc);\n\tspin_unlock(&ie->list_lock);\n\n\tif (found)\n\t\tidxd_dma_complete_txd(found, IDXD_COMPLETE_ABORT, false);\n\n\t \n\tlist_for_each_entry_safe(d, t, &flist, list) {\n\t\tlist_del_init(&d->list);\n\t\tidxd_dma_complete_txd(found, IDXD_COMPLETE_ABORT, true);\n\t}\n}\n\n \nint idxd_enqcmds(struct idxd_wq *wq, void __iomem *portal, const void *desc)\n{\n\tunsigned int retries = wq->enqcmds_retries;\n\tint rc;\n\n\tdo {\n\t\trc = enqcmds(portal, desc);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t} while (retries--);\n\n\treturn rc;\n}\n\nint idxd_submit_desc(struct idxd_wq *wq, struct idxd_desc *desc)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct idxd_irq_entry *ie = NULL;\n\tu32 desc_flags = desc->hw->flags;\n\tvoid __iomem *portal;\n\tint rc;\n\n\tif (idxd->state != IDXD_DEV_ENABLED)\n\t\treturn -EIO;\n\n\tif (!percpu_ref_tryget_live(&wq->wq_active)) {\n\t\twait_for_completion(&wq->wq_resurrect);\n\t\tif (!percpu_ref_tryget_live(&wq->wq_active))\n\t\t\treturn -ENXIO;\n\t}\n\n\tportal = idxd_wq_portal_addr(wq);\n\n\t \n\tif (desc_flags & IDXD_OP_FLAG_RCI) {\n\t\tie = &wq->ie;\n\t\tdesc->hw->int_handle = ie->int_handle;\n\t\tllist_add(&desc->llnode, &ie->pending_llist);\n\t}\n\n\t \n\twmb();\n\n\tif (wq_dedicated(wq)) {\n\t\tiosubmit_cmds512(portal, desc->hw, 1);\n\t} else {\n\t\trc = idxd_enqcmds(wq, portal, desc->hw);\n\t\tif (rc < 0) {\n\t\t\tpercpu_ref_put(&wq->wq_active);\n\t\t\t \n\t\t\tif (ie)\n\t\t\t\tllist_abort_desc(wq, ie, desc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tpercpu_ref_put(&wq->wq_active);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}