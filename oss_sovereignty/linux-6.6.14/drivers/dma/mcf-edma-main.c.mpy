{
  "module_name": "mcf-edma-main.c",
  "hash_id": "362cee666da4cff92bed07188093fa50e486a9dc7abf24a27d583f3701683d8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/mcf-edma-main.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/dma-mcf-edma.h>\n\n#include \"fsl-edma-common.h\"\n\n#define EDMA_CHANNELS\t\t64\n#define EDMA_MASK_CH(x)\t\t((x) & GENMASK(5, 0))\n\nstatic irqreturn_t mcf_edma_tx_handler(int irq, void *dev_id)\n{\n\tstruct fsl_edma_engine *mcf_edma = dev_id;\n\tstruct edma_regs *regs = &mcf_edma->regs;\n\tunsigned int ch;\n\tu64 intmap;\n\n\tintmap = ioread32(regs->inth);\n\tintmap <<= 32;\n\tintmap |= ioread32(regs->intl);\n\tif (!intmap)\n\t\treturn IRQ_NONE;\n\n\tfor (ch = 0; ch < mcf_edma->n_chans; ch++) {\n\t\tif (intmap & BIT(ch)) {\n\t\t\tiowrite8(EDMA_MASK_CH(ch), regs->cint);\n\t\t\tfsl_edma_tx_chan_handler(&mcf_edma->chans[ch]);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mcf_edma_err_handler(int irq, void *dev_id)\n{\n\tstruct fsl_edma_engine *mcf_edma = dev_id;\n\tstruct edma_regs *regs = &mcf_edma->regs;\n\tunsigned int err, ch;\n\n\terr = ioread32(regs->errl);\n\tif (!err)\n\t\treturn IRQ_NONE;\n\n\tfor (ch = 0; ch < (EDMA_CHANNELS / 2); ch++) {\n\t\tif (err & BIT(ch)) {\n\t\t\tfsl_edma_disable_request(&mcf_edma->chans[ch]);\n\t\t\tiowrite8(EDMA_CERR_CERR(ch), regs->cerr);\n\t\t\tfsl_edma_err_chan_handler(&mcf_edma->chans[ch]);\n\t\t}\n\t}\n\n\terr = ioread32(regs->errh);\n\tif (!err)\n\t\treturn IRQ_NONE;\n\n\tfor (ch = (EDMA_CHANNELS / 2); ch < EDMA_CHANNELS; ch++) {\n\t\tif (err & (BIT(ch - (EDMA_CHANNELS / 2)))) {\n\t\t\tfsl_edma_disable_request(&mcf_edma->chans[ch]);\n\t\t\tiowrite8(EDMA_CERR_CERR(ch), regs->cerr);\n\t\t\tmcf_edma->chans[ch].status = DMA_ERROR;\n\t\t\tmcf_edma->chans[ch].idle = true;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mcf_edma_irq_init(struct platform_device *pdev,\n\t\t\t\tstruct fsl_edma_engine *mcf_edma)\n{\n\tint ret = 0, i;\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev,\n\t\t\t\tIORESOURCE_IRQ, \"edma-tx-00-15\");\n\tif (!res)\n\t\treturn -1;\n\n\tfor (ret = 0, i = res->start; i <= res->end; ++i)\n\t\tret |= request_irq(i, mcf_edma_tx_handler, 0, \"eDMA\", mcf_edma);\n\tif (ret)\n\t\treturn ret;\n\n\tres = platform_get_resource_byname(pdev,\n\t\t\tIORESOURCE_IRQ, \"edma-tx-16-55\");\n\tif (!res)\n\t\treturn -1;\n\n\tfor (ret = 0, i = res->start; i <= res->end; ++i)\n\t\tret |= request_irq(i, mcf_edma_tx_handler, 0, \"eDMA\", mcf_edma);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_get_irq_byname(pdev, \"edma-tx-56-63\");\n\tif (ret != -ENXIO) {\n\t\tret = request_irq(ret, mcf_edma_tx_handler,\n\t\t\t\t  0, \"eDMA\", mcf_edma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = platform_get_irq_byname(pdev, \"edma-err\");\n\tif (ret != -ENXIO) {\n\t\tret = request_irq(ret, mcf_edma_err_handler,\n\t\t\t\t  0, \"eDMA\", mcf_edma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mcf_edma_irq_free(struct platform_device *pdev,\n\t\t\t\tstruct fsl_edma_engine *mcf_edma)\n{\n\tint irq;\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev,\n\t\t\tIORESOURCE_IRQ, \"edma-tx-00-15\");\n\tif (res) {\n\t\tfor (irq = res->start; irq <= res->end; irq++)\n\t\t\tfree_irq(irq, mcf_edma);\n\t}\n\n\tres = platform_get_resource_byname(pdev,\n\t\t\tIORESOURCE_IRQ, \"edma-tx-16-55\");\n\tif (res) {\n\t\tfor (irq = res->start; irq <= res->end; irq++)\n\t\t\tfree_irq(irq, mcf_edma);\n\t}\n\n\tirq = platform_get_irq_byname(pdev, \"edma-tx-56-63\");\n\tif (irq != -ENXIO)\n\t\tfree_irq(irq, mcf_edma);\n\n\tirq = platform_get_irq_byname(pdev, \"edma-err\");\n\tif (irq != -ENXIO)\n\t\tfree_irq(irq, mcf_edma);\n}\n\nstatic struct fsl_edma_drvdata mcf_data = {\n\t.flags = FSL_EDMA_DRV_EDMA64,\n\t.setup_irq = mcf_edma_irq_init,\n};\n\nstatic int mcf_edma_probe(struct platform_device *pdev)\n{\n\tstruct mcf_edma_platform_data *pdata;\n\tstruct fsl_edma_engine *mcf_edma;\n\tstruct edma_regs *regs;\n\tint ret, i, chans;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->dma_channels) {\n\t\tdev_info(&pdev->dev, \"setting default channel number to 64\");\n\t\tchans = 64;\n\t} else {\n\t\tchans = pdata->dma_channels;\n\t}\n\n\tmcf_edma = devm_kzalloc(&pdev->dev, struct_size(mcf_edma, chans, chans),\n\t\t\t\tGFP_KERNEL);\n\tif (!mcf_edma)\n\t\treturn -ENOMEM;\n\n\tmcf_edma->n_chans = chans;\n\n\t \n\tmcf_edma->drvdata = &mcf_data;\n\tmcf_edma->big_endian = 1;\n\n\tmutex_init(&mcf_edma->fsl_edma_mutex);\n\n\tmcf_edma->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mcf_edma->membase))\n\t\treturn PTR_ERR(mcf_edma->membase);\n\n\tfsl_edma_setup_regs(mcf_edma);\n\tregs = &mcf_edma->regs;\n\n\tINIT_LIST_HEAD(&mcf_edma->dma_dev.channels);\n\tfor (i = 0; i < mcf_edma->n_chans; i++) {\n\t\tstruct fsl_edma_chan *mcf_chan = &mcf_edma->chans[i];\n\n\t\tmcf_chan->edma = mcf_edma;\n\t\tmcf_chan->slave_id = i;\n\t\tmcf_chan->idle = true;\n\t\tmcf_chan->dma_dir = DMA_NONE;\n\t\tmcf_chan->vchan.desc_free = fsl_edma_free_desc;\n\t\tvchan_init(&mcf_chan->vchan, &mcf_edma->dma_dev);\n\t\tmcf_chan->tcd = mcf_edma->membase + EDMA_TCD\n\t\t\t\t+ i * sizeof(struct fsl_edma_hw_tcd);\n\t\tiowrite32(0x0, &mcf_chan->tcd->csr);\n\t}\n\n\tiowrite32(~0, regs->inth);\n\tiowrite32(~0, regs->intl);\n\n\tret = mcf_edma->drvdata->setup_irq(pdev, mcf_edma);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_cap_set(DMA_PRIVATE, mcf_edma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_SLAVE, mcf_edma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, mcf_edma->dma_dev.cap_mask);\n\n\tmcf_edma->dma_dev.dev = &pdev->dev;\n\tmcf_edma->dma_dev.device_alloc_chan_resources =\n\t\t\tfsl_edma_alloc_chan_resources;\n\tmcf_edma->dma_dev.device_free_chan_resources =\n\t\t\tfsl_edma_free_chan_resources;\n\tmcf_edma->dma_dev.device_config = fsl_edma_slave_config;\n\tmcf_edma->dma_dev.device_prep_dma_cyclic =\n\t\t\tfsl_edma_prep_dma_cyclic;\n\tmcf_edma->dma_dev.device_prep_slave_sg = fsl_edma_prep_slave_sg;\n\tmcf_edma->dma_dev.device_tx_status = fsl_edma_tx_status;\n\tmcf_edma->dma_dev.device_pause = fsl_edma_pause;\n\tmcf_edma->dma_dev.device_resume = fsl_edma_resume;\n\tmcf_edma->dma_dev.device_terminate_all = fsl_edma_terminate_all;\n\tmcf_edma->dma_dev.device_issue_pending = fsl_edma_issue_pending;\n\n\tmcf_edma->dma_dev.src_addr_widths = FSL_EDMA_BUSWIDTHS;\n\tmcf_edma->dma_dev.dst_addr_widths = FSL_EDMA_BUSWIDTHS;\n\tmcf_edma->dma_dev.directions =\n\t\t\tBIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\n\tmcf_edma->dma_dev.filter.fn = mcf_edma_filter_fn;\n\tmcf_edma->dma_dev.filter.map = pdata->slave_map;\n\tmcf_edma->dma_dev.filter.mapcnt = pdata->slavecnt;\n\n\tplatform_set_drvdata(pdev, mcf_edma);\n\n\tret = dma_async_device_register(&mcf_edma->dma_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't register Freescale eDMA engine. (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tiowrite32(EDMA_CR_ERGA | EDMA_CR_ERCA, regs->cr);\n\n\treturn 0;\n}\n\nstatic int mcf_edma_remove(struct platform_device *pdev)\n{\n\tstruct fsl_edma_engine *mcf_edma = platform_get_drvdata(pdev);\n\n\tmcf_edma_irq_free(pdev, mcf_edma);\n\tfsl_edma_cleanup_vchan(&mcf_edma->dma_dev);\n\tdma_async_device_unregister(&mcf_edma->dma_dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mcf_edma_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mcf-edma\",\n\t},\n\t.probe\t\t= mcf_edma_probe,\n\t.remove\t\t= mcf_edma_remove,\n};\n\nbool mcf_edma_filter_fn(struct dma_chan *chan, void *param)\n{\n\tif (chan->device->dev->driver == &mcf_edma_driver.driver) {\n\t\tstruct fsl_edma_chan *mcf_chan = to_fsl_edma_chan(chan);\n\n\t\treturn (mcf_chan->slave_id == (uintptr_t)param);\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(mcf_edma_filter_fn);\n\nstatic int __init mcf_edma_init(void)\n{\n\treturn platform_driver_register(&mcf_edma_driver);\n}\nsubsys_initcall(mcf_edma_init);\n\nstatic void __exit mcf_edma_exit(void)\n{\n\tplatform_driver_unregister(&mcf_edma_driver);\n}\nmodule_exit(mcf_edma_exit);\n\nMODULE_ALIAS(\"platform:mcf-edma\");\nMODULE_DESCRIPTION(\"Freescale eDMA engine driver, ColdFire family\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}