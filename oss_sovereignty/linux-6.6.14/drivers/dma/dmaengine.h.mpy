{
  "module_name": "dmaengine.h",
  "hash_id": "009b9f474538e28edb1b89be7f5ea81cffced179fa3861e09558dec89c5484e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dmaengine.h",
  "human_readable_source": " \n \n#ifndef DMAENGINE_H\n#define DMAENGINE_H\n\n#include <linux/bug.h>\n#include <linux/dmaengine.h>\n\n \nstatic inline void dma_cookie_init(struct dma_chan *chan)\n{\n\tchan->cookie = DMA_MIN_COOKIE;\n\tchan->completed_cookie = DMA_MIN_COOKIE;\n}\n\n \nstatic inline dma_cookie_t dma_cookie_assign(struct dma_async_tx_descriptor *tx)\n{\n\tstruct dma_chan *chan = tx->chan;\n\tdma_cookie_t cookie;\n\n\tcookie = chan->cookie + 1;\n\tif (cookie < DMA_MIN_COOKIE)\n\t\tcookie = DMA_MIN_COOKIE;\n\ttx->cookie = chan->cookie = cookie;\n\n\treturn cookie;\n}\n\n \nstatic inline void dma_cookie_complete(struct dma_async_tx_descriptor *tx)\n{\n\tBUG_ON(tx->cookie < DMA_MIN_COOKIE);\n\ttx->chan->completed_cookie = tx->cookie;\n\ttx->cookie = 0;\n}\n\n \nstatic inline enum dma_status dma_cookie_status(struct dma_chan *chan,\n\tdma_cookie_t cookie, struct dma_tx_state *state)\n{\n\tdma_cookie_t used, complete;\n\n\tused = chan->cookie;\n\tcomplete = chan->completed_cookie;\n\tbarrier();\n\tif (state) {\n\t\tstate->last = complete;\n\t\tstate->used = used;\n\t\tstate->residue = 0;\n\t\tstate->in_flight_bytes = 0;\n\t}\n\treturn dma_async_is_complete(cookie, complete, used);\n}\n\nstatic inline void dma_set_residue(struct dma_tx_state *state, u32 residue)\n{\n\tif (state)\n\t\tstate->residue = residue;\n}\n\nstatic inline void dma_set_in_flight_bytes(struct dma_tx_state *state,\n\t\t\t\t\t   u32 in_flight_bytes)\n{\n\tif (state)\n\t\tstate->in_flight_bytes = in_flight_bytes;\n}\n\nstruct dmaengine_desc_callback {\n\tdma_async_tx_callback callback;\n\tdma_async_tx_callback_result callback_result;\n\tvoid *callback_param;\n};\n\n \nstatic inline void\ndmaengine_desc_get_callback(struct dma_async_tx_descriptor *tx,\n\t\t\t    struct dmaengine_desc_callback *cb)\n{\n\tcb->callback = tx->callback;\n\tcb->callback_result = tx->callback_result;\n\tcb->callback_param = tx->callback_param;\n}\n\n \nstatic inline void\ndmaengine_desc_callback_invoke(struct dmaengine_desc_callback *cb,\n\t\t\t       const struct dmaengine_result *result)\n{\n\tstruct dmaengine_result dummy_result = {\n\t\t.result = DMA_TRANS_NOERROR,\n\t\t.residue = 0\n\t};\n\n\tif (cb->callback_result) {\n\t\tif (!result)\n\t\t\tresult = &dummy_result;\n\t\tcb->callback_result(cb->callback_param, result);\n\t} else if (cb->callback) {\n\t\tcb->callback(cb->callback_param);\n\t}\n}\n\n \nstatic inline void\ndmaengine_desc_get_callback_invoke(struct dma_async_tx_descriptor *tx,\n\t\t\t\t   const struct dmaengine_result *result)\n{\n\tstruct dmaengine_desc_callback cb;\n\n\tdmaengine_desc_get_callback(tx, &cb);\n\tdmaengine_desc_callback_invoke(&cb, result);\n}\n\n \nstatic inline bool\ndmaengine_desc_callback_valid(struct dmaengine_desc_callback *cb)\n{\n\treturn cb->callback || cb->callback_result;\n}\n\nstruct dma_chan *dma_get_slave_channel(struct dma_chan *chan);\nstruct dma_chan *dma_get_any_slave_channel(struct dma_device *device);\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n\nstatic inline struct dentry *\ndmaengine_get_debugfs_root(struct dma_device *dma_dev) {\n\treturn dma_dev->dbg_dev_root;\n}\n#else\nstruct dentry;\nstatic inline struct dentry *\ndmaengine_get_debugfs_root(struct dma_device *dma_dev)\n{\n\treturn NULL;\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}