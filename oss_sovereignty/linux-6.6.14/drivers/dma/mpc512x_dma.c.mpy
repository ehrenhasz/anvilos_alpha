{
  "module_name": "mpc512x_dma.c",
  "hash_id": "8b3939af954bf77a11c47e0a639c02a78e8f238da61f51d4fb8d310a9fd3e03a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/mpc512x_dma.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n\n#include <linux/random.h>\n\n#include \"dmaengine.h\"\n\n \n#define MPC_DMA_DESCRIPTORS\t64\n\n \n#define MPC_DMA_TCD_OFFSET\t0x1000\n\n \n#define MPC8308_DMACHAN_MAX\t16\n#define MPC512x_DMACHAN_MAX\t64\n#define MPC_DMA_CHANNELS\t64\n\n \n#define MPC_DMA_DMACR_EDCG\t(1 << 31)\n#define MPC_DMA_DMACR_ERGA\t(1 << 3)\n#define MPC_DMA_DMACR_ERCA\t(1 << 2)\n\n \n#define MPC_DMA_DMAES_VLD\t(1 << 31)\n#define MPC_DMA_DMAES_GPE\t(1 << 15)\n#define MPC_DMA_DMAES_CPE\t(1 << 14)\n#define MPC_DMA_DMAES_ERRCHN(err) \\\n\t\t\t\t(((err) >> 8) & 0x3f)\n#define MPC_DMA_DMAES_SAE\t(1 << 7)\n#define MPC_DMA_DMAES_SOE\t(1 << 6)\n#define MPC_DMA_DMAES_DAE\t(1 << 5)\n#define MPC_DMA_DMAES_DOE\t(1 << 4)\n#define MPC_DMA_DMAES_NCE\t(1 << 3)\n#define MPC_DMA_DMAES_SGE\t(1 << 2)\n#define MPC_DMA_DMAES_SBE\t(1 << 1)\n#define MPC_DMA_DMAES_DBE\t(1 << 0)\n\n#define MPC_DMA_DMAGPOR_SNOOP_ENABLE\t(1 << 6)\n\n#define MPC_DMA_TSIZE_1\t\t0x00\n#define MPC_DMA_TSIZE_2\t\t0x01\n#define MPC_DMA_TSIZE_4\t\t0x02\n#define MPC_DMA_TSIZE_16\t0x04\n#define MPC_DMA_TSIZE_32\t0x05\n\n \nstruct __attribute__ ((__packed__)) mpc_dma_regs {\n\t \n\tu32 dmacr;\t\t \n\tu32 dmaes;\t\t \n\t \n\tu32 dmaerqh;\t\t \n\tu32 dmaerql;\t\t \n\tu32 dmaeeih;\t\t \n\tu32 dmaeeil;\t\t \n\t \n\tu8 dmaserq;\t\t \n\tu8 dmacerq;\t\t \n\tu8 dmaseei;\t\t \n\tu8 dmaceei;\t\t \n\t \n\tu8 dmacint;\t\t \n\tu8 dmacerr;\t\t \n\tu8 dmassrt;\t\t \n\tu8 dmacdne;\t\t \n\t \n\tu32 dmainth;\t\t \n\tu32 dmaintl;\t\t \n\tu32 dmaerrh;\t\t \n\tu32 dmaerrl;\t\t \n\t \n\tu32 dmahrsh;\t\t \n\tu32 dmahrsl;\t\t \n\tunion {\n\t\tu32 dmaihsa;\t \n\t\tu32 dmagpor;\t \n\t};\n\tu32 dmailsa;\t\t \n\t \n\tu32 reserve0[48];\t \n\t \n\tu8 dchpri[MPC_DMA_CHANNELS];\n\t \n};\n\nstruct __attribute__ ((__packed__)) mpc_dma_tcd {\n\t \n\tu32 saddr;\t\t \n\n\tu32 smod:5;\t\t \n\tu32 ssize:3;\t\t \n\tu32 dmod:5;\t\t \n\tu32 dsize:3;\t\t \n\tu32 soff:16;\t\t \n\n\t \n\tu32 nbytes;\t\t \n\tu32 slast;\t\t \n\tu32 daddr;\t\t \n\n\t \n\tu32 citer_elink:1;\t \n\tu32 citer_linkch:6;\t \n\tu32 citer:9;\t\t \n\tu32 doff:16;\t\t \n\n\t \n\tu32 dlast_sga;\t\t \n\n\t \n\tu32 biter_elink:1;\t \n\tu32 biter_linkch:6;\n\tu32 biter:9;\t\t \n\tu32 bwc:2;\t\t \n\tu32 major_linkch:6;\t \n\tu32 done:1;\t\t \n\tu32 active:1;\t\t \n\tu32 major_elink:1;\t \n\tu32 e_sg:1;\t\t \n\tu32 d_req:1;\t\t \n\tu32 int_half:1;\t\t \n\tu32 int_maj:1;\t\t \n\tu32 start:1;\t\t \n};\n\nstruct mpc_dma_desc {\n\tstruct dma_async_tx_descriptor\tdesc;\n\tstruct mpc_dma_tcd\t\t*tcd;\n\tdma_addr_t\t\t\ttcd_paddr;\n\tint\t\t\t\terror;\n\tstruct list_head\t\tnode;\n\tint\t\t\t\twill_access_peripheral;\n};\n\nstruct mpc_dma_chan {\n\tstruct dma_chan\t\t\tchan;\n\tstruct list_head\t\tfree;\n\tstruct list_head\t\tprepared;\n\tstruct list_head\t\tqueued;\n\tstruct list_head\t\tactive;\n\tstruct list_head\t\tcompleted;\n\tstruct mpc_dma_tcd\t\t*tcd;\n\tdma_addr_t\t\t\ttcd_paddr;\n\n\t \n\tdma_addr_t\t\t\tsrc_per_paddr;\n\tu32\t\t\t\tsrc_tcd_nunits;\n\tu8\t\t\t\tswidth;\n\tdma_addr_t\t\t\tdst_per_paddr;\n\tu32\t\t\t\tdst_tcd_nunits;\n\tu8\t\t\t\tdwidth;\n\n\t \n\tspinlock_t\t\t\tlock;\n};\n\nstruct mpc_dma {\n\tstruct dma_device\t\tdma;\n\tstruct tasklet_struct\t\ttasklet;\n\tstruct mpc_dma_chan\t\tchannels[MPC_DMA_CHANNELS];\n\tstruct mpc_dma_regs __iomem\t*regs;\n\tstruct mpc_dma_tcd __iomem\t*tcd;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tirq2;\n\tuint\t\t\t\terror_status;\n\tint\t\t\t\tis_mpc8308;\n\n\t \n\tspinlock_t\t\t\terror_status_lock;\n};\n\n#define DRV_NAME\t\"mpc512x_dma\"\n\n \nstatic inline struct mpc_dma_chan *dma_chan_to_mpc_dma_chan(struct dma_chan *c)\n{\n\treturn container_of(c, struct mpc_dma_chan, chan);\n}\n\n \nstatic inline struct mpc_dma *dma_chan_to_mpc_dma(struct dma_chan *c)\n{\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(c);\n\n\treturn container_of(mchan, struct mpc_dma, channels[c->chan_id]);\n}\n\n \nstatic void mpc_dma_execute(struct mpc_dma_chan *mchan)\n{\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(&mchan->chan);\n\tstruct mpc_dma_desc *first = NULL;\n\tstruct mpc_dma_desc *prev = NULL;\n\tstruct mpc_dma_desc *mdesc;\n\tint cid = mchan->chan.chan_id;\n\n\twhile (!list_empty(&mchan->queued)) {\n\t\tmdesc = list_first_entry(&mchan->queued,\n\t\t\t\t\t\tstruct mpc_dma_desc, node);\n\t\t \n\t\tif (mdesc->will_access_peripheral) {\n\t\t\tif (list_empty(&mchan->active))\n\t\t\t\tlist_move_tail(&mdesc->node, &mchan->active);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlist_move_tail(&mdesc->node, &mchan->active);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(mdesc, &mchan->active, node) {\n\t\tif (!first)\n\t\t\tfirst = mdesc;\n\n\t\tif (!prev) {\n\t\t\tprev = mdesc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprev->tcd->dlast_sga = mdesc->tcd_paddr;\n\t\tprev->tcd->e_sg = 1;\n\t\tmdesc->tcd->start = 1;\n\n\t\tprev = mdesc;\n\t}\n\n\tprev->tcd->int_maj = 1;\n\n\t \n\tmemcpy_toio(&mdma->tcd[cid], first->tcd, sizeof(struct mpc_dma_tcd));\n\n\tif (first != prev)\n\t\tmdma->tcd[cid].e_sg = 1;\n\n\tif (mdma->is_mpc8308) {\n\t\t \n\t\tout_8(&mdma->regs->dmassrt, cid);\n\t} else if (first->will_access_peripheral) {\n\t\t \n\t\tout_8(&mdma->regs->dmaserq, cid);\n\t} else {\n\t\t \n\t\tout_8(&mdma->regs->dmassrt, cid);\n\t}\n}\n\n \nstatic void mpc_dma_irq_process(struct mpc_dma *mdma, u32 is, u32 es, int off)\n{\n\tstruct mpc_dma_chan *mchan;\n\tstruct mpc_dma_desc *mdesc;\n\tu32 status = is | es;\n\tint ch;\n\n\twhile ((ch = fls(status) - 1) >= 0) {\n\t\tstatus &= ~(1 << ch);\n\t\tmchan = &mdma->channels[ch + off];\n\n\t\tspin_lock(&mchan->lock);\n\n\t\tout_8(&mdma->regs->dmacint, ch + off);\n\t\tout_8(&mdma->regs->dmacerr, ch + off);\n\n\t\t \n\t\tif (es & (1 << ch))\n\t\t\tlist_for_each_entry(mdesc, &mchan->active, node)\n\t\t\t\tmdesc->error = -EIO;\n\n\t\t \n\t\tlist_splice_tail_init(&mchan->active, &mchan->completed);\n\t\tif (!list_empty(&mchan->queued))\n\t\t\tmpc_dma_execute(mchan);\n\n\t\tspin_unlock(&mchan->lock);\n\t}\n}\n\n \nstatic irqreturn_t mpc_dma_irq(int irq, void *data)\n{\n\tstruct mpc_dma *mdma = data;\n\tuint es;\n\n\t \n\tes = in_be32(&mdma->regs->dmaes);\n\tspin_lock(&mdma->error_status_lock);\n\tif ((es & MPC_DMA_DMAES_VLD) && mdma->error_status == 0)\n\t\tmdma->error_status = es;\n\tspin_unlock(&mdma->error_status_lock);\n\n\t \n\tif (mdma->dma.chancnt > 32) {\n\t\tmpc_dma_irq_process(mdma, in_be32(&mdma->regs->dmainth),\n\t\t\t\t\tin_be32(&mdma->regs->dmaerrh), 32);\n\t}\n\tmpc_dma_irq_process(mdma, in_be32(&mdma->regs->dmaintl),\n\t\t\t\t\tin_be32(&mdma->regs->dmaerrl), 0);\n\n\t \n\ttasklet_schedule(&mdma->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void mpc_dma_process_completed(struct mpc_dma *mdma)\n{\n\tdma_cookie_t last_cookie = 0;\n\tstruct mpc_dma_chan *mchan;\n\tstruct mpc_dma_desc *mdesc;\n\tstruct dma_async_tx_descriptor *desc;\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\tint i;\n\n\tfor (i = 0; i < mdma->dma.chancnt; i++) {\n\t\tmchan = &mdma->channels[i];\n\n\t\t \n\t\tspin_lock_irqsave(&mchan->lock, flags);\n\t\tif (!list_empty(&mchan->completed))\n\t\t\tlist_splice_tail_init(&mchan->completed, &list);\n\t\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\t\tif (list_empty(&list))\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(mdesc, &list, node) {\n\t\t\tdesc = &mdesc->desc;\n\n\t\t\tdmaengine_desc_get_callback_invoke(desc, NULL);\n\n\t\t\tlast_cookie = desc->cookie;\n\t\t\tdma_run_dependencies(desc);\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&mchan->lock, flags);\n\t\tlist_splice_tail_init(&list, &mchan->free);\n\t\tmchan->chan.completed_cookie = last_cookie;\n\t\tspin_unlock_irqrestore(&mchan->lock, flags);\n\t}\n}\n\n \nstatic void mpc_dma_tasklet(struct tasklet_struct *t)\n{\n\tstruct mpc_dma *mdma = from_tasklet(mdma, t, tasklet);\n\tunsigned long flags;\n\tuint es;\n\n\tspin_lock_irqsave(&mdma->error_status_lock, flags);\n\tes = mdma->error_status;\n\tmdma->error_status = 0;\n\tspin_unlock_irqrestore(&mdma->error_status_lock, flags);\n\n\t \n\tif (es) {\n\t\tdev_err(mdma->dma.dev,\n\t\t\t\"Hardware reported following error(s) on channel %u:\\n\",\n\t\t\t\t\t\t      MPC_DMA_DMAES_ERRCHN(es));\n\n\t\tif (es & MPC_DMA_DMAES_GPE)\n\t\t\tdev_err(mdma->dma.dev, \"- Group Priority Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_CPE)\n\t\t\tdev_err(mdma->dma.dev, \"- Channel Priority Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_SAE)\n\t\t\tdev_err(mdma->dma.dev, \"- Source Address Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_SOE)\n\t\t\tdev_err(mdma->dma.dev, \"- Source Offset Configuration Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_DAE)\n\t\t\tdev_err(mdma->dma.dev, \"- Destination Address Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_DOE)\n\t\t\tdev_err(mdma->dma.dev, \"- Destination Offset Configuration Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_NCE)\n\t\t\tdev_err(mdma->dma.dev, \"- NBytes/Citter Configuration Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_SGE)\n\t\t\tdev_err(mdma->dma.dev, \"- Scatter/Gather Configuration Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_SBE)\n\t\t\tdev_err(mdma->dma.dev, \"- Source Bus Error\\n\");\n\t\tif (es & MPC_DMA_DMAES_DBE)\n\t\t\tdev_err(mdma->dma.dev, \"- Destination Bus Error\\n\");\n\t}\n\n\tmpc_dma_process_completed(mdma);\n}\n\n \nstatic dma_cookie_t mpc_dma_tx_submit(struct dma_async_tx_descriptor *txd)\n{\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(txd->chan);\n\tstruct mpc_dma_desc *mdesc;\n\tunsigned long flags;\n\tdma_cookie_t cookie;\n\n\tmdesc = container_of(txd, struct mpc_dma_desc, desc);\n\n\tspin_lock_irqsave(&mchan->lock, flags);\n\n\t \n\tlist_move_tail(&mdesc->node, &mchan->queued);\n\n\t \n\tif (list_empty(&mchan->active))\n\t\tmpc_dma_execute(mchan);\n\n\t \n\tcookie = dma_cookie_assign(txd);\n\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\treturn cookie;\n}\n\n \nstatic int mpc_dma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(chan);\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma_desc *mdesc;\n\tstruct mpc_dma_tcd *tcd;\n\tdma_addr_t tcd_paddr;\n\tunsigned long flags;\n\tLIST_HEAD(descs);\n\tint i;\n\n\t \n\ttcd = dma_alloc_coherent(mdma->dma.dev,\n\t\t\tMPC_DMA_DESCRIPTORS * sizeof(struct mpc_dma_tcd),\n\t\t\t\t\t\t\t&tcd_paddr, GFP_KERNEL);\n\tif (!tcd)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < MPC_DMA_DESCRIPTORS; i++) {\n\t\tmdesc = kzalloc(sizeof(struct mpc_dma_desc), GFP_KERNEL);\n\t\tif (!mdesc) {\n\t\t\tdev_notice(mdma->dma.dev,\n\t\t\t\t\"Memory allocation error. Allocated only %u descriptors\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_async_tx_descriptor_init(&mdesc->desc, chan);\n\t\tmdesc->desc.flags = DMA_CTRL_ACK;\n\t\tmdesc->desc.tx_submit = mpc_dma_tx_submit;\n\n\t\tmdesc->tcd = &tcd[i];\n\t\tmdesc->tcd_paddr = tcd_paddr + (i * sizeof(struct mpc_dma_tcd));\n\n\t\tlist_add_tail(&mdesc->node, &descs);\n\t}\n\n\t \n\tif (i == 0) {\n\t\tdma_free_coherent(mdma->dma.dev,\n\t\t\tMPC_DMA_DESCRIPTORS * sizeof(struct mpc_dma_tcd),\n\t\t\t\t\t\t\t\ttcd, tcd_paddr);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&mchan->lock, flags);\n\tmchan->tcd = tcd;\n\tmchan->tcd_paddr = tcd_paddr;\n\tlist_splice_tail_init(&descs, &mchan->free);\n\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\t \n\tout_8(&mdma->regs->dmaseei, chan->chan_id);\n\n\treturn 0;\n}\n\n \nstatic void mpc_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(chan);\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma_desc *mdesc, *tmp;\n\tstruct mpc_dma_tcd *tcd;\n\tdma_addr_t tcd_paddr;\n\tunsigned long flags;\n\tLIST_HEAD(descs);\n\n\tspin_lock_irqsave(&mchan->lock, flags);\n\n\t \n\tBUG_ON(!list_empty(&mchan->prepared));\n\tBUG_ON(!list_empty(&mchan->queued));\n\tBUG_ON(!list_empty(&mchan->active));\n\tBUG_ON(!list_empty(&mchan->completed));\n\n\t \n\tlist_splice_tail_init(&mchan->free, &descs);\n\ttcd = mchan->tcd;\n\ttcd_paddr = mchan->tcd_paddr;\n\n\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\t \n\tdma_free_coherent(mdma->dma.dev,\n\t\t\tMPC_DMA_DESCRIPTORS * sizeof(struct mpc_dma_tcd),\n\t\t\t\t\t\t\t\ttcd, tcd_paddr);\n\n\t \n\tlist_for_each_entry_safe(mdesc, tmp, &descs, node)\n\t\tkfree(mdesc);\n\n\t \n\tout_8(&mdma->regs->dmaceei, chan->chan_id);\n}\n\n \nstatic void mpc_dma_issue_pending(struct dma_chan *chan)\n{\n\t \n}\n\n \nstatic enum dma_status\nmpc_dma_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\n\t       struct dma_tx_state *txstate)\n{\n\treturn dma_cookie_status(chan, cookie, txstate);\n}\n\n \nstatic struct dma_async_tx_descriptor *\nmpc_dma_prep_memcpy(struct dma_chan *chan, dma_addr_t dst, dma_addr_t src,\n\t\t\t\t\tsize_t len, unsigned long flags)\n{\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(chan);\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma_desc *mdesc = NULL;\n\tstruct mpc_dma_tcd *tcd;\n\tunsigned long iflags;\n\n\t \n\tspin_lock_irqsave(&mchan->lock, iflags);\n\tif (!list_empty(&mchan->free)) {\n\t\tmdesc = list_first_entry(&mchan->free, struct mpc_dma_desc,\n\t\t\t\t\t\t\t\t\tnode);\n\t\tlist_del(&mdesc->node);\n\t}\n\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\n\tif (!mdesc) {\n\t\t \n\t\tmpc_dma_process_completed(mdma);\n\t\treturn NULL;\n\t}\n\n\tmdesc->error = 0;\n\tmdesc->will_access_peripheral = 0;\n\ttcd = mdesc->tcd;\n\n\t \n\tmemset(tcd, 0, sizeof(struct mpc_dma_tcd));\n\n\tif (IS_ALIGNED(src | dst | len, 32)) {\n\t\ttcd->ssize = MPC_DMA_TSIZE_32;\n\t\ttcd->dsize = MPC_DMA_TSIZE_32;\n\t\ttcd->soff = 32;\n\t\ttcd->doff = 32;\n\t} else if (!mdma->is_mpc8308 && IS_ALIGNED(src | dst | len, 16)) {\n\t\t \n\t\ttcd->ssize = MPC_DMA_TSIZE_16;\n\t\ttcd->dsize = MPC_DMA_TSIZE_16;\n\t\ttcd->soff = 16;\n\t\ttcd->doff = 16;\n\t} else if (IS_ALIGNED(src | dst | len, 4)) {\n\t\ttcd->ssize = MPC_DMA_TSIZE_4;\n\t\ttcd->dsize = MPC_DMA_TSIZE_4;\n\t\ttcd->soff = 4;\n\t\ttcd->doff = 4;\n\t} else if (IS_ALIGNED(src | dst | len, 2)) {\n\t\ttcd->ssize = MPC_DMA_TSIZE_2;\n\t\ttcd->dsize = MPC_DMA_TSIZE_2;\n\t\ttcd->soff = 2;\n\t\ttcd->doff = 2;\n\t} else {\n\t\ttcd->ssize = MPC_DMA_TSIZE_1;\n\t\ttcd->dsize = MPC_DMA_TSIZE_1;\n\t\ttcd->soff = 1;\n\t\ttcd->doff = 1;\n\t}\n\n\ttcd->saddr = src;\n\ttcd->daddr = dst;\n\ttcd->nbytes = len;\n\ttcd->biter = 1;\n\ttcd->citer = 1;\n\n\t \n\tspin_lock_irqsave(&mchan->lock, iflags);\n\tlist_add_tail(&mdesc->node, &mchan->prepared);\n\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\n\treturn &mdesc->desc;\n}\n\ninline u8 buswidth_to_dmatsize(u8 buswidth)\n{\n\tu8 res;\n\n\tfor (res = 0; buswidth > 1; buswidth /= 2)\n\t\tres++;\n\treturn res;\n}\n\nstatic struct dma_async_tx_descriptor *\nmpc_dma_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(chan);\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma_desc *mdesc = NULL;\n\tdma_addr_t per_paddr;\n\tu32 tcd_nunits;\n\tstruct mpc_dma_tcd *tcd;\n\tunsigned long iflags;\n\tstruct scatterlist *sg;\n\tsize_t len;\n\tint iter, i;\n\n\t \n\tif (sg_len != 1)\n\t\treturn NULL;\n\n\tif (!is_slave_direction(direction))\n\t\treturn NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tspin_lock_irqsave(&mchan->lock, iflags);\n\n\t\tmdesc = list_first_entry(&mchan->free,\n\t\t\t\t\t\tstruct mpc_dma_desc, node);\n\t\tif (!mdesc) {\n\t\t\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\t\t\t \n\t\t\tmpc_dma_process_completed(mdma);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlist_del(&mdesc->node);\n\n\t\tif (direction == DMA_DEV_TO_MEM) {\n\t\t\tper_paddr = mchan->src_per_paddr;\n\t\t\ttcd_nunits = mchan->src_tcd_nunits;\n\t\t} else {\n\t\t\tper_paddr = mchan->dst_per_paddr;\n\t\t\ttcd_nunits = mchan->dst_tcd_nunits;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\n\t\tif (per_paddr == 0 || tcd_nunits == 0)\n\t\t\tgoto err_prep;\n\n\t\tmdesc->error = 0;\n\t\tmdesc->will_access_peripheral = 1;\n\n\t\t \n\t\ttcd = mdesc->tcd;\n\n\t\tmemset(tcd, 0, sizeof(struct mpc_dma_tcd));\n\n\t\tif (direction == DMA_DEV_TO_MEM) {\n\t\t\ttcd->saddr = per_paddr;\n\t\t\ttcd->daddr = sg_dma_address(sg);\n\n\t\t\tif (!IS_ALIGNED(sg_dma_address(sg), mchan->dwidth))\n\t\t\t\tgoto err_prep;\n\n\t\t\ttcd->soff = 0;\n\t\t\ttcd->doff = mchan->dwidth;\n\t\t} else {\n\t\t\ttcd->saddr = sg_dma_address(sg);\n\t\t\ttcd->daddr = per_paddr;\n\n\t\t\tif (!IS_ALIGNED(sg_dma_address(sg), mchan->swidth))\n\t\t\t\tgoto err_prep;\n\n\t\t\ttcd->soff = mchan->swidth;\n\t\t\ttcd->doff = 0;\n\t\t}\n\n\t\ttcd->ssize = buswidth_to_dmatsize(mchan->swidth);\n\t\ttcd->dsize = buswidth_to_dmatsize(mchan->dwidth);\n\n\t\tif (mdma->is_mpc8308) {\n\t\t\ttcd->nbytes = sg_dma_len(sg);\n\t\t\tif (!IS_ALIGNED(tcd->nbytes, mchan->swidth))\n\t\t\t\tgoto err_prep;\n\n\t\t\t \n\t\t\ttcd->biter = 1;\n\t\t\ttcd->citer = 1;\n\t\t} else {\n\t\t\tlen = sg_dma_len(sg);\n\t\t\ttcd->nbytes = tcd_nunits * tcd->ssize;\n\t\t\tif (!IS_ALIGNED(len, tcd->nbytes))\n\t\t\t\tgoto err_prep;\n\n\t\t\titer = len / tcd->nbytes;\n\t\t\tif (iter >= 1 << 15) {\n\t\t\t\t \n\t\t\t\tgoto err_prep;\n\t\t\t}\n\t\t\t \n\t\t\ttcd->biter = iter & 0x1ff;\n\t\t\ttcd->biter_linkch = iter >> 9;\n\t\t\ttcd->citer = tcd->biter;\n\t\t\ttcd->citer_linkch = tcd->biter_linkch;\n\t\t}\n\n\t\ttcd->e_sg = 0;\n\t\ttcd->d_req = 1;\n\n\t\t \n\t\tspin_lock_irqsave(&mchan->lock, iflags);\n\t\tlist_add_tail(&mdesc->node, &mchan->prepared);\n\t\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\t}\n\n\treturn &mdesc->desc;\n\nerr_prep:\n\t \n\tspin_lock_irqsave(&mchan->lock, iflags);\n\tlist_add_tail(&mdesc->node, &mchan->free);\n\tspin_unlock_irqrestore(&mchan->lock, iflags);\n\n\treturn NULL;\n}\n\ninline bool is_buswidth_valid(u8 buswidth, bool is_mpc8308)\n{\n\tswitch (buswidth) {\n\tcase 16:\n\t\tif (is_mpc8308)\n\t\t\treturn false;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int mpc_dma_device_config(struct dma_chan *chan,\n\t\t\t\t struct dma_slave_config *cfg)\n{\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(&mchan->chan);\n\tunsigned long flags;\n\n\t \n\n\tif (!IS_ALIGNED(cfg->src_addr, cfg->src_addr_width) ||\n\t    !IS_ALIGNED(cfg->dst_addr, cfg->dst_addr_width)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_buswidth_valid(cfg->src_addr_width, mdma->is_mpc8308) ||\n\t    !is_buswidth_valid(cfg->dst_addr_width, mdma->is_mpc8308))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&mchan->lock, flags);\n\n\tmchan->src_per_paddr = cfg->src_addr;\n\tmchan->src_tcd_nunits = cfg->src_maxburst;\n\tmchan->swidth = cfg->src_addr_width;\n\tmchan->dst_per_paddr = cfg->dst_addr;\n\tmchan->dst_tcd_nunits = cfg->dst_maxburst;\n\tmchan->dwidth = cfg->dst_addr_width;\n\n\t \n\tif (mchan->src_tcd_nunits == 0)\n\t\tmchan->src_tcd_nunits = 1;\n\tif (mchan->dst_tcd_nunits == 0)\n\t\tmchan->dst_tcd_nunits = 1;\n\n\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mpc_dma_device_terminate_all(struct dma_chan *chan)\n{\n\tstruct mpc_dma_chan *mchan = dma_chan_to_mpc_dma_chan(chan);\n\tstruct mpc_dma *mdma = dma_chan_to_mpc_dma(chan);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&mchan->lock, flags);\n\n\tout_8(&mdma->regs->dmacerq, chan->chan_id);\n\tlist_splice_tail_init(&mchan->prepared, &mchan->free);\n\tlist_splice_tail_init(&mchan->queued, &mchan->free);\n\tlist_splice_tail_init(&mchan->active, &mchan->free);\n\n\tspin_unlock_irqrestore(&mchan->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mpc_dma_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct device *dev = &op->dev;\n\tstruct dma_device *dma;\n\tstruct mpc_dma *mdma;\n\tstruct mpc_dma_chan *mchan;\n\tstruct resource res;\n\tulong regs_start, regs_size;\n\tint retval, i;\n\tu8 chancnt;\n\n\tmdma = devm_kzalloc(dev, sizeof(struct mpc_dma), GFP_KERNEL);\n\tif (!mdma) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmdma->irq = irq_of_parse_and_map(dn, 0);\n\tif (!mdma->irq) {\n\t\tdev_err(dev, \"Error mapping IRQ!\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (of_device_is_compatible(dn, \"fsl,mpc8308-dma\")) {\n\t\tmdma->is_mpc8308 = 1;\n\t\tmdma->irq2 = irq_of_parse_and_map(dn, 1);\n\t\tif (!mdma->irq2) {\n\t\t\tdev_err(dev, \"Error mapping IRQ!\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_dispose1;\n\t\t}\n\t}\n\n\tretval = of_address_to_resource(dn, 0, &res);\n\tif (retval) {\n\t\tdev_err(dev, \"Error parsing memory region!\\n\");\n\t\tgoto err_dispose2;\n\t}\n\n\tregs_start = res.start;\n\tregs_size = resource_size(&res);\n\n\tif (!devm_request_mem_region(dev, regs_start, regs_size, DRV_NAME)) {\n\t\tdev_err(dev, \"Error requesting memory region!\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err_dispose2;\n\t}\n\n\tmdma->regs = devm_ioremap(dev, regs_start, regs_size);\n\tif (!mdma->regs) {\n\t\tdev_err(dev, \"Error mapping memory region!\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_dispose2;\n\t}\n\n\tmdma->tcd = (struct mpc_dma_tcd *)((u8 *)(mdma->regs)\n\t\t\t\t\t\t\t+ MPC_DMA_TCD_OFFSET);\n\n\tretval = request_irq(mdma->irq, &mpc_dma_irq, 0, DRV_NAME, mdma);\n\tif (retval) {\n\t\tdev_err(dev, \"Error requesting IRQ!\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_dispose2;\n\t}\n\n\tif (mdma->is_mpc8308) {\n\t\tretval = request_irq(mdma->irq2, &mpc_dma_irq, 0,\n\t\t\t\t\t\t\tDRV_NAME, mdma);\n\t\tif (retval) {\n\t\t\tdev_err(dev, \"Error requesting IRQ2!\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_free1;\n\t\t}\n\t}\n\n\tspin_lock_init(&mdma->error_status_lock);\n\n\tdma = &mdma->dma;\n\tdma->dev = dev;\n\tdma->device_alloc_chan_resources = mpc_dma_alloc_chan_resources;\n\tdma->device_free_chan_resources = mpc_dma_free_chan_resources;\n\tdma->device_issue_pending = mpc_dma_issue_pending;\n\tdma->device_tx_status = mpc_dma_tx_status;\n\tdma->device_prep_dma_memcpy = mpc_dma_prep_memcpy;\n\tdma->device_prep_slave_sg = mpc_dma_prep_slave_sg;\n\tdma->device_config = mpc_dma_device_config;\n\tdma->device_terminate_all = mpc_dma_device_terminate_all;\n\n\tINIT_LIST_HEAD(&dma->channels);\n\tdma_cap_set(DMA_MEMCPY, dma->cap_mask);\n\tdma_cap_set(DMA_SLAVE, dma->cap_mask);\n\n\tif (mdma->is_mpc8308)\n\t\tchancnt = MPC8308_DMACHAN_MAX;\n\telse\n\t\tchancnt = MPC512x_DMACHAN_MAX;\n\n\tfor (i = 0; i < chancnt; i++) {\n\t\tmchan = &mdma->channels[i];\n\n\t\tmchan->chan.device = dma;\n\t\tdma_cookie_init(&mchan->chan);\n\n\t\tINIT_LIST_HEAD(&mchan->free);\n\t\tINIT_LIST_HEAD(&mchan->prepared);\n\t\tINIT_LIST_HEAD(&mchan->queued);\n\t\tINIT_LIST_HEAD(&mchan->active);\n\t\tINIT_LIST_HEAD(&mchan->completed);\n\n\t\tspin_lock_init(&mchan->lock);\n\t\tlist_add_tail(&mchan->chan.device_node, &dma->channels);\n\t}\n\n\ttasklet_setup(&mdma->tasklet, mpc_dma_tasklet);\n\n\t \n\tif (mdma->is_mpc8308) {\n\t\t \n\t\tout_be32(&mdma->regs->dmacr, MPC_DMA_DMACR_ERCA);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmagpor, MPC_DMA_DMAGPOR_SNOOP_ENABLE);\n\t\t \n\t\tout_be32(&mdma->regs->dmaeeil, 0);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmaintl, 0xFFFF);\n\t\tout_be32(&mdma->regs->dmaerrl, 0xFFFF);\n\t} else {\n\t\tout_be32(&mdma->regs->dmacr, MPC_DMA_DMACR_EDCG |\n\t\t\t\t\t\tMPC_DMA_DMACR_ERGA |\n\t\t\t\t\t\tMPC_DMA_DMACR_ERCA);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmaerqh, 0);\n\t\tout_be32(&mdma->regs->dmaerql, 0);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmaeeih, 0);\n\t\tout_be32(&mdma->regs->dmaeeil, 0);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmainth, 0xFFFFFFFF);\n\t\tout_be32(&mdma->regs->dmaintl, 0xFFFFFFFF);\n\t\tout_be32(&mdma->regs->dmaerrh, 0xFFFFFFFF);\n\t\tout_be32(&mdma->regs->dmaerrl, 0xFFFFFFFF);\n\n\t\t \n\t\tout_be32(&mdma->regs->dmaihsa, 0);\n\t\tout_be32(&mdma->regs->dmailsa, 0);\n\t}\n\n\t \n\tdev_set_drvdata(dev, mdma);\n\tretval = dma_async_device_register(dma);\n\tif (retval)\n\t\tgoto err_free2;\n\n\t \n\tif (dev->of_node) {\n\t\tretval = of_dma_controller_register(dev->of_node,\n\t\t\t\t\t\tof_dma_xlate_by_chan_id, mdma);\n\t\tif (retval)\n\t\t\tdev_warn(dev, \"Could not register for OF lookup\\n\");\n\t}\n\n\treturn 0;\n\nerr_free2:\n\tif (mdma->is_mpc8308)\n\t\tfree_irq(mdma->irq2, mdma);\nerr_free1:\n\tfree_irq(mdma->irq, mdma);\nerr_dispose2:\n\tif (mdma->is_mpc8308)\n\t\tirq_dispose_mapping(mdma->irq2);\nerr_dispose1:\n\tirq_dispose_mapping(mdma->irq);\nerr:\n\treturn retval;\n}\n\nstatic int mpc_dma_remove(struct platform_device *op)\n{\n\tstruct device *dev = &op->dev;\n\tstruct mpc_dma *mdma = dev_get_drvdata(dev);\n\n\tif (dev->of_node)\n\t\tof_dma_controller_free(dev->of_node);\n\tdma_async_device_unregister(&mdma->dma);\n\tif (mdma->is_mpc8308) {\n\t\tfree_irq(mdma->irq2, mdma);\n\t\tirq_dispose_mapping(mdma->irq2);\n\t}\n\tfree_irq(mdma->irq, mdma);\n\tirq_dispose_mapping(mdma->irq);\n\ttasklet_kill(&mdma->tasklet);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mpc_dma_match[] = {\n\t{ .compatible = \"fsl,mpc5121-dma\", },\n\t{ .compatible = \"fsl,mpc8308-dma\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc_dma_match);\n\nstatic struct platform_driver mpc_dma_driver = {\n\t.probe\t\t= mpc_dma_probe,\n\t.remove\t\t= mpc_dma_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table\t= mpc_dma_match,\n\t},\n};\n\nmodule_platform_driver(mpc_dma_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Piotr Ziecik <kosmo@semihalf.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}