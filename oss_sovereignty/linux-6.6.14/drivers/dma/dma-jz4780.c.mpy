{
  "module_name": "dma-jz4780.c",
  "hash_id": "0fd9eb42dde939f56fca2f6ce6807e9528e0f30548659fc96b96e26add4bd003",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dma-jz4780.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"dmaengine.h\"\n#include \"virt-dma.h\"\n\n \n#define JZ_DMA_REG_DMAC\t\t0x00\n#define JZ_DMA_REG_DIRQP\t0x04\n#define JZ_DMA_REG_DDR\t\t0x08\n#define JZ_DMA_REG_DDRS\t\t0x0c\n#define JZ_DMA_REG_DCKE\t\t0x10\n#define JZ_DMA_REG_DCKES\t0x14\n#define JZ_DMA_REG_DCKEC\t0x18\n#define JZ_DMA_REG_DMACP\t0x1c\n#define JZ_DMA_REG_DSIRQP\t0x20\n#define JZ_DMA_REG_DSIRQM\t0x24\n#define JZ_DMA_REG_DCIRQP\t0x28\n#define JZ_DMA_REG_DCIRQM\t0x2c\n\n \n#define JZ_DMA_REG_CHAN(n)\t(n * 0x20)\n#define JZ_DMA_REG_DSA\t\t0x00\n#define JZ_DMA_REG_DTA\t\t0x04\n#define JZ_DMA_REG_DTC\t\t0x08\n#define JZ_DMA_REG_DRT\t\t0x0c\n#define JZ_DMA_REG_DCS\t\t0x10\n#define JZ_DMA_REG_DCM\t\t0x14\n#define JZ_DMA_REG_DDA\t\t0x18\n#define JZ_DMA_REG_DSD\t\t0x1c\n\n#define JZ_DMA_DMAC_DMAE\tBIT(0)\n#define JZ_DMA_DMAC_AR\t\tBIT(2)\n#define JZ_DMA_DMAC_HLT\t\tBIT(3)\n#define JZ_DMA_DMAC_FAIC\tBIT(27)\n#define JZ_DMA_DMAC_FMSC\tBIT(31)\n\n#define JZ_DMA_DRT_AUTO\t\t0x8\n\n#define JZ_DMA_DCS_CTE\t\tBIT(0)\n#define JZ_DMA_DCS_HLT\t\tBIT(2)\n#define JZ_DMA_DCS_TT\t\tBIT(3)\n#define JZ_DMA_DCS_AR\t\tBIT(4)\n#define JZ_DMA_DCS_DES8\t\tBIT(30)\n\n#define JZ_DMA_DCM_LINK\t\tBIT(0)\n#define JZ_DMA_DCM_TIE\t\tBIT(1)\n#define JZ_DMA_DCM_STDE\t\tBIT(2)\n#define JZ_DMA_DCM_TSZ_SHIFT\t8\n#define JZ_DMA_DCM_TSZ_MASK\t(0x7 << JZ_DMA_DCM_TSZ_SHIFT)\n#define JZ_DMA_DCM_DP_SHIFT\t12\n#define JZ_DMA_DCM_SP_SHIFT\t14\n#define JZ_DMA_DCM_DAI\t\tBIT(22)\n#define JZ_DMA_DCM_SAI\t\tBIT(23)\n\n#define JZ_DMA_SIZE_4_BYTE\t0x0\n#define JZ_DMA_SIZE_1_BYTE\t0x1\n#define JZ_DMA_SIZE_2_BYTE\t0x2\n#define JZ_DMA_SIZE_16_BYTE\t0x3\n#define JZ_DMA_SIZE_32_BYTE\t0x4\n#define JZ_DMA_SIZE_64_BYTE\t0x5\n#define JZ_DMA_SIZE_128_BYTE\t0x6\n\n#define JZ_DMA_WIDTH_32_BIT\t0x0\n#define JZ_DMA_WIDTH_8_BIT\t0x1\n#define JZ_DMA_WIDTH_16_BIT\t0x2\n\n#define JZ_DMA_BUSWIDTHS\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE)\t | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))\n\n#define JZ4780_DMA_CTRL_OFFSET\t0x1000\n\n \n#define JZ_SOC_DATA_ALLOW_LEGACY_DT\tBIT(0)\n#define JZ_SOC_DATA_PROGRAMMABLE_DMA\tBIT(1)\n#define JZ_SOC_DATA_PER_CHAN_PM\t\tBIT(2)\n#define JZ_SOC_DATA_NO_DCKES_DCKEC\tBIT(3)\n#define JZ_SOC_DATA_BREAK_LINKS\t\tBIT(4)\n\n \nstruct jz4780_dma_hwdesc {\n\tu32 dcm;\n\tu32 dsa;\n\tu32 dta;\n\tu32 dtc;\n};\n\n \n#define JZ_DMA_DESC_BLOCK_SIZE\tPAGE_SIZE\n#define JZ_DMA_MAX_DESC\t\t\\\n\t(JZ_DMA_DESC_BLOCK_SIZE / sizeof(struct jz4780_dma_hwdesc))\n\nstruct jz4780_dma_desc {\n\tstruct virt_dma_desc vdesc;\n\n\tstruct jz4780_dma_hwdesc *desc;\n\tdma_addr_t desc_phys;\n\tunsigned int count;\n\tenum dma_transaction_type type;\n\tu32 transfer_type;\n\tu32 status;\n};\n\nstruct jz4780_dma_chan {\n\tstruct virt_dma_chan vchan;\n\tunsigned int id;\n\tstruct dma_pool *desc_pool;\n\n\tu32 transfer_type_tx, transfer_type_rx;\n\tu32 transfer_shift;\n\tstruct dma_slave_config\tconfig;\n\n\tstruct jz4780_dma_desc *desc;\n\tunsigned int curr_hwdesc;\n};\n\nstruct jz4780_dma_soc_data {\n\tunsigned int nb_channels;\n\tunsigned int transfer_ord_max;\n\tunsigned long flags;\n};\n\nstruct jz4780_dma_dev {\n\tstruct dma_device dma_device;\n\tvoid __iomem *chn_base;\n\tvoid __iomem *ctrl_base;\n\tstruct clk *clk;\n\tunsigned int irq;\n\tconst struct jz4780_dma_soc_data *soc_data;\n\n\tu32 chan_reserved;\n\tstruct jz4780_dma_chan chan[];\n};\n\nstruct jz4780_dma_filter_data {\n\tu32 transfer_type_tx, transfer_type_rx;\n\tint channel;\n};\n\nstatic inline struct jz4780_dma_chan *to_jz4780_dma_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct jz4780_dma_chan, vchan.chan);\n}\n\nstatic inline struct jz4780_dma_desc *to_jz4780_dma_desc(\n\tstruct virt_dma_desc *vdesc)\n{\n\treturn container_of(vdesc, struct jz4780_dma_desc, vdesc);\n}\n\nstatic inline struct jz4780_dma_dev *jz4780_dma_chan_parent(\n\tstruct jz4780_dma_chan *jzchan)\n{\n\treturn container_of(jzchan->vchan.chan.device, struct jz4780_dma_dev,\n\t\t\t    dma_device);\n}\n\nstatic inline u32 jz4780_dma_chn_readl(struct jz4780_dma_dev *jzdma,\n\tunsigned int chn, unsigned int reg)\n{\n\treturn readl(jzdma->chn_base + reg + JZ_DMA_REG_CHAN(chn));\n}\n\nstatic inline void jz4780_dma_chn_writel(struct jz4780_dma_dev *jzdma,\n\tunsigned int chn, unsigned int reg, u32 val)\n{\n\twritel(val, jzdma->chn_base + reg + JZ_DMA_REG_CHAN(chn));\n}\n\nstatic inline u32 jz4780_dma_ctrl_readl(struct jz4780_dma_dev *jzdma,\n\tunsigned int reg)\n{\n\treturn readl(jzdma->ctrl_base + reg);\n}\n\nstatic inline void jz4780_dma_ctrl_writel(struct jz4780_dma_dev *jzdma,\n\tunsigned int reg, u32 val)\n{\n\twritel(val, jzdma->ctrl_base + reg);\n}\n\nstatic inline void jz4780_dma_chan_enable(struct jz4780_dma_dev *jzdma,\n\tunsigned int chn)\n{\n\tif (jzdma->soc_data->flags & JZ_SOC_DATA_PER_CHAN_PM) {\n\t\tunsigned int reg;\n\n\t\tif (jzdma->soc_data->flags & JZ_SOC_DATA_NO_DCKES_DCKEC)\n\t\t\treg = JZ_DMA_REG_DCKE;\n\t\telse\n\t\t\treg = JZ_DMA_REG_DCKES;\n\n\t\tjz4780_dma_ctrl_writel(jzdma, reg, BIT(chn));\n\t}\n}\n\nstatic inline void jz4780_dma_chan_disable(struct jz4780_dma_dev *jzdma,\n\tunsigned int chn)\n{\n\tif ((jzdma->soc_data->flags & JZ_SOC_DATA_PER_CHAN_PM) &&\n\t\t\t!(jzdma->soc_data->flags & JZ_SOC_DATA_NO_DCKES_DCKEC))\n\t\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DCKEC, BIT(chn));\n}\n\nstatic struct jz4780_dma_desc *\njz4780_dma_desc_alloc(struct jz4780_dma_chan *jzchan, unsigned int count,\n\t\t      enum dma_transaction_type type,\n\t\t      enum dma_transfer_direction direction)\n{\n\tstruct jz4780_dma_desc *desc;\n\n\tif (count > JZ_DMA_MAX_DESC)\n\t\treturn NULL;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->desc = dma_pool_alloc(jzchan->desc_pool, GFP_NOWAIT,\n\t\t\t\t    &desc->desc_phys);\n\tif (!desc->desc) {\n\t\tkfree(desc);\n\t\treturn NULL;\n\t}\n\n\tdesc->count = count;\n\tdesc->type = type;\n\n\tif (direction == DMA_DEV_TO_MEM)\n\t\tdesc->transfer_type = jzchan->transfer_type_rx;\n\telse\n\t\tdesc->transfer_type = jzchan->transfer_type_tx;\n\n\treturn desc;\n}\n\nstatic void jz4780_dma_desc_free(struct virt_dma_desc *vdesc)\n{\n\tstruct jz4780_dma_desc *desc = to_jz4780_dma_desc(vdesc);\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(vdesc->tx.chan);\n\n\tdma_pool_free(jzchan->desc_pool, desc->desc, desc->desc_phys);\n\tkfree(desc);\n}\n\nstatic u32 jz4780_dma_transfer_size(struct jz4780_dma_chan *jzchan,\n\tunsigned long val, u32 *shift)\n{\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tint ord = ffs(val) - 1;\n\n\t \n\tif (ord == 3)\n\t\tord = 2;\n\telse if (ord > jzdma->soc_data->transfer_ord_max)\n\t\tord = jzdma->soc_data->transfer_ord_max;\n\n\t*shift = ord;\n\n\tswitch (ord) {\n\tcase 0:\n\t\treturn JZ_DMA_SIZE_1_BYTE;\n\tcase 1:\n\t\treturn JZ_DMA_SIZE_2_BYTE;\n\tcase 2:\n\t\treturn JZ_DMA_SIZE_4_BYTE;\n\tcase 4:\n\t\treturn JZ_DMA_SIZE_16_BYTE;\n\tcase 5:\n\t\treturn JZ_DMA_SIZE_32_BYTE;\n\tcase 6:\n\t\treturn JZ_DMA_SIZE_64_BYTE;\n\tdefault:\n\t\treturn JZ_DMA_SIZE_128_BYTE;\n\t}\n}\n\nstatic int jz4780_dma_setup_hwdesc(struct jz4780_dma_chan *jzchan,\n\tstruct jz4780_dma_hwdesc *desc, dma_addr_t addr, size_t len,\n\tenum dma_transfer_direction direction)\n{\n\tstruct dma_slave_config *config = &jzchan->config;\n\tu32 width, maxburst, tsz;\n\n\tif (direction == DMA_MEM_TO_DEV) {\n\t\tdesc->dcm = JZ_DMA_DCM_SAI;\n\t\tdesc->dsa = addr;\n\t\tdesc->dta = config->dst_addr;\n\n\t\twidth = config->dst_addr_width;\n\t\tmaxburst = config->dst_maxburst;\n\t} else {\n\t\tdesc->dcm = JZ_DMA_DCM_DAI;\n\t\tdesc->dsa = config->src_addr;\n\t\tdesc->dta = addr;\n\n\t\twidth = config->src_addr_width;\n\t\tmaxburst = config->src_maxburst;\n\t}\n\n\t \n\ttsz = jz4780_dma_transfer_size(jzchan, addr | len | (width * maxburst),\n\t\t\t\t       &jzchan->transfer_shift);\n\n\tswitch (width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\twidth = JZ_DMA_WIDTH_32_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->dcm |= tsz << JZ_DMA_DCM_TSZ_SHIFT;\n\tdesc->dcm |= width << JZ_DMA_DCM_SP_SHIFT;\n\tdesc->dcm |= width << JZ_DMA_DCM_DP_SHIFT;\n\n\tdesc->dtc = len >> jzchan->transfer_shift;\n\treturn 0;\n}\n\nstatic struct dma_async_tx_descriptor *jz4780_dma_prep_slave_sg(\n\tstruct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,\n\tenum dma_transfer_direction direction, unsigned long flags,\n\tvoid *context)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tstruct jz4780_dma_desc *desc;\n\tunsigned int i;\n\tint err;\n\n\tdesc = jz4780_dma_desc_alloc(jzchan, sg_len, DMA_SLAVE, direction);\n\tif (!desc)\n\t\treturn NULL;\n\n\tfor (i = 0; i < sg_len; i++) {\n\t\terr = jz4780_dma_setup_hwdesc(jzchan, &desc->desc[i],\n\t\t\t\t\t      sg_dma_address(&sgl[i]),\n\t\t\t\t\t      sg_dma_len(&sgl[i]),\n\t\t\t\t\t      direction);\n\t\tif (err < 0) {\n\t\t\tjz4780_dma_desc_free(&jzchan->desc->vdesc);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdesc->desc[i].dcm |= JZ_DMA_DCM_TIE;\n\n\t\tif (i != (sg_len - 1) &&\n\t\t    !(jzdma->soc_data->flags & JZ_SOC_DATA_BREAK_LINKS)) {\n\t\t\t \n\t\t\tdesc->desc[i].dcm |= JZ_DMA_DCM_LINK;\n\n\t\t\t \n\t\t\tdesc->desc[i].dtc |=\n\t\t\t\t(((i + 1) * sizeof(*desc->desc)) >> 4) << 24;\n\t\t}\n\t}\n\n\treturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\n}\n\nstatic struct dma_async_tx_descriptor *jz4780_dma_prep_dma_cyclic(\n\tstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\n\tsize_t period_len, enum dma_transfer_direction direction,\n\tunsigned long flags)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_desc *desc;\n\tunsigned int periods, i;\n\tint err;\n\n\tif (buf_len % period_len)\n\t\treturn NULL;\n\n\tperiods = buf_len / period_len;\n\n\tdesc = jz4780_dma_desc_alloc(jzchan, periods, DMA_CYCLIC, direction);\n\tif (!desc)\n\t\treturn NULL;\n\n\tfor (i = 0; i < periods; i++) {\n\t\terr = jz4780_dma_setup_hwdesc(jzchan, &desc->desc[i], buf_addr,\n\t\t\t\t\t      period_len, direction);\n\t\tif (err < 0) {\n\t\t\tjz4780_dma_desc_free(&jzchan->desc->vdesc);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbuf_addr += period_len;\n\n\t\t \n\t\tdesc->desc[i].dcm |= JZ_DMA_DCM_TIE | JZ_DMA_DCM_LINK;\n\n\t\t \n\t\tif (i != (periods - 1)) {\n\t\t\tdesc->desc[i].dtc |=\n\t\t\t\t(((i + 1) * sizeof(*desc->desc)) >> 4) << 24;\n\t\t}\n\t}\n\n\treturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\n}\n\nstatic struct dma_async_tx_descriptor *jz4780_dma_prep_dma_memcpy(\n\tstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\n\tsize_t len, unsigned long flags)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_desc *desc;\n\tu32 tsz;\n\n\tdesc = jz4780_dma_desc_alloc(jzchan, 1, DMA_MEMCPY, 0);\n\tif (!desc)\n\t\treturn NULL;\n\n\ttsz = jz4780_dma_transfer_size(jzchan, dest | src | len,\n\t\t\t\t       &jzchan->transfer_shift);\n\n\tdesc->transfer_type = JZ_DMA_DRT_AUTO;\n\n\tdesc->desc[0].dsa = src;\n\tdesc->desc[0].dta = dest;\n\tdesc->desc[0].dcm = JZ_DMA_DCM_TIE | JZ_DMA_DCM_SAI | JZ_DMA_DCM_DAI |\n\t\t\t    tsz << JZ_DMA_DCM_TSZ_SHIFT |\n\t\t\t    JZ_DMA_WIDTH_32_BIT << JZ_DMA_DCM_SP_SHIFT |\n\t\t\t    JZ_DMA_WIDTH_32_BIT << JZ_DMA_DCM_DP_SHIFT;\n\tdesc->desc[0].dtc = len >> jzchan->transfer_shift;\n\n\treturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\n}\n\nstatic void jz4780_dma_begin(struct jz4780_dma_chan *jzchan)\n{\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tstruct virt_dma_desc *vdesc;\n\tunsigned int i;\n\tdma_addr_t desc_phys;\n\n\tif (!jzchan->desc) {\n\t\tvdesc = vchan_next_desc(&jzchan->vchan);\n\t\tif (!vdesc)\n\t\t\treturn;\n\n\t\tlist_del(&vdesc->node);\n\n\t\tjzchan->desc = to_jz4780_dma_desc(vdesc);\n\t\tjzchan->curr_hwdesc = 0;\n\n\t\tif (jzchan->desc->type == DMA_CYCLIC && vdesc->tx.callback) {\n\t\t\t \n\t\t\tfor (i = 0; i < jzchan->desc->count; i++)\n\t\t\t\tjzchan->desc->desc[i].dcm &= ~JZ_DMA_DCM_LINK;\n\t\t}\n\t} else {\n\t\t \n\t\tjzchan->curr_hwdesc =\n\t\t\t(jzchan->curr_hwdesc + 1) % jzchan->desc->count;\n\t}\n\n\t \n\tjz4780_dma_chan_enable(jzdma, jzchan->id);\n\n\t \n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DCS, 0);\n\n\t \n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DRT,\n\t\t\t      jzchan->desc->transfer_type);\n\n\t \n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DTC,\n\t\t\t\tjzchan->desc->desc[jzchan->curr_hwdesc].dtc);\n\n\t \n\tdesc_phys = jzchan->desc->desc_phys +\n\t\t    (jzchan->curr_hwdesc * sizeof(*jzchan->desc->desc));\n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DDA, desc_phys);\n\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DDRS, BIT(jzchan->id));\n\n\t \n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DCS,\n\t\t\t      JZ_DMA_DCS_CTE);\n}\n\nstatic void jz4780_dma_issue_pending(struct dma_chan *chan)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&jzchan->vchan.lock, flags);\n\n\tif (vchan_issue_pending(&jzchan->vchan) && !jzchan->desc)\n\t\tjz4780_dma_begin(jzchan);\n\n\tspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\n}\n\nstatic int jz4780_dma_terminate_all(struct dma_chan *chan)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&jzchan->vchan.lock, flags);\n\n\t \n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DCS, 0);\n\tif (jzchan->desc) {\n\t\tvchan_terminate_vdesc(&jzchan->desc->vdesc);\n\t\tjzchan->desc = NULL;\n\t}\n\n\tjz4780_dma_chan_disable(jzdma, jzchan->id);\n\n\tvchan_get_all_descriptors(&jzchan->vchan, &head);\n\n\tspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\n\n\tvchan_dma_desc_free_list(&jzchan->vchan, &head);\n\treturn 0;\n}\n\nstatic void jz4780_dma_synchronize(struct dma_chan *chan)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\n\tvchan_synchronize(&jzchan->vchan);\n\tjz4780_dma_chan_disable(jzdma, jzchan->id);\n}\n\nstatic int jz4780_dma_config(struct dma_chan *chan,\n\tstruct dma_slave_config *config)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\n\tif ((config->src_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES)\n\t   || (config->dst_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES))\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(&jzchan->config, config, sizeof(jzchan->config));\n\n\treturn 0;\n}\n\nstatic size_t jz4780_dma_desc_residue(struct jz4780_dma_chan *jzchan,\n\tstruct jz4780_dma_desc *desc, unsigned int next_sg)\n{\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tunsigned int count = 0;\n\tunsigned int i;\n\n\tfor (i = next_sg; i < desc->count; i++)\n\t\tcount += desc->desc[i].dtc & GENMASK(23, 0);\n\n\tif (next_sg != 0)\n\t\tcount += jz4780_dma_chn_readl(jzdma, jzchan->id,\n\t\t\t\t\t JZ_DMA_REG_DTC);\n\n\treturn count << jzchan->transfer_shift;\n}\n\nstatic enum dma_status jz4780_dma_tx_status(struct dma_chan *chan,\n\tdma_cookie_t cookie, struct dma_tx_state *txstate)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct virt_dma_desc *vdesc;\n\tenum dma_status status;\n\tunsigned long flags;\n\tunsigned long residue = 0;\n\n\tspin_lock_irqsave(&jzchan->vchan.lock, flags);\n\n\tstatus = dma_cookie_status(chan, cookie, txstate);\n\tif ((status == DMA_COMPLETE) || (txstate == NULL))\n\t\tgoto out_unlock_irqrestore;\n\n\tvdesc = vchan_find_desc(&jzchan->vchan, cookie);\n\tif (vdesc) {\n\t\t \n\t\tresidue = jz4780_dma_desc_residue(jzchan,\n\t\t\t\t\tto_jz4780_dma_desc(vdesc), 0);\n\t} else if (cookie == jzchan->desc->vdesc.tx.cookie) {\n\t\tresidue = jz4780_dma_desc_residue(jzchan, jzchan->desc,\n\t\t\t\t\tjzchan->curr_hwdesc + 1);\n\t}\n\tdma_set_residue(txstate, residue);\n\n\tif (vdesc && jzchan->desc && vdesc == &jzchan->desc->vdesc\n\t    && jzchan->desc->status & (JZ_DMA_DCS_AR | JZ_DMA_DCS_HLT))\n\t\tstatus = DMA_ERROR;\n\nout_unlock_irqrestore:\n\tspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\n\treturn status;\n}\n\nstatic bool jz4780_dma_chan_irq(struct jz4780_dma_dev *jzdma,\n\t\t\t\tstruct jz4780_dma_chan *jzchan)\n{\n\tconst unsigned int soc_flags = jzdma->soc_data->flags;\n\tstruct jz4780_dma_desc *desc = jzchan->desc;\n\tu32 dcs;\n\tbool ack = true;\n\n\tspin_lock(&jzchan->vchan.lock);\n\n\tdcs = jz4780_dma_chn_readl(jzdma, jzchan->id, JZ_DMA_REG_DCS);\n\tjz4780_dma_chn_writel(jzdma, jzchan->id, JZ_DMA_REG_DCS, 0);\n\n\tif (dcs & JZ_DMA_DCS_AR) {\n\t\tdev_warn(&jzchan->vchan.chan.dev->device,\n\t\t\t \"address error (DCS=0x%x)\\n\", dcs);\n\t}\n\n\tif (dcs & JZ_DMA_DCS_HLT) {\n\t\tdev_warn(&jzchan->vchan.chan.dev->device,\n\t\t\t \"channel halt (DCS=0x%x)\\n\", dcs);\n\t}\n\n\tif (jzchan->desc) {\n\t\tjzchan->desc->status = dcs;\n\n\t\tif ((dcs & (JZ_DMA_DCS_AR | JZ_DMA_DCS_HLT)) == 0) {\n\t\t\tif (jzchan->desc->type == DMA_CYCLIC) {\n\t\t\t\tvchan_cyclic_callback(&jzchan->desc->vdesc);\n\n\t\t\t\tjz4780_dma_begin(jzchan);\n\t\t\t} else if (dcs & JZ_DMA_DCS_TT) {\n\t\t\t\tif (!(soc_flags & JZ_SOC_DATA_BREAK_LINKS) ||\n\t\t\t\t    (jzchan->curr_hwdesc + 1 == desc->count)) {\n\t\t\t\t\tvchan_cookie_complete(&desc->vdesc);\n\t\t\t\t\tjzchan->desc = NULL;\n\t\t\t\t}\n\n\t\t\t\tjz4780_dma_begin(jzchan);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tack = false;\n\t\t\t\tjz4780_dma_chn_writel(jzdma, jzchan->id,\n\t\t\t\t\t\t      JZ_DMA_REG_DCS,\n\t\t\t\t\t\t      JZ_DMA_DCS_CTE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(&jzchan->vchan.chan.dev->device,\n\t\t\t\"channel IRQ with no active transfer\\n\");\n\t}\n\n\tspin_unlock(&jzchan->vchan.lock);\n\n\treturn ack;\n}\n\nstatic irqreturn_t jz4780_dma_irq_handler(int irq, void *data)\n{\n\tstruct jz4780_dma_dev *jzdma = data;\n\tunsigned int nb_channels = jzdma->soc_data->nb_channels;\n\tunsigned long pending;\n\tu32 dmac;\n\tint i;\n\n\tpending = jz4780_dma_ctrl_readl(jzdma, JZ_DMA_REG_DIRQP);\n\n\tfor_each_set_bit(i, &pending, nb_channels) {\n\t\tif (jz4780_dma_chan_irq(jzdma, &jzdma->chan[i]))\n\t\t\tpending &= ~BIT(i);\n\t}\n\n\t \n\tdmac = jz4780_dma_ctrl_readl(jzdma, JZ_DMA_REG_DMAC);\n\tdmac &= ~(JZ_DMA_DMAC_HLT | JZ_DMA_DMAC_AR);\n\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DMAC, dmac);\n\n\t \n\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DIRQP, pending);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int jz4780_dma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\n\tjzchan->desc_pool = dma_pool_create(dev_name(&chan->dev->device),\n\t\t\t\t\t    chan->device->dev,\n\t\t\t\t\t    JZ_DMA_DESC_BLOCK_SIZE,\n\t\t\t\t\t    PAGE_SIZE, 0);\n\tif (!jzchan->desc_pool) {\n\t\tdev_err(&chan->dev->device,\n\t\t\t\"failed to allocate descriptor pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void jz4780_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\n\tvchan_free_chan_resources(&jzchan->vchan);\n\tdma_pool_destroy(jzchan->desc_pool);\n\tjzchan->desc_pool = NULL;\n}\n\nstatic bool jz4780_dma_filter_fn(struct dma_chan *chan, void *param)\n{\n\tstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\n\tstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\n\tstruct jz4780_dma_filter_data *data = param;\n\n\n\tif (data->channel > -1) {\n\t\tif (data->channel != jzchan->id)\n\t\t\treturn false;\n\t} else if (jzdma->chan_reserved & BIT(jzchan->id)) {\n\t\treturn false;\n\t}\n\n\tjzchan->transfer_type_tx = data->transfer_type_tx;\n\tjzchan->transfer_type_rx = data->transfer_type_rx;\n\n\treturn true;\n}\n\nstatic struct dma_chan *jz4780_of_dma_xlate(struct of_phandle_args *dma_spec,\n\tstruct of_dma *ofdma)\n{\n\tstruct jz4780_dma_dev *jzdma = ofdma->of_dma_data;\n\tdma_cap_mask_t mask = jzdma->dma_device.cap_mask;\n\tstruct jz4780_dma_filter_data data;\n\n\tif (dma_spec->args_count == 2) {\n\t\tdata.transfer_type_tx = dma_spec->args[0];\n\t\tdata.transfer_type_rx = dma_spec->args[0];\n\t\tdata.channel = dma_spec->args[1];\n\t} else if (dma_spec->args_count == 3) {\n\t\tdata.transfer_type_tx = dma_spec->args[0];\n\t\tdata.transfer_type_rx = dma_spec->args[1];\n\t\tdata.channel = dma_spec->args[2];\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tif (data.channel > -1) {\n\t\tif (data.channel >= jzdma->soc_data->nb_channels) {\n\t\t\tdev_err(jzdma->dma_device.dev,\n\t\t\t\t\"device requested non-existent channel %u\\n\",\n\t\t\t\tdata.channel);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (!(jzdma->chan_reserved & BIT(data.channel))) {\n\t\t\tdev_err(jzdma->dma_device.dev,\n\t\t\t\t\"device requested unreserved channel %u\\n\",\n\t\t\t\tdata.channel);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tjzdma->chan[data.channel].transfer_type_tx = data.transfer_type_tx;\n\t\tjzdma->chan[data.channel].transfer_type_rx = data.transfer_type_rx;\n\n\t\treturn dma_get_slave_channel(\n\t\t\t&jzdma->chan[data.channel].vchan.chan);\n\t} else {\n\t\treturn __dma_request_channel(&mask, jz4780_dma_filter_fn, &data,\n\t\t\t\t\t     ofdma->of_node);\n\t}\n}\n\nstatic int jz4780_dma_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct jz4780_dma_soc_data *soc_data;\n\tstruct jz4780_dma_dev *jzdma;\n\tstruct jz4780_dma_chan *jzchan;\n\tstruct dma_device *dd;\n\tstruct resource *res;\n\tint i, ret;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"This driver must be probed from devicetree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsoc_data = device_get_match_data(dev);\n\tif (!soc_data)\n\t\treturn -EINVAL;\n\n\tjzdma = devm_kzalloc(dev, struct_size(jzdma, chan,\n\t\t\t     soc_data->nb_channels), GFP_KERNEL);\n\tif (!jzdma)\n\t\treturn -ENOMEM;\n\n\tjzdma->soc_data = soc_data;\n\tplatform_set_drvdata(pdev, jzdma);\n\n\tjzdma->chn_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(jzdma->chn_base))\n\t\treturn PTR_ERR(jzdma->chn_base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tjzdma->ctrl_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(jzdma->ctrl_base))\n\t\t\treturn PTR_ERR(jzdma->ctrl_base);\n\t} else if (soc_data->flags & JZ_SOC_DATA_ALLOW_LEGACY_DT) {\n\t\t \n\t\tjzdma->ctrl_base = jzdma->chn_base + JZ4780_DMA_CTRL_OFFSET;\n\t} else {\n\t\tdev_err(dev, \"failed to get I/O memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjzdma->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(jzdma->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(jzdma->clk);\n\t\treturn ret;\n\t}\n\n\tclk_prepare_enable(jzdma->clk);\n\n\t \n\tof_property_read_u32_index(dev->of_node, \"ingenic,reserved-channels\",\n\t\t\t\t   0, &jzdma->chan_reserved);\n\n\tdd = &jzdma->dma_device;\n\n\t \n\tdma_set_max_seg_size(dev, 0xffffff);\n\n\tdma_cap_set(DMA_MEMCPY, dd->cap_mask);\n\tdma_cap_set(DMA_SLAVE, dd->cap_mask);\n\tdma_cap_set(DMA_CYCLIC, dd->cap_mask);\n\n\tdd->dev = dev;\n\tdd->copy_align = DMAENGINE_ALIGN_4_BYTES;\n\tdd->device_alloc_chan_resources = jz4780_dma_alloc_chan_resources;\n\tdd->device_free_chan_resources = jz4780_dma_free_chan_resources;\n\tdd->device_prep_slave_sg = jz4780_dma_prep_slave_sg;\n\tdd->device_prep_dma_cyclic = jz4780_dma_prep_dma_cyclic;\n\tdd->device_prep_dma_memcpy = jz4780_dma_prep_dma_memcpy;\n\tdd->device_config = jz4780_dma_config;\n\tdd->device_terminate_all = jz4780_dma_terminate_all;\n\tdd->device_synchronize = jz4780_dma_synchronize;\n\tdd->device_tx_status = jz4780_dma_tx_status;\n\tdd->device_issue_pending = jz4780_dma_issue_pending;\n\tdd->src_addr_widths = JZ_DMA_BUSWIDTHS;\n\tdd->dst_addr_widths = JZ_DMA_BUSWIDTHS;\n\tdd->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tdd->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tdd->max_sg_burst = JZ_DMA_MAX_DESC;\n\n\t \n\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DMAC, JZ_DMA_DMAC_DMAE |\n\t\t\t       JZ_DMA_DMAC_FAIC | JZ_DMA_DMAC_FMSC);\n\n\tif (soc_data->flags & JZ_SOC_DATA_PROGRAMMABLE_DMA)\n\t\tjz4780_dma_ctrl_writel(jzdma, JZ_DMA_REG_DMACP, 0);\n\n\tINIT_LIST_HEAD(&dd->channels);\n\n\tfor (i = 0; i < soc_data->nb_channels; i++) {\n\t\tjzchan = &jzdma->chan[i];\n\t\tjzchan->id = i;\n\n\t\tvchan_init(&jzchan->vchan, dd);\n\t\tjzchan->vchan.desc_free = jz4780_dma_desc_free;\n\t}\n\n\t \n\tjz4780_dma_chan_enable(jzdma, 1);\n\tjz4780_dma_chan_disable(jzdma, 1);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_disable_clk;\n\n\tjzdma->irq = ret;\n\n\tret = request_irq(jzdma->irq, jz4780_dma_irq_handler, 0, dev_name(dev),\n\t\t\t  jzdma);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ %u!\\n\", jzdma->irq);\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = dmaenginem_async_device_register(dd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register device\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tret = of_dma_controller_register(dev->of_node, jz4780_of_dma_xlate,\n\t\t\t\t\t jzdma);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register OF DMA controller\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\tdev_info(dev, \"JZ4780 DMA controller initialised\\n\");\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(jzdma->irq, jzdma);\n\nerr_disable_clk:\n\tclk_disable_unprepare(jzdma->clk);\n\treturn ret;\n}\n\nstatic int jz4780_dma_remove(struct platform_device *pdev)\n{\n\tstruct jz4780_dma_dev *jzdma = platform_get_drvdata(pdev);\n\tint i;\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\n\tclk_disable_unprepare(jzdma->clk);\n\tfree_irq(jzdma->irq, jzdma);\n\n\tfor (i = 0; i < jzdma->soc_data->nb_channels; i++)\n\t\ttasklet_kill(&jzdma->chan[i].vchan.task);\n\n\treturn 0;\n}\n\nstatic const struct jz4780_dma_soc_data jz4740_dma_soc_data = {\n\t.nb_channels = 6,\n\t.transfer_ord_max = 5,\n\t.flags = JZ_SOC_DATA_BREAK_LINKS,\n};\n\nstatic const struct jz4780_dma_soc_data jz4725b_dma_soc_data = {\n\t.nb_channels = 6,\n\t.transfer_ord_max = 5,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM | JZ_SOC_DATA_NO_DCKES_DCKEC |\n\t\t JZ_SOC_DATA_BREAK_LINKS,\n};\n\nstatic const struct jz4780_dma_soc_data jz4755_dma_soc_data = {\n\t.nb_channels = 4,\n\t.transfer_ord_max = 5,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM | JZ_SOC_DATA_NO_DCKES_DCKEC |\n\t\t JZ_SOC_DATA_BREAK_LINKS,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760_dma_soc_data = {\n\t.nb_channels = 5,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM | JZ_SOC_DATA_NO_DCKES_DCKEC,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760_mdma_soc_data = {\n\t.nb_channels = 2,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM | JZ_SOC_DATA_NO_DCKES_DCKEC,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760_bdma_soc_data = {\n\t.nb_channels = 3,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM | JZ_SOC_DATA_NO_DCKES_DCKEC,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760b_dma_soc_data = {\n\t.nb_channels = 5,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760b_mdma_soc_data = {\n\t.nb_channels = 2,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM,\n};\n\nstatic const struct jz4780_dma_soc_data jz4760b_bdma_soc_data = {\n\t.nb_channels = 3,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM,\n};\n\nstatic const struct jz4780_dma_soc_data jz4770_dma_soc_data = {\n\t.nb_channels = 6,\n\t.transfer_ord_max = 6,\n\t.flags = JZ_SOC_DATA_PER_CHAN_PM,\n};\n\nstatic const struct jz4780_dma_soc_data jz4780_dma_soc_data = {\n\t.nb_channels = 32,\n\t.transfer_ord_max = 7,\n\t.flags = JZ_SOC_DATA_ALLOW_LEGACY_DT | JZ_SOC_DATA_PROGRAMMABLE_DMA,\n};\n\nstatic const struct jz4780_dma_soc_data x1000_dma_soc_data = {\n\t.nb_channels = 8,\n\t.transfer_ord_max = 7,\n\t.flags = JZ_SOC_DATA_PROGRAMMABLE_DMA,\n};\n\nstatic const struct jz4780_dma_soc_data x1830_dma_soc_data = {\n\t.nb_channels = 32,\n\t.transfer_ord_max = 7,\n\t.flags = JZ_SOC_DATA_PROGRAMMABLE_DMA,\n};\n\nstatic const struct of_device_id jz4780_dma_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4740-dma\", .data = &jz4740_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4725b-dma\", .data = &jz4725b_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4755-dma\", .data = &jz4755_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4760-dma\", .data = &jz4760_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4760-mdma\", .data = &jz4760_mdma_soc_data },\n\t{ .compatible = \"ingenic,jz4760-bdma\", .data = &jz4760_bdma_soc_data },\n\t{ .compatible = \"ingenic,jz4760b-dma\", .data = &jz4760b_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4760b-mdma\", .data = &jz4760b_mdma_soc_data },\n\t{ .compatible = \"ingenic,jz4760b-bdma\", .data = &jz4760b_bdma_soc_data },\n\t{ .compatible = \"ingenic,jz4770-dma\", .data = &jz4770_dma_soc_data },\n\t{ .compatible = \"ingenic,jz4780-dma\", .data = &jz4780_dma_soc_data },\n\t{ .compatible = \"ingenic,x1000-dma\", .data = &x1000_dma_soc_data },\n\t{ .compatible = \"ingenic,x1830-dma\", .data = &x1830_dma_soc_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4780_dma_dt_match);\n\nstatic struct platform_driver jz4780_dma_driver = {\n\t.probe\t\t= jz4780_dma_probe,\n\t.remove\t\t= jz4780_dma_remove,\n\t.driver\t= {\n\t\t.name\t= \"jz4780-dma\",\n\t\t.of_match_table = jz4780_dma_dt_match,\n\t},\n};\n\nstatic int __init jz4780_dma_init(void)\n{\n\treturn platform_driver_register(&jz4780_dma_driver);\n}\nsubsys_initcall(jz4780_dma_init);\n\nstatic void __exit jz4780_dma_exit(void)\n{\n\tplatform_driver_unregister(&jz4780_dma_driver);\n}\nmodule_exit(jz4780_dma_exit);\n\nMODULE_AUTHOR(\"Alex Smith <alex@alex-smith.me.uk>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4780 DMA controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}