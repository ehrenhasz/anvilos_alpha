{
  "module_name": "dw-hdma-v0-core.c",
  "hash_id": "299aeff5f4ed22eb57b3cceb6f521fd4632158133d7864f67d8a71f857888863",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-edma/dw-hdma-v0-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/irqreturn.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#include \"dw-edma-core.h\"\n#include \"dw-hdma-v0-core.h\"\n#include \"dw-hdma-v0-regs.h\"\n#include \"dw-hdma-v0-debugfs.h\"\n\nenum dw_hdma_control {\n\tDW_HDMA_V0_CB\t\t\t\t\t= BIT(0),\n\tDW_HDMA_V0_TCB\t\t\t\t\t= BIT(1),\n\tDW_HDMA_V0_LLP\t\t\t\t\t= BIT(2),\n\tDW_HDMA_V0_LIE\t\t\t\t\t= BIT(3),\n\tDW_HDMA_V0_RIE\t\t\t\t\t= BIT(4),\n\tDW_HDMA_V0_CCS\t\t\t\t\t= BIT(8),\n\tDW_HDMA_V0_LLE\t\t\t\t\t= BIT(9),\n};\n\nstatic inline struct dw_hdma_v0_regs __iomem *__dw_regs(struct dw_edma *dw)\n{\n\treturn dw->chip->reg_base;\n}\n\nstatic inline struct dw_hdma_v0_ch_regs __iomem *\n__dw_ch_regs(struct dw_edma *dw, enum dw_edma_dir dir, u16 ch)\n{\n\tif (dir == EDMA_DIR_WRITE)\n\t\treturn &(__dw_regs(dw)->ch[ch].wr);\n\telse\n\t\treturn &(__dw_regs(dw)->ch[ch].rd);\n}\n\n#define SET_CH_32(dw, dir, ch, name, value) \\\n\twritel(value, &(__dw_ch_regs(dw, dir, ch)->name))\n\n#define GET_CH_32(dw, dir, ch, name) \\\n\treadl(&(__dw_ch_regs(dw, dir, ch)->name))\n\n#define SET_BOTH_CH_32(dw, ch, name, value) \\\n\tdo {\t\t\t\t\t\\\n\t\twritel(value, &(__dw_ch_regs(dw, EDMA_DIR_WRITE, ch)->name));\t\\\n\t\twritel(value, &(__dw_ch_regs(dw, EDMA_DIR_READ, ch)->name));\t\\\n\t} while (0)\n\n \nstatic void dw_hdma_v0_core_off(struct dw_edma *dw)\n{\n\tint id;\n\n\tfor (id = 0; id < HDMA_V0_MAX_NR_CH; id++) {\n\t\tSET_BOTH_CH_32(dw, id, int_setup,\n\t\t\t       HDMA_V0_STOP_INT_MASK | HDMA_V0_ABORT_INT_MASK);\n\t\tSET_BOTH_CH_32(dw, id, int_clear,\n\t\t\t       HDMA_V0_STOP_INT_MASK | HDMA_V0_ABORT_INT_MASK);\n\t\tSET_BOTH_CH_32(dw, id, ch_en, 0);\n\t}\n}\n\nstatic u16 dw_hdma_v0_core_ch_count(struct dw_edma *dw, enum dw_edma_dir dir)\n{\n\tu32 num_ch = 0;\n\tint id;\n\n\tfor (id = 0; id < HDMA_V0_MAX_NR_CH; id++) {\n\t\tif (GET_CH_32(dw, id, dir, ch_en) & BIT(0))\n\t\t\tnum_ch++;\n\t}\n\n\tif (num_ch > HDMA_V0_MAX_NR_CH)\n\t\tnum_ch = HDMA_V0_MAX_NR_CH;\n\n\treturn (u16)num_ch;\n}\n\nstatic enum dma_status dw_hdma_v0_core_ch_status(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\tu32 tmp;\n\n\ttmp = FIELD_GET(HDMA_V0_CH_STATUS_MASK,\n\t\t\tGET_CH_32(dw, chan->id, chan->dir, ch_stat));\n\n\tif (tmp == 1)\n\t\treturn DMA_IN_PROGRESS;\n\telse if (tmp == 3)\n\t\treturn DMA_COMPLETE;\n\telse\n\t\treturn DMA_ERROR;\n}\n\nstatic void dw_hdma_v0_core_clear_done_int(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\tSET_CH_32(dw, chan->dir, chan->id, int_clear, HDMA_V0_STOP_INT_MASK);\n}\n\nstatic void dw_hdma_v0_core_clear_abort_int(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\tSET_CH_32(dw, chan->dir, chan->id, int_clear, HDMA_V0_ABORT_INT_MASK);\n}\n\nstatic u32 dw_hdma_v0_core_status_int(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\treturn GET_CH_32(dw, chan->dir, chan->id, int_stat);\n}\n\nstatic irqreturn_t\ndw_hdma_v0_core_handle_int(struct dw_edma_irq *dw_irq, enum dw_edma_dir dir,\n\t\t\t   dw_edma_handler_t done, dw_edma_handler_t abort)\n{\n\tstruct dw_edma *dw = dw_irq->dw;\n\tunsigned long total, pos, val;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct dw_edma_chan *chan;\n\tunsigned long off, mask;\n\n\tif (dir == EDMA_DIR_WRITE) {\n\t\ttotal = dw->wr_ch_cnt;\n\t\toff = 0;\n\t\tmask = dw_irq->wr_mask;\n\t} else {\n\t\ttotal = dw->rd_ch_cnt;\n\t\toff = dw->wr_ch_cnt;\n\t\tmask = dw_irq->rd_mask;\n\t}\n\n\tfor_each_set_bit(pos, &mask, total) {\n\t\tchan = &dw->chan[pos + off];\n\n\t\tval = dw_hdma_v0_core_status_int(chan);\n\t\tif (FIELD_GET(HDMA_V0_STOP_INT_MASK, val)) {\n\t\t\tdw_hdma_v0_core_clear_done_int(chan);\n\t\t\tdone(chan);\n\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\n\t\tif (FIELD_GET(HDMA_V0_ABORT_INT_MASK, val)) {\n\t\t\tdw_hdma_v0_core_clear_abort_int(chan);\n\t\t\tabort(chan);\n\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void dw_hdma_v0_write_ll_data(struct dw_edma_chunk *chunk, int i,\n\t\t\t\t     u32 control, u32 size, u64 sar, u64 dar)\n{\n\tptrdiff_t ofs = i * sizeof(struct dw_hdma_v0_lli);\n\n\tif (chunk->chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL) {\n\t\tstruct dw_hdma_v0_lli *lli = chunk->ll_region.vaddr.mem + ofs;\n\n\t\tlli->control = control;\n\t\tlli->transfer_size = size;\n\t\tlli->sar.reg = sar;\n\t\tlli->dar.reg = dar;\n\t} else {\n\t\tstruct dw_hdma_v0_lli __iomem *lli = chunk->ll_region.vaddr.io + ofs;\n\n\t\twritel(control, &lli->control);\n\t\twritel(size, &lli->transfer_size);\n\t\twriteq(sar, &lli->sar.reg);\n\t\twriteq(dar, &lli->dar.reg);\n\t}\n}\n\nstatic void dw_hdma_v0_write_ll_link(struct dw_edma_chunk *chunk,\n\t\t\t\t     int i, u32 control, u64 pointer)\n{\n\tptrdiff_t ofs = i * sizeof(struct dw_hdma_v0_lli);\n\n\tif (chunk->chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL) {\n\t\tstruct dw_hdma_v0_llp *llp = chunk->ll_region.vaddr.mem + ofs;\n\n\t\tllp->control = control;\n\t\tllp->llp.reg = pointer;\n\t} else {\n\t\tstruct dw_hdma_v0_llp __iomem *llp = chunk->ll_region.vaddr.io + ofs;\n\n\t\twritel(control, &llp->control);\n\t\twriteq(pointer, &llp->llp.reg);\n\t}\n}\n\nstatic void dw_hdma_v0_core_write_chunk(struct dw_edma_chunk *chunk)\n{\n\tstruct dw_edma_burst *child;\n\tstruct dw_edma_chan *chan = chunk->chan;\n\tu32 control = 0, i = 0;\n\tint j;\n\n\tif (chunk->cb)\n\t\tcontrol = DW_HDMA_V0_CB;\n\n\tj = chunk->bursts_alloc;\n\tlist_for_each_entry(child, &chunk->burst->list, list) {\n\t\tj--;\n\t\tif (!j) {\n\t\t\tcontrol |= DW_HDMA_V0_LIE;\n\t\t\tif (!(chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL))\n\t\t\t\tcontrol |= DW_HDMA_V0_RIE;\n\t\t}\n\n\t\tdw_hdma_v0_write_ll_data(chunk, i++, control, child->sz,\n\t\t\t\t\t child->sar, child->dar);\n\t}\n\n\tcontrol = DW_HDMA_V0_LLP | DW_HDMA_V0_TCB;\n\tif (!chunk->cb)\n\t\tcontrol |= DW_HDMA_V0_CB;\n\n\tdw_hdma_v0_write_ll_link(chunk, i, control, chunk->ll_region.paddr);\n}\n\nstatic void dw_hdma_v0_core_start(struct dw_edma_chunk *chunk, bool first)\n{\n\tstruct dw_edma_chan *chan = chunk->chan;\n\tstruct dw_edma *dw = chan->dw;\n\tu32 tmp;\n\n\tdw_hdma_v0_core_write_chunk(chunk);\n\n\tif (first) {\n\t\t \n\t\tSET_CH_32(dw, chan->dir, chan->id, ch_en, BIT(0));\n\t\t \n\t\ttmp = GET_CH_32(dw, chan->dir, chan->id, int_setup) |\n\t\t      HDMA_V0_STOP_INT_MASK | HDMA_V0_ABORT_INT_MASK |\n\t\t      HDMA_V0_LOCAL_STOP_INT_EN | HDMA_V0_LOCAL_STOP_INT_EN;\n\t\tSET_CH_32(dw, chan->dir, chan->id, int_setup, tmp);\n\t\t \n\t\tSET_CH_32(dw, chan->dir, chan->id, control1, HDMA_V0_LINKLIST_EN);\n\t\t \n\t\t \n\t\tSET_CH_32(dw, chan->dir, chan->id, llp.lsb,\n\t\t\t  lower_32_bits(chunk->ll_region.paddr));\n\t\tSET_CH_32(dw, chan->dir, chan->id, llp.msb,\n\t\t\t  upper_32_bits(chunk->ll_region.paddr));\n\t}\n\t \n\tSET_CH_32(dw, chan->dir, chan->id, cycle_sync,\n\t\t  HDMA_V0_CONSUMER_CYCLE_STAT | HDMA_V0_CONSUMER_CYCLE_BIT);\n\t \n\tSET_CH_32(dw, chan->dir, chan->id, doorbell, HDMA_V0_DOORBELL_START);\n}\n\nstatic void dw_hdma_v0_core_ch_config(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\t \n\tSET_CH_32(dw, chan->dir, chan->id, msi_stop.lsb, chan->msi.address_lo);\n\tSET_CH_32(dw, chan->dir, chan->id, msi_stop.msb, chan->msi.address_hi);\n\t \n\tSET_CH_32(dw, chan->dir, chan->id, msi_abort.lsb, chan->msi.address_lo);\n\tSET_CH_32(dw, chan->dir, chan->id, msi_abort.msb, chan->msi.address_hi);\n\t \n\tSET_CH_32(dw, chan->dir, chan->id, msi_msgdata, chan->msi.data);\n}\n\n \nstatic void dw_hdma_v0_core_debugfs_on(struct dw_edma *dw)\n{\n\tdw_hdma_v0_debugfs_on(dw);\n}\n\nstatic const struct dw_edma_core_ops dw_hdma_v0_core = {\n\t.off = dw_hdma_v0_core_off,\n\t.ch_count = dw_hdma_v0_core_ch_count,\n\t.ch_status = dw_hdma_v0_core_ch_status,\n\t.handle_int = dw_hdma_v0_core_handle_int,\n\t.start = dw_hdma_v0_core_start,\n\t.ch_config = dw_hdma_v0_core_ch_config,\n\t.debugfs_on = dw_hdma_v0_core_debugfs_on,\n};\n\nvoid dw_hdma_v0_core_register(struct dw_edma *dw)\n{\n\tdw->core = &dw_hdma_v0_core;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}