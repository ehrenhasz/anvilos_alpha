{
  "module_name": "dw-edma-v0-core.c",
  "hash_id": "e6cc92477ba78db1e7b7da13011e549e1846f75b5c929a4a2b047839e99d7b90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-edma/dw-edma-v0-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/irqreturn.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#include \"dw-edma-core.h\"\n#include \"dw-edma-v0-core.h\"\n#include \"dw-edma-v0-regs.h\"\n#include \"dw-edma-v0-debugfs.h\"\n\nenum dw_edma_control {\n\tDW_EDMA_V0_CB\t\t\t\t\t= BIT(0),\n\tDW_EDMA_V0_TCB\t\t\t\t\t= BIT(1),\n\tDW_EDMA_V0_LLP\t\t\t\t\t= BIT(2),\n\tDW_EDMA_V0_LIE\t\t\t\t\t= BIT(3),\n\tDW_EDMA_V0_RIE\t\t\t\t\t= BIT(4),\n\tDW_EDMA_V0_CCS\t\t\t\t\t= BIT(8),\n\tDW_EDMA_V0_LLE\t\t\t\t\t= BIT(9),\n};\n\nstatic inline struct dw_edma_v0_regs __iomem *__dw_regs(struct dw_edma *dw)\n{\n\treturn dw->chip->reg_base;\n}\n\n#define SET_32(dw, name, value)\t\t\t\t\\\n\twritel(value, &(__dw_regs(dw)->name))\n\n#define GET_32(dw, name)\t\t\t\t\\\n\treadl(&(__dw_regs(dw)->name))\n\n#define SET_RW_32(dw, dir, name, value)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((dir) == EDMA_DIR_WRITE)\t\t\\\n\t\t\tSET_32(dw, wr_##name, value);\t\\\n\t\telse\t\t\t\t\t\\\n\t\t\tSET_32(dw, rd_##name, value);\t\\\n\t} while (0)\n\n#define GET_RW_32(dw, dir, name)\t\t\t\\\n\t((dir) == EDMA_DIR_WRITE\t\t\t\\\n\t  ? GET_32(dw, wr_##name)\t\t\t\\\n\t  : GET_32(dw, rd_##name))\n\n#define SET_BOTH_32(dw, name, value)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tSET_32(dw, wr_##name, value);\t\t\\\n\t\tSET_32(dw, rd_##name, value);\t\t\\\n\t} while (0)\n\n#define SET_64(dw, name, value)\t\t\t\t\\\n\twriteq(value, &(__dw_regs(dw)->name))\n\n#define GET_64(dw, name)\t\t\t\t\\\n\treadq(&(__dw_regs(dw)->name))\n\n#define SET_RW_64(dw, dir, name, value)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((dir) == EDMA_DIR_WRITE)\t\t\\\n\t\t\tSET_64(dw, wr_##name, value);\t\\\n\t\telse\t\t\t\t\t\\\n\t\t\tSET_64(dw, rd_##name, value);\t\\\n\t} while (0)\n\n#define GET_RW_64(dw, dir, name)\t\t\t\\\n\t((dir) == EDMA_DIR_WRITE\t\t\t\\\n\t  ? GET_64(dw, wr_##name)\t\t\t\\\n\t  : GET_64(dw, rd_##name))\n\n#define SET_BOTH_64(dw, name, value)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tSET_64(dw, wr_##name, value);\t\t\\\n\t\tSET_64(dw, rd_##name, value);\t\t\\\n\t} while (0)\n\n#define SET_COMPAT(dw, name, value)\t\t\t\\\n\twritel(value, &(__dw_regs(dw)->type.unroll.name))\n\n#define SET_RW_COMPAT(dw, dir, name, value)\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif ((dir) == EDMA_DIR_WRITE)\t\t\\\n\t\t\tSET_COMPAT(dw, wr_##name, value); \\\n\t\telse\t\t\t\t\t\\\n\t\t\tSET_COMPAT(dw, rd_##name, value); \\\n\t} while (0)\n\nstatic inline struct dw_edma_v0_ch_regs __iomem *\n__dw_ch_regs(struct dw_edma *dw, enum dw_edma_dir dir, u16 ch)\n{\n\tif (dw->chip->mf == EDMA_MF_EDMA_LEGACY)\n\t\treturn &(__dw_regs(dw)->type.legacy.ch);\n\n\tif (dir == EDMA_DIR_WRITE)\n\t\treturn &__dw_regs(dw)->type.unroll.ch[ch].wr;\n\n\treturn &__dw_regs(dw)->type.unroll.ch[ch].rd;\n}\n\nstatic inline void writel_ch(struct dw_edma *dw, enum dw_edma_dir dir, u16 ch,\n\t\t\t     u32 value, void __iomem *addr)\n{\n\tif (dw->chip->mf == EDMA_MF_EDMA_LEGACY) {\n\t\tu32 viewport_sel;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&dw->lock, flags);\n\n\t\tviewport_sel = FIELD_PREP(EDMA_V0_VIEWPORT_MASK, ch);\n\t\tif (dir == EDMA_DIR_READ)\n\t\t\tviewport_sel |= BIT(31);\n\n\t\twritel(viewport_sel,\n\t\t       &(__dw_regs(dw)->type.legacy.viewport_sel));\n\t\twritel(value, addr);\n\n\t\traw_spin_unlock_irqrestore(&dw->lock, flags);\n\t} else {\n\t\twritel(value, addr);\n\t}\n}\n\nstatic inline u32 readl_ch(struct dw_edma *dw, enum dw_edma_dir dir, u16 ch,\n\t\t\t   const void __iomem *addr)\n{\n\tu32 value;\n\n\tif (dw->chip->mf == EDMA_MF_EDMA_LEGACY) {\n\t\tu32 viewport_sel;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&dw->lock, flags);\n\n\t\tviewport_sel = FIELD_PREP(EDMA_V0_VIEWPORT_MASK, ch);\n\t\tif (dir == EDMA_DIR_READ)\n\t\t\tviewport_sel |= BIT(31);\n\n\t\twritel(viewport_sel,\n\t\t       &(__dw_regs(dw)->type.legacy.viewport_sel));\n\t\tvalue = readl(addr);\n\n\t\traw_spin_unlock_irqrestore(&dw->lock, flags);\n\t} else {\n\t\tvalue = readl(addr);\n\t}\n\n\treturn value;\n}\n\n#define SET_CH_32(dw, dir, ch, name, value) \\\n\twritel_ch(dw, dir, ch, value, &(__dw_ch_regs(dw, dir, ch)->name))\n\n#define GET_CH_32(dw, dir, ch, name) \\\n\treadl_ch(dw, dir, ch, &(__dw_ch_regs(dw, dir, ch)->name))\n\n \nstatic void dw_edma_v0_core_off(struct dw_edma *dw)\n{\n\tSET_BOTH_32(dw, int_mask,\n\t\t    EDMA_V0_DONE_INT_MASK | EDMA_V0_ABORT_INT_MASK);\n\tSET_BOTH_32(dw, int_clear,\n\t\t    EDMA_V0_DONE_INT_MASK | EDMA_V0_ABORT_INT_MASK);\n\tSET_BOTH_32(dw, engine_en, 0);\n}\n\nstatic u16 dw_edma_v0_core_ch_count(struct dw_edma *dw, enum dw_edma_dir dir)\n{\n\tu32 num_ch;\n\n\tif (dir == EDMA_DIR_WRITE)\n\t\tnum_ch = FIELD_GET(EDMA_V0_WRITE_CH_COUNT_MASK,\n\t\t\t\t   GET_32(dw, ctrl));\n\telse\n\t\tnum_ch = FIELD_GET(EDMA_V0_READ_CH_COUNT_MASK,\n\t\t\t\t   GET_32(dw, ctrl));\n\n\tif (num_ch > EDMA_V0_MAX_NR_CH)\n\t\tnum_ch = EDMA_V0_MAX_NR_CH;\n\n\treturn (u16)num_ch;\n}\n\nstatic enum dma_status dw_edma_v0_core_ch_status(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\tu32 tmp;\n\n\ttmp = FIELD_GET(EDMA_V0_CH_STATUS_MASK,\n\t\t\tGET_CH_32(dw, chan->dir, chan->id, ch_control1));\n\n\tif (tmp == 1)\n\t\treturn DMA_IN_PROGRESS;\n\telse if (tmp == 3)\n\t\treturn DMA_COMPLETE;\n\telse\n\t\treturn DMA_ERROR;\n}\n\nstatic void dw_edma_v0_core_clear_done_int(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\tSET_RW_32(dw, chan->dir, int_clear,\n\t\t  FIELD_PREP(EDMA_V0_DONE_INT_MASK, BIT(chan->id)));\n}\n\nstatic void dw_edma_v0_core_clear_abort_int(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\n\tSET_RW_32(dw, chan->dir, int_clear,\n\t\t  FIELD_PREP(EDMA_V0_ABORT_INT_MASK, BIT(chan->id)));\n}\n\nstatic u32 dw_edma_v0_core_status_done_int(struct dw_edma *dw, enum dw_edma_dir dir)\n{\n\treturn FIELD_GET(EDMA_V0_DONE_INT_MASK,\n\t\t\t GET_RW_32(dw, dir, int_status));\n}\n\nstatic u32 dw_edma_v0_core_status_abort_int(struct dw_edma *dw, enum dw_edma_dir dir)\n{\n\treturn FIELD_GET(EDMA_V0_ABORT_INT_MASK,\n\t\t\t GET_RW_32(dw, dir, int_status));\n}\n\nstatic irqreturn_t\ndw_edma_v0_core_handle_int(struct dw_edma_irq *dw_irq, enum dw_edma_dir dir,\n\t\t\t   dw_edma_handler_t done, dw_edma_handler_t abort)\n{\n\tstruct dw_edma *dw = dw_irq->dw;\n\tunsigned long total, pos, val;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct dw_edma_chan *chan;\n\tunsigned long off;\n\tu32 mask;\n\n\tif (dir == EDMA_DIR_WRITE) {\n\t\ttotal = dw->wr_ch_cnt;\n\t\toff = 0;\n\t\tmask = dw_irq->wr_mask;\n\t} else {\n\t\ttotal = dw->rd_ch_cnt;\n\t\toff = dw->wr_ch_cnt;\n\t\tmask = dw_irq->rd_mask;\n\t}\n\n\tval = dw_edma_v0_core_status_done_int(dw, dir);\n\tval &= mask;\n\tfor_each_set_bit(pos, &val, total) {\n\t\tchan = &dw->chan[pos + off];\n\n\t\tdw_edma_v0_core_clear_done_int(chan);\n\t\tdone(chan);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tval = dw_edma_v0_core_status_abort_int(dw, dir);\n\tval &= mask;\n\tfor_each_set_bit(pos, &val, total) {\n\t\tchan = &dw->chan[pos + off];\n\n\t\tdw_edma_v0_core_clear_abort_int(chan);\n\t\tabort(chan);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic void dw_edma_v0_write_ll_data(struct dw_edma_chunk *chunk, int i,\n\t\t\t\t     u32 control, u32 size, u64 sar, u64 dar)\n{\n\tptrdiff_t ofs = i * sizeof(struct dw_edma_v0_lli);\n\n\tif (chunk->chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL) {\n\t\tstruct dw_edma_v0_lli *lli = chunk->ll_region.vaddr.mem + ofs;\n\n\t\tlli->control = control;\n\t\tlli->transfer_size = size;\n\t\tlli->sar.reg = sar;\n\t\tlli->dar.reg = dar;\n\t} else {\n\t\tstruct dw_edma_v0_lli __iomem *lli = chunk->ll_region.vaddr.io + ofs;\n\n\t\twritel(control, &lli->control);\n\t\twritel(size, &lli->transfer_size);\n\t\twriteq(sar, &lli->sar.reg);\n\t\twriteq(dar, &lli->dar.reg);\n\t}\n}\n\nstatic void dw_edma_v0_write_ll_link(struct dw_edma_chunk *chunk,\n\t\t\t\t     int i, u32 control, u64 pointer)\n{\n\tptrdiff_t ofs = i * sizeof(struct dw_edma_v0_lli);\n\n\tif (chunk->chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL) {\n\t\tstruct dw_edma_v0_llp *llp = chunk->ll_region.vaddr.mem + ofs;\n\n\t\tllp->control = control;\n\t\tllp->llp.reg = pointer;\n\t} else {\n\t\tstruct dw_edma_v0_llp __iomem *llp = chunk->ll_region.vaddr.io + ofs;\n\n\t\twritel(control, &llp->control);\n\t\twriteq(pointer, &llp->llp.reg);\n\t}\n}\n\nstatic void dw_edma_v0_core_write_chunk(struct dw_edma_chunk *chunk)\n{\n\tstruct dw_edma_burst *child;\n\tstruct dw_edma_chan *chan = chunk->chan;\n\tu32 control = 0, i = 0;\n\tint j;\n\n\tif (chunk->cb)\n\t\tcontrol = DW_EDMA_V0_CB;\n\n\tj = chunk->bursts_alloc;\n\tlist_for_each_entry(child, &chunk->burst->list, list) {\n\t\tj--;\n\t\tif (!j) {\n\t\t\tcontrol |= DW_EDMA_V0_LIE;\n\t\t\tif (!(chan->dw->chip->flags & DW_EDMA_CHIP_LOCAL))\n\t\t\t\tcontrol |= DW_EDMA_V0_RIE;\n\t\t}\n\n\t\tdw_edma_v0_write_ll_data(chunk, i++, control, child->sz,\n\t\t\t\t\t child->sar, child->dar);\n\t}\n\n\tcontrol = DW_EDMA_V0_LLP | DW_EDMA_V0_TCB;\n\tif (!chunk->cb)\n\t\tcontrol |= DW_EDMA_V0_CB;\n\n\tdw_edma_v0_write_ll_link(chunk, i, control, chunk->ll_region.paddr);\n}\n\nstatic void dw_edma_v0_core_start(struct dw_edma_chunk *chunk, bool first)\n{\n\tstruct dw_edma_chan *chan = chunk->chan;\n\tstruct dw_edma *dw = chan->dw;\n\tu32 tmp;\n\n\tdw_edma_v0_core_write_chunk(chunk);\n\n\tif (first) {\n\t\t \n\t\tSET_RW_32(dw, chan->dir, engine_en, BIT(0));\n\t\tif (dw->chip->mf == EDMA_MF_HDMA_COMPAT) {\n\t\t\tswitch (chan->id) {\n\t\t\tcase 0:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch0_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch1_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch2_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch3_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch4_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch5_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch6_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tSET_RW_COMPAT(dw, chan->dir, ch7_pwr_en,\n\t\t\t\t\t      BIT(0));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\ttmp = GET_RW_32(dw, chan->dir, int_mask);\n\t\ttmp &= ~FIELD_PREP(EDMA_V0_DONE_INT_MASK, BIT(chan->id));\n\t\ttmp &= ~FIELD_PREP(EDMA_V0_ABORT_INT_MASK, BIT(chan->id));\n\t\tSET_RW_32(dw, chan->dir, int_mask, tmp);\n\t\t \n\t\ttmp = GET_RW_32(dw, chan->dir, linked_list_err_en);\n\t\ttmp |= FIELD_PREP(EDMA_V0_LINKED_LIST_ERR_MASK, BIT(chan->id));\n\t\tSET_RW_32(dw, chan->dir, linked_list_err_en, tmp);\n\t\t \n\t\tSET_CH_32(dw, chan->dir, chan->id, ch_control1,\n\t\t\t  (DW_EDMA_V0_CCS | DW_EDMA_V0_LLE));\n\t\t \n\t\t \n\t\tSET_CH_32(dw, chan->dir, chan->id, llp.lsb,\n\t\t\t  lower_32_bits(chunk->ll_region.paddr));\n\t\tSET_CH_32(dw, chan->dir, chan->id, llp.msb,\n\t\t\t  upper_32_bits(chunk->ll_region.paddr));\n\t}\n\t \n\tSET_RW_32(dw, chan->dir, doorbell,\n\t\t  FIELD_PREP(EDMA_V0_DOORBELL_CH_MASK, chan->id));\n}\n\nstatic void dw_edma_v0_core_ch_config(struct dw_edma_chan *chan)\n{\n\tstruct dw_edma *dw = chan->dw;\n\tu32 tmp = 0;\n\n\t \n\tSET_RW_32(dw, chan->dir, done_imwr.lsb, chan->msi.address_lo);\n\tSET_RW_32(dw, chan->dir, done_imwr.msb, chan->msi.address_hi);\n\t \n\tSET_RW_32(dw, chan->dir, abort_imwr.lsb, chan->msi.address_lo);\n\tSET_RW_32(dw, chan->dir, abort_imwr.msb, chan->msi.address_hi);\n\t \n\tswitch (chan->id) {\n\tcase 0:\n\tcase 1:\n\t\ttmp = GET_RW_32(dw, chan->dir, ch01_imwr_data);\n\t\tbreak;\n\n\tcase 2:\n\tcase 3:\n\t\ttmp = GET_RW_32(dw, chan->dir, ch23_imwr_data);\n\t\tbreak;\n\n\tcase 4:\n\tcase 5:\n\t\ttmp = GET_RW_32(dw, chan->dir, ch45_imwr_data);\n\t\tbreak;\n\n\tcase 6:\n\tcase 7:\n\t\ttmp = GET_RW_32(dw, chan->dir, ch67_imwr_data);\n\t\tbreak;\n\t}\n\n\tif (chan->id & BIT(0)) {\n\t\t \n\t\ttmp &= EDMA_V0_CH_EVEN_MSI_DATA_MASK;\n\t\ttmp |= FIELD_PREP(EDMA_V0_CH_ODD_MSI_DATA_MASK,\n\t\t\t\t  chan->msi.data);\n\t} else {\n\t\t \n\t\ttmp &= EDMA_V0_CH_ODD_MSI_DATA_MASK;\n\t\ttmp |= FIELD_PREP(EDMA_V0_CH_EVEN_MSI_DATA_MASK,\n\t\t\t\t  chan->msi.data);\n\t}\n\n\tswitch (chan->id) {\n\tcase 0:\n\tcase 1:\n\t\tSET_RW_32(dw, chan->dir, ch01_imwr_data, tmp);\n\t\tbreak;\n\n\tcase 2:\n\tcase 3:\n\t\tSET_RW_32(dw, chan->dir, ch23_imwr_data, tmp);\n\t\tbreak;\n\n\tcase 4:\n\tcase 5:\n\t\tSET_RW_32(dw, chan->dir, ch45_imwr_data, tmp);\n\t\tbreak;\n\n\tcase 6:\n\tcase 7:\n\t\tSET_RW_32(dw, chan->dir, ch67_imwr_data, tmp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void dw_edma_v0_core_debugfs_on(struct dw_edma *dw)\n{\n\tdw_edma_v0_debugfs_on(dw);\n}\n\nstatic const struct dw_edma_core_ops dw_edma_v0_core = {\n\t.off = dw_edma_v0_core_off,\n\t.ch_count = dw_edma_v0_core_ch_count,\n\t.ch_status = dw_edma_v0_core_ch_status,\n\t.handle_int = dw_edma_v0_core_handle_int,\n\t.start = dw_edma_v0_core_start,\n\t.ch_config = dw_edma_v0_core_ch_config,\n\t.debugfs_on = dw_edma_v0_core_debugfs_on,\n};\n\nvoid dw_edma_v0_core_register(struct dw_edma *dw)\n{\n\tdw->core = &dw_edma_v0_core;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}