{
  "module_name": "dw-edma-v0-debugfs.c",
  "hash_id": "cfc8f779c7506ec1ff17417104fedd12f2630b786f67aa97f65b548e2020876f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-edma/dw-edma-v0-debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/bitfield.h>\n\n#include \"dw-edma-v0-debugfs.h\"\n#include \"dw-edma-v0-regs.h\"\n#include \"dw-edma-core.h\"\n\n#define REGS_ADDR(dw, name)\t\t\t\t\t\t       \\\n\t({\t\t\t\t\t\t\t\t       \\\n\t\tstruct dw_edma_v0_regs __iomem *__regs = (dw)->chip->reg_base; \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\t(void __iomem *)&__regs->name;\t\t\t\t       \\\n\t})\n\n#define REGS_CH_ADDR(dw, name, _dir, _ch)\t\t\t\t       \\\n\t({\t\t\t\t\t\t\t\t       \\\n\t\tstruct dw_edma_v0_ch_regs __iomem *__ch_regs;\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tif ((dw)->chip->mf == EDMA_MF_EDMA_LEGACY)\t\t       \\\n\t\t\t__ch_regs = REGS_ADDR(dw, type.legacy.ch);\t       \\\n\t\telse if (_dir == EDMA_DIR_READ)\t\t\t\t       \\\n\t\t\t__ch_regs = REGS_ADDR(dw, type.unroll.ch[_ch].rd);     \\\n\t\telse\t\t\t\t\t\t\t       \\\n\t\t\t__ch_regs = REGS_ADDR(dw, type.unroll.ch[_ch].wr);     \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\t(void __iomem *)&__ch_regs->name;\t\t\t       \\\n\t})\n\n#define REGISTER(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, name) }\n\n#define CTX_REGISTER(dw, name, dir, ch) \\\n\t{ dw, #name, REGS_CH_ADDR(dw, name, dir, ch), dir, ch }\n\n#define WR_REGISTER(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, wr_##name) }\n#define RD_REGISTER(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, rd_##name) }\n\n#define WR_REGISTER_LEGACY(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, type.legacy.wr_##name) }\n#define RD_REGISTER_LEGACY(name) \\\n\t{ dw, #name, REGS_ADDR(dw, type.legacy.rd_##name) }\n\n#define WR_REGISTER_UNROLL(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, type.unroll.wr_##name) }\n#define RD_REGISTER_UNROLL(dw, name) \\\n\t{ dw, #name, REGS_ADDR(dw, type.unroll.rd_##name) }\n\n#define WRITE_STR\t\t\t\t\"write\"\n#define READ_STR\t\t\t\t\"read\"\n#define CHANNEL_STR\t\t\t\t\"channel\"\n#define REGISTERS_STR\t\t\t\t\"registers\"\n\nstruct dw_edma_debugfs_entry {\n\tstruct dw_edma\t\t\t\t*dw;\n\tconst char\t\t\t\t*name;\n\tvoid __iomem\t\t\t\t*reg;\n\tenum dw_edma_dir\t\t\tdir;\n\tu16\t\t\t\t\tch;\n};\n\nstatic int dw_edma_debugfs_u32_get(void *data, u64 *val)\n{\n\tstruct dw_edma_debugfs_entry *entry = data;\n\tstruct dw_edma *dw = entry->dw;\n\tvoid __iomem *reg = entry->reg;\n\n\tif (dw->chip->mf == EDMA_MF_EDMA_LEGACY &&\n\t    reg >= REGS_ADDR(dw, type.legacy.ch)) {\n\t\tunsigned long flags;\n\t\tu32 viewport_sel;\n\n\t\tviewport_sel = entry->dir == EDMA_DIR_READ ? BIT(31) : 0;\n\t\tviewport_sel |= FIELD_PREP(EDMA_V0_VIEWPORT_MASK, entry->ch);\n\n\t\traw_spin_lock_irqsave(&dw->lock, flags);\n\n\t\twritel(viewport_sel, REGS_ADDR(dw, type.legacy.viewport_sel));\n\t\t*val = readl(reg);\n\n\t\traw_spin_unlock_irqrestore(&dw->lock, flags);\n\t} else {\n\t\t*val = readl(reg);\n\t}\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32, dw_edma_debugfs_u32_get, NULL, \"0x%08llx\\n\");\n\nstatic void dw_edma_debugfs_create_x32(struct dw_edma *dw,\n\t\t\t\t       const struct dw_edma_debugfs_entry ini[],\n\t\t\t\t       int nr_entries, struct dentry *dent)\n{\n\tstruct dw_edma_debugfs_entry *entries;\n\tint i;\n\n\tentries = devm_kcalloc(dw->chip->dev, nr_entries, sizeof(*entries),\n\t\t\t       GFP_KERNEL);\n\tif (!entries)\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\tentries[i] = ini[i];\n\n\t\tdebugfs_create_file_unsafe(entries[i].name, 0444, dent,\n\t\t\t\t\t   &entries[i], &fops_x32);\n\t}\n}\n\nstatic void dw_edma_debugfs_regs_ch(struct dw_edma *dw, enum dw_edma_dir dir,\n\t\t\t\t    u16 ch, struct dentry *dent)\n{\n\tstruct dw_edma_debugfs_entry debugfs_regs[] = {\n\t\tCTX_REGISTER(dw, ch_control1, dir, ch),\n\t\tCTX_REGISTER(dw, ch_control2, dir, ch),\n\t\tCTX_REGISTER(dw, transfer_size, dir, ch),\n\t\tCTX_REGISTER(dw, sar.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, sar.msb, dir, ch),\n\t\tCTX_REGISTER(dw, dar.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, dar.msb, dir, ch),\n\t\tCTX_REGISTER(dw, llp.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, llp.msb, dir, ch),\n\t};\n\tint nr_entries;\n\n\tnr_entries = ARRAY_SIZE(debugfs_regs);\n\tdw_edma_debugfs_create_x32(dw, debugfs_regs, nr_entries, dent);\n}\n\nstatic noinline_for_stack void\ndw_edma_debugfs_regs_wr(struct dw_edma *dw, struct dentry *dent)\n{\n\tconst struct dw_edma_debugfs_entry debugfs_regs[] = {\n\t\t \n\t\tWR_REGISTER(dw, engine_en),\n\t\tWR_REGISTER(dw, doorbell),\n\t\tWR_REGISTER(dw, ch_arb_weight.lsb),\n\t\tWR_REGISTER(dw, ch_arb_weight.msb),\n\t\t \n\t\tWR_REGISTER(dw, int_status),\n\t\tWR_REGISTER(dw, int_mask),\n\t\tWR_REGISTER(dw, int_clear),\n\t\tWR_REGISTER(dw, err_status),\n\t\tWR_REGISTER(dw, done_imwr.lsb),\n\t\tWR_REGISTER(dw, done_imwr.msb),\n\t\tWR_REGISTER(dw, abort_imwr.lsb),\n\t\tWR_REGISTER(dw, abort_imwr.msb),\n\t\tWR_REGISTER(dw, ch01_imwr_data),\n\t\tWR_REGISTER(dw, ch23_imwr_data),\n\t\tWR_REGISTER(dw, ch45_imwr_data),\n\t\tWR_REGISTER(dw, ch67_imwr_data),\n\t\tWR_REGISTER(dw, linked_list_err_en),\n\t};\n\tconst struct dw_edma_debugfs_entry debugfs_unroll_regs[] = {\n\t\t \n\t\tWR_REGISTER_UNROLL(dw, engine_chgroup),\n\t\tWR_REGISTER_UNROLL(dw, engine_hshake_cnt.lsb),\n\t\tWR_REGISTER_UNROLL(dw, engine_hshake_cnt.msb),\n\t\tWR_REGISTER_UNROLL(dw, ch0_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch1_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch2_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch3_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch4_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch5_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch6_pwr_en),\n\t\tWR_REGISTER_UNROLL(dw, ch7_pwr_en),\n\t};\n\tstruct dentry *regs_dent, *ch_dent;\n\tint nr_entries, i;\n\tchar name[16];\n\n\tregs_dent = debugfs_create_dir(WRITE_STR, dent);\n\n\tnr_entries = ARRAY_SIZE(debugfs_regs);\n\tdw_edma_debugfs_create_x32(dw, debugfs_regs, nr_entries, regs_dent);\n\n\tif (dw->chip->mf == EDMA_MF_HDMA_COMPAT) {\n\t\tnr_entries = ARRAY_SIZE(debugfs_unroll_regs);\n\t\tdw_edma_debugfs_create_x32(dw, debugfs_unroll_regs, nr_entries,\n\t\t\t\t\t   regs_dent);\n\t}\n\n\tfor (i = 0; i < dw->wr_ch_cnt; i++) {\n\t\tsnprintf(name, sizeof(name), \"%s:%d\", CHANNEL_STR, i);\n\n\t\tch_dent = debugfs_create_dir(name, regs_dent);\n\n\t\tdw_edma_debugfs_regs_ch(dw, EDMA_DIR_WRITE, i, ch_dent);\n\t}\n}\n\nstatic noinline_for_stack void dw_edma_debugfs_regs_rd(struct dw_edma *dw,\n\t\t\t\t\t\t       struct dentry *dent)\n{\n\tconst struct dw_edma_debugfs_entry debugfs_regs[] = {\n\t\t \n\t\tRD_REGISTER(dw, engine_en),\n\t\tRD_REGISTER(dw, doorbell),\n\t\tRD_REGISTER(dw, ch_arb_weight.lsb),\n\t\tRD_REGISTER(dw, ch_arb_weight.msb),\n\t\t \n\t\tRD_REGISTER(dw, int_status),\n\t\tRD_REGISTER(dw, int_mask),\n\t\tRD_REGISTER(dw, int_clear),\n\t\tRD_REGISTER(dw, err_status.lsb),\n\t\tRD_REGISTER(dw, err_status.msb),\n\t\tRD_REGISTER(dw, linked_list_err_en),\n\t\tRD_REGISTER(dw, done_imwr.lsb),\n\t\tRD_REGISTER(dw, done_imwr.msb),\n\t\tRD_REGISTER(dw, abort_imwr.lsb),\n\t\tRD_REGISTER(dw, abort_imwr.msb),\n\t\tRD_REGISTER(dw, ch01_imwr_data),\n\t\tRD_REGISTER(dw, ch23_imwr_data),\n\t\tRD_REGISTER(dw, ch45_imwr_data),\n\t\tRD_REGISTER(dw, ch67_imwr_data),\n\t};\n\tconst struct dw_edma_debugfs_entry debugfs_unroll_regs[] = {\n\t\t \n\t\tRD_REGISTER_UNROLL(dw, engine_chgroup),\n\t\tRD_REGISTER_UNROLL(dw, engine_hshake_cnt.lsb),\n\t\tRD_REGISTER_UNROLL(dw, engine_hshake_cnt.msb),\n\t\tRD_REGISTER_UNROLL(dw, ch0_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch1_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch2_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch3_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch4_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch5_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch6_pwr_en),\n\t\tRD_REGISTER_UNROLL(dw, ch7_pwr_en),\n\t};\n\tstruct dentry *regs_dent, *ch_dent;\n\tint nr_entries, i;\n\tchar name[16];\n\n\tregs_dent = debugfs_create_dir(READ_STR, dent);\n\n\tnr_entries = ARRAY_SIZE(debugfs_regs);\n\tdw_edma_debugfs_create_x32(dw, debugfs_regs, nr_entries, regs_dent);\n\n\tif (dw->chip->mf == EDMA_MF_HDMA_COMPAT) {\n\t\tnr_entries = ARRAY_SIZE(debugfs_unroll_regs);\n\t\tdw_edma_debugfs_create_x32(dw, debugfs_unroll_regs, nr_entries,\n\t\t\t\t\t   regs_dent);\n\t}\n\n\tfor (i = 0; i < dw->rd_ch_cnt; i++) {\n\t\tsnprintf(name, sizeof(name), \"%s:%d\", CHANNEL_STR, i);\n\n\t\tch_dent = debugfs_create_dir(name, regs_dent);\n\n\t\tdw_edma_debugfs_regs_ch(dw, EDMA_DIR_READ, i, ch_dent);\n\t}\n}\n\nstatic void dw_edma_debugfs_regs(struct dw_edma *dw)\n{\n\tconst struct dw_edma_debugfs_entry debugfs_regs[] = {\n\t\tREGISTER(dw, ctrl_data_arb_prior),\n\t\tREGISTER(dw, ctrl),\n\t};\n\tstruct dentry *regs_dent;\n\tint nr_entries;\n\n\tregs_dent = debugfs_create_dir(REGISTERS_STR, dw->dma.dbg_dev_root);\n\n\tnr_entries = ARRAY_SIZE(debugfs_regs);\n\tdw_edma_debugfs_create_x32(dw, debugfs_regs, nr_entries, regs_dent);\n\n\tdw_edma_debugfs_regs_wr(dw, regs_dent);\n\tdw_edma_debugfs_regs_rd(dw, regs_dent);\n}\n\nvoid dw_edma_v0_debugfs_on(struct dw_edma *dw)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tdebugfs_create_u32(\"mf\", 0444, dw->dma.dbg_dev_root, &dw->chip->mf);\n\tdebugfs_create_u16(\"wr_ch_cnt\", 0444, dw->dma.dbg_dev_root, &dw->wr_ch_cnt);\n\tdebugfs_create_u16(\"rd_ch_cnt\", 0444, dw->dma.dbg_dev_root, &dw->rd_ch_cnt);\n\n\tdw_edma_debugfs_regs(dw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}