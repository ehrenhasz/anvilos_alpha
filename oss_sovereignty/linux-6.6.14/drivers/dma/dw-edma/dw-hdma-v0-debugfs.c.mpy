{
  "module_name": "dw-hdma-v0-debugfs.c",
  "hash_id": "303392d53b766259ec272de1834e53fcffaa176e217140faca23f914284f6dc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-edma/dw-hdma-v0-debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/bitfield.h>\n\n#include \"dw-hdma-v0-debugfs.h\"\n#include \"dw-hdma-v0-regs.h\"\n#include \"dw-edma-core.h\"\n\n#define REGS_ADDR(dw, name)\t\t\t\t\t\t       \\\n\t({\t\t\t\t\t\t\t\t       \\\n\t\tstruct dw_hdma_v0_regs __iomem *__regs = (dw)->chip->reg_base; \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\t(void __iomem *)&__regs->name;\t\t\t\t       \\\n\t})\n\n#define REGS_CH_ADDR(dw, name, _dir, _ch)\t\t\t\t       \\\n\t({\t\t\t\t\t\t\t\t       \\\n\t\tstruct dw_hdma_v0_ch_regs __iomem *__ch_regs;\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tif (_dir == EDMA_DIR_READ)\t\t\t\t       \\\n\t\t\t__ch_regs = REGS_ADDR(dw, ch[_ch].rd);\t\t       \\\n\t\telse\t\t\t\t\t\t\t       \\\n\t\t\t__ch_regs = REGS_ADDR(dw, ch[_ch].wr);\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\t(void __iomem *)&__ch_regs->name;\t\t\t       \\\n\t})\n\n#define CTX_REGISTER(dw, name, dir, ch) \\\n\t{#name, REGS_CH_ADDR(dw, name, dir, ch)}\n\n#define WRITE_STR\t\t\t\t\"write\"\n#define READ_STR\t\t\t\t\"read\"\n#define CHANNEL_STR\t\t\t\t\"channel\"\n#define REGISTERS_STR\t\t\t\t\"registers\"\n\nstruct dw_hdma_debugfs_entry {\n\tconst char\t\t\t\t*name;\n\tvoid __iomem\t\t\t\t*reg;\n};\n\nstatic int dw_hdma_debugfs_u32_get(void *data, u64 *val)\n{\n\tstruct dw_hdma_debugfs_entry *entry = data;\n\tvoid __iomem *reg = entry->reg;\n\n\t*val = readl(reg);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32, dw_hdma_debugfs_u32_get, NULL, \"0x%08llx\\n\");\n\nstatic void dw_hdma_debugfs_create_x32(struct dw_edma *dw,\n\t\t\t\t       const struct dw_hdma_debugfs_entry ini[],\n\t\t\t\t       int nr_entries, struct dentry *dent)\n{\n\tstruct dw_hdma_debugfs_entry *entries;\n\tint i;\n\n\tentries = devm_kcalloc(dw->chip->dev, nr_entries, sizeof(*entries),\n\t\t\t       GFP_KERNEL);\n\tif (!entries)\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\tentries[i] = ini[i];\n\n\t\tdebugfs_create_file_unsafe(entries[i].name, 0444, dent,\n\t\t\t\t\t   &entries[i], &fops_x32);\n\t}\n}\n\nstatic void dw_hdma_debugfs_regs_ch(struct dw_edma *dw, enum dw_edma_dir dir,\n\t\t\t\t    u16 ch, struct dentry *dent)\n{\n\tconst struct dw_hdma_debugfs_entry debugfs_regs[] = {\n\t\tCTX_REGISTER(dw, ch_en, dir, ch),\n\t\tCTX_REGISTER(dw, doorbell, dir, ch),\n\t\tCTX_REGISTER(dw, prefetch, dir, ch),\n\t\tCTX_REGISTER(dw, handshake, dir, ch),\n\t\tCTX_REGISTER(dw, llp.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, llp.msb, dir, ch),\n\t\tCTX_REGISTER(dw, cycle_sync, dir, ch),\n\t\tCTX_REGISTER(dw, transfer_size, dir, ch),\n\t\tCTX_REGISTER(dw, sar.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, sar.msb, dir, ch),\n\t\tCTX_REGISTER(dw, dar.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, dar.msb, dir, ch),\n\t\tCTX_REGISTER(dw, watermark_en, dir, ch),\n\t\tCTX_REGISTER(dw, control1, dir, ch),\n\t\tCTX_REGISTER(dw, func_num, dir, ch),\n\t\tCTX_REGISTER(dw, qos, dir, ch),\n\t\tCTX_REGISTER(dw, ch_stat, dir, ch),\n\t\tCTX_REGISTER(dw, int_stat, dir, ch),\n\t\tCTX_REGISTER(dw, int_setup, dir, ch),\n\t\tCTX_REGISTER(dw, int_clear, dir, ch),\n\t\tCTX_REGISTER(dw, msi_stop.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_stop.msb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_watermark.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_watermark.msb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_abort.lsb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_abort.msb, dir, ch),\n\t\tCTX_REGISTER(dw, msi_msgdata, dir, ch),\n\t};\n\tint nr_entries = ARRAY_SIZE(debugfs_regs);\n\n\tdw_hdma_debugfs_create_x32(dw, debugfs_regs, nr_entries, dent);\n}\n\nstatic void dw_hdma_debugfs_regs_wr(struct dw_edma *dw, struct dentry *dent)\n{\n\tstruct dentry *regs_dent, *ch_dent;\n\tchar name[16];\n\tint i;\n\n\tregs_dent = debugfs_create_dir(WRITE_STR, dent);\n\n\tfor (i = 0; i < dw->wr_ch_cnt; i++) {\n\t\tsnprintf(name, sizeof(name), \"%s:%d\", CHANNEL_STR, i);\n\n\t\tch_dent = debugfs_create_dir(name, regs_dent);\n\n\t\tdw_hdma_debugfs_regs_ch(dw, EDMA_DIR_WRITE, i, ch_dent);\n\t}\n}\n\nstatic void dw_hdma_debugfs_regs_rd(struct dw_edma *dw, struct dentry *dent)\n{\n\tstruct dentry *regs_dent, *ch_dent;\n\tchar name[16];\n\tint i;\n\n\tregs_dent = debugfs_create_dir(READ_STR, dent);\n\n\tfor (i = 0; i < dw->rd_ch_cnt; i++) {\n\t\tsnprintf(name, sizeof(name), \"%s:%d\", CHANNEL_STR, i);\n\n\t\tch_dent = debugfs_create_dir(name, regs_dent);\n\n\t\tdw_hdma_debugfs_regs_ch(dw, EDMA_DIR_READ, i, ch_dent);\n\t}\n}\n\nstatic void dw_hdma_debugfs_regs(struct dw_edma *dw)\n{\n\tstruct dentry *regs_dent;\n\n\tregs_dent = debugfs_create_dir(REGISTERS_STR, dw->dma.dbg_dev_root);\n\n\tdw_hdma_debugfs_regs_wr(dw, regs_dent);\n\tdw_hdma_debugfs_regs_rd(dw, regs_dent);\n}\n\nvoid dw_hdma_v0_debugfs_on(struct dw_edma *dw)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tdebugfs_create_u32(\"mf\", 0444, dw->dma.dbg_dev_root, &dw->chip->mf);\n\tdebugfs_create_u16(\"wr_ch_cnt\", 0444, dw->dma.dbg_dev_root, &dw->wr_ch_cnt);\n\tdebugfs_create_u16(\"rd_ch_cnt\", 0444, dw->dma.dbg_dev_root, &dw->rd_ch_cnt);\n\n\tdw_hdma_debugfs_regs(dw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}