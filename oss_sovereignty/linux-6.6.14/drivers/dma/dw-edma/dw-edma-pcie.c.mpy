{
  "module_name": "dw-edma-pcie.c",
  "hash_id": "3ed2e0b97fc4dc85990231e3b9ab77e14c751373d24735bd2e5bc0d9cf13b374",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-edma/dw-edma-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/dma/edma.h>\n#include <linux/pci-epf.h>\n#include <linux/msi.h>\n#include <linux/bitfield.h>\n\n#include \"dw-edma-core.h\"\n\n#define DW_PCIE_VSEC_DMA_ID\t\t\t0x6\n#define DW_PCIE_VSEC_DMA_BAR\t\t\tGENMASK(10, 8)\n#define DW_PCIE_VSEC_DMA_MAP\t\t\tGENMASK(2, 0)\n#define DW_PCIE_VSEC_DMA_WR_CH\t\t\tGENMASK(9, 0)\n#define DW_PCIE_VSEC_DMA_RD_CH\t\t\tGENMASK(25, 16)\n\n#define DW_BLOCK(a, b, c) \\\n\t{ \\\n\t\t.bar = a, \\\n\t\t.off = b, \\\n\t\t.sz = c, \\\n\t},\n\nstruct dw_edma_block {\n\tenum pci_barno\t\t\tbar;\n\toff_t\t\t\t\toff;\n\tsize_t\t\t\t\tsz;\n};\n\nstruct dw_edma_pcie_data {\n\t \n\tstruct dw_edma_block\t\trg;\n\t \n\tstruct dw_edma_block\t\tll_wr[EDMA_MAX_WR_CH];\n\tstruct dw_edma_block\t\tll_rd[EDMA_MAX_RD_CH];\n\t \n\tstruct dw_edma_block\t\tdt_wr[EDMA_MAX_WR_CH];\n\tstruct dw_edma_block\t\tdt_rd[EDMA_MAX_RD_CH];\n\t \n\tenum dw_edma_map_format\t\tmf;\n\tu8\t\t\t\tirqs;\n\tu16\t\t\t\twr_ch_cnt;\n\tu16\t\t\t\trd_ch_cnt;\n};\n\nstatic const struct dw_edma_pcie_data snps_edda_data = {\n\t \n\t.rg.bar\t\t\t\t= BAR_0,\n\t.rg.off\t\t\t\t= 0x00001000,\t \n\t.rg.sz\t\t\t\t= 0x00002000,\t \n\t \n\t.ll_wr = {\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00000000, 0x00000800)\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00200000, 0x00000800)\n\t},\n\t.ll_rd = {\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00400000, 0x00000800)\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00600000, 0x00000800)\n\t},\n\t \n\t.dt_wr = {\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00800000, 0x00000800)\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00900000, 0x00000800)\n\t},\n\t.dt_rd = {\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00a00000, 0x00000800)\n\t\t \n\t\tDW_BLOCK(BAR_2, 0x00b00000, 0x00000800)\n\t},\n\t \n\t.mf\t\t\t\t= EDMA_MF_EDMA_UNROLL,\n\t.irqs\t\t\t\t= 1,\n\t.wr_ch_cnt\t\t\t= 2,\n\t.rd_ch_cnt\t\t\t= 2,\n};\n\nstatic int dw_edma_pcie_irq_vector(struct device *dev, unsigned int nr)\n{\n\treturn pci_irq_vector(to_pci_dev(dev), nr);\n}\n\nstatic u64 dw_edma_pcie_address(struct device *dev, phys_addr_t cpu_addr)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_bus_region region;\n\tstruct resource res = {\n\t\t.flags = IORESOURCE_MEM,\n\t\t.start = cpu_addr,\n\t\t.end = cpu_addr,\n\t};\n\n\tpcibios_resource_to_bus(pdev->bus, &region, &res);\n\treturn region.start;\n}\n\nstatic const struct dw_edma_plat_ops dw_edma_pcie_plat_ops = {\n\t.irq_vector = dw_edma_pcie_irq_vector,\n\t.pci_address = dw_edma_pcie_address,\n};\n\nstatic void dw_edma_pcie_get_vsec_dma_data(struct pci_dev *pdev,\n\t\t\t\t\t   struct dw_edma_pcie_data *pdata)\n{\n\tu32 val, map;\n\tu16 vsec;\n\tu64 off;\n\n\tvsec = pci_find_vsec_capability(pdev, PCI_VENDOR_ID_SYNOPSYS,\n\t\t\t\t\tDW_PCIE_VSEC_DMA_ID);\n\tif (!vsec)\n\t\treturn;\n\n\tpci_read_config_dword(pdev, vsec + PCI_VNDR_HEADER, &val);\n\tif (PCI_VNDR_HEADER_REV(val) != 0x00 ||\n\t    PCI_VNDR_HEADER_LEN(val) != 0x18)\n\t\treturn;\n\n\tpci_dbg(pdev, \"Detected PCIe Vendor-Specific Extended Capability DMA\\n\");\n\tpci_read_config_dword(pdev, vsec + 0x8, &val);\n\tmap = FIELD_GET(DW_PCIE_VSEC_DMA_MAP, val);\n\tif (map != EDMA_MF_EDMA_LEGACY &&\n\t    map != EDMA_MF_EDMA_UNROLL &&\n\t    map != EDMA_MF_HDMA_COMPAT)\n\t\treturn;\n\n\tpdata->mf = map;\n\tpdata->rg.bar = FIELD_GET(DW_PCIE_VSEC_DMA_BAR, val);\n\n\tpci_read_config_dword(pdev, vsec + 0xc, &val);\n\tpdata->wr_ch_cnt = min_t(u16, pdata->wr_ch_cnt,\n\t\t\t\t FIELD_GET(DW_PCIE_VSEC_DMA_WR_CH, val));\n\tpdata->rd_ch_cnt = min_t(u16, pdata->rd_ch_cnt,\n\t\t\t\t FIELD_GET(DW_PCIE_VSEC_DMA_RD_CH, val));\n\n\tpci_read_config_dword(pdev, vsec + 0x14, &val);\n\toff = val;\n\tpci_read_config_dword(pdev, vsec + 0x10, &val);\n\toff <<= 32;\n\toff |= val;\n\tpdata->rg.off = off;\n}\n\nstatic int dw_edma_pcie_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *pid)\n{\n\tstruct dw_edma_pcie_data *pdata = (void *)pid->driver_data;\n\tstruct dw_edma_pcie_data vsec_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_edma_chip *chip;\n\tint err, nr_irqs;\n\tint i, mask;\n\n\t \n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tpci_err(pdev, \"enabling device failed\\n\");\n\t\treturn err;\n\t}\n\n\tmemcpy(&vsec_data, pdata, sizeof(struct dw_edma_pcie_data));\n\n\t \n\tdw_edma_pcie_get_vsec_dma_data(pdev, &vsec_data);\n\n\t \n\tmask = BIT(vsec_data.rg.bar);\n\tfor (i = 0; i < vsec_data.wr_ch_cnt; i++) {\n\t\tmask |= BIT(vsec_data.ll_wr[i].bar);\n\t\tmask |= BIT(vsec_data.dt_wr[i].bar);\n\t}\n\tfor (i = 0; i < vsec_data.rd_ch_cnt; i++) {\n\t\tmask |= BIT(vsec_data.ll_rd[i].bar);\n\t\tmask |= BIT(vsec_data.dt_rd[i].bar);\n\t}\n\terr = pcim_iomap_regions(pdev, mask, pci_name(pdev));\n\tif (err) {\n\t\tpci_err(pdev, \"eDMA BAR I/O remapping failed\\n\");\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tpci_err(pdev, \"DMA mask 64 set failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\t \n\tnr_irqs = pci_alloc_irq_vectors(pdev, 1, vsec_data.irqs,\n\t\t\t\t\tPCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (nr_irqs < 1) {\n\t\tpci_err(pdev, \"fail to alloc IRQ vector (number of IRQs=%u)\\n\",\n\t\t\tnr_irqs);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tchip->dev = dev;\n\n\tchip->mf = vsec_data.mf;\n\tchip->nr_irqs = nr_irqs;\n\tchip->ops = &dw_edma_pcie_plat_ops;\n\n\tchip->ll_wr_cnt = vsec_data.wr_ch_cnt;\n\tchip->ll_rd_cnt = vsec_data.rd_ch_cnt;\n\n\tchip->reg_base = pcim_iomap_table(pdev)[vsec_data.rg.bar];\n\tif (!chip->reg_base)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < chip->ll_wr_cnt; i++) {\n\t\tstruct dw_edma_region *ll_region = &chip->ll_region_wr[i];\n\t\tstruct dw_edma_region *dt_region = &chip->dt_region_wr[i];\n\t\tstruct dw_edma_block *ll_block = &vsec_data.ll_wr[i];\n\t\tstruct dw_edma_block *dt_block = &vsec_data.dt_wr[i];\n\n\t\tll_region->vaddr.io = pcim_iomap_table(pdev)[ll_block->bar];\n\t\tif (!ll_region->vaddr.io)\n\t\t\treturn -ENOMEM;\n\n\t\tll_region->vaddr.io += ll_block->off;\n\t\tll_region->paddr = pci_bus_address(pdev, ll_block->bar);\n\t\tll_region->paddr += ll_block->off;\n\t\tll_region->sz = ll_block->sz;\n\n\t\tdt_region->vaddr.io = pcim_iomap_table(pdev)[dt_block->bar];\n\t\tif (!dt_region->vaddr.io)\n\t\t\treturn -ENOMEM;\n\n\t\tdt_region->vaddr.io += dt_block->off;\n\t\tdt_region->paddr = pci_bus_address(pdev, dt_block->bar);\n\t\tdt_region->paddr += dt_block->off;\n\t\tdt_region->sz = dt_block->sz;\n\t}\n\n\tfor (i = 0; i < chip->ll_rd_cnt; i++) {\n\t\tstruct dw_edma_region *ll_region = &chip->ll_region_rd[i];\n\t\tstruct dw_edma_region *dt_region = &chip->dt_region_rd[i];\n\t\tstruct dw_edma_block *ll_block = &vsec_data.ll_rd[i];\n\t\tstruct dw_edma_block *dt_block = &vsec_data.dt_rd[i];\n\n\t\tll_region->vaddr.io = pcim_iomap_table(pdev)[ll_block->bar];\n\t\tif (!ll_region->vaddr.io)\n\t\t\treturn -ENOMEM;\n\n\t\tll_region->vaddr.io += ll_block->off;\n\t\tll_region->paddr = pci_bus_address(pdev, ll_block->bar);\n\t\tll_region->paddr += ll_block->off;\n\t\tll_region->sz = ll_block->sz;\n\n\t\tdt_region->vaddr.io = pcim_iomap_table(pdev)[dt_block->bar];\n\t\tif (!dt_region->vaddr.io)\n\t\t\treturn -ENOMEM;\n\n\t\tdt_region->vaddr.io += dt_block->off;\n\t\tdt_region->paddr = pci_bus_address(pdev, dt_block->bar);\n\t\tdt_region->paddr += dt_block->off;\n\t\tdt_region->sz = dt_block->sz;\n\t}\n\n\t \n\tif (chip->mf == EDMA_MF_EDMA_LEGACY)\n\t\tpci_dbg(pdev, \"Version:\\teDMA Port Logic (0x%x)\\n\", chip->mf);\n\telse if (chip->mf == EDMA_MF_EDMA_UNROLL)\n\t\tpci_dbg(pdev, \"Version:\\teDMA Unroll (0x%x)\\n\", chip->mf);\n\telse if (chip->mf == EDMA_MF_HDMA_COMPAT)\n\t\tpci_dbg(pdev, \"Version:\\tHDMA Compatible (0x%x)\\n\", chip->mf);\n\telse\n\t\tpci_dbg(pdev, \"Version:\\tUnknown (0x%x)\\n\", chip->mf);\n\n\tpci_dbg(pdev, \"Registers:\\tBAR=%u, off=0x%.8lx, sz=0x%zx bytes, addr(v=%p)\\n\",\n\t\tvsec_data.rg.bar, vsec_data.rg.off, vsec_data.rg.sz,\n\t\tchip->reg_base);\n\n\n\tfor (i = 0; i < chip->ll_wr_cnt; i++) {\n\t\tpci_dbg(pdev, \"L. List:\\tWRITE CH%.2u, BAR=%u, off=0x%.8lx, sz=0x%zx bytes, addr(v=%p, p=%pa)\\n\",\n\t\t\ti, vsec_data.ll_wr[i].bar,\n\t\t\tvsec_data.ll_wr[i].off, chip->ll_region_wr[i].sz,\n\t\t\tchip->ll_region_wr[i].vaddr.io, &chip->ll_region_wr[i].paddr);\n\n\t\tpci_dbg(pdev, \"Data:\\tWRITE CH%.2u, BAR=%u, off=0x%.8lx, sz=0x%zx bytes, addr(v=%p, p=%pa)\\n\",\n\t\t\ti, vsec_data.dt_wr[i].bar,\n\t\t\tvsec_data.dt_wr[i].off, chip->dt_region_wr[i].sz,\n\t\t\tchip->dt_region_wr[i].vaddr.io, &chip->dt_region_wr[i].paddr);\n\t}\n\n\tfor (i = 0; i < chip->ll_rd_cnt; i++) {\n\t\tpci_dbg(pdev, \"L. List:\\tREAD CH%.2u, BAR=%u, off=0x%.8lx, sz=0x%zx bytes, addr(v=%p, p=%pa)\\n\",\n\t\t\ti, vsec_data.ll_rd[i].bar,\n\t\t\tvsec_data.ll_rd[i].off, chip->ll_region_rd[i].sz,\n\t\t\tchip->ll_region_rd[i].vaddr.io, &chip->ll_region_rd[i].paddr);\n\n\t\tpci_dbg(pdev, \"Data:\\tREAD CH%.2u, BAR=%u, off=0x%.8lx, sz=0x%zx bytes, addr(v=%p, p=%pa)\\n\",\n\t\t\ti, vsec_data.dt_rd[i].bar,\n\t\t\tvsec_data.dt_rd[i].off, chip->dt_region_rd[i].sz,\n\t\t\tchip->dt_region_rd[i].vaddr.io, &chip->dt_region_rd[i].paddr);\n\t}\n\n\tpci_dbg(pdev, \"Nr. IRQs:\\t%u\\n\", chip->nr_irqs);\n\n\t \n\tif (!pci_dev_msi_enabled(pdev)) {\n\t\tpci_err(pdev, \"enable interrupt failed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\terr = dw_edma_probe(chip);\n\tif (err) {\n\t\tpci_err(pdev, \"eDMA probe failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tpci_set_drvdata(pdev, chip);\n\n\treturn 0;\n}\n\nstatic void dw_edma_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct dw_edma_chip *chip = pci_get_drvdata(pdev);\n\tint err;\n\n\t \n\terr = dw_edma_remove(chip);\n\tif (err)\n\t\tpci_warn(pdev, \"can't remove device properly: %d\\n\", err);\n\n\t \n\tpci_free_irq_vectors(pdev);\n}\n\nstatic const struct pci_device_id dw_edma_pcie_id_table[] = {\n\t{ PCI_DEVICE_DATA(SYNOPSYS, EDDA, &snps_edda_data) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, dw_edma_pcie_id_table);\n\nstatic struct pci_driver dw_edma_pcie_driver = {\n\t.name\t\t= \"dw-edma-pcie\",\n\t.id_table\t= dw_edma_pcie_id_table,\n\t.probe\t\t= dw_edma_pcie_probe,\n\t.remove\t\t= dw_edma_pcie_remove,\n};\n\nmodule_pci_driver(dw_edma_pcie_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare eDMA PCIe driver\");\nMODULE_AUTHOR(\"Gustavo Pimentel <gustavo.pimentel@synopsys.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}