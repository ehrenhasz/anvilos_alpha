{
  "module_name": "tegra210-adma.c",
  "hash_id": "632169150ed8feaaebf5a7ca13089a010e27666f129a94a7fa03fac73a112bbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/tegra210-adma.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"virt-dma.h\"\n\n#define ADMA_CH_CMD\t\t\t\t\t0x00\n#define ADMA_CH_STATUS\t\t\t\t\t0x0c\n#define ADMA_CH_STATUS_XFER_EN\t\t\t\tBIT(0)\n#define ADMA_CH_STATUS_XFER_PAUSED\t\t\tBIT(1)\n\n#define ADMA_CH_INT_STATUS\t\t\t\t0x10\n#define ADMA_CH_INT_STATUS_XFER_DONE\t\t\tBIT(0)\n\n#define ADMA_CH_INT_CLEAR\t\t\t\t0x1c\n#define ADMA_CH_CTRL\t\t\t\t\t0x24\n#define ADMA_CH_CTRL_DIR(val)\t\t\t\t(((val) & 0xf) << 12)\n#define ADMA_CH_CTRL_DIR_AHUB2MEM\t\t\t2\n#define ADMA_CH_CTRL_DIR_MEM2AHUB\t\t\t4\n#define ADMA_CH_CTRL_MODE_CONTINUOUS\t\t\t(2 << 8)\n#define ADMA_CH_CTRL_FLOWCTRL_EN\t\t\tBIT(1)\n#define ADMA_CH_CTRL_XFER_PAUSE_SHIFT\t\t\t0\n\n#define ADMA_CH_CONFIG\t\t\t\t\t0x28\n#define ADMA_CH_CONFIG_SRC_BUF(val)\t\t\t(((val) & 0x7) << 28)\n#define ADMA_CH_CONFIG_TRG_BUF(val)\t\t\t(((val) & 0x7) << 24)\n#define ADMA_CH_CONFIG_BURST_SIZE_SHIFT\t\t\t20\n#define ADMA_CH_CONFIG_MAX_BURST_SIZE                   16\n#define ADMA_CH_CONFIG_WEIGHT_FOR_WRR(val)\t\t((val) & 0xf)\n#define ADMA_CH_CONFIG_MAX_BUFS\t\t\t\t8\n#define TEGRA186_ADMA_CH_CONFIG_OUTSTANDING_REQS(reqs)\t(reqs << 4)\n\n#define ADMA_CH_FIFO_CTRL\t\t\t\t0x2c\n#define ADMA_CH_TX_FIFO_SIZE_SHIFT\t\t\t8\n#define ADMA_CH_RX_FIFO_SIZE_SHIFT\t\t\t0\n\n#define ADMA_CH_LOWER_SRC_ADDR\t\t\t\t0x34\n#define ADMA_CH_LOWER_TRG_ADDR\t\t\t\t0x3c\n#define ADMA_CH_TC\t\t\t\t\t0x44\n#define ADMA_CH_TC_COUNT_MASK\t\t\t\t0x3ffffffc\n\n#define ADMA_CH_XFER_STATUS\t\t\t\t0x54\n#define ADMA_CH_XFER_STATUS_COUNT_MASK\t\t\t0xffff\n\n#define ADMA_GLOBAL_CMD\t\t\t\t\t0x00\n#define ADMA_GLOBAL_SOFT_RESET\t\t\t\t0x04\n\n#define TEGRA_ADMA_BURST_COMPLETE_TIME\t\t\t20\n\n#define ADMA_CH_REG_FIELD_VAL(val, mask, shift)\t(((val) & mask) << shift)\n\nstruct tegra_adma;\n\n \nstruct tegra_adma_chip_data {\n\tunsigned int (*adma_get_burst_config)(unsigned int burst_size);\n\tunsigned int global_reg_offset;\n\tunsigned int global_int_clear;\n\tunsigned int ch_req_tx_shift;\n\tunsigned int ch_req_rx_shift;\n\tunsigned int ch_base_offset;\n\tunsigned int ch_fifo_ctrl;\n\tunsigned int ch_req_mask;\n\tunsigned int ch_req_max;\n\tunsigned int ch_reg_size;\n\tunsigned int nr_channels;\n\tunsigned int ch_fifo_size_mask;\n\tunsigned int sreq_index_offset;\n\tbool has_outstanding_reqs;\n};\n\n \nstruct tegra_adma_chan_regs {\n\tunsigned int ctrl;\n\tunsigned int config;\n\tunsigned int src_addr;\n\tunsigned int trg_addr;\n\tunsigned int fifo_ctrl;\n\tunsigned int cmd;\n\tunsigned int tc;\n};\n\n \nstruct tegra_adma_desc {\n\tstruct virt_dma_desc\t\tvd;\n\tstruct tegra_adma_chan_regs\tch_regs;\n\tsize_t\t\t\t\tbuf_len;\n\tsize_t\t\t\t\tperiod_len;\n\tsize_t\t\t\t\tnum_periods;\n};\n\n \nstruct tegra_adma_chan {\n\tstruct virt_dma_chan\t\tvc;\n\tstruct tegra_adma_desc\t\t*desc;\n\tstruct tegra_adma\t\t*tdma;\n\tint\t\t\t\tirq;\n\tvoid __iomem\t\t\t*chan_addr;\n\n\t \n\tstruct dma_slave_config\t\tsconfig;\n\tenum dma_transfer_direction\tsreq_dir;\n\tunsigned int\t\t\tsreq_index;\n\tbool\t\t\t\tsreq_reserved;\n\tstruct tegra_adma_chan_regs\tch_regs;\n\n\t \n\tunsigned int\t\t\ttx_buf_count;\n\tunsigned int\t\t\ttx_buf_pos;\n};\n\n \nstruct tegra_adma {\n\tstruct dma_device\t\tdma_dev;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*base_addr;\n\tstruct clk\t\t\t*ahub_clk;\n\tunsigned int\t\t\tnr_channels;\n\tunsigned long\t\t\trx_requests_reserved;\n\tunsigned long\t\t\ttx_requests_reserved;\n\n\t \n\tunsigned int\t\t\tglobal_cmd;\n\n\tconst struct tegra_adma_chip_data *cdata;\n\n\t \n\tstruct tegra_adma_chan\t\tchannels[];\n};\n\nstatic inline void tdma_write(struct tegra_adma *tdma, u32 reg, u32 val)\n{\n\twritel(val, tdma->base_addr + tdma->cdata->global_reg_offset + reg);\n}\n\nstatic inline u32 tdma_read(struct tegra_adma *tdma, u32 reg)\n{\n\treturn readl(tdma->base_addr + tdma->cdata->global_reg_offset + reg);\n}\n\nstatic inline void tdma_ch_write(struct tegra_adma_chan *tdc, u32 reg, u32 val)\n{\n\twritel(val, tdc->chan_addr + reg);\n}\n\nstatic inline u32 tdma_ch_read(struct tegra_adma_chan *tdc, u32 reg)\n{\n\treturn readl(tdc->chan_addr + reg);\n}\n\nstatic inline struct tegra_adma_chan *to_tegra_adma_chan(struct dma_chan *dc)\n{\n\treturn container_of(dc, struct tegra_adma_chan, vc.chan);\n}\n\nstatic inline struct tegra_adma_desc *to_tegra_adma_desc(\n\t\tstruct dma_async_tx_descriptor *td)\n{\n\treturn container_of(td, struct tegra_adma_desc, vd.tx);\n}\n\nstatic inline struct device *tdc2dev(struct tegra_adma_chan *tdc)\n{\n\treturn tdc->tdma->dev;\n}\n\nstatic void tegra_adma_desc_free(struct virt_dma_desc *vd)\n{\n\tkfree(container_of(vd, struct tegra_adma_desc, vd));\n}\n\nstatic int tegra_adma_slave_config(struct dma_chan *dc,\n\t\t\t\t   struct dma_slave_config *sconfig)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\n\tmemcpy(&tdc->sconfig, sconfig, sizeof(*sconfig));\n\n\treturn 0;\n}\n\nstatic int tegra_adma_init(struct tegra_adma *tdma)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\ttdma_write(tdma, tdma->cdata->ch_base_offset + tdma->cdata->global_int_clear, 0x1);\n\n\t \n\ttdma_write(tdma, ADMA_GLOBAL_SOFT_RESET, 0x1);\n\n\t \n\tret = readx_poll_timeout(readl,\n\t\t\t\t tdma->base_addr +\n\t\t\t\t tdma->cdata->global_reg_offset +\n\t\t\t\t ADMA_GLOBAL_SOFT_RESET,\n\t\t\t\t status, status == 0, 20, 10000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttdma_write(tdma, ADMA_GLOBAL_CMD, 1);\n\n\treturn 0;\n}\n\nstatic int tegra_adma_request_alloc(struct tegra_adma_chan *tdc,\n\t\t\t\t    enum dma_transfer_direction direction)\n{\n\tstruct tegra_adma *tdma = tdc->tdma;\n\tunsigned int sreq_index = tdc->sreq_index;\n\n\tif (tdc->sreq_reserved)\n\t\treturn tdc->sreq_dir == direction ? 0 : -EINVAL;\n\n\tif (sreq_index > tdma->cdata->ch_req_max) {\n\t\tdev_err(tdma->dev, \"invalid DMA request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tif (test_and_set_bit(sreq_index, &tdma->tx_requests_reserved)) {\n\t\t\tdev_err(tdma->dev, \"DMA request reserved\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tif (test_and_set_bit(sreq_index, &tdma->rx_requests_reserved)) {\n\t\t\tdev_err(tdma->dev, \"DMA request reserved\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_WARN(tdma->dev, \"channel %s has invalid transfer type\\n\",\n\t\t\t dma_chan_name(&tdc->vc.chan));\n\t\treturn -EINVAL;\n\t}\n\n\ttdc->sreq_dir = direction;\n\ttdc->sreq_reserved = true;\n\n\treturn 0;\n}\n\nstatic void tegra_adma_request_free(struct tegra_adma_chan *tdc)\n{\n\tstruct tegra_adma *tdma = tdc->tdma;\n\n\tif (!tdc->sreq_reserved)\n\t\treturn;\n\n\tswitch (tdc->sreq_dir) {\n\tcase DMA_MEM_TO_DEV:\n\t\tclear_bit(tdc->sreq_index, &tdma->tx_requests_reserved);\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tclear_bit(tdc->sreq_index, &tdma->rx_requests_reserved);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_WARN(tdma->dev, \"channel %s has invalid transfer type\\n\",\n\t\t\t dma_chan_name(&tdc->vc.chan));\n\t\treturn;\n\t}\n\n\ttdc->sreq_reserved = false;\n}\n\nstatic u32 tegra_adma_irq_status(struct tegra_adma_chan *tdc)\n{\n\tu32 status = tdma_ch_read(tdc, ADMA_CH_INT_STATUS);\n\n\treturn status & ADMA_CH_INT_STATUS_XFER_DONE;\n}\n\nstatic u32 tegra_adma_irq_clear(struct tegra_adma_chan *tdc)\n{\n\tu32 status = tegra_adma_irq_status(tdc);\n\n\tif (status)\n\t\ttdma_ch_write(tdc, ADMA_CH_INT_CLEAR, status);\n\n\treturn status;\n}\n\nstatic void tegra_adma_stop(struct tegra_adma_chan *tdc)\n{\n\tunsigned int status;\n\n\t \n\ttdma_ch_write(tdc, ADMA_CH_CMD, 0);\n\n\t \n\ttegra_adma_irq_clear(tdc);\n\n\tif (readx_poll_timeout_atomic(readl, tdc->chan_addr + ADMA_CH_STATUS,\n\t\t\tstatus, !(status & ADMA_CH_STATUS_XFER_EN),\n\t\t\t20, 10000)) {\n\t\tdev_err(tdc2dev(tdc), \"unable to stop DMA channel\\n\");\n\t\treturn;\n\t}\n\n\tkfree(tdc->desc);\n\ttdc->desc = NULL;\n}\n\nstatic void tegra_adma_start(struct tegra_adma_chan *tdc)\n{\n\tstruct virt_dma_desc *vd = vchan_next_desc(&tdc->vc);\n\tstruct tegra_adma_chan_regs *ch_regs;\n\tstruct tegra_adma_desc *desc;\n\n\tif (!vd)\n\t\treturn;\n\n\tlist_del(&vd->node);\n\n\tdesc = to_tegra_adma_desc(&vd->tx);\n\n\tif (!desc) {\n\t\tdev_warn(tdc2dev(tdc), \"unable to start DMA, no descriptor\\n\");\n\t\treturn;\n\t}\n\n\tch_regs = &desc->ch_regs;\n\n\ttdc->tx_buf_pos = 0;\n\ttdc->tx_buf_count = 0;\n\ttdma_ch_write(tdc, ADMA_CH_TC, ch_regs->tc);\n\ttdma_ch_write(tdc, ADMA_CH_CTRL, ch_regs->ctrl);\n\ttdma_ch_write(tdc, ADMA_CH_LOWER_SRC_ADDR, ch_regs->src_addr);\n\ttdma_ch_write(tdc, ADMA_CH_LOWER_TRG_ADDR, ch_regs->trg_addr);\n\ttdma_ch_write(tdc, ADMA_CH_FIFO_CTRL, ch_regs->fifo_ctrl);\n\ttdma_ch_write(tdc, ADMA_CH_CONFIG, ch_regs->config);\n\n\t \n\ttdma_ch_write(tdc, ADMA_CH_CMD, 1);\n\n\ttdc->desc = desc;\n}\n\nstatic unsigned int tegra_adma_get_residue(struct tegra_adma_chan *tdc)\n{\n\tstruct tegra_adma_desc *desc = tdc->desc;\n\tunsigned int max = ADMA_CH_XFER_STATUS_COUNT_MASK + 1;\n\tunsigned int pos = tdma_ch_read(tdc, ADMA_CH_XFER_STATUS);\n\tunsigned int periods_remaining;\n\n\t \n\tif (pos < tdc->tx_buf_pos)\n\t\ttdc->tx_buf_count += pos + (max - tdc->tx_buf_pos);\n\telse\n\t\ttdc->tx_buf_count += pos - tdc->tx_buf_pos;\n\n\tperiods_remaining = tdc->tx_buf_count % desc->num_periods;\n\ttdc->tx_buf_pos = pos;\n\n\treturn desc->buf_len - (periods_remaining * desc->period_len);\n}\n\nstatic irqreturn_t tegra_adma_isr(int irq, void *dev_id)\n{\n\tstruct tegra_adma_chan *tdc = dev_id;\n\tunsigned long status;\n\n\tspin_lock(&tdc->vc.lock);\n\n\tstatus = tegra_adma_irq_clear(tdc);\n\tif (status == 0 || !tdc->desc) {\n\t\tspin_unlock(&tdc->vc.lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tvchan_cyclic_callback(&tdc->desc->vd);\n\n\tspin_unlock(&tdc->vc.lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_adma_issue_pending(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\n\tif (vchan_issue_pending(&tdc->vc)) {\n\t\tif (!tdc->desc)\n\t\t\ttegra_adma_start(tdc);\n\t}\n\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n}\n\nstatic bool tegra_adma_is_paused(struct tegra_adma_chan *tdc)\n{\n\tu32 csts;\n\n\tcsts = tdma_ch_read(tdc, ADMA_CH_STATUS);\n\tcsts &= ADMA_CH_STATUS_XFER_PAUSED;\n\n\treturn csts ? true : false;\n}\n\nstatic int tegra_adma_pause(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tstruct tegra_adma_desc *desc = tdc->desc;\n\tstruct tegra_adma_chan_regs *ch_regs = &desc->ch_regs;\n\tint dcnt = 10;\n\n\tch_regs->ctrl = tdma_ch_read(tdc, ADMA_CH_CTRL);\n\tch_regs->ctrl |= (1 << ADMA_CH_CTRL_XFER_PAUSE_SHIFT);\n\ttdma_ch_write(tdc, ADMA_CH_CTRL, ch_regs->ctrl);\n\n\twhile (dcnt-- && !tegra_adma_is_paused(tdc))\n\t\tudelay(TEGRA_ADMA_BURST_COMPLETE_TIME);\n\n\tif (dcnt < 0) {\n\t\tdev_err(tdc2dev(tdc), \"unable to pause DMA channel\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_adma_resume(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tstruct tegra_adma_desc *desc = tdc->desc;\n\tstruct tegra_adma_chan_regs *ch_regs = &desc->ch_regs;\n\n\tch_regs->ctrl = tdma_ch_read(tdc, ADMA_CH_CTRL);\n\tch_regs->ctrl &= ~(1 << ADMA_CH_CTRL_XFER_PAUSE_SHIFT);\n\ttdma_ch_write(tdc, ADMA_CH_CTRL, ch_regs->ctrl);\n\n\treturn 0;\n}\n\nstatic int tegra_adma_terminate_all(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\n\tif (tdc->desc)\n\t\ttegra_adma_stop(tdc);\n\n\ttegra_adma_request_free(tdc);\n\tvchan_get_all_descriptors(&tdc->vc, &head);\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\tvchan_dma_desc_free_list(&tdc->vc, &head);\n\n\treturn 0;\n}\n\nstatic enum dma_status tegra_adma_tx_status(struct dma_chan *dc,\n\t\t\t\t\t    dma_cookie_t cookie,\n\t\t\t\t\t    struct dma_tx_state *txstate)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tstruct tegra_adma_desc *desc;\n\tstruct virt_dma_desc *vd;\n\tenum dma_status ret;\n\tunsigned long flags;\n\tunsigned int residual;\n\n\tret = dma_cookie_status(dc, cookie, txstate);\n\tif (ret == DMA_COMPLETE || !txstate)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&tdc->vc.lock, flags);\n\n\tvd = vchan_find_desc(&tdc->vc, cookie);\n\tif (vd) {\n\t\tdesc = to_tegra_adma_desc(&vd->tx);\n\t\tresidual = desc->ch_regs.tc;\n\t} else if (tdc->desc && tdc->desc->vd.tx.cookie == cookie) {\n\t\tresidual = tegra_adma_get_residue(tdc);\n\t} else {\n\t\tresidual = 0;\n\t}\n\n\tspin_unlock_irqrestore(&tdc->vc.lock, flags);\n\n\tdma_set_residue(txstate, residual);\n\n\treturn ret;\n}\n\nstatic unsigned int tegra210_adma_get_burst_config(unsigned int burst_size)\n{\n\tif (!burst_size || burst_size > ADMA_CH_CONFIG_MAX_BURST_SIZE)\n\t\tburst_size = ADMA_CH_CONFIG_MAX_BURST_SIZE;\n\n\treturn fls(burst_size) << ADMA_CH_CONFIG_BURST_SIZE_SHIFT;\n}\n\nstatic unsigned int tegra186_adma_get_burst_config(unsigned int burst_size)\n{\n\tif (!burst_size || burst_size > ADMA_CH_CONFIG_MAX_BURST_SIZE)\n\t\tburst_size = ADMA_CH_CONFIG_MAX_BURST_SIZE;\n\n\treturn (burst_size - 1) << ADMA_CH_CONFIG_BURST_SIZE_SHIFT;\n}\n\nstatic int tegra_adma_set_xfer_params(struct tegra_adma_chan *tdc,\n\t\t\t\t      struct tegra_adma_desc *desc,\n\t\t\t\t      dma_addr_t buf_addr,\n\t\t\t\t      enum dma_transfer_direction direction)\n{\n\tstruct tegra_adma_chan_regs *ch_regs = &desc->ch_regs;\n\tconst struct tegra_adma_chip_data *cdata = tdc->tdma->cdata;\n\tunsigned int burst_size, adma_dir, fifo_size_shift;\n\n\tif (desc->num_periods > ADMA_CH_CONFIG_MAX_BUFS)\n\t\treturn -EINVAL;\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tfifo_size_shift = ADMA_CH_TX_FIFO_SIZE_SHIFT;\n\t\tadma_dir = ADMA_CH_CTRL_DIR_MEM2AHUB;\n\t\tburst_size = tdc->sconfig.dst_maxburst;\n\t\tch_regs->config = ADMA_CH_CONFIG_SRC_BUF(desc->num_periods - 1);\n\t\tch_regs->ctrl = ADMA_CH_REG_FIELD_VAL(tdc->sreq_index,\n\t\t\t\t\t\t      cdata->ch_req_mask,\n\t\t\t\t\t\t      cdata->ch_req_tx_shift);\n\t\tch_regs->src_addr = buf_addr;\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tfifo_size_shift = ADMA_CH_RX_FIFO_SIZE_SHIFT;\n\t\tadma_dir = ADMA_CH_CTRL_DIR_AHUB2MEM;\n\t\tburst_size = tdc->sconfig.src_maxburst;\n\t\tch_regs->config = ADMA_CH_CONFIG_TRG_BUF(desc->num_periods - 1);\n\t\tch_regs->ctrl = ADMA_CH_REG_FIELD_VAL(tdc->sreq_index,\n\t\t\t\t\t\t      cdata->ch_req_mask,\n\t\t\t\t\t\t      cdata->ch_req_rx_shift);\n\t\tch_regs->trg_addr = buf_addr;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(tdc2dev(tdc), \"DMA direction is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tch_regs->ctrl |= ADMA_CH_CTRL_DIR(adma_dir) |\n\t\t\t ADMA_CH_CTRL_MODE_CONTINUOUS |\n\t\t\t ADMA_CH_CTRL_FLOWCTRL_EN;\n\tch_regs->config |= cdata->adma_get_burst_config(burst_size);\n\tch_regs->config |= ADMA_CH_CONFIG_WEIGHT_FOR_WRR(1);\n\tif (cdata->has_outstanding_reqs)\n\t\tch_regs->config |= TEGRA186_ADMA_CH_CONFIG_OUTSTANDING_REQS(8);\n\n\t \n\tif (tdc->sreq_index > cdata->sreq_index_offset)\n\t\tch_regs->fifo_ctrl =\n\t\t\tADMA_CH_REG_FIELD_VAL(2, cdata->ch_fifo_size_mask,\n\t\t\t\t\t      fifo_size_shift);\n\telse\n\t\tch_regs->fifo_ctrl =\n\t\t\tADMA_CH_REG_FIELD_VAL(3, cdata->ch_fifo_size_mask,\n\t\t\t\t\t      fifo_size_shift);\n\n\tch_regs->tc = desc->period_len & ADMA_CH_TC_COUNT_MASK;\n\n\treturn tegra_adma_request_alloc(tdc, direction);\n}\n\nstatic struct dma_async_tx_descriptor *tegra_adma_prep_dma_cyclic(\n\tstruct dma_chan *dc, dma_addr_t buf_addr, size_t buf_len,\n\tsize_t period_len, enum dma_transfer_direction direction,\n\tunsigned long flags)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tstruct tegra_adma_desc *desc = NULL;\n\n\tif (!buf_len || !period_len || period_len > ADMA_CH_TC_COUNT_MASK) {\n\t\tdev_err(tdc2dev(tdc), \"invalid buffer/period len\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (buf_len % period_len) {\n\t\tdev_err(tdc2dev(tdc), \"buf_len not a multiple of period_len\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!IS_ALIGNED(buf_addr, 4)) {\n\t\tdev_err(tdc2dev(tdc), \"invalid buffer alignment\\n\");\n\t\treturn NULL;\n\t}\n\n\tdesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->buf_len = buf_len;\n\tdesc->period_len = period_len;\n\tdesc->num_periods = buf_len / period_len;\n\n\tif (tegra_adma_set_xfer_params(tdc, desc, buf_addr, direction)) {\n\t\tkfree(desc);\n\t\treturn NULL;\n\t}\n\n\treturn vchan_tx_prep(&tdc->vc, &desc->vd, flags);\n}\n\nstatic int tegra_adma_alloc_chan_resources(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\tint ret;\n\n\tret = request_irq(tdc->irq, tegra_adma_isr, 0, dma_chan_name(dc), tdc);\n\tif (ret) {\n\t\tdev_err(tdc2dev(tdc), \"failed to get interrupt for %s\\n\",\n\t\t\tdma_chan_name(dc));\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(tdc2dev(tdc));\n\tif (ret < 0) {\n\t\tfree_irq(tdc->irq, tdc);\n\t\treturn ret;\n\t}\n\n\tdma_cookie_init(&tdc->vc.chan);\n\n\treturn 0;\n}\n\nstatic void tegra_adma_free_chan_resources(struct dma_chan *dc)\n{\n\tstruct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);\n\n\ttegra_adma_terminate_all(dc);\n\tvchan_free_chan_resources(&tdc->vc);\n\ttasklet_kill(&tdc->vc.task);\n\tfree_irq(tdc->irq, tdc);\n\tpm_runtime_put(tdc2dev(tdc));\n\n\ttdc->sreq_index = 0;\n\ttdc->sreq_dir = DMA_TRANS_NONE;\n}\n\nstatic struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct tegra_adma *tdma = ofdma->of_dma_data;\n\tstruct tegra_adma_chan *tdc;\n\tstruct dma_chan *chan;\n\tunsigned int sreq_index;\n\n\tif (dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\tsreq_index = dma_spec->args[0];\n\n\tif (sreq_index == 0) {\n\t\tdev_err(tdma->dev, \"DMA request must not be 0\\n\");\n\t\treturn NULL;\n\t}\n\n\tchan = dma_get_any_slave_channel(&tdma->dma_dev);\n\tif (!chan)\n\t\treturn NULL;\n\n\ttdc = to_tegra_adma_chan(chan);\n\ttdc->sreq_index = sreq_index;\n\n\treturn chan;\n}\n\nstatic int __maybe_unused tegra_adma_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_adma *tdma = dev_get_drvdata(dev);\n\tstruct tegra_adma_chan_regs *ch_reg;\n\tstruct tegra_adma_chan *tdc;\n\tint i;\n\n\ttdma->global_cmd = tdma_read(tdma, ADMA_GLOBAL_CMD);\n\tif (!tdma->global_cmd)\n\t\tgoto clk_disable;\n\n\tfor (i = 0; i < tdma->nr_channels; i++) {\n\t\ttdc = &tdma->channels[i];\n\t\tch_reg = &tdc->ch_regs;\n\t\tch_reg->cmd = tdma_ch_read(tdc, ADMA_CH_CMD);\n\t\t \n\t\tif (!ch_reg->cmd)\n\t\t\tcontinue;\n\t\tch_reg->tc = tdma_ch_read(tdc, ADMA_CH_TC);\n\t\tch_reg->src_addr = tdma_ch_read(tdc, ADMA_CH_LOWER_SRC_ADDR);\n\t\tch_reg->trg_addr = tdma_ch_read(tdc, ADMA_CH_LOWER_TRG_ADDR);\n\t\tch_reg->ctrl = tdma_ch_read(tdc, ADMA_CH_CTRL);\n\t\tch_reg->fifo_ctrl = tdma_ch_read(tdc, ADMA_CH_FIFO_CTRL);\n\t\tch_reg->config = tdma_ch_read(tdc, ADMA_CH_CONFIG);\n\t}\n\nclk_disable:\n\tclk_disable_unprepare(tdma->ahub_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_adma_runtime_resume(struct device *dev)\n{\n\tstruct tegra_adma *tdma = dev_get_drvdata(dev);\n\tstruct tegra_adma_chan_regs *ch_reg;\n\tstruct tegra_adma_chan *tdc;\n\tint ret, i;\n\n\tret = clk_prepare_enable(tdma->ahub_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"ahub clk_enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ttdma_write(tdma, ADMA_GLOBAL_CMD, tdma->global_cmd);\n\n\tif (!tdma->global_cmd)\n\t\treturn 0;\n\n\tfor (i = 0; i < tdma->nr_channels; i++) {\n\t\ttdc = &tdma->channels[i];\n\t\tch_reg = &tdc->ch_regs;\n\t\t \n\t\tif (!ch_reg->cmd)\n\t\t\tcontinue;\n\t\ttdma_ch_write(tdc, ADMA_CH_TC, ch_reg->tc);\n\t\ttdma_ch_write(tdc, ADMA_CH_LOWER_SRC_ADDR, ch_reg->src_addr);\n\t\ttdma_ch_write(tdc, ADMA_CH_LOWER_TRG_ADDR, ch_reg->trg_addr);\n\t\ttdma_ch_write(tdc, ADMA_CH_CTRL, ch_reg->ctrl);\n\t\ttdma_ch_write(tdc, ADMA_CH_FIFO_CTRL, ch_reg->fifo_ctrl);\n\t\ttdma_ch_write(tdc, ADMA_CH_CONFIG, ch_reg->config);\n\t\ttdma_ch_write(tdc, ADMA_CH_CMD, ch_reg->cmd);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tegra_adma_chip_data tegra210_chip_data = {\n\t.adma_get_burst_config  = tegra210_adma_get_burst_config,\n\t.global_reg_offset\t= 0xc00,\n\t.global_int_clear\t= 0x20,\n\t.ch_req_tx_shift\t= 28,\n\t.ch_req_rx_shift\t= 24,\n\t.ch_base_offset\t\t= 0,\n\t.ch_req_mask\t\t= 0xf,\n\t.ch_req_max\t\t= 10,\n\t.ch_reg_size\t\t= 0x80,\n\t.nr_channels\t\t= 22,\n\t.ch_fifo_size_mask\t= 0xf,\n\t.sreq_index_offset\t= 2,\n\t.has_outstanding_reqs\t= false,\n};\n\nstatic const struct tegra_adma_chip_data tegra186_chip_data = {\n\t.adma_get_burst_config  = tegra186_adma_get_burst_config,\n\t.global_reg_offset\t= 0,\n\t.global_int_clear\t= 0x402c,\n\t.ch_req_tx_shift\t= 27,\n\t.ch_req_rx_shift\t= 22,\n\t.ch_base_offset\t\t= 0x10000,\n\t.ch_req_mask\t\t= 0x1f,\n\t.ch_req_max\t\t= 20,\n\t.ch_reg_size\t\t= 0x100,\n\t.nr_channels\t\t= 32,\n\t.ch_fifo_size_mask\t= 0x1f,\n\t.sreq_index_offset\t= 4,\n\t.has_outstanding_reqs\t= true,\n};\n\nstatic const struct of_device_id tegra_adma_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-adma\", .data = &tegra210_chip_data },\n\t{ .compatible = \"nvidia,tegra186-adma\", .data = &tegra186_chip_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_adma_of_match);\n\nstatic int tegra_adma_probe(struct platform_device *pdev)\n{\n\tconst struct tegra_adma_chip_data *cdata;\n\tstruct tegra_adma *tdma;\n\tint ret, i;\n\n\tcdata = of_device_get_match_data(&pdev->dev);\n\tif (!cdata) {\n\t\tdev_err(&pdev->dev, \"device match data not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttdma = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(tdma, channels, cdata->nr_channels),\n\t\t\t    GFP_KERNEL);\n\tif (!tdma)\n\t\treturn -ENOMEM;\n\n\ttdma->dev = &pdev->dev;\n\ttdma->cdata = cdata;\n\ttdma->nr_channels = cdata->nr_channels;\n\tplatform_set_drvdata(pdev, tdma);\n\n\ttdma->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tdma->base_addr))\n\t\treturn PTR_ERR(tdma->base_addr);\n\n\ttdma->ahub_clk = devm_clk_get(&pdev->dev, \"d_audio\");\n\tif (IS_ERR(tdma->ahub_clk)) {\n\t\tdev_err(&pdev->dev, \"Error: Missing ahub controller clock\\n\");\n\t\treturn PTR_ERR(tdma->ahub_clk);\n\t}\n\n\tINIT_LIST_HEAD(&tdma->dma_dev.channels);\n\tfor (i = 0; i < tdma->nr_channels; i++) {\n\t\tstruct tegra_adma_chan *tdc = &tdma->channels[i];\n\n\t\ttdc->chan_addr = tdma->base_addr + cdata->ch_base_offset\n\t\t\t\t + (cdata->ch_reg_size * i);\n\n\t\ttdc->irq = of_irq_get(pdev->dev.of_node, i);\n\t\tif (tdc->irq <= 0) {\n\t\t\tret = tdc->irq ?: -ENXIO;\n\t\t\tgoto irq_dispose;\n\t\t}\n\n\t\tvchan_init(&tdc->vc, &tdma->dma_dev);\n\t\ttdc->vc.desc_free = tegra_adma_desc_free;\n\t\ttdc->tdma = tdma;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto rpm_disable;\n\n\tret = tegra_adma_init(tdma);\n\tif (ret)\n\t\tgoto rpm_put;\n\n\tdma_cap_set(DMA_SLAVE, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, tdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, tdma->dma_dev.cap_mask);\n\n\ttdma->dma_dev.dev = &pdev->dev;\n\ttdma->dma_dev.device_alloc_chan_resources =\n\t\t\t\t\ttegra_adma_alloc_chan_resources;\n\ttdma->dma_dev.device_free_chan_resources =\n\t\t\t\t\ttegra_adma_free_chan_resources;\n\ttdma->dma_dev.device_issue_pending = tegra_adma_issue_pending;\n\ttdma->dma_dev.device_prep_dma_cyclic = tegra_adma_prep_dma_cyclic;\n\ttdma->dma_dev.device_config = tegra_adma_slave_config;\n\ttdma->dma_dev.device_tx_status = tegra_adma_tx_status;\n\ttdma->dma_dev.device_terminate_all = tegra_adma_terminate_all;\n\ttdma->dma_dev.src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\ttdma->dma_dev.dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\ttdma->dma_dev.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\ttdma->dma_dev.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;\n\ttdma->dma_dev.device_pause = tegra_adma_pause;\n\ttdma->dma_dev.device_resume = tegra_adma_resume;\n\n\tret = dma_async_device_register(&tdma->dma_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"ADMA registration failed: %d\\n\", ret);\n\t\tgoto rpm_put;\n\t}\n\n\tret = of_dma_controller_register(pdev->dev.of_node,\n\t\t\t\t\t tegra_dma_of_xlate, tdma);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"ADMA OF registration failed %d\\n\", ret);\n\t\tgoto dma_remove;\n\t}\n\n\tpm_runtime_put(&pdev->dev);\n\n\tdev_info(&pdev->dev, \"Tegra210 ADMA driver registered %d channels\\n\",\n\t\t tdma->nr_channels);\n\n\treturn 0;\n\ndma_remove:\n\tdma_async_device_unregister(&tdma->dma_dev);\nrpm_put:\n\tpm_runtime_put_sync(&pdev->dev);\nrpm_disable:\n\tpm_runtime_disable(&pdev->dev);\nirq_dispose:\n\twhile (--i >= 0)\n\t\tirq_dispose_mapping(tdma->channels[i].irq);\n\n\treturn ret;\n}\n\nstatic int tegra_adma_remove(struct platform_device *pdev)\n{\n\tstruct tegra_adma *tdma = platform_get_drvdata(pdev);\n\tint i;\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&tdma->dma_dev);\n\n\tfor (i = 0; i < tdma->nr_channels; ++i)\n\t\tirq_dispose_mapping(tdma->channels[i].irq);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_adma_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_adma_runtime_suspend,\n\t\t\t   tegra_adma_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra_admac_driver = {\n\t.driver = {\n\t\t.name\t= \"tegra-adma\",\n\t\t.pm\t= &tegra_adma_dev_pm_ops,\n\t\t.of_match_table = tegra_adma_of_match,\n\t},\n\t.probe\t\t= tegra_adma_probe,\n\t.remove\t\t= tegra_adma_remove,\n};\n\nmodule_platform_driver(tegra_admac_driver);\n\nMODULE_ALIAS(\"platform:tegra210-adma\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra ADMA driver\");\nMODULE_AUTHOR(\"Dara Ramesh <dramesh@nvidia.com>\");\nMODULE_AUTHOR(\"Jon Hunter <jonathanh@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}