{
  "module_name": "dpaa2-qdma.c",
  "hash_id": "2963e29abb9b7521f8cd0f4d05cf7d4f4664139d11c0f32c12f9715600800c8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/fsl-dpaa2-qdma/dpaa2-qdma.c",
  "human_readable_source": "\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dmapool.h>\n#include <linux/of_irq.h>\n#include <linux/iommu.h>\n#include <linux/sys_soc.h>\n#include <linux/fsl/mc.h>\n#include <soc/fsl/dpaa2-io.h>\n\n#include \"../virt-dma.h\"\n#include \"dpdmai.h\"\n#include \"dpaa2-qdma.h\"\n\nstatic bool smmu_disable = true;\n\nstatic struct dpaa2_qdma_chan *to_dpaa2_qdma_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct dpaa2_qdma_chan, vchan.chan);\n}\n\nstatic struct dpaa2_qdma_comp *to_fsl_qdma_comp(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct dpaa2_qdma_comp, vdesc);\n}\n\nstatic int dpaa2_qdma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct dpaa2_qdma_chan *dpaa2_chan = to_dpaa2_qdma_chan(chan);\n\tstruct dpaa2_qdma_engine *dpaa2_qdma = dpaa2_chan->qdma;\n\tstruct device *dev = &dpaa2_qdma->priv->dpdmai_dev->dev;\n\n\tdpaa2_chan->fd_pool = dma_pool_create(\"fd_pool\", dev,\n\t\t\t\t\t      sizeof(struct dpaa2_fd),\n\t\t\t\t\t      sizeof(struct dpaa2_fd), 0);\n\tif (!dpaa2_chan->fd_pool)\n\t\tgoto err;\n\n\tdpaa2_chan->fl_pool = dma_pool_create(\"fl_pool\", dev,\n\t\t\t\t\t      sizeof(struct dpaa2_fl_entry),\n\t\t\t\t\t      sizeof(struct dpaa2_fl_entry), 0);\n\tif (!dpaa2_chan->fl_pool)\n\t\tgoto err_fd;\n\n\tdpaa2_chan->sdd_pool =\n\t\tdma_pool_create(\"sdd_pool\", dev,\n\t\t\t\tsizeof(struct dpaa2_qdma_sd_d),\n\t\t\t\tsizeof(struct dpaa2_qdma_sd_d), 0);\n\tif (!dpaa2_chan->sdd_pool)\n\t\tgoto err_fl;\n\n\treturn dpaa2_qdma->desc_allocated++;\nerr_fl:\n\tdma_pool_destroy(dpaa2_chan->fl_pool);\nerr_fd:\n\tdma_pool_destroy(dpaa2_chan->fd_pool);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void dpaa2_qdma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct dpaa2_qdma_chan *dpaa2_chan = to_dpaa2_qdma_chan(chan);\n\tstruct dpaa2_qdma_engine *dpaa2_qdma = dpaa2_chan->qdma;\n\tunsigned long flags;\n\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&dpaa2_chan->vchan.lock, flags);\n\tvchan_get_all_descriptors(&dpaa2_chan->vchan, &head);\n\tspin_unlock_irqrestore(&dpaa2_chan->vchan.lock, flags);\n\n\tvchan_dma_desc_free_list(&dpaa2_chan->vchan, &head);\n\n\tdpaa2_dpdmai_free_comp(dpaa2_chan, &dpaa2_chan->comp_used);\n\tdpaa2_dpdmai_free_comp(dpaa2_chan, &dpaa2_chan->comp_free);\n\n\tdma_pool_destroy(dpaa2_chan->fd_pool);\n\tdma_pool_destroy(dpaa2_chan->fl_pool);\n\tdma_pool_destroy(dpaa2_chan->sdd_pool);\n\tdpaa2_qdma->desc_allocated--;\n}\n\n \nstatic struct dpaa2_qdma_comp *\ndpaa2_qdma_request_desc(struct dpaa2_qdma_chan *dpaa2_chan)\n{\n\tstruct dpaa2_qdma_priv *qdma_priv = dpaa2_chan->qdma->priv;\n\tstruct device *dev = &qdma_priv->dpdmai_dev->dev;\n\tstruct dpaa2_qdma_comp *comp_temp = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dpaa2_chan->queue_lock, flags);\n\tif (list_empty(&dpaa2_chan->comp_free)) {\n\t\tspin_unlock_irqrestore(&dpaa2_chan->queue_lock, flags);\n\t\tcomp_temp = kzalloc(sizeof(*comp_temp), GFP_NOWAIT);\n\t\tif (!comp_temp)\n\t\t\tgoto err;\n\t\tcomp_temp->fd_virt_addr =\n\t\t\tdma_pool_alloc(dpaa2_chan->fd_pool, GFP_NOWAIT,\n\t\t\t\t       &comp_temp->fd_bus_addr);\n\t\tif (!comp_temp->fd_virt_addr)\n\t\t\tgoto err_comp;\n\n\t\tcomp_temp->fl_virt_addr =\n\t\t\tdma_pool_alloc(dpaa2_chan->fl_pool, GFP_NOWAIT,\n\t\t\t\t       &comp_temp->fl_bus_addr);\n\t\tif (!comp_temp->fl_virt_addr)\n\t\t\tgoto err_fd_virt;\n\n\t\tcomp_temp->desc_virt_addr =\n\t\t\tdma_pool_alloc(dpaa2_chan->sdd_pool, GFP_NOWAIT,\n\t\t\t\t       &comp_temp->desc_bus_addr);\n\t\tif (!comp_temp->desc_virt_addr)\n\t\t\tgoto err_fl_virt;\n\n\t\tcomp_temp->qchan = dpaa2_chan;\n\t\treturn comp_temp;\n\t}\n\n\tcomp_temp = list_first_entry(&dpaa2_chan->comp_free,\n\t\t\t\t     struct dpaa2_qdma_comp, list);\n\tlist_del(&comp_temp->list);\n\tspin_unlock_irqrestore(&dpaa2_chan->queue_lock, flags);\n\n\tcomp_temp->qchan = dpaa2_chan;\n\n\treturn comp_temp;\n\nerr_fl_virt:\n\t\tdma_pool_free(dpaa2_chan->fl_pool,\n\t\t\t      comp_temp->fl_virt_addr,\n\t\t\t      comp_temp->fl_bus_addr);\nerr_fd_virt:\n\t\tdma_pool_free(dpaa2_chan->fd_pool,\n\t\t\t      comp_temp->fd_virt_addr,\n\t\t\t      comp_temp->fd_bus_addr);\nerr_comp:\n\tkfree(comp_temp);\nerr:\n\tdev_err(dev, \"Failed to request descriptor\\n\");\n\treturn NULL;\n}\n\nstatic void\ndpaa2_qdma_populate_fd(u32 format, struct dpaa2_qdma_comp *dpaa2_comp)\n{\n\tstruct dpaa2_fd *fd;\n\n\tfd = dpaa2_comp->fd_virt_addr;\n\tmemset(fd, 0, sizeof(struct dpaa2_fd));\n\n\t \n\tdpaa2_fd_set_addr(fd, dpaa2_comp->fl_bus_addr);\n\n\t \n\tif (smmu_disable)\n\t\tdpaa2_fd_set_bpid(fd, QMAN_FD_BMT_ENABLE);\n\tdpaa2_fd_set_format(fd, QMAN_FD_FMT_ENABLE | QMAN_FD_SL_DISABLE);\n\n\tdpaa2_fd_set_frc(fd, format | QDMA_SER_CTX);\n}\n\n \nstatic void\ndpaa2_qdma_populate_first_framel(struct dpaa2_fl_entry *f_list,\n\t\t\t\t struct dpaa2_qdma_comp *dpaa2_comp,\n\t\t\t\t bool wrt_changed)\n{\n\tstruct dpaa2_qdma_sd_d *sdd;\n\n\tsdd = dpaa2_comp->desc_virt_addr;\n\tmemset(sdd, 0, 2 * (sizeof(*sdd)));\n\n\t \n\tsdd->cmd = cpu_to_le32(QDMA_SD_CMD_RDTTYPE_COHERENT);\n\tsdd++;\n\n\t \n\tif (wrt_changed)\n\t\tsdd->cmd = cpu_to_le32(LX2160_QDMA_DD_CMD_WRTTYPE_COHERENT);\n\telse\n\t\tsdd->cmd = cpu_to_le32(QDMA_DD_CMD_WRTTYPE_COHERENT);\n\n\tmemset(f_list, 0, sizeof(struct dpaa2_fl_entry));\n\n\t \n\tdpaa2_fl_set_addr(f_list, dpaa2_comp->desc_bus_addr);\n\tdpaa2_fl_set_len(f_list, 0x20);\n\tdpaa2_fl_set_format(f_list, QDMA_FL_FMT_SBF | QDMA_FL_SL_LONG);\n\n\t \n\tif (smmu_disable)\n\t\tf_list->bpid = cpu_to_le16(QDMA_FL_BMT_ENABLE);\n}\n\n \nstatic void\ndpaa2_qdma_populate_frames(struct dpaa2_fl_entry *f_list,\n\t\t\t   dma_addr_t dst, dma_addr_t src,\n\t\t\t   size_t len, uint8_t fmt)\n{\n\t \n\tmemset(f_list, 0, sizeof(struct dpaa2_fl_entry));\n\n\tdpaa2_fl_set_addr(f_list, src);\n\tdpaa2_fl_set_len(f_list, len);\n\n\t \n\tdpaa2_fl_set_format(f_list, (fmt | QDMA_FL_SL_LONG));\n\n\t \n\tif (smmu_disable)\n\t\tf_list->bpid = cpu_to_le16(QDMA_FL_BMT_ENABLE);\n\n\tf_list++;\n\n\t \n\tmemset(f_list, 0, sizeof(struct dpaa2_fl_entry));\n\n\tdpaa2_fl_set_addr(f_list, dst);\n\tdpaa2_fl_set_len(f_list, len);\n\tdpaa2_fl_set_format(f_list, (fmt | QDMA_FL_SL_LONG));\n\t \n\tdpaa2_fl_set_final(f_list, QDMA_FL_F);\n\t \n\tif (smmu_disable)\n\t\tf_list->bpid = cpu_to_le16(QDMA_FL_BMT_ENABLE);\n}\n\nstatic struct dma_async_tx_descriptor\n*dpaa2_qdma_prep_memcpy(struct dma_chan *chan, dma_addr_t dst,\n\t\t\tdma_addr_t src, size_t len, ulong flags)\n{\n\tstruct dpaa2_qdma_chan *dpaa2_chan = to_dpaa2_qdma_chan(chan);\n\tstruct dpaa2_qdma_engine *dpaa2_qdma;\n\tstruct dpaa2_qdma_comp *dpaa2_comp;\n\tstruct dpaa2_fl_entry *f_list;\n\tbool wrt_changed;\n\n\tdpaa2_qdma = dpaa2_chan->qdma;\n\tdpaa2_comp = dpaa2_qdma_request_desc(dpaa2_chan);\n\tif (!dpaa2_comp)\n\t\treturn NULL;\n\n\twrt_changed = (bool)dpaa2_qdma->qdma_wrtype_fixup;\n\n\t \n\tdpaa2_qdma_populate_fd(QDMA_FD_LONG_FORMAT, dpaa2_comp);\n\n\tf_list = dpaa2_comp->fl_virt_addr;\n\n\t \n\tdpaa2_qdma_populate_first_framel(f_list, dpaa2_comp, wrt_changed);\n\n\tf_list++;\n\n\tdpaa2_qdma_populate_frames(f_list, dst, src, len, QDMA_FL_FMT_SBF);\n\n\treturn vchan_tx_prep(&dpaa2_chan->vchan, &dpaa2_comp->vdesc, flags);\n}\n\nstatic void dpaa2_qdma_issue_pending(struct dma_chan *chan)\n{\n\tstruct dpaa2_qdma_chan *dpaa2_chan = to_dpaa2_qdma_chan(chan);\n\tstruct dpaa2_qdma_comp *dpaa2_comp;\n\tstruct virt_dma_desc *vdesc;\n\tstruct dpaa2_fd *fd;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&dpaa2_chan->queue_lock, flags);\n\tspin_lock(&dpaa2_chan->vchan.lock);\n\tif (vchan_issue_pending(&dpaa2_chan->vchan)) {\n\t\tvdesc = vchan_next_desc(&dpaa2_chan->vchan);\n\t\tif (!vdesc)\n\t\t\tgoto err_enqueue;\n\t\tdpaa2_comp = to_fsl_qdma_comp(vdesc);\n\n\t\tfd = dpaa2_comp->fd_virt_addr;\n\n\t\tlist_del(&vdesc->node);\n\t\tlist_add_tail(&dpaa2_comp->list, &dpaa2_chan->comp_used);\n\n\t\terr = dpaa2_io_service_enqueue_fq(NULL, dpaa2_chan->fqid, fd);\n\t\tif (err) {\n\t\t\tlist_move_tail(&dpaa2_comp->list,\n\t\t\t\t       &dpaa2_chan->comp_free);\n\t\t}\n\t}\nerr_enqueue:\n\tspin_unlock(&dpaa2_chan->vchan.lock);\n\tspin_unlock_irqrestore(&dpaa2_chan->queue_lock, flags);\n}\n\nstatic int __cold dpaa2_qdma_setup(struct fsl_mc_device *ls_dev)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv;\n\tstruct device *dev = &ls_dev->dev;\n\tstruct dpaa2_qdma_priv *priv;\n\tu8 prio_def = DPDMAI_PRIO_NUM;\n\tint err = -EINVAL;\n\tint i;\n\n\tpriv = dev_get_drvdata(dev);\n\n\tpriv->dev = dev;\n\tpriv->dpqdma_id = ls_dev->obj_desc.id;\n\n\t \n\terr = dpdmai_open(priv->mc_io, 0, priv->dpqdma_id, &ls_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpdmai_open() failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(dev, \"Opened dpdmai object successfully\\n\");\n\n\terr = dpdmai_get_attributes(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t    &priv->dpdmai_attr);\n\tif (err) {\n\t\tdev_err(dev, \"dpdmai_get_attributes() failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (priv->dpdmai_attr.version.major > DPDMAI_VER_MAJOR) {\n\t\terr = -EINVAL;\n\t\tdev_err(dev, \"DPDMAI major version mismatch\\n\"\n\t\t\t     \"Found %u.%u, supported version is %u.%u\\n\",\n\t\t\t\tpriv->dpdmai_attr.version.major,\n\t\t\t\tpriv->dpdmai_attr.version.minor,\n\t\t\t\tDPDMAI_VER_MAJOR, DPDMAI_VER_MINOR);\n\t\tgoto exit;\n\t}\n\n\tif (priv->dpdmai_attr.version.minor > DPDMAI_VER_MINOR) {\n\t\terr = -EINVAL;\n\t\tdev_err(dev, \"DPDMAI minor version mismatch\\n\"\n\t\t\t     \"Found %u.%u, supported version is %u.%u\\n\",\n\t\t\t\tpriv->dpdmai_attr.version.major,\n\t\t\t\tpriv->dpdmai_attr.version.minor,\n\t\t\t\tDPDMAI_VER_MAJOR, DPDMAI_VER_MINOR);\n\t\tgoto exit;\n\t}\n\n\tpriv->num_pairs = min(priv->dpdmai_attr.num_of_priorities, prio_def);\n\tppriv = kcalloc(priv->num_pairs, sizeof(*ppriv), GFP_KERNEL);\n\tif (!ppriv) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tpriv->ppriv = ppriv;\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\terr = dpdmai_get_rx_queue(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t\t  i, &priv->rx_queue_attr[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpdmai_get_rx_queue() failed\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tppriv->rsp_fqid = priv->rx_queue_attr[i].fqid;\n\n\t\terr = dpdmai_get_tx_queue(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t\t  i, &priv->tx_fqid[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpdmai_get_tx_queue() failed\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tppriv->req_fqid = priv->tx_fqid[i];\n\t\tppriv->prio = i;\n\t\tppriv->priv = priv;\n\t\tppriv++;\n\t}\n\n\treturn 0;\nexit:\n\tdpdmai_close(priv->mc_io, 0, ls_dev->mc_handle);\n\treturn err;\n}\n\nstatic void dpaa2_qdma_fqdan_cb(struct dpaa2_io_notification_ctx *ctx)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv = container_of(ctx,\n\t\t\tstruct dpaa2_qdma_priv_per_prio, nctx);\n\tstruct dpaa2_qdma_comp *dpaa2_comp, *_comp_tmp;\n\tstruct dpaa2_qdma_priv *priv = ppriv->priv;\n\tu32 n_chans = priv->dpaa2_qdma->n_chans;\n\tstruct dpaa2_qdma_chan *qchan;\n\tconst struct dpaa2_fd *fd_eq;\n\tconst struct dpaa2_fd *fd;\n\tstruct dpaa2_dq *dq;\n\tint is_last = 0;\n\tint found;\n\tu8 status;\n\tint err;\n\tint i;\n\n\tdo {\n\t\terr = dpaa2_io_service_pull_fq(NULL, ppriv->rsp_fqid,\n\t\t\t\t\t       ppriv->store);\n\t} while (err);\n\n\twhile (!is_last) {\n\t\tdo {\n\t\t\tdq = dpaa2_io_store_next(ppriv->store, &is_last);\n\t\t} while (!is_last && !dq);\n\t\tif (!dq) {\n\t\t\tdev_err(priv->dev, \"FQID returned no valid frames!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfd = dpaa2_dq_fd(dq);\n\n\t\tstatus = dpaa2_fd_get_ctrl(fd) & 0xff;\n\t\tif (status)\n\t\t\tdev_err(priv->dev, \"FD error occurred\\n\");\n\t\tfound = 0;\n\t\tfor (i = 0; i < n_chans; i++) {\n\t\t\tqchan = &priv->dpaa2_qdma->chans[i];\n\t\t\tspin_lock(&qchan->queue_lock);\n\t\t\tif (list_empty(&qchan->comp_used)) {\n\t\t\t\tspin_unlock(&qchan->queue_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(dpaa2_comp, _comp_tmp,\n\t\t\t\t\t\t &qchan->comp_used, list) {\n\t\t\t\tfd_eq = dpaa2_comp->fd_virt_addr;\n\n\t\t\t\tif (le64_to_cpu(fd_eq->simple.addr) ==\n\t\t\t\t    le64_to_cpu(fd->simple.addr)) {\n\t\t\t\t\tspin_lock(&qchan->vchan.lock);\n\t\t\t\t\tvchan_cookie_complete(&\n\t\t\t\t\t\t\tdpaa2_comp->vdesc);\n\t\t\t\t\tspin_unlock(&qchan->vchan.lock);\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&qchan->queue_lock);\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tdpaa2_io_service_rearm(NULL, ctx);\n}\n\nstatic int __cold dpaa2_qdma_dpio_setup(struct dpaa2_qdma_priv *priv)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv;\n\tstruct device *dev = priv->dev;\n\tint err = -EINVAL;\n\tint i, num;\n\n\tnum = priv->num_pairs;\n\tppriv = priv->ppriv;\n\tfor (i = 0; i < num; i++) {\n\t\tppriv->nctx.is_cdan = 0;\n\t\tppriv->nctx.desired_cpu = DPAA2_IO_ANY_CPU;\n\t\tppriv->nctx.id = ppriv->rsp_fqid;\n\t\tppriv->nctx.cb = dpaa2_qdma_fqdan_cb;\n\t\terr = dpaa2_io_service_register(NULL, &ppriv->nctx, dev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Notification register failed\\n\");\n\t\t\tgoto err_service;\n\t\t}\n\n\t\tppriv->store =\n\t\t\tdpaa2_io_store_create(DPAA2_QDMA_STORE_SIZE, dev);\n\t\tif (!ppriv->store) {\n\t\t\terr = -ENOMEM;\n\t\t\tdev_err(dev, \"dpaa2_io_store_create() failed\\n\");\n\t\t\tgoto err_store;\n\t\t}\n\n\t\tppriv++;\n\t}\n\treturn 0;\n\nerr_store:\n\tdpaa2_io_service_deregister(NULL, &ppriv->nctx, dev);\nerr_service:\n\tppriv--;\n\twhile (ppriv >= priv->ppriv) {\n\t\tdpaa2_io_service_deregister(NULL, &ppriv->nctx, dev);\n\t\tdpaa2_io_store_destroy(ppriv->store);\n\t\tppriv--;\n\t}\n\treturn err;\n}\n\nstatic void dpaa2_dpmai_store_free(struct dpaa2_qdma_priv *priv)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv = priv->ppriv;\n\tint i;\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\tdpaa2_io_store_destroy(ppriv->store);\n\t\tppriv++;\n\t}\n}\n\nstatic void dpaa2_dpdmai_dpio_free(struct dpaa2_qdma_priv *priv)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv = priv->ppriv;\n\tstruct device *dev = priv->dev;\n\tint i;\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\tdpaa2_io_service_deregister(NULL, &ppriv->nctx, dev);\n\t\tppriv++;\n\t}\n}\n\nstatic int __cold dpaa2_dpdmai_bind(struct dpaa2_qdma_priv *priv)\n{\n\tstruct dpdmai_rx_queue_cfg rx_queue_cfg;\n\tstruct dpaa2_qdma_priv_per_prio *ppriv;\n\tstruct device *dev = priv->dev;\n\tstruct fsl_mc_device *ls_dev;\n\tint i, num;\n\tint err;\n\n\tls_dev = to_fsl_mc_device(dev);\n\tnum = priv->num_pairs;\n\tppriv = priv->ppriv;\n\tfor (i = 0; i < num; i++) {\n\t\trx_queue_cfg.options = DPDMAI_QUEUE_OPT_USER_CTX |\n\t\t\t\t\tDPDMAI_QUEUE_OPT_DEST;\n\t\trx_queue_cfg.user_ctx = ppriv->nctx.qman64;\n\t\trx_queue_cfg.dest_cfg.dest_type = DPDMAI_DEST_DPIO;\n\t\trx_queue_cfg.dest_cfg.dest_id = ppriv->nctx.dpio_id;\n\t\trx_queue_cfg.dest_cfg.priority = ppriv->prio;\n\t\terr = dpdmai_set_rx_queue(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t\t  rx_queue_cfg.dest_cfg.priority,\n\t\t\t\t\t  &rx_queue_cfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpdmai_set_rx_queue() failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tppriv++;\n\t}\n\n\treturn 0;\n}\n\nstatic int __cold dpaa2_dpdmai_dpio_unbind(struct dpaa2_qdma_priv *priv)\n{\n\tstruct dpaa2_qdma_priv_per_prio *ppriv = priv->ppriv;\n\tstruct device *dev = priv->dev;\n\tstruct fsl_mc_device *ls_dev;\n\tint err = 0;\n\tint i;\n\n\tls_dev = to_fsl_mc_device(dev);\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\tppriv->nctx.qman64 = 0;\n\t\tppriv->nctx.dpio_id = 0;\n\t\tppriv++;\n\t}\n\n\terr = dpdmai_reset(priv->mc_io, 0, ls_dev->mc_handle);\n\tif (err)\n\t\tdev_err(dev, \"dpdmai_reset() failed\\n\");\n\n\treturn err;\n}\n\nstatic void dpaa2_dpdmai_free_comp(struct dpaa2_qdma_chan *qchan,\n\t\t\t\t   struct list_head *head)\n{\n\tstruct dpaa2_qdma_comp *comp_tmp, *_comp_tmp;\n\tunsigned long flags;\n\n\tlist_for_each_entry_safe(comp_tmp, _comp_tmp,\n\t\t\t\t head, list) {\n\t\tspin_lock_irqsave(&qchan->queue_lock, flags);\n\t\tlist_del(&comp_tmp->list);\n\t\tspin_unlock_irqrestore(&qchan->queue_lock, flags);\n\t\tdma_pool_free(qchan->fd_pool,\n\t\t\t      comp_tmp->fd_virt_addr,\n\t\t\t      comp_tmp->fd_bus_addr);\n\t\tdma_pool_free(qchan->fl_pool,\n\t\t\t      comp_tmp->fl_virt_addr,\n\t\t\t      comp_tmp->fl_bus_addr);\n\t\tdma_pool_free(qchan->sdd_pool,\n\t\t\t      comp_tmp->desc_virt_addr,\n\t\t\t      comp_tmp->desc_bus_addr);\n\t\tkfree(comp_tmp);\n\t}\n}\n\nstatic void dpaa2_dpdmai_free_channels(struct dpaa2_qdma_engine *dpaa2_qdma)\n{\n\tstruct dpaa2_qdma_chan *qchan;\n\tint num, i;\n\n\tnum = dpaa2_qdma->n_chans;\n\tfor (i = 0; i < num; i++) {\n\t\tqchan = &dpaa2_qdma->chans[i];\n\t\tdpaa2_dpdmai_free_comp(qchan, &qchan->comp_used);\n\t\tdpaa2_dpdmai_free_comp(qchan, &qchan->comp_free);\n\t\tdma_pool_destroy(qchan->fd_pool);\n\t\tdma_pool_destroy(qchan->fl_pool);\n\t\tdma_pool_destroy(qchan->sdd_pool);\n\t}\n}\n\nstatic void dpaa2_qdma_free_desc(struct virt_dma_desc *vdesc)\n{\n\tstruct dpaa2_qdma_comp *dpaa2_comp;\n\tstruct dpaa2_qdma_chan *qchan;\n\tunsigned long flags;\n\n\tdpaa2_comp = to_fsl_qdma_comp(vdesc);\n\tqchan = dpaa2_comp->qchan;\n\tspin_lock_irqsave(&qchan->queue_lock, flags);\n\tlist_move_tail(&dpaa2_comp->list, &qchan->comp_free);\n\tspin_unlock_irqrestore(&qchan->queue_lock, flags);\n}\n\nstatic int dpaa2_dpdmai_init_channels(struct dpaa2_qdma_engine *dpaa2_qdma)\n{\n\tstruct dpaa2_qdma_priv *priv = dpaa2_qdma->priv;\n\tstruct dpaa2_qdma_chan *dpaa2_chan;\n\tint num = priv->num_pairs;\n\tint i;\n\n\tINIT_LIST_HEAD(&dpaa2_qdma->dma_dev.channels);\n\tfor (i = 0; i < dpaa2_qdma->n_chans; i++) {\n\t\tdpaa2_chan = &dpaa2_qdma->chans[i];\n\t\tdpaa2_chan->qdma = dpaa2_qdma;\n\t\tdpaa2_chan->fqid = priv->tx_fqid[i % num];\n\t\tdpaa2_chan->vchan.desc_free = dpaa2_qdma_free_desc;\n\t\tvchan_init(&dpaa2_chan->vchan, &dpaa2_qdma->dma_dev);\n\t\tspin_lock_init(&dpaa2_chan->queue_lock);\n\t\tINIT_LIST_HEAD(&dpaa2_chan->comp_used);\n\t\tINIT_LIST_HEAD(&dpaa2_chan->comp_free);\n\t}\n\treturn 0;\n}\n\nstatic int dpaa2_qdma_probe(struct fsl_mc_device *dpdmai_dev)\n{\n\tstruct device *dev = &dpdmai_dev->dev;\n\tstruct dpaa2_qdma_engine *dpaa2_qdma;\n\tstruct dpaa2_qdma_priv *priv;\n\tint err;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, priv);\n\tpriv->dpdmai_dev = dpdmai_dev;\n\n\tpriv->iommu_domain = iommu_get_domain_for_dev(dev);\n\tif (priv->iommu_domain)\n\t\tsmmu_disable = false;\n\n\t \n\terr = fsl_mc_portal_allocate(dpdmai_dev, 0, &priv->mc_io);\n\tif (err) {\n\t\tif (err == -ENXIO)\n\t\t\terr = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_err(dev, \"MC portal allocation failed\\n\");\n\t\tgoto err_mcportal;\n\t}\n\n\t \n\terr = dpaa2_qdma_setup(dpdmai_dev);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpdmai_setup() failed\\n\");\n\t\tgoto err_dpdmai_setup;\n\t}\n\n\t \n\terr = dpaa2_qdma_dpio_setup(priv);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpdmai_dpio_setup() failed\\n\");\n\t\tgoto err_dpio_setup;\n\t}\n\n\t \n\terr = dpaa2_dpdmai_bind(priv);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpdmai_bind() failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\t \n\terr = dpdmai_enable(priv->mc_io, 0, dpdmai_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpdmai_enable() failed\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tdpaa2_qdma = kzalloc(sizeof(*dpaa2_qdma), GFP_KERNEL);\n\tif (!dpaa2_qdma) {\n\t\terr = -ENOMEM;\n\t\tgoto err_eng;\n\t}\n\n\tpriv->dpaa2_qdma = dpaa2_qdma;\n\tdpaa2_qdma->priv = priv;\n\n\tdpaa2_qdma->desc_allocated = 0;\n\tdpaa2_qdma->n_chans = NUM_CH;\n\n\tdpaa2_dpdmai_init_channels(dpaa2_qdma);\n\n\tif (soc_device_match(soc_fixup_tuning))\n\t\tdpaa2_qdma->qdma_wrtype_fixup = true;\n\telse\n\t\tdpaa2_qdma->qdma_wrtype_fixup = false;\n\n\tdma_cap_set(DMA_PRIVATE, dpaa2_qdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_SLAVE, dpaa2_qdma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, dpaa2_qdma->dma_dev.cap_mask);\n\n\tdpaa2_qdma->dma_dev.dev = dev;\n\tdpaa2_qdma->dma_dev.device_alloc_chan_resources =\n\t\tdpaa2_qdma_alloc_chan_resources;\n\tdpaa2_qdma->dma_dev.device_free_chan_resources =\n\t\tdpaa2_qdma_free_chan_resources;\n\tdpaa2_qdma->dma_dev.device_tx_status = dma_cookie_status;\n\tdpaa2_qdma->dma_dev.device_prep_dma_memcpy = dpaa2_qdma_prep_memcpy;\n\tdpaa2_qdma->dma_dev.device_issue_pending = dpaa2_qdma_issue_pending;\n\n\terr = dma_async_device_register(&dpaa2_qdma->dma_dev);\n\tif (err) {\n\t\tdev_err(dev, \"Can't register NXP QDMA engine.\\n\");\n\t\tgoto err_dpaa2_qdma;\n\t}\n\n\treturn 0;\n\nerr_dpaa2_qdma:\n\tkfree(dpaa2_qdma);\nerr_eng:\n\tdpdmai_disable(priv->mc_io, 0, dpdmai_dev->mc_handle);\nerr_enable:\n\tdpaa2_dpdmai_dpio_unbind(priv);\nerr_bind:\n\tdpaa2_dpmai_store_free(priv);\n\tdpaa2_dpdmai_dpio_free(priv);\nerr_dpio_setup:\n\tkfree(priv->ppriv);\n\tdpdmai_close(priv->mc_io, 0, dpdmai_dev->mc_handle);\nerr_dpdmai_setup:\n\tfsl_mc_portal_free(priv->mc_io);\nerr_mcportal:\n\tkfree(priv);\n\tdev_set_drvdata(dev, NULL);\n\treturn err;\n}\n\nstatic void dpaa2_qdma_remove(struct fsl_mc_device *ls_dev)\n{\n\tstruct dpaa2_qdma_engine *dpaa2_qdma;\n\tstruct dpaa2_qdma_priv *priv;\n\tstruct device *dev;\n\n\tdev = &ls_dev->dev;\n\tpriv = dev_get_drvdata(dev);\n\tdpaa2_qdma = priv->dpaa2_qdma;\n\n\tdpdmai_disable(priv->mc_io, 0, ls_dev->mc_handle);\n\tdpaa2_dpdmai_dpio_unbind(priv);\n\tdpaa2_dpmai_store_free(priv);\n\tdpaa2_dpdmai_dpio_free(priv);\n\tdpdmai_close(priv->mc_io, 0, ls_dev->mc_handle);\n\tfsl_mc_portal_free(priv->mc_io);\n\tdev_set_drvdata(dev, NULL);\n\tdpaa2_dpdmai_free_channels(dpaa2_qdma);\n\n\tdma_async_device_unregister(&dpaa2_qdma->dma_dev);\n\tkfree(priv);\n\tkfree(dpaa2_qdma);\n}\n\nstatic void dpaa2_qdma_shutdown(struct fsl_mc_device *ls_dev)\n{\n\tstruct dpaa2_qdma_priv *priv;\n\tstruct device *dev;\n\n\tdev = &ls_dev->dev;\n\tpriv = dev_get_drvdata(dev);\n\n\tdpdmai_disable(priv->mc_io, 0, ls_dev->mc_handle);\n\tdpaa2_dpdmai_dpio_unbind(priv);\n\tdpdmai_close(priv->mc_io, 0, ls_dev->mc_handle);\n\tdpdmai_destroy(priv->mc_io, 0, ls_dev->mc_handle);\n}\n\nstatic const struct fsl_mc_device_id dpaa2_qdma_id_table[] = {\n\t{\n\t\t.vendor = FSL_MC_VENDOR_FREESCALE,\n\t\t.obj_type = \"dpdmai\",\n\t},\n\t{ .vendor = 0x0 }\n};\n\nstatic struct fsl_mc_driver dpaa2_qdma_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dpaa2-qdma\",\n\t\t.owner  = THIS_MODULE,\n\t},\n\t.probe          = dpaa2_qdma_probe,\n\t.remove\t\t= dpaa2_qdma_remove,\n\t.shutdown\t= dpaa2_qdma_shutdown,\n\t.match_id_table\t= dpaa2_qdma_id_table\n};\n\nstatic int __init dpaa2_qdma_driver_init(void)\n{\n\treturn fsl_mc_driver_register(&(dpaa2_qdma_driver));\n}\nlate_initcall(dpaa2_qdma_driver_init);\n\nstatic void __exit fsl_qdma_exit(void)\n{\n\tfsl_mc_driver_unregister(&(dpaa2_qdma_driver));\n}\nmodule_exit(fsl_qdma_exit);\n\nMODULE_ALIAS(\"platform:fsl-dpaa2-qdma\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"NXP Layerscape DPAA2 qDMA engine driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}