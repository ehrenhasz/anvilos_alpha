{
  "module_name": "fsl-edma-main.c",
  "hash_id": "89ae776e2d14f966479fdffc5599e179a3c4e55029b71117e5279d7c1a450351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/fsl-edma-main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_dma.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n\n#include \"fsl-edma-common.h\"\n\n#define ARGS_RX                         BIT(0)\n#define ARGS_REMOTE                     BIT(1)\n#define ARGS_MULTI_FIFO                 BIT(2)\n\nstatic void fsl_edma_synchronize(struct dma_chan *chan)\n{\n\tstruct fsl_edma_chan *fsl_chan = to_fsl_edma_chan(chan);\n\n\tvchan_synchronize(&fsl_chan->vchan);\n}\n\nstatic irqreturn_t fsl_edma_tx_handler(int irq, void *dev_id)\n{\n\tstruct fsl_edma_engine *fsl_edma = dev_id;\n\tunsigned int intr, ch;\n\tstruct edma_regs *regs = &fsl_edma->regs;\n\n\tintr = edma_readl(fsl_edma, regs->intl);\n\tif (!intr)\n\t\treturn IRQ_NONE;\n\n\tfor (ch = 0; ch < fsl_edma->n_chans; ch++) {\n\t\tif (intr & (0x1 << ch)) {\n\t\t\tedma_writeb(fsl_edma, EDMA_CINT_CINT(ch), regs->cint);\n\t\t\tfsl_edma_tx_chan_handler(&fsl_edma->chans[ch]);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fsl_edma3_tx_handler(int irq, void *dev_id)\n{\n\tstruct fsl_edma_chan *fsl_chan = dev_id;\n\tunsigned int intr;\n\n\tintr = edma_readl_chreg(fsl_chan, ch_int);\n\tif (!intr)\n\t\treturn IRQ_HANDLED;\n\n\tedma_writel_chreg(fsl_chan, 1, ch_int);\n\n\tfsl_edma_tx_chan_handler(fsl_chan);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fsl_edma_err_handler(int irq, void *dev_id)\n{\n\tstruct fsl_edma_engine *fsl_edma = dev_id;\n\tunsigned int err, ch;\n\tstruct edma_regs *regs = &fsl_edma->regs;\n\n\terr = edma_readl(fsl_edma, regs->errl);\n\tif (!err)\n\t\treturn IRQ_NONE;\n\n\tfor (ch = 0; ch < fsl_edma->n_chans; ch++) {\n\t\tif (err & (0x1 << ch)) {\n\t\t\tfsl_edma_disable_request(&fsl_edma->chans[ch]);\n\t\t\tedma_writeb(fsl_edma, EDMA_CERR_CERR(ch), regs->cerr);\n\t\t\tfsl_edma_err_chan_handler(&fsl_edma->chans[ch]);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t fsl_edma_irq_handler(int irq, void *dev_id)\n{\n\tif (fsl_edma_tx_handler(irq, dev_id) == IRQ_HANDLED)\n\t\treturn IRQ_HANDLED;\n\n\treturn fsl_edma_err_handler(irq, dev_id);\n}\n\nstatic struct dma_chan *fsl_edma_xlate(struct of_phandle_args *dma_spec,\n\t\tstruct of_dma *ofdma)\n{\n\tstruct fsl_edma_engine *fsl_edma = ofdma->of_dma_data;\n\tstruct dma_chan *chan, *_chan;\n\tstruct fsl_edma_chan *fsl_chan;\n\tu32 dmamux_nr = fsl_edma->drvdata->dmamuxs;\n\tunsigned long chans_per_mux = fsl_edma->n_chans / dmamux_nr;\n\n\tif (dma_spec->args_count != 2)\n\t\treturn NULL;\n\n\tmutex_lock(&fsl_edma->fsl_edma_mutex);\n\tlist_for_each_entry_safe(chan, _chan, &fsl_edma->dma_dev.channels, device_node) {\n\t\tif (chan->client_count)\n\t\t\tcontinue;\n\t\tif ((chan->chan_id / chans_per_mux) == dma_spec->args[0]) {\n\t\t\tchan = dma_get_slave_channel(chan);\n\t\t\tif (chan) {\n\t\t\t\tchan->device->privatecnt++;\n\t\t\t\tfsl_chan = to_fsl_edma_chan(chan);\n\t\t\t\tfsl_chan->slave_id = dma_spec->args[1];\n\t\t\t\tfsl_edma_chan_mux(fsl_chan, fsl_chan->slave_id,\n\t\t\t\t\t\ttrue);\n\t\t\t\tmutex_unlock(&fsl_edma->fsl_edma_mutex);\n\t\t\t\treturn chan;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&fsl_edma->fsl_edma_mutex);\n\treturn NULL;\n}\n\nstatic struct dma_chan *fsl_edma3_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tstruct fsl_edma_engine *fsl_edma = ofdma->of_dma_data;\n\tstruct dma_chan *chan, *_chan;\n\tstruct fsl_edma_chan *fsl_chan;\n\tbool b_chmux;\n\tint i;\n\n\tif (dma_spec->args_count != 3)\n\t\treturn NULL;\n\n\tb_chmux = !!(fsl_edma->drvdata->flags & FSL_EDMA_DRV_HAS_CHMUX);\n\n\tmutex_lock(&fsl_edma->fsl_edma_mutex);\n\tlist_for_each_entry_safe(chan, _chan, &fsl_edma->dma_dev.channels,\n\t\t\t\t\tdevice_node) {\n\n\t\tif (chan->client_count)\n\t\t\tcontinue;\n\n\t\tfsl_chan = to_fsl_edma_chan(chan);\n\t\ti = fsl_chan - fsl_edma->chans;\n\n\t\tfsl_chan->priority = dma_spec->args[1];\n\t\tfsl_chan->is_rxchan = dma_spec->args[2] & ARGS_RX;\n\t\tfsl_chan->is_remote = dma_spec->args[2] & ARGS_REMOTE;\n\t\tfsl_chan->is_multi_fifo = dma_spec->args[2] & ARGS_MULTI_FIFO;\n\n\t\tif (!b_chmux && i == dma_spec->args[0]) {\n\t\t\tchan = dma_get_slave_channel(chan);\n\t\t\tchan->device->privatecnt++;\n\t\t\tmutex_unlock(&fsl_edma->fsl_edma_mutex);\n\t\t\treturn chan;\n\t\t} else if (b_chmux && !fsl_chan->srcid) {\n\t\t\t \n\t\t\tchan = dma_get_slave_channel(chan);\n\t\t\tchan->device->privatecnt++;\n\t\t\tfsl_chan->srcid = dma_spec->args[0];\n\t\t\tmutex_unlock(&fsl_edma->fsl_edma_mutex);\n\t\t\treturn chan;\n\t\t}\n\t}\n\tmutex_unlock(&fsl_edma->fsl_edma_mutex);\n\treturn NULL;\n}\n\nstatic int\nfsl_edma_irq_init(struct platform_device *pdev, struct fsl_edma_engine *fsl_edma)\n{\n\tint ret;\n\n\tedma_writel(fsl_edma, ~0, fsl_edma->regs.intl);\n\n\tfsl_edma->txirq = platform_get_irq_byname(pdev, \"edma-tx\");\n\tif (fsl_edma->txirq < 0)\n\t\treturn fsl_edma->txirq;\n\n\tfsl_edma->errirq = platform_get_irq_byname(pdev, \"edma-err\");\n\tif (fsl_edma->errirq < 0)\n\t\treturn fsl_edma->errirq;\n\n\tif (fsl_edma->txirq == fsl_edma->errirq) {\n\t\tret = devm_request_irq(&pdev->dev, fsl_edma->txirq,\n\t\t\t\tfsl_edma_irq_handler, 0, \"eDMA\", fsl_edma);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't register eDMA IRQ.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, fsl_edma->txirq,\n\t\t\t\tfsl_edma_tx_handler, 0, \"eDMA tx\", fsl_edma);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't register eDMA tx IRQ.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, fsl_edma->errirq,\n\t\t\t\tfsl_edma_err_handler, 0, \"eDMA err\", fsl_edma);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't register eDMA err IRQ.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_edma3_irq_init(struct platform_device *pdev, struct fsl_edma_engine *fsl_edma)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < fsl_edma->n_chans; i++) {\n\n\t\tstruct fsl_edma_chan *fsl_chan = &fsl_edma->chans[i];\n\n\t\tif (fsl_edma->chan_masked & BIT(i))\n\t\t\tcontinue;\n\n\t\t \n\t\tfsl_chan->txirq = platform_get_irq(pdev, i);\n\t\tif (fsl_chan->txirq < 0) {\n\t\t\tdev_err(&pdev->dev, \"Can't get chan %d's irq.\\n\", i);\n\t\t\treturn  -EINVAL;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, fsl_chan->txirq,\n\t\t\tfsl_edma3_tx_handler, IRQF_SHARED,\n\t\t\tfsl_chan->chan_name, fsl_chan);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't register chan%d's IRQ.\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfsl_edma2_irq_init(struct platform_device *pdev,\n\t\t   struct fsl_edma_engine *fsl_edma)\n{\n\tint i, ret, irq;\n\tint count;\n\n\tedma_writel(fsl_edma, ~0, fsl_edma->regs.intl);\n\n\tcount = platform_irq_count(pdev);\n\tdev_dbg(&pdev->dev, \"%s Found %d interrupts\\r\\n\", __func__, count);\n\tif (count <= 2) {\n\t\tdev_err(&pdev->dev, \"Interrupts in DTS not correct.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0)\n\t\t\treturn -ENXIO;\n\n\t\t \n\t\tif (i == count - 1)\n\t\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t\t\tfsl_edma_err_handler,\n\t\t\t\t\t\t0, \"eDMA2-ERR\", fsl_edma);\n\t\telse\n\t\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t\t\tfsl_edma_tx_handler, 0,\n\t\t\t\t\t\tfsl_edma->chans[i].chan_name,\n\t\t\t\t\t\tfsl_edma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_edma_irq_exit(\n\t\tstruct platform_device *pdev, struct fsl_edma_engine *fsl_edma)\n{\n\tif (fsl_edma->txirq == fsl_edma->errirq) {\n\t\tdevm_free_irq(&pdev->dev, fsl_edma->txirq, fsl_edma);\n\t} else {\n\t\tdevm_free_irq(&pdev->dev, fsl_edma->txirq, fsl_edma);\n\t\tdevm_free_irq(&pdev->dev, fsl_edma->errirq, fsl_edma);\n\t}\n}\n\nstatic void fsl_disable_clocks(struct fsl_edma_engine *fsl_edma, int nr_clocks)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_clocks; i++)\n\t\tclk_disable_unprepare(fsl_edma->muxclk[i]);\n}\n\nstatic struct fsl_edma_drvdata vf610_data = {\n\t.dmamuxs = DMAMUX_NR,\n\t.flags = FSL_EDMA_DRV_WRAP_IO,\n\t.chreg_off = EDMA_TCD,\n\t.chreg_space_sz = sizeof(struct fsl_edma_hw_tcd),\n\t.setup_irq = fsl_edma_irq_init,\n};\n\nstatic struct fsl_edma_drvdata ls1028a_data = {\n\t.dmamuxs = DMAMUX_NR,\n\t.flags = FSL_EDMA_DRV_MUX_SWAP | FSL_EDMA_DRV_WRAP_IO,\n\t.chreg_off = EDMA_TCD,\n\t.chreg_space_sz = sizeof(struct fsl_edma_hw_tcd),\n\t.setup_irq = fsl_edma_irq_init,\n};\n\nstatic struct fsl_edma_drvdata imx7ulp_data = {\n\t.dmamuxs = 1,\n\t.chreg_off = EDMA_TCD,\n\t.chreg_space_sz = sizeof(struct fsl_edma_hw_tcd),\n\t.flags = FSL_EDMA_DRV_HAS_DMACLK | FSL_EDMA_DRV_CONFIG32,\n\t.setup_irq = fsl_edma2_irq_init,\n};\n\nstatic struct fsl_edma_drvdata imx8qm_data = {\n\t.flags = FSL_EDMA_DRV_HAS_PD | FSL_EDMA_DRV_EDMA3,\n\t.chreg_space_sz = 0x10000,\n\t.chreg_off = 0x10000,\n\t.setup_irq = fsl_edma3_irq_init,\n};\n\nstatic struct fsl_edma_drvdata imx8qm_audio_data = {\n\t.flags = FSL_EDMA_DRV_QUIRK_SWAPPED | FSL_EDMA_DRV_HAS_PD | FSL_EDMA_DRV_EDMA3,\n\t.chreg_space_sz = 0x10000,\n\t.chreg_off = 0x10000,\n\t.setup_irq = fsl_edma3_irq_init,\n};\n\nstatic struct fsl_edma_drvdata imx93_data3 = {\n\t.flags = FSL_EDMA_DRV_HAS_DMACLK | FSL_EDMA_DRV_EDMA3,\n\t.chreg_space_sz = 0x10000,\n\t.chreg_off = 0x10000,\n\t.setup_irq = fsl_edma3_irq_init,\n};\n\nstatic struct fsl_edma_drvdata imx93_data4 = {\n\t.flags = FSL_EDMA_DRV_HAS_CHMUX | FSL_EDMA_DRV_HAS_DMACLK | FSL_EDMA_DRV_EDMA4,\n\t.chreg_space_sz = 0x8000,\n\t.chreg_off = 0x10000,\n\t.setup_irq = fsl_edma3_irq_init,\n};\n\nstatic const struct of_device_id fsl_edma_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-edma\", .data = &vf610_data},\n\t{ .compatible = \"fsl,ls1028a-edma\", .data = &ls1028a_data},\n\t{ .compatible = \"fsl,imx7ulp-edma\", .data = &imx7ulp_data},\n\t{ .compatible = \"fsl,imx8qm-edma\", .data = &imx8qm_data},\n\t{ .compatible = \"fsl,imx8qm-adma\", .data = &imx8qm_audio_data},\n\t{ .compatible = \"fsl,imx93-edma3\", .data = &imx93_data3},\n\t{ .compatible = \"fsl,imx93-edma4\", .data = &imx93_data4},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_edma_dt_ids);\n\nstatic int fsl_edma3_attach_pd(struct platform_device *pdev, struct fsl_edma_engine *fsl_edma)\n{\n\tstruct fsl_edma_chan *fsl_chan;\n\tstruct device_link *link;\n\tstruct device *pd_chan;\n\tstruct device *dev;\n\tint i;\n\n\tdev = &pdev->dev;\n\n\tfor (i = 0; i < fsl_edma->n_chans; i++) {\n\t\tif (fsl_edma->chan_masked & BIT(i))\n\t\t\tcontinue;\n\n\t\tfsl_chan = &fsl_edma->chans[i];\n\n\t\tpd_chan = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR_OR_NULL(pd_chan)) {\n\t\t\tdev_err(dev, \"Failed attach pd %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlink = device_link_add(dev, pd_chan, DL_FLAG_STATELESS |\n\t\t\t\t\t     DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t     DL_FLAG_RPM_ACTIVE);\n\t\tif (!link) {\n\t\t\tdev_err(dev, \"Failed to add device_link to %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfsl_chan->pd_dev = pd_chan;\n\n\t\tpm_runtime_use_autosuspend(fsl_chan->pd_dev);\n\t\tpm_runtime_set_autosuspend_delay(fsl_chan->pd_dev, 200);\n\t\tpm_runtime_set_active(fsl_chan->pd_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_edma_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(fsl_edma_dt_ids, &pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_edma_engine *fsl_edma;\n\tconst struct fsl_edma_drvdata *drvdata = NULL;\n\tu32 chan_mask[2] = {0, 0};\n\tstruct edma_regs *regs;\n\tint chans;\n\tint ret, i;\n\n\tif (of_id)\n\t\tdrvdata = of_id->data;\n\tif (!drvdata) {\n\t\tdev_err(&pdev->dev, \"unable to find driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(np, \"dma-channels\", &chans);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't get dma-channels.\\n\");\n\t\treturn ret;\n\t}\n\n\tfsl_edma = devm_kzalloc(&pdev->dev, struct_size(fsl_edma, chans, chans),\n\t\t\t\tGFP_KERNEL);\n\tif (!fsl_edma)\n\t\treturn -ENOMEM;\n\n\tfsl_edma->drvdata = drvdata;\n\tfsl_edma->n_chans = chans;\n\tmutex_init(&fsl_edma->fsl_edma_mutex);\n\n\tfsl_edma->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fsl_edma->membase))\n\t\treturn PTR_ERR(fsl_edma->membase);\n\n\tif (!(drvdata->flags & FSL_EDMA_DRV_SPLIT_REG)) {\n\t\tfsl_edma_setup_regs(fsl_edma);\n\t\tregs = &fsl_edma->regs;\n\t}\n\n\tif (drvdata->flags & FSL_EDMA_DRV_HAS_DMACLK) {\n\t\tfsl_edma->dmaclk = devm_clk_get_enabled(&pdev->dev, \"dma\");\n\t\tif (IS_ERR(fsl_edma->dmaclk)) {\n\t\t\tdev_err(&pdev->dev, \"Missing DMA block clock.\\n\");\n\t\t\treturn PTR_ERR(fsl_edma->dmaclk);\n\t\t}\n\t}\n\n\tif (drvdata->flags & FSL_EDMA_DRV_HAS_CHCLK) {\n\t\tfsl_edma->chclk = devm_clk_get_enabled(&pdev->dev, \"mp\");\n\t\tif (IS_ERR(fsl_edma->chclk)) {\n\t\t\tdev_err(&pdev->dev, \"Missing MP block clock.\\n\");\n\t\t\treturn PTR_ERR(fsl_edma->chclk);\n\t\t}\n\t}\n\n\tret = of_property_read_variable_u32_array(np, \"dma-channel-mask\", chan_mask, 1, 2);\n\n\tif (ret > 0) {\n\t\tfsl_edma->chan_masked = chan_mask[1];\n\t\tfsl_edma->chan_masked <<= 32;\n\t\tfsl_edma->chan_masked |= chan_mask[0];\n\t}\n\n\tfor (i = 0; i < fsl_edma->drvdata->dmamuxs; i++) {\n\t\tchar clkname[32];\n\n\t\t \n\t\tif (drvdata->flags & FSL_EDMA_DRV_SPLIT_REG)\n\t\t\tbreak;\n\n\t\tfsl_edma->muxbase[i] = devm_platform_ioremap_resource(pdev,\n\t\t\t\t\t\t\t\t      1 + i);\n\t\tif (IS_ERR(fsl_edma->muxbase[i])) {\n\t\t\t \n\t\t\tfsl_disable_clocks(fsl_edma, i);\n\t\t\treturn PTR_ERR(fsl_edma->muxbase[i]);\n\t\t}\n\n\t\tsprintf(clkname, \"dmamux%d\", i);\n\t\tfsl_edma->muxclk[i] = devm_clk_get_enabled(&pdev->dev, clkname);\n\t\tif (IS_ERR(fsl_edma->muxclk[i])) {\n\t\t\tdev_err(&pdev->dev, \"Missing DMAMUX block clock.\\n\");\n\t\t\t \n\t\t\treturn PTR_ERR(fsl_edma->muxclk[i]);\n\t\t}\n\t}\n\n\tfsl_edma->big_endian = of_property_read_bool(np, \"big-endian\");\n\n\tif (drvdata->flags & FSL_EDMA_DRV_HAS_PD) {\n\t\tret = fsl_edma3_attach_pd(pdev, fsl_edma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&fsl_edma->dma_dev.channels);\n\tfor (i = 0; i < fsl_edma->n_chans; i++) {\n\t\tstruct fsl_edma_chan *fsl_chan = &fsl_edma->chans[i];\n\t\tint len;\n\n\t\tif (fsl_edma->chan_masked & BIT(i))\n\t\t\tcontinue;\n\n\t\tsnprintf(fsl_chan->chan_name, sizeof(fsl_chan->chan_name), \"%s-CH%02d\",\n\t\t\t\t\t\t\t   dev_name(&pdev->dev), i);\n\n\t\tfsl_chan->edma = fsl_edma;\n\t\tfsl_chan->pm_state = RUNNING;\n\t\tfsl_chan->slave_id = 0;\n\t\tfsl_chan->idle = true;\n\t\tfsl_chan->dma_dir = DMA_NONE;\n\t\tfsl_chan->vchan.desc_free = fsl_edma_free_desc;\n\n\t\tlen = (drvdata->flags & FSL_EDMA_DRV_SPLIT_REG) ?\n\t\t\t\toffsetof(struct fsl_edma3_ch_reg, tcd) : 0;\n\t\tfsl_chan->tcd = fsl_edma->membase\n\t\t\t\t+ i * drvdata->chreg_space_sz + drvdata->chreg_off + len;\n\n\t\tfsl_chan->pdev = pdev;\n\t\tvchan_init(&fsl_chan->vchan, &fsl_edma->dma_dev);\n\n\t\tedma_write_tcdreg(fsl_chan, 0, csr);\n\t\tfsl_edma_chan_mux(fsl_chan, 0, false);\n\t}\n\n\tret = fsl_edma->drvdata->setup_irq(pdev, fsl_edma);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_cap_set(DMA_PRIVATE, fsl_edma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_SLAVE, fsl_edma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, fsl_edma->dma_dev.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, fsl_edma->dma_dev.cap_mask);\n\n\tfsl_edma->dma_dev.dev = &pdev->dev;\n\tfsl_edma->dma_dev.device_alloc_chan_resources\n\t\t= fsl_edma_alloc_chan_resources;\n\tfsl_edma->dma_dev.device_free_chan_resources\n\t\t= fsl_edma_free_chan_resources;\n\tfsl_edma->dma_dev.device_tx_status = fsl_edma_tx_status;\n\tfsl_edma->dma_dev.device_prep_slave_sg = fsl_edma_prep_slave_sg;\n\tfsl_edma->dma_dev.device_prep_dma_cyclic = fsl_edma_prep_dma_cyclic;\n\tfsl_edma->dma_dev.device_prep_dma_memcpy = fsl_edma_prep_memcpy;\n\tfsl_edma->dma_dev.device_config = fsl_edma_slave_config;\n\tfsl_edma->dma_dev.device_pause = fsl_edma_pause;\n\tfsl_edma->dma_dev.device_resume = fsl_edma_resume;\n\tfsl_edma->dma_dev.device_terminate_all = fsl_edma_terminate_all;\n\tfsl_edma->dma_dev.device_synchronize = fsl_edma_synchronize;\n\tfsl_edma->dma_dev.device_issue_pending = fsl_edma_issue_pending;\n\n\tfsl_edma->dma_dev.src_addr_widths = FSL_EDMA_BUSWIDTHS;\n\tfsl_edma->dma_dev.dst_addr_widths = FSL_EDMA_BUSWIDTHS;\n\n\tif (drvdata->flags & FSL_EDMA_DRV_BUS_8BYTE) {\n\t\tfsl_edma->dma_dev.src_addr_widths |= BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);\n\t\tfsl_edma->dma_dev.dst_addr_widths |= BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);\n\t}\n\n\tfsl_edma->dma_dev.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tif (drvdata->flags & FSL_EDMA_DRV_DEV_TO_DEV)\n\t\tfsl_edma->dma_dev.directions |= BIT(DMA_DEV_TO_DEV);\n\n\tfsl_edma->dma_dev.copy_align = drvdata->flags & FSL_EDMA_DRV_ALIGN_64BYTE ?\n\t\t\t\t\tDMAENGINE_ALIGN_64_BYTES :\n\t\t\t\t\tDMAENGINE_ALIGN_32_BYTES;\n\n\t \n\tdma_set_max_seg_size(fsl_edma->dma_dev.dev, 0x3fff);\n\n\tfsl_edma->dma_dev.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;\n\n\tplatform_set_drvdata(pdev, fsl_edma);\n\n\tret = dma_async_device_register(&fsl_edma->dma_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't register Freescale eDMA engine. (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_dma_controller_register(np,\n\t\t\tdrvdata->flags & FSL_EDMA_DRV_SPLIT_REG ? fsl_edma3_xlate : fsl_edma_xlate,\n\t\t\tfsl_edma);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't register Freescale eDMA of_dma. (%d)\\n\", ret);\n\t\tdma_async_device_unregister(&fsl_edma->dma_dev);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(drvdata->flags & FSL_EDMA_DRV_SPLIT_REG))\n\t\tedma_writel(fsl_edma, EDMA_CR_ERGA | EDMA_CR_ERCA, regs->cr);\n\n\treturn 0;\n}\n\nstatic int fsl_edma_remove(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_edma_engine *fsl_edma = platform_get_drvdata(pdev);\n\n\tfsl_edma_irq_exit(pdev, fsl_edma);\n\tfsl_edma_cleanup_vchan(&fsl_edma->dma_dev);\n\tof_dma_controller_free(np);\n\tdma_async_device_unregister(&fsl_edma->dma_dev);\n\tfsl_disable_clocks(fsl_edma, fsl_edma->drvdata->dmamuxs);\n\n\treturn 0;\n}\n\nstatic int fsl_edma_suspend_late(struct device *dev)\n{\n\tstruct fsl_edma_engine *fsl_edma = dev_get_drvdata(dev);\n\tstruct fsl_edma_chan *fsl_chan;\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < fsl_edma->n_chans; i++) {\n\t\tfsl_chan = &fsl_edma->chans[i];\n\t\tif (fsl_edma->chan_masked & BIT(i))\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&fsl_chan->vchan.lock, flags);\n\t\t \n\t\tif (unlikely(!fsl_chan->idle)) {\n\t\t\tdev_warn(dev, \"WARN: There is non-idle channel.\");\n\t\t\tfsl_edma_disable_request(fsl_chan);\n\t\t\tfsl_edma_chan_mux(fsl_chan, 0, false);\n\t\t}\n\n\t\tfsl_chan->pm_state = SUSPENDED;\n\t\tspin_unlock_irqrestore(&fsl_chan->vchan.lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_edma_resume_early(struct device *dev)\n{\n\tstruct fsl_edma_engine *fsl_edma = dev_get_drvdata(dev);\n\tstruct fsl_edma_chan *fsl_chan;\n\tstruct edma_regs *regs = &fsl_edma->regs;\n\tint i;\n\n\tfor (i = 0; i < fsl_edma->n_chans; i++) {\n\t\tfsl_chan = &fsl_edma->chans[i];\n\t\tif (fsl_edma->chan_masked & BIT(i))\n\t\t\tcontinue;\n\t\tfsl_chan->pm_state = RUNNING;\n\t\tedma_write_tcdreg(fsl_chan, 0, csr);\n\t\tif (fsl_chan->slave_id != 0)\n\t\t\tfsl_edma_chan_mux(fsl_chan, fsl_chan->slave_id, true);\n\t}\n\n\tif (!(fsl_edma->drvdata->flags & FSL_EDMA_DRV_SPLIT_REG))\n\t\tedma_writel(fsl_edma, EDMA_CR_ERGA | EDMA_CR_ERCA, regs->cr);\n\n\treturn 0;\n}\n\n \nstatic const struct dev_pm_ops fsl_edma_pm_ops = {\n\t.suspend_late   = fsl_edma_suspend_late,\n\t.resume_early   = fsl_edma_resume_early,\n};\n\nstatic struct platform_driver fsl_edma_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"fsl-edma\",\n\t\t.of_match_table = fsl_edma_dt_ids,\n\t\t.pm     = &fsl_edma_pm_ops,\n\t},\n\t.probe          = fsl_edma_probe,\n\t.remove\t\t= fsl_edma_remove,\n};\n\nstatic int __init fsl_edma_init(void)\n{\n\treturn platform_driver_register(&fsl_edma_driver);\n}\nsubsys_initcall(fsl_edma_init);\n\nstatic void __exit fsl_edma_exit(void)\n{\n\tplatform_driver_unregister(&fsl_edma_driver);\n}\nmodule_exit(fsl_edma_exit);\n\nMODULE_ALIAS(\"platform:fsl-edma\");\nMODULE_DESCRIPTION(\"Freescale eDMA engine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}