{
  "module_name": "bcm2835-dma.c",
  "hash_id": "9367245d9a6714088337b3b5cd6342824c559262e4e8c44fc3c16cb1cafcc4ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/bcm2835-dma.c",
  "human_readable_source": "\n \n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n\n#include \"virt-dma.h\"\n\n#define BCM2835_DMA_MAX_DMA_CHAN_SUPPORTED 14\n#define BCM2835_DMA_CHAN_NAME_SIZE 8\n\n \nstruct bcm2835_dmadev {\n\tstruct dma_device ddev;\n\tvoid __iomem *base;\n\tdma_addr_t zero_page;\n};\n\nstruct bcm2835_dma_cb {\n\tuint32_t info;\n\tuint32_t src;\n\tuint32_t dst;\n\tuint32_t length;\n\tuint32_t stride;\n\tuint32_t next;\n\tuint32_t pad[2];\n};\n\nstruct bcm2835_cb_entry {\n\tstruct bcm2835_dma_cb *cb;\n\tdma_addr_t paddr;\n};\n\nstruct bcm2835_chan {\n\tstruct virt_dma_chan vc;\n\n\tstruct dma_slave_config\tcfg;\n\tunsigned int dreq;\n\n\tint ch;\n\tstruct bcm2835_desc *desc;\n\tstruct dma_pool *cb_pool;\n\n\tvoid __iomem *chan_base;\n\tint irq_number;\n\tunsigned int irq_flags;\n\n\tbool is_lite_channel;\n};\n\nstruct bcm2835_desc {\n\tstruct bcm2835_chan *c;\n\tstruct virt_dma_desc vd;\n\tenum dma_transfer_direction dir;\n\n\tunsigned int frames;\n\tsize_t size;\n\n\tbool cyclic;\n\n\tstruct bcm2835_cb_entry cb_list[];\n};\n\n#define BCM2835_DMA_CS\t\t0x00\n#define BCM2835_DMA_ADDR\t0x04\n#define BCM2835_DMA_TI\t\t0x08\n#define BCM2835_DMA_SOURCE_AD\t0x0c\n#define BCM2835_DMA_DEST_AD\t0x10\n#define BCM2835_DMA_LEN\t\t0x14\n#define BCM2835_DMA_STRIDE\t0x18\n#define BCM2835_DMA_NEXTCB\t0x1c\n#define BCM2835_DMA_DEBUG\t0x20\n\n \n#define BCM2835_DMA_ACTIVE\tBIT(0)   \n#define BCM2835_DMA_END\t\tBIT(1)   \n#define BCM2835_DMA_INT\t\tBIT(2)   \n#define BCM2835_DMA_DREQ\tBIT(3)   \n#define BCM2835_DMA_ISPAUSED\tBIT(4)   \n#define BCM2835_DMA_ISHELD\tBIT(5)   \n#define BCM2835_DMA_WAITING_FOR_WRITES BIT(6)  \n#define BCM2835_DMA_ERR\t\tBIT(8)\n#define BCM2835_DMA_PRIORITY(x) ((x & 15) << 16)  \n#define BCM2835_DMA_PANIC_PRIORITY(x) ((x & 15) << 20)  \n \n#define BCM2835_DMA_WAIT_FOR_WRITES BIT(28)\n#define BCM2835_DMA_DIS_DEBUG\tBIT(29)  \n#define BCM2835_DMA_ABORT\tBIT(30)  \n#define BCM2835_DMA_RESET\tBIT(31)  \n\n \n#define BCM2835_DMA_INT_EN\tBIT(0)\n#define BCM2835_DMA_TDMODE\tBIT(1)  \n#define BCM2835_DMA_WAIT_RESP\tBIT(3)  \n#define BCM2835_DMA_D_INC\tBIT(4)\n#define BCM2835_DMA_D_WIDTH\tBIT(5)  \n#define BCM2835_DMA_D_DREQ\tBIT(6)  \n#define BCM2835_DMA_D_IGNORE\tBIT(7)  \n#define BCM2835_DMA_S_INC\tBIT(8)\n#define BCM2835_DMA_S_WIDTH\tBIT(9)  \n#define BCM2835_DMA_S_DREQ\tBIT(10)  \n#define BCM2835_DMA_S_IGNORE\tBIT(11)  \n#define BCM2835_DMA_BURST_LENGTH(x) ((x & 15) << 12)\n#define BCM2835_DMA_PER_MAP(x)\t((x & 31) << 16)  \n#define BCM2835_DMA_WAIT(x)\t((x & 31) << 21)  \n#define BCM2835_DMA_NO_WIDE_BURSTS BIT(26)  \n\n \n#define BCM2835_DMA_DEBUG_LAST_NOT_SET_ERR\tBIT(0)\n#define BCM2835_DMA_DEBUG_FIFO_ERR\t\tBIT(1)\n#define BCM2835_DMA_DEBUG_READ_ERR\t\tBIT(2)\n#define BCM2835_DMA_DEBUG_OUTSTANDING_WRITES_SHIFT 4\n#define BCM2835_DMA_DEBUG_OUTSTANDING_WRITES_BITS 4\n#define BCM2835_DMA_DEBUG_ID_SHIFT\t\t16\n#define BCM2835_DMA_DEBUG_ID_BITS\t\t9\n#define BCM2835_DMA_DEBUG_STATE_SHIFT\t\t16\n#define BCM2835_DMA_DEBUG_STATE_BITS\t\t9\n#define BCM2835_DMA_DEBUG_VERSION_SHIFT\t\t25\n#define BCM2835_DMA_DEBUG_VERSION_BITS\t\t3\n#define BCM2835_DMA_DEBUG_LITE\t\t\tBIT(28)\n\n \n#define BCM2835_DMA_INT_STATUS         0xfe0\n#define BCM2835_DMA_ENABLE             0xff0\n\n#define BCM2835_DMA_DATA_TYPE_S8\t1\n#define BCM2835_DMA_DATA_TYPE_S16\t2\n#define BCM2835_DMA_DATA_TYPE_S32\t4\n#define BCM2835_DMA_DATA_TYPE_S128\t16\n\n \n#define BCM2835_DMA_CHAN(n)\t((n) << 8)  \n#define BCM2835_DMA_CHANIO(base, n) ((base) + BCM2835_DMA_CHAN(n))\n\n \n#define MAX_DMA_LEN SZ_1G\n#define MAX_LITE_DMA_LEN (SZ_64K - 4)\n\nstatic inline size_t bcm2835_dma_max_frame_length(struct bcm2835_chan *c)\n{\n\t \n\treturn c->is_lite_channel ? MAX_LITE_DMA_LEN : MAX_DMA_LEN;\n}\n\n \nstatic inline size_t bcm2835_dma_frames_for_length(size_t len,\n\t\t\t\t\t\t   size_t max_len)\n{\n\treturn DIV_ROUND_UP(len, max_len);\n}\n\nstatic inline struct bcm2835_dmadev *to_bcm2835_dma_dev(struct dma_device *d)\n{\n\treturn container_of(d, struct bcm2835_dmadev, ddev);\n}\n\nstatic inline struct bcm2835_chan *to_bcm2835_dma_chan(struct dma_chan *c)\n{\n\treturn container_of(c, struct bcm2835_chan, vc.chan);\n}\n\nstatic inline struct bcm2835_desc *to_bcm2835_dma_desc(\n\t\tstruct dma_async_tx_descriptor *t)\n{\n\treturn container_of(t, struct bcm2835_desc, vd.tx);\n}\n\nstatic void bcm2835_dma_free_cb_chain(struct bcm2835_desc *desc)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < desc->frames; i++)\n\t\tdma_pool_free(desc->c->cb_pool, desc->cb_list[i].cb,\n\t\t\t      desc->cb_list[i].paddr);\n\n\tkfree(desc);\n}\n\nstatic void bcm2835_dma_desc_free(struct virt_dma_desc *vd)\n{\n\tbcm2835_dma_free_cb_chain(\n\t\tcontainer_of(vd, struct bcm2835_desc, vd));\n}\n\nstatic void bcm2835_dma_create_cb_set_length(\n\tstruct bcm2835_chan *chan,\n\tstruct bcm2835_dma_cb *control_block,\n\tsize_t len,\n\tsize_t period_len,\n\tsize_t *total_len,\n\tu32 finalextrainfo)\n{\n\tsize_t max_len = bcm2835_dma_max_frame_length(chan);\n\n\t \n\tcontrol_block->length = min_t(u32, len, max_len);\n\n\t \n\tif (!period_len)\n\t\treturn;\n\n\t \n\n\t \n\tif (*total_len + control_block->length < period_len) {\n\t\t \n\t\t*total_len += control_block->length;\n\t\treturn;\n\t}\n\n\t \n\tcontrol_block->length = period_len - *total_len;\n\n\t \n\t*total_len = 0;\n\n\t \n\tcontrol_block->info |= finalextrainfo;\n}\n\nstatic inline size_t bcm2835_dma_count_frames_for_sg(\n\tstruct bcm2835_chan *c,\n\tstruct scatterlist *sgl,\n\tunsigned int sg_len)\n{\n\tsize_t frames = 0;\n\tstruct scatterlist *sgent;\n\tunsigned int i;\n\tsize_t plength = bcm2835_dma_max_frame_length(c);\n\n\tfor_each_sg(sgl, sgent, sg_len, i)\n\t\tframes += bcm2835_dma_frames_for_length(\n\t\t\tsg_dma_len(sgent), plength);\n\n\treturn frames;\n}\n\n \nstatic struct bcm2835_desc *bcm2835_dma_create_cb_chain(\n\tstruct dma_chan *chan, enum dma_transfer_direction direction,\n\tbool cyclic, u32 info, u32 finalextrainfo, size_t frames,\n\tdma_addr_t src, dma_addr_t dst, size_t buf_len,\n\tsize_t period_len, gfp_t gfp)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tsize_t len = buf_len, total_len;\n\tsize_t frame;\n\tstruct bcm2835_desc *d;\n\tstruct bcm2835_cb_entry *cb_entry;\n\tstruct bcm2835_dma_cb *control_block;\n\n\tif (!frames)\n\t\treturn NULL;\n\n\t \n\td = kzalloc(struct_size(d, cb_list, frames), gfp);\n\tif (!d)\n\t\treturn NULL;\n\n\td->c = c;\n\td->dir = direction;\n\td->cyclic = cyclic;\n\n\t \n\tfor (frame = 0, total_len = 0; frame < frames; d->frames++, frame++) {\n\t\tcb_entry = &d->cb_list[frame];\n\t\tcb_entry->cb = dma_pool_alloc(c->cb_pool, gfp,\n\t\t\t\t\t      &cb_entry->paddr);\n\t\tif (!cb_entry->cb)\n\t\t\tgoto error_cb;\n\n\t\t \n\t\tcontrol_block = cb_entry->cb;\n\t\tcontrol_block->info = info;\n\t\tcontrol_block->src = src;\n\t\tcontrol_block->dst = dst;\n\t\tcontrol_block->stride = 0;\n\t\tcontrol_block->next = 0;\n\t\t \n\t\tif (buf_len) {\n\t\t\t \n\t\t\tbcm2835_dma_create_cb_set_length(\n\t\t\t\tc, control_block,\n\t\t\t\tlen, period_len, &total_len,\n\t\t\t\tcyclic ? finalextrainfo : 0);\n\n\t\t\t \n\t\t\tlen -= control_block->length;\n\t\t}\n\n\t\t \n\t\tif (frame)\n\t\t\td->cb_list[frame - 1].cb->next = cb_entry->paddr;\n\n\t\t \n\t\tif (src && (info & BCM2835_DMA_S_INC))\n\t\t\tsrc += control_block->length;\n\t\tif (dst && (info & BCM2835_DMA_D_INC))\n\t\t\tdst += control_block->length;\n\n\t\t \n\t\td->size += control_block->length;\n\t}\n\n\t \n\td->cb_list[d->frames - 1].cb->info |= finalextrainfo;\n\n\t \n\tif (buf_len && (d->size != buf_len))\n\t\tgoto error_cb;\n\n\treturn d;\nerror_cb:\n\tbcm2835_dma_free_cb_chain(d);\n\n\treturn NULL;\n}\n\nstatic void bcm2835_dma_fill_cb_chain_with_sg(\n\tstruct dma_chan *chan,\n\tenum dma_transfer_direction direction,\n\tstruct bcm2835_cb_entry *cb,\n\tstruct scatterlist *sgl,\n\tunsigned int sg_len)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tsize_t len, max_len;\n\tunsigned int i;\n\tdma_addr_t addr;\n\tstruct scatterlist *sgent;\n\n\tmax_len = bcm2835_dma_max_frame_length(c);\n\tfor_each_sg(sgl, sgent, sg_len, i) {\n\t\tfor (addr = sg_dma_address(sgent), len = sg_dma_len(sgent);\n\t\t     len > 0;\n\t\t     addr += cb->cb->length, len -= cb->cb->length, cb++) {\n\t\t\tif (direction == DMA_DEV_TO_MEM)\n\t\t\t\tcb->cb->dst = addr;\n\t\t\telse\n\t\t\t\tcb->cb->src = addr;\n\t\t\tcb->cb->length = min(len, max_len);\n\t\t}\n\t}\n}\n\nstatic void bcm2835_dma_abort(struct bcm2835_chan *c)\n{\n\tvoid __iomem *chan_base = c->chan_base;\n\tlong int timeout = 10000;\n\n\t \n\tif (!readl(chan_base + BCM2835_DMA_ADDR))\n\t\treturn;\n\n\t \n\twritel(0, chan_base + BCM2835_DMA_CS);\n\n\t \n\twhile ((readl(chan_base + BCM2835_DMA_CS) &\n\t\tBCM2835_DMA_WAITING_FOR_WRITES) && --timeout)\n\t\tcpu_relax();\n\n\t \n\tif (!timeout)\n\t\tdev_err(c->vc.chan.device->dev,\n\t\t\t\"failed to complete outstanding writes\\n\");\n\n\twritel(BCM2835_DMA_RESET, chan_base + BCM2835_DMA_CS);\n}\n\nstatic void bcm2835_dma_start_desc(struct bcm2835_chan *c)\n{\n\tstruct virt_dma_desc *vd = vchan_next_desc(&c->vc);\n\tstruct bcm2835_desc *d;\n\n\tif (!vd) {\n\t\tc->desc = NULL;\n\t\treturn;\n\t}\n\n\tlist_del(&vd->node);\n\n\tc->desc = d = to_bcm2835_dma_desc(&vd->tx);\n\n\twritel(d->cb_list[0].paddr, c->chan_base + BCM2835_DMA_ADDR);\n\twritel(BCM2835_DMA_ACTIVE, c->chan_base + BCM2835_DMA_CS);\n}\n\nstatic irqreturn_t bcm2835_dma_callback(int irq, void *data)\n{\n\tstruct bcm2835_chan *c = data;\n\tstruct bcm2835_desc *d;\n\tunsigned long flags;\n\n\t \n\tif (c->irq_flags & IRQF_SHARED) {\n\t\t \n\t\tflags = readl(c->chan_base + BCM2835_DMA_CS);\n\t\t \n\t\tif (!(flags & BCM2835_DMA_INT))\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock_irqsave(&c->vc.lock, flags);\n\n\t \n\twritel(BCM2835_DMA_INT | BCM2835_DMA_ACTIVE,\n\t       c->chan_base + BCM2835_DMA_CS);\n\n\td = c->desc;\n\n\tif (d) {\n\t\tif (d->cyclic) {\n\t\t\t \n\t\t\tvchan_cyclic_callback(&d->vd);\n\t\t} else if (!readl(c->chan_base + BCM2835_DMA_ADDR)) {\n\t\t\tvchan_cookie_complete(&c->desc->vd);\n\t\t\tbcm2835_dma_start_desc(c);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&c->vc.lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm2835_dma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tstruct device *dev = c->vc.chan.device->dev;\n\n\tdev_dbg(dev, \"Allocating DMA channel %d\\n\", c->ch);\n\n\t \n\tc->cb_pool = dma_pool_create(dev_name(dev), dev,\n\t\t\t\t     sizeof(struct bcm2835_dma_cb), 32, 0);\n\tif (!c->cb_pool) {\n\t\tdev_err(dev, \"unable to allocate descriptor pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn request_irq(c->irq_number, bcm2835_dma_callback,\n\t\t\t   c->irq_flags, \"DMA IRQ\", c);\n}\n\nstatic void bcm2835_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\n\tvchan_free_chan_resources(&c->vc);\n\tfree_irq(c->irq_number, c);\n\tdma_pool_destroy(c->cb_pool);\n\n\tdev_dbg(c->vc.chan.device->dev, \"Freeing DMA channel %u\\n\", c->ch);\n}\n\nstatic size_t bcm2835_dma_desc_size(struct bcm2835_desc *d)\n{\n\treturn d->size;\n}\n\nstatic size_t bcm2835_dma_desc_size_pos(struct bcm2835_desc *d, dma_addr_t addr)\n{\n\tunsigned int i;\n\tsize_t size;\n\n\tfor (size = i = 0; i < d->frames; i++) {\n\t\tstruct bcm2835_dma_cb *control_block = d->cb_list[i].cb;\n\t\tsize_t this_size = control_block->length;\n\t\tdma_addr_t dma;\n\n\t\tif (d->dir == DMA_DEV_TO_MEM)\n\t\t\tdma = control_block->dst;\n\t\telse\n\t\t\tdma = control_block->src;\n\n\t\tif (size)\n\t\t\tsize += this_size;\n\t\telse if (addr >= dma && addr < dma + this_size)\n\t\t\tsize += dma + this_size - addr;\n\t}\n\n\treturn size;\n}\n\nstatic enum dma_status bcm2835_dma_tx_status(struct dma_chan *chan,\n\tdma_cookie_t cookie, struct dma_tx_state *txstate)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tstruct virt_dma_desc *vd;\n\tenum dma_status ret;\n\tunsigned long flags;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret == DMA_COMPLETE || !txstate)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&c->vc.lock, flags);\n\tvd = vchan_find_desc(&c->vc, cookie);\n\tif (vd) {\n\t\ttxstate->residue =\n\t\t\tbcm2835_dma_desc_size(to_bcm2835_dma_desc(&vd->tx));\n\t} else if (c->desc && c->desc->vd.tx.cookie == cookie) {\n\t\tstruct bcm2835_desc *d = c->desc;\n\t\tdma_addr_t pos;\n\n\t\tif (d->dir == DMA_MEM_TO_DEV)\n\t\t\tpos = readl(c->chan_base + BCM2835_DMA_SOURCE_AD);\n\t\telse if (d->dir == DMA_DEV_TO_MEM)\n\t\t\tpos = readl(c->chan_base + BCM2835_DMA_DEST_AD);\n\t\telse\n\t\t\tpos = 0;\n\n\t\ttxstate->residue = bcm2835_dma_desc_size_pos(d, pos);\n\t} else {\n\t\ttxstate->residue = 0;\n\t}\n\n\tspin_unlock_irqrestore(&c->vc.lock, flags);\n\n\treturn ret;\n}\n\nstatic void bcm2835_dma_issue_pending(struct dma_chan *chan)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&c->vc.lock, flags);\n\tif (vchan_issue_pending(&c->vc) && !c->desc)\n\t\tbcm2835_dma_start_desc(c);\n\n\tspin_unlock_irqrestore(&c->vc.lock, flags);\n}\n\nstatic struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_memcpy(\n\tstruct dma_chan *chan, dma_addr_t dst, dma_addr_t src,\n\tsize_t len, unsigned long flags)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tstruct bcm2835_desc *d;\n\tu32 info = BCM2835_DMA_D_INC | BCM2835_DMA_S_INC;\n\tu32 extra = BCM2835_DMA_INT_EN | BCM2835_DMA_WAIT_RESP;\n\tsize_t max_len = bcm2835_dma_max_frame_length(c);\n\tsize_t frames;\n\n\t \n\tif (!src || !dst || !len)\n\t\treturn NULL;\n\n\t \n\tframes = bcm2835_dma_frames_for_length(len, max_len);\n\n\t \n\td = bcm2835_dma_create_cb_chain(chan, DMA_MEM_TO_MEM, false,\n\t\t\t\t\tinfo, extra, frames,\n\t\t\t\t\tsrc, dst, len, 0, GFP_KERNEL);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn vchan_tx_prep(&c->vc, &d->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *bcm2835_dma_prep_slave_sg(\n\tstruct dma_chan *chan,\n\tstruct scatterlist *sgl, unsigned int sg_len,\n\tenum dma_transfer_direction direction,\n\tunsigned long flags, void *context)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tstruct bcm2835_desc *d;\n\tdma_addr_t src = 0, dst = 0;\n\tu32 info = BCM2835_DMA_WAIT_RESP;\n\tu32 extra = BCM2835_DMA_INT_EN;\n\tsize_t frames;\n\n\tif (!is_slave_direction(direction)) {\n\t\tdev_err(chan->device->dev,\n\t\t\t\"%s: bad direction?\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (c->dreq != 0)\n\t\tinfo |= BCM2835_DMA_PER_MAP(c->dreq);\n\n\tif (direction == DMA_DEV_TO_MEM) {\n\t\tif (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)\n\t\t\treturn NULL;\n\t\tsrc = c->cfg.src_addr;\n\t\tinfo |= BCM2835_DMA_S_DREQ | BCM2835_DMA_D_INC;\n\t} else {\n\t\tif (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)\n\t\t\treturn NULL;\n\t\tdst = c->cfg.dst_addr;\n\t\tinfo |= BCM2835_DMA_D_DREQ | BCM2835_DMA_S_INC;\n\t}\n\n\t \n\tframes = bcm2835_dma_count_frames_for_sg(c, sgl, sg_len);\n\n\t \n\td = bcm2835_dma_create_cb_chain(chan, direction, false,\n\t\t\t\t\tinfo, extra,\n\t\t\t\t\tframes, src, dst, 0, 0,\n\t\t\t\t\tGFP_NOWAIT);\n\tif (!d)\n\t\treturn NULL;\n\n\t \n\tbcm2835_dma_fill_cb_chain_with_sg(chan, direction, d->cb_list,\n\t\t\t\t\t  sgl, sg_len);\n\n\treturn vchan_tx_prep(&c->vc, &d->vd, flags);\n}\n\nstatic struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(\n\tstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\n\tsize_t period_len, enum dma_transfer_direction direction,\n\tunsigned long flags)\n{\n\tstruct bcm2835_dmadev *od = to_bcm2835_dma_dev(chan->device);\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tstruct bcm2835_desc *d;\n\tdma_addr_t src, dst;\n\tu32 info = BCM2835_DMA_WAIT_RESP;\n\tu32 extra = 0;\n\tsize_t max_len = bcm2835_dma_max_frame_length(c);\n\tsize_t frames;\n\n\t \n\tif (!is_slave_direction(direction)) {\n\t\tdev_err(chan->device->dev, \"%s: bad direction?\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!buf_len) {\n\t\tdev_err(chan->device->dev,\n\t\t\t\"%s: bad buffer length (= 0)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (flags & DMA_PREP_INTERRUPT)\n\t\textra |= BCM2835_DMA_INT_EN;\n\telse\n\t\tperiod_len = buf_len;\n\n\t \n\tif (buf_len % period_len)\n\t\tdev_warn_once(chan->device->dev,\n\t\t\t      \"%s: buffer_length (%zd) is not a multiple of period_len (%zd)\\n\",\n\t\t\t      __func__, buf_len, period_len);\n\n\t \n\tif (c->dreq != 0)\n\t\tinfo |= BCM2835_DMA_PER_MAP(c->dreq);\n\n\tif (direction == DMA_DEV_TO_MEM) {\n\t\tif (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)\n\t\t\treturn NULL;\n\t\tsrc = c->cfg.src_addr;\n\t\tdst = buf_addr;\n\t\tinfo |= BCM2835_DMA_S_DREQ | BCM2835_DMA_D_INC;\n\t} else {\n\t\tif (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)\n\t\t\treturn NULL;\n\t\tdst = c->cfg.dst_addr;\n\t\tsrc = buf_addr;\n\t\tinfo |= BCM2835_DMA_D_DREQ | BCM2835_DMA_S_INC;\n\n\t\t \n\t\tif (buf_addr == od->zero_page && !c->is_lite_channel)\n\t\t\tinfo |= BCM2835_DMA_S_IGNORE;\n\t}\n\n\t \n\tframes =  \n\t\t DIV_ROUND_UP(buf_len, period_len) *\n\t\t  \n\t\t bcm2835_dma_frames_for_length(period_len, max_len);\n\n\t \n\td = bcm2835_dma_create_cb_chain(chan, direction, true,\n\t\t\t\t\tinfo, extra,\n\t\t\t\t\tframes, src, dst, buf_len,\n\t\t\t\t\tperiod_len, GFP_NOWAIT);\n\tif (!d)\n\t\treturn NULL;\n\n\t \n\td->cb_list[d->frames - 1].cb->next = d->cb_list[0].paddr;\n\n\treturn vchan_tx_prep(&c->vc, &d->vd, flags);\n}\n\nstatic int bcm2835_dma_slave_config(struct dma_chan *chan,\n\t\t\t\t    struct dma_slave_config *cfg)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\n\tc->cfg = *cfg;\n\n\treturn 0;\n}\n\nstatic int bcm2835_dma_terminate_all(struct dma_chan *chan)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&c->vc.lock, flags);\n\n\t \n\tif (c->desc) {\n\t\tvchan_terminate_vdesc(&c->desc->vd);\n\t\tc->desc = NULL;\n\t\tbcm2835_dma_abort(c);\n\t}\n\n\tvchan_get_all_descriptors(&c->vc, &head);\n\tspin_unlock_irqrestore(&c->vc.lock, flags);\n\tvchan_dma_desc_free_list(&c->vc, &head);\n\n\treturn 0;\n}\n\nstatic void bcm2835_dma_synchronize(struct dma_chan *chan)\n{\n\tstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\n\n\tvchan_synchronize(&c->vc);\n}\n\nstatic int bcm2835_dma_chan_init(struct bcm2835_dmadev *d, int chan_id,\n\t\t\t\t int irq, unsigned int irq_flags)\n{\n\tstruct bcm2835_chan *c;\n\n\tc = devm_kzalloc(d->ddev.dev, sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->vc.desc_free = bcm2835_dma_desc_free;\n\tvchan_init(&c->vc, &d->ddev);\n\n\tc->chan_base = BCM2835_DMA_CHANIO(d->base, chan_id);\n\tc->ch = chan_id;\n\tc->irq_number = irq;\n\tc->irq_flags = irq_flags;\n\n\t \n\tif (readl(c->chan_base + BCM2835_DMA_DEBUG) &\n\t\tBCM2835_DMA_DEBUG_LITE)\n\t\tc->is_lite_channel = true;\n\n\treturn 0;\n}\n\nstatic void bcm2835_dma_free(struct bcm2835_dmadev *od)\n{\n\tstruct bcm2835_chan *c, *next;\n\n\tlist_for_each_entry_safe(c, next, &od->ddev.channels,\n\t\t\t\t vc.chan.device_node) {\n\t\tlist_del(&c->vc.chan.device_node);\n\t\ttasklet_kill(&c->vc.task);\n\t}\n\n\tdma_unmap_page_attrs(od->ddev.dev, od->zero_page, PAGE_SIZE,\n\t\t\t     DMA_TO_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);\n}\n\nstatic const struct of_device_id bcm2835_dma_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-dma\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm2835_dma_of_match);\n\nstatic struct dma_chan *bcm2835_dma_xlate(struct of_phandle_args *spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct bcm2835_dmadev *d = ofdma->of_dma_data;\n\tstruct dma_chan *chan;\n\n\tchan = dma_get_any_slave_channel(&d->ddev);\n\tif (!chan)\n\t\treturn NULL;\n\n\t \n\tto_bcm2835_dma_chan(chan)->dreq = spec->args[0];\n\n\treturn chan;\n}\n\nstatic int bcm2835_dma_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_dmadev *od;\n\tvoid __iomem *base;\n\tint rc;\n\tint i, j;\n\tint irq[BCM2835_DMA_MAX_DMA_CHAN_SUPPORTED + 1];\n\tint irq_flags;\n\tuint32_t chans_available;\n\tchar chan_name[BCM2835_DMA_CHAN_NAME_SIZE];\n\n\tif (!pdev->dev.dma_mask)\n\t\tpdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Unable to set DMA mask\\n\");\n\t\treturn rc;\n\t}\n\n\tod = devm_kzalloc(&pdev->dev, sizeof(*od), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\tdma_set_max_seg_size(&pdev->dev, 0x3FFFFFFF);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tod->base = base;\n\n\tdma_cap_set(DMA_SLAVE, od->ddev.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, od->ddev.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, od->ddev.cap_mask);\n\tdma_cap_set(DMA_MEMCPY, od->ddev.cap_mask);\n\tod->ddev.device_alloc_chan_resources = bcm2835_dma_alloc_chan_resources;\n\tod->ddev.device_free_chan_resources = bcm2835_dma_free_chan_resources;\n\tod->ddev.device_tx_status = bcm2835_dma_tx_status;\n\tod->ddev.device_issue_pending = bcm2835_dma_issue_pending;\n\tod->ddev.device_prep_dma_cyclic = bcm2835_dma_prep_dma_cyclic;\n\tod->ddev.device_prep_slave_sg = bcm2835_dma_prep_slave_sg;\n\tod->ddev.device_prep_dma_memcpy = bcm2835_dma_prep_dma_memcpy;\n\tod->ddev.device_config = bcm2835_dma_slave_config;\n\tod->ddev.device_terminate_all = bcm2835_dma_terminate_all;\n\tod->ddev.device_synchronize = bcm2835_dma_synchronize;\n\tod->ddev.src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tod->ddev.dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\n\tod->ddev.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV) |\n\t\t\t      BIT(DMA_MEM_TO_MEM);\n\tod->ddev.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tod->ddev.descriptor_reuse = true;\n\tod->ddev.dev = &pdev->dev;\n\tINIT_LIST_HEAD(&od->ddev.channels);\n\n\tplatform_set_drvdata(pdev, od);\n\n\tod->zero_page = dma_map_page_attrs(od->ddev.dev, ZERO_PAGE(0), 0,\n\t\t\t\t\t   PAGE_SIZE, DMA_TO_DEVICE,\n\t\t\t\t\t   DMA_ATTR_SKIP_CPU_SYNC);\n\tif (dma_mapping_error(od->ddev.dev, od->zero_page)) {\n\t\tdev_err(&pdev->dev, \"Failed to map zero page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"brcm,dma-channel-mask\",\n\t\t\t&chans_available)) {\n\t\tdev_err(&pdev->dev, \"Failed to get channel mask\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_no_dma;\n\t}\n\n\t \n\tfor (i = 0; i <= BCM2835_DMA_MAX_DMA_CHAN_SUPPORTED; i++) {\n\t\t \n\t\tif (!(chans_available & (1 << i))) {\n\t\t\tirq[i] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsnprintf(chan_name, sizeof(chan_name), \"dma%i\", i);\n\t\tirq[i] = platform_get_irq_byname(pdev, chan_name);\n\t\tif (irq[i] >= 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tdev_warn_once(&pdev->dev,\n\t\t\t      \"missing interrupt-names property in device tree - legacy interpretation is used\\n\");\n\t\t \n\t\tirq[i] = platform_get_irq(pdev, i < 11 ? i : 11);\n\t}\n\n\t \n\tfor (i = 0; i <= BCM2835_DMA_MAX_DMA_CHAN_SUPPORTED; i++) {\n\t\t \n\t\tif (irq[i] < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tirq_flags = 0;\n\t\tfor (j = 0; j <= BCM2835_DMA_MAX_DMA_CHAN_SUPPORTED; j++)\n\t\t\tif ((i != j) && (irq[j] == irq[i])) {\n\t\t\t\tirq_flags = IRQF_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t \n\t\trc = bcm2835_dma_chan_init(od, i, irq[i], irq_flags);\n\t\tif (rc)\n\t\t\tgoto err_no_dma;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Initialized %i DMA channels\\n\", i);\n\n\t \n\trc = of_dma_controller_register(pdev->dev.of_node,\n\t\t\tbcm2835_dma_xlate, od);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to register DMA controller\\n\");\n\t\tgoto err_no_dma;\n\t}\n\n\trc = dma_async_device_register(&od->ddev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register slave DMA engine device: %d\\n\", rc);\n\t\tgoto err_no_dma;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Load BCM2835 DMA engine driver\\n\");\n\n\treturn 0;\n\nerr_no_dma:\n\tbcm2835_dma_free(od);\n\treturn rc;\n}\n\nstatic int bcm2835_dma_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835_dmadev *od = platform_get_drvdata(pdev);\n\n\tdma_async_device_unregister(&od->ddev);\n\tbcm2835_dma_free(od);\n\n\treturn 0;\n}\n\nstatic struct platform_driver bcm2835_dma_driver = {\n\t.probe\t= bcm2835_dma_probe,\n\t.remove\t= bcm2835_dma_remove,\n\t.driver = {\n\t\t.name = \"bcm2835-dma\",\n\t\t.of_match_table = of_match_ptr(bcm2835_dma_of_match),\n\t},\n};\n\nmodule_platform_driver(bcm2835_dma_driver);\n\nMODULE_ALIAS(\"platform:bcm2835-dma\");\nMODULE_DESCRIPTION(\"BCM2835 DMA engine driver\");\nMODULE_AUTHOR(\"Florian Meier <florian.meier@koalo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}