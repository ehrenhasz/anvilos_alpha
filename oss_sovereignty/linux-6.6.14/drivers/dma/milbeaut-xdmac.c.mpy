{
  "module_name": "milbeaut-xdmac.c",
  "hash_id": "1105dd386e8f42fa8097f1851c64a16acfc0fa0afe73a015cf2e8a8f10ebbde1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/milbeaut-xdmac.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bits.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/bitfield.h>\n\n#include \"virt-dma.h\"\n\n \n#define M10V_XDACS 0x00\n\n \n#define M10V_XDTBC 0x10\n#define M10V_XDSSA 0x14\n#define M10V_XDDSA 0x18\n#define M10V_XDSAC 0x1C\n#define M10V_XDDAC 0x20\n#define M10V_XDDCC 0x24\n#define M10V_XDDES 0x28\n#define M10V_XDDPC 0x2C\n#define M10V_XDDSD 0x30\n\n#define M10V_XDACS_XE BIT(28)\n\n#define M10V_DEFBS\t0x3\n#define M10V_DEFBL\t0xf\n\n#define M10V_XDSAC_SBS\tGENMASK(17, 16)\n#define M10V_XDSAC_SBL\tGENMASK(11, 8)\n\n#define M10V_XDDAC_DBS\tGENMASK(17, 16)\n#define M10V_XDDAC_DBL\tGENMASK(11, 8)\n\n#define M10V_XDDES_CE\tBIT(28)\n#define M10V_XDDES_SE\tBIT(24)\n#define M10V_XDDES_SA\tBIT(15)\n#define M10V_XDDES_TF\tGENMASK(23, 20)\n#define M10V_XDDES_EI\tBIT(1)\n#define M10V_XDDES_TI\tBIT(0)\n\n#define M10V_XDDSD_IS_MASK\tGENMASK(3, 0)\n#define M10V_XDDSD_IS_NORMAL\t0x8\n\n#define MLB_XDMAC_BUSWIDTHS\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \\\n\t\t\t\t BIT(DMA_SLAVE_BUSWIDTH_8_BYTES))\n\nstruct milbeaut_xdmac_desc {\n\tstruct virt_dma_desc vd;\n\tsize_t len;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n};\n\nstruct milbeaut_xdmac_chan {\n\tstruct virt_dma_chan vc;\n\tstruct milbeaut_xdmac_desc *md;\n\tvoid __iomem *reg_ch_base;\n};\n\nstruct milbeaut_xdmac_device {\n\tstruct dma_device ddev;\n\tvoid __iomem *reg_base;\n\tstruct milbeaut_xdmac_chan channels[];\n};\n\nstatic struct milbeaut_xdmac_chan *\nto_milbeaut_xdmac_chan(struct virt_dma_chan *vc)\n{\n\treturn container_of(vc, struct milbeaut_xdmac_chan, vc);\n}\n\nstatic struct milbeaut_xdmac_desc *\nto_milbeaut_xdmac_desc(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct milbeaut_xdmac_desc, vd);\n}\n\n \nstatic struct milbeaut_xdmac_desc *\nmilbeaut_xdmac_next_desc(struct milbeaut_xdmac_chan *mc)\n{\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&mc->vc);\n\tif (!vd) {\n\t\tmc->md = NULL;\n\t\treturn NULL;\n\t}\n\n\tlist_del(&vd->node);\n\n\tmc->md = to_milbeaut_xdmac_desc(vd);\n\n\treturn mc->md;\n}\n\n \nstatic void milbeaut_chan_start(struct milbeaut_xdmac_chan *mc,\n\t\t\t\tstruct milbeaut_xdmac_desc *md)\n{\n\tu32 val;\n\n\t \n\tval = md->len - 1;\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDTBC);\n\n\tval = md->src;\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDSSA);\n\n\tval = md->dst;\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDDSA);\n\n\tval = readl_relaxed(mc->reg_ch_base + M10V_XDSAC);\n\tval &= ~(M10V_XDSAC_SBS | M10V_XDSAC_SBL);\n\tval |= FIELD_PREP(M10V_XDSAC_SBS, M10V_DEFBS) |\n\t\tFIELD_PREP(M10V_XDSAC_SBL, M10V_DEFBL);\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDSAC);\n\n\tval = readl_relaxed(mc->reg_ch_base + M10V_XDDAC);\n\tval &= ~(M10V_XDDAC_DBS | M10V_XDDAC_DBL);\n\tval |= FIELD_PREP(M10V_XDDAC_DBS, M10V_DEFBS) |\n\t\tFIELD_PREP(M10V_XDDAC_DBL, M10V_DEFBL);\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDDAC);\n\n\t \n\tval = readl_relaxed(mc->reg_ch_base + M10V_XDDES);\n\tval &= ~(M10V_XDDES_CE | M10V_XDDES_SE | M10V_XDDES_TF |\n\t\t M10V_XDDES_EI | M10V_XDDES_TI);\n\tval |= FIELD_PREP(M10V_XDDES_CE, 1) | FIELD_PREP(M10V_XDDES_SE, 1) |\n\t\tFIELD_PREP(M10V_XDDES_TF, 1) | FIELD_PREP(M10V_XDDES_EI, 1) |\n\t\tFIELD_PREP(M10V_XDDES_TI, 1);\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDDES);\n}\n\n \nstatic void milbeaut_xdmac_start(struct milbeaut_xdmac_chan *mc)\n{\n\tstruct milbeaut_xdmac_desc *md;\n\n\tmd = milbeaut_xdmac_next_desc(mc);\n\tif (md)\n\t\tmilbeaut_chan_start(mc, md);\n}\n\nstatic irqreturn_t milbeaut_xdmac_interrupt(int irq, void *dev_id)\n{\n\tstruct milbeaut_xdmac_chan *mc = dev_id;\n\tstruct milbeaut_xdmac_desc *md;\n\tu32 val;\n\n\tspin_lock(&mc->vc.lock);\n\n\t \n\tval = FIELD_PREP(M10V_XDDSD_IS_MASK, 0x0);\n\twritel_relaxed(val, mc->reg_ch_base + M10V_XDDSD);\n\n\tmd = mc->md;\n\tif (!md)\n\t\tgoto out;\n\n\tvchan_cookie_complete(&md->vd);\n\n\tmilbeaut_xdmac_start(mc);\nout:\n\tspin_unlock(&mc->vc.lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void milbeaut_xdmac_free_chan_resources(struct dma_chan *chan)\n{\n\tvchan_free_chan_resources(to_virt_chan(chan));\n}\n\nstatic struct dma_async_tx_descriptor *\nmilbeaut_xdmac_prep_memcpy(struct dma_chan *chan, dma_addr_t dst,\n\t\t\t   dma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_xdmac_desc *md;\n\n\tmd = kzalloc(sizeof(*md), GFP_NOWAIT);\n\tif (!md)\n\t\treturn NULL;\n\n\tmd->len = len;\n\tmd->src = src;\n\tmd->dst = dst;\n\n\treturn vchan_tx_prep(vc, &md->vd, flags);\n}\n\nstatic int milbeaut_xdmac_terminate_all(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_xdmac_chan *mc = to_milbeaut_xdmac_chan(vc);\n\tunsigned long flags;\n\tu32 val;\n\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\t \n\tval = readl(mc->reg_ch_base + M10V_XDDES);\n\tval &= ~M10V_XDDES_CE;\n\tval |= FIELD_PREP(M10V_XDDES_CE, 0);\n\twritel(val, mc->reg_ch_base + M10V_XDDES);\n\n\tif (mc->md) {\n\t\tvchan_terminate_vdesc(&mc->md->vd);\n\t\tmc->md = NULL;\n\t}\n\n\tvchan_get_all_descriptors(vc, &head);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tvchan_dma_desc_free_list(vc, &head);\n\n\treturn 0;\n}\n\nstatic void milbeaut_xdmac_synchronize(struct dma_chan *chan)\n{\n\tvchan_synchronize(to_virt_chan(chan));\n}\n\nstatic void milbeaut_xdmac_issue_pending(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_xdmac_chan *mc = to_milbeaut_xdmac_chan(vc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tif (vchan_issue_pending(vc) && !mc->md)\n\t\tmilbeaut_xdmac_start(mc);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n}\n\nstatic void milbeaut_xdmac_desc_free(struct virt_dma_desc *vd)\n{\n\tkfree(to_milbeaut_xdmac_desc(vd));\n}\n\nstatic int milbeaut_xdmac_chan_init(struct platform_device *pdev,\n\t\t\t\t    struct milbeaut_xdmac_device *mdev,\n\t\t\t\t    int chan_id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct milbeaut_xdmac_chan *mc = &mdev->channels[chan_id];\n\tchar *irq_name;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, chan_id);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_name = devm_kasprintf(dev, GFP_KERNEL, \"milbeaut-xdmac-%d\",\n\t\t\t\t  chan_id);\n\tif (!irq_name)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(dev, irq, milbeaut_xdmac_interrupt,\n\t\t\t       IRQF_SHARED, irq_name, mc);\n\tif (ret)\n\t\treturn ret;\n\n\tmc->reg_ch_base = mdev->reg_base + chan_id * 0x30;\n\n\tmc->vc.desc_free = milbeaut_xdmac_desc_free;\n\tvchan_init(&mc->vc, &mdev->ddev);\n\n\treturn 0;\n}\n\nstatic void enable_xdmac(struct milbeaut_xdmac_device *mdev)\n{\n\tunsigned int val;\n\n\tval = readl(mdev->reg_base + M10V_XDACS);\n\tval |= M10V_XDACS_XE;\n\twritel(val, mdev->reg_base + M10V_XDACS);\n}\n\nstatic void disable_xdmac(struct milbeaut_xdmac_device *mdev)\n{\n\tunsigned int val;\n\n\tval = readl(mdev->reg_base + M10V_XDACS);\n\tval &= ~M10V_XDACS_XE;\n\twritel(val, mdev->reg_base + M10V_XDACS);\n}\n\nstatic int milbeaut_xdmac_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct milbeaut_xdmac_device *mdev;\n\tstruct dma_device *ddev;\n\tint nr_chans, ret, i;\n\n\tnr_chans = platform_irq_count(pdev);\n\tif (nr_chans < 0)\n\t\treturn nr_chans;\n\n\tmdev = devm_kzalloc(dev, struct_size(mdev, channels, nr_chans),\n\t\t\t    GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->reg_base))\n\t\treturn PTR_ERR(mdev->reg_base);\n\n\tddev = &mdev->ddev;\n\tddev->dev = dev;\n\tdma_cap_set(DMA_MEMCPY, ddev->cap_mask);\n\tddev->src_addr_widths = MLB_XDMAC_BUSWIDTHS;\n\tddev->dst_addr_widths = MLB_XDMAC_BUSWIDTHS;\n\tddev->device_free_chan_resources = milbeaut_xdmac_free_chan_resources;\n\tddev->device_prep_dma_memcpy = milbeaut_xdmac_prep_memcpy;\n\tddev->device_terminate_all = milbeaut_xdmac_terminate_all;\n\tddev->device_synchronize = milbeaut_xdmac_synchronize;\n\tddev->device_tx_status = dma_cookie_status;\n\tddev->device_issue_pending = milbeaut_xdmac_issue_pending;\n\tINIT_LIST_HEAD(&ddev->channels);\n\n\tfor (i = 0; i < nr_chans; i++) {\n\t\tret = milbeaut_xdmac_chan_init(pdev, mdev, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tenable_xdmac(mdev);\n\n\tret = dma_async_device_register(ddev);\n\tif (ret)\n\t\tgoto disable_xdmac;\n\n\tret = of_dma_controller_register(dev->of_node,\n\t\t\t\t\t of_dma_simple_xlate, mdev);\n\tif (ret)\n\t\tgoto unregister_dmac;\n\n\tplatform_set_drvdata(pdev, mdev);\n\n\treturn 0;\n\nunregister_dmac:\n\tdma_async_device_unregister(ddev);\ndisable_xdmac:\n\tdisable_xdmac(mdev);\n\treturn ret;\n}\n\nstatic int milbeaut_xdmac_remove(struct platform_device *pdev)\n{\n\tstruct milbeaut_xdmac_device *mdev = platform_get_drvdata(pdev);\n\tstruct dma_chan *chan;\n\tint ret;\n\n\t \n\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {\n\t\tret = dmaengine_terminate_sync(chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmilbeaut_xdmac_free_chan_resources(chan);\n\t}\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&mdev->ddev);\n\n\tdisable_xdmac(mdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id milbeaut_xdmac_match[] = {\n\t{ .compatible = \"socionext,milbeaut-m10v-xdmac\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, milbeaut_xdmac_match);\n\nstatic struct platform_driver milbeaut_xdmac_driver = {\n\t.probe = milbeaut_xdmac_probe,\n\t.remove = milbeaut_xdmac_remove,\n\t.driver = {\n\t\t.name = \"milbeaut-m10v-xdmac\",\n\t\t.of_match_table = milbeaut_xdmac_match,\n\t},\n};\nmodule_platform_driver(milbeaut_xdmac_driver);\n\nMODULE_DESCRIPTION(\"Milbeaut XDMAC DmaEngine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}