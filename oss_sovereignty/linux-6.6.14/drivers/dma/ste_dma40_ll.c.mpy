{
  "module_name": "ste_dma40_ll.c",
  "hash_id": "01f3029199f4daec8e873916791f38135a043510d4b58d3d1c6bedd7e8b41740",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ste_dma40_ll.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/dmaengine.h>\n\n#include \"ste_dma40.h\"\n#include \"ste_dma40_ll.h\"\n\nstatic u8 d40_width_to_bits(enum dma_slave_buswidth width)\n{\n\tif (width == DMA_SLAVE_BUSWIDTH_1_BYTE)\n\t\treturn STEDMA40_ESIZE_8_BIT;\n\telse if (width == DMA_SLAVE_BUSWIDTH_2_BYTES)\n\t\treturn STEDMA40_ESIZE_16_BIT;\n\telse if (width == DMA_SLAVE_BUSWIDTH_8_BYTES)\n\t\treturn STEDMA40_ESIZE_64_BIT;\n\telse\n\t\treturn STEDMA40_ESIZE_32_BIT;\n}\n\n \nvoid d40_log_cfg(struct stedma40_chan_cfg *cfg,\n\t\t u32 *lcsp1, u32 *lcsp3)\n{\n\tu32 l3 = 0;  \n\tu32 l1 = 0;  \n\n\t \n\tif (cfg->dir ==  DMA_MEM_TO_DEV ||\n\t    cfg->dir ==  DMA_MEM_TO_MEM)\n\t\tl1 |= BIT(D40_MEM_LCSP1_SCFG_INCR_POS);\n\n\t \n\tif (cfg->dir ==  DMA_DEV_TO_MEM ||\n\t    cfg->dir ==  DMA_MEM_TO_MEM)\n\t\tl3 |= BIT(D40_MEM_LCSP3_DCFG_INCR_POS);\n\n\t \n\tif (cfg->dir ==  DMA_DEV_TO_MEM ||\n\t    cfg->dir ==  DMA_DEV_TO_DEV)\n\t\tl1 |= BIT(D40_MEM_LCSP1_SCFG_MST_POS);\n\n\t \n\tif (cfg->dir ==  DMA_MEM_TO_DEV ||\n\t    cfg->dir ==  DMA_DEV_TO_DEV)\n\t\tl3 |= BIT(D40_MEM_LCSP3_DCFG_MST_POS);\n\n\tl3 |= BIT(D40_MEM_LCSP3_DCFG_EIM_POS);\n\tl3 |= cfg->dst_info.psize << D40_MEM_LCSP3_DCFG_PSIZE_POS;\n\tl3 |= d40_width_to_bits(cfg->dst_info.data_width)\n\t\t<< D40_MEM_LCSP3_DCFG_ESIZE_POS;\n\n\tl1 |= BIT(D40_MEM_LCSP1_SCFG_EIM_POS);\n\tl1 |= cfg->src_info.psize << D40_MEM_LCSP1_SCFG_PSIZE_POS;\n\tl1 |= d40_width_to_bits(cfg->src_info.data_width)\n\t\t<< D40_MEM_LCSP1_SCFG_ESIZE_POS;\n\n\t*lcsp1 = l1;\n\t*lcsp3 = l3;\n\n}\n\nvoid d40_phy_cfg(struct stedma40_chan_cfg *cfg, u32 *src_cfg, u32 *dst_cfg)\n{\n\tu32 src = 0;\n\tu32 dst = 0;\n\n\tif ((cfg->dir == DMA_DEV_TO_MEM) ||\n\t    (cfg->dir == DMA_DEV_TO_DEV)) {\n\t\t \n\t\tsrc |= BIT(D40_SREG_CFG_MST_POS);\n\t\tsrc |= D40_TYPE_TO_EVENT(cfg->dev_type);\n\n\t\tif (cfg->src_info.flow_ctrl == STEDMA40_NO_FLOW_CTRL)\n\t\t\tsrc |= BIT(D40_SREG_CFG_PHY_TM_POS);\n\t\telse\n\t\t\tsrc |= 3 << D40_SREG_CFG_PHY_TM_POS;\n\t}\n\tif ((cfg->dir == DMA_MEM_TO_DEV) ||\n\t    (cfg->dir == DMA_DEV_TO_DEV)) {\n\t\t \n\t\tdst |= BIT(D40_SREG_CFG_MST_POS);\n\t\tdst |= D40_TYPE_TO_EVENT(cfg->dev_type);\n\n\t\tif (cfg->dst_info.flow_ctrl == STEDMA40_NO_FLOW_CTRL)\n\t\t\tdst |= BIT(D40_SREG_CFG_PHY_TM_POS);\n\t\telse\n\t\t\tdst |= 3 << D40_SREG_CFG_PHY_TM_POS;\n\t}\n\t \n\tdst |= BIT(D40_SREG_CFG_TIM_POS);\n\n\t \n\tsrc |= BIT(D40_SREG_CFG_EIM_POS);\n\tdst |= BIT(D40_SREG_CFG_EIM_POS);\n\n\t \n\tif (cfg->src_info.psize != STEDMA40_PSIZE_PHY_1) {\n\t\tsrc |= BIT(D40_SREG_CFG_PHY_PEN_POS);\n\t\tsrc |= cfg->src_info.psize << D40_SREG_CFG_PSIZE_POS;\n\t}\n\tif (cfg->dst_info.psize != STEDMA40_PSIZE_PHY_1) {\n\t\tdst |= BIT(D40_SREG_CFG_PHY_PEN_POS);\n\t\tdst |= cfg->dst_info.psize << D40_SREG_CFG_PSIZE_POS;\n\t}\n\n\t \n\tsrc |= d40_width_to_bits(cfg->src_info.data_width)\n\t\t<< D40_SREG_CFG_ESIZE_POS;\n\tdst |= d40_width_to_bits(cfg->dst_info.data_width)\n\t\t<< D40_SREG_CFG_ESIZE_POS;\n\n\t \n\tif (cfg->high_priority) {\n\t\tsrc |= BIT(D40_SREG_CFG_PRI_POS);\n\t\tdst |= BIT(D40_SREG_CFG_PRI_POS);\n\t}\n\n\tif (cfg->src_info.big_endian)\n\t\tsrc |= BIT(D40_SREG_CFG_LBE_POS);\n\tif (cfg->dst_info.big_endian)\n\t\tdst |= BIT(D40_SREG_CFG_LBE_POS);\n\n\t*src_cfg = src;\n\t*dst_cfg = dst;\n}\n\nstatic int d40_phy_fill_lli(struct d40_phy_lli *lli,\n\t\t\t    dma_addr_t data,\n\t\t\t    u32 data_size,\n\t\t\t    dma_addr_t next_lli,\n\t\t\t    u32 reg_cfg,\n\t\t\t    struct stedma40_half_channel_info *info,\n\t\t\t    unsigned int flags)\n{\n\tbool addr_inc = flags & LLI_ADDR_INC;\n\tbool term_int = flags & LLI_TERM_INT;\n\tunsigned int data_width = info->data_width;\n\tint psize = info->psize;\n\tint num_elems;\n\n\tif (psize == STEDMA40_PSIZE_PHY_1)\n\t\tnum_elems = 1;\n\telse\n\t\tnum_elems = 2 << psize;\n\n\t \n\tif (!IS_ALIGNED(data, data_width))\n\t\treturn -EINVAL;\n\n\t \n\tif (data_size < num_elems * data_width)\n\t\treturn -EINVAL;\n\n\t \n\tlli->reg_elt = (data_size / data_width) << D40_SREG_ELEM_PHY_ECNT_POS;\n\n\t \n\tif (addr_inc)\n\t\tlli->reg_elt |= data_width << D40_SREG_ELEM_PHY_EIDX_POS;\n\n\t \n\tlli->reg_ptr = data;\n\tlli->reg_cfg = reg_cfg;\n\n\t \n\tif (next_lli == 0)\n\t\tlli->reg_lnk = BIT(D40_SREG_LNK_PHY_TCP_POS);\n\telse\n\t\tlli->reg_lnk = next_lli;\n\n\t \n\tif (term_int)\n\t\tlli->reg_cfg |= BIT(D40_SREG_CFG_TIM_POS);\n\telse\n\t\tlli->reg_cfg &= ~BIT(D40_SREG_CFG_TIM_POS);\n\n\t \n\n\treturn 0;\n}\n\nstatic int d40_seg_size(int size, int data_width1, int data_width2)\n{\n\tu32 max_w = max(data_width1, data_width2);\n\tu32 min_w = min(data_width1, data_width2);\n\tu32 seg_max = ALIGN(STEDMA40_MAX_SEG_SIZE * min_w, max_w);\n\n\tif (seg_max > STEDMA40_MAX_SEG_SIZE)\n\t\tseg_max -= max_w;\n\n\tif (size <= seg_max)\n\t\treturn size;\n\n\tif (size <= 2 * seg_max)\n\t\treturn ALIGN(size / 2, max_w);\n\n\treturn seg_max;\n}\n\nstatic struct d40_phy_lli *\nd40_phy_buf_to_lli(struct d40_phy_lli *lli, dma_addr_t addr, u32 size,\n\t\t   dma_addr_t lli_phys, dma_addr_t first_phys, u32 reg_cfg,\n\t\t   struct stedma40_half_channel_info *info,\n\t\t   struct stedma40_half_channel_info *otherinfo,\n\t\t   unsigned long flags)\n{\n\tbool lastlink = flags & LLI_LAST_LINK;\n\tbool addr_inc = flags & LLI_ADDR_INC;\n\tbool term_int = flags & LLI_TERM_INT;\n\tbool cyclic = flags & LLI_CYCLIC;\n\tint err;\n\tdma_addr_t next = lli_phys;\n\tint size_rest = size;\n\tint size_seg = 0;\n\n\t \n\tif (term_int)\n\t\tflags &= ~LLI_TERM_INT;\n\n\tdo {\n\t\tsize_seg = d40_seg_size(size_rest, info->data_width,\n\t\t\t\t\totherinfo->data_width);\n\t\tsize_rest -= size_seg;\n\n\t\tif (size_rest == 0 && term_int)\n\t\t\tflags |= LLI_TERM_INT;\n\n\t\tif (size_rest == 0 && lastlink)\n\t\t\tnext = cyclic ? first_phys : 0;\n\t\telse\n\t\t\tnext = ALIGN(next + sizeof(struct d40_phy_lli),\n\t\t\t\t     D40_LLI_ALIGN);\n\n\t\terr = d40_phy_fill_lli(lli, addr, size_seg, next,\n\t\t\t\t       reg_cfg, info, flags);\n\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tlli++;\n\t\tif (addr_inc)\n\t\t\taddr += size_seg;\n\t} while (size_rest);\n\n\treturn lli;\n\nerr:\n\treturn NULL;\n}\n\nint d40_phy_sg_to_lli(struct scatterlist *sg,\n\t\t      int sg_len,\n\t\t      dma_addr_t target,\n\t\t      struct d40_phy_lli *lli_sg,\n\t\t      dma_addr_t lli_phys,\n\t\t      u32 reg_cfg,\n\t\t      struct stedma40_half_channel_info *info,\n\t\t      struct stedma40_half_channel_info *otherinfo,\n\t\t      unsigned long flags)\n{\n\tint total_size = 0;\n\tint i;\n\tstruct scatterlist *current_sg = sg;\n\tstruct d40_phy_lli *lli = lli_sg;\n\tdma_addr_t l_phys = lli_phys;\n\n\tif (!target)\n\t\tflags |= LLI_ADDR_INC;\n\n\tfor_each_sg(sg, current_sg, sg_len, i) {\n\t\tdma_addr_t sg_addr = sg_dma_address(current_sg);\n\t\tunsigned int len = sg_dma_len(current_sg);\n\t\tdma_addr_t dst = target ?: sg_addr;\n\n\t\ttotal_size += sg_dma_len(current_sg);\n\n\t\tif (i == sg_len - 1)\n\t\t\tflags |= LLI_TERM_INT | LLI_LAST_LINK;\n\n\t\tl_phys = ALIGN(lli_phys + (lli - lli_sg) *\n\t\t\t       sizeof(struct d40_phy_lli), D40_LLI_ALIGN);\n\n\t\tlli = d40_phy_buf_to_lli(lli, dst, len, l_phys, lli_phys,\n\t\t\t\t\t reg_cfg, info, otherinfo, flags);\n\n\t\tif (lli == NULL)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn total_size;\n}\n\n\n \n\nstatic void d40_log_lli_link(struct d40_log_lli *lli_dst,\n\t\t\t     struct d40_log_lli *lli_src,\n\t\t\t     int next, unsigned int flags)\n{\n\tbool interrupt = flags & LLI_TERM_INT;\n\tu32 slos = 0;\n\tu32 dlos = 0;\n\n\tif (next != -EINVAL) {\n\t\tslos = next * 2;\n\t\tdlos = next * 2 + 1;\n\t}\n\n\tif (interrupt) {\n\t\tlli_dst->lcsp13 |= D40_MEM_LCSP1_SCFG_TIM_MASK;\n\t\tlli_dst->lcsp13 |= D40_MEM_LCSP3_DTCP_MASK;\n\t}\n\n\tlli_src->lcsp13 = (lli_src->lcsp13 & ~D40_MEM_LCSP1_SLOS_MASK) |\n\t\t(slos << D40_MEM_LCSP1_SLOS_POS);\n\n\tlli_dst->lcsp13 = (lli_dst->lcsp13 & ~D40_MEM_LCSP1_SLOS_MASK) |\n\t\t(dlos << D40_MEM_LCSP1_SLOS_POS);\n}\n\nvoid d40_log_lli_lcpa_write(struct d40_log_lli_full *lcpa,\n\t\t\t   struct d40_log_lli *lli_dst,\n\t\t\t   struct d40_log_lli *lli_src,\n\t\t\t   int next, unsigned int flags)\n{\n\td40_log_lli_link(lli_dst, lli_src, next, flags);\n\n\twritel_relaxed(lli_src->lcsp02, &lcpa[0].lcsp0);\n\twritel_relaxed(lli_src->lcsp13, &lcpa[0].lcsp1);\n\twritel_relaxed(lli_dst->lcsp02, &lcpa[0].lcsp2);\n\twritel_relaxed(lli_dst->lcsp13, &lcpa[0].lcsp3);\n}\n\nvoid d40_log_lli_lcla_write(struct d40_log_lli *lcla,\n\t\t\t   struct d40_log_lli *lli_dst,\n\t\t\t   struct d40_log_lli *lli_src,\n\t\t\t   int next, unsigned int flags)\n{\n\td40_log_lli_link(lli_dst, lli_src, next, flags);\n\n\twritel_relaxed(lli_src->lcsp02, &lcla[0].lcsp02);\n\twritel_relaxed(lli_src->lcsp13, &lcla[0].lcsp13);\n\twritel_relaxed(lli_dst->lcsp02, &lcla[1].lcsp02);\n\twritel_relaxed(lli_dst->lcsp13, &lcla[1].lcsp13);\n}\n\nstatic void d40_log_fill_lli(struct d40_log_lli *lli,\n\t\t\t     dma_addr_t data, u32 data_size,\n\t\t\t     u32 reg_cfg,\n\t\t\t     u32 data_width,\n\t\t\t     unsigned int flags)\n{\n\tbool addr_inc = flags & LLI_ADDR_INC;\n\n\tlli->lcsp13 = reg_cfg;\n\n\t \n\tlli->lcsp02 = ((data_size / data_width) <<\n\t\t       D40_MEM_LCSP0_ECNT_POS) & D40_MEM_LCSP0_ECNT_MASK;\n\n\tBUG_ON((data_size / data_width) > STEDMA40_MAX_SEG_SIZE);\n\n\t \n\tlli->lcsp02 |= data & D40_MEM_LCSP0_SPTR_MASK;\n\t \n\tlli->lcsp13 |= data & D40_MEM_LCSP1_SPTR_MASK;\n\n\tif (addr_inc)\n\t\tlli->lcsp13 |= D40_MEM_LCSP1_SCFG_INCR_MASK;\n\n}\n\nstatic struct d40_log_lli *d40_log_buf_to_lli(struct d40_log_lli *lli_sg,\n\t\t\t\t       dma_addr_t addr,\n\t\t\t\t       int size,\n\t\t\t\t       u32 lcsp13,  \n\t\t\t\t       u32 data_width1,\n\t\t\t\t       u32 data_width2,\n\t\t\t\t       unsigned int flags)\n{\n\tbool addr_inc = flags & LLI_ADDR_INC;\n\tstruct d40_log_lli *lli = lli_sg;\n\tint size_rest = size;\n\tint size_seg = 0;\n\n\tdo {\n\t\tsize_seg = d40_seg_size(size_rest, data_width1, data_width2);\n\t\tsize_rest -= size_seg;\n\n\t\td40_log_fill_lli(lli,\n\t\t\t\t addr,\n\t\t\t\t size_seg,\n\t\t\t\t lcsp13, data_width1,\n\t\t\t\t flags);\n\t\tif (addr_inc)\n\t\t\taddr += size_seg;\n\t\tlli++;\n\t} while (size_rest);\n\n\treturn lli;\n}\n\nint d40_log_sg_to_lli(struct scatterlist *sg,\n\t\t      int sg_len,\n\t\t      dma_addr_t dev_addr,\n\t\t      struct d40_log_lli *lli_sg,\n\t\t      u32 lcsp13,  \n\t\t      u32 data_width1, u32 data_width2)\n{\n\tint total_size = 0;\n\tstruct scatterlist *current_sg = sg;\n\tint i;\n\tstruct d40_log_lli *lli = lli_sg;\n\tunsigned long flags = 0;\n\n\tif (!dev_addr)\n\t\tflags |= LLI_ADDR_INC;\n\n\tfor_each_sg(sg, current_sg, sg_len, i) {\n\t\tdma_addr_t sg_addr = sg_dma_address(current_sg);\n\t\tunsigned int len = sg_dma_len(current_sg);\n\t\tdma_addr_t addr = dev_addr ?: sg_addr;\n\n\t\ttotal_size += sg_dma_len(current_sg);\n\n\t\tlli = d40_log_buf_to_lli(lli, addr, len,\n\t\t\t\t\t lcsp13,\n\t\t\t\t\t data_width1,\n\t\t\t\t\t data_width2,\n\t\t\t\t\t flags);\n\t}\n\n\treturn total_size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}