{
  "module_name": "milbeaut-hdmac.c",
  "hash_id": "fb828fe9a35f5e00ac5ca7608182346caf22875aa55afdd18040a31979064efa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/milbeaut-hdmac.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/bitfield.h>\n\n#include \"virt-dma.h\"\n\n#define MLB_HDMAC_DMACR\t\t0x0\t \n#define MLB_HDMAC_DE\t\tBIT(31)\n#define MLB_HDMAC_DS\t\tBIT(30)\n#define MLB_HDMAC_PR\t\tBIT(28)\n#define MLB_HDMAC_DH\t\tGENMASK(27, 24)\n\n#define MLB_HDMAC_CH_STRIDE\t0x10\n\n#define MLB_HDMAC_DMACA\t\t0x0\t \n#define MLB_HDMAC_EB\t\tBIT(31)\n#define MLB_HDMAC_PB\t\tBIT(30)\n#define MLB_HDMAC_ST\t\tBIT(29)\n#define MLB_HDMAC_IS\t\tGENMASK(28, 24)\n#define MLB_HDMAC_BT\t\tGENMASK(23, 20)\n#define MLB_HDMAC_BC\t\tGENMASK(19, 16)\n#define MLB_HDMAC_TC\t\tGENMASK(15, 0)\n#define MLB_HDMAC_DMACB\t\t0x4\n#define MLB_HDMAC_TT\t\tGENMASK(31, 30)\n#define MLB_HDMAC_MS\t\tGENMASK(29, 28)\n#define MLB_HDMAC_TW\t\tGENMASK(27, 26)\n#define MLB_HDMAC_FS\t\tBIT(25)\n#define MLB_HDMAC_FD\t\tBIT(24)\n#define MLB_HDMAC_RC\t\tBIT(23)\n#define MLB_HDMAC_RS\t\tBIT(22)\n#define MLB_HDMAC_RD\t\tBIT(21)\n#define MLB_HDMAC_EI\t\tBIT(20)\n#define MLB_HDMAC_CI\t\tBIT(19)\n#define HDMAC_PAUSE\t\t0x7\n#define MLB_HDMAC_SS\t\tGENMASK(18, 16)\n#define MLB_HDMAC_SP\t\tGENMASK(15, 12)\n#define MLB_HDMAC_DP\t\tGENMASK(11, 8)\n#define MLB_HDMAC_DMACSA\t0x8\n#define MLB_HDMAC_DMACDA\t0xc\n\n#define MLB_HDMAC_BUSWIDTHS\t\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES))\n\nstruct milbeaut_hdmac_desc {\n\tstruct virt_dma_desc vd;\n\tstruct scatterlist *sgl;\n\tunsigned int sg_len;\n\tunsigned int sg_cur;\n\tenum dma_transfer_direction dir;\n};\n\nstruct milbeaut_hdmac_chan {\n\tstruct virt_dma_chan vc;\n\tstruct milbeaut_hdmac_device *mdev;\n\tstruct milbeaut_hdmac_desc *md;\n\tvoid __iomem *reg_ch_base;\n\tunsigned int slave_id;\n\tstruct dma_slave_config\tcfg;\n};\n\nstruct milbeaut_hdmac_device {\n\tstruct dma_device ddev;\n\tstruct clk *clk;\n\tvoid __iomem *reg_base;\n\tstruct milbeaut_hdmac_chan channels[];\n};\n\nstatic struct milbeaut_hdmac_chan *\nto_milbeaut_hdmac_chan(struct virt_dma_chan *vc)\n{\n\treturn container_of(vc, struct milbeaut_hdmac_chan, vc);\n}\n\nstatic struct milbeaut_hdmac_desc *\nto_milbeaut_hdmac_desc(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct milbeaut_hdmac_desc, vd);\n}\n\n \nstatic struct milbeaut_hdmac_desc *\nmilbeaut_hdmac_next_desc(struct milbeaut_hdmac_chan *mc)\n{\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&mc->vc);\n\tif (!vd) {\n\t\tmc->md = NULL;\n\t\treturn NULL;\n\t}\n\n\tlist_del(&vd->node);\n\n\tmc->md = to_milbeaut_hdmac_desc(vd);\n\n\treturn mc->md;\n}\n\n \nstatic void milbeaut_chan_start(struct milbeaut_hdmac_chan *mc,\n\t\t\t\tstruct milbeaut_hdmac_desc *md)\n{\n\tstruct scatterlist *sg;\n\tu32 cb, ca, src_addr, dest_addr, len;\n\tu32 width, burst;\n\n\tsg = &md->sgl[md->sg_cur];\n\tlen = sg_dma_len(sg);\n\n\tcb = MLB_HDMAC_CI | MLB_HDMAC_EI;\n\tif (md->dir == DMA_MEM_TO_DEV) {\n\t\tcb |= MLB_HDMAC_FD;\n\t\twidth = mc->cfg.dst_addr_width;\n\t\tburst = mc->cfg.dst_maxburst;\n\t\tsrc_addr = sg_dma_address(sg);\n\t\tdest_addr = mc->cfg.dst_addr;\n\t} else {\n\t\tcb |= MLB_HDMAC_FS;\n\t\twidth = mc->cfg.src_addr_width;\n\t\tburst = mc->cfg.src_maxburst;\n\t\tsrc_addr = mc->cfg.src_addr;\n\t\tdest_addr = sg_dma_address(sg);\n\t}\n\tcb |= FIELD_PREP(MLB_HDMAC_TW, (width >> 1));\n\tcb |= FIELD_PREP(MLB_HDMAC_MS, 2);\n\n\twritel_relaxed(MLB_HDMAC_DE, mc->mdev->reg_base + MLB_HDMAC_DMACR);\n\twritel_relaxed(src_addr, mc->reg_ch_base + MLB_HDMAC_DMACSA);\n\twritel_relaxed(dest_addr, mc->reg_ch_base + MLB_HDMAC_DMACDA);\n\twritel_relaxed(cb, mc->reg_ch_base + MLB_HDMAC_DMACB);\n\n\tca = FIELD_PREP(MLB_HDMAC_IS, mc->slave_id);\n\tif (burst == 16)\n\t\tca |= FIELD_PREP(MLB_HDMAC_BT, 0xf);\n\telse if (burst == 8)\n\t\tca |= FIELD_PREP(MLB_HDMAC_BT, 0xd);\n\telse if (burst == 4)\n\t\tca |= FIELD_PREP(MLB_HDMAC_BT, 0xb);\n\tburst *= width;\n\tca |= FIELD_PREP(MLB_HDMAC_TC, (len / burst - 1));\n\twritel_relaxed(ca, mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tca |= MLB_HDMAC_EB;\n\twritel_relaxed(ca, mc->reg_ch_base + MLB_HDMAC_DMACA);\n}\n\n \nstatic void milbeaut_hdmac_start(struct milbeaut_hdmac_chan *mc)\n{\n\tstruct milbeaut_hdmac_desc *md;\n\n\tmd = milbeaut_hdmac_next_desc(mc);\n\tif (md)\n\t\tmilbeaut_chan_start(mc, md);\n}\n\nstatic irqreturn_t milbeaut_hdmac_interrupt(int irq, void *dev_id)\n{\n\tstruct milbeaut_hdmac_chan *mc = dev_id;\n\tstruct milbeaut_hdmac_desc *md;\n\tu32 val;\n\n\tspin_lock(&mc->vc.lock);\n\n\t \n\tval = readl_relaxed(mc->reg_ch_base + MLB_HDMAC_DMACB);\n\tval &= ~(FIELD_PREP(MLB_HDMAC_SS, HDMAC_PAUSE));\n\twritel_relaxed(val, mc->reg_ch_base + MLB_HDMAC_DMACB);\n\tval &= ~MLB_HDMAC_EI;\n\tval &= ~MLB_HDMAC_CI;\n\twritel_relaxed(val, mc->reg_ch_base + MLB_HDMAC_DMACB);\n\n\tmd = mc->md;\n\tif (!md)\n\t\tgoto out;\n\n\tmd->sg_cur++;\n\n\tif (md->sg_cur >= md->sg_len) {\n\t\tvchan_cookie_complete(&md->vd);\n\t\tmd = milbeaut_hdmac_next_desc(mc);\n\t\tif (!md)\n\t\t\tgoto out;\n\t}\n\n\tmilbeaut_chan_start(mc, md);\n\nout:\n\tspin_unlock(&mc->vc.lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void milbeaut_hdmac_free_chan_resources(struct dma_chan *chan)\n{\n\tvchan_free_chan_resources(to_virt_chan(chan));\n}\n\nstatic int\nmilbeaut_hdmac_chan_config(struct dma_chan *chan, struct dma_slave_config *cfg)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_chan *mc = to_milbeaut_hdmac_chan(vc);\n\n\tspin_lock(&mc->vc.lock);\n\tmc->cfg = *cfg;\n\tspin_unlock(&mc->vc.lock);\n\n\treturn 0;\n}\n\nstatic int milbeaut_hdmac_chan_pause(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_chan *mc = to_milbeaut_hdmac_chan(vc);\n\tu32 val;\n\n\tspin_lock(&mc->vc.lock);\n\tval = readl_relaxed(mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tval |= MLB_HDMAC_PB;\n\twritel_relaxed(val, mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tspin_unlock(&mc->vc.lock);\n\n\treturn 0;\n}\n\nstatic int milbeaut_hdmac_chan_resume(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_chan *mc = to_milbeaut_hdmac_chan(vc);\n\tu32 val;\n\n\tspin_lock(&mc->vc.lock);\n\tval = readl_relaxed(mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tval &= ~MLB_HDMAC_PB;\n\twritel_relaxed(val, mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tspin_unlock(&mc->vc.lock);\n\n\treturn 0;\n}\n\nstatic struct dma_async_tx_descriptor *\nmilbeaut_hdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\t\t     unsigned int sg_len,\n\t\t\t     enum dma_transfer_direction direction,\n\t\t\t     unsigned long flags, void *context)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_desc *md;\n\tint i;\n\n\tif (!is_slave_direction(direction))\n\t\treturn NULL;\n\n\tmd = kzalloc(sizeof(*md), GFP_NOWAIT);\n\tif (!md)\n\t\treturn NULL;\n\n\tmd->sgl = kcalloc(sg_len, sizeof(*sgl), GFP_NOWAIT);\n\tif (!md->sgl) {\n\t\tkfree(md);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < sg_len; i++)\n\t\tmd->sgl[i] = sgl[i];\n\n\tmd->sg_len = sg_len;\n\tmd->dir = direction;\n\n\treturn vchan_tx_prep(vc, &md->vd, flags);\n}\n\nstatic int milbeaut_hdmac_terminate_all(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_chan *mc = to_milbeaut_hdmac_chan(vc);\n\tunsigned long flags;\n\tu32 val;\n\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tval = readl_relaxed(mc->reg_ch_base + MLB_HDMAC_DMACA);\n\tval &= ~MLB_HDMAC_EB;  \n\twritel_relaxed(val, mc->reg_ch_base + MLB_HDMAC_DMACA);\n\n\tif (mc->md) {\n\t\tvchan_terminate_vdesc(&mc->md->vd);\n\t\tmc->md = NULL;\n\t}\n\n\tvchan_get_all_descriptors(vc, &head);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tvchan_dma_desc_free_list(vc, &head);\n\n\treturn 0;\n}\n\nstatic void milbeaut_hdmac_synchronize(struct dma_chan *chan)\n{\n\tvchan_synchronize(to_virt_chan(chan));\n}\n\nstatic enum dma_status milbeaut_hdmac_tx_status(struct dma_chan *chan,\n\t\t\t\t\t\tdma_cookie_t cookie,\n\t\t\t\t\t\tstruct dma_tx_state *txstate)\n{\n\tstruct virt_dma_chan *vc;\n\tstruct virt_dma_desc *vd;\n\tstruct milbeaut_hdmac_chan *mc;\n\tstruct milbeaut_hdmac_desc *md = NULL;\n\tenum dma_status stat;\n\tunsigned long flags;\n\tint i;\n\n\tstat = dma_cookie_status(chan, cookie, txstate);\n\t \n\tif (stat == DMA_COMPLETE || !txstate)\n\t\treturn stat;\n\n\tvc = to_virt_chan(chan);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tmc = to_milbeaut_hdmac_chan(vc);\n\n\t \n\tif (mc->md && mc->md->vd.tx.cookie == cookie) {\n\t\tstruct scatterlist *sg;\n\t\tu32 done;\n\n\t\tmd = mc->md;\n\t\tsg = &md->sgl[md->sg_cur];\n\n\t\tif (md->dir == DMA_DEV_TO_MEM)\n\t\t\tdone = readl_relaxed(mc->reg_ch_base\n\t\t\t\t\t     + MLB_HDMAC_DMACDA);\n\t\telse\n\t\t\tdone = readl_relaxed(mc->reg_ch_base\n\t\t\t\t\t     + MLB_HDMAC_DMACSA);\n\t\tdone -= sg_dma_address(sg);\n\n\t\ttxstate->residue = -done;\n\t}\n\n\tif (!md) {\n\t\tvd = vchan_find_desc(vc, cookie);\n\t\tif (vd)\n\t\t\tmd = to_milbeaut_hdmac_desc(vd);\n\t}\n\n\tif (md) {\n\t\t \n\t\tfor (i = md->sg_cur; i < md->sg_len; i++)\n\t\t\ttxstate->residue += sg_dma_len(&md->sgl[i]);\n\t}\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\treturn stat;\n}\n\nstatic void milbeaut_hdmac_issue_pending(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct milbeaut_hdmac_chan *mc = to_milbeaut_hdmac_chan(vc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tif (vchan_issue_pending(vc) && !mc->md)\n\t\tmilbeaut_hdmac_start(mc);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n}\n\nstatic void milbeaut_hdmac_desc_free(struct virt_dma_desc *vd)\n{\n\tstruct milbeaut_hdmac_desc *md = to_milbeaut_hdmac_desc(vd);\n\n\tkfree(md->sgl);\n\tkfree(md);\n}\n\nstatic struct dma_chan *\nmilbeaut_hdmac_xlate(struct of_phandle_args *dma_spec, struct of_dma *of_dma)\n{\n\tstruct milbeaut_hdmac_device *mdev = of_dma->of_dma_data;\n\tstruct milbeaut_hdmac_chan *mc;\n\tstruct virt_dma_chan *vc;\n\tstruct dma_chan *chan;\n\n\tif (dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\tchan = dma_get_any_slave_channel(&mdev->ddev);\n\tif (!chan)\n\t\treturn NULL;\n\n\tvc = to_virt_chan(chan);\n\tmc = to_milbeaut_hdmac_chan(vc);\n\tmc->slave_id = dma_spec->args[0];\n\n\treturn chan;\n}\n\nstatic int milbeaut_hdmac_chan_init(struct platform_device *pdev,\n\t\t\t\t    struct milbeaut_hdmac_device *mdev,\n\t\t\t\t    int chan_id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct milbeaut_hdmac_chan *mc = &mdev->channels[chan_id];\n\tchar *irq_name;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, chan_id);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_name = devm_kasprintf(dev, GFP_KERNEL, \"milbeaut-hdmac-%d\",\n\t\t\t\t  chan_id);\n\tif (!irq_name)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(dev, irq, milbeaut_hdmac_interrupt,\n\t\t\t       IRQF_SHARED, irq_name, mc);\n\tif (ret)\n\t\treturn ret;\n\n\tmc->mdev = mdev;\n\tmc->reg_ch_base = mdev->reg_base + MLB_HDMAC_CH_STRIDE * (chan_id + 1);\n\tmc->vc.desc_free = milbeaut_hdmac_desc_free;\n\tvchan_init(&mc->vc, &mdev->ddev);\n\n\treturn 0;\n}\n\nstatic int milbeaut_hdmac_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct milbeaut_hdmac_device *mdev;\n\tstruct dma_device *ddev;\n\tint nr_chans, ret, i;\n\n\tnr_chans = platform_irq_count(pdev);\n\tif (nr_chans < 0)\n\t\treturn nr_chans;\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tmdev = devm_kzalloc(dev, struct_size(mdev, channels, nr_chans),\n\t\t\t    GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->reg_base))\n\t\treturn PTR_ERR(mdev->reg_base);\n\n\tmdev->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(mdev->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(mdev->clk);\n\t}\n\n\tret = clk_prepare_enable(mdev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tddev = &mdev->ddev;\n\tddev->dev = dev;\n\tdma_cap_set(DMA_SLAVE, ddev->cap_mask);\n\tdma_cap_set(DMA_PRIVATE, ddev->cap_mask);\n\tddev->src_addr_widths = MLB_HDMAC_BUSWIDTHS;\n\tddev->dst_addr_widths = MLB_HDMAC_BUSWIDTHS;\n\tddev->directions = BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\n\tddev->device_free_chan_resources = milbeaut_hdmac_free_chan_resources;\n\tddev->device_config = milbeaut_hdmac_chan_config;\n\tddev->device_pause = milbeaut_hdmac_chan_pause;\n\tddev->device_resume = milbeaut_hdmac_chan_resume;\n\tddev->device_prep_slave_sg = milbeaut_hdmac_prep_slave_sg;\n\tddev->device_terminate_all = milbeaut_hdmac_terminate_all;\n\tddev->device_synchronize = milbeaut_hdmac_synchronize;\n\tddev->device_tx_status = milbeaut_hdmac_tx_status;\n\tddev->device_issue_pending = milbeaut_hdmac_issue_pending;\n\tINIT_LIST_HEAD(&ddev->channels);\n\n\tfor (i = 0; i < nr_chans; i++) {\n\t\tret = milbeaut_hdmac_chan_init(pdev, mdev, i);\n\t\tif (ret)\n\t\t\tgoto disable_clk;\n\t}\n\n\tret = dma_async_device_register(ddev);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = of_dma_controller_register(dev->of_node,\n\t\t\t\t\t milbeaut_hdmac_xlate, mdev);\n\tif (ret)\n\t\tgoto unregister_dmac;\n\n\tplatform_set_drvdata(pdev, mdev);\n\n\treturn 0;\n\nunregister_dmac:\n\tdma_async_device_unregister(ddev);\ndisable_clk:\n\tclk_disable_unprepare(mdev->clk);\n\n\treturn ret;\n}\n\nstatic int milbeaut_hdmac_remove(struct platform_device *pdev)\n{\n\tstruct milbeaut_hdmac_device *mdev = platform_get_drvdata(pdev);\n\tstruct dma_chan *chan;\n\tint ret;\n\n\t \n\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {\n\t\tret = dmaengine_terminate_sync(chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmilbeaut_hdmac_free_chan_resources(chan);\n\t}\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&mdev->ddev);\n\tclk_disable_unprepare(mdev->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id milbeaut_hdmac_match[] = {\n\t{ .compatible = \"socionext,milbeaut-m10v-hdmac\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, milbeaut_hdmac_match);\n\nstatic struct platform_driver milbeaut_hdmac_driver = {\n\t.probe = milbeaut_hdmac_probe,\n\t.remove = milbeaut_hdmac_remove,\n\t.driver = {\n\t\t.name = \"milbeaut-m10v-hdmac\",\n\t\t.of_match_table = milbeaut_hdmac_match,\n\t},\n};\nmodule_platform_driver(milbeaut_hdmac_driver);\n\nMODULE_DESCRIPTION(\"Milbeaut HDMAC DmaEngine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}