{
  "module_name": "fsldma.h",
  "hash_id": "37d837075dcc06ad01b119134ab8189df8d531e857a7d107348808ff31f9dffb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/fsldma.h",
  "human_readable_source": " \n \n#ifndef __DMA_FSLDMA_H\n#define __DMA_FSLDMA_H\n\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/dmaengine.h>\n\n \n#define FSL_DMA_MR_CS\t\t0x00000001\n#define FSL_DMA_MR_CC\t\t0x00000002\n#define FSL_DMA_MR_CA\t\t0x00000008\n#define FSL_DMA_MR_EIE\t\t0x00000040\n#define FSL_DMA_MR_XFE\t\t0x00000020\n#define FSL_DMA_MR_EOLNIE\t0x00000100\n#define FSL_DMA_MR_EOLSIE\t0x00000080\n#define FSL_DMA_MR_EOSIE\t0x00000200\n#define FSL_DMA_MR_CDSM\t\t0x00000010\n#define FSL_DMA_MR_CTM\t\t0x00000004\n#define FSL_DMA_MR_EMP_EN\t0x00200000\n#define FSL_DMA_MR_EMS_EN\t0x00040000\n#define FSL_DMA_MR_DAHE\t\t0x00002000\n#define FSL_DMA_MR_SAHE\t\t0x00001000\n\n#define FSL_DMA_MR_SAHTS_MASK\t0x0000C000\n#define FSL_DMA_MR_DAHTS_MASK\t0x00030000\n#define FSL_DMA_MR_BWC_MASK\t0x0f000000\n\n \n#define FSL_DMA_MR_BWC         0x0A000000\n\n \n#define FSL_DMA_MR_EOTIE\t0x00000080\n#define FSL_DMA_MR_PRC_RM\t0x00000800\n\n#define FSL_DMA_SR_CH\t\t0x00000020\n#define FSL_DMA_SR_PE\t\t0x00000010\n#define FSL_DMA_SR_CB\t\t0x00000004\n#define FSL_DMA_SR_TE\t\t0x00000080\n#define FSL_DMA_SR_EOSI\t\t0x00000002\n#define FSL_DMA_SR_EOLSI\t0x00000001\n#define FSL_DMA_SR_EOCDI\t0x00000001\n#define FSL_DMA_SR_EOLNI\t0x00000008\n\n#define FSL_DMA_SATR_SBPATMU\t\t\t0x20000000\n#define FSL_DMA_SATR_STRANSINT_RIO\t\t0x00c00000\n#define FSL_DMA_SATR_SREADTYPE_SNOOP_READ\t0x00050000\n#define FSL_DMA_SATR_SREADTYPE_BP_IORH\t\t0x00020000\n#define FSL_DMA_SATR_SREADTYPE_BP_NREAD\t\t0x00040000\n#define FSL_DMA_SATR_SREADTYPE_BP_MREAD\t\t0x00070000\n\n#define FSL_DMA_DATR_DBPATMU\t\t\t0x20000000\n#define FSL_DMA_DATR_DTRANSINT_RIO\t\t0x00c00000\n#define FSL_DMA_DATR_DWRITETYPE_SNOOP_WRITE\t0x00050000\n#define FSL_DMA_DATR_DWRITETYPE_BP_FLUSH\t0x00010000\n\n#define FSL_DMA_EOL\t\t((u64)0x1)\n#define FSL_DMA_SNEN\t\t((u64)0x10)\n#define FSL_DMA_EOSIE\t\t0x8\n#define FSL_DMA_NLDA_MASK\t(~(u64)0x1f)\n\n#define FSL_DMA_BCR_MAX_CNT\t0x03ffffffu\n\n#define FSL_DMA_DGSR_TE\t\t0x80\n#define FSL_DMA_DGSR_CH\t\t0x20\n#define FSL_DMA_DGSR_PE\t\t0x10\n#define FSL_DMA_DGSR_EOLNI\t0x08\n#define FSL_DMA_DGSR_CB\t\t0x04\n#define FSL_DMA_DGSR_EOSI\t0x02\n#define FSL_DMA_DGSR_EOLSI\t0x01\n\n#define FSL_DMA_BUSWIDTHS\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_8_BYTES))\ntypedef u64 __bitwise v64;\ntypedef u32 __bitwise v32;\n\nstruct fsl_dma_ld_hw {\n\tv64 src_addr;\n\tv64 dst_addr;\n\tv64 next_ln_addr;\n\tv32 count;\n\tv32 reserve;\n} __attribute__((aligned(32)));\n\nstruct fsl_desc_sw {\n\tstruct fsl_dma_ld_hw hw;\n\tstruct list_head node;\n\tstruct list_head tx_list;\n\tstruct dma_async_tx_descriptor async_tx;\n} __attribute__((aligned(32)));\n\nstruct fsldma_chan_regs {\n\tu32 mr;\t\t \n\tu32 sr;\t\t \n\tu64 cdar;\t \n\tu64 sar;\t \n\tu64 dar;\t \n\tu32 bcr;\t \n\tu64 ndar;\t \n};\n\nstruct fsldma_chan;\n#define FSL_DMA_MAX_CHANS_PER_DEVICE 8\n\nstruct fsldma_device {\n\tvoid __iomem *regs;\t \n\tstruct device *dev;\n\tstruct dma_device common;\n\tstruct fsldma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];\n\tu32 feature;\t\t \n\tint irq;\t\t \n};\n\n \n#define FSL_DMA_LITTLE_ENDIAN\t0x00000000\n#define FSL_DMA_BIG_ENDIAN\t0x00000001\n\n#define FSL_DMA_IP_MASK\t\t0x00000ff0\n#define FSL_DMA_IP_85XX\t\t0x00000010\n#define FSL_DMA_IP_83XX\t\t0x00000020\n\n#define FSL_DMA_CHAN_PAUSE_EXT\t0x00001000\n#define FSL_DMA_CHAN_START_EXT\t0x00002000\n\n#ifdef CONFIG_PM\nstruct fsldma_chan_regs_save {\n\tu32 mr;\n};\n\nenum fsldma_pm_state {\n\tRUNNING = 0,\n\tSUSPENDED,\n};\n#endif\n\nstruct fsldma_chan {\n\tchar name[8];\t\t\t \n\tstruct fsldma_chan_regs __iomem *regs;\n\tspinlock_t desc_lock;\t\t \n\t \n\tstruct list_head ld_pending;\n\t \n\tstruct list_head ld_running;\n\t \n\tstruct list_head ld_completed;\t \n\tstruct dma_chan common;\t\t \n\tstruct dma_pool *desc_pool;\t \n\tstruct device *dev;\t\t \n\tint irq;\t\t\t \n\tint id;\t\t\t\t \n\tstruct tasklet_struct tasklet;\n\tu32 feature;\n\tbool idle;\t\t\t \n#ifdef CONFIG_PM\n\tstruct fsldma_chan_regs_save regs_save;\n\tenum fsldma_pm_state pm_state;\n#endif\n\n\tvoid (*toggle_ext_pause)(struct fsldma_chan *fsl_chan, int enable);\n\tvoid (*toggle_ext_start)(struct fsldma_chan *fsl_chan, int enable);\n\tvoid (*set_src_loop_size)(struct fsldma_chan *fsl_chan, int size);\n\tvoid (*set_dst_loop_size)(struct fsldma_chan *fsl_chan, int size);\n\tvoid (*set_request_count)(struct fsldma_chan *fsl_chan, int size);\n};\n\n#define to_fsl_chan(chan) container_of(chan, struct fsldma_chan, common)\n#define to_fsl_desc(lh) container_of(lh, struct fsl_desc_sw, node)\n#define tx_to_fsl_desc(tx) container_of(tx, struct fsl_desc_sw, async_tx)\n\n#ifdef\tCONFIG_PPC\n#define fsl_ioread32(p)\t\tin_le32(p)\n#define fsl_ioread32be(p)\tin_be32(p)\n#define fsl_iowrite32(v, p)\tout_le32(p, v)\n#define fsl_iowrite32be(v, p)\tout_be32(p, v)\n\n#ifdef __powerpc64__\n#define fsl_ioread64(p)\t\tin_le64(p)\n#define fsl_ioread64be(p)\tin_be64(p)\n#define fsl_iowrite64(v, p)\tout_le64(p, v)\n#define fsl_iowrite64be(v, p)\tout_be64(p, v)\n#else\nstatic u64 fsl_ioread64(const u64 __iomem *addr)\n{\n\tu32 val_lo = in_le32((u32 __iomem *)addr);\n\tu32 val_hi = in_le32((u32 __iomem *)addr + 1);\n\n\treturn ((u64)val_hi << 32) + val_lo;\n}\n\nstatic void fsl_iowrite64(u64 val, u64 __iomem *addr)\n{\n\tout_le32((u32 __iomem *)addr + 1, val >> 32);\n\tout_le32((u32 __iomem *)addr, (u32)val);\n}\n\nstatic u64 fsl_ioread64be(const u64 __iomem *addr)\n{\n\tu32 val_hi = in_be32((u32 __iomem *)addr);\n\tu32 val_lo = in_be32((u32 __iomem *)addr + 1);\n\n\treturn ((u64)val_hi << 32) + val_lo;\n}\n\nstatic void fsl_iowrite64be(u64 val, u64 __iomem *addr)\n{\n\tout_be32((u32 __iomem *)addr, val >> 32);\n\tout_be32((u32 __iomem *)addr + 1, (u32)val);\n}\n#endif\n#endif\n\n#if defined(CONFIG_ARM64) || defined(CONFIG_ARM)\n#define fsl_ioread32(p)\t\tioread32(p)\n#define fsl_ioread32be(p)\tioread32be(p)\n#define fsl_iowrite32(v, p)\tiowrite32(v, p)\n#define fsl_iowrite32be(v, p)\tiowrite32be(v, p)\n#define fsl_ioread64(p)\t\tioread64(p)\n#define fsl_ioread64be(p)\tioread64be(p)\n#define fsl_iowrite64(v, p)\tiowrite64(v, p)\n#define fsl_iowrite64be(v, p)\tiowrite64be(v, p)\n#endif\n\n#define FSL_DMA_IN(fsl_dma, addr, width)\t\t\t\\\n\t\t(((fsl_dma)->feature & FSL_DMA_BIG_ENDIAN) ?\t\\\n\t\t\tfsl_ioread##width##be(addr) : fsl_ioread##width(addr))\n\n#define FSL_DMA_OUT(fsl_dma, addr, val, width)\t\t\t\\\n\t\t(((fsl_dma)->feature & FSL_DMA_BIG_ENDIAN) ?\t\\\n\t\t\tfsl_iowrite##width##be(val, addr) : fsl_iowrite\t\\\n\t\t##width(val, addr))\n\n#define DMA_TO_CPU(fsl_chan, d, width)\t\t\t\t\t\\\n\t\t(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?\t\t\\\n\t\t\tbe##width##_to_cpu((__force __be##width)(v##width)d) : \\\n\t\t\tle##width##_to_cpu((__force __le##width)(v##width)d))\n#define CPU_TO_DMA(fsl_chan, c, width)\t\t\t\t\t\\\n\t\t(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?\t\t\\\n\t\t\t(__force v##width)cpu_to_be##width(c) :\t\t\\\n\t\t\t(__force v##width)cpu_to_le##width(c))\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}