{
  "module_name": "virt-dma.c",
  "hash_id": "fb4ad7f8a23e0a9eac53f60805a25c4b19debba9160e5128703d37950471ded0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/virt-dma.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n\n#include \"virt-dma.h\"\n\nstatic struct virt_dma_desc *to_virt_desc(struct dma_async_tx_descriptor *tx)\n{\n\treturn container_of(tx, struct virt_dma_desc, tx);\n}\n\ndma_cookie_t vchan_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(tx->chan);\n\tstruct virt_dma_desc *vd = to_virt_desc(tx);\n\tunsigned long flags;\n\tdma_cookie_t cookie;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tcookie = dma_cookie_assign(tx);\n\n\tlist_move_tail(&vd->node, &vc->desc_submitted);\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tdev_dbg(vc->chan.device->dev, \"vchan %p: txd %p[%x]: submitted\\n\",\n\t\tvc, vd, cookie);\n\n\treturn cookie;\n}\nEXPORT_SYMBOL_GPL(vchan_tx_submit);\n\n \nint vchan_tx_desc_free(struct dma_async_tx_descriptor *tx)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(tx->chan);\n\tstruct virt_dma_desc *vd = to_virt_desc(tx);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tlist_del(&vd->node);\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tdev_dbg(vc->chan.device->dev, \"vchan %p: txd %p[%x]: freeing\\n\",\n\t\tvc, vd, vd->tx.cookie);\n\tvc->desc_free(vd);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vchan_tx_desc_free);\n\nstruct virt_dma_desc *vchan_find_desc(struct virt_dma_chan *vc,\n\tdma_cookie_t cookie)\n{\n\tstruct virt_dma_desc *vd;\n\n\tlist_for_each_entry(vd, &vc->desc_issued, node)\n\t\tif (vd->tx.cookie == cookie)\n\t\t\treturn vd;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(vchan_find_desc);\n\n \nstatic void vchan_complete(struct tasklet_struct *t)\n{\n\tstruct virt_dma_chan *vc = from_tasklet(vc, t, task);\n\tstruct virt_dma_desc *vd, *_vd;\n\tstruct dmaengine_desc_callback cb;\n\tLIST_HEAD(head);\n\n\tspin_lock_irq(&vc->lock);\n\tlist_splice_tail_init(&vc->desc_completed, &head);\n\tvd = vc->cyclic;\n\tif (vd) {\n\t\tvc->cyclic = NULL;\n\t\tdmaengine_desc_get_callback(&vd->tx, &cb);\n\t} else {\n\t\tmemset(&cb, 0, sizeof(cb));\n\t}\n\tspin_unlock_irq(&vc->lock);\n\n\tdmaengine_desc_callback_invoke(&cb, &vd->tx_result);\n\n\tlist_for_each_entry_safe(vd, _vd, &head, node) {\n\t\tdmaengine_desc_get_callback(&vd->tx, &cb);\n\n\t\tlist_del(&vd->node);\n\t\tdmaengine_desc_callback_invoke(&cb, &vd->tx_result);\n\t\tvchan_vdesc_fini(vd);\n\t}\n}\n\nvoid vchan_dma_desc_free_list(struct virt_dma_chan *vc, struct list_head *head)\n{\n\tstruct virt_dma_desc *vd, *_vd;\n\n\tlist_for_each_entry_safe(vd, _vd, head, node) {\n\t\tlist_del(&vd->node);\n\t\tvchan_vdesc_fini(vd);\n\t}\n}\nEXPORT_SYMBOL_GPL(vchan_dma_desc_free_list);\n\nvoid vchan_init(struct virt_dma_chan *vc, struct dma_device *dmadev)\n{\n\tdma_cookie_init(&vc->chan);\n\n\tspin_lock_init(&vc->lock);\n\tINIT_LIST_HEAD(&vc->desc_allocated);\n\tINIT_LIST_HEAD(&vc->desc_submitted);\n\tINIT_LIST_HEAD(&vc->desc_issued);\n\tINIT_LIST_HEAD(&vc->desc_completed);\n\tINIT_LIST_HEAD(&vc->desc_terminated);\n\n\ttasklet_setup(&vc->task, vchan_complete);\n\n\tvc->chan.device = dmadev;\n\tlist_add_tail(&vc->chan.device_node, &dmadev->channels);\n}\nEXPORT_SYMBOL_GPL(vchan_init);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}