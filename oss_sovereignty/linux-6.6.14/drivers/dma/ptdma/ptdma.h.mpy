{
  "module_name": "ptdma.h",
  "hash_id": "d9b3fe5bf8b682f1bed03eaa2ee3ef99ecb19d3c85bb2c4c26199b226ed7348f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ptdma/ptdma.h",
  "human_readable_source": " \n \n\n#ifndef __PT_DEV_H__\n#define __PT_DEV_H__\n\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/dmapool.h>\n\n#include \"../virt-dma.h\"\n\n#define MAX_PT_NAME_LEN\t\t\t16\n#define MAX_DMAPOOL_NAME_LEN\t\t32\n\n#define MAX_HW_QUEUES\t\t\t1\n#define MAX_CMD_QLEN\t\t\t100\n\n#define PT_ENGINE_PASSTHRU\t\t5\n\n \n#define IRQ_MASK_REG\t\t\t0x040\n#define IRQ_STATUS_REG\t\t\t0x200\n\n#define CMD_Q_ERROR(__qs)\t\t((__qs) & 0x0000003f)\n\n#define CMD_QUEUE_PRIO_OFFSET\t\t0x00\n#define CMD_REQID_CONFIG_OFFSET\t\t0x04\n#define CMD_TIMEOUT_OFFSET\t\t0x08\n#define CMD_PT_VERSION\t\t\t0x10\n\n#define CMD_Q_CONTROL_BASE\t\t0x0000\n#define CMD_Q_TAIL_LO_BASE\t\t0x0004\n#define CMD_Q_HEAD_LO_BASE\t\t0x0008\n#define CMD_Q_INT_ENABLE_BASE\t\t0x000C\n#define CMD_Q_INTERRUPT_STATUS_BASE\t0x0010\n\n#define CMD_Q_STATUS_BASE\t\t0x0100\n#define CMD_Q_INT_STATUS_BASE\t\t0x0104\n#define CMD_Q_DMA_STATUS_BASE\t\t0x0108\n#define CMD_Q_DMA_READ_STATUS_BASE\t0x010C\n#define CMD_Q_DMA_WRITE_STATUS_BASE\t0x0110\n#define CMD_Q_ABORT_BASE\t\t0x0114\n#define CMD_Q_AX_CACHE_BASE\t\t0x0118\n\n#define CMD_CONFIG_OFFSET\t\t0x1120\n#define CMD_CLK_GATE_CTL_OFFSET\t\t0x6004\n\n#define CMD_DESC_DW0_VAL\t\t0x500012\n\n \n#define CMD_Q_STATUS_INCR\t\t0x1000\n\n \n#define CMD_CONFIG_REQID\t\t0\n#define CMD_TIMEOUT_DISABLE\t\t0\n#define CMD_CLK_DYN_GATING_DIS\t\t0\n#define CMD_CLK_SW_GATE_MODE\t\t0\n#define CMD_CLK_GATE_CTL\t\t0\n#define CMD_QUEUE_PRIO\t\t\tGENMASK(2, 1)\n#define CMD_CONFIG_VHB_EN\t\tBIT(0)\n#define CMD_CLK_DYN_GATING_EN\t\tBIT(0)\n#define CMD_CLK_HW_GATE_MODE\t\tBIT(0)\n#define CMD_CLK_GATE_ON_DELAY\t\tBIT(12)\n#define CMD_CLK_GATE_OFF_DELAY\t\tBIT(12)\n\n#define CMD_CLK_GATE_CONFIG\t\t(CMD_CLK_GATE_CTL | \\\n\t\t\t\t\tCMD_CLK_HW_GATE_MODE | \\\n\t\t\t\t\tCMD_CLK_GATE_ON_DELAY | \\\n\t\t\t\t\tCMD_CLK_DYN_GATING_EN | \\\n\t\t\t\t\tCMD_CLK_GATE_OFF_DELAY)\n\n#define CMD_Q_LEN\t\t\t32\n#define CMD_Q_RUN\t\t\tBIT(0)\n#define CMD_Q_HALT\t\t\tBIT(1)\n#define CMD_Q_MEM_LOCATION\t\tBIT(2)\n#define CMD_Q_SIZE_MASK\t\t\tGENMASK(4, 0)\n#define CMD_Q_SIZE\t\t\tGENMASK(7, 3)\n#define CMD_Q_SHIFT\t\t\tGENMASK(1, 0)\n#define QUEUE_SIZE_VAL\t\t\t((ffs(CMD_Q_LEN) - 2) & \\\n\t\t\t\t\t\t\t\t  CMD_Q_SIZE_MASK)\n#define Q_PTR_MASK\t\t\t(2 << (QUEUE_SIZE_VAL + 5) - 1)\n#define Q_DESC_SIZE\t\t\tsizeof(struct ptdma_desc)\n#define Q_SIZE(n)\t\t\t(CMD_Q_LEN * (n))\n\n#define INT_COMPLETION\t\t\tBIT(0)\n#define INT_ERROR\t\t\tBIT(1)\n#define INT_QUEUE_STOPPED\t\tBIT(2)\n#define INT_EMPTY_QUEUE\t\t\tBIT(3)\n#define SUPPORTED_INTERRUPTS\t\t(INT_COMPLETION | INT_ERROR)\n\n \n#define LSB_START\t\t\t0\n#define LSB_END\t\t\t\t127\n#define LSB_COUNT\t\t\t(LSB_END - LSB_START + 1)\n\n#define PT_DMAPOOL_MAX_SIZE\t\t64\n#define PT_DMAPOOL_ALIGN\t\tBIT(5)\n\n#define PT_PASSTHRU_BLOCKSIZE\t\t512\n\nstruct pt_device;\n\nstruct pt_tasklet_data {\n\tstruct completion completion;\n\tstruct pt_cmd *cmd;\n};\n\n \nstruct pt_passthru_engine {\n\tdma_addr_t mask;\n\tu32 mask_len;\t\t \n\n\tdma_addr_t src_dma, dst_dma;\n\tu64 src_len;\t\t \n};\n\n \nstruct pt_cmd {\n\tstruct list_head entry;\n\tstruct work_struct work;\n\tstruct pt_device *pt;\n\tint ret;\n\tu32 engine;\n\tu32 engine_error;\n\tstruct pt_passthru_engine passthru;\n\t \n\tvoid (*pt_cmd_callback)(void *data, int err);\n\tvoid *data;\n};\n\nstruct pt_dma_desc {\n\tstruct virt_dma_desc vd;\n\tstruct pt_device *pt;\n\tenum dma_status status;\n\tsize_t len;\n\tbool issued_to_hw;\n\tstruct pt_cmd pt_cmd;\n};\n\nstruct pt_dma_chan {\n\tstruct virt_dma_chan vc;\n\tstruct pt_device *pt;\n};\n\nstruct pt_cmd_queue {\n\tstruct pt_device *pt;\n\n\t \n\tstruct dma_pool *dma_pool;\n\n\t \n\tstruct ptdma_desc *qbase;\n\n\t \n\tspinlock_t q_lock ____cacheline_aligned;\n\tunsigned int qidx;\n\n\tunsigned int qsize;\n\tdma_addr_t qbase_dma;\n\tdma_addr_t qdma_tail;\n\n\tunsigned int active;\n\tunsigned int suspended;\n\n\t \n\tbool int_en;\n\n\t \n\tvoid __iomem *reg_control;\n\tu32 qcontrol;  \n\n\t \n\tu32 int_status;\n\tu32 q_status;\n\tu32 q_int_status;\n\tu32 cmd_error;\n\t \n\tunsigned long total_pt_ops;\n} ____cacheline_aligned;\n\nstruct pt_device {\n\tstruct list_head entry;\n\n\tunsigned int ord;\n\tchar name[MAX_PT_NAME_LEN];\n\n\tstruct device *dev;\n\n\t \n\tstruct pt_msix *pt_msix;\n\n\tstruct pt_dev_vdata *dev_vdata;\n\n\tunsigned int pt_irq;\n\n\t \n\tvoid __iomem *io_regs;\n\n\tspinlock_t cmd_lock ____cacheline_aligned;\n\tunsigned int cmd_count;\n\tstruct list_head cmd;\n\n\t \n\tstruct pt_cmd_queue cmd_q;\n\n\t \n\tstruct dma_device dma_dev;\n\tstruct pt_dma_chan *pt_dma_chan;\n\tstruct kmem_cache *dma_cmd_cache;\n\tstruct kmem_cache *dma_desc_cache;\n\n\twait_queue_head_t lsb_queue;\n\n\t \n\tunsigned long total_interrupts;\n\n\tstruct pt_tasklet_data tdata;\n};\n\n \n\n#define DWORD0_SOC\tBIT(0)\n#define DWORD0_IOC\tBIT(1)\n\nstruct dword3 {\n\tunsigned int  src_hi:16;\n\tunsigned int  src_mem:2;\n\tunsigned int  lsb_cxt_id:8;\n\tunsigned int  rsvd1:5;\n\tunsigned int  fixed:1;\n};\n\nstruct dword5 {\n\tunsigned int  dst_hi:16;\n\tunsigned int  dst_mem:2;\n\tunsigned int  rsvd1:13;\n\tunsigned int  fixed:1;\n};\n\nstruct ptdma_desc {\n\tu32 dw0;\n\tu32 length;\n\tu32 src_lo;\n\tstruct dword3 dw3;\n\tu32 dst_lo;\n\tstruct dword5 dw5;\n\t__le32 rsvd1;\n\t__le32 rsvd2;\n};\n\n \nstruct pt_dev_vdata {\n\tconst unsigned int bar;\n};\n\nint pt_dmaengine_register(struct pt_device *pt);\nvoid pt_dmaengine_unregister(struct pt_device *pt);\n\nvoid ptdma_debugfs_setup(struct pt_device *pt);\nint pt_core_init(struct pt_device *pt);\nvoid pt_core_destroy(struct pt_device *pt);\n\nint pt_core_perform_passthru(struct pt_cmd_queue *cmd_q,\n\t\t\t     struct pt_passthru_engine *pt_engine);\n\nvoid pt_check_status_trans(struct pt_device *pt, struct pt_cmd_queue *cmd_q);\nvoid pt_start_queue(struct pt_cmd_queue *cmd_q);\nvoid pt_stop_queue(struct pt_cmd_queue *cmd_q);\n\nstatic inline void pt_core_disable_queue_interrupts(struct pt_device *pt)\n{\n\tiowrite32(0, pt->cmd_q.reg_control + 0x000C);\n}\n\nstatic inline void pt_core_enable_queue_interrupts(struct pt_device *pt)\n{\n\tiowrite32(SUPPORTED_INTERRUPTS, pt->cmd_q.reg_control + 0x000C);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}