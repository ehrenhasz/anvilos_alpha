{
  "module_name": "ptdma-pci.c",
  "hash_id": "737761ae981498b803ce7588e8c37acaca8262ecdcc020ac924689c6fa55c03d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ptdma/ptdma-pci.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/pci_ids.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n\n#include \"ptdma.h\"\n\nstruct pt_msix {\n\tint msix_count;\n\tstruct msix_entry msix_entry;\n};\n\n \nstatic struct pt_device *pt_alloc_struct(struct device *dev)\n{\n\tstruct pt_device *pt;\n\n\tpt = devm_kzalloc(dev, sizeof(*pt), GFP_KERNEL);\n\n\tif (!pt)\n\t\treturn NULL;\n\tpt->dev = dev;\n\n\tINIT_LIST_HEAD(&pt->cmd);\n\n\treturn pt;\n}\n\nstatic int pt_get_msix_irqs(struct pt_device *pt)\n{\n\tstruct pt_msix *pt_msix = pt->pt_msix;\n\tstruct device *dev = pt->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tpt_msix->msix_entry.entry = 0;\n\n\tret = pci_enable_msix_range(pdev, &pt_msix->msix_entry, 1, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpt_msix->msix_count = ret;\n\n\tpt->pt_irq = pt_msix->msix_entry.vector;\n\n\treturn 0;\n}\n\nstatic int pt_get_msi_irq(struct pt_device *pt)\n{\n\tstruct device *dev = pt->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = pci_enable_msi(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpt->pt_irq = pdev->irq;\n\n\treturn 0;\n}\n\nstatic int pt_get_irqs(struct pt_device *pt)\n{\n\tstruct device *dev = pt->dev;\n\tint ret;\n\n\tret = pt_get_msix_irqs(pt);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tdev_err(dev, \"could not enable MSI-X (%d), trying MSI\\n\", ret);\n\tret = pt_get_msi_irq(pt);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tdev_err(dev, \"could not enable MSI (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void pt_free_irqs(struct pt_device *pt)\n{\n\tstruct pt_msix *pt_msix = pt->pt_msix;\n\tstruct device *dev = pt->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (pt_msix->msix_count)\n\t\tpci_disable_msix(pdev);\n\telse if (pt->pt_irq)\n\t\tpci_disable_msi(pdev);\n\n\tpt->pt_irq = 0;\n}\n\nstatic int pt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct pt_device *pt;\n\tstruct pt_msix *pt_msix;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem * const *iomap_table;\n\tint bar_mask;\n\tint ret = -ENOMEM;\n\n\tpt = pt_alloc_struct(dev);\n\tif (!pt)\n\t\tgoto e_err;\n\n\tpt_msix = devm_kzalloc(dev, sizeof(*pt_msix), GFP_KERNEL);\n\tif (!pt_msix)\n\t\tgoto e_err;\n\n\tpt->pt_msix = pt_msix;\n\tpt->dev_vdata = (struct pt_dev_vdata *)id->driver_data;\n\tif (!pt->dev_vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_enable_device failed (%d)\\n\", ret);\n\t\tgoto e_err;\n\t}\n\n\tbar_mask = pci_select_bars(pdev, IORESOURCE_MEM);\n\tret = pcim_iomap_regions(pdev, bar_mask, \"ptdma\");\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_iomap_regions failed (%d)\\n\", ret);\n\t\tgoto e_err;\n\t}\n\n\tiomap_table = pcim_iomap_table(pdev);\n\tif (!iomap_table) {\n\t\tdev_err(dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto e_err;\n\t}\n\n\tpt->io_regs = iomap_table[pt->dev_vdata->bar];\n\tif (!pt->io_regs) {\n\t\tdev_err(dev, \"ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto e_err;\n\t}\n\n\tret = pt_get_irqs(pt);\n\tif (ret)\n\t\tgoto e_err;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"dma_set_mask_and_coherent failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto e_err;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, pt);\n\n\tif (pt->dev_vdata)\n\t\tret = pt_core_init(pt);\n\n\tif (ret)\n\t\tgoto e_err;\n\n\treturn 0;\n\ne_err:\n\tdev_err(dev, \"initialization failed ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void pt_pci_remove(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pt_device *pt = dev_get_drvdata(dev);\n\n\tif (!pt)\n\t\treturn;\n\n\tif (pt->dev_vdata)\n\t\tpt_core_destroy(pt);\n\n\tpt_free_irqs(pt);\n}\n\nstatic const struct pt_dev_vdata dev_vdata[] = {\n\t{\n\t\t.bar = 2,\n\t},\n};\n\nstatic const struct pci_device_id pt_pci_table[] = {\n\t{ PCI_VDEVICE(AMD, 0x1498), (kernel_ulong_t)&dev_vdata[0] },\n\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, pt_pci_table);\n\nstatic struct pci_driver pt_pci_driver = {\n\t.name = \"ptdma\",\n\t.id_table = pt_pci_table,\n\t.probe = pt_pci_probe,\n\t.remove = pt_pci_remove,\n};\n\nmodule_pci_driver(pt_pci_driver);\n\nMODULE_AUTHOR(\"Sanjay R Mehta <sanju.mehta@amd.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"AMD PassThru DMA driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}