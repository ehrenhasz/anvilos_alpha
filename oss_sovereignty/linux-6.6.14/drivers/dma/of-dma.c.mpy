{
  "module_name": "of-dma.c",
  "hash_id": "052f324c77ae3179dfd4def0f72e46e7708b9dfccbb6c24d13b0323e477e9a94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/of-dma.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n\n#include \"dmaengine.h\"\n\nstatic LIST_HEAD(of_dma_list);\nstatic DEFINE_MUTEX(of_dma_lock);\n\n \nstatic struct of_dma *of_dma_find_controller(struct of_phandle_args *dma_spec)\n{\n\tstruct of_dma *ofdma;\n\n\tlist_for_each_entry(ofdma, &of_dma_list, of_dma_controllers)\n\t\tif (ofdma->of_node == dma_spec->np)\n\t\t\treturn ofdma;\n\n\tpr_debug(\"%s: can't find DMA controller %pOF\\n\", __func__,\n\t\t dma_spec->np);\n\n\treturn NULL;\n}\n\n \nstatic struct dma_chan *of_dma_router_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t    struct of_dma *ofdma)\n{\n\tstruct dma_chan\t\t*chan;\n\tstruct of_dma\t\t*ofdma_target;\n\tstruct of_phandle_args\tdma_spec_target;\n\tvoid\t\t\t*route_data;\n\n\t \n\tmemcpy(&dma_spec_target, dma_spec, sizeof(dma_spec_target));\n\troute_data = ofdma->of_dma_route_allocate(&dma_spec_target, ofdma);\n\tif (IS_ERR(route_data))\n\t\treturn NULL;\n\n\tofdma_target = of_dma_find_controller(&dma_spec_target);\n\tif (!ofdma_target) {\n\t\tofdma->dma_router->route_free(ofdma->dma_router->dev,\n\t\t\t\t\t      route_data);\n\t\tchan = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto err;\n\t}\n\n\tchan = ofdma_target->of_dma_xlate(&dma_spec_target, ofdma_target);\n\tif (IS_ERR_OR_NULL(chan)) {\n\t\tofdma->dma_router->route_free(ofdma->dma_router->dev,\n\t\t\t\t\t      route_data);\n\t} else {\n\t\tint ret = 0;\n\n\t\tchan->router = ofdma->dma_router;\n\t\tchan->route_data = route_data;\n\n\t\tif (chan->device->device_router_config)\n\t\t\tret = chan->device->device_router_config(chan);\n\n\t\tif (ret) {\n\t\t\tdma_release_channel(chan);\n\t\t\tchan = ERR_PTR(ret);\n\t\t}\n\t}\n\nerr:\n\t \n\tof_node_put(dma_spec_target.np);\n\treturn chan;\n}\n\n \nint of_dma_controller_register(struct device_node *np,\n\t\t\t\tstruct dma_chan *(*of_dma_xlate)\n\t\t\t\t(struct of_phandle_args *, struct of_dma *),\n\t\t\t\tvoid *data)\n{\n\tstruct of_dma\t*ofdma;\n\n\tif (!np || !of_dma_xlate) {\n\t\tpr_err(\"%s: not enough information provided\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tofdma = kzalloc(sizeof(*ofdma), GFP_KERNEL);\n\tif (!ofdma)\n\t\treturn -ENOMEM;\n\n\tofdma->of_node = np;\n\tofdma->of_dma_xlate = of_dma_xlate;\n\tofdma->of_dma_data = data;\n\n\t \n\tmutex_lock(&of_dma_lock);\n\tlist_add_tail(&ofdma->of_dma_controllers, &of_dma_list);\n\tmutex_unlock(&of_dma_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_dma_controller_register);\n\n \nvoid of_dma_controller_free(struct device_node *np)\n{\n\tstruct of_dma *ofdma;\n\n\tmutex_lock(&of_dma_lock);\n\n\tlist_for_each_entry(ofdma, &of_dma_list, of_dma_controllers)\n\t\tif (ofdma->of_node == np) {\n\t\t\tlist_del(&ofdma->of_dma_controllers);\n\t\t\tkfree(ofdma);\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&of_dma_lock);\n}\nEXPORT_SYMBOL_GPL(of_dma_controller_free);\n\n \nint of_dma_router_register(struct device_node *np,\n\t\t\t   void *(*of_dma_route_allocate)\n\t\t\t   (struct of_phandle_args *, struct of_dma *),\n\t\t\t   struct dma_router *dma_router)\n{\n\tstruct of_dma\t*ofdma;\n\n\tif (!np || !of_dma_route_allocate || !dma_router) {\n\t\tpr_err(\"%s: not enough information provided\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tofdma = kzalloc(sizeof(*ofdma), GFP_KERNEL);\n\tif (!ofdma)\n\t\treturn -ENOMEM;\n\n\tofdma->of_node = np;\n\tofdma->of_dma_xlate = of_dma_router_xlate;\n\tofdma->of_dma_route_allocate = of_dma_route_allocate;\n\tofdma->dma_router = dma_router;\n\n\t \n\tmutex_lock(&of_dma_lock);\n\tlist_add_tail(&ofdma->of_dma_controllers, &of_dma_list);\n\tmutex_unlock(&of_dma_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_dma_router_register);\n\n \nstatic int of_dma_match_channel(struct device_node *np, const char *name,\n\t\t\t\tint index, struct of_phandle_args *dma_spec)\n{\n\tconst char *s;\n\n\tif (of_property_read_string_index(np, \"dma-names\", index, &s))\n\t\treturn -ENODEV;\n\n\tif (strcmp(name, s))\n\t\treturn -ENODEV;\n\n\tif (of_parse_phandle_with_args(np, \"dmas\", \"#dma-cells\", index,\n\t\t\t\t       dma_spec))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstruct dma_chan *of_dma_request_slave_channel(struct device_node *np,\n\t\t\t\t\t      const char *name)\n{\n\tstruct of_phandle_args\tdma_spec;\n\tstruct of_dma\t\t*ofdma;\n\tstruct dma_chan\t\t*chan;\n\tint\t\t\tcount, i, start;\n\tint\t\t\tret_no_channel = -ENODEV;\n\tstatic atomic_t\t\tlast_index;\n\n\tif (!np || !name) {\n\t\tpr_err(\"%s: not enough information provided\\n\", __func__);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tif (!of_property_present(np, \"dmas\"))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcount = of_property_count_strings(np, \"dma-names\");\n\tif (count < 0) {\n\t\tpr_err(\"%s: dma-names property of node '%pOF' missing or empty\\n\",\n\t\t\t__func__, np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tstart = atomic_inc_return(&last_index);\n\tfor (i = 0; i < count; i++) {\n\t\tif (of_dma_match_channel(np, name,\n\t\t\t\t\t (i + start) % count,\n\t\t\t\t\t &dma_spec))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&of_dma_lock);\n\t\tofdma = of_dma_find_controller(&dma_spec);\n\n\t\tif (ofdma) {\n\t\t\tchan = ofdma->of_dma_xlate(&dma_spec, ofdma);\n\t\t} else {\n\t\t\tret_no_channel = -EPROBE_DEFER;\n\t\t\tchan = NULL;\n\t\t}\n\n\t\tmutex_unlock(&of_dma_lock);\n\n\t\tof_node_put(dma_spec.np);\n\n\t\tif (chan)\n\t\t\treturn chan;\n\t}\n\n\treturn ERR_PTR(ret_no_channel);\n}\nEXPORT_SYMBOL_GPL(of_dma_request_slave_channel);\n\n \nstruct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tint count = dma_spec->args_count;\n\tstruct of_dma_filter_info *info = ofdma->of_dma_data;\n\n\tif (!info || !info->filter_fn)\n\t\treturn NULL;\n\n\tif (count != 1)\n\t\treturn NULL;\n\n\treturn __dma_request_channel(&info->dma_cap, info->filter_fn,\n\t\t\t\t     &dma_spec->args[0], dma_spec->np);\n}\nEXPORT_SYMBOL_GPL(of_dma_simple_xlate);\n\n \nstruct dma_chan *of_dma_xlate_by_chan_id(struct of_phandle_args *dma_spec,\n\t\t\t\t\t struct of_dma *ofdma)\n{\n\tstruct dma_device *dev = ofdma->of_dma_data;\n\tstruct dma_chan *chan, *candidate = NULL;\n\n\tif (!dev || dma_spec->args_count != 1)\n\t\treturn NULL;\n\n\tlist_for_each_entry(chan, &dev->channels, device_node)\n\t\tif (chan->chan_id == dma_spec->args[0]) {\n\t\t\tcandidate = chan;\n\t\t\tbreak;\n\t\t}\n\n\tif (!candidate)\n\t\treturn NULL;\n\n\treturn dma_get_slave_channel(candidate);\n}\nEXPORT_SYMBOL_GPL(of_dma_xlate_by_chan_id);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}