{
  "module_name": "moxart-dma.c",
  "hash_id": "12d0e58ad9fd7a7b47c924c8d9a9251113a726d4a61bb8a76d3dad3734e893c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/moxart-dma.c",
  "human_readable_source": "\n \n\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_dma.h>\n#include <linux/bitops.h>\n\n#include <asm/cacheflush.h>\n\n#include \"dmaengine.h\"\n#include \"virt-dma.h\"\n\n#define APB_DMA_MAX_CHANNEL\t\t\t4\n\n#define REG_OFF_ADDRESS_SOURCE\t\t\t0\n#define REG_OFF_ADDRESS_DEST\t\t\t4\n#define REG_OFF_CYCLES\t\t\t\t8\n#define REG_OFF_CTRL\t\t\t\t12\n#define REG_OFF_CHAN_SIZE\t\t\t16\n\n#define APB_DMA_ENABLE\t\t\t\tBIT(0)\n#define APB_DMA_FIN_INT_STS\t\t\tBIT(1)\n#define APB_DMA_FIN_INT_EN\t\t\tBIT(2)\n#define APB_DMA_BURST_MODE\t\t\tBIT(3)\n#define APB_DMA_ERR_INT_STS\t\t\tBIT(4)\n#define APB_DMA_ERR_INT_EN\t\t\tBIT(5)\n\n \n#define APB_DMA_SOURCE_SELECT\t\t\t0x40\n#define APB_DMA_DEST_SELECT\t\t\t0x80\n\n#define APB_DMA_SOURCE\t\t\t\t0x100\n#define APB_DMA_DEST\t\t\t\t0x1000\n\n#define APB_DMA_SOURCE_MASK\t\t\t0x700\n#define APB_DMA_DEST_MASK\t\t\t0x7000\n\n \n#define APB_DMA_SOURCE_INC_0\t\t\t0\n#define APB_DMA_SOURCE_INC_1_4\t\t\t0x100\n#define APB_DMA_SOURCE_INC_2_8\t\t\t0x200\n#define APB_DMA_SOURCE_INC_4_16\t\t\t0x300\n#define APB_DMA_SOURCE_DEC_1_4\t\t\t0x500\n#define APB_DMA_SOURCE_DEC_2_8\t\t\t0x600\n#define APB_DMA_SOURCE_DEC_4_16\t\t\t0x700\n#define APB_DMA_DEST_INC_0\t\t\t0\n#define APB_DMA_DEST_INC_1_4\t\t\t0x1000\n#define APB_DMA_DEST_INC_2_8\t\t\t0x2000\n#define APB_DMA_DEST_INC_4_16\t\t\t0x3000\n#define APB_DMA_DEST_DEC_1_4\t\t\t0x5000\n#define APB_DMA_DEST_DEC_2_8\t\t\t0x6000\n#define APB_DMA_DEST_DEC_4_16\t\t\t0x7000\n\n \n#define APB_DMA_SOURCE_REQ_NO\t\t\t0x1000000\n#define APB_DMA_SOURCE_REQ_NO_MASK\t\t0xf000000\n#define APB_DMA_DEST_REQ_NO\t\t\t0x10000\n#define APB_DMA_DEST_REQ_NO_MASK\t\t0xf0000\n\n#define APB_DMA_DATA_WIDTH\t\t\t0x100000\n#define APB_DMA_DATA_WIDTH_MASK\t\t\t0x300000\n \n#define APB_DMA_DATA_WIDTH_4\t\t\t0\n#define APB_DMA_DATA_WIDTH_2\t\t\t0x100000\n#define APB_DMA_DATA_WIDTH_1\t\t\t0x200000\n\n#define APB_DMA_CYCLES_MASK\t\t\t0x00ffffff\n\n#define MOXART_DMA_DATA_TYPE_S8\t\t\t0x00\n#define MOXART_DMA_DATA_TYPE_S16\t\t0x01\n#define MOXART_DMA_DATA_TYPE_S32\t\t0x02\n\nstruct moxart_sg {\n\tdma_addr_t addr;\n\tuint32_t len;\n};\n\nstruct moxart_desc {\n\tenum dma_transfer_direction\tdma_dir;\n\tdma_addr_t\t\t\tdev_addr;\n\tunsigned int\t\t\tsglen;\n\tunsigned int\t\t\tdma_cycles;\n\tstruct virt_dma_desc\t\tvd;\n\tuint8_t\t\t\t\tes;\n\tstruct moxart_sg\t\tsg[];\n};\n\nstruct moxart_chan {\n\tstruct virt_dma_chan\t\tvc;\n\n\tvoid __iomem\t\t\t*base;\n\tstruct moxart_desc\t\t*desc;\n\n\tstruct dma_slave_config\t\tcfg;\n\n\tbool\t\t\t\tallocated;\n\tbool\t\t\t\terror;\n\tint\t\t\t\tch_num;\n\tunsigned int\t\t\tline_reqno;\n\tunsigned int\t\t\tsgidx;\n};\n\nstruct moxart_dmadev {\n\tstruct dma_device\t\tdma_slave;\n\tstruct moxart_chan\t\tslave_chans[APB_DMA_MAX_CHANNEL];\n\tunsigned int\t\t\tirq;\n};\n\nstruct moxart_filter_data {\n\tstruct moxart_dmadev\t\t*mdc;\n\tstruct of_phandle_args\t\t*dma_spec;\n};\n\nstatic const unsigned int es_bytes[] = {\n\t[MOXART_DMA_DATA_TYPE_S8] = 1,\n\t[MOXART_DMA_DATA_TYPE_S16] = 2,\n\t[MOXART_DMA_DATA_TYPE_S32] = 4,\n};\n\nstatic struct device *chan2dev(struct dma_chan *chan)\n{\n\treturn &chan->dev->device;\n}\n\nstatic inline struct moxart_chan *to_moxart_dma_chan(struct dma_chan *c)\n{\n\treturn container_of(c, struct moxart_chan, vc.chan);\n}\n\nstatic inline struct moxart_desc *to_moxart_dma_desc(\n\tstruct dma_async_tx_descriptor *t)\n{\n\treturn container_of(t, struct moxart_desc, vd.tx);\n}\n\nstatic void moxart_dma_desc_free(struct virt_dma_desc *vd)\n{\n\tkfree(container_of(vd, struct moxart_desc, vd));\n}\n\nstatic int moxart_terminate_all(struct dma_chan *chan)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\tu32 ctrl;\n\n\tdev_dbg(chan2dev(chan), \"%s: ch=%p\\n\", __func__, ch);\n\n\tspin_lock_irqsave(&ch->vc.lock, flags);\n\n\tif (ch->desc) {\n\t\tmoxart_dma_desc_free(&ch->desc->vd);\n\t\tch->desc = NULL;\n\t}\n\n\tctrl = readl(ch->base + REG_OFF_CTRL);\n\tctrl &= ~(APB_DMA_ENABLE | APB_DMA_FIN_INT_EN | APB_DMA_ERR_INT_EN);\n\twritel(ctrl, ch->base + REG_OFF_CTRL);\n\n\tvchan_get_all_descriptors(&ch->vc, &head);\n\tspin_unlock_irqrestore(&ch->vc.lock, flags);\n\tvchan_dma_desc_free_list(&ch->vc, &head);\n\n\treturn 0;\n}\n\nstatic int moxart_slave_config(struct dma_chan *chan,\n\t\t\t       struct dma_slave_config *cfg)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tu32 ctrl;\n\n\tch->cfg = *cfg;\n\n\tctrl = readl(ch->base + REG_OFF_CTRL);\n\tctrl |= APB_DMA_BURST_MODE;\n\tctrl &= ~(APB_DMA_DEST_MASK | APB_DMA_SOURCE_MASK);\n\tctrl &= ~(APB_DMA_DEST_REQ_NO_MASK | APB_DMA_SOURCE_REQ_NO_MASK);\n\n\tswitch (ch->cfg.src_addr_width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tctrl |= APB_DMA_DATA_WIDTH_1;\n\t\tif (ch->cfg.direction != DMA_MEM_TO_DEV)\n\t\t\tctrl |= APB_DMA_DEST_INC_1_4;\n\t\telse\n\t\t\tctrl |= APB_DMA_SOURCE_INC_1_4;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tctrl |= APB_DMA_DATA_WIDTH_2;\n\t\tif (ch->cfg.direction != DMA_MEM_TO_DEV)\n\t\t\tctrl |= APB_DMA_DEST_INC_2_8;\n\t\telse\n\t\t\tctrl |= APB_DMA_SOURCE_INC_2_8;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tctrl &= ~APB_DMA_DATA_WIDTH;\n\t\tif (ch->cfg.direction != DMA_MEM_TO_DEV)\n\t\t\tctrl |= APB_DMA_DEST_INC_4_16;\n\t\telse\n\t\t\tctrl |= APB_DMA_SOURCE_INC_4_16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ch->cfg.direction == DMA_MEM_TO_DEV) {\n\t\tctrl &= ~APB_DMA_DEST_SELECT;\n\t\tctrl |= APB_DMA_SOURCE_SELECT;\n\t\tctrl |= (ch->line_reqno << 16 &\n\t\t\t APB_DMA_DEST_REQ_NO_MASK);\n\t} else {\n\t\tctrl |= APB_DMA_DEST_SELECT;\n\t\tctrl &= ~APB_DMA_SOURCE_SELECT;\n\t\tctrl |= (ch->line_reqno << 24 &\n\t\t\t APB_DMA_SOURCE_REQ_NO_MASK);\n\t}\n\n\twritel(ctrl, ch->base + REG_OFF_CTRL);\n\n\treturn 0;\n}\n\nstatic struct dma_async_tx_descriptor *moxart_prep_slave_sg(\n\tstruct dma_chan *chan, struct scatterlist *sgl,\n\tunsigned int sg_len, enum dma_transfer_direction dir,\n\tunsigned long tx_flags, void *context)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tstruct moxart_desc *d;\n\tenum dma_slave_buswidth dev_width;\n\tdma_addr_t dev_addr;\n\tstruct scatterlist *sgent;\n\tunsigned int es;\n\tunsigned int i;\n\n\tif (!is_slave_direction(dir)) {\n\t\tdev_err(chan2dev(chan), \"%s: invalid DMA direction\\n\",\n\t\t\t__func__);\n\t\treturn NULL;\n\t}\n\n\tif (dir == DMA_DEV_TO_MEM) {\n\t\tdev_addr = ch->cfg.src_addr;\n\t\tdev_width = ch->cfg.src_addr_width;\n\t} else {\n\t\tdev_addr = ch->cfg.dst_addr;\n\t\tdev_width = ch->cfg.dst_addr_width;\n\t}\n\n\tswitch (dev_width) {\n\tcase DMA_SLAVE_BUSWIDTH_1_BYTE:\n\t\tes = MOXART_DMA_DATA_TYPE_S8;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_2_BYTES:\n\t\tes = MOXART_DMA_DATA_TYPE_S16;\n\t\tbreak;\n\tcase DMA_SLAVE_BUSWIDTH_4_BYTES:\n\t\tes = MOXART_DMA_DATA_TYPE_S32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chan2dev(chan), \"%s: unsupported data width (%u)\\n\",\n\t\t\t__func__, dev_width);\n\t\treturn NULL;\n\t}\n\n\td = kzalloc(struct_size(d, sg, sg_len), GFP_ATOMIC);\n\tif (!d)\n\t\treturn NULL;\n\n\td->dma_dir = dir;\n\td->dev_addr = dev_addr;\n\td->es = es;\n\n\tfor_each_sg(sgl, sgent, sg_len, i) {\n\t\td->sg[i].addr = sg_dma_address(sgent);\n\t\td->sg[i].len = sg_dma_len(sgent);\n\t}\n\n\td->sglen = sg_len;\n\n\tch->error = 0;\n\n\treturn vchan_tx_prep(&ch->vc, &d->vd, tx_flags);\n}\n\nstatic struct dma_chan *moxart_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tstruct moxart_dmadev *mdc = ofdma->of_dma_data;\n\tstruct dma_chan *chan;\n\tstruct moxart_chan *ch;\n\n\tchan = dma_get_any_slave_channel(&mdc->dma_slave);\n\tif (!chan)\n\t\treturn NULL;\n\n\tch = to_moxart_dma_chan(chan);\n\tch->line_reqno = dma_spec->args[0];\n\n\treturn chan;\n}\n\nstatic int moxart_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\n\tdev_dbg(chan2dev(chan), \"%s: allocating channel #%u\\n\",\n\t\t__func__, ch->ch_num);\n\tch->allocated = 1;\n\n\treturn 0;\n}\n\nstatic void moxart_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\n\tvchan_free_chan_resources(&ch->vc);\n\n\tdev_dbg(chan2dev(chan), \"%s: freeing channel #%u\\n\",\n\t\t__func__, ch->ch_num);\n\tch->allocated = 0;\n}\n\nstatic void moxart_dma_set_params(struct moxart_chan *ch, dma_addr_t src_addr,\n\t\t\t\t  dma_addr_t dst_addr)\n{\n\twritel(src_addr, ch->base + REG_OFF_ADDRESS_SOURCE);\n\twritel(dst_addr, ch->base + REG_OFF_ADDRESS_DEST);\n}\n\nstatic void moxart_set_transfer_params(struct moxart_chan *ch, unsigned int len)\n{\n\tstruct moxart_desc *d = ch->desc;\n\tunsigned int sglen_div = es_bytes[d->es];\n\n\td->dma_cycles = len >> sglen_div;\n\n\t \n\twritel(d->dma_cycles, ch->base + REG_OFF_CYCLES);\n\n\tdev_dbg(chan2dev(&ch->vc.chan), \"%s: set %u DMA cycles (len=%u)\\n\",\n\t\t__func__, d->dma_cycles, len);\n}\n\nstatic void moxart_start_dma(struct moxart_chan *ch)\n{\n\tu32 ctrl;\n\n\tctrl = readl(ch->base + REG_OFF_CTRL);\n\tctrl |= (APB_DMA_ENABLE | APB_DMA_FIN_INT_EN | APB_DMA_ERR_INT_EN);\n\twritel(ctrl, ch->base + REG_OFF_CTRL);\n}\n\nstatic void moxart_dma_start_sg(struct moxart_chan *ch, unsigned int idx)\n{\n\tstruct moxart_desc *d = ch->desc;\n\tstruct moxart_sg *sg = ch->desc->sg + idx;\n\n\tif (ch->desc->dma_dir == DMA_MEM_TO_DEV)\n\t\tmoxart_dma_set_params(ch, sg->addr, d->dev_addr);\n\telse if (ch->desc->dma_dir == DMA_DEV_TO_MEM)\n\t\tmoxart_dma_set_params(ch, d->dev_addr, sg->addr);\n\n\tmoxart_set_transfer_params(ch, sg->len);\n\n\tmoxart_start_dma(ch);\n}\n\nstatic void moxart_dma_start_desc(struct dma_chan *chan)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&ch->vc);\n\n\tif (!vd) {\n\t\tch->desc = NULL;\n\t\treturn;\n\t}\n\n\tlist_del(&vd->node);\n\n\tch->desc = to_moxart_dma_desc(&vd->tx);\n\tch->sgidx = 0;\n\n\tmoxart_dma_start_sg(ch, 0);\n}\n\nstatic void moxart_issue_pending(struct dma_chan *chan)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ch->vc.lock, flags);\n\tif (vchan_issue_pending(&ch->vc) && !ch->desc)\n\t\tmoxart_dma_start_desc(chan);\n\tspin_unlock_irqrestore(&ch->vc.lock, flags);\n}\n\nstatic size_t moxart_dma_desc_size(struct moxart_desc *d,\n\t\t\t\t   unsigned int completed_sgs)\n{\n\tunsigned int i;\n\tsize_t size;\n\n\tfor (size = i = completed_sgs; i < d->sglen; i++)\n\t\tsize += d->sg[i].len;\n\n\treturn size;\n}\n\nstatic size_t moxart_dma_desc_size_in_flight(struct moxart_chan *ch)\n{\n\tsize_t size;\n\tunsigned int completed_cycles, cycles;\n\n\tsize = moxart_dma_desc_size(ch->desc, ch->sgidx);\n\tcycles = readl(ch->base + REG_OFF_CYCLES);\n\tcompleted_cycles = (ch->desc->dma_cycles - cycles);\n\tsize -= completed_cycles << es_bytes[ch->desc->es];\n\n\tdev_dbg(chan2dev(&ch->vc.chan), \"%s: size=%zu\\n\", __func__, size);\n\n\treturn size;\n}\n\nstatic enum dma_status moxart_tx_status(struct dma_chan *chan,\n\t\t\t\t\tdma_cookie_t cookie,\n\t\t\t\t\tstruct dma_tx_state *txstate)\n{\n\tstruct moxart_chan *ch = to_moxart_dma_chan(chan);\n\tstruct virt_dma_desc *vd;\n\tstruct moxart_desc *d;\n\tenum dma_status ret;\n\tunsigned long flags;\n\n\t \n\tret = dma_cookie_status(chan, cookie, txstate);\n\n\tspin_lock_irqsave(&ch->vc.lock, flags);\n\tvd = vchan_find_desc(&ch->vc, cookie);\n\tif (vd) {\n\t\td = to_moxart_dma_desc(&vd->tx);\n\t\ttxstate->residue = moxart_dma_desc_size(d, 0);\n\t} else if (ch->desc && ch->desc->vd.tx.cookie == cookie) {\n\t\ttxstate->residue = moxart_dma_desc_size_in_flight(ch);\n\t}\n\tspin_unlock_irqrestore(&ch->vc.lock, flags);\n\n\tif (ch->error)\n\t\treturn DMA_ERROR;\n\n\treturn ret;\n}\n\nstatic void moxart_dma_init(struct dma_device *dma, struct device *dev)\n{\n\tdma->device_prep_slave_sg\t\t= moxart_prep_slave_sg;\n\tdma->device_alloc_chan_resources\t= moxart_alloc_chan_resources;\n\tdma->device_free_chan_resources\t\t= moxart_free_chan_resources;\n\tdma->device_issue_pending\t\t= moxart_issue_pending;\n\tdma->device_tx_status\t\t\t= moxart_tx_status;\n\tdma->device_config\t\t\t= moxart_slave_config;\n\tdma->device_terminate_all\t\t= moxart_terminate_all;\n\tdma->dev\t\t\t\t= dev;\n\n\tINIT_LIST_HEAD(&dma->channels);\n}\n\nstatic irqreturn_t moxart_dma_interrupt(int irq, void *devid)\n{\n\tstruct moxart_dmadev *mc = devid;\n\tstruct moxart_chan *ch = &mc->slave_chans[0];\n\tunsigned int i;\n\tu32 ctrl;\n\n\tdev_dbg(chan2dev(&ch->vc.chan), \"%s\\n\", __func__);\n\n\tfor (i = 0; i < APB_DMA_MAX_CHANNEL; i++, ch++) {\n\t\tif (!ch->allocated)\n\t\t\tcontinue;\n\n\t\tctrl = readl(ch->base + REG_OFF_CTRL);\n\n\t\tdev_dbg(chan2dev(&ch->vc.chan), \"%s: ch=%p ch->base=%p ctrl=%x\\n\",\n\t\t\t__func__, ch, ch->base, ctrl);\n\n\t\tif (ctrl & APB_DMA_FIN_INT_STS) {\n\t\t\tctrl &= ~APB_DMA_FIN_INT_STS;\n\t\t\tif (ch->desc) {\n\t\t\t\tspin_lock(&ch->vc.lock);\n\t\t\t\tif (++ch->sgidx < ch->desc->sglen) {\n\t\t\t\t\tmoxart_dma_start_sg(ch, ch->sgidx);\n\t\t\t\t} else {\n\t\t\t\t\tvchan_cookie_complete(&ch->desc->vd);\n\t\t\t\t\tmoxart_dma_start_desc(&ch->vc.chan);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&ch->vc.lock);\n\t\t\t}\n\t\t}\n\n\t\tif (ctrl & APB_DMA_ERR_INT_STS) {\n\t\t\tctrl &= ~APB_DMA_ERR_INT_STS;\n\t\t\tch->error = 1;\n\t\t}\n\n\t\twritel(ctrl, ch->base + REG_OFF_CTRL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int moxart_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tvoid __iomem *dma_base_addr;\n\tint ret, i;\n\tunsigned int irq;\n\tstruct moxart_chan *ch;\n\tstruct moxart_dmadev *mdc;\n\n\tmdc = devm_kzalloc(dev, sizeof(*mdc), GFP_KERNEL);\n\tif (!mdc)\n\t\treturn -ENOMEM;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"no IRQ resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma_base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dma_base_addr))\n\t\treturn PTR_ERR(dma_base_addr);\n\n\tdma_cap_zero(mdc->dma_slave.cap_mask);\n\tdma_cap_set(DMA_SLAVE, mdc->dma_slave.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, mdc->dma_slave.cap_mask);\n\n\tmoxart_dma_init(&mdc->dma_slave, dev);\n\n\tch = &mdc->slave_chans[0];\n\tfor (i = 0; i < APB_DMA_MAX_CHANNEL; i++, ch++) {\n\t\tch->ch_num = i;\n\t\tch->base = dma_base_addr + i * REG_OFF_CHAN_SIZE;\n\t\tch->allocated = 0;\n\n\t\tch->vc.desc_free = moxart_dma_desc_free;\n\t\tvchan_init(&ch->vc, &mdc->dma_slave);\n\n\t\tdev_dbg(dev, \"%s: chs[%d]: ch->ch_num=%u ch->base=%p\\n\",\n\t\t\t__func__, i, ch->ch_num, ch->base);\n\t}\n\n\tplatform_set_drvdata(pdev, mdc);\n\n\tret = devm_request_irq(dev, irq, moxart_dma_interrupt, 0,\n\t\t\t       \"moxart-dma-engine\", mdc);\n\tif (ret) {\n\t\tdev_err(dev, \"devm_request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\tmdc->irq = irq;\n\n\tret = dma_async_device_register(&mdc->dma_slave);\n\tif (ret) {\n\t\tdev_err(dev, \"dma_async_device_register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_dma_controller_register(node, moxart_of_xlate, mdc);\n\tif (ret) {\n\t\tdev_err(dev, \"of_dma_controller_register failed\\n\");\n\t\tdma_async_device_unregister(&mdc->dma_slave);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%s: IRQ=%u\\n\", __func__, irq);\n\n\treturn 0;\n}\n\nstatic int moxart_remove(struct platform_device *pdev)\n{\n\tstruct moxart_dmadev *m = platform_get_drvdata(pdev);\n\n\tdevm_free_irq(&pdev->dev, m->irq, m);\n\n\tdma_async_device_unregister(&m->dma_slave);\n\n\tif (pdev->dev.of_node)\n\t\tof_dma_controller_free(pdev->dev.of_node);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id moxart_dma_match[] = {\n\t{ .compatible = \"moxa,moxart-dma\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, moxart_dma_match);\n\nstatic struct platform_driver moxart_driver = {\n\t.probe\t= moxart_probe,\n\t.remove\t= moxart_remove,\n\t.driver = {\n\t\t.name\t\t= \"moxart-dma-engine\",\n\t\t.of_match_table\t= moxart_dma_match,\n\t},\n};\n\nstatic int moxart_init(void)\n{\n\treturn platform_driver_register(&moxart_driver);\n}\nsubsys_initcall(moxart_init);\n\nstatic void __exit moxart_exit(void)\n{\n\tplatform_driver_unregister(&moxart_driver);\n}\nmodule_exit(moxart_exit);\n\nMODULE_AUTHOR(\"Jonas Jensen <jonas.jensen@gmail.com>\");\nMODULE_DESCRIPTION(\"MOXART DMA engine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}