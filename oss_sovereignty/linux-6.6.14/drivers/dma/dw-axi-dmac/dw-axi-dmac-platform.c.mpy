{
  "module_name": "dw-axi-dmac-platform.c",
  "hash_id": "c8ef9edef4ab5ef93f032754aedd5fd9e9d2d46072d9c67af5314b0337d4ff18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"dw-axi-dmac.h\"\n#include \"../dmaengine.h\"\n#include \"../virt-dma.h\"\n\n \n#define AXI_DMA_BUSWIDTHS\t\t  \\\n\t(DMA_SLAVE_BUSWIDTH_1_BYTE\t| \\\n\tDMA_SLAVE_BUSWIDTH_2_BYTES\t| \\\n\tDMA_SLAVE_BUSWIDTH_4_BYTES\t| \\\n\tDMA_SLAVE_BUSWIDTH_8_BYTES\t| \\\n\tDMA_SLAVE_BUSWIDTH_16_BYTES\t| \\\n\tDMA_SLAVE_BUSWIDTH_32_BYTES\t| \\\n\tDMA_SLAVE_BUSWIDTH_64_BYTES)\n\n#define AXI_DMA_FLAG_HAS_APB_REGS\tBIT(0)\n#define AXI_DMA_FLAG_HAS_RESETS\t\tBIT(1)\n#define AXI_DMA_FLAG_USE_CFG2\t\tBIT(2)\n\nstatic inline void\naxi_dma_iowrite32(struct axi_dma_chip *chip, u32 reg, u32 val)\n{\n\tiowrite32(val, chip->regs + reg);\n}\n\nstatic inline u32 axi_dma_ioread32(struct axi_dma_chip *chip, u32 reg)\n{\n\treturn ioread32(chip->regs + reg);\n}\n\nstatic inline void\naxi_chan_iowrite32(struct axi_dma_chan *chan, u32 reg, u32 val)\n{\n\tiowrite32(val, chan->chan_regs + reg);\n}\n\nstatic inline u32 axi_chan_ioread32(struct axi_dma_chan *chan, u32 reg)\n{\n\treturn ioread32(chan->chan_regs + reg);\n}\n\nstatic inline void\naxi_chan_iowrite64(struct axi_dma_chan *chan, u32 reg, u64 val)\n{\n\t \n\tiowrite32(lower_32_bits(val), chan->chan_regs + reg);\n\tiowrite32(upper_32_bits(val), chan->chan_regs + reg + 4);\n}\n\nstatic inline void axi_chan_config_write(struct axi_dma_chan *chan,\n\t\t\t\t\t struct axi_dma_chan_config *config)\n{\n\tu32 cfg_lo, cfg_hi;\n\n\tcfg_lo = (config->dst_multblk_type << CH_CFG_L_DST_MULTBLK_TYPE_POS |\n\t\t  config->src_multblk_type << CH_CFG_L_SRC_MULTBLK_TYPE_POS);\n\tif (chan->chip->dw->hdata->reg_map_8_channels &&\n\t    !chan->chip->dw->hdata->use_cfg2) {\n\t\tcfg_hi = config->tt_fc << CH_CFG_H_TT_FC_POS |\n\t\t\t config->hs_sel_src << CH_CFG_H_HS_SEL_SRC_POS |\n\t\t\t config->hs_sel_dst << CH_CFG_H_HS_SEL_DST_POS |\n\t\t\t config->src_per << CH_CFG_H_SRC_PER_POS |\n\t\t\t config->dst_per << CH_CFG_H_DST_PER_POS |\n\t\t\t config->prior << CH_CFG_H_PRIORITY_POS;\n\t} else {\n\t\tcfg_lo |= config->src_per << CH_CFG2_L_SRC_PER_POS |\n\t\t\t  config->dst_per << CH_CFG2_L_DST_PER_POS;\n\t\tcfg_hi = config->tt_fc << CH_CFG2_H_TT_FC_POS |\n\t\t\t config->hs_sel_src << CH_CFG2_H_HS_SEL_SRC_POS |\n\t\t\t config->hs_sel_dst << CH_CFG2_H_HS_SEL_DST_POS |\n\t\t\t config->prior << CH_CFG2_H_PRIORITY_POS;\n\t}\n\taxi_chan_iowrite32(chan, CH_CFG_L, cfg_lo);\n\taxi_chan_iowrite32(chan, CH_CFG_H, cfg_hi);\n}\n\nstatic inline void axi_dma_disable(struct axi_dma_chip *chip)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chip, DMAC_CFG);\n\tval &= ~DMAC_EN_MASK;\n\taxi_dma_iowrite32(chip, DMAC_CFG, val);\n}\n\nstatic inline void axi_dma_enable(struct axi_dma_chip *chip)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chip, DMAC_CFG);\n\tval |= DMAC_EN_MASK;\n\taxi_dma_iowrite32(chip, DMAC_CFG, val);\n}\n\nstatic inline void axi_dma_irq_disable(struct axi_dma_chip *chip)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chip, DMAC_CFG);\n\tval &= ~INT_EN_MASK;\n\taxi_dma_iowrite32(chip, DMAC_CFG, val);\n}\n\nstatic inline void axi_dma_irq_enable(struct axi_dma_chip *chip)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chip, DMAC_CFG);\n\tval |= INT_EN_MASK;\n\taxi_dma_iowrite32(chip, DMAC_CFG, val);\n}\n\nstatic inline void axi_chan_irq_disable(struct axi_dma_chan *chan, u32 irq_mask)\n{\n\tu32 val;\n\n\tif (likely(irq_mask == DWAXIDMAC_IRQ_ALL)) {\n\t\taxi_chan_iowrite32(chan, CH_INTSTATUS_ENA, DWAXIDMAC_IRQ_NONE);\n\t} else {\n\t\tval = axi_chan_ioread32(chan, CH_INTSTATUS_ENA);\n\t\tval &= ~irq_mask;\n\t\taxi_chan_iowrite32(chan, CH_INTSTATUS_ENA, val);\n\t}\n}\n\nstatic inline void axi_chan_irq_set(struct axi_dma_chan *chan, u32 irq_mask)\n{\n\taxi_chan_iowrite32(chan, CH_INTSTATUS_ENA, irq_mask);\n}\n\nstatic inline void axi_chan_irq_sig_set(struct axi_dma_chan *chan, u32 irq_mask)\n{\n\taxi_chan_iowrite32(chan, CH_INTSIGNAL_ENA, irq_mask);\n}\n\nstatic inline void axi_chan_irq_clear(struct axi_dma_chan *chan, u32 irq_mask)\n{\n\taxi_chan_iowrite32(chan, CH_INTCLEAR, irq_mask);\n}\n\nstatic inline u32 axi_chan_irq_read(struct axi_dma_chan *chan)\n{\n\treturn axi_chan_ioread32(chan, CH_INTSTATUS);\n}\n\nstatic inline void axi_chan_disable(struct axi_dma_chan *chan)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chan->chip, DMAC_CHEN);\n\tval &= ~(BIT(chan->id) << DMAC_CHAN_EN_SHIFT);\n\tif (chan->chip->dw->hdata->reg_map_8_channels)\n\t\tval |=   BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;\n\telse\n\t\tval |=   BIT(chan->id) << DMAC_CHAN_EN2_WE_SHIFT;\n\taxi_dma_iowrite32(chan->chip, DMAC_CHEN, val);\n}\n\nstatic inline void axi_chan_enable(struct axi_dma_chan *chan)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chan->chip, DMAC_CHEN);\n\tif (chan->chip->dw->hdata->reg_map_8_channels)\n\t\tval |= BIT(chan->id) << DMAC_CHAN_EN_SHIFT |\n\t\t\tBIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;\n\telse\n\t\tval |= BIT(chan->id) << DMAC_CHAN_EN_SHIFT |\n\t\t\tBIT(chan->id) << DMAC_CHAN_EN2_WE_SHIFT;\n\taxi_dma_iowrite32(chan->chip, DMAC_CHEN, val);\n}\n\nstatic inline bool axi_chan_is_hw_enable(struct axi_dma_chan *chan)\n{\n\tu32 val;\n\n\tval = axi_dma_ioread32(chan->chip, DMAC_CHEN);\n\n\treturn !!(val & (BIT(chan->id) << DMAC_CHAN_EN_SHIFT));\n}\n\nstatic void axi_dma_hw_init(struct axi_dma_chip *chip)\n{\n\tint ret;\n\tu32 i;\n\n\tfor (i = 0; i < chip->dw->hdata->nr_channels; i++) {\n\t\taxi_chan_irq_disable(&chip->dw->chan[i], DWAXIDMAC_IRQ_ALL);\n\t\taxi_chan_disable(&chip->dw->chan[i]);\n\t}\n\tret = dma_set_mask_and_coherent(chip->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\tdev_warn(chip->dev, \"Unable to set coherent mask\\n\");\n}\n\nstatic u32 axi_chan_get_xfer_width(struct axi_dma_chan *chan, dma_addr_t src,\n\t\t\t\t   dma_addr_t dst, size_t len)\n{\n\tu32 max_width = chan->chip->dw->hdata->m_data_width;\n\n\treturn __ffs(src | dst | len | BIT(max_width));\n}\n\nstatic inline const char *axi_chan_name(struct axi_dma_chan *chan)\n{\n\treturn dma_chan_name(&chan->vc.chan);\n}\n\nstatic struct axi_dma_desc *axi_desc_alloc(u32 num)\n{\n\tstruct axi_dma_desc *desc;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->hw_desc = kcalloc(num, sizeof(*desc->hw_desc), GFP_NOWAIT);\n\tif (!desc->hw_desc) {\n\t\tkfree(desc);\n\t\treturn NULL;\n\t}\n\n\treturn desc;\n}\n\nstatic struct axi_dma_lli *axi_desc_get(struct axi_dma_chan *chan,\n\t\t\t\t\tdma_addr_t *addr)\n{\n\tstruct axi_dma_lli *lli;\n\tdma_addr_t phys;\n\n\tlli = dma_pool_zalloc(chan->desc_pool, GFP_NOWAIT, &phys);\n\tif (unlikely(!lli)) {\n\t\tdev_err(chan2dev(chan), \"%s: not enough descriptors available\\n\",\n\t\t\taxi_chan_name(chan));\n\t\treturn NULL;\n\t}\n\n\tatomic_inc(&chan->descs_allocated);\n\t*addr = phys;\n\n\treturn lli;\n}\n\nstatic void axi_desc_put(struct axi_dma_desc *desc)\n{\n\tstruct axi_dma_chan *chan = desc->chan;\n\tint count = atomic_read(&chan->descs_allocated);\n\tstruct axi_dma_hw_desc *hw_desc;\n\tint descs_put;\n\n\tfor (descs_put = 0; descs_put < count; descs_put++) {\n\t\thw_desc = &desc->hw_desc[descs_put];\n\t\tdma_pool_free(chan->desc_pool, hw_desc->lli, hw_desc->llp);\n\t}\n\n\tkfree(desc->hw_desc);\n\tkfree(desc);\n\tatomic_sub(descs_put, &chan->descs_allocated);\n\tdev_vdbg(chan2dev(chan), \"%s: %d descs put, %d still allocated\\n\",\n\t\taxi_chan_name(chan), descs_put,\n\t\tatomic_read(&chan->descs_allocated));\n}\n\nstatic void vchan_desc_put(struct virt_dma_desc *vdesc)\n{\n\taxi_desc_put(vd_to_axi_desc(vdesc));\n}\n\nstatic enum dma_status\ndma_chan_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,\n\t\t  struct dma_tx_state *txstate)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tstruct virt_dma_desc *vdesc;\n\tenum dma_status status;\n\tu32 completed_length;\n\tunsigned long flags;\n\tu32 completed_blocks;\n\tsize_t bytes = 0;\n\tu32 length;\n\tu32 len;\n\n\tstatus = dma_cookie_status(dchan, cookie, txstate);\n\tif (status == DMA_COMPLETE || !txstate)\n\t\treturn status;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\n\tvdesc = vchan_find_desc(&chan->vc, cookie);\n\tif (vdesc) {\n\t\tlength = vd_to_axi_desc(vdesc)->length;\n\t\tcompleted_blocks = vd_to_axi_desc(vdesc)->completed_blocks;\n\t\tlen = vd_to_axi_desc(vdesc)->hw_desc[0].len;\n\t\tcompleted_length = completed_blocks * len;\n\t\tbytes = length - completed_length;\n\t}\n\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\tdma_set_residue(txstate, bytes);\n\n\treturn status;\n}\n\nstatic void write_desc_llp(struct axi_dma_hw_desc *desc, dma_addr_t adr)\n{\n\tdesc->lli->llp = cpu_to_le64(adr);\n}\n\nstatic void write_chan_llp(struct axi_dma_chan *chan, dma_addr_t adr)\n{\n\taxi_chan_iowrite64(chan, CH_LLP, adr);\n}\n\nstatic void dw_axi_dma_set_byte_halfword(struct axi_dma_chan *chan, bool set)\n{\n\tu32 offset = DMAC_APB_BYTE_WR_CH_EN;\n\tu32 reg_width, val;\n\n\tif (!chan->chip->apb_regs) {\n\t\tdev_dbg(chan->chip->dev, \"apb_regs not initialized\\n\");\n\t\treturn;\n\t}\n\n\treg_width = __ffs(chan->config.dst_addr_width);\n\tif (reg_width == DWAXIDMAC_TRANS_WIDTH_16)\n\t\toffset = DMAC_APB_HALFWORD_WR_CH_EN;\n\n\tval = ioread32(chan->chip->apb_regs + offset);\n\n\tif (set)\n\t\tval |= BIT(chan->id);\n\telse\n\t\tval &= ~BIT(chan->id);\n\n\tiowrite32(val, chan->chip->apb_regs + offset);\n}\n \nstatic void axi_chan_block_xfer_start(struct axi_dma_chan *chan,\n\t\t\t\t      struct axi_dma_desc *first)\n{\n\tu32 priority = chan->chip->dw->hdata->priority[chan->id];\n\tstruct axi_dma_chan_config config = {};\n\tu32 irq_mask;\n\tu8 lms = 0;  \n\n\tif (unlikely(axi_chan_is_hw_enable(chan))) {\n\t\tdev_err(chan2dev(chan), \"%s is non-idle!\\n\",\n\t\t\taxi_chan_name(chan));\n\n\t\treturn;\n\t}\n\n\taxi_dma_enable(chan->chip);\n\n\tconfig.dst_multblk_type = DWAXIDMAC_MBLK_TYPE_LL;\n\tconfig.src_multblk_type = DWAXIDMAC_MBLK_TYPE_LL;\n\tconfig.tt_fc = DWAXIDMAC_TT_FC_MEM_TO_MEM_DMAC;\n\tconfig.prior = priority;\n\tconfig.hs_sel_dst = DWAXIDMAC_HS_SEL_HW;\n\tconfig.hs_sel_src = DWAXIDMAC_HS_SEL_HW;\n\tswitch (chan->direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tdw_axi_dma_set_byte_halfword(chan, true);\n\t\tconfig.tt_fc = chan->config.device_fc ?\n\t\t\t\tDWAXIDMAC_TT_FC_MEM_TO_PER_DST :\n\t\t\t\tDWAXIDMAC_TT_FC_MEM_TO_PER_DMAC;\n\t\tif (chan->chip->apb_regs)\n\t\t\tconfig.dst_per = chan->id;\n\t\telse\n\t\t\tconfig.dst_per = chan->hw_handshake_num;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tconfig.tt_fc = chan->config.device_fc ?\n\t\t\t\tDWAXIDMAC_TT_FC_PER_TO_MEM_SRC :\n\t\t\t\tDWAXIDMAC_TT_FC_PER_TO_MEM_DMAC;\n\t\tif (chan->chip->apb_regs)\n\t\t\tconfig.src_per = chan->id;\n\t\telse\n\t\t\tconfig.src_per = chan->hw_handshake_num;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\taxi_chan_config_write(chan, &config);\n\n\twrite_chan_llp(chan, first->hw_desc[0].llp | lms);\n\n\tirq_mask = DWAXIDMAC_IRQ_DMA_TRF | DWAXIDMAC_IRQ_ALL_ERR;\n\taxi_chan_irq_sig_set(chan, irq_mask);\n\n\t \n\tirq_mask |= DWAXIDMAC_IRQ_SUSPENDED;\n\taxi_chan_irq_set(chan, irq_mask);\n\n\taxi_chan_enable(chan);\n}\n\nstatic void axi_chan_start_first_queued(struct axi_dma_chan *chan)\n{\n\tstruct axi_dma_desc *desc;\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&chan->vc);\n\tif (!vd)\n\t\treturn;\n\n\tdesc = vd_to_axi_desc(vd);\n\tdev_vdbg(chan2dev(chan), \"%s: started %u\\n\", axi_chan_name(chan),\n\t\tvd->tx.cookie);\n\taxi_chan_block_xfer_start(chan, desc);\n}\n\nstatic void dma_chan_issue_pending(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\tif (vchan_issue_pending(&chan->vc))\n\t\taxi_chan_start_first_queued(chan);\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n}\n\nstatic void dw_axi_dma_synchronize(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\n\tvchan_synchronize(&chan->vc);\n}\n\nstatic int dma_chan_alloc_chan_resources(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\n\t \n\tif (axi_chan_is_hw_enable(chan)) {\n\t\tdev_err(chan2dev(chan), \"%s is non-idle!\\n\",\n\t\t\taxi_chan_name(chan));\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tchan->desc_pool = dma_pool_create(dev_name(chan2dev(chan)),\n\t\t\t\t\t  chan->chip->dev,\n\t\t\t\t\t  sizeof(struct axi_dma_lli),\n\t\t\t\t\t  64, 0);\n\tif (!chan->desc_pool) {\n\t\tdev_err(chan2dev(chan), \"No memory for descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdev_vdbg(dchan2dev(dchan), \"%s: allocating\\n\", axi_chan_name(chan));\n\n\tpm_runtime_get(chan->chip->dev);\n\n\treturn 0;\n}\n\nstatic void dma_chan_free_chan_resources(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\n\t \n\tif (axi_chan_is_hw_enable(chan))\n\t\tdev_err(dchan2dev(dchan), \"%s is non-idle!\\n\",\n\t\t\taxi_chan_name(chan));\n\n\taxi_chan_disable(chan);\n\taxi_chan_irq_disable(chan, DWAXIDMAC_IRQ_ALL);\n\n\tvchan_free_chan_resources(&chan->vc);\n\n\tdma_pool_destroy(chan->desc_pool);\n\tchan->desc_pool = NULL;\n\tdev_vdbg(dchan2dev(dchan),\n\t\t \"%s: free resources, descriptor still allocated: %u\\n\",\n\t\t axi_chan_name(chan), atomic_read(&chan->descs_allocated));\n\n\tpm_runtime_put(chan->chip->dev);\n}\n\nstatic void dw_axi_dma_set_hw_channel(struct axi_dma_chan *chan, bool set)\n{\n\tstruct axi_dma_chip *chip = chan->chip;\n\tunsigned long reg_value, val;\n\n\tif (!chip->apb_regs) {\n\t\tdev_err(chip->dev, \"apb_regs not initialized\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (set)\n\t\tval = chan->hw_handshake_num;\n\telse\n\t\tval = UNUSED_CHANNEL;\n\n\treg_value = lo_hi_readq(chip->apb_regs + DMAC_APB_HW_HS_SEL_0);\n\n\t \n\t \n\n\treg_value &= ~(DMA_APB_HS_SEL_MASK <<\n\t\t\t(chan->id * DMA_APB_HS_SEL_BIT_SIZE));\n\treg_value |= (val << (chan->id * DMA_APB_HS_SEL_BIT_SIZE));\n\tlo_hi_writeq(reg_value, chip->apb_regs + DMAC_APB_HW_HS_SEL_0);\n\n\treturn;\n}\n\n \nstatic void set_desc_last(struct axi_dma_hw_desc *desc)\n{\n\tu32 val;\n\n\tval = le32_to_cpu(desc->lli->ctl_hi);\n\tval |= CH_CTL_H_LLI_LAST;\n\tdesc->lli->ctl_hi = cpu_to_le32(val);\n}\n\nstatic void write_desc_sar(struct axi_dma_hw_desc *desc, dma_addr_t adr)\n{\n\tdesc->lli->sar = cpu_to_le64(adr);\n}\n\nstatic void write_desc_dar(struct axi_dma_hw_desc *desc, dma_addr_t adr)\n{\n\tdesc->lli->dar = cpu_to_le64(adr);\n}\n\nstatic void set_desc_src_master(struct axi_dma_hw_desc *desc)\n{\n\tu32 val;\n\n\t \n\tval = le32_to_cpu(desc->lli->ctl_lo);\n\tval &= ~CH_CTL_L_SRC_MAST;\n\tdesc->lli->ctl_lo = cpu_to_le32(val);\n}\n\nstatic void set_desc_dest_master(struct axi_dma_hw_desc *hw_desc,\n\t\t\t\t struct axi_dma_desc *desc)\n{\n\tu32 val;\n\n\t \n\tval = le32_to_cpu(hw_desc->lli->ctl_lo);\n\tif (desc->chan->chip->dw->hdata->nr_masters > 1)\n\t\tval |= CH_CTL_L_DST_MAST;\n\telse\n\t\tval &= ~CH_CTL_L_DST_MAST;\n\n\thw_desc->lli->ctl_lo = cpu_to_le32(val);\n}\n\nstatic int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,\n\t\t\t\t  struct axi_dma_hw_desc *hw_desc,\n\t\t\t\t  dma_addr_t mem_addr, size_t len)\n{\n\tunsigned int data_width = BIT(chan->chip->dw->hdata->m_data_width);\n\tunsigned int reg_width;\n\tunsigned int mem_width;\n\tdma_addr_t device_addr;\n\tsize_t axi_block_ts;\n\tsize_t block_ts;\n\tu32 ctllo, ctlhi;\n\tu32 burst_len;\n\n\taxi_block_ts = chan->chip->dw->hdata->block_size[chan->id];\n\n\tmem_width = __ffs(data_width | mem_addr | len);\n\tif (mem_width > DWAXIDMAC_TRANS_WIDTH_32)\n\t\tmem_width = DWAXIDMAC_TRANS_WIDTH_32;\n\n\tif (!IS_ALIGNED(mem_addr, 4)) {\n\t\tdev_err(chan->chip->dev, \"invalid buffer alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chan->direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\treg_width = __ffs(chan->config.dst_addr_width);\n\t\tdevice_addr = chan->config.dst_addr;\n\t\tctllo = reg_width << CH_CTL_L_DST_WIDTH_POS |\n\t\t\tmem_width << CH_CTL_L_SRC_WIDTH_POS |\n\t\t\tDWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_DST_INC_POS |\n\t\t\tDWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_SRC_INC_POS;\n\t\tblock_ts = len >> mem_width;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\treg_width = __ffs(chan->config.src_addr_width);\n\t\tdevice_addr = chan->config.src_addr;\n\t\tctllo = reg_width << CH_CTL_L_SRC_WIDTH_POS |\n\t\t\tmem_width << CH_CTL_L_DST_WIDTH_POS |\n\t\t\tDWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_DST_INC_POS |\n\t\t\tDWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_SRC_INC_POS;\n\t\tblock_ts = len >> reg_width;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (block_ts > axi_block_ts)\n\t\treturn -EINVAL;\n\n\thw_desc->lli = axi_desc_get(chan, &hw_desc->llp);\n\tif (unlikely(!hw_desc->lli))\n\t\treturn -ENOMEM;\n\n\tctlhi = CH_CTL_H_LLI_VALID;\n\n\tif (chan->chip->dw->hdata->restrict_axi_burst_len) {\n\t\tburst_len = chan->chip->dw->hdata->axi_rw_burst_len;\n\t\tctlhi |= CH_CTL_H_ARLEN_EN | CH_CTL_H_AWLEN_EN |\n\t\t\t burst_len << CH_CTL_H_ARLEN_POS |\n\t\t\t burst_len << CH_CTL_H_AWLEN_POS;\n\t}\n\n\thw_desc->lli->ctl_hi = cpu_to_le32(ctlhi);\n\n\tif (chan->direction == DMA_MEM_TO_DEV) {\n\t\twrite_desc_sar(hw_desc, mem_addr);\n\t\twrite_desc_dar(hw_desc, device_addr);\n\t} else {\n\t\twrite_desc_sar(hw_desc, device_addr);\n\t\twrite_desc_dar(hw_desc, mem_addr);\n\t}\n\n\thw_desc->lli->block_ts_lo = cpu_to_le32(block_ts - 1);\n\n\tctllo |= DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |\n\t\t DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS;\n\thw_desc->lli->ctl_lo = cpu_to_le32(ctllo);\n\n\tset_desc_src_master(hw_desc);\n\n\thw_desc->len = len;\n\treturn 0;\n}\n\nstatic size_t calculate_block_len(struct axi_dma_chan *chan,\n\t\t\t\t  dma_addr_t dma_addr, size_t buf_len,\n\t\t\t\t  enum dma_transfer_direction direction)\n{\n\tu32 data_width, reg_width, mem_width;\n\tsize_t axi_block_ts, block_len;\n\n\taxi_block_ts = chan->chip->dw->hdata->block_size[chan->id];\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_DEV:\n\t\tdata_width = BIT(chan->chip->dw->hdata->m_data_width);\n\t\tmem_width = __ffs(data_width | dma_addr | buf_len);\n\t\tif (mem_width > DWAXIDMAC_TRANS_WIDTH_32)\n\t\t\tmem_width = DWAXIDMAC_TRANS_WIDTH_32;\n\n\t\tblock_len = axi_block_ts << mem_width;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\treg_width = __ffs(chan->config.src_addr_width);\n\t\tblock_len = axi_block_ts << reg_width;\n\t\tbreak;\n\tdefault:\n\t\tblock_len = 0;\n\t}\n\n\treturn block_len;\n}\n\nstatic struct dma_async_tx_descriptor *\ndw_axi_dma_chan_prep_cyclic(struct dma_chan *dchan, dma_addr_t dma_addr,\n\t\t\t    size_t buf_len, size_t period_len,\n\t\t\t    enum dma_transfer_direction direction,\n\t\t\t    unsigned long flags)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tstruct axi_dma_hw_desc *hw_desc = NULL;\n\tstruct axi_dma_desc *desc = NULL;\n\tdma_addr_t src_addr = dma_addr;\n\tu32 num_periods, num_segments;\n\tsize_t axi_block_len;\n\tu32 total_segments;\n\tu32 segment_len;\n\tunsigned int i;\n\tint status;\n\tu64 llp = 0;\n\tu8 lms = 0;  \n\n\tnum_periods = buf_len / period_len;\n\n\taxi_block_len = calculate_block_len(chan, dma_addr, buf_len, direction);\n\tif (axi_block_len == 0)\n\t\treturn NULL;\n\n\tnum_segments = DIV_ROUND_UP(period_len, axi_block_len);\n\tsegment_len = DIV_ROUND_UP(period_len, num_segments);\n\n\ttotal_segments = num_periods * num_segments;\n\n\tdesc = axi_desc_alloc(total_segments);\n\tif (unlikely(!desc))\n\t\tgoto err_desc_get;\n\n\tchan->direction = direction;\n\tdesc->chan = chan;\n\tchan->cyclic = true;\n\tdesc->length = 0;\n\tdesc->period_len = period_len;\n\n\tfor (i = 0; i < total_segments; i++) {\n\t\thw_desc = &desc->hw_desc[i];\n\n\t\tstatus = dw_axi_dma_set_hw_desc(chan, hw_desc, src_addr,\n\t\t\t\t\t\tsegment_len);\n\t\tif (status < 0)\n\t\t\tgoto err_desc_get;\n\n\t\tdesc->length += hw_desc->len;\n\t\t \n\t\tset_desc_last(hw_desc);\n\n\t\tsrc_addr += segment_len;\n\t}\n\n\tllp = desc->hw_desc[0].llp;\n\n\t \n\tdo {\n\t\thw_desc = &desc->hw_desc[--total_segments];\n\t\twrite_desc_llp(hw_desc, llp | lms);\n\t\tllp = hw_desc->llp;\n\t} while (total_segments);\n\n\tdw_axi_dma_set_hw_channel(chan, true);\n\n\treturn vchan_tx_prep(&chan->vc, &desc->vd, flags);\n\nerr_desc_get:\n\tif (desc)\n\t\taxi_desc_put(desc);\n\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *\ndw_axi_dma_chan_prep_slave_sg(struct dma_chan *dchan, struct scatterlist *sgl,\n\t\t\t      unsigned int sg_len,\n\t\t\t      enum dma_transfer_direction direction,\n\t\t\t      unsigned long flags, void *context)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tstruct axi_dma_hw_desc *hw_desc = NULL;\n\tstruct axi_dma_desc *desc = NULL;\n\tu32 num_segments, segment_len;\n\tunsigned int loop = 0;\n\tstruct scatterlist *sg;\n\tsize_t axi_block_len;\n\tu32 len, num_sgs = 0;\n\tunsigned int i;\n\tdma_addr_t mem;\n\tint status;\n\tu64 llp = 0;\n\tu8 lms = 0;  \n\n\tif (unlikely(!is_slave_direction(direction) || !sg_len))\n\t\treturn NULL;\n\n\tmem = sg_dma_address(sgl);\n\tlen = sg_dma_len(sgl);\n\n\taxi_block_len = calculate_block_len(chan, mem, len, direction);\n\tif (axi_block_len == 0)\n\t\treturn NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, i)\n\t\tnum_sgs += DIV_ROUND_UP(sg_dma_len(sg), axi_block_len);\n\n\tdesc = axi_desc_alloc(num_sgs);\n\tif (unlikely(!desc))\n\t\tgoto err_desc_get;\n\n\tdesc->chan = chan;\n\tdesc->length = 0;\n\tchan->direction = direction;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tmem = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\t\tnum_segments = DIV_ROUND_UP(sg_dma_len(sg), axi_block_len);\n\t\tsegment_len = DIV_ROUND_UP(sg_dma_len(sg), num_segments);\n\n\t\tdo {\n\t\t\thw_desc = &desc->hw_desc[loop++];\n\t\t\tstatus = dw_axi_dma_set_hw_desc(chan, hw_desc, mem, segment_len);\n\t\t\tif (status < 0)\n\t\t\t\tgoto err_desc_get;\n\n\t\t\tdesc->length += hw_desc->len;\n\t\t\tlen -= segment_len;\n\t\t\tmem += segment_len;\n\t\t} while (len >= segment_len);\n\t}\n\n\t \n\tset_desc_last(&desc->hw_desc[num_sgs - 1]);\n\n\t \n\tdo {\n\t\thw_desc = &desc->hw_desc[--num_sgs];\n\t\twrite_desc_llp(hw_desc, llp | lms);\n\t\tllp = hw_desc->llp;\n\t} while (num_sgs);\n\n\tdw_axi_dma_set_hw_channel(chan, true);\n\n\treturn vchan_tx_prep(&chan->vc, &desc->vd, flags);\n\nerr_desc_get:\n\tif (desc)\n\t\taxi_desc_put(desc);\n\n\treturn NULL;\n}\n\nstatic struct dma_async_tx_descriptor *\ndma_chan_prep_dma_memcpy(struct dma_chan *dchan, dma_addr_t dst_adr,\n\t\t\t dma_addr_t src_adr, size_t len, unsigned long flags)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tsize_t block_ts, max_block_ts, xfer_len;\n\tstruct axi_dma_hw_desc *hw_desc = NULL;\n\tstruct axi_dma_desc *desc = NULL;\n\tu32 xfer_width, reg, num;\n\tu64 llp = 0;\n\tu8 lms = 0;  \n\n\tdev_dbg(chan2dev(chan), \"%s: memcpy: src: %pad dst: %pad length: %zd flags: %#lx\",\n\t\taxi_chan_name(chan), &src_adr, &dst_adr, len, flags);\n\n\tmax_block_ts = chan->chip->dw->hdata->block_size[chan->id];\n\txfer_width = axi_chan_get_xfer_width(chan, src_adr, dst_adr, len);\n\tnum = DIV_ROUND_UP(len, max_block_ts << xfer_width);\n\tdesc = axi_desc_alloc(num);\n\tif (unlikely(!desc))\n\t\tgoto err_desc_get;\n\n\tdesc->chan = chan;\n\tnum = 0;\n\tdesc->length = 0;\n\twhile (len) {\n\t\txfer_len = len;\n\n\t\thw_desc = &desc->hw_desc[num];\n\t\t \n\t\txfer_width = axi_chan_get_xfer_width(chan, src_adr, dst_adr, xfer_len);\n\n\t\t \n\t\tblock_ts = xfer_len >> xfer_width;\n\t\tif (block_ts > max_block_ts) {\n\t\t\tblock_ts = max_block_ts;\n\t\t\txfer_len = max_block_ts << xfer_width;\n\t\t}\n\n\t\thw_desc->lli = axi_desc_get(chan, &hw_desc->llp);\n\t\tif (unlikely(!hw_desc->lli))\n\t\t\tgoto err_desc_get;\n\n\t\twrite_desc_sar(hw_desc, src_adr);\n\t\twrite_desc_dar(hw_desc, dst_adr);\n\t\thw_desc->lli->block_ts_lo = cpu_to_le32(block_ts - 1);\n\n\t\treg = CH_CTL_H_LLI_VALID;\n\t\tif (chan->chip->dw->hdata->restrict_axi_burst_len) {\n\t\t\tu32 burst_len = chan->chip->dw->hdata->axi_rw_burst_len;\n\n\t\t\treg |= (CH_CTL_H_ARLEN_EN |\n\t\t\t\tburst_len << CH_CTL_H_ARLEN_POS |\n\t\t\t\tCH_CTL_H_AWLEN_EN |\n\t\t\t\tburst_len << CH_CTL_H_AWLEN_POS);\n\t\t}\n\t\thw_desc->lli->ctl_hi = cpu_to_le32(reg);\n\n\t\treg = (DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |\n\t\t       DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS |\n\t\t       xfer_width << CH_CTL_L_DST_WIDTH_POS |\n\t\t       xfer_width << CH_CTL_L_SRC_WIDTH_POS |\n\t\t       DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_DST_INC_POS |\n\t\t       DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_SRC_INC_POS);\n\t\thw_desc->lli->ctl_lo = cpu_to_le32(reg);\n\n\t\tset_desc_src_master(hw_desc);\n\t\tset_desc_dest_master(hw_desc, desc);\n\n\t\thw_desc->len = xfer_len;\n\t\tdesc->length += hw_desc->len;\n\t\t \n\t\tlen -= xfer_len;\n\t\tdst_adr += xfer_len;\n\t\tsrc_adr += xfer_len;\n\t\tnum++;\n\t}\n\n\t \n\tset_desc_last(&desc->hw_desc[num - 1]);\n\t \n\tdo {\n\t\thw_desc = &desc->hw_desc[--num];\n\t\twrite_desc_llp(hw_desc, llp | lms);\n\t\tllp = hw_desc->llp;\n\t} while (num);\n\n\treturn vchan_tx_prep(&chan->vc, &desc->vd, flags);\n\nerr_desc_get:\n\tif (desc)\n\t\taxi_desc_put(desc);\n\treturn NULL;\n}\n\nstatic int dw_axi_dma_chan_slave_config(struct dma_chan *dchan,\n\t\t\t\t\tstruct dma_slave_config *config)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\n\tmemcpy(&chan->config, config, sizeof(*config));\n\n\treturn 0;\n}\n\nstatic void axi_chan_dump_lli(struct axi_dma_chan *chan,\n\t\t\t      struct axi_dma_hw_desc *desc)\n{\n\tif (!desc->lli) {\n\t\tdev_err(dchan2dev(&chan->vc.chan), \"NULL LLI\\n\");\n\t\treturn;\n\t}\n\n\tdev_err(dchan2dev(&chan->vc.chan),\n\t\t\"SAR: 0x%llx DAR: 0x%llx LLP: 0x%llx BTS 0x%x CTL: 0x%x:%08x\",\n\t\tle64_to_cpu(desc->lli->sar),\n\t\tle64_to_cpu(desc->lli->dar),\n\t\tle64_to_cpu(desc->lli->llp),\n\t\tle32_to_cpu(desc->lli->block_ts_lo),\n\t\tle32_to_cpu(desc->lli->ctl_hi),\n\t\tle32_to_cpu(desc->lli->ctl_lo));\n}\n\nstatic void axi_chan_list_dump_lli(struct axi_dma_chan *chan,\n\t\t\t\t   struct axi_dma_desc *desc_head)\n{\n\tint count = atomic_read(&chan->descs_allocated);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\taxi_chan_dump_lli(chan, &desc_head->hw_desc[i]);\n}\n\nstatic noinline void axi_chan_handle_err(struct axi_dma_chan *chan, u32 status)\n{\n\tstruct virt_dma_desc *vd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\n\taxi_chan_disable(chan);\n\n\t \n\tvd = vchan_next_desc(&chan->vc);\n\tif (!vd) {\n\t\tdev_err(chan2dev(chan), \"BUG: %s, IRQ with no descriptors\\n\",\n\t\t\taxi_chan_name(chan));\n\t\tgoto out;\n\t}\n\t \n\tlist_del(&vd->node);\n\n\t \n\tdev_err(chan2dev(chan),\n\t\t\"Bad descriptor submitted for %s, cookie: %d, irq: 0x%08x\\n\",\n\t\taxi_chan_name(chan), vd->tx.cookie, status);\n\taxi_chan_list_dump_lli(chan, vd_to_axi_desc(vd));\n\n\tvchan_cookie_complete(vd);\n\n\t \n\taxi_chan_start_first_queued(chan);\n\nout:\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n}\n\nstatic void axi_chan_block_xfer_complete(struct axi_dma_chan *chan)\n{\n\tint count = atomic_read(&chan->descs_allocated);\n\tstruct axi_dma_hw_desc *hw_desc;\n\tstruct axi_dma_desc *desc;\n\tstruct virt_dma_desc *vd;\n\tunsigned long flags;\n\tu64 llp;\n\tint i;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\tif (unlikely(axi_chan_is_hw_enable(chan))) {\n\t\tdev_err(chan2dev(chan), \"BUG: %s caught DWAXIDMAC_IRQ_DMA_TRF, but channel not idle!\\n\",\n\t\t\taxi_chan_name(chan));\n\t\taxi_chan_disable(chan);\n\t}\n\n\t \n\tvd = vchan_next_desc(&chan->vc);\n\tif (!vd) {\n\t\tdev_err(chan2dev(chan), \"BUG: %s, IRQ with no descriptors\\n\",\n\t\t\taxi_chan_name(chan));\n\t\tgoto out;\n\t}\n\n\tif (chan->cyclic) {\n\t\tdesc = vd_to_axi_desc(vd);\n\t\tif (desc) {\n\t\t\tllp = lo_hi_readq(chan->chan_regs + CH_LLP);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\thw_desc = &desc->hw_desc[i];\n\t\t\t\tif (hw_desc->llp == llp) {\n\t\t\t\t\taxi_chan_irq_clear(chan, hw_desc->lli->status_lo);\n\t\t\t\t\thw_desc->lli->ctl_hi |= CH_CTL_H_LLI_VALID;\n\t\t\t\t\tdesc->completed_blocks = i;\n\n\t\t\t\t\tif (((hw_desc->len * (i + 1)) % desc->period_len) == 0)\n\t\t\t\t\t\tvchan_cyclic_callback(vd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taxi_chan_enable(chan);\n\t\t}\n\t} else {\n\t\t \n\t\tlist_del(&vd->node);\n\t\tvchan_cookie_complete(vd);\n\n\t\t \n\t\taxi_chan_start_first_queued(chan);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n}\n\nstatic irqreturn_t dw_axi_dma_interrupt(int irq, void *dev_id)\n{\n\tstruct axi_dma_chip *chip = dev_id;\n\tstruct dw_axi_dma *dw = chip->dw;\n\tstruct axi_dma_chan *chan;\n\n\tu32 status, i;\n\n\t \n\taxi_dma_irq_disable(chip);\n\n\t \n\tfor (i = 0; i < dw->hdata->nr_channels; i++) {\n\t\tchan = &dw->chan[i];\n\t\tstatus = axi_chan_irq_read(chan);\n\t\taxi_chan_irq_clear(chan, status);\n\n\t\tdev_vdbg(chip->dev, \"%s %u IRQ status: 0x%08x\\n\",\n\t\t\taxi_chan_name(chan), i, status);\n\n\t\tif (status & DWAXIDMAC_IRQ_ALL_ERR)\n\t\t\taxi_chan_handle_err(chan, status);\n\t\telse if (status & DWAXIDMAC_IRQ_DMA_TRF)\n\t\t\taxi_chan_block_xfer_complete(chan);\n\t}\n\n\t \n\taxi_dma_irq_enable(chip);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dma_chan_terminate_all(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tu32 chan_active = BIT(chan->id) << DMAC_CHAN_EN_SHIFT;\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\tLIST_HEAD(head);\n\n\taxi_chan_disable(chan);\n\n\tret = readl_poll_timeout_atomic(chan->chip->regs + DMAC_CHEN, val,\n\t\t\t\t\t!(val & chan_active), 1000, 50000);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(dchan2dev(dchan),\n\t\t\t \"%s failed to stop\\n\", axi_chan_name(chan));\n\n\tif (chan->direction != DMA_MEM_TO_MEM)\n\t\tdw_axi_dma_set_hw_channel(chan, false);\n\tif (chan->direction == DMA_MEM_TO_DEV)\n\t\tdw_axi_dma_set_byte_halfword(chan, false);\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\n\tvchan_get_all_descriptors(&chan->vc, &head);\n\n\tchan->cyclic = false;\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\n\tvchan_dma_desc_free_list(&chan->vc, &head);\n\n\tdev_vdbg(dchan2dev(dchan), \"terminated: %s\\n\", axi_chan_name(chan));\n\n\treturn 0;\n}\n\nstatic int dma_chan_pause(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tunsigned long flags;\n\tunsigned int timeout = 20;  \n\tu32 val;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\n\tif (chan->chip->dw->hdata->reg_map_8_channels) {\n\t\tval = axi_dma_ioread32(chan->chip, DMAC_CHEN);\n\t\tval |= BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT |\n\t\t\tBIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT;\n\t\taxi_dma_iowrite32(chan->chip, DMAC_CHEN, val);\n\t} else {\n\t\tval = axi_dma_ioread32(chan->chip, DMAC_CHSUSPREG);\n\t\tval |= BIT(chan->id) << DMAC_CHAN_SUSP2_SHIFT |\n\t\t\tBIT(chan->id) << DMAC_CHAN_SUSP2_WE_SHIFT;\n\t\taxi_dma_iowrite32(chan->chip, DMAC_CHSUSPREG, val);\n\t}\n\n\tdo  {\n\t\tif (axi_chan_irq_read(chan) & DWAXIDMAC_IRQ_SUSPENDED)\n\t\t\tbreak;\n\n\t\tudelay(2);\n\t} while (--timeout);\n\n\taxi_chan_irq_clear(chan, DWAXIDMAC_IRQ_SUSPENDED);\n\n\tchan->is_paused = true;\n\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\n\treturn timeout ? 0 : -EAGAIN;\n}\n\n \nstatic inline void axi_chan_resume(struct axi_dma_chan *chan)\n{\n\tu32 val;\n\n\tif (chan->chip->dw->hdata->reg_map_8_channels) {\n\t\tval = axi_dma_ioread32(chan->chip, DMAC_CHEN);\n\t\tval &= ~(BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT);\n\t\tval |=  (BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT);\n\t\taxi_dma_iowrite32(chan->chip, DMAC_CHEN, val);\n\t} else {\n\t\tval = axi_dma_ioread32(chan->chip, DMAC_CHSUSPREG);\n\t\tval &= ~(BIT(chan->id) << DMAC_CHAN_SUSP2_SHIFT);\n\t\tval |=  (BIT(chan->id) << DMAC_CHAN_SUSP2_WE_SHIFT);\n\t\taxi_dma_iowrite32(chan->chip, DMAC_CHSUSPREG, val);\n\t}\n\n\tchan->is_paused = false;\n}\n\nstatic int dma_chan_resume(struct dma_chan *dchan)\n{\n\tstruct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->vc.lock, flags);\n\n\tif (chan->is_paused)\n\t\taxi_chan_resume(chan);\n\n\tspin_unlock_irqrestore(&chan->vc.lock, flags);\n\n\treturn 0;\n}\n\nstatic int axi_dma_suspend(struct axi_dma_chip *chip)\n{\n\taxi_dma_irq_disable(chip);\n\taxi_dma_disable(chip);\n\n\tclk_disable_unprepare(chip->core_clk);\n\tclk_disable_unprepare(chip->cfgr_clk);\n\n\treturn 0;\n}\n\nstatic int axi_dma_resume(struct axi_dma_chip *chip)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(chip->cfgr_clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(chip->core_clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taxi_dma_enable(chip);\n\taxi_dma_irq_enable(chip);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused axi_dma_runtime_suspend(struct device *dev)\n{\n\tstruct axi_dma_chip *chip = dev_get_drvdata(dev);\n\n\treturn axi_dma_suspend(chip);\n}\n\nstatic int __maybe_unused axi_dma_runtime_resume(struct device *dev)\n{\n\tstruct axi_dma_chip *chip = dev_get_drvdata(dev);\n\n\treturn axi_dma_resume(chip);\n}\n\nstatic struct dma_chan *dw_axi_dma_of_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t    struct of_dma *ofdma)\n{\n\tstruct dw_axi_dma *dw = ofdma->of_dma_data;\n\tstruct axi_dma_chan *chan;\n\tstruct dma_chan *dchan;\n\n\tdchan = dma_get_any_slave_channel(&dw->dma);\n\tif (!dchan)\n\t\treturn NULL;\n\n\tchan = dchan_to_axi_dma_chan(dchan);\n\tchan->hw_handshake_num = dma_spec->args[0];\n\treturn dchan;\n}\n\nstatic int parse_device_properties(struct axi_dma_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tu32 tmp, carr[DMAC_MAX_CHANNELS];\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"dma-channels\", &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp == 0 || tmp > DMAC_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tchip->dw->hdata->nr_channels = tmp;\n\tif (tmp <= DMA_REG_MAP_CH_REF)\n\t\tchip->dw->hdata->reg_map_8_channels = true;\n\n\tret = device_property_read_u32(dev, \"snps,dma-masters\", &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp == 0 || tmp > DMAC_MAX_MASTERS)\n\t\treturn -EINVAL;\n\n\tchip->dw->hdata->nr_masters = tmp;\n\n\tret = device_property_read_u32(dev, \"snps,data-width\", &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp > DWAXIDMAC_TRANS_WIDTH_MAX)\n\t\treturn -EINVAL;\n\n\tchip->dw->hdata->m_data_width = tmp;\n\n\tret = device_property_read_u32_array(dev, \"snps,block-size\", carr,\n\t\t\t\t\t     chip->dw->hdata->nr_channels);\n\tif (ret)\n\t\treturn ret;\n\tfor (tmp = 0; tmp < chip->dw->hdata->nr_channels; tmp++) {\n\t\tif (carr[tmp] == 0 || carr[tmp] > DMAC_MAX_BLK_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tchip->dw->hdata->block_size[tmp] = carr[tmp];\n\t}\n\n\tret = device_property_read_u32_array(dev, \"snps,priority\", carr,\n\t\t\t\t\t     chip->dw->hdata->nr_channels);\n\tif (ret)\n\t\treturn ret;\n\t \n\tfor (tmp = 0; tmp < chip->dw->hdata->nr_channels; tmp++) {\n\t\tif (carr[tmp] >= chip->dw->hdata->nr_channels)\n\t\t\treturn -EINVAL;\n\n\t\tchip->dw->hdata->priority[tmp] = carr[tmp];\n\t}\n\n\t \n\tret = device_property_read_u32(dev, \"snps,axi-max-burst-len\", &tmp);\n\tif (!ret) {\n\t\tif (tmp > DWAXIDMAC_ARWLEN_MAX + 1)\n\t\t\treturn -EINVAL;\n\t\tif (tmp < DWAXIDMAC_ARWLEN_MIN + 1)\n\t\t\treturn -EINVAL;\n\n\t\tchip->dw->hdata->restrict_axi_burst_len = true;\n\t\tchip->dw->hdata->axi_rw_burst_len = tmp;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_probe(struct platform_device *pdev)\n{\n\tstruct axi_dma_chip *chip;\n\tstruct dw_axi_dma *dw;\n\tstruct dw_axi_dma_hcfg *hdata;\n\tstruct reset_control *resets;\n\tunsigned int flags;\n\tu32 i;\n\tint ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tdw = devm_kzalloc(&pdev->dev, sizeof(*dw), GFP_KERNEL);\n\tif (!dw)\n\t\treturn -ENOMEM;\n\n\thdata = devm_kzalloc(&pdev->dev, sizeof(*hdata), GFP_KERNEL);\n\tif (!hdata)\n\t\treturn -ENOMEM;\n\n\tchip->dw = dw;\n\tchip->dev = &pdev->dev;\n\tchip->dw->hdata = hdata;\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tif (chip->irq < 0)\n\t\treturn chip->irq;\n\n\tchip->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->regs))\n\t\treturn PTR_ERR(chip->regs);\n\n\tflags = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\tif (flags & AXI_DMA_FLAG_HAS_APB_REGS) {\n\t\tchip->apb_regs = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(chip->apb_regs))\n\t\t\treturn PTR_ERR(chip->apb_regs);\n\t}\n\n\tif (flags & AXI_DMA_FLAG_HAS_RESETS) {\n\t\tresets = devm_reset_control_array_get_exclusive(&pdev->dev);\n\t\tif (IS_ERR(resets))\n\t\t\treturn PTR_ERR(resets);\n\n\t\tret = reset_control_deassert(resets);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tchip->dw->hdata->use_cfg2 = !!(flags & AXI_DMA_FLAG_USE_CFG2);\n\n\tchip->core_clk = devm_clk_get(chip->dev, \"core-clk\");\n\tif (IS_ERR(chip->core_clk))\n\t\treturn PTR_ERR(chip->core_clk);\n\n\tchip->cfgr_clk = devm_clk_get(chip->dev, \"cfgr-clk\");\n\tif (IS_ERR(chip->cfgr_clk))\n\t\treturn PTR_ERR(chip->cfgr_clk);\n\n\tret = parse_device_properties(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tdw->chan = devm_kcalloc(chip->dev, hdata->nr_channels,\n\t\t\t\tsizeof(*dw->chan), GFP_KERNEL);\n\tif (!dw->chan)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(chip->dev, chip->irq, dw_axi_dma_interrupt,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&dw->dma.channels);\n\tfor (i = 0; i < hdata->nr_channels; i++) {\n\t\tstruct axi_dma_chan *chan = &dw->chan[i];\n\n\t\tchan->chip = chip;\n\t\tchan->id = i;\n\t\tchan->chan_regs = chip->regs + COMMON_REG_LEN + i * CHAN_REG_LEN;\n\t\tatomic_set(&chan->descs_allocated, 0);\n\n\t\tchan->vc.desc_free = vchan_desc_put;\n\t\tvchan_init(&chan->vc, &dw->dma);\n\t}\n\n\t \n\tdma_cap_set(DMA_MEMCPY, dw->dma.cap_mask);\n\tdma_cap_set(DMA_SLAVE, dw->dma.cap_mask);\n\tdma_cap_set(DMA_CYCLIC, dw->dma.cap_mask);\n\n\t \n\tdw->dma.max_burst = hdata->axi_rw_burst_len;\n\tdw->dma.src_addr_widths = AXI_DMA_BUSWIDTHS;\n\tdw->dma.dst_addr_widths = AXI_DMA_BUSWIDTHS;\n\tdw->dma.directions = BIT(DMA_MEM_TO_MEM);\n\tdw->dma.directions |= BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\n\tdw->dma.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\n\tdw->dma.dev = chip->dev;\n\tdw->dma.device_tx_status = dma_chan_tx_status;\n\tdw->dma.device_issue_pending = dma_chan_issue_pending;\n\tdw->dma.device_terminate_all = dma_chan_terminate_all;\n\tdw->dma.device_pause = dma_chan_pause;\n\tdw->dma.device_resume = dma_chan_resume;\n\n\tdw->dma.device_alloc_chan_resources = dma_chan_alloc_chan_resources;\n\tdw->dma.device_free_chan_resources = dma_chan_free_chan_resources;\n\n\tdw->dma.device_prep_dma_memcpy = dma_chan_prep_dma_memcpy;\n\tdw->dma.device_synchronize = dw_axi_dma_synchronize;\n\tdw->dma.device_config = dw_axi_dma_chan_slave_config;\n\tdw->dma.device_prep_slave_sg = dw_axi_dma_chan_prep_slave_sg;\n\tdw->dma.device_prep_dma_cyclic = dw_axi_dma_chan_prep_cyclic;\n\n\t \n\tdw->dma.dev->dma_parms = &dw->dma_parms;\n\tdma_set_max_seg_size(&pdev->dev, MAX_BLOCK_SIZE);\n\tplatform_set_drvdata(pdev, chip);\n\n\tpm_runtime_enable(chip->dev);\n\n\t \n\tpm_runtime_get_noresume(chip->dev);\n\tret = axi_dma_resume(chip);\n\tif (ret < 0)\n\t\tgoto err_pm_disable;\n\n\taxi_dma_hw_init(chip);\n\n\tpm_runtime_put(chip->dev);\n\n\tret = dmaenginem_async_device_register(&dw->dma);\n\tif (ret)\n\t\tgoto err_pm_disable;\n\n\t \n\tret = of_dma_controller_register(pdev->dev.of_node,\n\t\t\t\t\t dw_axi_dma_of_xlate, dw);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to register OF DMA controller, fallback to MEM_TO_MEM mode\\n\");\n\n\tdev_info(chip->dev, \"DesignWare AXI DMA Controller, %d channels\\n\",\n\t\t dw->hdata->nr_channels);\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(chip->dev);\n\n\treturn ret;\n}\n\nstatic int dw_remove(struct platform_device *pdev)\n{\n\tstruct axi_dma_chip *chip = platform_get_drvdata(pdev);\n\tstruct dw_axi_dma *dw = chip->dw;\n\tstruct axi_dma_chan *chan, *_chan;\n\tu32 i;\n\n\t \n\tclk_prepare_enable(chip->cfgr_clk);\n\tclk_prepare_enable(chip->core_clk);\n\taxi_dma_irq_disable(chip);\n\tfor (i = 0; i < dw->hdata->nr_channels; i++) {\n\t\taxi_chan_disable(&chip->dw->chan[i]);\n\t\taxi_chan_irq_disable(&chip->dw->chan[i], DWAXIDMAC_IRQ_ALL);\n\t}\n\taxi_dma_disable(chip);\n\n\tpm_runtime_disable(chip->dev);\n\taxi_dma_suspend(chip);\n\n\tdevm_free_irq(chip->dev, chip->irq, chip);\n\n\tof_dma_controller_free(chip->dev->of_node);\n\n\tlist_for_each_entry_safe(chan, _chan, &dw->dma.channels,\n\t\t\tvc.chan.device_node) {\n\t\tlist_del(&chan->vc.chan.device_node);\n\t\ttasklet_kill(&chan->vc.task);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw_axi_dma_pm_ops = {\n\tSET_RUNTIME_PM_OPS(axi_dma_runtime_suspend, axi_dma_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id dw_dma_of_id_table[] = {\n\t{\n\t\t.compatible = \"snps,axi-dma-1.01a\"\n\t}, {\n\t\t.compatible = \"intel,kmb-axi-dma\",\n\t\t.data = (void *)AXI_DMA_FLAG_HAS_APB_REGS,\n\t}, {\n\t\t.compatible = \"starfive,jh7110-axi-dma\",\n\t\t.data = (void *)(AXI_DMA_FLAG_HAS_RESETS | AXI_DMA_FLAG_USE_CFG2),\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dw_dma_of_id_table);\n\nstatic struct platform_driver dw_driver = {\n\t.probe\t\t= dw_probe,\n\t.remove\t\t= dw_remove,\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.of_match_table = dw_dma_of_id_table,\n\t\t.pm = &dw_axi_dma_pm_ops,\n\t},\n};\nmodule_platform_driver(dw_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare AXI DMA Controller platform driver\");\nMODULE_AUTHOR(\"Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}