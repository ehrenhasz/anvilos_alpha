{
  "module_name": "pl330.c",
  "hash_id": "c55002a69c10bed72e4089361f9496d2cd60dd1f9f7e0ffb822e4cf4c56cafc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/pl330.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/amba/bus.h>\n#include <linux/scatterlist.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n#include <linux/bug.h>\n#include <linux/reset.h>\n\n#include \"dmaengine.h\"\n#define PL330_MAX_CHAN\t\t8\n#define PL330_MAX_IRQS\t\t32\n#define PL330_MAX_PERI\t\t32\n#define PL330_MAX_BURST         16\n\n#define PL330_QUIRK_BROKEN_NO_FLUSHP\tBIT(0)\n#define PL330_QUIRK_PERIPH_BURST\tBIT(1)\n\nenum pl330_cachectrl {\n\tCCTRL0,\t\t \n\tCCTRL1,\t\t \n\tCCTRL2,\t\t \n\tCCTRL3,\t\t \n\tINVALID1,\t \n\tINVALID2,\n\tCCTRL6,\t\t \n\tCCTRL7,\t\t \n};\n\nenum pl330_byteswap {\n\tSWAP_NO,\n\tSWAP_2,\n\tSWAP_4,\n\tSWAP_8,\n\tSWAP_16,\n};\n\n \n#define DS\t\t\t0x0\n#define DS_ST_STOP\t\t0x0\n#define DS_ST_EXEC\t\t0x1\n#define DS_ST_CMISS\t\t0x2\n#define DS_ST_UPDTPC\t\t0x3\n#define DS_ST_WFE\t\t0x4\n#define DS_ST_ATBRR\t\t0x5\n#define DS_ST_QBUSY\t\t0x6\n#define DS_ST_WFP\t\t0x7\n#define DS_ST_KILL\t\t0x8\n#define DS_ST_CMPLT\t\t0x9\n#define DS_ST_FLTCMP\t\t0xe\n#define DS_ST_FAULT\t\t0xf\n\n#define DPC\t\t\t0x4\n#define INTEN\t\t\t0x20\n#define ES\t\t\t0x24\n#define INTSTATUS\t\t0x28\n#define INTCLR\t\t\t0x2c\n#define FSM\t\t\t0x30\n#define FSC\t\t\t0x34\n#define FTM\t\t\t0x38\n\n#define _FTC\t\t\t0x40\n#define FTC(n)\t\t\t(_FTC + (n)*0x4)\n\n#define _CS\t\t\t0x100\n#define CS(n)\t\t\t(_CS + (n)*0x8)\n#define CS_CNS\t\t\t(1 << 21)\n\n#define _CPC\t\t\t0x104\n#define CPC(n)\t\t\t(_CPC + (n)*0x8)\n\n#define _SA\t\t\t0x400\n#define SA(n)\t\t\t(_SA + (n)*0x20)\n\n#define _DA\t\t\t0x404\n#define DA(n)\t\t\t(_DA + (n)*0x20)\n\n#define _CC\t\t\t0x408\n#define CC(n)\t\t\t(_CC + (n)*0x20)\n\n#define CC_SRCINC\t\t(1 << 0)\n#define CC_DSTINC\t\t(1 << 14)\n#define CC_SRCPRI\t\t(1 << 8)\n#define CC_DSTPRI\t\t(1 << 22)\n#define CC_SRCNS\t\t(1 << 9)\n#define CC_DSTNS\t\t(1 << 23)\n#define CC_SRCIA\t\t(1 << 10)\n#define CC_DSTIA\t\t(1 << 24)\n#define CC_SRCBRSTLEN_SHFT\t4\n#define CC_DSTBRSTLEN_SHFT\t18\n#define CC_SRCBRSTSIZE_SHFT\t1\n#define CC_DSTBRSTSIZE_SHFT\t15\n#define CC_SRCCCTRL_SHFT\t11\n#define CC_SRCCCTRL_MASK\t0x7\n#define CC_DSTCCTRL_SHFT\t25\n#define CC_DRCCCTRL_MASK\t0x7\n#define CC_SWAP_SHFT\t\t28\n\n#define _LC0\t\t\t0x40c\n#define LC0(n)\t\t\t(_LC0 + (n)*0x20)\n\n#define _LC1\t\t\t0x410\n#define LC1(n)\t\t\t(_LC1 + (n)*0x20)\n\n#define DBGSTATUS\t\t0xd00\n#define DBG_BUSY\t\t(1 << 0)\n\n#define DBGCMD\t\t\t0xd04\n#define DBGINST0\t\t0xd08\n#define DBGINST1\t\t0xd0c\n\n#define CR0\t\t\t0xe00\n#define CR1\t\t\t0xe04\n#define CR2\t\t\t0xe08\n#define CR3\t\t\t0xe0c\n#define CR4\t\t\t0xe10\n#define CRD\t\t\t0xe14\n\n#define PERIPH_ID\t\t0xfe0\n#define PERIPH_REV_SHIFT\t20\n#define PERIPH_REV_MASK\t\t0xf\n#define PERIPH_REV_R0P0\t\t0\n#define PERIPH_REV_R1P0\t\t1\n#define PERIPH_REV_R1P1\t\t2\n\n#define CR0_PERIPH_REQ_SET\t(1 << 0)\n#define CR0_BOOT_EN_SET\t\t(1 << 1)\n#define CR0_BOOT_MAN_NS\t\t(1 << 2)\n#define CR0_NUM_CHANS_SHIFT\t4\n#define CR0_NUM_CHANS_MASK\t0x7\n#define CR0_NUM_PERIPH_SHIFT\t12\n#define CR0_NUM_PERIPH_MASK\t0x1f\n#define CR0_NUM_EVENTS_SHIFT\t17\n#define CR0_NUM_EVENTS_MASK\t0x1f\n\n#define CR1_ICACHE_LEN_SHIFT\t0\n#define CR1_ICACHE_LEN_MASK\t0x7\n#define CR1_NUM_ICACHELINES_SHIFT\t4\n#define CR1_NUM_ICACHELINES_MASK\t0xf\n\n#define CRD_DATA_WIDTH_SHIFT\t0\n#define CRD_DATA_WIDTH_MASK\t0x7\n#define CRD_WR_CAP_SHIFT\t4\n#define CRD_WR_CAP_MASK\t\t0x7\n#define CRD_WR_Q_DEP_SHIFT\t8\n#define CRD_WR_Q_DEP_MASK\t0xf\n#define CRD_RD_CAP_SHIFT\t12\n#define CRD_RD_CAP_MASK\t\t0x7\n#define CRD_RD_Q_DEP_SHIFT\t16\n#define CRD_RD_Q_DEP_MASK\t0xf\n#define CRD_DATA_BUFF_SHIFT\t20\n#define CRD_DATA_BUFF_MASK\t0x3ff\n\n#define PART\t\t\t0x330\n#define DESIGNER\t\t0x41\n#define REVISION\t\t0x0\n#define INTEG_CFG\t\t0x0\n#define PERIPH_ID_VAL\t\t((PART << 0) | (DESIGNER << 12))\n\n#define PL330_STATE_STOPPED\t\t(1 << 0)\n#define PL330_STATE_EXECUTING\t\t(1 << 1)\n#define PL330_STATE_WFE\t\t\t(1 << 2)\n#define PL330_STATE_FAULTING\t\t(1 << 3)\n#define PL330_STATE_COMPLETING\t\t(1 << 4)\n#define PL330_STATE_WFP\t\t\t(1 << 5)\n#define PL330_STATE_KILLING\t\t(1 << 6)\n#define PL330_STATE_FAULT_COMPLETING\t(1 << 7)\n#define PL330_STATE_CACHEMISS\t\t(1 << 8)\n#define PL330_STATE_UPDTPC\t\t(1 << 9)\n#define PL330_STATE_ATBARRIER\t\t(1 << 10)\n#define PL330_STATE_QUEUEBUSY\t\t(1 << 11)\n#define PL330_STATE_INVALID\t\t(1 << 15)\n\n#define PL330_STABLE_STATES (PL330_STATE_STOPPED | PL330_STATE_EXECUTING \\\n\t\t\t\t| PL330_STATE_WFE | PL330_STATE_FAULTING)\n\n#define CMD_DMAADDH\t\t0x54\n#define CMD_DMAEND\t\t0x00\n#define CMD_DMAFLUSHP\t\t0x35\n#define CMD_DMAGO\t\t0xa0\n#define CMD_DMALD\t\t0x04\n#define CMD_DMALDP\t\t0x25\n#define CMD_DMALP\t\t0x20\n#define CMD_DMALPEND\t\t0x28\n#define CMD_DMAKILL\t\t0x01\n#define CMD_DMAMOV\t\t0xbc\n#define CMD_DMANOP\t\t0x18\n#define CMD_DMARMB\t\t0x12\n#define CMD_DMASEV\t\t0x34\n#define CMD_DMAST\t\t0x08\n#define CMD_DMASTP\t\t0x29\n#define CMD_DMASTZ\t\t0x0c\n#define CMD_DMAWFE\t\t0x36\n#define CMD_DMAWFP\t\t0x30\n#define CMD_DMAWMB\t\t0x13\n\n#define SZ_DMAADDH\t\t3\n#define SZ_DMAEND\t\t1\n#define SZ_DMAFLUSHP\t\t2\n#define SZ_DMALD\t\t1\n#define SZ_DMALDP\t\t2\n#define SZ_DMALP\t\t2\n#define SZ_DMALPEND\t\t2\n#define SZ_DMAKILL\t\t1\n#define SZ_DMAMOV\t\t6\n#define SZ_DMANOP\t\t1\n#define SZ_DMARMB\t\t1\n#define SZ_DMASEV\t\t2\n#define SZ_DMAST\t\t1\n#define SZ_DMASTP\t\t2\n#define SZ_DMASTZ\t\t1\n#define SZ_DMAWFE\t\t2\n#define SZ_DMAWFP\t\t2\n#define SZ_DMAWMB\t\t1\n#define SZ_DMAGO\t\t6\n\n#define BRST_LEN(ccr)\t\t((((ccr) >> CC_SRCBRSTLEN_SHFT) & 0xf) + 1)\n#define BRST_SIZE(ccr)\t\t(1 << (((ccr) >> CC_SRCBRSTSIZE_SHFT) & 0x7))\n\n#define BYTE_TO_BURST(b, ccr)\t((b) / BRST_SIZE(ccr) / BRST_LEN(ccr))\n#define BURST_TO_BYTE(c, ccr)\t((c) * BRST_SIZE(ccr) * BRST_LEN(ccr))\n\n \n#define MCODE_BUFF_PER_REQ\t256\n\n \n#define UNTIL(t, s)\twhile (!(_state(t) & (s))) cpu_relax();\n\n#ifdef PL330_DEBUG_MCGEN\nstatic unsigned cmd_line;\n#define PL330_DBGCMD_DUMP(off, x...)\tdo { \\\n\t\t\t\t\t\tprintk(\"%x:\", cmd_line); \\\n\t\t\t\t\t\tprintk(KERN_CONT x); \\\n\t\t\t\t\t\tcmd_line += off; \\\n\t\t\t\t\t} while (0)\n#define PL330_DBGMC_START(addr)\t\t(cmd_line = addr)\n#else\n#define PL330_DBGCMD_DUMP(off, x...)\tdo {} while (0)\n#define PL330_DBGMC_START(addr)\t\tdo {} while (0)\n#endif\n\n \n\n#define NR_DEFAULT_DESC\t16\n\n \n#define PL330_AUTOSUSPEND_DELAY 20\n\n \nstruct pl330_config {\n\tu32\tperiph_id;\n#define DMAC_MODE_NS\t(1 << 0)\n\tunsigned int\tmode;\n\tunsigned int\tdata_bus_width:10;  \n\tunsigned int\tdata_buf_dep:11;\n\tunsigned int\tnum_chan:4;\n\tunsigned int\tnum_peri:6;\n\tu32\t\tperi_ns;\n\tunsigned int\tnum_events:6;\n\tu32\t\tirq_ns;\n};\n\n \nstruct pl330_reqcfg {\n\t \n\tunsigned dst_inc:1;\n\tunsigned src_inc:1;\n\n\t \n\tbool nonsecure;\n\tbool privileged;\n\tbool insnaccess;\n\tunsigned brst_len:5;\n\tunsigned brst_size:3;  \n\n\tenum pl330_cachectrl dcctl;\n\tenum pl330_cachectrl scctl;\n\tenum pl330_byteswap swap;\n\tstruct pl330_config *pcfg;\n};\n\n \nstruct pl330_xfer {\n\tu32 src_addr;\n\tu32 dst_addr;\n\t \n\tu32 bytes;\n};\n\n \nenum pl330_op_err {\n\t \n\tPL330_ERR_NONE,\n\t \n\tPL330_ERR_ABORT,\n\t \n\tPL330_ERR_FAIL,\n};\n\nenum dmamov_dst {\n\tSAR = 0,\n\tCCR,\n\tDAR,\n};\n\nenum pl330_dst {\n\tSRC = 0,\n\tDST,\n};\n\nenum pl330_cond {\n\tSINGLE,\n\tBURST,\n\tALWAYS,\n};\n\nstruct dma_pl330_desc;\n\nstruct _pl330_req {\n\tu32 mc_bus;\n\tvoid *mc_cpu;\n\tstruct dma_pl330_desc *desc;\n};\n\n \nstruct _pl330_tbd {\n\tbool reset_dmac;\n\tbool reset_mngr;\n\tu8 reset_chan;\n};\n\n \nstruct pl330_thread {\n\tu8 id;\n\tint ev;\n\t \n\tbool free;\n\t \n\tstruct pl330_dmac *dmac;\n\t \n\tstruct _pl330_req req[2];\n\t \n\tunsigned lstenq;\n\t \n\tint req_running;\n};\n\nenum pl330_dmac_state {\n\tUNINIT,\n\tINIT,\n\tDYING,\n};\n\nenum desc_status {\n\t \n\tFREE,\n\t \n\tPREP,\n\t \n\tBUSY,\n\t \n\tPAUSED,\n\t \n\tDONE,\n};\n\nstruct dma_pl330_chan {\n\t \n\tstruct tasklet_struct task;\n\n\t \n\tstruct dma_chan chan;\n\n\t \n\tstruct list_head submitted_list;\n\t \n\tstruct list_head work_list;\n\t \n\tstruct list_head completed_list;\n\n\t \n\tstruct pl330_dmac *dmac;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct pl330_thread *thread;\n\n\t \n\tint burst_sz;  \n\tint burst_len;  \n\tphys_addr_t fifo_addr;\n\t \n\tdma_addr_t fifo_dma;\n\tenum dma_data_direction dir;\n\tstruct dma_slave_config slave_config;\n\n\t \n\tbool cyclic;\n\n\t \n\tbool active;\n};\n\nstruct pl330_dmac {\n\t \n\tstruct dma_device ddma;\n\n\t \n\tstruct list_head desc_pool;\n\t \n\tspinlock_t pool_lock;\n\n\t \n\tunsigned mcbufsz;\n\t \n\tvoid __iomem\t*base;\n\t \n\tstruct pl330_config\tpcfg;\n\n\tspinlock_t\t\tlock;\n\t \n\tint\t\t\tevents[32];\n\t \n\tdma_addr_t\t\tmcode_bus;\n\t \n\tvoid\t\t\t*mcode_cpu;\n\t \n\tstruct pl330_thread\t*channels;\n\t \n\tstruct pl330_thread\t*manager;\n\t \n\tstruct tasklet_struct\ttasks;\n\tstruct _pl330_tbd\tdmac_tbd;\n\t \n\tenum pl330_dmac_state\tstate;\n\t \n\tstruct list_head        req_done;\n\n\t \n\tunsigned int num_peripherals;\n\tstruct dma_pl330_chan *peripherals;  \n\tint quirks;\n\n\tstruct reset_control\t*rstc;\n\tstruct reset_control\t*rstc_ocp;\n};\n\nstatic struct pl330_of_quirks {\n\tchar *quirk;\n\tint id;\n} of_quirks[] = {\n\t{\n\t\t.quirk = \"arm,pl330-broken-no-flushp\",\n\t\t.id = PL330_QUIRK_BROKEN_NO_FLUSHP,\n\t},\n\t{\n\t\t.quirk = \"arm,pl330-periph-burst\",\n\t\t.id = PL330_QUIRK_PERIPH_BURST,\n\t}\n};\n\nstruct dma_pl330_desc {\n\t \n\tstruct list_head node;\n\n\t \n\tstruct dma_async_tx_descriptor txd;\n\n\t \n\tstruct pl330_xfer px;\n\n\tstruct pl330_reqcfg rqcfg;\n\n\tenum desc_status status;\n\n\tint bytes_requested;\n\tbool last;\n\n\t \n\tstruct dma_pl330_chan *pchan;\n\n\tenum dma_transfer_direction rqtype;\n\t \n\tunsigned peri:5;\n\t \n\tstruct list_head rqd;\n};\n\nstruct _xfer_spec {\n\tu32 ccr;\n\tstruct dma_pl330_desc *desc;\n};\n\nstatic int pl330_config_write(struct dma_chan *chan,\n\t\t\tstruct dma_slave_config *slave_config,\n\t\t\tenum dma_transfer_direction direction);\n\nstatic inline bool _queue_full(struct pl330_thread *thrd)\n{\n\treturn thrd->req[0].desc != NULL && thrd->req[1].desc != NULL;\n}\n\nstatic inline bool is_manager(struct pl330_thread *thrd)\n{\n\treturn thrd->dmac->manager == thrd;\n}\n\n \nstatic inline bool _manager_ns(struct pl330_thread *thrd)\n{\n\treturn (thrd->dmac->pcfg.mode & DMAC_MODE_NS) ? true : false;\n}\n\nstatic inline u32 get_revision(u32 periph_id)\n{\n\treturn (periph_id >> PERIPH_REV_SHIFT) & PERIPH_REV_MASK;\n}\n\nstatic inline u32 _emit_END(unsigned dry_run, u8 buf[])\n{\n\tif (dry_run)\n\t\treturn SZ_DMAEND;\n\n\tbuf[0] = CMD_DMAEND;\n\n\tPL330_DBGCMD_DUMP(SZ_DMAEND, \"\\tDMAEND\\n\");\n\n\treturn SZ_DMAEND;\n}\n\nstatic inline u32 _emit_FLUSHP(unsigned dry_run, u8 buf[], u8 peri)\n{\n\tif (dry_run)\n\t\treturn SZ_DMAFLUSHP;\n\n\tbuf[0] = CMD_DMAFLUSHP;\n\n\tperi &= 0x1f;\n\tperi <<= 3;\n\tbuf[1] = peri;\n\n\tPL330_DBGCMD_DUMP(SZ_DMAFLUSHP, \"\\tDMAFLUSHP %u\\n\", peri >> 3);\n\n\treturn SZ_DMAFLUSHP;\n}\n\nstatic inline u32 _emit_LD(unsigned dry_run, u8 buf[],\tenum pl330_cond cond)\n{\n\tif (dry_run)\n\t\treturn SZ_DMALD;\n\n\tbuf[0] = CMD_DMALD;\n\n\tif (cond == SINGLE)\n\t\tbuf[0] |= (0 << 1) | (1 << 0);\n\telse if (cond == BURST)\n\t\tbuf[0] |= (1 << 1) | (1 << 0);\n\n\tPL330_DBGCMD_DUMP(SZ_DMALD, \"\\tDMALD%c\\n\",\n\t\tcond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'));\n\n\treturn SZ_DMALD;\n}\n\nstatic inline u32 _emit_LDP(unsigned dry_run, u8 buf[],\n\t\tenum pl330_cond cond, u8 peri)\n{\n\tif (dry_run)\n\t\treturn SZ_DMALDP;\n\n\tbuf[0] = CMD_DMALDP;\n\n\tif (cond == BURST)\n\t\tbuf[0] |= (1 << 1);\n\n\tperi &= 0x1f;\n\tperi <<= 3;\n\tbuf[1] = peri;\n\n\tPL330_DBGCMD_DUMP(SZ_DMALDP, \"\\tDMALDP%c %u\\n\",\n\t\tcond == SINGLE ? 'S' : 'B', peri >> 3);\n\n\treturn SZ_DMALDP;\n}\n\nstatic inline u32 _emit_LP(unsigned dry_run, u8 buf[],\n\t\tunsigned loop, u8 cnt)\n{\n\tif (dry_run)\n\t\treturn SZ_DMALP;\n\n\tbuf[0] = CMD_DMALP;\n\n\tif (loop)\n\t\tbuf[0] |= (1 << 1);\n\n\tcnt--;  \n\tbuf[1] = cnt;\n\n\tPL330_DBGCMD_DUMP(SZ_DMALP, \"\\tDMALP_%c %u\\n\", loop ? '1' : '0', cnt);\n\n\treturn SZ_DMALP;\n}\n\nstruct _arg_LPEND {\n\tenum pl330_cond cond;\n\tbool forever;\n\tunsigned loop;\n\tu8 bjump;\n};\n\nstatic inline u32 _emit_LPEND(unsigned dry_run, u8 buf[],\n\t\tconst struct _arg_LPEND *arg)\n{\n\tenum pl330_cond cond = arg->cond;\n\tbool forever = arg->forever;\n\tunsigned loop = arg->loop;\n\tu8 bjump = arg->bjump;\n\n\tif (dry_run)\n\t\treturn SZ_DMALPEND;\n\n\tbuf[0] = CMD_DMALPEND;\n\n\tif (loop)\n\t\tbuf[0] |= (1 << 2);\n\n\tif (!forever)\n\t\tbuf[0] |= (1 << 4);\n\n\tif (cond == SINGLE)\n\t\tbuf[0] |= (0 << 1) | (1 << 0);\n\telse if (cond == BURST)\n\t\tbuf[0] |= (1 << 1) | (1 << 0);\n\n\tbuf[1] = bjump;\n\n\tPL330_DBGCMD_DUMP(SZ_DMALPEND, \"\\tDMALP%s%c_%c bjmpto_%x\\n\",\n\t\t\tforever ? \"FE\" : \"END\",\n\t\t\tcond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'),\n\t\t\tloop ? '1' : '0',\n\t\t\tbjump);\n\n\treturn SZ_DMALPEND;\n}\n\nstatic inline u32 _emit_KILL(unsigned dry_run, u8 buf[])\n{\n\tif (dry_run)\n\t\treturn SZ_DMAKILL;\n\n\tbuf[0] = CMD_DMAKILL;\n\n\treturn SZ_DMAKILL;\n}\n\nstatic inline u32 _emit_MOV(unsigned dry_run, u8 buf[],\n\t\tenum dmamov_dst dst, u32 val)\n{\n\tif (dry_run)\n\t\treturn SZ_DMAMOV;\n\n\tbuf[0] = CMD_DMAMOV;\n\tbuf[1] = dst;\n\tbuf[2] = val;\n\tbuf[3] = val >> 8;\n\tbuf[4] = val >> 16;\n\tbuf[5] = val >> 24;\n\n\tPL330_DBGCMD_DUMP(SZ_DMAMOV, \"\\tDMAMOV %s 0x%x\\n\",\n\t\tdst == SAR ? \"SAR\" : (dst == DAR ? \"DAR\" : \"CCR\"), val);\n\n\treturn SZ_DMAMOV;\n}\n\nstatic inline u32 _emit_RMB(unsigned dry_run, u8 buf[])\n{\n\tif (dry_run)\n\t\treturn SZ_DMARMB;\n\n\tbuf[0] = CMD_DMARMB;\n\n\tPL330_DBGCMD_DUMP(SZ_DMARMB, \"\\tDMARMB\\n\");\n\n\treturn SZ_DMARMB;\n}\n\nstatic inline u32 _emit_SEV(unsigned dry_run, u8 buf[], u8 ev)\n{\n\tif (dry_run)\n\t\treturn SZ_DMASEV;\n\n\tbuf[0] = CMD_DMASEV;\n\n\tev &= 0x1f;\n\tev <<= 3;\n\tbuf[1] = ev;\n\n\tPL330_DBGCMD_DUMP(SZ_DMASEV, \"\\tDMASEV %u\\n\", ev >> 3);\n\n\treturn SZ_DMASEV;\n}\n\nstatic inline u32 _emit_ST(unsigned dry_run, u8 buf[], enum pl330_cond cond)\n{\n\tif (dry_run)\n\t\treturn SZ_DMAST;\n\n\tbuf[0] = CMD_DMAST;\n\n\tif (cond == SINGLE)\n\t\tbuf[0] |= (0 << 1) | (1 << 0);\n\telse if (cond == BURST)\n\t\tbuf[0] |= (1 << 1) | (1 << 0);\n\n\tPL330_DBGCMD_DUMP(SZ_DMAST, \"\\tDMAST%c\\n\",\n\t\tcond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'A'));\n\n\treturn SZ_DMAST;\n}\n\nstatic inline u32 _emit_STP(unsigned dry_run, u8 buf[],\n\t\tenum pl330_cond cond, u8 peri)\n{\n\tif (dry_run)\n\t\treturn SZ_DMASTP;\n\n\tbuf[0] = CMD_DMASTP;\n\n\tif (cond == BURST)\n\t\tbuf[0] |= (1 << 1);\n\n\tperi &= 0x1f;\n\tperi <<= 3;\n\tbuf[1] = peri;\n\n\tPL330_DBGCMD_DUMP(SZ_DMASTP, \"\\tDMASTP%c %u\\n\",\n\t\tcond == SINGLE ? 'S' : 'B', peri >> 3);\n\n\treturn SZ_DMASTP;\n}\n\nstatic inline u32 _emit_WFP(unsigned dry_run, u8 buf[],\n\t\tenum pl330_cond cond, u8 peri)\n{\n\tif (dry_run)\n\t\treturn SZ_DMAWFP;\n\n\tbuf[0] = CMD_DMAWFP;\n\n\tif (cond == SINGLE)\n\t\tbuf[0] |= (0 << 1) | (0 << 0);\n\telse if (cond == BURST)\n\t\tbuf[0] |= (1 << 1) | (0 << 0);\n\telse\n\t\tbuf[0] |= (0 << 1) | (1 << 0);\n\n\tperi &= 0x1f;\n\tperi <<= 3;\n\tbuf[1] = peri;\n\n\tPL330_DBGCMD_DUMP(SZ_DMAWFP, \"\\tDMAWFP%c %u\\n\",\n\t\tcond == SINGLE ? 'S' : (cond == BURST ? 'B' : 'P'), peri >> 3);\n\n\treturn SZ_DMAWFP;\n}\n\nstatic inline u32 _emit_WMB(unsigned dry_run, u8 buf[])\n{\n\tif (dry_run)\n\t\treturn SZ_DMAWMB;\n\n\tbuf[0] = CMD_DMAWMB;\n\n\tPL330_DBGCMD_DUMP(SZ_DMAWMB, \"\\tDMAWMB\\n\");\n\n\treturn SZ_DMAWMB;\n}\n\nstruct _arg_GO {\n\tu8 chan;\n\tu32 addr;\n\tunsigned ns;\n};\n\nstatic inline u32 _emit_GO(unsigned dry_run, u8 buf[],\n\t\tconst struct _arg_GO *arg)\n{\n\tu8 chan = arg->chan;\n\tu32 addr = arg->addr;\n\tunsigned ns = arg->ns;\n\n\tif (dry_run)\n\t\treturn SZ_DMAGO;\n\n\tbuf[0] = CMD_DMAGO;\n\tbuf[0] |= (ns << 1);\n\tbuf[1] = chan & 0x7;\n\tbuf[2] = addr;\n\tbuf[3] = addr >> 8;\n\tbuf[4] = addr >> 16;\n\tbuf[5] = addr >> 24;\n\n\treturn SZ_DMAGO;\n}\n\n#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)\n\n \nstatic bool _until_dmac_idle(struct pl330_thread *thrd)\n{\n\tvoid __iomem *regs = thrd->dmac->base;\n\tunsigned long loops = msecs_to_loops(5);\n\n\tdo {\n\t\t \n\t\tif (!(readl(regs + DBGSTATUS) & DBG_BUSY))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t} while (--loops);\n\n\tif (!loops)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void _execute_DBGINSN(struct pl330_thread *thrd,\n\t\tu8 insn[], bool as_manager)\n{\n\tvoid __iomem *regs = thrd->dmac->base;\n\tu32 val;\n\n\t \n\tif (_until_dmac_idle(thrd)) {\n\t\tdev_err(thrd->dmac->ddma.dev, \"DMAC halted!\\n\");\n\t\treturn;\n\t}\n\n\tval = (insn[0] << 16) | (insn[1] << 24);\n\tif (!as_manager) {\n\t\tval |= (1 << 0);\n\t\tval |= (thrd->id << 8);  \n\t}\n\twritel(val, regs + DBGINST0);\n\n\tval = le32_to_cpu(*((__le32 *)&insn[2]));\n\twritel(val, regs + DBGINST1);\n\n\t \n\twritel(0, regs + DBGCMD);\n}\n\nstatic inline u32 _state(struct pl330_thread *thrd)\n{\n\tvoid __iomem *regs = thrd->dmac->base;\n\tu32 val;\n\n\tif (is_manager(thrd))\n\t\tval = readl(regs + DS) & 0xf;\n\telse\n\t\tval = readl(regs + CS(thrd->id)) & 0xf;\n\n\tswitch (val) {\n\tcase DS_ST_STOP:\n\t\treturn PL330_STATE_STOPPED;\n\tcase DS_ST_EXEC:\n\t\treturn PL330_STATE_EXECUTING;\n\tcase DS_ST_CMISS:\n\t\treturn PL330_STATE_CACHEMISS;\n\tcase DS_ST_UPDTPC:\n\t\treturn PL330_STATE_UPDTPC;\n\tcase DS_ST_WFE:\n\t\treturn PL330_STATE_WFE;\n\tcase DS_ST_FAULT:\n\t\treturn PL330_STATE_FAULTING;\n\tcase DS_ST_ATBRR:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_ATBARRIER;\n\tcase DS_ST_QBUSY:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_QUEUEBUSY;\n\tcase DS_ST_WFP:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_WFP;\n\tcase DS_ST_KILL:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_KILLING;\n\tcase DS_ST_CMPLT:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_COMPLETING;\n\tcase DS_ST_FLTCMP:\n\t\tif (is_manager(thrd))\n\t\t\treturn PL330_STATE_INVALID;\n\t\telse\n\t\t\treturn PL330_STATE_FAULT_COMPLETING;\n\tdefault:\n\t\treturn PL330_STATE_INVALID;\n\t}\n}\n\nstatic void _stop(struct pl330_thread *thrd)\n{\n\tvoid __iomem *regs = thrd->dmac->base;\n\tu8 insn[6] = {0, 0, 0, 0, 0, 0};\n\tu32 inten = readl(regs + INTEN);\n\n\tif (_state(thrd) == PL330_STATE_FAULT_COMPLETING)\n\t\tUNTIL(thrd, PL330_STATE_FAULTING | PL330_STATE_KILLING);\n\n\t \n\tif (_state(thrd) == PL330_STATE_COMPLETING\n\t\t  || _state(thrd) == PL330_STATE_KILLING\n\t\t  || _state(thrd) == PL330_STATE_STOPPED)\n\t\treturn;\n\n\t_emit_KILL(0, insn);\n\n\t_execute_DBGINSN(thrd, insn, is_manager(thrd));\n\n\t \n\tif (inten & (1 << thrd->ev))\n\t\twritel(1 << thrd->ev, regs + INTCLR);\n\t \n\twritel(inten & ~(1 << thrd->ev), regs + INTEN);\n}\n\n \nstatic bool _trigger(struct pl330_thread *thrd)\n{\n\tvoid __iomem *regs = thrd->dmac->base;\n\tstruct _pl330_req *req;\n\tstruct dma_pl330_desc *desc;\n\tstruct _arg_GO go;\n\tunsigned ns;\n\tu8 insn[6] = {0, 0, 0, 0, 0, 0};\n\tint idx;\n\n\t \n\tif (_state(thrd) != PL330_STATE_STOPPED)\n\t\treturn true;\n\n\tidx = 1 - thrd->lstenq;\n\tif (thrd->req[idx].desc != NULL) {\n\t\treq = &thrd->req[idx];\n\t} else {\n\t\tidx = thrd->lstenq;\n\t\tif (thrd->req[idx].desc != NULL)\n\t\t\treq = &thrd->req[idx];\n\t\telse\n\t\t\treq = NULL;\n\t}\n\n\t \n\tif (!req)\n\t\treturn true;\n\n\t \n\tif (idx == thrd->req_running)\n\t\treturn true;\n\n\tdesc = req->desc;\n\n\tns = desc->rqcfg.nonsecure ? 1 : 0;\n\n\t \n\tif (_manager_ns(thrd) && !ns)\n\t\tdev_info(thrd->dmac->ddma.dev, \"%s:%d Recipe for ABORT!\\n\",\n\t\t\t__func__, __LINE__);\n\n\tgo.chan = thrd->id;\n\tgo.addr = req->mc_bus;\n\tgo.ns = ns;\n\t_emit_GO(0, insn, &go);\n\n\t \n\twritel(readl(regs + INTEN) | (1 << thrd->ev), regs + INTEN);\n\n\t \n\t_execute_DBGINSN(thrd, insn, true);\n\n\tthrd->req_running = idx;\n\n\treturn true;\n}\n\nstatic bool pl330_start_thread(struct pl330_thread *thrd)\n{\n\tswitch (_state(thrd)) {\n\tcase PL330_STATE_FAULT_COMPLETING:\n\t\tUNTIL(thrd, PL330_STATE_FAULTING | PL330_STATE_KILLING);\n\n\t\tif (_state(thrd) == PL330_STATE_KILLING)\n\t\t\tUNTIL(thrd, PL330_STATE_STOPPED)\n\t\tfallthrough;\n\n\tcase PL330_STATE_FAULTING:\n\t\t_stop(thrd);\n\t\tfallthrough;\n\n\tcase PL330_STATE_KILLING:\n\tcase PL330_STATE_COMPLETING:\n\t\tUNTIL(thrd, PL330_STATE_STOPPED)\n\t\tfallthrough;\n\n\tcase PL330_STATE_STOPPED:\n\t\treturn _trigger(thrd);\n\n\tcase PL330_STATE_WFP:\n\tcase PL330_STATE_QUEUEBUSY:\n\tcase PL330_STATE_ATBARRIER:\n\tcase PL330_STATE_UPDTPC:\n\tcase PL330_STATE_CACHEMISS:\n\tcase PL330_STATE_EXECUTING:\n\t\treturn true;\n\n\tcase PL330_STATE_WFE:  \n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int _ldst_memtomem(unsigned dry_run, u8 buf[],\n\t\tconst struct _xfer_spec *pxs, int cyc)\n{\n\tint off = 0;\n\tstruct pl330_config *pcfg = pxs->desc->rqcfg.pcfg;\n\n\t \n\tif (get_revision(pcfg->periph_id) >= PERIPH_REV_R1P0) {\n\t\twhile (cyc--) {\n\t\t\toff += _emit_LD(dry_run, &buf[off], ALWAYS);\n\t\t\toff += _emit_ST(dry_run, &buf[off], ALWAYS);\n\t\t}\n\t} else {\n\t\twhile (cyc--) {\n\t\t\toff += _emit_LD(dry_run, &buf[off], ALWAYS);\n\t\t\toff += _emit_RMB(dry_run, &buf[off]);\n\t\t\toff += _emit_ST(dry_run, &buf[off], ALWAYS);\n\t\t\toff += _emit_WMB(dry_run, &buf[off]);\n\t\t}\n\t}\n\n\treturn off;\n}\n\nstatic u32 _emit_load(unsigned int dry_run, u8 buf[],\n\tenum pl330_cond cond, enum dma_transfer_direction direction,\n\tu8 peri)\n{\n\tint off = 0;\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_MEM:\n\tcase DMA_MEM_TO_DEV:\n\t\toff += _emit_LD(dry_run, &buf[off], cond);\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tif (cond == ALWAYS) {\n\t\t\toff += _emit_LDP(dry_run, &buf[off], SINGLE,\n\t\t\t\tperi);\n\t\t\toff += _emit_LDP(dry_run, &buf[off], BURST,\n\t\t\t\tperi);\n\t\t} else {\n\t\t\toff += _emit_LDP(dry_run, &buf[off], cond,\n\t\t\t\tperi);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn off;\n}\n\nstatic inline u32 _emit_store(unsigned int dry_run, u8 buf[],\n\tenum pl330_cond cond, enum dma_transfer_direction direction,\n\tu8 peri)\n{\n\tint off = 0;\n\n\tswitch (direction) {\n\tcase DMA_MEM_TO_MEM:\n\tcase DMA_DEV_TO_MEM:\n\t\toff += _emit_ST(dry_run, &buf[off], cond);\n\t\tbreak;\n\n\tcase DMA_MEM_TO_DEV:\n\t\tif (cond == ALWAYS) {\n\t\t\toff += _emit_STP(dry_run, &buf[off], SINGLE,\n\t\t\t\tperi);\n\t\t\toff += _emit_STP(dry_run, &buf[off], BURST,\n\t\t\t\tperi);\n\t\t} else {\n\t\t\toff += _emit_STP(dry_run, &buf[off], cond,\n\t\t\t\tperi);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn off;\n}\n\nstatic inline int _ldst_peripheral(struct pl330_dmac *pl330,\n\t\t\t\t unsigned dry_run, u8 buf[],\n\t\t\t\t const struct _xfer_spec *pxs, int cyc,\n\t\t\t\t enum pl330_cond cond)\n{\n\tint off = 0;\n\n\t \n\tif (!(pl330->quirks & PL330_QUIRK_BROKEN_NO_FLUSHP))\n\t\toff += _emit_FLUSHP(dry_run, &buf[off], pxs->desc->peri);\n\twhile (cyc--) {\n\t\toff += _emit_WFP(dry_run, &buf[off], cond, pxs->desc->peri);\n\t\toff += _emit_load(dry_run, &buf[off], cond, pxs->desc->rqtype,\n\t\t\tpxs->desc->peri);\n\t\toff += _emit_store(dry_run, &buf[off], cond, pxs->desc->rqtype,\n\t\t\tpxs->desc->peri);\n\t}\n\n\treturn off;\n}\n\nstatic int _bursts(struct pl330_dmac *pl330, unsigned dry_run, u8 buf[],\n\t\tconst struct _xfer_spec *pxs, int cyc)\n{\n\tint off = 0;\n\tenum pl330_cond cond = BRST_LEN(pxs->ccr) > 1 ? BURST : SINGLE;\n\n\tif (pl330->quirks & PL330_QUIRK_PERIPH_BURST)\n\t\tcond = BURST;\n\n\tswitch (pxs->desc->rqtype) {\n\tcase DMA_MEM_TO_DEV:\n\tcase DMA_DEV_TO_MEM:\n\t\toff += _ldst_peripheral(pl330, dry_run, &buf[off], pxs, cyc,\n\t\t\tcond);\n\t\tbreak;\n\n\tcase DMA_MEM_TO_MEM:\n\t\toff += _ldst_memtomem(dry_run, &buf[off], pxs, cyc);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn off;\n}\n\n \nstatic int _dregs(struct pl330_dmac *pl330, unsigned int dry_run, u8 buf[],\n\t\tconst struct _xfer_spec *pxs, int transfer_length)\n{\n\tint off = 0;\n\tint dregs_ccr;\n\n\tif (transfer_length == 0)\n\t\treturn off;\n\n\t \n\tdregs_ccr = pxs->ccr;\n\tdregs_ccr &= ~((0xf << CC_SRCBRSTLEN_SHFT) |\n\t\t(0xf << CC_DSTBRSTLEN_SHFT));\n\tdregs_ccr |= (((transfer_length - 1) & 0xf) <<\n\t\tCC_SRCBRSTLEN_SHFT);\n\tdregs_ccr |= (((transfer_length - 1) & 0xf) <<\n\t\tCC_DSTBRSTLEN_SHFT);\n\n\tswitch (pxs->desc->rqtype) {\n\tcase DMA_MEM_TO_DEV:\n\tcase DMA_DEV_TO_MEM:\n\t\toff += _emit_MOV(dry_run, &buf[off], CCR, dregs_ccr);\n\t\toff += _ldst_peripheral(pl330, dry_run, &buf[off], pxs, 1,\n\t\t\t\t\tBURST);\n\t\tbreak;\n\n\tcase DMA_MEM_TO_MEM:\n\t\toff += _emit_MOV(dry_run, &buf[off], CCR, dregs_ccr);\n\t\toff += _ldst_memtomem(dry_run, &buf[off], pxs, 1);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn off;\n}\n\n \nstatic inline int _loop(struct pl330_dmac *pl330, unsigned dry_run, u8 buf[],\n\t\tunsigned long *bursts, const struct _xfer_spec *pxs)\n{\n\tint cyc, cycmax, szlp, szlpend, szbrst, off;\n\tunsigned lcnt0, lcnt1, ljmp0, ljmp1;\n\tstruct _arg_LPEND lpend;\n\n\tif (*bursts == 1)\n\t\treturn _bursts(pl330, dry_run, buf, pxs, 1);\n\n\t \n\tif (*bursts >= 256*256) {\n\t\tlcnt1 = 256;\n\t\tlcnt0 = 256;\n\t\tcyc = *bursts / lcnt1 / lcnt0;\n\t} else if (*bursts > 256) {\n\t\tlcnt1 = 256;\n\t\tlcnt0 = *bursts / lcnt1;\n\t\tcyc = 1;\n\t} else {\n\t\tlcnt1 = *bursts;\n\t\tlcnt0 = 0;\n\t\tcyc = 1;\n\t}\n\n\tszlp = _emit_LP(1, buf, 0, 0);\n\tszbrst = _bursts(pl330, 1, buf, pxs, 1);\n\n\tlpend.cond = ALWAYS;\n\tlpend.forever = false;\n\tlpend.loop = 0;\n\tlpend.bjump = 0;\n\tszlpend = _emit_LPEND(1, buf, &lpend);\n\n\tif (lcnt0) {\n\t\tszlp *= 2;\n\t\tszlpend *= 2;\n\t}\n\n\t \n\tcycmax = (255 - (szlp + szlpend)) / szbrst;\n\n\tcyc = (cycmax < cyc) ? cycmax : cyc;\n\n\toff = 0;\n\n\tif (lcnt0) {\n\t\toff += _emit_LP(dry_run, &buf[off], 0, lcnt0);\n\t\tljmp0 = off;\n\t}\n\n\toff += _emit_LP(dry_run, &buf[off], 1, lcnt1);\n\tljmp1 = off;\n\n\toff += _bursts(pl330, dry_run, &buf[off], pxs, cyc);\n\n\tlpend.cond = ALWAYS;\n\tlpend.forever = false;\n\tlpend.loop = 1;\n\tlpend.bjump = off - ljmp1;\n\toff += _emit_LPEND(dry_run, &buf[off], &lpend);\n\n\tif (lcnt0) {\n\t\tlpend.cond = ALWAYS;\n\t\tlpend.forever = false;\n\t\tlpend.loop = 0;\n\t\tlpend.bjump = off - ljmp0;\n\t\toff += _emit_LPEND(dry_run, &buf[off], &lpend);\n\t}\n\n\t*bursts = lcnt1 * cyc;\n\tif (lcnt0)\n\t\t*bursts *= lcnt0;\n\n\treturn off;\n}\n\nstatic inline int _setup_loops(struct pl330_dmac *pl330,\n\t\t\t       unsigned dry_run, u8 buf[],\n\t\t\t       const struct _xfer_spec *pxs)\n{\n\tstruct pl330_xfer *x = &pxs->desc->px;\n\tu32 ccr = pxs->ccr;\n\tunsigned long c, bursts = BYTE_TO_BURST(x->bytes, ccr);\n\tint num_dregs = (x->bytes - BURST_TO_BYTE(bursts, ccr)) /\n\t\tBRST_SIZE(ccr);\n\tint off = 0;\n\n\twhile (bursts) {\n\t\tc = bursts;\n\t\toff += _loop(pl330, dry_run, &buf[off], &c, pxs);\n\t\tbursts -= c;\n\t}\n\toff += _dregs(pl330, dry_run, &buf[off], pxs, num_dregs);\n\n\treturn off;\n}\n\nstatic inline int _setup_xfer(struct pl330_dmac *pl330,\n\t\t\t      unsigned dry_run, u8 buf[],\n\t\t\t      const struct _xfer_spec *pxs)\n{\n\tstruct pl330_xfer *x = &pxs->desc->px;\n\tint off = 0;\n\n\t \n\toff += _emit_MOV(dry_run, &buf[off], SAR, x->src_addr);\n\t \n\toff += _emit_MOV(dry_run, &buf[off], DAR, x->dst_addr);\n\n\t \n\toff += _setup_loops(pl330, dry_run, &buf[off], pxs);\n\n\treturn off;\n}\n\n \nstatic int _setup_req(struct pl330_dmac *pl330, unsigned dry_run,\n\t\t      struct pl330_thread *thrd, unsigned index,\n\t\t      struct _xfer_spec *pxs)\n{\n\tstruct _pl330_req *req = &thrd->req[index];\n\tu8 *buf = req->mc_cpu;\n\tint off = 0;\n\n\tPL330_DBGMC_START(req->mc_bus);\n\n\t \n\toff += _emit_MOV(dry_run, &buf[off], CCR, pxs->ccr);\n\n\toff += _setup_xfer(pl330, dry_run, &buf[off], pxs);\n\n\t \n\toff += _emit_SEV(dry_run, &buf[off], thrd->ev);\n\t \n\toff += _emit_END(dry_run, &buf[off]);\n\n\treturn off;\n}\n\nstatic inline u32 _prepare_ccr(const struct pl330_reqcfg *rqc)\n{\n\tu32 ccr = 0;\n\n\tif (rqc->src_inc)\n\t\tccr |= CC_SRCINC;\n\n\tif (rqc->dst_inc)\n\t\tccr |= CC_DSTINC;\n\n\t \n\tif (rqc->privileged)\n\t\tccr |= CC_SRCPRI | CC_DSTPRI;\n\tif (rqc->nonsecure)\n\t\tccr |= CC_SRCNS | CC_DSTNS;\n\tif (rqc->insnaccess)\n\t\tccr |= CC_SRCIA | CC_DSTIA;\n\n\tccr |= (((rqc->brst_len - 1) & 0xf) << CC_SRCBRSTLEN_SHFT);\n\tccr |= (((rqc->brst_len - 1) & 0xf) << CC_DSTBRSTLEN_SHFT);\n\n\tccr |= (rqc->brst_size << CC_SRCBRSTSIZE_SHFT);\n\tccr |= (rqc->brst_size << CC_DSTBRSTSIZE_SHFT);\n\n\tccr |= (rqc->scctl << CC_SRCCCTRL_SHFT);\n\tccr |= (rqc->dcctl << CC_DSTCCTRL_SHFT);\n\n\tccr |= (rqc->swap << CC_SWAP_SHFT);\n\n\treturn ccr;\n}\n\n \nstatic int pl330_submit_req(struct pl330_thread *thrd,\n\tstruct dma_pl330_desc *desc)\n{\n\tstruct pl330_dmac *pl330 = thrd->dmac;\n\tstruct _xfer_spec xs;\n\tunsigned long flags;\n\tunsigned idx;\n\tu32 ccr;\n\tint ret = 0;\n\n\tswitch (desc->rqtype) {\n\tcase DMA_MEM_TO_DEV:\n\t\tbreak;\n\n\tcase DMA_DEV_TO_MEM:\n\t\tbreak;\n\n\tcase DMA_MEM_TO_MEM:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (pl330->state == DYING\n\t\t|| pl330->dmac_tbd.reset_chan & (1 << thrd->id)) {\n\t\tdev_info(thrd->dmac->ddma.dev, \"%s:%d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (desc->rqtype != DMA_MEM_TO_MEM &&\n\t    desc->peri >= pl330->pcfg.num_peri) {\n\t\tdev_info(thrd->dmac->ddma.dev,\n\t\t\t\t\"%s:%d Invalid peripheral(%u)!\\n\",\n\t\t\t\t__func__, __LINE__, desc->peri);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&pl330->lock, flags);\n\n\tif (_queue_full(thrd)) {\n\t\tret = -EAGAIN;\n\t\tgoto xfer_exit;\n\t}\n\n\t \n\tif (!_manager_ns(thrd))\n\t\tdesc->rqcfg.nonsecure = 0;\n\telse\n\t\tdesc->rqcfg.nonsecure = 1;\n\n\tccr = _prepare_ccr(&desc->rqcfg);\n\n\tidx = thrd->req[0].desc == NULL ? 0 : 1;\n\n\txs.ccr = ccr;\n\txs.desc = desc;\n\n\t \n\tret = _setup_req(pl330, 1, thrd, idx, &xs);\n\n\tif (ret > pl330->mcbufsz / 2) {\n\t\tdev_info(pl330->ddma.dev, \"%s:%d Try increasing mcbufsz (%i/%i)\\n\",\n\t\t\t\t__func__, __LINE__, ret, pl330->mcbufsz / 2);\n\t\tret = -ENOMEM;\n\t\tgoto xfer_exit;\n\t}\n\n\t \n\tthrd->lstenq = idx;\n\tthrd->req[idx].desc = desc;\n\t_setup_req(pl330, 0, thrd, idx, &xs);\n\n\tret = 0;\n\nxfer_exit:\n\tspin_unlock_irqrestore(&pl330->lock, flags);\n\n\treturn ret;\n}\n\nstatic void dma_pl330_rqcb(struct dma_pl330_desc *desc, enum pl330_op_err err)\n{\n\tstruct dma_pl330_chan *pch;\n\tunsigned long flags;\n\n\tif (!desc)\n\t\treturn;\n\n\tpch = desc->pchan;\n\n\t \n\tif (!pch)\n\t\treturn;\n\n\tspin_lock_irqsave(&pch->lock, flags);\n\n\tdesc->status = DONE;\n\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\n\ttasklet_schedule(&pch->task);\n}\n\nstatic void pl330_dotask(struct tasklet_struct *t)\n{\n\tstruct pl330_dmac *pl330 = from_tasklet(pl330, t, tasks);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&pl330->lock, flags);\n\n\t \n\tif (pl330->dmac_tbd.reset_dmac) {\n\t\tpl330->state = DYING;\n\t\t \n\t\tpl330->dmac_tbd.reset_mngr = true;\n\t\t \n\t\tpl330->dmac_tbd.reset_dmac = false;\n\t}\n\n\tif (pl330->dmac_tbd.reset_mngr) {\n\t\t_stop(pl330->manager);\n\t\t \n\t\tpl330->dmac_tbd.reset_chan = (1 << pl330->pcfg.num_chan) - 1;\n\t\t \n\t\tpl330->dmac_tbd.reset_mngr = false;\n\t}\n\n\tfor (i = 0; i < pl330->pcfg.num_chan; i++) {\n\n\t\tif (pl330->dmac_tbd.reset_chan & (1 << i)) {\n\t\t\tstruct pl330_thread *thrd = &pl330->channels[i];\n\t\t\tvoid __iomem *regs = pl330->base;\n\t\t\tenum pl330_op_err err;\n\n\t\t\t_stop(thrd);\n\n\t\t\tif (readl(regs + FSC) & (1 << thrd->id))\n\t\t\t\terr = PL330_ERR_FAIL;\n\t\t\telse\n\t\t\t\terr = PL330_ERR_ABORT;\n\n\t\t\tspin_unlock_irqrestore(&pl330->lock, flags);\n\t\t\tdma_pl330_rqcb(thrd->req[1 - thrd->lstenq].desc, err);\n\t\t\tdma_pl330_rqcb(thrd->req[thrd->lstenq].desc, err);\n\t\t\tspin_lock_irqsave(&pl330->lock, flags);\n\n\t\t\tthrd->req[0].desc = NULL;\n\t\t\tthrd->req[1].desc = NULL;\n\t\t\tthrd->req_running = -1;\n\n\t\t\t \n\t\t\tpl330->dmac_tbd.reset_chan &= ~(1 << i);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pl330->lock, flags);\n\n\treturn;\n}\n\n \nstatic int pl330_update(struct pl330_dmac *pl330)\n{\n\tstruct dma_pl330_desc *descdone;\n\tunsigned long flags;\n\tvoid __iomem *regs;\n\tu32 val;\n\tint id, ev, ret = 0;\n\n\tregs = pl330->base;\n\n\tspin_lock_irqsave(&pl330->lock, flags);\n\n\tval = readl(regs + FSM) & 0x1;\n\tif (val)\n\t\tpl330->dmac_tbd.reset_mngr = true;\n\telse\n\t\tpl330->dmac_tbd.reset_mngr = false;\n\n\tval = readl(regs + FSC) & ((1 << pl330->pcfg.num_chan) - 1);\n\tpl330->dmac_tbd.reset_chan |= val;\n\tif (val) {\n\t\tint i = 0;\n\t\twhile (i < pl330->pcfg.num_chan) {\n\t\t\tif (val & (1 << i)) {\n\t\t\t\tdev_info(pl330->ddma.dev,\n\t\t\t\t\t\"Reset Channel-%d\\t CS-%x FTC-%x\\n\",\n\t\t\t\t\t\ti, readl(regs + CS(i)),\n\t\t\t\t\t\treadl(regs + FTC(i)));\n\t\t\t\t_stop(&pl330->channels[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tval = readl(regs + ES);\n\tif (pl330->pcfg.num_events < 32\n\t\t\t&& val & ~((1 << pl330->pcfg.num_events) - 1)) {\n\t\tpl330->dmac_tbd.reset_dmac = true;\n\t\tdev_err(pl330->ddma.dev, \"%s:%d Unexpected!\\n\", __func__,\n\t\t\t__LINE__);\n\t\tret = 1;\n\t\tgoto updt_exit;\n\t}\n\n\tfor (ev = 0; ev < pl330->pcfg.num_events; ev++) {\n\t\tif (val & (1 << ev)) {  \n\t\t\tstruct pl330_thread *thrd;\n\t\t\tu32 inten = readl(regs + INTEN);\n\t\t\tint active;\n\n\t\t\t \n\t\t\tif (inten & (1 << ev))\n\t\t\t\twritel(1 << ev, regs + INTCLR);\n\n\t\t\tret = 1;\n\n\t\t\tid = pl330->events[ev];\n\n\t\t\tthrd = &pl330->channels[id];\n\n\t\t\tactive = thrd->req_running;\n\t\t\tif (active == -1)  \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdescdone = thrd->req[active].desc;\n\t\t\tthrd->req[active].desc = NULL;\n\n\t\t\tthrd->req_running = -1;\n\n\t\t\t \n\t\t\tpl330_start_thread(thrd);\n\n\t\t\t \n\t\t\tlist_add_tail(&descdone->rqd, &pl330->req_done);\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&pl330->req_done)) {\n\t\tdescdone = list_first_entry(&pl330->req_done,\n\t\t\t\t\t    struct dma_pl330_desc, rqd);\n\t\tlist_del(&descdone->rqd);\n\t\tspin_unlock_irqrestore(&pl330->lock, flags);\n\t\tdma_pl330_rqcb(descdone, PL330_ERR_NONE);\n\t\tspin_lock_irqsave(&pl330->lock, flags);\n\t}\n\nupdt_exit:\n\tspin_unlock_irqrestore(&pl330->lock, flags);\n\n\tif (pl330->dmac_tbd.reset_dmac\n\t\t\t|| pl330->dmac_tbd.reset_mngr\n\t\t\t|| pl330->dmac_tbd.reset_chan) {\n\t\tret = 1;\n\t\ttasklet_schedule(&pl330->tasks);\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline int _alloc_event(struct pl330_thread *thrd)\n{\n\tstruct pl330_dmac *pl330 = thrd->dmac;\n\tint ev;\n\n\tfor (ev = 0; ev < pl330->pcfg.num_events; ev++)\n\t\tif (pl330->events[ev] == -1) {\n\t\t\tpl330->events[ev] = thrd->id;\n\t\t\treturn ev;\n\t\t}\n\n\treturn -1;\n}\n\nstatic bool _chan_ns(const struct pl330_dmac *pl330, int i)\n{\n\treturn pl330->pcfg.irq_ns & (1 << i);\n}\n\n \nstatic struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330)\n{\n\tstruct pl330_thread *thrd = NULL;\n\tint chans, i;\n\n\tif (pl330->state == DYING)\n\t\treturn NULL;\n\n\tchans = pl330->pcfg.num_chan;\n\n\tfor (i = 0; i < chans; i++) {\n\t\tthrd = &pl330->channels[i];\n\t\tif ((thrd->free) && (!_manager_ns(thrd) ||\n\t\t\t\t\t_chan_ns(pl330, i))) {\n\t\t\tthrd->ev = _alloc_event(thrd);\n\t\t\tif (thrd->ev >= 0) {\n\t\t\t\tthrd->free = false;\n\t\t\t\tthrd->lstenq = 1;\n\t\t\t\tthrd->req[0].desc = NULL;\n\t\t\t\tthrd->req[1].desc = NULL;\n\t\t\t\tthrd->req_running = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthrd = NULL;\n\t}\n\n\treturn thrd;\n}\n\n \nstatic inline void _free_event(struct pl330_thread *thrd, int ev)\n{\n\tstruct pl330_dmac *pl330 = thrd->dmac;\n\n\t \n\tif (ev >= 0 && ev < pl330->pcfg.num_events\n\t\t\t&& pl330->events[ev] == thrd->id)\n\t\tpl330->events[ev] = -1;\n}\n\nstatic void pl330_release_channel(struct pl330_thread *thrd)\n{\n\tif (!thrd || thrd->free)\n\t\treturn;\n\n\t_stop(thrd);\n\n\tdma_pl330_rqcb(thrd->req[1 - thrd->lstenq].desc, PL330_ERR_ABORT);\n\tdma_pl330_rqcb(thrd->req[thrd->lstenq].desc, PL330_ERR_ABORT);\n\n\t_free_event(thrd, thrd->ev);\n\tthrd->free = true;\n}\n\n \nstatic void read_dmac_config(struct pl330_dmac *pl330)\n{\n\tvoid __iomem *regs = pl330->base;\n\tu32 val;\n\n\tval = readl(regs + CRD) >> CRD_DATA_WIDTH_SHIFT;\n\tval &= CRD_DATA_WIDTH_MASK;\n\tpl330->pcfg.data_bus_width = 8 * (1 << val);\n\n\tval = readl(regs + CRD) >> CRD_DATA_BUFF_SHIFT;\n\tval &= CRD_DATA_BUFF_MASK;\n\tpl330->pcfg.data_buf_dep = val + 1;\n\n\tval = readl(regs + CR0) >> CR0_NUM_CHANS_SHIFT;\n\tval &= CR0_NUM_CHANS_MASK;\n\tval += 1;\n\tpl330->pcfg.num_chan = val;\n\n\tval = readl(regs + CR0);\n\tif (val & CR0_PERIPH_REQ_SET) {\n\t\tval = (val >> CR0_NUM_PERIPH_SHIFT) & CR0_NUM_PERIPH_MASK;\n\t\tval += 1;\n\t\tpl330->pcfg.num_peri = val;\n\t\tpl330->pcfg.peri_ns = readl(regs + CR4);\n\t} else {\n\t\tpl330->pcfg.num_peri = 0;\n\t}\n\n\tval = readl(regs + CR0);\n\tif (val & CR0_BOOT_MAN_NS)\n\t\tpl330->pcfg.mode |= DMAC_MODE_NS;\n\telse\n\t\tpl330->pcfg.mode &= ~DMAC_MODE_NS;\n\n\tval = readl(regs + CR0) >> CR0_NUM_EVENTS_SHIFT;\n\tval &= CR0_NUM_EVENTS_MASK;\n\tval += 1;\n\tpl330->pcfg.num_events = val;\n\n\tpl330->pcfg.irq_ns = readl(regs + CR3);\n}\n\nstatic inline void _reset_thread(struct pl330_thread *thrd)\n{\n\tstruct pl330_dmac *pl330 = thrd->dmac;\n\n\tthrd->req[0].mc_cpu = pl330->mcode_cpu\n\t\t\t\t+ (thrd->id * pl330->mcbufsz);\n\tthrd->req[0].mc_bus = pl330->mcode_bus\n\t\t\t\t+ (thrd->id * pl330->mcbufsz);\n\tthrd->req[0].desc = NULL;\n\n\tthrd->req[1].mc_cpu = thrd->req[0].mc_cpu\n\t\t\t\t+ pl330->mcbufsz / 2;\n\tthrd->req[1].mc_bus = thrd->req[0].mc_bus\n\t\t\t\t+ pl330->mcbufsz / 2;\n\tthrd->req[1].desc = NULL;\n\n\tthrd->req_running = -1;\n}\n\nstatic int dmac_alloc_threads(struct pl330_dmac *pl330)\n{\n\tint chans = pl330->pcfg.num_chan;\n\tstruct pl330_thread *thrd;\n\tint i;\n\n\t \n\tpl330->channels = kcalloc(1 + chans, sizeof(*thrd),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pl330->channels)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < chans; i++) {\n\t\tthrd = &pl330->channels[i];\n\t\tthrd->id = i;\n\t\tthrd->dmac = pl330;\n\t\t_reset_thread(thrd);\n\t\tthrd->free = true;\n\t}\n\n\t \n\tthrd = &pl330->channels[chans];\n\tthrd->id = chans;\n\tthrd->dmac = pl330;\n\tthrd->free = false;\n\tpl330->manager = thrd;\n\n\treturn 0;\n}\n\nstatic int dmac_alloc_resources(struct pl330_dmac *pl330)\n{\n\tint chans = pl330->pcfg.num_chan;\n\tint ret;\n\n\t \n\tpl330->mcode_cpu = dma_alloc_attrs(pl330->ddma.dev,\n\t\t\t\tchans * pl330->mcbufsz,\n\t\t\t\t&pl330->mcode_bus, GFP_KERNEL,\n\t\t\t\tDMA_ATTR_PRIVILEGED);\n\tif (!pl330->mcode_cpu) {\n\t\tdev_err(pl330->ddma.dev, \"%s:%d Can't allocate memory!\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = dmac_alloc_threads(pl330);\n\tif (ret) {\n\t\tdev_err(pl330->ddma.dev, \"%s:%d Can't to create channels for DMAC!\\n\",\n\t\t\t__func__, __LINE__);\n\t\tdma_free_attrs(pl330->ddma.dev,\n\t\t\t\tchans * pl330->mcbufsz,\n\t\t\t\tpl330->mcode_cpu, pl330->mcode_bus,\n\t\t\t\tDMA_ATTR_PRIVILEGED);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl330_add(struct pl330_dmac *pl330)\n{\n\tint i, ret;\n\n\t \n\tif ((pl330->pcfg.periph_id & 0xfffff) != PERIPH_ID_VAL) {\n\t\tdev_err(pl330->ddma.dev, \"PERIPH_ID 0x%x !\\n\",\n\t\t\tpl330->pcfg.periph_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tread_dmac_config(pl330);\n\n\tif (pl330->pcfg.num_events == 0) {\n\t\tdev_err(pl330->ddma.dev, \"%s:%d Can't work without events!\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_init(&pl330->lock);\n\n\tINIT_LIST_HEAD(&pl330->req_done);\n\n\t \n\tif (!pl330->mcbufsz)\n\t\tpl330->mcbufsz = MCODE_BUFF_PER_REQ * 2;\n\n\t \n\tfor (i = 0; i < pl330->pcfg.num_events; i++)\n\t\tpl330->events[i] = -1;\n\n\t \n\tret = dmac_alloc_resources(pl330);\n\tif (ret) {\n\t\tdev_err(pl330->ddma.dev, \"Unable to create channels for DMAC\\n\");\n\t\treturn ret;\n\t}\n\n\ttasklet_setup(&pl330->tasks, pl330_dotask);\n\n\tpl330->state = INIT;\n\n\treturn 0;\n}\n\nstatic int dmac_free_threads(struct pl330_dmac *pl330)\n{\n\tstruct pl330_thread *thrd;\n\tint i;\n\n\t \n\tfor (i = 0; i < pl330->pcfg.num_chan; i++) {\n\t\tthrd = &pl330->channels[i];\n\t\tpl330_release_channel(thrd);\n\t}\n\n\t \n\tkfree(pl330->channels);\n\n\treturn 0;\n}\n\nstatic void pl330_del(struct pl330_dmac *pl330)\n{\n\tpl330->state = UNINIT;\n\n\ttasklet_kill(&pl330->tasks);\n\n\t \n\tdmac_free_threads(pl330);\n\n\tdma_free_attrs(pl330->ddma.dev,\n\t\tpl330->pcfg.num_chan * pl330->mcbufsz, pl330->mcode_cpu,\n\t\tpl330->mcode_bus, DMA_ATTR_PRIVILEGED);\n}\n\n \nstatic struct amba_driver pl330_driver;\n\nstatic inline struct dma_pl330_chan *\nto_pchan(struct dma_chan *ch)\n{\n\tif (!ch)\n\t\treturn NULL;\n\n\treturn container_of(ch, struct dma_pl330_chan, chan);\n}\n\nstatic inline struct dma_pl330_desc *\nto_desc(struct dma_async_tx_descriptor *tx)\n{\n\treturn container_of(tx, struct dma_pl330_desc, txd);\n}\n\nstatic inline void fill_queue(struct dma_pl330_chan *pch)\n{\n\tstruct dma_pl330_desc *desc;\n\tint ret;\n\n\tlist_for_each_entry(desc, &pch->work_list, node) {\n\n\t\t \n\t\tif (desc->status == BUSY || desc->status == PAUSED)\n\t\t\tcontinue;\n\n\t\tret = pl330_submit_req(pch->thread, desc);\n\t\tif (!ret) {\n\t\t\tdesc->status = BUSY;\n\t\t} else if (ret == -EAGAIN) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tdesc->status = DONE;\n\t\t\tdev_err(pch->dmac->ddma.dev, \"%s:%d Bad Desc(%d)\\n\",\n\t\t\t\t\t__func__, __LINE__, desc->txd.cookie);\n\t\t\ttasklet_schedule(&pch->task);\n\t\t}\n\t}\n}\n\nstatic void pl330_tasklet(struct tasklet_struct *t)\n{\n\tstruct dma_pl330_chan *pch = from_tasklet(pch, t, task);\n\tstruct dma_pl330_desc *desc, *_dt;\n\tunsigned long flags;\n\tbool power_down = false;\n\n\tspin_lock_irqsave(&pch->lock, flags);\n\n\t \n\tlist_for_each_entry_safe(desc, _dt, &pch->work_list, node)\n\t\tif (desc->status == DONE) {\n\t\t\tif (!pch->cyclic)\n\t\t\t\tdma_cookie_complete(&desc->txd);\n\t\t\tlist_move_tail(&desc->node, &pch->completed_list);\n\t\t}\n\n\t \n\tfill_queue(pch);\n\n\tif (list_empty(&pch->work_list)) {\n\t\tspin_lock(&pch->thread->dmac->lock);\n\t\t_stop(pch->thread);\n\t\tspin_unlock(&pch->thread->dmac->lock);\n\t\tpower_down = true;\n\t\tpch->active = false;\n\t} else {\n\t\t \n\t\tspin_lock(&pch->thread->dmac->lock);\n\t\tpl330_start_thread(pch->thread);\n\t\tspin_unlock(&pch->thread->dmac->lock);\n\t}\n\n\twhile (!list_empty(&pch->completed_list)) {\n\t\tstruct dmaengine_desc_callback cb;\n\n\t\tdesc = list_first_entry(&pch->completed_list,\n\t\t\t\t\tstruct dma_pl330_desc, node);\n\n\t\tdmaengine_desc_get_callback(&desc->txd, &cb);\n\n\t\tif (pch->cyclic) {\n\t\t\tdesc->status = PREP;\n\t\t\tlist_move_tail(&desc->node, &pch->work_list);\n\t\t\tif (power_down) {\n\t\t\t\tpch->active = true;\n\t\t\t\tspin_lock(&pch->thread->dmac->lock);\n\t\t\t\tpl330_start_thread(pch->thread);\n\t\t\t\tspin_unlock(&pch->thread->dmac->lock);\n\t\t\t\tpower_down = false;\n\t\t\t}\n\t\t} else {\n\t\t\tdesc->status = FREE;\n\t\t\tlist_move_tail(&desc->node, &pch->dmac->desc_pool);\n\t\t}\n\n\t\tdma_descriptor_unmap(&desc->txd);\n\n\t\tif (dmaengine_desc_callback_valid(&cb)) {\n\t\t\tspin_unlock_irqrestore(&pch->lock, flags);\n\t\t\tdmaengine_desc_callback_invoke(&cb, NULL);\n\t\t\tspin_lock_irqsave(&pch->lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\n\t \n\tif (power_down) {\n\t\tpm_runtime_mark_last_busy(pch->dmac->ddma.dev);\n\t\tpm_runtime_put_autosuspend(pch->dmac->ddma.dev);\n\t}\n}\n\nstatic struct dma_chan *of_dma_pl330_xlate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t\tstruct of_dma *ofdma)\n{\n\tint count = dma_spec->args_count;\n\tstruct pl330_dmac *pl330 = ofdma->of_dma_data;\n\tunsigned int chan_id;\n\n\tif (!pl330)\n\t\treturn NULL;\n\n\tif (count != 1)\n\t\treturn NULL;\n\n\tchan_id = dma_spec->args[0];\n\tif (chan_id >= pl330->num_peripherals)\n\t\treturn NULL;\n\n\treturn dma_get_slave_channel(&pl330->peripherals[chan_id].chan);\n}\n\nstatic int pl330_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pl330->lock, flags);\n\n\tdma_cookie_init(chan);\n\tpch->cyclic = false;\n\n\tpch->thread = pl330_request_channel(pl330);\n\tif (!pch->thread) {\n\t\tspin_unlock_irqrestore(&pl330->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\ttasklet_setup(&pch->task, pl330_tasklet);\n\n\tspin_unlock_irqrestore(&pl330->lock, flags);\n\n\treturn 1;\n}\n\n \nstatic enum dma_data_direction\npl330_dma_slave_map_dir(enum dma_transfer_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_MEM_TO_DEV:\n\t\treturn DMA_FROM_DEVICE;\n\tcase DMA_DEV_TO_MEM:\n\t\treturn DMA_TO_DEVICE;\n\tcase DMA_DEV_TO_DEV:\n\t\treturn DMA_BIDIRECTIONAL;\n\tdefault:\n\t\treturn DMA_NONE;\n\t}\n}\n\nstatic void pl330_unprep_slave_fifo(struct dma_pl330_chan *pch)\n{\n\tif (pch->dir != DMA_NONE)\n\t\tdma_unmap_resource(pch->chan.device->dev, pch->fifo_dma,\n\t\t\t\t   1 << pch->burst_sz, pch->dir, 0);\n\tpch->dir = DMA_NONE;\n}\n\n\nstatic bool pl330_prep_slave_fifo(struct dma_pl330_chan *pch,\n\t\t\t\t  enum dma_transfer_direction dir)\n{\n\tstruct device *dev = pch->chan.device->dev;\n\tenum dma_data_direction dma_dir = pl330_dma_slave_map_dir(dir);\n\n\t \n\tif (pch->dir == dma_dir)\n\t\treturn true;\n\n\tpl330_unprep_slave_fifo(pch);\n\tpch->fifo_dma = dma_map_resource(dev, pch->fifo_addr,\n\t\t\t\t\t 1 << pch->burst_sz, dma_dir, 0);\n\tif (dma_mapping_error(dev, pch->fifo_dma))\n\t\treturn false;\n\n\tpch->dir = dma_dir;\n\treturn true;\n}\n\nstatic int fixup_burst_len(int max_burst_len, int quirks)\n{\n\tif (max_burst_len > PL330_MAX_BURST)\n\t\treturn PL330_MAX_BURST;\n\telse if (max_burst_len < 1)\n\t\treturn 1;\n\telse\n\t\treturn max_burst_len;\n}\n\nstatic int pl330_config_write(struct dma_chan *chan,\n\t\t\tstruct dma_slave_config *slave_config,\n\t\t\tenum dma_transfer_direction direction)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\n\tpl330_unprep_slave_fifo(pch);\n\tif (direction == DMA_MEM_TO_DEV) {\n\t\tif (slave_config->dst_addr)\n\t\t\tpch->fifo_addr = slave_config->dst_addr;\n\t\tif (slave_config->dst_addr_width)\n\t\t\tpch->burst_sz = __ffs(slave_config->dst_addr_width);\n\t\tpch->burst_len = fixup_burst_len(slave_config->dst_maxburst,\n\t\t\tpch->dmac->quirks);\n\t} else if (direction == DMA_DEV_TO_MEM) {\n\t\tif (slave_config->src_addr)\n\t\t\tpch->fifo_addr = slave_config->src_addr;\n\t\tif (slave_config->src_addr_width)\n\t\t\tpch->burst_sz = __ffs(slave_config->src_addr_width);\n\t\tpch->burst_len = fixup_burst_len(slave_config->src_maxburst,\n\t\t\tpch->dmac->quirks);\n\t}\n\n\treturn 0;\n}\n\nstatic int pl330_config(struct dma_chan *chan,\n\t\t\tstruct dma_slave_config *slave_config)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\n\tmemcpy(&pch->slave_config, slave_config, sizeof(*slave_config));\n\n\treturn 0;\n}\n\nstatic int pl330_terminate_all(struct dma_chan *chan)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct dma_pl330_desc *desc;\n\tunsigned long flags;\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tbool power_down = false;\n\n\tpm_runtime_get_sync(pl330->ddma.dev);\n\tspin_lock_irqsave(&pch->lock, flags);\n\n\tspin_lock(&pl330->lock);\n\t_stop(pch->thread);\n\tpch->thread->req[0].desc = NULL;\n\tpch->thread->req[1].desc = NULL;\n\tpch->thread->req_running = -1;\n\tspin_unlock(&pl330->lock);\n\n\tpower_down = pch->active;\n\tpch->active = false;\n\n\t \n\tlist_for_each_entry(desc, &pch->submitted_list, node) {\n\t\tdesc->status = FREE;\n\t\tdma_cookie_complete(&desc->txd);\n\t}\n\n\tlist_for_each_entry(desc, &pch->work_list , node) {\n\t\tdesc->status = FREE;\n\t\tdma_cookie_complete(&desc->txd);\n\t}\n\n\tlist_splice_tail_init(&pch->submitted_list, &pl330->desc_pool);\n\tlist_splice_tail_init(&pch->work_list, &pl330->desc_pool);\n\tlist_splice_tail_init(&pch->completed_list, &pl330->desc_pool);\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\tpm_runtime_mark_last_busy(pl330->ddma.dev);\n\tif (power_down)\n\t\tpm_runtime_put_autosuspend(pl330->ddma.dev);\n\tpm_runtime_put_autosuspend(pl330->ddma.dev);\n\n\treturn 0;\n}\n\n \nstatic int pl330_pause(struct dma_chan *chan)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tstruct dma_pl330_desc *desc;\n\tunsigned long flags;\n\n\tpm_runtime_get_sync(pl330->ddma.dev);\n\tspin_lock_irqsave(&pch->lock, flags);\n\n\tspin_lock(&pl330->lock);\n\t_stop(pch->thread);\n\tspin_unlock(&pl330->lock);\n\n\tlist_for_each_entry(desc, &pch->work_list, node) {\n\t\tif (desc->status == BUSY)\n\t\t\tdesc->status = PAUSED;\n\t}\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\tpm_runtime_mark_last_busy(pl330->ddma.dev);\n\tpm_runtime_put_autosuspend(pl330->ddma.dev);\n\n\treturn 0;\n}\n\nstatic void pl330_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tunsigned long flags;\n\n\ttasklet_kill(&pch->task);\n\n\tpm_runtime_get_sync(pch->dmac->ddma.dev);\n\tspin_lock_irqsave(&pl330->lock, flags);\n\n\tpl330_release_channel(pch->thread);\n\tpch->thread = NULL;\n\n\tif (pch->cyclic)\n\t\tlist_splice_tail_init(&pch->work_list, &pch->dmac->desc_pool);\n\n\tspin_unlock_irqrestore(&pl330->lock, flags);\n\tpm_runtime_mark_last_busy(pch->dmac->ddma.dev);\n\tpm_runtime_put_autosuspend(pch->dmac->ddma.dev);\n\tpl330_unprep_slave_fifo(pch);\n}\n\nstatic int pl330_get_current_xferred_count(struct dma_pl330_chan *pch,\n\t\t\t\t\t   struct dma_pl330_desc *desc)\n{\n\tstruct pl330_thread *thrd = pch->thread;\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tvoid __iomem *regs = thrd->dmac->base;\n\tu32 val, addr;\n\n\tpm_runtime_get_sync(pl330->ddma.dev);\n\tval = addr = 0;\n\tif (desc->rqcfg.src_inc) {\n\t\tval = readl(regs + SA(thrd->id));\n\t\taddr = desc->px.src_addr;\n\t} else {\n\t\tval = readl(regs + DA(thrd->id));\n\t\taddr = desc->px.dst_addr;\n\t}\n\tpm_runtime_mark_last_busy(pch->dmac->ddma.dev);\n\tpm_runtime_put_autosuspend(pl330->ddma.dev);\n\n\t \n\tif (!val)\n\t\treturn 0;\n\n\treturn val - addr;\n}\n\nstatic enum dma_status\npl330_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\n\t\t struct dma_tx_state *txstate)\n{\n\tenum dma_status ret;\n\tunsigned long flags;\n\tstruct dma_pl330_desc *desc, *running = NULL, *last_enq = NULL;\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tunsigned int transferred, residual = 0;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\n\tif (!txstate)\n\t\treturn ret;\n\n\tif (ret == DMA_COMPLETE)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&pch->lock, flags);\n\tspin_lock(&pch->thread->dmac->lock);\n\n\tif (pch->thread->req_running != -1)\n\t\trunning = pch->thread->req[pch->thread->req_running].desc;\n\n\tlast_enq = pch->thread->req[pch->thread->lstenq].desc;\n\n\t \n\tlist_for_each_entry(desc, &pch->work_list, node) {\n\t\tif (desc->status == DONE)\n\t\t\ttransferred = desc->bytes_requested;\n\t\telse if (running && desc == running)\n\t\t\ttransferred =\n\t\t\t\tpl330_get_current_xferred_count(pch, desc);\n\t\telse if (desc->status == BUSY || desc->status == PAUSED)\n\t\t\t \n\t\t\tif (desc == last_enq)\n\t\t\t\ttransferred = 0;\n\t\t\telse\n\t\t\t\ttransferred = desc->bytes_requested;\n\t\telse\n\t\t\ttransferred = 0;\n\t\tresidual += desc->bytes_requested - transferred;\n\t\tif (desc->txd.cookie == cookie) {\n\t\t\tswitch (desc->status) {\n\t\t\tcase DONE:\n\t\t\t\tret = DMA_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase PAUSED:\n\t\t\t\tret = DMA_PAUSED;\n\t\t\t\tbreak;\n\t\t\tcase PREP:\n\t\t\tcase BUSY:\n\t\t\t\tret = DMA_IN_PROGRESS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (desc->last)\n\t\t\tresidual = 0;\n\t}\n\tspin_unlock(&pch->thread->dmac->lock);\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\nout:\n\tdma_set_residue(txstate, residual);\n\n\treturn ret;\n}\n\nstatic void pl330_issue_pending(struct dma_chan *chan)\n{\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pch->lock, flags);\n\tif (list_empty(&pch->work_list)) {\n\t\t \n\t\tWARN_ON(list_empty(&pch->submitted_list));\n\t\tpch->active = true;\n\t\tpm_runtime_get_sync(pch->dmac->ddma.dev);\n\t}\n\tlist_splice_tail_init(&pch->submitted_list, &pch->work_list);\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\n\tpl330_tasklet(&pch->task);\n}\n\n \nstatic dma_cookie_t pl330_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tstruct dma_pl330_desc *desc, *last = to_desc(tx);\n\tstruct dma_pl330_chan *pch = to_pchan(tx->chan);\n\tdma_cookie_t cookie;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pch->lock, flags);\n\n\t \n\twhile (!list_empty(&last->node)) {\n\t\tdesc = list_entry(last->node.next, struct dma_pl330_desc, node);\n\t\tif (pch->cyclic) {\n\t\t\tdesc->txd.callback = last->txd.callback;\n\t\t\tdesc->txd.callback_param = last->txd.callback_param;\n\t\t}\n\t\tdesc->last = false;\n\n\t\tdma_cookie_assign(&desc->txd);\n\n\t\tlist_move_tail(&desc->node, &pch->submitted_list);\n\t}\n\n\tlast->last = true;\n\tcookie = dma_cookie_assign(&last->txd);\n\tlist_add_tail(&last->node, &pch->submitted_list);\n\tspin_unlock_irqrestore(&pch->lock, flags);\n\n\treturn cookie;\n}\n\nstatic inline void _init_desc(struct dma_pl330_desc *desc)\n{\n\tdesc->rqcfg.swap = SWAP_NO;\n\tdesc->rqcfg.scctl = CCTRL0;\n\tdesc->rqcfg.dcctl = CCTRL0;\n\tdesc->txd.tx_submit = pl330_tx_submit;\n\n\tINIT_LIST_HEAD(&desc->node);\n}\n\n \nstatic int add_desc(struct list_head *pool, spinlock_t *lock,\n\t\t    gfp_t flg, int count)\n{\n\tstruct dma_pl330_desc *desc;\n\tunsigned long flags;\n\tint i;\n\n\tdesc = kcalloc(count, sizeof(*desc), flg);\n\tif (!desc)\n\t\treturn 0;\n\n\tspin_lock_irqsave(lock, flags);\n\n\tfor (i = 0; i < count; i++) {\n\t\t_init_desc(&desc[i]);\n\t\tlist_add_tail(&desc[i].node, pool);\n\t}\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn count;\n}\n\nstatic struct dma_pl330_desc *pluck_desc(struct list_head *pool,\n\t\t\t\t\t spinlock_t *lock)\n{\n\tstruct dma_pl330_desc *desc = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\n\tif (!list_empty(pool)) {\n\t\tdesc = list_entry(pool->next,\n\t\t\t\tstruct dma_pl330_desc, node);\n\n\t\tlist_del_init(&desc->node);\n\n\t\tdesc->status = PREP;\n\t\tdesc->txd.callback = NULL;\n\t}\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn desc;\n}\n\nstatic struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)\n{\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tu8 *peri_id = pch->chan.private;\n\tstruct dma_pl330_desc *desc;\n\n\t \n\tdesc = pluck_desc(&pl330->desc_pool, &pl330->pool_lock);\n\n\t \n\tif (!desc) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tLIST_HEAD(pool);\n\n\t\tif (!add_desc(&pool, &lock, GFP_ATOMIC, 1))\n\t\t\treturn NULL;\n\n\t\tdesc = pluck_desc(&pool, &lock);\n\t\tWARN_ON(!desc || !list_empty(&pool));\n\t}\n\n\t \n\tdesc->pchan = pch;\n\tdesc->txd.cookie = 0;\n\tasync_tx_ack(&desc->txd);\n\n\tdesc->peri = peri_id ? pch->chan.chan_id : 0;\n\tdesc->rqcfg.pcfg = &pch->dmac->pcfg;\n\n\tdma_async_tx_descriptor_init(&desc->txd, &pch->chan);\n\n\treturn desc;\n}\n\nstatic inline void fill_px(struct pl330_xfer *px,\n\t\tdma_addr_t dst, dma_addr_t src, size_t len)\n{\n\tpx->bytes = len;\n\tpx->dst_addr = dst;\n\tpx->src_addr = src;\n}\n\nstatic struct dma_pl330_desc *\n__pl330_prep_dma_memcpy(struct dma_pl330_chan *pch, dma_addr_t dst,\n\t\tdma_addr_t src, size_t len)\n{\n\tstruct dma_pl330_desc *desc = pl330_get_desc(pch);\n\n\tif (!desc) {\n\t\tdev_err(pch->dmac->ddma.dev, \"%s:%d Unable to fetch desc\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn NULL;\n\t}\n\n\t \n\tfill_px(&desc->px, dst, src, len);\n\n\treturn desc;\n}\n\n \nstatic inline int get_burst_len(struct dma_pl330_desc *desc, size_t len)\n{\n\tstruct dma_pl330_chan *pch = desc->pchan;\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tint burst_len;\n\n\tburst_len = pl330->pcfg.data_bus_width / 8;\n\tburst_len *= pl330->pcfg.data_buf_dep / pl330->pcfg.num_chan;\n\tburst_len >>= desc->rqcfg.brst_size;\n\n\t \n\tif (burst_len > PL330_MAX_BURST)\n\t\tburst_len = PL330_MAX_BURST;\n\n\treturn burst_len;\n}\n\nstatic struct dma_async_tx_descriptor *pl330_prep_dma_cyclic(\n\t\tstruct dma_chan *chan, dma_addr_t dma_addr, size_t len,\n\t\tsize_t period_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags)\n{\n\tstruct dma_pl330_desc *desc = NULL, *first = NULL;\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tunsigned int i;\n\tdma_addr_t dst;\n\tdma_addr_t src;\n\n\tif (len % period_len != 0)\n\t\treturn NULL;\n\n\tif (!is_slave_direction(direction)) {\n\t\tdev_err(pch->dmac->ddma.dev, \"%s:%d Invalid dma direction\\n\",\n\t\t__func__, __LINE__);\n\t\treturn NULL;\n\t}\n\n\tpl330_config_write(chan, &pch->slave_config, direction);\n\n\tif (!pl330_prep_slave_fifo(pch, direction))\n\t\treturn NULL;\n\n\tfor (i = 0; i < len / period_len; i++) {\n\t\tdesc = pl330_get_desc(pch);\n\t\tif (!desc) {\n\t\t\tunsigned long iflags;\n\n\t\t\tdev_err(pch->dmac->ddma.dev, \"%s:%d Unable to fetch desc\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t\tif (!first)\n\t\t\t\treturn NULL;\n\n\t\t\tspin_lock_irqsave(&pl330->pool_lock, iflags);\n\n\t\t\twhile (!list_empty(&first->node)) {\n\t\t\t\tdesc = list_entry(first->node.next,\n\t\t\t\t\t\tstruct dma_pl330_desc, node);\n\t\t\t\tlist_move_tail(&desc->node, &pl330->desc_pool);\n\t\t\t}\n\n\t\t\tlist_move_tail(&first->node, &pl330->desc_pool);\n\n\t\t\tspin_unlock_irqrestore(&pl330->pool_lock, iflags);\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (direction) {\n\t\tcase DMA_MEM_TO_DEV:\n\t\t\tdesc->rqcfg.src_inc = 1;\n\t\t\tdesc->rqcfg.dst_inc = 0;\n\t\t\tsrc = dma_addr;\n\t\t\tdst = pch->fifo_dma;\n\t\t\tbreak;\n\t\tcase DMA_DEV_TO_MEM:\n\t\t\tdesc->rqcfg.src_inc = 0;\n\t\t\tdesc->rqcfg.dst_inc = 1;\n\t\t\tsrc = pch->fifo_dma;\n\t\t\tdst = dma_addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc->rqtype = direction;\n\t\tdesc->rqcfg.brst_size = pch->burst_sz;\n\t\tdesc->rqcfg.brst_len = pch->burst_len;\n\t\tdesc->bytes_requested = period_len;\n\t\tfill_px(&desc->px, dst, src, period_len);\n\n\t\tif (!first)\n\t\t\tfirst = desc;\n\t\telse\n\t\t\tlist_add_tail(&desc->node, &first->node);\n\n\t\tdma_addr += period_len;\n\t}\n\n\tif (!desc)\n\t\treturn NULL;\n\n\tpch->cyclic = true;\n\n\treturn &desc->txd;\n}\n\nstatic struct dma_async_tx_descriptor *\npl330_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst,\n\t\tdma_addr_t src, size_t len, unsigned long flags)\n{\n\tstruct dma_pl330_desc *desc;\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct pl330_dmac *pl330;\n\tint burst;\n\n\tif (unlikely(!pch || !len))\n\t\treturn NULL;\n\n\tpl330 = pch->dmac;\n\n\tdesc = __pl330_prep_dma_memcpy(pch, dst, src, len);\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->rqcfg.src_inc = 1;\n\tdesc->rqcfg.dst_inc = 1;\n\tdesc->rqtype = DMA_MEM_TO_MEM;\n\n\t \n\tburst = pl330->pcfg.data_bus_width / 8;\n\n\t \n\twhile ((src | dst | len) & (burst - 1))\n\t\tburst /= 2;\n\n\tdesc->rqcfg.brst_size = 0;\n\twhile (burst != (1 << desc->rqcfg.brst_size))\n\t\tdesc->rqcfg.brst_size++;\n\n\tdesc->rqcfg.brst_len = get_burst_len(desc, len);\n\t \n\tif (burst * 8 < pl330->pcfg.data_bus_width)\n\t\tdesc->rqcfg.brst_len = 1;\n\n\tdesc->bytes_requested = len;\n\n\treturn &desc->txd;\n}\n\nstatic void __pl330_giveback_desc(struct pl330_dmac *pl330,\n\t\t\t\t  struct dma_pl330_desc *first)\n{\n\tunsigned long flags;\n\tstruct dma_pl330_desc *desc;\n\n\tif (!first)\n\t\treturn;\n\n\tspin_lock_irqsave(&pl330->pool_lock, flags);\n\n\twhile (!list_empty(&first->node)) {\n\t\tdesc = list_entry(first->node.next,\n\t\t\t\tstruct dma_pl330_desc, node);\n\t\tlist_move_tail(&desc->node, &pl330->desc_pool);\n\t}\n\n\tlist_move_tail(&first->node, &pl330->desc_pool);\n\n\tspin_unlock_irqrestore(&pl330->pool_lock, flags);\n}\n\nstatic struct dma_async_tx_descriptor *\npl330_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flg, void *context)\n{\n\tstruct dma_pl330_desc *first, *desc = NULL;\n\tstruct dma_pl330_chan *pch = to_pchan(chan);\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (unlikely(!pch || !sgl || !sg_len))\n\t\treturn NULL;\n\n\tpl330_config_write(chan, &pch->slave_config, direction);\n\n\tif (!pl330_prep_slave_fifo(pch, direction))\n\t\treturn NULL;\n\n\tfirst = NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\n\t\tdesc = pl330_get_desc(pch);\n\t\tif (!desc) {\n\t\t\tstruct pl330_dmac *pl330 = pch->dmac;\n\n\t\t\tdev_err(pch->dmac->ddma.dev,\n\t\t\t\t\"%s:%d Unable to fetch desc\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\t__pl330_giveback_desc(pl330, first);\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!first)\n\t\t\tfirst = desc;\n\t\telse\n\t\t\tlist_add_tail(&desc->node, &first->node);\n\n\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\tdesc->rqcfg.src_inc = 1;\n\t\t\tdesc->rqcfg.dst_inc = 0;\n\t\t\tfill_px(&desc->px, pch->fifo_dma, sg_dma_address(sg),\n\t\t\t\tsg_dma_len(sg));\n\t\t} else {\n\t\t\tdesc->rqcfg.src_inc = 0;\n\t\t\tdesc->rqcfg.dst_inc = 1;\n\t\t\tfill_px(&desc->px, sg_dma_address(sg), pch->fifo_dma,\n\t\t\t\tsg_dma_len(sg));\n\t\t}\n\n\t\tdesc->rqcfg.brst_size = pch->burst_sz;\n\t\tdesc->rqcfg.brst_len = pch->burst_len;\n\t\tdesc->rqtype = direction;\n\t\tdesc->bytes_requested = sg_dma_len(sg);\n\t}\n\n\t \n\treturn &desc->txd;\n}\n\nstatic irqreturn_t pl330_irq_handler(int irq, void *data)\n{\n\tif (pl330_update(data))\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\n#define PL330_DMA_BUSWIDTHS \\\n\tBIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \\\n\tBIT(DMA_SLAVE_BUSWIDTH_8_BYTES)\n\n#ifdef CONFIG_DEBUG_FS\nstatic int pl330_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct pl330_dmac *pl330 = s->private;\n\tint chans, pchs, ch, pr;\n\n\tchans = pl330->pcfg.num_chan;\n\tpchs = pl330->num_peripherals;\n\n\tseq_puts(s, \"PL330 physical channels:\\n\");\n\tseq_puts(s, \"THREAD:\\t\\tCHANNEL:\\n\");\n\tseq_puts(s, \"--------\\t-----\\n\");\n\tfor (ch = 0; ch < chans; ch++) {\n\t\tstruct pl330_thread *thrd = &pl330->channels[ch];\n\t\tint found = -1;\n\n\t\tfor (pr = 0; pr < pchs; pr++) {\n\t\t\tstruct dma_pl330_chan *pch = &pl330->peripherals[pr];\n\n\t\t\tif (!pch->thread || thrd->id != pch->thread->id)\n\t\t\t\tcontinue;\n\n\t\t\tfound = pr;\n\t\t}\n\n\t\tseq_printf(s, \"%d\\t\\t\", thrd->id);\n\t\tif (found == -1)\n\t\t\tseq_puts(s, \"--\\n\");\n\t\telse\n\t\t\tseq_printf(s, \"%d\\n\", found);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pl330_debugfs);\n\nstatic inline void init_pl330_debugfs(struct pl330_dmac *pl330)\n{\n\tdebugfs_create_file(dev_name(pl330->ddma.dev),\n\t\t\t    S_IFREG | 0444, NULL, pl330,\n\t\t\t    &pl330_debugfs_fops);\n}\n#else\nstatic inline void init_pl330_debugfs(struct pl330_dmac *pl330)\n{\n}\n#endif\n\n \nstatic int __maybe_unused pl330_suspend(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\n\tpm_runtime_force_suspend(dev);\n\tclk_unprepare(pcdev->pclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pl330_resume(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tint ret;\n\n\tret = clk_prepare(pcdev->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_force_resume(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops pl330_pm = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pl330_suspend, pl330_resume)\n};\n\nstatic int\npl330_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct pl330_config *pcfg;\n\tstruct pl330_dmac *pl330;\n\tstruct dma_pl330_chan *pch, *_p;\n\tstruct dma_device *pd;\n\tstruct resource *res;\n\tint i, ret, irq;\n\tint num_chan;\n\tstruct device_node *np = adev->dev.of_node;\n\n\tret = dma_set_mask_and_coherent(&adev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpl330 = devm_kzalloc(&adev->dev, sizeof(*pl330), GFP_KERNEL);\n\tif (!pl330)\n\t\treturn -ENOMEM;\n\n\tpd = &pl330->ddma;\n\tpd->dev = &adev->dev;\n\n\tpl330->mcbufsz = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(of_quirks); i++)\n\t\tif (of_property_read_bool(np, of_quirks[i].quirk))\n\t\t\tpl330->quirks |= of_quirks[i].id;\n\n\tres = &adev->res;\n\tpl330->base = devm_ioremap_resource(&adev->dev, res);\n\tif (IS_ERR(pl330->base))\n\t\treturn PTR_ERR(pl330->base);\n\n\tamba_set_drvdata(adev, pl330);\n\n\tpl330->rstc = devm_reset_control_get_optional(&adev->dev, \"dma\");\n\tif (IS_ERR(pl330->rstc)) {\n\t\treturn dev_err_probe(&adev->dev, PTR_ERR(pl330->rstc), \"Failed to get reset!\\n\");\n\t} else {\n\t\tret = reset_control_deassert(pl330->rstc);\n\t\tif (ret) {\n\t\t\tdev_err(&adev->dev, \"Couldn't deassert the device from reset!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpl330->rstc_ocp = devm_reset_control_get_optional(&adev->dev, \"dma-ocp\");\n\tif (IS_ERR(pl330->rstc_ocp)) {\n\t\treturn dev_err_probe(&adev->dev, PTR_ERR(pl330->rstc_ocp),\n\t\t\t\t     \"Failed to get OCP reset!\\n\");\n\t} else {\n\t\tret = reset_control_deassert(pl330->rstc_ocp);\n\t\tif (ret) {\n\t\t\tdev_err(&adev->dev, \"Couldn't deassert the device from OCP reset!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AMBA_NR_IRQS; i++) {\n\t\tirq = adev->irq[i];\n\t\tif (irq) {\n\t\t\tret = devm_request_irq(&adev->dev, irq,\n\t\t\t\t\t       pl330_irq_handler, 0,\n\t\t\t\t\t       dev_name(&adev->dev), pl330);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcfg = &pl330->pcfg;\n\n\tpcfg->periph_id = adev->periphid;\n\tret = pl330_add(pl330);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&pl330->desc_pool);\n\tspin_lock_init(&pl330->pool_lock);\n\n\t \n\tif (!add_desc(&pl330->desc_pool, &pl330->pool_lock,\n\t\t      GFP_KERNEL, NR_DEFAULT_DESC))\n\t\tdev_warn(&adev->dev, \"unable to allocate desc\\n\");\n\n\tINIT_LIST_HEAD(&pd->channels);\n\n\t \n\tnum_chan = max_t(int, pcfg->num_peri, pcfg->num_chan);\n\n\tpl330->num_peripherals = num_chan;\n\n\tpl330->peripherals = kcalloc(num_chan, sizeof(*pch), GFP_KERNEL);\n\tif (!pl330->peripherals) {\n\t\tret = -ENOMEM;\n\t\tgoto probe_err2;\n\t}\n\n\tfor (i = 0; i < num_chan; i++) {\n\t\tpch = &pl330->peripherals[i];\n\n\t\tpch->chan.private = adev->dev.of_node;\n\t\tINIT_LIST_HEAD(&pch->submitted_list);\n\t\tINIT_LIST_HEAD(&pch->work_list);\n\t\tINIT_LIST_HEAD(&pch->completed_list);\n\t\tspin_lock_init(&pch->lock);\n\t\tpch->thread = NULL;\n\t\tpch->chan.device = pd;\n\t\tpch->dmac = pl330;\n\t\tpch->dir = DMA_NONE;\n\n\t\t \n\t\tlist_add_tail(&pch->chan.device_node, &pd->channels);\n\t}\n\n\tdma_cap_set(DMA_MEMCPY, pd->cap_mask);\n\tif (pcfg->num_peri) {\n\t\tdma_cap_set(DMA_SLAVE, pd->cap_mask);\n\t\tdma_cap_set(DMA_CYCLIC, pd->cap_mask);\n\t\tdma_cap_set(DMA_PRIVATE, pd->cap_mask);\n\t}\n\n\tpd->device_alloc_chan_resources = pl330_alloc_chan_resources;\n\tpd->device_free_chan_resources = pl330_free_chan_resources;\n\tpd->device_prep_dma_memcpy = pl330_prep_dma_memcpy;\n\tpd->device_prep_dma_cyclic = pl330_prep_dma_cyclic;\n\tpd->device_tx_status = pl330_tx_status;\n\tpd->device_prep_slave_sg = pl330_prep_slave_sg;\n\tpd->device_config = pl330_config;\n\tpd->device_pause = pl330_pause;\n\tpd->device_terminate_all = pl330_terminate_all;\n\tpd->device_issue_pending = pl330_issue_pending;\n\tpd->src_addr_widths = PL330_DMA_BUSWIDTHS;\n\tpd->dst_addr_widths = PL330_DMA_BUSWIDTHS;\n\tpd->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tpd->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tpd->max_burst = PL330_MAX_BURST;\n\n\tret = dma_async_device_register(pd);\n\tif (ret) {\n\t\tdev_err(&adev->dev, \"unable to register DMAC\\n\");\n\t\tgoto probe_err3;\n\t}\n\n\tif (adev->dev.of_node) {\n\t\tret = of_dma_controller_register(adev->dev.of_node,\n\t\t\t\t\t of_dma_pl330_xlate, pl330);\n\t\tif (ret) {\n\t\t\tdev_err(&adev->dev,\n\t\t\t\"unable to register DMA to the generic DT DMA helpers\\n\");\n\t\t}\n\t}\n\n\t \n\tret = dma_set_max_seg_size(&adev->dev, 1900800);\n\tif (ret)\n\t\tdev_err(&adev->dev, \"unable to set the seg size\\n\");\n\n\n\tinit_pl330_debugfs(pl330);\n\tdev_info(&adev->dev,\n\t\t\"Loaded driver for PL330 DMAC-%x\\n\", adev->periphid);\n\tdev_info(&adev->dev,\n\t\t\"\\tDBUFF-%ux%ubytes Num_Chans-%u Num_Peri-%u Num_Events-%u\\n\",\n\t\tpcfg->data_buf_dep, pcfg->data_bus_width / 8, pcfg->num_chan,\n\t\tpcfg->num_peri, pcfg->num_events);\n\n\tpm_runtime_irq_safe(&adev->dev);\n\tpm_runtime_use_autosuspend(&adev->dev);\n\tpm_runtime_set_autosuspend_delay(&adev->dev, PL330_AUTOSUSPEND_DELAY);\n\tpm_runtime_mark_last_busy(&adev->dev);\n\tpm_runtime_put_autosuspend(&adev->dev);\n\n\treturn 0;\nprobe_err3:\n\t \n\tlist_for_each_entry_safe(pch, _p, &pl330->ddma.channels,\n\t\t\tchan.device_node) {\n\n\t\t \n\t\tlist_del(&pch->chan.device_node);\n\n\t\t \n\t\tif (pch->thread) {\n\t\t\tpl330_terminate_all(&pch->chan);\n\t\t\tpl330_free_chan_resources(&pch->chan);\n\t\t}\n\t}\nprobe_err2:\n\tpl330_del(pl330);\n\n\tif (pl330->rstc_ocp)\n\t\treset_control_assert(pl330->rstc_ocp);\n\n\tif (pl330->rstc)\n\t\treset_control_assert(pl330->rstc);\n\treturn ret;\n}\n\nstatic void pl330_remove(struct amba_device *adev)\n{\n\tstruct pl330_dmac *pl330 = amba_get_drvdata(adev);\n\tstruct dma_pl330_chan *pch, *_p;\n\tint i, irq;\n\n\tpm_runtime_get_noresume(pl330->ddma.dev);\n\n\tif (adev->dev.of_node)\n\t\tof_dma_controller_free(adev->dev.of_node);\n\n\tfor (i = 0; i < AMBA_NR_IRQS; i++) {\n\t\tirq = adev->irq[i];\n\t\tif (irq)\n\t\t\tdevm_free_irq(&adev->dev, irq, pl330);\n\t}\n\n\tdma_async_device_unregister(&pl330->ddma);\n\n\t \n\tlist_for_each_entry_safe(pch, _p, &pl330->ddma.channels,\n\t\t\tchan.device_node) {\n\n\t\t \n\t\tlist_del(&pch->chan.device_node);\n\n\t\t \n\t\tif (pch->thread) {\n\t\t\tpl330_terminate_all(&pch->chan);\n\t\t\tpl330_free_chan_resources(&pch->chan);\n\t\t}\n\t}\n\n\tpl330_del(pl330);\n\n\tif (pl330->rstc_ocp)\n\t\treset_control_assert(pl330->rstc_ocp);\n\n\tif (pl330->rstc)\n\t\treset_control_assert(pl330->rstc);\n}\n\nstatic const struct amba_id pl330_ids[] = {\n\t{\n\t\t.id\t= 0x00041330,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl330_ids);\n\nstatic struct amba_driver pl330_driver = {\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"dma-pl330\",\n\t\t.pm = &pl330_pm,\n\t},\n\t.id_table = pl330_ids,\n\t.probe = pl330_probe,\n\t.remove = pl330_remove,\n};\n\nmodule_amba_driver(pl330_driver);\n\nMODULE_AUTHOR(\"Jaswinder Singh <jassisinghbrar@gmail.com>\");\nMODULE_DESCRIPTION(\"API Driver for PL330 DMAC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}