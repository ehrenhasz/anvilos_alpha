{
  "module_name": "uniphier-mdmac.c",
  "hash_id": "066059aca53400ab85bc92c2f7bce817163812bc50cf2737b5ec80af1ff66068",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/uniphier-mdmac.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"virt-dma.h\"\n\n \n#define UNIPHIER_MDMAC_CMD\t\t0x000\t \n#define   UNIPHIER_MDMAC_CMD_ABORT\t\tBIT(31)  \n\n \n#define UNIPHIER_MDMAC_CH_OFFSET\t0x100\n#define UNIPHIER_MDMAC_CH_STRIDE\t0x040\n\n#define UNIPHIER_MDMAC_CH_IRQ_STAT\t0x010\t \n#define UNIPHIER_MDMAC_CH_IRQ_REQ\t0x014\t \n#define UNIPHIER_MDMAC_CH_IRQ_EN\t0x018\t \n#define UNIPHIER_MDMAC_CH_IRQ_DET\t0x01c\t \n#define   UNIPHIER_MDMAC_CH_IRQ__ABORT\t\tBIT(13)\n#define   UNIPHIER_MDMAC_CH_IRQ__DONE\t\tBIT(1)\n#define UNIPHIER_MDMAC_CH_SRC_MODE\t0x020\t \n#define UNIPHIER_MDMAC_CH_DEST_MODE\t0x024\t \n#define   UNIPHIER_MDMAC_CH_MODE__ADDR_INC\t(0 << 4)\n#define   UNIPHIER_MDMAC_CH_MODE__ADDR_DEC\t(1 << 4)\n#define   UNIPHIER_MDMAC_CH_MODE__ADDR_FIXED\t(2 << 4)\n#define UNIPHIER_MDMAC_CH_SRC_ADDR\t0x028\t \n#define UNIPHIER_MDMAC_CH_DEST_ADDR\t0x02c\t \n#define UNIPHIER_MDMAC_CH_SIZE\t\t0x030\t \n\n#define UNIPHIER_MDMAC_SLAVE_BUSWIDTHS \\\n\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t BIT(DMA_SLAVE_BUSWIDTH_3_BYTES) | \\\n\t BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))\n\nstruct uniphier_mdmac_desc {\n\tstruct virt_dma_desc vd;\n\tstruct scatterlist *sgl;\n\tunsigned int sg_len;\n\tunsigned int sg_cur;\n\tenum dma_transfer_direction dir;\n};\n\nstruct uniphier_mdmac_chan {\n\tstruct virt_dma_chan vc;\n\tstruct uniphier_mdmac_device *mdev;\n\tstruct uniphier_mdmac_desc *md;\n\tvoid __iomem *reg_ch_base;\n\tunsigned int chan_id;\n};\n\nstruct uniphier_mdmac_device {\n\tstruct dma_device ddev;\n\tstruct clk *clk;\n\tvoid __iomem *reg_base;\n\tstruct uniphier_mdmac_chan channels[];\n};\n\nstatic struct uniphier_mdmac_chan *\nto_uniphier_mdmac_chan(struct virt_dma_chan *vc)\n{\n\treturn container_of(vc, struct uniphier_mdmac_chan, vc);\n}\n\nstatic struct uniphier_mdmac_desc *\nto_uniphier_mdmac_desc(struct virt_dma_desc *vd)\n{\n\treturn container_of(vd, struct uniphier_mdmac_desc, vd);\n}\n\n \nstatic struct uniphier_mdmac_desc *\nuniphier_mdmac_next_desc(struct uniphier_mdmac_chan *mc)\n{\n\tstruct virt_dma_desc *vd;\n\n\tvd = vchan_next_desc(&mc->vc);\n\tif (!vd) {\n\t\tmc->md = NULL;\n\t\treturn NULL;\n\t}\n\n\tlist_del(&vd->node);\n\n\tmc->md = to_uniphier_mdmac_desc(vd);\n\n\treturn mc->md;\n}\n\n \nstatic void uniphier_mdmac_handle(struct uniphier_mdmac_chan *mc,\n\t\t\t\t  struct uniphier_mdmac_desc *md)\n{\n\tstruct uniphier_mdmac_device *mdev = mc->mdev;\n\tstruct scatterlist *sg;\n\tu32 irq_flag = UNIPHIER_MDMAC_CH_IRQ__DONE;\n\tu32 src_mode, src_addr, dest_mode, dest_addr, chunk_size;\n\n\tsg = &md->sgl[md->sg_cur];\n\n\tif (md->dir == DMA_MEM_TO_DEV) {\n\t\tsrc_mode = UNIPHIER_MDMAC_CH_MODE__ADDR_INC;\n\t\tsrc_addr = sg_dma_address(sg);\n\t\tdest_mode = UNIPHIER_MDMAC_CH_MODE__ADDR_FIXED;\n\t\tdest_addr = 0;\n\t} else {\n\t\tsrc_mode = UNIPHIER_MDMAC_CH_MODE__ADDR_FIXED;\n\t\tsrc_addr = 0;\n\t\tdest_mode = UNIPHIER_MDMAC_CH_MODE__ADDR_INC;\n\t\tdest_addr = sg_dma_address(sg);\n\t}\n\n\tchunk_size = sg_dma_len(sg);\n\n\twritel(src_mode, mc->reg_ch_base + UNIPHIER_MDMAC_CH_SRC_MODE);\n\twritel(dest_mode, mc->reg_ch_base + UNIPHIER_MDMAC_CH_DEST_MODE);\n\twritel(src_addr, mc->reg_ch_base + UNIPHIER_MDMAC_CH_SRC_ADDR);\n\twritel(dest_addr, mc->reg_ch_base + UNIPHIER_MDMAC_CH_DEST_ADDR);\n\twritel(chunk_size, mc->reg_ch_base + UNIPHIER_MDMAC_CH_SIZE);\n\n\t \n\twritel(irq_flag, mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_REQ);\n\n\twritel(irq_flag, mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_EN);\n\n\twritel(BIT(mc->chan_id), mdev->reg_base + UNIPHIER_MDMAC_CMD);\n}\n\n \nstatic void uniphier_mdmac_start(struct uniphier_mdmac_chan *mc)\n{\n\tstruct uniphier_mdmac_desc *md;\n\n\tmd = uniphier_mdmac_next_desc(mc);\n\tif (md)\n\t\tuniphier_mdmac_handle(mc, md);\n}\n\n \nstatic int uniphier_mdmac_abort(struct uniphier_mdmac_chan *mc)\n{\n\tstruct uniphier_mdmac_device *mdev = mc->mdev;\n\tu32 irq_flag = UNIPHIER_MDMAC_CH_IRQ__ABORT;\n\tu32 val;\n\n\t \n\twritel(irq_flag, mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_REQ);\n\n\twritel(UNIPHIER_MDMAC_CMD_ABORT | BIT(mc->chan_id),\n\t       mdev->reg_base + UNIPHIER_MDMAC_CMD);\n\n\t \n\treturn readl_poll_timeout(mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_REQ,\n\t\t\t\t  val, val & irq_flag, 0, 20);\n}\n\nstatic irqreturn_t uniphier_mdmac_interrupt(int irq, void *dev_id)\n{\n\tstruct uniphier_mdmac_chan *mc = dev_id;\n\tstruct uniphier_mdmac_desc *md;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tu32 irq_stat;\n\n\tspin_lock(&mc->vc.lock);\n\n\tirq_stat = readl(mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_DET);\n\n\t \n\tif (!irq_stat) {\n\t\tret = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\t \n\twritel(irq_stat, mc->reg_ch_base + UNIPHIER_MDMAC_CH_IRQ_REQ);\n\n\t \n\tmd = mc->md;\n\tif (!md)\n\t\tgoto out;\n\n\tmd->sg_cur++;\n\n\tif (md->sg_cur >= md->sg_len) {\n\t\tvchan_cookie_complete(&md->vd);\n\t\tmd = uniphier_mdmac_next_desc(mc);\n\t\tif (!md)\n\t\t\tgoto out;\n\t}\n\n\tuniphier_mdmac_handle(mc, md);\n\nout:\n\tspin_unlock(&mc->vc.lock);\n\n\treturn ret;\n}\n\nstatic void uniphier_mdmac_free_chan_resources(struct dma_chan *chan)\n{\n\tvchan_free_chan_resources(to_virt_chan(chan));\n}\n\nstatic struct dma_async_tx_descriptor *\nuniphier_mdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\t\t     unsigned int sg_len,\n\t\t\t     enum dma_transfer_direction direction,\n\t\t\t     unsigned long flags, void *context)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct uniphier_mdmac_desc *md;\n\n\tif (!is_slave_direction(direction))\n\t\treturn NULL;\n\n\tmd = kzalloc(sizeof(*md), GFP_NOWAIT);\n\tif (!md)\n\t\treturn NULL;\n\n\tmd->sgl = sgl;\n\tmd->sg_len = sg_len;\n\tmd->dir = direction;\n\n\treturn vchan_tx_prep(vc, &md->vd, flags);\n}\n\nstatic int uniphier_mdmac_terminate_all(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct uniphier_mdmac_chan *mc = to_uniphier_mdmac_chan(vc);\n\tunsigned long flags;\n\tint ret = 0;\n\tLIST_HEAD(head);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tif (mc->md) {\n\t\tvchan_terminate_vdesc(&mc->md->vd);\n\t\tmc->md = NULL;\n\t\tret = uniphier_mdmac_abort(mc);\n\t}\n\tvchan_get_all_descriptors(vc, &head);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\tvchan_dma_desc_free_list(vc, &head);\n\n\treturn ret;\n}\n\nstatic void uniphier_mdmac_synchronize(struct dma_chan *chan)\n{\n\tvchan_synchronize(to_virt_chan(chan));\n}\n\nstatic enum dma_status uniphier_mdmac_tx_status(struct dma_chan *chan,\n\t\t\t\t\t\tdma_cookie_t cookie,\n\t\t\t\t\t\tstruct dma_tx_state *txstate)\n{\n\tstruct virt_dma_chan *vc;\n\tstruct virt_dma_desc *vd;\n\tstruct uniphier_mdmac_chan *mc;\n\tstruct uniphier_mdmac_desc *md = NULL;\n\tenum dma_status stat;\n\tunsigned long flags;\n\tint i;\n\n\tstat = dma_cookie_status(chan, cookie, txstate);\n\t \n\tif (stat == DMA_COMPLETE || !txstate)\n\t\treturn stat;\n\n\tvc = to_virt_chan(chan);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tmc = to_uniphier_mdmac_chan(vc);\n\n\tif (mc->md && mc->md->vd.tx.cookie == cookie) {\n\t\t \n\t\ttxstate->residue = readl(mc->reg_ch_base +\n\t\t\t\t\t UNIPHIER_MDMAC_CH_SIZE);\n\t\tmd = mc->md;\n\t}\n\n\tif (!md) {\n\t\tvd = vchan_find_desc(vc, cookie);\n\t\tif (vd)\n\t\t\tmd = to_uniphier_mdmac_desc(vd);\n\t}\n\n\tif (md) {\n\t\t \n\t\tfor (i = md->sg_cur; i < md->sg_len; i++)\n\t\t\ttxstate->residue += sg_dma_len(&md->sgl[i]);\n\t}\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\treturn stat;\n}\n\nstatic void uniphier_mdmac_issue_pending(struct dma_chan *chan)\n{\n\tstruct virt_dma_chan *vc = to_virt_chan(chan);\n\tstruct uniphier_mdmac_chan *mc = to_uniphier_mdmac_chan(vc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\n\tif (vchan_issue_pending(vc) && !mc->md)\n\t\tuniphier_mdmac_start(mc);\n\n\tspin_unlock_irqrestore(&vc->lock, flags);\n}\n\nstatic void uniphier_mdmac_desc_free(struct virt_dma_desc *vd)\n{\n\tkfree(to_uniphier_mdmac_desc(vd));\n}\n\nstatic int uniphier_mdmac_chan_init(struct platform_device *pdev,\n\t\t\t\t    struct uniphier_mdmac_device *mdev,\n\t\t\t\t    int chan_id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_mdmac_chan *mc = &mdev->channels[chan_id];\n\tchar *irq_name;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, chan_id);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_name = devm_kasprintf(dev, GFP_KERNEL, \"uniphier-mio-dmac-ch%d\",\n\t\t\t\t  chan_id);\n\tif (!irq_name)\n\t\treturn -ENOMEM;\n\n\tret = devm_request_irq(dev, irq, uniphier_mdmac_interrupt,\n\t\t\t       IRQF_SHARED, irq_name, mc);\n\tif (ret)\n\t\treturn ret;\n\n\tmc->mdev = mdev;\n\tmc->reg_ch_base = mdev->reg_base + UNIPHIER_MDMAC_CH_OFFSET +\n\t\t\t\t\tUNIPHIER_MDMAC_CH_STRIDE * chan_id;\n\tmc->chan_id = chan_id;\n\tmc->vc.desc_free = uniphier_mdmac_desc_free;\n\tvchan_init(&mc->vc, &mdev->ddev);\n\n\treturn 0;\n}\n\nstatic int uniphier_mdmac_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_mdmac_device *mdev;\n\tstruct dma_device *ddev;\n\tint nr_chans, ret, i;\n\n\tnr_chans = platform_irq_count(pdev);\n\tif (nr_chans < 0)\n\t\treturn nr_chans;\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tmdev = devm_kzalloc(dev, struct_size(mdev, channels, nr_chans),\n\t\t\t    GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->reg_base))\n\t\treturn PTR_ERR(mdev->reg_base);\n\n\tmdev->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(mdev->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(mdev->clk);\n\t}\n\n\tret = clk_prepare_enable(mdev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tddev = &mdev->ddev;\n\tddev->dev = dev;\n\tdma_cap_set(DMA_PRIVATE, ddev->cap_mask);\n\tddev->src_addr_widths = UNIPHIER_MDMAC_SLAVE_BUSWIDTHS;\n\tddev->dst_addr_widths = UNIPHIER_MDMAC_SLAVE_BUSWIDTHS;\n\tddev->directions = BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\n\tddev->residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;\n\tddev->device_free_chan_resources = uniphier_mdmac_free_chan_resources;\n\tddev->device_prep_slave_sg = uniphier_mdmac_prep_slave_sg;\n\tddev->device_terminate_all = uniphier_mdmac_terminate_all;\n\tddev->device_synchronize = uniphier_mdmac_synchronize;\n\tddev->device_tx_status = uniphier_mdmac_tx_status;\n\tddev->device_issue_pending = uniphier_mdmac_issue_pending;\n\tINIT_LIST_HEAD(&ddev->channels);\n\n\tfor (i = 0; i < nr_chans; i++) {\n\t\tret = uniphier_mdmac_chan_init(pdev, mdev, i);\n\t\tif (ret)\n\t\t\tgoto disable_clk;\n\t}\n\n\tret = dma_async_device_register(ddev);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = of_dma_controller_register(dev->of_node, of_dma_xlate_by_chan_id,\n\t\t\t\t\t ddev);\n\tif (ret)\n\t\tgoto unregister_dmac;\n\n\tplatform_set_drvdata(pdev, mdev);\n\n\treturn 0;\n\nunregister_dmac:\n\tdma_async_device_unregister(ddev);\ndisable_clk:\n\tclk_disable_unprepare(mdev->clk);\n\n\treturn ret;\n}\n\nstatic int uniphier_mdmac_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_mdmac_device *mdev = platform_get_drvdata(pdev);\n\tstruct dma_chan *chan;\n\tint ret;\n\n\t \n\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {\n\t\tret = dmaengine_terminate_sync(chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tuniphier_mdmac_free_chan_resources(chan);\n\t}\n\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&mdev->ddev);\n\tclk_disable_unprepare(mdev->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id uniphier_mdmac_match[] = {\n\t{ .compatible = \"socionext,uniphier-mio-dmac\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_mdmac_match);\n\nstatic struct platform_driver uniphier_mdmac_driver = {\n\t.probe = uniphier_mdmac_probe,\n\t.remove = uniphier_mdmac_remove,\n\t.driver = {\n\t\t.name = \"uniphier-mio-dmac\",\n\t\t.of_match_table = uniphier_mdmac_match,\n\t},\n};\nmodule_platform_driver(uniphier_mdmac_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier MIO DMAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}