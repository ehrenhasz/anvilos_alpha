{
  "module_name": "k3-psil.c",
  "hash_id": "b44587dcce1993613316713060130d0171523ba963ed2375a5dde3b803ed84ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ti/k3-psil.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/sys_soc.h>\n\n#include \"k3-psil-priv.h\"\n\nstatic DEFINE_MUTEX(ep_map_mutex);\nstatic const struct psil_ep_map *soc_ep_map;\n\nstatic const struct soc_device_attribute k3_soc_devices[] = {\n\t{ .family = \"AM65X\", .data = &am654_ep_map },\n\t{ .family = \"J721E\", .data = &j721e_ep_map },\n\t{ .family = \"J7200\", .data = &j7200_ep_map },\n\t{ .family = \"AM64X\", .data = &am64_ep_map },\n\t{ .family = \"J721S2\", .data = &j721s2_ep_map },\n\t{ .family = \"AM62X\", .data = &am62_ep_map },\n\t{ .family = \"AM62AX\", .data = &am62a_ep_map },\n\t{ .family = \"J784S4\", .data = &j784s4_ep_map },\n\t{   }\n};\n\nstruct psil_endpoint_config *psil_get_ep_config(u32 thread_id)\n{\n\tint i;\n\n\tmutex_lock(&ep_map_mutex);\n\tif (!soc_ep_map) {\n\t\tconst struct soc_device_attribute *soc;\n\n\t\tsoc = soc_device_match(k3_soc_devices);\n\t\tif (soc) {\n\t\t\tsoc_ep_map = soc->data;\n\t\t} else {\n\t\t\tpr_err(\"PSIL: No compatible machine found for map\\n\");\n\t\t\tmutex_unlock(&ep_map_mutex);\n\t\t\treturn ERR_PTR(-ENOTSUPP);\n\t\t}\n\t\tpr_debug(\"%s: Using map for %s\\n\", __func__, soc_ep_map->name);\n\t}\n\tmutex_unlock(&ep_map_mutex);\n\n\tif (thread_id & K3_PSIL_DST_THREAD_ID_OFFSET && soc_ep_map->dst) {\n\t\t \n\t\tfor (i = 0; i < soc_ep_map->dst_count; i++) {\n\t\t\tif (soc_ep_map->dst[i].thread_id == thread_id)\n\t\t\t\treturn &soc_ep_map->dst[i].ep_config;\n\t\t}\n\t}\n\n\tthread_id &= ~K3_PSIL_DST_THREAD_ID_OFFSET;\n\tif (soc_ep_map->src) {\n\t\tfor (i = 0; i < soc_ep_map->src_count; i++) {\n\t\t\tif (soc_ep_map->src[i].thread_id == thread_id)\n\t\t\t\treturn &soc_ep_map->src[i].ep_config;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\nEXPORT_SYMBOL_GPL(psil_get_ep_config);\n\nint psil_set_new_ep_config(struct device *dev, const char *name,\n\t\t\t   struct psil_endpoint_config *ep_config)\n{\n\tstruct psil_endpoint_config *dst_ep_config;\n\tstruct of_phandle_args dma_spec;\n\tu32 thread_id;\n\tint index;\n\n\tif (!dev || !dev->of_node)\n\t\treturn -EINVAL;\n\n\tindex = of_property_match_string(dev->of_node, \"dma-names\", name);\n\tif (index < 0)\n\t\treturn index;\n\n\tif (of_parse_phandle_with_args(dev->of_node, \"dmas\", \"#dma-cells\",\n\t\t\t\t       index, &dma_spec))\n\t\treturn -ENOENT;\n\n\tthread_id = dma_spec.args[0];\n\n\tdst_ep_config = psil_get_ep_config(thread_id);\n\tif (IS_ERR(dst_ep_config)) {\n\t\tpr_err(\"PSIL: thread ID 0x%04x not defined in map\\n\",\n\t\t       thread_id);\n\t\tof_node_put(dma_spec.np);\n\t\treturn PTR_ERR(dst_ep_config);\n\t}\n\n\tmemcpy(dst_ep_config, ep_config, sizeof(*dst_ep_config));\n\n\tof_node_put(dma_spec.np);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(psil_set_new_ep_config);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}