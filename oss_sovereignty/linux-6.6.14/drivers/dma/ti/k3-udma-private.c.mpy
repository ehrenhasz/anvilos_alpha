{
  "module_name": "k3-udma-private.c",
  "hash_id": "1cc37255ae6f477212e8b5cbbec2508c516fc4cd5eca7859169ca1a4f4a6e901",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ti/k3-udma-private.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/of_platform.h>\n\nint xudma_navss_psil_pair(struct udma_dev *ud, u32 src_thread, u32 dst_thread)\n{\n\treturn navss_psil_pair(ud, src_thread, dst_thread);\n}\nEXPORT_SYMBOL(xudma_navss_psil_pair);\n\nint xudma_navss_psil_unpair(struct udma_dev *ud, u32 src_thread, u32 dst_thread)\n{\n\treturn navss_psil_unpair(ud, src_thread, dst_thread);\n}\nEXPORT_SYMBOL(xudma_navss_psil_unpair);\n\nstruct udma_dev *of_xudma_dev_get(struct device_node *np, const char *property)\n{\n\tstruct device_node *udma_node = np;\n\tstruct platform_device *pdev;\n\tstruct udma_dev *ud;\n\n\tif (property) {\n\t\tudma_node = of_parse_phandle(np, property, 0);\n\t\tif (!udma_node) {\n\t\t\tpr_err(\"UDMA node is not found\\n\");\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\t}\n\t}\n\n\tpdev = of_find_device_by_node(udma_node);\n\tif (np != udma_node)\n\t\tof_node_put(udma_node);\n\n\tif (!pdev) {\n\t\tpr_debug(\"UDMA device not found\\n\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tud = platform_get_drvdata(pdev);\n\tif (!ud) {\n\t\tpr_debug(\"UDMA has not been probed\\n\");\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\treturn ud;\n}\nEXPORT_SYMBOL(of_xudma_dev_get);\n\nstruct device *xudma_get_device(struct udma_dev *ud)\n{\n\treturn ud->dev;\n}\nEXPORT_SYMBOL(xudma_get_device);\n\nstruct k3_ringacc *xudma_get_ringacc(struct udma_dev *ud)\n{\n\treturn ud->ringacc;\n}\nEXPORT_SYMBOL(xudma_get_ringacc);\n\nu32 xudma_dev_get_psil_base(struct udma_dev *ud)\n{\n\treturn ud->psil_base;\n}\nEXPORT_SYMBOL(xudma_dev_get_psil_base);\n\nstruct udma_tisci_rm *xudma_dev_get_tisci_rm(struct udma_dev *ud)\n{\n\treturn &ud->tisci_rm;\n}\nEXPORT_SYMBOL(xudma_dev_get_tisci_rm);\n\nint xudma_alloc_gp_rflow_range(struct udma_dev *ud, int from, int cnt)\n{\n\treturn __udma_alloc_gp_rflow_range(ud, from, cnt);\n}\nEXPORT_SYMBOL(xudma_alloc_gp_rflow_range);\n\nint xudma_free_gp_rflow_range(struct udma_dev *ud, int from, int cnt)\n{\n\treturn __udma_free_gp_rflow_range(ud, from, cnt);\n}\nEXPORT_SYMBOL(xudma_free_gp_rflow_range);\n\nbool xudma_rflow_is_gp(struct udma_dev *ud, int id)\n{\n\tif (!ud->rflow_gp_map)\n\t\treturn false;\n\n\treturn !test_bit(id, ud->rflow_gp_map);\n}\nEXPORT_SYMBOL(xudma_rflow_is_gp);\n\n#define XUDMA_GET_PUT_RESOURCE(res)\t\t\t\t\t\\\nstruct udma_##res *xudma_##res##_get(struct udma_dev *ud, int id)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __udma_reserve_##res(ud, UDMA_TP_NORMAL, id);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(xudma_##res##_get);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid xudma_##res##_put(struct udma_dev *ud, struct udma_##res *p)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tclear_bit(p->id, ud->res##_map);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(xudma_##res##_put)\nXUDMA_GET_PUT_RESOURCE(tchan);\nXUDMA_GET_PUT_RESOURCE(rchan);\n\nstruct udma_rflow *xudma_rflow_get(struct udma_dev *ud, int id)\n{\n\treturn __udma_get_rflow(ud, id);\n}\nEXPORT_SYMBOL(xudma_rflow_get);\n\nvoid xudma_rflow_put(struct udma_dev *ud, struct udma_rflow *p)\n{\n\t__udma_put_rflow(ud, p);\n}\nEXPORT_SYMBOL(xudma_rflow_put);\n\nint xudma_get_rflow_ring_offset(struct udma_dev *ud)\n{\n\treturn ud->tflow_cnt;\n}\nEXPORT_SYMBOL(xudma_get_rflow_ring_offset);\n\n#define XUDMA_GET_RESOURCE_ID(res)\t\t\t\t\t\\\nint xudma_##res##_get_id(struct udma_##res *p)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn p->id;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(xudma_##res##_get_id)\nXUDMA_GET_RESOURCE_ID(tchan);\nXUDMA_GET_RESOURCE_ID(rchan);\nXUDMA_GET_RESOURCE_ID(rflow);\n\n \n#define XUDMA_RT_IO_FUNCTIONS(res)\t\t\t\t\t\\\nu32 xudma_##res##rt_read(struct udma_##res *p, int reg)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!p)\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\treturn udma_read(p->reg_rt, reg);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(xudma_##res##rt_read);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid xudma_##res##rt_write(struct udma_##res *p, int reg, u32 val)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!p)\t\t\t\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\tudma_write(p->reg_rt, reg, val);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(xudma_##res##rt_write)\nXUDMA_RT_IO_FUNCTIONS(tchan);\nXUDMA_RT_IO_FUNCTIONS(rchan);\n\nint xudma_is_pktdma(struct udma_dev *ud)\n{\n\treturn ud->match_data->type == DMA_TYPE_PKTDMA;\n}\nEXPORT_SYMBOL(xudma_is_pktdma);\n\nint xudma_pktdma_tflow_get_irq(struct udma_dev *ud, int udma_tflow_id)\n{\n\tconst struct udma_oes_offsets *oes = &ud->soc_data->oes;\n\n\treturn msi_get_virq(ud->dev, udma_tflow_id + oes->pktdma_tchan_flow);\n}\nEXPORT_SYMBOL(xudma_pktdma_tflow_get_irq);\n\nint xudma_pktdma_rflow_get_irq(struct udma_dev *ud, int udma_rflow_id)\n{\n\tconst struct udma_oes_offsets *oes = &ud->soc_data->oes;\n\n\treturn msi_get_virq(ud->dev, udma_rflow_id + oes->pktdma_rchan_flow);\n}\nEXPORT_SYMBOL(xudma_pktdma_rflow_get_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}