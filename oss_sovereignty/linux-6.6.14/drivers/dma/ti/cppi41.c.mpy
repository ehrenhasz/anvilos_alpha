{
  "module_name": "cppi41.c",
  "hash_id": "ca6a46d0877507c94c663499f71cb5b20cdd39bf17b1ab1ddac0e62e35a09d7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ti/cppi41.c",
  "human_readable_source": "\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/of_dma.h>\n#include <linux/of_irq.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/pm_runtime.h>\n#include \"../dmaengine.h\"\n\n#define DESC_TYPE\t27\n#define DESC_TYPE_HOST\t0x10\n#define DESC_TYPE_TEARD\t0x13\n\n#define TD_DESC_IS_RX\t(1 << 16)\n#define TD_DESC_DMA_NUM\t10\n\n#define DESC_LENGTH_BITS_NUM\t21\n\n#define DESC_TYPE_USB\t(5 << 26)\n#define DESC_PD_COMPLETE\t(1 << 31)\n\n \n#define DMA_TDFDQ\t4\n#define DMA_TXGCR(x)\t(0x800 + (x) * 0x20)\n#define DMA_RXGCR(x)\t(0x808 + (x) * 0x20)\n#define RXHPCRA0\t\t4\n\n#define GCR_CHAN_ENABLE\t\t(1 << 31)\n#define GCR_TEARDOWN\t\t(1 << 30)\n#define GCR_STARV_RETRY\t\t(1 << 24)\n#define GCR_DESC_TYPE_HOST\t(1 << 14)\n\n \n#define DMA_SCHED_CTRL\t\t0\n#define DMA_SCHED_CTRL_EN\t(1 << 31)\n#define DMA_SCHED_WORD(x)\t((x) * 4 + 0x800)\n\n#define SCHED_ENTRY0_CHAN(x)\t((x) << 0)\n#define SCHED_ENTRY0_IS_RX\t(1 << 7)\n\n#define SCHED_ENTRY1_CHAN(x)\t((x) << 8)\n#define SCHED_ENTRY1_IS_RX\t(1 << 15)\n\n#define SCHED_ENTRY2_CHAN(x)\t((x) << 16)\n#define SCHED_ENTRY2_IS_RX\t(1 << 23)\n\n#define SCHED_ENTRY3_CHAN(x)\t((x) << 24)\n#define SCHED_ENTRY3_IS_RX\t(1 << 31)\n\n \n \n#define ALLOC_DECS_NUM\t\t128\n#define DESCS_AREAS\t\t1\n#define TOTAL_DESCS_NUM\t\t(ALLOC_DECS_NUM * DESCS_AREAS)\n#define QMGR_SCRATCH_SIZE\t(TOTAL_DESCS_NUM * 4)\n\n#define QMGR_LRAM0_BASE\t\t0x80\n#define QMGR_LRAM_SIZE\t\t0x84\n#define QMGR_LRAM1_BASE\t\t0x88\n#define QMGR_MEMBASE(x)\t\t(0x1000 + (x) * 0x10)\n#define QMGR_MEMCTRL(x)\t\t(0x1004 + (x) * 0x10)\n#define QMGR_MEMCTRL_IDX_SH\t16\n#define QMGR_MEMCTRL_DESC_SH\t8\n\n#define QMGR_PEND(x)\t(0x90 + (x) * 4)\n\n#define QMGR_PENDING_SLOT_Q(x)\t(x / 32)\n#define QMGR_PENDING_BIT_Q(x)\t(x % 32)\n\n#define QMGR_QUEUE_A(n)\t(0x2000 + (n) * 0x10)\n#define QMGR_QUEUE_B(n)\t(0x2004 + (n) * 0x10)\n#define QMGR_QUEUE_C(n)\t(0x2008 + (n) * 0x10)\n#define QMGR_QUEUE_D(n)\t(0x200c + (n) * 0x10)\n\n \n#define PD2_ZERO_LENGTH\t\t(1 << 19)\n\nstruct cppi41_channel {\n\tstruct dma_chan chan;\n\tstruct dma_async_tx_descriptor txd;\n\tstruct cppi41_dd *cdd;\n\tstruct cppi41_desc *desc;\n\tdma_addr_t desc_phys;\n\tvoid __iomem *gcr_reg;\n\tint is_tx;\n\tu32 residue;\n\n\tunsigned int q_num;\n\tunsigned int q_comp_num;\n\tunsigned int port_num;\n\n\tunsigned td_retry;\n\tunsigned td_queued:1;\n\tunsigned td_seen:1;\n\tunsigned td_desc_seen:1;\n\n\tstruct list_head node;\t\t \n};\n\nstruct cppi41_desc {\n\tu32 pd0;\n\tu32 pd1;\n\tu32 pd2;\n\tu32 pd3;\n\tu32 pd4;\n\tu32 pd5;\n\tu32 pd6;\n\tu32 pd7;\n} __aligned(32);\n\nstruct chan_queues {\n\tu16 submit;\n\tu16 complete;\n};\n\nstruct cppi41_dd {\n\tstruct dma_device ddev;\n\n\tvoid *qmgr_scratch;\n\tdma_addr_t scratch_phys;\n\n\tstruct cppi41_desc *cd;\n\tdma_addr_t descs_phys;\n\tu32 first_td_desc;\n\tstruct cppi41_channel *chan_busy[ALLOC_DECS_NUM];\n\n\tvoid __iomem *ctrl_mem;\n\tvoid __iomem *sched_mem;\n\tvoid __iomem *qmgr_mem;\n\tunsigned int irq;\n\tconst struct chan_queues *queues_rx;\n\tconst struct chan_queues *queues_tx;\n\tstruct chan_queues td_queue;\n\tu16 first_completion_queue;\n\tu16 qmgr_num_pend;\n\tu32 n_chans;\n\tu8 platform;\n\n\tstruct list_head pending;\t \n\tspinlock_t lock;\t\t \n\n\t \n\tunsigned int dma_tdfdq;\n\n\tbool is_suspended;\n};\n\nstatic struct chan_queues am335x_usb_queues_tx[] = {\n\t \n\t[ 0] = { .submit = 32, .complete =  93},\n\t[ 1] = { .submit = 34, .complete =  94},\n\t[ 2] = { .submit = 36, .complete =  95},\n\t[ 3] = { .submit = 38, .complete =  96},\n\t[ 4] = { .submit = 40, .complete =  97},\n\t[ 5] = { .submit = 42, .complete =  98},\n\t[ 6] = { .submit = 44, .complete =  99},\n\t[ 7] = { .submit = 46, .complete = 100},\n\t[ 8] = { .submit = 48, .complete = 101},\n\t[ 9] = { .submit = 50, .complete = 102},\n\t[10] = { .submit = 52, .complete = 103},\n\t[11] = { .submit = 54, .complete = 104},\n\t[12] = { .submit = 56, .complete = 105},\n\t[13] = { .submit = 58, .complete = 106},\n\t[14] = { .submit = 60, .complete = 107},\n\n\t \n\t[15] = { .submit = 62, .complete = 125},\n\t[16] = { .submit = 64, .complete = 126},\n\t[17] = { .submit = 66, .complete = 127},\n\t[18] = { .submit = 68, .complete = 128},\n\t[19] = { .submit = 70, .complete = 129},\n\t[20] = { .submit = 72, .complete = 130},\n\t[21] = { .submit = 74, .complete = 131},\n\t[22] = { .submit = 76, .complete = 132},\n\t[23] = { .submit = 78, .complete = 133},\n\t[24] = { .submit = 80, .complete = 134},\n\t[25] = { .submit = 82, .complete = 135},\n\t[26] = { .submit = 84, .complete = 136},\n\t[27] = { .submit = 86, .complete = 137},\n\t[28] = { .submit = 88, .complete = 138},\n\t[29] = { .submit = 90, .complete = 139},\n};\n\nstatic const struct chan_queues am335x_usb_queues_rx[] = {\n\t \n\t[ 0] = { .submit =  1, .complete = 109},\n\t[ 1] = { .submit =  2, .complete = 110},\n\t[ 2] = { .submit =  3, .complete = 111},\n\t[ 3] = { .submit =  4, .complete = 112},\n\t[ 4] = { .submit =  5, .complete = 113},\n\t[ 5] = { .submit =  6, .complete = 114},\n\t[ 6] = { .submit =  7, .complete = 115},\n\t[ 7] = { .submit =  8, .complete = 116},\n\t[ 8] = { .submit =  9, .complete = 117},\n\t[ 9] = { .submit = 10, .complete = 118},\n\t[10] = { .submit = 11, .complete = 119},\n\t[11] = { .submit = 12, .complete = 120},\n\t[12] = { .submit = 13, .complete = 121},\n\t[13] = { .submit = 14, .complete = 122},\n\t[14] = { .submit = 15, .complete = 123},\n\n\t \n\t[15] = { .submit = 16, .complete = 141},\n\t[16] = { .submit = 17, .complete = 142},\n\t[17] = { .submit = 18, .complete = 143},\n\t[18] = { .submit = 19, .complete = 144},\n\t[19] = { .submit = 20, .complete = 145},\n\t[20] = { .submit = 21, .complete = 146},\n\t[21] = { .submit = 22, .complete = 147},\n\t[22] = { .submit = 23, .complete = 148},\n\t[23] = { .submit = 24, .complete = 149},\n\t[24] = { .submit = 25, .complete = 150},\n\t[25] = { .submit = 26, .complete = 151},\n\t[26] = { .submit = 27, .complete = 152},\n\t[27] = { .submit = 28, .complete = 153},\n\t[28] = { .submit = 29, .complete = 154},\n\t[29] = { .submit = 30, .complete = 155},\n};\n\nstatic const struct chan_queues da8xx_usb_queues_tx[] = {\n\t[0] = { .submit =  16, .complete = 24},\n\t[1] = { .submit =  18, .complete = 24},\n\t[2] = { .submit =  20, .complete = 24},\n\t[3] = { .submit =  22, .complete = 24},\n};\n\nstatic const struct chan_queues da8xx_usb_queues_rx[] = {\n\t[0] = { .submit =  1, .complete = 26},\n\t[1] = { .submit =  3, .complete = 26},\n\t[2] = { .submit =  5, .complete = 26},\n\t[3] = { .submit =  7, .complete = 26},\n};\n\nstruct cppi_glue_infos {\n\tconst struct chan_queues *queues_rx;\n\tconst struct chan_queues *queues_tx;\n\tstruct chan_queues td_queue;\n\tu16 first_completion_queue;\n\tu16 qmgr_num_pend;\n};\n\nstatic struct cppi41_channel *to_cpp41_chan(struct dma_chan *c)\n{\n\treturn container_of(c, struct cppi41_channel, chan);\n}\n\nstatic struct cppi41_channel *desc_to_chan(struct cppi41_dd *cdd, u32 desc)\n{\n\tstruct cppi41_channel *c;\n\tu32 descs_size;\n\tu32 desc_num;\n\n\tdescs_size = sizeof(struct cppi41_desc) * ALLOC_DECS_NUM;\n\n\tif (!((desc >= cdd->descs_phys) &&\n\t\t\t(desc < (cdd->descs_phys + descs_size)))) {\n\t\treturn NULL;\n\t}\n\n\tdesc_num = (desc - cdd->descs_phys) / sizeof(struct cppi41_desc);\n\tBUG_ON(desc_num >= ALLOC_DECS_NUM);\n\tc = cdd->chan_busy[desc_num];\n\tcdd->chan_busy[desc_num] = NULL;\n\n\t \n\tpm_runtime_put(cdd->ddev.dev);\n\n\treturn c;\n}\n\nstatic void cppi_writel(u32 val, void *__iomem *mem)\n{\n\t__raw_writel(val, mem);\n}\n\nstatic u32 cppi_readl(void *__iomem *mem)\n{\n\treturn __raw_readl(mem);\n}\n\nstatic u32 pd_trans_len(u32 val)\n{\n\treturn val & ((1 << (DESC_LENGTH_BITS_NUM + 1)) - 1);\n}\n\nstatic u32 cppi41_pop_desc(struct cppi41_dd *cdd, unsigned queue_num)\n{\n\tu32 desc;\n\n\tdesc = cppi_readl(cdd->qmgr_mem + QMGR_QUEUE_D(queue_num));\n\tdesc &= ~0x1f;\n\treturn desc;\n}\n\nstatic irqreturn_t cppi41_irq(int irq, void *data)\n{\n\tstruct cppi41_dd *cdd = data;\n\tu16 first_completion_queue = cdd->first_completion_queue;\n\tu16 qmgr_num_pend = cdd->qmgr_num_pend;\n\tstruct cppi41_channel *c;\n\tint i;\n\n\tfor (i = QMGR_PENDING_SLOT_Q(first_completion_queue); i < qmgr_num_pend;\n\t\t\ti++) {\n\t\tu32 val;\n\t\tu32 q_num;\n\n\t\tval = cppi_readl(cdd->qmgr_mem + QMGR_PEND(i));\n\t\tif (i == QMGR_PENDING_SLOT_Q(first_completion_queue) && val) {\n\t\t\tu32 mask;\n\t\t\t \n\t\t\tmask = 1 << QMGR_PENDING_BIT_Q(first_completion_queue);\n\t\t\t \n\t\t\tmask--;\n\t\t\t \n\t\t\tval &= ~mask;\n\t\t}\n\n\t\tif (val)\n\t\t\t__iormb();\n\n\t\twhile (val) {\n\t\t\tu32 desc, len;\n\n\t\t\t \n\t\t\tWARN_ON(cdd->is_suspended);\n\n\t\t\tq_num = __fls(val);\n\t\t\tval &= ~(1 << q_num);\n\t\t\tq_num += 32 * i;\n\t\t\tdesc = cppi41_pop_desc(cdd, q_num);\n\t\t\tc = desc_to_chan(cdd, desc);\n\t\t\tif (WARN_ON(!c)) {\n\t\t\t\tpr_err(\"%s() q %d desc %08x\\n\", __func__,\n\t\t\t\t\t\tq_num, desc);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->desc->pd2 & PD2_ZERO_LENGTH)\n\t\t\t\tlen = 0;\n\t\t\telse\n\t\t\t\tlen = pd_trans_len(c->desc->pd0);\n\n\t\t\tc->residue = pd_trans_len(c->desc->pd6) - len;\n\t\t\tdma_cookie_complete(&c->txd);\n\t\t\tdmaengine_desc_get_callback_invoke(&c->txd, NULL);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic dma_cookie_t cppi41_tx_submit(struct dma_async_tx_descriptor *tx)\n{\n\tdma_cookie_t cookie;\n\n\tcookie = dma_cookie_assign(tx);\n\n\treturn cookie;\n}\n\nstatic int cppi41_dma_alloc_chan_resources(struct dma_chan *chan)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tstruct cppi41_dd *cdd = c->cdd;\n\tint error;\n\n\terror = pm_runtime_get_sync(cdd->ddev.dev);\n\tif (error < 0) {\n\t\tdev_err(cdd->ddev.dev, \"%s pm runtime get: %i\\n\",\n\t\t\t__func__, error);\n\t\tpm_runtime_put_noidle(cdd->ddev.dev);\n\n\t\treturn error;\n\t}\n\n\tdma_cookie_init(chan);\n\tdma_async_tx_descriptor_init(&c->txd, chan);\n\tc->txd.tx_submit = cppi41_tx_submit;\n\n\tif (!c->is_tx)\n\t\tcppi_writel(c->q_num, c->gcr_reg + RXHPCRA0);\n\n\tpm_runtime_mark_last_busy(cdd->ddev.dev);\n\tpm_runtime_put_autosuspend(cdd->ddev.dev);\n\n\treturn 0;\n}\n\nstatic void cppi41_dma_free_chan_resources(struct dma_chan *chan)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tstruct cppi41_dd *cdd = c->cdd;\n\tint error;\n\n\terror = pm_runtime_get_sync(cdd->ddev.dev);\n\tif (error < 0) {\n\t\tpm_runtime_put_noidle(cdd->ddev.dev);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(!list_empty(&cdd->pending));\n\n\tpm_runtime_mark_last_busy(cdd->ddev.dev);\n\tpm_runtime_put_autosuspend(cdd->ddev.dev);\n}\n\nstatic enum dma_status cppi41_dma_tx_status(struct dma_chan *chan,\n\tdma_cookie_t cookie, struct dma_tx_state *txstate)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tenum dma_status ret;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\n\tdma_set_residue(txstate, c->residue);\n\n\treturn ret;\n}\n\nstatic void push_desc_queue(struct cppi41_channel *c)\n{\n\tstruct cppi41_dd *cdd = c->cdd;\n\tu32 desc_num;\n\tu32 desc_phys;\n\tu32 reg;\n\n\tc->residue = 0;\n\n\treg = GCR_CHAN_ENABLE;\n\tif (!c->is_tx) {\n\t\treg |= GCR_STARV_RETRY;\n\t\treg |= GCR_DESC_TYPE_HOST;\n\t\treg |= c->q_comp_num;\n\t}\n\n\tcppi_writel(reg, c->gcr_reg);\n\n\t \n\t__iowmb();\n\n\t \n\tpm_runtime_get(cdd->ddev.dev);\n\n\tdesc_phys = lower_32_bits(c->desc_phys);\n\tdesc_num = (desc_phys - cdd->descs_phys) / sizeof(struct cppi41_desc);\n\tWARN_ON(cdd->chan_busy[desc_num]);\n\tcdd->chan_busy[desc_num] = c;\n\n\treg = (sizeof(struct cppi41_desc) - 24) / 4;\n\treg |= desc_phys;\n\tcppi_writel(reg, cdd->qmgr_mem + QMGR_QUEUE_D(c->q_num));\n}\n\n \nstatic void cppi41_run_queue(struct cppi41_dd *cdd)\n{\n\tstruct cppi41_channel *c, *_c;\n\n\tlist_for_each_entry_safe(c, _c, &cdd->pending, node) {\n\t\tpush_desc_queue(c);\n\t\tlist_del(&c->node);\n\t}\n}\n\nstatic void cppi41_dma_issue_pending(struct dma_chan *chan)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tstruct cppi41_dd *cdd = c->cdd;\n\tunsigned long flags;\n\tint error;\n\n\terror = pm_runtime_get(cdd->ddev.dev);\n\tif ((error != -EINPROGRESS) && error < 0) {\n\t\tpm_runtime_put_noidle(cdd->ddev.dev);\n\t\tdev_err(cdd->ddev.dev, \"Failed to pm_runtime_get: %i\\n\",\n\t\t\terror);\n\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&cdd->lock, flags);\n\tlist_add_tail(&c->node, &cdd->pending);\n\tif (!cdd->is_suspended)\n\t\tcppi41_run_queue(cdd);\n\tspin_unlock_irqrestore(&cdd->lock, flags);\n\n\tpm_runtime_mark_last_busy(cdd->ddev.dev);\n\tpm_runtime_put_autosuspend(cdd->ddev.dev);\n}\n\nstatic u32 get_host_pd0(u32 length)\n{\n\tu32 reg;\n\n\treg = DESC_TYPE_HOST << DESC_TYPE;\n\treg |= length;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd1(struct cppi41_channel *c)\n{\n\tu32 reg;\n\n\treg = 0;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd2(struct cppi41_channel *c)\n{\n\tu32 reg;\n\n\treg = DESC_TYPE_USB;\n\treg |= c->q_comp_num;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd3(u32 length)\n{\n\tu32 reg;\n\n\t \n\treg = length;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd6(u32 length)\n{\n\tu32 reg;\n\n\t \n\treg = DESC_PD_COMPLETE;\n\treg |= length;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd4_or_7(u32 addr)\n{\n\tu32 reg;\n\n\treg = addr;\n\n\treturn reg;\n}\n\nstatic u32 get_host_pd5(void)\n{\n\tu32 reg;\n\n\treg = 0;\n\n\treturn reg;\n}\n\nstatic struct dma_async_tx_descriptor *cppi41_dma_prep_slave_sg(\n\tstruct dma_chan *chan, struct scatterlist *sgl, unsigned sg_len,\n\tenum dma_transfer_direction dir, unsigned long tx_flags, void *context)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tstruct dma_async_tx_descriptor *txd = NULL;\n\tstruct cppi41_dd *cdd = c->cdd;\n\tstruct cppi41_desc *d;\n\tstruct scatterlist *sg;\n\tunsigned int i;\n\tint error;\n\n\terror = pm_runtime_get(cdd->ddev.dev);\n\tif (error < 0) {\n\t\tpm_runtime_put_noidle(cdd->ddev.dev);\n\n\t\treturn NULL;\n\t}\n\n\tif (cdd->is_suspended)\n\t\tgoto err_out_not_ready;\n\n\td = c->desc;\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tu32 addr;\n\t\tu32 len;\n\n\t\t \n\t\taddr = lower_32_bits(sg_dma_address(sg));\n\t\tlen = sg_dma_len(sg);\n\n\t\td->pd0 = get_host_pd0(len);\n\t\td->pd1 = get_host_pd1(c);\n\t\td->pd2 = get_host_pd2(c);\n\t\td->pd3 = get_host_pd3(len);\n\t\td->pd4 = get_host_pd4_or_7(addr);\n\t\td->pd5 = get_host_pd5();\n\t\td->pd6 = get_host_pd6(len);\n\t\td->pd7 = get_host_pd4_or_7(addr);\n\n\t\td++;\n\t}\n\n\ttxd = &c->txd;\n\nerr_out_not_ready:\n\tpm_runtime_mark_last_busy(cdd->ddev.dev);\n\tpm_runtime_put_autosuspend(cdd->ddev.dev);\n\n\treturn txd;\n}\n\nstatic void cppi41_compute_td_desc(struct cppi41_desc *d)\n{\n\td->pd0 = DESC_TYPE_TEARD << DESC_TYPE;\n}\n\nstatic int cppi41_tear_down_chan(struct cppi41_channel *c)\n{\n\tstruct dmaengine_result abort_result;\n\tstruct cppi41_dd *cdd = c->cdd;\n\tstruct cppi41_desc *td;\n\tu32 reg;\n\tu32 desc_phys;\n\tu32 td_desc_phys;\n\n\ttd = cdd->cd;\n\ttd += cdd->first_td_desc;\n\n\ttd_desc_phys = cdd->descs_phys;\n\ttd_desc_phys += cdd->first_td_desc * sizeof(struct cppi41_desc);\n\n\tif (!c->td_queued) {\n\t\tcppi41_compute_td_desc(td);\n\t\t__iowmb();\n\n\t\treg = (sizeof(struct cppi41_desc) - 24) / 4;\n\t\treg |= td_desc_phys;\n\t\tcppi_writel(reg, cdd->qmgr_mem +\n\t\t\t\tQMGR_QUEUE_D(cdd->td_queue.submit));\n\n\t\treg = GCR_CHAN_ENABLE;\n\t\tif (!c->is_tx) {\n\t\t\treg |= GCR_STARV_RETRY;\n\t\t\treg |= GCR_DESC_TYPE_HOST;\n\t\t\treg |= cdd->td_queue.complete;\n\t\t}\n\t\treg |= GCR_TEARDOWN;\n\t\tcppi_writel(reg, c->gcr_reg);\n\t\tc->td_queued = 1;\n\t\tc->td_retry = 500;\n\t}\n\n\tif (!c->td_seen || !c->td_desc_seen) {\n\n\t\tdesc_phys = cppi41_pop_desc(cdd, cdd->td_queue.complete);\n\t\tif (!desc_phys && c->is_tx)\n\t\t\tdesc_phys = cppi41_pop_desc(cdd, c->q_comp_num);\n\n\t\tif (desc_phys == c->desc_phys) {\n\t\t\tc->td_desc_seen = 1;\n\n\t\t} else if (desc_phys == td_desc_phys) {\n\t\t\tu32 pd0;\n\n\t\t\t__iormb();\n\t\t\tpd0 = td->pd0;\n\t\t\tWARN_ON((pd0 >> DESC_TYPE) != DESC_TYPE_TEARD);\n\t\t\tWARN_ON(!c->is_tx && !(pd0 & TD_DESC_IS_RX));\n\t\t\tWARN_ON((pd0 & 0x1f) != c->port_num);\n\t\t\tc->td_seen = 1;\n\t\t} else if (desc_phys) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\tc->td_retry--;\n\t \n\tif (!c->td_seen && c->td_retry) {\n\t\tudelay(1);\n\t\treturn -EAGAIN;\n\t}\n\tWARN_ON(!c->td_retry);\n\n\tif (!c->td_desc_seen) {\n\t\tdesc_phys = cppi41_pop_desc(cdd, c->q_num);\n\t\tif (!desc_phys)\n\t\t\tdesc_phys = cppi41_pop_desc(cdd, c->q_comp_num);\n\t\tWARN_ON(!desc_phys);\n\t}\n\n\tc->td_queued = 0;\n\tc->td_seen = 0;\n\tc->td_desc_seen = 0;\n\tcppi_writel(0, c->gcr_reg);\n\n\t \n\tabort_result.result = DMA_TRANS_ABORTED;\n\tdma_cookie_complete(&c->txd);\n\tdmaengine_desc_get_callback_invoke(&c->txd, &abort_result);\n\n\treturn 0;\n}\n\nstatic int cppi41_stop_chan(struct dma_chan *chan)\n{\n\tstruct cppi41_channel *c = to_cpp41_chan(chan);\n\tstruct cppi41_dd *cdd = c->cdd;\n\tu32 desc_num;\n\tu32 desc_phys;\n\tint ret;\n\n\tdesc_phys = lower_32_bits(c->desc_phys);\n\tdesc_num = (desc_phys - cdd->descs_phys) / sizeof(struct cppi41_desc);\n\tif (!cdd->chan_busy[desc_num]) {\n\t\tstruct cppi41_channel *cc, *_ct;\n\n\t\t \n\t\tlist_for_each_entry_safe(cc, _ct, &cdd->pending, node) {\n\t\t\tif (cc != c)\n\t\t\t\tcontinue;\n\t\t\tlist_del(&cc->node);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tret = cppi41_tear_down_chan(c);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(!cdd->chan_busy[desc_num]);\n\tcdd->chan_busy[desc_num] = NULL;\n\n\t \n\tpm_runtime_put(cdd->ddev.dev);\n\n\treturn 0;\n}\n\nstatic int cppi41_add_chans(struct device *dev, struct cppi41_dd *cdd)\n{\n\tstruct cppi41_channel *cchan, *chans;\n\tint i;\n\tu32 n_chans = cdd->n_chans;\n\n\t \n\tn_chans *= 2;\n\n\tchans = devm_kcalloc(dev, n_chans, sizeof(*chans), GFP_KERNEL);\n\tif (!chans)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n_chans; i++) {\n\t\tcchan = &chans[i];\n\n\t\tcchan->cdd = cdd;\n\t\tif (i & 1) {\n\t\t\tcchan->gcr_reg = cdd->ctrl_mem + DMA_TXGCR(i >> 1);\n\t\t\tcchan->is_tx = 1;\n\t\t} else {\n\t\t\tcchan->gcr_reg = cdd->ctrl_mem + DMA_RXGCR(i >> 1);\n\t\t\tcchan->is_tx = 0;\n\t\t}\n\t\tcchan->port_num = i >> 1;\n\t\tcchan->desc = &cdd->cd[i];\n\t\tcchan->desc_phys = cdd->descs_phys;\n\t\tcchan->desc_phys += i * sizeof(struct cppi41_desc);\n\t\tcchan->chan.device = &cdd->ddev;\n\t\tlist_add_tail(&cchan->chan.device_node, &cdd->ddev.channels);\n\t}\n\tcdd->first_td_desc = n_chans;\n\n\treturn 0;\n}\n\nstatic void purge_descs(struct device *dev, struct cppi41_dd *cdd)\n{\n\tunsigned int mem_decs;\n\tint i;\n\n\tmem_decs = ALLOC_DECS_NUM * sizeof(struct cppi41_desc);\n\n\tfor (i = 0; i < DESCS_AREAS; i++) {\n\n\t\tcppi_writel(0, cdd->qmgr_mem + QMGR_MEMBASE(i));\n\t\tcppi_writel(0, cdd->qmgr_mem + QMGR_MEMCTRL(i));\n\n\t\tdma_free_coherent(dev, mem_decs, cdd->cd,\n\t\t\t\tcdd->descs_phys);\n\t}\n}\n\nstatic void disable_sched(struct cppi41_dd *cdd)\n{\n\tcppi_writel(0, cdd->sched_mem + DMA_SCHED_CTRL);\n}\n\nstatic void deinit_cppi41(struct device *dev, struct cppi41_dd *cdd)\n{\n\tdisable_sched(cdd);\n\n\tpurge_descs(dev, cdd);\n\n\tcppi_writel(0, cdd->qmgr_mem + QMGR_LRAM0_BASE);\n\tcppi_writel(0, cdd->qmgr_mem + QMGR_LRAM0_BASE);\n\tdma_free_coherent(dev, QMGR_SCRATCH_SIZE, cdd->qmgr_scratch,\n\t\t\tcdd->scratch_phys);\n}\n\nstatic int init_descs(struct device *dev, struct cppi41_dd *cdd)\n{\n\tunsigned int desc_size;\n\tunsigned int mem_decs;\n\tint i;\n\tu32 reg;\n\tu32 idx;\n\n\tBUILD_BUG_ON(sizeof(struct cppi41_desc) &\n\t\t\t(sizeof(struct cppi41_desc) - 1));\n\tBUILD_BUG_ON(sizeof(struct cppi41_desc) < 32);\n\tBUILD_BUG_ON(ALLOC_DECS_NUM < 32);\n\n\tdesc_size = sizeof(struct cppi41_desc);\n\tmem_decs = ALLOC_DECS_NUM * desc_size;\n\n\tidx = 0;\n\tfor (i = 0; i < DESCS_AREAS; i++) {\n\n\t\treg = idx << QMGR_MEMCTRL_IDX_SH;\n\t\treg |= (ilog2(desc_size) - 5) << QMGR_MEMCTRL_DESC_SH;\n\t\treg |= ilog2(ALLOC_DECS_NUM) - 5;\n\n\t\tBUILD_BUG_ON(DESCS_AREAS != 1);\n\t\tcdd->cd = dma_alloc_coherent(dev, mem_decs,\n\t\t\t\t&cdd->descs_phys, GFP_KERNEL);\n\t\tif (!cdd->cd)\n\t\t\treturn -ENOMEM;\n\n\t\tcppi_writel(cdd->descs_phys, cdd->qmgr_mem + QMGR_MEMBASE(i));\n\t\tcppi_writel(reg, cdd->qmgr_mem + QMGR_MEMCTRL(i));\n\n\t\tidx += ALLOC_DECS_NUM;\n\t}\n\treturn 0;\n}\n\nstatic void init_sched(struct cppi41_dd *cdd)\n{\n\tunsigned ch;\n\tunsigned word;\n\tu32 reg;\n\n\tword = 0;\n\tcppi_writel(0, cdd->sched_mem + DMA_SCHED_CTRL);\n\tfor (ch = 0; ch < cdd->n_chans; ch += 2) {\n\n\t\treg = SCHED_ENTRY0_CHAN(ch);\n\t\treg |= SCHED_ENTRY1_CHAN(ch) | SCHED_ENTRY1_IS_RX;\n\n\t\treg |= SCHED_ENTRY2_CHAN(ch + 1);\n\t\treg |= SCHED_ENTRY3_CHAN(ch + 1) | SCHED_ENTRY3_IS_RX;\n\t\tcppi_writel(reg, cdd->sched_mem + DMA_SCHED_WORD(word));\n\t\tword++;\n\t}\n\treg = cdd->n_chans * 2 - 1;\n\treg |= DMA_SCHED_CTRL_EN;\n\tcppi_writel(reg, cdd->sched_mem + DMA_SCHED_CTRL);\n}\n\nstatic int init_cppi41(struct device *dev, struct cppi41_dd *cdd)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(QMGR_SCRATCH_SIZE > ((1 << 14) - 1));\n\tcdd->qmgr_scratch = dma_alloc_coherent(dev, QMGR_SCRATCH_SIZE,\n\t\t\t&cdd->scratch_phys, GFP_KERNEL);\n\tif (!cdd->qmgr_scratch)\n\t\treturn -ENOMEM;\n\n\tcppi_writel(cdd->scratch_phys, cdd->qmgr_mem + QMGR_LRAM0_BASE);\n\tcppi_writel(TOTAL_DESCS_NUM, cdd->qmgr_mem + QMGR_LRAM_SIZE);\n\tcppi_writel(0, cdd->qmgr_mem + QMGR_LRAM1_BASE);\n\n\tret = init_descs(dev, cdd);\n\tif (ret)\n\t\tgoto err_td;\n\n\tcppi_writel(cdd->td_queue.submit, cdd->ctrl_mem + DMA_TDFDQ);\n\tinit_sched(cdd);\n\n\treturn 0;\nerr_td:\n\tdeinit_cppi41(dev, cdd);\n\treturn ret;\n}\n\nstatic struct platform_driver cpp41_dma_driver;\n \n#define INFO_PORT\t0\n#define INFO_IS_TX\t1\n\nstatic bool cpp41_dma_filter_fn(struct dma_chan *chan, void *param)\n{\n\tstruct cppi41_channel *cchan;\n\tstruct cppi41_dd *cdd;\n\tconst struct chan_queues *queues;\n\tu32 *num = param;\n\n\tif (chan->device->dev->driver != &cpp41_dma_driver.driver)\n\t\treturn false;\n\n\tcchan = to_cpp41_chan(chan);\n\n\tif (cchan->port_num != num[INFO_PORT])\n\t\treturn false;\n\n\tif (cchan->is_tx && !num[INFO_IS_TX])\n\t\treturn false;\n\tcdd = cchan->cdd;\n\tif (cchan->is_tx)\n\t\tqueues = cdd->queues_tx;\n\telse\n\t\tqueues = cdd->queues_rx;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(am335x_usb_queues_rx) !=\n\t\t     ARRAY_SIZE(am335x_usb_queues_tx));\n\tif (WARN_ON(cchan->port_num >= ARRAY_SIZE(am335x_usb_queues_rx)))\n\t\treturn false;\n\n\tcchan->q_num = queues[cchan->port_num].submit;\n\tcchan->q_comp_num = queues[cchan->port_num].complete;\n\treturn true;\n}\n\nstatic struct of_dma_filter_info cpp41_dma_info = {\n\t.filter_fn = cpp41_dma_filter_fn,\n};\n\nstatic struct dma_chan *cppi41_dma_xlate(struct of_phandle_args *dma_spec,\n\t\tstruct of_dma *ofdma)\n{\n\tint count = dma_spec->args_count;\n\tstruct of_dma_filter_info *info = ofdma->of_dma_data;\n\n\tif (!info || !info->filter_fn)\n\t\treturn NULL;\n\n\tif (count != 2)\n\t\treturn NULL;\n\n\treturn dma_request_channel(info->dma_cap, info->filter_fn,\n\t\t\t&dma_spec->args[0]);\n}\n\nstatic const struct cppi_glue_infos am335x_usb_infos = {\n\t.queues_rx = am335x_usb_queues_rx,\n\t.queues_tx = am335x_usb_queues_tx,\n\t.td_queue = { .submit = 31, .complete = 0 },\n\t.first_completion_queue = 93,\n\t.qmgr_num_pend = 5,\n};\n\nstatic const struct cppi_glue_infos da8xx_usb_infos = {\n\t.queues_rx = da8xx_usb_queues_rx,\n\t.queues_tx = da8xx_usb_queues_tx,\n\t.td_queue = { .submit = 31, .complete = 0 },\n\t.first_completion_queue = 24,\n\t.qmgr_num_pend = 2,\n};\n\nstatic const struct of_device_id cppi41_dma_ids[] = {\n\t{ .compatible = \"ti,am3359-cppi41\", .data = &am335x_usb_infos},\n\t{ .compatible = \"ti,da830-cppi41\", .data = &da8xx_usb_infos},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cppi41_dma_ids);\n\nstatic const struct cppi_glue_infos *get_glue_info(struct device *dev)\n{\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(cppi41_dma_ids, dev->of_node);\n\tif (!of_id)\n\t\treturn NULL;\n\treturn of_id->data;\n}\n\n#define CPPI41_DMA_BUSWIDTHS\t(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_3_BYTES) | \\\n\t\t\t\tBIT(DMA_SLAVE_BUSWIDTH_4_BYTES))\n\nstatic int cppi41_dma_probe(struct platform_device *pdev)\n{\n\tstruct cppi41_dd *cdd;\n\tstruct device *dev = &pdev->dev;\n\tconst struct cppi_glue_infos *glue_info;\n\tint index;\n\tint irq;\n\tint ret;\n\n\tglue_info = get_glue_info(dev);\n\tif (!glue_info)\n\t\treturn -EINVAL;\n\n\tcdd = devm_kzalloc(&pdev->dev, sizeof(*cdd), GFP_KERNEL);\n\tif (!cdd)\n\t\treturn -ENOMEM;\n\n\tdma_cap_set(DMA_SLAVE, cdd->ddev.cap_mask);\n\tcdd->ddev.device_alloc_chan_resources = cppi41_dma_alloc_chan_resources;\n\tcdd->ddev.device_free_chan_resources = cppi41_dma_free_chan_resources;\n\tcdd->ddev.device_tx_status = cppi41_dma_tx_status;\n\tcdd->ddev.device_issue_pending = cppi41_dma_issue_pending;\n\tcdd->ddev.device_prep_slave_sg = cppi41_dma_prep_slave_sg;\n\tcdd->ddev.device_terminate_all = cppi41_stop_chan;\n\tcdd->ddev.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\n\tcdd->ddev.src_addr_widths = CPPI41_DMA_BUSWIDTHS;\n\tcdd->ddev.dst_addr_widths = CPPI41_DMA_BUSWIDTHS;\n\tcdd->ddev.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\n\tcdd->ddev.dev = dev;\n\tINIT_LIST_HEAD(&cdd->ddev.channels);\n\tcpp41_dma_info.dma_cap = cdd->ddev.cap_mask;\n\n\tindex = of_property_match_string(dev->of_node,\n\t\t\t\t\t \"reg-names\", \"controller\");\n\tif (index < 0)\n\t\treturn index;\n\n\tcdd->ctrl_mem = devm_platform_ioremap_resource(pdev, index);\n\tif (IS_ERR(cdd->ctrl_mem))\n\t\treturn PTR_ERR(cdd->ctrl_mem);\n\n\tcdd->sched_mem = devm_platform_ioremap_resource(pdev, index + 1);\n\tif (IS_ERR(cdd->sched_mem))\n\t\treturn PTR_ERR(cdd->sched_mem);\n\n\tcdd->qmgr_mem = devm_platform_ioremap_resource(pdev, index + 2);\n\tif (IS_ERR(cdd->qmgr_mem))\n\t\treturn PTR_ERR(cdd->qmgr_mem);\n\n\tspin_lock_init(&cdd->lock);\n\tINIT_LIST_HEAD(&cdd->pending);\n\n\tplatform_set_drvdata(pdev, cdd);\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 100);\n\tpm_runtime_use_autosuspend(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tgoto err_get_sync;\n\n\tcdd->queues_rx = glue_info->queues_rx;\n\tcdd->queues_tx = glue_info->queues_tx;\n\tcdd->td_queue = glue_info->td_queue;\n\tcdd->qmgr_num_pend = glue_info->qmgr_num_pend;\n\tcdd->first_completion_queue = glue_info->first_completion_queue;\n\n\t \n\tret = of_property_read_u32(dev->of_node,\n\t\t\t\t   \"dma-channels\", &cdd->n_chans);\n\tif (ret)\n\t\tret = of_property_read_u32(dev->of_node,\n\t\t\t\t\t   \"#dma-channels\", &cdd->n_chans);\n\tif (ret)\n\t\tgoto err_get_n_chans;\n\n\tret = init_cppi41(dev, cdd);\n\tif (ret)\n\t\tgoto err_init_cppi;\n\n\tret = cppi41_add_chans(dev, cdd);\n\tif (ret)\n\t\tgoto err_chans;\n\n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq) {\n\t\tret = -EINVAL;\n\t\tgoto err_chans;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, cppi41_irq, IRQF_SHARED,\n\t\t\tdev_name(dev), cdd);\n\tif (ret)\n\t\tgoto err_chans;\n\tcdd->irq = irq;\n\n\tret = dma_async_device_register(&cdd->ddev);\n\tif (ret)\n\t\tgoto err_chans;\n\n\tret = of_dma_controller_register(dev->of_node,\n\t\t\tcppi41_dma_xlate, &cpp41_dma_info);\n\tif (ret)\n\t\tgoto err_of;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\nerr_of:\n\tdma_async_device_unregister(&cdd->ddev);\nerr_chans:\n\tdeinit_cppi41(dev, cdd);\nerr_init_cppi:\n\tpm_runtime_dont_use_autosuspend(dev);\nerr_get_n_chans:\nerr_get_sync:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int cppi41_dma_remove(struct platform_device *pdev)\n{\n\tstruct cppi41_dd *cdd = platform_get_drvdata(pdev);\n\tint error;\n\n\terror = pm_runtime_get_sync(&pdev->dev);\n\tif (error < 0)\n\t\tdev_err(&pdev->dev, \"%s could not pm_runtime_get: %i\\n\",\n\t\t\t__func__, error);\n\tof_dma_controller_free(pdev->dev.of_node);\n\tdma_async_device_unregister(&cdd->ddev);\n\n\tdevm_free_irq(&pdev->dev, cdd->irq, cdd);\n\tdeinit_cppi41(&pdev->dev, cdd);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused cppi41_suspend(struct device *dev)\n{\n\tstruct cppi41_dd *cdd = dev_get_drvdata(dev);\n\n\tcdd->dma_tdfdq = cppi_readl(cdd->ctrl_mem + DMA_TDFDQ);\n\tdisable_sched(cdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cppi41_resume(struct device *dev)\n{\n\tstruct cppi41_dd *cdd = dev_get_drvdata(dev);\n\tstruct cppi41_channel *c;\n\tint i;\n\n\tfor (i = 0; i < DESCS_AREAS; i++)\n\t\tcppi_writel(cdd->descs_phys, cdd->qmgr_mem + QMGR_MEMBASE(i));\n\n\tlist_for_each_entry(c, &cdd->ddev.channels, chan.device_node)\n\t\tif (!c->is_tx)\n\t\t\tcppi_writel(c->q_num, c->gcr_reg + RXHPCRA0);\n\n\tinit_sched(cdd);\n\n\tcppi_writel(cdd->dma_tdfdq, cdd->ctrl_mem + DMA_TDFDQ);\n\tcppi_writel(cdd->scratch_phys, cdd->qmgr_mem + QMGR_LRAM0_BASE);\n\tcppi_writel(QMGR_SCRATCH_SIZE, cdd->qmgr_mem + QMGR_LRAM_SIZE);\n\tcppi_writel(0, cdd->qmgr_mem + QMGR_LRAM1_BASE);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cppi41_runtime_suspend(struct device *dev)\n{\n\tstruct cppi41_dd *cdd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdd->lock, flags);\n\tcdd->is_suspended = true;\n\tWARN_ON(!list_empty(&cdd->pending));\n\tspin_unlock_irqrestore(&cdd->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cppi41_runtime_resume(struct device *dev)\n{\n\tstruct cppi41_dd *cdd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdd->lock, flags);\n\tcdd->is_suspended = false;\n\tcppi41_run_queue(cdd);\n\tspin_unlock_irqrestore(&cdd->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cppi41_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(cppi41_suspend, cppi41_resume)\n\tSET_RUNTIME_PM_OPS(cppi41_runtime_suspend,\n\t\t\t   cppi41_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver cpp41_dma_driver = {\n\t.probe  = cppi41_dma_probe,\n\t.remove = cppi41_dma_remove,\n\t.driver = {\n\t\t.name = \"cppi41-dma-engine\",\n\t\t.pm = &cppi41_pm_ops,\n\t\t.of_match_table = of_match_ptr(cppi41_dma_ids),\n\t},\n};\n\nmodule_platform_driver(cpp41_dma_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sebastian Andrzej Siewior <bigeasy@linutronix.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}