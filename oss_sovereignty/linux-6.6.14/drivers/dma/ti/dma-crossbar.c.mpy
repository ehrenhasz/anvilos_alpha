{
  "module_name": "dma-crossbar.c",
  "hash_id": "64f1e2e1fedaeb3c8c31b3e3355b5084d14a7e1187219f1e74db34602f46b07c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma/ti/dma-crossbar.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/of_platform.h>\n\n#define TI_XBAR_DRA7\t\t0\n#define TI_XBAR_AM335X\t\t1\nstatic const u32 ti_xbar_type[] = {\n\t[TI_XBAR_DRA7] = TI_XBAR_DRA7,\n\t[TI_XBAR_AM335X] = TI_XBAR_AM335X,\n};\n\nstatic const struct of_device_id ti_dma_xbar_match[] = {\n\t{\n\t\t.compatible = \"ti,dra7-dma-crossbar\",\n\t\t.data = &ti_xbar_type[TI_XBAR_DRA7],\n\t},\n\t{\n\t\t.compatible = \"ti,am335x-edma-crossbar\",\n\t\t.data = &ti_xbar_type[TI_XBAR_AM335X],\n\t},\n\t{},\n};\n\n \n#define TI_AM335X_XBAR_LINES\t64\n\nstruct ti_am335x_xbar_data {\n\tvoid __iomem *iomem;\n\n\tstruct dma_router dmarouter;\n\n\tu32 xbar_events;  \n\tu32 dma_requests;  \n};\n\nstruct ti_am335x_xbar_map {\n\tu16 dma_line;\n\tu8 mux_val;\n};\n\nstatic inline void ti_am335x_xbar_write(void __iomem *iomem, int event, u8 val)\n{\n\t \n\tif (event >= 60 && event <= 63)\n\t\twriteb_relaxed(val, iomem + (63 - event % 4));\n\telse\n\t\twriteb_relaxed(val, iomem + event);\n}\n\nstatic void ti_am335x_xbar_free(struct device *dev, void *route_data)\n{\n\tstruct ti_am335x_xbar_data *xbar = dev_get_drvdata(dev);\n\tstruct ti_am335x_xbar_map *map = route_data;\n\n\tdev_dbg(dev, \"Unmapping XBAR event %u on channel %u\\n\",\n\t\tmap->mux_val, map->dma_line);\n\n\tti_am335x_xbar_write(xbar->iomem, map->dma_line, 0);\n\tkfree(map);\n}\n\nstatic void *ti_am335x_xbar_route_allocate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t   struct of_dma *ofdma)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\n\tstruct ti_am335x_xbar_data *xbar = platform_get_drvdata(pdev);\n\tstruct ti_am335x_xbar_map *map;\n\n\tif (dma_spec->args_count != 3)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (dma_spec->args[2] >= xbar->xbar_events) {\n\t\tdev_err(&pdev->dev, \"Invalid XBAR event number: %d\\n\",\n\t\t\tdma_spec->args[2]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dma_spec->args[0] >= xbar->dma_requests) {\n\t\tdev_err(&pdev->dev, \"Invalid DMA request line number: %d\\n\",\n\t\t\tdma_spec->args[0]);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tdma_spec->np = of_parse_phandle(ofdma->of_node, \"dma-masters\", 0);\n\tif (!dma_spec->np) {\n\t\tdev_err(&pdev->dev, \"Can't get DMA master\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map) {\n\t\tof_node_put(dma_spec->np);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmap->dma_line = (u16)dma_spec->args[0];\n\tmap->mux_val = (u8)dma_spec->args[2];\n\n\tdma_spec->args[2] = 0;\n\tdma_spec->args_count = 2;\n\n\tdev_dbg(&pdev->dev, \"Mapping XBAR event%u to DMA%u\\n\",\n\t\tmap->mux_val, map->dma_line);\n\n\tti_am335x_xbar_write(xbar->iomem, map->dma_line, map->mux_val);\n\n\treturn map;\n}\n\nstatic const struct of_device_id ti_am335x_master_match[] __maybe_unused = {\n\t{ .compatible = \"ti,edma3-tpcc\", },\n\t{},\n};\n\nstatic int ti_am335x_xbar_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct device_node *dma_node;\n\tstruct ti_am335x_xbar_data *xbar;\n\tvoid __iomem *iomem;\n\tint i, ret;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\txbar = devm_kzalloc(&pdev->dev, sizeof(*xbar), GFP_KERNEL);\n\tif (!xbar)\n\t\treturn -ENOMEM;\n\n\tdma_node = of_parse_phandle(node, \"dma-masters\", 0);\n\tif (!dma_node) {\n\t\tdev_err(&pdev->dev, \"Can't get DMA master node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_node(ti_am335x_master_match, dma_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"DMA master is not supported\\n\");\n\t\tof_node_put(dma_node);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dma_node, \"dma-requests\",\n\t\t\t\t &xbar->dma_requests)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Missing XBAR output information, using %u.\\n\",\n\t\t\t TI_AM335X_XBAR_LINES);\n\t\txbar->dma_requests = TI_AM335X_XBAR_LINES;\n\t}\n\tof_node_put(dma_node);\n\n\tif (of_property_read_u32(node, \"dma-requests\", &xbar->xbar_events)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Missing XBAR input information, using %u.\\n\",\n\t\t\t TI_AM335X_XBAR_LINES);\n\t\txbar->xbar_events = TI_AM335X_XBAR_LINES;\n\t}\n\n\tiomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iomem))\n\t\treturn PTR_ERR(iomem);\n\n\txbar->iomem = iomem;\n\n\txbar->dmarouter.dev = &pdev->dev;\n\txbar->dmarouter.route_free = ti_am335x_xbar_free;\n\n\tplatform_set_drvdata(pdev, xbar);\n\n\t \n\tfor (i = 0; i < xbar->dma_requests; i++)\n\t\tti_am335x_xbar_write(xbar->iomem, i, 0);\n\n\tret = of_dma_router_register(node, ti_am335x_xbar_route_allocate,\n\t\t\t\t     &xbar->dmarouter);\n\n\treturn ret;\n}\n\n \n#define TI_DRA7_XBAR_OUTPUTS\t127\n#define TI_DRA7_XBAR_INPUTS\t256\n\nstruct ti_dra7_xbar_data {\n\tvoid __iomem *iomem;\n\n\tstruct dma_router dmarouter;\n\tstruct mutex mutex;\n\tunsigned long *dma_inuse;\n\n\tu16 safe_val;  \n\tu32 xbar_requests;  \n\tu32 dma_requests;  \n\tu32 dma_offset;\n};\n\nstruct ti_dra7_xbar_map {\n\tu16 xbar_in;\n\tint xbar_out;\n};\n\nstatic inline void ti_dra7_xbar_write(void __iomem *iomem, int xbar, u16 val)\n{\n\twritew_relaxed(val, iomem + (xbar * 2));\n}\n\nstatic void ti_dra7_xbar_free(struct device *dev, void *route_data)\n{\n\tstruct ti_dra7_xbar_data *xbar = dev_get_drvdata(dev);\n\tstruct ti_dra7_xbar_map *map = route_data;\n\n\tdev_dbg(dev, \"Unmapping XBAR%u (was routed to %d)\\n\",\n\t\tmap->xbar_in, map->xbar_out);\n\n\tti_dra7_xbar_write(xbar->iomem, map->xbar_out, xbar->safe_val);\n\tmutex_lock(&xbar->mutex);\n\tclear_bit(map->xbar_out, xbar->dma_inuse);\n\tmutex_unlock(&xbar->mutex);\n\tkfree(map);\n}\n\nstatic void *ti_dra7_xbar_route_allocate(struct of_phandle_args *dma_spec,\n\t\t\t\t\t struct of_dma *ofdma)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(ofdma->of_node);\n\tstruct ti_dra7_xbar_data *xbar = platform_get_drvdata(pdev);\n\tstruct ti_dra7_xbar_map *map;\n\n\tif (dma_spec->args[0] >= xbar->xbar_requests) {\n\t\tdev_err(&pdev->dev, \"Invalid XBAR request number: %d\\n\",\n\t\t\tdma_spec->args[0]);\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tdma_spec->np = of_parse_phandle(ofdma->of_node, \"dma-masters\", 0);\n\tif (!dma_spec->np) {\n\t\tdev_err(&pdev->dev, \"Can't get DMA master\\n\");\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map) {\n\t\tof_node_put(dma_spec->np);\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmutex_lock(&xbar->mutex);\n\tmap->xbar_out = find_first_zero_bit(xbar->dma_inuse,\n\t\t\t\t\t    xbar->dma_requests);\n\tif (map->xbar_out == xbar->dma_requests) {\n\t\tmutex_unlock(&xbar->mutex);\n\t\tdev_err(&pdev->dev, \"Run out of free DMA requests\\n\");\n\t\tkfree(map);\n\t\tof_node_put(dma_spec->np);\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tset_bit(map->xbar_out, xbar->dma_inuse);\n\tmutex_unlock(&xbar->mutex);\n\n\tmap->xbar_in = (u16)dma_spec->args[0];\n\n\tdma_spec->args[0] = map->xbar_out + xbar->dma_offset;\n\n\tdev_dbg(&pdev->dev, \"Mapping XBAR%u to DMA%d\\n\",\n\t\tmap->xbar_in, map->xbar_out);\n\n\tti_dra7_xbar_write(xbar->iomem, map->xbar_out, map->xbar_in);\n\n\treturn map;\n}\n\n#define TI_XBAR_EDMA_OFFSET\t0\n#define TI_XBAR_SDMA_OFFSET\t1\nstatic const u32 ti_dma_offset[] = {\n\t[TI_XBAR_EDMA_OFFSET] = 0,\n\t[TI_XBAR_SDMA_OFFSET] = 1,\n};\n\nstatic const struct of_device_id ti_dra7_master_match[] __maybe_unused = {\n\t{\n\t\t.compatible = \"ti,omap4430-sdma\",\n\t\t.data = &ti_dma_offset[TI_XBAR_SDMA_OFFSET],\n\t},\n\t{\n\t\t.compatible = \"ti,edma3\",\n\t\t.data = &ti_dma_offset[TI_XBAR_EDMA_OFFSET],\n\t},\n\t{\n\t\t.compatible = \"ti,edma3-tpcc\",\n\t\t.data = &ti_dma_offset[TI_XBAR_EDMA_OFFSET],\n\t},\n\t{},\n};\n\nstatic inline void ti_dra7_xbar_reserve(int offset, int len, unsigned long *p)\n{\n\tfor (; len > 0; len--)\n\t\tset_bit(offset + (len - 1), p);\n}\n\nstatic int ti_dra7_xbar_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct device_node *dma_node;\n\tstruct ti_dra7_xbar_data *xbar;\n\tstruct property *prop;\n\tu32 safe_val;\n\tint sz;\n\tvoid __iomem *iomem;\n\tint i, ret;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\txbar = devm_kzalloc(&pdev->dev, sizeof(*xbar), GFP_KERNEL);\n\tif (!xbar)\n\t\treturn -ENOMEM;\n\n\tdma_node = of_parse_phandle(node, \"dma-masters\", 0);\n\tif (!dma_node) {\n\t\tdev_err(&pdev->dev, \"Can't get DMA master node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_node(ti_dra7_master_match, dma_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"DMA master is not supported\\n\");\n\t\tof_node_put(dma_node);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dma_node, \"dma-requests\",\n\t\t\t\t &xbar->dma_requests)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Missing XBAR output information, using %u.\\n\",\n\t\t\t TI_DRA7_XBAR_OUTPUTS);\n\t\txbar->dma_requests = TI_DRA7_XBAR_OUTPUTS;\n\t}\n\tof_node_put(dma_node);\n\n\txbar->dma_inuse = devm_kcalloc(&pdev->dev,\n\t\t\t\t       BITS_TO_LONGS(xbar->dma_requests),\n\t\t\t\t       sizeof(unsigned long), GFP_KERNEL);\n\tif (!xbar->dma_inuse)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(node, \"dma-requests\", &xbar->xbar_requests)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Missing XBAR input information, using %u.\\n\",\n\t\t\t TI_DRA7_XBAR_INPUTS);\n\t\txbar->xbar_requests = TI_DRA7_XBAR_INPUTS;\n\t}\n\n\tif (!of_property_read_u32(node, \"ti,dma-safe-map\", &safe_val))\n\t\txbar->safe_val = (u16)safe_val;\n\n\n\tprop = of_find_property(node, \"ti,reserved-dma-request-ranges\", &sz);\n\tif (prop) {\n\t\tconst char pname[] = \"ti,reserved-dma-request-ranges\";\n\t\tu32 (*rsv_events)[2];\n\t\tsize_t nelm = sz / sizeof(*rsv_events);\n\t\tint i;\n\n\t\tif (!nelm)\n\t\t\treturn -EINVAL;\n\n\t\trsv_events = kcalloc(nelm, sizeof(*rsv_events), GFP_KERNEL);\n\t\tif (!rsv_events)\n\t\t\treturn -ENOMEM;\n\n\t\tret = of_property_read_u32_array(node, pname, (u32 *)rsv_events,\n\t\t\t\t\t\t nelm * 2);\n\t\tif (ret) {\n\t\t\tkfree(rsv_events);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < nelm; i++) {\n\t\t\tti_dra7_xbar_reserve(rsv_events[i][0], rsv_events[i][1],\n\t\t\t\t\t     xbar->dma_inuse);\n\t\t}\n\t\tkfree(rsv_events);\n\t}\n\n\tiomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iomem))\n\t\treturn PTR_ERR(iomem);\n\n\txbar->iomem = iomem;\n\n\txbar->dmarouter.dev = &pdev->dev;\n\txbar->dmarouter.route_free = ti_dra7_xbar_free;\n\txbar->dma_offset = *(u32 *)match->data;\n\n\tmutex_init(&xbar->mutex);\n\tplatform_set_drvdata(pdev, xbar);\n\n\t \n\tfor (i = 0; i < xbar->dma_requests; i++) {\n\t\tif (!test_bit(i, xbar->dma_inuse))\n\t\t\tti_dra7_xbar_write(xbar->iomem, i, xbar->safe_val);\n\t}\n\n\tret = of_dma_router_register(node, ti_dra7_xbar_route_allocate,\n\t\t\t\t     &xbar->dmarouter);\n\tif (ret) {\n\t\t \n\t\tfor (i = 0; i < xbar->dma_requests; i++) {\n\t\t\tif (!test_bit(i, xbar->dma_inuse))\n\t\t\t\tti_dra7_xbar_write(xbar->iomem, i, i);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_dma_xbar_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_node(ti_dma_xbar_match, pdev->dev.of_node);\n\tif (unlikely(!match))\n\t\treturn -EINVAL;\n\n\tswitch (*(u32 *)match->data) {\n\tcase TI_XBAR_DRA7:\n\t\tret = ti_dra7_xbar_probe(pdev);\n\t\tbreak;\n\tcase TI_XBAR_AM335X:\n\t\tret = ti_am335x_xbar_probe(pdev);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported crossbar\\n\");\n\t\tret = -ENODEV;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver ti_dma_xbar_driver = {\n\t.driver = {\n\t\t.name = \"ti-dma-crossbar\",\n\t\t.of_match_table = ti_dma_xbar_match,\n\t},\n\t.probe\t= ti_dma_xbar_probe,\n};\n\nstatic int omap_dmaxbar_init(void)\n{\n\treturn platform_driver_register(&ti_dma_xbar_driver);\n}\narch_initcall(omap_dmaxbar_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}