{
  "module_name": "windfarm_fcu_controls.c",
  "hash_id": "44b0c54d24075c4cd9e40db90493811514afff15f4995d25de82337c9325572e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_fcu_controls.c",
  "human_readable_source": "\n \n#undef DEBUG\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/i2c.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_mpu.h\"\n\n#define VERSION \"1.0\"\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n \n#define RPM_PID_USE_ACTUAL_SPEED\t0\n\n \n#define CPU_PUMP_OUTPUT_MAX\t\t3200\n#define CPU_PUMP_OUTPUT_MIN\t\t1250\n\n#define FCU_FAN_RPM\t\t0\n#define FCU_FAN_PWM\t\t1\n\nstruct wf_fcu_priv {\n\tstruct kref\t\tref;\n\tstruct i2c_client\t*i2c;\n\tstruct mutex\t\tlock;\n\tstruct list_head\tfan_list;\n\tint\t\t\trpm_shift;\n};\n\nstruct wf_fcu_fan {\n\tstruct list_head\tlink;\n\tint\t\t\tid;\n\ts32\t\t\tmin, max, target;\n\tstruct wf_fcu_priv\t*fcu_priv;\n\tstruct wf_control\tctrl;\n};\n\nstatic void wf_fcu_release(struct kref *ref)\n{\n\tstruct wf_fcu_priv *pv = container_of(ref, struct wf_fcu_priv, ref);\n\n\tkfree(pv);\n}\n\nstatic void wf_fcu_fan_release(struct wf_control *ct)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\n\tkref_put(&fan->fcu_priv->ref, wf_fcu_release);\n\tkfree(fan);\n}\n\nstatic int wf_fcu_read_reg(struct wf_fcu_priv *pv, int reg,\n\t\t\t   unsigned char *buf, int nb)\n{\n\tint tries, nr, nw;\n\n\tmutex_lock(&pv->lock);\n\n\tbuf[0] = reg;\n\ttries = 0;\n\tfor (;;) {\n\t\tnw = i2c_master_send(pv->i2c, buf, 1);\n\t\tif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t\t++tries;\n\t}\n\tif (nw <= 0) {\n\t\tpr_err(\"Failure writing address to FCU: %d\", nw);\n\t\tnr = nw;\n\t\tgoto bail;\n\t}\n\ttries = 0;\n\tfor (;;) {\n\t\tnr = i2c_master_recv(pv->i2c, buf, nb);\n\t\tif (nr > 0 || (nr < 0 && nr != -ENODEV) || tries >= 100)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t\t++tries;\n\t}\n\tif (nr <= 0)\n\t\tpr_err(\"wf_fcu: Failure reading data from FCU: %d\", nw);\n bail:\n\tmutex_unlock(&pv->lock);\n\treturn nr;\n}\n\nstatic int wf_fcu_write_reg(struct wf_fcu_priv *pv, int reg,\n\t\t\t    const unsigned char *ptr, int nb)\n{\n\tint tries, nw;\n\tunsigned char buf[16];\n\n\tbuf[0] = reg;\n\tmemcpy(buf+1, ptr, nb);\n\t++nb;\n\ttries = 0;\n\tfor (;;) {\n\t\tnw = i2c_master_send(pv->i2c, buf, nb);\n\t\tif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t\t++tries;\n\t}\n\tif (nw < 0)\n\t\tpr_err(\"wf_fcu: Failure writing to FCU: %d\", nw);\n\treturn nw;\n}\n\nstatic int wf_fcu_fan_set_rpm(struct wf_control *ct, s32 value)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\tstruct wf_fcu_priv *pv = fan->fcu_priv;\n\tint rc, shift = pv->rpm_shift;\n\tunsigned char buf[2];\n\n\tif (value < fan->min)\n\t\tvalue = fan->min;\n\tif (value > fan->max)\n\t\tvalue = fan->max;\n\n\tfan->target = value;\n\n\tbuf[0] = value >> (8 - shift);\n\tbuf[1] = value << shift;\n\trc = wf_fcu_write_reg(pv, 0x10 + (fan->id * 2), buf, 2);\n\tif (rc < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int wf_fcu_fan_get_rpm(struct wf_control *ct, s32 *value)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\tstruct wf_fcu_priv *pv = fan->fcu_priv;\n\tint rc, reg_base, shift = pv->rpm_shift;\n\tunsigned char failure;\n\tunsigned char active;\n\tunsigned char buf[2];\n\n\trc = wf_fcu_read_reg(pv, 0xb, &failure, 1);\n\tif (rc != 1)\n\t\treturn -EIO;\n\tif ((failure & (1 << fan->id)) != 0)\n\t\treturn -EFAULT;\n\trc = wf_fcu_read_reg(pv, 0xd, &active, 1);\n\tif (rc != 1)\n\t\treturn -EIO;\n\tif ((active & (1 << fan->id)) == 0)\n\t\treturn -ENXIO;\n\n\t \n#if RPM_PID_USE_ACTUAL_SPEED\n\treg_base = 0x11;\n#else\n\treg_base = 0x10;\n#endif\n\trc = wf_fcu_read_reg(pv, reg_base + (fan->id * 2), buf, 2);\n\tif (rc != 2)\n\t\treturn -EIO;\n\n\t*value = (buf[0] << (8 - shift)) | buf[1] >> shift;\n\n\treturn 0;\n}\n\nstatic int wf_fcu_fan_set_pwm(struct wf_control *ct, s32 value)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\tstruct wf_fcu_priv *pv = fan->fcu_priv;\n\tunsigned char buf[2];\n\tint rc;\n\n\tif (value < fan->min)\n\t\tvalue = fan->min;\n\tif (value > fan->max)\n\t\tvalue = fan->max;\n\n\tfan->target = value;\n\n\tvalue = (value * 2559) / 1000;\n\tbuf[0] = value;\n\trc = wf_fcu_write_reg(pv, 0x30 + (fan->id * 2), buf, 1);\n\tif (rc < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int wf_fcu_fan_get_pwm(struct wf_control *ct, s32 *value)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\tstruct wf_fcu_priv *pv = fan->fcu_priv;\n\tunsigned char failure;\n\tunsigned char active;\n\tunsigned char buf[2];\n\tint rc;\n\n\trc = wf_fcu_read_reg(pv, 0x2b, &failure, 1);\n\tif (rc != 1)\n\t\treturn -EIO;\n\tif ((failure & (1 << fan->id)) != 0)\n\t\treturn -EFAULT;\n\trc = wf_fcu_read_reg(pv, 0x2d, &active, 1);\n\tif (rc != 1)\n\t\treturn -EIO;\n\tif ((active & (1 << fan->id)) == 0)\n\t\treturn -ENXIO;\n\n\trc = wf_fcu_read_reg(pv, 0x30 + (fan->id * 2), buf, 1);\n\tif (rc != 1)\n\t\treturn -EIO;\n\n\t*value = (((s32)buf[0]) * 1000) / 2559;\n\n\treturn 0;\n}\n\nstatic s32 wf_fcu_fan_min(struct wf_control *ct)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\n\treturn fan->min;\n}\n\nstatic s32 wf_fcu_fan_max(struct wf_control *ct)\n{\n\tstruct wf_fcu_fan *fan = ct->priv;\n\n\treturn fan->max;\n}\n\nstatic const struct wf_control_ops wf_fcu_fan_rpm_ops = {\n\t.set_value\t= wf_fcu_fan_set_rpm,\n\t.get_value\t= wf_fcu_fan_get_rpm,\n\t.get_min\t= wf_fcu_fan_min,\n\t.get_max\t= wf_fcu_fan_max,\n\t.release\t= wf_fcu_fan_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct wf_control_ops wf_fcu_fan_pwm_ops = {\n\t.set_value\t= wf_fcu_fan_set_pwm,\n\t.get_value\t= wf_fcu_fan_get_pwm,\n\t.get_min\t= wf_fcu_fan_min,\n\t.get_max\t= wf_fcu_fan_max,\n\t.release\t= wf_fcu_fan_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void wf_fcu_get_pump_minmax(struct wf_fcu_fan *fan)\n{\n\tconst struct mpu_data *mpu = wf_get_mpu(0);\n\tu16 pump_min = 0, pump_max = 0xffff;\n\tu16 tmp[4];\n\n\t \n\tif (mpu) {\n\t\tmemcpy(&tmp, mpu->processor_part_num, 8);\n\t\tif (tmp[0] != 0xffff && tmp[1] != 0xffff) {\n\t\t\tpump_min = max(pump_min, tmp[0]);\n\t\t\tpump_max = min(pump_max, tmp[1]);\n\t\t}\n\t\tif (tmp[2] != 0xffff && tmp[3] != 0xffff) {\n\t\t\tpump_min = max(pump_min, tmp[2]);\n\t\t\tpump_max = min(pump_max, tmp[3]);\n\t\t}\n\t}\n\n\t \n\tif (pump_min == pump_max || pump_min == 0 || pump_max == 0xffff) {\n\t\tpump_min = CPU_PUMP_OUTPUT_MIN;\n\t\tpump_max = CPU_PUMP_OUTPUT_MAX;\n\t}\n\n\tfan->min = pump_min;\n\tfan->max = pump_max;\n\n\tDBG(\"wf_fcu: pump min/max for %s set to: [%d..%d] RPM\\n\",\n\t    fan->ctrl.name, pump_min, pump_max);\n}\n\nstatic void wf_fcu_get_rpmfan_minmax(struct wf_fcu_fan *fan)\n{\n\tstruct wf_fcu_priv *pv = fan->fcu_priv;\n\tconst struct mpu_data *mpu0 = wf_get_mpu(0);\n\tconst struct mpu_data *mpu1 = wf_get_mpu(1);\n\n\t \n\tfan->min = 2400 >> pv->rpm_shift;\n\tfan->max = 56000 >> pv->rpm_shift;\n\n\t \n\tif (mpu0 && !strcmp(fan->ctrl.name, \"cpu-front-fan-0\")) {\n\t\tfan->min = max(fan->min, (s32)mpu0->rminn_intake_fan);\n\t\tfan->max = min(fan->max, (s32)mpu0->rmaxn_intake_fan);\n\t\tgoto bail;\n\t}\n\tif (mpu1 && !strcmp(fan->ctrl.name, \"cpu-front-fan-1\")) {\n\t\tfan->min = max(fan->min, (s32)mpu1->rminn_intake_fan);\n\t\tfan->max = min(fan->max, (s32)mpu1->rmaxn_intake_fan);\n\t\tgoto bail;\n\t}\n\tif (mpu0 && !strcmp(fan->ctrl.name, \"cpu-rear-fan-0\")) {\n\t\tfan->min = max(fan->min, (s32)mpu0->rminn_exhaust_fan);\n\t\tfan->max = min(fan->max, (s32)mpu0->rmaxn_exhaust_fan);\n\t\tgoto bail;\n\t}\n\tif (mpu1 && !strcmp(fan->ctrl.name, \"cpu-rear-fan-1\")) {\n\t\tfan->min = max(fan->min, (s32)mpu1->rminn_exhaust_fan);\n\t\tfan->max = min(fan->max, (s32)mpu1->rmaxn_exhaust_fan);\n\t\tgoto bail;\n\t}\n\t \n\tif (!strncmp(fan->ctrl.name, \"cpu-fan\", 7)) {\n\t\tfan->min = max(fan->min, (s32)mpu0->rminn_intake_fan);\n\t\tfan->max = min(fan->max, (s32)mpu0->rmaxn_intake_fan);\n\t\tgoto bail;\n\t}\n bail:\n\tDBG(\"wf_fcu: fan min/max for %s set to: [%d..%d] RPM\\n\",\n\t    fan->ctrl.name, fan->min, fan->max);\n}\n\nstatic void wf_fcu_add_fan(struct wf_fcu_priv *pv, const char *name,\n\t\t\t   int type, int id)\n{\n\tstruct wf_fcu_fan *fan;\n\n\tfan = kzalloc(sizeof(*fan), GFP_KERNEL);\n\tif (!fan)\n\t\treturn;\n\tfan->fcu_priv = pv;\n\tfan->id = id;\n\tfan->ctrl.name = name;\n\tfan->ctrl.priv = fan;\n\n\t \n\tif (type == FCU_FAN_RPM) {\n\t\tif (!strncmp(name, \"cpu-pump\", strlen(\"cpu-pump\")))\n\t\t\twf_fcu_get_pump_minmax(fan);\n\t\telse\n\t\t\twf_fcu_get_rpmfan_minmax(fan);\n\t\tfan->ctrl.type = WF_CONTROL_RPM_FAN;\n\t\tfan->ctrl.ops = &wf_fcu_fan_rpm_ops;\n\t} else {\n\t\tfan->min = 10;\n\t\tfan->max = 100;\n\t\tfan->ctrl.type = WF_CONTROL_PWM_FAN;\n\t\tfan->ctrl.ops = &wf_fcu_fan_pwm_ops;\n\t}\n\n\tif (wf_register_control(&fan->ctrl)) {\n\t\tpr_err(\"wf_fcu: Failed to register fan %s\\n\", name);\n\t\tkfree(fan);\n\t\treturn;\n\t}\n\tlist_add(&fan->link, &pv->fan_list);\n\tkref_get(&pv->ref);\n}\n\nstatic void wf_fcu_lookup_fans(struct wf_fcu_priv *pv)\n{\n\t \n\tstatic const struct {\n\t\tconst char *dt_name;\t \n\t\tconst char *ct_name;\t \n\t} loc_trans[] = {\n\t\t{ \"BACKSIDE\",\t\t\"backside-fan\",\t\t},\n\t\t{ \"SYS CTRLR FAN\",\t\"backside-fan\",\t\t},\n\t\t{ \"DRIVE BAY\",\t\t\"drive-bay-fan\",\t},\n\t\t{ \"SLOT\",\t\t\"slots-fan\",\t\t},\n\t\t{ \"PCI FAN\",\t\t\"slots-fan\",\t\t},\n\t\t{ \"CPU A INTAKE\",\t\"cpu-front-fan-0\",\t},\n\t\t{ \"CPU A EXHAUST\",\t\"cpu-rear-fan-0\",\t},\n\t\t{ \"CPU B INTAKE\",\t\"cpu-front-fan-1\",\t},\n\t\t{ \"CPU B EXHAUST\",\t\"cpu-rear-fan-1\",\t},\n\t\t{ \"CPU A PUMP\",\t\t\"cpu-pump-0\",\t\t},\n\t\t{ \"CPU B PUMP\",\t\t\"cpu-pump-1\",\t\t},\n\t\t{ \"CPU A 1\",\t\t\"cpu-fan-a-0\",\t\t},\n\t\t{ \"CPU A 2\",\t\t\"cpu-fan-b-0\",\t\t},\n\t\t{ \"CPU A 3\",\t\t\"cpu-fan-c-0\",\t\t},\n\t\t{ \"CPU B 1\",\t\t\"cpu-fan-a-1\",\t\t},\n\t\t{ \"CPU B 2\",\t\t\"cpu-fan-b-1\",\t\t},\n\t\t{ \"CPU B 3\",\t\t\"cpu-fan-c-1\",\t\t},\n\t};\n\tstruct device_node *np, *fcu = pv->i2c->dev.of_node;\n\tint i;\n\n\tDBG(\"Looking up FCU controls in device-tree...\\n\");\n\n\tfor_each_child_of_node(fcu, np) {\n\t\tint id, type = -1;\n\t\tconst char *loc;\n\t\tconst char *name;\n\t\tconst u32 *reg;\n\n\t\tDBG(\" control: %pOFn, type: %s\\n\", np, of_node_get_device_type(np));\n\n\t\t \n\t\tif (of_node_is_type(np, \"fan-rpm-control\") ||\n\t\t    of_node_is_type(np, \"fan-rpm\"))\n\t\t\ttype = FCU_FAN_RPM;\n\t\tif (of_node_is_type(np, \"fan-pwm-control\") ||\n\t\t    of_node_is_type(np, \"fan-pwm\"))\n\t\t\ttype = FCU_FAN_PWM;\n\t\t \n\t\tif (type == -1)\n\t\t\tcontinue;\n\n\t\t \n\t\tloc = of_get_property(np, \"location\", NULL);\n\t\treg = of_get_property(np, \"reg\", NULL);\n\t\tif (loc == NULL || reg == NULL)\n\t\t\tcontinue;\n\t\tDBG(\" matching location: %s, reg: 0x%08x\\n\", loc, *reg);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(loc_trans); i++) {\n\t\t\tif (strncmp(loc, loc_trans[i].dt_name,\n\t\t\t\t    strlen(loc_trans[i].dt_name)))\n\t\t\t\tcontinue;\n\t\t\tname = loc_trans[i].ct_name;\n\n\t\t\tDBG(\" location match, name: %s\\n\", name);\n\n\t\t\tif (type == FCU_FAN_RPM)\n\t\t\t\tid = ((*reg) - 0x10) / 2;\n\t\t\telse\n\t\t\t\tid = ((*reg) - 0x30) / 2;\n\t\t\tif (id > 7) {\n\t\t\t\tpr_warn(\"wf_fcu: Can't parse fan ID in device-tree for %pOF\\n\", np);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twf_fcu_add_fan(pv, name, type, id);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void wf_fcu_default_fans(struct wf_fcu_priv *pv)\n{\n\t \n\tif (!of_machine_is_compatible(\"PowerMac7,2\"))\n\t\treturn;\n\n\twf_fcu_add_fan(pv, \"backside-fan\",\tFCU_FAN_PWM, 1);\n\twf_fcu_add_fan(pv, \"drive-bay-fan\",\tFCU_FAN_RPM, 2);\n\twf_fcu_add_fan(pv, \"slots-fan\",\t\tFCU_FAN_PWM, 2);\n\twf_fcu_add_fan(pv, \"cpu-front-fan-0\",\tFCU_FAN_RPM, 3);\n\twf_fcu_add_fan(pv, \"cpu-rear-fan-0\",\tFCU_FAN_RPM, 4);\n\twf_fcu_add_fan(pv, \"cpu-front-fan-1\",\tFCU_FAN_RPM, 5);\n\twf_fcu_add_fan(pv, \"cpu-rear-fan-1\",\tFCU_FAN_RPM, 6);\n}\n\nstatic int wf_fcu_init_chip(struct wf_fcu_priv *pv)\n{\n\tunsigned char buf = 0xff;\n\tint rc;\n\n\trc = wf_fcu_write_reg(pv, 0xe, &buf, 1);\n\tif (rc < 0)\n\t\treturn -EIO;\n\trc = wf_fcu_write_reg(pv, 0x2e, &buf, 1);\n\tif (rc < 0)\n\t\treturn -EIO;\n\trc = wf_fcu_read_reg(pv, 0, &buf, 1);\n\tif (rc < 0)\n\t\treturn -EIO;\n\tpv->rpm_shift = (buf == 1) ? 2 : 3;\n\n\tpr_debug(\"wf_fcu: FCU Initialized, RPM fan shift is %d\\n\",\n\t\t pv->rpm_shift);\n\n\treturn 0;\n}\n\nstatic int wf_fcu_probe(struct i2c_client *client)\n{\n\tstruct wf_fcu_priv *pv;\n\n\tpv = kzalloc(sizeof(*pv), GFP_KERNEL);\n\tif (!pv)\n\t\treturn -ENOMEM;\n\n\tkref_init(&pv->ref);\n\tmutex_init(&pv->lock);\n\tINIT_LIST_HEAD(&pv->fan_list);\n\tpv->i2c = client;\n\n\t \n\tif (wf_fcu_init_chip(pv)) {\n\t\tpr_err(\"wf_fcu: Initialization failed !\\n\");\n\t\tkfree(pv);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\twf_fcu_lookup_fans(pv);\n\n\t \n\tif (list_empty(&pv->fan_list))\n\t\twf_fcu_default_fans(pv);\n\n\t \n\tif (list_empty(&pv->fan_list)) {\n\t\tpr_err(\"wf_fcu: Failed to find fans for your machine\\n\");\n\t\tkfree(pv);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_set_drvdata(&client->dev, pv);\n\n\treturn 0;\n}\n\nstatic void wf_fcu_remove(struct i2c_client *client)\n{\n\tstruct wf_fcu_priv *pv = dev_get_drvdata(&client->dev);\n\tstruct wf_fcu_fan *fan;\n\n\twhile (!list_empty(&pv->fan_list)) {\n\t\tfan = list_first_entry(&pv->fan_list, struct wf_fcu_fan, link);\n\t\tlist_del(&fan->link);\n\t\twf_unregister_control(&fan->ctrl);\n\t}\n\tkref_put(&pv->ref, wf_fcu_release);\n}\n\nstatic const struct i2c_device_id wf_fcu_id[] = {\n\t{ \"MAC,fcu\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wf_fcu_id);\n\nstatic const struct of_device_id wf_fcu_of_id[] = {\n\t{ .compatible = \"fcu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wf_fcu_of_id);\n\nstatic struct i2c_driver wf_fcu_driver = {\n\t.driver = {\n\t\t.name\t= \"wf_fcu\",\n\t\t.of_match_table = wf_fcu_of_id,\n\t},\n\t.probe\t\t= wf_fcu_probe,\n\t.remove\t\t= wf_fcu_remove,\n\t.id_table\t= wf_fcu_id,\n};\n\nmodule_i2c_driver(wf_fcu_driver);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"FCU control objects for PowerMacs thermal control\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}