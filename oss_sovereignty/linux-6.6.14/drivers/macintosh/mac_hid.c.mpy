{
  "module_name": "mac_hid.c",
  "hash_id": "3c87dafb769feababcc76f62422aa8d6e4c4cf38000c653f2b3ba0264bf067f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/mac_hid.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int mouse_emulate_buttons;\nstatic int mouse_button2_keycode = KEY_RIGHTCTRL;\t \nstatic int mouse_button3_keycode = KEY_RIGHTALT;\t \n\nstatic struct input_dev *mac_hid_emumouse_dev;\n\nstatic DEFINE_MUTEX(mac_hid_emumouse_mutex);\n\nstatic int mac_hid_create_emumouse(void)\n{\n\tstatic struct lock_class_key mac_hid_emumouse_dev_event_class;\n\tstatic struct lock_class_key mac_hid_emumouse_dev_mutex_class;\n\tint err;\n\n\tmac_hid_emumouse_dev = input_allocate_device();\n\tif (!mac_hid_emumouse_dev)\n\t\treturn -ENOMEM;\n\n\tlockdep_set_class(&mac_hid_emumouse_dev->event_lock,\n\t\t\t  &mac_hid_emumouse_dev_event_class);\n\tlockdep_set_class(&mac_hid_emumouse_dev->mutex,\n\t\t\t  &mac_hid_emumouse_dev_mutex_class);\n\n\tmac_hid_emumouse_dev->name = \"Macintosh mouse button emulation\";\n\tmac_hid_emumouse_dev->id.bustype = BUS_ADB;\n\tmac_hid_emumouse_dev->id.vendor = 0x0001;\n\tmac_hid_emumouse_dev->id.product = 0x0001;\n\tmac_hid_emumouse_dev->id.version = 0x0100;\n\n\tmac_hid_emumouse_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tmac_hid_emumouse_dev->keybit[BIT_WORD(BTN_MOUSE)] =\n\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\n\tmac_hid_emumouse_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\n\terr = input_register_device(mac_hid_emumouse_dev);\n\tif (err) {\n\t\tinput_free_device(mac_hid_emumouse_dev);\n\t\tmac_hid_emumouse_dev = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mac_hid_destroy_emumouse(void)\n{\n\tinput_unregister_device(mac_hid_emumouse_dev);\n\tmac_hid_emumouse_dev = NULL;\n}\n\nstatic bool mac_hid_emumouse_filter(struct input_handle *handle,\n\t\t\t\t    unsigned int type, unsigned int code,\n\t\t\t\t    int value)\n{\n\tunsigned int btn;\n\n\tif (type != EV_KEY)\n\t\treturn false;\n\n\tif (code == mouse_button2_keycode)\n\t\tbtn = BTN_MIDDLE;\n\telse if (code == mouse_button3_keycode)\n\t\tbtn = BTN_RIGHT;\n\telse\n\t\treturn false;\n\n\tinput_report_key(mac_hid_emumouse_dev, btn, value);\n\tinput_sync(mac_hid_emumouse_dev);\n\n\treturn true;\n}\n\nstatic int mac_hid_emumouse_connect(struct input_handler *handler,\n\t\t\t\t    struct input_dev *dev,\n\t\t\t\t    const struct input_device_id *id)\n{\n\tstruct input_handle *handle;\n\tint error;\n\n\t \n\tif (dev == mac_hid_emumouse_dev)\n\t\treturn -ENODEV;\n\n\thandle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\thandle->dev = dev;\n\thandle->handler = handler;\n\thandle->name = \"mac-button-emul\";\n\n\terror = input_register_handle(handle);\n\tif (error) {\n\t\tprintk(KERN_ERR\n\t\t\t\"mac_hid: Failed to register button emulation handle, \"\n\t\t\t\"error %d\\n\", error);\n\t\tgoto err_free;\n\t}\n\n\terror = input_open_device(handle);\n\tif (error) {\n\t\tprintk(KERN_ERR\n\t\t\t\"mac_hid: Failed to open input device, error %d\\n\",\n\t\t\terror);\n\t\tgoto err_unregister;\n\t}\n\n\treturn 0;\n\n err_unregister:\n\tinput_unregister_handle(handle);\n err_free:\n\tkfree(handle);\n\treturn error;\n}\n\nstatic void mac_hid_emumouse_disconnect(struct input_handle *handle)\n{\n\tinput_close_device(handle);\n\tinput_unregister_handle(handle);\n\tkfree(handle);\n}\n\nstatic const struct input_device_id mac_hid_emumouse_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(input, mac_hid_emumouse_ids);\n\nstatic struct input_handler mac_hid_emumouse_handler = {\n\t.filter\t\t= mac_hid_emumouse_filter,\n\t.connect\t= mac_hid_emumouse_connect,\n\t.disconnect\t= mac_hid_emumouse_disconnect,\n\t.name\t\t= \"mac-button-emul\",\n\t.id_table\t= mac_hid_emumouse_ids,\n};\n\nstatic int mac_hid_start_emulation(void)\n{\n\tint err;\n\n\terr = mac_hid_create_emumouse();\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_handler(&mac_hid_emumouse_handler);\n\tif (err) {\n\t\tmac_hid_destroy_emumouse();\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mac_hid_stop_emulation(void)\n{\n\tinput_unregister_handler(&mac_hid_emumouse_handler);\n\tmac_hid_destroy_emumouse();\n}\n\nstatic int mac_hid_toggle_emumouse(struct ctl_table *table, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint old_val = *valp;\n\tint rc;\n\n\trc = mutex_lock_killable(&mac_hid_emumouse_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (rc == 0 && write && *valp != old_val) {\n\t\tif (*valp == 1)\n\t\t\trc = mac_hid_start_emulation();\n\t\telse if (*valp == 0)\n\t\t\tmac_hid_stop_emulation();\n\t\telse\n\t\t\trc = -EINVAL;\n\t}\n\n\t \n\tif (rc)\n\t\t*valp = old_val;\n\n\tmutex_unlock(&mac_hid_emumouse_mutex);\n\n\treturn rc;\n}\n\n \nstatic struct ctl_table mac_hid_files[] = {\n\t{\n\t\t.procname\t= \"mouse_button_emulation\",\n\t\t.data\t\t= &mouse_emulate_buttons,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mac_hid_toggle_emumouse,\n\t},\n\t{\n\t\t.procname\t= \"mouse_button2_keycode\",\n\t\t.data\t\t= &mouse_button2_keycode,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"mouse_button3_keycode\",\n\t\t.data\t\t= &mouse_button3_keycode,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table_header *mac_hid_sysctl_header;\n\nstatic int __init mac_hid_init(void)\n{\n\tmac_hid_sysctl_header = register_sysctl(\"dev/mac_hid\", mac_hid_files);\n\tif (!mac_hid_sysctl_header)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nmodule_init(mac_hid_init);\n\nstatic void __exit mac_hid_exit(void)\n{\n\tunregister_sysctl_table(mac_hid_sysctl_header);\n\n\tif (mouse_emulate_buttons)\n\t\tmac_hid_stop_emulation();\n}\nmodule_exit(mac_hid_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}