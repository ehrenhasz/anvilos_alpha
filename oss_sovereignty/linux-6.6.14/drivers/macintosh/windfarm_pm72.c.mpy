{
  "module_name": "windfarm_pm72.c",
  "hash_id": "41558e6f1c6dc8d5bcd30678f0ce670a0b2667750fd8cbeb5f9174e0621dc93f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_pm72.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_pid.h\"\n#include \"windfarm_mpu.h\"\n\n#define VERSION \"1.0\"\n\n#undef DEBUG\n#undef LOTSA_DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n#ifdef LOTSA_DEBUG\n#define DBG_LOTS(args...)\tprintk(args)\n#else\n#define DBG_LOTS(args...)\tdo { } while(0)\n#endif\n\n \n#undef HACKED_OVERTEMP\n\n \n#define NR_CHIPS\t2\n#define NR_CPU_FANS\t3 * NR_CHIPS\n\n \nstatic struct wf_sensor *sens_cpu_temp[NR_CHIPS];\nstatic struct wf_sensor *sens_cpu_volts[NR_CHIPS];\nstatic struct wf_sensor *sens_cpu_amps[NR_CHIPS];\nstatic struct wf_sensor *backside_temp;\nstatic struct wf_sensor *drives_temp;\n\nstatic struct wf_control *cpu_front_fans[NR_CHIPS];\nstatic struct wf_control *cpu_rear_fans[NR_CHIPS];\nstatic struct wf_control *cpu_pumps[NR_CHIPS];\nstatic struct wf_control *backside_fan;\nstatic struct wf_control *drives_fan;\nstatic struct wf_control *slots_fan;\nstatic struct wf_control *cpufreq_clamp;\n\n \n#define CPU_TEMP_HIST_SIZE\t180\n\n \n#define\tSLOTS_FAN_DEFAULT_PWM\t40\n\n \n#define CPU_INTAKE_SCALE\t0x0000f852\n\n \nstatic const struct mpu_data *cpu_mpu_data[NR_CHIPS];\nstatic struct wf_cpu_pid_state cpu_pid[NR_CHIPS];\nstatic bool cpu_pid_combined;\nstatic u32 cpu_thist[CPU_TEMP_HIST_SIZE];\nstatic int cpu_thist_pt;\nstatic s64 cpu_thist_total;\nstatic s32 cpu_all_tmax = 100 << 16;\nstatic struct wf_pid_state backside_pid;\nstatic int backside_tick;\nstatic struct wf_pid_state drives_pid;\nstatic int drives_tick;\n\nstatic int nr_chips;\nstatic bool have_all_controls;\nstatic bool have_all_sensors;\nstatic bool started;\n\nstatic int failure_state;\n#define FAILURE_SENSOR\t\t1\n#define FAILURE_FAN\t\t2\n#define FAILURE_PERM\t\t4\n#define FAILURE_LOW_OVERTEMP\t8\n#define FAILURE_HIGH_OVERTEMP\t16\n\n \n#define LOW_OVER_AVERAGE\t0\n#define LOW_OVER_IMMEDIATE\t(10 << 16)\n#define LOW_OVER_CLEAR\t\t((-10) << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n#define HIGH_OVER_AVERAGE\t(10 << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n\n\nstatic void cpu_max_all_fans(void)\n{\n\tint i;\n\n\t \n\tif (cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tfor (i = 0; i < nr_chips; i++) {\n\t\tif (cpu_front_fans[i])\n\t\t\twf_control_set_max(cpu_front_fans[i]);\n\t\tif (cpu_rear_fans[i])\n\t\t\twf_control_set_max(cpu_rear_fans[i]);\n\t\tif (cpu_pumps[i])\n\t\t\twf_control_set_max(cpu_pumps[i]);\n\t}\n}\n\nstatic int cpu_check_overtemp(s32 temp)\n{\n\tint new_state = 0;\n\ts32 t_avg, t_old;\n\tstatic bool first = true;\n\n\t \n\tif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to immediate CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" immediate CPU temperature !\\n\");\n\t}\n\n\t \n\tif (first) {\n\t\tint i;\n\n\t\tcpu_thist_total = 0;\n\t\tfor (i = 0; i < CPU_TEMP_HIST_SIZE; i++) {\n\t\t\tcpu_thist[i] = temp;\n\t\t\tcpu_thist_total += temp;\n\t\t}\n\t\tfirst = false;\n\t}\n\n\t \n\tt_old = cpu_thist[cpu_thist_pt];\n\tcpu_thist[cpu_thist_pt] = temp;\n\tcpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\n\tcpu_thist_total -= t_old;\n\tcpu_thist_total += temp;\n\tt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\n\n\tDBG_LOTS(\"  t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\\n\",\n\t\t FIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\n\n\t \n\tif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to average CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" average CPU temperature !\\n\");\n\t}\n\n\t \n\tif (new_state) {\n\t\t \n\t\tif (new_state & FAILURE_HIGH_OVERTEMP)\n\t\t\tmachine_power_off();\n\t\tif ((failure_state & new_state) != new_state)\n\t\t\tcpu_max_all_fans();\n\t\tfailure_state |= new_state;\n\t} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\n\t\t   (temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\n\t\tprintk(KERN_ERR \"windfarm: Overtemp condition cleared !\\n\");\n\t\tfailure_state &= ~FAILURE_LOW_OVERTEMP;\n\t}\n\n\treturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\n}\n\nstatic int read_one_cpu_vals(int cpu, s32 *temp, s32 *power)\n{\n\ts32 dtemp, volts, amps;\n\tint rc;\n\n\t \n\trc = wf_sensor_get(sens_cpu_temp[cpu], &dtemp);\n\tif (rc) {\n\t\tDBG(\"  CPU%d: temp reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: temp   = %d.%03d\\n\", cpu, FIX32TOPRINT((dtemp)));\n\t*temp = dtemp;\n\n\t \n\trc = wf_sensor_get(sens_cpu_volts[cpu], &volts);\n\tif (rc) {\n\t\tDBG(\"  CPU%d, volts reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: volts  = %d.%03d\\n\", cpu, FIX32TOPRINT((volts)));\n\n\t \n\trc = wf_sensor_get(sens_cpu_amps[cpu], &amps);\n\tif (rc) {\n\t\tDBG(\"  CPU%d, current reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: amps   = %d.%03d\\n\", cpu, FIX32TOPRINT((amps)));\n\n\t \n\n\t \n\t*power = (((u64)volts) * ((u64)amps)) >> 16;\n\n\tDBG_LOTS(\"  CPU%d: power  = %d.%03d\\n\", cpu, FIX32TOPRINT((*power)));\n\n\treturn 0;\n\n}\n\nstatic void cpu_fans_tick_split(void)\n{\n\tint err, cpu;\n\ts32 intake, temp, power, t_max = 0;\n\n\tDBG_LOTS(\"* cpu fans_tick_split()\\n\");\n\n\tfor (cpu = 0; cpu < nr_chips; ++cpu) {\n\t\tstruct wf_cpu_pid_state *sp = &cpu_pid[cpu];\n\n\t\t \n\t\twf_control_get(cpu_rear_fans[cpu], &sp->target);\n\n\t\tDBG_LOTS(\"  CPU%d: cur_target = %d RPM\\n\", cpu, sp->target);\n\n\t\terr = read_one_cpu_vals(cpu, &temp, &power);\n\t\tif (err) {\n\t\t\tfailure_state |= FAILURE_SENSOR;\n\t\t\tcpu_max_all_fans();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tt_max = max(t_max, temp);\n\n\t\t \n\t\tif (cpu_check_overtemp(t_max))\n\t\t\treturn;\n\n\t\t \n\t\twf_cpu_pid_run(sp, power, temp);\n\n\t\tDBG_LOTS(\"  CPU%d: target = %d RPM\\n\", cpu, sp->target);\n\n\t\t \n\t\terr = wf_control_set(cpu_rear_fans[cpu], sp->target);\n\t\tif (err) {\n\t\t\tpr_warn(\"wf_pm72: Fan %s reports error %d\\n\",\n\t\t\t\tcpu_rear_fans[cpu]->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tintake = (sp->target * CPU_INTAKE_SCALE) >> 16;\n\t\tDBG_LOTS(\"  CPU%d: intake = %d RPM\\n\", cpu, intake);\n\t\terr = wf_control_set(cpu_front_fans[cpu], intake);\n\t\tif (err) {\n\t\t\tpr_warn(\"wf_pm72: Fan %s reports error %d\\n\",\n\t\t\t\tcpu_front_fans[cpu]->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void cpu_fans_tick_combined(void)\n{\n\ts32 temp0, power0, temp1, power1, t_max = 0;\n\ts32 temp, power, intake, pump;\n\tstruct wf_control *pump0, *pump1;\n\tstruct wf_cpu_pid_state *sp = &cpu_pid[0];\n\tint err, cpu;\n\n\tDBG_LOTS(\"* cpu fans_tick_combined()\\n\");\n\n\t \n\twf_control_get(cpu_rear_fans[0], &sp->target);\n\n\tDBG_LOTS(\"  CPUs: cur_target = %d RPM\\n\", sp->target);\n\n\t \n\terr = read_one_cpu_vals(0, &temp0, &power0);\n\tif (err) {\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\tcpu_max_all_fans();\n\t\treturn;\n\t}\n\terr = read_one_cpu_vals(1, &temp1, &power1);\n\tif (err) {\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\tcpu_max_all_fans();\n\t\treturn;\n\t}\n\n\t \n\tt_max = max(t_max, max(temp0, temp1));\n\n\t \n\tif (cpu_check_overtemp(t_max))\n\t\treturn;\n\n\t \n\ttemp = max(temp0, temp1);\n\tpower = max(power0, power1);\n\n\t \n\twf_cpu_pid_run(sp, power, temp);\n\n\t \n\tintake = (sp->target * CPU_INTAKE_SCALE) >> 16;\n\n\t \n\tpump0 = cpu_pumps[0];\n\tpump1 = cpu_pumps[1];\n\tif (!pump0) {\n\t\tpump0 = pump1;\n\t\tpump1 = NULL;\n\t}\n\tpump = (sp->target * wf_control_get_max(pump0)) /\n\t\tcpu_mpu_data[0]->rmaxn_exhaust_fan;\n\n\tDBG_LOTS(\"  CPUs: target = %d RPM\\n\", sp->target);\n\tDBG_LOTS(\"  CPUs: intake = %d RPM\\n\", intake);\n\tDBG_LOTS(\"  CPUs: pump   = %d RPM\\n\", pump);\n\n\tfor (cpu = 0; cpu < nr_chips; cpu++) {\n\t\terr = wf_control_set(cpu_rear_fans[cpu], sp->target);\n\t\tif (err) {\n\t\t\tpr_warn(\"wf_pm72: Fan %s reports error %d\\n\",\n\t\t\t\tcpu_rear_fans[cpu]->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t}\n\t\terr = wf_control_set(cpu_front_fans[cpu], intake);\n\t\tif (err) {\n\t\t\tpr_warn(\"wf_pm72: Fan %s reports error %d\\n\",\n\t\t\t\tcpu_front_fans[cpu]->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t}\n\t\terr = 0;\n\t\tif (cpu_pumps[cpu])\n\t\t\terr = wf_control_set(cpu_pumps[cpu], pump);\n\t\tif (err) {\n\t\t\tpr_warn(\"wf_pm72: Pump %s reports error %d\\n\",\n\t\t\t\tcpu_pumps[cpu]->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t}\n\t}\n}\n\n \nstatic int cpu_setup_pid(int cpu)\n{\n\tstruct wf_cpu_pid_param pid;\n\tconst struct mpu_data *mpu = cpu_mpu_data[cpu];\n\ts32 tmax, ttarget, ptarget;\n\tint fmin, fmax, hsize;\n\n\t \n\ttmax = mpu->tmax << 16;\n\tttarget = mpu->ttarget << 16;\n\tptarget = ((s32)(mpu->pmaxh - mpu->padjmax)) << 16;\n\n\tDBG(\"wf_72: CPU%d ttarget = %d.%03d, tmax = %d.%03d\\n\",\n\t    cpu, FIX32TOPRINT(ttarget), FIX32TOPRINT(tmax));\n\n\t \n\tif (tmax < cpu_all_tmax)\n\t\tcpu_all_tmax = tmax;\n\n\t \n\tfmin = wf_control_get_min(cpu_rear_fans[cpu]);\n\tfmax = wf_control_get_max(cpu_rear_fans[cpu]);\n\tDBG(\"wf_72: CPU%d max RPM range = [%d..%d]\\n\", cpu, fmin, fmax);\n\n\t \n\thsize = min_t(int, mpu->tguardband, WF_PID_MAX_HISTORY);\n\tDBG(\"wf_72: CPU%d history size = %d\\n\", cpu, hsize);\n\n\t \n\tpid.interval\t= 1;\t \n\tpid.history_len = hsize;\n\tpid.gd\t\t= mpu->pid_gd;\n\tpid.gp\t\t= mpu->pid_gp;\n\tpid.gr\t\t= mpu->pid_gr;\n\tpid.tmax\t= tmax;\n\tpid.ttarget\t= ttarget;\n\tpid.pmaxadj\t= ptarget;\n\tpid.min\t\t= fmin;\n\tpid.max\t\t= fmax;\n\n\twf_cpu_pid_init(&cpu_pid[cpu], &pid);\n\tcpu_pid[cpu].target = 1000;\n\n\treturn 0;\n}\n\n \nstatic struct wf_pid_param backside_u3_param = {\n\t.interval\t= 5,\n\t.history_len\t= 2,\n\t.gd\t\t= 40 << 20,\n\t.gp\t\t= 5 << 20,\n\t.gr\t\t= 0,\n\t.itarget\t= 65 << 16,\n\t.additive\t= 1,\n\t.min\t\t= 20,\n\t.max\t\t= 100,\n};\n\nstatic struct wf_pid_param backside_u3h_param = {\n\t.interval\t= 5,\n\t.history_len\t= 2,\n\t.gd\t\t= 20 << 20,\n\t.gp\t\t= 5 << 20,\n\t.gr\t\t= 0,\n\t.itarget\t= 75 << 16,\n\t.additive\t= 1,\n\t.min\t\t= 20,\n\t.max\t\t= 100,\n};\n\nstatic void backside_fan_tick(void)\n{\n\ts32 temp;\n\tint speed;\n\tint err;\n\n\tif (!backside_fan || !backside_temp || !backside_tick)\n\t\treturn;\n\tif (--backside_tick > 0)\n\t\treturn;\n\tbackside_tick = backside_pid.param.interval;\n\n\tDBG_LOTS(\"* backside fans tick\\n\");\n\n\t \n\terr = wf_control_get(backside_fan, &speed);\n\tif (!err)\n\t\tbackside_pid.target = speed;\n\n\terr = wf_sensor_get(backside_temp, &temp);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: U4 temp sensor error %d\\n\",\n\t\t       err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(backside_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&backside_pid, temp);\n\n\tDBG_LOTS(\"backside PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\terr = wf_control_set(backside_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: backside fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\nstatic void backside_setup_pid(void)\n{\n\t \n\ts32 fmin = wf_control_get_min(backside_fan);\n\ts32 fmax = wf_control_get_max(backside_fan);\n\tstruct wf_pid_param param;\n\tstruct device_node *u3;\n\tint u3h = 1;  \n\n\tu3 = of_find_node_by_path(\"/u3@0,f8000000\");\n\tif (u3 != NULL) {\n\t\tconst u32 *vers = of_get_property(u3, \"device-rev\", NULL);\n\t\tif (vers)\n\t\t\tif (((*vers) & 0x3f) < 0x34)\n\t\t\t\tu3h = 0;\n\t\tof_node_put(u3);\n\t}\n\n\tparam = u3h ? backside_u3h_param : backside_u3_param;\n\n\tparam.min = max(param.min, fmin);\n\tparam.max = min(param.max, fmax);\n\twf_pid_init(&backside_pid, &param);\n\tbackside_tick = 1;\n\n\tpr_info(\"wf_pm72: Backside control loop started.\\n\");\n}\n\n \nstatic const struct wf_pid_param drives_param = {\n\t.interval\t= 5,\n\t.history_len\t= 2,\n\t.gd\t\t= 30 << 20,\n\t.gp\t\t= 5 << 20,\n\t.gr\t\t= 0,\n\t.itarget\t= 40 << 16,\n\t.additive\t= 1,\n\t.min\t\t= 300,\n\t.max\t\t= 4000,\n};\n\nstatic void drives_fan_tick(void)\n{\n\ts32 temp;\n\tint speed;\n\tint err;\n\n\tif (!drives_fan || !drives_temp || !drives_tick)\n\t\treturn;\n\tif (--drives_tick > 0)\n\t\treturn;\n\tdrives_tick = drives_pid.param.interval;\n\n\tDBG_LOTS(\"* drives fans tick\\n\");\n\n\t \n\terr = wf_control_get(drives_fan, &speed);\n\tif (!err)\n\t\tdrives_pid.target = speed;\n\n\terr = wf_sensor_get(drives_temp, &temp);\n\tif (err) {\n\t\tpr_warn(\"wf_pm72: drive bay temp sensor error %d\\n\", err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(drives_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&drives_pid, temp);\n\n\tDBG_LOTS(\"drives PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\terr = wf_control_set(drives_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: drive bay fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\nstatic void drives_setup_pid(void)\n{\n\t \n\ts32 fmin = wf_control_get_min(drives_fan);\n\ts32 fmax = wf_control_get_max(drives_fan);\n\tstruct wf_pid_param param = drives_param;\n\n\tparam.min = max(param.min, fmin);\n\tparam.max = min(param.max, fmax);\n\twf_pid_init(&drives_pid, &param);\n\tdrives_tick = 1;\n\n\tpr_info(\"wf_pm72: Drive bay control loop started.\\n\");\n}\n\nstatic void set_fail_state(void)\n{\n\tcpu_max_all_fans();\n\n\tif (backside_fan)\n\t\twf_control_set_max(backside_fan);\n\tif (slots_fan)\n\t\twf_control_set_max(slots_fan);\n\tif (drives_fan)\n\t\twf_control_set_max(drives_fan);\n}\n\nstatic void pm72_tick(void)\n{\n\tint i, last_failure;\n\n\tif (!started) {\n\t\tstarted = true;\n\t\tprintk(KERN_INFO \"windfarm: CPUs control loops started.\\n\");\n\t\tfor (i = 0; i < nr_chips; ++i) {\n\t\t\tif (cpu_setup_pid(i) < 0) {\n\t\t\t\tfailure_state = FAILURE_PERM;\n\t\t\t\tset_fail_state();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDBG_LOTS(\"cpu_all_tmax=%d.%03d\\n\", FIX32TOPRINT(cpu_all_tmax));\n\n\t\tbackside_setup_pid();\n\t\tdrives_setup_pid();\n\n\t\t \n\t\twf_control_set(slots_fan, SLOTS_FAN_DEFAULT_PWM);\n\n#ifdef HACKED_OVERTEMP\n\t\tcpu_all_tmax = 60 << 16;\n#endif\n\t}\n\n\t \n\tif (failure_state & FAILURE_PERM)\n\t\treturn;\n\n\t \n\tlast_failure = failure_state;\n\tfailure_state &= FAILURE_LOW_OVERTEMP;\n\tif (cpu_pid_combined)\n\t\tcpu_fans_tick_combined();\n\telse\n\t\tcpu_fans_tick_split();\n\tbackside_fan_tick();\n\tdrives_fan_tick();\n\n\tDBG_LOTS(\"  last_failure: 0x%x, failure_state: %x\\n\",\n\t\t last_failure, failure_state);\n\n\t \n\tif (failure_state && last_failure == 0 && cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tif (failure_state == 0 && last_failure && cpufreq_clamp)\n\t\twf_control_set_min(cpufreq_clamp);\n\n\t \n}\n\nstatic void pm72_new_control(struct wf_control *ct)\n{\n\tbool all_controls;\n\tbool had_pump = cpu_pumps[0] || cpu_pumps[1];\n\n\tif (!strcmp(ct->name, \"cpu-front-fan-0\"))\n\t\tcpu_front_fans[0] = ct;\n\telse if (!strcmp(ct->name, \"cpu-front-fan-1\"))\n\t\tcpu_front_fans[1] = ct;\n\telse if (!strcmp(ct->name, \"cpu-rear-fan-0\"))\n\t\tcpu_rear_fans[0] = ct;\n\telse if (!strcmp(ct->name, \"cpu-rear-fan-1\"))\n\t\tcpu_rear_fans[1] = ct;\n\telse if (!strcmp(ct->name, \"cpu-pump-0\"))\n\t\tcpu_pumps[0] = ct;\n\telse if (!strcmp(ct->name, \"cpu-pump-1\"))\n\t\tcpu_pumps[1] = ct;\n\telse if (!strcmp(ct->name, \"backside-fan\"))\n\t\tbackside_fan = ct;\n\telse if (!strcmp(ct->name, \"slots-fan\"))\n\t\tslots_fan = ct;\n\telse if (!strcmp(ct->name, \"drive-bay-fan\"))\n\t\tdrives_fan = ct;\n\telse if (!strcmp(ct->name, \"cpufreq-clamp\"))\n\t\tcpufreq_clamp = ct;\n\n\tall_controls =\n\t\tcpu_front_fans[0] &&\n\t\tcpu_rear_fans[0] &&\n\t\tbackside_fan &&\n\t\tslots_fan &&\n\t\tdrives_fan;\n\tif (nr_chips > 1)\n\t\tall_controls &=\n\t\t\tcpu_front_fans[1] &&\n\t\t\tcpu_rear_fans[1];\n\thave_all_controls = all_controls;\n\n\tif ((cpu_pumps[0] || cpu_pumps[1]) && !had_pump) {\n\t\tpr_info(\"wf_pm72: Liquid cooling pump(s) detected,\"\n\t\t\t\" using new algorithm !\\n\");\n\t\tcpu_pid_combined = true;\n\t}\n}\n\n\nstatic void pm72_new_sensor(struct wf_sensor *sr)\n{\n\tbool all_sensors;\n\n\tif (!strcmp(sr->name, \"cpu-diode-temp-0\"))\n\t\tsens_cpu_temp[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-diode-temp-1\"))\n\t\tsens_cpu_temp[1] = sr;\n\telse if (!strcmp(sr->name, \"cpu-voltage-0\"))\n\t\tsens_cpu_volts[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-voltage-1\"))\n\t\tsens_cpu_volts[1] = sr;\n\telse if (!strcmp(sr->name, \"cpu-current-0\"))\n\t\tsens_cpu_amps[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-current-1\"))\n\t\tsens_cpu_amps[1] = sr;\n\telse if (!strcmp(sr->name, \"backside-temp\"))\n\t\tbackside_temp = sr;\n\telse if (!strcmp(sr->name, \"hd-temp\"))\n\t\tdrives_temp = sr;\n\n\tall_sensors =\n\t\tsens_cpu_temp[0] &&\n\t\tsens_cpu_volts[0] &&\n\t\tsens_cpu_amps[0] &&\n\t\tbackside_temp &&\n\t\tdrives_temp;\n\tif (nr_chips > 1)\n\t\tall_sensors &=\n\t\t\tsens_cpu_temp[1] &&\n\t\t\tsens_cpu_volts[1] &&\n\t\t\tsens_cpu_amps[1];\n\n\thave_all_sensors = all_sensors;\n}\n\nstatic int pm72_wf_notify(struct notifier_block *self,\n\t\t\t  unsigned long event, void *data)\n{\n\tswitch (event) {\n\tcase WF_EVENT_NEW_SENSOR:\n\t\tpm72_new_sensor(data);\n\t\tbreak;\n\tcase WF_EVENT_NEW_CONTROL:\n\t\tpm72_new_control(data);\n\t\tbreak;\n\tcase WF_EVENT_TICK:\n\t\tif (have_all_controls && have_all_sensors)\n\t\t\tpm72_tick();\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block pm72_events = {\n\t.notifier_call = pm72_wf_notify,\n};\n\nstatic int wf_pm72_probe(struct platform_device *dev)\n{\n\twf_register_client(&pm72_events);\n\treturn 0;\n}\n\nstatic int wf_pm72_remove(struct platform_device *dev)\n{\n\twf_unregister_client(&pm72_events);\n\n\t \n\treturn 0;\n}\n\nstatic struct platform_driver wf_pm72_driver = {\n\t.probe\t= wf_pm72_probe,\n\t.remove\t= wf_pm72_remove,\n\t.driver\t= {\n\t\t.name = \"windfarm\",\n\t},\n};\n\nstatic int __init wf_pm72_init(void)\n{\n\tstruct device_node *cpu;\n\tint i;\n\n\tif (!of_machine_is_compatible(\"PowerMac7,2\") &&\n\t    !of_machine_is_compatible(\"PowerMac7,3\"))\n\t\treturn -ENODEV;\n\n\t \n\tnr_chips = 0;\n\tfor_each_node_by_type(cpu, \"cpu\")\n\t\t++nr_chips;\n\tif (nr_chips > NR_CHIPS)\n\t\tnr_chips = NR_CHIPS;\n\n\tpr_info(\"windfarm: Initializing for desktop G5 with %d chips\\n\",\n\t\tnr_chips);\n\n\t \n\tfor (i = 0; i < nr_chips; i++) {\n\t\tcpu_mpu_data[i] = wf_get_mpu(i);\n\t\tif (!cpu_mpu_data[i]) {\n\t\t\tpr_err(\"wf_pm72: Failed to find MPU data for CPU %d\\n\", i);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n#ifdef MODULE\n\trequest_module(\"windfarm_fcu_controls\");\n\trequest_module(\"windfarm_lm75_sensor\");\n\trequest_module(\"windfarm_ad7417_sensor\");\n\trequest_module(\"windfarm_max6690_sensor\");\n\trequest_module(\"windfarm_cpufreq_clamp\");\n#endif  \n\n\tplatform_driver_register(&wf_pm72_driver);\n\treturn 0;\n}\n\nstatic void __exit wf_pm72_exit(void)\n{\n\tplatform_driver_unregister(&wf_pm72_driver);\n}\n\nmodule_init(wf_pm72_init);\nmodule_exit(wf_pm72_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Thermal control for AGP PowerMac G5s\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:windfarm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}