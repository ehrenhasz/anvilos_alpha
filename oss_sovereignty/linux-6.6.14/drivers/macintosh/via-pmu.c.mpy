{
  "module_name": "via-pmu.c",
  "hash_id": "4b95c6ff55938cd6ede714a13d3217954ead11cdfe9efaf2c7b8de2de26b9007",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/via-pmu.c",
  "human_readable_source": "\n \n#include <linux/stdarg.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\n#include <linux/miscdevice.h>\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#include <linux/cuda.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/pm.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/syscore_ops.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/cpu.h>\n#include <linux/compat.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/irq.h>\n#ifdef CONFIG_PPC_PMAC\n#include <asm/pmac_feature.h>\n#include <asm/pmac_pfunc.h>\n#include <asm/pmac_low_i2c.h>\n#include <asm/mmu_context.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/backlight.h>\n#else\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/mac_via.h>\n#endif\n\n#include \"via-pmu-event.h\"\n\n \n#undef DEBUG_SLEEP\n\n \n#define BATTERY_POLLING_COUNT\t2\n\nstatic DEFINE_MUTEX(pmu_info_proc_mutex);\n\n \n#define RS\t\t0x200\t\t \n#define B\t\t0\t\t \n#define A\t\tRS\t\t \n#define DIRB\t\t(2*RS)\t\t \n#define DIRA\t\t(3*RS)\t\t \n#define T1CL\t\t(4*RS)\t\t \n#define T1CH\t\t(5*RS)\t\t \n#define T1LL\t\t(6*RS)\t\t \n#define T1LH\t\t(7*RS)\t\t \n#define T2CL\t\t(8*RS)\t\t \n#define T2CH\t\t(9*RS)\t\t \n#define SR\t\t(10*RS)\t\t \n#define ACR\t\t(11*RS)\t\t \n#define PCR\t\t(12*RS)\t\t \n#define IFR\t\t(13*RS)\t\t \n#define IER\t\t(14*RS)\t\t \n#define ANH\t\t(15*RS)\t\t \n\n \n#ifdef CONFIG_PPC_PMAC\n#define TACK\t\t0x08\t\t \n#define TREQ\t\t0x10\t\t \n#else\n#define TACK\t\t0x02\n#define TREQ\t\t0x04\n#endif\n\n \n#define SR_CTRL\t\t0x1c\t\t \n#define SR_EXT\t\t0x0c\t\t \n#define SR_OUT\t\t0x10\t\t \n\n \n#define IER_SET\t\t0x80\t\t \n#define IER_CLR\t\t0\t\t \n#define SR_INT\t\t0x04\t\t \n#define CB2_INT\t\t0x08\n#define CB1_INT\t\t0x10\t\t \n\nstatic volatile enum pmu_state {\n\tuninitialized = 0,\n\tidle,\n\tsending,\n\tintack,\n\treading,\n\treading_intr,\n\tlocked,\n} pmu_state;\n\nstatic volatile enum int_data_state {\n\tint_data_empty,\n\tint_data_fill,\n\tint_data_ready,\n\tint_data_flush\n} int_data_state[2] = { int_data_empty, int_data_empty };\n\nstatic struct adb_request *current_req;\nstatic struct adb_request *last_req;\nstatic struct adb_request *req_awaiting_reply;\nstatic unsigned char interrupt_data[2][32];\nstatic int interrupt_data_len[2];\nstatic int int_data_last;\nstatic unsigned char *reply_ptr;\nstatic int data_index;\nstatic int data_len;\nstatic volatile int adb_int_pending;\nstatic volatile int disable_poll;\nstatic int pmu_kind = PMU_UNKNOWN;\nstatic int pmu_fully_inited;\nstatic int pmu_has_adb;\n#ifdef CONFIG_PPC_PMAC\nstatic volatile unsigned char __iomem *via1;\nstatic volatile unsigned char __iomem *via2;\nstatic struct device_node *vias;\nstatic struct device_node *gpio_node;\n#endif\nstatic unsigned char __iomem *gpio_reg;\nstatic int gpio_irq = 0;\nstatic int gpio_irq_enabled = -1;\nstatic volatile int pmu_suspended;\nstatic DEFINE_SPINLOCK(pmu_lock);\nstatic u8 pmu_intr_mask;\nstatic int pmu_version;\nstatic int drop_interrupts;\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\nstatic int option_lid_wakeup = 1;\n#endif  \nstatic unsigned long async_req_locks;\n\n#define NUM_IRQ_STATS 13\nstatic unsigned int pmu_irq_stats[NUM_IRQ_STATS];\n\nstatic struct proc_dir_entry *proc_pmu_root;\nstatic struct proc_dir_entry *proc_pmu_info;\nstatic struct proc_dir_entry *proc_pmu_irqstats;\nstatic struct proc_dir_entry *proc_pmu_options;\nstatic int option_server_mode;\n\nint pmu_battery_count;\nstatic int pmu_cur_battery;\nunsigned int pmu_power_flags = PMU_PWR_AC_PRESENT;\nstruct pmu_battery_info pmu_batteries[PMU_MAX_BATTERIES];\nstatic int query_batt_timer = BATTERY_POLLING_COUNT;\nstatic struct adb_request batt_req;\nstatic struct proc_dir_entry *proc_pmu_batt[PMU_MAX_BATTERIES];\n\nint asleep;\n\n#ifdef CONFIG_ADB\nstatic int adb_dev_map;\nstatic int pmu_adb_flags;\n\nstatic int pmu_probe(void);\nstatic int pmu_init(void);\nstatic int pmu_send_request(struct adb_request *req, int sync);\nstatic int pmu_adb_autopoll(int devs);\nstatic int pmu_adb_reset_bus(void);\n#endif  \n\nstatic int init_pmu(void);\nstatic void pmu_start(void);\nstatic irqreturn_t via_pmu_interrupt(int irq, void *arg);\nstatic irqreturn_t gpio1_interrupt(int irq, void *arg);\n#ifdef CONFIG_PROC_FS\nstatic int pmu_info_proc_show(struct seq_file *m, void *v);\nstatic int pmu_irqstats_proc_show(struct seq_file *m, void *v);\nstatic int pmu_battery_proc_show(struct seq_file *m, void *v);\n#endif\nstatic void pmu_pass_intr(unsigned char *data, int len);\nstatic const struct proc_ops pmu_options_proc_ops;\n\n#ifdef CONFIG_ADB\nconst struct adb_driver via_pmu_driver = {\n\t.name         = \"PMU\",\n\t.probe        = pmu_probe,\n\t.init         = pmu_init,\n\t.send_request = pmu_send_request,\n\t.autopoll     = pmu_adb_autopoll,\n\t.poll         = pmu_poll_adb,\n\t.reset_bus    = pmu_adb_reset_bus,\n};\n#endif  \n\nextern void low_sleep_handler(void);\nextern void enable_kernel_altivec(void);\nextern void enable_kernel_fp(void);\n\n#ifdef DEBUG_SLEEP\nint pmu_polled_request(struct adb_request *req);\nvoid pmu_blink(int n);\n#endif\n\n \nstatic const s8 pmu_data_len[256][2] = {\n \n \t{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{ 1, 0},{ 1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 1},{ 0, 1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{ 0, 0},\n \t{-1, 0},{ 0, 0},{ 2, 0},{ 1, 0},{ 1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0,-1},{ 0,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{ 0,-1},\n \t{ 4, 0},{20, 0},{-1, 0},{ 3, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 4},{ 0,20},{ 2,-1},{ 2, 1},{ 3,-1},{-1,-1},{-1,-1},{ 4, 0},\n \t{ 1, 0},{ 1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 1},{ 0, 1},{-1,-1},{ 1, 0},{ 1, 0},{-1,-1},{-1,-1},{-1,-1},\n \t{ 1, 0},{ 0, 0},{ 2, 0},{ 2, 0},{-1, 0},{ 1, 0},{ 3, 0},{ 1, 0},\n \t{ 0, 1},{ 1, 0},{ 0, 2},{ 0, 2},{ 0,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{ 2, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 3},{ 0, 3},{ 0, 2},{ 0, 8},{ 0,-1},{ 0,-1},{-1,-1},{-1,-1},\n \t{ 1, 0},{ 1, 0},{ 1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0,-1},{ 0,-1},{-1,-1},{-1,-1},{-1,-1},{ 5, 1},{ 4, 1},{ 4, 1},\n \t{ 4, 0},{-1, 0},{ 0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 5},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{ 1, 0},{ 2, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 0, 1},{ 0, 1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{ 2, 0},{ 2, 0},{ 2, 0},{ 4, 0},{-1, 0},{ 0, 0},{-1, 0},{-1, 0},\n \t{ 1, 1},{ 1, 0},{ 3, 0},{ 2, 0},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n \t{ 0, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{ 1, 1},{ 1, 1},{-1,-1},{-1,-1},{ 0, 1},{ 0,-1},{-1,-1},{-1,-1},\n \t{-1, 0},{ 4, 0},{ 0, 1},{-1, 0},{-1, 0},{ 4, 0},{-1, 0},{-1, 0},\n \t{ 3,-1},{-1,-1},{ 0, 1},{-1,-1},{ 0,-1},{-1,-1},{-1,-1},{ 0, 0},\n \t{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},{-1, 0},\n \t{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},\n};\n\nstatic char *pbook_type[] = {\n\t\"Unknown PowerBook\",\n\t\"PowerBook 2400/3400/3500(G3)\",\n\t\"PowerBook G3 Series\",\n\t\"1999 PowerBook G3\",\n\t\"Core99\"\n};\n\nint __init find_via_pmu(void)\n{\n#ifdef CONFIG_PPC_PMAC\n\tint err;\n\tu64 taddr;\n\tstruct resource res;\n\n\tif (pmu_state != uninitialized)\n\t\treturn 1;\n\tvias = of_find_node_by_name(NULL, \"via-pmu\");\n\tif (vias == NULL)\n\t\treturn 0;\n\n\terr = of_address_to_resource(vias, 0, &res);\n\tif (err) {\n\t\tprintk(KERN_ERR \"via-pmu: Error getting \\\"reg\\\" property !\\n\");\n\t\tgoto fail;\n\t}\n\ttaddr = res.start;\n\n\tpmu_has_adb = 1;\n\n\tpmu_intr_mask =\tPMU_INT_PCEJECT |\n\t\t\tPMU_INT_SNDBRT |\n\t\t\tPMU_INT_ADB |\n\t\t\tPMU_INT_TICK;\n\t\n\tif (of_node_name_eq(vias->parent, \"ohare\") ||\n\t    of_device_is_compatible(vias->parent, \"ohare\"))\n\t\tpmu_kind = PMU_OHARE_BASED;\n\telse if (of_device_is_compatible(vias->parent, \"paddington\"))\n\t\tpmu_kind = PMU_PADDINGTON_BASED;\n\telse if (of_device_is_compatible(vias->parent, \"heathrow\"))\n\t\tpmu_kind = PMU_HEATHROW_BASED;\n\telse if (of_device_is_compatible(vias->parent, \"Keylargo\")\n\t\t || of_device_is_compatible(vias->parent, \"K2-Keylargo\")) {\n\t\tstruct device_node *gpiop;\n\t\tstruct device_node *adbp;\n\n\t\tpmu_kind = PMU_KEYLARGO_BASED;\n\t\tadbp = of_find_node_by_type(NULL, \"adb\");\n\t\tpmu_has_adb = (adbp != NULL);\n\t\tof_node_put(adbp);\n\t\tpmu_intr_mask =\tPMU_INT_PCEJECT |\n\t\t\t\tPMU_INT_SNDBRT |\n\t\t\t\tPMU_INT_ADB |\n\t\t\t\tPMU_INT_TICK |\n\t\t\t\tPMU_INT_ENVIRONMENT;\n\t\t\n\t\tgpiop = of_find_node_by_name(NULL, \"gpio\");\n\t\tif (gpiop) {\n\t\t\tif (!of_address_to_resource(gpiop, 0, &res))\n\t\t\t\tgpio_reg = ioremap(res.start, 0x10);\n\t\t\tof_node_put(gpiop);\n\t\t}\n\t\tif (gpio_reg == NULL) {\n\t\t\tprintk(KERN_ERR \"via-pmu: Can't find GPIO reg !\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tpmu_kind = PMU_UNKNOWN;\n\n\tvia1 = via2 = ioremap(taddr, 0x2000);\n\tif (via1 == NULL) {\n\t\tprintk(KERN_ERR \"via-pmu: Can't map address !\\n\");\n\t\tgoto fail_via_remap;\n\t}\n\t\n\tout_8(&via1[IER], IER_CLR | 0x7f);\t \n\tout_8(&via1[IFR], 0x7f);\t\t\t \n\n\tpmu_state = idle;\n\n\tif (!init_pmu())\n\t\tgoto fail_init;\n\n\tsys_ctrler = SYS_CTRLER_PMU;\n\t\n\treturn 1;\n\n fail_init:\n\tiounmap(via1);\n\tvia1 = via2 = NULL;\n fail_via_remap:\n\tiounmap(gpio_reg);\n\tgpio_reg = NULL;\n fail:\n\tof_node_put(vias);\n\tvias = NULL;\n\tpmu_state = uninitialized;\n\treturn 0;\n#else\n\tif (macintosh_config->adb_type != MAC_ADB_PB2)\n\t\treturn 0;\n\n\tpmu_kind = PMU_UNKNOWN;\n\n\tpmu_has_adb = 1;\n\n\tpmu_intr_mask =\tPMU_INT_PCEJECT |\n\t\t\tPMU_INT_SNDBRT |\n\t\t\tPMU_INT_ADB |\n\t\t\tPMU_INT_TICK;\n\n\tpmu_state = idle;\n\n\tif (!init_pmu()) {\n\t\tpmu_state = uninitialized;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n#endif  \n}\n\n#ifdef CONFIG_ADB\nstatic int pmu_probe(void)\n{\n\treturn pmu_state == uninitialized ? -ENODEV : 0;\n}\n\nstatic int pmu_init(void)\n{\n\treturn pmu_state == uninitialized ? -ENODEV : 0;\n}\n#endif  \n\n \nstatic int __init via_pmu_start(void)\n{\n\tunsigned int __maybe_unused irq;\n\n\tif (pmu_state == uninitialized)\n\t\treturn -ENODEV;\n\n\tbatt_req.complete = 1;\n\n#ifdef CONFIG_PPC_PMAC\n\tirq = irq_of_parse_and_map(vias, 0);\n\tif (!irq) {\n\t\tprintk(KERN_ERR \"via-pmu: can't map interrupt\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (request_irq(irq, via_pmu_interrupt, IRQF_NO_SUSPEND,\n\t\t\t\"VIA-PMU\", (void *)0)) {\n\t\tprintk(KERN_ERR \"via-pmu: can't request irq %d\\n\", irq);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pmu_kind == PMU_KEYLARGO_BASED) {\n\t\tgpio_node = of_find_node_by_name(NULL, \"extint-gpio1\");\n\t\tif (gpio_node == NULL)\n\t\t\tgpio_node = of_find_node_by_name(NULL,\n\t\t\t\t\t\t\t \"pmu-interrupt\");\n\t\tif (gpio_node)\n\t\t\tgpio_irq = irq_of_parse_and_map(gpio_node, 0);\n\n\t\tif (gpio_irq) {\n\t\t\tif (request_irq(gpio_irq, gpio1_interrupt,\n\t\t\t\t\tIRQF_NO_SUSPEND, \"GPIO1 ADB\",\n\t\t\t\t\t(void *)0))\n\t\t\t\tprintk(KERN_ERR \"pmu: can't get irq %d\"\n\t\t\t\t       \" (GPIO1)\\n\", gpio_irq);\n\t\t\telse\n\t\t\t\tgpio_irq_enabled = 1;\n\t\t}\n\t}\n\n\t \n\tout_8(&via1[IER], IER_SET | SR_INT | CB1_INT);\n#else\n\tif (request_irq(IRQ_MAC_ADB_SR, via_pmu_interrupt, IRQF_NO_SUSPEND,\n\t\t\t\"VIA-PMU-SR\", NULL)) {\n\t\tpr_err(\"%s: couldn't get SR irq\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (request_irq(IRQ_MAC_ADB_CL, via_pmu_interrupt, IRQF_NO_SUSPEND,\n\t\t\t\"VIA-PMU-CL\", NULL)) {\n\t\tpr_err(\"%s: couldn't get CL irq\\n\", __func__);\n\t\tfree_irq(IRQ_MAC_ADB_SR, NULL);\n\t\treturn -ENODEV;\n\t}\n#endif  \n\n\tpmu_fully_inited = 1;\n\n\t \n\tdo {\n\t\tpmu_poll();\n\t} while (pmu_state != idle);\n\n\treturn 0;\n}\n\narch_initcall(via_pmu_start);\n\n \nstatic int __init via_pmu_dev_init(void)\n{\n\tif (pmu_state == uninitialized)\n\t\treturn -ENODEV;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\t \n\tpmu_backlight_init();\n#endif\n\n#ifdef CONFIG_PPC32\n  \tif (of_machine_is_compatible(\"AAPL,3400/2400\") ||\n  \t\tof_machine_is_compatible(\"AAPL,3500\")) {\n\t\tint mb = pmac_call_feature(PMAC_FTR_GET_MB_INFO,\n\t\t\tNULL, PMAC_MB_INFO_MODEL, 0);\n\t\tpmu_battery_count = 1;\n\t\tif (mb == PMAC_TYPE_COMET)\n\t\t\tpmu_batteries[0].flags |= PMU_BATT_TYPE_COMET;\n\t\telse\n\t\t\tpmu_batteries[0].flags |= PMU_BATT_TYPE_HOOPER;\n\t} else if (of_machine_is_compatible(\"AAPL,PowerBook1998\") ||\n\t\tof_machine_is_compatible(\"PowerBook1,1\")) {\n\t\tpmu_battery_count = 2;\n\t\tpmu_batteries[0].flags |= PMU_BATT_TYPE_SMART;\n\t\tpmu_batteries[1].flags |= PMU_BATT_TYPE_SMART;\n\t} else {\n\t\tstruct device_node* prim =\n\t\t\tof_find_node_by_name(NULL, \"power-mgt\");\n\t\tconst u32 *prim_info = NULL;\n\t\tif (prim)\n\t\t\tprim_info = of_get_property(prim, \"prim-info\", NULL);\n\t\tif (prim_info) {\n\t\t\t \n\t\t\tpmu_battery_count = (prim_info[6] >> 16) & 0xff;\n\t\t\tpmu_batteries[0].flags |= PMU_BATT_TYPE_SMART;\n\t\t\tif (pmu_battery_count > 1)\n\t\t\t\tpmu_batteries[1].flags |= PMU_BATT_TYPE_SMART;\n\t\t}\n\t\tof_node_put(prim);\n\t}\n#endif  \n\n\t \n\tproc_pmu_root = proc_mkdir(\"pmu\", NULL);\n\tif (proc_pmu_root) {\n\t\tlong i;\n\n\t\tfor (i=0; i<pmu_battery_count; i++) {\n\t\t\tchar title[16];\n\t\t\tsprintf(title, \"battery_%ld\", i);\n\t\t\tproc_pmu_batt[i] = proc_create_single_data(title, 0,\n\t\t\t\t\tproc_pmu_root, pmu_battery_proc_show,\n\t\t\t\t\t(void *)i);\n\t\t}\n\n\t\tproc_pmu_info = proc_create_single(\"info\", 0, proc_pmu_root,\n\t\t\t\tpmu_info_proc_show);\n\t\tproc_pmu_irqstats = proc_create_single(\"interrupts\", 0,\n\t\t\t\tproc_pmu_root, pmu_irqstats_proc_show);\n\t\tproc_pmu_options = proc_create(\"options\", 0600, proc_pmu_root,\n\t\t\t\t\t\t&pmu_options_proc_ops);\n\t}\n\treturn 0;\n}\n\ndevice_initcall(via_pmu_dev_init);\n\nstatic int\ninit_pmu(void)\n{\n\tint timeout;\n\tstruct adb_request req;\n\n\t \n\tout_8(&via2[B], in_8(&via2[B]) | TREQ);\n\tout_8(&via2[DIRB], (in_8(&via2[DIRB]) | TREQ) & ~TACK);\n\n\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\n\ttimeout =  100000;\n\twhile (!req.complete) {\n\t\tif (--timeout < 0) {\n\t\t\tprintk(KERN_ERR \"init_pmu: no response from PMU\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(10);\n\t\tpmu_poll();\n\t}\n\n\t \n\ttimeout = 100000;\n\tinterrupt_data[0][0] = 1;\n\twhile (interrupt_data[0][0] || pmu_state != idle) {\n\t\tif (--timeout < 0) {\n\t\t\tprintk(KERN_ERR \"init_pmu: timed out acking intrs\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (pmu_state == idle)\n\t\t\tadb_int_pending = 1;\n\t\tvia_pmu_interrupt(0, NULL);\n\t\tudelay(10);\n\t}\n\n\t \n\tif (pmu_kind == PMU_KEYLARGO_BASED) {\n\t\tpmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\n\t\twhile (!req.complete)\n\t\t\tpmu_poll();\n\t}\n\n\t \n\tpmu_request(&req, NULL, 1, PMU_GET_VERSION);\n\tpmu_wait_complete(&req);\n\tif (req.reply_len > 0)\n\t\tpmu_version = req.reply[0];\n\t\n\t \n\tif (pmu_kind == PMU_KEYLARGO_BASED) {\n\t\tpmu_request(&req, NULL, 2, PMU_POWER_EVENTS,\n\t\t\t    PMU_PWR_GET_POWERUP_EVENTS);\n\t\tpmu_wait_complete(&req);\n\t\tif (req.reply_len == 2) {\n\t\t\tif (req.reply[1] & PMU_PWR_WAKEUP_AC_INSERT)\n\t\t\t\toption_server_mode = 1;\n\t\t\tprintk(KERN_INFO \"via-pmu: Server Mode is %s\\n\",\n\t\t\t       option_server_mode ? \"enabled\" : \"disabled\");\n\t\t}\n\t}\n\n\tprintk(KERN_INFO \"PMU driver v%d initialized for %s, firmware: %02x\\n\",\n\t       PMU_DRIVER_VERSION, pbook_type[pmu_kind], pmu_version);\n\n\treturn 1;\n}\n\nint\npmu_get_model(void)\n{\n\treturn pmu_kind;\n}\n\nstatic void pmu_set_server_mode(int server_mode)\n{\n\tstruct adb_request req;\n\n\tif (pmu_kind != PMU_KEYLARGO_BASED)\n\t\treturn;\n\n\toption_server_mode = server_mode;\n\tpmu_request(&req, NULL, 2, PMU_POWER_EVENTS, PMU_PWR_GET_POWERUP_EVENTS);\n\tpmu_wait_complete(&req);\n\tif (req.reply_len < 2)\n\t\treturn;\n\tif (server_mode)\n\t\tpmu_request(&req, NULL, 4, PMU_POWER_EVENTS,\n\t\t\t    PMU_PWR_SET_POWERUP_EVENTS,\n\t\t\t    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); \n\telse\n\t\tpmu_request(&req, NULL, 4, PMU_POWER_EVENTS,\n\t\t\t    PMU_PWR_CLR_POWERUP_EVENTS,\n\t\t\t    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); \n\tpmu_wait_complete(&req);\n}\n\n \nstatic void\ndone_battery_state_ohare(struct adb_request* req)\n{\n#ifdef CONFIG_PPC_PMAC\n\t \n\tunsigned int bat_flags = PMU_BATT_TYPE_HOOPER;\n\tlong pcharge, charge, vb, vmax, lmax;\n\tlong vmax_charging, vmax_charged;\n\tlong amperage, voltage, time, max;\n\tint mb = pmac_call_feature(PMAC_FTR_GET_MB_INFO,\n\t\t\tNULL, PMAC_MB_INFO_MODEL, 0);\n\n\tif (req->reply[0] & 0x01)\n\t\tpmu_power_flags |= PMU_PWR_AC_PRESENT;\n\telse\n\t\tpmu_power_flags &= ~PMU_PWR_AC_PRESENT;\n\t\n\tif (mb == PMAC_TYPE_COMET) {\n\t\tvmax_charged = 189;\n\t\tvmax_charging = 213;\n\t\tlmax = 6500;\n\t} else {\n\t\tvmax_charged = 330;\n\t\tvmax_charging = 330;\n\t\tlmax = 6500;\n\t}\n\tvmax = vmax_charged;\n\n\t \n\tif (req->reply[0] & 0x04) {\n\t\tbat_flags |= PMU_BATT_PRESENT;\n\t\tif (req->reply[0] & 0x02)\n\t\t\tbat_flags |= PMU_BATT_CHARGING;\n\t\tvb = (req->reply[1] << 8) | req->reply[2];\n\t\tvoltage = (vb * 265 + 72665) / 10;\n\t\tamperage = req->reply[5];\n\t\tif ((req->reply[0] & 0x01) == 0) {\n\t\t\tif (amperage > 200)\n\t\t\t\tvb += ((amperage - 200) * 15)/100;\n\t\t} else if (req->reply[0] & 0x02) {\n\t\t\tvb = (vb * 97) / 100;\n\t\t\tvmax = vmax_charging;\n\t\t}\n\t\tcharge = (100 * vb) / vmax;\n\t\tif (req->reply[0] & 0x40) {\n\t\t\tpcharge = (req->reply[6] << 8) + req->reply[7];\n\t\t\tif (pcharge > lmax)\n\t\t\t\tpcharge = lmax;\n\t\t\tpcharge *= 100;\n\t\t\tpcharge = 100 - pcharge / lmax;\n\t\t\tif (pcharge < charge)\n\t\t\t\tcharge = pcharge;\n\t\t}\n\t\tif (amperage > 0)\n\t\t\ttime = (charge * 16440) / amperage;\n\t\telse\n\t\t\ttime = 0;\n\t\tmax = 100;\n\t\tamperage = -amperage;\n\t} else\n\t\tcharge = max = amperage = voltage = time = 0;\n\n\tpmu_batteries[pmu_cur_battery].flags = bat_flags;\n\tpmu_batteries[pmu_cur_battery].charge = charge;\n\tpmu_batteries[pmu_cur_battery].max_charge = max;\n\tpmu_batteries[pmu_cur_battery].amperage = amperage;\n\tpmu_batteries[pmu_cur_battery].voltage = voltage;\n\tpmu_batteries[pmu_cur_battery].time_remaining = time;\n#endif  \n\n\tclear_bit(0, &async_req_locks);\n}\n\nstatic void\ndone_battery_state_smart(struct adb_request* req)\n{\n\t \n\t \n\tunsigned int bat_flags = PMU_BATT_TYPE_SMART;\n\tint amperage;\n\tunsigned int capa, max, voltage;\n\t\n\tif (req->reply[1] & 0x01)\n\t\tpmu_power_flags |= PMU_PWR_AC_PRESENT;\n\telse\n\t\tpmu_power_flags &= ~PMU_PWR_AC_PRESENT;\n\n\n\tcapa = max = amperage = voltage = 0;\n\t\n\tif (req->reply[1] & 0x04) {\n\t\tbat_flags |= PMU_BATT_PRESENT;\n\t\tswitch(req->reply[0]) {\n\t\t\tcase 3:\n\t\t\tcase 4: capa = req->reply[2];\n\t\t\t\tmax = req->reply[3];\n\t\t\t\tamperage = *((signed char *)&req->reply[4]);\n\t\t\t\tvoltage = req->reply[5];\n\t\t\t\tbreak;\n\t\t\tcase 5: capa = (req->reply[2] << 8) | req->reply[3];\n\t\t\t\tmax = (req->reply[4] << 8) | req->reply[5];\n\t\t\t\tamperage = *((signed short *)&req->reply[6]);\n\t\t\t\tvoltage = (req->reply[8] << 8) | req->reply[9];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"pmu.c: unrecognized battery info, \"\n\t\t\t\t\t\"len: %d, %4ph\\n\", req->reply_len,\n\t\t\t\t\t\t\t   req->reply);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((req->reply[1] & 0x01) && (amperage > 0))\n\t\tbat_flags |= PMU_BATT_CHARGING;\n\n\tpmu_batteries[pmu_cur_battery].flags = bat_flags;\n\tpmu_batteries[pmu_cur_battery].charge = capa;\n\tpmu_batteries[pmu_cur_battery].max_charge = max;\n\tpmu_batteries[pmu_cur_battery].amperage = amperage;\n\tpmu_batteries[pmu_cur_battery].voltage = voltage;\n\tif (amperage) {\n\t\tif ((req->reply[1] & 0x01) && (amperage > 0))\n\t\t\tpmu_batteries[pmu_cur_battery].time_remaining\n\t\t\t\t= ((max-capa) * 3600) / amperage;\n\t\telse\n\t\t\tpmu_batteries[pmu_cur_battery].time_remaining\n\t\t\t\t= (capa * 3600) / (-amperage);\n\t} else\n\t\tpmu_batteries[pmu_cur_battery].time_remaining = 0;\n\n\tpmu_cur_battery = (pmu_cur_battery + 1) % pmu_battery_count;\n\n\tclear_bit(0, &async_req_locks);\n}\n\nstatic void\nquery_battery_state(void)\n{\n\tif (test_and_set_bit(0, &async_req_locks))\n\t\treturn;\n\tif (pmu_kind == PMU_OHARE_BASED)\n\t\tpmu_request(&batt_req, done_battery_state_ohare,\n\t\t\t1, PMU_BATTERY_STATE);\n\telse\n\t\tpmu_request(&batt_req, done_battery_state_smart,\n\t\t\t2, PMU_SMART_BATTERY_STATE, pmu_cur_battery+1);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int pmu_info_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"PMU driver version     : %d\\n\", PMU_DRIVER_VERSION);\n\tseq_printf(m, \"PMU firmware version   : %02x\\n\", pmu_version);\n\tseq_printf(m, \"AC Power               : %d\\n\",\n\t\t((pmu_power_flags & PMU_PWR_AC_PRESENT) != 0) || pmu_battery_count == 0);\n\tseq_printf(m, \"Battery count          : %d\\n\", pmu_battery_count);\n\n\treturn 0;\n}\n\nstatic int pmu_irqstats_proc_show(struct seq_file *m, void *v)\n{\n\tint i;\n\tstatic const char *irq_names[NUM_IRQ_STATS] = {\n\t\t\"Unknown interrupt (type 0)\",\n\t\t\"Unknown interrupt (type 1)\",\n\t\t\"PC-Card eject button\",\n\t\t\"Sound/Brightness button\",\n\t\t\"ADB message\",\n\t\t\"Battery state change\",\n\t\t\"Environment interrupt\",\n\t\t\"Tick timer\",\n\t\t\"Ghost interrupt (zero len)\",\n\t\t\"Empty interrupt (empty mask)\",\n\t\t\"Max irqs in a row\",\n\t\t\"Total CB1 triggered events\",\n\t\t\"Total GPIO1 triggered events\",\n        };\n\n\tfor (i = 0; i < NUM_IRQ_STATS; i++) {\n\t\tseq_printf(m, \" %2u: %10u (%s)\\n\",\n\t\t\t     i, pmu_irq_stats[i], irq_names[i]);\n\t}\n\treturn 0;\n}\n\nstatic int pmu_battery_proc_show(struct seq_file *m, void *v)\n{\n\tlong batnum = (long)m->private;\n\t\n\tseq_putc(m, '\\n');\n\tseq_printf(m, \"flags      : %08x\\n\", pmu_batteries[batnum].flags);\n\tseq_printf(m, \"charge     : %d\\n\", pmu_batteries[batnum].charge);\n\tseq_printf(m, \"max_charge : %d\\n\", pmu_batteries[batnum].max_charge);\n\tseq_printf(m, \"current    : %d\\n\", pmu_batteries[batnum].amperage);\n\tseq_printf(m, \"voltage    : %d\\n\", pmu_batteries[batnum].voltage);\n\tseq_printf(m, \"time rem.  : %d\\n\", pmu_batteries[batnum].time_remaining);\n\treturn 0;\n}\n\nstatic int pmu_options_proc_show(struct seq_file *m, void *v)\n{\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\n\tif (pmu_kind == PMU_KEYLARGO_BASED &&\n\t    pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)\n\t\tseq_printf(m, \"lid_wakeup=%d\\n\", option_lid_wakeup);\n#endif\n\tif (pmu_kind == PMU_KEYLARGO_BASED)\n\t\tseq_printf(m, \"server_mode=%d\\n\", option_server_mode);\n\n\treturn 0;\n}\n\nstatic int pmu_options_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pmu_options_proc_show, NULL);\n}\n\nstatic ssize_t pmu_options_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar tmp[33];\n\tchar *label, *val;\n\tsize_t fcount = count;\n\t\n\tif (!count)\n\t\treturn -EINVAL;\n\tif (count > 32)\n\t\tcount = 32;\n\tif (copy_from_user(tmp, buffer, count))\n\t\treturn -EFAULT;\n\ttmp[count] = 0;\n\n\tlabel = tmp;\n\twhile(*label == ' ')\n\t\tlabel++;\n\tval = label;\n\twhile(*val && (*val != '=')) {\n\t\tif (*val == ' ')\n\t\t\t*val = 0;\n\t\tval++;\n\t}\n\tif ((*val) == 0)\n\t\treturn -EINVAL;\n\t*(val++) = 0;\n\twhile(*val == ' ')\n\t\tval++;\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\n\tif (pmu_kind == PMU_KEYLARGO_BASED &&\n\t    pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)\n\t\tif (!strcmp(label, \"lid_wakeup\"))\n\t\t\toption_lid_wakeup = ((*val) == '1');\n#endif\n\tif (pmu_kind == PMU_KEYLARGO_BASED && !strcmp(label, \"server_mode\")) {\n\t\tint new_value;\n\t\tnew_value = ((*val) == '1');\n\t\tif (new_value != option_server_mode)\n\t\t\tpmu_set_server_mode(new_value);\n\t}\n\treturn fcount;\n}\n\nstatic const struct proc_ops pmu_options_proc_ops = {\n\t.proc_open\t= pmu_options_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= pmu_options_proc_write,\n};\n#endif\n\n#ifdef CONFIG_ADB\n \nstatic int pmu_send_request(struct adb_request *req, int sync)\n{\n\tint i, ret;\n\n\tif (pmu_state == uninitialized || !pmu_fully_inited) {\n\t\treq->complete = 1;\n\t\treturn -ENXIO;\n\t}\n\n\tret = -EINVAL;\n\n\tswitch (req->data[0]) {\n\tcase PMU_PACKET:\n\t\tfor (i = 0; i < req->nbytes - 1; ++i)\n\t\t\treq->data[i] = req->data[i+1];\n\t\t--req->nbytes;\n\t\tif (pmu_data_len[req->data[0]][1] != 0) {\n\t\t\treq->reply[0] = ADB_RET_OK;\n\t\t\treq->reply_len = 1;\n\t\t} else\n\t\t\treq->reply_len = 0;\n\t\tret = pmu_queue_request(req);\n\t\tbreak;\n\tcase CUDA_PACKET:\n\t\tswitch (req->data[1]) {\n\t\tcase CUDA_GET_TIME:\n\t\t\tif (req->nbytes != 2)\n\t\t\t\tbreak;\n\t\t\treq->data[0] = PMU_READ_RTC;\n\t\t\treq->nbytes = 1;\n\t\t\treq->reply_len = 3;\n\t\t\treq->reply[0] = CUDA_PACKET;\n\t\t\treq->reply[1] = 0;\n\t\t\treq->reply[2] = CUDA_GET_TIME;\n\t\t\tret = pmu_queue_request(req);\n\t\t\tbreak;\n\t\tcase CUDA_SET_TIME:\n\t\t\tif (req->nbytes != 6)\n\t\t\t\tbreak;\n\t\t\treq->data[0] = PMU_SET_RTC;\n\t\t\treq->nbytes = 5;\n\t\t\tfor (i = 1; i <= 4; ++i)\n\t\t\t\treq->data[i] = req->data[i+1];\n\t\t\treq->reply_len = 3;\n\t\t\treq->reply[0] = CUDA_PACKET;\n\t\t\treq->reply[1] = 0;\n\t\t\treq->reply[2] = CUDA_SET_TIME;\n\t\t\tret = pmu_queue_request(req);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ADB_PACKET:\n\t    \tif (!pmu_has_adb)\n    \t\t\treturn -ENXIO;\n\t\tfor (i = req->nbytes - 1; i > 1; --i)\n\t\t\treq->data[i+2] = req->data[i];\n\t\treq->data[3] = req->nbytes - 2;\n\t\treq->data[2] = pmu_adb_flags;\n\t\t \n\t\treq->data[0] = PMU_ADB_CMD;\n\t\treq->nbytes += 2;\n\t\treq->reply_expected = 1;\n\t\treq->reply_len = 0;\n\t\tret = pmu_queue_request(req);\n\t\tbreak;\n\t}\n\tif (ret) {\n\t\treq->complete = 1;\n\t\treturn ret;\n\t}\n\n\tif (sync)\n\t\twhile (!req->complete)\n\t\t\tpmu_poll();\n\n\treturn 0;\n}\n\n \nstatic int __pmu_adb_autopoll(int devs)\n{\n\tstruct adb_request req;\n\n\tif (devs) {\n\t\tpmu_request(&req, NULL, 5, PMU_ADB_CMD, 0, 0x86,\n\t\t\t    adb_dev_map >> 8, adb_dev_map);\n\t\tpmu_adb_flags = 2;\n\t} else {\n\t\tpmu_request(&req, NULL, 1, PMU_ADB_POLL_OFF);\n\t\tpmu_adb_flags = 0;\n\t}\n\twhile (!req.complete)\n\t\tpmu_poll();\n\treturn 0;\n}\n\nstatic int pmu_adb_autopoll(int devs)\n{\n\tif (pmu_state == uninitialized || !pmu_fully_inited || !pmu_has_adb)\n\t\treturn -ENXIO;\n\n\tadb_dev_map = devs;\n\treturn __pmu_adb_autopoll(devs);\n}\n\n \nstatic int pmu_adb_reset_bus(void)\n{\n\tstruct adb_request req;\n\tint save_autopoll = adb_dev_map;\n\n\tif (pmu_state == uninitialized || !pmu_fully_inited || !pmu_has_adb)\n\t\treturn -ENXIO;\n\n\t \n\t__pmu_adb_autopoll(0);\n\n\treq.nbytes = 4;\n\treq.done = NULL;\n\treq.data[0] = PMU_ADB_CMD;\n\treq.data[1] = ADB_BUSRESET;\n\treq.data[2] = 0;\n\treq.data[3] = 0;\n\treq.data[4] = 0;\n\treq.reply_len = 0;\n\treq.reply_expected = 1;\n\tif (pmu_queue_request(&req) != 0) {\n\t\tprintk(KERN_ERR \"pmu_adb_reset_bus: pmu_queue_request failed\\n\");\n\t\treturn -EIO;\n\t}\n\tpmu_wait_complete(&req);\n\n\tif (save_autopoll != 0)\n\t\t__pmu_adb_autopoll(save_autopoll);\n\n\treturn 0;\n}\n#endif  \n\n \nint\npmu_request(struct adb_request *req, void (*done)(struct adb_request *),\n\t    int nbytes, ...)\n{\n\tva_list list;\n\tint i;\n\n\tif (pmu_state == uninitialized)\n\t\treturn -ENXIO;\n\n\tif (nbytes < 0 || nbytes > 32) {\n\t\tprintk(KERN_ERR \"pmu_request: bad nbytes (%d)\\n\", nbytes);\n\t\treq->complete = 1;\n\t\treturn -EINVAL;\n\t}\n\treq->nbytes = nbytes;\n\treq->done = done;\n\tva_start(list, nbytes);\n\tfor (i = 0; i < nbytes; ++i)\n\t\treq->data[i] = va_arg(list, int);\n\tva_end(list);\n\treq->reply_len = 0;\n\treq->reply_expected = 0;\n\treturn pmu_queue_request(req);\n}\n\nint\npmu_queue_request(struct adb_request *req)\n{\n\tunsigned long flags;\n\tint nsend;\n\n\tif (pmu_state == uninitialized) {\n\t\treq->complete = 1;\n\t\treturn -ENXIO;\n\t}\n\tif (req->nbytes <= 0) {\n\t\treq->complete = 1;\n\t\treturn 0;\n\t}\n\tnsend = pmu_data_len[req->data[0]][0];\n\tif (nsend >= 0 && req->nbytes != nsend + 1) {\n\t\treq->complete = 1;\n\t\treturn -EINVAL;\n\t}\n\n\treq->next = NULL;\n\treq->sent = 0;\n\treq->complete = 0;\n\n\tspin_lock_irqsave(&pmu_lock, flags);\n\tif (current_req) {\n\t\tlast_req->next = req;\n\t\tlast_req = req;\n\t} else {\n\t\tcurrent_req = req;\n\t\tlast_req = req;\n\t\tif (pmu_state == idle)\n\t\t\tpmu_start();\n\t}\n\tspin_unlock_irqrestore(&pmu_lock, flags);\n\n\treturn 0;\n}\n\nstatic inline void\nwait_for_ack(void)\n{\n\t \n\tint timeout = 4000;\n\twhile ((in_8(&via2[B]) & TACK) == 0) {\n\t\tif (--timeout < 0) {\n\t\t\tprintk(KERN_ERR \"PMU not responding (!ack)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tudelay(10);\n\t}\n}\n\n \nstatic inline void\nsend_byte(int x)\n{\n\tout_8(&via1[ACR], in_8(&via1[ACR]) | SR_OUT | SR_EXT);\n\tout_8(&via1[SR], x);\n\tout_8(&via2[B], in_8(&via2[B]) & ~TREQ);\t \n\t(void)in_8(&via2[B]);\n}\n\nstatic inline void\nrecv_byte(void)\n{\n\tout_8(&via1[ACR], (in_8(&via1[ACR]) & ~SR_OUT) | SR_EXT);\n\tin_8(&via1[SR]);\t\t \n\tout_8(&via2[B], in_8(&via2[B]) & ~TREQ);\n\t(void)in_8(&via2[B]);\n}\n\nstatic inline void\npmu_done(struct adb_request *req)\n{\n\tvoid (*done)(struct adb_request *) = req->done;\n\tmb();\n\treq->complete = 1;\n    \t \n\tif (done)\n\t\t(*done)(req);\n}\n\nstatic void\npmu_start(void)\n{\n\tstruct adb_request *req;\n\n\t \n\t \n\treq = current_req;\n\tif (!req || pmu_state != idle\n\t    || ( req_awaiting_reply))\n\t\treturn;\n\n\tpmu_state = sending;\n\tdata_index = 1;\n\tdata_len = pmu_data_len[req->data[0]][0];\n\n\t \n\twait_for_ack();\n\t \n\tsend_byte(req->data[0]);\n}\n\nvoid\npmu_poll(void)\n{\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\tif (disable_poll)\n\t\treturn;\n\tvia_pmu_interrupt(0, NULL);\n}\n\nvoid\npmu_poll_adb(void)\n{\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\tif (disable_poll)\n\t\treturn;\n\t \n\tadb_int_pending = 1;\n\tdo {\n\t\tvia_pmu_interrupt(0, NULL);\n\t} while (pmu_suspended && (adb_int_pending || pmu_state != idle\n\t\t|| req_awaiting_reply));\n}\n\nvoid\npmu_wait_complete(struct adb_request *req)\n{\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\twhile((pmu_state != idle && pmu_state != locked) || !req->complete)\n\t\tvia_pmu_interrupt(0, NULL);\n}\n\n \nvoid\npmu_suspend(void)\n{\n\tunsigned long flags;\n\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\t\n\tspin_lock_irqsave(&pmu_lock, flags);\n\tpmu_suspended++;\n\tif (pmu_suspended > 1) {\n\t\tspin_unlock_irqrestore(&pmu_lock, flags);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tspin_unlock_irqrestore(&pmu_lock, flags);\n\t\tif (req_awaiting_reply)\n\t\t\tadb_int_pending = 1;\n\t\tvia_pmu_interrupt(0, NULL);\n\t\tspin_lock_irqsave(&pmu_lock, flags);\n\t\tif (!adb_int_pending && pmu_state == idle && !req_awaiting_reply) {\n\t\t\tif (gpio_irq >= 0)\n\t\t\t\tdisable_irq_nosync(gpio_irq);\n\t\t\tout_8(&via1[IER], CB1_INT | IER_CLR);\n\t\t\tspin_unlock_irqrestore(&pmu_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n}\n\nvoid\npmu_resume(void)\n{\n\tunsigned long flags;\n\n\tif (pmu_state == uninitialized || pmu_suspended < 1)\n\t\treturn;\n\n\tspin_lock_irqsave(&pmu_lock, flags);\n\tpmu_suspended--;\n\tif (pmu_suspended > 0) {\n\t\tspin_unlock_irqrestore(&pmu_lock, flags);\n\t\treturn;\n\t}\n\tadb_int_pending = 1;\n\tif (gpio_irq >= 0)\n\t\tenable_irq(gpio_irq);\n\tout_8(&via1[IER], CB1_INT | IER_SET);\n\tspin_unlock_irqrestore(&pmu_lock, flags);\n\tpmu_poll();\n}\n\n \nstatic void\npmu_handle_data(unsigned char *data, int len)\n{\n\tunsigned char ints;\n\tint idx;\n\tint i = 0;\n\n\tasleep = 0;\n\tif (drop_interrupts || len < 1) {\n\t\tadb_int_pending = 0;\n\t\tpmu_irq_stats[8]++;\n\t\treturn;\n\t}\n\n\t \n\tints = data[0];\n\n\t \n\tif (ints == 0)\n\t\tpmu_irq_stats[9]++;\n\n\t \n\tif (ints & PMU_INT_ADB)\n\t\tints &= ~(PMU_INT_ADB_AUTO | PMU_INT_AUTO_SRQ_POLL);\n\nnext:\n\tif (ints == 0) {\n\t\tif (i > pmu_irq_stats[10])\n\t\t\tpmu_irq_stats[10] = i;\n\t\treturn;\n\t}\n\ti++;\n\n\tidx = ffs(ints) - 1;\n\tints &= ~BIT(idx);\n\n\tpmu_irq_stats[idx]++;\n\n\t \n\tswitch (BIT(idx)) {\n\tcase PMU_INT_ADB:\n\t\tif ((data[0] & PMU_INT_ADB_AUTO) == 0) {\n\t\t\tstruct adb_request *req = req_awaiting_reply;\n\t\t\tif (!req) {\n\t\t\t\tprintk(KERN_ERR \"PMU: extra ADB reply\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treq_awaiting_reply = NULL;\n\t\t\tif (len <= 2)\n\t\t\t\treq->reply_len = 0;\n\t\t\telse {\n\t\t\t\tmemcpy(req->reply, data + 1, len - 1);\n\t\t\t\treq->reply_len = len - 1;\n\t\t\t}\n\t\t\tpmu_done(req);\n\t\t} else {\n#ifdef CONFIG_XMON\n\t\t\tif (len == 4 && data[1] == 0x2c) {\n\t\t\t\textern int xmon_wants_key, xmon_adb_keycode;\n\t\t\t\tif (xmon_wants_key) {\n\t\t\t\t\txmon_adb_keycode = data[2];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n#endif  \n#ifdef CONFIG_ADB\n\t\t\t \n\t\t\tif (!(pmu_kind == PMU_OHARE_BASED && len == 4\n\t\t\t      && data[1] == 0x2c && data[3] == 0xff\n\t\t\t      && (data[2] & ~1) == 0xf4))\n\t\t\t\tadb_input(data+1, len-1, 1);\n#endif  \t\t\n\t\t}\n\t\tbreak;\n\n\t \n\tcase PMU_INT_SNDBRT:\n#ifdef CONFIG_PMAC_BACKLIGHT\n\t\tif (len == 3)\n\t\t\tpmac_backlight_set_legacy_brightness_pmu(data[1] >> 4);\n#endif\n\t\tbreak;\n\n\t \n\tcase PMU_INT_TICK:\n\t\t \n\t\tif (pmu_battery_count) {\n\t\t\tif ((--query_batt_timer) == 0) {\n\t\t\t\tquery_battery_state();\n\t\t\t\tquery_batt_timer = BATTERY_POLLING_COUNT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PMU_INT_ENVIRONMENT:\n\t\tif (pmu_battery_count)\n\t\t\tquery_battery_state();\n\t\tpmu_pass_intr(data, len);\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ADB_PMU_EVENT) && len == 6) {\n\t\t\tvia_pmu_event(PMU_EVT_POWER, !!(data[1]&8));\n\t\t\tvia_pmu_event(PMU_EVT_LID, data[1]&1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t       pmu_pass_intr(data, len);\n\t}\n\tgoto next;\n}\n\nstatic struct adb_request*\npmu_sr_intr(void)\n{\n\tstruct adb_request *req;\n\tint bite = 0;\n\n\tif (in_8(&via2[B]) & TREQ) {\n\t\tprintk(KERN_ERR \"PMU: spurious SR intr (%x)\\n\", in_8(&via2[B]));\n\t\treturn NULL;\n\t}\n\t \n\twhile ((in_8(&via2[B]) & TACK) != 0)\n\t\t\t;\n\n\t \n\tif (pmu_state == reading || pmu_state == reading_intr)\n\t\tbite = in_8(&via1[SR]);\n\n\t \n\tout_8(&via2[B], in_8(&via2[B]) | TREQ);\n\twait_for_ack();\n\n\tswitch (pmu_state) {\n\tcase sending:\n\t\treq = current_req;\n\t\tif (data_len < 0) {\n\t\t\tdata_len = req->nbytes - 1;\n\t\t\tsend_byte(data_len);\n\t\t\tbreak;\n\t\t}\n\t\tif (data_index <= data_len) {\n\t\t\tsend_byte(req->data[data_index++]);\n\t\t\tbreak;\n\t\t}\n\t\treq->sent = 1;\n\t\tdata_len = pmu_data_len[req->data[0]][1];\n\t\tif (data_len == 0) {\n\t\t\tpmu_state = idle;\n\t\t\tcurrent_req = req->next;\n\t\t\tif (req->reply_expected)\n\t\t\t\treq_awaiting_reply = req;\n\t\t\telse\n\t\t\t\treturn req;\n\t\t} else {\n\t\t\tpmu_state = reading;\n\t\t\tdata_index = 0;\n\t\t\treply_ptr = req->reply + req->reply_len;\n\t\t\trecv_byte();\n\t\t}\n\t\tbreak;\n\n\tcase intack:\n\t\tdata_index = 0;\n\t\tdata_len = -1;\n\t\tpmu_state = reading_intr;\n\t\treply_ptr = interrupt_data[int_data_last];\n\t\trecv_byte();\n\t\tif (gpio_irq >= 0 && !gpio_irq_enabled) {\n\t\t\tenable_irq(gpio_irq);\n\t\t\tgpio_irq_enabled = 1;\n\t\t}\n\t\tbreak;\n\n\tcase reading:\n\tcase reading_intr:\n\t\tif (data_len == -1) {\n\t\t\tdata_len = bite;\n\t\t\tif (bite > 32)\n\t\t\t\tprintk(KERN_ERR \"PMU: bad reply len %d\\n\", bite);\n\t\t} else if (data_index < 32) {\n\t\t\treply_ptr[data_index++] = bite;\n\t\t}\n\t\tif (data_index < data_len) {\n\t\t\trecv_byte();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pmu_state == reading_intr) {\n\t\t\tpmu_state = idle;\n\t\t\tint_data_state[int_data_last] = int_data_ready;\n\t\t\tinterrupt_data_len[int_data_last] = data_len;\n\t\t} else {\n\t\t\treq = current_req;\n\t\t\t \n\t\t\tcurrent_req = req->next;\n\t\t\treq->reply_len += data_index;\n\t\t\tif (req->data[0] == PMU_SLEEP || req->data[0] == PMU_CPU_SPEED)\n\t\t\t\tpmu_state = locked;\n\t\t\telse\n\t\t\t\tpmu_state = idle;\n\t\t\treturn req;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"via_pmu_interrupt: unknown state %d?\\n\",\n\t\t       pmu_state);\n\t}\n\treturn NULL;\n}\n\nstatic irqreturn_t\nvia_pmu_interrupt(int irq, void *arg)\n{\n\tunsigned long flags;\n\tint intr;\n\tint nloop = 0;\n\tint int_data = -1;\n\tstruct adb_request *req = NULL;\n\tint handled = 0;\n\n\t \n\tspin_lock_irqsave(&pmu_lock, flags);\n\t++disable_poll;\n\t\n\tfor (;;) {\n\t\t \n\t\tintr = 0;\n\t\tif (IS_ENABLED(CONFIG_PPC_PMAC) || !irq) {\n\t\t\tintr = in_8(&via1[IFR]) & (SR_INT | CB1_INT);\n\t\t\tout_8(&via1[IFR], intr);\n\t\t}\n#ifndef CONFIG_PPC_PMAC\n\t\tswitch (irq) {\n\t\tcase IRQ_MAC_ADB_CL:\n\t\t\tintr = CB1_INT;\n\t\t\tbreak;\n\t\tcase IRQ_MAC_ADB_SR:\n\t\t\tintr = SR_INT;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif (intr == 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\tif (++nloop > 1000) {\n\t\t\tprintk(KERN_DEBUG \"PMU: stuck in intr loop, \"\n\t\t\t       \"intr=%x, ier=%x pmu_state=%d\\n\",\n\t\t\t       intr, in_8(&via1[IER]), pmu_state);\n\t\t\tbreak;\n\t\t}\n\t\tif (intr & CB1_INT) {\n\t\t\tadb_int_pending = 1;\n\t\t\tpmu_irq_stats[11]++;\n\t\t}\n\t\tif (intr & SR_INT) {\n\t\t\treq = pmu_sr_intr();\n\t\t\tif (req)\n\t\t\t\tbreak;\n\t\t}\n#ifndef CONFIG_PPC_PMAC\n\t\tbreak;\n#endif\n\t}\n\nrecheck:\n\tif (pmu_state == idle) {\n\t\tif (adb_int_pending) {\n\t\t\tif (int_data_state[0] == int_data_empty)\n\t\t\t\tint_data_last = 0;\n\t\t\telse if (int_data_state[1] == int_data_empty)\n\t\t\t\tint_data_last = 1;\n\t\t\telse\n\t\t\t\tgoto no_free_slot;\n\t\t\tpmu_state = intack;\n\t\t\tint_data_state[int_data_last] = int_data_fill;\n\t\t\t \n\t\t\twait_for_ack();\n\t\t\tsend_byte(PMU_INT_ACK);\n\t\t\tadb_int_pending = 0;\n\t\t} else if (current_req)\n\t\t\tpmu_start();\n\t}\nno_free_slot:\t\t\t\n\t \n\tif (int_data_state[!int_data_last] == int_data_ready) {\n\t\tint_data_state[!int_data_last] = int_data_flush;\n\t\tint_data = !int_data_last;\n\t} else if (int_data_state[int_data_last] == int_data_ready) {\n\t\tint_data_state[int_data_last] = int_data_flush;\n\t\tint_data = int_data_last;\n\t}\n\t--disable_poll;\n\tspin_unlock_irqrestore(&pmu_lock, flags);\n\n\t \n\tif (req) {\n\t\tpmu_done(req);\n\t\treq = NULL;\n\t}\n\t\t\n\t \n\tif (int_data >= 0) {\n\t\tpmu_handle_data(interrupt_data[int_data], interrupt_data_len[int_data]);\n\t\tspin_lock_irqsave(&pmu_lock, flags);\n\t\t++disable_poll;\n\t\tint_data_state[int_data] = int_data_empty;\n\t\tint_data = -1;\n\t\tgoto recheck;\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nvoid\npmu_unlock(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmu_lock, flags);\n\tif (pmu_state == locked)\n\t\tpmu_state = idle;\n\tadb_int_pending = 1;\n\tspin_unlock_irqrestore(&pmu_lock, flags);\n}\n\n\nstatic __maybe_unused irqreturn_t\ngpio1_interrupt(int irq, void *arg)\n{\n\tunsigned long flags;\n\n\tif ((in_8(gpio_reg + 0x9) & 0x02) == 0) {\n\t\tspin_lock_irqsave(&pmu_lock, flags);\n\t\tif (gpio_irq_enabled > 0) {\n\t\t\tdisable_irq_nosync(gpio_irq);\n\t\t\tgpio_irq_enabled = 0;\n\t\t}\n\t\tpmu_irq_stats[12]++;\n\t\tadb_int_pending = 1;\n\t\tspin_unlock_irqrestore(&pmu_lock, flags);\n\t\tvia_pmu_interrupt(0, NULL);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nvoid\npmu_enable_irled(int on)\n{\n\tstruct adb_request req;\n\n\tif (pmu_state == uninitialized)\n\t\treturn ;\n\tif (pmu_kind == PMU_KEYLARGO_BASED)\n\t\treturn ;\n\n\tpmu_request(&req, NULL, 2, PMU_POWER_CTRL, PMU_POW_IRLED |\n\t    (on ? PMU_POW_ON : PMU_POW_OFF));\n\tpmu_wait_complete(&req);\n}\n\n \n#define RTC_OFFSET\t2082844800\n\ntime64_t pmu_get_time(void)\n{\n\tstruct adb_request req;\n\tu32 now;\n\n\tif (pmu_request(&req, NULL, 1, PMU_READ_RTC) < 0)\n\t\treturn 0;\n\tpmu_wait_complete(&req);\n\tif (req.reply_len != 4)\n\t\tpr_err(\"%s: got %d byte reply\\n\", __func__, req.reply_len);\n\tnow = (req.reply[0] << 24) + (req.reply[1] << 16) +\n\t      (req.reply[2] << 8) + req.reply[3];\n\treturn (time64_t)now - RTC_OFFSET;\n}\n\nint pmu_set_rtc_time(struct rtc_time *tm)\n{\n\tu32 now;\n\tstruct adb_request req;\n\n\tnow = lower_32_bits(rtc_tm_to_time64(tm) + RTC_OFFSET);\n\tif (pmu_request(&req, NULL, 5, PMU_SET_RTC,\n\t                now >> 24, now >> 16, now >> 8, now) < 0)\n\t\treturn -ENXIO;\n\tpmu_wait_complete(&req);\n\tif (req.reply_len != 0)\n\t\tpr_err(\"%s: got %d byte reply\\n\", __func__, req.reply_len);\n\treturn 0;\n}\n\nvoid\npmu_restart(void)\n{\n\tstruct adb_request req;\n\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\n\tlocal_irq_disable();\n\n\tdrop_interrupts = 1;\n\t\n\tif (pmu_kind != PMU_KEYLARGO_BASED) {\n\t\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |\n\t\t\t\t\t\tPMU_INT_TICK );\n\t\twhile(!req.complete)\n\t\t\tpmu_poll();\n\t}\n\n\tpmu_request(&req, NULL, 1, PMU_RESET);\n\tpmu_wait_complete(&req);\n\tfor (;;)\n\t\t;\n}\n\nvoid\npmu_shutdown(void)\n{\n\tstruct adb_request req;\n\n\tif (pmu_state == uninitialized)\n\t\treturn;\n\n\tlocal_irq_disable();\n\n\tdrop_interrupts = 1;\n\n\tif (pmu_kind != PMU_KEYLARGO_BASED) {\n\t\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |\n\t\t\t\t\t\tPMU_INT_TICK );\n\t\tpmu_wait_complete(&req);\n\t} else {\n\t\t \n\t\tpmu_set_server_mode(0);\n\t}\n\n\tpmu_request(&req, NULL, 5, PMU_SHUTDOWN,\n\t\t    'M', 'A', 'T', 'T');\n\tpmu_wait_complete(&req);\n\tfor (;;)\n\t\t;\n}\n\nint\npmu_present(void)\n{\n\treturn pmu_state != uninitialized;\n}\n\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\n \n \nstatic u32 save_via[8];\nstatic int __fake_sleep;\n\nstatic void\nsave_via_state(void)\n{\n\tsave_via[0] = in_8(&via1[ANH]);\n\tsave_via[1] = in_8(&via1[DIRA]);\n\tsave_via[2] = in_8(&via1[B]);\n\tsave_via[3] = in_8(&via1[DIRB]);\n\tsave_via[4] = in_8(&via1[PCR]);\n\tsave_via[5] = in_8(&via1[ACR]);\n\tsave_via[6] = in_8(&via1[T1CL]);\n\tsave_via[7] = in_8(&via1[T1CH]);\n}\nstatic void\nrestore_via_state(void)\n{\n\tout_8(&via1[ANH],  save_via[0]);\n\tout_8(&via1[DIRA], save_via[1]);\n\tout_8(&via1[B],    save_via[2]);\n\tout_8(&via1[DIRB], save_via[3]);\n\tout_8(&via1[PCR],  save_via[4]);\n\tout_8(&via1[ACR],  save_via[5]);\n\tout_8(&via1[T1CL], save_via[6]);\n\tout_8(&via1[T1CH], save_via[7]);\n\tout_8(&via1[IER], IER_CLR | 0x7f);\t \n\tout_8(&via1[IFR], 0x7f);\t\t\t \n\tout_8(&via1[IER], IER_SET | SR_INT | CB1_INT);\n}\n\n#define\tGRACKLE_PM\t(1<<7)\n#define GRACKLE_DOZE\t(1<<5)\n#define\tGRACKLE_NAP\t(1<<4)\n#define\tGRACKLE_SLEEP\t(1<<3)\n\nstatic int powerbook_sleep_grackle(void)\n{\n\tunsigned long save_l2cr;\n\tunsigned short pmcr1;\n\tstruct adb_request req;\n\tstruct pci_dev *grackle;\n\n\tgrackle = pci_get_domain_bus_and_slot(0, 0, 0);\n\tif (!grackle)\n\t\treturn -ENODEV;\n\n\t \n\tpmu_request(&req, NULL, 2, PMU_POWER_CTRL0, PMU_POW0_OFF|PMU_POW0_HARD_DRIVE);\n\tpmu_wait_complete(&req);\n\tpmu_request(&req, NULL, 2, PMU_POWER_CTRL,\n\t\tPMU_POW_OFF|PMU_POW_BACKLIGHT|PMU_POW_IRLED|PMU_POW_MEDIABAY);\n\tpmu_wait_complete(&req);\n\n\t \n\tsave_l2cr = _get_L2CR();\t \n\n\tif (!__fake_sleep) {\n\t\t \n\t\tpmu_request(&req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\n\t\tpmu_wait_complete(&req);\n\t}\n\n\t \n\tsave_via_state();\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,1);\n\n\tpci_read_config_word(grackle, 0x70, &pmcr1);\n\t \n\tpmcr1 &= ~(GRACKLE_DOZE|GRACKLE_SLEEP); \n\tpmcr1 |= GRACKLE_PM|GRACKLE_NAP;\n\tpci_write_config_word(grackle, 0x70, pmcr1);\n\n\t \n\tif (__fake_sleep)\n\t\tmdelay(5000);\n\telse\n\t\tlow_sleep_handler();\n\n\t \n\tpci_read_config_word(grackle, 0x70, &pmcr1);\n\tpmcr1 &= ~(GRACKLE_PM|GRACKLE_DOZE|GRACKLE_SLEEP|GRACKLE_NAP); \n\tpci_write_config_word(grackle, 0x70, pmcr1);\n\n\tpci_dev_put(grackle);\n\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,0);\n\trestore_via_state();\n\t\n\t \n\tif (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)\n \t\t_set_L2CR(save_l2cr);\n\t\n\t \n\tswitch_mmu_context(NULL, current->active_mm, NULL);\n\n\t \n\tpmu_unlock();\n\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\n\tpmu_wait_complete(&req);\n\tpmu_request(&req, NULL, 2, PMU_POWER_CTRL0,\n\t\t\tPMU_POW0_ON|PMU_POW0_HARD_DRIVE);\n\tpmu_wait_complete(&req);\n\tpmu_request(&req, NULL, 2, PMU_POWER_CTRL,\n\t\t\tPMU_POW_ON|PMU_POW_BACKLIGHT|PMU_POW_CHARGER|PMU_POW_IRLED|PMU_POW_MEDIABAY);\n\tpmu_wait_complete(&req);\n\n\treturn 0;\n}\n\nstatic int\npowerbook_sleep_Core99(void)\n{\n\tunsigned long save_l2cr;\n\tunsigned long save_l3cr;\n\tstruct adb_request req;\n\t\n\tif (pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) < 0) {\n\t\tprintk(KERN_ERR \"Sleep mode not supported on this machine\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (num_online_cpus() > 1 || cpu_is_offline(0))\n\t\treturn -EAGAIN;\n\n\t \n\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, 0);\n\tpmu_wait_complete(&req);\n\n\t \n\tpmu_request(&req, NULL, 4, PMU_POWER_EVENTS, PMU_PWR_CLR_WAKEUP_EVENTS,\n\t\t0xff, 0xff);\n\tpmu_wait_complete(&req);\n\tpmu_request(&req, NULL, 4, PMU_POWER_EVENTS, PMU_PWR_SET_WAKEUP_EVENTS,\n\t\t0, PMU_PWR_WAKEUP_KEY |\n\t\t(option_lid_wakeup ? PMU_PWR_WAKEUP_LID_OPEN : 0));\n\tpmu_wait_complete(&req);\n\n\t \n\tsave_l3cr = _get_L3CR();\t \n\tsave_l2cr = _get_L2CR();\t \n\n\tif (!__fake_sleep) {\n\t\t \n\t\tpmu_request(&req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\n\t\tpmu_wait_complete(&req);\n\t}\n\n\t \n\tsave_via_state();\n\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 1);\n\n\t \n\tif (__fake_sleep)\n\t\tmdelay(5000);\n\telse\n\t\tlow_sleep_handler();\n\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 0);\n\n\t \n\trestore_via_state();\n\n\t \n\tloops_per_jiffy *= 2;\n\n\t \n\tpmac_call_early_video_resume();\n\n\t \n\tif (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)\n \t\t_set_L2CR(save_l2cr);\n\t \n\tif (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)\n \t\t_set_L3CR(save_l3cr);\n\t\n\t \n\tswitch_mmu_context(NULL, current->active_mm, NULL);\n\n\t \n\tpmu_unlock();\n\tpmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\n\tpmu_wait_complete(&req);\n\tpmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\n\tpmu_wait_complete(&req);\n\n\t \n\tloops_per_jiffy /= 2;\n\n\treturn 0;\n}\n\n#define PB3400_MEM_CTRL\t\t0xf8000000\n#define PB3400_MEM_CTRL_SLEEP\t0x70\n\nstatic void __iomem *pb3400_mem_ctrl;\n\nstatic void powerbook_sleep_init_3400(void)\n{\n\t \n\tpb3400_mem_ctrl = ioremap(PB3400_MEM_CTRL, 0x100);\n\tif (pb3400_mem_ctrl == NULL)\n\t\tprintk(KERN_WARNING \"ioremap failed: sleep won't be possible\");\n}\n\nstatic int powerbook_sleep_3400(void)\n{\n\tint i, x;\n\tunsigned int hid0;\n\tunsigned long msr;\n\tstruct adb_request sleep_req;\n\tunsigned int __iomem *mem_ctrl_sleep;\n\n\tif (pb3400_mem_ctrl == NULL)\n\t\treturn -ENOMEM;\n\tmem_ctrl_sleep = pb3400_mem_ctrl + PB3400_MEM_CTRL_SLEEP;\n\n\t \n\tfor (i = 0x403f; i >= 0x4000; --i) {\n\t\tout_be32(mem_ctrl_sleep, i);\n\t\tdo {\n\t\t\tx = (in_be32(mem_ctrl_sleep) >> 16) & 0x3ff;\n\t\t} while (x == 0);\n\t\tif (x >= 0x100)\n\t\t\tbreak;\n\t}\n\n\t \n\tpmu_request(&sleep_req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\n\tpmu_wait_complete(&sleep_req);\n\tpmu_unlock();\n\n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 1);\n\n\tasleep = 1;\n\n\t \n\thid0 = mfspr(SPRN_HID0);\n\thid0 = (hid0 & ~(HID0_NAP | HID0_DOZE)) | HID0_SLEEP;\n\tmtspr(SPRN_HID0, hid0);\n\tlocal_irq_enable();\n\tmsr = mfmsr() | MSR_POW;\n\twhile (asleep) {\n\t\tmb();\n\t\tmtmsr(msr);\n\t\tisync();\n\t}\n\tlocal_irq_disable();\n\n\t \n\tout_be32(mem_ctrl_sleep, 0x3f);\n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 0);\n\n\treturn 0;\n}\n\n#endif  \n\n \n#define RB_SIZE\t\t0x10\nstruct pmu_private {\n\tstruct list_head list;\n\tint\trb_get;\n\tint\trb_put;\n\tstruct rb_entry {\n\t\tunsigned short len;\n\t\tunsigned char data[16];\n\t}\trb_buf[RB_SIZE];\n\twait_queue_head_t wait;\n\tspinlock_t lock;\n#if defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_PMAC_BACKLIGHT)\n\tint\tbacklight_locker;\n#endif\n};\n\nstatic LIST_HEAD(all_pmu_pvt);\nstatic DEFINE_SPINLOCK(all_pvt_lock);\n\nstatic void\npmu_pass_intr(unsigned char *data, int len)\n{\n\tstruct pmu_private *pp;\n\tstruct list_head *list;\n\tint i;\n\tunsigned long flags;\n\n\tif (len > sizeof(pp->rb_buf[0].data))\n\t\tlen = sizeof(pp->rb_buf[0].data);\n\tspin_lock_irqsave(&all_pvt_lock, flags);\n\tfor (list = &all_pmu_pvt; (list = list->next) != &all_pmu_pvt; ) {\n\t\tpp = list_entry(list, struct pmu_private, list);\n\t\tspin_lock(&pp->lock);\n\t\ti = pp->rb_put + 1;\n\t\tif (i >= RB_SIZE)\n\t\t\ti = 0;\n\t\tif (i != pp->rb_get) {\n\t\t\tstruct rb_entry *rp = &pp->rb_buf[pp->rb_put];\n\t\t\trp->len = len;\n\t\t\tmemcpy(rp->data, data, len);\n\t\t\tpp->rb_put = i;\n\t\t\twake_up_interruptible(&pp->wait);\n\t\t}\n\t\tspin_unlock(&pp->lock);\n\t}\n\tspin_unlock_irqrestore(&all_pvt_lock, flags);\n}\n\nstatic int\npmu_open(struct inode *inode, struct file *file)\n{\n\tstruct pmu_private *pp;\n\tunsigned long flags;\n\n\tpp = kmalloc(sizeof(struct pmu_private), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\tpp->rb_get = pp->rb_put = 0;\n\tspin_lock_init(&pp->lock);\n\tinit_waitqueue_head(&pp->wait);\n\tmutex_lock(&pmu_info_proc_mutex);\n\tspin_lock_irqsave(&all_pvt_lock, flags);\n#if defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_PMAC_BACKLIGHT)\n\tpp->backlight_locker = 0;\n#endif\n\tlist_add(&pp->list, &all_pmu_pvt);\n\tspin_unlock_irqrestore(&all_pvt_lock, flags);\n\tfile->private_data = pp;\n\tmutex_unlock(&pmu_info_proc_mutex);\n\treturn 0;\n}\n\nstatic ssize_t \npmu_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct pmu_private *pp = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (count < 1 || !pp)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&pp->lock, flags);\n\tadd_wait_queue(&pp->wait, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\tfor (;;) {\n\t\tret = -EAGAIN;\n\t\tif (pp->rb_get != pp->rb_put) {\n\t\t\tint i = pp->rb_get;\n\t\t\tstruct rb_entry *rp = &pp->rb_buf[i];\n\t\t\tret = rp->len;\n\t\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\t\tif (ret > count)\n\t\t\t\tret = count;\n\t\t\tif (ret > 0 && copy_to_user(buf, rp->data, ret))\n\t\t\t\tret = -EFAULT;\n\t\t\tif (++i >= RB_SIZE)\n\t\t\t\ti = 0;\n\t\t\tspin_lock_irqsave(&pp->lock, flags);\n\t\t\tpp->rb_get = i;\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&pp->lock, flags);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pp->wait, &wait);\n\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\n\treturn ret;\n}\n\nstatic ssize_t\npmu_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\nstatic __poll_t\npmu_fpoll(struct file *filp, poll_table *wait)\n{\n\tstruct pmu_private *pp = filp->private_data;\n\t__poll_t mask = 0;\n\tunsigned long flags;\n\t\n\tif (!pp)\n\t\treturn 0;\n\tpoll_wait(filp, &pp->wait, wait);\n\tspin_lock_irqsave(&pp->lock, flags);\n\tif (pp->rb_get != pp->rb_put)\n\t\tmask |= EPOLLIN;\n\tspin_unlock_irqrestore(&pp->lock, flags);\n\treturn mask;\n}\n\nstatic int\npmu_release(struct inode *inode, struct file *file)\n{\n\tstruct pmu_private *pp = file->private_data;\n\tunsigned long flags;\n\n\tif (pp) {\n\t\tfile->private_data = NULL;\n\t\tspin_lock_irqsave(&all_pvt_lock, flags);\n\t\tlist_del(&pp->list);\n\t\tspin_unlock_irqrestore(&all_pvt_lock, flags);\n\n#if defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_PMAC_BACKLIGHT)\n\t\tif (pp->backlight_locker)\n\t\t\tpmac_backlight_enable();\n#endif\n\n\t\tkfree(pp);\n\t}\n\treturn 0;\n}\n\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\nstatic void pmac_suspend_disable_irqs(void)\n{\n\t \n\tpmac_pfunc_i2c_suspend();\n\tpmac_pfunc_base_suspend();\n}\n\nstatic int powerbook_sleep(suspend_state_t state)\n{\n\tint error = 0;\n\n\t \n\twhile (!batt_req.complete)\n\t\tpmu_poll();\n\n\t \n\tenable_kernel_fp();\n\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tenable_kernel_altivec();\n#endif  \n\n\tswitch (pmu_kind) {\n\tcase PMU_OHARE_BASED:\n\t\terror = powerbook_sleep_3400();\n\t\tbreak;\n\tcase PMU_HEATHROW_BASED:\n\tcase PMU_PADDINGTON_BASED:\n\t\terror = powerbook_sleep_grackle();\n\t\tbreak;\n\tcase PMU_KEYLARGO_BASED:\n\t\terror = powerbook_sleep_Core99();\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\tmdelay(100);\n\n\treturn 0;\n}\n\nstatic void pmac_suspend_enable_irqs(void)\n{\n\t \n\tadb_int_pending = 1;\n\tvia_pmu_interrupt(0, NULL);\n\n\tmdelay(10);\n\n\t \n\tpmac_pfunc_base_resume();\n\tpmac_pfunc_i2c_resume();\n}\n\nstatic int pmu_sleep_valid(suspend_state_t state)\n{\n\treturn state == PM_SUSPEND_MEM\n\t\t&& (pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, -1) >= 0);\n}\n\nstatic const struct platform_suspend_ops pmu_pm_ops = {\n\t.enter = powerbook_sleep,\n\t.valid = pmu_sleep_valid,\n};\n\nstatic int register_pmu_pm_ops(void)\n{\n\tif (pmu_kind == PMU_OHARE_BASED)\n\t\tpowerbook_sleep_init_3400();\n\tppc_md.suspend_disable_irqs = pmac_suspend_disable_irqs;\n\tppc_md.suspend_enable_irqs = pmac_suspend_enable_irqs;\n\tsuspend_set_ops(&pmu_pm_ops);\n\n\treturn 0;\n}\n\ndevice_initcall(register_pmu_pm_ops);\n#endif\n\nstatic int pmu_ioctl(struct file *filp,\n\t\t     u_int cmd, u_long arg)\n{\n\t__u32 __user *argp = (__u32 __user *)arg;\n\tint error = -EINVAL;\n\n\tswitch (cmd) {\n#ifdef CONFIG_PPC_PMAC\n\tcase PMU_IOC_SLEEP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\treturn pm_suspend(PM_SUSPEND_MEM);\n\tcase PMU_IOC_CAN_SLEEP:\n\t\tif (pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, -1) < 0)\n\t\t\treturn put_user(0, argp);\n\t\telse\n\t\t\treturn put_user(1, argp);\n#endif\n\n#ifdef CONFIG_PMAC_BACKLIGHT_LEGACY\n\t \n\tcase PMU_IOC_GET_BACKLIGHT:\n\t{\n\t\tint brightness;\n\n\t\tbrightness = pmac_backlight_get_legacy_brightness();\n\t\tif (brightness < 0)\n\t\t\treturn brightness;\n\t\telse\n\t\t\treturn put_user(brightness, argp);\n\n\t}\n\tcase PMU_IOC_SET_BACKLIGHT:\n\t{\n\t\tint brightness;\n\n\t\terror = get_user(brightness, argp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn pmac_backlight_set_legacy_brightness(brightness);\n\t}\n#ifdef CONFIG_INPUT_ADBHID\n\tcase PMU_IOC_GRAB_BACKLIGHT: {\n\t\tstruct pmu_private *pp = filp->private_data;\n\n\t\tif (pp->backlight_locker)\n\t\t\treturn 0;\n\n\t\tpp->backlight_locker = 1;\n\t\tpmac_backlight_disable();\n\n\t\treturn 0;\n\t}\n#endif  \n#endif  \n\n\tcase PMU_IOC_GET_MODEL:\n\t    \treturn put_user(pmu_kind, argp);\n\tcase PMU_IOC_HAS_ADB:\n\t\treturn put_user(pmu_has_adb, argp);\n\t}\n\treturn error;\n}\n\nstatic long pmu_unlocked_ioctl(struct file *filp,\n\t\t\t       u_int cmd, u_long arg)\n{\n\tint ret;\n\n\tmutex_lock(&pmu_info_proc_mutex);\n\tret = pmu_ioctl(filp, cmd, arg);\n\tmutex_unlock(&pmu_info_proc_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n#define PMU_IOC_GET_BACKLIGHT32\t_IOR('B', 1, compat_size_t)\n#define PMU_IOC_SET_BACKLIGHT32\t_IOW('B', 2, compat_size_t)\n#define PMU_IOC_GET_MODEL32\t_IOR('B', 3, compat_size_t)\n#define PMU_IOC_HAS_ADB32\t_IOR('B', 4, compat_size_t)\n#define PMU_IOC_CAN_SLEEP32\t_IOR('B', 5, compat_size_t)\n#define PMU_IOC_GRAB_BACKLIGHT32 _IOR('B', 6, compat_size_t)\n\nstatic long compat_pmu_ioctl (struct file *filp, u_int cmd, u_long arg)\n{\n\tswitch (cmd) {\n\tcase PMU_IOC_SLEEP:\n\t\tbreak;\n\tcase PMU_IOC_GET_BACKLIGHT32:\n\t\tcmd = PMU_IOC_GET_BACKLIGHT;\n\t\tbreak;\n\tcase PMU_IOC_SET_BACKLIGHT32:\n\t\tcmd = PMU_IOC_SET_BACKLIGHT;\n\t\tbreak;\n\tcase PMU_IOC_GET_MODEL32:\n\t\tcmd = PMU_IOC_GET_MODEL;\n\t\tbreak;\n\tcase PMU_IOC_HAS_ADB32:\n\t\tcmd = PMU_IOC_HAS_ADB;\n\t\tbreak;\n\tcase PMU_IOC_CAN_SLEEP32:\n\t\tcmd = PMU_IOC_CAN_SLEEP;\n\t\tbreak;\n\tcase PMU_IOC_GRAB_BACKLIGHT32:\n\t\tcmd = PMU_IOC_GRAB_BACKLIGHT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn pmu_unlocked_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations pmu_device_fops = {\n\t.read\t\t= pmu_read,\n\t.write\t\t= pmu_write,\n\t.poll\t\t= pmu_fpoll,\n\t.unlocked_ioctl\t= pmu_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= compat_pmu_ioctl,\n#endif\n\t.open\t\t= pmu_open,\n\t.release\t= pmu_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice pmu_device = {\n\tPMU_MINOR, \"pmu\", &pmu_device_fops\n};\n\nstatic int pmu_device_init(void)\n{\n\tif (pmu_state == uninitialized)\n\t\treturn 0;\n\tif (misc_register(&pmu_device) < 0)\n\t\tprintk(KERN_ERR \"via-pmu: cannot register misc device.\\n\");\n\treturn 0;\n}\ndevice_initcall(pmu_device_init);\n\n\n#ifdef DEBUG_SLEEP\nstatic inline void \npolled_handshake(void)\n{\n\tvia2[B] &= ~TREQ; eieio();\n\twhile ((via2[B] & TACK) != 0)\n\t\t;\n\tvia2[B] |= TREQ; eieio();\n\twhile ((via2[B] & TACK) == 0)\n\t\t;\n}\n\nstatic inline void \npolled_send_byte(int x)\n{\n\tvia1[ACR] |= SR_OUT | SR_EXT; eieio();\n\tvia1[SR] = x; eieio();\n\tpolled_handshake();\n}\n\nstatic inline int\npolled_recv_byte(void)\n{\n\tint x;\n\n\tvia1[ACR] = (via1[ACR] & ~SR_OUT) | SR_EXT; eieio();\n\tx = via1[SR]; eieio();\n\tpolled_handshake();\n\tx = via1[SR]; eieio();\n\treturn x;\n}\n\nint\npmu_polled_request(struct adb_request *req)\n{\n\tunsigned long flags;\n\tint i, l, c;\n\n\treq->complete = 1;\n\tc = req->data[0];\n\tl = pmu_data_len[c][0];\n\tif (l >= 0 && req->nbytes != l + 1)\n\t\treturn -EINVAL;\n\n\tlocal_irq_save(flags);\n\twhile (pmu_state != idle)\n\t\tpmu_poll();\n\n\twhile ((via2[B] & TACK) == 0)\n\t\t;\n\tpolled_send_byte(c);\n\tif (l < 0) {\n\t\tl = req->nbytes - 1;\n\t\tpolled_send_byte(l);\n\t}\n\tfor (i = 1; i <= l; ++i)\n\t\tpolled_send_byte(req->data[i]);\n\n\tl = pmu_data_len[c][1];\n\tif (l < 0)\n\t\tl = polled_recv_byte();\n\tfor (i = 0; i < l; ++i)\n\t\treq->reply[i + req->reply_len] = polled_recv_byte();\n\n\tif (req->done)\n\t\t(*req->done)(req);\n\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n \nvoid pmu_blink(int n)\n{\n\tstruct adb_request req;\n\n\tmemset(&req, 0, sizeof(req));\n\n\tfor (; n > 0; --n) {\n\t\treq.nbytes = 4;\n\t\treq.done = NULL;\n\t\treq.data[0] = 0xee;\n\t\treq.data[1] = 4;\n\t\treq.data[2] = 0;\n\t\treq.data[3] = 1;\n\t\treq.reply[0] = ADB_RET_OK;\n\t\treq.reply_len = 1;\n\t\treq.reply_expected = 0;\n\t\tpmu_polled_request(&req);\n\t\tmdelay(50);\n\t\treq.nbytes = 4;\n\t\treq.done = NULL;\n\t\treq.data[0] = 0xee;\n\t\treq.data[1] = 4;\n\t\treq.data[2] = 0;\n\t\treq.data[3] = 0;\n\t\treq.reply[0] = ADB_RET_OK;\n\t\treq.reply_len = 1;\n\t\treq.reply_expected = 0;\n\t\tpmu_polled_request(&req);\n\t\tmdelay(50);\n\t}\n\tmdelay(50);\n}\n#endif  \n\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\nint pmu_sys_suspended;\n\nstatic int pmu_syscore_suspend(void)\n{\n\t \n\tpmu_suspend();\n\tpmu_sys_suspended = 1;\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\t \n\tpmu_backlight_set_sleep(1);\n#endif\n\n\treturn 0;\n}\n\nstatic void pmu_syscore_resume(void)\n{\n\tstruct adb_request req;\n\n\tif (!pmu_sys_suspended)\n\t\treturn;\n\n\t \n\tpmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\n\tpmu_wait_complete(&req);\n\n#ifdef CONFIG_PMAC_BACKLIGHT\n\t \n\tpmu_backlight_set_sleep(0);\n#endif\n\t \n\tpmu_resume();\n\tpmu_sys_suspended = 0;\n}\n\nstatic struct syscore_ops pmu_syscore_ops = {\n\t.suspend = pmu_syscore_suspend,\n\t.resume = pmu_syscore_resume,\n};\n\nstatic int pmu_syscore_register(void)\n{\n\tregister_syscore_ops(&pmu_syscore_ops);\n\n\treturn 0;\n}\nsubsys_initcall(pmu_syscore_register);\n#endif  \n\nEXPORT_SYMBOL(pmu_request);\nEXPORT_SYMBOL(pmu_queue_request);\nEXPORT_SYMBOL(pmu_poll);\nEXPORT_SYMBOL(pmu_poll_adb);\nEXPORT_SYMBOL(pmu_wait_complete);\nEXPORT_SYMBOL(pmu_suspend);\nEXPORT_SYMBOL(pmu_resume);\nEXPORT_SYMBOL(pmu_unlock);\n#if defined(CONFIG_PPC32)\nEXPORT_SYMBOL(pmu_enable_irled);\nEXPORT_SYMBOL(pmu_battery_count);\nEXPORT_SYMBOL(pmu_batteries);\nEXPORT_SYMBOL(pmu_power_flags);\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}