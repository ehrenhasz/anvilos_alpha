{
  "module_name": "rack-meter.c",
  "hash_id": "f8253666817d51d136de7b2168c753228c93a55a694c1c4e7a49efe4e884cbe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/rack-meter.c",
  "human_readable_source": "\n \n#undef DEBUG\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel_stat.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/io.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/dbdma.h>\n#include <asm/macio.h>\n#include <asm/keylargo.h>\n\n \n#define SAMPLE_COUNT\t\t256\n\n \n#define CPU_SAMPLING_RATE\t250\n\nstruct rackmeter_dma {\n\tstruct dbdma_cmd\tcmd[4]\t\t\t____cacheline_aligned;\n\tu32\t\t\tmark\t\t\t____cacheline_aligned;\n\tu32\t\t\tbuf1[SAMPLE_COUNT]\t____cacheline_aligned;\n\tu32\t\t\tbuf2[SAMPLE_COUNT]\t____cacheline_aligned;\n} ____cacheline_aligned;\n\nstruct rackmeter_cpu {\n\tstruct delayed_work\tsniffer;\n\tstruct rackmeter\t*rm;\n\tu64\t\t\tprev_wall;\n\tu64\t\t\tprev_idle;\n\tint\t\t\tzero;\n} ____cacheline_aligned;\n\nstruct rackmeter {\n\tstruct macio_dev\t\t*mdev;\n\tunsigned int\t\t\tirq;\n\tstruct device_node\t\t*i2s;\n\tu8\t\t\t\t*ubuf;\n\tstruct dbdma_regs __iomem\t*dma_regs;\n\tvoid __iomem\t\t\t*i2s_regs;\n\tdma_addr_t\t\t\tdma_buf_p;\n\tstruct rackmeter_dma\t\t*dma_buf_v;\n\tint\t\t\t\tstale_irq;\n\tstruct rackmeter_cpu\t\tcpu[2];\n\tint\t\t\t\tpaused;\n\tstruct mutex\t\t\tsem;\n};\n\n \nstatic int rackmeter_ignore_nice;\n\n \n#define RACKMETER_MAGIC_GPIO\t0x78\n\n \nstatic inline u64 get_cpu_idle_time(unsigned int cpu)\n{\n\tstruct kernel_cpustat *kcpustat = &kcpustat_cpu(cpu);\n\tu64 retval;\n\n\tretval = kcpustat->cpustat[CPUTIME_IDLE] +\n\t\t kcpustat->cpustat[CPUTIME_IOWAIT];\n\n\tif (rackmeter_ignore_nice)\n\t\tretval += kcpustat_field(kcpustat, CPUTIME_NICE, cpu);\n\n\treturn retval;\n}\n\nstatic void rackmeter_setup_i2s(struct rackmeter *rm)\n{\n\tstruct macio_chip *macio = rm->mdev->bus->chip;\n\n\t \n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, RACKMETER_MAGIC_GPIO, 5);\n\n\n\t \n\tpmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, rm->i2s, 0, 1);\n\n\t \n\tMACIO_BIS(KEYLARGO_FCR1, KL1_I2S0_ENABLE);\n\tMACIO_BIC(KEYLARGO_FCR1, KL1_I2S0_CLK_ENABLE_BIT);\n\t(void)MACIO_IN32(KEYLARGO_FCR1);\n\tudelay(10);\n\n\t \n\tout_le32(rm->i2s_regs + 0x10, 0x01fa0000);\n\t(void)in_le32(rm->i2s_regs + 0x10);\n\tudelay(10);\n\n\t \n\tMACIO_BIS(KEYLARGO_FCR1, KL1_I2S0_CELL_ENABLE |\n\t\t  KL1_I2S0_CLK_ENABLE_BIT);\n\t(void)MACIO_IN32(KEYLARGO_FCR1);\n\tudelay(10);\n}\n\nstatic void rackmeter_set_default_pattern(struct rackmeter *rm)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (i < 8)\n\t\t\trm->ubuf[i] = (i & 1) * 255;\n\t\telse\n\t\t\trm->ubuf[i] = ((~i) & 1) * 255;\n\t}\n}\n\nstatic void rackmeter_do_pause(struct rackmeter *rm, int pause)\n{\n\tstruct rackmeter_dma *rdma = rm->dma_buf_v;\n\n\tpr_debug(\"rackmeter: %s\\n\", pause ? \"paused\" : \"started\");\n\n\trm->paused = pause;\n\tif (pause) {\n\t\tDBDMA_DO_STOP(rm->dma_regs);\n\t\treturn;\n\t}\n\tmemset(rdma->buf1, 0, sizeof(rdma->buf1));\n\tmemset(rdma->buf2, 0, sizeof(rdma->buf2));\n\n\trm->dma_buf_v->mark = 0;\n\n\tmb();\n\tout_le32(&rm->dma_regs->cmdptr_hi, 0);\n\tout_le32(&rm->dma_regs->cmdptr, rm->dma_buf_p);\n\tout_le32(&rm->dma_regs->control, (RUN << 16) | RUN);\n}\n\nstatic void rackmeter_setup_dbdma(struct rackmeter *rm)\n{\n\tstruct rackmeter_dma *db = rm->dma_buf_v;\n\tstruct dbdma_cmd *cmd = db->cmd;\n\n\t \n\tDBDMA_DO_RESET(rm->dma_regs);\n\n\tpr_debug(\"rackmeter: mark offset=0x%zx\\n\",\n\t\t offsetof(struct rackmeter_dma, mark));\n\tpr_debug(\"rackmeter: buf1 offset=0x%zx\\n\",\n\t\t offsetof(struct rackmeter_dma, buf1));\n\tpr_debug(\"rackmeter: buf2 offset=0x%zx\\n\",\n\t\t offsetof(struct rackmeter_dma, buf2));\n\n\t \n\tmemset(cmd, 0, 4 * sizeof(struct dbdma_cmd));\n\tcmd->req_count = cpu_to_le16(4);\n\tcmd->command = cpu_to_le16(STORE_WORD | INTR_ALWAYS | KEY_SYSTEM);\n\tcmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\n\t\toffsetof(struct rackmeter_dma, mark));\n\tcmd->cmd_dep = cpu_to_le32(0x02000000);\n\tcmd++;\n\n\tcmd->req_count = cpu_to_le16(SAMPLE_COUNT * 4);\n\tcmd->command = cpu_to_le16(OUTPUT_MORE);\n\tcmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\n\t\toffsetof(struct rackmeter_dma, buf1));\n\tcmd++;\n\n\tcmd->req_count = cpu_to_le16(4);\n\tcmd->command = cpu_to_le16(STORE_WORD | INTR_ALWAYS | KEY_SYSTEM);\n\tcmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\n\t\toffsetof(struct rackmeter_dma, mark));\n\tcmd->cmd_dep = cpu_to_le32(0x01000000);\n\tcmd++;\n\n\tcmd->req_count = cpu_to_le16(SAMPLE_COUNT * 4);\n\tcmd->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS);\n\tcmd->phy_addr = cpu_to_le32(rm->dma_buf_p +\n\t\toffsetof(struct rackmeter_dma, buf2));\n\tcmd->cmd_dep = cpu_to_le32(rm->dma_buf_p);\n\n\trackmeter_do_pause(rm, 0);\n}\n\nstatic void rackmeter_do_timer(struct work_struct *work)\n{\n\tstruct rackmeter_cpu *rcpu =\n\t\tcontainer_of(work, struct rackmeter_cpu, sniffer.work);\n\tstruct rackmeter *rm = rcpu->rm;\n\tunsigned int cpu = smp_processor_id();\n\tu64 cur_nsecs, total_idle_nsecs;\n\tu64 total_nsecs, idle_nsecs;\n\tint i, offset, load, cumm, pause;\n\n\tcur_nsecs = jiffies64_to_nsecs(get_jiffies_64());\n\ttotal_nsecs = cur_nsecs - rcpu->prev_wall;\n\trcpu->prev_wall = cur_nsecs;\n\n\ttotal_idle_nsecs = get_cpu_idle_time(cpu);\n\tidle_nsecs = total_idle_nsecs - rcpu->prev_idle;\n\tidle_nsecs = min(idle_nsecs, total_nsecs);\n\trcpu->prev_idle = total_idle_nsecs;\n\n\t \n\tload = div64_u64(9 * (total_nsecs - idle_nsecs), total_nsecs);\n\n\toffset = cpu << 3;\n\tcumm = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tu8 ub = (load > i) ? 0xff : 0;\n\t\trm->ubuf[i + offset] = ub;\n\t\tcumm |= ub;\n\t}\n\trcpu->zero = (cumm == 0);\n\n\t \n\tpause = (rm->cpu[0].zero && rm->cpu[1].zero);\n\tif (pause != rm->paused) {\n\t\tmutex_lock(&rm->sem);\n\t\tpause = (rm->cpu[0].zero && rm->cpu[1].zero);\n\t\trackmeter_do_pause(rm, pause);\n\t\tmutex_unlock(&rm->sem);\n\t}\n\tschedule_delayed_work_on(cpu, &rcpu->sniffer,\n\t\t\t\t msecs_to_jiffies(CPU_SAMPLING_RATE));\n}\n\nstatic void rackmeter_init_cpu_sniffer(struct rackmeter *rm)\n{\n\tunsigned int cpu;\n\n\t \n\n\trm->cpu[0].rm = rm;\n\tINIT_DELAYED_WORK(&rm->cpu[0].sniffer, rackmeter_do_timer);\n\trm->cpu[1].rm = rm;\n\tINIT_DELAYED_WORK(&rm->cpu[1].sniffer, rackmeter_do_timer);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct rackmeter_cpu *rcpu;\n\n\t\tif (cpu > 1)\n\t\t\tcontinue;\n\t\trcpu = &rm->cpu[cpu];\n\t\trcpu->prev_idle = get_cpu_idle_time(cpu);\n\t\trcpu->prev_wall = jiffies64_to_nsecs(get_jiffies_64());\n\t\tschedule_delayed_work_on(cpu, &rm->cpu[cpu].sniffer,\n\t\t\t\t\t msecs_to_jiffies(CPU_SAMPLING_RATE));\n\t}\n}\n\nstatic void rackmeter_stop_cpu_sniffer(struct rackmeter *rm)\n{\n\tcancel_delayed_work_sync(&rm->cpu[0].sniffer);\n\tcancel_delayed_work_sync(&rm->cpu[1].sniffer);\n}\n\nstatic int rackmeter_setup(struct rackmeter *rm)\n{\n\tpr_debug(\"rackmeter: setting up i2s..\\n\");\n\trackmeter_setup_i2s(rm);\n\n\tpr_debug(\"rackmeter: setting up default pattern..\\n\");\n\trackmeter_set_default_pattern(rm);\n\n\tpr_debug(\"rackmeter: setting up dbdma..\\n\");\n\trackmeter_setup_dbdma(rm);\n\n\tpr_debug(\"rackmeter: start CPU measurements..\\n\");\n\trackmeter_init_cpu_sniffer(rm);\n\n\tprintk(KERN_INFO \"RackMeter initialized\\n\");\n\n\treturn 0;\n}\n\n \nstatic u32 rackmeter_calc_sample(struct rackmeter *rm, unsigned int index)\n{\n\tint led;\n\tu32 sample = 0;\n\n\tfor (led = 0; led < 16; led++) {\n\t\tsample >>= 1;\n\t\tsample |= ((rm->ubuf[led] >= 0x80) << 15);\n\t}\n\treturn (sample << 17) | (sample >> 15);\n}\n\nstatic irqreturn_t rackmeter_irq(int irq, void *arg)\n{\n\tstruct rackmeter *rm = arg;\n\tstruct rackmeter_dma *db = rm->dma_buf_v;\n\tunsigned int mark, i;\n\tu32 *buf;\n\n\t \n\t(void)in_le32(&rm->dma_regs->status);\n\n\t \n\trmb();\n\n\t \n\tmark = db->mark;\n\tif (mark != 1 && mark != 2) {\n\t\tprintk(KERN_WARNING \"rackmeter: Incorrect DMA mark 0x%08x\\n\",\n\t\t       mark);\n\t\t \n\t\tif (++rm->stale_irq > 3) {\n\t\t\tprintk(KERN_ERR \"rackmeter: Too many errors,\"\n\t\t\t       \" stopping DMA\\n\");\n\t\t\tDBDMA_DO_RESET(rm->dma_regs);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tbuf = mark == 1 ? db->buf1 : db->buf2;\n\n\t \n\tfor (i = 0; i < SAMPLE_COUNT; i++)\n\t\tbuf[i] = rackmeter_calc_sample(rm, i);\n\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rackmeter_probe(struct macio_dev* mdev,\n\t\t\t   const struct of_device_id *match)\n{\n\tstruct device_node *i2s = NULL, *np = NULL;\n\tstruct rackmeter *rm = NULL;\n\tstruct resource ri2s, rdma;\n\tint rc = -ENODEV;\n\n\tpr_debug(\"rackmeter_probe()\\n\");\n\n\t \n\tfor_each_child_of_node(mdev->ofdev.dev.of_node, i2s)\n\t\tif (of_node_name_eq(i2s, \"i2s-a\"))\n\t\t\tbreak;\n\n\tif (i2s == NULL) {\n\t\tpr_debug(\"  i2s-a child not found\\n\");\n\t\tgoto bail;\n\t}\n\t \n\tfor_each_child_of_node(i2s, np) {\n\t       if (of_node_name_eq(np, \"lightshow\"))\n\t\t       break;\n\t       if (of_node_name_eq(np, \"sound\") &&\n\t\t   of_property_present(np, \"virtual\"))\n\t\t       break;\n\t}\n\tif (np == NULL) {\n\t\tpr_debug(\"  lightshow or sound+virtual child not found\\n\");\n\t\tgoto bail;\n\t}\n\n\t \n\trm = kzalloc(sizeof(*rm), GFP_KERNEL);\n\tif (rm == NULL) {\n\t\tprintk(KERN_ERR \"rackmeter: failed to allocate memory !\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto bail_release;\n\t}\n\trm->mdev = mdev;\n\trm->i2s = i2s;\n\tmutex_init(&rm->sem);\n\tdev_set_drvdata(&mdev->ofdev.dev, rm);\n\t \n#if 0  \n\tif (macio_resource_count(mdev) < 2 || macio_irq_count(mdev) < 2) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: found match but lacks resources: %pOF\"\n\t\t       \" (%d resources, %d interrupts)\\n\",\n\t\t       mdev->ofdev.dev.of_node);\n\t\trc = -ENXIO;\n\t\tgoto bail_free;\n\t}\n\tif (macio_request_resources(mdev, \"rackmeter\")) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to request resources: %pOF\\n\",\n\t\t       mdev->ofdev.dev.of_node);\n\t\trc = -EBUSY;\n\t\tgoto bail_free;\n\t}\n\trm->irq = macio_irq(mdev, 1);\n#else\n\trm->irq = irq_of_parse_and_map(i2s, 1);\n\tif (!rm->irq ||\n\t    of_address_to_resource(i2s, 0, &ri2s) ||\n\t    of_address_to_resource(i2s, 1, &rdma)) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: found match but lacks resources: %pOF\",\n\t\t       mdev->ofdev.dev.of_node);\n\t\trc = -ENXIO;\n\t\tgoto bail_free;\n\t}\n#endif\n\n\tpr_debug(\"  i2s @0x%08x\\n\", (unsigned int)ri2s.start);\n\tpr_debug(\"  dma @0x%08x\\n\", (unsigned int)rdma.start);\n\tpr_debug(\"  irq %d\\n\", rm->irq);\n\n\trm->ubuf = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (rm->ubuf == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to allocate samples page !\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto bail_release;\n\t}\n\n\trm->dma_buf_v = dma_alloc_coherent(&macio_get_pci_dev(mdev)->dev,\n\t\t\t\t\t   sizeof(struct rackmeter_dma),\n\t\t\t\t\t   &rm->dma_buf_p, GFP_KERNEL);\n\tif (rm->dma_buf_v == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to allocate dma buffer !\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto bail_free_samples;\n\t}\n#if 0\n\trm->i2s_regs = ioremap(macio_resource_start(mdev, 0), 0x1000);\n#else\n\trm->i2s_regs = ioremap(ri2s.start, 0x1000);\n#endif\n\tif (rm->i2s_regs == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to map i2s registers !\\n\");\n\t\trc = -ENXIO;\n\t\tgoto bail_free_dma;\n\t}\n#if 0\n\trm->dma_regs = ioremap(macio_resource_start(mdev, 1), 0x100);\n#else\n\trm->dma_regs = ioremap(rdma.start, 0x100);\n#endif\n\tif (rm->dma_regs == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to map dma registers !\\n\");\n\t\trc = -ENXIO;\n\t\tgoto bail_unmap_i2s;\n\t}\n\n\trc = rackmeter_setup(rm);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to initialize !\\n\");\n\t\trc = -ENXIO;\n\t\tgoto bail_unmap_dma;\n\t}\n\n\trc = request_irq(rm->irq, rackmeter_irq, 0, \"rackmeter\", rm);\n\tif (rc != 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"rackmeter: failed to request interrupt !\\n\");\n\t\tgoto bail_stop_dma;\n\t}\n\tof_node_put(np);\n\treturn 0;\n\n bail_stop_dma:\n\tDBDMA_DO_RESET(rm->dma_regs);\n bail_unmap_dma:\n\tiounmap(rm->dma_regs);\n bail_unmap_i2s:\n\tiounmap(rm->i2s_regs);\n bail_free_dma:\n\tdma_free_coherent(&macio_get_pci_dev(mdev)->dev,\n\t\t\t  sizeof(struct rackmeter_dma),\n\t\t\t  rm->dma_buf_v, rm->dma_buf_p);\n bail_free_samples:\n\tfree_page((unsigned long)rm->ubuf);\n bail_release:\n#if 0\n\tmacio_release_resources(mdev);\n#endif\n bail_free:\n\tkfree(rm);\n bail:\n\tof_node_put(i2s);\n\tof_node_put(np);\n\tdev_set_drvdata(&mdev->ofdev.dev, NULL);\n\treturn rc;\n}\n\nstatic int rackmeter_remove(struct macio_dev* mdev)\n{\n\tstruct rackmeter *rm = dev_get_drvdata(&mdev->ofdev.dev);\n\n\t \n\trackmeter_stop_cpu_sniffer(rm);\n\n\t \n\tdev_set_drvdata(&mdev->ofdev.dev, NULL);\n\n\t \n\tDBDMA_DO_RESET(rm->dma_regs);\n\n\t \n\tfree_irq(rm->irq, rm);\n\n\t \n\tiounmap(rm->dma_regs);\n\tiounmap(rm->i2s_regs);\n\n\t \n\tdma_free_coherent(&macio_get_pci_dev(mdev)->dev,\n\t\t\t  sizeof(struct rackmeter_dma),\n\t\t\t  rm->dma_buf_v, rm->dma_buf_p);\n\n\t \n\tfree_page((unsigned long)rm->ubuf);\n\n#if 0\n\t \n\tmacio_release_resources(mdev);\n#endif\n\n\t \n\tkfree(rm);\n\n\treturn 0;\n}\n\nstatic int rackmeter_shutdown(struct macio_dev* mdev)\n{\n\tstruct rackmeter *rm = dev_get_drvdata(&mdev->ofdev.dev);\n\n\tif (rm == NULL)\n\t\treturn -ENODEV;\n\n\t \n\trackmeter_stop_cpu_sniffer(rm);\n\n\t \n\tDBDMA_DO_RESET(rm->dma_regs);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rackmeter_match[] = {\n\t{ .name = \"i2s\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rackmeter_match);\n\nstatic struct macio_driver rackmeter_driver = {\n\t.driver = {\n\t\t.name = \"rackmeter\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = rackmeter_match,\n\t},\n\t.probe = rackmeter_probe,\n\t.remove = rackmeter_remove,\n\t.shutdown = rackmeter_shutdown,\n};\n\n\nstatic int __init rackmeter_init(void)\n{\n\tpr_debug(\"rackmeter_init()\\n\");\n\n\treturn macio_register_driver(&rackmeter_driver);\n}\n\nstatic void __exit rackmeter_exit(void)\n{\n\tpr_debug(\"rackmeter_exit()\\n\");\n\n\tmacio_unregister_driver(&rackmeter_driver);\n}\n\nmodule_init(rackmeter_init);\nmodule_exit(rackmeter_exit);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"RackMeter: Support vu-meter on XServe front panel\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}