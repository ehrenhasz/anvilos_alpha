{
  "module_name": "ams-input.c",
  "hash_id": "7d255fdf6d8e1ba84646abd101412d49b3ad02b9501830c33cd5b75036fd16ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/ams/ams-input.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"ams.h\"\n\nstatic bool joystick;\nmodule_param(joystick, bool, S_IRUGO);\nMODULE_PARM_DESC(joystick, \"Enable the input class device on module load\");\n\nstatic bool invert;\nmodule_param(invert, bool, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(invert, \"Invert input data on X and Y axis\");\n\nstatic DEFINE_MUTEX(ams_input_mutex);\n\nstatic void ams_idev_poll(struct input_dev *idev)\n{\n\ts8 x, y, z;\n\n\tmutex_lock(&ams_info.lock);\n\n\tams_sensors(&x, &y, &z);\n\n\tx -= ams_info.xcalib;\n\ty -= ams_info.ycalib;\n\tz -= ams_info.zcalib;\n\n\tinput_report_abs(idev, ABS_X, invert ? -x : x);\n\tinput_report_abs(idev, ABS_Y, invert ? -y : y);\n\tinput_report_abs(idev, ABS_Z, z);\n\n\tinput_sync(idev);\n\n\tmutex_unlock(&ams_info.lock);\n}\n\n \nstatic int ams_input_enable(void)\n{\n\tstruct input_dev *input;\n\ts8 x, y, z;\n\tint error;\n\n\tams_sensors(&x, &y, &z);\n\tams_info.xcalib = x;\n\tams_info.ycalib = y;\n\tams_info.zcalib = z;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Apple Motion Sensor\";\n\tinput->id.bustype = ams_info.bustype;\n\tinput->id.vendor = 0;\n\tinput->dev.parent = &ams_info.of_dev->dev;\n\n\tinput_set_abs_params(input, ABS_X, -50, 50, 3, 0);\n\tinput_set_abs_params(input, ABS_Y, -50, 50, 3, 0);\n\tinput_set_abs_params(input, ABS_Z, -50, 50, 3, 0);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\n\terror = input_setup_polling(input, ams_idev_poll);\n\tif (error)\n\t\tgoto err_free_input;\n\n\tinput_set_poll_interval(input, 25);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\tgoto err_free_input;\n\n\tams_info.idev = input;\n\tjoystick = true;\n\n\treturn 0;\n\nerr_free_input:\n\tinput_free_device(input);\n\treturn error;\n}\n\nstatic void ams_input_disable(void)\n{\n\tif (ams_info.idev) {\n\t\tinput_unregister_device(ams_info.idev);\n\t\tams_info.idev = NULL;\n\t}\n\n\tjoystick = false;\n}\n\nstatic ssize_t ams_input_show_joystick(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", joystick);\n}\n\nstatic ssize_t ams_input_store_joystick(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long enable;\n\tint error = 0;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &enable);\n\tif (ret)\n\t\treturn ret;\n\tif (enable > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ams_input_mutex);\n\n\tif (enable != joystick) {\n\t\tif (enable)\n\t\t\terror = ams_input_enable();\n\t\telse\n\t\t\tams_input_disable();\n\t}\n\n\tmutex_unlock(&ams_input_mutex);\n\n\treturn error ? error : count;\n}\n\nstatic DEVICE_ATTR(joystick, S_IRUGO | S_IWUSR,\n\tams_input_show_joystick, ams_input_store_joystick);\n\nint ams_input_init(void)\n{\n\tif (joystick)\n\t\tams_input_enable();\n\n\treturn device_create_file(&ams_info.of_dev->dev, &dev_attr_joystick);\n}\n\nvoid ams_input_exit(void)\n{\n\tdevice_remove_file(&ams_info.of_dev->dev, &dev_attr_joystick);\n\n\tmutex_lock(&ams_input_mutex);\n\tams_input_disable();\n\tmutex_unlock(&ams_input_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}