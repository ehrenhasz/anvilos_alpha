{
  "module_name": "ams-i2c.c",
  "hash_id": "5f4ebc43d270906c02d5e8cf2365ad0451f002b47be21ccb0ebf31c8eb8949f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/ams/ams-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n\n#include \"ams.h\"\n\n \n#define AMS_COMMAND\t0x00\t \n#define AMS_STATUS\t0x01\t \n#define AMS_CTRL1\t0x02\t \n#define AMS_CTRL2\t0x03\t \n#define AMS_CTRL3\t0x04\t \n#define AMS_DATA1\t0x05\t \n#define AMS_DATA2\t0x06\t \n#define AMS_DATA3\t0x07\t \n#define AMS_DATA4\t0x08\t \n#define AMS_DATAX\t0x20\t \n#define AMS_DATAY\t0x21\t \n#define AMS_DATAZ\t0x22\t \n#define AMS_FREEFALL\t0x24\t \n#define AMS_SHOCK\t0x25\t \n#define AMS_SENSLOW\t0x26\t \n#define AMS_SENSHIGH\t0x27\t \n#define AMS_CTRLX\t0x28\t \n#define AMS_CTRLY\t0x29\t \n#define AMS_CTRLZ\t0x2A\t \n#define AMS_UNKNOWN1\t0x2B\t \n#define AMS_UNKNOWN2\t0x2C\t \n#define AMS_UNKNOWN3\t0x2D\t \n#define AMS_VENDOR\t0x2E\t \n\n \nenum ams_i2c_cmd {\n\tAMS_CMD_NOOP = 0,\n\tAMS_CMD_VERSION,\n\tAMS_CMD_READMEM,\n\tAMS_CMD_WRITEMEM,\n\tAMS_CMD_ERASEMEM,\n\tAMS_CMD_READEE,\n\tAMS_CMD_WRITEEE,\n\tAMS_CMD_RESET,\n\tAMS_CMD_START,\n};\n\nstatic int ams_i2c_probe(struct i2c_client *client);\nstatic void ams_i2c_remove(struct i2c_client *client);\n\nstatic const struct i2c_device_id ams_id[] = {\n\t{ \"MAC,accelerometer_1\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ams_id);\n\nstatic struct i2c_driver ams_i2c_driver = {\n\t.driver = {\n\t\t.name   = \"ams\",\n\t},\n\t.probe          = ams_i2c_probe,\n\t.remove         = ams_i2c_remove,\n\t.id_table       = ams_id,\n};\n\nstatic s32 ams_i2c_read(u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(ams_info.i2c_client, reg);\n}\n\nstatic int ams_i2c_write(u8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(ams_info.i2c_client, reg, value);\n}\n\nstatic int ams_i2c_cmd(enum ams_i2c_cmd cmd)\n{\n\ts32 result;\n\tint count = 3;\n\n\tams_i2c_write(AMS_COMMAND, cmd);\n\tmsleep(5);\n\n\twhile (count--) {\n\t\tresult = ams_i2c_read(AMS_COMMAND);\n\t\tif (result == 0 || result & 0x80)\n\t\t\treturn 0;\n\n\t\tschedule_timeout_uninterruptible(HZ / 20);\n\t}\n\n\treturn -1;\n}\n\nstatic void ams_i2c_set_irq(enum ams_irq reg, char enable)\n{\n\tif (reg & AMS_IRQ_FREEFALL) {\n\t\tu8 val = ams_i2c_read(AMS_CTRLX);\n\t\tif (enable)\n\t\t\tval |= 0x80;\n\t\telse\n\t\t\tval &= ~0x80;\n\t\tams_i2c_write(AMS_CTRLX, val);\n\t}\n\n\tif (reg & AMS_IRQ_SHOCK) {\n\t\tu8 val = ams_i2c_read(AMS_CTRLY);\n\t\tif (enable)\n\t\t\tval |= 0x80;\n\t\telse\n\t\t\tval &= ~0x80;\n\t\tams_i2c_write(AMS_CTRLY, val);\n\t}\n\n\tif (reg & AMS_IRQ_GLOBAL) {\n\t\tu8 val = ams_i2c_read(AMS_CTRLZ);\n\t\tif (enable)\n\t\t\tval |= 0x80;\n\t\telse\n\t\t\tval &= ~0x80;\n\t\tams_i2c_write(AMS_CTRLZ, val);\n\t}\n}\n\nstatic void ams_i2c_clear_irq(enum ams_irq reg)\n{\n\tif (reg & AMS_IRQ_FREEFALL)\n\t\tams_i2c_write(AMS_FREEFALL, 0);\n\n\tif (reg & AMS_IRQ_SHOCK)\n\t\tams_i2c_write(AMS_SHOCK, 0);\n}\n\nstatic u8 ams_i2c_get_vendor(void)\n{\n\treturn ams_i2c_read(AMS_VENDOR);\n}\n\nstatic void ams_i2c_get_xyz(s8 *x, s8 *y, s8 *z)\n{\n\t*x = ams_i2c_read(AMS_DATAX);\n\t*y = ams_i2c_read(AMS_DATAY);\n\t*z = ams_i2c_read(AMS_DATAZ);\n}\n\nstatic int ams_i2c_probe(struct i2c_client *client)\n{\n\tint vmaj, vmin;\n\tint result;\n\n\t \n\tif (unlikely(ams_info.has_device))\n\t\treturn -ENODEV;\n\n\tams_info.i2c_client = client;\n\n\tif (ams_i2c_cmd(AMS_CMD_RESET)) {\n\t\tprintk(KERN_INFO \"ams: Failed to reset the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ams_i2c_cmd(AMS_CMD_START)) {\n\t\tprintk(KERN_INFO \"ams: Failed to start the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tams_i2c_write(AMS_CTRL1, 0x02);\n\tams_i2c_write(AMS_CTRL2, 0x85);\n\tams_i2c_write(AMS_CTRL3, 0x01);\n\n\tams_i2c_cmd(AMS_CMD_READMEM);\n\n\tvmaj = ams_i2c_read(AMS_DATA1);\n\tvmin = ams_i2c_read(AMS_DATA2);\n\tif (vmaj != 1 || vmin != 52) {\n\t\tprintk(KERN_INFO \"ams: Incorrect device version (%d.%d)\\n\",\n\t\t\tvmaj, vmin);\n\t\treturn -ENODEV;\n\t}\n\n\tams_i2c_cmd(AMS_CMD_VERSION);\n\n\tvmaj = ams_i2c_read(AMS_DATA1);\n\tvmin = ams_i2c_read(AMS_DATA2);\n\tif (vmaj != 0 || vmin != 1) {\n\t\tprintk(KERN_INFO \"ams: Incorrect firmware version (%d.%d)\\n\",\n\t\t\tvmaj, vmin);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tams_i2c_set_irq(AMS_IRQ_ALL, 0);\n\n\tresult = ams_sensor_attach();\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tams_i2c_write(AMS_SENSLOW, 0x15);\n\tams_i2c_write(AMS_SENSHIGH, 0x60);\n\tams_i2c_write(AMS_CTRLX, 0x08);\n\tams_i2c_write(AMS_CTRLY, 0x0F);\n\tams_i2c_write(AMS_CTRLZ, 0x4F);\n\tams_i2c_write(AMS_UNKNOWN1, 0x14);\n\n\t \n\tams_i2c_clear_irq(AMS_IRQ_ALL);\n\n\tams_info.has_device = 1;\n\n\t \n\tams_i2c_set_irq(AMS_IRQ_ALL, 1);\n\n\tprintk(KERN_INFO \"ams: Found I2C based motion sensor\\n\");\n\n\treturn 0;\n}\n\nstatic void ams_i2c_remove(struct i2c_client *client)\n{\n\tif (ams_info.has_device) {\n\t\tams_sensor_detach();\n\n\t\t \n\t\tams_i2c_set_irq(AMS_IRQ_ALL, 0);\n\n\t\t \n\t\tams_i2c_clear_irq(AMS_IRQ_ALL);\n\n\t\tprintk(KERN_INFO \"ams: Unloading\\n\");\n\n\t\tams_info.has_device = 0;\n\t}\n}\n\nstatic void ams_i2c_exit(void)\n{\n\ti2c_del_driver(&ams_i2c_driver);\n}\n\nint __init ams_i2c_init(struct device_node *np)\n{\n\t \n\tams_info.of_node = np;\n\tams_info.exit = ams_i2c_exit;\n\tams_info.get_vendor = ams_i2c_get_vendor;\n\tams_info.get_xyz = ams_i2c_get_xyz;\n\tams_info.clear_irq = ams_i2c_clear_irq;\n\tams_info.bustype = BUS_I2C;\n\n\treturn i2c_add_driver(&ams_i2c_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}