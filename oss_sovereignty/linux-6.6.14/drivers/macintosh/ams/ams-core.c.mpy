{
  "module_name": "ams-core.c",
  "hash_id": "782004905d5a5c1cb6b41c58878f60ad72fe00bc24bc7828426351cb439150be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/ams/ams-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/of_platform.h>\n#include <asm/pmac_pfunc.h>\n\n#include \"ams.h\"\n\n \nstruct ams ams_info;\n\nstatic bool verbose;\nmodule_param(verbose, bool, 0644);\nMODULE_PARM_DESC(verbose, \"Show free falls and shocks in kernel output\");\n\n \nvoid ams_sensors(s8 *x, s8 *y, s8 *z)\n{\n\tu32 orient = ams_info.vflag? ams_info.orient1 : ams_info.orient2;\n\n\tif (orient & 0x80)\n\t\t \n\t\tams_info.get_xyz(y, x, z);\n\telse\n\t\tams_info.get_xyz(x, y, z);\n\n\tif (orient & 0x04)\n\t\t*z = ~(*z);\n\tif (orient & 0x02)\n\t\t*y = ~(*y);\n\tif (orient & 0x01)\n\t\t*x = ~(*x);\n}\n\nstatic ssize_t ams_show_current(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\ts8 x, y, z;\n\n\tmutex_lock(&ams_info.lock);\n\tams_sensors(&x, &y, &z);\n\tmutex_unlock(&ams_info.lock);\n\n\treturn sysfs_emit(buf, \"%d %d %d\\n\", x, y, z);\n}\n\nstatic DEVICE_ATTR(current, S_IRUGO, ams_show_current, NULL);\n\nstatic void ams_handle_irq(void *data)\n{\n\tenum ams_irq irq = *((enum ams_irq *)data);\n\n\tspin_lock(&ams_info.irq_lock);\n\n\tams_info.worker_irqs |= irq;\n\tschedule_work(&ams_info.worker);\n\n\tspin_unlock(&ams_info.irq_lock);\n}\n\nstatic enum ams_irq ams_freefall_irq_data = AMS_IRQ_FREEFALL;\nstatic struct pmf_irq_client ams_freefall_client = {\n\t.owner = THIS_MODULE,\n\t.handler = ams_handle_irq,\n\t.data = &ams_freefall_irq_data,\n};\n\nstatic enum ams_irq ams_shock_irq_data = AMS_IRQ_SHOCK;\nstatic struct pmf_irq_client ams_shock_client = {\n\t.owner = THIS_MODULE,\n\t.handler = ams_handle_irq,\n\t.data = &ams_shock_irq_data,\n};\n\n \nstatic void ams_worker(struct work_struct *work)\n{\n\tunsigned long flags;\n\tu8 irqs_to_clear;\n\n\tmutex_lock(&ams_info.lock);\n\n\tspin_lock_irqsave(&ams_info.irq_lock, flags);\n\tirqs_to_clear = ams_info.worker_irqs;\n\n\tif (ams_info.worker_irqs & AMS_IRQ_FREEFALL) {\n\t\tif (verbose)\n\t\t\tprintk(KERN_INFO \"ams: freefall detected!\\n\");\n\n\t\tams_info.worker_irqs &= ~AMS_IRQ_FREEFALL;\n\t}\n\n\tif (ams_info.worker_irqs & AMS_IRQ_SHOCK) {\n\t\tif (verbose)\n\t\t\tprintk(KERN_INFO \"ams: shock detected!\\n\");\n\n\t\tams_info.worker_irqs &= ~AMS_IRQ_SHOCK;\n\t}\n\n\tspin_unlock_irqrestore(&ams_info.irq_lock, flags);\n\n\tams_info.clear_irq(irqs_to_clear);\n\n\tmutex_unlock(&ams_info.lock);\n}\n\n \nint ams_sensor_attach(void)\n{\n\tint result;\n\tconst u32 *prop;\n\n\t \n\tprop = of_get_property(ams_info.of_node, \"orientation\", NULL);\n\tif (!prop)\n\t\treturn -ENODEV;\n\tams_info.orient1 = *prop;\n\tams_info.orient2 = *(prop + 1);\n\n\t \n\tresult = pmf_register_irq_client(ams_info.of_node,\n\t\t\t\"accel-int-1\",\n\t\t\t&ams_freefall_client);\n\tif (result < 0)\n\t\treturn -ENODEV;\n\n\t \n\tams_info.worker_irqs = 0;\n\n\t \n\tresult = pmf_register_irq_client(ams_info.of_node,\n\t\t\t\"accel-int-2\",\n\t\t\t&ams_shock_client);\n\tif (result < 0)\n\t\tgoto release_freefall;\n\n\t \n\tams_info.of_dev = of_platform_device_create(ams_info.of_node, \"ams\", NULL);\n\tif (!ams_info.of_dev) {\n\t\tresult = -ENODEV;\n\t\tgoto release_shock;\n\t}\n\n\t \n\tresult = device_create_file(&ams_info.of_dev->dev, &dev_attr_current);\n\tif (result)\n\t\tgoto release_of;\n\n\tams_info.vflag = !!(ams_info.get_vendor() & 0x10);\n\n\t \n\tresult = ams_input_init();\n\tif (result)\n\t\tgoto release_device_file;\n\n\treturn result;\nrelease_device_file:\n\tdevice_remove_file(&ams_info.of_dev->dev, &dev_attr_current);\nrelease_of:\n\tof_device_unregister(ams_info.of_dev);\nrelease_shock:\n\tpmf_unregister_irq_client(&ams_shock_client);\nrelease_freefall:\n\tpmf_unregister_irq_client(&ams_freefall_client);\n\treturn result;\n}\n\nstatic int __init ams_init(void)\n{\n\tstruct device_node *np;\n\n\tspin_lock_init(&ams_info.irq_lock);\n\tmutex_init(&ams_info.lock);\n\tINIT_WORK(&ams_info.worker, ams_worker);\n\n#ifdef CONFIG_SENSORS_AMS_I2C\n\tnp = of_find_node_by_name(NULL, \"accelerometer\");\n\tif (np && of_device_is_compatible(np, \"AAPL,accelerometer_1\"))\n\t\t \n\t\treturn ams_i2c_init(np);\n#endif\n\n#ifdef CONFIG_SENSORS_AMS_PMU\n\tnp = of_find_node_by_name(NULL, \"sms\");\n\tif (np && of_device_is_compatible(np, \"sms\"))\n\t\t \n\t\treturn ams_pmu_init(np);\n#endif\n\treturn -ENODEV;\n}\n\nvoid ams_sensor_detach(void)\n{\n\t \n\tams_input_exit();\n\n\t \n\tdevice_remove_file(&ams_info.of_dev->dev, &dev_attr_current);\n\n\t \n\tflush_work(&ams_info.worker);\n\n\t \n\tof_device_unregister(ams_info.of_dev);\n\n\t \n\tpmf_unregister_irq_client(&ams_shock_client);\n\tpmf_unregister_irq_client(&ams_freefall_client);\n}\n\nstatic void __exit ams_exit(void)\n{\n\t \n\tams_info.exit();\n}\n\nMODULE_AUTHOR(\"Stelian Pop, Michael Hanselmann\");\nMODULE_DESCRIPTION(\"Apple Motion Sensor driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ams_init);\nmodule_exit(ams_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}