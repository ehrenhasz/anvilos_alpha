{
  "module_name": "adb.c",
  "hash_id": "2c934e87f7be224785e6c56b1df2d2a90f4f4d3a6256f5d47cba9bb159746867",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/adb.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/adb.h>\n#include <linux/cuda.h>\n#include <linux/pmu.h>\n#include <linux/notifier.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/kthread.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n#include <linux/uaccess.h>\n#ifdef CONFIG_PPC\n#include <asm/machdep.h>\n#endif\n\n\nEXPORT_SYMBOL(adb_client_list);\n\nextern struct adb_driver via_macii_driver;\nextern struct adb_driver via_cuda_driver;\nextern struct adb_driver adb_iop_driver;\nextern struct adb_driver via_pmu_driver;\nextern struct adb_driver macio_adb_driver;\n\nstatic DEFINE_MUTEX(adb_mutex);\nstatic struct adb_driver *adb_driver_list[] = {\n#ifdef CONFIG_ADB_MACII\n\t&via_macii_driver,\n#endif\n#ifdef CONFIG_ADB_CUDA\n\t&via_cuda_driver,\n#endif\n#ifdef CONFIG_ADB_IOP\n\t&adb_iop_driver,\n#endif\n#ifdef CONFIG_ADB_PMU\n\t&via_pmu_driver,\n#endif\n#ifdef CONFIG_ADB_MACIO\n\t&macio_adb_driver,\n#endif\n\tNULL\n};\n\nstatic struct class *adb_dev_class;\n\nstatic struct adb_driver *adb_controller;\nBLOCKING_NOTIFIER_HEAD(adb_client_list);\nstatic int adb_got_sleep;\nstatic int adb_inited;\nstatic DEFINE_SEMAPHORE(adb_probe_mutex, 1);\nstatic int sleepy_trackpad;\nstatic int autopoll_devs;\nint __adb_probe_sync;\n\nstatic int adb_scan_bus(void);\nstatic int do_adb_reset_bus(void);\nstatic void adbdev_init(void);\nstatic int try_handler_change(int, int);\n\nstatic struct adb_handler {\n\tvoid (*handler)(unsigned char *, int, int);\n\tint original_address;\n\tint handler_id;\n\tint busy;\n} adb_handler[16];\n\n \nstatic DEFINE_MUTEX(adb_handler_mutex);\nstatic DEFINE_RWLOCK(adb_handler_lock);\n\n#if 0\nstatic void printADBreply(struct adb_request *req)\n{\n        int i;\n\n        printk(\"adb reply (%d)\", req->reply_len);\n        for(i = 0; i < req->reply_len; i++)\n                printk(\" %x\", req->reply[i]);\n        printk(\"\\n\");\n\n}\n#endif\n\nstatic int adb_scan_bus(void)\n{\n\tint i, highFree=0, noMovement;\n\tint devmask = 0;\n\tstruct adb_request req;\n\t\n\t \n\tfor (i = 1; i < 16; i++) {\n\t\t \n\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n                            (i << 4) | 0xf);\n\t\tif (req.reply_len > 1)\n\t\t\t \n\t\t\tadb_handler[i].original_address = i;\n\t\telse if (i > highFree)\n\t\t\thighFree = i;\n\t}\n\n\t \n\tfor (noMovement = 1; noMovement < 2 && highFree > 0; noMovement++) {\n\t\tfor (i = 1; i < 16; i++) {\n\t\t\tif (adb_handler[i].original_address == 0)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t\t\t    (i << 4) | 0xf);\n\t\t\t \n\t\t\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\t\t\t\t    (i<< 4) | 0xb, (highFree | 0x60), 0xfe);\n\t\t\t \n\t\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t\t\t    (highFree << 4) | 0xf);\n\t\t\tif (req.reply_len <= 1) continue;\n\t\t\t \n\t\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t\t\t    (i << 4) | 0xf);\n\t\t\tif (req.reply_len > 1) {\n\t\t\t\t \n\t\t\t\tadb_handler[highFree].original_address =\n\t\t\t\t\tadb_handler[i].original_address;\n\t\t\t\twhile (highFree > 0 &&\n\t\t\t\t       adb_handler[highFree].original_address)\n\t\t\t\t\thighFree--;\n\t\t\t\tif (highFree <= 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnoMovement = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\t\t\t\t\t    (highFree << 4) | 0xb,\n\t\t\t\t\t    (i | 0x60), 0xfe);\n\t\t\t}\n\t\t}\t\n\t}\n\n\t \n\tfor (i = 1; i < 16; i++) {\n\t\tif (adb_handler[i].original_address == 0)\n\t\t\tcontinue;\n\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t\t    (i << 4) | 0xf);\n\t\tadb_handler[i].handler_id = req.reply[2];\n\t\tprintk(KERN_DEBUG \"adb device [%d]: %d 0x%X\\n\", i,\n\t\t       adb_handler[i].original_address,\n\t\t       adb_handler[i].handler_id);\n\t\tdevmask |= 1 << i;\n\t}\n\treturn devmask;\n}\n\n \nstatic int\nadb_probe_task(void *x)\n{\n\tpr_debug(\"adb: starting probe task...\\n\");\n\tdo_adb_reset_bus();\n\tpr_debug(\"adb: finished probe task...\\n\");\n\n\tup(&adb_probe_mutex);\n\n\treturn 0;\n}\n\nstatic void\n__adb_probe_task(struct work_struct *bullshit)\n{\n\tkthread_run(adb_probe_task, NULL, \"kadbprobe\");\n}\n\nstatic DECLARE_WORK(adb_reset_work, __adb_probe_task);\n\nint\nadb_reset_bus(void)\n{\n\tif (__adb_probe_sync) {\n\t\tdo_adb_reset_bus();\n\t\treturn 0;\n\t}\n\n\tdown(&adb_probe_mutex);\n\tschedule_work(&adb_reset_work);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n \nstatic int __adb_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tadb_got_sleep = 1;\n\t \n\tdown(&adb_probe_mutex);\n\t \n\tif (adb_controller->autopoll)\n\t\tadb_controller->autopoll(0);\n\tblocking_notifier_call_chain(&adb_client_list, ADB_MSG_POWERDOWN, NULL);\n\n\treturn 0;\n}\n\nstatic int adb_suspend(struct device *dev)\n{\n\treturn __adb_suspend(to_platform_device(dev), PMSG_SUSPEND);\n}\n\nstatic int adb_freeze(struct device *dev)\n{\n\treturn __adb_suspend(to_platform_device(dev), PMSG_FREEZE);\n}\n\nstatic int adb_poweroff(struct device *dev)\n{\n\treturn __adb_suspend(to_platform_device(dev), PMSG_HIBERNATE);\n}\n\n \nstatic int __adb_resume(struct platform_device *dev)\n{\n\tadb_got_sleep = 0;\n\tup(&adb_probe_mutex);\n\tadb_reset_bus();\n\n\treturn 0;\n}\n\nstatic int adb_resume(struct device *dev)\n{\n\treturn __adb_resume(to_platform_device(dev));\n}\n#endif  \n\nstatic int __init adb_init(void)\n{\n\tstruct adb_driver *driver;\n\tint i;\n\n#ifdef CONFIG_PPC32\n\tif (!machine_is(chrp) && !machine_is(powermac))\n\t\treturn 0;\n#endif\n#ifdef CONFIG_MAC\n\tif (!MACH_IS_MAC)\n\t\treturn 0;\n#endif\n\n\t \n\tif (adb_inited)\n\t\treturn 0;\n\tadb_inited = 1;\n\t\t\n\tadb_controller = NULL;\n\n\ti = 0;\n\twhile ((driver = adb_driver_list[i++]) != NULL) {\n\t\tif (!driver->probe()) {\n\t\t\tadb_controller = driver;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (adb_controller != NULL && adb_controller->init &&\n\t    adb_controller->init())\n\t\tadb_controller = NULL;\n\tif (adb_controller == NULL) {\n\t\tpr_warn(\"Warning: no ADB interface detected\\n\");\n\t} else {\n#ifdef CONFIG_PPC\n\t\tif (of_machine_is_compatible(\"AAPL,PowerBook1998\") ||\n\t\t\tof_machine_is_compatible(\"PowerBook1,1\"))\n\t\t\tsleepy_trackpad = 1;\n#endif  \n\n\t\tadbdev_init();\n\t\tadb_reset_bus();\n\t}\n\treturn 0;\n}\n\ndevice_initcall(adb_init);\n\nstatic int\ndo_adb_reset_bus(void)\n{\n\tint ret;\n\t\n\tif (adb_controller == NULL)\n\t\treturn -ENXIO;\n\t\t\n\tif (adb_controller->autopoll)\n\t\tadb_controller->autopoll(0);\n\n\tblocking_notifier_call_chain(&adb_client_list,\n\t\tADB_MSG_PRE_RESET, NULL);\n\n\tif (sleepy_trackpad) {\n\t\t \n\t\tmsleep(500);\n\t}\n\n\tmutex_lock(&adb_handler_mutex);\n\twrite_lock_irq(&adb_handler_lock);\n\tmemset(adb_handler, 0, sizeof(adb_handler));\n\twrite_unlock_irq(&adb_handler_lock);\n\n\t \n\tif (adb_controller->reset_bus)\n\t\tret = adb_controller->reset_bus();\n\telse\n\t\tret = 0;\n\n\tif (sleepy_trackpad) {\n\t\t \n\t\tmsleep(1500);\n\t}\n\n\tif (!ret) {\n\t\tautopoll_devs = adb_scan_bus();\n\t\tif (adb_controller->autopoll)\n\t\t\tadb_controller->autopoll(autopoll_devs);\n\t}\n\tmutex_unlock(&adb_handler_mutex);\n\n\tblocking_notifier_call_chain(&adb_client_list,\n\t\tADB_MSG_POST_RESET, NULL);\n\t\n\treturn ret;\n}\n\nvoid\nadb_poll(void)\n{\n\tif ((adb_controller == NULL)||(adb_controller->poll == NULL))\n\t\treturn;\n\tadb_controller->poll();\n}\nEXPORT_SYMBOL(adb_poll);\n\nstatic void adb_sync_req_done(struct adb_request *req)\n{\n\tstruct completion *comp = req->arg;\n\n\tcomplete(comp);\n}\n\nint\nadb_request(struct adb_request *req, void (*done)(struct adb_request *),\n\t    int flags, int nbytes, ...)\n{\n\tva_list list;\n\tint i;\n\tint rc;\n\tstruct completion comp;\n\n\tif ((adb_controller == NULL) || (adb_controller->send_request == NULL))\n\t\treturn -ENXIO;\n\tif (nbytes < 1)\n\t\treturn -EINVAL;\n\n\treq->nbytes = nbytes+1;\n\treq->done = done;\n\treq->reply_expected = flags & ADBREQ_REPLY;\n\treq->data[0] = ADB_PACKET;\n\tva_start(list, nbytes);\n\tfor (i = 0; i < nbytes; ++i)\n\t\treq->data[i+1] = va_arg(list, int);\n\tva_end(list);\n\n\tif (flags & ADBREQ_NOSEND)\n\t\treturn 0;\n\n\t \n\tif (flags & ADBREQ_SYNC) {\n\t\tWARN_ON(done);\n\t\treq->done = adb_sync_req_done;\n\t\treq->arg = &comp;\n\t\tinit_completion(&comp);\n\t}\n\n\trc = adb_controller->send_request(req, 0);\n\n\tif ((flags & ADBREQ_SYNC) && !rc && !req->complete)\n\t\twait_for_completion(&comp);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(adb_request);\n\n  \nint\nadb_register(int default_id, int handler_id, struct adb_ids *ids,\n\t     void (*handler)(unsigned char *, int, int))\n{\n\tint i;\n\n\tmutex_lock(&adb_handler_mutex);\n\tids->nids = 0;\n\tfor (i = 1; i < 16; i++) {\n\t\tif ((adb_handler[i].original_address == default_id) &&\n\t\t    (!handler_id || (handler_id == adb_handler[i].handler_id) || \n\t\t    try_handler_change(i, handler_id))) {\n\t\t\tif (adb_handler[i].handler) {\n\t\t\t\tpr_err(\"Two handlers for ADB device %d\\n\",\n\t\t\t\t       default_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite_lock_irq(&adb_handler_lock);\n\t\t\tadb_handler[i].handler = handler;\n\t\t\twrite_unlock_irq(&adb_handler_lock);\n\t\t\tids->id[ids->nids++] = i;\n\t\t}\n\t}\n\tmutex_unlock(&adb_handler_mutex);\n\treturn ids->nids;\n}\nEXPORT_SYMBOL(adb_register);\n\nint\nadb_unregister(int index)\n{\n\tint ret = -ENODEV;\n\n\tmutex_lock(&adb_handler_mutex);\n\twrite_lock_irq(&adb_handler_lock);\n\tif (adb_handler[index].handler) {\n\t\twhile(adb_handler[index].busy) {\n\t\t\twrite_unlock_irq(&adb_handler_lock);\n\t\t\tyield();\n\t\t\twrite_lock_irq(&adb_handler_lock);\n\t\t}\n\t\tret = 0;\n\t\tadb_handler[index].handler = NULL;\n\t}\n\twrite_unlock_irq(&adb_handler_lock);\n\tmutex_unlock(&adb_handler_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(adb_unregister);\n\nvoid\nadb_input(unsigned char *buf, int nb, int autopoll)\n{\n\tint i, id;\n\tstatic int dump_adb_input;\n\tunsigned long flags;\n\t\n\tvoid (*handler)(unsigned char *, int, int);\n\n\t \n\tif (adb_got_sleep)\n\t\treturn;\n\t\t\n\tid = buf[0] >> 4;\n\tif (dump_adb_input) {\n\t\tpr_info(\"adb packet: \");\n\t\tfor (i = 0; i < nb; ++i)\n\t\t\tpr_cont(\" %x\", buf[i]);\n\t\tpr_cont(\", id = %d\\n\", id);\n\t}\n\twrite_lock_irqsave(&adb_handler_lock, flags);\n\thandler = adb_handler[id].handler;\n\tif (handler != NULL)\n\t\tadb_handler[id].busy = 1;\n\twrite_unlock_irqrestore(&adb_handler_lock, flags);\n\tif (handler != NULL) {\n\t\t(*handler)(buf, nb, autopoll);\n\t\twmb();\n\t\tadb_handler[id].busy = 0;\n\t}\n\t\t\n}\n\n \nstatic int try_handler_change(int address, int new_id)\n{\n\tstruct adb_request req;\n\n\tif (adb_handler[address].handler_id == new_id)\n\t    return 1;\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\t    ADB_WRITEREG(address, 3), address | 0x20, new_id);\n\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t    ADB_READREG(address, 3));\n\tif (req.reply_len < 2)\n\t    return 0;\n\tif (req.reply[2] != new_id)\n\t    return 0;\n\tadb_handler[address].handler_id = req.reply[2];\n\n\treturn 1;\n}\n\nint\nadb_try_handler_change(int address, int new_id)\n{\n\tint ret;\n\n\tmutex_lock(&adb_handler_mutex);\n\tret = try_handler_change(address, new_id);\n\tmutex_unlock(&adb_handler_mutex);\n\tif (ret)\n\t\tpr_debug(\"adb handler change: [%d] 0x%X\\n\", address, new_id);\n\treturn ret;\n}\nEXPORT_SYMBOL(adb_try_handler_change);\n\nint\nadb_get_infos(int address, int *original_address, int *handler_id)\n{\n\tmutex_lock(&adb_handler_mutex);\n\t*original_address = adb_handler[address].original_address;\n\t*handler_id = adb_handler[address].handler_id;\n\tmutex_unlock(&adb_handler_mutex);\n\n\treturn (*original_address != 0);\n}\n\n\n \n\n#define ADB_MAJOR\t56\t \n\nstruct adbdev_state {\n\tspinlock_t\tlock;\n\tatomic_t\tn_pending;\n\tstruct adb_request *completed;\n  \twait_queue_head_t wait_queue;\n\tint\t\tinuse;\n};\n\nstatic void adb_write_done(struct adb_request *req)\n{\n\tstruct adbdev_state *state = (struct adbdev_state *) req->arg;\n\tunsigned long flags;\n\n\tif (!req->complete) {\n\t\treq->reply_len = 0;\n\t\treq->complete = 1;\n\t}\n\tspin_lock_irqsave(&state->lock, flags);\n\tatomic_dec(&state->n_pending);\n\tif (!state->inuse) {\n\t\tkfree(req);\n\t\tif (atomic_read(&state->n_pending) == 0) {\n\t\t\tspin_unlock_irqrestore(&state->lock, flags);\n\t\t\tkfree(state);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tstruct adb_request **ap = &state->completed;\n\t\twhile (*ap != NULL)\n\t\t\tap = &(*ap)->next;\n\t\treq->next = NULL;\n\t\t*ap = req;\n\t\twake_up_interruptible(&state->wait_queue);\n\t}\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nstatic int\ndo_adb_query(struct adb_request *req)\n{\n\tint\tret = -EINVAL;\n\n\tswitch(req->data[1]) {\n\tcase ADB_QUERY_GETDEVINFO:\n\t\tif (req->nbytes < 3 || req->data[2] >= 16)\n\t\t\tbreak;\n\t\tmutex_lock(&adb_handler_mutex);\n\t\treq->reply[0] = adb_handler[req->data[2]].original_address;\n\t\treq->reply[1] = adb_handler[req->data[2]].handler_id;\n\t\tmutex_unlock(&adb_handler_mutex);\n\t\treq->complete = 1;\n\t\treq->reply_len = 2;\n\t\tadb_write_done(req);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int adb_open(struct inode *inode, struct file *file)\n{\n\tstruct adbdev_state *state;\n\tint ret = 0;\n\n\tmutex_lock(&adb_mutex);\n\tif (iminor(inode) > 0 || adb_controller == NULL) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\tstate = kmalloc(sizeof(struct adbdev_state), GFP_KERNEL);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile->private_data = state;\n\tspin_lock_init(&state->lock);\n\tatomic_set(&state->n_pending, 0);\n\tstate->completed = NULL;\n\tinit_waitqueue_head(&state->wait_queue);\n\tstate->inuse = 1;\n\nout:\n\tmutex_unlock(&adb_mutex);\n\treturn ret;\n}\n\nstatic int adb_release(struct inode *inode, struct file *file)\n{\n\tstruct adbdev_state *state = file->private_data;\n\tunsigned long flags;\n\n\tmutex_lock(&adb_mutex);\n\tif (state) {\n\t\tfile->private_data = NULL;\n\t\tspin_lock_irqsave(&state->lock, flags);\n\t\tif (atomic_read(&state->n_pending) == 0\n\t\t    && state->completed == NULL) {\n\t\t\tspin_unlock_irqrestore(&state->lock, flags);\n\t\t\tkfree(state);\n\t\t} else {\n\t\t\tstate->inuse = 0;\n\t\t\tspin_unlock_irqrestore(&state->lock, flags);\n\t\t}\n\t}\n\tmutex_unlock(&adb_mutex);\n\treturn 0;\n}\n\nstatic ssize_t adb_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tint ret = 0;\n\tstruct adbdev_state *state = file->private_data;\n\tstruct adb_request *req;\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long flags;\n\n\tif (count < 2)\n\t\treturn -EINVAL;\n\tif (count > sizeof(req->reply))\n\t\tcount = sizeof(req->reply);\n\n\treq = NULL;\n\tspin_lock_irqsave(&state->lock, flags);\n\tadd_wait_queue(&state->wait_queue, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\tfor (;;) {\n\t\treq = state->completed;\n\t\tif (req != NULL)\n\t\t\tstate->completed = req->next;\n\t\telse if (atomic_read(&state->n_pending) == 0)\n\t\t\tret = -EIO;\n\t\tif (req != NULL || ret != 0)\n\t\t\tbreak;\n\t\t\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&state->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&state->lock, flags);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&state->wait_queue, &wait);\n\tspin_unlock_irqrestore(&state->lock, flags);\n\t\n\tif (ret)\n\t\treturn ret;\n\n\tret = req->reply_len;\n\tif (ret > count)\n\t\tret = count;\n\tif (ret > 0 && copy_to_user(buf, req->reply, ret))\n\t\tret = -EFAULT;\n\n\tkfree(req);\n\treturn ret;\n}\n\nstatic ssize_t adb_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint ret ;\n\tstruct adbdev_state *state = file->private_data;\n\tstruct adb_request *req;\n\n\tif (count < 2 || count > sizeof(req->data))\n\t\treturn -EINVAL;\n\tif (adb_controller == NULL)\n\t\treturn -ENXIO;\n\n\treq = kmalloc(sizeof(struct adb_request),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (req == NULL)\n\t\treturn -ENOMEM;\n\n\treq->nbytes = count;\n\treq->done = adb_write_done;\n\treq->arg = (void *) state;\n\treq->complete = 0;\n\t\n\tret = -EFAULT;\n\tif (copy_from_user(req->data, buf, count))\n\t\tgoto out;\n\n\tatomic_inc(&state->n_pending);\n\n\t \n\tdown(&adb_probe_mutex);\n\n\t \n\tif (req->data[0] == ADB_QUERY) {\n\t\tif (count > 1)\n\t\t\tret = do_adb_query(req);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tup(&adb_probe_mutex);\n\t}\n\t \n\telse if ((req->data[0] == ADB_PACKET) && (count > 1)\n\t\t&& (req->data[1] == ADB_BUSRESET)) {\n\t\tret = do_adb_reset_bus();\n\t\tup(&adb_probe_mutex);\n\t\tatomic_dec(&state->n_pending);\n\t\tif (ret == 0)\n\t\t\tret = count;\n\t\tgoto out;\n\t} else {\t\n\t\treq->reply_expected = ((req->data[1] & 0xc) == 0xc);\n\t\tif (adb_controller && adb_controller->send_request)\n\t\t\tret = adb_controller->send_request(req, 0);\n\t\telse\n\t\t\tret = -ENXIO;\n\t\tup(&adb_probe_mutex);\n\t}\n\n\tif (ret != 0) {\n\t\tatomic_dec(&state->n_pending);\n\t\tgoto out;\n\t}\n\treturn count;\n\nout:\n\tkfree(req);\n\treturn ret;\n}\n\nstatic const struct file_operations adb_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= adb_read,\n\t.write\t\t= adb_write,\n\t.open\t\t= adb_open,\n\t.release\t= adb_release,\n};\n\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops adb_dev_pm_ops = {\n\t.suspend = adb_suspend,\n\t.resume = adb_resume,\n\t \n\t.freeze = adb_freeze,\n\t.thaw = adb_resume,\n\t.poweroff = adb_poweroff,\n\t.restore = adb_resume,\n};\n#endif\n\nstatic struct platform_driver adb_pfdrv = {\n\t.driver = {\n\t\t.name = \"adb\",\n#ifdef CONFIG_PM\n\t\t.pm = &adb_dev_pm_ops,\n#endif\n\t},\n};\n\nstatic struct platform_device adb_pfdev = {\n\t.name = \"adb\",\n};\n\nstatic int __init\nadb_dummy_probe(struct platform_device *dev)\n{\n\tif (dev == &adb_pfdev)\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\nstatic void __init\nadbdev_init(void)\n{\n\tif (register_chrdev(ADB_MAJOR, \"adb\", &adb_fops)) {\n\t\tpr_err(\"adb: unable to get major %d\\n\", ADB_MAJOR);\n\t\treturn;\n\t}\n\n\tadb_dev_class = class_create(\"adb\");\n\tif (IS_ERR(adb_dev_class))\n\t\treturn;\n\tdevice_create(adb_dev_class, NULL, MKDEV(ADB_MAJOR, 0), NULL, \"adb\");\n\n\tplatform_device_register(&adb_pfdev);\n\tplatform_driver_probe(&adb_pfdrv, adb_dummy_probe);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}