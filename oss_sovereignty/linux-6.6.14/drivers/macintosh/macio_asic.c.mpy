{
  "module_name": "macio_asic.c",
  "hash_id": "afcac7cb942609736adb0e13e6b36ce912d5919889dd02cd93079c35b2962dfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/macio_asic.c",
  "human_readable_source": "\n \n \n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n\n#include <asm/machdep.h>\n#include <asm/macio.h>\n#include <asm/pmac_feature.h>\n\n#undef DEBUG\n\n#define MAX_NODE_NAME_SIZE (20 - 12)\n\nstatic struct macio_chip      *macio_on_hold;\n\nstatic int macio_bus_match(struct device *dev, struct device_driver *drv) \n{\n\tconst struct of_device_id * matches = drv->of_match_table;\n\n\tif (!matches) \n\t\treturn 0;\n\n\treturn of_match_device(matches, dev) != NULL;\n}\n\nstruct macio_dev *macio_dev_get(struct macio_dev *dev)\n{\n\tstruct device *tmp;\n\n\tif (!dev)\n\t\treturn NULL;\n\ttmp = get_device(&dev->ofdev.dev);\n\tif (tmp)\n\t\treturn to_macio_device(tmp);\n\telse\n\t\treturn NULL;\n}\n\nvoid macio_dev_put(struct macio_dev *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->ofdev.dev);\n}\n\n\nstatic int macio_device_probe(struct device *dev)\n{\n\tint error = -ENODEV;\n\tstruct macio_driver *drv;\n\tstruct macio_dev *macio_dev;\n\tconst struct of_device_id *match;\n\n\tdrv = to_macio_driver(dev->driver);\n\tmacio_dev = to_macio_device(dev);\n\n\tif (!drv->probe)\n\t\treturn error;\n\n\tmacio_dev_get(macio_dev);\n\n\tmatch = of_match_device(drv->driver.of_match_table, dev);\n\tif (match)\n\t\terror = drv->probe(macio_dev, match);\n\tif (error)\n\t\tmacio_dev_put(macio_dev);\n\n\treturn error;\n}\n\nstatic void macio_device_remove(struct device *dev)\n{\n\tstruct macio_dev * macio_dev = to_macio_device(dev);\n\tstruct macio_driver * drv = to_macio_driver(dev->driver);\n\n\tif (dev->driver && drv->remove)\n\t\tdrv->remove(macio_dev);\n\tmacio_dev_put(macio_dev);\n}\n\nstatic void macio_device_shutdown(struct device *dev)\n{\n\tstruct macio_dev * macio_dev = to_macio_device(dev);\n\tstruct macio_driver * drv = to_macio_driver(dev->driver);\n\n\tif (dev->driver && drv->shutdown)\n\t\tdrv->shutdown(macio_dev);\n}\n\nstatic int macio_device_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct macio_dev * macio_dev = to_macio_device(dev);\n\tstruct macio_driver * drv = to_macio_driver(dev->driver);\n\n\tif (dev->driver && drv->suspend)\n\t\treturn drv->suspend(macio_dev, state);\n\treturn 0;\n}\n\nstatic int macio_device_resume(struct device * dev)\n{\n\tstruct macio_dev * macio_dev = to_macio_device(dev);\n\tstruct macio_driver * drv = to_macio_driver(dev->driver);\n\n\tif (dev->driver && drv->resume)\n\t\treturn drv->resume(macio_dev);\n\treturn 0;\n}\n\nstatic int macio_device_modalias(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn of_device_uevent_modalias(dev, env);\n}\n\nextern const struct attribute_group *macio_dev_groups[];\n\nstruct bus_type macio_bus_type = {\n       .name\t= \"macio\",\n       .match\t= macio_bus_match,\n       .uevent\t= macio_device_modalias,\n       .probe\t= macio_device_probe,\n       .remove\t= macio_device_remove,\n       .shutdown = macio_device_shutdown,\n       .suspend\t= macio_device_suspend,\n       .resume\t= macio_device_resume,\n       .dev_groups = macio_dev_groups,\n};\n\nstatic int __init macio_bus_driver_init(void)\n{\n\treturn bus_register(&macio_bus_type);\n}\n\npostcore_initcall(macio_bus_driver_init);\n\n\n \nstatic void macio_release_dev(struct device *dev)\n{\n\tstruct macio_dev *mdev;\n\n        mdev = to_macio_device(dev);\n\tkfree(mdev);\n}\n\n \nstatic int macio_resource_quirks(struct device_node *np, struct resource *res,\n\t\t\t\t int index)\n{\n\t \n\tif ((res->flags & IORESOURCE_MEM) == 0)\n\t\treturn 0;\n\n\t \n\tif (index == 0 && of_node_name_eq(np, \"gc\"))\n\t\tres->end = res->start + 0x1ffff;\n\n\t \n\tif (index >= 2 && of_node_name_eq(np, \"radio\"))\n\t\treturn 1;\n\n#ifndef CONFIG_PPC64\n\t \n\tif ((res->start & 0x0001f000) == 0x00008000)\n\t\tres->end = res->start + 0xff;\n#endif  \n\n\t \n\tif (of_node_name_eq(np, \"escc\"))\n\t\treturn 1;\n\n\t \n\tif (index >= 3 && (of_node_name_eq(np, \"ch-a\") ||\n\t\t\t   of_node_name_eq(np, \"ch-b\")))\n\t\treturn 1;\n\n\t \n\tif (index > 0 && of_node_name_eq(np, \"media-bay\"))\n\t\treturn 1;\n\n\t \n\tif (of_node_name_eq(np, \"IDE\") || of_node_name_eq(np, \"ATA\") ||\n\t    of_node_is_type(np, \"ide\") || of_node_is_type(np, \"ata\")) {\n\t\tif (index == 0 && (res->end - res->start) > 0xfff)\n\t\t\tres->end = res->start + 0xfff;\n\t\tif (index == 1 && (res->end - res->start) > 0xff)\n\t\t\tres->end = res->start + 0xff;\n\t}\n\treturn 0;\n}\n\nstatic void macio_create_fixup_irq(struct macio_dev *dev, int index,\n\t\t\t\t   unsigned int line)\n{\n\tunsigned int irq;\n\n\tirq = irq_create_mapping(NULL, line);\n\tif (!irq) {\n\t\tdev->interrupt[index].start = irq;\n\t\tdev->interrupt[index].flags = IORESOURCE_IRQ;\n\t\tdev->interrupt[index].name = dev_name(&dev->ofdev.dev);\n\t}\n\tif (dev->n_interrupts <= index)\n\t\tdev->n_interrupts = index + 1;\n}\n\nstatic void macio_add_missing_resources(struct macio_dev *dev)\n{\n\tstruct device_node *np = dev->ofdev.dev.of_node;\n\tunsigned int irq_base;\n\n\t \n\tif (dev->bus->chip->type != macio_gatwick)\n\t\treturn;\n\n\t \n\tirq_base = 64;\n\n\t \n\tif (of_node_name_eq(np, \"ch-a\")) {\n\t\tmacio_create_fixup_irq(dev, 0, 15 + irq_base);\n\t\tmacio_create_fixup_irq(dev, 1,  4 + irq_base);\n\t\tmacio_create_fixup_irq(dev, 2,  5 + irq_base);\n\t\tprintk(KERN_INFO \"macio: fixed SCC irqs on gatwick\\n\");\n\t}\n\n\t \n\tif (of_node_name_eq(np, \"media-bay\")) {\n\t\tmacio_create_fixup_irq(dev, 0, 29 + irq_base);\n\t\tprintk(KERN_INFO \"macio: fixed media-bay irq on gatwick\\n\");\n\t}\n\n\t \n\tif (dev->media_bay != NULL && of_node_name_eq(np, \"floppy\")) {\n\t\tmacio_create_fixup_irq(dev, 0, 19 + irq_base);\n\t\tmacio_create_fixup_irq(dev, 1,  1 + irq_base);\n\t\tprintk(KERN_INFO \"macio: fixed left floppy irqs\\n\");\n\t}\n\tif (dev->media_bay != NULL && of_node_name_eq(np, \"ata4\")) {\n\t\tmacio_create_fixup_irq(dev, 0, 14 + irq_base);\n\t\tmacio_create_fixup_irq(dev, 0,  3 + irq_base);\n\t\tprintk(KERN_INFO \"macio: fixed left ide irqs\\n\");\n\t}\n}\n\nstatic void macio_setup_interrupts(struct macio_dev *dev)\n{\n\tstruct device_node *np = dev->ofdev.dev.of_node;\n\tunsigned int irq;\n\tint i = 0, j = 0;\n\n\tfor (;;) {\n\t\tstruct resource *res;\n\n\t\tif (j >= MACIO_DEV_COUNT_IRQS)\n\t\t\tbreak;\n\t\tres = &dev->interrupt[j];\n\t\tirq = irq_of_parse_and_map(np, i++);\n\t\tif (!irq)\n\t\t\tbreak;\n\t\tres->start = irq;\n\t\tres->flags = IORESOURCE_IRQ;\n\t\tres->name = dev_name(&dev->ofdev.dev);\n\t\tif (macio_resource_quirks(np, res, i - 1)) {\n\t\t\tmemset(res, 0, sizeof(struct resource));\n\t\t\tcontinue;\n\t\t} else\n\t\t\tj++;\n\t}\n\tdev->n_interrupts = j;\n}\n\nstatic void macio_setup_resources(struct macio_dev *dev,\n\t\t\t\t  struct resource *parent_res)\n{\n\tstruct device_node *np = dev->ofdev.dev.of_node;\n\tstruct resource r;\n\tint index;\n\n\tfor (index = 0; of_address_to_resource(np, index, &r) == 0; index++) {\n\t\tstruct resource *res;\n\t\tif (index >= MACIO_DEV_COUNT_RESOURCES)\n\t\t\tbreak;\n\t\tres = &dev->resource[index];\n\t\t*res = r;\n\t\tres->name = dev_name(&dev->ofdev.dev);\n\n\t\tif (macio_resource_quirks(np, res, index)) {\n\t\t\tmemset(res, 0, sizeof(struct resource));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (insert_resource(parent_res, res)) {\n\t\t\tprintk(KERN_WARNING \"Can't request resource \"\n\t\t\t       \"%d for MacIO device %s\\n\",\n\t\t\t       index, dev_name(&dev->ofdev.dev));\n\t\t}\n\t}\n\tdev->n_resources = index;\n}\n\n \nstatic struct macio_dev * macio_add_one_device(struct macio_chip *chip,\n\t\t\t\t\t       struct device *parent,\n\t\t\t\t\t       struct device_node *np,\n\t\t\t\t\t       struct macio_dev *in_bay,\n\t\t\t\t\t       struct resource *parent_res)\n{\n\tchar name[MAX_NODE_NAME_SIZE + 1];\n\tstruct macio_dev *dev;\n\tconst u32 *reg;\n\n\tif (np == NULL)\n\t\treturn NULL;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->bus = &chip->lbus;\n\tdev->media_bay = in_bay;\n\tdev->ofdev.dev.of_node = np;\n\tdev->ofdev.archdata.dma_mask = 0xffffffffUL;\n\tdev->ofdev.dev.dma_mask = &dev->ofdev.archdata.dma_mask;\n\tdev->ofdev.dev.coherent_dma_mask = dev->ofdev.archdata.dma_mask;\n\tdev->ofdev.dev.parent = parent;\n\tdev->ofdev.dev.bus = &macio_bus_type;\n\tdev->ofdev.dev.release = macio_release_dev;\n\tdev->ofdev.dev.dma_parms = &dev->dma_parms;\n\n\t \n\tdma_set_max_seg_size(&dev->ofdev.dev, 65536);\n\tdma_set_seg_boundary(&dev->ofdev.dev, 0xffffffff);\n\n#if defined(CONFIG_PCI) && defined(CONFIG_DMA_OPS)\n\t \n\tdev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;\n\tdev->ofdev.dev.dma_ops = chip->lbus.pdev->dev.dma_ops;\n#endif  \n\n#ifdef DEBUG\n\tprintk(\"preparing mdev @%p, ofdev @%p, dev @%p, kobj @%p\\n\",\n\t       dev, &dev->ofdev, &dev->ofdev.dev, &dev->ofdev.dev.kobj);\n#endif\n\n\t \n\tsnprintf(name, sizeof(name), \"%pOFn\", np);\n\tif (np == chip->of_node) {\n\t\tdev_set_name(&dev->ofdev.dev, \"%1d.%08x:%.*s\",\n\t\t\t     chip->lbus.index,\n#ifdef CONFIG_PCI\n\t\t\t(unsigned int)pci_resource_start(chip->lbus.pdev, 0),\n#else\n\t\t\t0,  \n#endif\n\t\t\tMAX_NODE_NAME_SIZE, name);\n\t} else {\n\t\treg = of_get_property(np, \"reg\", NULL);\n\t\tdev_set_name(&dev->ofdev.dev, \"%1d.%08x:%.*s\",\n\t\t\t     chip->lbus.index,\n\t\t\t     reg ? *reg : 0, MAX_NODE_NAME_SIZE, name);\n\t}\n\n\t \n\tmacio_setup_interrupts(dev);\n\tmacio_setup_resources(dev, parent_res);\n\tmacio_add_missing_resources(dev);\n\n\t \n\tif (of_device_register(&dev->ofdev) != 0) {\n\t\tprintk(KERN_DEBUG\"macio: device registration error for %s!\\n\",\n\t\t       dev_name(&dev->ofdev.dev));\n\t\tput_device(&dev->ofdev.dev);\n\t\treturn NULL;\n\t}\n\n\treturn dev;\n}\n\nstatic int macio_skip_device(struct device_node *np)\n{\n\treturn of_node_name_prefix(np, \"battery\") ||\n\t       of_node_name_prefix(np, \"escc-legacy\");\n}\n\n \nstatic void macio_pci_add_devices(struct macio_chip *chip)\n{\n\tstruct device_node *np, *pnode;\n\tstruct macio_dev *rdev, *mdev, *mbdev = NULL, *sdev = NULL;\n\tstruct device *parent = NULL;\n\tstruct resource *root_res = &iomem_resource;\n\t\n\t \n#ifdef CONFIG_PCI\n\tif (chip->lbus.pdev) {\n\t\tparent = &chip->lbus.pdev->dev;\n\t\troot_res = &chip->lbus.pdev->resource[0];\n\t}\n#endif\n\tpnode = of_node_get(chip->of_node);\n\tif (pnode == NULL)\n\t\treturn;\n\n\t \n\trdev = macio_add_one_device(chip, parent, pnode, NULL, root_res);\n\tif (rdev == NULL)\n\t\treturn;\n\troot_res = &rdev->resource[0];\n\n\t \n\tfor_each_child_of_node(pnode, np) {\n\t\tif (macio_skip_device(np))\n\t\t\tcontinue;\n\t\tof_node_get(np);\n\t\tmdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL,\n\t\t\t\t\t    root_res);\n\t\tif (mdev == NULL)\n\t\t\tof_node_put(np);\n\t\telse if (of_node_name_prefix(np, \"media-bay\"))\n\t\t\tmbdev = mdev;\n\t\telse if (of_node_name_prefix(np, \"escc\"))\n\t\t\tsdev = mdev;\n\t}\n\n\t \n\tif (mbdev) {\n\t\tpnode = mbdev->ofdev.dev.of_node;\n\t\tfor_each_child_of_node(pnode, np) {\n\t\t\tif (macio_skip_device(np))\n\t\t\t\tcontinue;\n\t\t\tof_node_get(np);\n\t\t\tif (macio_add_one_device(chip, &mbdev->ofdev.dev, np,\n\t\t\t\t\t\t mbdev,  root_res) == NULL)\n\t\t\t\tof_node_put(np);\n\t\t}\n\t}\n\n\t \n\tif (sdev) {\n\t\tpnode = sdev->ofdev.dev.of_node;\n\t\tfor_each_child_of_node(pnode, np) {\n\t\t\tif (macio_skip_device(np))\n\t\t\t\tcontinue;\n\t\t\tof_node_get(np);\n\t\t\tif (macio_add_one_device(chip, &sdev->ofdev.dev, np,\n\t\t\t\t\t\t NULL, root_res) == NULL)\n\t\t\t\tof_node_put(np);\n\t\t}\n\t}\n}\n\n\n \nint macio_register_driver(struct macio_driver *drv)\n{\n\t \n\tdrv->driver.bus = &macio_bus_type;\n\n\t \n\treturn driver_register(&drv->driver);\n}\n\n \nvoid macio_unregister_driver(struct macio_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\n\n \nstruct macio_devres {\n\tu32\tres_mask;\n};\n\nstatic void maciom_release(struct device *gendev, void *res)\n{\n\tstruct macio_dev *dev = to_macio_device(gendev);\n\tstruct macio_devres *dr = res;\n\tint i, max;\n\n\tmax = min(dev->n_resources, 32);\n\tfor (i = 0; i < max; i++) {\n\t\tif (dr->res_mask & (1 << i))\n\t\t\tmacio_release_resource(dev, i);\n\t}\n}\n\nint macio_enable_devres(struct macio_dev *dev)\n{\n\tstruct macio_devres *dr;\n\n\tdr = devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);\n\tif (!dr) {\n\t\tdr = devres_alloc(maciom_release, sizeof(*dr), GFP_KERNEL);\n\t\tif (!dr)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn devres_get(&dev->ofdev.dev, dr, NULL, NULL) != NULL;\n}\n\nstatic struct macio_devres * find_macio_dr(struct macio_dev *dev)\n{\n\treturn devres_find(&dev->ofdev.dev, maciom_release, NULL, NULL);\n}\n\n \nint macio_request_resource(struct macio_dev *dev, int resource_no,\n\t\t\t   const char *name)\n{\n\tstruct macio_devres *dr = find_macio_dr(dev);\n\n\tif (macio_resource_len(dev, resource_no) == 0)\n\t\treturn 0;\n\t\t\n\tif (!request_mem_region(macio_resource_start(dev, resource_no),\n\t\t\t\tmacio_resource_len(dev, resource_no),\n\t\t\t\tname))\n\t\tgoto err_out;\n\n\tif (dr && resource_no < 32)\n\t\tdr->res_mask |= 1 << resource_no;\n\t\n\treturn 0;\n\nerr_out:\n\tprintk (KERN_WARNING \"MacIO: Unable to reserve resource #%d:%lx@%lx\"\n\t\t\" for device %s\\n\",\n\t\tresource_no,\n\t\tmacio_resource_len(dev, resource_no),\n\t\tmacio_resource_start(dev, resource_no),\n\t\tdev_name(&dev->ofdev.dev));\n\treturn -EBUSY;\n}\n\n \nvoid macio_release_resource(struct macio_dev *dev, int resource_no)\n{\n\tstruct macio_devres *dr = find_macio_dr(dev);\n\n\tif (macio_resource_len(dev, resource_no) == 0)\n\t\treturn;\n\trelease_mem_region(macio_resource_start(dev, resource_no),\n\t\t\t   macio_resource_len(dev, resource_no));\n\tif (dr && resource_no < 32)\n\t\tdr->res_mask &= ~(1 << resource_no);\n}\n\n \nint macio_request_resources(struct macio_dev *dev, const char *name)\n{\n\tint i;\n\t\n\tfor (i = 0; i < dev->n_resources; i++)\n\t\tif (macio_request_resource(dev, i, name))\n\t\t\tgoto err_out;\n\treturn 0;\n\nerr_out:\n\twhile(--i >= 0)\n\t\tmacio_release_resource(dev, i);\n\t\t\n\treturn -EBUSY;\n}\n\n \n\nvoid macio_release_resources(struct macio_dev *dev)\n{\n\tint i;\n\t\n\tfor (i = 0; i < dev->n_resources; i++)\n\t\tmacio_release_resource(dev, i);\n}\n\n\n#ifdef CONFIG_PCI\n\nstatic int macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device_node* np;\n\tstruct macio_chip* chip;\n\t\n\tif (ent->vendor != PCI_VENDOR_ID_APPLE)\n\t\treturn -ENODEV;\n\n\t \n\tnp = pci_device_to_OF_node(pdev);\n\tif (np == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tof_node_get(np);\n\n\t \n\tchip = macio_find(np, macio_unknown);\n       \tof_node_put(np);\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (chip->lbus.pdev == NULL) {\n\t\tchip->lbus.pdev = pdev;\n\t\tchip->lbus.chip = chip;\n\t\tpci_set_drvdata(pdev, &chip->lbus);\n\t\tpci_set_master(pdev);\n\t}\n\n\tprintk(KERN_INFO \"MacIO PCI driver attached to %s chipset\\n\",\n\t\tchip->name);\n\n\t \n\tif (chip->type == macio_gatwick || chip->type == macio_ohareII)\n\t\tif (macio_chips[0].lbus.pdev == NULL) {\n\t\t\tmacio_on_hold = chip;\n\t\t\treturn 0;\n\t\t}\n\n\tmacio_pci_add_devices(chip);\n\tif (macio_on_hold && macio_chips[0].lbus.pdev != NULL) {\n\t\tmacio_pci_add_devices(macio_on_hold);\n\t\tmacio_on_hold = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void macio_pci_remove(struct pci_dev* pdev)\n{\n\tpanic(\"removing of macio-asic not supported !\\n\");\n}\n\n \nstatic const struct pci_device_id pci_ids[] = { {\n\t.vendor\t\t= PCI_VENDOR_ID_APPLE,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\n\t}, {   }\n};\nMODULE_DEVICE_TABLE (pci, pci_ids);\n\n \nstatic struct pci_driver macio_pci_driver = {\n\t.name\t\t= \"macio\",\n\t.id_table\t= pci_ids,\n\n\t.probe\t\t= macio_pci_probe,\n\t.remove\t\t= macio_pci_remove,\n};\n\n#endif  \n\nstatic int __init macio_module_init (void) \n{\n#ifdef CONFIG_PCI\n\tint rc;\n\n\trc = pci_register_driver(&macio_pci_driver);\n\tif (rc)\n\t\treturn rc;\n#endif  \n\treturn 0;\n}\n\nmodule_init(macio_module_init);\n\nEXPORT_SYMBOL(macio_register_driver);\nEXPORT_SYMBOL(macio_unregister_driver);\nEXPORT_SYMBOL(macio_dev_get);\nEXPORT_SYMBOL(macio_dev_put);\nEXPORT_SYMBOL(macio_request_resource);\nEXPORT_SYMBOL(macio_release_resource);\nEXPORT_SYMBOL(macio_request_resources);\nEXPORT_SYMBOL(macio_release_resources);\nEXPORT_SYMBOL(macio_enable_devres);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}