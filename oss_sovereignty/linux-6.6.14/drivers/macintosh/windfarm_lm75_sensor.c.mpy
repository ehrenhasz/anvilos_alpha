{
  "module_name": "windfarm_lm75_sensor.c",
  "hash_id": "bfbf5c9ec44b23622711c3e9da6139843be33f2af5f1519e814f52bc5bf3e343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_lm75_sensor.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/pmac_low_i2c.h>\n\n#include \"windfarm.h\"\n\n#define VERSION \"1.0\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\nstruct wf_lm75_sensor {\n\tunsigned int\t\tds1775 : 1;\n\tunsigned int\t\tinited : 1;\n\tstruct i2c_client\t*i2c;\n\tstruct wf_sensor\tsens;\n};\n#define wf_to_lm75(c) container_of(c, struct wf_lm75_sensor, sens)\n\nstatic int wf_lm75_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct wf_lm75_sensor *lm = wf_to_lm75(sr);\n\ts32 data;\n\n\tif (lm->i2c == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (!lm->inited) {\n\t\tu8 cfg_new, cfg = (u8)i2c_smbus_read_byte_data(lm->i2c, 1);\n\n\t\tDBG(\"wf_lm75: Initializing %s, cfg was: %02x\\n\",\n\t\t    sr->name, cfg);\n\n\t\t \n\t\tcfg_new = cfg & ~0x01;\n\t\ti2c_smbus_write_byte_data(lm->i2c, 1, cfg_new);\n\t\tlm->inited = 1;\n\n\t\t \n\t\tmsleep(200);\n\t}\n\n\t \n\tdata = (s32)le16_to_cpu(i2c_smbus_read_word_data(lm->i2c, 0));\n\tdata <<= 8;\n\t*value = data;\n\n\treturn 0;\n}\n\nstatic void wf_lm75_release(struct wf_sensor *sr)\n{\n\tstruct wf_lm75_sensor *lm = wf_to_lm75(sr);\n\n\tkfree(lm);\n}\n\nstatic const struct wf_sensor_ops wf_lm75_ops = {\n\t.get_value\t= wf_lm75_get,\n\t.release\t= wf_lm75_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int wf_lm75_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct wf_lm75_sensor *lm;\n\tint rc, ds1775;\n\tconst char *name, *loc;\n\n\tif (id)\n\t\tds1775 = id->driver_data;\n\telse\n\t\tds1775 = !!of_device_get_match_data(&client->dev);\n\n\tDBG(\"wf_lm75: creating  %s device at address 0x%02x\\n\",\n\t    ds1775 ? \"ds1775\" : \"lm75\", client->addr);\n\n\tloc = of_get_property(client->dev.of_node, \"hwsensor-location\", NULL);\n\tif (!loc) {\n\t\tdev_warn(&client->dev, \"Missing hwsensor-location property!\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (!strcmp(loc, \"Hard drive\") || !strcmp(loc, \"DRIVE BAY\"))\n\t\tname = \"hd-temp\";\n\telse if (!strcmp(loc, \"Incoming Air Temp\"))\n\t\tname = \"incoming-air-temp\";\n\telse if (!strcmp(loc, \"ODD Temp\"))\n\t\tname = \"optical-drive-temp\";\n\telse if (!strcmp(loc, \"HD Temp\"))\n\t\tname = \"hard-drive-temp\";\n\telse if (!strcmp(loc, \"PCI SLOTS\"))\n\t\tname = \"slots-temp\";\n\telse if (!strcmp(loc, \"CPU A INLET\"))\n\t\tname = \"cpu-inlet-temp-0\";\n\telse if (!strcmp(loc, \"CPU B INLET\"))\n\t\tname = \"cpu-inlet-temp-1\";\n\telse\n\t\treturn -ENXIO;\n \t\n\n\tlm = kzalloc(sizeof(struct wf_lm75_sensor), GFP_KERNEL);\n\tif (lm == NULL)\n\t\treturn -ENODEV;\n\n\tlm->inited = 0;\n\tlm->ds1775 = ds1775;\n\tlm->i2c = client;\n\tlm->sens.name = name;\n\tlm->sens.ops = &wf_lm75_ops;\n\ti2c_set_clientdata(client, lm);\n\n\trc = wf_register_sensor(&lm->sens);\n\tif (rc)\n\t\tkfree(lm);\n\treturn rc;\n}\n\nstatic void wf_lm75_remove(struct i2c_client *client)\n{\n\tstruct wf_lm75_sensor *lm = i2c_get_clientdata(client);\n\n\t \n\tlm->i2c = NULL;\n\n\t \n\twf_unregister_sensor(&lm->sens);\n}\n\nstatic const struct i2c_device_id wf_lm75_id[] = {\n\t{ \"MAC,lm75\", 0 },\n\t{ \"MAC,ds1775\", 1 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wf_lm75_id);\n\nstatic const struct of_device_id wf_lm75_of_id[] = {\n\t{ .compatible = \"lm75\", .data = (void *)0},\n\t{ .compatible = \"ds1775\", .data = (void *)1 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wf_lm75_of_id);\n\nstatic struct i2c_driver wf_lm75_driver = {\n\t.driver = {\n\t\t.name\t= \"wf_lm75\",\n\t\t.of_match_table = wf_lm75_of_id,\n\t},\n\t.probe\t\t= wf_lm75_probe,\n\t.remove\t\t= wf_lm75_remove,\n\t.id_table\t= wf_lm75_id,\n};\n\nmodule_i2c_driver(wf_lm75_driver);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"LM75 sensor objects for PowerMacs thermal control\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}