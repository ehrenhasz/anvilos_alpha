{
  "module_name": "windfarm_smu_sensors.c",
  "hash_id": "93cadeeb34389aa90e8de299da70e5836029568935f3f5a3bd99baba9475900a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_smu_sensors.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n\n#define VERSION \"0.2\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n \nstatic struct smu_sdbp_cpuvcp *cpuvcp;\nstatic int  cpuvcp_version;\nstatic struct smu_sdbp_cpudiode *cpudiode;\nstatic struct smu_sdbp_slotspow *slotspow;\nstatic u8 *debugswitches;\n\n \n\nstatic LIST_HEAD(smu_ads);\n\nstruct smu_ad_sensor {\n\tstruct list_head\tlink;\n\tu32\t\t\treg;\t\t \n\tstruct wf_sensor\tsens;\n};\n#define to_smu_ads(c) container_of(c, struct smu_ad_sensor, sens)\n\nstatic void smu_ads_release(struct wf_sensor *sr)\n{\n\tstruct smu_ad_sensor *ads = to_smu_ads(sr);\n\n\tkfree(ads);\n}\n\nstatic int smu_read_adc(u8 id, s32 *value)\n{\n\tstruct smu_simple_cmd\tcmd;\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tint rc;\n\n\trc = smu_queue_simple(&cmd, SMU_CMD_READ_ADC, 1,\n\t\t\t      smu_done_complete, &comp, id);\n\tif (rc)\n\t\treturn rc;\n\twait_for_completion(&comp);\n\tif (cmd.cmd.status != 0)\n\t\treturn cmd.cmd.status;\n\tif (cmd.cmd.reply_len != 2) {\n\t\tprintk(KERN_ERR \"winfarm: read ADC 0x%x returned %d bytes !\\n\",\n\t\t       id, cmd.cmd.reply_len);\n\t\treturn -EIO;\n\t}\n\t*value = *((u16 *)cmd.buffer);\n\treturn 0;\n}\n\nstatic int smu_cputemp_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct smu_ad_sensor *ads = to_smu_ads(sr);\n\tint rc;\n\ts32 val;\n\ts64 scaled;\n\n\trc = smu_read_adc(ads->reg, &val);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"windfarm: read CPU temp failed, err %d\\n\",\n\t\t       rc);\n\t\treturn rc;\n\t}\n\n\t \n\tscaled = (s64)(((u64)val) * (u64)cpudiode->m_value);\n\tscaled >>= 3;\n\tscaled += ((s64)cpudiode->b_value) << 9;\n\t*value = (s32)(scaled << 1);\n\n\treturn 0;\n}\n\nstatic int smu_cpuamp_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct smu_ad_sensor *ads = to_smu_ads(sr);\n\ts32 val, scaled;\n\tint rc;\n\n\trc = smu_read_adc(ads->reg, &val);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"windfarm: read CPU current failed, err %d\\n\",\n\t\t       rc);\n\t\treturn rc;\n\t}\n\n\t \n\tscaled = (s32)(val * (u32)cpuvcp->curr_scale);\n\tscaled += (s32)cpuvcp->curr_offset;\n\t*value = scaled << 4;\n\n\treturn 0;\n}\n\nstatic int smu_cpuvolt_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct smu_ad_sensor *ads = to_smu_ads(sr);\n\ts32 val, scaled;\n\tint rc;\n\n\trc = smu_read_adc(ads->reg, &val);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"windfarm: read CPU voltage failed, err %d\\n\",\n\t\t       rc);\n\t\treturn rc;\n\t}\n\n\t \n\tscaled = (s32)(val * (u32)cpuvcp->volt_scale);\n\tscaled += (s32)cpuvcp->volt_offset;\n\t*value = scaled << 4;\n\n\treturn 0;\n}\n\nstatic int smu_slotspow_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct smu_ad_sensor *ads = to_smu_ads(sr);\n\ts32 val, scaled;\n\tint rc;\n\n\trc = smu_read_adc(ads->reg, &val);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"windfarm: read slots power failed, err %d\\n\",\n\t\t       rc);\n\t\treturn rc;\n\t}\n\n\t \n\tscaled = (s32)(val * (u32)slotspow->pow_scale);\n\tscaled += (s32)slotspow->pow_offset;\n\t*value = scaled << 4;\n\n\treturn 0;\n}\n\n\nstatic const struct wf_sensor_ops smu_cputemp_ops = {\n\t.get_value\t= smu_cputemp_get,\n\t.release\t= smu_ads_release,\n\t.owner\t\t= THIS_MODULE,\n};\nstatic const struct wf_sensor_ops smu_cpuamp_ops = {\n\t.get_value\t= smu_cpuamp_get,\n\t.release\t= smu_ads_release,\n\t.owner\t\t= THIS_MODULE,\n};\nstatic const struct wf_sensor_ops smu_cpuvolt_ops = {\n\t.get_value\t= smu_cpuvolt_get,\n\t.release\t= smu_ads_release,\n\t.owner\t\t= THIS_MODULE,\n};\nstatic const struct wf_sensor_ops smu_slotspow_ops = {\n\t.get_value\t= smu_slotspow_get,\n\t.release\t= smu_ads_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\n\nstatic struct smu_ad_sensor *smu_ads_create(struct device_node *node)\n{\n\tstruct smu_ad_sensor *ads;\n\tconst char *l;\n\tconst u32 *v;\n\n\tads = kmalloc(sizeof(struct smu_ad_sensor), GFP_KERNEL);\n\tif (ads == NULL)\n\t\treturn NULL;\n\tl = of_get_property(node, \"location\", NULL);\n\tif (l == NULL)\n\t\tgoto fail;\n\n\t \n\tif (of_node_is_type(node, \"temp-sensor\") &&\n\t    !strcmp(l, \"CPU T-Diode\")) {\n\t\tads->sens.ops = &smu_cputemp_ops;\n\t\tads->sens.name = \"cpu-temp\";\n\t\tif (cpudiode == NULL) {\n\t\t\tDBG(\"wf: cpudiode partition (%02x) not found\\n\",\n\t\t\t    SMU_SDB_CPUDIODE_ID);\n\t\t\tgoto fail;\n\t\t}\n\t} else if (of_node_is_type(node, \"current-sensor\") &&\n\t\t   !strcmp(l, \"CPU Current\")) {\n\t\tads->sens.ops = &smu_cpuamp_ops;\n\t\tads->sens.name = \"cpu-current\";\n\t\tif (cpuvcp == NULL) {\n\t\t\tDBG(\"wf: cpuvcp partition (%02x) not found\\n\",\n\t\t\t    SMU_SDB_CPUVCP_ID);\n\t\t\tgoto fail;\n\t\t}\n\t} else if (of_node_is_type(node, \"voltage-sensor\") &&\n\t\t   !strcmp(l, \"CPU Voltage\")) {\n\t\tads->sens.ops = &smu_cpuvolt_ops;\n\t\tads->sens.name = \"cpu-voltage\";\n\t\tif (cpuvcp == NULL) {\n\t\t\tDBG(\"wf: cpuvcp partition (%02x) not found\\n\",\n\t\t\t    SMU_SDB_CPUVCP_ID);\n\t\t\tgoto fail;\n\t\t}\n\t} else if (of_node_is_type(node, \"power-sensor\") &&\n\t\t   !strcmp(l, \"Slots Power\")) {\n\t\tads->sens.ops = &smu_slotspow_ops;\n\t\tads->sens.name = \"slots-power\";\n\t\tif (slotspow == NULL) {\n\t\t\tDBG(\"wf: slotspow partition (%02x) not found\\n\",\n\t\t\t    SMU_SDB_SLOTSPOW_ID);\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tgoto fail;\n\n\tv = of_get_property(node, \"reg\", NULL);\n\tif (v == NULL)\n\t\tgoto fail;\n\tads->reg = *v;\n\n\tif (wf_register_sensor(&ads->sens))\n\t\tgoto fail;\n\treturn ads;\n fail:\n\tkfree(ads);\n\treturn NULL;\n}\n\n \n\nstruct smu_cpu_power_sensor {\n\tstruct list_head\tlink;\n\tstruct wf_sensor\t*volts;\n\tstruct wf_sensor\t*amps;\n\tunsigned int\t\tfake_volts : 1;\n\tunsigned int\t\tquadratic : 1;\n\tstruct wf_sensor\tsens;\n};\n#define to_smu_cpu_power(c) container_of(c, struct smu_cpu_power_sensor, sens)\n\nstatic struct smu_cpu_power_sensor *smu_cpu_power;\n\nstatic void smu_cpu_power_release(struct wf_sensor *sr)\n{\n\tstruct smu_cpu_power_sensor *pow = to_smu_cpu_power(sr);\n\n\tif (pow->volts)\n\t\twf_put_sensor(pow->volts);\n\tif (pow->amps)\n\t\twf_put_sensor(pow->amps);\n\tkfree(pow);\n}\n\nstatic int smu_cpu_power_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct smu_cpu_power_sensor *pow = to_smu_cpu_power(sr);\n\ts32 volts, amps, power;\n\tu64 tmps, tmpa, tmpb;\n\tint rc;\n\n\trc = pow->amps->ops->get_value(pow->amps, &amps);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pow->fake_volts) {\n\t\t*value = amps * 12 - 0x30000;\n\t\treturn 0;\n\t}\n\n\trc = pow->volts->ops->get_value(pow->volts, &volts);\n\tif (rc)\n\t\treturn rc;\n\n\tpower = (s32)((((u64)volts) * ((u64)amps)) >> 16);\n\tif (!pow->quadratic) {\n\t\t*value = power;\n\t\treturn 0;\n\t}\n\ttmps = (((u64)power) * ((u64)power)) >> 16;\n\ttmpa = ((u64)cpuvcp->power_quads[0]) * tmps;\n\ttmpb = ((u64)cpuvcp->power_quads[1]) * ((u64)power);\n\t*value = (tmpa >> 28) + (tmpb >> 28) + (cpuvcp->power_quads[2] >> 12);\n\n\treturn 0;\n}\n\nstatic const struct wf_sensor_ops smu_cpu_power_ops = {\n\t.get_value\t= smu_cpu_power_get,\n\t.release\t= smu_cpu_power_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\n\nstatic struct smu_cpu_power_sensor *\nsmu_cpu_power_create(struct wf_sensor *volts, struct wf_sensor *amps)\n{\n\tstruct smu_cpu_power_sensor *pow;\n\n\tpow = kmalloc(sizeof(struct smu_cpu_power_sensor), GFP_KERNEL);\n\tif (pow == NULL)\n\t\treturn NULL;\n\tpow->sens.ops = &smu_cpu_power_ops;\n\tpow->sens.name = \"cpu-power\";\n\n\twf_get_sensor(volts);\n\tpow->volts = volts;\n\twf_get_sensor(amps);\n\tpow->amps = amps;\n\n\t \n\tif (debugswitches && ((*debugswitches) & 0x80)) {\n\t\tprintk(KERN_INFO \"windfarm: CPU Power sensor using faked\"\n\t\t       \" voltage !\\n\");\n\t\tpow->fake_volts = 1;\n\t} else\n\t\tpow->fake_volts = 0;\n\n\t \n\tif ((of_machine_is_compatible(\"PowerMac8,1\") ||\n\t     of_machine_is_compatible(\"PowerMac8,2\") ||\n\t     of_machine_is_compatible(\"PowerMac9,1\")) &&\n\t    cpuvcp_version >= 2) {\n\t\tpow->quadratic = 1;\n\t\tDBG(\"windfarm: CPU Power using quadratic transform\\n\");\n\t} else\n\t\tpow->quadratic = 0;\n\n\tif (wf_register_sensor(&pow->sens))\n\t\tgoto fail;\n\treturn pow;\n fail:\n\tkfree(pow);\n\treturn NULL;\n}\n\nstatic void smu_fetch_param_partitions(void)\n{\n\tconst struct smu_sdbp_header *hdr;\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_CPUVCP_ID, NULL);\n\tif (hdr != NULL) {\n\t\tcpuvcp = (struct smu_sdbp_cpuvcp *)&hdr[1];\n\t\t \n\t\tcpuvcp_version = hdr->version;\n\t}\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_CPUDIODE_ID, NULL);\n\tif (hdr != NULL)\n\t\tcpudiode = (struct smu_sdbp_cpudiode *)&hdr[1];\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_SLOTSPOW_ID, NULL);\n\tif (hdr != NULL)\n\t\tslotspow = (struct smu_sdbp_slotspow *)&hdr[1];\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_DEBUG_SWITCHES_ID, NULL);\n\tif (hdr != NULL)\n\t\tdebugswitches = (u8 *)&hdr[1];\n}\n\nstatic int __init smu_sensors_init(void)\n{\n\tstruct device_node *smu, *sensors, *s;\n\tstruct smu_ad_sensor *volt_sensor = NULL, *curr_sensor = NULL;\n\n\tif (!smu_present())\n\t\treturn -ENODEV;\n\n\t \n\tsmu_fetch_param_partitions();\n\n\tsmu = of_find_node_by_type(NULL, \"smu\");\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_child_of_node(smu, sensors)\n\t\tif (of_node_name_eq(sensors, \"sensors\"))\n\t\t\tbreak;\n\n\tof_node_put(smu);\n\n\t \n\tfor (s = NULL;\n\t     sensors && (s = of_get_next_child(sensors, s)) != NULL;) {\n\t\tstruct smu_ad_sensor *ads;\n\n\t\tads = smu_ads_create(s);\n\t\tif (ads == NULL)\n\t\t\tcontinue;\n\t\tlist_add(&ads->link, &smu_ads);\n\t\t \n\t\tif (!strcmp(ads->sens.name, \"cpu-voltage\"))\n\t\t\tvolt_sensor = ads;\n\t\telse if (!strcmp(ads->sens.name, \"cpu-current\"))\n\t\t\tcurr_sensor = ads;\n\t}\n\n\tof_node_put(sensors);\n\n\t \n\tif (volt_sensor && curr_sensor)\n\t\tsmu_cpu_power = smu_cpu_power_create(&volt_sensor->sens,\n\t\t\t\t\t\t     &curr_sensor->sens);\n\n\treturn 0;\n}\n\nstatic void __exit smu_sensors_exit(void)\n{\n\tstruct smu_ad_sensor *ads;\n\n\t \n\tif (smu_cpu_power)\n\t\twf_unregister_sensor(&smu_cpu_power->sens);\n\n\t \n\twhile (!list_empty(&smu_ads)) {\n\t\tads = list_entry(smu_ads.next, struct smu_ad_sensor, link);\n\t\tlist_del(&ads->link);\n\t\twf_unregister_sensor(&ads->sens);\n\t}\n}\n\n\nmodule_init(smu_sensors_init);\nmodule_exit(smu_sensors_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"SMU sensor objects for PowerMacs thermal control\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}