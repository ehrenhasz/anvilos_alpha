{
  "module_name": "macio-adb.c",
  "hash_id": "eb00cc05d0a1bf7d611babe953c66498ff1189734802ff8f5897bd9bd2d3d73f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/macio-adb.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/pgtable.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/adb.h>\n\n#include <asm/io.h>\n#include <asm/hydra.h>\n#include <asm/irq.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n\nstruct preg {\n\tunsigned char r;\n\tchar pad[15];\n};\n\nstruct adb_regs {\n\tstruct preg intr;\n\tstruct preg data[9];\n\tstruct preg intr_enb;\n\tstruct preg dcount;\n\tstruct preg error;\n\tstruct preg ctrl;\n\tstruct preg autopoll;\n\tstruct preg active_hi;\n\tstruct preg active_lo;\n\tstruct preg test;\n};\n\n \n#define DFB\t1\t\t \n#define TAG\t2\t\t \n\n \n#define HMB\t0x0f\t\t \n#define APD\t0x10\t\t \n\n \n#define NRE\t1\t\t \n#define DLE\t2\t\t \n\n \n#define TAR\t1\t\t \n#define DTB\t2\t\t \n#define CRE\t4\t\t \n#define ADB_RST\t8\t\t \n\n \n#define APE\t1\t\t \n\nstatic volatile struct adb_regs __iomem *adb;\nstatic struct adb_request *current_req, *last_req;\nstatic DEFINE_SPINLOCK(macio_lock);\n\nstatic int macio_probe(void);\nstatic int macio_init(void);\nstatic irqreturn_t macio_adb_interrupt(int irq, void *arg);\nstatic int macio_send_request(struct adb_request *req, int sync);\nstatic int macio_adb_autopoll(int devs);\nstatic void macio_adb_poll(void);\nstatic int macio_adb_reset_bus(void);\n\nstruct adb_driver macio_adb_driver = {\n\t.name         = \"MACIO\",\n\t.probe        = macio_probe,\n\t.init         = macio_init,\n\t.send_request = macio_send_request,\n\t.autopoll     = macio_adb_autopoll,\n\t.poll         = macio_adb_poll,\n\t.reset_bus    = macio_adb_reset_bus,\n};\n\nint macio_probe(void)\n{\n\tstruct device_node *np;\n\n\tnp = of_find_compatible_node(NULL, \"adb\", \"chrp,adb0\");\n\tif (np) {\n\t\tof_node_put(np);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nint macio_init(void)\n{\n\tstruct device_node *adbs;\n\tstruct resource r;\n\tunsigned int irq;\n\n\tadbs = of_find_compatible_node(NULL, \"adb\", \"chrp,adb0\");\n\tif (!adbs)\n\t\treturn -ENXIO;\n\n\tif (of_address_to_resource(adbs, 0, &r)) {\n\t\tof_node_put(adbs);\n\t\treturn -ENXIO;\n\t}\n\tadb = ioremap(r.start, sizeof(struct adb_regs));\n\tif (!adb) {\n\t\tof_node_put(adbs);\n\t\treturn -ENOMEM;\n\t}\n\n\tout_8(&adb->ctrl.r, 0);\n\tout_8(&adb->intr.r, 0);\n\tout_8(&adb->error.r, 0);\n\tout_8(&adb->active_hi.r, 0xff);  \n\tout_8(&adb->active_lo.r, 0xff);\n\tout_8(&adb->autopoll.r, APE);\n\n\tirq = irq_of_parse_and_map(adbs, 0);\n\tof_node_put(adbs);\n\tif (request_irq(irq, macio_adb_interrupt, 0, \"ADB\", (void *)0)) {\n\t\tprintk(KERN_ERR \"ADB: can't get irq %d\\n\", irq);\n\t\treturn -EAGAIN;\n\t}\n\tout_8(&adb->intr_enb.r, DFB | TAG);\n\n\tprintk(\"adb: mac-io driver 1.0 for unified ADB\\n\");\n\n\treturn 0;\n}\n\nstatic int macio_adb_autopoll(int devs)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&macio_lock, flags);\n\tout_8(&adb->active_hi.r, devs >> 8);\n\tout_8(&adb->active_lo.r, devs);\n\tout_8(&adb->autopoll.r, devs? APE: 0);\n\tspin_unlock_irqrestore(&macio_lock, flags);\n\treturn 0;\n}\n\nstatic int macio_adb_reset_bus(void)\n{\n\tunsigned long flags;\n\tint timeout = 1000000;\n\n\t \n\tspin_lock_irqsave(&macio_lock, flags);\n\tout_8(&adb->ctrl.r, in_8(&adb->ctrl.r) | ADB_RST);\n\twhile ((in_8(&adb->ctrl.r) & ADB_RST) != 0) {\n\t\tif (--timeout == 0) {\n\t\t\tout_8(&adb->ctrl.r, in_8(&adb->ctrl.r) & ~ADB_RST);\n\t\t\tspin_unlock_irqrestore(&macio_lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&macio_lock, flags);\n\treturn 0;\n}\n\n \nstatic int macio_send_request(struct adb_request *req, int sync)\n{\n\tunsigned long flags;\n\tint i;\n\t\n\tif (req->data[0] != ADB_PACKET)\n\t\treturn -EINVAL;\n\t\n\tfor (i = 0; i < req->nbytes - 1; ++i)\n\t\treq->data[i] = req->data[i+1];\n\t--req->nbytes;\n\t\n\treq->next = NULL;\n\treq->sent = 0;\n\treq->complete = 0;\n\treq->reply_len = 0;\n\n\tspin_lock_irqsave(&macio_lock, flags);\n\tif (current_req) {\n\t\tlast_req->next = req;\n\t\tlast_req = req;\n\t} else {\n\t\tcurrent_req = last_req = req;\n\t\tout_8(&adb->ctrl.r, in_8(&adb->ctrl.r) | TAR);\n\t}\n\tspin_unlock_irqrestore(&macio_lock, flags);\n\t\n\tif (sync) {\n\t\twhile (!req->complete)\n\t\t\tmacio_adb_poll();\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t macio_adb_interrupt(int irq, void *arg)\n{\n\tint i, n, err;\n\tstruct adb_request *req = NULL;\n\tunsigned char ibuf[16];\n\tint ibuf_len = 0;\n\tint complete = 0;\n\tint autopoll = 0;\n\tint handled = 0;\n\n\tspin_lock(&macio_lock);\n\tif (in_8(&adb->intr.r) & TAG) {\n\t\thandled = 1;\n\t\treq = current_req;\n\t\tif (req) {\n\t\t\t \n\t\t\tfor (i = 0; i < req->nbytes; ++i)\n\t\t\t\tout_8(&adb->data[i].r, req->data[i]);\n\t\t\tout_8(&adb->dcount.r, req->nbytes & HMB);\n\t\t\treq->sent = 1;\n\t\t\tif (req->reply_expected) {\n\t\t\t\tout_8(&adb->ctrl.r, DTB + CRE);\n\t\t\t} else {\n\t\t\t\tout_8(&adb->ctrl.r, DTB);\n\t\t\t\tcurrent_req = req->next;\n\t\t\t\tcomplete = 1;\n\t\t\t\tif (current_req)\n\t\t\t\t\tout_8(&adb->ctrl.r, in_8(&adb->ctrl.r) | TAR);\n\t\t\t}\n\t\t}\n\t\tout_8(&adb->intr.r, 0);\n\t}\n\n\tif (in_8(&adb->intr.r) & DFB) {\n\t\thandled = 1;\n\t\terr = in_8(&adb->error.r);\n\t\tif (current_req && current_req->sent) {\n\t\t\t \n\t\t\treq = current_req;\n\t\t\tif (err == 0) {\n\t\t\t\treq->reply_len = in_8(&adb->dcount.r) & HMB;\n\t\t\t\tfor (i = 0; i < req->reply_len; ++i)\n\t\t\t\t\treq->reply[i] = in_8(&adb->data[i].r);\n\t\t\t}\n\t\t\tcurrent_req = req->next;\n\t\t\tcomplete = 1;\n\t\t\tif (current_req)\n\t\t\t\tout_8(&adb->ctrl.r, in_8(&adb->ctrl.r) | TAR);\n\t\t} else if (err == 0) {\n\t\t\t \n\t\t\tn = in_8(&adb->dcount.r) & HMB;\n\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\tibuf[i] = in_8(&adb->data[i].r);\n\t\t\tibuf_len = n;\n\t\t\tautopoll = (in_8(&adb->dcount.r) & APD) != 0;\n\t\t}\n\t\tout_8(&adb->error.r, 0);\n\t\tout_8(&adb->intr.r, 0);\n\t}\n\tspin_unlock(&macio_lock);\n\tif (complete && req) {\n\t    void (*done)(struct adb_request *) = req->done;\n\t    mb();\n\t    req->complete = 1;\n\t     \n\t    if (done)\n\t\t(*done)(req);\n\t}\n\tif (ibuf_len)\n\t\tadb_input(ibuf, ibuf_len, autopoll);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void macio_adb_poll(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tif (in_8(&adb->intr.r) != 0)\n\t\tmacio_adb_interrupt(0, NULL);\n\tlocal_irq_restore(flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}