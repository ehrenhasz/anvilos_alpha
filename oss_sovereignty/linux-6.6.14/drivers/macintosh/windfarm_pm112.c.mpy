{
  "module_name": "windfarm_pm112.c",
  "hash_id": "2fdbea98dd0f3fdb15c16e1d0057fed8d8f625f960446af8c118c72a43d1346b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_pm112.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_pid.h\"\n\n#define VERSION \"0.2\"\n\n#define DEBUG\n#undef LOTSA_DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n#ifdef LOTSA_DEBUG\n#define DBG_LOTS(args...)\tprintk(args)\n#else\n#define DBG_LOTS(args...)\tdo { } while(0)\n#endif\n\n \n#undef HACKED_OVERTEMP\n\n \n#define NR_CHIPS\t2\n#define NR_CORES\t4\n#define NR_CPU_FANS\t3 * NR_CHIPS\n\n \nstatic struct wf_sensor *sens_cpu_temp[NR_CORES];\nstatic struct wf_sensor *sens_cpu_power[NR_CORES];\nstatic struct wf_sensor *hd_temp;\nstatic struct wf_sensor *slots_power;\nstatic struct wf_sensor *u4_temp;\n\nstatic struct wf_control *cpu_fans[NR_CPU_FANS];\nstatic char *cpu_fan_names[NR_CPU_FANS] = {\n\t\"cpu-rear-fan-0\",\n\t\"cpu-rear-fan-1\",\n\t\"cpu-front-fan-0\",\n\t\"cpu-front-fan-1\",\n\t\"cpu-pump-0\",\n\t\"cpu-pump-1\",\n};\nstatic struct wf_control *cpufreq_clamp;\n\n \n#define CPU_FANS_REQD\t\t(NR_CPU_FANS - 2)\n#define FIRST_PUMP\t\t4\n#define LAST_PUMP\t\t5\n\n \n#define CPU_TEMP_HIST_SIZE\t180\n\n \nstatic int cpu_fan_scale[NR_CPU_FANS] = {\n\t100,\n\t100,\n\t97,\t\t \n\t97,\n\t100,\t\t \n\t100,\t\t \n};\n\nstatic struct wf_control *backside_fan;\nstatic struct wf_control *slots_fan;\nstatic struct wf_control *drive_bay_fan;\n\n \nstatic struct wf_cpu_pid_state cpu_pid[NR_CORES];\nstatic u32 cpu_thist[CPU_TEMP_HIST_SIZE];\nstatic int cpu_thist_pt;\nstatic s64 cpu_thist_total;\nstatic s32 cpu_all_tmax = 100 << 16;\nstatic int cpu_last_target;\nstatic struct wf_pid_state backside_pid;\nstatic int backside_tick;\nstatic struct wf_pid_state slots_pid;\nstatic bool slots_started;\nstatic struct wf_pid_state drive_bay_pid;\nstatic int drive_bay_tick;\n\nstatic int nr_cores;\nstatic int have_all_controls;\nstatic int have_all_sensors;\nstatic bool started;\n\nstatic int failure_state;\n#define FAILURE_SENSOR\t\t1\n#define FAILURE_FAN\t\t2\n#define FAILURE_PERM\t\t4\n#define FAILURE_LOW_OVERTEMP\t8\n#define FAILURE_HIGH_OVERTEMP\t16\n\n \n#define LOW_OVER_AVERAGE\t0\n#define LOW_OVER_IMMEDIATE\t(10 << 16)\n#define LOW_OVER_CLEAR\t\t((-10) << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n#define HIGH_OVER_AVERAGE\t(10 << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n\n\n \nstatic int create_cpu_loop(int cpu)\n{\n\tint chip = cpu / 2;\n\tint core = cpu & 1;\n\tstruct smu_sdbp_header *hdr;\n\tstruct smu_sdbp_cpupiddata *piddata;\n\tstruct wf_cpu_pid_param pid;\n\tstruct wf_control *main_fan = cpu_fans[0];\n\ts32 tmax;\n\tint fmin;\n\n\t \n\thdr = smu_sat_get_sdb_partition(chip, 0xC4 + core, NULL);\n\tif (hdr) {\n\t\tstruct smu_sdbp_fvt *fvt = (struct smu_sdbp_fvt *)&hdr[1];\n\t\ttmax = fvt->maxtemp << 16;\n\t} else\n\t\ttmax = 95 << 16;\t \n\n\t \n\tif (tmax < cpu_all_tmax)\n\t\tcpu_all_tmax = tmax;\n\n\tkfree(hdr);\n\n\t \n\thdr = smu_sat_get_sdb_partition(chip, 0xC8 + core, NULL);\n\tif (hdr == NULL) {\n\t\tprintk(KERN_WARNING\"windfarm: can't get CPU PID fan config\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\n\n\t \n\tfmin = (nr_cores > 2) ? 750 : 515;\n\n\t \n\tpid.interval = 1;\t \n\tpid.history_len = piddata->history_len;\n\tpid.gd = piddata->gd;\n\tpid.gp = piddata->gp;\n\tpid.gr = piddata->gr / piddata->history_len;\n\tpid.pmaxadj = (piddata->max_power << 16) - (piddata->power_adj << 8);\n\tpid.ttarget = tmax - (piddata->target_temp_delta << 16);\n\tpid.tmax = tmax;\n\tpid.min = main_fan->ops->get_min(main_fan);\n\tpid.max = main_fan->ops->get_max(main_fan);\n\tif (pid.min < fmin)\n\t\tpid.min = fmin;\n\n\twf_cpu_pid_init(&cpu_pid[cpu], &pid);\n\n\tkfree(hdr);\n\n\treturn 0;\n}\n\nstatic void cpu_max_all_fans(void)\n{\n\tint i;\n\n\t \n\tif (cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tfor (i = 0; i < NR_CPU_FANS; ++i)\n\t\tif (cpu_fans[i])\n\t\t\twf_control_set_max(cpu_fans[i]);\n}\n\nstatic int cpu_check_overtemp(s32 temp)\n{\n\tint new_state = 0;\n\ts32 t_avg, t_old;\n\n\t \n\tif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to immediate CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" immediate CPU temperature !\\n\");\n\t}\n\n\t \n\tt_old = cpu_thist[cpu_thist_pt];\n\tcpu_thist[cpu_thist_pt] = temp;\n\tcpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\n\tcpu_thist_total -= t_old;\n\tcpu_thist_total += temp;\n\tt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\n\n\tDBG_LOTS(\"t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\\n\",\n\t\t FIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\n\n\t \n\tif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to average CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" average CPU temperature !\\n\");\n\t}\n\n\t \n\tif (new_state) {\n\t\t \n\t\tif (new_state & FAILURE_HIGH_OVERTEMP)\n\t\t\tmachine_power_off();\n\t\tif ((failure_state & new_state) != new_state)\n\t\t\tcpu_max_all_fans();\n\t\tfailure_state |= new_state;\n\t} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\n\t\t   (temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\n\t\tprintk(KERN_ERR \"windfarm: Overtemp condition cleared !\\n\");\n\t\tfailure_state &= ~FAILURE_LOW_OVERTEMP;\n\t}\n\n\treturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\n}\n\nstatic void cpu_fans_tick(void)\n{\n\tint err, cpu;\n\ts32 greatest_delta = 0;\n\ts32 temp, power, t_max = 0;\n\tint i, t, target = 0;\n\tstruct wf_sensor *sr;\n\tstruct wf_control *ct;\n\tstruct wf_cpu_pid_state *sp;\n\n\tDBG_LOTS(KERN_DEBUG);\n\tfor (cpu = 0; cpu < nr_cores; ++cpu) {\n\t\t \n\t\tsr = sens_cpu_temp[cpu];\n\t\terr = sr->ops->get_value(sr, &temp);\n\t\tif (err) {\n\t\t\tDBG(\"\\n\");\n\t\t\tprintk(KERN_WARNING \"windfarm: CPU %d temperature \"\n\t\t\t       \"sensor error %d\\n\", cpu, err);\n\t\t\tfailure_state |= FAILURE_SENSOR;\n\t\t\tcpu_max_all_fans();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tt_max = max(t_max, temp);\n\n\t\t \n\t\tsr = sens_cpu_power[cpu];\n\t\terr = sr->ops->get_value(sr, &power);\n\t\tif (err) {\n\t\t\tDBG(\"\\n\");\n\t\t\tprintk(KERN_WARNING \"windfarm: CPU %d power \"\n\t\t\t       \"sensor error %d\\n\", cpu, err);\n\t\t\tfailure_state |= FAILURE_SENSOR;\n\t\t\tcpu_max_all_fans();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsp = &cpu_pid[cpu];\n\t\tt = wf_cpu_pid_run(sp, power, temp);\n\n\t\tif (cpu == 0 || sp->last_delta > greatest_delta) {\n\t\t\tgreatest_delta = sp->last_delta;\n\t\t\ttarget = t;\n\t\t}\n\t\tDBG_LOTS(\"[%d] P=%d.%.3d T=%d.%.3d \",\n\t\t    cpu, FIX32TOPRINT(power), FIX32TOPRINT(temp));\n\t}\n\tDBG_LOTS(\"fans = %d, t_max = %d.%03d\\n\", target, FIX32TOPRINT(t_max));\n\n\t \n\tif (target < (cpu_last_target - 20))\n\t\ttarget = cpu_last_target - 20;\n\tcpu_last_target = target;\n\tfor (cpu = 0; cpu < nr_cores; ++cpu)\n\t\tcpu_pid[cpu].target = target;\n\n\t \n\tif (cpu_check_overtemp(t_max))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < NR_CPU_FANS; ++i) {\n\t\tct = cpu_fans[i];\n\t\tif (ct == NULL)\n\t\t\tcontinue;\n\t\terr = ct->ops->set_value(ct, target * cpu_fan_scale[i] / 100);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING \"windfarm: fan %s reports \"\n\t\t\t       \"error %d\\n\", ct->name, err);\n\t\t\tfailure_state |= FAILURE_FAN;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic struct wf_pid_param backside_param = {\n\t.interval\t= 5,\n\t.history_len\t= 2,\n\t.gd\t\t= 48 << 20,\n\t.gp\t\t= 5 << 20,\n\t.gr\t\t= 0,\n\t.itarget\t= 64 << 16,\n\t.additive\t= 1,\n};\n\nstatic void backside_fan_tick(void)\n{\n\ts32 temp;\n\tint speed;\n\tint err;\n\n\tif (!backside_fan || !u4_temp)\n\t\treturn;\n\tif (!backside_tick) {\n\t\t \n\t\tprintk(KERN_INFO \"windfarm: Backside control loop started.\\n\");\n\t\tbackside_param.min = backside_fan->ops->get_min(backside_fan);\n\t\tbackside_param.max = backside_fan->ops->get_max(backside_fan);\n\t\twf_pid_init(&backside_pid, &backside_param);\n\t\tbackside_tick = 1;\n\t}\n\tif (--backside_tick > 0)\n\t\treturn;\n\tbackside_tick = backside_pid.param.interval;\n\n\terr = u4_temp->ops->get_value(u4_temp, &temp);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: U4 temp sensor error %d\\n\",\n\t\t       err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(backside_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&backside_pid, temp);\n\tDBG_LOTS(\"backside PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\terr = backside_fan->ops->set_value(backside_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: backside fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\n \nstatic struct wf_pid_param drive_bay_prm = {\n\t.interval\t= 5,\n\t.history_len\t= 2,\n\t.gd\t\t= 30 << 20,\n\t.gp\t\t= 5 << 20,\n\t.gr\t\t= 0,\n\t.itarget\t= 40 << 16,\n\t.additive\t= 1,\n};\n\nstatic void drive_bay_fan_tick(void)\n{\n\ts32 temp;\n\tint speed;\n\tint err;\n\n\tif (!drive_bay_fan || !hd_temp)\n\t\treturn;\n\tif (!drive_bay_tick) {\n\t\t \n\t\tprintk(KERN_INFO \"windfarm: Drive bay control loop started.\\n\");\n\t\tdrive_bay_prm.min = drive_bay_fan->ops->get_min(drive_bay_fan);\n\t\tdrive_bay_prm.max = drive_bay_fan->ops->get_max(drive_bay_fan);\n\t\twf_pid_init(&drive_bay_pid, &drive_bay_prm);\n\t\tdrive_bay_tick = 1;\n\t}\n\tif (--drive_bay_tick > 0)\n\t\treturn;\n\tdrive_bay_tick = drive_bay_pid.param.interval;\n\n\terr = hd_temp->ops->get_value(hd_temp, &temp);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: drive bay temp sensor \"\n\t\t       \"error %d\\n\", err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(drive_bay_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&drive_bay_pid, temp);\n\tDBG_LOTS(\"drive_bay PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\terr = drive_bay_fan->ops->set_value(drive_bay_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: drive bay fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\n \n \nstatic struct wf_pid_param slots_param = {\n\t.interval\t= 1,\n\t.history_len\t= 2,\n\t.gd\t\t= 0,\n\t.gp\t\t= 0,\n\t.gr\t\t= 0x1277952,\n\t.itarget\t= 0,\n\t.min\t\t= 1560,\n\t.max\t\t= 3510,\n};\n\nstatic void slots_fan_tick(void)\n{\n\ts32 power;\n\tint speed;\n\tint err;\n\n\tif (!slots_fan || !slots_power)\n\t\treturn;\n\tif (!slots_started) {\n\t\t \n\t\tprintk(KERN_INFO \"windfarm: Slots control loop started.\\n\");\n\t\twf_pid_init(&slots_pid, &slots_param);\n\t\tslots_started = true;\n\t}\n\n\terr = slots_power->ops->get_value(slots_power, &power);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: slots power sensor error %d\\n\",\n\t\t       err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(slots_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&slots_pid, power);\n\tDBG_LOTS(\"slots PID power=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(power), speed);\n\n\terr = slots_fan->ops->set_value(slots_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: slots fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\nstatic void set_fail_state(void)\n{\n\tint i;\n\n\tif (cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tfor (i = 0; i < NR_CPU_FANS; ++i)\n\t\tif (cpu_fans[i])\n\t\t\twf_control_set_max(cpu_fans[i]);\n\tif (backside_fan)\n\t\twf_control_set_max(backside_fan);\n\tif (slots_fan)\n\t\twf_control_set_max(slots_fan);\n\tif (drive_bay_fan)\n\t\twf_control_set_max(drive_bay_fan);\n}\n\nstatic void pm112_tick(void)\n{\n\tint i, last_failure;\n\n\tif (!started) {\n\t\tstarted = true;\n\t\tprintk(KERN_INFO \"windfarm: CPUs control loops started.\\n\");\n\t\tfor (i = 0; i < nr_cores; ++i) {\n\t\t\tif (create_cpu_loop(i) < 0) {\n\t\t\t\tfailure_state = FAILURE_PERM;\n\t\t\t\tset_fail_state();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDBG_LOTS(\"cpu_all_tmax=%d.%03d\\n\", FIX32TOPRINT(cpu_all_tmax));\n\n#ifdef HACKED_OVERTEMP\n\t\tcpu_all_tmax = 60 << 16;\n#endif\n\t}\n\n\t \n\tif (failure_state & FAILURE_PERM)\n\t\treturn;\n\t \n\tlast_failure = failure_state;\n\tfailure_state &= FAILURE_LOW_OVERTEMP;\n\tcpu_fans_tick();\n\tbackside_fan_tick();\n\tslots_fan_tick();\n\tdrive_bay_fan_tick();\n\n\tDBG_LOTS(\"last_failure: 0x%x, failure_state: %x\\n\",\n\t\t last_failure, failure_state);\n\n\t \n\tif (failure_state && last_failure == 0 && cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tif (failure_state == 0 && last_failure && cpufreq_clamp)\n\t\twf_control_set_min(cpufreq_clamp);\n\n\t \n}\n\nstatic void pm112_new_control(struct wf_control *ct)\n{\n\tint i, max_exhaust;\n\n\tif (cpufreq_clamp == NULL && !strcmp(ct->name, \"cpufreq-clamp\")) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tcpufreq_clamp = ct;\n\t}\n\n\tfor (i = 0; i < NR_CPU_FANS; ++i) {\n\t\tif (!strcmp(ct->name, cpu_fan_names[i])) {\n\t\t\tif (cpu_fans[i] == NULL && wf_get_control(ct) == 0)\n\t\t\t\tcpu_fans[i] = ct;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= NR_CPU_FANS) {\n\t\t \n\t\tif (!strcmp(ct->name, \"backside-fan\")) {\n\t\t\tif (backside_fan == NULL && wf_get_control(ct) == 0)\n\t\t\t\tbackside_fan = ct;\n\t\t} else if (!strcmp(ct->name, \"slots-fan\")) {\n\t\t\tif (slots_fan == NULL && wf_get_control(ct) == 0)\n\t\t\t\tslots_fan = ct;\n\t\t} else if (!strcmp(ct->name, \"drive-bay-fan\")) {\n\t\t\tif (drive_bay_fan == NULL && wf_get_control(ct) == 0)\n\t\t\t\tdrive_bay_fan = ct;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < CPU_FANS_REQD; ++i)\n\t\tif (cpu_fans[i] == NULL)\n\t\t\treturn;\n\n\t \n\tmax_exhaust = cpu_fans[0]->ops->get_max(cpu_fans[0]);\n\tfor (i = FIRST_PUMP; i <= LAST_PUMP; ++i)\n\t\tif ((ct = cpu_fans[i]) != NULL)\n\t\t\tcpu_fan_scale[i] =\n\t\t\t\tct->ops->get_max(ct) * 100 / max_exhaust;\n\n\thave_all_controls = 1;\n}\n\nstatic void pm112_new_sensor(struct wf_sensor *sr)\n{\n\tunsigned int i;\n\n\tif (!strncmp(sr->name, \"cpu-temp-\", 9)) {\n\t\ti = sr->name[9] - '0';\n\t\tif (sr->name[10] == 0 && i < NR_CORES &&\n\t\t    sens_cpu_temp[i] == NULL && wf_get_sensor(sr) == 0)\n\t\t\tsens_cpu_temp[i] = sr;\n\n\t} else if (!strncmp(sr->name, \"cpu-power-\", 10)) {\n\t\ti = sr->name[10] - '0';\n\t\tif (sr->name[11] == 0 && i < NR_CORES &&\n\t\t    sens_cpu_power[i] == NULL && wf_get_sensor(sr) == 0)\n\t\t\tsens_cpu_power[i] = sr;\n\t} else if (!strcmp(sr->name, \"hd-temp\")) {\n\t\tif (hd_temp == NULL && wf_get_sensor(sr) == 0)\n\t\t\thd_temp = sr;\n\t} else if (!strcmp(sr->name, \"slots-power\")) {\n\t\tif (slots_power == NULL && wf_get_sensor(sr) == 0)\n\t\t\tslots_power = sr;\n\t} else if (!strcmp(sr->name, \"backside-temp\")) {\n\t\tif (u4_temp == NULL && wf_get_sensor(sr) == 0)\n\t\t\tu4_temp = sr;\n\t} else\n\t\treturn;\n\n\t \n\tfor (i = 0; i < nr_cores; ++i)\n\t\tif (sens_cpu_temp[i] == NULL || sens_cpu_power[i] == NULL)\n\t\t\treturn;\n\n\thave_all_sensors = 1;\n}\n\nstatic int pm112_wf_notify(struct notifier_block *self,\n\t\t\t   unsigned long event, void *data)\n{\n\tswitch (event) {\n\tcase WF_EVENT_NEW_SENSOR:\n\t\tpm112_new_sensor(data);\n\t\tbreak;\n\tcase WF_EVENT_NEW_CONTROL:\n\t\tpm112_new_control(data);\n\t\tbreak;\n\tcase WF_EVENT_TICK:\n\t\tif (have_all_controls && have_all_sensors)\n\t\t\tpm112_tick();\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block pm112_events = {\n\t.notifier_call = pm112_wf_notify,\n};\n\nstatic int wf_pm112_probe(struct platform_device *dev)\n{\n\twf_register_client(&pm112_events);\n\treturn 0;\n}\n\nstatic int wf_pm112_remove(struct platform_device *dev)\n{\n\twf_unregister_client(&pm112_events);\n\t \n\treturn 0;\n}\n\nstatic struct platform_driver wf_pm112_driver = {\n\t.probe = wf_pm112_probe,\n\t.remove = wf_pm112_remove,\n\t.driver = {\n\t\t.name = \"windfarm\",\n\t},\n};\n\nstatic int __init wf_pm112_init(void)\n{\n\tstruct device_node *cpu;\n\n\tif (!of_machine_is_compatible(\"PowerMac11,2\"))\n\t\treturn -ENODEV;\n\n\t \n\tnr_cores = 0;\n\tfor_each_node_by_type(cpu, \"cpu\")\n\t\t++nr_cores;\n\n\tprintk(KERN_INFO \"windfarm: initializing for dual-core desktop G5\\n\");\n\n#ifdef MODULE\n\trequest_module(\"windfarm_smu_controls\");\n\trequest_module(\"windfarm_smu_sensors\");\n\trequest_module(\"windfarm_smu_sat\");\n\trequest_module(\"windfarm_lm75_sensor\");\n\trequest_module(\"windfarm_max6690_sensor\");\n\trequest_module(\"windfarm_cpufreq_clamp\");\n\n#endif  \n\n\tplatform_driver_register(&wf_pm112_driver);\n\treturn 0;\n}\n\nstatic void __exit wf_pm112_exit(void)\n{\n\tplatform_driver_unregister(&wf_pm112_driver);\n}\n\nmodule_init(wf_pm112_init);\nmodule_exit(wf_pm112_exit);\n\nMODULE_AUTHOR(\"Paul Mackerras <paulus@samba.org>\");\nMODULE_DESCRIPTION(\"Thermal control for PowerMac11,2\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:windfarm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}