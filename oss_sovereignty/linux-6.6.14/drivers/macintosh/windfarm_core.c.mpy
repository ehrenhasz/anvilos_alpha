{
  "module_name": "windfarm_core.c",
  "hash_id": "a8da6cbdd6c47439bb2d3ddfc9f1bcceed9cd88c027135ff07ef0957d4efafcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_core.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/jiffies.h>\n#include <linux/reboot.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/freezer.h>\n\n#include \"windfarm.h\"\n\n#define VERSION \"0.2\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\nstatic LIST_HEAD(wf_controls);\nstatic LIST_HEAD(wf_sensors);\nstatic DEFINE_MUTEX(wf_lock);\nstatic BLOCKING_NOTIFIER_HEAD(wf_client_list);\nstatic int wf_client_count;\nstatic unsigned int wf_overtemp;\nstatic unsigned int wf_overtemp_counter;\nstatic struct task_struct *wf_thread;\n\nstatic struct platform_device wf_platform_device = {\n\t.name\t= \"windfarm\",\n};\n\n \n\nstatic inline void wf_notify(int event, void *param)\n{\n\tblocking_notifier_call_chain(&wf_client_list, event, param);\n}\n\nstatic int wf_critical_overtemp(void)\n{\n\tstatic char const critical_overtemp_path[] = \"/sbin/critical_overtemp\";\n\tchar *argv[] = { (char *)critical_overtemp_path, NULL };\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\t\t\"TERM=linux\",\n\t\t\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\t\t\tNULL };\n\n\treturn call_usermodehelper(critical_overtemp_path,\n\t\t\t\t   argv, envp, UMH_WAIT_EXEC);\n}\n\nstatic int wf_thread_func(void *data)\n{\n\tunsigned long next, delay;\n\n\tnext = jiffies;\n\n\tDBG(\"wf: thread started\\n\");\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\ttry_to_freeze();\n\n\t\tif (time_after_eq(jiffies, next)) {\n\t\t\twf_notify(WF_EVENT_TICK, NULL);\n\t\t\tif (wf_overtemp) {\n\t\t\t\twf_overtemp_counter++;\n\t\t\t\t \n\t\t\t\tif (wf_overtemp_counter > 10)\n\t\t\t\t\twf_critical_overtemp();\n\t\t\t\t \n\t\t\t\tif (wf_overtemp_counter > 30) {\n\t\t\t\t\tprintk(KERN_ERR \"windfarm: Overtemp \"\n\t\t\t\t\t       \"for more than 30\"\n\t\t\t\t\t       \" seconds, shutting down\\n\");\n\t\t\t\t\tmachine_power_off();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext += HZ;\n\t\t}\n\n\t\tdelay = next - jiffies;\n\t\tif (delay <= HZ)\n\t\t\tschedule_timeout_interruptible(delay);\n\t}\n\n\tDBG(\"wf: thread stopped\\n\");\n\n\treturn 0;\n}\n\nstatic void wf_start_thread(void)\n{\n\twf_thread = kthread_run(wf_thread_func, NULL, \"kwindfarm\");\n\tif (IS_ERR(wf_thread)) {\n\t\tprintk(KERN_ERR \"windfarm: failed to create thread,err %ld\\n\",\n\t\t       PTR_ERR(wf_thread));\n\t\twf_thread = NULL;\n\t}\n}\n\n\nstatic void wf_stop_thread(void)\n{\n\tif (wf_thread)\n\t\tkthread_stop(wf_thread);\n\twf_thread = NULL;\n}\n\n \n\nstatic void wf_control_release(struct kref *kref)\n{\n\tstruct wf_control *ct = container_of(kref, struct wf_control, ref);\n\n\tDBG(\"wf: Deleting control %s\\n\", ct->name);\n\n\tif (ct->ops && ct->ops->release)\n\t\tct->ops->release(ct);\n\telse\n\t\tkfree(ct);\n}\n\nstatic ssize_t wf_show_control(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct wf_control *ctrl = container_of(attr, struct wf_control, attr);\n\tconst char *typestr;\n\ts32 val = 0;\n\tint err;\n\n\terr = ctrl->ops->get_value(ctrl, &val);\n\tif (err < 0) {\n\t\tif (err == -EFAULT)\n\t\t\treturn sprintf(buf, \"<HW FAULT>\\n\");\n\t\treturn err;\n\t}\n\tswitch(ctrl->type) {\n\tcase WF_CONTROL_RPM_FAN:\n\t\ttypestr = \" RPM\";\n\t\tbreak;\n\tcase WF_CONTROL_PWM_FAN:\n\t\ttypestr = \" %\";\n\t\tbreak;\n\tdefault:\n\t\ttypestr = \"\";\n\t}\n\treturn sprintf(buf, \"%d%s\\n\", val, typestr);\n}\n\n \nstatic ssize_t wf_store_control(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct wf_control *ctrl = container_of(attr, struct wf_control, attr);\n\tint val;\n\tint err;\n\tchar *endp;\n\n\tval = simple_strtoul(buf, &endp, 0);\n\twhile (endp < buf + count && (*endp == ' ' || *endp == '\\n'))\n\t\t++endp;\n\tif (endp - buf < count)\n\t\treturn -EINVAL;\n\terr = ctrl->ops->set_value(ctrl, val);\n\tif (err < 0)\n\t\treturn err;\n\treturn count;\n}\n\nint wf_register_control(struct wf_control *new_ct)\n{\n\tstruct wf_control *ct;\n\n\tmutex_lock(&wf_lock);\n\tlist_for_each_entry(ct, &wf_controls, link) {\n\t\tif (!strcmp(ct->name, new_ct->name)) {\n\t\t\tprintk(KERN_WARNING \"windfarm: trying to register\"\n\t\t\t       \" duplicate control %s\\n\", ct->name);\n\t\t\tmutex_unlock(&wf_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tkref_init(&new_ct->ref);\n\tlist_add(&new_ct->link, &wf_controls);\n\n\tsysfs_attr_init(&new_ct->attr.attr);\n\tnew_ct->attr.attr.name = new_ct->name;\n\tnew_ct->attr.attr.mode = 0644;\n\tnew_ct->attr.show = wf_show_control;\n\tnew_ct->attr.store = wf_store_control;\n\tif (device_create_file(&wf_platform_device.dev, &new_ct->attr))\n\t\tprintk(KERN_WARNING \"windfarm: device_create_file failed\"\n\t\t\t\" for %s\\n\", new_ct->name);\n\t\t \n\n\tDBG(\"wf: Registered control %s\\n\", new_ct->name);\n\n\twf_notify(WF_EVENT_NEW_CONTROL, new_ct);\n\tmutex_unlock(&wf_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wf_register_control);\n\nvoid wf_unregister_control(struct wf_control *ct)\n{\n\tmutex_lock(&wf_lock);\n\tlist_del(&ct->link);\n\tmutex_unlock(&wf_lock);\n\n\tDBG(\"wf: Unregistered control %s\\n\", ct->name);\n\n\tkref_put(&ct->ref, wf_control_release);\n}\nEXPORT_SYMBOL_GPL(wf_unregister_control);\n\nint wf_get_control(struct wf_control *ct)\n{\n\tif (!try_module_get(ct->ops->owner))\n\t\treturn -ENODEV;\n\tkref_get(&ct->ref);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wf_get_control);\n\nvoid wf_put_control(struct wf_control *ct)\n{\n\tstruct module *mod = ct->ops->owner;\n\tkref_put(&ct->ref, wf_control_release);\n\tmodule_put(mod);\n}\nEXPORT_SYMBOL_GPL(wf_put_control);\n\n\n \n\n\nstatic void wf_sensor_release(struct kref *kref)\n{\n\tstruct wf_sensor *sr = container_of(kref, struct wf_sensor, ref);\n\n\tDBG(\"wf: Deleting sensor %s\\n\", sr->name);\n\n\tif (sr->ops && sr->ops->release)\n\t\tsr->ops->release(sr);\n\telse\n\t\tkfree(sr);\n}\n\nstatic ssize_t wf_show_sensor(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct wf_sensor *sens = container_of(attr, struct wf_sensor, attr);\n\ts32 val = 0;\n\tint err;\n\n\terr = sens->ops->get_value(sens, &val);\n\tif (err < 0)\n\t\treturn err;\n\treturn sprintf(buf, \"%d.%03d\\n\", FIX32TOPRINT(val));\n}\n\nint wf_register_sensor(struct wf_sensor *new_sr)\n{\n\tstruct wf_sensor *sr;\n\n\tmutex_lock(&wf_lock);\n\tlist_for_each_entry(sr, &wf_sensors, link) {\n\t\tif (!strcmp(sr->name, new_sr->name)) {\n\t\t\tprintk(KERN_WARNING \"windfarm: trying to register\"\n\t\t\t       \" duplicate sensor %s\\n\", sr->name);\n\t\t\tmutex_unlock(&wf_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tkref_init(&new_sr->ref);\n\tlist_add(&new_sr->link, &wf_sensors);\n\n\tsysfs_attr_init(&new_sr->attr.attr);\n\tnew_sr->attr.attr.name = new_sr->name;\n\tnew_sr->attr.attr.mode = 0444;\n\tnew_sr->attr.show = wf_show_sensor;\n\tnew_sr->attr.store = NULL;\n\tif (device_create_file(&wf_platform_device.dev, &new_sr->attr))\n\t\tprintk(KERN_WARNING \"windfarm: device_create_file failed\"\n\t\t\t\" for %s\\n\", new_sr->name);\n\t\t \n\n\tDBG(\"wf: Registered sensor %s\\n\", new_sr->name);\n\n\twf_notify(WF_EVENT_NEW_SENSOR, new_sr);\n\tmutex_unlock(&wf_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wf_register_sensor);\n\nvoid wf_unregister_sensor(struct wf_sensor *sr)\n{\n\tmutex_lock(&wf_lock);\n\tlist_del(&sr->link);\n\tmutex_unlock(&wf_lock);\n\n\tDBG(\"wf: Unregistered sensor %s\\n\", sr->name);\n\n\twf_put_sensor(sr);\n}\nEXPORT_SYMBOL_GPL(wf_unregister_sensor);\n\nint wf_get_sensor(struct wf_sensor *sr)\n{\n\tif (!try_module_get(sr->ops->owner))\n\t\treturn -ENODEV;\n\tkref_get(&sr->ref);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wf_get_sensor);\n\nvoid wf_put_sensor(struct wf_sensor *sr)\n{\n\tstruct module *mod = sr->ops->owner;\n\tkref_put(&sr->ref, wf_sensor_release);\n\tmodule_put(mod);\n}\nEXPORT_SYMBOL_GPL(wf_put_sensor);\n\n\n \n\nint wf_register_client(struct notifier_block *nb)\n{\n\tint rc;\n\tstruct wf_control *ct;\n\tstruct wf_sensor *sr;\n\n\tmutex_lock(&wf_lock);\n\trc = blocking_notifier_chain_register(&wf_client_list, nb);\n\tif (rc != 0)\n\t\tgoto bail;\n\twf_client_count++;\n\tlist_for_each_entry(ct, &wf_controls, link)\n\t\twf_notify(WF_EVENT_NEW_CONTROL, ct);\n\tlist_for_each_entry(sr, &wf_sensors, link)\n\t\twf_notify(WF_EVENT_NEW_SENSOR, sr);\n\tif (wf_client_count == 1)\n\t\twf_start_thread();\n bail:\n\tmutex_unlock(&wf_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(wf_register_client);\n\nint wf_unregister_client(struct notifier_block *nb)\n{\n\tmutex_lock(&wf_lock);\n\tblocking_notifier_chain_unregister(&wf_client_list, nb);\n\twf_client_count--;\n\tif (wf_client_count == 0)\n\t\twf_stop_thread();\n\tmutex_unlock(&wf_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wf_unregister_client);\n\nvoid wf_set_overtemp(void)\n{\n\tmutex_lock(&wf_lock);\n\twf_overtemp++;\n\tif (wf_overtemp == 1) {\n\t\tprintk(KERN_WARNING \"windfarm: Overtemp condition detected !\\n\");\n\t\twf_overtemp_counter = 0;\n\t\twf_notify(WF_EVENT_OVERTEMP, NULL);\n\t}\n\tmutex_unlock(&wf_lock);\n}\nEXPORT_SYMBOL_GPL(wf_set_overtemp);\n\nvoid wf_clear_overtemp(void)\n{\n\tmutex_lock(&wf_lock);\n\tWARN_ON(wf_overtemp == 0);\n\tif (wf_overtemp == 0) {\n\t\tmutex_unlock(&wf_lock);\n\t\treturn;\n\t}\n\twf_overtemp--;\n\tif (wf_overtemp == 0) {\n\t\tprintk(KERN_WARNING \"windfarm: Overtemp condition cleared !\\n\");\n\t\twf_notify(WF_EVENT_NORMALTEMP, NULL);\n\t}\n\tmutex_unlock(&wf_lock);\n}\nEXPORT_SYMBOL_GPL(wf_clear_overtemp);\n\nstatic int __init windfarm_core_init(void)\n{\n\tDBG(\"wf: core loaded\\n\");\n\n\tplatform_device_register(&wf_platform_device);\n\treturn 0;\n}\n\nstatic void __exit windfarm_core_exit(void)\n{\n\tBUG_ON(wf_client_count != 0);\n\n\tDBG(\"wf: core unloaded\\n\");\n\n\tplatform_device_unregister(&wf_platform_device);\n}\n\n\nmodule_init(windfarm_core_init);\nmodule_exit(windfarm_core_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Core component of PowerMac thermal control\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}