{
  "module_name": "windfarm_smu_controls.c",
  "hash_id": "60f74c9abce7932f30a131878435c7a16ed72b3c28922286235012934c1d41ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_smu_controls.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n\n#define VERSION \"0.4\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\nstatic int smu_supports_new_fans_ops = 1;\n\n \n\nstatic LIST_HEAD(smu_fans);\n\nstruct smu_fan_control {\n\tstruct list_head\tlink;\n\tint    \t\t\tfan_type;\t \n\tu32\t\t\treg;\t\t \n\ts32\t\t\tvalue;\t\t \n\ts32\t\t\tmin, max;\t \n\tstruct wf_control\tctrl;\n};\n#define to_smu_fan(c) container_of(c, struct smu_fan_control, ctrl)\n\nstatic int smu_set_fan(int pwm, u8 id, u16 value)\n{\n\tstruct smu_cmd cmd;\n\tu8 buffer[16];\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tint rc;\n\n\t \n\tcmd.cmd = SMU_CMD_FAN_COMMAND;\n\n\t \n retry:\n\tif (smu_supports_new_fans_ops) {\n\t\tbuffer[0] = 0x30;\n\t\tbuffer[1] = id;\n\t\t*((u16 *)(&buffer[2])) = value;\n\t\tcmd.data_len = 4;\n\t} else {\n\t\tif (id > 7)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tmemset(buffer, 0, 16);\n\t\tbuffer[0] = pwm ? 0x10 : 0x00;\n\t\tbuffer[1] = 0x01 << id;\n\t\t*((u16 *)&buffer[2 + id * 2]) = value;\n\t\tcmd.data_len = 14;\n\t}\n\n\tcmd.reply_len = 16;\n\tcmd.data_buf = cmd.reply_buf = buffer;\n\tcmd.status = 0;\n\tcmd.done = smu_done_complete;\n\tcmd.misc = &comp;\n\n\trc = smu_queue_cmd(&cmd);\n\tif (rc)\n\t\treturn rc;\n\twait_for_completion(&comp);\n\n\t \n\tif (cmd.status != 0 && smu_supports_new_fans_ops) {\n\t\tprintk(KERN_WARNING \"windfarm: SMU failed new fan command \"\n\t\t       \"falling back to old method\\n\");\n\t\tsmu_supports_new_fans_ops = 0;\n\t\tgoto retry;\n\t}\n\n\treturn cmd.status;\n}\n\nstatic void smu_fan_release(struct wf_control *ct)\n{\n\tstruct smu_fan_control *fct = to_smu_fan(ct);\n\n\tkfree(fct);\n}\n\nstatic int smu_fan_set(struct wf_control *ct, s32 value)\n{\n\tstruct smu_fan_control *fct = to_smu_fan(ct);\n\n\tif (value < fct->min)\n\t\tvalue = fct->min;\n\tif (value > fct->max)\n\t\tvalue = fct->max;\n\tfct->value = value;\n\n\treturn smu_set_fan(fct->fan_type, fct->reg, value);\n}\n\nstatic int smu_fan_get(struct wf_control *ct, s32 *value)\n{\n\tstruct smu_fan_control *fct = to_smu_fan(ct);\n\t*value = fct->value;  \n\treturn 0;\n}\n\nstatic s32 smu_fan_min(struct wf_control *ct)\n{\n\tstruct smu_fan_control *fct = to_smu_fan(ct);\n\treturn fct->min;\n}\n\nstatic s32 smu_fan_max(struct wf_control *ct)\n{\n\tstruct smu_fan_control *fct = to_smu_fan(ct);\n\treturn fct->max;\n}\n\nstatic const struct wf_control_ops smu_fan_ops = {\n\t.set_value\t= smu_fan_set,\n\t.get_value\t= smu_fan_get,\n\t.get_min\t= smu_fan_min,\n\t.get_max\t= smu_fan_max,\n\t.release\t= smu_fan_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct smu_fan_control *smu_fan_create(struct device_node *node,\n\t\t\t\t\t      int pwm_fan)\n{\n\tstruct smu_fan_control *fct;\n\tconst s32 *v;\n\tconst u32 *reg;\n\tconst char *l;\n\n\tfct = kmalloc(sizeof(struct smu_fan_control), GFP_KERNEL);\n\tif (fct == NULL)\n\t\treturn NULL;\n\tfct->ctrl.ops = &smu_fan_ops;\n\tl = of_get_property(node, \"location\", NULL);\n\tif (l == NULL)\n\t\tgoto fail;\n\n\tfct->fan_type = pwm_fan;\n\tfct->ctrl.type = pwm_fan ? WF_CONTROL_PWM_FAN : WF_CONTROL_RPM_FAN;\n\n\t \n\n\tfct->ctrl.name = NULL;\n\n\t \n\tif (!strcmp(l, \"Rear Fan 0\") || !strcmp(l, \"Rear Fan\") ||\n\t    !strcmp(l, \"Rear fan 0\") || !strcmp(l, \"Rear fan\") ||\n\t    !strcmp(l, \"CPU A EXHAUST\"))\n\t\tfct->ctrl.name = \"cpu-rear-fan-0\";\n\telse if (!strcmp(l, \"Rear Fan 1\") || !strcmp(l, \"Rear fan 1\") ||\n\t\t !strcmp(l, \"CPU B EXHAUST\"))\n\t\tfct->ctrl.name = \"cpu-rear-fan-1\";\n\telse if (!strcmp(l, \"Front Fan 0\") || !strcmp(l, \"Front Fan\") ||\n\t\t !strcmp(l, \"Front fan 0\") || !strcmp(l, \"Front fan\") ||\n\t\t !strcmp(l, \"CPU A INTAKE\"))\n\t\tfct->ctrl.name = \"cpu-front-fan-0\";\n\telse if (!strcmp(l, \"Front Fan 1\") || !strcmp(l, \"Front fan 1\") ||\n\t\t !strcmp(l, \"CPU B INTAKE\"))\n\t\tfct->ctrl.name = \"cpu-front-fan-1\";\n\telse if (!strcmp(l, \"CPU A PUMP\"))\n\t\tfct->ctrl.name = \"cpu-pump-0\";\n\telse if (!strcmp(l, \"CPU B PUMP\"))\n\t\tfct->ctrl.name = \"cpu-pump-1\";\n\telse if (!strcmp(l, \"Slots Fan\") || !strcmp(l, \"Slots fan\") ||\n\t\t !strcmp(l, \"EXPANSION SLOTS INTAKE\"))\n\t\tfct->ctrl.name = \"slots-fan\";\n\telse if (!strcmp(l, \"Drive Bay\") || !strcmp(l, \"Drive bay\") ||\n\t\t !strcmp(l, \"DRIVE BAY A INTAKE\"))\n\t\tfct->ctrl.name = \"drive-bay-fan\";\n\telse if (!strcmp(l, \"BACKSIDE\"))\n\t\tfct->ctrl.name = \"backside-fan\";\n\n\t \n\tif (!strcmp(l, \"System Fan\") || !strcmp(l, \"System fan\"))\n\t\tfct->ctrl.name = \"system-fan\";\n\telse if (!strcmp(l, \"CPU Fan\") || !strcmp(l, \"CPU fan\"))\n\t\tfct->ctrl.name = \"cpu-fan\";\n\telse if (!strcmp(l, \"Hard Drive\") || !strcmp(l, \"Hard drive\"))\n\t\tfct->ctrl.name = \"drive-bay-fan\";\n\telse if (!strcmp(l, \"HDD Fan\"))  \n\t\tfct->ctrl.name = \"hard-drive-fan\";\n\telse if (!strcmp(l, \"ODD Fan\"))  \n\t\tfct->ctrl.name = \"optical-drive-fan\";\n\n\t \n\tif (fct->ctrl.name == NULL)\n\t\tgoto fail;\n\n\t \n\tv = of_get_property(node, \"min-value\", NULL);\n\tif (v == NULL)\n\t\tgoto fail;\n\tfct->min = *v;\n\tv = of_get_property(node, \"max-value\", NULL);\n\tif (v == NULL)\n\t\tgoto fail;\n\tfct->max = *v;\n\n\t \n\treg = of_get_property(node, \"reg\", NULL);\n\tif (reg == NULL)\n\t\tgoto fail;\n\tfct->reg = *reg;\n\n\tif (wf_register_control(&fct->ctrl))\n\t\tgoto fail;\n\n\treturn fct;\n fail:\n\tkfree(fct);\n\treturn NULL;\n}\n\n\nstatic int __init smu_controls_init(void)\n{\n\tstruct device_node *smu, *fans, *fan;\n\n\tif (!smu_present())\n\t\treturn -ENODEV;\n\n\tsmu = of_find_node_by_type(NULL, \"smu\");\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_child_of_node(smu, fans)\n\t\tif (of_node_name_eq(fans, \"rpm-fans\") ||\n\t\t    of_device_is_compatible(fans, \"smu-rpm-fans\"))\n\t\t\tbreak;\n\tfor_each_child_of_node(fans, fan) {\n\t\tstruct smu_fan_control *fct;\n\n\t\tfct = smu_fan_create(fan, 0);\n\t\tif (fct == NULL) {\n\t\t\tprintk(KERN_WARNING \"windfarm: Failed to create SMU \"\n\t\t\t       \"RPM fan %pOFn\\n\", fan);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&fct->link, &smu_fans);\n\t}\n\tof_node_put(fans);\n\n\n\t \n\tfor_each_child_of_node(smu, fans)\n\t\tif (of_node_name_eq(fans, \"pwm-fans\"))\n\t\t\tbreak;\n\tfor_each_child_of_node(fans, fan) {\n\t\tstruct smu_fan_control *fct;\n\n\t\tfct = smu_fan_create(fan, 1);\n\t\tif (fct == NULL) {\n\t\t\tprintk(KERN_WARNING \"windfarm: Failed to create SMU \"\n\t\t\t       \"PWM fan %pOFn\\n\", fan);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&fct->link, &smu_fans);\n\t}\n\tof_node_put(fans);\n\tof_node_put(smu);\n\n\treturn 0;\n}\n\nstatic void __exit smu_controls_exit(void)\n{\n\tstruct smu_fan_control *fct;\n\n\twhile (!list_empty(&smu_fans)) {\n\t\tfct = list_entry(smu_fans.next, struct smu_fan_control, link);\n\t\tlist_del(&fct->link);\n\t\twf_unregister_control(&fct->ctrl);\n\t}\n}\n\n\nmodule_init(smu_controls_init);\nmodule_exit(smu_controls_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"SMU control objects for PowerMacs thermal control\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}