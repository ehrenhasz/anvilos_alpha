{
  "module_name": "via-cuda.c",
  "hash_id": "ebd08f5f12ed47fd341e32d1b96f287d85faf55cda2733cab934d5b4bc5e78eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/via-cuda.c",
  "human_readable_source": "\n \n#include <linux/stdarg.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/adb.h>\n#include <linux/cuda.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#ifdef CONFIG_PPC\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#else\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/mac_via.h>\n#endif\n#include <asm/io.h>\n#include <linux/init.h>\n\nstatic volatile unsigned char __iomem *via;\nstatic DEFINE_SPINLOCK(cuda_lock);\n\n \n#define RS\t\t0x200\t\t \n#define B\t\t0\t\t \n#define A\t\tRS\t\t \n#define DIRB\t\t(2*RS)\t\t \n#define DIRA\t\t(3*RS)\t\t \n#define T1CL\t\t(4*RS)\t\t \n#define T1CH\t\t(5*RS)\t\t \n#define T1LL\t\t(6*RS)\t\t \n#define T1LH\t\t(7*RS)\t\t \n#define T2CL\t\t(8*RS)\t\t \n#define T2CH\t\t(9*RS)\t\t \n#define SR\t\t(10*RS)\t\t \n#define ACR\t\t(11*RS)\t\t \n#define PCR\t\t(12*RS)\t\t \n#define IFR\t\t(13*RS)\t\t \n#define IER\t\t(14*RS)\t\t \n#define ANH\t\t(15*RS)\t\t \n\n \n\n \n#define TREQ\t\t0x08\t\t \n#define TACK\t\t0x10\t\t \n#define TIP\t\t0x20\t\t \n\n \n#define SR_CTRL\t\t0x1c\t\t \n#define SR_EXT\t\t0x0c\t\t \n#define SR_OUT\t\t0x10\t\t \n\n \n#define IER_SET\t\t0x80\t\t \n#define IER_CLR\t\t0\t\t \n#define SR_INT\t\t0x04\t\t \n\n \n#define EGRET_TACK_ASSERTED_DELAY\t300\n#define EGRET_TACK_NEGATED_DELAY\t400\n\n \n#define EGRET_SESSION_DELAY\t\t450\n\n#ifdef CONFIG_PPC\n#define mcu_is_egret\tfalse\n#else\nstatic bool mcu_is_egret;\n#endif\n\nstatic inline bool TREQ_asserted(u8 portb)\n{\n\treturn !(portb & TREQ);\n}\n\nstatic inline void assert_TIP(void)\n{\n\tif (mcu_is_egret) {\n\t\tudelay(EGRET_SESSION_DELAY);\n\t\tout_8(&via[B], in_8(&via[B]) | TIP);\n\t} else\n\t\tout_8(&via[B], in_8(&via[B]) & ~TIP);\n}\n\nstatic inline void assert_TIP_and_TACK(void)\n{\n\tif (mcu_is_egret) {\n\t\tudelay(EGRET_SESSION_DELAY);\n\t\tout_8(&via[B], in_8(&via[B]) | TIP | TACK);\n\t} else\n\t\tout_8(&via[B], in_8(&via[B]) & ~(TIP | TACK));\n}\n\nstatic inline void assert_TACK(void)\n{\n\tif (mcu_is_egret) {\n\t\tudelay(EGRET_TACK_NEGATED_DELAY);\n\t\tout_8(&via[B], in_8(&via[B]) | TACK);\n\t} else\n\t\tout_8(&via[B], in_8(&via[B]) & ~TACK);\n}\n\nstatic inline void toggle_TACK(void)\n{\n\tout_8(&via[B], in_8(&via[B]) ^ TACK);\n}\n\nstatic inline void negate_TACK(void)\n{\n\tif (mcu_is_egret) {\n\t\tudelay(EGRET_TACK_ASSERTED_DELAY);\n\t\tout_8(&via[B], in_8(&via[B]) & ~TACK);\n\t} else\n\t\tout_8(&via[B], in_8(&via[B]) | TACK);\n}\n\nstatic inline void negate_TIP_and_TACK(void)\n{\n\tif (mcu_is_egret) {\n\t\tudelay(EGRET_TACK_ASSERTED_DELAY);\n\t\tout_8(&via[B], in_8(&via[B]) & ~(TIP | TACK));\n\t} else\n\t\tout_8(&via[B], in_8(&via[B]) | TIP | TACK);\n}\n\nstatic enum cuda_state {\n    idle,\n    sent_first_byte,\n    sending,\n    reading,\n    read_done,\n    awaiting_reply\n} cuda_state;\n\nstatic struct adb_request *current_req;\nstatic struct adb_request *last_req;\nstatic unsigned char cuda_rbuf[16];\nstatic unsigned char *reply_ptr;\nstatic int reading_reply;\nstatic int data_index;\nstatic int cuda_irq;\n#ifdef CONFIG_PPC\nstatic struct device_node *vias;\n#endif\nstatic int cuda_fully_inited;\n\n#ifdef CONFIG_ADB\nstatic int cuda_probe(void);\nstatic int cuda_send_request(struct adb_request *req, int sync);\nstatic int cuda_adb_autopoll(int devs);\nstatic int cuda_reset_adb_bus(void);\n#endif  \n\nstatic int cuda_init_via(void);\nstatic void cuda_start(void);\nstatic irqreturn_t cuda_interrupt(int irq, void *arg);\nstatic void cuda_input(unsigned char *buf, int nb);\nvoid cuda_poll(void);\nstatic int cuda_write(struct adb_request *req);\n\nint cuda_request(struct adb_request *req,\n\t\t void (*done)(struct adb_request *), int nbytes, ...);\n\n#ifdef CONFIG_ADB\nstruct adb_driver via_cuda_driver = {\n\t.name         = \"CUDA\",\n\t.probe        = cuda_probe,\n\t.send_request = cuda_send_request,\n\t.autopoll     = cuda_adb_autopoll,\n\t.poll         = cuda_poll,\n\t.reset_bus    = cuda_reset_adb_bus,\n};\n#endif  \n\n#ifdef CONFIG_MAC\nint __init find_via_cuda(void)\n{\n    struct adb_request req;\n    int err;\n\n    if (macintosh_config->adb_type != MAC_ADB_CUDA &&\n        macintosh_config->adb_type != MAC_ADB_EGRET)\n\treturn 0;\n\n    via = via1;\n    cuda_state = idle;\n    mcu_is_egret = macintosh_config->adb_type == MAC_ADB_EGRET;\n\n    err = cuda_init_via();\n    if (err) {\n\tprintk(KERN_ERR \"cuda_init_via() failed\\n\");\n\tvia = NULL;\n\treturn 0;\n    }\n\n     \n    cuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, 1);\n    while (!req.complete)\n\tcuda_poll();\n\n    return 1;\n}\n#else\nint __init find_via_cuda(void)\n{\n    struct adb_request req;\n    struct resource res;\n    int err;\n\n    if (vias)\n\treturn 1;\n    vias = of_find_node_by_name(NULL, \"via-cuda\");\n    if (!vias)\n\treturn 0;\n\n    err = of_address_to_resource(vias, 0, &res);\n    if (err) {\n\t    printk(KERN_ERR \"via-cuda: Error getting \\\"reg\\\" property !\\n\");\n\t    goto fail;\n    }\n    via = ioremap(res.start, 0x2000);\n    if (via == NULL) {\n\t    printk(KERN_ERR \"via-cuda: Can't map address !\\n\");\n\t    goto fail;\n    }\n\n    cuda_state = idle;\n    sys_ctrler = SYS_CTRLER_CUDA;\n\n    err = cuda_init_via();\n    if (err) {\n\tprintk(KERN_ERR \"cuda_init_via() failed\\n\");\n\tvia = NULL;\n\treturn 0;\n    }\n\n     \n     \n\n    out_8(&via[IFR], 0x7f);\t \n    out_8(&via[IER], IER_SET|SR_INT);  \n\n     \n    cuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, 1);\n    while (!req.complete)\n\tcuda_poll();\n\n    return 1;\n\n fail:\n    of_node_put(vias);\n    vias = NULL;\n    return 0;\n}\n#endif  \n\nstatic int __init via_cuda_start(void)\n{\n    if (via == NULL)\n\treturn -ENODEV;\n\n#ifdef CONFIG_MAC\n    cuda_irq = IRQ_MAC_ADB;\n#else\n    cuda_irq = irq_of_parse_and_map(vias, 0);\n    if (!cuda_irq) {\n\tprintk(KERN_ERR \"via-cuda: can't map interrupts for %pOF\\n\",\n\t       vias);\n\treturn -ENODEV;\n    }\n#endif\n\n    if (request_irq(cuda_irq, cuda_interrupt, 0, \"ADB\", cuda_interrupt)) {\n\tprintk(KERN_ERR \"via-cuda: can't request irq %d\\n\", cuda_irq);\n\treturn -EAGAIN;\n    }\n\n    pr_info(\"Macintosh Cuda and Egret driver.\\n\");\n\n    cuda_fully_inited = 1;\n    return 0;\n}\n\ndevice_initcall(via_cuda_start);\n\n#ifdef CONFIG_ADB\nstatic int\ncuda_probe(void)\n{\n#ifdef CONFIG_PPC\n    if (sys_ctrler != SYS_CTRLER_CUDA)\n\treturn -ENODEV;\n#else\n    if (macintosh_config->adb_type != MAC_ADB_CUDA &&\n        macintosh_config->adb_type != MAC_ADB_EGRET)\n\treturn -ENODEV;\n#endif\n    if (via == NULL)\n\treturn -ENODEV;\n    return 0;\n}\n#endif  \n\nstatic int __init sync_egret(void)\n{\n\tif (TREQ_asserted(in_8(&via[B]))) {\n\t\t \n\t\tassert_TIP_and_TACK();\n\t\twhile (1) {\n\t\t\tnegate_TACK();\n\t\t\tmdelay(1);\n\t\t\t(void)in_8(&via[SR]);\n\t\t\tassert_TACK();\n\t\t\tif (!TREQ_asserted(in_8(&via[B])))\n\t\t\t\tbreak;\n\t\t}\n\t\tnegate_TIP_and_TACK();\n\t} else if (in_8(&via[B]) & TIP) {\n\t\t \n\t\tnegate_TACK();\n\t\tassert_TACK();\n\t\tmdelay(1);\n\t\tnegate_TIP_and_TACK();\n\t}\n\t \n\tif (in_8(&via[IFR]) & SR_INT)\n\t\t(void)in_8(&via[SR]);\n\treturn 0;\n}\n\n#define WAIT_FOR(cond, what)\t\t\t\t\t\\\n    do {                                                        \\\n    \tint x;\t\t\t\t\t\t\t\\\n\tfor (x = 1000; !(cond); --x) {\t\t\t\t\\\n\t    if (x == 0) {\t\t\t\t\t\\\n\t\tpr_err(\"Timeout waiting for \" what \"\\n\");\t\\\n\t\treturn -ENXIO;\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\\\n\t    udelay(100);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n    } while (0)\n\nstatic int\n__init cuda_init_via(void)\n{\n#ifdef CONFIG_PPC\n    out_8(&via[IER], 0x7f);\t\t\t\t\t \n    (void)in_8(&via[IER]);\n#else\n    out_8(&via[IER], SR_INT);\t\t\t\t\t \n#endif\n\n    out_8(&via[DIRB], (in_8(&via[DIRB]) | TACK | TIP) & ~TREQ);\t \n    out_8(&via[ACR], (in_8(&via[ACR]) & ~SR_CTRL) | SR_EXT);\t \n    (void)in_8(&via[SR]);\t\t\t\t\t \n\n    if (mcu_is_egret)\n\treturn sync_egret();\n\n    negate_TIP_and_TACK();\n\n     \n    mdelay(4);\n    (void)in_8(&via[SR]);\n    out_8(&via[IFR], SR_INT);\n\n     \n    assert_TACK();\n\n     \n    WAIT_FOR(TREQ_asserted(in_8(&via[B])), \"CUDA response to sync\");\n\n     \n    WAIT_FOR(in_8(&via[IFR]) & SR_INT, \"CUDA response to sync (2)\");\n    (void)in_8(&via[SR]);\n    out_8(&via[IFR], SR_INT);\n\n     \n    negate_TACK();\n\n     \n    WAIT_FOR(!TREQ_asserted(in_8(&via[B])), \"CUDA response to sync (3)\");\n    WAIT_FOR(in_8(&via[IFR]) & SR_INT, \"CUDA response to sync (4)\");\n    (void)in_8(&via[SR]);\n    out_8(&via[IFR], SR_INT);\n\n    return 0;\n}\n\n#ifdef CONFIG_ADB\n \nstatic int\ncuda_send_request(struct adb_request *req, int sync)\n{\n    int i;\n\n    if ((via == NULL) || !cuda_fully_inited) {\n\treq->complete = 1;\n\treturn -ENXIO;\n    }\n  \n    req->reply_expected = 1;\n\n    i = cuda_write(req);\n    if (i)\n\treturn i;\n\n    if (sync) {\n\twhile (!req->complete)\n\t    cuda_poll();\n    }\n    return 0;\n}\n\n\n \nstatic int\ncuda_adb_autopoll(int devs)\n{\n    struct adb_request req;\n\n    if ((via == NULL) || !cuda_fully_inited)\n\treturn -ENXIO;\n\n    cuda_request(&req, NULL, 3, CUDA_PACKET, CUDA_AUTOPOLL, (devs? 1: 0));\n    while (!req.complete)\n\tcuda_poll();\n    return 0;\n}\n\n \nstatic int\ncuda_reset_adb_bus(void)\n{\n    struct adb_request req;\n\n    if ((via == NULL) || !cuda_fully_inited)\n\treturn -ENXIO;\n\n    cuda_request(&req, NULL, 2, ADB_PACKET, 0);\t\t \n    while (!req.complete)\n\tcuda_poll();\n    return 0;\n}\n#endif  \n\n \nint\ncuda_request(struct adb_request *req, void (*done)(struct adb_request *),\n\t     int nbytes, ...)\n{\n    va_list list;\n    int i;\n\n    if (via == NULL) {\n\treq->complete = 1;\n\treturn -ENXIO;\n    }\n\n    req->nbytes = nbytes;\n    req->done = done;\n    va_start(list, nbytes);\n    for (i = 0; i < nbytes; ++i)\n\treq->data[i] = va_arg(list, int);\n    va_end(list);\n    req->reply_expected = 1;\n    return cuda_write(req);\n}\nEXPORT_SYMBOL(cuda_request);\n\nstatic int\ncuda_write(struct adb_request *req)\n{\n    unsigned long flags;\n\n    if (req->nbytes < 2 || req->data[0] > CUDA_PACKET) {\n\treq->complete = 1;\n\treturn -EINVAL;\n    }\n    req->next = NULL;\n    req->sent = 0;\n    req->complete = 0;\n    req->reply_len = 0;\n\n    spin_lock_irqsave(&cuda_lock, flags);\n    if (current_req) {\n\tlast_req->next = req;\n\tlast_req = req;\n    } else {\n\tcurrent_req = req;\n\tlast_req = req;\n\tif (cuda_state == idle)\n\t    cuda_start();\n    }\n    spin_unlock_irqrestore(&cuda_lock, flags);\n\n    return 0;\n}\n\nstatic void\ncuda_start(void)\n{\n     \n    if (current_req == NULL)\n\treturn;\n    data_index = 0;\n    if (TREQ_asserted(in_8(&via[B])))\n\treturn;\t\t\t \n\n     \n    out_8(&via[ACR], in_8(&via[ACR]) | SR_OUT);\n    out_8(&via[SR], current_req->data[data_index++]);\n    if (mcu_is_egret)\n\tassert_TIP_and_TACK();\n    else\n\tassert_TIP();\n    cuda_state = sent_first_byte;\n}\n\nvoid\ncuda_poll(void)\n{\n\tcuda_interrupt(0, NULL);\n}\nEXPORT_SYMBOL(cuda_poll);\n\n#define ARRAY_FULL(a, p)\t((p) - (a) == ARRAY_SIZE(a))\n\nstatic irqreturn_t\ncuda_interrupt(int irq, void *arg)\n{\n    unsigned long flags;\n    u8 status;\n    struct adb_request *req = NULL;\n    unsigned char ibuf[16];\n    int ibuf_len = 0;\n    int complete = 0;\n    bool full;\n    \n    spin_lock_irqsave(&cuda_lock, flags);\n\n     \n\n#ifdef CONFIG_MAC\n    if (!arg)\n#endif\n    {\n        if ((in_8(&via[IFR]) & SR_INT) == 0) {\n            spin_unlock_irqrestore(&cuda_lock, flags);\n            return IRQ_NONE;\n        } else {\n            out_8(&via[IFR], SR_INT);\n        }\n    }\n\n    status = in_8(&via[B]) & (TIP | TACK | TREQ);\n\n    switch (cuda_state) {\n    case idle:\n\t \n\t(void)in_8(&via[SR]);\nidle_state:\n\tassert_TIP();\n\tcuda_state = reading;\n\treply_ptr = cuda_rbuf;\n\treading_reply = 0;\n\tbreak;\n\n    case awaiting_reply:\n\t \n\t(void)in_8(&via[SR]);\n\tassert_TIP();\n\tcuda_state = reading;\n\treply_ptr = current_req->reply;\n\treading_reply = 1;\n\tbreak;\n\n    case sent_first_byte:\n\tif (TREQ_asserted(status)) {\n\t     \n\t    out_8(&via[ACR], in_8(&via[ACR]) & ~SR_OUT);\n\t    (void)in_8(&via[SR]);\n\t    negate_TIP_and_TACK();\n\t    cuda_state = idle;\n\t     \n\t    if (mcu_is_egret)\n\t\tgoto idle_state;\n\t} else {\n\t    out_8(&via[SR], current_req->data[data_index++]);\n\t    toggle_TACK();\n\t    if (mcu_is_egret)\n\t\tassert_TACK();\n\t    cuda_state = sending;\n\t}\n\tbreak;\n\n    case sending:\n\treq = current_req;\n\tif (data_index >= req->nbytes) {\n\t    out_8(&via[ACR], in_8(&via[ACR]) & ~SR_OUT);\n\t    (void)in_8(&via[SR]);\n\t    negate_TIP_and_TACK();\n\t    req->sent = 1;\n\t    if (req->reply_expected) {\n\t\tcuda_state = awaiting_reply;\n\t    } else {\n\t\tcurrent_req = req->next;\n\t\tcomplete = 1;\n\t\t \n\t\tcuda_state = idle;\n\t\tcuda_start();\n\t    }\n\t} else {\n\t    out_8(&via[SR], req->data[data_index++]);\n\t    toggle_TACK();\n\t    if (mcu_is_egret)\n\t\tassert_TACK();\n\t}\n\tbreak;\n\n    case reading:\n\tfull = reading_reply ? ARRAY_FULL(current_req->reply, reply_ptr)\n\t                     : ARRAY_FULL(cuda_rbuf, reply_ptr);\n\tif (full)\n\t    (void)in_8(&via[SR]);\n\telse\n\t    *reply_ptr++ = in_8(&via[SR]);\n\tif (!TREQ_asserted(status) || full) {\n\t    if (mcu_is_egret)\n\t\tassert_TACK();\n\t     \n\t    negate_TIP_and_TACK();\n\t    cuda_state = read_done;\n\t     \n\t    if (mcu_is_egret)\n\t\tgoto read_done_state;\n\t} else {\n\t    toggle_TACK();\n\t    if (mcu_is_egret)\n\t\tnegate_TACK();\n\t}\n\tbreak;\n\n    case read_done:\n\t(void)in_8(&via[SR]);\nread_done_state:\n\tif (reading_reply) {\n\t    req = current_req;\n\t    req->reply_len = reply_ptr - req->reply;\n\t    if (req->data[0] == ADB_PACKET) {\n\t\t \n\t\tif (req->reply_len <= 2 || (req->reply[1] & 2) != 0) {\n\t\t     \n\t\t    req->reply_len = 0;\n\t\t} else {\n\t\t     \n\t\t    req->reply_len -= 2;\n\t\t    memmove(req->reply, req->reply + 2, req->reply_len);\n\t\t}\n\t    }\n\t    current_req = req->next;\n\t    complete = 1;\n\t    reading_reply = 0;\n\t} else {\n\t     \n\t    ibuf_len = reply_ptr - cuda_rbuf;\n\t    memcpy(ibuf, cuda_rbuf, ibuf_len);\n\t}\n\treply_ptr = cuda_rbuf;\n\tcuda_state = idle;\n\tcuda_start();\n\tif (cuda_state == idle && TREQ_asserted(in_8(&via[B]))) {\n\t    assert_TIP();\n\t    cuda_state = reading;\n\t}\n\tbreak;\n\n    default:\n\tpr_err(\"cuda_interrupt: unknown cuda_state %d?\\n\", cuda_state);\n    }\n    spin_unlock_irqrestore(&cuda_lock, flags);\n    if (complete && req) {\n    \tvoid (*done)(struct adb_request *) = req->done;\n    \tmb();\n    \treq->complete = 1;\n    \t \n    \tif (done)\n\t\t(*done)(req);\n    }\n    if (ibuf_len)\n\tcuda_input(ibuf, ibuf_len);\n    return IRQ_HANDLED;\n}\n\nstatic void\ncuda_input(unsigned char *buf, int nb)\n{\n    switch (buf[0]) {\n    case ADB_PACKET:\n#ifdef CONFIG_XMON\n\tif (nb == 5 && buf[2] == 0x2c) {\n\t    extern int xmon_wants_key, xmon_adb_keycode;\n\t    if (xmon_wants_key) {\n\t\txmon_adb_keycode = buf[3];\n\t\treturn;\n\t    }\n\t}\n#endif  \n#ifdef CONFIG_ADB\n\tadb_input(buf+2, nb-2, buf[1] & 0x40);\n#endif  \n\tbreak;\n\n    case TIMER_PACKET:\n\t \n\tbreak;\n\n    default:\n\tprint_hex_dump(KERN_INFO, \"cuda_input: \", DUMP_PREFIX_NONE, 32, 1,\n\t               buf, nb, false);\n    }\n}\n\n \n#define RTC_OFFSET\t2082844800\n\ntime64_t cuda_get_time(void)\n{\n\tstruct adb_request req;\n\tu32 now;\n\n\tif (cuda_request(&req, NULL, 2, CUDA_PACKET, CUDA_GET_TIME) < 0)\n\t\treturn 0;\n\twhile (!req.complete)\n\t\tcuda_poll();\n\tif (req.reply_len != 7)\n\t\tpr_err(\"%s: got %d byte reply\\n\", __func__, req.reply_len);\n\tnow = (req.reply[3] << 24) + (req.reply[4] << 16) +\n\t      (req.reply[5] << 8) + req.reply[6];\n\treturn (time64_t)now - RTC_OFFSET;\n}\n\nint cuda_set_rtc_time(struct rtc_time *tm)\n{\n\tu32 now;\n\tstruct adb_request req;\n\n\tnow = lower_32_bits(rtc_tm_to_time64(tm) + RTC_OFFSET);\n\tif (cuda_request(&req, NULL, 6, CUDA_PACKET, CUDA_SET_TIME,\n\t                 now >> 24, now >> 16, now >> 8, now) < 0)\n\t\treturn -ENXIO;\n\twhile (!req.complete)\n\t\tcuda_poll();\n\tif ((req.reply_len != 3) && (req.reply_len != 7))\n\t\tpr_err(\"%s: got %d byte reply\\n\", __func__, req.reply_len);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}