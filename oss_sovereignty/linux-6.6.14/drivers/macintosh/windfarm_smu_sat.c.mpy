{
  "module_name": "windfarm_smu_sat.c",
  "hash_id": "90fa62945c69aac4af255770d128cf7ded1f0352fae638f22cbb97aca54e4e27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_smu_sat.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <asm/smu.h>\n#include <asm/pmac_low_i2c.h>\n\n#include \"windfarm.h\"\n\n#define VERSION \"1.0\"\n\n \n#define MAX_AGE\t\tmsecs_to_jiffies(800)\n\nstruct wf_sat {\n\tstruct kref\t\tref;\n\tint\t\t\tnr;\n\tstruct mutex\t\tmutex;\n\tunsigned long\t\tlast_read;  \n\tu8\t\t\tcache[16];\n\tstruct list_head\tsensors;\n\tstruct i2c_client\t*i2c;\n\tstruct device_node\t*node;\n};\n\nstatic struct wf_sat *sats[2];\n\nstruct wf_sat_sensor {\n\tstruct list_head\tlink;\n\tint\t\t\tindex;\n\tint\t\t\tindex2;\t\t \n\tint\t\t\tshift;\n\tstruct wf_sat\t\t*sat;\n\tstruct wf_sensor \tsens;\n};\n\n#define wf_to_sat(c)\tcontainer_of(c, struct wf_sat_sensor, sens)\n\nstruct smu_sdbp_header *smu_sat_get_sdb_partition(unsigned int sat_id, int id,\n\t\t\t\t\t\t  unsigned int *size)\n{\n\tstruct wf_sat *sat;\n\tint err;\n\tunsigned int i, len;\n\tu8 *buf;\n\tu8 data[4];\n\n\t \n\n\tif (sat_id > 1 || (sat = sats[sat_id]) == NULL)\n\t\treturn NULL;\n\n\terr = i2c_smbus_write_word_data(sat->i2c, 8, id << 8);\n\tif (err) {\n\t\tprintk(KERN_ERR \"smu_sat_get_sdb_part wr error %d\\n\", err);\n\t\treturn NULL;\n\t}\n\n\terr = i2c_smbus_read_word_data(sat->i2c, 9);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"smu_sat_get_sdb_part rd len error\\n\");\n\t\treturn NULL;\n\t}\n\tlen = err;\n\tif (len == 0) {\n\t\tprintk(KERN_ERR \"smu_sat_get_sdb_part no partition %x\\n\", id);\n\t\treturn NULL;\n\t}\n\n\tlen = le16_to_cpu(len);\n\tlen = (len + 3) & ~3;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i += 4) {\n\t\terr = i2c_smbus_read_i2c_block_data(sat->i2c, 0xa, 4, data);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"smu_sat_get_sdb_part rd err %d\\n\",\n\t\t\t       err);\n\t\t\tgoto fail;\n\t\t}\n\t\tbuf[i] = data[1];\n\t\tbuf[i+1] = data[0];\n\t\tbuf[i+2] = data[3];\n\t\tbuf[i+3] = data[2];\n\t}\n\n\tprintk(KERN_DEBUG \"sat %d partition %x:\", sat_id, id);\n\tprint_hex_dump(KERN_DEBUG, \"  \", DUMP_PREFIX_OFFSET,\n\t\t       16, 1, buf, len, false);\n\tif (size)\n\t\t*size = len;\n\treturn (struct smu_sdbp_header *) buf;\n\n fail:\n\tkfree(buf);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(smu_sat_get_sdb_partition);\n\n \nstatic int wf_sat_read_cache(struct wf_sat *sat)\n{\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(sat->i2c, 0x3f, 16, sat->cache);\n\tif (err < 0)\n\t\treturn err;\n\tsat->last_read = jiffies;\n\n#ifdef LOTSA_DEBUG\n\t{\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"wf_sat_get: data is\");\n\t\tprint_hex_dump(KERN_DEBUG, \"  \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, sat->cache, 16, false);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int wf_sat_sensor_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct wf_sat_sensor *sens = wf_to_sat(sr);\n\tstruct wf_sat *sat = sens->sat;\n\tint i, err;\n\ts32 val;\n\n\tif (sat->i2c == NULL)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sat->mutex);\n\tif (time_after(jiffies, (sat->last_read + MAX_AGE))) {\n\t\terr = wf_sat_read_cache(sat);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\ti = sens->index * 2;\n\tval = ((sat->cache[i] << 8) + sat->cache[i+1]) << sens->shift;\n\tif (sens->index2 >= 0) {\n\t\ti = sens->index2 * 2;\n\t\t \n\t\tval = (val * ((sat->cache[i] << 8) + sat->cache[i+1])) >> 4;\n\t}\n\n\t*value = val;\n\terr = 0;\n\n fail:\n\tmutex_unlock(&sat->mutex);\n\treturn err;\n}\n\nstatic void wf_sat_release(struct kref *ref)\n{\n\tstruct wf_sat *sat = container_of(ref, struct wf_sat, ref);\n\n\tif (sat->nr >= 0)\n\t\tsats[sat->nr] = NULL;\n\tof_node_put(sat->node);\n\tkfree(sat);\n}\n\nstatic void wf_sat_sensor_release(struct wf_sensor *sr)\n{\n\tstruct wf_sat_sensor *sens = wf_to_sat(sr);\n\tstruct wf_sat *sat = sens->sat;\n\n\tkfree(sens);\n\tkref_put(&sat->ref, wf_sat_release);\n}\n\nstatic const struct wf_sensor_ops wf_sat_ops = {\n\t.get_value\t= wf_sat_sensor_get,\n\t.release\t= wf_sat_sensor_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int wf_sat_probe(struct i2c_client *client)\n{\n\tstruct device_node *dev = client->dev.of_node;\n\tstruct wf_sat *sat;\n\tstruct wf_sat_sensor *sens;\n\tconst u32 *reg;\n\tconst char *loc;\n\tu8 chip, core;\n\tstruct device_node *child;\n\tint shift, cpu, index;\n\tchar *name;\n\tint vsens[2], isens[2];\n\n\tsat = kzalloc(sizeof(struct wf_sat), GFP_KERNEL);\n\tif (sat == NULL)\n\t\treturn -ENOMEM;\n\tsat->nr = -1;\n\tsat->node = of_node_get(dev);\n\tkref_init(&sat->ref);\n\tmutex_init(&sat->mutex);\n\tsat->i2c = client;\n\tINIT_LIST_HEAD(&sat->sensors);\n\ti2c_set_clientdata(client, sat);\n\n\tvsens[0] = vsens[1] = -1;\n\tisens[0] = isens[1] = -1;\n\tfor_each_child_of_node(dev, child) {\n\t\treg = of_get_property(child, \"reg\", NULL);\n\t\tloc = of_get_property(child, \"location\", NULL);\n\t\tif (reg == NULL || loc == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (*reg < 0x30 || *reg > 0x37)\n\t\t\tcontinue;\n\t\tindex = *reg - 0x30;\n\n\t\t \n\t\tif (strncmp(loc, \"CPU \", 4) != 0)\n\t\t\tcontinue;\n\t\tchip = loc[4] - 'A';\n\t\tcore = loc[5] - '0';\n\t\tif (chip > 1 || core > 1) {\n\t\t\tprintk(KERN_ERR \"wf_sat_create: don't understand \"\n\t\t\t       \"location %s for %pOF\\n\", loc, child);\n\t\t\tcontinue;\n\t\t}\n\t\tcpu = 2 * chip + core;\n\t\tif (sat->nr < 0)\n\t\t\tsat->nr = chip;\n\t\telse if (sat->nr != chip) {\n\t\t\tprintk(KERN_ERR \"wf_sat_create: can't cope with \"\n\t\t\t       \"multiple CPU chips on one SAT (%s)\\n\", loc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_node_is_type(child, \"voltage-sensor\")) {\n\t\t\tname = \"cpu-voltage\";\n\t\t\tshift = 4;\n\t\t\tvsens[core] = index;\n\t\t} else if (of_node_is_type(child, \"current-sensor\")) {\n\t\t\tname = \"cpu-current\";\n\t\t\tshift = 8;\n\t\t\tisens[core] = index;\n\t\t} else if (of_node_is_type(child, \"temp-sensor\")) {\n\t\t\tname = \"cpu-temp\";\n\t\t\tshift = 10;\n\t\t} else\n\t\t\tcontinue;\t \n\n\t\t \n\t\tsens = kzalloc(sizeof(struct wf_sat_sensor) + 16, GFP_KERNEL);\n\t\tif (sens == NULL) {\n\t\t\tprintk(KERN_ERR \"wf_sat_create: couldn't create \"\n\t\t\t       \"%s sensor %d (no memory)\\n\", name, cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tsens->index = index;\n\t\tsens->index2 = -1;\n\t\tsens->shift = shift;\n\t\tsens->sat = sat;\n\t\tsens->sens.ops = &wf_sat_ops;\n\t\tsens->sens.name = (char *) (sens + 1);\n\t\tsnprintf((char *)sens->sens.name, 16, \"%s-%d\", name, cpu);\n\n\t\tif (wf_register_sensor(&sens->sens))\n\t\t\tkfree(sens);\n\t\telse {\n\t\t\tlist_add(&sens->link, &sat->sensors);\n\t\t\tkref_get(&sat->ref);\n\t\t}\n\t}\n\n\t \n\tfor (core = 0; core < 2; ++core) {\n\t\tif (vsens[core] < 0 || isens[core] < 0)\n\t\t\tcontinue;\n\t\tcpu = 2 * sat->nr + core;\n\t\tsens = kzalloc(sizeof(struct wf_sat_sensor) + 16, GFP_KERNEL);\n\t\tif (sens == NULL) {\n\t\t\tprintk(KERN_ERR \"wf_sat_create: couldn't create power \"\n\t\t\t       \"sensor %d (no memory)\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\t\tsens->index = vsens[core];\n\t\tsens->index2 = isens[core];\n\t\tsens->shift = 0;\n\t\tsens->sat = sat;\n\t\tsens->sens.ops = &wf_sat_ops;\n\t\tsens->sens.name = (char *) (sens + 1);\n\t\tsnprintf((char *)sens->sens.name, 16, \"cpu-power-%d\", cpu);\n\n\t\tif (wf_register_sensor(&sens->sens))\n\t\t\tkfree(sens);\n\t\telse {\n\t\t\tlist_add(&sens->link, &sat->sensors);\n\t\t\tkref_get(&sat->ref);\n\t\t}\n\t}\n\n\tif (sat->nr >= 0)\n\t\tsats[sat->nr] = sat;\n\n\treturn 0;\n}\n\nstatic void wf_sat_remove(struct i2c_client *client)\n{\n\tstruct wf_sat *sat = i2c_get_clientdata(client);\n\tstruct wf_sat_sensor *sens;\n\n\t \n\twhile(!list_empty(&sat->sensors)) {\n\t\tsens = list_first_entry(&sat->sensors,\n\t\t\t\t\tstruct wf_sat_sensor, link);\n\t\tlist_del(&sens->link);\n\t\twf_unregister_sensor(&sens->sens);\n\t}\n\tsat->i2c = NULL;\n\tkref_put(&sat->ref, wf_sat_release);\n}\n\nstatic const struct i2c_device_id wf_sat_id[] = {\n\t{ \"MAC,smu-sat\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wf_sat_id);\n\nstatic const struct of_device_id wf_sat_of_id[] = {\n\t{ .compatible = \"smu-sat\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wf_sat_of_id);\n\nstatic struct i2c_driver wf_sat_driver = {\n\t.driver = {\n\t\t.name\t\t= \"wf_smu_sat\",\n\t\t.of_match_table = wf_sat_of_id,\n\t},\n\t.probe\t\t= wf_sat_probe,\n\t.remove\t\t= wf_sat_remove,\n\t.id_table\t= wf_sat_id,\n};\n\nmodule_i2c_driver(wf_sat_driver);\n\nMODULE_AUTHOR(\"Paul Mackerras <paulus@samba.org>\");\nMODULE_DESCRIPTION(\"SMU satellite sensors for PowerMac thermal control\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}