{
  "module_name": "adbhid.c",
  "hash_id": "bf3ca1f7505247e1f53168e891a7a074fc75827f8107ed674add084c24552339",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/adbhid.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/input.h>\n\n#include <linux/adb.h>\n#include <linux/cuda.h>\n#include <linux/pmu.h>\n\n#include <asm/machdep.h>\n#ifdef CONFIG_PPC_PMAC\n#include <asm/backlight.h>\n#include <asm/pmac_feature.h>\n#endif\n\nMODULE_AUTHOR(\"Franz Sirl <Franz.Sirl-kernel@lauterbach.com>\");\n\nstatic int restore_capslock_events;\nmodule_param(restore_capslock_events, int, 0644);\nMODULE_PARM_DESC(restore_capslock_events,\n\t\"Produce keypress events for capslock on both keyup and keydown.\");\n\n#define KEYB_KEYREG\t0\t \n#define KEYB_LEDREG\t2\t \n#define MOUSE_DATAREG\t0\t \n\nstatic int adb_message_handler(struct notifier_block *, unsigned long, void *);\nstatic struct notifier_block adbhid_adb_notifier = {\n\t.notifier_call\t= adb_message_handler,\n};\n\n \n#define ADB_KEY_DEL\t\t0x33\n#define ADB_KEY_CMD\t\t0x37\n#define ADB_KEY_CAPSLOCK\t0x39\n#define ADB_KEY_FN\t\t0x3f\n#define ADB_KEY_FWDEL\t\t0x75\n#define ADB_KEY_POWER_OLD\t0x7e\n#define ADB_KEY_POWER\t\t0x7f\n\nstatic const u16 adb_to_linux_keycodes[128] = {\n\t  KEY_A, \t\t \n\t  KEY_S, \t\t \n\t  KEY_D,\t\t \n\t  KEY_F,\t\t \n\t  KEY_H,\t\t \n\t  KEY_G,\t\t \n\t  KEY_Z,\t\t \n\t  KEY_X,\t\t \n\t  KEY_C,\t\t \n\t  KEY_V,\t\t \n\t  KEY_102ND,\t\t \n\t  KEY_B,\t\t \n\t  KEY_Q,\t\t \n\t  KEY_W,\t\t \n\t  KEY_E,\t\t \n\t  KEY_R,\t\t \n\t  KEY_Y,\t\t \n\t  KEY_T,\t\t \n\t  KEY_1,\t\t \n\t  KEY_2,\t\t \n\t  KEY_3,\t\t \n\t  KEY_4,\t\t \n\t  KEY_6,\t\t \n\t  KEY_5,\t\t \n\t  KEY_EQUAL,\t\t \n\t  KEY_9,\t\t \n\t  KEY_7,\t\t \n\t  KEY_MINUS,\t\t \n\t  KEY_8,\t\t \n\t  KEY_0,\t\t \n\t  KEY_RIGHTBRACE,\t \n\t  KEY_O,\t\t \n\t  KEY_U,\t\t \n\t  KEY_LEFTBRACE,\t \n\t  KEY_I,\t\t \n\t  KEY_P,\t\t \n\t  KEY_ENTER,\t\t \n\t  KEY_L,\t\t \n\t  KEY_J,\t\t \n\t  KEY_APOSTROPHE,\t \n\t  KEY_K,\t\t \n\t  KEY_SEMICOLON,\t \n\t  KEY_BACKSLASH,\t \n\t  KEY_COMMA,\t\t \n\t  KEY_SLASH,\t\t \n\t  KEY_N,\t\t \n\t  KEY_M,\t\t \n\t  KEY_DOT,\t\t \n\t  KEY_TAB,\t\t \n\t  KEY_SPACE,\t\t \n\t  KEY_GRAVE,\t\t \n\t  KEY_BACKSPACE,\t \n\t  KEY_KPENTER,\t\t \n\t  KEY_ESC,\t\t \n\t  KEY_LEFTCTRL,\t \n\t  KEY_LEFTMETA,\t \n\t  KEY_LEFTSHIFT,\t \n\t  KEY_CAPSLOCK,\t \n\t  KEY_LEFTALT,\t\t \n\t  KEY_LEFT,\t\t \n\t  KEY_RIGHT,\t\t \n\t  KEY_DOWN,\t\t \n\t  KEY_UP,\t\t \n\t  KEY_FN,\t\t \n\t  0,\n\t  KEY_KPDOT,\t\t \n\t  0,\n\t  KEY_KPASTERISK,\t \n\t  0,\n\t  KEY_KPPLUS,\t\t \n\t  0,\n\t  KEY_NUMLOCK,\t\t \n\t  0,\n\t  0,\n\t  0,\n\t  KEY_KPSLASH,\t\t \n\t  KEY_KPENTER,\t\t \n\t  0,\n\t  KEY_KPMINUS,\t\t \n\t  0,\n\t  0,\n\t  KEY_KPEQUAL,\t\t \n\t  KEY_KP0,\t\t \n\t  KEY_KP1,\t\t \n\t  KEY_KP2,\t\t \n\t  KEY_KP3,\t\t \n\t  KEY_KP4,\t\t \n\t  KEY_KP5,\t\t \n\t  KEY_KP6,\t\t \n\t  KEY_KP7,\t\t \n\t  0,\n\t  KEY_KP8,\t\t \n\t  KEY_KP9,\t\t \n\t  KEY_YEN,\t\t \n\t  KEY_RO,\t\t \n\t  KEY_KPCOMMA,\t\t \n\t  KEY_F5,\t\t \n\t  KEY_F6,\t\t \n\t  KEY_F7,\t\t \n\t  KEY_F3,\t\t \n\t  KEY_F8,\t\t \n\t  KEY_F9,\t\t \n\t  KEY_HANJA,\t\t \n\t  KEY_F11,\t\t \n\t  KEY_HANGEUL,\t\t \n\t  KEY_SYSRQ,\t\t \n\t  0,\n\t  KEY_SCROLLLOCK,\t \n\t  0,\n\t  KEY_F10,\t\t \n\t  KEY_COMPOSE,\t\t \n\t  KEY_F12,\t\t \n\t  0,\n\t  KEY_PAUSE,\t\t \n\t  KEY_INSERT,\t\t \n\t  KEY_HOME,\t\t \n\t  KEY_PAGEUP,\t\t \n\t  KEY_DELETE,\t\t \n\t  KEY_F4,\t\t \n\t  KEY_END,\t\t \n\t  KEY_F2,\t\t \n\t  KEY_PAGEDOWN,\t \n\t  KEY_F1,\t\t \n\t  KEY_RIGHTSHIFT,\t \n\t  KEY_RIGHTALT,\t \n\t  KEY_RIGHTCTRL,\t \n\t  KEY_RIGHTMETA,\t \n\t  KEY_POWER,\t\t \n};\n\nstruct adbhid {\n\tstruct input_dev *input;\n\tint id;\n\tint default_id;\n\tint original_handler_id;\n\tint current_handler_id;\n\tint mouse_kind;\n\tu16 *keycode;\n\tchar name[64];\n\tchar phys[32];\n\tint flags;\n};\n\n#define FLAG_FN_KEY_PRESSED\t\t0x00000001\n#define FLAG_POWER_FROM_FN\t\t0x00000002\n#define FLAG_EMU_FWDEL_DOWN\t\t0x00000004\n#define FLAG_CAPSLOCK_TRANSLATE\t\t0x00000008\n#define FLAG_CAPSLOCK_DOWN\t\t0x00000010\n#define FLAG_CAPSLOCK_IGNORE_NEXT\t0x00000020\n#define FLAG_POWER_KEY_PRESSED\t\t0x00000040\n\nstatic struct adbhid *adbhid[16];\n\nstatic void adbhid_probe(void);\n\nstatic void adbhid_input_keycode(int, int, int);\n\nstatic void init_trackpad(int id);\nstatic void init_trackball(int id);\nstatic void init_turbomouse(int id);\nstatic void init_microspeed(int id);\nstatic void init_ms_a3(int id);\n\nstatic struct adb_ids keyboard_ids;\nstatic struct adb_ids mouse_ids;\nstatic struct adb_ids buttons_ids;\n\n \n#define ADB_KEYBOARD_UNKNOWN\t0\n#define ADB_KEYBOARD_ANSI\t0x0100\n#define ADB_KEYBOARD_ISO\t0x0200\n#define ADB_KEYBOARD_JIS\t0x0300\n\n \n#define ADBMOUSE_STANDARD_100\t0\t \n#define ADBMOUSE_STANDARD_200\t1\t \n#define ADBMOUSE_EXTENDED\t2\t \n#define ADBMOUSE_TRACKBALL\t3\t \n#define ADBMOUSE_TRACKPAD       4\t \n#define ADBMOUSE_TURBOMOUSE5    5\t \n#define ADBMOUSE_MICROSPEED\t6\t \n#define ADBMOUSE_TRACKBALLPRO\t7\t \n#define ADBMOUSE_MS_A3\t\t8\t \n#define ADBMOUSE_MACALLY2\t9\t \n\nstatic void\nadbhid_keyboard_input(unsigned char *data, int nb, int apoll)\n{\n\tint id = (data[0] >> 4) & 0x0f;\n\n\tif (!adbhid[id]) {\n\t\tpr_err(\"ADB HID on ID %d not yet registered, packet %#02x, %#02x, %#02x, %#02x\\n\",\n\t\t       id, data[0], data[1], data[2], data[3]);\n\t\treturn;\n\t}\n\n\t \n\tif (nb != 3 || (data[0] & 3) != KEYB_KEYREG)\n\t\treturn;\t\t \n\tadbhid_input_keycode(id, data[1], 0);\n\tif (!(data[2] == 0xff || (data[2] == 0x7f && data[1] == 0x7f)))\n\t\tadbhid_input_keycode(id, data[2], 0);\n}\n\nstatic void\nadbhid_input_keycode(int id, int scancode, int repeat)\n{\n\tstruct adbhid *ahid = adbhid[id];\n\tint keycode, up_flag, key;\n\n\tkeycode = scancode & 0x7f;\n\tup_flag = scancode & 0x80;\n\n\tif (restore_capslock_events) {\n\t\tif (keycode == ADB_KEY_CAPSLOCK && !up_flag) {\n\t\t\t \n\t\t\tif (ahid->flags & FLAG_CAPSLOCK_IGNORE_NEXT) {\n\t\t\t\t \n\t\t\t\tahid->flags &= ~FLAG_CAPSLOCK_IGNORE_NEXT;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tahid->flags |= FLAG_CAPSLOCK_TRANSLATE\n\t\t\t\t\t| FLAG_CAPSLOCK_DOWN;\n\t\t\t}\n\t\t} else if (scancode == 0xff &&\n\t\t\t   !(ahid->flags & FLAG_POWER_KEY_PRESSED)) {\n\t\t\t \n\t\t\tif (ahid->flags & FLAG_CAPSLOCK_TRANSLATE) {\n\t\t\t\tkeycode = ADB_KEY_CAPSLOCK;\n\t\t\t\tif (ahid->flags & FLAG_CAPSLOCK_DOWN) {\n\t\t\t\t\t \n\t\t\t\t\tup_flag = 1;\n\t\t\t\t\tahid->flags &= ~FLAG_CAPSLOCK_DOWN;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tup_flag = 0;\n\t\t\t\t\tahid->flags &= ~FLAG_CAPSLOCK_TRANSLATE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpr_info(\"Spurious caps lock event (scancode 0xff).\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (keycode) {\n\tcase ADB_KEY_CAPSLOCK:\n\t\tif (!restore_capslock_events) {\n\t\t\t \n\t\t\tinput_report_key(ahid->input, KEY_CAPSLOCK, 1);\n\t\t\tinput_sync(ahid->input);\n\t\t\tinput_report_key(ahid->input, KEY_CAPSLOCK, 0);\n\t\t\tinput_sync(ahid->input);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_PPC_PMAC\n\tcase ADB_KEY_POWER_OLD:  \n\t\tswitch(pmac_call_feature(PMAC_FTR_GET_MB_INFO,\n\t\t\tNULL, PMAC_MB_INFO_MODEL, 0)) {\n\t\tcase PMAC_TYPE_COMET:\n\t\tcase PMAC_TYPE_HOOPER:\n\t\tcase PMAC_TYPE_KANGA:\n\t\t\tkeycode = ADB_KEY_POWER;\n\t\t}\n\t\tbreak;\n\tcase ADB_KEY_POWER:\n\t\t \n\t\tif (up_flag)\n\t\t\tahid->flags &= ~FLAG_POWER_KEY_PRESSED;\n\t\telse\n\t\t\tahid->flags |= FLAG_POWER_KEY_PRESSED;\n\n\t\t \n\t\tif (ahid->flags & FLAG_FN_KEY_PRESSED) {\n\t\t\tkeycode = ADB_KEY_CMD;\n\t\t\tif (up_flag)\n\t\t\t\tahid->flags &= ~FLAG_POWER_FROM_FN;\n\t\t\telse\n\t\t\t\tahid->flags |= FLAG_POWER_FROM_FN;\n\t\t} else if (ahid->flags & FLAG_POWER_FROM_FN) {\n\t\t\tkeycode = ADB_KEY_CMD;\n\t\t\tahid->flags &= ~FLAG_POWER_FROM_FN;\n\t\t}\n\t\tbreak;\n\tcase ADB_KEY_FN:\n\t\t \n\t\tif (up_flag) {\n\t\t\tahid->flags &= ~FLAG_FN_KEY_PRESSED;\n\t\t\t \n\t\t\tif (ahid->flags & FLAG_EMU_FWDEL_DOWN) {\n\t\t\t\tahid->flags &= ~FLAG_EMU_FWDEL_DOWN;\n\t\t\t\tkeycode = ADB_KEY_FWDEL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tahid->flags |= FLAG_FN_KEY_PRESSED;\n\t\tbreak;\n\tcase ADB_KEY_DEL:\n\t\t \n\t\tif (ahid->flags & FLAG_FN_KEY_PRESSED) {\n\t\t\tkeycode = ADB_KEY_FWDEL;\n\t\t\tif (up_flag)\n\t\t\t\tahid->flags &= ~FLAG_EMU_FWDEL_DOWN;\n\t\t\telse\n\t\t\t\tahid->flags |= FLAG_EMU_FWDEL_DOWN;\n\t\t}\n\t\tbreak;\n#endif  \n\t}\n\n\tkey = adbhid[id]->keycode[keycode];\n\tif (key) {\n\t\tinput_report_key(adbhid[id]->input, key, !up_flag);\n\t\tinput_sync(adbhid[id]->input);\n\t} else\n\t\tpr_info(\"Unhandled ADB key (scancode %#02x) %s.\\n\", keycode,\n\t\t\tup_flag ? \"released\" : \"pressed\");\n\n}\n\nstatic void\nadbhid_mouse_input(unsigned char *data, int nb, int autopoll)\n{\n\tint id = (data[0] >> 4) & 0x0f;\n\n\tif (!adbhid[id]) {\n\t\tpr_err(\"ADB HID on ID %d not yet registered\\n\", id);\n\t\treturn;\n\t}\n\n   \n\n\t \n\tswitch (adbhid[id]->mouse_kind)\n\t{\n\t    case ADBMOUSE_TRACKPAD:\n\t\tdata[1] = (data[1] & 0x7f) | ((data[1] & data[2]) & 0x80);\n\t\tdata[2] = data[2] | 0x80;\n\t\tbreak;\n\t    case ADBMOUSE_MICROSPEED:\n\t\tdata[1] = (data[1] & 0x7f) | ((data[3] & 0x01) << 7);\n\t\tdata[2] = (data[2] & 0x7f) | ((data[3] & 0x02) << 6);\n\t\tdata[3] = (data[3] & 0x77) | ((data[3] & 0x04) << 5)\n\t\t\t| (data[3] & 0x08);\n\t\tbreak;\n\t    case ADBMOUSE_TRACKBALLPRO:\n\t\tdata[1] = (data[1] & 0x7f) | (((data[3] & 0x04) << 5)\n\t\t\t& ((data[3] & 0x08) << 4));\n\t\tdata[2] = (data[2] & 0x7f) | ((data[3] & 0x01) << 7);\n\t\tdata[3] = (data[3] & 0x77) | ((data[3] & 0x02) << 6);\n\t\tbreak;\n\t    case ADBMOUSE_MS_A3:\n\t\tdata[1] = (data[1] & 0x7f) | ((data[3] & 0x01) << 7);\n\t\tdata[2] = (data[2] & 0x7f) | ((data[3] & 0x02) << 6);\n\t\tdata[3] = ((data[3] & 0x04) << 5);\n\t\tbreak;\n            case ADBMOUSE_MACALLY2:\n\t\tdata[3] = (data[2] & 0x80) ? 0x80 : 0x00;\n\t\tdata[2] |= 0x80;   \n\t\tnb=4;\n                break;\n\t}\n\n\tinput_report_key(adbhid[id]->input, BTN_LEFT,   !((data[1] >> 7) & 1));\n\tinput_report_key(adbhid[id]->input, BTN_MIDDLE, !((data[2] >> 7) & 1));\n\n\tif (nb >= 4 && adbhid[id]->mouse_kind != ADBMOUSE_TRACKPAD)\n\t\tinput_report_key(adbhid[id]->input, BTN_RIGHT,  !((data[3] >> 7) & 1));\n\n\tinput_report_rel(adbhid[id]->input, REL_X,\n\t\t\t ((data[2]&0x7f) < 64 ? (data[2]&0x7f) : (data[2]&0x7f)-128 ));\n\tinput_report_rel(adbhid[id]->input, REL_Y,\n\t\t\t ((data[1]&0x7f) < 64 ? (data[1]&0x7f) : (data[1]&0x7f)-128 ));\n\n\tinput_sync(adbhid[id]->input);\n}\n\nstatic void\nadbhid_buttons_input(unsigned char *data, int nb, int autopoll)\n{\n\tint id = (data[0] >> 4) & 0x0f;\n\n\tif (!adbhid[id]) {\n\t\tpr_err(\"ADB HID on ID %d not yet registered\\n\", id);\n\t\treturn;\n\t}\n\n\tswitch (adbhid[id]->original_handler_id) {\n\tdefault:\n\tcase 0x02:  \n\t  {\n\t\tint down = (data[1] == (data[1] & 0xf));\n\n\t\tswitch (data[1] & 0x0f) {\n\t\tcase 0x0:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_SOUND, down);\n\t\t\tbreak;\n\n\t\tcase 0x1:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_MUTE, down);\n\t\t\tbreak;\n\n\t\tcase 0x2:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_VOLUMEDOWN, down);\n\t\t\tbreak;\n\n\t\tcase 0x3:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_VOLUMEUP, down);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_info(\"Unhandled ADB_MISC event %02x, %02x, %02x, %02x\\n\",\n\t\t\t\tdata[0], data[1], data[2], data[3]);\n\t\t\tbreak;\n\t\t}\n\t  }\n\t  break;\n\n\tcase 0x1f:  \n\t  {\n\t\tint down = (data[1] == (data[1] & 0xf));\n\n\t\t \n\n\t\tswitch (data[1] & 0x0f) {\n\t\tcase 0x8:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_MUTE, down);\n\t\t\tbreak;\n\n\t\tcase 0x7:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_VOLUMEDOWN, down);\n\t\t\tbreak;\n\n\t\tcase 0x6:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_VOLUMEUP, down);\n\t\t\tbreak;\n\n\t\tcase 0xb:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_EJECTCD, down);\n\t\t\tbreak;\n\n\t\tcase 0xa:\t \n#ifdef CONFIG_PMAC_BACKLIGHT\n\t\t\tif (down)\n\t\t\t\tpmac_backlight_key_down();\n#endif\n\t\t\tinput_report_key(adbhid[id]->input, KEY_BRIGHTNESSDOWN, down);\n\t\t\tbreak;\n\n\t\tcase 0x9:\t \n#ifdef CONFIG_PMAC_BACKLIGHT\n\t\t\tif (down)\n\t\t\t\tpmac_backlight_key_up();\n#endif\n\t\t\tinput_report_key(adbhid[id]->input, KEY_BRIGHTNESSUP, down);\n\t\t\tbreak;\n\n\t\tcase 0xc:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_SWITCHVIDEOMODE, down);\n\t\t\tbreak;\n\n\t\tcase 0xd:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_KBDILLUMTOGGLE, down);\n\t\t\tbreak;\n\n\t\tcase 0xe:\t \n\t\t\tinput_report_key(adbhid[id]->input, KEY_KBDILLUMDOWN, down);\n\t\t\tbreak;\n\n\t\tcase 0xf:\n\t\t\tswitch (data[1]) {\n\t\t\tcase 0x8f:\n\t\t\tcase 0x0f:\n\t\t\t\t \n\t\t\t\tinput_report_key(adbhid[id]->input, KEY_KBDILLUMUP, down);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x7f:\n\t\t\tcase 0xff:\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_info(\"Unhandled ADB_MISC event %02x, %02x, %02x, %02x\\n\",\n\t\t\t\t\tdata[0], data[1], data[2], data[3]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Unhandled ADB_MISC event %02x, %02x, %02x, %02x\\n\",\n\t\t\t\tdata[0], data[1], data[2], data[3]);\n\t\t\tbreak;\n\t\t}\n\t  }\n\t  break;\n\t}\n\n\tinput_sync(adbhid[id]->input);\n}\n\nstatic struct adb_request led_request;\nstatic int leds_pending[16];\nstatic int leds_req_pending;\nstatic int pending_devs[16];\nstatic int pending_led_start;\nstatic int pending_led_end;\nstatic DEFINE_SPINLOCK(leds_lock);\n\nstatic void leds_done(struct adb_request *req)\n{\n\tint leds = 0, device = 0, pending = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leds_lock, flags);\n\n\tif (pending_led_start != pending_led_end) {\n\t\tdevice = pending_devs[pending_led_start];\n\t\tleds = leds_pending[device] & 0xff;\n\t\tleds_pending[device] = 0;\n\t\tpending_led_start++;\n\t\tpending_led_start = (pending_led_start < 16) ? pending_led_start : 0;\n\t\tpending = leds_req_pending;\n\t} else\n\t\tleds_req_pending = 0;\n\tspin_unlock_irqrestore(&leds_lock, flags);\n\tif (pending)\n\t\tadb_request(&led_request, leds_done, 0, 3,\n\t\t\t    ADB_WRITEREG(device, KEYB_LEDREG), 0xff, ~leds);\n}\n\nstatic void real_leds(unsigned char leds, int device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leds_lock, flags);\n\tif (!leds_req_pending) {\n\t\tleds_req_pending = 1;\n\t\tspin_unlock_irqrestore(&leds_lock, flags);\t       \n\t\tadb_request(&led_request, leds_done, 0, 3,\n\t\t\t    ADB_WRITEREG(device, KEYB_LEDREG), 0xff, ~leds);\n\t\treturn;\n\t} else {\n\t\tif (!(leds_pending[device] & 0x100)) {\n\t\t\tpending_devs[pending_led_end] = device;\n\t\t\tpending_led_end++;\n\t\t\tpending_led_end = (pending_led_end < 16) ? pending_led_end : 0;\n\t\t}\n\t\tleds_pending[device] = leds | 0x100;\n\t}\n\tspin_unlock_irqrestore(&leds_lock, flags);\t       \n}\n\n \nstatic int adbhid_kbd_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\n{\n\tstruct adbhid *adbhid = input_get_drvdata(dev);\n\tunsigned char leds;\n\n\tswitch (type) {\n\tcase EV_LED:\n\t\tleds =  (test_bit(LED_SCROLLL, dev->led) ? 4 : 0) |\n\t\t\t(test_bit(LED_NUML,    dev->led) ? 1 : 0) |\n\t\t\t(test_bit(LED_CAPSL,   dev->led) ? 2 : 0);\n\t\treal_leds(leds, adbhid->id);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic void\nadbhid_kbd_capslock_remember(void)\n{\n\tstruct adbhid *ahid;\n\tint i;\n\n\tfor (i = 1; i < 16; i++) {\n\t\tahid = adbhid[i];\n\n\t\tif (ahid && ahid->id == ADB_KEYBOARD)\n\t\t\tif (ahid->flags & FLAG_CAPSLOCK_TRANSLATE)\n\t\t\t\tahid->flags |= FLAG_CAPSLOCK_IGNORE_NEXT;\n\t}\n}\n\nstatic int\nadb_message_handler(struct notifier_block *this, unsigned long code, void *x)\n{\n\tswitch (code) {\n\tcase ADB_MSG_PRE_RESET:\n\tcase ADB_MSG_POWERDOWN:\n\t\t \n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 1; i < 16; i++) {\n\t\t\t\tif (adbhid[i])\n\t\t\t\t\tdel_timer_sync(&adbhid[i]->input->timer);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twhile (leds_req_pending)\n\t\t\tadb_poll();\n\n\t\t \n\t\tif (restore_capslock_events)\n\t\t\tadbhid_kbd_capslock_remember();\n\n\t\tbreak;\n\n\tcase ADB_MSG_POST_RESET:\n\t\tadbhid_probe();\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nadbhid_input_register(int id, int default_id, int original_handler_id,\n\t\t      int current_handler_id, int mouse_kind)\n{\n\tstruct adbhid *hid;\n\tstruct input_dev *input_dev;\n\tint err;\n\tint i;\n\tchar *keyboard_type;\n\n\tif (adbhid[id]) {\n\t\tpr_err(\"Trying to reregister ADB HID on ID %d\\n\", id);\n\t\treturn -EEXIST;\n\t}\n\n\tadbhid[id] = hid = kzalloc(sizeof(struct adbhid), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!hid || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tsprintf(hid->phys, \"adb%d:%d.%02x/input\", id, default_id, original_handler_id);\n\n\thid->input = input_dev;\n\thid->id = default_id;\n\thid->original_handler_id = original_handler_id;\n\thid->current_handler_id = current_handler_id;\n\thid->mouse_kind = mouse_kind;\n\thid->flags = 0;\n\tinput_set_drvdata(input_dev, hid);\n\tinput_dev->name = hid->name;\n\tinput_dev->phys = hid->phys;\n\tinput_dev->id.bustype = BUS_ADB;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = (id << 12) | (default_id << 8) | original_handler_id;\n\tinput_dev->id.version = 0x0100;\n\n\tswitch (default_id) {\n\tcase ADB_KEYBOARD:\n\t\thid->keycode = kmemdup(adb_to_linux_keycodes,\n\t\t\t\t       sizeof(adb_to_linux_keycodes), GFP_KERNEL);\n\t\tif (!hid->keycode) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsprintf(hid->name, \"ADB keyboard\");\n\n\t\tswitch (original_handler_id) {\n\t\tdefault:\n\t\t\tkeyboard_type = \"<unknown>\";\n\t\t\tinput_dev->id.version = ADB_KEYBOARD_UNKNOWN;\n\t\t\tbreak;\n\n\t\tcase 0x01: case 0x02: case 0x03: case 0x06: case 0x08:\n\t\tcase 0x0C: case 0x10: case 0x18: case 0x1B: case 0x1C:\n\t\tcase 0xC0: case 0xC3: case 0xC6:\n\t\t\tkeyboard_type = \"ANSI\";\n\t\t\tinput_dev->id.version = ADB_KEYBOARD_ANSI;\n\t\t\tbreak;\n\n\t\tcase 0x04: case 0x05: case 0x07: case 0x09: case 0x0D:\n\t\tcase 0x11: case 0x14: case 0x19: case 0x1D: case 0xC1:\n\t\tcase 0xC4: case 0xC7:\n\t\t\tkeyboard_type = \"ISO, swapping keys\";\n\t\t\tinput_dev->id.version = ADB_KEYBOARD_ISO;\n\t\t\tswap(hid->keycode[10], hid->keycode[50]);\n\t\t\tbreak;\n\n\t\tcase 0x12: case 0x15: case 0x16: case 0x17: case 0x1A:\n\t\tcase 0x1E: case 0xC2: case 0xC5: case 0xC8: case 0xC9:\n\t\t\tkeyboard_type = \"JIS\";\n\t\t\tinput_dev->id.version = ADB_KEYBOARD_JIS;\n\t\t\tbreak;\n\t\t}\n\t\tpr_info(\"Detected ADB keyboard, type %s.\\n\", keyboard_type);\n\n\t\tfor (i = 0; i < 128; i++)\n\t\t\tif (hid->keycode[i])\n\t\t\t\tset_bit(hid->keycode[i], input_dev->keybit);\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n\t\t\tBIT_MASK(EV_REP);\n\t\tinput_dev->ledbit[0] = BIT_MASK(LED_SCROLLL) |\n\t\t\tBIT_MASK(LED_CAPSL) | BIT_MASK(LED_NUML);\n\t\tinput_dev->event = adbhid_kbd_event;\n\t\tinput_dev->keycodemax = KEY_FN;\n\t\tinput_dev->keycodesize = sizeof(hid->keycode[0]);\n\t\tbreak;\n\n\tcase ADB_MOUSE:\n\t\tsprintf(hid->name, \"ADB mouse\");\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\t\tinput_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\t\tBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\n\t\tinput_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\t\tbreak;\n\n\tcase ADB_MISC:\n\t\tswitch (original_handler_id) {\n\t\tcase 0x02:  \n\t\t\tsprintf(hid->name, \"ADB adjustable keyboard buttons\");\n\t\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) |\n\t\t\t\tBIT_MASK(EV_REP);\n\t\t\tset_bit(KEY_SOUND, input_dev->keybit);\n\t\t\tset_bit(KEY_MUTE, input_dev->keybit);\n\t\t\tset_bit(KEY_VOLUMEUP, input_dev->keybit);\n\t\t\tset_bit(KEY_VOLUMEDOWN, input_dev->keybit);\n\t\t\tbreak;\n\t\tcase 0x1f:  \n\t\t\tsprintf(hid->name, \"ADB Powerbook buttons\");\n\t\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) |\n\t\t\t\tBIT_MASK(EV_REP);\n\t\t\tset_bit(KEY_MUTE, input_dev->keybit);\n\t\t\tset_bit(KEY_VOLUMEUP, input_dev->keybit);\n\t\t\tset_bit(KEY_VOLUMEDOWN, input_dev->keybit);\n\t\t\tset_bit(KEY_BRIGHTNESSUP, input_dev->keybit);\n\t\t\tset_bit(KEY_BRIGHTNESSDOWN, input_dev->keybit);\n\t\t\tset_bit(KEY_EJECTCD, input_dev->keybit);\n\t\t\tset_bit(KEY_SWITCHVIDEOMODE, input_dev->keybit);\n\t\t\tset_bit(KEY_KBDILLUMTOGGLE, input_dev->keybit);\n\t\t\tset_bit(KEY_KBDILLUMDOWN, input_dev->keybit);\n\t\t\tset_bit(KEY_KBDILLUMUP, input_dev->keybit);\n\t\t\tbreak;\n\t\t}\n\t\tif (hid->name[0])\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tdefault:\n\t\tpr_info(\"Trying to register unknown ADB device to input layer.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tinput_dev->keycode = hid->keycode;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\tgoto fail;\n\n\tif (default_id == ADB_KEYBOARD) {\n\t\t \n\t\tinput_dev->rep[REP_DELAY] = 500;    \n\t\tinput_dev->rep[REP_PERIOD] = 66;  \n\t}\n\n\treturn 0;\n\n fail:\tinput_free_device(input_dev);\n\tif (hid) {\n\t\tkfree(hid->keycode);\n\t\tkfree(hid);\n\t}\n\tadbhid[id] = NULL;\n\treturn err;\n}\n\nstatic void adbhid_input_unregister(int id)\n{\n\tinput_unregister_device(adbhid[id]->input);\n\tkfree(adbhid[id]->keycode);\n\tkfree(adbhid[id]);\n\tadbhid[id] = NULL;\n}\n\n\nstatic u16\nadbhid_input_reregister(int id, int default_id, int org_handler_id,\n\t\t\tint cur_handler_id, int mk)\n{\n\tif (adbhid[id]) {\n\t\tif (adbhid[id]->input->id.product !=\n\t\t    ((id << 12)|(default_id << 8)|org_handler_id)) {\n\t\t\tadbhid_input_unregister(id);\n\t\t\tadbhid_input_register(id, default_id, org_handler_id,\n\t\t\t\t\t      cur_handler_id, mk);\n\t\t}\n\t} else\n\t\tadbhid_input_register(id, default_id, org_handler_id,\n\t\t\t\t      cur_handler_id, mk);\n\treturn 1<<id;\n}\n\nstatic void\nadbhid_input_devcleanup(u16 exist)\n{\n\tint i;\n\tfor(i=1; i<16; i++)\n\t\tif (adbhid[i] && !(exist&(1<<i)))\n\t\t\tadbhid_input_unregister(i);\n}\n\nstatic void\nadbhid_probe(void)\n{\n\tstruct adb_request req;\n\tint i, default_id, org_handler_id, cur_handler_id;\n\tu16 reg = 0;\n\n\tadb_register(ADB_MOUSE, 0, &mouse_ids, adbhid_mouse_input);\n\tadb_register(ADB_KEYBOARD, 0, &keyboard_ids, adbhid_keyboard_input);\n\tadb_register(ADB_MISC, 0, &buttons_ids, adbhid_buttons_input);\n\n\tfor (i = 0; i < keyboard_ids.nids; i++) {\n\t\tint id = keyboard_ids.id[i];\n\n\t\tadb_get_infos(id, &default_id, &org_handler_id);\n\n\t\t \n\t\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\t\t\t    ADB_WRITEREG(id, KEYB_LEDREG), 0xff, 0xff);\n\n\t\t \n#if 0\t\t \n\t\tif (!adb_try_handler_change(id, 5))\n#endif\n\t\tadb_try_handler_change(id, 3);\n\n\t\tadb_get_infos(id, &default_id, &cur_handler_id);\n\t\tprintk(KERN_DEBUG \"ADB keyboard at %d has handler 0x%X\\n\",\n\t\t       id, cur_handler_id);\n\t\treg |= adbhid_input_reregister(id, default_id, org_handler_id,\n\t\t\t\t\t       cur_handler_id, 0);\n\t}\n\n\tfor (i = 0; i < buttons_ids.nids; i++) {\n\t\tint id = buttons_ids.id[i];\n\n\t\tadb_get_infos(id, &default_id, &org_handler_id);\n\t\treg |= adbhid_input_reregister(id, default_id, org_handler_id,\n\t\t\t\t\t       org_handler_id, 0);\n\t}\n\n\t \n\tfor (i = 0; i < mouse_ids.nids; i++) {\n\t\tint id = mouse_ids.id[i];\n\t\tint mouse_kind;\n\t\tchar *desc = \"standard\";\n\n\t\tadb_get_infos(id, &default_id, &org_handler_id);\n\n\t\tif (adb_try_handler_change(id, 4)) {\n\t\t\tmouse_kind = ADBMOUSE_EXTENDED;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 0x2F)) {\n\t\t\tmouse_kind = ADBMOUSE_MICROSPEED;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 0x42)) {\n\t\t\tmouse_kind = ADBMOUSE_TRACKBALLPRO;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 0x66)) {\n\t\t\tmouse_kind = ADBMOUSE_MICROSPEED;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 0x5F)) {\n\t\t\tmouse_kind = ADBMOUSE_MICROSPEED;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 3)) {\n\t\t\tmouse_kind = ADBMOUSE_MS_A3;\n\t\t}\n\t\telse if (adb_try_handler_change(id, 2)) {\n\t\t\tmouse_kind = ADBMOUSE_STANDARD_200;\n\t\t}\n\t\telse {\n\t\t\tmouse_kind = ADBMOUSE_STANDARD_100;\n\t\t}\n\n\t\tif ((mouse_kind == ADBMOUSE_TRACKBALLPRO)\n\t\t    || (mouse_kind == ADBMOUSE_MICROSPEED)) {\n\t\t\tdesc = \"Microspeed/MacPoint or compatible\";\n\t\t\tinit_microspeed(id);\n\t\t} else if (mouse_kind == ADBMOUSE_MS_A3) {\n\t\t\tdesc = \"Mouse Systems A3 Mouse or compatible\";\n\t\t\tinit_ms_a3(id);\n\t\t} else if (mouse_kind ==  ADBMOUSE_EXTENDED) {\n\t\t\tdesc = \"extended\";\n\t\t\t \n\t\t\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t\t\t    ADB_READREG(id, 1));\n\n\t\t\tif ((req.reply_len) &&\n\t\t\t    (req.reply[1] == 0x9a) && ((req.reply[2] == 0x21)\n\t\t\t    \t|| (req.reply[2] == 0x20))) {\n\t\t\t\tmouse_kind = ADBMOUSE_TRACKBALL;\n\t\t\t\tdesc = \"trackman/mouseman\";\n\t\t\t\tinit_trackball(id);\n\t\t\t}\n\t\t\telse if ((req.reply_len >= 4) &&\n\t\t\t    (req.reply[1] == 0x74) && (req.reply[2] == 0x70) &&\n\t\t\t    (req.reply[3] == 0x61) && (req.reply[4] == 0x64)) {\n\t\t\t\tmouse_kind = ADBMOUSE_TRACKPAD;\n\t\t\t\tdesc = \"trackpad\";\n\t\t\t\tinit_trackpad(id);\n\t\t\t}\n\t\t\telse if ((req.reply_len >= 4) &&\n\t\t\t    (req.reply[1] == 0x4b) && (req.reply[2] == 0x4d) &&\n\t\t\t    (req.reply[3] == 0x4c) && (req.reply[4] == 0x31)) {\n\t\t\t\tmouse_kind = ADBMOUSE_TURBOMOUSE5;\n\t\t\t\tdesc = \"TurboMouse 5\";\n\t\t\t\tinit_turbomouse(id);\n\t\t\t}\n\t\t\telse if ((req.reply_len == 9) &&\n\t\t\t    (req.reply[1] == 0x4b) && (req.reply[2] == 0x4f) &&\n\t\t\t    (req.reply[3] == 0x49) && (req.reply[4] == 0x54)) {\n\t\t\t\tif (adb_try_handler_change(id, 0x42)) {\n\t\t\t\t\tmouse_kind = ADBMOUSE_MACALLY2;\n\t\t\t\t\tdesc = \"MacAlly 2-button\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadb_get_infos(id, &default_id, &cur_handler_id);\n\t\tprintk(KERN_DEBUG \"ADB mouse (%s) at %d has handler 0x%X\\n\",\n\t\t       desc, id, cur_handler_id);\n\t\treg |= adbhid_input_reregister(id, default_id, org_handler_id,\n\t\t\t\t\t       cur_handler_id, mouse_kind);\n\t}\n\tadbhid_input_devcleanup(reg);\n}\n\nstatic void \ninit_trackpad(int id)\n{\n\tstruct adb_request req;\n\tunsigned char r1_buffer[8];\n\n\tadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\n\t\t    ADB_READREG(id,1));\n\tif (req.reply_len < 8)\n\t\tpr_err(\"%s: bad length for reg. 1\\n\", __func__);\n\telse\n\t{\n\t    memcpy(r1_buffer, &req.reply[1], 8);\n\n\t    adb_request(&req, NULL, ADBREQ_SYNC, 9,\n\t        ADB_WRITEREG(id,1),\n\t            r1_buffer[0],\n\t            r1_buffer[1],\n\t            r1_buffer[2],\n\t            r1_buffer[3],\n\t            r1_buffer[4],\n\t            r1_buffer[5],\n\t            0x0d,\n\t            r1_buffer[7]);\n\n            adb_request(&req, NULL, ADBREQ_SYNC, 9,\n\t        ADB_WRITEREG(id,2),\n\t    \t    0x99,\n\t    \t    0x94,\n\t    \t    0x19,\n\t    \t    0xff,\n\t    \t    0xb2,\n\t    \t    0x8a,\n\t    \t    0x1b,\n\t    \t    0x50);\n\n\t    adb_request(&req, NULL, ADBREQ_SYNC, 9,\n\t        ADB_WRITEREG(id,1),\n\t            r1_buffer[0],\n\t            r1_buffer[1],\n\t            r1_buffer[2],\n\t            r1_buffer[3],\n\t            r1_buffer[4],\n\t            r1_buffer[5],\n\t            0x03,  \n\t            r1_buffer[7]);\n\n\t     \n\t    adb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\n        }\n}\n\nstatic void \ninit_trackball(int id)\n{\n\tstruct adb_request req;\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 00,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 01,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 02,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 03,0x38);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 00,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 01,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 02,0x81);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id,1), 03,0x38);\n}\n\nstatic void\ninit_turbomouse(int id)\n{\n\tstruct adb_request req;\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(3));\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 9,\n\tADB_WRITEREG(3,2),\n\t    0xe7,\n\t    0x8c,\n\t    0,\n\t    0,\n\t    0,\n\t    0xff,\n\t    0xff,\n\t    0x94);\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(3));\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 9,\n\tADB_WRITEREG(3,2),\n\t    0xa5,\n\t    0x14,\n\t    0,\n\t    0,\n\t    0x69,\n\t    0xff,\n\t    0xff,\n\t    0x27);\n}\n\nstatic void\ninit_microspeed(int id)\n{\n\tstruct adb_request req;\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\n\n\t \n\tadb_request(&req, NULL, ADBREQ_SYNC, 5,\n\tADB_WRITEREG(id,1),\n\t    0x20,\t \n\t    0x00,\t \n\t    0x10,\t \n\t    0x07);\t \n\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\n}\n\nstatic void\ninit_ms_a3(int id)\n{\n\tstruct adb_request req;\n\n\tadb_request(&req, NULL, ADBREQ_SYNC, 3,\n\tADB_WRITEREG(id, 0x2),\n\t    0x00,\n\t    0x07);\n \n \tadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\n}\n\nstatic int __init adbhid_init(void)\n{\n#ifndef CONFIG_MAC\n\tif (!machine_is(chrp) && !machine_is(powermac))\n\t\treturn 0;\n#endif\n\n\tled_request.complete = 1;\n\n\tadbhid_probe();\n\n\tblocking_notifier_chain_register(&adb_client_list,\n\t\t\t&adbhid_adb_notifier);\n\n\treturn 0;\n}\n\nstatic void __exit adbhid_exit(void)\n{\n}\n \nmodule_init(adbhid_init);\nmodule_exit(adbhid_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}