{
  "module_name": "via-macii.c",
  "hash_id": "5ce3c04b2318da64bc584b265c9ed4390ccc94dc203332613672f7b53c7c8484",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/via-macii.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/adb.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/mac_via.h>\n\nstatic volatile unsigned char *via;\n\n \n#define RS\t\t0x200\t\t \n#define B\t\t0\t\t \n#define A\t\tRS\t\t \n#define DIRB\t\t(2*RS)\t\t \n#define DIRA\t\t(3*RS)\t\t \n#define T1CL\t\t(4*RS)\t\t \n#define T1CH\t\t(5*RS)\t\t \n#define T1LL\t\t(6*RS)\t\t \n#define T1LH\t\t(7*RS)\t\t \n#define T2CL\t\t(8*RS)\t\t \n#define T2CH\t\t(9*RS)\t\t \n#define SR\t\t(10*RS)\t\t \n#define ACR\t\t(11*RS)\t\t \n#define PCR\t\t(12*RS)\t\t \n#define IFR\t\t(13*RS)\t\t \n#define IER\t\t(14*RS)\t\t \n#define ANH\t\t(15*RS)\t\t \n\n \n#define CTLR_IRQ\t0x08\t\t \n#define ST_MASK\t\t0x30\t\t \n\n \n#define SR_CTRL\t\t0x1c\t\t \n#define SR_EXT\t\t0x0c\t\t \n#define SR_OUT\t\t0x10\t\t \n\n \n#define IER_SET\t\t0x80\t\t \n#define IER_CLR\t\t0\t\t \n#define SR_INT\t\t0x04\t\t \n\n \n#define ST_CMD\t\t0x00\t\t \n#define ST_EVEN\t\t0x10\t\t \n#define ST_ODD\t\t0x20\t\t \n#define ST_IDLE\t\t0x30\t\t \n\n \n#define ADDR_MASK\t0xF0\n#define CMD_MASK\t0x0F\n#define OP_MASK\t\t0x0C\n#define TALK\t\t0x0C\n\nstatic int macii_init_via(void);\nstatic void macii_start(void);\nstatic irqreturn_t macii_interrupt(int irq, void *arg);\nstatic void macii_queue_poll(void);\n\nstatic int macii_probe(void);\nstatic int macii_init(void);\nstatic int macii_send_request(struct adb_request *req, int sync);\nstatic int macii_write(struct adb_request *req);\nstatic int macii_autopoll(int devs);\nstatic void macii_poll(void);\nstatic int macii_reset_bus(void);\n\nstruct adb_driver via_macii_driver = {\n\t.name         = \"Mac II\",\n\t.probe        = macii_probe,\n\t.init         = macii_init,\n\t.send_request = macii_send_request,\n\t.autopoll     = macii_autopoll,\n\t.poll         = macii_poll,\n\t.reset_bus    = macii_reset_bus,\n};\n\nstatic enum macii_state {\n\tidle,\n\tsending,\n\treading,\n} macii_state;\n\nstatic struct adb_request *current_req;  \nstatic struct adb_request *last_req;      \nstatic unsigned char reply_buf[16];         \nstatic unsigned char *reply_ptr;      \nstatic bool reading_reply;        \nstatic int data_index;       \nstatic int reply_len;  \nstatic int status;           \nstatic bool bus_timeout;                    \nstatic bool srq_asserted;     \nstatic u8 last_cmd;               \nstatic u8 last_talk_cmd;     \nstatic u8 last_poll_cmd;  \nstatic unsigned int autopoll_devs;   \n\n \nstatic int macii_probe(void)\n{\n\tif (macintosh_config->adb_type != MAC_ADB_II)\n\t\treturn -ENODEV;\n\n\tvia = via1;\n\n\tpr_info(\"adb: Mac II ADB Driver v1.0 for Unified ADB\\n\");\n\treturn 0;\n}\n\n \nstatic int macii_init(void)\n{\n\tunsigned long flags;\n\tint err;\n\n\tlocal_irq_save(flags);\n\n\terr = macii_init_via();\n\tif (err)\n\t\tgoto out;\n\n\terr = request_irq(IRQ_MAC_ADB, macii_interrupt, 0, \"ADB\",\n\t\t\t  macii_interrupt);\n\tif (err)\n\t\tgoto out;\n\n\tmacii_state = idle;\nout:\n\tlocal_irq_restore(flags);\n\treturn err;\n}\n\n \nstatic int macii_init_via(void)\n{\n\tunsigned char x;\n\n\t \n\tvia[DIRB] = (via[DIRB] | ST_EVEN | ST_ODD) & ~CTLR_IRQ;\n\n\t \n\tvia[B] |= ST_IDLE;\n\n\t \n\tvia[ACR] = (via[ACR] & ~SR_CTRL) | SR_EXT;\n\n\t \n\tx = via[SR];\n\n\treturn 0;\n}\n\n \nstatic void macii_queue_poll(void)\n{\n\tstatic struct adb_request req;\n\tunsigned char poll_command;\n\tunsigned int poll_addr;\n\n\t \n\tif (!autopoll_devs)\n\t\treturn;\n\n\t \n\tpoll_addr = (last_poll_cmd & ADDR_MASK) >> 4;\n\tif ((srq_asserted && last_cmd == last_poll_cmd) ||\n\t    !(autopoll_devs & (1 << poll_addr))) {\n\t\tunsigned int higher_devs;\n\n\t\thigher_devs = autopoll_devs & -(1 << (poll_addr + 1));\n\t\tpoll_addr = ffs(higher_devs ? higher_devs : autopoll_devs) - 1;\n\t}\n\n\t \n\tpoll_command = ADB_READREG(poll_addr, 0);\n\n\t \n\tif (poll_command == last_cmd)\n\t\treturn;\n\n\tadb_request(&req, NULL, ADBREQ_NOSEND, 1, poll_command);\n\n\treq.sent = 0;\n\treq.complete = 0;\n\treq.reply_len = 0;\n\treq.next = current_req;\n\n\tif (WARN_ON(current_req)) {\n\t\tcurrent_req = &req;\n\t} else {\n\t\tcurrent_req = &req;\n\t\tlast_req = &req;\n\t}\n}\n\n \nstatic int macii_send_request(struct adb_request *req, int sync)\n{\n\tint err;\n\n\terr = macii_write(req);\n\tif (err)\n\t\treturn err;\n\n\tif (sync)\n\t\twhile (!req->complete)\n\t\t\tmacii_poll();\n\n\treturn 0;\n}\n\n \nstatic int macii_write(struct adb_request *req)\n{\n\tunsigned long flags;\n\n\tif (req->nbytes < 2 || req->data[0] != ADB_PACKET || req->nbytes > 15) {\n\t\treq->complete = 1;\n\t\treturn -EINVAL;\n\t}\n\n\treq->next = NULL;\n\treq->sent = 0;\n\treq->complete = 0;\n\treq->reply_len = 0;\n\n\tlocal_irq_save(flags);\n\n\tif (current_req != NULL) {\n\t\tlast_req->next = req;\n\t\tlast_req = req;\n\t} else {\n\t\tcurrent_req = req;\n\t\tlast_req = req;\n\t\tif (macii_state == idle)\n\t\t\tmacii_start();\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n \nstatic int macii_autopoll(int devs)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\t \n\tautopoll_devs = (unsigned int)devs & 0xFFFE;\n\n\tif (!current_req) {\n\t\tmacii_queue_poll();\n\t\tif (current_req && macii_state == idle)\n\t\t\tmacii_start();\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n \nstatic void macii_poll(void)\n{\n\tmacii_interrupt(0, NULL);\n}\n\n \nstatic int macii_reset_bus(void)\n{\n\tstruct adb_request req;\n\n\t \n\tadb_request(&req, NULL, ADBREQ_NOSEND, 1, ADB_BUSRESET);\n\tmacii_send_request(&req, 1);\n\n\t \n\tudelay(3000);\n\n\treturn 0;\n}\n\n \nstatic void macii_start(void)\n{\n\tstruct adb_request *req;\n\n\treq = current_req;\n\n\t \n\n\t \n\tvia[ACR] |= SR_OUT;\n\t \n\tvia[SR] = req->data[1];\n\t \n\tvia[B] = (via[B] & ~ST_MASK) | ST_CMD;\n\n\tmacii_state = sending;\n\tdata_index = 2;\n\n\tbus_timeout = false;\n\tsrq_asserted = false;\n}\n\n \nstatic irqreturn_t macii_interrupt(int irq, void *arg)\n{\n\tint x;\n\tstruct adb_request *req;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!arg) {\n\t\t \n\t\tif (via[IFR] & SR_INT)\n\t\t\tvia[IFR] = SR_INT;\n\t\telse {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\n\tstatus = via[B] & (ST_MASK | CTLR_IRQ);\n\n\tswitch (macii_state) {\n\tcase idle:\n\t\tWARN_ON((status & ST_MASK) != ST_IDLE);\n\n\t\treply_ptr = reply_buf;\n\t\treading_reply = false;\n\n\t\tbus_timeout = false;\n\t\tsrq_asserted = false;\n\n\t\tx = via[SR];\n\n\t\tif (!(status & CTLR_IRQ)) {\n\t\t\t \n\t\t\tmacii_state = reading;\n\t\t\t*reply_ptr = x;\n\t\t\treply_len = 1;\n\t\t} else {\n\t\t\t \n\t\t\treply_len = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvia[B] = (via[B] & ~ST_MASK) | ST_EVEN;\n\t\tbreak;\n\n\tcase sending:\n\t\treq = current_req;\n\n\t\tif (status == (ST_CMD | CTLR_IRQ)) {\n\t\t\t \n\n\t\t\t \n\t\t\tlast_cmd = req->data[1];\n\t\t\tif ((last_cmd & OP_MASK) == TALK) {\n\t\t\t\tlast_talk_cmd = last_cmd;\n\t\t\t\tif ((last_cmd & CMD_MASK) == ADB_READREG(0, 0))\n\t\t\t\t\tlast_poll_cmd = last_cmd;\n\t\t\t}\n\t\t}\n\n\t\tif (status == ST_CMD) {\n\t\t\t \n\t\t\tmacii_state = reading;\n\n\t\t\treading_reply = false;\n\t\t\treply_ptr = reply_buf;\n\t\t\t*reply_ptr = last_talk_cmd;\n\t\t\treply_len = 1;\n\n\t\t\t \n\t\t\tvia[ACR] &= ~SR_OUT;\n\t\t\tx = via[SR];\n\t\t} else if (data_index >= req->nbytes) {\n\t\t\treq->sent = 1;\n\n\t\t\tif (req->reply_expected) {\n\t\t\t\tmacii_state = reading;\n\n\t\t\t\treading_reply = true;\n\t\t\t\treply_ptr = req->reply;\n\t\t\t\t*reply_ptr = req->data[1];\n\t\t\t\treply_len = 1;\n\n\t\t\t\tvia[ACR] &= ~SR_OUT;\n\t\t\t\tx = via[SR];\n\t\t\t} else if ((req->data[1] & OP_MASK) == TALK) {\n\t\t\t\tmacii_state = reading;\n\n\t\t\t\treading_reply = false;\n\t\t\t\treply_ptr = reply_buf;\n\t\t\t\t*reply_ptr = req->data[1];\n\t\t\t\treply_len = 1;\n\n\t\t\t\tvia[ACR] &= ~SR_OUT;\n\t\t\t\tx = via[SR];\n\n\t\t\t\treq->complete = 1;\n\t\t\t\tcurrent_req = req->next;\n\t\t\t\tif (req->done)\n\t\t\t\t\t(*req->done)(req);\n\t\t\t} else {\n\t\t\t\tmacii_state = idle;\n\n\t\t\t\treq->complete = 1;\n\t\t\t\tcurrent_req = req->next;\n\t\t\t\tif (req->done)\n\t\t\t\t\t(*req->done)(req);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tvia[SR] = req->data[data_index++];\n\t\t}\n\n\t\tif ((via[B] & ST_MASK) == ST_CMD) {\n\t\t\t \n\t\t\tvia[B] = (via[B] & ~ST_MASK) | ST_EVEN;\n\t\t} else {\n\t\t\t \n\t\t\tvia[B] ^= ST_MASK;\n\t\t}\n\t\tbreak;\n\n\tcase reading:\n\t\tx = via[SR];\n\t\tWARN_ON((status & ST_MASK) == ST_CMD ||\n\t\t\t(status & ST_MASK) == ST_IDLE);\n\n\t\tif (!(status & CTLR_IRQ)) {\n\t\t\tif (status == ST_EVEN && reply_len == 1) {\n\t\t\t\tbus_timeout = true;\n\t\t\t} else if (status == ST_ODD && reply_len == 2) {\n\t\t\t\tsrq_asserted = true;\n\t\t\t} else {\n\t\t\t\tmacii_state = idle;\n\n\t\t\t\tif (bus_timeout)\n\t\t\t\t\treply_len = 0;\n\n\t\t\t\tif (reading_reply) {\n\t\t\t\t\tstruct adb_request *req = current_req;\n\n\t\t\t\t\treq->reply_len = reply_len;\n\n\t\t\t\t\treq->complete = 1;\n\t\t\t\t\tcurrent_req = req->next;\n\t\t\t\t\tif (req->done)\n\t\t\t\t\t\t(*req->done)(req);\n\t\t\t\t} else if (reply_len && autopoll_devs &&\n\t\t\t\t\t   reply_buf[0] == last_poll_cmd) {\n\t\t\t\t\tadb_input(reply_buf, reply_len, 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (reply_len < ARRAY_SIZE(reply_buf)) {\n\t\t\treply_ptr++;\n\t\t\t*reply_ptr = x;\n\t\t\treply_len++;\n\t\t}\n\n\t\t \n\t\tvia[B] ^= ST_MASK;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (macii_state == idle) {\n\t\tif (!current_req)\n\t\t\tmacii_queue_poll();\n\n\t\tif (current_req)\n\t\t\tmacii_start();\n\n\t\tif (macii_state == idle) {\n\t\t\tvia[ACR] &= ~SR_OUT;\n\t\t\tx = via[SR];\n\t\t\tvia[B] = (via[B] & ~ST_MASK) | ST_IDLE;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}