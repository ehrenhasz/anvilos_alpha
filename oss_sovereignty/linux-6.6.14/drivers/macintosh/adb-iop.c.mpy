{
  "module_name": "adb-iop.c",
  "hash_id": "6574e10c13734bae373bbed7d0be034ca2a30bca30c0b7544744120887abed22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/adb-iop.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n\n#include <asm/macintosh.h>\n#include <asm/macints.h>\n#include <asm/mac_iop.h>\n#include <asm/adb_iop.h>\n#include <asm/unaligned.h>\n\n#include <linux/adb.h>\n\nstatic struct adb_request *current_req;\nstatic struct adb_request *last_req;\nstatic unsigned int autopoll_devs;\nstatic u8 autopoll_addr;\n\nstatic enum adb_iop_state {\n\tidle,\n\tsending,\n\tawaiting_reply\n} adb_iop_state;\n\nstatic void adb_iop_start(void);\nstatic int adb_iop_probe(void);\nstatic int adb_iop_init(void);\nstatic int adb_iop_send_request(struct adb_request *, int);\nstatic int adb_iop_write(struct adb_request *);\nstatic int adb_iop_autopoll(int);\nstatic void adb_iop_poll(void);\nstatic int adb_iop_reset_bus(void);\n\n \n#define ADDR_MASK       0xF0\n#define OP_MASK         0x0C\n#define TALK            0x0C\n\nstruct adb_driver adb_iop_driver = {\n\t.name         = \"ISM IOP\",\n\t.probe        = adb_iop_probe,\n\t.init         = adb_iop_init,\n\t.send_request = adb_iop_send_request,\n\t.autopoll     = adb_iop_autopoll,\n\t.poll         = adb_iop_poll,\n\t.reset_bus    = adb_iop_reset_bus\n};\n\nstatic void adb_iop_done(void)\n{\n\tstruct adb_request *req = current_req;\n\n\tadb_iop_state = idle;\n\n\treq->complete = 1;\n\tcurrent_req = req->next;\n\tif (req->done)\n\t\t(*req->done)(req);\n\n\tif (adb_iop_state == idle)\n\t\tadb_iop_start();\n}\n\n \n\nstatic void adb_iop_complete(struct iop_msg *msg)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tadb_iop_state = awaiting_reply;\n\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic void adb_iop_listen(struct iop_msg *msg)\n{\n\tstruct adb_iopmsg *amsg = (struct adb_iopmsg *)msg->message;\n\tu8 addr = (amsg->cmd & ADDR_MASK) >> 4;\n\tu8 op = amsg->cmd & OP_MASK;\n\tunsigned long flags;\n\tbool req_done = false;\n\n\tlocal_irq_save(flags);\n\n\t \n\tif (op == TALK && ((1 << addr) & autopoll_devs))\n\t\tautopoll_addr = addr;\n\n\tswitch (amsg->flags & (ADB_IOP_EXPLICIT |\n\t\t\t       ADB_IOP_AUTOPOLL |\n\t\t\t       ADB_IOP_TIMEOUT)) {\n\tcase ADB_IOP_EXPLICIT:\n\tcase ADB_IOP_EXPLICIT | ADB_IOP_TIMEOUT:\n\t\tif (adb_iop_state == awaiting_reply) {\n\t\t\tstruct adb_request *req = current_req;\n\n\t\t\tif (req->reply_expected) {\n\t\t\t\treq->reply_len = amsg->count + 1;\n\t\t\t\tmemcpy(req->reply, &amsg->cmd, req->reply_len);\n\t\t\t}\n\n\t\t\treq_done = true;\n\t\t}\n\t\tbreak;\n\tcase ADB_IOP_AUTOPOLL:\n\t\tif (((1 << addr) & autopoll_devs) &&\n\t\t    amsg->cmd == ADB_READREG(addr, 0))\n\t\t\tadb_input(&amsg->cmd, amsg->count + 1, 1);\n\t\tbreak;\n\t}\n\tmsg->reply[0] = autopoll_addr ? ADB_IOP_AUTOPOLL : 0;\n\tmsg->reply[1] = 0;\n\tmsg->reply[2] = autopoll_addr ? ADB_READREG(autopoll_addr, 0) : 0;\n\tiop_complete_message(msg);\n\n\tif (req_done)\n\t\tadb_iop_done();\n\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic void adb_iop_start(void)\n{\n\tstruct adb_request *req;\n\tstruct adb_iopmsg amsg;\n\n\t \n\treq = current_req;\n\tif (!req)\n\t\treturn;\n\n\t \n\tamsg.flags = ADB_IOP_EXPLICIT;\n\tamsg.count = req->nbytes - 2;\n\n\t \n\tmemcpy(&amsg.cmd, req->data + 1, req->nbytes - 1);\n\n\treq->sent = 1;\n\tadb_iop_state = sending;\n\n\t \n\tiop_send_message(ADB_IOP, ADB_CHAN, req, sizeof(amsg), (__u8 *)&amsg,\n\t\t\t adb_iop_complete);\n}\n\nstatic int adb_iop_probe(void)\n{\n\tif (!iop_ism_present)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int adb_iop_init(void)\n{\n\tpr_info(\"adb: IOP ISM driver v0.4 for Unified ADB\\n\");\n\tiop_listen(ADB_IOP, ADB_CHAN, adb_iop_listen, \"ADB\");\n\treturn 0;\n}\n\nstatic int adb_iop_send_request(struct adb_request *req, int sync)\n{\n\tint err;\n\n\terr = adb_iop_write(req);\n\tif (err)\n\t\treturn err;\n\n\tif (sync) {\n\t\twhile (!req->complete)\n\t\t\tadb_iop_poll();\n\t}\n\treturn 0;\n}\n\nstatic int adb_iop_write(struct adb_request *req)\n{\n\tunsigned long flags;\n\n\tif ((req->nbytes < 2) || (req->data[0] != ADB_PACKET)) {\n\t\treq->complete = 1;\n\t\treturn -EINVAL;\n\t}\n\n\treq->next = NULL;\n\treq->sent = 0;\n\treq->complete = 0;\n\treq->reply_len = 0;\n\n\tlocal_irq_save(flags);\n\n\tif (current_req) {\n\t\tlast_req->next = req;\n\t\tlast_req = req;\n\t} else {\n\t\tcurrent_req = req;\n\t\tlast_req = req;\n\t}\n\n\tif (adb_iop_state == idle)\n\t\tadb_iop_start();\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic void adb_iop_set_ap_complete(struct iop_msg *msg)\n{\n\tstruct adb_iopmsg *amsg = (struct adb_iopmsg *)msg->message;\n\n\tautopoll_devs = get_unaligned_be16(amsg->data);\n\tif (autopoll_devs & (1 << autopoll_addr))\n\t\treturn;\n\tautopoll_addr = autopoll_devs ? (ffs(autopoll_devs) - 1) : 0;\n}\n\nstatic int adb_iop_autopoll(int devs)\n{\n\tstruct adb_iopmsg amsg;\n\tunsigned long flags;\n\tunsigned int mask = (unsigned int)devs & 0xFFFE;\n\n\tlocal_irq_save(flags);\n\n\tamsg.flags = ADB_IOP_SET_AUTOPOLL | (mask ? ADB_IOP_AUTOPOLL : 0);\n\tamsg.count = 2;\n\tamsg.cmd = 0;\n\tput_unaligned_be16(mask, amsg.data);\n\n\tiop_send_message(ADB_IOP, ADB_CHAN, NULL, sizeof(amsg), (__u8 *)&amsg,\n\t\t\t adb_iop_set_ap_complete);\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic void adb_iop_poll(void)\n{\n\tiop_ism_irq_poll(ADB_IOP);\n}\n\nstatic int adb_iop_reset_bus(void)\n{\n\tstruct adb_request req;\n\n\t \n\tadb_request(&req, NULL, ADBREQ_NOSEND, 1, ADB_BUSRESET);\n\tadb_iop_send_request(&req, 1);\n\n\t \n\tmdelay(3);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}