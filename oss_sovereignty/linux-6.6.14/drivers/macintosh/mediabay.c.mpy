{
  "module_name": "mediabay.c",
  "hash_id": "d7e3538c1e53f88c1516ab68785a0b26e4c5d28b208330652b7a9495f699528c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/mediabay.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/stddef.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/pgtable.h>\n\n#include <asm/io.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/mediabay.h>\n#include <asm/sections.h>\n#include <asm/ohare.h>\n#include <asm/heathrow.h>\n#include <asm/keylargo.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n\n#define MB_FCR32(bay, r)\t((bay)->base + ((r) >> 2))\n#define MB_FCR8(bay, r)\t\t(((volatile u8 __iomem *)((bay)->base)) + (r))\n\n#define MB_IN32(bay,r)\t\t(in_le32(MB_FCR32(bay,r)))\n#define MB_OUT32(bay,r,v)\t(out_le32(MB_FCR32(bay,r), (v)))\n#define MB_BIS(bay,r,v)\t\t(MB_OUT32((bay), (r), MB_IN32((bay), r) | (v)))\n#define MB_BIC(bay,r,v)\t\t(MB_OUT32((bay), (r), MB_IN32((bay), r) & ~(v)))\n#define MB_IN8(bay,r)\t\t(in_8(MB_FCR8(bay,r)))\n#define MB_OUT8(bay,r,v)\t(out_8(MB_FCR8(bay,r), (v)))\n\nstruct media_bay_info;\n\nstruct mb_ops {\n\tchar*\tname;\n\tvoid\t(*init)(struct media_bay_info *bay);\n\tu8\t(*content)(struct media_bay_info *bay);\n\tvoid\t(*power)(struct media_bay_info *bay, int on_off);\n\tint\t(*setup_bus)(struct media_bay_info *bay, u8 device_id);\n\tvoid\t(*un_reset)(struct media_bay_info *bay);\n\tvoid\t(*un_reset_ide)(struct media_bay_info *bay);\n};\n\nstruct media_bay_info {\n\tu32 __iomem\t\t\t*base;\n\tint\t\t\t\tcontent_id;\n\tint\t\t\t\tstate;\n\tint\t\t\t\tlast_value;\n\tint\t\t\t\tvalue_count;\n\tint\t\t\t\ttimer;\n\tstruct macio_dev\t\t*mdev;\n\tconst struct mb_ops*\t\tops;\n\tint\t\t\t\tindex;\n\tint\t\t\t\tcached_gpio;\n\tint\t\t\t\tsleeping;\n\tint\t\t\t\tuser_lock;\n\tstruct mutex\t\t\tlock;\n};\n\n#define MAX_BAYS\t2\n\nstatic struct media_bay_info media_bays[MAX_BAYS];\nstatic int media_bay_count = 0;\n\n \n#define MB_POLL_DELAY\t25\n\n \n#define MB_STABLE_DELAY\t100\n\n \n#define MB_POWER_DELAY\t200\n\n \n#define MB_RESET_DELAY\t50\n\n \n#define MB_SETUP_DELAY\t100\n\n \n#define MB_IDE_WAIT\t1000\n\n \nenum {\n\tmb_empty = 0,\t\t \n\tmb_powering_up,\t\t \n\tmb_enabling_bay,\t \n\tmb_resetting,\t\t \n\tmb_ide_resetting,\t \n\tmb_up,\t\t\t \n\tmb_powering_down\t \n};\n\n#define MB_POWER_SOUND\t\t0x08\n#define MB_POWER_FLOPPY\t\t0x04\n#define MB_POWER_ATA\t\t0x02\n#define MB_POWER_PCI\t\t0x01\n#define MB_POWER_OFF\t\t0x00\n\n \n \nstatic u8\nohare_mb_content(struct media_bay_info *bay)\n{\n\treturn (MB_IN32(bay, OHARE_MBCR) >> 12) & 7;\n}\n\nstatic u8\nheathrow_mb_content(struct media_bay_info *bay)\n{\n\treturn (MB_IN32(bay, HEATHROW_MBCR) >> 12) & 7;\n}\n\nstatic u8\nkeylargo_mb_content(struct media_bay_info *bay)\n{\n\tint new_gpio;\n\n\tnew_gpio = MB_IN8(bay, KL_GPIO_MEDIABAY_IRQ) & KEYLARGO_GPIO_INPUT_DATA;\n\tif (new_gpio) {\n\t\tbay->cached_gpio = new_gpio;\n\t\treturn MB_NO;\n\t} else if (bay->cached_gpio != new_gpio) {\n\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_ENABLE);\n\t\t(void)MB_IN32(bay, KEYLARGO_MBCR);\n\t\tudelay(5);\n\t\tMB_BIC(bay, KEYLARGO_MBCR, 0x0000000F);\n\t\t(void)MB_IN32(bay, KEYLARGO_MBCR);\n\t\tudelay(5);\n\t\tbay->cached_gpio = new_gpio;\n\t}\n\treturn (MB_IN32(bay, KEYLARGO_MBCR) >> 4) & 7;\n}\n\n \n\nstatic void\nohare_mb_power(struct media_bay_info* bay, int on_off)\n{\n\tif (on_off) {\n\t\t \n\t\tMB_BIC(bay, OHARE_FCR, OH_BAY_RESET_N);\n\t\tMB_BIC(bay, OHARE_FCR, OH_BAY_POWER_N);\n\t} else {\n\t\t \n\t\tMB_BIC(bay, OHARE_FCR, OH_BAY_DEV_MASK);\n\t\tMB_BIC(bay, OHARE_FCR, OH_FLOPPY_ENABLE);\n\t\t \n\t\tMB_BIS(bay, OHARE_FCR, OH_BAY_POWER_N);\n\t\tMB_BIS(bay, OHARE_FCR, OH_BAY_RESET_N);\n\t\tMB_BIS(bay, OHARE_FCR, OH_IDE1_RESET_N);\n\t}\n\tMB_BIC(bay, OHARE_MBCR, 0x00000F00);\n}\n\nstatic void\nheathrow_mb_power(struct media_bay_info* bay, int on_off)\n{\n\tif (on_off) {\n\t\t \n\t\tMB_BIC(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\n\t\tMB_BIC(bay, HEATHROW_FCR, HRW_BAY_POWER_N);\n\t} else {\n\t\t \n\t\tMB_BIC(bay, HEATHROW_FCR, HRW_BAY_DEV_MASK);\n\t\tMB_BIC(bay, HEATHROW_FCR, HRW_SWIM_ENABLE);\n\t\t \n\t\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_POWER_N);\n\t\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\n\t\tMB_BIS(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\n\t}\n\tMB_BIC(bay, HEATHROW_MBCR, 0x00000F00);\n}\n\nstatic void\nkeylargo_mb_power(struct media_bay_info* bay, int on_off)\n{\n\tif (on_off) {\n\t\t \n            \tMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\n            \tMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_POWER);\n\t} else {\n\t\t \n\t\tMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_MASK);\n\t\tMB_BIC(bay, KEYLARGO_FCR1, KL1_EIDE0_ENABLE);\n\t\t \n\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_POWER);\n\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\n\t\tMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\n\t}\n\tMB_BIC(bay, KEYLARGO_MBCR, 0x0000000F);\n}\n\n \n\nstatic int\nohare_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\n{\n\tswitch(device_id) {\n\t\tcase MB_FD:\n\t\tcase MB_FD1:\n\t\t\tMB_BIS(bay, OHARE_FCR, OH_BAY_FLOPPY_ENABLE);\n\t\t\tMB_BIS(bay, OHARE_FCR, OH_FLOPPY_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_CD:\n\t\t\tMB_BIC(bay, OHARE_FCR, OH_IDE1_RESET_N);\n\t\t\tMB_BIS(bay, OHARE_FCR, OH_BAY_IDE_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_PCI:\n\t\t\tMB_BIS(bay, OHARE_FCR, OH_BAY_PCI_ENABLE);\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int\nheathrow_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\n{\n\tswitch(device_id) {\n\t\tcase MB_FD:\n\t\tcase MB_FD1:\n\t\t\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_FLOPPY_ENABLE);\n\t\t\tMB_BIS(bay, HEATHROW_FCR, HRW_SWIM_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_CD:\n\t\t\tMB_BIC(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\n\t\t\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_IDE_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_PCI:\n\t\t\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_PCI_ENABLE);\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int\nkeylargo_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\n{\n\tswitch(device_id) {\n\t\tcase MB_CD:\n\t\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_IDE_ENABLE);\n\t\t\tMB_BIC(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\n\t\t\tMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_PCI:\n\t\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_PCI_ENABLE);\n\t\t\treturn 0;\n\t\tcase MB_SOUND:\n\t\t\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_SOUND_ENABLE);\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n \n\nstatic void\nohare_mb_un_reset(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, OHARE_FCR, OH_BAY_RESET_N);\n}\n\nstatic void keylargo_mb_init(struct media_bay_info *bay)\n{\n\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_ENABLE);\n}\n\nstatic void heathrow_mb_un_reset(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\n}\n\nstatic void keylargo_mb_un_reset(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\n}\n\nstatic void ohare_mb_un_reset_ide(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, OHARE_FCR, OH_IDE1_RESET_N);\n}\n\nstatic void heathrow_mb_un_reset_ide(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\n}\n\nstatic void keylargo_mb_un_reset_ide(struct media_bay_info* bay)\n{\n\tMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\n}\n\nstatic inline void set_mb_power(struct media_bay_info* bay, int onoff)\n{\n\t \n\tif (onoff) {\n\t\tbay->ops->power(bay, 1);\n\t\tbay->state = mb_powering_up;\n\t\tpr_debug(\"mediabay%d: powering up\\n\", bay->index);\n\t} else { \n\t\t \n\t\tbay->ops->power(bay, 0);\n\t\tbay->state = mb_powering_down;\n\t\tpr_debug(\"mediabay%d: powering down\\n\", bay->index);\n\t}\n\tbay->timer = msecs_to_jiffies(MB_POWER_DELAY);\n}\n\nstatic void poll_media_bay(struct media_bay_info* bay)\n{\n\tint id = bay->ops->content(bay);\n\n\tstatic char *mb_content_types[] = {\n\t\t\"a floppy drive\",\n\t\t\"a floppy drive\",\n\t\t\"an unsupported audio device\",\n\t\t\"an ATA device\",\n\t\t\"an unsupported PCI device\",\n\t\t\"an unknown device\",\n\t};\n\n\tif (id != bay->last_value) {\n\t\tbay->last_value = id;\n\t\tbay->value_count = 0;\n\t\treturn;\n\t}\n\tif (id == bay->content_id)\n\t\treturn;\n\n\tbay->value_count += msecs_to_jiffies(MB_POLL_DELAY);\n\tif (bay->value_count >= msecs_to_jiffies(MB_STABLE_DELAY)) {\n\t\t \n\t\tif ((id != MB_NO) && (bay->content_id != MB_NO)) {\n\t\t\tid = MB_NO;\n\t\t\tpr_debug(\"mediabay%d: forcing MB_NO\\n\", bay->index);\n\t\t}\n\t\tpr_debug(\"mediabay%d: switching to %d\\n\", bay->index, id);\n\t\tset_mb_power(bay, id != MB_NO);\n\t\tbay->content_id = id;\n\t\tif (id >= MB_NO || id < 0)\n\t\t\tprintk(KERN_INFO \"mediabay%d: Bay is now empty\\n\", bay->index);\n\t\telse\n\t\t\tprintk(KERN_INFO \"mediabay%d: Bay contains %s\\n\",\n\t\t\t       bay->index, mb_content_types[id]);\n\t}\n}\n\nint check_media_bay(struct macio_dev *baydev)\n{\n\tstruct media_bay_info* bay;\n\tint id;\n\n\tif (baydev == NULL)\n\t\treturn MB_NO;\n\n\t \n\tbay = macio_get_drvdata(baydev);\n\tif (bay == NULL)\n\t\treturn MB_NO;\n\tid = bay->content_id;\n\tif (bay->state != mb_up)\n\t\treturn MB_NO;\n\tif (id == MB_FD1)\n\t\treturn MB_FD;\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(check_media_bay);\n\nvoid lock_media_bay(struct macio_dev *baydev)\n{\n\tstruct media_bay_info* bay;\n\n\tif (baydev == NULL)\n\t\treturn;\n\tbay = macio_get_drvdata(baydev);\n\tif (bay == NULL)\n\t\treturn;\n\tmutex_lock(&bay->lock);\n\tbay->user_lock = 1;\n}\nEXPORT_SYMBOL_GPL(lock_media_bay);\n\nvoid unlock_media_bay(struct macio_dev *baydev)\n{\n\tstruct media_bay_info* bay;\n\n\tif (baydev == NULL)\n\t\treturn;\n\tbay = macio_get_drvdata(baydev);\n\tif (bay == NULL)\n\t\treturn;\n\tif (bay->user_lock) {\n\t\tbay->user_lock = 0;\n\t\tmutex_unlock(&bay->lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(unlock_media_bay);\n\nstatic int mb_broadcast_hotplug(struct device *dev, void *data)\n{\n\tstruct media_bay_info* bay = data;\n\tstruct macio_dev *mdev;\n\tstruct macio_driver *drv;\n\tint state;\n\n\tif (dev->bus != &macio_bus_type)\n\t\treturn 0;\n\n\tstate = bay->state == mb_up ? bay->content_id : MB_NO;\n\tif (state == MB_FD1)\n\t\tstate = MB_FD;\n\tmdev = to_macio_device(dev);\n\tdrv = to_macio_driver(dev->driver);\n\tif (dev->driver && drv->mediabay_event)\n\t\tdrv->mediabay_event(mdev, state);\n\treturn 0;\n}\n\nstatic void media_bay_step(int i)\n{\n\tstruct media_bay_info* bay = &media_bays[i];\n\n\t \n\tif (bay->state != mb_powering_down)\n\t    poll_media_bay(bay);\n\n\t \n\tif (bay->timer != 0) {\n\t\tbay->timer -= msecs_to_jiffies(MB_POLL_DELAY);\n\t\tif (bay->timer > 0)\n\t\t\treturn;\n\t\tbay->timer = 0;\n\t}\n\n\tswitch(bay->state) {\n\tcase mb_powering_up:\n\t    \tif (bay->ops->setup_bus(bay, bay->last_value) < 0) {\n\t\t\tpr_debug(\"mediabay%d: device not supported (kind:%d)\\n\",\n\t\t\t\t i, bay->content_id);\n\t    \t\tset_mb_power(bay, 0);\n\t    \t\tbreak;\n\t    \t}\n\t    \tbay->timer = msecs_to_jiffies(MB_RESET_DELAY);\n\t    \tbay->state = mb_enabling_bay;\n\t\tpr_debug(\"mediabay%d: enabling (kind:%d)\\n\", i, bay->content_id);\n\t\tbreak;\n\tcase mb_enabling_bay:\n\t\tbay->ops->un_reset(bay);\n\t    \tbay->timer = msecs_to_jiffies(MB_SETUP_DELAY);\n\t    \tbay->state = mb_resetting;\n\t\tpr_debug(\"mediabay%d: releasing bay reset (kind:%d)\\n\",\n\t\t\t i, bay->content_id);\n\t    \tbreak;\n\tcase mb_resetting:\n\t\tif (bay->content_id != MB_CD) {\n\t\t\tpr_debug(\"mediabay%d: bay is up (kind:%d)\\n\", i,\n\t\t\t\t bay->content_id);\n\t\t\tbay->state = mb_up;\n\t\t\tdevice_for_each_child(&bay->mdev->ofdev.dev,\n\t\t\t\t\t      bay, mb_broadcast_hotplug);\n\t\t\tbreak;\n\t    \t}\n\t\tpr_debug(\"mediabay%d: releasing ATA reset (kind:%d)\\n\",\n\t\t\t i, bay->content_id);\n\t\tbay->ops->un_reset_ide(bay);\n\t    \tbay->timer = msecs_to_jiffies(MB_IDE_WAIT);\n\t    \tbay->state = mb_ide_resetting;\n\t    \tbreak;\n\n\tcase mb_ide_resetting:\n\t\tpr_debug(\"mediabay%d: bay is up (kind:%d)\\n\", i, bay->content_id);\n\t\tbay->state = mb_up;\n\t\tdevice_for_each_child(&bay->mdev->ofdev.dev,\n\t\t\t\t      bay, mb_broadcast_hotplug);\n\t    \tbreak;\n\n\tcase mb_powering_down:\n\t    \tbay->state = mb_empty;\n\t\tdevice_for_each_child(&bay->mdev->ofdev.dev,\n\t\t\t\t      bay, mb_broadcast_hotplug);\n\t\tpr_debug(\"mediabay%d: end of power down\\n\", i);\n\t    \tbreak;\n\t}\n}\n\n \nstatic int media_bay_task(void *x)\n{\n\tint\ti;\n\n\twhile (!kthread_should_stop()) {\n\t\tfor (i = 0; i < media_bay_count; ++i) {\n\t\t\tmutex_lock(&media_bays[i].lock);\n\t\t\tif (!media_bays[i].sleeping)\n\t\t\t\tmedia_bay_step(i);\n\t\t\tmutex_unlock(&media_bays[i].lock);\n\t\t}\n\n\t\tmsleep_interruptible(MB_POLL_DELAY);\n\t}\n\treturn 0;\n}\n\nstatic int media_bay_attach(struct macio_dev *mdev,\n\t\t\t    const struct of_device_id *match)\n{\n\tstruct media_bay_info* bay;\n\tu32 __iomem *regbase;\n\tstruct device_node *ofnode;\n\tunsigned long base;\n\tint i;\n\n\tofnode = mdev->ofdev.dev.of_node;\n\n\tif (macio_resource_count(mdev) < 1)\n\t\treturn -ENODEV;\n\tif (macio_request_resources(mdev, \"media-bay\"))\n\t\treturn -EBUSY;\n\t \n\tbase = macio_resource_start(mdev, 0) & 0xffff0000u;\n\tregbase = (u32 __iomem *)ioremap(base, 0x100);\n\tif (regbase == NULL) {\n\t\tmacio_release_resources(mdev);\n\t\treturn -ENOMEM;\n\t}\n\t\n\ti = media_bay_count++;\n\tbay = &media_bays[i];\n\tbay->mdev = mdev;\n\tbay->base = regbase;\n\tbay->index = i;\n\tbay->ops = match->data;\n\tbay->sleeping = 0;\n\tmutex_init(&bay->lock);\n\n\t \n\tif (bay->ops->init)\n\t\tbay->ops->init(bay);\n\n\tprintk(KERN_INFO \"mediabay%d: Registered %s media-bay\\n\", i, bay->ops->name);\n\n\t \n\tset_mb_power(bay, 0);\n\tmsleep(MB_POWER_DELAY);\n\tbay->content_id = MB_NO;\n\tbay->last_value = bay->ops->content(bay);\n\tbay->value_count = msecs_to_jiffies(MB_STABLE_DELAY);\n\tbay->state = mb_empty;\n\n\t \n\tmacio_set_drvdata(mdev, bay);\n\n\t \n\tif (i == 0)\n\t\tkthread_run(media_bay_task, NULL, \"media-bay\");\n\n\treturn 0;\n\n}\n\nstatic int media_bay_suspend(struct macio_dev *mdev, pm_message_t state)\n{\n\tstruct media_bay_info\t*bay = macio_get_drvdata(mdev);\n\n\tif (state.event != mdev->ofdev.dev.power.power_state.event\n\t    && (state.event & PM_EVENT_SLEEP)) {\n\t\tmutex_lock(&bay->lock);\n\t\tbay->sleeping = 1;\n\t\tset_mb_power(bay, 0);\n\t\tmutex_unlock(&bay->lock);\n\t\tmsleep(MB_POLL_DELAY);\n\t\tmdev->ofdev.dev.power.power_state = state;\n\t}\n\treturn 0;\n}\n\nstatic int media_bay_resume(struct macio_dev *mdev)\n{\n\tstruct media_bay_info\t*bay = macio_get_drvdata(mdev);\n\n\tif (mdev->ofdev.dev.power.power_state.event != PM_EVENT_ON) {\n\t\tmdev->ofdev.dev.power.power_state = PMSG_ON;\n\n\t       \t \n\t       \t \n\t\tmutex_lock(&bay->lock);\n\t       \tset_mb_power(bay, 0);\n\t\tmsleep(MB_POWER_DELAY);\n\t       \tif (bay->ops->content(bay) != bay->content_id) {\n\t\t\tprintk(\"mediabay%d: Content changed during sleep...\\n\", bay->index);\n\t\t\tmutex_unlock(&bay->lock);\n\t       \t\treturn 0;\n\t\t}\n\t       \tset_mb_power(bay, 1);\n\t       \tbay->last_value = bay->content_id;\n\t       \tbay->value_count = msecs_to_jiffies(MB_STABLE_DELAY);\n\t       \tbay->timer = msecs_to_jiffies(MB_POWER_DELAY);\n\t       \tdo {\n\t\t\tmsleep(MB_POLL_DELAY);\n\t       \t\tmedia_bay_step(bay->index);\n\t       \t} while((bay->state != mb_empty) &&\n\t       \t\t(bay->state != mb_up));\n\t\tbay->sleeping = 0;\n\t\tmutex_unlock(&bay->lock);\n\t}\n\treturn 0;\n}\n\n\n \nstatic const struct mb_ops ohare_mb_ops = {\n\t.name\t\t= \"Ohare\",\n\t.content\t= ohare_mb_content,\n\t.power\t\t= ohare_mb_power,\n\t.setup_bus\t= ohare_mb_setup_bus,\n\t.un_reset\t= ohare_mb_un_reset,\n\t.un_reset_ide\t= ohare_mb_un_reset_ide,\n};\n\nstatic const struct mb_ops heathrow_mb_ops = {\n\t.name\t\t= \"Heathrow\",\n\t.content\t= heathrow_mb_content,\n\t.power\t\t= heathrow_mb_power,\n\t.setup_bus\t= heathrow_mb_setup_bus,\n\t.un_reset\t= heathrow_mb_un_reset,\n\t.un_reset_ide\t= heathrow_mb_un_reset_ide,\n};\n\nstatic const struct mb_ops keylargo_mb_ops = {\n\t.name\t\t= \"KeyLargo\",\n\t.init\t\t= keylargo_mb_init,\n\t.content\t= keylargo_mb_content,\n\t.power\t\t= keylargo_mb_power,\n\t.setup_bus\t= keylargo_mb_setup_bus,\n\t.un_reset\t= keylargo_mb_un_reset,\n\t.un_reset_ide\t= keylargo_mb_un_reset_ide,\n};\n\n \n\nstatic const struct of_device_id media_bay_match[] =\n{\n\t{\n\t.name\t\t= \"media-bay\",\n\t.compatible\t= \"keylargo-media-bay\",\n\t.data\t\t= &keylargo_mb_ops,\n\t},\n\t{\n\t.name\t\t= \"media-bay\",\n\t.compatible\t= \"heathrow-media-bay\",\n\t.data\t\t= &heathrow_mb_ops,\n\t},\n\t{\n\t.name\t\t= \"media-bay\",\n\t.compatible\t= \"ohare-media-bay\",\n\t.data\t\t= &ohare_mb_ops,\n\t},\n\t{},\n};\n\nstatic struct macio_driver media_bay_driver =\n{\n\t.driver = {\n\t\t.name\t\t= \"media-bay\",\n\t\t.of_match_table\t= media_bay_match,\n\t},\n\t.probe\t\t= media_bay_attach,\n\t.suspend\t= media_bay_suspend,\n\t.resume\t\t= media_bay_resume\n};\n\nstatic int __init media_bay_init(void)\n{\n\tint i;\n\n\tfor (i=0; i<MAX_BAYS; i++) {\n\t\tmemset((char *)&media_bays[i], 0, sizeof(struct media_bay_info));\n\t\tmedia_bays[i].content_id\t= -1;\n\t}\n\tif (!machine_is(powermac))\n\t\treturn 0;\n\n\tmacio_register_driver(&media_bay_driver);\t\n\n\treturn 0;\n}\n\ndevice_initcall(media_bay_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}