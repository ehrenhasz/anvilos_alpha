{
  "module_name": "windfarm_pm81.c",
  "hash_id": "4925f280513690c0cc83ebb83cbe74c588caf3f4fa92516d33694e9893325491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_pm81.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_pid.h\"\n\n#define VERSION \"0.4\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n \n#undef HACKED_OVERTEMP\n\nstatic int wf_smu_mach_model;\t \n\n \nstatic struct wf_sensor\t*sensor_cpu_power;\nstatic struct wf_sensor\t*sensor_cpu_temp;\nstatic struct wf_sensor\t*sensor_hd_temp;\nstatic struct wf_control *fan_cpu_main;\nstatic struct wf_control *fan_hd;\nstatic struct wf_control *fan_system;\nstatic struct wf_control *cpufreq_clamp;\n\n \nstatic int wf_smu_all_controls_ok, wf_smu_all_sensors_ok;\nstatic bool wf_smu_started;\n\n \n#define FAILURE_FAN\t\t0x01\n#define FAILURE_SENSOR\t\t0x02\n#define FAILURE_OVERTEMP\t0x04\n\nstatic unsigned int wf_smu_failure_state;\nstatic int wf_smu_readjust, wf_smu_skipping;\nstatic bool wf_smu_overtemp;\n\n \n\n \nstruct wf_smu_sys_fans_param {\n\tint\tmodel_id;\n\ts32\titarget;\n\ts32\tgd, gp, gr;\n\n\ts16\toffset0;\n\tu16\tscale0;\n\ts16\toffset1;\n\tu16\tscale1;\n};\n\n#define WF_SMU_SYS_FANS_INTERVAL\t5\n#define WF_SMU_SYS_FANS_HISTORY_SIZE\t2\n\n \nstruct wf_smu_sys_fans_state {\n\tint\t\t\tticks;\n\ts32\t\t\tsys_setpoint;\n\ts32\t\t\thd_setpoint;\n\ts16\t\t\toffset0;\n\tu16\t\t\tscale0;\n\ts16\t\t\toffset1;\n\tu16\t\t\tscale1;\n\tstruct wf_pid_state\tpid;\n};\n\n \nstatic struct wf_smu_sys_fans_param wf_smu_sys_all_params[] = {\n\t \n\t{\n\t\t.model_id\t= 2,\n\t\t.itarget\t= 0x3a0000,\n\t\t.gd\t\t= 0x15400000,\n\t\t.gp\t\t= 0x00200000,\n\t\t.gr\t\t= 0x000002fd,\n\t\t.offset0\t= 0xff38,\n\t\t.scale0\t\t= 0x0ccd,\n\t\t.offset1\t= 0x0208,\n\t\t.scale1\t\t= 0x07ae,\n\t},\n\t \n\t{\n\t\t.model_id\t= 3,\n\t\t.itarget\t= 0x350000,\n\t\t.gd\t\t= 0x08e00000,\n\t\t.gp\t\t= 0x00566666,\n\t\t.gr\t\t= 0x0000072b,\n\t\t.offset0\t= 0xff38,\n\t\t.scale0\t\t= 0x0ccd,\n\t\t.offset1\t= 0x0000,\n\t\t.scale1\t\t= 0x0000,\n\t},\n\t \n\t{\n\t\t.model_id\t= 5,\n\t\t.itarget\t= 0x3a0000,\n\t\t.gd\t\t= 0x15400000,\n\t\t.gp\t\t= 0x00233333,\n\t\t.gr\t\t= 0x000002fd,\n\t\t.offset0\t= 0x0000,\n\t\t.scale0\t\t= 0x1000,\n\t\t.offset1\t= 0x0091,\n\t\t.scale1\t\t= 0x0bae,\n\t},\n};\n#define WF_SMU_SYS_FANS_NUM_CONFIGS ARRAY_SIZE(wf_smu_sys_all_params)\n\nstatic struct wf_smu_sys_fans_state *wf_smu_sys_fans;\n\n \n\n\n#define WF_SMU_CPU_FANS_INTERVAL\t1\n#define WF_SMU_CPU_FANS_MAX_HISTORY\t16\n#define WF_SMU_CPU_FANS_SIBLING_SCALE\t0x00001000\n#define WF_SMU_CPU_FANS_SIBLING_OFFSET\t0xfffffb50\n\n \nstruct wf_smu_cpu_fans_state {\n\tint\t\t\tticks;\n\ts32\t\t\tcpu_setpoint;\n\ts32\t\t\tscale;\n\ts32\t\t\toffset;\n\tstruct wf_cpu_pid_state\tpid;\n};\n\nstatic struct wf_smu_cpu_fans_state *wf_smu_cpu_fans;\n\n\n\n \n\nstatic void wf_smu_create_sys_fans(void)\n{\n\tstruct wf_smu_sys_fans_param *param = NULL;\n\tstruct wf_pid_param pid_param;\n\tint i;\n\n\t \n\tfor (i = 0; i < WF_SMU_SYS_FANS_NUM_CONFIGS; i++)\n\t\tif (wf_smu_sys_all_params[i].model_id == wf_smu_mach_model) {\n\t\t\tparam = &wf_smu_sys_all_params[i];\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (param == NULL) {\n\t\tprintk(KERN_WARNING \"windfarm: System fan config not found \"\n\t\t       \"for this machine model, max fan speed\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\twf_smu_sys_fans = kmalloc(sizeof(struct wf_smu_sys_fans_state),\n\t\t\t\t  GFP_KERNEL);\n\tif (wf_smu_sys_fans == NULL) {\n\t\tprintk(KERN_WARNING \"windfarm: Memory allocation error\"\n\t\t       \" max fan speed\\n\");\n\t\tgoto fail;\n\t}\n\twf_smu_sys_fans->ticks = 1;\n\twf_smu_sys_fans->scale0 = param->scale0;\n\twf_smu_sys_fans->offset0 = param->offset0;\n\twf_smu_sys_fans->scale1 = param->scale1;\n\twf_smu_sys_fans->offset1 = param->offset1;\n\n\t \n\tpid_param.gd = param->gd;\n\tpid_param.gp = param->gp;\n\tpid_param.gr = param->gr;\n\tpid_param.interval = WF_SMU_SYS_FANS_INTERVAL;\n\tpid_param.history_len = WF_SMU_SYS_FANS_HISTORY_SIZE;\n\tpid_param.itarget = param->itarget;\n\tpid_param.min = wf_control_get_min(fan_system);\n\tpid_param.max = wf_control_get_max(fan_system);\n\tif (fan_hd) {\n\t\tpid_param.min =\n\t\t\tmax(pid_param.min, wf_control_get_min(fan_hd));\n\t\tpid_param.max =\n\t\t\tmin(pid_param.max, wf_control_get_max(fan_hd));\n\t}\n\twf_pid_init(&wf_smu_sys_fans->pid, &pid_param);\n\n\tDBG(\"wf: System Fan control initialized.\\n\");\n\tDBG(\"    itarged=%d.%03d, min=%d RPM, max=%d RPM\\n\",\n\t    FIX32TOPRINT(pid_param.itarget), pid_param.min, pid_param.max);\n\treturn;\n\n fail:\n\n\tif (fan_system)\n\t\twf_control_set_max(fan_system);\n\tif (fan_hd)\n\t\twf_control_set_max(fan_hd);\n}\n\nstatic void wf_smu_sys_fans_tick(struct wf_smu_sys_fans_state *st)\n{\n\ts32 new_setpoint, temp, scaled, cputarget;\n\tint rc;\n\n\tif (--st->ticks != 0) {\n\t\tif (wf_smu_readjust)\n\t\t\tgoto readjust;\n\t\treturn;\n\t}\n\tst->ticks = WF_SMU_SYS_FANS_INTERVAL;\n\n\trc = wf_sensor_get(sensor_hd_temp, &temp);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"windfarm: HD temp sensor error %d\\n\",\n\t\t       rc);\n\t\twf_smu_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\tDBG(\"wf_smu: System Fans tick ! HD temp: %d.%03d\\n\",\n\t    FIX32TOPRINT(temp));\n\n\tif (temp > (st->pid.param.itarget + 0x50000))\n\t\twf_smu_failure_state |= FAILURE_OVERTEMP;\n\n\tnew_setpoint = wf_pid_run(&st->pid, temp);\n\n\tDBG(\"wf_smu: new_setpoint: %d RPM\\n\", (int)new_setpoint);\n\n\tscaled = ((((s64)new_setpoint) * (s64)st->scale0) >> 12) + st->offset0;\n\n\tDBG(\"wf_smu: scaled setpoint: %d RPM\\n\", (int)scaled);\n\n\tcputarget = wf_smu_cpu_fans ? wf_smu_cpu_fans->pid.target : 0;\n\tcputarget = ((((s64)cputarget) * (s64)st->scale1) >> 12) + st->offset1;\n\tscaled = max(scaled, cputarget);\n\tscaled = max(scaled, st->pid.param.min);\n\tscaled = min(scaled, st->pid.param.max);\n\n\tDBG(\"wf_smu: adjusted setpoint: %d RPM\\n\", (int)scaled);\n\n\tif (st->sys_setpoint == scaled && new_setpoint == st->hd_setpoint)\n\t\treturn;\n\tst->sys_setpoint = scaled;\n\tst->hd_setpoint = new_setpoint;\n readjust:\n\tif (fan_system && wf_smu_failure_state == 0) {\n\t\trc = wf_control_set(fan_system, st->sys_setpoint);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"windfarm: Sys fan error %d\\n\",\n\t\t\t       rc);\n\t\t\twf_smu_failure_state |= FAILURE_FAN;\n\t\t}\n\t}\n\tif (fan_hd && wf_smu_failure_state == 0) {\n\t\trc = wf_control_set(fan_hd, st->hd_setpoint);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"windfarm: HD fan error %d\\n\",\n\t\t\t       rc);\n\t\t\twf_smu_failure_state |= FAILURE_FAN;\n\t\t}\n\t}\n}\n\nstatic void wf_smu_create_cpu_fans(void)\n{\n\tstruct wf_cpu_pid_param pid_param;\n\tconst struct smu_sdbp_header *hdr;\n\tstruct smu_sdbp_cpupiddata *piddata;\n\tstruct smu_sdbp_fvt *fvt;\n\ts32 tmax, tdelta, maxpow, powadj;\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_CPUPIDDATA_ID, NULL);\n\tif (!hdr) {\n\t\tprintk(KERN_WARNING \"windfarm: CPU PID fan config not found \"\n\t\t       \"max fan speed\\n\");\n\t\tgoto fail;\n\t}\n\tpiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\n\tif (hdr) {\n\t\tfvt = (struct smu_sdbp_fvt *)&hdr[1];\n\t\ttmax = ((s32)fvt->maxtemp) << 16;\n\t} else\n\t\ttmax = 0x5e0000;  \n\n\t \n\twf_smu_cpu_fans = kmalloc(sizeof(struct wf_smu_cpu_fans_state),\n\t\t\t\t  GFP_KERNEL);\n\tif (wf_smu_cpu_fans == NULL)\n\t\tgoto fail;\n       \twf_smu_cpu_fans->ticks = 1;\n\n\twf_smu_cpu_fans->scale = WF_SMU_CPU_FANS_SIBLING_SCALE;\n\twf_smu_cpu_fans->offset = WF_SMU_CPU_FANS_SIBLING_OFFSET;\n\n\t \n\tpid_param.interval = WF_SMU_CPU_FANS_INTERVAL;\n\tpid_param.history_len = piddata->history_len;\n\tif (pid_param.history_len > WF_CPU_PID_MAX_HISTORY) {\n\t\tprintk(KERN_WARNING \"windfarm: History size overflow on \"\n\t\t       \"CPU control loop (%d)\\n\", piddata->history_len);\n\t\tpid_param.history_len = WF_CPU_PID_MAX_HISTORY;\n\t}\n\tpid_param.gd = piddata->gd;\n\tpid_param.gp = piddata->gp;\n\tpid_param.gr = piddata->gr / pid_param.history_len;\n\n\ttdelta = ((s32)piddata->target_temp_delta) << 16;\n\tmaxpow = ((s32)piddata->max_power) << 16;\n\tpowadj = ((s32)piddata->power_adj) << 16;\n\n\tpid_param.tmax = tmax;\n\tpid_param.ttarget = tmax - tdelta;\n\tpid_param.pmaxadj = maxpow - powadj;\n\n\tpid_param.min = wf_control_get_min(fan_cpu_main);\n\tpid_param.max = wf_control_get_max(fan_cpu_main);\n\n\twf_cpu_pid_init(&wf_smu_cpu_fans->pid, &pid_param);\n\n\tDBG(\"wf: CPU Fan control initialized.\\n\");\n\tDBG(\"    ttarget=%d.%03d, tmax=%d.%03d, min=%d RPM, max=%d RPM\\n\",\n\t    FIX32TOPRINT(pid_param.ttarget), FIX32TOPRINT(pid_param.tmax),\n\t    pid_param.min, pid_param.max);\n\n\treturn;\n\n fail:\n\tprintk(KERN_WARNING \"windfarm: CPU fan config not found\\n\"\n\t       \"for this machine model, max fan speed\\n\");\n\n\tif (cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tif (fan_cpu_main)\n\t\twf_control_set_max(fan_cpu_main);\n}\n\nstatic void wf_smu_cpu_fans_tick(struct wf_smu_cpu_fans_state *st)\n{\n\ts32 new_setpoint, temp, power, systarget;\n\tint rc;\n\n\tif (--st->ticks != 0) {\n\t\tif (wf_smu_readjust)\n\t\t\tgoto readjust;\n\t\treturn;\n\t}\n\tst->ticks = WF_SMU_CPU_FANS_INTERVAL;\n\n\trc = wf_sensor_get(sensor_cpu_temp, &temp);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"windfarm: CPU temp sensor error %d\\n\",\n\t\t       rc);\n\t\twf_smu_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\trc = wf_sensor_get(sensor_cpu_power, &power);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"windfarm: CPU power sensor error %d\\n\",\n\t\t       rc);\n\t\twf_smu_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\tDBG(\"wf_smu: CPU Fans tick ! CPU temp: %d.%03d, power: %d.%03d\\n\",\n\t    FIX32TOPRINT(temp), FIX32TOPRINT(power));\n\n#ifdef HACKED_OVERTEMP\n\tif (temp > 0x4a0000)\n\t\twf_smu_failure_state |= FAILURE_OVERTEMP;\n#else\n\tif (temp > st->pid.param.tmax)\n\t\twf_smu_failure_state |= FAILURE_OVERTEMP;\n#endif\n\tnew_setpoint = wf_cpu_pid_run(&st->pid, power, temp);\n\n\tDBG(\"wf_smu: new_setpoint: %d RPM\\n\", (int)new_setpoint);\n\n\tsystarget = wf_smu_sys_fans ? wf_smu_sys_fans->pid.target : 0;\n\tsystarget = ((((s64)systarget) * (s64)st->scale) >> 12)\n\t\t+ st->offset;\n\tnew_setpoint = max(new_setpoint, systarget);\n\tnew_setpoint = max(new_setpoint, st->pid.param.min);\n\tnew_setpoint = min(new_setpoint, st->pid.param.max);\n\n\tDBG(\"wf_smu: adjusted setpoint: %d RPM\\n\", (int)new_setpoint);\n\n\tif (st->cpu_setpoint == new_setpoint)\n\t\treturn;\n\tst->cpu_setpoint = new_setpoint;\n readjust:\n\tif (fan_cpu_main && wf_smu_failure_state == 0) {\n\t\trc = wf_control_set(fan_cpu_main, st->cpu_setpoint);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"windfarm: CPU main fan\"\n\t\t\t       \" error %d\\n\", rc);\n\t\t\twf_smu_failure_state |= FAILURE_FAN;\n\t\t}\n\t}\n}\n\n \n\nstatic void wf_smu_tick(void)\n{\n\tunsigned int last_failure = wf_smu_failure_state;\n\tunsigned int new_failure;\n\n\tif (!wf_smu_started) {\n\t\tDBG(\"wf: creating control loops !\\n\");\n\t\twf_smu_create_sys_fans();\n\t\twf_smu_create_cpu_fans();\n\t\twf_smu_started = true;\n\t}\n\n\t \n\tif (wf_smu_skipping && --wf_smu_skipping)\n\t\treturn;\n\n\twf_smu_failure_state = 0;\n\tif (wf_smu_sys_fans)\n\t\twf_smu_sys_fans_tick(wf_smu_sys_fans);\n\tif (wf_smu_cpu_fans)\n\t\twf_smu_cpu_fans_tick(wf_smu_cpu_fans);\n\n\twf_smu_readjust = 0;\n\tnew_failure = wf_smu_failure_state & ~last_failure;\n\n\t \n\tif (wf_smu_failure_state && !last_failure) {\n\t\tif (cpufreq_clamp)\n\t\t\twf_control_set_max(cpufreq_clamp);\n\t\tif (fan_system)\n\t\t\twf_control_set_max(fan_system);\n\t\tif (fan_cpu_main)\n\t\t\twf_control_set_max(fan_cpu_main);\n\t\tif (fan_hd)\n\t\t\twf_control_set_max(fan_hd);\n\t}\n\n\t \n\tif (!wf_smu_failure_state && last_failure) {\n\t\tif (cpufreq_clamp)\n\t\t\twf_control_set_min(cpufreq_clamp);\n\t\twf_smu_readjust = 1;\n\t}\n\n\t \n\tif (new_failure & FAILURE_OVERTEMP) {\n\t\twf_set_overtemp();\n\t\twf_smu_skipping = 2;\n\t\twf_smu_overtemp = true;\n\t}\n\n\t \n\tif (!wf_smu_failure_state && wf_smu_overtemp) {\n\t\twf_clear_overtemp();\n\t\twf_smu_overtemp = false;\n\t}\n}\n\nstatic void wf_smu_new_control(struct wf_control *ct)\n{\n\tif (wf_smu_all_controls_ok)\n\t\treturn;\n\n\tif (fan_cpu_main == NULL && !strcmp(ct->name, \"cpu-fan\")) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tfan_cpu_main = ct;\n\t}\n\n\tif (fan_system == NULL && !strcmp(ct->name, \"system-fan\")) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tfan_system = ct;\n\t}\n\n\tif (cpufreq_clamp == NULL && !strcmp(ct->name, \"cpufreq-clamp\")) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tcpufreq_clamp = ct;\n\t}\n\n\t \n\n\tif (wf_smu_mach_model > 3) {\n\t\tif (fan_system && fan_cpu_main && cpufreq_clamp)\n\t\t\twf_smu_all_controls_ok = 1;\n\t\treturn;\n\t}\n\n\tif (fan_hd == NULL && !strcmp(ct->name, \"drive-bay-fan\")) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tfan_hd = ct;\n\t}\n\n\tif (fan_system && fan_hd && fan_cpu_main && cpufreq_clamp)\n\t\twf_smu_all_controls_ok = 1;\n}\n\nstatic void wf_smu_new_sensor(struct wf_sensor *sr)\n{\n\tif (wf_smu_all_sensors_ok)\n\t\treturn;\n\n\tif (sensor_cpu_power == NULL && !strcmp(sr->name, \"cpu-power\")) {\n\t\tif (wf_get_sensor(sr) == 0)\n\t\t\tsensor_cpu_power = sr;\n\t}\n\n\tif (sensor_cpu_temp == NULL && !strcmp(sr->name, \"cpu-temp\")) {\n\t\tif (wf_get_sensor(sr) == 0)\n\t\t\tsensor_cpu_temp = sr;\n\t}\n\n\tif (sensor_hd_temp == NULL && !strcmp(sr->name, \"hd-temp\")) {\n\t\tif (wf_get_sensor(sr) == 0)\n\t\t\tsensor_hd_temp = sr;\n\t}\n\n\tif (sensor_cpu_power && sensor_cpu_temp && sensor_hd_temp)\n\t\twf_smu_all_sensors_ok = 1;\n}\n\n\nstatic int wf_smu_notify(struct notifier_block *self,\n\t\t\t       unsigned long event, void *data)\n{\n\tswitch(event) {\n\tcase WF_EVENT_NEW_CONTROL:\n\t\tDBG(\"wf: new control %s detected\\n\",\n\t\t    ((struct wf_control *)data)->name);\n\t\twf_smu_new_control(data);\n\t\twf_smu_readjust = 1;\n\t\tbreak;\n\tcase WF_EVENT_NEW_SENSOR:\n\t\tDBG(\"wf: new sensor %s detected\\n\",\n\t\t    ((struct wf_sensor *)data)->name);\n\t\twf_smu_new_sensor(data);\n\t\tbreak;\n\tcase WF_EVENT_TICK:\n\t\tif (wf_smu_all_controls_ok && wf_smu_all_sensors_ok)\n\t\t\twf_smu_tick();\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block wf_smu_events = {\n\t.notifier_call\t= wf_smu_notify,\n};\n\nstatic int wf_init_pm(void)\n{\n\tconst struct smu_sdbp_header *hdr;\n\n\thdr = smu_get_sdb_partition(SMU_SDB_SENSORTREE_ID, NULL);\n\tif (hdr) {\n\t\tstruct smu_sdbp_sensortree *st =\n\t\t\t(struct smu_sdbp_sensortree *)&hdr[1];\n\t\twf_smu_mach_model = st->model_id;\n\t}\n\n\tprintk(KERN_INFO \"windfarm: Initializing for iMacG5 model ID %d\\n\",\n\t       wf_smu_mach_model);\n\n\treturn 0;\n}\n\nstatic int wf_smu_probe(struct platform_device *ddev)\n{\n\twf_register_client(&wf_smu_events);\n\n\treturn 0;\n}\n\nstatic int wf_smu_remove(struct platform_device *ddev)\n{\n\twf_unregister_client(&wf_smu_events);\n\n\t \n\tmsleep(1000);\n\n\t \n\t \n\tif (sensor_cpu_power)\n\t\twf_put_sensor(sensor_cpu_power);\n\tif (sensor_cpu_temp)\n\t\twf_put_sensor(sensor_cpu_temp);\n\tif (sensor_hd_temp)\n\t\twf_put_sensor(sensor_hd_temp);\n\n\t \n\tif (fan_cpu_main)\n\t\twf_put_control(fan_cpu_main);\n\tif (fan_hd)\n\t\twf_put_control(fan_hd);\n\tif (fan_system)\n\t\twf_put_control(fan_system);\n\tif (cpufreq_clamp)\n\t\twf_put_control(cpufreq_clamp);\n\n\t \n\tkfree(wf_smu_sys_fans);\n\tkfree(wf_smu_cpu_fans);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wf_smu_driver = {\n        .probe = wf_smu_probe,\n        .remove = wf_smu_remove,\n\t.driver = {\n\t\t.name = \"windfarm\",\n\t},\n};\n\n\nstatic int __init wf_smu_init(void)\n{\n\tint rc = -ENODEV;\n\n\tif (of_machine_is_compatible(\"PowerMac8,1\") ||\n\t    of_machine_is_compatible(\"PowerMac8,2\"))\n\t\trc = wf_init_pm();\n\n\tif (rc == 0) {\n#ifdef MODULE\n\t\trequest_module(\"windfarm_smu_controls\");\n\t\trequest_module(\"windfarm_smu_sensors\");\n\t\trequest_module(\"windfarm_lm75_sensor\");\n\t\trequest_module(\"windfarm_cpufreq_clamp\");\n\n#endif  \n\t\tplatform_driver_register(&wf_smu_driver);\n\t}\n\n\treturn rc;\n}\n\nstatic void __exit wf_smu_exit(void)\n{\n\n\tplatform_driver_unregister(&wf_smu_driver);\n}\n\n\nmodule_init(wf_smu_init);\nmodule_exit(wf_smu_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Thermal control logic for iMac G5\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:windfarm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}