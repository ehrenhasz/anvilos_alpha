{
  "module_name": "windfarm_pid.c",
  "hash_id": "7c1c525905cfd0b96968601db69cb464faeac5d7efdf44d9fe468fa7aa917664",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_pid.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#include \"windfarm_pid.h\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\nvoid wf_pid_init(struct wf_pid_state *st, struct wf_pid_param *param)\n{\n\tmemset(st, 0, sizeof(struct wf_pid_state));\n\tst->param = *param;\n\tst->first = 1;\n}\nEXPORT_SYMBOL_GPL(wf_pid_init);\n\ns32 wf_pid_run(struct wf_pid_state *st, s32 new_sample)\n{\n\ts64\terror, integ, deriv;\n\ts32\ttarget;\n\tint\ti, hlen = st->param.history_len;\n\n\t \n\terror = new_sample - st->param.itarget;\n\n\t \n\tif (st->first) {\n\t\tfor (i = 0; i < hlen; i++) {\n\t\t\tst->samples[i] = new_sample;\n\t\t\tst->errors[i] = error;\n\t\t}\n\t\tst->first = 0;\n\t\tst->index = 0;\n\t} else {\n\t\tst->index = (st->index + 1) % hlen;\n\t\tst->samples[st->index] = new_sample;\n\t\tst->errors[st->index] = error;\n\t}\n\n\t \n\tfor (i = 0, integ = 0; i < hlen; i++)\n\t\tinteg += st->errors[(st->index + hlen - i) % hlen];\n\tinteg *= st->param.interval;\n\n\t \n\tderiv = st->errors[st->index] -\n\t\tst->errors[(st->index + hlen - 1) % hlen];\n\tderiv /= st->param.interval;\n\n\t \n\ttarget = (s32)((integ * (s64)st->param.gr + deriv * (s64)st->param.gd +\n\t\t  error * (s64)st->param.gp) >> 36);\n\tif (st->param.additive)\n\t\ttarget += st->target;\n\ttarget = max(target, st->param.min);\n\ttarget = min(target, st->param.max);\n\tst->target = target;\n\n\treturn st->target;\n}\nEXPORT_SYMBOL_GPL(wf_pid_run);\n\nvoid wf_cpu_pid_init(struct wf_cpu_pid_state *st,\n\t\t     struct wf_cpu_pid_param *param)\n{\n\tmemset(st, 0, sizeof(struct wf_cpu_pid_state));\n\tst->param = *param;\n\tst->first = 1;\n}\nEXPORT_SYMBOL_GPL(wf_cpu_pid_init);\n\ns32 wf_cpu_pid_run(struct wf_cpu_pid_state *st, s32 new_power, s32 new_temp)\n{\n\ts64\tinteg, deriv, prop;\n\ts32\terror, target, sval, adj;\n\tint\ti, hlen = st->param.history_len;\n\n\t \n\terror = st->param.pmaxadj - new_power;\n\n\t \n\tif (st->first) {\n\t\tfor (i = 0; i < hlen; i++) {\n\t\t\tst->powers[i] = new_power;\n\t\t\tst->errors[i] = error;\n\t\t}\n\t\tst->temps[0] = st->temps[1] = new_temp;\n\t\tst->first = 0;\n\t\tst->index = st->tindex = 0;\n\t} else {\n\t\tst->index = (st->index + 1) % hlen;\n\t\tst->powers[st->index] = new_power;\n\t\tst->errors[st->index] = error;\n\t\tst->tindex = (st->tindex + 1) % 2;\n\t\tst->temps[st->tindex] = new_temp;\n\t}\n\n\t \n\tfor (i = 0, integ = 0; i < hlen; i++)\n\t\tinteg += st->errors[(st->index + hlen - i) % hlen];\n\tinteg *= st->param.interval;\n\tinteg *= st->param.gr;\n\tsval = st->param.tmax - (s32)(integ >> 20);\n\tadj = min(st->param.ttarget, sval);\n\n\tDBG(\"integ: %lx, sval: %lx, adj: %lx\\n\", integ, sval, adj);\n\n\t \n\tderiv = st->temps[st->tindex] -\n\t\tst->temps[(st->tindex + 2 - 1) % 2];\n\tderiv /= st->param.interval;\n\tderiv *= st->param.gd;\n\n\t \n\tprop = st->last_delta = (new_temp - adj);\n\tprop *= st->param.gp;\n\n\tDBG(\"deriv: %lx, prop: %lx\\n\", deriv, prop);\n\n\t \n\ttarget = st->target + (s32)((deriv + prop) >> 36);\n\ttarget = max(target, st->param.min);\n\ttarget = min(target, st->param.max);\n\tst->target = target;\n\n\treturn st->target;\n}\nEXPORT_SYMBOL_GPL(wf_cpu_pid_run);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"PID algorithm for PowerMacs thermal control\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}