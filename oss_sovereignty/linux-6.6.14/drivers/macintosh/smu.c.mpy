{
  "module_name": "smu.c",
  "hash_id": "9bc329ea7ad73ab11ae9c386385f5c92e9c549e33441d45808a8400564b37814",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/smu.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/memblock.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/rtc.h>\n#include <linux/completion.h>\n#include <linux/miscdevice.h>\n#include <linux/delay.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/smu.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n\n#define VERSION \"0.7\"\n#define AUTHOR  \"(c) 2005 Benjamin Herrenschmidt, IBM Corp.\"\n\n#undef DEBUG_SMU\n\n#ifdef DEBUG_SMU\n#define DPRINTK(fmt, args...) do { printk(KERN_DEBUG fmt , ##args); } while (0)\n#else\n#define DPRINTK(fmt, args...) do { } while (0)\n#endif\n\n \n#define SMU_MAX_DATA\t254\n\nstruct smu_cmd_buf {\n\tu8 cmd;\n\tu8 length;\n\tu8 data[SMU_MAX_DATA];\n};\n\nstruct smu_device {\n\tspinlock_t\t\tlock;\n\tstruct device_node\t*of_node;\n\tstruct platform_device\t*of_dev;\n\tint\t\t\tdoorbell;\t \n\tu32 __iomem\t\t*db_buf;\t \n\tstruct device_node\t*db_node;\n\tunsigned int\t\tdb_irq;\n\tint\t\t\tmsg;\n\tstruct device_node\t*msg_node;\n\tunsigned int\t\tmsg_irq;\n\tstruct smu_cmd_buf\t*cmd_buf;\t \n\tu32\t\t\tcmd_buf_abs;\t \n\tstruct list_head\tcmd_list;\n\tstruct smu_cmd\t\t*cmd_cur;\t \n\tint\t\t\tbroken_nap;\n\tstruct list_head\tcmd_i2c_list;\n\tstruct smu_i2c_cmd\t*cmd_i2c_cur;\t \n\tstruct timer_list\ti2c_timer;\n};\n\n \nstatic DEFINE_MUTEX(smu_mutex);\nstatic struct smu_device\t*smu;\nstatic DEFINE_MUTEX(smu_part_access);\nstatic int smu_irq_inited;\nstatic unsigned long smu_cmdbuf_abs;\n\nstatic void smu_i2c_retry(struct timer_list *t);\n\n \n\nstatic void smu_start_cmd(void)\n{\n\tunsigned long faddr, fend;\n\tstruct smu_cmd *cmd;\n\n\tif (list_empty(&smu->cmd_list))\n\t\treturn;\n\n\t \n\tcmd = list_entry(smu->cmd_list.next, struct smu_cmd, link);\n\tsmu->cmd_cur = cmd;\n\tlist_del(&cmd->link);\n\n\tDPRINTK(\"SMU: starting cmd %x, %d bytes data\\n\", cmd->cmd,\n\t\tcmd->data_len);\n\tDPRINTK(\"SMU: data buffer: %8ph\\n\", cmd->data_buf);\n\n\t \n\tsmu->cmd_buf->cmd = cmd->cmd;\n\tsmu->cmd_buf->length = cmd->data_len;\n\tmemcpy(smu->cmd_buf->data, cmd->data_buf, cmd->data_len);\n\n\t \n\tfaddr = (unsigned long)smu->cmd_buf;\n\tfend = faddr + smu->cmd_buf->length + 2;\n\tflush_dcache_range(faddr, fend);\n\n\n\t \n\tif (smu->broken_nap)\n\t\tpowersave_nap = 0;\n\n\t \n\twritel(smu->cmd_buf_abs, smu->db_buf);\n\n\t \n\tpmac_do_feature_call(PMAC_FTR_WRITE_GPIO, NULL, smu->doorbell, 4);\n}\n\n\nstatic irqreturn_t smu_db_intr(int irq, void *arg)\n{\n\tunsigned long flags;\n\tstruct smu_cmd *cmd;\n\tvoid (*done)(struct smu_cmd *cmd, void *misc) = NULL;\n\tvoid *misc = NULL;\n\tu8 gpio;\n\tint rc = 0;\n\n\t \n\tspin_lock_irqsave(&smu->lock, flags);\n\n\tgpio = pmac_do_feature_call(PMAC_FTR_READ_GPIO, NULL, smu->doorbell);\n\tif ((gpio & 7) != 7) {\n\t\tspin_unlock_irqrestore(&smu->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tcmd = smu->cmd_cur;\n\tsmu->cmd_cur = NULL;\n\tif (cmd == NULL)\n\t\tgoto bail;\n\n\tif (rc == 0) {\n\t\tunsigned long faddr;\n\t\tint reply_len;\n\t\tu8 ack;\n\n\t\t \n\t\tfaddr = (unsigned long)smu->cmd_buf;\n\t\tflush_dcache_range(faddr, faddr + 256);\n\n\t\t \n\t\tack = (~cmd->cmd) & 0xff;\n\t\tif (ack != smu->cmd_buf->cmd) {\n\t\t\tDPRINTK(\"SMU: incorrect ack, want %x got %x\\n\",\n\t\t\t\tack, smu->cmd_buf->cmd);\n\t\t\trc = -EIO;\n\t\t}\n\t\treply_len = rc == 0 ? smu->cmd_buf->length : 0;\n\t\tDPRINTK(\"SMU: reply len: %d\\n\", reply_len);\n\t\tif (reply_len > cmd->reply_len) {\n\t\t\tprintk(KERN_WARNING \"SMU: reply buffer too small,\"\n\t\t\t       \"got %d bytes for a %d bytes buffer\\n\",\n\t\t\t       reply_len, cmd->reply_len);\n\t\t\treply_len = cmd->reply_len;\n\t\t}\n\t\tcmd->reply_len = reply_len;\n\t\tif (cmd->reply_buf && reply_len)\n\t\t\tmemcpy(cmd->reply_buf, smu->cmd_buf->data, reply_len);\n\t}\n\n\t \n\tdone = cmd->done;\n\tmisc = cmd->misc;\n\tmb();\n\tcmd->status = rc;\n\n\t \n\tif (smu->broken_nap)\n\t\tpowersave_nap = 1;\n bail:\n\t \n\tsmu_start_cmd();\n\tspin_unlock_irqrestore(&smu->lock, flags);\n\n\t \n\tif (done)\n\t\tdone(cmd, misc);\n\n\t \n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t smu_msg_intr(int irq, void *arg)\n{\n\t \n\n\tprintk(KERN_INFO \"SMU: message interrupt !\\n\");\n\n\t \n\treturn IRQ_HANDLED;\n}\n\n\n \n\nint smu_queue_cmd(struct smu_cmd *cmd)\n{\n\tunsigned long flags;\n\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\tif (cmd->data_len > SMU_MAX_DATA ||\n\t    cmd->reply_len > SMU_MAX_DATA)\n\t\treturn -EINVAL;\n\n\tcmd->status = 1;\n\tspin_lock_irqsave(&smu->lock, flags);\n\tlist_add_tail(&cmd->link, &smu->cmd_list);\n\tif (smu->cmd_cur == NULL)\n\t\tsmu_start_cmd();\n\tspin_unlock_irqrestore(&smu->lock, flags);\n\n\t \n\tif (!smu_irq_inited || !smu->db_irq)\n\t\tsmu_spinwait_cmd(cmd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(smu_queue_cmd);\n\n\nint smu_queue_simple(struct smu_simple_cmd *scmd, u8 command,\n\t\t     unsigned int data_len,\n\t\t     void (*done)(struct smu_cmd *cmd, void *misc),\n\t\t     void *misc, ...)\n{\n\tstruct smu_cmd *cmd = &scmd->cmd;\n\tva_list list;\n\tint i;\n\n\tif (data_len > sizeof(scmd->buffer))\n\t\treturn -EINVAL;\n\n\tmemset(scmd, 0, sizeof(*scmd));\n\tcmd->cmd = command;\n\tcmd->data_len = data_len;\n\tcmd->data_buf = scmd->buffer;\n\tcmd->reply_len = sizeof(scmd->buffer);\n\tcmd->reply_buf = scmd->buffer;\n\tcmd->done = done;\n\tcmd->misc = misc;\n\n\tva_start(list, misc);\n\tfor (i = 0; i < data_len; ++i)\n\t\tscmd->buffer[i] = (u8)va_arg(list, int);\n\tva_end(list);\n\n\treturn smu_queue_cmd(cmd);\n}\nEXPORT_SYMBOL(smu_queue_simple);\n\n\nvoid smu_poll(void)\n{\n\tu8 gpio;\n\n\tif (smu == NULL)\n\t\treturn;\n\n\tgpio = pmac_do_feature_call(PMAC_FTR_READ_GPIO, NULL, smu->doorbell);\n\tif ((gpio & 7) == 7)\n\t\tsmu_db_intr(smu->db_irq, smu);\n}\nEXPORT_SYMBOL(smu_poll);\n\n\nvoid smu_done_complete(struct smu_cmd *cmd, void *misc)\n{\n\tstruct completion *comp = misc;\n\n\tcomplete(comp);\n}\nEXPORT_SYMBOL(smu_done_complete);\n\n\nvoid smu_spinwait_cmd(struct smu_cmd *cmd)\n{\n\twhile(cmd->status == 1)\n\t\tsmu_poll();\n}\nEXPORT_SYMBOL(smu_spinwait_cmd);\n\n\n \nstatic inline int bcd2hex (int n)\n{\n\treturn (((n & 0xf0) >> 4) * 10) + (n & 0xf);\n}\n\n\nstatic inline int hex2bcd (int n)\n{\n\treturn ((n / 10) << 4) + (n % 10);\n}\n\n\nstatic inline void smu_fill_set_rtc_cmd(struct smu_cmd_buf *cmd_buf,\n\t\t\t\t\tstruct rtc_time *time)\n{\n\tcmd_buf->cmd = 0x8e;\n\tcmd_buf->length = 8;\n\tcmd_buf->data[0] = 0x80;\n\tcmd_buf->data[1] = hex2bcd(time->tm_sec);\n\tcmd_buf->data[2] = hex2bcd(time->tm_min);\n\tcmd_buf->data[3] = hex2bcd(time->tm_hour);\n\tcmd_buf->data[4] = time->tm_wday;\n\tcmd_buf->data[5] = hex2bcd(time->tm_mday);\n\tcmd_buf->data[6] = hex2bcd(time->tm_mon) + 1;\n\tcmd_buf->data[7] = hex2bcd(time->tm_year - 100);\n}\n\n\nint smu_get_rtc_time(struct rtc_time *time, int spinwait)\n{\n\tstruct smu_simple_cmd cmd;\n\tint rc;\n\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\n\tmemset(time, 0, sizeof(struct rtc_time));\n\trc = smu_queue_simple(&cmd, SMU_CMD_RTC_COMMAND, 1, NULL, NULL,\n\t\t\t      SMU_CMD_RTC_GET_DATETIME);\n\tif (rc)\n\t\treturn rc;\n\tsmu_spinwait_simple(&cmd);\n\n\ttime->tm_sec = bcd2hex(cmd.buffer[0]);\n\ttime->tm_min = bcd2hex(cmd.buffer[1]);\n\ttime->tm_hour = bcd2hex(cmd.buffer[2]);\n\ttime->tm_wday = bcd2hex(cmd.buffer[3]);\n\ttime->tm_mday = bcd2hex(cmd.buffer[4]);\n\ttime->tm_mon = bcd2hex(cmd.buffer[5]) - 1;\n\ttime->tm_year = bcd2hex(cmd.buffer[6]) + 100;\n\n\treturn 0;\n}\n\n\nint smu_set_rtc_time(struct rtc_time *time, int spinwait)\n{\n\tstruct smu_simple_cmd cmd;\n\tint rc;\n\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\n\trc = smu_queue_simple(&cmd, SMU_CMD_RTC_COMMAND, 8, NULL, NULL,\n\t\t\t      SMU_CMD_RTC_SET_DATETIME,\n\t\t\t      hex2bcd(time->tm_sec),\n\t\t\t      hex2bcd(time->tm_min),\n\t\t\t      hex2bcd(time->tm_hour),\n\t\t\t      time->tm_wday,\n\t\t\t      hex2bcd(time->tm_mday),\n\t\t\t      hex2bcd(time->tm_mon) + 1,\n\t\t\t      hex2bcd(time->tm_year - 100));\n\tif (rc)\n\t\treturn rc;\n\tsmu_spinwait_simple(&cmd);\n\n\treturn 0;\n}\n\n\nvoid smu_shutdown(void)\n{\n\tstruct smu_simple_cmd cmd;\n\n\tif (smu == NULL)\n\t\treturn;\n\n\tif (smu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 9, NULL, NULL,\n\t\t\t     'S', 'H', 'U', 'T', 'D', 'O', 'W', 'N', 0))\n\t\treturn;\n\tsmu_spinwait_simple(&cmd);\n\tfor (;;)\n\t\t;\n}\n\n\nvoid smu_restart(void)\n{\n\tstruct smu_simple_cmd cmd;\n\n\tif (smu == NULL)\n\t\treturn;\n\n\tif (smu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 8, NULL, NULL,\n\t\t\t     'R', 'E', 'S', 'T', 'A', 'R', 'T', 0))\n\t\treturn;\n\tsmu_spinwait_simple(&cmd);\n\tfor (;;)\n\t\t;\n}\n\n\nint smu_present(void)\n{\n\treturn smu != NULL;\n}\nEXPORT_SYMBOL(smu_present);\n\n\nint __init smu_init (void)\n{\n\tstruct device_node *np;\n\tu64 data;\n\tint ret = 0;\n\n        np = of_find_node_by_type(NULL, \"smu\");\n        if (np == NULL)\n\t\treturn -ENODEV;\n\n\tprintk(KERN_INFO \"SMU: Driver %s %s\\n\", VERSION, AUTHOR);\n\n\t \n\tsmu_cmdbuf_abs = memblock_phys_alloc_range(4096, 4096, 0, 0x80000000UL);\n\tif (smu_cmdbuf_abs == 0) {\n\t\tprintk(KERN_ERR \"SMU: Command buffer allocation failed !\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail_np;\n\t}\n\n\tsmu = memblock_alloc(sizeof(struct smu_device), SMP_CACHE_BYTES);\n\tif (!smu)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(struct smu_device));\n\n\tspin_lock_init(&smu->lock);\n\tINIT_LIST_HEAD(&smu->cmd_list);\n\tINIT_LIST_HEAD(&smu->cmd_i2c_list);\n\tsmu->of_node = np;\n\tsmu->db_irq = 0;\n\tsmu->msg_irq = 0;\n\n\t \n\tsmu->cmd_buf_abs = (u32)smu_cmdbuf_abs;\n\tsmu->cmd_buf = __va(smu_cmdbuf_abs);\n\n\tsmu->db_node = of_find_node_by_name(NULL, \"smu-doorbell\");\n\tif (smu->db_node == NULL) {\n\t\tprintk(KERN_ERR \"SMU: Can't find doorbell GPIO !\\n\");\n\t\tret = -ENXIO;\n\t\tgoto fail_bootmem;\n\t}\n\tif (of_property_read_reg(smu->db_node, 0, &data, NULL)) {\n\t\tprintk(KERN_ERR \"SMU: Can't find doorbell GPIO address !\\n\");\n\t\tret = -ENXIO;\n\t\tgoto fail_db_node;\n\t}\n\n\t \n\tsmu->doorbell = data;\n\tif (smu->doorbell < 0x50)\n\t\tsmu->doorbell += 0x50;\n\n\t \n\tdo {\n\t\tsmu->msg_node = of_find_node_by_name(NULL, \"smu-interrupt\");\n\t\tif (smu->msg_node == NULL)\n\t\t\tbreak;\n\t\tif (of_property_read_reg(smu->msg_node, 0, &data, NULL)) {\n\t\t\tof_node_put(smu->msg_node);\n\t\t\tsmu->msg_node = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tsmu->msg = data;\n\t\tif (smu->msg < 0x50)\n\t\t\tsmu->msg += 0x50;\n\t} while(0);\n\n\t \n\tsmu->db_buf = ioremap(0x8000860c, 0x1000);\n\tif (smu->db_buf == NULL) {\n\t\tprintk(KERN_ERR \"SMU: Can't map doorbell buffer pointer !\\n\");\n\t\tret = -ENXIO;\n\t\tgoto fail_msg_node;\n\t}\n\n\t \n\tsmu->broken_nap = pmac_get_uninorth_variant() < 4;\n\tif (smu->broken_nap)\n\t\tprintk(KERN_INFO \"SMU: using NAP mode workaround\\n\");\n\n\tsys_ctrler = SYS_CTRLER_SMU;\n\treturn 0;\n\nfail_msg_node:\n\tof_node_put(smu->msg_node);\nfail_db_node:\n\tof_node_put(smu->db_node);\nfail_bootmem:\n\tmemblock_free(smu, sizeof(struct smu_device));\n\tsmu = NULL;\nfail_np:\n\tof_node_put(np);\n\treturn ret;\n}\n\n\nstatic int smu_late_init(void)\n{\n\tif (!smu)\n\t\treturn 0;\n\n\ttimer_setup(&smu->i2c_timer, smu_i2c_retry, 0);\n\n\tif (smu->db_node) {\n\t\tsmu->db_irq = irq_of_parse_and_map(smu->db_node, 0);\n\t\tif (!smu->db_irq)\n\t\t\tprintk(KERN_ERR \"smu: failed to map irq for node %pOF\\n\",\n\t\t\t       smu->db_node);\n\t}\n\tif (smu->msg_node) {\n\t\tsmu->msg_irq = irq_of_parse_and_map(smu->msg_node, 0);\n\t\tif (!smu->msg_irq)\n\t\t\tprintk(KERN_ERR \"smu: failed to map irq for node %pOF\\n\",\n\t\t\t       smu->msg_node);\n\t}\n\n\t \n\n\tif (smu->db_irq) {\n\t\tif (request_irq(smu->db_irq, smu_db_intr,\n\t\t\t\tIRQF_SHARED, \"SMU doorbell\", smu) < 0) {\n\t\t\tprintk(KERN_WARNING \"SMU: can't \"\n\t\t\t       \"request interrupt %d\\n\",\n\t\t\t       smu->db_irq);\n\t\t\tsmu->db_irq = 0;\n\t\t}\n\t}\n\n\tif (smu->msg_irq) {\n\t\tif (request_irq(smu->msg_irq, smu_msg_intr,\n\t\t\t\tIRQF_SHARED, \"SMU message\", smu) < 0) {\n\t\t\tprintk(KERN_WARNING \"SMU: can't \"\n\t\t\t       \"request interrupt %d\\n\",\n\t\t\t       smu->msg_irq);\n\t\t\tsmu->msg_irq = 0;\n\t\t}\n\t}\n\n\tsmu_irq_inited = 1;\n\treturn 0;\n}\n \ncore_initcall(smu_late_init);\n\n \n\nstatic void smu_expose_childs(struct work_struct *unused)\n{\n\tstruct device_node *np;\n\n\tfor_each_child_of_node(smu->of_node, np)\n\t\tif (of_device_is_compatible(np, \"smu-sensors\"))\n\t\t\tof_platform_device_create(np, \"smu-sensors\",\n\t\t\t\t\t\t  &smu->of_dev->dev);\n}\n\nstatic DECLARE_WORK(smu_expose_childs_work, smu_expose_childs);\n\nstatic int smu_platform_probe(struct platform_device* dev)\n{\n\tif (!smu)\n\t\treturn -ENODEV;\n\tsmu->of_dev = dev;\n\n\t \n\tschedule_work(&smu_expose_childs_work);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id smu_platform_match[] =\n{\n\t{\n\t\t.type\t\t= \"smu\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver smu_of_platform_driver =\n{\n\t.driver = {\n\t\t.name = \"smu\",\n\t\t.of_match_table = smu_platform_match,\n\t},\n\t.probe\t\t= smu_platform_probe,\n};\n\nstatic int __init smu_init_sysfs(void)\n{\n\t \n\tplatform_driver_register(&smu_of_platform_driver);\n\treturn 0;\n}\n\ndevice_initcall(smu_init_sysfs);\n\nstruct platform_device *smu_get_ofdev(void)\n{\n\tif (!smu)\n\t\treturn NULL;\n\treturn smu->of_dev;\n}\n\nEXPORT_SYMBOL_GPL(smu_get_ofdev);\n\n \n\nstatic void smu_i2c_complete_command(struct smu_i2c_cmd *cmd, int fail)\n{\n\tvoid (*done)(struct smu_i2c_cmd *cmd, void *misc) = cmd->done;\n\tvoid *misc = cmd->misc;\n\tunsigned long flags;\n\n\t \n\tif (!fail && cmd->read) {\n\t\tif (cmd->pdata[0] < 1)\n\t\t\tfail = 1;\n\t\telse\n\t\t\tmemcpy(cmd->info.data, &cmd->pdata[1],\n\t\t\t       cmd->info.datalen);\n\t}\n\n\tDPRINTK(\"SMU: completing, success: %d\\n\", !fail);\n\n\t \n\tspin_lock_irqsave(&smu->lock, flags);\n\tsmu->cmd_i2c_cur = NULL;\n\twmb();\n\tcmd->status = fail ? -EIO : 0;\n\n\t \n\tif (!list_empty(&smu->cmd_i2c_list)) {\n\t\tstruct smu_i2c_cmd *newcmd;\n\n\t\t \n\t\tnewcmd = list_entry(smu->cmd_i2c_list.next,\n\t\t\t\t    struct smu_i2c_cmd, link);\n\t\tsmu->cmd_i2c_cur = newcmd;\n\t\tlist_del(&cmd->link);\n\n\t\t \n\t\tlist_add_tail(&cmd->scmd.link, &smu->cmd_list);\n\t\tif (smu->cmd_cur == NULL)\n\t\t\tsmu_start_cmd();\n\t}\n\tspin_unlock_irqrestore(&smu->lock, flags);\n\n\t \n\tif (done)\n\t\tdone(cmd, misc);\n\n}\n\n\nstatic void smu_i2c_retry(struct timer_list *unused)\n{\n\tstruct smu_i2c_cmd\t*cmd = smu->cmd_i2c_cur;\n\n\tDPRINTK(\"SMU: i2c failure, requeuing...\\n\");\n\n\t \n\tcmd->pdata[0] = 0xff;\n\tcmd->scmd.reply_len = sizeof(cmd->pdata);\n\tsmu_queue_cmd(&cmd->scmd);\n}\n\n\nstatic void smu_i2c_low_completion(struct smu_cmd *scmd, void *misc)\n{\n\tstruct smu_i2c_cmd\t*cmd = misc;\n\tint\t\t\tfail = 0;\n\n\tDPRINTK(\"SMU: i2c compl. stage=%d status=%x pdata[0]=%x rlen: %x\\n\",\n\t\tcmd->stage, scmd->status, cmd->pdata[0], scmd->reply_len);\n\n\t \n\tif (scmd->status < 0)\n\t\tfail = 1;\n\telse if (cmd->read) {\n\t\tif (cmd->stage == 0)\n\t\t\tfail = cmd->pdata[0] != 0;\n\t\telse\n\t\t\tfail = cmd->pdata[0] >= 0x80;\n\t} else {\n\t\tfail = cmd->pdata[0] != 0;\n\t}\n\n\t \n\tif (fail && --cmd->retries > 0) {\n\t\tDPRINTK(\"SMU: i2c failure, starting timer...\\n\");\n\t\tBUG_ON(cmd != smu->cmd_i2c_cur);\n\t\tif (!smu_irq_inited) {\n\t\t\tmdelay(5);\n\t\t\tsmu_i2c_retry(NULL);\n\t\t\treturn;\n\t\t}\n\t\tmod_timer(&smu->i2c_timer, jiffies + msecs_to_jiffies(5));\n\t\treturn;\n\t}\n\n\t \n\tif (fail || cmd->stage != 0) {\n\t\tsmu_i2c_complete_command(cmd, fail);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"SMU: going to stage 1\\n\");\n\n\t \n\tscmd->reply_buf = cmd->pdata;\n\tscmd->reply_len = sizeof(cmd->pdata);\n\tscmd->data_buf = cmd->pdata;\n\tscmd->data_len = 1;\n\tcmd->pdata[0] = 0;\n\tcmd->stage = 1;\n\tcmd->retries = 20;\n\tsmu_queue_cmd(scmd);\n}\n\n\nint smu_queue_i2c(struct smu_i2c_cmd *cmd)\n{\n\tunsigned long flags;\n\n\tif (smu == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tcmd->scmd.cmd = SMU_CMD_I2C_COMMAND;\n\tcmd->scmd.done = smu_i2c_low_completion;\n\tcmd->scmd.misc = cmd;\n\tcmd->scmd.reply_buf = cmd->pdata;\n\tcmd->scmd.reply_len = sizeof(cmd->pdata);\n\tcmd->scmd.data_buf = (u8 *)(char *)&cmd->info;\n\tcmd->scmd.status = 1;\n\tcmd->stage = 0;\n\tcmd->pdata[0] = 0xff;\n\tcmd->retries = 20;\n\tcmd->status = 1;\n\n\t \n\tcmd->info.caddr = cmd->info.devaddr;\n\tcmd->read = cmd->info.devaddr & 0x01;\n\tswitch(cmd->info.type) {\n\tcase SMU_I2C_TRANSFER_SIMPLE:\n\t\tcmd->info.sublen = 0;\n\t\tmemset(cmd->info.subaddr, 0, sizeof(cmd->info.subaddr));\n\t\tbreak;\n\tcase SMU_I2C_TRANSFER_COMBINED:\n\t\tcmd->info.devaddr &= 0xfe;\n\t\tfallthrough;\n\tcase SMU_I2C_TRANSFER_STDSUB:\n\t\tif (cmd->info.sublen > 3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cmd->read) {\n\t\tif (cmd->info.datalen > SMU_I2C_READ_MAX)\n\t\t\treturn -EINVAL;\n\t\tmemset(cmd->info.data, 0xff, cmd->info.datalen);\n\t\tcmd->scmd.data_len = 9;\n\t} else {\n\t\tif (cmd->info.datalen > SMU_I2C_WRITE_MAX)\n\t\t\treturn -EINVAL;\n\t\tcmd->scmd.data_len = 9 + cmd->info.datalen;\n\t}\n\n\tDPRINTK(\"SMU: i2c enqueuing command\\n\");\n\tDPRINTK(\"SMU:   %s, len=%d bus=%x addr=%x sub0=%x type=%x\\n\",\n\t\tcmd->read ? \"read\" : \"write\", cmd->info.datalen,\n\t\tcmd->info.bus, cmd->info.caddr,\n\t\tcmd->info.subaddr[0], cmd->info.type);\n\n\n\t \n\tspin_lock_irqsave(&smu->lock, flags);\n\tif (smu->cmd_i2c_cur == NULL) {\n\t\tsmu->cmd_i2c_cur = cmd;\n\t\tlist_add_tail(&cmd->scmd.link, &smu->cmd_list);\n\t\tif (smu->cmd_cur == NULL)\n\t\t\tsmu_start_cmd();\n\t} else\n\t\tlist_add_tail(&cmd->link, &smu->cmd_i2c_list);\n\tspin_unlock_irqrestore(&smu->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic int smu_read_datablock(u8 *dest, unsigned int addr, unsigned int len)\n{\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tunsigned int chunk;\n\tstruct smu_cmd cmd;\n\tint rc;\n\tu8 params[8];\n\n\t \n\tchunk = 0xe;\n\n\twhile (len) {\n\t\tunsigned int clen = min(len, chunk);\n\n\t\tcmd.cmd = SMU_CMD_MISC_ee_COMMAND;\n\t\tcmd.data_len = 7;\n\t\tcmd.data_buf = params;\n\t\tcmd.reply_len = chunk;\n\t\tcmd.reply_buf = dest;\n\t\tcmd.done = smu_done_complete;\n\t\tcmd.misc = &comp;\n\t\tparams[0] = SMU_CMD_MISC_ee_GET_DATABLOCK_REC;\n\t\tparams[1] = 0x4;\n\t\t*((u32 *)&params[2]) = addr;\n\t\tparams[6] = clen;\n\n\t\trc = smu_queue_cmd(&cmd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\twait_for_completion(&comp);\n\t\tif (cmd.status != 0)\n\t\t\treturn rc;\n\t\tif (cmd.reply_len != clen) {\n\t\t\tprintk(KERN_DEBUG \"SMU: short read in \"\n\t\t\t       \"smu_read_datablock, got: %d, want: %d\\n\",\n\t\t\t       cmd.reply_len, clen);\n\t\t\treturn -EIO;\n\t\t}\n\t\tlen -= clen;\n\t\taddr += clen;\n\t\tdest += clen;\n\t}\n\treturn 0;\n}\n\nstatic struct smu_sdbp_header *smu_create_sdb_partition(int id)\n{\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tstruct smu_simple_cmd cmd;\n\tunsigned int addr, len, tlen;\n\tstruct smu_sdbp_header *hdr;\n\tstruct property *prop;\n\n\t \n\tDPRINTK(\"SMU: Query partition infos ... (irq=%d)\\n\", smu->db_irq);\n\tsmu_queue_simple(&cmd, SMU_CMD_PARTITION_COMMAND, 2,\n\t\t\t smu_done_complete, &comp,\n\t\t\t SMU_CMD_PARTITION_LATEST, id);\n\twait_for_completion(&comp);\n\tDPRINTK(\"SMU: done, status: %d, reply_len: %d\\n\",\n\t\tcmd.cmd.status, cmd.cmd.reply_len);\n\n\t \n\tif (cmd.cmd.status != 0 || cmd.cmd.reply_len != 6)\n\t\treturn NULL;\n\n\t \n\taddr = *((u16 *)cmd.buffer);\n\tlen = cmd.buffer[3] << 2;\n\t \n\ttlen = sizeof(struct property) + len + 18;\n\n\tprop = kzalloc(tlen, GFP_KERNEL);\n\tif (prop == NULL)\n\t\treturn NULL;\n\thdr = (struct smu_sdbp_header *)(prop + 1);\n\tprop->name = ((char *)prop) + tlen - 18;\n\tsprintf(prop->name, \"sdb-partition-%02x\", id);\n\tprop->length = len;\n\tprop->value = hdr;\n\tprop->next = NULL;\n\n\t \n\tif (smu_read_datablock((u8 *)hdr, addr, len)) {\n\t\tprintk(KERN_DEBUG \"SMU: datablock read failed while reading \"\n\t\t       \"partition %02x !\\n\", id);\n\t\tgoto failure;\n\t}\n\n\t \n\tif (hdr->id != id) {\n\t\tprintk(KERN_DEBUG \"SMU: Reading partition %02x and got \"\n\t\t       \"%02x !\\n\", id, hdr->id);\n\t\tgoto failure;\n\t}\n\tif (of_add_property(smu->of_node, prop)) {\n\t\tprintk(KERN_DEBUG \"SMU: Failed creating sdb-partition-%02x \"\n\t\t       \"property !\\n\", id);\n\t\tgoto failure;\n\t}\n\n\treturn hdr;\n failure:\n\tkfree(prop);\n\treturn NULL;\n}\n\n \nstatic const struct smu_sdbp_header *__smu_get_sdb_partition(int id,\n\t\tunsigned int *size, int interruptible)\n{\n\tchar pname[32];\n\tconst struct smu_sdbp_header *part;\n\n\tif (!smu)\n\t\treturn NULL;\n\n\tsprintf(pname, \"sdb-partition-%02x\", id);\n\n\tDPRINTK(\"smu_get_sdb_partition(%02x)\\n\", id);\n\n\tif (interruptible) {\n\t\tint rc;\n\t\trc = mutex_lock_interruptible(&smu_part_access);\n\t\tif (rc)\n\t\t\treturn ERR_PTR(rc);\n\t} else\n\t\tmutex_lock(&smu_part_access);\n\n\tpart = of_get_property(smu->of_node, pname, size);\n\tif (part == NULL) {\n\t\tDPRINTK(\"trying to extract from SMU ...\\n\");\n\t\tpart = smu_create_sdb_partition(id);\n\t\tif (part != NULL && size)\n\t\t\t*size = part->len << 2;\n\t}\n\tmutex_unlock(&smu_part_access);\n\treturn part;\n}\n\nconst struct smu_sdbp_header *smu_get_sdb_partition(int id, unsigned int *size)\n{\n\treturn __smu_get_sdb_partition(id, size, 0);\n}\nEXPORT_SYMBOL(smu_get_sdb_partition);\n\n\n \n\n\nstatic LIST_HEAD(smu_clist);\nstatic DEFINE_SPINLOCK(smu_clist_lock);\n\nenum smu_file_mode {\n\tsmu_file_commands,\n\tsmu_file_events,\n\tsmu_file_closing\n};\n\nstruct smu_private\n{\n\tstruct list_head\tlist;\n\tenum smu_file_mode\tmode;\n\tint\t\t\tbusy;\n\tstruct smu_cmd\t\tcmd;\n\tspinlock_t\t\tlock;\n\twait_queue_head_t\twait;\n\tu8\t\t\tbuffer[SMU_MAX_DATA];\n};\n\n\nstatic int smu_open(struct inode *inode, struct file *file)\n{\n\tstruct smu_private *pp;\n\tunsigned long flags;\n\n\tpp = kzalloc(sizeof(struct smu_private), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&pp->lock);\n\tpp->mode = smu_file_commands;\n\tinit_waitqueue_head(&pp->wait);\n\n\tmutex_lock(&smu_mutex);\n\tspin_lock_irqsave(&smu_clist_lock, flags);\n\tlist_add(&pp->list, &smu_clist);\n\tspin_unlock_irqrestore(&smu_clist_lock, flags);\n\tfile->private_data = pp;\n\tmutex_unlock(&smu_mutex);\n\n\treturn 0;\n}\n\n\nstatic void smu_user_cmd_done(struct smu_cmd *cmd, void *misc)\n{\n\tstruct smu_private *pp = misc;\n\n\twake_up_all(&pp->wait);\n}\n\n\nstatic ssize_t smu_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct smu_private *pp = file->private_data;\n\tunsigned long flags;\n\tstruct smu_user_cmd_hdr hdr;\n\tint rc = 0;\n\n\tif (pp->busy)\n\t\treturn -EBUSY;\n\telse if (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\telse if (hdr.cmdtype == SMU_CMDTYPE_WANTS_EVENTS) {\n\t\tpp->mode = smu_file_events;\n\t\treturn 0;\n\t} else if (hdr.cmdtype == SMU_CMDTYPE_GET_PARTITION) {\n\t\tconst struct smu_sdbp_header *part;\n\t\tpart = __smu_get_sdb_partition(hdr.cmd, NULL, 1);\n\t\tif (part == NULL)\n\t\t\treturn -EINVAL;\n\t\telse if (IS_ERR(part))\n\t\t\treturn PTR_ERR(part);\n\t\treturn 0;\n\t} else if (hdr.cmdtype != SMU_CMDTYPE_SMU)\n\t\treturn -EINVAL;\n\telse if (pp->mode != smu_file_commands)\n\t\treturn -EBADFD;\n\telse if (hdr.data_len > SMU_MAX_DATA)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&pp->lock, flags);\n\tif (pp->busy) {\n\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tpp->busy = 1;\n\tpp->cmd.status = 1;\n\tspin_unlock_irqrestore(&pp->lock, flags);\n\n\tif (copy_from_user(pp->buffer, buf + sizeof(hdr), hdr.data_len)) {\n\t\tpp->busy = 0;\n\t\treturn -EFAULT;\n\t}\n\n\tpp->cmd.cmd = hdr.cmd;\n\tpp->cmd.data_len = hdr.data_len;\n\tpp->cmd.reply_len = SMU_MAX_DATA;\n\tpp->cmd.data_buf = pp->buffer;\n\tpp->cmd.reply_buf = pp->buffer;\n\tpp->cmd.done = smu_user_cmd_done;\n\tpp->cmd.misc = pp;\n\trc = smu_queue_cmd(&pp->cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\treturn count;\n}\n\n\nstatic ssize_t smu_read_command(struct file *file, struct smu_private *pp,\n\t\t\t\tchar __user *buf, size_t count)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct smu_user_reply_hdr hdr;\n\tunsigned long flags;\n\tint size, rc = 0;\n\n\tif (!pp->busy)\n\t\treturn 0;\n\tif (count < sizeof(struct smu_user_reply_hdr))\n\t\treturn -EOVERFLOW;\n\tspin_lock_irqsave(&pp->lock, flags);\n\tif (pp->cmd.status == 1) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tadd_wait_queue(&pp->wait, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\trc = 0;\n\t\t\tif (pp->cmd.status != 1)\n\t\t\t\tbreak;\n\t\t\trc = -ERESTARTSYS;\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\t\tschedule();\n\t\t\tspin_lock_irqsave(&pp->lock, flags);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&pp->wait, &wait);\n\t}\n\tspin_unlock_irqrestore(&pp->lock, flags);\n\tif (rc)\n\t\treturn rc;\n\tif (pp->cmd.status != 0)\n\t\tpp->cmd.reply_len = 0;\n\tsize = sizeof(hdr) + pp->cmd.reply_len;\n\tif (count < size)\n\t\tsize = count;\n\trc = size;\n\thdr.status = pp->cmd.status;\n\thdr.reply_len = pp->cmd.reply_len;\n\tif (copy_to_user(buf, &hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tsize -= sizeof(hdr);\n\tif (size && copy_to_user(buf + sizeof(hdr), pp->buffer, size))\n\t\treturn -EFAULT;\n\tpp->busy = 0;\n\n\treturn rc;\n}\n\n\nstatic ssize_t smu_read_events(struct file *file, struct smu_private *pp,\n\t\t\t       char __user *buf, size_t count)\n{\n\t \n\tmsleep_interruptible(1000);\n\treturn 0;\n}\n\n\nstatic ssize_t smu_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smu_private *pp = file->private_data;\n\n\tif (pp->mode == smu_file_commands)\n\t\treturn smu_read_command(file, pp, buf, count);\n\tif (pp->mode == smu_file_events)\n\t\treturn smu_read_events(file, pp, buf, count);\n\n\treturn -EBADFD;\n}\n\nstatic __poll_t smu_fpoll(struct file *file, poll_table *wait)\n{\n\tstruct smu_private *pp = file->private_data;\n\t__poll_t mask = 0;\n\tunsigned long flags;\n\n\tif (!pp)\n\t\treturn 0;\n\n\tif (pp->mode == smu_file_commands) {\n\t\tpoll_wait(file, &pp->wait, wait);\n\n\t\tspin_lock_irqsave(&pp->lock, flags);\n\t\tif (pp->busy && pp->cmd.status != 1)\n\t\t\tmask |= EPOLLIN;\n\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t}\n\tif (pp->mode == smu_file_events) {\n\t\t \n\t}\n\treturn mask;\n}\n\nstatic int smu_release(struct inode *inode, struct file *file)\n{\n\tstruct smu_private *pp = file->private_data;\n\tunsigned long flags;\n\tunsigned int busy;\n\n\tif (!pp)\n\t\treturn 0;\n\n\tfile->private_data = NULL;\n\n\t \n\tspin_lock_irqsave(&pp->lock, flags);\n\tpp->mode = smu_file_closing;\n\tbusy = pp->busy;\n\n\t \n\tif (busy && pp->cmd.status == 1) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\tadd_wait_queue(&pp->wait, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (pp->cmd.status != 1)\n\t\t\t\tbreak;\n\t\t\tspin_unlock_irqrestore(&pp->lock, flags);\n\t\t\tschedule();\n\t\t\tspin_lock_irqsave(&pp->lock, flags);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&pp->wait, &wait);\n\t}\n\tspin_unlock_irqrestore(&pp->lock, flags);\n\n\tspin_lock_irqsave(&smu_clist_lock, flags);\n\tlist_del(&pp->list);\n\tspin_unlock_irqrestore(&smu_clist_lock, flags);\n\tkfree(pp);\n\n\treturn 0;\n}\n\n\nstatic const struct file_operations smu_device_fops = {\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= smu_read,\n\t.write\t\t= smu_write,\n\t.poll\t\t= smu_fpoll,\n\t.open\t\t= smu_open,\n\t.release\t= smu_release,\n};\n\nstatic struct miscdevice pmu_device = {\n\tMISC_DYNAMIC_MINOR, \"smu\", &smu_device_fops\n};\n\nstatic int smu_device_init(void)\n{\n\tif (!smu)\n\t\treturn -ENODEV;\n\tif (misc_register(&pmu_device) < 0)\n\t\tprintk(KERN_ERR \"via-pmu: cannot register misc device.\\n\");\n\treturn 0;\n}\ndevice_initcall(smu_device_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}