{
  "module_name": "windfarm_ad7417_sensor.c",
  "hash_id": "bbc79b7553415badf233dfce71e403ed6a0740077385d43d3ed69fa7914873ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_ad7417_sensor.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <linux/i2c.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_mpu.h\"\n\n#define VERSION \"1.0\"\n\nstruct wf_ad7417_priv {\n\tstruct kref\t\tref;\n\tstruct i2c_client\t*i2c;\n\tu8\t\t\tconfig;\n\tu8\t\t\tcpu;\n\tconst struct mpu_data\t*mpu;\n\tstruct wf_sensor\tsensors[5];\n\tstruct mutex\t\tlock;\n};\n\nstatic int wf_ad7417_temp_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct wf_ad7417_priv *pv = sr->priv;\n\tu8 buf[2];\n\ts16 raw;\n\tint rc;\n\n\t*value = 0;\n\tmutex_lock(&pv->lock);\n\n\t \n\tbuf[0] = 0;\n\trc = i2c_master_send(pv->i2c, buf, 1);\n\tif (rc < 0)\n\t\tgoto error;\n\trc = i2c_master_recv(pv->i2c, buf, 2);\n\tif (rc < 0)\n\t\tgoto error;\n\n\t \n\traw = be16_to_cpup((__le16 *)buf);\n\n\t \n\t*value = ((s32)raw) << 8;\n\n\tmutex_unlock(&pv->lock);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&pv->lock);\n\treturn -1;\n}\n\n \n#define ADC_12V_CURRENT_SCALE\t0x0320\t \n#define ADC_CPU_VOLTAGE_SCALE\t0x00a0\t \n#define ADC_CPU_CURRENT_SCALE\t0x1f40\t \n\nstatic void wf_ad7417_adc_convert(struct wf_ad7417_priv *pv,\n\t\t\t\t  int chan, s32 raw, s32 *value)\n{\n\tswitch(chan) {\n\tcase 1:  \n\t\t*value = (raw * (s32)pv->mpu->mdiode +\n\t\t\t((s32)pv->mpu->bdiode << 12)) >> 2;\n\t\tbreak;\n\tcase 2:  \n\t\t*value = raw * ADC_12V_CURRENT_SCALE;\n\t\tbreak;\n\tcase 3:  \n\t\t*value = raw * ADC_CPU_VOLTAGE_SCALE;\n\t\tbreak;\n\tcase 4:  \n\t\t*value = raw * ADC_CPU_CURRENT_SCALE;\n\t\tbreak;\n\t}\n}\n\nstatic int wf_ad7417_adc_get(struct wf_sensor *sr, s32 *value)\n{\n\tstruct wf_ad7417_priv *pv = sr->priv;\n\tint chan = sr - pv->sensors;\n\tint i, rc;\n\tu8 buf[2];\n\tu16 raw;\n\n\t*value = 0;\n\tmutex_lock(&pv->lock);\n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tbuf[0] = 1;\n\t\tbuf[1] = (pv->config & 0x1f) | (chan << 5);\n\t\trc = i2c_master_send(pv->i2c, buf, 2);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tmsleep(1);\n\n\t\t \n\t\tbuf[0] = 4;\n\t\trc = i2c_master_send(pv->i2c, buf, 1);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\trc = i2c_master_recv(pv->i2c, buf, 2);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\traw = be16_to_cpup((__le16 *)buf) >> 6;\n\t\twf_ad7417_adc_convert(pv, chan, raw, value);\n\n\t\tdev_vdbg(&pv->i2c->dev, \"ADC chan %d [%s]\"\n\t\t\t \" raw value: 0x%x, conv to: 0x%08x\\n\",\n\t\t\t chan, sr->name, raw, *value);\n\n\t\tmutex_unlock(&pv->lock);\n\t\treturn 0;\n\n\terror:\n\t\tdev_dbg(&pv->i2c->dev,\n\t\t\t  \"Error reading ADC, try %d...\\n\", i);\n\t\tif (i < 9)\n\t\t\tmsleep(10);\n\t}\n\tmutex_unlock(&pv->lock);\n\treturn -1;\n}\n\nstatic void wf_ad7417_release(struct kref *ref)\n{\n\tstruct wf_ad7417_priv *pv = container_of(ref,\n\t\t\t\t\t\t struct wf_ad7417_priv, ref);\n\tkfree(pv);\n}\n\nstatic void wf_ad7417_sensor_release(struct wf_sensor *sr)\n{\n\tstruct wf_ad7417_priv *pv = sr->priv;\n\n\tkfree(sr->name);\n\tkref_put(&pv->ref, wf_ad7417_release);\n}\n\nstatic const struct wf_sensor_ops wf_ad7417_temp_ops = {\n\t.get_value\t= wf_ad7417_temp_get,\n\t.release\t= wf_ad7417_sensor_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct wf_sensor_ops wf_ad7417_adc_ops = {\n\t.get_value\t= wf_ad7417_adc_get,\n\t.release\t= wf_ad7417_sensor_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void wf_ad7417_add_sensor(struct wf_ad7417_priv *pv,\n\t\t\t\t int index, const char *name,\n\t\t\t\t const struct wf_sensor_ops *ops)\n{\n\tpv->sensors[index].name = kasprintf(GFP_KERNEL, \"%s-%d\", name, pv->cpu);\n\tpv->sensors[index].priv = pv;\n\tpv->sensors[index].ops = ops;\n\tif (!wf_register_sensor(&pv->sensors[index]))\n\t\tkref_get(&pv->ref);\n}\n\nstatic void wf_ad7417_init_chip(struct wf_ad7417_priv *pv)\n{\n\tint rc;\n\tu8 buf[2];\n\tu8 config = 0;\n\n\t \n\n\t \n\tbuf[0] = 5;\n\tbuf[1] = 0;\n\ti2c_master_send(pv->i2c, buf, 2);\n\n\t \n\tbuf[0] = 1;\n\trc = i2c_master_send(pv->i2c, buf, 1);\n\tif (rc > 0) {\n\t\trc = i2c_master_recv(pv->i2c, buf, 1);\n\t\tif (rc > 0) {\n\t\t\tconfig = buf[0];\n\n\t\t\tdev_dbg(&pv->i2c->dev, \"ADC config reg: %02x\\n\",\n\t\t\t\tconfig);\n\n\t\t\t \n\t\t\tconfig &= 0xfe;\n\t\t\tbuf[0] = 1;\n\t\t\tbuf[1] = config;\n\t\t\trc = i2c_master_send(pv->i2c, buf, 2);\n\t\t}\n\t}\n\tif (rc <= 0)\n\t\tdev_err(&pv->i2c->dev, \"Error reading ADC config\\n\");\n\n\tpv->config = config;\n}\n\nstatic int wf_ad7417_probe(struct i2c_client *client)\n{\n\tstruct wf_ad7417_priv *pv;\n\tconst struct mpu_data *mpu;\n\tconst char *loc;\n\tint cpu_nr;\n\n\tloc = of_get_property(client->dev.of_node, \"hwsensor-location\", NULL);\n\tif (!loc) {\n\t\tdev_warn(&client->dev, \"Missing hwsensor-location property!\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (!strncmp(loc, \"CPU A\", 5))\n\t\tcpu_nr = 0;\n\telse if (!strncmp(loc, \"CPU B\", 5))\n\t\tcpu_nr = 1;\n\telse {\n\t\tpr_err(\"wf_ad7417: Can't identify location %s\\n\", loc);\n\t\treturn -ENXIO;\n\t}\n\tmpu = wf_get_mpu(cpu_nr);\n\tif (!mpu) {\n\t\tdev_err(&client->dev, \"Failed to retrieve MPU data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpv = kzalloc(sizeof(struct wf_ad7417_priv), GFP_KERNEL);\n\tif (pv == NULL)\n\t\treturn -ENODEV;\n\n\tkref_init(&pv->ref);\n\tmutex_init(&pv->lock);\n\tpv->i2c = client;\n\tpv->cpu = cpu_nr;\n\tpv->mpu = mpu;\n\tdev_set_drvdata(&client->dev, pv);\n\n\t \n\twf_ad7417_init_chip(pv);\n\n\t \n\twf_ad7417_add_sensor(pv, 0, \"cpu-amb-temp\", &wf_ad7417_temp_ops);\n\twf_ad7417_add_sensor(pv, 1, \"cpu-diode-temp\", &wf_ad7417_adc_ops);\n\twf_ad7417_add_sensor(pv, 2, \"cpu-12v-current\", &wf_ad7417_adc_ops);\n\twf_ad7417_add_sensor(pv, 3, \"cpu-voltage\", &wf_ad7417_adc_ops);\n\twf_ad7417_add_sensor(pv, 4, \"cpu-current\", &wf_ad7417_adc_ops);\n\n\treturn 0;\n}\n\nstatic void wf_ad7417_remove(struct i2c_client *client)\n{\n\tstruct wf_ad7417_priv *pv = dev_get_drvdata(&client->dev);\n\tint i;\n\n\t \n\tpv->i2c = NULL;\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\twf_unregister_sensor(&pv->sensors[i]);\n\n\tkref_put(&pv->ref, wf_ad7417_release);\n}\n\nstatic const struct i2c_device_id wf_ad7417_id[] = {\n\t{ \"MAC,ad7417\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wf_ad7417_id);\n\nstatic const struct of_device_id wf_ad7417_of_id[] = {\n\t{ .compatible = \"ad7417\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wf_ad7417_of_id);\n\nstatic struct i2c_driver wf_ad7417_driver = {\n\t.driver = {\n\t\t.name\t= \"wf_ad7417\",\n\t\t.of_match_table = wf_ad7417_of_id,\n\t},\n\t.probe\t\t= wf_ad7417_probe,\n\t.remove\t\t= wf_ad7417_remove,\n\t.id_table\t= wf_ad7417_id,\n};\n\nstatic int wf_ad7417_init(void)\n{\n\t \n\tif (!of_machine_is_compatible(\"PowerMac7,2\") &&\n\t    !of_machine_is_compatible(\"PowerMac7,3\") &&\n\t    !of_machine_is_compatible(\"RackMac3,1\"))\n\t\treturn -ENODEV;\n\n\treturn i2c_add_driver(&wf_ad7417_driver);\n}\n\nstatic void wf_ad7417_exit(void)\n{\n\ti2c_del_driver(&wf_ad7417_driver);\n}\n\nmodule_init(wf_ad7417_init);\nmodule_exit(wf_ad7417_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"ad7417 sensor driver for PowerMacs\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}