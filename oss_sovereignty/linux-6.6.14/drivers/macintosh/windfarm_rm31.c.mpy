{
  "module_name": "windfarm_rm31.c",
  "hash_id": "711f60262026433f5ab77db68db96b2a987e29c9075576b602c00c0aac656e93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_rm31.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_pid.h\"\n#include \"windfarm_mpu.h\"\n\n#define VERSION \"1.0\"\n\n#undef DEBUG\n#undef LOTSA_DEBUG\n\n#ifdef DEBUG\n#define DBG(args...)\tprintk(args)\n#else\n#define DBG(args...)\tdo { } while(0)\n#endif\n\n#ifdef LOTSA_DEBUG\n#define DBG_LOTS(args...)\tprintk(args)\n#else\n#define DBG_LOTS(args...)\tdo { } while(0)\n#endif\n\n \n#undef HACKED_OVERTEMP\n\n \n#define NR_CHIPS\t2\n#define NR_CPU_FANS\t3 * NR_CHIPS\n\n \nstatic struct wf_sensor *sens_cpu_temp[NR_CHIPS];\nstatic struct wf_sensor *sens_cpu_volts[NR_CHIPS];\nstatic struct wf_sensor *sens_cpu_amps[NR_CHIPS];\nstatic struct wf_sensor *backside_temp;\nstatic struct wf_sensor *slots_temp;\nstatic struct wf_sensor *dimms_temp;\n\nstatic struct wf_control *cpu_fans[NR_CHIPS][3];\nstatic struct wf_control *backside_fan;\nstatic struct wf_control *slots_fan;\nstatic struct wf_control *cpufreq_clamp;\n\n \n#define CPU_TEMP_HIST_SIZE\t180\n\n \nstatic const struct mpu_data *cpu_mpu_data[NR_CHIPS];\nstatic struct wf_cpu_pid_state cpu_pid[NR_CHIPS];\nstatic u32 cpu_thist[CPU_TEMP_HIST_SIZE];\nstatic int cpu_thist_pt;\nstatic s64 cpu_thist_total;\nstatic s32 cpu_all_tmax = 100 << 16;\nstatic struct wf_pid_state backside_pid;\nstatic int backside_tick;\nstatic struct wf_pid_state slots_pid;\nstatic int slots_tick;\nstatic int slots_speed;\nstatic struct wf_pid_state dimms_pid;\nstatic int dimms_output_clamp;\n\nstatic int nr_chips;\nstatic bool have_all_controls;\nstatic bool have_all_sensors;\nstatic bool started;\n\nstatic int failure_state;\n#define FAILURE_SENSOR\t\t1\n#define FAILURE_FAN\t\t2\n#define FAILURE_PERM\t\t4\n#define FAILURE_LOW_OVERTEMP\t8\n#define FAILURE_HIGH_OVERTEMP\t16\n\n \n#define LOW_OVER_AVERAGE\t0\n#define LOW_OVER_IMMEDIATE\t(10 << 16)\n#define LOW_OVER_CLEAR\t\t((-10) << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n#define HIGH_OVER_AVERAGE\t(10 << 16)\n#define HIGH_OVER_IMMEDIATE\t(14 << 16)\n\n\nstatic void cpu_max_all_fans(void)\n{\n\tint i;\n\n\t \n\tif (cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tfor (i = 0; i < nr_chips; i++) {\n\t\tif (cpu_fans[i][0])\n\t\t\twf_control_set_max(cpu_fans[i][0]);\n\t\tif (cpu_fans[i][1])\n\t\t\twf_control_set_max(cpu_fans[i][1]);\n\t\tif (cpu_fans[i][2])\n\t\t\twf_control_set_max(cpu_fans[i][2]);\n\t}\n}\n\nstatic int cpu_check_overtemp(s32 temp)\n{\n\tint new_state = 0;\n\ts32 t_avg, t_old;\n\tstatic bool first = true;\n\n\t \n\tif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to immediate CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" immediate CPU temperature !\\n\");\n\t}\n\n\t \n\tif (first) {\n\t\tint i;\n\n\t\tcpu_thist_total = 0;\n\t\tfor (i = 0; i < CPU_TEMP_HIST_SIZE; i++) {\n\t\t\tcpu_thist[i] = temp;\n\t\t\tcpu_thist_total += temp;\n\t\t}\n\t\tfirst = false;\n\t}\n\n\t \n\tt_old = cpu_thist[cpu_thist_pt];\n\tcpu_thist[cpu_thist_pt] = temp;\n\tcpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\n\tcpu_thist_total -= t_old;\n\tcpu_thist_total += temp;\n\tt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\n\n\tDBG_LOTS(\"  t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\\n\",\n\t\t FIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\n\n\t \n\tif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_LOW_OVERTEMP;\n\t\tif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Overtemp due to average CPU\"\n\t\t\t       \" temperature !\\n\");\n\t}\n\tif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\n\t\tnew_state |= FAILURE_HIGH_OVERTEMP;\n\t\tif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\n\t\t\tprintk(KERN_ERR \"windfarm: Critical overtemp due to\"\n\t\t\t       \" average CPU temperature !\\n\");\n\t}\n\n\t \n\tif (new_state) {\n\t\t \n\t\tif (new_state & FAILURE_HIGH_OVERTEMP)\n\t\t\tmachine_power_off();\n\t\tif ((failure_state & new_state) != new_state)\n\t\t\tcpu_max_all_fans();\n\t\tfailure_state |= new_state;\n\t} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\n\t\t   (temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\n\t\tprintk(KERN_ERR \"windfarm: Overtemp condition cleared !\\n\");\n\t\tfailure_state &= ~FAILURE_LOW_OVERTEMP;\n\t}\n\n\treturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\n}\n\nstatic int read_one_cpu_vals(int cpu, s32 *temp, s32 *power)\n{\n\ts32 dtemp, volts, amps;\n\tint rc;\n\n\t \n\trc = wf_sensor_get(sens_cpu_temp[cpu], &dtemp);\n\tif (rc) {\n\t\tDBG(\"  CPU%d: temp reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: temp   = %d.%03d\\n\", cpu, FIX32TOPRINT((dtemp)));\n\t*temp = dtemp;\n\n\t \n\trc = wf_sensor_get(sens_cpu_volts[cpu], &volts);\n\tif (rc) {\n\t\tDBG(\"  CPU%d, volts reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: volts  = %d.%03d\\n\", cpu, FIX32TOPRINT((volts)));\n\n\t \n\trc = wf_sensor_get(sens_cpu_amps[cpu], &amps);\n\tif (rc) {\n\t\tDBG(\"  CPU%d, current reading error !\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\tDBG_LOTS(\"  CPU%d: amps   = %d.%03d\\n\", cpu, FIX32TOPRINT((amps)));\n\n\t \n\n\t \n\t*power = (((u64)volts) * ((u64)amps)) >> 16;\n\n\tDBG_LOTS(\"  CPU%d: power  = %d.%03d\\n\", cpu, FIX32TOPRINT((*power)));\n\n\treturn 0;\n\n}\n\nstatic void cpu_fans_tick(void)\n{\n\tint err, cpu, i;\n\ts32 speed, temp, power, t_max = 0;\n\n\tDBG_LOTS(\"* cpu fans_tick_split()\\n\");\n\n\tfor (cpu = 0; cpu < nr_chips; ++cpu) {\n\t\tstruct wf_cpu_pid_state *sp = &cpu_pid[cpu];\n\n\t\t \n\t\twf_control_get(cpu_fans[cpu][0], &sp->target);\n\n\t\terr = read_one_cpu_vals(cpu, &temp, &power);\n\t\tif (err) {\n\t\t\tfailure_state |= FAILURE_SENSOR;\n\t\t\tcpu_max_all_fans();\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tt_max = max(t_max, temp);\n\n\t\t \n\t\tif (cpu_check_overtemp(t_max))\n\t\t\treturn;\n\n\t\t \n\t\twf_cpu_pid_run(sp, power, temp);\n\n\t\tDBG_LOTS(\"  CPU%d: target = %d RPM\\n\", cpu, sp->target);\n\n\t\t \n\t\tspeed = max(sp->target, dimms_output_clamp);\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\terr = wf_control_set(cpu_fans[cpu][i], speed);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"wf_rm31: Fan %s reports error %d\\n\",\n\t\t\t\t\tcpu_fans[cpu][i]->name, err);\n\t\t\t\tfailure_state |= FAILURE_FAN;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int cpu_setup_pid(int cpu)\n{\n\tstruct wf_cpu_pid_param pid;\n\tconst struct mpu_data *mpu = cpu_mpu_data[cpu];\n\ts32 tmax, ttarget, ptarget;\n\tint fmin, fmax, hsize;\n\n\t \n\ttmax = mpu->tmax << 16;\n\tttarget = mpu->ttarget << 16;\n\tptarget = ((s32)(mpu->pmaxh - mpu->padjmax)) << 16;\n\n\tDBG(\"wf_72: CPU%d ttarget = %d.%03d, tmax = %d.%03d\\n\",\n\t    cpu, FIX32TOPRINT(ttarget), FIX32TOPRINT(tmax));\n\n\t \n\tif (tmax < cpu_all_tmax)\n\t\tcpu_all_tmax = tmax;\n\n\t \n\tfmin = wf_control_get_min(cpu_fans[cpu][0]);\n\tfmax = wf_control_get_max(cpu_fans[cpu][0]);\n\tDBG(\"wf_72: CPU%d max RPM range = [%d..%d]\\n\", cpu, fmin, fmax);\n\n\t \n\thsize = min_t(int, mpu->tguardband, WF_PID_MAX_HISTORY);\n\tDBG(\"wf_72: CPU%d history size = %d\\n\", cpu, hsize);\n\n\t \n\tpid.interval\t= 1;\t \n\tpid.history_len = hsize;\n\tpid.gd\t\t= mpu->pid_gd;\n\tpid.gp\t\t= mpu->pid_gp;\n\tpid.gr\t\t= mpu->pid_gr;\n\tpid.tmax\t= tmax;\n\tpid.ttarget\t= ttarget;\n\tpid.pmaxadj\t= ptarget;\n\tpid.min\t\t= fmin;\n\tpid.max\t\t= fmax;\n\n\twf_cpu_pid_init(&cpu_pid[cpu], &pid);\n\tcpu_pid[cpu].target = 4000;\n\t\n\treturn 0;\n}\n\n \nstatic const struct wf_pid_param backside_param = {\n\t.interval\t= 1,\n\t.history_len\t= 2,\n\t.gd\t\t= 0x00500000,\n\t.gp\t\t= 0x0004cccc,\n\t.gr\t\t= 0,\n\t.itarget\t= 70 << 16,\n\t.additive\t= 0,\n\t.min\t\t= 20,\n\t.max\t\t= 100,\n};\n\n \nstatic const struct wf_pid_param dimms_param = {\n\t.interval\t= 1,\n\t.history_len\t= 20,\n\t.gd\t\t= 0,\n\t.gp\t\t= 0,\n\t.gr\t\t= 0x06553600,\n\t.itarget\t= 50 << 16,\n\t.additive\t= 0,\n\t.min\t\t= 4000,\n\t.max\t\t= 14000,\n};\n\nstatic void backside_fan_tick(void)\n{\n\ts32 temp, dtemp;\n\tint speed, dspeed, fan_min;\n\tint err;\n\n\tif (!backside_fan || !backside_temp || !dimms_temp || !backside_tick)\n\t\treturn;\n\tif (--backside_tick > 0)\n\t\treturn;\n\tbackside_tick = backside_pid.param.interval;\n\n\tDBG_LOTS(\"* backside fans tick\\n\");\n\n\t \n\terr = wf_control_get(backside_fan, &speed);\n\tif (!err)\n\t\tbackside_pid.target = speed;\n\n\terr = wf_sensor_get(backside_temp, &temp);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: U3 temp sensor error %d\\n\",\n\t\t       err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(backside_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&backside_pid, temp);\n\n\tDBG_LOTS(\"backside PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\terr = wf_sensor_get(dimms_temp, &dtemp);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: DIMMs temp sensor error %d\\n\",\n\t\t       err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(backside_fan);\n\t\treturn;\n\t}\n\tdspeed = wf_pid_run(&dimms_pid, dtemp);\n\tdimms_output_clamp = dspeed;\n\n\tfan_min = (dspeed * 100) / 14000;\n\tfan_min = max(fan_min, backside_param.min);\n\tspeed = max(speed, fan_min);\n\n\terr = wf_control_set(backside_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: backside fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\nstatic void backside_setup_pid(void)\n{\n\t \n\ts32 fmin = wf_control_get_min(backside_fan);\n\ts32 fmax = wf_control_get_max(backside_fan);\n\tstruct wf_pid_param param;\n\n\tparam = backside_param;\n\tparam.min = max(param.min, fmin);\n\tparam.max = min(param.max, fmax);\n\twf_pid_init(&backside_pid, &param);\n\n\tparam = dimms_param;\n\twf_pid_init(&dimms_pid, &param);\n\n\tbackside_tick = 1;\n\n\tpr_info(\"wf_rm31: Backside control loop started.\\n\");\n}\n\n \nstatic const struct wf_pid_param slots_param = {\n\t.interval\t= 1,\n\t.history_len\t= 20,\n\t.gd\t\t= 0,\n\t.gp\t\t= 0,\n\t.gr\t\t= 0x00100000,\n\t.itarget\t= 3200000,\n\t.additive\t= 0,\n\t.min\t\t= 20,\n\t.max\t\t= 100,\n};\n\nstatic void slots_fan_tick(void)\n{\n\ts32 temp;\n\tint speed;\n\tint err;\n\n\tif (!slots_fan || !slots_temp || !slots_tick)\n\t\treturn;\n\tif (--slots_tick > 0)\n\t\treturn;\n\tslots_tick = slots_pid.param.interval;\n\n\tDBG_LOTS(\"* slots fans tick\\n\");\n\n\terr = wf_sensor_get(slots_temp, &temp);\n\tif (err) {\n\t\tpr_warn(\"wf_rm31: slots temp sensor error %d\\n\", err);\n\t\tfailure_state |= FAILURE_SENSOR;\n\t\twf_control_set_max(slots_fan);\n\t\treturn;\n\t}\n\tspeed = wf_pid_run(&slots_pid, temp);\n\n\tDBG_LOTS(\"slots PID temp=%d.%.3d speed=%d\\n\",\n\t\t FIX32TOPRINT(temp), speed);\n\n\tslots_speed = speed;\n\terr = wf_control_set(slots_fan, speed);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"windfarm: slots bay fan error %d\\n\", err);\n\t\tfailure_state |= FAILURE_FAN;\n\t}\n}\n\nstatic void slots_setup_pid(void)\n{\n\t \n\ts32 fmin = wf_control_get_min(slots_fan);\n\ts32 fmax = wf_control_get_max(slots_fan);\n\tstruct wf_pid_param param = slots_param;\n\n\tparam.min = max(param.min, fmin);\n\tparam.max = min(param.max, fmax);\n\twf_pid_init(&slots_pid, &param);\n\tslots_tick = 1;\n\n\tpr_info(\"wf_rm31: Slots control loop started.\\n\");\n}\n\nstatic void set_fail_state(void)\n{\n\tcpu_max_all_fans();\n\n\tif (backside_fan)\n\t\twf_control_set_max(backside_fan);\n\tif (slots_fan)\n\t\twf_control_set_max(slots_fan);\n}\n\nstatic void rm31_tick(void)\n{\n\tint i, last_failure;\n\n\tif (!started) {\n\t\tstarted = true;\n\t\tprintk(KERN_INFO \"windfarm: CPUs control loops started.\\n\");\n\t\tfor (i = 0; i < nr_chips; ++i) {\n\t\t\tif (cpu_setup_pid(i) < 0) {\n\t\t\t\tfailure_state = FAILURE_PERM;\n\t\t\t\tset_fail_state();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDBG_LOTS(\"cpu_all_tmax=%d.%03d\\n\", FIX32TOPRINT(cpu_all_tmax));\n\n\t\tbackside_setup_pid();\n\t\tslots_setup_pid();\n\n#ifdef HACKED_OVERTEMP\n\t\tcpu_all_tmax = 60 << 16;\n#endif\n\t}\n\n\t \n\tif (failure_state & FAILURE_PERM)\n\t\treturn;\n\n\t \n\tlast_failure = failure_state;\n\tfailure_state &= FAILURE_LOW_OVERTEMP;\n\tbackside_fan_tick();\n\tslots_fan_tick();\n\n\t \n\tcpu_fans_tick();\n\n\tDBG_LOTS(\"  last_failure: 0x%x, failure_state: %x\\n\",\n\t\t last_failure, failure_state);\n\n\t \n\tif (failure_state && last_failure == 0 && cpufreq_clamp)\n\t\twf_control_set_max(cpufreq_clamp);\n\tif (failure_state == 0 && last_failure && cpufreq_clamp)\n\t\twf_control_set_min(cpufreq_clamp);\n\n\t \n}\n\nstatic void rm31_new_control(struct wf_control *ct)\n{\n\tbool all_controls;\n\n\tif (!strcmp(ct->name, \"cpu-fan-a-0\"))\n\t\tcpu_fans[0][0] = ct;\n\telse if (!strcmp(ct->name, \"cpu-fan-b-0\"))\n\t\tcpu_fans[0][1] = ct;\n\telse if (!strcmp(ct->name, \"cpu-fan-c-0\"))\n\t\tcpu_fans[0][2] = ct;\n\telse if (!strcmp(ct->name, \"cpu-fan-a-1\"))\n\t\tcpu_fans[1][0] = ct;\n\telse if (!strcmp(ct->name, \"cpu-fan-b-1\"))\n\t\tcpu_fans[1][1] = ct;\n\telse if (!strcmp(ct->name, \"cpu-fan-c-1\"))\n\t\tcpu_fans[1][2] = ct;\n\telse if (!strcmp(ct->name, \"backside-fan\"))\n\t\tbackside_fan = ct;\n\telse if (!strcmp(ct->name, \"slots-fan\"))\n\t\tslots_fan = ct;\n\telse if (!strcmp(ct->name, \"cpufreq-clamp\"))\n\t\tcpufreq_clamp = ct;\n\n\tall_controls =\n\t\tcpu_fans[0][0] &&\n\t\tcpu_fans[0][1] &&\n\t\tcpu_fans[0][2] &&\n\t\tbackside_fan &&\n\t\tslots_fan;\n\tif (nr_chips > 1)\n\t\tall_controls &=\n\t\t\tcpu_fans[1][0] &&\n\t\t\tcpu_fans[1][1] &&\n\t\t\tcpu_fans[1][2];\n\thave_all_controls = all_controls;\n}\n\n\nstatic void rm31_new_sensor(struct wf_sensor *sr)\n{\n\tbool all_sensors;\n\n\tif (!strcmp(sr->name, \"cpu-diode-temp-0\"))\n\t\tsens_cpu_temp[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-diode-temp-1\"))\n\t\tsens_cpu_temp[1] = sr;\n\telse if (!strcmp(sr->name, \"cpu-voltage-0\"))\n\t\tsens_cpu_volts[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-voltage-1\"))\n\t\tsens_cpu_volts[1] = sr;\n\telse if (!strcmp(sr->name, \"cpu-current-0\"))\n\t\tsens_cpu_amps[0] = sr;\n\telse if (!strcmp(sr->name, \"cpu-current-1\"))\n\t\tsens_cpu_amps[1] = sr;\n\telse if (!strcmp(sr->name, \"backside-temp\"))\n\t\tbackside_temp = sr;\n\telse if (!strcmp(sr->name, \"slots-temp\"))\n\t\tslots_temp = sr;\n\telse if (!strcmp(sr->name, \"dimms-temp\"))\n\t\tdimms_temp = sr;\n\n\tall_sensors =\n\t\tsens_cpu_temp[0] &&\n\t\tsens_cpu_volts[0] &&\n\t\tsens_cpu_amps[0] &&\n\t\tbackside_temp &&\n\t\tslots_temp &&\n\t\tdimms_temp;\n\tif (nr_chips > 1)\n\t\tall_sensors &=\n\t\t\tsens_cpu_temp[1] &&\n\t\t\tsens_cpu_volts[1] &&\n\t\t\tsens_cpu_amps[1];\n\n\thave_all_sensors = all_sensors;\n}\n\nstatic int rm31_wf_notify(struct notifier_block *self,\n\t\t\t  unsigned long event, void *data)\n{\n\tswitch (event) {\n\tcase WF_EVENT_NEW_SENSOR:\n\t\trm31_new_sensor(data);\n\t\tbreak;\n\tcase WF_EVENT_NEW_CONTROL:\n\t\trm31_new_control(data);\n\t\tbreak;\n\tcase WF_EVENT_TICK:\n\t\tif (have_all_controls && have_all_sensors)\n\t\t\trm31_tick();\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block rm31_events = {\n\t.notifier_call = rm31_wf_notify,\n};\n\nstatic int wf_rm31_probe(struct platform_device *dev)\n{\n\twf_register_client(&rm31_events);\n\treturn 0;\n}\n\nstatic int wf_rm31_remove(struct platform_device *dev)\n{\n\twf_unregister_client(&rm31_events);\n\n\t \n\treturn 0;\n}\n\nstatic struct platform_driver wf_rm31_driver = {\n\t.probe\t= wf_rm31_probe,\n\t.remove\t= wf_rm31_remove,\n\t.driver\t= {\n\t\t.name = \"windfarm\",\n\t},\n};\n\nstatic int __init wf_rm31_init(void)\n{\n\tstruct device_node *cpu;\n\tint i;\n\n\tif (!of_machine_is_compatible(\"RackMac3,1\"))\n\t\treturn -ENODEV;\n\n\t \n\tnr_chips = 0;\n\tfor_each_node_by_type(cpu, \"cpu\")\n\t\t++nr_chips;\n\tif (nr_chips > NR_CHIPS)\n\t\tnr_chips = NR_CHIPS;\n\n\tpr_info(\"windfarm: Initializing for desktop G5 with %d chips\\n\",\n\t\tnr_chips);\n\n\t \n\tfor (i = 0; i < nr_chips; i++) {\n\t\tcpu_mpu_data[i] = wf_get_mpu(i);\n\t\tif (!cpu_mpu_data[i]) {\n\t\t\tpr_err(\"wf_rm31: Failed to find MPU data for CPU %d\\n\", i);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n#ifdef MODULE\n\trequest_module(\"windfarm_fcu_controls\");\n\trequest_module(\"windfarm_lm75_sensor\");\n\trequest_module(\"windfarm_lm87_sensor\");\n\trequest_module(\"windfarm_ad7417_sensor\");\n\trequest_module(\"windfarm_max6690_sensor\");\n\trequest_module(\"windfarm_cpufreq_clamp\");\n#endif  \n\n\tplatform_driver_register(&wf_rm31_driver);\n\treturn 0;\n}\n\nstatic void __exit wf_rm31_exit(void)\n{\n\tplatform_driver_unregister(&wf_rm31_driver);\n}\n\nmodule_init(wf_rm31_init);\nmodule_exit(wf_rm31_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Thermal control for Xserve G5\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:windfarm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}