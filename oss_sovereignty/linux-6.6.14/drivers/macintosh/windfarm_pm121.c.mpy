{
  "module_name": "windfarm_pm121.c",
  "hash_id": "45ce21fa258c5fe18daace83548a0a0c8be824d1ac7a22302249c5e3aa0aeb24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/windfarm_pm121.c",
  "human_readable_source": "\n \n\n#undef\tDEBUG\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/smu.h>\n\n#include \"windfarm.h\"\n#include \"windfarm_pid.h\"\n\n#define VERSION \"0.3\"\n\nstatic int pm121_mach_model;\t \n\n \nstatic struct wf_sensor\t*sensor_cpu_power;\nstatic struct wf_sensor\t*sensor_cpu_temp;\nstatic struct wf_sensor\t*sensor_cpu_voltage;\nstatic struct wf_sensor\t*sensor_cpu_current;\nstatic struct wf_sensor\t*sensor_gpu_temp;\nstatic struct wf_sensor\t*sensor_north_bridge_temp;\nstatic struct wf_sensor\t*sensor_hard_drive_temp;\nstatic struct wf_sensor\t*sensor_optical_drive_temp;\nstatic struct wf_sensor\t*sensor_incoming_air_temp;  \n\nenum {\n\tFAN_CPU,\n\tFAN_HD,\n\tFAN_OD,\n\tCPUFREQ,\n\tN_CONTROLS\n};\nstatic struct wf_control *controls[N_CONTROLS] = {};\n\n \nstatic int pm121_all_controls_ok, pm121_all_sensors_ok;\nstatic bool pm121_started;\n\nenum {\n\tFAILURE_FAN\t\t= 1 << 0,\n\tFAILURE_SENSOR\t\t= 1 << 1,\n\tFAILURE_OVERTEMP\t= 1 << 2\n};\n\n \nenum {\n\tLOOP_GPU,\t\t \n\tLOOP_HD,\t\t \n\tLOOP_KODIAK,\t\t \n\tLOOP_OD,\t\t \n\tN_LOOPS\n};\n\nstatic const char *loop_names[N_LOOPS] = {\n\t\"GPU\",\n\t\"HD\",\n\t\"KODIAK\",\n\t\"OD\",\n};\n\n#define\tPM121_NUM_CONFIGS\t2\n\nstatic unsigned int pm121_failure_state;\nstatic int pm121_readjust, pm121_skipping;\nstatic bool pm121_overtemp;\nstatic s32 average_power;\n\nstruct pm121_correction {\n\tint\toffset;\n\tint\tslope;\n};\n\nstatic struct pm121_correction corrections[N_CONTROLS][PM121_NUM_CONFIGS] = {\n\t \n\t{\n\t\t \n\t\t{ .offset\t= -19563152,\n\t\t  .slope\t=  1956315\n\t\t},\n\t\t \n\t\t{ .offset\t= -15650652,\n\t\t  .slope\t=  1565065\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{ .offset\t= -15650652,\n\t\t  .slope\t=  1565065\n\t\t},\n\t\t \n\t\t{ .offset\t= -19563152,\n\t\t  .slope\t=  1956315\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{ .offset\t= -25431900,\n\t\t  .slope\t=  2543190\n\t\t},\n\t\t \n\t\t{ .offset\t= -15650652,\n\t\t  .slope\t=  1565065\n\t\t},\n\t},\n\t \n};\n\nstruct pm121_connection {\n\tunsigned int\tcontrol_id;\n\tunsigned int\tref_id;\n\tstruct pm121_correction\tcorrection;\n};\n\nstatic struct pm121_connection pm121_connections[] = {\n\t \n\t{ .control_id\t= FAN_CPU,\n\t  .ref_id\t= FAN_OD,\n\t  { .offset\t= -32768000,\n\t    .slope\t=  65536\n\t  }\n\t},\n\t \n\t{ .control_id\t= FAN_OD,\n\t  .ref_id\t= FAN_HD,\n\t  { .offset\t= -32768000,\n\t    .slope\t=  65536\n\t  }\n\t},\n};\n\n \nstatic struct pm121_connection *pm121_connection;\n\n \n\n \nstruct pm121_sys_param {\n\t \n\tint\t\t\tmodel_id;\n\tstruct wf_sensor\t**sensor;  \n\ts32\t\t\tgp, itarget;\n\tunsigned int\t\tcontrol_id;\n};\n\nstatic struct pm121_sys_param\npm121_sys_all_params[N_LOOPS][PM121_NUM_CONFIGS] = {\n\t \n\t{\n\t\t{ .model_id\t= 2,\n\t\t  .sensor\t= &sensor_gpu_temp,\n\t\t  .gp\t\t= 0x002A6666,\n\t\t  .itarget\t= 0x5A0000,\n\t\t  .control_id\t= FAN_HD,\n\t\t},\n\t\t{ .model_id\t= 3,\n\t\t  .sensor\t= &sensor_gpu_temp,\n\t\t  .gp\t\t= 0x0010CCCC,\n\t\t  .itarget\t= 0x500000,\n\t\t  .control_id\t= FAN_CPU,\n\t\t},\n\t},\n\t \n\t{\n\t\t{ .model_id\t= 2,\n\t\t  .sensor\t= &sensor_hard_drive_temp,\n\t\t  .gp\t\t= 0x002D70A3,\n\t\t  .itarget\t= 0x370000,\n\t\t  .control_id\t= FAN_HD,\n\t\t},\n\t\t{ .model_id\t= 3,\n\t\t  .sensor\t= &sensor_hard_drive_temp,\n\t\t  .gp\t\t= 0x002170A3,\n\t\t  .itarget\t= 0x370000,\n\t\t  .control_id\t= FAN_HD,\n\t\t},\n\t},\n\t \n\t{\n\t\t{ .model_id\t= 2,\n\t\t  .sensor\t= &sensor_north_bridge_temp,\n\t\t  .gp\t\t= 0x003BD70A,\n\t\t  .itarget\t= 0x550000,\n\t\t  .control_id\t= FAN_OD,\n\t\t},\n\t\t{ .model_id\t= 3,\n\t\t  .sensor\t= &sensor_north_bridge_temp,\n\t\t  .gp\t\t= 0x0030F5C2,\n\t\t  .itarget\t= 0x550000,\n\t\t  .control_id\t= FAN_HD,\n\t\t},\n\t},\n\t \n\t{\n\t\t{ .model_id\t= 2,\n\t\t  .sensor\t= &sensor_optical_drive_temp,\n\t\t  .gp\t\t= 0x001FAE14,\n\t\t  .itarget\t= 0x320000,\n\t\t  .control_id\t= FAN_OD,\n\t\t},\n\t\t{ .model_id\t= 3,\n\t\t  .sensor\t= &sensor_optical_drive_temp,\n\t\t  .gp\t\t= 0x001FAE14,\n\t\t  .itarget\t= 0x320000,\n\t\t  .control_id\t= FAN_OD,\n\t\t},\n\t},\n};\n\n \n#define\tPM121_SYS_GD\t\t0x00000000\n#define\tPM121_SYS_GR\t\t0x00019999\n#define\tPM121_SYS_HISTORY_SIZE\t2\n#define\tPM121_SYS_INTERVAL\t5\n\n \nstruct pm121_sys_state {\n\tint\t\t\tticks;\n\ts32\t\t\tsetpoint;\n\tstruct wf_pid_state\tpid;\n};\n\nstatic struct pm121_sys_state *pm121_sys_state[N_LOOPS] = {};\n\n \n\n#define PM121_CPU_INTERVAL\t1\n\n \nstruct pm121_cpu_state {\n\tint\t\t\tticks;\n\ts32\t\t\tsetpoint;\n\tstruct wf_cpu_pid_state\tpid;\n};\n\nstatic struct pm121_cpu_state *pm121_cpu_state;\n\n\n\n \n\n \nstatic s32 pm121_correct(s32 new_setpoint,\n\t\t\t unsigned int control_id,\n\t\t\t s32 min)\n{\n\ts32 new_min;\n\tstruct pm121_correction *correction;\n\tcorrection = &corrections[control_id][pm121_mach_model - 2];\n\n\tnew_min = (average_power * correction->slope) >> 16;\n\tnew_min += correction->offset;\n\tnew_min = (new_min >> 16) + min;\n\n\treturn max3(new_setpoint, new_min, 0);\n}\n\nstatic s32 pm121_connect(unsigned int control_id, s32 setpoint)\n{\n\ts32 new_min, value, new_setpoint;\n\n\tif (pm121_connection->control_id == control_id) {\n\t\tcontrols[control_id]->ops->get_value(controls[control_id],\n\t\t\t\t\t\t     &value);\n\t\tnew_min = value * pm121_connection->correction.slope;\n\t\tnew_min += pm121_connection->correction.offset;\n\t\tif (new_min > 0) {\n\t\t\tnew_setpoint = max(setpoint, (new_min >> 16));\n\t\t\tif (new_setpoint != setpoint) {\n\t\t\t\tpr_debug(\"pm121: %s depending on %s, \"\n\t\t\t\t\t \"corrected from %d to %d RPM\\n\",\n\t\t\t\t\t controls[control_id]->name,\n\t\t\t\t\t controls[pm121_connection->ref_id]->name,\n\t\t\t\t\t (int) setpoint, (int) new_setpoint);\n\t\t\t}\n\t\t} else\n\t\t\tnew_setpoint = setpoint;\n\t}\n\t \n\telse\n\t\tnew_setpoint = setpoint;\n\n\treturn new_setpoint;\n}\n\n \nstatic void pm121_create_sys_fans(int loop_id)\n{\n\tstruct pm121_sys_param *param = NULL;\n\tstruct wf_pid_param pid_param;\n\tstruct wf_control *control = NULL;\n\tint i;\n\n\t \n\tfor (i = 0; i < PM121_NUM_CONFIGS; i++) {\n\t\tif (pm121_sys_all_params[loop_id][i].model_id == pm121_mach_model) {\n\t\t\tparam = &(pm121_sys_all_params[loop_id][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (param == NULL) {\n\t\tprintk(KERN_WARNING \"pm121: %s fan config not found \"\n\t\t       \" for this machine model\\n\",\n\t\t       loop_names[loop_id]);\n\t\tgoto fail;\n\t}\n\n\tcontrol = controls[param->control_id];\n\n\t \n\tpm121_sys_state[loop_id] = kmalloc(sizeof(struct pm121_sys_state),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (pm121_sys_state[loop_id] == NULL) {\n\t\tprintk(KERN_WARNING \"pm121: Memory allocation error\\n\");\n\t\tgoto fail;\n\t}\n\tpm121_sys_state[loop_id]->ticks = 1;\n\n\t \n\tpid_param.gd\t\t= PM121_SYS_GD;\n\tpid_param.gp\t\t= param->gp;\n\tpid_param.gr\t\t= PM121_SYS_GR;\n\tpid_param.interval\t= PM121_SYS_INTERVAL;\n\tpid_param.history_len\t= PM121_SYS_HISTORY_SIZE;\n\tpid_param.itarget\t= param->itarget;\n\tif(control)\n\t{\n\t\tpid_param.min\t\t= control->ops->get_min(control);\n\t\tpid_param.max\t\t= control->ops->get_max(control);\n\t} else {\n\t\t \n\t\tpid_param.min\t\t= 0;\n\t\tpid_param.max\t\t= 0;\n\t}\n\n\twf_pid_init(&pm121_sys_state[loop_id]->pid, &pid_param);\n\n\tpr_debug(\"pm121: %s Fan control loop initialized.\\n\"\n\t\t \"       itarged=%d.%03d, min=%d RPM, max=%d RPM\\n\",\n\t\t loop_names[loop_id], FIX32TOPRINT(pid_param.itarget),\n\t\t pid_param.min, pid_param.max);\n\treturn;\n\n fail:\n\t \n\tprintk(KERN_WARNING \"pm121: failed to set up %s loop \"\n\t       \"setting \\\"%s\\\" to max speed.\\n\",\n\t       loop_names[loop_id], control ? control->name : \"uninitialized value\");\n\n\tif (control)\n\t\twf_control_set_max(control);\n}\n\nstatic void pm121_sys_fans_tick(int loop_id)\n{\n\tstruct pm121_sys_param *param;\n\tstruct pm121_sys_state *st;\n\tstruct wf_sensor *sensor;\n\tstruct wf_control *control;\n\ts32 temp, new_setpoint;\n\tint rc;\n\n\tparam = &(pm121_sys_all_params[loop_id][pm121_mach_model-2]);\n\tst = pm121_sys_state[loop_id];\n\tsensor = *(param->sensor);\n\tcontrol = controls[param->control_id];\n\n\tif (--st->ticks != 0) {\n\t\tif (pm121_readjust)\n\t\t\tgoto readjust;\n\t\treturn;\n\t}\n\tst->ticks = PM121_SYS_INTERVAL;\n\n\trc = sensor->ops->get_value(sensor, &temp);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"windfarm: %s sensor error %d\\n\",\n\t\t       sensor->name, rc);\n\t\tpm121_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\tpr_debug(\"pm121: %s Fan tick ! %s: %d.%03d\\n\",\n\t\t loop_names[loop_id], sensor->name,\n\t\t FIX32TOPRINT(temp));\n\n\tnew_setpoint = wf_pid_run(&st->pid, temp);\n\n\t \n\tnew_setpoint = pm121_correct(new_setpoint,\n\t\t\t\t     param->control_id,\n\t\t\t\t     st->pid.param.min);\n\t \n\tnew_setpoint = pm121_connect(param->control_id, new_setpoint);\n\n\tif (new_setpoint == st->setpoint)\n\t\treturn;\n\tst->setpoint = new_setpoint;\n\tpr_debug(\"pm121: %s corrected setpoint: %d RPM\\n\",\n\t\t control->name, (int)new_setpoint);\n readjust:\n\tif (control && pm121_failure_state == 0) {\n\t\trc = control->ops->set_value(control, st->setpoint);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"windfarm: %s fan error %d\\n\",\n\t\t\t       control->name, rc);\n\t\t\tpm121_failure_state |= FAILURE_FAN;\n\t\t}\n\t}\n}\n\n\n \nstatic void pm121_create_cpu_fans(void)\n{\n\tstruct wf_cpu_pid_param pid_param;\n\tconst struct smu_sdbp_header *hdr;\n\tstruct smu_sdbp_cpupiddata *piddata;\n\tstruct smu_sdbp_fvt *fvt;\n\tstruct wf_control *fan_cpu;\n\ts32 tmax, tdelta, maxpow, powadj;\n\n\tfan_cpu = controls[FAN_CPU];\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_CPUPIDDATA_ID, NULL);\n\tif (!hdr) {\n\t\tprintk(KERN_WARNING \"pm121: CPU PID fan config not found.\\n\");\n\t\tgoto fail;\n\t}\n\tpiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\n\n\t \n\thdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\n\tif (hdr) {\n\t\tfvt = (struct smu_sdbp_fvt *)&hdr[1];\n\t\ttmax = ((s32)fvt->maxtemp) << 16;\n\t} else\n\t\ttmax = 0x5e0000;  \n\n\t \n\tpm121_cpu_state = kmalloc(sizeof(struct pm121_cpu_state),\n\t\t\t\t  GFP_KERNEL);\n\tif (pm121_cpu_state == NULL)\n\t\tgoto fail;\n\tpm121_cpu_state->ticks = 1;\n\n\t \n\tpid_param.interval = PM121_CPU_INTERVAL;\n\tpid_param.history_len = piddata->history_len;\n\tif (pid_param.history_len > WF_CPU_PID_MAX_HISTORY) {\n\t\tprintk(KERN_WARNING \"pm121: History size overflow on \"\n\t\t       \"CPU control loop (%d)\\n\", piddata->history_len);\n\t\tpid_param.history_len = WF_CPU_PID_MAX_HISTORY;\n\t}\n\tpid_param.gd = piddata->gd;\n\tpid_param.gp = piddata->gp;\n\tpid_param.gr = piddata->gr / pid_param.history_len;\n\n\ttdelta = ((s32)piddata->target_temp_delta) << 16;\n\tmaxpow = ((s32)piddata->max_power) << 16;\n\tpowadj = ((s32)piddata->power_adj) << 16;\n\n\tpid_param.tmax = tmax;\n\tpid_param.ttarget = tmax - tdelta;\n\tpid_param.pmaxadj = maxpow - powadj;\n\n\tpid_param.min = fan_cpu->ops->get_min(fan_cpu);\n\tpid_param.max = fan_cpu->ops->get_max(fan_cpu);\n\n\twf_cpu_pid_init(&pm121_cpu_state->pid, &pid_param);\n\n\tpr_debug(\"pm121: CPU Fan control initialized.\\n\");\n\tpr_debug(\"       ttarget=%d.%03d, tmax=%d.%03d, min=%d RPM, max=%d RPM,\\n\",\n\t\t FIX32TOPRINT(pid_param.ttarget), FIX32TOPRINT(pid_param.tmax),\n\t\t pid_param.min, pid_param.max);\n\n\treturn;\n\n fail:\n\tprintk(KERN_WARNING \"pm121: CPU fan config not found, max fan speed\\n\");\n\n\tif (controls[CPUFREQ])\n\t\twf_control_set_max(controls[CPUFREQ]);\n\tif (fan_cpu)\n\t\twf_control_set_max(fan_cpu);\n}\n\n\nstatic void pm121_cpu_fans_tick(struct pm121_cpu_state *st)\n{\n\ts32 new_setpoint, temp, power;\n\tstruct wf_control *fan_cpu = NULL;\n\tint rc;\n\n\tif (--st->ticks != 0) {\n\t\tif (pm121_readjust)\n\t\t\tgoto readjust;\n\t\treturn;\n\t}\n\tst->ticks = PM121_CPU_INTERVAL;\n\n\tfan_cpu = controls[FAN_CPU];\n\n\trc = sensor_cpu_temp->ops->get_value(sensor_cpu_temp, &temp);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"pm121: CPU temp sensor error %d\\n\",\n\t\t       rc);\n\t\tpm121_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\trc = sensor_cpu_power->ops->get_value(sensor_cpu_power, &power);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"pm121: CPU power sensor error %d\\n\",\n\t\t       rc);\n\t\tpm121_failure_state |= FAILURE_SENSOR;\n\t\treturn;\n\t}\n\n\tpr_debug(\"pm121: CPU Fans tick ! CPU temp: %d.%03d\u00b0C, power: %d.%03d\\n\",\n\t\t FIX32TOPRINT(temp), FIX32TOPRINT(power));\n\n\tif (temp > st->pid.param.tmax)\n\t\tpm121_failure_state |= FAILURE_OVERTEMP;\n\n\tnew_setpoint = wf_cpu_pid_run(&st->pid, power, temp);\n\n\t \n\tnew_setpoint = pm121_correct(new_setpoint,\n\t\t\t\t     FAN_CPU,\n\t\t\t\t     st->pid.param.min);\n\n\t \n\tnew_setpoint = pm121_connect(FAN_CPU, new_setpoint);\n\n\tif (st->setpoint == new_setpoint)\n\t\treturn;\n\tst->setpoint = new_setpoint;\n\tpr_debug(\"pm121: CPU corrected setpoint: %d RPM\\n\", (int)new_setpoint);\n\n readjust:\n\tif (fan_cpu && pm121_failure_state == 0) {\n\t\trc = fan_cpu->ops->set_value(fan_cpu, st->setpoint);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"pm121: %s fan error %d\\n\",\n\t\t\t       fan_cpu->name, rc);\n\t\t\tpm121_failure_state |= FAILURE_FAN;\n\t\t}\n\t}\n}\n\n \n\nstatic void pm121_tick(void)\n{\n\tunsigned int last_failure = pm121_failure_state;\n\tunsigned int new_failure;\n\ts32 total_power;\n\tint i;\n\n\tif (!pm121_started) {\n\t\tpr_debug(\"pm121: creating control loops !\\n\");\n\t\tfor (i = 0; i < N_LOOPS; i++)\n\t\t\tpm121_create_sys_fans(i);\n\n\t\tpm121_create_cpu_fans();\n\t\tpm121_started = true;\n\t}\n\n\t \n\tif (pm121_skipping && --pm121_skipping)\n\t\treturn;\n\n\t \n\ttotal_power = 0;\n\tfor (i = 0; i < pm121_cpu_state->pid.param.history_len; i++)\n\t\ttotal_power += pm121_cpu_state->pid.powers[i];\n\n\taverage_power = total_power / pm121_cpu_state->pid.param.history_len;\n\n\n\tpm121_failure_state = 0;\n\tfor (i = 0 ; i < N_LOOPS; i++) {\n\t\tif (pm121_sys_state[i])\n\t\t\tpm121_sys_fans_tick(i);\n\t}\n\n\tif (pm121_cpu_state)\n\t\tpm121_cpu_fans_tick(pm121_cpu_state);\n\n\tpm121_readjust = 0;\n\tnew_failure = pm121_failure_state & ~last_failure;\n\n\t \n\tif (pm121_failure_state && !last_failure) {\n\t\tfor (i = 0; i < N_CONTROLS; i++) {\n\t\t\tif (controls[i])\n\t\t\t\twf_control_set_max(controls[i]);\n\t\t}\n\t}\n\n\t \n\tif (!pm121_failure_state && last_failure) {\n\t\tif (controls[CPUFREQ])\n\t\t\twf_control_set_min(controls[CPUFREQ]);\n\t\tpm121_readjust = 1;\n\t}\n\n\t \n\tif (new_failure & FAILURE_OVERTEMP) {\n\t\twf_set_overtemp();\n\t\tpm121_skipping = 2;\n\t\tpm121_overtemp = true;\n\t}\n\n\t \n\tif (!pm121_failure_state && pm121_overtemp) {\n\t\twf_clear_overtemp();\n\t\tpm121_overtemp = false;\n\t}\n}\n\n\nstatic struct wf_control* pm121_register_control(struct wf_control *ct,\n\t\t\t\t\t\t const char *match,\n\t\t\t\t\t\t unsigned int id)\n{\n\tif (controls[id] == NULL && !strcmp(ct->name, match)) {\n\t\tif (wf_get_control(ct) == 0)\n\t\t\tcontrols[id] = ct;\n\t}\n\treturn controls[id];\n}\n\nstatic void pm121_new_control(struct wf_control *ct)\n{\n\tint all = 1;\n\n\tif (pm121_all_controls_ok)\n\t\treturn;\n\n\tall = pm121_register_control(ct, \"optical-drive-fan\", FAN_OD) && all;\n\tall = pm121_register_control(ct, \"hard-drive-fan\", FAN_HD) && all;\n\tall = pm121_register_control(ct, \"cpu-fan\", FAN_CPU) && all;\n\tall = pm121_register_control(ct, \"cpufreq-clamp\", CPUFREQ) && all;\n\n\tif (all)\n\t\tpm121_all_controls_ok = 1;\n}\n\n\n\n\nstatic struct wf_sensor* pm121_register_sensor(struct wf_sensor *sensor,\n\t\t\t\t\t       const char *match,\n\t\t\t\t\t       struct wf_sensor **var)\n{\n\tif (*var == NULL && !strcmp(sensor->name, match)) {\n\t\tif (wf_get_sensor(sensor) == 0)\n\t\t\t*var = sensor;\n\t}\n\treturn *var;\n}\n\nstatic void pm121_new_sensor(struct wf_sensor *sr)\n{\n\tint all = 1;\n\n\tif (pm121_all_sensors_ok)\n\t\treturn;\n\n\tall = pm121_register_sensor(sr, \"cpu-temp\",\n\t\t\t\t    &sensor_cpu_temp) && all;\n\tall = pm121_register_sensor(sr, \"cpu-current\",\n\t\t\t\t    &sensor_cpu_current) && all;\n\tall = pm121_register_sensor(sr, \"cpu-voltage\",\n\t\t\t\t    &sensor_cpu_voltage) && all;\n\tall = pm121_register_sensor(sr, \"cpu-power\",\n\t\t\t\t    &sensor_cpu_power) && all;\n\tall = pm121_register_sensor(sr, \"hard-drive-temp\",\n\t\t\t\t    &sensor_hard_drive_temp) && all;\n\tall = pm121_register_sensor(sr, \"optical-drive-temp\",\n\t\t\t\t    &sensor_optical_drive_temp) && all;\n\tall = pm121_register_sensor(sr, \"incoming-air-temp\",\n\t\t\t\t    &sensor_incoming_air_temp) && all;\n\tall = pm121_register_sensor(sr, \"north-bridge-temp\",\n\t\t\t\t    &sensor_north_bridge_temp) && all;\n\tall = pm121_register_sensor(sr, \"gpu-temp\",\n\t\t\t\t    &sensor_gpu_temp) && all;\n\n\tif (all)\n\t\tpm121_all_sensors_ok = 1;\n}\n\n\n\nstatic int pm121_notify(struct notifier_block *self,\n\t\t\tunsigned long event, void *data)\n{\n\tswitch (event) {\n\tcase WF_EVENT_NEW_CONTROL:\n\t\tpr_debug(\"pm121: new control %s detected\\n\",\n\t\t\t ((struct wf_control *)data)->name);\n\t\tpm121_new_control(data);\n\t\tbreak;\n\tcase WF_EVENT_NEW_SENSOR:\n\t\tpr_debug(\"pm121: new sensor %s detected\\n\",\n\t\t\t ((struct wf_sensor *)data)->name);\n\t\tpm121_new_sensor(data);\n\t\tbreak;\n\tcase WF_EVENT_TICK:\n\t\tif (pm121_all_controls_ok && pm121_all_sensors_ok)\n\t\t\tpm121_tick();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block pm121_events = {\n\t.notifier_call\t= pm121_notify,\n};\n\nstatic int pm121_init_pm(void)\n{\n\tconst struct smu_sdbp_header *hdr;\n\n\thdr = smu_get_sdb_partition(SMU_SDB_SENSORTREE_ID, NULL);\n\tif (hdr) {\n\t\tstruct smu_sdbp_sensortree *st =\n\t\t\t(struct smu_sdbp_sensortree *)&hdr[1];\n\t\tpm121_mach_model = st->model_id;\n\t}\n\n\tpm121_connection = &pm121_connections[pm121_mach_model - 2];\n\n\tprintk(KERN_INFO \"pm121: Initializing for iMac G5 iSight model ID %d\\n\",\n\t       pm121_mach_model);\n\n\treturn 0;\n}\n\n\nstatic int pm121_probe(struct platform_device *ddev)\n{\n\twf_register_client(&pm121_events);\n\n\treturn 0;\n}\n\nstatic int pm121_remove(struct platform_device *ddev)\n{\n\twf_unregister_client(&pm121_events);\n\treturn 0;\n}\n\nstatic struct platform_driver pm121_driver = {\n\t.probe = pm121_probe,\n\t.remove = pm121_remove,\n\t.driver = {\n\t\t.name = \"windfarm\",\n\t\t.bus = &platform_bus_type,\n\t},\n};\n\n\nstatic int __init pm121_init(void)\n{\n\tint rc = -ENODEV;\n\n\tif (of_machine_is_compatible(\"PowerMac12,1\"))\n\t\trc = pm121_init_pm();\n\n\tif (rc == 0) {\n\t\trequest_module(\"windfarm_smu_controls\");\n\t\trequest_module(\"windfarm_smu_sensors\");\n\t\trequest_module(\"windfarm_smu_sat\");\n\t\trequest_module(\"windfarm_lm75_sensor\");\n\t\trequest_module(\"windfarm_max6690_sensor\");\n\t\trequest_module(\"windfarm_cpufreq_clamp\");\n\t\tplatform_driver_register(&pm121_driver);\n\t}\n\n\treturn rc;\n}\n\nstatic void __exit pm121_exit(void)\n{\n\n\tplatform_driver_unregister(&pm121_driver);\n}\n\n\nmodule_init(pm121_init);\nmodule_exit(pm121_exit);\n\nMODULE_AUTHOR(\"\u00c9tienne Bersac <bersace@gmail.com>\");\nMODULE_DESCRIPTION(\"Thermal control logic for iMac G5 (iSight)\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}