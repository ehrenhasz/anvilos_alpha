{
  "module_name": "ans-lcd.c",
  "hash_id": "cf19ac081c9b7f03823d3014003fcd0ed95e31fc5351b6b5ffe17f6313194450",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/ans-lcd.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/fcntl.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/of.h>\n\n#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <asm/io.h>\n\n#include \"ans-lcd.h\"\n\n#define ANSLCD_ADDR\t\t0xf301c000\n#define ANSLCD_CTRL_IX 0x00\n#define ANSLCD_DATA_IX 0x10\n\nstatic unsigned long anslcd_short_delay = 80;\nstatic unsigned long anslcd_long_delay = 3280;\nstatic volatile unsigned char __iomem *anslcd_ptr;\nstatic DEFINE_MUTEX(anslcd_mutex);\n\n#undef DEBUG\n\nstatic void\nanslcd_write_byte_ctrl ( unsigned char c )\n{\n#ifdef DEBUG\n\tprintk(KERN_DEBUG \"LCD: CTRL byte: %02x\\n\",c);\n#endif\n\tout_8(anslcd_ptr + ANSLCD_CTRL_IX, c);\n\tswitch(c) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tudelay(anslcd_long_delay); break;\n\t\tdefault: udelay(anslcd_short_delay);\n\t}\n}\n\nstatic void\nanslcd_write_byte_data ( unsigned char c )\n{\n\tout_8(anslcd_ptr + ANSLCD_DATA_IX, c);\n\tudelay(anslcd_short_delay);\n}\n\nstatic ssize_t\nanslcd_write( struct file * file, const char __user * buf, \n\t\t\t\tsize_t count, loff_t *ppos )\n{\n\tconst char __user *p = buf;\n\tint i;\n\n#ifdef DEBUG\n\tprintk(KERN_DEBUG \"LCD: write\\n\");\n#endif\n\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&anslcd_mutex);\n\tfor ( i = *ppos; count > 0; ++i, ++p, --count ) \n\t{\n\t\tchar c;\n\t\t__get_user(c, p);\n\t\tanslcd_write_byte_data( c );\n\t}\n\tmutex_unlock(&anslcd_mutex);\n\t*ppos = i;\n\treturn p - buf;\n}\n\nstatic long\nanslcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tchar ch, __user *temp;\n\tlong ret = 0;\n\n#ifdef DEBUG\n\tprintk(KERN_DEBUG \"LCD: ioctl(%d,%d)\\n\",cmd,arg);\n#endif\n\n\tmutex_lock(&anslcd_mutex);\n\n\tswitch ( cmd )\n\t{\n\tcase ANSLCD_CLEAR:\n\t\tanslcd_write_byte_ctrl ( 0x38 );\n\t\tanslcd_write_byte_ctrl ( 0x0f );\n\t\tanslcd_write_byte_ctrl ( 0x06 );\n\t\tanslcd_write_byte_ctrl ( 0x01 );\n\t\tanslcd_write_byte_ctrl ( 0x02 );\n\t\tbreak;\n\tcase ANSLCD_SENDCTRL:\n\t\ttemp = (char __user *) arg;\n\t\t__get_user(ch, temp);\n\t\tfor (; ch; temp++) {  \n\t\t\tanslcd_write_byte_ctrl ( ch );\n\t\t\t__get_user(ch, temp);\n\t\t}\n\t\tbreak;\n\tcase ANSLCD_SETSHORTDELAY:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\tret =-EACCES;\n\t\telse\n\t\t\tanslcd_short_delay=arg;\n\t\tbreak;\n\tcase ANSLCD_SETLONGDELAY:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tanslcd_long_delay=arg;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&anslcd_mutex);\n\treturn ret;\n}\n\nstatic int\nanslcd_open( struct inode * inode, struct file * file )\n{\n\treturn 0;\n}\n\nconst struct file_operations anslcd_fops = {\n\t.write\t\t= anslcd_write,\n\t.unlocked_ioctl\t= anslcd_ioctl,\n\t.open\t\t= anslcd_open,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct miscdevice anslcd_dev = {\n\tLCD_MINOR,\n\t\"anslcd\",\n\t&anslcd_fops\n};\n\nstatic const char anslcd_logo[] __initconst =\n\t\t\t\t\"********************\"   \n\t\t\t\t\"*      LINUX!      *\"   \n\t\t\t\t\"*    Welcome to    *\"   \n\t\t\t\t\"********************\";  \n\nstatic int __init\nanslcd_init(void)\n{\n\tint a;\n\tint retval;\n\tstruct device_node* node;\n\n\tnode = of_find_node_by_name(NULL, \"lcd\");\n\tif (!node || !of_node_name_eq(node->parent, \"gc\")) {\n\t\tof_node_put(node);\n\t\treturn -ENODEV;\n\t}\n\tof_node_put(node);\n\n\tanslcd_ptr = ioremap(ANSLCD_ADDR, 0x20);\n\t\n\tretval = misc_register(&anslcd_dev);\n\tif(retval < 0){\n\t\tprintk(KERN_INFO \"LCD: misc_register failed\\n\");\n\t\tiounmap(anslcd_ptr);\n\t\treturn retval;\n\t}\n\n#ifdef DEBUG\n\tprintk(KERN_DEBUG \"LCD: init\\n\");\n#endif\n\n\tmutex_lock(&anslcd_mutex);\n\tanslcd_write_byte_ctrl ( 0x38 );\n\tanslcd_write_byte_ctrl ( 0x0c );\n\tanslcd_write_byte_ctrl ( 0x06 );\n\tanslcd_write_byte_ctrl ( 0x01 );\n\tanslcd_write_byte_ctrl ( 0x02 );\n\tfor(a=0;a<80;a++) {\n\t\tanslcd_write_byte_data(anslcd_logo[a]);\n\t}\n\tmutex_unlock(&anslcd_mutex);\n\treturn 0;\n}\n\nstatic void __exit\nanslcd_exit(void)\n{\n\tmisc_deregister(&anslcd_dev);\n\tiounmap(anslcd_ptr);\n}\n\nmodule_init(anslcd_init);\nmodule_exit(anslcd_exit);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}