{
  "module_name": "therm_windtunnel.c",
  "hash_id": "93f47321250db4ee7fd19b97df1d484992334fe510bc66565bef7adec1f14141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/macintosh/therm_windtunnel.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/sections.h>\n#include <asm/macio.h>\n\n#define LOG_TEMP\t\t0\t\t\t \n\nstatic struct {\n\tvolatile int\t\trunning;\n\tstruct task_struct\t*poll_task;\n\t\n\tstruct mutex\t \tlock;\n\tstruct platform_device\t*of_dev;\n\t\n\tstruct i2c_client\t*thermostat;\n\tstruct i2c_client\t*fan;\n\n\tint\t\t\toverheat_temp;\t\t \n\tint\t\t\toverheat_hyst;\n\tint\t\t\ttemp;\n\tint\t\t\tcasetemp;\n\tint\t\t\tfan_level;\t\t \n\n\tint\t\t\tdownind;\n\tint\t\t\tupind;\n\n\tint\t\t\tr0, r1, r20, r23, r25;\t \n} x;\n\n#define T(x,y)\t\t\t(((x)<<8) | (y)*0x100/10 )\n\nstatic struct {\n\tint\t\t\tfan_down_setting;\n\tint\t\t\ttemp;\n\tint\t\t\tfan_up_setting;\n} fan_table[] = {\n\t{ 11, T(0,0),  11 },\t \n\t{ 11, T(55,0), 11 },\n\t{  6, T(55,3), 11 },\n\t{  7, T(56,0), 11 },\n\t{  8, T(57,0), 8 },\n\t{  7, T(58,3), 7 },\n\t{  6, T(58,8), 6 },\n\t{  5, T(59,2), 5 },\n\t{  4, T(59,6), 4 },\n\t{  3, T(59,9), 3 },\n\t{  2, T(60,1), 2 },\n\t{  1, 0xfffff, 1 }\t \n};\n\nstatic void\nprint_temp( const char *s, int temp )\n{\n\tprintk(\"%s%d.%d C\", s ? s : \"\", temp>>8, (temp & 255)*10/256 );\n}\n\nstatic ssize_t\nshow_cpu_temperature( struct device *dev, struct device_attribute *attr, char *buf )\n{\n\treturn sprintf(buf, \"%d.%d\\n\", x.temp>>8, (x.temp & 255)*10/256 );\n}\n\nstatic ssize_t\nshow_case_temperature( struct device *dev, struct device_attribute *attr, char *buf )\n{\n\treturn sprintf(buf, \"%d.%d\\n\", x.casetemp>>8, (x.casetemp & 255)*10/256 );\n}\n\nstatic DEVICE_ATTR(cpu_temperature, S_IRUGO, show_cpu_temperature, NULL );\nstatic DEVICE_ATTR(case_temperature, S_IRUGO, show_case_temperature, NULL );\n\n\n\n \n \n \n\nstatic int\nwrite_reg( struct i2c_client *cl, int reg, int data, int len )\n{\n\tu8 tmp[3];\n\n\tif( len < 1 || len > 2 || data < 0 )\n\t\treturn -EINVAL;\n\n\ttmp[0] = reg;\n\ttmp[1] = (len == 1) ? data : (data >> 8);\n\ttmp[2] = data;\n\tlen++;\n\t\n\tif( i2c_master_send(cl, tmp, len) != len )\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int\nread_reg( struct i2c_client *cl, int reg, int len )\n{\n\tu8 buf[2];\n\n\tif( len != 1 && len != 2 )\n\t\treturn -EINVAL;\n\tbuf[0] = reg;\n\tif( i2c_master_send(cl, buf, 1) != 1 )\n\t\treturn -ENODEV;\n\tif( i2c_master_recv(cl, buf, len) != len )\n\t\treturn -ENODEV;\n\treturn (len == 2)? ((unsigned int)buf[0] << 8) | buf[1] : buf[0];\n}\n\nstatic void\ntune_fan( int fan_setting )\n{\n\tint val = (fan_setting << 3) | 7;\n\n\t \n\twrite_reg( x.fan, 0x25, val, 1 );\n\twrite_reg( x.fan, 0x20, 0, 1 );\n\tprint_temp(\"CPU-temp: \", x.temp );\n\tif( x.casetemp )\n\t\tprint_temp(\", Case: \", x.casetemp );\n\tprintk(\",  Fan: %d (tuned %+d)\\n\", 11-fan_setting, x.fan_level-fan_setting );\n\n\tx.fan_level = fan_setting;\n}\n\nstatic void\npoll_temp( void )\n{\n\tint temp, i, level, casetemp;\n\n\ttemp = read_reg( x.thermostat, 0, 2 );\n\n\t \n\tif( temp < 0 )\n\t\treturn;\n\n\tcasetemp = read_reg(x.fan, 0x0b, 1) << 8;\n\tcasetemp |= (read_reg(x.fan, 0x06, 1) & 0x7) << 5;\n\n\tif( LOG_TEMP && x.temp != temp ) {\n\t\tprint_temp(\"CPU-temp: \", temp );\n\t\tprint_temp(\", Case: \", casetemp );\n\t\tprintk(\",  Fan: %d\\n\", 11-x.fan_level );\n\t}\n\tx.temp = temp;\n\tx.casetemp = casetemp;\n\n\tlevel = -1;\n\tfor( i=0; (temp & 0xffff) > fan_table[i].temp ; i++ )\n\t\t;\n\tif( i < x.downind )\n\t\tlevel = fan_table[i].fan_down_setting;\n\tx.downind = i;\n\n\tfor( i=0; (temp & 0xffff) >= fan_table[i+1].temp ; i++ )\n\t\t;\n\tif( x.upind < i )\n\t\tlevel = fan_table[i].fan_up_setting;\n\tx.upind = i;\n\n\tif( level >= 0 )\n\t\ttune_fan( level );\n}\n\n\nstatic void\nsetup_hardware( void )\n{\n\tint val;\n\tint err;\n\n\t \n\tx.r0 = read_reg( x.fan, 0x00, 1 );\n\tx.r1 = read_reg( x.fan, 0x01, 1 );\n\tx.r20 = read_reg( x.fan, 0x20, 1 );\n\tx.r23 = read_reg( x.fan, 0x23, 1 );\n\tx.r25 = read_reg( x.fan, 0x25, 1 );\n\n\t \n\tif( (val=read_reg(x.thermostat, 1, 1)) >= 0 ) {\n\t\tval |= 0x60;\n\t\tif( write_reg( x.thermostat, 1, val, 1 ) )\n\t\t\tprintk(\"Failed writing config register\\n\");\n\t}\n\t \n\twrite_reg( x.fan, 0x01, 0x01, 1 );\n\t \n\twrite_reg( x.fan, 0x23, 0x91, 1 );\n\t \n\twrite_reg( x.fan, 0x00, 0x95, 1 );\n\n\t \n\tif( x.overheat_temp == (80 << 8) ) {\n\t\tx.overheat_temp = 75 << 8;\n\t\tx.overheat_hyst = 70 << 8;\n\t\twrite_reg( x.thermostat, 2, x.overheat_hyst, 2 );\n\t\twrite_reg( x.thermostat, 3, x.overheat_temp, 2 );\n\n\t\tprint_temp(\"Reducing overheating limit to \", x.overheat_temp );\n\t\tprint_temp(\" (Hyst: \", x.overheat_hyst );\n\t\tprintk(\")\\n\");\n\t}\n\n\t \n\tx.downind = 0xffff;\n\tx.upind = -1;\n\t \n\n\terr = device_create_file( &x.of_dev->dev, &dev_attr_cpu_temperature );\n\terr |= device_create_file( &x.of_dev->dev, &dev_attr_case_temperature );\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t\t\"Failed to create temperature attribute file(s).\\n\");\n}\n\nstatic void\nrestore_regs( void )\n{\n\tdevice_remove_file( &x.of_dev->dev, &dev_attr_cpu_temperature );\n\tdevice_remove_file( &x.of_dev->dev, &dev_attr_case_temperature );\n\n\twrite_reg( x.fan, 0x01, x.r1, 1 );\n\twrite_reg( x.fan, 0x20, x.r20, 1 );\n\twrite_reg( x.fan, 0x23, x.r23, 1 );\n\twrite_reg( x.fan, 0x25, x.r25, 1 );\n\twrite_reg( x.fan, 0x00, x.r0, 1 );\n}\n\nstatic int control_loop(void *dummy)\n{\n\tmutex_lock(&x.lock);\n\tsetup_hardware();\n\tmutex_unlock(&x.lock);\n\n\tfor (;;) {\n\t\tmsleep_interruptible(8000);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tmutex_lock(&x.lock);\n\t\tpoll_temp();\n\t\tmutex_unlock(&x.lock);\n\t}\n\n\tmutex_lock(&x.lock);\n\trestore_regs();\n\tmutex_unlock(&x.lock);\n\n\treturn 0;\n}\n\n\n \n \n \n\nstatic void do_attach(struct i2c_adapter *adapter)\n{\n\tstruct i2c_board_info info = { };\n\tstruct device_node *np;\n\n\t \n\tstatic const unsigned short scan_ds1775[] = {\n\t\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n\t\tI2C_CLIENT_END\n\t};\n\tstatic const unsigned short scan_adm1030[] = {\n\t\t0x2c, 0x2d, 0x2e, 0x2f,\n\t\tI2C_CLIENT_END\n\t};\n\n\tif (x.running || strncmp(adapter->name, \"uni-n\", 5))\n\t\treturn;\n\n\tof_node_get(adapter->dev.of_node);\n\tnp = of_find_compatible_node(adapter->dev.of_node, NULL, \"MAC,ds1775\");\n\tif (np) {\n\t\tof_node_put(np);\n\t} else {\n\t\tstrscpy(info.type, \"MAC,ds1775\", I2C_NAME_SIZE);\n\t\ti2c_new_scanned_device(adapter, &info, scan_ds1775, NULL);\n\t}\n\n\tof_node_get(adapter->dev.of_node);\n\tnp = of_find_compatible_node(adapter->dev.of_node, NULL, \"MAC,adm1030\");\n\tif (np) {\n\t\tof_node_put(np);\n\t} else {\n\t\tstrscpy(info.type, \"MAC,adm1030\", I2C_NAME_SIZE);\n\t\ti2c_new_scanned_device(adapter, &info, scan_adm1030, NULL);\n\t}\n}\n\nstatic void\ndo_remove(struct i2c_client *client)\n{\n\tif (x.running) {\n\t\tx.running = 0;\n\t\tkthread_stop(x.poll_task);\n\t\tx.poll_task = NULL;\n\t}\n\tif (client == x.thermostat)\n\t\tx.thermostat = NULL;\n\telse if (client == x.fan)\n\t\tx.fan = NULL;\n\telse\n\t\tprintk(KERN_ERR \"g4fan: bad client\\n\");\n}\n\nstatic int\nattach_fan( struct i2c_client *cl )\n{\n\tif( x.fan )\n\t\tgoto out;\n\n\t \n\tif( read_reg(cl, 0x3d, 1) != 0x30 || read_reg(cl, 0x3e, 1) != 0x41 )\n\t\tgoto out;\n\tprintk(\"ADM1030 fan controller [@%02x]\\n\", cl->addr );\n\n\tx.fan = cl;\n out:\n\treturn 0;\n}\n\nstatic int\nattach_thermostat( struct i2c_client *cl ) \n{\n\tint hyst_temp, os_temp, temp;\n\n\tif( x.thermostat )\n\t\tgoto out;\n\n\tif( (temp=read_reg(cl, 0, 2)) < 0 )\n\t\tgoto out;\n\t\n\t \n\tif( temp < 0x1600 || temp > 0x3c00 )\n\t\tgoto out;\n\thyst_temp = read_reg(cl, 2, 2);\n\tos_temp = read_reg(cl, 3, 2);\n\tif( hyst_temp < 0 || os_temp < 0 )\n\t\tgoto out;\n\n\tprintk(\"DS1775 digital thermometer [@%02x]\\n\", cl->addr );\n\tprint_temp(\"Temp: \", temp );\n\tprint_temp(\"  Hyst: \", hyst_temp );\n\tprint_temp(\"  OS: \", os_temp );\n\tprintk(\"\\n\");\n\n\tx.temp = temp;\n\tx.overheat_temp = os_temp;\n\tx.overheat_hyst = hyst_temp;\n\tx.thermostat = cl;\nout:\n\treturn 0;\n}\n\nenum chip { ds1775, adm1030 };\n\nstatic const struct i2c_device_id therm_windtunnel_id[] = {\n\t{ \"MAC,ds1775\", ds1775 },\n\t{ \"MAC,adm1030\", adm1030 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, therm_windtunnel_id);\n\nstatic int\ndo_probe(struct i2c_client *cl)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(cl);\n\tstruct i2c_adapter *adapter = cl->adapter;\n\tint ret = 0;\n\n\tif( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_WRITE_BYTE) )\n\t\treturn 0;\n\n\tswitch (id->driver_data) {\n\tcase adm1030:\n\t\tret = attach_fan(cl);\n\t\tbreak;\n\tcase ds1775:\n\t\tret = attach_thermostat(cl);\n\t\tbreak;\n\t}\n\n\tif (!x.running && x.thermostat && x.fan) {\n\t\tx.running = 1;\n\t\tx.poll_task = kthread_run(control_loop, NULL, \"g4fand\");\n\t}\n\n\treturn ret;\n}\n\nstatic struct i2c_driver g4fan_driver = {\n\t.driver = {\n\t\t.name\t= \"therm_windtunnel\",\n\t},\n\t.probe\t\t= do_probe,\n\t.remove\t\t= do_remove,\n\t.id_table\t= therm_windtunnel_id,\n};\n\n\n \n \n \n\nstatic int therm_of_probe(struct platform_device *dev)\n{\n\tstruct i2c_adapter *adap;\n\tint ret, i = 0;\n\n\tadap = i2c_get_adapter(0);\n\tif (!adap)\n\t\treturn -EPROBE_DEFER;\n\n\tret = i2c_add_driver(&g4fan_driver);\n\tif (ret) {\n\t\ti2c_put_adapter(adap);\n\t\treturn ret;\n\t}\n\n\t \n\twhile (adap) {\n\t\tdo_attach(adap);\n\t\tif (x.running)\n\t\t\treturn 0;\n\t\ti2c_put_adapter(adap);\n\t\tadap = i2c_get_adapter(++i);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int\ntherm_of_remove( struct platform_device *dev )\n{\n\ti2c_del_driver( &g4fan_driver );\n\treturn 0;\n}\n\nstatic const struct of_device_id therm_of_match[] = {{\n\t.name\t\t= \"fan\",\n\t.compatible\t= \"adm1030\"\n    }, {}\n};\nMODULE_DEVICE_TABLE(of, therm_of_match);\n\nstatic struct platform_driver therm_of_driver = {\n\t.driver = {\n\t\t.name = \"temperature\",\n\t\t.of_match_table = therm_of_match,\n\t},\n\t.probe\t\t= therm_of_probe,\n\t.remove\t\t= therm_of_remove,\n};\n\nstruct apple_thermal_info {\n\tu8\t\tid;\t\t\t \n\tu8\t\tfan_count;\t\t \n\tu8\t\tthermostat_count;\t \n\tu8\t\tunused;\n};\n\nstatic int __init\ng4fan_init( void )\n{\n\tconst struct apple_thermal_info *info;\n\tstruct device_node *np;\n\n\tmutex_init(&x.lock);\n\n\tif( !(np=of_find_node_by_name(NULL, \"power-mgt\")) )\n\t\treturn -ENODEV;\n\tinfo = of_get_property(np, \"thermal-info\", NULL);\n\tof_node_put(np);\n\n\tif( !info || !of_machine_is_compatible(\"PowerMac3,6\") )\n\t\treturn -ENODEV;\n\n\tif( info->id != 3 ) {\n\t\tprintk(KERN_ERR \"therm_windtunnel: unsupported thermal design %d\\n\", info->id );\n\t\treturn -ENODEV;\n\t}\n\tif( !(np=of_find_node_by_name(NULL, \"fan\")) )\n\t\treturn -ENODEV;\n\tx.of_dev = of_platform_device_create(np, \"temperature\", NULL);\n\tof_node_put( np );\n\n\tif( !x.of_dev ) {\n\t\tprintk(KERN_ERR \"Can't register fan controller!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform_driver_register( &therm_of_driver );\n\treturn 0;\n}\n\nstatic void __exit\ng4fan_exit( void )\n{\n\tplatform_driver_unregister( &therm_of_driver );\n\n\tif( x.of_dev )\n\t\tof_device_unregister( x.of_dev );\n}\n\nmodule_init(g4fan_init);\nmodule_exit(g4fan_exit);\n\nMODULE_AUTHOR(\"Samuel Rydh <samuel@ibrium.se>\");\nMODULE_DESCRIPTION(\"Apple G4 (windtunnel) fan controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}