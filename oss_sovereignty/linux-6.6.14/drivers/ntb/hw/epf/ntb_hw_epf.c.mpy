{
  "module_name": "ntb_hw_epf.c",
  "hash_id": "dc27f586d53b88cecef61b6241d89db1ec08e2450729bc3200c453f39e63fd78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/hw/epf/ntb_hw_epf.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/ntb.h>\n\n#define NTB_EPF_COMMAND\t\t0x0\n#define CMD_CONFIGURE_DOORBELL\t1\n#define CMD_TEARDOWN_DOORBELL\t2\n#define CMD_CONFIGURE_MW\t3\n#define CMD_TEARDOWN_MW\t\t4\n#define CMD_LINK_UP\t\t5\n#define CMD_LINK_DOWN\t\t6\n\n#define NTB_EPF_ARGUMENT\t0x4\n#define MSIX_ENABLE\t\tBIT(16)\n\n#define NTB_EPF_CMD_STATUS\t0x8\n#define COMMAND_STATUS_OK\t1\n#define COMMAND_STATUS_ERROR\t2\n\n#define NTB_EPF_LINK_STATUS\t0x0A\n#define LINK_STATUS_UP\t\tBIT(0)\n\n#define NTB_EPF_TOPOLOGY\t0x0C\n#define NTB_EPF_LOWER_ADDR\t0x10\n#define NTB_EPF_UPPER_ADDR\t0x14\n#define NTB_EPF_LOWER_SIZE\t0x18\n#define NTB_EPF_UPPER_SIZE\t0x1C\n#define NTB_EPF_MW_COUNT\t0x20\n#define NTB_EPF_MW1_OFFSET\t0x24\n#define NTB_EPF_SPAD_OFFSET\t0x28\n#define NTB_EPF_SPAD_COUNT\t0x2C\n#define NTB_EPF_DB_ENTRY_SIZE\t0x30\n#define NTB_EPF_DB_DATA(n)\t(0x34 + (n) * 4)\n#define NTB_EPF_DB_OFFSET(n)\t(0xB4 + (n) * 4)\n\n#define NTB_EPF_MIN_DB_COUNT\t3\n#define NTB_EPF_MAX_DB_COUNT\t31\n\n#define NTB_EPF_COMMAND_TIMEOUT\t1000  \n\nenum pci_barno {\n\tBAR_0,\n\tBAR_1,\n\tBAR_2,\n\tBAR_3,\n\tBAR_4,\n\tBAR_5,\n};\n\nstruct ntb_epf_dev {\n\tstruct ntb_dev ntb;\n\tstruct device *dev;\n\t \n\tstruct mutex cmd_lock;\n\n\tenum pci_barno ctrl_reg_bar;\n\tenum pci_barno peer_spad_reg_bar;\n\tenum pci_barno db_reg_bar;\n\tenum pci_barno mw_bar;\n\n\tunsigned int mw_count;\n\tunsigned int spad_count;\n\tunsigned int db_count;\n\n\tvoid __iomem *ctrl_reg;\n\tvoid __iomem *db_reg;\n\tvoid __iomem *peer_spad_reg;\n\n\tunsigned int self_spad;\n\tunsigned int peer_spad;\n\n\tint db_val;\n\tu64 db_valid_mask;\n};\n\n#define ntb_ndev(__ntb) container_of(__ntb, struct ntb_epf_dev, ntb)\n\nstruct ntb_epf_data {\n\t \n\tenum pci_barno ctrl_reg_bar;\n\t \n\tenum pci_barno peer_spad_reg_bar;\n\t \n\tenum pci_barno db_reg_bar;\n\t \n\tenum pci_barno mw_bar;\n};\n\nstatic int ntb_epf_send_command(struct ntb_epf_dev *ndev, u32 command,\n\t\t\t\tu32 argument)\n{\n\tktime_t timeout;\n\tbool timedout;\n\tint ret = 0;\n\tu32 status;\n\n\tmutex_lock(&ndev->cmd_lock);\n\twritel(argument, ndev->ctrl_reg + NTB_EPF_ARGUMENT);\n\twritel(command, ndev->ctrl_reg + NTB_EPF_COMMAND);\n\n\ttimeout = ktime_add_ms(ktime_get(), NTB_EPF_COMMAND_TIMEOUT);\n\twhile (1) {\n\t\ttimedout = ktime_after(ktime_get(), timeout);\n\t\tstatus = readw(ndev->ctrl_reg + NTB_EPF_CMD_STATUS);\n\n\t\tif (status == COMMAND_STATUS_ERROR) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status == COMMAND_STATUS_OK)\n\t\t\tbreak;\n\n\t\tif (WARN_ON(timedout)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(5, 10);\n\t}\n\n\twritew(0, ndev->ctrl_reg + NTB_EPF_CMD_STATUS);\n\tmutex_unlock(&ndev->cmd_lock);\n\n\treturn ret;\n}\n\nstatic int ntb_epf_mw_to_bar(struct ntb_epf_dev *ndev, int idx)\n{\n\tstruct device *dev = ndev->dev;\n\n\tif (idx < 0 || idx > ndev->mw_count) {\n\t\tdev_err(dev, \"Unsupported Memory Window index %d\\n\", idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn idx + 2;\n}\n\nstatic int ntb_epf_mw_count(struct ntb_dev *ntb, int pidx)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\n\tif (pidx != NTB_DEF_PEER_IDX) {\n\t\tdev_err(dev, \"Unsupported Peer ID %d\\n\", pidx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ndev->mw_count;\n}\n\nstatic int ntb_epf_mw_get_align(struct ntb_dev *ntb, int pidx, int idx,\n\t\t\t\tresource_size_t *addr_align,\n\t\t\t\tresource_size_t *size_align,\n\t\t\t\tresource_size_t *size_max)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tint bar;\n\n\tif (pidx != NTB_DEF_PEER_IDX) {\n\t\tdev_err(dev, \"Unsupported Peer ID %d\\n\", pidx);\n\t\treturn -EINVAL;\n\t}\n\n\tbar = ntb_epf_mw_to_bar(ndev, idx);\n\tif (bar < 0)\n\t\treturn bar;\n\n\tif (addr_align)\n\t\t*addr_align = SZ_4K;\n\n\tif (size_align)\n\t\t*size_align = 1;\n\n\tif (size_max)\n\t\t*size_max = pci_resource_len(ndev->ntb.pdev, bar);\n\n\treturn 0;\n}\n\nstatic u64 ntb_epf_link_is_up(struct ntb_dev *ntb,\n\t\t\t      enum ntb_speed *speed,\n\t\t\t      enum ntb_width *width)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tu32 status;\n\n\tstatus = readw(ndev->ctrl_reg + NTB_EPF_LINK_STATUS);\n\n\treturn status & LINK_STATUS_UP;\n}\n\nstatic u32 ntb_epf_spad_read(struct ntb_dev *ntb, int idx)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tu32 offset;\n\n\tif (idx < 0 || idx >= ndev->spad_count) {\n\t\tdev_err(dev, \"READ: Invalid ScratchPad Index %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\toffset = readl(ndev->ctrl_reg + NTB_EPF_SPAD_OFFSET);\n\toffset += (idx << 2);\n\n\treturn readl(ndev->ctrl_reg + offset);\n}\n\nstatic int ntb_epf_spad_write(struct ntb_dev *ntb,\n\t\t\t      int idx, u32 val)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tu32 offset;\n\n\tif (idx < 0 || idx >= ndev->spad_count) {\n\t\tdev_err(dev, \"WRITE: Invalid ScratchPad Index %d\\n\", idx);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = readl(ndev->ctrl_reg + NTB_EPF_SPAD_OFFSET);\n\toffset += (idx << 2);\n\twritel(val, ndev->ctrl_reg + offset);\n\n\treturn 0;\n}\n\nstatic u32 ntb_epf_peer_spad_read(struct ntb_dev *ntb, int pidx, int idx)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tu32 offset;\n\n\tif (pidx != NTB_DEF_PEER_IDX) {\n\t\tdev_err(dev, \"Unsupported Peer ID %d\\n\", pidx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (idx < 0 || idx >= ndev->spad_count) {\n\t\tdev_err(dev, \"WRITE: Invalid Peer ScratchPad Index %d\\n\", idx);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = (idx << 2);\n\treturn readl(ndev->peer_spad_reg + offset);\n}\n\nstatic int ntb_epf_peer_spad_write(struct ntb_dev *ntb, int pidx,\n\t\t\t\t   int idx, u32 val)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tu32 offset;\n\n\tif (pidx != NTB_DEF_PEER_IDX) {\n\t\tdev_err(dev, \"Unsupported Peer ID %d\\n\", pidx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (idx < 0 || idx >= ndev->spad_count) {\n\t\tdev_err(dev, \"WRITE: Invalid Peer ScratchPad Index %d\\n\", idx);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = (idx << 2);\n\twritel(val, ndev->peer_spad_reg + offset);\n\n\treturn 0;\n}\n\nstatic int ntb_epf_link_enable(struct ntb_dev *ntb,\n\t\t\t       enum ntb_speed max_speed,\n\t\t\t       enum ntb_width max_width)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tint ret;\n\n\tret = ntb_epf_send_command(ndev, CMD_LINK_UP, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Fail to enable link\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ntb_epf_link_disable(struct ntb_dev *ntb)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tint ret;\n\n\tret = ntb_epf_send_command(ndev, CMD_LINK_DOWN, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Fail to disable link\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ntb_epf_vec_isr(int irq, void *dev)\n{\n\tstruct ntb_epf_dev *ndev = dev;\n\tint irq_no;\n\n\tirq_no = irq - pci_irq_vector(ndev->ntb.pdev, 0);\n\tndev->db_val = irq_no + 1;\n\n\tif (irq_no == 0)\n\t\tntb_link_event(&ndev->ntb);\n\telse\n\t\tntb_db_event(&ndev->ntb, irq_no);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ntb_epf_init_isr(struct ntb_epf_dev *ndev, int msi_min, int msi_max)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tstruct device *dev = ndev->dev;\n\tu32 argument = MSIX_ENABLE;\n\tint irq;\n\tint ret;\n\tint i;\n\n\tirq = pci_alloc_irq_vectors(pdev, msi_min, msi_max, PCI_IRQ_MSIX);\n\tif (irq < 0) {\n\t\tdev_dbg(dev, \"Failed to get MSIX interrupts\\n\");\n\t\tirq = pci_alloc_irq_vectors(pdev, msi_min, msi_max,\n\t\t\t\t\t    PCI_IRQ_MSI);\n\t\tif (irq < 0) {\n\t\t\tdev_err(dev, \"Failed to get MSI interrupts\\n\");\n\t\t\treturn irq;\n\t\t}\n\t\targument &= ~MSIX_ENABLE;\n\t}\n\n\tfor (i = 0; i < irq; i++) {\n\t\tret = request_irq(pci_irq_vector(pdev, i), ntb_epf_vec_isr,\n\t\t\t\t  0, \"ntb_epf\", ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request irq\\n\");\n\t\t\tgoto err_request_irq;\n\t\t}\n\t}\n\n\tndev->db_count = irq - 1;\n\n\tret = ntb_epf_send_command(ndev, CMD_CONFIGURE_DOORBELL,\n\t\t\t\t   argument | irq);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to configure doorbell\\n\");\n\t\tgoto err_configure_db;\n\t}\n\n\treturn 0;\n\nerr_configure_db:\n\tfor (i = 0; i < ndev->db_count + 1; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), ndev);\n\nerr_request_irq:\n\tpci_free_irq_vectors(pdev);\n\n\treturn ret;\n}\n\nstatic int ntb_epf_peer_mw_count(struct ntb_dev *ntb)\n{\n\treturn ntb_ndev(ntb)->mw_count;\n}\n\nstatic int ntb_epf_spad_count(struct ntb_dev *ntb)\n{\n\treturn ntb_ndev(ntb)->spad_count;\n}\n\nstatic u64 ntb_epf_db_valid_mask(struct ntb_dev *ntb)\n{\n\treturn ntb_ndev(ntb)->db_valid_mask;\n}\n\nstatic int ntb_epf_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn 0;\n}\n\nstatic int ntb_epf_mw_set_trans(struct ntb_dev *ntb, int pidx, int idx,\n\t\t\t\tdma_addr_t addr, resource_size_t size)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tresource_size_t mw_size;\n\tint bar;\n\n\tif (pidx != NTB_DEF_PEER_IDX) {\n\t\tdev_err(dev, \"Unsupported Peer ID %d\\n\", pidx);\n\t\treturn -EINVAL;\n\t}\n\n\tbar = idx + ndev->mw_bar;\n\n\tmw_size = pci_resource_len(ntb->pdev, bar);\n\n\tif (size > mw_size) {\n\t\tdev_err(dev, \"Size:%pa is greater than the MW size %pa\\n\",\n\t\t\t&size, &mw_size);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(lower_32_bits(addr), ndev->ctrl_reg + NTB_EPF_LOWER_ADDR);\n\twritel(upper_32_bits(addr), ndev->ctrl_reg + NTB_EPF_UPPER_ADDR);\n\twritel(lower_32_bits(size), ndev->ctrl_reg + NTB_EPF_LOWER_SIZE);\n\twritel(upper_32_bits(size), ndev->ctrl_reg + NTB_EPF_UPPER_SIZE);\n\tntb_epf_send_command(ndev, CMD_CONFIGURE_MW, idx);\n\n\treturn 0;\n}\n\nstatic int ntb_epf_mw_clear_trans(struct ntb_dev *ntb, int pidx, int idx)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tstruct device *dev = ndev->dev;\n\tint ret = 0;\n\n\tntb_epf_send_command(ndev, CMD_TEARDOWN_MW, idx);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to teardown memory window\\n\");\n\n\treturn ret;\n}\n\nstatic int ntb_epf_peer_mw_get_addr(struct ntb_dev *ntb, int idx,\n\t\t\t\t    phys_addr_t *base, resource_size_t *size)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tu32 offset = 0;\n\tint bar;\n\n\tif (idx == 0)\n\t\toffset = readl(ndev->ctrl_reg + NTB_EPF_MW1_OFFSET);\n\n\tbar = idx + ndev->mw_bar;\n\n\tif (base)\n\t\t*base = pci_resource_start(ndev->ntb.pdev, bar) + offset;\n\n\tif (size)\n\t\t*size = pci_resource_len(ndev->ntb.pdev, bar) - offset;\n\n\treturn 0;\n}\n\nstatic int ntb_epf_peer_db_set(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\tu32 interrupt_num = ffs(db_bits) + 1;\n\tstruct device *dev = ndev->dev;\n\tu32 db_entry_size;\n\tu32 db_offset;\n\tu32 db_data;\n\n\tif (interrupt_num > ndev->db_count) {\n\t\tdev_err(dev, \"DB interrupt %d greater than Max Supported %d\\n\",\n\t\t\tinterrupt_num, ndev->db_count);\n\t\treturn -EINVAL;\n\t}\n\n\tdb_entry_size = readl(ndev->ctrl_reg + NTB_EPF_DB_ENTRY_SIZE);\n\n\tdb_data = readl(ndev->ctrl_reg + NTB_EPF_DB_DATA(interrupt_num));\n\tdb_offset = readl(ndev->ctrl_reg + NTB_EPF_DB_OFFSET(interrupt_num));\n\twritel(db_data, ndev->db_reg + (db_entry_size * interrupt_num) +\n\t       db_offset);\n\n\treturn 0;\n}\n\nstatic u64 ntb_epf_db_read(struct ntb_dev *ntb)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\n\treturn ndev->db_val;\n}\n\nstatic int ntb_epf_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn 0;\n}\n\nstatic int ntb_epf_db_clear(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct ntb_epf_dev *ndev = ntb_ndev(ntb);\n\n\tndev->db_val = 0;\n\n\treturn 0;\n}\n\nstatic const struct ntb_dev_ops ntb_epf_ops = {\n\t.mw_count\t\t= ntb_epf_mw_count,\n\t.spad_count\t\t= ntb_epf_spad_count,\n\t.peer_mw_count\t\t= ntb_epf_peer_mw_count,\n\t.db_valid_mask\t\t= ntb_epf_db_valid_mask,\n\t.db_set_mask\t\t= ntb_epf_db_set_mask,\n\t.mw_set_trans\t\t= ntb_epf_mw_set_trans,\n\t.mw_clear_trans\t\t= ntb_epf_mw_clear_trans,\n\t.peer_mw_get_addr\t= ntb_epf_peer_mw_get_addr,\n\t.link_enable\t\t= ntb_epf_link_enable,\n\t.spad_read\t\t= ntb_epf_spad_read,\n\t.spad_write\t\t= ntb_epf_spad_write,\n\t.peer_spad_read\t\t= ntb_epf_peer_spad_read,\n\t.peer_spad_write\t= ntb_epf_peer_spad_write,\n\t.peer_db_set\t\t= ntb_epf_peer_db_set,\n\t.db_read\t\t= ntb_epf_db_read,\n\t.mw_get_align\t\t= ntb_epf_mw_get_align,\n\t.link_is_up\t\t= ntb_epf_link_is_up,\n\t.db_clear_mask\t\t= ntb_epf_db_clear_mask,\n\t.db_clear\t\t= ntb_epf_db_clear,\n\t.link_disable\t\t= ntb_epf_link_disable,\n};\n\nstatic inline void ntb_epf_init_struct(struct ntb_epf_dev *ndev,\n\t\t\t\t       struct pci_dev *pdev)\n{\n\tndev->ntb.pdev = pdev;\n\tndev->ntb.topo = NTB_TOPO_NONE;\n\tndev->ntb.ops = &ntb_epf_ops;\n}\n\nstatic int ntb_epf_init_dev(struct ntb_epf_dev *ndev)\n{\n\tstruct device *dev = ndev->dev;\n\tint ret;\n\n\t \n\tret = ntb_epf_init_isr(ndev, NTB_EPF_MIN_DB_COUNT + 1,\n\t\t\t       NTB_EPF_MAX_DB_COUNT + 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init ISR\\n\");\n\t\treturn ret;\n\t}\n\n\tndev->db_valid_mask = BIT_ULL(ndev->db_count) - 1;\n\tndev->mw_count = readl(ndev->ctrl_reg + NTB_EPF_MW_COUNT);\n\tndev->spad_count = readl(ndev->ctrl_reg + NTB_EPF_SPAD_COUNT);\n\n\treturn 0;\n}\n\nstatic int ntb_epf_init_pci(struct ntb_epf_dev *ndev,\n\t\t\t    struct pci_dev *pdev)\n{\n\tstruct device *dev = ndev->dev;\n\tsize_t spad_sz, spad_off;\n\tint ret;\n\n\tpci_set_drvdata(pdev, ndev);\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable PCI device\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\tret = pci_request_regions(pdev, \"ntb\");\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot obtain PCI resources\\n\");\n\t\tgoto err_pci_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot set DMA mask\\n\");\n\t\t\tgoto err_pci_regions;\n\t\t}\n\t\tdev_warn(&pdev->dev, \"Cannot DMA highmem\\n\");\n\t}\n\n\tndev->ctrl_reg = pci_iomap(pdev, ndev->ctrl_reg_bar, 0);\n\tif (!ndev->ctrl_reg) {\n\t\tret = -EIO;\n\t\tgoto err_pci_regions;\n\t}\n\n\tif (ndev->peer_spad_reg_bar) {\n\t\tndev->peer_spad_reg = pci_iomap(pdev, ndev->peer_spad_reg_bar, 0);\n\t\tif (!ndev->peer_spad_reg) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_pci_regions;\n\t\t}\n\t} else {\n\t\tspad_sz = 4 * readl(ndev->ctrl_reg + NTB_EPF_SPAD_COUNT);\n\t\tspad_off = readl(ndev->ctrl_reg + NTB_EPF_SPAD_OFFSET);\n\t\tndev->peer_spad_reg = ndev->ctrl_reg + spad_off  + spad_sz;\n\t}\n\n\tndev->db_reg = pci_iomap(pdev, ndev->db_reg_bar, 0);\n\tif (!ndev->db_reg) {\n\t\tret = -EIO;\n\t\tgoto err_pci_regions;\n\t}\n\n\treturn 0;\n\nerr_pci_regions:\n\tpci_disable_device(pdev);\n\nerr_pci_enable:\n\tpci_set_drvdata(pdev, NULL);\n\n\treturn ret;\n}\n\nstatic void ntb_epf_deinit_pci(struct ntb_epf_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\n\tpci_iounmap(pdev, ndev->ctrl_reg);\n\tpci_iounmap(pdev, ndev->peer_spad_reg);\n\tpci_iounmap(pdev, ndev->db_reg);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic void ntb_epf_cleanup_isr(struct ntb_epf_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tint i;\n\n\tntb_epf_send_command(ndev, CMD_TEARDOWN_DOORBELL, ndev->db_count + 1);\n\n\tfor (i = 0; i < ndev->db_count + 1; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), ndev);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int ntb_epf_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tenum pci_barno peer_spad_reg_bar = BAR_1;\n\tenum pci_barno ctrl_reg_bar = BAR_0;\n\tenum pci_barno db_reg_bar = BAR_2;\n\tenum pci_barno mw_bar = BAR_2;\n\tstruct device *dev = &pdev->dev;\n\tstruct ntb_epf_data *data;\n\tstruct ntb_epf_dev *ndev;\n\tint ret;\n\n\tif (pci_is_bridge(pdev))\n\t\treturn -ENODEV;\n\n\tndev = devm_kzalloc(dev, sizeof(*ndev), GFP_KERNEL);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdata = (struct ntb_epf_data *)id->driver_data;\n\tif (data) {\n\t\tpeer_spad_reg_bar = data->peer_spad_reg_bar;\n\t\tctrl_reg_bar = data->ctrl_reg_bar;\n\t\tdb_reg_bar = data->db_reg_bar;\n\t\tmw_bar = data->mw_bar;\n\t}\n\n\tndev->peer_spad_reg_bar = peer_spad_reg_bar;\n\tndev->ctrl_reg_bar = ctrl_reg_bar;\n\tndev->db_reg_bar = db_reg_bar;\n\tndev->mw_bar = mw_bar;\n\tndev->dev = dev;\n\n\tntb_epf_init_struct(ndev, pdev);\n\tmutex_init(&ndev->cmd_lock);\n\n\tret = ntb_epf_init_pci(ndev, pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init PCI\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ntb_epf_init_dev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init device\\n\");\n\t\tgoto err_init_dev;\n\t}\n\n\tret = ntb_register_device(&ndev->ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register NTB device\\n\");\n\t\tgoto err_register_dev;\n\t}\n\n\treturn 0;\n\nerr_register_dev:\n\tntb_epf_cleanup_isr(ndev);\n\nerr_init_dev:\n\tntb_epf_deinit_pci(ndev);\n\n\treturn ret;\n}\n\nstatic void ntb_epf_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ntb_epf_dev *ndev = pci_get_drvdata(pdev);\n\n\tntb_unregister_device(&ndev->ntb);\n\tntb_epf_cleanup_isr(ndev);\n\tntb_epf_deinit_pci(ndev);\n}\n\nstatic const struct ntb_epf_data j721e_data = {\n\t.ctrl_reg_bar = BAR_0,\n\t.peer_spad_reg_bar = BAR_1,\n\t.db_reg_bar = BAR_2,\n\t.mw_bar = BAR_2,\n};\n\nstatic const struct ntb_epf_data mx8_data = {\n\t.ctrl_reg_bar = BAR_0,\n\t.peer_spad_reg_bar = BAR_0,\n\t.db_reg_bar = BAR_2,\n\t.mw_bar = BAR_4,\n};\n\nstatic const struct pci_device_id ntb_epf_pci_tbl[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_J721E),\n\t\t.class = PCI_CLASS_MEMORY_RAM << 8, .class_mask = 0xffff00,\n\t\t.driver_data = (kernel_ulong_t)&j721e_data,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_FREESCALE, 0x0809),\n\t\t.class = PCI_CLASS_MEMORY_RAM << 8, .class_mask = 0xffff00,\n\t\t.driver_data = (kernel_ulong_t)&mx8_data,\n\t},\n\t{ },\n};\n\nstatic struct pci_driver ntb_epf_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= ntb_epf_pci_tbl,\n\t.probe\t\t= ntb_epf_pci_probe,\n\t.remove\t\t= ntb_epf_pci_remove,\n};\nmodule_pci_driver(ntb_epf_pci_driver);\n\nMODULE_DESCRIPTION(\"PCI ENDPOINT NTB HOST DRIVER\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}