{
  "module_name": "ntb_hw_idt.c",
  "hash_id": "2326a3720c556d77db1b420cfc7b965eca5ae38bdca2ff7e9f6786da5e4963e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/hw/idt/ntb_hw_idt.c",
  "human_readable_source": " \n\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/sizes.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/ntb.h>\n\n#include \"ntb_hw_idt.h\"\n\n#define NTB_NAME\t\"ntb_hw_idt\"\n#define NTB_DESC\t\"IDT PCI-E Non-Transparent Bridge Driver\"\n#define NTB_VER\t\t\"2.0\"\n#define NTB_IRQNAME\t\"ntb_irq_idt\"\n\nMODULE_DESCRIPTION(NTB_DESC);\nMODULE_VERSION(NTB_VER);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"T-platforms\");\n\n \nstatic const struct idt_ntb_regs ntdata_tbl = {\n\t{ {IDT_NT_BARSETUP0,\tIDT_NT_BARLIMIT0,\n\t   IDT_NT_BARLTBASE0,\tIDT_NT_BARUTBASE0},\n\t  {IDT_NT_BARSETUP1,\tIDT_NT_BARLIMIT1,\n\t   IDT_NT_BARLTBASE1,\tIDT_NT_BARUTBASE1},\n\t  {IDT_NT_BARSETUP2,\tIDT_NT_BARLIMIT2,\n\t   IDT_NT_BARLTBASE2,\tIDT_NT_BARUTBASE2},\n\t  {IDT_NT_BARSETUP3,\tIDT_NT_BARLIMIT3,\n\t   IDT_NT_BARLTBASE3,\tIDT_NT_BARUTBASE3},\n\t  {IDT_NT_BARSETUP4,\tIDT_NT_BARLIMIT4,\n\t   IDT_NT_BARLTBASE4,\tIDT_NT_BARUTBASE4},\n\t  {IDT_NT_BARSETUP5,\tIDT_NT_BARLIMIT5,\n\t   IDT_NT_BARLTBASE5,\tIDT_NT_BARUTBASE5} },\n\t{ {IDT_NT_INMSG0,\tIDT_NT_OUTMSG0,\tIDT_NT_INMSGSRC0},\n\t  {IDT_NT_INMSG1,\tIDT_NT_OUTMSG1,\tIDT_NT_INMSGSRC1},\n\t  {IDT_NT_INMSG2,\tIDT_NT_OUTMSG2,\tIDT_NT_INMSGSRC2},\n\t  {IDT_NT_INMSG3,\tIDT_NT_OUTMSG3,\tIDT_NT_INMSGSRC3} }\n};\n\n \nstatic const struct idt_ntb_port portdata_tbl[IDT_MAX_NR_PORTS] = {\n \t{ IDT_SW_NTP0_PCIECMDSTS,\tIDT_SW_NTP0_PCIELCTLSTS,\n\t  IDT_SW_NTP0_NTCTL,\n\t  IDT_SW_SWPORT0CTL,\t\tIDT_SW_SWPORT0STS,\n\t  { {IDT_SW_NTP0_BARSETUP0,\tIDT_SW_NTP0_BARLIMIT0,\n\t     IDT_SW_NTP0_BARLTBASE0,\tIDT_SW_NTP0_BARUTBASE0},\n\t    {IDT_SW_NTP0_BARSETUP1,\tIDT_SW_NTP0_BARLIMIT1,\n\t     IDT_SW_NTP0_BARLTBASE1,\tIDT_SW_NTP0_BARUTBASE1},\n\t    {IDT_SW_NTP0_BARSETUP2,\tIDT_SW_NTP0_BARLIMIT2,\n\t     IDT_SW_NTP0_BARLTBASE2,\tIDT_SW_NTP0_BARUTBASE2},\n\t    {IDT_SW_NTP0_BARSETUP3,\tIDT_SW_NTP0_BARLIMIT3,\n\t     IDT_SW_NTP0_BARLTBASE3,\tIDT_SW_NTP0_BARUTBASE3},\n\t    {IDT_SW_NTP0_BARSETUP4,\tIDT_SW_NTP0_BARLIMIT4,\n\t     IDT_SW_NTP0_BARLTBASE4,\tIDT_SW_NTP0_BARUTBASE4},\n\t    {IDT_SW_NTP0_BARSETUP5,\tIDT_SW_NTP0_BARLIMIT5,\n\t     IDT_SW_NTP0_BARLTBASE5,\tIDT_SW_NTP0_BARUTBASE5} } },\n \t{0},\n \t{ IDT_SW_NTP2_PCIECMDSTS,\tIDT_SW_NTP2_PCIELCTLSTS,\n\t  IDT_SW_NTP2_NTCTL,\n\t  IDT_SW_SWPORT2CTL,\t\tIDT_SW_SWPORT2STS,\n\t  { {IDT_SW_NTP2_BARSETUP0,\tIDT_SW_NTP2_BARLIMIT0,\n\t     IDT_SW_NTP2_BARLTBASE0,\tIDT_SW_NTP2_BARUTBASE0},\n\t    {IDT_SW_NTP2_BARSETUP1,\tIDT_SW_NTP2_BARLIMIT1,\n\t     IDT_SW_NTP2_BARLTBASE1,\tIDT_SW_NTP2_BARUTBASE1},\n\t    {IDT_SW_NTP2_BARSETUP2,\tIDT_SW_NTP2_BARLIMIT2,\n\t     IDT_SW_NTP2_BARLTBASE2,\tIDT_SW_NTP2_BARUTBASE2},\n\t    {IDT_SW_NTP2_BARSETUP3,\tIDT_SW_NTP2_BARLIMIT3,\n\t     IDT_SW_NTP2_BARLTBASE3,\tIDT_SW_NTP2_BARUTBASE3},\n\t    {IDT_SW_NTP2_BARSETUP4,\tIDT_SW_NTP2_BARLIMIT4,\n\t     IDT_SW_NTP2_BARLTBASE4,\tIDT_SW_NTP2_BARUTBASE4},\n\t    {IDT_SW_NTP2_BARSETUP5,\tIDT_SW_NTP2_BARLIMIT5,\n\t     IDT_SW_NTP2_BARLTBASE5,\tIDT_SW_NTP2_BARUTBASE5} } },\n \t{0},\n \t{ IDT_SW_NTP4_PCIECMDSTS,\tIDT_SW_NTP4_PCIELCTLSTS,\n\t  IDT_SW_NTP4_NTCTL,\n\t  IDT_SW_SWPORT4CTL,\t\tIDT_SW_SWPORT4STS,\n\t  { {IDT_SW_NTP4_BARSETUP0,\tIDT_SW_NTP4_BARLIMIT0,\n\t     IDT_SW_NTP4_BARLTBASE0,\tIDT_SW_NTP4_BARUTBASE0},\n\t    {IDT_SW_NTP4_BARSETUP1,\tIDT_SW_NTP4_BARLIMIT1,\n\t     IDT_SW_NTP4_BARLTBASE1,\tIDT_SW_NTP4_BARUTBASE1},\n\t    {IDT_SW_NTP4_BARSETUP2,\tIDT_SW_NTP4_BARLIMIT2,\n\t     IDT_SW_NTP4_BARLTBASE2,\tIDT_SW_NTP4_BARUTBASE2},\n\t    {IDT_SW_NTP4_BARSETUP3,\tIDT_SW_NTP4_BARLIMIT3,\n\t     IDT_SW_NTP4_BARLTBASE3,\tIDT_SW_NTP4_BARUTBASE3},\n\t    {IDT_SW_NTP4_BARSETUP4,\tIDT_SW_NTP4_BARLIMIT4,\n\t     IDT_SW_NTP4_BARLTBASE4,\tIDT_SW_NTP4_BARUTBASE4},\n\t    {IDT_SW_NTP4_BARSETUP5,\tIDT_SW_NTP4_BARLIMIT5,\n\t     IDT_SW_NTP4_BARLTBASE5,\tIDT_SW_NTP4_BARUTBASE5} } },\n \t{0},\n \t{ IDT_SW_NTP6_PCIECMDSTS,\tIDT_SW_NTP6_PCIELCTLSTS,\n\t  IDT_SW_NTP6_NTCTL,\n\t  IDT_SW_SWPORT6CTL,\t\tIDT_SW_SWPORT6STS,\n\t  { {IDT_SW_NTP6_BARSETUP0,\tIDT_SW_NTP6_BARLIMIT0,\n\t     IDT_SW_NTP6_BARLTBASE0,\tIDT_SW_NTP6_BARUTBASE0},\n\t    {IDT_SW_NTP6_BARSETUP1,\tIDT_SW_NTP6_BARLIMIT1,\n\t     IDT_SW_NTP6_BARLTBASE1,\tIDT_SW_NTP6_BARUTBASE1},\n\t    {IDT_SW_NTP6_BARSETUP2,\tIDT_SW_NTP6_BARLIMIT2,\n\t     IDT_SW_NTP6_BARLTBASE2,\tIDT_SW_NTP6_BARUTBASE2},\n\t    {IDT_SW_NTP6_BARSETUP3,\tIDT_SW_NTP6_BARLIMIT3,\n\t     IDT_SW_NTP6_BARLTBASE3,\tIDT_SW_NTP6_BARUTBASE3},\n\t    {IDT_SW_NTP6_BARSETUP4,\tIDT_SW_NTP6_BARLIMIT4,\n\t     IDT_SW_NTP6_BARLTBASE4,\tIDT_SW_NTP6_BARUTBASE4},\n\t    {IDT_SW_NTP6_BARSETUP5,\tIDT_SW_NTP6_BARLIMIT5,\n\t     IDT_SW_NTP6_BARLTBASE5,\tIDT_SW_NTP6_BARUTBASE5} } },\n \t{0},\n \t{ IDT_SW_NTP8_PCIECMDSTS,\tIDT_SW_NTP8_PCIELCTLSTS,\n\t  IDT_SW_NTP8_NTCTL,\n\t  IDT_SW_SWPORT8CTL,\t\tIDT_SW_SWPORT8STS,\n\t  { {IDT_SW_NTP8_BARSETUP0,\tIDT_SW_NTP8_BARLIMIT0,\n\t     IDT_SW_NTP8_BARLTBASE0,\tIDT_SW_NTP8_BARUTBASE0},\n\t    {IDT_SW_NTP8_BARSETUP1,\tIDT_SW_NTP8_BARLIMIT1,\n\t     IDT_SW_NTP8_BARLTBASE1,\tIDT_SW_NTP8_BARUTBASE1},\n\t    {IDT_SW_NTP8_BARSETUP2,\tIDT_SW_NTP8_BARLIMIT2,\n\t     IDT_SW_NTP8_BARLTBASE2,\tIDT_SW_NTP8_BARUTBASE2},\n\t    {IDT_SW_NTP8_BARSETUP3,\tIDT_SW_NTP8_BARLIMIT3,\n\t     IDT_SW_NTP8_BARLTBASE3,\tIDT_SW_NTP8_BARUTBASE3},\n\t    {IDT_SW_NTP8_BARSETUP4,\tIDT_SW_NTP8_BARLIMIT4,\n\t     IDT_SW_NTP8_BARLTBASE4,\tIDT_SW_NTP8_BARUTBASE4},\n\t    {IDT_SW_NTP8_BARSETUP5,\tIDT_SW_NTP8_BARLIMIT5,\n\t     IDT_SW_NTP8_BARLTBASE5,\tIDT_SW_NTP8_BARUTBASE5} } },\n \t{0},\n \t{0},\n \t{0},\n \t{ IDT_SW_NTP12_PCIECMDSTS,\tIDT_SW_NTP12_PCIELCTLSTS,\n\t  IDT_SW_NTP12_NTCTL,\n\t  IDT_SW_SWPORT12CTL,\t\tIDT_SW_SWPORT12STS,\n\t  { {IDT_SW_NTP12_BARSETUP0,\tIDT_SW_NTP12_BARLIMIT0,\n\t     IDT_SW_NTP12_BARLTBASE0,\tIDT_SW_NTP12_BARUTBASE0},\n\t    {IDT_SW_NTP12_BARSETUP1,\tIDT_SW_NTP12_BARLIMIT1,\n\t     IDT_SW_NTP12_BARLTBASE1,\tIDT_SW_NTP12_BARUTBASE1},\n\t    {IDT_SW_NTP12_BARSETUP2,\tIDT_SW_NTP12_BARLIMIT2,\n\t     IDT_SW_NTP12_BARLTBASE2,\tIDT_SW_NTP12_BARUTBASE2},\n\t    {IDT_SW_NTP12_BARSETUP3,\tIDT_SW_NTP12_BARLIMIT3,\n\t     IDT_SW_NTP12_BARLTBASE3,\tIDT_SW_NTP12_BARUTBASE3},\n\t    {IDT_SW_NTP12_BARSETUP4,\tIDT_SW_NTP12_BARLIMIT4,\n\t     IDT_SW_NTP12_BARLTBASE4,\tIDT_SW_NTP12_BARUTBASE4},\n\t    {IDT_SW_NTP12_BARSETUP5,\tIDT_SW_NTP12_BARLIMIT5,\n\t     IDT_SW_NTP12_BARLTBASE5,\tIDT_SW_NTP12_BARUTBASE5} } },\n \t{0},\n \t{0},\n \t{0},\n \t{ IDT_SW_NTP16_PCIECMDSTS,\tIDT_SW_NTP16_PCIELCTLSTS,\n\t  IDT_SW_NTP16_NTCTL,\n\t  IDT_SW_SWPORT16CTL,\t\tIDT_SW_SWPORT16STS,\n\t  { {IDT_SW_NTP16_BARSETUP0,\tIDT_SW_NTP16_BARLIMIT0,\n\t     IDT_SW_NTP16_BARLTBASE0,\tIDT_SW_NTP16_BARUTBASE0},\n\t    {IDT_SW_NTP16_BARSETUP1,\tIDT_SW_NTP16_BARLIMIT1,\n\t     IDT_SW_NTP16_BARLTBASE1,\tIDT_SW_NTP16_BARUTBASE1},\n\t    {IDT_SW_NTP16_BARSETUP2,\tIDT_SW_NTP16_BARLIMIT2,\n\t     IDT_SW_NTP16_BARLTBASE2,\tIDT_SW_NTP16_BARUTBASE2},\n\t    {IDT_SW_NTP16_BARSETUP3,\tIDT_SW_NTP16_BARLIMIT3,\n\t     IDT_SW_NTP16_BARLTBASE3,\tIDT_SW_NTP16_BARUTBASE3},\n\t    {IDT_SW_NTP16_BARSETUP4,\tIDT_SW_NTP16_BARLIMIT4,\n\t     IDT_SW_NTP16_BARLTBASE4,\tIDT_SW_NTP16_BARUTBASE4},\n\t    {IDT_SW_NTP16_BARSETUP5,\tIDT_SW_NTP16_BARLIMIT5,\n\t     IDT_SW_NTP16_BARLTBASE5,\tIDT_SW_NTP16_BARUTBASE5} } },\n \t{0},\n \t{0},\n \t{0},\n \t{ IDT_SW_NTP20_PCIECMDSTS,\tIDT_SW_NTP20_PCIELCTLSTS,\n\t  IDT_SW_NTP20_NTCTL,\n\t  IDT_SW_SWPORT20CTL,\t\tIDT_SW_SWPORT20STS,\n\t  { {IDT_SW_NTP20_BARSETUP0,\tIDT_SW_NTP20_BARLIMIT0,\n\t     IDT_SW_NTP20_BARLTBASE0,\tIDT_SW_NTP20_BARUTBASE0},\n\t    {IDT_SW_NTP20_BARSETUP1,\tIDT_SW_NTP20_BARLIMIT1,\n\t     IDT_SW_NTP20_BARLTBASE1,\tIDT_SW_NTP20_BARUTBASE1},\n\t    {IDT_SW_NTP20_BARSETUP2,\tIDT_SW_NTP20_BARLIMIT2,\n\t     IDT_SW_NTP20_BARLTBASE2,\tIDT_SW_NTP20_BARUTBASE2},\n\t    {IDT_SW_NTP20_BARSETUP3,\tIDT_SW_NTP20_BARLIMIT3,\n\t     IDT_SW_NTP20_BARLTBASE3,\tIDT_SW_NTP20_BARUTBASE3},\n\t    {IDT_SW_NTP20_BARSETUP4,\tIDT_SW_NTP20_BARLIMIT4,\n\t     IDT_SW_NTP20_BARLTBASE4,\tIDT_SW_NTP20_BARUTBASE4},\n\t    {IDT_SW_NTP20_BARSETUP5,\tIDT_SW_NTP20_BARLIMIT5,\n\t     IDT_SW_NTP20_BARLTBASE5,\tIDT_SW_NTP20_BARUTBASE5} } },\n \t{0},\n \t{0},\n \t{0}\n};\n\n \nstatic const struct idt_ntb_part partdata_tbl[IDT_MAX_NR_PARTS] = {\n \t{ IDT_SW_SWPART0CTL,\tIDT_SW_SWPART0STS,\n\t  {IDT_SW_SWP0MSGCTL0,\tIDT_SW_SWP0MSGCTL1,\n\t   IDT_SW_SWP0MSGCTL2,\tIDT_SW_SWP0MSGCTL3} },\n \t{ IDT_SW_SWPART1CTL,\tIDT_SW_SWPART1STS,\n\t  {IDT_SW_SWP1MSGCTL0,\tIDT_SW_SWP1MSGCTL1,\n\t   IDT_SW_SWP1MSGCTL2,\tIDT_SW_SWP1MSGCTL3} },\n \t{ IDT_SW_SWPART2CTL,\tIDT_SW_SWPART2STS,\n\t  {IDT_SW_SWP2MSGCTL0,\tIDT_SW_SWP2MSGCTL1,\n\t   IDT_SW_SWP2MSGCTL2,\tIDT_SW_SWP2MSGCTL3} },\n \t{ IDT_SW_SWPART3CTL,\tIDT_SW_SWPART3STS,\n\t  {IDT_SW_SWP3MSGCTL0,\tIDT_SW_SWP3MSGCTL1,\n\t   IDT_SW_SWP3MSGCTL2,\tIDT_SW_SWP3MSGCTL3} },\n \t{ IDT_SW_SWPART4CTL,\tIDT_SW_SWPART4STS,\n\t  {IDT_SW_SWP4MSGCTL0,\tIDT_SW_SWP4MSGCTL1,\n\t   IDT_SW_SWP4MSGCTL2,\tIDT_SW_SWP4MSGCTL3} },\n \t{ IDT_SW_SWPART5CTL,\tIDT_SW_SWPART5STS,\n\t  {IDT_SW_SWP5MSGCTL0,\tIDT_SW_SWP5MSGCTL1,\n\t   IDT_SW_SWP5MSGCTL2,\tIDT_SW_SWP5MSGCTL3} },\n \t{ IDT_SW_SWPART6CTL,\tIDT_SW_SWPART6STS,\n\t  {IDT_SW_SWP6MSGCTL0,\tIDT_SW_SWP6MSGCTL1,\n\t   IDT_SW_SWP6MSGCTL2,\tIDT_SW_SWP6MSGCTL3} },\n \t{ IDT_SW_SWPART7CTL,\tIDT_SW_SWPART7STS,\n\t  {IDT_SW_SWP7MSGCTL0,\tIDT_SW_SWP7MSGCTL1,\n\t   IDT_SW_SWP7MSGCTL2,\tIDT_SW_SWP7MSGCTL3} }\n};\n\n \nstatic struct dentry *dbgfs_topdir;\n\n \n\n \nstatic void idt_nt_write(struct idt_ntb_dev *ndev,\n\t\t\t const unsigned int reg, const u32 data)\n{\n\t \n\tif (WARN_ON(reg > IDT_REG_PCI_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\n\t\treturn;\n\n\t \n\tiowrite32(data, ndev->cfgspc + (ptrdiff_t)reg);\n}\n\n \nstatic u32 idt_nt_read(struct idt_ntb_dev *ndev, const unsigned int reg)\n{\n\t \n\tif (WARN_ON(reg > IDT_REG_PCI_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\n\t\treturn ~0;\n\n\t \n\treturn ioread32(ndev->cfgspc + (ptrdiff_t)reg);\n}\n\n \nstatic void idt_sw_write(struct idt_ntb_dev *ndev,\n\t\t\t const unsigned int reg, const u32 data)\n{\n\tunsigned long irqflags;\n\n\t \n\tif (WARN_ON(reg > IDT_REG_SW_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&ndev->gasa_lock, irqflags);\n\t \n\tiowrite32((u32)reg, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASAADDR);\n\t \n\tiowrite32(data, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASADATA);\n\t \n\tspin_unlock_irqrestore(&ndev->gasa_lock, irqflags);\n}\n\n \nstatic u32 idt_sw_read(struct idt_ntb_dev *ndev, const unsigned int reg)\n{\n\tunsigned long irqflags;\n\tu32 data;\n\n\t \n\tif (WARN_ON(reg > IDT_REG_SW_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\n\t\treturn ~0;\n\n\t \n\tspin_lock_irqsave(&ndev->gasa_lock, irqflags);\n\t \n\tiowrite32((u32)reg, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASAADDR);\n\t \n\tdata = ioread32(ndev->cfgspc + (ptrdiff_t)IDT_NT_GASADATA);\n\t \n\tspin_unlock_irqrestore(&ndev->gasa_lock, irqflags);\n\n\treturn data;\n}\n\n \nstatic inline int idt_reg_set_bits(struct idt_ntb_dev *ndev, unsigned int reg,\n\t\t\t\t   spinlock_t *reg_lock,\n\t\t\t\t   u64 valid_mask, u64 set_bits)\n{\n\tunsigned long irqflags;\n\tu32 data;\n\n\tif (set_bits & ~(u64)valid_mask)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irqsave(reg_lock, irqflags);\n\tdata = idt_nt_read(ndev, reg) | (u32)set_bits;\n\tidt_nt_write(ndev, reg, data);\n\t \n\tspin_unlock_irqrestore(reg_lock, irqflags);\n\n\treturn 0;\n}\n\n \nstatic inline void idt_reg_clear_bits(struct idt_ntb_dev *ndev,\n\t\t\t\t     unsigned int reg, spinlock_t *reg_lock,\n\t\t\t\t     u64 clear_bits)\n{\n\tunsigned long irqflags;\n\tu32 data;\n\n\t \n\tspin_lock_irqsave(reg_lock, irqflags);\n\tdata = idt_nt_read(ndev, reg) & ~(u32)clear_bits;\n\tidt_nt_write(ndev, reg, data);\n\t \n\tspin_unlock_irqrestore(reg_lock, irqflags);\n}\n\n \n\n \nstatic int idt_scan_ports(struct idt_ntb_dev *ndev)\n{\n\tunsigned char pidx, port, part;\n\tu32 data, portsts, partsts;\n\n\t \n\tdata = idt_nt_read(ndev, IDT_NT_PCIELCAP);\n\tndev->port = GET_FIELD(PCIELCAP_PORTNUM, data);\n\n\t \n\tportsts = idt_sw_read(ndev, portdata_tbl[ndev->port].sts);\n\tndev->part = GET_FIELD(SWPORTxSTS_SWPART, portsts);\n\n\t \n\tmemset(ndev->port_idx_map, -EINVAL, sizeof(ndev->port_idx_map));\n\tmemset(ndev->part_idx_map, -EINVAL, sizeof(ndev->part_idx_map));\n\n\t \n\tndev->peer_cnt = 0;\n\tfor (pidx = 0; pidx < ndev->swcfg->port_cnt; pidx++) {\n\t\tport = ndev->swcfg->ports[pidx];\n\t\t \n\t\tif (port == ndev->port)\n\t\t\tcontinue;\n\n\t\t \n\t\tportsts = idt_sw_read(ndev, portdata_tbl[port].sts);\n\t\tpart = GET_FIELD(SWPORTxSTS_SWPART, portsts);\n\n\t\t \n\t\tpartsts = idt_sw_read(ndev, partdata_tbl[part].sts);\n\t\t \n\t\tif (IS_FLD_SET(SWPARTxSTS_STATE, partsts, ACT) &&\n\t\t    (IS_FLD_SET(SWPORTxSTS_MODE, portsts, NT) ||\n\t\t     IS_FLD_SET(SWPORTxSTS_MODE, portsts, USNT) ||\n\t\t     IS_FLD_SET(SWPORTxSTS_MODE, portsts, USNTDMA) ||\n\t\t     IS_FLD_SET(SWPORTxSTS_MODE, portsts, NTDMA))) {\n\t\t\t \n\t\t\tndev->peers[ndev->peer_cnt].port = port;\n\t\t\tndev->peers[ndev->peer_cnt].part = part;\n\t\t\t \n\t\t\tndev->port_idx_map[port] = ndev->peer_cnt;\n\t\t\tndev->part_idx_map[part] = ndev->peer_cnt;\n\t\t\tndev->peer_cnt++;\n\t\t}\n\t}\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"Local port: %hhu, num of peers: %hhu\\n\",\n\t\tndev->port, ndev->peer_cnt);\n\n\t \n\tif (ndev->peer_cnt == 0) {\n\t\tdev_warn(&ndev->ntb.pdev->dev, \"No active peer found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_port_number(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn ndev->port;\n}\n\n \nstatic int idt_ntb_peer_port_count(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn ndev->peer_cnt;\n}\n\n \nstatic int idt_ntb_peer_port_number(struct ntb_dev *ntb, int pidx)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\t \n\treturn ndev->peers[pidx].port;\n}\n\n \nstatic int idt_ntb_peer_port_idx(struct ntb_dev *ntb, int port)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (port < 0 || IDT_MAX_NR_PORTS <= port)\n\t\treturn -EINVAL;\n\n\treturn ndev->port_idx_map[port];\n}\n\n \n\nstatic void idt_ntb_local_link_disable(struct idt_ntb_dev *ndev);\n\n \nstatic void idt_init_link(struct idt_ntb_dev *ndev)\n{\n\tu32 part_mask, port_mask, se_mask;\n\tunsigned char pidx;\n\n\t \n\tspin_lock_init(&ndev->mtbl_lock);\n\n\t \n\tport_mask = ~BIT(ndev->port);\n\tpart_mask = ~BIT(ndev->part);\n\tfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\n\t\tport_mask &= ~BIT(ndev->peers[pidx].port);\n\t\tpart_mask &= ~BIT(ndev->peers[pidx].part);\n\t}\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SELINKUPSTS, (u32)-1);\n\tidt_sw_write(ndev, IDT_SW_SELINKDNSTS, (u32)-1);\n\tidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)-1);\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SEPMSK, part_mask);\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SELINKUPMSK, port_mask);\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SELINKDNMSK, port_mask);\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SEGSIGMSK, part_mask);\n\n\t \n\tse_mask = ~(IDT_SEMSK_LINKUP | IDT_SEMSK_LINKDN | IDT_SEMSK_GSIGNAL);\n\tidt_sw_write(ndev, IDT_SW_SEMSK, se_mask);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB link status events initialized\");\n}\n\n \nstatic void idt_deinit_link(struct idt_ntb_dev *ndev)\n{\n\t \n\tidt_ntb_local_link_disable(ndev);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB link status events deinitialized\");\n}\n\n \nstatic void idt_se_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\n{\n\tu32 sests;\n\n\t \n\tsests = idt_sw_read(ndev, IDT_SW_SESTS);\n\n\t \n\tidt_sw_write(ndev, IDT_SW_SELINKUPSTS, (u32)-1);\n\tidt_sw_write(ndev, IDT_SW_SELINKDNSTS, (u32)-1);\n\tidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)-1);\n\n\t \n\tidt_nt_write(ndev, IDT_NT_NTINTSTS, IDT_NTINTSTS_SEVENT);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"SE IRQ detected %#08x (SESTS %#08x)\",\n\t\t\t  ntint_sts, sests);\n\n\t \n\tntb_link_event(&ndev->ntb);\n}\n\n \nstatic void idt_ntb_local_link_enable(struct idt_ntb_dev *ndev)\n{\n\tu32 reqid, mtbldata = 0;\n\tunsigned long irqflags;\n\n\t \n\tidt_nt_write(ndev, IDT_NT_NTCTL, IDT_NTCTL_CPEN);\n\n\t \n\treqid = idt_nt_read(ndev, IDT_NT_REQIDCAP);\n\n\t \n\tmtbldata = SET_FIELD(NTMTBLDATA_REQID, 0, reqid) |\n\t\t   SET_FIELD(NTMTBLDATA_PART, 0, ndev->part) |\n\t\t   IDT_NTMTBLDATA_VALID;\n\tspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLDATA, mtbldata);\n\tspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\n\n\t \n\tidt_nt_write(ndev, IDT_NT_NTGSIGNAL, IDT_NTGSIGNAL_SET);\n\tidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)1 << ndev->part);\n}\n\n \nstatic void idt_ntb_local_link_disable(struct idt_ntb_dev *ndev)\n{\n\tunsigned long irqflags;\n\n\t \n\tidt_nt_write(ndev, IDT_NT_NTCTL, 0);\n\n\t \n\tspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLDATA, 0);\n\tspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\n\n\t \n\tidt_nt_write(ndev, IDT_NT_NTGSIGNAL, IDT_NTGSIGNAL_SET);\n\tidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)1 << ndev->part);\n}\n\n \nstatic bool idt_ntb_local_link_is_up(struct idt_ntb_dev *ndev)\n{\n\tunsigned long irqflags;\n\tu32 data;\n\n\t \n\tdata = idt_nt_read(ndev, IDT_NT_PCICMDSTS);\n\tif (!(data & IDT_PCICMDSTS_BME))\n\t\treturn false;\n\n\t \n\tdata = idt_nt_read(ndev, IDT_NT_NTCTL);\n\tif (!(data & IDT_NTCTL_CPEN))\n\t\treturn false;\n\n\t \n\tspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\n\tdata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\n\tspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\n\n\treturn !!(data & IDT_NTMTBLDATA_VALID);\n}\n\n \nstatic bool idt_ntb_peer_link_is_up(struct idt_ntb_dev *ndev, int pidx)\n{\n\tunsigned long irqflags;\n\tunsigned char port;\n\tu32 data;\n\n\t \n\tport = ndev->peers[pidx].port;\n\n\t \n\tdata = idt_sw_read(ndev, portdata_tbl[port].sts);\n\tif (!(data & IDT_SWPORTxSTS_LINKUP))\n\t\treturn false;\n\n\t \n\tdata = idt_sw_read(ndev, portdata_tbl[port].pcicmdsts);\n\tif (!(data & IDT_PCICMDSTS_BME))\n\t\treturn false;\n\n\t \n\tdata = idt_sw_read(ndev, portdata_tbl[port].ntctl);\n\tif (!(data & IDT_NTCTL_CPEN))\n\t\treturn false;\n\n\t \n\tspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\n\tidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->peers[pidx].part);\n\tdata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\n\tspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\n\n\treturn !!(data & IDT_NTMTBLDATA_VALID);\n}\n\n \nstatic u64 idt_ntb_link_is_up(struct ntb_dev *ntb,\n\t\t\t      enum ntb_speed *speed, enum ntb_width *width)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\tunsigned char pidx;\n\tu64 status;\n\tu32 data;\n\n\t \n\tif (speed != NULL || width != NULL) {\n\t\tdata = idt_nt_read(ndev, IDT_NT_PCIELCTLSTS);\n\t\tif (speed != NULL)\n\t\t\t*speed = GET_FIELD(PCIELCTLSTS_CLS, data);\n\t\tif (width != NULL)\n\t\t\t*width = GET_FIELD(PCIELCTLSTS_NLW, data);\n\t}\n\n\t \n\tif (!idt_ntb_local_link_is_up(ndev))\n\t\treturn 0;\n\n\t \n\tstatus = 0;\n\tfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\n\t\tif (idt_ntb_peer_link_is_up(ndev, pidx))\n\t\t\tstatus |= ((u64)1 << pidx);\n\t}\n\n\treturn status;\n}\n\n \nstatic int idt_ntb_link_enable(struct ntb_dev *ntb, enum ntb_speed speed,\n\t\t\t       enum ntb_width width)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\t \n\tidt_ntb_local_link_enable(ndev);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"Local NTB link enabled\");\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_link_disable(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\t \n\tidt_ntb_local_link_disable(ndev);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"Local NTB link disabled\");\n\n\treturn 0;\n}\n\n \n\n \nstatic inline unsigned char idt_get_mw_count(enum idt_mw_type mw_type)\n{\n\tswitch (mw_type) {\n\tcase IDT_MW_DIR:\n\t\treturn 1;\n\tcase IDT_MW_LUT12:\n\t\treturn 12;\n\tcase IDT_MW_LUT24:\n\t\treturn 24;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline char *idt_get_mw_name(enum idt_mw_type mw_type)\n{\n\tswitch (mw_type) {\n\tcase IDT_MW_DIR:\n\t\treturn \"DIR  \";\n\tcase IDT_MW_LUT12:\n\t\treturn \"LUT12\";\n\tcase IDT_MW_LUT24:\n\t\treturn \"LUT24\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"unknown\";\n}\n\n \nstatic struct idt_mw_cfg *idt_scan_mws(struct idt_ntb_dev *ndev, int port,\n\t\t\t\t       unsigned char *mw_cnt)\n{\n\tstruct idt_mw_cfg mws[IDT_MAX_NR_MWS], *ret_mws;\n\tconst struct idt_ntb_bar *bars;\n\tenum idt_mw_type mw_type;\n\tunsigned char widx, bidx, en_cnt;\n\tbool bar_64bit = false;\n\tint aprt_size;\n\tu32 data;\n\n\t \n\tbars = portdata_tbl[port].bars;\n\n\t \n\t*mw_cnt = 0;\n\tfor (bidx = 0; bidx < IDT_BAR_CNT; bidx += 1 + bar_64bit) {\n\t\t \n\t\tdata = idt_sw_read(ndev, bars[bidx].setup);\n\n\t\t \n\t\tif (!(data & IDT_BARSETUP_EN)) {\n\t\t\tbar_64bit = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbar_64bit = IS_FLD_SET(BARSETUP_TYPE, data, 64);\n\n\t\t \n\t\tif (data & IDT_BARSETUP_MODE_CFG)\n\t\t\tcontinue;\n\n\t\t \n\t\tmw_type = GET_FIELD(BARSETUP_ATRAN, data);\n\t\ten_cnt = idt_get_mw_count(mw_type);\n\t\taprt_size = (u64)1 << GET_FIELD(BARSETUP_SIZE, data);\n\n\t\t \n\t\tfor (widx = 0; widx < en_cnt; widx++, (*mw_cnt)++) {\n\t\t\t \n\t\t\tif (*mw_cnt >= IDT_MAX_NR_MWS)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t \n\t\t\tmws[*mw_cnt].type = mw_type;\n\t\t\tmws[*mw_cnt].bar = bidx;\n\t\t\tmws[*mw_cnt].idx = widx;\n\t\t\t \n\t\t\tmws[*mw_cnt].addr_align = IDT_TRANS_ALIGN;\n\t\t\t \n\t\t\tif (mw_type == IDT_MW_DIR)\n\t\t\t\tmws[*mw_cnt].size_max = aprt_size;\n\t\t\telse if (mw_type == IDT_MW_LUT12)\n\t\t\t\tmws[*mw_cnt].size_max = aprt_size / 16;\n\t\t\telse\n\t\t\t\tmws[*mw_cnt].size_max = aprt_size / 32;\n\t\t\tmws[*mw_cnt].size_align = (mw_type == IDT_MW_DIR) ?\n\t\t\t\tIDT_DIR_SIZE_ALIGN : mws[*mw_cnt].size_max;\n\t\t}\n\t}\n\n\t \n\tret_mws = devm_kcalloc(&ndev->ntb.pdev->dev, *mw_cnt, sizeof(*ret_mws),\n\t\t\t       GFP_KERNEL);\n\tif (!ret_mws)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmemcpy(ret_mws, mws, (*mw_cnt)*sizeof(*ret_mws));\n\n\treturn ret_mws;\n}\n\n \nstatic int idt_init_mws(struct idt_ntb_dev *ndev)\n{\n\tstruct idt_ntb_peer *peer;\n\tunsigned char pidx;\n\n\t \n\tndev->mws = idt_scan_mws(ndev, ndev->port, &ndev->mw_cnt);\n\tif (IS_ERR(ndev->mws)) {\n\t\tdev_err(&ndev->ntb.pdev->dev,\n\t\t\t\"Failed to scan mws of local port %hhu\", ndev->port);\n\t\treturn PTR_ERR(ndev->mws);\n\t}\n\n\t \n\tfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\n\t\tpeer = &ndev->peers[pidx];\n\t\tpeer->mws = idt_scan_mws(ndev, peer->port, &peer->mw_cnt);\n\t\tif (IS_ERR(peer->mws)) {\n\t\t\tdev_err(&ndev->ntb.pdev->dev,\n\t\t\t\t\"Failed to scan mws of port %hhu\", peer->port);\n\t\t\treturn PTR_ERR(peer->mws);\n\t\t}\n\t}\n\n\t \n\tspin_lock_init(&ndev->lut_lock);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"Outbound and inbound MWs initialized\");\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_mw_count(struct ntb_dev *ntb, int pidx)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\treturn ndev->peers[pidx].mw_cnt;\n}\n\n \nstatic int idt_ntb_mw_get_align(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\tresource_size_t *addr_align,\n\t\t\t\tresource_size_t *size_align,\n\t\t\t\tresource_size_t *size_max)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\tstruct idt_ntb_peer *peer;\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\tpeer = &ndev->peers[pidx];\n\n\tif (widx < 0 || peer->mw_cnt <= widx)\n\t\treturn -EINVAL;\n\n\tif (addr_align != NULL)\n\t\t*addr_align = peer->mws[widx].addr_align;\n\n\tif (size_align != NULL)\n\t\t*size_align = peer->mws[widx].size_align;\n\n\tif (size_max != NULL)\n\t\t*size_max = peer->mws[widx].size_max;\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_peer_mw_count(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn ndev->mw_cnt;\n}\n\n \nstatic int idt_ntb_peer_mw_get_addr(struct ntb_dev *ntb, int widx,\n\t\t\t\t    phys_addr_t *base, resource_size_t *size)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (widx < 0 || ndev->mw_cnt <= widx)\n\t\treturn -EINVAL;\n\n\t \n\tif (base != NULL)\n\t\t*base = pci_resource_start(ntb->pdev, ndev->mws[widx].bar) +\n\t\t\tndev->mws[widx].idx * ndev->mws[widx].size_max;\n\n\t \n\tif (size != NULL)\n\t\t*size = ndev->mws[widx].size_max;\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_peer_mw_set_trans(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t     u64 addr, resource_size_t size)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\tstruct idt_mw_cfg *mw_cfg;\n\tu32 data = 0, lutoff = 0;\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\tif (widx < 0 || ndev->mw_cnt <= widx)\n\t\treturn -EINVAL;\n\n\t \n\tmw_cfg = &ndev->mws[widx];\n\tif (!IS_ALIGNED(addr, mw_cfg->addr_align))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(size, mw_cfg->size_align) || size > mw_cfg->size_max)\n\t\treturn -EINVAL;\n\n\t \n\tif (mw_cfg->type == IDT_MW_DIR) {\n\t\tconst struct idt_ntb_bar *bar = &ntdata_tbl.bars[mw_cfg->bar];\n\t\tu64 limit;\n\t\t \n\t\tdata = idt_nt_read(ndev, bar->setup);\n\t\tdata = SET_FIELD(BARSETUP_TPART, data, ndev->peers[pidx].part);\n\t\tidt_nt_write(ndev, bar->setup, data);\n\t\t \n\t\tidt_nt_write(ndev, bar->ltbase, (u32)addr);\n\t\tidt_nt_write(ndev, bar->utbase, (u32)(addr >> 32));\n\t\t \n\t\tlimit = pci_bus_address(ntb->pdev, mw_cfg->bar) + size;\n\t\tidt_nt_write(ndev, bar->limit, (u32)limit);\n\t\tif (IS_FLD_SET(BARSETUP_TYPE, data, 64))\n\t\t\tidt_nt_write(ndev, (bar + 1)->limit, (limit >> 32));\n\t} else {\n\t\tunsigned long irqflags;\n\t\t \n\t\tlutoff = SET_FIELD(LUTOFFSET_INDEX, 0, mw_cfg->idx) |\n\t\t\t SET_FIELD(LUTOFFSET_BAR, 0, mw_cfg->bar);\n\t\tdata = SET_FIELD(LUTUDATA_PART, 0, ndev->peers[pidx].part) |\n\t\t\tIDT_LUTUDATA_VALID;\n\t\tspin_lock_irqsave(&ndev->lut_lock, irqflags);\n\t\tidt_nt_write(ndev, IDT_NT_LUTOFFSET, lutoff);\n\t\tidt_nt_write(ndev, IDT_NT_LUTLDATA, (u32)addr);\n\t\tidt_nt_write(ndev, IDT_NT_LUTMDATA, (u32)(addr >> 32));\n\t\tidt_nt_write(ndev, IDT_NT_LUTUDATA, data);\n\t\tspin_unlock_irqrestore(&ndev->lut_lock, irqflags);\n\t\t \n\t}\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_peer_mw_clear_trans(struct ntb_dev *ntb, int pidx,\n\t\t\t\t\tint widx)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\tstruct idt_mw_cfg *mw_cfg;\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\tif (widx < 0 || ndev->mw_cnt <= widx)\n\t\treturn -EINVAL;\n\n\tmw_cfg = &ndev->mws[widx];\n\n\t \n\tif (mw_cfg->type == IDT_MW_DIR) {\n\t\tconst struct idt_ntb_bar *bar = &ntdata_tbl.bars[mw_cfg->bar];\n\t\tu32 data;\n\t\t \n\t\tdata = idt_nt_read(ndev, bar->setup);\n\t\t \n\t\tidt_nt_write(ndev, bar->limit, 0);\n\t\tif (IS_FLD_SET(BARSETUP_TYPE, data, 64))\n\t\t\tidt_nt_write(ndev, (bar + 1)->limit, 0);\n\t} else {\n\t\tunsigned long irqflags;\n\t\tu32 lutoff;\n\t\t \n\t\tlutoff = SET_FIELD(LUTOFFSET_INDEX, 0, mw_cfg->idx) |\n\t\t\t SET_FIELD(LUTOFFSET_BAR, 0, mw_cfg->bar);\n\t\tspin_lock_irqsave(&ndev->lut_lock, irqflags);\n\t\tidt_nt_write(ndev, IDT_NT_LUTOFFSET, lutoff);\n\t\tidt_nt_write(ndev, IDT_NT_LUTLDATA, 0);\n\t\tidt_nt_write(ndev, IDT_NT_LUTMDATA, 0);\n\t\tidt_nt_write(ndev, IDT_NT_LUTUDATA, 0);\n\t\tspin_unlock_irqrestore(&ndev->lut_lock, irqflags);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void idt_db_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\n{\n\t \n\tdev_dbg(&ndev->ntb.pdev->dev, \"DB IRQ detected %#08x\", ntint_sts);\n\n\t \n\tntb_db_event(&ndev->ntb, 0);\n}\n\n \nstatic u64 idt_ntb_db_valid_mask(struct ntb_dev *ntb)\n{\n\treturn IDT_DBELL_MASK;\n}\n\n \nstatic u64 idt_ntb_db_read(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn idt_nt_read(ndev, IDT_NT_INDBELLSTS);\n}\n\n \nstatic int idt_ntb_db_clear(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tidt_nt_write(ndev, IDT_NT_INDBELLSTS, (u32)db_bits);\n\n\treturn 0;\n}\n\n \nstatic u64 idt_ntb_db_read_mask(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn idt_nt_read(ndev, IDT_NT_INDBELLMSK);\n}\n\n \nstatic int idt_ntb_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn idt_reg_set_bits(ndev, IDT_NT_INDBELLMSK, &ndev->db_mask_lock,\n\t\t\t\tIDT_DBELL_MASK, db_bits);\n}\n\n \nstatic int idt_ntb_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tidt_reg_clear_bits(ndev, IDT_NT_INDBELLMSK, &ndev->db_mask_lock,\n\t\t\t   db_bits);\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_peer_db_set(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (db_bits & ~(u64)IDT_DBELL_MASK)\n\t\treturn -EINVAL;\n\n\tidt_nt_write(ndev, IDT_NT_OUTDBELLSET, (u32)db_bits);\n\treturn 0;\n}\n\n \n\n \nstatic void idt_init_msg(struct idt_ntb_dev *ndev)\n{\n\tunsigned char midx;\n\n\t \n\tfor (midx = 0; midx < IDT_MSG_CNT; midx++)\n\t\tspin_lock_init(&ndev->msg_locks[midx]);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB Messaging initialized\");\n}\n\n \nstatic void idt_msg_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\n{\n\t \n\tdev_dbg(&ndev->ntb.pdev->dev, \"Message IRQ detected %#08x\", ntint_sts);\n\n\t \n\tntb_msg_event(&ndev->ntb);\n}\n\n \nstatic int idt_ntb_msg_count(struct ntb_dev *ntb)\n{\n\treturn IDT_MSG_CNT;\n}\n\n \nstatic u64 idt_ntb_msg_inbits(struct ntb_dev *ntb)\n{\n\treturn (u64)IDT_INMSG_MASK;\n}\n\n \nstatic u64 idt_ntb_msg_outbits(struct ntb_dev *ntb)\n{\n\treturn (u64)IDT_OUTMSG_MASK;\n}\n\n \nstatic u64 idt_ntb_msg_read_sts(struct ntb_dev *ntb)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn idt_nt_read(ndev, IDT_NT_MSGSTS);\n}\n\n \nstatic int idt_ntb_msg_clear_sts(struct ntb_dev *ntb, u64 sts_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tidt_nt_write(ndev, IDT_NT_MSGSTS, sts_bits);\n\n\treturn 0;\n}\n\n \nstatic int idt_ntb_msg_set_mask(struct ntb_dev *ntb, u64 mask_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\treturn idt_reg_set_bits(ndev, IDT_NT_MSGSTSMSK, &ndev->msg_mask_lock,\n\t\t\t\tIDT_MSG_MASK, mask_bits);\n}\n\n \nstatic int idt_ntb_msg_clear_mask(struct ntb_dev *ntb, u64 mask_bits)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tidt_reg_clear_bits(ndev, IDT_NT_MSGSTSMSK, &ndev->msg_mask_lock,\n\t\t\t   mask_bits);\n\n\treturn 0;\n}\n\n \nstatic u32 idt_ntb_msg_read(struct ntb_dev *ntb, int *pidx, int midx)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\n\tif (midx < 0 || IDT_MSG_CNT <= midx)\n\t\treturn ~(u32)0;\n\n\t \n\tif (pidx != NULL) {\n\t\tu32 srcpart;\n\n\t\tsrcpart = idt_nt_read(ndev, ntdata_tbl.msgs[midx].src);\n\t\t*pidx = ndev->part_idx_map[srcpart];\n\n\t\t \n\t\tif (*pidx == -EINVAL)\n\t\t\t*pidx = 0;\n\t}\n\n\t \n\treturn idt_nt_read(ndev, ntdata_tbl.msgs[midx].in);\n}\n\n \nstatic int idt_ntb_peer_msg_write(struct ntb_dev *ntb, int pidx, int midx,\n\t\t\t\t  u32 msg)\n{\n\tstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\n\tunsigned long irqflags;\n\tu32 swpmsgctl = 0;\n\n\tif (midx < 0 || IDT_MSG_CNT <= midx)\n\t\treturn -EINVAL;\n\n\tif (pidx < 0 || ndev->peer_cnt <= pidx)\n\t\treturn -EINVAL;\n\n\t \n\tswpmsgctl = SET_FIELD(SWPxMSGCTL_REG, 0, midx) |\n\t\t    SET_FIELD(SWPxMSGCTL_PART, 0, ndev->peers[pidx].part);\n\n\t \n\tspin_lock_irqsave(&ndev->msg_locks[midx], irqflags);\n\t \n\tidt_sw_write(ndev, partdata_tbl[ndev->part].msgctl[midx], swpmsgctl);\n\tidt_nt_write(ndev, ntdata_tbl.msgs[midx].out, msg);\n\t \n\tspin_unlock_irqrestore(&ndev->msg_locks[midx], irqflags);\n\n\t \n\treturn 0;\n}\n\n \n\n \nstatic inline s8 idt_get_deg(long mdegC)\n{\n\treturn mdegC / 1000;\n}\n\n \nstatic inline u8 idt_get_deg_frac(long mdegC)\n{\n\treturn (mdegC % 1000) >= 500 ? 5 : 0;\n}\n\n \nstatic inline u8 idt_temp_get_fmt(long mdegC)\n{\n\treturn (idt_get_deg(mdegC) << 1) | (idt_get_deg_frac(mdegC) ? 1 : 0);\n}\n\n \nstatic inline long idt_get_temp_sval(u32 data)\n{\n\treturn ((s8)data / 2) * 1000 + (data & 0x1 ? 500 : 0);\n}\n\n \nstatic inline long idt_get_temp_uval(u32 data)\n{\n\treturn (data / 2) * 1000 + (data & 0x1 ? 500 : 0);\n}\n\n \nstatic void idt_read_temp(struct idt_ntb_dev *ndev,\n\t\t\t  const enum idt_temp_val type, long *val)\n{\n\tu32 data;\n\n\t \n\tswitch (type) {\n\tcase IDT_TEMP_CUR:\n\t\tdata = GET_FIELD(TMPSTS_TEMP,\n\t\t\t\t idt_sw_read(ndev, IDT_SW_TMPSTS));\n\t\tbreak;\n\tcase IDT_TEMP_LOW:\n\t\tdata = GET_FIELD(TMPSTS_LTEMP,\n\t\t\t\t idt_sw_read(ndev, IDT_SW_TMPSTS));\n\t\tbreak;\n\tcase IDT_TEMP_HIGH:\n\t\tdata = GET_FIELD(TMPSTS_HTEMP,\n\t\t\t\t idt_sw_read(ndev, IDT_SW_TMPSTS));\n\t\tbreak;\n\tcase IDT_TEMP_OFFSET:\n\t\t \n\t\tdata = GET_FIELD(TMPADJ_OFFSET,\n\t\t\t\t idt_sw_read(ndev, IDT_SW_TMPADJ));\n\t\t*val = idt_get_temp_sval(data);\n\t\treturn;\n\tdefault:\n\t\tdata = GET_FIELD(TMPSTS_TEMP,\n\t\t\t\t idt_sw_read(ndev, IDT_SW_TMPSTS));\n\t\tbreak;\n\t}\n\n\t \n\t*val = idt_get_temp_uval(data);\n}\n\n \nstatic void idt_write_temp(struct idt_ntb_dev *ndev,\n\t\t\t   const enum idt_temp_val type, const long val)\n{\n\tunsigned int reg;\n\tu32 data;\n\tu8 fmt;\n\n\t \n\tfmt = idt_temp_get_fmt(val);\n\n\tmutex_lock(&ndev->hwmon_mtx);\n\tswitch (type) {\n\tcase IDT_TEMP_LOW:\n\t\treg = IDT_SW_TMPALARM;\n\t\tdata = SET_FIELD(TMPALARM_LTEMP, idt_sw_read(ndev, reg), fmt) &\n\t\t\t~IDT_TMPALARM_IRQ_MASK;\n\t\tbreak;\n\tcase IDT_TEMP_HIGH:\n\t\treg = IDT_SW_TMPALARM;\n\t\tdata = SET_FIELD(TMPALARM_HTEMP, idt_sw_read(ndev, reg), fmt) &\n\t\t\t~IDT_TMPALARM_IRQ_MASK;\n\t\tbreak;\n\tcase IDT_TEMP_OFFSET:\n\t\treg = IDT_SW_TMPADJ;\n\t\tdata = SET_FIELD(TMPADJ_OFFSET, idt_sw_read(ndev, reg), fmt);\n\t\tbreak;\n\tdefault:\n\t\tgoto inval_spin_unlock;\n\t}\n\n\tidt_sw_write(ndev, reg, data);\n\ninval_spin_unlock:\n\tmutex_unlock(&ndev->hwmon_mtx);\n}\n\n \nstatic ssize_t idt_sysfs_show_temp(struct device *dev,\n\t\t\t\t   struct device_attribute *da, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct idt_ntb_dev *ndev = dev_get_drvdata(dev);\n\tenum idt_temp_val type = attr->index;\n\tlong mdeg;\n\n\tidt_read_temp(ndev, type, &mdeg);\n\treturn sprintf(buf, \"%ld\\n\", mdeg);\n}\n\n \nstatic ssize_t idt_sysfs_set_temp(struct device *dev,\n\t\t\t\t  struct device_attribute *da, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\n\tstruct idt_ntb_dev *ndev = dev_get_drvdata(dev);\n\tenum idt_temp_val type = attr->index;\n\tlong mdeg;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &mdeg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (type == IDT_TEMP_OFFSET)\n\t\tmdeg = clamp_val(mdeg, IDT_TEMP_MIN_OFFSET,\n\t\t\t\t IDT_TEMP_MAX_OFFSET);\n\telse\n\t\tmdeg = clamp_val(mdeg, IDT_TEMP_MIN_MDEG, IDT_TEMP_MAX_MDEG);\n\n\tidt_write_temp(ndev, type, mdeg);\n\n\treturn count;\n}\n\n \nstatic ssize_t idt_sysfs_reset_hist(struct device *dev,\n\t\t\t\t    struct device_attribute *da,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct idt_ntb_dev *ndev = dev_get_drvdata(dev);\n\n\t \n\tidt_write_temp(ndev, IDT_TEMP_LOW, IDT_TEMP_MAX_MDEG);\n\tidt_write_temp(ndev, IDT_TEMP_HIGH, IDT_TEMP_MIN_MDEG);\n\n\treturn count;\n}\n\n \nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, idt_sysfs_show_temp, NULL,\n\t\t\t  IDT_TEMP_CUR);\nstatic SENSOR_DEVICE_ATTR(temp1_lowest, 0444, idt_sysfs_show_temp, NULL,\n\t\t\t  IDT_TEMP_LOW);\nstatic SENSOR_DEVICE_ATTR(temp1_highest, 0444, idt_sysfs_show_temp, NULL,\n\t\t\t  IDT_TEMP_HIGH);\nstatic SENSOR_DEVICE_ATTR(temp1_offset, 0644, idt_sysfs_show_temp,\n\t\t\t  idt_sysfs_set_temp, IDT_TEMP_OFFSET);\nstatic DEVICE_ATTR(temp1_reset_history, 0200, NULL, idt_sysfs_reset_hist);\n\n \nstatic struct attribute *idt_temp_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_lowest.dev_attr.attr,\n\t&sensor_dev_attr_temp1_highest.dev_attr.attr,\n\t&sensor_dev_attr_temp1_offset.dev_attr.attr,\n\t&dev_attr_temp1_reset_history.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(idt_temp);\n\n \nstatic void idt_init_temp(struct idt_ntb_dev *ndev)\n{\n\tstruct device *hwmon;\n\n\t \n\tidt_sw_write(ndev, IDT_SW_TMPCTL, 0x0);\n\n\t \n\tmutex_init(&ndev->hwmon_mtx);\n\n\thwmon = devm_hwmon_device_register_with_groups(&ndev->ntb.pdev->dev,\n\t\tndev->swcfg->name, ndev, idt_temp_groups);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(&ndev->ntb.pdev->dev, \"Couldn't create hwmon device\");\n\t\treturn;\n\t}\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"Temperature HWmon interface registered\");\n}\n\n \n\nstatic irqreturn_t idt_thread_isr(int irq, void *devid);\n\n \nstatic int idt_init_isr(struct idt_ntb_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tu32 ntint_mask;\n\tint ret;\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI | PCI_IRQ_LEGACY);\n\tif (ret != 1) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate IRQ vector\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = pci_irq_vector(pdev, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get IRQ vector\");\n\t\tgoto err_free_vectors;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(&pdev->dev, ret, NULL, idt_thread_isr,\n\t\t\t\t\tIRQF_ONESHOT, NTB_IRQNAME, ndev);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set MSI IRQ handler, %d\", ret);\n\t\tgoto err_free_vectors;\n\t}\n\n\t \n\tntint_mask = idt_nt_read(ndev, IDT_NT_NTINTMSK) & ~IDT_NTINTMSK_ALL;\n\tidt_nt_write(ndev, IDT_NT_NTINTMSK, ntint_mask);\n\n\t \n\tdev_dbg(&pdev->dev, \"NTB interrupts initialized\");\n\n\treturn 0;\n\nerr_free_vectors:\n\tpci_free_irq_vectors(pdev);\n\n\treturn ret;\n}\n\n \nstatic void idt_deinit_isr(struct idt_ntb_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tu32 ntint_mask;\n\n\t \n\tntint_mask = idt_nt_read(ndev, IDT_NT_NTINTMSK) | IDT_NTINTMSK_ALL;\n\tidt_nt_write(ndev, IDT_NT_NTINTMSK, ntint_mask);\n\n\t \n\tdevm_free_irq(&pdev->dev, pci_irq_vector(pdev, 0), ndev);\n\n\t \n\tpci_free_irq_vectors(pdev);\n\n\tdev_dbg(&pdev->dev, \"NTB interrupts deinitialized\");\n}\n\n \nstatic irqreturn_t idt_thread_isr(int irq, void *devid)\n{\n\tstruct idt_ntb_dev *ndev = devid;\n\tbool handled = false;\n\tu32 ntint_sts;\n\n\t \n\tntint_sts = idt_nt_read(ndev, IDT_NT_NTINTSTS);\n\n\t \n\tif (ntint_sts & IDT_NTINTSTS_MSG) {\n\t\tidt_msg_isr(ndev, ntint_sts);\n\t\thandled = true;\n\t}\n\n\t \n\tif (ntint_sts & IDT_NTINTSTS_DBELL) {\n\t\tidt_db_isr(ndev, ntint_sts);\n\t\thandled = true;\n\t}\n\n\t \n\tif (ntint_sts & IDT_NTINTSTS_SEVENT) {\n\t\tidt_se_isr(ndev, ntint_sts);\n\t\thandled = true;\n\t}\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"IDT IRQs 0x%08x handled\", ntint_sts);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \n\n \nstatic const struct ntb_dev_ops idt_ntb_ops = {\n\t.port_number\t\t= idt_ntb_port_number,\n\t.peer_port_count\t= idt_ntb_peer_port_count,\n\t.peer_port_number\t= idt_ntb_peer_port_number,\n\t.peer_port_idx\t\t= idt_ntb_peer_port_idx,\n\t.link_is_up\t\t= idt_ntb_link_is_up,\n\t.link_enable\t\t= idt_ntb_link_enable,\n\t.link_disable\t\t= idt_ntb_link_disable,\n\t.mw_count\t\t= idt_ntb_mw_count,\n\t.mw_get_align\t\t= idt_ntb_mw_get_align,\n\t.peer_mw_count\t\t= idt_ntb_peer_mw_count,\n\t.peer_mw_get_addr\t= idt_ntb_peer_mw_get_addr,\n\t.peer_mw_set_trans\t= idt_ntb_peer_mw_set_trans,\n\t.peer_mw_clear_trans\t= idt_ntb_peer_mw_clear_trans,\n\t.db_valid_mask\t\t= idt_ntb_db_valid_mask,\n\t.db_read\t\t= idt_ntb_db_read,\n\t.db_clear\t\t= idt_ntb_db_clear,\n\t.db_read_mask\t\t= idt_ntb_db_read_mask,\n\t.db_set_mask\t\t= idt_ntb_db_set_mask,\n\t.db_clear_mask\t\t= idt_ntb_db_clear_mask,\n\t.peer_db_set\t\t= idt_ntb_peer_db_set,\n\t.msg_count\t\t= idt_ntb_msg_count,\n\t.msg_inbits\t\t= idt_ntb_msg_inbits,\n\t.msg_outbits\t\t= idt_ntb_msg_outbits,\n\t.msg_read_sts\t\t= idt_ntb_msg_read_sts,\n\t.msg_clear_sts\t\t= idt_ntb_msg_clear_sts,\n\t.msg_set_mask\t\t= idt_ntb_msg_set_mask,\n\t.msg_clear_mask\t\t= idt_ntb_msg_clear_mask,\n\t.msg_read\t\t= idt_ntb_msg_read,\n\t.peer_msg_write\t\t= idt_ntb_peer_msg_write\n};\n\n \nstatic int idt_register_device(struct idt_ntb_dev *ndev)\n{\n\tint ret;\n\n\t \n\tndev->ntb.ops = &idt_ntb_ops;\n\tndev->ntb.topo = NTB_TOPO_SWITCH;\n\n\tret = ntb_register_device(&ndev->ntb);\n\tif (ret != 0) {\n\t\tdev_err(&ndev->ntb.pdev->dev, \"Failed to register NTB device\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB device successfully registered\");\n\n\treturn 0;\n}\n\n \nstatic void idt_unregister_device(struct idt_ntb_dev *ndev)\n{\n\t \n\tntb_unregister_device(&ndev->ntb);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB device unregistered\");\n}\n\n \n\nstatic ssize_t idt_dbgfs_info_read(struct file *filp, char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *offp);\n\n \nstatic const struct file_operations idt_dbgfs_info_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = idt_dbgfs_info_read\n};\n\n \nstatic ssize_t idt_dbgfs_info_read(struct file *filp, char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *offp)\n{\n\tstruct idt_ntb_dev *ndev = filp->private_data;\n\tunsigned char idx, pidx, cnt;\n\tunsigned long irqflags, mdeg;\n\tssize_t ret = 0, off = 0;\n\tenum ntb_speed speed;\n\tenum ntb_width width;\n\tchar *strbuf;\n\tsize_t size;\n\tu32 data;\n\n\t \n\tsize = min_t(size_t, count, 0x1000U);\n\n\t \n\tstrbuf = kmalloc(size, GFP_KERNEL);\n\tif (strbuf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\toff += scnprintf(strbuf + off, size - off,\n\t\t\"\\n\\t\\tIDT NTB device Information:\\n\\n\");\n\n\t \n\toff += scnprintf(strbuf + off, size - off,\n\t\t\"Local Port %hhu, Partition %hhu\\n\", ndev->port, ndev->part);\n\n\t \n\toff += scnprintf(strbuf + off, size - off, \"Peers:\\n\");\n\tfor (idx = 0; idx < ndev->peer_cnt; idx++) {\n\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\"\\t%hhu. Port %hhu, Partition %hhu\\n\",\n\t\t\tidx, ndev->peers[idx].port, ndev->peers[idx].part);\n\t}\n\n\t \n\tdata = idt_ntb_link_is_up(&ndev->ntb, &speed, &width);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t\"NTB link status\\t- 0x%08x, \", data);\n\toff += scnprintf(strbuf + off, size - off, \"PCIe Gen %d x%d lanes\\n\",\n\t\tspeed, width);\n\n\t \n\toff += scnprintf(strbuf + off, size - off, \"NTB Mapping Table:\\n\");\n\tfor (idx = 0; idx < IDT_MTBL_ENTRY_CNT; idx++) {\n\t\tspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\n\t\tidt_nt_write(ndev, IDT_NT_NTMTBLADDR, idx);\n\t\tdata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\n\t\tspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\n\n\t\t \n\t\tif (data & IDT_NTMTBLDATA_VALID) {\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"\\t%hhu. Partition %d, Requester ID 0x%04x\\n\",\n\t\t\t\tidx, GET_FIELD(NTMTBLDATA_PART, data),\n\t\t\t\tGET_FIELD(NTMTBLDATA_REQID, data));\n\t\t}\n\t}\n\toff += scnprintf(strbuf + off, size - off, \"\\n\");\n\n\t \n\toff += scnprintf(strbuf + off, size - off,\n\t\t\"Outbound Memory Windows:\\n\");\n\tfor (idx = 0; idx < ndev->mw_cnt; idx += cnt) {\n\t\tdata = ndev->mws[idx].type;\n\t\tcnt = idt_get_mw_count(data);\n\n\t\t \n\t\tif (data == IDT_MW_DIR)\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"\\t%hhu.\\t\", idx);\n\t\telse\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"\\t%hhu-%d.\\t\", idx, idx + cnt - 1);\n\n\t\toff += scnprintf(strbuf + off, size - off, \"%s BAR%hhu, \",\n\t\t\tidt_get_mw_name(data), ndev->mws[idx].bar);\n\n\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\"Address align 0x%08llx, \", ndev->mws[idx].addr_align);\n\n\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\"Size align 0x%08llx, Size max %llu\\n\",\n\t\t\tndev->mws[idx].size_align, ndev->mws[idx].size_max);\n\t}\n\n\t \n\tfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\n\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\"Inbound Memory Windows for peer %hhu (Port %hhu):\\n\",\n\t\t\tpidx, ndev->peers[pidx].port);\n\n\t\t \n\t\tfor (idx = 0; idx < ndev->peers[pidx].mw_cnt; idx += cnt) {\n\t\t\tdata = ndev->peers[pidx].mws[idx].type;\n\t\t\tcnt = idt_get_mw_count(data);\n\n\t\t\tif (data == IDT_MW_DIR)\n\t\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\t\"\\t%hhu.\\t\", idx);\n\t\t\telse\n\t\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\t\"\\t%hhu-%d.\\t\", idx, idx + cnt - 1);\n\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"%s BAR%hhu, \", idt_get_mw_name(data),\n\t\t\t\tndev->peers[pidx].mws[idx].bar);\n\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"Address align 0x%08llx, \",\n\t\t\t\tndev->peers[pidx].mws[idx].addr_align);\n\n\t\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\t\"Size align 0x%08llx, Size max %llu\\n\",\n\t\t\t\tndev->peers[pidx].mws[idx].size_align,\n\t\t\t\tndev->peers[pidx].mws[idx].size_max);\n\t\t}\n\t}\n\toff += scnprintf(strbuf + off, size - off, \"\\n\");\n\n\t \n\tdata = idt_sw_read(ndev, IDT_SW_GDBELLSTS);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Global Doorbell state\\t- 0x%08x\\n\", data);\n\tdata = idt_ntb_db_read(&ndev->ntb);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Local  Doorbell state\\t- 0x%08x\\n\", data);\n\tdata = idt_nt_read(ndev, IDT_NT_INDBELLMSK);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Local  Doorbell mask\\t- 0x%08x\\n\", data);\n\toff += scnprintf(strbuf + off, size - off, \"\\n\");\n\n\t \n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Message event valid\\t- 0x%08x\\n\", IDT_MSG_MASK);\n\tdata = idt_ntb_msg_read_sts(&ndev->ntb);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Message event status\\t- 0x%08x\\n\", data);\n\tdata = idt_nt_read(ndev, IDT_NT_MSGSTSMSK);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Message event mask\\t- 0x%08x\\n\", data);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t \"Message data:\\n\");\n\tfor (idx = 0; idx < IDT_MSG_CNT; idx++) {\n\t\tint src;\n\t\tdata = idt_ntb_msg_read(&ndev->ntb, &src, idx);\n\t\toff += scnprintf(strbuf + off, size - off,\n\t\t\t\"\\t%hhu. 0x%08x from peer %d (Port %hhu)\\n\",\n\t\t\tidx, data, src, ndev->peers[src].port);\n\t}\n\toff += scnprintf(strbuf + off, size - off, \"\\n\");\n\n\t \n\tidt_read_temp(ndev, IDT_TEMP_CUR, &mdeg);\n\toff += scnprintf(strbuf + off, size - off,\n\t\t\"Switch temperature\\t\\t- %hhd.%hhuC\\n\",\n\t\tidt_get_deg(mdeg), idt_get_deg_frac(mdeg));\n\n\t \n\tret = simple_read_from_buffer(ubuf, count, offp, strbuf, off);\n\tkfree(strbuf);\n\n\treturn ret;\n}\n\n \nstatic int idt_init_dbgfs(struct idt_ntb_dev *ndev)\n{\n\tchar devname[64];\n\n\t \n\tif (IS_ERR_OR_NULL(dbgfs_topdir)) {\n\t\tdev_info(&ndev->ntb.pdev->dev, \"Top DebugFS directory absent\");\n\t\treturn PTR_ERR_OR_ZERO(dbgfs_topdir);\n\t}\n\n\t \n\tsnprintf(devname, 64, \"info:%s\", pci_name(ndev->ntb.pdev));\n\tndev->dbgfs_info = debugfs_create_file(devname, 0400, dbgfs_topdir,\n\t\tndev, &idt_dbgfs_info_ops);\n\tif (IS_ERR(ndev->dbgfs_info)) {\n\t\tdev_dbg(&ndev->ntb.pdev->dev, \"Failed to create DebugFS node\");\n\t\treturn PTR_ERR(ndev->dbgfs_info);\n\t}\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB device DebugFS node created\");\n\n\treturn 0;\n}\n\n \nstatic void idt_deinit_dbgfs(struct idt_ntb_dev *ndev)\n{\n\tdebugfs_remove(ndev->dbgfs_info);\n\n\tdev_dbg(&ndev->ntb.pdev->dev, \"NTB device DebugFS node discarded\");\n}\n\n \n\n \nstatic int idt_check_setup(struct pci_dev *pdev)\n{\n\tu32 data;\n\tint ret;\n\n\t \n\tret = pci_read_config_dword(pdev, IDT_NT_BARSETUP0, &data);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to read BARSETUP0 config register\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(data & IDT_BARSETUP_EN) || !(data & IDT_BARSETUP_MODE_CFG)) {\n\t\tdev_err(&pdev->dev, \"BAR0 doesn't map config space\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((data & IDT_BARSETUP_SIZE_MASK) != IDT_BARSETUP_SIZE_CFG) {\n\t\tdev_err(&pdev->dev, \"Invalid size of config space\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&pdev->dev, \"NTB device pre-initialized correctly\");\n\n\treturn 0;\n}\n\n \nstatic struct idt_ntb_dev *idt_create_dev(struct pci_dev *pdev,\n\t\t\t\t\t  const struct pci_device_id *id)\n{\n\tstruct idt_ntb_dev *ndev;\n\n\t \n\tndev = devm_kzalloc(&pdev->dev, sizeof(*ndev), GFP_KERNEL);\n\tif (!ndev) {\n\t\tdev_err(&pdev->dev, \"Memory allocation failed for descriptor\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tndev->swcfg = (struct idt_89hpes_cfg *)id->driver_data;\n\t \n\tndev->ntb.pdev = pdev;\n\n\t \n\tspin_lock_init(&ndev->db_mask_lock);\n\tspin_lock_init(&ndev->msg_mask_lock);\n\tspin_lock_init(&ndev->gasa_lock);\n\n\tdev_info(&pdev->dev, \"IDT %s discovered\", ndev->swcfg->name);\n\n\tdev_dbg(&pdev->dev, \"NTB device descriptor created\");\n\n\treturn ndev;\n}\n\n \nstatic int idt_init_pci(struct idt_ntb_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tint ret;\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret != 0) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set DMA bit mask\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_warn(&pdev->dev, \"Cannot set DMA highmem bit mask\\n\");\n\t}\n\n\t \n\tpci_aer_clear_nonfatal_status(pdev);\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCIe device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tret = pcim_iomap_regions_request_all(pdev, 1, NTB_NAME);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request resources\\n\");\n\t\tgoto err_clear_master;\n\t}\n\n\t \n\tndev->cfgspc = pcim_iomap_table(pdev)[0];\n\n\t \n\tpci_set_drvdata(pdev, ndev);\n\n\tdev_dbg(&pdev->dev, \"NT-function PCIe interface initialized\");\n\n\treturn 0;\n\nerr_clear_master:\n\tpci_clear_master(pdev);\n\n\treturn ret;\n}\n\n \nstatic void idt_deinit_pci(struct idt_ntb_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\n\t \n\tpci_set_drvdata(pdev, NULL);\n\n\t \n\tpci_clear_master(pdev);\n\n\tdev_dbg(&pdev->dev, \"NT-function PCIe interface cleared\");\n}\n\n \n\n \nstatic int idt_pci_probe(struct pci_dev *pdev,\n\t\t\t const struct pci_device_id *id)\n{\n\tstruct idt_ntb_dev *ndev;\n\tint ret;\n\n\t \n\tret = idt_check_setup(pdev);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tndev = idt_create_dev(pdev, id);\n\tif (IS_ERR(ndev))\n\t\treturn PTR_ERR(ndev);\n\n\t \n\tret = idt_init_pci(ndev);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\t(void)idt_scan_ports(ndev);\n\n\t \n\tidt_init_link(ndev);\n\n\t \n\tret = idt_init_mws(ndev);\n\tif (ret != 0)\n\t\tgoto err_deinit_link;\n\n\t \n\tidt_init_msg(ndev);\n\n\t \n\tidt_init_temp(ndev);\n\n\t \n\tret = idt_init_isr(ndev);\n\tif (ret != 0)\n\t\tgoto err_deinit_link;\n\n\t \n\tret = idt_register_device(ndev);\n\tif (ret != 0)\n\t\tgoto err_deinit_isr;\n\n\t \n\t(void)idt_init_dbgfs(ndev);\n\n\t \n\tdev_info(&pdev->dev, \"IDT NTB device is ready\");\n\n\t \n\treturn 0;\n\nerr_deinit_isr:\n\tidt_deinit_isr(ndev);\nerr_deinit_link:\n\tidt_deinit_link(ndev);\n\tidt_deinit_pci(ndev);\n\n\treturn ret;\n}\n\n \nstatic void idt_pci_remove(struct pci_dev *pdev)\n{\n\tstruct idt_ntb_dev *ndev = pci_get_drvdata(pdev);\n\n\t \n\tidt_deinit_dbgfs(ndev);\n\n\t \n\tidt_unregister_device(ndev);\n\n\t \n\tidt_deinit_isr(ndev);\n\n\t \n\tidt_deinit_link(ndev);\n\n\t \n\tidt_deinit_pci(ndev);\n\n\t \n\tdev_info(&pdev->dev, \"IDT NTB device is removed\");\n\n\t \n}\n\n \nstatic const struct idt_89hpes_cfg idt_89hpes24nt6ag2_config = {\n\t.name = \"89HPES24NT6AG2\",\n\t.port_cnt = 6, .ports = {0, 2, 4, 6, 8, 12}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes32nt8ag2_config = {\n\t.name = \"89HPES32NT8AG2\",\n\t.port_cnt = 8, .ports = {0, 2, 4, 6, 8, 12, 16, 20}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes32nt8bg2_config = {\n\t.name = \"89HPES32NT8BG2\",\n\t.port_cnt = 8, .ports = {0, 2, 4, 6, 8, 12, 16, 20}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes12nt12g2_config = {\n\t.name = \"89HPES12NT12G2\",\n\t.port_cnt = 3, .ports = {0, 8, 16}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes16nt16g2_config = {\n\t.name = \"89HPES16NT16G2\",\n\t.port_cnt = 4, .ports = {0, 8, 12, 16}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes24nt24g2_config = {\n\t.name = \"89HPES24NT24G2\",\n\t.port_cnt = 8, .ports = {0, 2, 4, 6, 8, 12, 16, 20}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes32nt24ag2_config = {\n\t.name = \"89HPES32NT24AG2\",\n\t.port_cnt = 8, .ports = {0, 2, 4, 6, 8, 12, 16, 20}\n};\nstatic const struct idt_89hpes_cfg idt_89hpes32nt24bg2_config = {\n\t.name = \"89HPES32NT24BG2\",\n\t.port_cnt = 8, .ports = {0, 2, 4, 6, 8, 12, 16, 20}\n};\n\n \nstatic const struct pci_device_id idt_pci_tbl[] = {\n\t{IDT_PCI_DEVICE_IDS(89HPES24NT6AG2,  idt_89hpes24nt6ag2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES32NT8AG2,  idt_89hpes32nt8ag2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES32NT8BG2,  idt_89hpes32nt8bg2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES12NT12G2,  idt_89hpes12nt12g2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES16NT16G2,  idt_89hpes16nt16g2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES24NT24G2,  idt_89hpes24nt24g2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES32NT24AG2, idt_89hpes32nt24ag2_config)},\n\t{IDT_PCI_DEVICE_IDS(89HPES32NT24BG2, idt_89hpes32nt24bg2_config)},\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, idt_pci_tbl);\n\n \nstatic struct pci_driver idt_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.probe\t\t= idt_pci_probe,\n\t.remove\t\t= idt_pci_remove,\n\t.id_table\t= idt_pci_tbl,\n};\n\nstatic int __init idt_pci_driver_init(void)\n{\n\tint ret;\n\tpr_info(\"%s %s\\n\", NTB_DESC, NTB_VER);\n\n\t \n\tif (debugfs_initialized())\n\t\tdbgfs_topdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\t \n\tret = pci_register_driver(&idt_pci_driver);\n\tif (ret)\n\t\tdebugfs_remove_recursive(dbgfs_topdir);\n\n\treturn ret;\n}\nmodule_init(idt_pci_driver_init);\n\nstatic void __exit idt_pci_driver_exit(void)\n{\n\t \n\tpci_unregister_driver(&idt_pci_driver);\n\n\t \n\tdebugfs_remove_recursive(dbgfs_topdir);\n}\nmodule_exit(idt_pci_driver_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}