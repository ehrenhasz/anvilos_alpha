{
  "module_name": "ntb_hw_switchtec.c",
  "hash_id": "cf9fb545433efd85f78cc9c08940a9bf27071f0e9df65861bb8f9af3652fb327",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/hw/mscc/ntb_hw_switchtec.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/ntb.h>\n#include <linux/pci.h>\n#include <linux/switchtec.h>\n\nMODULE_DESCRIPTION(\"Microsemi Switchtec(tm) NTB Driver\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Microsemi Corporation\");\n\nstatic ulong max_mw_size = SZ_2M;\nmodule_param(max_mw_size, ulong, 0644);\nMODULE_PARM_DESC(max_mw_size,\n\t\"Max memory window size reported to the upper layer\");\n\nstatic bool use_lut_mws;\nmodule_param(use_lut_mws, bool, 0644);\nMODULE_PARM_DESC(use_lut_mws,\n\t\t \"Enable the use of the LUT based memory windows\");\n\n#define SWITCHTEC_NTB_MAGIC 0x45CC0001\n#define MAX_MWS     128\n\nstruct shared_mw {\n\tu32 magic;\n\tu32 link_sta;\n\tu32 partition_id;\n\tu64 mw_sizes[MAX_MWS];\n\tu32 spad[128];\n};\n\n#define MAX_DIRECT_MW ARRAY_SIZE(((struct ntb_ctrl_regs *)(0))->bar_entry)\n#define LUT_SIZE SZ_64K\n\nstruct switchtec_ntb {\n\tstruct ntb_dev ntb;\n\tstruct switchtec_dev *stdev;\n\n\tint self_partition;\n\tint peer_partition;\n\n\tint doorbell_irq;\n\tint message_irq;\n\n\tstruct ntb_info_regs __iomem *mmio_ntb;\n\tstruct ntb_ctrl_regs __iomem *mmio_ctrl;\n\tstruct ntb_dbmsg_regs __iomem *mmio_dbmsg;\n\tstruct ntb_ctrl_regs __iomem *mmio_self_ctrl;\n\tstruct ntb_ctrl_regs __iomem *mmio_peer_ctrl;\n\tstruct ntb_dbmsg_regs __iomem *mmio_self_dbmsg;\n\tstruct ntb_dbmsg_regs __iomem *mmio_peer_dbmsg;\n\n\tvoid __iomem *mmio_xlink_win;\n\n\tstruct shared_mw *self_shared;\n\tstruct shared_mw __iomem *peer_shared;\n\tdma_addr_t self_shared_dma;\n\n\tu64 db_mask;\n\tu64 db_valid_mask;\n\tint db_shift;\n\tint db_peer_shift;\n\n\t \n\tspinlock_t db_mask_lock;\n\n\tint nr_direct_mw;\n\tint nr_lut_mw;\n\tint nr_rsvd_luts;\n\tint direct_mw_to_bar[MAX_DIRECT_MW];\n\n\tint peer_nr_direct_mw;\n\tint peer_nr_lut_mw;\n\tint peer_direct_mw_to_bar[MAX_DIRECT_MW];\n\n\tbool link_is_up;\n\tenum ntb_speed link_speed;\n\tenum ntb_width link_width;\n\tstruct work_struct check_link_status_work;\n\tbool link_force_down;\n};\n\nstatic struct switchtec_ntb *ntb_sndev(struct ntb_dev *ntb)\n{\n\treturn container_of(ntb, struct switchtec_ntb, ntb);\n}\n\nstatic int switchtec_ntb_part_op(struct switchtec_ntb *sndev,\n\t\t\t\t struct ntb_ctrl_regs __iomem *ctl,\n\t\t\t\t u32 op, int wait_status)\n{\n\tstatic const char * const op_text[] = {\n\t\t[NTB_CTRL_PART_OP_LOCK] = \"lock\",\n\t\t[NTB_CTRL_PART_OP_CFG] = \"configure\",\n\t\t[NTB_CTRL_PART_OP_RESET] = \"reset\",\n\t};\n\n\tint i;\n\tu32 ps;\n\tint status;\n\n\tswitch (op) {\n\tcase NTB_CTRL_PART_OP_LOCK:\n\t\tstatus = NTB_CTRL_PART_STATUS_LOCKING;\n\t\tbreak;\n\tcase NTB_CTRL_PART_OP_CFG:\n\t\tstatus = NTB_CTRL_PART_STATUS_CONFIGURING;\n\t\tbreak;\n\tcase NTB_CTRL_PART_OP_RESET:\n\t\tstatus = NTB_CTRL_PART_STATUS_RESETTING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tiowrite32(op, &ctl->partition_op);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (msleep_interruptible(50) != 0) {\n\t\t\tiowrite32(NTB_CTRL_PART_OP_RESET, &ctl->partition_op);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tps = ioread32(&ctl->partition_status) & 0xFFFF;\n\n\t\tif (ps != status)\n\t\t\tbreak;\n\t}\n\n\tif (ps == wait_status)\n\t\treturn 0;\n\n\tif (ps == status) {\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Timed out while performing %s (%d). (%08x)\\n\",\n\t\t\top_text[op], op,\n\t\t\tioread32(&ctl->partition_status));\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int switchtec_ntb_send_msg(struct switchtec_ntb *sndev, int idx,\n\t\t\t\t  u32 val)\n{\n\tif (idx < 0 || idx >= ARRAY_SIZE(sndev->mmio_peer_dbmsg->omsg))\n\t\treturn -EINVAL;\n\n\tiowrite32(val, &sndev->mmio_peer_dbmsg->omsg[idx].msg);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_mw_count(struct ntb_dev *ntb, int pidx)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tint nr_direct_mw = sndev->peer_nr_direct_mw;\n\tint nr_lut_mw = sndev->peer_nr_lut_mw - sndev->nr_rsvd_luts;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tif (!use_lut_mws)\n\t\tnr_lut_mw = 0;\n\n\treturn nr_direct_mw + nr_lut_mw;\n}\n\nstatic int lut_index(struct switchtec_ntb *sndev, int mw_idx)\n{\n\treturn mw_idx - sndev->nr_direct_mw + sndev->nr_rsvd_luts;\n}\n\nstatic int peer_lut_index(struct switchtec_ntb *sndev, int mw_idx)\n{\n\treturn mw_idx - sndev->peer_nr_direct_mw + sndev->nr_rsvd_luts;\n}\n\nstatic int switchtec_ntb_mw_get_align(struct ntb_dev *ntb, int pidx,\n\t\t\t\t      int widx, resource_size_t *addr_align,\n\t\t\t\t      resource_size_t *size_align,\n\t\t\t\t      resource_size_t *size_max)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tint lut;\n\tresource_size_t size;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tlut = widx >= sndev->peer_nr_direct_mw;\n\tsize = ioread64(&sndev->peer_shared->mw_sizes[widx]);\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (addr_align)\n\t\t*addr_align = lut ? size : SZ_4K;\n\n\tif (size_align)\n\t\t*size_align = lut ? size : SZ_4K;\n\n\tif (size_max)\n\t\t*size_max = size;\n\n\treturn 0;\n}\n\nstatic void switchtec_ntb_mw_clr_direct(struct switchtec_ntb *sndev, int idx)\n{\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_peer_ctrl;\n\tint bar = sndev->peer_direct_mw_to_bar[idx];\n\tu32 ctl_val;\n\n\tctl_val = ioread32(&ctl->bar_entry[bar].ctl);\n\tctl_val &= ~NTB_CTRL_BAR_DIR_WIN_EN;\n\tiowrite32(ctl_val, &ctl->bar_entry[bar].ctl);\n\tiowrite32(0, &ctl->bar_entry[bar].win_size);\n\tiowrite32(0, &ctl->bar_ext_entry[bar].win_size);\n\tiowrite64(sndev->self_partition, &ctl->bar_entry[bar].xlate_addr);\n}\n\nstatic void switchtec_ntb_mw_clr_lut(struct switchtec_ntb *sndev, int idx)\n{\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_peer_ctrl;\n\n\tiowrite64(0, &ctl->lut_entry[peer_lut_index(sndev, idx)]);\n}\n\nstatic void switchtec_ntb_mw_set_direct(struct switchtec_ntb *sndev, int idx,\n\t\t\t\t\tdma_addr_t addr, resource_size_t size)\n{\n\tint xlate_pos = ilog2(size);\n\tint bar = sndev->peer_direct_mw_to_bar[idx];\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_peer_ctrl;\n\tu32 ctl_val;\n\n\tctl_val = ioread32(&ctl->bar_entry[bar].ctl);\n\tctl_val |= NTB_CTRL_BAR_DIR_WIN_EN;\n\n\tiowrite32(ctl_val, &ctl->bar_entry[bar].ctl);\n\tiowrite32(xlate_pos | (lower_32_bits(size) & 0xFFFFF000),\n\t\t  &ctl->bar_entry[bar].win_size);\n\tiowrite32(upper_32_bits(size), &ctl->bar_ext_entry[bar].win_size);\n\tiowrite64(sndev->self_partition | addr,\n\t\t  &ctl->bar_entry[bar].xlate_addr);\n}\n\nstatic void switchtec_ntb_mw_set_lut(struct switchtec_ntb *sndev, int idx,\n\t\t\t\t     dma_addr_t addr, resource_size_t size)\n{\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_peer_ctrl;\n\n\tiowrite64((NTB_CTRL_LUT_EN | (sndev->self_partition << 1) | addr),\n\t\t  &ctl->lut_entry[peer_lut_index(sndev, idx)]);\n}\n\nstatic int switchtec_ntb_mw_set_trans(struct ntb_dev *ntb, int pidx, int widx,\n\t\t\t\t      dma_addr_t addr, resource_size_t size)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_peer_ctrl;\n\tint xlate_pos = ilog2(size);\n\tint nr_direct_mw = sndev->peer_nr_direct_mw;\n\tint rc;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&sndev->stdev->dev, \"MW %d: part %d addr %pad size %pap\\n\",\n\t\twidx, pidx, &addr, &size);\n\n\tif (widx >= switchtec_ntb_mw_count(ntb, pidx))\n\t\treturn -EINVAL;\n\n\tif (size != 0 && xlate_pos < 12)\n\t\treturn -EINVAL;\n\n\tif (!IS_ALIGNED(addr, BIT_ULL(xlate_pos))) {\n\t\t \n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"ERROR: Memory window address is not aligned to its size!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_LOCK,\n\t\t\t\t   NTB_CTRL_PART_STATUS_LOCKED);\n\tif (rc)\n\t\treturn rc;\n\n\tif (size == 0) {\n\t\tif (widx < nr_direct_mw)\n\t\t\tswitchtec_ntb_mw_clr_direct(sndev, widx);\n\t\telse\n\t\t\tswitchtec_ntb_mw_clr_lut(sndev, widx);\n\t} else {\n\t\tif (widx < nr_direct_mw)\n\t\t\tswitchtec_ntb_mw_set_direct(sndev, widx, addr, size);\n\t\telse\n\t\t\tswitchtec_ntb_mw_set_lut(sndev, widx, addr, size);\n\t}\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_CFG,\n\t\t\t\t   NTB_CTRL_PART_STATUS_NORMAL);\n\n\tif (rc == -EIO) {\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Hardware reported an error configuring mw %d: %08x\\n\",\n\t\t\twidx, ioread32(&ctl->bar_error));\n\n\t\tif (widx < nr_direct_mw)\n\t\t\tswitchtec_ntb_mw_clr_direct(sndev, widx);\n\t\telse\n\t\t\tswitchtec_ntb_mw_clr_lut(sndev, widx);\n\n\t\tswitchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_CFG,\n\t\t\t\t      NTB_CTRL_PART_STATUS_NORMAL);\n\t}\n\n\treturn rc;\n}\n\nstatic int switchtec_ntb_peer_mw_count(struct ntb_dev *ntb)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tint nr_lut_mw = sndev->nr_lut_mw - sndev->nr_rsvd_luts;\n\n\treturn sndev->nr_direct_mw + (use_lut_mws ? nr_lut_mw : 0);\n}\n\nstatic int switchtec_ntb_direct_get_addr(struct switchtec_ntb *sndev,\n\t\t\t\t\t int idx, phys_addr_t *base,\n\t\t\t\t\t resource_size_t *size)\n{\n\tint bar = sndev->direct_mw_to_bar[idx];\n\tsize_t offset = 0;\n\n\tif (bar < 0)\n\t\treturn -EINVAL;\n\n\tif (idx == 0) {\n\t\t \n\n\t\toffset = LUT_SIZE * sndev->nr_lut_mw;\n\t}\n\n\tif (base)\n\t\t*base = pci_resource_start(sndev->ntb.pdev, bar) + offset;\n\n\tif (size) {\n\t\t*size = pci_resource_len(sndev->ntb.pdev, bar) - offset;\n\t\tif (offset && *size > offset)\n\t\t\t*size = offset;\n\n\t\tif (*size > max_mw_size)\n\t\t\t*size = max_mw_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_lut_get_addr(struct switchtec_ntb *sndev,\n\t\t\t\t      int idx, phys_addr_t *base,\n\t\t\t\t      resource_size_t *size)\n{\n\tint bar = sndev->direct_mw_to_bar[0];\n\tint offset;\n\n\toffset = LUT_SIZE * lut_index(sndev, idx);\n\n\tif (base)\n\t\t*base = pci_resource_start(sndev->ntb.pdev, bar) + offset;\n\n\tif (size)\n\t\t*size = LUT_SIZE;\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_peer_mw_get_addr(struct ntb_dev *ntb, int idx,\n\t\t\t\t\t  phys_addr_t *base,\n\t\t\t\t\t  resource_size_t *size)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (idx < sndev->nr_direct_mw)\n\t\treturn switchtec_ntb_direct_get_addr(sndev, idx, base, size);\n\telse if (idx < switchtec_ntb_peer_mw_count(ntb))\n\t\treturn switchtec_ntb_lut_get_addr(sndev, idx, base, size);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void switchtec_ntb_part_link_speed(struct switchtec_ntb *sndev,\n\t\t\t\t\t  int partition,\n\t\t\t\t\t  enum ntb_speed *speed,\n\t\t\t\t\t  enum ntb_width *width)\n{\n\tstruct switchtec_dev *stdev = sndev->stdev;\n\tstruct part_cfg_regs __iomem *part_cfg =\n\t\t&stdev->mmio_part_cfg_all[partition];\n\n\tu32 pff = ioread32(&part_cfg->vep_pff_inst_id) & 0xFF;\n\tu32 linksta = ioread32(&stdev->mmio_pff_csr[pff].pci_cap_region[13]);\n\n\tif (speed)\n\t\t*speed = (linksta >> 16) & 0xF;\n\n\tif (width)\n\t\t*width = (linksta >> 20) & 0x3F;\n}\n\nstatic void switchtec_ntb_set_link_speed(struct switchtec_ntb *sndev)\n{\n\tenum ntb_speed self_speed, peer_speed;\n\tenum ntb_width self_width, peer_width;\n\n\tif (!sndev->link_is_up) {\n\t\tsndev->link_speed = NTB_SPEED_NONE;\n\t\tsndev->link_width = NTB_WIDTH_NONE;\n\t\treturn;\n\t}\n\n\tswitchtec_ntb_part_link_speed(sndev, sndev->self_partition,\n\t\t\t\t      &self_speed, &self_width);\n\tswitchtec_ntb_part_link_speed(sndev, sndev->peer_partition,\n\t\t\t\t      &peer_speed, &peer_width);\n\n\tsndev->link_speed = min(self_speed, peer_speed);\n\tsndev->link_width = min(self_width, peer_width);\n}\n\nstatic int crosslink_is_enabled(struct switchtec_ntb *sndev)\n{\n\tstruct ntb_info_regs __iomem *inf = sndev->mmio_ntb;\n\n\treturn ioread8(&inf->ntp_info[sndev->peer_partition].xlink_enabled);\n}\n\nstatic void crosslink_init_dbmsgs(struct switchtec_ntb *sndev)\n{\n\tint i;\n\tu32 msg_map = 0;\n\n\tif (!crosslink_is_enabled(sndev))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(sndev->mmio_peer_dbmsg->imsg); i++) {\n\t\tint m = i | sndev->self_partition << 2;\n\n\t\tmsg_map |= m << i * 8;\n\t}\n\n\tiowrite32(msg_map, &sndev->mmio_peer_dbmsg->msg_map);\n\tiowrite64(sndev->db_valid_mask << sndev->db_peer_shift,\n\t\t  &sndev->mmio_peer_dbmsg->odb_mask);\n}\n\nenum switchtec_msg {\n\tLINK_MESSAGE = 0,\n\tMSG_LINK_UP = 1,\n\tMSG_LINK_DOWN = 2,\n\tMSG_CHECK_LINK = 3,\n\tMSG_LINK_FORCE_DOWN = 4,\n};\n\nstatic int switchtec_ntb_reinit_peer(struct switchtec_ntb *sndev);\n\nstatic void switchtec_ntb_link_status_update(struct switchtec_ntb *sndev)\n{\n\tint link_sta;\n\tint old = sndev->link_is_up;\n\n\tlink_sta = sndev->self_shared->link_sta;\n\tif (link_sta) {\n\t\tu64 peer = ioread64(&sndev->peer_shared->magic);\n\n\t\tif ((peer & 0xFFFFFFFF) == SWITCHTEC_NTB_MAGIC)\n\t\t\tlink_sta = peer >> 32;\n\t\telse\n\t\t\tlink_sta = 0;\n\t}\n\n\tsndev->link_is_up = link_sta;\n\tswitchtec_ntb_set_link_speed(sndev);\n\n\tif (link_sta != old) {\n\t\tswitchtec_ntb_send_msg(sndev, LINK_MESSAGE, MSG_CHECK_LINK);\n\t\tntb_link_event(&sndev->ntb);\n\t\tdev_info(&sndev->stdev->dev, \"ntb link %s\\n\",\n\t\t\t link_sta ? \"up\" : \"down\");\n\n\t\tif (link_sta)\n\t\t\tcrosslink_init_dbmsgs(sndev);\n\t}\n}\n\nstatic void check_link_status_work(struct work_struct *work)\n{\n\tstruct switchtec_ntb *sndev;\n\n\tsndev = container_of(work, struct switchtec_ntb,\n\t\t\t     check_link_status_work);\n\n\tif (sndev->link_force_down) {\n\t\tsndev->link_force_down = false;\n\t\tswitchtec_ntb_reinit_peer(sndev);\n\n\t\tif (sndev->link_is_up) {\n\t\t\tsndev->link_is_up = 0;\n\t\t\tntb_link_event(&sndev->ntb);\n\t\t\tdev_info(&sndev->stdev->dev, \"ntb link forced down\\n\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitchtec_ntb_link_status_update(sndev);\n}\n\nstatic void switchtec_ntb_check_link(struct switchtec_ntb *sndev,\n\t\t\t\t      enum switchtec_msg msg)\n{\n\tif (msg == MSG_LINK_FORCE_DOWN)\n\t\tsndev->link_force_down = true;\n\n\tschedule_work(&sndev->check_link_status_work);\n}\n\nstatic void switchtec_ntb_link_notification(struct switchtec_dev *stdev)\n{\n\tstruct switchtec_ntb *sndev = stdev->sndev;\n\n\tswitchtec_ntb_check_link(sndev, MSG_CHECK_LINK);\n}\n\nstatic u64 switchtec_ntb_link_is_up(struct ntb_dev *ntb,\n\t\t\t\t    enum ntb_speed *speed,\n\t\t\t\t    enum ntb_width *width)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (speed)\n\t\t*speed = sndev->link_speed;\n\tif (width)\n\t\t*width = sndev->link_width;\n\n\treturn sndev->link_is_up;\n}\n\nstatic int switchtec_ntb_link_enable(struct ntb_dev *ntb,\n\t\t\t\t     enum ntb_speed max_speed,\n\t\t\t\t     enum ntb_width max_width)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tdev_dbg(&sndev->stdev->dev, \"enabling link\\n\");\n\n\tsndev->self_shared->link_sta = 1;\n\tswitchtec_ntb_send_msg(sndev, LINK_MESSAGE, MSG_LINK_UP);\n\n\tswitchtec_ntb_link_status_update(sndev);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_link_disable(struct ntb_dev *ntb)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tdev_dbg(&sndev->stdev->dev, \"disabling link\\n\");\n\n\tsndev->self_shared->link_sta = 0;\n\tswitchtec_ntb_send_msg(sndev, LINK_MESSAGE, MSG_LINK_DOWN);\n\n\tswitchtec_ntb_link_status_update(sndev);\n\n\treturn 0;\n}\n\nstatic u64 switchtec_ntb_db_valid_mask(struct ntb_dev *ntb)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\treturn sndev->db_valid_mask;\n}\n\nstatic int switchtec_ntb_db_vector_count(struct ntb_dev *ntb)\n{\n\treturn 1;\n}\n\nstatic u64 switchtec_ntb_db_vector_mask(struct ntb_dev *ntb, int db_vector)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (db_vector < 0 || db_vector > 1)\n\t\treturn 0;\n\n\treturn sndev->db_valid_mask;\n}\n\nstatic u64 switchtec_ntb_db_read(struct ntb_dev *ntb)\n{\n\tu64 ret;\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tret = ioread64(&sndev->mmio_self_dbmsg->idb) >> sndev->db_shift;\n\n\treturn ret & sndev->db_valid_mask;\n}\n\nstatic int switchtec_ntb_db_clear(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tiowrite64(db_bits << sndev->db_shift, &sndev->mmio_self_dbmsg->idb);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tunsigned long irqflags;\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (db_bits & ~sndev->db_valid_mask)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&sndev->db_mask_lock, irqflags);\n\n\tsndev->db_mask |= db_bits << sndev->db_shift;\n\tiowrite64(~sndev->db_mask, &sndev->mmio_self_dbmsg->idb_mask);\n\n\tspin_unlock_irqrestore(&sndev->db_mask_lock, irqflags);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\tunsigned long irqflags;\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (db_bits & ~sndev->db_valid_mask)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&sndev->db_mask_lock, irqflags);\n\n\tsndev->db_mask &= ~(db_bits << sndev->db_shift);\n\tiowrite64(~sndev->db_mask, &sndev->mmio_self_dbmsg->idb_mask);\n\n\tspin_unlock_irqrestore(&sndev->db_mask_lock, irqflags);\n\n\treturn 0;\n}\n\nstatic u64 switchtec_ntb_db_read_mask(struct ntb_dev *ntb)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\treturn (sndev->db_mask >> sndev->db_shift) & sndev->db_valid_mask;\n}\n\nstatic int switchtec_ntb_peer_db_addr(struct ntb_dev *ntb,\n\t\t\t\t      phys_addr_t *db_addr,\n\t\t\t\t      resource_size_t *db_size,\n\t\t\t\t      u64 *db_data,\n\t\t\t\t      int db_bit)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tunsigned long offset;\n\n\tif (unlikely(db_bit >= BITS_PER_LONG_LONG))\n\t\treturn -EINVAL;\n\n\toffset = (unsigned long)sndev->mmio_peer_dbmsg->odb -\n\t\t(unsigned long)sndev->stdev->mmio;\n\n\toffset += sndev->db_shift / 8;\n\n\tif (db_addr)\n\t\t*db_addr = pci_resource_start(ntb->pdev, 0) + offset;\n\tif (db_size)\n\t\t*db_size = sizeof(u32);\n\tif (db_data)\n\t\t*db_data = BIT_ULL(db_bit) << sndev->db_peer_shift;\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_peer_db_set(struct ntb_dev *ntb, u64 db_bits)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tiowrite64(db_bits << sndev->db_peer_shift,\n\t\t  &sndev->mmio_peer_dbmsg->odb);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_spad_count(struct ntb_dev *ntb)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\treturn ARRAY_SIZE(sndev->self_shared->spad);\n}\n\nstatic u32 switchtec_ntb_spad_read(struct ntb_dev *ntb, int idx)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (idx < 0 || idx >= ARRAY_SIZE(sndev->self_shared->spad))\n\t\treturn 0;\n\n\tif (!sndev->self_shared)\n\t\treturn 0;\n\n\treturn sndev->self_shared->spad[idx];\n}\n\nstatic int switchtec_ntb_spad_write(struct ntb_dev *ntb, int idx, u32 val)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (idx < 0 || idx >= ARRAY_SIZE(sndev->self_shared->spad))\n\t\treturn -EINVAL;\n\n\tif (!sndev->self_shared)\n\t\treturn -EIO;\n\n\tsndev->self_shared->spad[idx] = val;\n\n\treturn 0;\n}\n\nstatic u32 switchtec_ntb_peer_spad_read(struct ntb_dev *ntb, int pidx,\n\t\t\t\t\tint sidx)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tif (sidx < 0 || sidx >= ARRAY_SIZE(sndev->peer_shared->spad))\n\t\treturn 0;\n\n\tif (!sndev->peer_shared)\n\t\treturn 0;\n\n\treturn ioread32(&sndev->peer_shared->spad[sidx]);\n}\n\nstatic int switchtec_ntb_peer_spad_write(struct ntb_dev *ntb, int pidx,\n\t\t\t\t\t int sidx, u32 val)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tif (sidx < 0 || sidx >= ARRAY_SIZE(sndev->peer_shared->spad))\n\t\treturn -EINVAL;\n\n\tif (!sndev->peer_shared)\n\t\treturn -EIO;\n\n\tiowrite32(val, &sndev->peer_shared->spad[sidx]);\n\n\treturn 0;\n}\n\nstatic int switchtec_ntb_peer_spad_addr(struct ntb_dev *ntb, int pidx,\n\t\t\t\t\tint sidx, phys_addr_t *spad_addr)\n{\n\tstruct switchtec_ntb *sndev = ntb_sndev(ntb);\n\tunsigned long offset;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\toffset = (unsigned long)&sndev->peer_shared->spad[sidx] -\n\t\t(unsigned long)sndev->stdev->mmio;\n\n\tif (spad_addr)\n\t\t*spad_addr = pci_resource_start(ntb->pdev, 0) + offset;\n\n\treturn 0;\n}\n\nstatic const struct ntb_dev_ops switchtec_ntb_ops = {\n\t.mw_count\t\t= switchtec_ntb_mw_count,\n\t.mw_get_align\t\t= switchtec_ntb_mw_get_align,\n\t.mw_set_trans\t\t= switchtec_ntb_mw_set_trans,\n\t.peer_mw_count\t\t= switchtec_ntb_peer_mw_count,\n\t.peer_mw_get_addr\t= switchtec_ntb_peer_mw_get_addr,\n\t.link_is_up\t\t= switchtec_ntb_link_is_up,\n\t.link_enable\t\t= switchtec_ntb_link_enable,\n\t.link_disable\t\t= switchtec_ntb_link_disable,\n\t.db_valid_mask\t\t= switchtec_ntb_db_valid_mask,\n\t.db_vector_count\t= switchtec_ntb_db_vector_count,\n\t.db_vector_mask\t\t= switchtec_ntb_db_vector_mask,\n\t.db_read\t\t= switchtec_ntb_db_read,\n\t.db_clear\t\t= switchtec_ntb_db_clear,\n\t.db_set_mask\t\t= switchtec_ntb_db_set_mask,\n\t.db_clear_mask\t\t= switchtec_ntb_db_clear_mask,\n\t.db_read_mask\t\t= switchtec_ntb_db_read_mask,\n\t.peer_db_addr\t\t= switchtec_ntb_peer_db_addr,\n\t.peer_db_set\t\t= switchtec_ntb_peer_db_set,\n\t.spad_count\t\t= switchtec_ntb_spad_count,\n\t.spad_read\t\t= switchtec_ntb_spad_read,\n\t.spad_write\t\t= switchtec_ntb_spad_write,\n\t.peer_spad_read\t\t= switchtec_ntb_peer_spad_read,\n\t.peer_spad_write\t= switchtec_ntb_peer_spad_write,\n\t.peer_spad_addr\t\t= switchtec_ntb_peer_spad_addr,\n};\n\nstatic int switchtec_ntb_init_sndev(struct switchtec_ntb *sndev)\n{\n\tu64 tpart_vec;\n\tint self;\n\tu64 part_map;\n\n\tsndev->ntb.pdev = sndev->stdev->pdev;\n\tsndev->ntb.topo = NTB_TOPO_SWITCH;\n\tsndev->ntb.ops = &switchtec_ntb_ops;\n\n\tINIT_WORK(&sndev->check_link_status_work, check_link_status_work);\n\tsndev->link_force_down = false;\n\n\tsndev->self_partition = sndev->stdev->partition;\n\n\tsndev->mmio_ntb = sndev->stdev->mmio_ntb;\n\n\tself = sndev->self_partition;\n\ttpart_vec = ioread32(&sndev->mmio_ntb->ntp_info[self].target_part_high);\n\ttpart_vec <<= 32;\n\ttpart_vec |= ioread32(&sndev->mmio_ntb->ntp_info[self].target_part_low);\n\n\tpart_map = ioread64(&sndev->mmio_ntb->ep_map);\n\ttpart_vec &= part_map;\n\tpart_map &= ~(1 << sndev->self_partition);\n\n\tif (!tpart_vec) {\n\t\tif (sndev->stdev->partition_count != 2) {\n\t\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\t\"ntb target partition not defined\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (!part_map) {\n\t\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\t\"peer partition is not NT partition\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsndev->peer_partition = __ffs64(part_map);\n\t} else {\n\t\tif (__ffs64(tpart_vec) != (fls64(tpart_vec) - 1)) {\n\t\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\t\"ntb driver only supports 1 pair of 1-1 ntb mapping\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsndev->peer_partition = __ffs64(tpart_vec);\n\t\tif (!(part_map & (1ULL << sndev->peer_partition))) {\n\t\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\t\"ntb target partition is not NT partition\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tdev_dbg(&sndev->stdev->dev, \"Partition ID %d of %d\\n\",\n\t\tsndev->self_partition, sndev->stdev->partition_count);\n\n\tsndev->mmio_ctrl = (void * __iomem)sndev->mmio_ntb +\n\t\tSWITCHTEC_NTB_REG_CTRL_OFFSET;\n\tsndev->mmio_dbmsg = (void * __iomem)sndev->mmio_ntb +\n\t\tSWITCHTEC_NTB_REG_DBMSG_OFFSET;\n\n\tsndev->mmio_self_ctrl = &sndev->mmio_ctrl[sndev->self_partition];\n\tsndev->mmio_peer_ctrl = &sndev->mmio_ctrl[sndev->peer_partition];\n\tsndev->mmio_self_dbmsg = &sndev->mmio_dbmsg[sndev->self_partition];\n\tsndev->mmio_peer_dbmsg = sndev->mmio_self_dbmsg;\n\n\treturn 0;\n}\n\nstatic int config_rsvd_lut_win(struct switchtec_ntb *sndev,\n\t\t\t       struct ntb_ctrl_regs __iomem *ctl,\n\t\t\t       int lut_idx, int partition, u64 addr)\n{\n\tint peer_bar = sndev->peer_direct_mw_to_bar[0];\n\tu32 ctl_val;\n\tint rc;\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_LOCK,\n\t\t\t\t   NTB_CTRL_PART_STATUS_LOCKED);\n\tif (rc)\n\t\treturn rc;\n\n\tctl_val = ioread32(&ctl->bar_entry[peer_bar].ctl);\n\tctl_val &= 0xFF;\n\tctl_val |= NTB_CTRL_BAR_LUT_WIN_EN;\n\tctl_val |= ilog2(LUT_SIZE) << 8;\n\tctl_val |= (sndev->nr_lut_mw - 1) << 14;\n\tiowrite32(ctl_val, &ctl->bar_entry[peer_bar].ctl);\n\n\tiowrite64((NTB_CTRL_LUT_EN | (partition << 1) | addr),\n\t\t  &ctl->lut_entry[lut_idx]);\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_CFG,\n\t\t\t\t   NTB_CTRL_PART_STATUS_NORMAL);\n\tif (rc) {\n\t\tu32 bar_error, lut_error;\n\n\t\tbar_error = ioread32(&ctl->bar_error);\n\t\tlut_error = ioread32(&ctl->lut_error);\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Error setting up reserved lut window: %08x / %08x\\n\",\n\t\t\tbar_error, lut_error);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int config_req_id_table(struct switchtec_ntb *sndev,\n\t\t\t       struct ntb_ctrl_regs __iomem *mmio_ctrl,\n\t\t\t       int *req_ids, int count)\n{\n\tint i, rc = 0;\n\tu32 error;\n\tu32 proxy_id;\n\n\tif (ioread16(&mmio_ctrl->req_id_table_size) < count) {\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Not enough requester IDs available.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\trc = switchtec_ntb_part_op(sndev, mmio_ctrl,\n\t\t\t\t   NTB_CTRL_PART_OP_LOCK,\n\t\t\t\t   NTB_CTRL_PART_STATUS_LOCKED);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < count; i++) {\n\t\tiowrite32(req_ids[i] << 16 | NTB_CTRL_REQ_ID_EN,\n\t\t\t  &mmio_ctrl->req_id_table[i]);\n\n\t\tproxy_id = ioread32(&mmio_ctrl->req_id_table[i]);\n\t\tdev_dbg(&sndev->stdev->dev,\n\t\t\t\"Requester ID %02X:%02X.%X -> BB:%02X.%X\\n\",\n\t\t\treq_ids[i] >> 8, (req_ids[i] >> 3) & 0x1F,\n\t\t\treq_ids[i] & 0x7, (proxy_id >> 4) & 0x1F,\n\t\t\t(proxy_id >> 1) & 0x7);\n\t}\n\n\trc = switchtec_ntb_part_op(sndev, mmio_ctrl,\n\t\t\t\t   NTB_CTRL_PART_OP_CFG,\n\t\t\t\t   NTB_CTRL_PART_STATUS_NORMAL);\n\n\tif (rc == -EIO) {\n\t\terror = ioread32(&mmio_ctrl->req_id_error);\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Error setting up the requester ID table: %08x\\n\",\n\t\t\terror);\n\t}\n\n\treturn 0;\n}\n\nstatic int crosslink_setup_mws(struct switchtec_ntb *sndev, int ntb_lut_idx,\n\t\t\t       u64 *mw_addrs, int mw_count)\n{\n\tint rc, i;\n\tstruct ntb_ctrl_regs __iomem *ctl = sndev->mmio_self_ctrl;\n\tu64 addr;\n\tsize_t size, offset;\n\tint bar;\n\tint xlate_pos;\n\tu32 ctl_val;\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_LOCK,\n\t\t\t\t   NTB_CTRL_PART_STATUS_LOCKED);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < sndev->nr_lut_mw; i++) {\n\t\tif (i == ntb_lut_idx)\n\t\t\tcontinue;\n\n\t\taddr = mw_addrs[0] + LUT_SIZE * i;\n\n\t\tiowrite64((NTB_CTRL_LUT_EN | (sndev->peer_partition << 1) |\n\t\t\t   addr),\n\t\t\t  &ctl->lut_entry[i]);\n\t}\n\n\tsndev->nr_direct_mw = min_t(int, sndev->nr_direct_mw, mw_count);\n\n\tfor (i = 0; i < sndev->nr_direct_mw; i++) {\n\t\tbar = sndev->direct_mw_to_bar[i];\n\t\toffset = (i == 0) ? LUT_SIZE * sndev->nr_lut_mw : 0;\n\t\taddr = mw_addrs[i] + offset;\n\t\tsize = pci_resource_len(sndev->ntb.pdev, bar) - offset;\n\t\txlate_pos = ilog2(size);\n\n\t\tif (offset && size > offset)\n\t\t\tsize = offset;\n\n\t\tctl_val = ioread32(&ctl->bar_entry[bar].ctl);\n\t\tctl_val |= NTB_CTRL_BAR_DIR_WIN_EN;\n\n\t\tiowrite32(ctl_val, &ctl->bar_entry[bar].ctl);\n\t\tiowrite32(xlate_pos | (lower_32_bits(size) & 0xFFFFF000),\n\t\t\t  &ctl->bar_entry[bar].win_size);\n\t\tiowrite32(upper_32_bits(size), &ctl->bar_ext_entry[bar].win_size);\n\t\tiowrite64(sndev->peer_partition | addr,\n\t\t\t  &ctl->bar_entry[bar].xlate_addr);\n\t}\n\n\trc = switchtec_ntb_part_op(sndev, ctl, NTB_CTRL_PART_OP_CFG,\n\t\t\t\t   NTB_CTRL_PART_STATUS_NORMAL);\n\tif (rc) {\n\t\tu32 bar_error, lut_error;\n\n\t\tbar_error = ioread32(&ctl->bar_error);\n\t\tlut_error = ioread32(&ctl->lut_error);\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Error setting up cross link windows: %08x / %08x\\n\",\n\t\t\tbar_error, lut_error);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int crosslink_setup_req_ids(struct switchtec_ntb *sndev,\n\tstruct ntb_ctrl_regs __iomem *mmio_ctrl)\n{\n\tint req_ids[16];\n\tint i;\n\tu32 proxy_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(req_ids); i++) {\n\t\tproxy_id = ioread32(&sndev->mmio_self_ctrl->req_id_table[i]);\n\n\t\tif (!(proxy_id & NTB_CTRL_REQ_ID_EN))\n\t\t\tbreak;\n\n\t\treq_ids[i] = ((proxy_id >> 1) & 0xFF);\n\t}\n\n\treturn config_req_id_table(sndev, mmio_ctrl, req_ids, i);\n}\n\n \nstatic int crosslink_enum_partition(struct switchtec_ntb *sndev,\n\t\t\t\t    u64 *bar_addrs)\n{\n\tstruct part_cfg_regs __iomem *part_cfg =\n\t\t&sndev->stdev->mmio_part_cfg_all[sndev->peer_partition];\n\tu32 pff = ioread32(&part_cfg->vep_pff_inst_id) & 0xFF;\n\tstruct pff_csr_regs __iomem *mmio_pff =\n\t\t&sndev->stdev->mmio_pff_csr[pff];\n\tconst u64 bar_space = 0x1000000000LL;\n\tu64 bar_addr;\n\tint bar_cnt = 0;\n\tint i;\n\n\tiowrite16(0x6, &mmio_pff->pcicmd);\n\n\tfor (i = 0; i < ARRAY_SIZE(mmio_pff->pci_bar64); i++) {\n\t\tiowrite64(bar_space * i, &mmio_pff->pci_bar64[i]);\n\t\tbar_addr = ioread64(&mmio_pff->pci_bar64[i]);\n\t\tbar_addr &= ~0xf;\n\n\t\tdev_dbg(&sndev->stdev->dev,\n\t\t\t\"Crosslink BAR%d addr: %llx\\n\",\n\t\t\ti*2, bar_addr);\n\n\t\tif (bar_addr != bar_space * i)\n\t\t\tcontinue;\n\n\t\tbar_addrs[bar_cnt++] = bar_addr;\n\t}\n\n\treturn bar_cnt;\n}\n\nstatic int switchtec_ntb_init_crosslink(struct switchtec_ntb *sndev)\n{\n\tint rc;\n\tint bar = sndev->direct_mw_to_bar[0];\n\tconst int ntb_lut_idx = 1;\n\tu64 bar_addrs[6];\n\tu64 addr;\n\tint offset;\n\tint bar_cnt;\n\n\tif (!crosslink_is_enabled(sndev))\n\t\treturn 0;\n\n\tdev_info(&sndev->stdev->dev, \"Using crosslink configuration\\n\");\n\tsndev->ntb.topo = NTB_TOPO_CROSSLINK;\n\n\tbar_cnt = crosslink_enum_partition(sndev, bar_addrs);\n\tif (bar_cnt < sndev->nr_direct_mw + 1) {\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"Error enumerating crosslink partition\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = (bar_addrs[0] + SWITCHTEC_GAS_NTB_OFFSET +\n\t\tSWITCHTEC_NTB_REG_DBMSG_OFFSET +\n\t\tsizeof(struct ntb_dbmsg_regs) * sndev->peer_partition);\n\n\toffset = addr & (LUT_SIZE - 1);\n\taddr -= offset;\n\n\trc = config_rsvd_lut_win(sndev, sndev->mmio_self_ctrl, ntb_lut_idx,\n\t\t\t\t sndev->peer_partition, addr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = crosslink_setup_mws(sndev, ntb_lut_idx, &bar_addrs[1],\n\t\t\t\t bar_cnt - 1);\n\tif (rc)\n\t\treturn rc;\n\n\trc = crosslink_setup_req_ids(sndev, sndev->mmio_peer_ctrl);\n\tif (rc)\n\t\treturn rc;\n\n\tsndev->mmio_xlink_win = pci_iomap_range(sndev->stdev->pdev, bar,\n\t\t\t\t\t\tLUT_SIZE, LUT_SIZE);\n\tif (!sndev->mmio_xlink_win) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tsndev->mmio_peer_dbmsg = sndev->mmio_xlink_win + offset;\n\tsndev->nr_rsvd_luts++;\n\n\tcrosslink_init_dbmsgs(sndev);\n\n\treturn 0;\n}\n\nstatic void switchtec_ntb_deinit_crosslink(struct switchtec_ntb *sndev)\n{\n\tif (sndev->mmio_xlink_win)\n\t\tpci_iounmap(sndev->stdev->pdev, sndev->mmio_xlink_win);\n}\n\nstatic int map_bars(int *map, struct ntb_ctrl_regs __iomem *ctrl)\n{\n\tint i;\n\tint cnt = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl->bar_entry); i++) {\n\t\tu32 r = ioread32(&ctrl->bar_entry[i].ctl);\n\n\t\tif (r & NTB_CTRL_BAR_VALID)\n\t\t\tmap[cnt++] = i;\n\t}\n\n\treturn cnt;\n}\n\nstatic void switchtec_ntb_init_mw(struct switchtec_ntb *sndev)\n{\n\tsndev->nr_direct_mw = map_bars(sndev->direct_mw_to_bar,\n\t\t\t\t       sndev->mmio_self_ctrl);\n\n\tsndev->nr_lut_mw = ioread16(&sndev->mmio_self_ctrl->lut_table_entries);\n\tsndev->nr_lut_mw = rounddown_pow_of_two(sndev->nr_lut_mw);\n\n\tdev_dbg(&sndev->stdev->dev, \"MWs: %d direct, %d lut\\n\",\n\t\tsndev->nr_direct_mw, sndev->nr_lut_mw);\n\n\tsndev->peer_nr_direct_mw = map_bars(sndev->peer_direct_mw_to_bar,\n\t\t\t\t\t    sndev->mmio_peer_ctrl);\n\n\tsndev->peer_nr_lut_mw =\n\t\tioread16(&sndev->mmio_peer_ctrl->lut_table_entries);\n\tsndev->peer_nr_lut_mw = rounddown_pow_of_two(sndev->peer_nr_lut_mw);\n\n\tdev_dbg(&sndev->stdev->dev, \"Peer MWs: %d direct, %d lut\\n\",\n\t\tsndev->peer_nr_direct_mw, sndev->peer_nr_lut_mw);\n\n}\n\n \nstatic void switchtec_ntb_init_db(struct switchtec_ntb *sndev)\n{\n\tsndev->db_mask = 0x0FFFFFFFFFFFFFFFULL;\n\n\tif (sndev->mmio_peer_dbmsg != sndev->mmio_self_dbmsg) {\n\t\tsndev->db_shift = 0;\n\t\tsndev->db_peer_shift = 0;\n\t\tsndev->db_valid_mask = sndev->db_mask;\n\t} else if (sndev->self_partition < sndev->peer_partition) {\n\t\tsndev->db_shift = 0;\n\t\tsndev->db_peer_shift = 32;\n\t\tsndev->db_valid_mask = 0x0FFFFFFF;\n\t} else {\n\t\tsndev->db_shift = 32;\n\t\tsndev->db_peer_shift = 0;\n\t\tsndev->db_valid_mask = 0x0FFFFFFF;\n\t}\n\n\tiowrite64(~sndev->db_mask, &sndev->mmio_self_dbmsg->idb_mask);\n\tiowrite64(sndev->db_valid_mask << sndev->db_peer_shift,\n\t\t  &sndev->mmio_peer_dbmsg->odb_mask);\n\n\tdev_dbg(&sndev->stdev->dev, \"dbs: shift %d/%d, mask %016llx\\n\",\n\t\tsndev->db_shift, sndev->db_peer_shift, sndev->db_valid_mask);\n}\n\nstatic void switchtec_ntb_init_msgs(struct switchtec_ntb *sndev)\n{\n\tint i;\n\tu32 msg_map = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sndev->mmio_self_dbmsg->imsg); i++) {\n\t\tint m = i | sndev->peer_partition << 2;\n\n\t\tmsg_map |= m << i * 8;\n\t}\n\n\tiowrite32(msg_map, &sndev->mmio_self_dbmsg->msg_map);\n\n\tfor (i = 0; i < ARRAY_SIZE(sndev->mmio_self_dbmsg->imsg); i++)\n\t\tiowrite64(NTB_DBMSG_IMSG_STATUS | NTB_DBMSG_IMSG_MASK,\n\t\t\t  &sndev->mmio_self_dbmsg->imsg[i]);\n}\n\nstatic int\nswitchtec_ntb_init_req_id_table(struct switchtec_ntb *sndev)\n{\n\tint req_ids[2];\n\n\t \n\treq_ids[0] = 0;\n\n\t \n\treq_ids[1] = ioread16(&sndev->mmio_ntb->requester_id);\n\n\treturn config_req_id_table(sndev, sndev->mmio_self_ctrl, req_ids,\n\t\t\t\t   ARRAY_SIZE(req_ids));\n}\n\nstatic void switchtec_ntb_init_shared(struct switchtec_ntb *sndev)\n{\n\tint i;\n\n\tmemset(sndev->self_shared, 0, LUT_SIZE);\n\tsndev->self_shared->magic = SWITCHTEC_NTB_MAGIC;\n\tsndev->self_shared->partition_id = sndev->stdev->partition;\n\n\tfor (i = 0; i < sndev->nr_direct_mw; i++) {\n\t\tint bar = sndev->direct_mw_to_bar[i];\n\t\tresource_size_t sz = pci_resource_len(sndev->stdev->pdev, bar);\n\n\t\tif (i == 0)\n\t\t\tsz = min_t(resource_size_t, sz,\n\t\t\t\t   LUT_SIZE * sndev->nr_lut_mw);\n\n\t\tsndev->self_shared->mw_sizes[i] = sz;\n\t}\n\n\tfor (i = 0; i < sndev->nr_lut_mw; i++) {\n\t\tint idx = sndev->nr_direct_mw + i;\n\n\t\tsndev->self_shared->mw_sizes[idx] = LUT_SIZE;\n\t}\n}\n\nstatic int switchtec_ntb_init_shared_mw(struct switchtec_ntb *sndev)\n{\n\tint self_bar = sndev->direct_mw_to_bar[0];\n\tint rc;\n\n\tsndev->nr_rsvd_luts++;\n\tsndev->self_shared = dma_alloc_coherent(&sndev->stdev->pdev->dev,\n\t\t\t\t\t\tLUT_SIZE,\n\t\t\t\t\t\t&sndev->self_shared_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!sndev->self_shared) {\n\t\tdev_err(&sndev->stdev->dev,\n\t\t\t\"unable to allocate memory for shared mw\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tswitchtec_ntb_init_shared(sndev);\n\n\trc = config_rsvd_lut_win(sndev, sndev->mmio_peer_ctrl, 0,\n\t\t\t\t sndev->self_partition,\n\t\t\t\t sndev->self_shared_dma);\n\tif (rc)\n\t\tgoto unalloc_and_exit;\n\n\tsndev->peer_shared = pci_iomap(sndev->stdev->pdev, self_bar, LUT_SIZE);\n\tif (!sndev->peer_shared) {\n\t\trc = -ENOMEM;\n\t\tgoto unalloc_and_exit;\n\t}\n\n\tdev_dbg(&sndev->stdev->dev, \"Shared MW Ready\\n\");\n\treturn 0;\n\nunalloc_and_exit:\n\tdma_free_coherent(&sndev->stdev->pdev->dev, LUT_SIZE,\n\t\t\t  sndev->self_shared, sndev->self_shared_dma);\n\n\treturn rc;\n}\n\nstatic void switchtec_ntb_deinit_shared_mw(struct switchtec_ntb *sndev)\n{\n\tif (sndev->peer_shared)\n\t\tpci_iounmap(sndev->stdev->pdev, sndev->peer_shared);\n\n\tif (sndev->self_shared)\n\t\tdma_free_coherent(&sndev->stdev->pdev->dev, LUT_SIZE,\n\t\t\t\t  sndev->self_shared,\n\t\t\t\t  sndev->self_shared_dma);\n\tsndev->nr_rsvd_luts--;\n}\n\nstatic irqreturn_t switchtec_ntb_doorbell_isr(int irq, void *dev)\n{\n\tstruct switchtec_ntb *sndev = dev;\n\n\tdev_dbg(&sndev->stdev->dev, \"doorbell\\n\");\n\n\tntb_db_event(&sndev->ntb, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t switchtec_ntb_message_isr(int irq, void *dev)\n{\n\tint i;\n\tstruct switchtec_ntb *sndev = dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(sndev->mmio_self_dbmsg->imsg); i++) {\n\t\tu64 msg = ioread64(&sndev->mmio_self_dbmsg->imsg[i]);\n\n\t\tif (msg & NTB_DBMSG_IMSG_STATUS) {\n\t\t\tdev_dbg(&sndev->stdev->dev, \"message: %d %08x\\n\",\n\t\t\t\ti, (u32)msg);\n\t\t\tiowrite8(1, &sndev->mmio_self_dbmsg->imsg[i].status);\n\n\t\t\tif (i == LINK_MESSAGE)\n\t\t\t\tswitchtec_ntb_check_link(sndev, msg);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int switchtec_ntb_init_db_msg_irq(struct switchtec_ntb *sndev)\n{\n\tint i;\n\tint rc;\n\tint doorbell_irq = 0;\n\tint message_irq = 0;\n\tint event_irq;\n\tint idb_vecs = sizeof(sndev->mmio_self_dbmsg->idb_vec_map);\n\n\tevent_irq = ioread32(&sndev->stdev->mmio_part_cfg->vep_vector_number);\n\n\twhile (doorbell_irq == event_irq)\n\t\tdoorbell_irq++;\n\twhile (message_irq == doorbell_irq ||\n\t       message_irq == event_irq)\n\t\tmessage_irq++;\n\n\tdev_dbg(&sndev->stdev->dev, \"irqs - event: %d, db: %d, msgs: %d\\n\",\n\t\tevent_irq, doorbell_irq, message_irq);\n\n\tfor (i = 0; i < idb_vecs - 4; i++)\n\t\tiowrite8(doorbell_irq,\n\t\t\t &sndev->mmio_self_dbmsg->idb_vec_map[i]);\n\n\tfor (; i < idb_vecs; i++)\n\t\tiowrite8(message_irq,\n\t\t\t &sndev->mmio_self_dbmsg->idb_vec_map[i]);\n\n\tsndev->doorbell_irq = pci_irq_vector(sndev->stdev->pdev, doorbell_irq);\n\tsndev->message_irq = pci_irq_vector(sndev->stdev->pdev, message_irq);\n\n\trc = request_irq(sndev->doorbell_irq,\n\t\t\t switchtec_ntb_doorbell_isr, 0,\n\t\t\t \"switchtec_ntb_doorbell\", sndev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = request_irq(sndev->message_irq,\n\t\t\t switchtec_ntb_message_isr, 0,\n\t\t\t \"switchtec_ntb_message\", sndev);\n\tif (rc) {\n\t\tfree_irq(sndev->doorbell_irq, sndev);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void switchtec_ntb_deinit_db_msg_irq(struct switchtec_ntb *sndev)\n{\n\tfree_irq(sndev->doorbell_irq, sndev);\n\tfree_irq(sndev->message_irq, sndev);\n}\n\nstatic int switchtec_ntb_reinit_peer(struct switchtec_ntb *sndev)\n{\n\tint rc;\n\n\tif (crosslink_is_enabled(sndev))\n\t\treturn 0;\n\n\tdev_info(&sndev->stdev->dev, \"reinitialize shared memory window\\n\");\n\trc = config_rsvd_lut_win(sndev, sndev->mmio_peer_ctrl, 0,\n\t\t\t\t sndev->self_partition,\n\t\t\t\t sndev->self_shared_dma);\n\treturn rc;\n}\n\nstatic int switchtec_ntb_add(struct device *dev)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tstruct switchtec_ntb *sndev;\n\tint rc;\n\n\tstdev->sndev = NULL;\n\n\tif (stdev->pdev->class != (PCI_CLASS_BRIDGE_OTHER << 8))\n\t\treturn -ENODEV;\n\n\tsndev = kzalloc_node(sizeof(*sndev), GFP_KERNEL, dev_to_node(dev));\n\tif (!sndev)\n\t\treturn -ENOMEM;\n\n\tsndev->stdev = stdev;\n\trc = switchtec_ntb_init_sndev(sndev);\n\tif (rc)\n\t\tgoto free_and_exit;\n\n\tswitchtec_ntb_init_mw(sndev);\n\n\trc = switchtec_ntb_init_req_id_table(sndev);\n\tif (rc)\n\t\tgoto free_and_exit;\n\n\trc = switchtec_ntb_init_crosslink(sndev);\n\tif (rc)\n\t\tgoto free_and_exit;\n\n\tswitchtec_ntb_init_db(sndev);\n\tswitchtec_ntb_init_msgs(sndev);\n\n\trc = switchtec_ntb_init_shared_mw(sndev);\n\tif (rc)\n\t\tgoto deinit_crosslink;\n\n\trc = switchtec_ntb_init_db_msg_irq(sndev);\n\tif (rc)\n\t\tgoto deinit_shared_and_exit;\n\n\t \n\tswitchtec_ntb_send_msg(sndev, LINK_MESSAGE, MSG_LINK_FORCE_DOWN);\n\n\trc = ntb_register_device(&sndev->ntb);\n\tif (rc)\n\t\tgoto deinit_and_exit;\n\n\tstdev->sndev = sndev;\n\tstdev->link_notifier = switchtec_ntb_link_notification;\n\tdev_info(dev, \"NTB device registered\\n\");\n\n\treturn 0;\n\ndeinit_and_exit:\n\tswitchtec_ntb_deinit_db_msg_irq(sndev);\ndeinit_shared_and_exit:\n\tswitchtec_ntb_deinit_shared_mw(sndev);\ndeinit_crosslink:\n\tswitchtec_ntb_deinit_crosslink(sndev);\nfree_and_exit:\n\tkfree(sndev);\n\tdev_err(dev, \"failed to register ntb device: %d\\n\", rc);\n\treturn rc;\n}\n\nstatic void switchtec_ntb_remove(struct device *dev)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tstruct switchtec_ntb *sndev = stdev->sndev;\n\n\tif (!sndev)\n\t\treturn;\n\n\tstdev->link_notifier = NULL;\n\tstdev->sndev = NULL;\n\tntb_unregister_device(&sndev->ntb);\n\tswitchtec_ntb_deinit_db_msg_irq(sndev);\n\tswitchtec_ntb_deinit_shared_mw(sndev);\n\tswitchtec_ntb_deinit_crosslink(sndev);\n\tkfree(sndev);\n\tdev_info(dev, \"ntb device unregistered\\n\");\n}\n\nstatic struct class_interface switchtec_interface  = {\n\t.add_dev = switchtec_ntb_add,\n\t.remove_dev = switchtec_ntb_remove,\n};\n\nstatic int __init switchtec_ntb_init(void)\n{\n\tswitchtec_interface.class = switchtec_class;\n\treturn class_interface_register(&switchtec_interface);\n}\nmodule_init(switchtec_ntb_init);\n\nstatic void __exit switchtec_ntb_exit(void)\n{\n\tclass_interface_unregister(&switchtec_interface);\n}\nmodule_exit(switchtec_ntb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}