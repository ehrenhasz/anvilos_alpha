{
  "module_name": "ntb_hw_gen4.c",
  "hash_id": "2ecf876704e5edcb51b9875b7e5c093d0d899faf07207fcae7403594d35849ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/hw/intel/ntb_hw_gen4.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/ntb.h>\n#include <linux/log2.h>\n\n#include \"ntb_hw_intel.h\"\n#include \"ntb_hw_gen1.h\"\n#include \"ntb_hw_gen3.h\"\n#include \"ntb_hw_gen4.h\"\n\nstatic int gen4_poll_link(struct intel_ntb_dev *ndev);\nstatic int gen4_link_is_up(struct intel_ntb_dev *ndev);\n\nstatic const struct intel_ntb_reg gen4_reg = {\n\t.poll_link\t\t= gen4_poll_link,\n\t.link_is_up\t\t= gen4_link_is_up,\n\t.db_ioread\t\t= gen3_db_ioread,\n\t.db_iowrite\t\t= gen3_db_iowrite,\n\t.db_size\t\t= sizeof(u32),\n\t.ntb_ctl\t\t= GEN4_NTBCNTL_OFFSET,\n\t.mw_bar\t\t\t= {2, 4},\n};\n\nstatic const struct intel_ntb_alt_reg gen4_pri_reg = {\n\t.db_clear\t\t= GEN4_IM_INT_STATUS_OFFSET,\n\t.db_mask\t\t= GEN4_IM_INT_DISABLE_OFFSET,\n\t.spad\t\t\t= GEN4_IM_SPAD_OFFSET,\n};\n\nstatic const struct intel_ntb_xlat_reg gen4_sec_xlat = {\n\t.bar2_limit\t\t= GEN4_IM23XLMT_OFFSET,\n\t.bar2_xlat\t\t= GEN4_IM23XBASE_OFFSET,\n\t.bar2_idx\t\t= GEN4_IM23XBASEIDX_OFFSET,\n};\n\nstatic const struct intel_ntb_alt_reg gen4_b2b_reg = {\n\t.db_bell\t\t= GEN4_IM_DOORBELL_OFFSET,\n\t.spad\t\t\t= GEN4_EM_SPAD_OFFSET,\n};\n\nstatic int gen4_poll_link(struct intel_ntb_dev *ndev)\n{\n\tu16 reg_val;\n\n\t \n\tiowrite16(GEN4_SLOTSTS_DLLSCS, ndev->self_mmio + GEN4_SLOTSTS);\n\tndev->reg->db_iowrite(ndev->db_link_mask,\n\t\t\t      ndev->self_mmio +\n\t\t\t      ndev->self_reg->db_clear);\n\n\treg_val = ioread16(ndev->self_mmio + GEN4_LINK_STATUS_OFFSET);\n\tif (reg_val == ndev->lnk_sta)\n\t\treturn 0;\n\n\tndev->lnk_sta = reg_val;\n\n\treturn 1;\n}\n\nstatic int gen4_link_is_up(struct intel_ntb_dev *ndev)\n{\n\treturn NTB_LNK_STA_ACTIVE(ndev->lnk_sta);\n}\n\nstatic int gen4_init_isr(struct intel_ntb_dev *ndev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < GEN4_DB_MSIX_VECTOR_COUNT; i++)\n\t\tiowrite8(i, ndev->self_mmio + GEN4_INTVEC_OFFSET + i);\n\n\treturn ndev_init_isr(ndev, GEN4_DB_MSIX_VECTOR_COUNT,\n\t\t\t     GEN4_DB_MSIX_VECTOR_COUNT,\n\t\t\t     GEN4_DB_MSIX_VECTOR_SHIFT,\n\t\t\t     GEN4_DB_TOTAL_SHIFT);\n}\n\nstatic int gen4_setup_b2b_mw(struct intel_ntb_dev *ndev,\n\t\t\t    const struct intel_b2b_addr *addr,\n\t\t\t    const struct intel_b2b_addr *peer_addr)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *mmio;\n\tphys_addr_t bar_addr;\n\n\tpdev = ndev->ntb.pdev;\n\tmmio = ndev->self_mmio;\n\n\t \n\tbar_addr = addr->bar2_addr64;\n\tiowrite64(bar_addr, mmio + GEN4_IM23XLMT_OFFSET);\n\tbar_addr = ioread64(mmio + GEN4_IM23XLMT_OFFSET);\n\tdev_dbg(&pdev->dev, \"IM23XLMT %#018llx\\n\", bar_addr);\n\n\tbar_addr = addr->bar4_addr64;\n\tiowrite64(bar_addr, mmio + GEN4_IM45XLMT_OFFSET);\n\tbar_addr = ioread64(mmio + GEN4_IM45XLMT_OFFSET);\n\tdev_dbg(&pdev->dev, \"IM45XLMT %#018llx\\n\", bar_addr);\n\n\t \n\tiowrite64(0, mmio + GEN4_IM23XBASE_OFFSET);\n\tiowrite64(0, mmio + GEN4_IM45XBASE_OFFSET);\n\n\tndev->peer_mmio = ndev->self_mmio;\n\n\treturn 0;\n}\n\nstatic int gen4_init_ntb(struct intel_ntb_dev *ndev)\n{\n\tint rc;\n\n\n\tndev->mw_count = XEON_MW_COUNT;\n\tndev->spad_count = GEN4_SPAD_COUNT;\n\tndev->db_count = GEN4_DB_COUNT;\n\tndev->db_link_mask = GEN4_DB_LINK_BIT;\n\n\tndev->self_reg = &gen4_pri_reg;\n\tndev->xlat_reg = &gen4_sec_xlat;\n\tndev->peer_reg = &gen4_b2b_reg;\n\n\tif (ndev->ntb.topo == NTB_TOPO_B2B_USD)\n\t\trc = gen4_setup_b2b_mw(ndev, &xeon_b2b_dsd_addr,\n\t\t\t\t&xeon_b2b_usd_addr);\n\telse\n\t\trc = gen4_setup_b2b_mw(ndev, &xeon_b2b_usd_addr,\n\t\t\t\t&xeon_b2b_dsd_addr);\n\tif (rc)\n\t\treturn rc;\n\n\tndev->db_valid_mask = BIT_ULL(ndev->db_count) - 1;\n\n\tndev->reg->db_iowrite(ndev->db_valid_mask,\n\t\t\t      ndev->self_mmio +\n\t\t\t      ndev->self_reg->db_mask);\n\n\treturn 0;\n}\n\nstatic enum ntb_topo gen4_ppd_topo(struct intel_ntb_dev *ndev, u32 ppd)\n{\n\tswitch (ppd & GEN4_PPD_TOPO_MASK) {\n\tcase GEN4_PPD_TOPO_B2B_USD:\n\t\treturn NTB_TOPO_B2B_USD;\n\tcase GEN4_PPD_TOPO_B2B_DSD:\n\t\treturn NTB_TOPO_B2B_DSD;\n\t}\n\n\treturn NTB_TOPO_NONE;\n}\n\nstatic enum ntb_topo spr_ppd_topo(struct intel_ntb_dev *ndev, u32 ppd)\n{\n\tswitch (ppd & SPR_PPD_TOPO_MASK) {\n\tcase SPR_PPD_TOPO_B2B_USD:\n\t\treturn NTB_TOPO_B2B_USD;\n\tcase SPR_PPD_TOPO_B2B_DSD:\n\t\treturn NTB_TOPO_B2B_DSD;\n\t}\n\n\treturn NTB_TOPO_NONE;\n}\n\nint gen4_init_dev(struct intel_ntb_dev *ndev)\n{\n\tstruct pci_dev *pdev = ndev->ntb.pdev;\n\tu32 ppd1 ;\n\tu16 lnkctl;\n\tint rc;\n\n\tndev->reg = &gen4_reg;\n\n\tif (pdev_is_ICX(pdev)) {\n\t\tndev->hwerr_flags |= NTB_HWERR_BAR_ALIGN;\n\t\tndev->hwerr_flags |= NTB_HWERR_LTR_BAD;\n\t}\n\n\tppd1 = ioread32(ndev->self_mmio + GEN4_PPD1_OFFSET);\n\tif (pdev_is_ICX(pdev))\n\t\tndev->ntb.topo = gen4_ppd_topo(ndev, ppd1);\n\telse if (pdev_is_SPR(pdev) || pdev_is_gen5(pdev))\n\t\tndev->ntb.topo = spr_ppd_topo(ndev, ppd1);\n\tdev_dbg(&pdev->dev, \"ppd %#x topo %s\\n\", ppd1,\n\t\tntb_topo_string(ndev->ntb.topo));\n\tif (ndev->ntb.topo == NTB_TOPO_NONE)\n\t\treturn -EINVAL;\n\n\trc = gen4_init_ntb(ndev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tlnkctl = ioread16(ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\tlnkctl |= GEN4_LINK_CTRL_LINK_DISABLE;\n\tiowrite16(lnkctl, ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\n\treturn gen4_init_isr(ndev);\n}\n\nssize_t ndev_ntb4_debugfs_read(struct file *filp, char __user *ubuf,\n\t\t\t\t      size_t count, loff_t *offp)\n{\n\tstruct intel_ntb_dev *ndev;\n\tvoid __iomem *mmio;\n\tchar *buf;\n\tsize_t buf_size;\n\tssize_t ret, off;\n\tunion { u64 v64; u32 v32; u16 v16; } u;\n\n\tndev = filp->private_data;\n\tmmio = ndev->self_mmio;\n\n\tbuf_size = min(count, 0x800ul);\n\n\tbuf = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\toff = 0;\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"NTB Device Information:\\n\");\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Connection Topology -\\t%s\\n\",\n\t\t\t ntb_topo_string(ndev->ntb.topo));\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"NTB CTL -\\t\\t%#06x\\n\", ndev->ntb_ctl);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"LNK STA (cached) -\\t\\t%#06x\\n\", ndev->lnk_sta);\n\n\tif (!ndev->reg->link_is_up(ndev))\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"Link Status -\\t\\tDown\\n\");\n\telse {\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"Link Status -\\t\\tUp\\n\");\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"Link Speed -\\t\\tPCI-E Gen %u\\n\",\n\t\t\t\t NTB_LNK_STA_SPEED(ndev->lnk_sta));\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"Link Width -\\t\\tx%u\\n\",\n\t\t\t\t NTB_LNK_STA_WIDTH(ndev->lnk_sta));\n\t}\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Memory Window Count -\\t%u\\n\", ndev->mw_count);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Scratchpad Count -\\t%u\\n\", ndev->spad_count);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Count -\\t%u\\n\", ndev->db_count);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Vector Count -\\t%u\\n\", ndev->db_vec_count);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Vector Shift -\\t%u\\n\", ndev->db_vec_shift);\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Valid Mask -\\t%#llx\\n\", ndev->db_valid_mask);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Link Mask -\\t%#llx\\n\", ndev->db_link_mask);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Mask Cached -\\t%#llx\\n\", ndev->db_mask);\n\n\tu.v64 = ndev_db_read(ndev, mmio + ndev->self_reg->db_mask);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"Doorbell Mask -\\t\\t%#llx\\n\", u.v64);\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"\\nNTB Incoming XLAT:\\n\");\n\n\tu.v64 = ioread64(mmio + GEN4_IM23XBASE_OFFSET);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"IM23XBASE -\\t\\t%#018llx\\n\", u.v64);\n\n\tu.v64 = ioread64(mmio + GEN4_IM45XBASE_OFFSET);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"IM45XBASE -\\t\\t%#018llx\\n\", u.v64);\n\n\tu.v64 = ioread64(mmio + GEN4_IM23XLMT_OFFSET);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"IM23XLMT -\\t\\t\\t%#018llx\\n\", u.v64);\n\n\tu.v64 = ioread64(mmio + GEN4_IM45XLMT_OFFSET);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"IM45XLMT -\\t\\t\\t%#018llx\\n\", u.v64);\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"\\nNTB Statistics:\\n\");\n\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t \"\\nNTB Hardware Errors:\\n\");\n\n\tif (!pci_read_config_word(ndev->ntb.pdev,\n\t\t\t\t  GEN4_DEVSTS_OFFSET, &u.v16))\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t\"DEVSTS -\\t\\t%#06x\\n\", u.v16);\n\n\tu.v16 = ioread16(mmio + GEN4_LINK_STATUS_OFFSET);\n\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\"LNKSTS -\\t\\t%#06x\\n\", u.v16);\n\n\tif (!pci_read_config_dword(ndev->ntb.pdev,\n\t\t\t\t   GEN4_UNCERRSTS_OFFSET, &u.v32))\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"UNCERRSTS -\\t\\t%#06x\\n\", u.v32);\n\n\tif (!pci_read_config_dword(ndev->ntb.pdev,\n\t\t\t\t   GEN4_CORERRSTS_OFFSET, &u.v32))\n\t\toff += scnprintf(buf + off, buf_size - off,\n\t\t\t\t \"CORERRSTS -\\t\\t%#06x\\n\", u.v32);\n\n\tret = simple_read_from_buffer(ubuf, count, offp, buf, off);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int intel_ntb4_mw_set_trans(struct ntb_dev *ntb, int pidx, int idx,\n\t\t\t\t   dma_addr_t addr, resource_size_t size)\n{\n\tstruct intel_ntb_dev *ndev = ntb_ndev(ntb);\n\tunsigned long xlat_reg, limit_reg, idx_reg;\n\tunsigned short base_idx, reg_val16;\n\tresource_size_t bar_size, mw_size;\n\tvoid __iomem *mmio;\n\tu64 base, limit, reg_val;\n\tint bar;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tif (idx >= ndev->b2b_idx && !ndev->b2b_off)\n\t\tidx += 1;\n\n\tbar = ndev_mw_to_bar(ndev, idx);\n\tif (bar < 0)\n\t\treturn bar;\n\n\tbar_size = pci_resource_len(ndev->ntb.pdev, bar);\n\n\tif (idx == ndev->b2b_idx)\n\t\tmw_size = bar_size - ndev->b2b_off;\n\telse\n\t\tmw_size = bar_size;\n\n\tif (ndev->hwerr_flags & NTB_HWERR_BAR_ALIGN) {\n\t\t \n\t\tif (addr & (bar_size - 1))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (addr & (PAGE_SIZE - 1))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (size > mw_size)\n\t\treturn -EINVAL;\n\n\tmmio = ndev->self_mmio;\n\txlat_reg = ndev->xlat_reg->bar2_xlat + (idx * 0x10);\n\tlimit_reg = ndev->xlat_reg->bar2_limit + (idx * 0x10);\n\tbase = pci_resource_start(ndev->ntb.pdev, bar);\n\n\t \n\tif (limit_reg && size != mw_size) {\n\t\tlimit = base + size;\n\t\tbase_idx = __ilog2_u64(size);\n\t} else {\n\t\tlimit = base + mw_size;\n\t\tbase_idx = __ilog2_u64(mw_size);\n\t}\n\n\n\t \n\tiowrite64(addr, mmio + xlat_reg);\n\treg_val = ioread64(mmio + xlat_reg);\n\tif (reg_val != addr) {\n\t\tiowrite64(0, mmio + xlat_reg);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&ntb->pdev->dev, \"BAR %d IMXBASE: %#Lx\\n\", bar, reg_val);\n\n\t \n\tiowrite64(limit, mmio + limit_reg);\n\treg_val = ioread64(mmio + limit_reg);\n\tif (reg_val != limit) {\n\t\tiowrite64(base, mmio + limit_reg);\n\t\tiowrite64(0, mmio + xlat_reg);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&ntb->pdev->dev, \"BAR %d IMXLMT: %#Lx\\n\", bar, reg_val);\n\n\tif (ndev->hwerr_flags & NTB_HWERR_BAR_ALIGN) {\n\t\tidx_reg = ndev->xlat_reg->bar2_idx + (idx * 0x2);\n\t\tiowrite16(base_idx, mmio + idx_reg);\n\t\treg_val16 = ioread16(mmio + idx_reg);\n\t\tif (reg_val16 != base_idx) {\n\t\t\tiowrite64(base, mmio + limit_reg);\n\t\t\tiowrite64(0, mmio + xlat_reg);\n\t\t\tiowrite16(0, mmio + idx_reg);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(&ntb->pdev->dev, \"BAR %d IMBASEIDX: %#x\\n\", bar, reg_val16);\n\t}\n\n\n\treturn 0;\n}\n\nstatic int intel_ntb4_link_enable(struct ntb_dev *ntb,\n\t\tenum ntb_speed max_speed, enum ntb_width max_width)\n{\n\tstruct intel_ntb_dev *ndev;\n\tu32 ntb_ctl, ppd0;\n\tu16 lnkctl;\n\n\tndev = container_of(ntb, struct intel_ntb_dev, ntb);\n\n\tdev_dbg(&ntb->pdev->dev,\n\t\t\t\"Enabling link with max_speed %d max_width %d\\n\",\n\t\t\tmax_speed, max_width);\n\n\tif (max_speed != NTB_SPEED_AUTO)\n\t\tdev_dbg(&ntb->pdev->dev,\n\t\t\t\t\"ignoring max_speed %d\\n\", max_speed);\n\tif (max_width != NTB_WIDTH_AUTO)\n\t\tdev_dbg(&ntb->pdev->dev,\n\t\t\t\t\"ignoring max_width %d\\n\", max_width);\n\n\tif (!(ndev->hwerr_flags & NTB_HWERR_LTR_BAD)) {\n\t\tu32 ltr;\n\n\t\t \n\t\tltr = NTB_LTR_ACTIVE_REQMNT | NTB_LTR_ACTIVE_VAL | NTB_LTR_ACTIVE_LATSCALE;\n\t\t \n\t\tltr = (ltr << NTB_LTR_NS_SHIFT) | ltr;\n\t\tiowrite32(ltr, ndev->self_mmio + GEN4_LTR_ACTIVE_OFFSET);\n\n\t\t \n\t\tltr = NTB_LTR_IDLE_VAL | NTB_LTR_IDLE_LATSCALE | NTB_LTR_IDLE_REQMNT;\n\t\t \n\t\tltr = (ltr << NTB_LTR_NS_SHIFT) | ltr;\n\t\tiowrite32(ltr, ndev->self_mmio + GEN4_LTR_IDLE_OFFSET);\n\n\t\t \n\t\tiowrite8(NTB_LTR_SWSEL_ACTIVE, ndev->self_mmio + GEN4_LTR_SWSEL_OFFSET);\n\t}\n\n\tntb_ctl = NTB_CTL_E2I_BAR23_SNOOP | NTB_CTL_I2E_BAR23_SNOOP;\n\tntb_ctl |= NTB_CTL_E2I_BAR45_SNOOP | NTB_CTL_I2E_BAR45_SNOOP;\n\tiowrite32(ntb_ctl, ndev->self_mmio + ndev->reg->ntb_ctl);\n\n\tlnkctl = ioread16(ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\tlnkctl &= ~GEN4_LINK_CTRL_LINK_DISABLE;\n\tiowrite16(lnkctl, ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\n\t \n\tppd0 = ioread32(ndev->self_mmio + GEN4_PPD0_OFFSET);\n\tppd0 |= GEN4_PPD_LINKTRN;\n\tiowrite32(ppd0, ndev->self_mmio + GEN4_PPD0_OFFSET);\n\n\t \n\tppd0 = ioread32(ndev->self_mmio + GEN4_PPD0_OFFSET);\n\tif (!(ppd0 & GEN4_PPD_LINKTRN)) {\n\t\tdev_warn(&ntb->pdev->dev, \"Link is not training\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tndev->dev_up = 1;\n\n\treturn 0;\n}\n\nstatic int intel_ntb4_link_disable(struct ntb_dev *ntb)\n{\n\tstruct intel_ntb_dev *ndev;\n\tu32 ntb_cntl;\n\tu16 lnkctl;\n\n\tndev = container_of(ntb, struct intel_ntb_dev, ntb);\n\n\tdev_dbg(&ntb->pdev->dev, \"Disabling link\\n\");\n\n\t \n\tntb_cntl = ioread32(ndev->self_mmio + ndev->reg->ntb_ctl);\n\tntb_cntl &= ~(NTB_CTL_E2I_BAR23_SNOOP | NTB_CTL_I2E_BAR23_SNOOP);\n\tntb_cntl &= ~(NTB_CTL_E2I_BAR45_SNOOP | NTB_CTL_I2E_BAR45_SNOOP);\n\tiowrite32(ntb_cntl, ndev->self_mmio + ndev->reg->ntb_ctl);\n\n\tlnkctl = ioread16(ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\tlnkctl |= GEN4_LINK_CTRL_LINK_DISABLE;\n\tiowrite16(lnkctl, ndev->self_mmio + GEN4_LINK_CTRL_OFFSET);\n\n\t \n\tif (!(ndev->hwerr_flags & NTB_HWERR_LTR_BAD))\n\t\tiowrite8(NTB_LTR_SWSEL_IDLE, ndev->self_mmio + GEN4_LTR_SWSEL_OFFSET);\n\n\tndev->dev_up = 0;\n\n\treturn 0;\n}\n\nstatic int intel_ntb4_mw_get_align(struct ntb_dev *ntb, int pidx, int idx,\n\t\t\t\t   resource_size_t *addr_align,\n\t\t\t\t   resource_size_t *size_align,\n\t\t\t\t   resource_size_t *size_max)\n{\n\tstruct intel_ntb_dev *ndev = ntb_ndev(ntb);\n\tresource_size_t bar_size, mw_size;\n\tint bar;\n\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tif (idx >= ndev->b2b_idx && !ndev->b2b_off)\n\t\tidx += 1;\n\n\tbar = ndev_mw_to_bar(ndev, idx);\n\tif (bar < 0)\n\t\treturn bar;\n\n\tbar_size = pci_resource_len(ndev->ntb.pdev, bar);\n\n\tif (idx == ndev->b2b_idx)\n\t\tmw_size = bar_size - ndev->b2b_off;\n\telse\n\t\tmw_size = bar_size;\n\n\tif (addr_align) {\n\t\tif (ndev->hwerr_flags & NTB_HWERR_BAR_ALIGN)\n\t\t\t*addr_align = pci_resource_len(ndev->ntb.pdev, bar);\n\t\telse\n\t\t\t*addr_align = PAGE_SIZE;\n\t}\n\n\tif (size_align)\n\t\t*size_align = 1;\n\n\tif (size_max)\n\t\t*size_max = mw_size;\n\n\treturn 0;\n}\n\nconst struct ntb_dev_ops intel_ntb4_ops = {\n\t.mw_count\t\t= intel_ntb_mw_count,\n\t.mw_get_align\t\t= intel_ntb4_mw_get_align,\n\t.mw_set_trans\t\t= intel_ntb4_mw_set_trans,\n\t.peer_mw_count\t\t= intel_ntb_peer_mw_count,\n\t.peer_mw_get_addr\t= intel_ntb_peer_mw_get_addr,\n\t.link_is_up\t\t= intel_ntb_link_is_up,\n\t.link_enable\t\t= intel_ntb4_link_enable,\n\t.link_disable\t\t= intel_ntb4_link_disable,\n\t.db_valid_mask\t\t= intel_ntb_db_valid_mask,\n\t.db_vector_count\t= intel_ntb_db_vector_count,\n\t.db_vector_mask\t\t= intel_ntb_db_vector_mask,\n\t.db_read\t\t= intel_ntb3_db_read,\n\t.db_clear\t\t= intel_ntb3_db_clear,\n\t.db_set_mask\t\t= intel_ntb_db_set_mask,\n\t.db_clear_mask\t\t= intel_ntb_db_clear_mask,\n\t.peer_db_addr\t\t= intel_ntb3_peer_db_addr,\n\t.peer_db_set\t\t= intel_ntb3_peer_db_set,\n\t.spad_is_unsafe\t\t= intel_ntb_spad_is_unsafe,\n\t.spad_count\t\t= intel_ntb_spad_count,\n\t.spad_read\t\t= intel_ntb_spad_read,\n\t.spad_write\t\t= intel_ntb_spad_write,\n\t.peer_spad_addr\t\t= intel_ntb_peer_spad_addr,\n\t.peer_spad_read\t\t= intel_ntb_peer_spad_read,\n\t.peer_spad_write\t= intel_ntb_peer_spad_write,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}