{
  "module_name": "msi.c",
  "hash_id": "a313960c16bbc3d7120bed7397f2c19b57cb80cbb2192bd6871b19c1dbbb6168",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/msi.c",
  "human_readable_source": "\n\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/ntb.h>\n#include <linux/msi.h>\n#include <linux/pci.h>\n\nstruct ntb_msi {\n\tu64 base_addr;\n\tu64 end_addr;\n\n\tvoid (*desc_changed)(void *ctx);\n\n\tu32 __iomem *peer_mws[];\n};\n\n \nint ntb_msi_init(struct ntb_dev *ntb,\n\t\t void (*desc_changed)(void *ctx))\n{\n\tphys_addr_t mw_phys_addr;\n\tresource_size_t mw_size;\n\tint peer_widx;\n\tint peers;\n\tint ret;\n\tint i;\n\n\tpeers = ntb_peer_port_count(ntb);\n\tif (peers <= 0)\n\t\treturn -EINVAL;\n\n\tntb->msi = devm_kzalloc(&ntb->dev, struct_size(ntb->msi, peer_mws, peers),\n\t\t\t\tGFP_KERNEL);\n\tif (!ntb->msi)\n\t\treturn -ENOMEM;\n\n\tntb->msi->desc_changed = desc_changed;\n\n\tfor (i = 0; i < peers; i++) {\n\t\tpeer_widx = ntb_peer_mw_count(ntb) - 1 - i;\n\n\t\tret = ntb_peer_mw_get_addr(ntb, peer_widx, &mw_phys_addr,\n\t\t\t\t\t   &mw_size);\n\t\tif (ret)\n\t\t\tgoto unroll;\n\n\t\tntb->msi->peer_mws[i] = devm_ioremap(&ntb->dev, mw_phys_addr,\n\t\t\t\t\t\t     mw_size);\n\t\tif (!ntb->msi->peer_mws[i]) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unroll;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll:\n\tfor (i = 0; i < peers; i++)\n\t\tif (ntb->msi->peer_mws[i])\n\t\t\tdevm_iounmap(&ntb->dev, ntb->msi->peer_mws[i]);\n\n\tdevm_kfree(&ntb->dev, ntb->msi);\n\tntb->msi = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL(ntb_msi_init);\n\n \nint ntb_msi_setup_mws(struct ntb_dev *ntb)\n{\n\tstruct msi_desc *desc;\n\tu64 addr;\n\tint peer, peer_widx;\n\tresource_size_t addr_align, size_align, size_max;\n\tresource_size_t mw_size = SZ_32K;\n\tresource_size_t mw_min_size = mw_size;\n\tint i;\n\tint ret;\n\n\tif (!ntb->msi)\n\t\treturn -EINVAL;\n\n\tmsi_lock_descs(&ntb->pdev->dev);\n\tdesc = msi_first_desc(&ntb->pdev->dev, MSI_DESC_ASSOCIATED);\n\taddr = desc->msg.address_lo + ((uint64_t)desc->msg.address_hi << 32);\n\tmsi_unlock_descs(&ntb->pdev->dev);\n\n\tfor (peer = 0; peer < ntb_peer_port_count(ntb); peer++) {\n\t\tpeer_widx = ntb_peer_highest_mw_idx(ntb, peer);\n\t\tif (peer_widx < 0)\n\t\t\treturn peer_widx;\n\n\t\tret = ntb_mw_get_align(ntb, peer, peer_widx, &addr_align,\n\t\t\t\t       NULL, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taddr &= ~(addr_align - 1);\n\t}\n\n\tfor (peer = 0; peer < ntb_peer_port_count(ntb); peer++) {\n\t\tpeer_widx = ntb_peer_highest_mw_idx(ntb, peer);\n\t\tif (peer_widx < 0) {\n\t\t\tret = peer_widx;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tret = ntb_mw_get_align(ntb, peer, peer_widx, NULL,\n\t\t\t\t       &size_align, &size_max);\n\t\tif (ret)\n\t\t\tgoto error_out;\n\n\t\tmw_size = round_up(mw_size, size_align);\n\t\tmw_size = max(mw_size, size_max);\n\t\tif (mw_size < mw_min_size)\n\t\t\tmw_min_size = mw_size;\n\n\t\tret = ntb_mw_set_trans(ntb, peer, peer_widx,\n\t\t\t\t       addr, mw_size);\n\t\tif (ret)\n\t\t\tgoto error_out;\n\t}\n\n\tntb->msi->base_addr = addr;\n\tntb->msi->end_addr = addr + mw_min_size;\n\n\treturn 0;\n\nerror_out:\n\tfor (i = 0; i < peer; i++) {\n\t\tpeer_widx = ntb_peer_highest_mw_idx(ntb, peer);\n\t\tif (peer_widx < 0)\n\t\t\tcontinue;\n\n\t\tntb_mw_clear_trans(ntb, i, peer_widx);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ntb_msi_setup_mws);\n\n \nvoid ntb_msi_clear_mws(struct ntb_dev *ntb)\n{\n\tint peer;\n\tint peer_widx;\n\n\tfor (peer = 0; peer < ntb_peer_port_count(ntb); peer++) {\n\t\tpeer_widx = ntb_peer_highest_mw_idx(ntb, peer);\n\t\tif (peer_widx < 0)\n\t\t\tcontinue;\n\n\t\tntb_mw_clear_trans(ntb, peer, peer_widx);\n\t}\n}\nEXPORT_SYMBOL(ntb_msi_clear_mws);\n\nstruct ntb_msi_devres {\n\tstruct ntb_dev *ntb;\n\tstruct msi_desc *entry;\n\tstruct ntb_msi_desc *msi_desc;\n};\n\nstatic int ntb_msi_set_desc(struct ntb_dev *ntb, struct msi_desc *entry,\n\t\t\t    struct ntb_msi_desc *msi_desc)\n{\n\tu64 addr;\n\n\taddr = entry->msg.address_lo +\n\t\t((uint64_t)entry->msg.address_hi << 32);\n\n\tif (addr < ntb->msi->base_addr || addr >= ntb->msi->end_addr) {\n\t\tdev_warn_once(&ntb->dev,\n\t\t\t      \"IRQ %d: MSI Address not within the memory window (%llx, [%llx %llx])\\n\",\n\t\t\t      entry->irq, addr, ntb->msi->base_addr,\n\t\t\t      ntb->msi->end_addr);\n\t\treturn -EFAULT;\n\t}\n\n\tmsi_desc->addr_offset = addr - ntb->msi->base_addr;\n\tmsi_desc->data = entry->msg.data;\n\n\treturn 0;\n}\n\nstatic void ntb_msi_write_msg(struct msi_desc *entry, void *data)\n{\n\tstruct ntb_msi_devres *dr = data;\n\n\tWARN_ON(ntb_msi_set_desc(dr->ntb, entry, dr->msi_desc));\n\n\tif (dr->ntb->msi->desc_changed)\n\t\tdr->ntb->msi->desc_changed(dr->ntb->ctx);\n}\n\nstatic void ntbm_msi_callback_release(struct device *dev, void *res)\n{\n\tstruct ntb_msi_devres *dr = res;\n\n\tdr->entry->write_msi_msg = NULL;\n\tdr->entry->write_msi_msg_data = NULL;\n}\n\nstatic int ntbm_msi_setup_callback(struct ntb_dev *ntb, struct msi_desc *entry,\n\t\t\t\t   struct ntb_msi_desc *msi_desc)\n{\n\tstruct ntb_msi_devres *dr;\n\n\tdr = devres_alloc(ntbm_msi_callback_release,\n\t\t\t  sizeof(struct ntb_msi_devres), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->ntb = ntb;\n\tdr->entry = entry;\n\tdr->msi_desc = msi_desc;\n\n\tdevres_add(&ntb->dev, dr);\n\n\tdr->entry->write_msi_msg = ntb_msi_write_msg;\n\tdr->entry->write_msi_msg_data = dr;\n\n\treturn 0;\n}\n\n \nint ntbm_msi_request_threaded_irq(struct ntb_dev *ntb, irq_handler_t handler,\n\t\t\t\t  irq_handler_t thread_fn,\n\t\t\t\t  const char *name, void *dev_id,\n\t\t\t\t  struct ntb_msi_desc *msi_desc)\n{\n\tstruct device *dev = &ntb->pdev->dev;\n\tstruct msi_desc *entry;\n\tint ret;\n\n\tif (!ntb->msi)\n\t\treturn -EINVAL;\n\n\tmsi_lock_descs(dev);\n\tmsi_for_each_desc(entry, dev, MSI_DESC_ASSOCIATED) {\n\t\tif (irq_has_action(entry->irq))\n\t\t\tcontinue;\n\n\t\tret = devm_request_threaded_irq(&ntb->dev, entry->irq, handler,\n\t\t\t\t\t\tthread_fn, 0, name, dev_id);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (ntb_msi_set_desc(ntb, entry, msi_desc)) {\n\t\t\tdevm_free_irq(&ntb->dev, entry->irq, dev_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ntbm_msi_setup_callback(ntb, entry, msi_desc);\n\t\tif (ret) {\n\t\t\tdevm_free_irq(&ntb->dev, entry->irq, dev_id);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = entry->irq;\n\t\tgoto unlock;\n\t}\n\tret = -ENODEV;\n\nunlock:\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(ntbm_msi_request_threaded_irq);\n\nstatic int ntbm_msi_callback_match(struct device *dev, void *res, void *data)\n{\n\tstruct ntb_dev *ntb = dev_ntb(dev);\n\tstruct ntb_msi_devres *dr = res;\n\n\treturn dr->ntb == ntb && dr->entry == data;\n}\n\n \nvoid ntbm_msi_free_irq(struct ntb_dev *ntb, unsigned int irq, void *dev_id)\n{\n\tstruct msi_desc *entry = irq_get_msi_desc(irq);\n\n\tentry->write_msi_msg = NULL;\n\tentry->write_msi_msg_data = NULL;\n\n\tWARN_ON(devres_destroy(&ntb->dev, ntbm_msi_callback_release,\n\t\t\t       ntbm_msi_callback_match, entry));\n\n\tdevm_free_irq(&ntb->dev, irq, dev_id);\n}\nEXPORT_SYMBOL(ntbm_msi_free_irq);\n\n \nint ntb_msi_peer_trigger(struct ntb_dev *ntb, int peer,\n\t\t\t struct ntb_msi_desc *desc)\n{\n\tint idx;\n\n\tif (!ntb->msi)\n\t\treturn -EINVAL;\n\n\tidx = desc->addr_offset / sizeof(*ntb->msi->peer_mws[peer]);\n\n\tiowrite32(desc->data, &ntb->msi->peer_mws[peer][idx]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ntb_msi_peer_trigger);\n\n \nint ntb_msi_peer_addr(struct ntb_dev *ntb, int peer,\n\t\t      struct ntb_msi_desc *desc,\n\t\t      phys_addr_t *msi_addr)\n{\n\tint peer_widx = ntb_peer_mw_count(ntb) - 1 - peer;\n\tphys_addr_t mw_phys_addr;\n\tint ret;\n\n\tret = ntb_peer_mw_get_addr(ntb, peer_widx, &mw_phys_addr, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msi_addr)\n\t\t*msi_addr = mw_phys_addr + desc->addr_offset;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ntb_msi_peer_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}