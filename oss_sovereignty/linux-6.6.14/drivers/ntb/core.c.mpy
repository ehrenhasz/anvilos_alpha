{
  "module_name": "core.c",
  "hash_id": "294d4ef6640178752be071ef69865b11f737c79866a491316d2c8925a8f8d29d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ntb/core.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <linux/ntb.h>\n#include <linux/pci.h>\n\n#define DRIVER_NAME\t\t\t\"ntb\"\n#define DRIVER_DESCRIPTION\t\t\"PCIe NTB Driver Framework\"\n\n#define DRIVER_VERSION\t\t\t\"1.0\"\n#define DRIVER_RELDATE\t\t\t\"24 March 2015\"\n#define DRIVER_AUTHOR\t\t\t\"Allen Hubbe <Allen.Hubbe@emc.com>\"\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESCRIPTION);\n\nstatic struct bus_type ntb_bus;\nstatic void ntb_dev_release(struct device *dev);\n\nint __ntb_register_client(struct ntb_client *client, struct module *mod,\n\t\t\t  const char *mod_name)\n{\n\tif (!client)\n\t\treturn -EINVAL;\n\tif (!ntb_client_ops_is_valid(&client->ops))\n\t\treturn -EINVAL;\n\n\tmemset(&client->drv, 0, sizeof(client->drv));\n\tclient->drv.bus = &ntb_bus;\n\tclient->drv.name = mod_name;\n\tclient->drv.owner = mod;\n\n\treturn driver_register(&client->drv);\n}\nEXPORT_SYMBOL(__ntb_register_client);\n\nvoid ntb_unregister_client(struct ntb_client *client)\n{\n\tdriver_unregister(&client->drv);\n}\nEXPORT_SYMBOL(ntb_unregister_client);\n\nint ntb_register_device(struct ntb_dev *ntb)\n{\n\tif (!ntb)\n\t\treturn -EINVAL;\n\tif (!ntb->pdev)\n\t\treturn -EINVAL;\n\tif (!ntb->ops)\n\t\treturn -EINVAL;\n\tif (!ntb_dev_ops_is_valid(ntb->ops))\n\t\treturn -EINVAL;\n\n\tinit_completion(&ntb->released);\n\n\tntb->dev.bus = &ntb_bus;\n\tntb->dev.parent = &ntb->pdev->dev;\n\tntb->dev.release = ntb_dev_release;\n\tdev_set_name(&ntb->dev, \"%s\", pci_name(ntb->pdev));\n\n\tntb->ctx = NULL;\n\tntb->ctx_ops = NULL;\n\tspin_lock_init(&ntb->ctx_lock);\n\n\treturn device_register(&ntb->dev);\n}\nEXPORT_SYMBOL(ntb_register_device);\n\nvoid ntb_unregister_device(struct ntb_dev *ntb)\n{\n\tdevice_unregister(&ntb->dev);\n\twait_for_completion(&ntb->released);\n}\nEXPORT_SYMBOL(ntb_unregister_device);\n\nint ntb_set_ctx(struct ntb_dev *ntb, void *ctx,\n\t\tconst struct ntb_ctx_ops *ctx_ops)\n{\n\tunsigned long irqflags;\n\n\tif (!ntb_ctx_ops_is_valid(ctx_ops))\n\t\treturn -EINVAL;\n\tif (ntb->ctx_ops)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ntb->ctx_lock, irqflags);\n\t{\n\t\tntb->ctx = ctx;\n\t\tntb->ctx_ops = ctx_ops;\n\t}\n\tspin_unlock_irqrestore(&ntb->ctx_lock, irqflags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ntb_set_ctx);\n\nvoid ntb_clear_ctx(struct ntb_dev *ntb)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&ntb->ctx_lock, irqflags);\n\t{\n\t\tntb->ctx_ops = NULL;\n\t\tntb->ctx = NULL;\n\t}\n\tspin_unlock_irqrestore(&ntb->ctx_lock, irqflags);\n}\nEXPORT_SYMBOL(ntb_clear_ctx);\n\nvoid ntb_link_event(struct ntb_dev *ntb)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&ntb->ctx_lock, irqflags);\n\t{\n\t\tif (ntb->ctx_ops && ntb->ctx_ops->link_event)\n\t\t\tntb->ctx_ops->link_event(ntb->ctx);\n\t}\n\tspin_unlock_irqrestore(&ntb->ctx_lock, irqflags);\n}\nEXPORT_SYMBOL(ntb_link_event);\n\nvoid ntb_db_event(struct ntb_dev *ntb, int vector)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&ntb->ctx_lock, irqflags);\n\t{\n\t\tif (ntb->ctx_ops && ntb->ctx_ops->db_event)\n\t\t\tntb->ctx_ops->db_event(ntb->ctx, vector);\n\t}\n\tspin_unlock_irqrestore(&ntb->ctx_lock, irqflags);\n}\nEXPORT_SYMBOL(ntb_db_event);\n\nvoid ntb_msg_event(struct ntb_dev *ntb)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&ntb->ctx_lock, irqflags);\n\t{\n\t\tif (ntb->ctx_ops && ntb->ctx_ops->msg_event)\n\t\t\tntb->ctx_ops->msg_event(ntb->ctx);\n\t}\n\tspin_unlock_irqrestore(&ntb->ctx_lock, irqflags);\n}\nEXPORT_SYMBOL(ntb_msg_event);\n\nint ntb_default_port_number(struct ntb_dev *ntb)\n{\n\tswitch (ntb->topo) {\n\tcase NTB_TOPO_PRI:\n\tcase NTB_TOPO_B2B_USD:\n\t\treturn NTB_PORT_PRI_USD;\n\tcase NTB_TOPO_SEC:\n\tcase NTB_TOPO_B2B_DSD:\n\t\treturn NTB_PORT_SEC_DSD;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(ntb_default_port_number);\n\nint ntb_default_peer_port_count(struct ntb_dev *ntb)\n{\n\treturn NTB_DEF_PEER_CNT;\n}\nEXPORT_SYMBOL(ntb_default_peer_port_count);\n\nint ntb_default_peer_port_number(struct ntb_dev *ntb, int pidx)\n{\n\tif (pidx != NTB_DEF_PEER_IDX)\n\t\treturn -EINVAL;\n\n\tswitch (ntb->topo) {\n\tcase NTB_TOPO_PRI:\n\tcase NTB_TOPO_B2B_USD:\n\t\treturn NTB_PORT_SEC_DSD;\n\tcase NTB_TOPO_SEC:\n\tcase NTB_TOPO_B2B_DSD:\n\t\treturn NTB_PORT_PRI_USD;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(ntb_default_peer_port_number);\n\nint ntb_default_peer_port_idx(struct ntb_dev *ntb, int port)\n{\n\tint peer_port = ntb_default_peer_port_number(ntb, NTB_DEF_PEER_IDX);\n\n\tif (peer_port == -EINVAL || port != peer_port)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ntb_default_peer_port_idx);\n\nstatic int ntb_probe(struct device *dev)\n{\n\tstruct ntb_dev *ntb;\n\tstruct ntb_client *client;\n\tint rc;\n\n\tget_device(dev);\n\tntb = dev_ntb(dev);\n\tclient = drv_ntb_client(dev->driver);\n\n\trc = client->ops.probe(client, ntb);\n\tif (rc)\n\t\tput_device(dev);\n\n\treturn rc;\n}\n\nstatic void ntb_remove(struct device *dev)\n{\n\tstruct ntb_dev *ntb;\n\tstruct ntb_client *client;\n\n\tif (dev->driver) {\n\t\tntb = dev_ntb(dev);\n\t\tclient = drv_ntb_client(dev->driver);\n\n\t\tclient->ops.remove(client, ntb);\n\t\tput_device(dev);\n\t}\n}\n\nstatic void ntb_dev_release(struct device *dev)\n{\n\tstruct ntb_dev *ntb = dev_ntb(dev);\n\n\tcomplete(&ntb->released);\n}\n\nstatic struct bus_type ntb_bus = {\n\t.name = \"ntb\",\n\t.probe = ntb_probe,\n\t.remove = ntb_remove,\n};\n\nstatic int __init ntb_driver_init(void)\n{\n\treturn bus_register(&ntb_bus);\n}\nmodule_init(ntb_driver_init);\n\nstatic void __exit ntb_driver_exit(void)\n{\n\tbus_unregister(&ntb_bus);\n}\nmodule_exit(ntb_driver_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}