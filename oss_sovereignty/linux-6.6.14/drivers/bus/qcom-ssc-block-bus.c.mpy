{
  "module_name": "qcom-ssc-block-bus.c",
  "hash_id": "bb877fe4ef7cf9168c0b78730f624ef373fca6d65f4d073d28cf9a8265b5d26b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/qcom-ssc-block-bus.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_clock.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define AXI_HALTREQ_REG\t\t\t0x0\n#define AXI_HALTACK_REG\t\t\t0x4\n#define AXI_IDLE_REG\t\t\t0x8\n\n#define SSCAON_CONFIG0_CLAMP_EN_OVRD\t\tBIT(4)\n#define SSCAON_CONFIG0_CLAMP_EN_OVRD_VAL\tBIT(5)\n\nstatic const char *const qcom_ssc_block_pd_names[] = {\n\t\"ssc_cx\",\n\t\"ssc_mx\"\n};\n\nstruct qcom_ssc_block_bus_data {\n\tconst char *const *pd_names;\n\tstruct device *pds[ARRAY_SIZE(qcom_ssc_block_pd_names)];\n\tchar __iomem *reg_mpm_sscaon_config0;\n\tchar __iomem *reg_mpm_sscaon_config1;\n\tstruct regmap *halt_map;\n\tstruct clk *xo_clk;\n\tstruct clk *aggre2_clk;\n\tstruct clk *gcc_im_sleep_clk;\n\tstruct clk *aggre2_north_clk;\n\tstruct clk *ssc_xo_clk;\n\tstruct clk *ssc_ahbs_clk;\n\tstruct reset_control *ssc_bcr;\n\tstruct reset_control *ssc_reset;\n\tu32 ssc_axi_halt;\n\tint num_pds;\n};\n\nstatic void reg32_set_bits(char __iomem *reg, u32 value)\n{\n\tu32 tmp = ioread32(reg);\n\n\tiowrite32(tmp | value, reg);\n}\n\nstatic void reg32_clear_bits(char __iomem *reg, u32 value)\n{\n\tu32 tmp = ioread32(reg);\n\n\tiowrite32(tmp & (~value), reg);\n}\n\nstatic int qcom_ssc_block_bus_init(struct device *dev)\n{\n\tint ret;\n\n\tstruct qcom_ssc_block_bus_data *data = dev_get_drvdata(dev);\n\n\tret = clk_prepare_enable(data->xo_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling xo_clk: %d\\n\", ret);\n\t\tgoto err_xo_clk;\n\t}\n\n\tret = clk_prepare_enable(data->aggre2_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling aggre2_clk: %d\\n\", ret);\n\t\tgoto err_aggre2_clk;\n\t}\n\n\tret = clk_prepare_enable(data->gcc_im_sleep_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling gcc_im_sleep_clk: %d\\n\", ret);\n\t\tgoto err_gcc_im_sleep_clk;\n\t}\n\n\t \n\treg32_clear_bits(data->reg_mpm_sscaon_config0,\n\t\t\t SSCAON_CONFIG0_CLAMP_EN_OVRD | SSCAON_CONFIG0_CLAMP_EN_OVRD_VAL);\n\t \n\treg32_clear_bits(data->reg_mpm_sscaon_config1, BIT(31));\n\n\tret = clk_prepare_enable(data->aggre2_north_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling aggre2_north_clk: %d\\n\", ret);\n\t\tgoto err_aggre2_north_clk;\n\t}\n\n\tret = reset_control_deassert(data->ssc_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"error deasserting ssc_reset: %d\\n\", ret);\n\t\tgoto err_ssc_reset;\n\t}\n\n\tret = reset_control_deassert(data->ssc_bcr);\n\tif (ret) {\n\t\tdev_err(dev, \"error deasserting ssc_bcr: %d\\n\", ret);\n\t\tgoto err_ssc_bcr;\n\t}\n\n\tregmap_write(data->halt_map, data->ssc_axi_halt + AXI_HALTREQ_REG, 0);\n\n\tret = clk_prepare_enable(data->ssc_xo_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error deasserting ssc_xo_clk: %d\\n\", ret);\n\t\tgoto err_ssc_xo_clk;\n\t}\n\n\tret = clk_prepare_enable(data->ssc_ahbs_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error deasserting ssc_ahbs_clk: %d\\n\", ret);\n\t\tgoto err_ssc_ahbs_clk;\n\t}\n\n\treturn 0;\n\nerr_ssc_ahbs_clk:\n\tclk_disable(data->ssc_xo_clk);\n\nerr_ssc_xo_clk:\n\tregmap_write(data->halt_map, data->ssc_axi_halt + AXI_HALTREQ_REG, 1);\n\n\treset_control_assert(data->ssc_bcr);\n\nerr_ssc_bcr:\n\treset_control_assert(data->ssc_reset);\n\nerr_ssc_reset:\n\tclk_disable(data->aggre2_north_clk);\n\nerr_aggre2_north_clk:\n\treg32_set_bits(data->reg_mpm_sscaon_config0, BIT(4) | BIT(5));\n\treg32_set_bits(data->reg_mpm_sscaon_config1, BIT(31));\n\n\tclk_disable(data->gcc_im_sleep_clk);\n\nerr_gcc_im_sleep_clk:\n\tclk_disable(data->aggre2_clk);\n\nerr_aggre2_clk:\n\tclk_disable(data->xo_clk);\n\nerr_xo_clk:\n\treturn ret;\n}\n\nstatic void qcom_ssc_block_bus_deinit(struct device *dev)\n{\n\tint ret;\n\n\tstruct qcom_ssc_block_bus_data *data = dev_get_drvdata(dev);\n\n\tclk_disable(data->ssc_xo_clk);\n\tclk_disable(data->ssc_ahbs_clk);\n\n\tret = reset_control_assert(data->ssc_bcr);\n\tif (ret)\n\t\tdev_err(dev, \"error asserting ssc_bcr: %d\\n\", ret);\n\n\tregmap_write(data->halt_map, data->ssc_axi_halt + AXI_HALTREQ_REG, 1);\n\n\treg32_set_bits(data->reg_mpm_sscaon_config1, BIT(31));\n\treg32_set_bits(data->reg_mpm_sscaon_config0, BIT(4) | BIT(5));\n\n\tret = reset_control_assert(data->ssc_reset);\n\tif (ret)\n\t\tdev_err(dev, \"error asserting ssc_reset: %d\\n\", ret);\n\n\tclk_disable(data->gcc_im_sleep_clk);\n\n\tclk_disable(data->aggre2_north_clk);\n\n\tclk_disable(data->aggre2_clk);\n\tclk_disable(data->xo_clk);\n}\n\nstatic int qcom_ssc_block_bus_pds_attach(struct device *dev, struct device **pds,\n\t\t\t\t\t const char *const *pd_names, size_t num_pds)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tpds[i] = dev_pm_domain_attach_by_name(dev, pd_names[i]);\n\t\tif (IS_ERR_OR_NULL(pds[i])) {\n\t\t\tret = PTR_ERR(pds[i]) ? : -ENODATA;\n\t\t\tgoto unroll_attach;\n\t\t}\n\t}\n\n\treturn num_pds;\n\nunroll_attach:\n\tfor (i--; i >= 0; i--)\n\t\tdev_pm_domain_detach(pds[i], false);\n\n\treturn ret;\n};\n\nstatic void qcom_ssc_block_bus_pds_detach(struct device *dev, struct device **pds, size_t num_pds)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pds; i++)\n\t\tdev_pm_domain_detach(pds[i], false);\n}\n\nstatic int qcom_ssc_block_bus_pds_enable(struct device **pds, size_t num_pds)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], INT_MAX);\n\t\tret = pm_runtime_get_sync(pds[i]);\n\t\tif (ret < 0)\n\t\t\tgoto unroll_pd_votes;\n\t}\n\n\treturn 0;\n\nunroll_pd_votes:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n\n\treturn ret;\n};\n\nstatic void qcom_ssc_block_bus_pds_disable(struct device **pds, size_t num_pds)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n}\n\nstatic int qcom_ssc_block_bus_probe(struct platform_device *pdev)\n{\n\tstruct qcom_ssc_block_bus_data *data;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct of_phandle_args halt_args;\n\tstruct resource *res;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->pd_names = qcom_ssc_block_pd_names;\n\tdata->num_pds = ARRAY_SIZE(qcom_ssc_block_pd_names);\n\n\t \n\tret = qcom_ssc_block_bus_pds_attach(&pdev->dev, data->pds, data->pd_names, data->num_pds);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"error when attaching power domains\\n\");\n\n\tret = qcom_ssc_block_bus_pds_enable(data->pds, data->num_pds);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"error when enabling power domains\\n\");\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mpm_sscaon_config0\");\n\tdata->reg_mpm_sscaon_config0 = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(data->reg_mpm_sscaon_config0))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->reg_mpm_sscaon_config0),\n\t\t\t\t     \"Failed to ioremap mpm_sscaon_config0\\n\");\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mpm_sscaon_config1\");\n\tdata->reg_mpm_sscaon_config1 = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(data->reg_mpm_sscaon_config1))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->reg_mpm_sscaon_config1),\n\t\t\t\t     \"Failed to ioremap mpm_sscaon_config1\\n\");\n\n\t \n\tdata->ssc_bcr = devm_reset_control_get_exclusive(&pdev->dev, \"ssc_bcr\");\n\tif (IS_ERR(data->ssc_bcr))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ssc_bcr),\n\t\t\t\t     \"Failed to acquire reset: scc_bcr\\n\");\n\n\tdata->ssc_reset = devm_reset_control_get_exclusive(&pdev->dev, \"ssc_reset\");\n\tif (IS_ERR(data->ssc_reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ssc_reset),\n\t\t\t\t     \"Failed to acquire reset: ssc_reset:\\n\");\n\n\t \n\tdata->xo_clk = devm_clk_get(&pdev->dev, \"xo\");\n\tif (IS_ERR(data->xo_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->xo_clk),\n\t\t\t\t     \"Failed to get clock: xo\\n\");\n\n\tdata->aggre2_clk = devm_clk_get(&pdev->dev, \"aggre2\");\n\tif (IS_ERR(data->aggre2_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->aggre2_clk),\n\t\t\t\t     \"Failed to get clock: aggre2\\n\");\n\n\tdata->gcc_im_sleep_clk = devm_clk_get(&pdev->dev, \"gcc_im_sleep\");\n\tif (IS_ERR(data->gcc_im_sleep_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->gcc_im_sleep_clk),\n\t\t\t\t     \"Failed to get clock: gcc_im_sleep\\n\");\n\n\tdata->aggre2_north_clk = devm_clk_get(&pdev->dev, \"aggre2_north\");\n\tif (IS_ERR(data->aggre2_north_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->aggre2_north_clk),\n\t\t\t\t     \"Failed to get clock: aggre2_north\\n\");\n\n\tdata->ssc_xo_clk = devm_clk_get(&pdev->dev, \"ssc_xo\");\n\tif (IS_ERR(data->ssc_xo_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ssc_xo_clk),\n\t\t\t\t     \"Failed to get clock: ssc_xo\\n\");\n\n\tdata->ssc_ahbs_clk = devm_clk_get(&pdev->dev, \"ssc_ahbs\");\n\tif (IS_ERR(data->ssc_ahbs_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(data->ssc_ahbs_clk),\n\t\t\t\t     \"Failed to get clock: ssc_ahbs\\n\");\n\n\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node, \"qcom,halt-regs\", 1, 0,\n\t\t\t\t\t       &halt_args);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to parse qcom,halt-regs\\n\");\n\n\tdata->halt_map = syscon_node_to_regmap(halt_args.np);\n\tof_node_put(halt_args.np);\n\tif (IS_ERR(data->halt_map))\n\t\treturn PTR_ERR(data->halt_map);\n\n\tdata->ssc_axi_halt = halt_args.args[0];\n\n\tqcom_ssc_block_bus_init(&pdev->dev);\n\n\tof_platform_populate(np, NULL, NULL, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic int qcom_ssc_block_bus_remove(struct platform_device *pdev)\n{\n\tstruct qcom_ssc_block_bus_data *data = platform_get_drvdata(pdev);\n\n\tqcom_ssc_block_bus_deinit(&pdev->dev);\n\n\tiounmap(data->reg_mpm_sscaon_config0);\n\tiounmap(data->reg_mpm_sscaon_config1);\n\n\tqcom_ssc_block_bus_pds_disable(data->pds, data->num_pds);\n\tqcom_ssc_block_bus_pds_detach(&pdev->dev, data->pds, data->num_pds);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_clk_destroy(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_ssc_block_bus_of_match[] = {\n\t{ .compatible = \"qcom,ssc-block-bus\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, qcom_ssc_block_bus_of_match);\n\nstatic struct platform_driver qcom_ssc_block_bus_driver = {\n\t.probe = qcom_ssc_block_bus_probe,\n\t.remove = qcom_ssc_block_bus_remove,\n\t.driver = {\n\t\t.name = \"qcom-ssc-block-bus\",\n\t\t.of_match_table = qcom_ssc_block_bus_of_match,\n\t},\n};\n\nmodule_platform_driver(qcom_ssc_block_bus_driver);\n\nMODULE_DESCRIPTION(\"A driver for handling the init sequence needed for accessing the SSC block on (some) qcom SoCs over AHB\");\nMODULE_AUTHOR(\"Michael Srba <Michael.Srba@seznam.cz>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}