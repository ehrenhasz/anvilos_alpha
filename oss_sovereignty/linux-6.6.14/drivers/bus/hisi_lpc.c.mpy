{
  "module_name": "hisi_lpc.c",
  "hash_id": "a1846dbebbb89c0015cd5bc0a4ede6d734e7347eb234c57f6d054f2bd849082a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/hisi_lpc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/console.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/logic_pio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/serial_8250.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"hisi-lpc\"\n\n \n#define FG_INCRADDR_LPC\t\t0x02\n\nstruct lpc_cycle_para {\n\tunsigned int opflags;\n\tunsigned int csize;  \n};\n\nstruct hisi_lpc_dev {\n\tspinlock_t cycle_lock;\n\tvoid __iomem  *membase;\n\tstruct logic_pio_hwaddr *io_host;\n};\n\n \n#define LPC_MAX_DWIDTH\t4\n\n#define LPC_REG_STARTUP_SIGNAL\t\t0x00\n#define LPC_REG_STARTUP_SIGNAL_START\tBIT(0)\n#define LPC_REG_OP_STATUS\t\t0x04\n#define LPC_REG_OP_STATUS_IDLE\t\tBIT(0)\n#define LPC_REG_OP_STATUS_FINISHED\tBIT(1)\n#define LPC_REG_OP_LEN\t\t\t0x10  \n#define LPC_REG_CMD\t\t\t0x14\n#define LPC_REG_CMD_OP\t\t\tBIT(0)  \n#define LPC_REG_CMD_SAMEADDR\t\tBIT(3)\n#define LPC_REG_ADDR\t\t\t0x20  \n#define LPC_REG_WDATA\t\t\t0x24  \n#define LPC_REG_RDATA\t\t\t0x28  \n\n \n#define LPC_NSEC_PERWAIT\t100\n\n \n#define LPC_MAX_WAITCNT\t\t1300\n\n \n#define LPC_PEROP_WAITCNT\t100\n\nstatic int wait_lpc_idle(void __iomem *mbase, unsigned int waitcnt)\n{\n\tu32 status;\n\n\tdo {\n\t\tstatus = readl(mbase + LPC_REG_OP_STATUS);\n\t\tif (status & LPC_REG_OP_STATUS_IDLE)\n\t\t\treturn (status & LPC_REG_OP_STATUS_FINISHED) ? 0 : -EIO;\n\t\tndelay(LPC_NSEC_PERWAIT);\n\t} while (--waitcnt);\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int hisi_lpc_target_in(struct hisi_lpc_dev *lpcdev,\n\t\t\t      struct lpc_cycle_para *para, unsigned long addr,\n\t\t\t      unsigned char *buf, unsigned long opcnt)\n{\n\tunsigned int cmd_word;\n\tunsigned int waitcnt;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!buf || !opcnt || !para || !para->csize || !lpcdev)\n\t\treturn -EINVAL;\n\n\tcmd_word = 0;  \n\twaitcnt = LPC_PEROP_WAITCNT;\n\tif (!(para->opflags & FG_INCRADDR_LPC)) {\n\t\tcmd_word |= LPC_REG_CMD_SAMEADDR;\n\t\twaitcnt = LPC_MAX_WAITCNT;\n\t}\n\n\t \n\tspin_lock_irqsave(&lpcdev->cycle_lock, flags);\n\n\twritel_relaxed(opcnt, lpcdev->membase + LPC_REG_OP_LEN);\n\twritel_relaxed(cmd_word, lpcdev->membase + LPC_REG_CMD);\n\twritel_relaxed(addr, lpcdev->membase + LPC_REG_ADDR);\n\n\twritel(LPC_REG_STARTUP_SIGNAL_START,\n\t       lpcdev->membase + LPC_REG_STARTUP_SIGNAL);\n\n\t \n\tret = wait_lpc_idle(lpcdev->membase, waitcnt);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&lpcdev->cycle_lock, flags);\n\t\treturn ret;\n\t}\n\n\treadsb(lpcdev->membase + LPC_REG_RDATA, buf, opcnt);\n\n\tspin_unlock_irqrestore(&lpcdev->cycle_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int hisi_lpc_target_out(struct hisi_lpc_dev *lpcdev,\n\t\t\t       struct lpc_cycle_para *para, unsigned long addr,\n\t\t\t       const unsigned char *buf, unsigned long opcnt)\n{\n\tunsigned int waitcnt;\n\tunsigned long flags;\n\tu32 cmd_word;\n\tint ret;\n\n\tif (!buf || !opcnt || !para || !lpcdev)\n\t\treturn -EINVAL;\n\n\t \n\tcmd_word = LPC_REG_CMD_OP;  \n\twaitcnt = LPC_PEROP_WAITCNT;\n\tif (!(para->opflags & FG_INCRADDR_LPC)) {\n\t\tcmd_word |= LPC_REG_CMD_SAMEADDR;\n\t\twaitcnt = LPC_MAX_WAITCNT;\n\t}\n\n\tspin_lock_irqsave(&lpcdev->cycle_lock, flags);\n\n\twritel_relaxed(opcnt, lpcdev->membase + LPC_REG_OP_LEN);\n\twritel_relaxed(cmd_word, lpcdev->membase + LPC_REG_CMD);\n\twritel_relaxed(addr, lpcdev->membase + LPC_REG_ADDR);\n\n\twritesb(lpcdev->membase + LPC_REG_WDATA, buf, opcnt);\n\n\twritel(LPC_REG_STARTUP_SIGNAL_START,\n\t       lpcdev->membase + LPC_REG_STARTUP_SIGNAL);\n\n\t \n\tret = wait_lpc_idle(lpcdev->membase, waitcnt);\n\n\tspin_unlock_irqrestore(&lpcdev->cycle_lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned long hisi_lpc_pio_to_addr(struct hisi_lpc_dev *lpcdev,\n\t\t\t\t\t  unsigned long pio)\n{\n\treturn pio - lpcdev->io_host->io_start + lpcdev->io_host->hw_start;\n}\n\n \nstatic u32 hisi_lpc_comm_in(void *hostdata, unsigned long pio, size_t dwidth)\n{\n\tstruct hisi_lpc_dev *lpcdev = hostdata;\n\tstruct lpc_cycle_para iopara;\n\tunsigned long addr;\n\t__le32 rd_data = 0;\n\tint ret;\n\n\tif (!lpcdev || !dwidth || dwidth > LPC_MAX_DWIDTH)\n\t\treturn ~0;\n\n\taddr = hisi_lpc_pio_to_addr(lpcdev, pio);\n\n\tiopara.opflags = FG_INCRADDR_LPC;\n\tiopara.csize = dwidth;\n\n\tret = hisi_lpc_target_in(lpcdev, &iopara, addr,\n\t\t\t\t (unsigned char *)&rd_data, dwidth);\n\tif (ret)\n\t\treturn ~0;\n\n\treturn le32_to_cpu(rd_data);\n}\n\n \nstatic void hisi_lpc_comm_out(void *hostdata, unsigned long pio,\n\t\t\t      u32 val, size_t dwidth)\n{\n\tstruct hisi_lpc_dev *lpcdev = hostdata;\n\tstruct lpc_cycle_para iopara;\n\tconst unsigned char *buf;\n\tunsigned long addr;\n\t__le32 _val = cpu_to_le32(val);\n\n\tif (!lpcdev || !dwidth || dwidth > LPC_MAX_DWIDTH)\n\t\treturn;\n\n\tbuf = (const unsigned char *)&_val;\n\taddr = hisi_lpc_pio_to_addr(lpcdev, pio);\n\n\tiopara.opflags = FG_INCRADDR_LPC;\n\tiopara.csize = dwidth;\n\n\thisi_lpc_target_out(lpcdev, &iopara, addr, buf, dwidth);\n}\n\n \nstatic u32 hisi_lpc_comm_ins(void *hostdata, unsigned long pio, void *buffer,\n\t\t\t     size_t dwidth, unsigned int count)\n{\n\tstruct hisi_lpc_dev *lpcdev = hostdata;\n\tunsigned char *buf = buffer;\n\tstruct lpc_cycle_para iopara;\n\tunsigned long addr;\n\n\tif (!lpcdev || !buf || !count || !dwidth || dwidth > LPC_MAX_DWIDTH)\n\t\treturn -EINVAL;\n\n\tiopara.opflags = 0;\n\tif (dwidth > 1)\n\t\tiopara.opflags |= FG_INCRADDR_LPC;\n\tiopara.csize = dwidth;\n\n\taddr = hisi_lpc_pio_to_addr(lpcdev, pio);\n\n\tdo {\n\t\tint ret;\n\n\t\tret = hisi_lpc_target_in(lpcdev, &iopara, addr, buf, dwidth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbuf += dwidth;\n\t} while (--count);\n\n\treturn 0;\n}\n\n \nstatic void hisi_lpc_comm_outs(void *hostdata, unsigned long pio,\n\t\t\t       const void *buffer, size_t dwidth,\n\t\t\t       unsigned int count)\n{\n\tstruct hisi_lpc_dev *lpcdev = hostdata;\n\tstruct lpc_cycle_para iopara;\n\tconst unsigned char *buf = buffer;\n\tunsigned long addr;\n\n\tif (!lpcdev || !buf || !count || !dwidth || dwidth > LPC_MAX_DWIDTH)\n\t\treturn;\n\n\tiopara.opflags = 0;\n\tif (dwidth > 1)\n\t\tiopara.opflags |= FG_INCRADDR_LPC;\n\tiopara.csize = dwidth;\n\n\taddr = hisi_lpc_pio_to_addr(lpcdev, pio);\n\tdo {\n\t\tif (hisi_lpc_target_out(lpcdev, &iopara, addr, buf, dwidth))\n\t\t\tbreak;\n\t\tbuf += dwidth;\n\t} while (--count);\n}\n\nstatic const struct logic_pio_host_ops hisi_lpc_ops = {\n\t.in = hisi_lpc_comm_in,\n\t.out = hisi_lpc_comm_out,\n\t.ins = hisi_lpc_comm_ins,\n\t.outs = hisi_lpc_comm_outs,\n};\n\n#ifdef CONFIG_ACPI\nstatic int hisi_lpc_acpi_xlat_io_res(struct acpi_device *adev,\n\t\t\t\t     struct acpi_device *host,\n\t\t\t\t     struct resource *res)\n{\n\tunsigned long sys_port;\n\tresource_size_t len = resource_size(res);\n\n\tsys_port = logic_pio_trans_hwaddr(acpi_fwnode_handle(host), res->start, len);\n\tif (sys_port == ~0UL)\n\t\treturn -EFAULT;\n\n\tres->start = sys_port;\n\tres->end = sys_port + len;\n\n\treturn 0;\n}\n\n \nstatic void hisi_lpc_acpi_fixup_child_resource(struct device *hostdev,\n\t\t\t\t\t       struct resource *r)\n{\n\tif (r->end != 0x3fff)\n\t\treturn;\n\n\tif (r->start == 0xe4)\n\t\tr->end = 0xe4 + 0x04 - 1;\n\telse if (r->start == 0x2f8)\n\t\tr->end = 0x2f8 + 0x08 - 1;\n\telse\n\t\tdev_warn(hostdev, \"unrecognised resource %pR to fixup, ignoring\\n\",\n\t\t\t r);\n}\n\n \nstatic int hisi_lpc_acpi_set_io_res(struct acpi_device *adev,\n\t\t\t\t    struct device *hostdev,\n\t\t\t\t    const struct resource **res, int *num_res)\n{\n\tstruct acpi_device *host = to_acpi_device(adev->dev.parent);\n\tstruct resource_entry *rentry;\n\tLIST_HEAD(resource_list);\n\tstruct resource *resources;\n\tint count;\n\tint i;\n\n\tif (!adev->status.present) {\n\t\tdev_dbg(&adev->dev, \"device is not present\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (acpi_device_enumerated(adev)) {\n\t\tdev_dbg(&adev->dev, \"has been enumerated\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tcount = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\n\tif (count <= 0) {\n\t\tdev_dbg(&adev->dev, \"failed to get resources\\n\");\n\t\treturn count ? count : -EIO;\n\t}\n\n\tresources = devm_kcalloc(hostdev, count, sizeof(*resources),\n\t\t\t\t GFP_KERNEL);\n\tif (!resources) {\n\t\tdev_warn(hostdev, \"could not allocate memory for %d resources\\n\",\n\t\t\t count);\n\t\tacpi_dev_free_resource_list(&resource_list);\n\t\treturn -ENOMEM;\n\t}\n\tcount = 0;\n\tlist_for_each_entry(rentry, &resource_list, node) {\n\t\tresources[count] = *rentry->res;\n\t\thisi_lpc_acpi_fixup_child_resource(hostdev, &resources[count]);\n\t\tcount++;\n\t}\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint ret;\n\n\t\tif (!(resources[i].flags & IORESOURCE_IO))\n\t\t\tcontinue;\n\t\tret = hisi_lpc_acpi_xlat_io_res(adev, host, &resources[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&adev->dev, \"translate IO range %pR failed (%d)\\n\",\n\t\t\t\t&resources[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t*res = resources;\n\t*num_res = count;\n\n\treturn 0;\n}\n\nstatic int hisi_lpc_acpi_remove_subdev(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int hisi_lpc_acpi_clear_enumerated(struct acpi_device *adev, void *not_used)\n{\n\tacpi_device_clear_enumerated(adev);\n\treturn 0;\n}\n\nstruct hisi_lpc_acpi_cell {\n\tconst char *hid;\n\tconst struct platform_device_info *pdevinfo;\n};\n\nstatic void hisi_lpc_acpi_remove(struct device *hostdev)\n{\n\tdevice_for_each_child(hostdev, NULL, hisi_lpc_acpi_remove_subdev);\n\tacpi_dev_for_each_child(ACPI_COMPANION(hostdev),\n\t\t\t\thisi_lpc_acpi_clear_enumerated, NULL);\n}\n\nstatic int hisi_lpc_acpi_add_child(struct acpi_device *child, void *data)\n{\n\tconst char *hid = acpi_device_hid(child);\n\tstruct device *hostdev = data;\n\tconst struct hisi_lpc_acpi_cell *cell;\n\tstruct platform_device *pdev;\n\tconst struct resource *res;\n\tbool found = false;\n\tint num_res;\n\tint ret;\n\n\tret = hisi_lpc_acpi_set_io_res(child, hostdev, &res, &num_res);\n\tif (ret) {\n\t\tdev_warn(hostdev, \"set resource fail (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcell = (struct hisi_lpc_acpi_cell []){\n\t\t \n\t\t{\n\t\t\t.hid = \"IPI0001\",\n\t\t\t.pdevinfo = (struct platform_device_info []) {\n\t\t\t\t{\n\t\t\t\t\t.parent = hostdev,\n\t\t\t\t\t.fwnode = acpi_fwnode_handle(child),\n\t\t\t\t\t.name = \"hisi-lpc-ipmi\",\n\t\t\t\t\t.id = PLATFORM_DEVID_AUTO,\n\t\t\t\t\t.res = res,\n\t\t\t\t\t.num_res = num_res,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t \n\t\t{\n\t\t\t.hid = \"HISI1031\",\n\t\t\t.pdevinfo = (struct platform_device_info []) {\n\t\t\t\t{\n\t\t\t\t\t.parent = hostdev,\n\t\t\t\t\t.fwnode = acpi_fwnode_handle(child),\n\t\t\t\t\t.name = \"serial8250\",\n\t\t\t\t\t.id = PLATFORM_DEVID_AUTO,\n\t\t\t\t\t.res = res,\n\t\t\t\t\t.num_res = num_res,\n\t\t\t\t\t.data = (struct plat_serial8250_port []) {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t.iobase = res->start,\n\t\t\t\t\t\t\t.uartclk = 1843200,\n\t\t\t\t\t\t\t.iotype = UPIO_PORT,\n\t\t\t\t\t\t\t.flags = UPF_BOOT_AUTOCONF,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{}\n\t\t\t\t\t},\n\t\t\t\t\t.size_data =  2 * sizeof(struct plat_serial8250_port),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{}\n\t};\n\n\tfor (; cell && cell->hid; cell++) {\n\t\tif (!strcmp(cell->hid, hid)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tdev_warn(hostdev,\n\t\t\t \"could not find cell for child device (%s), discarding\\n\",\n\t\t\t hid);\n\t\treturn 0;\n\t}\n\n\tpdev = platform_device_register_full(cell->pdevinfo);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tacpi_device_set_enumerated(child);\n\treturn 0;\n}\n\n \nstatic int hisi_lpc_acpi_probe(struct device *hostdev)\n{\n\tint ret;\n\n\t \n\tret = acpi_dev_for_each_child(ACPI_COMPANION(hostdev),\n\t\t\t\t      hisi_lpc_acpi_add_child, hostdev);\n\tif (ret)\n\t\thisi_lpc_acpi_remove(hostdev);\n\n\treturn ret;\n}\n#else\nstatic int hisi_lpc_acpi_probe(struct device *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic void hisi_lpc_acpi_remove(struct device *hostdev)\n{\n}\n#endif \n\n \nstatic int hisi_lpc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct logic_pio_hwaddr *range;\n\tstruct hisi_lpc_dev *lpcdev;\n\tresource_size_t io_end;\n\tint ret;\n\n\tlpcdev = devm_kzalloc(dev, sizeof(*lpcdev), GFP_KERNEL);\n\tif (!lpcdev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&lpcdev->cycle_lock);\n\n\tlpcdev->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lpcdev->membase))\n\t\treturn PTR_ERR(lpcdev->membase);\n\n\trange = devm_kzalloc(dev, sizeof(*range), GFP_KERNEL);\n\tif (!range)\n\t\treturn -ENOMEM;\n\n\trange->fwnode = dev_fwnode(dev);\n\trange->flags = LOGIC_PIO_INDIRECT;\n\trange->size = PIO_INDIRECT_SIZE;\n\trange->hostdata = lpcdev;\n\trange->ops = &hisi_lpc_ops;\n\tlpcdev->io_host = range;\n\n\tret = logic_pio_register_range(range);\n\tif (ret) {\n\t\tdev_err(dev, \"register IO range failed (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (is_acpi_device_node(range->fwnode))\n\t\tret = hisi_lpc_acpi_probe(dev);\n\telse\n\t\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret) {\n\t\tlogic_pio_unregister_range(range);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, lpcdev);\n\n\tio_end = lpcdev->io_host->io_start + lpcdev->io_host->size;\n\tdev_info(dev, \"registered range [%pa - %pa]\\n\",\n\t\t &lpcdev->io_host->io_start, &io_end);\n\n\treturn ret;\n}\n\nstatic int hisi_lpc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hisi_lpc_dev *lpcdev = dev_get_drvdata(dev);\n\tstruct logic_pio_hwaddr *range = lpcdev->io_host;\n\n\tif (is_acpi_device_node(range->fwnode))\n\t\thisi_lpc_acpi_remove(dev);\n\telse\n\t\tof_platform_depopulate(dev);\n\n\tlogic_pio_unregister_range(range);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id hisi_lpc_of_match[] = {\n\t{ .compatible = \"hisilicon,hip06-lpc\", },\n\t{ .compatible = \"hisilicon,hip07-lpc\", },\n\t{}\n};\n\nstatic const struct acpi_device_id hisi_lpc_acpi_match[] = {\n\t{\"HISI0191\"},\n\t{}\n};\n\nstatic struct platform_driver hisi_lpc_driver = {\n\t.driver = {\n\t\t.name           = DRV_NAME,\n\t\t.of_match_table = hisi_lpc_of_match,\n\t\t.acpi_match_table = hisi_lpc_acpi_match,\n\t},\n\t.probe = hisi_lpc_probe,\n\t.remove = hisi_lpc_remove,\n};\nbuiltin_platform_driver(hisi_lpc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}