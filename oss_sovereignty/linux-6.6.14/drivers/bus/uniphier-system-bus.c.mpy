{
  "module_name": "uniphier-system-bus.c",
  "hash_id": "8e10a9910000245a2853ee69af047a7a9ae84ebb07d9488083896175f0307105",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/uniphier-system-bus.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n \n#define UNIPHIER_SBC_BASE\t0x100\t \n#define    UNIPHIER_SBC_BASE_BE\t\tBIT(0)\t \n#define UNIPHIER_SBC_CTRL0\t0x200\t \n#define UNIPHIER_SBC_CTRL1\t0x204\t \n#define UNIPHIER_SBC_CTRL2\t0x208\t \n#define UNIPHIER_SBC_CTRL3\t0x20c\t \n#define UNIPHIER_SBC_CTRL4\t0x300\t \n\n#define UNIPHIER_SBC_STRIDE\t0x10\t \n#define UNIPHIER_SBC_NR_BANKS\t8\t \n#define UNIPHIER_SBC_BASE_DUMMY\t0xffffffff\t \n\nstruct uniphier_system_bus_bank {\n\tu32 base;\n\tu32 end;\n};\n\nstruct uniphier_system_bus_priv {\n\tstruct device *dev;\n\tvoid __iomem *membase;\n\tstruct uniphier_system_bus_bank bank[UNIPHIER_SBC_NR_BANKS];\n};\n\nstatic int uniphier_system_bus_add_bank(struct uniphier_system_bus_priv *priv,\n\t\t\t\t\tint bank, u32 addr, u64 paddr, u32 size)\n{\n\tu64 end, mask;\n\n\tdev_dbg(priv->dev,\n\t\t\"range found: bank = %d, addr = %08x, paddr = %08llx, size = %08x\\n\",\n\t\tbank, addr, paddr, size);\n\n\tif (bank >= ARRAY_SIZE(priv->bank)) {\n\t\tdev_err(priv->dev, \"unsupported bank number %d\\n\", bank);\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->bank[bank].base || priv->bank[bank].end) {\n\t\tdev_err(priv->dev,\n\t\t\t\"range for bank %d has already been specified\\n\", bank);\n\t\treturn -EINVAL;\n\t}\n\n\tif (paddr > U32_MAX) {\n\t\tdev_err(priv->dev, \"base address %llx is too high\\n\", paddr);\n\t\treturn -EINVAL;\n\t}\n\n\tend = paddr + size;\n\n\tif (addr > paddr) {\n\t\tdev_err(priv->dev,\n\t\t\t\"base %08x cannot be mapped to %08llx of parent\\n\",\n\t\t\taddr, paddr);\n\t\treturn -EINVAL;\n\t}\n\tpaddr -= addr;\n\n\tpaddr = round_down(paddr, 0x00020000);\n\tend = round_up(end, 0x00020000);\n\n\tif (end > U32_MAX) {\n\t\tdev_err(priv->dev, \"end address %08llx is too high\\n\", end);\n\t\treturn -EINVAL;\n\t}\n\tmask = paddr ^ (end - 1);\n\tmask = roundup_pow_of_two(mask);\n\n\tpaddr = round_down(paddr, mask);\n\tend = round_up(end, mask);\n\n\tpriv->bank[bank].base = paddr;\n\tpriv->bank[bank].end = end;\n\n\tdev_dbg(priv->dev, \"range added: bank = %d, addr = %08x, end = %08x\\n\",\n\t\tbank, priv->bank[bank].base, priv->bank[bank].end);\n\n\treturn 0;\n}\n\nstatic int uniphier_system_bus_check_overlap(\n\t\t\t\tconst struct uniphier_system_bus_priv *priv)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->bank); i++) {\n\t\tfor (j = i + 1; j < ARRAY_SIZE(priv->bank); j++) {\n\t\t\tif (priv->bank[i].end > priv->bank[j].base &&\n\t\t\t    priv->bank[i].base < priv->bank[j].end) {\n\t\t\t\tdev_err(priv->dev,\n\t\t\t\t\t\"region overlap between bank%d and bank%d\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void uniphier_system_bus_check_boot_swap(\n\t\t\t\t\tstruct uniphier_system_bus_priv *priv)\n{\n\tvoid __iomem *base_reg = priv->membase + UNIPHIER_SBC_BASE;\n\tint is_swapped;\n\n\tis_swapped = !(readl(base_reg) & UNIPHIER_SBC_BASE_BE);\n\n\tdev_dbg(priv->dev, \"Boot Swap: %s\\n\", is_swapped ? \"on\" : \"off\");\n\n\t \n\tif (is_swapped)\n\t\tswap(priv->bank[0], priv->bank[1]);\n}\n\nstatic void uniphier_system_bus_set_reg(\n\t\t\t\tconst struct uniphier_system_bus_priv *priv)\n{\n\tvoid __iomem *base_reg = priv->membase + UNIPHIER_SBC_BASE;\n\tu32 base, end, mask, val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->bank); i++) {\n\t\tbase = priv->bank[i].base;\n\t\tend = priv->bank[i].end;\n\n\t\tif (base == end) {\n\t\t\t \n\t\t\tif (i < 2)\n\t\t\t\tval = UNIPHIER_SBC_BASE_DUMMY;\n\t\t\telse\n\t\t\t\tval = 0;\n\t\t} else {\n\t\t\tmask = base ^ (end - 1);\n\n\t\t\tval = base & 0xfffe0000;\n\t\t\tval |= (~mask >> 16) & 0xfffe;\n\t\t\tval |= UNIPHIER_SBC_BASE_BE;\n\t\t}\n\t\tdev_dbg(priv->dev, \"SBC_BASE[%d] = 0x%08x\\n\", i, val);\n\n\t\twritel(val, base_reg + UNIPHIER_SBC_STRIDE * i);\n\t}\n}\n\nstatic int uniphier_system_bus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_system_bus_priv *priv;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->membase))\n\t\treturn PTR_ERR(priv->membase);\n\n\tpriv->dev = dev;\n\n\tret = of_range_parser_init(&parser, dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_of_range(&parser, &range) {\n\t\tif (range.cpu_addr == OF_BAD_ADDR)\n\t\t\treturn -EINVAL;\n\t\tret = uniphier_system_bus_add_bank(priv,\n\t\t\t\t\t\t   upper_32_bits(range.bus_addr),\n\t\t\t\t\t\t   lower_32_bits(range.bus_addr),\n\t\t\t\t\t\t   range.cpu_addr, range.size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = uniphier_system_bus_check_overlap(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tuniphier_system_bus_check_boot_swap(priv);\n\n\tuniphier_system_bus_set_reg(priv);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\treturn of_platform_default_populate(dev->of_node, NULL, dev);\n}\n\nstatic int __maybe_unused uniphier_system_bus_resume(struct device *dev)\n{\n\tuniphier_system_bus_set_reg(dev_get_drvdata(dev));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_system_bus_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, uniphier_system_bus_resume)\n};\n\nstatic const struct of_device_id uniphier_system_bus_match[] = {\n\t{ .compatible = \"socionext,uniphier-system-bus\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_system_bus_match);\n\nstatic struct platform_driver uniphier_system_bus_driver = {\n\t.probe\t\t= uniphier_system_bus_probe,\n\t.driver = {\n\t\t.name\t= \"uniphier-system-bus\",\n\t\t.of_match_table = uniphier_system_bus_match,\n\t\t.pm = &uniphier_system_bus_pm_ops,\n\t},\n};\nmodule_platform_driver(uniphier_system_bus_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier System Bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}