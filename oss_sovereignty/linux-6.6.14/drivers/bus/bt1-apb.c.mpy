{
  "module_name": "bt1-apb.c",
  "hash_id": "ea340711ddefbe0b9ac17294f52bafe051e687915dcae793493bfb7a765c9a42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/bt1-apb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/atomic.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/nmi.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/time64.h>\n#include <linux/clk.h>\n#include <linux/sysfs.h>\n\n#define APB_EHB_ISR\t\t\t0x00\n#define APB_EHB_ISR_PENDING\t\tBIT(0)\n#define APB_EHB_ISR_MASK\t\tBIT(1)\n#define APB_EHB_ADDR\t\t\t0x04\n#define APB_EHB_TIMEOUT\t\t\t0x08\n\n#define APB_EHB_TIMEOUT_MIN\t\t0x000003FFU\n#define APB_EHB_TIMEOUT_MAX\t\t0xFFFFFFFFU\n\n \nstruct bt1_apb {\n\tstruct device *dev;\n\n\tstruct regmap *regs;\n\tvoid __iomem *res;\n\tint irq;\n\n\tunsigned long rate;\n\tstruct clk *pclk;\n\n\tstruct reset_control *prst;\n\n\tatomic_t count;\n};\n\nstatic const struct regmap_config bt1_apb_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = APB_EHB_TIMEOUT,\n\t.fast_io = true\n};\n\nstatic inline unsigned long bt1_apb_n_to_timeout_us(struct bt1_apb *apb, u32 n)\n{\n\tu64 timeout = (u64)n * USEC_PER_SEC;\n\n\tdo_div(timeout, apb->rate);\n\n\treturn timeout;\n\n}\n\nstatic inline unsigned long bt1_apb_timeout_to_n_us(struct bt1_apb *apb,\n\t\t\t\t\t\t    unsigned long timeout)\n{\n\tu64 n = (u64)timeout * apb->rate;\n\n\tdo_div(n, USEC_PER_SEC);\n\n\treturn n;\n\n}\n\nstatic irqreturn_t bt1_apb_isr(int irq, void *data)\n{\n\tstruct bt1_apb *apb = data;\n\tu32 addr = 0;\n\n\tregmap_read(apb->regs, APB_EHB_ADDR, &addr);\n\n\tdev_crit_ratelimited(apb->dev,\n\t\t\"APB-bus fault %d: Slave access timeout at 0x%08x\\n\",\n\t\tatomic_inc_return(&apb->count),\n\t\taddr);\n\n\t \n\ttrigger_all_cpu_backtrace();\n\n\tregmap_update_bits(apb->regs, APB_EHB_ISR, APB_EHB_ISR_PENDING, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bt1_apb_clear_data(void *data)\n{\n\tstruct bt1_apb *apb = data;\n\tstruct platform_device *pdev = to_platform_device(apb->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic struct bt1_apb *bt1_apb_create_data(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bt1_apb *apb;\n\tint ret;\n\n\tapb = devm_kzalloc(dev, sizeof(*apb), GFP_KERNEL);\n\tif (!apb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = devm_add_action(dev, bt1_apb_clear_data, apb);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't add APB EHB data clear action\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tapb->dev = dev;\n\tatomic_set(&apb->count, 0);\n\tplatform_set_drvdata(pdev, apb);\n\n\treturn apb;\n}\n\nstatic int bt1_apb_request_regs(struct bt1_apb *apb)\n{\n\tstruct platform_device *pdev = to_platform_device(apb->dev);\n\tvoid __iomem *regs;\n\n\tregs = devm_platform_ioremap_resource_byname(pdev, \"ehb\");\n\tif (IS_ERR(regs)) {\n\t\tdev_err(apb->dev, \"Couldn't map APB EHB registers\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\n\tapb->regs = devm_regmap_init_mmio(apb->dev, regs, &bt1_apb_regmap_cfg);\n\tif (IS_ERR(apb->regs)) {\n\t\tdev_err(apb->dev, \"Couldn't create APB EHB regmap\\n\");\n\t\treturn PTR_ERR(apb->regs);\n\t}\n\n\tapb->res = devm_platform_ioremap_resource_byname(pdev, \"nodev\");\n\tif (IS_ERR(apb->res))\n\t\tdev_err(apb->dev, \"Couldn't map reserved region\\n\");\n\n\treturn PTR_ERR_OR_ZERO(apb->res);\n}\n\nstatic int bt1_apb_request_rst(struct bt1_apb *apb)\n{\n\tint ret;\n\n\tapb->prst = devm_reset_control_get_optional_exclusive(apb->dev, \"prst\");\n\tif (IS_ERR(apb->prst))\n\t\treturn dev_err_probe(apb->dev, PTR_ERR(apb->prst),\n\t\t\t\t     \"Couldn't get reset control line\\n\");\n\n\tret = reset_control_deassert(apb->prst);\n\tif (ret)\n\t\tdev_err(apb->dev, \"Failed to deassert the reset line\\n\");\n\n\treturn ret;\n}\n\nstatic void bt1_apb_disable_clk(void *data)\n{\n\tstruct bt1_apb *apb = data;\n\n\tclk_disable_unprepare(apb->pclk);\n}\n\nstatic int bt1_apb_request_clk(struct bt1_apb *apb)\n{\n\tint ret;\n\n\tapb->pclk = devm_clk_get(apb->dev, \"pclk\");\n\tif (IS_ERR(apb->pclk))\n\t\treturn dev_err_probe(apb->dev, PTR_ERR(apb->pclk),\n\t\t\t\t     \"Couldn't get APB clock descriptor\\n\");\n\n\tret = clk_prepare_enable(apb->pclk);\n\tif (ret) {\n\t\tdev_err(apb->dev, \"Couldn't enable the APB clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(apb->dev, bt1_apb_disable_clk, apb);\n\tif (ret) {\n\t\tdev_err(apb->dev, \"Can't add APB EHB clocks disable action\\n\");\n\t\treturn ret;\n\t}\n\n\tapb->rate = clk_get_rate(apb->pclk);\n\tif (!apb->rate) {\n\t\tdev_err(apb->dev, \"Invalid clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void bt1_apb_clear_irq(void *data)\n{\n\tstruct bt1_apb *apb = data;\n\n\tregmap_update_bits(apb->regs, APB_EHB_ISR, APB_EHB_ISR_MASK, 0);\n}\n\nstatic int bt1_apb_request_irq(struct bt1_apb *apb)\n{\n\tstruct platform_device *pdev = to_platform_device(apb->dev);\n\tint ret;\n\n\tapb->irq = platform_get_irq(pdev, 0);\n\tif (apb->irq < 0)\n\t\treturn apb->irq;\n\n\tret = devm_request_irq(apb->dev, apb->irq, bt1_apb_isr, IRQF_SHARED,\n\t\t\t       \"bt1-apb\", apb);\n\tif (ret) {\n\t\tdev_err(apb->dev, \"Couldn't request APB EHB IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action(apb->dev, bt1_apb_clear_irq, apb);\n\tif (ret) {\n\t\tdev_err(apb->dev, \"Can't add APB EHB IRQs clear action\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_update_bits(apb->regs, APB_EHB_ISR,\n\t\t\t   APB_EHB_ISR_PENDING | APB_EHB_ISR_MASK,\n\t\t\t   APB_EHB_ISR_MASK);\n\n\treturn 0;\n}\n\nstatic ssize_t count_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct bt1_apb *apb = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&apb->count));\n}\nstatic DEVICE_ATTR_RO(count);\n\nstatic ssize_t timeout_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct bt1_apb *apb = dev_get_drvdata(dev);\n\tunsigned long timeout;\n\tint ret;\n\tu32 n;\n\n\tret = regmap_read(apb->regs, APB_EHB_TIMEOUT, &n);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = bt1_apb_n_to_timeout_us(apb, n);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%lu\\n\", timeout);\n}\n\nstatic ssize_t timeout_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct bt1_apb *apb = dev_get_drvdata(dev);\n\tunsigned long timeout;\n\tint ret;\n\tu32 n;\n\n\tif (kstrtoul(buf, 0, &timeout) < 0)\n\t\treturn -EINVAL;\n\n\tn = bt1_apb_timeout_to_n_us(apb, timeout);\n\tn = clamp(n, APB_EHB_TIMEOUT_MIN, APB_EHB_TIMEOUT_MAX);\n\n\tret = regmap_write(apb->regs, APB_EHB_TIMEOUT, n);\n\n\treturn ret ?: count;\n}\nstatic DEVICE_ATTR_RW(timeout);\n\nstatic ssize_t inject_error_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"Error injection: nodev irq\\n\");\n}\n\nstatic ssize_t inject_error_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *data, size_t count)\n{\n\tstruct bt1_apb *apb = dev_get_drvdata(dev);\n\n\t \n\tif (sysfs_streq(data, \"nodev\"))\n\t\treadl(apb->res);\n\telse if (sysfs_streq(data, \"irq\"))\n\t\tregmap_update_bits(apb->regs, APB_EHB_ISR, APB_EHB_ISR_PENDING,\n\t\t\t\t   APB_EHB_ISR_PENDING);\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(inject_error);\n\nstatic struct attribute *bt1_apb_sysfs_attrs[] = {\n\t&dev_attr_count.attr,\n\t&dev_attr_timeout.attr,\n\t&dev_attr_inject_error.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(bt1_apb_sysfs);\n\nstatic void bt1_apb_remove_sysfs(void *data)\n{\n\tstruct bt1_apb *apb = data;\n\n\tdevice_remove_groups(apb->dev, bt1_apb_sysfs_groups);\n}\n\nstatic int bt1_apb_init_sysfs(struct bt1_apb *apb)\n{\n\tint ret;\n\n\tret = device_add_groups(apb->dev, bt1_apb_sysfs_groups);\n\tif (ret) {\n\t\tdev_err(apb->dev, \"Failed to create EHB APB sysfs nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(apb->dev, bt1_apb_remove_sysfs, apb);\n\tif (ret)\n\t\tdev_err(apb->dev, \"Can't add APB EHB sysfs remove action\\n\");\n\n\treturn ret;\n}\n\nstatic int bt1_apb_probe(struct platform_device *pdev)\n{\n\tstruct bt1_apb *apb;\n\tint ret;\n\n\tapb = bt1_apb_create_data(pdev);\n\tif (IS_ERR(apb))\n\t\treturn PTR_ERR(apb);\n\n\tret = bt1_apb_request_regs(apb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_apb_request_rst(apb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_apb_request_clk(apb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_apb_request_irq(apb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_apb_init_sysfs(apb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bt1_apb_of_match[] = {\n\t{ .compatible = \"baikal,bt1-apb\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bt1_apb_of_match);\n\nstatic struct platform_driver bt1_apb_driver = {\n\t.probe = bt1_apb_probe,\n\t.driver = {\n\t\t.name = \"bt1-apb\",\n\t\t.of_match_table = bt1_apb_of_match\n\t}\n};\nmodule_platform_driver(bt1_apb_driver);\n\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 APB-bus driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}