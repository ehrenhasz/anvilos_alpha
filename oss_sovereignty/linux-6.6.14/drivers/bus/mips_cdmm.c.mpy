{
  "module_name": "mips_cdmm.c",
  "hash_id": "f976ecc2198c2e4b06f2f0ffcaa86e7045b901064deaa49e12c712e3a23f0918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mips_cdmm.c",
  "human_readable_source": " \n\n#include <linux/atomic.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <asm/cdmm.h>\n#include <asm/hazards.h>\n#include <asm/mipsregs.h>\n\n \n#define CDMM_ACSR_DEVTYPE_SHIFT\t24\n#define CDMM_ACSR_DEVTYPE\t(255ul << CDMM_ACSR_DEVTYPE_SHIFT)\n#define CDMM_ACSR_DEVSIZE_SHIFT\t16\n#define CDMM_ACSR_DEVSIZE\t(31ul << CDMM_ACSR_DEVSIZE_SHIFT)\n#define CDMM_ACSR_DEVREV_SHIFT\t12\n#define CDMM_ACSR_DEVREV\t(15ul << CDMM_ACSR_DEVREV_SHIFT)\n#define CDMM_ACSR_UW\t\t(1ul << 3)\n#define CDMM_ACSR_UR\t\t(1ul << 2)\n#define CDMM_ACSR_SW\t\t(1ul << 1)\n#define CDMM_ACSR_SR\t\t(1ul << 0)\n\n \n#define CDMM_DRB_SIZE\t\t64\n\n#define to_mips_cdmm_driver(d)\tcontainer_of(d, struct mips_cdmm_driver, drv)\n\n \nstatic phys_addr_t mips_cdmm_default_base;\n\n \n\nstatic const struct mips_cdmm_device_id *\nmips_cdmm_lookup(const struct mips_cdmm_device_id *table,\n\t\t struct mips_cdmm_device *dev)\n{\n\tint ret = 0;\n\n\tfor (; table->type; ++table) {\n\t\tret = (dev->type == table->type);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret ? table : NULL;\n}\n\nstatic int mips_cdmm_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\n\tstruct mips_cdmm_driver *cdrv = to_mips_cdmm_driver(drv);\n\n\treturn mips_cdmm_lookup(cdrv->id_table, cdev) != NULL;\n}\n\nstatic int mips_cdmm_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\n\tint retval = 0;\n\n\tretval = add_uevent_var(env, \"CDMM_CPU=%u\", cdev->cpu);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = add_uevent_var(env, \"CDMM_TYPE=0x%02x\", cdev->type);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = add_uevent_var(env, \"CDMM_REV=%u\", cdev->rev);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = add_uevent_var(env, \"MODALIAS=mipscdmm:t%02X\", cdev->type);\n\treturn retval;\n}\n\n \n\n#define CDMM_ATTR(name, fmt, arg...)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *_dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mips_cdmm_device *dev = to_mips_cdmm_device(_dev);\t\\\n\treturn sprintf(buf, fmt, arg);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name);\n\nCDMM_ATTR(cpu, \"%u\\n\", dev->cpu);\nCDMM_ATTR(type, \"0x%02x\\n\", dev->type);\nCDMM_ATTR(revision, \"%u\\n\", dev->rev);\nCDMM_ATTR(modalias, \"mipscdmm:t%02X\\n\", dev->type);\nCDMM_ATTR(resource, \"\\t%016llx\\t%016llx\\t%016lx\\n\",\n\t  (unsigned long long)dev->res.start,\n\t  (unsigned long long)dev->res.end,\n\t  dev->res.flags);\n\nstatic struct attribute *mips_cdmm_dev_attrs[] = {\n\t&dev_attr_cpu.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_resource.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mips_cdmm_dev);\n\nstruct bus_type mips_cdmm_bustype = {\n\t.name\t\t= \"cdmm\",\n\t.dev_groups\t= mips_cdmm_dev_groups,\n\t.match\t\t= mips_cdmm_match,\n\t.uevent\t\t= mips_cdmm_uevent,\n};\nEXPORT_SYMBOL_GPL(mips_cdmm_bustype);\n\n \n\n \nstruct mips_cdmm_work_dev {\n\tvoid\t\t\t*fn;\n\tstruct mips_cdmm_device *dev;\n};\n\n \nstatic long mips_cdmm_void_work(void *data)\n{\n\tstruct mips_cdmm_work_dev *work = data;\n\tvoid (*fn)(struct mips_cdmm_device *) = work->fn;\n\n\tfn(work->dev);\n\treturn 0;\n}\n\n \nstatic long mips_cdmm_int_work(void *data)\n{\n\tstruct mips_cdmm_work_dev *work = data;\n\tint (*fn)(struct mips_cdmm_device *) = work->fn;\n\n\treturn fn(work->dev);\n}\n\n#define _BUILD_RET_void\n#define _BUILD_RET_int\treturn\n\n \n#define BUILD_PERCPU_HELPER(_ret, _name)\t\t\t\t\\\nstatic _ret mips_cdmm_##_name(struct device *dev)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\t\\\n\tstruct mips_cdmm_driver *cdrv = to_mips_cdmm_driver(dev->driver); \\\n\tstruct mips_cdmm_work_dev work = {\t\t\t\t\\\n\t\t.fn\t= cdrv->_name,\t\t\t\t\t\\\n\t\t.dev\t= cdev,\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_BUILD_RET_##_ret work_on_cpu(cdev->cpu,\t\t\t\\\n\t\t\t\t      mips_cdmm_##_ret##_work, &work);\t\\\n}\n\n \nBUILD_PERCPU_HELPER(int, probe)      \nBUILD_PERCPU_HELPER(int, remove)     \nBUILD_PERCPU_HELPER(void, shutdown)  \n\n\n \n\n \nint mips_cdmm_driver_register(struct mips_cdmm_driver *drv)\n{\n\tdrv->drv.bus = &mips_cdmm_bustype;\n\n\tif (drv->probe)\n\t\tdrv->drv.probe = mips_cdmm_probe;\n\tif (drv->remove)\n\t\tdrv->drv.remove = mips_cdmm_remove;\n\tif (drv->shutdown)\n\t\tdrv->drv.shutdown = mips_cdmm_shutdown;\n\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(mips_cdmm_driver_register);\n\n \nvoid mips_cdmm_driver_unregister(struct mips_cdmm_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(mips_cdmm_driver_unregister);\n\n\n \n\n \nstruct mips_cdmm_bus {\n\tphys_addr_t\t phys;\n\tvoid __iomem\t*regs;\n\tunsigned int\t drbs;\n\tunsigned int\t drbs_reserved;\n\tbool\t\t discovered;\n\tbool\t\t offline;\n};\n\nstatic struct mips_cdmm_bus mips_cdmm_boot_bus;\nstatic DEFINE_PER_CPU(struct mips_cdmm_bus *, mips_cdmm_buses);\nstatic atomic_t mips_cdmm_next_id = ATOMIC_INIT(-1);\n\n \nstatic struct mips_cdmm_bus *mips_cdmm_get_bus(void)\n{\n\tstruct mips_cdmm_bus *bus, **bus_p;\n\tunsigned long flags;\n\tunsigned int cpu;\n\n\tif (!cpu_has_cdmm)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcpu = smp_processor_id();\n\t \n\tif (cpu == 0)\n\t\treturn &mips_cdmm_boot_bus;\n\n\t \n\tbus_p = per_cpu_ptr(&mips_cdmm_buses, cpu);\n\tlocal_irq_save(flags);\n\tbus = *bus_p;\n\t \n\tif (unlikely(!bus)) {\n\t\tbus = kzalloc(sizeof(*bus), GFP_ATOMIC);\n\t\tif (unlikely(!bus))\n\t\t\tbus = ERR_PTR(-ENOMEM);\n\t\telse\n\t\t\t*bus_p = bus;\n\t}\n\tlocal_irq_restore(flags);\n\treturn bus;\n}\n\n \nstatic phys_addr_t mips_cdmm_cur_base(void)\n{\n\tunsigned long cdmmbase = read_c0_cdmmbase();\n\n\tif (!(cdmmbase & MIPS_CDMMBASE_EN))\n\t\treturn 0;\n\n\treturn (cdmmbase >> MIPS_CDMMBASE_ADDR_SHIFT)\n\t\t<< MIPS_CDMMBASE_ADDR_START;\n}\n\n \nphys_addr_t __weak mips_cdmm_phys_base(void)\n{\n\tstruct device_node *np;\n\tstruct resource res;\n\tint err;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"mti,mips-cdmm\");\n\tif (np) {\n\t\terr = of_address_to_resource(np, 0, &res);\n\t\tof_node_put(np);\n\t\tif (!err)\n\t\t\treturn res.start;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mips_cdmm_setup(struct mips_cdmm_bus *bus)\n{\n\tunsigned long cdmmbase, flags;\n\tint ret = 0;\n\n\tif (IS_ERR(bus))\n\t\treturn PTR_ERR(bus);\n\n\tlocal_irq_save(flags);\n\t \n\tif (bus->offline) {\n\t\t \n\t\tif (bus->phys == mips_cdmm_cur_base())\n\t\t\tgoto out;\n\t\t \n\t\tbus->offline = false;\n\t} else if (bus->phys > 1) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (!bus->phys)\n\t\tbus->phys = mips_cdmm_cur_base();\n\t \n\tif (!bus->phys)\n\t\tbus->phys = mips_cdmm_phys_base();\n\t \n\tif (!bus->phys)\n\t\tbus->phys = mips_cdmm_default_base;\n\t \n\tif (!bus->phys) {\n\t\tbus->phys = 1;\n\t\t \n\t\tpr_err(\"cdmm%u: Failed to choose a physical base\\n\",\n\t\t       smp_processor_id());\n\t}\n\t \n\tif (bus->phys == 1) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tmips_cdmm_default_base = bus->phys;\n\n\tpr_debug(\"cdmm%u: Enabling CDMM region at %pa\\n\",\n\t\t smp_processor_id(), &bus->phys);\n\n\t \n\tcdmmbase = read_c0_cdmmbase();\n\tcdmmbase &= (1ul << MIPS_CDMMBASE_ADDR_SHIFT) - 1;\n\tcdmmbase |= (bus->phys >> MIPS_CDMMBASE_ADDR_START)\n\t\t\t<< MIPS_CDMMBASE_ADDR_SHIFT;\n\tcdmmbase |= MIPS_CDMMBASE_EN;\n\twrite_c0_cdmmbase(cdmmbase);\n\ttlbw_use_hazard();\n\n\tbus->regs = (void __iomem *)CKSEG1ADDR(bus->phys);\n\tbus->drbs = 1 + ((cdmmbase & MIPS_CDMMBASE_SIZE) >>\n\t\t\t MIPS_CDMMBASE_SIZE_SHIFT);\n\tbus->drbs_reserved = !!(cdmmbase & MIPS_CDMMBASE_CI);\n\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n\n \nvoid __iomem *mips_cdmm_early_probe(unsigned int dev_type)\n{\n\tstruct mips_cdmm_bus *bus;\n\tvoid __iomem *cdmm;\n\tu32 acsr;\n\tunsigned int drb, type, size;\n\tint err;\n\n\tif (WARN_ON(!dev_type))\n\t\treturn IOMEM_ERR_PTR(-ENODEV);\n\n\tbus = mips_cdmm_get_bus();\n\terr = mips_cdmm_setup(bus);\n\tif (err)\n\t\treturn IOMEM_ERR_PTR(err);\n\n\t \n\tdrb = bus->drbs_reserved;\n\tcdmm = bus->regs;\n\n\t \n\tfor (; drb < bus->drbs; drb += size + 1) {\n\t\tacsr = __raw_readl(cdmm + drb * CDMM_DRB_SIZE);\n\t\ttype = (acsr & CDMM_ACSR_DEVTYPE) >> CDMM_ACSR_DEVTYPE_SHIFT;\n\t\tif (type == dev_type)\n\t\t\treturn cdmm + drb * CDMM_DRB_SIZE;\n\t\tsize = (acsr & CDMM_ACSR_DEVSIZE) >> CDMM_ACSR_DEVSIZE_SHIFT;\n\t}\n\n\treturn IOMEM_ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL_GPL(mips_cdmm_early_probe);\n\n \nstatic void mips_cdmm_release(struct device *dev)\n{\n\tstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\n\n\tkfree(cdev);\n}\n\n \nstatic void mips_cdmm_bus_discover(struct mips_cdmm_bus *bus)\n{\n\tvoid __iomem *cdmm;\n\tu32 acsr;\n\tunsigned int drb, type, size, rev;\n\tstruct mips_cdmm_device *dev;\n\tunsigned int cpu = smp_processor_id();\n\tint ret = 0;\n\tint id = 0;\n\n\t \n\tdrb = bus->drbs_reserved;\n\tcdmm = bus->regs;\n\n\t \n\tbus->discovered = true;\n\tpr_info(\"cdmm%u discovery (%u blocks)\\n\", cpu, bus->drbs);\n\tfor (; drb < bus->drbs; drb += size + 1) {\n\t\tacsr = __raw_readl(cdmm + drb * CDMM_DRB_SIZE);\n\t\ttype = (acsr & CDMM_ACSR_DEVTYPE) >> CDMM_ACSR_DEVTYPE_SHIFT;\n\t\tsize = (acsr & CDMM_ACSR_DEVSIZE) >> CDMM_ACSR_DEVSIZE_SHIFT;\n\t\trev  = (acsr & CDMM_ACSR_DEVREV)  >> CDMM_ACSR_DEVREV_SHIFT;\n\n\t\tif (!type)\n\t\t\tcontinue;\n\n\t\tpr_info(\"cdmm%u-%u: @%u (%#x..%#x), type 0x%02x, rev %u\\n\",\n\t\t\tcpu, id, drb, drb * CDMM_DRB_SIZE,\n\t\t\t(drb + size + 1) * CDMM_DRB_SIZE - 1,\n\t\t\ttype, rev);\n\n\t\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tdev->cpu = cpu;\n\t\tdev->res.start = bus->phys + drb * CDMM_DRB_SIZE;\n\t\tdev->res.end = bus->phys +\n\t\t\t\t(drb + size + 1) * CDMM_DRB_SIZE - 1;\n\t\tdev->res.flags = IORESOURCE_MEM;\n\t\tdev->type = type;\n\t\tdev->rev = rev;\n\t\tdev->dev.parent = get_cpu_device(cpu);\n\t\tdev->dev.bus = &mips_cdmm_bustype;\n\t\tdev->dev.id = atomic_inc_return(&mips_cdmm_next_id);\n\t\tdev->dev.release = mips_cdmm_release;\n\n\t\tdev_set_name(&dev->dev, \"cdmm%u-%u\", cpu, id);\n\t\t++id;\n\t\tret = device_register(&dev->dev);\n\t\tif (ret)\n\t\t\tput_device(&dev->dev);\n\t}\n}\n\n\n \n\n \n#define BUILD_PERDEV_HELPER(_name)\t\t\t\t\t\\\nstatic int mips_cdmm_##_name##_helper(struct device *dev, void *data)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mips_cdmm_device *cdev = to_mips_cdmm_device(dev);\t\\\n\tstruct mips_cdmm_driver *cdrv;\t\t\t\t\t\\\n\tunsigned int cpu = *(unsigned int *)data;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (cdev->cpu != cpu || !dev->driver)\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcdrv = to_mips_cdmm_driver(dev->driver);\t\t\t\\\n\tif (!cdrv->_name)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\treturn cdrv->_name(cdev);\t\t\t\t\t\\\n}\n\n \nBUILD_PERDEV_HELPER(cpu_down)        \nBUILD_PERDEV_HELPER(cpu_up)          \n\n \nstatic int mips_cdmm_cpu_down_prep(unsigned int cpu)\n{\n\tstruct mips_cdmm_bus *bus;\n\tlong ret;\n\n\t \n\tret = bus_for_each_dev(&mips_cdmm_bustype, NULL, &cpu,\n\t\t\t       mips_cdmm_cpu_down_helper);\n\n\t \n\tbus = mips_cdmm_get_bus();\n\tif (!IS_ERR(bus))\n\t\tbus->offline = true;\n\n\treturn ret;\n}\n\n \nstatic int mips_cdmm_cpu_online(unsigned int cpu)\n{\n\tstruct mips_cdmm_bus *bus;\n\tlong ret;\n\n\tbus = mips_cdmm_get_bus();\n\tret = mips_cdmm_setup(bus);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbus->offline = false;\n\n\tif (!bus->discovered)\n\t\tmips_cdmm_bus_discover(bus);\n\telse\n\t\t \n\t\tret = bus_for_each_dev(&mips_cdmm_bustype, NULL, &cpu,\n\t\t\t\t       mips_cdmm_cpu_up_helper);\n\n\treturn ret;\n}\n\n \nstatic int __init mips_cdmm_init(void)\n{\n\tint ret;\n\n\t \n\tret = bus_register(&mips_cdmm_bustype);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"bus/cdmm:online\",\n\t\t\t\tmips_cdmm_cpu_online, mips_cdmm_cpu_down_prep);\n\tif (ret < 0)\n\t\tpr_warn(\"cdmm: Failed to register CPU notifier\\n\");\n\n\treturn ret;\n}\nsubsys_initcall(mips_cdmm_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}