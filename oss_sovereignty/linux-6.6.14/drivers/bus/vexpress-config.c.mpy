{
  "module_name": "vexpress-config.c",
  "hash_id": "6732d2b5a9162670864065d10348b9d1423845717f4a2b3455f646961a2d5b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/vexpress-config.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/of_platform.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/vexpress.h>\n\n#define SYS_MISC\t\t0x0\n#define SYS_MISC_MASTERSITE\t(1 << 14)\n\n#define SYS_PROCID0\t\t0x24\n#define SYS_PROCID1\t\t0x28\n#define SYS_HBI_MASK\t\t0xfff\n#define SYS_PROCIDx_HBI_SHIFT\t0\n\n#define SYS_CFGDATA\t\t0x40\n\n#define SYS_CFGCTRL\t\t0x44\n#define SYS_CFGCTRL_START\t(1 << 31)\n#define SYS_CFGCTRL_WRITE\t(1 << 30)\n#define SYS_CFGCTRL_DCC(n)\t(((n) & 0xf) << 26)\n#define SYS_CFGCTRL_FUNC(n)\t(((n) & 0x3f) << 20)\n#define SYS_CFGCTRL_SITE(n)\t(((n) & 0x3) << 16)\n#define SYS_CFGCTRL_POSITION(n)\t(((n) & 0xf) << 12)\n#define SYS_CFGCTRL_DEVICE(n)\t(((n) & 0xfff) << 0)\n\n#define SYS_CFGSTAT\t\t0x48\n#define SYS_CFGSTAT_ERR\t\t(1 << 1)\n#define SYS_CFGSTAT_COMPLETE\t(1 << 0)\n\n#define VEXPRESS_SITE_MB\t\t0\n#define VEXPRESS_SITE_DB1\t\t1\n#define VEXPRESS_SITE_DB2\t\t2\n#define VEXPRESS_SITE_MASTER\t\t0xf\n\nstruct vexpress_syscfg {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct list_head funcs;\n};\n\nstruct vexpress_syscfg_func {\n\tstruct list_head list;\n\tstruct vexpress_syscfg *syscfg;\n\tstruct regmap *regmap;\n\tint num_templates;\n\tu32 template[];  \n};\n\nstruct vexpress_config_bridge_ops {\n\tstruct regmap * (*regmap_init)(struct device *dev, void *context);\n\tvoid (*regmap_exit)(struct regmap *regmap, void *context);\n};\n\nstruct vexpress_config_bridge {\n\tstruct vexpress_config_bridge_ops *ops;\n\tvoid *context;\n};\n\n\nstatic DEFINE_MUTEX(vexpress_config_mutex);\nstatic u32 vexpress_config_site_master = VEXPRESS_SITE_MASTER;\n\n\nstatic void vexpress_config_set_master(u32 site)\n{\n\tvexpress_config_site_master = site;\n}\n\nstatic void vexpress_config_lock(void *arg)\n{\n\tmutex_lock(&vexpress_config_mutex);\n}\n\nstatic void vexpress_config_unlock(void *arg)\n{\n\tmutex_unlock(&vexpress_config_mutex);\n}\n\n\nstatic void vexpress_config_find_prop(struct device_node *node,\n\t\tconst char *name, u32 *val)\n{\n\t \n\t*val = 0;\n\n\tof_node_get(node);\n\twhile (node) {\n\t\tif (of_property_read_u32(node, name, val) == 0) {\n\t\t\tof_node_put(node);\n\t\t\treturn;\n\t\t}\n\t\tnode = of_get_next_parent(node);\n\t}\n}\n\nstatic int vexpress_config_get_topo(struct device_node *node, u32 *site,\n\t\tu32 *position, u32 *dcc)\n{\n\tvexpress_config_find_prop(node, \"arm,vexpress,site\", site);\n\tif (*site == VEXPRESS_SITE_MASTER)\n\t\t*site = vexpress_config_site_master;\n\tif (WARN_ON(vexpress_config_site_master == VEXPRESS_SITE_MASTER))\n\t\treturn -EINVAL;\n\tvexpress_config_find_prop(node, \"arm,vexpress,position\", position);\n\tvexpress_config_find_prop(node, \"arm,vexpress,dcc\", dcc);\n\n\treturn 0;\n}\n\n\nstatic void vexpress_config_devres_release(struct device *dev, void *res)\n{\n\tstruct vexpress_config_bridge *bridge = dev_get_drvdata(dev->parent);\n\tstruct regmap *regmap = res;\n\n\tbridge->ops->regmap_exit(regmap, bridge->context);\n}\n\nstruct regmap *devm_regmap_init_vexpress_config(struct device *dev)\n{\n\tstruct vexpress_config_bridge *bridge;\n\tstruct regmap *regmap;\n\tstruct regmap **res;\n\n\tbridge = dev_get_drvdata(dev->parent);\n\tif (WARN_ON(!bridge))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = devres_alloc(vexpress_config_devres_release, sizeof(*res),\n\t\t\tGFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregmap = (bridge->ops->regmap_init)(dev, bridge->context);\n\tif (IS_ERR(regmap)) {\n\t\tdevres_free(res);\n\t\treturn regmap;\n\t}\n\n\t*res = regmap;\n\tdevres_add(dev, res);\n\n\treturn regmap;\n}\nEXPORT_SYMBOL_GPL(devm_regmap_init_vexpress_config);\n\nstatic int vexpress_syscfg_exec(struct vexpress_syscfg_func *func,\n\t\tint index, bool write, u32 *data)\n{\n\tstruct vexpress_syscfg *syscfg = func->syscfg;\n\tu32 command, status;\n\tint tries;\n\tlong timeout;\n\n\tif (WARN_ON(index >= func->num_templates))\n\t\treturn -EINVAL;\n\n\tcommand = readl(syscfg->base + SYS_CFGCTRL);\n\tif (WARN_ON(command & SYS_CFGCTRL_START))\n\t\treturn -EBUSY;\n\n\tcommand = func->template[index];\n\tcommand |= SYS_CFGCTRL_START;\n\tcommand |= write ? SYS_CFGCTRL_WRITE : 0;\n\n\t \n\tif (!write)\n\t\t*data = 0xdeadbeef;\n\n\tdev_dbg(syscfg->dev, \"func %p, command %x, data %x\\n\",\n\t\t\tfunc, command, *data);\n\twritel(*data, syscfg->base + SYS_CFGDATA);\n\twritel(0, syscfg->base + SYS_CFGSTAT);\n\twritel(command, syscfg->base + SYS_CFGCTRL);\n\tmb();\n\n\t \n\ttries = 100;\n\ttimeout = 100;\n\tdo {\n\t\tif (!irqs_disabled()) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(usecs_to_jiffies(timeout));\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t} else {\n\t\t\tudelay(timeout);\n\t\t}\n\n\t\tstatus = readl(syscfg->base + SYS_CFGSTAT);\n\t\tif (status & SYS_CFGSTAT_ERR)\n\t\t\treturn -EFAULT;\n\n\t\tif (timeout > 20)\n\t\t\ttimeout -= 20;\n\t} while (--tries && !(status & SYS_CFGSTAT_COMPLETE));\n\tif (WARN_ON_ONCE(!tries))\n\t\treturn -ETIMEDOUT;\n\n\tif (!write) {\n\t\t*data = readl(syscfg->base + SYS_CFGDATA);\n\t\tdev_dbg(syscfg->dev, \"func %p, read data %x\\n\", func, *data);\n\t}\n\n\treturn 0;\n}\n\nstatic int vexpress_syscfg_read(void *context, unsigned int index,\n\t\tunsigned int *val)\n{\n\tstruct vexpress_syscfg_func *func = context;\n\n\treturn vexpress_syscfg_exec(func, index, false, val);\n}\n\nstatic int vexpress_syscfg_write(void *context, unsigned int index,\n\t\tunsigned int val)\n{\n\tstruct vexpress_syscfg_func *func = context;\n\n\treturn vexpress_syscfg_exec(func, index, true, &val);\n}\n\nstatic struct regmap_config vexpress_syscfg_regmap_config = {\n\t.lock = vexpress_config_lock,\n\t.unlock = vexpress_config_unlock,\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_read = vexpress_syscfg_read,\n\t.reg_write = vexpress_syscfg_write,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\n\nstatic struct regmap *vexpress_syscfg_regmap_init(struct device *dev,\n\t\tvoid *context)\n{\n\tint err;\n\tstruct vexpress_syscfg *syscfg = context;\n\tstruct vexpress_syscfg_func *func;\n\tstruct property *prop;\n\tconst __be32 *val = NULL;\n\t__be32 energy_quirk[4];\n\tint num;\n\tu32 site, position, dcc;\n\tint i;\n\n\terr = vexpress_config_get_topo(dev->of_node, &site,\n\t\t\t\t&position, &dcc);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tprop = of_find_property(dev->of_node,\n\t\t\t\"arm,vexpress-sysreg,func\", NULL);\n\tif (!prop)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnum = prop->length / sizeof(u32) / 2;\n\tval = prop->value;\n\n\t \n\tif (num == 1 && of_device_is_compatible(dev->of_node,\n\t\t\t\"arm,vexpress-energy\")) {\n\t\tnum = 2;\n\t\tenergy_quirk[0] = *val;\n\t\tenergy_quirk[2] = *val++;\n\t\tenergy_quirk[1] = *val;\n\t\tenergy_quirk[3] = cpu_to_be32(be32_to_cpup(val) + 1);\n\t\tval = energy_quirk;\n\t}\n\n\tfunc = kzalloc(struct_size(func, template, num), GFP_KERNEL);\n\tif (!func)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfunc->syscfg = syscfg;\n\tfunc->num_templates = num;\n\n\tfor (i = 0; i < num; i++) {\n\t\tu32 function, device;\n\n\t\tfunction = be32_to_cpup(val++);\n\t\tdevice = be32_to_cpup(val++);\n\n\t\tdev_dbg(dev, \"func %p: %u/%u/%u/%u/%u\\n\",\n\t\t\t\tfunc, site, position, dcc,\n\t\t\t\tfunction, device);\n\n\t\tfunc->template[i] = SYS_CFGCTRL_DCC(dcc);\n\t\tfunc->template[i] |= SYS_CFGCTRL_SITE(site);\n\t\tfunc->template[i] |= SYS_CFGCTRL_POSITION(position);\n\t\tfunc->template[i] |= SYS_CFGCTRL_FUNC(function);\n\t\tfunc->template[i] |= SYS_CFGCTRL_DEVICE(device);\n\t}\n\n\tvexpress_syscfg_regmap_config.max_register = num - 1;\n\n\tfunc->regmap = regmap_init(dev, NULL, func,\n\t\t\t&vexpress_syscfg_regmap_config);\n\n\tif (IS_ERR(func->regmap)) {\n\t\tvoid *err = func->regmap;\n\n\t\tkfree(func);\n\t\treturn err;\n\t}\n\n\tlist_add(&func->list, &syscfg->funcs);\n\n\treturn func->regmap;\n}\n\nstatic void vexpress_syscfg_regmap_exit(struct regmap *regmap, void *context)\n{\n\tstruct vexpress_syscfg *syscfg = context;\n\tstruct vexpress_syscfg_func *func, *tmp;\n\n\tregmap_exit(regmap);\n\n\tlist_for_each_entry_safe(func, tmp, &syscfg->funcs, list) {\n\t\tif (func->regmap == regmap) {\n\t\t\tlist_del(&syscfg->funcs);\n\t\t\tkfree(func);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct vexpress_config_bridge_ops vexpress_syscfg_bridge_ops = {\n\t.regmap_init = vexpress_syscfg_regmap_init,\n\t.regmap_exit = vexpress_syscfg_regmap_exit,\n};\n\n\nstatic int vexpress_syscfg_probe(struct platform_device *pdev)\n{\n\tstruct vexpress_syscfg *syscfg;\n\tstruct vexpress_config_bridge *bridge;\n\tstruct device_node *node;\n\tint master;\n\tu32 dt_hbi;\n\n\tsyscfg = devm_kzalloc(&pdev->dev, sizeof(*syscfg), GFP_KERNEL);\n\tif (!syscfg)\n\t\treturn -ENOMEM;\n\tsyscfg->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&syscfg->funcs);\n\n\tsyscfg->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(syscfg->base))\n\t\treturn PTR_ERR(syscfg->base);\n\n\tbridge = devm_kmalloc(&pdev->dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->ops = &vexpress_syscfg_bridge_ops;\n\tbridge->context = syscfg;\n\n\tdev_set_drvdata(&pdev->dev, bridge);\n\n\tmaster = readl(syscfg->base + SYS_MISC) & SYS_MISC_MASTERSITE ?\n\t\t\tVEXPRESS_SITE_DB2 : VEXPRESS_SITE_DB1;\n\tvexpress_config_set_master(master);\n\n\t \n\tif (of_property_read_u32(of_root, \"arm,hbi\", &dt_hbi) == 0) {\n\t\tu32 id = readl(syscfg->base + (master == VEXPRESS_SITE_DB1 ?\n\t\t\t\t SYS_PROCID0 : SYS_PROCID1));\n\t\tu32 hbi = (id >> SYS_PROCIDx_HBI_SHIFT) & SYS_HBI_MASK;\n\n\t\tif (WARN_ON(dt_hbi != hbi))\n\t\t\tdev_warn(&pdev->dev, \"DT HBI (%x) is not matching hardware (%x)!\\n\",\n\t\t\t\t\tdt_hbi, hbi);\n\t}\n\n\tfor_each_compatible_node(node, NULL, \"arm,vexpress,config-bus\") {\n\t\tstruct device_node *bridge_np;\n\n\t\tbridge_np = of_parse_phandle(node, \"arm,vexpress,config-bridge\", 0);\n\t\tif (bridge_np != pdev->dev.parent->of_node)\n\t\t\tcontinue;\n\n\t\tof_platform_populate(node, NULL, NULL, &pdev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id vexpress_syscfg_id_table[] = {\n\t{ \"vexpress-syscfg\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, vexpress_syscfg_id_table);\n\nstatic struct platform_driver vexpress_syscfg_driver = {\n\t.driver.name = \"vexpress-syscfg\",\n\t.id_table = vexpress_syscfg_id_table,\n\t.probe = vexpress_syscfg_probe,\n};\nmodule_platform_driver(vexpress_syscfg_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}