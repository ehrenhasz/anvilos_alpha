{
  "module_name": "mvebu-mbus.c",
  "hash_id": "41d0690959a357f9b49549fff0611f50ca37b9c211fc668931ba3b10cf9c2b29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mvebu-mbus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mbus.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/debugfs.h>\n#include <linux/log2.h>\n#include <linux/memblock.h>\n#include <linux/syscore_ops.h>\n\n \n#define TARGET_DDR\t\t0\n\n \n#define WIN_CTRL_OFF\t\t0x0000\n#define   WIN_CTRL_ENABLE       BIT(0)\n \n#define   WIN_CTRL_SYNCBARRIER  BIT(1)\n#define   WIN_CTRL_TGT_MASK     0xf0\n#define   WIN_CTRL_TGT_SHIFT    4\n#define   WIN_CTRL_ATTR_MASK    0xff00\n#define   WIN_CTRL_ATTR_SHIFT   8\n#define   WIN_CTRL_SIZE_MASK    0xffff0000\n#define   WIN_CTRL_SIZE_SHIFT   16\n#define WIN_BASE_OFF\t\t0x0004\n#define   WIN_BASE_LOW          0xffff0000\n#define   WIN_BASE_HIGH         0xf\n#define WIN_REMAP_LO_OFF\t0x0008\n#define   WIN_REMAP_LOW         0xffff0000\n#define WIN_REMAP_HI_OFF\t0x000c\n\n#define UNIT_SYNC_BARRIER_OFF   0x84\n#define   UNIT_SYNC_BARRIER_ALL 0xFFFF\n\n#define ATTR_HW_COHERENCY\t(0x1 << 4)\n\n#define DDR_BASE_CS_OFF(n)\t(0x0000 + ((n) << 3))\n#define  DDR_BASE_CS_HIGH_MASK  0xf\n#define  DDR_BASE_CS_LOW_MASK   0xff000000\n#define DDR_SIZE_CS_OFF(n)\t(0x0004 + ((n) << 3))\n#define  DDR_SIZE_ENABLED       BIT(0)\n#define  DDR_SIZE_CS_MASK       0x1c\n#define  DDR_SIZE_CS_SHIFT      2\n#define  DDR_SIZE_MASK          0xff000000\n\n#define DOVE_DDR_BASE_CS_OFF(n) ((n) << 4)\n\n \n#define MBUS_BRIDGE_CTRL_OFF\t0x0\n#define MBUS_BRIDGE_BASE_OFF\t0x4\n\n \n#define MBUS_WINS_MAX           20\n\nstruct mvebu_mbus_state;\n\nstruct mvebu_mbus_soc_data {\n\tunsigned int num_wins;\n\tbool has_mbus_bridge;\n\tunsigned int (*win_cfg_offset)(const int win);\n\tunsigned int (*win_remap_offset)(const int win);\n\tvoid (*setup_cpu_target)(struct mvebu_mbus_state *s);\n\tint (*save_cpu_target)(struct mvebu_mbus_state *s,\n\t\t\t       u32 __iomem *store_addr);\n\tint (*show_cpu_target)(struct mvebu_mbus_state *s,\n\t\t\t       struct seq_file *seq, void *v);\n};\n\n \nstruct mvebu_mbus_win_data {\n\tu32 ctrl;\n\tu32 base;\n\tu32 remap_lo;\n\tu32 remap_hi;\n};\n\nstruct mvebu_mbus_state {\n\tvoid __iomem *mbuswins_base;\n\tvoid __iomem *sdramwins_base;\n\tvoid __iomem *mbusbridge_base;\n\tphys_addr_t sdramwins_phys_base;\n\tstruct dentry *debugfs_root;\n\tstruct dentry *debugfs_sdram;\n\tstruct dentry *debugfs_devs;\n\tstruct resource pcie_mem_aperture;\n\tstruct resource pcie_io_aperture;\n\tconst struct mvebu_mbus_soc_data *soc;\n\tint hw_io_coherency;\n\n\t \n\tu32 mbus_bridge_ctrl;\n\tu32 mbus_bridge_base;\n\tstruct mvebu_mbus_win_data wins[MBUS_WINS_MAX];\n};\n\nstatic struct mvebu_mbus_state mbus_state;\n\n \n\nstatic struct mbus_dram_target_info mvebu_mbus_dram_info;\nstatic struct mbus_dram_target_info mvebu_mbus_dram_info_nooverlap;\n\nconst struct mbus_dram_target_info *mv_mbus_dram_info(void)\n{\n\treturn &mvebu_mbus_dram_info;\n}\nEXPORT_SYMBOL_GPL(mv_mbus_dram_info);\n\nconst struct mbus_dram_target_info *mv_mbus_dram_info_nooverlap(void)\n{\n\treturn &mvebu_mbus_dram_info_nooverlap;\n}\nEXPORT_SYMBOL_GPL(mv_mbus_dram_info_nooverlap);\n\n \nstatic bool mvebu_mbus_window_is_remappable(struct mvebu_mbus_state *mbus,\n\t\t\t\t\t    const int win)\n{\n\treturn mbus->soc->win_remap_offset(win) != MVEBU_MBUS_NO_REMAP;\n}\n\n \n\nstatic void mvebu_mbus_read_window(struct mvebu_mbus_state *mbus,\n\t\t\t\t   int win, int *enabled, u64 *base,\n\t\t\t\t   u32 *size, u8 *target, u8 *attr,\n\t\t\t\t   u64 *remap)\n{\n\tvoid __iomem *addr = mbus->mbuswins_base +\n\t\tmbus->soc->win_cfg_offset(win);\n\tu32 basereg = readl(addr + WIN_BASE_OFF);\n\tu32 ctrlreg = readl(addr + WIN_CTRL_OFF);\n\n\tif (!(ctrlreg & WIN_CTRL_ENABLE)) {\n\t\t*enabled = 0;\n\t\treturn;\n\t}\n\n\t*enabled = 1;\n\t*base = ((u64)basereg & WIN_BASE_HIGH) << 32;\n\t*base |= (basereg & WIN_BASE_LOW);\n\t*size = (ctrlreg | ~WIN_CTRL_SIZE_MASK) + 1;\n\n\tif (target)\n\t\t*target = (ctrlreg & WIN_CTRL_TGT_MASK) >> WIN_CTRL_TGT_SHIFT;\n\n\tif (attr)\n\t\t*attr = (ctrlreg & WIN_CTRL_ATTR_MASK) >> WIN_CTRL_ATTR_SHIFT;\n\n\tif (remap) {\n\t\tif (mvebu_mbus_window_is_remappable(mbus, win)) {\n\t\t\tu32 remap_low, remap_hi;\n\t\t\tvoid __iomem *addr_rmp = mbus->mbuswins_base +\n\t\t\t\tmbus->soc->win_remap_offset(win);\n\t\t\tremap_low = readl(addr_rmp + WIN_REMAP_LO_OFF);\n\t\t\tremap_hi  = readl(addr_rmp + WIN_REMAP_HI_OFF);\n\t\t\t*remap = ((u64)remap_hi << 32) | remap_low;\n\t\t} else\n\t\t\t*remap = 0;\n\t}\n}\n\nstatic void mvebu_mbus_disable_window(struct mvebu_mbus_state *mbus,\n\t\t\t\t      int win)\n{\n\tvoid __iomem *addr;\n\n\taddr = mbus->mbuswins_base + mbus->soc->win_cfg_offset(win);\n\twritel(0, addr + WIN_BASE_OFF);\n\twritel(0, addr + WIN_CTRL_OFF);\n\n\tif (mvebu_mbus_window_is_remappable(mbus, win)) {\n\t\taddr = mbus->mbuswins_base + mbus->soc->win_remap_offset(win);\n\t\twritel(0, addr + WIN_REMAP_LO_OFF);\n\t\twritel(0, addr + WIN_REMAP_HI_OFF);\n\t}\n}\n\n \n\nstatic int mvebu_mbus_window_is_free(struct mvebu_mbus_state *mbus,\n\t\t\t\t     const int win)\n{\n\tvoid __iomem *addr = mbus->mbuswins_base +\n\t\tmbus->soc->win_cfg_offset(win);\n\tu32 ctrl = readl(addr + WIN_CTRL_OFF);\n\n\treturn !(ctrl & WIN_CTRL_ENABLE);\n}\n\n \nstatic int mvebu_mbus_window_conflicts(struct mvebu_mbus_state *mbus,\n\t\t\t\t       phys_addr_t base, size_t size,\n\t\t\t\t       u8 target, u8 attr)\n{\n\tu64 end = (u64)base + size;\n\tint win;\n\n\tfor (win = 0; win < mbus->soc->num_wins; win++) {\n\t\tu64 wbase, wend;\n\t\tu32 wsize;\n\t\tu8 wtarget, wattr;\n\t\tint enabled;\n\n\t\tmvebu_mbus_read_window(mbus, win,\n\t\t\t\t       &enabled, &wbase, &wsize,\n\t\t\t\t       &wtarget, &wattr, NULL);\n\n\t\tif (!enabled)\n\t\t\tcontinue;\n\n\t\twend = wbase + wsize;\n\n\t\t \n\t\tif ((u64)base < wend && end > wbase)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int mvebu_mbus_find_window(struct mvebu_mbus_state *mbus,\n\t\t\t\t  phys_addr_t base, size_t size)\n{\n\tint win;\n\n\tfor (win = 0; win < mbus->soc->num_wins; win++) {\n\t\tu64 wbase;\n\t\tu32 wsize;\n\t\tint enabled;\n\n\t\tmvebu_mbus_read_window(mbus, win,\n\t\t\t\t       &enabled, &wbase, &wsize,\n\t\t\t\t       NULL, NULL, NULL);\n\n\t\tif (!enabled)\n\t\t\tcontinue;\n\n\t\tif (base == wbase && size == wsize)\n\t\t\treturn win;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int mvebu_mbus_setup_window(struct mvebu_mbus_state *mbus,\n\t\t\t\t   int win, phys_addr_t base, size_t size,\n\t\t\t\t   phys_addr_t remap, u8 target,\n\t\t\t\t   u8 attr)\n{\n\tvoid __iomem *addr = mbus->mbuswins_base +\n\t\tmbus->soc->win_cfg_offset(win);\n\tu32 ctrl, remap_addr;\n\n\tif (!is_power_of_2(size)) {\n\t\tWARN(true, \"Invalid MBus window size: 0x%zx\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((base & (phys_addr_t)(size - 1)) != 0) {\n\t\tWARN(true, \"Invalid MBus base/size: %pa len 0x%zx\\n\", &base,\n\t\t     size);\n\t\treturn -EINVAL;\n\t}\n\n\tctrl = ((size - 1) & WIN_CTRL_SIZE_MASK) |\n\t\t(attr << WIN_CTRL_ATTR_SHIFT)    |\n\t\t(target << WIN_CTRL_TGT_SHIFT)   |\n\t\tWIN_CTRL_ENABLE;\n\tif (mbus->hw_io_coherency)\n\t\tctrl |= WIN_CTRL_SYNCBARRIER;\n\n\twritel(base & WIN_BASE_LOW, addr + WIN_BASE_OFF);\n\twritel(ctrl, addr + WIN_CTRL_OFF);\n\n\tif (mvebu_mbus_window_is_remappable(mbus, win)) {\n\t\tvoid __iomem *addr_rmp = mbus->mbuswins_base +\n\t\t\tmbus->soc->win_remap_offset(win);\n\n\t\tif (remap == MVEBU_MBUS_NO_REMAP)\n\t\t\tremap_addr = base;\n\t\telse\n\t\t\tremap_addr = remap;\n\t\twritel(remap_addr & WIN_REMAP_LOW, addr_rmp + WIN_REMAP_LO_OFF);\n\t\twritel(0, addr_rmp + WIN_REMAP_HI_OFF);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_mbus_alloc_window(struct mvebu_mbus_state *mbus,\n\t\t\t\t   phys_addr_t base, size_t size,\n\t\t\t\t   phys_addr_t remap, u8 target,\n\t\t\t\t   u8 attr)\n{\n\tint win;\n\n\tif (remap == MVEBU_MBUS_NO_REMAP) {\n\t\tfor (win = 0; win < mbus->soc->num_wins; win++) {\n\t\t\tif (mvebu_mbus_window_is_remappable(mbus, win))\n\t\t\t\tcontinue;\n\n\t\t\tif (mvebu_mbus_window_is_free(mbus, win))\n\t\t\t\treturn mvebu_mbus_setup_window(mbus, win, base,\n\t\t\t\t\t\t\t       size, remap,\n\t\t\t\t\t\t\t       target, attr);\n\t\t}\n\t}\n\n\tfor (win = 0; win < mbus->soc->num_wins; win++) {\n\t\t \n\t\tif ((remap != MVEBU_MBUS_NO_REMAP) &&\n\t\t    !mvebu_mbus_window_is_remappable(mbus, win))\n\t\t\tcontinue;\n\n\t\tif (mvebu_mbus_window_is_free(mbus, win))\n\t\t\treturn mvebu_mbus_setup_window(mbus, win, base, size,\n\t\t\t\t\t\t       remap, target, attr);\n\t}\n\n\treturn -ENOMEM;\n}\n\n \n\n \nstatic int mvebu_sdram_debug_show_orion(struct mvebu_mbus_state *mbus,\n\t\t\t\t\tstruct seq_file *seq, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 basereg = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\n\t\tu32 sizereg = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\n\t\tu64 base;\n\t\tu32 size;\n\n\t\tif (!(sizereg & DDR_SIZE_ENABLED)) {\n\t\t\tseq_printf(seq, \"[%d] disabled\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase = ((u64)basereg & DDR_BASE_CS_HIGH_MASK) << 32;\n\t\tbase |= basereg & DDR_BASE_CS_LOW_MASK;\n\t\tsize = (sizereg | ~DDR_SIZE_MASK);\n\n\t\tseq_printf(seq, \"[%d] %016llx - %016llx : cs%d\\n\",\n\t\t\t   i, (unsigned long long)base,\n\t\t\t   (unsigned long long)base + size + 1,\n\t\t\t   (sizereg & DDR_SIZE_CS_MASK) >> DDR_SIZE_CS_SHIFT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mvebu_sdram_debug_show_dove(struct mvebu_mbus_state *mbus,\n\t\t\t\t       struct seq_file *seq, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\n\t\tu64 base;\n\t\tu32 size;\n\n\t\tif (!(map & 1)) {\n\t\t\tseq_printf(seq, \"[%d] disabled\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase = map & 0xff800000;\n\t\tsize = 0x100000 << (((map & 0x000f0000) >> 16) - 4);\n\n\t\tseq_printf(seq, \"[%d] %016llx - %016llx : cs%d\\n\",\n\t\t\t   i, (unsigned long long)base,\n\t\t\t   (unsigned long long)base + size, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_sdram_debug_show(struct seq_file *seq, void *v)\n{\n\tstruct mvebu_mbus_state *mbus = &mbus_state;\n\treturn mbus->soc->show_cpu_target(mbus, seq, v);\n}\nDEFINE_SHOW_ATTRIBUTE(mvebu_sdram_debug);\n\nstatic int mvebu_devs_debug_show(struct seq_file *seq, void *v)\n{\n\tstruct mvebu_mbus_state *mbus = &mbus_state;\n\tint win;\n\n\tfor (win = 0; win < mbus->soc->num_wins; win++) {\n\t\tu64 wbase, wremap;\n\t\tu32 wsize;\n\t\tu8 wtarget, wattr;\n\t\tint enabled;\n\n\t\tmvebu_mbus_read_window(mbus, win,\n\t\t\t\t       &enabled, &wbase, &wsize,\n\t\t\t\t       &wtarget, &wattr, &wremap);\n\n\t\tif (!enabled) {\n\t\t\tseq_printf(seq, \"[%02d] disabled\\n\", win);\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(seq, \"[%02d] %016llx - %016llx : %04x:%04x\",\n\t\t\t   win, (unsigned long long)wbase,\n\t\t\t   (unsigned long long)(wbase + wsize), wtarget, wattr);\n\n\t\tif (!is_power_of_2(wsize) ||\n\t\t    ((wbase & (u64)(wsize - 1)) != 0))\n\t\t\tseq_puts(seq, \" (Invalid base/size!!)\");\n\n\t\tif (mvebu_mbus_window_is_remappable(mbus, win)) {\n\t\t\tseq_printf(seq, \" (remap %016llx)\\n\",\n\t\t\t\t   (unsigned long long)wremap);\n\t\t} else\n\t\t\tseq_printf(seq, \"\\n\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mvebu_devs_debug);\n\n \n\nstatic unsigned int generic_mbus_win_cfg_offset(int win)\n{\n\treturn win << 4;\n}\n\nstatic unsigned int armada_370_xp_mbus_win_cfg_offset(int win)\n{\n\t \n\tif (win < 8)\n\t\treturn win << 4;\n\telse\n\t\treturn 0x90 + ((win - 8) << 3);\n}\n\nstatic unsigned int mv78xx0_mbus_win_cfg_offset(int win)\n{\n\tif (win < 8)\n\t\treturn win << 4;\n\telse\n\t\treturn 0x900 + ((win - 8) << 4);\n}\n\nstatic unsigned int generic_mbus_win_remap_2_offset(int win)\n{\n\tif (win < 2)\n\t\treturn generic_mbus_win_cfg_offset(win);\n\telse\n\t\treturn MVEBU_MBUS_NO_REMAP;\n}\n\nstatic unsigned int generic_mbus_win_remap_4_offset(int win)\n{\n\tif (win < 4)\n\t\treturn generic_mbus_win_cfg_offset(win);\n\telse\n\t\treturn MVEBU_MBUS_NO_REMAP;\n}\n\nstatic unsigned int generic_mbus_win_remap_8_offset(int win)\n{\n\tif (win < 8)\n\t\treturn generic_mbus_win_cfg_offset(win);\n\telse\n\t\treturn MVEBU_MBUS_NO_REMAP;\n}\n\nstatic unsigned int armada_xp_mbus_win_remap_offset(int win)\n{\n\tif (win < 8)\n\t\treturn generic_mbus_win_cfg_offset(win);\n\telse if (win == 13)\n\t\treturn 0xF0 - WIN_REMAP_LO_OFF;\n\telse\n\t\treturn MVEBU_MBUS_NO_REMAP;\n}\n\n \nstatic void __init\nmvebu_mbus_find_bridge_hole(uint64_t *start, uint64_t *end)\n{\n\tphys_addr_t reg_start, reg_end;\n\tuint64_t i, s = 0;\n\n\tfor_each_mem_range(i, &reg_start, &reg_end) {\n\t\t \n\t\tif ((u64)reg_start >= 0x100000000ULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (reg_end > s)\n\t\t\ts = reg_end;\n\t}\n\n\t*start = s;\n\t*end = 0x100000000ULL;\n}\n\n \nstatic void __init\nmvebu_mbus_setup_cpu_target_nooverlap(struct mvebu_mbus_state *mbus)\n{\n\tuint64_t mbus_bridge_base, mbus_bridge_end;\n\tint cs_nooverlap = 0;\n\tint i;\n\n\tmvebu_mbus_find_bridge_hole(&mbus_bridge_base, &mbus_bridge_end);\n\n\tfor (i = 0; i < mvebu_mbus_dram_info.num_cs; i++) {\n\t\tstruct mbus_dram_window *w;\n\t\tu64 base, size, end;\n\n\t\tw = &mvebu_mbus_dram_info.cs[i];\n\t\tbase = w->base;\n\t\tsize = w->size;\n\t\tend = base + size;\n\n\t\t \n\t\tif (base >= mbus_bridge_base && end <= mbus_bridge_end)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (base >= mbus_bridge_base && end > mbus_bridge_end) {\n\t\t\tsize -= mbus_bridge_end - base;\n\t\t\tbase = mbus_bridge_end;\n\t\t}\n\n\t\t \n\t\tif (base < mbus_bridge_base && end > mbus_bridge_base)\n\t\t\tsize -= end - mbus_bridge_base;\n\n\t\tw = &mvebu_mbus_dram_info_nooverlap.cs[cs_nooverlap++];\n\t\tw->cs_index = i;\n\t\tw->mbus_attr = 0xf & ~(1 << i);\n\t\tif (mbus->hw_io_coherency)\n\t\t\tw->mbus_attr |= ATTR_HW_COHERENCY;\n\t\tw->base = base;\n\t\tw->size = size;\n\t}\n\n\tmvebu_mbus_dram_info_nooverlap.mbus_dram_target_id = TARGET_DDR;\n\tmvebu_mbus_dram_info_nooverlap.num_cs = cs_nooverlap;\n}\n\nstatic void __init\nmvebu_mbus_default_setup_cpu_target(struct mvebu_mbus_state *mbus)\n{\n\tint i;\n\tint cs;\n\n\tmvebu_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;\n\n\tfor (i = 0, cs = 0; i < 4; i++) {\n\t\tu32 base = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\n\t\tu32 size = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\n\n\t\t \n\t\tif ((size & DDR_SIZE_ENABLED) &&\n\t\t    !(base & DDR_BASE_CS_HIGH_MASK)) {\n\t\t\tstruct mbus_dram_window *w;\n\n\t\t\tw = &mvebu_mbus_dram_info.cs[cs++];\n\t\t\tw->cs_index = i;\n\t\t\tw->mbus_attr = 0xf & ~(1 << i);\n\t\t\tif (mbus->hw_io_coherency)\n\t\t\t\tw->mbus_attr |= ATTR_HW_COHERENCY;\n\t\t\tw->base = base & DDR_BASE_CS_LOW_MASK;\n\t\t\tw->size = (u64)(size | ~DDR_SIZE_MASK) + 1;\n\t\t}\n\t}\n\tmvebu_mbus_dram_info.num_cs = cs;\n}\n\nstatic int\nmvebu_mbus_default_save_cpu_target(struct mvebu_mbus_state *mbus,\n\t\t\t\t   u32 __iomem *store_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 base = readl(mbus->sdramwins_base + DDR_BASE_CS_OFF(i));\n\t\tu32 size = readl(mbus->sdramwins_base + DDR_SIZE_CS_OFF(i));\n\n\t\twritel(mbus->sdramwins_phys_base + DDR_BASE_CS_OFF(i),\n\t\t       store_addr++);\n\t\twritel(base, store_addr++);\n\t\twritel(mbus->sdramwins_phys_base + DDR_SIZE_CS_OFF(i),\n\t\t       store_addr++);\n\t\twritel(size, store_addr++);\n\t}\n\n\t \n\treturn 16;\n}\n\nstatic void __init\nmvebu_mbus_dove_setup_cpu_target(struct mvebu_mbus_state *mbus)\n{\n\tint i;\n\tint cs;\n\n\tmvebu_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;\n\n\tfor (i = 0, cs = 0; i < 2; i++) {\n\t\tu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\n\n\t\t \n\t\tif (map & 1) {\n\t\t\tstruct mbus_dram_window *w;\n\n\t\t\tw = &mvebu_mbus_dram_info.cs[cs++];\n\t\t\tw->cs_index = i;\n\t\t\tw->mbus_attr = 0;  \n\t\t\t\t\t   \n\t\t\t\t\t   \n\t\t\tw->base = map & 0xff800000;\n\t\t\tw->size = 0x100000 << (((map & 0x000f0000) >> 16) - 4);\n\t\t}\n\t}\n\n\tmvebu_mbus_dram_info.num_cs = cs;\n}\n\nstatic int\nmvebu_mbus_dove_save_cpu_target(struct mvebu_mbus_state *mbus,\n\t\t\t\tu32 __iomem *store_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu32 map = readl(mbus->sdramwins_base + DOVE_DDR_BASE_CS_OFF(i));\n\n\t\twritel(mbus->sdramwins_phys_base + DOVE_DDR_BASE_CS_OFF(i),\n\t\t       store_addr++);\n\t\twritel(map, store_addr++);\n\t}\n\n\t \n\treturn 4;\n}\n\nint mvebu_mbus_save_cpu_target(u32 __iomem *store_addr)\n{\n\treturn mbus_state.soc->save_cpu_target(&mbus_state, store_addr);\n}\n\nstatic const struct mvebu_mbus_soc_data armada_370_mbus_data = {\n\t.num_wins            = 20,\n\t.has_mbus_bridge     = true,\n\t.win_cfg_offset      = armada_370_xp_mbus_win_cfg_offset,\n\t.win_remap_offset    = generic_mbus_win_remap_8_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n};\n\nstatic const struct mvebu_mbus_soc_data armada_xp_mbus_data = {\n\t.num_wins            = 20,\n\t.has_mbus_bridge     = true,\n\t.win_cfg_offset      = armada_370_xp_mbus_win_cfg_offset,\n\t.win_remap_offset    = armada_xp_mbus_win_remap_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n};\n\nstatic const struct mvebu_mbus_soc_data kirkwood_mbus_data = {\n\t.num_wins            = 8,\n\t.win_cfg_offset      = generic_mbus_win_cfg_offset,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n\t.win_remap_offset    = generic_mbus_win_remap_4_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n};\n\nstatic const struct mvebu_mbus_soc_data dove_mbus_data = {\n\t.num_wins            = 8,\n\t.win_cfg_offset      = generic_mbus_win_cfg_offset,\n\t.save_cpu_target     = mvebu_mbus_dove_save_cpu_target,\n\t.win_remap_offset    = generic_mbus_win_remap_4_offset,\n\t.setup_cpu_target    = mvebu_mbus_dove_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_dove,\n};\n\n \nstatic const struct mvebu_mbus_soc_data orion5x_4win_mbus_data = {\n\t.num_wins            = 8,\n\t.win_cfg_offset      = generic_mbus_win_cfg_offset,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n\t.win_remap_offset    = generic_mbus_win_remap_4_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n};\n\nstatic const struct mvebu_mbus_soc_data orion5x_2win_mbus_data = {\n\t.num_wins            = 8,\n\t.win_cfg_offset      = generic_mbus_win_cfg_offset,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n\t.win_remap_offset    = generic_mbus_win_remap_2_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n};\n\nstatic const struct mvebu_mbus_soc_data mv78xx0_mbus_data = {\n\t.num_wins            = 14,\n\t.win_cfg_offset      = mv78xx0_mbus_win_cfg_offset,\n\t.save_cpu_target     = mvebu_mbus_default_save_cpu_target,\n\t.win_remap_offset    = generic_mbus_win_remap_8_offset,\n\t.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,\n\t.show_cpu_target     = mvebu_sdram_debug_show_orion,\n};\n\nstatic const struct of_device_id of_mvebu_mbus_ids[] = {\n\t{ .compatible = \"marvell,armada370-mbus\",\n\t  .data = &armada_370_mbus_data, },\n\t{ .compatible = \"marvell,armada375-mbus\",\n\t  .data = &armada_xp_mbus_data, },\n\t{ .compatible = \"marvell,armada380-mbus\",\n\t  .data = &armada_xp_mbus_data, },\n\t{ .compatible = \"marvell,armadaxp-mbus\",\n\t  .data = &armada_xp_mbus_data, },\n\t{ .compatible = \"marvell,kirkwood-mbus\",\n\t  .data = &kirkwood_mbus_data, },\n\t{ .compatible = \"marvell,dove-mbus\",\n\t  .data = &dove_mbus_data, },\n\t{ .compatible = \"marvell,orion5x-88f5281-mbus\",\n\t  .data = &orion5x_4win_mbus_data, },\n\t{ .compatible = \"marvell,orion5x-88f5182-mbus\",\n\t  .data = &orion5x_2win_mbus_data, },\n\t{ .compatible = \"marvell,orion5x-88f5181-mbus\",\n\t  .data = &orion5x_2win_mbus_data, },\n\t{ .compatible = \"marvell,orion5x-88f6183-mbus\",\n\t  .data = &orion5x_4win_mbus_data, },\n\t{ .compatible = \"marvell,mv78xx0-mbus\",\n\t  .data = &mv78xx0_mbus_data, },\n\t{ },\n};\n\n \nint mvebu_mbus_add_window_remap_by_id(unsigned int target,\n\t\t\t\t      unsigned int attribute,\n\t\t\t\t      phys_addr_t base, size_t size,\n\t\t\t\t      phys_addr_t remap)\n{\n\tstruct mvebu_mbus_state *s = &mbus_state;\n\n\tif (!mvebu_mbus_window_conflicts(s, base, size, target, attribute)) {\n\t\tpr_err(\"cannot add window '%x:%x', conflicts with another window\\n\",\n\t\t       target, attribute);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mvebu_mbus_alloc_window(s, base, size, remap, target, attribute);\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_add_window_remap_by_id);\n\nint mvebu_mbus_add_window_by_id(unsigned int target, unsigned int attribute,\n\t\t\t\tphys_addr_t base, size_t size)\n{\n\treturn mvebu_mbus_add_window_remap_by_id(target, attribute, base,\n\t\t\t\t\t\t size, MVEBU_MBUS_NO_REMAP);\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_add_window_by_id);\n\nint mvebu_mbus_del_window(phys_addr_t base, size_t size)\n{\n\tint win;\n\n\twin = mvebu_mbus_find_window(&mbus_state, base, size);\n\tif (win < 0)\n\t\treturn win;\n\n\tmvebu_mbus_disable_window(&mbus_state, win);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_del_window);\n\nvoid mvebu_mbus_get_pcie_mem_aperture(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\t*res = mbus_state.pcie_mem_aperture;\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_get_pcie_mem_aperture);\n\nvoid mvebu_mbus_get_pcie_io_aperture(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\t*res = mbus_state.pcie_io_aperture;\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_get_pcie_io_aperture);\n\nint mvebu_mbus_get_dram_win_info(phys_addr_t phyaddr, u8 *target, u8 *attr)\n{\n\tconst struct mbus_dram_target_info *dram;\n\tint i;\n\n\t \n\tdram = mv_mbus_dram_info();\n\tif (!dram) {\n\t\tpr_err(\"missing DRAM information\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\tif (cs->base <= phyaddr &&\n\t\t\tphyaddr <= (cs->base + cs->size - 1)) {\n\t\t\t*target = dram->mbus_dram_target_id;\n\t\t\t*attr = cs->mbus_attr;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"invalid dram address %pa\\n\", &phyaddr);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_get_dram_win_info);\n\nint mvebu_mbus_get_io_win_info(phys_addr_t phyaddr, u32 *size, u8 *target,\n\t\t\t       u8 *attr)\n{\n\tint win;\n\n\tfor (win = 0; win < mbus_state.soc->num_wins; win++) {\n\t\tu64 wbase;\n\t\tint enabled;\n\n\t\tmvebu_mbus_read_window(&mbus_state, win, &enabled, &wbase,\n\t\t\t\t       size, target, attr, NULL);\n\n\t\tif (!enabled)\n\t\t\tcontinue;\n\n\t\tif (wbase <= phyaddr && phyaddr <= wbase + *size)\n\t\t\treturn win;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(mvebu_mbus_get_io_win_info);\n\nstatic __init int mvebu_mbus_debugfs_init(void)\n{\n\tstruct mvebu_mbus_state *s = &mbus_state;\n\n\t \n\tif (!s->mbuswins_base)\n\t\treturn 0;\n\n\ts->debugfs_root = debugfs_create_dir(\"mvebu-mbus\", NULL);\n\tif (s->debugfs_root) {\n\t\ts->debugfs_sdram = debugfs_create_file(\"sdram\", S_IRUGO,\n\t\t\t\t\t\t       s->debugfs_root, NULL,\n\t\t\t\t\t\t       &mvebu_sdram_debug_fops);\n\t\ts->debugfs_devs = debugfs_create_file(\"devices\", S_IRUGO,\n\t\t\t\t\t\t      s->debugfs_root, NULL,\n\t\t\t\t\t\t      &mvebu_devs_debug_fops);\n\t}\n\n\treturn 0;\n}\nfs_initcall(mvebu_mbus_debugfs_init);\n\nstatic int mvebu_mbus_suspend(void)\n{\n\tstruct mvebu_mbus_state *s = &mbus_state;\n\tint win;\n\n\tif (!s->mbusbridge_base)\n\t\treturn -ENODEV;\n\n\tfor (win = 0; win < s->soc->num_wins; win++) {\n\t\tvoid __iomem *addr = s->mbuswins_base +\n\t\t\ts->soc->win_cfg_offset(win);\n\t\tvoid __iomem *addr_rmp;\n\n\t\ts->wins[win].base = readl(addr + WIN_BASE_OFF);\n\t\ts->wins[win].ctrl = readl(addr + WIN_CTRL_OFF);\n\n\t\tif (!mvebu_mbus_window_is_remappable(s, win))\n\t\t\tcontinue;\n\n\t\taddr_rmp = s->mbuswins_base +\n\t\t\ts->soc->win_remap_offset(win);\n\n\t\ts->wins[win].remap_lo = readl(addr_rmp + WIN_REMAP_LO_OFF);\n\t\ts->wins[win].remap_hi = readl(addr_rmp + WIN_REMAP_HI_OFF);\n\t}\n\n\ts->mbus_bridge_ctrl = readl(s->mbusbridge_base +\n\t\t\t\t    MBUS_BRIDGE_CTRL_OFF);\n\ts->mbus_bridge_base = readl(s->mbusbridge_base +\n\t\t\t\t    MBUS_BRIDGE_BASE_OFF);\n\n\treturn 0;\n}\n\nstatic void mvebu_mbus_resume(void)\n{\n\tstruct mvebu_mbus_state *s = &mbus_state;\n\tint win;\n\n\twritel(s->mbus_bridge_ctrl,\n\t       s->mbusbridge_base + MBUS_BRIDGE_CTRL_OFF);\n\twritel(s->mbus_bridge_base,\n\t       s->mbusbridge_base + MBUS_BRIDGE_BASE_OFF);\n\n\tfor (win = 0; win < s->soc->num_wins; win++) {\n\t\tvoid __iomem *addr = s->mbuswins_base +\n\t\t\ts->soc->win_cfg_offset(win);\n\t\tvoid __iomem *addr_rmp;\n\n\t\twritel(s->wins[win].base, addr + WIN_BASE_OFF);\n\t\twritel(s->wins[win].ctrl, addr + WIN_CTRL_OFF);\n\n\t\tif (!mvebu_mbus_window_is_remappable(s, win))\n\t\t\tcontinue;\n\n\t\taddr_rmp = s->mbuswins_base +\n\t\t\ts->soc->win_remap_offset(win);\n\n\t\twritel(s->wins[win].remap_lo, addr_rmp + WIN_REMAP_LO_OFF);\n\t\twritel(s->wins[win].remap_hi, addr_rmp + WIN_REMAP_HI_OFF);\n\t}\n}\n\nstatic struct syscore_ops mvebu_mbus_syscore_ops = {\n\t.suspend\t= mvebu_mbus_suspend,\n\t.resume\t\t= mvebu_mbus_resume,\n};\n\nstatic int __init mvebu_mbus_common_init(struct mvebu_mbus_state *mbus,\n\t\t\t\t\t phys_addr_t mbuswins_phys_base,\n\t\t\t\t\t size_t mbuswins_size,\n\t\t\t\t\t phys_addr_t sdramwins_phys_base,\n\t\t\t\t\t size_t sdramwins_size,\n\t\t\t\t\t phys_addr_t mbusbridge_phys_base,\n\t\t\t\t\t size_t mbusbridge_size,\n\t\t\t\t\t bool is_coherent)\n{\n\tint win;\n\n\tmbus->mbuswins_base = ioremap(mbuswins_phys_base, mbuswins_size);\n\tif (!mbus->mbuswins_base)\n\t\treturn -ENOMEM;\n\n\tmbus->sdramwins_base = ioremap(sdramwins_phys_base, sdramwins_size);\n\tif (!mbus->sdramwins_base) {\n\t\tiounmap(mbus->mbuswins_base);\n\t\treturn -ENOMEM;\n\t}\n\n\tmbus->sdramwins_phys_base = sdramwins_phys_base;\n\n\tif (mbusbridge_phys_base) {\n\t\tmbus->mbusbridge_base = ioremap(mbusbridge_phys_base,\n\t\t\t\t\t\tmbusbridge_size);\n\t\tif (!mbus->mbusbridge_base) {\n\t\t\tiounmap(mbus->sdramwins_base);\n\t\t\tiounmap(mbus->mbuswins_base);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\tmbus->mbusbridge_base = NULL;\n\n\tfor (win = 0; win < mbus->soc->num_wins; win++)\n\t\tmvebu_mbus_disable_window(mbus, win);\n\n\tmbus->soc->setup_cpu_target(mbus);\n\tmvebu_mbus_setup_cpu_target_nooverlap(mbus);\n\n\tif (is_coherent)\n\t\twritel(UNIT_SYNC_BARRIER_ALL,\n\t\t       mbus->mbuswins_base + UNIT_SYNC_BARRIER_OFF);\n\n\tregister_syscore_ops(&mvebu_mbus_syscore_ops);\n\n\treturn 0;\n}\n\nint __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base,\n\t\t\t   size_t mbuswins_size,\n\t\t\t   phys_addr_t sdramwins_phys_base,\n\t\t\t   size_t sdramwins_size)\n{\n\tconst struct of_device_id *of_id;\n\n\tfor (of_id = of_mvebu_mbus_ids; of_id->compatible[0]; of_id++)\n\t\tif (!strcmp(of_id->compatible, soc))\n\t\t\tbreak;\n\n\tif (!of_id->compatible[0]) {\n\t\tpr_err(\"could not find a matching SoC family\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmbus_state.soc = of_id->data;\n\n\treturn mvebu_mbus_common_init(&mbus_state,\n\t\t\tmbuswins_phys_base,\n\t\t\tmbuswins_size,\n\t\t\tsdramwins_phys_base,\n\t\t\tsdramwins_size, 0, 0, false);\n}\n\n#ifdef CONFIG_OF\n \n#define CUSTOM(id) (((id) & 0xF0000000) >> 24)\n#define TARGET(id) (((id) & 0x0F000000) >> 24)\n#define ATTR(id)   (((id) & 0x00FF0000) >> 16)\n\nstatic int __init mbus_dt_setup_win(struct mvebu_mbus_state *mbus,\n\t\t\t\t    u32 base, u32 size,\n\t\t\t\t    u8 target, u8 attr)\n{\n\tif (!mvebu_mbus_window_conflicts(mbus, base, size, target, attr)) {\n\t\tpr_err(\"cannot add window '%04x:%04x', conflicts with another window\\n\",\n\t\t       target, attr);\n\t\treturn -EBUSY;\n\t}\n\n\tif (mvebu_mbus_alloc_window(mbus, base, size, MVEBU_MBUS_NO_REMAP,\n\t\t\t\t    target, attr)) {\n\t\tpr_err(\"cannot add window '%04x:%04x', too many windows\\n\",\n\t\t       target, attr);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int __init mbus_dt_setup(struct mvebu_mbus_state *mbus,\n\t\t\t\tstruct device_node *np)\n{\n\tint ret;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\n\tret = of_range_parser_init(&parser, np);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tfor_each_of_range(&parser, &range) {\n\t\tu32 windowid = upper_32_bits(range.bus_addr);\n\t\tu8 target, attr;\n\n\t\t \n\t\tif (CUSTOM(windowid))\n\t\t\tcontinue;\n\n\t\ttarget = TARGET(windowid);\n\t\tattr = ATTR(windowid);\n\n\t\tret = mbus_dt_setup_win(mbus, range.cpu_addr, range.size, target, attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __init mvebu_mbus_get_pcie_resources(struct device_node *np,\n\t\t\t\t\t\t struct resource *mem,\n\t\t\t\t\t\t struct resource *io)\n{\n\tu32 reg[2];\n\tint ret;\n\n\t \n\tmemset(mem, 0, sizeof(struct resource));\n\tmem->end = -1;\n\tmemset(io, 0, sizeof(struct resource));\n\tio->end = -1;\n\n\tret = of_property_read_u32_array(np, \"pcie-mem-aperture\", reg, ARRAY_SIZE(reg));\n\tif (!ret) {\n\t\tmem->start = reg[0];\n\t\tmem->end = mem->start + reg[1] - 1;\n\t\tmem->flags = IORESOURCE_MEM;\n\t}\n\n\tret = of_property_read_u32_array(np, \"pcie-io-aperture\", reg, ARRAY_SIZE(reg));\n\tif (!ret) {\n\t\tio->start = reg[0];\n\t\tio->end = io->start + reg[1] - 1;\n\t\tio->flags = IORESOURCE_IO;\n\t}\n}\n\nint __init mvebu_mbus_dt_init(bool is_coherent)\n{\n\tstruct resource mbuswins_res, sdramwins_res, mbusbridge_res;\n\tstruct device_node *np, *controller;\n\tconst struct of_device_id *of_id;\n\tconst __be32 *prop;\n\tint ret;\n\n\tnp = of_find_matching_node_and_match(NULL, of_mvebu_mbus_ids, &of_id);\n\tif (!np) {\n\t\tpr_err(\"could not find a matching SoC family\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmbus_state.soc = of_id->data;\n\n\tprop = of_get_property(np, \"controller\", NULL);\n\tif (!prop) {\n\t\tpr_err(\"required 'controller' property missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcontroller = of_find_node_by_phandle(be32_to_cpup(prop));\n\tif (!controller) {\n\t\tpr_err(\"could not find an 'mbus-controller' node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_address_to_resource(controller, 0, &mbuswins_res)) {\n\t\tpr_err(\"cannot get MBUS register address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_address_to_resource(controller, 1, &sdramwins_res)) {\n\t\tpr_err(\"cannot get SDRAM register address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(&mbusbridge_res, 0, sizeof(mbusbridge_res));\n\n\tif (mbus_state.soc->has_mbus_bridge) {\n\t\tif (of_address_to_resource(controller, 2, &mbusbridge_res))\n\t\t\tpr_warn(FW_WARN \"deprecated mbus-mvebu Device Tree, suspend/resume will not work\\n\");\n\t}\n\n\tmbus_state.hw_io_coherency = is_coherent;\n\n\t \n\tmvebu_mbus_get_pcie_resources(np, &mbus_state.pcie_mem_aperture,\n\t\t\t\t\t  &mbus_state.pcie_io_aperture);\n\n\tret = mvebu_mbus_common_init(&mbus_state,\n\t\t\t\t     mbuswins_res.start,\n\t\t\t\t     resource_size(&mbuswins_res),\n\t\t\t\t     sdramwins_res.start,\n\t\t\t\t     resource_size(&sdramwins_res),\n\t\t\t\t     mbusbridge_res.start,\n\t\t\t\t     resource_size(&mbusbridge_res),\n\t\t\t\t     is_coherent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mbus_dt_setup(&mbus_state, np);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}