{
  "module_name": "fsl-mc-msi.c",
  "hash_id": "3c647f0a27c0e8c07a45068d80b8ab59e80b2d88f7442b356a97c22416452f3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/fsl-mc-msi.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/acpi_iort.h>\n\n#include \"fsl-mc-private.h\"\n\n#ifdef GENERIC_MSI_DOMAIN_OPS\n \nstatic irq_hw_number_t fsl_mc_domain_calc_hwirq(struct fsl_mc_device *dev,\n\t\t\t\t\t\tstruct msi_desc *desc)\n{\n\t \n\treturn (irq_hw_number_t)(desc->msi_index + (dev->icid * 10000));\n}\n\nstatic void fsl_mc_msi_set_desc(msi_alloc_info_t *arg,\n\t\t\t\tstruct msi_desc *desc)\n{\n\targ->desc = desc;\n\targ->hwirq = fsl_mc_domain_calc_hwirq(to_fsl_mc_device(desc->dev),\n\t\t\t\t\t      desc);\n}\n#else\n#define fsl_mc_msi_set_desc NULL\n#endif\n\nstatic void fsl_mc_msi_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (!ops)\n\t\treturn;\n\n\t \n\tif (!ops->set_desc)\n\t\tops->set_desc = fsl_mc_msi_set_desc;\n}\n\nstatic void __fsl_mc_msi_write_msg(struct fsl_mc_device *mc_bus_dev,\n\t\t\t\t   struct fsl_mc_device_irq *mc_dev_irq,\n\t\t\t\t   struct msi_desc *msi_desc)\n{\n\tint error;\n\tstruct fsl_mc_device *owner_mc_dev = mc_dev_irq->mc_dev;\n\tstruct dprc_irq_cfg irq_cfg;\n\n\t \n\tif (msi_desc->msg.address_lo == 0x0 && msi_desc->msg.address_hi == 0x0)\n\t\treturn;\n\n\tif (!owner_mc_dev)\n\t\treturn;\n\n\tirq_cfg.paddr = ((u64)msi_desc->msg.address_hi << 32) |\n\t\t\tmsi_desc->msg.address_lo;\n\tirq_cfg.val = msi_desc->msg.data;\n\tirq_cfg.irq_num = msi_desc->irq;\n\n\tif (owner_mc_dev == mc_bus_dev) {\n\t\t \n\t\terror = dprc_set_irq(mc_bus_dev->mc_io,\n\t\t\t\t     MC_CMD_FLAG_INTR_DIS | MC_CMD_FLAG_PRI,\n\t\t\t\t     mc_bus_dev->mc_handle,\n\t\t\t\t     mc_dev_irq->dev_irq_index,\n\t\t\t\t     &irq_cfg);\n\t\tif (error < 0) {\n\t\t\tdev_err(&owner_mc_dev->dev,\n\t\t\t\t\"dprc_set_irq() failed: %d\\n\", error);\n\t\t}\n\t} else {\n\t\t \n\t\terror = dprc_set_obj_irq(mc_bus_dev->mc_io,\n\t\t\t\t\t MC_CMD_FLAG_INTR_DIS | MC_CMD_FLAG_PRI,\n\t\t\t\t\t mc_bus_dev->mc_handle,\n\t\t\t\t\t owner_mc_dev->obj_desc.type,\n\t\t\t\t\t owner_mc_dev->obj_desc.id,\n\t\t\t\t\t mc_dev_irq->dev_irq_index,\n\t\t\t\t\t &irq_cfg);\n\t\tif (error < 0) {\n\t\t\tdev_err(&owner_mc_dev->dev,\n\t\t\t\t\"dprc_obj_set_irq() failed: %d\\n\", error);\n\t\t}\n\t}\n}\n\n \nstatic void fsl_mc_msi_write_msg(struct irq_data *irq_data,\n\t\t\t\t struct msi_msg *msg)\n{\n\tstruct msi_desc *msi_desc = irq_data_get_msi_desc(irq_data);\n\tstruct fsl_mc_device *mc_bus_dev = to_fsl_mc_device(msi_desc->dev);\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\tstruct fsl_mc_device_irq *mc_dev_irq =\n\t\t&mc_bus->irq_resources[msi_desc->msi_index];\n\n\tmsi_desc->msg = *msg;\n\n\t \n\t__fsl_mc_msi_write_msg(mc_bus_dev, mc_dev_irq, msi_desc);\n}\n\nstatic void fsl_mc_msi_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tif (!chip)\n\t\treturn;\n\n\t \n\tif (!chip->irq_write_msi_msg)\n\t\tchip->irq_write_msi_msg = fsl_mc_msi_write_msg;\n}\n\n \nstruct irq_domain *fsl_mc_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\tstruct msi_domain_info *info,\n\t\t\t\t\t\tstruct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tif (WARN_ON((info->flags & MSI_FLAG_LEVEL_CAPABLE)))\n\t\tinfo->flags &= ~MSI_FLAG_LEVEL_CAPABLE;\n\tif (info->flags & MSI_FLAG_USE_DEF_DOM_OPS)\n\t\tfsl_mc_msi_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tfsl_mc_msi_update_chip_ops(info);\n\tinfo->flags |= MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS | MSI_FLAG_FREE_MSI_DESCS;\n\n\tdomain = msi_create_irq_domain(fwnode, info, parent);\n\tif (domain)\n\t\tirq_domain_update_bus_token(domain, DOMAIN_BUS_FSL_MC_MSI);\n\n\treturn domain;\n}\n\nstruct irq_domain *fsl_mc_find_msi_domain(struct device *dev)\n{\n\tstruct device *root_dprc_dev;\n\tstruct device *bus_dev;\n\tstruct irq_domain *msi_domain;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\tfsl_mc_get_root_dprc(dev, &root_dprc_dev);\n\tbus_dev = root_dprc_dev->parent;\n\n\tif (bus_dev->of_node) {\n\t\tmsi_domain = of_msi_map_get_device_domain(dev,\n\t\t\t\t\t\t  mc_dev->icid,\n\t\t\t\t\t\t  DOMAIN_BUS_FSL_MC_MSI);\n\n\t\t \n\t\tif (!msi_domain)\n\n\t\t\tmsi_domain = of_msi_get_domain(bus_dev,\n\t\t\t\t\t\tbus_dev->of_node,\n\t\t\t\t\t\tDOMAIN_BUS_FSL_MC_MSI);\n\t} else {\n\t\tmsi_domain = iort_get_device_domain(dev, mc_dev->icid,\n\t\t\t\t\t\t    DOMAIN_BUS_FSL_MC_MSI);\n\t}\n\n\treturn msi_domain;\n}\n\nint fsl_mc_msi_domain_alloc_irqs(struct device *dev,  unsigned int irq_count)\n{\n\tint error = msi_setup_device_data(dev);\n\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = msi_domain_alloc_irqs_range(dev, MSI_DEFAULT_DOMAIN, 0, irq_count - 1);\n\n\tif (error)\n\t\tdev_err(dev, \"Failed to allocate IRQs\\n\");\n\treturn error;\n}\n\nvoid fsl_mc_msi_domain_free_irqs(struct device *dev)\n{\n\tmsi_domain_free_irqs_all(dev, MSI_DEFAULT_DOMAIN);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}