{
  "module_name": "fsl-mc-bus.c",
  "hash_id": "bef29fa2aaec24e14aa75e91b1a90f6ce3b1074e1e5c68300bee710adeb44ed3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/fsl-mc-bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"fsl-mc: \" fmt\n\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/limits.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/acpi.h>\n#include <linux/iommu.h>\n#include <linux/dma-map-ops.h>\n\n#include \"fsl-mc-private.h\"\n\n \n#define FSL_MC_DEFAULT_DMA_MASK\t(~0ULL)\n\nstatic struct fsl_mc_version mc_version;\n\n \nstruct fsl_mc {\n\tstruct fsl_mc_device *root_mc_bus_dev;\n\tu8 num_translation_ranges;\n\tstruct fsl_mc_addr_translation_range *translation_ranges;\n\tvoid __iomem *fsl_mc_regs;\n};\n\n \nstruct fsl_mc_addr_translation_range {\n\tenum dprc_region_type mc_region_type;\n\tu64 start_mc_offset;\n\tu64 end_mc_offset;\n\tphys_addr_t start_phys_addr;\n};\n\n#define FSL_MC_GCR1\t0x0\n#define GCR1_P1_STOP\tBIT(31)\n#define GCR1_P2_STOP\tBIT(30)\n\n#define FSL_MC_FAPR\t0x28\n#define MC_FAPR_PL\tBIT(18)\n#define MC_FAPR_BMT\tBIT(17)\n\nstatic phys_addr_t mc_portal_base_phys_addr;\n\n \nstatic int fsl_mc_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tconst struct fsl_mc_device_id *id;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(drv);\n\tbool found = false;\n\n\t \n\tif (mc_dev->driver_override) {\n\t\tfound = !strcmp(mc_dev->driver_override, mc_drv->driver.name);\n\t\tgoto out;\n\t}\n\n\tif (!mc_drv->match_id_table)\n\t\tgoto out;\n\n\t \n\tif ((mc_dev->obj_desc.state & FSL_MC_OBJ_STATE_PLUGGED) == 0 &&\n\t    !fsl_mc_is_root_dprc(&mc_dev->dev))\n\t\tgoto out;\n\n\t \n\tfor (id = mc_drv->match_id_table; id->vendor != 0x0; id++) {\n\t\tif (id->vendor == mc_dev->obj_desc.vendor &&\n\t\t    strcmp(id->obj_type, mc_dev->obj_desc.type) == 0) {\n\t\t\tfound = true;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tdev_dbg(dev, \"%smatched\\n\", found ? \"\" : \"not \");\n\treturn found;\n}\n\n \nstatic int fsl_mc_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\tif (add_uevent_var(env, \"MODALIAS=fsl-mc:v%08Xd%s\",\n\t\t\t   mc_dev->obj_desc.vendor,\n\t\t\t   mc_dev->obj_desc.type))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int fsl_mc_dma_configure(struct device *dev)\n{\n\tstruct device *dma_dev = dev;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\n\tu32 input_id = mc_dev->icid;\n\tint ret;\n\n\twhile (dev_is_fsl_mc(dma_dev))\n\t\tdma_dev = dma_dev->parent;\n\n\tif (dev_of_node(dma_dev))\n\t\tret = of_dma_configure_id(dev, dma_dev->of_node, 0, &input_id);\n\telse\n\t\tret = acpi_dma_configure_id(dev, DEV_DMA_COHERENT, &input_id);\n\n\tif (!ret && !mc_drv->driver_managed_dma) {\n\t\tret = iommu_device_use_default_domain(dev);\n\t\tif (ret)\n\t\t\tarch_teardown_dma_ops(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void fsl_mc_dma_cleanup(struct device *dev)\n{\n\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\n\n\tif (!mc_drv->driver_managed_dma)\n\t\tiommu_device_unuse_default_domain(dev);\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\treturn sprintf(buf, \"fsl-mc:v%08Xd%s\\n\", mc_dev->obj_desc.vendor,\n\t\t       mc_dev->obj_desc.type);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tint ret;\n\n\tif (WARN_ON(dev->bus != &fsl_mc_bus_type))\n\t\treturn -EINVAL;\n\n\tret = driver_set_override(dev, &mc_dev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", mc_dev->driver_override);\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\nstatic struct attribute *fsl_mc_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(fsl_mc_dev);\n\nstatic int scan_fsl_mc_bus(struct device *dev, void *data)\n{\n\tstruct fsl_mc_device *root_mc_dev;\n\tstruct fsl_mc_bus *root_mc_bus;\n\n\tif (!fsl_mc_is_root_dprc(dev))\n\t\tgoto exit;\n\n\troot_mc_dev = to_fsl_mc_device(dev);\n\troot_mc_bus = to_fsl_mc_bus(root_mc_dev);\n\tmutex_lock(&root_mc_bus->scan_mutex);\n\tdprc_scan_objects(root_mc_dev, false);\n\tmutex_unlock(&root_mc_bus->scan_mutex);\n\nexit:\n\treturn 0;\n}\n\nstatic ssize_t rescan_store(const struct bus_type *bus,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tbus_for_each_dev(bus, NULL, NULL, scan_fsl_mc_bus);\n\n\treturn count;\n}\nstatic BUS_ATTR_WO(rescan);\n\nstatic int fsl_mc_bus_set_autorescan(struct device *dev, void *data)\n{\n\tstruct fsl_mc_device *root_mc_dev;\n\tunsigned long val;\n\tchar *buf = data;\n\n\tif (!fsl_mc_is_root_dprc(dev))\n\t\tgoto exit;\n\n\troot_mc_dev = to_fsl_mc_device(dev);\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tenable_dprc_irq(root_mc_dev);\n\telse\n\t\tdisable_dprc_irq(root_mc_dev);\n\nexit:\n\treturn 0;\n}\n\nstatic int fsl_mc_bus_get_autorescan(struct device *dev, void *data)\n{\n\tstruct fsl_mc_device *root_mc_dev;\n\tchar *buf = data;\n\n\tif (!fsl_mc_is_root_dprc(dev))\n\t\tgoto exit;\n\n\troot_mc_dev = to_fsl_mc_device(dev);\n\n\tsprintf(buf, \"%d\\n\", get_dprc_irq_state(root_mc_dev));\nexit:\n\treturn 0;\n}\n\nstatic ssize_t autorescan_store(const struct bus_type *bus,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tbus_for_each_dev(bus, NULL, (void *)buf, fsl_mc_bus_set_autorescan);\n\n\treturn count;\n}\n\nstatic ssize_t autorescan_show(const struct bus_type *bus, char *buf)\n{\n\tbus_for_each_dev(bus, NULL, (void *)buf, fsl_mc_bus_get_autorescan);\n\treturn strlen(buf);\n}\n\nstatic BUS_ATTR_RW(autorescan);\n\nstatic struct attribute *fsl_mc_bus_attrs[] = {\n\t&bus_attr_rescan.attr,\n\t&bus_attr_autorescan.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(fsl_mc_bus);\n\nstruct bus_type fsl_mc_bus_type = {\n\t.name = \"fsl-mc\",\n\t.match = fsl_mc_bus_match,\n\t.uevent = fsl_mc_bus_uevent,\n\t.dma_configure  = fsl_mc_dma_configure,\n\t.dma_cleanup = fsl_mc_dma_cleanup,\n\t.dev_groups = fsl_mc_dev_groups,\n\t.bus_groups = fsl_mc_bus_groups,\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_type);\n\nstruct device_type fsl_mc_bus_dprc_type = {\n\t.name = \"fsl_mc_bus_dprc\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dprc_type);\n\nstruct device_type fsl_mc_bus_dpni_type = {\n\t.name = \"fsl_mc_bus_dpni\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpni_type);\n\nstruct device_type fsl_mc_bus_dpio_type = {\n\t.name = \"fsl_mc_bus_dpio\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpio_type);\n\nstruct device_type fsl_mc_bus_dpsw_type = {\n\t.name = \"fsl_mc_bus_dpsw\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpsw_type);\n\nstruct device_type fsl_mc_bus_dpbp_type = {\n\t.name = \"fsl_mc_bus_dpbp\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpbp_type);\n\nstruct device_type fsl_mc_bus_dpcon_type = {\n\t.name = \"fsl_mc_bus_dpcon\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpcon_type);\n\nstruct device_type fsl_mc_bus_dpmcp_type = {\n\t.name = \"fsl_mc_bus_dpmcp\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpmcp_type);\n\nstruct device_type fsl_mc_bus_dpmac_type = {\n\t.name = \"fsl_mc_bus_dpmac\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpmac_type);\n\nstruct device_type fsl_mc_bus_dprtc_type = {\n\t.name = \"fsl_mc_bus_dprtc\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dprtc_type);\n\nstruct device_type fsl_mc_bus_dpseci_type = {\n\t.name = \"fsl_mc_bus_dpseci\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpseci_type);\n\nstruct device_type fsl_mc_bus_dpdmux_type = {\n\t.name = \"fsl_mc_bus_dpdmux\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpdmux_type);\n\nstruct device_type fsl_mc_bus_dpdcei_type = {\n\t.name = \"fsl_mc_bus_dpdcei\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpdcei_type);\n\nstruct device_type fsl_mc_bus_dpaiop_type = {\n\t.name = \"fsl_mc_bus_dpaiop\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpaiop_type);\n\nstruct device_type fsl_mc_bus_dpci_type = {\n\t.name = \"fsl_mc_bus_dpci\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpci_type);\n\nstruct device_type fsl_mc_bus_dpdmai_type = {\n\t.name = \"fsl_mc_bus_dpdmai\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpdmai_type);\n\nstruct device_type fsl_mc_bus_dpdbg_type = {\n\t.name = \"fsl_mc_bus_dpdbg\"\n};\nEXPORT_SYMBOL_GPL(fsl_mc_bus_dpdbg_type);\n\nstatic struct device_type *fsl_mc_get_device_type(const char *type)\n{\n\tstatic const struct {\n\t\tstruct device_type *dev_type;\n\t\tconst char *type;\n\t} dev_types[] = {\n\t\t{ &fsl_mc_bus_dprc_type, \"dprc\" },\n\t\t{ &fsl_mc_bus_dpni_type, \"dpni\" },\n\t\t{ &fsl_mc_bus_dpio_type, \"dpio\" },\n\t\t{ &fsl_mc_bus_dpsw_type, \"dpsw\" },\n\t\t{ &fsl_mc_bus_dpbp_type, \"dpbp\" },\n\t\t{ &fsl_mc_bus_dpcon_type, \"dpcon\" },\n\t\t{ &fsl_mc_bus_dpmcp_type, \"dpmcp\" },\n\t\t{ &fsl_mc_bus_dpmac_type, \"dpmac\" },\n\t\t{ &fsl_mc_bus_dprtc_type, \"dprtc\" },\n\t\t{ &fsl_mc_bus_dpseci_type, \"dpseci\" },\n\t\t{ &fsl_mc_bus_dpdmux_type, \"dpdmux\" },\n\t\t{ &fsl_mc_bus_dpdcei_type, \"dpdcei\" },\n\t\t{ &fsl_mc_bus_dpaiop_type, \"dpaiop\" },\n\t\t{ &fsl_mc_bus_dpci_type, \"dpci\" },\n\t\t{ &fsl_mc_bus_dpdmai_type, \"dpdmai\" },\n\t\t{ &fsl_mc_bus_dpdbg_type, \"dpdbg\" },\n\t\t{ NULL, NULL }\n\t};\n\tint i;\n\n\tfor (i = 0; dev_types[i].dev_type; i++)\n\t\tif (!strcmp(dev_types[i].type, type))\n\t\t\treturn dev_types[i].dev_type;\n\n\treturn NULL;\n}\n\nstatic int fsl_mc_driver_probe(struct device *dev)\n{\n\tstruct fsl_mc_driver *mc_drv;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tint error;\n\n\tmc_drv = to_fsl_mc_driver(dev->driver);\n\n\terror = mc_drv->probe(mc_dev);\n\tif (error < 0) {\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"%s failed: %d\\n\", __func__, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_mc_driver_remove(struct device *dev)\n{\n\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\tmc_drv->remove(mc_dev);\n\n\treturn 0;\n}\n\nstatic void fsl_mc_driver_shutdown(struct device *dev)\n{\n\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\tmc_drv->shutdown(mc_dev);\n}\n\n \nint __fsl_mc_driver_register(struct fsl_mc_driver *mc_driver,\n\t\t\t     struct module *owner)\n{\n\tint error;\n\n\tmc_driver->driver.owner = owner;\n\tmc_driver->driver.bus = &fsl_mc_bus_type;\n\n\tif (mc_driver->probe)\n\t\tmc_driver->driver.probe = fsl_mc_driver_probe;\n\n\tif (mc_driver->remove)\n\t\tmc_driver->driver.remove = fsl_mc_driver_remove;\n\n\tif (mc_driver->shutdown)\n\t\tmc_driver->driver.shutdown = fsl_mc_driver_shutdown;\n\n\terror = driver_register(&mc_driver->driver);\n\tif (error < 0) {\n\t\tpr_err(\"driver_register() failed for %s: %d\\n\",\n\t\t       mc_driver->driver.name, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__fsl_mc_driver_register);\n\n \nvoid fsl_mc_driver_unregister(struct fsl_mc_driver *mc_driver)\n{\n\tdriver_unregister(&mc_driver->driver);\n}\nEXPORT_SYMBOL_GPL(fsl_mc_driver_unregister);\n\n \nstatic int mc_get_version(struct fsl_mc_io *mc_io,\n\t\t\t  u32 cmd_flags,\n\t\t\t  struct fsl_mc_version *mc_ver_info)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dpmng_rsp_get_version *rsp_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPMNG_CMDID_GET_VERSION,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  0);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dpmng_rsp_get_version *)cmd.params;\n\tmc_ver_info->revision = le32_to_cpu(rsp_params->revision);\n\tmc_ver_info->major = le32_to_cpu(rsp_params->version_major);\n\tmc_ver_info->minor = le32_to_cpu(rsp_params->version_minor);\n\n\treturn 0;\n}\n\n \nstruct fsl_mc_version *fsl_mc_get_version(void)\n{\n\tif (mc_version.major)\n\t\treturn &mc_version;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_get_version);\n\n \nvoid fsl_mc_get_root_dprc(struct device *dev,\n\t\t\t struct device **root_dprc_dev)\n{\n\tif (!dev) {\n\t\t*root_dprc_dev = NULL;\n\t} else if (!dev_is_fsl_mc(dev)) {\n\t\t*root_dprc_dev = NULL;\n\t} else {\n\t\t*root_dprc_dev = dev;\n\t\twhile (dev_is_fsl_mc((*root_dprc_dev)->parent))\n\t\t\t*root_dprc_dev = (*root_dprc_dev)->parent;\n\t}\n}\n\nstatic int get_dprc_attr(struct fsl_mc_io *mc_io,\n\t\t\t int container_id, struct dprc_attributes *attr)\n{\n\tu16 dprc_handle;\n\tint error;\n\n\terror = dprc_open(mc_io, 0, container_id, &dprc_handle);\n\tif (error < 0) {\n\t\tdev_err(mc_io->dev, \"dprc_open() failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmemset(attr, 0, sizeof(struct dprc_attributes));\n\terror = dprc_get_attributes(mc_io, 0, dprc_handle, attr);\n\tif (error < 0) {\n\t\tdev_err(mc_io->dev, \"dprc_get_attributes() failed: %d\\n\",\n\t\t\terror);\n\t\tgoto common_cleanup;\n\t}\n\n\terror = 0;\n\ncommon_cleanup:\n\t(void)dprc_close(mc_io, 0, dprc_handle);\n\treturn error;\n}\n\nstatic int get_dprc_icid(struct fsl_mc_io *mc_io,\n\t\t\t int container_id, u32 *icid)\n{\n\tstruct dprc_attributes attr;\n\tint error;\n\n\terror = get_dprc_attr(mc_io, container_id, &attr);\n\tif (error == 0)\n\t\t*icid = attr.icid;\n\n\treturn error;\n}\n\nstatic int translate_mc_addr(struct fsl_mc_device *mc_dev,\n\t\t\t     enum dprc_region_type mc_region_type,\n\t\t\t     u64 mc_offset, phys_addr_t *phys_addr)\n{\n\tint i;\n\tstruct device *root_dprc_dev;\n\tstruct fsl_mc *mc;\n\n\tfsl_mc_get_root_dprc(&mc_dev->dev, &root_dprc_dev);\n\tmc = dev_get_drvdata(root_dprc_dev->parent);\n\n\tif (mc->num_translation_ranges == 0) {\n\t\t \n\t\t*phys_addr = mc_offset;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < mc->num_translation_ranges; i++) {\n\t\tstruct fsl_mc_addr_translation_range *range =\n\t\t\t&mc->translation_ranges[i];\n\n\t\tif (mc_region_type == range->mc_region_type &&\n\t\t    mc_offset >= range->start_mc_offset &&\n\t\t    mc_offset < range->end_mc_offset) {\n\t\t\t*phys_addr = range->start_phys_addr +\n\t\t\t\t     (mc_offset - range->start_mc_offset);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EFAULT;\n}\n\nstatic int fsl_mc_device_get_mmio_regions(struct fsl_mc_device *mc_dev,\n\t\t\t\t\t  struct fsl_mc_device *mc_bus_dev)\n{\n\tint i;\n\tint error;\n\tstruct resource *regions;\n\tstruct fsl_mc_obj_desc *obj_desc = &mc_dev->obj_desc;\n\tstruct device *parent_dev = mc_dev->dev.parent;\n\tenum dprc_region_type mc_region_type;\n\n\tif (is_fsl_mc_bus_dprc(mc_dev) ||\n\t    is_fsl_mc_bus_dpmcp(mc_dev)) {\n\t\tmc_region_type = DPRC_REGION_TYPE_MC_PORTAL;\n\t} else if (is_fsl_mc_bus_dpio(mc_dev)) {\n\t\tmc_region_type = DPRC_REGION_TYPE_QBMAN_PORTAL;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tregions = kmalloc_array(obj_desc->region_count,\n\t\t\t\tsizeof(regions[0]), GFP_KERNEL);\n\tif (!regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < obj_desc->region_count; i++) {\n\t\tstruct dprc_region_desc region_desc;\n\n\t\terror = dprc_get_obj_region(mc_bus_dev->mc_io,\n\t\t\t\t\t    0,\n\t\t\t\t\t    mc_bus_dev->mc_handle,\n\t\t\t\t\t    obj_desc->type,\n\t\t\t\t\t    obj_desc->id, i, &region_desc);\n\t\tif (error < 0) {\n\t\t\tdev_err(parent_dev,\n\t\t\t\t\"dprc_get_obj_region() failed: %d\\n\", error);\n\t\t\tgoto error_cleanup_regions;\n\t\t}\n\t\t \n\t\tif (region_desc.base_address) {\n\t\t\tregions[i].start = region_desc.base_address +\n\t\t\t\t\t\tregion_desc.base_offset;\n\t\t} else {\n\t\t\terror = translate_mc_addr(mc_dev, mc_region_type,\n\t\t\t\t\t  region_desc.base_offset,\n\t\t\t\t\t  &regions[i].start);\n\n\t\t\t \n\t\t\tif (is_fsl_mc_bus_dprc(mc_dev) &&\n\t\t\t    regions[i].start == region_desc.base_offset)\n\t\t\t\tregions[i].start += mc_portal_base_phys_addr;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tdev_err(parent_dev,\n\t\t\t\t\"Invalid MC offset: %#x (for %s.%d\\'s region %d)\\n\",\n\t\t\t\tregion_desc.base_offset,\n\t\t\t\tobj_desc->type, obj_desc->id, i);\n\t\t\tgoto error_cleanup_regions;\n\t\t}\n\n\t\tregions[i].end = regions[i].start + region_desc.size - 1;\n\t\tregions[i].name = \"fsl-mc object MMIO region\";\n\t\tregions[i].flags = region_desc.flags & IORESOURCE_BITS;\n\t\tregions[i].flags |= IORESOURCE_MEM;\n\t}\n\n\tmc_dev->regions = regions;\n\treturn 0;\n\nerror_cleanup_regions:\n\tkfree(regions);\n\treturn error;\n}\n\n \nbool fsl_mc_is_root_dprc(struct device *dev)\n{\n\tstruct device *root_dprc_dev;\n\n\tfsl_mc_get_root_dprc(dev, &root_dprc_dev);\n\tif (!root_dprc_dev)\n\t\treturn false;\n\treturn dev == root_dprc_dev;\n}\n\nstatic void fsl_mc_device_release(struct device *dev)\n{\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\tkfree(mc_dev->regions);\n\n\tif (is_fsl_mc_bus_dprc(mc_dev))\n\t\tkfree(to_fsl_mc_bus(mc_dev));\n\telse\n\t\tkfree(mc_dev);\n}\n\n \nint fsl_mc_device_add(struct fsl_mc_obj_desc *obj_desc,\n\t\t      struct fsl_mc_io *mc_io,\n\t\t      struct device *parent_dev,\n\t\t      struct fsl_mc_device **new_mc_dev)\n{\n\tint error;\n\tstruct fsl_mc_device *mc_dev = NULL;\n\tstruct fsl_mc_bus *mc_bus = NULL;\n\tstruct fsl_mc_device *parent_mc_dev;\n\n\tif (dev_is_fsl_mc(parent_dev))\n\t\tparent_mc_dev = to_fsl_mc_device(parent_dev);\n\telse\n\t\tparent_mc_dev = NULL;\n\n\tif (strcmp(obj_desc->type, \"dprc\") == 0) {\n\t\t \n\t\tmc_bus = kzalloc(sizeof(*mc_bus), GFP_KERNEL);\n\t\tif (!mc_bus)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_init(&mc_bus->scan_mutex);\n\t\tmc_dev = &mc_bus->mc_dev;\n\t} else {\n\t\t \n\t\tmc_dev = kzalloc(sizeof(*mc_dev), GFP_KERNEL);\n\t\tif (!mc_dev)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmc_dev->obj_desc = *obj_desc;\n\tmc_dev->mc_io = mc_io;\n\tdevice_initialize(&mc_dev->dev);\n\tmc_dev->dev.parent = parent_dev;\n\tmc_dev->dev.bus = &fsl_mc_bus_type;\n\tmc_dev->dev.release = fsl_mc_device_release;\n\tmc_dev->dev.type = fsl_mc_get_device_type(obj_desc->type);\n\tif (!mc_dev->dev.type) {\n\t\terror = -ENODEV;\n\t\tdev_err(parent_dev, \"unknown device type %s\\n\", obj_desc->type);\n\t\tgoto error_cleanup_dev;\n\t}\n\tdev_set_name(&mc_dev->dev, \"%s.%d\", obj_desc->type, obj_desc->id);\n\n\tif (strcmp(obj_desc->type, \"dprc\") == 0) {\n\t\tstruct fsl_mc_io *mc_io2;\n\n\t\tmc_dev->flags |= FSL_MC_IS_DPRC;\n\n\t\t \n\t\tif (parent_mc_dev) {\n\t\t\t \n\t\t\tmc_io2 = parent_mc_dev->mc_io;\n\t\t} else {\n\t\t\t \n\t\t\tif (!mc_io) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto error_cleanup_dev;\n\t\t\t}\n\n\t\t\tmc_io2 = mc_io;\n\t\t}\n\n\t\terror = get_dprc_icid(mc_io2, obj_desc->id, &mc_dev->icid);\n\t\tif (error < 0)\n\t\t\tgoto error_cleanup_dev;\n\t} else {\n\t\t \n\t\tmc_dev->icid = parent_mc_dev->icid;\n\t\tmc_dev->dma_mask = FSL_MC_DEFAULT_DMA_MASK;\n\t\tmc_dev->dev.dma_mask = &mc_dev->dma_mask;\n\t\tmc_dev->dev.coherent_dma_mask = mc_dev->dma_mask;\n\t\tdev_set_msi_domain(&mc_dev->dev,\n\t\t\t\t   dev_get_msi_domain(&parent_mc_dev->dev));\n\t}\n\n\t \n\tif (parent_mc_dev && obj_desc->region_count != 0) {\n\t\terror = fsl_mc_device_get_mmio_regions(mc_dev,\n\t\t\t\t\t\t       parent_mc_dev);\n\t\tif (error < 0)\n\t\t\tgoto error_cleanup_dev;\n\t}\n\n\t \n\terror = device_add(&mc_dev->dev);\n\tif (error < 0) {\n\t\tdev_err(parent_dev,\n\t\t\t\"device_add() failed for device %s: %d\\n\",\n\t\t\tdev_name(&mc_dev->dev), error);\n\t\tgoto error_cleanup_dev;\n\t}\n\n\tdev_dbg(parent_dev, \"added %s\\n\", dev_name(&mc_dev->dev));\n\n\t*new_mc_dev = mc_dev;\n\treturn 0;\n\nerror_cleanup_dev:\n\tkfree(mc_dev->regions);\n\tkfree(mc_bus);\n\tkfree(mc_dev);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_device_add);\n\nstatic struct notifier_block fsl_mc_nb;\n\n \nvoid fsl_mc_device_remove(struct fsl_mc_device *mc_dev)\n{\n\tkfree(mc_dev->driver_override);\n\tmc_dev->driver_override = NULL;\n\n\t \n\tdevice_del(&mc_dev->dev);\n\tput_device(&mc_dev->dev);\n}\nEXPORT_SYMBOL_GPL(fsl_mc_device_remove);\n\nstruct fsl_mc_device *fsl_mc_get_endpoint(struct fsl_mc_device *mc_dev,\n\t\t\t\t\t  u16 if_id)\n{\n\tstruct fsl_mc_device *mc_bus_dev, *endpoint;\n\tstruct fsl_mc_obj_desc endpoint_desc = {{ 0 }};\n\tstruct dprc_endpoint endpoint1 = {{ 0 }};\n\tstruct dprc_endpoint endpoint2 = {{ 0 }};\n\tint state, err;\n\n\tmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\n\tstrcpy(endpoint1.type, mc_dev->obj_desc.type);\n\tendpoint1.id = mc_dev->obj_desc.id;\n\tendpoint1.if_id = if_id;\n\n\terr = dprc_get_connection(mc_bus_dev->mc_io, 0,\n\t\t\t\t  mc_bus_dev->mc_handle,\n\t\t\t\t  &endpoint1, &endpoint2,\n\t\t\t\t  &state);\n\n\tif (err == -ENOTCONN || state == -1)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\tif (err < 0) {\n\t\tdev_err(&mc_bus_dev->dev, \"dprc_get_connection() = %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tstrcpy(endpoint_desc.type, endpoint2.type);\n\tendpoint_desc.id = endpoint2.id;\n\tendpoint = fsl_mc_device_lookup(&endpoint_desc, mc_bus_dev);\n\n\t \n\tif (!endpoint) {\n\t\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\n\t\tif (mutex_trylock(&mc_bus->scan_mutex)) {\n\t\t\terr = dprc_scan_objects(mc_bus_dev, true);\n\t\t\tmutex_unlock(&mc_bus->scan_mutex);\n\t\t}\n\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\tendpoint = fsl_mc_device_lookup(&endpoint_desc, mc_bus_dev);\n\t \n\tif (!endpoint)\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn endpoint;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_get_endpoint);\n\nstatic int get_mc_addr_translation_ranges(struct device *dev,\n\t\t\t\t\t  struct fsl_mc_addr_translation_range\n\t\t\t\t\t\t**ranges,\n\t\t\t\t\t  u8 *num_ranges)\n{\n\tstruct fsl_mc_addr_translation_range *r;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\n\tof_range_parser_init(&parser, dev->of_node);\n\t*num_ranges = of_range_count(&parser);\n\tif (!*num_ranges) {\n\t\t \n\t\t*ranges = NULL;\n\t\treturn 0;\n\t}\n\n\t*ranges = devm_kcalloc(dev, *num_ranges,\n\t\t\t       sizeof(struct fsl_mc_addr_translation_range),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ranges))\n\t\treturn -ENOMEM;\n\n\tr = *ranges;\n\tfor_each_of_range(&parser, &range) {\n\t\tr->mc_region_type = range.flags;\n\t\tr->start_mc_offset = range.bus_addr;\n\t\tr->end_mc_offset = range.bus_addr + range.size;\n\t\tr->start_phys_addr = range.cpu_addr;\n\t\tr++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_mc_bus_probe(struct platform_device *pdev)\n{\n\tstruct fsl_mc_obj_desc obj_desc;\n\tint error;\n\tstruct fsl_mc *mc;\n\tstruct fsl_mc_device *mc_bus_dev = NULL;\n\tstruct fsl_mc_io *mc_io = NULL;\n\tint container_id;\n\tphys_addr_t mc_portal_phys_addr;\n\tu32 mc_portal_size, mc_stream_id;\n\tstruct resource *plat_res;\n\n\tmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mc);\n\n\tplat_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (plat_res) {\n\t\tmc->fsl_mc_regs = devm_ioremap_resource(&pdev->dev, plat_res);\n\t\tif (IS_ERR(mc->fsl_mc_regs))\n\t\t\treturn PTR_ERR(mc->fsl_mc_regs);\n\t}\n\n\tif (mc->fsl_mc_regs) {\n\t\tif (IS_ENABLED(CONFIG_ACPI) && !dev_of_node(&pdev->dev)) {\n\t\t\tmc_stream_id = readl(mc->fsl_mc_regs + FSL_MC_FAPR);\n\t\t\t \n\t\t\tmc_stream_id = (mc_stream_id & 0xffff) |\n\t\t\t\t((mc_stream_id & (MC_FAPR_PL | MC_FAPR_BMT)) ?\n\t\t\t\t\tBIT(14) : 0);\n\t\t\terror = acpi_dma_configure_id(&pdev->dev,\n\t\t\t\t\t\t      DEV_DMA_COHERENT,\n\t\t\t\t\t\t      &mc_stream_id);\n\t\t\tif (error == -EPROBE_DEFER)\n\t\t\t\treturn error;\n\t\t\tif (error)\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"failed to configure dma: %d.\\n\",\n\t\t\t\t\t error);\n\t\t}\n\n\t\t \n\t\twritel(readl(mc->fsl_mc_regs + FSL_MC_GCR1) &\n\t\t\t     (~(GCR1_P1_STOP | GCR1_P2_STOP)),\n\t\t       mc->fsl_mc_regs + FSL_MC_GCR1);\n\t}\n\n\t \n\tplat_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tmc_portal_phys_addr = plat_res->start;\n\tmc_portal_size = resource_size(plat_res);\n\tmc_portal_base_phys_addr = mc_portal_phys_addr & ~0x3ffffff;\n\n\terror = fsl_create_mc_io(&pdev->dev, mc_portal_phys_addr,\n\t\t\t\t mc_portal_size, NULL,\n\t\t\t\t FSL_MC_IO_ATOMIC_CONTEXT_PORTAL, &mc_io);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = mc_get_version(mc_io, 0, &mc_version);\n\tif (error != 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"mc_get_version() failed with error %d\\n\", error);\n\t\tgoto error_cleanup_mc_io;\n\t}\n\n\tdev_info(&pdev->dev, \"MC firmware version: %u.%u.%u\\n\",\n\t\t mc_version.major, mc_version.minor, mc_version.revision);\n\n\tif (dev_of_node(&pdev->dev)) {\n\t\terror = get_mc_addr_translation_ranges(&pdev->dev,\n\t\t\t\t\t\t&mc->translation_ranges,\n\t\t\t\t\t\t&mc->num_translation_ranges);\n\t\tif (error < 0)\n\t\t\tgoto error_cleanup_mc_io;\n\t}\n\n\terror = dprc_get_container_id(mc_io, 0, &container_id);\n\tif (error < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"dprc_get_container_id() failed: %d\\n\", error);\n\t\tgoto error_cleanup_mc_io;\n\t}\n\n\tmemset(&obj_desc, 0, sizeof(struct fsl_mc_obj_desc));\n\terror = dprc_get_api_version(mc_io, 0,\n\t\t\t\t     &obj_desc.ver_major,\n\t\t\t\t     &obj_desc.ver_minor);\n\tif (error < 0)\n\t\tgoto error_cleanup_mc_io;\n\n\tobj_desc.vendor = FSL_MC_VENDOR_FREESCALE;\n\tstrcpy(obj_desc.type, \"dprc\");\n\tobj_desc.id = container_id;\n\tobj_desc.irq_count = 1;\n\tobj_desc.region_count = 0;\n\n\terror = fsl_mc_device_add(&obj_desc, mc_io, &pdev->dev, &mc_bus_dev);\n\tif (error < 0)\n\t\tgoto error_cleanup_mc_io;\n\n\tmc->root_mc_bus_dev = mc_bus_dev;\n\tmc_bus_dev->dev.fwnode = pdev->dev.fwnode;\n\treturn 0;\n\nerror_cleanup_mc_io:\n\tfsl_destroy_mc_io(mc_io);\n\treturn error;\n}\n\n \nstatic int fsl_mc_bus_remove(struct platform_device *pdev)\n{\n\tstruct fsl_mc *mc = platform_get_drvdata(pdev);\n\tstruct fsl_mc_io *mc_io;\n\n\tif (!fsl_mc_is_root_dprc(&mc->root_mc_bus_dev->dev))\n\t\treturn -EINVAL;\n\n\tmc_io = mc->root_mc_bus_dev->mc_io;\n\tfsl_mc_device_remove(mc->root_mc_bus_dev);\n\tfsl_destroy_mc_io(mc_io);\n\n\tbus_unregister_notifier(&fsl_mc_bus_type, &fsl_mc_nb);\n\n\tif (mc->fsl_mc_regs) {\n\t\t \n\t\twritel(readl(mc->fsl_mc_regs + FSL_MC_GCR1) |\n\t\t       (GCR1_P1_STOP | GCR1_P2_STOP),\n\t\t       mc->fsl_mc_regs + FSL_MC_GCR1);\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_mc_bus_shutdown(struct platform_device *pdev)\n{\n\tfsl_mc_bus_remove(pdev);\n}\n\nstatic const struct of_device_id fsl_mc_bus_match_table[] = {\n\t{.compatible = \"fsl,qoriq-mc\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, fsl_mc_bus_match_table);\n\nstatic const struct acpi_device_id fsl_mc_bus_acpi_match_table[] = {\n\t{\"NXP0008\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, fsl_mc_bus_acpi_match_table);\n\nstatic struct platform_driver fsl_mc_bus_driver = {\n\t.driver = {\n\t\t   .name = \"fsl_mc_bus\",\n\t\t   .pm = NULL,\n\t\t   .of_match_table = fsl_mc_bus_match_table,\n\t\t   .acpi_match_table = fsl_mc_bus_acpi_match_table,\n\t\t   },\n\t.probe = fsl_mc_bus_probe,\n\t.remove = fsl_mc_bus_remove,\n\t.shutdown = fsl_mc_bus_shutdown,\n};\n\nstatic int fsl_mc_bus_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct resource *res;\n\tvoid __iomem *fsl_mc_regs;\n\n\tif (action != BUS_NOTIFY_ADD_DEVICE)\n\t\treturn 0;\n\n\tif (!of_match_device(fsl_mc_bus_match_table, dev) &&\n\t    !acpi_match_device(fsl_mc_bus_acpi_match_table, dev))\n\t\treturn 0;\n\n\tres = platform_get_resource(to_platform_device(dev), IORESOURCE_MEM, 1);\n\tif (!res)\n\t\treturn 0;\n\n\tfsl_mc_regs = ioremap(res->start, resource_size(res));\n\tif (!fsl_mc_regs)\n\t\treturn 0;\n\n\t \n\twritel(readl(fsl_mc_regs + FSL_MC_GCR1) | (GCR1_P1_STOP | GCR1_P2_STOP),\n\t       fsl_mc_regs + FSL_MC_GCR1);\n\tiounmap(fsl_mc_regs);\n\n\treturn 0;\n}\n\nstatic struct notifier_block fsl_mc_nb = {\n\t.notifier_call = fsl_mc_bus_notifier,\n};\n\nstatic int __init fsl_mc_bus_driver_init(void)\n{\n\tint error;\n\n\terror = bus_register(&fsl_mc_bus_type);\n\tif (error < 0) {\n\t\tpr_err(\"bus type registration failed: %d\\n\", error);\n\t\tgoto error_cleanup_cache;\n\t}\n\n\terror = platform_driver_register(&fsl_mc_bus_driver);\n\tif (error < 0) {\n\t\tpr_err(\"platform_driver_register() failed: %d\\n\", error);\n\t\tgoto error_cleanup_bus;\n\t}\n\n\terror = dprc_driver_init();\n\tif (error < 0)\n\t\tgoto error_cleanup_driver;\n\n\terror = fsl_mc_allocator_driver_init();\n\tif (error < 0)\n\t\tgoto error_cleanup_dprc_driver;\n\n\treturn bus_register_notifier(&platform_bus_type, &fsl_mc_nb);\n\nerror_cleanup_dprc_driver:\n\tdprc_driver_exit();\n\nerror_cleanup_driver:\n\tplatform_driver_unregister(&fsl_mc_bus_driver);\n\nerror_cleanup_bus:\n\tbus_unregister(&fsl_mc_bus_type);\n\nerror_cleanup_cache:\n\treturn error;\n}\npostcore_initcall(fsl_mc_bus_driver_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}