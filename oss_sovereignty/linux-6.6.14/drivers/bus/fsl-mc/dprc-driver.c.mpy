{
  "module_name": "dprc-driver.c",
  "hash_id": "a63f2f303fd53e92536396d51aec7242cbbc22e8fc29fcac2f978d638e412019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/dprc-driver.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/fsl/mc.h>\n\n#include \"fsl-mc-private.h\"\n\n#define FSL_MC_DPRC_DRIVER_NAME    \"fsl_mc_dprc\"\n\nstruct fsl_mc_child_objs {\n\tint child_count;\n\tstruct fsl_mc_obj_desc *child_array;\n};\n\nstatic bool fsl_mc_device_match(struct fsl_mc_device *mc_dev,\n\t\t\t\tstruct fsl_mc_obj_desc *obj_desc)\n{\n\treturn mc_dev->obj_desc.id == obj_desc->id &&\n\t       strcmp(mc_dev->obj_desc.type, obj_desc->type) == 0;\n}\n\nstatic bool fsl_mc_obj_desc_is_allocatable(struct fsl_mc_obj_desc *obj)\n{\n\tif (strcmp(obj->type, \"dpmcp\") == 0 ||\n\t    strcmp(obj->type, \"dpcon\") == 0 ||\n\t    strcmp(obj->type, \"dpbp\") == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int __fsl_mc_device_remove_if_not_in_mc(struct device *dev, void *data)\n{\n\tint i;\n\tstruct fsl_mc_child_objs *objs;\n\tstruct fsl_mc_device *mc_dev;\n\n\tif (!dev_is_fsl_mc(dev))\n\t\treturn 0;\n\n\tmc_dev = to_fsl_mc_device(dev);\n\tobjs = data;\n\n\tfor (i = 0; i < objs->child_count; i++) {\n\t\tstruct fsl_mc_obj_desc *obj_desc = &objs->child_array[i];\n\n\t\tif (strlen(obj_desc->type) != 0 &&\n\t\t    fsl_mc_device_match(mc_dev, obj_desc))\n\t\t\tbreak;\n\t}\n\n\tif (i == objs->child_count)\n\t\tfsl_mc_device_remove(mc_dev);\n\n\treturn 0;\n}\n\nstatic int __fsl_mc_device_remove(struct device *dev, void *data)\n{\n\tif (!dev_is_fsl_mc(dev))\n\t\treturn 0;\n\n\tfsl_mc_device_remove(to_fsl_mc_device(dev));\n\treturn 0;\n}\n\n \nvoid dprc_remove_devices(struct fsl_mc_device *mc_bus_dev,\n\t\t\t struct fsl_mc_obj_desc *obj_desc_array,\n\t\t\t int num_child_objects_in_mc)\n{\n\tif (num_child_objects_in_mc != 0) {\n\t\t \n\t\tstruct fsl_mc_child_objs objs;\n\n\t\tobjs.child_count = num_child_objects_in_mc;\n\t\tobjs.child_array = obj_desc_array;\n\t\tdevice_for_each_child(&mc_bus_dev->dev, &objs,\n\t\t\t\t      __fsl_mc_device_remove_if_not_in_mc);\n\t} else {\n\t\t \n\t\tdevice_for_each_child(&mc_bus_dev->dev, NULL,\n\t\t\t\t      __fsl_mc_device_remove);\n\t}\n}\nEXPORT_SYMBOL_GPL(dprc_remove_devices);\n\nstatic int __fsl_mc_device_match(struct device *dev, void *data)\n{\n\tstruct fsl_mc_obj_desc *obj_desc = data;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\n\treturn fsl_mc_device_match(mc_dev, obj_desc);\n}\n\nstruct fsl_mc_device *fsl_mc_device_lookup(struct fsl_mc_obj_desc *obj_desc,\n\t\t\t\t\t   struct fsl_mc_device *mc_bus_dev)\n{\n\tstruct device *dev;\n\n\tdev = device_find_child(&mc_bus_dev->dev, obj_desc,\n\t\t\t\t__fsl_mc_device_match);\n\n\treturn dev ? to_fsl_mc_device(dev) : NULL;\n}\n\n \nstatic void check_plugged_state_change(struct fsl_mc_device *mc_dev,\n\t\t\t\t       struct fsl_mc_obj_desc *obj_desc)\n{\n\tint error;\n\tu32 plugged_flag_at_mc =\n\t\t\tobj_desc->state & FSL_MC_OBJ_STATE_PLUGGED;\n\n\tif (plugged_flag_at_mc !=\n\t    (mc_dev->obj_desc.state & FSL_MC_OBJ_STATE_PLUGGED)) {\n\t\tif (plugged_flag_at_mc) {\n\t\t\tmc_dev->obj_desc.state |= FSL_MC_OBJ_STATE_PLUGGED;\n\t\t\terror = device_attach(&mc_dev->dev);\n\t\t\tif (error < 0) {\n\t\t\t\tdev_err(&mc_dev->dev,\n\t\t\t\t\t\"device_attach() failed: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t}\n\t\t} else {\n\t\t\tmc_dev->obj_desc.state &= ~FSL_MC_OBJ_STATE_PLUGGED;\n\t\t\tdevice_release_driver(&mc_dev->dev);\n\t\t}\n\t}\n}\n\nstatic void fsl_mc_obj_device_add(struct fsl_mc_device *mc_bus_dev,\n\t\t\t\t  struct fsl_mc_obj_desc *obj_desc)\n{\n\tint error;\n\tstruct fsl_mc_device *child_dev;\n\n\t \n\tchild_dev = fsl_mc_device_lookup(obj_desc, mc_bus_dev);\n\tif (child_dev) {\n\t\tcheck_plugged_state_change(child_dev, obj_desc);\n\t\tput_device(&child_dev->dev);\n\t} else {\n\t\terror = fsl_mc_device_add(obj_desc, NULL, &mc_bus_dev->dev,\n\t\t\t\t\t  &child_dev);\n\t\tif (error < 0)\n\t\t\treturn;\n\t}\n}\n\n \nstatic void dprc_add_new_devices(struct fsl_mc_device *mc_bus_dev,\n\t\t\t\t struct fsl_mc_obj_desc *obj_desc_array,\n\t\t\t\t int num_child_objects_in_mc)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < num_child_objects_in_mc; i++) {\n\t\tstruct fsl_mc_obj_desc *obj_desc = &obj_desc_array[i];\n\n\t\tif (strlen(obj_desc->type) > 0 &&\n\t\t    fsl_mc_obj_desc_is_allocatable(obj_desc))\n\t\t\tfsl_mc_obj_device_add(mc_bus_dev, obj_desc);\n\t}\n\n\tfor (i = 0; i < num_child_objects_in_mc; i++) {\n\t\tstruct fsl_mc_obj_desc *obj_desc = &obj_desc_array[i];\n\n\t\tif (strlen(obj_desc->type) > 0 &&\n\t\t    !fsl_mc_obj_desc_is_allocatable(obj_desc))\n\t\t\tfsl_mc_obj_device_add(mc_bus_dev, obj_desc);\n\t}\n}\n\n \nint dprc_scan_objects(struct fsl_mc_device *mc_bus_dev,\n\t\t      bool alloc_interrupts)\n{\n\tint num_child_objects;\n\tint dprc_get_obj_failures;\n\tint error;\n\tunsigned int irq_count = mc_bus_dev->obj_desc.irq_count;\n\tstruct fsl_mc_obj_desc *child_obj_desc_array = NULL;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\n\terror = dprc_get_obj_count(mc_bus_dev->mc_io,\n\t\t\t\t   0,\n\t\t\t\t   mc_bus_dev->mc_handle,\n\t\t\t\t   &num_child_objects);\n\tif (error < 0) {\n\t\tdev_err(&mc_bus_dev->dev, \"dprc_get_obj_count() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (num_child_objects != 0) {\n\t\tint i;\n\n\t\tchild_obj_desc_array =\n\t\t    devm_kmalloc_array(&mc_bus_dev->dev, num_child_objects,\n\t\t\t\t       sizeof(*child_obj_desc_array),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!child_obj_desc_array)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tdprc_get_obj_failures = 0;\n\t\tfor (i = 0; i < num_child_objects; i++) {\n\t\t\tstruct fsl_mc_obj_desc *obj_desc =\n\t\t\t    &child_obj_desc_array[i];\n\n\t\t\terror = dprc_get_obj(mc_bus_dev->mc_io,\n\t\t\t\t\t     0,\n\t\t\t\t\t     mc_bus_dev->mc_handle,\n\t\t\t\t\t     i, obj_desc);\n\t\t\tif (error < 0) {\n\t\t\t\tdev_err(&mc_bus_dev->dev,\n\t\t\t\t\t\"dprc_get_obj(i=%d) failed: %d\\n\",\n\t\t\t\t\ti, error);\n\t\t\t\t \n\t\t\t\tobj_desc->type[0] = '\\0';\n\t\t\t\tobj_desc->id = error;\n\t\t\t\tdprc_get_obj_failures++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((strcmp(obj_desc->type, \"dpseci\") == 0) &&\n\t\t\t    (obj_desc->ver_major < 4))\n\t\t\t\tobj_desc->flags |=\n\t\t\t\t\tFSL_MC_OBJ_FLAG_NO_MEM_SHAREABILITY;\n\n\t\t\tirq_count += obj_desc->irq_count;\n\t\t\tdev_dbg(&mc_bus_dev->dev,\n\t\t\t\t\"Discovered object: type %s, id %d\\n\",\n\t\t\t\tobj_desc->type, obj_desc->id);\n\t\t}\n\n\t\tif (dprc_get_obj_failures != 0) {\n\t\t\tdev_err(&mc_bus_dev->dev,\n\t\t\t\t\"%d out of %d devices could not be retrieved\\n\",\n\t\t\t\tdprc_get_obj_failures, num_child_objects);\n\t\t}\n\t}\n\n\t \n\tif (dev_get_msi_domain(&mc_bus_dev->dev)) {\n\t\tif (irq_count > FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS) {\n\t\t\tdev_warn(&mc_bus_dev->dev,\n\t\t\t\t \"IRQs needed (%u) exceed IRQs preallocated (%u)\\n\",\n\t\t\t\t irq_count, FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\n\t\t}\n\n\t\tif (alloc_interrupts && !mc_bus->irq_resources) {\n\t\t\terror = fsl_mc_populate_irq_pool(mc_bus_dev,\n\t\t\t\t\t FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tdprc_remove_devices(mc_bus_dev, child_obj_desc_array,\n\t\t\t    num_child_objects);\n\n\tdprc_add_new_devices(mc_bus_dev, child_obj_desc_array,\n\t\t\t     num_child_objects);\n\n\tif (child_obj_desc_array)\n\t\tdevm_kfree(&mc_bus_dev->dev, child_obj_desc_array);\n\n\treturn 0;\n}\n\n \nint dprc_scan_container(struct fsl_mc_device *mc_bus_dev,\n\t\t\tbool alloc_interrupts)\n{\n\tint error = 0;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\n\tfsl_mc_init_all_resource_pools(mc_bus_dev);\n\n\t \n\tmutex_lock(&mc_bus->scan_mutex);\n\terror = dprc_scan_objects(mc_bus_dev, alloc_interrupts);\n\tmutex_unlock(&mc_bus->scan_mutex);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(dprc_scan_container);\n\n \nstatic irqreturn_t dprc_irq0_handler(int irq_num, void *arg)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t dprc_irq0_handler_thread(int irq_num, void *arg)\n{\n\tint error;\n\tu32 status;\n\tstruct device *dev = arg;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\tstruct fsl_mc_io *mc_io = mc_dev->mc_io;\n\tint irq = mc_dev->irqs[0]->virq;\n\n\tdev_dbg(dev, \"DPRC IRQ %d triggered on CPU %u\\n\",\n\t\tirq_num, smp_processor_id());\n\n\tif (!(mc_dev->flags & FSL_MC_IS_DPRC))\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&mc_bus->scan_mutex);\n\tif (irq != (u32)irq_num)\n\t\tgoto out;\n\n\tstatus = 0;\n\terror = dprc_get_irq_status(mc_io, 0, mc_dev->mc_handle, 0,\n\t\t\t\t    &status);\n\tif (error < 0) {\n\t\tdev_err(dev,\n\t\t\t\"dprc_get_irq_status() failed: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\terror = dprc_clear_irq_status(mc_io, 0, mc_dev->mc_handle, 0,\n\t\t\t\t      status);\n\tif (error < 0) {\n\t\tdev_err(dev,\n\t\t\t\"dprc_clear_irq_status() failed: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tif (status & (DPRC_IRQ_EVENT_OBJ_ADDED |\n\t\t      DPRC_IRQ_EVENT_OBJ_REMOVED |\n\t\t      DPRC_IRQ_EVENT_CONTAINER_DESTROYED |\n\t\t      DPRC_IRQ_EVENT_OBJ_DESTROYED |\n\t\t      DPRC_IRQ_EVENT_OBJ_CREATED)) {\n\n\t\terror = dprc_scan_objects(mc_dev, true);\n\t\tif (error < 0) {\n\t\t\t \n\t\t\tif (error != -ENXIO) {\n\t\t\t\tdev_err(dev, \"dprc_scan_objects() failed: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t}\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mc_bus->scan_mutex);\n\treturn IRQ_HANDLED;\n}\n\n \nint disable_dprc_irq(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\tint error;\n\tstruct fsl_mc_io *mc_io = mc_dev->mc_io;\n\n\t \n\terror = dprc_set_irq_enable(mc_io, 0, mc_dev->mc_handle, 0, 0);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Disabling DPRC IRQ failed: dprc_set_irq_enable() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = dprc_set_irq_mask(mc_io, 0, mc_dev->mc_handle, 0, 0x0);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Disabling DPRC IRQ failed: dprc_set_irq_mask() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = dprc_clear_irq_status(mc_io, 0, mc_dev->mc_handle, 0, ~0x0U);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Disabling DPRC IRQ failed: dprc_clear_irq_status() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tmc_bus->irq_enabled = 0;\n\n\treturn 0;\n}\n\nint get_dprc_irq_state(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\n\treturn mc_bus->irq_enabled;\n}\n\nstatic int register_dprc_irq_handler(struct fsl_mc_device *mc_dev)\n{\n\tint error;\n\tstruct fsl_mc_device_irq *irq = mc_dev->irqs[0];\n\n\t \n\terror = devm_request_threaded_irq(&mc_dev->dev,\n\t\t\t\t\t  irq->virq,\n\t\t\t\t\t  dprc_irq0_handler,\n\t\t\t\t\t  dprc_irq0_handler_thread,\n\t\t\t\t\t  IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\t  dev_name(&mc_dev->dev),\n\t\t\t\t\t  &mc_dev->dev);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"devm_request_threaded_irq() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nint enable_dprc_irq(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\tint error;\n\n\t \n\terror = dprc_set_irq_mask(mc_dev->mc_io, 0, mc_dev->mc_handle, 0,\n\t\t\t\t  ~0x0u);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Enabling DPRC IRQ failed: dprc_set_irq_mask() failed: %d\\n\",\n\t\t\terror);\n\n\t\treturn error;\n\t}\n\n\t \n\terror = dprc_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle, 0, 1);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Enabling DPRC IRQ failed: dprc_set_irq_enable() failed: %d\\n\",\n\t\t\terror);\n\n\t\treturn error;\n\t}\n\n\tmc_bus->irq_enabled = 1;\n\n\treturn 0;\n}\n\n \nstatic int dprc_setup_irq(struct fsl_mc_device *mc_dev)\n{\n\tint error;\n\n\terror = fsl_mc_allocate_irqs(mc_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = disable_dprc_irq(mc_dev);\n\tif (error < 0)\n\t\tgoto error_free_irqs;\n\n\terror = register_dprc_irq_handler(mc_dev);\n\tif (error < 0)\n\t\tgoto error_free_irqs;\n\n\terror = enable_dprc_irq(mc_dev);\n\tif (error < 0)\n\t\tgoto error_free_irqs;\n\n\treturn 0;\n\nerror_free_irqs:\n\tfsl_mc_free_irqs(mc_dev);\n\treturn error;\n}\n\n \n\nint dprc_setup(struct fsl_mc_device *mc_dev)\n{\n\tstruct device *parent_dev = mc_dev->dev.parent;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\tstruct irq_domain *mc_msi_domain;\n\tbool mc_io_created = false;\n\tbool msi_domain_set = false;\n\tbool uapi_created = false;\n\tu16 major_ver, minor_ver;\n\tsize_t region_size;\n\tint error;\n\n\tif (!is_fsl_mc_bus_dprc(mc_dev))\n\t\treturn -EINVAL;\n\n\tif (dev_get_msi_domain(&mc_dev->dev))\n\t\treturn -EINVAL;\n\n\tif (!mc_dev->mc_io) {\n\t\t \n\t\tif (!dev_is_fsl_mc(parent_dev))\n\t\t\treturn -EINVAL;\n\n\t\tif (mc_dev->obj_desc.region_count == 0)\n\t\t\treturn -EINVAL;\n\n\t\tregion_size = resource_size(mc_dev->regions);\n\n\t\terror = fsl_create_mc_io(&mc_dev->dev,\n\t\t\t\t\t mc_dev->regions[0].start,\n\t\t\t\t\t region_size,\n\t\t\t\t\t NULL,\n\t\t\t\t\t FSL_MC_IO_ATOMIC_CONTEXT_PORTAL,\n\t\t\t\t\t &mc_dev->mc_io);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tmc_io_created = true;\n\t} else {\n\t\terror = fsl_mc_uapi_create_device_file(mc_bus);\n\t\tif (error < 0)\n\t\t\treturn -EPROBE_DEFER;\n\t\tuapi_created = true;\n\t}\n\n\tmc_msi_domain = fsl_mc_find_msi_domain(&mc_dev->dev);\n\tif (!mc_msi_domain) {\n\t\tdev_warn(&mc_dev->dev,\n\t\t\t \"WARNING: MC bus without interrupt support\\n\");\n\t} else {\n\t\tdev_set_msi_domain(&mc_dev->dev, mc_msi_domain);\n\t\tmsi_domain_set = true;\n\t}\n\n\terror = dprc_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,\n\t\t\t  &mc_dev->mc_handle);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev, \"dprc_open() failed: %d\\n\", error);\n\t\tgoto error_cleanup_msi_domain;\n\t}\n\n\terror = dprc_get_attributes(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t    &mc_bus->dprc_attr);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev, \"dprc_get_attributes() failed: %d\\n\",\n\t\t\terror);\n\t\tgoto error_cleanup_open;\n\t}\n\n\terror = dprc_get_api_version(mc_dev->mc_io, 0,\n\t\t\t\t     &major_ver,\n\t\t\t\t     &minor_ver);\n\tif (error < 0) {\n\t\tdev_err(&mc_dev->dev, \"dprc_get_api_version() failed: %d\\n\",\n\t\t\terror);\n\t\tgoto error_cleanup_open;\n\t}\n\n\tif (major_ver < DPRC_MIN_VER_MAJOR) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"ERROR: DPRC version %d.%d not supported\\n\",\n\t\t\tmajor_ver, minor_ver);\n\t\terror = -ENOTSUPP;\n\t\tgoto error_cleanup_open;\n\t}\n\n\treturn 0;\n\nerror_cleanup_open:\n\t(void)dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\n\nerror_cleanup_msi_domain:\n\tif (msi_domain_set)\n\t\tdev_set_msi_domain(&mc_dev->dev, NULL);\n\n\tif (mc_io_created) {\n\t\tfsl_destroy_mc_io(mc_dev->mc_io);\n\t\tmc_dev->mc_io = NULL;\n\t}\n\n\tif (uapi_created)\n\t\tfsl_mc_uapi_remove_device_file(mc_bus);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(dprc_setup);\n\n \nstatic int dprc_probe(struct fsl_mc_device *mc_dev)\n{\n\tint error;\n\n\terror = dprc_setup(mc_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\terror = dprc_scan_container(mc_dev, true);\n\tif (error < 0)\n\t\tgoto dprc_cleanup;\n\n\t \n\terror = dprc_setup_irq(mc_dev);\n\tif (error < 0)\n\t\tgoto scan_cleanup;\n\n\tdev_info(&mc_dev->dev, \"DPRC device bound to driver\");\n\treturn 0;\n\nscan_cleanup:\n\tdevice_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);\ndprc_cleanup:\n\tdprc_cleanup(mc_dev);\n\treturn error;\n}\n\n \nstatic void dprc_teardown_irq(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_device_irq *irq = mc_dev->irqs[0];\n\n\t(void)disable_dprc_irq(mc_dev);\n\n\tdevm_free_irq(&mc_dev->dev, irq->virq, &mc_dev->dev);\n\n\tfsl_mc_free_irqs(mc_dev);\n}\n\n \n\nint dprc_cleanup(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\tint error;\n\n\t \n\tif (!is_fsl_mc_bus_dprc(mc_dev))\n\t\treturn -EINVAL;\n\n\tif (dev_get_msi_domain(&mc_dev->dev)) {\n\t\tfsl_mc_cleanup_irq_pool(mc_dev);\n\t\tdev_set_msi_domain(&mc_dev->dev, NULL);\n\t}\n\n\tfsl_mc_cleanup_all_resource_pools(mc_dev);\n\n\t \n\tif (!mc_dev->mc_io) {\n\t\tdev_err(&mc_dev->dev, \"mc_io is NULL, tear down cannot be performed in firmware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\n\tif (error < 0)\n\t\tdev_err(&mc_dev->dev, \"dprc_close() failed: %d\\n\", error);\n\n\tif (!fsl_mc_is_root_dprc(&mc_dev->dev)) {\n\t\tfsl_destroy_mc_io(mc_dev->mc_io);\n\t\tmc_dev->mc_io = NULL;\n\t} else {\n\t\tfsl_mc_uapi_remove_device_file(mc_bus);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dprc_cleanup);\n\n \nstatic void dprc_remove(struct fsl_mc_device *mc_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\n\n\tif (!mc_bus->irq_resources) {\n\t\tdev_err(&mc_dev->dev, \"No irq resources, so unbinding the device failed\\n\");\n\t\treturn;\n\t}\n\n\tif (dev_get_msi_domain(&mc_dev->dev))\n\t\tdprc_teardown_irq(mc_dev);\n\n\tdevice_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);\n\n\tdprc_cleanup(mc_dev);\n\n\tdev_info(&mc_dev->dev, \"DPRC device unbound from driver\");\n}\n\nstatic const struct fsl_mc_device_id match_id_table[] = {\n\t{\n\t .vendor = FSL_MC_VENDOR_FREESCALE,\n\t .obj_type = \"dprc\"},\n\t{.vendor = 0x0},\n};\n\nstatic struct fsl_mc_driver dprc_driver = {\n\t.driver = {\n\t\t   .name = FSL_MC_DPRC_DRIVER_NAME,\n\t\t   .owner = THIS_MODULE,\n\t\t   .pm = NULL,\n\t\t   },\n\t.match_id_table = match_id_table,\n\t.probe = dprc_probe,\n\t.remove = dprc_remove,\n};\n\nint __init dprc_driver_init(void)\n{\n\treturn fsl_mc_driver_register(&dprc_driver);\n}\n\nvoid dprc_driver_exit(void)\n{\n\tfsl_mc_driver_unregister(&dprc_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}