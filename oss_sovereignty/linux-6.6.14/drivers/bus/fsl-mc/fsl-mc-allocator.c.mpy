{
  "module_name": "fsl-mc-allocator.c",
  "hash_id": "6b918846e254c45d329dd794231c8b38dfb0576de85d268d2e8d58448e2b09fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/fsl-mc-allocator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/fsl/mc.h>\n\n#include \"fsl-mc-private.h\"\n\nstatic bool __must_check fsl_mc_is_allocatable(struct fsl_mc_device *mc_dev)\n{\n\treturn is_fsl_mc_bus_dpbp(mc_dev) ||\n\t       is_fsl_mc_bus_dpmcp(mc_dev) ||\n\t       is_fsl_mc_bus_dpcon(mc_dev);\n}\n\n \nstatic int __must_check fsl_mc_resource_pool_add_device(struct fsl_mc_bus\n\t\t\t\t\t\t\t\t*mc_bus,\n\t\t\t\t\t\t\tenum fsl_mc_pool_type\n\t\t\t\t\t\t\t\tpool_type,\n\t\t\t\t\t\t\tstruct fsl_mc_device\n\t\t\t\t\t\t\t\t*mc_dev)\n{\n\tstruct fsl_mc_resource_pool *res_pool;\n\tstruct fsl_mc_resource *resource;\n\tstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\n\tint error = -EINVAL;\n\n\tif (pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES)\n\t\tgoto out;\n\tif (!fsl_mc_is_allocatable(mc_dev))\n\t\tgoto out;\n\tif (mc_dev->resource)\n\t\tgoto out;\n\n\tres_pool = &mc_bus->resource_pools[pool_type];\n\tif (res_pool->type != pool_type)\n\t\tgoto out;\n\tif (res_pool->mc_bus != mc_bus)\n\t\tgoto out;\n\n\tmutex_lock(&res_pool->mutex);\n\n\tif (res_pool->max_count < 0)\n\t\tgoto out_unlock;\n\tif (res_pool->free_count < 0 ||\n\t    res_pool->free_count > res_pool->max_count)\n\t\tgoto out_unlock;\n\n\tresource = devm_kzalloc(&mc_bus_dev->dev, sizeof(*resource),\n\t\t\t\tGFP_KERNEL);\n\tif (!resource) {\n\t\terror = -ENOMEM;\n\t\tdev_err(&mc_bus_dev->dev,\n\t\t\t\"Failed to allocate memory for fsl_mc_resource\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tresource->type = pool_type;\n\tresource->id = mc_dev->obj_desc.id;\n\tresource->data = mc_dev;\n\tresource->parent_pool = res_pool;\n\tINIT_LIST_HEAD(&resource->node);\n\tlist_add_tail(&resource->node, &res_pool->free_list);\n\tmc_dev->resource = resource;\n\tres_pool->free_count++;\n\tres_pool->max_count++;\n\terror = 0;\nout_unlock:\n\tmutex_unlock(&res_pool->mutex);\nout:\n\treturn error;\n}\n\n \nstatic int __must_check fsl_mc_resource_pool_remove_device(struct fsl_mc_device\n\t\t\t\t\t\t\t\t   *mc_dev)\n{\n\tstruct fsl_mc_device *mc_bus_dev;\n\tstruct fsl_mc_bus *mc_bus;\n\tstruct fsl_mc_resource_pool *res_pool;\n\tstruct fsl_mc_resource *resource;\n\tint error = -EINVAL;\n\n\tmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\n\tmc_bus = to_fsl_mc_bus(mc_bus_dev);\n\n\tresource = mc_dev->resource;\n\tif (!resource || resource->data != mc_dev) {\n\t\tdev_err(&mc_bus_dev->dev, \"resource mismatch\\n\");\n\t\tgoto out;\n\t}\n\n\tres_pool = resource->parent_pool;\n\tif (res_pool != &mc_bus->resource_pools[resource->type]) {\n\t\tdev_err(&mc_bus_dev->dev, \"pool mismatch\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&res_pool->mutex);\n\n\tif (res_pool->max_count <= 0) {\n\t\tdev_err(&mc_bus_dev->dev, \"max_count underflow\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (res_pool->free_count <= 0 ||\n\t    res_pool->free_count > res_pool->max_count) {\n\t\tdev_err(&mc_bus_dev->dev, \"free_count mismatch\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (list_empty(&resource->node)) {\n\t\terror = -EBUSY;\n\t\tdev_err(&mc_bus_dev->dev,\n\t\t\t\"Device %s cannot be removed from resource pool\\n\",\n\t\t\tdev_name(&mc_dev->dev));\n\t\tgoto out_unlock;\n\t}\n\n\tlist_del_init(&resource->node);\n\tres_pool->free_count--;\n\tres_pool->max_count--;\n\n\tdevm_kfree(&mc_bus_dev->dev, resource);\n\tmc_dev->resource = NULL;\n\terror = 0;\nout_unlock:\n\tmutex_unlock(&res_pool->mutex);\nout:\n\treturn error;\n}\n\nstatic const char *const fsl_mc_pool_type_strings[] = {\n\t[FSL_MC_POOL_DPMCP] = \"dpmcp\",\n\t[FSL_MC_POOL_DPBP] = \"dpbp\",\n\t[FSL_MC_POOL_DPCON] = \"dpcon\",\n\t[FSL_MC_POOL_IRQ] = \"irq\",\n};\n\nstatic int __must_check object_type_to_pool_type(const char *object_type,\n\t\t\t\t\t\t enum fsl_mc_pool_type\n\t\t\t\t\t\t\t\t*pool_type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsl_mc_pool_type_strings); i++) {\n\t\tif (strcmp(object_type, fsl_mc_pool_type_strings[i]) == 0) {\n\t\t\t*pool_type = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nint __must_check fsl_mc_resource_allocate(struct fsl_mc_bus *mc_bus,\n\t\t\t\t\t  enum fsl_mc_pool_type pool_type,\n\t\t\t\t\t  struct fsl_mc_resource **new_resource)\n{\n\tstruct fsl_mc_resource_pool *res_pool;\n\tstruct fsl_mc_resource *resource;\n\tstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\n\tint error = -EINVAL;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(fsl_mc_pool_type_strings) !=\n\t\t     FSL_MC_NUM_POOL_TYPES);\n\n\t*new_resource = NULL;\n\tif (pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES)\n\t\tgoto out;\n\n\tres_pool = &mc_bus->resource_pools[pool_type];\n\tif (res_pool->mc_bus != mc_bus)\n\t\tgoto out;\n\n\tmutex_lock(&res_pool->mutex);\n\tresource = list_first_entry_or_null(&res_pool->free_list,\n\t\t\t\t\t    struct fsl_mc_resource, node);\n\n\tif (!resource) {\n\t\terror = -ENXIO;\n\t\tdev_err(&mc_bus_dev->dev,\n\t\t\t\"No more resources of type %s left\\n\",\n\t\t\tfsl_mc_pool_type_strings[pool_type]);\n\t\tgoto out_unlock;\n\t}\n\n\tif (resource->type != pool_type)\n\t\tgoto out_unlock;\n\tif (resource->parent_pool != res_pool)\n\t\tgoto out_unlock;\n\tif (res_pool->free_count <= 0 ||\n\t    res_pool->free_count > res_pool->max_count)\n\t\tgoto out_unlock;\n\n\tlist_del_init(&resource->node);\n\n\tres_pool->free_count--;\n\terror = 0;\nout_unlock:\n\tmutex_unlock(&res_pool->mutex);\n\t*new_resource = resource;\nout:\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_resource_allocate);\n\nvoid fsl_mc_resource_free(struct fsl_mc_resource *resource)\n{\n\tstruct fsl_mc_resource_pool *res_pool;\n\n\tres_pool = resource->parent_pool;\n\tif (resource->type != res_pool->type)\n\t\treturn;\n\n\tmutex_lock(&res_pool->mutex);\n\tif (res_pool->free_count < 0 ||\n\t    res_pool->free_count >= res_pool->max_count)\n\t\tgoto out_unlock;\n\n\tif (!list_empty(&resource->node))\n\t\tgoto out_unlock;\n\n\tlist_add_tail(&resource->node, &res_pool->free_list);\n\tres_pool->free_count++;\nout_unlock:\n\tmutex_unlock(&res_pool->mutex);\n}\nEXPORT_SYMBOL_GPL(fsl_mc_resource_free);\n\n \nint __must_check fsl_mc_object_allocate(struct fsl_mc_device *mc_dev,\n\t\t\t\t\tenum fsl_mc_pool_type pool_type,\n\t\t\t\t\tstruct fsl_mc_device **new_mc_adev)\n{\n\tstruct fsl_mc_device *mc_bus_dev;\n\tstruct fsl_mc_bus *mc_bus;\n\tstruct fsl_mc_device *mc_adev;\n\tint error = -EINVAL;\n\tstruct fsl_mc_resource *resource = NULL;\n\n\t*new_mc_adev = NULL;\n\tif (mc_dev->flags & FSL_MC_IS_DPRC)\n\t\tgoto error;\n\n\tif (!dev_is_fsl_mc(mc_dev->dev.parent))\n\t\tgoto error;\n\n\tif (pool_type == FSL_MC_POOL_DPMCP)\n\t\tgoto error;\n\n\tmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\n\tmc_bus = to_fsl_mc_bus(mc_bus_dev);\n\terror = fsl_mc_resource_allocate(mc_bus, pool_type, &resource);\n\tif (error < 0)\n\t\tgoto error;\n\n\tmc_adev = resource->data;\n\tif (!mc_adev) {\n\t\terror = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tmc_adev->consumer_link = device_link_add(&mc_dev->dev,\n\t\t\t\t\t\t &mc_adev->dev,\n\t\t\t\t\t\t DL_FLAG_AUTOREMOVE_CONSUMER);\n\tif (!mc_adev->consumer_link) {\n\t\terror = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t*new_mc_adev = mc_adev;\n\treturn 0;\nerror:\n\tif (resource)\n\t\tfsl_mc_resource_free(resource);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_object_allocate);\n\n \nvoid fsl_mc_object_free(struct fsl_mc_device *mc_adev)\n{\n\tstruct fsl_mc_resource *resource;\n\n\tresource = mc_adev->resource;\n\tif (resource->type == FSL_MC_POOL_DPMCP)\n\t\treturn;\n\tif (resource->data != mc_adev)\n\t\treturn;\n\n\tfsl_mc_resource_free(resource);\n\n\tmc_adev->consumer_link = NULL;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_object_free);\n\n \n\n \nint fsl_mc_populate_irq_pool(struct fsl_mc_device *mc_bus_dev,\n\t\t\t     unsigned int irq_count)\n{\n\tunsigned int i;\n\tstruct fsl_mc_device_irq *irq_resources;\n\tstruct fsl_mc_device_irq *mc_dev_irq;\n\tint error;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\tstruct fsl_mc_resource_pool *res_pool =\n\t\t\t&mc_bus->resource_pools[FSL_MC_POOL_IRQ];\n\n\t \n\tif (mc_bus->irq_resources)\n\t\treturn 0;\n\n\tif (irq_count == 0 ||\n\t    irq_count > FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS)\n\t\treturn -EINVAL;\n\n\terror = fsl_mc_msi_domain_alloc_irqs(&mc_bus_dev->dev, irq_count);\n\tif (error < 0)\n\t\treturn error;\n\n\tirq_resources = devm_kcalloc(&mc_bus_dev->dev,\n\t\t\t\t     irq_count, sizeof(*irq_resources),\n\t\t\t\t     GFP_KERNEL);\n\tif (!irq_resources) {\n\t\terror = -ENOMEM;\n\t\tgoto cleanup_msi_irqs;\n\t}\n\n\tfor (i = 0; i < irq_count; i++) {\n\t\tmc_dev_irq = &irq_resources[i];\n\n\t\t \n\t\tmc_dev_irq->resource.type = res_pool->type;\n\t\tmc_dev_irq->resource.data = mc_dev_irq;\n\t\tmc_dev_irq->resource.parent_pool = res_pool;\n\t\tmc_dev_irq->virq = msi_get_virq(&mc_bus_dev->dev, i);\n\t\tmc_dev_irq->resource.id = mc_dev_irq->virq;\n\t\tINIT_LIST_HEAD(&mc_dev_irq->resource.node);\n\t\tlist_add_tail(&mc_dev_irq->resource.node, &res_pool->free_list);\n\t}\n\n\tres_pool->max_count = irq_count;\n\tres_pool->free_count = irq_count;\n\tmc_bus->irq_resources = irq_resources;\n\treturn 0;\n\ncleanup_msi_irqs:\n\tfsl_mc_msi_domain_free_irqs(&mc_bus_dev->dev);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_populate_irq_pool);\n\n \nvoid fsl_mc_cleanup_irq_pool(struct fsl_mc_device *mc_bus_dev)\n{\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\tstruct fsl_mc_resource_pool *res_pool =\n\t\t\t&mc_bus->resource_pools[FSL_MC_POOL_IRQ];\n\n\tif (!mc_bus->irq_resources)\n\t\treturn;\n\n\tif (res_pool->max_count == 0)\n\t\treturn;\n\n\tif (res_pool->free_count != res_pool->max_count)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&res_pool->free_list);\n\tres_pool->max_count = 0;\n\tres_pool->free_count = 0;\n\tmc_bus->irq_resources = NULL;\n\tfsl_mc_msi_domain_free_irqs(&mc_bus_dev->dev);\n}\nEXPORT_SYMBOL_GPL(fsl_mc_cleanup_irq_pool);\n\n \nint __must_check fsl_mc_allocate_irqs(struct fsl_mc_device *mc_dev)\n{\n\tint i;\n\tint irq_count;\n\tint res_allocated_count = 0;\n\tint error = -EINVAL;\n\tstruct fsl_mc_device_irq **irqs = NULL;\n\tstruct fsl_mc_bus *mc_bus;\n\tstruct fsl_mc_resource_pool *res_pool;\n\n\tif (mc_dev->irqs)\n\t\treturn -EINVAL;\n\n\tirq_count = mc_dev->obj_desc.irq_count;\n\tif (irq_count == 0)\n\t\treturn -EINVAL;\n\n\tif (is_fsl_mc_bus_dprc(mc_dev))\n\t\tmc_bus = to_fsl_mc_bus(mc_dev);\n\telse\n\t\tmc_bus = to_fsl_mc_bus(to_fsl_mc_device(mc_dev->dev.parent));\n\n\tif (!mc_bus->irq_resources)\n\t\treturn -EINVAL;\n\n\tres_pool = &mc_bus->resource_pools[FSL_MC_POOL_IRQ];\n\tif (res_pool->free_count < irq_count) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"Not able to allocate %u irqs for device\\n\", irq_count);\n\t\treturn -ENOSPC;\n\t}\n\n\tirqs = devm_kcalloc(&mc_dev->dev, irq_count, sizeof(irqs[0]),\n\t\t\t    GFP_KERNEL);\n\tif (!irqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < irq_count; i++) {\n\t\tstruct fsl_mc_resource *resource;\n\n\t\terror = fsl_mc_resource_allocate(mc_bus, FSL_MC_POOL_IRQ,\n\t\t\t\t\t\t &resource);\n\t\tif (error < 0)\n\t\t\tgoto error_resource_alloc;\n\n\t\tirqs[i] = to_fsl_mc_irq(resource);\n\t\tres_allocated_count++;\n\n\t\tirqs[i]->mc_dev = mc_dev;\n\t\tirqs[i]->dev_irq_index = i;\n\t}\n\n\tmc_dev->irqs = irqs;\n\treturn 0;\n\nerror_resource_alloc:\n\tfor (i = 0; i < res_allocated_count; i++) {\n\t\tirqs[i]->mc_dev = NULL;\n\t\tfsl_mc_resource_free(&irqs[i]->resource);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_allocate_irqs);\n\n \nvoid fsl_mc_free_irqs(struct fsl_mc_device *mc_dev)\n{\n\tint i;\n\tint irq_count;\n\tstruct fsl_mc_bus *mc_bus;\n\tstruct fsl_mc_device_irq **irqs = mc_dev->irqs;\n\n\tif (!irqs)\n\t\treturn;\n\n\tirq_count = mc_dev->obj_desc.irq_count;\n\n\tif (is_fsl_mc_bus_dprc(mc_dev))\n\t\tmc_bus = to_fsl_mc_bus(mc_dev);\n\telse\n\t\tmc_bus = to_fsl_mc_bus(to_fsl_mc_device(mc_dev->dev.parent));\n\n\tif (!mc_bus->irq_resources)\n\t\treturn;\n\n\tfor (i = 0; i < irq_count; i++) {\n\t\tirqs[i]->mc_dev = NULL;\n\t\tfsl_mc_resource_free(&irqs[i]->resource);\n\t}\n\n\tmc_dev->irqs = NULL;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_free_irqs);\n\nvoid fsl_mc_init_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\n{\n\tint pool_type;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\n\tfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++) {\n\t\tstruct fsl_mc_resource_pool *res_pool =\n\t\t    &mc_bus->resource_pools[pool_type];\n\n\t\tres_pool->type = pool_type;\n\t\tres_pool->max_count = 0;\n\t\tres_pool->free_count = 0;\n\t\tres_pool->mc_bus = mc_bus;\n\t\tINIT_LIST_HEAD(&res_pool->free_list);\n\t\tmutex_init(&res_pool->mutex);\n\t}\n}\n\nstatic void fsl_mc_cleanup_resource_pool(struct fsl_mc_device *mc_bus_dev,\n\t\t\t\t\t enum fsl_mc_pool_type pool_type)\n{\n\tstruct fsl_mc_resource *resource;\n\tstruct fsl_mc_resource *next;\n\tstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\n\tstruct fsl_mc_resource_pool *res_pool =\n\t\t\t\t\t&mc_bus->resource_pools[pool_type];\n\n\tlist_for_each_entry_safe(resource, next, &res_pool->free_list, node)\n\t\tdevm_kfree(&mc_bus_dev->dev, resource);\n}\n\nvoid fsl_mc_cleanup_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\n{\n\tint pool_type;\n\n\tfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++)\n\t\tfsl_mc_cleanup_resource_pool(mc_bus_dev, pool_type);\n}\n\n \nstatic int fsl_mc_allocator_probe(struct fsl_mc_device *mc_dev)\n{\n\tenum fsl_mc_pool_type pool_type;\n\tstruct fsl_mc_device *mc_bus_dev;\n\tstruct fsl_mc_bus *mc_bus;\n\tint error;\n\n\tif (!fsl_mc_is_allocatable(mc_dev))\n\t\treturn -EINVAL;\n\n\tmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\n\tif (!dev_is_fsl_mc(&mc_bus_dev->dev))\n\t\treturn -EINVAL;\n\n\tmc_bus = to_fsl_mc_bus(mc_bus_dev);\n\terror = object_type_to_pool_type(mc_dev->obj_desc.type, &pool_type);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = fsl_mc_resource_pool_add_device(mc_bus, pool_type, mc_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_dbg(&mc_dev->dev,\n\t\t\"Allocatable fsl-mc device bound to fsl_mc_allocator driver\");\n\treturn 0;\n}\n\n \nstatic void fsl_mc_allocator_remove(struct fsl_mc_device *mc_dev)\n{\n\tint error;\n\n\tif (mc_dev->resource) {\n\t\terror = fsl_mc_resource_pool_remove_device(mc_dev);\n\t\tif (error < 0)\n\t\t\treturn;\n\t}\n\n\tdev_dbg(&mc_dev->dev,\n\t\t\"Allocatable fsl-mc device unbound from fsl_mc_allocator driver\");\n}\n\nstatic const struct fsl_mc_device_id match_id_table[] = {\n\t{\n\t .vendor = FSL_MC_VENDOR_FREESCALE,\n\t .obj_type = \"dpbp\",\n\t},\n\t{\n\t .vendor = FSL_MC_VENDOR_FREESCALE,\n\t .obj_type = \"dpmcp\",\n\t},\n\t{\n\t .vendor = FSL_MC_VENDOR_FREESCALE,\n\t .obj_type = \"dpcon\",\n\t},\n\t{.vendor = 0x0},\n};\n\nstatic struct fsl_mc_driver fsl_mc_allocator_driver = {\n\t.driver = {\n\t\t   .name = \"fsl_mc_allocator\",\n\t\t   .pm = NULL,\n\t\t   },\n\t.match_id_table = match_id_table,\n\t.probe = fsl_mc_allocator_probe,\n\t.remove = fsl_mc_allocator_remove,\n};\n\nint __init fsl_mc_allocator_driver_init(void)\n{\n\treturn fsl_mc_driver_register(&fsl_mc_allocator_driver);\n}\n\nvoid fsl_mc_allocator_driver_exit(void)\n{\n\tfsl_mc_driver_unregister(&fsl_mc_allocator_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}