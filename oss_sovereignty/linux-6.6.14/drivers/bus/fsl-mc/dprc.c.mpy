{
  "module_name": "dprc.c",
  "hash_id": "5e7204c07eb9c2099206be476b09c1dad0ad3713ea6fa956d258c51146a9bade",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/dprc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/fsl/mc.h>\n\n#include \"fsl-mc-private.h\"\n\n \nstatic u16 dprc_major_ver;\nstatic u16 dprc_minor_ver;\n\n \nint dprc_open(struct fsl_mc_io *mc_io,\n\t      u32 cmd_flags,\n\t      int container_id,\n\t      u16 *token)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_open *cmd_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_OPEN, cmd_flags,\n\t\t\t\t\t  0);\n\tcmd_params = (struct dprc_cmd_open *)cmd.params;\n\tcmd_params->container_id = cpu_to_le32(container_id);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*token = mc_cmd_hdr_read_token(&cmd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dprc_open);\n\n \nint dprc_close(struct fsl_mc_io *mc_io,\n\t       u32 cmd_flags,\n\t       u16 token)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_CLOSE, cmd_flags,\n\t\t\t\t\t  token);\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\nEXPORT_SYMBOL_GPL(dprc_close);\n\n \nint dprc_reset_container(struct fsl_mc_io *mc_io,\n\t\t\t u32 cmd_flags,\n\t\t\t u16 token,\n\t\t\t int child_container_id,\n\t\t\t u32 options)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_reset_container *cmd_params;\n\tu32 cmdid = DPRC_CMDID_RESET_CONT;\n\tint err;\n\n\t \n\tif (!dprc_major_ver && !dprc_minor_ver) {\n\t\terr = dprc_get_api_version(mc_io, 0,\n\t\t\t\t&dprc_major_ver,\n\t\t\t\t&dprc_minor_ver);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (dprc_major_ver > 6 || (dprc_major_ver == 6 && dprc_minor_ver >= 5))\n\t\tcmdid = DPRC_CMDID_RESET_CONT_V2;\n\n\t \n\tcmd.header = mc_encode_cmd_header(cmdid, cmd_flags, token);\n\tcmd_params = (struct dprc_cmd_reset_container *)cmd.params;\n\tcmd_params->child_container_id = cpu_to_le32(child_container_id);\n\tcmd_params->options = cpu_to_le32(options);\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\nEXPORT_SYMBOL_GPL(dprc_reset_container);\n\n \nint dprc_set_irq(struct fsl_mc_io *mc_io,\n\t\t u32 cmd_flags,\n\t\t u16 token,\n\t\t u8 irq_index,\n\t\t struct dprc_irq_cfg *irq_cfg)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_set_irq *cmd_params;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_SET_IRQ,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dprc_cmd_set_irq *)cmd.params;\n\tcmd_params->irq_val = cpu_to_le32(irq_cfg->val);\n\tcmd_params->irq_index = irq_index;\n\tcmd_params->irq_addr = cpu_to_le64(irq_cfg->paddr);\n\tcmd_params->irq_num = cpu_to_le32(irq_cfg->irq_num);\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\n\n \nint dprc_set_irq_enable(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tu8 irq_index,\n\t\t\tu8 en)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_set_irq_enable *cmd_params;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_SET_IRQ_ENABLE,\n\t\t\t\t\t  cmd_flags, token);\n\tcmd_params = (struct dprc_cmd_set_irq_enable *)cmd.params;\n\tcmd_params->enable = en & DPRC_ENABLE;\n\tcmd_params->irq_index = irq_index;\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\n\n \nint dprc_set_irq_mask(struct fsl_mc_io *mc_io,\n\t\t      u32 cmd_flags,\n\t\t      u16 token,\n\t\t      u8 irq_index,\n\t\t      u32 mask)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_set_irq_mask *cmd_params;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_SET_IRQ_MASK,\n\t\t\t\t\t  cmd_flags, token);\n\tcmd_params = (struct dprc_cmd_set_irq_mask *)cmd.params;\n\tcmd_params->mask = cpu_to_le32(mask);\n\tcmd_params->irq_index = irq_index;\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\n\n \nint dprc_get_irq_status(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tu8 irq_index,\n\t\t\tu32 *status)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_get_irq_status *cmd_params;\n\tstruct dprc_rsp_get_irq_status *rsp_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_IRQ_STATUS,\n\t\t\t\t\t  cmd_flags, token);\n\tcmd_params = (struct dprc_cmd_get_irq_status *)cmd.params;\n\tcmd_params->status = cpu_to_le32(*status);\n\tcmd_params->irq_index = irq_index;\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dprc_rsp_get_irq_status *)cmd.params;\n\t*status = le32_to_cpu(rsp_params->status);\n\n\treturn 0;\n}\n\n \nint dprc_clear_irq_status(struct fsl_mc_io *mc_io,\n\t\t\t  u32 cmd_flags,\n\t\t\t  u16 token,\n\t\t\t  u8 irq_index,\n\t\t\t  u32 status)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_clear_irq_status *cmd_params;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_CLEAR_IRQ_STATUS,\n\t\t\t\t\t  cmd_flags, token);\n\tcmd_params = (struct dprc_cmd_clear_irq_status *)cmd.params;\n\tcmd_params->status = cpu_to_le32(status);\n\tcmd_params->irq_index = irq_index;\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\n\n \nint dprc_get_attributes(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tstruct dprc_attributes *attr)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_rsp_get_attributes *rsp_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_ATTR,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dprc_rsp_get_attributes *)cmd.params;\n\tattr->container_id = le32_to_cpu(rsp_params->container_id);\n\tattr->icid = le32_to_cpu(rsp_params->icid);\n\tattr->options = le32_to_cpu(rsp_params->options);\n\tattr->portal_id = le32_to_cpu(rsp_params->portal_id);\n\n\treturn 0;\n}\n\n \nint dprc_get_obj_count(struct fsl_mc_io *mc_io,\n\t\t       u32 cmd_flags,\n\t\t       u16 token,\n\t\t       int *obj_count)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_rsp_get_obj_count *rsp_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_OBJ_COUNT,\n\t\t\t\t\t  cmd_flags, token);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dprc_rsp_get_obj_count *)cmd.params;\n\t*obj_count = le32_to_cpu(rsp_params->obj_count);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dprc_get_obj_count);\n\n \nint dprc_get_obj(struct fsl_mc_io *mc_io,\n\t\t u32 cmd_flags,\n\t\t u16 token,\n\t\t int obj_index,\n\t\t struct fsl_mc_obj_desc *obj_desc)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_get_obj *cmd_params;\n\tstruct dprc_rsp_get_obj *rsp_params;\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_OBJ,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dprc_cmd_get_obj *)cmd.params;\n\tcmd_params->obj_index = cpu_to_le32(obj_index);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dprc_rsp_get_obj *)cmd.params;\n\tobj_desc->id = le32_to_cpu(rsp_params->id);\n\tobj_desc->vendor = le16_to_cpu(rsp_params->vendor);\n\tobj_desc->irq_count = rsp_params->irq_count;\n\tobj_desc->region_count = rsp_params->region_count;\n\tobj_desc->state = le32_to_cpu(rsp_params->state);\n\tobj_desc->ver_major = le16_to_cpu(rsp_params->version_major);\n\tobj_desc->ver_minor = le16_to_cpu(rsp_params->version_minor);\n\tobj_desc->flags = le16_to_cpu(rsp_params->flags);\n\tstrncpy(obj_desc->type, rsp_params->type, 16);\n\tobj_desc->type[15] = '\\0';\n\tstrncpy(obj_desc->label, rsp_params->label, 16);\n\tobj_desc->label[15] = '\\0';\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dprc_get_obj);\n\n \nint dprc_set_obj_irq(struct fsl_mc_io *mc_io,\n\t\t     u32 cmd_flags,\n\t\t     u16 token,\n\t\t     char *obj_type,\n\t\t     int obj_id,\n\t\t     u8 irq_index,\n\t\t     struct dprc_irq_cfg *irq_cfg)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_set_obj_irq *cmd_params;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_SET_OBJ_IRQ,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dprc_cmd_set_obj_irq *)cmd.params;\n\tcmd_params->irq_val = cpu_to_le32(irq_cfg->val);\n\tcmd_params->irq_index = irq_index;\n\tcmd_params->irq_addr = cpu_to_le64(irq_cfg->paddr);\n\tcmd_params->irq_num = cpu_to_le32(irq_cfg->irq_num);\n\tcmd_params->obj_id = cpu_to_le32(obj_id);\n\tstrncpy(cmd_params->obj_type, obj_type, 16);\n\tcmd_params->obj_type[15] = '\\0';\n\n\t \n\treturn mc_send_command(mc_io, &cmd);\n}\nEXPORT_SYMBOL_GPL(dprc_set_obj_irq);\n\n \nint dprc_get_obj_region(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tchar *obj_type,\n\t\t\tint obj_id,\n\t\t\tu8 region_index,\n\t\t\tstruct dprc_region_desc *region_desc)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tstruct dprc_cmd_get_obj_region *cmd_params;\n\tstruct dprc_rsp_get_obj_region *rsp_params;\n\tint err;\n\n     \n\tif (!dprc_major_ver && !dprc_minor_ver) {\n\t\terr = dprc_get_api_version(mc_io, 0,\n\t\t\t\t      &dprc_major_ver,\n\t\t\t\t      &dprc_minor_ver);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (dprc_major_ver > 6 || (dprc_major_ver == 6 && dprc_minor_ver >= 6)) {\n\t\t \n\n\t\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_OBJ_REG_V3,\n\t\t\t\t\t\t  cmd_flags, token);\n\n\t} else if (dprc_major_ver == 6 && dprc_minor_ver >= 3) {\n\t\t \n\t\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_OBJ_REG_V2,\n\t\t\t\t\t\t  cmd_flags, token);\n\t} else {\n\t\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_OBJ_REG,\n\t\t\t\t\t\t  cmd_flags, token);\n\t}\n\n\tcmd_params = (struct dprc_cmd_get_obj_region *)cmd.params;\n\tcmd_params->obj_id = cpu_to_le32(obj_id);\n\tcmd_params->region_index = region_index;\n\tstrncpy(cmd_params->obj_type, obj_type, 16);\n\tcmd_params->obj_type[15] = '\\0';\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\trsp_params = (struct dprc_rsp_get_obj_region *)cmd.params;\n\tregion_desc->base_offset = le64_to_cpu(rsp_params->base_offset);\n\tregion_desc->size = le32_to_cpu(rsp_params->size);\n\tregion_desc->type = rsp_params->type;\n\tregion_desc->flags = le32_to_cpu(rsp_params->flags);\n\tif (dprc_major_ver > 6 || (dprc_major_ver == 6 && dprc_minor_ver >= 3))\n\t\tregion_desc->base_address = le64_to_cpu(rsp_params->base_addr);\n\telse\n\t\tregion_desc->base_address = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dprc_get_obj_region);\n\n \nint dprc_get_api_version(struct fsl_mc_io *mc_io,\n\t\t\t u32 cmd_flags,\n\t\t\t u16 *major_ver,\n\t\t\t u16 *minor_ver)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_API_VERSION,\n\t\t\t\t\t  cmd_flags, 0);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmc_cmd_read_api_version(&cmd, major_ver, minor_ver);\n\n\treturn 0;\n}\n\n \nint dprc_get_container_id(struct fsl_mc_io *mc_io,\n\t\t\t  u32 cmd_flags,\n\t\t\t  int *container_id)\n{\n\tstruct fsl_mc_command cmd = { 0 };\n\tint err;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_CONT_ID,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  0);\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*container_id = (int)mc_cmd_read_object_id(&cmd);\n\n\treturn 0;\n}\n\n \nint dprc_get_connection(struct fsl_mc_io *mc_io,\n\t\t\tu32 cmd_flags,\n\t\t\tu16 token,\n\t\t\tconst struct dprc_endpoint *endpoint1,\n\t\t\tstruct dprc_endpoint *endpoint2,\n\t\t\tint *state)\n{\n\tstruct dprc_cmd_get_connection *cmd_params;\n\tstruct dprc_rsp_get_connection *rsp_params;\n\tstruct fsl_mc_command cmd = { 0 };\n\tint err, i;\n\n\t \n\tcmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_CONNECTION,\n\t\t\t\t\t  cmd_flags,\n\t\t\t\t\t  token);\n\tcmd_params = (struct dprc_cmd_get_connection *)cmd.params;\n\tcmd_params->ep1_id = cpu_to_le32(endpoint1->id);\n\tcmd_params->ep1_interface_id = cpu_to_le16(endpoint1->if_id);\n\tfor (i = 0; i < 16; i++)\n\t\tcmd_params->ep1_type[i] = endpoint1->type[i];\n\n\t \n\terr = mc_send_command(mc_io, &cmd);\n\tif (err)\n\t\treturn -ENOTCONN;\n\n\t \n\trsp_params = (struct dprc_rsp_get_connection *)cmd.params;\n\tendpoint2->id = le32_to_cpu(rsp_params->ep2_id);\n\tendpoint2->if_id = le16_to_cpu(rsp_params->ep2_interface_id);\n\t*state = le32_to_cpu(rsp_params->state);\n\tfor (i = 0; i < 16; i++)\n\t\tendpoint2->type[i] = rsp_params->ep2_type[i];\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}