{
  "module_name": "mc-sys.c",
  "hash_id": "2961c99a6ba22e883108289ca1a82d58eea52a82cc25bcace2684562e9083b06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/mc-sys.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/fsl/mc.h>\n\n#include \"fsl-mc-private.h\"\n\n \n#define MC_CMD_COMPLETION_TIMEOUT_MS\t500\n\n \n#define MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS    10\n#define MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS    500\n\nstatic enum mc_cmd_status mc_cmd_hdr_read_status(struct fsl_mc_command *cmd)\n{\n\tstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&cmd->header;\n\n\treturn (enum mc_cmd_status)hdr->status;\n}\n\nu16 mc_cmd_hdr_read_cmdid(struct fsl_mc_command *cmd)\n{\n\tstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&cmd->header;\n\tu16 cmd_id = le16_to_cpu(hdr->cmd_id);\n\n\treturn cmd_id;\n}\n\nstatic int mc_status_to_error(enum mc_cmd_status status)\n{\n\tstatic const int mc_status_to_error_map[] = {\n\t\t[MC_CMD_STATUS_OK] = 0,\n\t\t[MC_CMD_STATUS_AUTH_ERR] = -EACCES,\n\t\t[MC_CMD_STATUS_NO_PRIVILEGE] = -EPERM,\n\t\t[MC_CMD_STATUS_DMA_ERR] = -EIO,\n\t\t[MC_CMD_STATUS_CONFIG_ERR] = -ENXIO,\n\t\t[MC_CMD_STATUS_TIMEOUT] = -ETIMEDOUT,\n\t\t[MC_CMD_STATUS_NO_RESOURCE] = -ENAVAIL,\n\t\t[MC_CMD_STATUS_NO_MEMORY] = -ENOMEM,\n\t\t[MC_CMD_STATUS_BUSY] = -EBUSY,\n\t\t[MC_CMD_STATUS_UNSUPPORTED_OP] = -ENOTSUPP,\n\t\t[MC_CMD_STATUS_INVALID_STATE] = -ENODEV,\n\t};\n\n\tif ((u32)status >= ARRAY_SIZE(mc_status_to_error_map))\n\t\treturn -EINVAL;\n\n\treturn mc_status_to_error_map[status];\n}\n\nstatic const char *mc_status_to_string(enum mc_cmd_status status)\n{\n\tstatic const char *const status_strings[] = {\n\t\t[MC_CMD_STATUS_OK] = \"Command completed successfully\",\n\t\t[MC_CMD_STATUS_READY] = \"Command ready to be processed\",\n\t\t[MC_CMD_STATUS_AUTH_ERR] = \"Authentication error\",\n\t\t[MC_CMD_STATUS_NO_PRIVILEGE] = \"No privilege\",\n\t\t[MC_CMD_STATUS_DMA_ERR] = \"DMA or I/O error\",\n\t\t[MC_CMD_STATUS_CONFIG_ERR] = \"Configuration error\",\n\t\t[MC_CMD_STATUS_TIMEOUT] = \"Operation timed out\",\n\t\t[MC_CMD_STATUS_NO_RESOURCE] = \"No resources\",\n\t\t[MC_CMD_STATUS_NO_MEMORY] = \"No memory available\",\n\t\t[MC_CMD_STATUS_BUSY] = \"Device is busy\",\n\t\t[MC_CMD_STATUS_UNSUPPORTED_OP] = \"Unsupported operation\",\n\t\t[MC_CMD_STATUS_INVALID_STATE] = \"Invalid state\"\n\t};\n\n\tif ((unsigned int)status >= ARRAY_SIZE(status_strings))\n\t\treturn \"Unknown MC error\";\n\n\treturn status_strings[status];\n}\n\n \nstatic inline void mc_write_command(struct fsl_mc_command __iomem *portal,\n\t\t\t\t    struct fsl_mc_command *cmd)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\n\t\t \n\t\twriteq_relaxed(le64_to_cpu(cmd->params[i]), &portal->params[i]);\n\n\t \n\twriteq(le64_to_cpu(cmd->header), &portal->header);\n}\n\n \nstatic inline enum mc_cmd_status mc_read_response(struct fsl_mc_command __iomem\n\t\t\t\t\t\t  *portal,\n\t\t\t\t\t\t  struct fsl_mc_command *resp)\n{\n\tint i;\n\tenum mc_cmd_status status;\n\n\t \n\tresp->header = cpu_to_le64(readq_relaxed(&portal->header));\n\tstatus = mc_cmd_hdr_read_status(resp);\n\tif (status != MC_CMD_STATUS_OK)\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\n\t\t \n\t\tresp->params[i] =\n\t\t\tcpu_to_le64(readq_relaxed(&portal->params[i]));\n\n\treturn status;\n}\n\n \nstatic int mc_polling_wait_preemptible(struct fsl_mc_io *mc_io,\n\t\t\t\t       struct fsl_mc_command *cmd,\n\t\t\t\t       enum mc_cmd_status *mc_status)\n{\n\tenum mc_cmd_status status;\n\tunsigned long jiffies_until_timeout =\n\t\tjiffies + msecs_to_jiffies(MC_CMD_COMPLETION_TIMEOUT_MS);\n\n\t \n\tfor (;;) {\n\t\tstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\n\t\tif (status != MC_CMD_STATUS_READY)\n\t\t\tbreak;\n\n\t\t \n\t\tusleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,\n\t\t\t     MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\n\n\t\tif (time_after_eq(jiffies, jiffies_until_timeout)) {\n\t\t\tdev_dbg(mc_io->dev,\n\t\t\t\t\"MC command timed out (portal: %pa, dprc handle: %#x, command: %#x)\\n\",\n\t\t\t\t &mc_io->portal_phys_addr,\n\t\t\t\t (unsigned int)mc_cmd_hdr_read_token(cmd),\n\t\t\t\t (unsigned int)mc_cmd_hdr_read_cmdid(cmd));\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t*mc_status = status;\n\treturn 0;\n}\n\n \nstatic int mc_polling_wait_atomic(struct fsl_mc_io *mc_io,\n\t\t\t\t  struct fsl_mc_command *cmd,\n\t\t\t\t  enum mc_cmd_status *mc_status)\n{\n\tenum mc_cmd_status status;\n\tunsigned long timeout_usecs = MC_CMD_COMPLETION_TIMEOUT_MS * 1000;\n\n\tBUILD_BUG_ON((MC_CMD_COMPLETION_TIMEOUT_MS * 1000) %\n\t\t     MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS != 0);\n\n\tfor (;;) {\n\t\tstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\n\t\tif (status != MC_CMD_STATUS_READY)\n\t\t\tbreak;\n\n\t\tudelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\n\t\ttimeout_usecs -= MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS;\n\t\tif (timeout_usecs == 0) {\n\t\t\tdev_dbg(mc_io->dev,\n\t\t\t\t\"MC command timed out (portal: %pa, dprc handle: %#x, command: %#x)\\n\",\n\t\t\t\t &mc_io->portal_phys_addr,\n\t\t\t\t (unsigned int)mc_cmd_hdr_read_token(cmd),\n\t\t\t\t (unsigned int)mc_cmd_hdr_read_cmdid(cmd));\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t*mc_status = status;\n\treturn 0;\n}\n\n \nint mc_send_command(struct fsl_mc_io *mc_io, struct fsl_mc_command *cmd)\n{\n\tint error;\n\tenum mc_cmd_status status;\n\tunsigned long irq_flags = 0;\n\n\tif (in_irq() && !(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))\n\t\treturn -EINVAL;\n\n\tif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\n\t\traw_spin_lock_irqsave(&mc_io->spinlock, irq_flags);\n\telse\n\t\tmutex_lock(&mc_io->mutex);\n\n\t \n\tmc_write_command(mc_io->portal_virt_addr, cmd);\n\n\t \n\tif (!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))\n\t\terror = mc_polling_wait_preemptible(mc_io, cmd, &status);\n\telse\n\t\terror = mc_polling_wait_atomic(mc_io, cmd, &status);\n\n\tif (error < 0)\n\t\tgoto common_exit;\n\n\tif (status != MC_CMD_STATUS_OK) {\n\t\tdev_dbg(mc_io->dev,\n\t\t\t\"MC command failed: portal: %pa, dprc handle: %#x, command: %#x, status: %s (%#x)\\n\",\n\t\t\t &mc_io->portal_phys_addr,\n\t\t\t (unsigned int)mc_cmd_hdr_read_token(cmd),\n\t\t\t (unsigned int)mc_cmd_hdr_read_cmdid(cmd),\n\t\t\t mc_status_to_string(status),\n\t\t\t (unsigned int)status);\n\n\t\terror = mc_status_to_error(status);\n\t\tgoto common_exit;\n\t}\n\n\terror = 0;\ncommon_exit:\n\tif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\n\t\traw_spin_unlock_irqrestore(&mc_io->spinlock, irq_flags);\n\telse\n\t\tmutex_unlock(&mc_io->mutex);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(mc_send_command);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}