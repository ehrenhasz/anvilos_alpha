{
  "module_name": "mc-io.c",
  "hash_id": "8c7c22ae21f810591f59bcdb7a004b54a4e1d4dd77333c5dd390e4afa810c3d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/mc-io.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/fsl/mc.h>\n\n#include \"fsl-mc-private.h\"\n\nstatic int fsl_mc_io_set_dpmcp(struct fsl_mc_io *mc_io,\n\t\t\t       struct fsl_mc_device *dpmcp_dev)\n{\n\tint error;\n\n\tif (mc_io->dpmcp_dev)\n\t\treturn -EINVAL;\n\n\tif (dpmcp_dev->mc_io)\n\t\treturn -EINVAL;\n\n\terror = dpmcp_open(mc_io,\n\t\t\t   0,\n\t\t\t   dpmcp_dev->obj_desc.id,\n\t\t\t   &dpmcp_dev->mc_handle);\n\tif (error < 0)\n\t\treturn error;\n\n\tmc_io->dpmcp_dev = dpmcp_dev;\n\tdpmcp_dev->mc_io = mc_io;\n\treturn 0;\n}\n\nstatic void fsl_mc_io_unset_dpmcp(struct fsl_mc_io *mc_io)\n{\n\tint error;\n\tstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\n\n\terror = dpmcp_close(mc_io,\n\t\t\t    0,\n\t\t\t    dpmcp_dev->mc_handle);\n\tif (error < 0) {\n\t\tdev_err(&dpmcp_dev->dev, \"dpmcp_close() failed: %d\\n\",\n\t\t\terror);\n\t}\n\n\tmc_io->dpmcp_dev = NULL;\n\tdpmcp_dev->mc_io = NULL;\n}\n\n \nint __must_check fsl_create_mc_io(struct device *dev,\n\t\t\t\t  phys_addr_t mc_portal_phys_addr,\n\t\t\t\t  u32 mc_portal_size,\n\t\t\t\t  struct fsl_mc_device *dpmcp_dev,\n\t\t\t\t  u32 flags, struct fsl_mc_io **new_mc_io)\n{\n\tint error;\n\tstruct fsl_mc_io *mc_io;\n\tvoid __iomem *mc_portal_virt_addr;\n\tstruct resource *res;\n\n\tmc_io = devm_kzalloc(dev, sizeof(*mc_io), GFP_KERNEL);\n\tif (!mc_io)\n\t\treturn -ENOMEM;\n\n\tmc_io->dev = dev;\n\tmc_io->flags = flags;\n\tmc_io->portal_phys_addr = mc_portal_phys_addr;\n\tmc_io->portal_size = mc_portal_size;\n\tif (flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\n\t\traw_spin_lock_init(&mc_io->spinlock);\n\telse\n\t\tmutex_init(&mc_io->mutex);\n\n\tres = devm_request_mem_region(dev,\n\t\t\t\t      mc_portal_phys_addr,\n\t\t\t\t      mc_portal_size,\n\t\t\t\t      \"mc_portal\");\n\tif (!res) {\n\t\tdev_err(dev,\n\t\t\t\"devm_request_mem_region failed for MC portal %pa\\n\",\n\t\t\t&mc_portal_phys_addr);\n\t\treturn -EBUSY;\n\t}\n\n\tmc_portal_virt_addr = devm_ioremap(dev,\n\t\t\t\t\t\t   mc_portal_phys_addr,\n\t\t\t\t\t\t   mc_portal_size);\n\tif (!mc_portal_virt_addr) {\n\t\tdev_err(dev,\n\t\t\t\"devm_ioremap failed for MC portal %pa\\n\",\n\t\t\t&mc_portal_phys_addr);\n\t\treturn -ENXIO;\n\t}\n\n\tmc_io->portal_virt_addr = mc_portal_virt_addr;\n\tif (dpmcp_dev) {\n\t\terror = fsl_mc_io_set_dpmcp(mc_io, dpmcp_dev);\n\t\tif (error < 0)\n\t\t\tgoto error_destroy_mc_io;\n\t}\n\n\t*new_mc_io = mc_io;\n\treturn 0;\n\nerror_destroy_mc_io:\n\tfsl_destroy_mc_io(mc_io);\n\treturn error;\n}\n\n \nvoid fsl_destroy_mc_io(struct fsl_mc_io *mc_io)\n{\n\tstruct fsl_mc_device *dpmcp_dev;\n\n\tif (!mc_io)\n\t\treturn;\n\n\tdpmcp_dev = mc_io->dpmcp_dev;\n\n\tif (dpmcp_dev)\n\t\tfsl_mc_io_unset_dpmcp(mc_io);\n\n\tdevm_iounmap(mc_io->dev, mc_io->portal_virt_addr);\n\tdevm_release_mem_region(mc_io->dev,\n\t\t\t\tmc_io->portal_phys_addr,\n\t\t\t\tmc_io->portal_size);\n\n\tmc_io->portal_virt_addr = NULL;\n\tdevm_kfree(mc_io->dev, mc_io);\n}\n\n \nint __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,\n\t\t\t\t\tu16 mc_io_flags,\n\t\t\t\t\tstruct fsl_mc_io **new_mc_io)\n{\n\tstruct fsl_mc_device *mc_bus_dev;\n\tstruct fsl_mc_bus *mc_bus;\n\tphys_addr_t mc_portal_phys_addr;\n\tsize_t mc_portal_size;\n\tstruct fsl_mc_device *dpmcp_dev;\n\tint error = -EINVAL;\n\tstruct fsl_mc_resource *resource = NULL;\n\tstruct fsl_mc_io *mc_io = NULL;\n\n\tif (mc_dev->flags & FSL_MC_IS_DPRC) {\n\t\tmc_bus_dev = mc_dev;\n\t} else {\n\t\tif (!dev_is_fsl_mc(mc_dev->dev.parent))\n\t\t\treturn error;\n\n\t\tmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\n\t}\n\n\tmc_bus = to_fsl_mc_bus(mc_bus_dev);\n\t*new_mc_io = NULL;\n\terror = fsl_mc_resource_allocate(mc_bus, FSL_MC_POOL_DPMCP, &resource);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = -EINVAL;\n\tdpmcp_dev = resource->data;\n\n\tif (dpmcp_dev->obj_desc.ver_major < DPMCP_MIN_VER_MAJOR ||\n\t    (dpmcp_dev->obj_desc.ver_major == DPMCP_MIN_VER_MAJOR &&\n\t     dpmcp_dev->obj_desc.ver_minor < DPMCP_MIN_VER_MINOR)) {\n\t\tdev_err(&dpmcp_dev->dev,\n\t\t\t\"ERROR: Version %d.%d of DPMCP not supported.\\n\",\n\t\t\tdpmcp_dev->obj_desc.ver_major,\n\t\t\tdpmcp_dev->obj_desc.ver_minor);\n\t\terror = -ENOTSUPP;\n\t\tgoto error_cleanup_resource;\n\t}\n\n\tmc_portal_phys_addr = dpmcp_dev->regions[0].start;\n\tmc_portal_size = resource_size(dpmcp_dev->regions);\n\n\terror = fsl_create_mc_io(&mc_bus_dev->dev,\n\t\t\t\t mc_portal_phys_addr,\n\t\t\t\t mc_portal_size, dpmcp_dev,\n\t\t\t\t mc_io_flags, &mc_io);\n\tif (error < 0)\n\t\tgoto error_cleanup_resource;\n\n\tdpmcp_dev->consumer_link = device_link_add(&mc_dev->dev,\n\t\t\t\t\t\t   &dpmcp_dev->dev,\n\t\t\t\t\t\t   DL_FLAG_AUTOREMOVE_CONSUMER);\n\tif (!dpmcp_dev->consumer_link) {\n\t\terror = -EINVAL;\n\t\tgoto error_cleanup_mc_io;\n\t}\n\n\t*new_mc_io = mc_io;\n\treturn 0;\n\nerror_cleanup_mc_io:\n\tfsl_destroy_mc_io(mc_io);\nerror_cleanup_resource:\n\tfsl_mc_resource_free(resource);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_portal_allocate);\n\n \nvoid fsl_mc_portal_free(struct fsl_mc_io *mc_io)\n{\n\tstruct fsl_mc_device *dpmcp_dev;\n\tstruct fsl_mc_resource *resource;\n\n\t \n\tdpmcp_dev = mc_io->dpmcp_dev;\n\n\tresource = dpmcp_dev->resource;\n\tif (!resource || resource->type != FSL_MC_POOL_DPMCP)\n\t\treturn;\n\n\tif (resource->data != dpmcp_dev)\n\t\treturn;\n\n\tfsl_destroy_mc_io(mc_io);\n\tfsl_mc_resource_free(resource);\n\n\tdpmcp_dev->consumer_link = NULL;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_portal_free);\n\n \nint fsl_mc_portal_reset(struct fsl_mc_io *mc_io)\n{\n\tint error;\n\tstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\n\n\terror = dpmcp_reset(mc_io, 0, dpmcp_dev->mc_handle);\n\tif (error < 0) {\n\t\tdev_err(&dpmcp_dev->dev, \"dpmcp_reset() failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fsl_mc_portal_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}