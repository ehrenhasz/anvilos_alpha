{
  "module_name": "fsl-mc-uapi.c",
  "hash_id": "d7752c09ba47de66dc183b8bd430708e05362fbe40fd6366ca07dd88faee6cf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/fsl-mc/fsl-mc-uapi.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n\n#include \"fsl-mc-private.h\"\n\nstruct uapi_priv_data {\n\tstruct fsl_mc_uapi *uapi;\n\tstruct fsl_mc_io *mc_io;\n};\n\nstruct fsl_mc_cmd_desc {\n\tu16 cmdid_value;\n\tu16 cmdid_mask;\n\tint size;\n\tbool token;\n\tint flags;\n};\n\n#define FSL_MC_CHECK_MODULE_ID\t\tBIT(0)\n#define FSL_MC_CAP_NET_ADMIN_NEEDED\tBIT(1)\n\nenum fsl_mc_cmd_index {\n\tDPDBG_DUMP = 0,\n\tDPDBG_SET,\n\tDPRC_GET_CONTAINER_ID,\n\tDPRC_CREATE_CONT,\n\tDPRC_DESTROY_CONT,\n\tDPRC_ASSIGN,\n\tDPRC_UNASSIGN,\n\tDPRC_GET_OBJ_COUNT,\n\tDPRC_GET_OBJ,\n\tDPRC_GET_RES_COUNT,\n\tDPRC_GET_RES_IDS,\n\tDPRC_SET_OBJ_LABEL,\n\tDPRC_SET_LOCKED,\n\tDPRC_CONNECT,\n\tDPRC_DISCONNECT,\n\tDPRC_GET_POOL,\n\tDPRC_GET_POOL_COUNT,\n\tDPRC_GET_CONNECTION,\n\tDPCI_GET_LINK_STATE,\n\tDPCI_GET_PEER_ATTR,\n\tDPAIOP_GET_SL_VERSION,\n\tDPAIOP_GET_STATE,\n\tDPMNG_GET_VERSION,\n\tDPSECI_GET_TX_QUEUE,\n\tDPMAC_GET_COUNTER,\n\tDPMAC_GET_MAC_ADDR,\n\tDPNI_SET_PRIM_MAC,\n\tDPNI_GET_PRIM_MAC,\n\tDPNI_GET_STATISTICS,\n\tDPNI_GET_LINK_STATE,\n\tDPNI_GET_MAX_FRAME_LENGTH,\n\tDPSW_GET_TAILDROP,\n\tDPSW_SET_TAILDROP,\n\tDPSW_IF_GET_COUNTER,\n\tDPSW_IF_GET_MAX_FRAME_LENGTH,\n\tDPDMUX_GET_COUNTER,\n\tDPDMUX_IF_GET_MAX_FRAME_LENGTH,\n\tGET_ATTR,\n\tGET_IRQ_MASK,\n\tGET_IRQ_STATUS,\n\tCLOSE,\n\tOPEN,\n\tGET_API_VERSION,\n\tDESTROY,\n\tCREATE,\n};\n\nstatic struct fsl_mc_cmd_desc fsl_mc_accepted_cmds[] = {\n\t[DPDBG_DUMP] = {\n\t\t.cmdid_value = 0x1300,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 28,\n\t},\n\t[DPDBG_SET] = {\n\t\t.cmdid_value = 0x1400,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 28,\n\t},\n\t[DPRC_GET_CONTAINER_ID] = {\n\t\t.cmdid_value = 0x8300,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = false,\n\t\t.size = 8,\n\t},\n\t[DPRC_CREATE_CONT] = {\n\t\t.cmdid_value = 0x1510,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 40,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_DESTROY_CONT] = {\n\t\t.cmdid_value = 0x1520,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 12,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_ASSIGN] = {\n\t\t.cmdid_value = 0x1570,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 40,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_UNASSIGN] = {\n\t\t.cmdid_value = 0x1580,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 40,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_GET_OBJ_COUNT] = {\n\t\t.cmdid_value = 0x1590,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 16,\n\t},\n\t[DPRC_GET_OBJ] = {\n\t\t.cmdid_value = 0x15A0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 12,\n\t},\n\t[DPRC_GET_RES_COUNT] = {\n\t\t.cmdid_value = 0x15B0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 32,\n\t},\n\t[DPRC_GET_RES_IDS] = {\n\t\t.cmdid_value = 0x15C0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 40,\n\t},\n\t[DPRC_SET_OBJ_LABEL] = {\n\t\t.cmdid_value = 0x1610,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 48,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_SET_LOCKED] = {\n\t\t.cmdid_value = 0x16B0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 16,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_CONNECT] = {\n\t\t.cmdid_value = 0x1670,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 56,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_DISCONNECT] = {\n\t\t.cmdid_value = 0x1680,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 32,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPRC_GET_POOL] = {\n\t\t.cmdid_value = 0x1690,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 12,\n\t},\n\t[DPRC_GET_POOL_COUNT] = {\n\t\t.cmdid_value = 0x16A0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPRC_GET_CONNECTION] = {\n\t\t.cmdid_value = 0x16C0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 32,\n\t},\n\n\t[DPCI_GET_LINK_STATE] = {\n\t\t.cmdid_value = 0x0E10,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPCI_GET_PEER_ATTR] = {\n\t\t.cmdid_value = 0x0E20,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPAIOP_GET_SL_VERSION] = {\n\t\t.cmdid_value = 0x2820,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPAIOP_GET_STATE] = {\n\t\t.cmdid_value = 0x2830,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPMNG_GET_VERSION] = {\n\t\t.cmdid_value = 0x8310,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = false,\n\t\t.size = 8,\n\t},\n\t[DPSECI_GET_TX_QUEUE] = {\n\t\t.cmdid_value = 0x1970,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 14,\n\t},\n\t[DPMAC_GET_COUNTER] = {\n\t\t.cmdid_value = 0x0c40,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 9,\n\t},\n\t[DPMAC_GET_MAC_ADDR] = {\n\t\t.cmdid_value = 0x0c50,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPNI_SET_PRIM_MAC] = {\n\t\t.cmdid_value = 0x2240,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 16,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPNI_GET_PRIM_MAC] = {\n\t\t.cmdid_value = 0x2250,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPNI_GET_STATISTICS] = {\n\t\t.cmdid_value = 0x25D0,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 10,\n\t},\n\t[DPNI_GET_LINK_STATE] = {\n\t\t.cmdid_value = 0x2150,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPNI_GET_MAX_FRAME_LENGTH] = {\n\t\t.cmdid_value = 0x2170,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[DPSW_GET_TAILDROP] = {\n\t\t.cmdid_value = 0x0A80,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 14,\n\t},\n\t[DPSW_SET_TAILDROP] = {\n\t\t.cmdid_value = 0x0A90,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 24,\n\t\t.flags = FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[DPSW_IF_GET_COUNTER] = {\n\t\t.cmdid_value = 0x0340,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 11,\n\t},\n\t[DPSW_IF_GET_MAX_FRAME_LENGTH] = {\n\t\t.cmdid_value = 0x0450,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 10,\n\t},\n\t[DPDMUX_GET_COUNTER] = {\n\t\t.cmdid_value = 0x0b20,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 11,\n\t},\n\t[DPDMUX_IF_GET_MAX_FRAME_LENGTH] = {\n\t\t.cmdid_value = 0x0a20,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 10,\n\t},\n\t[GET_ATTR] = {\n\t\t.cmdid_value = 0x0040,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\t[GET_IRQ_MASK] = {\n\t\t.cmdid_value = 0x0150,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 13,\n\t},\n\t[GET_IRQ_STATUS] = {\n\t\t.cmdid_value = 0x0160,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 13,\n\t},\n\t[CLOSE] = {\n\t\t.cmdid_value = 0x8000,\n\t\t.cmdid_mask = 0xFFF0,\n\t\t.token = true,\n\t\t.size = 8,\n\t},\n\n\t \n\t[OPEN] = {\n\t\t.cmdid_value = 0x8000,\n\t\t.cmdid_mask = 0xFC00,\n\t\t.token = false,\n\t\t.size = 12,\n\t\t.flags = FSL_MC_CHECK_MODULE_ID,\n\t},\n\t[GET_API_VERSION] = {\n\t\t.cmdid_value = 0xA000,\n\t\t.cmdid_mask = 0xFC00,\n\t\t.token = false,\n\t\t.size = 8,\n\t\t.flags = FSL_MC_CHECK_MODULE_ID,\n\t},\n\t[DESTROY] = {\n\t\t.cmdid_value = 0x9800,\n\t\t.cmdid_mask = 0xFC00,\n\t\t.token = true,\n\t\t.size = 12,\n\t\t.flags = FSL_MC_CHECK_MODULE_ID | FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n\t[CREATE] = {\n\t\t.cmdid_value = 0x9000,\n\t\t.cmdid_mask = 0xFC00,\n\t\t.token = true,\n\t\t.size = 64,\n\t\t.flags = FSL_MC_CHECK_MODULE_ID | FSL_MC_CAP_NET_ADMIN_NEEDED,\n\t},\n};\n\n#define FSL_MC_NUM_ACCEPTED_CMDS ARRAY_SIZE(fsl_mc_accepted_cmds)\n\n#define FSL_MC_MAX_MODULE_ID 0x10\n\nstatic int fsl_mc_command_check(struct fsl_mc_device *mc_dev,\n\t\t\t\tstruct fsl_mc_command *mc_cmd)\n{\n\tstruct fsl_mc_cmd_desc *desc = NULL;\n\tint mc_cmd_max_size, i;\n\tbool token_provided;\n\tu16 cmdid, module_id;\n\tchar *mc_cmd_end;\n\tchar sum = 0;\n\n\t \n\tcmdid = mc_cmd_hdr_read_cmdid(mc_cmd);\n\tfor (i = 0; i < FSL_MC_NUM_ACCEPTED_CMDS; i++) {\n\t\tdesc = &fsl_mc_accepted_cmds[i];\n\t\tif ((cmdid & desc->cmdid_mask) == desc->cmdid_value)\n\t\t\tbreak;\n\t}\n\tif (i == FSL_MC_NUM_ACCEPTED_CMDS) {\n\t\tdev_err(&mc_dev->dev, \"MC command 0x%04x: cmdid not accepted\\n\", cmdid);\n\t\treturn -EACCES;\n\t}\n\n\t \n\tmc_cmd_max_size = sizeof(*mc_cmd);\n\tmc_cmd_end = ((char *)mc_cmd) + desc->size;\n\tfor (i = desc->size; i < mc_cmd_max_size; i++)\n\t\tsum |= *mc_cmd_end++;\n\tif (sum) {\n\t\tdev_err(&mc_dev->dev, \"MC command 0x%04x: garbage beyond max size of %d bytes!\\n\",\n\t\t\tcmdid, desc->size);\n\t\treturn -EACCES;\n\t}\n\n\t \n\ttoken_provided = mc_cmd_hdr_read_token(mc_cmd) ? true : false;\n\tif (token_provided != desc->token) {\n\t\tdev_err(&mc_dev->dev, \"MC command 0x%04x: token 0x%04x is invalid!\\n\",\n\t\t\tcmdid, mc_cmd_hdr_read_token(mc_cmd));\n\t\treturn -EACCES;\n\t}\n\n\t \n\tif (desc->flags & FSL_MC_CHECK_MODULE_ID) {\n\t\t \n\t\tmodule_id = (cmdid & GENMASK(9, 4)) >> 4;\n\t\tif (module_id == 0 || module_id > FSL_MC_MAX_MODULE_ID) {\n\t\t\tdev_err(&mc_dev->dev, \"MC command 0x%04x: unknown module ID 0x%x\\n\",\n\t\t\t\tcmdid, module_id);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\t \n\tif (desc->flags & FSL_MC_CAP_NET_ADMIN_NEEDED) {\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tdev_err(&mc_dev->dev, \"MC command 0x%04x: needs CAP_NET_ADMIN!\\n\",\n\t\t\t\tcmdid);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_mc_uapi_send_command(struct fsl_mc_device *mc_dev, unsigned long arg,\n\t\t\t\t    struct fsl_mc_io *mc_io)\n{\n\tstruct fsl_mc_command mc_cmd;\n\tint error;\n\n\terror = copy_from_user(&mc_cmd, (void __user *)arg, sizeof(mc_cmd));\n\tif (error)\n\t\treturn -EFAULT;\n\n\terror = fsl_mc_command_check(mc_dev, &mc_cmd);\n\tif (error)\n\t\treturn error;\n\n\terror = mc_send_command(mc_io, &mc_cmd);\n\tif (error)\n\t\treturn error;\n\n\terror = copy_to_user((void __user *)arg, &mc_cmd, sizeof(mc_cmd));\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int fsl_mc_uapi_dev_open(struct inode *inode, struct file *filep)\n{\n\tstruct fsl_mc_device *root_mc_device;\n\tstruct uapi_priv_data *priv_data;\n\tstruct fsl_mc_io *dynamic_mc_io;\n\tstruct fsl_mc_uapi *mc_uapi;\n\tstruct fsl_mc_bus *mc_bus;\n\tint error;\n\n\tpriv_data = kzalloc(sizeof(*priv_data), GFP_KERNEL);\n\tif (!priv_data)\n\t\treturn -ENOMEM;\n\n\tmc_uapi = container_of(filep->private_data, struct fsl_mc_uapi, misc);\n\tmc_bus = container_of(mc_uapi, struct fsl_mc_bus, uapi_misc);\n\troot_mc_device = &mc_bus->mc_dev;\n\n\tmutex_lock(&mc_uapi->mutex);\n\n\tif (!mc_uapi->local_instance_in_use) {\n\t\tpriv_data->mc_io = mc_uapi->static_mc_io;\n\t\tmc_uapi->local_instance_in_use = 1;\n\t} else {\n\t\terror = fsl_mc_portal_allocate(root_mc_device, 0,\n\t\t\t\t\t       &dynamic_mc_io);\n\t\tif (error) {\n\t\t\tdev_dbg(&root_mc_device->dev,\n\t\t\t\t\"Could not allocate MC portal\\n\");\n\t\t\tgoto error_portal_allocate;\n\t\t}\n\n\t\tpriv_data->mc_io = dynamic_mc_io;\n\t}\n\tpriv_data->uapi = mc_uapi;\n\tfilep->private_data = priv_data;\n\n\tmutex_unlock(&mc_uapi->mutex);\n\n\treturn 0;\n\nerror_portal_allocate:\n\tmutex_unlock(&mc_uapi->mutex);\n\tkfree(priv_data);\n\n\treturn error;\n}\n\nstatic int fsl_mc_uapi_dev_release(struct inode *inode, struct file *filep)\n{\n\tstruct uapi_priv_data *priv_data;\n\tstruct fsl_mc_uapi *mc_uapi;\n\tstruct fsl_mc_io *mc_io;\n\n\tpriv_data = filep->private_data;\n\tmc_uapi = priv_data->uapi;\n\tmc_io = priv_data->mc_io;\n\n\tmutex_lock(&mc_uapi->mutex);\n\n\tif (mc_io == mc_uapi->static_mc_io)\n\t\tmc_uapi->local_instance_in_use = 0;\n\telse\n\t\tfsl_mc_portal_free(mc_io);\n\n\tkfree(filep->private_data);\n\tfilep->private_data =  NULL;\n\n\tmutex_unlock(&mc_uapi->mutex);\n\n\treturn 0;\n}\n\nstatic long fsl_mc_uapi_dev_ioctl(struct file *file,\n\t\t\t\t  unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct uapi_priv_data *priv_data = file->private_data;\n\tstruct fsl_mc_device *root_mc_device;\n\tstruct fsl_mc_bus *mc_bus;\n\tint error;\n\n\tmc_bus = container_of(priv_data->uapi, struct fsl_mc_bus, uapi_misc);\n\troot_mc_device = &mc_bus->mc_dev;\n\n\tswitch (cmd) {\n\tcase FSL_MC_SEND_MC_COMMAND:\n\t\terror = fsl_mc_uapi_send_command(root_mc_device, arg, priv_data->mc_io);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&root_mc_device->dev, \"unexpected ioctl call number\\n\");\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}\n\nstatic const struct file_operations fsl_mc_uapi_dev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fsl_mc_uapi_dev_open,\n\t.release = fsl_mc_uapi_dev_release,\n\t.unlocked_ioctl = fsl_mc_uapi_dev_ioctl,\n};\n\nint fsl_mc_uapi_create_device_file(struct fsl_mc_bus *mc_bus)\n{\n\tstruct fsl_mc_device *mc_dev = &mc_bus->mc_dev;\n\tstruct fsl_mc_uapi *mc_uapi = &mc_bus->uapi_misc;\n\tint error;\n\n\tmc_uapi->misc.minor = MISC_DYNAMIC_MINOR;\n\tmc_uapi->misc.name = dev_name(&mc_dev->dev);\n\tmc_uapi->misc.fops = &fsl_mc_uapi_dev_fops;\n\n\terror = misc_register(&mc_uapi->misc);\n\tif (error)\n\t\treturn error;\n\n\tmc_uapi->static_mc_io = mc_bus->mc_dev.mc_io;\n\n\tmutex_init(&mc_uapi->mutex);\n\n\treturn 0;\n}\n\nvoid fsl_mc_uapi_remove_device_file(struct fsl_mc_bus *mc_bus)\n{\n\tmisc_deregister(&mc_bus->uapi_misc.misc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}