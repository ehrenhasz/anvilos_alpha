{
  "module_name": "moxtet.c",
  "hash_id": "5bbc083aa73827b79ef16847233b8caa113ec45a7116667ce3d231a5ea39f1e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/moxtet.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/bus/moxtet.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moxtet.h>\n#include <linux/mutex.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/spi/spi.h>\n\n \nstatic const struct {\n\tconst char *name;\n\tint hwirq_base;\n\tint nirqs;\n\tconst char *desc;\n} mox_module_table[] = {\n\t \n\t{ NULL,\t\t 0,\t\t\t0, NULL },\n\t{ \"sfp\",\t-1,\t\t\t0, \"MOX D (SFP cage)\" },\n\t{ \"pci\",\tMOXTET_IRQ_PCI,\t\t1, \"MOX B (Mini-PCIe)\" },\n\t{ \"topaz\",\tMOXTET_IRQ_TOPAZ,\t1, \"MOX C (4 port switch)\" },\n\t{ \"peridot\",\tMOXTET_IRQ_PERIDOT(0),\t1, \"MOX E (8 port switch)\" },\n\t{ \"usb3\",\tMOXTET_IRQ_USB3,\t2, \"MOX F (USB 3.0)\" },\n\t{ \"pci-bridge\",\t-1,\t\t\t0, \"MOX G (Mini-PCIe bridge)\" },\n};\n\nstatic inline bool mox_module_known(unsigned int id)\n{\n\treturn id >= TURRIS_MOX_MODULE_FIRST && id <= TURRIS_MOX_MODULE_LAST;\n}\n\nstatic inline const char *mox_module_name(unsigned int id)\n{\n\tif (mox_module_known(id))\n\t\treturn mox_module_table[id].name;\n\telse\n\t\treturn \"unknown\";\n}\n\n#define DEF_MODULE_ATTR(name, fmt, ...)\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nmodule_##name##_show(struct device *dev, struct device_attribute *a,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\t\t\\\n\treturn sprintf(buf, (fmt), __VA_ARGS__);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(module_##name)\n\nDEF_MODULE_ATTR(id, \"0x%x\\n\", mdev->id);\nDEF_MODULE_ATTR(name, \"%s\\n\", mox_module_name(mdev->id));\nDEF_MODULE_ATTR(description, \"%s\\n\",\n\t\tmox_module_known(mdev->id) ? mox_module_table[mdev->id].desc\n\t\t\t\t\t   : \"\");\n\nstatic struct attribute *moxtet_dev_attrs[] = {\n\t&dev_attr_module_id.attr,\n\t&dev_attr_module_name.attr,\n\t&dev_attr_module_description.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group moxtet_dev_group = {\n\t.attrs = moxtet_dev_attrs,\n};\n\nstatic const struct attribute_group *moxtet_dev_groups[] = {\n\t&moxtet_dev_group,\n\tNULL,\n};\n\nstatic int moxtet_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\tstruct moxtet_driver *tdrv = to_moxtet_driver(drv);\n\tconst enum turris_mox_module_id *t;\n\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (!tdrv->id_table)\n\t\treturn 0;\n\n\tfor (t = tdrv->id_table; *t; ++t)\n\t\tif (*t == mdev->id)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct bus_type moxtet_bus_type = {\n\t.name\t\t= \"moxtet\",\n\t.dev_groups\t= moxtet_dev_groups,\n\t.match\t\t= moxtet_match,\n};\n\nint __moxtet_register_driver(struct module *owner,\n\t\t\t     struct moxtet_driver *mdrv)\n{\n\tmdrv->driver.owner = owner;\n\tmdrv->driver.bus = &moxtet_bus_type;\n\treturn driver_register(&mdrv->driver);\n}\nEXPORT_SYMBOL_GPL(__moxtet_register_driver);\n\nstatic int moxtet_dev_check(struct device *dev, void *data)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\tstruct moxtet_device *new_dev = data;\n\n\tif (mdev->moxtet == new_dev->moxtet && mdev->id == new_dev->id &&\n\t    mdev->idx == new_dev->idx)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic void moxtet_dev_release(struct device *dev)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\n\tput_device(mdev->moxtet->dev);\n\tkfree(mdev);\n}\n\nstatic struct moxtet_device *\nmoxtet_alloc_device(struct moxtet *moxtet)\n{\n\tstruct moxtet_device *dev;\n\n\tif (!get_device(moxtet->dev))\n\t\treturn NULL;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tput_device(moxtet->dev);\n\t\treturn NULL;\n\t}\n\n\tdev->moxtet = moxtet;\n\tdev->dev.parent = moxtet->dev;\n\tdev->dev.bus = &moxtet_bus_type;\n\tdev->dev.release = moxtet_dev_release;\n\n\tdevice_initialize(&dev->dev);\n\n\treturn dev;\n}\n\nstatic int moxtet_add_device(struct moxtet_device *dev)\n{\n\tstatic DEFINE_MUTEX(add_mutex);\n\tint ret;\n\n\tif (dev->idx >= TURRIS_MOX_MAX_MODULES || dev->id > 0xf)\n\t\treturn -EINVAL;\n\n\tdev_set_name(&dev->dev, \"moxtet-%s.%u\", mox_module_name(dev->id),\n\t\t     dev->idx);\n\n\tmutex_lock(&add_mutex);\n\n\tret = bus_for_each_dev(&moxtet_bus_type, NULL, dev,\n\t\t\t       moxtet_dev_check);\n\tif (ret)\n\t\tgoto done;\n\n\tret = device_add(&dev->dev);\n\tif (ret < 0)\n\t\tdev_err(dev->moxtet->dev, \"can't add %s, status %d\\n\",\n\t\t\tdev_name(dev->moxtet->dev), ret);\n\ndone:\n\tmutex_unlock(&add_mutex);\n\treturn ret;\n}\n\nstatic int __unregister(struct device *dev, void *null)\n{\n\tif (dev->of_node) {\n\t\tof_node_clear_flag(dev->of_node, OF_POPULATED);\n\t\tof_node_put(dev->of_node);\n\t}\n\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nstatic struct moxtet_device *\nof_register_moxtet_device(struct moxtet *moxtet, struct device_node *nc)\n{\n\tstruct moxtet_device *dev;\n\tu32 val;\n\tint ret;\n\n\tdev = moxtet_alloc_device(moxtet);\n\tif (!dev) {\n\t\tdev_err(moxtet->dev,\n\t\t\t\"Moxtet device alloc error for %pOF\\n\", nc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tret = of_property_read_u32(nc, \"reg\", &val);\n\tif (ret) {\n\t\tdev_err(moxtet->dev, \"%pOF has no valid 'reg' property (%d)\\n\",\n\t\t\tnc, ret);\n\t\tgoto err_put;\n\t}\n\n\tdev->idx = val;\n\n\tif (dev->idx >= TURRIS_MOX_MAX_MODULES) {\n\t\tdev_err(moxtet->dev, \"%pOF Moxtet address 0x%x out of range\\n\",\n\t\t\tnc, dev->idx);\n\t\tret = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tdev->id = moxtet->modules[dev->idx];\n\n\tif (!dev->id) {\n\t\tdev_err(moxtet->dev, \"%pOF Moxtet address 0x%x is empty\\n\", nc,\n\t\t\tdev->idx);\n\t\tret = -ENODEV;\n\t\tgoto err_put;\n\t}\n\n\tof_node_get(nc);\n\tdev->dev.of_node = nc;\n\n\tret = moxtet_add_device(dev);\n\tif (ret) {\n\t\tdev_err(moxtet->dev,\n\t\t\t\"Moxtet device register error for %pOF\\n\", nc);\n\t\tof_node_put(nc);\n\t\tgoto err_put;\n\t}\n\n\treturn dev;\n\nerr_put:\n\tput_device(&dev->dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic void of_register_moxtet_devices(struct moxtet *moxtet)\n{\n\tstruct moxtet_device *dev;\n\tstruct device_node *nc;\n\n\tif (!moxtet->dev->of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(moxtet->dev->of_node, nc) {\n\t\tif (of_node_test_and_set_flag(nc, OF_POPULATED))\n\t\t\tcontinue;\n\t\tdev = of_register_moxtet_device(moxtet, nc);\n\t\tif (IS_ERR(dev)) {\n\t\t\tdev_warn(moxtet->dev,\n\t\t\t\t \"Failed to create Moxtet device for %pOF\\n\",\n\t\t\t\t nc);\n\t\t\tof_node_clear_flag(nc, OF_POPULATED);\n\t\t}\n\t}\n}\n\nstatic void\nmoxtet_register_devices_from_topology(struct moxtet *moxtet)\n{\n\tstruct moxtet_device *dev;\n\tint i, ret;\n\n\tfor (i = 0; i < moxtet->count; ++i) {\n\t\tdev = moxtet_alloc_device(moxtet);\n\t\tif (!dev) {\n\t\t\tdev_err(moxtet->dev, \"Moxtet device %u alloc error\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev->idx = i;\n\t\tdev->id = moxtet->modules[i];\n\n\t\tret = moxtet_add_device(dev);\n\t\tif (ret && ret != -EBUSY) {\n\t\t\tput_device(&dev->dev);\n\t\t\tdev_err(moxtet->dev,\n\t\t\t\t\"Moxtet device %u register error: %i\\n\", i,\n\t\t\t\tret);\n\t\t}\n\t}\n}\n\n \nstatic int moxtet_set_irq(struct moxtet *moxtet, int idx, int id, int nsame)\n{\n\tint i, first;\n\tstruct moxtet_irqpos *pos;\n\n\tfirst = mox_module_table[id].hwirq_base +\n\t\tnsame * mox_module_table[id].nirqs;\n\n\tif (first + mox_module_table[id].nirqs > MOXTET_NIRQS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < mox_module_table[id].nirqs; ++i) {\n\t\tpos = &moxtet->irq.position[first + i];\n\t\tpos->idx = idx;\n\t\tpos->bit = i;\n\t\tmoxtet->irq.exists |= BIT(first + i);\n\t}\n\n\treturn 0;\n}\n\nstatic int moxtet_find_topology(struct moxtet *moxtet)\n{\n\tu8 buf[TURRIS_MOX_MAX_MODULES];\n\tint cnts[TURRIS_MOX_MODULE_LAST];\n\tint i, ret;\n\n\tmemset(cnts, 0, sizeof(cnts));\n\n\tret = spi_read(to_spi_device(moxtet->dev), buf, TURRIS_MOX_MAX_MODULES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buf[0] == TURRIS_MOX_CPU_ID_EMMC) {\n\t\tdev_info(moxtet->dev, \"Found MOX A (eMMC CPU) module\\n\");\n\t} else if (buf[0] == TURRIS_MOX_CPU_ID_SD) {\n\t\tdev_info(moxtet->dev, \"Found MOX A (CPU) module\\n\");\n\t} else {\n\t\tdev_err(moxtet->dev, \"Invalid Turris MOX A CPU module 0x%02x\\n\",\n\t\t\tbuf[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tmoxtet->count = 0;\n\n\tfor (i = 1; i < TURRIS_MOX_MAX_MODULES; ++i) {\n\t\tint id;\n\n\t\tif (buf[i] == 0xff)\n\t\t\tbreak;\n\n\t\tid = buf[i] & 0xf;\n\n\t\tmoxtet->modules[i-1] = id;\n\t\t++moxtet->count;\n\n\t\tif (mox_module_known(id)) {\n\t\t\tdev_info(moxtet->dev, \"Found %s module\\n\",\n\t\t\t\t mox_module_table[id].desc);\n\n\t\t\tif (moxtet_set_irq(moxtet, i-1, id, cnts[id]++) < 0)\n\t\t\t\tdev_err(moxtet->dev,\n\t\t\t\t\t\"  Cannot set IRQ for module %s\\n\",\n\t\t\t\t\tmox_module_table[id].desc);\n\t\t} else {\n\t\t\tdev_warn(moxtet->dev,\n\t\t\t\t \"Unknown Moxtet module found (ID 0x%02x)\\n\",\n\t\t\t\t id);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int moxtet_spi_read(struct moxtet *moxtet, u8 *buf)\n{\n\tstruct spi_transfer xfer = {\n\t\t.rx_buf = buf,\n\t\t.tx_buf = moxtet->tx,\n\t\t.len = moxtet->count + 1\n\t};\n\tint ret;\n\n\tmutex_lock(&moxtet->lock);\n\n\tret = spi_sync_transfer(to_spi_device(moxtet->dev), &xfer, 1);\n\n\tmutex_unlock(&moxtet->lock);\n\n\treturn ret;\n}\n\nint moxtet_device_read(struct device *dev)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\tstruct moxtet *moxtet = mdev->moxtet;\n\tu8 buf[TURRIS_MOX_MAX_MODULES];\n\tint ret;\n\n\tif (mdev->idx >= moxtet->count)\n\t\treturn -EINVAL;\n\n\tret = moxtet_spi_read(moxtet, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf[mdev->idx + 1] >> 4;\n}\nEXPORT_SYMBOL_GPL(moxtet_device_read);\n\nint moxtet_device_write(struct device *dev, u8 val)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\tstruct moxtet *moxtet = mdev->moxtet;\n\tint ret;\n\n\tif (mdev->idx >= moxtet->count)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&moxtet->lock);\n\n\tmoxtet->tx[moxtet->count - mdev->idx] = val;\n\n\tret = spi_write(to_spi_device(moxtet->dev), moxtet->tx,\n\t\t\tmoxtet->count + 1);\n\n\tmutex_unlock(&moxtet->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(moxtet_device_write);\n\nint moxtet_device_written(struct device *dev)\n{\n\tstruct moxtet_device *mdev = to_moxtet_device(dev);\n\tstruct moxtet *moxtet = mdev->moxtet;\n\n\tif (mdev->idx >= moxtet->count)\n\t\treturn -EINVAL;\n\n\treturn moxtet->tx[moxtet->count - mdev->idx];\n}\nEXPORT_SYMBOL_GPL(moxtet_device_written);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int moxtet_debug_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t input_read(struct file *file, char __user *buf, size_t len,\n\t\t\t  loff_t *ppos)\n{\n\tstruct moxtet *moxtet = file->private_data;\n\tu8 bin[TURRIS_MOX_MAX_MODULES];\n\tu8 hex[sizeof(bin) * 2 + 1];\n\tint ret, n;\n\n\tret = moxtet_spi_read(moxtet, bin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tn = moxtet->count + 1;\n\tbin2hex(hex, bin, n);\n\n\thex[2*n] = '\\n';\n\n\treturn simple_read_from_buffer(buf, len, ppos, hex, 2*n + 1);\n}\n\nstatic const struct file_operations input_fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= moxtet_debug_open,\n\t.read\t= input_read,\n\t.llseek\t= no_llseek,\n};\n\nstatic ssize_t output_read(struct file *file, char __user *buf, size_t len,\n\t\t\t   loff_t *ppos)\n{\n\tstruct moxtet *moxtet = file->private_data;\n\tu8 hex[TURRIS_MOX_MAX_MODULES * 2 + 1];\n\tu8 *p = hex;\n\tint i;\n\n\tmutex_lock(&moxtet->lock);\n\n\tfor (i = 0; i < moxtet->count; ++i)\n\t\tp = hex_byte_pack(p, moxtet->tx[moxtet->count - i]);\n\n\tmutex_unlock(&moxtet->lock);\n\n\t*p++ = '\\n';\n\n\treturn simple_read_from_buffer(buf, len, ppos, hex, p - hex);\n}\n\nstatic ssize_t output_write(struct file *file, const char __user *buf,\n\t\t\t    size_t len, loff_t *ppos)\n{\n\tstruct moxtet *moxtet = file->private_data;\n\tu8 bin[TURRIS_MOX_MAX_MODULES];\n\tu8 hex[sizeof(bin) * 2 + 1];\n\tssize_t res;\n\tloff_t dummy = 0;\n\tint err, i;\n\n\tif (len > 2 * moxtet->count + 1 || len < 2 * moxtet->count)\n\t\treturn -EINVAL;\n\n\tres = simple_write_to_buffer(hex, sizeof(hex), &dummy, buf, len);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (len % 2 == 1 && hex[len - 1] != '\\n')\n\t\treturn -EINVAL;\n\n\terr = hex2bin(bin, hex, moxtet->count);\n\tif (err < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&moxtet->lock);\n\n\tfor (i = 0; i < moxtet->count; ++i)\n\t\tmoxtet->tx[moxtet->count - i] = bin[i];\n\n\terr = spi_write(to_spi_device(moxtet->dev), moxtet->tx,\n\t\t\tmoxtet->count + 1);\n\n\tmutex_unlock(&moxtet->lock);\n\n\treturn err < 0 ? err : len;\n}\n\nstatic const struct file_operations output_fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= moxtet_debug_open,\n\t.read\t= output_read,\n\t.write\t= output_write,\n\t.llseek\t= no_llseek,\n};\n\nstatic int moxtet_register_debugfs(struct moxtet *moxtet)\n{\n\tstruct dentry *root, *entry;\n\n\troot = debugfs_create_dir(\"moxtet\", NULL);\n\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tentry = debugfs_create_file_unsafe(\"input\", 0444, root, moxtet,\n\t\t\t\t\t   &input_fops);\n\tif (IS_ERR(entry))\n\t\tgoto err_remove;\n\n\tentry = debugfs_create_file_unsafe(\"output\", 0644, root, moxtet,\n\t\t\t\t\t   &output_fops);\n\tif (IS_ERR(entry))\n\t\tgoto err_remove;\n\n\tmoxtet->debugfs_root = root;\n\n\treturn 0;\nerr_remove:\n\tdebugfs_remove_recursive(root);\n\treturn PTR_ERR(entry);\n}\n\nstatic void moxtet_unregister_debugfs(struct moxtet *moxtet)\n{\n\tdebugfs_remove_recursive(moxtet->debugfs_root);\n}\n#else\nstatic inline int moxtet_register_debugfs(struct moxtet *moxtet)\n{\n\treturn 0;\n}\n\nstatic inline void moxtet_unregister_debugfs(struct moxtet *moxtet)\n{\n}\n#endif\n\nstatic int moxtet_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t irq_hw_number_t hw)\n{\n\tstruct moxtet *moxtet = d->host_data;\n\n\tif (hw >= MOXTET_NIRQS || !(moxtet->irq.exists & BIT(hw))) {\n\t\tdev_err(moxtet->dev, \"Invalid hw irq number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_chip_and_handler(irq, &moxtet->irq.chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic int moxtet_irq_domain_xlate(struct irq_domain *d,\n\t\t\t\t   struct device_node *ctrlr,\n\t\t\t\t   const u32 *intspec, unsigned int intsize,\n\t\t\t\t   unsigned long *out_hwirq,\n\t\t\t\t   unsigned int *out_type)\n{\n\tstruct moxtet *moxtet = d->host_data;\n\tint irq;\n\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\n\tirq = intspec[0];\n\n\tif (irq >= MOXTET_NIRQS || !(moxtet->irq.exists & BIT(irq)))\n\t\treturn -EINVAL;\n\n\t*out_hwirq = irq;\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops moxtet_irq_domain = {\n\t.map = moxtet_irq_domain_map,\n\t.xlate = moxtet_irq_domain_xlate,\n};\n\nstatic void moxtet_irq_mask(struct irq_data *d)\n{\n\tstruct moxtet *moxtet = irq_data_get_irq_chip_data(d);\n\n\tmoxtet->irq.masked |= BIT(d->hwirq);\n}\n\nstatic void moxtet_irq_unmask(struct irq_data *d)\n{\n\tstruct moxtet *moxtet = irq_data_get_irq_chip_data(d);\n\n\tmoxtet->irq.masked &= ~BIT(d->hwirq);\n}\n\nstatic void moxtet_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct moxtet *moxtet = irq_data_get_irq_chip_data(d);\n\tstruct moxtet_irqpos *pos = &moxtet->irq.position[d->hwirq];\n\tint id;\n\n\tid = moxtet->modules[pos->idx];\n\n\tseq_printf(p, \" moxtet-%s.%i#%i\", mox_module_name(id), pos->idx,\n\t\t   pos->bit);\n}\n\nstatic const struct irq_chip moxtet_irq_chip = {\n\t.name\t\t\t= \"moxtet\",\n\t.irq_mask\t\t= moxtet_irq_mask,\n\t.irq_unmask\t\t= moxtet_irq_unmask,\n\t.irq_print_chip\t\t= moxtet_irq_print_chip,\n};\n\nstatic int moxtet_irq_read(struct moxtet *moxtet, unsigned long *map)\n{\n\tstruct moxtet_irqpos *pos = moxtet->irq.position;\n\tu8 buf[TURRIS_MOX_MAX_MODULES];\n\tint i, ret;\n\n\tret = moxtet_spi_read(moxtet, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*map = 0;\n\n\tfor_each_set_bit(i, &moxtet->irq.exists, MOXTET_NIRQS) {\n\t\tif (!(buf[pos[i].idx + 1] & BIT(4 + pos[i].bit)))\n\t\t\tset_bit(i, map);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t moxtet_irq_thread_fn(int irq, void *data)\n{\n\tstruct moxtet *moxtet = data;\n\tunsigned long set;\n\tint nhandled = 0, i, sub_irq, ret;\n\n\tret = moxtet_irq_read(moxtet, &set);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tset &= ~moxtet->irq.masked;\n\n\tdo {\n\t\tfor_each_set_bit(i, &set, MOXTET_NIRQS) {\n\t\t\tsub_irq = irq_find_mapping(moxtet->irq.domain, i);\n\t\t\thandle_nested_irq(sub_irq);\n\t\t\tdev_dbg(moxtet->dev, \"%i irq\\n\", i);\n\t\t\t++nhandled;\n\t\t}\n\n\t\tret = moxtet_irq_read(moxtet, &set);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tset &= ~moxtet->irq.masked;\n\t} while (set);\n\nout:\n\treturn (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);\n}\n\nstatic void moxtet_irq_free(struct moxtet *moxtet)\n{\n\tint i, irq;\n\n\tfor (i = 0; i < MOXTET_NIRQS; ++i) {\n\t\tif (moxtet->irq.exists & BIT(i)) {\n\t\t\tirq = irq_find_mapping(moxtet->irq.domain, i);\n\t\t\tirq_dispose_mapping(irq);\n\t\t}\n\t}\n\n\tirq_domain_remove(moxtet->irq.domain);\n}\n\nstatic int moxtet_irq_setup(struct moxtet *moxtet)\n{\n\tint i, ret;\n\n\tmoxtet->irq.domain = irq_domain_add_simple(moxtet->dev->of_node,\n\t\t\t\t\t\t   MOXTET_NIRQS, 0,\n\t\t\t\t\t\t   &moxtet_irq_domain, moxtet);\n\tif (moxtet->irq.domain == NULL) {\n\t\tdev_err(moxtet->dev, \"Could not add IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < MOXTET_NIRQS; ++i)\n\t\tif (moxtet->irq.exists & BIT(i))\n\t\t\tirq_create_mapping(moxtet->irq.domain, i);\n\n\tmoxtet->irq.chip = moxtet_irq_chip;\n\tmoxtet->irq.masked = ~0;\n\n\tret = request_threaded_irq(moxtet->dev_irq, NULL, moxtet_irq_thread_fn,\n\t\t\t\t   IRQF_SHARED | IRQF_ONESHOT, \"moxtet\", moxtet);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tmoxtet_irq_free(moxtet);\n\treturn ret;\n}\n\nstatic int moxtet_probe(struct spi_device *spi)\n{\n\tstruct moxtet *moxtet;\n\tint ret;\n\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmoxtet = devm_kzalloc(&spi->dev, sizeof(struct moxtet),\n\t\t\t      GFP_KERNEL);\n\tif (!moxtet)\n\t\treturn -ENOMEM;\n\n\tmoxtet->dev = &spi->dev;\n\tspi_set_drvdata(spi, moxtet);\n\n\tmutex_init(&moxtet->lock);\n\n\tmoxtet->dev_irq = of_irq_get(moxtet->dev->of_node, 0);\n\tif (moxtet->dev_irq == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (moxtet->dev_irq <= 0) {\n\t\tdev_err(moxtet->dev, \"No IRQ resource found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = moxtet_find_topology(moxtet);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (moxtet->irq.exists) {\n\t\tret = moxtet_irq_setup(moxtet);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tof_register_moxtet_devices(moxtet);\n\tmoxtet_register_devices_from_topology(moxtet);\n\n\tret = moxtet_register_debugfs(moxtet);\n\tif (ret < 0)\n\t\tdev_warn(moxtet->dev, \"Failed creating debugfs entries: %i\\n\",\n\t\t\t ret);\n\n\treturn 0;\n}\n\nstatic void moxtet_remove(struct spi_device *spi)\n{\n\tstruct moxtet *moxtet = spi_get_drvdata(spi);\n\n\tfree_irq(moxtet->dev_irq, moxtet);\n\n\tmoxtet_irq_free(moxtet);\n\n\tmoxtet_unregister_debugfs(moxtet);\n\n\tdevice_for_each_child(moxtet->dev, NULL, __unregister);\n\n\tmutex_destroy(&moxtet->lock);\n}\n\nstatic const struct spi_device_id moxtet_spi_ids[] = {\n\t{ \"moxtet\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, moxtet_spi_ids);\n\nstatic const struct of_device_id moxtet_dt_ids[] = {\n\t{ .compatible = \"cznic,moxtet\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, moxtet_dt_ids);\n\nstatic struct spi_driver moxtet_spi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"moxtet\",\n\t\t.of_match_table = moxtet_dt_ids,\n\t},\n\t.id_table\t= moxtet_spi_ids,\n\t.probe\t\t= moxtet_probe,\n\t.remove\t\t= moxtet_remove,\n};\n\nstatic int __init moxtet_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&moxtet_bus_type);\n\tif (ret < 0) {\n\t\tpr_err(\"moxtet bus registration failed: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = spi_register_driver(&moxtet_spi_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"moxtet spi driver registration failed: %d\\n\", ret);\n\t\tgoto error_bus;\n\t}\n\n\treturn 0;\n\nerror_bus:\n\tbus_unregister(&moxtet_bus_type);\nerror:\n\treturn ret;\n}\npostcore_initcall_sync(moxtet_init);\n\nstatic void __exit moxtet_exit(void)\n{\n\tspi_unregister_driver(&moxtet_spi_driver);\n\tbus_unregister(&moxtet_bus_type);\n}\nmodule_exit(moxtet_exit);\n\nMODULE_AUTHOR(\"Marek Behun <kabel@kernel.org>\");\nMODULE_DESCRIPTION(\"CZ.NIC's Turris Mox module configuration bus\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}