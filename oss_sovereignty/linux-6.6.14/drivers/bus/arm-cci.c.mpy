{
  "module_name": "arm-cci.c",
  "hash_id": "5cb246cd187b812972c308beb56d69f72b2983272c57762cd8f68e1507e3747a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/arm-cci.c",
  "human_readable_source": " \n\n#include <linux/arm-cci.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/cacheflush.h>\n#include <asm/smp_plat.h>\n\nstatic void __iomem *cci_ctrl_base __ro_after_init;\nstatic unsigned long cci_ctrl_phys __ro_after_init;\n\n#ifdef CONFIG_ARM_CCI400_PORT_CTRL\nstruct cci_nb_ports {\n\tunsigned int nb_ace;\n\tunsigned int nb_ace_lite;\n};\n\nstatic const struct cci_nb_ports cci400_ports = {\n\t.nb_ace = 2,\n\t.nb_ace_lite = 3\n};\n\n#define CCI400_PORTS_DATA\t(&cci400_ports)\n#else\n#define CCI400_PORTS_DATA\t(NULL)\n#endif\n\nstatic const struct of_device_id arm_cci_matches[] = {\n#ifdef CONFIG_ARM_CCI400_COMMON\n\t{.compatible = \"arm,cci-400\", .data = CCI400_PORTS_DATA },\n#endif\n#ifdef CONFIG_ARM_CCI5xx_PMU\n\t{ .compatible = \"arm,cci-500\", },\n\t{ .compatible = \"arm,cci-550\", },\n#endif\n\t{},\n};\n\nstatic const struct of_dev_auxdata arm_cci_auxdata[] = {\n\tOF_DEV_AUXDATA(\"arm,cci-400-pmu\", 0, NULL, &cci_ctrl_base),\n\tOF_DEV_AUXDATA(\"arm,cci-400-pmu,r0\", 0, NULL, &cci_ctrl_base),\n\tOF_DEV_AUXDATA(\"arm,cci-400-pmu,r1\", 0, NULL, &cci_ctrl_base),\n\tOF_DEV_AUXDATA(\"arm,cci-500-pmu,r0\", 0, NULL, &cci_ctrl_base),\n\tOF_DEV_AUXDATA(\"arm,cci-550-pmu,r0\", 0, NULL, &cci_ctrl_base),\n\t{}\n};\n\n#define DRIVER_NAME\t\t\"ARM-CCI\"\n\nstatic int cci_platform_probe(struct platform_device *pdev)\n{\n\tif (!cci_probed())\n\t\treturn -ENODEV;\n\n\treturn of_platform_populate(pdev->dev.of_node, NULL,\n\t\t\t\t    arm_cci_auxdata, &pdev->dev);\n}\n\nstatic struct platform_driver cci_platform_driver = {\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = arm_cci_matches,\n\t\t  },\n\t.probe = cci_platform_probe,\n};\n\nstatic int __init cci_platform_init(void)\n{\n\treturn platform_driver_register(&cci_platform_driver);\n}\n\n#ifdef CONFIG_ARM_CCI400_PORT_CTRL\n\n#define CCI_PORT_CTRL\t\t0x0\n#define CCI_CTRL_STATUS\t\t0xc\n\n#define CCI_ENABLE_SNOOP_REQ\t0x1\n#define CCI_ENABLE_DVM_REQ\t0x2\n#define CCI_ENABLE_REQ\t\t(CCI_ENABLE_SNOOP_REQ | CCI_ENABLE_DVM_REQ)\n\nenum cci_ace_port_type {\n\tACE_INVALID_PORT = 0x0,\n\tACE_PORT,\n\tACE_LITE_PORT,\n};\n\nstruct cci_ace_port {\n\tvoid __iomem *base;\n\tunsigned long phys;\n\tenum cci_ace_port_type type;\n\tstruct device_node *dn;\n};\n\nstatic struct cci_ace_port *ports;\nstatic unsigned int nb_cci_ports;\n\nstruct cpu_port {\n\tu64 mpidr;\n\tu32 port;\n};\n\n \n#define PORT_VALID_SHIFT\t31\n#define PORT_VALID\t\t(0x1 << PORT_VALID_SHIFT)\n\nstatic inline void init_cpu_port(struct cpu_port *port, u32 index, u64 mpidr)\n{\n\tport->port = PORT_VALID | index;\n\tport->mpidr = mpidr;\n}\n\nstatic inline bool cpu_port_is_valid(struct cpu_port *port)\n{\n\treturn !!(port->port & PORT_VALID);\n}\n\nstatic inline bool cpu_port_match(struct cpu_port *port, u64 mpidr)\n{\n\treturn port->mpidr == (mpidr & MPIDR_HWID_BITMASK);\n}\n\nstatic struct cpu_port cpu_port[NR_CPUS];\n\n \nstatic int __cci_ace_get_port(struct device_node *dn, int type)\n{\n\tint i;\n\tbool ace_match;\n\tstruct device_node *cci_portn;\n\n\tcci_portn = of_parse_phandle(dn, \"cci-control-port\", 0);\n\tfor (i = 0; i < nb_cci_ports; i++) {\n\t\tace_match = ports[i].type == type;\n\t\tif (ace_match && cci_portn == ports[i].dn)\n\t\t\treturn i;\n\t}\n\treturn -ENODEV;\n}\n\nint cci_ace_get_port(struct device_node *dn)\n{\n\treturn __cci_ace_get_port(dn, ACE_LITE_PORT);\n}\nEXPORT_SYMBOL_GPL(cci_ace_get_port);\n\nstatic void cci_ace_init_ports(void)\n{\n\tint port, cpu;\n\tstruct device_node *cpun;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\t \n\t\tcpun = of_get_cpu_node(cpu, NULL);\n\n\t\tif (WARN(!cpun, \"Missing cpu device node\\n\"))\n\t\t\tcontinue;\n\n\t\tport = __cci_ace_get_port(cpun, ACE_PORT);\n\t\tif (port < 0)\n\t\t\tcontinue;\n\n\t\tinit_cpu_port(&cpu_port[cpu], port, cpu_logical_map(cpu));\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tWARN(!cpu_port_is_valid(&cpu_port[cpu]),\n\t\t\t\"CPU %u does not have an associated CCI port\\n\",\n\t\t\tcpu);\n\t}\n}\n \n\n \nstatic void notrace cci_port_control(unsigned int port, bool enable)\n{\n\tvoid __iomem *base = ports[port].base;\n\n\twritel_relaxed(enable ? CCI_ENABLE_REQ : 0, base + CCI_PORT_CTRL);\n\t \n\twhile (readl_relaxed(cci_ctrl_base + CCI_CTRL_STATUS) & 0x1)\n\t\t\t;\n}\n\n \nint notrace cci_disable_port_by_cpu(u64 mpidr)\n{\n\tint cpu;\n\tbool is_valid;\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++) {\n\t\tis_valid = cpu_port_is_valid(&cpu_port[cpu]);\n\t\tif (is_valid && cpu_port_match(&cpu_port[cpu], mpidr)) {\n\t\t\tcci_port_control(cpu_port[cpu].port, false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(cci_disable_port_by_cpu);\n\n \nasmlinkage void __naked cci_enable_port_for_self(void)\n{\n\tasm volatile (\"\\n\"\n\"\t.arch armv7-a\\n\"\n\"\tmrc\tp15, 0, r0, c0, c0, 5\t@ get MPIDR value \\n\"\n\"\tand\tr0, r0, #\"__stringify(MPIDR_HWID_BITMASK)\" \\n\"\n\"\tadr\tr1, 5f \\n\"\n\"\tldr\tr2, [r1] \\n\"\n\"\tadd\tr1, r1, r2\t\t@ &cpu_port \\n\"\n\"\tadd\tip, r1, %[sizeof_cpu_port] \\n\"\n\n\t \n\"1:\tldr\tr2, [r1, %[offsetof_cpu_port_mpidr_lsb]] \\n\"\n\"\tcmp\tr2, r0 \t\t\t@ compare MPIDR \\n\"\n\"\tbne\t2f \\n\"\n\n\t \n\"\tldr\tr3, [r1, %[offsetof_cpu_port_port]] \\n\"\n\"\ttst\tr3, #\"__stringify(PORT_VALID)\" \\n\"\n\"\tbne\t3f \\n\"\n\n\t \n\"2:\tadd\tr1, r1, %[sizeof_struct_cpu_port] \\n\"\n\"\tcmp\tr1, ip\t\t\t@ done? \\n\"\n\"\tblo\t1b \\n\"\n\n\t \n\"cci_port_not_found: \\n\"\n\"\twfi \\n\"\n\"\twfe \\n\"\n\"\tb\tcci_port_not_found \\n\"\n\n\t \n\"3:\tbic\tr3, r3, #\"__stringify(PORT_VALID)\" \\n\"\n\"\tadr\tr0, 6f \\n\"\n\"\tldmia\tr0, {r1, r2} \\n\"\n\"\tsub\tr1, r1, r0 \t\t@ virt - phys \\n\"\n\"\tldr\tr0, [r0, r2] \t\t@ *(&ports) \\n\"\n\"\tmov\tr2, %[sizeof_struct_ace_port] \\n\"\n\"\tmla\tr0, r2, r3, r0\t\t@ &ports[index] \\n\"\n\"\tsub\tr0, r0, r1\t\t@ virt_to_phys() \\n\"\n\n\t \n\"\tldr\tr0, [r0, %[offsetof_port_phys]] \\n\"\n\"\tmov\tr3, %[cci_enable_req]\\n\"\t\t   \n\"\tstr\tr3, [r0, #\"__stringify(CCI_PORT_CTRL)\"] \\n\"\n\n\t \n\"\tadr\tr1, 7f \\n\"\n\"\tldr\tr0, [r1] \\n\"\n\"\tldr\tr0, [r0, r1]\t\t@ cci_ctrl_base \\n\"\n\"4:\tldr\tr1, [r0, #\"__stringify(CCI_CTRL_STATUS)\"] \\n\"\n\"\ttst\tr1, %[cci_control_status_bits] \\n\"\t\t\t\n\"\tbne\t4b \\n\"\n\n\"\tmov\tr0, #0 \\n\"\n\"\tbx\tlr \\n\"\n\n\"\t.align\t2 \\n\"\n\"5:\t.word\tcpu_port - . \\n\"\n\"6:\t.word\t. \\n\"\n\"\t.word\tports - 6b \\n\"\n\"7:\t.word\tcci_ctrl_phys - . \\n\"\n\t: :\n\t[sizeof_cpu_port] \"i\" (sizeof(cpu_port)),\n\t[cci_enable_req] \"i\" cpu_to_le32(CCI_ENABLE_REQ),\n\t[cci_control_status_bits] \"i\" cpu_to_le32(1),\n#ifndef __ARMEB__\n\t[offsetof_cpu_port_mpidr_lsb] \"i\" (offsetof(struct cpu_port, mpidr)),\n#else\n\t[offsetof_cpu_port_mpidr_lsb] \"i\" (offsetof(struct cpu_port, mpidr)+4),\n#endif\n\t[offsetof_cpu_port_port] \"i\" (offsetof(struct cpu_port, port)),\n\t[sizeof_struct_cpu_port] \"i\" (sizeof(struct cpu_port)),\n\t[sizeof_struct_ace_port] \"i\" (sizeof(struct cci_ace_port)),\n\t[offsetof_port_phys] \"i\" (offsetof(struct cci_ace_port, phys)) );\n}\n\n \nint notrace __cci_control_port_by_device(struct device_node *dn, bool enable)\n{\n\tint port;\n\n\tif (!dn)\n\t\treturn -ENODEV;\n\n\tport = __cci_ace_get_port(dn, ACE_LITE_PORT);\n\tif (WARN_ONCE(port < 0, \"node %pOF ACE lite port look-up failure\\n\",\n\t\t\t\tdn))\n\t\treturn -ENODEV;\n\tcci_port_control(port, enable);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__cci_control_port_by_device);\n\n \nint notrace __cci_control_port_by_index(u32 port, bool enable)\n{\n\tif (port >= nb_cci_ports || ports[port].type == ACE_INVALID_PORT)\n\t\treturn -ENODEV;\n\t \n\tif (ports[port].type == ACE_PORT)\n\t\treturn -EPERM;\n\n\tcci_port_control(port, enable);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__cci_control_port_by_index);\n\nstatic const struct of_device_id arm_cci_ctrl_if_matches[] = {\n\t{.compatible = \"arm,cci-400-ctrl-if\", },\n\t{},\n};\n\nstatic int cci_probe_ports(struct device_node *np)\n{\n\tstruct cci_nb_ports const *cci_config;\n\tint ret, i, nb_ace = 0, nb_ace_lite = 0;\n\tstruct device_node *cp;\n\tstruct resource res;\n\tconst char *match_str;\n\tbool is_ace;\n\n\n\tcci_config = of_match_node(arm_cci_matches, np)->data;\n\tif (!cci_config)\n\t\treturn -ENODEV;\n\n\tnb_cci_ports = cci_config->nb_ace + cci_config->nb_ace_lite;\n\n\tports = kcalloc(nb_cci_ports, sizeof(*ports), GFP_KERNEL);\n\tif (!ports)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(np, cp) {\n\t\tif (!of_match_node(arm_cci_ctrl_if_matches, cp))\n\t\t\tcontinue;\n\n\t\ti = nb_ace + nb_ace_lite;\n\n\t\tif (i >= nb_cci_ports)\n\t\t\tbreak;\n\n\t\tif (of_property_read_string(cp, \"interface-type\",\n\t\t\t\t\t&match_str)) {\n\t\t\tWARN(1, \"node %pOF missing interface-type property\\n\",\n\t\t\t\t  cp);\n\t\t\tcontinue;\n\t\t}\n\t\tis_ace = strcmp(match_str, \"ace\") == 0;\n\t\tif (!is_ace && strcmp(match_str, \"ace-lite\")) {\n\t\t\tWARN(1, \"node %pOF containing invalid interface-type property, skipping it\\n\",\n\t\t\t\t\tcp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = of_address_to_resource(cp, 0, &res);\n\t\tif (!ret) {\n\t\t\tports[i].base = ioremap(res.start, resource_size(&res));\n\t\t\tports[i].phys = res.start;\n\t\t}\n\t\tif (ret || !ports[i].base) {\n\t\t\tWARN(1, \"unable to ioremap CCI port %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_ace) {\n\t\t\tif (WARN_ON(nb_ace >= cci_config->nb_ace))\n\t\t\t\tcontinue;\n\t\t\tports[i].type = ACE_PORT;\n\t\t\t++nb_ace;\n\t\t} else {\n\t\t\tif (WARN_ON(nb_ace_lite >= cci_config->nb_ace_lite))\n\t\t\t\tcontinue;\n\t\t\tports[i].type = ACE_LITE_PORT;\n\t\t\t++nb_ace_lite;\n\t\t}\n\t\tports[i].dn = cp;\n\t}\n\n\t \n\tif (!nb_ace && !nb_ace_lite)\n\t\treturn -ENODEV;\n\n\t  \n\tcci_ace_init_ports();\n\n\t \n\tsync_cache_w(&cci_ctrl_base);\n\tsync_cache_w(&cci_ctrl_phys);\n\tsync_cache_w(&ports);\n\tsync_cache_w(&cpu_port);\n\t__sync_cache_range_w(ports, sizeof(*ports) * nb_cci_ports);\n\tpr_info(\"ARM CCI driver probed\\n\");\n\n\treturn 0;\n}\n#else  \nstatic inline int cci_probe_ports(struct device_node *np)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int cci_probe(void)\n{\n\tint ret;\n\tstruct device_node *np;\n\tstruct resource res;\n\n\tnp = of_find_matching_node(NULL, arm_cci_matches);\n\tif (!of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\tret = of_address_to_resource(np, 0, &res);\n\tif (!ret) {\n\t\tcci_ctrl_base = ioremap(res.start, resource_size(&res));\n\t\tcci_ctrl_phys =\tres.start;\n\t}\n\tif (ret || !cci_ctrl_base) {\n\t\tWARN(1, \"unable to ioremap CCI ctrl\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn cci_probe_ports(np);\n}\n\nstatic int cci_init_status = -EAGAIN;\nstatic DEFINE_MUTEX(cci_probing);\n\nstatic int cci_init(void)\n{\n\tif (cci_init_status != -EAGAIN)\n\t\treturn cci_init_status;\n\n\tmutex_lock(&cci_probing);\n\tif (cci_init_status == -EAGAIN)\n\t\tcci_init_status = cci_probe();\n\tmutex_unlock(&cci_probing);\n\treturn cci_init_status;\n}\n\n \nbool cci_probed(void)\n{\n\treturn cci_init() == 0;\n}\nEXPORT_SYMBOL_GPL(cci_probed);\n\nearly_initcall(cci_init);\ncore_initcall(cci_platform_init);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ARM CCI support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}