{
  "module_name": "imx-weim.c",
  "hash_id": "87045b1113c59a983572663a5e6642b7c5756b16d109d37868036b8f11013dd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/imx-weim.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/regmap.h>\n\nstruct imx_weim_devtype {\n\tunsigned int\tcs_count;\n\tunsigned int\tcs_regs_count;\n\tunsigned int\tcs_stride;\n\tunsigned int\twcr_offset;\n\tunsigned int\twcr_bcm;\n\tunsigned int\twcr_cont_bclk;\n};\n\nstatic const struct imx_weim_devtype imx1_weim_devtype = {\n\t.cs_count\t= 6,\n\t.cs_regs_count\t= 2,\n\t.cs_stride\t= 0x08,\n};\n\nstatic const struct imx_weim_devtype imx27_weim_devtype = {\n\t.cs_count\t= 6,\n\t.cs_regs_count\t= 3,\n\t.cs_stride\t= 0x10,\n};\n\nstatic const struct imx_weim_devtype imx50_weim_devtype = {\n\t.cs_count\t= 4,\n\t.cs_regs_count\t= 6,\n\t.cs_stride\t= 0x18,\n\t.wcr_offset\t= 0x90,\n\t.wcr_bcm\t= BIT(0),\n\t.wcr_cont_bclk\t= BIT(3),\n};\n\nstatic const struct imx_weim_devtype imx51_weim_devtype = {\n\t.cs_count\t= 6,\n\t.cs_regs_count\t= 6,\n\t.cs_stride\t= 0x18,\n};\n\n#define MAX_CS_REGS_COUNT\t6\n#define MAX_CS_COUNT\t\t6\n#define OF_REG_SIZE\t\t3\n\nstruct cs_timing {\n\tbool is_applied;\n\tu32 regs[MAX_CS_REGS_COUNT];\n};\n\nstruct cs_timing_state {\n\tstruct cs_timing cs[MAX_CS_COUNT];\n};\n\nstruct weim_priv {\n\tvoid __iomem *base;\n\tstruct cs_timing_state timing_state;\n};\n\nstatic const struct of_device_id weim_id_table[] = {\n\t \n\t{ .compatible = \"fsl,imx1-weim\", .data = &imx1_weim_devtype, },\n\t \n\t{ .compatible = \"fsl,imx27-weim\", .data = &imx27_weim_devtype, },\n\t \n\t{ .compatible = \"fsl,imx50-weim\", .data = &imx50_weim_devtype, },\n\t{ .compatible = \"fsl,imx6q-weim\", .data = &imx50_weim_devtype, },\n\t \n\t{ .compatible = \"fsl,imx51-weim\", .data = &imx51_weim_devtype, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, weim_id_table);\n\nstatic int imx_weim_gpr_setup(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\tstruct regmap *gpr;\n\tu32 gprvals[4] = {\n\t\t05,\t \n\t\t033,\t \n\t\t0113,\t \n\t\t01111,\t \n\t};\n\tu32 gprval = 0;\n\tu32 val;\n\tint cs = 0;\n\tint i = 0;\n\n\tgpr = syscon_regmap_lookup_by_phandle(np, \"fsl,weim-cs-gpr\");\n\tif (IS_ERR(gpr)) {\n\t\tdev_dbg(&pdev->dev, \"failed to find weim-cs-gpr\\n\");\n\t\treturn 0;\n\t}\n\n\tif (of_range_parser_init(&parser, np))\n\t\tgoto err;\n\n\tfor_each_of_range(&parser, &range) {\n\t\tcs = range.bus_addr >> 32;\n\t\tval = (range.size / SZ_32M) | 1;\n\t\tgprval |= val << cs * 3;\n\t\ti++;\n\t}\n\n\tif (i == 0 || i % 4)\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(gprvals); i++) {\n\t\tif (gprval == gprvals[i]) {\n\t\t\t \n\t\t\tregmap_update_bits(gpr, IOMUXC_GPR1, 0xfff, gprval);\n\t\t\treturn 0;\n\t\t}\n\t}\n\nerr:\n\tdev_err(&pdev->dev, \"Invalid 'ranges' configuration\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int weim_timing_setup(struct device *dev, struct device_node *np,\n\t\t\t     const struct imx_weim_devtype *devtype)\n{\n\tu32 cs_idx, value[MAX_CS_REGS_COUNT];\n\tint i, ret;\n\tint reg_idx, num_regs;\n\tstruct cs_timing *cst;\n\tstruct weim_priv *priv;\n\tstruct cs_timing_state *ts;\n\tvoid __iomem *base;\n\n\tif (WARN_ON(devtype->cs_regs_count > MAX_CS_REGS_COUNT))\n\t\treturn -EINVAL;\n\tif (WARN_ON(devtype->cs_count > MAX_CS_COUNT))\n\t\treturn -EINVAL;\n\n\tpriv = dev_get_drvdata(dev);\n\tbase = priv->base;\n\tts = &priv->timing_state;\n\n\tret = of_property_read_u32_array(np, \"fsl,weim-cs-timing\",\n\t\t\t\t\t value, devtype->cs_regs_count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnum_regs = of_property_count_elems_of_size(np, \"reg\", OF_REG_SIZE);\n\tif (num_regs < 0)\n\t\treturn num_regs;\n\tif (!num_regs)\n\t\treturn -EINVAL;\n\tfor (reg_idx = 0; reg_idx < num_regs; reg_idx++) {\n\t\t \n\t\tret = of_property_read_u32_index(np, \"reg\",\n\t\t\t\t\treg_idx * OF_REG_SIZE, &cs_idx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (cs_idx >= devtype->cs_count)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tcst = &ts->cs[cs_idx];\n\t\tif (cst->is_applied && memcmp(value, cst->regs,\n\t\t\t\t\tdevtype->cs_regs_count * sizeof(u32))) {\n\t\t\tdev_err(dev, \"fsl,weim-cs-timing conflict on %pOF\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < devtype->cs_regs_count; i++)\n\t\t\twritel(value[i],\n\t\t\t\tbase + cs_idx * devtype->cs_stride + i * 4);\n\t\tif (!cst->is_applied) {\n\t\t\tcst->is_applied = true;\n\t\t\tmemcpy(cst->regs, value,\n\t\t\t\tdevtype->cs_regs_count * sizeof(u32));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int weim_parse_dt(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id = of_match_device(weim_id_table,\n\t\t\t\t\t\t\t   &pdev->dev);\n\tconst struct imx_weim_devtype *devtype = of_id->data;\n\tint ret = 0, have_child = 0;\n\tstruct device_node *child;\n\tstruct weim_priv *priv;\n\tvoid __iomem *base;\n\tu32 reg;\n\n\tif (devtype == &imx50_weim_devtype) {\n\t\tret = imx_weim_gpr_setup(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv = dev_get_drvdata(&pdev->dev);\n\tbase = priv->base;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"fsl,burst-clk-enable\")) {\n\t\tif (devtype->wcr_bcm) {\n\t\t\treg = readl(base + devtype->wcr_offset);\n\t\t\treg |= devtype->wcr_bcm;\n\n\t\t\tif (of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t\"fsl,continuous-burst-clk\")) {\n\t\t\t\tif (devtype->wcr_cont_bclk) {\n\t\t\t\t\treg |= devtype->wcr_cont_bclk;\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\t\"continuous burst clk not supported.\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twritel(reg, base + devtype->wcr_offset);\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"burst clk mode not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, child) {\n\t\tret = weim_timing_setup(&pdev->dev, child, devtype);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"%pOF set timing failed.\\n\",\n\t\t\t\tchild);\n\t\telse\n\t\t\thave_child = 1;\n\t}\n\n\tif (have_child)\n\t\tret = of_platform_default_populate(pdev->dev.of_node,\n\t\t\t\t\t\t   NULL, &pdev->dev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"%pOF fail to create devices.\\n\",\n\t\t\tpdev->dev.of_node);\n\treturn ret;\n}\n\nstatic int weim_probe(struct platform_device *pdev)\n{\n\tstruct weim_priv *priv;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->base = base;\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\t \n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = weim_parse_dt(pdev);\n\tif (ret)\n\t\tclk_disable_unprepare(clk);\n\telse\n\t\tdev_info(&pdev->dev, \"Driver registered.\\n\");\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_OF_DYNAMIC)\nstatic int of_weim_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t  void *arg)\n{\n\tconst struct imx_weim_devtype *devtype;\n\tstruct of_reconfig_data *rd = arg;\n\tconst struct of_device_id *of_id;\n\tstruct platform_device *pdev;\n\tint ret = NOTIFY_OK;\n\n\tswitch (of_reconfig_get_state_change(action, rd)) {\n\tcase OF_RECONFIG_CHANGE_ADD:\n\t\tof_id = of_match_node(weim_id_table, rd->dn->parent);\n\t\tif (!of_id)\n\t\t\treturn NOTIFY_OK;  \n\n\t\tdevtype = of_id->data;\n\n\t\tpdev = of_find_device_by_node(rd->dn->parent);\n\t\tif (!pdev) {\n\t\t\tpr_err(\"%s: could not find platform device for '%pOF'\\n\",\n\t\t\t\t__func__, rd->dn->parent);\n\n\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t}\n\n\t\tif (weim_timing_setup(&pdev->dev, rd->dn, devtype))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Failed to setup timing for '%pOF'\\n\", rd->dn);\n\n\t\tif (!of_node_check_flag(rd->dn, OF_POPULATED)) {\n\t\t\t \n\t\t\trd->dn->fwnode.flags &= ~FWNODE_FLAG_NOT_DEVICE;\n\t\t\tif (!of_platform_device_create(rd->dn, NULL, &pdev->dev)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Failed to create child device '%pOF'\\n\",\n\t\t\t\t\trd->dn);\n\t\t\t\tret = notifier_from_errno(-EINVAL);\n\t\t\t}\n\t\t}\n\n\t\tplatform_device_put(pdev);\n\n\t\tbreak;\n\tcase OF_RECONFIG_CHANGE_REMOVE:\n\t\tif (!of_node_check_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;  \n\n\t\tof_id = of_match_node(weim_id_table, rd->dn->parent);\n\t\tif (!of_id)\n\t\t\treturn NOTIFY_OK;  \n\n\t\tpdev = of_find_device_by_node(rd->dn);\n\t\tif (!pdev) {\n\t\t\tpr_err(\"Could not find platform device for '%pOF'\\n\",\n\t\t\t\trd->dn);\n\n\t\t\tret = notifier_from_errno(-EINVAL);\n\t\t} else {\n\t\t\tof_platform_device_destroy(&pdev->dev, NULL);\n\t\t\tplatform_device_put(pdev);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct notifier_block weim_of_notifier = {\n\t.notifier_call = of_weim_notify,\n};\n#endif  \n\nstatic struct platform_driver weim_driver = {\n\t.driver = {\n\t\t.name\t\t= \"imx-weim\",\n\t\t.of_match_table\t= weim_id_table,\n\t},\n\t.probe = weim_probe,\n};\n\nstatic int __init weim_init(void)\n{\n#if IS_ENABLED(CONFIG_OF_DYNAMIC)\n\tWARN_ON(of_reconfig_notifier_register(&weim_of_notifier));\n#endif  \n\n\treturn platform_driver_register(&weim_driver);\n}\nmodule_init(weim_init);\n\nstatic void __exit weim_exit(void)\n{\n#if IS_ENABLED(CONFIG_OF_DYNAMIC)\n\tof_reconfig_notifier_unregister(&weim_of_notifier);\n#endif  \n\n\treturn platform_driver_unregister(&weim_driver);\n\n}\nmodule_exit(weim_exit);\n\nMODULE_AUTHOR(\"Freescale Semiconductor Inc.\");\nMODULE_DESCRIPTION(\"i.MX EIM Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}