{
  "module_name": "bt1-axi.c",
  "hash_id": "7facb2859d561100507acf8b2513b8656273b8a4432b02f124d7ae7a8a351654",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/bt1-axi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/atomic.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/nmi.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/sysfs.h>\n\n#define BT1_AXI_WERRL\t\t\t0x110\n#define BT1_AXI_WERRH\t\t\t0x114\n#define BT1_AXI_WERRH_TYPE\t\tBIT(23)\n#define BT1_AXI_WERRH_ADDR_FLD\t\t24\n#define BT1_AXI_WERRH_ADDR_MASK\t\tGENMASK(31, BT1_AXI_WERRH_ADDR_FLD)\n\n \nstruct bt1_axi {\n\tstruct device *dev;\n\n\tvoid __iomem *qos_regs;\n\tstruct regmap *sys_regs;\n\tint irq;\n\n\tstruct clk *aclk;\n\n\tstruct reset_control *arst;\n\n\tatomic_t count;\n};\n\nstatic irqreturn_t bt1_axi_isr(int irq, void *data)\n{\n\tstruct bt1_axi *axi = data;\n\tu32 low = 0, high = 0;\n\n\tregmap_read(axi->sys_regs, BT1_AXI_WERRL, &low);\n\tregmap_read(axi->sys_regs, BT1_AXI_WERRH, &high);\n\n\tdev_crit_ratelimited(axi->dev,\n\t\t\"AXI-bus fault %d: %s at 0x%x%08x\\n\",\n\t\tatomic_inc_return(&axi->count),\n\t\thigh & BT1_AXI_WERRH_TYPE ? \"no slave\" : \"slave protocol error\",\n\t\thigh, low);\n\n\t \n\ttrigger_all_cpu_backtrace();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bt1_axi_clear_data(void *data)\n{\n\tstruct bt1_axi *axi = data;\n\tstruct platform_device *pdev = to_platform_device(axi->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic struct bt1_axi *bt1_axi_create_data(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bt1_axi *axi;\n\tint ret;\n\n\taxi = devm_kzalloc(dev, sizeof(*axi), GFP_KERNEL);\n\tif (!axi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = devm_add_action(dev, bt1_axi_clear_data, axi);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't add AXI EHB data clear action\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\taxi->dev = dev;\n\tatomic_set(&axi->count, 0);\n\tplatform_set_drvdata(pdev, axi);\n\n\treturn axi;\n}\n\nstatic int bt1_axi_request_regs(struct bt1_axi *axi)\n{\n\tstruct platform_device *pdev = to_platform_device(axi->dev);\n\tstruct device *dev = axi->dev;\n\n\taxi->sys_regs = syscon_regmap_lookup_by_phandle(dev->of_node, \"syscon\");\n\tif (IS_ERR(axi->sys_regs)) {\n\t\tdev_err(dev, \"Couldn't find syscon registers\\n\");\n\t\treturn PTR_ERR(axi->sys_regs);\n\t}\n\n\taxi->qos_regs = devm_platform_ioremap_resource_byname(pdev, \"qos\");\n\tif (IS_ERR(axi->qos_regs))\n\t\tdev_err(dev, \"Couldn't map AXI-bus QoS registers\\n\");\n\n\treturn PTR_ERR_OR_ZERO(axi->qos_regs);\n}\n\nstatic int bt1_axi_request_rst(struct bt1_axi *axi)\n{\n\tint ret;\n\n\taxi->arst = devm_reset_control_get_optional_exclusive(axi->dev, \"arst\");\n\tif (IS_ERR(axi->arst))\n\t\treturn dev_err_probe(axi->dev, PTR_ERR(axi->arst),\n\t\t\t\t     \"Couldn't get reset control line\\n\");\n\n\tret = reset_control_deassert(axi->arst);\n\tif (ret)\n\t\tdev_err(axi->dev, \"Failed to deassert the reset line\\n\");\n\n\treturn ret;\n}\n\nstatic void bt1_axi_disable_clk(void *data)\n{\n\tstruct bt1_axi *axi = data;\n\n\tclk_disable_unprepare(axi->aclk);\n}\n\nstatic int bt1_axi_request_clk(struct bt1_axi *axi)\n{\n\tint ret;\n\n\taxi->aclk = devm_clk_get(axi->dev, \"aclk\");\n\tif (IS_ERR(axi->aclk))\n\t\treturn dev_err_probe(axi->dev, PTR_ERR(axi->aclk),\n\t\t\t\t     \"Couldn't get AXI Interconnect clock\\n\");\n\n\tret = clk_prepare_enable(axi->aclk);\n\tif (ret) {\n\t\tdev_err(axi->dev, \"Couldn't enable the AXI clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(axi->dev, bt1_axi_disable_clk, axi);\n\tif (ret)\n\t\tdev_err(axi->dev, \"Can't add AXI clock disable action\\n\");\n\n\treturn ret;\n}\n\nstatic int bt1_axi_request_irq(struct bt1_axi *axi)\n{\n\tstruct platform_device *pdev = to_platform_device(axi->dev);\n\tint ret;\n\n\taxi->irq = platform_get_irq(pdev, 0);\n\tif (axi->irq < 0)\n\t\treturn axi->irq;\n\n\tret = devm_request_irq(axi->dev, axi->irq, bt1_axi_isr, IRQF_SHARED,\n\t\t\t       \"bt1-axi\", axi);\n\tif (ret)\n\t\tdev_err(axi->dev, \"Couldn't request AXI EHB IRQ\\n\");\n\n\treturn ret;\n}\n\nstatic ssize_t count_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct bt1_axi *axi = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&axi->count));\n}\nstatic DEVICE_ATTR_RO(count);\n\nstatic ssize_t inject_error_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"Error injection: bus unaligned\\n\");\n}\n\nstatic ssize_t inject_error_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *data, size_t count)\n{\n\tstruct bt1_axi *axi = dev_get_drvdata(dev);\n\n\t \n\tif (sysfs_streq(data, \"bus\"))\n\t\treadb(axi->qos_regs);\n\telse if (sysfs_streq(data, \"unaligned\"))\n\t\twriteb(0, axi->qos_regs);\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(inject_error);\n\nstatic struct attribute *bt1_axi_sysfs_attrs[] = {\n\t&dev_attr_count.attr,\n\t&dev_attr_inject_error.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(bt1_axi_sysfs);\n\nstatic void bt1_axi_remove_sysfs(void *data)\n{\n\tstruct bt1_axi *axi = data;\n\n\tdevice_remove_groups(axi->dev, bt1_axi_sysfs_groups);\n}\n\nstatic int bt1_axi_init_sysfs(struct bt1_axi *axi)\n{\n\tint ret;\n\n\tret = device_add_groups(axi->dev, bt1_axi_sysfs_groups);\n\tif (ret) {\n\t\tdev_err(axi->dev, \"Failed to add sysfs files group\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(axi->dev, bt1_axi_remove_sysfs, axi);\n\tif (ret)\n\t\tdev_err(axi->dev, \"Can't add AXI EHB sysfs remove action\\n\");\n\n\treturn ret;\n}\n\nstatic int bt1_axi_probe(struct platform_device *pdev)\n{\n\tstruct bt1_axi *axi;\n\tint ret;\n\n\taxi = bt1_axi_create_data(pdev);\n\tif (IS_ERR(axi))\n\t\treturn PTR_ERR(axi);\n\n\tret = bt1_axi_request_regs(axi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_axi_request_rst(axi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_axi_request_clk(axi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_axi_request_irq(axi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bt1_axi_init_sysfs(axi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bt1_axi_of_match[] = {\n\t{ .compatible = \"baikal,bt1-axi\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bt1_axi_of_match);\n\nstatic struct platform_driver bt1_axi_driver = {\n\t.probe = bt1_axi_probe,\n\t.driver = {\n\t\t.name = \"bt1-axi\",\n\t\t.of_match_table = bt1_axi_of_match\n\t}\n};\nmodule_platform_driver(bt1_axi_driver);\n\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 AXI-bus driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}