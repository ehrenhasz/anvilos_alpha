{
  "module_name": "brcmstb_gisb.c",
  "hash_id": "340ec2a27d8d08152d6cadcb46c452f5e353e113d29546c95948534a71d451d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/brcmstb_gisb.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/panic_notifier.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/sysfs.h>\n#include <linux/io.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/bitops.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/notifier.h>\n\n#ifdef CONFIG_MIPS\n#include <asm/traps.h>\n#endif\n\n#define  ARB_ERR_CAP_CLEAR\t\t(1 << 0)\n#define  ARB_ERR_CAP_STATUS_TIMEOUT\t(1 << 12)\n#define  ARB_ERR_CAP_STATUS_TEA\t\t(1 << 11)\n#define  ARB_ERR_CAP_STATUS_WRITE\t(1 << 1)\n#define  ARB_ERR_CAP_STATUS_VALID\t(1 << 0)\n\n#define  ARB_BP_CAP_CLEAR\t\t(1 << 0)\n#define  ARB_BP_CAP_STATUS_PROT_SHIFT\t14\n#define  ARB_BP_CAP_STATUS_TYPE\t\t(1 << 13)\n#define  ARB_BP_CAP_STATUS_RSP_SHIFT\t10\n#define  ARB_BP_CAP_STATUS_MASK\t\tGENMASK(1, 0)\n#define  ARB_BP_CAP_STATUS_BS_SHIFT\t2\n#define  ARB_BP_CAP_STATUS_WRITE\t(1 << 1)\n#define  ARB_BP_CAP_STATUS_VALID\t(1 << 0)\n\nenum {\n\tARB_TIMER,\n\tARB_BP_CAP_CLR,\n\tARB_BP_CAP_HI_ADDR,\n\tARB_BP_CAP_ADDR,\n\tARB_BP_CAP_STATUS,\n\tARB_BP_CAP_MASTER,\n\tARB_ERR_CAP_CLR,\n\tARB_ERR_CAP_HI_ADDR,\n\tARB_ERR_CAP_ADDR,\n\tARB_ERR_CAP_STATUS,\n\tARB_ERR_CAP_MASTER,\n};\n\nstatic const int gisb_offsets_bcm7038[] = {\n\t[ARB_TIMER]\t\t= 0x00c,\n\t[ARB_BP_CAP_CLR]\t= 0x014,\n\t[ARB_BP_CAP_HI_ADDR]\t= -1,\n\t[ARB_BP_CAP_ADDR]\t= 0x0b8,\n\t[ARB_BP_CAP_STATUS]\t= 0x0c0,\n\t[ARB_BP_CAP_MASTER]\t= -1,\n\t[ARB_ERR_CAP_CLR]\t= 0x0c4,\n\t[ARB_ERR_CAP_HI_ADDR]\t= -1,\n\t[ARB_ERR_CAP_ADDR]\t= 0x0c8,\n\t[ARB_ERR_CAP_STATUS]\t= 0x0d0,\n\t[ARB_ERR_CAP_MASTER]\t= -1,\n};\n\nstatic const int gisb_offsets_bcm7278[] = {\n\t[ARB_TIMER]\t\t= 0x008,\n\t[ARB_BP_CAP_CLR]\t= 0x01c,\n\t[ARB_BP_CAP_HI_ADDR]\t= -1,\n\t[ARB_BP_CAP_ADDR]\t= 0x220,\n\t[ARB_BP_CAP_STATUS]\t= 0x230,\n\t[ARB_BP_CAP_MASTER]\t= 0x234,\n\t[ARB_ERR_CAP_CLR]\t= 0x7f8,\n\t[ARB_ERR_CAP_HI_ADDR]\t= -1,\n\t[ARB_ERR_CAP_ADDR]\t= 0x7e0,\n\t[ARB_ERR_CAP_STATUS]\t= 0x7f0,\n\t[ARB_ERR_CAP_MASTER]\t= 0x7f4,\n};\n\nstatic const int gisb_offsets_bcm7400[] = {\n\t[ARB_TIMER]\t\t= 0x00c,\n\t[ARB_BP_CAP_CLR]\t= 0x014,\n\t[ARB_BP_CAP_HI_ADDR]\t= -1,\n\t[ARB_BP_CAP_ADDR]\t= 0x0b8,\n\t[ARB_BP_CAP_STATUS]\t= 0x0c0,\n\t[ARB_BP_CAP_MASTER]\t= 0x0c4,\n\t[ARB_ERR_CAP_CLR]\t= 0x0c8,\n\t[ARB_ERR_CAP_HI_ADDR]\t= -1,\n\t[ARB_ERR_CAP_ADDR]\t= 0x0cc,\n\t[ARB_ERR_CAP_STATUS]\t= 0x0d4,\n\t[ARB_ERR_CAP_MASTER]\t= 0x0d8,\n};\n\nstatic const int gisb_offsets_bcm7435[] = {\n\t[ARB_TIMER]\t\t= 0x00c,\n\t[ARB_BP_CAP_CLR]\t= 0x014,\n\t[ARB_BP_CAP_HI_ADDR]\t= -1,\n\t[ARB_BP_CAP_ADDR]\t= 0x158,\n\t[ARB_BP_CAP_STATUS]\t= 0x160,\n\t[ARB_BP_CAP_MASTER]\t= 0x164,\n\t[ARB_ERR_CAP_CLR]\t= 0x168,\n\t[ARB_ERR_CAP_HI_ADDR]\t= -1,\n\t[ARB_ERR_CAP_ADDR]\t= 0x16c,\n\t[ARB_ERR_CAP_STATUS]\t= 0x174,\n\t[ARB_ERR_CAP_MASTER]\t= 0x178,\n};\n\nstatic const int gisb_offsets_bcm7445[] = {\n\t[ARB_TIMER]\t\t= 0x008,\n\t[ARB_BP_CAP_CLR]\t= 0x010,\n\t[ARB_BP_CAP_HI_ADDR]\t= -1,\n\t[ARB_BP_CAP_ADDR]\t= 0x1d8,\n\t[ARB_BP_CAP_STATUS]\t= 0x1e0,\n\t[ARB_BP_CAP_MASTER]\t= 0x1e4,\n\t[ARB_ERR_CAP_CLR]\t= 0x7e4,\n\t[ARB_ERR_CAP_HI_ADDR]\t= 0x7e8,\n\t[ARB_ERR_CAP_ADDR]\t= 0x7ec,\n\t[ARB_ERR_CAP_STATUS]\t= 0x7f4,\n\t[ARB_ERR_CAP_MASTER]\t= 0x7f8,\n};\n\nstruct brcmstb_gisb_arb_device {\n\tvoid __iomem\t*base;\n\tconst int\t*gisb_offsets;\n\tbool\t\tbig_endian;\n\tstruct mutex\tlock;\n\tstruct list_head next;\n\tu32 valid_mask;\n\tconst char *master_names[sizeof(u32) * BITS_PER_BYTE];\n\tu32 saved_timeout;\n};\n\nstatic LIST_HEAD(brcmstb_gisb_arb_device_list);\n\nstatic u32 gisb_read(struct brcmstb_gisb_arb_device *gdev, int reg)\n{\n\tint offset = gdev->gisb_offsets[reg];\n\n\tif (offset < 0) {\n\t\t \n\t\tif (reg == ARB_ERR_CAP_MASTER)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (gdev->big_endian)\n\t\treturn ioread32be(gdev->base + offset);\n\telse\n\t\treturn ioread32(gdev->base + offset);\n}\n\nstatic u64 gisb_read_address(struct brcmstb_gisb_arb_device *gdev)\n{\n\tu64 value;\n\n\tvalue = gisb_read(gdev, ARB_ERR_CAP_ADDR);\n\tvalue |= (u64)gisb_read(gdev, ARB_ERR_CAP_HI_ADDR) << 32;\n\n\treturn value;\n}\n\nstatic u64 gisb_read_bp_address(struct brcmstb_gisb_arb_device *gdev)\n{\n\tu64 value;\n\n\tvalue = gisb_read(gdev, ARB_BP_CAP_ADDR);\n\tvalue |= (u64)gisb_read(gdev, ARB_BP_CAP_HI_ADDR) << 32;\n\n\treturn value;\n}\n\nstatic void gisb_write(struct brcmstb_gisb_arb_device *gdev, u32 val, int reg)\n{\n\tint offset = gdev->gisb_offsets[reg];\n\n\tif (offset == -1)\n\t\treturn;\n\n\tif (gdev->big_endian)\n\t\tiowrite32be(val, gdev->base + offset);\n\telse\n\t\tiowrite32(val, gdev->base + offset);\n}\n\nstatic ssize_t gisb_arb_get_timeout(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct brcmstb_gisb_arb_device *gdev = dev_get_drvdata(dev);\n\tu32 timeout;\n\n\tmutex_lock(&gdev->lock);\n\ttimeout = gisb_read(gdev, ARB_TIMER);\n\tmutex_unlock(&gdev->lock);\n\n\treturn sprintf(buf, \"%d\", timeout);\n}\n\nstatic ssize_t gisb_arb_set_timeout(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct brcmstb_gisb_arb_device *gdev = dev_get_drvdata(dev);\n\tint val, ret;\n\n\tret = kstrtoint(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val == 0 || val >= 0xffffffff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&gdev->lock);\n\tgisb_write(gdev, val, ARB_TIMER);\n\tmutex_unlock(&gdev->lock);\n\n\treturn count;\n}\n\nstatic const char *\nbrcmstb_gisb_master_to_str(struct brcmstb_gisb_arb_device *gdev,\n\t\t\t\t\t\tu32 masters)\n{\n\tu32 mask = gdev->valid_mask & masters;\n\n\tif (hweight_long(mask) != 1)\n\t\treturn NULL;\n\n\treturn gdev->master_names[ffs(mask) - 1];\n}\n\nstatic int brcmstb_gisb_arb_decode_addr(struct brcmstb_gisb_arb_device *gdev,\n\t\t\t\t\tconst char *reason)\n{\n\tu32 cap_status;\n\tu64 arb_addr;\n\tu32 master;\n\tconst char *m_name;\n\tchar m_fmt[11];\n\n\tcap_status = gisb_read(gdev, ARB_ERR_CAP_STATUS);\n\n\t \n\tif (!(cap_status & ARB_ERR_CAP_STATUS_VALID))\n\t\treturn 1;\n\n\t \n\tarb_addr = gisb_read_address(gdev);\n\tmaster = gisb_read(gdev, ARB_ERR_CAP_MASTER);\n\n\tm_name = brcmstb_gisb_master_to_str(gdev, master);\n\tif (!m_name) {\n\t\tsnprintf(m_fmt, sizeof(m_fmt), \"0x%08x\", master);\n\t\tm_name = m_fmt;\n\t}\n\n\tpr_crit(\"GISB: %s at 0x%llx [%c %s], core: %s\\n\",\n\t\treason, arb_addr,\n\t\tcap_status & ARB_ERR_CAP_STATUS_WRITE ? 'W' : 'R',\n\t\tcap_status & ARB_ERR_CAP_STATUS_TIMEOUT ? \"timeout\" : \"\",\n\t\tm_name);\n\n\t \n\tgisb_write(gdev, ARB_ERR_CAP_CLEAR, ARB_ERR_CAP_CLR);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_MIPS\nstatic int brcmstb_bus_error_handler(struct pt_regs *regs, int is_fixup)\n{\n\tint ret = 0;\n\tstruct brcmstb_gisb_arb_device *gdev;\n\tu32 cap_status;\n\n\tlist_for_each_entry(gdev, &brcmstb_gisb_arb_device_list, next) {\n\t\tcap_status = gisb_read(gdev, ARB_ERR_CAP_STATUS);\n\n\t\t \n\t\tif (!(cap_status & ARB_ERR_CAP_STATUS_VALID)) {\n\t\t\tis_fixup = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret |= brcmstb_gisb_arb_decode_addr(gdev, \"bus error\");\n\t}\nout:\n\treturn is_fixup ? MIPS_BE_FIXUP : MIPS_BE_FATAL;\n}\n#endif\n\nstatic irqreturn_t brcmstb_gisb_timeout_handler(int irq, void *dev_id)\n{\n\tbrcmstb_gisb_arb_decode_addr(dev_id, \"timeout\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t brcmstb_gisb_tea_handler(int irq, void *dev_id)\n{\n\tbrcmstb_gisb_arb_decode_addr(dev_id, \"target abort\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t brcmstb_gisb_bp_handler(int irq, void *dev_id)\n{\n\tstruct brcmstb_gisb_arb_device *gdev = dev_id;\n\tconst char *m_name;\n\tu32 bp_status;\n\tu64 arb_addr;\n\tu32 master;\n\tchar m_fmt[11];\n\n\tbp_status = gisb_read(gdev, ARB_BP_CAP_STATUS);\n\n\t \n\tif (!(bp_status & ARB_BP_CAP_STATUS_VALID))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tarb_addr = gisb_read_bp_address(gdev);\n\tmaster = gisb_read(gdev, ARB_BP_CAP_MASTER);\n\n\tm_name = brcmstb_gisb_master_to_str(gdev, master);\n\tif (!m_name) {\n\t\tsnprintf(m_fmt, sizeof(m_fmt), \"0x%08x\", master);\n\t\tm_name = m_fmt;\n\t}\n\n\tpr_crit(\"GISB: breakpoint at 0x%llx [%c], core: %s\\n\",\n\t\tarb_addr, bp_status & ARB_BP_CAP_STATUS_WRITE ? 'W' : 'R',\n\t\tm_name);\n\n\t \n\tgisb_write(gdev, ARB_ERR_CAP_CLEAR, ARB_ERR_CAP_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int dump_gisb_error(struct notifier_block *self, unsigned long v,\n\t\t\t   void *p);\n\nstatic struct notifier_block gisb_die_notifier = {\n\t.notifier_call = dump_gisb_error,\n};\n\nstatic struct notifier_block gisb_panic_notifier = {\n\t.notifier_call = dump_gisb_error,\n};\n\nstatic int dump_gisb_error(struct notifier_block *self, unsigned long v,\n\t\t\t   void *p)\n{\n\tstruct brcmstb_gisb_arb_device *gdev;\n\tconst char *reason = \"panic\";\n\n\tif (self == &gisb_die_notifier)\n\t\treason = \"die\";\n\n\t \n\tlist_for_each_entry(gdev, &brcmstb_gisb_arb_device_list, next)\n\t\tbrcmstb_gisb_arb_decode_addr(gdev, reason);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic DEVICE_ATTR(gisb_arb_timeout, S_IWUSR | S_IRUGO,\n\t\tgisb_arb_get_timeout, gisb_arb_set_timeout);\n\nstatic struct attribute *gisb_arb_sysfs_attrs[] = {\n\t&dev_attr_gisb_arb_timeout.attr,\n\tNULL,\n};\n\nstatic struct attribute_group gisb_arb_sysfs_attr_group = {\n\t.attrs = gisb_arb_sysfs_attrs,\n};\n\nstatic const struct of_device_id brcmstb_gisb_arb_of_match[] = {\n\t{ .compatible = \"brcm,gisb-arb\",         .data = gisb_offsets_bcm7445 },\n\t{ .compatible = \"brcm,bcm7445-gisb-arb\", .data = gisb_offsets_bcm7445 },\n\t{ .compatible = \"brcm,bcm7435-gisb-arb\", .data = gisb_offsets_bcm7435 },\n\t{ .compatible = \"brcm,bcm7400-gisb-arb\", .data = gisb_offsets_bcm7400 },\n\t{ .compatible = \"brcm,bcm7278-gisb-arb\", .data = gisb_offsets_bcm7278 },\n\t{ .compatible = \"brcm,bcm7038-gisb-arb\", .data = gisb_offsets_bcm7038 },\n\t{ },\n};\n\nstatic int __init brcmstb_gisb_arb_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct brcmstb_gisb_arb_device *gdev;\n\tconst struct of_device_id *of_id;\n\tint err, timeout_irq, tea_irq, bp_irq;\n\tunsigned int num_masters, j = 0;\n\tint i, first, last;\n\n\ttimeout_irq = platform_get_irq(pdev, 0);\n\ttea_irq = platform_get_irq(pdev, 1);\n\tbp_irq = platform_get_irq(pdev, 2);\n\n\tgdev = devm_kzalloc(&pdev->dev, sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&gdev->lock);\n\tINIT_LIST_HEAD(&gdev->next);\n\n\tgdev->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(gdev->base))\n\t\treturn PTR_ERR(gdev->base);\n\n\tof_id = of_match_node(brcmstb_gisb_arb_of_match, dn);\n\tif (!of_id) {\n\t\tpr_err(\"failed to look up compatible string\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgdev->gisb_offsets = of_id->data;\n\tgdev->big_endian = of_device_is_big_endian(dn);\n\n\terr = devm_request_irq(&pdev->dev, timeout_irq,\n\t\t\t\tbrcmstb_gisb_timeout_handler, 0, pdev->name,\n\t\t\t\tgdev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_irq(&pdev->dev, tea_irq,\n\t\t\t\tbrcmstb_gisb_tea_handler, 0, pdev->name,\n\t\t\t\tgdev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (bp_irq > 0) {\n\t\terr = devm_request_irq(&pdev->dev, bp_irq,\n\t\t\t\t       brcmstb_gisb_bp_handler, 0, pdev->name,\n\t\t\t\t       gdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (of_property_read_u32(dn, \"brcm,gisb-arb-master-mask\",\n\t\t\t\t&gdev->valid_mask))\n\t\tgdev->valid_mask = 0xffffffff;\n\n\t \n\tnum_masters = of_property_count_strings(dn,\n\t\t\t\"brcm,gisb-arb-master-names\");\n\tif (hweight_long(gdev->valid_mask) == num_masters) {\n\t\tfirst = ffs(gdev->valid_mask) - 1;\n\t\tlast = fls(gdev->valid_mask) - 1;\n\n\t\tfor (i = first; i < last; i++) {\n\t\t\tif (!(gdev->valid_mask & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tof_property_read_string_index(dn,\n\t\t\t\t\t\"brcm,gisb-arb-master-names\", j,\n\t\t\t\t\t&gdev->master_names[i]);\n\t\t\tj++;\n\t\t}\n\t}\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &gisb_arb_sysfs_attr_group);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, gdev);\n\n\tlist_add_tail(&gdev->next, &brcmstb_gisb_arb_device_list);\n\n#ifdef CONFIG_MIPS\n\tmips_set_be_handler(brcmstb_bus_error_handler);\n#endif\n\n\tif (list_is_singular(&brcmstb_gisb_arb_device_list)) {\n\t\tregister_die_notifier(&gisb_die_notifier);\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &gisb_panic_notifier);\n\t}\n\n\tdev_info(&pdev->dev, \"registered irqs: %d, %d\\n\",\n\t\t timeout_irq, tea_irq);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int brcmstb_gisb_arb_suspend(struct device *dev)\n{\n\tstruct brcmstb_gisb_arb_device *gdev = dev_get_drvdata(dev);\n\n\tgdev->saved_timeout = gisb_read(gdev, ARB_TIMER);\n\n\treturn 0;\n}\n\n \nstatic int brcmstb_gisb_arb_resume_noirq(struct device *dev)\n{\n\tstruct brcmstb_gisb_arb_device *gdev = dev_get_drvdata(dev);\n\n\tgisb_write(gdev, gdev->saved_timeout, ARB_TIMER);\n\n\treturn 0;\n}\n#else\n#define brcmstb_gisb_arb_suspend       NULL\n#define brcmstb_gisb_arb_resume_noirq  NULL\n#endif\n\nstatic const struct dev_pm_ops brcmstb_gisb_arb_pm_ops = {\n\t.suspend\t= brcmstb_gisb_arb_suspend,\n\t.resume_noirq\t= brcmstb_gisb_arb_resume_noirq,\n};\n\nstatic struct platform_driver brcmstb_gisb_arb_driver = {\n\t.driver = {\n\t\t.name\t= \"brcm-gisb-arb\",\n\t\t.of_match_table = brcmstb_gisb_arb_of_match,\n\t\t.pm\t= &brcmstb_gisb_arb_pm_ops,\n\t},\n};\n\nstatic int __init brcm_gisb_driver_init(void)\n{\n\treturn platform_driver_probe(&brcmstb_gisb_arb_driver,\n\t\t\t\t     brcmstb_gisb_arb_probe);\n}\n\nmodule_init(brcm_gisb_driver_init);\n\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"Broadcom STB GISB arbiter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}