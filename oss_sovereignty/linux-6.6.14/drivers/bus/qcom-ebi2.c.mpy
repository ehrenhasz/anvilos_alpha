{
  "module_name": "qcom-ebi2.c",
  "hash_id": "b22bd55b19fdc32b43d58f28fa05f43bafdad5487dba933fb39f7194bcbf0179",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/qcom-ebi2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n\n \n#define EBI2_CS0_ENABLE_MASK BIT(0)|BIT(1)\n#define EBI2_CS1_ENABLE_MASK BIT(2)|BIT(3)\n#define EBI2_CS2_ENABLE_MASK BIT(4)\n#define EBI2_CS3_ENABLE_MASK BIT(5)\n#define EBI2_CS4_ENABLE_MASK BIT(6)|BIT(7)\n#define EBI2_CS5_ENABLE_MASK BIT(8)|BIT(9)\n#define EBI2_CSN_MASK GENMASK(9, 0)\n\n#define EBI2_XMEM_CFG 0x0000  \n\n \n#define EBI2_XMEM_CS0_SLOW_CFG 0x0008\n#define EBI2_XMEM_CS1_SLOW_CFG 0x000C\n#define EBI2_XMEM_CS2_SLOW_CFG 0x0010\n#define EBI2_XMEM_CS3_SLOW_CFG 0x0014\n#define EBI2_XMEM_CS4_SLOW_CFG 0x0018\n#define EBI2_XMEM_CS5_SLOW_CFG 0x001C\n\n#define EBI2_XMEM_RECOVERY_SHIFT\t28\n#define EBI2_XMEM_WR_HOLD_SHIFT\t\t24\n#define EBI2_XMEM_WR_DELTA_SHIFT\t16\n#define EBI2_XMEM_RD_DELTA_SHIFT\t8\n#define EBI2_XMEM_WR_WAIT_SHIFT\t\t4\n#define EBI2_XMEM_RD_WAIT_SHIFT\t\t0\n\n \n#define EBI2_XMEM_CS0_FAST_CFG 0x0028\n#define EBI2_XMEM_CS1_FAST_CFG 0x002C\n#define EBI2_XMEM_CS2_FAST_CFG 0x0030\n#define EBI2_XMEM_CS3_FAST_CFG 0x0034\n#define EBI2_XMEM_CS4_FAST_CFG 0x0038\n#define EBI2_XMEM_CS5_FAST_CFG 0x003C\n\n#define EBI2_XMEM_RD_HOLD_SHIFT\t\t24\n#define EBI2_XMEM_ADV_OE_RECOVERY_SHIFT\t16\n#define EBI2_XMEM_ADDR_HOLD_ENA_SHIFT\t5\n\n \nstruct cs_data {\n\tu32 enable_mask;\n\tu16 slow_cfg;\n\tu16 fast_cfg;\n};\n\nstatic const struct cs_data cs_info[] = {\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS0_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS0_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS0_FAST_CFG,\n\t},\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS1_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS1_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS1_FAST_CFG,\n\t},\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS2_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS2_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS2_FAST_CFG,\n\t},\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS3_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS3_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS3_FAST_CFG,\n\t},\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS4_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS4_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS4_FAST_CFG,\n\t},\n\t{\n\t\t \n\t\t.enable_mask = EBI2_CS5_ENABLE_MASK,\n\t\t.slow_cfg = EBI2_XMEM_CS5_SLOW_CFG,\n\t\t.fast_cfg = EBI2_XMEM_CS5_FAST_CFG,\n\t},\n};\n\n \nstruct ebi2_xmem_prop {\n\tconst char *prop;\n\tu32 max;\n\tbool slowreg;\n\tu16 shift;\n};\n\nstatic const struct ebi2_xmem_prop xmem_props[] = {\n\t{\n\t\t.prop = \"qcom,xmem-recovery-cycles\",\n\t\t.max = 15,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_RECOVERY_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-write-hold-cycles\",\n\t\t.max = 15,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_WR_HOLD_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-write-delta-cycles\",\n\t\t.max = 255,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_WR_DELTA_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-read-delta-cycles\",\n\t\t.max = 255,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_RD_DELTA_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-write-wait-cycles\",\n\t\t.max = 15,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_WR_WAIT_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-read-wait-cycles\",\n\t\t.max = 15,\n\t\t.slowreg = true,\n\t\t.shift = EBI2_XMEM_RD_WAIT_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-address-hold-enable\",\n\t\t.max = 1,  \n\t\t.slowreg = false,\n\t\t.shift = EBI2_XMEM_ADDR_HOLD_ENA_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-adv-to-oe-recovery-cycles\",\n\t\t.max = 3,\n\t\t.slowreg = false,\n\t\t.shift = EBI2_XMEM_ADV_OE_RECOVERY_SHIFT,\n\t},\n\t{\n\t\t.prop = \"qcom,xmem-read-hold-cycles\",\n\t\t.max = 15,\n\t\t.slowreg = false,\n\t\t.shift = EBI2_XMEM_RD_HOLD_SHIFT,\n\t},\n};\n\nstatic void qcom_ebi2_setup_chipselect(struct device_node *np,\n\t\t\t\t       struct device *dev,\n\t\t\t\t       void __iomem *ebi2_base,\n\t\t\t\t       void __iomem *ebi2_xmem,\n\t\t\t\t       u32 csindex)\n{\n\tconst struct cs_data *csd;\n\tu32 slowcfg, fastcfg;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tcsd = &cs_info[csindex];\n\tval = readl(ebi2_base);\n\tval |= csd->enable_mask;\n\twritel(val, ebi2_base);\n\tdev_dbg(dev, \"enabled CS%u\\n\", csindex);\n\n\t \n\tslowcfg = 0;\n\tfastcfg = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(xmem_props); i++) {\n\t\tconst struct ebi2_xmem_prop *xp = &xmem_props[i];\n\n\t\t \n\t\tret = of_property_read_u32(np, xp->prop, &val);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"could not read %s for CS%d\\n\",\n\t\t\t\txp->prop, csindex);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (xp->max == 1 && val) {\n\t\t\tif (xp->slowreg)\n\t\t\t\tslowcfg |= BIT(xp->shift);\n\t\t\telse\n\t\t\t\tfastcfg |= BIT(xp->shift);\n\t\t\tdev_dbg(dev, \"set %s flag\\n\", xp->prop);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (val > xp->max) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"too high value for %s: %u, capped at %u\\n\",\n\t\t\t\txp->prop, val, xp->max);\n\t\t\tval = xp->max;\n\t\t}\n\t\tif (xp->slowreg)\n\t\t\tslowcfg |= (val << xp->shift);\n\t\telse\n\t\t\tfastcfg |= (val << xp->shift);\n\t\tdev_dbg(dev, \"set %s to %u\\n\", xp->prop, val);\n\t}\n\n\tdev_info(dev, \"CS%u: SLOW CFG 0x%08x, FAST CFG 0x%08x\\n\",\n\t\t csindex, slowcfg, fastcfg);\n\n\tif (slowcfg)\n\t\twritel(slowcfg, ebi2_xmem + csd->slow_cfg);\n\tif (fastcfg)\n\t\twritel(fastcfg, ebi2_xmem + csd->fast_cfg);\n}\n\nstatic int qcom_ebi2_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tvoid __iomem *ebi2_base;\n\tvoid __iomem *ebi2_xmem;\n\tstruct clk *ebi2xclk;\n\tstruct clk *ebi2clk;\n\tbool have_children = false;\n\tu32 val;\n\tint ret;\n\n\tebi2xclk = devm_clk_get(dev, \"ebi2x\");\n\tif (IS_ERR(ebi2xclk))\n\t\treturn PTR_ERR(ebi2xclk);\n\n\tret = clk_prepare_enable(ebi2xclk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable EBI2X clk (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tebi2clk = devm_clk_get(dev, \"ebi2\");\n\tif (IS_ERR(ebi2clk)) {\n\t\tret = PTR_ERR(ebi2clk);\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tret = clk_prepare_enable(ebi2clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable EBI2 clk\\n\");\n\t\tgoto err_disable_2x_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tebi2_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_base)) {\n\t\tret = PTR_ERR(ebi2_base);\n\t\tgoto err_disable_clk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tebi2_xmem = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ebi2_xmem)) {\n\t\tret = PTR_ERR(ebi2_xmem);\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\twritel(0UL, ebi2_xmem + EBI2_XMEM_CFG);\n\n\t \n\tval = readl(ebi2_base);\n\tval &= ~EBI2_CSN_MASK;\n\twritel(val, ebi2_base);\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\tu32 csindex;\n\n\t\t \n\t\tret = of_property_read_u32(child, \"reg\", &csindex);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (csindex > 5) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"invalid chipselect %u, we only support 0-5\\n\",\n\t\t\t\tcsindex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqcom_ebi2_setup_chipselect(child,\n\t\t\t\t\t   dev,\n\t\t\t\t\t   ebi2_base,\n\t\t\t\t\t   ebi2_xmem,\n\t\t\t\t\t   csindex);\n\n\t\t \n\t\thave_children = true;\n\t}\n\n\tif (have_children)\n\t\treturn of_platform_default_populate(np, NULL, dev);\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(ebi2clk);\nerr_disable_2x_clk:\n\tclk_disable_unprepare(ebi2xclk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id qcom_ebi2_of_match[] = {\n\t{ .compatible = \"qcom,msm8660-ebi2\", },\n\t{ .compatible = \"qcom,apq8060-ebi2\", },\n\t{ }\n};\n\nstatic struct platform_driver qcom_ebi2_driver = {\n\t.probe = qcom_ebi2_probe,\n\t.driver = {\n\t\t.name = \"qcom-ebi2\",\n\t\t.of_match_table = qcom_ebi2_of_match,\n\t},\n};\nmodule_platform_driver(qcom_ebi2_driver);\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm EBI2 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}