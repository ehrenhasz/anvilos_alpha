{
  "module_name": "omap_l3_noc.c",
  "hash_id": "f0c15263fd9f7d2689c2aa399aedc943a11877ca8dfb3ed7bd61a2ba4f234c74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/omap_l3_noc.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"omap_l3_noc.h\"\n\n \nstatic int l3_handle_target(struct omap_l3 *l3, void __iomem *base,\n\t\t\t    struct l3_flagmux_data *flag_mux, int err_src)\n{\n\tint k;\n\tu32 std_err_main, clear, masterid;\n\tu8 op_code, m_req_info;\n\tvoid __iomem *l3_targ_base;\n\tvoid __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;\n\tvoid __iomem *l3_targ_hdr, *l3_targ_info;\n\tstruct l3_target_data *l3_targ_inst;\n\tstruct l3_masters_data *master;\n\tchar *target_name, *master_name = \"UN IDENTIFIED\";\n\tchar *err_description;\n\tchar err_string[30] = { 0 };\n\tchar info_string[60] = { 0 };\n\n\t \n\tBUG_ON(err_src > MAX_CLKDM_TARGETS);\n\n\tif (err_src < flag_mux->num_targ_data) {\n\t\tl3_targ_inst = &flag_mux->l3_targ[err_src];\n\t\ttarget_name = l3_targ_inst->name;\n\t\tl3_targ_base = base + l3_targ_inst->offset;\n\t} else {\n\t\ttarget_name = L3_TARGET_NOT_SUPPORTED;\n\t}\n\n\tif (target_name == L3_TARGET_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\t \n\tl3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;\n\tl3_targ_slvofslsb = l3_targ_base + L3_TARG_STDERRLOG_SLVOFSLSB;\n\n\tstd_err_main = readl_relaxed(l3_targ_stderr);\n\n\tswitch (std_err_main & CUSTOM_ERROR) {\n\tcase STANDARD_ERROR:\n\t\terr_description = \"Standard\";\n\t\tsnprintf(err_string, sizeof(err_string),\n\t\t\t \": At Address: 0x%08X \",\n\t\t\t readl_relaxed(l3_targ_slvofslsb));\n\n\t\tl3_targ_mstaddr = l3_targ_base + L3_TARG_STDERRLOG_MSTADDR;\n\t\tl3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_HDR;\n\t\tl3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_INFO;\n\t\tbreak;\n\n\tcase CUSTOM_ERROR:\n\t\terr_description = \"Custom\";\n\n\t\tl3_targ_mstaddr = l3_targ_base +\n\t\t\t\t  L3_TARG_STDERRLOG_CINFO_MSTADDR;\n\t\tl3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_CINFO_OPCODE;\n\t\tl3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_CINFO_INFO;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tmasterid = (readl_relaxed(l3_targ_mstaddr) &\n\t\t    l3->mst_addr_mask) >> __ffs(l3->mst_addr_mask);\n\n\tfor (k = 0, master = l3->l3_masters; k < l3->num_masters;\n\t     k++, master++) {\n\t\tif (masterid == master->id) {\n\t\t\tmaster_name = master->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\top_code = readl_relaxed(l3_targ_hdr) & 0x7;\n\n\tm_req_info = readl_relaxed(l3_targ_info) & 0xF;\n\tsnprintf(info_string, sizeof(info_string),\n\t\t \": %s in %s mode during %s access\",\n\t\t (m_req_info & BIT(0)) ? \"Opcode Fetch\" : \"Data Access\",\n\t\t (m_req_info & BIT(1)) ? \"Supervisor\" : \"User\",\n\t\t (m_req_info & BIT(3)) ? \"Debug\" : \"Functional\");\n\n\tWARN(true,\n\t     \"%s:L3 %s Error: MASTER %s TARGET %s (%s)%s%s\\n\",\n\t     dev_name(l3->dev),\n\t     err_description,\n\t     master_name, target_name,\n\t     l3_transaction_type[op_code],\n\t     err_string, info_string);\n\n\t \n\tclear = std_err_main | CLEAR_STDERR_LOG;\n\twritel_relaxed(clear, l3_targ_stderr);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t l3_interrupt_handler(int irq, void *_l3)\n{\n\tstruct omap_l3 *l3 = _l3;\n\tint inttype, i, ret;\n\tint err_src = 0;\n\tu32 err_reg, mask_val;\n\tvoid __iomem *base, *mask_reg;\n\tstruct l3_flagmux_data *flag_mux;\n\n\t \n\tinttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\n\n\tfor (i = 0; i < l3->num_modules; i++) {\n\t\t \n\t\tbase = l3->l3_base[i];\n\t\tflag_mux = l3->l3_flagmux[i];\n\t\terr_reg = readl_relaxed(base + flag_mux->offset +\n\t\t\t\t\tL3_FLAGMUX_REGERR0 + (inttype << 3));\n\n\t\terr_reg &= ~(inttype ? flag_mux->mask_app_bits :\n\t\t\t\tflag_mux->mask_dbg_bits);\n\n\t\t \n\t\tif (err_reg) {\n\t\t\t \n\t\t\terr_src = __ffs(err_reg);\n\n\t\t\tret = l3_handle_target(l3, base, flag_mux, err_src);\n\n\t\t\t \n\t\t\tif (ret) {\n\t\t\t\tdev_err(l3->dev,\n\t\t\t\t\t\"L3 %s error: target %d mod:%d %s\\n\",\n\t\t\t\t\tinttype ? \"debug\" : \"application\",\n\t\t\t\t\terr_src, i, \"(unclearable)\");\n\n\t\t\t\tmask_reg = base + flag_mux->offset +\n\t\t\t\t\t   L3_FLAGMUX_MASK0 + (inttype << 3);\n\t\t\t\tmask_val = readl_relaxed(mask_reg);\n\t\t\t\tmask_val &= ~(1 << err_src);\n\t\t\t\twritel_relaxed(mask_val, mask_reg);\n\n\t\t\t\t \n\t\t\t\tif (inttype)\n\t\t\t\t\tflag_mux->mask_app_bits |= 1 << err_src;\n\t\t\t\telse\n\t\t\t\t\tflag_mux->mask_dbg_bits |= 1 << err_src;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\tdev_err(l3->dev, \"L3 %s IRQ not handled!!\\n\",\n\t\tinttype ? \"debug\" : \"application\");\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct of_device_id l3_noc_match[] = {\n\t{.compatible = \"ti,omap4-l3-noc\", .data = &omap4_l3_data},\n\t{.compatible = \"ti,omap5-l3-noc\", .data = &omap5_l3_data},\n\t{.compatible = \"ti,dra7-l3-noc\", .data = &dra_l3_data},\n\t{.compatible = \"ti,am4372-l3-noc\", .data = &am4372_l3_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, l3_noc_match);\n\nstatic int omap_l3_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tstatic struct omap_l3 *l3;\n\tint ret, i, res_idx;\n\n\tof_id = of_match_device(l3_noc_match, &pdev->dev);\n\tif (!of_id) {\n\t\tdev_err(&pdev->dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tl3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);\n\tif (!l3)\n\t\treturn -ENOMEM;\n\n\tmemcpy(l3, of_id->data, sizeof(*l3));\n\tl3->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, l3);\n\n\t \n\tfor (i = 0, res_idx = 0; i < l3->num_modules; i++) {\n\t\tstruct resource\t*res;\n\n\t\tif (l3->l3_base[i] == L3_BASE_IS_SUBMODULE) {\n\t\t\t \n\t\t\tBUG_ON(i == 0);\n\t\t\tl3->l3_base[i] = l3->l3_base[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, res_idx);\n\t\tl3->l3_base[i] = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(l3->l3_base[i])) {\n\t\t\tdev_err(l3->dev, \"ioremap %d failed\\n\", i);\n\t\t\treturn PTR_ERR(l3->l3_base[i]);\n\t\t}\n\t\tres_idx++;\n\t}\n\n\t \n\tl3->debug_irq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(l3->dev, l3->debug_irq, l3_interrupt_handler,\n\t\t\t       IRQF_NO_THREAD, \"l3-dbg-irq\", l3);\n\tif (ret) {\n\t\tdev_err(l3->dev, \"request_irq failed for %d\\n\",\n\t\t\tl3->debug_irq);\n\t\treturn ret;\n\t}\n\n\tl3->app_irq = platform_get_irq(pdev, 1);\n\tret = devm_request_irq(l3->dev, l3->app_irq, l3_interrupt_handler,\n\t\t\t       IRQF_NO_THREAD, \"l3-app-irq\", l3);\n\tif (ret)\n\t\tdev_err(l3->dev, \"request_irq failed for %d\\n\", l3->app_irq);\n\n\treturn ret;\n}\n\n#ifdef\tCONFIG_PM_SLEEP\n\n \nstatic int l3_resume_noirq(struct device *dev)\n{\n\tstruct omap_l3 *l3 = dev_get_drvdata(dev);\n\tint i;\n\tstruct l3_flagmux_data *flag_mux;\n\tvoid __iomem *base, *mask_regx = NULL;\n\tu32 mask_val;\n\n\tfor (i = 0; i < l3->num_modules; i++) {\n\t\tbase = l3->l3_base[i];\n\t\tflag_mux = l3->l3_flagmux[i];\n\t\tif (!flag_mux->mask_app_bits && !flag_mux->mask_dbg_bits)\n\t\t\tcontinue;\n\n\t\tmask_regx = base + flag_mux->offset + L3_FLAGMUX_MASK0 +\n\t\t\t   (L3_APPLICATION_ERROR << 3);\n\t\tmask_val = readl_relaxed(mask_regx);\n\t\tmask_val &= ~(flag_mux->mask_app_bits);\n\n\t\twritel_relaxed(mask_val, mask_regx);\n\t\tmask_regx = base + flag_mux->offset + L3_FLAGMUX_MASK0 +\n\t\t\t   (L3_DEBUG_ERROR << 3);\n\t\tmask_val = readl_relaxed(mask_regx);\n\t\tmask_val &= ~(flag_mux->mask_dbg_bits);\n\n\t\twritel_relaxed(mask_val, mask_regx);\n\t}\n\n\t \n\tif (mask_regx)\n\t\t(void)readl(mask_regx);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops l3_dev_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, l3_resume_noirq)\n};\n\n#define L3_DEV_PM_OPS (&l3_dev_pm_ops)\n#else\n#define L3_DEV_PM_OPS NULL\n#endif\n\nstatic struct platform_driver omap_l3_driver = {\n\t.probe\t\t= omap_l3_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"omap_l3_noc\",\n\t\t.pm\t\t= L3_DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(l3_noc_match),\n\t},\n};\n\nstatic int __init omap_l3_init(void)\n{\n\treturn platform_driver_register(&omap_l3_driver);\n}\npostcore_initcall_sync(omap_l3_init);\n\nstatic void __exit omap_l3_exit(void)\n{\n\tplatform_driver_unregister(&omap_l3_driver);\n}\nmodule_exit(omap_l3_exit);\n\nMODULE_AUTHOR(\"Santosh Shilimkar\");\nMODULE_AUTHOR(\"Sricharan R\");\nMODULE_DESCRIPTION(\"OMAP L3 Interconnect error handling driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}