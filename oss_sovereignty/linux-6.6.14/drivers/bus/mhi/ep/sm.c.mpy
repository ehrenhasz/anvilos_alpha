{
  "module_name": "sm.c",
  "hash_id": "39f2c7f66537bc5705211d87a83f9726e6255b82524a4e5f075c6fe37a063569",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/ep/sm.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/mhi_ep.h>\n#include \"internal.h\"\n\nbool __must_check mhi_ep_check_mhi_state(struct mhi_ep_cntrl *mhi_cntrl,\n\t\t\t\t\t enum mhi_state cur_mhi_state,\n\t\t\t\t\t enum mhi_state mhi_state)\n{\n\tif (mhi_state == MHI_STATE_SYS_ERR)\n\t\treturn true;     \n\n\tif (mhi_state == MHI_STATE_READY)\n\t\treturn cur_mhi_state == MHI_STATE_RESET;\n\n\tif (mhi_state == MHI_STATE_M0)\n\t\treturn cur_mhi_state == MHI_STATE_M3 || cur_mhi_state == MHI_STATE_READY;\n\n\tif (mhi_state == MHI_STATE_M3)\n\t\treturn cur_mhi_state == MHI_STATE_M0;\n\n\treturn false;\n}\n\nint mhi_ep_set_mhi_state(struct mhi_ep_cntrl *mhi_cntrl, enum mhi_state mhi_state)\n{\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\n\tif (!mhi_ep_check_mhi_state(mhi_cntrl, mhi_cntrl->mhi_state, mhi_state)) {\n\t\tdev_err(dev, \"MHI state change to %s from %s is not allowed!\\n\",\n\t\t\tmhi_state_str(mhi_state),\n\t\t\tmhi_state_str(mhi_cntrl->mhi_state));\n\t\treturn -EACCES;\n\t}\n\n\t \n\tif (mhi_state == MHI_STATE_M1 || mhi_state == MHI_STATE_M2) {\n\t\tdev_err(dev, \"MHI state (%s) not supported\\n\", mhi_state_str(mhi_state));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmhi_ep_mmio_masked_write(mhi_cntrl, EP_MHISTATUS, MHISTATUS_MHISTATE_MASK, mhi_state);\n\tmhi_cntrl->mhi_state = mhi_state;\n\n\tif (mhi_state == MHI_STATE_READY)\n\t\tmhi_ep_mmio_masked_write(mhi_cntrl, EP_MHISTATUS, MHISTATUS_READY_MASK, 1);\n\n\tif (mhi_state == MHI_STATE_SYS_ERR)\n\t\tmhi_ep_mmio_masked_write(mhi_cntrl, EP_MHISTATUS, MHISTATUS_SYSERR_MASK, 1);\n\n\treturn 0;\n}\n\nint mhi_ep_set_m0_state(struct mhi_ep_cntrl *mhi_cntrl)\n{\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tenum mhi_state old_state;\n\tint ret;\n\n\t \n\tmutex_lock(&mhi_cntrl->state_lock);\n\n\told_state = mhi_cntrl->mhi_state;\n\tif (old_state == MHI_STATE_M3)\n\t\tmhi_ep_resume_channels(mhi_cntrl);\n\n\tret = mhi_ep_set_mhi_state(mhi_cntrl, MHI_STATE_M0);\n\tif (ret) {\n\t\tmhi_ep_handle_syserr(mhi_cntrl);\n\t\tgoto err_unlock;\n\t}\n\n\t \n\tret = mhi_ep_send_state_change_event(mhi_cntrl, MHI_STATE_M0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed sending M0 state change event\\n\");\n\t\tgoto err_unlock;\n\t}\n\n\tif (old_state == MHI_STATE_READY) {\n\t\t \n\t\tret = mhi_ep_send_ee_event(mhi_cntrl, MHI_EE_AMSS);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed sending AMSS EE event\\n\");\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\nerr_unlock:\n\tmutex_unlock(&mhi_cntrl->state_lock);\n\n\treturn ret;\n}\n\nint mhi_ep_set_m3_state(struct mhi_ep_cntrl *mhi_cntrl)\n{\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tint ret;\n\n\tmutex_lock(&mhi_cntrl->state_lock);\n\n\tret = mhi_ep_set_mhi_state(mhi_cntrl, MHI_STATE_M3);\n\tif (ret) {\n\t\tmhi_ep_handle_syserr(mhi_cntrl);\n\t\tgoto err_unlock;\n\t}\n\n\tmhi_ep_suspend_channels(mhi_cntrl);\n\n\t \n\tret = mhi_ep_send_state_change_event(mhi_cntrl, MHI_STATE_M3);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed sending M3 state change event\\n\");\n\t\tgoto err_unlock;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&mhi_cntrl->state_lock);\n\n\treturn ret;\n}\n\nint mhi_ep_set_ready_state(struct mhi_ep_cntrl *mhi_cntrl)\n{\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tenum mhi_state mhi_state;\n\tint ret, is_ready;\n\n\tmutex_lock(&mhi_cntrl->state_lock);\n\n\t \n\tmhi_state = mhi_ep_mmio_masked_read(mhi_cntrl, EP_MHISTATUS, MHISTATUS_MHISTATE_MASK);\n\tis_ready = mhi_ep_mmio_masked_read(mhi_cntrl, EP_MHISTATUS, MHISTATUS_READY_MASK);\n\n\tif (mhi_state != MHI_STATE_RESET || is_ready) {\n\t\tdev_err(dev, \"READY state transition failed. MHI host not in RESET state\\n\");\n\t\tret = -EIO;\n\t\tgoto err_unlock;\n\t}\n\n\tret = mhi_ep_set_mhi_state(mhi_cntrl, MHI_STATE_READY);\n\tif (ret)\n\t\tmhi_ep_handle_syserr(mhi_cntrl);\n\nerr_unlock:\n\tmutex_unlock(&mhi_cntrl->state_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}