{
  "module_name": "ring.c",
  "hash_id": "f1fe3bfb75bac102921969aea6fb0822244788d7abd882aa477a9e043aacf1d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/ep/ring.c",
  "human_readable_source": "\n \n\n#include <linux/mhi_ep.h>\n#include \"internal.h\"\n\nsize_t mhi_ep_ring_addr2offset(struct mhi_ep_ring *ring, u64 ptr)\n{\n\treturn (ptr - ring->rbase) / sizeof(struct mhi_ring_element);\n}\n\nstatic u32 mhi_ep_ring_num_elems(struct mhi_ep_ring *ring)\n{\n\t__le64 rlen;\n\n\tmemcpy_fromio(&rlen, (void __iomem *) &ring->ring_ctx->generic.rlen, sizeof(u64));\n\n\treturn le64_to_cpu(rlen) / sizeof(struct mhi_ring_element);\n}\n\nvoid mhi_ep_ring_inc_index(struct mhi_ep_ring *ring)\n{\n\tring->rd_offset = (ring->rd_offset + 1) % ring->ring_size;\n}\n\nstatic int __mhi_ep_cache_ring(struct mhi_ep_ring *ring, size_t end)\n{\n\tstruct mhi_ep_cntrl *mhi_cntrl = ring->mhi_cntrl;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tstruct mhi_ep_buf_info buf_info = {};\n\tsize_t start;\n\tint ret;\n\n\t \n\tif (ring->type == RING_TYPE_ER)\n\t\treturn 0;\n\n\t \n\tif (ring->wr_offset == end)\n\t\treturn 0;\n\n\tstart = ring->wr_offset;\n\tif (start < end) {\n\t\tbuf_info.size = (end - start) * sizeof(struct mhi_ring_element);\n\t\tbuf_info.host_addr = ring->rbase + (start * sizeof(struct mhi_ring_element));\n\t\tbuf_info.dev_addr = &ring->ring_cache[start];\n\n\t\tret = mhi_cntrl->read_from_host(mhi_cntrl, &buf_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tbuf_info.size = (ring->ring_size - start) * sizeof(struct mhi_ring_element);\n\t\tbuf_info.host_addr = ring->rbase + (start * sizeof(struct mhi_ring_element));\n\t\tbuf_info.dev_addr = &ring->ring_cache[start];\n\n\t\tret = mhi_cntrl->read_from_host(mhi_cntrl, &buf_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (end) {\n\t\t\tbuf_info.host_addr = ring->rbase;\n\t\t\tbuf_info.dev_addr = &ring->ring_cache[0];\n\t\t\tbuf_info.size = end * sizeof(struct mhi_ring_element);\n\n\t\t\tret = mhi_cntrl->read_from_host(mhi_cntrl, &buf_info);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"Cached ring: start %zu end %zu size %zu\\n\", start, end, buf_info.size);\n\n\treturn 0;\n}\n\nstatic int mhi_ep_cache_ring(struct mhi_ep_ring *ring, u64 wr_ptr)\n{\n\tsize_t wr_offset;\n\tint ret;\n\n\twr_offset = mhi_ep_ring_addr2offset(ring, wr_ptr);\n\n\t \n\tret = __mhi_ep_cache_ring(ring, wr_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tring->wr_offset = wr_offset;\n\n\treturn 0;\n}\n\nint mhi_ep_update_wr_offset(struct mhi_ep_ring *ring)\n{\n\tu64 wr_ptr;\n\n\twr_ptr = mhi_ep_mmio_get_db(ring);\n\n\treturn mhi_ep_cache_ring(ring, wr_ptr);\n}\n\n \nint mhi_ep_ring_add_element(struct mhi_ep_ring *ring, struct mhi_ring_element *el)\n{\n\tstruct mhi_ep_cntrl *mhi_cntrl = ring->mhi_cntrl;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tstruct mhi_ep_buf_info buf_info = {};\n\tsize_t old_offset = 0;\n\tu32 num_free_elem;\n\t__le64 rp;\n\tint ret;\n\n\tret = mhi_ep_update_wr_offset(ring);\n\tif (ret) {\n\t\tdev_err(dev, \"Error updating write pointer\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ring->rd_offset < ring->wr_offset)\n\t\tnum_free_elem = (ring->wr_offset - ring->rd_offset) - 1;\n\telse\n\t\tnum_free_elem = ((ring->ring_size - ring->rd_offset) + ring->wr_offset) - 1;\n\n\t \n\tif (!num_free_elem) {\n\t\tdev_err(dev, \"No space left in the ring\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\told_offset = ring->rd_offset;\n\tmhi_ep_ring_inc_index(ring);\n\n\tdev_dbg(dev, \"Adding an element to ring at offset (%zu)\\n\", ring->rd_offset);\n\n\t \n\trp = cpu_to_le64(ring->rd_offset * sizeof(*el) + ring->rbase);\n\tmemcpy_toio((void __iomem *) &ring->ring_ctx->generic.rp, &rp, sizeof(u64));\n\n\tbuf_info.host_addr = ring->rbase + (old_offset * sizeof(*el));\n\tbuf_info.dev_addr = el;\n\tbuf_info.size = sizeof(*el);\n\n\treturn mhi_cntrl->write_to_host(mhi_cntrl, &buf_info);\n}\n\nvoid mhi_ep_ring_init(struct mhi_ep_ring *ring, enum mhi_ep_ring_type type, u32 id)\n{\n\tring->type = type;\n\tif (ring->type == RING_TYPE_CMD) {\n\t\tring->db_offset_h = EP_CRDB_HIGHER;\n\t\tring->db_offset_l = EP_CRDB_LOWER;\n\t} else if (ring->type == RING_TYPE_CH) {\n\t\tring->db_offset_h = CHDB_HIGHER_n(id);\n\t\tring->db_offset_l = CHDB_LOWER_n(id);\n\t\tring->ch_id = id;\n\t} else {\n\t\tring->db_offset_h = ERDB_HIGHER_n(id);\n\t\tring->db_offset_l = ERDB_LOWER_n(id);\n\t}\n}\n\nint mhi_ep_ring_start(struct mhi_ep_cntrl *mhi_cntrl, struct mhi_ep_ring *ring,\n\t\t\tunion mhi_ep_ring_ctx *ctx)\n{\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\t__le64 val;\n\tint ret;\n\n\tring->mhi_cntrl = mhi_cntrl;\n\tring->ring_ctx = ctx;\n\tring->ring_size = mhi_ep_ring_num_elems(ring);\n\tmemcpy_fromio(&val, (void __iomem *) &ring->ring_ctx->generic.rbase, sizeof(u64));\n\tring->rbase = le64_to_cpu(val);\n\n\tif (ring->type == RING_TYPE_CH)\n\t\tring->er_index = le32_to_cpu(ring->ring_ctx->ch.erindex);\n\n\tif (ring->type == RING_TYPE_ER)\n\t\tring->irq_vector = le32_to_cpu(ring->ring_ctx->ev.msivec);\n\n\t \n\tmemcpy_fromio(&val, (void __iomem *) &ring->ring_ctx->generic.rp, sizeof(u64));\n\tring->rd_offset = mhi_ep_ring_addr2offset(ring, le64_to_cpu(val));\n\tring->wr_offset = mhi_ep_ring_addr2offset(ring, le64_to_cpu(val));\n\n\t \n\tring->ring_cache = kcalloc(ring->ring_size, sizeof(struct mhi_ring_element), GFP_KERNEL);\n\tif (!ring->ring_cache)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(&val, (void __iomem *) &ring->ring_ctx->generic.wp, sizeof(u64));\n\tret = mhi_ep_cache_ring(ring, le64_to_cpu(val));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to cache ring\\n\");\n\t\tkfree(ring->ring_cache);\n\t\treturn ret;\n\t}\n\n\tring->started = true;\n\n\treturn 0;\n}\n\nvoid mhi_ep_ring_reset(struct mhi_ep_cntrl *mhi_cntrl, struct mhi_ep_ring *ring)\n{\n\tring->started = false;\n\tkfree(ring->ring_cache);\n\tring->ring_cache = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}