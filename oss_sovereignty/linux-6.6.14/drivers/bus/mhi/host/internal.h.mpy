{
  "module_name": "internal.h",
  "hash_id": "15eb5451b2afe221d63bab047b15875bbd3cc54a79500d4ac08b59bbd72dc2a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/host/internal.h",
  "human_readable_source": " \n \n\n#ifndef _MHI_INT_H\n#define _MHI_INT_H\n\n#include \"../common.h\"\n\nextern struct bus_type mhi_bus_type;\n\n \n#define MHI_SOC_RESET_REQ_OFFSET\t\t\t0xb0\n#define MHI_SOC_RESET_REQ\t\t\t\tBIT(0)\n\n#define SOC_HW_VERSION_OFFS\t\t\t\t0x224\n#define SOC_HW_VERSION_FAM_NUM_BMSK\t\t\tGENMASK(31, 28)\n#define SOC_HW_VERSION_DEV_NUM_BMSK\t\t\tGENMASK(27, 16)\n#define SOC_HW_VERSION_MAJOR_VER_BMSK\t\t\tGENMASK(15, 8)\n#define SOC_HW_VERSION_MINOR_VER_BMSK\t\t\tGENMASK(7, 0)\n\nstruct mhi_ctxt {\n\tstruct mhi_event_ctxt *er_ctxt;\n\tstruct mhi_chan_ctxt *chan_ctxt;\n\tstruct mhi_cmd_ctxt *cmd_ctxt;\n\tdma_addr_t er_ctxt_addr;\n\tdma_addr_t chan_ctxt_addr;\n\tdma_addr_t cmd_ctxt_addr;\n};\n\nstruct bhi_vec_entry {\n\tu64 dma_addr;\n\tu64 size;\n};\n\nenum mhi_ch_state_type {\n\tMHI_CH_STATE_TYPE_RESET,\n\tMHI_CH_STATE_TYPE_STOP,\n\tMHI_CH_STATE_TYPE_START,\n\tMHI_CH_STATE_TYPE_MAX,\n};\n\nextern const char * const mhi_ch_state_type_str[MHI_CH_STATE_TYPE_MAX];\n#define TO_CH_STATE_TYPE_STR(state) (((state) >= MHI_CH_STATE_TYPE_MAX) ? \\\n\t\t\t\t     \"INVALID_STATE\" : \\\n\t\t\t\t     mhi_ch_state_type_str[(state)])\n\n#define MHI_INVALID_BRSTMODE(mode) (mode != MHI_DB_BRST_DISABLE && \\\n\t\t\t\t    mode != MHI_DB_BRST_ENABLE)\n\nextern const char * const mhi_ee_str[MHI_EE_MAX];\n#define TO_MHI_EXEC_STR(ee) (((ee) >= MHI_EE_MAX) ? \\\n\t\t\t     \"INVALID_EE\" : mhi_ee_str[ee])\n\n#define MHI_IN_PBL(ee) (ee == MHI_EE_PBL || ee == MHI_EE_PTHRU || \\\n\t\t\tee == MHI_EE_EDL)\n#define MHI_POWER_UP_CAPABLE(ee) (MHI_IN_PBL(ee) || ee == MHI_EE_AMSS)\n#define MHI_FW_LOAD_CAPABLE(ee) (ee == MHI_EE_PBL || ee == MHI_EE_EDL)\n#define MHI_IN_MISSION_MODE(ee) (ee == MHI_EE_AMSS || ee == MHI_EE_WFW || \\\n\t\t\t\t ee == MHI_EE_FP)\n\nenum dev_st_transition {\n\tDEV_ST_TRANSITION_PBL,\n\tDEV_ST_TRANSITION_READY,\n\tDEV_ST_TRANSITION_SBL,\n\tDEV_ST_TRANSITION_MISSION_MODE,\n\tDEV_ST_TRANSITION_FP,\n\tDEV_ST_TRANSITION_SYS_ERR,\n\tDEV_ST_TRANSITION_DISABLE,\n\tDEV_ST_TRANSITION_MAX,\n};\n\nextern const char * const dev_state_tran_str[DEV_ST_TRANSITION_MAX];\n#define TO_DEV_STATE_TRANS_STR(state) (((state) >= DEV_ST_TRANSITION_MAX) ? \\\n\t\t\t\t\"INVALID_STATE\" : dev_state_tran_str[state])\n\n \nenum mhi_pm_state {\n\tMHI_PM_STATE_DISABLE,\n\tMHI_PM_STATE_POR,\n\tMHI_PM_STATE_M0,\n\tMHI_PM_STATE_M2,\n\tMHI_PM_STATE_M3_ENTER,\n\tMHI_PM_STATE_M3,\n\tMHI_PM_STATE_M3_EXIT,\n\tMHI_PM_STATE_FW_DL_ERR,\n\tMHI_PM_STATE_SYS_ERR_DETECT,\n\tMHI_PM_STATE_SYS_ERR_PROCESS,\n\tMHI_PM_STATE_SHUTDOWN_PROCESS,\n\tMHI_PM_STATE_LD_ERR_FATAL_DETECT,\n\tMHI_PM_STATE_MAX\n};\n\n#define MHI_PM_DISABLE\t\t\t\t\tBIT(0)\n#define MHI_PM_POR\t\t\t\t\tBIT(1)\n#define MHI_PM_M0\t\t\t\t\tBIT(2)\n#define MHI_PM_M2\t\t\t\t\tBIT(3)\n#define MHI_PM_M3_ENTER\t\t\t\t\tBIT(4)\n#define MHI_PM_M3\t\t\t\t\tBIT(5)\n#define MHI_PM_M3_EXIT\t\t\t\t\tBIT(6)\n \n#define MHI_PM_FW_DL_ERR\t\t\t\tBIT(7)\n#define MHI_PM_SYS_ERR_DETECT\t\t\t\tBIT(8)\n#define MHI_PM_SYS_ERR_PROCESS\t\t\t\tBIT(9)\n#define MHI_PM_SHUTDOWN_PROCESS\t\t\t\tBIT(10)\n \n#define MHI_PM_LD_ERR_FATAL_DETECT\t\t\tBIT(11)\n\n#define MHI_REG_ACCESS_VALID(pm_state)\t\t\t((pm_state & (MHI_PM_POR | MHI_PM_M0 | \\\n\t\t\t\t\t\tMHI_PM_M2 | MHI_PM_M3_ENTER | MHI_PM_M3_EXIT | \\\n\t\t\t\t\t\tMHI_PM_SYS_ERR_DETECT | MHI_PM_SYS_ERR_PROCESS | \\\n\t\t\t\t\t\tMHI_PM_SHUTDOWN_PROCESS | MHI_PM_FW_DL_ERR)))\n#define MHI_PM_IN_ERROR_STATE(pm_state)\t\t\t(pm_state >= MHI_PM_FW_DL_ERR)\n#define MHI_PM_IN_FATAL_STATE(pm_state)\t\t\t(pm_state == MHI_PM_LD_ERR_FATAL_DETECT)\n#define MHI_DB_ACCESS_VALID(mhi_cntrl)\t\t\t(mhi_cntrl->pm_state & mhi_cntrl->db_access)\n#define MHI_WAKE_DB_CLEAR_VALID(pm_state)\t\t(pm_state & (MHI_PM_M0 | \\\n\t\t\t\t\t\t\tMHI_PM_M2 | MHI_PM_M3_EXIT))\n#define MHI_WAKE_DB_SET_VALID(pm_state)\t\t\t(pm_state & MHI_PM_M2)\n#define MHI_WAKE_DB_FORCE_SET_VALID(pm_state)\t\tMHI_WAKE_DB_CLEAR_VALID(pm_state)\n#define MHI_EVENT_ACCESS_INVALID(pm_state)\t\t(pm_state == MHI_PM_DISABLE || \\\n\t\t\t\t\t\t\tMHI_PM_IN_ERROR_STATE(pm_state))\n#define MHI_PM_IN_SUSPEND_STATE(pm_state)\t\t(pm_state & \\\n\t\t\t\t\t\t\t(MHI_PM_M3_ENTER | MHI_PM_M3))\n\n#define NR_OF_CMD_RINGS\t\t\t\t\t1\n#define CMD_EL_PER_RING\t\t\t\t\t128\n#define PRIMARY_CMD_RING\t\t\t\t0\n#define MHI_DEV_WAKE_DB\t\t\t\t\t127\n#define MHI_MAX_MTU\t\t\t\t\t0xffff\n#define MHI_RANDOM_U32_NONZERO(bmsk)\t\t\t(get_random_u32_inclusive(1, bmsk))\n\nenum mhi_er_type {\n\tMHI_ER_TYPE_INVALID = 0x0,\n\tMHI_ER_TYPE_VALID = 0x1,\n};\n\nstruct db_cfg {\n\tbool reset_req;\n\tbool db_mode;\n\tu32 pollcfg;\n\tenum mhi_db_brst_mode brstmode;\n\tdma_addr_t db_val;\n\tvoid (*process_db)(struct mhi_controller *mhi_cntrl,\n\t\t\t   struct db_cfg *db_cfg, void __iomem *io_addr,\n\t\t\t   dma_addr_t db_val);\n};\n\nstruct mhi_pm_transitions {\n\tenum mhi_pm_state from_state;\n\tu32 to_states;\n};\n\nstruct state_transition {\n\tstruct list_head node;\n\tenum dev_st_transition state;\n};\n\nstruct mhi_ring {\n\tdma_addr_t dma_handle;\n\tdma_addr_t iommu_base;\n\t__le64 *ctxt_wp;  \n\tvoid *pre_aligned;\n\tvoid *base;\n\tvoid *rp;\n\tvoid *wp;\n\tsize_t el_size;\n\tsize_t len;\n\tsize_t elements;\n\tsize_t alloc_size;\n\tvoid __iomem *db_addr;\n};\n\nstruct mhi_cmd {\n\tstruct mhi_ring ring;\n\tspinlock_t lock;\n};\n\nstruct mhi_buf_info {\n\tvoid *v_addr;\n\tvoid *bb_addr;\n\tvoid *wp;\n\tvoid *cb_buf;\n\tdma_addr_t p_addr;\n\tsize_t len;\n\tenum dma_data_direction dir;\n\tbool used;  \n\tbool pre_mapped;  \n};\n\nstruct mhi_event {\n\tstruct mhi_controller *mhi_cntrl;\n\tstruct mhi_chan *mhi_chan;  \n\tu32 er_index;\n\tu32 intmod;\n\tu32 irq;\n\tint chan;  \n\tu32 priority;\n\tenum mhi_er_data_type data_type;\n\tstruct mhi_ring ring;\n\tstruct db_cfg db_cfg;\n\tstruct tasklet_struct task;\n\tspinlock_t lock;\n\tint (*process_event)(struct mhi_controller *mhi_cntrl,\n\t\t\t     struct mhi_event *mhi_event,\n\t\t\t     u32 event_quota);\n\tbool hw_ring;\n\tbool cl_manage;\n\tbool offload_ev;  \n};\n\nstruct mhi_chan {\n\tconst char *name;\n\t \n\tstruct mhi_ring buf_ring;\n\tstruct mhi_ring tre_ring;\n\tu32 chan;\n\tu32 er_index;\n\tu32 intmod;\n\tenum mhi_ch_type type;\n\tenum dma_data_direction dir;\n\tstruct db_cfg db_cfg;\n\tenum mhi_ch_ee_mask ee_mask;\n\tenum mhi_ch_state ch_state;\n\tenum mhi_ev_ccs ccs;\n\tstruct mhi_device *mhi_dev;\n\tvoid (*xfer_cb)(struct mhi_device *mhi_dev, struct mhi_result *result);\n\tstruct mutex mutex;\n\tstruct completion completion;\n\trwlock_t lock;\n\tstruct list_head node;\n\tbool lpm_notify;\n\tbool configured;\n\tbool offload_ch;\n\tbool pre_alloc;\n\tbool wake_capable;\n};\n\n \n#define MHI_TIMEOUT_MS (1000)\n\n \n#ifdef CONFIG_MHI_BUS_DEBUG\nvoid mhi_create_debugfs(struct mhi_controller *mhi_cntrl);\nvoid mhi_destroy_debugfs(struct mhi_controller *mhi_cntrl);\nvoid mhi_debugfs_init(void);\nvoid mhi_debugfs_exit(void);\n#else\nstatic inline void mhi_create_debugfs(struct mhi_controller *mhi_cntrl)\n{\n}\n\nstatic inline void mhi_destroy_debugfs(struct mhi_controller *mhi_cntrl)\n{\n}\n\nstatic inline void mhi_debugfs_init(void)\n{\n}\n\nstatic inline void mhi_debugfs_exit(void)\n{\n}\n#endif\n\nstruct mhi_device *mhi_alloc_device(struct mhi_controller *mhi_cntrl);\n\nint mhi_destroy_device(struct device *dev, void *data);\nvoid mhi_create_devices(struct mhi_controller *mhi_cntrl);\n\nint mhi_alloc_bhie_table(struct mhi_controller *mhi_cntrl,\n\t\t\t struct image_info **image_info, size_t alloc_size);\nvoid mhi_free_bhie_table(struct mhi_controller *mhi_cntrl,\n\t\t\t struct image_info *image_info);\n\n \nenum mhi_pm_state __must_check mhi_tryset_pm_state(\n\t\t\t\t\tstruct mhi_controller *mhi_cntrl,\n\t\t\t\t\tenum mhi_pm_state state);\nconst char *to_mhi_pm_state_str(u32 state);\nint mhi_queue_state_transition(struct mhi_controller *mhi_cntrl,\n\t\t\t       enum dev_st_transition state);\nvoid mhi_pm_st_worker(struct work_struct *work);\nvoid mhi_pm_sys_err_handler(struct mhi_controller *mhi_cntrl);\nint mhi_ready_state_transition(struct mhi_controller *mhi_cntrl);\nint mhi_pm_m0_transition(struct mhi_controller *mhi_cntrl);\nvoid mhi_pm_m1_transition(struct mhi_controller *mhi_cntrl);\nint mhi_pm_m3_transition(struct mhi_controller *mhi_cntrl);\nint __mhi_device_get_sync(struct mhi_controller *mhi_cntrl);\nint mhi_send_cmd(struct mhi_controller *mhi_cntrl, struct mhi_chan *mhi_chan,\n\t\t enum mhi_cmd_type cmd);\nint mhi_download_amss_image(struct mhi_controller *mhi_cntrl);\nstatic inline bool mhi_is_active(struct mhi_controller *mhi_cntrl)\n{\n\treturn (mhi_cntrl->dev_state >= MHI_STATE_M0 &&\n\t\tmhi_cntrl->dev_state <= MHI_STATE_M3_FAST);\n}\n\nstatic inline void mhi_trigger_resume(struct mhi_controller *mhi_cntrl)\n{\n\tpm_wakeup_event(&mhi_cntrl->mhi_dev->dev, 0);\n\tmhi_cntrl->runtime_get(mhi_cntrl);\n\tmhi_cntrl->runtime_put(mhi_cntrl);\n}\n\n \nvoid mhi_db_brstmode(struct mhi_controller *mhi_cntrl, struct db_cfg *db_cfg,\n\t\t     void __iomem *db_addr, dma_addr_t db_val);\nvoid mhi_db_brstmode_disable(struct mhi_controller *mhi_cntrl,\n\t\t\t     struct db_cfg *db_mode, void __iomem *db_addr,\n\t\t\t     dma_addr_t db_val);\nint __must_check mhi_read_reg(struct mhi_controller *mhi_cntrl,\n\t\t\t      void __iomem *base, u32 offset, u32 *out);\nint __must_check mhi_read_reg_field(struct mhi_controller *mhi_cntrl,\n\t\t\t\t    void __iomem *base, u32 offset, u32 mask,\n\t\t\t\t    u32 *out);\nint __must_check mhi_poll_reg_field(struct mhi_controller *mhi_cntrl,\n\t\t\t\t    void __iomem *base, u32 offset, u32 mask,\n\t\t\t\t    u32 val, u32 delayus);\nvoid mhi_write_reg(struct mhi_controller *mhi_cntrl, void __iomem *base,\n\t\t   u32 offset, u32 val);\nint __must_check mhi_write_reg_field(struct mhi_controller *mhi_cntrl,\n\t\t\t\t     void __iomem *base, u32 offset, u32 mask,\n\t\t\t\t     u32 val);\nvoid mhi_ring_er_db(struct mhi_event *mhi_event);\nvoid mhi_write_db(struct mhi_controller *mhi_cntrl, void __iomem *db_addr,\n\t\t  dma_addr_t db_val);\nvoid mhi_ring_cmd_db(struct mhi_controller *mhi_cntrl, struct mhi_cmd *mhi_cmd);\nvoid mhi_ring_chan_db(struct mhi_controller *mhi_cntrl,\n\t\t      struct mhi_chan *mhi_chan);\n\n \nint mhi_init_mmio(struct mhi_controller *mhi_cntrl);\nint mhi_init_dev_ctxt(struct mhi_controller *mhi_cntrl);\nvoid mhi_deinit_dev_ctxt(struct mhi_controller *mhi_cntrl);\nint mhi_init_irq_setup(struct mhi_controller *mhi_cntrl);\nvoid mhi_deinit_free_irq(struct mhi_controller *mhi_cntrl);\nint mhi_rddm_prepare(struct mhi_controller *mhi_cntrl,\n\t\t      struct image_info *img_info);\nvoid mhi_fw_load_handler(struct mhi_controller *mhi_cntrl);\n\n \n#define MHI_CH_INBOUND_ALLOC_BUFS BIT(0)\nint mhi_prepare_channel(struct mhi_controller *mhi_cntrl,\n\t\t\tstruct mhi_chan *mhi_chan, unsigned int flags);\n\nint mhi_init_chan_ctxt(struct mhi_controller *mhi_cntrl,\n\t\t       struct mhi_chan *mhi_chan);\nvoid mhi_deinit_chan_ctxt(struct mhi_controller *mhi_cntrl,\n\t\t\t  struct mhi_chan *mhi_chan);\nvoid mhi_reset_chan(struct mhi_controller *mhi_cntrl,\n\t\t    struct mhi_chan *mhi_chan);\n\n \nvoid mhi_ctrl_ev_task(unsigned long data);\nvoid mhi_ev_task(unsigned long data);\nint mhi_process_data_event_ring(struct mhi_controller *mhi_cntrl,\n\t\t\t\tstruct mhi_event *mhi_event, u32 event_quota);\nint mhi_process_ctrl_ev_ring(struct mhi_controller *mhi_cntrl,\n\t\t\t     struct mhi_event *mhi_event, u32 event_quota);\n\n \nirqreturn_t mhi_irq_handler(int irq_number, void *dev);\nirqreturn_t mhi_intvec_threaded_handler(int irq_number, void *dev);\nirqreturn_t mhi_intvec_handler(int irq_number, void *dev);\n\nint mhi_gen_tre(struct mhi_controller *mhi_cntrl, struct mhi_chan *mhi_chan,\n\t\tstruct mhi_buf_info *info, enum mhi_flags flags);\nint mhi_map_single_no_bb(struct mhi_controller *mhi_cntrl,\n\t\t\t struct mhi_buf_info *buf_info);\nint mhi_map_single_use_bb(struct mhi_controller *mhi_cntrl,\n\t\t\t  struct mhi_buf_info *buf_info);\nvoid mhi_unmap_single_no_bb(struct mhi_controller *mhi_cntrl,\n\t\t\t    struct mhi_buf_info *buf_info);\nvoid mhi_unmap_single_use_bb(struct mhi_controller *mhi_cntrl,\n\t\t\t     struct mhi_buf_info *buf_info);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}