{
  "module_name": "boot.c",
  "hash_id": "ed1e5dd38758b2c0068b75bfa75411c0fe71e1f5bc5665f1ada5bc300a433ba6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/host/boot.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-direction.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/mhi.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include \"internal.h\"\n\n \nint mhi_rddm_prepare(struct mhi_controller *mhi_cntrl,\n\t\t     struct image_info *img_info)\n{\n\tstruct mhi_buf *mhi_buf = img_info->mhi_buf;\n\tstruct bhi_vec_entry *bhi_vec = img_info->bhi_vec;\n\tvoid __iomem *base = mhi_cntrl->bhie;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tu32 sequence_id;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < img_info->entries - 1; i++, mhi_buf++, bhi_vec++) {\n\t\tbhi_vec->dma_addr = mhi_buf->dma_addr;\n\t\tbhi_vec->size = mhi_buf->len;\n\t}\n\n\tdev_dbg(dev, \"BHIe programming for RDDM\\n\");\n\n\tmhi_write_reg(mhi_cntrl, base, BHIE_RXVECADDR_HIGH_OFFS,\n\t\t      upper_32_bits(mhi_buf->dma_addr));\n\n\tmhi_write_reg(mhi_cntrl, base, BHIE_RXVECADDR_LOW_OFFS,\n\t\t      lower_32_bits(mhi_buf->dma_addr));\n\n\tmhi_write_reg(mhi_cntrl, base, BHIE_RXVECSIZE_OFFS, mhi_buf->len);\n\tsequence_id = MHI_RANDOM_U32_NONZERO(BHIE_RXVECSTATUS_SEQNUM_BMSK);\n\n\tret = mhi_write_reg_field(mhi_cntrl, base, BHIE_RXVECDB_OFFS,\n\t\t\t\t  BHIE_RXVECDB_SEQNUM_BMSK, sequence_id);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write sequence ID for BHIE_RXVECDB\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"Address: %p and len: 0x%zx sequence: %u\\n\",\n\t\t&mhi_buf->dma_addr, mhi_buf->len, sequence_id);\n\n\treturn 0;\n}\n\n \nstatic int __mhi_download_rddm_in_panic(struct mhi_controller *mhi_cntrl)\n{\n\tint ret;\n\tu32 rx_status;\n\tenum mhi_ee_type ee;\n\tconst u32 delayus = 2000;\n\tu32 retry = (mhi_cntrl->timeout_ms * 1000) / delayus;\n\tconst u32 rddm_timeout_us = 200000;\n\tint rddm_retry = rddm_timeout_us / delayus;\n\tvoid __iomem *base = mhi_cntrl->bhie;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\n\tdev_dbg(dev, \"Entered with pm_state:%s dev_state:%s ee:%s\\n\",\n\t\tto_mhi_pm_state_str(mhi_cntrl->pm_state),\n\t\tmhi_state_str(mhi_cntrl->dev_state),\n\t\tTO_MHI_EXEC_STR(mhi_cntrl->ee));\n\n\t \n\tmhi_cntrl->pm_state = MHI_PM_LD_ERR_FATAL_DETECT;\n\t \n\tsmp_wmb();\n\n\t \n\tee = mhi_get_exec_env(mhi_cntrl);\n\tif (ee == MHI_EE_MAX)\n\t\tgoto error_exit_rddm;\n\n\tif (ee != MHI_EE_RDDM) {\n\t\tdev_dbg(dev, \"Trigger device into RDDM mode using SYS ERR\\n\");\n\t\tmhi_set_mhi_state(mhi_cntrl, MHI_STATE_SYS_ERR);\n\n\t\tdev_dbg(dev, \"Waiting for device to enter RDDM\\n\");\n\t\twhile (rddm_retry--) {\n\t\t\tee = mhi_get_exec_env(mhi_cntrl);\n\t\t\tif (ee == MHI_EE_RDDM)\n\t\t\t\tbreak;\n\n\t\t\tudelay(delayus);\n\t\t}\n\n\t\tif (rddm_retry <= 0) {\n\t\t\t \n\t\t\tdev_dbg(dev,\n\t\t\t\t\"Did not enter RDDM, do a host req reset\\n\");\n\t\t\tmhi_soc_reset(mhi_cntrl);\n\t\t\tudelay(delayus);\n\t\t}\n\n\t\tee = mhi_get_exec_env(mhi_cntrl);\n\t}\n\n\tdev_dbg(dev,\n\t\t\"Waiting for RDDM image download via BHIe, current EE:%s\\n\",\n\t\tTO_MHI_EXEC_STR(ee));\n\n\twhile (retry--) {\n\t\tret = mhi_read_reg_field(mhi_cntrl, base, BHIE_RXVECSTATUS_OFFS,\n\t\t\t\t\t BHIE_RXVECSTATUS_STATUS_BMSK, &rx_status);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\n\t\tif (rx_status == BHIE_RXVECSTATUS_STATUS_XFER_COMPL)\n\t\t\treturn 0;\n\n\t\tudelay(delayus);\n\t}\n\n\tee = mhi_get_exec_env(mhi_cntrl);\n\tret = mhi_read_reg(mhi_cntrl, base, BHIE_RXVECSTATUS_OFFS, &rx_status);\n\n\tdev_err(dev, \"RXVEC_STATUS: 0x%x\\n\", rx_status);\n\nerror_exit_rddm:\n\tdev_err(dev, \"RDDM transfer failed. Current EE: %s\\n\",\n\t\tTO_MHI_EXEC_STR(ee));\n\n\treturn -EIO;\n}\n\n \nint mhi_download_rddm_image(struct mhi_controller *mhi_cntrl, bool in_panic)\n{\n\tvoid __iomem *base = mhi_cntrl->bhie;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tu32 rx_status;\n\n\tif (in_panic)\n\t\treturn __mhi_download_rddm_in_panic(mhi_cntrl);\n\n\tdev_dbg(dev, \"Waiting for RDDM image download via BHIe\\n\");\n\n\t \n\twait_event_timeout(mhi_cntrl->state_event,\n\t\t\t   mhi_read_reg_field(mhi_cntrl, base,\n\t\t\t\t\t      BHIE_RXVECSTATUS_OFFS,\n\t\t\t\t\t      BHIE_RXVECSTATUS_STATUS_BMSK,\n\t\t\t\t\t      &rx_status) || rx_status,\n\t\t\t   msecs_to_jiffies(mhi_cntrl->timeout_ms));\n\n\treturn (rx_status == BHIE_RXVECSTATUS_STATUS_XFER_COMPL) ? 0 : -EIO;\n}\nEXPORT_SYMBOL_GPL(mhi_download_rddm_image);\n\nstatic int mhi_fw_load_bhie(struct mhi_controller *mhi_cntrl,\n\t\t\t    const struct mhi_buf *mhi_buf)\n{\n\tvoid __iomem *base = mhi_cntrl->bhie;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\trwlock_t *pm_lock = &mhi_cntrl->pm_lock;\n\tu32 tx_status, sequence_id;\n\tint ret;\n\n\tread_lock_bh(pm_lock);\n\tif (!MHI_REG_ACCESS_VALID(mhi_cntrl->pm_state)) {\n\t\tread_unlock_bh(pm_lock);\n\t\treturn -EIO;\n\t}\n\n\tsequence_id = MHI_RANDOM_U32_NONZERO(BHIE_TXVECSTATUS_SEQNUM_BMSK);\n\tdev_dbg(dev, \"Starting image download via BHIe. Sequence ID: %u\\n\",\n\t\tsequence_id);\n\tmhi_write_reg(mhi_cntrl, base, BHIE_TXVECADDR_HIGH_OFFS,\n\t\t      upper_32_bits(mhi_buf->dma_addr));\n\n\tmhi_write_reg(mhi_cntrl, base, BHIE_TXVECADDR_LOW_OFFS,\n\t\t      lower_32_bits(mhi_buf->dma_addr));\n\n\tmhi_write_reg(mhi_cntrl, base, BHIE_TXVECSIZE_OFFS, mhi_buf->len);\n\n\tret = mhi_write_reg_field(mhi_cntrl, base, BHIE_TXVECDB_OFFS,\n\t\t\t\t  BHIE_TXVECDB_SEQNUM_BMSK, sequence_id);\n\tread_unlock_bh(pm_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = wait_event_timeout(mhi_cntrl->state_event,\n\t\t\t\t MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state) ||\n\t\t\t\t mhi_read_reg_field(mhi_cntrl, base,\n\t\t\t\t\t\t   BHIE_TXVECSTATUS_OFFS,\n\t\t\t\t\t\t   BHIE_TXVECSTATUS_STATUS_BMSK,\n\t\t\t\t\t\t   &tx_status) || tx_status,\n\t\t\t\t msecs_to_jiffies(mhi_cntrl->timeout_ms));\n\tif (MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state) ||\n\t    tx_status != BHIE_TXVECSTATUS_STATUS_XFER_COMPL)\n\t\treturn -EIO;\n\n\treturn (!ret) ? -ETIMEDOUT : 0;\n}\n\nstatic int mhi_fw_load_bhi(struct mhi_controller *mhi_cntrl,\n\t\t\t   dma_addr_t dma_addr,\n\t\t\t   size_t size)\n{\n\tu32 tx_status, val, session_id;\n\tint i, ret;\n\tvoid __iomem *base = mhi_cntrl->bhi;\n\trwlock_t *pm_lock = &mhi_cntrl->pm_lock;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tstruct {\n\t\tchar *name;\n\t\tu32 offset;\n\t} error_reg[] = {\n\t\t{ \"ERROR_CODE\", BHI_ERRCODE },\n\t\t{ \"ERROR_DBG1\", BHI_ERRDBG1 },\n\t\t{ \"ERROR_DBG2\", BHI_ERRDBG2 },\n\t\t{ \"ERROR_DBG3\", BHI_ERRDBG3 },\n\t\t{ NULL },\n\t};\n\n\tread_lock_bh(pm_lock);\n\tif (!MHI_REG_ACCESS_VALID(mhi_cntrl->pm_state)) {\n\t\tread_unlock_bh(pm_lock);\n\t\tgoto invalid_pm_state;\n\t}\n\n\tsession_id = MHI_RANDOM_U32_NONZERO(BHI_TXDB_SEQNUM_BMSK);\n\tdev_dbg(dev, \"Starting image download via BHI. Session ID: %u\\n\",\n\t\tsession_id);\n\tmhi_write_reg(mhi_cntrl, base, BHI_STATUS, 0);\n\tmhi_write_reg(mhi_cntrl, base, BHI_IMGADDR_HIGH,\n\t\t      upper_32_bits(dma_addr));\n\tmhi_write_reg(mhi_cntrl, base, BHI_IMGADDR_LOW,\n\t\t      lower_32_bits(dma_addr));\n\tmhi_write_reg(mhi_cntrl, base, BHI_IMGSIZE, size);\n\tmhi_write_reg(mhi_cntrl, base, BHI_IMGTXDB, session_id);\n\tread_unlock_bh(pm_lock);\n\n\t \n\tret = wait_event_timeout(mhi_cntrl->state_event,\n\t\t\t   MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state) ||\n\t\t\t   mhi_read_reg_field(mhi_cntrl, base, BHI_STATUS,\n\t\t\t\t\t      BHI_STATUS_MASK, &tx_status) || tx_status,\n\t\t\t   msecs_to_jiffies(mhi_cntrl->timeout_ms));\n\tif (MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state))\n\t\tgoto invalid_pm_state;\n\n\tif (tx_status == BHI_STATUS_ERROR) {\n\t\tdev_err(dev, \"Image transfer failed\\n\");\n\t\tread_lock_bh(pm_lock);\n\t\tif (MHI_REG_ACCESS_VALID(mhi_cntrl->pm_state)) {\n\t\t\tfor (i = 0; error_reg[i].name; i++) {\n\t\t\t\tret = mhi_read_reg(mhi_cntrl, base,\n\t\t\t\t\t\t   error_reg[i].offset, &val);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tdev_err(dev, \"Reg: %s value: 0x%x\\n\",\n\t\t\t\t\terror_reg[i].name, val);\n\t\t\t}\n\t\t}\n\t\tread_unlock_bh(pm_lock);\n\t\tgoto invalid_pm_state;\n\t}\n\n\treturn (!ret) ? -ETIMEDOUT : 0;\n\ninvalid_pm_state:\n\n\treturn -EIO;\n}\n\nvoid mhi_free_bhie_table(struct mhi_controller *mhi_cntrl,\n\t\t\t struct image_info *image_info)\n{\n\tint i;\n\tstruct mhi_buf *mhi_buf = image_info->mhi_buf;\n\n\tfor (i = 0; i < image_info->entries; i++, mhi_buf++)\n\t\tdma_free_coherent(mhi_cntrl->cntrl_dev, mhi_buf->len,\n\t\t\t\t  mhi_buf->buf, mhi_buf->dma_addr);\n\n\tkfree(image_info->mhi_buf);\n\tkfree(image_info);\n}\n\nint mhi_alloc_bhie_table(struct mhi_controller *mhi_cntrl,\n\t\t\t struct image_info **image_info,\n\t\t\t size_t alloc_size)\n{\n\tsize_t seg_size = mhi_cntrl->seg_len;\n\tint segments = DIV_ROUND_UP(alloc_size, seg_size) + 1;\n\tint i;\n\tstruct image_info *img_info;\n\tstruct mhi_buf *mhi_buf;\n\n\timg_info = kzalloc(sizeof(*img_info), GFP_KERNEL);\n\tif (!img_info)\n\t\treturn -ENOMEM;\n\n\t \n\timg_info->mhi_buf = kcalloc(segments, sizeof(*img_info->mhi_buf),\n\t\t\t\t    GFP_KERNEL);\n\tif (!img_info->mhi_buf)\n\t\tgoto error_alloc_mhi_buf;\n\n\t \n\tmhi_buf = img_info->mhi_buf;\n\tfor (i = 0; i < segments; i++, mhi_buf++) {\n\t\tsize_t vec_size = seg_size;\n\n\t\t \n\t\tif (i == segments - 1)\n\t\t\tvec_size = sizeof(struct bhi_vec_entry) * i;\n\n\t\tmhi_buf->len = vec_size;\n\t\tmhi_buf->buf = dma_alloc_coherent(mhi_cntrl->cntrl_dev,\n\t\t\t\t\t\t  vec_size, &mhi_buf->dma_addr,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!mhi_buf->buf)\n\t\t\tgoto error_alloc_segment;\n\t}\n\n\timg_info->bhi_vec = img_info->mhi_buf[segments - 1].buf;\n\timg_info->entries = segments;\n\t*image_info = img_info;\n\n\treturn 0;\n\nerror_alloc_segment:\n\tfor (--i, --mhi_buf; i >= 0; i--, mhi_buf--)\n\t\tdma_free_coherent(mhi_cntrl->cntrl_dev, mhi_buf->len,\n\t\t\t\t  mhi_buf->buf, mhi_buf->dma_addr);\n\nerror_alloc_mhi_buf:\n\tkfree(img_info);\n\n\treturn -ENOMEM;\n}\n\nstatic void mhi_firmware_copy(struct mhi_controller *mhi_cntrl,\n\t\t\t      const u8 *buf, size_t remainder,\n\t\t\t      struct image_info *img_info)\n{\n\tsize_t to_cpy;\n\tstruct mhi_buf *mhi_buf = img_info->mhi_buf;\n\tstruct bhi_vec_entry *bhi_vec = img_info->bhi_vec;\n\n\twhile (remainder) {\n\t\tto_cpy = min(remainder, mhi_buf->len);\n\t\tmemcpy(mhi_buf->buf, buf, to_cpy);\n\t\tbhi_vec->dma_addr = mhi_buf->dma_addr;\n\t\tbhi_vec->size = to_cpy;\n\n\t\tbuf += to_cpy;\n\t\tremainder -= to_cpy;\n\t\tbhi_vec++;\n\t\tmhi_buf++;\n\t}\n}\n\nvoid mhi_fw_load_handler(struct mhi_controller *mhi_cntrl)\n{\n\tconst struct firmware *firmware = NULL;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tenum mhi_pm_state new_state;\n\tconst char *fw_name;\n\tconst u8 *fw_data;\n\tvoid *buf;\n\tdma_addr_t dma_addr;\n\tsize_t size, fw_sz;\n\tint i, ret;\n\n\tif (MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state)) {\n\t\tdev_err(dev, \"Device MHI is not in valid state\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = mhi_read_reg(mhi_cntrl, mhi_cntrl->bhi, BHI_SERIALNU,\n\t\t\t   &mhi_cntrl->serial_number);\n\tif (ret)\n\t\tdev_err(dev, \"Could not capture serial number via BHI\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(mhi_cntrl->oem_pk_hash); i++) {\n\t\tret = mhi_read_reg(mhi_cntrl, mhi_cntrl->bhi, BHI_OEMPKHASH(i),\n\t\t\t\t   &mhi_cntrl->oem_pk_hash[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Could not capture OEM PK HASH via BHI\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!MHI_FW_LOAD_CAPABLE(mhi_cntrl->ee))\n\t\tgoto fw_load_ready_state;\n\n\tfw_name = (mhi_cntrl->ee == MHI_EE_EDL) ?\n\t\tmhi_cntrl->edl_image : mhi_cntrl->fw_image;\n\n\t \n\tif (!fw_name && mhi_cntrl->fbc_download &&\n\t    mhi_cntrl->fw_data && mhi_cntrl->fw_sz) {\n\t\tif (!mhi_cntrl->sbl_size) {\n\t\t\tdev_err(dev, \"fw_data provided but no sbl_size\\n\");\n\t\t\tgoto error_fw_load;\n\t\t}\n\n\t\tsize = mhi_cntrl->sbl_size;\n\t\tfw_data = mhi_cntrl->fw_data;\n\t\tfw_sz = mhi_cntrl->fw_sz;\n\t\tgoto skip_req_fw;\n\t}\n\n\tif (!fw_name || (mhi_cntrl->fbc_download && (!mhi_cntrl->sbl_size ||\n\t\t\t\t\t\t     !mhi_cntrl->seg_len))) {\n\t\tdev_err(dev,\n\t\t\t\"No firmware image defined or !sbl_size || !seg_len\\n\");\n\t\tgoto error_fw_load;\n\t}\n\n\tret = request_firmware(&firmware, fw_name, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Error loading firmware: %d\\n\", ret);\n\t\tgoto error_fw_load;\n\t}\n\n\tsize = (mhi_cntrl->fbc_download) ? mhi_cntrl->sbl_size : firmware->size;\n\n\t \n\tif (size > firmware->size)\n\t\tsize = firmware->size;\n\n\tfw_data = firmware->data;\n\tfw_sz = firmware->size;\n\nskip_req_fw:\n\tbuf = dma_alloc_coherent(mhi_cntrl->cntrl_dev, size, &dma_addr,\n\t\t\t\t GFP_KERNEL);\n\tif (!buf) {\n\t\trelease_firmware(firmware);\n\t\tgoto error_fw_load;\n\t}\n\n\t \n\tmemcpy(buf, fw_data, size);\n\tret = mhi_fw_load_bhi(mhi_cntrl, dma_addr, size);\n\tdma_free_coherent(mhi_cntrl->cntrl_dev, size, buf, dma_addr);\n\n\t \n\tif (ret) {\n\t\tdev_err(dev, \"MHI did not load image over BHI, ret: %d\\n\", ret);\n\t\trelease_firmware(firmware);\n\t\tgoto error_fw_load;\n\t}\n\n\t \n\tif (fw_name && fw_name == mhi_cntrl->edl_image) {\n\t\trelease_firmware(firmware);\n\t\tgoto fw_load_ready_state;\n\t}\n\n\twrite_lock_irq(&mhi_cntrl->pm_lock);\n\tmhi_cntrl->dev_state = MHI_STATE_RESET;\n\twrite_unlock_irq(&mhi_cntrl->pm_lock);\n\n\t \n\tif (mhi_cntrl->fbc_download) {\n\t\tret = mhi_alloc_bhie_table(mhi_cntrl, &mhi_cntrl->fbc_image, fw_sz);\n\t\tif (ret) {\n\t\t\trelease_firmware(firmware);\n\t\t\tgoto error_fw_load;\n\t\t}\n\n\t\t \n\t\tmhi_firmware_copy(mhi_cntrl, fw_data, fw_sz, mhi_cntrl->fbc_image);\n\t}\n\n\trelease_firmware(firmware);\n\nfw_load_ready_state:\n\t \n\tret = mhi_ready_state_transition(mhi_cntrl);\n\tif (ret) {\n\t\tdev_err(dev, \"MHI did not enter READY state\\n\");\n\t\tgoto error_ready_state;\n\t}\n\n\tdev_info(dev, \"Wait for device to enter SBL or Mission mode\\n\");\n\treturn;\n\nerror_ready_state:\n\tif (mhi_cntrl->fbc_download) {\n\t\tmhi_free_bhie_table(mhi_cntrl, mhi_cntrl->fbc_image);\n\t\tmhi_cntrl->fbc_image = NULL;\n\t}\n\nerror_fw_load:\n\twrite_lock_irq(&mhi_cntrl->pm_lock);\n\tnew_state = mhi_tryset_pm_state(mhi_cntrl, MHI_PM_FW_DL_ERR);\n\twrite_unlock_irq(&mhi_cntrl->pm_lock);\n\tif (new_state == MHI_PM_FW_DL_ERR)\n\t\twake_up_all(&mhi_cntrl->state_event);\n}\n\nint mhi_download_amss_image(struct mhi_controller *mhi_cntrl)\n{\n\tstruct image_info *image_info = mhi_cntrl->fbc_image;\n\tstruct device *dev = &mhi_cntrl->mhi_dev->dev;\n\tenum mhi_pm_state new_state;\n\tint ret;\n\n\tif (!image_info)\n\t\treturn -EIO;\n\n\tret = mhi_fw_load_bhie(mhi_cntrl,\n\t\t\t        \n\t\t\t       &image_info->mhi_buf[image_info->entries - 1]);\n\tif (ret) {\n\t\tdev_err(dev, \"MHI did not load AMSS, ret:%d\\n\", ret);\n\t\twrite_lock_irq(&mhi_cntrl->pm_lock);\n\t\tnew_state = mhi_tryset_pm_state(mhi_cntrl, MHI_PM_FW_DL_ERR);\n\t\twrite_unlock_irq(&mhi_cntrl->pm_lock);\n\t\tif (new_state == MHI_PM_FW_DL_ERR)\n\t\t\twake_up_all(&mhi_cntrl->state_event);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}