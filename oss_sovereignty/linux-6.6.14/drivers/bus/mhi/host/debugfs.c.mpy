{
  "module_name": "debugfs.c",
  "hash_id": "95f2a61a66f9bbb0b464a8240bd1882a23954f1e498a7a503fa05723cf98d523",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/host/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/mhi.h>\n#include <linux/module.h>\n#include \"internal.h\"\n\nstatic int mhi_debugfs_states_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\n\t \n\tseq_printf(m, \"PM state: %s Device: %s MHI state: %s EE: %s wake: %s\\n\",\n\t\t   to_mhi_pm_state_str(mhi_cntrl->pm_state),\n\t\t   mhi_is_active(mhi_cntrl) ? \"Active\" : \"Inactive\",\n\t\t   mhi_state_str(mhi_cntrl->dev_state),\n\t\t   TO_MHI_EXEC_STR(mhi_cntrl->ee),\n\t\t   mhi_cntrl->wake_set ? \"true\" : \"false\");\n\n\t \n\tseq_printf(m, \"M0: %u M2: %u M3: %u\", mhi_cntrl->M0, mhi_cntrl->M2,\n\t\t   mhi_cntrl->M3);\n\n\tseq_printf(m, \" device wake: %u pending packets: %u\\n\",\n\t\t   atomic_read(&mhi_cntrl->dev_wake),\n\t\t   atomic_read(&mhi_cntrl->pending_pkts));\n\n\treturn 0;\n}\n\nstatic int mhi_debugfs_events_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tstruct mhi_event *mhi_event;\n\tstruct mhi_event_ctxt *er_ctxt;\n\tint i;\n\n\tif (!mhi_is_active(mhi_cntrl)) {\n\t\tseq_puts(m, \"Device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ter_ctxt = mhi_cntrl->mhi_ctxt->er_ctxt;\n\tmhi_event = mhi_cntrl->mhi_event;\n\tfor (i = 0; i < mhi_cntrl->total_ev_rings;\n\t\t\t\t\t\ti++, er_ctxt++, mhi_event++) {\n\t\tstruct mhi_ring *ring = &mhi_event->ring;\n\n\t\tif (mhi_event->offload_ev) {\n\t\t\tseq_printf(m, \"Index: %d is an offload event ring\\n\",\n\t\t\t\t   i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"Index: %d intmod count: %lu time: %lu\",\n\t\t\t   i, (le32_to_cpu(er_ctxt->intmod) & EV_CTX_INTMODC_MASK) >>\n\t\t\t   __ffs(EV_CTX_INTMODC_MASK),\n\t\t\t   (le32_to_cpu(er_ctxt->intmod) & EV_CTX_INTMODT_MASK) >>\n\t\t\t   __ffs(EV_CTX_INTMODT_MASK));\n\n\t\tseq_printf(m, \" base: 0x%0llx len: 0x%llx\", le64_to_cpu(er_ctxt->rbase),\n\t\t\t   le64_to_cpu(er_ctxt->rlen));\n\n\t\tseq_printf(m, \" rp: 0x%llx wp: 0x%llx\", le64_to_cpu(er_ctxt->rp),\n\t\t\t   le64_to_cpu(er_ctxt->wp));\n\n\t\tseq_printf(m, \" local rp: 0x%pK db: 0x%pad\\n\", ring->rp,\n\t\t\t   &mhi_event->db_cfg.db_val);\n\t}\n\n\treturn 0;\n}\n\nstatic int mhi_debugfs_channels_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tstruct mhi_chan *mhi_chan;\n\tstruct mhi_chan_ctxt *chan_ctxt;\n\tint i;\n\n\tif (!mhi_is_active(mhi_cntrl)) {\n\t\tseq_puts(m, \"Device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmhi_chan = mhi_cntrl->mhi_chan;\n\tchan_ctxt = mhi_cntrl->mhi_ctxt->chan_ctxt;\n\tfor (i = 0; i < mhi_cntrl->max_chan; i++, chan_ctxt++, mhi_chan++) {\n\t\tstruct mhi_ring *ring = &mhi_chan->tre_ring;\n\n\t\tif (mhi_chan->offload_ch) {\n\t\t\tseq_printf(m, \"%s(%u) is an offload channel\\n\",\n\t\t\t\t   mhi_chan->name, mhi_chan->chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mhi_chan->mhi_dev)\n\t\t\tcontinue;\n\n\t\tseq_printf(m,\n\t\t\t   \"%s(%u) state: 0x%lx brstmode: 0x%lx pollcfg: 0x%lx\",\n\t\t\t   mhi_chan->name, mhi_chan->chan, (le32_to_cpu(chan_ctxt->chcfg) &\n\t\t\t   CHAN_CTX_CHSTATE_MASK) >> __ffs(CHAN_CTX_CHSTATE_MASK),\n\t\t\t   (le32_to_cpu(chan_ctxt->chcfg) & CHAN_CTX_BRSTMODE_MASK) >>\n\t\t\t   __ffs(CHAN_CTX_BRSTMODE_MASK), (le32_to_cpu(chan_ctxt->chcfg) &\n\t\t\t   CHAN_CTX_POLLCFG_MASK) >> __ffs(CHAN_CTX_POLLCFG_MASK));\n\n\t\tseq_printf(m, \" type: 0x%x event ring: %u\", le32_to_cpu(chan_ctxt->chtype),\n\t\t\t   le32_to_cpu(chan_ctxt->erindex));\n\n\t\tseq_printf(m, \" base: 0x%llx len: 0x%llx rp: 0x%llx wp: 0x%llx\",\n\t\t\t   le64_to_cpu(chan_ctxt->rbase), le64_to_cpu(chan_ctxt->rlen),\n\t\t\t   le64_to_cpu(chan_ctxt->rp), le64_to_cpu(chan_ctxt->wp));\n\n\t\tseq_printf(m, \" local rp: 0x%pK local wp: 0x%pK db: 0x%pad\\n\",\n\t\t\t   ring->rp, ring->wp,\n\t\t\t   &mhi_chan->db_cfg.db_val);\n\t}\n\n\treturn 0;\n}\n\nstatic int mhi_device_info_show(struct device *dev, void *data)\n{\n\tstruct mhi_device *mhi_dev;\n\n\tif (dev->bus != &mhi_bus_type)\n\t\treturn 0;\n\n\tmhi_dev = to_mhi_device(dev);\n\n\tseq_printf((struct seq_file *)data, \"%s: type: %s dev_wake: %u\",\n\t\t   mhi_dev->name, mhi_dev->dev_type ? \"Controller\" : \"Transfer\",\n\t\t   mhi_dev->dev_wake);\n\n\t \n\tif (mhi_dev->dev_type == MHI_DEVICE_XFER)\n\t\tseq_printf((struct seq_file *)data, \" channels: %u(UL)/%u(DL)\",\n\t\t\t   mhi_dev->ul_chan_id, mhi_dev->dl_chan_id);\n\n\tseq_puts((struct seq_file *)data, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int mhi_debugfs_devices_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\n\tif (!mhi_is_active(mhi_cntrl)) {\n\t\tseq_puts(m, \"Device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmhi_device_info_show(&mhi_cntrl->mhi_dev->dev, m);\n\tdevice_for_each_child(&mhi_cntrl->mhi_dev->dev, m, mhi_device_info_show);\n\n\treturn 0;\n}\n\nstatic int mhi_debugfs_regdump_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tenum mhi_state state;\n\tenum mhi_ee_type ee;\n\tint i, ret = -EIO;\n\tu32 val;\n\tvoid __iomem *mhi_base = mhi_cntrl->regs;\n\tvoid __iomem *bhi_base = mhi_cntrl->bhi;\n\tvoid __iomem *bhie_base = mhi_cntrl->bhie;\n\tvoid __iomem *wake_db = mhi_cntrl->wake_db;\n\tstruct {\n\t\tconst char *name;\n\t\tint offset;\n\t\tvoid __iomem *base;\n\t} regs[] = {\n\t\t{ \"MHI_REGLEN\", MHIREGLEN, mhi_base},\n\t\t{ \"MHI_VER\", MHIVER, mhi_base},\n\t\t{ \"MHI_CFG\", MHICFG, mhi_base},\n\t\t{ \"MHI_CTRL\", MHICTRL, mhi_base},\n\t\t{ \"MHI_STATUS\", MHISTATUS, mhi_base},\n\t\t{ \"MHI_WAKE_DB\", 0, wake_db},\n\t\t{ \"BHI_EXECENV\", BHI_EXECENV, bhi_base},\n\t\t{ \"BHI_STATUS\", BHI_STATUS, bhi_base},\n\t\t{ \"BHI_ERRCODE\", BHI_ERRCODE, bhi_base},\n\t\t{ \"BHI_ERRDBG1\", BHI_ERRDBG1, bhi_base},\n\t\t{ \"BHI_ERRDBG2\", BHI_ERRDBG2, bhi_base},\n\t\t{ \"BHI_ERRDBG3\", BHI_ERRDBG3, bhi_base},\n\t\t{ \"BHIE_TXVEC_DB\", BHIE_TXVECDB_OFFS, bhie_base},\n\t\t{ \"BHIE_TXVEC_STATUS\", BHIE_TXVECSTATUS_OFFS, bhie_base},\n\t\t{ \"BHIE_RXVEC_DB\", BHIE_RXVECDB_OFFS, bhie_base},\n\t\t{ \"BHIE_RXVEC_STATUS\", BHIE_RXVECSTATUS_OFFS, bhie_base},\n\t\t{ NULL },\n\t};\n\n\tif (!MHI_REG_ACCESS_VALID(mhi_cntrl->pm_state))\n\t\treturn ret;\n\n\tseq_printf(m, \"Host PM state: %s Device state: %s EE: %s\\n\",\n\t\t   to_mhi_pm_state_str(mhi_cntrl->pm_state),\n\t\t   mhi_state_str(mhi_cntrl->dev_state),\n\t\t   TO_MHI_EXEC_STR(mhi_cntrl->ee));\n\n\tstate = mhi_get_mhi_state(mhi_cntrl);\n\tee = mhi_get_exec_env(mhi_cntrl);\n\tseq_printf(m, \"Device EE: %s state: %s\\n\", TO_MHI_EXEC_STR(ee),\n\t\t   mhi_state_str(state));\n\n\tfor (i = 0; regs[i].name; i++) {\n\t\tif (!regs[i].base)\n\t\t\tcontinue;\n\t\tret = mhi_read_reg(mhi_cntrl, regs[i].base, regs[i].offset,\n\t\t\t\t   &val);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%s: 0x%x\\n\", regs[i].name, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int mhi_debugfs_device_wake_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tstruct mhi_device *mhi_dev = mhi_cntrl->mhi_dev;\n\n\tif (!mhi_is_active(mhi_cntrl)) {\n\t\tseq_puts(m, \"Device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tseq_printf(m,\n\t\t   \"Wake count: %d\\n%s\\n\", mhi_dev->dev_wake,\n\t\t   \"Usage: echo get/put > device_wake to vote/unvote for M0\");\n\n\treturn 0;\n}\n\nstatic ssize_t mhi_debugfs_device_wake_write(struct file *file,\n\t\t\t\t\t     const char __user *ubuf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct seq_file\t*m = file->private_data;\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tstruct mhi_device *mhi_dev = mhi_cntrl->mhi_dev;\n\tchar buf[16];\n\tint ret = -EINVAL;\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"get\", 3)) {\n\t\tret = mhi_device_get_sync(mhi_dev);\n\t} else if (!strncmp(buf, \"put\", 3)) {\n\t\tmhi_device_put(mhi_dev);\n\t\tret = 0;\n\t}\n\n\treturn ret ? ret : count;\n}\n\nstatic int mhi_debugfs_timeout_ms_show(struct seq_file *m, void *d)\n{\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\n\tseq_printf(m, \"%u ms\\n\", mhi_cntrl->timeout_ms);\n\n\treturn 0;\n}\n\nstatic ssize_t mhi_debugfs_timeout_ms_write(struct file *file,\n\t\t\t\t\t    const char __user *ubuf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct seq_file\t*m = file->private_data;\n\tstruct mhi_controller *mhi_cntrl = m->private;\n\tu32 timeout_ms;\n\n\tif (kstrtou32_from_user(ubuf, count, 0, &timeout_ms))\n\t\treturn -EINVAL;\n\n\tmhi_cntrl->timeout_ms = timeout_ms;\n\n\treturn count;\n}\n\nstatic int mhi_debugfs_states_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_states_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_events_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_events_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_channels_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_channels_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_devices_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_devices_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_regdump_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_regdump_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_device_wake_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_device_wake_show, inode->i_private);\n}\n\nstatic int mhi_debugfs_timeout_ms_open(struct inode *inode, struct file *fp)\n{\n\treturn single_open(fp, mhi_debugfs_timeout_ms_show, inode->i_private);\n}\n\nstatic const struct file_operations debugfs_states_fops = {\n\t.open = mhi_debugfs_states_open,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_events_fops = {\n\t.open = mhi_debugfs_events_open,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_channels_fops = {\n\t.open = mhi_debugfs_channels_open,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_devices_fops = {\n\t.open = mhi_debugfs_devices_open,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_regdump_fops = {\n\t.open = mhi_debugfs_regdump_open,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_device_wake_fops = {\n\t.open = mhi_debugfs_device_wake_open,\n\t.write = mhi_debugfs_device_wake_write,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic const struct file_operations debugfs_timeout_ms_fops = {\n\t.open = mhi_debugfs_timeout_ms_open,\n\t.write = mhi_debugfs_timeout_ms_write,\n\t.release = single_release,\n\t.read = seq_read,\n};\n\nstatic struct dentry *mhi_debugfs_root;\n\nvoid mhi_create_debugfs(struct mhi_controller *mhi_cntrl)\n{\n\tmhi_cntrl->debugfs_dentry =\n\t\t\tdebugfs_create_dir(dev_name(&mhi_cntrl->mhi_dev->dev),\n\t\t\t\t\t   mhi_debugfs_root);\n\n\tdebugfs_create_file(\"states\", 0444, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_states_fops);\n\tdebugfs_create_file(\"events\", 0444, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_events_fops);\n\tdebugfs_create_file(\"channels\", 0444, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_channels_fops);\n\tdebugfs_create_file(\"devices\", 0444, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_devices_fops);\n\tdebugfs_create_file(\"regdump\", 0444, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_regdump_fops);\n\tdebugfs_create_file(\"device_wake\", 0644, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_device_wake_fops);\n\tdebugfs_create_file(\"timeout_ms\", 0644, mhi_cntrl->debugfs_dentry,\n\t\t\t    mhi_cntrl, &debugfs_timeout_ms_fops);\n}\n\nvoid mhi_destroy_debugfs(struct mhi_controller *mhi_cntrl)\n{\n\tdebugfs_remove_recursive(mhi_cntrl->debugfs_dentry);\n\tmhi_cntrl->debugfs_dentry = NULL;\n}\n\nvoid mhi_debugfs_init(void)\n{\n\tmhi_debugfs_root = debugfs_create_dir(mhi_bus_type.name, NULL);\n}\n\nvoid mhi_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(mhi_debugfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}