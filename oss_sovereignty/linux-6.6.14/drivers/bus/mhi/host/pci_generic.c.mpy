{
  "module_name": "pci_generic.c",
  "hash_id": "ca0fe42d4b48c831c36f209aac464756a463de8438672f58ad11ed12ccc0a7e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/mhi/host/pci_generic.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mhi.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#define MHI_PCI_DEFAULT_BAR_NUM 0\n\n#define MHI_POST_RESET_DELAY_MS 2000\n\n#define HEALTH_CHECK_PERIOD (HZ * 2)\n\n \n#define PCI_VENDOR_ID_THALES\t0x1269\n#define PCI_VENDOR_ID_QUECTEL\t0x1eac\n\n \nstruct mhi_pci_dev_info {\n\tconst struct mhi_controller_config *config;\n\tconst char *name;\n\tconst char *fw;\n\tconst char *edl;\n\tunsigned int bar_num;\n\tunsigned int dma_data_width;\n\tunsigned int mru_default;\n\tbool sideband_wake;\n};\n\n#define MHI_CHANNEL_CONFIG_UL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_TO_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_AMSS),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\t\t\t\t\t\t\\\n\n#define MHI_CHANNEL_CONFIG_DL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_FROM_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_AMSS),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\n\n#define MHI_CHANNEL_CONFIG_DL_AUTOQUEUE(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_FROM_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_AMSS),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t\t.auto_queue = true,\t\t\t\\\n\t}\n\n#define MHI_EVENT_CONFIG_CTRL(ev_ring, el_count) \\\n\t{\t\t\t\t\t\\\n\t\t.num_elements = el_count,\t\\\n\t\t.irq_moderation_ms = 0,\t\t\\\n\t\t.irq = (ev_ring) + 1,\t\t\\\n\t\t.priority = 1,\t\t\t\\\n\t\t.mode = MHI_DB_BRST_DISABLE,\t\\\n\t\t.data_type = MHI_ER_CTRL,\t\\\n\t\t.hardware_event = false,\t\\\n\t\t.client_managed = false,\t\\\n\t\t.offload_channel = false,\t\\\n\t}\n\n#define MHI_CHANNEL_CONFIG_HW_UL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_TO_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_AMSS),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_ENABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = true,\t\t\\\n\t}\t\t\t\t\t\t\\\n\n#define MHI_CHANNEL_CONFIG_HW_DL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_FROM_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_AMSS),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_ENABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = true,\t\t\\\n\t}\n\n#define MHI_CHANNEL_CONFIG_UL_SBL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_TO_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_SBL),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\t\t\t\t\t\t\\\n\n#define MHI_CHANNEL_CONFIG_DL_SBL(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_FROM_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_SBL),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\n\n#define MHI_CHANNEL_CONFIG_UL_FP(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_TO_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_FP),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\t\t\t\t\t\t\\\n\n#define MHI_CHANNEL_CONFIG_DL_FP(ch_num, ch_name, el_count, ev_ring) \\\n\t{\t\t\t\t\t\t\\\n\t\t.num = ch_num,\t\t\t\t\\\n\t\t.name = ch_name,\t\t\t\\\n\t\t.num_elements = el_count,\t\t\\\n\t\t.event_ring = ev_ring,\t\t\t\\\n\t\t.dir = DMA_FROM_DEVICE,\t\t\t\\\n\t\t.ee_mask = BIT(MHI_EE_FP),\t\t\\\n\t\t.pollcfg = 0,\t\t\t\t\\\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\t\\\n\t\t.lpm_notify = false,\t\t\t\\\n\t\t.offload_channel = false,\t\t\\\n\t\t.doorbell_mode_switch = false,\t\t\\\n\t}\n\n#define MHI_EVENT_CONFIG_DATA(ev_ring, el_count) \\\n\t{\t\t\t\t\t\\\n\t\t.num_elements = el_count,\t\\\n\t\t.irq_moderation_ms = 5,\t\t\\\n\t\t.irq = (ev_ring) + 1,\t\t\\\n\t\t.priority = 1,\t\t\t\\\n\t\t.mode = MHI_DB_BRST_DISABLE,\t\\\n\t\t.data_type = MHI_ER_DATA,\t\\\n\t\t.hardware_event = false,\t\\\n\t\t.client_managed = false,\t\\\n\t\t.offload_channel = false,\t\\\n\t}\n\n#define MHI_EVENT_CONFIG_SW_DATA(ev_ring, el_count) \\\n\t{\t\t\t\t\t\\\n\t\t.num_elements = el_count,\t\\\n\t\t.irq_moderation_ms = 0,\t\t\\\n\t\t.irq = (ev_ring) + 1,\t\t\\\n\t\t.priority = 1,\t\t\t\\\n\t\t.mode = MHI_DB_BRST_DISABLE,\t\\\n\t\t.data_type = MHI_ER_DATA,\t\\\n\t\t.hardware_event = false,\t\\\n\t\t.client_managed = false,\t\\\n\t\t.offload_channel = false,\t\\\n\t}\n\n#define MHI_EVENT_CONFIG_HW_DATA(ev_ring, el_count, ch_num) \\\n\t{\t\t\t\t\t\\\n\t\t.num_elements = el_count,\t\\\n\t\t.irq_moderation_ms = 1,\t\t\\\n\t\t.irq = (ev_ring) + 1,\t\t\\\n\t\t.priority = 1,\t\t\t\\\n\t\t.mode = MHI_DB_BRST_DISABLE,\t\\\n\t\t.data_type = MHI_ER_DATA,\t\\\n\t\t.hardware_event = true,\t\t\\\n\t\t.client_managed = false,\t\\\n\t\t.offload_channel = false,\t\\\n\t\t.channel = ch_num,\t\t\\\n\t}\n\nstatic const struct mhi_channel_config modem_qcom_v1_mhi_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL(4, \"DIAG\", 16, 1),\n\tMHI_CHANNEL_CONFIG_DL(5, \"DIAG\", 16, 1),\n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 4, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 4, 0),\n\tMHI_CHANNEL_CONFIG_UL(14, \"QMI\", 4, 0),\n\tMHI_CHANNEL_CONFIG_DL(15, \"QMI\", 4, 0),\n\tMHI_CHANNEL_CONFIG_UL(20, \"IPCR\", 8, 0),\n\tMHI_CHANNEL_CONFIG_DL_AUTOQUEUE(21, \"IPCR\", 8, 0),\n\tMHI_CHANNEL_CONFIG_UL_FP(34, \"FIREHOSE\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL_FP(35, \"FIREHOSE\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(46, \"IP_SW0\", 64, 2),\n\tMHI_CHANNEL_CONFIG_DL(47, \"IP_SW0\", 64, 3),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0\", 128, 4),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0\", 128, 5),\n};\n\nstatic struct mhi_event_config modem_qcom_v1_mhi_events[] = {\n\t \n\tMHI_EVENT_CONFIG_CTRL(0, 64),\n\t \n\tMHI_EVENT_CONFIG_DATA(1, 128),\n\t \n\tMHI_EVENT_CONFIG_SW_DATA(2, 64),\n\tMHI_EVENT_CONFIG_SW_DATA(3, 64),\n\t \n\tMHI_EVENT_CONFIG_HW_DATA(4, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(5, 2048, 101)\n};\n\nstatic const struct mhi_controller_config modem_qcom_v1_mhiv_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 8000,\n\t.num_channels = ARRAY_SIZE(modem_qcom_v1_mhi_channels),\n\t.ch_cfg = modem_qcom_v1_mhi_channels,\n\t.num_events = ARRAY_SIZE(modem_qcom_v1_mhi_events),\n\t.event_cfg = modem_qcom_v1_mhi_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_qcom_sdx65_info = {\n\t.name = \"qcom-sdx65m\",\n\t.fw = \"qcom/sdx65m/xbl.elf\",\n\t.edl = \"qcom/sdx65m/edl.mbn\",\n\t.config = &modem_qcom_v1_mhiv_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_pci_dev_info mhi_qcom_sdx55_info = {\n\t.name = \"qcom-sdx55m\",\n\t.fw = \"qcom/sdx55m/sbl1.mbn\",\n\t.edl = \"qcom/sdx55m/edl.mbn\",\n\t.config = &modem_qcom_v1_mhiv_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_pci_dev_info mhi_qcom_sdx24_info = {\n\t.name = \"qcom-sdx24\",\n\t.edl = \"qcom/prog_firehose_sdx24.mbn\",\n\t.config = &modem_qcom_v1_mhiv_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.sideband_wake = true,\n};\n\nstatic const struct mhi_channel_config mhi_quectel_em1xx_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL(0, \"NMEA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(1, \"NMEA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL_SBL(2, \"SAHARA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL_SBL(3, \"SAHARA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(4, \"DIAG\", 32, 1),\n\tMHI_CHANNEL_CONFIG_DL(5, \"DIAG\", 32, 1),\n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(32, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(33, \"DUN\", 32, 0),\n\t \n\tMHI_CHANNEL_CONFIG_UL_FP(34, \"FIREHOSE\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL_FP(35, \"FIREHOSE\", 32, 0),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0_MBIM\", 128, 2),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0_MBIM\", 128, 3),\n};\n\nstatic struct mhi_event_config mhi_quectel_em1xx_events[] = {\n\tMHI_EVENT_CONFIG_CTRL(0, 128),\n\tMHI_EVENT_CONFIG_DATA(1, 128),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(3, 1024, 101)\n};\n\nstatic const struct mhi_controller_config modem_quectel_em1xx_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 20000,\n\t.num_channels = ARRAY_SIZE(mhi_quectel_em1xx_channels),\n\t.ch_cfg = mhi_quectel_em1xx_channels,\n\t.num_events = ARRAY_SIZE(mhi_quectel_em1xx_events),\n\t.event_cfg = mhi_quectel_em1xx_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_quectel_em1xx_info = {\n\t.name = \"quectel-em1xx\",\n\t.edl = \"qcom/prog_firehose_sdx24.mbn\",\n\t.config = &modem_quectel_em1xx_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = true,\n};\n\nstatic const struct mhi_pci_dev_info mhi_quectel_rm5xx_info = {\n\t.name = \"quectel-rm5xx\",\n\t.edl = \"qcom/prog_firehose_sdx6x.elf\",\n\t.config = &modem_quectel_em1xx_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = true,\n};\n\nstatic const struct mhi_channel_config mhi_foxconn_sdx55_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL(0, \"LOOPBACK\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(1, \"LOOPBACK\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(4, \"DIAG\", 32, 1),\n\tMHI_CHANNEL_CONFIG_DL(5, \"DIAG\", 32, 1),\n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(32, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(33, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0_MBIM\", 128, 2),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0_MBIM\", 128, 3),\n};\n\nstatic struct mhi_event_config mhi_foxconn_sdx55_events[] = {\n\tMHI_EVENT_CONFIG_CTRL(0, 128),\n\tMHI_EVENT_CONFIG_DATA(1, 128),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(3, 1024, 101)\n};\n\nstatic const struct mhi_controller_config modem_foxconn_sdx55_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 20000,\n\t.num_channels = ARRAY_SIZE(mhi_foxconn_sdx55_channels),\n\t.ch_cfg = mhi_foxconn_sdx55_channels,\n\t.num_events = ARRAY_SIZE(mhi_foxconn_sdx55_events),\n\t.event_cfg = mhi_foxconn_sdx55_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_foxconn_sdx24_info = {\n\t.name = \"foxconn-sdx24\",\n\t.config = &modem_foxconn_sdx55_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_pci_dev_info mhi_foxconn_sdx55_info = {\n\t.name = \"foxconn-sdx55\",\n\t.fw = \"qcom/sdx55m/sbl1.mbn\",\n\t.edl = \"qcom/sdx55m/edl.mbn\",\n\t.config = &modem_foxconn_sdx55_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_pci_dev_info mhi_foxconn_sdx65_info = {\n\t.name = \"foxconn-sdx65\",\n\t.config = &modem_foxconn_sdx55_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_channel_config mhi_mv3x_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL(0, \"LOOPBACK\", 64, 0),\n\tMHI_CHANNEL_CONFIG_DL(1, \"LOOPBACK\", 64, 0),\n\t \n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 64, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 64, 0),\n\t \n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0_MBIM\", 512, 2),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0_MBIM\", 512, 3),\n};\n\nstatic struct mhi_event_config mhi_mv3x_events[] = {\n\tMHI_EVENT_CONFIG_CTRL(0, 256),\n\tMHI_EVENT_CONFIG_DATA(1, 256),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(3, 1024, 101),\n};\n\nstatic const struct mhi_controller_config modem_mv3x_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 20000,\n\t.num_channels = ARRAY_SIZE(mhi_mv3x_channels),\n\t.ch_cfg = mhi_mv3x_channels,\n\t.num_events = ARRAY_SIZE(mhi_mv3x_events),\n\t.event_cfg = mhi_mv3x_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_mv31_info = {\n\t.name = \"cinterion-mv31\",\n\t.config = &modem_mv3x_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n};\n\nstatic const struct mhi_pci_dev_info mhi_mv32_info = {\n\t.name = \"cinterion-mv32\",\n\t.config = &modem_mv3x_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n};\n\nstatic const struct mhi_channel_config mhi_sierra_em919x_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL_SBL(2, \"SAHARA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL_SBL(3, \"SAHARA\", 256, 0),\n\tMHI_CHANNEL_CONFIG_UL(4, \"DIAG\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(5, \"DIAG\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 128, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 128, 0),\n\tMHI_CHANNEL_CONFIG_UL(14, \"QMI\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(15, \"QMI\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(32, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(33, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0\", 512, 1),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0\", 512, 2),\n};\n\nstatic struct mhi_event_config modem_sierra_em919x_mhi_events[] = {\n\t \n\tMHI_EVENT_CONFIG_CTRL(0, 2048),\n\t \n\tMHI_EVENT_CONFIG_HW_DATA(1, 2048, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 2048, 101)\n};\n\nstatic const struct mhi_controller_config modem_sierra_em919x_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 24000,\n\t.num_channels = ARRAY_SIZE(mhi_sierra_em919x_channels),\n\t.ch_cfg = mhi_sierra_em919x_channels,\n\t.num_events = ARRAY_SIZE(modem_sierra_em919x_mhi_events),\n\t.event_cfg = modem_sierra_em919x_mhi_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_sierra_em919x_info = {\n\t.name = \"sierra-em919x\",\n\t.config = &modem_sierra_em919x_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_channel_config mhi_telit_fn980_hw_v1_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL(14, \"QMI\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(15, \"QMI\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(20, \"IPCR\", 16, 0),\n\tMHI_CHANNEL_CONFIG_DL_AUTOQUEUE(21, \"IPCR\", 16, 0),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0\", 128, 1),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0\", 128, 2),\n};\n\nstatic struct mhi_event_config mhi_telit_fn980_hw_v1_events[] = {\n\tMHI_EVENT_CONFIG_CTRL(0, 128),\n\tMHI_EVENT_CONFIG_HW_DATA(1, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 2048, 101)\n};\n\nstatic struct mhi_controller_config modem_telit_fn980_hw_v1_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 20000,\n\t.num_channels = ARRAY_SIZE(mhi_telit_fn980_hw_v1_channels),\n\t.ch_cfg = mhi_telit_fn980_hw_v1_channels,\n\t.num_events = ARRAY_SIZE(mhi_telit_fn980_hw_v1_events),\n\t.event_cfg = mhi_telit_fn980_hw_v1_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_telit_fn980_hw_v1_info = {\n\t.name = \"telit-fn980-hwv1\",\n\t.fw = \"qcom/sdx55m/sbl1.mbn\",\n\t.edl = \"qcom/sdx55m/edl.mbn\",\n\t.config = &modem_telit_fn980_hw_v1_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.mru_default = 32768,\n\t.sideband_wake = false,\n};\n\nstatic const struct mhi_channel_config mhi_telit_fn990_channels[] = {\n\tMHI_CHANNEL_CONFIG_UL_SBL(2, \"SAHARA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL_SBL(3, \"SAHARA\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(4, \"DIAG\", 64, 1),\n\tMHI_CHANNEL_CONFIG_DL(5, \"DIAG\", 64, 1),\n\tMHI_CHANNEL_CONFIG_UL(12, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(13, \"MBIM\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(32, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_DL(33, \"DUN\", 32, 0),\n\tMHI_CHANNEL_CONFIG_UL(92, \"DUN2\", 32, 1),\n\tMHI_CHANNEL_CONFIG_DL(93, \"DUN2\", 32, 1),\n\tMHI_CHANNEL_CONFIG_HW_UL(100, \"IP_HW0_MBIM\", 128, 2),\n\tMHI_CHANNEL_CONFIG_HW_DL(101, \"IP_HW0_MBIM\", 128, 3),\n};\n\nstatic struct mhi_event_config mhi_telit_fn990_events[] = {\n\tMHI_EVENT_CONFIG_CTRL(0, 128),\n\tMHI_EVENT_CONFIG_DATA(1, 128),\n\tMHI_EVENT_CONFIG_HW_DATA(2, 1024, 100),\n\tMHI_EVENT_CONFIG_HW_DATA(3, 2048, 101)\n};\n\nstatic const struct mhi_controller_config modem_telit_fn990_config = {\n\t.max_channels = 128,\n\t.timeout_ms = 20000,\n\t.num_channels = ARRAY_SIZE(mhi_telit_fn990_channels),\n\t.ch_cfg = mhi_telit_fn990_channels,\n\t.num_events = ARRAY_SIZE(mhi_telit_fn990_events),\n\t.event_cfg = mhi_telit_fn990_events,\n};\n\nstatic const struct mhi_pci_dev_info mhi_telit_fn990_info = {\n\t.name = \"telit-fn990\",\n\t.config = &modem_telit_fn990_config,\n\t.bar_num = MHI_PCI_DEFAULT_BAR_NUM,\n\t.dma_data_width = 32,\n\t.sideband_wake = false,\n\t.mru_default = 32768,\n};\n\n \nstatic const struct pci_device_id mhi_pci_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QCOM, 0x0304),\n\t\t.driver_data = (kernel_ulong_t) &mhi_qcom_sdx24_info },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0306, PCI_VENDOR_ID_QCOM, 0x010c),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0306, 0x18d7, 0x0200),\n\t\t.driver_data = (kernel_ulong_t) &mhi_sierra_em919x_info },\n\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0306, 0x1C5D, 0x2000),\n\t\t.driver_data = (kernel_ulong_t) &mhi_telit_fn980_hw_v1_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QCOM, 0x0306),\n\t\t.driver_data = (kernel_ulong_t) &mhi_qcom_sdx55_info },\n\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0308, 0x1c5d, 0x2010),\n\t\t.driver_data = (kernel_ulong_t) &mhi_telit_fn990_info },\n\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0308, 0x1c5d, 0x2015),\n\t\t.driver_data = (kernel_ulong_t) &mhi_telit_fn990_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QCOM, 0x0308),\n\t\t.driver_data = (kernel_ulong_t) &mhi_qcom_sdx65_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x1001),  \n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_em1xx_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x1002),  \n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_em1xx_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x1004),\n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_rm5xx_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x1007),\n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_rm5xx_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x100d),  \n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_em1xx_info },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QUECTEL, 0x2001),  \n\t\t.driver_data = (kernel_ulong_t) &mhi_quectel_em1xx_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0ab),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0b0),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0b1),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0bf),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0c3),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0d8),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx65_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0d9),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx65_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0f0),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx24_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0f1),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx24_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0f2),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx24_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0f5),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx65_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_FOXCONN, 0xe0f9),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx65_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_THALES, 0x00b3),\n\t\t.driver_data = (kernel_ulong_t) &mhi_mv31_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_THALES, 0x00b4),\n\t\t.driver_data = (kernel_ulong_t) &mhi_mv31_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_THALES, 0x00ba),\n\t\t.driver_data = (kernel_ulong_t) &mhi_mv32_info },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_THALES, 0x00bb),\n\t\t.driver_data = (kernel_ulong_t) &mhi_mv32_info },\n\t \n\t{ PCI_DEVICE(0x03f0, 0x0a6c),\n\t\t.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },\n\t{  }\n};\nMODULE_DEVICE_TABLE(pci, mhi_pci_id_table);\n\nenum mhi_pci_device_status {\n\tMHI_PCI_DEV_STARTED,\n\tMHI_PCI_DEV_SUSPENDED,\n};\n\nstruct mhi_pci_device {\n\tstruct mhi_controller mhi_cntrl;\n\tstruct pci_saved_state *pci_state;\n\tstruct work_struct recovery_work;\n\tstruct timer_list health_check_timer;\n\tunsigned long status;\n};\n\nstatic int mhi_pci_read_reg(struct mhi_controller *mhi_cntrl,\n\t\t\t    void __iomem *addr, u32 *out)\n{\n\t*out = readl(addr);\n\treturn 0;\n}\n\nstatic void mhi_pci_write_reg(struct mhi_controller *mhi_cntrl,\n\t\t\t      void __iomem *addr, u32 val)\n{\n\twritel(val, addr);\n}\n\nstatic void mhi_pci_status_cb(struct mhi_controller *mhi_cntrl,\n\t\t\t      enum mhi_callback cb)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mhi_cntrl->cntrl_dev);\n\n\t \n\tswitch (cb) {\n\tcase MHI_CB_FATAL_ERROR:\n\tcase MHI_CB_SYS_ERROR:\n\t\tdev_warn(&pdev->dev, \"firmware crashed (%u)\\n\", cb);\n\t\tpm_runtime_forbid(&pdev->dev);\n\t\tbreak;\n\tcase MHI_CB_EE_MISSION_MODE:\n\t\tpm_runtime_allow(&pdev->dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mhi_pci_wake_get_nop(struct mhi_controller *mhi_cntrl, bool force)\n{\n\t \n}\n\nstatic void mhi_pci_wake_put_nop(struct mhi_controller *mhi_cntrl, bool override)\n{\n\t \n}\n\nstatic void mhi_pci_wake_toggle_nop(struct mhi_controller *mhi_cntrl)\n{\n\t \n}\n\nstatic bool mhi_pci_is_alive(struct mhi_controller *mhi_cntrl)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mhi_cntrl->cntrl_dev);\n\tu16 vendor = 0;\n\n\tif (pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor))\n\t\treturn false;\n\n\tif (vendor == (u16) ~0 || vendor == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mhi_pci_claim(struct mhi_controller *mhi_cntrl,\n\t\t\t unsigned int bar_num, u64 dma_mask)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mhi_cntrl->cntrl_dev);\n\tint err;\n\n\terr = pci_assign_resource(pdev, bar_num);\n\tif (err)\n\t\treturn err;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable pci device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = pcim_iomap_regions(pdev, 1 << bar_num, pci_name(pdev));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to map pci region: %d\\n\", err);\n\t\treturn err;\n\t}\n\tmhi_cntrl->regs = pcim_iomap_table(pdev)[bar_num];\n\tmhi_cntrl->reg_len = pci_resource_len(pdev, bar_num);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, dma_mask);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot set proper DMA mask\\n\");\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n}\n\nstatic int mhi_pci_get_irqs(struct mhi_controller *mhi_cntrl,\n\t\t\t    const struct mhi_controller_config *mhi_cntrl_config)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mhi_cntrl->cntrl_dev);\n\tint nr_vectors, i;\n\tint *irq;\n\n\t \n\tmhi_cntrl->nr_irqs = 1 + mhi_cntrl_config->num_events;\n\n\tnr_vectors = pci_alloc_irq_vectors(pdev, 1, mhi_cntrl->nr_irqs, PCI_IRQ_MSI);\n\tif (nr_vectors < 0) {\n\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors %d\\n\",\n\t\t\tnr_vectors);\n\t\treturn nr_vectors;\n\t}\n\n\tif (nr_vectors < mhi_cntrl->nr_irqs) {\n\t\tdev_warn(&pdev->dev, \"using shared MSI\\n\");\n\n\t\t \n\t\tfor (i = 0; i < mhi_cntrl_config->num_events; i++)\n\t\t\tmhi_cntrl_config->event_cfg[i].irq = 0;\n\t\tmhi_cntrl->nr_irqs = 1;\n\t}\n\n\tirq = devm_kcalloc(&pdev->dev, mhi_cntrl->nr_irqs, sizeof(int), GFP_KERNEL);\n\tif (!irq)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < mhi_cntrl->nr_irqs; i++) {\n\t\tint vector = i >= nr_vectors ? (nr_vectors - 1) : i;\n\n\t\tirq[i] = pci_irq_vector(pdev, vector);\n\t}\n\n\tmhi_cntrl->irq = irq;\n\n\treturn 0;\n}\n\nstatic int mhi_pci_runtime_get(struct mhi_controller *mhi_cntrl)\n{\n\t \n\treturn pm_runtime_get(mhi_cntrl->cntrl_dev);\n}\n\nstatic void mhi_pci_runtime_put(struct mhi_controller *mhi_cntrl)\n{\n\t \n\tpm_runtime_mark_last_busy(mhi_cntrl->cntrl_dev);\n\tpm_runtime_put(mhi_cntrl->cntrl_dev);\n}\n\nstatic void mhi_pci_recovery_work(struct work_struct *work)\n{\n\tstruct mhi_pci_device *mhi_pdev = container_of(work, struct mhi_pci_device,\n\t\t\t\t\t\t       recovery_work);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\tstruct pci_dev *pdev = to_pci_dev(mhi_cntrl->cntrl_dev);\n\tint err;\n\n\tdev_warn(&pdev->dev, \"device recovery started\\n\");\n\n\tdel_timer(&mhi_pdev->health_check_timer);\n\tpm_runtime_forbid(&pdev->dev);\n\n\t \n\tif (test_and_clear_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status)) {\n\t\tmhi_power_down(mhi_cntrl, false);\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t}\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_load_saved_state(pdev, mhi_pdev->pci_state);\n\tpci_restore_state(pdev);\n\n\tif (!mhi_pci_is_alive(mhi_cntrl))\n\t\tgoto err_try_reset;\n\n\terr = mhi_prepare_for_power_up(mhi_cntrl);\n\tif (err)\n\t\tgoto err_try_reset;\n\n\terr = mhi_sync_power_up(mhi_cntrl);\n\tif (err)\n\t\tgoto err_unprepare;\n\n\tdev_dbg(&pdev->dev, \"Recovery completed\\n\");\n\n\tset_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status);\n\tmod_timer(&mhi_pdev->health_check_timer, jiffies + HEALTH_CHECK_PERIOD);\n\treturn;\n\nerr_unprepare:\n\tmhi_unprepare_after_power_down(mhi_cntrl);\nerr_try_reset:\n\tif (pci_reset_function(pdev))\n\t\tdev_err(&pdev->dev, \"Recovery failed\\n\");\n}\n\nstatic void health_check(struct timer_list *t)\n{\n\tstruct mhi_pci_device *mhi_pdev = from_timer(mhi_pdev, t, health_check_timer);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\tif (!test_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status) ||\n\t\t\ttest_bit(MHI_PCI_DEV_SUSPENDED, &mhi_pdev->status))\n\t\treturn;\n\n\tif (!mhi_pci_is_alive(mhi_cntrl)) {\n\t\tdev_err(mhi_cntrl->cntrl_dev, \"Device died\\n\");\n\t\tqueue_work(system_long_wq, &mhi_pdev->recovery_work);\n\t\treturn;\n\t}\n\n\t \n\tmod_timer(&mhi_pdev->health_check_timer, jiffies + HEALTH_CHECK_PERIOD);\n}\n\nstatic int mhi_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tconst struct mhi_pci_dev_info *info = (struct mhi_pci_dev_info *) id->driver_data;\n\tconst struct mhi_controller_config *mhi_cntrl_config;\n\tstruct mhi_pci_device *mhi_pdev;\n\tstruct mhi_controller *mhi_cntrl;\n\tint err;\n\n\tdev_info(&pdev->dev, \"MHI PCI device found: %s\\n\", info->name);\n\n\t \n\tmhi_pdev = devm_kzalloc(&pdev->dev, sizeof(*mhi_pdev), GFP_KERNEL);\n\tif (!mhi_pdev)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&mhi_pdev->recovery_work, mhi_pci_recovery_work);\n\ttimer_setup(&mhi_pdev->health_check_timer, health_check, 0);\n\n\tmhi_cntrl_config = info->config;\n\tmhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\tmhi_cntrl->cntrl_dev = &pdev->dev;\n\tmhi_cntrl->iova_start = 0;\n\tmhi_cntrl->iova_stop = (dma_addr_t)DMA_BIT_MASK(info->dma_data_width);\n\tmhi_cntrl->fw_image = info->fw;\n\tmhi_cntrl->edl_image = info->edl;\n\n\tmhi_cntrl->read_reg = mhi_pci_read_reg;\n\tmhi_cntrl->write_reg = mhi_pci_write_reg;\n\tmhi_cntrl->status_cb = mhi_pci_status_cb;\n\tmhi_cntrl->runtime_get = mhi_pci_runtime_get;\n\tmhi_cntrl->runtime_put = mhi_pci_runtime_put;\n\tmhi_cntrl->mru = info->mru_default;\n\n\tif (info->sideband_wake) {\n\t\tmhi_cntrl->wake_get = mhi_pci_wake_get_nop;\n\t\tmhi_cntrl->wake_put = mhi_pci_wake_put_nop;\n\t\tmhi_cntrl->wake_toggle = mhi_pci_wake_toggle_nop;\n\t}\n\n\terr = mhi_pci_claim(mhi_cntrl, info->bar_num, DMA_BIT_MASK(info->dma_data_width));\n\tif (err)\n\t\treturn err;\n\n\terr = mhi_pci_get_irqs(mhi_cntrl, mhi_cntrl_config);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_drvdata(pdev, mhi_pdev);\n\n\t \n\tpci_save_state(pdev);\n\tmhi_pdev->pci_state = pci_store_saved_state(pdev);\n\tpci_load_saved_state(pdev, NULL);\n\n\terr = mhi_register_controller(mhi_cntrl, mhi_cntrl_config);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mhi_prepare_for_power_up(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to prepare MHI controller\\n\");\n\t\tgoto err_unregister;\n\t}\n\n\terr = mhi_sync_power_up(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to power up MHI controller\\n\");\n\t\tgoto err_unprepare;\n\t}\n\n\tset_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status);\n\n\t \n\tmod_timer(&mhi_pdev->health_check_timer, jiffies + HEALTH_CHECK_PERIOD);\n\n\t \n\tif (pci_pme_capable(pdev, PCI_D3hot)) {\n\t\tpm_runtime_set_autosuspend_delay(&pdev->dev, 2000);\n\t\tpm_runtime_use_autosuspend(&pdev->dev);\n\t\tpm_runtime_mark_last_busy(&pdev->dev);\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t}\n\n\treturn 0;\n\nerr_unprepare:\n\tmhi_unprepare_after_power_down(mhi_cntrl);\nerr_unregister:\n\tmhi_unregister_controller(mhi_cntrl);\n\n\treturn err;\n}\n\nstatic void mhi_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mhi_pci_device *mhi_pdev = pci_get_drvdata(pdev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\tdel_timer_sync(&mhi_pdev->health_check_timer);\n\tcancel_work_sync(&mhi_pdev->recovery_work);\n\n\tif (test_and_clear_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status)) {\n\t\tmhi_power_down(mhi_cntrl, true);\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t}\n\n\t \n\tif (pci_pme_capable(pdev, PCI_D3hot))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\tmhi_unregister_controller(mhi_cntrl);\n}\n\nstatic void mhi_pci_shutdown(struct pci_dev *pdev)\n{\n\tmhi_pci_remove(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\nstatic void mhi_pci_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct mhi_pci_device *mhi_pdev = pci_get_drvdata(pdev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\tdev_info(&pdev->dev, \"reset\\n\");\n\n\tdel_timer(&mhi_pdev->health_check_timer);\n\n\t \n\tif (test_and_clear_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status)) {\n\t\tmhi_power_down(mhi_cntrl, false);\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t}\n\n\t \n\tmhi_soc_reset(mhi_cntrl);\n\n\t \n\tmsleep(MHI_POST_RESET_DELAY_MS);\n}\n\nstatic void mhi_pci_reset_done(struct pci_dev *pdev)\n{\n\tstruct mhi_pci_device *mhi_pdev = pci_get_drvdata(pdev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\tint err;\n\n\t \n\tpci_load_saved_state(pdev, mhi_pdev->pci_state);\n\tpci_restore_state(pdev);\n\n\t \n\tif (!mhi_pci_is_alive(mhi_cntrl)) {\n\t\tdev_err(&pdev->dev, \"reset failed\\n\");\n\t\treturn;\n\t}\n\n\terr = mhi_prepare_for_power_up(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to prepare MHI controller\\n\");\n\t\treturn;\n\t}\n\n\terr = mhi_sync_power_up(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to power up MHI controller\\n\");\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t\treturn;\n\t}\n\n\tset_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status);\n\tmod_timer(&mhi_pdev->health_check_timer, jiffies + HEALTH_CHECK_PERIOD);\n}\n\nstatic pci_ers_result_t mhi_pci_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct mhi_pci_device *mhi_pdev = pci_get_drvdata(pdev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\tdev_err(&pdev->dev, \"PCI error detected, state = %u\\n\", state);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\t \n\tif (test_and_clear_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status)) {\n\t\tmhi_power_down(mhi_cntrl, false);\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t} else {\n\t\t \n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\tpci_disable_device(pdev);\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t mhi_pci_slot_reset(struct pci_dev *pdev)\n{\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"Cannot re-enable PCI device after reset.\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void mhi_pci_io_resume(struct pci_dev *pdev)\n{\n\tstruct mhi_pci_device *mhi_pdev = pci_get_drvdata(pdev);\n\n\tdev_err(&pdev->dev, \"PCI slot reset done\\n\");\n\n\tqueue_work(system_long_wq, &mhi_pdev->recovery_work);\n}\n\nstatic const struct pci_error_handlers mhi_pci_err_handler = {\n\t.error_detected = mhi_pci_error_detected,\n\t.slot_reset = mhi_pci_slot_reset,\n\t.resume = mhi_pci_io_resume,\n\t.reset_prepare = mhi_pci_reset_prepare,\n\t.reset_done = mhi_pci_reset_done,\n};\n\nstatic int  __maybe_unused mhi_pci_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct mhi_pci_device *mhi_pdev = dev_get_drvdata(dev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\tint err;\n\n\tif (test_and_set_bit(MHI_PCI_DEV_SUSPENDED, &mhi_pdev->status))\n\t\treturn 0;\n\n\tdel_timer(&mhi_pdev->health_check_timer);\n\tcancel_work_sync(&mhi_pdev->recovery_work);\n\n\tif (!test_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status) ||\n\t\t\tmhi_cntrl->ee != MHI_EE_AMSS)\n\t\tgoto pci_suspend;  \n\n\t \n\terr = mhi_pm_suspend(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to suspend device: %d\\n\", err);\n\t\tclear_bit(MHI_PCI_DEV_SUSPENDED, &mhi_pdev->status);\n\t\treturn -EBUSY;\n\t}\n\npci_suspend:\n\tpci_disable_device(pdev);\n\tpci_wake_from_d3(pdev, true);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mhi_pci_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct mhi_pci_device *mhi_pdev = dev_get_drvdata(dev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\tint err;\n\n\tif (!test_and_clear_bit(MHI_PCI_DEV_SUSPENDED, &mhi_pdev->status))\n\t\treturn 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto err_recovery;\n\n\tpci_set_master(pdev);\n\tpci_wake_from_d3(pdev, false);\n\n\tif (!test_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status) ||\n\t\t\tmhi_cntrl->ee != MHI_EE_AMSS)\n\t\treturn 0;  \n\n\t \n\terr = mhi_pm_resume(mhi_cntrl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to resume device: %d\\n\", err);\n\t\tgoto err_recovery;\n\t}\n\n\t \n\tmod_timer(&mhi_pdev->health_check_timer, jiffies + HEALTH_CHECK_PERIOD);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\treturn 0;\n\nerr_recovery:\n\t \n\tqueue_work(system_long_wq, &mhi_pdev->recovery_work);\n\tpm_runtime_mark_last_busy(dev);\n\n\treturn 0;\n}\n\nstatic int  __maybe_unused mhi_pci_suspend(struct device *dev)\n{\n\tpm_runtime_disable(dev);\n\treturn mhi_pci_runtime_suspend(dev);\n}\n\nstatic int __maybe_unused mhi_pci_resume(struct device *dev)\n{\n\tint ret;\n\n\t \n\tret = mhi_pci_runtime_resume(dev);\n\tpm_runtime_enable(dev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused mhi_pci_freeze(struct device *dev)\n{\n\tstruct mhi_pci_device *mhi_pdev = dev_get_drvdata(dev);\n\tstruct mhi_controller *mhi_cntrl = &mhi_pdev->mhi_cntrl;\n\n\t \n\tflush_work(&mhi_pdev->recovery_work);\n\tif (test_and_clear_bit(MHI_PCI_DEV_STARTED, &mhi_pdev->status)) {\n\t\tmhi_power_down(mhi_cntrl, true);\n\t\tmhi_unprepare_after_power_down(mhi_cntrl);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mhi_pci_restore(struct device *dev)\n{\n\tstruct mhi_pci_device *mhi_pdev = dev_get_drvdata(dev);\n\n\t \n\tqueue_work(system_long_wq, &mhi_pdev->recovery_work);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mhi_pci_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mhi_pci_runtime_suspend, mhi_pci_runtime_resume, NULL)\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = mhi_pci_suspend,\n\t.resume = mhi_pci_resume,\n\t.freeze = mhi_pci_freeze,\n\t.thaw = mhi_pci_restore,\n\t.poweroff = mhi_pci_freeze,\n\t.restore = mhi_pci_restore,\n#endif\n};\n\nstatic struct pci_driver mhi_pci_driver = {\n\t.name\t\t= \"mhi-pci-generic\",\n\t.id_table\t= mhi_pci_id_table,\n\t.probe\t\t= mhi_pci_probe,\n\t.remove\t\t= mhi_pci_remove,\n\t.shutdown\t= mhi_pci_shutdown,\n\t.err_handler\t= &mhi_pci_err_handler,\n\t.driver.pm\t= &mhi_pci_pm_ops\n};\nmodule_pci_driver(mhi_pci_driver);\n\nMODULE_AUTHOR(\"Loic Poulain <loic.poulain@linaro.org>\");\nMODULE_DESCRIPTION(\"Modem Host Interface (MHI) PCI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}