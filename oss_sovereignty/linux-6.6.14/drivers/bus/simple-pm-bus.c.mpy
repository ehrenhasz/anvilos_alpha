{
  "module_name": "simple-pm-bus.c",
  "hash_id": "b6adf12e2303aa246c68febbc1d1bfe392387d07acf99df6b5df3e79e18fecd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/simple-pm-bus.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\nstruct simple_pm_bus {\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n};\n\nstatic int simple_pm_bus_probe(struct platform_device *pdev)\n{\n\tconst struct device *dev = &pdev->dev;\n\tconst struct of_dev_auxdata *lookup = dev_get_platdata(dev);\n\tstruct device_node *np = dev->of_node;\n\tconst struct of_device_id *match;\n\tstruct simple_pm_bus *bus;\n\n\t \n\tif (pdev->driver_override)\n\t\treturn 0;\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\t \n\tif (match && match->data) {\n\t\tif (of_property_match_string(np, \"compatible\", match->compatible) == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -ENODEV;\n\t}\n\n\tbus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->num_clks = devm_clk_bulk_get_all(&pdev->dev, &bus->clks);\n\tif (bus->num_clks < 0)\n\t\treturn dev_err_probe(&pdev->dev, bus->num_clks, \"failed to get clocks\\n\");\n\n\tdev_set_drvdata(&pdev->dev, bus);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tif (np)\n\t\tof_platform_populate(np, NULL, lookup, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic int simple_pm_bus_remove(struct platform_device *pdev)\n{\n\tconst void *data = of_device_get_match_data(&pdev->dev);\n\n\tif (pdev->driver_override || data)\n\t\treturn 0;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int simple_pm_bus_runtime_suspend(struct device *dev)\n{\n\tstruct simple_pm_bus *bus = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(bus->num_clks, bus->clks);\n\n\treturn 0;\n}\n\nstatic int simple_pm_bus_runtime_resume(struct device *dev)\n{\n\tstruct simple_pm_bus *bus = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(bus->num_clks, bus->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops simple_pm_bus_pm_ops = {\n\tRUNTIME_PM_OPS(simple_pm_bus_runtime_suspend, simple_pm_bus_runtime_resume, NULL)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\n#define ONLY_BUS\t((void *) 1)  \n\nstatic const struct of_device_id simple_pm_bus_of_match[] = {\n\t{ .compatible = \"simple-pm-bus\", },\n\t{ .compatible = \"simple-bus\",\t.data = ONLY_BUS },\n\t{ .compatible = \"simple-mfd\",\t.data = ONLY_BUS },\n\t{ .compatible = \"isa\",\t\t.data = ONLY_BUS },\n\t{ .compatible = \"arm,amba-bus\",\t.data = ONLY_BUS },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, simple_pm_bus_of_match);\n\nstatic struct platform_driver simple_pm_bus_driver = {\n\t.probe = simple_pm_bus_probe,\n\t.remove = simple_pm_bus_remove,\n\t.driver = {\n\t\t.name = \"simple-pm-bus\",\n\t\t.of_match_table = simple_pm_bus_of_match,\n\t\t.pm = pm_ptr(&simple_pm_bus_pm_ops),\n\t},\n};\n\nmodule_platform_driver(simple_pm_bus_driver);\n\nMODULE_DESCRIPTION(\"Simple Power-Managed Bus Driver\");\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert+renesas@glider.be>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}