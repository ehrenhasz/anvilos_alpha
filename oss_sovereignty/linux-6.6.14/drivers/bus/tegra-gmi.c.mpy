{
  "module_name": "tegra-gmi.c",
  "hash_id": "21017cfc96384679cc62d85f09113d786b08fd86b6ffd92dcd280535f67a6223",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/tegra-gmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n\n#define TEGRA_GMI_CONFIG\t\t0x00\n#define TEGRA_GMI_CONFIG_GO\t\tBIT(31)\n#define TEGRA_GMI_BUS_WIDTH_32BIT\tBIT(30)\n#define TEGRA_GMI_MUX_MODE\t\tBIT(28)\n#define TEGRA_GMI_RDY_BEFORE_DATA\tBIT(24)\n#define TEGRA_GMI_RDY_ACTIVE_HIGH\tBIT(23)\n#define TEGRA_GMI_ADV_ACTIVE_HIGH\tBIT(22)\n#define TEGRA_GMI_OE_ACTIVE_HIGH\tBIT(21)\n#define TEGRA_GMI_CS_ACTIVE_HIGH\tBIT(20)\n#define TEGRA_GMI_CS_SELECT(x)\t\t((x & 0x7) << 4)\n\n#define TEGRA_GMI_TIMING0\t\t0x10\n#define TEGRA_GMI_MUXED_WIDTH(x)\t((x & 0xf) << 12)\n#define TEGRA_GMI_HOLD_WIDTH(x)\t\t((x & 0xf) << 8)\n#define TEGRA_GMI_ADV_WIDTH(x)\t\t((x & 0xf) << 4)\n#define TEGRA_GMI_CE_WIDTH(x)\t\t(x & 0xf)\n\n#define TEGRA_GMI_TIMING1\t\t0x14\n#define TEGRA_GMI_WE_WIDTH(x)\t\t((x & 0xff) << 16)\n#define TEGRA_GMI_OE_WIDTH(x)\t\t((x & 0xff) << 8)\n#define TEGRA_GMI_WAIT_WIDTH(x)\t\t(x & 0xff)\n\n#define TEGRA_GMI_MAX_CHIP_SELECT\t8\n\nstruct tegra_gmi {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\n\tu32 snor_config;\n\tu32 snor_timing0;\n\tu32 snor_timing1;\n};\n\nstatic int tegra_gmi_enable(struct tegra_gmi *gmi)\n{\n\tint err;\n\n\tpm_runtime_enable(gmi->dev);\n\terr = pm_runtime_resume_and_get(gmi->dev);\n\tif (err) {\n\t\tpm_runtime_disable(gmi->dev);\n\t\treturn err;\n\t}\n\n\treset_control_assert(gmi->rst);\n\tusleep_range(2000, 4000);\n\treset_control_deassert(gmi->rst);\n\n\twritel(gmi->snor_timing0, gmi->base + TEGRA_GMI_TIMING0);\n\twritel(gmi->snor_timing1, gmi->base + TEGRA_GMI_TIMING1);\n\n\tgmi->snor_config |= TEGRA_GMI_CONFIG_GO;\n\twritel(gmi->snor_config, gmi->base + TEGRA_GMI_CONFIG);\n\n\treturn 0;\n}\n\nstatic void tegra_gmi_disable(struct tegra_gmi *gmi)\n{\n\tu32 config;\n\n\t \n\tconfig = readl(gmi->base + TEGRA_GMI_CONFIG);\n\tconfig &= ~TEGRA_GMI_CONFIG_GO;\n\twritel(config, gmi->base + TEGRA_GMI_CONFIG);\n\n\treset_control_assert(gmi->rst);\n\n\tpm_runtime_put_sync_suspend(gmi->dev);\n\tpm_runtime_force_suspend(gmi->dev);\n}\n\nstatic int tegra_gmi_parse_dt(struct tegra_gmi *gmi)\n{\n\tstruct device_node *child;\n\tu32 property, ranges[4];\n\tint err;\n\n\tchild = of_get_next_available_child(gmi->dev->of_node, NULL);\n\tif (!child) {\n\t\tdev_err(gmi->dev, \"no child nodes found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (of_get_child_count(gmi->dev->of_node) > 1)\n\t\tdev_warn(gmi->dev, \"only one child device is supported.\");\n\n\tif (of_property_read_bool(child, \"nvidia,snor-data-width-32bit\"))\n\t\tgmi->snor_config |= TEGRA_GMI_BUS_WIDTH_32BIT;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-mux-mode\"))\n\t\tgmi->snor_config |= TEGRA_GMI_MUX_MODE;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-rdy-active-before-data\"))\n\t\tgmi->snor_config |= TEGRA_GMI_RDY_BEFORE_DATA;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-rdy-active-high\"))\n\t\tgmi->snor_config |= TEGRA_GMI_RDY_ACTIVE_HIGH;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-adv-active-high\"))\n\t\tgmi->snor_config |= TEGRA_GMI_ADV_ACTIVE_HIGH;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-oe-active-high\"))\n\t\tgmi->snor_config |= TEGRA_GMI_OE_ACTIVE_HIGH;\n\n\tif (of_property_read_bool(child, \"nvidia,snor-cs-active-high\"))\n\t\tgmi->snor_config |= TEGRA_GMI_CS_ACTIVE_HIGH;\n\n\t \n\terr = of_property_read_u32_array(child, \"ranges\", ranges, 4);\n\tif (err < 0) {\n\t\t \n\t\tif (err == -EOVERFLOW) {\n\t\t\tdev_err(gmi->dev,\n\t\t\t\t\"failed to decode CS: invalid ranges length\\n\");\n\t\t\tgoto error_cs;\n\t\t}\n\n\t\t \n\t\terr = of_property_read_u32(child, \"reg\", &property);\n\t\tif (err < 0) {\n\t\t\tdev_err(gmi->dev,\n\t\t\t\t\"failed to decode CS: no reg property found\\n\");\n\t\t\tgoto error_cs;\n\t\t}\n\t} else {\n\t\tproperty = ranges[1];\n\t}\n\n\t \n\tif (property >= TEGRA_GMI_MAX_CHIP_SELECT) {\n\t\tdev_err(gmi->dev, \"invalid chip select: %d\", property);\n\t\terr = -EINVAL;\n\t\tgoto error_cs;\n\t}\n\n\tgmi->snor_config |= TEGRA_GMI_CS_SELECT(property);\n\n\t \n\tif (!of_property_read_u32(child, \"nvidia,snor-muxed-width\", &property))\n\t\tgmi->snor_timing0 |= TEGRA_GMI_MUXED_WIDTH(property);\n\telse\n\t\tgmi->snor_timing0 |= TEGRA_GMI_MUXED_WIDTH(1);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-hold-width\", &property))\n\t\tgmi->snor_timing0 |= TEGRA_GMI_HOLD_WIDTH(property);\n\telse\n\t\tgmi->snor_timing0 |= TEGRA_GMI_HOLD_WIDTH(1);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-adv-width\", &property))\n\t\tgmi->snor_timing0 |= TEGRA_GMI_ADV_WIDTH(property);\n\telse\n\t\tgmi->snor_timing0 |= TEGRA_GMI_ADV_WIDTH(1);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-ce-width\", &property))\n\t\tgmi->snor_timing0 |= TEGRA_GMI_CE_WIDTH(property);\n\telse\n\t\tgmi->snor_timing0 |= TEGRA_GMI_CE_WIDTH(4);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-we-width\", &property))\n\t\tgmi->snor_timing1 |= TEGRA_GMI_WE_WIDTH(property);\n\telse\n\t\tgmi->snor_timing1 |= TEGRA_GMI_WE_WIDTH(1);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-oe-width\", &property))\n\t\tgmi->snor_timing1 |= TEGRA_GMI_OE_WIDTH(property);\n\telse\n\t\tgmi->snor_timing1 |= TEGRA_GMI_OE_WIDTH(1);\n\n\tif (!of_property_read_u32(child, \"nvidia,snor-wait-width\", &property))\n\t\tgmi->snor_timing1 |= TEGRA_GMI_WAIT_WIDTH(property);\n\telse\n\t\tgmi->snor_timing1 |= TEGRA_GMI_WAIT_WIDTH(3);\n\nerror_cs:\n\tof_node_put(child);\n\treturn err;\n}\n\nstatic int tegra_gmi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_gmi *gmi;\n\tint err;\n\n\tgmi = devm_kzalloc(dev, sizeof(*gmi), GFP_KERNEL);\n\tif (!gmi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, gmi);\n\tgmi->dev = dev;\n\n\tgmi->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gmi->base))\n\t\treturn PTR_ERR(gmi->base);\n\n\tgmi->clk = devm_clk_get(dev, \"gmi\");\n\tif (IS_ERR(gmi->clk)) {\n\t\tdev_err(dev, \"can not get clock\\n\");\n\t\treturn PTR_ERR(gmi->clk);\n\t}\n\n\tgmi->rst = devm_reset_control_get(dev, \"gmi\");\n\tif (IS_ERR(gmi->rst)) {\n\t\tdev_err(dev, \"can not get reset\\n\");\n\t\treturn PTR_ERR(gmi->rst);\n\t}\n\n\terr = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_gmi_parse_dt(gmi);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_gmi_enable(gmi);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = of_platform_default_populate(dev->of_node, NULL, dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"fail to create devices.\\n\");\n\t\ttegra_gmi_disable(gmi);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_gmi_remove(struct platform_device *pdev)\n{\n\tstruct tegra_gmi *gmi = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(gmi->dev);\n\ttegra_gmi_disable(gmi);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_gmi_runtime_resume(struct device *dev)\n{\n\tstruct tegra_gmi *gmi = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(gmi->clk);\n\tif (err < 0) {\n\t\tdev_err(gmi->dev, \"failed to enable clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_gmi_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_gmi *gmi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(gmi->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_gmi_pm = {\n\tSET_RUNTIME_PM_OPS(tegra_gmi_runtime_suspend, tegra_gmi_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id tegra_gmi_id_table[] = {\n\t{ .compatible = \"nvidia,tegra20-gmi\", },\n\t{ .compatible = \"nvidia,tegra30-gmi\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_gmi_id_table);\n\nstatic struct platform_driver tegra_gmi_driver = {\n\t.probe = tegra_gmi_probe,\n\t.remove = tegra_gmi_remove,\n\t.driver = {\n\t\t.name\t\t= \"tegra-gmi\",\n\t\t.of_match_table\t= tegra_gmi_id_table,\n\t\t.pm = &tegra_gmi_pm,\n\t},\n};\nmodule_platform_driver(tegra_gmi_driver);\n\nMODULE_AUTHOR(\"Mirza Krak <mirza.krak@gmail.com\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra GMI Bus Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}