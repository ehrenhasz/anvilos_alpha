{
  "module_name": "omap_l3_smx.c",
  "hash_id": "da90e03dd8abfba82bf758fb6af2dd786bb20cdefc41f2b95aa529fd74048db4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/omap_l3_smx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include \"omap_l3_smx.h\"\n\nstatic inline u64 omap3_l3_readll(void __iomem *base, u16 reg)\n{\n\treturn __raw_readll(base + reg);\n}\n\nstatic inline void omap3_l3_writell(void __iomem *base, u16 reg, u64 value)\n{\n\t__raw_writell(value, base + reg);\n}\n\nstatic inline enum omap3_l3_code omap3_l3_decode_error_code(u64 error)\n{\n\treturn (error & 0x0f000000) >> L3_ERROR_LOG_CODE;\n}\n\nstatic inline u32 omap3_l3_decode_addr(u64 error_addr)\n{\n\treturn error_addr & 0xffffffff;\n}\n\nstatic inline unsigned omap3_l3_decode_cmd(u64 error)\n{\n\treturn (error & 0x07) >> L3_ERROR_LOG_CMD;\n}\n\nstatic inline enum omap3_l3_initiator_id omap3_l3_decode_initid(u64 error)\n{\n\treturn (error & 0xff00) >> L3_ERROR_LOG_INITID;\n}\n\nstatic inline unsigned omap3_l3_decode_req_info(u64 error)\n{\n\treturn (error >> 32) & 0xffff;\n}\n\nstatic char *omap3_l3_code_string(u8 code)\n{\n\tswitch (code) {\n\tcase OMAP_L3_CODE_NOERROR:\n\t\treturn \"No Error\";\n\tcase OMAP_L3_CODE_UNSUP_CMD:\n\t\treturn \"Unsupported Command\";\n\tcase OMAP_L3_CODE_ADDR_HOLE:\n\t\treturn \"Address Hole\";\n\tcase OMAP_L3_CODE_PROTECT_VIOLATION:\n\t\treturn \"Protection Violation\";\n\tcase OMAP_L3_CODE_IN_BAND_ERR:\n\t\treturn \"In-band Error\";\n\tcase OMAP_L3_CODE_REQ_TOUT_NOT_ACCEPT:\n\t\treturn \"Request Timeout Not Accepted\";\n\tcase OMAP_L3_CODE_REQ_TOUT_NO_RESP:\n\t\treturn \"Request Timeout, no response\";\n\tdefault:\n\t\treturn \"UNKNOWN error\";\n\t}\n}\n\nstatic char *omap3_l3_initiator_string(u8 initid)\n{\n\tswitch (initid) {\n\tcase OMAP_L3_LCD:\n\t\treturn \"LCD\";\n\tcase OMAP_L3_SAD2D:\n\t\treturn \"SAD2D\";\n\tcase OMAP_L3_IA_MPU_SS_1:\n\tcase OMAP_L3_IA_MPU_SS_2:\n\tcase OMAP_L3_IA_MPU_SS_3:\n\tcase OMAP_L3_IA_MPU_SS_4:\n\tcase OMAP_L3_IA_MPU_SS_5:\n\t\treturn \"MPU\";\n\tcase OMAP_L3_IA_IVA_SS_1:\n\tcase OMAP_L3_IA_IVA_SS_2:\n\tcase OMAP_L3_IA_IVA_SS_3:\n\t\treturn \"IVA_SS\";\n\tcase OMAP_L3_IA_IVA_SS_DMA_1:\n\tcase OMAP_L3_IA_IVA_SS_DMA_2:\n\tcase OMAP_L3_IA_IVA_SS_DMA_3:\n\tcase OMAP_L3_IA_IVA_SS_DMA_4:\n\tcase OMAP_L3_IA_IVA_SS_DMA_5:\n\tcase OMAP_L3_IA_IVA_SS_DMA_6:\n\t\treturn \"IVA_SS_DMA\";\n\tcase OMAP_L3_IA_SGX:\n\t\treturn \"SGX\";\n\tcase OMAP_L3_IA_CAM_1:\n\tcase OMAP_L3_IA_CAM_2:\n\tcase OMAP_L3_IA_CAM_3:\n\t\treturn \"CAM\";\n\tcase OMAP_L3_IA_DAP:\n\t\treturn \"DAP\";\n\tcase OMAP_L3_SDMA_WR_1:\n\tcase OMAP_L3_SDMA_WR_2:\n\t\treturn \"SDMA_WR\";\n\tcase OMAP_L3_SDMA_RD_1:\n\tcase OMAP_L3_SDMA_RD_2:\n\tcase OMAP_L3_SDMA_RD_3:\n\tcase OMAP_L3_SDMA_RD_4:\n\t\treturn \"SDMA_RD\";\n\tcase OMAP_L3_USBOTG:\n\t\treturn \"USB_OTG\";\n\tcase OMAP_L3_USBHOST:\n\t\treturn \"USB_HOST\";\n\tdefault:\n\t\treturn \"UNKNOWN Initiator\";\n\t}\n}\n\n \nstatic irqreturn_t omap3_l3_block_irq(struct omap3_l3 *l3,\n\t\t\t\t\tu64 error, int error_addr)\n{\n\tu8 code = omap3_l3_decode_error_code(error);\n\tu8 initid = omap3_l3_decode_initid(error);\n\tu8 multi = error & L3_ERROR_LOG_MULTI;\n\tu32 address = omap3_l3_decode_addr(error_addr);\n\n\tpr_err(\"%s seen by %s %s at address %x\\n\",\n\t\t\tomap3_l3_code_string(code),\n\t\t\tomap3_l3_initiator_string(initid),\n\t\t\tmulti ? \"Multiple Errors\" : \"\", address);\n\tWARN_ON(1);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t omap3_l3_app_irq(int irq, void *_l3)\n{\n\tstruct omap3_l3 *l3 = _l3;\n\tu64 status, clear;\n\tu64 error;\n\tu64 error_addr;\n\tu64 err_source = 0;\n\tvoid __iomem *base;\n\tint int_type;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tint_type = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\n\tif (!int_type)\n\t\tstatus = omap3_l3_readll(l3->rt, L3_SI_FLAG_STATUS_0);\n\telse\n\t\tstatus = omap3_l3_readll(l3->rt, L3_SI_FLAG_STATUS_1);\n\n\t \n\terr_source = __ffs(status);\n\n\tbase = l3->rt + omap3_l3_bases[int_type][err_source];\n\terror = omap3_l3_readll(base, L3_ERROR_LOG);\n\tif (error) {\n\t\terror_addr = omap3_l3_readll(base, L3_ERROR_LOG_ADDR);\n\t\tret |= omap3_l3_block_irq(l3, error, error_addr);\n\t}\n\n\t \n\tBUG_ON(!int_type && status & L3_STATUS_0_TIMEOUT_MASK);\n\n\t \n\tclear = (L3_AGENT_STATUS_CLEAR_IA << int_type) |\n\t\tL3_AGENT_STATUS_CLEAR_TA;\n\tomap3_l3_writell(base, L3_AGENT_STATUS, clear);\n\n\t \n\tomap3_l3_writell(base, L3_ERROR_LOG, error);\n\n\treturn ret;\n}\n\n#if IS_BUILTIN(CONFIG_OF)\nstatic const struct of_device_id omap3_l3_match[] = {\n\t{\n\t\t.compatible = \"ti,omap3-l3-smx\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap3_l3_match);\n#endif\n\nstatic int omap3_l3_probe(struct platform_device *pdev)\n{\n\tstruct omap3_l3 *l3;\n\tstruct resource *res;\n\tint ret;\n\n\tl3 = kzalloc(sizeof(*l3), GFP_KERNEL);\n\tif (!l3)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, l3);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"couldn't find resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err0;\n\t}\n\tl3->rt = ioremap(res->start, resource_size(res));\n\tif (!l3->rt) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tl3->debug_irq = platform_get_irq(pdev, 0);\n\tret = request_irq(l3->debug_irq, omap3_l3_app_irq, IRQF_TRIGGER_RISING,\n\t\t\t  \"l3-debug-irq\", l3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"couldn't request debug irq\\n\");\n\t\tgoto err1;\n\t}\n\n\tl3->app_irq = platform_get_irq(pdev, 1);\n\tret = request_irq(l3->app_irq, omap3_l3_app_irq, IRQF_TRIGGER_RISING,\n\t\t\t  \"l3-app-irq\", l3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"couldn't request app irq\\n\");\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\nerr2:\n\tfree_irq(l3->debug_irq, l3);\nerr1:\n\tiounmap(l3->rt);\nerr0:\n\tkfree(l3);\n\treturn ret;\n}\n\nstatic int omap3_l3_remove(struct platform_device *pdev)\n{\n\tstruct omap3_l3         *l3 = platform_get_drvdata(pdev);\n\n\tfree_irq(l3->app_irq, l3);\n\tfree_irq(l3->debug_irq, l3);\n\tiounmap(l3->rt);\n\tkfree(l3);\n\n\treturn 0;\n}\n\nstatic struct platform_driver omap3_l3_driver = {\n\t.probe\t\t= omap3_l3_probe,\n\t.remove         = omap3_l3_remove,\n\t.driver         = {\n\t\t.name   = \"omap_l3_smx\",\n\t\t.of_match_table = of_match_ptr(omap3_l3_match),\n\t},\n};\n\nstatic int __init omap3_l3_init(void)\n{\n\treturn platform_driver_register(&omap3_l3_driver);\n}\npostcore_initcall_sync(omap3_l3_init);\n\nstatic void __exit omap3_l3_exit(void)\n{\n\tplatform_driver_unregister(&omap3_l3_driver);\n}\nmodule_exit(omap3_l3_exit);\n\nMODULE_AUTHOR(\"Felipe Balbi\");\nMODULE_AUTHOR(\"Santosh Shilimkar\");\nMODULE_AUTHOR(\"Sricharan R\");\nMODULE_DESCRIPTION(\"OMAP3XXX L3 Interconnect Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}