{
  "module_name": "sunxi-rsb.c",
  "hash_id": "e24296fc79118088715d2a8d9c0fc641448a997d67ea313a08a59ebc658aa82d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/sunxi-rsb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/sunxi-rsb.h>\n#include <linux/types.h>\n\n \n#define RSB_CTRL\t0x0\t \n#define RSB_CCR\t\t0x4\t \n#define RSB_INTE\t0x8\t \n#define RSB_INTS\t0xc\t \n#define RSB_ADDR\t0x10\t \n#define RSB_DATA\t0x1c\t \n#define RSB_LCR\t\t0x24\t \n#define RSB_DMCR\t0x28\t \n#define RSB_CMD\t\t0x2c\t \n#define RSB_DAR\t\t0x30\t \n\n \n#define RSB_CTRL_START_TRANS\t\tBIT(7)\n#define RSB_CTRL_ABORT_TRANS\t\tBIT(6)\n#define RSB_CTRL_GLOBAL_INT_ENB\t\tBIT(1)\n#define RSB_CTRL_SOFT_RST\t\tBIT(0)\n\n \n#define RSB_CCR_SDA_OUT_DELAY(v)\t(((v) & 0x7) << 8)\n#define RSB_CCR_MAX_CLK_DIV\t\t0xff\n#define RSB_CCR_CLK_DIV(v)\t\t((v) & RSB_CCR_MAX_CLK_DIV)\n\n \n#define RSB_INTS_TRANS_ERR_ACK\t\tBIT(16)\n#define RSB_INTS_TRANS_ERR_DATA_BIT(v)\t(((v) >> 8) & 0xf)\n#define RSB_INTS_TRANS_ERR_DATA\t\tGENMASK(11, 8)\n#define RSB_INTS_LOAD_BSY\t\tBIT(2)\n#define RSB_INTS_TRANS_ERR\t\tBIT(1)\n#define RSB_INTS_TRANS_OVER\t\tBIT(0)\n\n \n#define RSB_LCR_SCL_STATE\t\tBIT(5)\n#define RSB_LCR_SDA_STATE\t\tBIT(4)\n#define RSB_LCR_SCL_CTL\t\t\tBIT(3)\n#define RSB_LCR_SCL_CTL_EN\t\tBIT(2)\n#define RSB_LCR_SDA_CTL\t\t\tBIT(1)\n#define RSB_LCR_SDA_CTL_EN\t\tBIT(0)\n\n \n#define RSB_DMCR_DEVICE_START\t\tBIT(31)\n#define RSB_DMCR_MODE_DATA\t\t(0x7c << 16)\n#define RSB_DMCR_MODE_REG\t\t(0x3e << 8)\n#define RSB_DMCR_DEV_ADDR\t\t0x00\n\n \n#define RSB_CMD_RD8\t\t\t0x8b\n#define RSB_CMD_RD16\t\t\t0x9c\n#define RSB_CMD_RD32\t\t\t0xa6\n#define RSB_CMD_WR8\t\t\t0x4e\n#define RSB_CMD_WR16\t\t\t0x59\n#define RSB_CMD_WR32\t\t\t0x63\n#define RSB_CMD_STRA\t\t\t0xe8\n\n \n#define RSB_DAR_RTA(v)\t\t\t(((v) & 0xff) << 16)\n#define RSB_DAR_DA(v)\t\t\t((v) & 0xffff)\n\n#define RSB_MAX_FREQ\t\t\t20000000\n\n#define RSB_CTRL_NAME\t\t\t\"sunxi-rsb\"\n\nstruct sunxi_rsb_addr_map {\n\tu16 hwaddr;\n\tu8 rtaddr;\n};\n\nstruct sunxi_rsb {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n\tstruct completion complete;\n\tstruct mutex lock;\n\tunsigned int status;\n\tu32 clk_freq;\n};\n\n \nstatic struct bus_type sunxi_rsb_bus;\n\nstatic int sunxi_rsb_device_match(struct device *dev, struct device_driver *drv)\n{\n\treturn of_driver_match_device(dev, drv);\n}\n\nstatic int sunxi_rsb_device_probe(struct device *dev)\n{\n\tconst struct sunxi_rsb_driver *drv = to_sunxi_rsb_driver(dev->driver);\n\tstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\n\tint ret;\n\n\tif (!drv->probe)\n\t\treturn -ENODEV;\n\n\tif (!rdev->irq) {\n\t\tint irq = -ENOENT;\n\n\t\tif (dev->of_node)\n\t\t\tirq = of_irq_get(dev->of_node, 0);\n\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn irq;\n\t\tif (irq < 0)\n\t\t\tirq = 0;\n\n\t\trdev->irq = irq;\n\t}\n\n\tret = of_clk_set_defaults(dev->of_node, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn drv->probe(rdev);\n}\n\nstatic void sunxi_rsb_device_remove(struct device *dev)\n{\n\tconst struct sunxi_rsb_driver *drv = to_sunxi_rsb_driver(dev->driver);\n\n\tdrv->remove(to_sunxi_rsb_device(dev));\n}\n\nstatic int sunxi_rsb_device_modalias(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn of_device_uevent_modalias(dev, env);\n}\n\nstatic struct bus_type sunxi_rsb_bus = {\n\t.name\t\t= RSB_CTRL_NAME,\n\t.match\t\t= sunxi_rsb_device_match,\n\t.probe\t\t= sunxi_rsb_device_probe,\n\t.remove\t\t= sunxi_rsb_device_remove,\n\t.uevent\t\t= sunxi_rsb_device_modalias,\n};\n\nstatic void sunxi_rsb_dev_release(struct device *dev)\n{\n\tstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\n\n\tkfree(rdev);\n}\n\n \nstatic struct sunxi_rsb_device *sunxi_rsb_device_create(struct sunxi_rsb *rsb,\n\t\tstruct device_node *node, u16 hwaddr, u8 rtaddr)\n{\n\tint err;\n\tstruct sunxi_rsb_device *rdev;\n\n\trdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trdev->rsb = rsb;\n\trdev->hwaddr = hwaddr;\n\trdev->rtaddr = rtaddr;\n\trdev->dev.bus = &sunxi_rsb_bus;\n\trdev->dev.parent = rsb->dev;\n\trdev->dev.of_node = node;\n\trdev->dev.release = sunxi_rsb_dev_release;\n\n\tdev_set_name(&rdev->dev, \"%s-%x\", RSB_CTRL_NAME, hwaddr);\n\n\terr = device_register(&rdev->dev);\n\tif (err < 0) {\n\t\tdev_err(&rdev->dev, \"Can't add %s, status %d\\n\",\n\t\t\tdev_name(&rdev->dev), err);\n\t\tgoto err_device_add;\n\t}\n\n\tdev_dbg(&rdev->dev, \"device %s registered\\n\", dev_name(&rdev->dev));\n\n\treturn rdev;\n\nerr_device_add:\n\tput_device(&rdev->dev);\n\n\treturn ERR_PTR(err);\n}\n\n \nstatic void sunxi_rsb_device_unregister(struct sunxi_rsb_device *rdev)\n{\n\tdevice_unregister(&rdev->dev);\n}\n\nstatic int sunxi_rsb_remove_devices(struct device *dev, void *data)\n{\n\tstruct sunxi_rsb_device *rdev = to_sunxi_rsb_device(dev);\n\n\tif (dev->bus == &sunxi_rsb_bus)\n\t\tsunxi_rsb_device_unregister(rdev);\n\n\treturn 0;\n}\n\n \nint sunxi_rsb_driver_register(struct sunxi_rsb_driver *rdrv)\n{\n\trdrv->driver.bus = &sunxi_rsb_bus;\n\treturn driver_register(&rdrv->driver);\n}\nEXPORT_SYMBOL_GPL(sunxi_rsb_driver_register);\n\n \nstatic int _sunxi_rsb_run_xfer(struct sunxi_rsb *rsb)\n{\n\tu32 int_mask, status;\n\tbool timeout;\n\n\tif (readl(rsb->regs + RSB_CTRL) & RSB_CTRL_START_TRANS) {\n\t\tdev_dbg(rsb->dev, \"RSB transfer still in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treinit_completion(&rsb->complete);\n\n\tint_mask = RSB_INTS_LOAD_BSY | RSB_INTS_TRANS_ERR | RSB_INTS_TRANS_OVER;\n\twritel(int_mask, rsb->regs + RSB_INTE);\n\twritel(RSB_CTRL_START_TRANS | RSB_CTRL_GLOBAL_INT_ENB,\n\t       rsb->regs + RSB_CTRL);\n\n\tif (irqs_disabled()) {\n\t\ttimeout = readl_poll_timeout_atomic(rsb->regs + RSB_INTS,\n\t\t\t\t\t\t    status, (status & int_mask),\n\t\t\t\t\t\t    10, 100000);\n\t\twritel(status, rsb->regs + RSB_INTS);\n\t} else {\n\t\ttimeout = !wait_for_completion_io_timeout(&rsb->complete,\n\t\t\t\t\t\t\t  msecs_to_jiffies(100));\n\t\tstatus = rsb->status;\n\t}\n\n\tif (timeout) {\n\t\tdev_dbg(rsb->dev, \"RSB timeout\\n\");\n\n\t\t \n\t\twritel(RSB_CTRL_ABORT_TRANS, rsb->regs + RSB_CTRL);\n\n\t\t \n\t\twritel(readl(rsb->regs + RSB_INTS), rsb->regs + RSB_INTS);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (status & RSB_INTS_LOAD_BSY) {\n\t\tdev_dbg(rsb->dev, \"RSB busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (status & RSB_INTS_TRANS_ERR) {\n\t\tif (status & RSB_INTS_TRANS_ERR_ACK) {\n\t\t\tdev_dbg(rsb->dev, \"RSB slave nack\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (status & RSB_INTS_TRANS_ERR_DATA) {\n\t\t\tdev_dbg(rsb->dev, \"RSB transfer data error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_rsb_read(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,\n\t\t\t  u32 *buf, size_t len)\n{\n\tu32 cmd;\n\tint ret;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase 1:\n\t\tcmd = RSB_CMD_RD8;\n\t\tbreak;\n\tcase 2:\n\t\tcmd = RSB_CMD_RD16;\n\t\tbreak;\n\tcase 4:\n\t\tcmd = RSB_CMD_RD32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rsb->dev, \"Invalid access width: %zd\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pm_runtime_resume_and_get(rsb->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rsb->lock);\n\n\twritel(addr, rsb->regs + RSB_ADDR);\n\twritel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);\n\twritel(cmd, rsb->regs + RSB_CMD);\n\n\tret = _sunxi_rsb_run_xfer(rsb);\n\tif (ret)\n\t\tgoto unlock;\n\n\t*buf = readl(rsb->regs + RSB_DATA) & GENMASK(len * 8 - 1, 0);\n\nunlock:\n\tmutex_unlock(&rsb->lock);\n\n\tpm_runtime_mark_last_busy(rsb->dev);\n\tpm_runtime_put_autosuspend(rsb->dev);\n\n\treturn ret;\n}\n\nstatic int sunxi_rsb_write(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,\n\t\t\t   const u32 *buf, size_t len)\n{\n\tu32 cmd;\n\tint ret;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase 1:\n\t\tcmd = RSB_CMD_WR8;\n\t\tbreak;\n\tcase 2:\n\t\tcmd = RSB_CMD_WR16;\n\t\tbreak;\n\tcase 4:\n\t\tcmd = RSB_CMD_WR32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rsb->dev, \"Invalid access width: %zd\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pm_runtime_resume_and_get(rsb->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rsb->lock);\n\n\twritel(addr, rsb->regs + RSB_ADDR);\n\twritel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);\n\twritel(*buf, rsb->regs + RSB_DATA);\n\twritel(cmd, rsb->regs + RSB_CMD);\n\tret = _sunxi_rsb_run_xfer(rsb);\n\n\tmutex_unlock(&rsb->lock);\n\n\tpm_runtime_mark_last_busy(rsb->dev);\n\tpm_runtime_put_autosuspend(rsb->dev);\n\n\treturn ret;\n}\n\n \nstruct sunxi_rsb_ctx {\n\tstruct sunxi_rsb_device *rdev;\n\tint size;\n};\n\nstatic int regmap_sunxi_rsb_reg_read(void *context, unsigned int reg,\n\t\t\t\t     unsigned int *val)\n{\n\tstruct sunxi_rsb_ctx *ctx = context;\n\tstruct sunxi_rsb_device *rdev = ctx->rdev;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\treturn sunxi_rsb_read(rdev->rsb, rdev->rtaddr, reg, val, ctx->size);\n}\n\nstatic int regmap_sunxi_rsb_reg_write(void *context, unsigned int reg,\n\t\t\t\t      unsigned int val)\n{\n\tstruct sunxi_rsb_ctx *ctx = context;\n\tstruct sunxi_rsb_device *rdev = ctx->rdev;\n\n\treturn sunxi_rsb_write(rdev->rsb, rdev->rtaddr, reg, &val, ctx->size);\n}\n\nstatic void regmap_sunxi_rsb_free_ctx(void *context)\n{\n\tstruct sunxi_rsb_ctx *ctx = context;\n\n\tkfree(ctx);\n}\n\nstatic struct regmap_bus regmap_sunxi_rsb = {\n\t.reg_write = regmap_sunxi_rsb_reg_write,\n\t.reg_read = regmap_sunxi_rsb_reg_read,\n\t.free_context = regmap_sunxi_rsb_free_ctx,\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n};\n\nstatic struct sunxi_rsb_ctx *regmap_sunxi_rsb_init_ctx(struct sunxi_rsb_device *rdev,\n\t\tconst struct regmap_config *config)\n{\n\tstruct sunxi_rsb_ctx *ctx;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\tcase 16:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->rdev = rdev;\n\tctx->size = config->val_bits / 8;\n\n\treturn ctx;\n}\n\nstruct regmap *__devm_regmap_init_sunxi_rsb(struct sunxi_rsb_device *rdev,\n\t\t\t\t\t    const struct regmap_config *config,\n\t\t\t\t\t    struct lock_class_key *lock_key,\n\t\t\t\t\t    const char *lock_name)\n{\n\tstruct sunxi_rsb_ctx *ctx = regmap_sunxi_rsb_init_ctx(rdev, config);\n\n\tif (IS_ERR(ctx))\n\t\treturn ERR_CAST(ctx);\n\n\treturn __devm_regmap_init(&rdev->dev, &regmap_sunxi_rsb, ctx, config,\n\t\t\t\t  lock_key, lock_name);\n}\nEXPORT_SYMBOL_GPL(__devm_regmap_init_sunxi_rsb);\n\n \nstatic irqreturn_t sunxi_rsb_irq(int irq, void *dev_id)\n{\n\tstruct sunxi_rsb *rsb = dev_id;\n\tu32 status;\n\n\tstatus = readl(rsb->regs + RSB_INTS);\n\trsb->status = status;\n\n\t \n\tstatus &= (RSB_INTS_LOAD_BSY | RSB_INTS_TRANS_ERR |\n\t\t   RSB_INTS_TRANS_OVER);\n\twritel(status, rsb->regs + RSB_INTS);\n\n\tcomplete(&rsb->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sunxi_rsb_init_device_mode(struct sunxi_rsb *rsb)\n{\n\tint ret = 0;\n\tu32 reg;\n\n\t \n\twritel(RSB_DMCR_DEVICE_START | RSB_DMCR_MODE_DATA |\n\t       RSB_DMCR_MODE_REG | RSB_DMCR_DEV_ADDR, rsb->regs + RSB_DMCR);\n\n\treadl_poll_timeout(rsb->regs + RSB_DMCR, reg,\n\t\t\t   !(reg & RSB_DMCR_DEVICE_START), 100, 250000);\n\tif (reg & RSB_DMCR_DEVICE_START)\n\t\tret = -ETIMEDOUT;\n\n\t \n\twritel(readl(rsb->regs + RSB_INTS), rsb->regs + RSB_INTS);\n\n\treturn ret;\n}\n\n \n\nstatic const struct sunxi_rsb_addr_map sunxi_rsb_addr_maps[] = {\n\t{ 0x3a3, 0x2d },  \n\t{ 0x745, 0x3a },  \n\t{ 0xe89, 0x4e },  \n};\n\nstatic u8 sunxi_rsb_get_rtaddr(u16 hwaddr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sunxi_rsb_addr_maps); i++)\n\t\tif (hwaddr == sunxi_rsb_addr_maps[i].hwaddr)\n\t\t\treturn sunxi_rsb_addr_maps[i].rtaddr;\n\n\treturn 0;  \n}\n\nstatic int of_rsb_register_devices(struct sunxi_rsb *rsb)\n{\n\tstruct device *dev = rsb->dev;\n\tstruct device_node *child, *np = dev->of_node;\n\tu32 hwaddr;\n\tu8 rtaddr;\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\tdev_dbg(dev, \"setting child %pOF runtime address\\n\",\n\t\t\tchild);\n\n\t\tret = of_property_read_u32(child, \"reg\", &hwaddr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%pOF: invalid 'reg' property: %d\\n\",\n\t\t\t\tchild, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\trtaddr = sunxi_rsb_get_rtaddr(hwaddr);\n\t\tif (!rtaddr) {\n\t\t\tdev_err(dev, \"%pOF: unknown hardware device address\\n\",\n\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\twritel(RSB_CMD_STRA, rsb->regs + RSB_CMD);\n\t\twritel(RSB_DAR_RTA(rtaddr) | RSB_DAR_DA(hwaddr),\n\t\t       rsb->regs + RSB_DAR);\n\n\t\t \n\t\tret = _sunxi_rsb_run_xfer(rsb);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"%pOF: set runtime address failed: %d\\n\",\n\t\t\t\t child, ret);\n\t}\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct sunxi_rsb_device *rdev;\n\n\t\tdev_dbg(dev, \"adding child %pOF\\n\", child);\n\n\t\tret = of_property_read_u32(child, \"reg\", &hwaddr);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\trtaddr = sunxi_rsb_get_rtaddr(hwaddr);\n\t\tif (!rtaddr)\n\t\t\tcontinue;\n\n\t\trdev = sunxi_rsb_device_create(rsb, child, hwaddr, rtaddr);\n\t\tif (IS_ERR(rdev))\n\t\t\tdev_err(dev, \"failed to add child device %pOF: %ld\\n\",\n\t\t\t\tchild, PTR_ERR(rdev));\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_rsb_hw_init(struct sunxi_rsb *rsb)\n{\n\tstruct device *dev = rsb->dev;\n\tunsigned long p_clk_freq;\n\tu32 clk_delay, reg;\n\tint clk_div, ret;\n\n\tret = clk_prepare_enable(rsb->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(rsb->rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert reset line: %d\\n\", ret);\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\twritel(RSB_CTRL_SOFT_RST, rsb->regs + RSB_CTRL);\n\treadl_poll_timeout(rsb->regs + RSB_CTRL, reg,\n\t\t\t   !(reg & RSB_CTRL_SOFT_RST), 1000, 100000);\n\n\t \n\tp_clk_freq = clk_get_rate(rsb->clk);\n\tclk_div = p_clk_freq / rsb->clk_freq / 2;\n\tif (!clk_div)\n\t\tclk_div = 1;\n\telse if (clk_div > RSB_CCR_MAX_CLK_DIV + 1)\n\t\tclk_div = RSB_CCR_MAX_CLK_DIV + 1;\n\n\tclk_delay = clk_div >> 1;\n\tif (!clk_delay)\n\t\tclk_delay = 1;\n\n\tdev_info(dev, \"RSB running at %lu Hz\\n\", p_clk_freq / clk_div / 2);\n\twritel(RSB_CCR_SDA_OUT_DELAY(clk_delay) | RSB_CCR_CLK_DIV(clk_div - 1),\n\t       rsb->regs + RSB_CCR);\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(rsb->clk);\n\n\treturn ret;\n}\n\nstatic void sunxi_rsb_hw_exit(struct sunxi_rsb *rsb)\n{\n\treset_control_assert(rsb->rstc);\n\n\t \n\tif (!pm_runtime_status_suspended(rsb->dev))\n\t\tclk_disable_unprepare(rsb->clk);\n}\n\nstatic int __maybe_unused sunxi_rsb_runtime_suspend(struct device *dev)\n{\n\tstruct sunxi_rsb *rsb = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(rsb->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sunxi_rsb_runtime_resume(struct device *dev)\n{\n\tstruct sunxi_rsb *rsb = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(rsb->clk);\n}\n\nstatic int __maybe_unused sunxi_rsb_suspend(struct device *dev)\n{\n\tstruct sunxi_rsb *rsb = dev_get_drvdata(dev);\n\n\tsunxi_rsb_hw_exit(rsb);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sunxi_rsb_resume(struct device *dev)\n{\n\tstruct sunxi_rsb *rsb = dev_get_drvdata(dev);\n\n\treturn sunxi_rsb_hw_init(rsb);\n}\n\nstatic int sunxi_rsb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sunxi_rsb *rsb;\n\tu32 clk_freq = 3000000;\n\tint irq, ret;\n\n\tof_property_read_u32(np, \"clock-frequency\", &clk_freq);\n\tif (clk_freq > RSB_MAX_FREQ) {\n\t\tdev_err(dev,\n\t\t\t\"clock-frequency (%u Hz) is too high (max = 20MHz)\\n\",\n\t\t\tclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\trsb = devm_kzalloc(dev, sizeof(*rsb), GFP_KERNEL);\n\tif (!rsb)\n\t\treturn -ENOMEM;\n\n\trsb->dev = dev;\n\trsb->clk_freq = clk_freq;\n\tplatform_set_drvdata(pdev, rsb);\n\trsb->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rsb->regs))\n\t\treturn PTR_ERR(rsb->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\trsb->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(rsb->clk)) {\n\t\tret = PTR_ERR(rsb->clk);\n\t\tdev_err(dev, \"failed to retrieve clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trsb->rstc = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(rsb->rstc)) {\n\t\tret = PTR_ERR(rsb->rstc);\n\t\tdev_err(dev, \"failed to retrieve reset controller: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&rsb->complete);\n\tmutex_init(&rsb->lock);\n\n\tret = devm_request_irq(dev, irq, sunxi_rsb_irq, 0, RSB_CTRL_NAME, rsb);\n\tif (ret) {\n\t\tdev_err(dev, \"can't register interrupt handler irq %d: %d\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tret = sunxi_rsb_hw_init(rsb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = sunxi_rsb_init_device_mode(rsb);\n\tif (ret)\n\t\tdev_warn(dev, \"Initialize device mode failed: %d\\n\", ret);\n\n\tpm_suspend_ignore_children(dev, true);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_set_autosuspend_delay(dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\tof_rsb_register_devices(rsb);\n\n\treturn 0;\n}\n\nstatic int sunxi_rsb_remove(struct platform_device *pdev)\n{\n\tstruct sunxi_rsb *rsb = platform_get_drvdata(pdev);\n\n\tdevice_for_each_child(rsb->dev, NULL, sunxi_rsb_remove_devices);\n\tpm_runtime_disable(&pdev->dev);\n\tsunxi_rsb_hw_exit(rsb);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sunxi_rsb_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sunxi_rsb_runtime_suspend,\n\t\t\t   sunxi_rsb_runtime_resume, NULL)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sunxi_rsb_suspend, sunxi_rsb_resume)\n};\n\nstatic const struct of_device_id sunxi_rsb_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun8i-a23-rsb\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sunxi_rsb_of_match_table);\n\nstatic struct platform_driver sunxi_rsb_driver = {\n\t.probe = sunxi_rsb_probe,\n\t.remove\t= sunxi_rsb_remove,\n\t.driver\t= {\n\t\t.name = RSB_CTRL_NAME,\n\t\t.of_match_table = sunxi_rsb_of_match_table,\n\t\t.pm = &sunxi_rsb_dev_pm_ops,\n\t},\n};\n\nstatic int __init sunxi_rsb_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&sunxi_rsb_bus);\n\tif (ret) {\n\t\tpr_err(\"failed to register sunxi sunxi_rsb bus: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = platform_driver_register(&sunxi_rsb_driver);\n\tif (ret) {\n\t\tbus_unregister(&sunxi_rsb_bus);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(sunxi_rsb_init);\n\nstatic void __exit sunxi_rsb_exit(void)\n{\n\tplatform_driver_unregister(&sunxi_rsb_driver);\n\tbus_unregister(&sunxi_rsb_bus);\n}\nmodule_exit(sunxi_rsb_exit);\n\nMODULE_AUTHOR(\"Chen-Yu Tsai <wens@csie.org>\");\nMODULE_DESCRIPTION(\"Allwinner sunXi Reduced Serial Bus controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}