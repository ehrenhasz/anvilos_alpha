{
  "module_name": "intel-ixp4xx-eb.c",
  "hash_id": "5acf6d646c37d95fc9a1df09b687e79cd37ab84e55a2720bde21059100a88f30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/intel-ixp4xx-eb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/log2.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define IXP4XX_EXP_NUM_CS\t\t8\n\n#define IXP4XX_EXP_TIMING_CS0\t\t0x00\n#define IXP4XX_EXP_TIMING_CS1\t\t0x04\n#define IXP4XX_EXP_TIMING_CS2\t\t0x08\n#define IXP4XX_EXP_TIMING_CS3\t\t0x0c\n#define IXP4XX_EXP_TIMING_CS4\t\t0x10\n#define IXP4XX_EXP_TIMING_CS5\t\t0x14\n#define IXP4XX_EXP_TIMING_CS6\t\t0x18\n#define IXP4XX_EXP_TIMING_CS7\t\t0x1c\n\n \n#define IXP4XX_EXP_TIMING_STRIDE\t0x04\n#define IXP4XX_EXP_CS_EN\t\tBIT(31)\n#define IXP456_EXP_PAR_EN\t\tBIT(30)  \n#define IXP4XX_EXP_T1_MASK\t\tGENMASK(29, 28)\n#define IXP4XX_EXP_T1_SHIFT\t\t28\n#define IXP4XX_EXP_T2_MASK\t\tGENMASK(27, 26)\n#define IXP4XX_EXP_T2_SHIFT\t\t26\n#define IXP4XX_EXP_T3_MASK\t\tGENMASK(25, 22)\n#define IXP4XX_EXP_T3_SHIFT\t\t22\n#define IXP4XX_EXP_T4_MASK\t\tGENMASK(21, 20)\n#define IXP4XX_EXP_T4_SHIFT\t\t20\n#define IXP4XX_EXP_T5_MASK\t\tGENMASK(19, 16)\n#define IXP4XX_EXP_T5_SHIFT\t\t16\n#define IXP4XX_EXP_CYC_TYPE_MASK\tGENMASK(15, 14)\n#define IXP4XX_EXP_CYC_TYPE_SHIFT\t14\n#define IXP4XX_EXP_SIZE_MASK\t\tGENMASK(13, 10)\n#define IXP4XX_EXP_SIZE_SHIFT\t\t10\n#define IXP4XX_EXP_CNFG_0\t\tBIT(9)  \n#define IXP43X_EXP_SYNC_INTEL\t\tBIT(8)  \n#define IXP43X_EXP_EXP_CHIP\t\tBIT(7)  \n#define IXP4XX_EXP_BYTE_RD16\t\tBIT(6)\n#define IXP4XX_EXP_HRDY_POL\t\tBIT(5)  \n#define IXP4XX_EXP_MUX_EN\t\tBIT(4)\n#define IXP4XX_EXP_SPLT_EN\t\tBIT(3)\n#define IXP4XX_EXP_WORD\t\t\tBIT(2)  \n#define IXP4XX_EXP_WR_EN\t\tBIT(1)\n#define IXP4XX_EXP_BYTE_EN\t\tBIT(0)\n\n#define IXP4XX_EXP_CNFG0\t\t0x20\n#define IXP4XX_EXP_CNFG0_MEM_MAP\tBIT(31)\n#define IXP4XX_EXP_CNFG1\t\t0x24\n\n#define IXP4XX_EXP_BOOT_BASE\t\t0x00000000\n#define IXP4XX_EXP_NORMAL_BASE\t\t0x50000000\n#define IXP4XX_EXP_STRIDE\t\t0x01000000\n\n \n#define IXP43X_EXP_UNIT_FUSE_RESET\t0x28\n#define IXP43x_EXP_FUSE_SPEED_MASK\tGENMASK(23, 22)\n\n \n#define IXP4XX_OF_REG_SIZE\t\t3\n\nstruct ixp4xx_eb {\n\tstruct device *dev;\n\tstruct regmap *rmap;\n\tu32 bus_base;\n\tbool is_42x;\n\tbool is_43x;\n};\n\nstruct ixp4xx_exp_tim_prop {\n\tconst char *prop;\n\tu32 max;\n\tu32 mask;\n\tu16 shift;\n};\n\nstatic const struct ixp4xx_exp_tim_prop ixp4xx_exp_tim_props[] = {\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-t1\",\n\t\t.max = 3,\n\t\t.mask = IXP4XX_EXP_T1_MASK,\n\t\t.shift = IXP4XX_EXP_T1_SHIFT,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-t2\",\n\t\t.max = 3,\n\t\t.mask = IXP4XX_EXP_T2_MASK,\n\t\t.shift = IXP4XX_EXP_T2_SHIFT,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-t3\",\n\t\t.max = 15,\n\t\t.mask = IXP4XX_EXP_T3_MASK,\n\t\t.shift = IXP4XX_EXP_T3_SHIFT,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-t4\",\n\t\t.max = 3,\n\t\t.mask = IXP4XX_EXP_T4_MASK,\n\t\t.shift = IXP4XX_EXP_T4_SHIFT,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-t5\",\n\t\t.max = 15,\n\t\t.mask = IXP4XX_EXP_T5_MASK,\n\t\t.shift = IXP4XX_EXP_T5_SHIFT,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-byte-access-on-halfword\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_BYTE_RD16,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-hpi-hrdy-pol-high\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_HRDY_POL,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-mux-address-and-data\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_MUX_EN,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-ahb-split-transfers\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_SPLT_EN,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-write-enable\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_WR_EN,\n\t},\n\t{\n\t\t.prop = \"intel,ixp4xx-eb-byte-access\",\n\t\t.max = 1,\n\t\t.mask = IXP4XX_EXP_BYTE_EN,\n\t},\n};\n\nstatic void ixp4xx_exp_setup_chipselect(struct ixp4xx_eb *eb,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tu32 cs_index,\n\t\t\t\t\tu32 cs_size)\n{\n\tu32 cs_cfg;\n\tu32 val;\n\tu32 cur_cssize;\n\tu32 cs_order;\n\tint ret;\n\tint i;\n\n\tif (eb->is_42x && (cs_index > 7)) {\n\t\tdev_err(eb->dev,\n\t\t\t\"invalid chipselect %u, we only support 0-7\\n\",\n\t\t\tcs_index);\n\t\treturn;\n\t}\n\tif (eb->is_43x && (cs_index > 3)) {\n\t\tdev_err(eb->dev,\n\t\t\t\"invalid chipselect %u, we only support 0-3\\n\",\n\t\t\tcs_index);\n\t\treturn;\n\t}\n\n\t \n\tif (cs_size > IXP4XX_EXP_STRIDE)\n\t\tcur_cssize = IXP4XX_EXP_STRIDE;\n\telse\n\t\tcur_cssize = cs_size;\n\n\n\t \n\tregmap_read(eb->rmap, IXP4XX_EXP_TIMING_CS0 +\n\t\t    IXP4XX_EXP_TIMING_STRIDE * cs_index, &cs_cfg);\n\tdev_info(eb->dev, \"CS%d at %#08x, size %#08x, config before: %#08x\\n\",\n\t\t cs_index, eb->bus_base + IXP4XX_EXP_STRIDE * cs_index,\n\t\t cur_cssize, cs_cfg);\n\n\t \n\tcur_cssize = roundup_pow_of_two(cur_cssize);\n\tif (cur_cssize < 512)\n\t\tcur_cssize = 512;\n\tcs_order = ilog2(cur_cssize);\n\tif (cs_order < 9 || cs_order > 24) {\n\t\tdev_err(eb->dev, \"illegal size order %d\\n\", cs_order);\n\t\treturn;\n\t}\n\tdev_dbg(eb->dev, \"CS%d size order: %d\\n\", cs_index, cs_order);\n\tcs_cfg &= ~(IXP4XX_EXP_SIZE_MASK);\n\tcs_cfg |= ((cs_order - 9) << IXP4XX_EXP_SIZE_SHIFT);\n\n\tfor (i = 0; i < ARRAY_SIZE(ixp4xx_exp_tim_props); i++) {\n\t\tconst struct ixp4xx_exp_tim_prop *ip = &ixp4xx_exp_tim_props[i];\n\n\t\t \n\t\tret = of_property_read_u32(np, ip->prop, &val);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ip->max == 1) {\n\t\t\tif (val)\n\t\t\t\tcs_cfg |= ip->mask;\n\t\t\telse\n\t\t\t\tcs_cfg &= ~ip->mask;\n\t\t\tdev_info(eb->dev, \"CS%d %s %s\\n\", cs_index,\n\t\t\t\t val ? \"enabled\" : \"disabled\",\n\t\t\t\t ip->prop);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (val > ip->max) {\n\t\t\tdev_err(eb->dev,\n\t\t\t\t\"CS%d too high value for %s: %u, capped at %u\\n\",\n\t\t\t\tcs_index, ip->prop, val, ip->max);\n\t\t\tval = ip->max;\n\t\t}\n\t\t \n\t\tcs_cfg &= ~ip->mask;\n\t\tcs_cfg |= (val << ip->shift);\n\t\tdev_info(eb->dev, \"CS%d set %s to %u\\n\", cs_index, ip->prop, val);\n\t}\n\n\tret = of_property_read_u32(np, \"intel,ixp4xx-eb-cycle-type\", &val);\n\tif (!ret) {\n\t\tif (val > 3) {\n\t\t\tdev_err(eb->dev, \"illegal cycle type %d\\n\", val);\n\t\t\treturn;\n\t\t}\n\t\tdev_info(eb->dev, \"CS%d set cycle type %d\\n\", cs_index, val);\n\t\tcs_cfg &= ~IXP4XX_EXP_CYC_TYPE_MASK;\n\t\tcs_cfg |= val << IXP4XX_EXP_CYC_TYPE_SHIFT;\n\t}\n\n\tif (eb->is_43x) {\n\t\t \n\t\tcs_cfg &= ~IXP4XX_EXP_WORD;\n\t\t \n\t\tif (cs_cfg & IXP43X_EXP_SYNC_INTEL)\n\t\t\tdev_info(eb->dev, \"claims to be Intel strata flash\\n\");\n\t}\n\tcs_cfg |= IXP4XX_EXP_CS_EN;\n\n\tregmap_write(eb->rmap,\n\t\t     IXP4XX_EXP_TIMING_CS0 + IXP4XX_EXP_TIMING_STRIDE * cs_index,\n\t\t     cs_cfg);\n\tdev_info(eb->dev, \"CS%d wrote %#08x into CS config\\n\", cs_index, cs_cfg);\n\n\t \n\tif (cs_size > IXP4XX_EXP_STRIDE)\n\t\tixp4xx_exp_setup_chipselect(eb, np,\n\t\t\t\t\t    cs_index + 1,\n\t\t\t\t\t    cs_size - IXP4XX_EXP_STRIDE);\n}\n\nstatic void ixp4xx_exp_setup_child(struct ixp4xx_eb *eb,\n\t\t\t\t   struct device_node *np)\n{\n\tu32 cs_sizes[IXP4XX_EXP_NUM_CS];\n\tint num_regs;\n\tu32 csindex;\n\tu32 cssize;\n\tint ret;\n\tint i;\n\n\tnum_regs = of_property_count_elems_of_size(np, \"reg\", IXP4XX_OF_REG_SIZE);\n\tif (num_regs <= 0)\n\t\treturn;\n\tdev_dbg(eb->dev, \"child %s has %d register sets\\n\",\n\t\tof_node_full_name(np), num_regs);\n\n\tfor (csindex = 0; csindex < IXP4XX_EXP_NUM_CS; csindex++)\n\t\tcs_sizes[csindex] = 0;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tu32 rbase, rsize;\n\n\t\tret = of_property_read_u32_index(np, \"reg\",\n\t\t\t\t\t\t i * IXP4XX_OF_REG_SIZE, &csindex);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = of_property_read_u32_index(np, \"reg\",\n\t\t\t\t\t\t i * IXP4XX_OF_REG_SIZE + 1, &rbase);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = of_property_read_u32_index(np, \"reg\",\n\t\t\t\t\t\t i * IXP4XX_OF_REG_SIZE + 2, &rsize);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (csindex >= IXP4XX_EXP_NUM_CS) {\n\t\t\tdev_err(eb->dev, \"illegal CS %d\\n\", csindex);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tcssize = rbase + rsize;\n\t\tdev_dbg(eb->dev, \"CS%d size %#08x\\n\", csindex, cssize);\n\t\tif (cs_sizes[csindex] < cssize)\n\t\t\tcs_sizes[csindex] = cssize;\n\t}\n\n\tfor (csindex = 0; csindex < IXP4XX_EXP_NUM_CS; csindex++) {\n\t\tcssize = cs_sizes[csindex];\n\t\tif (!cssize)\n\t\t\tcontinue;\n\t\t \n\t\tixp4xx_exp_setup_chipselect(eb, np, csindex, cssize);\n\t}\n}\n\nstatic int ixp4xx_exp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ixp4xx_eb *eb;\n\tstruct device_node *child;\n\tbool have_children = false;\n\tu32 val;\n\tint ret;\n\n\teb = devm_kzalloc(dev, sizeof(*eb), GFP_KERNEL);\n\tif (!eb)\n\t\treturn -ENOMEM;\n\n\teb->dev = dev;\n\teb->is_42x = of_device_is_compatible(np, \"intel,ixp42x-expansion-bus-controller\");\n\teb->is_43x = of_device_is_compatible(np, \"intel,ixp43x-expansion-bus-controller\");\n\n\teb->rmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(eb->rmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(eb->rmap), \"no regmap\\n\");\n\n\t \n\tret = regmap_read(eb->rmap, IXP4XX_EXP_CNFG0, &val);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot read regmap\\n\");\n\tif (val & IXP4XX_EXP_CNFG0_MEM_MAP)\n\t\teb->bus_base = IXP4XX_EXP_BOOT_BASE;\n\telse\n\t\teb->bus_base = IXP4XX_EXP_NORMAL_BASE;\n\tdev_info(dev, \"expansion bus at %08x\\n\", eb->bus_base);\n\n\tif (eb->is_43x) {\n\t\t \n\t\tregmap_read(eb->rmap, IXP43X_EXP_UNIT_FUSE_RESET, &val);\n\t\tswitch (FIELD_GET(IXP43x_EXP_FUSE_SPEED_MASK, val)) {\n\t\tcase 0:\n\t\t\tdev_info(dev, \"IXP43x at 533 MHz\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_info(dev, \"IXP43x at 400 MHz\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_info(dev, \"IXP43x at 667 MHz\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(dev, \"IXP43x unknown speed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\tixp4xx_exp_setup_child(eb, child);\n\t\t \n\t\thave_children = true;\n\t}\n\n\tif (have_children)\n\t\treturn of_platform_default_populate(np, NULL, dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ixp4xx_exp_of_match[] = {\n\t{ .compatible = \"intel,ixp42x-expansion-bus-controller\", },\n\t{ .compatible = \"intel,ixp43x-expansion-bus-controller\", },\n\t{ .compatible = \"intel,ixp45x-expansion-bus-controller\", },\n\t{ .compatible = \"intel,ixp46x-expansion-bus-controller\", },\n\t{ }\n};\n\nstatic struct platform_driver ixp4xx_exp_driver = {\n\t.probe = ixp4xx_exp_probe,\n\t.driver = {\n\t\t.name = \"intel-extbus\",\n\t\t.of_match_table = ixp4xx_exp_of_match,\n\t},\n};\nmodule_platform_driver(ixp4xx_exp_driver);\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Intel IXP4xx external bus driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}