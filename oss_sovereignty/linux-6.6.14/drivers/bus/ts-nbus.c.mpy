{
  "module_name": "ts-nbus.c",
  "hash_id": "61fad41d869e17f527f182bcd90b61b9aac546a88ce0dbd2b0dafbe51420f401",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/ts-nbus.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/ts-nbus.h>\n\n#define TS_NBUS_DIRECTION_IN  0\n#define TS_NBUS_DIRECTION_OUT 1\n#define TS_NBUS_WRITE_ADR 0\n#define TS_NBUS_WRITE_VAL 1\n\nstruct ts_nbus {\n\tstruct pwm_device *pwm;\n\tstruct gpio_descs *data;\n\tstruct gpio_desc *csn;\n\tstruct gpio_desc *txrx;\n\tstruct gpio_desc *strobe;\n\tstruct gpio_desc *ale;\n\tstruct gpio_desc *rdy;\n\tstruct mutex lock;\n};\n\n \nstatic int ts_nbus_init_pdata(struct platform_device *pdev, struct ts_nbus\n\t\t*ts_nbus)\n{\n\tts_nbus->data = devm_gpiod_get_array(&pdev->dev, \"ts,data\",\n\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(ts_nbus->data)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,data-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->data);\n\t}\n\n\tts_nbus->csn = devm_gpiod_get(&pdev->dev, \"ts,csn\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts_nbus->csn)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,csn-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->csn);\n\t}\n\n\tts_nbus->txrx = devm_gpiod_get(&pdev->dev, \"ts,txrx\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts_nbus->txrx)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,txrx-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->txrx);\n\t}\n\n\tts_nbus->strobe = devm_gpiod_get(&pdev->dev, \"ts,strobe\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts_nbus->strobe)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,strobe-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->strobe);\n\t}\n\n\tts_nbus->ale = devm_gpiod_get(&pdev->dev, \"ts,ale\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts_nbus->ale)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,ale-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->ale);\n\t}\n\n\tts_nbus->rdy = devm_gpiod_get(&pdev->dev, \"ts,rdy\", GPIOD_IN);\n\tif (IS_ERR(ts_nbus->rdy)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve ts,rdy-gpio from dts\\n\");\n\t\treturn PTR_ERR(ts_nbus->rdy);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ts_nbus_set_direction(struct ts_nbus *ts_nbus, int direction)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (direction == TS_NBUS_DIRECTION_IN)\n\t\t\tgpiod_direction_input(ts_nbus->data->desc[i]);\n\t\telse\n\t\t\t \n\t\t\tgpiod_direction_output(ts_nbus->data->desc[i], 1);\n\t}\n}\n\n \nstatic void ts_nbus_reset_bus(struct ts_nbus *ts_nbus)\n{\n\tDECLARE_BITMAP(values, 8);\n\n\tvalues[0] = 0;\n\n\tgpiod_set_array_value_cansleep(8, ts_nbus->data->desc,\n\t\t\t\t       ts_nbus->data->info, values);\n\tgpiod_set_value_cansleep(ts_nbus->csn, 0);\n\tgpiod_set_value_cansleep(ts_nbus->strobe, 0);\n\tgpiod_set_value_cansleep(ts_nbus->ale, 0);\n}\n\n \nstatic void ts_nbus_start_transaction(struct ts_nbus *ts_nbus)\n{\n\tgpiod_set_value_cansleep(ts_nbus->strobe, 1);\n}\n\n \nstatic int ts_nbus_read_byte(struct ts_nbus *ts_nbus, u8 *val)\n{\n\tstruct gpio_descs *gpios = ts_nbus->data;\n\tint ret, i;\n\n\t*val = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tret = gpiod_get_value_cansleep(gpios->desc[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\t*val |= BIT(i);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ts_nbus_write_byte(struct ts_nbus *ts_nbus, u8 byte)\n{\n\tstruct gpio_descs *gpios = ts_nbus->data;\n\tDECLARE_BITMAP(values, 8);\n\n\tvalues[0] = byte;\n\n\tgpiod_set_array_value_cansleep(8, gpios->desc, gpios->info, values);\n}\n\n \nstatic int ts_nbus_read_bus(struct ts_nbus *ts_nbus, u8 *val)\n{\n\tts_nbus_reset_bus(ts_nbus);\n\tts_nbus_start_transaction(ts_nbus);\n\n\treturn ts_nbus_read_byte(ts_nbus, val);\n}\n\n \nstatic void ts_nbus_write_bus(struct ts_nbus *ts_nbus, int cmd, u8 val)\n{\n\tts_nbus_reset_bus(ts_nbus);\n\n\tif (cmd == TS_NBUS_WRITE_ADR)\n\t\tgpiod_set_value_cansleep(ts_nbus->ale, 1);\n\n\tts_nbus_write_byte(ts_nbus, val);\n\tts_nbus_start_transaction(ts_nbus);\n}\n\n \nint ts_nbus_read(struct ts_nbus *ts_nbus, u8 adr, u16 *val)\n{\n\tint ret, i;\n\tu8 byte;\n\n\t \n\tmutex_lock(&ts_nbus->lock);\n\n\t \n\tgpiod_set_value_cansleep(ts_nbus->txrx, 0);\n\n\t \n\tts_nbus_write_bus(ts_nbus, TS_NBUS_WRITE_ADR, adr);\n\n\t \n\tts_nbus_set_direction(ts_nbus, TS_NBUS_DIRECTION_IN);\n\n\t \n\tdo {\n\t\t*val = 0;\n\t\tbyte = 0;\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\t \n\t\t\tret = ts_nbus_read_bus(ts_nbus, &byte);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\t*val |= byte << (i * 8);\n\t\t}\n\t\tgpiod_set_value_cansleep(ts_nbus->csn, 1);\n\t\tret = gpiod_get_value_cansleep(ts_nbus->rdy);\n\t} while (ret);\n\nerr:\n\t \n\tts_nbus_set_direction(ts_nbus, TS_NBUS_DIRECTION_OUT);\n\n\tmutex_unlock(&ts_nbus->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ts_nbus_read);\n\n \nint ts_nbus_write(struct ts_nbus *ts_nbus, u8 adr, u16 val)\n{\n\tint i;\n\n\t \n\tmutex_lock(&ts_nbus->lock);\n\n\t \n\tgpiod_set_value_cansleep(ts_nbus->txrx, 1);\n\n\t \n\tts_nbus_write_bus(ts_nbus, TS_NBUS_WRITE_ADR, adr);\n\n\t \n\tfor (i = 1; i >= 0; i--)\n\t\tts_nbus_write_bus(ts_nbus, TS_NBUS_WRITE_VAL, (u8)(val >> (i * 8)));\n\n\t \n\tgpiod_set_value_cansleep(ts_nbus->csn, 1);\n\twhile (gpiod_get_value_cansleep(ts_nbus->rdy) != 0) {\n\t\tgpiod_set_value_cansleep(ts_nbus->csn, 0);\n\t\tgpiod_set_value_cansleep(ts_nbus->csn, 1);\n\t}\n\n\tmutex_unlock(&ts_nbus->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ts_nbus_write);\n\nstatic int ts_nbus_probe(struct platform_device *pdev)\n{\n\tstruct pwm_device *pwm;\n\tstruct pwm_args pargs;\n\tstruct device *dev = &pdev->dev;\n\tstruct ts_nbus *ts_nbus;\n\tint ret;\n\n\tts_nbus = devm_kzalloc(dev, sizeof(*ts_nbus), GFP_KERNEL);\n\tif (!ts_nbus)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ts_nbus->lock);\n\n\tret = ts_nbus_init_pdata(pdev, ts_nbus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpwm = devm_pwm_get(dev, NULL);\n\tif (IS_ERR(pwm)) {\n\t\tret = PTR_ERR(pwm);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"unable to request PWM\\n\");\n\t\treturn ret;\n\t}\n\n\tpwm_get_args(pwm, &pargs);\n\tif (!pargs.period) {\n\t\tdev_err(&pdev->dev, \"invalid PWM period\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpwm_apply_args(pwm);\n\tret = pwm_config(pwm, pargs.period, pargs.period);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpwm_enable(pwm);\n\tts_nbus->pwm = pwm;\n\n\t \n\tdev_set_drvdata(dev, ts_nbus);\n\n\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"initialized\\n\");\n\n\treturn 0;\n}\n\nstatic int ts_nbus_remove(struct platform_device *pdev)\n{\n\tstruct ts_nbus *ts_nbus = dev_get_drvdata(&pdev->dev);\n\n\t \n\tmutex_lock(&ts_nbus->lock);\n\tpwm_disable(ts_nbus->pwm);\n\tmutex_unlock(&ts_nbus->lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ts_nbus_of_match[] = {\n\t{ .compatible = \"technologic,ts-nbus\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ts_nbus_of_match);\n\nstatic struct platform_driver ts_nbus_driver = {\n\t.probe\t\t= ts_nbus_probe,\n\t.remove\t\t= ts_nbus_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ts_nbus\",\n\t\t.of_match_table = ts_nbus_of_match,\n\t},\n};\n\nmodule_platform_driver(ts_nbus_driver);\n\nMODULE_ALIAS(\"platform:ts_nbus\");\nMODULE_AUTHOR(\"Sebastien Bourdelin <sebastien.bourdelin@savoirfairelinux.com>\");\nMODULE_DESCRIPTION(\"Technologic Systems NBUS\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}