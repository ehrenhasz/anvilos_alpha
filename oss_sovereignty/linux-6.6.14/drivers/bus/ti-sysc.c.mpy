{
  "module_name": "ti-sysc.c",
  "hash_id": "2338b51401b4bb715caf8bb3316c0e9416ed823e62a1a5c543d8724d0d137c4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bus/ti-sysc.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/cpu_pm.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n#include <linux/timekeeping.h>\n#include <linux/iopoll.h>\n\n#include <linux/platform_data/ti-sysc.h>\n\n#include <dt-bindings/bus/ti-sysc.h>\n\n#define DIS_ISP\t\tBIT(2)\n#define DIS_IVA\t\tBIT(1)\n#define DIS_SGX\t\tBIT(0)\n\n#define SOC_FLAG(match, flag)\t{ .machine = match, .data = (void *)(flag), }\n\n#define MAX_MODULE_SOFTRESET_WAIT\t\t10000\n\nenum sysc_soc {\n\tSOC_UNKNOWN,\n\tSOC_2420,\n\tSOC_2430,\n\tSOC_3430,\n\tSOC_AM35,\n\tSOC_3630,\n\tSOC_4430,\n\tSOC_4460,\n\tSOC_4470,\n\tSOC_5430,\n\tSOC_AM3,\n\tSOC_AM4,\n\tSOC_DRA7,\n};\n\nstruct sysc_address {\n\tunsigned long base;\n\tstruct list_head node;\n};\n\nstruct sysc_module {\n\tstruct sysc *ddata;\n\tstruct list_head node;\n};\n\nstruct sysc_soc_info {\n\tunsigned long general_purpose:1;\n\tenum sysc_soc soc;\n\tstruct mutex list_lock;\t \n\tstruct list_head disabled_modules;\n\tstruct list_head restored_modules;\n\tstruct notifier_block nb;\n};\n\nenum sysc_clocks {\n\tSYSC_FCK,\n\tSYSC_ICK,\n\tSYSC_OPTFCK0,\n\tSYSC_OPTFCK1,\n\tSYSC_OPTFCK2,\n\tSYSC_OPTFCK3,\n\tSYSC_OPTFCK4,\n\tSYSC_OPTFCK5,\n\tSYSC_OPTFCK6,\n\tSYSC_OPTFCK7,\n\tSYSC_MAX_CLOCKS,\n};\n\nstatic struct sysc_soc_info *sysc_soc;\nstatic const char * const reg_names[] = { \"rev\", \"sysc\", \"syss\", };\nstatic const char * const clock_names[SYSC_MAX_CLOCKS] = {\n\t\"fck\", \"ick\", \"opt0\", \"opt1\", \"opt2\", \"opt3\", \"opt4\",\n\t\"opt5\", \"opt6\", \"opt7\",\n};\n\n#define SYSC_IDLEMODE_MASK\t\t3\n#define SYSC_CLOCKACTIVITY_MASK\t\t3\n\n \nstruct sysc {\n\tstruct device *dev;\n\tu64 module_pa;\n\tu32 module_size;\n\tvoid __iomem *module_va;\n\tint offsets[SYSC_MAX_REGS];\n\tstruct ti_sysc_module_data *mdata;\n\tstruct clk **clocks;\n\tconst char **clock_roles;\n\tint nr_clocks;\n\tstruct reset_control *rsts;\n\tconst char *legacy_mode;\n\tconst struct sysc_capabilities *cap;\n\tstruct sysc_config cfg;\n\tstruct ti_sysc_cookie cookie;\n\tconst char *name;\n\tu32 revision;\n\tu32 sysconfig;\n\tunsigned int reserved:1;\n\tunsigned int enabled:1;\n\tunsigned int needs_resume:1;\n\tunsigned int child_needs_resume:1;\n\tstruct delayed_work idle_work;\n\tvoid (*pre_reset_quirk)(struct sysc *sysc);\n\tvoid (*post_reset_quirk)(struct sysc *sysc);\n\tvoid (*reset_done_quirk)(struct sysc *sysc);\n\tvoid (*module_enable_quirk)(struct sysc *sysc);\n\tvoid (*module_disable_quirk)(struct sysc *sysc);\n\tvoid (*module_unlock_quirk)(struct sysc *sysc);\n\tvoid (*module_lock_quirk)(struct sysc *sysc);\n};\n\nstatic void sysc_parse_dts_quirks(struct sysc *ddata, struct device_node *np,\n\t\t\t\t  bool is_child);\nstatic int sysc_reset(struct sysc *ddata);\n\nstatic void sysc_write(struct sysc *ddata, int offset, u32 value)\n{\n\tif (ddata->cfg.quirks & SYSC_QUIRK_16BIT) {\n\t\twritew_relaxed(value & 0xffff, ddata->module_va + offset);\n\n\t\t \n\t\tif (ddata->offsets[SYSC_REVISION] >= 0 &&\n\t\t    offset == ddata->offsets[SYSC_REVISION]) {\n\t\t\tu16 hi = value >> 16;\n\n\t\t\twritew_relaxed(hi, ddata->module_va + offset + 4);\n\t\t}\n\n\t\treturn;\n\t}\n\n\twritel_relaxed(value, ddata->module_va + offset);\n}\n\nstatic u32 sysc_read(struct sysc *ddata, int offset)\n{\n\tif (ddata->cfg.quirks & SYSC_QUIRK_16BIT) {\n\t\tu32 val;\n\n\t\tval = readw_relaxed(ddata->module_va + offset);\n\n\t\t \n\t\tif (ddata->offsets[SYSC_REVISION] >= 0 &&\n\t\t    offset == ddata->offsets[SYSC_REVISION]) {\n\t\t\tu16 tmp = readw_relaxed(ddata->module_va + offset + 4);\n\n\t\t\tval |= tmp << 16;\n\t\t}\n\n\t\treturn val;\n\t}\n\n\treturn readl_relaxed(ddata->module_va + offset);\n}\n\nstatic bool sysc_opt_clks_needed(struct sysc *ddata)\n{\n\treturn !!(ddata->cfg.quirks & SYSC_QUIRK_OPT_CLKS_NEEDED);\n}\n\nstatic u32 sysc_read_revision(struct sysc *ddata)\n{\n\tint offset = ddata->offsets[SYSC_REVISION];\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\treturn sysc_read(ddata, offset);\n}\n\nstatic u32 sysc_read_sysconfig(struct sysc *ddata)\n{\n\tint offset = ddata->offsets[SYSC_SYSCONFIG];\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\treturn sysc_read(ddata, offset);\n}\n\nstatic u32 sysc_read_sysstatus(struct sysc *ddata)\n{\n\tint offset = ddata->offsets[SYSC_SYSSTATUS];\n\n\tif (offset < 0)\n\t\treturn 0;\n\n\treturn sysc_read(ddata, offset);\n}\n\nstatic int sysc_poll_reset_sysstatus(struct sysc *ddata)\n{\n\tint error, retries;\n\tu32 syss_done, rstval;\n\n\tif (ddata->cfg.quirks & SYSS_QUIRK_RESETDONE_INVERTED)\n\t\tsyss_done = 0;\n\telse\n\t\tsyss_done = ddata->cfg.syss_mask;\n\n\tif (likely(!timekeeping_suspended)) {\n\t\terror = readx_poll_timeout_atomic(sysc_read_sysstatus, ddata,\n\t\t\t\trstval, (rstval & ddata->cfg.syss_mask) ==\n\t\t\t\tsyss_done, 100, MAX_MODULE_SOFTRESET_WAIT);\n\t} else {\n\t\tretries = MAX_MODULE_SOFTRESET_WAIT;\n\t\twhile (retries--) {\n\t\t\trstval = sysc_read_sysstatus(ddata);\n\t\t\tif ((rstval & ddata->cfg.syss_mask) == syss_done)\n\t\t\t\treturn 0;\n\t\t\tudelay(2);  \n\t\t}\n\t\terror = -ETIMEDOUT;\n\t}\n\n\treturn error;\n}\n\nstatic int sysc_poll_reset_sysconfig(struct sysc *ddata)\n{\n\tint error, retries;\n\tu32 sysc_mask, rstval;\n\n\tsysc_mask = BIT(ddata->cap->regbits->srst_shift);\n\n\tif (likely(!timekeeping_suspended)) {\n\t\terror = readx_poll_timeout_atomic(sysc_read_sysconfig, ddata,\n\t\t\t\trstval, !(rstval & sysc_mask),\n\t\t\t\t100, MAX_MODULE_SOFTRESET_WAIT);\n\t} else {\n\t\tretries = MAX_MODULE_SOFTRESET_WAIT;\n\t\twhile (retries--) {\n\t\t\trstval = sysc_read_sysconfig(ddata);\n\t\t\tif (!(rstval & sysc_mask))\n\t\t\t\treturn 0;\n\t\t\tudelay(2);  \n\t\t}\n\t\terror = -ETIMEDOUT;\n\t}\n\n\treturn error;\n}\n\n \nstatic int sysc_wait_softreset(struct sysc *ddata)\n{\n\tint syss_offset, error = 0;\n\n\tif (ddata->cap->regbits->srst_shift < 0)\n\t\treturn 0;\n\n\tsyss_offset = ddata->offsets[SYSC_SYSSTATUS];\n\n\tif (syss_offset >= 0)\n\t\terror = sysc_poll_reset_sysstatus(ddata);\n\telse if (ddata->cfg.quirks & SYSC_QUIRK_RESET_STATUS)\n\t\terror = sysc_poll_reset_sysconfig(ddata);\n\n\treturn error;\n}\n\nstatic int sysc_add_named_clock_from_child(struct sysc *ddata,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   const char *optfck_name)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tstruct device_node *child;\n\tstruct clk_lookup *cl;\n\tstruct clk *clock;\n\tconst char *n;\n\n\tif (name)\n\t\tn = name;\n\telse\n\t\tn = optfck_name;\n\n\t \n\tclock = of_clk_get_by_name(np, n);\n\tif (!IS_ERR(clock)) {\n\t\tclk_put(clock);\n\n\t\treturn 0;\n\t}\n\n\tchild = of_get_next_available_child(np, NULL);\n\tif (!child)\n\t\treturn -ENODEV;\n\n\tclock = devm_get_clk_from_child(ddata->dev, child, name);\n\tif (IS_ERR(clock))\n\t\treturn PTR_ERR(clock);\n\n\t \n\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\treturn -ENOMEM;\n\n\tcl->con_id = n;\n\tcl->dev_id = dev_name(ddata->dev);\n\tcl->clk = clock;\n\tclkdev_add(cl);\n\n\tclk_put(clock);\n\n\treturn 0;\n}\n\nstatic int sysc_init_ext_opt_clock(struct sysc *ddata, const char *name)\n{\n\tconst char *optfck_name;\n\tint error, index;\n\n\tif (ddata->nr_clocks < SYSC_OPTFCK0)\n\t\tindex = SYSC_OPTFCK0;\n\telse\n\t\tindex = ddata->nr_clocks;\n\n\tif (name)\n\t\toptfck_name = name;\n\telse\n\t\toptfck_name = clock_names[index];\n\n\terror = sysc_add_named_clock_from_child(ddata, name, optfck_name);\n\tif (error)\n\t\treturn error;\n\n\tddata->clock_roles[index] = optfck_name;\n\tddata->nr_clocks++;\n\n\treturn 0;\n}\n\nstatic int sysc_get_one_clock(struct sysc *ddata, const char *name)\n{\n\tint error, i, index = -ENODEV;\n\n\tif (!strncmp(clock_names[SYSC_FCK], name, 3))\n\t\tindex = SYSC_FCK;\n\telse if (!strncmp(clock_names[SYSC_ICK], name, 3))\n\t\tindex = SYSC_ICK;\n\n\tif (index < 0) {\n\t\tfor (i = SYSC_OPTFCK0; i < SYSC_MAX_CLOCKS; i++) {\n\t\t\tif (!ddata->clocks[i]) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (index < 0) {\n\t\tdev_err(ddata->dev, \"clock %s not added\\n\", name);\n\t\treturn index;\n\t}\n\n\tddata->clocks[index] = devm_clk_get(ddata->dev, name);\n\tif (IS_ERR(ddata->clocks[index])) {\n\t\tdev_err(ddata->dev, \"clock get error for %s: %li\\n\",\n\t\t\tname, PTR_ERR(ddata->clocks[index]));\n\n\t\treturn PTR_ERR(ddata->clocks[index]);\n\t}\n\n\terror = clk_prepare(ddata->clocks[index]);\n\tif (error) {\n\t\tdev_err(ddata->dev, \"clock prepare error for %s: %i\\n\",\n\t\t\tname, error);\n\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int sysc_get_clocks(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tstruct property *prop;\n\tconst char *name;\n\tint nr_fck = 0, nr_ick = 0, i, error = 0;\n\n\tddata->clock_roles = devm_kcalloc(ddata->dev,\n\t\t\t\t\t  SYSC_MAX_CLOCKS,\n\t\t\t\t\t  sizeof(*ddata->clock_roles),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!ddata->clock_roles)\n\t\treturn -ENOMEM;\n\n\tof_property_for_each_string(np, \"clock-names\", prop, name) {\n\t\tif (!strncmp(clock_names[SYSC_FCK], name, 3))\n\t\t\tnr_fck++;\n\t\tif (!strncmp(clock_names[SYSC_ICK], name, 3))\n\t\t\tnr_ick++;\n\t\tddata->clock_roles[ddata->nr_clocks] = name;\n\t\tddata->nr_clocks++;\n\t}\n\n\tif (ddata->nr_clocks < 1)\n\t\treturn 0;\n\n\tif ((ddata->cfg.quirks & SYSC_QUIRK_EXT_OPT_CLOCK)) {\n\t\terror = sysc_init_ext_opt_clock(ddata, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ddata->nr_clocks > SYSC_MAX_CLOCKS) {\n\t\tdev_err(ddata->dev, \"too many clocks for %pOF\\n\", np);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr_fck > 1 || nr_ick > 1) {\n\t\tdev_err(ddata->dev, \"max one fck and ick for %pOF\\n\", np);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!nr_fck)\n\t\tddata->nr_clocks++;\n\tif (!nr_ick)\n\t\tddata->nr_clocks++;\n\n\tddata->clocks = devm_kcalloc(ddata->dev,\n\t\t\t\t     ddata->nr_clocks, sizeof(*ddata->clocks),\n\t\t\t\t     GFP_KERNEL);\n\tif (!ddata->clocks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < SYSC_MAX_CLOCKS; i++) {\n\t\tconst char *name = ddata->clock_roles[i];\n\n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\terror = sysc_get_one_clock(ddata, name);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int sysc_enable_main_clocks(struct sysc *ddata)\n{\n\tstruct clk *clock;\n\tint i, error;\n\n\tif (!ddata->clocks)\n\t\treturn 0;\n\n\tfor (i = 0; i < SYSC_OPTFCK0; i++) {\n\t\tclock = ddata->clocks[i];\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\tcontinue;\n\n\t\terror = clk_enable(clock);\n\t\tif (error)\n\t\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tfor (i--; i >= 0; i--) {\n\t\tclock = ddata->clocks[i];\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\tcontinue;\n\n\t\tclk_disable(clock);\n\t}\n\n\treturn error;\n}\n\nstatic void sysc_disable_main_clocks(struct sysc *ddata)\n{\n\tstruct clk *clock;\n\tint i;\n\n\tif (!ddata->clocks)\n\t\treturn;\n\n\tfor (i = 0; i < SYSC_OPTFCK0; i++) {\n\t\tclock = ddata->clocks[i];\n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\tcontinue;\n\n\t\tclk_disable(clock);\n\t}\n}\n\nstatic int sysc_enable_opt_clocks(struct sysc *ddata)\n{\n\tstruct clk *clock;\n\tint i, error;\n\n\tif (!ddata->clocks || ddata->nr_clocks < SYSC_OPTFCK0 + 1)\n\t\treturn 0;\n\n\tfor (i = SYSC_OPTFCK0; i < SYSC_MAX_CLOCKS; i++) {\n\t\tclock = ddata->clocks[i];\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\treturn 0;\n\n\t\terror = clk_enable(clock);\n\t\tif (error)\n\t\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tfor (i--; i >= 0; i--) {\n\t\tclock = ddata->clocks[i];\n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\tcontinue;\n\n\t\tclk_disable(clock);\n\t}\n\n\treturn error;\n}\n\nstatic void sysc_disable_opt_clocks(struct sysc *ddata)\n{\n\tstruct clk *clock;\n\tint i;\n\n\tif (!ddata->clocks || ddata->nr_clocks < SYSC_OPTFCK0 + 1)\n\t\treturn;\n\n\tfor (i = SYSC_OPTFCK0; i < SYSC_MAX_CLOCKS; i++) {\n\t\tclock = ddata->clocks[i];\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(clock))\n\t\t\treturn;\n\n\t\tclk_disable(clock);\n\t}\n}\n\nstatic void sysc_clkdm_deny_idle(struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata;\n\n\tif (ddata->legacy_mode || (ddata->cfg.quirks & SYSC_QUIRK_CLKDM_NOAUTO))\n\t\treturn;\n\n\tpdata = dev_get_platdata(ddata->dev);\n\tif (pdata && pdata->clkdm_deny_idle)\n\t\tpdata->clkdm_deny_idle(ddata->dev, &ddata->cookie);\n}\n\nstatic void sysc_clkdm_allow_idle(struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata;\n\n\tif (ddata->legacy_mode || (ddata->cfg.quirks & SYSC_QUIRK_CLKDM_NOAUTO))\n\t\treturn;\n\n\tpdata = dev_get_platdata(ddata->dev);\n\tif (pdata && pdata->clkdm_allow_idle)\n\t\tpdata->clkdm_allow_idle(ddata->dev, &ddata->cookie);\n}\n\n \nstatic int sysc_init_resets(struct sysc *ddata)\n{\n\tddata->rsts =\n\t\tdevm_reset_control_get_optional_shared(ddata->dev, \"rstctrl\");\n\n\treturn PTR_ERR_OR_ZERO(ddata->rsts);\n}\n\n \nstatic int sysc_parse_and_check_child_range(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tstruct of_range_parser parser;\n\tstruct of_range range;\n\tint error;\n\n\terror = of_range_parser_init(&parser, np);\n\tif (error)\n\t\treturn error;\n\n\tfor_each_of_range(&parser, &range) {\n\t\tddata->module_pa = range.cpu_addr;\n\t\tddata->module_size = range.size;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct resource early_bus_ranges[] = {\n\t \n\t{ .start = 0x44c00000, .end = 0x44c00000 + 0x300000, },\n\t \n\t{ .start = 0x4a000000, .end = 0x4a000000 + 0x300000, },\n\t \n\t{ .start = 0x4a300000, .end = 0x4a300000 + 0x30000,  },\n\t \n\t{ .start = 0x4ae00000, .end = 0x4ae00000 + 0x30000,  },\n};\n\nstatic atomic_t sysc_defer = ATOMIC_INIT(10);\n\n \nstatic int sysc_defer_non_critical(struct sysc *ddata)\n{\n\tstruct resource *res;\n\tint i;\n\n\tif (!atomic_read(&sysc_defer))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(early_bus_ranges); i++) {\n\t\tres = &early_bus_ranges[i];\n\t\tif (ddata->module_pa >= res->start &&\n\t\t    ddata->module_pa <= res->end) {\n\t\t\tatomic_set(&sysc_defer, 0);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tatomic_dec_if_positive(&sysc_defer);\n\n\treturn -EPROBE_DEFER;\n}\n\nstatic struct device_node *stdout_path;\n\nstatic void sysc_init_stdout_path(struct sysc *ddata)\n{\n\tstruct device_node *np = NULL;\n\tconst char *uart;\n\n\tif (IS_ERR(stdout_path))\n\t\treturn;\n\n\tif (stdout_path)\n\t\treturn;\n\n\tnp = of_find_node_by_path(\"/chosen\");\n\tif (!np)\n\t\tgoto err;\n\n\tuart = of_get_property(np, \"stdout-path\", NULL);\n\tif (!uart)\n\t\tgoto err;\n\n\tnp = of_find_node_by_path(uart);\n\tif (!np)\n\t\tgoto err;\n\n\tstdout_path = np;\n\n\treturn;\n\nerr:\n\tstdout_path = ERR_PTR(-ENODEV);\n}\n\nstatic void sysc_check_quirk_stdout(struct sysc *ddata,\n\t\t\t\t    struct device_node *np)\n{\n\tsysc_init_stdout_path(ddata);\n\tif (np != stdout_path)\n\t\treturn;\n\n\tddata->cfg.quirks |= SYSC_QUIRK_NO_IDLE_ON_INIT |\n\t\t\t\tSYSC_QUIRK_NO_RESET_ON_INIT;\n}\n\n \nstatic void sysc_check_one_child(struct sysc *ddata,\n\t\t\t\t struct device_node *np)\n{\n\tconst char *name;\n\n\tname = of_get_property(np, \"ti,hwmods\", NULL);\n\tif (name && !of_device_is_compatible(np, \"ti,sysc\"))\n\t\tdev_warn(ddata->dev, \"really a child ti,hwmods property?\");\n\n\tsysc_check_quirk_stdout(ddata, np);\n\tsysc_parse_dts_quirks(ddata, np, true);\n}\n\nstatic void sysc_check_children(struct sysc *ddata)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(ddata->dev->of_node, child)\n\t\tsysc_check_one_child(ddata, child);\n}\n\n \nstatic void sysc_check_quirk_16bit(struct sysc *ddata, struct resource *res)\n{\n\tif (resource_size(res) == 8)\n\t\tddata->cfg.quirks |= SYSC_QUIRK_16BIT | SYSC_QUIRK_USE_CLOCKACT;\n}\n\n \nstatic int sysc_parse_one(struct sysc *ddata, enum sysc_registers reg)\n{\n\tstruct resource *res;\n\tconst char *name;\n\n\tswitch (reg) {\n\tcase SYSC_REVISION:\n\tcase SYSC_SYSCONFIG:\n\tcase SYSC_SYSSTATUS:\n\t\tname = reg_names[reg];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tres = platform_get_resource_byname(to_platform_device(ddata->dev),\n\t\t\t\t\t   IORESOURCE_MEM, name);\n\tif (!res) {\n\t\tddata->offsets[reg] = -ENODEV;\n\n\t\treturn 0;\n\t}\n\n\tddata->offsets[reg] = res->start - ddata->module_pa;\n\tif (reg == SYSC_REVISION)\n\t\tsysc_check_quirk_16bit(ddata, res);\n\n\treturn 0;\n}\n\nstatic int sysc_parse_registers(struct sysc *ddata)\n{\n\tint i, error;\n\n\tfor (i = 0; i < SYSC_MAX_REGS; i++) {\n\t\terror = sysc_parse_one(ddata, i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sysc_check_registers(struct sysc *ddata)\n{\n\tint i, j, nr_regs = 0, nr_matches = 0;\n\n\tfor (i = 0; i < SYSC_MAX_REGS; i++) {\n\t\tif (ddata->offsets[i] < 0)\n\t\t\tcontinue;\n\n\t\tif (ddata->offsets[i] > (ddata->module_size - 4)) {\n\t\t\tdev_err(ddata->dev, \"register outside module range\");\n\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < SYSC_MAX_REGS; j++) {\n\t\t\tif (ddata->offsets[j] < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (ddata->offsets[i] == ddata->offsets[j])\n\t\t\t\tnr_matches++;\n\t\t}\n\t\tnr_regs++;\n\t}\n\n\tif (nr_matches > nr_regs) {\n\t\tdev_err(ddata->dev, \"overlapping registers: (%i/%i)\",\n\t\t\tnr_regs, nr_matches);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sysc_ioremap(struct sysc *ddata)\n{\n\tint size;\n\n\tif (ddata->offsets[SYSC_REVISION] < 0 &&\n\t    ddata->offsets[SYSC_SYSCONFIG] < 0 &&\n\t    ddata->offsets[SYSC_SYSSTATUS] < 0) {\n\t\tsize = ddata->module_size;\n\t} else {\n\t\tsize = max3(ddata->offsets[SYSC_REVISION],\n\t\t\t    ddata->offsets[SYSC_SYSCONFIG],\n\t\t\t    ddata->offsets[SYSC_SYSSTATUS]);\n\n\t\tif (size < SZ_1K)\n\t\t\tsize = SZ_1K;\n\n\t\tif ((size + sizeof(u32)) > ddata->module_size)\n\t\t\tsize = ddata->module_size;\n\t}\n\n\tddata->module_va = devm_ioremap(ddata->dev,\n\t\t\t\t\tddata->module_pa,\n\t\t\t\t\tsize + sizeof(u32));\n\tif (!ddata->module_va)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int sysc_map_and_check_registers(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tint error;\n\n\terror = sysc_parse_and_check_child_range(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_defer_non_critical(ddata);\n\tif (error)\n\t\treturn error;\n\n\tsysc_check_children(ddata);\n\n\tif (!of_property_present(np, \"reg\"))\n\t\treturn 0;\n\n\terror = sysc_parse_registers(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_ioremap(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_check_registers(ddata);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nstatic int sysc_show_rev(char *bufp, struct sysc *ddata)\n{\n\tint len;\n\n\tif (ddata->offsets[SYSC_REVISION] < 0)\n\t\treturn sprintf(bufp, \":NA\");\n\n\tlen = sprintf(bufp, \":%08x\", ddata->revision);\n\n\treturn len;\n}\n\nstatic int sysc_show_reg(struct sysc *ddata,\n\t\t\t char *bufp, enum sysc_registers reg)\n{\n\tif (ddata->offsets[reg] < 0)\n\t\treturn sprintf(bufp, \":NA\");\n\n\treturn sprintf(bufp, \":%x\", ddata->offsets[reg]);\n}\n\nstatic int sysc_show_name(char *bufp, struct sysc *ddata)\n{\n\tif (!ddata->name)\n\t\treturn 0;\n\n\treturn sprintf(bufp, \":%s\", ddata->name);\n}\n\n \nstatic void sysc_show_registers(struct sysc *ddata)\n{\n\tchar buf[128];\n\tchar *bufp = buf;\n\tint i;\n\n\tfor (i = 0; i < SYSC_MAX_REGS; i++)\n\t\tbufp += sysc_show_reg(ddata, bufp, i);\n\n\tbufp += sysc_show_rev(bufp, ddata);\n\tbufp += sysc_show_name(bufp, ddata);\n\n\tdev_dbg(ddata->dev, \"%llx:%x%s\\n\",\n\t\tddata->module_pa, ddata->module_size,\n\t\tbuf);\n}\n\n \nstatic void sysc_write_sysconfig(struct sysc *ddata, u32 value)\n{\n\tif (ddata->module_unlock_quirk)\n\t\tddata->module_unlock_quirk(ddata);\n\n\tsysc_write(ddata, ddata->offsets[SYSC_SYSCONFIG], value);\n\n\tif (ddata->module_lock_quirk)\n\t\tddata->module_lock_quirk(ddata);\n}\n\n#define SYSC_IDLE_MASK\t(SYSC_NR_IDLEMODES - 1)\n#define SYSC_CLOCACT_ICK\t2\n\n \nstatic int sysc_enable_module(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tconst struct sysc_regbits *regbits;\n\tu32 reg, idlemodes, best_mode;\n\tint error;\n\n\tddata = dev_get_drvdata(dev);\n\n\t \n\tif (ddata->cfg.quirks & SYSC_QUIRK_OPT_CLKS_IN_RESET) {\n\t\terror = sysc_enable_opt_clocks(ddata);\n\t\tif (error) {\n\t\t\tdev_err(ddata->dev,\n\t\t\t\t\"Optional clocks failed for enable: %i\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\t \n\tif (!(ddata->cfg.quirks & SYSC_MODULE_QUIRK_ENA_RESETDONE)) {\n\t\terror = sysc_wait_softreset(ddata);\n\t\tif (error)\n\t\t\tdev_warn(ddata->dev, \"OCP softreset timed out\\n\");\n\t}\n\tif (ddata->cfg.quirks & SYSC_QUIRK_OPT_CLKS_IN_RESET)\n\t\tsysc_disable_opt_clocks(ddata);\n\n\t \n\tif (ddata->offsets[SYSC_SYSCONFIG] == -ENODEV)\n\t\treturn 0;\n\n\tregbits = ddata->cap->regbits;\n\treg = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\n\t \n\tif (regbits->clkact_shift >= 0 &&\n\t    (ddata->cfg.quirks & SYSC_QUIRK_USE_CLOCKACT))\n\t\treg |= SYSC_CLOCACT_ICK << regbits->clkact_shift;\n\n\t \n\tidlemodes = ddata->cfg.sidlemodes;\n\tif (!idlemodes || regbits->sidle_shift < 0)\n\t\tgoto set_midle;\n\n\tif (ddata->cfg.quirks & (SYSC_QUIRK_SWSUP_SIDLE |\n\t\t\t\t SYSC_QUIRK_SWSUP_SIDLE_ACT)) {\n\t\tbest_mode = SYSC_IDLE_NO;\n\n\t\t \n\t\tif (regbits->enwkup_shift >= 0 &&\n\t\t    ddata->cfg.sysc_val & BIT(regbits->enwkup_shift))\n\t\t\treg &= ~BIT(regbits->enwkup_shift);\n\t} else {\n\t\tbest_mode = fls(ddata->cfg.sidlemodes) - 1;\n\t\tif (best_mode > SYSC_IDLE_MASK) {\n\t\t\tdev_err(dev, \"%s: invalid sidlemode\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (regbits->enwkup_shift >= 0 &&\n\t\t    ddata->cfg.sysc_val & BIT(regbits->enwkup_shift))\n\t\t\treg |= BIT(regbits->enwkup_shift);\n\t}\n\n\treg &= ~(SYSC_IDLE_MASK << regbits->sidle_shift);\n\treg |= best_mode << regbits->sidle_shift;\n\tsysc_write_sysconfig(ddata, reg);\n\nset_midle:\n\t \n\tidlemodes = ddata->cfg.midlemodes;\n\tif (!idlemodes || regbits->midle_shift < 0)\n\t\tgoto set_autoidle;\n\n\tbest_mode = fls(ddata->cfg.midlemodes) - 1;\n\tif (best_mode > SYSC_IDLE_MASK) {\n\t\tdev_err(dev, \"%s: invalid midlemode\\n\", __func__);\n\t\terror = -EINVAL;\n\t\tgoto save_context;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_QUIRK_SWSUP_MSTANDBY)\n\t\tbest_mode = SYSC_IDLE_NO;\n\n\treg &= ~(SYSC_IDLE_MASK << regbits->midle_shift);\n\treg |= best_mode << regbits->midle_shift;\n\tsysc_write_sysconfig(ddata, reg);\n\nset_autoidle:\n\t \n\tif (regbits->autoidle_shift >= 0 &&\n\t    ddata->cfg.sysc_val & BIT(regbits->autoidle_shift)) {\n\t\treg |= 1 << regbits->autoidle_shift;\n\t\tsysc_write_sysconfig(ddata, reg);\n\t}\n\n\terror = 0;\n\nsave_context:\n\t \n\tddata->sysconfig = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\n\tif (ddata->module_enable_quirk)\n\t\tddata->module_enable_quirk(ddata);\n\n\treturn error;\n}\n\nstatic int sysc_best_idle_mode(u32 idlemodes, u32 *best_mode)\n{\n\tif (idlemodes & BIT(SYSC_IDLE_SMART_WKUP))\n\t\t*best_mode = SYSC_IDLE_SMART_WKUP;\n\telse if (idlemodes & BIT(SYSC_IDLE_SMART))\n\t\t*best_mode = SYSC_IDLE_SMART;\n\telse if (idlemodes & BIT(SYSC_IDLE_FORCE))\n\t\t*best_mode = SYSC_IDLE_FORCE;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int sysc_disable_module(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tconst struct sysc_regbits *regbits;\n\tu32 reg, idlemodes, best_mode;\n\tint ret;\n\n\tddata = dev_get_drvdata(dev);\n\tif (ddata->offsets[SYSC_SYSCONFIG] == -ENODEV)\n\t\treturn 0;\n\n\tif (ddata->module_disable_quirk)\n\t\tddata->module_disable_quirk(ddata);\n\n\tregbits = ddata->cap->regbits;\n\treg = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\n\t \n\tidlemodes = ddata->cfg.midlemodes;\n\tif (!idlemodes || regbits->midle_shift < 0)\n\t\tgoto set_sidle;\n\n\tret = sysc_best_idle_mode(idlemodes, &best_mode);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: invalid midlemode\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (ddata->cfg.quirks & (SYSC_QUIRK_SWSUP_MSTANDBY) ||\n\t    ddata->cfg.quirks & (SYSC_QUIRK_FORCE_MSTANDBY))\n\t\tbest_mode = SYSC_IDLE_FORCE;\n\n\treg &= ~(SYSC_IDLE_MASK << regbits->midle_shift);\n\treg |= best_mode << regbits->midle_shift;\n\tsysc_write_sysconfig(ddata, reg);\n\nset_sidle:\n\t \n\tidlemodes = ddata->cfg.sidlemodes;\n\tif (!idlemodes || regbits->sidle_shift < 0) {\n\t\tret = 0;\n\t\tgoto save_context;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_QUIRK_SWSUP_SIDLE) {\n\t\tbest_mode = SYSC_IDLE_FORCE;\n\t} else {\n\t\tret = sysc_best_idle_mode(idlemodes, &best_mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: invalid sidlemode\\n\", __func__);\n\t\t\tret = -EINVAL;\n\t\t\tgoto save_context;\n\t\t}\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_QUIRK_SWSUP_SIDLE_ACT) {\n\t\t \n\t\tif (regbits->enwkup_shift >= 0 &&\n\t\t    ddata->cfg.sysc_val & BIT(regbits->enwkup_shift))\n\t\t\treg |= BIT(regbits->enwkup_shift);\n\t}\n\n\treg &= ~(SYSC_IDLE_MASK << regbits->sidle_shift);\n\treg |= best_mode << regbits->sidle_shift;\n\tif (regbits->autoidle_shift >= 0 &&\n\t    ddata->cfg.sysc_val & BIT(regbits->autoidle_shift))\n\t\treg |= 1 << regbits->autoidle_shift;\n\tsysc_write_sysconfig(ddata, reg);\n\n\tret = 0;\n\nsave_context:\n\t \n\tddata->sysconfig = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused sysc_runtime_suspend_legacy(struct device *dev,\n\t\t\t\t\t\t      struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata;\n\tint error;\n\n\tpdata = dev_get_platdata(ddata->dev);\n\tif (!pdata)\n\t\treturn 0;\n\n\tif (!pdata->idle_module)\n\t\treturn -ENODEV;\n\n\terror = pdata->idle_module(dev, &ddata->cookie);\n\tif (error)\n\t\tdev_err(dev, \"%s: could not idle: %i\\n\",\n\t\t\t__func__, error);\n\n\treset_control_assert(ddata->rsts);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sysc_runtime_resume_legacy(struct device *dev,\n\t\t\t\t\t\t     struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata;\n\tint error;\n\n\tpdata = dev_get_platdata(ddata->dev);\n\tif (!pdata)\n\t\treturn 0;\n\n\tif (!pdata->enable_module)\n\t\treturn -ENODEV;\n\n\terror = pdata->enable_module(dev, &ddata->cookie);\n\tif (error)\n\t\tdev_err(dev, \"%s: could not enable: %i\\n\",\n\t\t\t__func__, error);\n\n\treset_control_deassert(ddata->rsts);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sysc_runtime_suspend(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error = 0;\n\n\tddata = dev_get_drvdata(dev);\n\n\tif (!ddata->enabled)\n\t\treturn 0;\n\n\tsysc_clkdm_deny_idle(ddata);\n\n\tif (ddata->legacy_mode) {\n\t\terror = sysc_runtime_suspend_legacy(dev, ddata);\n\t\tif (error)\n\t\t\tgoto err_allow_idle;\n\t} else {\n\t\terror = sysc_disable_module(dev);\n\t\tif (error)\n\t\t\tgoto err_allow_idle;\n\t}\n\n\tsysc_disable_main_clocks(ddata);\n\n\tif (sysc_opt_clks_needed(ddata))\n\t\tsysc_disable_opt_clocks(ddata);\n\n\tddata->enabled = false;\n\nerr_allow_idle:\n\tsysc_clkdm_allow_idle(ddata);\n\n\treset_control_assert(ddata->rsts);\n\n\treturn error;\n}\n\nstatic int __maybe_unused sysc_runtime_resume(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error = 0;\n\n\tddata = dev_get_drvdata(dev);\n\n\tif (ddata->enabled)\n\t\treturn 0;\n\n\n\tsysc_clkdm_deny_idle(ddata);\n\n\tif (sysc_opt_clks_needed(ddata)) {\n\t\terror = sysc_enable_opt_clocks(ddata);\n\t\tif (error)\n\t\t\tgoto err_allow_idle;\n\t}\n\n\terror = sysc_enable_main_clocks(ddata);\n\tif (error)\n\t\tgoto err_opt_clocks;\n\n\treset_control_deassert(ddata->rsts);\n\n\tif (ddata->legacy_mode) {\n\t\terror = sysc_runtime_resume_legacy(dev, ddata);\n\t\tif (error)\n\t\t\tgoto err_main_clocks;\n\t} else {\n\t\terror = sysc_enable_module(dev);\n\t\tif (error)\n\t\t\tgoto err_main_clocks;\n\t}\n\n\tddata->enabled = true;\n\n\tsysc_clkdm_allow_idle(ddata);\n\n\treturn 0;\n\nerr_main_clocks:\n\tsysc_disable_main_clocks(ddata);\nerr_opt_clocks:\n\tif (sysc_opt_clks_needed(ddata))\n\t\tsysc_disable_opt_clocks(ddata);\nerr_allow_idle:\n\tsysc_clkdm_allow_idle(ddata);\n\n\treturn error;\n}\n\n \nstatic int sysc_check_context(struct sysc *ddata)\n{\n\tu32 reg;\n\n\tif (!ddata->enabled)\n\t\treturn -ENODATA;\n\n\treg = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\tif (reg == ddata->sysconfig)\n\t\treturn 0;\n\n\treturn -EACCES;\n}\n\nstatic int sysc_reinit_module(struct sysc *ddata, bool leave_enabled)\n{\n\tstruct device *dev = ddata->dev;\n\tint error;\n\n\tif (ddata->enabled) {\n\t\t \n\t\terror = sysc_check_context(ddata);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\t \n\t\terror = sysc_runtime_suspend(dev);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"reinit suspend failed: %i\\n\", error);\n\t}\n\n\t \n\terror = sysc_runtime_resume(dev);\n\tif (error)\n\t\tdev_warn(dev, \"reinit resume failed: %i\\n\", error);\n\n\t \n\tif (ddata->cfg.quirks & SYSC_QUIRK_RESET_ON_CTX_LOST) {\n\t\terror = sysc_reset(ddata);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"reinit reset failed: %i\\n\", error);\n\n\t\tsysc_write_sysconfig(ddata, ddata->sysconfig);\n\t}\n\n\tif (leave_enabled)\n\t\treturn error;\n\n\t \n\terror = sysc_runtime_suspend(dev);\n\tif (error)\n\t\tdev_warn(dev, \"reinit suspend failed: %i\\n\", error);\n\n\treturn error;\n}\n\nstatic int __maybe_unused sysc_noirq_suspend(struct device *dev)\n{\n\tstruct sysc *ddata;\n\n\tddata = dev_get_drvdata(dev);\n\n\tif (ddata->cfg.quirks &\n\t    (SYSC_QUIRK_LEGACY_IDLE | SYSC_QUIRK_NO_IDLE))\n\t\treturn 0;\n\n\tif (!ddata->enabled)\n\t\treturn 0;\n\n\tddata->needs_resume = 1;\n\n\treturn sysc_runtime_suspend(dev);\n}\n\nstatic int __maybe_unused sysc_noirq_resume(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error = 0;\n\n\tddata = dev_get_drvdata(dev);\n\n\tif (ddata->cfg.quirks &\n\t    (SYSC_QUIRK_LEGACY_IDLE | SYSC_QUIRK_NO_IDLE))\n\t\treturn 0;\n\n\tif (ddata->cfg.quirks & SYSC_QUIRK_REINIT_ON_RESUME) {\n\t\terror = sysc_reinit_module(ddata, ddata->needs_resume);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"noirq_resume failed: %i\\n\", error);\n\t} else if (ddata->needs_resume) {\n\t\terror = sysc_runtime_resume(dev);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"noirq_resume failed: %i\\n\", error);\n\t}\n\n\tddata->needs_resume = 0;\n\n\treturn error;\n}\n\nstatic const struct dev_pm_ops sysc_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sysc_noirq_suspend, sysc_noirq_resume)\n\tSET_RUNTIME_PM_OPS(sysc_runtime_suspend,\n\t\t\t   sysc_runtime_resume,\n\t\t\t   NULL)\n};\n\n \nstruct sysc_revision_quirk {\n\tconst char *name;\n\tu32 base;\n\tint rev_offset;\n\tint sysc_offset;\n\tint syss_offset;\n\tu32 revision;\n\tu32 revision_mask;\n\tu32 quirks;\n};\n\n#define SYSC_QUIRK(optname, optbase, optrev, optsysc, optsyss,\t\t\\\n\t\t   optrev_val, optrevmask, optquirkmask)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = (optname),\t\t\t\t\t\\\n\t\t.base = (optbase),\t\t\t\t\t\\\n\t\t.rev_offset = (optrev),\t\t\t\t\t\\\n\t\t.sysc_offset = (optsysc),\t\t\t\t\\\n\t\t.syss_offset = (optsyss),\t\t\t\t\\\n\t\t.revision = (optrev_val),\t\t\t\t\\\n\t\t.revision_mask = (optrevmask),\t\t\t\t\\\n\t\t.quirks = (optquirkmask),\t\t\t\t\\\n\t}\n\nstatic const struct sysc_revision_quirk sysc_revision_quirks[] = {\n\t \n\tSYSC_QUIRK(\"uart\", 0, 0x50, 0x54, 0x58, 0x00000046, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE_ACT | SYSC_QUIRK_LEGACY_IDLE),\n\tSYSC_QUIRK(\"uart\", 0, 0x50, 0x54, 0x58, 0x00000052, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE_ACT | SYSC_QUIRK_LEGACY_IDLE),\n\t \n\tSYSC_QUIRK(\"uart\", 0, 0x50, 0x54, 0x58, 0x50411e03, 0xffff00ff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE_ACT | SYSC_QUIRK_LEGACY_IDLE),\n\tSYSC_QUIRK(\"uart\", 0, 0x50, 0x54, 0x58, 0x47422e03, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE_ACT | SYSC_QUIRK_LEGACY_IDLE),\n\tSYSC_QUIRK(\"uart\", 0, 0x50, 0x54, 0x58, 0x47424e03, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE_ACT | SYSC_QUIRK_LEGACY_IDLE),\n\n\t \n\tSYSC_QUIRK(\"mcpdm\", 0x40132000, 0, 0x10, -ENODEV, 0x50000800, 0xffffffff,\n\t\t   SYSC_QUIRK_EXT_OPT_CLOCK | SYSC_QUIRK_NO_RESET_ON_INIT |\n\t\t   SYSC_QUIRK_SWSUP_SIDLE),\n\n\t \n\tSYSC_QUIRK(\"aess\", 0, 0, 0x10, -ENODEV, 0x40000000, 0xffffffff,\n\t\t   SYSC_MODULE_QUIRK_AESS),\n\t \n\tSYSC_QUIRK(\"dcan\", 0x4ae3c000, 0x20, -ENODEV, -ENODEV, 0xa3170504, 0xffffffff,\n\t\t   SYSC_QUIRK_CLKDM_NOAUTO),\n\tSYSC_QUIRK(\"dcan\", 0x48480000, 0x20, -ENODEV, -ENODEV, 0xa3170504, 0xffffffff,\n\t\t   SYSC_QUIRK_CLKDM_NOAUTO),\n\tSYSC_QUIRK(\"dss\", 0x4832a000, 0, 0x10, 0x14, 0x00000020, 0xffffffff,\n\t\t   SYSC_QUIRK_OPT_CLKS_IN_RESET | SYSC_MODULE_QUIRK_DSS_RESET),\n\tSYSC_QUIRK(\"dss\", 0x58000000, 0, -ENODEV, 0x14, 0x00000040, 0xffffffff,\n\t\t   SYSC_QUIRK_OPT_CLKS_IN_RESET | SYSC_MODULE_QUIRK_DSS_RESET),\n\tSYSC_QUIRK(\"dss\", 0x58000000, 0, -ENODEV, 0x14, 0x00000061, 0xffffffff,\n\t\t   SYSC_QUIRK_OPT_CLKS_IN_RESET | SYSC_MODULE_QUIRK_DSS_RESET),\n\tSYSC_QUIRK(\"dwc3\", 0x48880000, 0, 0x10, -ENODEV, 0x500a0200, 0xffffffff,\n\t\t   SYSC_QUIRK_CLKDM_NOAUTO),\n\tSYSC_QUIRK(\"dwc3\", 0x488c0000, 0, 0x10, -ENODEV, 0x500a0200, 0xffffffff,\n\t\t   SYSC_QUIRK_CLKDM_NOAUTO),\n\tSYSC_QUIRK(\"gpio\", 0, 0, 0x10, 0x114, 0x50600801, 0xffff00ff,\n\t\t   SYSC_QUIRK_OPT_CLKS_IN_RESET),\n\tSYSC_QUIRK(\"gpmc\", 0, 0, 0x10, 0x14, 0x00000060, 0xffffffff,\n\t\t   SYSC_QUIRK_REINIT_ON_CTX_LOST | SYSC_QUIRK_RESET_ON_CTX_LOST |\n\t\t   SYSC_QUIRK_GPMC_DEBUG),\n\tSYSC_QUIRK(\"hdmi\", 0, 0, 0x10, -ENODEV, 0x50030200, 0xffffffff,\n\t\t   SYSC_QUIRK_OPT_CLKS_NEEDED),\n\tSYSC_QUIRK(\"hdq1w\", 0, 0, 0x14, 0x18, 0x00000006, 0xffffffff,\n\t\t   SYSC_MODULE_QUIRK_HDQ1W | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"hdq1w\", 0, 0, 0x14, 0x18, 0x0000000a, 0xffffffff,\n\t\t   SYSC_MODULE_QUIRK_HDQ1W | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"i2c\", 0, 0, 0x20, 0x10, 0x00000036, 0x000000ff,\n\t\t   SYSC_MODULE_QUIRK_I2C | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"i2c\", 0, 0, 0x20, 0x10, 0x0000003c, 0x000000ff,\n\t\t   SYSC_MODULE_QUIRK_I2C | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"i2c\", 0, 0, 0x20, 0x10, 0x00000040, 0x000000ff,\n\t\t   SYSC_MODULE_QUIRK_I2C | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"i2c\", 0, 0, 0x10, 0x90, 0x5040000a, 0xfffff0f0,\n\t\t   SYSC_MODULE_QUIRK_I2C | SYSC_MODULE_QUIRK_ENA_RESETDONE),\n\tSYSC_QUIRK(\"gpu\", 0x50000000, 0x14, -ENODEV, -ENODEV, 0x00010201, 0xffffffff, 0),\n\tSYSC_QUIRK(\"gpu\", 0x50000000, 0xfe00, 0xfe10, -ENODEV, 0x40000000 , 0xffffffff,\n\t\t   SYSC_MODULE_QUIRK_SGX),\n\tSYSC_QUIRK(\"lcdc\", 0, 0, 0x54, -ENODEV, 0x4f201000, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"mcasp\", 0, 0, 0x4, -ENODEV, 0x44306302, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE),\n\tSYSC_QUIRK(\"rtc\", 0, 0x74, 0x78, -ENODEV, 0x4eb01908, 0xffff00f0,\n\t\t   SYSC_MODULE_QUIRK_RTC_UNLOCK),\n\tSYSC_QUIRK(\"tptc\", 0, 0, 0x10, -ENODEV, 0x40006c00, 0xffffefff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"tptc\", 0, 0, -ENODEV, -ENODEV, 0x40007c00, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"sata\", 0, 0xfc, 0x1100, -ENODEV, 0x5e412000, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"usb_host_hs\", 0, 0, 0x10, 0x14, 0x50700100, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"usb_host_hs\", 0, 0, 0x10, -ENODEV, 0x50700101, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY),\n\tSYSC_QUIRK(\"usb_otg_hs\", 0, 0x400, 0x404, 0x408, 0x00000033,\n\t\t   0xffffffff, SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY |\n\t\t   SYSC_MODULE_QUIRK_OTG),\n\tSYSC_QUIRK(\"usb_otg_hs\", 0, 0x400, 0x404, 0x408, 0x00000040,\n\t\t   0xffffffff, SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY |\n\t\t   SYSC_MODULE_QUIRK_OTG),\n\tSYSC_QUIRK(\"usb_otg_hs\", 0, 0x400, 0x404, 0x408, 0x00000050,\n\t\t   0xffffffff, SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY |\n\t\t   SYSC_MODULE_QUIRK_OTG),\n\tSYSC_QUIRK(\"usb_otg_hs\", 0, 0, 0x10, -ENODEV, 0x4ea2080d, 0xffffffff,\n\t\t   SYSC_QUIRK_SWSUP_SIDLE | SYSC_QUIRK_SWSUP_MSTANDBY |\n\t\t   SYSC_QUIRK_REINIT_ON_CTX_LOST),\n\tSYSC_QUIRK(\"wdt\", 0, 0, 0x10, 0x14, 0x502a0500, 0xfffff0f0,\n\t\t   SYSC_MODULE_QUIRK_WDT),\n\t \n\tSYSC_QUIRK(\"pruss\", 0, 0x26000, 0x26004, -ENODEV, 0x47000000, 0xff000000,\n\t\t   SYSC_MODULE_QUIRK_PRUSS),\n\t \n\tSYSC_QUIRK(\"wdt\", 0x44e35000, 0, 0x10, 0x14, 0x502a0500, 0xfffff0f0,\n\t\t   SYSC_MODULE_QUIRK_WDT | SYSC_QUIRK_SWSUP_SIDLE),\n\n#ifdef DEBUG\n\tSYSC_QUIRK(\"adc\", 0, 0, 0x10, -ENODEV, 0x47300001, 0xffffffff, 0),\n\tSYSC_QUIRK(\"atl\", 0, 0, -ENODEV, -ENODEV, 0x0a070100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"cm\", 0, 0, -ENODEV, -ENODEV, 0x40000301, 0xffffffff, 0),\n\tSYSC_QUIRK(\"control\", 0, 0, 0x10, -ENODEV, 0x40000900, 0xffffffff, 0),\n\tSYSC_QUIRK(\"cpgmac\", 0, 0x1200, 0x1208, 0x1204, 0x4edb1902,\n\t\t   0xffff00f0, 0),\n\tSYSC_QUIRK(\"dcan\", 0, 0x20, -ENODEV, -ENODEV, 0xa3170504, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dcan\", 0, 0x20, -ENODEV, -ENODEV, 0x4edb1902, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dispc\", 0x4832a400, 0, 0x10, 0x14, 0x00000030, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dispc\", 0x58001000, 0, 0x10, 0x14, 0x00000040, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dispc\", 0x58001000, 0, 0x10, 0x14, 0x00000051, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dmic\", 0, 0, 0x10, -ENODEV, 0x50010000, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dsi\", 0x58004000, 0, 0x10, 0x14, 0x00000030, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dsi\", 0x58005000, 0, 0x10, 0x14, 0x00000030, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dsi\", 0x58005000, 0, 0x10, 0x14, 0x00000040, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dsi\", 0x58009000, 0, 0x10, 0x14, 0x00000040, 0xffffffff, 0),\n\tSYSC_QUIRK(\"dwc3\", 0, 0, 0x10, -ENODEV, 0x500a0200, 0xffffffff, 0),\n\tSYSC_QUIRK(\"d2d\", 0x4a0b6000, 0, 0x10, 0x14, 0x00000010, 0xffffffff, 0),\n\tSYSC_QUIRK(\"d2d\", 0x4a0cd000, 0, 0x10, 0x14, 0x00000010, 0xffffffff, 0),\n\tSYSC_QUIRK(\"elm\", 0x48080000, 0, 0x10, 0x14, 0x00000020, 0xffffffff, 0),\n\tSYSC_QUIRK(\"emif\", 0, 0, -ENODEV, -ENODEV, 0x40441403, 0xffff0fff, 0),\n\tSYSC_QUIRK(\"emif\", 0, 0, -ENODEV, -ENODEV, 0x50440500, 0xffffffff, 0),\n\tSYSC_QUIRK(\"epwmss\", 0, 0, 0x4, -ENODEV, 0x47400001, 0xffffffff, 0),\n\tSYSC_QUIRK(\"gpu\", 0, 0x1fc00, 0x1fc10, -ENODEV, 0, 0, 0),\n\tSYSC_QUIRK(\"gpu\", 0, 0xfe00, 0xfe10, -ENODEV, 0x40000000 , 0xffffffff, 0),\n\tSYSC_QUIRK(\"hdmi\", 0, 0, 0x10, -ENODEV, 0x50031d00, 0xffffffff, 0),\n\tSYSC_QUIRK(\"hsi\", 0, 0, 0x10, 0x14, 0x50043101, 0xffffffff, 0),\n\tSYSC_QUIRK(\"iss\", 0, 0, 0x10, -ENODEV, 0x40000101, 0xffffffff, 0),\n\tSYSC_QUIRK(\"keypad\", 0x4a31c000, 0, 0x10, 0x14, 0x00000020, 0xffffffff, 0),\n\tSYSC_QUIRK(\"mcasp\", 0, 0, 0x4, -ENODEV, 0x44307b02, 0xffffffff, 0),\n\tSYSC_QUIRK(\"mcbsp\", 0, -ENODEV, 0x8c, -ENODEV, 0, 0, 0),\n\tSYSC_QUIRK(\"mcspi\", 0, 0, 0x10, -ENODEV, 0x40300a0b, 0xffff00ff, 0),\n\tSYSC_QUIRK(\"mcspi\", 0, 0, 0x110, 0x114, 0x40300a0b, 0xffffffff, 0),\n\tSYSC_QUIRK(\"mailbox\", 0, 0, 0x10, -ENODEV, 0x00000400, 0xffffffff, 0),\n\tSYSC_QUIRK(\"m3\", 0, 0, -ENODEV, -ENODEV, 0x5f580105, 0x0fff0f00, 0),\n\tSYSC_QUIRK(\"ocp2scp\", 0, 0, 0x10, 0x14, 0x50060005, 0xfffffff0, 0),\n\tSYSC_QUIRK(\"ocp2scp\", 0, 0, -ENODEV, -ENODEV, 0x50060007, 0xffffffff, 0),\n\tSYSC_QUIRK(\"padconf\", 0, 0, 0x10, -ENODEV, 0x4fff0800, 0xffffffff, 0),\n\tSYSC_QUIRK(\"padconf\", 0, 0, -ENODEV, -ENODEV, 0x40001100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"pcie\", 0x51000000, -ENODEV, -ENODEV, -ENODEV, 0, 0, 0),\n\tSYSC_QUIRK(\"pcie\", 0x51800000, -ENODEV, -ENODEV, -ENODEV, 0, 0, 0),\n\tSYSC_QUIRK(\"prcm\", 0, 0, -ENODEV, -ENODEV, 0x40000100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"prcm\", 0, 0, -ENODEV, -ENODEV, 0x00004102, 0xffffffff, 0),\n\tSYSC_QUIRK(\"prcm\", 0, 0, -ENODEV, -ENODEV, 0x40000400, 0xffffffff, 0),\n\tSYSC_QUIRK(\"rfbi\", 0x4832a800, 0, 0x10, 0x14, 0x00000010, 0xffffffff, 0),\n\tSYSC_QUIRK(\"rfbi\", 0x58002000, 0, 0x10, 0x14, 0x00000010, 0xffffffff, 0),\n\tSYSC_QUIRK(\"scm\", 0, 0, 0x10, -ENODEV, 0x40000900, 0xffffffff, 0),\n\tSYSC_QUIRK(\"scm\", 0, 0, -ENODEV, -ENODEV, 0x4e8b0100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"scm\", 0, 0, -ENODEV, -ENODEV, 0x4f000100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"scm\", 0, 0, -ENODEV, -ENODEV, 0x40000900, 0xffffffff, 0),\n\tSYSC_QUIRK(\"scrm\", 0, 0, -ENODEV, -ENODEV, 0x00000010, 0xffffffff, 0),\n\tSYSC_QUIRK(\"sdio\", 0, 0, 0x10, -ENODEV, 0x40202301, 0xffff0ff0, 0),\n\tSYSC_QUIRK(\"sdio\", 0, 0x2fc, 0x110, 0x114, 0x31010000, 0xffffffff, 0),\n\tSYSC_QUIRK(\"sdma\", 0, 0, 0x2c, 0x28, 0x00010900, 0xffffffff, 0),\n\tSYSC_QUIRK(\"sham\", 0, 0x100, 0x110, 0x114, 0x40000c03, 0xffffffff, 0),\n\tSYSC_QUIRK(\"slimbus\", 0, 0, 0x10, -ENODEV, 0x40000902, 0xffffffff, 0),\n\tSYSC_QUIRK(\"slimbus\", 0, 0, 0x10, -ENODEV, 0x40002903, 0xffffffff, 0),\n\tSYSC_QUIRK(\"smartreflex\", 0, -ENODEV, 0x24, -ENODEV, 0x00000000, 0xffffffff, 0),\n\tSYSC_QUIRK(\"smartreflex\", 0, -ENODEV, 0x38, -ENODEV, 0x00000000, 0xffffffff, 0),\n\tSYSC_QUIRK(\"spinlock\", 0, 0, 0x10, -ENODEV, 0x50020000, 0xffffffff, 0),\n\tSYSC_QUIRK(\"rng\", 0, 0x1fe0, 0x1fe4, -ENODEV, 0x00000020, 0xffffffff, 0),\n\tSYSC_QUIRK(\"timer\", 0, 0, 0x10, 0x14, 0x00000013, 0xffffffff, 0),\n\tSYSC_QUIRK(\"timer\", 0, 0, 0x10, 0x14, 0x00000015, 0xffffffff, 0),\n\t \n\tSYSC_QUIRK(\"timer\", 0, 0, 0x10, -ENODEV, 0x50002100, 0xffffffff, 0),\n\tSYSC_QUIRK(\"timer\", 0, 0, 0x10, -ENODEV, 0x4fff1301, 0xffff00ff, 0),\n\tSYSC_QUIRK(\"timer32k\", 0, 0, 0x4, -ENODEV, 0x00000040, 0xffffffff, 0),\n\tSYSC_QUIRK(\"timer32k\", 0, 0, 0x4, -ENODEV, 0x00000011, 0xffffffff, 0),\n\tSYSC_QUIRK(\"timer32k\", 0, 0, 0x4, -ENODEV, 0x00000060, 0xffffffff, 0),\n\tSYSC_QUIRK(\"tpcc\", 0, 0, -ENODEV, -ENODEV, 0x40014c00, 0xffffffff, 0),\n\tSYSC_QUIRK(\"usbhstll\", 0, 0, 0x10, 0x14, 0x00000004, 0xffffffff, 0),\n\tSYSC_QUIRK(\"usbhstll\", 0, 0, 0x10, 0x14, 0x00000008, 0xffffffff, 0),\n\tSYSC_QUIRK(\"venc\", 0x58003000, 0, -ENODEV, -ENODEV, 0x00000002, 0xffffffff, 0),\n\tSYSC_QUIRK(\"vfpe\", 0, 0, 0x104, -ENODEV, 0x4d001200, 0xffffffff, 0),\n#endif\n};\n\n \nstatic void sysc_init_early_quirks(struct sysc *ddata)\n{\n\tconst struct sysc_revision_quirk *q;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sysc_revision_quirks); i++) {\n\t\tq = &sysc_revision_quirks[i];\n\n\t\tif (!q->base)\n\t\t\tcontinue;\n\n\t\tif (q->base != ddata->module_pa)\n\t\t\tcontinue;\n\n\t\tif (q->rev_offset != ddata->offsets[SYSC_REVISION])\n\t\t\tcontinue;\n\n\t\tif (q->sysc_offset != ddata->offsets[SYSC_SYSCONFIG])\n\t\t\tcontinue;\n\n\t\tif (q->syss_offset != ddata->offsets[SYSC_SYSSTATUS])\n\t\t\tcontinue;\n\n\t\tddata->name = q->name;\n\t\tddata->cfg.quirks |= q->quirks;\n\t}\n}\n\n \nstatic void sysc_init_revision_quirks(struct sysc *ddata)\n{\n\tconst struct sysc_revision_quirk *q;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sysc_revision_quirks); i++) {\n\t\tq = &sysc_revision_quirks[i];\n\n\t\tif (q->base && q->base != ddata->module_pa)\n\t\t\tcontinue;\n\n\t\tif (q->rev_offset != ddata->offsets[SYSC_REVISION])\n\t\t\tcontinue;\n\n\t\tif (q->sysc_offset != ddata->offsets[SYSC_SYSCONFIG])\n\t\t\tcontinue;\n\n\t\tif (q->syss_offset != ddata->offsets[SYSC_SYSSTATUS])\n\t\t\tcontinue;\n\n\t\tif (q->revision == ddata->revision ||\n\t\t    (q->revision & q->revision_mask) ==\n\t\t    (ddata->revision & q->revision_mask)) {\n\t\t\tddata->name = q->name;\n\t\t\tddata->cfg.quirks |= q->quirks;\n\t\t}\n\t}\n}\n\n \nstatic u32 sysc_quirk_dispc(struct sysc *ddata, int dispc_offset,\n\t\t\t    bool disable)\n{\n\tbool lcd_en, digit_en, lcd2_en = false, lcd3_en = false;\n\tconst int lcd_en_mask = BIT(0), digit_en_mask = BIT(1);\n\tint manager_count;\n\tbool framedonetv_irq = true;\n\tu32 val, irq_mask = 0;\n\n\tswitch (sysc_soc->soc) {\n\tcase SOC_2420 ... SOC_3630:\n\t\tmanager_count = 2;\n\t\tframedonetv_irq = false;\n\t\tbreak;\n\tcase SOC_4430 ... SOC_4470:\n\t\tmanager_count = 3;\n\t\tbreak;\n\tcase SOC_5430:\n\tcase SOC_DRA7:\n\t\tmanager_count = 4;\n\t\tbreak;\n\tcase SOC_AM4:\n\t\tmanager_count = 1;\n\t\tframedonetv_irq = false;\n\t\tbreak;\n\tcase SOC_UNKNOWN:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tdevm_iounmap(ddata->dev, ddata->module_va);\n\tddata->module_va = devm_ioremap(ddata->dev,\n\t\t\t\t\tddata->module_pa,\n\t\t\t\t\tddata->module_size);\n\tif (!ddata->module_va)\n\t\treturn -EIO;\n\n\t \n\tval = sysc_read(ddata, dispc_offset + 0x40);\n\tlcd_en = val & lcd_en_mask;\n\tdigit_en = val & digit_en_mask;\n\tif (lcd_en)\n\t\tirq_mask |= BIT(0);\t\t\t \n\tif (digit_en) {\n\t\tif (framedonetv_irq)\n\t\t\tirq_mask |= BIT(24);\t\t \n\t\telse\n\t\t\tirq_mask |= BIT(2) | BIT(3);\t \n\t}\n\tif (disable && (lcd_en || digit_en))\n\t\tsysc_write(ddata, dispc_offset + 0x40,\n\t\t\t   val & ~(lcd_en_mask | digit_en_mask));\n\n\tif (manager_count <= 2)\n\t\treturn irq_mask;\n\n\t \n\tval = sysc_read(ddata, dispc_offset + 0x238);\n\tlcd2_en = val & lcd_en_mask;\n\tif (lcd2_en)\n\t\tirq_mask |= BIT(22);\t\t\t \n\tif (disable && lcd2_en)\n\t\tsysc_write(ddata, dispc_offset + 0x238,\n\t\t\t   val & ~lcd_en_mask);\n\n\tif (manager_count <= 3)\n\t\treturn irq_mask;\n\n\t \n\tval = sysc_read(ddata, dispc_offset + 0x848);\n\tlcd3_en = val & lcd_en_mask;\n\tif (lcd3_en)\n\t\tirq_mask |= BIT(30);\t\t\t \n\tif (disable && lcd3_en)\n\t\tsysc_write(ddata, dispc_offset + 0x848,\n\t\t\t   val & ~lcd_en_mask);\n\n\treturn irq_mask;\n}\n\n \nstatic void sysc_pre_reset_quirk_dss(struct sysc *ddata)\n{\n\tconst int dispc_offset = 0x1000;\n\tint error;\n\tu32 irq_mask, val;\n\n\t \n\tirq_mask = sysc_quirk_dispc(ddata, dispc_offset, false);\n\tif (!irq_mask)\n\t\treturn;\n\n\t \n\tsysc_write(ddata, dispc_offset + 0x18, irq_mask);\n\n\t \n\tval = sysc_quirk_dispc(ddata, dispc_offset, true);\n\n\t \n\terror = readl_poll_timeout(ddata->module_va + dispc_offset + 0x18,\n\t\t\t\t   val, val != irq_mask, 100, 50);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"%s: timed out %08x !+ %08x\\n\",\n\t\t\t __func__, val, irq_mask);\n\n\tif (sysc_soc->soc == SOC_3430 || sysc_soc->soc == SOC_AM35) {\n\t\t \n\t\tsysc_write(ddata, 0x44, 0);\n\n\t\t \n\t\tsysc_write(ddata, 0x48, 0);\n\t}\n\n\t \n\tsysc_write(ddata, 0x40, 0);\n}\n\n \nstatic void sysc_pre_reset_quirk_hdq1w(struct sysc *ddata)\n{\n\tint offset = 0x0c;\t \n\tu16 val;\n\n\tval = sysc_read(ddata, offset);\n\tval |= BIT(5);\n\tsysc_write(ddata, offset, val);\n}\n\n \nstatic void sysc_module_enable_quirk_aess(struct sysc *ddata)\n{\n\tint offset = 0x7c;\t \n\n\tsysc_write(ddata, offset, 1);\n}\n\n \nstatic void sysc_clk_quirk_i2c(struct sysc *ddata, bool enable)\n{\n\tint offset;\n\tu16 val;\n\n\t \n\tif ((ddata->revision & 0xffffff00) == 0x001f0000)\n\t\toffset = 0x24;\n\telse\n\t\toffset = 0xa4;\n\n\t \n\tval = sysc_read(ddata, offset);\n\tif (enable)\n\t\tval |= BIT(15);\n\telse\n\t\tval &= ~BIT(15);\n\tsysc_write(ddata, offset, val);\n}\n\nstatic void sysc_pre_reset_quirk_i2c(struct sysc *ddata)\n{\n\tsysc_clk_quirk_i2c(ddata, false);\n}\n\nstatic void sysc_post_reset_quirk_i2c(struct sysc *ddata)\n{\n\tsysc_clk_quirk_i2c(ddata, true);\n}\n\n \nstatic void sysc_quirk_rtc(struct sysc *ddata, bool lock)\n{\n\tu32 val, kick0_val = 0, kick1_val = 0;\n\tunsigned long flags;\n\tint error;\n\n\tif (!lock) {\n\t\tkick0_val = 0x83e70b13;\n\t\tkick1_val = 0x95a4f1e0;\n\t}\n\n\tlocal_irq_save(flags);\n\t \n\terror = readl_poll_timeout_atomic(ddata->module_va + 0x44, val,\n\t\t\t\t\t  !(val & BIT(0)), 100, 50);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"rtc busy timeout\\n\");\n\t \n\tsysc_write(ddata, 0x6c, kick0_val);\n\tsysc_write(ddata, 0x70, kick1_val);\n\tlocal_irq_restore(flags);\n}\n\nstatic void sysc_module_unlock_quirk_rtc(struct sysc *ddata)\n{\n\tsysc_quirk_rtc(ddata, false);\n}\n\nstatic void sysc_module_lock_quirk_rtc(struct sysc *ddata)\n{\n\tsysc_quirk_rtc(ddata, true);\n}\n\n \nstatic void sysc_module_enable_quirk_otg(struct sysc *ddata)\n{\n\tint offset = 0x414;\t \n\n\tsysc_write(ddata, offset, 0);\n}\n\nstatic void sysc_module_disable_quirk_otg(struct sysc *ddata)\n{\n\tint offset = 0x414;\t \n\tu32 val = BIT(0);\t \n\n\tsysc_write(ddata, offset, val);\n}\n\n \nstatic void sysc_module_enable_quirk_sgx(struct sysc *ddata)\n{\n\tint offset = 0xff08;\t \n\tu32 val = BIT(31);\t \n\n\tsysc_write(ddata, offset, val);\n}\n\n \nstatic void sysc_reset_done_quirk_wdt(struct sysc *ddata)\n{\n\tint wps, spr, error;\n\tu32 val;\n\n\twps = 0x34;\n\tspr = 0x48;\n\n\tsysc_write(ddata, spr, 0xaaaa);\n\terror = readl_poll_timeout(ddata->module_va + wps, val,\n\t\t\t\t   !(val & 0x10), 100,\n\t\t\t\t   MAX_MODULE_SOFTRESET_WAIT);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"wdt disable step1 failed\\n\");\n\n\tsysc_write(ddata, spr, 0x5555);\n\terror = readl_poll_timeout(ddata->module_va + wps, val,\n\t\t\t\t   !(val & 0x10), 100,\n\t\t\t\t   MAX_MODULE_SOFTRESET_WAIT);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"wdt disable step2 failed\\n\");\n}\n\n \nstatic void sysc_module_disable_quirk_pruss(struct sysc *ddata)\n{\n\tu32 reg;\n\n\treg = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);\n\treg |= SYSC_PRUSS_STANDBY_INIT;\n\tsysc_write(ddata, ddata->offsets[SYSC_SYSCONFIG], reg);\n}\n\nstatic void sysc_init_module_quirks(struct sysc *ddata)\n{\n\tif (ddata->legacy_mode || !ddata->name)\n\t\treturn;\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_HDQ1W) {\n\t\tddata->pre_reset_quirk = sysc_pre_reset_quirk_hdq1w;\n\n\t\treturn;\n\t}\n\n#ifdef CONFIG_OMAP_GPMC_DEBUG\n\tif (ddata->cfg.quirks & SYSC_QUIRK_GPMC_DEBUG) {\n\t\tddata->cfg.quirks |= SYSC_QUIRK_NO_RESET_ON_INIT;\n\n\t\treturn;\n\t}\n#endif\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_I2C) {\n\t\tddata->pre_reset_quirk = sysc_pre_reset_quirk_i2c;\n\t\tddata->post_reset_quirk = sysc_post_reset_quirk_i2c;\n\n\t\treturn;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_AESS)\n\t\tddata->module_enable_quirk = sysc_module_enable_quirk_aess;\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_DSS_RESET)\n\t\tddata->pre_reset_quirk = sysc_pre_reset_quirk_dss;\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_RTC_UNLOCK) {\n\t\tddata->module_unlock_quirk = sysc_module_unlock_quirk_rtc;\n\t\tddata->module_lock_quirk = sysc_module_lock_quirk_rtc;\n\n\t\treturn;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_OTG) {\n\t\tddata->module_enable_quirk = sysc_module_enable_quirk_otg;\n\t\tddata->module_disable_quirk = sysc_module_disable_quirk_otg;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_SGX)\n\t\tddata->module_enable_quirk = sysc_module_enable_quirk_sgx;\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_WDT) {\n\t\tddata->reset_done_quirk = sysc_reset_done_quirk_wdt;\n\t\tddata->module_disable_quirk = sysc_reset_done_quirk_wdt;\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_MODULE_QUIRK_PRUSS)\n\t\tddata->module_disable_quirk = sysc_module_disable_quirk_pruss;\n}\n\nstatic int sysc_clockdomain_init(struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata = dev_get_platdata(ddata->dev);\n\tstruct clk *fck = NULL, *ick = NULL;\n\tint error;\n\n\tif (!pdata || !pdata->init_clockdomain)\n\t\treturn 0;\n\n\tswitch (ddata->nr_clocks) {\n\tcase 2:\n\t\tick = ddata->clocks[SYSC_ICK];\n\t\tfallthrough;\n\tcase 1:\n\t\tfck = ddata->clocks[SYSC_FCK];\n\t\tbreak;\n\tcase 0:\n\t\treturn 0;\n\t}\n\n\terror = pdata->init_clockdomain(ddata->dev, fck, ick, &ddata->cookie);\n\tif (!error || error == -ENODEV)\n\t\treturn 0;\n\n\treturn error;\n}\n\n \nstatic int sysc_legacy_init(struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata = dev_get_platdata(ddata->dev);\n\tint error;\n\n\tif (!pdata || !pdata->init_module)\n\t\treturn 0;\n\n\terror = pdata->init_module(ddata->dev, ddata->mdata, &ddata->cookie);\n\tif (error == -EEXIST)\n\t\terror = 0;\n\n\treturn error;\n}\n\n \nstatic int sysc_reset(struct sysc *ddata)\n{\n\tint sysc_offset, sysc_val, error;\n\tu32 sysc_mask;\n\n\tsysc_offset = ddata->offsets[SYSC_SYSCONFIG];\n\n\tif (ddata->legacy_mode ||\n\t    ddata->cap->regbits->srst_shift < 0 ||\n\t    ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT)\n\t\treturn 0;\n\n\tsysc_mask = BIT(ddata->cap->regbits->srst_shift);\n\n\tif (ddata->pre_reset_quirk)\n\t\tddata->pre_reset_quirk(ddata);\n\n\tif (sysc_offset >= 0) {\n\t\tsysc_val = sysc_read_sysconfig(ddata);\n\t\tsysc_val |= sysc_mask;\n\t\tsysc_write(ddata, sysc_offset, sysc_val);\n\n\t\t \n\t\tif (ddata->cfg.srst_udelay)\n\t\t\tfsleep(ddata->cfg.srst_udelay);\n\n\t\t \n\t\tsysc_val = sysc_read_sysconfig(ddata);\n\t}\n\n\tif (ddata->post_reset_quirk)\n\t\tddata->post_reset_quirk(ddata);\n\n\terror = sysc_wait_softreset(ddata);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"OCP softreset timed out\\n\");\n\n\tif (ddata->reset_done_quirk)\n\t\tddata->reset_done_quirk(ddata);\n\n\treturn error;\n}\n\n \nstatic int sysc_init_module(struct sysc *ddata)\n{\n\tbool rstctrl_deasserted = false;\n\tint error = 0;\n\n\terror = sysc_clockdomain_init(ddata);\n\tif (error)\n\t\treturn error;\n\n\tsysc_clkdm_deny_idle(ddata);\n\n\t \n\terror = sysc_enable_opt_clocks(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_enable_main_clocks(ddata);\n\tif (error)\n\t\tgoto err_opt_clocks;\n\n\tif (!(ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT)) {\n\t\terror = reset_control_deassert(ddata->rsts);\n\t\tif (error)\n\t\t\tgoto err_main_clocks;\n\t\trstctrl_deasserted = true;\n\t}\n\n\tddata->revision = sysc_read_revision(ddata);\n\tsysc_init_revision_quirks(ddata);\n\tsysc_init_module_quirks(ddata);\n\n\tif (ddata->legacy_mode) {\n\t\terror = sysc_legacy_init(ddata);\n\t\tif (error)\n\t\t\tgoto err_main_clocks;\n\t}\n\n\tif (!ddata->legacy_mode) {\n\t\terror = sysc_enable_module(ddata->dev);\n\t\tif (error)\n\t\t\tgoto err_main_clocks;\n\t}\n\n\terror = sysc_reset(ddata);\n\tif (error)\n\t\tdev_err(ddata->dev, \"Reset failed with %d\\n\", error);\n\n\tif (error && !ddata->legacy_mode)\n\t\tsysc_disable_module(ddata->dev);\n\nerr_main_clocks:\n\tif (error)\n\t\tsysc_disable_main_clocks(ddata);\nerr_opt_clocks:\n\t \n\tif (error) {\n\t\tsysc_disable_opt_clocks(ddata);\n\t\tsysc_clkdm_allow_idle(ddata);\n\t}\n\n\tif (error && rstctrl_deasserted &&\n\t    !(ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT))\n\t\treset_control_assert(ddata->rsts);\n\n\treturn error;\n}\n\nstatic int sysc_init_sysc_mask(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tint error;\n\tu32 val;\n\n\terror = of_property_read_u32(np, \"ti,sysc-mask\", &val);\n\tif (error)\n\t\treturn 0;\n\n\tddata->cfg.sysc_val = val & ddata->cap->sysc_mask;\n\n\treturn 0;\n}\n\nstatic int sysc_init_idlemode(struct sysc *ddata, u8 *idlemodes,\n\t\t\t      const char *name)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 val;\n\n\tof_property_for_each_u32(np, name, prop, p, val) {\n\t\tif (val >= SYSC_NR_IDLEMODES) {\n\t\t\tdev_err(ddata->dev, \"invalid idlemode: %i\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*idlemodes |=  (1 << val);\n\t}\n\n\treturn 0;\n}\n\nstatic int sysc_init_idlemodes(struct sysc *ddata)\n{\n\tint error;\n\n\terror = sysc_init_idlemode(ddata, &ddata->cfg.midlemodes,\n\t\t\t\t   \"ti,sysc-midle\");\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_idlemode(ddata, &ddata->cfg.sidlemodes,\n\t\t\t\t   \"ti,sysc-sidle\");\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nstatic int sysc_init_syss_mask(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tint error;\n\tu32 val;\n\n\terror = of_property_read_u32(np, \"ti,syss-mask\", &val);\n\tif (error) {\n\t\tif ((ddata->cap->type == TI_SYSC_OMAP4 ||\n\t\t     ddata->cap->type == TI_SYSC_OMAP4_TIMER) &&\n\t\t    (ddata->cfg.sysc_val & SYSC_OMAP4_SOFTRESET))\n\t\t\tddata->cfg.quirks |= SYSC_QUIRK_RESET_STATUS;\n\n\t\treturn 0;\n\t}\n\n\tif (!(val & 1) && (ddata->cfg.sysc_val & SYSC_OMAP4_SOFTRESET))\n\t\tddata->cfg.quirks |= SYSC_QUIRK_RESET_STATUS;\n\n\tddata->cfg.syss_mask = val;\n\n\treturn 0;\n}\n\n \nstatic int sysc_child_add_named_clock(struct sysc *ddata,\n\t\t\t\t      struct device *child,\n\t\t\t\t      const char *name)\n{\n\tstruct clk *clk;\n\tstruct clk_lookup *l;\n\tint error = 0;\n\n\tif (!name)\n\t\treturn 0;\n\n\tclk = clk_get(child, name);\n\tif (!IS_ERR(clk)) {\n\t\terror = -EEXIST;\n\t\tgoto put_clk;\n\t}\n\n\tclk = clk_get(ddata->dev, name);\n\tif (IS_ERR(clk))\n\t\treturn -ENODEV;\n\n\tl = clkdev_create(clk, name, dev_name(child));\n\tif (!l)\n\t\terror = -ENOMEM;\nput_clk:\n\tclk_put(clk);\n\n\treturn error;\n}\n\nstatic int sysc_child_add_clocks(struct sysc *ddata,\n\t\t\t\t struct device *child)\n{\n\tint i, error;\n\n\tfor (i = 0; i < ddata->nr_clocks; i++) {\n\t\terror = sysc_child_add_named_clock(ddata,\n\t\t\t\t\t\t   child,\n\t\t\t\t\t\t   ddata->clock_roles[i]);\n\t\tif (error && error != -EEXIST) {\n\t\t\tdev_err(ddata->dev, \"could not add child clock %s: %i\\n\",\n\t\t\t\tddata->clock_roles[i], error);\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct device_type sysc_device_type = {\n};\n\nstatic struct sysc *sysc_child_to_parent(struct device *dev)\n{\n\tstruct device *parent = dev->parent;\n\n\tif (!parent || parent->type != &sysc_device_type)\n\t\treturn NULL;\n\n\treturn dev_get_drvdata(parent);\n}\n\nstatic int __maybe_unused sysc_child_runtime_suspend(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = sysc_child_to_parent(dev);\n\n\terror = pm_generic_runtime_suspend(dev);\n\tif (error)\n\t\treturn error;\n\n\tif (!ddata->enabled)\n\t\treturn 0;\n\n\treturn sysc_runtime_suspend(ddata->dev);\n}\n\nstatic int __maybe_unused sysc_child_runtime_resume(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = sysc_child_to_parent(dev);\n\n\tif (!ddata->enabled) {\n\t\terror = sysc_runtime_resume(ddata->dev);\n\t\tif (error < 0)\n\t\t\tdev_err(ddata->dev,\n\t\t\t\t\"%s error: %i\\n\", __func__, error);\n\t}\n\n\treturn pm_generic_runtime_resume(dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sysc_child_suspend_noirq(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = sysc_child_to_parent(dev);\n\n\tdev_dbg(ddata->dev, \"%s %s\\n\", __func__,\n\t\tddata->name ? ddata->name : \"\");\n\n\terror = pm_generic_suspend_noirq(dev);\n\tif (error) {\n\t\tdev_err(dev, \"%s error at %i: %i\\n\",\n\t\t\t__func__, __LINE__, error);\n\n\t\treturn error;\n\t}\n\n\tif (!pm_runtime_status_suspended(dev)) {\n\t\terror = pm_generic_runtime_suspend(dev);\n\t\tif (error) {\n\t\t\tdev_dbg(dev, \"%s busy at %i: %i\\n\",\n\t\t\t\t__func__, __LINE__, error);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = sysc_runtime_suspend(ddata->dev);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"%s error at %i: %i\\n\",\n\t\t\t\t__func__, __LINE__, error);\n\n\t\t\treturn error;\n\t\t}\n\n\t\tddata->child_needs_resume = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int sysc_child_resume_noirq(struct device *dev)\n{\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = sysc_child_to_parent(dev);\n\n\tdev_dbg(ddata->dev, \"%s %s\\n\", __func__,\n\t\tddata->name ? ddata->name : \"\");\n\n\tif (ddata->child_needs_resume) {\n\t\tddata->child_needs_resume = false;\n\n\t\terror = sysc_runtime_resume(ddata->dev);\n\t\tif (error)\n\t\t\tdev_err(ddata->dev,\n\t\t\t\t\"%s runtime resume error: %i\\n\",\n\t\t\t\t__func__, error);\n\n\t\terror = pm_generic_runtime_resume(dev);\n\t\tif (error)\n\t\t\tdev_err(ddata->dev,\n\t\t\t\t\"%s generic runtime resume: %i\\n\",\n\t\t\t\t__func__, error);\n\t}\n\n\treturn pm_generic_resume_noirq(dev);\n}\n#endif\n\nstatic struct dev_pm_domain sysc_child_pm_domain = {\n\t.ops = {\n\t\tSET_RUNTIME_PM_OPS(sysc_child_runtime_suspend,\n\t\t\t\t   sysc_child_runtime_resume,\n\t\t\t\t   NULL)\n\t\tUSE_PLATFORM_PM_SLEEP_OPS\n\t\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sysc_child_suspend_noirq,\n\t\t\t\t\t      sysc_child_resume_noirq)\n\t}\n};\n\n \nstatic void sysc_reinit_modules(struct sysc_soc_info *soc)\n{\n\tstruct sysc_module *module;\n\tstruct sysc *ddata;\n\n\tlist_for_each_entry(module, &sysc_soc->restored_modules, node) {\n\t\tddata = module->ddata;\n\t\tsysc_reinit_module(ddata, ddata->enabled);\n\t}\n}\n\n \nstatic int sysc_context_notifier(struct notifier_block *nb, unsigned long cmd,\n\t\t\t\t void *v)\n{\n\tstruct sysc_soc_info *soc;\n\n\tsoc = container_of(nb, struct sysc_soc_info, nb);\n\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\t \n\t\tbreak;\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tsysc_reinit_modules(soc);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic void sysc_add_restored(struct sysc *ddata)\n{\n\tstruct sysc_module *restored_module;\n\n\trestored_module = kzalloc(sizeof(*restored_module), GFP_KERNEL);\n\tif (!restored_module)\n\t\treturn;\n\n\trestored_module->ddata = ddata;\n\n\tmutex_lock(&sysc_soc->list_lock);\n\n\tlist_add(&restored_module->node, &sysc_soc->restored_modules);\n\n\tif (sysc_soc->nb.notifier_call)\n\t\tgoto out_unlock;\n\n\tsysc_soc->nb.notifier_call = sysc_context_notifier;\n\tcpu_pm_register_notifier(&sysc_soc->nb);\n\nout_unlock:\n\tmutex_unlock(&sysc_soc->list_lock);\n}\n\n \nstatic void sysc_legacy_idle_quirk(struct sysc *ddata, struct device *child)\n{\n\tif (ddata->cfg.quirks & SYSC_QUIRK_LEGACY_IDLE)\n\t\tdev_pm_domain_set(child, &sysc_child_pm_domain);\n}\n\nstatic int sysc_notifier_call(struct notifier_block *nb,\n\t\t\t      unsigned long event, void *device)\n{\n\tstruct device *dev = device;\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = sysc_child_to_parent(dev);\n\tif (!ddata)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\terror = sysc_child_add_clocks(ddata, dev);\n\t\tif (error)\n\t\t\treturn error;\n\t\tsysc_legacy_idle_quirk(ddata, dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sysc_nb = {\n\t.notifier_call = sysc_notifier_call,\n};\n\n \nstruct sysc_dts_quirk {\n\tconst char *name;\n\tu32 mask;\n};\n\nstatic const struct sysc_dts_quirk sysc_dts_quirks[] = {\n\t{ .name = \"ti,no-idle-on-init\",\n\t  .mask = SYSC_QUIRK_NO_IDLE_ON_INIT, },\n\t{ .name = \"ti,no-reset-on-init\",\n\t  .mask = SYSC_QUIRK_NO_RESET_ON_INIT, },\n\t{ .name = \"ti,no-idle\",\n\t  .mask = SYSC_QUIRK_NO_IDLE, },\n};\n\nstatic void sysc_parse_dts_quirks(struct sysc *ddata, struct device_node *np,\n\t\t\t\t  bool is_child)\n{\n\tconst struct property *prop;\n\tint i, len;\n\n\tfor (i = 0; i < ARRAY_SIZE(sysc_dts_quirks); i++) {\n\t\tconst char *name = sysc_dts_quirks[i].name;\n\n\t\tprop = of_get_property(np, name, &len);\n\t\tif (!prop)\n\t\t\tcontinue;\n\n\t\tddata->cfg.quirks |= sysc_dts_quirks[i].mask;\n\t\tif (is_child) {\n\t\t\tdev_warn(ddata->dev,\n\t\t\t\t \"dts flag should be at module level for %s\\n\",\n\t\t\t\t name);\n\t\t}\n\t}\n}\n\nstatic int sysc_init_dts_quirks(struct sysc *ddata)\n{\n\tstruct device_node *np = ddata->dev->of_node;\n\tint error;\n\tu32 val;\n\n\tddata->legacy_mode = of_get_property(np, \"ti,hwmods\", NULL);\n\n\tsysc_parse_dts_quirks(ddata, np, false);\n\terror = of_property_read_u32(np, \"ti,sysc-delay-us\", &val);\n\tif (!error) {\n\t\tif (val > 255) {\n\t\t\tdev_warn(ddata->dev, \"bad ti,sysc-delay-us: %i\\n\",\n\t\t\t\t val);\n\t\t}\n\n\t\tddata->cfg.srst_udelay = (u8)val;\n\t}\n\n\treturn 0;\n}\n\nstatic void sysc_unprepare(struct sysc *ddata)\n{\n\tint i;\n\n\tif (!ddata->clocks)\n\t\treturn;\n\n\tfor (i = 0; i < SYSC_MAX_CLOCKS; i++) {\n\t\tif (!IS_ERR_OR_NULL(ddata->clocks[i]))\n\t\t\tclk_unprepare(ddata->clocks[i]);\n\t}\n}\n\n \nstatic const struct sysc_regbits sysc_regbits_omap2 = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = 12,\n\t.sidle_shift = 3,\n\t.clkact_shift = 8,\n\t.emufree_shift = 5,\n\t.enwkup_shift = 2,\n\t.srst_shift = 1,\n\t.autoidle_shift = 0,\n};\n\nstatic const struct sysc_capabilities sysc_omap2 = {\n\t.type = TI_SYSC_OMAP2,\n\t.sysc_mask = SYSC_OMAP2_CLOCKACTIVITY | SYSC_OMAP2_EMUFREE |\n\t\t     SYSC_OMAP2_ENAWAKEUP | SYSC_OMAP2_SOFTRESET |\n\t\t     SYSC_OMAP2_AUTOIDLE,\n\t.regbits = &sysc_regbits_omap2,\n};\n\n \nstatic const struct sysc_capabilities sysc_omap2_timer = {\n\t.type = TI_SYSC_OMAP2_TIMER,\n\t.sysc_mask = SYSC_OMAP2_CLOCKACTIVITY | SYSC_OMAP2_EMUFREE |\n\t\t     SYSC_OMAP2_ENAWAKEUP | SYSC_OMAP2_SOFTRESET |\n\t\t     SYSC_OMAP2_AUTOIDLE,\n\t.regbits = &sysc_regbits_omap2,\n\t.mod_quirks = SYSC_QUIRK_USE_CLOCKACT,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap3_sham = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = 4,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = -ENODEV,\n\t.srst_shift = 1,\n\t.autoidle_shift = 0,\n\t.emufree_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap3_sham = {\n\t.type = TI_SYSC_OMAP3_SHAM,\n\t.sysc_mask = SYSC_OMAP2_SOFTRESET | SYSC_OMAP2_AUTOIDLE,\n\t.regbits = &sysc_regbits_omap3_sham,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap3_aes = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = 6,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = -ENODEV,\n\t.srst_shift = 1,\n\t.autoidle_shift = 0,\n\t.emufree_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap3_aes = {\n\t.type = TI_SYSC_OMAP3_AES,\n\t.sysc_mask = SYSC_OMAP2_SOFTRESET | SYSC_OMAP2_AUTOIDLE,\n\t.regbits = &sysc_regbits_omap3_aes,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap4 = {\n\t.dmadisable_shift = 16,\n\t.midle_shift = 4,\n\t.sidle_shift = 2,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = -ENODEV,\n\t.emufree_shift = 1,\n\t.srst_shift = 0,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap4 = {\n\t.type = TI_SYSC_OMAP4,\n\t.sysc_mask = SYSC_OMAP4_DMADISABLE | SYSC_OMAP4_FREEEMU |\n\t\t     SYSC_OMAP4_SOFTRESET,\n\t.regbits = &sysc_regbits_omap4,\n};\n\nstatic const struct sysc_capabilities sysc_omap4_timer = {\n\t.type = TI_SYSC_OMAP4_TIMER,\n\t.sysc_mask = SYSC_OMAP4_DMADISABLE | SYSC_OMAP4_FREEEMU |\n\t\t     SYSC_OMAP4_SOFTRESET,\n\t.regbits = &sysc_regbits_omap4,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap4_simple = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = 2,\n\t.sidle_shift = 0,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = -ENODEV,\n\t.srst_shift = -ENODEV,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap4_simple = {\n\t.type = TI_SYSC_OMAP4_SIMPLE,\n\t.regbits = &sysc_regbits_omap4_simple,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap34xx_sr = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = -ENODEV,\n\t.clkact_shift = 20,\n\t.enwkup_shift = -ENODEV,\n\t.srst_shift = -ENODEV,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_34xx_sr = {\n\t.type = TI_SYSC_OMAP34XX_SR,\n\t.sysc_mask = SYSC_OMAP2_CLOCKACTIVITY,\n\t.regbits = &sysc_regbits_omap34xx_sr,\n\t.mod_quirks = SYSC_QUIRK_USE_CLOCKACT | SYSC_QUIRK_UNCACHED |\n\t\t      SYSC_QUIRK_LEGACY_IDLE,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap36xx_sr = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = 24,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = 26,\n\t.srst_shift = -ENODEV,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_36xx_sr = {\n\t.type = TI_SYSC_OMAP36XX_SR,\n\t.sysc_mask = SYSC_OMAP3_SR_ENAWAKEUP,\n\t.regbits = &sysc_regbits_omap36xx_sr,\n\t.mod_quirks = SYSC_QUIRK_UNCACHED | SYSC_QUIRK_LEGACY_IDLE,\n};\n\nstatic const struct sysc_capabilities sysc_omap4_sr = {\n\t.type = TI_SYSC_OMAP4_SR,\n\t.regbits = &sysc_regbits_omap36xx_sr,\n\t.mod_quirks = SYSC_QUIRK_LEGACY_IDLE,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap4_mcasp = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = 0,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = -ENODEV,\n\t.srst_shift = -ENODEV,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap4_mcasp = {\n\t.type = TI_SYSC_OMAP4_MCASP,\n\t.regbits = &sysc_regbits_omap4_mcasp,\n\t.mod_quirks = SYSC_QUIRK_OPT_CLKS_NEEDED,\n};\n\n \nstatic const struct sysc_capabilities sysc_dra7_mcasp = {\n\t.type = TI_SYSC_OMAP4_SIMPLE,\n\t.regbits = &sysc_regbits_omap4_simple,\n\t.mod_quirks = SYSC_QUIRK_OPT_CLKS_NEEDED,\n};\n\n \nstatic const struct sysc_regbits sysc_regbits_omap4_usb_host_fs = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = 24,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = 26,\n\t.srst_shift = -ENODEV,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_omap4_usb_host_fs = {\n\t.type = TI_SYSC_OMAP4_USB_HOST_FS,\n\t.sysc_mask = SYSC_OMAP2_ENAWAKEUP,\n\t.regbits = &sysc_regbits_omap4_usb_host_fs,\n};\n\nstatic const struct sysc_regbits sysc_regbits_dra7_mcan = {\n\t.dmadisable_shift = -ENODEV,\n\t.midle_shift = -ENODEV,\n\t.sidle_shift = -ENODEV,\n\t.clkact_shift = -ENODEV,\n\t.enwkup_shift = 4,\n\t.srst_shift = 0,\n\t.emufree_shift = -ENODEV,\n\t.autoidle_shift = -ENODEV,\n};\n\nstatic const struct sysc_capabilities sysc_dra7_mcan = {\n\t.type = TI_SYSC_DRA7_MCAN,\n\t.sysc_mask = SYSC_DRA7_MCAN_ENAWAKEUP | SYSC_OMAP4_SOFTRESET,\n\t.regbits = &sysc_regbits_dra7_mcan,\n\t.mod_quirks = SYSS_QUIRK_RESETDONE_INVERTED,\n};\n\n \nstatic const struct sysc_capabilities sysc_pruss = {\n\t.type = TI_SYSC_PRUSS,\n\t.sysc_mask = SYSC_PRUSS_STANDBY_INIT | SYSC_PRUSS_SUB_MWAIT,\n\t.regbits = &sysc_regbits_omap4_simple,\n\t.mod_quirks = SYSC_MODULE_QUIRK_PRUSS,\n};\n\nstatic int sysc_init_pdata(struct sysc *ddata)\n{\n\tstruct ti_sysc_platform_data *pdata = dev_get_platdata(ddata->dev);\n\tstruct ti_sysc_module_data *mdata;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tmdata = devm_kzalloc(ddata->dev, sizeof(*mdata), GFP_KERNEL);\n\tif (!mdata)\n\t\treturn -ENOMEM;\n\n\tif (ddata->legacy_mode) {\n\t\tmdata->name = ddata->legacy_mode;\n\t\tmdata->module_pa = ddata->module_pa;\n\t\tmdata->module_size = ddata->module_size;\n\t\tmdata->offsets = ddata->offsets;\n\t\tmdata->nr_offsets = SYSC_MAX_REGS;\n\t\tmdata->cap = ddata->cap;\n\t\tmdata->cfg = &ddata->cfg;\n\t}\n\n\tddata->mdata = mdata;\n\n\treturn 0;\n}\n\nstatic int sysc_init_match(struct sysc *ddata)\n{\n\tconst struct sysc_capabilities *cap;\n\n\tcap = of_device_get_match_data(ddata->dev);\n\tif (!cap)\n\t\treturn -EINVAL;\n\n\tddata->cap = cap;\n\tif (ddata->cap)\n\t\tddata->cfg.quirks |= ddata->cap->mod_quirks;\n\n\treturn 0;\n}\n\nstatic void ti_sysc_idle(struct work_struct *work)\n{\n\tstruct sysc *ddata;\n\n\tddata = container_of(work, struct sysc, idle_work.work);\n\n\t \n\tif (ddata->cfg.quirks & (SYSC_QUIRK_NO_IDLE |\n\t\t\t\t SYSC_QUIRK_NO_IDLE_ON_INIT)) {\n\t\tsysc_disable_main_clocks(ddata);\n\t\tsysc_disable_opt_clocks(ddata);\n\t\tsysc_clkdm_allow_idle(ddata);\n\t}\n\n\t \n\tif (ddata->cfg.quirks & SYSC_QUIRK_NO_IDLE)\n\t\treturn;\n\n\t \n\tif (pm_runtime_active(ddata->dev))\n\t\tpm_runtime_put_sync(ddata->dev);\n}\n\n \nstatic const struct soc_device_attribute sysc_soc_match[] = {\n\tSOC_FLAG(\"OMAP242*\", SOC_2420),\n\tSOC_FLAG(\"OMAP243*\", SOC_2430),\n\tSOC_FLAG(\"AM35*\", SOC_AM35),\n\tSOC_FLAG(\"OMAP3[45]*\", SOC_3430),\n\tSOC_FLAG(\"OMAP3[67]*\", SOC_3630),\n\tSOC_FLAG(\"OMAP443*\", SOC_4430),\n\tSOC_FLAG(\"OMAP446*\", SOC_4460),\n\tSOC_FLAG(\"OMAP447*\", SOC_4470),\n\tSOC_FLAG(\"OMAP54*\", SOC_5430),\n\tSOC_FLAG(\"AM433\", SOC_AM3),\n\tSOC_FLAG(\"AM43*\", SOC_AM4),\n\tSOC_FLAG(\"DRA7*\", SOC_DRA7),\n\n\t{   }\n};\n\n \nstatic const struct soc_device_attribute sysc_soc_feat_match[] = {\n\t \n\tSOC_FLAG(\"AM3505\", DIS_SGX),\n\tSOC_FLAG(\"OMAP3525\", DIS_SGX),\n\tSOC_FLAG(\"OMAP3515\", DIS_IVA | DIS_SGX),\n\tSOC_FLAG(\"OMAP3503\", DIS_ISP | DIS_IVA | DIS_SGX),\n\n\t \n\tSOC_FLAG(\"AM3703\", DIS_IVA | DIS_SGX),\n\tSOC_FLAG(\"DM3725\", DIS_SGX),\n\tSOC_FLAG(\"OMAP3611\", DIS_ISP | DIS_IVA | DIS_SGX),\n\tSOC_FLAG(\"OMAP3615/AM3715\", DIS_IVA),\n\tSOC_FLAG(\"OMAP3621\", DIS_ISP),\n\n\t{   }\n};\n\nstatic int sysc_add_disabled(unsigned long base)\n{\n\tstruct sysc_address *disabled_module;\n\n\tdisabled_module = kzalloc(sizeof(*disabled_module), GFP_KERNEL);\n\tif (!disabled_module)\n\t\treturn -ENOMEM;\n\n\tdisabled_module->base = base;\n\n\tmutex_lock(&sysc_soc->list_lock);\n\tlist_add(&disabled_module->node, &sysc_soc->disabled_modules);\n\tmutex_unlock(&sysc_soc->list_lock);\n\n\treturn 0;\n}\n\n \nstatic int sysc_init_static_data(struct sysc *ddata)\n{\n\tconst struct soc_device_attribute *match;\n\tstruct ti_sysc_platform_data *pdata;\n\tunsigned long features = 0;\n\tstruct device_node *np;\n\n\tif (sysc_soc)\n\t\treturn 0;\n\n\tsysc_soc = kzalloc(sizeof(*sysc_soc), GFP_KERNEL);\n\tif (!sysc_soc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sysc_soc->list_lock);\n\tINIT_LIST_HEAD(&sysc_soc->disabled_modules);\n\tINIT_LIST_HEAD(&sysc_soc->restored_modules);\n\tsysc_soc->general_purpose = true;\n\n\tpdata = dev_get_platdata(ddata->dev);\n\tif (pdata && pdata->soc_type_gp)\n\t\tsysc_soc->general_purpose = pdata->soc_type_gp();\n\n\tmatch = soc_device_match(sysc_soc_match);\n\tif (match && match->data)\n\t\tsysc_soc->soc = (enum sysc_soc)(uintptr_t)match->data;\n\n\t \n\tswitch (sysc_soc->soc) {\n\tcase SOC_AM3:\n\tcase SOC_AM4:\n\tcase SOC_4430 ... SOC_4470:\n\tcase SOC_5430:\n\tcase SOC_DRA7:\n\t\tnp = of_find_node_by_path(\"/ocp\");\n\t\tWARN_ONCE(np && of_device_is_compatible(np, \"simple-bus\"),\n\t\t\t  \"ti-sysc: Incomplete old dtb, please update\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!sysc_soc->general_purpose) {\n\t\tswitch (sysc_soc->soc) {\n\t\tcase SOC_3430 ... SOC_3630:\n\t\t\tsysc_add_disabled(0x48304000);\t \n\t\t\tbreak;\n\t\tcase SOC_AM3:\n\t\t\tsysc_add_disabled(0x48310000);   \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmatch = soc_device_match(sysc_soc_feat_match);\n\tif (!match)\n\t\treturn 0;\n\n\tif (match->data)\n\t\tfeatures = (unsigned long)match->data;\n\n\t \n\tif (features & DIS_ISP)\n\t\tsysc_add_disabled(0x480bd400);\n\tif (features & DIS_IVA)\n\t\tsysc_add_disabled(0x5d000000);\n\tif (features & DIS_SGX)\n\t\tsysc_add_disabled(0x50000000);\n\n\treturn 0;\n}\n\nstatic void sysc_cleanup_static_data(void)\n{\n\tstruct sysc_module *restored_module;\n\tstruct sysc_address *disabled_module;\n\tstruct list_head *pos, *tmp;\n\n\tif (!sysc_soc)\n\t\treturn;\n\n\tif (sysc_soc->nb.notifier_call)\n\t\tcpu_pm_unregister_notifier(&sysc_soc->nb);\n\n\tmutex_lock(&sysc_soc->list_lock);\n\tlist_for_each_safe(pos, tmp, &sysc_soc->restored_modules) {\n\t\trestored_module = list_entry(pos, struct sysc_module, node);\n\t\tlist_del(pos);\n\t\tkfree(restored_module);\n\t}\n\tlist_for_each_safe(pos, tmp, &sysc_soc->disabled_modules) {\n\t\tdisabled_module = list_entry(pos, struct sysc_address, node);\n\t\tlist_del(pos);\n\t\tkfree(disabled_module);\n\t}\n\tmutex_unlock(&sysc_soc->list_lock);\n}\n\nstatic int sysc_check_disabled_devices(struct sysc *ddata)\n{\n\tstruct sysc_address *disabled_module;\n\tint error = 0;\n\n\tmutex_lock(&sysc_soc->list_lock);\n\tlist_for_each_entry(disabled_module, &sysc_soc->disabled_modules, node) {\n\t\tif (ddata->module_pa == disabled_module->base) {\n\t\t\tdev_dbg(ddata->dev, \"module disabled for this SoC\\n\");\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&sysc_soc->list_lock);\n\n\treturn error;\n}\n\n \nstatic int sysc_check_active_timer(struct sysc *ddata)\n{\n\tint error;\n\n\tif (ddata->cap->type != TI_SYSC_OMAP2_TIMER &&\n\t    ddata->cap->type != TI_SYSC_OMAP4_TIMER)\n\t\treturn 0;\n\n\t \n\tif (sysc_soc->soc == SOC_3430 || sysc_soc->soc == SOC_AM35)\n\t\terror = -ENXIO;\n\telse\n\t\terror = -EBUSY;\n\n\tif ((ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT) &&\n\t    (ddata->cfg.quirks & SYSC_QUIRK_NO_IDLE))\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sysc_match_table[] = {\n\t{ .compatible = \"simple-bus\", },\n\t{   },\n};\n\nstatic int sysc_probe(struct platform_device *pdev)\n{\n\tstruct ti_sysc_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct sysc *ddata;\n\tint error;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->offsets[SYSC_REVISION] = -ENODEV;\n\tddata->offsets[SYSC_SYSCONFIG] = -ENODEV;\n\tddata->offsets[SYSC_SYSSTATUS] = -ENODEV;\n\tddata->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ddata);\n\n\terror = sysc_init_static_data(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_match(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_dts_quirks(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_map_and_check_registers(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_sysc_mask(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_idlemodes(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_syss_mask(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_pdata(ddata);\n\tif (error)\n\t\treturn error;\n\n\tsysc_init_early_quirks(ddata);\n\n\terror = sysc_check_disabled_devices(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_check_active_timer(ddata);\n\tif (error == -ENXIO)\n\t\tddata->reserved = true;\n\telse if (error)\n\t\treturn error;\n\n\terror = sysc_get_clocks(ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = sysc_init_resets(ddata);\n\tif (error)\n\t\tgoto unprepare;\n\n\terror = sysc_init_module(ddata);\n\tif (error)\n\t\tgoto unprepare;\n\n\tpm_runtime_enable(ddata->dev);\n\terror = pm_runtime_resume_and_get(ddata->dev);\n\tif (error < 0) {\n\t\tpm_runtime_disable(ddata->dev);\n\t\tgoto unprepare;\n\t}\n\n\t \n\tif (!(ddata->cfg.quirks &\n\t      (SYSC_QUIRK_NO_IDLE | SYSC_QUIRK_NO_IDLE_ON_INIT))) {\n\t\tsysc_disable_main_clocks(ddata);\n\t\tsysc_disable_opt_clocks(ddata);\n\t\tsysc_clkdm_allow_idle(ddata);\n\t}\n\n\tif (!(ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT))\n\t\treset_control_assert(ddata->rsts);\n\n\tsysc_show_registers(ddata);\n\n\tddata->dev->type = &sysc_device_type;\n\n\tif (!ddata->reserved) {\n\t\terror = of_platform_populate(ddata->dev->of_node,\n\t\t\t\t\t     sysc_match_table,\n\t\t\t\t\t     pdata ? pdata->auxdata : NULL,\n\t\t\t\t\t     ddata->dev);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\tINIT_DELAYED_WORK(&ddata->idle_work, ti_sysc_idle);\n\n\t \n\tif (ddata->cfg.quirks & (SYSC_QUIRK_NO_IDLE |\n\t\t\t\t SYSC_QUIRK_NO_IDLE_ON_INIT |\n\t\t\t\t SYSC_QUIRK_NO_RESET_ON_INIT)) {\n\t\tschedule_delayed_work(&ddata->idle_work, 3000);\n\t} else {\n\t\tpm_runtime_put(&pdev->dev);\n\t}\n\n\tif (ddata->cfg.quirks & SYSC_QUIRK_REINIT_ON_CTX_LOST)\n\t\tsysc_add_restored(ddata);\n\n\treturn 0;\n\nerr:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\nunprepare:\n\tsysc_unprepare(ddata);\n\n\treturn error;\n}\n\nstatic int sysc_remove(struct platform_device *pdev)\n{\n\tstruct sysc *ddata = platform_get_drvdata(pdev);\n\tint error;\n\n\t \n\tif (cancel_delayed_work_sync(&ddata->idle_work))\n\t\tti_sysc_idle(&ddata->idle_work.work);\n\n\terror = pm_runtime_resume_and_get(ddata->dev);\n\tif (error < 0) {\n\t\tpm_runtime_disable(ddata->dev);\n\t\tgoto unprepare;\n\t}\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (!reset_control_status(ddata->rsts))\n\t\treset_control_assert(ddata->rsts);\n\nunprepare:\n\tsysc_unprepare(ddata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sysc_match[] = {\n\t{ .compatible = \"ti,sysc-omap2\", .data = &sysc_omap2, },\n\t{ .compatible = \"ti,sysc-omap2-timer\", .data = &sysc_omap2_timer, },\n\t{ .compatible = \"ti,sysc-omap4\", .data = &sysc_omap4, },\n\t{ .compatible = \"ti,sysc-omap4-timer\", .data = &sysc_omap4_timer, },\n\t{ .compatible = \"ti,sysc-omap4-simple\", .data = &sysc_omap4_simple, },\n\t{ .compatible = \"ti,sysc-omap3430-sr\", .data = &sysc_34xx_sr, },\n\t{ .compatible = \"ti,sysc-omap3630-sr\", .data = &sysc_36xx_sr, },\n\t{ .compatible = \"ti,sysc-omap4-sr\", .data = &sysc_omap4_sr, },\n\t{ .compatible = \"ti,sysc-omap3-sham\", .data = &sysc_omap3_sham, },\n\t{ .compatible = \"ti,sysc-omap-aes\", .data = &sysc_omap3_aes, },\n\t{ .compatible = \"ti,sysc-mcasp\", .data = &sysc_omap4_mcasp, },\n\t{ .compatible = \"ti,sysc-dra7-mcasp\", .data = &sysc_dra7_mcasp, },\n\t{ .compatible = \"ti,sysc-usb-host-fs\",\n\t  .data = &sysc_omap4_usb_host_fs, },\n\t{ .compatible = \"ti,sysc-dra7-mcan\", .data = &sysc_dra7_mcan, },\n\t{ .compatible = \"ti,sysc-pruss\", .data = &sysc_pruss, },\n\t{  },\n};\nMODULE_DEVICE_TABLE(of, sysc_match);\n\nstatic struct platform_driver sysc_driver = {\n\t.probe\t\t= sysc_probe,\n\t.remove\t\t= sysc_remove,\n\t.driver         = {\n\t\t.name   = \"ti-sysc\",\n\t\t.of_match_table\t= sysc_match,\n\t\t.pm = &sysc_pm_ops,\n\t},\n};\n\nstatic int __init sysc_init(void)\n{\n\tbus_register_notifier(&platform_bus_type, &sysc_nb);\n\n\treturn platform_driver_register(&sysc_driver);\n}\nmodule_init(sysc_init);\n\nstatic void __exit sysc_exit(void)\n{\n\tbus_unregister_notifier(&platform_bus_type, &sysc_nb);\n\tplatform_driver_unregister(&sysc_driver);\n\tsysc_cleanup_static_data();\n}\nmodule_exit(sysc_exit);\n\nMODULE_DESCRIPTION(\"TI sysc interconnect target driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}