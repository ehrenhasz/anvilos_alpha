{
  "module_name": "virqfd.c",
  "hash_id": "a1ada35753db350b432ef01446c01c1e0f823d14c100343cd6b3dc3c73302f43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/virqfd.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/eventfd.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"vfio.h\"\n\nstatic struct workqueue_struct *vfio_irqfd_cleanup_wq;\nstatic DEFINE_SPINLOCK(virqfd_lock);\n\nint __init vfio_virqfd_init(void)\n{\n\tvfio_irqfd_cleanup_wq =\n\t\tcreate_singlethread_workqueue(\"vfio-irqfd-cleanup\");\n\tif (!vfio_irqfd_cleanup_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid vfio_virqfd_exit(void)\n{\n\tdestroy_workqueue(vfio_irqfd_cleanup_wq);\n}\n\nstatic void virqfd_deactivate(struct virqfd *virqfd)\n{\n\tqueue_work(vfio_irqfd_cleanup_wq, &virqfd->shutdown);\n}\n\nstatic int virqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct virqfd *virqfd = container_of(wait, struct virqfd, wait);\n\t__poll_t flags = key_to_poll(key);\n\n\tif (flags & EPOLLIN) {\n\t\tu64 cnt;\n\t\teventfd_ctx_do_read(virqfd->eventfd, &cnt);\n\n\t\t \n\t\tif ((!virqfd->handler ||\n\t\t     virqfd->handler(virqfd->opaque, virqfd->data)) &&\n\t\t    virqfd->thread)\n\t\t\tschedule_work(&virqfd->inject);\n\t}\n\n\tif (flags & EPOLLHUP) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&virqfd_lock, flags);\n\n\t\t \n\t\tif (*(virqfd->pvirqfd) == virqfd) {\n\t\t\t*(virqfd->pvirqfd) = NULL;\n\t\t\tvirqfd_deactivate(virqfd);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&virqfd_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void virqfd_ptable_queue_proc(struct file *file,\n\t\t\t\t     wait_queue_head_t *wqh, poll_table *pt)\n{\n\tstruct virqfd *virqfd = container_of(pt, struct virqfd, pt);\n\tadd_wait_queue(wqh, &virqfd->wait);\n}\n\nstatic void virqfd_shutdown(struct work_struct *work)\n{\n\tstruct virqfd *virqfd = container_of(work, struct virqfd, shutdown);\n\tu64 cnt;\n\n\teventfd_ctx_remove_wait_queue(virqfd->eventfd, &virqfd->wait, &cnt);\n\tflush_work(&virqfd->inject);\n\teventfd_ctx_put(virqfd->eventfd);\n\n\tkfree(virqfd);\n}\n\nstatic void virqfd_inject(struct work_struct *work)\n{\n\tstruct virqfd *virqfd = container_of(work, struct virqfd, inject);\n\tif (virqfd->thread)\n\t\tvirqfd->thread(virqfd->opaque, virqfd->data);\n}\n\nint vfio_virqfd_enable(void *opaque,\n\t\t       int (*handler)(void *, void *),\n\t\t       void (*thread)(void *, void *),\n\t\t       void *data, struct virqfd **pvirqfd, int fd)\n{\n\tstruct fd irqfd;\n\tstruct eventfd_ctx *ctx;\n\tstruct virqfd *virqfd;\n\tint ret = 0;\n\t__poll_t events;\n\n\tvirqfd = kzalloc(sizeof(*virqfd), GFP_KERNEL_ACCOUNT);\n\tif (!virqfd)\n\t\treturn -ENOMEM;\n\n\tvirqfd->pvirqfd = pvirqfd;\n\tvirqfd->opaque = opaque;\n\tvirqfd->handler = handler;\n\tvirqfd->thread = thread;\n\tvirqfd->data = data;\n\n\tINIT_WORK(&virqfd->shutdown, virqfd_shutdown);\n\tINIT_WORK(&virqfd->inject, virqfd_inject);\n\n\tirqfd = fdget(fd);\n\tif (!irqfd.file) {\n\t\tret = -EBADF;\n\t\tgoto err_fd;\n\t}\n\n\tctx = eventfd_ctx_fileget(irqfd.file);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto err_ctx;\n\t}\n\n\tvirqfd->eventfd = ctx;\n\n\t \n\tspin_lock_irq(&virqfd_lock);\n\n\tif (*pvirqfd) {\n\t\tspin_unlock_irq(&virqfd_lock);\n\t\tret = -EBUSY;\n\t\tgoto err_busy;\n\t}\n\t*pvirqfd = virqfd;\n\n\tspin_unlock_irq(&virqfd_lock);\n\n\t \n\tinit_waitqueue_func_entry(&virqfd->wait, virqfd_wakeup);\n\tinit_poll_funcptr(&virqfd->pt, virqfd_ptable_queue_proc);\n\n\tevents = vfs_poll(irqfd.file, &virqfd->pt);\n\n\t \n\tif (events & EPOLLIN) {\n\t\tif ((!handler || handler(opaque, data)) && thread)\n\t\t\tschedule_work(&virqfd->inject);\n\t}\n\n\t \n\tfdput(irqfd);\n\n\treturn 0;\nerr_busy:\n\teventfd_ctx_put(ctx);\nerr_ctx:\n\tfdput(irqfd);\nerr_fd:\n\tkfree(virqfd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfio_virqfd_enable);\n\nvoid vfio_virqfd_disable(struct virqfd **pvirqfd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&virqfd_lock, flags);\n\n\tif (*pvirqfd) {\n\t\tvirqfd_deactivate(*pvirqfd);\n\t\t*pvirqfd = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&virqfd_lock, flags);\n\n\t \n\tflush_workqueue(vfio_irqfd_cleanup_wq);\n}\nEXPORT_SYMBOL_GPL(vfio_virqfd_disable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}