{
  "module_name": "iova_bitmap.c",
  "hash_id": "a7be2fc082c2c9e3083e46349399053732bea6aaef04f79e7956ae1e37f32d5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/iova_bitmap.c",
  "human_readable_source": "\n \n#include <linux/iova_bitmap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n\n#define BITS_PER_PAGE (PAGE_SIZE * BITS_PER_BYTE)\n\n \nstruct iova_bitmap_map {\n\t \n\tunsigned long iova;\n\n\t \n\tunsigned long pgshift;\n\n\t \n\tunsigned long pgoff;\n\n\t \n\tunsigned long npages;\n\n\t \n\tstruct page **pages;\n};\n\n \nstruct iova_bitmap {\n\t \n\tstruct iova_bitmap_map mapped;\n\n\t \n\tu64 __user *bitmap;\n\n\t \n\tunsigned long mapped_base_index;\n\n\t \n\tunsigned long mapped_total_index;\n\n\t \n\tunsigned long iova;\n\n\t \n\tsize_t length;\n};\n\n \nstatic unsigned long iova_bitmap_offset_to_index(struct iova_bitmap *bitmap,\n\t\t\t\t\t\t unsigned long iova)\n{\n\tunsigned long pgsize = 1 << bitmap->mapped.pgshift;\n\n\treturn iova / (BITS_PER_TYPE(*bitmap->bitmap) * pgsize);\n}\n\n \nstatic unsigned long iova_bitmap_index_to_offset(struct iova_bitmap *bitmap,\n\t\t\t\t\t\t unsigned long index)\n{\n\tunsigned long pgshift = bitmap->mapped.pgshift;\n\n\treturn (index * BITS_PER_TYPE(*bitmap->bitmap)) << pgshift;\n}\n\n \nstatic unsigned long iova_bitmap_mapped_iova(struct iova_bitmap *bitmap)\n{\n\tunsigned long skip = bitmap->mapped_base_index;\n\n\treturn bitmap->iova + iova_bitmap_index_to_offset(bitmap, skip);\n}\n\n \nstatic int iova_bitmap_get(struct iova_bitmap *bitmap)\n{\n\tstruct iova_bitmap_map *mapped = &bitmap->mapped;\n\tunsigned long npages;\n\tu64 __user *addr;\n\tlong ret;\n\n\t \n\tnpages = DIV_ROUND_UP((bitmap->mapped_total_index -\n\t\t\t       bitmap->mapped_base_index) *\n\t\t\t       sizeof(*bitmap->bitmap), PAGE_SIZE);\n\n\t \n\tnpages = min(npages,  PAGE_SIZE / sizeof(struct page *));\n\n\t \n\taddr = bitmap->bitmap + bitmap->mapped_base_index;\n\n\tret = pin_user_pages_fast((unsigned long)addr, npages,\n\t\t\t\t  FOLL_WRITE, mapped->pages);\n\tif (ret <= 0)\n\t\treturn -EFAULT;\n\n\tmapped->npages = (unsigned long)ret;\n\t \n\tmapped->iova = iova_bitmap_mapped_iova(bitmap);\n\n\t \n\tmapped->pgoff = offset_in_page(addr);\n\treturn 0;\n}\n\n \nstatic void iova_bitmap_put(struct iova_bitmap *bitmap)\n{\n\tstruct iova_bitmap_map *mapped = &bitmap->mapped;\n\n\tif (mapped->npages) {\n\t\tunpin_user_pages(mapped->pages, mapped->npages);\n\t\tmapped->npages = 0;\n\t}\n}\n\n \nstruct iova_bitmap *iova_bitmap_alloc(unsigned long iova, size_t length,\n\t\t\t\t      unsigned long page_size, u64 __user *data)\n{\n\tstruct iova_bitmap_map *mapped;\n\tstruct iova_bitmap *bitmap;\n\tint rc;\n\n\tbitmap = kzalloc(sizeof(*bitmap), GFP_KERNEL);\n\tif (!bitmap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmapped = &bitmap->mapped;\n\tmapped->pgshift = __ffs(page_size);\n\tbitmap->bitmap = data;\n\tbitmap->mapped_total_index =\n\t\tiova_bitmap_offset_to_index(bitmap, length - 1) + 1;\n\tbitmap->iova = iova;\n\tbitmap->length = length;\n\tmapped->iova = iova;\n\tmapped->pages = (struct page **)__get_free_page(GFP_KERNEL);\n\tif (!mapped->pages) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\trc = iova_bitmap_get(bitmap);\n\tif (rc)\n\t\tgoto err;\n\treturn bitmap;\n\nerr:\n\tiova_bitmap_free(bitmap);\n\treturn ERR_PTR(rc);\n}\n\n \nvoid iova_bitmap_free(struct iova_bitmap *bitmap)\n{\n\tstruct iova_bitmap_map *mapped = &bitmap->mapped;\n\n\tiova_bitmap_put(bitmap);\n\n\tif (mapped->pages) {\n\t\tfree_page((unsigned long)mapped->pages);\n\t\tmapped->pages = NULL;\n\t}\n\n\tkfree(bitmap);\n}\n\n \nstatic unsigned long iova_bitmap_mapped_remaining(struct iova_bitmap *bitmap)\n{\n\tunsigned long remaining, bytes;\n\n\tbytes = (bitmap->mapped.npages << PAGE_SHIFT) - bitmap->mapped.pgoff;\n\n\tremaining = bitmap->mapped_total_index - bitmap->mapped_base_index;\n\tremaining = min_t(unsigned long, remaining,\n\t\t\t  bytes / sizeof(*bitmap->bitmap));\n\n\treturn remaining;\n}\n\n \nstatic unsigned long iova_bitmap_mapped_length(struct iova_bitmap *bitmap)\n{\n\tunsigned long max_iova = bitmap->iova + bitmap->length - 1;\n\tunsigned long iova = iova_bitmap_mapped_iova(bitmap);\n\tunsigned long remaining;\n\n\t \n\tremaining = iova_bitmap_index_to_offset(bitmap,\n\t\t\tiova_bitmap_mapped_remaining(bitmap));\n\n\tif (iova + remaining - 1 > max_iova)\n\t\tremaining -= ((iova + remaining - 1) - max_iova);\n\n\treturn remaining;\n}\n\n \nstatic bool iova_bitmap_done(struct iova_bitmap *bitmap)\n{\n\treturn bitmap->mapped_base_index >= bitmap->mapped_total_index;\n}\n\n \nstatic int iova_bitmap_advance(struct iova_bitmap *bitmap)\n{\n\tunsigned long iova = iova_bitmap_mapped_length(bitmap) - 1;\n\tunsigned long count = iova_bitmap_offset_to_index(bitmap, iova) + 1;\n\n\tbitmap->mapped_base_index += count;\n\n\tiova_bitmap_put(bitmap);\n\tif (iova_bitmap_done(bitmap))\n\t\treturn 0;\n\n\t \n\treturn iova_bitmap_get(bitmap);\n}\n\n \nint iova_bitmap_for_each(struct iova_bitmap *bitmap, void *opaque,\n\t\t\t iova_bitmap_fn_t fn)\n{\n\tint ret = 0;\n\n\tfor (; !iova_bitmap_done(bitmap) && !ret;\n\t     ret = iova_bitmap_advance(bitmap)) {\n\t\tret = fn(bitmap, iova_bitmap_mapped_iova(bitmap),\n\t\t\t iova_bitmap_mapped_length(bitmap), opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nvoid iova_bitmap_set(struct iova_bitmap *bitmap,\n\t\t     unsigned long iova, size_t length)\n{\n\tstruct iova_bitmap_map *mapped = &bitmap->mapped;\n\tunsigned long cur_bit = ((iova - mapped->iova) >>\n\t\t\tmapped->pgshift) + mapped->pgoff * BITS_PER_BYTE;\n\tunsigned long last_bit = (((iova + length - 1) - mapped->iova) >>\n\t\t\tmapped->pgshift) + mapped->pgoff * BITS_PER_BYTE;\n\n\tdo {\n\t\tunsigned int page_idx = cur_bit / BITS_PER_PAGE;\n\t\tunsigned int offset = cur_bit % BITS_PER_PAGE;\n\t\tunsigned int nbits = min(BITS_PER_PAGE - offset,\n\t\t\t\t\t last_bit - cur_bit + 1);\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap_local_page(mapped->pages[page_idx]);\n\t\tbitmap_set(kaddr, offset, nbits);\n\t\tkunmap_local(kaddr);\n\t\tcur_bit += nbits;\n\t} while (cur_bit <= last_bit);\n}\nEXPORT_SYMBOL_GPL(iova_bitmap_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}