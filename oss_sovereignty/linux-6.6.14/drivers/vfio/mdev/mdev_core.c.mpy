{
  "module_name": "mdev_core.c",
  "hash_id": "651c4bf7a7faef60c949a273930855206776dbd6b5e75610d79ea3d4a0bebcf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/mdev/mdev_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/mdev.h>\n\n#include \"mdev_private.h\"\n\n#define DRIVER_VERSION\t\t\"0.1\"\n#define DRIVER_AUTHOR\t\t\"NVIDIA Corporation\"\n#define DRIVER_DESC\t\t\"Mediated device Core Driver\"\n\nstatic struct class_compat *mdev_bus_compat_class;\n\nstatic LIST_HEAD(mdev_list);\nstatic DEFINE_MUTEX(mdev_list_lock);\n\n \nstatic void mdev_device_remove_common(struct mdev_device *mdev)\n{\n\tstruct mdev_parent *parent = mdev->type->parent;\n\n\tmdev_remove_sysfs_files(mdev);\n\tdevice_del(&mdev->dev);\n\tlockdep_assert_held(&parent->unreg_sem);\n\t \n\tput_device(&mdev->dev);\n}\n\nstatic int mdev_device_remove_cb(struct device *dev, void *data)\n{\n\tif (dev->bus == &mdev_bus_type)\n\t\tmdev_device_remove_common(to_mdev_device(dev));\n\treturn 0;\n}\n\n \nint mdev_register_parent(struct mdev_parent *parent, struct device *dev,\n\t\tstruct mdev_driver *mdev_driver, struct mdev_type **types,\n\t\tunsigned int nr_types)\n{\n\tchar *env_string = \"MDEV_STATE=registered\";\n\tchar *envp[] = { env_string, NULL };\n\tint ret;\n\n\tmemset(parent, 0, sizeof(*parent));\n\tinit_rwsem(&parent->unreg_sem);\n\tparent->dev = dev;\n\tparent->mdev_driver = mdev_driver;\n\tparent->types = types;\n\tparent->nr_types = nr_types;\n\tatomic_set(&parent->available_instances, mdev_driver->max_instances);\n\n\tret = parent_create_sysfs_files(parent);\n\tif (ret)\n\t\treturn ret;\n\n\tret = class_compat_create_link(mdev_bus_compat_class, dev, NULL);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to create compatibility class link\\n\");\n\n\tdev_info(dev, \"MDEV: Registered\\n\");\n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n\treturn 0;\n}\nEXPORT_SYMBOL(mdev_register_parent);\n\n \nvoid mdev_unregister_parent(struct mdev_parent *parent)\n{\n\tchar *env_string = \"MDEV_STATE=unregistered\";\n\tchar *envp[] = { env_string, NULL };\n\n\tdev_info(parent->dev, \"MDEV: Unregistering\\n\");\n\n\tdown_write(&parent->unreg_sem);\n\tclass_compat_remove_link(mdev_bus_compat_class, parent->dev, NULL);\n\tdevice_for_each_child(parent->dev, NULL, mdev_device_remove_cb);\n\tparent_remove_sysfs_files(parent);\n\tup_write(&parent->unreg_sem);\n\n\tkobject_uevent_env(&parent->dev->kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(mdev_unregister_parent);\n\nstatic void mdev_device_release(struct device *dev)\n{\n\tstruct mdev_device *mdev = to_mdev_device(dev);\n\tstruct mdev_parent *parent = mdev->type->parent;\n\n\tmutex_lock(&mdev_list_lock);\n\tlist_del(&mdev->next);\n\tif (!parent->mdev_driver->get_available)\n\t\tatomic_inc(&parent->available_instances);\n\tmutex_unlock(&mdev_list_lock);\n\n\t \n\tkobject_put(&mdev->type->kobj);\n\n\tdev_dbg(&mdev->dev, \"MDEV: destroying\\n\");\n\tkfree(mdev);\n}\n\nint mdev_device_create(struct mdev_type *type, const guid_t *uuid)\n{\n\tint ret;\n\tstruct mdev_device *mdev, *tmp;\n\tstruct mdev_parent *parent = type->parent;\n\tstruct mdev_driver *drv = parent->mdev_driver;\n\n\tmutex_lock(&mdev_list_lock);\n\n\t \n\tlist_for_each_entry(tmp, &mdev_list, next) {\n\t\tif (guid_equal(&tmp->uuid, uuid)) {\n\t\t\tmutex_unlock(&mdev_list_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tif (!drv->get_available) {\n\t\t \n\t\tif (!atomic_read(&parent->available_instances)) {\n\t\t\tmutex_unlock(&mdev_list_lock);\n\t\t\treturn -EUSERS;\n\t\t}\n\t\tatomic_dec(&parent->available_instances);\n\t}\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev) {\n\t\tmutex_unlock(&mdev_list_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tdevice_initialize(&mdev->dev);\n\tmdev->dev.parent  = parent->dev;\n\tmdev->dev.bus = &mdev_bus_type;\n\tmdev->dev.release = mdev_device_release;\n\tmdev->dev.groups = mdev_device_groups;\n\tmdev->type = type;\n\t \n\tkobject_get(&type->kobj);\n\n\tguid_copy(&mdev->uuid, uuid);\n\tlist_add(&mdev->next, &mdev_list);\n\tmutex_unlock(&mdev_list_lock);\n\n\tret = dev_set_name(&mdev->dev, \"%pUl\", uuid);\n\tif (ret)\n\t\tgoto out_put_device;\n\n\t \n\tif (!down_read_trylock(&parent->unreg_sem)) {\n\t\tret = -ENODEV;\n\t\tgoto out_put_device;\n\t}\n\n\tret = device_add(&mdev->dev);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = device_driver_attach(&drv->driver, &mdev->dev);\n\tif (ret)\n\t\tgoto out_del;\n\n\tret = mdev_create_sysfs_files(mdev);\n\tif (ret)\n\t\tgoto out_del;\n\n\tmdev->active = true;\n\tdev_dbg(&mdev->dev, \"MDEV: created\\n\");\n\tup_read(&parent->unreg_sem);\n\n\treturn 0;\n\nout_del:\n\tdevice_del(&mdev->dev);\nout_unlock:\n\tup_read(&parent->unreg_sem);\nout_put_device:\n\tput_device(&mdev->dev);\n\treturn ret;\n}\n\nint mdev_device_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_device *tmp;\n\tstruct mdev_parent *parent = mdev->type->parent;\n\n\tmutex_lock(&mdev_list_lock);\n\tlist_for_each_entry(tmp, &mdev_list, next) {\n\t\tif (tmp == mdev)\n\t\t\tbreak;\n\t}\n\n\tif (tmp != mdev) {\n\t\tmutex_unlock(&mdev_list_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!mdev->active) {\n\t\tmutex_unlock(&mdev_list_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmdev->active = false;\n\tmutex_unlock(&mdev_list_lock);\n\n\t \n\tif (!down_read_trylock(&parent->unreg_sem))\n\t\treturn -ENODEV;\n\n\tmdev_device_remove_common(mdev);\n\tup_read(&parent->unreg_sem);\n\treturn 0;\n}\n\nstatic int __init mdev_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&mdev_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tmdev_bus_compat_class = class_compat_register(\"mdev_bus\");\n\tif (!mdev_bus_compat_class) {\n\t\tbus_unregister(&mdev_bus_type);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit mdev_exit(void)\n{\n\tclass_compat_unregister(mdev_bus_compat_class);\n\tbus_unregister(&mdev_bus_type);\n}\n\nsubsys_initcall(mdev_init)\nmodule_exit(mdev_exit)\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}