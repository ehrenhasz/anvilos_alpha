{
  "module_name": "mdev_sysfs.c",
  "hash_id": "e6a93409b157d1a56851f2d0985521891a537935c7ff3a9d4fff1283e683aaf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/mdev/mdev_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/mdev.h>\n\n#include \"mdev_private.h\"\n\nstruct mdev_type_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct mdev_type *mtype,\n\t\t\tstruct mdev_type_attribute *attr, char *buf);\n\tssize_t (*store)(struct mdev_type *mtype,\n\t\t\t struct mdev_type_attribute *attr, const char *buf,\n\t\t\t size_t count);\n};\n\n#define MDEV_TYPE_ATTR_RO(_name) \\\n\tstruct mdev_type_attribute mdev_type_attr_##_name = __ATTR_RO(_name)\n#define MDEV_TYPE_ATTR_WO(_name) \\\n\tstruct mdev_type_attribute mdev_type_attr_##_name = __ATTR_WO(_name)\n\nstatic ssize_t mdev_type_attr_show(struct kobject *kobj,\n\t\t\t\t     struct attribute *__attr, char *buf)\n{\n\tstruct mdev_type_attribute *attr = to_mdev_type_attr(__attr);\n\tstruct mdev_type *type = to_mdev_type(kobj);\n\tssize_t ret = -EIO;\n\n\tif (attr->show)\n\t\tret = attr->show(type, attr, buf);\n\treturn ret;\n}\n\nstatic ssize_t mdev_type_attr_store(struct kobject *kobj,\n\t\t\t\t      struct attribute *__attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct mdev_type_attribute *attr = to_mdev_type_attr(__attr);\n\tstruct mdev_type *type = to_mdev_type(kobj);\n\tssize_t ret = -EIO;\n\n\tif (attr->store)\n\t\tret = attr->store(type, attr, buf, count);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops mdev_type_sysfs_ops = {\n\t.show = mdev_type_attr_show,\n\t.store = mdev_type_attr_store,\n};\n\nstatic ssize_t create_store(struct mdev_type *mtype,\n\t\t\t    struct mdev_type_attribute *attr, const char *buf,\n\t\t\t    size_t count)\n{\n\tchar *str;\n\tguid_t uuid;\n\tint ret;\n\n\tif ((count < UUID_STRING_LEN) || (count > UUID_STRING_LEN + 1))\n\t\treturn -EINVAL;\n\n\tstr = kstrndup(buf, count, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tret = guid_parse(str, &uuid);\n\tkfree(str);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mdev_device_create(mtype, &uuid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic MDEV_TYPE_ATTR_WO(create);\n\nstatic ssize_t device_api_show(struct mdev_type *mtype,\n\t\t\t       struct mdev_type_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", mtype->parent->mdev_driver->device_api);\n}\nstatic MDEV_TYPE_ATTR_RO(device_api);\n\nstatic ssize_t name_show(struct mdev_type *mtype,\n\t\t\t struct mdev_type_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\tmtype->pretty_name ? mtype->pretty_name : mtype->sysfs_name);\n}\n\nstatic MDEV_TYPE_ATTR_RO(name);\n\nstatic ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct mdev_driver *drv = mtype->parent->mdev_driver;\n\n\tif (drv->get_available)\n\t\treturn sysfs_emit(buf, \"%u\\n\", drv->get_available(mtype));\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  atomic_read(&mtype->parent->available_instances));\n}\nstatic MDEV_TYPE_ATTR_RO(available_instances);\n\nstatic ssize_t description_show(struct mdev_type *mtype,\n\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn mtype->parent->mdev_driver->show_description(mtype, buf);\n}\nstatic MDEV_TYPE_ATTR_RO(description);\n\nstatic struct attribute *mdev_types_core_attrs[] = {\n\t&mdev_type_attr_create.attr,\n\t&mdev_type_attr_device_api.attr,\n\t&mdev_type_attr_name.attr,\n\t&mdev_type_attr_available_instances.attr,\n\t&mdev_type_attr_description.attr,\n\tNULL,\n};\n\nstatic umode_t mdev_types_core_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\tif (attr == &mdev_type_attr_description.attr &&\n\t    !to_mdev_type(kobj)->parent->mdev_driver->show_description)\n\t\treturn 0;\n\treturn attr->mode;\n}\n\nstatic struct attribute_group mdev_type_core_group = {\n\t.attrs = mdev_types_core_attrs,\n\t.is_visible = mdev_types_core_is_visible,\n};\n\nstatic const struct attribute_group *mdev_type_groups[] = {\n\t&mdev_type_core_group,\n\tNULL,\n};\n\nstatic void mdev_type_release(struct kobject *kobj)\n{\n\tstruct mdev_type *type = to_mdev_type(kobj);\n\n\tpr_debug(\"Releasing group %s\\n\", kobj->name);\n\t \n\tput_device(type->parent->dev);\n}\n\nstatic struct kobj_type mdev_type_ktype = {\n\t.sysfs_ops\t= &mdev_type_sysfs_ops,\n\t.release\t= mdev_type_release,\n\t.default_groups\t= mdev_type_groups,\n};\n\nstatic int mdev_type_add(struct mdev_parent *parent, struct mdev_type *type)\n{\n\tint ret;\n\n\ttype->kobj.kset = parent->mdev_types_kset;\n\ttype->parent = parent;\n\t \n\tget_device(parent->dev);\n\n\tret = kobject_init_and_add(&type->kobj, &mdev_type_ktype, NULL,\n\t\t\t\t   \"%s-%s\", dev_driver_string(parent->dev),\n\t\t\t\t   type->sysfs_name);\n\tif (ret) {\n\t\tkobject_put(&type->kobj);\n\t\treturn ret;\n\t}\n\n\ttype->devices_kobj = kobject_create_and_add(\"devices\", &type->kobj);\n\tif (!type->devices_kobj) {\n\t\tret = -ENOMEM;\n\t\tgoto attr_devices_failed;\n\t}\n\n\treturn 0;\n\nattr_devices_failed:\n\tkobject_del(&type->kobj);\n\tkobject_put(&type->kobj);\n\treturn ret;\n}\n\nstatic void mdev_type_remove(struct mdev_type *type)\n{\n\tkobject_put(type->devices_kobj);\n\tkobject_del(&type->kobj);\n\tkobject_put(&type->kobj);\n}\n\n \nvoid parent_remove_sysfs_files(struct mdev_parent *parent)\n{\n\tint i;\n\n\tfor (i = 0; i < parent->nr_types; i++)\n\t\tmdev_type_remove(parent->types[i]);\n\tkset_unregister(parent->mdev_types_kset);\n}\n\nint parent_create_sysfs_files(struct mdev_parent *parent)\n{\n\tint ret, i;\n\n\tparent->mdev_types_kset = kset_create_and_add(\"mdev_supported_types\",\n\t\t\t\t\t       NULL, &parent->dev->kobj);\n\tif (!parent->mdev_types_kset)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < parent->nr_types; i++) {\n\t\tret = mdev_type_add(parent, parent->types[i]);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\twhile (--i >= 0)\n\t\tmdev_type_remove(parent->types[i]);\n\tkset_unregister(parent->mdev_types_kset);\n\treturn ret;\n}\n\nstatic ssize_t remove_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct mdev_device *mdev = to_mdev_device(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val && device_remove_file_self(dev, attr)) {\n\t\tint ret;\n\n\t\tret = mdev_device_remove(mdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(remove);\n\nstatic struct attribute *mdev_device_attrs[] = {\n\t&dev_attr_remove.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdev_device_group = {\n\t.attrs = mdev_device_attrs,\n};\n\nconst struct attribute_group *mdev_device_groups[] = {\n\t&mdev_device_group,\n\tNULL\n};\n\nint mdev_create_sysfs_files(struct mdev_device *mdev)\n{\n\tstruct mdev_type *type = mdev->type;\n\tstruct kobject *kobj = &mdev->dev.kobj;\n\tint ret;\n\n\tret = sysfs_create_link(type->devices_kobj, kobj, dev_name(&mdev->dev));\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_link(kobj, &type->kobj, \"mdev_type\");\n\tif (ret)\n\t\tgoto type_link_failed;\n\treturn ret;\n\ntype_link_failed:\n\tsysfs_remove_link(mdev->type->devices_kobj, dev_name(&mdev->dev));\n\treturn ret;\n}\n\nvoid mdev_remove_sysfs_files(struct mdev_device *mdev)\n{\n\tstruct kobject *kobj = &mdev->dev.kobj;\n\n\tsysfs_remove_link(kobj, \"mdev_type\");\n\tsysfs_remove_link(mdev->type->devices_kobj, dev_name(&mdev->dev));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}