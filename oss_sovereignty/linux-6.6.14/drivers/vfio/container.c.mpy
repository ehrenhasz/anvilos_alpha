{
  "module_name": "container.c",
  "hash_id": "87011c94c2fad452a637823fa7d62cdd53104d284e4a58d71e341d68e2d9812d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/container.c",
  "human_readable_source": "\n \n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/iommu.h>\n#include <linux/miscdevice.h>\n#include <linux/vfio.h>\n#include <uapi/linux/vfio.h>\n\n#include \"vfio.h\"\n\nstruct vfio_container {\n\tstruct kref\t\t\tkref;\n\tstruct list_head\t\tgroup_list;\n\tstruct rw_semaphore\t\tgroup_lock;\n\tstruct vfio_iommu_driver\t*iommu_driver;\n\tvoid\t\t\t\t*iommu_data;\n\tbool\t\t\t\tnoiommu;\n};\n\nstatic struct vfio {\n\tstruct list_head\t\tiommu_drivers_list;\n\tstruct mutex\t\t\tiommu_drivers_lock;\n} vfio;\n\nstatic void *vfio_noiommu_open(unsigned long arg)\n{\n\tif (arg != VFIO_NOIOMMU_IOMMU)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn NULL;\n}\n\nstatic void vfio_noiommu_release(void *iommu_data)\n{\n}\n\nstatic long vfio_noiommu_ioctl(void *iommu_data,\n\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tif (cmd == VFIO_CHECK_EXTENSION)\n\t\treturn vfio_noiommu && (arg == VFIO_NOIOMMU_IOMMU) ? 1 : 0;\n\n\treturn -ENOTTY;\n}\n\nstatic int vfio_noiommu_attach_group(void *iommu_data,\n\t\tstruct iommu_group *iommu_group, enum vfio_group_type type)\n{\n\treturn 0;\n}\n\nstatic void vfio_noiommu_detach_group(void *iommu_data,\n\t\t\t\t      struct iommu_group *iommu_group)\n{\n}\n\nstatic const struct vfio_iommu_driver_ops vfio_noiommu_ops = {\n\t.name = \"vfio-noiommu\",\n\t.owner = THIS_MODULE,\n\t.open = vfio_noiommu_open,\n\t.release = vfio_noiommu_release,\n\t.ioctl = vfio_noiommu_ioctl,\n\t.attach_group = vfio_noiommu_attach_group,\n\t.detach_group = vfio_noiommu_detach_group,\n};\n\n \nstatic bool vfio_iommu_driver_allowed(struct vfio_container *container,\n\t\t\t\t      const struct vfio_iommu_driver *driver)\n{\n\tif (!IS_ENABLED(CONFIG_VFIO_NOIOMMU))\n\t\treturn true;\n\treturn container->noiommu == (driver->ops == &vfio_noiommu_ops);\n}\n\n \nint vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops)\n{\n\tstruct vfio_iommu_driver *driver, *tmp;\n\n\tif (WARN_ON(!ops->register_device != !ops->unregister_device))\n\t\treturn -EINVAL;\n\n\tdriver = kzalloc(sizeof(*driver), GFP_KERNEL);\n\tif (!driver)\n\t\treturn -ENOMEM;\n\n\tdriver->ops = ops;\n\n\tmutex_lock(&vfio.iommu_drivers_lock);\n\n\t \n\tlist_for_each_entry(tmp, &vfio.iommu_drivers_list, vfio_next) {\n\t\tif (tmp->ops == ops) {\n\t\t\tmutex_unlock(&vfio.iommu_drivers_lock);\n\t\t\tkfree(driver);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tlist_add(&driver->vfio_next, &vfio.iommu_drivers_list);\n\n\tmutex_unlock(&vfio.iommu_drivers_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_register_iommu_driver);\n\nvoid vfio_unregister_iommu_driver(const struct vfio_iommu_driver_ops *ops)\n{\n\tstruct vfio_iommu_driver *driver;\n\n\tmutex_lock(&vfio.iommu_drivers_lock);\n\tlist_for_each_entry(driver, &vfio.iommu_drivers_list, vfio_next) {\n\t\tif (driver->ops == ops) {\n\t\t\tlist_del(&driver->vfio_next);\n\t\t\tmutex_unlock(&vfio.iommu_drivers_lock);\n\t\t\tkfree(driver);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&vfio.iommu_drivers_lock);\n}\nEXPORT_SYMBOL_GPL(vfio_unregister_iommu_driver);\n\n \nstatic void vfio_container_release(struct kref *kref)\n{\n\tstruct vfio_container *container;\n\tcontainer = container_of(kref, struct vfio_container, kref);\n\n\tkfree(container);\n}\n\nstatic void vfio_container_get(struct vfio_container *container)\n{\n\tkref_get(&container->kref);\n}\n\nstatic void vfio_container_put(struct vfio_container *container)\n{\n\tkref_put(&container->kref, vfio_container_release);\n}\n\nvoid vfio_device_container_register(struct vfio_device *device)\n{\n\tstruct vfio_iommu_driver *iommu_driver =\n\t\tdevice->group->container->iommu_driver;\n\n\tif (iommu_driver && iommu_driver->ops->register_device)\n\t\tiommu_driver->ops->register_device(\n\t\t\tdevice->group->container->iommu_data, device);\n}\n\nvoid vfio_device_container_unregister(struct vfio_device *device)\n{\n\tstruct vfio_iommu_driver *iommu_driver =\n\t\tdevice->group->container->iommu_driver;\n\n\tif (iommu_driver && iommu_driver->ops->unregister_device)\n\t\tiommu_driver->ops->unregister_device(\n\t\t\tdevice->group->container->iommu_data, device);\n}\n\nstatic long\nvfio_container_ioctl_check_extension(struct vfio_container *container,\n\t\t\t\t     unsigned long arg)\n{\n\tstruct vfio_iommu_driver *driver;\n\tlong ret = 0;\n\n\tdown_read(&container->group_lock);\n\n\tdriver = container->iommu_driver;\n\n\tswitch (arg) {\n\t\t \n\tdefault:\n\t\t \n\t\tif (!driver) {\n\t\t\tmutex_lock(&vfio.iommu_drivers_lock);\n\t\t\tlist_for_each_entry(driver, &vfio.iommu_drivers_list,\n\t\t\t\t\t    vfio_next) {\n\n\t\t\t\tif (!list_empty(&container->group_list) &&\n\t\t\t\t    !vfio_iommu_driver_allowed(container,\n\t\t\t\t\t\t\t       driver))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!try_module_get(driver->ops->owner))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = driver->ops->ioctl(NULL,\n\t\t\t\t\t\t\t VFIO_CHECK_EXTENSION,\n\t\t\t\t\t\t\t arg);\n\t\t\t\tmodule_put(driver->ops->owner);\n\t\t\t\tif (ret > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&vfio.iommu_drivers_lock);\n\t\t} else\n\t\t\tret = driver->ops->ioctl(container->iommu_data,\n\t\t\t\t\t\t VFIO_CHECK_EXTENSION, arg);\n\t}\n\n\tup_read(&container->group_lock);\n\n\treturn ret;\n}\n\n \nstatic int __vfio_container_attach_groups(struct vfio_container *container,\n\t\t\t\t\t  struct vfio_iommu_driver *driver,\n\t\t\t\t\t  void *data)\n{\n\tstruct vfio_group *group;\n\tint ret = -ENODEV;\n\n\tlist_for_each_entry(group, &container->group_list, container_next) {\n\t\tret = driver->ops->attach_group(data, group->iommu_group,\n\t\t\t\t\t\tgroup->type);\n\t\tif (ret)\n\t\t\tgoto unwind;\n\t}\n\n\treturn ret;\n\nunwind:\n\tlist_for_each_entry_continue_reverse(group, &container->group_list,\n\t\t\t\t\t     container_next) {\n\t\tdriver->ops->detach_group(data, group->iommu_group);\n\t}\n\n\treturn ret;\n}\n\nstatic long vfio_ioctl_set_iommu(struct vfio_container *container,\n\t\t\t\t unsigned long arg)\n{\n\tstruct vfio_iommu_driver *driver;\n\tlong ret = -ENODEV;\n\n\tdown_write(&container->group_lock);\n\n\t \n\tif (list_empty(&container->group_list) || container->iommu_driver) {\n\t\tup_write(&container->group_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&vfio.iommu_drivers_lock);\n\tlist_for_each_entry(driver, &vfio.iommu_drivers_list, vfio_next) {\n\t\tvoid *data;\n\n\t\tif (!vfio_iommu_driver_allowed(container, driver))\n\t\t\tcontinue;\n\t\tif (!try_module_get(driver->ops->owner))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (driver->ops->ioctl(NULL, VFIO_CHECK_EXTENSION, arg) <= 0) {\n\t\t\tmodule_put(driver->ops->owner);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata = driver->ops->open(arg);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tmodule_put(driver->ops->owner);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = __vfio_container_attach_groups(container, driver, data);\n\t\tif (ret) {\n\t\t\tdriver->ops->release(data);\n\t\t\tmodule_put(driver->ops->owner);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontainer->iommu_driver = driver;\n\t\tcontainer->iommu_data = data;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&vfio.iommu_drivers_lock);\n\tup_write(&container->group_lock);\n\n\treturn ret;\n}\n\nstatic long vfio_fops_unl_ioctl(struct file *filep,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_container *container = filep->private_data;\n\tstruct vfio_iommu_driver *driver;\n\tvoid *data;\n\tlong ret = -EINVAL;\n\n\tif (!container)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase VFIO_GET_API_VERSION:\n\t\tret = VFIO_API_VERSION;\n\t\tbreak;\n\tcase VFIO_CHECK_EXTENSION:\n\t\tret = vfio_container_ioctl_check_extension(container, arg);\n\t\tbreak;\n\tcase VFIO_SET_IOMMU:\n\t\tret = vfio_ioctl_set_iommu(container, arg);\n\t\tbreak;\n\tdefault:\n\t\tdriver = container->iommu_driver;\n\t\tdata = container->iommu_data;\n\n\t\tif (driver)  \n\t\t\tret = driver->ops->ioctl(data, cmd, arg);\n\t}\n\n\treturn ret;\n}\n\nstatic int vfio_fops_open(struct inode *inode, struct file *filep)\n{\n\tstruct vfio_container *container;\n\n\tcontainer = kzalloc(sizeof(*container), GFP_KERNEL_ACCOUNT);\n\tif (!container)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&container->group_list);\n\tinit_rwsem(&container->group_lock);\n\tkref_init(&container->kref);\n\n\tfilep->private_data = container;\n\n\treturn 0;\n}\n\nstatic int vfio_fops_release(struct inode *inode, struct file *filep)\n{\n\tstruct vfio_container *container = filep->private_data;\n\n\tfilep->private_data = NULL;\n\n\tvfio_container_put(container);\n\n\treturn 0;\n}\n\nstatic const struct file_operations vfio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vfio_fops_open,\n\t.release\t= vfio_fops_release,\n\t.unlocked_ioctl\t= vfio_fops_unl_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n\nstruct vfio_container *vfio_container_from_file(struct file *file)\n{\n\tstruct vfio_container *container;\n\n\t \n\tif (file->f_op != &vfio_fops)\n\t\treturn NULL;\n\n\tcontainer = file->private_data;\n\tWARN_ON(!container);  \n\treturn container;\n}\n\nstatic struct miscdevice vfio_dev = {\n\t.minor = VFIO_MINOR,\n\t.name = \"vfio\",\n\t.fops = &vfio_fops,\n\t.nodename = \"vfio/vfio\",\n\t.mode = S_IRUGO | S_IWUGO,\n};\n\nint vfio_container_attach_group(struct vfio_container *container,\n\t\t\t\tstruct vfio_group *group)\n{\n\tstruct vfio_iommu_driver *driver;\n\tint ret = 0;\n\n\tlockdep_assert_held(&group->group_lock);\n\n\tif (group->type == VFIO_NO_IOMMU && !capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tdown_write(&container->group_lock);\n\n\t \n\tif (!list_empty(&container->group_list) &&\n\t    container->noiommu != (group->type == VFIO_NO_IOMMU)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock_container;\n\t}\n\n\tif (group->type == VFIO_IOMMU) {\n\t\tret = iommu_group_claim_dma_owner(group->iommu_group, group);\n\t\tif (ret)\n\t\t\tgoto out_unlock_container;\n\t}\n\n\tdriver = container->iommu_driver;\n\tif (driver) {\n\t\tret = driver->ops->attach_group(container->iommu_data,\n\t\t\t\t\t\tgroup->iommu_group,\n\t\t\t\t\t\tgroup->type);\n\t\tif (ret) {\n\t\t\tif (group->type == VFIO_IOMMU)\n\t\t\t\tiommu_group_release_dma_owner(\n\t\t\t\t\tgroup->iommu_group);\n\t\t\tgoto out_unlock_container;\n\t\t}\n\t}\n\n\tgroup->container = container;\n\tgroup->container_users = 1;\n\tcontainer->noiommu = (group->type == VFIO_NO_IOMMU);\n\tlist_add(&group->container_next, &container->group_list);\n\n\t \n\tvfio_container_get(container);\n\nout_unlock_container:\n\tup_write(&container->group_lock);\n\treturn ret;\n}\n\nvoid vfio_group_detach_container(struct vfio_group *group)\n{\n\tstruct vfio_container *container = group->container;\n\tstruct vfio_iommu_driver *driver;\n\n\tlockdep_assert_held(&group->group_lock);\n\tWARN_ON(group->container_users != 1);\n\n\tdown_write(&container->group_lock);\n\n\tdriver = container->iommu_driver;\n\tif (driver)\n\t\tdriver->ops->detach_group(container->iommu_data,\n\t\t\t\t\t  group->iommu_group);\n\n\tif (group->type == VFIO_IOMMU)\n\t\tiommu_group_release_dma_owner(group->iommu_group);\n\n\tgroup->container = NULL;\n\tgroup->container_users = 0;\n\tlist_del(&group->container_next);\n\n\t \n\tif (driver && list_empty(&container->group_list)) {\n\t\tdriver->ops->release(container->iommu_data);\n\t\tmodule_put(driver->ops->owner);\n\t\tcontainer->iommu_driver = NULL;\n\t\tcontainer->iommu_data = NULL;\n\t}\n\n\tup_write(&container->group_lock);\n\n\tvfio_container_put(container);\n}\n\nint vfio_group_use_container(struct vfio_group *group)\n{\n\tlockdep_assert_held(&group->group_lock);\n\n\t \n\tif (!group->container->iommu_driver)\n\t\treturn -EINVAL;\n\n\tif (group->type == VFIO_NO_IOMMU && !capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tget_file(group->opened_file);\n\tgroup->container_users++;\n\treturn 0;\n}\n\nvoid vfio_group_unuse_container(struct vfio_group *group)\n{\n\tlockdep_assert_held(&group->group_lock);\n\n\tWARN_ON(group->container_users <= 1);\n\tgroup->container_users--;\n\tfput(group->opened_file);\n}\n\nint vfio_device_container_pin_pages(struct vfio_device *device,\n\t\t\t\t    dma_addr_t iova, int npage,\n\t\t\t\t    int prot, struct page **pages)\n{\n\tstruct vfio_container *container = device->group->container;\n\tstruct iommu_group *iommu_group = device->group->iommu_group;\n\tstruct vfio_iommu_driver *driver = container->iommu_driver;\n\n\tif (npage > VFIO_PIN_PAGES_MAX_ENTRIES)\n\t\treturn -E2BIG;\n\n\tif (unlikely(!driver || !driver->ops->pin_pages))\n\t\treturn -ENOTTY;\n\treturn driver->ops->pin_pages(container->iommu_data, iommu_group, iova,\n\t\t\t\t      npage, prot, pages);\n}\n\nvoid vfio_device_container_unpin_pages(struct vfio_device *device,\n\t\t\t\t       dma_addr_t iova, int npage)\n{\n\tstruct vfio_container *container = device->group->container;\n\n\tif (WARN_ON(npage <= 0 || npage > VFIO_PIN_PAGES_MAX_ENTRIES))\n\t\treturn;\n\n\tcontainer->iommu_driver->ops->unpin_pages(container->iommu_data, iova,\n\t\t\t\t\t\t  npage);\n}\n\nint vfio_device_container_dma_rw(struct vfio_device *device,\n\t\t\t\t dma_addr_t iova, void *data,\n\t\t\t\t size_t len, bool write)\n{\n\tstruct vfio_container *container = device->group->container;\n\tstruct vfio_iommu_driver *driver = container->iommu_driver;\n\n\tif (unlikely(!driver || !driver->ops->dma_rw))\n\t\treturn -ENOTTY;\n\treturn driver->ops->dma_rw(container->iommu_data, iova, data, len,\n\t\t\t\t   write);\n}\n\nint __init vfio_container_init(void)\n{\n\tint ret;\n\n\tmutex_init(&vfio.iommu_drivers_lock);\n\tINIT_LIST_HEAD(&vfio.iommu_drivers_list);\n\n\tret = misc_register(&vfio_dev);\n\tif (ret) {\n\t\tpr_err(\"vfio: misc device register failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_VFIO_NOIOMMU)) {\n\t\tret = vfio_register_iommu_driver(&vfio_noiommu_ops);\n\t\tif (ret)\n\t\t\tgoto err_misc;\n\t}\n\treturn 0;\n\nerr_misc:\n\tmisc_deregister(&vfio_dev);\n\treturn ret;\n}\n\nvoid vfio_container_cleanup(void)\n{\n\tif (IS_ENABLED(CONFIG_VFIO_NOIOMMU))\n\t\tvfio_unregister_iommu_driver(&vfio_noiommu_ops);\n\tmisc_deregister(&vfio_dev);\n\tmutex_destroy(&vfio.iommu_drivers_lock);\n}\n\nMODULE_ALIAS_MISCDEV(VFIO_MINOR);\nMODULE_ALIAS(\"devname:vfio/vfio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}