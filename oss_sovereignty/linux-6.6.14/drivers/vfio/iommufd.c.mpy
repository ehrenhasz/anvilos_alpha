{
  "module_name": "iommufd.c",
  "hash_id": "d85d6f43bd94df4a36bf1813a301e4c9ad7ee1fb87e9b6c0d2143b1f54207f8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/iommufd.c",
  "human_readable_source": "\n \n#include <linux/vfio.h>\n#include <linux/iommufd.h>\n\n#include \"vfio.h\"\n\nMODULE_IMPORT_NS(IOMMUFD);\nMODULE_IMPORT_NS(IOMMUFD_VFIO);\n\nbool vfio_iommufd_device_has_compat_ioas(struct vfio_device *vdev,\n\t\t\t\t\t struct iommufd_ctx *ictx)\n{\n\tu32 ioas_id;\n\n\treturn !iommufd_vfio_compat_ioas_get_id(ictx, &ioas_id);\n}\n\nint vfio_df_iommufd_bind(struct vfio_device_file *df)\n{\n\tstruct vfio_device *vdev = df->device;\n\tstruct iommufd_ctx *ictx = df->iommufd;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\treturn vdev->ops->bind_iommufd(vdev, ictx, &df->devid);\n}\n\nint vfio_iommufd_compat_attach_ioas(struct vfio_device *vdev,\n\t\t\t\t    struct iommufd_ctx *ictx)\n{\n\tu32 ioas_id;\n\tint ret;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\t \n\tif (vfio_device_is_noiommu(vdev))\n\t\treturn 0;\n\n\tret = iommufd_vfio_compat_ioas_get_id(ictx, &ioas_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn vdev->ops->attach_ioas(vdev, &ioas_id);\n}\n\nvoid vfio_df_iommufd_unbind(struct vfio_device_file *df)\n{\n\tstruct vfio_device *vdev = df->device;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (vfio_device_is_noiommu(vdev))\n\t\treturn;\n\n\tif (vdev->ops->unbind_iommufd)\n\t\tvdev->ops->unbind_iommufd(vdev);\n}\n\nstruct iommufd_ctx *vfio_iommufd_device_ictx(struct vfio_device *vdev)\n{\n\tif (vdev->iommufd_device)\n\t\treturn iommufd_device_to_ictx(vdev->iommufd_device);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_device_ictx);\n\nstatic int vfio_iommufd_device_id(struct vfio_device *vdev)\n{\n\tif (vdev->iommufd_device)\n\t\treturn iommufd_device_to_id(vdev->iommufd_device);\n\treturn -EINVAL;\n}\n\n \nint vfio_iommufd_get_dev_id(struct vfio_device *vdev, struct iommufd_ctx *ictx)\n{\n\tstruct iommu_group *group;\n\tint devid;\n\n\tif (vfio_iommufd_device_ictx(vdev) == ictx)\n\t\treturn vfio_iommufd_device_id(vdev);\n\n\tgroup = iommu_group_get(vdev->dev);\n\tif (!group)\n\t\treturn -ENODEV;\n\n\tif (iommufd_ctx_has_group(ictx, group))\n\t\tdevid = -ENOENT;\n\telse\n\t\tdevid = -ENODEV;\n\n\tiommu_group_put(group);\n\n\treturn devid;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_get_dev_id);\n\n \nint vfio_iommufd_physical_bind(struct vfio_device *vdev,\n\t\t\t       struct iommufd_ctx *ictx, u32 *out_device_id)\n{\n\tstruct iommufd_device *idev;\n\n\tidev = iommufd_device_bind(ictx, vdev->dev, out_device_id);\n\tif (IS_ERR(idev))\n\t\treturn PTR_ERR(idev);\n\tvdev->iommufd_device = idev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_physical_bind);\n\nvoid vfio_iommufd_physical_unbind(struct vfio_device *vdev)\n{\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (vdev->iommufd_attached) {\n\t\tiommufd_device_detach(vdev->iommufd_device);\n\t\tvdev->iommufd_attached = false;\n\t}\n\tiommufd_device_unbind(vdev->iommufd_device);\n\tvdev->iommufd_device = NULL;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_physical_unbind);\n\nint vfio_iommufd_physical_attach_ioas(struct vfio_device *vdev, u32 *pt_id)\n{\n\tint rc;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (WARN_ON(!vdev->iommufd_device))\n\t\treturn -EINVAL;\n\n\tif (vdev->iommufd_attached)\n\t\trc = iommufd_device_replace(vdev->iommufd_device, pt_id);\n\telse\n\t\trc = iommufd_device_attach(vdev->iommufd_device, pt_id);\n\tif (rc)\n\t\treturn rc;\n\tvdev->iommufd_attached = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_physical_attach_ioas);\n\nvoid vfio_iommufd_physical_detach_ioas(struct vfio_device *vdev)\n{\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (WARN_ON(!vdev->iommufd_device) || !vdev->iommufd_attached)\n\t\treturn;\n\n\tiommufd_device_detach(vdev->iommufd_device);\n\tvdev->iommufd_attached = false;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_physical_detach_ioas);\n\n \n\nstatic void vfio_emulated_unmap(void *data, unsigned long iova,\n\t\t\t\tunsigned long length)\n{\n\tstruct vfio_device *vdev = data;\n\n\tif (vdev->ops->dma_unmap)\n\t\tvdev->ops->dma_unmap(vdev, iova, length);\n}\n\nstatic const struct iommufd_access_ops vfio_user_ops = {\n\t.needs_pin_pages = 1,\n\t.unmap = vfio_emulated_unmap,\n};\n\nint vfio_iommufd_emulated_bind(struct vfio_device *vdev,\n\t\t\t       struct iommufd_ctx *ictx, u32 *out_device_id)\n{\n\tstruct iommufd_access *user;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tuser = iommufd_access_create(ictx, &vfio_user_ops, vdev, out_device_id);\n\tif (IS_ERR(user))\n\t\treturn PTR_ERR(user);\n\tvdev->iommufd_access = user;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_emulated_bind);\n\nvoid vfio_iommufd_emulated_unbind(struct vfio_device *vdev)\n{\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (vdev->iommufd_access) {\n\t\tiommufd_access_destroy(vdev->iommufd_access);\n\t\tvdev->iommufd_attached = false;\n\t\tvdev->iommufd_access = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_emulated_unbind);\n\nint vfio_iommufd_emulated_attach_ioas(struct vfio_device *vdev, u32 *pt_id)\n{\n\tint rc;\n\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (vdev->iommufd_attached)\n\t\trc = iommufd_access_replace(vdev->iommufd_access, *pt_id);\n\telse\n\t\trc = iommufd_access_attach(vdev->iommufd_access, *pt_id);\n\tif (rc)\n\t\treturn rc;\n\tvdev->iommufd_attached = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_emulated_attach_ioas);\n\nvoid vfio_iommufd_emulated_detach_ioas(struct vfio_device *vdev)\n{\n\tlockdep_assert_held(&vdev->dev_set->lock);\n\n\tif (WARN_ON(!vdev->iommufd_access) ||\n\t    !vdev->iommufd_attached)\n\t\treturn;\n\n\tiommufd_access_detach(vdev->iommufd_access);\n\tvdev->iommufd_attached = false;\n}\nEXPORT_SYMBOL_GPL(vfio_iommufd_emulated_detach_ioas);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}