{
  "module_name": "vfio_fsl_mc_intr.c",
  "hash_id": "df93bac052f6f34037b5cc1cb80cbe76569ac081933a0a04b0f28181e35b1b62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/fsl-mc/vfio_fsl_mc_intr.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/eventfd.h>\n\n#include \"linux/fsl/mc.h\"\n#include \"vfio_fsl_mc_private.h\"\n\nstatic int vfio_fsl_mc_irqs_allocate(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tstruct vfio_fsl_mc_irq *mc_irq;\n\tint irq_count;\n\tint ret, i;\n\n\t \n\tif (mc_dev->obj_desc.irq_count == 0)\n\t\treturn 0;\n\n\t \n\tif (vdev->mc_irqs)\n\t\treturn 0;\n\n\tirq_count = mc_dev->obj_desc.irq_count;\n\n\tmc_irq = kcalloc(irq_count, sizeof(*mc_irq), GFP_KERNEL_ACCOUNT);\n\tif (!mc_irq)\n\t\treturn -ENOMEM;\n\n\t \n\tret = fsl_mc_allocate_irqs(mc_dev);\n\tif (ret) {\n\t\tkfree(mc_irq);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < irq_count; i++) {\n\t\tmc_irq[i].count = 1;\n\t\tmc_irq[i].flags = VFIO_IRQ_INFO_EVENTFD;\n\t}\n\n\tvdev->mc_irqs = mc_irq;\n\n\treturn 0;\n}\n\nstatic irqreturn_t vfio_fsl_mc_irq_handler(int irq_num, void *arg)\n{\n\tstruct vfio_fsl_mc_irq *mc_irq = (struct vfio_fsl_mc_irq *)arg;\n\n\teventfd_signal(mc_irq->trigger, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic int vfio_set_trigger(struct vfio_fsl_mc_device *vdev,\n\t\t\t\t\t\t   int index, int fd)\n{\n\tstruct vfio_fsl_mc_irq *irq = &vdev->mc_irqs[index];\n\tstruct eventfd_ctx *trigger;\n\tint hwirq;\n\tint ret;\n\n\thwirq = vdev->mc_dev->irqs[index]->virq;\n\tif (irq->trigger) {\n\t\tfree_irq(hwirq, irq);\n\t\tkfree(irq->name);\n\t\teventfd_ctx_put(irq->trigger);\n\t\tirq->trigger = NULL;\n\t}\n\n\tif (fd < 0)  \n\t\treturn 0;\n\n\tirq->name = kasprintf(GFP_KERNEL_ACCOUNT, \"vfio-irq[%d](%s)\",\n\t\t\t    hwirq, dev_name(&vdev->mc_dev->dev));\n\tif (!irq->name)\n\t\treturn -ENOMEM;\n\n\ttrigger = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(trigger)) {\n\t\tkfree(irq->name);\n\t\treturn PTR_ERR(trigger);\n\t}\n\n\tirq->trigger = trigger;\n\n\tret = request_irq(hwirq, vfio_fsl_mc_irq_handler, 0,\n\t\t  irq->name, irq);\n\tif (ret) {\n\t\tkfree(irq->name);\n\t\teventfd_ctx_put(trigger);\n\t\tirq->trigger = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_fsl_mc_set_irq_trigger(struct vfio_fsl_mc_device *vdev,\n\t\t\t\t       unsigned int index, unsigned int start,\n\t\t\t\t       unsigned int count, u32 flags,\n\t\t\t\t       void *data)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint ret, hwirq;\n\tstruct vfio_fsl_mc_irq *irq;\n\tstruct device *cont_dev = fsl_mc_cont_dev(&mc_dev->dev);\n\tstruct fsl_mc_device *mc_cont = to_fsl_mc_device(cont_dev);\n\n\tif (!count && (flags & VFIO_IRQ_SET_DATA_NONE))\n\t\treturn vfio_set_trigger(vdev, index, -1);\n\n\tif (start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vdev->vdev.dev_set->lock);\n\tret = fsl_mc_populate_irq_pool(mc_cont,\n\t\t\tFSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = vfio_fsl_mc_irqs_allocate(vdev);\n\tif (ret)\n\t\tgoto unlock;\n\tmutex_unlock(&vdev->vdev.dev_set->lock);\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\ts32 fd = *(s32 *)data;\n\n\t\treturn vfio_set_trigger(vdev, index, fd);\n\t}\n\n\thwirq = vdev->mc_dev->irqs[index]->virq;\n\n\tirq = &vdev->mc_irqs[index];\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_fsl_mc_irq_handler(hwirq, irq);\n\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tu8 trigger = *(u8 *)data;\n\n\t\tif (trigger)\n\t\t\tvfio_fsl_mc_irq_handler(hwirq, irq);\n\t}\n\n\treturn 0;\n\nunlock:\n\tmutex_unlock(&vdev->vdev.dev_set->lock);\n\treturn ret;\n\n}\n\nint vfio_fsl_mc_set_irqs_ioctl(struct vfio_fsl_mc_device *vdev,\n\t\t\t       u32 flags, unsigned int index,\n\t\t\t       unsigned int start, unsigned int count,\n\t\t\t       void *data)\n{\n\tif (flags & VFIO_IRQ_SET_ACTION_TRIGGER)\n\t\treturn  vfio_fsl_mc_set_irq_trigger(vdev, index, start,\n\t\t\t  count, flags, data);\n\telse\n\t\treturn -EINVAL;\n}\n\n \nvoid vfio_fsl_mc_irqs_cleanup(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint irq_count = mc_dev->obj_desc.irq_count;\n\tint i;\n\n\t \n\tif (!vdev->mc_irqs)\n\t\treturn;\n\n\tfor (i = 0; i < irq_count; i++)\n\t\tvfio_set_trigger(vdev, i, -1);\n\n\tfsl_mc_free_irqs(mc_dev);\n\tkfree(vdev->mc_irqs);\n\tvdev->mc_irqs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}