{
  "module_name": "vfio_fsl_mc.c",
  "hash_id": "b47a3086ff30aebd213d76a4ff9aae050a52df6cb94d360dbddb60f1737389b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/fsl-mc/vfio_fsl_mc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vfio.h>\n#include <linux/fsl/mc.h>\n#include <linux/delay.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n\n#include \"vfio_fsl_mc_private.h\"\n\nstatic struct fsl_mc_driver vfio_fsl_mc_driver;\n\nstatic int vfio_fsl_mc_open_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint count = mc_dev->obj_desc.region_count;\n\tint i;\n\n\tvdev->regions = kcalloc(count, sizeof(struct vfio_fsl_mc_region),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\tif (!vdev->regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct resource *res = &mc_dev->regions[i];\n\t\tint no_mmap = is_fsl_mc_bus_dprc(mc_dev);\n\n\t\tvdev->regions[i].addr = res->start;\n\t\tvdev->regions[i].size = resource_size(res);\n\t\tvdev->regions[i].type = mc_dev->regions[i].flags & IORESOURCE_BITS;\n\t\t \n\t\tif (!no_mmap && !(vdev->regions[i].addr & ~PAGE_MASK) &&\n\t\t\t\t!(vdev->regions[i].size & ~PAGE_MASK))\n\t\t\tvdev->regions[i].flags |=\n\t\t\t\t\tVFIO_REGION_INFO_FLAG_MMAP;\n\t\tvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_READ;\n\t\tif (!(mc_dev->regions[i].flags & IORESOURCE_READONLY))\n\t\t\tvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_WRITE;\n\t}\n\n\treturn 0;\n}\n\nstatic void vfio_fsl_mc_regions_cleanup(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint i;\n\n\tfor (i = 0; i < mc_dev->obj_desc.region_count; i++)\n\t\tiounmap(vdev->regions[i].ioaddr);\n\tkfree(vdev->regions);\n}\n\nstatic int vfio_fsl_mc_reset_device(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint ret = 0;\n\n\tif (is_fsl_mc_bus_dprc(vdev->mc_dev)) {\n\t\treturn dprc_reset_container(mc_dev->mc_io, 0,\n\t\t\t\t\tmc_dev->mc_handle,\n\t\t\t\t\tmc_dev->obj_desc.id,\n\t\t\t\t\tDPRC_RESET_OPTION_NON_RECURSIVE);\n\t} else {\n\t\tu16 token;\n\n\t\tret = fsl_mc_obj_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,\n\t\t\t\t      mc_dev->obj_desc.type,\n\t\t\t\t      &token);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = fsl_mc_obj_reset(mc_dev->mc_io, 0, token);\n\t\tif (ret) {\n\t\t\tfsl_mc_obj_close(mc_dev->mc_io, 0, token);\n\t\t\tgoto out;\n\t\t}\n\t\tret = fsl_mc_obj_close(mc_dev->mc_io, 0, token);\n\t}\nout:\n\treturn ret;\n}\n\nstatic void vfio_fsl_mc_close_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tstruct device *cont_dev = fsl_mc_cont_dev(&mc_dev->dev);\n\tstruct fsl_mc_device *mc_cont = to_fsl_mc_device(cont_dev);\n\tint ret;\n\n\tvfio_fsl_mc_regions_cleanup(vdev);\n\n\t \n\tret = vfio_fsl_mc_reset_device(vdev);\n\n\tif (ret)\n\t\tdev_warn(&mc_cont->dev,\n\t\t\t \"VFIO_FSL_MC: reset device has failed (%d)\\n\", ret);\n\n\tvfio_fsl_mc_irqs_cleanup(vdev);\n\n\tfsl_mc_cleanup_irq_pool(mc_cont);\n}\n\nstatic long vfio_fsl_mc_ioctl(struct vfio_device *core_vdev,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tunsigned long minsz;\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_FSL_MC;\n\n\t\tif (is_fsl_mc_bus_dprc(mc_dev))\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = mc_dev->obj_desc.region_count;\n\t\tinfo.num_irqs = mc_dev->obj_desc.irq_count;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info info;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tif (info.index >= mc_dev->obj_desc.region_count)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tinfo.offset = VFIO_FSL_MC_INDEX_TO_OFFSET(info.index);\n\t\tinfo.size = vdev->regions[info.index].size;\n\t\tinfo.flags = vdev->regions[info.index].flags;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tif (info.index >= mc_dev->obj_desc.irq_count)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\t\tinfo.count = 1;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_SET_IRQS:\n\t{\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\t\tsize_t data_size = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tret = vfio_set_irqs_validate_and_prepare(&hdr, mc_dev->obj_desc.irq_count,\n\t\t\t\t\tmc_dev->obj_desc.irq_count, &data_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (data_size) {\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t   data_size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\t\tret = vfio_fsl_mc_set_irqs_ioctl(vdev, hdr.flags,\n\t\t\t\t\t\t hdr.index, hdr.start,\n\t\t\t\t\t\t hdr.count, data);\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\t}\n\tcase VFIO_DEVICE_RESET:\n\t{\n\t\treturn vfio_fsl_mc_reset_device(vdev);\n\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic ssize_t vfio_fsl_mc_read(struct vfio_device *core_vdev, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tunsigned int index = VFIO_FSL_MC_OFFSET_TO_INDEX(*ppos);\n\tloff_t off = *ppos & VFIO_FSL_MC_OFFSET_MASK;\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tstruct vfio_fsl_mc_region *region;\n\tu64 data[8];\n\tint i;\n\n\tif (index >= mc_dev->obj_desc.region_count)\n\t\treturn -EINVAL;\n\n\tregion = &vdev->regions[index];\n\n\tif (!(region->flags & VFIO_REGION_INFO_FLAG_READ))\n\t\treturn -EINVAL;\n\n\tif (!region->ioaddr) {\n\t\tregion->ioaddr = ioremap(region->addr, region->size);\n\t\tif (!region->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (count != 64 || off != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 7; i >= 0; i--)\n\t\tdata[i] = readq(region->ioaddr + i * sizeof(uint64_t));\n\n\tif (copy_to_user(buf, data, 64))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\n#define MC_CMD_COMPLETION_TIMEOUT_MS    5000\n#define MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS    500\n\nstatic int vfio_fsl_mc_send_command(void __iomem *ioaddr, uint64_t *cmd_data)\n{\n\tint i;\n\tenum mc_cmd_status status;\n\tunsigned long timeout_usecs = MC_CMD_COMPLETION_TIMEOUT_MS * 1000;\n\n\t \n\tfor (i = 7; i >= 1; i--)\n\t\twriteq_relaxed(cmd_data[i], ioaddr + i * sizeof(uint64_t));\n\n\t \n\twriteq(cmd_data[0], ioaddr);\n\n\t \n\tfor (;;) {\n\t\tu64 header;\n\t\tstruct mc_cmd_header *resp_hdr;\n\n\t\theader = cpu_to_le64(readq_relaxed(ioaddr));\n\n\t\tresp_hdr = (struct mc_cmd_header *)&header;\n\t\tstatus = (enum mc_cmd_status)resp_hdr->status;\n\t\tif (status != MC_CMD_STATUS_READY)\n\t\t\tbreak;\n\n\t\tudelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\n\t\ttimeout_usecs -= MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS;\n\t\tif (timeout_usecs == 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t vfio_fsl_mc_write(struct vfio_device *core_vdev,\n\t\t\t\t const char __user *buf, size_t count,\n\t\t\t\t loff_t *ppos)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tunsigned int index = VFIO_FSL_MC_OFFSET_TO_INDEX(*ppos);\n\tloff_t off = *ppos & VFIO_FSL_MC_OFFSET_MASK;\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tstruct vfio_fsl_mc_region *region;\n\tu64 data[8];\n\tint ret;\n\n\tif (index >= mc_dev->obj_desc.region_count)\n\t\treturn -EINVAL;\n\n\tregion = &vdev->regions[index];\n\n\tif (!(region->flags & VFIO_REGION_INFO_FLAG_WRITE))\n\t\treturn -EINVAL;\n\n\tif (!region->ioaddr) {\n\t\tregion->ioaddr = ioremap(region->addr, region->size);\n\t\tif (!region->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (count != 64 || off != 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&data, buf, 64))\n\t\treturn -EFAULT;\n\n\tret = vfio_fsl_mc_send_command(region->ioaddr, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n\n}\n\nstatic int vfio_fsl_mc_mmap_mmio(struct vfio_fsl_mc_region region,\n\t\t\t\t struct vm_area_struct *vma)\n{\n\tu64 size = vma->vm_end - vma->vm_start;\n\tu64 pgoff, base;\n\tu8 region_cacheable;\n\n\tpgoff = vma->vm_pgoff &\n\t\t((1U << (VFIO_FSL_MC_OFFSET_SHIFT - PAGE_SHIFT)) - 1);\n\tbase = pgoff << PAGE_SHIFT;\n\n\tif (region.size < PAGE_SIZE || base + size > region.size)\n\t\treturn -EINVAL;\n\n\tregion_cacheable = (region.type & FSL_MC_REGION_CACHEABLE) &&\n\t\t\t   (region.type & FSL_MC_REGION_SHAREABLE);\n\tif (!region_cacheable)\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\tvma->vm_pgoff = (region.addr >> PAGE_SHIFT) + pgoff;\n\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       size, vma->vm_page_prot);\n}\n\nstatic int vfio_fsl_mc_mmap(struct vfio_device *core_vdev,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tunsigned int index;\n\n\tindex = vma->vm_pgoff >> (VFIO_FSL_MC_OFFSET_SHIFT - PAGE_SHIFT);\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif (vma->vm_start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (vma->vm_end & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\tif (index >= mc_dev->obj_desc.region_count)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_MMAP))\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ)\n\t\t\t&& (vma->vm_flags & VM_READ))\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE)\n\t\t\t&& (vma->vm_flags & VM_WRITE))\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = mc_dev;\n\n\treturn vfio_fsl_mc_mmap_mmio(vdev->regions[index], vma);\n}\n\nstatic const struct vfio_device_ops vfio_fsl_mc_ops;\nstatic int vfio_fsl_mc_bus_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long action, void *data)\n{\n\tstruct vfio_fsl_mc_device *vdev = container_of(nb,\n\t\t\t\t\tstruct vfio_fsl_mc_device, nb);\n\tstruct device *dev = data;\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\n\tstruct fsl_mc_device *mc_cont = to_fsl_mc_device(mc_dev->dev.parent);\n\n\tif (action == BUS_NOTIFY_ADD_DEVICE &&\n\t    vdev->mc_dev == mc_cont) {\n\t\tmc_dev->driver_override = kasprintf(GFP_KERNEL, \"%s\",\n\t\t\t\t\t\t    vfio_fsl_mc_ops.name);\n\t\tif (!mc_dev->driver_override)\n\t\t\tdev_warn(dev, \"VFIO_FSL_MC: Setting driver override for device in dprc %s failed\\n\",\n\t\t\t\t dev_name(&mc_cont->dev));\n\t\telse\n\t\t\tdev_info(dev, \"VFIO_FSL_MC: Setting driver override for device in dprc %s\\n\",\n\t\t\t\t dev_name(&mc_cont->dev));\n\t} else if (action == BUS_NOTIFY_BOUND_DRIVER &&\n\t\tvdev->mc_dev == mc_cont) {\n\t\tstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\n\n\t\tif (mc_drv && mc_drv != &vfio_fsl_mc_driver)\n\t\t\tdev_warn(dev, \"VFIO_FSL_MC: Object %s bound to driver %s while DPRC bound to vfio-fsl-mc\\n\",\n\t\t\t\t dev_name(dev), mc_drv->driver.name);\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_fsl_mc_init_device(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\tint ret;\n\n\t \n\tif (!is_fsl_mc_bus_dprc(mc_dev)) {\n\t\tstruct fsl_mc_device *mc_cont = to_fsl_mc_device(mc_dev->dev.parent);\n\n\t\tmc_dev->mc_io = mc_cont->mc_io;\n\t\treturn 0;\n\t}\n\n\tvdev->nb.notifier_call = vfio_fsl_mc_bus_notifier;\n\tret = bus_register_notifier(&fsl_mc_bus_type, &vdev->nb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = dprc_setup(mc_dev);\n\tif (ret) {\n\t\tdev_err(&mc_dev->dev, \"VFIO_FSL_MC: Failed to setup DPRC (%d)\\n\", ret);\n\t\tgoto out_nc_unreg;\n\t}\n\treturn 0;\n\nout_nc_unreg:\n\tbus_unregister_notifier(&fsl_mc_bus_type, &vdev->nb);\n\treturn ret;\n}\n\nstatic int vfio_fsl_mc_scan_container(struct fsl_mc_device *mc_dev)\n{\n\tint ret;\n\n\t \n\tif (!is_fsl_mc_bus_dprc(mc_dev))\n\t\treturn 0;\n\tret = dprc_scan_container(mc_dev, false);\n\tif (ret) {\n\t\tdev_err(&mc_dev->dev,\n\t\t\t\"VFIO_FSL_MC: Container scanning failed (%d)\\n\", ret);\n\t\tdprc_remove_devices(mc_dev, NULL, 0);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void vfio_fsl_uninit_device(struct vfio_fsl_mc_device *vdev)\n{\n\tstruct fsl_mc_device *mc_dev = vdev->mc_dev;\n\n\tif (!is_fsl_mc_bus_dprc(mc_dev))\n\t\treturn;\n\n\tdprc_cleanup(mc_dev);\n\tbus_unregister_notifier(&fsl_mc_bus_type, &vdev->nb);\n}\n\nstatic int vfio_fsl_mc_init_dev(struct vfio_device *core_vdev)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\tstruct fsl_mc_device *mc_dev = to_fsl_mc_device(core_vdev->dev);\n\tint ret;\n\n\tvdev->mc_dev = mc_dev;\n\tmutex_init(&vdev->igate);\n\n\tif (is_fsl_mc_bus_dprc(mc_dev))\n\t\tret = vfio_assign_device_set(core_vdev, &mc_dev->dev);\n\telse\n\t\tret = vfio_assign_device_set(core_vdev, mc_dev->dev.parent);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn vfio_fsl_mc_init_device(vdev);\n}\n\nstatic int vfio_fsl_mc_probe(struct fsl_mc_device *mc_dev)\n{\n\tstruct vfio_fsl_mc_device *vdev;\n\tstruct device *dev = &mc_dev->dev;\n\tint ret;\n\n\tvdev = vfio_alloc_device(vfio_fsl_mc_device, vdev, dev,\n\t\t\t\t &vfio_fsl_mc_ops);\n\tif (IS_ERR(vdev))\n\t\treturn PTR_ERR(vdev);\n\n\tret = vfio_register_group_dev(&vdev->vdev);\n\tif (ret) {\n\t\tdev_err(dev, \"VFIO_FSL_MC: Failed to add to vfio group\\n\");\n\t\tgoto out_put_vdev;\n\t}\n\n\tret = vfio_fsl_mc_scan_container(mc_dev);\n\tif (ret)\n\t\tgoto out_group_dev;\n\tdev_set_drvdata(dev, vdev);\n\treturn 0;\n\nout_group_dev:\n\tvfio_unregister_group_dev(&vdev->vdev);\nout_put_vdev:\n\tvfio_put_device(&vdev->vdev);\n\treturn ret;\n}\n\nstatic void vfio_fsl_mc_release_dev(struct vfio_device *core_vdev)\n{\n\tstruct vfio_fsl_mc_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_fsl_mc_device, vdev);\n\n\tvfio_fsl_uninit_device(vdev);\n\tmutex_destroy(&vdev->igate);\n}\n\nstatic void vfio_fsl_mc_remove(struct fsl_mc_device *mc_dev)\n{\n\tstruct device *dev = &mc_dev->dev;\n\tstruct vfio_fsl_mc_device *vdev = dev_get_drvdata(dev);\n\n\tvfio_unregister_group_dev(&vdev->vdev);\n\tdprc_remove_devices(mc_dev, NULL, 0);\n\tvfio_put_device(&vdev->vdev);\n}\n\nstatic const struct vfio_device_ops vfio_fsl_mc_ops = {\n\t.name\t\t= \"vfio-fsl-mc\",\n\t.init\t\t= vfio_fsl_mc_init_dev,\n\t.release\t= vfio_fsl_mc_release_dev,\n\t.open_device\t= vfio_fsl_mc_open_device,\n\t.close_device\t= vfio_fsl_mc_close_device,\n\t.ioctl\t\t= vfio_fsl_mc_ioctl,\n\t.read\t\t= vfio_fsl_mc_read,\n\t.write\t\t= vfio_fsl_mc_write,\n\t.mmap\t\t= vfio_fsl_mc_mmap,\n\t.bind_iommufd\t= vfio_iommufd_physical_bind,\n\t.unbind_iommufd\t= vfio_iommufd_physical_unbind,\n\t.attach_ioas\t= vfio_iommufd_physical_attach_ioas,\n\t.detach_ioas\t= vfio_iommufd_physical_detach_ioas,\n};\n\nstatic struct fsl_mc_driver vfio_fsl_mc_driver = {\n\t.probe\t\t= vfio_fsl_mc_probe,\n\t.remove\t\t= vfio_fsl_mc_remove,\n\t.driver\t= {\n\t\t.name\t= \"vfio-fsl-mc\",\n\t},\n\t.driver_managed_dma = true,\n};\n\nmodule_fsl_mc_driver(vfio_fsl_mc_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"VFIO for FSL-MC devices - User Level meta-driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}