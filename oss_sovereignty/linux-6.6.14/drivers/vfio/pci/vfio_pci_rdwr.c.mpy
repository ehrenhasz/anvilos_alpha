{
  "module_name": "vfio_pci_rdwr.c",
  "hash_id": "2055cd3b3837bc9192e73dab517766fa7f351a0f7a6d2053969d239a971de360",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci_rdwr.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/vfio.h>\n#include <linux/vgaarb.h>\n\n#include \"vfio_pci_priv.h\"\n\n#ifdef __LITTLE_ENDIAN\n#define vfio_ioread64\tioread64\n#define vfio_iowrite64\tiowrite64\n#define vfio_ioread32\tioread32\n#define vfio_iowrite32\tiowrite32\n#define vfio_ioread16\tioread16\n#define vfio_iowrite16\tiowrite16\n#else\n#define vfio_ioread64\tioread64be\n#define vfio_iowrite64\tiowrite64be\n#define vfio_ioread32\tioread32be\n#define vfio_iowrite32\tiowrite32be\n#define vfio_ioread16\tioread16be\n#define vfio_iowrite16\tiowrite16be\n#endif\n#define vfio_ioread8\tioread8\n#define vfio_iowrite8\tiowrite8\n\n#define VFIO_IOWRITE(size) \\\nstatic int vfio_pci_iowrite##size(struct vfio_pci_core_device *vdev,\t\t\\\n\t\t\tbool test_mem, u##size val, void __iomem *io)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (test_mem) {\t\t\t\t\t\t\t\\\n\t\tdown_read(&vdev->memory_lock);\t\t\t\t\\\n\t\tif (!__vfio_pci_memory_enabled(vdev)) {\t\t\t\\\n\t\t\tup_read(&vdev->memory_lock);\t\t\t\\\n\t\t\treturn -EIO;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tvfio_iowrite##size(val, io);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_mem)\t\t\t\t\t\t\t\\\n\t\tup_read(&vdev->memory_lock);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nVFIO_IOWRITE(8)\nVFIO_IOWRITE(16)\nVFIO_IOWRITE(32)\n#ifdef iowrite64\nVFIO_IOWRITE(64)\n#endif\n\n#define VFIO_IOREAD(size) \\\nstatic int vfio_pci_ioread##size(struct vfio_pci_core_device *vdev,\t\t\\\n\t\t\tbool test_mem, u##size *val, void __iomem *io)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (test_mem) {\t\t\t\t\t\t\t\\\n\t\tdown_read(&vdev->memory_lock);\t\t\t\t\\\n\t\tif (!__vfio_pci_memory_enabled(vdev)) {\t\t\t\\\n\t\t\tup_read(&vdev->memory_lock);\t\t\t\\\n\t\t\treturn -EIO;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t*val = vfio_ioread##size(io);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_mem)\t\t\t\t\t\t\t\\\n\t\tup_read(&vdev->memory_lock);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nVFIO_IOREAD(8)\nVFIO_IOREAD(16)\nVFIO_IOREAD(32)\n\n \nstatic ssize_t do_io_rw(struct vfio_pci_core_device *vdev, bool test_mem,\n\t\t\tvoid __iomem *io, char __user *buf,\n\t\t\tloff_t off, size_t count, size_t x_start,\n\t\t\tsize_t x_end, bool iswrite)\n{\n\tssize_t done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t fillable, filled;\n\n\t\tif (off < x_start)\n\t\t\tfillable = min(count, (size_t)(x_start - off));\n\t\telse if (off >= x_end)\n\t\t\tfillable = count;\n\t\telse\n\t\t\tfillable = 0;\n\n\t\tif (fillable >= 4 && !(off % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (iswrite) {\n\t\t\t\tif (copy_from_user(&val, buf, 4))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tret = vfio_pci_iowrite32(vdev, test_mem,\n\t\t\t\t\t\t\t val, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tret = vfio_pci_ioread32(vdev, test_mem,\n\t\t\t\t\t\t\t&val, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (copy_to_user(buf, &val, 4))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tfilled = 4;\n\t\t} else if (fillable >= 2 && !(off % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (iswrite) {\n\t\t\t\tif (copy_from_user(&val, buf, 2))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tret = vfio_pci_iowrite16(vdev, test_mem,\n\t\t\t\t\t\t\t val, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tret = vfio_pci_ioread16(vdev, test_mem,\n\t\t\t\t\t\t\t&val, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (copy_to_user(buf, &val, 2))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tfilled = 2;\n\t\t} else if (fillable) {\n\t\t\tu8 val;\n\n\t\t\tif (iswrite) {\n\t\t\t\tif (copy_from_user(&val, buf, 1))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tret = vfio_pci_iowrite8(vdev, test_mem,\n\t\t\t\t\t\t\tval, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tret = vfio_pci_ioread8(vdev, test_mem,\n\t\t\t\t\t\t       &val, io + off);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (copy_to_user(buf, &val, 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tfilled = 1;\n\t\t} else {\n\t\t\t \n\t\t\tfilled = min(count, (size_t)(x_end - off));\n\t\t\tif (!iswrite) {\n\t\t\t\tu8 val = 0xFF;\n\t\t\t\tsize_t i;\n\n\t\t\t\tfor (i = 0; i < filled; i++)\n\t\t\t\t\tif (copy_to_user(buf + i, &val, 1))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\toff += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\n}\n\nstatic int vfio_pci_setup_barmap(struct vfio_pci_core_device *vdev, int bar)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tint ret;\n\tvoid __iomem *io;\n\n\tif (vdev->barmap[bar])\n\t\treturn 0;\n\n\tret = pci_request_selected_regions(pdev, 1 << bar, \"vfio\");\n\tif (ret)\n\t\treturn ret;\n\n\tio = pci_iomap(pdev, bar, 0);\n\tif (!io) {\n\t\tpci_release_selected_regions(pdev, 1 << bar);\n\t\treturn -ENOMEM;\n\t}\n\n\tvdev->barmap[bar] = io;\n\n\treturn 0;\n}\n\nssize_t vfio_pci_bar_rw(struct vfio_pci_core_device *vdev, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, bool iswrite)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tloff_t pos = *ppos & VFIO_PCI_OFFSET_MASK;\n\tint bar = VFIO_PCI_OFFSET_TO_INDEX(*ppos);\n\tsize_t x_start = 0, x_end = 0;\n\tresource_size_t end;\n\tvoid __iomem *io;\n\tstruct resource *res = &vdev->pdev->resource[bar];\n\tssize_t done;\n\n\tif (pci_resource_start(pdev, bar))\n\t\tend = pci_resource_len(pdev, bar);\n\telse if (bar == PCI_ROM_RESOURCE &&\n\t\t pdev->resource[bar].flags & IORESOURCE_ROM_SHADOW)\n\t\tend = 0x20000;\n\telse\n\t\treturn -EINVAL;\n\n\tif (pos >= end)\n\t\treturn -EINVAL;\n\n\tcount = min(count, (size_t)(end - pos));\n\n\tif (bar == PCI_ROM_RESOURCE) {\n\t\t \n\t\tio = pci_map_rom(pdev, &x_start);\n\t\tif (!io) {\n\t\t\tdone = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tx_end = end;\n\t} else {\n\t\tint ret = vfio_pci_setup_barmap(vdev, bar);\n\t\tif (ret) {\n\t\t\tdone = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tio = vdev->barmap[bar];\n\t}\n\n\tif (bar == vdev->msix_bar) {\n\t\tx_start = vdev->msix_offset;\n\t\tx_end = vdev->msix_offset + vdev->msix_size;\n\t}\n\n\tdone = do_io_rw(vdev, res->flags & IORESOURCE_MEM, io, buf, pos,\n\t\t\tcount, x_start, x_end, iswrite);\n\n\tif (done >= 0)\n\t\t*ppos += done;\n\n\tif (bar == PCI_ROM_RESOURCE)\n\t\tpci_unmap_rom(pdev, io);\nout:\n\treturn done;\n}\n\n#ifdef CONFIG_VFIO_PCI_VGA\nssize_t vfio_pci_vga_rw(struct vfio_pci_core_device *vdev, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos, bool iswrite)\n{\n\tint ret;\n\tloff_t off, pos = *ppos & VFIO_PCI_OFFSET_MASK;\n\tvoid __iomem *iomem = NULL;\n\tunsigned int rsrc;\n\tbool is_ioport;\n\tssize_t done;\n\n\tif (!vdev->has_vga)\n\t\treturn -EINVAL;\n\n\tif (pos > 0xbfffful)\n\t\treturn -EINVAL;\n\n\tswitch ((u32)pos) {\n\tcase 0xa0000 ... 0xbffff:\n\t\tcount = min(count, (size_t)(0xc0000 - pos));\n\t\tiomem = ioremap(0xa0000, 0xbffff - 0xa0000 + 1);\n\t\toff = pos - 0xa0000;\n\t\trsrc = VGA_RSRC_LEGACY_MEM;\n\t\tis_ioport = false;\n\t\tbreak;\n\tcase 0x3b0 ... 0x3bb:\n\t\tcount = min(count, (size_t)(0x3bc - pos));\n\t\tiomem = ioport_map(0x3b0, 0x3bb - 0x3b0 + 1);\n\t\toff = pos - 0x3b0;\n\t\trsrc = VGA_RSRC_LEGACY_IO;\n\t\tis_ioport = true;\n\t\tbreak;\n\tcase 0x3c0 ... 0x3df:\n\t\tcount = min(count, (size_t)(0x3e0 - pos));\n\t\tiomem = ioport_map(0x3c0, 0x3df - 0x3c0 + 1);\n\t\toff = pos - 0x3c0;\n\t\trsrc = VGA_RSRC_LEGACY_IO;\n\t\tis_ioport = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!iomem)\n\t\treturn -ENOMEM;\n\n\tret = vga_get_interruptible(vdev->pdev, rsrc);\n\tif (ret) {\n\t\tis_ioport ? ioport_unmap(iomem) : iounmap(iomem);\n\t\treturn ret;\n\t}\n\n\t \n\tdone = do_io_rw(vdev, false, iomem, buf, off, count, 0, 0, iswrite);\n\n\tvga_put(vdev->pdev, rsrc);\n\n\tis_ioport ? ioport_unmap(iomem) : iounmap(iomem);\n\n\tif (done >= 0)\n\t\t*ppos += done;\n\n\treturn done;\n}\n#endif\n\nstatic void vfio_pci_ioeventfd_do_write(struct vfio_pci_ioeventfd *ioeventfd,\n\t\t\t\t\tbool test_mem)\n{\n\tswitch (ioeventfd->count) {\n\tcase 1:\n\t\tvfio_pci_iowrite8(ioeventfd->vdev, test_mem,\n\t\t\t\t  ioeventfd->data, ioeventfd->addr);\n\t\tbreak;\n\tcase 2:\n\t\tvfio_pci_iowrite16(ioeventfd->vdev, test_mem,\n\t\t\t\t   ioeventfd->data, ioeventfd->addr);\n\t\tbreak;\n\tcase 4:\n\t\tvfio_pci_iowrite32(ioeventfd->vdev, test_mem,\n\t\t\t\t   ioeventfd->data, ioeventfd->addr);\n\t\tbreak;\n#ifdef iowrite64\n\tcase 8:\n\t\tvfio_pci_iowrite64(ioeventfd->vdev, test_mem,\n\t\t\t\t   ioeventfd->data, ioeventfd->addr);\n\t\tbreak;\n#endif\n\t}\n}\n\nstatic int vfio_pci_ioeventfd_handler(void *opaque, void *unused)\n{\n\tstruct vfio_pci_ioeventfd *ioeventfd = opaque;\n\tstruct vfio_pci_core_device *vdev = ioeventfd->vdev;\n\n\tif (ioeventfd->test_mem) {\n\t\tif (!down_read_trylock(&vdev->memory_lock))\n\t\t\treturn 1;  \n\t\tif (!__vfio_pci_memory_enabled(vdev)) {\n\t\t\tup_read(&vdev->memory_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvfio_pci_ioeventfd_do_write(ioeventfd, false);\n\n\tif (ioeventfd->test_mem)\n\t\tup_read(&vdev->memory_lock);\n\n\treturn 0;\n}\n\nstatic void vfio_pci_ioeventfd_thread(void *opaque, void *unused)\n{\n\tstruct vfio_pci_ioeventfd *ioeventfd = opaque;\n\n\tvfio_pci_ioeventfd_do_write(ioeventfd, ioeventfd->test_mem);\n}\n\nint vfio_pci_ioeventfd(struct vfio_pci_core_device *vdev, loff_t offset,\n\t\t       uint64_t data, int count, int fd)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tloff_t pos = offset & VFIO_PCI_OFFSET_MASK;\n\tint ret, bar = VFIO_PCI_OFFSET_TO_INDEX(offset);\n\tstruct vfio_pci_ioeventfd *ioeventfd;\n\n\t \n\tif (bar > VFIO_PCI_BAR5_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tif (pos + count > pci_resource_len(pdev, bar))\n\t\treturn -EINVAL;\n\n\t \n\tif (bar == vdev->msix_bar &&\n\t    !(pos + count <= vdev->msix_offset ||\n\t      pos >= vdev->msix_offset + vdev->msix_size))\n\t\treturn -EINVAL;\n\n#ifndef iowrite64\n\tif (count == 8)\n\t\treturn -EINVAL;\n#endif\n\n\tret = vfio_pci_setup_barmap(vdev, bar);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&vdev->ioeventfds_lock);\n\n\tlist_for_each_entry(ioeventfd, &vdev->ioeventfds_list, next) {\n\t\tif (ioeventfd->pos == pos && ioeventfd->bar == bar &&\n\t\t    ioeventfd->data == data && ioeventfd->count == count) {\n\t\t\tif (fd == -1) {\n\t\t\t\tvfio_virqfd_disable(&ioeventfd->virqfd);\n\t\t\t\tlist_del(&ioeventfd->next);\n\t\t\t\tvdev->ioeventfds_nr--;\n\t\t\t\tkfree(ioeventfd);\n\t\t\t\tret = 0;\n\t\t\t} else\n\t\t\t\tret = -EEXIST;\n\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (fd < 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (vdev->ioeventfds_nr >= VFIO_PCI_IOEVENTFD_MAX) {\n\t\tret = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\n\tioeventfd = kzalloc(sizeof(*ioeventfd), GFP_KERNEL_ACCOUNT);\n\tif (!ioeventfd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tioeventfd->vdev = vdev;\n\tioeventfd->addr = vdev->barmap[bar] + pos;\n\tioeventfd->data = data;\n\tioeventfd->pos = pos;\n\tioeventfd->bar = bar;\n\tioeventfd->count = count;\n\tioeventfd->test_mem = vdev->pdev->resource[bar].flags & IORESOURCE_MEM;\n\n\tret = vfio_virqfd_enable(ioeventfd, vfio_pci_ioeventfd_handler,\n\t\t\t\t vfio_pci_ioeventfd_thread, NULL,\n\t\t\t\t &ioeventfd->virqfd, fd);\n\tif (ret) {\n\t\tkfree(ioeventfd);\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add(&ioeventfd->next, &vdev->ioeventfds_list);\n\tvdev->ioeventfds_nr++;\n\nout_unlock:\n\tmutex_unlock(&vdev->ioeventfds_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}