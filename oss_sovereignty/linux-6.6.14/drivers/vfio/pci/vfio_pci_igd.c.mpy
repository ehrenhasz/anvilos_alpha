{
  "module_name": "vfio_pci_igd.c",
  "hash_id": "267558d4054152b5ac37ece2ce8f30a281b81994d9f7262575e3b03f03e0f058",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci_igd.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/vfio.h>\n\n#include \"vfio_pci_priv.h\"\n\n#define OPREGION_SIGNATURE\t\"IntelGraphicsMem\"\n#define OPREGION_SIZE\t\t(8 * 1024)\n#define OPREGION_PCI_ADDR\t0xfc\n\n#define OPREGION_RVDA\t\t0x3ba\n#define OPREGION_RVDS\t\t0x3c2\n#define OPREGION_VERSION\t0x16\n\nstruct igd_opregion_vbt {\n\tvoid *opregion;\n\tvoid *vbt_ex;\n};\n\n \nstatic inline unsigned long igd_opregion_shift_copy(char __user *dst,\n\t\t\t\t\t\t    loff_t *off,\n\t\t\t\t\t\t    void *src,\n\t\t\t\t\t\t    loff_t *pos,\n\t\t\t\t\t\t    size_t *remaining,\n\t\t\t\t\t\t    size_t bytes)\n{\n\tif (copy_to_user(dst + (*off), src, bytes))\n\t\treturn -EFAULT;\n\n\t*off += bytes;\n\t*pos += bytes;\n\t*remaining -= bytes;\n\n\treturn 0;\n}\n\nstatic ssize_t vfio_pci_igd_rw(struct vfio_pci_core_device *vdev,\n\t\t\t       char __user *buf, size_t count, loff_t *ppos,\n\t\t\t       bool iswrite)\n{\n\tunsigned int i = VFIO_PCI_OFFSET_TO_INDEX(*ppos) - VFIO_PCI_NUM_REGIONS;\n\tstruct igd_opregion_vbt *opregionvbt = vdev->region[i].data;\n\tloff_t pos = *ppos & VFIO_PCI_OFFSET_MASK, off = 0;\n\tsize_t remaining;\n\n\tif (pos >= vdev->region[i].size || iswrite)\n\t\treturn -EINVAL;\n\n\tcount = min_t(size_t, count, vdev->region[i].size - pos);\n\tremaining = count;\n\n\t \n\tif (remaining && pos < OPREGION_VERSION) {\n\t\tsize_t bytes = min_t(size_t, remaining, OPREGION_VERSION - pos);\n\n\t\tif (igd_opregion_shift_copy(buf, &off,\n\t\t\t\t\t    opregionvbt->opregion + pos, &pos,\n\t\t\t\t\t    &remaining, bytes))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (remaining && pos < OPREGION_VERSION + sizeof(__le16)) {\n\t\tsize_t bytes = min_t(size_t, remaining,\n\t\t\t\t     OPREGION_VERSION + sizeof(__le16) - pos);\n\t\t__le16 version = *(__le16 *)(opregionvbt->opregion +\n\t\t\t\t\t     OPREGION_VERSION);\n\n\t\t \n\t\tif (le16_to_cpu(version) == 0x0200 && opregionvbt->vbt_ex)\n\t\t\tversion = cpu_to_le16(0x0201);\n\n\t\tif (igd_opregion_shift_copy(buf, &off,\n\t\t\t\t\t    (u8 *)&version +\n\t\t\t\t\t    (pos - OPREGION_VERSION),\n\t\t\t\t\t    &pos, &remaining, bytes))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (remaining && pos < OPREGION_RVDA) {\n\t\tsize_t bytes = min_t(size_t, remaining, OPREGION_RVDA - pos);\n\n\t\tif (igd_opregion_shift_copy(buf, &off,\n\t\t\t\t\t    opregionvbt->opregion + pos, &pos,\n\t\t\t\t\t    &remaining, bytes))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (remaining && pos < OPREGION_RVDA + sizeof(__le64)) {\n\t\tsize_t bytes = min_t(size_t, remaining,\n\t\t\t\t     OPREGION_RVDA + sizeof(__le64) - pos);\n\t\t__le64 rvda = cpu_to_le64(opregionvbt->vbt_ex ?\n\t\t\t\t\t  OPREGION_SIZE : 0);\n\n\t\tif (igd_opregion_shift_copy(buf, &off,\n\t\t\t\t\t    (u8 *)&rvda + (pos - OPREGION_RVDA),\n\t\t\t\t\t    &pos, &remaining, bytes))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (remaining && pos < OPREGION_SIZE) {\n\t\tsize_t bytes = min_t(size_t, remaining, OPREGION_SIZE - pos);\n\n\t\tif (igd_opregion_shift_copy(buf, &off,\n\t\t\t\t\t    opregionvbt->opregion + pos, &pos,\n\t\t\t\t\t    &remaining, bytes))\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (remaining &&\n\t    copy_to_user(buf + off, opregionvbt->vbt_ex + (pos - OPREGION_SIZE),\n\t\t\t remaining))\n\t\treturn -EFAULT;\n\n\t*ppos += count;\n\n\treturn count;\n}\n\nstatic void vfio_pci_igd_release(struct vfio_pci_core_device *vdev,\n\t\t\t\t struct vfio_pci_region *region)\n{\n\tstruct igd_opregion_vbt *opregionvbt = region->data;\n\n\tif (opregionvbt->vbt_ex)\n\t\tmemunmap(opregionvbt->vbt_ex);\n\n\tmemunmap(opregionvbt->opregion);\n\tkfree(opregionvbt);\n}\n\nstatic const struct vfio_pci_regops vfio_pci_igd_regops = {\n\t.rw\t\t= vfio_pci_igd_rw,\n\t.release\t= vfio_pci_igd_release,\n};\n\nstatic int vfio_pci_igd_opregion_init(struct vfio_pci_core_device *vdev)\n{\n\t__le32 *dwordp = (__le32 *)(vdev->vconfig + OPREGION_PCI_ADDR);\n\tu32 addr, size;\n\tstruct igd_opregion_vbt *opregionvbt;\n\tint ret;\n\tu16 version;\n\n\tret = pci_read_config_dword(vdev->pdev, OPREGION_PCI_ADDR, &addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!addr || !(~addr))\n\t\treturn -ENODEV;\n\n\topregionvbt = kzalloc(sizeof(*opregionvbt), GFP_KERNEL_ACCOUNT);\n\tif (!opregionvbt)\n\t\treturn -ENOMEM;\n\n\topregionvbt->opregion = memremap(addr, OPREGION_SIZE, MEMREMAP_WB);\n\tif (!opregionvbt->opregion) {\n\t\tkfree(opregionvbt);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (memcmp(opregionvbt->opregion, OPREGION_SIGNATURE, 16)) {\n\t\tmemunmap(opregionvbt->opregion);\n\t\tkfree(opregionvbt);\n\t\treturn -EINVAL;\n\t}\n\n\tsize = le32_to_cpu(*(__le32 *)(opregionvbt->opregion + 16));\n\tif (!size) {\n\t\tmemunmap(opregionvbt->opregion);\n\t\tkfree(opregionvbt);\n\t\treturn -EINVAL;\n\t}\n\n\tsize *= 1024;  \n\n\t \n\tversion = le16_to_cpu(*(__le16 *)(opregionvbt->opregion +\n\t\t\t\t\t  OPREGION_VERSION));\n\tif (version >= 0x0200) {\n\t\tu64 rvda = le64_to_cpu(*(__le64 *)(opregionvbt->opregion +\n\t\t\t\t\t\t   OPREGION_RVDA));\n\t\tu32 rvds = le32_to_cpu(*(__le32 *)(opregionvbt->opregion +\n\t\t\t\t\t\t   OPREGION_RVDS));\n\n\t\t \n\t\tif (rvda && rvds) {\n\t\t\tsize += rvds;\n\n\t\t\t \n\t\t\tif (version == 0x0200)\n\t\t\t\taddr = rvda;\n\t\t\telse\n\t\t\t\taddr += rvda;\n\n\t\t\topregionvbt->vbt_ex = memremap(addr, rvds, MEMREMAP_WB);\n\t\t\tif (!opregionvbt->vbt_ex) {\n\t\t\t\tmemunmap(opregionvbt->opregion);\n\t\t\t\tkfree(opregionvbt);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = vfio_pci_core_register_dev_region(vdev,\n\t\tPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\n\t\tVFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION, &vfio_pci_igd_regops,\n\t\tsize, VFIO_REGION_INFO_FLAG_READ, opregionvbt);\n\tif (ret) {\n\t\tif (opregionvbt->vbt_ex)\n\t\t\tmemunmap(opregionvbt->vbt_ex);\n\n\t\tmemunmap(opregionvbt->opregion);\n\t\tkfree(opregionvbt);\n\t\treturn ret;\n\t}\n\n\t \n\t*dwordp = cpu_to_le32(addr);\n\tmemset(vdev->pci_config_map + OPREGION_PCI_ADDR,\n\t       PCI_CAP_ID_INVALID_VIRT, 4);\n\n\treturn ret;\n}\n\nstatic ssize_t vfio_pci_igd_cfg_rw(struct vfio_pci_core_device *vdev,\n\t\t\t\t   char __user *buf, size_t count, loff_t *ppos,\n\t\t\t\t   bool iswrite)\n{\n\tunsigned int i = VFIO_PCI_OFFSET_TO_INDEX(*ppos) - VFIO_PCI_NUM_REGIONS;\n\tstruct pci_dev *pdev = vdev->region[i].data;\n\tloff_t pos = *ppos & VFIO_PCI_OFFSET_MASK;\n\tsize_t size;\n\tint ret;\n\n\tif (pos >= vdev->region[i].size || iswrite)\n\t\treturn -EINVAL;\n\n\tsize = count = min(count, (size_t)(vdev->region[i].size - pos));\n\n\tif ((pos & 1) && size) {\n\t\tu8 val;\n\n\t\tret = pci_user_read_config_byte(pdev, pos, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(buf + count - size, &val, 1))\n\t\t\treturn -EFAULT;\n\n\t\tpos++;\n\t\tsize--;\n\t}\n\n\tif ((pos & 3) && size > 2) {\n\t\tu16 val;\n\t\t__le16 lval;\n\n\t\tret = pci_user_read_config_word(pdev, pos, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlval = cpu_to_le16(val);\n\t\tif (copy_to_user(buf + count - size, &lval, 2))\n\t\t\treturn -EFAULT;\n\n\t\tpos += 2;\n\t\tsize -= 2;\n\t}\n\n\twhile (size > 3) {\n\t\tu32 val;\n\t\t__le32 lval;\n\n\t\tret = pci_user_read_config_dword(pdev, pos, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlval = cpu_to_le32(val);\n\t\tif (copy_to_user(buf + count - size, &lval, 4))\n\t\t\treturn -EFAULT;\n\n\t\tpos += 4;\n\t\tsize -= 4;\n\t}\n\n\twhile (size >= 2) {\n\t\tu16 val;\n\t\t__le16 lval;\n\n\t\tret = pci_user_read_config_word(pdev, pos, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlval = cpu_to_le16(val);\n\t\tif (copy_to_user(buf + count - size, &lval, 2))\n\t\t\treturn -EFAULT;\n\n\t\tpos += 2;\n\t\tsize -= 2;\n\t}\n\n\twhile (size) {\n\t\tu8 val;\n\n\t\tret = pci_user_read_config_byte(pdev, pos, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(buf + count - size, &val, 1))\n\t\t\treturn -EFAULT;\n\n\t\tpos++;\n\t\tsize--;\n\t}\n\n\t*ppos += count;\n\n\treturn count;\n}\n\nstatic void vfio_pci_igd_cfg_release(struct vfio_pci_core_device *vdev,\n\t\t\t\t     struct vfio_pci_region *region)\n{\n\tstruct pci_dev *pdev = region->data;\n\n\tpci_dev_put(pdev);\n}\n\nstatic const struct vfio_pci_regops vfio_pci_igd_cfg_regops = {\n\t.rw\t\t= vfio_pci_igd_cfg_rw,\n\t.release\t= vfio_pci_igd_cfg_release,\n};\n\nstatic int vfio_pci_igd_cfg_init(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *host_bridge, *lpc_bridge;\n\tint ret;\n\n\thost_bridge = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (!host_bridge)\n\t\treturn -ENODEV;\n\n\tif (host_bridge->vendor != PCI_VENDOR_ID_INTEL ||\n\t    host_bridge->class != (PCI_CLASS_BRIDGE_HOST << 8)) {\n\t\tpci_dev_put(host_bridge);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vfio_pci_core_register_dev_region(vdev,\n\t\tPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\n\t\tVFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG,\n\t\t&vfio_pci_igd_cfg_regops, host_bridge->cfg_size,\n\t\tVFIO_REGION_INFO_FLAG_READ, host_bridge);\n\tif (ret) {\n\t\tpci_dev_put(host_bridge);\n\t\treturn ret;\n\t}\n\n\tlpc_bridge = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0x1f, 0));\n\tif (!lpc_bridge)\n\t\treturn -ENODEV;\n\n\tif (lpc_bridge->vendor != PCI_VENDOR_ID_INTEL ||\n\t    lpc_bridge->class != (PCI_CLASS_BRIDGE_ISA << 8)) {\n\t\tpci_dev_put(lpc_bridge);\n\t\treturn -EINVAL;\n\t}\n\n\tret = vfio_pci_core_register_dev_region(vdev,\n\t\tPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\n\t\tVFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG,\n\t\t&vfio_pci_igd_cfg_regops, lpc_bridge->cfg_size,\n\t\tVFIO_REGION_INFO_FLAG_READ, lpc_bridge);\n\tif (ret) {\n\t\tpci_dev_put(lpc_bridge);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint vfio_pci_igd_init(struct vfio_pci_core_device *vdev)\n{\n\tint ret;\n\n\tret = vfio_pci_igd_opregion_init(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vfio_pci_igd_cfg_init(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}