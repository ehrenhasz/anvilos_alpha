{
  "module_name": "pci_drv.c",
  "hash_id": "85d74be3496f9dd4fa5e627d4e50754a4b03bfbbb920aba6c910c58285df154b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/pds/pci_drv.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/vfio.h>\n\n#include <linux/pds/pds_common.h>\n#include <linux/pds/pds_core_if.h>\n#include <linux/pds/pds_adminq.h>\n\n#include \"vfio_dev.h\"\n#include \"pci_drv.h\"\n#include \"cmds.h\"\n\n#define PDS_VFIO_DRV_DESCRIPTION\t\"AMD/Pensando VFIO Device Driver\"\n#define PCI_VENDOR_ID_PENSANDO\t\t0x1dd8\n\nstatic void pds_vfio_recovery(struct pds_vfio_pci_device *pds_vfio)\n{\n\tbool deferred_reset_needed = false;\n\n\t \n\tmutex_lock(&pds_vfio->state_mutex);\n\tif ((pds_vfio->state != VFIO_DEVICE_STATE_RUNNING &&\n\t     pds_vfio->state != VFIO_DEVICE_STATE_ERROR) ||\n\t    (pds_vfio->state == VFIO_DEVICE_STATE_RUNNING &&\n\t     pds_vfio_dirty_is_enabled(pds_vfio)))\n\t\tdeferred_reset_needed = true;\n\tmutex_unlock(&pds_vfio->state_mutex);\n\n\t \n\tif (deferred_reset_needed) {\n\t\tmutex_lock(&pds_vfio->reset_mutex);\n\t\tpds_vfio->deferred_reset = true;\n\t\tpds_vfio->deferred_reset_state = VFIO_DEVICE_STATE_ERROR;\n\t\tmutex_unlock(&pds_vfio->reset_mutex);\n\t}\n}\n\nstatic int pds_vfio_pci_notify_handler(struct notifier_block *nb,\n\t\t\t\t       unsigned long ecode, void *data)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(nb, struct pds_vfio_pci_device, nb);\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_notifyq_comp *event = data;\n\n\tdev_dbg(dev, \"%s: event code %lu\\n\", __func__, ecode);\n\n\t \n\tif (ecode == PDS_EVENT_RESET) {\n\t\tdev_info(dev, \"%s: PDS_EVENT_RESET event received, state==%d\\n\",\n\t\t\t __func__, event->reset.state);\n\t\t \n\t\tif (event->reset.state == 1)\n\t\t\tpds_vfio_recovery(pds_vfio);\n\t}\n\n\treturn 0;\n}\n\nstatic int\npds_vfio_pci_register_event_handler(struct pds_vfio_pci_device *pds_vfio)\n{\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tstruct notifier_block *nb = &pds_vfio->nb;\n\tint err;\n\n\tif (!nb->notifier_call) {\n\t\tnb->notifier_call = pds_vfio_pci_notify_handler;\n\t\terr = pdsc_register_notify(nb);\n\t\tif (err) {\n\t\t\tnb->notifier_call = NULL;\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to register pds event handler: %pe\\n\",\n\t\t\t\tERR_PTR(err));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_dbg(dev, \"pds event handler registered\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void\npds_vfio_pci_unregister_event_handler(struct pds_vfio_pci_device *pds_vfio)\n{\n\tif (pds_vfio->nb.notifier_call) {\n\t\tpdsc_unregister_notify(&pds_vfio->nb);\n\t\tpds_vfio->nb.notifier_call = NULL;\n\t}\n}\n\nstatic int pds_vfio_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct pds_vfio_pci_device *pds_vfio;\n\tint err;\n\n\tpds_vfio = vfio_alloc_device(pds_vfio_pci_device, vfio_coredev.vdev,\n\t\t\t\t     &pdev->dev, pds_vfio_ops_info());\n\tif (IS_ERR(pds_vfio))\n\t\treturn PTR_ERR(pds_vfio);\n\n\tdev_set_drvdata(&pdev->dev, &pds_vfio->vfio_coredev);\n\n\terr = vfio_pci_core_register_device(&pds_vfio->vfio_coredev);\n\tif (err)\n\t\tgoto out_put_vdev;\n\n\terr = pds_vfio_register_client_cmd(pds_vfio);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register as client: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\tgoto out_unregister_coredev;\n\t}\n\n\terr = pds_vfio_pci_register_event_handler(pds_vfio);\n\tif (err)\n\t\tgoto out_unregister_client;\n\n\treturn 0;\n\nout_unregister_client:\n\tpds_vfio_unregister_client_cmd(pds_vfio);\nout_unregister_coredev:\n\tvfio_pci_core_unregister_device(&pds_vfio->vfio_coredev);\nout_put_vdev:\n\tvfio_put_device(&pds_vfio->vfio_coredev.vdev);\n\treturn err;\n}\n\nstatic void pds_vfio_pci_remove(struct pci_dev *pdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio = pds_vfio_pci_drvdata(pdev);\n\n\tpds_vfio_pci_unregister_event_handler(pds_vfio);\n\tpds_vfio_unregister_client_cmd(pds_vfio);\n\tvfio_pci_core_unregister_device(&pds_vfio->vfio_coredev);\n\tvfio_put_device(&pds_vfio->vfio_coredev.vdev);\n}\n\nstatic const struct pci_device_id pds_vfio_pci_table[] = {\n\t{ PCI_DRIVER_OVERRIDE_DEVICE_VFIO(PCI_VENDOR_ID_PENSANDO, 0x1003) },  \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, pds_vfio_pci_table);\n\nstatic void pds_vfio_pci_aer_reset_done(struct pci_dev *pdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio = pds_vfio_pci_drvdata(pdev);\n\n\tpds_vfio_reset(pds_vfio);\n}\n\nstatic const struct pci_error_handlers pds_vfio_pci_err_handlers = {\n\t.reset_done = pds_vfio_pci_aer_reset_done,\n\t.error_detected = vfio_pci_core_aer_err_detected,\n};\n\nstatic struct pci_driver pds_vfio_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = pds_vfio_pci_table,\n\t.probe = pds_vfio_pci_probe,\n\t.remove = pds_vfio_pci_remove,\n\t.err_handler = &pds_vfio_pci_err_handlers,\n\t.driver_managed_dma = true,\n};\n\nmodule_pci_driver(pds_vfio_pci_driver);\n\nMODULE_DESCRIPTION(PDS_VFIO_DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Brett Creeley <brett.creeley@amd.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}