{
  "module_name": "lm.c",
  "hash_id": "3268a8cdef801d7eff1fde64b8480a72e8c34c71e6d7aeaff1ac7af531c0154d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/pds/lm.c",
  "human_readable_source": "\n \n\n#include <linux/anon_inodes.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/vfio.h>\n#include <linux/vfio_pci_core.h>\n\n#include \"vfio_dev.h\"\n#include \"cmds.h\"\n\nstatic struct pds_vfio_lm_file *\npds_vfio_get_lm_file(const struct file_operations *fops, int flags, u64 size)\n{\n\tstruct pds_vfio_lm_file *lm_file = NULL;\n\tunsigned long long npages;\n\tstruct page **pages;\n\tvoid *page_mem;\n\tconst void *p;\n\n\tif (!size)\n\t\treturn NULL;\n\n\t \n\tlm_file = kzalloc(sizeof(*lm_file), GFP_KERNEL);\n\tif (!lm_file)\n\t\treturn NULL;\n\n\t \n\tlm_file->filep =\n\t\tanon_inode_getfile(\"pds_vfio_lm\", fops, lm_file, flags);\n\tif (IS_ERR(lm_file->filep))\n\t\tgoto out_free_file;\n\n\tstream_open(lm_file->filep->f_inode, lm_file->filep);\n\tmutex_init(&lm_file->lock);\n\n\t \n\tget_file(lm_file->filep);\n\n\t \n\tnpages = DIV_ROUND_UP_ULL(size, PAGE_SIZE);\n\tpages = kmalloc_array(npages, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out_put_file;\n\n\tpage_mem = kvzalloc(ALIGN(size, PAGE_SIZE), GFP_KERNEL);\n\tif (!page_mem)\n\t\tgoto out_free_pages_array;\n\n\tp = page_mem - offset_in_page(page_mem);\n\tfor (unsigned long long i = 0; i < npages; i++) {\n\t\tif (is_vmalloc_addr(p))\n\t\t\tpages[i] = vmalloc_to_page(p);\n\t\telse\n\t\t\tpages[i] = kmap_to_page((void *)p);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_page_mem;\n\n\t\tp += PAGE_SIZE;\n\t}\n\n\t \n\tif (sg_alloc_table_from_pages(&lm_file->sg_table, pages, npages, 0,\n\t\t\t\t      size, GFP_KERNEL))\n\t\tgoto out_free_page_mem;\n\n\tlm_file->size = size;\n\tlm_file->pages = pages;\n\tlm_file->npages = npages;\n\tlm_file->page_mem = page_mem;\n\tlm_file->alloc_size = npages * PAGE_SIZE;\n\n\treturn lm_file;\n\nout_free_page_mem:\n\tkvfree(page_mem);\nout_free_pages_array:\n\tkfree(pages);\nout_put_file:\n\tfput(lm_file->filep);\n\tmutex_destroy(&lm_file->lock);\nout_free_file:\n\tkfree(lm_file);\n\n\treturn NULL;\n}\n\nstatic void pds_vfio_put_lm_file(struct pds_vfio_lm_file *lm_file)\n{\n\tmutex_lock(&lm_file->lock);\n\n\tlm_file->size = 0;\n\tlm_file->alloc_size = 0;\n\n\t \n\tsg_free_table(&lm_file->sg_table);\n\n\tkvfree(lm_file->page_mem);\n\tlm_file->page_mem = NULL;\n\tkfree(lm_file->pages);\n\tlm_file->pages = NULL;\n\n\tmutex_unlock(&lm_file->lock);\n\n\t \n\tfput(lm_file->filep);\n}\n\nvoid pds_vfio_put_save_file(struct pds_vfio_pci_device *pds_vfio)\n{\n\tif (!pds_vfio->save_file)\n\t\treturn;\n\n\tpds_vfio_put_lm_file(pds_vfio->save_file);\n\tpds_vfio->save_file = NULL;\n}\n\nvoid pds_vfio_put_restore_file(struct pds_vfio_pci_device *pds_vfio)\n{\n\tif (!pds_vfio->restore_file)\n\t\treturn;\n\n\tpds_vfio_put_lm_file(pds_vfio->restore_file);\n\tpds_vfio->restore_file = NULL;\n}\n\nstatic struct page *pds_vfio_get_file_page(struct pds_vfio_lm_file *lm_file,\n\t\t\t\t\t   unsigned long offset)\n{\n\tunsigned long cur_offset = 0;\n\tstruct scatterlist *sg;\n\tunsigned int i;\n\n\t \n\tif (offset < lm_file->last_offset || !lm_file->last_offset_sg) {\n\t\tlm_file->last_offset = 0;\n\t\tlm_file->last_offset_sg = lm_file->sg_table.sgl;\n\t\tlm_file->sg_last_entry = 0;\n\t}\n\n\tcur_offset = lm_file->last_offset;\n\n\tfor_each_sg(lm_file->last_offset_sg, sg,\n\t\t    lm_file->sg_table.orig_nents - lm_file->sg_last_entry, i) {\n\t\tif (offset < sg->length + cur_offset) {\n\t\t\tlm_file->last_offset_sg = sg;\n\t\t\tlm_file->sg_last_entry += i;\n\t\t\tlm_file->last_offset = cur_offset;\n\t\t\treturn nth_page(sg_page(sg),\n\t\t\t\t\t(offset - cur_offset) / PAGE_SIZE);\n\t\t}\n\t\tcur_offset += sg->length;\n\t}\n\n\treturn NULL;\n}\n\nstatic int pds_vfio_release_file(struct inode *inode, struct file *filp)\n{\n\tstruct pds_vfio_lm_file *lm_file = filp->private_data;\n\n\tmutex_lock(&lm_file->lock);\n\tlm_file->filep->f_pos = 0;\n\tlm_file->size = 0;\n\tmutex_unlock(&lm_file->lock);\n\tmutex_destroy(&lm_file->lock);\n\tkfree(lm_file);\n\n\treturn 0;\n}\n\nstatic ssize_t pds_vfio_save_read(struct file *filp, char __user *buf,\n\t\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct pds_vfio_lm_file *lm_file = filp->private_data;\n\tssize_t done = 0;\n\n\tif (pos)\n\t\treturn -ESPIPE;\n\tpos = &filp->f_pos;\n\n\tmutex_lock(&lm_file->lock);\n\tif (*pos > lm_file->size) {\n\t\tdone = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = min_t(size_t, lm_file->size - *pos, len);\n\twhile (len) {\n\t\tsize_t page_offset;\n\t\tstruct page *page;\n\t\tsize_t page_len;\n\t\tu8 *from_buff;\n\t\tint err;\n\n\t\tpage_offset = (*pos) % PAGE_SIZE;\n\t\tpage = pds_vfio_get_file_page(lm_file, *pos - page_offset);\n\t\tif (!page) {\n\t\t\tif (done == 0)\n\t\t\t\tdone = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_len = min_t(size_t, len, PAGE_SIZE - page_offset);\n\t\tfrom_buff = kmap_local_page(page);\n\t\terr = copy_to_user(buf, from_buff + page_offset, page_len);\n\t\tkunmap_local(from_buff);\n\t\tif (err) {\n\t\t\tdone = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t*pos += page_len;\n\t\tlen -= page_len;\n\t\tdone += page_len;\n\t\tbuf += page_len;\n\t}\n\nout_unlock:\n\tmutex_unlock(&lm_file->lock);\n\treturn done;\n}\n\nstatic const struct file_operations pds_vfio_save_fops = {\n\t.owner = THIS_MODULE,\n\t.read = pds_vfio_save_read,\n\t.release = pds_vfio_release_file,\n\t.llseek = no_llseek,\n};\n\nstatic int pds_vfio_get_save_file(struct pds_vfio_pci_device *pds_vfio)\n{\n\tstruct device *dev = &pds_vfio->vfio_coredev.pdev->dev;\n\tstruct pds_vfio_lm_file *lm_file;\n\tu64 size;\n\tint err;\n\n\t \n\terr = pds_vfio_get_lm_state_size_cmd(pds_vfio, &size);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get save status: %pe\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tdev_dbg(dev, \"save status, size = %lld\\n\", size);\n\n\tif (!size) {\n\t\tdev_err(dev, \"invalid state size\\n\");\n\t\treturn -EIO;\n\t}\n\n\tlm_file = pds_vfio_get_lm_file(&pds_vfio_save_fops, O_RDONLY, size);\n\tif (!lm_file) {\n\t\tdev_err(dev, \"failed to create save file\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdev_dbg(dev, \"size = %lld, alloc_size = %lld, npages = %lld\\n\",\n\t\tlm_file->size, lm_file->alloc_size, lm_file->npages);\n\n\tpds_vfio->save_file = lm_file;\n\n\treturn 0;\n}\n\nstatic ssize_t pds_vfio_restore_write(struct file *filp, const char __user *buf,\n\t\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct pds_vfio_lm_file *lm_file = filp->private_data;\n\tloff_t requested_length;\n\tssize_t done = 0;\n\n\tif (pos)\n\t\treturn -ESPIPE;\n\n\tpos = &filp->f_pos;\n\n\tif (*pos < 0 ||\n\t    check_add_overflow((loff_t)len, *pos, &requested_length))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lm_file->lock);\n\n\twhile (len) {\n\t\tsize_t page_offset;\n\t\tstruct page *page;\n\t\tsize_t page_len;\n\t\tu8 *to_buff;\n\t\tint err;\n\n\t\tpage_offset = (*pos) % PAGE_SIZE;\n\t\tpage = pds_vfio_get_file_page(lm_file, *pos - page_offset);\n\t\tif (!page) {\n\t\t\tif (done == 0)\n\t\t\t\tdone = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_len = min_t(size_t, len, PAGE_SIZE - page_offset);\n\t\tto_buff = kmap_local_page(page);\n\t\terr = copy_from_user(to_buff + page_offset, buf, page_len);\n\t\tkunmap_local(to_buff);\n\t\tif (err) {\n\t\t\tdone = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t*pos += page_len;\n\t\tlen -= page_len;\n\t\tdone += page_len;\n\t\tbuf += page_len;\n\t\tlm_file->size += page_len;\n\t}\nout_unlock:\n\tmutex_unlock(&lm_file->lock);\n\treturn done;\n}\n\nstatic const struct file_operations pds_vfio_restore_fops = {\n\t.owner = THIS_MODULE,\n\t.write = pds_vfio_restore_write,\n\t.release = pds_vfio_release_file,\n\t.llseek = no_llseek,\n};\n\nstatic int pds_vfio_get_restore_file(struct pds_vfio_pci_device *pds_vfio)\n{\n\tstruct device *dev = &pds_vfio->vfio_coredev.pdev->dev;\n\tstruct pds_vfio_lm_file *lm_file;\n\tu64 size;\n\n\tsize = sizeof(union pds_lm_dev_state);\n\tdev_dbg(dev, \"restore status, size = %lld\\n\", size);\n\n\tif (!size) {\n\t\tdev_err(dev, \"invalid state size\");\n\t\treturn -EIO;\n\t}\n\n\tlm_file = pds_vfio_get_lm_file(&pds_vfio_restore_fops, O_WRONLY, size);\n\tif (!lm_file) {\n\t\tdev_err(dev, \"failed to create restore file\");\n\t\treturn -ENOENT;\n\t}\n\tpds_vfio->restore_file = lm_file;\n\n\treturn 0;\n}\n\nstruct file *\npds_vfio_step_device_state_locked(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t\t  enum vfio_device_mig_state next)\n{\n\tenum vfio_device_mig_state cur = pds_vfio->state;\n\tint err;\n\n\tif (cur == VFIO_DEVICE_STATE_STOP && next == VFIO_DEVICE_STATE_STOP_COPY) {\n\t\terr = pds_vfio_get_save_file(pds_vfio);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\terr = pds_vfio_get_lm_state_cmd(pds_vfio);\n\t\tif (err) {\n\t\t\tpds_vfio_put_save_file(pds_vfio);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\treturn pds_vfio->save_file->filep;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_STOP_COPY && next == VFIO_DEVICE_STATE_STOP) {\n\t\tpds_vfio_put_save_file(pds_vfio);\n\t\tpds_vfio_dirty_disable(pds_vfio, true);\n\t\treturn NULL;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_STOP && next == VFIO_DEVICE_STATE_RESUMING) {\n\t\terr = pds_vfio_get_restore_file(pds_vfio);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\treturn pds_vfio->restore_file->filep;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_RESUMING && next == VFIO_DEVICE_STATE_STOP) {\n\t\terr = pds_vfio_set_lm_state_cmd(pds_vfio);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tpds_vfio_put_restore_file(pds_vfio);\n\t\treturn NULL;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_RUNNING && next == VFIO_DEVICE_STATE_RUNNING_P2P) {\n\t\tpds_vfio_send_host_vf_lm_status_cmd(pds_vfio,\n\t\t\t\t\t\t    PDS_LM_STA_IN_PROGRESS);\n\t\terr = pds_vfio_suspend_device_cmd(pds_vfio,\n\t\t\t\t\t\t  PDS_LM_SUSPEND_RESUME_TYPE_P2P);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\treturn NULL;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_RUNNING_P2P && next == VFIO_DEVICE_STATE_RUNNING) {\n\t\terr = pds_vfio_resume_device_cmd(pds_vfio,\n\t\t\t\t\t\t PDS_LM_SUSPEND_RESUME_TYPE_FULL);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\tpds_vfio_send_host_vf_lm_status_cmd(pds_vfio, PDS_LM_STA_NONE);\n\t\treturn NULL;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_STOP && next == VFIO_DEVICE_STATE_RUNNING_P2P) {\n\t\terr = pds_vfio_resume_device_cmd(pds_vfio,\n\t\t\t\t\t\t PDS_LM_SUSPEND_RESUME_TYPE_P2P);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\treturn NULL;\n\t}\n\n\tif (cur == VFIO_DEVICE_STATE_RUNNING_P2P && next == VFIO_DEVICE_STATE_STOP) {\n\t\terr = pds_vfio_suspend_device_cmd(pds_vfio,\n\t\t\t\t\t\t  PDS_LM_SUSPEND_RESUME_TYPE_FULL);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\treturn NULL;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}