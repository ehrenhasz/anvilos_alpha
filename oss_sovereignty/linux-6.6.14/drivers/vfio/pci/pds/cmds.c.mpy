{
  "module_name": "cmds.c",
  "hash_id": "6273f0a97ce2a2035ac343a31081b60cac76c882d013bc6bf8d6022e4abbe830",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/pds/cmds.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/pds/pds_common.h>\n#include <linux/pds/pds_core_if.h>\n#include <linux/pds/pds_adminq.h>\n\n#include \"vfio_dev.h\"\n#include \"cmds.h\"\n\n#define SUSPEND_TIMEOUT_S\t\t5\n#define SUSPEND_CHECK_INTERVAL_MS\t1\n\nstatic int pds_vfio_client_adminq_cmd(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t\t      union pds_core_adminq_cmd *req,\n\t\t\t\t      union pds_core_adminq_comp *resp,\n\t\t\t\t      bool fast_poll)\n{\n\tstruct pci_dev *pdev = pds_vfio_to_pci_dev(pds_vfio);\n\tunion pds_core_adminq_cmd cmd = {};\n\tstruct pdsc *pdsc;\n\tint err;\n\n\t \n\tcmd.client_request.opcode = PDS_AQ_CMD_CLIENT_CMD;\n\tcmd.client_request.client_id = cpu_to_le16(pds_vfio->client_id);\n\tmemcpy(cmd.client_request.client_cmd, req,\n\t       sizeof(cmd.client_request.client_cmd));\n\n\tpdsc = pdsc_get_pf_struct(pdev);\n\tif (IS_ERR(pdsc))\n\t\treturn PTR_ERR(pdsc);\n\n\terr = pdsc_adminq_post(pdsc, &cmd, resp, fast_poll);\n\tif (err && err != -EAGAIN)\n\t\tdev_err(pds_vfio_to_dev(pds_vfio),\n\t\t\t\"client admin cmd failed: %pe\\n\", ERR_PTR(err));\n\n\treturn err;\n}\n\nint pds_vfio_register_client_cmd(struct pds_vfio_pci_device *pds_vfio)\n{\n\tstruct pci_dev *pdev = pds_vfio_to_pci_dev(pds_vfio);\n\tchar devname[PDS_DEVNAME_LEN];\n\tstruct pdsc *pdsc;\n\tint ci;\n\n\tsnprintf(devname, sizeof(devname), \"%s.%d-%u\", PDS_VFIO_LM_DEV_NAME,\n\t\t pci_domain_nr(pdev->bus),\n\t\t PCI_DEVID(pdev->bus->number, pdev->devfn));\n\n\tpdsc = pdsc_get_pf_struct(pdev);\n\tif (IS_ERR(pdsc))\n\t\treturn PTR_ERR(pdsc);\n\n\tci = pds_client_register(pdsc, devname);\n\tif (ci < 0)\n\t\treturn ci;\n\n\tpds_vfio->client_id = ci;\n\n\treturn 0;\n}\n\nvoid pds_vfio_unregister_client_cmd(struct pds_vfio_pci_device *pds_vfio)\n{\n\tstruct pci_dev *pdev = pds_vfio_to_pci_dev(pds_vfio);\n\tstruct pdsc *pdsc;\n\tint err;\n\n\tpdsc = pdsc_get_pf_struct(pdev);\n\tif (IS_ERR(pdsc))\n\t\treturn;\n\n\terr = pds_client_unregister(pdsc, pds_vfio->client_id);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"unregister from DSC failed: %pe\\n\",\n\t\t\tERR_PTR(err));\n\n\tpds_vfio->client_id = 0;\n}\n\nstatic int\npds_vfio_suspend_wait_device_cmd(struct pds_vfio_pci_device *pds_vfio, u8 type)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_suspend_status = {\n\t\t\t.opcode = PDS_LM_CMD_SUSPEND_STATUS,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.type = type,\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tunsigned long time_limit;\n\tunsigned long time_start;\n\tunsigned long time_done;\n\tint err;\n\n\ttime_start = jiffies;\n\ttime_limit = time_start + HZ * SUSPEND_TIMEOUT_S;\n\tdo {\n\t\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, true);\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\n\t\tmsleep(SUSPEND_CHECK_INTERVAL_MS);\n\t} while (time_before(jiffies, time_limit));\n\n\ttime_done = jiffies;\n\tdev_dbg(dev, \"%s: vf%u: Suspend comp received in %d msecs\\n\", __func__,\n\t\tpds_vfio->vf_id, jiffies_to_msecs(time_done - time_start));\n\n\t \n\tif (time_after_eq(time_done, time_limit)) {\n\t\tdev_err(dev, \"%s: vf%u: Suspend comp timeout\\n\", __func__,\n\t\t\tpds_vfio->vf_id);\n\t\terr = -ETIMEDOUT;\n\t}\n\n\treturn err;\n}\n\nint pds_vfio_suspend_device_cmd(struct pds_vfio_pci_device *pds_vfio, u8 type)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_suspend = {\n\t\t\t.opcode = PDS_LM_CMD_SUSPEND,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.type = type,\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\tdev_dbg(dev, \"vf%u: Suspend device\\n\", pds_vfio->vf_id);\n\n\t \n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, true);\n\tif (err) {\n\t\tdev_err(dev, \"vf%u: Suspend failed: %pe\\n\", pds_vfio->vf_id,\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t \n\treturn pds_vfio_suspend_wait_device_cmd(pds_vfio, type);\n}\n\nint pds_vfio_resume_device_cmd(struct pds_vfio_pci_device *pds_vfio, u8 type)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_resume = {\n\t\t\t.opcode = PDS_LM_CMD_RESUME,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.type = type,\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\n\tdev_dbg(dev, \"vf%u: Resume device\\n\", pds_vfio->vf_id);\n\n\treturn pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, true);\n}\n\nint pds_vfio_get_lm_state_size_cmd(struct pds_vfio_pci_device *pds_vfio, u64 *size)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_state_size = {\n\t\t\t.opcode = PDS_LM_CMD_STATE_SIZE,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\tdev_dbg(dev, \"vf%u: Get migration status\\n\", pds_vfio->vf_id);\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err)\n\t\treturn err;\n\n\t*size = le64_to_cpu(comp.lm_state_size.size);\n\treturn 0;\n}\n\nstatic int pds_vfio_dma_map_lm_file(struct device *dev,\n\t\t\t\t    enum dma_data_direction dir,\n\t\t\t\t    struct pds_vfio_lm_file *lm_file)\n{\n\tstruct pds_lm_sg_elem *sgl, *sge;\n\tstruct scatterlist *sg;\n\tdma_addr_t sgl_addr;\n\tsize_t sgl_size;\n\tint err;\n\tint i;\n\n\tif (!lm_file)\n\t\treturn -EINVAL;\n\n\t \n\terr = dma_map_sgtable(dev, &lm_file->sg_table, dir, 0);\n\tif (err)\n\t\treturn err;\n\n\tlm_file->num_sge = lm_file->sg_table.nents;\n\n\t \n\tsgl_size = lm_file->num_sge * sizeof(struct pds_lm_sg_elem);\n\tsgl = kzalloc(sgl_size, GFP_KERNEL);\n\tif (!sgl) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_sgtable;\n\t}\n\n\t \n\tsge = sgl;\n\tfor_each_sgtable_dma_sg(&lm_file->sg_table, sg, i) {\n\t\tsge->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tsge->len = cpu_to_le32(sg_dma_len(sg));\n\t\tdev_dbg(dev, \"addr = %llx, len = %u\\n\", sge->addr, sge->len);\n\t\tsge++;\n\t}\n\n\tsgl_addr = dma_map_single(dev, sgl, sgl_size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, sgl_addr)) {\n\t\terr = -EIO;\n\t\tgoto out_free_sgl;\n\t}\n\n\tlm_file->sgl = sgl;\n\tlm_file->sgl_addr = sgl_addr;\n\n\treturn 0;\n\nout_free_sgl:\n\tkfree(sgl);\nout_unmap_sgtable:\n\tlm_file->num_sge = 0;\n\tdma_unmap_sgtable(dev, &lm_file->sg_table, dir, 0);\n\treturn err;\n}\n\nstatic void pds_vfio_dma_unmap_lm_file(struct device *dev,\n\t\t\t\t       enum dma_data_direction dir,\n\t\t\t\t       struct pds_vfio_lm_file *lm_file)\n{\n\tif (!lm_file)\n\t\treturn;\n\n\t \n\tif (lm_file->sgl) {\n\t\tdma_unmap_single(dev, lm_file->sgl_addr,\n\t\t\t\t lm_file->num_sge * sizeof(*lm_file->sgl),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tkfree(lm_file->sgl);\n\t\tlm_file->sgl = NULL;\n\t\tlm_file->sgl_addr = DMA_MAPPING_ERROR;\n\t\tlm_file->num_sge = 0;\n\t}\n\n\t \n\tdma_unmap_sgtable(dev, &lm_file->sg_table, dir, 0);\n}\n\nint pds_vfio_get_lm_state_cmd(struct pds_vfio_pci_device *pds_vfio)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_save = {\n\t\t\t.opcode = PDS_LM_CMD_SAVE,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t},\n\t};\n\tstruct pci_dev *pdev = pds_vfio_to_pci_dev(pds_vfio);\n\tstruct device *pdsc_dev = &pci_physfn(pdev)->dev;\n\tunion pds_core_adminq_comp comp = {};\n\tstruct pds_vfio_lm_file *lm_file;\n\tint err;\n\n\tdev_dbg(&pdev->dev, \"vf%u: Get migration state\\n\", pds_vfio->vf_id);\n\n\tlm_file = pds_vfio->save_file;\n\n\terr = pds_vfio_dma_map_lm_file(pdsc_dev, DMA_FROM_DEVICE, lm_file);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to map save migration file: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tcmd.lm_save.sgl_addr = cpu_to_le64(lm_file->sgl_addr);\n\tcmd.lm_save.num_sge = cpu_to_le32(lm_file->num_sge);\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"failed to get migration state: %pe\\n\",\n\t\t\tERR_PTR(err));\n\n\tpds_vfio_dma_unmap_lm_file(pdsc_dev, DMA_FROM_DEVICE, lm_file);\n\n\treturn err;\n}\n\nint pds_vfio_set_lm_state_cmd(struct pds_vfio_pci_device *pds_vfio)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_restore = {\n\t\t\t.opcode = PDS_LM_CMD_RESTORE,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t},\n\t};\n\tstruct pci_dev *pdev = pds_vfio_to_pci_dev(pds_vfio);\n\tstruct device *pdsc_dev = &pci_physfn(pdev)->dev;\n\tunion pds_core_adminq_comp comp = {};\n\tstruct pds_vfio_lm_file *lm_file;\n\tint err;\n\n\tdev_dbg(&pdev->dev, \"vf%u: Set migration state\\n\", pds_vfio->vf_id);\n\n\tlm_file = pds_vfio->restore_file;\n\n\terr = pds_vfio_dma_map_lm_file(pdsc_dev, DMA_TO_DEVICE, lm_file);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to map restore migration file: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tcmd.lm_restore.sgl_addr = cpu_to_le64(lm_file->sgl_addr);\n\tcmd.lm_restore.num_sge = cpu_to_le32(lm_file->num_sge);\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"failed to set migration state: %pe\\n\",\n\t\t\tERR_PTR(err));\n\n\tpds_vfio_dma_unmap_lm_file(pdsc_dev, DMA_TO_DEVICE, lm_file);\n\n\treturn err;\n}\n\nvoid pds_vfio_send_host_vf_lm_status_cmd(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t\t\t enum pds_lm_host_vf_status vf_status)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_host_vf_status = {\n\t\t\t.opcode = PDS_LM_CMD_HOST_VF_STATUS,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.status = vf_status,\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\tdev_dbg(dev, \"vf%u: Set host VF LM status: %u\", pds_vfio->vf_id,\n\t\tvf_status);\n\tif (vf_status != PDS_LM_STA_IN_PROGRESS &&\n\t    vf_status != PDS_LM_STA_NONE) {\n\t\tdev_warn(dev, \"Invalid host VF migration status, %d\\n\",\n\t\t\t vf_status);\n\t\treturn;\n\t}\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err)\n\t\tdev_warn(dev, \"failed to send host VF migration status: %pe\\n\",\n\t\t\t ERR_PTR(err));\n}\n\nint pds_vfio_dirty_status_cmd(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t      u64 regions_dma, u8 *max_regions, u8 *num_regions)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_dirty_status = {\n\t\t\t.opcode = PDS_LM_CMD_DIRTY_STATUS,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\tdev_dbg(dev, \"vf%u: Dirty status\\n\", pds_vfio->vf_id);\n\n\tcmd.lm_dirty_status.regions_dma = cpu_to_le64(regions_dma);\n\tcmd.lm_dirty_status.max_regions = *max_regions;\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get dirty status: %pe\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t \n\tif (!(le32_to_cpu(comp.lm_dirty_status.bmp_type_mask) &\n\t      BIT(PDS_LM_DIRTY_BMP_TYPE_SEQ_ACK))) {\n\t\tdev_err(dev, \"Dirty bitmap tracking SEQ_ACK not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*num_regions = comp.lm_dirty_status.num_regions;\n\t*max_regions = comp.lm_dirty_status.max_regions;\n\n\tdev_dbg(dev,\n\t\t\"Page Tracking Status command successful, max_regions: %d, num_regions: %d, bmp_type: %s\\n\",\n\t\t*max_regions, *num_regions, \"PDS_LM_DIRTY_BMP_TYPE_SEQ_ACK\");\n\n\treturn 0;\n}\n\nint pds_vfio_dirty_enable_cmd(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t      u64 regions_dma, u8 num_regions)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_dirty_enable = {\n\t\t\t.opcode = PDS_LM_CMD_DIRTY_ENABLE,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.regions_dma = cpu_to_le64(regions_dma),\n\t\t\t.bmp_type = PDS_LM_DIRTY_BMP_TYPE_SEQ_ACK,\n\t\t\t.num_regions = num_regions,\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err) {\n\t\tdev_err(dev, \"failed dirty tracking enable: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint pds_vfio_dirty_disable_cmd(struct pds_vfio_pci_device *pds_vfio)\n{\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_dirty_disable = {\n\t\t\t.opcode = PDS_LM_CMD_DIRTY_DISABLE,\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err || comp.lm_dirty_status.num_regions != 0) {\n\t\t \n\t\terr = err ? err : -EIO;\n\t\tdev_err(dev,\n\t\t\t\"failed dirty tracking disable: %pe, num_regions %d\\n\",\n\t\t\tERR_PTR(err), comp.lm_dirty_status.num_regions);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint pds_vfio_dirty_seq_ack_cmd(struct pds_vfio_pci_device *pds_vfio,\n\t\t\t       u64 sgl_dma, u16 num_sge, u32 offset,\n\t\t\t       u32 total_len, bool read_seq)\n{\n\tconst char *cmd_type_str = read_seq ? \"read_seq\" : \"write_ack\";\n\tunion pds_core_adminq_cmd cmd = {\n\t\t.lm_dirty_seq_ack = {\n\t\t\t.vf_id = cpu_to_le16(pds_vfio->vf_id),\n\t\t\t.len_bytes = cpu_to_le32(total_len),\n\t\t\t.off_bytes = cpu_to_le32(offset),\n\t\t\t.sgl_addr = cpu_to_le64(sgl_dma),\n\t\t\t.num_sge = cpu_to_le16(num_sge),\n\t\t},\n\t};\n\tstruct device *dev = pds_vfio_to_dev(pds_vfio);\n\tunion pds_core_adminq_comp comp = {};\n\tint err;\n\n\tif (read_seq)\n\t\tcmd.lm_dirty_seq_ack.opcode = PDS_LM_CMD_DIRTY_READ_SEQ;\n\telse\n\t\tcmd.lm_dirty_seq_ack.opcode = PDS_LM_CMD_DIRTY_WRITE_ACK;\n\n\terr = pds_vfio_client_adminq_cmd(pds_vfio, &cmd, &comp, false);\n\tif (err) {\n\t\tdev_err(dev, \"failed cmd Page Tracking %s: %pe\\n\", cmd_type_str,\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}