{
  "module_name": "vfio_dev.c",
  "hash_id": "787a16c45d5a2d00f68a77df6550c396458575f4878447db390c802b9a76ce3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/pds/vfio_dev.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/vfio_pci_core.h>\n\n#include \"lm.h\"\n#include \"dirty.h\"\n#include \"vfio_dev.h\"\n\nstruct pci_dev *pds_vfio_to_pci_dev(struct pds_vfio_pci_device *pds_vfio)\n{\n\treturn pds_vfio->vfio_coredev.pdev;\n}\n\nstruct device *pds_vfio_to_dev(struct pds_vfio_pci_device *pds_vfio)\n{\n\treturn &pds_vfio_to_pci_dev(pds_vfio)->dev;\n}\n\nstruct pds_vfio_pci_device *pds_vfio_pci_drvdata(struct pci_dev *pdev)\n{\n\tstruct vfio_pci_core_device *core_device = dev_get_drvdata(&pdev->dev);\n\n\treturn container_of(core_device, struct pds_vfio_pci_device,\n\t\t\t    vfio_coredev);\n}\n\nvoid pds_vfio_state_mutex_unlock(struct pds_vfio_pci_device *pds_vfio)\n{\nagain:\n\tmutex_lock(&pds_vfio->reset_mutex);\n\tif (pds_vfio->deferred_reset) {\n\t\tpds_vfio->deferred_reset = false;\n\t\tif (pds_vfio->state == VFIO_DEVICE_STATE_ERROR) {\n\t\t\tpds_vfio_put_restore_file(pds_vfio);\n\t\t\tpds_vfio_put_save_file(pds_vfio);\n\t\t\tpds_vfio_dirty_disable(pds_vfio, false);\n\t\t}\n\t\tpds_vfio->state = pds_vfio->deferred_reset_state;\n\t\tpds_vfio->deferred_reset_state = VFIO_DEVICE_STATE_RUNNING;\n\t\tmutex_unlock(&pds_vfio->reset_mutex);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&pds_vfio->state_mutex);\n\tmutex_unlock(&pds_vfio->reset_mutex);\n}\n\nvoid pds_vfio_reset(struct pds_vfio_pci_device *pds_vfio)\n{\n\tmutex_lock(&pds_vfio->reset_mutex);\n\tpds_vfio->deferred_reset = true;\n\tpds_vfio->deferred_reset_state = VFIO_DEVICE_STATE_RUNNING;\n\tif (!mutex_trylock(&pds_vfio->state_mutex)) {\n\t\tmutex_unlock(&pds_vfio->reset_mutex);\n\t\treturn;\n\t}\n\tmutex_unlock(&pds_vfio->reset_mutex);\n\tpds_vfio_state_mutex_unlock(pds_vfio);\n}\n\nstatic struct file *\npds_vfio_set_device_state(struct vfio_device *vdev,\n\t\t\t  enum vfio_device_mig_state new_state)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\tstruct file *res = NULL;\n\n\tmutex_lock(&pds_vfio->state_mutex);\n\t \n\twhile (pds_vfio->state != VFIO_DEVICE_STATE_ERROR &&\n\t       new_state != pds_vfio->state) {\n\t\tenum vfio_device_mig_state next_state;\n\n\t\tint err = vfio_mig_get_next_state(vdev, pds_vfio->state,\n\t\t\t\t\t\t  new_state, &next_state);\n\t\tif (err) {\n\t\t\tres = ERR_PTR(err);\n\t\t\tbreak;\n\t\t}\n\n\t\tres = pds_vfio_step_device_state_locked(pds_vfio, next_state);\n\t\tif (IS_ERR(res))\n\t\t\tbreak;\n\n\t\tpds_vfio->state = next_state;\n\n\t\tif (WARN_ON(res && new_state != pds_vfio->state)) {\n\t\t\tres = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpds_vfio_state_mutex_unlock(pds_vfio);\n\t \n\tif (pds_vfio->state == VFIO_DEVICE_STATE_ERROR)\n\t\tres = ERR_PTR(-EIO);\n\n\treturn res;\n}\n\nstatic int pds_vfio_get_device_state(struct vfio_device *vdev,\n\t\t\t\t     enum vfio_device_mig_state *current_state)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\n\tmutex_lock(&pds_vfio->state_mutex);\n\t*current_state = pds_vfio->state;\n\tpds_vfio_state_mutex_unlock(pds_vfio);\n\treturn 0;\n}\n\nstatic int pds_vfio_get_device_state_size(struct vfio_device *vdev,\n\t\t\t\t\t  unsigned long *stop_copy_length)\n{\n\t*stop_copy_length = PDS_LM_DEVICE_STATE_LENGTH;\n\treturn 0;\n}\n\nstatic const struct vfio_migration_ops pds_vfio_lm_ops = {\n\t.migration_set_state = pds_vfio_set_device_state,\n\t.migration_get_state = pds_vfio_get_device_state,\n\t.migration_get_data_size = pds_vfio_get_device_state_size\n};\n\nstatic const struct vfio_log_ops pds_vfio_log_ops = {\n\t.log_start = pds_vfio_dma_logging_start,\n\t.log_stop = pds_vfio_dma_logging_stop,\n\t.log_read_and_clear = pds_vfio_dma_logging_report,\n};\n\nstatic int pds_vfio_init_device(struct vfio_device *vdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\tstruct pci_dev *pdev = to_pci_dev(vdev->dev);\n\tint err, vf_id, pci_id;\n\n\tvf_id = pci_iov_vf_id(pdev);\n\tif (vf_id < 0)\n\t\treturn vf_id;\n\n\terr = vfio_pci_core_init_dev(vdev);\n\tif (err)\n\t\treturn err;\n\n\tpds_vfio->vf_id = vf_id;\n\n\tmutex_init(&pds_vfio->state_mutex);\n\tmutex_init(&pds_vfio->reset_mutex);\n\n\tvdev->migration_flags = VFIO_MIGRATION_STOP_COPY | VFIO_MIGRATION_P2P;\n\tvdev->mig_ops = &pds_vfio_lm_ops;\n\tvdev->log_ops = &pds_vfio_log_ops;\n\n\tpci_id = PCI_DEVID(pdev->bus->number, pdev->devfn);\n\tdev_dbg(&pdev->dev,\n\t\t\"%s: PF %#04x VF %#04x vf_id %d domain %d pds_vfio %p\\n\",\n\t\t__func__, pci_dev_id(pci_physfn(pdev)), pci_id, vf_id,\n\t\tpci_domain_nr(pdev->bus), pds_vfio);\n\n\treturn 0;\n}\n\nstatic void pds_vfio_release_device(struct vfio_device *vdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\n\tmutex_destroy(&pds_vfio->state_mutex);\n\tmutex_destroy(&pds_vfio->reset_mutex);\n\tvfio_pci_core_release_dev(vdev);\n}\n\nstatic int pds_vfio_open_device(struct vfio_device *vdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\tint err;\n\n\terr = vfio_pci_core_enable(&pds_vfio->vfio_coredev);\n\tif (err)\n\t\treturn err;\n\n\tpds_vfio->state = VFIO_DEVICE_STATE_RUNNING;\n\tpds_vfio->deferred_reset_state = VFIO_DEVICE_STATE_RUNNING;\n\n\tvfio_pci_core_finish_enable(&pds_vfio->vfio_coredev);\n\n\treturn 0;\n}\n\nstatic void pds_vfio_close_device(struct vfio_device *vdev)\n{\n\tstruct pds_vfio_pci_device *pds_vfio =\n\t\tcontainer_of(vdev, struct pds_vfio_pci_device,\n\t\t\t     vfio_coredev.vdev);\n\n\tmutex_lock(&pds_vfio->state_mutex);\n\tpds_vfio_put_restore_file(pds_vfio);\n\tpds_vfio_put_save_file(pds_vfio);\n\tpds_vfio_dirty_disable(pds_vfio, true);\n\tmutex_unlock(&pds_vfio->state_mutex);\n\tvfio_pci_core_close_device(vdev);\n}\n\nstatic const struct vfio_device_ops pds_vfio_ops = {\n\t.name = \"pds-vfio\",\n\t.init = pds_vfio_init_device,\n\t.release = pds_vfio_release_device,\n\t.open_device = pds_vfio_open_device,\n\t.close_device = pds_vfio_close_device,\n\t.ioctl = vfio_pci_core_ioctl,\n\t.device_feature = vfio_pci_core_ioctl_feature,\n\t.read = vfio_pci_core_read,\n\t.write = vfio_pci_core_write,\n\t.mmap = vfio_pci_core_mmap,\n\t.request = vfio_pci_core_request,\n\t.match = vfio_pci_core_match,\n\t.bind_iommufd = vfio_iommufd_physical_bind,\n\t.unbind_iommufd = vfio_iommufd_physical_unbind,\n\t.attach_ioas = vfio_iommufd_physical_attach_ioas,\n};\n\nconst struct vfio_device_ops *pds_vfio_ops_info(void)\n{\n\treturn &pds_vfio_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}