{
  "module_name": "vfio_pci_config.c",
  "hash_id": "cf51b1dcd9422f8905609c18d51d3f94bf21b851d2808cd6ab86bfb115ce3cee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci_config.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/vfio.h>\n#include <linux/slab.h>\n\n#include \"vfio_pci_priv.h\"\n\n \n#define PCI_CAP_ID_BASIC\t0\n\n#define is_bar(offset)\t\\\n\t((offset >= PCI_BASE_ADDRESS_0 && offset < PCI_BASE_ADDRESS_5 + 4) || \\\n\t (offset >= PCI_ROM_ADDRESS && offset < PCI_ROM_ADDRESS + 4))\n\n \nstatic const u8 pci_cap_length[PCI_CAP_ID_MAX + 1] = {\n\t[PCI_CAP_ID_BASIC]\t= PCI_STD_HEADER_SIZEOF,  \n\t[PCI_CAP_ID_PM]\t\t= PCI_PM_SIZEOF,\n\t[PCI_CAP_ID_AGP]\t= PCI_AGP_SIZEOF,\n\t[PCI_CAP_ID_VPD]\t= PCI_CAP_VPD_SIZEOF,\n\t[PCI_CAP_ID_SLOTID]\t= 0,\t\t \n\t[PCI_CAP_ID_MSI]\t= 0xFF,\t\t \n\t[PCI_CAP_ID_CHSWP]\t= 0,\t\t \n\t[PCI_CAP_ID_PCIX]\t= 0xFF,\t\t \n\t[PCI_CAP_ID_HT]\t\t= 0xFF,\t\t \n\t[PCI_CAP_ID_VNDR]\t= 0xFF,\t\t \n\t[PCI_CAP_ID_DBG]\t= 0,\t\t \n\t[PCI_CAP_ID_CCRC]\t= 0,\t\t \n\t[PCI_CAP_ID_SHPC]\t= 0,\t\t \n\t[PCI_CAP_ID_SSVID]\t= 0,\t\t \n\t[PCI_CAP_ID_AGP3]\t= 0,\t\t \n\t[PCI_CAP_ID_SECDEV]\t= 0,\t\t \n\t[PCI_CAP_ID_EXP]\t= 0xFF,\t\t \n\t[PCI_CAP_ID_MSIX]\t= PCI_CAP_MSIX_SIZEOF,\n\t[PCI_CAP_ID_SATA]\t= 0xFF,\n\t[PCI_CAP_ID_AF]\t\t= PCI_CAP_AF_SIZEOF,\n};\n\n \nstatic const u16 pci_ext_cap_length[PCI_EXT_CAP_ID_MAX + 1] = {\n\t[PCI_EXT_CAP_ID_ERR]\t=\tPCI_ERR_ROOT_COMMAND,\n\t[PCI_EXT_CAP_ID_VC]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_DSN]\t=\tPCI_EXT_CAP_DSN_SIZEOF,\n\t[PCI_EXT_CAP_ID_PWR]\t=\tPCI_EXT_CAP_PWR_SIZEOF,\n\t[PCI_EXT_CAP_ID_RCLD]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_RCILC]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_RCEC]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_MFVC]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_VC9]\t=\t0xFF,\t \n\t[PCI_EXT_CAP_ID_RCRB]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_VNDR]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_CAC]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_ACS]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_ARI]\t=\tPCI_EXT_CAP_ARI_SIZEOF,\n\t[PCI_EXT_CAP_ID_ATS]\t=\tPCI_EXT_CAP_ATS_SIZEOF,\n\t[PCI_EXT_CAP_ID_SRIOV]\t=\tPCI_EXT_CAP_SRIOV_SIZEOF,\n\t[PCI_EXT_CAP_ID_MRIOV]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_MCAST]\t=\tPCI_EXT_CAP_MCAST_ENDPOINT_SIZEOF,\n\t[PCI_EXT_CAP_ID_PRI]\t=\tPCI_EXT_CAP_PRI_SIZEOF,\n\t[PCI_EXT_CAP_ID_AMD_XXX] =\t0,\t \n\t[PCI_EXT_CAP_ID_REBAR]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_DPA]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_TPH]\t=\t0xFF,\n\t[PCI_EXT_CAP_ID_LTR]\t=\tPCI_EXT_CAP_LTR_SIZEOF,\n\t[PCI_EXT_CAP_ID_SECPCI]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_PMUX]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_PASID]\t=\t0,\t \n\t[PCI_EXT_CAP_ID_DVSEC]\t=\t0xFF,\n};\n\n \nstruct perm_bits {\n\tu8\t*virt;\t\t \n\tu8\t*write;\t\t \n\tint\t(*readfn)(struct vfio_pci_core_device *vdev, int pos, int count,\n\t\t\t  struct perm_bits *perm, int offset, __le32 *val);\n\tint\t(*writefn)(struct vfio_pci_core_device *vdev, int pos, int count,\n\t\t\t   struct perm_bits *perm, int offset, __le32 val);\n};\n\n#define\tNO_VIRT\t\t0\n#define\tALL_VIRT\t0xFFFFFFFFU\n#define\tNO_WRITE\t0\n#define\tALL_WRITE\t0xFFFFFFFFU\n\nstatic int vfio_user_config_read(struct pci_dev *pdev, int offset,\n\t\t\t\t __le32 *val, int count)\n{\n\tint ret = -EINVAL;\n\tu32 tmp_val = 0;\n\n\tswitch (count) {\n\tcase 1:\n\t{\n\t\tu8 tmp;\n\t\tret = pci_user_read_config_byte(pdev, offset, &tmp);\n\t\ttmp_val = tmp;\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tu16 tmp;\n\t\tret = pci_user_read_config_word(pdev, offset, &tmp);\n\t\ttmp_val = tmp;\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tret = pci_user_read_config_dword(pdev, offset, &tmp_val);\n\t\tbreak;\n\t}\n\n\t*val = cpu_to_le32(tmp_val);\n\n\treturn ret;\n}\n\nstatic int vfio_user_config_write(struct pci_dev *pdev, int offset,\n\t\t\t\t  __le32 val, int count)\n{\n\tint ret = -EINVAL;\n\tu32 tmp_val = le32_to_cpu(val);\n\n\tswitch (count) {\n\tcase 1:\n\t\tret = pci_user_write_config_byte(pdev, offset, tmp_val);\n\t\tbreak;\n\tcase 2:\n\t\tret = pci_user_write_config_word(pdev, offset, tmp_val);\n\t\tbreak;\n\tcase 4:\n\t\tret = pci_user_write_config_dword(pdev, offset, tmp_val);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vfio_default_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t    int count, struct perm_bits *perm,\n\t\t\t\t    int offset, __le32 *val)\n{\n\t__le32 virt = 0;\n\n\tmemcpy(val, vdev->vconfig + pos, count);\n\n\tmemcpy(&virt, perm->virt + offset, count);\n\n\t \n\tif (cpu_to_le32(~0U >> (32 - (count * 8))) != virt) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\t__le32 phys_val = 0;\n\t\tint ret;\n\n\t\tret = vfio_user_config_read(pdev, pos, &phys_val, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = (phys_val & ~virt) | (*val & virt);\n\t}\n\n\treturn count;\n}\n\nstatic int vfio_default_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t     int count, struct perm_bits *perm,\n\t\t\t\t     int offset, __le32 val)\n{\n\t__le32 virt = 0, write = 0;\n\n\tmemcpy(&write, perm->write + offset, count);\n\n\tif (!write)\n\t\treturn count;  \n\n\tmemcpy(&virt, perm->virt + offset, count);\n\n\t \n\tif (write & virt) {\n\t\t__le32 virt_val = 0;\n\n\t\tmemcpy(&virt_val, vdev->vconfig + pos, count);\n\n\t\tvirt_val &= ~(write & virt);\n\t\tvirt_val |= (val & (write & virt));\n\n\t\tmemcpy(vdev->vconfig + pos, &virt_val, count);\n\t}\n\n\t \n\tif (write & ~virt) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\t__le32 phys_val = 0;\n\t\tint ret;\n\n\t\tret = vfio_user_config_read(pdev, pos, &phys_val, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tphys_val &= ~(write & ~virt);\n\t\tphys_val |= (val & (write & ~virt));\n\n\t\tret = vfio_user_config_write(pdev, pos, phys_val, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\n \nstatic int vfio_direct_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t   int count, struct perm_bits *perm,\n\t\t\t\t   int offset, __le32 *val)\n{\n\tint ret;\n\n\tret = vfio_user_config_read(vdev->pdev, pos, val, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pos >= PCI_CFG_SPACE_SIZE) {  \n\t\tif (offset < 4)\n\t\t\tmemcpy(val, vdev->vconfig + pos, count);\n\t} else if (pos >= PCI_STD_HEADER_SIZEOF) {  \n\t\tif (offset == PCI_CAP_LIST_ID && count > 1)\n\t\t\tmemcpy(val, vdev->vconfig + pos,\n\t\t\t       min(PCI_CAP_FLAGS, count));\n\t\telse if (offset == PCI_CAP_LIST_NEXT)\n\t\t\tmemcpy(val, vdev->vconfig + pos, 1);\n\t}\n\n\treturn count;\n}\n\n \nstatic int vfio_raw_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t int count, struct perm_bits *perm,\n\t\t\t\t int offset, __le32 val)\n{\n\tint ret;\n\n\tret = vfio_user_config_write(vdev->pdev, pos, val, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic int vfio_raw_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\tint count, struct perm_bits *perm,\n\t\t\t\tint offset, __le32 *val)\n{\n\tint ret;\n\n\tret = vfio_user_config_read(vdev->pdev, pos, val, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\n \nstatic int vfio_virt_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t  int count, struct perm_bits *perm,\n\t\t\t\t  int offset, __le32 val)\n{\n\tmemcpy(vdev->vconfig + pos, &val, count);\n\treturn count;\n}\n\nstatic int vfio_virt_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t int count, struct perm_bits *perm,\n\t\t\t\t int offset, __le32 *val)\n{\n\tmemcpy(val, vdev->vconfig + pos, count);\n\treturn count;\n}\n\n \nstatic struct perm_bits cap_perms[PCI_CAP_ID_MAX + 1] = {\n\t[0 ... PCI_CAP_ID_MAX] = { .readfn = vfio_direct_config_read }\n};\nstatic struct perm_bits ecap_perms[PCI_EXT_CAP_ID_MAX + 1] = {\n\t[0 ... PCI_EXT_CAP_ID_MAX] = { .readfn = vfio_direct_config_read }\n};\n \nstatic struct perm_bits unassigned_perms = {\n\t.readfn = vfio_raw_config_read,\n\t.writefn = vfio_raw_config_write\n};\n\nstatic struct perm_bits virt_perms = {\n\t.readfn = vfio_virt_config_read,\n\t.writefn = vfio_virt_config_write\n};\n\nstatic void free_perm_bits(struct perm_bits *perm)\n{\n\tkfree(perm->virt);\n\tkfree(perm->write);\n\tperm->virt = NULL;\n\tperm->write = NULL;\n}\n\nstatic int alloc_perm_bits(struct perm_bits *perm, int size)\n{\n\t \n\tsize = round_up(size, 4);\n\n\t \n\tperm->virt = kzalloc(size, GFP_KERNEL);\n\tperm->write = kzalloc(size, GFP_KERNEL);\n\tif (!perm->virt || !perm->write) {\n\t\tfree_perm_bits(perm);\n\t\treturn -ENOMEM;\n\t}\n\n\tperm->readfn = vfio_default_config_read;\n\tperm->writefn = vfio_default_config_write;\n\n\treturn 0;\n}\n\n \nstatic inline void p_setb(struct perm_bits *p, int off, u8 virt, u8 write)\n{\n\tp->virt[off] = virt;\n\tp->write[off] = write;\n}\n\n \nstatic inline void p_setw(struct perm_bits *p, int off, u16 virt, u16 write)\n{\n\t*(__le16 *)(&p->virt[off]) = cpu_to_le16(virt);\n\t*(__le16 *)(&p->write[off]) = cpu_to_le16(write);\n}\n\n \nstatic inline void p_setd(struct perm_bits *p, int off, u32 virt, u32 write)\n{\n\t*(__le32 *)(&p->virt[off]) = cpu_to_le32(virt);\n\t*(__le32 *)(&p->write[off]) = cpu_to_le32(write);\n}\n\n \nbool __vfio_pci_memory_enabled(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu16 cmd = le16_to_cpu(*(__le16 *)&vdev->vconfig[PCI_COMMAND]);\n\n\t \n\treturn pdev->current_state < PCI_D3hot &&\n\t       (pdev->no_command_memory || (cmd & PCI_COMMAND_MEMORY));\n}\n\n \nstatic void vfio_bar_restore(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu32 *rbar = vdev->rbar;\n\tu16 cmd;\n\tint i;\n\n\tif (pdev->is_virtfn)\n\t\treturn;\n\n\tpci_info(pdev, \"%s: reset recovery - restoring BARs\\n\", __func__);\n\n\tfor (i = PCI_BASE_ADDRESS_0; i <= PCI_BASE_ADDRESS_5; i += 4, rbar++)\n\t\tpci_user_write_config_dword(pdev, i, *rbar);\n\n\tpci_user_write_config_dword(pdev, PCI_ROM_ADDRESS, *rbar);\n\n\tif (vdev->nointx) {\n\t\tpci_user_read_config_word(pdev, PCI_COMMAND, &cmd);\n\t\tcmd |= PCI_COMMAND_INTX_DISABLE;\n\t\tpci_user_write_config_word(pdev, PCI_COMMAND, cmd);\n\t}\n}\n\nstatic __le32 vfio_generate_bar_flags(struct pci_dev *pdev, int bar)\n{\n\tunsigned long flags = pci_resource_flags(pdev, bar);\n\tu32 val;\n\n\tif (flags & IORESOURCE_IO)\n\t\treturn cpu_to_le32(PCI_BASE_ADDRESS_SPACE_IO);\n\n\tval = PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\tif (flags & IORESOURCE_PREFETCH)\n\t\tval |= PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\tif (flags & IORESOURCE_MEM_64)\n\t\tval |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n\treturn cpu_to_le32(val);\n}\n\n \nstatic void vfio_bar_fixup(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tint i;\n\t__le32 *vbar;\n\tu64 mask;\n\n\tif (!vdev->bardirty)\n\t\treturn;\n\n\tvbar = (__le32 *)&vdev->vconfig[PCI_BASE_ADDRESS_0];\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++, vbar++) {\n\t\tint bar = i + PCI_STD_RESOURCES;\n\n\t\tif (!pci_resource_start(pdev, bar)) {\n\t\t\t*vbar = 0;  \n\t\t\tcontinue;\n\t\t}\n\n\t\tmask = ~(pci_resource_len(pdev, bar) - 1);\n\n\t\t*vbar &= cpu_to_le32((u32)mask);\n\t\t*vbar |= vfio_generate_bar_flags(pdev, bar);\n\n\t\tif (*vbar & cpu_to_le32(PCI_BASE_ADDRESS_MEM_TYPE_64)) {\n\t\t\tvbar++;\n\t\t\t*vbar &= cpu_to_le32((u32)(mask >> 32));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tvbar = (__le32 *)&vdev->vconfig[PCI_ROM_ADDRESS];\n\n\t \n\tif (pci_resource_start(pdev, PCI_ROM_RESOURCE)) {\n\t\tmask = ~(pci_resource_len(pdev, PCI_ROM_RESOURCE) - 1);\n\t\tmask |= PCI_ROM_ADDRESS_ENABLE;\n\t\t*vbar &= cpu_to_le32((u32)mask);\n\t} else if (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\tIORESOURCE_ROM_SHADOW) {\n\t\tmask = ~(0x20000 - 1);\n\t\tmask |= PCI_ROM_ADDRESS_ENABLE;\n\t\t*vbar &= cpu_to_le32((u32)mask);\n\t} else\n\t\t*vbar = 0;\n\n\tvdev->bardirty = false;\n}\n\nstatic int vfio_basic_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t  int count, struct perm_bits *perm,\n\t\t\t\t  int offset, __le32 *val)\n{\n\tif (is_bar(offset))  \n\t\tvfio_bar_fixup(vdev);\n\n\tcount = vfio_default_config_read(vdev, pos, count, perm, offset, val);\n\n\t \n\tif (offset == PCI_COMMAND && vdev->pdev->no_command_memory) {\n\t\tu16 cmd = le16_to_cpu(*(__le16 *)&vdev->vconfig[PCI_COMMAND]);\n\t\tu32 tmp_val = le32_to_cpu(*val);\n\n\t\ttmp_val |= cmd & PCI_COMMAND_MEMORY;\n\t\t*val = cpu_to_le32(tmp_val);\n\t}\n\n\treturn count;\n}\n\n \nstatic bool vfio_need_bar_restore(struct vfio_pci_core_device *vdev)\n{\n\tint i = 0, pos = PCI_BASE_ADDRESS_0, ret;\n\tu32 bar;\n\n\tfor (; pos <= PCI_BASE_ADDRESS_5; i++, pos += 4) {\n\t\tif (vdev->rbar[i]) {\n\t\t\tret = pci_user_read_config_dword(vdev->pdev, pos, &bar);\n\t\t\tif (ret || vdev->rbar[i] != bar)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int vfio_basic_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t   int count, struct perm_bits *perm,\n\t\t\t\t   int offset, __le32 val)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\t__le16 *virt_cmd;\n\tu16 new_cmd = 0;\n\tint ret;\n\n\tvirt_cmd = (__le16 *)&vdev->vconfig[PCI_COMMAND];\n\n\tif (offset == PCI_COMMAND) {\n\t\tbool phys_mem, virt_mem, new_mem, phys_io, virt_io, new_io;\n\t\tu16 phys_cmd;\n\n\t\tret = pci_user_read_config_word(pdev, PCI_COMMAND, &phys_cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnew_cmd = le32_to_cpu(val);\n\n\t\tphys_io = !!(phys_cmd & PCI_COMMAND_IO);\n\t\tvirt_io = !!(le16_to_cpu(*virt_cmd) & PCI_COMMAND_IO);\n\t\tnew_io = !!(new_cmd & PCI_COMMAND_IO);\n\n\t\tphys_mem = !!(phys_cmd & PCI_COMMAND_MEMORY);\n\t\tvirt_mem = !!(le16_to_cpu(*virt_cmd) & PCI_COMMAND_MEMORY);\n\t\tnew_mem = !!(new_cmd & PCI_COMMAND_MEMORY);\n\n\t\tif (!new_mem)\n\t\t\tvfio_pci_zap_and_down_write_memory_lock(vdev);\n\t\telse\n\t\t\tdown_write(&vdev->memory_lock);\n\n\t\t \n\t\tif ((new_mem && virt_mem && !phys_mem &&\n\t\t     !pdev->no_command_memory) ||\n\t\t    (new_io && virt_io && !phys_io) ||\n\t\t    vfio_need_bar_restore(vdev))\n\t\t\tvfio_bar_restore(vdev);\n\t}\n\n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0) {\n\t\tif (offset == PCI_COMMAND)\n\t\t\tup_write(&vdev->memory_lock);\n\t\treturn count;\n\t}\n\n\t \n\tif (offset == PCI_COMMAND) {\n\t\tu16 mask = PCI_COMMAND_MEMORY | PCI_COMMAND_IO;\n\n\t\t*virt_cmd &= cpu_to_le16(~mask);\n\t\t*virt_cmd |= cpu_to_le16(new_cmd & mask);\n\n\t\tup_write(&vdev->memory_lock);\n\t}\n\n\t \n\tif (offset >= PCI_COMMAND && offset <= PCI_COMMAND + 1) {\n\t\tbool virt_intx_disable;\n\n\t\tvirt_intx_disable = !!(le16_to_cpu(*virt_cmd) &\n\t\t\t\t       PCI_COMMAND_INTX_DISABLE);\n\n\t\tif (virt_intx_disable && !vdev->virq_disabled) {\n\t\t\tvdev->virq_disabled = true;\n\t\t\tvfio_pci_intx_mask(vdev);\n\t\t} else if (!virt_intx_disable && vdev->virq_disabled) {\n\t\t\tvdev->virq_disabled = false;\n\t\t\tvfio_pci_intx_unmask(vdev);\n\t\t}\n\t}\n\n\tif (is_bar(offset))\n\t\tvdev->bardirty = true;\n\n\treturn count;\n}\n\n \nstatic int __init init_pci_cap_basic_perm(struct perm_bits *perm)\n{\n\tif (alloc_perm_bits(perm, PCI_STD_HEADER_SIZEOF))\n\t\treturn -ENOMEM;\n\n\tperm->readfn = vfio_basic_config_read;\n\tperm->writefn = vfio_basic_config_write;\n\n\t \n\tp_setw(perm, PCI_VENDOR_ID, (u16)ALL_VIRT, NO_WRITE);\n\tp_setw(perm, PCI_DEVICE_ID, (u16)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setw(perm, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE, (u16)ALL_WRITE);\n\n\t \n\tp_setw(perm, PCI_STATUS, PCI_STATUS_CAP_LIST, NO_WRITE);\n\n\t \n\tp_setb(perm, PCI_CACHE_LINE_SIZE, NO_VIRT, (u8)ALL_WRITE);\n\tp_setb(perm, PCI_LATENCY_TIMER, NO_VIRT, (u8)ALL_WRITE);\n\tp_setb(perm, PCI_BIST, NO_VIRT, (u8)ALL_WRITE);\n\n\t \n\tp_setd(perm, PCI_BASE_ADDRESS_0, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_BASE_ADDRESS_1, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_BASE_ADDRESS_2, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_BASE_ADDRESS_3, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_BASE_ADDRESS_4, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_BASE_ADDRESS_5, ALL_VIRT, ALL_WRITE);\n\tp_setd(perm, PCI_ROM_ADDRESS, ALL_VIRT, ALL_WRITE);\n\n\t \n\tp_setb(perm, PCI_CAPABILITY_LIST, (u8)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setb(perm, PCI_INTERRUPT_LINE, (u8)ALL_VIRT, (u8)ALL_WRITE);\n\n\t \n\tp_setb(perm, PCI_INTERRUPT_PIN, (u8)ALL_VIRT, (u8)NO_WRITE);\n\n\treturn 0;\n}\n\n \nstatic void vfio_lock_and_set_power_state(struct vfio_pci_core_device *vdev,\n\t\t\t\t\t  pci_power_t state)\n{\n\tif (state >= PCI_D3hot)\n\t\tvfio_pci_zap_and_down_write_memory_lock(vdev);\n\telse\n\t\tdown_write(&vdev->memory_lock);\n\n\tvfio_pci_set_power_state(vdev, state);\n\tup_write(&vdev->memory_lock);\n}\n\nstatic int vfio_pm_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\tint count, struct perm_bits *perm,\n\t\t\t\tint offset, __le32 val)\n{\n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0)\n\t\treturn count;\n\n\tif (offset == PCI_PM_CTRL) {\n\t\tpci_power_t state;\n\n\t\tswitch (le32_to_cpu(val) & PCI_PM_CTRL_STATE_MASK) {\n\t\tcase 0:\n\t\t\tstate = PCI_D0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstate = PCI_D1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstate = PCI_D2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstate = PCI_D3hot;\n\t\t\tbreak;\n\t\t}\n\n\t\tvfio_lock_and_set_power_state(vdev, state);\n\t}\n\n\treturn count;\n}\n\n \nstatic int __init init_pci_cap_pm_perm(struct perm_bits *perm)\n{\n\tif (alloc_perm_bits(perm, pci_cap_length[PCI_CAP_ID_PM]))\n\t\treturn -ENOMEM;\n\n\tperm->writefn = vfio_pm_config_write;\n\n\t \n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setw(perm, PCI_PM_PMC, PCI_PM_CAP_PME_MASK, NO_WRITE);\n\n\t \n\tp_setd(perm, PCI_PM_CTRL,\n\t       PCI_PM_CTRL_PME_ENABLE | PCI_PM_CTRL_PME_STATUS,\n\t       ~(PCI_PM_CTRL_PME_ENABLE | PCI_PM_CTRL_PME_STATUS |\n\t\t PCI_PM_CTRL_STATE_MASK));\n\n\treturn 0;\n}\n\nstatic int vfio_vpd_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t int count, struct perm_bits *perm,\n\t\t\t\t int offset, __le32 val)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\t__le16 *paddr = (__le16 *)(vdev->vconfig + pos - offset + PCI_VPD_ADDR);\n\t__le32 *pdata = (__le32 *)(vdev->vconfig + pos - offset + PCI_VPD_DATA);\n\tu16 addr;\n\tu32 data;\n\n\t \n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0 || offset > PCI_VPD_ADDR + 1 ||\n\t    offset + count <= PCI_VPD_ADDR + 1)\n\t\treturn count;\n\n\taddr = le16_to_cpu(*paddr);\n\n\tif (addr & PCI_VPD_ADDR_F) {\n\t\tdata = le32_to_cpu(*pdata);\n\t\tif (pci_write_vpd(pdev, addr & ~PCI_VPD_ADDR_F, 4, &data) != 4)\n\t\t\treturn count;\n\t} else {\n\t\tdata = 0;\n\t\tif (pci_read_vpd(pdev, addr, 4, &data) < 0)\n\t\t\treturn count;\n\t\t*pdata = cpu_to_le32(data);\n\t}\n\n\t \n\taddr ^= PCI_VPD_ADDR_F;\n\t*paddr = cpu_to_le16(addr);\n\n\treturn count;\n}\n\n \nstatic int __init init_pci_cap_vpd_perm(struct perm_bits *perm)\n{\n\tif (alloc_perm_bits(perm, pci_cap_length[PCI_CAP_ID_VPD]))\n\t\treturn -ENOMEM;\n\n\tperm->writefn = vfio_vpd_config_write;\n\n\t \n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setw(perm, PCI_VPD_ADDR, (u16)ALL_VIRT, (u16)ALL_WRITE);\n\tp_setd(perm, PCI_VPD_DATA, ALL_VIRT, ALL_WRITE);\n\n\treturn 0;\n}\n\n \nstatic int __init init_pci_cap_pcix_perm(struct perm_bits *perm)\n{\n\t \n\tif (alloc_perm_bits(perm, PCI_CAP_PCIX_SIZEOF_V2))\n\t\treturn -ENOMEM;\n\n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\n\tp_setw(perm, PCI_X_CMD, NO_VIRT, (u16)ALL_WRITE);\n\tp_setd(perm, PCI_X_ECC_CSR, NO_VIRT, ALL_WRITE);\n\treturn 0;\n}\n\nstatic int vfio_exp_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t int count, struct perm_bits *perm,\n\t\t\t\t int offset, __le32 val)\n{\n\t__le16 *ctrl = (__le16 *)(vdev->vconfig + pos -\n\t\t\t\t  offset + PCI_EXP_DEVCTL);\n\tint readrq = le16_to_cpu(*ctrl) & PCI_EXP_DEVCTL_READRQ;\n\n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0)\n\t\treturn count;\n\n\t \n\tif (*ctrl & cpu_to_le16(PCI_EXP_DEVCTL_BCR_FLR)) {\n\t\tu32 cap;\n\t\tint ret;\n\n\t\t*ctrl &= ~cpu_to_le16(PCI_EXP_DEVCTL_BCR_FLR);\n\n\t\tret = pci_user_read_config_dword(vdev->pdev,\n\t\t\t\t\t\t pos - offset + PCI_EXP_DEVCAP,\n\t\t\t\t\t\t &cap);\n\n\t\tif (!ret && (cap & PCI_EXP_DEVCAP_FLR)) {\n\t\t\tvfio_pci_zap_and_down_write_memory_lock(vdev);\n\t\t\tpci_try_reset_function(vdev->pdev);\n\t\t\tup_write(&vdev->memory_lock);\n\t\t}\n\t}\n\n\t \n\tif (readrq != (le16_to_cpu(*ctrl) & PCI_EXP_DEVCTL_READRQ)) {\n\t\treadrq = 128 <<\n\t\t\t((le16_to_cpu(*ctrl) & PCI_EXP_DEVCTL_READRQ) >> 12);\n\t\treadrq = max(readrq, pcie_get_mps(vdev->pdev));\n\n\t\tpcie_set_readrq(vdev->pdev, readrq);\n\t}\n\n\treturn count;\n}\n\n \nstatic int __init init_pci_cap_exp_perm(struct perm_bits *perm)\n{\n\t \n\tif (alloc_perm_bits(perm, PCI_CAP_EXP_ENDPOINT_SIZEOF_V2))\n\t\treturn -ENOMEM;\n\n\tperm->writefn = vfio_exp_config_write;\n\n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setw(perm, PCI_EXP_DEVCTL,\n\t       PCI_EXP_DEVCTL_BCR_FLR | PCI_EXP_DEVCTL_PAYLOAD |\n\t       PCI_EXP_DEVCTL_READRQ, ~PCI_EXP_DEVCTL_PHANTOM);\n\tp_setw(perm, PCI_EXP_DEVCTL2, NO_VIRT, ~PCI_EXP_DEVCTL2_ARI);\n\treturn 0;\n}\n\nstatic int vfio_af_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\tint count, struct perm_bits *perm,\n\t\t\t\tint offset, __le32 val)\n{\n\tu8 *ctrl = vdev->vconfig + pos - offset + PCI_AF_CTRL;\n\n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0)\n\t\treturn count;\n\n\t \n\tif (*ctrl & PCI_AF_CTRL_FLR) {\n\t\tu8 cap;\n\t\tint ret;\n\n\t\t*ctrl &= ~PCI_AF_CTRL_FLR;\n\n\t\tret = pci_user_read_config_byte(vdev->pdev,\n\t\t\t\t\t\tpos - offset + PCI_AF_CAP,\n\t\t\t\t\t\t&cap);\n\n\t\tif (!ret && (cap & PCI_AF_CAP_FLR) && (cap & PCI_AF_CAP_TP)) {\n\t\t\tvfio_pci_zap_and_down_write_memory_lock(vdev);\n\t\t\tpci_try_reset_function(vdev->pdev);\n\t\t\tup_write(&vdev->memory_lock);\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic int __init init_pci_cap_af_perm(struct perm_bits *perm)\n{\n\tif (alloc_perm_bits(perm, pci_cap_length[PCI_CAP_ID_AF]))\n\t\treturn -ENOMEM;\n\n\tperm->writefn = vfio_af_config_write;\n\n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\tp_setb(perm, PCI_AF_CTRL, PCI_AF_CTRL_FLR, PCI_AF_CTRL_FLR);\n\treturn 0;\n}\n\n \nstatic int __init init_pci_ext_cap_err_perm(struct perm_bits *perm)\n{\n\tu32 mask;\n\n\tif (alloc_perm_bits(perm, pci_ext_cap_length[PCI_EXT_CAP_ID_ERR]))\n\t\treturn -ENOMEM;\n\n\t \n\tp_setd(perm, 0, ALL_VIRT, NO_WRITE);\n\n\t \n\tmask =\tPCI_ERR_UNC_UND |\t\t \n\t\tPCI_ERR_UNC_DLP |\t\t \n\t\tPCI_ERR_UNC_SURPDN |\t\t \n\t\tPCI_ERR_UNC_POISON_TLP |\t \n\t\tPCI_ERR_UNC_FCP |\t\t \n\t\tPCI_ERR_UNC_COMP_TIME |\t\t \n\t\tPCI_ERR_UNC_COMP_ABORT |\t \n\t\tPCI_ERR_UNC_UNX_COMP |\t\t \n\t\tPCI_ERR_UNC_RX_OVER |\t\t \n\t\tPCI_ERR_UNC_MALF_TLP |\t\t \n\t\tPCI_ERR_UNC_ECRC |\t\t \n\t\tPCI_ERR_UNC_UNSUP |\t\t \n\t\tPCI_ERR_UNC_ACSV |\t\t \n\t\tPCI_ERR_UNC_INTN |\t\t \n\t\tPCI_ERR_UNC_MCBTLP |\t\t \n\t\tPCI_ERR_UNC_ATOMEG |\t\t \n\t\tPCI_ERR_UNC_TLPPRE;\t\t \n\tp_setd(perm, PCI_ERR_UNCOR_STATUS, NO_VIRT, mask);\n\tp_setd(perm, PCI_ERR_UNCOR_MASK, NO_VIRT, mask);\n\tp_setd(perm, PCI_ERR_UNCOR_SEVER, NO_VIRT, mask);\n\n\tmask =\tPCI_ERR_COR_RCVR |\t\t \n\t\tPCI_ERR_COR_BAD_TLP |\t\t \n\t\tPCI_ERR_COR_BAD_DLLP |\t\t \n\t\tPCI_ERR_COR_REP_ROLL |\t\t \n\t\tPCI_ERR_COR_REP_TIMER |\t\t \n\t\tPCI_ERR_COR_ADV_NFAT |\t\t \n\t\tPCI_ERR_COR_INTERNAL |\t\t \n\t\tPCI_ERR_COR_LOG_OVER;\t\t \n\tp_setd(perm, PCI_ERR_COR_STATUS, NO_VIRT, mask);\n\tp_setd(perm, PCI_ERR_COR_MASK, NO_VIRT, mask);\n\n\tmask =\tPCI_ERR_CAP_ECRC_GENE |\t\t \n\t\tPCI_ERR_CAP_ECRC_CHKE;\t\t \n\tp_setd(perm, PCI_ERR_CAP, NO_VIRT, mask);\n\treturn 0;\n}\n\n \nstatic int __init init_pci_ext_cap_pwr_perm(struct perm_bits *perm)\n{\n\tif (alloc_perm_bits(perm, pci_ext_cap_length[PCI_EXT_CAP_ID_PWR]))\n\t\treturn -ENOMEM;\n\n\tp_setd(perm, 0, ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setb(perm, PCI_PWR_DATA, NO_VIRT, (u8)ALL_WRITE);\n\treturn 0;\n}\n\n \nvoid vfio_pci_uninit_perm_bits(void)\n{\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_BASIC]);\n\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_PM]);\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_VPD]);\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_PCIX]);\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_EXP]);\n\tfree_perm_bits(&cap_perms[PCI_CAP_ID_AF]);\n\n\tfree_perm_bits(&ecap_perms[PCI_EXT_CAP_ID_ERR]);\n\tfree_perm_bits(&ecap_perms[PCI_EXT_CAP_ID_PWR]);\n}\n\nint __init vfio_pci_init_perm_bits(void)\n{\n\tint ret;\n\n\t \n\tret = init_pci_cap_basic_perm(&cap_perms[PCI_CAP_ID_BASIC]);\n\n\t \n\tret |= init_pci_cap_pm_perm(&cap_perms[PCI_CAP_ID_PM]);\n\tret |= init_pci_cap_vpd_perm(&cap_perms[PCI_CAP_ID_VPD]);\n\tret |= init_pci_cap_pcix_perm(&cap_perms[PCI_CAP_ID_PCIX]);\n\tcap_perms[PCI_CAP_ID_VNDR].writefn = vfio_raw_config_write;\n\tret |= init_pci_cap_exp_perm(&cap_perms[PCI_CAP_ID_EXP]);\n\tret |= init_pci_cap_af_perm(&cap_perms[PCI_CAP_ID_AF]);\n\n\t \n\tret |= init_pci_ext_cap_err_perm(&ecap_perms[PCI_EXT_CAP_ID_ERR]);\n\tret |= init_pci_ext_cap_pwr_perm(&ecap_perms[PCI_EXT_CAP_ID_PWR]);\n\tecap_perms[PCI_EXT_CAP_ID_VNDR].writefn = vfio_raw_config_write;\n\tecap_perms[PCI_EXT_CAP_ID_DVSEC].writefn = vfio_raw_config_write;\n\n\tif (ret)\n\t\tvfio_pci_uninit_perm_bits();\n\n\treturn ret;\n}\n\nstatic int vfio_find_cap_start(struct vfio_pci_core_device *vdev, int pos)\n{\n\tu8 cap;\n\tint base = (pos >= PCI_CFG_SPACE_SIZE) ? PCI_CFG_SPACE_SIZE :\n\t\t\t\t\t\t PCI_STD_HEADER_SIZEOF;\n\tcap = vdev->pci_config_map[pos];\n\n\tif (cap == PCI_CAP_ID_BASIC)\n\t\treturn 0;\n\n\t \n\twhile (pos - 1 >= base && vdev->pci_config_map[pos - 1] == cap)\n\t\tpos--;\n\n\treturn pos;\n}\n\nstatic int vfio_msi_config_read(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\tint count, struct perm_bits *perm,\n\t\t\t\tint offset, __le32 *val)\n{\n\t \n\tif (offset <= PCI_MSI_FLAGS && offset + count >= PCI_MSI_FLAGS) {\n\t\t__le16 *flags;\n\t\tint start;\n\n\t\tstart = vfio_find_cap_start(vdev, pos);\n\n\t\tflags = (__le16 *)&vdev->vconfig[start];\n\n\t\t*flags &= cpu_to_le16(~PCI_MSI_FLAGS_QMASK);\n\t\t*flags |= cpu_to_le16(vdev->msi_qmax << 1);\n\t}\n\n\treturn vfio_default_config_read(vdev, pos, count, perm, offset, val);\n}\n\nstatic int vfio_msi_config_write(struct vfio_pci_core_device *vdev, int pos,\n\t\t\t\t int count, struct perm_bits *perm,\n\t\t\t\t int offset, __le32 val)\n{\n\tcount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\n\tif (count < 0)\n\t\treturn count;\n\n\t \n\tif (offset <= PCI_MSI_FLAGS && offset + count >= PCI_MSI_FLAGS) {\n\t\t__le16 *pflags;\n\t\tu16 flags;\n\t\tint start, ret;\n\n\t\tstart = vfio_find_cap_start(vdev, pos);\n\n\t\tpflags = (__le16 *)&vdev->vconfig[start + PCI_MSI_FLAGS];\n\n\t\tflags = le16_to_cpu(*pflags);\n\n\t\t \n\t\tif  (vdev->irq_type != VFIO_PCI_MSI_IRQ_INDEX)\n\t\t\tflags &= ~PCI_MSI_FLAGS_ENABLE;\n\n\t\t \n\t\tif ((flags & PCI_MSI_FLAGS_QSIZE) >> 4 > vdev->msi_qmax) {\n\t\t\tflags &= ~PCI_MSI_FLAGS_QSIZE;\n\t\t\tflags |= vdev->msi_qmax << 4;\n\t\t}\n\n\t\t \n\t\t*pflags = cpu_to_le16(flags);\n\t\tret = pci_user_write_config_word(vdev->pdev,\n\t\t\t\t\t\t start + PCI_MSI_FLAGS,\n\t\t\t\t\t\t flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\n \nstatic int init_pci_cap_msi_perm(struct perm_bits *perm, int len, u16 flags)\n{\n\tif (alloc_perm_bits(perm, len))\n\t\treturn -ENOMEM;\n\n\tperm->readfn = vfio_msi_config_read;\n\tperm->writefn = vfio_msi_config_write;\n\n\tp_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\n\n\t \n\tp_setb(perm, PCI_MSI_FLAGS, (u8)ALL_VIRT, (u8)ALL_WRITE);\n\tp_setd(perm, PCI_MSI_ADDRESS_LO, ALL_VIRT, ALL_WRITE);\n\tif (flags & PCI_MSI_FLAGS_64BIT) {\n\t\tp_setd(perm, PCI_MSI_ADDRESS_HI, ALL_VIRT, ALL_WRITE);\n\t\tp_setw(perm, PCI_MSI_DATA_64, (u16)ALL_VIRT, (u16)ALL_WRITE);\n\t\tif (flags & PCI_MSI_FLAGS_MASKBIT) {\n\t\t\tp_setd(perm, PCI_MSI_MASK_64, NO_VIRT, ALL_WRITE);\n\t\t\tp_setd(perm, PCI_MSI_PENDING_64, NO_VIRT, ALL_WRITE);\n\t\t}\n\t} else {\n\t\tp_setw(perm, PCI_MSI_DATA_32, (u16)ALL_VIRT, (u16)ALL_WRITE);\n\t\tif (flags & PCI_MSI_FLAGS_MASKBIT) {\n\t\t\tp_setd(perm, PCI_MSI_MASK_32, NO_VIRT, ALL_WRITE);\n\t\t\tp_setd(perm, PCI_MSI_PENDING_32, NO_VIRT, ALL_WRITE);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int vfio_msi_cap_len(struct vfio_pci_core_device *vdev, u8 pos)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tint len, ret;\n\tu16 flags;\n\n\tret = pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &flags);\n\tif (ret)\n\t\treturn pcibios_err_to_errno(ret);\n\n\tlen = 10;  \n\tif (flags & PCI_MSI_FLAGS_64BIT)\n\t\tlen += 4;\n\tif (flags & PCI_MSI_FLAGS_MASKBIT)\n\t\tlen += 10;\n\n\tif (vdev->msi_perm)\n\t\treturn len;\n\n\tvdev->msi_perm = kmalloc(sizeof(struct perm_bits), GFP_KERNEL_ACCOUNT);\n\tif (!vdev->msi_perm)\n\t\treturn -ENOMEM;\n\n\tret = init_pci_cap_msi_perm(vdev->msi_perm, len, flags);\n\tif (ret) {\n\t\tkfree(vdev->msi_perm);\n\t\treturn ret;\n\t}\n\n\treturn len;\n}\n\n \nstatic int vfio_vc_cap_len(struct vfio_pci_core_device *vdev, u16 pos)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu32 tmp;\n\tint ret, evcc, phases, vc_arb;\n\tint len = PCI_CAP_VC_BASE_SIZEOF;\n\n\tret = pci_read_config_dword(pdev, pos + PCI_VC_PORT_CAP1, &tmp);\n\tif (ret)\n\t\treturn pcibios_err_to_errno(ret);\n\n\tevcc = tmp & PCI_VC_CAP1_EVCC;  \n\tret = pci_read_config_dword(pdev, pos + PCI_VC_PORT_CAP2, &tmp);\n\tif (ret)\n\t\treturn pcibios_err_to_errno(ret);\n\n\tif (tmp & PCI_VC_CAP2_128_PHASE)\n\t\tphases = 128;\n\telse if (tmp & PCI_VC_CAP2_64_PHASE)\n\t\tphases = 64;\n\telse if (tmp & PCI_VC_CAP2_32_PHASE)\n\t\tphases = 32;\n\telse\n\t\tphases = 0;\n\n\tvc_arb = phases * 4;\n\n\t \n\tlen += (1 + evcc) * PCI_CAP_VC_PER_VC_SIZEOF;\n\tif (vc_arb) {\n\t\tlen = round_up(len, 16);\n\t\tlen += vc_arb / 8;\n\t}\n\treturn len;\n}\n\nstatic int vfio_cap_len(struct vfio_pci_core_device *vdev, u8 cap, u8 pos)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu32 dword;\n\tu16 word;\n\tu8 byte;\n\tint ret;\n\n\tswitch (cap) {\n\tcase PCI_CAP_ID_MSI:\n\t\treturn vfio_msi_cap_len(vdev, pos);\n\tcase PCI_CAP_ID_PCIX:\n\t\tret = pci_read_config_word(pdev, pos + PCI_X_CMD, &word);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tif (PCI_X_CMD_VERSION(word)) {\n\t\t\tif (pdev->cfg_size > PCI_CFG_SPACE_SIZE) {\n\t\t\t\t \n\t\t\t\tpci_read_config_dword(pdev, PCI_CFG_SPACE_SIZE,\n\t\t\t\t\t\t      &dword);\n\t\t\t\tvdev->extended_caps = (dword != 0);\n\t\t\t}\n\t\t\treturn PCI_CAP_PCIX_SIZEOF_V2;\n\t\t} else\n\t\t\treturn PCI_CAP_PCIX_SIZEOF_V0;\n\tcase PCI_CAP_ID_VNDR:\n\t\t \n\t\tret = pci_read_config_byte(pdev, pos + PCI_CAP_FLAGS, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\treturn byte;\n\tcase PCI_CAP_ID_EXP:\n\t\tif (pdev->cfg_size > PCI_CFG_SPACE_SIZE) {\n\t\t\t \n\t\t\tpci_read_config_dword(pdev, PCI_CFG_SPACE_SIZE, &dword);\n\t\t\tvdev->extended_caps = (dword != 0);\n\t\t}\n\n\t\t \n\t\tif ((pcie_caps_reg(pdev) & PCI_EXP_FLAGS_VERS) == 1) {\n\t\t\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_RC_END)\n\t\t\t\treturn 0xc;  \n\t\t\treturn PCI_CAP_EXP_ENDPOINT_SIZEOF_V1;\n\t\t} else {\n\t\t\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_RC_END)\n\t\t\t\treturn 0x2c;  \n\t\t\treturn PCI_CAP_EXP_ENDPOINT_SIZEOF_V2;\n\t\t}\n\tcase PCI_CAP_ID_HT:\n\t\tret = pci_read_config_byte(pdev, pos + 3, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\treturn (byte & HT_3BIT_CAP_MASK) ?\n\t\t\tHT_CAP_SIZEOF_SHORT : HT_CAP_SIZEOF_LONG;\n\tcase PCI_CAP_ID_SATA:\n\t\tret = pci_read_config_byte(pdev, pos + PCI_SATA_REGS, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tbyte &= PCI_SATA_REGS_MASK;\n\t\tif (byte == PCI_SATA_REGS_INLINE)\n\t\t\treturn PCI_SATA_SIZEOF_LONG;\n\t\telse\n\t\t\treturn PCI_SATA_SIZEOF_SHORT;\n\tdefault:\n\t\tpci_warn(pdev, \"%s: unknown length for PCI cap %#x@%#x\\n\",\n\t\t\t __func__, cap, pos);\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_ext_cap_len(struct vfio_pci_core_device *vdev, u16 ecap, u16 epos)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu8 byte;\n\tu32 dword;\n\tint ret;\n\n\tswitch (ecap) {\n\tcase PCI_EXT_CAP_ID_VNDR:\n\t\tret = pci_read_config_dword(pdev, epos + PCI_VSEC_HDR, &dword);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\treturn dword >> PCI_VSEC_HDR_LEN_SHIFT;\n\tcase PCI_EXT_CAP_ID_VC:\n\tcase PCI_EXT_CAP_ID_VC9:\n\tcase PCI_EXT_CAP_ID_MFVC:\n\t\treturn vfio_vc_cap_len(vdev, epos);\n\tcase PCI_EXT_CAP_ID_ACS:\n\t\tret = pci_read_config_byte(pdev, epos + PCI_ACS_CAP, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tif (byte & PCI_ACS_EC) {\n\t\t\tint bits;\n\n\t\t\tret = pci_read_config_byte(pdev,\n\t\t\t\t\t\t   epos + PCI_ACS_EGRESS_BITS,\n\t\t\t\t\t\t   &byte);\n\t\t\tif (ret)\n\t\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\t\tbits = byte ? round_up(byte, 32) : 256;\n\t\t\treturn 8 + (bits / 8);\n\t\t}\n\t\treturn 8;\n\n\tcase PCI_EXT_CAP_ID_REBAR:\n\t\tret = pci_read_config_byte(pdev, epos + PCI_REBAR_CTRL, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tbyte &= PCI_REBAR_CTRL_NBAR_MASK;\n\t\tbyte >>= PCI_REBAR_CTRL_NBAR_SHIFT;\n\n\t\treturn 4 + (byte * 8);\n\tcase PCI_EXT_CAP_ID_DPA:\n\t\tret = pci_read_config_byte(pdev, epos + PCI_DPA_CAP, &byte);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tbyte &= PCI_DPA_CAP_SUBSTATE_MASK;\n\t\treturn PCI_DPA_BASE_SIZEOF + byte + 1;\n\tcase PCI_EXT_CAP_ID_TPH:\n\t\tret = pci_read_config_dword(pdev, epos + PCI_TPH_CAP, &dword);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\n\t\tif ((dword & PCI_TPH_CAP_LOC_MASK) == PCI_TPH_LOC_CAP) {\n\t\t\tint sts;\n\n\t\t\tsts = dword & PCI_TPH_CAP_ST_MASK;\n\t\t\tsts >>= PCI_TPH_CAP_ST_SHIFT;\n\t\t\treturn PCI_TPH_BASE_SIZEOF + (sts * 2) + 2;\n\t\t}\n\t\treturn PCI_TPH_BASE_SIZEOF;\n\tcase PCI_EXT_CAP_ID_DVSEC:\n\t\tret = pci_read_config_dword(pdev, epos + PCI_DVSEC_HEADER1, &dword);\n\t\tif (ret)\n\t\t\treturn pcibios_err_to_errno(ret);\n\t\treturn PCI_DVSEC_HEADER1_LEN(dword);\n\tdefault:\n\t\tpci_warn(pdev, \"%s: unknown length for PCI ecap %#x@%#x\\n\",\n\t\t\t __func__, ecap, epos);\n\t}\n\n\treturn 0;\n}\n\nstatic void vfio_update_pm_vconfig_bytes(struct vfio_pci_core_device *vdev,\n\t\t\t\t\t int offset)\n{\n\t__le16 *pmc = (__le16 *)&vdev->vconfig[offset + PCI_PM_PMC];\n\t__le16 *ctrl = (__le16 *)&vdev->vconfig[offset + PCI_PM_CTRL];\n\n\t \n\t*pmc &= ~cpu_to_le16(PCI_PM_CAP_PME_MASK);\n\t*ctrl &= ~cpu_to_le16(PCI_PM_CTRL_PME_ENABLE | PCI_PM_CTRL_PME_STATUS);\n}\n\nstatic int vfio_fill_vconfig_bytes(struct vfio_pci_core_device *vdev,\n\t\t\t\t   int offset, int size)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tint ret = 0;\n\n\t \n\twhile (size) {\n\t\tint filled;\n\n\t\tif (size >= 4 && !(offset % 4)) {\n\t\t\t__le32 *dwordp = (__le32 *)&vdev->vconfig[offset];\n\t\t\tu32 dword;\n\n\t\t\tret = pci_read_config_dword(pdev, offset, &dword);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*dwordp = cpu_to_le32(dword);\n\t\t\tfilled = 4;\n\t\t} else if (size >= 2 && !(offset % 2)) {\n\t\t\t__le16 *wordp = (__le16 *)&vdev->vconfig[offset];\n\t\t\tu16 word;\n\n\t\t\tret = pci_read_config_word(pdev, offset, &word);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*wordp = cpu_to_le16(word);\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 *byte = &vdev->vconfig[offset];\n\t\t\tret = pci_read_config_byte(pdev, offset, byte);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tfilled = 1;\n\t\t}\n\n\t\toffset += filled;\n\t\tsize -= filled;\n\t}\n\n\treturn ret;\n}\n\nstatic int vfio_cap_init(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu8 *map = vdev->pci_config_map;\n\tu16 status;\n\tu8 pos, *prev, cap;\n\tint loops, ret, caps = 0;\n\n\t \n\tret = pci_read_config_word(pdev, PCI_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(status & PCI_STATUS_CAP_LIST))\n\t\treturn 0;  \n\n\tret = pci_read_config_byte(pdev, PCI_CAPABILITY_LIST, &pos);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tprev = &vdev->vconfig[PCI_CAPABILITY_LIST];\n\n\t \n\tloops = (PCI_CFG_SPACE_SIZE - PCI_STD_HEADER_SIZEOF) / PCI_CAP_SIZEOF;\n\twhile (pos && loops--) {\n\t\tu8 next;\n\t\tint i, len = 0;\n\n\t\tret = pci_read_config_byte(pdev, pos, &cap);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pci_read_config_byte(pdev,\n\t\t\t\t\t   pos + PCI_CAP_LIST_NEXT, &next);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (cap && cap <= PCI_CAP_ID_MAX) {\n\t\t\tlen = pci_cap_length[cap];\n\t\t\tif (len == 0xFF) {  \n\t\t\t\tlen = vfio_cap_len(vdev, cap, pos);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\n\t\tif (!len) {\n\t\t\tpci_dbg(pdev, \"%s: hiding cap %#x@%#x\\n\", __func__,\n\t\t\t\tcap, pos);\n\t\t\t*prev = next;\n\t\t\tpos = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (likely(map[pos + i] == PCI_CAP_ID_INVALID))\n\t\t\t\tcontinue;\n\n\t\t\tpci_warn(pdev, \"%s: PCI config conflict @%#x, was cap %#x now cap %#x\\n\",\n\t\t\t\t __func__, pos + i, map[pos + i], cap);\n\t\t}\n\n\t\tBUILD_BUG_ON(PCI_CAP_ID_MAX >= PCI_CAP_ID_INVALID_VIRT);\n\n\t\tmemset(map + pos, cap, len);\n\t\tret = vfio_fill_vconfig_bytes(vdev, pos, len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (cap == PCI_CAP_ID_PM)\n\t\t\tvfio_update_pm_vconfig_bytes(vdev, pos);\n\n\t\tprev = &vdev->vconfig[pos + PCI_CAP_LIST_NEXT];\n\t\tpos = next;\n\t\tcaps++;\n\t}\n\n\t \n\tif (!caps) {\n\t\t__le16 *vstatus = (__le16 *)&vdev->vconfig[PCI_STATUS];\n\t\t*vstatus &= ~cpu_to_le16(PCI_STATUS_CAP_LIST);\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_ecap_init(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu8 *map = vdev->pci_config_map;\n\tu16 epos;\n\t__le32 *prev = NULL;\n\tint loops, ret, ecaps = 0;\n\n\tif (!vdev->extended_caps)\n\t\treturn 0;\n\n\tepos = PCI_CFG_SPACE_SIZE;\n\n\tloops = (pdev->cfg_size - PCI_CFG_SPACE_SIZE) / PCI_CAP_SIZEOF;\n\n\twhile (loops-- && epos >= PCI_CFG_SPACE_SIZE) {\n\t\tu32 header;\n\t\tu16 ecap;\n\t\tint i, len = 0;\n\t\tbool hidden = false;\n\n\t\tret = pci_read_config_dword(pdev, epos, &header);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tecap = PCI_EXT_CAP_ID(header);\n\n\t\tif (ecap <= PCI_EXT_CAP_ID_MAX) {\n\t\t\tlen = pci_ext_cap_length[ecap];\n\t\t\tif (len == 0xFF) {\n\t\t\t\tlen = vfio_ext_cap_len(vdev, ecap, epos);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\n\t\tif (!len) {\n\t\t\tpci_dbg(pdev, \"%s: hiding ecap %#x@%#x\\n\",\n\t\t\t\t__func__, ecap, epos);\n\n\t\t\t \n\t\t\tif (prev) {\n\t\t\t\tu32 val = epos = PCI_EXT_CAP_NEXT(header);\n\t\t\t\t*prev &= cpu_to_le32(~(0xffcU << 20));\n\t\t\t\t*prev |= cpu_to_le32(val << 20);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tlen = PCI_CAP_SIZEOF;\n\t\t\thidden = true;\n\t\t}\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (likely(map[epos + i] == PCI_CAP_ID_INVALID))\n\t\t\t\tcontinue;\n\n\t\t\tpci_warn(pdev, \"%s: PCI config conflict @%#x, was ecap %#x now ecap %#x\\n\",\n\t\t\t\t __func__, epos + i, map[epos + i], ecap);\n\t\t}\n\n\t\t \n\t\tBUILD_BUG_ON(PCI_EXT_CAP_ID_MAX >= PCI_CAP_ID_INVALID_VIRT);\n\n\t\tmemset(map + epos, ecap, len);\n\t\tret = vfio_fill_vconfig_bytes(vdev, epos, len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (hidden)\n\t\t\t*(__le32 *)&vdev->vconfig[epos] &=\n\t\t\t\tcpu_to_le32((0xffcU << 20));\n\t\telse\n\t\t\tecaps++;\n\n\t\tprev = (__le32 *)&vdev->vconfig[epos];\n\t\tepos = PCI_EXT_CAP_NEXT(header);\n\t}\n\n\tif (!ecaps)\n\t\t*(u32 *)&vdev->vconfig[PCI_CFG_SPACE_SIZE] = 0;\n\n\treturn 0;\n}\n\n \nstatic const struct pci_device_id known_bogus_vf_intx_pin[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x270c) },\n\t{}\n};\n\n \nint vfio_config_init(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tu8 *map, *vconfig;\n\tint ret;\n\n\t \n\tmap = kmalloc(pdev->cfg_size, GFP_KERNEL_ACCOUNT);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tvconfig = kmalloc(pdev->cfg_size, GFP_KERNEL_ACCOUNT);\n\tif (!vconfig) {\n\t\tkfree(map);\n\t\treturn -ENOMEM;\n\t}\n\n\tvdev->pci_config_map = map;\n\tvdev->vconfig = vconfig;\n\n\tmemset(map, PCI_CAP_ID_BASIC, PCI_STD_HEADER_SIZEOF);\n\tmemset(map + PCI_STD_HEADER_SIZEOF, PCI_CAP_ID_INVALID,\n\t       pdev->cfg_size - PCI_STD_HEADER_SIZEOF);\n\n\tret = vfio_fill_vconfig_bytes(vdev, 0, PCI_STD_HEADER_SIZEOF);\n\tif (ret)\n\t\tgoto out;\n\n\tvdev->bardirty = true;\n\n\t \n\n\t \n\tvdev->rbar[0] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_0]);\n\tvdev->rbar[1] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_1]);\n\tvdev->rbar[2] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_2]);\n\tvdev->rbar[3] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_3]);\n\tvdev->rbar[4] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_4]);\n\tvdev->rbar[5] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_5]);\n\tvdev->rbar[6] = le32_to_cpu(*(__le32 *)&vconfig[PCI_ROM_ADDRESS]);\n\n\tif (pdev->is_virtfn) {\n\t\t*(__le16 *)&vconfig[PCI_VENDOR_ID] = cpu_to_le16(pdev->vendor);\n\t\t*(__le16 *)&vconfig[PCI_DEVICE_ID] = cpu_to_le16(pdev->device);\n\n\t\t \n\t\tif (vconfig[PCI_INTERRUPT_PIN] &&\n\t\t    !pci_match_id(known_bogus_vf_intx_pin, pdev))\n\t\t\tpci_warn(pdev,\n\t\t\t\t \"Hardware bug: VF reports bogus INTx pin %d\\n\",\n\t\t\t\t vconfig[PCI_INTERRUPT_PIN]);\n\n\t\tvconfig[PCI_INTERRUPT_PIN] = 0;  \n\t}\n\tif (pdev->no_command_memory) {\n\t\t \n\t\t*(__le16 *)&vconfig[PCI_COMMAND] |=\n\t\t\t\t\tcpu_to_le16(PCI_COMMAND_MEMORY);\n\t}\n\n\tif (!IS_ENABLED(CONFIG_VFIO_PCI_INTX) || vdev->nointx)\n\t\tvconfig[PCI_INTERRUPT_PIN] = 0;\n\n\tret = vfio_cap_init(vdev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = vfio_ecap_init(vdev);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tkfree(map);\n\tvdev->pci_config_map = NULL;\n\tkfree(vconfig);\n\tvdev->vconfig = NULL;\n\treturn pcibios_err_to_errno(ret);\n}\n\nvoid vfio_config_free(struct vfio_pci_core_device *vdev)\n{\n\tkfree(vdev->vconfig);\n\tvdev->vconfig = NULL;\n\tkfree(vdev->pci_config_map);\n\tvdev->pci_config_map = NULL;\n\tif (vdev->msi_perm) {\n\t\tfree_perm_bits(vdev->msi_perm);\n\t\tkfree(vdev->msi_perm);\n\t\tvdev->msi_perm = NULL;\n\t}\n}\n\n \nstatic size_t vfio_pci_cap_remaining_dword(struct vfio_pci_core_device *vdev,\n\t\t\t\t\t   loff_t pos)\n{\n\tu8 cap = vdev->pci_config_map[pos];\n\tsize_t i;\n\n\tfor (i = 1; (pos + i) % 4 && vdev->pci_config_map[pos + i] == cap; i++)\n\t\t ;\n\n\treturn i;\n}\n\nstatic ssize_t vfio_config_do_rw(struct vfio_pci_core_device *vdev, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos, bool iswrite)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct perm_bits *perm;\n\t__le32 val = 0;\n\tint cap_start = 0, offset;\n\tu8 cap_id;\n\tssize_t ret;\n\n\tif (*ppos < 0 || *ppos >= pdev->cfg_size ||\n\t    *ppos + count > pdev->cfg_size)\n\t\treturn -EFAULT;\n\n\t \n\tcount = min(count, vfio_pci_cap_remaining_dword(vdev, *ppos));\n\tif (count >= 4 && !(*ppos % 4))\n\t\tcount = 4;\n\telse if (count >= 2 && !(*ppos % 2))\n\t\tcount = 2;\n\telse\n\t\tcount = 1;\n\n\tret = count;\n\n\tcap_id = vdev->pci_config_map[*ppos];\n\n\tif (cap_id == PCI_CAP_ID_INVALID) {\n\t\tperm = &unassigned_perms;\n\t\tcap_start = *ppos;\n\t} else if (cap_id == PCI_CAP_ID_INVALID_VIRT) {\n\t\tperm = &virt_perms;\n\t\tcap_start = *ppos;\n\t} else {\n\t\tif (*ppos >= PCI_CFG_SPACE_SIZE) {\n\t\t\tWARN_ON(cap_id > PCI_EXT_CAP_ID_MAX);\n\n\t\t\tperm = &ecap_perms[cap_id];\n\t\t\tcap_start = vfio_find_cap_start(vdev, *ppos);\n\t\t} else {\n\t\t\tWARN_ON(cap_id > PCI_CAP_ID_MAX);\n\n\t\t\tperm = &cap_perms[cap_id];\n\n\t\t\tif (cap_id == PCI_CAP_ID_MSI)\n\t\t\t\tperm = vdev->msi_perm;\n\n\t\t\tif (cap_id > PCI_CAP_ID_BASIC)\n\t\t\t\tcap_start = vfio_find_cap_start(vdev, *ppos);\n\t\t}\n\t}\n\n\tWARN_ON(!cap_start && cap_id != PCI_CAP_ID_BASIC);\n\tWARN_ON(cap_start > *ppos);\n\n\toffset = *ppos - cap_start;\n\n\tif (iswrite) {\n\t\tif (!perm->writefn)\n\t\t\treturn ret;\n\n\t\tif (copy_from_user(&val, buf, count))\n\t\t\treturn -EFAULT;\n\n\t\tret = perm->writefn(vdev, *ppos, count, perm, offset, val);\n\t} else {\n\t\tif (perm->readfn) {\n\t\t\tret = perm->readfn(vdev, *ppos, count,\n\t\t\t\t\t   perm, offset, &val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (copy_to_user(buf, &val, count))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nssize_t vfio_pci_config_rw(struct vfio_pci_core_device *vdev, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos, bool iswrite)\n{\n\tsize_t done = 0;\n\tint ret = 0;\n\tloff_t pos = *ppos;\n\n\tpos &= VFIO_PCI_OFFSET_MASK;\n\n\twhile (count) {\n\t\tret = vfio_config_do_rw(vdev, buf, count, &pos, iswrite);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcount -= ret;\n\t\tdone += ret;\n\t\tbuf += ret;\n\t\tpos += ret;\n\t}\n\n\t*ppos += done;\n\n\treturn done;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}