{
  "module_name": "vfio_pci.c",
  "hash_id": "fe4529bd692b5a98777ca21dba061911db9197f9b53c7091f8019f11362cabe7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/eventfd.h>\n#include <linux/file.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include \"vfio_pci_priv.h\"\n\n#define DRIVER_AUTHOR   \"Alex Williamson <alex.williamson@redhat.com>\"\n#define DRIVER_DESC     \"VFIO PCI - User Level meta-driver\"\n\nstatic char ids[1024] __initdata;\nmodule_param_string(ids, ids, sizeof(ids), 0);\nMODULE_PARM_DESC(ids, \"Initial PCI IDs to add to the vfio driver, format is \\\"vendor:device[:subvendor[:subdevice[:class[:class_mask]]]]\\\" and multiple comma separated entries can be specified\");\n\nstatic bool nointxmask;\nmodule_param_named(nointxmask, nointxmask, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(nointxmask,\n\t\t  \"Disable support for PCI 2.3 style INTx masking.  If this resolves problems for specific devices, report lspci -vvvxxx to linux-pci@vger.kernel.org so the device can be fixed automatically via the broken_intx_masking flag.\");\n\n#ifdef CONFIG_VFIO_PCI_VGA\nstatic bool disable_vga;\nmodule_param(disable_vga, bool, S_IRUGO);\nMODULE_PARM_DESC(disable_vga, \"Disable VGA resource access through vfio-pci\");\n#endif\n\nstatic bool disable_idle_d3;\nmodule_param(disable_idle_d3, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(disable_idle_d3,\n\t\t \"Disable using the PCI D3 low power state for idle, unused devices\");\n\nstatic bool enable_sriov;\n#ifdef CONFIG_PCI_IOV\nmodule_param(enable_sriov, bool, 0644);\nMODULE_PARM_DESC(enable_sriov, \"Enable support for SR-IOV configuration.  Enabling SR-IOV on a PF typically requires support of the userspace PF driver, enabling VFs without such support may result in non-functional VFs or PF.\");\n#endif\n\nstatic bool disable_denylist;\nmodule_param(disable_denylist, bool, 0444);\nMODULE_PARM_DESC(disable_denylist, \"Disable use of device denylist. Disabling the denylist allows binding to devices with known errata that may lead to exploitable stability or security issues when accessed by untrusted users.\");\n\nstatic bool vfio_pci_dev_in_denylist(struct pci_dev *pdev)\n{\n\tswitch (pdev->vendor) {\n\tcase PCI_VENDOR_ID_INTEL:\n\t\tswitch (pdev->device) {\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_C3XXX:\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_C3XXX_VF:\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_C62X:\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_C62X_VF:\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_DH895XCC:\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_DH895XCC_VF:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool vfio_pci_is_denylisted(struct pci_dev *pdev)\n{\n\tif (!vfio_pci_dev_in_denylist(pdev))\n\t\treturn false;\n\n\tif (disable_denylist) {\n\t\tpci_warn(pdev,\n\t\t\t \"device denylist disabled - allowing device %04x:%04x.\\n\",\n\t\t\t pdev->vendor, pdev->device);\n\t\treturn false;\n\t}\n\n\tpci_warn(pdev, \"%04x:%04x exists in vfio-pci device denylist, driver probing disallowed.\\n\",\n\t\t pdev->vendor, pdev->device);\n\n\treturn true;\n}\n\nstatic int vfio_pci_open_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_pci_core_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_pci_core_device, vdev);\n\tstruct pci_dev *pdev = vdev->pdev;\n\tint ret;\n\n\tret = vfio_pci_core_enable(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vfio_pci_is_vga(pdev) &&\n\t    pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    IS_ENABLED(CONFIG_VFIO_PCI_IGD)) {\n\t\tret = vfio_pci_igd_init(vdev);\n\t\tif (ret && ret != -ENODEV) {\n\t\t\tpci_warn(pdev, \"Failed to setup Intel IGD regions\\n\");\n\t\t\tvfio_pci_core_disable(vdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvfio_pci_core_finish_enable(vdev);\n\n\treturn 0;\n}\n\nstatic const struct vfio_device_ops vfio_pci_ops = {\n\t.name\t\t= \"vfio-pci\",\n\t.init\t\t= vfio_pci_core_init_dev,\n\t.release\t= vfio_pci_core_release_dev,\n\t.open_device\t= vfio_pci_open_device,\n\t.close_device\t= vfio_pci_core_close_device,\n\t.ioctl\t\t= vfio_pci_core_ioctl,\n\t.device_feature = vfio_pci_core_ioctl_feature,\n\t.read\t\t= vfio_pci_core_read,\n\t.write\t\t= vfio_pci_core_write,\n\t.mmap\t\t= vfio_pci_core_mmap,\n\t.request\t= vfio_pci_core_request,\n\t.match\t\t= vfio_pci_core_match,\n\t.bind_iommufd\t= vfio_iommufd_physical_bind,\n\t.unbind_iommufd\t= vfio_iommufd_physical_unbind,\n\t.attach_ioas\t= vfio_iommufd_physical_attach_ioas,\n\t.detach_ioas\t= vfio_iommufd_physical_detach_ioas,\n};\n\nstatic int vfio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct vfio_pci_core_device *vdev;\n\tint ret;\n\n\tif (vfio_pci_is_denylisted(pdev))\n\t\treturn -EINVAL;\n\n\tvdev = vfio_alloc_device(vfio_pci_core_device, vdev, &pdev->dev,\n\t\t\t\t &vfio_pci_ops);\n\tif (IS_ERR(vdev))\n\t\treturn PTR_ERR(vdev);\n\n\tdev_set_drvdata(&pdev->dev, vdev);\n\tret = vfio_pci_core_register_device(vdev);\n\tif (ret)\n\t\tgoto out_put_vdev;\n\treturn 0;\n\nout_put_vdev:\n\tvfio_put_device(&vdev->vdev);\n\treturn ret;\n}\n\nstatic void vfio_pci_remove(struct pci_dev *pdev)\n{\n\tstruct vfio_pci_core_device *vdev = dev_get_drvdata(&pdev->dev);\n\n\tvfio_pci_core_unregister_device(vdev);\n\tvfio_put_device(&vdev->vdev);\n}\n\nstatic int vfio_pci_sriov_configure(struct pci_dev *pdev, int nr_virtfn)\n{\n\tstruct vfio_pci_core_device *vdev = dev_get_drvdata(&pdev->dev);\n\n\tif (!enable_sriov)\n\t\treturn -ENOENT;\n\n\treturn vfio_pci_core_sriov_configure(vdev, nr_virtfn);\n}\n\nstatic const struct pci_device_id vfio_pci_table[] = {\n\t{ PCI_DRIVER_OVERRIDE_DEVICE_VFIO(PCI_ANY_ID, PCI_ANY_ID) },  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, vfio_pci_table);\n\nstatic struct pci_driver vfio_pci_driver = {\n\t.name\t\t\t= \"vfio-pci\",\n\t.id_table\t\t= vfio_pci_table,\n\t.probe\t\t\t= vfio_pci_probe,\n\t.remove\t\t\t= vfio_pci_remove,\n\t.sriov_configure\t= vfio_pci_sriov_configure,\n\t.err_handler\t\t= &vfio_pci_core_err_handlers,\n\t.driver_managed_dma\t= true,\n};\n\nstatic void __init vfio_pci_fill_ids(void)\n{\n\tchar *p, *id;\n\tint rc;\n\n\t \n\tif (ids[0] == '\\0')\n\t\treturn;\n\n\t \n\tp = ids;\n\twhile ((id = strsep(&p, \",\"))) {\n\t\tunsigned int vendor, device, subvendor = PCI_ANY_ID,\n\t\t\tsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\n\t\tint fields;\n\n\t\tif (!strlen(id))\n\t\t\tcontinue;\n\n\t\tfields = sscanf(id, \"%x:%x:%x:%x:%x:%x\",\n\t\t\t\t&vendor, &device, &subvendor, &subdevice,\n\t\t\t\t&class, &class_mask);\n\n\t\tif (fields < 2) {\n\t\t\tpr_warn(\"invalid id string \\\"%s\\\"\\n\", id);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = pci_add_dynid(&vfio_pci_driver, vendor, device,\n\t\t\t\t   subvendor, subdevice, class, class_mask, 0);\n\t\tif (rc)\n\t\t\tpr_warn(\"failed to add dynamic id [%04x:%04x[%04x:%04x]] class %#08x/%08x (%d)\\n\",\n\t\t\t\tvendor, device, subvendor, subdevice,\n\t\t\t\tclass, class_mask, rc);\n\t\telse\n\t\t\tpr_info(\"add [%04x:%04x[%04x:%04x]] class %#08x/%08x\\n\",\n\t\t\t\tvendor, device, subvendor, subdevice,\n\t\t\t\tclass, class_mask);\n\t}\n}\n\nstatic int __init vfio_pci_init(void)\n{\n\tint ret;\n\tbool is_disable_vga = true;\n\n#ifdef CONFIG_VFIO_PCI_VGA\n\tis_disable_vga = disable_vga;\n#endif\n\n\tvfio_pci_core_set_params(nointxmask, is_disable_vga, disable_idle_d3);\n\n\t \n\tret = pci_register_driver(&vfio_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tvfio_pci_fill_ids();\n\n\tif (disable_denylist)\n\t\tpr_warn(\"device denylist disabled.\\n\");\n\n\treturn 0;\n}\nmodule_init(vfio_pci_init);\n\nstatic void __exit vfio_pci_cleanup(void)\n{\n\tpci_unregister_driver(&vfio_pci_driver);\n}\nmodule_exit(vfio_pci_cleanup);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}