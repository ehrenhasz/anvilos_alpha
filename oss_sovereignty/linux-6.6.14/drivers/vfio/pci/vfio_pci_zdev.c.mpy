{
  "module_name": "vfio_pci_zdev.c",
  "hash_id": "6d066b64a546b1f8216763bff2f571eaf769268c852b039263933fcc9f2bc93a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci_zdev.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/vfio.h>\n#include <linux/vfio_zdev.h>\n#include <linux/kvm_host.h>\n#include <asm/pci_clp.h>\n#include <asm/pci_io.h>\n\n#include \"vfio_pci_priv.h\"\n\n \nstatic int zpci_base_cap(struct zpci_dev *zdev, struct vfio_info_cap *caps)\n{\n\tstruct vfio_device_info_cap_zpci_base cap = {\n\t\t.header.id = VFIO_DEVICE_INFO_CAP_ZPCI_BASE,\n\t\t.header.version = 2,\n\t\t.start_dma = zdev->start_dma,\n\t\t.end_dma = zdev->end_dma,\n\t\t.pchid = zdev->pchid,\n\t\t.vfn = zdev->vfn,\n\t\t.fmb_length = zdev->fmb_length,\n\t\t.pft = zdev->pft,\n\t\t.gid = zdev->pfgid,\n\t\t.fh = zdev->fh\n\t};\n\n\treturn vfio_info_add_capability(caps, &cap.header, sizeof(cap));\n}\n\n \nstatic int zpci_group_cap(struct zpci_dev *zdev, struct vfio_info_cap *caps)\n{\n\tstruct vfio_device_info_cap_zpci_group cap = {\n\t\t.header.id = VFIO_DEVICE_INFO_CAP_ZPCI_GROUP,\n\t\t.header.version = 2,\n\t\t.dasm = zdev->dma_mask,\n\t\t.msi_addr = zdev->msi_addr,\n\t\t.flags = VFIO_DEVICE_INFO_ZPCI_FLAG_REFRESH,\n\t\t.mui = zdev->fmb_update,\n\t\t.noi = zdev->max_msi,\n\t\t.maxstbl = ZPCI_MAX_WRITE_SIZE,\n\t\t.version = zdev->version,\n\t\t.reserved = 0,\n\t\t.imaxstbl = zdev->maxstbl\n\t};\n\n\treturn vfio_info_add_capability(caps, &cap.header, sizeof(cap));\n}\n\n \nstatic int zpci_util_cap(struct zpci_dev *zdev, struct vfio_info_cap *caps)\n{\n\tstruct vfio_device_info_cap_zpci_util *cap;\n\tint cap_size = sizeof(*cap) + CLP_UTIL_STR_LEN;\n\tint ret;\n\n\tcap = kmalloc(cap_size, GFP_KERNEL);\n\tif (!cap)\n\t\treturn -ENOMEM;\n\n\tcap->header.id = VFIO_DEVICE_INFO_CAP_ZPCI_UTIL;\n\tcap->header.version = 1;\n\tcap->size = CLP_UTIL_STR_LEN;\n\tmemcpy(cap->util_str, zdev->util_str, cap->size);\n\n\tret = vfio_info_add_capability(caps, &cap->header, cap_size);\n\n\tkfree(cap);\n\n\treturn ret;\n}\n\n \nstatic int zpci_pfip_cap(struct zpci_dev *zdev, struct vfio_info_cap *caps)\n{\n\tstruct vfio_device_info_cap_zpci_pfip *cap;\n\tint cap_size = sizeof(*cap) + CLP_PFIP_NR_SEGMENTS;\n\tint ret;\n\n\tcap = kmalloc(cap_size, GFP_KERNEL);\n\tif (!cap)\n\t\treturn -ENOMEM;\n\n\tcap->header.id = VFIO_DEVICE_INFO_CAP_ZPCI_PFIP;\n\tcap->header.version = 1;\n\tcap->size = CLP_PFIP_NR_SEGMENTS;\n\tmemcpy(cap->pfip, zdev->pfip, cap->size);\n\n\tret = vfio_info_add_capability(caps, &cap->header, cap_size);\n\n\tkfree(cap);\n\n\treturn ret;\n}\n\n \nint vfio_pci_info_zdev_add_caps(struct vfio_pci_core_device *vdev,\n\t\t\t\tstruct vfio_info_cap *caps)\n{\n\tstruct zpci_dev *zdev = to_zpci(vdev->pdev);\n\tint ret;\n\n\tif (!zdev)\n\t\treturn -ENODEV;\n\n\tret = zpci_base_cap(zdev, caps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zpci_group_cap(zdev, caps);\n\tif (ret)\n\t\treturn ret;\n\n\tif (zdev->util_str_avail) {\n\t\tret = zpci_util_cap(zdev, caps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = zpci_pfip_cap(zdev, caps);\n\n\treturn ret;\n}\n\nint vfio_pci_zdev_open_device(struct vfio_pci_core_device *vdev)\n{\n\tstruct zpci_dev *zdev = to_zpci(vdev->pdev);\n\n\tif (!zdev)\n\t\treturn -ENODEV;\n\n\tif (!vdev->vdev.kvm)\n\t\treturn 0;\n\n\tif (zpci_kvm_hook.kvm_register)\n\t\treturn zpci_kvm_hook.kvm_register(zdev, vdev->vdev.kvm);\n\n\treturn -ENOENT;\n}\n\nvoid vfio_pci_zdev_close_device(struct vfio_pci_core_device *vdev)\n{\n\tstruct zpci_dev *zdev = to_zpci(vdev->pdev);\n\n\tif (!zdev || !vdev->vdev.kvm)\n\t\treturn;\n\n\tif (zpci_kvm_hook.kvm_unregister)\n\t\tzpci_kvm_hook.kvm_unregister(zdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}