{
  "module_name": "vfio_pci_intrs.c",
  "hash_id": "3ae3f996fc4fae21009a87a2773275a5a8bb0e9e46a86ce7b844ab715b91b552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/pci/vfio_pci_intrs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/eventfd.h>\n#include <linux/msi.h>\n#include <linux/pci.h>\n#include <linux/file.h>\n#include <linux/vfio.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n\n#include \"vfio_pci_priv.h\"\n\nstruct vfio_pci_irq_ctx {\n\tstruct eventfd_ctx\t*trigger;\n\tstruct virqfd\t\t*unmask;\n\tstruct virqfd\t\t*mask;\n\tchar\t\t\t*name;\n\tbool\t\t\tmasked;\n\tstruct irq_bypass_producer\tproducer;\n};\n\nstatic bool irq_is(struct vfio_pci_core_device *vdev, int type)\n{\n\treturn vdev->irq_type == type;\n}\n\nstatic bool is_intx(struct vfio_pci_core_device *vdev)\n{\n\treturn vdev->irq_type == VFIO_PCI_INTX_IRQ_INDEX;\n}\n\nstatic bool is_irq_none(struct vfio_pci_core_device *vdev)\n{\n\treturn !(vdev->irq_type == VFIO_PCI_INTX_IRQ_INDEX ||\n\t\t vdev->irq_type == VFIO_PCI_MSI_IRQ_INDEX ||\n\t\t vdev->irq_type == VFIO_PCI_MSIX_IRQ_INDEX);\n}\n\nstatic\nstruct vfio_pci_irq_ctx *vfio_irq_ctx_get(struct vfio_pci_core_device *vdev,\n\t\t\t\t\t  unsigned long index)\n{\n\treturn xa_load(&vdev->ctx, index);\n}\n\nstatic void vfio_irq_ctx_free(struct vfio_pci_core_device *vdev,\n\t\t\t      struct vfio_pci_irq_ctx *ctx, unsigned long index)\n{\n\txa_erase(&vdev->ctx, index);\n\tkfree(ctx);\n}\n\nstatic struct vfio_pci_irq_ctx *\nvfio_irq_ctx_alloc(struct vfio_pci_core_device *vdev, unsigned long index)\n{\n\tstruct vfio_pci_irq_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tret = xa_insert(&vdev->ctx, index, ctx, GFP_KERNEL_ACCOUNT);\n\tif (ret) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\treturn ctx;\n}\n\n \nstatic void vfio_send_intx_eventfd(void *opaque, void *unused)\n{\n\tstruct vfio_pci_core_device *vdev = opaque;\n\n\tif (likely(is_intx(vdev) && !vdev->virq_disabled)) {\n\t\tstruct vfio_pci_irq_ctx *ctx;\n\n\t\tctx = vfio_irq_ctx_get(vdev, 0);\n\t\tif (WARN_ON_ONCE(!ctx))\n\t\t\treturn;\n\t\teventfd_signal(ctx->trigger, 1);\n\t}\n}\n\n \nbool vfio_pci_intx_mask(struct vfio_pci_core_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tunsigned long flags;\n\tbool masked_changed = false;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\t \n\tif (unlikely(!is_intx(vdev))) {\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t\tgoto out_unlock;\n\t}\n\n\tctx = vfio_irq_ctx_get(vdev, 0);\n\tif (WARN_ON_ONCE(!ctx))\n\t\tgoto out_unlock;\n\n\tif (!ctx->masked) {\n\t\t \n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t\telse\n\t\t\tdisable_irq_nosync(pdev->irq);\n\n\t\tctx->masked = true;\n\t\tmasked_changed = true;\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n\treturn masked_changed;\n}\n\n \nstatic int vfio_pci_intx_unmask_handler(void *opaque, void *unused)\n{\n\tstruct vfio_pci_core_device *vdev = opaque;\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\t \n\tif (unlikely(!is_intx(vdev))) {\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 1);\n\t\tgoto out_unlock;\n\t}\n\n\tctx = vfio_irq_ctx_get(vdev, 0);\n\tif (WARN_ON_ONCE(!ctx))\n\t\tgoto out_unlock;\n\n\tif (ctx->masked && !vdev->virq_disabled) {\n\t\t \n\t\tif (vdev->pci_2_3) {\n\t\t\tif (!pci_check_and_unmask_intx(pdev))\n\t\t\t\tret = 1;\n\t\t} else\n\t\t\tenable_irq(pdev->irq);\n\n\t\tctx->masked = (ret > 0);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n\n\treturn ret;\n}\n\nvoid vfio_pci_intx_unmask(struct vfio_pci_core_device *vdev)\n{\n\tif (vfio_pci_intx_unmask_handler(vdev, NULL) > 0)\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n}\n\nstatic irqreturn_t vfio_intx_handler(int irq, void *dev_id)\n{\n\tstruct vfio_pci_core_device *vdev = dev_id;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tunsigned long flags;\n\tint ret = IRQ_NONE;\n\n\tctx = vfio_irq_ctx_get(vdev, 0);\n\tif (WARN_ON_ONCE(!ctx))\n\t\treturn ret;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\tif (!vdev->pci_2_3) {\n\t\tdisable_irq_nosync(vdev->pdev->irq);\n\t\tctx->masked = true;\n\t\tret = IRQ_HANDLED;\n\t} else if (!ctx->masked &&   \n\t\t   pci_check_and_mask_intx(vdev->pdev)) {\n\t\tctx->masked = true;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n\n\tif (ret == IRQ_HANDLED)\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n\n\treturn ret;\n}\n\nstatic int vfio_intx_enable(struct vfio_pci_core_device *vdev)\n{\n\tstruct vfio_pci_irq_ctx *ctx;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tif (!vdev->pdev->irq)\n\t\treturn -ENODEV;\n\n\tctx = vfio_irq_ctx_alloc(vdev, 0);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t \n\tctx->masked = vdev->virq_disabled;\n\tif (vdev->pci_2_3)\n\t\tpci_intx(vdev->pdev, !ctx->masked);\n\n\tvdev->irq_type = VFIO_PCI_INTX_IRQ_INDEX;\n\n\treturn 0;\n}\n\nstatic int vfio_intx_set_signal(struct vfio_pci_core_device *vdev, int fd)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned long irqflags = IRQF_SHARED;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tstruct eventfd_ctx *trigger;\n\tunsigned long flags;\n\tint ret;\n\n\tctx = vfio_irq_ctx_get(vdev, 0);\n\tif (WARN_ON_ONCE(!ctx))\n\t\treturn -EINVAL;\n\n\tif (ctx->trigger) {\n\t\tfree_irq(pdev->irq, vdev);\n\t\tkfree(ctx->name);\n\t\teventfd_ctx_put(ctx->trigger);\n\t\tctx->trigger = NULL;\n\t}\n\n\tif (fd < 0)  \n\t\treturn 0;\n\n\tctx->name = kasprintf(GFP_KERNEL_ACCOUNT, \"vfio-intx(%s)\",\n\t\t\t      pci_name(pdev));\n\tif (!ctx->name)\n\t\treturn -ENOMEM;\n\n\ttrigger = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(trigger)) {\n\t\tkfree(ctx->name);\n\t\treturn PTR_ERR(trigger);\n\t}\n\n\tctx->trigger = trigger;\n\n\tif (!vdev->pci_2_3)\n\t\tirqflags = 0;\n\n\tret = request_irq(pdev->irq, vfio_intx_handler,\n\t\t\t  irqflags, ctx->name, vdev);\n\tif (ret) {\n\t\tctx->trigger = NULL;\n\t\tkfree(ctx->name);\n\t\teventfd_ctx_put(trigger);\n\t\treturn ret;\n\t}\n\n\t \n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\tif (!vdev->pci_2_3 && ctx->masked)\n\t\tdisable_irq_nosync(pdev->irq);\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n\n\treturn 0;\n}\n\nstatic void vfio_intx_disable(struct vfio_pci_core_device *vdev)\n{\n\tstruct vfio_pci_irq_ctx *ctx;\n\n\tctx = vfio_irq_ctx_get(vdev, 0);\n\tWARN_ON_ONCE(!ctx);\n\tif (ctx) {\n\t\tvfio_virqfd_disable(&ctx->unmask);\n\t\tvfio_virqfd_disable(&ctx->mask);\n\t}\n\tvfio_intx_set_signal(vdev, -1);\n\tvdev->irq_type = VFIO_PCI_NUM_IRQS;\n\tvfio_irq_ctx_free(vdev, ctx, 0);\n}\n\n \nstatic irqreturn_t vfio_msihandler(int irq, void *arg)\n{\n\tstruct eventfd_ctx *trigger = arg;\n\n\teventfd_signal(trigger, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic int vfio_msi_enable(struct vfio_pci_core_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\tu16 cmd;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\t \n\tcmd = vfio_pci_memory_lock_and_enable(vdev);\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\t\treturn ret;\n\t}\n\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t \n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vfio_msi_alloc_irq(struct vfio_pci_core_device *vdev,\n\t\t\t      unsigned int vector, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct msi_map map;\n\tint irq;\n\tu16 cmd;\n\n\tirq = pci_irq_vector(pdev, vector);\n\tif (WARN_ON_ONCE(irq == 0))\n\t\treturn -EINVAL;\n\tif (irq > 0 || !msix || !vdev->has_dyn_msix)\n\t\treturn irq;\n\n\tcmd = vfio_pci_memory_lock_and_enable(vdev);\n\tmap = pci_msix_alloc_irq_at(pdev, vector, NULL);\n\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\n\treturn map.index < 0 ? map.index : map.virq;\n}\n\nstatic int vfio_msi_set_vector_signal(struct vfio_pci_core_device *vdev,\n\t\t\t\t      unsigned int vector, int fd, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tstruct eventfd_ctx *trigger;\n\tint irq = -EINVAL, ret;\n\tu16 cmd;\n\n\tctx = vfio_irq_ctx_get(vdev, vector);\n\n\tif (ctx) {\n\t\tirq_bypass_unregister_producer(&ctx->producer);\n\t\tirq = pci_irq_vector(pdev, vector);\n\t\tcmd = vfio_pci_memory_lock_and_enable(vdev);\n\t\tfree_irq(irq, ctx->trigger);\n\t\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\t\t \n\t\tkfree(ctx->name);\n\t\teventfd_ctx_put(ctx->trigger);\n\t\tvfio_irq_ctx_free(vdev, ctx, vector);\n\t}\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (irq == -EINVAL) {\n\t\t \n\t\tirq = vfio_msi_alloc_irq(vdev, vector, msix);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t}\n\n\tctx = vfio_irq_ctx_alloc(vdev, vector);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->name = kasprintf(GFP_KERNEL_ACCOUNT, \"vfio-msi%s[%d](%s)\",\n\t\t\t      msix ? \"x\" : \"\", vector, pci_name(pdev));\n\tif (!ctx->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_ctx;\n\t}\n\n\ttrigger = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(trigger)) {\n\t\tret = PTR_ERR(trigger);\n\t\tgoto out_free_name;\n\t}\n\n\t \n\tcmd = vfio_pci_memory_lock_and_enable(vdev);\n\tif (msix) {\n\t\tstruct msi_msg msg;\n\n\t\tget_cached_msi_msg(irq, &msg);\n\t\tpci_write_msi_msg(irq, &msg);\n\t}\n\n\tret = request_irq(irq, vfio_msihandler, 0, ctx->name, trigger);\n\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\tif (ret)\n\t\tgoto out_put_eventfd_ctx;\n\n\tctx->producer.token = trigger;\n\tctx->producer.irq = irq;\n\tret = irq_bypass_register_producer(&ctx->producer);\n\tif (unlikely(ret)) {\n\t\tdev_info(&pdev->dev,\n\t\t\"irq bypass producer (token %p) registration fails: %d\\n\",\n\t\tctx->producer.token, ret);\n\n\t\tctx->producer.token = NULL;\n\t}\n\tctx->trigger = trigger;\n\n\treturn 0;\n\nout_put_eventfd_ctx:\n\teventfd_ctx_put(trigger);\nout_free_name:\n\tkfree(ctx->name);\nout_free_ctx:\n\tvfio_irq_ctx_free(vdev, ctx, vector);\n\treturn ret;\n}\n\nstatic int vfio_msi_set_block(struct vfio_pci_core_device *vdev, unsigned start,\n\t\t\t      unsigned count, int32_t *fds, bool msix)\n{\n\tunsigned int i, j;\n\tint ret = 0;\n\n\tfor (i = 0, j = start; i < count && !ret; i++, j++) {\n\t\tint fd = fds ? fds[i] : -1;\n\t\tret = vfio_msi_set_vector_signal(vdev, j, fd, msix);\n\t}\n\n\tif (ret) {\n\t\tfor (i = start; i < j; i++)\n\t\t\tvfio_msi_set_vector_signal(vdev, i, -1, msix);\n\t}\n\n\treturn ret;\n}\n\nstatic void vfio_msi_disable(struct vfio_pci_core_device *vdev, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tstruct vfio_pci_irq_ctx *ctx;\n\tunsigned long i;\n\tu16 cmd;\n\n\txa_for_each(&vdev->ctx, i, ctx) {\n\t\tvfio_virqfd_disable(&ctx->unmask);\n\t\tvfio_virqfd_disable(&ctx->mask);\n\t\tvfio_msi_set_vector_signal(vdev, i, -1, msix);\n\t}\n\n\tcmd = vfio_pci_memory_lock_and_enable(vdev);\n\tpci_free_irq_vectors(pdev);\n\tvfio_pci_memory_unlock_and_restore(vdev, cmd);\n\n\t \n\tif (vdev->nointx)\n\t\tpci_intx(pdev, 0);\n\n\tvdev->irq_type = VFIO_PCI_NUM_IRQS;\n}\n\n \nstatic int vfio_pci_set_intx_unmask(struct vfio_pci_core_device *vdev,\n\t\t\t\t    unsigned index, unsigned start,\n\t\t\t\t    unsigned count, uint32_t flags, void *data)\n{\n\tif (!is_intx(vdev) || start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_pci_intx_unmask(vdev);\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t unmask = *(uint8_t *)data;\n\t\tif (unmask)\n\t\t\tvfio_pci_intx_unmask(vdev);\n\t} else if (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tstruct vfio_pci_irq_ctx *ctx = vfio_irq_ctx_get(vdev, 0);\n\t\tint32_t fd = *(int32_t *)data;\n\n\t\tif (WARN_ON_ONCE(!ctx))\n\t\t\treturn -EINVAL;\n\t\tif (fd >= 0)\n\t\t\treturn vfio_virqfd_enable((void *) vdev,\n\t\t\t\t\t\t  vfio_pci_intx_unmask_handler,\n\t\t\t\t\t\t  vfio_send_intx_eventfd, NULL,\n\t\t\t\t\t\t  &ctx->unmask, fd);\n\n\t\tvfio_virqfd_disable(&ctx->unmask);\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_pci_set_intx_mask(struct vfio_pci_core_device *vdev,\n\t\t\t\t  unsigned index, unsigned start,\n\t\t\t\t  unsigned count, uint32_t flags, void *data)\n{\n\tif (!is_intx(vdev) || start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_pci_intx_mask(vdev);\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t mask = *(uint8_t *)data;\n\t\tif (mask)\n\t\t\tvfio_pci_intx_mask(vdev);\n\t} else if (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\treturn -ENOTTY;  \n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_pci_set_intx_trigger(struct vfio_pci_core_device *vdev,\n\t\t\t\t     unsigned index, unsigned start,\n\t\t\t\t     unsigned count, uint32_t flags, void *data)\n{\n\tif (is_intx(vdev) && !count && (flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\tvfio_intx_disable(vdev);\n\t\treturn 0;\n\t}\n\n\tif (!(is_intx(vdev) || is_irq_none(vdev)) || start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t fd = *(int32_t *)data;\n\t\tint ret;\n\n\t\tif (is_intx(vdev))\n\t\t\treturn vfio_intx_set_signal(vdev, fd);\n\n\t\tret = vfio_intx_enable(vdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vfio_intx_set_signal(vdev, fd);\n\t\tif (ret)\n\t\t\tvfio_intx_disable(vdev);\n\n\t\treturn ret;\n\t}\n\n\tif (!is_intx(vdev))\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t trigger = *(uint8_t *)data;\n\t\tif (trigger)\n\t\t\tvfio_send_intx_eventfd(vdev, NULL);\n\t}\n\treturn 0;\n}\n\nstatic int vfio_pci_set_msi_trigger(struct vfio_pci_core_device *vdev,\n\t\t\t\t    unsigned index, unsigned start,\n\t\t\t\t    unsigned count, uint32_t flags, void *data)\n{\n\tstruct vfio_pci_irq_ctx *ctx;\n\tunsigned int i;\n\tbool msix = (index == VFIO_PCI_MSIX_IRQ_INDEX) ? true : false;\n\n\tif (irq_is(vdev, index) && !count && (flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\tvfio_msi_disable(vdev, msix);\n\t\treturn 0;\n\t}\n\n\tif (!(irq_is(vdev, index) || is_irq_none(vdev)))\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t *fds = data;\n\t\tint ret;\n\n\t\tif (vdev->irq_type == index)\n\t\t\treturn vfio_msi_set_block(vdev, start, count,\n\t\t\t\t\t\t  fds, msix);\n\n\t\tret = vfio_msi_enable(vdev, start + count, msix);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vfio_msi_set_block(vdev, start, count, fds, msix);\n\t\tif (ret)\n\t\t\tvfio_msi_disable(vdev, msix);\n\n\t\treturn ret;\n\t}\n\n\tif (!irq_is(vdev, index))\n\t\treturn -EINVAL;\n\n\tfor (i = start; i < start + count; i++) {\n\t\tctx = vfio_irq_ctx_get(vdev, i);\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\t\teventfd_signal(ctx->trigger, 1);\n\t\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\t\tuint8_t *bools = data;\n\t\t\tif (bools[i - start])\n\t\t\t\teventfd_signal(ctx->trigger, 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vfio_pci_set_ctx_trigger_single(struct eventfd_ctx **ctx,\n\t\t\t\t\t   unsigned int count, uint32_t flags,\n\t\t\t\t\t   void *data)\n{\n\t \n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tif (*ctx) {\n\t\t\tif (count) {\n\t\t\t\teventfd_signal(*ctx, 1);\n\t\t\t} else {\n\t\t\t\teventfd_ctx_put(*ctx);\n\t\t\t\t*ctx = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t trigger;\n\n\t\tif (!count)\n\t\t\treturn -EINVAL;\n\n\t\ttrigger = *(uint8_t *)data;\n\t\tif (trigger && *ctx)\n\t\t\teventfd_signal(*ctx, 1);\n\n\t\treturn 0;\n\t} else if (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t fd;\n\n\t\tif (!count)\n\t\t\treturn -EINVAL;\n\n\t\tfd = *(int32_t *)data;\n\t\tif (fd == -1) {\n\t\t\tif (*ctx)\n\t\t\t\teventfd_ctx_put(*ctx);\n\t\t\t*ctx = NULL;\n\t\t} else if (fd >= 0) {\n\t\t\tstruct eventfd_ctx *efdctx;\n\n\t\t\tefdctx = eventfd_ctx_fdget(fd);\n\t\t\tif (IS_ERR(efdctx))\n\t\t\t\treturn PTR_ERR(efdctx);\n\n\t\t\tif (*ctx)\n\t\t\t\teventfd_ctx_put(*ctx);\n\n\t\t\t*ctx = efdctx;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vfio_pci_set_err_trigger(struct vfio_pci_core_device *vdev,\n\t\t\t\t    unsigned index, unsigned start,\n\t\t\t\t    unsigned count, uint32_t flags, void *data)\n{\n\tif (index != VFIO_PCI_ERR_IRQ_INDEX || start != 0 || count > 1)\n\t\treturn -EINVAL;\n\n\treturn vfio_pci_set_ctx_trigger_single(&vdev->err_trigger,\n\t\t\t\t\t       count, flags, data);\n}\n\nstatic int vfio_pci_set_req_trigger(struct vfio_pci_core_device *vdev,\n\t\t\t\t    unsigned index, unsigned start,\n\t\t\t\t    unsigned count, uint32_t flags, void *data)\n{\n\tif (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count > 1)\n\t\treturn -EINVAL;\n\n\treturn vfio_pci_set_ctx_trigger_single(&vdev->req_trigger,\n\t\t\t\t\t       count, flags, data);\n}\n\nint vfio_pci_set_irqs_ioctl(struct vfio_pci_core_device *vdev, uint32_t flags,\n\t\t\t    unsigned index, unsigned start, unsigned count,\n\t\t\t    void *data)\n{\n\tint (*func)(struct vfio_pci_core_device *vdev, unsigned index,\n\t\t    unsigned start, unsigned count, uint32_t flags,\n\t\t    void *data) = NULL;\n\n\tswitch (index) {\n\tcase VFIO_PCI_INTX_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_MASK:\n\t\t\tfunc = vfio_pci_set_intx_mask;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_UNMASK:\n\t\t\tfunc = vfio_pci_set_intx_unmask;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tfunc = vfio_pci_set_intx_trigger;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VFIO_PCI_MSI_IRQ_INDEX:\n\tcase VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_MASK:\n\t\tcase VFIO_IRQ_SET_ACTION_UNMASK:\n\t\t\t \n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tfunc = vfio_pci_set_msi_trigger;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tfunc = vfio_pci_set_err_trigger;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tfunc = vfio_pci_set_req_trigger;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!func)\n\t\treturn -ENOTTY;\n\n\treturn func(vdev, index, start, count, flags, data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}