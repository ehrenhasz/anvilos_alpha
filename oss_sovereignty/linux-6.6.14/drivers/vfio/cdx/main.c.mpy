{
  "module_name": "main.c",
  "hash_id": "a1ca77241bca779984a625fdd142a1e2ff532c3964f59df8699bb31657c99b7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/cdx/main.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/cdx/cdx_bus.h>\n\n#include \"private.h\"\n\nstatic int vfio_cdx_open_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_cdx_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_cdx_device, vdev);\n\tstruct cdx_device *cdx_dev = to_cdx_device(core_vdev->dev);\n\tint count = cdx_dev->res_count;\n\tint i;\n\n\tvdev->regions = kcalloc(count, sizeof(struct vfio_cdx_region),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\tif (!vdev->regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct resource *res = &cdx_dev->res[i];\n\n\t\tvdev->regions[i].addr = res->start;\n\t\tvdev->regions[i].size = resource_size(res);\n\t\tvdev->regions[i].type = res->flags;\n\t\t \n\t\tif (!(vdev->regions[i].addr & ~PAGE_MASK) &&\n\t\t    !(vdev->regions[i].size & ~PAGE_MASK))\n\t\t\tvdev->regions[i].flags |=\n\t\t\t\t\tVFIO_REGION_INFO_FLAG_MMAP;\n\t\tvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_READ;\n\t\tif (!(cdx_dev->res[i].flags & IORESOURCE_READONLY))\n\t\t\tvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_WRITE;\n\t}\n\n\treturn 0;\n}\n\nstatic void vfio_cdx_close_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_cdx_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_cdx_device, vdev);\n\n\tkfree(vdev->regions);\n\tcdx_dev_reset(core_vdev->dev);\n}\n\nstatic int vfio_cdx_ioctl_get_info(struct vfio_cdx_device *vdev,\n\t\t\t\t   struct vfio_device_info __user *arg)\n{\n\tunsigned long minsz = offsetofend(struct vfio_device_info, num_irqs);\n\tstruct cdx_device *cdx_dev = to_cdx_device(vdev->vdev.dev);\n\tstruct vfio_device_info info;\n\n\tif (copy_from_user(&info, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (info.argsz < minsz)\n\t\treturn -EINVAL;\n\n\tinfo.flags = VFIO_DEVICE_FLAGS_CDX;\n\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\tinfo.num_regions = cdx_dev->res_count;\n\tinfo.num_irqs = 0;\n\n\treturn copy_to_user(arg, &info, minsz) ? -EFAULT : 0;\n}\n\nstatic int vfio_cdx_ioctl_get_region_info(struct vfio_cdx_device *vdev,\n\t\t\t\t\t  struct vfio_region_info __user *arg)\n{\n\tunsigned long minsz = offsetofend(struct vfio_region_info, offset);\n\tstruct cdx_device *cdx_dev = to_cdx_device(vdev->vdev.dev);\n\tstruct vfio_region_info info;\n\n\tif (copy_from_user(&info, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (info.argsz < minsz)\n\t\treturn -EINVAL;\n\n\tif (info.index >= cdx_dev->res_count)\n\t\treturn -EINVAL;\n\n\t \n\tinfo.offset = vfio_cdx_index_to_offset(info.index);\n\tinfo.size = vdev->regions[info.index].size;\n\tinfo.flags = vdev->regions[info.index].flags;\n\n\treturn copy_to_user(arg, &info, minsz) ? -EFAULT : 0;\n}\n\nstatic long vfio_cdx_ioctl(struct vfio_device *core_vdev,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_cdx_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_cdx_device, vdev);\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t\treturn vfio_cdx_ioctl_get_info(vdev, uarg);\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t\treturn vfio_cdx_ioctl_get_region_info(vdev, uarg);\n\tcase VFIO_DEVICE_RESET:\n\t\treturn cdx_dev_reset(core_vdev->dev);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int vfio_cdx_mmap_mmio(struct vfio_cdx_region region,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tu64 size = vma->vm_end - vma->vm_start;\n\tu64 pgoff, base;\n\n\tpgoff = vma->vm_pgoff &\n\t\t((1U << (VFIO_CDX_OFFSET_SHIFT - PAGE_SHIFT)) - 1);\n\tbase = pgoff << PAGE_SHIFT;\n\n\tif (base + size > region.size)\n\t\treturn -EINVAL;\n\n\tvma->vm_pgoff = (region.addr >> PAGE_SHIFT) + pgoff;\n\tvma->vm_page_prot = pgprot_device(vma->vm_page_prot);\n\n\treturn io_remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t\t  size, vma->vm_page_prot);\n}\n\nstatic int vfio_cdx_mmap(struct vfio_device *core_vdev,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct vfio_cdx_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_cdx_device, vdev);\n\tstruct cdx_device *cdx_dev = to_cdx_device(core_vdev->dev);\n\tunsigned int index;\n\n\tindex = vma->vm_pgoff >> (VFIO_CDX_OFFSET_SHIFT - PAGE_SHIFT);\n\n\tif (index >= cdx_dev->res_count)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_MMAP))\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ) &&\n\t    (vma->vm_flags & VM_READ))\n\t\treturn -EPERM;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE) &&\n\t    (vma->vm_flags & VM_WRITE))\n\t\treturn -EPERM;\n\n\treturn vfio_cdx_mmap_mmio(vdev->regions[index], vma);\n}\n\nstatic const struct vfio_device_ops vfio_cdx_ops = {\n\t.name\t\t= \"vfio-cdx\",\n\t.open_device\t= vfio_cdx_open_device,\n\t.close_device\t= vfio_cdx_close_device,\n\t.ioctl\t\t= vfio_cdx_ioctl,\n\t.mmap\t\t= vfio_cdx_mmap,\n\t.bind_iommufd\t= vfio_iommufd_physical_bind,\n\t.unbind_iommufd\t= vfio_iommufd_physical_unbind,\n\t.attach_ioas\t= vfio_iommufd_physical_attach_ioas,\n};\n\nstatic int vfio_cdx_probe(struct cdx_device *cdx_dev)\n{\n\tstruct vfio_cdx_device *vdev;\n\tstruct device *dev = &cdx_dev->dev;\n\tint ret;\n\n\tvdev = vfio_alloc_device(vfio_cdx_device, vdev, dev,\n\t\t\t\t &vfio_cdx_ops);\n\tif (IS_ERR(vdev))\n\t\treturn PTR_ERR(vdev);\n\n\tret = vfio_register_group_dev(&vdev->vdev);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tdev_set_drvdata(dev, vdev);\n\treturn 0;\n\nout_uninit:\n\tvfio_put_device(&vdev->vdev);\n\treturn ret;\n}\n\nstatic int vfio_cdx_remove(struct cdx_device *cdx_dev)\n{\n\tstruct device *dev = &cdx_dev->dev;\n\tstruct vfio_cdx_device *vdev = dev_get_drvdata(dev);\n\n\tvfio_unregister_group_dev(&vdev->vdev);\n\tvfio_put_device(&vdev->vdev);\n\n\treturn 0;\n}\n\nstatic const struct cdx_device_id vfio_cdx_table[] = {\n\t{ CDX_DEVICE_DRIVER_OVERRIDE(CDX_ANY_ID, CDX_ANY_ID,\n\t\t\t\t     CDX_ID_F_VFIO_DRIVER_OVERRIDE) },  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(cdx, vfio_cdx_table);\n\nstatic struct cdx_driver vfio_cdx_driver = {\n\t.probe\t\t= vfio_cdx_probe,\n\t.remove\t\t= vfio_cdx_remove,\n\t.match_id_table\t= vfio_cdx_table,\n\t.driver\t= {\n\t\t.name\t= \"vfio-cdx\",\n\t},\n\t.driver_managed_dma = true,\n};\n\nmodule_driver(vfio_cdx_driver, cdx_driver_register, cdx_driver_unregister);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VFIO for CDX devices - User Level meta-driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}