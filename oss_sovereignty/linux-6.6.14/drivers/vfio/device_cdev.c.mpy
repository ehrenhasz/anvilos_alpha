{
  "module_name": "device_cdev.c",
  "hash_id": "328bbe44474a14d4cc6e45d87645f7a112f56b34ff61c9d8b1843e56e815d02b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/device_cdev.c",
  "human_readable_source": "\n \n#include <linux/vfio.h>\n#include <linux/iommufd.h>\n\n#include \"vfio.h\"\n\nstatic dev_t device_devt;\n\nvoid vfio_init_device_cdev(struct vfio_device *device)\n{\n\tdevice->device.devt = MKDEV(MAJOR(device_devt), device->index);\n\tcdev_init(&device->cdev, &vfio_device_fops);\n\tdevice->cdev.owner = THIS_MODULE;\n}\n\n \nint vfio_device_fops_cdev_open(struct inode *inode, struct file *filep)\n{\n\tstruct vfio_device *device = container_of(inode->i_cdev,\n\t\t\t\t\t\t  struct vfio_device, cdev);\n\tstruct vfio_device_file *df;\n\tint ret;\n\n\t \n\tif (!vfio_device_try_get_registration(device))\n\t\treturn -ENODEV;\n\n\tdf = vfio_allocate_device_file(device);\n\tif (IS_ERR(df)) {\n\t\tret = PTR_ERR(df);\n\t\tgoto err_put_registration;\n\t}\n\n\tfilep->private_data = df;\n\n\treturn 0;\n\nerr_put_registration:\n\tvfio_device_put_registration(device);\n\treturn ret;\n}\n\nstatic void vfio_df_get_kvm_safe(struct vfio_device_file *df)\n{\n\tspin_lock(&df->kvm_ref_lock);\n\tvfio_device_get_kvm_safe(df->device, df->kvm);\n\tspin_unlock(&df->kvm_ref_lock);\n}\n\nlong vfio_df_ioctl_bind_iommufd(struct vfio_device_file *df,\n\t\t\t\tstruct vfio_device_bind_iommufd __user *arg)\n{\n\tstruct vfio_device *device = df->device;\n\tstruct vfio_device_bind_iommufd bind;\n\tunsigned long minsz;\n\tint ret;\n\n\tstatic_assert(__same_type(arg->out_devid, df->devid));\n\n\tminsz = offsetofend(struct vfio_device_bind_iommufd, out_devid);\n\n\tif (copy_from_user(&bind, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (bind.argsz < minsz || bind.flags || bind.iommufd < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (df->group)\n\t\treturn -EINVAL;\n\n\tret = vfio_device_block_group(device);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&device->dev_set->lock);\n\t \n\tif (df->access_granted) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tdf->iommufd = iommufd_ctx_from_fd(bind.iommufd);\n\tif (IS_ERR(df->iommufd)) {\n\t\tret = PTR_ERR(df->iommufd);\n\t\tdf->iommufd = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tvfio_df_get_kvm_safe(df);\n\n\tret = vfio_df_open(df);\n\tif (ret)\n\t\tgoto out_put_kvm;\n\n\tret = copy_to_user(&arg->out_devid, &df->devid,\n\t\t\t   sizeof(df->devid)) ? -EFAULT : 0;\n\tif (ret)\n\t\tgoto out_close_device;\n\n\tdevice->cdev_opened = true;\n\t \n\tsmp_store_release(&df->access_granted, true);\n\tmutex_unlock(&device->dev_set->lock);\n\treturn 0;\n\nout_close_device:\n\tvfio_df_close(df);\nout_put_kvm:\n\tvfio_device_put_kvm(device);\n\tiommufd_ctx_put(df->iommufd);\n\tdf->iommufd = NULL;\nout_unlock:\n\tmutex_unlock(&device->dev_set->lock);\n\tvfio_device_unblock_group(device);\n\treturn ret;\n}\n\nvoid vfio_df_unbind_iommufd(struct vfio_device_file *df)\n{\n\tstruct vfio_device *device = df->device;\n\n\t \n\tif (!df->access_granted)\n\t\treturn;\n\n\tmutex_lock(&device->dev_set->lock);\n\tvfio_df_close(df);\n\tvfio_device_put_kvm(device);\n\tiommufd_ctx_put(df->iommufd);\n\tdevice->cdev_opened = false;\n\tmutex_unlock(&device->dev_set->lock);\n\tvfio_device_unblock_group(device);\n}\n\nint vfio_df_ioctl_attach_pt(struct vfio_device_file *df,\n\t\t\t    struct vfio_device_attach_iommufd_pt __user *arg)\n{\n\tstruct vfio_device *device = df->device;\n\tstruct vfio_device_attach_iommufd_pt attach;\n\tunsigned long minsz;\n\tint ret;\n\n\tminsz = offsetofend(struct vfio_device_attach_iommufd_pt, pt_id);\n\n\tif (copy_from_user(&attach, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (attach.argsz < minsz || attach.flags)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&device->dev_set->lock);\n\tret = device->ops->attach_ioas(device, &attach.pt_id);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (copy_to_user(&arg->pt_id, &attach.pt_id, sizeof(attach.pt_id))) {\n\t\tret = -EFAULT;\n\t\tgoto out_detach;\n\t}\n\tmutex_unlock(&device->dev_set->lock);\n\n\treturn 0;\n\nout_detach:\n\tdevice->ops->detach_ioas(device);\nout_unlock:\n\tmutex_unlock(&device->dev_set->lock);\n\treturn ret;\n}\n\nint vfio_df_ioctl_detach_pt(struct vfio_device_file *df,\n\t\t\t    struct vfio_device_detach_iommufd_pt __user *arg)\n{\n\tstruct vfio_device *device = df->device;\n\tstruct vfio_device_detach_iommufd_pt detach;\n\tunsigned long minsz;\n\n\tminsz = offsetofend(struct vfio_device_detach_iommufd_pt, flags);\n\n\tif (copy_from_user(&detach, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (detach.argsz < minsz || detach.flags)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&device->dev_set->lock);\n\tdevice->ops->detach_ioas(device);\n\tmutex_unlock(&device->dev_set->lock);\n\n\treturn 0;\n}\n\nstatic char *vfio_device_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"vfio/devices/%s\", dev_name(dev));\n}\n\nint vfio_cdev_init(struct class *device_class)\n{\n\tdevice_class->devnode = vfio_device_devnode;\n\treturn alloc_chrdev_region(&device_devt, 0,\n\t\t\t\t   MINORMASK + 1, \"vfio-dev\");\n}\n\nvoid vfio_cdev_cleanup(void)\n{\n\tunregister_chrdev_region(device_devt, MINORMASK + 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}