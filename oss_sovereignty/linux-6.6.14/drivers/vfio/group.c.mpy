{
  "module_name": "group.c",
  "hash_id": "3156583a375877641a140a4c2e940af7308c0a6b8c66a27ebb665f70297b128f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/group.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/iommufd.h>\n#include <linux/anon_inodes.h>\n#include \"vfio.h\"\n\nstatic struct vfio {\n\tstruct class\t\t\t*class;\n\tstruct list_head\t\tgroup_list;\n\tstruct mutex\t\t\tgroup_lock;  \n\tstruct ida\t\t\tgroup_ida;\n\tdev_t\t\t\t\tgroup_devt;\n} vfio;\n\nstatic struct vfio_device *vfio_device_get_from_name(struct vfio_group *group,\n\t\t\t\t\t\t     char *buf)\n{\n\tstruct vfio_device *it, *device = ERR_PTR(-ENODEV);\n\n\tmutex_lock(&group->device_lock);\n\tlist_for_each_entry(it, &group->device_list, group_next) {\n\t\tint ret;\n\n\t\tif (it->ops->match) {\n\t\t\tret = it->ops->match(it, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tdevice = ERR_PTR(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = !strcmp(dev_name(it->dev), buf);\n\t\t}\n\n\t\tif (ret && vfio_device_try_get_registration(it)) {\n\t\t\tdevice = it;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&group->device_lock);\n\n\treturn device;\n}\n\n \nstatic bool vfio_group_has_iommu(struct vfio_group *group)\n{\n\tlockdep_assert_held(&group->group_lock);\n\t \n\tWARN_ON(!group->container != !group->container_users);\n\n\treturn group->container || group->iommufd;\n}\n\n \nstatic int vfio_group_ioctl_unset_container(struct vfio_group *group)\n{\n\tint ret = 0;\n\n\tmutex_lock(&group->group_lock);\n\tif (!vfio_group_has_iommu(group)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (group->container) {\n\t\tif (group->container_users != 1) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tvfio_group_detach_container(group);\n\t}\n\tif (group->iommufd) {\n\t\tiommufd_ctx_put(group->iommufd);\n\t\tgroup->iommufd = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&group->group_lock);\n\treturn ret;\n}\n\nstatic int vfio_group_ioctl_set_container(struct vfio_group *group,\n\t\t\t\t\t  int __user *arg)\n{\n\tstruct vfio_container *container;\n\tstruct iommufd_ctx *iommufd;\n\tstruct fd f;\n\tint ret;\n\tint fd;\n\n\tif (get_user(fd, arg))\n\t\treturn -EFAULT;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tmutex_lock(&group->group_lock);\n\tif (vfio_group_has_iommu(group)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!group->iommu_group) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tcontainer = vfio_container_from_file(f.file);\n\tif (container) {\n\t\tret = vfio_container_attach_group(container, group);\n\t\tgoto out_unlock;\n\t}\n\n\tiommufd = iommufd_ctx_from_file(f.file);\n\tif (!IS_ERR(iommufd)) {\n\t\tif (IS_ENABLED(CONFIG_VFIO_NOIOMMU) &&\n\t\t    group->type == VFIO_NO_IOMMU)\n\t\t\tret = iommufd_vfio_compat_set_no_iommu(iommufd);\n\t\telse\n\t\t\tret = iommufd_vfio_compat_ioas_create(iommufd);\n\n\t\tif (ret) {\n\t\t\tiommufd_ctx_put(iommufd);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tgroup->iommufd = iommufd;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = -EBADFD;\n\nout_unlock:\n\tmutex_unlock(&group->group_lock);\n\tfdput(f);\n\treturn ret;\n}\n\nstatic void vfio_device_group_get_kvm_safe(struct vfio_device *device)\n{\n\tspin_lock(&device->group->kvm_ref_lock);\n\tvfio_device_get_kvm_safe(device, device->group->kvm);\n\tspin_unlock(&device->group->kvm_ref_lock);\n}\n\nstatic int vfio_df_group_open(struct vfio_device_file *df)\n{\n\tstruct vfio_device *device = df->device;\n\tint ret;\n\n\tmutex_lock(&device->group->group_lock);\n\tif (!vfio_group_has_iommu(device->group)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&device->dev_set->lock);\n\n\t \n\tif (device->open_count == 0)\n\t\tvfio_device_group_get_kvm_safe(device);\n\n\tdf->iommufd = device->group->iommufd;\n\tif (df->iommufd && vfio_device_is_noiommu(device) && device->open_count == 0) {\n\t\t \n\t\tif (!capable(CAP_SYS_RAWIO) ||\n\t\t    vfio_iommufd_device_has_compat_ioas(device, df->iommufd))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tret = 0;\n\t\tgoto out_put_kvm;\n\t}\n\n\tret = vfio_df_open(df);\n\tif (ret)\n\t\tgoto out_put_kvm;\n\n\tif (df->iommufd && device->open_count == 1) {\n\t\tret = vfio_iommufd_compat_attach_ioas(device, df->iommufd);\n\t\tif (ret)\n\t\t\tgoto out_close_device;\n\t}\n\n\t \n\tsmp_store_release(&df->access_granted, true);\n\n\tmutex_unlock(&device->dev_set->lock);\n\tmutex_unlock(&device->group->group_lock);\n\treturn 0;\n\nout_close_device:\n\tvfio_df_close(df);\nout_put_kvm:\n\tdf->iommufd = NULL;\n\tif (device->open_count == 0)\n\t\tvfio_device_put_kvm(device);\n\tmutex_unlock(&device->dev_set->lock);\nout_unlock:\n\tmutex_unlock(&device->group->group_lock);\n\treturn ret;\n}\n\nvoid vfio_df_group_close(struct vfio_device_file *df)\n{\n\tstruct vfio_device *device = df->device;\n\n\tmutex_lock(&device->group->group_lock);\n\tmutex_lock(&device->dev_set->lock);\n\n\tvfio_df_close(df);\n\tdf->iommufd = NULL;\n\n\tif (device->open_count == 0)\n\t\tvfio_device_put_kvm(device);\n\n\tmutex_unlock(&device->dev_set->lock);\n\tmutex_unlock(&device->group->group_lock);\n}\n\nstatic struct file *vfio_device_open_file(struct vfio_device *device)\n{\n\tstruct vfio_device_file *df;\n\tstruct file *filep;\n\tint ret;\n\n\tdf = vfio_allocate_device_file(device);\n\tif (IS_ERR(df)) {\n\t\tret = PTR_ERR(df);\n\t\tgoto err_out;\n\t}\n\n\tdf->group = device->group;\n\n\tret = vfio_df_group_open(df);\n\tif (ret)\n\t\tgoto err_free;\n\n\t \n\tfilep = anon_inode_getfile(\"[vfio-device]\", &vfio_device_fops,\n\t\t\t\t   df, O_RDWR);\n\tif (IS_ERR(filep)) {\n\t\tret = PTR_ERR(filep);\n\t\tgoto err_close_device;\n\t}\n\n\t \n\tfilep->f_mode |= (FMODE_PREAD | FMODE_PWRITE);\n\n\tif (device->group->type == VFIO_NO_IOMMU)\n\t\tdev_warn(device->dev, \"vfio-noiommu device opened by user \"\n\t\t\t \"(%s:%d)\\n\", current->comm, task_pid_nr(current));\n\t \n\treturn filep;\n\nerr_close_device:\n\tvfio_df_group_close(df);\nerr_free:\n\tkfree(df);\nerr_out:\n\treturn ERR_PTR(ret);\n}\n\nstatic int vfio_group_ioctl_get_device_fd(struct vfio_group *group,\n\t\t\t\t\t  char __user *arg)\n{\n\tstruct vfio_device *device;\n\tstruct file *filep;\n\tchar *buf;\n\tint fdno;\n\tint ret;\n\n\tbuf = strndup_user(arg, PAGE_SIZE);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tdevice = vfio_device_get_from_name(group, buf);\n\tkfree(buf);\n\tif (IS_ERR(device))\n\t\treturn PTR_ERR(device);\n\n\tfdno = get_unused_fd_flags(O_CLOEXEC);\n\tif (fdno < 0) {\n\t\tret = fdno;\n\t\tgoto err_put_device;\n\t}\n\n\tfilep = vfio_device_open_file(device);\n\tif (IS_ERR(filep)) {\n\t\tret = PTR_ERR(filep);\n\t\tgoto err_put_fdno;\n\t}\n\n\tfd_install(fdno, filep);\n\treturn fdno;\n\nerr_put_fdno:\n\tput_unused_fd(fdno);\nerr_put_device:\n\tvfio_device_put_registration(device);\n\treturn ret;\n}\n\nstatic int vfio_group_ioctl_get_status(struct vfio_group *group,\n\t\t\t\t       struct vfio_group_status __user *arg)\n{\n\tunsigned long minsz = offsetofend(struct vfio_group_status, flags);\n\tstruct vfio_group_status status;\n\n\tif (copy_from_user(&status, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (status.argsz < minsz)\n\t\treturn -EINVAL;\n\n\tstatus.flags = 0;\n\n\tmutex_lock(&group->group_lock);\n\tif (!group->iommu_group) {\n\t\tmutex_unlock(&group->group_lock);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (vfio_group_has_iommu(group))\n\t\tstatus.flags |= VFIO_GROUP_FLAGS_CONTAINER_SET |\n\t\t\t\tVFIO_GROUP_FLAGS_VIABLE;\n\telse if (!iommu_group_dma_owner_claimed(group->iommu_group))\n\t\tstatus.flags |= VFIO_GROUP_FLAGS_VIABLE;\n\tmutex_unlock(&group->group_lock);\n\n\tif (copy_to_user(arg, &status, minsz))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic long vfio_group_fops_unl_ioctl(struct file *filep,\n\t\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_group *group = filep->private_data;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase VFIO_GROUP_GET_DEVICE_FD:\n\t\treturn vfio_group_ioctl_get_device_fd(group, uarg);\n\tcase VFIO_GROUP_GET_STATUS:\n\t\treturn vfio_group_ioctl_get_status(group, uarg);\n\tcase VFIO_GROUP_SET_CONTAINER:\n\t\treturn vfio_group_ioctl_set_container(group, uarg);\n\tcase VFIO_GROUP_UNSET_CONTAINER:\n\t\treturn vfio_group_ioctl_unset_container(group);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nint vfio_device_block_group(struct vfio_device *device)\n{\n\tstruct vfio_group *group = device->group;\n\tint ret = 0;\n\n\tmutex_lock(&group->group_lock);\n\tif (group->opened_file) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tgroup->cdev_device_open_cnt++;\n\nout_unlock:\n\tmutex_unlock(&group->group_lock);\n\treturn ret;\n}\n\nvoid vfio_device_unblock_group(struct vfio_device *device)\n{\n\tstruct vfio_group *group = device->group;\n\n\tmutex_lock(&group->group_lock);\n\tgroup->cdev_device_open_cnt--;\n\tmutex_unlock(&group->group_lock);\n}\n\nstatic int vfio_group_fops_open(struct inode *inode, struct file *filep)\n{\n\tstruct vfio_group *group =\n\t\tcontainer_of(inode->i_cdev, struct vfio_group, cdev);\n\tint ret;\n\n\tmutex_lock(&group->group_lock);\n\n\t \n\tif (refcount_read(&group->drivers) == 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (group->type == VFIO_NO_IOMMU && !capable(CAP_SYS_RAWIO)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (group->cdev_device_open_cnt) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (group->opened_file) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tgroup->opened_file = filep;\n\tfilep->private_data = group;\n\tret = 0;\nout_unlock:\n\tmutex_unlock(&group->group_lock);\n\treturn ret;\n}\n\nstatic int vfio_group_fops_release(struct inode *inode, struct file *filep)\n{\n\tstruct vfio_group *group = filep->private_data;\n\n\tfilep->private_data = NULL;\n\n\tmutex_lock(&group->group_lock);\n\t \n\tWARN_ON(group->notifier.head);\n\tif (group->container)\n\t\tvfio_group_detach_container(group);\n\tif (group->iommufd) {\n\t\tiommufd_ctx_put(group->iommufd);\n\t\tgroup->iommufd = NULL;\n\t}\n\tgroup->opened_file = NULL;\n\tmutex_unlock(&group->group_lock);\n\treturn 0;\n}\n\nstatic const struct file_operations vfio_group_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= vfio_group_fops_unl_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= vfio_group_fops_open,\n\t.release\t= vfio_group_fops_release,\n};\n\n \nstatic struct vfio_group *\nvfio_group_find_from_iommu(struct iommu_group *iommu_group)\n{\n\tstruct vfio_group *group;\n\n\tlockdep_assert_held(&vfio.group_lock);\n\n\t \n\tlist_for_each_entry(group, &vfio.group_list, vfio_next) {\n\t\tif (group->iommu_group == iommu_group)\n\t\t\treturn group;\n\t}\n\treturn NULL;\n}\n\nstatic void vfio_group_release(struct device *dev)\n{\n\tstruct vfio_group *group = container_of(dev, struct vfio_group, dev);\n\n\tmutex_destroy(&group->device_lock);\n\tmutex_destroy(&group->group_lock);\n\tWARN_ON(group->iommu_group);\n\tWARN_ON(group->cdev_device_open_cnt);\n\tida_free(&vfio.group_ida, MINOR(group->dev.devt));\n\tkfree(group);\n}\n\nstatic struct vfio_group *vfio_group_alloc(struct iommu_group *iommu_group,\n\t\t\t\t\t   enum vfio_group_type type)\n{\n\tstruct vfio_group *group;\n\tint minor;\n\n\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\tif (!group)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tminor = ida_alloc_max(&vfio.group_ida, MINORMASK, GFP_KERNEL);\n\tif (minor < 0) {\n\t\tkfree(group);\n\t\treturn ERR_PTR(minor);\n\t}\n\n\tdevice_initialize(&group->dev);\n\tgroup->dev.devt = MKDEV(MAJOR(vfio.group_devt), minor);\n\tgroup->dev.class = vfio.class;\n\tgroup->dev.release = vfio_group_release;\n\tcdev_init(&group->cdev, &vfio_group_fops);\n\tgroup->cdev.owner = THIS_MODULE;\n\n\trefcount_set(&group->drivers, 1);\n\tmutex_init(&group->group_lock);\n\tspin_lock_init(&group->kvm_ref_lock);\n\tINIT_LIST_HEAD(&group->device_list);\n\tmutex_init(&group->device_lock);\n\tgroup->iommu_group = iommu_group;\n\t \n\tiommu_group_ref_get(iommu_group);\n\tgroup->type = type;\n\tBLOCKING_INIT_NOTIFIER_HEAD(&group->notifier);\n\n\treturn group;\n}\n\nstatic struct vfio_group *vfio_create_group(struct iommu_group *iommu_group,\n\t\tenum vfio_group_type type)\n{\n\tstruct vfio_group *group;\n\tstruct vfio_group *ret;\n\tint err;\n\n\tlockdep_assert_held(&vfio.group_lock);\n\n\tgroup = vfio_group_alloc(iommu_group, type);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\terr = dev_set_name(&group->dev, \"%s%d\",\n\t\t\t   group->type == VFIO_NO_IOMMU ? \"noiommu-\" : \"\",\n\t\t\t   iommu_group_id(iommu_group));\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_put;\n\t}\n\n\terr = cdev_device_add(&group->cdev, &group->dev);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_put;\n\t}\n\n\tlist_add(&group->vfio_next, &vfio.group_list);\n\n\treturn group;\n\nerr_put:\n\tput_device(&group->dev);\n\treturn ret;\n}\n\nstatic struct vfio_group *vfio_noiommu_group_alloc(struct device *dev,\n\t\tenum vfio_group_type type)\n{\n\tstruct iommu_group *iommu_group;\n\tstruct vfio_group *group;\n\tint ret;\n\n\tiommu_group = iommu_group_alloc();\n\tif (IS_ERR(iommu_group))\n\t\treturn ERR_CAST(iommu_group);\n\n\tret = iommu_group_set_name(iommu_group, \"vfio-noiommu\");\n\tif (ret)\n\t\tgoto out_put_group;\n\tret = iommu_group_add_device(iommu_group, dev);\n\tif (ret)\n\t\tgoto out_put_group;\n\n\tmutex_lock(&vfio.group_lock);\n\tgroup = vfio_create_group(iommu_group, type);\n\tmutex_unlock(&vfio.group_lock);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_remove_device;\n\t}\n\tiommu_group_put(iommu_group);\n\treturn group;\n\nout_remove_device:\n\tiommu_group_remove_device(dev);\nout_put_group:\n\tiommu_group_put(iommu_group);\n\treturn ERR_PTR(ret);\n}\n\nstatic bool vfio_group_has_device(struct vfio_group *group, struct device *dev)\n{\n\tstruct vfio_device *device;\n\n\tmutex_lock(&group->device_lock);\n\tlist_for_each_entry(device, &group->device_list, group_next) {\n\t\tif (device->dev == dev) {\n\t\t\tmutex_unlock(&group->device_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(&group->device_lock);\n\treturn false;\n}\n\nstatic struct vfio_group *vfio_group_find_or_alloc(struct device *dev)\n{\n\tstruct iommu_group *iommu_group;\n\tstruct vfio_group *group;\n\n\tiommu_group = iommu_group_get(dev);\n\tif (!iommu_group && vfio_noiommu) {\n\t\t \n\t\tgroup = vfio_noiommu_group_alloc(dev, VFIO_NO_IOMMU);\n\t\tif (!IS_ERR(group)) {\n\t\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t\t\tdev_warn(dev, \"Adding kernel taint for vfio-noiommu group on device\\n\");\n\t\t}\n\t\treturn group;\n\t}\n\n\tif (!iommu_group)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&vfio.group_lock);\n\tgroup = vfio_group_find_from_iommu(iommu_group);\n\tif (group) {\n\t\tif (WARN_ON(vfio_group_has_device(group, dev)))\n\t\t\tgroup = ERR_PTR(-EINVAL);\n\t\telse\n\t\t\trefcount_inc(&group->drivers);\n\t} else {\n\t\tgroup = vfio_create_group(iommu_group, VFIO_IOMMU);\n\t}\n\tmutex_unlock(&vfio.group_lock);\n\n\t \n\tiommu_group_put(iommu_group);\n\treturn group;\n}\n\nint vfio_device_set_group(struct vfio_device *device,\n\t\t\t  enum vfio_group_type type)\n{\n\tstruct vfio_group *group;\n\n\tif (type == VFIO_IOMMU)\n\t\tgroup = vfio_group_find_or_alloc(device->dev);\n\telse\n\t\tgroup = vfio_noiommu_group_alloc(device->dev, type);\n\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\n\t \n\tdevice->group = group;\n\treturn 0;\n}\n\nvoid vfio_device_remove_group(struct vfio_device *device)\n{\n\tstruct vfio_group *group = device->group;\n\tstruct iommu_group *iommu_group;\n\n\tif (group->type == VFIO_NO_IOMMU || group->type == VFIO_EMULATED_IOMMU)\n\t\tiommu_group_remove_device(device->dev);\n\n\t \n\tif (!refcount_dec_and_mutex_lock(&group->drivers, &vfio.group_lock))\n\t\treturn;\n\tlist_del(&group->vfio_next);\n\n\t \n\tcdev_device_del(&group->cdev, &group->dev);\n\n\tmutex_lock(&group->group_lock);\n\t \n\tWARN_ON(!list_empty(&group->device_list));\n\tWARN_ON(group->notifier.head);\n\n\t \n\tif (group->container)\n\t\tvfio_group_detach_container(group);\n\tiommu_group = group->iommu_group;\n\tgroup->iommu_group = NULL;\n\tmutex_unlock(&group->group_lock);\n\tmutex_unlock(&vfio.group_lock);\n\n\tiommu_group_put(iommu_group);\n\tput_device(&group->dev);\n}\n\nvoid vfio_device_group_register(struct vfio_device *device)\n{\n\tmutex_lock(&device->group->device_lock);\n\tlist_add(&device->group_next, &device->group->device_list);\n\tmutex_unlock(&device->group->device_lock);\n}\n\nvoid vfio_device_group_unregister(struct vfio_device *device)\n{\n\tmutex_lock(&device->group->device_lock);\n\tlist_del(&device->group_next);\n\tmutex_unlock(&device->group->device_lock);\n}\n\nint vfio_device_group_use_iommu(struct vfio_device *device)\n{\n\tstruct vfio_group *group = device->group;\n\tint ret = 0;\n\n\tlockdep_assert_held(&group->group_lock);\n\n\tif (WARN_ON(!group->container))\n\t\treturn -EINVAL;\n\n\tret = vfio_group_use_container(group);\n\tif (ret)\n\t\treturn ret;\n\tvfio_device_container_register(device);\n\treturn 0;\n}\n\nvoid vfio_device_group_unuse_iommu(struct vfio_device *device)\n{\n\tstruct vfio_group *group = device->group;\n\n\tlockdep_assert_held(&group->group_lock);\n\n\tif (WARN_ON(!group->container))\n\t\treturn;\n\n\tvfio_device_container_unregister(device);\n\tvfio_group_unuse_container(group);\n}\n\nbool vfio_device_has_container(struct vfio_device *device)\n{\n\treturn device->group->container;\n}\n\nstruct vfio_group *vfio_group_from_file(struct file *file)\n{\n\tstruct vfio_group *group = file->private_data;\n\n\tif (file->f_op != &vfio_group_fops)\n\t\treturn NULL;\n\treturn group;\n}\n\n \nstruct iommu_group *vfio_file_iommu_group(struct file *file)\n{\n\tstruct vfio_group *group = vfio_group_from_file(file);\n\tstruct iommu_group *iommu_group = NULL;\n\n\tif (!IS_ENABLED(CONFIG_SPAPR_TCE_IOMMU))\n\t\treturn NULL;\n\n\tif (!group)\n\t\treturn NULL;\n\n\tmutex_lock(&group->group_lock);\n\tif (group->iommu_group) {\n\t\tiommu_group = group->iommu_group;\n\t\tiommu_group_ref_get(iommu_group);\n\t}\n\tmutex_unlock(&group->group_lock);\n\treturn iommu_group;\n}\nEXPORT_SYMBOL_GPL(vfio_file_iommu_group);\n\n \nbool vfio_file_is_group(struct file *file)\n{\n\treturn vfio_group_from_file(file);\n}\nEXPORT_SYMBOL_GPL(vfio_file_is_group);\n\nbool vfio_group_enforced_coherent(struct vfio_group *group)\n{\n\tstruct vfio_device *device;\n\tbool ret = true;\n\n\t \n\tmutex_lock(&group->device_lock);\n\tlist_for_each_entry(device, &group->device_list, group_next) {\n\t\tif (!device_iommu_capable(device->dev,\n\t\t\t\t\t  IOMMU_CAP_ENFORCE_CACHE_COHERENCY)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&group->device_lock);\n\treturn ret;\n}\n\nvoid vfio_group_set_kvm(struct vfio_group *group, struct kvm *kvm)\n{\n\tspin_lock(&group->kvm_ref_lock);\n\tgroup->kvm = kvm;\n\tspin_unlock(&group->kvm_ref_lock);\n}\n\n \nbool vfio_file_has_dev(struct file *file, struct vfio_device *device)\n{\n\tstruct vfio_group *group = vfio_group_from_file(file);\n\n\tif (!group)\n\t\treturn false;\n\n\treturn group == device->group;\n}\nEXPORT_SYMBOL_GPL(vfio_file_has_dev);\n\nstatic char *vfio_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"vfio/%s\", dev_name(dev));\n}\n\nint __init vfio_group_init(void)\n{\n\tint ret;\n\n\tida_init(&vfio.group_ida);\n\tmutex_init(&vfio.group_lock);\n\tINIT_LIST_HEAD(&vfio.group_list);\n\n\tret = vfio_container_init();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvfio.class = class_create(\"vfio\");\n\tif (IS_ERR(vfio.class)) {\n\t\tret = PTR_ERR(vfio.class);\n\t\tgoto err_group_class;\n\t}\n\n\tvfio.class->devnode = vfio_devnode;\n\n\tret = alloc_chrdev_region(&vfio.group_devt, 0, MINORMASK + 1, \"vfio\");\n\tif (ret)\n\t\tgoto err_alloc_chrdev;\n\treturn 0;\n\nerr_alloc_chrdev:\n\tclass_destroy(vfio.class);\n\tvfio.class = NULL;\nerr_group_class:\n\tvfio_container_cleanup();\n\treturn ret;\n}\n\nvoid vfio_group_cleanup(void)\n{\n\tWARN_ON(!list_empty(&vfio.group_list));\n\tida_destroy(&vfio.group_ida);\n\tunregister_chrdev_region(vfio.group_devt, MINORMASK + 1);\n\tclass_destroy(vfio.class);\n\tvfio.class = NULL;\n\tvfio_container_cleanup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}