{
  "module_name": "vfio_platform_common.c",
  "hash_id": "fa4d30a40f8195b8d204132138d29b36e46345a8952f1a1fc9e6e950973f5126",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/platform/vfio_platform_common.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt)\t\"VFIO: \" fmt\n\n#include <linux/device.h>\n#include <linux/acpi.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/vfio.h>\n\n#include \"vfio_platform_private.h\"\n\n#define DRIVER_VERSION  \"0.10\"\n#define DRIVER_AUTHOR   \"Antonios Motakis <a.motakis@virtualopensystems.com>\"\n#define DRIVER_DESC     \"VFIO platform base module\"\n\n#define VFIO_PLATFORM_IS_ACPI(vdev) ((vdev)->acpihid != NULL)\n\nstatic LIST_HEAD(reset_list);\nstatic DEFINE_MUTEX(driver_lock);\n\nstatic vfio_platform_reset_fn_t vfio_platform_lookup_reset(const char *compat,\n\t\t\t\t\tstruct module **module)\n{\n\tstruct vfio_platform_reset_node *iter;\n\tvfio_platform_reset_fn_t reset_fn = NULL;\n\n\tmutex_lock(&driver_lock);\n\tlist_for_each_entry(iter, &reset_list, link) {\n\t\tif (!strcmp(iter->compat, compat) &&\n\t\t\ttry_module_get(iter->owner)) {\n\t\t\t*module = iter->owner;\n\t\t\treset_fn = iter->of_reset;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&driver_lock);\n\treturn reset_fn;\n}\n\nstatic int vfio_platform_acpi_probe(struct vfio_platform_device *vdev,\n\t\t\t\t    struct device *dev)\n{\n\tstruct acpi_device *adev;\n\n\tif (acpi_disabled)\n\t\treturn -ENOENT;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev) {\n\t\tdev_err(dev, \"ACPI companion device not found for %s\\n\",\n\t\t\tvdev->name);\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CONFIG_ACPI\n\tvdev->acpihid = acpi_device_hid(adev);\n#endif\n\treturn WARN_ON(!vdev->acpihid) ? -EINVAL : 0;\n}\n\nstatic int vfio_platform_acpi_call_reset(struct vfio_platform_device *vdev,\n\t\t\t\t  const char **extra_dbg)\n{\n#ifdef CONFIG_ACPI\n\tstruct device *dev = vdev->device;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tacpi_status acpi_ret;\n\n\tacpi_ret = acpi_evaluate_object(handle, \"_RST\", NULL, NULL);\n\tif (ACPI_FAILURE(acpi_ret)) {\n\t\tif (extra_dbg)\n\t\t\t*extra_dbg = acpi_format_exception(acpi_ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n#else\n\treturn -ENOENT;\n#endif\n}\n\nstatic bool vfio_platform_acpi_has_reset(struct vfio_platform_device *vdev)\n{\n#ifdef CONFIG_ACPI\n\tstruct device *dev = vdev->device;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\n\treturn acpi_has_method(handle, \"_RST\");\n#else\n\treturn false;\n#endif\n}\n\nstatic bool vfio_platform_has_reset(struct vfio_platform_device *vdev)\n{\n\tif (VFIO_PLATFORM_IS_ACPI(vdev))\n\t\treturn vfio_platform_acpi_has_reset(vdev);\n\n\treturn vdev->of_reset ? true : false;\n}\n\nstatic int vfio_platform_get_reset(struct vfio_platform_device *vdev)\n{\n\tif (VFIO_PLATFORM_IS_ACPI(vdev))\n\t\treturn vfio_platform_acpi_has_reset(vdev) ? 0 : -ENOENT;\n\n\tvdev->of_reset = vfio_platform_lookup_reset(vdev->compat,\n\t\t\t\t\t\t    &vdev->reset_module);\n\tif (!vdev->of_reset) {\n\t\trequest_module(\"vfio-reset:%s\", vdev->compat);\n\t\tvdev->of_reset = vfio_platform_lookup_reset(vdev->compat,\n\t\t\t\t\t\t\t&vdev->reset_module);\n\t}\n\n\treturn vdev->of_reset ? 0 : -ENOENT;\n}\n\nstatic void vfio_platform_put_reset(struct vfio_platform_device *vdev)\n{\n\tif (VFIO_PLATFORM_IS_ACPI(vdev))\n\t\treturn;\n\n\tif (vdev->of_reset)\n\t\tmodule_put(vdev->reset_module);\n}\n\nstatic int vfio_platform_regions_init(struct vfio_platform_device *vdev)\n{\n\tint cnt = 0, i;\n\n\twhile (vdev->get_resource(vdev, cnt))\n\t\tcnt++;\n\n\tvdev->regions = kcalloc(cnt, sizeof(struct vfio_platform_region),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\tif (!vdev->regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt;  i++) {\n\t\tstruct resource *res =\n\t\t\tvdev->get_resource(vdev, i);\n\n\t\tvdev->regions[i].addr = res->start;\n\t\tvdev->regions[i].size = resource_size(res);\n\t\tvdev->regions[i].flags = 0;\n\n\t\tswitch (resource_type(res)) {\n\t\tcase IORESOURCE_MEM:\n\t\t\tvdev->regions[i].type = VFIO_PLATFORM_REGION_TYPE_MMIO;\n\t\t\tvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_READ;\n\t\t\tif (!(res->flags & IORESOURCE_READONLY))\n\t\t\t\tvdev->regions[i].flags |=\n\t\t\t\t\tVFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\t \n\t\t\tif (!(vdev->regions[i].addr & ~PAGE_MASK) &&\n\t\t\t\t\t!(vdev->regions[i].size & ~PAGE_MASK))\n\t\t\t\tvdev->regions[i].flags |=\n\t\t\t\t\tVFIO_REGION_INFO_FLAG_MMAP;\n\n\t\t\tbreak;\n\t\tcase IORESOURCE_IO:\n\t\t\tvdev->regions[i].type = VFIO_PLATFORM_REGION_TYPE_PIO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tvdev->num_regions = cnt;\n\n\treturn 0;\nerr:\n\tkfree(vdev->regions);\n\treturn -EINVAL;\n}\n\nstatic void vfio_platform_regions_cleanup(struct vfio_platform_device *vdev)\n{\n\tint i;\n\n\tfor (i = 0; i < vdev->num_regions; i++)\n\t\tiounmap(vdev->regions[i].ioaddr);\n\n\tvdev->num_regions = 0;\n\tkfree(vdev->regions);\n}\n\nstatic int vfio_platform_call_reset(struct vfio_platform_device *vdev,\n\t\t\t\t    const char **extra_dbg)\n{\n\tif (VFIO_PLATFORM_IS_ACPI(vdev)) {\n\t\tdev_info(vdev->device, \"reset\\n\");\n\t\treturn vfio_platform_acpi_call_reset(vdev, extra_dbg);\n\t} else if (vdev->of_reset) {\n\t\tdev_info(vdev->device, \"reset\\n\");\n\t\treturn vdev->of_reset(vdev);\n\t}\n\n\tdev_warn(vdev->device, \"no reset function found!\\n\");\n\treturn -EINVAL;\n}\n\nvoid vfio_platform_close_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\tconst char *extra_dbg = NULL;\n\tint ret;\n\n\tret = vfio_platform_call_reset(vdev, &extra_dbg);\n\tif (WARN_ON(ret && vdev->reset_required)) {\n\t\tdev_warn(\n\t\t\tvdev->device,\n\t\t\t\"reset driver is required and reset call failed in release (%d) %s\\n\",\n\t\t\tret, extra_dbg ? extra_dbg : \"\");\n\t}\n\tpm_runtime_put(vdev->device);\n\tvfio_platform_regions_cleanup(vdev);\n\tvfio_platform_irq_cleanup(vdev);\n}\nEXPORT_SYMBOL_GPL(vfio_platform_close_device);\n\nint vfio_platform_open_device(struct vfio_device *core_vdev)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\tconst char *extra_dbg = NULL;\n\tint ret;\n\n\tret = vfio_platform_regions_init(vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vfio_platform_irq_init(vdev);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tret = pm_runtime_get_sync(vdev->device);\n\tif (ret < 0)\n\t\tgoto err_rst;\n\n\tret = vfio_platform_call_reset(vdev, &extra_dbg);\n\tif (ret && vdev->reset_required) {\n\t\tdev_warn(\n\t\t\tvdev->device,\n\t\t\t\"reset driver is required and reset call failed in open (%d) %s\\n\",\n\t\t\tret, extra_dbg ? extra_dbg : \"\");\n\t\tgoto err_rst;\n\t}\n\treturn 0;\n\nerr_rst:\n\tpm_runtime_put(vdev->device);\n\tvfio_platform_irq_cleanup(vdev);\nerr_irq:\n\tvfio_platform_regions_cleanup(vdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_open_device);\n\nlong vfio_platform_ioctl(struct vfio_device *core_vdev,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tif (vfio_platform_has_reset(vdev))\n\t\t\tvdev->flags |= VFIO_DEVICE_FLAGS_RESET;\n\t\tinfo.flags = vdev->flags;\n\t\tinfo.num_regions = vdev->num_regions;\n\t\tinfo.num_irqs = vdev->num_irqs;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct vfio_region_info info;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tif (info.index >= vdev->num_regions)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tinfo.offset = VFIO_PLATFORM_INDEX_TO_OFFSET(info.index);\n\t\tinfo.size = vdev->regions[info.index].size;\n\t\tinfo.flags = vdev->regions[info.index].flags;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tif (info.index >= vdev->num_irqs)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = vdev->irqs[info.index].flags;\n\t\tinfo.count = vdev->irqs[info.index].count;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\t\tsize_t data_size = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tret = vfio_set_irqs_validate_and_prepare(&hdr, vdev->num_irqs,\n\t\t\t\t\t\t vdev->num_irqs, &data_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (data_size) {\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t    data_size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_platform_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t\t   hdr.start, hdr.count, data);\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vfio_platform_call_reset(vdev, NULL);\n\t}\n\n\treturn -ENOTTY;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_ioctl);\n\nstatic ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\n\t\t\t\t       char __user *buf, size_t count,\n\t\t\t\t       loff_t off)\n{\n\tunsigned int done = 0;\n\n\tif (!reg->ioaddr) {\n\t\treg->ioaddr =\n\t\t\tioremap(reg->addr, reg->size);\n\n\t\tif (!reg->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(off % 4)) {\n\t\t\tu32 val;\n\n\t\t\tval = ioread32(reg->ioaddr + off);\n\t\t\tif (copy_to_user(buf, &val, 4))\n\t\t\t\tgoto err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(off % 2)) {\n\t\t\tu16 val;\n\n\t\t\tval = ioread16(reg->ioaddr + off);\n\t\t\tif (copy_to_user(buf, &val, 2))\n\t\t\t\tgoto err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tval = ioread8(reg->ioaddr + off);\n\t\t\tif (copy_to_user(buf, &val, 1))\n\t\t\t\tgoto err;\n\n\t\t\tfilled = 1;\n\t\t}\n\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\toff += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nerr:\n\treturn -EFAULT;\n}\n\nssize_t vfio_platform_read(struct vfio_device *core_vdev,\n\t\t\t   char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\tunsigned int index = VFIO_PLATFORM_OFFSET_TO_INDEX(*ppos);\n\tloff_t off = *ppos & VFIO_PLATFORM_OFFSET_MASK;\n\n\tif (index >= vdev->num_regions)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ))\n\t\treturn -EINVAL;\n\n\tif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\n\t\treturn vfio_platform_read_mmio(&vdev->regions[index],\n\t\t\t\t\t\t\tbuf, count, off);\n\telse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\n\t\treturn -EINVAL;  \n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_read);\n\nstatic ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\n\t\t\t\t\tconst char __user *buf, size_t count,\n\t\t\t\t\tloff_t off)\n{\n\tunsigned int done = 0;\n\n\tif (!reg->ioaddr) {\n\t\treg->ioaddr =\n\t\t\tioremap(reg->addr, reg->size);\n\n\t\tif (!reg->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(off % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (copy_from_user(&val, buf, 4))\n\t\t\t\tgoto err;\n\t\t\tiowrite32(val, reg->ioaddr + off);\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(off % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (copy_from_user(&val, buf, 2))\n\t\t\t\tgoto err;\n\t\t\tiowrite16(val, reg->ioaddr + off);\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tif (copy_from_user(&val, buf, 1))\n\t\t\t\tgoto err;\n\t\t\tiowrite8(val, reg->ioaddr + off);\n\n\t\t\tfilled = 1;\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\toff += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nerr:\n\treturn -EFAULT;\n}\n\nssize_t vfio_platform_write(struct vfio_device *core_vdev, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\tunsigned int index = VFIO_PLATFORM_OFFSET_TO_INDEX(*ppos);\n\tloff_t off = *ppos & VFIO_PLATFORM_OFFSET_MASK;\n\n\tif (index >= vdev->num_regions)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE))\n\t\treturn -EINVAL;\n\n\tif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\n\t\treturn vfio_platform_write_mmio(&vdev->regions[index],\n\t\t\t\t\t\t\tbuf, count, off);\n\telse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\n\t\treturn -EINVAL;  \n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_write);\n\nstatic int vfio_platform_mmap_mmio(struct vfio_platform_region region,\n\t\t\t\t   struct vm_area_struct *vma)\n{\n\tu64 req_len, pgoff, req_start;\n\n\treq_len = vma->vm_end - vma->vm_start;\n\tpgoff = vma->vm_pgoff &\n\t\t((1U << (VFIO_PLATFORM_OFFSET_SHIFT - PAGE_SHIFT)) - 1);\n\treq_start = pgoff << PAGE_SHIFT;\n\n\tif (region.size < PAGE_SIZE || req_start + req_len > region.size)\n\t\treturn -EINVAL;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvma->vm_pgoff = (region.addr >> PAGE_SHIFT) + pgoff;\n\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       req_len, vma->vm_page_prot);\n}\n\nint vfio_platform_mmap(struct vfio_device *core_vdev, struct vm_area_struct *vma)\n{\n\tstruct vfio_platform_device *vdev =\n\t\tcontainer_of(core_vdev, struct vfio_platform_device, vdev);\n\tunsigned int index;\n\n\tindex = vma->vm_pgoff >> (VFIO_PLATFORM_OFFSET_SHIFT - PAGE_SHIFT);\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\tif (index >= vdev->num_regions)\n\t\treturn -EINVAL;\n\tif (vma->vm_start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (vma->vm_end & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_MMAP))\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ)\n\t\t\t&& (vma->vm_flags & VM_READ))\n\t\treturn -EINVAL;\n\n\tif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE)\n\t\t\t&& (vma->vm_flags & VM_WRITE))\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = vdev;\n\n\tif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\n\t\treturn vfio_platform_mmap_mmio(vdev->regions[index], vma);\n\n\telse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\n\t\treturn -EINVAL;  \n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_mmap);\n\nstatic int vfio_platform_of_probe(struct vfio_platform_device *vdev,\n\t\t\t   struct device *dev)\n{\n\tint ret;\n\n\tret = device_property_read_string(dev, \"compatible\",\n\t\t\t\t\t  &vdev->compat);\n\tif (ret)\n\t\tdev_err(dev, \"Cannot retrieve compat for %s\\n\", vdev->name);\n\n\treturn ret;\n}\n\n \nint vfio_platform_init_common(struct vfio_platform_device *vdev)\n{\n\tint ret;\n\tstruct device *dev = vdev->vdev.dev;\n\n\tret = vfio_platform_acpi_probe(vdev, dev);\n\tif (ret)\n\t\tret = vfio_platform_of_probe(vdev, dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tvdev->device = dev;\n\tmutex_init(&vdev->igate);\n\n\tret = vfio_platform_get_reset(vdev);\n\tif (ret && vdev->reset_required) {\n\t\tdev_err(dev, \"No reset function found for device %s\\n\",\n\t\t\tvdev->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vfio_platform_init_common);\n\nvoid vfio_platform_release_common(struct vfio_platform_device *vdev)\n{\n\tvfio_platform_put_reset(vdev);\n}\nEXPORT_SYMBOL_GPL(vfio_platform_release_common);\n\nvoid __vfio_platform_register_reset(struct vfio_platform_reset_node *node)\n{\n\tmutex_lock(&driver_lock);\n\tlist_add(&node->link, &reset_list);\n\tmutex_unlock(&driver_lock);\n}\nEXPORT_SYMBOL_GPL(__vfio_platform_register_reset);\n\nvoid vfio_platform_unregister_reset(const char *compat,\n\t\t\t\t    vfio_platform_reset_fn_t fn)\n{\n\tstruct vfio_platform_reset_node *iter, *temp;\n\n\tmutex_lock(&driver_lock);\n\tlist_for_each_entry_safe(iter, temp, &reset_list, link) {\n\t\tif (!strcmp(iter->compat, compat) && (iter->of_reset == fn)) {\n\t\t\tlist_del(&iter->link);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&driver_lock);\n\n}\nEXPORT_SYMBOL_GPL(vfio_platform_unregister_reset);\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}