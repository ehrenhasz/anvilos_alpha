{
  "module_name": "vfio_platform_amdxgbe.c",
  "hash_id": "7aa6d2e67a367eaa35e3fd2f8e165fa3a07a644cb7f81576a1a529c23c961fb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/platform/reset/vfio_platform_amdxgbe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <uapi/linux/mdio.h>\n#include <linux/delay.h>\n\n#include \"../vfio_platform_private.h\"\n\n#define DMA_MR\t\t\t0x3000\n#define MAC_VR\t\t\t0x0110\n#define DMA_ISR\t\t\t0x3008\n#define MAC_ISR\t\t\t0x00b0\n#define PCS_MMD_SELECT\t\t0xff\n#define MDIO_AN_INT\t\t0x8002\n#define MDIO_AN_INTMASK\t\t0x8001\n\nstatic unsigned int xmdio_read(void __iomem *ioaddr, unsigned int mmd,\n\t\t\t       unsigned int reg)\n{\n\tunsigned int mmd_address, value;\n\n\tmmd_address = (mmd << 16) | ((reg) & 0xffff);\n\tiowrite32(mmd_address >> 8, ioaddr + (PCS_MMD_SELECT << 2));\n\tvalue = ioread32(ioaddr + ((mmd_address & 0xff) << 2));\n\treturn value;\n}\n\nstatic void xmdio_write(void __iomem *ioaddr, unsigned int mmd,\n\t\t\tunsigned int reg, unsigned int value)\n{\n\tunsigned int mmd_address;\n\n\tmmd_address = (mmd << 16) | ((reg) & 0xffff);\n\tiowrite32(mmd_address >> 8, ioaddr + (PCS_MMD_SELECT << 2));\n\tiowrite32(value, ioaddr + ((mmd_address & 0xff) << 2));\n}\n\nstatic int vfio_platform_amdxgbe_reset(struct vfio_platform_device *vdev)\n{\n\tstruct vfio_platform_region *xgmac_regs = &vdev->regions[0];\n\tstruct vfio_platform_region *xpcs_regs = &vdev->regions[1];\n\tu32 dma_mr_value, pcs_value, value;\n\tunsigned int count;\n\n\tif (!xgmac_regs->ioaddr) {\n\t\txgmac_regs->ioaddr =\n\t\t\tioremap(xgmac_regs->addr, xgmac_regs->size);\n\t\tif (!xgmac_regs->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!xpcs_regs->ioaddr) {\n\t\txpcs_regs->ioaddr =\n\t\t\tioremap(xpcs_regs->addr, xpcs_regs->size);\n\t\tif (!xpcs_regs->ioaddr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpcs_value = xmdio_read(xpcs_regs->ioaddr, MDIO_MMD_PCS, MDIO_CTRL1);\n\tpcs_value |= MDIO_CTRL1_RESET;\n\txmdio_write(xpcs_regs->ioaddr, MDIO_MMD_PCS, MDIO_CTRL1, pcs_value);\n\n\tcount = 50;\n\tdo {\n\t\tmsleep(20);\n\t\tpcs_value = xmdio_read(xpcs_regs->ioaddr, MDIO_MMD_PCS,\n\t\t\t\t\tMDIO_CTRL1);\n\t} while ((pcs_value & MDIO_CTRL1_RESET) && --count);\n\n\tif (pcs_value & MDIO_CTRL1_RESET)\n\t\tdev_warn(vdev->device, \"%s: XGBE PHY reset timeout\\n\",\n\t\t\t __func__);\n\n\t \n\tvalue = xmdio_read(xpcs_regs->ioaddr, MDIO_MMD_AN, MDIO_CTRL1);\n\tvalue &= ~MDIO_AN_CTRL1_ENABLE;\n\txmdio_write(xpcs_regs->ioaddr, MDIO_MMD_AN, MDIO_CTRL1, value);\n\n\t \n\txmdio_write(xpcs_regs->ioaddr, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);\n\n\t \n\txmdio_write(xpcs_regs->ioaddr, MDIO_MMD_AN, MDIO_AN_INT, 0);\n\n\t \n\tdma_mr_value = ioread32(xgmac_regs->ioaddr + DMA_MR);\n\tdma_mr_value |= 0x1;\n\tiowrite32(dma_mr_value, xgmac_regs->ioaddr + DMA_MR);\n\n\tusleep_range(10, 15);\n\n\tcount = 2000;\n\twhile (--count && (ioread32(xgmac_regs->ioaddr + DMA_MR) & 1))\n\t\tusleep_range(500, 600);\n\n\tif (!count)\n\t\tdev_warn(vdev->device, \"%s: MAC SW reset failed\\n\", __func__);\n\n\treturn 0;\n}\n\nmodule_vfio_reset_handler(\"amd,xgbe-seattle-v1a\", vfio_platform_amdxgbe_reset);\n\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Eric Auger <eric.auger@linaro.org>\");\nMODULE_DESCRIPTION(\"Reset support for AMD xgbe vfio platform device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}