{
  "module_name": "vfio_platform_irq.c",
  "hash_id": "b7c860b6feb9c966c2ade2c5debde2b33baea8a3751ade56b47ec61257b39a75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vfio/platform/vfio_platform_irq.c",
  "human_readable_source": "\n \n\n#include <linux/eventfd.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vfio.h>\n#include <linux/irq.h>\n\n#include \"vfio_platform_private.h\"\n\nstatic void vfio_platform_mask(struct vfio_platform_irq *irq_ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&irq_ctx->lock, flags);\n\n\tif (!irq_ctx->masked) {\n\t\tdisable_irq_nosync(irq_ctx->hwirq);\n\t\tirq_ctx->masked = true;\n\t}\n\n\tspin_unlock_irqrestore(&irq_ctx->lock, flags);\n}\n\nstatic int vfio_platform_mask_handler(void *opaque, void *unused)\n{\n\tstruct vfio_platform_irq *irq_ctx = opaque;\n\n\tvfio_platform_mask(irq_ctx);\n\n\treturn 0;\n}\n\nstatic int vfio_platform_set_irq_mask(struct vfio_platform_device *vdev,\n\t\t\t\t      unsigned index, unsigned start,\n\t\t\t\t      unsigned count, uint32_t flags,\n\t\t\t\t      void *data)\n{\n\tif (start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->irqs[index].flags & VFIO_IRQ_INFO_MASKABLE))\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t fd = *(int32_t *)data;\n\n\t\tif (fd >= 0)\n\t\t\treturn vfio_virqfd_enable((void *) &vdev->irqs[index],\n\t\t\t\t\t\t  vfio_platform_mask_handler,\n\t\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t\t  &vdev->irqs[index].mask, fd);\n\n\t\tvfio_virqfd_disable(&vdev->irqs[index].mask);\n\t\treturn 0;\n\t}\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_platform_mask(&vdev->irqs[index]);\n\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t mask = *(uint8_t *)data;\n\n\t\tif (mask)\n\t\t\tvfio_platform_mask(&vdev->irqs[index]);\n\t}\n\n\treturn 0;\n}\n\nstatic void vfio_platform_unmask(struct vfio_platform_irq *irq_ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&irq_ctx->lock, flags);\n\n\tif (irq_ctx->masked) {\n\t\tenable_irq(irq_ctx->hwirq);\n\t\tirq_ctx->masked = false;\n\t}\n\n\tspin_unlock_irqrestore(&irq_ctx->lock, flags);\n}\n\nstatic int vfio_platform_unmask_handler(void *opaque, void *unused)\n{\n\tstruct vfio_platform_irq *irq_ctx = opaque;\n\n\tvfio_platform_unmask(irq_ctx);\n\n\treturn 0;\n}\n\nstatic int vfio_platform_set_irq_unmask(struct vfio_platform_device *vdev,\n\t\t\t\t\tunsigned index, unsigned start,\n\t\t\t\t\tunsigned count, uint32_t flags,\n\t\t\t\t\tvoid *data)\n{\n\tif (start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (!(vdev->irqs[index].flags & VFIO_IRQ_INFO_MASKABLE))\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t fd = *(int32_t *)data;\n\n\t\tif (fd >= 0)\n\t\t\treturn vfio_virqfd_enable((void *) &vdev->irqs[index],\n\t\t\t\t\t\t  vfio_platform_unmask_handler,\n\t\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t\t  &vdev->irqs[index].unmask,\n\t\t\t\t\t\t  fd);\n\n\t\tvfio_virqfd_disable(&vdev->irqs[index].unmask);\n\t\treturn 0;\n\t}\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\tvfio_platform_unmask(&vdev->irqs[index]);\n\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t unmask = *(uint8_t *)data;\n\n\t\tif (unmask)\n\t\t\tvfio_platform_unmask(&vdev->irqs[index]);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t vfio_automasked_irq_handler(int irq, void *dev_id)\n{\n\tstruct vfio_platform_irq *irq_ctx = dev_id;\n\tunsigned long flags;\n\tint ret = IRQ_NONE;\n\n\tspin_lock_irqsave(&irq_ctx->lock, flags);\n\n\tif (!irq_ctx->masked) {\n\t\tret = IRQ_HANDLED;\n\n\t\t \n\t\tdisable_irq_nosync(irq_ctx->hwirq);\n\t\tirq_ctx->masked = true;\n\t}\n\n\tspin_unlock_irqrestore(&irq_ctx->lock, flags);\n\n\tif (ret == IRQ_HANDLED)\n\t\teventfd_signal(irq_ctx->trigger, 1);\n\n\treturn ret;\n}\n\nstatic irqreturn_t vfio_irq_handler(int irq, void *dev_id)\n{\n\tstruct vfio_platform_irq *irq_ctx = dev_id;\n\n\teventfd_signal(irq_ctx->trigger, 1);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vfio_set_trigger(struct vfio_platform_device *vdev, int index,\n\t\t\t    int fd, irq_handler_t handler)\n{\n\tstruct vfio_platform_irq *irq = &vdev->irqs[index];\n\tstruct eventfd_ctx *trigger;\n\tint ret;\n\n\tif (irq->trigger) {\n\t\tirq_clear_status_flags(irq->hwirq, IRQ_NOAUTOEN);\n\t\tfree_irq(irq->hwirq, irq);\n\t\tkfree(irq->name);\n\t\teventfd_ctx_put(irq->trigger);\n\t\tirq->trigger = NULL;\n\t}\n\n\tif (fd < 0)  \n\t\treturn 0;\n\tirq->name = kasprintf(GFP_KERNEL_ACCOUNT, \"vfio-irq[%d](%s)\",\n\t\t\t      irq->hwirq, vdev->name);\n\tif (!irq->name)\n\t\treturn -ENOMEM;\n\n\ttrigger = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(trigger)) {\n\t\tkfree(irq->name);\n\t\treturn PTR_ERR(trigger);\n\t}\n\n\tirq->trigger = trigger;\n\n\tirq_set_status_flags(irq->hwirq, IRQ_NOAUTOEN);\n\tret = request_irq(irq->hwirq, handler, 0, irq->name, irq);\n\tif (ret) {\n\t\tkfree(irq->name);\n\t\teventfd_ctx_put(trigger);\n\t\tirq->trigger = NULL;\n\t\treturn ret;\n\t}\n\n\tif (!irq->masked)\n\t\tenable_irq(irq->hwirq);\n\n\treturn 0;\n}\n\nstatic int vfio_platform_set_irq_trigger(struct vfio_platform_device *vdev,\n\t\t\t\t\t unsigned index, unsigned start,\n\t\t\t\t\t unsigned count, uint32_t flags,\n\t\t\t\t\t void *data)\n{\n\tstruct vfio_platform_irq *irq = &vdev->irqs[index];\n\tirq_handler_t handler;\n\n\tif (vdev->irqs[index].flags & VFIO_IRQ_INFO_AUTOMASKED)\n\t\thandler = vfio_automasked_irq_handler;\n\telse\n\t\thandler = vfio_irq_handler;\n\n\tif (!count && (flags & VFIO_IRQ_SET_DATA_NONE))\n\t\treturn vfio_set_trigger(vdev, index, -1, handler);\n\n\tif (start != 0 || count != 1)\n\t\treturn -EINVAL;\n\n\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\tint32_t fd = *(int32_t *)data;\n\n\t\treturn vfio_set_trigger(vdev, index, fd, handler);\n\t}\n\n\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\thandler(irq->hwirq, irq);\n\n\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\tuint8_t trigger = *(uint8_t *)data;\n\n\t\tif (trigger)\n\t\t\thandler(irq->hwirq, irq);\n\t}\n\n\treturn 0;\n}\n\nint vfio_platform_set_irqs_ioctl(struct vfio_platform_device *vdev,\n\t\t\t\t uint32_t flags, unsigned index, unsigned start,\n\t\t\t\t unsigned count, void *data)\n{\n\tint (*func)(struct vfio_platform_device *vdev, unsigned index,\n\t\t    unsigned start, unsigned count, uint32_t flags,\n\t\t    void *data) = NULL;\n\n\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\tcase VFIO_IRQ_SET_ACTION_MASK:\n\t\tfunc = vfio_platform_set_irq_mask;\n\t\tbreak;\n\tcase VFIO_IRQ_SET_ACTION_UNMASK:\n\t\tfunc = vfio_platform_set_irq_unmask;\n\t\tbreak;\n\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\tfunc = vfio_platform_set_irq_trigger;\n\t\tbreak;\n\t}\n\n\tif (!func)\n\t\treturn -ENOTTY;\n\n\treturn func(vdev, index, start, count, flags, data);\n}\n\nint vfio_platform_irq_init(struct vfio_platform_device *vdev)\n{\n\tint cnt = 0, i;\n\n\twhile (vdev->get_irq(vdev, cnt) >= 0)\n\t\tcnt++;\n\n\tvdev->irqs = kcalloc(cnt, sizeof(struct vfio_platform_irq),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\tif (!vdev->irqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tint hwirq = vdev->get_irq(vdev, i);\n\n\t\tif (hwirq < 0)\n\t\t\tgoto err;\n\n\t\tspin_lock_init(&vdev->irqs[i].lock);\n\n\t\tvdev->irqs[i].flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tif (irq_get_trigger_type(hwirq) & IRQ_TYPE_LEVEL_MASK)\n\t\t\tvdev->irqs[i].flags |= VFIO_IRQ_INFO_MASKABLE\n\t\t\t\t\t\t| VFIO_IRQ_INFO_AUTOMASKED;\n\n\t\tvdev->irqs[i].count = 1;\n\t\tvdev->irqs[i].hwirq = hwirq;\n\t\tvdev->irqs[i].masked = false;\n\t}\n\n\tvdev->num_irqs = cnt;\n\n\treturn 0;\nerr:\n\tkfree(vdev->irqs);\n\treturn -EINVAL;\n}\n\nvoid vfio_platform_irq_cleanup(struct vfio_platform_device *vdev)\n{\n\tint i;\n\n\tfor (i = 0; i < vdev->num_irqs; i++)\n\t\tvfio_set_trigger(vdev, i, -1, NULL);\n\n\tvdev->num_irqs = 0;\n\tkfree(vdev->irqs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}