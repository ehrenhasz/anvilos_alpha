{
  "module_name": "rtc-optee.c",
  "hash_id": "c4efe34eade1586efa7ee3253e35f8b37e00ef726a0a7c6e2bc86c1ea923bfcd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-optee.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/tee_drv.h>\n\n#define RTC_INFO_VERSION\t0x1\n\n#define TA_CMD_RTC_GET_INFO\t\t0x0\n#define TA_CMD_RTC_GET_TIME\t\t0x1\n#define TA_CMD_RTC_SET_TIME\t\t0x2\n#define TA_CMD_RTC_GET_OFFSET\t\t0x3\n#define TA_CMD_RTC_SET_OFFSET\t\t0x4\n\n#define TA_RTC_FEATURE_CORRECTION\tBIT(0)\n\nstruct optee_rtc_time {\n\tu32 tm_sec;\n\tu32 tm_min;\n\tu32 tm_hour;\n\tu32 tm_mday;\n\tu32 tm_mon;\n\tu32 tm_year;\n\tu32 tm_wday;\n};\n\nstruct optee_rtc_info {\n\tu64 version;\n\tu64 features;\n\tstruct optee_rtc_time range_min;\n\tstruct optee_rtc_time range_max;\n};\n\n \nstruct optee_rtc {\n\tstruct device *dev;\n\tstruct tee_context *ctx;\n\tu32 session_id;\n\tstruct tee_shm *shm;\n\tu64 features;\n};\n\nstatic int optee_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\tstruct tee_ioctl_invoke_arg inv_arg = {0};\n\tstruct optee_rtc_time *optee_tm;\n\tstruct tee_param param[4] = {0};\n\tint ret;\n\n\tinv_arg.func = TA_CMD_RTC_GET_TIME;\n\tinv_arg.session = priv->session_id;\n\tinv_arg.num_params = 4;\n\n\t \n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[0].u.memref.shm = priv->shm;\n\tparam[0].u.memref.size = sizeof(struct optee_rtc_time);\n\n\tret = tee_client_invoke_func(priv->ctx, &inv_arg, param);\n\tif (ret < 0 || inv_arg.ret != 0)\n\t\treturn ret ? ret : -EPROTO;\n\n\toptee_tm = tee_shm_get_va(priv->shm, 0);\n\tif (IS_ERR(optee_tm))\n\t\treturn PTR_ERR(optee_tm);\n\n\tif (param[0].u.memref.size != sizeof(*optee_tm))\n\t\treturn -EPROTO;\n\n\ttm->tm_sec = optee_tm->tm_sec;\n\ttm->tm_min = optee_tm->tm_min;\n\ttm->tm_hour = optee_tm->tm_hour;\n\ttm->tm_mday = optee_tm->tm_mday;\n\ttm->tm_mon = optee_tm->tm_mon;\n\ttm->tm_year = optee_tm->tm_year - 1900;\n\ttm->tm_wday = optee_tm->tm_wday;\n\ttm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\n\n\treturn 0;\n}\n\nstatic int optee_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\tstruct tee_ioctl_invoke_arg inv_arg = {0};\n\tstruct tee_param param[4] = {0};\n\tstruct optee_rtc_time optee_tm;\n\tvoid *rtc_data;\n\tint ret;\n\n\toptee_tm.tm_sec = tm->tm_sec;\n\toptee_tm.tm_min = tm->tm_min;\n\toptee_tm.tm_hour = tm->tm_hour;\n\toptee_tm.tm_mday = tm->tm_mday;\n\toptee_tm.tm_mon = tm->tm_mon;\n\toptee_tm.tm_year = tm->tm_year + 1900;\n\toptee_tm.tm_wday = tm->tm_wday;\n\n\tinv_arg.func = TA_CMD_RTC_SET_TIME;\n\tinv_arg.session = priv->session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\tparam[0].u.memref.shm = priv->shm;\n\tparam[0].u.memref.size = sizeof(struct optee_rtc_time);\n\n\trtc_data = tee_shm_get_va(priv->shm, 0);\n\tif (IS_ERR(rtc_data))\n\t\treturn PTR_ERR(rtc_data);\n\n\tmemcpy(rtc_data, &optee_tm, sizeof(struct optee_rtc_time));\n\n\tret = tee_client_invoke_func(priv->ctx, &inv_arg, param);\n\tif (ret < 0 || inv_arg.ret != 0)\n\t\treturn ret ? ret : -EPROTO;\n\n\treturn 0;\n}\n\nstatic int optee_rtc_readoffset(struct device *dev, long *offset)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\tstruct tee_ioctl_invoke_arg inv_arg = {0};\n\tstruct tee_param param[4] = {0};\n\tint ret;\n\n\tif (!(priv->features & TA_RTC_FEATURE_CORRECTION))\n\t\treturn -EOPNOTSUPP;\n\n\tinv_arg.func = TA_CMD_RTC_GET_OFFSET;\n\tinv_arg.session = priv->session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;\n\n\tret = tee_client_invoke_func(priv->ctx, &inv_arg, param);\n\tif (ret < 0 || inv_arg.ret != 0)\n\t\treturn ret ? ret : -EPROTO;\n\n\t*offset = param[0].u.value.a;\n\n\treturn 0;\n}\n\nstatic int optee_rtc_setoffset(struct device *dev, long offset)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\tstruct tee_ioctl_invoke_arg inv_arg = {0};\n\tstruct tee_param param[4] = {0};\n\tint ret;\n\n\tif (!(priv->features & TA_RTC_FEATURE_CORRECTION))\n\t\treturn -EOPNOTSUPP;\n\n\tinv_arg.func = TA_CMD_RTC_SET_OFFSET;\n\tinv_arg.session = priv->session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;\n\tparam[0].u.value.a = offset;\n\n\tret = tee_client_invoke_func(priv->ctx, &inv_arg, param);\n\tif (ret < 0 || inv_arg.ret != 0)\n\t\treturn ret ? ret : -EPROTO;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops optee_rtc_ops = {\n\t.read_time\t= optee_rtc_readtime,\n\t.set_time\t= optee_rtc_settime,\n\t.set_offset\t= optee_rtc_setoffset,\n\t.read_offset\t= optee_rtc_readoffset,\n};\n\nstatic int optee_rtc_read_info(struct device *dev, struct rtc_device *rtc,\n\t\t\t       u64 *features)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\tstruct tee_ioctl_invoke_arg inv_arg = {0};\n\tstruct tee_param param[4] = {0};\n\tstruct optee_rtc_info *info;\n\tstruct optee_rtc_time *tm;\n\tint ret;\n\n\tinv_arg.func = TA_CMD_RTC_GET_INFO;\n\tinv_arg.session = priv->session_id;\n\tinv_arg.num_params = 4;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[0].u.memref.shm = priv->shm;\n\tparam[0].u.memref.size = sizeof(*info);\n\n\tret = tee_client_invoke_func(priv->ctx, &inv_arg, param);\n\tif (ret < 0 || inv_arg.ret != 0)\n\t\treturn ret ? ret : -EPROTO;\n\n\tinfo = tee_shm_get_va(priv->shm, 0);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tif (param[0].u.memref.size != sizeof(*info))\n\t\treturn -EPROTO;\n\n\tif (info->version != RTC_INFO_VERSION)\n\t\treturn -EPROTO;\n\n\t*features = info->features;\n\n\ttm = &info->range_min;\n\trtc->range_min = mktime64(tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min,\n\t\t\t\t  tm->tm_sec);\n\ttm = &info->range_max;\n\trtc->range_max = mktime64(tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min,\n\t\t\t\t  tm->tm_sec);\n\n\treturn 0;\n}\n\nstatic int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\tif (ver->impl_id == TEE_IMPL_ID_OPTEE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int optee_rtc_probe(struct device *dev)\n{\n\tstruct tee_client_device *rtc_device = to_tee_client_device(dev);\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\tstruct optee_rtc *priv;\n\tstruct rtc_device *rtc;\n\tstruct tee_shm *shm;\n\tint ret, err;\n\n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\trtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\t \n\tpriv->ctx = tee_client_open_context(NULL, optee_ctx_match, NULL, NULL);\n\tif (IS_ERR(priv->ctx))\n\t\treturn -ENODEV;\n\n\t \n\texport_uuid(sess_arg.uuid, &rtc_device->id.uuid);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;\n\n\tret = tee_client_open_session(priv->ctx, &sess_arg, NULL);\n\tif (ret < 0 || sess_arg.ret != 0) {\n\t\tdev_err(dev, \"tee_client_open_session failed, err: %x\\n\", sess_arg.ret);\n\t\terr = -EINVAL;\n\t\tgoto out_ctx;\n\t}\n\tpriv->session_id = sess_arg.session;\n\n\tshm = tee_shm_alloc_kernel_buf(priv->ctx, sizeof(struct optee_rtc_info));\n\tif (IS_ERR(shm)) {\n\t\tdev_err(priv->dev, \"tee_shm_alloc_kernel_buf failed\\n\");\n\t\terr = PTR_ERR(shm);\n\t\tgoto out_sess;\n\t}\n\n\tpriv->shm = shm;\n\tpriv->dev = dev;\n\tdev_set_drvdata(dev, priv);\n\n\trtc->ops = &optee_rtc_ops;\n\n\terr = optee_rtc_read_info(dev, rtc, &priv->features);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to get RTC features from OP-TEE\\n\");\n\t\tgoto out_shm;\n\t}\n\n\terr = devm_rtc_register_device(rtc);\n\tif (err)\n\t\tgoto out_shm;\n\n\t \n\tif (!(priv->features & TA_RTC_FEATURE_CORRECTION))\n\t\tclear_bit(RTC_FEATURE_CORRECTION, rtc->features);\n\n\treturn 0;\n\nout_shm:\n\ttee_shm_free(priv->shm);\nout_sess:\n\ttee_client_close_session(priv->ctx, priv->session_id);\nout_ctx:\n\ttee_client_close_context(priv->ctx);\n\n\treturn err;\n}\n\nstatic int optee_rtc_remove(struct device *dev)\n{\n\tstruct optee_rtc *priv = dev_get_drvdata(dev);\n\n\ttee_client_close_session(priv->ctx, priv->session_id);\n\ttee_client_close_context(priv->ctx);\n\n\treturn 0;\n}\n\nstatic const struct tee_client_device_id optee_rtc_id_table[] = {\n\t{UUID_INIT(0xf389f8c8, 0x845f, 0x496c,\n\t\t   0x8b, 0xbe, 0xd6, 0x4b, 0xd2, 0x4c, 0x92, 0xfd)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(tee, optee_rtc_id_table);\n\nstatic struct tee_client_driver optee_rtc_driver = {\n\t.id_table\t= optee_rtc_id_table,\n\t.driver\t\t= {\n\t\t.name\t\t= \"optee_rtc\",\n\t\t.bus\t\t= &tee_bus_type,\n\t\t.probe\t\t= optee_rtc_probe,\n\t\t.remove\t\t= optee_rtc_remove,\n\t},\n};\n\nstatic int __init optee_rtc_mod_init(void)\n{\n\treturn driver_register(&optee_rtc_driver.driver);\n}\n\nstatic void __exit optee_rtc_mod_exit(void)\n{\n\tdriver_unregister(&optee_rtc_driver.driver);\n}\n\nmodule_init(optee_rtc_mod_init);\nmodule_exit(optee_rtc_mod_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Cl\u00e9ment L\u00e9ger <clement.leger@bootlin.com>\");\nMODULE_DESCRIPTION(\"OP-TEE based RTC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}