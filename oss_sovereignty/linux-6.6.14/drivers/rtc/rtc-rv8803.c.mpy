{
  "module_name": "rtc-rv8803.c",
  "hash_id": "8d6207f7ded322159b6196f3c733421a28486d93e278b37a66167188a4db2478",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rv8803.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/log2.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n\n#define RV8803_I2C_TRY_COUNT\t\t4\n\n#define RV8803_SEC\t\t\t0x00\n#define RV8803_MIN\t\t\t0x01\n#define RV8803_HOUR\t\t\t0x02\n#define RV8803_WEEK\t\t\t0x03\n#define RV8803_DAY\t\t\t0x04\n#define RV8803_MONTH\t\t\t0x05\n#define RV8803_YEAR\t\t\t0x06\n#define RV8803_RAM\t\t\t0x07\n#define RV8803_ALARM_MIN\t\t0x08\n#define RV8803_ALARM_HOUR\t\t0x09\n#define RV8803_ALARM_WEEK_OR_DAY\t0x0A\n#define RV8803_EXT\t\t\t0x0D\n#define RV8803_FLAG\t\t\t0x0E\n#define RV8803_CTRL\t\t\t0x0F\n#define RV8803_OSC_OFFSET\t\t0x2C\n\n#define RV8803_EXT_WADA\t\t\tBIT(6)\n\n#define RV8803_FLAG_V1F\t\t\tBIT(0)\n#define RV8803_FLAG_V2F\t\t\tBIT(1)\n#define RV8803_FLAG_AF\t\t\tBIT(3)\n#define RV8803_FLAG_TF\t\t\tBIT(4)\n#define RV8803_FLAG_UF\t\t\tBIT(5)\n\n#define RV8803_CTRL_RESET\t\tBIT(0)\n\n#define RV8803_CTRL_EIE\t\t\tBIT(2)\n#define RV8803_CTRL_AIE\t\t\tBIT(3)\n#define RV8803_CTRL_TIE\t\t\tBIT(4)\n#define RV8803_CTRL_UIE\t\t\tBIT(5)\n\n#define RX8803_CTRL_CSEL\t\tGENMASK(7, 6)\n\n#define RX8900_BACKUP_CTRL\t\t0x18\n#define RX8900_FLAG_SWOFF\t\tBIT(2)\n#define RX8900_FLAG_VDETOFF\t\tBIT(3)\n\nenum rv8803_type {\n\trv_8803,\n\trx_8803,\n\trx_8804,\n\trx_8900\n};\n\nstruct rv8803_data {\n\tstruct i2c_client *client;\n\tstruct rtc_device *rtc;\n\tstruct mutex flags_lock;\n\tu8 ctrl;\n\tu8 backup;\n\tu8 alarm_invalid:1;\n\tenum rv8803_type type;\n};\n\nstatic int rv8803_read_reg(const struct i2c_client *client, u8 reg)\n{\n\tint try = RV8803_I2C_TRY_COUNT;\n\ts32 ret;\n\n\t \n\tdo\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\twhile ((ret == -ENXIO || ret == -EIO) && --try);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Unable to read register 0x%02x\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int rv8803_read_regs(const struct i2c_client *client,\n\t\t\t    u8 reg, u8 count, u8 *values)\n{\n\tint try = RV8803_I2C_TRY_COUNT;\n\ts32 ret;\n\n\tdo\n\t\tret = i2c_smbus_read_i2c_block_data(client, reg, count, values);\n\twhile ((ret == -ENXIO || ret == -EIO) && --try);\n\tif (ret != count) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to read registers 0x%02x..0x%02x\\n\",\n\t\t\treg, reg + count - 1);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv8803_write_reg(const struct i2c_client *client, u8 reg, u8 value)\n{\n\tint try = RV8803_I2C_TRY_COUNT;\n\ts32 ret;\n\n\tdo\n\t\tret = i2c_smbus_write_byte_data(client, reg, value);\n\twhile ((ret == -ENXIO || ret == -EIO) && --try);\n\tif (ret)\n\t\tdev_err(&client->dev, \"Unable to write register 0x%02x\\n\", reg);\n\n\treturn ret;\n}\n\nstatic int rv8803_write_regs(const struct i2c_client *client,\n\t\t\t     u8 reg, u8 count, const u8 *values)\n{\n\tint try = RV8803_I2C_TRY_COUNT;\n\ts32 ret;\n\n\tdo\n\t\tret = i2c_smbus_write_i2c_block_data(client, reg, count,\n\t\t\t\t\t\t     values);\n\twhile ((ret == -ENXIO || ret == -EIO) && --try);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to write registers 0x%02x..0x%02x\\n\",\n\t\t\treg, reg + count - 1);\n\n\treturn ret;\n}\n\nstatic int rv8803_regs_init(struct rv8803_data *rv8803)\n{\n\tint ret;\n\n\tret = rv8803_write_reg(rv8803->client, RV8803_OSC_OFFSET, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv8803_write_reg(rv8803->client, RV8803_CTRL,\n\t\t\t       FIELD_PREP(RX8803_CTRL_CSEL, 1));  \n\tif (ret)\n\t\treturn ret;\n\n\tret = rv8803_write_regs(rv8803->client, RV8803_ALARM_MIN, 3,\n\t\t\t\t(u8[]){ 0, 0, 0 });\n\tif (ret)\n\t\treturn ret;\n\n\treturn rv8803_write_reg(rv8803->client, RV8803_RAM, 0x00);\n}\n\nstatic int rv8803_regs_configure(struct rv8803_data *rv8803);\n\nstatic int rv8803_regs_reset(struct rv8803_data *rv8803, bool full)\n{\n\t \n\tif (full || rv8803->type == rx_8803 || rv8803->type == rx_8900) {\n\t\tint ret = rv8803_regs_init(rv8803);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn rv8803_regs_configure(rv8803);\n}\n\nstatic irqreturn_t rv8803_handle_irq(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct rv8803_data *rv8803 = i2c_get_clientdata(client);\n\tunsigned long events = 0;\n\tint flags;\n\n\tmutex_lock(&rv8803->flags_lock);\n\n\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\tif (flags <= 0) {\n\t\tmutex_unlock(&rv8803->flags_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (flags & RV8803_FLAG_V1F)\n\t\tdev_warn(&client->dev, \"Voltage low, temperature compensation stopped.\\n\");\n\n\tif (flags & RV8803_FLAG_V2F)\n\t\tdev_warn(&client->dev, \"Voltage low, data loss detected.\\n\");\n\n\tif (flags & RV8803_FLAG_TF) {\n\t\tflags &= ~RV8803_FLAG_TF;\n\t\trv8803->ctrl &= ~RV8803_CTRL_TIE;\n\t\tevents |= RTC_PF;\n\t}\n\n\tif (flags & RV8803_FLAG_AF) {\n\t\tflags &= ~RV8803_FLAG_AF;\n\t\trv8803->ctrl &= ~RV8803_CTRL_AIE;\n\t\tevents |= RTC_AF;\n\t}\n\n\tif (flags & RV8803_FLAG_UF) {\n\t\tflags &= ~RV8803_FLAG_UF;\n\t\trv8803->ctrl &= ~RV8803_CTRL_UIE;\n\t\tevents |= RTC_UF;\n\t}\n\n\tif (events) {\n\t\trtc_update_irq(rv8803->rtc, 1, events);\n\t\trv8803_write_reg(client, RV8803_FLAG, flags);\n\t\trv8803_write_reg(rv8803->client, RV8803_CTRL, rv8803->ctrl);\n\t}\n\n\tmutex_unlock(&rv8803->flags_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rv8803_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tu8 date1[7];\n\tu8 date2[7];\n\tu8 *date = date1;\n\tint ret, flags;\n\n\tif (rv8803->alarm_invalid) {\n\t\tdev_warn(dev, \"Corruption detected, data may be invalid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflags = rv8803_read_reg(rv8803->client, RV8803_FLAG);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (flags & RV8803_FLAG_V2F) {\n\t\tdev_warn(dev, \"Voltage low, data is invalid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rv8803_read_regs(rv8803->client, RV8803_SEC, 7, date);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((date1[RV8803_SEC] & 0x7f) == bin2bcd(59)) {\n\t\tret = rv8803_read_regs(rv8803->client, RV8803_SEC, 7, date2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((date2[RV8803_SEC] & 0x7f) != bin2bcd(59))\n\t\t\tdate = date2;\n\t}\n\n\ttm->tm_sec  = bcd2bin(date[RV8803_SEC] & 0x7f);\n\ttm->tm_min  = bcd2bin(date[RV8803_MIN] & 0x7f);\n\ttm->tm_hour = bcd2bin(date[RV8803_HOUR] & 0x3f);\n\ttm->tm_wday = ilog2(date[RV8803_WEEK] & 0x7f);\n\ttm->tm_mday = bcd2bin(date[RV8803_DAY] & 0x3f);\n\ttm->tm_mon  = bcd2bin(date[RV8803_MONTH] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(date[RV8803_YEAR]) + 100;\n\n\treturn 0;\n}\n\nstatic int rv8803_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ctrl, flags, ret;\n\n\tctrl = rv8803_read_reg(rv8803->client, RV8803_CTRL);\n\tif (ctrl < 0)\n\t\treturn ctrl;\n\n\t \n\tret = rv8803_write_reg(rv8803->client, RV8803_CTRL,\n\t\t\t       ctrl | RV8803_CTRL_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tdate[RV8803_SEC]   = bin2bcd(tm->tm_sec);\n\tdate[RV8803_MIN]   = bin2bcd(tm->tm_min);\n\tdate[RV8803_HOUR]  = bin2bcd(tm->tm_hour);\n\tdate[RV8803_WEEK]  = 1 << (tm->tm_wday);\n\tdate[RV8803_DAY]   = bin2bcd(tm->tm_mday);\n\tdate[RV8803_MONTH] = bin2bcd(tm->tm_mon + 1);\n\tdate[RV8803_YEAR]  = bin2bcd(tm->tm_year - 100);\n\n\tret = rv8803_write_regs(rv8803->client, RV8803_SEC, 7, date);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rv8803_write_reg(rv8803->client, RV8803_CTRL,\n\t\t\t       ctrl & ~RV8803_CTRL_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rv8803->flags_lock);\n\n\tflags = rv8803_read_reg(rv8803->client, RV8803_FLAG);\n\tif (flags < 0) {\n\t\tmutex_unlock(&rv8803->flags_lock);\n\t\treturn flags;\n\t}\n\n\tif ((flags & RV8803_FLAG_V2F) || rv8803->alarm_invalid) {\n\t\t \n\t\tret = rv8803_regs_reset(rv8803, rv8803->alarm_invalid);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&rv8803->flags_lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\trv8803->alarm_invalid = false;\n\t}\n\n\tret = rv8803_write_reg(rv8803->client, RV8803_FLAG,\n\t\t\t       flags & ~(RV8803_FLAG_V1F | RV8803_FLAG_V2F));\n\n\tmutex_unlock(&rv8803->flags_lock);\n\n\treturn ret;\n}\n\nstatic int rv8803_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = rv8803->client;\n\tu8 alarmvals[3];\n\tint flags, ret;\n\n\tret = rv8803_read_regs(client, RV8803_ALARM_MIN, 3, alarmvals);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\tif (flags < 0)\n\t\treturn flags;\n\n\talarmvals[0] &= 0x7f;\n\talarmvals[1] &= 0x3f;\n\talarmvals[2] &= 0x3f;\n\n\tif (!bcd_is_valid(alarmvals[0]) ||\n\t    !bcd_is_valid(alarmvals[1]) ||\n\t    !bcd_is_valid(alarmvals[2]))\n\t\tgoto err_invalid;\n\n\talrm->time.tm_sec  = 0;\n\talrm->time.tm_min  = bcd2bin(alarmvals[0]);\n\talrm->time.tm_hour = bcd2bin(alarmvals[1]);\n\talrm->time.tm_mday = bcd2bin(alarmvals[2]);\n\n\talrm->enabled = !!(rv8803->ctrl & RV8803_CTRL_AIE);\n\talrm->pending = (flags & RV8803_FLAG_AF) && alrm->enabled;\n\n\tif ((unsigned int)alrm->time.tm_mday > 31 ||\n\t    (unsigned int)alrm->time.tm_hour >= 24 ||\n\t    (unsigned int)alrm->time.tm_min >= 60)\n\t\tgoto err_invalid;\n\n\treturn 0;\n\nerr_invalid:\n\trv8803->alarm_invalid = true;\n\treturn -EINVAL;\n}\n\nstatic int rv8803_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tu8 ctrl[2];\n\tint ret, err;\n\n\t \n\tif (alrm->time.tm_sec) {\n\t\ttime64_t alarm_time = rtc_tm_to_time64(&alrm->time);\n\n\t\talarm_time += 60 - alrm->time.tm_sec;\n\t\trtc_time64_to_tm(alarm_time, &alrm->time);\n\t}\n\n\tmutex_lock(&rv8803->flags_lock);\n\n\tret = rv8803_read_regs(client, RV8803_FLAG, 2, ctrl);\n\tif (ret) {\n\t\tmutex_unlock(&rv8803->flags_lock);\n\t\treturn ret;\n\t}\n\n\talarmvals[0] = bin2bcd(alrm->time.tm_min);\n\talarmvals[1] = bin2bcd(alrm->time.tm_hour);\n\talarmvals[2] = bin2bcd(alrm->time.tm_mday);\n\n\tif (rv8803->ctrl & (RV8803_CTRL_AIE | RV8803_CTRL_UIE)) {\n\t\trv8803->ctrl &= ~(RV8803_CTRL_AIE | RV8803_CTRL_UIE);\n\t\terr = rv8803_write_reg(rv8803->client, RV8803_CTRL,\n\t\t\t\t       rv8803->ctrl);\n\t\tif (err) {\n\t\t\tmutex_unlock(&rv8803->flags_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tctrl[0] &= ~RV8803_FLAG_AF;\n\terr = rv8803_write_reg(rv8803->client, RV8803_FLAG, ctrl[0]);\n\tmutex_unlock(&rv8803->flags_lock);\n\tif (err)\n\t\treturn err;\n\n\terr = rv8803_write_regs(rv8803->client, RV8803_ALARM_MIN, 3, alarmvals);\n\tif (err)\n\t\treturn err;\n\n\tif (alrm->enabled) {\n\t\tif (rv8803->rtc->uie_rtctimer.enabled)\n\t\t\trv8803->ctrl |= RV8803_CTRL_UIE;\n\t\tif (rv8803->rtc->aie_timer.enabled)\n\t\t\trv8803->ctrl |= RV8803_CTRL_AIE;\n\n\t\terr = rv8803_write_reg(rv8803->client, RV8803_CTRL,\n\t\t\t\t       rv8803->ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv8803_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tint ctrl, flags, err;\n\n\tctrl = rv8803->ctrl;\n\n\tif (enabled) {\n\t\tif (rv8803->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RV8803_CTRL_UIE;\n\t\tif (rv8803->rtc->aie_timer.enabled)\n\t\t\tctrl |= RV8803_CTRL_AIE;\n\t} else {\n\t\tif (!rv8803->rtc->uie_rtctimer.enabled)\n\t\t\tctrl &= ~RV8803_CTRL_UIE;\n\t\tif (!rv8803->rtc->aie_timer.enabled)\n\t\t\tctrl &= ~RV8803_CTRL_AIE;\n\t}\n\n\tmutex_lock(&rv8803->flags_lock);\n\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\tif (flags < 0) {\n\t\tmutex_unlock(&rv8803->flags_lock);\n\t\treturn flags;\n\t}\n\tflags &= ~(RV8803_FLAG_AF | RV8803_FLAG_UF);\n\terr = rv8803_write_reg(client, RV8803_FLAG, flags);\n\tmutex_unlock(&rv8803->flags_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (ctrl != rv8803->ctrl) {\n\t\trv8803->ctrl = ctrl;\n\t\terr = rv8803_write_reg(client, RV8803_CTRL, rv8803->ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv8803_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\n\tunsigned int vl = 0;\n\tint flags, ret = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\t\tif (flags < 0)\n\t\t\treturn flags;\n\n\t\tif (flags & RV8803_FLAG_V1F) {\n\t\t\tdev_warn(&client->dev, \"Voltage low, temperature compensation stopped.\\n\");\n\t\t\tvl = RTC_VL_ACCURACY_LOW;\n\t\t}\n\n\t\tif (flags & RV8803_FLAG_V2F)\n\t\t\tvl |= RTC_VL_DATA_INVALID;\n\n\t\treturn put_user(vl, (unsigned int __user *)arg);\n\n\tcase RTC_VL_CLR:\n\t\tmutex_lock(&rv8803->flags_lock);\n\t\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\t\tif (flags < 0) {\n\t\t\tmutex_unlock(&rv8803->flags_lock);\n\t\t\treturn flags;\n\t\t}\n\n\t\tflags &= ~RV8803_FLAG_V1F;\n\t\tret = rv8803_write_reg(client, RV8803_FLAG, flags);\n\t\tmutex_unlock(&rv8803->flags_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int rv8803_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\treturn rv8803_write_reg(priv, RV8803_RAM, *(u8 *)val);\n}\n\nstatic int rv8803_nvram_read(void *priv, unsigned int offset,\n\t\t\t     void *val, size_t bytes)\n{\n\tint ret;\n\n\tret = rv8803_read_reg(priv, RV8803_RAM);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*(u8 *)val = ret;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops rv8803_rtc_ops = {\n\t.read_time = rv8803_get_time,\n\t.set_time = rv8803_set_time,\n\t.ioctl = rv8803_ioctl,\n\t.read_alarm = rv8803_get_alarm,\n\t.set_alarm = rv8803_set_alarm,\n\t.alarm_irq_enable = rv8803_alarm_irq_enable,\n};\n\nstatic int rx8900_trickle_charger_init(struct rv8803_data *rv8803)\n{\n\tstruct i2c_client *client = rv8803->client;\n\tstruct device_node *node = client->dev.of_node;\n\tint err;\n\tu8 flags;\n\n\tif (!node)\n\t\treturn 0;\n\n\tif (rv8803->type != rx_8900)\n\t\treturn 0;\n\n\terr = i2c_smbus_read_byte_data(rv8803->client, RX8900_BACKUP_CTRL);\n\tif (err < 0)\n\t\treturn err;\n\n\tflags = (u8)err;\n\tflags &= ~(RX8900_FLAG_VDETOFF | RX8900_FLAG_SWOFF);\n\tflags |= rv8803->backup;\n\n\treturn i2c_smbus_write_byte_data(rv8803->client, RX8900_BACKUP_CTRL,\n\t\t\t\t\t flags);\n}\n\n \nstatic int rv8803_regs_configure(struct rv8803_data *rv8803)\n{\n\tint err;\n\n\terr = rv8803_write_reg(rv8803->client, RV8803_EXT, RV8803_EXT_WADA);\n\tif (err)\n\t\treturn err;\n\n\terr = rx8900_trickle_charger_init(rv8803);\n\tif (err) {\n\t\tdev_err(&rv8803->client->dev, \"failed to init charger\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id rv8803_id[] = {\n\t{ \"rv8803\", rv_8803 },\n\t{ \"rv8804\", rx_8804 },\n\t{ \"rx8803\", rx_8803 },\n\t{ \"rx8900\", rx_8900 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rv8803_id);\n\nstatic int rv8803_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct rv8803_data *rv8803;\n\tint err, flags;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"rv8803_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = 1,\n\t\t.reg_read = rv8803_nvram_read,\n\t\t.reg_write = rv8803_nvram_write,\n\t\t.priv = client,\n\t};\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&adapter->dev, \"doesn't support I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK\\n\");\n\t\treturn -EIO;\n\t}\n\n\trv8803 = devm_kzalloc(&client->dev, sizeof(struct rv8803_data),\n\t\t\t      GFP_KERNEL);\n\tif (!rv8803)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&rv8803->flags_lock);\n\trv8803->client = client;\n\tif (client->dev.of_node) {\n\t\trv8803->type = (uintptr_t)of_device_get_match_data(&client->dev);\n\t} else {\n\t\tconst struct i2c_device_id *id = i2c_match_id(rv8803_id, client);\n\n\t\trv8803->type = id->driver_data;\n\t}\n\ti2c_set_clientdata(client, rv8803);\n\n\tflags = rv8803_read_reg(client, RV8803_FLAG);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (flags & RV8803_FLAG_V1F)\n\t\tdev_warn(&client->dev, \"Voltage low, temperature compensation stopped.\\n\");\n\n\tif (flags & RV8803_FLAG_V2F)\n\t\tdev_warn(&client->dev, \"Voltage low, data loss detected.\\n\");\n\n\tif (flags & RV8803_FLAG_AF)\n\t\tdev_warn(&client->dev, \"An alarm maybe have been missed.\\n\");\n\n\trv8803->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rv8803->rtc))\n\t\treturn PTR_ERR(rv8803->rtc);\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, rv8803_handle_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"rv8803\", client);\n\t\tif (err) {\n\t\t\tdev_warn(&client->dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\tif (!client->irq)\n\t\tclear_bit(RTC_FEATURE_ALARM, rv8803->rtc->features);\n\n\tif (of_property_read_bool(client->dev.of_node, \"epson,vdet-disable\"))\n\t\trv8803->backup |= RX8900_FLAG_VDETOFF;\n\n\tif (of_property_read_bool(client->dev.of_node, \"trickle-diode-disable\"))\n\t\trv8803->backup |= RX8900_FLAG_SWOFF;\n\n\terr = rv8803_regs_configure(rv8803);\n\tif (err)\n\t\treturn err;\n\n\trv8803->rtc->ops = &rv8803_rtc_ops;\n\trv8803->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trv8803->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\terr = devm_rtc_register_device(rv8803->rtc);\n\tif (err)\n\t\treturn err;\n\n\tdevm_rtc_nvmem_register(rv8803->rtc, &nvmem_cfg);\n\n\trv8803->rtc->max_user_freq = 1;\n\n\treturn 0;\n}\n\nstatic const __maybe_unused struct of_device_id rv8803_of_match[] = {\n\t{\n\t\t.compatible = \"microcrystal,rv8803\",\n\t\t.data = (void *)rv_8803\n\t},\n\t{\n\t\t.compatible = \"epson,rx8803\",\n\t\t.data = (void *)rx_8803\n\t},\n\t{\n\t\t.compatible = \"epson,rx8804\",\n\t\t.data = (void *)rx_8804\n\t},\n\t{\n\t\t.compatible = \"epson,rx8900\",\n\t\t.data = (void *)rx_8900\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rv8803_of_match);\n\nstatic struct i2c_driver rv8803_driver = {\n\t.driver = {\n\t\t.name = \"rtc-rv8803\",\n\t\t.of_match_table = of_match_ptr(rv8803_of_match),\n\t},\n\t.probe\t\t= rv8803_probe,\n\t.id_table\t= rv8803_id,\n};\nmodule_i2c_driver(rv8803_driver);\n\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_DESCRIPTION(\"Micro Crystal RV8803 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}