{
  "module_name": "rtc-mc146818-lib.c",
  "hash_id": "dbfe3770381b94a2e2351369000e2c3903777e71b8e6eb8840ebb3be56b27ace",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mc146818-lib.c",
  "human_readable_source": "\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/mc146818rtc.h>\n\n#ifdef CONFIG_ACPI\n#include <linux/acpi.h>\n#endif\n\n \nbool mc146818_avoid_UIP(void (*callback)(unsigned char seconds, void *param),\n\t\t\tvoid *param)\n{\n\tint i;\n\tunsigned long flags;\n\tunsigned char seconds;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tspin_lock_irqsave(&rtc_lock, flags);\n\n\t\t \n\t\tseconds = CMOS_READ(RTC_SECONDS);\n\n\t\tif (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP) {\n\t\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t\t\tudelay(100);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (seconds != CMOS_READ(RTC_SECONDS)) {\n\t\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (callback)\n\t\t\tcallback(seconds, param);\n\n\t\t \n\t\tif (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP) {\n\t\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t\t\tudelay(100);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (seconds != CMOS_READ(RTC_SECONDS)) {\n\t\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mc146818_avoid_UIP);\n\n \nbool mc146818_does_rtc_work(void)\n{\n\treturn mc146818_avoid_UIP(NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(mc146818_does_rtc_work);\n\nstruct mc146818_get_time_callback_param {\n\tstruct rtc_time *time;\n\tunsigned char ctrl;\n#ifdef CONFIG_ACPI\n\tunsigned char century;\n#endif\n#ifdef CONFIG_MACH_DECSTATION\n\tunsigned int real_year;\n#endif\n};\n\nstatic void mc146818_get_time_callback(unsigned char seconds, void *param_in)\n{\n\tstruct mc146818_get_time_callback_param *p = param_in;\n\n\t \n\tp->time->tm_sec = seconds;\n\tp->time->tm_min = CMOS_READ(RTC_MINUTES);\n\tp->time->tm_hour = CMOS_READ(RTC_HOURS);\n\tp->time->tm_mday = CMOS_READ(RTC_DAY_OF_MONTH);\n\tp->time->tm_mon = CMOS_READ(RTC_MONTH);\n\tp->time->tm_year = CMOS_READ(RTC_YEAR);\n#ifdef CONFIG_MACH_DECSTATION\n\tp->real_year = CMOS_READ(RTC_DEC_YEAR);\n#endif\n#ifdef CONFIG_ACPI\n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&\n\t    acpi_gbl_FADT.century) {\n\t\tp->century = CMOS_READ(acpi_gbl_FADT.century);\n\t} else {\n\t\tp->century = 0;\n\t}\n#endif\n\n\tp->ctrl = CMOS_READ(RTC_CONTROL);\n}\n\nint mc146818_get_time(struct rtc_time *time)\n{\n\tstruct mc146818_get_time_callback_param p = {\n\t\t.time = time\n\t};\n\n\tif (!mc146818_avoid_UIP(mc146818_get_time_callback, &p)) {\n\t\tmemset(time, 0, sizeof(*time));\n\t\treturn -EIO;\n\t}\n\n\tif (!(p.ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD)\n\t{\n\t\ttime->tm_sec = bcd2bin(time->tm_sec);\n\t\ttime->tm_min = bcd2bin(time->tm_min);\n\t\ttime->tm_hour = bcd2bin(time->tm_hour);\n\t\ttime->tm_mday = bcd2bin(time->tm_mday);\n\t\ttime->tm_mon = bcd2bin(time->tm_mon);\n\t\ttime->tm_year = bcd2bin(time->tm_year);\n#ifdef CONFIG_ACPI\n\t\tp.century = bcd2bin(p.century);\n#endif\n\t}\n\n#ifdef CONFIG_MACH_DECSTATION\n\ttime->tm_year += p.real_year - 72;\n#endif\n\n#ifdef CONFIG_ACPI\n\tif (p.century > 19)\n\t\ttime->tm_year += (p.century - 19) * 100;\n#endif\n\n\t \n\tif (time->tm_year <= 69)\n\t\ttime->tm_year += 100;\n\n\ttime->tm_mon--;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mc146818_get_time);\n\n \nstatic bool apply_amd_register_a_behavior(void)\n{\n#ifdef CONFIG_X86\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD ||\n\t    boot_cpu_data.x86_vendor == X86_VENDOR_HYGON)\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n \nint mc146818_set_time(struct rtc_time *time)\n{\n\tunsigned long flags;\n\tunsigned char mon, day, hrs, min, sec;\n\tunsigned char save_control, save_freq_select;\n\tunsigned int yrs;\n#ifdef CONFIG_MACH_DECSTATION\n\tunsigned int real_yrs, leap_yr;\n#endif\n\tunsigned char century = 0;\n\n\tyrs = time->tm_year;\n\tmon = time->tm_mon + 1;    \n\tday = time->tm_mday;\n\thrs = time->tm_hour;\n\tmin = time->tm_min;\n\tsec = time->tm_sec;\n\n\tif (yrs > 255)\t \n\t\treturn -EINVAL;\n\n#ifdef CONFIG_MACH_DECSTATION\n\treal_yrs = yrs;\n\tleap_yr = ((!((yrs + 1900) % 4) && ((yrs + 1900) % 100)) ||\n\t\t\t!((yrs + 1900) % 400));\n\tyrs = 72;\n\n\t \n\tif (!leap_yr && mon < 3) {\n\t\treal_yrs--;\n\t\tyrs = 73;\n\t}\n#endif\n\n#ifdef CONFIG_ACPI\n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&\n\t    acpi_gbl_FADT.century) {\n\t\tcentury = (yrs + 1900) / 100;\n\t\tyrs %= 100;\n\t}\n#endif\n\n\t \n\tif (yrs > 169)\n\t\treturn -EINVAL;\n\n\tif (yrs >= 100)\n\t\tyrs -= 100;\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\tsave_control = CMOS_READ(RTC_CONTROL);\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n\tif (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {\n\t\tsec = bin2bcd(sec);\n\t\tmin = bin2bcd(min);\n\t\thrs = bin2bcd(hrs);\n\t\tday = bin2bcd(day);\n\t\tmon = bin2bcd(mon);\n\t\tyrs = bin2bcd(yrs);\n\t\tcentury = bin2bcd(century);\n\t}\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\tsave_control = CMOS_READ(RTC_CONTROL);\n\tCMOS_WRITE((save_control|RTC_SET), RTC_CONTROL);\n\tsave_freq_select = CMOS_READ(RTC_FREQ_SELECT);\n\tif (apply_amd_register_a_behavior())\n\t\tCMOS_WRITE((save_freq_select & ~RTC_AMD_BANK_SELECT), RTC_FREQ_SELECT);\n\telse\n\t\tCMOS_WRITE((save_freq_select|RTC_DIV_RESET2), RTC_FREQ_SELECT);\n\n#ifdef CONFIG_MACH_DECSTATION\n\tCMOS_WRITE(real_yrs, RTC_DEC_YEAR);\n#endif\n\tCMOS_WRITE(yrs, RTC_YEAR);\n\tCMOS_WRITE(mon, RTC_MONTH);\n\tCMOS_WRITE(day, RTC_DAY_OF_MONTH);\n\tCMOS_WRITE(hrs, RTC_HOURS);\n\tCMOS_WRITE(min, RTC_MINUTES);\n\tCMOS_WRITE(sec, RTC_SECONDS);\n#ifdef CONFIG_ACPI\n\tif (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&\n\t    acpi_gbl_FADT.century)\n\t\tCMOS_WRITE(century, acpi_gbl_FADT.century);\n#endif\n\n\tCMOS_WRITE(save_control, RTC_CONTROL);\n\tCMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);\n\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mc146818_set_time);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}