{
  "module_name": "rtc-at91sam9.c",
  "hash_id": "a54522b7c4f126eb02a68d4cc6f990ac92f6e7d38dd3fe74c747786b7400354b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-at91sam9.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/time.h>\n\n \n\n#define AT91_RTT_MR\t\t0x00\t\t \n#define AT91_RTT_RTPRES\t\t(0xffff << 0)\t \n#define AT91_RTT_ALMIEN\t\tBIT(16)\t\t \n#define AT91_RTT_RTTINCIEN\tBIT(17)\t\t \n#define AT91_RTT_RTTRST\t\tBIT(18)\t\t \n\n#define AT91_RTT_AR\t\t0x04\t\t \n#define AT91_RTT_ALMV\t\t(0xffffffff)\t \n\n#define AT91_RTT_VR\t\t0x08\t\t \n#define AT91_RTT_CRTV\t\t(0xffffffff)\t \n\n#define AT91_RTT_SR\t\t0x0c\t\t \n#define AT91_RTT_ALMS\t\tBIT(0)\t\t \n#define AT91_RTT_RTTINC\t\tBIT(1)\t\t \n\n \n#define ALARM_DISABLED\t((u32)~0)\n\nstruct sam9_rtc {\n\tvoid __iomem\t\t*rtt;\n\tstruct rtc_device\t*rtcdev;\n\tu32\t\t\timr;\n\tstruct regmap\t\t*gpbr;\n\tunsigned int\t\tgpbr_offset;\n\tint\t\t\tirq;\n\tstruct clk\t\t*sclk;\n\tbool\t\t\tsuspended;\n\tunsigned long\t\tevents;\n\tspinlock_t\t\tlock;\n};\n\n#define rtt_readl(rtc, field) \\\n\treadl((rtc)->rtt + AT91_RTT_ ## field)\n#define rtt_writel(rtc, field, val) \\\n\twritel((val), (rtc)->rtt + AT91_RTT_ ## field)\n\nstatic inline unsigned int gpbr_readl(struct sam9_rtc *rtc)\n{\n\tunsigned int val;\n\n\tregmap_read(rtc->gpbr, rtc->gpbr_offset, &val);\n\n\treturn val;\n}\n\nstatic inline void gpbr_writel(struct sam9_rtc *rtc, unsigned int val)\n{\n\tregmap_write(rtc->gpbr, rtc->gpbr_offset, val);\n}\n\n \nstatic int at91_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tu32 secs, secs2;\n\tu32 offset;\n\n\t \n\toffset = gpbr_readl(rtc);\n\tif (offset == 0)\n\t\treturn -EILSEQ;\n\n\t \n\tsecs = rtt_readl(rtc, VR);\n\tsecs2 = rtt_readl(rtc, VR);\n\tif (secs != secs2)\n\t\tsecs = rtt_readl(rtc, VR);\n\n\trtc_time64_to_tm(offset + secs, tm);\n\n\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\n \nstatic int at91_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tu32 offset, alarm, mr;\n\tunsigned long secs;\n\n\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\tmr = rtt_readl(rtc, MR);\n\n\t \n\trtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\n\n\t \n\toffset = gpbr_readl(rtc);\n\n\t \n\tsecs += 1;\n\tgpbr_writel(rtc, secs);\n\n\t \n\talarm = rtt_readl(rtc, AR);\n\tif (alarm != ALARM_DISABLED) {\n\t\tif (offset > secs) {\n\t\t\t \n\t\t\talarm += (offset - secs);\n\t\t} else if ((alarm + offset) > secs) {\n\t\t\t \n\t\t\talarm -= (secs - offset);\n\t\t} else {\n\t\t\t \n\t\t\talarm = ALARM_DISABLED;\n\t\t\tmr &= ~AT91_RTT_ALMIEN;\n\t\t}\n\t\trtt_writel(rtc, AR, alarm);\n\t}\n\n\t \n\trtt_writel(rtc, MR, mr | AT91_RTT_RTTRST);\n\n\treturn 0;\n}\n\nstatic int at91_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tu32 alarm = rtt_readl(rtc, AR);\n\tu32 offset;\n\n\toffset = gpbr_readl(rtc);\n\tif (offset == 0)\n\t\treturn -EILSEQ;\n\n\tmemset(alrm, 0, sizeof(*alrm));\n\tif (alarm != ALARM_DISABLED) {\n\t\trtc_time64_to_tm(offset + alarm, tm);\n\n\t\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\t\tif (rtt_readl(rtc, MR) & AT91_RTT_ALMIEN)\n\t\t\talrm->enabled = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned long secs;\n\tu32 offset;\n\tu32 mr;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\toffset = gpbr_readl(rtc);\n\tif (offset == 0) {\n\t\t \n\t\treturn -EILSEQ;\n\t}\n\tmr = rtt_readl(rtc, MR);\n\trtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\n\n\t \n\tif (secs <= offset) {\n\t\trtt_writel(rtc, AR, ALARM_DISABLED);\n\t\treturn 0;\n\t}\n\n\t \n\trtt_writel(rtc, AR, secs - offset);\n\tif (alrm->enabled)\n\t\trtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\n\n\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic int at91_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tu32 mr = rtt_readl(rtc, MR);\n\n\tdev_dbg(dev, \"alarm_irq_enable: enabled=%08x, mr %08x\\n\", enabled, mr);\n\tif (enabled)\n\t\trtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\n\telse\n\t\trtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\n\treturn 0;\n}\n\n \nstatic int at91_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct sam9_rtc *rtc = dev_get_drvdata(dev);\n\tu32 mr = rtt_readl(rtc, MR);\n\n\tseq_printf(seq, \"update_IRQ\\t: %s\\n\",\n\t\t   (mr & AT91_RTT_RTTINCIEN) ? \"yes\" : \"no\");\n\treturn 0;\n}\n\nstatic irqreturn_t at91_rtc_cache_events(struct sam9_rtc *rtc)\n{\n\tu32 sr, mr;\n\n\t \n\tmr = rtt_readl(rtc, MR) & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\n\tsr = rtt_readl(rtc, SR) & (mr >> 16);\n\tif (!sr)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (sr & AT91_RTT_ALMS)\n\t\trtc->events |= (RTC_AF | RTC_IRQF);\n\n\t \n\tif (sr & AT91_RTT_RTTINC)\n\t\trtc->events |= (RTC_UF | RTC_IRQF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void at91_rtc_flush_events(struct sam9_rtc *rtc)\n{\n\tif (!rtc->events)\n\t\treturn;\n\n\trtc_update_irq(rtc->rtcdev, 1, rtc->events);\n\trtc->events = 0;\n\n\tpr_debug(\"%s: num=%ld, events=0x%02lx\\n\", __func__,\n\t\t rtc->events >> 8, rtc->events & 0x000000FF);\n}\n\n \nstatic irqreturn_t at91_rtc_interrupt(int irq, void *_rtc)\n{\n\tstruct sam9_rtc *rtc = _rtc;\n\tint ret;\n\n\tspin_lock(&rtc->lock);\n\n\tret = at91_rtc_cache_events(rtc);\n\n\t \n\tif (rtc->suspended) {\n\t\t \n\t\trtt_writel(rtc, MR,\n\t\t\t   rtt_readl(rtc, MR) &\n\t\t\t   ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\n\t\t \n\t\tpm_system_wakeup();\n\t} else {\n\t\tat91_rtc_flush_events(rtc);\n\t}\n\n\tspin_unlock(&rtc->lock);\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops at91_rtc_ops = {\n\t.read_time\t= at91_rtc_readtime,\n\t.set_time\t= at91_rtc_settime,\n\t.read_alarm\t= at91_rtc_readalarm,\n\t.set_alarm\t= at91_rtc_setalarm,\n\t.proc\t\t= at91_rtc_proc,\n\t.alarm_irq_enable = at91_rtc_alarm_irq_enable,\n};\n\n \nstatic int at91_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sam9_rtc\t*rtc;\n\tint\t\tret, irq;\n\tu32\t\tmr;\n\tunsigned int\tsclk_rate;\n\tstruct of_phandle_args args;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&rtc->lock);\n\trtc->irq = irq;\n\n\t \n\tif (!device_can_wakeup(&pdev->dev))\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtt = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->rtt))\n\t\treturn PTR_ERR(rtc->rtt);\n\n\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t       \"atmel,rtt-rtc-time-reg\", 1, 0,\n\t\t\t\t\t       &args);\n\tif (ret)\n\t\treturn ret;\n\n\trtc->gpbr = syscon_node_to_regmap(args.np);\n\trtc->gpbr_offset = args.args[0];\n\tif (IS_ERR(rtc->gpbr)) {\n\t\tdev_err(&pdev->dev, \"failed to retrieve gpbr regmap, aborting.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtc->sclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(rtc->sclk))\n\t\treturn PTR_ERR(rtc->sclk);\n\n\tret = clk_prepare_enable(rtc->sclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not enable slow clock\\n\");\n\t\treturn ret;\n\t}\n\n\tsclk_rate = clk_get_rate(rtc->sclk);\n\tif (!sclk_rate || sclk_rate > AT91_RTT_RTPRES) {\n\t\tdev_err(&pdev->dev, \"Invalid slow clock rate\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk;\n\t}\n\n\tmr = rtt_readl(rtc, MR);\n\n\t \n\tif ((mr & AT91_RTT_RTPRES) != sclk_rate) {\n\t\tmr = AT91_RTT_RTTRST | (sclk_rate & AT91_RTT_RTPRES);\n\t\tgpbr_writel(rtc, 0);\n\t}\n\n\t \n\tmr &= ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\n\trtt_writel(rtc, MR, mr);\n\n\trtc->rtcdev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtcdev)) {\n\t\tret = PTR_ERR(rtc->rtcdev);\n\t\tgoto err_clk;\n\t}\n\n\trtc->rtcdev->ops = &at91_rtc_ops;\n\trtc->rtcdev->range_max = U32_MAX;\n\n\t \n\tret = devm_request_irq(&pdev->dev, rtc->irq, at91_rtc_interrupt,\n\t\t\t       IRQF_SHARED | IRQF_COND_SUSPEND,\n\t\t\t       dev_name(&rtc->rtcdev->dev), rtc);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"can't share IRQ %d?\\n\", rtc->irq);\n\t\tgoto err_clk;\n\t}\n\n\t \n\n\tif (gpbr_readl(rtc) == 0)\n\t\tdev_warn(&pdev->dev, \"%s: SET TIME!\\n\",\n\t\t\t dev_name(&rtc->rtcdev->dev));\n\n\treturn devm_rtc_register_device(rtc->rtcdev);\n\nerr_clk:\n\tclk_disable_unprepare(rtc->sclk);\n\n\treturn ret;\n}\n\n \nstatic void at91_rtc_remove(struct platform_device *pdev)\n{\n\tstruct sam9_rtc\t*rtc = platform_get_drvdata(pdev);\n\tu32\t\tmr = rtt_readl(rtc, MR);\n\n\t \n\trtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\n\n\tclk_disable_unprepare(rtc->sclk);\n}\n\nstatic void at91_rtc_shutdown(struct platform_device *pdev)\n{\n\tstruct sam9_rtc\t*rtc = platform_get_drvdata(pdev);\n\tu32\t\tmr = rtt_readl(rtc, MR);\n\n\trtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\n\trtt_writel(rtc, MR, mr & ~rtc->imr);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\n \n\nstatic int at91_rtc_suspend(struct device *dev)\n{\n\tstruct sam9_rtc\t*rtc = dev_get_drvdata(dev);\n\tu32\t\tmr = rtt_readl(rtc, MR);\n\n\t \n\trtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\n\tif (rtc->imr) {\n\t\tif (device_may_wakeup(dev) && (mr & AT91_RTT_ALMIEN)) {\n\t\t\tunsigned long flags;\n\n\t\t\tenable_irq_wake(rtc->irq);\n\t\t\tspin_lock_irqsave(&rtc->lock, flags);\n\t\t\trtc->suspended = true;\n\t\t\tspin_unlock_irqrestore(&rtc->lock, flags);\n\t\t\t \n\t\t\tif (mr & AT91_RTT_RTTINCIEN)\n\t\t\t\trtt_writel(rtc, MR, mr & ~AT91_RTT_RTTINCIEN);\n\t\t} else {\n\t\t\trtt_writel(rtc, MR, mr & ~rtc->imr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_rtc_resume(struct device *dev)\n{\n\tstruct sam9_rtc\t*rtc = dev_get_drvdata(dev);\n\tu32\t\tmr;\n\n\tif (rtc->imr) {\n\t\tunsigned long flags;\n\n\t\tif (device_may_wakeup(dev))\n\t\t\tdisable_irq_wake(rtc->irq);\n\t\tmr = rtt_readl(rtc, MR);\n\t\trtt_writel(rtc, MR, mr | rtc->imr);\n\n\t\tspin_lock_irqsave(&rtc->lock, flags);\n\t\trtc->suspended = false;\n\t\tat91_rtc_cache_events(rtc);\n\t\tat91_rtc_flush_events(rtc);\n\t\tspin_unlock_irqrestore(&rtc->lock, flags);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(at91_rtc_pm_ops, at91_rtc_suspend, at91_rtc_resume);\n\nstatic const struct of_device_id at91_rtc_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9260-rtt\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, at91_rtc_dt_ids);\n\nstatic struct platform_driver at91_rtc_driver = {\n\t.probe\t\t= at91_rtc_probe,\n\t.remove_new\t= at91_rtc_remove,\n\t.shutdown\t= at91_rtc_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-at91sam9\",\n\t\t.pm\t= &at91_rtc_pm_ops,\n\t\t.of_match_table = at91_rtc_dt_ids,\n\t},\n};\n\nmodule_platform_driver(at91_rtc_driver);\n\nMODULE_AUTHOR(\"Michel Benoit\");\nMODULE_DESCRIPTION(\"RTC driver for Atmel AT91SAM9x\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}