{
  "module_name": "rtc-em3027.c",
  "hash_id": "107c6134b75051206ed6e8fa7943541fd59adeabd94d155a01b92b4f137cd8d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-em3027.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n \n#define EM3027_REG_ON_OFF_CTRL\t0x00\n#define EM3027_REG_IRQ_CTRL\t0x01\n#define EM3027_REG_IRQ_FLAGS\t0x02\n#define EM3027_REG_STATUS\t0x03\n#define EM3027_REG_RST_CTRL\t0x04\n\n#define EM3027_REG_WATCH_SEC\t0x08\n#define EM3027_REG_WATCH_MIN\t0x09\n#define EM3027_REG_WATCH_HOUR\t0x0a\n#define EM3027_REG_WATCH_DATE\t0x0b\n#define EM3027_REG_WATCH_DAY\t0x0c\n#define EM3027_REG_WATCH_MON\t0x0d\n#define EM3027_REG_WATCH_YEAR\t0x0e\n\n#define EM3027_REG_ALARM_SEC\t0x10\n#define EM3027_REG_ALARM_MIN\t0x11\n#define EM3027_REG_ALARM_HOUR\t0x12\n#define EM3027_REG_ALARM_DATE\t0x13\n#define EM3027_REG_ALARM_DAY\t0x14\n#define EM3027_REG_ALARM_MON\t0x15\n#define EM3027_REG_ALARM_YEAR\t0x16\n\nstatic struct i2c_driver em3027_driver;\n\nstatic int em3027_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tunsigned char addr = EM3027_REG_WATCH_SEC;\n\tunsigned char buf[7];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t},\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 7,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\t \n\tif ((i2c_transfer(client->adapter, &msgs[0], 2)) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\ttm->tm_sec\t= bcd2bin(buf[0]);\n\ttm->tm_min\t= bcd2bin(buf[1]);\n\ttm->tm_hour\t= bcd2bin(buf[2]);\n\ttm->tm_mday\t= bcd2bin(buf[3]);\n\ttm->tm_wday\t= bcd2bin(buf[4]);\n\ttm->tm_mon\t= bcd2bin(buf[5]) - 1;\n\ttm->tm_year\t= bcd2bin(buf[6]) + 100;\n\n\treturn 0;\n}\n\nstatic int em3027_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[8];\n\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.len = 8,\n\t\t.buf = buf,\t \n\t};\n\n\tbuf[0] = EM3027_REG_WATCH_SEC;\n\tbuf[1] = bin2bcd(tm->tm_sec);\n\tbuf[2] = bin2bcd(tm->tm_min);\n\tbuf[3] = bin2bcd(tm->tm_hour);\n\tbuf[4] = bin2bcd(tm->tm_mday);\n\tbuf[5] = bin2bcd(tm->tm_wday);\n\tbuf[6] = bin2bcd(tm->tm_mon + 1);\n\tbuf[7] = bin2bcd(tm->tm_year % 100);\n\n\t \n\tif ((i2c_transfer(client->adapter, &msg, 1)) != 1) {\n\t\tdev_err(&client->dev, \"%s: write error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops em3027_rtc_ops = {\n\t.read_time = em3027_get_time,\n\t.set_time = em3027_set_time,\n};\n\nstatic int em3027_probe(struct i2c_client *client)\n{\n\tstruct rtc_device *rtc;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\trtc = devm_rtc_device_register(&client->dev, em3027_driver.driver.name,\n\t\t\t\t  &em3027_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\ti2c_set_clientdata(client, rtc);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id em3027_id[] = {\n\t{ \"em3027\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, em3027_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id em3027_of_match[] = {\n\t{ .compatible = \"emmicro,em3027\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, em3027_of_match);\n#endif\n\nstatic struct i2c_driver em3027_driver = {\n\t.driver = {\n\t\t   .name = \"rtc-em3027\",\n\t\t   .of_match_table = of_match_ptr(em3027_of_match),\n\t},\n\t.probe = em3027_probe,\n\t.id_table = em3027_id,\n};\n\nmodule_i2c_driver(em3027_driver);\n\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_DESCRIPTION(\"EM Microelectronic EM3027 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}