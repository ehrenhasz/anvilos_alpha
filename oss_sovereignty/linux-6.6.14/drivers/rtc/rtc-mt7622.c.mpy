{
  "module_name": "rtc-mt7622.c",
  "hash_id": "90eeb958494cac483fc3d14c0eb66a0db728784c3f730dd5b9ac65d95a504340",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mt7622.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n#define MTK_RTC_DEV KBUILD_MODNAME\n\n#define MTK_RTC_PWRCHK1\t\t0x4\n#define\tRTC_PWRCHK1_MAGIC\t0xc6\n\n#define MTK_RTC_PWRCHK2\t\t0x8\n#define\tRTC_PWRCHK2_MAGIC\t0x9a\n\n#define MTK_RTC_KEY\t\t0xc\n#define\tRTC_KEY_MAGIC\t\t0x59\n\n#define MTK_RTC_PROT1\t\t0x10\n#define\tRTC_PROT1_MAGIC\t\t0xa3\n\n#define MTK_RTC_PROT2\t\t0x14\n#define\tRTC_PROT2_MAGIC\t\t0x57\n\n#define MTK_RTC_PROT3\t\t0x18\n#define\tRTC_PROT3_MAGIC\t\t0x67\n\n#define MTK_RTC_PROT4\t\t0x1c\n#define\tRTC_PROT4_MAGIC\t\t0xd2\n\n#define MTK_RTC_CTL\t\t0x20\n#define\tRTC_RC_STOP\t\tBIT(0)\n\n#define MTK_RTC_DEBNCE\t\t0x2c\n#define\tRTC_DEBNCE_MASK\t\tGENMASK(2, 0)\n\n#define MTK_RTC_INT\t\t0x30\n#define RTC_INT_AL_STA\t\tBIT(4)\n\n \n#define MTK_RTC_TREG(_t, _f)\t(0x40 + (0x4 * (_f)) + ((_t) * 0x20))\n\n#define MTK_RTC_AL_CTL\t\t0x7c\n#define\tRTC_AL_EN\t\tBIT(0)\n#define\tRTC_AL_ALL\t\tGENMASK(7, 0)\n\n \n#define MTK_RTC_TM_YR_OFFSET\t100\n\n \n#define MTK_RTC_TM_YR_L\t\t(MTK_RTC_TM_YR_OFFSET + 1)\n\n \n#define MTK_RTC_HW_YR_LIMIT\t99\n\n \n#define MTK_RTC_TM_YR_H\t\t(MTK_RTC_TM_YR_OFFSET + MTK_RTC_HW_YR_LIMIT)\n\n \n#define MTK_RTC_TM_YR_VALID(_y)\t((_y) >= MTK_RTC_TM_YR_L && \\\n\t\t\t\t (_y) <= MTK_RTC_TM_YR_H)\n\n \nenum {\n\tMTK_TC,\n\tMTK_AL,\n};\n\n \nenum {\n\tMTK_YEA,\n\tMTK_MON,\n\tMTK_DOM,\n\tMTK_DOW,\n\tMTK_HOU,\n\tMTK_MIN,\n\tMTK_SEC\n};\n\nstruct mtk_rtc {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *base;\n\tint irq;\n\tstruct clk *clk;\n};\n\nstatic void mtk_w32(struct mtk_rtc *rtc, u32 reg, u32 val)\n{\n\twritel_relaxed(val, rtc->base + reg);\n}\n\nstatic u32 mtk_r32(struct mtk_rtc *rtc, u32 reg)\n{\n\treturn readl_relaxed(rtc->base + reg);\n}\n\nstatic void mtk_rmw(struct mtk_rtc *rtc, u32 reg, u32 mask, u32 set)\n{\n\tu32 val;\n\n\tval = mtk_r32(rtc, reg);\n\tval &= ~mask;\n\tval |= set;\n\tmtk_w32(rtc, reg, val);\n}\n\nstatic void mtk_set(struct mtk_rtc *rtc, u32 reg, u32 val)\n{\n\tmtk_rmw(rtc, reg, 0, val);\n}\n\nstatic void mtk_clr(struct mtk_rtc *rtc, u32 reg, u32 val)\n{\n\tmtk_rmw(rtc, reg, val, 0);\n}\n\nstatic void mtk_rtc_hw_init(struct mtk_rtc *hw)\n{\n\t \n\tmtk_w32(hw, MTK_RTC_PWRCHK1, RTC_PWRCHK1_MAGIC);\n\tmtk_w32(hw, MTK_RTC_PWRCHK2, RTC_PWRCHK2_MAGIC);\n\tmtk_w32(hw, MTK_RTC_KEY, RTC_KEY_MAGIC);\n\tmtk_w32(hw, MTK_RTC_PROT1, RTC_PROT1_MAGIC);\n\tmtk_w32(hw, MTK_RTC_PROT2, RTC_PROT2_MAGIC);\n\tmtk_w32(hw, MTK_RTC_PROT3, RTC_PROT3_MAGIC);\n\tmtk_w32(hw, MTK_RTC_PROT4, RTC_PROT4_MAGIC);\n\tmtk_rmw(hw, MTK_RTC_DEBNCE, RTC_DEBNCE_MASK, 0);\n\tmtk_clr(hw, MTK_RTC_CTL, RTC_RC_STOP);\n}\n\nstatic void mtk_rtc_get_alarm_or_time(struct mtk_rtc *hw, struct rtc_time *tm,\n\t\t\t\t      int time_alarm)\n{\n\tu32 year, mon, mday, wday, hour, min, sec;\n\n\t \n\tdo {\n\t\tsec = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_SEC));\n\t\tmin = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_MIN));\n\t\thour = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_HOU));\n\t\twday = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_DOW));\n\t\tmday = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_DOM));\n\t\tmon = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_MON));\n\t\tyear = mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_YEA));\n\t} while (sec != mtk_r32(hw, MTK_RTC_TREG(time_alarm, MTK_SEC)));\n\n\ttm->tm_sec  = sec;\n\ttm->tm_min  = min;\n\ttm->tm_hour = hour;\n\ttm->tm_wday = wday;\n\ttm->tm_mday = mday;\n\ttm->tm_mon  = mon - 1;\n\n\t \n\ttm->tm_year = year + MTK_RTC_TM_YR_OFFSET;\n}\n\nstatic void mtk_rtc_set_alarm_or_time(struct mtk_rtc *hw, struct rtc_time *tm,\n\t\t\t\t      int time_alarm)\n{\n\tu32 year;\n\n\t \n\tyear = tm->tm_year - MTK_RTC_TM_YR_OFFSET;\n\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_YEA), year);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_MON), tm->tm_mon + 1);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_DOW), tm->tm_wday);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_DOM), tm->tm_mday);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_HOU), tm->tm_hour);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_MIN), tm->tm_min);\n\tmtk_w32(hw, MTK_RTC_TREG(time_alarm, MTK_SEC), tm->tm_sec);\n}\n\nstatic irqreturn_t mtk_rtc_alarmirq(int irq, void *id)\n{\n\tstruct mtk_rtc *hw = (struct mtk_rtc *)id;\n\tu32 irq_sta;\n\n\tirq_sta = mtk_r32(hw, MTK_RTC_INT);\n\tif (irq_sta & RTC_INT_AL_STA) {\n\t\t \n\t\tmtk_w32(hw, MTK_RTC_AL_CTL, 0);\n\t\trtc_update_irq(hw->rtc, 1, RTC_IRQF | RTC_AF);\n\n\t\t \n\t\tmtk_w32(hw, MTK_RTC_INT, RTC_INT_AL_STA);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mtk_rtc_gettime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\n\tmtk_rtc_get_alarm_or_time(hw, tm, MTK_TC);\n\n\treturn 0;\n}\n\nstatic int mtk_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\n\tif (!MTK_RTC_TM_YR_VALID(tm->tm_year))\n\t\treturn -EINVAL;\n\n\t \n\tmtk_set(hw, MTK_RTC_CTL, RTC_RC_STOP);\n\n\tmtk_rtc_set_alarm_or_time(hw, tm, MTK_TC);\n\n\t \n\tmtk_clr(hw, MTK_RTC_CTL, RTC_RC_STOP);\n\n\treturn 0;\n}\n\nstatic int mtk_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\tstruct rtc_time *alrm_tm = &wkalrm->time;\n\n\tmtk_rtc_get_alarm_or_time(hw, alrm_tm, MTK_AL);\n\n\twkalrm->enabled = !!(mtk_r32(hw, MTK_RTC_AL_CTL) & RTC_AL_EN);\n\twkalrm->pending = !!(mtk_r32(hw, MTK_RTC_INT) & RTC_INT_AL_STA);\n\n\treturn 0;\n}\n\nstatic int mtk_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\tstruct rtc_time *alrm_tm = &wkalrm->time;\n\n\tif (!MTK_RTC_TM_YR_VALID(alrm_tm->tm_year))\n\t\treturn -EINVAL;\n\n\t \n\tmtk_clr(hw, MTK_RTC_AL_CTL, RTC_AL_EN);\n\n\t \n\tsynchronize_irq(hw->irq);\n\n\tmtk_rtc_set_alarm_or_time(hw, alrm_tm, MTK_AL);\n\n\t \n\tmtk_w32(hw, MTK_RTC_AL_CTL, RTC_AL_ALL);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops mtk_rtc_ops = {\n\t.read_time\t\t= mtk_rtc_gettime,\n\t.set_time\t\t= mtk_rtc_settime,\n\t.read_alarm\t\t= mtk_rtc_getalarm,\n\t.set_alarm\t\t= mtk_rtc_setalarm,\n};\n\nstatic const struct of_device_id mtk_rtc_match[] = {\n\t{ .compatible = \"mediatek,mt7622-rtc\" },\n\t{ .compatible = \"mediatek,soc-rtc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_rtc_match);\n\nstatic int mtk_rtc_probe(struct platform_device *pdev)\n{\n\tstruct mtk_rtc *hw;\n\tint ret;\n\n\thw = devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hw);\n\n\thw->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hw->base))\n\t\treturn PTR_ERR(hw->base);\n\n\thw->clk = devm_clk_get(&pdev->dev, \"rtc\");\n\tif (IS_ERR(hw->clk)) {\n\t\tdev_err(&pdev->dev, \"No clock\\n\");\n\t\treturn PTR_ERR(hw->clk);\n\t}\n\n\tret = clk_prepare_enable(hw->clk);\n\tif (ret)\n\t\treturn ret;\n\n\thw->irq = platform_get_irq(pdev, 0);\n\tif (hw->irq < 0) {\n\t\tret = hw->irq;\n\t\tgoto err;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, hw->irq, mtk_rtc_alarmirq,\n\t\t\t       0, dev_name(&pdev->dev), hw);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't request IRQ\\n\");\n\t\tgoto err;\n\t}\n\n\tmtk_rtc_hw_init(hw);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\thw->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\t   &mtk_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(hw->rtc)) {\n\t\tret = PTR_ERR(hw->rtc);\n\t\tdev_err(&pdev->dev, \"Unable to register device\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tclk_disable_unprepare(hw->clk);\n\n\treturn ret;\n}\n\nstatic void mtk_rtc_remove(struct platform_device *pdev)\n{\n\tstruct mtk_rtc *hw = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(hw->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_rtc_suspend(struct device *dev)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(hw->irq);\n\n\treturn 0;\n}\n\nstatic int mtk_rtc_resume(struct device *dev)\n{\n\tstruct mtk_rtc *hw = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(hw->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mtk_rtc_pm_ops, mtk_rtc_suspend, mtk_rtc_resume);\n\n#define MTK_RTC_PM_OPS (&mtk_rtc_pm_ops)\n#else\t \n#define MTK_RTC_PM_OPS NULL\n#endif\t \n\nstatic struct platform_driver mtk_rtc_driver = {\n\t.probe\t= mtk_rtc_probe,\n\t.remove_new = mtk_rtc_remove,\n\t.driver = {\n\t\t.name = MTK_RTC_DEV,\n\t\t.of_match_table = mtk_rtc_match,\n\t\t.pm = MTK_RTC_PM_OPS,\n\t},\n};\n\nmodule_platform_driver(mtk_rtc_driver);\n\nMODULE_DESCRIPTION(\"MediaTek SoC based RTC Driver\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}