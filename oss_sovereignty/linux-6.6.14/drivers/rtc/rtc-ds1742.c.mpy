{
  "module_name": "rtc-ds1742.c",
  "hash_id": "cb11f390bb0a30e395f8fd7b64f6b00b88792cd7b0ab2c1c8baaa43dbfb838a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1742.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#define RTC_SIZE\t\t8\n\n#define RTC_CONTROL\t\t0\n#define RTC_CENTURY\t\t0\n#define RTC_SECONDS\t\t1\n#define RTC_MINUTES\t\t2\n#define RTC_HOURS\t\t3\n#define RTC_DAY\t\t\t4\n#define RTC_DATE\t\t5\n#define RTC_MONTH\t\t6\n#define RTC_YEAR\t\t7\n\n#define RTC_CENTURY_MASK\t0x3f\n#define RTC_SECONDS_MASK\t0x7f\n#define RTC_DAY_MASK\t\t0x07\n\n \n#define RTC_WRITE\t\t0x80\n#define RTC_READ\t\t0x40\n\n \n#define RTC_STOP\t\t0x80\n\n \n#define RTC_BATT_FLAG\t\t0x80\n\nstruct rtc_plat_data {\n\tvoid __iomem *ioaddr_nvram;\n\tvoid __iomem *ioaddr_rtc;\n\tunsigned long last_jiffies;\n};\n\nstatic int ds1742_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr_rtc;\n\tu8 century;\n\n\tcentury = bin2bcd((tm->tm_year + 1900) / 100);\n\n\twriteb(RTC_WRITE, ioaddr + RTC_CONTROL);\n\n\twriteb(bin2bcd(tm->tm_year % 100), ioaddr + RTC_YEAR);\n\twriteb(bin2bcd(tm->tm_mon + 1), ioaddr + RTC_MONTH);\n\twriteb(bin2bcd(tm->tm_wday) & RTC_DAY_MASK, ioaddr + RTC_DAY);\n\twriteb(bin2bcd(tm->tm_mday), ioaddr + RTC_DATE);\n\twriteb(bin2bcd(tm->tm_hour), ioaddr + RTC_HOURS);\n\twriteb(bin2bcd(tm->tm_min), ioaddr + RTC_MINUTES);\n\twriteb(bin2bcd(tm->tm_sec) & RTC_SECONDS_MASK, ioaddr + RTC_SECONDS);\n\n\t \n\twriteb(RTC_WRITE | (century & RTC_CENTURY_MASK), ioaddr + RTC_CENTURY);\n\twriteb(century & RTC_CENTURY_MASK, ioaddr + RTC_CONTROL);\n\treturn 0;\n}\n\nstatic int ds1742_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr_rtc;\n\tunsigned int year, month, day, hour, minute, second, week;\n\tunsigned int century;\n\n\t \n\tif (pdata->last_jiffies == jiffies)\n\t\tmsleep(1);\n\tpdata->last_jiffies = jiffies;\n\twriteb(RTC_READ, ioaddr + RTC_CONTROL);\n\tsecond = readb(ioaddr + RTC_SECONDS) & RTC_SECONDS_MASK;\n\tminute = readb(ioaddr + RTC_MINUTES);\n\thour = readb(ioaddr + RTC_HOURS);\n\tday = readb(ioaddr + RTC_DATE);\n\tweek = readb(ioaddr + RTC_DAY) & RTC_DAY_MASK;\n\tmonth = readb(ioaddr + RTC_MONTH);\n\tyear = readb(ioaddr + RTC_YEAR);\n\tcentury = readb(ioaddr + RTC_CENTURY) & RTC_CENTURY_MASK;\n\twriteb(0, ioaddr + RTC_CONTROL);\n\ttm->tm_sec = bcd2bin(second);\n\ttm->tm_min = bcd2bin(minute);\n\ttm->tm_hour = bcd2bin(hour);\n\ttm->tm_mday = bcd2bin(day);\n\ttm->tm_wday = bcd2bin(week);\n\ttm->tm_mon = bcd2bin(month) - 1;\n\t \n\ttm->tm_year = bcd2bin(year) + bcd2bin(century) * 100 - 1900;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1742_rtc_ops = {\n\t.read_time\t= ds1742_rtc_read_time,\n\t.set_time\t= ds1742_rtc_set_time,\n};\n\nstatic int ds1742_nvram_read(void *priv, unsigned int pos, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct rtc_plat_data *pdata = priv;\n\tvoid __iomem *ioaddr = pdata->ioaddr_nvram;\n\tu8 *buf = val;\n\n\tfor (; bytes; bytes--)\n\t\t*buf++ = readb(ioaddr + pos++);\n\treturn 0;\n}\n\nstatic int ds1742_nvram_write(void *priv, unsigned int pos, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct rtc_plat_data *pdata = priv;\n\tvoid __iomem *ioaddr = pdata->ioaddr_nvram;\n\tu8 *buf = val;\n\n\tfor (; bytes; bytes--)\n\t\twriteb(*buf++, ioaddr + pos++);\n\treturn 0;\n}\n\nstatic int ds1742_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\tstruct resource *res;\n\tunsigned int cen, sec;\n\tstruct rtc_plat_data *pdata;\n\tvoid __iomem *ioaddr;\n\tint ret = 0;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"ds1742_nvram\",\n\t\t.reg_read = ds1742_nvram_read,\n\t\t.reg_write = ds1742_nvram_write,\n\t};\n\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tioaddr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ioaddr))\n\t\treturn PTR_ERR(ioaddr);\n\n\tpdata->ioaddr_nvram = ioaddr;\n\tpdata->ioaddr_rtc = ioaddr + resource_size(res) - RTC_SIZE;\n\n\tnvmem_cfg.size = resource_size(res) - RTC_SIZE;\n\tnvmem_cfg.priv = pdata;\n\n\t \n\tioaddr = pdata->ioaddr_rtc;\n\tsec = readb(ioaddr + RTC_SECONDS);\n\tif (sec & RTC_STOP) {\n\t\tsec &= RTC_SECONDS_MASK;\n\t\tcen = readb(ioaddr + RTC_CENTURY) & RTC_CENTURY_MASK;\n\t\twriteb(RTC_WRITE, ioaddr + RTC_CONTROL);\n\t\twriteb(sec, ioaddr + RTC_SECONDS);\n\t\twriteb(cen & RTC_CENTURY_MASK, ioaddr + RTC_CONTROL);\n\t}\n\tif (!(readb(ioaddr + RTC_DAY) & RTC_BATT_FLAG))\n\t\tdev_warn(&pdev->dev, \"voltage-low detected.\\n\");\n\n\tpdata->last_jiffies = jiffies;\n\tplatform_set_drvdata(pdev, pdata);\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\trtc->ops = &ds1742_rtc_ops;\n\n\tret = devm_rtc_register_device(rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tdevm_rtc_nvmem_register(rtc, &nvmem_cfg);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused ds1742_rtc_of_match[] = {\n\t{ .compatible = \"maxim,ds1742\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ds1742_rtc_of_match);\n\nstatic struct platform_driver ds1742_rtc_driver = {\n\t.probe\t\t= ds1742_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-ds1742\",\n\t\t.of_match_table = of_match_ptr(ds1742_rtc_of_match),\n\t},\n};\n\nmodule_platform_driver(ds1742_rtc_driver);\n\nMODULE_AUTHOR(\"Atsushi Nemoto <anemo@mba.ocn.ne.jp>\");\nMODULE_DESCRIPTION(\"Dallas DS1742 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-ds1742\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}