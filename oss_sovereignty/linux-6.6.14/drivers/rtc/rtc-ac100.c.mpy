{
  "module_name": "rtc-ac100.c",
  "hash_id": "5d8cef4c5ab916ac1affb1f7e9a04905e8e66083edb526ef46f6f50650d5c8dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ac100.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/ac100.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/types.h>\n\n \n#define AC100_RTC_CTRL_24HOUR\tBIT(0)\n\n \n#define AC100_CLKOUT_PRE_DIV_SHIFT\t5\n#define AC100_CLKOUT_PRE_DIV_WIDTH\t3\n#define AC100_CLKOUT_MUX_SHIFT\t\t4\n#define AC100_CLKOUT_MUX_WIDTH\t\t1\n#define AC100_CLKOUT_DIV_SHIFT\t\t1\n#define AC100_CLKOUT_DIV_WIDTH\t\t3\n#define AC100_CLKOUT_EN\t\t\tBIT(0)\n\n \n#define AC100_RTC_SEC_MASK\tGENMASK(6, 0)\n#define AC100_RTC_MIN_MASK\tGENMASK(6, 0)\n#define AC100_RTC_HOU_MASK\tGENMASK(5, 0)\n#define AC100_RTC_WEE_MASK\tGENMASK(2, 0)\n#define AC100_RTC_DAY_MASK\tGENMASK(5, 0)\n#define AC100_RTC_MON_MASK\tGENMASK(4, 0)\n#define AC100_RTC_YEA_MASK\tGENMASK(7, 0)\n#define AC100_RTC_YEA_LEAP\tBIT(15)\n#define AC100_RTC_UPD_TRIGGER\tBIT(15)\n\n \n#define AC100_ALM_INT_ENABLE\tBIT(0)\n\n#define AC100_ALM_SEC_MASK\tGENMASK(6, 0)\n#define AC100_ALM_MIN_MASK\tGENMASK(6, 0)\n#define AC100_ALM_HOU_MASK\tGENMASK(5, 0)\n#define AC100_ALM_WEE_MASK\tGENMASK(2, 0)\n#define AC100_ALM_DAY_MASK\tGENMASK(5, 0)\n#define AC100_ALM_MON_MASK\tGENMASK(4, 0)\n#define AC100_ALM_YEA_MASK\tGENMASK(7, 0)\n#define AC100_ALM_ENABLE_FLAG\tBIT(15)\n#define AC100_ALM_UPD_TRIGGER\tBIT(15)\n\n \n#define AC100_YEAR_MIN\t\t\t\t1970\n#define AC100_YEAR_MAX\t\t\t\t2069\n#define AC100_YEAR_OFF\t\t\t\t(AC100_YEAR_MIN - 1900)\n\nstruct ac100_clkout {\n\tstruct clk_hw hw;\n\tstruct regmap *regmap;\n\tu8 offset;\n};\n\n#define to_ac100_clkout(_hw) container_of(_hw, struct ac100_clkout, hw)\n\n#define AC100_RTC_32K_NAME\t\"ac100-rtc-32k\"\n#define AC100_RTC_32K_RATE\t32768\n#define AC100_CLKOUT_NUM\t3\n\nstatic const char * const ac100_clkout_names[AC100_CLKOUT_NUM] = {\n\t\"ac100-cko1-rtc\",\n\t\"ac100-cko2-rtc\",\n\t\"ac100-cko3-rtc\",\n};\n\nstruct ac100_rtc_dev {\n\tstruct rtc_device *rtc;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tint irq;\n\tunsigned long alarm;\n\n\tstruct clk_hw *rtc_32k_clk;\n\tstruct ac100_clkout clks[AC100_CLKOUT_NUM];\n\tstruct clk_hw_onecell_data *clk_data;\n};\n\n \n\nstatic const struct clk_div_table ac100_clkout_prediv[] = {\n\t{ .val = 0, .div = 1 },\n\t{ .val = 1, .div = 2 },\n\t{ .val = 2, .div = 4 },\n\t{ .val = 3, .div = 8 },\n\t{ .val = 4, .div = 16 },\n\t{ .val = 5, .div = 32 },\n\t{ .val = 6, .div = 64 },\n\t{ .val = 7, .div = 122 },\n\t{ },\n};\n\n \nstatic unsigned long ac100_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long prate)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\tunsigned int reg, div;\n\n\tregmap_read(clk->regmap, clk->offset, &reg);\n\n\t \n\tif (prate != AC100_RTC_32K_RATE) {\n\t\tdiv = (reg >> AC100_CLKOUT_PRE_DIV_SHIFT) &\n\t\t\t((1 << AC100_CLKOUT_PRE_DIV_WIDTH) - 1);\n\t\tprate = divider_recalc_rate(hw, prate, div,\n\t\t\t\t\t    ac100_clkout_prediv, 0,\n\t\t\t\t\t    AC100_CLKOUT_PRE_DIV_WIDTH);\n\t}\n\n\tdiv = (reg >> AC100_CLKOUT_DIV_SHIFT) &\n\t\t(BIT(AC100_CLKOUT_DIV_WIDTH) - 1);\n\treturn divider_recalc_rate(hw, prate, div, NULL,\n\t\t\t\t   CLK_DIVIDER_POWER_OF_TWO,\n\t\t\t\t   AC100_CLKOUT_DIV_WIDTH);\n}\n\nstatic long ac100_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long prate)\n{\n\tunsigned long best_rate = 0, tmp_rate, tmp_prate;\n\tint i;\n\n\tif (prate == AC100_RTC_32K_RATE)\n\t\treturn divider_round_rate(hw, rate, &prate, NULL,\n\t\t\t\t\t  AC100_CLKOUT_DIV_WIDTH,\n\t\t\t\t\t  CLK_DIVIDER_POWER_OF_TWO);\n\n\tfor (i = 0; ac100_clkout_prediv[i].div; i++) {\n\t\ttmp_prate = DIV_ROUND_UP(prate, ac100_clkout_prediv[i].val);\n\t\ttmp_rate = divider_round_rate(hw, rate, &tmp_prate, NULL,\n\t\t\t\t\t      AC100_CLKOUT_DIV_WIDTH,\n\t\t\t\t\t      CLK_DIVIDER_POWER_OF_TWO);\n\n\t\tif (tmp_rate > rate)\n\t\t\tcontinue;\n\t\tif (rate - tmp_rate < best_rate - tmp_rate)\n\t\t\tbest_rate = tmp_rate;\n\t}\n\n\treturn best_rate;\n}\n\nstatic int ac100_clkout_determine_rate(struct clk_hw *hw,\n\t\t\t\t       struct clk_rate_request *req)\n{\n\tstruct clk_hw *best_parent;\n\tunsigned long best = 0;\n\tint i, num_parents = clk_hw_get_num_parents(hw);\n\n\tfor (i = 0; i < num_parents; i++) {\n\t\tstruct clk_hw *parent = clk_hw_get_parent_by_index(hw, i);\n\t\tunsigned long tmp, prate;\n\n\t\t \n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tprate = clk_hw_get_rate(parent);\n\n\t\ttmp = ac100_clkout_round_rate(hw, req->rate, prate);\n\n\t\tif (tmp > req->rate)\n\t\t\tcontinue;\n\t\tif (req->rate - tmp < req->rate - best) {\n\t\t\tbest = tmp;\n\t\t\tbest_parent = parent;\n\t\t}\n\t}\n\n\tif (!best)\n\t\treturn -EINVAL;\n\n\treq->best_parent_hw = best_parent;\n\treq->best_parent_rate = best;\n\treq->rate = best;\n\n\treturn 0;\n}\n\nstatic int ac100_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long prate)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\tint div = 0, pre_div = 0;\n\n\tdo {\n\t\tdiv = divider_get_val(rate * ac100_clkout_prediv[pre_div].div,\n\t\t\t\t      prate, NULL, AC100_CLKOUT_DIV_WIDTH,\n\t\t\t\t      CLK_DIVIDER_POWER_OF_TWO);\n\t\tif (div >= 0)\n\t\t\tbreak;\n\t} while (prate != AC100_RTC_32K_RATE &&\n\t\t ac100_clkout_prediv[++pre_div].div);\n\n\tif (div < 0)\n\t\treturn div;\n\n\tpre_div = ac100_clkout_prediv[pre_div].val;\n\n\tregmap_update_bits(clk->regmap, clk->offset,\n\t\t\t   ((1 << AC100_CLKOUT_DIV_WIDTH) - 1) << AC100_CLKOUT_DIV_SHIFT |\n\t\t\t   ((1 << AC100_CLKOUT_PRE_DIV_WIDTH) - 1) << AC100_CLKOUT_PRE_DIV_SHIFT,\n\t\t\t   (div - 1) << AC100_CLKOUT_DIV_SHIFT |\n\t\t\t   (pre_div - 1) << AC100_CLKOUT_PRE_DIV_SHIFT);\n\n\treturn 0;\n}\n\nstatic int ac100_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\n\treturn regmap_update_bits(clk->regmap, clk->offset, AC100_CLKOUT_EN,\n\t\t\t\t  AC100_CLKOUT_EN);\n}\n\nstatic void ac100_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\n\tregmap_update_bits(clk->regmap, clk->offset, AC100_CLKOUT_EN, 0);\n}\n\nstatic int ac100_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\tunsigned int reg;\n\n\tregmap_read(clk->regmap, clk->offset, &reg);\n\n\treturn reg & AC100_CLKOUT_EN;\n}\n\nstatic u8 ac100_clkout_get_parent(struct clk_hw *hw)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\tunsigned int reg;\n\n\tregmap_read(clk->regmap, clk->offset, &reg);\n\n\treturn (reg >> AC100_CLKOUT_MUX_SHIFT) & 0x1;\n}\n\nstatic int ac100_clkout_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct ac100_clkout *clk = to_ac100_clkout(hw);\n\n\treturn regmap_update_bits(clk->regmap, clk->offset,\n\t\t\t\t  BIT(AC100_CLKOUT_MUX_SHIFT),\n\t\t\t\t  index ? BIT(AC100_CLKOUT_MUX_SHIFT) : 0);\n}\n\nstatic const struct clk_ops ac100_clkout_ops = {\n\t.prepare\t= ac100_clkout_prepare,\n\t.unprepare\t= ac100_clkout_unprepare,\n\t.is_prepared\t= ac100_clkout_is_prepared,\n\t.recalc_rate\t= ac100_clkout_recalc_rate,\n\t.determine_rate\t= ac100_clkout_determine_rate,\n\t.get_parent\t= ac100_clkout_get_parent,\n\t.set_parent\t= ac100_clkout_set_parent,\n\t.set_rate\t= ac100_clkout_set_rate,\n};\n\nstatic int ac100_rtc_register_clks(struct ac100_rtc_dev *chip)\n{\n\tstruct device_node *np = chip->dev->of_node;\n\tconst char *parents[2] = {AC100_RTC_32K_NAME};\n\tint i, ret;\n\n\tchip->clk_data = devm_kzalloc(chip->dev,\n\t\t\t\t      struct_size(chip->clk_data, hws,\n\t\t\t\t\t\t  AC100_CLKOUT_NUM),\n\t\t\t\t      GFP_KERNEL);\n\tif (!chip->clk_data)\n\t\treturn -ENOMEM;\n\n\tchip->rtc_32k_clk = clk_hw_register_fixed_rate(chip->dev,\n\t\t\t\t\t\t       AC100_RTC_32K_NAME,\n\t\t\t\t\t\t       NULL, 0,\n\t\t\t\t\t\t       AC100_RTC_32K_RATE);\n\tif (IS_ERR(chip->rtc_32k_clk)) {\n\t\tret = PTR_ERR(chip->rtc_32k_clk);\n\t\tdev_err(chip->dev, \"Failed to register RTC-32k clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tparents[1] = of_clk_get_parent_name(np, 0);\n\tif (!parents[1]) {\n\t\tdev_err(chip->dev, \"Failed to get ADDA 4M clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < AC100_CLKOUT_NUM; i++) {\n\t\tstruct ac100_clkout *clk = &chip->clks[i];\n\t\tstruct clk_init_data init = {\n\t\t\t.name = ac100_clkout_names[i],\n\t\t\t.ops = &ac100_clkout_ops,\n\t\t\t.parent_names = parents,\n\t\t\t.num_parents = ARRAY_SIZE(parents),\n\t\t\t.flags = 0,\n\t\t};\n\n\t\tof_property_read_string_index(np, \"clock-output-names\",\n\t\t\t\t\t      i, &init.name);\n\t\tclk->regmap = chip->regmap;\n\t\tclk->offset = AC100_CLKOUT_CTRL1 + i;\n\t\tclk->hw.init = &init;\n\n\t\tret = devm_clk_hw_register(chip->dev, &clk->hw);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"Failed to register clk '%s': %d\\n\",\n\t\t\t\tinit.name, ret);\n\t\t\tgoto err_unregister_rtc_32k;\n\t\t}\n\n\t\tchip->clk_data->hws[i] = &clk->hw;\n\t}\n\n\tchip->clk_data->num = i;\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, chip->clk_data);\n\tif (ret)\n\t\tgoto err_unregister_rtc_32k;\n\n\treturn 0;\n\nerr_unregister_rtc_32k:\n\tclk_unregister_fixed_rate(chip->rtc_32k_clk->clk);\n\n\treturn ret;\n}\n\nstatic void ac100_rtc_unregister_clks(struct ac100_rtc_dev *chip)\n{\n\tof_clk_del_provider(chip->dev->of_node);\n\tclk_unregister_fixed_rate(chip->rtc_32k_clk->clk);\n}\n\n \nstatic int ac100_rtc_get_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct regmap *regmap = chip->regmap;\n\tu16 reg[7];\n\tint ret;\n\n\tret = regmap_bulk_read(regmap, AC100_RTC_SEC, reg, 7);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_tm->tm_sec  = bcd2bin(reg[0] & AC100_RTC_SEC_MASK);\n\trtc_tm->tm_min  = bcd2bin(reg[1] & AC100_RTC_MIN_MASK);\n\trtc_tm->tm_hour = bcd2bin(reg[2] & AC100_RTC_HOU_MASK);\n\trtc_tm->tm_wday = bcd2bin(reg[3] & AC100_RTC_WEE_MASK);\n\trtc_tm->tm_mday = bcd2bin(reg[4] & AC100_RTC_DAY_MASK);\n\trtc_tm->tm_mon  = bcd2bin(reg[5] & AC100_RTC_MON_MASK) - 1;\n\trtc_tm->tm_year = bcd2bin(reg[6] & AC100_RTC_YEA_MASK) +\n\t\t\t  AC100_YEAR_OFF;\n\n\treturn 0;\n}\n\nstatic int ac100_rtc_set_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct regmap *regmap = chip->regmap;\n\tint year;\n\tu16 reg[8];\n\n\t \n\tyear = rtc_tm->tm_year - AC100_YEAR_OFF;\n\tif (year < 0 || year > (AC100_YEAR_MAX - 1900)) {\n\t\tdev_err(dev, \"rtc only supports year in range %d - %d\\n\",\n\t\t\tAC100_YEAR_MIN, AC100_YEAR_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg[0] = bin2bcd(rtc_tm->tm_sec)     & AC100_RTC_SEC_MASK;\n\treg[1] = bin2bcd(rtc_tm->tm_min)     & AC100_RTC_MIN_MASK;\n\treg[2] = bin2bcd(rtc_tm->tm_hour)    & AC100_RTC_HOU_MASK;\n\treg[3] = bin2bcd(rtc_tm->tm_wday)    & AC100_RTC_WEE_MASK;\n\treg[4] = bin2bcd(rtc_tm->tm_mday)    & AC100_RTC_DAY_MASK;\n\treg[5] = bin2bcd(rtc_tm->tm_mon + 1) & AC100_RTC_MON_MASK;\n\treg[6] = bin2bcd(year)\t\t     & AC100_RTC_YEA_MASK;\n\t \n\treg[7] = AC100_RTC_UPD_TRIGGER;\n\n\t \n\tif (is_leap_year(year + AC100_YEAR_OFF + 1900))\n\t\treg[6] |= AC100_RTC_YEA_LEAP;\n\n\treturn regmap_bulk_write(regmap, AC100_RTC_SEC, reg, 8);\n}\n\nstatic int ac100_rtc_alarm_irq_enable(struct device *dev, unsigned int en)\n{\n\tstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct regmap *regmap = chip->regmap;\n\tunsigned int val;\n\n\tval = en ? AC100_ALM_INT_ENABLE : 0;\n\n\treturn regmap_write(regmap, AC100_ALM_INT_ENA, val);\n}\n\nstatic int ac100_rtc_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct regmap *regmap = chip->regmap;\n\tstruct rtc_time *alrm_tm = &alrm->time;\n\tu16 reg[7];\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(regmap, AC100_ALM_INT_ENA, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled = !!(val & AC100_ALM_INT_ENABLE);\n\n\tret = regmap_bulk_read(regmap, AC100_ALM_SEC, reg, 7);\n\tif (ret)\n\t\treturn ret;\n\n\talrm_tm->tm_sec  = bcd2bin(reg[0] & AC100_ALM_SEC_MASK);\n\talrm_tm->tm_min  = bcd2bin(reg[1] & AC100_ALM_MIN_MASK);\n\talrm_tm->tm_hour = bcd2bin(reg[2] & AC100_ALM_HOU_MASK);\n\talrm_tm->tm_wday = bcd2bin(reg[3] & AC100_ALM_WEE_MASK);\n\talrm_tm->tm_mday = bcd2bin(reg[4] & AC100_ALM_DAY_MASK);\n\talrm_tm->tm_mon  = bcd2bin(reg[5] & AC100_ALM_MON_MASK) - 1;\n\talrm_tm->tm_year = bcd2bin(reg[6] & AC100_ALM_YEA_MASK) +\n\t\t\t   AC100_YEAR_OFF;\n\n\treturn 0;\n}\n\nstatic int ac100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct regmap *regmap = chip->regmap;\n\tstruct rtc_time *alrm_tm = &alrm->time;\n\tu16 reg[8];\n\tint year;\n\tint ret;\n\n\t \n\tyear = alrm_tm->tm_year - AC100_YEAR_OFF;\n\tif (year < 0 || year > (AC100_YEAR_MAX - 1900)) {\n\t\tdev_err(dev, \"alarm only supports year in range %d - %d\\n\",\n\t\t\tAC100_YEAR_MIN, AC100_YEAR_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg[0] = (bin2bcd(alrm_tm->tm_sec)  & AC100_ALM_SEC_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\treg[1] = (bin2bcd(alrm_tm->tm_min)  & AC100_ALM_MIN_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\treg[2] = (bin2bcd(alrm_tm->tm_hour) & AC100_ALM_HOU_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\t \n\treg[3] = bin2bcd(alrm_tm->tm_wday) & AC100_ALM_WEE_MASK;\n\treg[4] = (bin2bcd(alrm_tm->tm_mday) & AC100_ALM_DAY_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\treg[5] = (bin2bcd(alrm_tm->tm_mon + 1)  & AC100_ALM_MON_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\treg[6] = (bin2bcd(year) & AC100_ALM_YEA_MASK) |\n\t\t\tAC100_ALM_ENABLE_FLAG;\n\t \n\treg[7] = AC100_ALM_UPD_TRIGGER;\n\n\tret = regmap_bulk_write(regmap, AC100_ALM_SEC, reg, 8);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ac100_rtc_alarm_irq_enable(dev, alrm->enabled);\n}\n\nstatic irqreturn_t ac100_rtc_irq(int irq, void *data)\n{\n\tstruct ac100_rtc_dev *chip = data;\n\tstruct regmap *regmap = chip->regmap;\n\tunsigned int val = 0;\n\tint ret;\n\n\trtc_lock(chip->rtc);\n\n\t \n\tret = regmap_read(regmap, AC100_ALM_INT_STA, &val);\n\tif (ret)\n\t\tgoto out;\n\n\tif (val & AC100_ALM_INT_ENABLE) {\n\t\t \n\t\trtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\t \n\t\tret = regmap_write(regmap, AC100_ALM_INT_STA, val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = ac100_rtc_alarm_irq_enable(chip->dev, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\trtc_unlock(chip->rtc);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops ac100_rtc_ops = {\n\t.read_time\t  = ac100_rtc_get_time,\n\t.set_time\t  = ac100_rtc_set_time,\n\t.read_alarm\t  = ac100_rtc_get_alarm,\n\t.set_alarm\t  = ac100_rtc_set_alarm,\n\t.alarm_irq_enable = ac100_rtc_alarm_irq_enable,\n};\n\nstatic int ac100_rtc_probe(struct platform_device *pdev)\n{\n\tstruct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);\n\tstruct ac100_rtc_dev *chip;\n\tint ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\tchip->dev = &pdev->dev;\n\tchip->regmap = ac100->regmap;\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tif (chip->irq < 0)\n\t\treturn chip->irq;\n\n\tchip->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(chip->rtc))\n\t\treturn PTR_ERR(chip->rtc);\n\n\tchip->rtc->ops = &ac100_rtc_ops;\n\n\tret = devm_request_threaded_irq(&pdev->dev, chip->irq, NULL,\n\t\t\t\t\tac100_rtc_irq,\n\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev), chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write_bits(chip->regmap, AC100_RTC_CTRL, AC100_RTC_CTRL_24HOUR,\n\t\t\t  AC100_RTC_CTRL_24HOUR);\n\n\t \n\tregmap_write(chip->regmap, AC100_ALM_INT_ENA, 0);\n\n\t \n\tregmap_write(chip->regmap, AC100_ALM_INT_STA, AC100_ALM_INT_ENABLE);\n\n\tret = ac100_rtc_register_clks(chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_register_device(chip->rtc);\n}\n\nstatic void ac100_rtc_remove(struct platform_device *pdev)\n{\n\tstruct ac100_rtc_dev *chip = platform_get_drvdata(pdev);\n\n\tac100_rtc_unregister_clks(chip);\n}\n\nstatic const struct of_device_id ac100_rtc_match[] = {\n\t{ .compatible = \"x-powers,ac100-rtc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ac100_rtc_match);\n\nstatic struct platform_driver ac100_rtc_driver = {\n\t.probe\t\t= ac100_rtc_probe,\n\t.remove_new\t= ac100_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"ac100-rtc\",\n\t\t.of_match_table\t= of_match_ptr(ac100_rtc_match),\n\t},\n};\nmodule_platform_driver(ac100_rtc_driver);\n\nMODULE_DESCRIPTION(\"X-Powers AC100 RTC driver\");\nMODULE_AUTHOR(\"Chen-Yu Tsai <wens@csie.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}