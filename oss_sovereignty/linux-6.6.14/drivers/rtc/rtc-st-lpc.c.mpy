{
  "module_name": "rtc-st-lpc.c",
  "hash_id": "43bac8562528af6963a2b3ea184c855c8a335fd91a904daa21c855b6afc55497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-st-lpc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n#include <dt-bindings/mfd/st-lpc.h>\n\n \n#define LPC_LPT_LSB_OFF\t\t0x400\n#define LPC_LPT_MSB_OFF\t\t0x404\n#define LPC_LPT_START_OFF\t0x408\n\n \n#define LPC_LPA_LSB_OFF\t\t0x410\n#define LPC_LPA_MSB_OFF\t\t0x414\n#define LPC_LPA_START_OFF\t0x418\n\n \n#define LPC_WDT_OFF\t\t0x510\n#define LPC_WDT_FLAG_OFF\t0x514\n\nstruct st_rtc {\n\tstruct rtc_device *rtc_dev;\n\tstruct rtc_wkalrm alarm;\n\tstruct clk *clk;\n\tunsigned long clkrate;\n\tvoid __iomem *ioaddr;\n\tbool irq_enabled:1;\n\tspinlock_t lock;\n\tshort irq;\n};\n\nstatic void st_rtc_set_hw_alarm(struct st_rtc *rtc,\n\t\t\t\tunsigned long msb, unsigned long  lsb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\twritel_relaxed(1, rtc->ioaddr + LPC_WDT_OFF);\n\n\twritel_relaxed(msb, rtc->ioaddr + LPC_LPA_MSB_OFF);\n\twritel_relaxed(lsb, rtc->ioaddr + LPC_LPA_LSB_OFF);\n\twritel_relaxed(1, rtc->ioaddr + LPC_LPA_START_OFF);\n\n\twritel_relaxed(0, rtc->ioaddr + LPC_WDT_OFF);\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n}\n\nstatic irqreturn_t st_rtc_handler(int this_irq, void *data)\n{\n\tstruct st_rtc *rtc = (struct st_rtc *)data;\n\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int st_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long lpt_lsb, lpt_msb;\n\tunsigned long long lpt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\tdo {\n\t\tlpt_msb = readl_relaxed(rtc->ioaddr + LPC_LPT_MSB_OFF);\n\t\tlpt_lsb = readl_relaxed(rtc->ioaddr + LPC_LPT_LSB_OFF);\n\t} while (readl_relaxed(rtc->ioaddr + LPC_LPT_MSB_OFF) != lpt_msb);\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\tlpt = ((unsigned long long)lpt_msb << 32) | lpt_lsb;\n\tdo_div(lpt, rtc->clkrate);\n\trtc_time64_to_tm(lpt, tm);\n\n\treturn 0;\n}\n\nstatic int st_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long long lpt, secs;\n\tunsigned long flags;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\tlpt = (unsigned long long)secs * rtc->clkrate;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\twritel_relaxed(lpt >> 32, rtc->ioaddr + LPC_LPT_MSB_OFF);\n\twritel_relaxed(lpt, rtc->ioaddr + LPC_LPT_LSB_OFF);\n\twritel_relaxed(1, rtc->ioaddr + LPC_LPT_START_OFF);\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int st_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\tmemcpy(wkalrm, &rtc->alarm, sizeof(struct rtc_wkalrm));\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int st_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (enabled && !rtc->irq_enabled) {\n\t\tenable_irq(rtc->irq);\n\t\trtc->irq_enabled = true;\n\t} else if (!enabled && rtc->irq_enabled) {\n\t\tdisable_irq(rtc->irq);\n\t\trtc->irq_enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time now;\n\tunsigned long long now_secs;\n\tunsigned long long alarm_secs;\n\tunsigned long long lpa;\n\n\tst_rtc_read_time(dev, &now);\n\tnow_secs = rtc_tm_to_time64(&now);\n\talarm_secs = rtc_tm_to_time64(&t->time);\n\n\tmemcpy(&rtc->alarm, t, sizeof(struct rtc_wkalrm));\n\n\t \n\talarm_secs -= now_secs;\n\tlpa = (unsigned long long)alarm_secs * rtc->clkrate;\n\n\tst_rtc_set_hw_alarm(rtc, lpa >> 32, lpa);\n\tst_rtc_alarm_irq_enable(dev, t->enabled);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops st_rtc_ops = {\n\t.read_time\t\t= st_rtc_read_time,\n\t.set_time\t\t= st_rtc_set_time,\n\t.read_alarm\t\t= st_rtc_read_alarm,\n\t.set_alarm\t\t= st_rtc_set_alarm,\n\t.alarm_irq_enable\t= st_rtc_alarm_irq_enable,\n};\n\nstatic int st_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct st_rtc *rtc;\n\tuint32_t mode;\n\tint ret = 0;\n\n\tret = of_property_read_u32(np, \"st,lpc-mode\", &mode);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"An LPC mode must be provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode != ST_LPC_MODE_RTC)\n\t\treturn -ENODEV;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(struct st_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tspin_lock_init(&rtc->lock);\n\n\trtc->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->ioaddr))\n\t\treturn PTR_ERR(rtc->ioaddr);\n\n\trtc->irq = irq_of_parse_and_map(np, 0);\n\tif (!rtc->irq) {\n\t\tdev_err(&pdev->dev, \"IRQ missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, rtc->irq, st_rtc_handler, 0,\n\t\t\t       pdev->name, rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq %i\\n\", rtc->irq);\n\t\treturn ret;\n\t}\n\n\tenable_irq_wake(rtc->irq);\n\tdisable_irq(rtc->irq);\n\n\trtc->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(rtc->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rtc->clk),\n\t\t\t\t     \"Unable to request clock\\n\");\n\n\trtc->clkrate = clk_get_rate(rtc->clk);\n\tif (!rtc->clkrate) {\n\t\tdev_err(&pdev->dev, \"Unable to fetch clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev->ops = &st_rtc_ops;\n\trtc->rtc_dev->range_max = U64_MAX;\n\tdo_div(rtc->rtc_dev->range_max, rtc->clkrate);\n\n\tret = devm_rtc_register_device(rtc->rtc_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int st_rtc_suspend(struct device *dev)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn 0;\n\n\twritel_relaxed(1, rtc->ioaddr + LPC_WDT_OFF);\n\twritel_relaxed(0, rtc->ioaddr + LPC_LPA_START_OFF);\n\twritel_relaxed(0, rtc->ioaddr + LPC_WDT_OFF);\n\n\treturn 0;\n}\n\nstatic int st_rtc_resume(struct device *dev)\n{\n\tstruct st_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc_alarm_irq_enable(rtc->rtc_dev, 0);\n\n\t \n\tmemset(&rtc->alarm, 0, sizeof(struct rtc_wkalrm));\n\n\twritel_relaxed(0, rtc->ioaddr + LPC_LPA_MSB_OFF);\n\twritel_relaxed(0, rtc->ioaddr + LPC_LPA_LSB_OFF);\n\twritel_relaxed(1, rtc->ioaddr + LPC_WDT_OFF);\n\twritel_relaxed(1, rtc->ioaddr + LPC_LPA_START_OFF);\n\twritel_relaxed(0, rtc->ioaddr + LPC_WDT_OFF);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(st_rtc_pm_ops, st_rtc_suspend, st_rtc_resume);\n\nstatic const struct of_device_id st_rtc_match[] = {\n\t{ .compatible = \"st,stih407-lpc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, st_rtc_match);\n\nstatic struct platform_driver st_rtc_platform_driver = {\n\t.driver = {\n\t\t.name = \"st-lpc-rtc\",\n\t\t.pm = &st_rtc_pm_ops,\n\t\t.of_match_table = st_rtc_match,\n\t},\n\t.probe = st_rtc_probe,\n};\n\nmodule_platform_driver(st_rtc_platform_driver);\n\nMODULE_DESCRIPTION(\"STMicroelectronics LPC RTC driver\");\nMODULE_AUTHOR(\"David Paris <david.paris@st.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}