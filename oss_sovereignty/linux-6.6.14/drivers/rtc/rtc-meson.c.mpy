{
  "module_name": "rtc-meson.c",
  "hash_id": "78959121b311e9b2398683ed87cd438f64b37e64fb27f9d4d835b3d1aea60093",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-meson.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/rtc.h>\n\n \n#define RTC_ADDR0\t\t\t\t0x00\n\t#define RTC_ADDR0_LINE_SCLK\t\tBIT(0)\n\t#define RTC_ADDR0_LINE_SEN\t\tBIT(1)\n\t#define RTC_ADDR0_LINE_SDI\t\tBIT(2)\n\t#define RTC_ADDR0_START_SER\t\tBIT(17)\n\t#define RTC_ADDR0_WAIT_SER\t\tBIT(22)\n\t#define RTC_ADDR0_DATA\t\t\tGENMASK(31, 24)\n\n#define RTC_ADDR1\t\t\t\t0x04\n\t#define RTC_ADDR1_SDO\t\t\tBIT(0)\n\t#define RTC_ADDR1_S_READY\t\tBIT(1)\n\n#define RTC_ADDR2\t\t\t\t0x08\n#define RTC_ADDR3\t\t\t\t0x0c\n\n#define RTC_REG4\t\t\t\t0x10\n\t#define RTC_REG4_STATIC_VALUE\t\tGENMASK(7, 0)\n\n \n#define RTC_COUNTER\t\t(0)\n#define RTC_SEC_ADJ\t\t(2)\n#define RTC_REGMEM_0\t\t(4)\n#define RTC_REGMEM_1\t\t(5)\n#define RTC_REGMEM_2\t\t(6)\n#define RTC_REGMEM_3\t\t(7)\n\n#define RTC_ADDR_BITS\t\t(3)\t \n#define RTC_DATA_BITS\t\t(32)\t \n\n#define MESON_STATIC_BIAS_CUR\t(0x5 << 1)\n#define MESON_STATIC_VOLTAGE\t(0x3 << 11)\n#define MESON_STATIC_DEFAULT    (MESON_STATIC_BIAS_CUR | MESON_STATIC_VOLTAGE)\n\nstruct meson_rtc {\n\tstruct rtc_device\t*rtc;\t\t \n\tstruct device\t\t*dev;\t\t \n\tstruct reset_control\t*reset;\t\t \n\tstruct regulator\t*vdd;\t\t \n\tstruct regmap\t\t*peripheral;\t \n\tstruct regmap\t\t*serial;\t \n};\n\nstatic const struct regmap_config meson_rtc_peripheral_regmap_config = {\n\t.name\t\t= \"peripheral-registers\",\n\t.reg_bits\t= 8,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= RTC_REG4,\n\t.fast_io\t= true,\n};\n\n \n\nstatic void meson_rtc_sclk_pulse(struct meson_rtc *rtc)\n{\n\tudelay(5);\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SCLK, 0);\n\tudelay(5);\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SCLK,\n\t\t\t   RTC_ADDR0_LINE_SCLK);\n}\n\nstatic void meson_rtc_send_bit(struct meson_rtc *rtc, unsigned int bit)\n{\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SDI,\n\t\t\t   bit ? RTC_ADDR0_LINE_SDI : 0);\n\tmeson_rtc_sclk_pulse(rtc);\n}\n\nstatic void meson_rtc_send_bits(struct meson_rtc *rtc, u32 data,\n\t\t\t\tunsigned int nr)\n{\n\tu32 bit = 1 << (nr - 1);\n\n\twhile (bit) {\n\t\tmeson_rtc_send_bit(rtc, data & bit);\n\t\tbit >>= 1;\n\t}\n}\n\nstatic void meson_rtc_set_dir(struct meson_rtc *rtc, u32 mode)\n{\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SEN, 0);\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SDI, 0);\n\tmeson_rtc_send_bit(rtc, mode);\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SDI, 0);\n}\n\nstatic u32 meson_rtc_get_data(struct meson_rtc *rtc)\n{\n\tu32 tmp, val = 0;\n\tint bit;\n\n\tfor (bit = 0; bit < RTC_DATA_BITS; bit++) {\n\t\tmeson_rtc_sclk_pulse(rtc);\n\t\tval <<= 1;\n\n\t\tregmap_read(rtc->peripheral, RTC_ADDR1, &tmp);\n\t\tval |= tmp & RTC_ADDR1_SDO;\n\t}\n\n\treturn val;\n}\n\nstatic int meson_rtc_get_bus(struct meson_rtc *rtc)\n{\n\tint ret, retries;\n\tu32 val;\n\n\t \n\tval = RTC_ADDR0_LINE_SDI | RTC_ADDR0_LINE_SEN | RTC_ADDR0_LINE_SCLK;\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, val, 0);\n\n\tfor (retries = 0; retries < 3; retries++) {\n\t\t \n\t\tif (!regmap_read_poll_timeout(rtc->peripheral, RTC_ADDR1, val,\n\t\t\t\t\t      val & RTC_ADDR1_S_READY, 10,\n\t\t\t\t\t      10000))\n\t\t\treturn 0;\n\n\t\tdev_warn(rtc->dev, \"failed to get bus, resetting RTC\\n\");\n\n\t\tret = reset_control_reset(rtc->reset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_err(rtc->dev, \"bus is not ready\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int meson_rtc_serial_bus_reg_read(void *context, unsigned int reg,\n\t\t\t\t\t unsigned int *data)\n{\n\tstruct meson_rtc *rtc = context;\n\tint ret;\n\n\tret = meson_rtc_get_bus(rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SEN,\n\t\t\t   RTC_ADDR0_LINE_SEN);\n\tmeson_rtc_send_bits(rtc, reg, RTC_ADDR_BITS);\n\tmeson_rtc_set_dir(rtc, 0);\n\t*data = meson_rtc_get_data(rtc);\n\n\treturn 0;\n}\n\nstatic int meson_rtc_serial_bus_reg_write(void *context, unsigned int reg,\n\t\t\t\t\t  unsigned int data)\n{\n\tstruct meson_rtc *rtc = context;\n\tint ret;\n\n\tret = meson_rtc_get_bus(rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0, RTC_ADDR0_LINE_SEN,\n\t\t\t   RTC_ADDR0_LINE_SEN);\n\tmeson_rtc_send_bits(rtc, data, RTC_DATA_BITS);\n\tmeson_rtc_send_bits(rtc, reg, RTC_ADDR_BITS);\n\tmeson_rtc_set_dir(rtc, 1);\n\n\treturn 0;\n}\n\nstatic const struct regmap_bus meson_rtc_serial_bus = {\n\t.reg_read\t= meson_rtc_serial_bus_reg_read,\n\t.reg_write\t= meson_rtc_serial_bus_reg_write,\n};\n\nstatic const struct regmap_config meson_rtc_serial_regmap_config = {\n\t.name\t\t= \"serial-registers\",\n\t.reg_bits\t= 4,\n\t.reg_stride\t= 1,\n\t.val_bits\t= 32,\n\t.max_register\t= RTC_REGMEM_3,\n\t.fast_io\t= false,\n};\n\nstatic int meson_rtc_write_static(struct meson_rtc *rtc, u32 data)\n{\n\tu32 tmp;\n\n\tregmap_write(rtc->peripheral, RTC_REG4,\n\t\t     FIELD_PREP(RTC_REG4_STATIC_VALUE, (data >> 8)));\n\n\t \n\ttmp = FIELD_PREP(RTC_ADDR0_DATA, (data & 0xff)) | RTC_ADDR0_START_SER;\n\tregmap_update_bits(rtc->peripheral, RTC_ADDR0,\n\t\t\t   RTC_ADDR0_DATA | RTC_ADDR0_START_SER, tmp);\n\n\t \n\treturn regmap_read_poll_timeout(rtc->peripheral, RTC_REG4, tmp,\n\t\t\t\t\t!(tmp & RTC_ADDR0_WAIT_SER), 10,\n\t\t\t\t\t10000);\n}\n\n \n\nstatic int meson_rtc_gettime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct meson_rtc *rtc = dev_get_drvdata(dev);\n\tu32 time;\n\tint ret;\n\n\tret = regmap_read(rtc->serial, RTC_COUNTER, &time);\n\tif (!ret)\n\t\trtc_time64_to_tm(time, tm);\n\n\treturn ret;\n}\n\nstatic int meson_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct meson_rtc *rtc = dev_get_drvdata(dev);\n\n\treturn regmap_write(rtc->serial, RTC_COUNTER, rtc_tm_to_time64(tm));\n}\n\nstatic const struct rtc_class_ops meson_rtc_ops = {\n\t.read_time\t= meson_rtc_gettime,\n\t.set_time\t= meson_rtc_settime,\n};\n\n \n\nstatic int meson_rtc_regmem_read(void *context, unsigned int offset,\n\t\t\t\t void *buf, size_t bytes)\n{\n\tstruct meson_rtc *rtc = context;\n\tunsigned int read_offset, read_size;\n\n\tread_offset = RTC_REGMEM_0 + (offset / 4);\n\tread_size = bytes / 4;\n\n\treturn regmap_bulk_read(rtc->serial, read_offset, buf, read_size);\n}\n\nstatic int meson_rtc_regmem_write(void *context, unsigned int offset,\n\t\t\t\t  void *buf, size_t bytes)\n{\n\tstruct meson_rtc *rtc = context;\n\tunsigned int write_offset, write_size;\n\n\twrite_offset = RTC_REGMEM_0 + (offset / 4);\n\twrite_size = bytes / 4;\n\n\treturn regmap_bulk_write(rtc->serial, write_offset, buf, write_size);\n}\n\nstatic int meson_rtc_probe(struct platform_device *pdev)\n{\n\tstruct nvmem_config meson_rtc_nvmem_config = {\n\t\t.name = \"meson-rtc-regmem\",\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.word_size = 4,\n\t\t.stride = 4,\n\t\t.size = 4 * 4,\n\t\t.reg_read = meson_rtc_regmem_read,\n\t\t.reg_write = meson_rtc_regmem_write,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_rtc *rtc;\n\tvoid __iomem *base;\n\tint ret;\n\tu32 tm;\n\n\trtc = devm_kzalloc(dev, sizeof(struct meson_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc->rtc))\n\t\treturn PTR_ERR(rtc->rtc);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->dev = dev;\n\n\trtc->rtc->ops = &meson_rtc_ops;\n\trtc->rtc->range_max = U32_MAX;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\trtc->peripheral = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t&meson_rtc_peripheral_regmap_config);\n\tif (IS_ERR(rtc->peripheral)) {\n\t\tdev_err(dev, \"failed to create peripheral regmap\\n\");\n\t\treturn PTR_ERR(rtc->peripheral);\n\t}\n\n\trtc->reset = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(rtc->reset)) {\n\t\tdev_err(dev, \"missing reset line\\n\");\n\t\treturn PTR_ERR(rtc->reset);\n\t}\n\n\trtc->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(rtc->vdd)) {\n\t\tdev_err(dev, \"failed to get the vdd-supply\\n\");\n\t\treturn PTR_ERR(rtc->vdd);\n\t}\n\n\tret = regulator_enable(rtc->vdd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable vdd-supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = meson_rtc_write_static(rtc, MESON_STATIC_DEFAULT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set static values\\n\");\n\t\tgoto out_disable_vdd;\n\t}\n\n\trtc->serial = devm_regmap_init(dev, &meson_rtc_serial_bus, rtc,\n\t\t\t\t       &meson_rtc_serial_regmap_config);\n\tif (IS_ERR(rtc->serial)) {\n\t\tdev_err(dev, \"failed to create serial regmap\\n\");\n\t\tret = PTR_ERR(rtc->serial);\n\t\tgoto out_disable_vdd;\n\t}\n\n\t \n\tret = regmap_read(rtc->serial, RTC_COUNTER, &tm);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot read RTC counter, RTC not functional\\n\");\n\t\tgoto out_disable_vdd;\n\t}\n\n\tmeson_rtc_nvmem_config.priv = rtc;\n\tret = devm_rtc_nvmem_register(rtc->rtc, &meson_rtc_nvmem_config);\n\tif (ret)\n\t\tgoto out_disable_vdd;\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\tgoto out_disable_vdd;\n\n\treturn 0;\n\nout_disable_vdd:\n\tregulator_disable(rtc->vdd);\n\treturn ret;\n}\n\nstatic const __maybe_unused struct of_device_id meson_rtc_dt_match[] = {\n\t{ .compatible = \"amlogic,meson6-rtc\", },\n\t{ .compatible = \"amlogic,meson8-rtc\", },\n\t{ .compatible = \"amlogic,meson8b-rtc\", },\n\t{ .compatible = \"amlogic,meson8m2-rtc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, meson_rtc_dt_match);\n\nstatic struct platform_driver meson_rtc_driver = {\n\t.probe\t\t= meson_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"meson-rtc\",\n\t\t.of_match_table\t= of_match_ptr(meson_rtc_dt_match),\n\t},\n};\nmodule_platform_driver(meson_rtc_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson RTC Driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben.dooks@codethink.co.uk>\");\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:meson-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}