{
  "module_name": "rtc-max8998.c",
  "hash_id": "0100586be56a7b0a1cc386bed77a0c96e031416655252ebda243df0b3e578a49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-max8998.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/bcd.h>\n#include <linux/irqdomain.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/max8998.h>\n#include <linux/mfd/max8998-private.h>\n#include <linux/delay.h>\n\n#define MAX8998_RTC_SEC\t\t\t0x00\n#define MAX8998_RTC_MIN\t\t\t0x01\n#define MAX8998_RTC_HOUR\t\t0x02\n#define MAX8998_RTC_WEEKDAY\t\t0x03\n#define MAX8998_RTC_DATE\t\t0x04\n#define MAX8998_RTC_MONTH\t\t0x05\n#define MAX8998_RTC_YEAR1\t\t0x06\n#define MAX8998_RTC_YEAR2\t\t0x07\n#define MAX8998_ALARM0_SEC\t\t0x08\n#define MAX8998_ALARM0_MIN\t\t0x09\n#define MAX8998_ALARM0_HOUR\t\t0x0a\n#define MAX8998_ALARM0_WEEKDAY\t\t0x0b\n#define MAX8998_ALARM0_DATE\t\t0x0c\n#define MAX8998_ALARM0_MONTH\t\t0x0d\n#define MAX8998_ALARM0_YEAR1\t\t0x0e\n#define MAX8998_ALARM0_YEAR2\t\t0x0f\n#define MAX8998_ALARM1_SEC\t\t0x10\n#define MAX8998_ALARM1_MIN\t\t0x11\n#define MAX8998_ALARM1_HOUR\t\t0x12\n#define MAX8998_ALARM1_WEEKDAY\t\t0x13\n#define MAX8998_ALARM1_DATE\t\t0x14\n#define MAX8998_ALARM1_MONTH\t\t0x15\n#define MAX8998_ALARM1_YEAR1\t\t0x16\n#define MAX8998_ALARM1_YEAR2\t\t0x17\n#define MAX8998_ALARM0_CONF\t\t0x18\n#define MAX8998_ALARM1_CONF\t\t0x19\n#define MAX8998_RTC_STATUS\t\t0x1a\n#define MAX8998_WTSR_SMPL_CNTL\t\t0x1b\n#define MAX8998_TEST\t\t\t0x1f\n\n#define HOUR_12\t\t\t\t(1 << 7)\n#define HOUR_PM\t\t\t\t(1 << 5)\n#define ALARM0_STATUS\t\t\t(1 << 1)\n#define ALARM1_STATUS\t\t\t(1 << 2)\n\nenum {\n\tRTC_SEC = 0,\n\tRTC_MIN,\n\tRTC_HOUR,\n\tRTC_WEEKDAY,\n\tRTC_DATE,\n\tRTC_MONTH,\n\tRTC_YEAR1,\n\tRTC_YEAR2,\n};\n\nstruct max8998_rtc_info {\n\tstruct device\t\t*dev;\n\tstruct max8998_dev\t*max8998;\n\tstruct i2c_client\t*rtc;\n\tstruct rtc_device\t*rtc_dev;\n\tint irq;\n\tbool lp3974_bug_workaround;\n};\n\nstatic void max8998_data_to_tm(u8 *data, struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(data[RTC_SEC]);\n\ttm->tm_min = bcd2bin(data[RTC_MIN]);\n\tif (data[RTC_HOUR] & HOUR_12) {\n\t\ttm->tm_hour = bcd2bin(data[RTC_HOUR] & 0x1f);\n\t\tif (data[RTC_HOUR] & HOUR_PM)\n\t\t\ttm->tm_hour += 12;\n\t} else\n\t\ttm->tm_hour = bcd2bin(data[RTC_HOUR] & 0x3f);\n\n\ttm->tm_wday = data[RTC_WEEKDAY] & 0x07;\n\ttm->tm_mday = bcd2bin(data[RTC_DATE]);\n\ttm->tm_mon = bcd2bin(data[RTC_MONTH]);\n\ttm->tm_year = bcd2bin(data[RTC_YEAR1]) + bcd2bin(data[RTC_YEAR2]) * 100;\n\ttm->tm_year -= 1900;\n}\n\nstatic void max8998_tm_to_data(struct rtc_time *tm, u8 *data)\n{\n\tdata[RTC_SEC] = bin2bcd(tm->tm_sec);\n\tdata[RTC_MIN] = bin2bcd(tm->tm_min);\n\tdata[RTC_HOUR] = bin2bcd(tm->tm_hour);\n\tdata[RTC_WEEKDAY] = tm->tm_wday;\n\tdata[RTC_DATE] = bin2bcd(tm->tm_mday);\n\tdata[RTC_MONTH] = bin2bcd(tm->tm_mon);\n\tdata[RTC_YEAR1] = bin2bcd(tm->tm_year % 100);\n\tdata[RTC_YEAR2] = bin2bcd((tm->tm_year + 1900) / 100);\n}\n\nstatic int max8998_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8998_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[8];\n\tint ret;\n\n\tret = max8998_bulk_read(info->rtc, MAX8998_RTC_SEC, 8, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmax8998_data_to_tm(data, tm);\n\n\treturn 0;\n}\n\nstatic int max8998_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8998_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[8];\n\tint ret;\n\n\tmax8998_tm_to_data(tm, data);\n\n\tret = max8998_bulk_write(info->rtc, MAX8998_RTC_SEC, 8, data);\n\n\tif (info->lp3974_bug_workaround)\n\t\tmsleep(2000);\n\n\treturn ret;\n}\n\nstatic int max8998_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8998_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[8];\n\tu8 val;\n\tint ret;\n\n\tret = max8998_bulk_read(info->rtc, MAX8998_ALARM0_SEC, 8, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmax8998_data_to_tm(data, &alrm->time);\n\n\tret = max8998_read_reg(info->rtc, MAX8998_ALARM0_CONF, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talrm->enabled = !!val;\n\n\tret = max8998_read_reg(info->rtc, MAX8998_RTC_STATUS, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & ALARM0_STATUS)\n\t\talrm->pending = 1;\n\telse\n\t\talrm->pending = 0;\n\n\treturn 0;\n}\n\nstatic int max8998_rtc_stop_alarm(struct max8998_rtc_info *info)\n{\n\tint ret = max8998_write_reg(info->rtc, MAX8998_ALARM0_CONF, 0);\n\n\tif (info->lp3974_bug_workaround)\n\t\tmsleep(2000);\n\n\treturn ret;\n}\n\nstatic int max8998_rtc_start_alarm(struct max8998_rtc_info *info)\n{\n\tint ret;\n\tu8 alarm0_conf = 0x77;\n\n\t \n\tif (info->lp3974_bug_workaround)\n\t\talarm0_conf = 0x57;\n\n\tret = max8998_write_reg(info->rtc, MAX8998_ALARM0_CONF, alarm0_conf);\n\n\tif (info->lp3974_bug_workaround)\n\t\tmsleep(2000);\n\n\treturn ret;\n}\n\nstatic int max8998_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8998_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[8];\n\tint ret;\n\n\tmax8998_tm_to_data(&alrm->time, data);\n\n\tret = max8998_rtc_stop_alarm(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = max8998_bulk_write(info->rtc, MAX8998_ALARM0_SEC, 8, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (info->lp3974_bug_workaround)\n\t\tmsleep(2000);\n\n\tif (alrm->enabled)\n\t\tret = max8998_rtc_start_alarm(info);\n\n\treturn ret;\n}\n\nstatic int max8998_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct max8998_rtc_info *info = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\treturn max8998_rtc_start_alarm(info);\n\telse\n\t\treturn max8998_rtc_stop_alarm(info);\n}\n\nstatic irqreturn_t max8998_rtc_alarm_irq(int irq, void *data)\n{\n\tstruct max8998_rtc_info *info = data;\n\n\trtc_update_irq(info->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops max8998_rtc_ops = {\n\t.read_time = max8998_rtc_read_time,\n\t.set_time = max8998_rtc_set_time,\n\t.read_alarm = max8998_rtc_read_alarm,\n\t.set_alarm = max8998_rtc_set_alarm,\n\t.alarm_irq_enable = max8998_rtc_alarm_irq_enable,\n};\n\nstatic int max8998_rtc_probe(struct platform_device *pdev)\n{\n\tstruct max8998_dev *max8998 = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8998_platform_data *pdata = max8998->pdata;\n\tstruct max8998_rtc_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct max8998_rtc_info),\n\t\t\tGFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\tinfo->max8998 = max8998;\n\tinfo->rtc = max8998->rtc;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tinfo->rtc_dev = devm_rtc_device_register(&pdev->dev, \"max8998-rtc\",\n\t\t\t&max8998_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(info->rtc_dev)) {\n\t\tret = PTR_ERR(info->rtc_dev);\n\t\tdev_err(&pdev->dev, \"Failed to register RTC device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!max8998->irq_domain)\n\t\tgoto no_irq;\n\n\tinfo->irq = irq_create_mapping(max8998->irq_domain, MAX8998_IRQ_ALARM0);\n\tif (!info->irq) {\n\t\tdev_warn(&pdev->dev, \"Failed to map alarm IRQ\\n\");\n\t\tgoto no_irq;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\n\t\t\t\tmax8998_rtc_alarm_irq, 0, \"rtc-alarm0\", info);\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ: %d: %d\\n\",\n\t\t\tinfo->irq, ret);\n\nno_irq:\n\tdev_info(&pdev->dev, \"RTC CHIP NAME: %s\\n\", pdev->id_entry->name);\n\tif (pdata && pdata->rtc_delay) {\n\t\tinfo->lp3974_bug_workaround = true;\n\t\tdev_warn(&pdev->dev, \"LP3974 with RTC REGERR option.\"\n\t\t\t\t\" RTC updates will be extremely slow.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max8998_rtc_id[] = {\n\t{ \"max8998-rtc\", TYPE_MAX8998 },\n\t{ \"lp3974-rtc\", TYPE_LP3974 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, max8998_rtc_id);\n\nstatic struct platform_driver max8998_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8998-rtc\",\n\t},\n\t.probe\t\t= max8998_rtc_probe,\n\t.id_table\t= max8998_rtc_id,\n};\n\nmodule_platform_driver(max8998_rtc_driver);\n\nMODULE_AUTHOR(\"Minkyu Kang <mk7.kang@samsung.com>\");\nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX8998 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}