{
  "module_name": "rtc-lpc24xx.c",
  "hash_id": "190922ed19b488c9428629095d28f9ef6c2f3e0f181447140331a35075015e90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-lpc24xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n \n#define LPC24XX_ILR\t\t0x00\n#define  LPC24XX_RTCCIF\t\tBIT(0)\n#define  LPC24XX_RTCALF\t\tBIT(1)\n#define LPC24XX_CTC\t\t0x04\n#define LPC24XX_CCR\t\t0x08\n#define  LPC24XX_CLKEN\t\tBIT(0)\n#define  LPC178X_CCALEN\t\tBIT(4)\n#define LPC24XX_CIIR\t\t0x0c\n#define LPC24XX_AMR\t\t0x10\n#define  LPC24XX_ALARM_DISABLE\t0xff\n#define LPC24XX_CTIME0\t\t0x14\n#define LPC24XX_CTIME1\t\t0x18\n#define LPC24XX_CTIME2\t\t0x1c\n#define LPC24XX_SEC\t\t0x20\n#define LPC24XX_MIN\t\t0x24\n#define LPC24XX_HOUR\t\t0x28\n#define LPC24XX_DOM\t\t0x2c\n#define LPC24XX_DOW\t\t0x30\n#define LPC24XX_DOY\t\t0x34\n#define LPC24XX_MONTH\t\t0x38\n#define LPC24XX_YEAR\t\t0x3c\n#define LPC24XX_ALSEC\t\t0x60\n#define LPC24XX_ALMIN\t\t0x64\n#define LPC24XX_ALHOUR\t\t0x68\n#define LPC24XX_ALDOM\t\t0x6c\n#define LPC24XX_ALDOW\t\t0x70\n#define LPC24XX_ALDOY\t\t0x74\n#define LPC24XX_ALMON\t\t0x78\n#define LPC24XX_ALYEAR\t\t0x7c\n\n \n#define CT0_SECS(x)\t\t(((x) >> 0)  & 0x3f)\n#define CT0_MINS(x)\t\t(((x) >> 8)  & 0x3f)\n#define CT0_HOURS(x)\t\t(((x) >> 16) & 0x1f)\n#define CT0_DOW(x)\t\t(((x) >> 24) & 0x07)\n#define CT1_DOM(x)\t\t(((x) >> 0)  & 0x1f)\n#define CT1_MONTH(x)\t\t(((x) >> 8)  & 0x0f)\n#define CT1_YEAR(x)\t\t(((x) >> 16) & 0xfff)\n#define CT2_DOY(x)\t\t(((x) >> 0)  & 0xfff)\n\n#define rtc_readl(dev, reg)\t\treadl((dev)->rtc_base + (reg))\n#define rtc_writel(dev, reg, val)\twritel((val), (dev)->rtc_base + (reg))\n\nstruct lpc24xx_rtc {\n\tvoid __iomem *rtc_base;\n\tstruct rtc_device *rtc;\n\tstruct clk *clk_rtc;\n\tstruct clk *clk_reg;\n};\n\nstatic int lpc24xx_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\n\n\t \n\trtc_writel(rtc, LPC24XX_CCR, LPC178X_CCALEN);\n\n\trtc_writel(rtc, LPC24XX_SEC,\ttm->tm_sec);\n\trtc_writel(rtc, LPC24XX_MIN,\ttm->tm_min);\n\trtc_writel(rtc, LPC24XX_HOUR,\ttm->tm_hour);\n\trtc_writel(rtc, LPC24XX_DOW,\ttm->tm_wday);\n\trtc_writel(rtc, LPC24XX_DOM,\ttm->tm_mday);\n\trtc_writel(rtc, LPC24XX_DOY,\ttm->tm_yday);\n\trtc_writel(rtc, LPC24XX_MONTH,\ttm->tm_mon);\n\trtc_writel(rtc, LPC24XX_YEAR,\ttm->tm_year);\n\n\trtc_writel(rtc, LPC24XX_CCR, LPC24XX_CLKEN | LPC178X_CCALEN);\n\n\treturn 0;\n}\n\nstatic int lpc24xx_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\n\tu32 ct0, ct1, ct2;\n\n\tct0 = rtc_readl(rtc, LPC24XX_CTIME0);\n\tct1 = rtc_readl(rtc, LPC24XX_CTIME1);\n\tct2 = rtc_readl(rtc, LPC24XX_CTIME2);\n\n\ttm->tm_sec  = CT0_SECS(ct0);\n\ttm->tm_min  = CT0_MINS(ct0);\n\ttm->tm_hour = CT0_HOURS(ct0);\n\ttm->tm_wday = CT0_DOW(ct0);\n\ttm->tm_mon  = CT1_MONTH(ct1);\n\ttm->tm_mday = CT1_DOM(ct1);\n\ttm->tm_year = CT1_YEAR(ct1);\n\ttm->tm_yday = CT2_DOY(ct2);\n\n\treturn 0;\n}\n\nstatic int lpc24xx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &wkalrm->time;\n\n\ttm->tm_sec  = rtc_readl(rtc, LPC24XX_ALSEC);\n\ttm->tm_min  = rtc_readl(rtc, LPC24XX_ALMIN);\n\ttm->tm_hour = rtc_readl(rtc, LPC24XX_ALHOUR);\n\ttm->tm_mday = rtc_readl(rtc, LPC24XX_ALDOM);\n\ttm->tm_wday = rtc_readl(rtc, LPC24XX_ALDOW);\n\ttm->tm_yday = rtc_readl(rtc, LPC24XX_ALDOY);\n\ttm->tm_mon  = rtc_readl(rtc, LPC24XX_ALMON);\n\ttm->tm_year = rtc_readl(rtc, LPC24XX_ALYEAR);\n\n\twkalrm->enabled = rtc_readl(rtc, LPC24XX_AMR) == 0;\n\twkalrm->pending = !!(rtc_readl(rtc, LPC24XX_ILR) & LPC24XX_RTCCIF);\n\n\treturn rtc_valid_tm(&wkalrm->time);\n}\n\nstatic int lpc24xx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &wkalrm->time;\n\n\t \n\trtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\n\n\trtc_writel(rtc, LPC24XX_ALSEC,  tm->tm_sec);\n\trtc_writel(rtc, LPC24XX_ALMIN,  tm->tm_min);\n\trtc_writel(rtc, LPC24XX_ALHOUR, tm->tm_hour);\n\trtc_writel(rtc, LPC24XX_ALDOM,  tm->tm_mday);\n\trtc_writel(rtc, LPC24XX_ALDOW,  tm->tm_wday);\n\trtc_writel(rtc, LPC24XX_ALDOY,  tm->tm_yday);\n\trtc_writel(rtc, LPC24XX_ALMON,  tm->tm_mon);\n\trtc_writel(rtc, LPC24XX_ALYEAR, tm->tm_year);\n\n\tif (wkalrm->enabled)\n\t\trtc_writel(rtc, LPC24XX_AMR, 0);\n\n\treturn 0;\n}\n\nstatic int lpc24xx_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (enable)\n\t\trtc_writel(rtc, LPC24XX_AMR, 0);\n\telse\n\t\trtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\n\n\treturn 0;\n}\n\nstatic irqreturn_t lpc24xx_rtc_interrupt(int irq, void *data)\n{\n\tunsigned long events = RTC_IRQF;\n\tstruct lpc24xx_rtc *rtc = data;\n\tu32 rtc_iir;\n\n\t \n\trtc_iir = rtc_readl(rtc, LPC24XX_ILR);\n\tif (rtc_iir & LPC24XX_RTCALF) {\n\t\tevents |= RTC_AF;\n\t\trtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\n\t}\n\n\t \n\trtc_writel(rtc, LPC24XX_ILR, rtc_iir);\n\trtc_update_irq(rtc->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops lpc24xx_rtc_ops = {\n\t.read_time\t\t= lpc24xx_rtc_read_time,\n\t.set_time\t\t= lpc24xx_rtc_set_time,\n\t.read_alarm\t\t= lpc24xx_rtc_read_alarm,\n\t.set_alarm\t\t= lpc24xx_rtc_set_alarm,\n\t.alarm_irq_enable\t= lpc24xx_rtc_alarm_irq_enable,\n};\n\nstatic int lpc24xx_rtc_probe(struct platform_device *pdev)\n{\n\tstruct lpc24xx_rtc *rtc;\n\tint irq, ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->rtc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->rtc_base))\n\t\treturn PTR_ERR(rtc->rtc_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\trtc->clk_rtc = devm_clk_get(&pdev->dev, \"rtc\");\n\tif (IS_ERR(rtc->clk_rtc)) {\n\t\tdev_err(&pdev->dev, \"error getting rtc clock\\n\");\n\t\treturn PTR_ERR(rtc->clk_rtc);\n\t}\n\n\trtc->clk_reg = devm_clk_get(&pdev->dev, \"reg\");\n\tif (IS_ERR(rtc->clk_reg)) {\n\t\tdev_err(&pdev->dev, \"error getting reg clock\\n\");\n\t\treturn PTR_ERR(rtc->clk_reg);\n\t}\n\n\tret = clk_prepare_enable(rtc->clk_rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable rtc clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(rtc->clk_reg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to enable reg clock\\n\");\n\t\tgoto disable_rtc_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\t \n\trtc_writel(rtc, LPC24XX_ILR, LPC24XX_RTCCIF | LPC24XX_RTCALF);\n\n\t \n\trtc_writel(rtc, LPC24XX_CCR, LPC24XX_CLKEN | LPC178X_CCALEN);\n\n\tret = devm_request_irq(&pdev->dev, irq, lpc24xx_rtc_interrupt, 0,\n\t\t\t       pdev->name, rtc);\n\tif (ret < 0) {\n\t\tdev_warn(&pdev->dev, \"can't request interrupt\\n\");\n\t\tgoto disable_clks;\n\t}\n\n\trtc->rtc = devm_rtc_device_register(&pdev->dev, \"lpc24xx-rtc\",\n\t\t\t\t\t    &lpc24xx_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc->rtc)) {\n\t\tdev_err(&pdev->dev, \"can't register rtc device\\n\");\n\t\tret = PTR_ERR(rtc->rtc);\n\t\tgoto disable_clks;\n\t}\n\n\treturn 0;\n\ndisable_clks:\n\tclk_disable_unprepare(rtc->clk_reg);\ndisable_rtc_clk:\n\tclk_disable_unprepare(rtc->clk_rtc);\n\treturn ret;\n}\n\nstatic void lpc24xx_rtc_remove(struct platform_device *pdev)\n{\n\tstruct lpc24xx_rtc *rtc = platform_get_drvdata(pdev);\n\n\t \n\trtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\n\trtc_writel(rtc, LPC24XX_CIIR, 0);\n\n\trtc_writel(rtc, LPC24XX_CCR, LPC178X_CCALEN);\n\n\tclk_disable_unprepare(rtc->clk_rtc);\n\tclk_disable_unprepare(rtc->clk_reg);\n}\n\nstatic const struct of_device_id lpc24xx_rtc_match[] = {\n\t{ .compatible = \"nxp,lpc1788-rtc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpc24xx_rtc_match);\n\nstatic struct platform_driver lpc24xx_rtc_driver = {\n\t.probe\t= lpc24xx_rtc_probe,\n\t.remove_new = lpc24xx_rtc_remove,\n\t.driver\t= {\n\t\t.name = \"lpc24xx-rtc\",\n\t\t.of_match_table\t= lpc24xx_rtc_match,\n\t},\n};\nmodule_platform_driver(lpc24xx_rtc_driver);\n\nMODULE_AUTHOR(\"Kevin Wells <wellsk40@gmail.com>\");\nMODULE_DESCRIPTION(\"RTC driver for the LPC178x/18xx/408x/43xx SoCs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}