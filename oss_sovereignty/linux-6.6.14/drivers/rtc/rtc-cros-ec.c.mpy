{
  "module_name": "rtc-cros-ec.c",
  "hash_id": "61af84ca6eed61335121d48d0e8ba06091680d1ab7d39d68019d088a71728d8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-cros-ec.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#define DRV_NAME\t\"cros-ec-rtc\"\n\n#define SECS_PER_DAY\t(24 * 60 * 60)\n\n \nstruct cros_ec_rtc {\n\tstruct cros_ec_device *cros_ec;\n\tstruct rtc_device *rtc;\n\tstruct notifier_block notifier;\n\tu32 saved_alarm;\n};\n\nstatic int cros_ec_rtc_get(struct cros_ec_device *cros_ec, u32 command,\n\t\t\t   u32 *response)\n{\n\tint ret;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_response_rtc data;\n\t} __packed msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg.command = command;\n\tmsg.msg.insize = sizeof(msg.data);\n\n\tret = cros_ec_cmd_xfer_status(cros_ec, &msg.msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*response = msg.data.time;\n\n\treturn 0;\n}\n\nstatic int cros_ec_rtc_set(struct cros_ec_device *cros_ec, u32 command,\n\t\t\t   u32 param)\n{\n\tint ret;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_response_rtc data;\n\t} __packed msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg.command = command;\n\tmsg.msg.outsize = sizeof(msg.data);\n\tmsg.data.time = param;\n\n\tret = cros_ec_cmd_xfer_status(cros_ec, &msg.msg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\n \nstatic int cros_ec_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(dev);\n\tstruct cros_ec_device *cros_ec = cros_ec_rtc->cros_ec;\n\tint ret;\n\tu32 time;\n\n\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_VALUE, &time);\n\tif (ret) {\n\t\tdev_err(dev, \"error getting time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(dev);\n\tstruct cros_ec_device *cros_ec = cros_ec_rtc->cros_ec;\n\tint ret;\n\ttime64_t time = rtc_tm_to_time64(tm);\n\n\tret = cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_VALUE, (u32)time);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error setting time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(dev);\n\tstruct cros_ec_device *cros_ec = cros_ec_rtc->cros_ec;\n\tint ret;\n\tu32 current_time, alarm_offset;\n\n\t \n\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_VALUE, &current_time);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error getting time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_ALARM, &alarm_offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error getting alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtc_time64_to_tm(current_time + alarm_offset, &alrm->time);\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(dev);\n\tstruct cros_ec_device *cros_ec = cros_ec_rtc->cros_ec;\n\tint ret;\n\ttime64_t alarm_time;\n\tu32 current_time, alarm_offset;\n\n\t \n\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_VALUE, &current_time);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error getting time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talarm_time = rtc_tm_to_time64(&alrm->time);\n\n\tif (alarm_time < 0 || alarm_time > U32_MAX)\n\t\treturn -EINVAL;\n\n\tif (!alrm->enabled) {\n\t\t \n\t\talarm_offset = EC_RTC_ALARM_CLEAR;\n\t\tcros_ec_rtc->saved_alarm = (u32)alarm_time;\n\t} else {\n\t\t \n\t\tif ((u32)alarm_time <= current_time)\n\t\t\treturn -ETIME;\n\n\t\talarm_offset = (u32)alarm_time - current_time;\n\t}\n\n\tret = cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_ALARM, alarm_offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error setting alarm in %u seconds: %d\\n\",\n\t\t\talarm_offset, ret);\n\t\t \n\t\tif (ret == -EINVAL)\n\t\t\tret = -ERANGE;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(dev);\n\tstruct cros_ec_device *cros_ec = cros_ec_rtc->cros_ec;\n\tint ret;\n\tu32 current_time, alarm_offset, alarm_value;\n\n\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_VALUE, &current_time);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error getting time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (enabled) {\n\t\t \n\t\tif (cros_ec_rtc->saved_alarm < current_time)\n\t\t\talarm_offset = EC_RTC_ALARM_CLEAR;\n\t\telse\n\t\t\talarm_offset = cros_ec_rtc->saved_alarm - current_time;\n\n\t\tret = cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_ALARM,\n\t\t\t\t      alarm_offset);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error restoring alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tret = cros_ec_rtc_get(cros_ec, EC_CMD_RTC_GET_ALARM,\n\t\t\t\t      &alarm_offset);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error saving alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\talarm_value = current_time + alarm_offset;\n\n\t\t \n\t\tif (alarm_value < current_time)\n\t\t\tcros_ec_rtc->saved_alarm = EC_RTC_ALARM_CLEAR;\n\t\telse\n\t\t\tcros_ec_rtc->saved_alarm = alarm_value;\n\n\t\talarm_offset = EC_RTC_ALARM_CLEAR;\n\t\tret = cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_ALARM,\n\t\t\t\t      alarm_offset);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error disabling alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_rtc_event(struct notifier_block *nb,\n\t\t\t     unsigned long queued_during_suspend,\n\t\t\t     void *_notify)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc;\n\tstruct rtc_device *rtc;\n\tstruct cros_ec_device *cros_ec;\n\tu32 host_event;\n\n\tcros_ec_rtc = container_of(nb, struct cros_ec_rtc, notifier);\n\trtc = cros_ec_rtc->rtc;\n\tcros_ec = cros_ec_rtc->cros_ec;\n\n\thost_event = cros_ec_get_host_event(cros_ec);\n\tif (host_event & EC_HOST_EVENT_MASK(EC_HOST_EVENT_RTC)) {\n\t\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\n\t\treturn NOTIFY_OK;\n\t} else {\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic const struct rtc_class_ops cros_ec_rtc_ops = {\n\t.read_time = cros_ec_rtc_read_time,\n\t.set_time = cros_ec_rtc_set_time,\n\t.read_alarm = cros_ec_rtc_read_alarm,\n\t.set_alarm = cros_ec_rtc_set_alarm,\n\t.alarm_irq_enable = cros_ec_rtc_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(&pdev->dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn enable_irq_wake(cros_ec_rtc->cros_ec->irq);\n\n\treturn 0;\n}\n\nstatic int cros_ec_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct cros_ec_rtc *cros_ec_rtc = dev_get_drvdata(&pdev->dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn disable_irq_wake(cros_ec_rtc->cros_ec->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_rtc_pm_ops, cros_ec_rtc_suspend,\n\t\t\t cros_ec_rtc_resume);\n\nstatic int cros_ec_rtc_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct cros_ec_device *cros_ec = ec_dev->ec_dev;\n\tstruct cros_ec_rtc *cros_ec_rtc;\n\tstruct rtc_time tm;\n\tint ret;\n\n\tcros_ec_rtc = devm_kzalloc(&pdev->dev, sizeof(*cros_ec_rtc),\n\t\t\t\t   GFP_KERNEL);\n\tif (!cros_ec_rtc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, cros_ec_rtc);\n\tcros_ec_rtc->cros_ec = cros_ec;\n\n\t \n\tret = cros_ec_rtc_read_time(&pdev->dev, &tm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read RTC time\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_init_wakeup(&pdev->dev, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to initialize wakeup\\n\");\n\t\treturn ret;\n\t}\n\n\tcros_ec_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(cros_ec_rtc->rtc))\n\t\treturn PTR_ERR(cros_ec_rtc->rtc);\n\n\tcros_ec_rtc->rtc->ops = &cros_ec_rtc_ops;\n\tcros_ec_rtc->rtc->range_max = U32_MAX;\n\n\t \n\tret = cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_ALARM, SECS_PER_DAY * 2);\n\tif (ret == -EINVAL)\n\t\tcros_ec_rtc->rtc->alarm_offset_max = SECS_PER_DAY - 1;\n\n\t(void)cros_ec_rtc_set(cros_ec, EC_CMD_RTC_SET_ALARM,\n\t\t\t      EC_RTC_ALARM_CLEAR);\n\n\tret = devm_rtc_register_device(cros_ec_rtc->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcros_ec_rtc->notifier.notifier_call = cros_ec_rtc_event;\n\tret = blocking_notifier_chain_register(&cros_ec->event_notifier,\n\t\t\t\t\t       &cros_ec_rtc->notifier);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register notifier\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void cros_ec_rtc_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_rtc *cros_ec_rtc = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = blocking_notifier_chain_unregister(\n\t\t\t\t&cros_ec_rtc->cros_ec->event_notifier,\n\t\t\t\t&cros_ec_rtc->notifier);\n\tif (ret)\n\t\tdev_err(dev, \"failed to unregister notifier\\n\");\n}\n\nstatic struct platform_driver cros_ec_rtc_driver = {\n\t.probe = cros_ec_rtc_probe,\n\t.remove_new = cros_ec_rtc_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_ec_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(cros_ec_rtc_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for Chrome OS ECs\");\nMODULE_AUTHOR(\"Stephen Barber <smbarber@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}