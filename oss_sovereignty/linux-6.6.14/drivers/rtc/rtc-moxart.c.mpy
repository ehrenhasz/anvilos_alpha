{
  "module_name": "rtc-moxart.c",
  "hash_id": "37a814126811fec4bd6cea3c22793da9e6b9242fda54eea74e025ade30589181",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-moxart.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/gpio/consumer.h>\n\n#define GPIO_RTC_RESERVED\t\t\t0x0C\n#define GPIO_RTC_DATA_SET\t\t\t0x10\n#define GPIO_RTC_DATA_CLEAR\t\t\t0x14\n#define GPIO_RTC_PIN_PULL_ENABLE\t\t0x18\n#define GPIO_RTC_PIN_PULL_TYPE\t\t\t0x1C\n#define GPIO_RTC_INT_ENABLE\t\t\t0x20\n#define GPIO_RTC_INT_RAW_STATE\t\t\t0x24\n#define GPIO_RTC_INT_MASKED_STATE\t\t0x28\n#define GPIO_RTC_INT_MASK\t\t\t0x2C\n#define GPIO_RTC_INT_CLEAR\t\t\t0x30\n#define GPIO_RTC_INT_TRIGGER\t\t\t0x34\n#define GPIO_RTC_INT_BOTH\t\t\t0x38\n#define GPIO_RTC_INT_RISE_NEG\t\t\t0x3C\n#define GPIO_RTC_BOUNCE_ENABLE\t\t\t0x40\n#define GPIO_RTC_BOUNCE_PRE_SCALE\t\t0x44\n#define GPIO_RTC_PROTECT_W\t\t\t0x8E\n#define GPIO_RTC_PROTECT_R\t\t\t0x8F\n#define GPIO_RTC_YEAR_W\t\t\t\t0x8C\n#define GPIO_RTC_YEAR_R\t\t\t\t0x8D\n#define GPIO_RTC_DAY_W\t\t\t\t0x8A\n#define GPIO_RTC_DAY_R\t\t\t\t0x8B\n#define GPIO_RTC_MONTH_W\t\t\t0x88\n#define GPIO_RTC_MONTH_R\t\t\t0x89\n#define GPIO_RTC_DATE_W\t\t\t\t0x86\n#define GPIO_RTC_DATE_R\t\t\t\t0x87\n#define GPIO_RTC_HOURS_W\t\t\t0x84\n#define GPIO_RTC_HOURS_R\t\t\t0x85\n#define GPIO_RTC_MINUTES_W\t\t\t0x82\n#define GPIO_RTC_MINUTES_R\t\t\t0x83\n#define GPIO_RTC_SECONDS_W\t\t\t0x80\n#define GPIO_RTC_SECONDS_R\t\t\t0x81\n#define GPIO_RTC_DELAY_TIME\t\t\t8\n\nstruct moxart_rtc {\n\tstruct rtc_device *rtc;\n\tspinlock_t rtc_lock;\n\tstruct gpio_desc *gpio_data;\n\tstruct gpio_desc *gpio_sclk;\n\tstruct gpio_desc *gpio_reset;\n};\n\nstatic int day_of_year[12] =\t{ 0, 31, 59, 90, 120, 151, 181,\n\t\t\t\t  212, 243, 273, 304, 334 };\n\nstatic void moxart_rtc_write_byte(struct device *dev, u8 data)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < 8; i++, data >>= 1) {\n\t\tgpiod_set_value(moxart_rtc->gpio_sclk, 0);\n\t\tgpiod_set_value(moxart_rtc->gpio_data, ((data & 1) == 1));\n\t\tudelay(GPIO_RTC_DELAY_TIME);\n\t\tgpiod_set_value(moxart_rtc->gpio_sclk, 1);\n\t\tudelay(GPIO_RTC_DELAY_TIME);\n\t}\n}\n\nstatic u8 moxart_rtc_read_byte(struct device *dev)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\tint i;\n\tu8 data = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tgpiod_set_value(moxart_rtc->gpio_sclk, 0);\n\t\tudelay(GPIO_RTC_DELAY_TIME);\n\t\tgpiod_set_value(moxart_rtc->gpio_sclk, 1);\n\t\tudelay(GPIO_RTC_DELAY_TIME);\n\t\tif (gpiod_get_value(moxart_rtc->gpio_data))\n\t\t\tdata |= (1 << i);\n\t\tudelay(GPIO_RTC_DELAY_TIME);\n\t}\n\treturn data;\n}\n\nstatic u8 moxart_rtc_read_register(struct device *dev, u8 cmd)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\tu8 data;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tgpiod_direction_output(moxart_rtc->gpio_data, 0);\n\tgpiod_set_value(moxart_rtc->gpio_reset, 1);\n\tudelay(GPIO_RTC_DELAY_TIME);\n\tmoxart_rtc_write_byte(dev, cmd);\n\tgpiod_direction_input(moxart_rtc->gpio_data);\n\tudelay(GPIO_RTC_DELAY_TIME);\n\tdata = moxart_rtc_read_byte(dev);\n\tgpiod_set_value(moxart_rtc->gpio_sclk, 0);\n\tgpiod_set_value(moxart_rtc->gpio_reset, 0);\n\tudelay(GPIO_RTC_DELAY_TIME);\n\n\tlocal_irq_restore(flags);\n\n\treturn data;\n}\n\nstatic void moxart_rtc_write_register(struct device *dev, u8 cmd, u8 data)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tgpiod_direction_output(moxart_rtc->gpio_data, 0);\n\tgpiod_set_value(moxart_rtc->gpio_reset, 1);\n\tudelay(GPIO_RTC_DELAY_TIME);\n\tmoxart_rtc_write_byte(dev, cmd);\n\tmoxart_rtc_write_byte(dev, data);\n\tgpiod_set_value(moxart_rtc->gpio_sclk, 0);\n\tgpiod_set_value(moxart_rtc->gpio_reset, 0);\n\tudelay(GPIO_RTC_DELAY_TIME);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic int moxart_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&moxart_rtc->rtc_lock);\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_PROTECT_W, 0);\n\tmoxart_rtc_write_register(dev, GPIO_RTC_YEAR_W,\n\t\t\t\t  (((tm->tm_year - 100) / 10) << 4) |\n\t\t\t\t  ((tm->tm_year - 100) % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_MONTH_W,\n\t\t\t\t  (((tm->tm_mon + 1) / 10) << 4) |\n\t\t\t\t  ((tm->tm_mon + 1) % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_DATE_W,\n\t\t\t\t  ((tm->tm_mday / 10) << 4) |\n\t\t\t\t  (tm->tm_mday % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_HOURS_W,\n\t\t\t\t  ((tm->tm_hour / 10) << 4) |\n\t\t\t\t  (tm->tm_hour % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_MINUTES_W,\n\t\t\t\t  ((tm->tm_min / 10) << 4) |\n\t\t\t\t  (tm->tm_min % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_SECONDS_W,\n\t\t\t\t  ((tm->tm_sec / 10) << 4) |\n\t\t\t\t  (tm->tm_sec % 10));\n\n\tmoxart_rtc_write_register(dev, GPIO_RTC_PROTECT_W, 0x80);\n\n\tspin_unlock_irq(&moxart_rtc->rtc_lock);\n\n\tdev_dbg(dev, \"%s: success tm_year=%d tm_mon=%d\\n\"\n\t\t\"tm_mday=%d tm_hour=%d tm_min=%d tm_sec=%d\\n\",\n\t\t__func__, tm->tm_year, tm->tm_mon, tm->tm_mday,\n\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\n\treturn 0;\n}\n\nstatic int moxart_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct moxart_rtc *moxart_rtc = dev_get_drvdata(dev);\n\tunsigned char v;\n\n\tspin_lock_irq(&moxart_rtc->rtc_lock);\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_SECONDS_R);\n\ttm->tm_sec = (((v & 0x70) >> 4) * 10) + (v & 0x0F);\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_MINUTES_R);\n\ttm->tm_min = (((v & 0x70) >> 4) * 10) + (v & 0x0F);\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_HOURS_R);\n\tif (v & 0x80) {  \n\t\ttm->tm_hour = (((v & 0x10) >> 4) * 10) + (v & 0x0F);\n\t\tif (v & 0x20) {  \n\t\t\ttm->tm_hour += 12;\n\t\t\tif (tm->tm_hour >= 24)\n\t\t\t\ttm->tm_hour = 0;\n\t\t}\n\t} else {  \n\t\ttm->tm_hour = (((v & 0x30) >> 4) * 10) + (v & 0x0F);\n\t}\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_DATE_R);\n\ttm->tm_mday = (((v & 0x30) >> 4) * 10) + (v & 0x0F);\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_MONTH_R);\n\ttm->tm_mon = (((v & 0x10) >> 4) * 10) + (v & 0x0F);\n\ttm->tm_mon--;\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_YEAR_R);\n\ttm->tm_year = (((v & 0xF0) >> 4) * 10) + (v & 0x0F);\n\ttm->tm_year += 100;\n\tif (tm->tm_year <= 69)\n\t\ttm->tm_year += 100;\n\n\tv = moxart_rtc_read_register(dev, GPIO_RTC_DAY_R);\n\ttm->tm_wday = (v & 0x0f) - 1;\n\ttm->tm_yday = day_of_year[tm->tm_mon];\n\ttm->tm_yday += (tm->tm_mday - 1);\n\tif (tm->tm_mon >= 2) {\n\t\tif (!(tm->tm_year % 4) && (tm->tm_year % 100))\n\t\t\ttm->tm_yday++;\n\t}\n\n\ttm->tm_isdst = 0;\n\n\tspin_unlock_irq(&moxart_rtc->rtc_lock);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops moxart_rtc_ops = {\n\t.read_time\t= moxart_rtc_read_time,\n\t.set_time\t= moxart_rtc_set_time,\n};\n\nstatic int moxart_rtc_probe(struct platform_device *pdev)\n{\n\tstruct moxart_rtc *moxart_rtc;\n\tint ret = 0;\n\n\tmoxart_rtc = devm_kzalloc(&pdev->dev, sizeof(*moxart_rtc), GFP_KERNEL);\n\tif (!moxart_rtc)\n\t\treturn -ENOMEM;\n\n\tmoxart_rtc->gpio_data = devm_gpiod_get(&pdev->dev, \"rtc-data\",\n\t\t\t\t\t       GPIOD_IN);\n\tret = PTR_ERR_OR_ZERO(moxart_rtc->gpio_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get rtc data gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmoxart_rtc->gpio_sclk = devm_gpiod_get(&pdev->dev, \"rtc-sclk\",\n\t\t\t\t\t       GPIOD_ASIS);\n\tret = PTR_ERR_OR_ZERO(moxart_rtc->gpio_sclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get rtc sclk gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmoxart_rtc->gpio_reset = devm_gpiod_get(&pdev->dev, \"rtc-reset\",\n\t\t\t\t\t\tGPIOD_ASIS);\n\tret = PTR_ERR_OR_ZERO(moxart_rtc->gpio_reset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get rtc reset gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&moxart_rtc->rtc_lock);\n\tplatform_set_drvdata(pdev, moxart_rtc);\n\n\tmoxart_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\t\t   &moxart_rtc_ops,\n\t\t\t\t\t\t   THIS_MODULE);\n\tif (IS_ERR(moxart_rtc->rtc)) {\n\t\tdev_err(&pdev->dev, \"devm_rtc_device_register failed\\n\");\n\t\treturn PTR_ERR(moxart_rtc->rtc);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id moxart_rtc_match[] = {\n\t{ .compatible = \"moxa,moxart-rtc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, moxart_rtc_match);\n\nstatic struct platform_driver moxart_rtc_driver = {\n\t.probe\t= moxart_rtc_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"moxart-rtc\",\n\t\t.of_match_table\t= moxart_rtc_match,\n\t},\n};\nmodule_platform_driver(moxart_rtc_driver);\n\nMODULE_DESCRIPTION(\"MOXART RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jonas Jensen <jonas.jensen@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}