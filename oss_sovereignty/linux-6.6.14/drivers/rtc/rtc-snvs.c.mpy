{
  "module_name": "rtc-snvs.c",
  "hash_id": "3481bf4f3924439e5aaf54db29299a52d21ff3b9634699a96a1bd9ce5b452b83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-snvs.c",
  "human_readable_source": "\n\n\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/rtc.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define SNVS_LPREGISTER_OFFSET\t0x34\n\n \n#define SNVS_LPCR\t\t0x04\n#define SNVS_LPSR\t\t0x18\n#define SNVS_LPSRTCMR\t\t0x1c\n#define SNVS_LPSRTCLR\t\t0x20\n#define SNVS_LPTAR\t\t0x24\n#define SNVS_LPPGDR\t\t0x30\n\n#define SNVS_LPCR_SRTC_ENV\t(1 << 0)\n#define SNVS_LPCR_LPTA_EN\t(1 << 1)\n#define SNVS_LPCR_LPWUI_EN\t(1 << 3)\n#define SNVS_LPSR_LPTA\t\t(1 << 0)\n\n#define SNVS_LPPGDR_INIT\t0x41736166\n#define CNTR_TO_SECS_SH\t\t15\n\n \n#define MAX_RTC_READ_DIFF_CYCLES\t320\n\nstruct snvs_rtc_data {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\tint offset;\n\tint irq;\n\tstruct clk *clk;\n};\n\n \nstatic u64 rtc_read_lpsrt(struct snvs_rtc_data *data)\n{\n\tu32 msb, lsb;\n\n\tregmap_read(data->regmap, data->offset + SNVS_LPSRTCMR, &msb);\n\tregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &lsb);\n\treturn (u64)msb << 32 | lsb;\n}\n\n \nstatic u32 rtc_read_lp_counter(struct snvs_rtc_data *data)\n{\n\tu64 read1, read2;\n\ts64 diff;\n\tunsigned int timeout = 100;\n\n\t \n\tread1 = rtc_read_lpsrt(data);\n\tdo {\n\t\tread2 = read1;\n\t\tread1 = rtc_read_lpsrt(data);\n\t\tdiff = read1 - read2;\n\t} while (((diff < 0) || (diff > MAX_RTC_READ_DIFF_CYCLES)) && --timeout);\n\tif (!timeout)\n\t\tdev_err(&data->rtc->dev, \"Timeout trying to get valid LPSRT Counter read\\n\");\n\n\t \n\treturn (u32) (read1 >> CNTR_TO_SECS_SH);\n}\n\n \nstatic int rtc_read_lp_counter_lsb(struct snvs_rtc_data *data, u32 *lsb)\n{\n\tu32 count1, count2;\n\ts32 diff;\n\tunsigned int timeout = 100;\n\n\tregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count1);\n\tdo {\n\t\tcount2 = count1;\n\t\tregmap_read(data->regmap, data->offset + SNVS_LPSRTCLR, &count1);\n\t\tdiff = count1 - count2;\n\t} while (((diff < 0) || (diff > MAX_RTC_READ_DIFF_CYCLES)) && --timeout);\n\tif (!timeout) {\n\t\tdev_err(&data->rtc->dev, \"Timeout trying to get valid LPSRT Counter read\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*lsb = count1;\n\treturn 0;\n}\n\nstatic int rtc_write_sync_lp(struct snvs_rtc_data *data)\n{\n\tu32 count1, count2;\n\tu32 elapsed;\n\tunsigned int timeout = 1000;\n\tint ret;\n\n\tret = rtc_read_lp_counter_lsb(data, &count1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tret = rtc_read_lp_counter_lsb(data, &count2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\telapsed = count2 - count1;  \n\t} while (elapsed < 3 && --timeout);\n\tif (!timeout) {\n\t\tdev_err(&data->rtc->dev, \"Timeout waiting for LPSRT Counter to change\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic int snvs_rtc_enable(struct snvs_rtc_data *data, bool enable)\n{\n\tint timeout = 1000;\n\tu32 lpcr;\n\n\tregmap_update_bits(data->regmap, data->offset + SNVS_LPCR, SNVS_LPCR_SRTC_ENV,\n\t\t\t   enable ? SNVS_LPCR_SRTC_ENV : 0);\n\n\twhile (--timeout) {\n\t\tregmap_read(data->regmap, data->offset + SNVS_LPCR, &lpcr);\n\n\t\tif (enable) {\n\t\t\tif (lpcr & SNVS_LPCR_SRTC_ENV)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(lpcr & SNVS_LPCR_SRTC_ENV))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int snvs_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tunsigned long time;\n\tint ret;\n\n\tret = clk_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\ttime = rtc_read_lp_counter(data);\n\trtc_time64_to_tm(time, tm);\n\n\tclk_disable(data->clk);\n\n\treturn 0;\n}\n\nstatic int snvs_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tunsigned long time = rtc_tm_to_time64(tm);\n\tint ret;\n\n\tret = clk_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = snvs_rtc_enable(data, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(data->regmap, data->offset + SNVS_LPSRTCLR, time << CNTR_TO_SECS_SH);\n\tregmap_write(data->regmap, data->offset + SNVS_LPSRTCMR, time >> (32 - CNTR_TO_SECS_SH));\n\n\t \n\tret = snvs_rtc_enable(data, true);\n\n\tclk_disable(data->clk);\n\n\treturn ret;\n}\n\nstatic int snvs_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tu32 lptar, lpsr;\n\tint ret;\n\n\tret = clk_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(data->regmap, data->offset + SNVS_LPTAR, &lptar);\n\trtc_time64_to_tm(lptar, &alrm->time);\n\n\tregmap_read(data->regmap, data->offset + SNVS_LPSR, &lpsr);\n\talrm->pending = (lpsr & SNVS_LPSR_LPTA) ? 1 : 0;\n\n\tclk_disable(data->clk);\n\n\treturn 0;\n}\n\nstatic int snvs_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(data->regmap, data->offset + SNVS_LPCR,\n\t\t\t   (SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN),\n\t\t\t   enable ? (SNVS_LPCR_LPTA_EN | SNVS_LPCR_LPWUI_EN) : 0);\n\n\tret = rtc_write_sync_lp(data);\n\n\tclk_disable(data->clk);\n\n\treturn ret;\n}\n\nstatic int snvs_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tunsigned long time = rtc_tm_to_time64(&alrm->time);\n\tint ret;\n\n\tret = clk_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(data->regmap, data->offset + SNVS_LPCR, SNVS_LPCR_LPTA_EN, 0);\n\tret = rtc_write_sync_lp(data);\n\tif (ret)\n\t\treturn ret;\n\tregmap_write(data->regmap, data->offset + SNVS_LPTAR, time);\n\n\t \n\tregmap_write(data->regmap, data->offset + SNVS_LPSR, SNVS_LPSR_LPTA);\n\n\tclk_disable(data->clk);\n\n\treturn snvs_rtc_alarm_irq_enable(dev, alrm->enabled);\n}\n\nstatic const struct rtc_class_ops snvs_rtc_ops = {\n\t.read_time = snvs_rtc_read_time,\n\t.set_time = snvs_rtc_set_time,\n\t.read_alarm = snvs_rtc_read_alarm,\n\t.set_alarm = snvs_rtc_set_alarm,\n\t.alarm_irq_enable = snvs_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\tu32 lpsr;\n\tu32 events = 0;\n\n\tclk_enable(data->clk);\n\n\tregmap_read(data->regmap, data->offset + SNVS_LPSR, &lpsr);\n\n\tif (lpsr & SNVS_LPSR_LPTA) {\n\t\tevents |= (RTC_AF | RTC_IRQF);\n\n\t\t \n\t\tsnvs_rtc_alarm_irq_enable(dev, 0);\n\n\t\trtc_update_irq(data->rtc, 1, events);\n\t}\n\n\t \n\tregmap_write(data->regmap, data->offset + SNVS_LPSR, lpsr);\n\n\tclk_disable(data->clk);\n\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic const struct regmap_config snvs_rtc_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic void snvs_rtc_action(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int snvs_rtc_probe(struct platform_device *pdev)\n{\n\tstruct snvs_rtc_data *data;\n\tint ret;\n\tvoid __iomem *mmio;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(data->rtc))\n\t\treturn PTR_ERR(data->rtc);\n\n\tdata->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, \"regmap\");\n\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_warn(&pdev->dev, \"snvs rtc: you use old dts file, please update it\\n\");\n\n\t\tmmio = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(mmio))\n\t\t\treturn PTR_ERR(mmio);\n\n\t\tdata->regmap = devm_regmap_init_mmio(&pdev->dev, mmio, &snvs_rtc_config);\n\t} else {\n\t\tdata->offset = SNVS_LPREGISTER_OFFSET;\n\t\tof_property_read_u32(pdev->dev.of_node, \"offset\", &data->offset);\n\t}\n\n\tif (IS_ERR(data->regmap)) {\n\t\tdev_err(&pdev->dev, \"Can't find snvs syscon\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->irq = platform_get_irq(pdev, 0);\n\tif (data->irq < 0)\n\t\treturn data->irq;\n\n\tdata->clk = devm_clk_get(&pdev->dev, \"snvs-rtc\");\n\tif (IS_ERR(data->clk)) {\n\t\tdata->clk = NULL;\n\t} else {\n\t\tret = clk_prepare_enable(data->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Could not prepare or enable the snvs clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, snvs_rtc_action, data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tregmap_write(data->regmap, data->offset + SNVS_LPPGDR, SNVS_LPPGDR_INIT);\n\n\t \n\tregmap_write(data->regmap, data->offset + SNVS_LPSR, 0xffffffff);\n\n\t \n\tret = snvs_rtc_enable(data, true);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable rtc %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tret = dev_pm_set_wake_irq(&pdev->dev, data->irq);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to enable irq wake\\n\");\n\n\tret = devm_request_irq(&pdev->dev, data->irq, snvs_rtc_irq_handler,\n\t\t\t       IRQF_SHARED, \"rtc alarm\", &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request irq %d: %d\\n\",\n\t\t\tdata->irq, ret);\n\t\treturn ret;\n\t}\n\n\tdata->rtc->ops = &snvs_rtc_ops;\n\tdata->rtc->range_max = U32_MAX;\n\n\treturn devm_rtc_register_device(data->rtc);\n}\n\nstatic int __maybe_unused snvs_rtc_suspend_noirq(struct device *dev)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\n\tclk_disable(data->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused snvs_rtc_resume_noirq(struct device *dev)\n{\n\tstruct snvs_rtc_data *data = dev_get_drvdata(dev);\n\n\tif (data->clk)\n\t\treturn clk_enable(data->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops snvs_rtc_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(snvs_rtc_suspend_noirq, snvs_rtc_resume_noirq)\n};\n\nstatic const struct of_device_id snvs_dt_ids[] = {\n\t{ .compatible = \"fsl,sec-v4.0-mon-rtc-lp\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, snvs_dt_ids);\n\nstatic struct platform_driver snvs_rtc_driver = {\n\t.driver = {\n\t\t.name\t= \"snvs_rtc\",\n\t\t.pm\t= &snvs_rtc_pm_ops,\n\t\t.of_match_table = snvs_dt_ids,\n\t},\n\t.probe\t\t= snvs_rtc_probe,\n};\nmodule_platform_driver(snvs_rtc_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Freescale SNVS RTC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}