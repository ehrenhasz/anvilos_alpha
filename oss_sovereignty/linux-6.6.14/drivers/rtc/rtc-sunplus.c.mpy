{
  "module_name": "rtc-sunplus.c",
  "hash_id": "2530fe893ad61b5fbf48df5c264d42ec10307d0501a9c8e6ee697fce35d30cbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sunplus.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/rtc.h>\n\n#define RTC_REG_NAME\t\t\t\"rtc\"\n\n#define RTC_CTRL\t\t\t0x40\n#define TIMER_FREEZE_MASK_BIT\t\tBIT(5 + 16)\n#define TIMER_FREEZE\t\t\tBIT(5)\n#define DIS_SYS_RST_RTC_MASK_BIT\tBIT(4 + 16)\n#define DIS_SYS_RST_RTC\t\t\tBIT(4)\n#define RTC32K_MODE_RESET_MASK_BIT\tBIT(3 + 16)\n#define RTC32K_MODE_RESET\t\tBIT(3)\n#define ALARM_EN_OVERDUE_MASK_BIT\tBIT(2 + 16)\n#define ALARM_EN_OVERDUE\t\tBIT(2)\n#define ALARM_EN_PMC_MASK_BIT\t\tBIT(1 + 16)\n#define ALARM_EN_PMC\t\t\tBIT(1)\n#define ALARM_EN_MASK_BIT\t\tBIT(0 + 16)\n#define ALARM_EN\t\t\tBIT(0)\n#define RTC_TIMER_OUT\t\t\t0x44\n#define RTC_DIVIDER\t\t\t0x48\n#define RTC_TIMER_SET\t\t\t0x4c\n#define RTC_ALARM_SET\t\t\t0x50\n#define RTC_USER_DATA\t\t\t0x54\n#define RTC_RESET_RECORD\t\t0x58\n#define RTC_BATT_CHARGE_CTRL\t\t0x5c\n#define BAT_CHARGE_RSEL_MASK_BIT\tGENMASK(3 + 16, 2 + 16)\n#define BAT_CHARGE_RSEL_MASK\t\tGENMASK(3, 2)\n#define BAT_CHARGE_RSEL_2K_OHM\t\tFIELD_PREP(BAT_CHARGE_RSEL_MASK, 0)\n#define BAT_CHARGE_RSEL_250_OHM\t\tFIELD_PREP(BAT_CHARGE_RSEL_MASK, 1)\n#define BAT_CHARGE_RSEL_50_OHM\t\tFIELD_PREP(BAT_CHARGE_RSEL_MASK, 2)\n#define BAT_CHARGE_RSEL_0_OHM\t\tFIELD_PREP(BAT_CHARGE_RSEL_MASK, 3)\n#define BAT_CHARGE_DSEL_MASK_BIT\tBIT(1 + 16)\n#define BAT_CHARGE_DSEL_MASK\t\tGENMASK(1, 1)\n#define BAT_CHARGE_DSEL_ON\t\tFIELD_PREP(BAT_CHARGE_DSEL_MASK, 0)\n#define BAT_CHARGE_DSEL_OFF\t\tFIELD_PREP(BAT_CHARGE_DSEL_MASK, 1)\n#define BAT_CHARGE_EN_MASK_BIT\t\tBIT(0 + 16)\n#define BAT_CHARGE_EN\t\t\tBIT(0)\n#define RTC_TRIM_CTRL\t\t\t0x60\n\nstruct sunplus_rtc {\n\tstruct rtc_device *rtc;\n\tstruct resource *res;\n\tstruct clk *rtcclk;\n\tstruct reset_control *rstc;\n\tvoid __iomem *reg_base;\n\tint irq;\n};\n\nstatic void sp_get_seconds(struct device *dev, unsigned long *secs)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\n\t*secs = (unsigned long)readl(sp_rtc->reg_base + RTC_TIMER_OUT);\n}\n\nstatic void sp_set_seconds(struct device *dev, unsigned long secs)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\n\twritel((u32)secs, sp_rtc->reg_base + RTC_TIMER_SET);\n}\n\nstatic int sp_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long secs;\n\n\tsp_get_seconds(dev, &secs);\n\trtc_time64_to_tm(secs, tm);\n\n\treturn 0;\n}\n\nstatic int sp_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long secs;\n\n\tsecs = rtc_tm_to_time64(tm);\n\tdev_dbg(dev, \"%s, secs = %lu\\n\", __func__, secs);\n\tsp_set_seconds(dev, secs);\n\n\treturn 0;\n}\n\nstatic int sp_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\tunsigned long alarm_time;\n\n\talarm_time = rtc_tm_to_time64(&alrm->time);\n\tdev_dbg(dev, \"%s, alarm_time: %u\\n\", __func__, (u32)(alarm_time));\n\twritel((u32)alarm_time, sp_rtc->reg_base + RTC_ALARM_SET);\n\n\treturn 0;\n}\n\nstatic int sp_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\tunsigned int alarm_time;\n\n\talarm_time = readl(sp_rtc->reg_base + RTC_ALARM_SET);\n\tdev_dbg(dev, \"%s, alarm_time: %u\\n\", __func__, alarm_time);\n\n\tif (alarm_time == 0)\n\t\talrm->enabled = 0;\n\telse\n\t\talrm->enabled = 1;\n\n\trtc_time64_to_tm((unsigned long)(alarm_time), &alrm->time);\n\n\treturn 0;\n}\n\nstatic int sp_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\twritel((TIMER_FREEZE_MASK_BIT | DIS_SYS_RST_RTC_MASK_BIT |\n\t\t\tRTC32K_MODE_RESET_MASK_BIT | ALARM_EN_OVERDUE_MASK_BIT |\n\t\t\tALARM_EN_PMC_MASK_BIT | ALARM_EN_MASK_BIT) |\n\t\t\t(DIS_SYS_RST_RTC | ALARM_EN_OVERDUE | ALARM_EN_PMC | ALARM_EN),\n\t\t\tsp_rtc->reg_base + RTC_CTRL);\n\telse\n\t\twritel((ALARM_EN_OVERDUE_MASK_BIT | ALARM_EN_PMC_MASK_BIT | ALARM_EN_MASK_BIT) |\n\t\t\t0x0, sp_rtc->reg_base + RTC_CTRL);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sp_rtc_ops = {\n\t.read_time =\t\tsp_rtc_read_time,\n\t.set_time =\t\tsp_rtc_set_time,\n\t.set_alarm =\t\tsp_rtc_set_alarm,\n\t.read_alarm =\t\tsp_rtc_read_alarm,\n\t.alarm_irq_enable =\tsp_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t sp_rtc_irq_handler(int irq, void *dev_id)\n{\n\tstruct platform_device *plat_dev = dev_id;\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(&plat_dev->dev);\n\n\trtc_update_irq(sp_rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\tdev_dbg(&plat_dev->dev, \"[RTC] ALARM INT\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void sp_rtc_set_trickle_charger(struct device dev)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(&dev);\n\tu32 ohms, rsel;\n\tu32 chargeable;\n\n\tif (of_property_read_u32(dev.of_node, \"trickle-resistor-ohms\", &ohms) ||\n\t    of_property_read_u32(dev.of_node, \"aux-voltage-chargeable\", &chargeable)) {\n\t\tdev_warn(&dev, \"battery charger disabled\\n\");\n\t\treturn;\n\t}\n\n\tswitch (ohms) {\n\tcase 2000:\n\t\trsel = BAT_CHARGE_RSEL_2K_OHM;\n\t\tbreak;\n\tcase 250:\n\t\trsel = BAT_CHARGE_RSEL_250_OHM;\n\t\tbreak;\n\tcase 50:\n\t\trsel = BAT_CHARGE_RSEL_50_OHM;\n\t\tbreak;\n\tcase 0:\n\t\trsel = BAT_CHARGE_RSEL_0_OHM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev, \"invalid charger resistor value (%d)\\n\", ohms);\n\t\treturn;\n\t}\n\n\twritel(BAT_CHARGE_RSEL_MASK_BIT | rsel, sp_rtc->reg_base + RTC_BATT_CHARGE_CTRL);\n\n\tswitch (chargeable) {\n\tcase 0:\n\t\twritel(BAT_CHARGE_DSEL_MASK_BIT | BAT_CHARGE_DSEL_OFF,\n\t\t       sp_rtc->reg_base + RTC_BATT_CHARGE_CTRL);\n\t\tbreak;\n\tcase 1:\n\t\twritel(BAT_CHARGE_DSEL_MASK_BIT | BAT_CHARGE_DSEL_ON,\n\t\t       sp_rtc->reg_base + RTC_BATT_CHARGE_CTRL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev, \"invalid aux-voltage-chargeable value (%d)\\n\", chargeable);\n\t\treturn;\n\t}\n\n\twritel(BAT_CHARGE_EN_MASK_BIT | BAT_CHARGE_EN, sp_rtc->reg_base + RTC_BATT_CHARGE_CTRL);\n}\n\nstatic int sp_rtc_probe(struct platform_device *plat_dev)\n{\n\tstruct sunplus_rtc *sp_rtc;\n\tint ret;\n\n\tsp_rtc = devm_kzalloc(&plat_dev->dev, sizeof(*sp_rtc), GFP_KERNEL);\n\tif (!sp_rtc)\n\t\treturn -ENOMEM;\n\n\tsp_rtc->reg_base = devm_platform_ioremap_resource_byname(plat_dev, RTC_REG_NAME);\n\tif (IS_ERR(sp_rtc->reg_base))\n\t\treturn dev_err_probe(&plat_dev->dev, PTR_ERR(sp_rtc->reg_base),\n\t\t\t\t\t    \"%s devm_ioremap_resource fail\\n\", RTC_REG_NAME);\n\tdev_dbg(&plat_dev->dev, \"res = %pR, reg_base = %p\\n\",\n\t\tsp_rtc->res, sp_rtc->reg_base);\n\n\tsp_rtc->irq = platform_get_irq(plat_dev, 0);\n\tif (sp_rtc->irq < 0)\n\t\treturn sp_rtc->irq;\n\n\tret = devm_request_irq(&plat_dev->dev, sp_rtc->irq, sp_rtc_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING, \"rtc irq\", plat_dev);\n\tif (ret)\n\t\treturn dev_err_probe(&plat_dev->dev, ret, \"devm_request_irq failed:\\n\");\n\n\tsp_rtc->rtcclk = devm_clk_get(&plat_dev->dev, NULL);\n\tif (IS_ERR(sp_rtc->rtcclk))\n\t\treturn dev_err_probe(&plat_dev->dev, PTR_ERR(sp_rtc->rtcclk),\n\t\t\t\t\t    \"devm_clk_get fail\\n\");\n\n\tsp_rtc->rstc = devm_reset_control_get_exclusive(&plat_dev->dev, NULL);\n\tif (IS_ERR(sp_rtc->rstc))\n\t\treturn dev_err_probe(&plat_dev->dev, PTR_ERR(sp_rtc->rstc),\n\t\t\t\t\t    \"failed to retrieve reset controller\\n\");\n\n\tret = clk_prepare_enable(sp_rtc->rtcclk);\n\tif (ret)\n\t\tgoto free_clk;\n\n\tret = reset_control_deassert(sp_rtc->rstc);\n\tif (ret)\n\t\tgoto free_reset_assert;\n\n\tdevice_init_wakeup(&plat_dev->dev, 1);\n\tdev_set_drvdata(&plat_dev->dev, sp_rtc);\n\n\tsp_rtc->rtc = devm_rtc_allocate_device(&plat_dev->dev);\n\tif (IS_ERR(sp_rtc->rtc)) {\n\t\tret = PTR_ERR(sp_rtc->rtc);\n\t\tgoto free_reset_assert;\n\t}\n\n\tsp_rtc->rtc->range_max = U32_MAX;\n\tsp_rtc->rtc->range_min = 0;\n\tsp_rtc->rtc->ops = &sp_rtc_ops;\n\n\tret = devm_rtc_register_device(sp_rtc->rtc);\n\tif (ret)\n\t\tgoto free_reset_assert;\n\n\t \n\tif (plat_dev->dev.of_node)\n\t\tsp_rtc_set_trickle_charger(plat_dev->dev);\n\n\t \n\twritel(DIS_SYS_RST_RTC_MASK_BIT | DIS_SYS_RST_RTC, sp_rtc->reg_base + RTC_CTRL);\n\n\treturn 0;\n\nfree_reset_assert:\n\treset_control_assert(sp_rtc->rstc);\nfree_clk:\n\tclk_disable_unprepare(sp_rtc->rtcclk);\n\n\treturn ret;\n}\n\nstatic void sp_rtc_remove(struct platform_device *plat_dev)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(&plat_dev->dev);\n\n\tdevice_init_wakeup(&plat_dev->dev, 0);\n\treset_control_assert(sp_rtc->rstc);\n\tclk_disable_unprepare(sp_rtc->rtcclk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sp_rtc_suspend(struct device *dev)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(sp_rtc->irq);\n\n\treturn 0;\n}\n\nstatic int sp_rtc_resume(struct device *dev)\n{\n\tstruct sunplus_rtc *sp_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(sp_rtc->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id sp_rtc_of_match[] = {\n\t{ .compatible = \"sunplus,sp7021-rtc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sp_rtc_of_match);\n\nstatic SIMPLE_DEV_PM_OPS(sp_rtc_pm_ops, sp_rtc_suspend, sp_rtc_resume);\n\nstatic struct platform_driver sp_rtc_driver = {\n\t.probe   = sp_rtc_probe,\n\t.remove_new = sp_rtc_remove,\n\t.driver  = {\n\t\t.name\t= \"sp7021-rtc\",\n\t\t.of_match_table = sp_rtc_of_match,\n\t\t.pm\t= &sp_rtc_pm_ops,\n\t},\n};\nmodule_platform_driver(sp_rtc_driver);\n\nMODULE_AUTHOR(\"Vincent Shih <vincent.sunplus@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}