{
  "module_name": "rtc-armada38x.c",
  "hash_id": "c196d92f7f378f4ad466b1ec9ad6afab14b5d94980a4ee5a706f03ad53d03a0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-armada38x.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n#define RTC_STATUS\t    0x0\n#define RTC_STATUS_ALARM1\t    BIT(0)\n#define RTC_STATUS_ALARM2\t    BIT(1)\n#define RTC_IRQ1_CONF\t    0x4\n#define RTC_IRQ2_CONF\t    0x8\n#define RTC_IRQ_AL_EN\t\t    BIT(0)\n#define RTC_IRQ_FREQ_EN\t\t    BIT(1)\n#define RTC_IRQ_FREQ_1HZ\t    BIT(2)\n#define RTC_CCR\t\t    0x18\n#define RTC_CCR_MODE\t\t    BIT(15)\n#define RTC_CONF_TEST\t    0x1C\n#define RTC_NOMINAL_TIMING\t    BIT(13)\n\n#define RTC_TIME\t    0xC\n#define RTC_ALARM1\t    0x10\n#define RTC_ALARM2\t    0x14\n\n \n#define RTC_38X_BRIDGE_TIMING_CTL   0x0\n#define RTC_38X_PERIOD_OFFS\t\t0\n#define RTC_38X_PERIOD_MASK\t\t(0x3FF << RTC_38X_PERIOD_OFFS)\n#define RTC_38X_READ_DELAY_OFFS\t\t26\n#define RTC_38X_READ_DELAY_MASK\t\t(0x1F << RTC_38X_READ_DELAY_OFFS)\n\n \n#define RTC_8K_BRIDGE_TIMING_CTL0    0x0\n#define RTC_8K_WRCLK_PERIOD_OFFS\t0\n#define RTC_8K_WRCLK_PERIOD_MASK\t(0xFFFF << RTC_8K_WRCLK_PERIOD_OFFS)\n#define RTC_8K_WRCLK_SETUP_OFFS\t\t16\n#define RTC_8K_WRCLK_SETUP_MASK\t\t(0xFFFF << RTC_8K_WRCLK_SETUP_OFFS)\n#define RTC_8K_BRIDGE_TIMING_CTL1   0x4\n#define RTC_8K_READ_DELAY_OFFS\t\t0\n#define RTC_8K_READ_DELAY_MASK\t\t(0xFFFF << RTC_8K_READ_DELAY_OFFS)\n\n#define RTC_8K_ISR\t\t    0x10\n#define RTC_8K_IMR\t\t    0x14\n#define RTC_8K_ALARM2\t\t\tBIT(0)\n\n#define SOC_RTC_INTERRUPT\t    0x8\n#define SOC_RTC_ALARM1\t\t\tBIT(0)\n#define SOC_RTC_ALARM2\t\t\tBIT(1)\n#define SOC_RTC_ALARM1_MASK\t\tBIT(2)\n#define SOC_RTC_ALARM2_MASK\t\tBIT(3)\n\n#define SAMPLE_NR 100\n\nstruct value_to_freq {\n\tu32 value;\n\tu8 freq;\n};\n\nstruct armada38x_rtc {\n\tstruct rtc_device   *rtc_dev;\n\tvoid __iomem\t    *regs;\n\tvoid __iomem\t    *regs_soc;\n\tspinlock_t\t    lock;\n\tint\t\t    irq;\n\tbool\t\t    initialized;\n\tstruct value_to_freq *val_to_freq;\n\tconst struct armada38x_rtc_data *data;\n};\n\n#define ALARM1\t0\n#define ALARM2\t1\n\n#define ALARM_REG(base, alarm)\t ((base) + (alarm) * sizeof(u32))\n\nstruct armada38x_rtc_data {\n\t \n\tvoid (*update_mbus_timing)(struct armada38x_rtc *rtc);\n\tu32 (*read_rtc_reg)(struct armada38x_rtc *rtc, u8 rtc_reg);\n\tvoid (*clear_isr)(struct armada38x_rtc *rtc);\n\tvoid (*unmask_interrupt)(struct armada38x_rtc *rtc);\n\tu32 alarm;\n};\n\n \n\nstatic void rtc_delayed_write(u32 val, struct armada38x_rtc *rtc, int offset)\n{\n\twritel(0, rtc->regs + RTC_STATUS);\n\twritel(0, rtc->regs + RTC_STATUS);\n\twritel(val, rtc->regs + offset);\n\tudelay(5);\n}\n\n \nstatic void rtc_update_38x_mbus_timing_params(struct armada38x_rtc *rtc)\n{\n\tu32 reg;\n\n\treg = readl(rtc->regs_soc + RTC_38X_BRIDGE_TIMING_CTL);\n\treg &= ~RTC_38X_PERIOD_MASK;\n\treg |= 0x3FF << RTC_38X_PERIOD_OFFS;  \n\treg &= ~RTC_38X_READ_DELAY_MASK;\n\treg |= 0x1F << RTC_38X_READ_DELAY_OFFS;  \n\twritel(reg, rtc->regs_soc + RTC_38X_BRIDGE_TIMING_CTL);\n}\n\nstatic void rtc_update_8k_mbus_timing_params(struct armada38x_rtc *rtc)\n{\n\tu32 reg;\n\n\treg = readl(rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL0);\n\treg &= ~RTC_8K_WRCLK_PERIOD_MASK;\n\treg |= 0x3FF << RTC_8K_WRCLK_PERIOD_OFFS;\n\treg &= ~RTC_8K_WRCLK_SETUP_MASK;\n\treg |= 0x29 << RTC_8K_WRCLK_SETUP_OFFS;\n\twritel(reg, rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL0);\n\n\treg = readl(rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL1);\n\treg &= ~RTC_8K_READ_DELAY_MASK;\n\treg |= 0x3F << RTC_8K_READ_DELAY_OFFS;\n\twritel(reg, rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL1);\n}\n\nstatic u32 read_rtc_register(struct armada38x_rtc *rtc, u8 rtc_reg)\n{\n\treturn readl(rtc->regs + rtc_reg);\n}\n\nstatic u32 read_rtc_register_38x_wa(struct armada38x_rtc *rtc, u8 rtc_reg)\n{\n\tint i, index_max = 0, max = 0;\n\n\tfor (i = 0; i < SAMPLE_NR; i++) {\n\t\trtc->val_to_freq[i].value = readl(rtc->regs + rtc_reg);\n\t\trtc->val_to_freq[i].freq = 0;\n\t}\n\n\tfor (i = 0; i < SAMPLE_NR; i++) {\n\t\tint j = 0;\n\t\tu32 value = rtc->val_to_freq[i].value;\n\n\t\twhile (rtc->val_to_freq[j].freq) {\n\t\t\tif (rtc->val_to_freq[j].value == value) {\n\t\t\t\trtc->val_to_freq[j].freq++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!rtc->val_to_freq[j].freq) {\n\t\t\trtc->val_to_freq[j].value = value;\n\t\t\trtc->val_to_freq[j].freq = 1;\n\t\t}\n\n\t\tif (rtc->val_to_freq[j].freq > max) {\n\t\t\tindex_max = j;\n\t\t\tmax = rtc->val_to_freq[j].freq;\n\t\t}\n\n\t\t \n\t\tif (max > SAMPLE_NR / 2)\n\t\t\tbreak;\n\t}\n\n\treturn rtc->val_to_freq[index_max].value;\n}\n\nstatic void armada38x_clear_isr(struct armada38x_rtc *rtc)\n{\n\tu32 val = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\n\n\twritel(val & ~SOC_RTC_ALARM1, rtc->regs_soc + SOC_RTC_INTERRUPT);\n}\n\nstatic void armada38x_unmask_interrupt(struct armada38x_rtc *rtc)\n{\n\tu32 val = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\n\n\twritel(val | SOC_RTC_ALARM1_MASK, rtc->regs_soc + SOC_RTC_INTERRUPT);\n}\n\nstatic void armada8k_clear_isr(struct armada38x_rtc *rtc)\n{\n\twritel(RTC_8K_ALARM2, rtc->regs_soc + RTC_8K_ISR);\n}\n\nstatic void armada8k_unmask_interrupt(struct armada38x_rtc *rtc)\n{\n\twritel(RTC_8K_ALARM2, rtc->regs_soc + RTC_8K_IMR);\n}\n\nstatic int armada38x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long time, flags;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\ttime = rtc->data->read_rtc_reg(rtc, RTC_TIME);\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\nstatic void armada38x_rtc_reset(struct armada38x_rtc *rtc)\n{\n\tu32 reg;\n\n\treg = rtc->data->read_rtc_reg(rtc, RTC_CONF_TEST);\n\t \n\tif (reg & 0xff) {\n\t\trtc_delayed_write(0, rtc, RTC_CONF_TEST);\n\t\tmsleep(500);  \n\t\trtc_delayed_write(0, rtc, RTC_TIME);\n\t\trtc_delayed_write(SOC_RTC_ALARM1 | SOC_RTC_ALARM2, rtc,\n\t\t\t\t  RTC_STATUS);\n\t\trtc_delayed_write(RTC_NOMINAL_TIMING, rtc, RTC_CCR);\n\t}\n\trtc->initialized = true;\n}\n\nstatic int armada38x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long time, flags;\n\n\ttime = rtc_tm_to_time64(tm);\n\n\tif (!rtc->initialized)\n\t\tarmada38x_rtc_reset(rtc);\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\trtc_delayed_write(time, rtc, RTC_TIME);\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int armada38x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long time, flags;\n\tu32 reg = ALARM_REG(RTC_ALARM1, rtc->data->alarm);\n\tu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\n\tu32 val;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\ttime = rtc->data->read_rtc_reg(rtc, reg);\n\tval = rtc->data->read_rtc_reg(rtc, reg_irq) & RTC_IRQ_AL_EN;\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\talrm->enabled = val ? 1 : 0;\n\trtc_time64_to_tm(time,  &alrm->time);\n\n\treturn 0;\n}\n\nstatic int armada38x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tu32 reg = ALARM_REG(RTC_ALARM1, rtc->data->alarm);\n\tu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\n\tunsigned long time, flags;\n\n\ttime = rtc_tm_to_time64(&alrm->time);\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\trtc_delayed_write(time, rtc, reg);\n\n\tif (alrm->enabled) {\n\t\trtc_delayed_write(RTC_IRQ_AL_EN, rtc, reg_irq);\n\t\trtc->data->unmask_interrupt(rtc);\n\t}\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int armada38x_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enabled)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\tif (enabled)\n\t\trtc_delayed_write(RTC_IRQ_AL_EN, rtc, reg_irq);\n\telse\n\t\trtc_delayed_write(0, rtc, reg_irq);\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic irqreturn_t armada38x_rtc_alarm_irq(int irq, void *data)\n{\n\tstruct armada38x_rtc *rtc = data;\n\tu32 val;\n\tint event = RTC_IRQF | RTC_AF;\n\tu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\n\n\tdev_dbg(&rtc->rtc_dev->dev, \"%s:irq(%d)\\n\", __func__, irq);\n\n\tspin_lock(&rtc->lock);\n\n\trtc->data->clear_isr(rtc);\n\tval = rtc->data->read_rtc_reg(rtc, reg_irq);\n\t \n\trtc_delayed_write(0, rtc, reg_irq);\n\t \n\trtc_delayed_write(1 << rtc->data->alarm, rtc, RTC_STATUS);\n\n\tspin_unlock(&rtc->lock);\n\n\tif (val & RTC_IRQ_FREQ_EN) {\n\t\tif (val & RTC_IRQ_FREQ_1HZ)\n\t\t\tevent |= RTC_UF;\n\t\telse\n\t\t\tevent |= RTC_PF;\n\t}\n\n\trtc_update_irq(rtc->rtc_dev, 1, event);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic long armada38x_ppb_convert(long ppb)\n{\n\tlong div = ppb + 1000000000L;\n\n\treturn div_s64(1000000000000000000LL + div / 2, div) - 1000000000L;\n}\n\nstatic int armada38x_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long ccr, flags;\n\tlong ppb_cor;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\tccr = rtc->data->read_rtc_reg(rtc, RTC_CCR);\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\tppb_cor = (ccr & RTC_CCR_MODE ? 3815 : 954) * (s8)ccr;\n\t \n\t*offset = armada38x_ppb_convert(ppb_cor);\n\n\treturn 0;\n}\n\nstatic int armada38x_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long ccr = 0;\n\tlong ppb_cor, off;\n\n\t \n\toffset = clamp(offset, -484270L, 488558L);\n\n\tppb_cor = armada38x_ppb_convert(offset);\n\n\t \n\toff = DIV_ROUND_CLOSEST(ppb_cor, 954);\n\tif (off > 127 || off < -128) {\n\t\tccr = RTC_CCR_MODE;\n\t\toff = DIV_ROUND_CLOSEST(ppb_cor, 3815);\n\t}\n\n\t \n\tccr |= (off & 0x3fff) ^ 0x2000;\n\trtc_delayed_write(ccr, rtc, RTC_CCR);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops armada38x_rtc_ops = {\n\t.read_time = armada38x_rtc_read_time,\n\t.set_time = armada38x_rtc_set_time,\n\t.read_alarm = armada38x_rtc_read_alarm,\n\t.set_alarm = armada38x_rtc_set_alarm,\n\t.alarm_irq_enable = armada38x_rtc_alarm_irq_enable,\n\t.read_offset = armada38x_rtc_read_offset,\n\t.set_offset = armada38x_rtc_set_offset,\n};\n\nstatic const struct armada38x_rtc_data armada38x_data = {\n\t.update_mbus_timing = rtc_update_38x_mbus_timing_params,\n\t.read_rtc_reg = read_rtc_register_38x_wa,\n\t.clear_isr = armada38x_clear_isr,\n\t.unmask_interrupt = armada38x_unmask_interrupt,\n\t.alarm = ALARM1,\n};\n\nstatic const struct armada38x_rtc_data armada8k_data = {\n\t.update_mbus_timing = rtc_update_8k_mbus_timing_params,\n\t.read_rtc_reg = read_rtc_register,\n\t.clear_isr = armada8k_clear_isr,\n\t.unmask_interrupt = armada8k_unmask_interrupt,\n\t.alarm = ALARM2,\n};\n\nstatic const struct of_device_id armada38x_rtc_of_match_table[] = {\n\t{\n\t\t.compatible = \"marvell,armada-380-rtc\",\n\t\t.data = &armada38x_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-8k-rtc\",\n\t\t.data = &armada8k_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, armada38x_rtc_of_match_table);\n\nstatic __init int armada38x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct armada38x_rtc *rtc;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(struct armada38x_rtc),\n\t\t\t    GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->data = of_device_get_match_data(&pdev->dev);\n\n\trtc->val_to_freq = devm_kcalloc(&pdev->dev, SAMPLE_NR,\n\t\t\t\tsizeof(struct value_to_freq), GFP_KERNEL);\n\tif (!rtc->val_to_freq)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&rtc->lock);\n\n\trtc->regs = devm_platform_ioremap_resource_byname(pdev, \"rtc\");\n\tif (IS_ERR(rtc->regs))\n\t\treturn PTR_ERR(rtc->regs);\n\trtc->regs_soc = devm_platform_ioremap_resource_byname(pdev, \"rtc-soc\");\n\tif (IS_ERR(rtc->regs_soc))\n\t\treturn PTR_ERR(rtc->regs_soc);\n\n\trtc->irq = platform_get_irq(pdev, 0);\n\tif (rtc->irq < 0)\n\t\treturn rtc->irq;\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tif (devm_request_irq(&pdev->dev, rtc->irq, armada38x_rtc_alarm_irq,\n\t\t\t\t0, pdev->name, rtc) < 0) {\n\t\tdev_warn(&pdev->dev, \"Interrupt not available.\\n\");\n\t\trtc->irq = -1;\n\t}\n\tplatform_set_drvdata(pdev, rtc);\n\n\tif (rtc->irq != -1)\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, rtc->rtc_dev->features);\n\n\t \n\trtc->data->update_mbus_timing(rtc);\n\n\trtc->rtc_dev->ops = &armada38x_rtc_ops;\n\trtc->rtc_dev->range_max = U32_MAX;\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int armada38x_rtc_suspend(struct device *dev)\n{\n\tif (device_may_wakeup(dev)) {\n\t\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\n\t\treturn enable_irq_wake(rtc->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int armada38x_rtc_resume(struct device *dev)\n{\n\tif (device_may_wakeup(dev)) {\n\t\tstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\n\n\t\t \n\t\trtc->data->update_mbus_timing(rtc);\n\n\t\treturn disable_irq_wake(rtc->irq);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(armada38x_rtc_pm_ops,\n\t\t\t armada38x_rtc_suspend, armada38x_rtc_resume);\n\nstatic struct platform_driver armada38x_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"armada38x-rtc\",\n\t\t.pm\t= &armada38x_rtc_pm_ops,\n\t\t.of_match_table = armada38x_rtc_of_match_table,\n\t},\n};\n\nmodule_platform_driver_probe(armada38x_rtc_driver, armada38x_rtc_probe);\n\nMODULE_DESCRIPTION(\"Marvell Armada 38x RTC driver\");\nMODULE_AUTHOR(\"Gregory CLEMENT <gregory.clement@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}