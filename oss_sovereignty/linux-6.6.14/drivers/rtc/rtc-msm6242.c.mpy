{
  "module_name": "rtc-msm6242.c",
  "hash_id": "2a33a6e53e7440102217664ca4ee5ea77482cd0551c417fb7955cdf3b3237d86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-msm6242.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n\nenum {\n\tMSM6242_SECOND1\t\t= 0x0,\t \n\tMSM6242_SECOND10\t= 0x1,\t \n\tMSM6242_MINUTE1\t\t= 0x2,\t \n\tMSM6242_MINUTE10\t= 0x3,\t \n\tMSM6242_HOUR1\t\t= 0x4,\t \n\tMSM6242_HOUR10\t\t= 0x5,\t \n\tMSM6242_DAY1\t\t= 0x6,\t \n\tMSM6242_DAY10\t\t= 0x7,\t \n\tMSM6242_MONTH1\t\t= 0x8,\t \n\tMSM6242_MONTH10\t\t= 0x9,\t \n\tMSM6242_YEAR1\t\t= 0xa,\t \n\tMSM6242_YEAR10\t\t= 0xb,\t \n\tMSM6242_WEEK\t\t= 0xc,\t \n\tMSM6242_CD\t\t= 0xd,\t \n\tMSM6242_CE\t\t= 0xe,\t \n\tMSM6242_CF\t\t= 0xf,\t \n};\n\n#define MSM6242_HOUR10_AM\t(0 << 2)\n#define MSM6242_HOUR10_PM\t(1 << 2)\n#define MSM6242_HOUR10_HR_MASK\t(3 << 0)\n\n#define MSM6242_WEEK_SUNDAY\t0\n#define MSM6242_WEEK_MONDAY\t1\n#define MSM6242_WEEK_TUESDAY\t2\n#define MSM6242_WEEK_WEDNESDAY\t3\n#define MSM6242_WEEK_THURSDAY\t4\n#define MSM6242_WEEK_FRIDAY\t5\n#define MSM6242_WEEK_SATURDAY\t6\n\n#define MSM6242_CD_30_S_ADJ\t(1 << 3)\t \n#define MSM6242_CD_IRQ_FLAG\t(1 << 2)\n#define MSM6242_CD_BUSY\t\t(1 << 1)\n#define MSM6242_CD_HOLD\t\t(1 << 0)\n\n#define MSM6242_CE_T_MASK\t(3 << 2)\n#define MSM6242_CE_T_64HZ\t(0 << 2)\t \n#define MSM6242_CE_T_1HZ\t(1 << 2)\t \n#define MSM6242_CE_T_1MINUTE\t(2 << 2)\t \n#define MSM6242_CE_T_1HOUR\t(3 << 2)\t \n\n#define MSM6242_CE_ITRPT_STND\t(1 << 1)\n#define MSM6242_CE_MASK\t\t(1 << 0)\t \n\n#define MSM6242_CF_TEST\t\t(1 << 3)\n#define MSM6242_CF_12H\t\t(0 << 2)\n#define MSM6242_CF_24H\t\t(1 << 2)\n#define MSM6242_CF_STOP\t\t(1 << 1)\n#define MSM6242_CF_REST\t\t(1 << 0)\t \n\n\nstruct msm6242_priv {\n\tu32 __iomem *regs;\n\tstruct rtc_device *rtc;\n};\n\nstatic inline unsigned int msm6242_read(struct msm6242_priv *priv,\n\t\t\t\t       unsigned int reg)\n{\n\treturn __raw_readl(&priv->regs[reg]) & 0xf;\n}\n\nstatic inline void msm6242_write(struct msm6242_priv *priv, unsigned int val,\n\t\t\t\tunsigned int reg)\n{\n\t__raw_writel(val, &priv->regs[reg]);\n}\n\nstatic void msm6242_lock(struct msm6242_priv *priv)\n{\n\tint cnt = 5;\n\n\tmsm6242_write(priv, MSM6242_CD_HOLD|MSM6242_CD_IRQ_FLAG, MSM6242_CD);\n\n\twhile ((msm6242_read(priv, MSM6242_CD) & MSM6242_CD_BUSY) && cnt) {\n\t\tmsm6242_write(priv, MSM6242_CD_IRQ_FLAG, MSM6242_CD);\n\t\tudelay(70);\n\t\tmsm6242_write(priv, MSM6242_CD_HOLD|MSM6242_CD_IRQ_FLAG, MSM6242_CD);\n\t\tcnt--;\n\t}\n\n\tif (!cnt)\n\t\tpr_warn(\"timed out waiting for RTC (0x%x)\\n\",\n\t\t\tmsm6242_read(priv, MSM6242_CD));\n}\n\nstatic void msm6242_unlock(struct msm6242_priv *priv)\n{\n\tmsm6242_write(priv, MSM6242_CD_IRQ_FLAG, MSM6242_CD);\n}\n\nstatic int msm6242_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct msm6242_priv *priv = dev_get_drvdata(dev);\n\n\tmsm6242_lock(priv);\n\n\ttm->tm_sec  = msm6242_read(priv, MSM6242_SECOND10) * 10 +\n\t\t      msm6242_read(priv, MSM6242_SECOND1);\n\ttm->tm_min  = msm6242_read(priv, MSM6242_MINUTE10) * 10 +\n\t\t      msm6242_read(priv, MSM6242_MINUTE1);\n\ttm->tm_hour = (msm6242_read(priv, MSM6242_HOUR10) &\n\t\t       MSM6242_HOUR10_HR_MASK) * 10 +\n\t\t      msm6242_read(priv, MSM6242_HOUR1);\n\ttm->tm_mday = msm6242_read(priv, MSM6242_DAY10) * 10 +\n\t\t      msm6242_read(priv, MSM6242_DAY1);\n\ttm->tm_wday = msm6242_read(priv, MSM6242_WEEK);\n\ttm->tm_mon  = msm6242_read(priv, MSM6242_MONTH10) * 10 +\n\t\t      msm6242_read(priv, MSM6242_MONTH1) - 1;\n\ttm->tm_year = msm6242_read(priv, MSM6242_YEAR10) * 10 +\n\t\t      msm6242_read(priv, MSM6242_YEAR1);\n\tif (tm->tm_year <= 69)\n\t\ttm->tm_year += 100;\n\n\tif (!(msm6242_read(priv, MSM6242_CF) & MSM6242_CF_24H)) {\n\t\tunsigned int pm = msm6242_read(priv, MSM6242_HOUR10) &\n\t\t\t\t  MSM6242_HOUR10_PM;\n\t\tif (!pm && tm->tm_hour == 12)\n\t\t\ttm->tm_hour = 0;\n\t\telse if (pm && tm->tm_hour != 12)\n\t\t\ttm->tm_hour += 12;\n\t}\n\n\tmsm6242_unlock(priv);\n\n\treturn 0;\n}\n\nstatic int msm6242_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct msm6242_priv *priv = dev_get_drvdata(dev);\n\n\tmsm6242_lock(priv);\n\n\tmsm6242_write(priv, tm->tm_sec / 10, MSM6242_SECOND10);\n\tmsm6242_write(priv, tm->tm_sec % 10, MSM6242_SECOND1);\n\tmsm6242_write(priv, tm->tm_min / 10, MSM6242_MINUTE10);\n\tmsm6242_write(priv, tm->tm_min % 10, MSM6242_MINUTE1);\n\tif (msm6242_read(priv, MSM6242_CF) & MSM6242_CF_24H)\n\t\tmsm6242_write(priv, tm->tm_hour / 10, MSM6242_HOUR10);\n\telse if (tm->tm_hour >= 12)\n\t\tmsm6242_write(priv, MSM6242_HOUR10_PM + (tm->tm_hour - 12) / 10,\n\t\t\t      MSM6242_HOUR10);\n\telse\n\t\tmsm6242_write(priv, tm->tm_hour / 10, MSM6242_HOUR10);\n\tmsm6242_write(priv, tm->tm_hour % 10, MSM6242_HOUR1);\n\tmsm6242_write(priv, tm->tm_mday / 10, MSM6242_DAY10);\n\tmsm6242_write(priv, tm->tm_mday % 10, MSM6242_DAY1);\n\tif (tm->tm_wday != -1)\n\t\tmsm6242_write(priv, tm->tm_wday, MSM6242_WEEK);\n\tmsm6242_write(priv, (tm->tm_mon + 1) / 10, MSM6242_MONTH10);\n\tmsm6242_write(priv, (tm->tm_mon + 1) % 10, MSM6242_MONTH1);\n\tif (tm->tm_year >= 100)\n\t\ttm->tm_year -= 100;\n\tmsm6242_write(priv, tm->tm_year / 10, MSM6242_YEAR10);\n\tmsm6242_write(priv, tm->tm_year % 10, MSM6242_YEAR1);\n\n\tmsm6242_unlock(priv);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops msm6242_rtc_ops = {\n\t.read_time\t= msm6242_read_time,\n\t.set_time\t= msm6242_set_time,\n};\n\nstatic int __init msm6242_rtc_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct msm6242_priv *priv;\n\tstruct rtc_device *rtc;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!priv->regs)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\trtc = devm_rtc_device_register(&pdev->dev, \"rtc-msm6242\",\n\t\t\t\t&msm6242_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tpriv->rtc = rtc;\n\treturn 0;\n}\n\nstatic struct platform_driver msm6242_rtc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rtc-msm6242\",\n\t},\n};\n\nmodule_platform_driver_probe(msm6242_rtc_driver, msm6242_rtc_probe);\n\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert@linux-m68k.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Oki MSM6242 RTC driver\");\nMODULE_ALIAS(\"platform:rtc-msm6242\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}