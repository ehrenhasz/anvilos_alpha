{
  "module_name": "rtc-mpc5121.c",
  "hash_id": "3e47accdf3b8a348ce60a2139a0f35b6376a36bb037481e9707245b5ebabfd10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mpc5121.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\nstruct mpc5121_rtc_regs {\n\tu8 set_time;\t\t \n\tu8 hour_set;\t\t \n\tu8 minute_set;\t\t \n\tu8 second_set;\t\t \n\n\tu8 set_date;\t\t \n\tu8 month_set;\t\t \n\tu8 weekday_set;\t\t \n\tu8 date_set;\t\t \n\n\tu8 write_sw;\t\t \n\tu8 sw_set;\t\t \n\tu16 year_set;\t\t \n\n\tu8 alm_enable;\t\t \n\tu8 alm_hour_set;\t \n\tu8 alm_min_set;\t\t \n\tu8 int_enable;\t\t \n\n\tu8 reserved1;\n\tu8 hour;\t\t \n\tu8 minute;\t\t \n\tu8 second;\t\t \n\n\tu8 month;\t\t \n\tu8 wday_mday;\t\t \n\tu16 year;\t\t \n\n\tu8 int_alm;\t\t \n\tu8 int_sw;\t\t \n\tu8 alm_status;\t\t \n\tu8 sw_minute;\t\t \n\n\tu8 bus_error_1;\t\t \n\tu8 int_day;\t\t \n\tu8 int_min;\t\t \n\tu8 int_sec;\t\t \n\n\t \n\tu32 target_time;\t \n\t \n\tu32 actual_time;\t \n\tu32 keep_alive;\t\t \n};\n\nstruct mpc5121_rtc_data {\n\tunsigned irq;\n\tunsigned irq_periodic;\n\tstruct mpc5121_rtc_regs __iomem *regs;\n\tstruct rtc_device *rtc;\n\tstruct rtc_wkalrm wkalarm;\n};\n\n \nstatic void mpc5121_rtc_update_smh(struct mpc5121_rtc_regs __iomem *regs,\n\t\t\t\t   struct rtc_time *tm)\n{\n\tout_8(&regs->second_set, tm->tm_sec);\n\tout_8(&regs->minute_set, tm->tm_min);\n\tout_8(&regs->hour_set, tm->tm_hour);\n\n\t \n\tout_8(&regs->set_time, 0x1);\n\tout_8(&regs->set_time, 0x3);\n\tout_8(&regs->set_time, 0x1);\n\tout_8(&regs->set_time, 0x0);\n}\n\nstatic int mpc5121_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\tunsigned long now;\n\n\t \n\tnow = in_be32(&regs->actual_time) + in_be32(&regs->target_time);\n\n\trtc_time64_to_tm(now, tm);\n\n\t \n\tmpc5121_rtc_update_smh(regs, tm);\n\n\treturn 0;\n}\n\nstatic int mpc5121_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\tunsigned long now;\n\n\t \n\tnow = rtc_tm_to_time64(tm);\n\tout_be32(&regs->target_time, now - in_be32(&regs->actual_time));\n\n\t \n\tmpc5121_rtc_update_smh(regs, tm);\n\n\treturn 0;\n}\n\nstatic int mpc5200_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\tint tmp;\n\n\ttm->tm_sec = in_8(&regs->second);\n\ttm->tm_min = in_8(&regs->minute);\n\n\t \n\tif (in_8(&regs->hour) & 0x20)\n\t\ttm->tm_hour = (in_8(&regs->hour) >> 1) +\n\t\t\t(in_8(&regs->hour) & 1 ? 12 : 0);\n\telse\n\t\ttm->tm_hour = in_8(&regs->hour);\n\n\ttmp = in_8(&regs->wday_mday);\n\ttm->tm_mday = tmp & 0x1f;\n\ttm->tm_mon = in_8(&regs->month) - 1;\n\ttm->tm_year = in_be16(&regs->year) - 1900;\n\ttm->tm_wday = (tmp >> 5) % 7;\n\ttm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\n\ttm->tm_isdst = 0;\n\n\treturn 0;\n}\n\nstatic int mpc5200_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\tmpc5121_rtc_update_smh(regs, tm);\n\n\t \n\tout_8(&regs->month_set, tm->tm_mon + 1);\n\tout_8(&regs->weekday_set, tm->tm_wday ? tm->tm_wday : 7);\n\tout_8(&regs->date_set, tm->tm_mday);\n\tout_be16(&regs->year_set, tm->tm_year + 1900);\n\n\t \n\tout_8(&regs->set_date, 0x1);\n\tout_8(&regs->set_date, 0x3);\n\tout_8(&regs->set_date, 0x1);\n\tout_8(&regs->set_date, 0x0);\n\n\treturn 0;\n}\n\nstatic int mpc5121_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\t*alarm = rtc->wkalarm;\n\n\talarm->pending = in_8(&regs->alm_status);\n\n\treturn 0;\n}\n\nstatic int mpc5121_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\talarm->time.tm_mday = -1;\n\talarm->time.tm_mon = -1;\n\talarm->time.tm_year = -1;\n\n\tout_8(&regs->alm_min_set, alarm->time.tm_min);\n\tout_8(&regs->alm_hour_set, alarm->time.tm_hour);\n\n\tout_8(&regs->alm_enable, alarm->enabled);\n\n\trtc->wkalarm = *alarm;\n\treturn 0;\n}\n\nstatic irqreturn_t mpc5121_rtc_handler(int irq, void *dev)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata((struct device *)dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\tif (in_8(&regs->int_alm)) {\n\t\t \n\t\tout_8(&regs->int_alm, 1);\n\t\tout_8(&regs->alm_status, 1);\n\n\t\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t mpc5121_rtc_handler_upd(int irq, void *dev)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata((struct device *)dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\tif (in_8(&regs->int_sec) && (in_8(&regs->int_enable) & 0x1)) {\n\t\t \n\t\tout_8(&regs->int_sec, 1);\n\n\t\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_UF);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mpc5121_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\tint val;\n\n\tif (enabled)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\tout_8(&regs->alm_enable, val);\n\trtc->wkalarm.enabled = val;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops mpc5121_rtc_ops = {\n\t.read_time = mpc5121_rtc_read_time,\n\t.set_time = mpc5121_rtc_set_time,\n\t.read_alarm = mpc5121_rtc_read_alarm,\n\t.set_alarm = mpc5121_rtc_set_alarm,\n\t.alarm_irq_enable = mpc5121_rtc_alarm_irq_enable,\n};\n\nstatic const struct rtc_class_ops mpc5200_rtc_ops = {\n\t.read_time = mpc5200_rtc_read_time,\n\t.set_time = mpc5200_rtc_set_time,\n\t.read_alarm = mpc5121_rtc_read_alarm,\n\t.set_alarm = mpc5121_rtc_set_alarm,\n\t.alarm_irq_enable = mpc5121_rtc_alarm_irq_enable,\n};\n\nstatic int mpc5121_rtc_probe(struct platform_device *op)\n{\n\tstruct mpc5121_rtc_data *rtc;\n\tint err = 0;\n\n\trtc = devm_kzalloc(&op->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->regs = devm_platform_ioremap_resource(op, 0);\n\tif (IS_ERR(rtc->regs)) {\n\t\tdev_err(&op->dev, \"%s: couldn't map io space\\n\", __func__);\n\t\treturn PTR_ERR(rtc->regs);\n\t}\n\n\tdevice_init_wakeup(&op->dev, 1);\n\n\tplatform_set_drvdata(op, rtc);\n\n\trtc->irq = irq_of_parse_and_map(op->dev.of_node, 1);\n\terr = devm_request_irq(&op->dev, rtc->irq, mpc5121_rtc_handler, 0,\n\t\t\t       \"mpc5121-rtc\", &op->dev);\n\tif (err) {\n\t\tdev_err(&op->dev, \"%s: could not request irq: %i\\n\",\n\t\t\t\t\t\t\t__func__, rtc->irq);\n\t\tgoto out_dispose;\n\t}\n\n\trtc->irq_periodic = irq_of_parse_and_map(op->dev.of_node, 0);\n\terr = devm_request_irq(&op->dev, rtc->irq_periodic,\n\t\t\t       mpc5121_rtc_handler_upd, 0, \"mpc5121-rtc_upd\",\n\t\t\t       &op->dev);\n\tif (err) {\n\t\tdev_err(&op->dev, \"%s: could not request irq: %i\\n\",\n\t\t\t\t\t\t__func__, rtc->irq_periodic);\n\t\tgoto out_dispose2;\n\t}\n\n\trtc->rtc = devm_rtc_allocate_device(&op->dev);\n\tif (IS_ERR(rtc->rtc)) {\n\t\terr = PTR_ERR(rtc->rtc);\n\t\tgoto out_dispose2;\n\t}\n\n\trtc->rtc->ops = &mpc5200_rtc_ops;\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->rtc->features);\n\trtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_0000;\n\trtc->rtc->range_max = 65733206399ULL;  \n\n\tif (of_device_is_compatible(op->dev.of_node, \"fsl,mpc5121-rtc\")) {\n\t\tu32 ka;\n\t\tka = in_be32(&rtc->regs->keep_alive);\n\t\tif (ka & 0x02) {\n\t\t\tdev_warn(&op->dev,\n\t\t\t\t\"mpc5121-rtc: Battery or oscillator failure!\\n\");\n\t\t\tout_be32(&rtc->regs->keep_alive, ka);\n\t\t}\n\t\trtc->rtc->ops = &mpc5121_rtc_ops;\n\t\t \n\t\trtc->rtc->range_min = 0;\n\t\trtc->rtc->range_max = U32_MAX;\n\t}\n\n\terr = devm_rtc_register_device(rtc->rtc);\n\tif (err)\n\t\tgoto out_dispose2;\n\n\treturn 0;\n\nout_dispose2:\n\tirq_dispose_mapping(rtc->irq_periodic);\nout_dispose:\n\tirq_dispose_mapping(rtc->irq);\n\n\treturn err;\n}\n\nstatic void mpc5121_rtc_remove(struct platform_device *op)\n{\n\tstruct mpc5121_rtc_data *rtc = platform_get_drvdata(op);\n\tstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\n\n\t \n\tout_8(&regs->alm_enable, 0);\n\tout_8(&regs->int_enable, in_8(&regs->int_enable) & ~0x1);\n\n\tirq_dispose_mapping(rtc->irq);\n\tirq_dispose_mapping(rtc->irq_periodic);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mpc5121_rtc_match[] = {\n\t{ .compatible = \"fsl,mpc5121-rtc\", },\n\t{ .compatible = \"fsl,mpc5200-rtc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc5121_rtc_match);\n#endif\n\nstatic struct platform_driver mpc5121_rtc_driver = {\n\t.driver = {\n\t\t.name = \"mpc5121-rtc\",\n\t\t.of_match_table = of_match_ptr(mpc5121_rtc_match),\n\t},\n\t.probe = mpc5121_rtc_probe,\n\t.remove_new = mpc5121_rtc_remove,\n};\n\nmodule_platform_driver(mpc5121_rtc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Rigby <jcrigby@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}