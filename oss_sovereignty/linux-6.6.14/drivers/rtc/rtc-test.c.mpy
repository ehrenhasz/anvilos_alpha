{
  "module_name": "rtc-test.c",
  "hash_id": "a5ce4ea4a226e04d95ad65ff62f5e19170d569f8b2839103a984cdec1d885b6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-test.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n\n#define MAX_RTC_TEST 3\n\nstruct rtc_test_data {\n\tstruct rtc_device *rtc;\n\ttime64_t offset;\n\tstruct timer_list alarm;\n\tbool alarm_en;\n};\n\nstatic struct platform_device *pdev[MAX_RTC_TEST];\n\nstatic int test_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_test_data *rtd = dev_get_drvdata(dev);\n\ttime64_t alarm;\n\n\talarm = (rtd->alarm.expires - jiffies) / HZ;\n\talarm += ktime_get_real_seconds() + rtd->offset;\n\n\trtc_time64_to_tm(alarm, &alrm->time);\n\talrm->enabled = rtd->alarm_en;\n\n\treturn 0;\n}\n\nstatic int test_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_test_data *rtd = dev_get_drvdata(dev);\n\tktime_t timeout;\n\tu64 expires;\n\n\ttimeout = rtc_tm_to_time64(&alrm->time) - ktime_get_real_seconds();\n\ttimeout -= rtd->offset;\n\n\tdel_timer(&rtd->alarm);\n\n\texpires = jiffies + timeout * HZ;\n\tif (expires > U32_MAX)\n\t\texpires = U32_MAX;\n\n\trtd->alarm.expires = expires;\n\n\tif (alrm->enabled)\n\t\tadd_timer(&rtd->alarm);\n\n\trtd->alarm_en = alrm->enabled;\n\n\treturn 0;\n}\n\nstatic int test_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_test_data *rtd = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(ktime_get_real_seconds() + rtd->offset, tm);\n\n\treturn 0;\n}\n\nstatic int test_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_test_data *rtd = dev_get_drvdata(dev);\n\n\trtd->offset = rtc_tm_to_time64(tm) - ktime_get_real_seconds();\n\n\treturn 0;\n}\n\nstatic int test_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct rtc_test_data *rtd = dev_get_drvdata(dev);\n\n\trtd->alarm_en = enable;\n\tif (enable)\n\t\tadd_timer(&rtd->alarm);\n\telse\n\t\tdel_timer(&rtd->alarm);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops test_rtc_ops_noalm = {\n\t.read_time = test_rtc_read_time,\n\t.set_time = test_rtc_set_time,\n\t.alarm_irq_enable = test_rtc_alarm_irq_enable,\n};\n\nstatic const struct rtc_class_ops test_rtc_ops = {\n\t.read_time = test_rtc_read_time,\n\t.set_time = test_rtc_set_time,\n\t.read_alarm = test_rtc_read_alarm,\n\t.set_alarm = test_rtc_set_alarm,\n\t.alarm_irq_enable = test_rtc_alarm_irq_enable,\n};\n\nstatic void test_rtc_alarm_handler(struct timer_list *t)\n{\n\tstruct rtc_test_data *rtd = from_timer(rtd, t, alarm);\n\n\trtc_update_irq(rtd->rtc, 1, RTC_AF | RTC_IRQF);\n}\n\nstatic int test_probe(struct platform_device *plat_dev)\n{\n\tstruct rtc_test_data *rtd;\n\n\trtd = devm_kzalloc(&plat_dev->dev, sizeof(*rtd), GFP_KERNEL);\n\tif (!rtd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(plat_dev, rtd);\n\n\trtd->rtc = devm_rtc_allocate_device(&plat_dev->dev);\n\tif (IS_ERR(rtd->rtc))\n\t\treturn PTR_ERR(rtd->rtc);\n\n\tswitch (plat_dev->id) {\n\tcase 0:\n\t\trtd->rtc->ops = &test_rtc_ops_noalm;\n\t\tbreak;\n\tdefault:\n\t\trtd->rtc->ops = &test_rtc_ops;\n\t\tdevice_init_wakeup(&plat_dev->dev, 1);\n\t}\n\n\ttimer_setup(&rtd->alarm, test_rtc_alarm_handler, 0);\n\trtd->alarm.expires = 0;\n\n\treturn devm_rtc_register_device(rtd->rtc);\n}\n\nstatic struct platform_driver test_driver = {\n\t.probe\t= test_probe,\n\t.driver = {\n\t\t.name = \"rtc-test\",\n\t},\n};\n\nstatic int __init test_init(void)\n{\n\tint i, err;\n\n\terr = platform_driver_register(&test_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tfor (i = 0; i < MAX_RTC_TEST; i++) {\n\t\tpdev[i] = platform_device_alloc(\"rtc-test\", i);\n\t\tif (!pdev[i])\n\t\t\tgoto exit_free_mem;\n\t}\n\n\tfor (i = 0; i < MAX_RTC_TEST; i++) {\n\t\terr = platform_device_add(pdev[i]);\n\t\tif (err)\n\t\t\tgoto exit_device_del;\n\t}\n\n\treturn 0;\n\nexit_device_del:\n\tfor (; i > 0; i--)\n\t\tplatform_device_del(pdev[i - 1]);\n\nexit_free_mem:\n\tfor (i = 0; i < MAX_RTC_TEST; i++)\n\t\tplatform_device_put(pdev[i]);\n\n\tplatform_driver_unregister(&test_driver);\n\treturn err;\n}\n\nstatic void __exit test_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_RTC_TEST; i++)\n\t\tplatform_device_unregister(pdev[i]);\n\n\tplatform_driver_unregister(&test_driver);\n}\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"RTC test driver/device\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_init(test_init);\nmodule_exit(test_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}