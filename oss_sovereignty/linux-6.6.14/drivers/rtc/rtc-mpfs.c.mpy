{
  "module_name": "rtc-mpfs.c",
  "hash_id": "cc93cce4e1acb55fdbbefb329a52ce760e2d481f00bebd0fa0ad2343dcc482b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mpfs.c",
  "human_readable_source": "\n \n#include \"linux/bits.h\"\n#include \"linux/iopoll.h\"\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n\n#define CONTROL_REG\t\t0x00\n#define MODE_REG\t\t0x04\n#define PRESCALER_REG\t\t0x08\n#define ALARM_LOWER_REG\t\t0x0c\n#define ALARM_UPPER_REG\t\t0x10\n#define COMPARE_LOWER_REG\t0x14\n#define COMPARE_UPPER_REG\t0x18\n#define DATETIME_LOWER_REG\t0x20\n#define DATETIME_UPPER_REG\t0x24\n\n#define CONTROL_RUNNING_BIT\tBIT(0)\n#define CONTROL_START_BIT\tBIT(0)\n#define CONTROL_STOP_BIT\tBIT(1)\n#define CONTROL_ALARM_ON_BIT\tBIT(2)\n#define CONTROL_ALARM_OFF_BIT\tBIT(3)\n#define CONTROL_RESET_BIT\tBIT(4)\n#define CONTROL_UPLOAD_BIT\tBIT(5)\n#define CONTROL_DOWNLOAD_BIT\tBIT(6)\n#define CONTROL_MATCH_BIT\tBIT(7)\n#define CONTROL_WAKEUP_CLR_BIT\tBIT(8)\n#define CONTROL_WAKEUP_SET_BIT\tBIT(9)\n#define CONTROL_UPDATED_BIT\tBIT(10)\n\n#define MODE_CLOCK_CALENDAR\tBIT(0)\n#define MODE_WAKE_EN\t\tBIT(1)\n#define MODE_WAKE_RESET\t\tBIT(2)\n#define MODE_WAKE_CONTINUE\tBIT(3)\n\n#define MAX_PRESCALER_COUNT\tGENMASK(25, 0)\n#define DATETIME_UPPER_MASK\tGENMASK(29, 0)\n#define ALARM_UPPER_MASK\tGENMASK(10, 0)\n\n#define UPLOAD_TIMEOUT_US\t50\n\nstruct mpfs_rtc_dev {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *base;\n};\n\nstatic void mpfs_rtc_start(struct mpfs_rtc_dev *rtcdev)\n{\n\tu32 ctrl;\n\n\tctrl = readl(rtcdev->base + CONTROL_REG);\n\tctrl &= ~CONTROL_STOP_BIT;\n\tctrl |= CONTROL_START_BIT;\n\twritel(ctrl, rtcdev->base + CONTROL_REG);\n}\n\nstatic void mpfs_rtc_clear_irq(struct mpfs_rtc_dev *rtcdev)\n{\n\tu32 val = readl(rtcdev->base + CONTROL_REG);\n\n\tval &= ~(CONTROL_ALARM_ON_BIT | CONTROL_STOP_BIT);\n\tval |= CONTROL_ALARM_OFF_BIT;\n\twritel(val, rtcdev->base + CONTROL_REG);\n\t \n\t(void)readl(rtcdev->base + CONTROL_REG);\n}\n\nstatic int mpfs_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev_get_drvdata(dev);\n\tu64 time;\n\n\ttime = readl(rtcdev->base + DATETIME_LOWER_REG);\n\ttime |= ((u64)readl(rtcdev->base + DATETIME_UPPER_REG) & DATETIME_UPPER_MASK) << 32;\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\nstatic int mpfs_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev_get_drvdata(dev);\n\tu32 ctrl, prog;\n\tu64 time;\n\tint ret;\n\n\ttime = rtc_tm_to_time64(tm);\n\n\twritel((u32)time, rtcdev->base + DATETIME_LOWER_REG);\n\twritel((u32)(time >> 32) & DATETIME_UPPER_MASK, rtcdev->base + DATETIME_UPPER_REG);\n\n\tctrl = readl(rtcdev->base + CONTROL_REG);\n\tctrl &= ~CONTROL_STOP_BIT;\n\tctrl |= CONTROL_UPLOAD_BIT;\n\twritel(ctrl, rtcdev->base + CONTROL_REG);\n\n\tret = read_poll_timeout(readl, prog, prog & CONTROL_UPLOAD_BIT, 0, UPLOAD_TIMEOUT_US,\n\t\t\t\tfalse, rtcdev->base + CONTROL_REG);\n\tif (ret) {\n\t\tdev_err(dev, \"timed out uploading time to rtc\");\n\t\treturn ret;\n\t}\n\tmpfs_rtc_start(rtcdev);\n\n\treturn 0;\n}\n\nstatic int mpfs_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev_get_drvdata(dev);\n\tu32 mode = readl(rtcdev->base + MODE_REG);\n\tu64 time;\n\n\talrm->enabled = mode & MODE_WAKE_EN;\n\n\ttime = (u64)readl(rtcdev->base + ALARM_LOWER_REG) << 32;\n\ttime |= (readl(rtcdev->base + ALARM_UPPER_REG) & ALARM_UPPER_MASK);\n\trtc_time64_to_tm(time, &alrm->time);\n\n\treturn 0;\n}\n\nstatic int mpfs_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev_get_drvdata(dev);\n\tu32 mode, ctrl;\n\tu64 time;\n\n\t \n\tctrl = readl(rtcdev->base + CONTROL_REG);\n\tctrl |= CONTROL_ALARM_OFF_BIT;\n\twritel(ctrl, rtcdev->base + CONTROL_REG);\n\n\ttime = rtc_tm_to_time64(&alrm->time);\n\n\twritel((u32)time, rtcdev->base + ALARM_LOWER_REG);\n\twritel((u32)(time >> 32) & ALARM_UPPER_MASK, rtcdev->base + ALARM_UPPER_REG);\n\n\t \n\twritel(GENMASK(31, 0), rtcdev->base + COMPARE_LOWER_REG);\n\twritel(GENMASK(29, 0), rtcdev->base + COMPARE_UPPER_REG);\n\n\t \n\tctrl = readl(rtcdev->base + CONTROL_REG);\n\tmode = readl(rtcdev->base + MODE_REG);\n\tif (alrm->enabled) {\n\t\tmode = MODE_WAKE_EN | MODE_WAKE_CONTINUE;\n\t\t \n\t\tctrl &= ~CONTROL_ALARM_OFF_BIT;\n\t\tctrl |= CONTROL_ALARM_ON_BIT;\n\t}\n\tctrl &= ~CONTROL_STOP_BIT;\n\tctrl |= CONTROL_START_BIT;\n\twritel(ctrl, rtcdev->base + CONTROL_REG);\n\twritel(mode, rtcdev->base + MODE_REG);\n\n\treturn 0;\n}\n\nstatic int mpfs_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev_get_drvdata(dev);\n\tu32 ctrl;\n\n\tctrl = readl(rtcdev->base + CONTROL_REG);\n\tctrl &= ~(CONTROL_ALARM_ON_BIT | CONTROL_ALARM_OFF_BIT | CONTROL_STOP_BIT);\n\n\tif (enabled)\n\t\tctrl |= CONTROL_ALARM_ON_BIT;\n\telse\n\t\tctrl |= CONTROL_ALARM_OFF_BIT;\n\n\twritel(ctrl, rtcdev->base + CONTROL_REG);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mpfs_rtc_wakeup_irq_handler(int irq, void *dev)\n{\n\tstruct mpfs_rtc_dev *rtcdev = dev;\n\n\tmpfs_rtc_clear_irq(rtcdev);\n\n\trtc_update_irq(rtcdev->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops mpfs_rtc_ops = {\n\t.read_time\t\t= mpfs_rtc_readtime,\n\t.set_time\t\t= mpfs_rtc_settime,\n\t.read_alarm\t\t= mpfs_rtc_readalarm,\n\t.set_alarm\t\t= mpfs_rtc_setalarm,\n\t.alarm_irq_enable\t= mpfs_rtc_alarm_irq_enable,\n};\n\nstatic int mpfs_rtc_probe(struct platform_device *pdev)\n{\n\tstruct mpfs_rtc_dev *rtcdev;\n\tstruct clk *clk;\n\tunsigned long prescaler;\n\tint wakeup_irq, ret;\n\n\trtcdev = devm_kzalloc(&pdev->dev, sizeof(struct mpfs_rtc_dev), GFP_KERNEL);\n\tif (!rtcdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rtcdev);\n\n\trtcdev->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtcdev->rtc))\n\t\treturn PTR_ERR(rtcdev->rtc);\n\n\trtcdev->rtc->ops = &mpfs_rtc_ops;\n\n\t \n\trtcdev->rtc->range_max = GENMASK_ULL(42, 0);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, \"rtc\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\trtcdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtcdev->base)) {\n\t\tdev_dbg(&pdev->dev, \"invalid ioremap resources\\n\");\n\t\treturn PTR_ERR(rtcdev->base);\n\t}\n\n\twakeup_irq = platform_get_irq(pdev, 0);\n\tif (wakeup_irq <= 0) {\n\t\tdev_dbg(&pdev->dev, \"could not get wakeup irq\\n\");\n\t\treturn wakeup_irq;\n\t}\n\tret = devm_request_irq(&pdev->dev, wakeup_irq, mpfs_rtc_wakeup_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), rtcdev);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"could not request wakeup irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tprescaler = clk_get_rate(devm_clk_get(&pdev->dev, \"rtcref\")) - 1;\n\tif (prescaler > MAX_PRESCALER_COUNT) {\n\t\tdev_dbg(&pdev->dev, \"invalid prescaler %lu\\n\", prescaler);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(prescaler, rtcdev->base + PRESCALER_REG);\n\tdev_info(&pdev->dev, \"prescaler set to: %lu\\n\", prescaler);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tret = dev_pm_set_wake_irq(&pdev->dev, wakeup_irq);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to enable irq wake\\n\");\n\n\treturn devm_rtc_register_device(rtcdev->rtc);\n}\n\nstatic void mpfs_rtc_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n}\n\nstatic const struct of_device_id mpfs_rtc_of_match[] = {\n\t{ .compatible = \"microchip,mpfs-rtc\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, mpfs_rtc_of_match);\n\nstatic struct platform_driver mpfs_rtc_driver = {\n\t.probe = mpfs_rtc_probe,\n\t.remove_new = mpfs_rtc_remove,\n\t.driver\t= {\n\t\t.name = \"mpfs_rtc\",\n\t\t.of_match_table = mpfs_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(mpfs_rtc_driver);\n\nMODULE_DESCRIPTION(\"Real time clock for Microchip Polarfire SoC\");\nMODULE_AUTHOR(\"Daire McNamara <daire.mcnamara@microchip.com>\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}