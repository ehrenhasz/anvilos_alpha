{
  "module_name": "rtc-ds2404.c",
  "hash_id": "c89efff33deab72fb48d300e5e0d7f96cc48588d884a105c7c0492565c2f3bd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds2404.c",
  "human_readable_source": "\n\n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/rtc.h>\n#include <linux/types.h>\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/io.h>\n\n#define DS2404_STATUS_REG 0x200\n#define DS2404_CONTROL_REG 0x201\n#define DS2404_RTC_REG 0x202\n\n#define DS2404_WRITE_SCRATCHPAD_CMD 0x0f\n#define DS2404_READ_SCRATCHPAD_CMD 0xaa\n#define DS2404_COPY_SCRATCHPAD_CMD 0x55\n#define DS2404_READ_MEMORY_CMD 0xf0\n\n#define DS2404_RST\t0\n#define DS2404_CLK\t1\n#define DS2404_DQ\t2\n\nstruct ds2404 {\n\tstruct device *dev;\n\tstruct gpio_desc *rst_gpiod;\n\tstruct gpio_desc *clk_gpiod;\n\tstruct gpio_desc *dq_gpiod;\n\tstruct rtc_device *rtc;\n};\n\nstatic int ds2404_gpio_map(struct ds2404 *chip, struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tchip->rst_gpiod = devm_gpiod_get(dev, \"rst\", GPIOD_OUT_LOW);\n\tif (IS_ERR(chip->rst_gpiod))\n\t\treturn PTR_ERR(chip->rst_gpiod);\n\n\tchip->clk_gpiod = devm_gpiod_get(dev, \"clk\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->clk_gpiod))\n\t\treturn PTR_ERR(chip->clk_gpiod);\n\n\tchip->dq_gpiod = devm_gpiod_get(dev, \"dq\", GPIOD_ASIS);\n\tif (IS_ERR(chip->dq_gpiod))\n\t\treturn PTR_ERR(chip->dq_gpiod);\n\n\treturn 0;\n}\n\nstatic void ds2404_reset(struct ds2404 *chip)\n{\n\tgpiod_set_value(chip->rst_gpiod, 1);\n\tudelay(1000);\n\tgpiod_set_value(chip->rst_gpiod, 0);\n\tgpiod_set_value(chip->clk_gpiod, 0);\n\tgpiod_direction_output(chip->dq_gpiod, 0);\n\tudelay(10);\n}\n\nstatic void ds2404_write_byte(struct ds2404 *chip, u8 byte)\n{\n\tint i;\n\n\tgpiod_direction_output(chip->dq_gpiod, 1);\n\tfor (i = 0; i < 8; i++) {\n\t\tgpiod_set_value(chip->dq_gpiod, byte & (1 << i));\n\t\tudelay(10);\n\t\tgpiod_set_value(chip->clk_gpiod, 1);\n\t\tudelay(10);\n\t\tgpiod_set_value(chip->clk_gpiod, 0);\n\t\tudelay(10);\n\t}\n}\n\nstatic u8 ds2404_read_byte(struct ds2404 *chip)\n{\n\tint i;\n\tu8 ret = 0;\n\n\tgpiod_direction_input(chip->dq_gpiod);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tgpiod_set_value(chip->clk_gpiod, 0);\n\t\tudelay(10);\n\t\tif (gpiod_get_value(chip->dq_gpiod))\n\t\t\tret |= 1 << i;\n\t\tgpiod_set_value(chip->clk_gpiod, 1);\n\t\tudelay(10);\n\t}\n\treturn ret;\n}\n\nstatic void ds2404_read_memory(struct ds2404 *chip, u16 offset,\n\t\t\t       int length, u8 *out)\n{\n\tds2404_reset(chip);\n\tds2404_write_byte(chip, DS2404_READ_MEMORY_CMD);\n\tds2404_write_byte(chip, offset & 0xff);\n\tds2404_write_byte(chip, (offset >> 8) & 0xff);\n\twhile (length--)\n\t\t*out++ = ds2404_read_byte(chip);\n}\n\nstatic void ds2404_write_memory(struct ds2404 *chip, u16 offset,\n\t\t\t\tint length, u8 *out)\n{\n\tint i;\n\tu8 ta01, ta02, es;\n\n\tds2404_reset(chip);\n\tds2404_write_byte(chip, DS2404_WRITE_SCRATCHPAD_CMD);\n\tds2404_write_byte(chip, offset & 0xff);\n\tds2404_write_byte(chip, (offset >> 8) & 0xff);\n\n\tfor (i = 0; i < length; i++)\n\t\tds2404_write_byte(chip, out[i]);\n\n\tds2404_reset(chip);\n\tds2404_write_byte(chip, DS2404_READ_SCRATCHPAD_CMD);\n\n\tta01 = ds2404_read_byte(chip);\n\tta02 = ds2404_read_byte(chip);\n\tes = ds2404_read_byte(chip);\n\n\tfor (i = 0; i < length; i++) {\n\t\tif (out[i] != ds2404_read_byte(chip)) {\n\t\t\tdev_err(chip->dev, \"read invalid data\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tds2404_reset(chip);\n\tds2404_write_byte(chip, DS2404_COPY_SCRATCHPAD_CMD);\n\tds2404_write_byte(chip, ta01);\n\tds2404_write_byte(chip, ta02);\n\tds2404_write_byte(chip, es);\n\n\twhile (gpiod_get_value(chip->dq_gpiod))\n\t\t;\n}\n\nstatic void ds2404_enable_osc(struct ds2404 *chip)\n{\n\tu8 in[1] = { 0x10 };  \n\n\tds2404_write_memory(chip, 0x201, 1, in);\n}\n\nstatic int ds2404_read_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct ds2404 *chip = dev_get_drvdata(dev);\n\tunsigned long time = 0;\n\t__le32 hw_time = 0;\n\n\tds2404_read_memory(chip, 0x203, 4, (u8 *)&hw_time);\n\ttime = le32_to_cpu(hw_time);\n\n\trtc_time64_to_tm(time, dt);\n\treturn 0;\n}\n\nstatic int ds2404_set_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct ds2404 *chip = dev_get_drvdata(dev);\n\tu32 time = cpu_to_le32(rtc_tm_to_time64(dt));\n\tds2404_write_memory(chip, 0x203, 4, (u8 *)&time);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds2404_rtc_ops = {\n\t.read_time\t= ds2404_read_time,\n\t.set_time\t= ds2404_set_time,\n};\n\nstatic int rtc_probe(struct platform_device *pdev)\n{\n\tstruct ds2404 *chip;\n\tint retval = -EBUSY;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(struct ds2404), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &pdev->dev;\n\n\tchip->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(chip->rtc))\n\t\treturn PTR_ERR(chip->rtc);\n\n\tretval = ds2404_gpio_map(chip, pdev);\n\tif (retval)\n\t\treturn retval;\n\n\tplatform_set_drvdata(pdev, chip);\n\n\tchip->rtc->ops = &ds2404_rtc_ops;\n\tchip->rtc->range_max = U32_MAX;\n\n\tretval = devm_rtc_register_device(chip->rtc);\n\tif (retval)\n\t\treturn retval;\n\n\tds2404_enable_osc(chip);\n\treturn 0;\n}\n\nstatic struct platform_driver rtc_device_driver = {\n\t.probe\t= rtc_probe,\n\t.driver = {\n\t\t.name\t= \"ds2404\",\n\t},\n};\nmodule_platform_driver(rtc_device_driver);\n\nMODULE_DESCRIPTION(\"DS2404 RTC\");\nMODULE_AUTHOR(\"Sven Schnelle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ds2404\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}