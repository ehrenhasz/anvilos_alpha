{
  "module_name": "rtc-tps6586x.c",
  "hash_id": "5eaa619f37f68b62138d27686f314dfb5dc36abf08c3346466ec6d2bba23a44c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-tps6586x.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mfd/tps6586x.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#define RTC_CTRL\t\t\t0xc0\n#define POR_RESET_N\t\t\tBIT(7)\n#define OSC_SRC_SEL\t\t\tBIT(6)\n#define RTC_ENABLE\t\t\tBIT(5)\t \n#define RTC_BUF_ENABLE\t\t\tBIT(4)\t \n#define PRE_BYPASS\t\t\tBIT(3)\t \n#define CL_SEL_MASK\t\t\t(BIT(2)|BIT(1))\n#define CL_SEL_POS\t\t\t1\n#define RTC_ALARM1_HI\t\t\t0xc1\n#define RTC_COUNT4\t\t\t0xc6\n\n \n#define RTC_COUNT4_DUMMYREAD\t\t0xc5\n\n \n#define ALM1_VALID_RANGE_IN_SEC\t\t0x3FFF\n\n#define TPS6586X_RTC_CL_SEL_1_5PF\t0x0\n#define TPS6586X_RTC_CL_SEL_6_5PF\t0x1\n#define TPS6586X_RTC_CL_SEL_7_5PF\t0x2\n#define TPS6586X_RTC_CL_SEL_12_5PF\t0x3\n\nstruct tps6586x_rtc {\n\tstruct device\t\t*dev;\n\tstruct rtc_device\t*rtc;\n\tint\t\t\tirq;\n\tbool\t\t\tirq_en;\n};\n\nstatic inline struct device *to_tps6586x_dev(struct device *dev)\n{\n\treturn dev->parent;\n}\n\nstatic int tps6586x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(dev);\n\tunsigned long long ticks = 0;\n\ttime64_t seconds;\n\tu8 buff[6];\n\tint ret;\n\tint i;\n\n\tret = tps6586x_reads(tps_dev, RTC_COUNT4_DUMMYREAD, sizeof(buff), buff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"read counter failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 1; i < sizeof(buff); i++) {\n\t\tticks <<= 8;\n\t\tticks |= buff[i];\n\t}\n\n\tseconds = ticks >> 10;\n\trtc_time64_to_tm(seconds, tm);\n\n\treturn 0;\n}\n\nstatic int tps6586x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(dev);\n\tunsigned long long ticks;\n\ttime64_t seconds;\n\tu8 buff[5];\n\tint ret;\n\n\tseconds = rtc_tm_to_time64(tm);\n\n\tticks = (unsigned long long)seconds << 10;\n\tbuff[0] = (ticks >> 32) & 0xff;\n\tbuff[1] = (ticks >> 24) & 0xff;\n\tbuff[2] = (ticks >> 16) & 0xff;\n\tbuff[3] = (ticks >> 8) & 0xff;\n\tbuff[4] = ticks & 0xff;\n\n\t \n\tret = tps6586x_clr_bits(tps_dev, RTC_CTRL, RTC_ENABLE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to clear RTC_ENABLE\\n\");\n\t\treturn ret;\n\t}\n\n\tret = tps6586x_writes(tps_dev, RTC_COUNT4, sizeof(buff), buff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to program new time\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = tps6586x_set_bits(tps_dev, RTC_CTRL, RTC_ENABLE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set RTC_ENABLE\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int tps6586x_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t unsigned int enabled)\n{\n\tstruct tps6586x_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (enabled && !rtc->irq_en) {\n\t\tenable_irq(rtc->irq);\n\t\trtc->irq_en = true;\n\t} else if (!enabled && rtc->irq_en)  {\n\t\tdisable_irq(rtc->irq);\n\t\trtc->irq_en = false;\n\t}\n\treturn 0;\n}\n\nstatic int tps6586x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(dev);\n\ttime64_t seconds;\n\tunsigned long ticks;\n\tunsigned long rtc_current_time;\n\tunsigned long long rticks = 0;\n\tu8 buff[3];\n\tu8 rbuff[6];\n\tint ret;\n\tint i;\n\n\tseconds = rtc_tm_to_time64(&alrm->time);\n\n\tret = tps6586x_rtc_alarm_irq_enable(dev, alrm->enabled);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't set alarm irq, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tps6586x_reads(tps_dev, RTC_COUNT4_DUMMYREAD,\n\t\t\tsizeof(rbuff), rbuff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"read counter failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 1; i < sizeof(rbuff); i++) {\n\t\trticks <<= 8;\n\t\trticks |= rbuff[i];\n\t}\n\n\trtc_current_time = rticks >> 10;\n\tif ((seconds - rtc_current_time) > ALM1_VALID_RANGE_IN_SEC)\n\t\tseconds = rtc_current_time - 1;\n\n\tticks = (unsigned long long)seconds << 10;\n\tbuff[0] = (ticks >> 16) & 0xff;\n\tbuff[1] = (ticks >> 8) & 0xff;\n\tbuff[2] = ticks & 0xff;\n\n\tret = tps6586x_writes(tps_dev, RTC_ALARM1_HI, sizeof(buff), buff);\n\tif (ret)\n\t\tdev_err(dev, \"programming alarm failed with err %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tps6586x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(dev);\n\tunsigned long ticks;\n\ttime64_t seconds;\n\tu8 buff[3];\n\tint ret;\n\n\tret = tps6586x_reads(tps_dev, RTC_ALARM1_HI, sizeof(buff), buff);\n\tif (ret) {\n\t\tdev_err(dev, \"read RTC_ALARM1_HI failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tticks = (buff[0] << 16) | (buff[1] << 8) | buff[2];\n\tseconds = ticks >> 10;\n\n\trtc_time64_to_tm(seconds, &alrm->time);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops tps6586x_rtc_ops = {\n\t.read_time\t= tps6586x_rtc_read_time,\n\t.set_time\t= tps6586x_rtc_set_time,\n\t.set_alarm\t= tps6586x_rtc_set_alarm,\n\t.read_alarm\t= tps6586x_rtc_read_alarm,\n\t.alarm_irq_enable = tps6586x_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t tps6586x_rtc_irq(int irq, void *data)\n{\n\tstruct tps6586x_rtc *rtc = data;\n\n\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int tps6586x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(&pdev->dev);\n\tstruct tps6586x_rtc *rtc;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->dev = &pdev->dev;\n\trtc->irq = platform_get_irq(pdev, 0);\n\n\t \n\tret = tps6586x_update(tps_dev, RTC_CTRL,\n\t\tRTC_ENABLE | OSC_SRC_SEL |\n\t\t((TPS6586X_RTC_CL_SEL_1_5PF << CL_SEL_POS) & CL_SEL_MASK),\n\t\tRTC_ENABLE | OSC_SRC_SEL | PRE_BYPASS | CL_SEL_MASK);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to start counter\\n\");\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tplatform_set_drvdata(pdev, rtc);\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc)) {\n\t\tret = PTR_ERR(rtc->rtc);\n\t\tgoto fail_rtc_register;\n\t}\n\n\trtc->rtc->ops = &tps6586x_rtc_ops;\n\trtc->rtc->range_max = (1ULL << 30) - 1;  \n\trtc->rtc->alarm_offset_max = ALM1_VALID_RANGE_IN_SEC;\n\trtc->rtc->start_secs = mktime64(2009, 1, 1, 0, 0, 0);\n\trtc->rtc->set_start_time = true;\n\n\tirq_set_status_flags(rtc->irq, IRQ_NOAUTOEN);\n\n\tret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\n\t\t\t\ttps6586x_rtc_irq,\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tdev_name(&pdev->dev), rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request IRQ(%d) failed with ret %d\\n\",\n\t\t\t\trtc->irq, ret);\n\t\tgoto fail_rtc_register;\n\t}\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\tgoto fail_rtc_register;\n\n\treturn 0;\n\nfail_rtc_register:\n\ttps6586x_update(tps_dev, RTC_CTRL, 0,\n\t\tRTC_ENABLE | OSC_SRC_SEL | PRE_BYPASS | CL_SEL_MASK);\n\treturn ret;\n};\n\nstatic void tps6586x_rtc_remove(struct platform_device *pdev)\n{\n\tstruct device *tps_dev = to_tps6586x_dev(&pdev->dev);\n\n\ttps6586x_update(tps_dev, RTC_CTRL, 0,\n\t\tRTC_ENABLE | OSC_SRC_SEL | PRE_BYPASS | CL_SEL_MASK);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tps6586x_rtc_suspend(struct device *dev)\n{\n\tstruct tps6586x_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(rtc->irq);\n\treturn 0;\n}\n\nstatic int tps6586x_rtc_resume(struct device *dev)\n{\n\tstruct tps6586x_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(rtc->irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tps6586x_pm_ops, tps6586x_rtc_suspend,\n\t\t\ttps6586x_rtc_resume);\n\nstatic struct platform_driver tps6586x_rtc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"tps6586x-rtc\",\n\t\t.pm\t= &tps6586x_pm_ops,\n\t},\n\t.probe\t= tps6586x_rtc_probe,\n\t.remove_new = tps6586x_rtc_remove,\n};\nmodule_platform_driver(tps6586x_rtc_driver);\n\nMODULE_ALIAS(\"platform:tps6586x-rtc\");\nMODULE_DESCRIPTION(\"TI TPS6586x RTC driver\");\nMODULE_AUTHOR(\"Laxman dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}