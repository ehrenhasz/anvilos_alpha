{
  "module_name": "rtc-tegra.c",
  "hash_id": "0a9422be45577486aa8d4f13756bae4d9e0012d603a28e3522ba01d72d9e9971",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n \n#define TEGRA_RTC_REG_BUSY\t\t\t0x004\n#define TEGRA_RTC_REG_SECONDS\t\t\t0x008\n \n#define TEGRA_RTC_REG_SHADOW_SECONDS\t\t0x00c\n#define TEGRA_RTC_REG_MILLI_SECONDS\t\t0x010\n#define TEGRA_RTC_REG_SECONDS_ALARM0\t\t0x014\n#define TEGRA_RTC_REG_SECONDS_ALARM1\t\t0x018\n#define TEGRA_RTC_REG_MILLI_SECONDS_ALARM0\t0x01c\n#define TEGRA_RTC_REG_INTR_MASK\t\t\t0x028\n \n#define TEGRA_RTC_REG_INTR_STATUS\t\t0x02c\n\n \n#define TEGRA_RTC_INTR_MASK_MSEC_CDN_ALARM\t(1<<4)\n#define TEGRA_RTC_INTR_MASK_SEC_CDN_ALARM\t(1<<3)\n#define TEGRA_RTC_INTR_MASK_MSEC_ALARM\t\t(1<<2)\n#define TEGRA_RTC_INTR_MASK_SEC_ALARM1\t\t(1<<1)\n#define TEGRA_RTC_INTR_MASK_SEC_ALARM0\t\t(1<<0)\n\n \n#define TEGRA_RTC_INTR_STATUS_MSEC_CDN_ALARM\t(1<<4)\n#define TEGRA_RTC_INTR_STATUS_SEC_CDN_ALARM\t(1<<3)\n#define TEGRA_RTC_INTR_STATUS_MSEC_ALARM\t(1<<2)\n#define TEGRA_RTC_INTR_STATUS_SEC_ALARM1\t(1<<1)\n#define TEGRA_RTC_INTR_STATUS_SEC_ALARM0\t(1<<0)\n\nstruct tegra_rtc_info {\n\tstruct platform_device *pdev;\n\tstruct rtc_device *rtc;\n\tvoid __iomem *base;  \n\tstruct clk *clk;\n\tint irq;  \n\tspinlock_t lock;\n};\n\n \nstatic inline u32 tegra_rtc_check_busy(struct tegra_rtc_info *info)\n{\n\treturn readl(info->base + TEGRA_RTC_REG_BUSY) & 1;\n}\n\n \nstatic int tegra_rtc_wait_while_busy(struct device *dev)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tint retries = 500;  \n\n\t \n\twhile (tegra_rtc_check_busy(info)) {\n\t\tif (!retries--)\n\t\t\tgoto retry_failed;\n\n\t\tudelay(1);\n\t}\n\n\t \n\treturn 0;\n\nretry_failed:\n\tdev_err(dev, \"write failed: retry count exceeded\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 sec;\n\n\t \n\tspin_lock_irqsave(&info->lock, flags);\n\n\treadl(info->base + TEGRA_RTC_REG_MILLI_SECONDS);\n\tsec = readl(info->base + TEGRA_RTC_REG_SHADOW_SECONDS);\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\trtc_time64_to_tm(sec, tm);\n\n\tdev_vdbg(dev, \"time read as %u, %ptR\\n\", sec, tm);\n\n\treturn 0;\n}\n\nstatic int tegra_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tu32 sec;\n\tint ret;\n\n\t \n\tsec = rtc_tm_to_time64(tm);\n\n\tdev_vdbg(dev, \"time set to %u, %ptR\\n\", sec, tm);\n\n\t \n\tret = tegra_rtc_wait_while_busy(dev);\n\tif (!ret)\n\t\twritel(sec, info->base + TEGRA_RTC_REG_SECONDS);\n\n\tdev_vdbg(dev, \"time read back as %d\\n\",\n\t\t readl(info->base + TEGRA_RTC_REG_SECONDS));\n\n\treturn ret;\n}\n\nstatic int tegra_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tu32 sec, value;\n\n\tsec = readl(info->base + TEGRA_RTC_REG_SECONDS_ALARM0);\n\n\tif (sec == 0) {\n\t\t \n\t\talarm->enabled = 0;\n\t} else {\n\t\t \n\t\talarm->enabled = 1;\n\t\trtc_time64_to_tm(sec, &alarm->time);\n\t}\n\n\tvalue = readl(info->base + TEGRA_RTC_REG_INTR_STATUS);\n\talarm->pending = (value & TEGRA_RTC_INTR_STATUS_SEC_ALARM0) != 0;\n\n\treturn 0;\n}\n\nstatic int tegra_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 status;\n\n\ttegra_rtc_wait_while_busy(dev);\n\tspin_lock_irqsave(&info->lock, flags);\n\n\t \n\tstatus = readl(info->base + TEGRA_RTC_REG_INTR_MASK);\n\tif (enabled)\n\t\tstatus |= TEGRA_RTC_INTR_MASK_SEC_ALARM0;  \n\telse\n\t\tstatus &= ~TEGRA_RTC_INTR_MASK_SEC_ALARM0;  \n\n\twritel(status, info->base + TEGRA_RTC_REG_INTR_MASK);\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tegra_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tu32 sec;\n\n\tif (alarm->enabled)\n\t\tsec = rtc_tm_to_time64(&alarm->time);\n\telse\n\t\tsec = 0;\n\n\ttegra_rtc_wait_while_busy(dev);\n\twritel(sec, info->base + TEGRA_RTC_REG_SECONDS_ALARM0);\n\tdev_vdbg(dev, \"alarm read back as %d\\n\",\n\t\t readl(info->base + TEGRA_RTC_REG_SECONDS_ALARM0));\n\n\t \n\tif (sec) {\n\t\ttegra_rtc_alarm_irq_enable(dev, 1);\n\t\tdev_vdbg(dev, \"alarm set as %u, %ptR\\n\", sec, &alarm->time);\n\t} else {\n\t\t \n\t\tdev_vdbg(dev, \"alarm disabled\\n\");\n\t\ttegra_rtc_alarm_irq_enable(dev, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tif (!dev || !dev->driver)\n\t\treturn 0;\n\n\tseq_printf(seq, \"name\\t\\t: %s\\n\", dev_name(dev));\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_rtc_irq_handler(int irq, void *data)\n{\n\tstruct device *dev = data;\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned long events = 0;\n\tu32 status;\n\n\tstatus = readl(info->base + TEGRA_RTC_REG_INTR_STATUS);\n\tif (status) {\n\t\t \n\t\ttegra_rtc_wait_while_busy(dev);\n\n\t\tspin_lock(&info->lock);\n\t\twritel(0, info->base + TEGRA_RTC_REG_INTR_MASK);\n\t\twritel(status, info->base + TEGRA_RTC_REG_INTR_STATUS);\n\t\tspin_unlock(&info->lock);\n\t}\n\n\t \n\tif (status & TEGRA_RTC_INTR_STATUS_SEC_ALARM0)\n\t\tevents |= RTC_IRQF | RTC_AF;\n\n\t \n\tif (status & TEGRA_RTC_INTR_STATUS_SEC_CDN_ALARM)\n\t\tevents |= RTC_IRQF | RTC_PF;\n\n\trtc_update_irq(info->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops tegra_rtc_ops = {\n\t.read_time = tegra_rtc_read_time,\n\t.set_time = tegra_rtc_set_time,\n\t.read_alarm = tegra_rtc_read_alarm,\n\t.set_alarm = tegra_rtc_set_alarm,\n\t.proc = tegra_rtc_proc,\n\t.alarm_irq_enable = tegra_rtc_alarm_irq_enable,\n};\n\nstatic const struct of_device_id tegra_rtc_dt_match[] = {\n\t{ .compatible = \"nvidia,tegra20-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_rtc_dt_match);\n\nstatic int tegra_rtc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_rtc_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->base))\n\t\treturn PTR_ERR(info->base);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tinfo->irq = ret;\n\n\tinfo->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc))\n\t\treturn PTR_ERR(info->rtc);\n\n\tinfo->rtc->ops = &tegra_rtc_ops;\n\tinfo->rtc->range_max = U32_MAX;\n\n\tinfo->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(info->clk))\n\t\treturn PTR_ERR(info->clk);\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tinfo->pdev = pdev;\n\tspin_lock_init(&info->lock);\n\n\tplatform_set_drvdata(pdev, info);\n\n\t \n\twritel(0, info->base + TEGRA_RTC_REG_SECONDS_ALARM0);\n\twritel(0xffffffff, info->base + TEGRA_RTC_REG_INTR_STATUS);\n\twritel(0, info->base + TEGRA_RTC_REG_INTR_MASK);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tret = devm_request_irq(&pdev->dev, info->irq, tegra_rtc_irq_handler,\n\t\t\t       IRQF_TRIGGER_HIGH, dev_name(&pdev->dev),\n\t\t\t       &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request interrupt: %d\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\tret = devm_rtc_register_device(info->rtc);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tdev_notice(&pdev->dev, \"Tegra internal Real Time Clock\\n\");\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(info->clk);\n\treturn ret;\n}\n\nstatic void tegra_rtc_remove(struct platform_device *pdev)\n{\n\tstruct tegra_rtc_info *info = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(info->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_rtc_suspend(struct device *dev)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\n\ttegra_rtc_wait_while_busy(dev);\n\n\t \n\twritel(0xffffffff, info->base + TEGRA_RTC_REG_INTR_STATUS);\n\twritel(TEGRA_RTC_INTR_STATUS_SEC_ALARM0,\n\t       info->base + TEGRA_RTC_REG_INTR_MASK);\n\n\tdev_vdbg(dev, \"alarm sec = %d\\n\",\n\t\t readl(info->base + TEGRA_RTC_REG_SECONDS_ALARM0));\n\n\tdev_vdbg(dev, \"Suspend (device_may_wakeup=%d) IRQ:%d\\n\",\n\t\t device_may_wakeup(dev), info->irq);\n\n\t \n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(info->irq);\n\n\treturn 0;\n}\n\nstatic int tegra_rtc_resume(struct device *dev)\n{\n\tstruct tegra_rtc_info *info = dev_get_drvdata(dev);\n\n\tdev_vdbg(dev, \"Resume (device_may_wakeup=%d)\\n\",\n\t\t device_may_wakeup(dev));\n\n\t \n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(info->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tegra_rtc_pm_ops, tegra_rtc_suspend, tegra_rtc_resume);\n\nstatic void tegra_rtc_shutdown(struct platform_device *pdev)\n{\n\tdev_vdbg(&pdev->dev, \"disabling interrupts\\n\");\n\ttegra_rtc_alarm_irq_enable(&pdev->dev, 0);\n}\n\nstatic struct platform_driver tegra_rtc_driver = {\n\t.probe = tegra_rtc_probe,\n\t.remove_new = tegra_rtc_remove,\n\t.shutdown = tegra_rtc_shutdown,\n\t.driver = {\n\t\t.name = \"tegra_rtc\",\n\t\t.of_match_table = tegra_rtc_dt_match,\n\t\t.pm = &tegra_rtc_pm_ops,\n\t},\n};\nmodule_platform_driver(tegra_rtc_driver);\n\nMODULE_AUTHOR(\"Jon Mayo <jmayo@nvidia.com>\");\nMODULE_DESCRIPTION(\"driver for Tegra internal RTC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}