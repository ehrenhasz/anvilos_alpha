{
  "module_name": "rtc-ntxec.c",
  "hash_id": "a4329bc6070ab8c71c61f9661ddc2ea85d4bfdbc353a81df942504c2c0539132",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ntxec.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/ntxec.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/types.h>\n\nstruct ntxec_rtc {\n\tstruct device *dev;\n\tstruct ntxec *ec;\n};\n\n#define NTXEC_REG_WRITE_YEAR\t0x10\n#define NTXEC_REG_WRITE_MONTH\t0x11\n#define NTXEC_REG_WRITE_DAY\t0x12\n#define NTXEC_REG_WRITE_HOUR\t0x13\n#define NTXEC_REG_WRITE_MINUTE\t0x14\n#define NTXEC_REG_WRITE_SECOND\t0x15\n\n#define NTXEC_REG_READ_YEAR_MONTH\t0x20\n#define NTXEC_REG_READ_MDAY_HOUR\t0x21\n#define NTXEC_REG_READ_MINUTE_SECOND\t0x23\n\nstatic int ntxec_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ntxec_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint res;\n\nretry:\n\tres = regmap_read(rtc->ec->regmap, NTXEC_REG_READ_MINUTE_SECOND, &value);\n\tif (res < 0)\n\t\treturn res;\n\n\ttm->tm_min = value >> 8;\n\ttm->tm_sec = value & 0xff;\n\n\tres = regmap_read(rtc->ec->regmap, NTXEC_REG_READ_MDAY_HOUR, &value);\n\tif (res < 0)\n\t\treturn res;\n\n\ttm->tm_mday = value >> 8;\n\ttm->tm_hour = value & 0xff;\n\n\tres = regmap_read(rtc->ec->regmap, NTXEC_REG_READ_YEAR_MONTH, &value);\n\tif (res < 0)\n\t\treturn res;\n\n\ttm->tm_year = (value >> 8) + 100;\n\ttm->tm_mon = (value & 0xff) - 1;\n\n\t \n\tres = regmap_read(rtc->ec->regmap, NTXEC_REG_READ_MINUTE_SECOND, &value);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (tm->tm_min != value >> 8 || tm->tm_sec != (value & 0xff))\n\t\tgoto retry;\n\n\treturn 0;\n}\n\nstatic int ntxec_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ntxec_rtc *rtc = dev_get_drvdata(dev);\n\n\t \n\tstruct reg_sequence regs[] = {\n\t\t{ NTXEC_REG_WRITE_SECOND, ntxec_reg8(0) },\n\t\t{ NTXEC_REG_WRITE_YEAR, ntxec_reg8(tm->tm_year - 100) },\n\t\t{ NTXEC_REG_WRITE_MONTH, ntxec_reg8(tm->tm_mon + 1) },\n\t\t{ NTXEC_REG_WRITE_DAY, ntxec_reg8(tm->tm_mday) },\n\t\t{ NTXEC_REG_WRITE_HOUR, ntxec_reg8(tm->tm_hour) },\n\t\t{ NTXEC_REG_WRITE_MINUTE, ntxec_reg8(tm->tm_min) },\n\t\t{ NTXEC_REG_WRITE_SECOND, ntxec_reg8(tm->tm_sec) },\n\t};\n\n\treturn regmap_multi_reg_write(rtc->ec->regmap, regs, ARRAY_SIZE(regs));\n}\n\nstatic const struct rtc_class_ops ntxec_rtc_ops = {\n\t.read_time = ntxec_read_time,\n\t.set_time = ntxec_set_time,\n};\n\nstatic int ntxec_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *dev;\n\tstruct ntxec_rtc *rtc;\n\n\tpdev->dev.of_node = pdev->dev.parent->of_node;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->dev = &pdev->dev;\n\trtc->ec = dev_get_drvdata(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, rtc);\n\n\tdev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tdev->ops = &ntxec_rtc_ops;\n\tdev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tdev->range_max = 9025257599LL;  \n\n\treturn devm_rtc_register_device(dev);\n}\n\nstatic struct platform_driver ntxec_rtc_driver = {\n\t.driver = {\n\t\t.name = \"ntxec-rtc\",\n\t},\n\t.probe = ntxec_rtc_probe,\n};\nmodule_platform_driver(ntxec_rtc_driver);\n\nMODULE_AUTHOR(\"Jonathan Neusch\u00e4fer <j.neuschaefer@gmx.net>\");\nMODULE_DESCRIPTION(\"RTC driver for Netronix EC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ntxec-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}