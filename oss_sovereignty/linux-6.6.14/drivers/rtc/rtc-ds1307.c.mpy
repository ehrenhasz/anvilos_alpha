{
  "module_name": "rtc-ds1307.c",
  "hash_id": "301a52ccdad2adb865d0712557d6a3f160ddf2e9d48f1b9d0673f7610ad7757b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1307.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kstrtox.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/rtc/ds1307.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/clk-provider.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n \nenum ds_type {\n\tunknown_ds_type,  \n\tds_1307,\n\tds_1308,\n\tds_1337,\n\tds_1338,\n\tds_1339,\n\tds_1340,\n\tds_1341,\n\tds_1388,\n\tds_3231,\n\tm41t0,\n\tm41t00,\n\tm41t11,\n\tmcp794xx,\n\trx_8025,\n\trx_8130,\n\tlast_ds_type  \n\t \n};\n\n \n#define DS1307_REG_SECS\t\t0x00\t \n#\tdefine DS1307_BIT_CH\t\t0x80\n#\tdefine DS1340_BIT_nEOSC\t\t0x80\n#\tdefine MCP794XX_BIT_ST\t\t0x80\n#define DS1307_REG_MIN\t\t0x01\t \n#\tdefine M41T0_BIT_OF\t\t0x80\n#define DS1307_REG_HOUR\t\t0x02\t \n#\tdefine DS1307_BIT_12HR\t\t0x40\t \n#\tdefine DS1307_BIT_PM\t\t0x20\t \n#\tdefine DS1340_BIT_CENTURY_EN\t0x80\t \n#\tdefine DS1340_BIT_CENTURY\t0x40\t \n#define DS1307_REG_WDAY\t\t0x03\t \n#\tdefine MCP794XX_BIT_VBATEN\t0x08\n#define DS1307_REG_MDAY\t\t0x04\t \n#define DS1307_REG_MONTH\t0x05\t \n#\tdefine DS1337_BIT_CENTURY\t0x80\t \n#define DS1307_REG_YEAR\t\t0x06\t \n\n \n#define DS1307_REG_CONTROL\t0x07\t\t \n#\tdefine DS1307_BIT_OUT\t\t0x80\n#\tdefine DS1338_BIT_OSF\t\t0x20\n#\tdefine DS1307_BIT_SQWE\t\t0x10\n#\tdefine DS1307_BIT_RS1\t\t0x02\n#\tdefine DS1307_BIT_RS0\t\t0x01\n#define DS1337_REG_CONTROL\t0x0e\n#\tdefine DS1337_BIT_nEOSC\t\t0x80\n#\tdefine DS1339_BIT_BBSQI\t\t0x20\n#\tdefine DS3231_BIT_BBSQW\t\t0x40  \n#\tdefine DS1337_BIT_RS2\t\t0x10\n#\tdefine DS1337_BIT_RS1\t\t0x08\n#\tdefine DS1337_BIT_INTCN\t\t0x04\n#\tdefine DS1337_BIT_A2IE\t\t0x02\n#\tdefine DS1337_BIT_A1IE\t\t0x01\n#define DS1340_REG_CONTROL\t0x07\n#\tdefine DS1340_BIT_OUT\t\t0x80\n#\tdefine DS1340_BIT_FT\t\t0x40\n#\tdefine DS1340_BIT_CALIB_SIGN\t0x20\n#\tdefine DS1340_M_CALIBRATION\t0x1f\n#define DS1340_REG_FLAG\t\t0x09\n#\tdefine DS1340_BIT_OSF\t\t0x80\n#define DS1337_REG_STATUS\t0x0f\n#\tdefine DS1337_BIT_OSF\t\t0x80\n#\tdefine DS3231_BIT_EN32KHZ\t0x08\n#\tdefine DS1337_BIT_A2I\t\t0x02\n#\tdefine DS1337_BIT_A1I\t\t0x01\n#define DS1339_REG_ALARM1_SECS\t0x07\n\n#define DS13XX_TRICKLE_CHARGER_MAGIC\t0xa0\n\n#define RX8025_REG_CTRL1\t0x0e\n#\tdefine RX8025_BIT_2412\t\t0x20\n#define RX8025_REG_CTRL2\t0x0f\n#\tdefine RX8025_BIT_PON\t\t0x10\n#\tdefine RX8025_BIT_VDET\t\t0x40\n#\tdefine RX8025_BIT_XST\t\t0x20\n\n#define RX8130_REG_ALARM_MIN\t\t0x17\n#define RX8130_REG_ALARM_HOUR\t\t0x18\n#define RX8130_REG_ALARM_WEEK_OR_DAY\t0x19\n#define RX8130_REG_EXTENSION\t\t0x1c\n#define RX8130_REG_EXTENSION_WADA\tBIT(3)\n#define RX8130_REG_FLAG\t\t\t0x1d\n#define RX8130_REG_FLAG_VLF\t\tBIT(1)\n#define RX8130_REG_FLAG_AF\t\tBIT(3)\n#define RX8130_REG_CONTROL0\t\t0x1e\n#define RX8130_REG_CONTROL0_AIE\t\tBIT(3)\n#define RX8130_REG_CONTROL1\t\t0x1f\n#define RX8130_REG_CONTROL1_INIEN\tBIT(4)\n#define RX8130_REG_CONTROL1_CHGEN\tBIT(5)\n\n#define MCP794XX_REG_CONTROL\t\t0x07\n#\tdefine MCP794XX_BIT_ALM0_EN\t0x10\n#\tdefine MCP794XX_BIT_ALM1_EN\t0x20\n#define MCP794XX_REG_ALARM0_BASE\t0x0a\n#define MCP794XX_REG_ALARM0_CTRL\t0x0d\n#define MCP794XX_REG_ALARM1_BASE\t0x11\n#define MCP794XX_REG_ALARM1_CTRL\t0x14\n#\tdefine MCP794XX_BIT_ALMX_IF\tBIT(3)\n#\tdefine MCP794XX_BIT_ALMX_C0\tBIT(4)\n#\tdefine MCP794XX_BIT_ALMX_C1\tBIT(5)\n#\tdefine MCP794XX_BIT_ALMX_C2\tBIT(6)\n#\tdefine MCP794XX_BIT_ALMX_POL\tBIT(7)\n#\tdefine MCP794XX_MSK_ALMX_MATCH\t(MCP794XX_BIT_ALMX_C0 | \\\n\t\t\t\t\t MCP794XX_BIT_ALMX_C1 | \\\n\t\t\t\t\t MCP794XX_BIT_ALMX_C2)\n\n#define M41TXX_REG_CONTROL\t0x07\n#\tdefine M41TXX_BIT_OUT\t\tBIT(7)\n#\tdefine M41TXX_BIT_FT\t\tBIT(6)\n#\tdefine M41TXX_BIT_CALIB_SIGN\tBIT(5)\n#\tdefine M41TXX_M_CALIBRATION\tGENMASK(4, 0)\n\n#define DS1388_REG_WDOG_HUN_SECS\t0x08\n#define DS1388_REG_WDOG_SECS\t\t0x09\n#define DS1388_REG_FLAG\t\t\t0x0b\n#\tdefine DS1388_BIT_WF\t\tBIT(6)\n#\tdefine DS1388_BIT_OSF\t\tBIT(7)\n#define DS1388_REG_CONTROL\t\t0x0c\n#\tdefine DS1388_BIT_RST\t\tBIT(0)\n#\tdefine DS1388_BIT_WDE\t\tBIT(1)\n#\tdefine DS1388_BIT_nEOSC\t\tBIT(7)\n\n \n#define M41TXX_NEG_OFFSET_STEP_PPB\t2034\n \n#define M41TXX_POS_OFFSET_STEP_PPB\t4068\n \n#define M41TXX_MIN_OFFSET\t((-31) * M41TXX_NEG_OFFSET_STEP_PPB)\n#define M41TXX_MAX_OFFSET\t((31) * M41TXX_POS_OFFSET_STEP_PPB)\n\nstruct ds1307 {\n\tenum ds_type\t\ttype;\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\tconst char\t\t*name;\n\tstruct rtc_device\t*rtc;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw\t\tclks[2];\n#endif\n};\n\nstruct chip_desc {\n\tunsigned\t\talarm:1;\n\tu16\t\t\tnvram_offset;\n\tu16\t\t\tnvram_size;\n\tu8\t\t\toffset;  \n\tu8\t\t\tcentury_reg;\n\tu8\t\t\tcentury_enable_bit;\n\tu8\t\t\tcentury_bit;\n\tu8\t\t\tbbsqi_bit;\n\tirq_handler_t\t\tirq_handler;\n\tconst struct rtc_class_ops *rtc_ops;\n\tu16\t\t\ttrickle_charger_reg;\n\tu8\t\t\t(*do_trickle_setup)(struct ds1307 *, u32,\n\t\t\t\t\t\t    bool);\n\t \n\tbool\t\t\trequires_trickle_resistor;\n\t \n\tbool\t\t\tcharge_default;\n};\n\nstatic const struct chip_desc chips[last_ds_type];\n\nstatic int ds1307_get_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct ds1307\t*ds1307 = dev_get_drvdata(dev);\n\tint\t\ttmp, ret;\n\tconst struct chip_desc *chip = &chips[ds1307->type];\n\tu8 regs[7];\n\n\tif (ds1307->type == rx_8130) {\n\t\tunsigned int regflag;\n\t\tret = regmap_read(ds1307->regmap, RX8130_REG_FLAG, &regflag);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s error %d\\n\", \"read\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (regflag & RX8130_REG_FLAG_VLF) {\n\t\t\tdev_warn_once(dev, \"oscillator failed, set time!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, chip->offset, regs,\n\t\t\t       sizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"read\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%s: %7ph\\n\", \"read\", regs);\n\n\t \n\tif (ds1307->type == m41t0 &&\n\t    regs[DS1307_REG_MIN] & M41T0_BIT_OF) {\n\t\tdev_warn_once(dev, \"oscillator failed, set time!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = regs[DS1307_REG_SECS];\n\tswitch (ds1307->type) {\n\tcase ds_1307:\n\tcase m41t0:\n\tcase m41t00:\n\tcase m41t11:\n\t\tif (tmp & DS1307_BIT_CH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ds_1308:\n\tcase ds_1338:\n\t\tif (tmp & DS1307_BIT_CH)\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_read(ds1307->regmap, DS1307_REG_CONTROL, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tmp & DS1338_BIT_OSF)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ds_1340:\n\t\tif (tmp & DS1340_BIT_nEOSC)\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_read(ds1307->regmap, DS1340_REG_FLAG, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tmp & DS1340_BIT_OSF)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ds_1388:\n\t\tret = regmap_read(ds1307->regmap, DS1388_REG_FLAG, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tmp & DS1388_BIT_OSF)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase mcp794xx:\n\t\tif (!(tmp & MCP794XX_BIT_ST))\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt->tm_sec = bcd2bin(regs[DS1307_REG_SECS] & 0x7f);\n\tt->tm_min = bcd2bin(regs[DS1307_REG_MIN] & 0x7f);\n\ttmp = regs[DS1307_REG_HOUR] & 0x3f;\n\tt->tm_hour = bcd2bin(tmp);\n\t \n\tif (ds1307->type == rx_8130)\n\t\tt->tm_wday = fls(regs[DS1307_REG_WDAY] & 0x7f);\n\telse\n\t\tt->tm_wday = bcd2bin(regs[DS1307_REG_WDAY] & 0x07) - 1;\n\tt->tm_mday = bcd2bin(regs[DS1307_REG_MDAY] & 0x3f);\n\ttmp = regs[DS1307_REG_MONTH] & 0x1f;\n\tt->tm_mon = bcd2bin(tmp) - 1;\n\tt->tm_year = bcd2bin(regs[DS1307_REG_YEAR]) + 100;\n\n\tif (regs[chip->century_reg] & chip->century_bit &&\n\t    IS_ENABLED(CONFIG_RTC_DRV_DS1307_CENTURY))\n\t\tt->tm_year += 100;\n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"read\", t->tm_sec, t->tm_min,\n\t\tt->tm_hour, t->tm_mday,\n\t\tt->tm_mon, t->tm_year, t->tm_wday);\n\n\treturn 0;\n}\n\nstatic int ds1307_set_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct ds1307\t*ds1307 = dev_get_drvdata(dev);\n\tconst struct chip_desc *chip = &chips[ds1307->type];\n\tint\t\tresult;\n\tint\t\ttmp;\n\tu8\t\tregs[7];\n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"write\", t->tm_sec, t->tm_min,\n\t\tt->tm_hour, t->tm_mday,\n\t\tt->tm_mon, t->tm_year, t->tm_wday);\n\n\tif (t->tm_year < 100)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_RTC_DRV_DS1307_CENTURY\n\tif (t->tm_year > (chip->century_bit ? 299 : 199))\n\t\treturn -EINVAL;\n#else\n\tif (t->tm_year > 199)\n\t\treturn -EINVAL;\n#endif\n\n\tregs[DS1307_REG_SECS] = bin2bcd(t->tm_sec);\n\tregs[DS1307_REG_MIN] = bin2bcd(t->tm_min);\n\tregs[DS1307_REG_HOUR] = bin2bcd(t->tm_hour);\n\t \n\tif (ds1307->type == rx_8130)\n\t\tregs[DS1307_REG_WDAY] = 1 << t->tm_wday;\n\telse\n\t\tregs[DS1307_REG_WDAY] = bin2bcd(t->tm_wday + 1);\n\tregs[DS1307_REG_MDAY] = bin2bcd(t->tm_mday);\n\tregs[DS1307_REG_MONTH] = bin2bcd(t->tm_mon + 1);\n\n\t \n\ttmp = t->tm_year - 100;\n\tregs[DS1307_REG_YEAR] = bin2bcd(tmp);\n\n\tif (chip->century_enable_bit)\n\t\tregs[chip->century_reg] |= chip->century_enable_bit;\n\tif (t->tm_year > 199 && chip->century_bit)\n\t\tregs[chip->century_reg] |= chip->century_bit;\n\n\tswitch (ds1307->type) {\n\tcase ds_1308:\n\tcase ds_1338:\n\t\tregmap_update_bits(ds1307->regmap, DS1307_REG_CONTROL,\n\t\t\t\t   DS1338_BIT_OSF, 0);\n\t\tbreak;\n\tcase ds_1340:\n\t\tregmap_update_bits(ds1307->regmap, DS1340_REG_FLAG,\n\t\t\t\t   DS1340_BIT_OSF, 0);\n\t\tbreak;\n\tcase ds_1388:\n\t\tregmap_update_bits(ds1307->regmap, DS1388_REG_FLAG,\n\t\t\t\t   DS1388_BIT_OSF, 0);\n\t\tbreak;\n\tcase mcp794xx:\n\t\t \n\t\tregs[DS1307_REG_SECS] |= MCP794XX_BIT_ST;\n\t\tregs[DS1307_REG_WDAY] |= MCP794XX_BIT_VBATEN;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"%s: %7ph\\n\", \"write\", regs);\n\n\tresult = regmap_bulk_write(ds1307->regmap, chip->offset, regs,\n\t\t\t\t   sizeof(regs));\n\tif (result) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"write\", result);\n\t\treturn result;\n\t}\n\n\tif (ds1307->type == rx_8130) {\n\t\t \n\t\tresult = regmap_write(ds1307->regmap, RX8130_REG_FLAG,\n\t\t\t\t      ~(u8)RX8130_REG_FLAG_VLF);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"%s error %d\\n\", \"write\", result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ds1337_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307\t\t*ds1307 = dev_get_drvdata(dev);\n\tint\t\t\tret;\n\tu8\t\t\tregs[9];\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, DS1339_REG_ALARM1_SECS,\n\t\t\t       regs, sizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"alarm read\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%s: %4ph, %3ph, %2ph\\n\", \"alarm read\",\n\t\t&regs[0], &regs[4], &regs[7]);\n\n\t \n\tt->time.tm_sec = bcd2bin(regs[0] & 0x7f);\n\tt->time.tm_min = bcd2bin(regs[1] & 0x7f);\n\tt->time.tm_hour = bcd2bin(regs[2] & 0x3f);\n\tt->time.tm_mday = bcd2bin(regs[3] & 0x3f);\n\n\t \n\tt->enabled = !!(regs[7] & DS1337_BIT_A1IE);\n\tt->pending = !!(regs[8] & DS1337_BIT_A1I);\n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, enabled=%d, pending=%d\\n\",\n\t\t\"alarm read\", t->time.tm_sec, t->time.tm_min,\n\t\tt->time.tm_hour, t->time.tm_mday,\n\t\tt->enabled, t->pending);\n\n\treturn 0;\n}\n\nstatic int ds1337_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307\t\t*ds1307 = dev_get_drvdata(dev);\n\tunsigned char\t\tregs[9];\n\tu8\t\t\tcontrol, status;\n\tint\t\t\tret;\n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, enabled=%d, pending=%d\\n\",\n\t\t\"alarm set\", t->time.tm_sec, t->time.tm_min,\n\t\tt->time.tm_hour, t->time.tm_mday,\n\t\tt->enabled, t->pending);\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, DS1339_REG_ALARM1_SECS, regs,\n\t\t\t       sizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"alarm write\", ret);\n\t\treturn ret;\n\t}\n\tcontrol = regs[7];\n\tstatus = regs[8];\n\n\tdev_dbg(dev, \"%s: %4ph, %3ph, %02x %02x\\n\", \"alarm set (old status)\",\n\t\t&regs[0], &regs[4], control, status);\n\n\t \n\tregs[0] = bin2bcd(t->time.tm_sec);\n\tregs[1] = bin2bcd(t->time.tm_min);\n\tregs[2] = bin2bcd(t->time.tm_hour);\n\tregs[3] = bin2bcd(t->time.tm_mday);\n\n\t \n\tregs[4] = 0;\n\tregs[5] = 0;\n\tregs[6] = 0;\n\n\t \n\tregs[7] = control & ~(DS1337_BIT_A1IE | DS1337_BIT_A2IE);\n\tregs[8] = status & ~(DS1337_BIT_A1I | DS1337_BIT_A2I);\n\n\tret = regmap_bulk_write(ds1307->regmap, DS1339_REG_ALARM1_SECS, regs,\n\t\t\t\tsizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"can't set alarm time\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (t->enabled) {\n\t\tdev_dbg(dev, \"alarm IRQ armed\\n\");\n\t\tregs[7] |= DS1337_BIT_A1IE;\t \n\t\tregmap_write(ds1307->regmap, DS1337_REG_CONTROL, regs[7]);\n\t}\n\n\treturn 0;\n}\n\nstatic int ds1307_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1307\t\t*ds1307 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t\t  DS1337_BIT_A1IE,\n\t\t\t\t  enabled ? DS1337_BIT_A1IE : 0);\n}\n\nstatic u8 do_trickle_setup_ds1339(struct ds1307 *ds1307, u32 ohms, bool diode)\n{\n\tu8 setup = (diode) ? DS1307_TRICKLE_CHARGER_DIODE :\n\t\tDS1307_TRICKLE_CHARGER_NO_DIODE;\n\n\tsetup |= DS13XX_TRICKLE_CHARGER_MAGIC;\n\n\tswitch (ohms) {\n\tcase 250:\n\t\tsetup |= DS1307_TRICKLE_CHARGER_250_OHM;\n\t\tbreak;\n\tcase 2000:\n\t\tsetup |= DS1307_TRICKLE_CHARGER_2K_OHM;\n\t\tbreak;\n\tcase 4000:\n\t\tsetup |= DS1307_TRICKLE_CHARGER_4K_OHM;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(ds1307->dev,\n\t\t\t \"Unsupported ohm value %u in dt\\n\", ohms);\n\t\treturn 0;\n\t}\n\treturn setup;\n}\n\nstatic u8 do_trickle_setup_rx8130(struct ds1307 *ds1307, u32 ohms, bool diode)\n{\n\t \n\tu8 setup = RX8130_REG_CONTROL1_INIEN;\n\tif (diode)\n\t\tsetup |= RX8130_REG_CONTROL1_CHGEN;\n\n\treturn setup;\n}\n\nstatic irqreturn_t rx8130_irq(int irq, void *dev_id)\n{\n\tstruct ds1307           *ds1307 = dev_id;\n\tu8 ctl[3];\n\tint ret;\n\n\trtc_lock(ds1307->rtc);\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, RX8130_REG_EXTENSION, ctl,\n\t\t\t       sizeof(ctl));\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!(ctl[1] & RX8130_REG_FLAG_AF))\n\t\tgoto out;\n\tctl[1] &= ~RX8130_REG_FLAG_AF;\n\tctl[2] &= ~RX8130_REG_CONTROL0_AIE;\n\n\tret = regmap_bulk_write(ds1307->regmap, RX8130_REG_EXTENSION, ctl,\n\t\t\t\tsizeof(ctl));\n\tif (ret < 0)\n\t\tgoto out;\n\n\trtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\n\nout:\n\trtc_unlock(ds1307->rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rx8130_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tu8 ald[3], ctl[3];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, RX8130_REG_ALARM_MIN, ald,\n\t\t\t       sizeof(ald));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, RX8130_REG_EXTENSION, ctl,\n\t\t\t       sizeof(ctl));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tt->enabled = !!(ctl[2] & RX8130_REG_CONTROL0_AIE);\n\tt->pending = !!(ctl[1] & RX8130_REG_FLAG_AF);\n\n\t \n\tt->time.tm_sec = -1;\n\tt->time.tm_min = bcd2bin(ald[0] & 0x7f);\n\tt->time.tm_hour = bcd2bin(ald[1] & 0x7f);\n\tt->time.tm_wday = -1;\n\tt->time.tm_mday = bcd2bin(ald[2] & 0x7f);\n\tt->time.tm_mon = -1;\n\tt->time.tm_year = -1;\n\tt->time.tm_yday = -1;\n\tt->time.tm_isdst = -1;\n\n\tdev_dbg(dev, \"%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d enabled=%d\\n\",\n\t\t__func__, t->time.tm_sec, t->time.tm_min, t->time.tm_hour,\n\t\tt->time.tm_wday, t->time.tm_mday, t->time.tm_mon, t->enabled);\n\n\treturn 0;\n}\n\nstatic int rx8130_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tu8 ald[3], ctl[3];\n\tint ret;\n\n\tdev_dbg(dev, \"%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d \"\n\t\t\"enabled=%d pending=%d\\n\", __func__,\n\t\tt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\n\t\tt->time.tm_wday, t->time.tm_mday, t->time.tm_mon,\n\t\tt->enabled, t->pending);\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, RX8130_REG_EXTENSION, ctl,\n\t\t\t       sizeof(ctl));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctl[0] &= RX8130_REG_EXTENSION_WADA;\n\tctl[1] &= ~RX8130_REG_FLAG_AF;\n\tctl[2] &= ~RX8130_REG_CONTROL0_AIE;\n\n\tret = regmap_bulk_write(ds1307->regmap, RX8130_REG_EXTENSION, ctl,\n\t\t\t\tsizeof(ctl));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tald[0] = bin2bcd(t->time.tm_min);\n\tald[1] = bin2bcd(t->time.tm_hour);\n\tald[2] = bin2bcd(t->time.tm_mday);\n\n\tret = regmap_bulk_write(ds1307->regmap, RX8130_REG_ALARM_MIN, ald,\n\t\t\t\tsizeof(ald));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!t->enabled)\n\t\treturn 0;\n\n\tctl[2] |= RX8130_REG_CONTROL0_AIE;\n\n\treturn regmap_write(ds1307->regmap, RX8130_REG_CONTROL0, ctl[2]);\n}\n\nstatic int rx8130_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tint ret, reg;\n\n\tret = regmap_read(ds1307->regmap, RX8130_REG_CONTROL0, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enabled)\n\t\treg |= RX8130_REG_CONTROL0_AIE;\n\telse\n\t\treg &= ~RX8130_REG_CONTROL0_AIE;\n\n\treturn regmap_write(ds1307->regmap, RX8130_REG_CONTROL0, reg);\n}\n\nstatic irqreturn_t mcp794xx_irq(int irq, void *dev_id)\n{\n\tstruct ds1307           *ds1307 = dev_id;\n\tstruct mutex            *lock = &ds1307->rtc->ops_lock;\n\tint reg, ret;\n\n\tmutex_lock(lock);\n\n\t \n\tret = regmap_read(ds1307->regmap, MCP794XX_REG_ALARM0_CTRL, &reg);\n\tif (ret)\n\t\tgoto out;\n\tif (!(reg & MCP794XX_BIT_ALMX_IF))\n\t\tgoto out;\n\treg &= ~MCP794XX_BIT_ALMX_IF;\n\tret = regmap_write(ds1307->regmap, MCP794XX_REG_ALARM0_CTRL, reg);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_update_bits(ds1307->regmap, MCP794XX_REG_CONTROL,\n\t\t\t\t MCP794XX_BIT_ALM0_EN, 0);\n\tif (ret)\n\t\tgoto out;\n\n\trtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\n\nout:\n\tmutex_unlock(lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mcp794xx_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tu8 regs[10];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, MCP794XX_REG_CONTROL, regs,\n\t\t\t       sizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\tt->enabled = !!(regs[0] & MCP794XX_BIT_ALM0_EN);\n\n\t \n\tt->time.tm_sec = bcd2bin(regs[3] & 0x7f);\n\tt->time.tm_min = bcd2bin(regs[4] & 0x7f);\n\tt->time.tm_hour = bcd2bin(regs[5] & 0x3f);\n\tt->time.tm_wday = bcd2bin(regs[6] & 0x7) - 1;\n\tt->time.tm_mday = bcd2bin(regs[7] & 0x3f);\n\tt->time.tm_mon = bcd2bin(regs[8] & 0x1f) - 1;\n\tt->time.tm_year = -1;\n\tt->time.tm_yday = -1;\n\tt->time.tm_isdst = -1;\n\n\tdev_dbg(dev, \"%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d \"\n\t\t\"enabled=%d polarity=%d irq=%d match=%lu\\n\", __func__,\n\t\tt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\n\t\tt->time.tm_wday, t->time.tm_mday, t->time.tm_mon, t->enabled,\n\t\t!!(regs[6] & MCP794XX_BIT_ALMX_POL),\n\t\t!!(regs[6] & MCP794XX_BIT_ALMX_IF),\n\t\t(regs[6] & MCP794XX_MSK_ALMX_MATCH) >> 4);\n\n\treturn 0;\n}\n\n \nstatic int mcp794xx_alm_weekday(struct device *dev, struct rtc_time *tm_alarm)\n{\n\tstruct rtc_time tm_now;\n\tint days_now, days_alarm, ret;\n\n\tret = ds1307_get_time(dev, &tm_now);\n\tif (ret)\n\t\treturn ret;\n\n\tdays_now = div_s64(rtc_tm_to_time64(&tm_now), 24 * 60 * 60);\n\tdays_alarm = div_s64(rtc_tm_to_time64(tm_alarm), 24 * 60 * 60);\n\n\treturn (tm_now.tm_wday + days_alarm - days_now) % 7 + 1;\n}\n\nstatic int mcp794xx_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tunsigned char regs[10];\n\tint wday, ret;\n\n\twday = mcp794xx_alm_weekday(dev, &t->time);\n\tif (wday < 0)\n\t\treturn wday;\n\n\tdev_dbg(dev, \"%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d \"\n\t\t\"enabled=%d pending=%d\\n\", __func__,\n\t\tt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\n\t\tt->time.tm_wday, t->time.tm_mday, t->time.tm_mon,\n\t\tt->enabled, t->pending);\n\n\t \n\tret = regmap_bulk_read(ds1307->regmap, MCP794XX_REG_CONTROL, regs,\n\t\t\t       sizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregs[3] = bin2bcd(t->time.tm_sec);\n\tregs[4] = bin2bcd(t->time.tm_min);\n\tregs[5] = bin2bcd(t->time.tm_hour);\n\tregs[6] = wday;\n\tregs[7] = bin2bcd(t->time.tm_mday);\n\tregs[8] = bin2bcd(t->time.tm_mon + 1);\n\n\t \n\tregs[6] &= ~MCP794XX_BIT_ALMX_IF;\n\t \n\tregs[6] |= MCP794XX_MSK_ALMX_MATCH;\n\t \n\tregs[0] &= ~MCP794XX_BIT_ALM0_EN;\n\n\tret = regmap_bulk_write(ds1307->regmap, MCP794XX_REG_CONTROL, regs,\n\t\t\t\tsizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!t->enabled)\n\t\treturn 0;\n\tregs[0] |= MCP794XX_BIT_ALM0_EN;\n\treturn regmap_write(ds1307->regmap, MCP794XX_REG_CONTROL, regs[0]);\n}\n\nstatic int mcp794xx_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(ds1307->regmap, MCP794XX_REG_CONTROL,\n\t\t\t\t  MCP794XX_BIT_ALM0_EN,\n\t\t\t\t  enabled ? MCP794XX_BIT_ALM0_EN : 0);\n}\n\nstatic int m41txx_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tunsigned int ctrl_reg;\n\tu8 val;\n\n\tregmap_read(ds1307->regmap, M41TXX_REG_CONTROL, &ctrl_reg);\n\n\tval = ctrl_reg & M41TXX_M_CALIBRATION;\n\n\t \n\tif (ctrl_reg & M41TXX_BIT_CALIB_SIGN)\n\t\t*offset = (val * M41TXX_POS_OFFSET_STEP_PPB);\n\telse\n\t\t*offset = -(val * M41TXX_NEG_OFFSET_STEP_PPB);\n\n\treturn 0;\n}\n\nstatic int m41txx_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tunsigned int ctrl_reg;\n\n\tif ((offset < M41TXX_MIN_OFFSET) || (offset > M41TXX_MAX_OFFSET))\n\t\treturn -ERANGE;\n\n\tif (offset >= 0) {\n\t\tctrl_reg = DIV_ROUND_CLOSEST(offset,\n\t\t\t\t\t     M41TXX_POS_OFFSET_STEP_PPB);\n\t\tctrl_reg |= M41TXX_BIT_CALIB_SIGN;\n\t} else {\n\t\tctrl_reg = DIV_ROUND_CLOSEST(abs(offset),\n\t\t\t\t\t     M41TXX_NEG_OFFSET_STEP_PPB);\n\t}\n\n\treturn regmap_update_bits(ds1307->regmap, M41TXX_REG_CONTROL,\n\t\t\t\t  M41TXX_M_CALIBRATION | M41TXX_BIT_CALIB_SIGN,\n\t\t\t\t  ctrl_reg);\n}\n\n#ifdef CONFIG_WATCHDOG_CORE\nstatic int ds1388_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct ds1307 *ds1307 = watchdog_get_drvdata(wdt_dev);\n\tu8 regs[2];\n\tint ret;\n\n\tret = regmap_update_bits(ds1307->regmap, DS1388_REG_FLAG,\n\t\t\t\t DS1388_BIT_WF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(ds1307->regmap, DS1388_REG_CONTROL,\n\t\t\t\t DS1388_BIT_WDE | DS1388_BIT_RST, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregs[0] = 0;\n\tregs[1] = bin2bcd(wdt_dev->timeout);\n\n\tret = regmap_bulk_write(ds1307->regmap, DS1388_REG_WDOG_HUN_SECS, regs,\n\t\t\t\tsizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(ds1307->regmap, DS1388_REG_CONTROL,\n\t\t\t\t  DS1388_BIT_WDE | DS1388_BIT_RST,\n\t\t\t\t  DS1388_BIT_WDE | DS1388_BIT_RST);\n}\n\nstatic int ds1388_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct ds1307 *ds1307 = watchdog_get_drvdata(wdt_dev);\n\n\treturn regmap_update_bits(ds1307->regmap, DS1388_REG_CONTROL,\n\t\t\t\t  DS1388_BIT_WDE | DS1388_BIT_RST, 0);\n}\n\nstatic int ds1388_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct ds1307 *ds1307 = watchdog_get_drvdata(wdt_dev);\n\tu8 regs[2];\n\n\treturn regmap_bulk_read(ds1307->regmap, DS1388_REG_WDOG_HUN_SECS, regs,\n\t\t\t\tsizeof(regs));\n}\n\nstatic int ds1388_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t  unsigned int val)\n{\n\tstruct ds1307 *ds1307 = watchdog_get_drvdata(wdt_dev);\n\tu8 regs[2];\n\n\twdt_dev->timeout = val;\n\tregs[0] = 0;\n\tregs[1] = bin2bcd(wdt_dev->timeout);\n\n\treturn regmap_bulk_write(ds1307->regmap, DS1388_REG_WDOG_HUN_SECS, regs,\n\t\t\t\t sizeof(regs));\n}\n#endif\n\nstatic const struct rtc_class_ops rx8130_rtc_ops = {\n\t.read_time      = ds1307_get_time,\n\t.set_time       = ds1307_set_time,\n\t.read_alarm     = rx8130_read_alarm,\n\t.set_alarm      = rx8130_set_alarm,\n\t.alarm_irq_enable = rx8130_alarm_irq_enable,\n};\n\nstatic const struct rtc_class_ops mcp794xx_rtc_ops = {\n\t.read_time      = ds1307_get_time,\n\t.set_time       = ds1307_set_time,\n\t.read_alarm     = mcp794xx_read_alarm,\n\t.set_alarm      = mcp794xx_set_alarm,\n\t.alarm_irq_enable = mcp794xx_alarm_irq_enable,\n};\n\nstatic const struct rtc_class_ops m41txx_rtc_ops = {\n\t.read_time      = ds1307_get_time,\n\t.set_time       = ds1307_set_time,\n\t.read_alarm\t= ds1337_read_alarm,\n\t.set_alarm\t= ds1337_set_alarm,\n\t.alarm_irq_enable = ds1307_alarm_irq_enable,\n\t.read_offset\t= m41txx_rtc_read_offset,\n\t.set_offset\t= m41txx_rtc_set_offset,\n};\n\nstatic const struct chip_desc chips[last_ds_type] = {\n\t[ds_1307] = {\n\t\t.nvram_offset\t= 8,\n\t\t.nvram_size\t= 56,\n\t},\n\t[ds_1308] = {\n\t\t.nvram_offset\t= 8,\n\t\t.nvram_size\t= 56,\n\t},\n\t[ds_1337] = {\n\t\t.alarm\t\t= 1,\n\t\t.century_reg\t= DS1307_REG_MONTH,\n\t\t.century_bit\t= DS1337_BIT_CENTURY,\n\t},\n\t[ds_1338] = {\n\t\t.nvram_offset\t= 8,\n\t\t.nvram_size\t= 56,\n\t},\n\t[ds_1339] = {\n\t\t.alarm\t\t= 1,\n\t\t.century_reg\t= DS1307_REG_MONTH,\n\t\t.century_bit\t= DS1337_BIT_CENTURY,\n\t\t.bbsqi_bit\t= DS1339_BIT_BBSQI,\n\t\t.trickle_charger_reg = 0x10,\n\t\t.do_trickle_setup = &do_trickle_setup_ds1339,\n\t\t.requires_trickle_resistor = true,\n\t\t.charge_default = true,\n\t},\n\t[ds_1340] = {\n\t\t.century_reg\t= DS1307_REG_HOUR,\n\t\t.century_enable_bit = DS1340_BIT_CENTURY_EN,\n\t\t.century_bit\t= DS1340_BIT_CENTURY,\n\t\t.do_trickle_setup = &do_trickle_setup_ds1339,\n\t\t.trickle_charger_reg = 0x08,\n\t\t.requires_trickle_resistor = true,\n\t\t.charge_default = true,\n\t},\n\t[ds_1341] = {\n\t\t.century_reg\t= DS1307_REG_MONTH,\n\t\t.century_bit\t= DS1337_BIT_CENTURY,\n\t},\n\t[ds_1388] = {\n\t\t.offset\t\t= 1,\n\t\t.trickle_charger_reg = 0x0a,\n\t},\n\t[ds_3231] = {\n\t\t.alarm\t\t= 1,\n\t\t.century_reg\t= DS1307_REG_MONTH,\n\t\t.century_bit\t= DS1337_BIT_CENTURY,\n\t\t.bbsqi_bit\t= DS3231_BIT_BBSQW,\n\t},\n\t[rx_8130] = {\n\t\t.alarm\t\t= 1,\n\t\t \n\t\t.nvram_offset\t= 0x20,\n\t\t.nvram_size\t= 4,\t \n\t\t.offset\t\t= 0x10,\n\t\t.irq_handler = rx8130_irq,\n\t\t.rtc_ops = &rx8130_rtc_ops,\n\t\t.trickle_charger_reg = RX8130_REG_CONTROL1,\n\t\t.do_trickle_setup = &do_trickle_setup_rx8130,\n\t},\n\t[m41t0] = {\n\t\t.rtc_ops\t= &m41txx_rtc_ops,\n\t},\n\t[m41t00] = {\n\t\t.rtc_ops\t= &m41txx_rtc_ops,\n\t},\n\t[m41t11] = {\n\t\t \n\t\t.nvram_offset\t= 8,\n\t\t.nvram_size\t= 56,\n\t\t.rtc_ops\t= &m41txx_rtc_ops,\n\t},\n\t[mcp794xx] = {\n\t\t.alarm\t\t= 1,\n\t\t \n\t\t.nvram_offset\t= 0x20,\n\t\t.nvram_size\t= 0x40,\n\t\t.irq_handler = mcp794xx_irq,\n\t\t.rtc_ops = &mcp794xx_rtc_ops,\n\t},\n};\n\nstatic const struct i2c_device_id ds1307_id[] = {\n\t{ \"ds1307\", ds_1307 },\n\t{ \"ds1308\", ds_1308 },\n\t{ \"ds1337\", ds_1337 },\n\t{ \"ds1338\", ds_1338 },\n\t{ \"ds1339\", ds_1339 },\n\t{ \"ds1388\", ds_1388 },\n\t{ \"ds1340\", ds_1340 },\n\t{ \"ds1341\", ds_1341 },\n\t{ \"ds3231\", ds_3231 },\n\t{ \"m41t0\", m41t0 },\n\t{ \"m41t00\", m41t00 },\n\t{ \"m41t11\", m41t11 },\n\t{ \"mcp7940x\", mcp794xx },\n\t{ \"mcp7941x\", mcp794xx },\n\t{ \"pt7c4338\", ds_1307 },\n\t{ \"rx8025\", rx_8025 },\n\t{ \"isl12057\", ds_1337 },\n\t{ \"rx8130\", rx_8130 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds1307_id);\n\nstatic const struct of_device_id ds1307_of_match[] = {\n\t{\n\t\t.compatible = \"dallas,ds1307\",\n\t\t.data = (void *)ds_1307\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1308\",\n\t\t.data = (void *)ds_1308\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1337\",\n\t\t.data = (void *)ds_1337\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1338\",\n\t\t.data = (void *)ds_1338\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1339\",\n\t\t.data = (void *)ds_1339\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1388\",\n\t\t.data = (void *)ds_1388\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1340\",\n\t\t.data = (void *)ds_1340\n\t},\n\t{\n\t\t.compatible = \"dallas,ds1341\",\n\t\t.data = (void *)ds_1341\n\t},\n\t{\n\t\t.compatible = \"maxim,ds3231\",\n\t\t.data = (void *)ds_3231\n\t},\n\t{\n\t\t.compatible = \"st,m41t0\",\n\t\t.data = (void *)m41t0\n\t},\n\t{\n\t\t.compatible = \"st,m41t00\",\n\t\t.data = (void *)m41t00\n\t},\n\t{\n\t\t.compatible = \"st,m41t11\",\n\t\t.data = (void *)m41t11\n\t},\n\t{\n\t\t.compatible = \"microchip,mcp7940x\",\n\t\t.data = (void *)mcp794xx\n\t},\n\t{\n\t\t.compatible = \"microchip,mcp7941x\",\n\t\t.data = (void *)mcp794xx\n\t},\n\t{\n\t\t.compatible = \"pericom,pt7c4338\",\n\t\t.data = (void *)ds_1307\n\t},\n\t{\n\t\t.compatible = \"epson,rx8025\",\n\t\t.data = (void *)rx_8025\n\t},\n\t{\n\t\t.compatible = \"isil,isl12057\",\n\t\t.data = (void *)ds_1337\n\t},\n\t{\n\t\t.compatible = \"epson,rx8130\",\n\t\t.data = (void *)rx_8130\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ds1307_of_match);\n\n \nstatic irqreturn_t ds1307_irq(int irq, void *dev_id)\n{\n\tstruct ds1307\t\t*ds1307 = dev_id;\n\tstruct mutex\t\t*lock = &ds1307->rtc->ops_lock;\n\tint\t\t\tstat, ret;\n\n\tmutex_lock(lock);\n\tret = regmap_read(ds1307->regmap, DS1337_REG_STATUS, &stat);\n\tif (ret)\n\t\tgoto out;\n\n\tif (stat & DS1337_BIT_A1I) {\n\t\tstat &= ~DS1337_BIT_A1I;\n\t\tregmap_write(ds1307->regmap, DS1337_REG_STATUS, stat);\n\n\t\tret = regmap_update_bits(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t\t\t DS1337_BIT_A1IE, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\trtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\n\t}\n\nout:\n\tmutex_unlock(lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic const struct rtc_class_ops ds13xx_rtc_ops = {\n\t.read_time\t= ds1307_get_time,\n\t.set_time\t= ds1307_set_time,\n\t.read_alarm\t= ds1337_read_alarm,\n\t.set_alarm\t= ds1337_set_alarm,\n\t.alarm_irq_enable = ds1307_alarm_irq_enable,\n};\n\nstatic ssize_t frequency_test_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev->parent);\n\tbool freq_test_en;\n\tint ret;\n\n\tret = kstrtobool(buf, &freq_test_en);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to store RTC Frequency Test attribute\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(ds1307->regmap, M41TXX_REG_CONTROL, M41TXX_BIT_FT,\n\t\t\t   freq_test_en ? M41TXX_BIT_FT : 0);\n\n\treturn count;\n}\n\nstatic ssize_t frequency_test_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev->parent);\n\tunsigned int ctrl_reg;\n\n\tregmap_read(ds1307->regmap, M41TXX_REG_CONTROL, &ctrl_reg);\n\n\treturn sysfs_emit(buf, (ctrl_reg & M41TXX_BIT_FT) ? \"on\\n\" : \"off\\n\");\n}\n\nstatic DEVICE_ATTR_RW(frequency_test);\n\nstatic struct attribute *rtc_freq_test_attrs[] = {\n\t&dev_attr_frequency_test.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtc_freq_test_attr_group = {\n\t.attrs\t\t= rtc_freq_test_attrs,\n};\n\nstatic int ds1307_add_frequency_test(struct ds1307 *ds1307)\n{\n\tint err;\n\n\tswitch (ds1307->type) {\n\tcase m41t0:\n\tcase m41t00:\n\tcase m41t11:\n\t\terr = rtc_add_group(ds1307->rtc, &rtc_freq_test_attr_group);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int ds1307_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct ds1307 *ds1307 = priv;\n\tconst struct chip_desc *chip = &chips[ds1307->type];\n\n\treturn regmap_bulk_read(ds1307->regmap, chip->nvram_offset + offset,\n\t\t\t\tval, bytes);\n}\n\nstatic int ds1307_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct ds1307 *ds1307 = priv;\n\tconst struct chip_desc *chip = &chips[ds1307->type];\n\n\treturn regmap_bulk_write(ds1307->regmap, chip->nvram_offset + offset,\n\t\t\t\t val, bytes);\n}\n\n \n\nstatic u8 ds1307_trickle_init(struct ds1307 *ds1307,\n\t\t\t      const struct chip_desc *chip)\n{\n\tu32 ohms, chargeable;\n\tbool diode = chip->charge_default;\n\n\tif (!chip->do_trickle_setup)\n\t\treturn 0;\n\n\tif (device_property_read_u32(ds1307->dev, \"trickle-resistor-ohms\",\n\t\t\t\t     &ohms) && chip->requires_trickle_resistor)\n\t\treturn 0;\n\n\t \n\tif (!device_property_read_u32(ds1307->dev, \"aux-voltage-chargeable\",\n\t\t\t\t     &chargeable)) {\n\t\tswitch (chargeable) {\n\t\tcase 0:\n\t\t\tdiode = false;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdiode = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(ds1307->dev,\n\t\t\t\t \"unsupported aux-voltage-chargeable value\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else if (device_property_read_bool(ds1307->dev,\n\t\t\t\t\t     \"trickle-diode-disable\")) {\n\t\tdiode = false;\n\t}\n\n\treturn chip->do_trickle_setup(ds1307, ohms, diode);\n}\n\n \n\n#if IS_REACHABLE(CONFIG_HWMON)\n\n \n\n#define DS3231_REG_TEMPERATURE\t0x11\n\n \nstatic int ds3231_hwmon_read_temp(struct device *dev, s32 *mC)\n{\n\tstruct ds1307 *ds1307 = dev_get_drvdata(dev);\n\tu8 temp_buf[2];\n\ts16 temp;\n\tint ret;\n\n\tret = regmap_bulk_read(ds1307->regmap, DS3231_REG_TEMPERATURE,\n\t\t\t       temp_buf, sizeof(temp_buf));\n\tif (ret)\n\t\treturn ret;\n\t \n\ttemp = (temp_buf[0] << 8) | temp_buf[1];\n\ttemp >>= 6;\n\t*mC = temp * 250;\n\n\treturn 0;\n}\n\nstatic ssize_t ds3231_hwmon_show_temp(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\ts32 temp;\n\n\tret = ds3231_hwmon_read_temp(dev, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, ds3231_hwmon_show_temp,\n\t\t\t  NULL, 0);\n\nstatic struct attribute *ds3231_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ds3231_hwmon);\n\nstatic void ds1307_hwmon_register(struct ds1307 *ds1307)\n{\n\tstruct device *dev;\n\n\tif (ds1307->type != ds_3231)\n\t\treturn;\n\n\tdev = devm_hwmon_device_register_with_groups(ds1307->dev, ds1307->name,\n\t\t\t\t\t\t     ds1307,\n\t\t\t\t\t\t     ds3231_hwmon_groups);\n\tif (IS_ERR(dev)) {\n\t\tdev_warn(ds1307->dev, \"unable to register hwmon device %ld\\n\",\n\t\t\t PTR_ERR(dev));\n\t}\n}\n\n#else\n\nstatic void ds1307_hwmon_register(struct ds1307 *ds1307)\n{\n}\n\n#endif  \n\n \n\n \n#ifdef CONFIG_COMMON_CLK\n\nenum {\n\tDS3231_CLK_SQW = 0,\n\tDS3231_CLK_32KHZ,\n};\n\n#define clk_sqw_to_ds1307(clk)\t\\\n\tcontainer_of(clk, struct ds1307, clks[DS3231_CLK_SQW])\n#define clk_32khz_to_ds1307(clk)\t\\\n\tcontainer_of(clk, struct ds1307, clks[DS3231_CLK_32KHZ])\n\nstatic int ds3231_clk_sqw_rates[] = {\n\t1,\n\t1024,\n\t4096,\n\t8192,\n};\n\nstatic int ds1337_write_control(struct ds1307 *ds1307, u8 mask, u8 value)\n{\n\tstruct mutex *lock = &ds1307->rtc->ops_lock;\n\tint ret;\n\n\tmutex_lock(lock);\n\tret = regmap_update_bits(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t\t mask, value);\n\tmutex_unlock(lock);\n\n\treturn ret;\n}\n\nstatic unsigned long ds3231_clk_sqw_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\n\tint control, ret;\n\tint rate_sel = 0;\n\n\tret = regmap_read(ds1307->regmap, DS1337_REG_CONTROL, &control);\n\tif (ret)\n\t\treturn ret;\n\tif (control & DS1337_BIT_RS1)\n\t\trate_sel += 1;\n\tif (control & DS1337_BIT_RS2)\n\t\trate_sel += 2;\n\n\treturn ds3231_clk_sqw_rates[rate_sel];\n}\n\nstatic long ds3231_clk_sqw_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = ARRAY_SIZE(ds3231_clk_sqw_rates) - 1; i >= 0; i--) {\n\t\tif (ds3231_clk_sqw_rates[i] <= rate)\n\t\t\treturn ds3231_clk_sqw_rates[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3231_clk_sqw_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\n\tint control = 0;\n\tint rate_sel;\n\n\tfor (rate_sel = 0; rate_sel < ARRAY_SIZE(ds3231_clk_sqw_rates);\n\t\t\trate_sel++) {\n\t\tif (ds3231_clk_sqw_rates[rate_sel] == rate)\n\t\t\tbreak;\n\t}\n\n\tif (rate_sel == ARRAY_SIZE(ds3231_clk_sqw_rates))\n\t\treturn -EINVAL;\n\n\tif (rate_sel & 1)\n\t\tcontrol |= DS1337_BIT_RS1;\n\tif (rate_sel & 2)\n\t\tcontrol |= DS1337_BIT_RS2;\n\n\treturn ds1337_write_control(ds1307, DS1337_BIT_RS1 | DS1337_BIT_RS2,\n\t\t\t\tcontrol);\n}\n\nstatic int ds3231_clk_sqw_prepare(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\n\n\treturn ds1337_write_control(ds1307, DS1337_BIT_INTCN, 0);\n}\n\nstatic void ds3231_clk_sqw_unprepare(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\n\n\tds1337_write_control(ds1307, DS1337_BIT_INTCN, DS1337_BIT_INTCN);\n}\n\nstatic int ds3231_clk_sqw_is_prepared(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\n\tint control, ret;\n\n\tret = regmap_read(ds1307->regmap, DS1337_REG_CONTROL, &control);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(control & DS1337_BIT_INTCN);\n}\n\nstatic const struct clk_ops ds3231_clk_sqw_ops = {\n\t.prepare = ds3231_clk_sqw_prepare,\n\t.unprepare = ds3231_clk_sqw_unprepare,\n\t.is_prepared = ds3231_clk_sqw_is_prepared,\n\t.recalc_rate = ds3231_clk_sqw_recalc_rate,\n\t.round_rate = ds3231_clk_sqw_round_rate,\n\t.set_rate = ds3231_clk_sqw_set_rate,\n};\n\nstatic unsigned long ds3231_clk_32khz_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t  unsigned long parent_rate)\n{\n\treturn 32768;\n}\n\nstatic int ds3231_clk_32khz_control(struct ds1307 *ds1307, bool enable)\n{\n\tstruct mutex *lock = &ds1307->rtc->ops_lock;\n\tint ret;\n\n\tmutex_lock(lock);\n\tret = regmap_update_bits(ds1307->regmap, DS1337_REG_STATUS,\n\t\t\t\t DS3231_BIT_EN32KHZ,\n\t\t\t\t enable ? DS3231_BIT_EN32KHZ : 0);\n\tmutex_unlock(lock);\n\n\treturn ret;\n}\n\nstatic int ds3231_clk_32khz_prepare(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\n\n\treturn ds3231_clk_32khz_control(ds1307, true);\n}\n\nstatic void ds3231_clk_32khz_unprepare(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\n\n\tds3231_clk_32khz_control(ds1307, false);\n}\n\nstatic int ds3231_clk_32khz_is_prepared(struct clk_hw *hw)\n{\n\tstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\n\tint status, ret;\n\n\tret = regmap_read(ds1307->regmap, DS1337_REG_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(status & DS3231_BIT_EN32KHZ);\n}\n\nstatic const struct clk_ops ds3231_clk_32khz_ops = {\n\t.prepare = ds3231_clk_32khz_prepare,\n\t.unprepare = ds3231_clk_32khz_unprepare,\n\t.is_prepared = ds3231_clk_32khz_is_prepared,\n\t.recalc_rate = ds3231_clk_32khz_recalc_rate,\n};\n\nstatic const char *ds3231_clks_names[] = {\n\t[DS3231_CLK_SQW] = \"ds3231_clk_sqw\",\n\t[DS3231_CLK_32KHZ] = \"ds3231_clk_32khz\",\n};\n\nstatic struct clk_init_data ds3231_clks_init[] = {\n\t[DS3231_CLK_SQW] = {\n\t\t.ops = &ds3231_clk_sqw_ops,\n\t},\n\t[DS3231_CLK_32KHZ] = {\n\t\t.ops = &ds3231_clk_32khz_ops,\n\t},\n};\n\nstatic int ds3231_clks_register(struct ds1307 *ds1307)\n{\n\tstruct device_node *node = ds1307->dev->of_node;\n\tstruct clk_onecell_data\t*onecell;\n\tint i;\n\n\tonecell = devm_kzalloc(ds1307->dev, sizeof(*onecell), GFP_KERNEL);\n\tif (!onecell)\n\t\treturn -ENOMEM;\n\n\tonecell->clk_num = ARRAY_SIZE(ds3231_clks_init);\n\tonecell->clks = devm_kcalloc(ds1307->dev, onecell->clk_num,\n\t\t\t\t     sizeof(onecell->clks[0]), GFP_KERNEL);\n\tif (!onecell->clks)\n\t\treturn -ENOMEM;\n\n\t \n\tdevice_property_read_string_array(ds1307->dev, \"clock-output-names\",\n\t\t\t\t\t  ds3231_clks_names,\n\t\t\t\t\t  ARRAY_SIZE(ds3231_clks_names));\n\n\tfor (i = 0; i < ARRAY_SIZE(ds3231_clks_init); i++) {\n\t\tstruct clk_init_data init = ds3231_clks_init[i];\n\n\t\t \n\t\tif (i == DS3231_CLK_SQW && test_bit(RTC_FEATURE_ALARM, ds1307->rtc->features))\n\t\t\tcontinue;\n\n\t\tinit.name = ds3231_clks_names[i];\n\t\tds1307->clks[i].init = &init;\n\n\t\tonecell->clks[i] = devm_clk_register(ds1307->dev,\n\t\t\t\t\t\t     &ds1307->clks[i]);\n\t\tif (IS_ERR(onecell->clks[i]))\n\t\t\treturn PTR_ERR(onecell->clks[i]);\n\t}\n\n\tif (node)\n\t\tof_clk_add_provider(node, of_clk_src_onecell_get, onecell);\n\n\treturn 0;\n}\n\nstatic void ds1307_clks_register(struct ds1307 *ds1307)\n{\n\tint ret;\n\n\tif (ds1307->type != ds_3231)\n\t\treturn;\n\n\tret = ds3231_clks_register(ds1307);\n\tif (ret) {\n\t\tdev_warn(ds1307->dev, \"unable to register clock device %d\\n\",\n\t\t\t ret);\n\t}\n}\n\n#else\n\nstatic void ds1307_clks_register(struct ds1307 *ds1307)\n{\n}\n\n#endif  \n\n#ifdef CONFIG_WATCHDOG_CORE\nstatic const struct watchdog_info ds1388_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"DS1388 watchdog\",\n};\n\nstatic const struct watchdog_ops ds1388_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = ds1388_wdt_start,\n\t.stop = ds1388_wdt_stop,\n\t.ping = ds1388_wdt_ping,\n\t.set_timeout = ds1388_wdt_set_timeout,\n\n};\n\nstatic void ds1307_wdt_register(struct ds1307 *ds1307)\n{\n\tstruct watchdog_device\t*wdt;\n\tint err;\n\tint val;\n\n\tif (ds1307->type != ds_1388)\n\t\treturn;\n\n\twdt = devm_kzalloc(ds1307->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn;\n\n\terr = regmap_read(ds1307->regmap, DS1388_REG_FLAG, &val);\n\tif (!err && val & DS1388_BIT_WF)\n\t\twdt->bootstatus = WDIOF_CARDRESET;\n\n\twdt->info = &ds1388_wdt_info;\n\twdt->ops = &ds1388_wdt_ops;\n\twdt->timeout = 99;\n\twdt->max_timeout = 99;\n\twdt->min_timeout = 1;\n\n\twatchdog_init_timeout(wdt, 0, ds1307->dev);\n\twatchdog_set_drvdata(wdt, ds1307);\n\tdevm_watchdog_register_device(ds1307->dev, wdt);\n}\n#else\nstatic void ds1307_wdt_register(struct ds1307 *ds1307)\n{\n}\n#endif  \n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int ds1307_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ds1307\t\t*ds1307;\n\tconst void\t\t*match;\n\tint\t\t\terr = -ENODEV;\n\tint\t\t\ttmp;\n\tconst struct chip_desc\t*chip;\n\tbool\t\t\twant_irq;\n\tbool\t\t\tds1307_can_wakeup_device = false;\n\tunsigned char\t\tregs[8];\n\tstruct ds1307_platform_data *pdata = dev_get_platdata(&client->dev);\n\tu8\t\t\ttrickle_charger_setup = 0;\n\n\tds1307 = devm_kzalloc(&client->dev, sizeof(struct ds1307), GFP_KERNEL);\n\tif (!ds1307)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&client->dev, ds1307);\n\tds1307->dev = &client->dev;\n\tds1307->name = client->name;\n\n\tds1307->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(ds1307->regmap)) {\n\t\tdev_err(ds1307->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(ds1307->regmap);\n\t}\n\n\ti2c_set_clientdata(client, ds1307);\n\n\tmatch = device_get_match_data(&client->dev);\n\tif (match) {\n\t\tds1307->type = (uintptr_t)match;\n\t\tchip = &chips[ds1307->type];\n\t} else if (id) {\n\t\tchip = &chips[id->driver_data];\n\t\tds1307->type = id->driver_data;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\twant_irq = client->irq > 0 && chip->alarm;\n\n\tif (!pdata)\n\t\ttrickle_charger_setup = ds1307_trickle_init(ds1307, chip);\n\telse if (pdata->trickle_charger_setup)\n\t\ttrickle_charger_setup = pdata->trickle_charger_setup;\n\n\tif (trickle_charger_setup && chip->trickle_charger_reg) {\n\t\tdev_dbg(ds1307->dev,\n\t\t\t\"writing trickle charger info 0x%x to 0x%x\\n\",\n\t\t\ttrickle_charger_setup, chip->trickle_charger_reg);\n\t\tregmap_write(ds1307->regmap, chip->trickle_charger_reg,\n\t\t\t     trickle_charger_setup);\n\t}\n\n \n\tif (chip->alarm && device_property_read_bool(&client->dev, \"wakeup-source\"))\n\t\tds1307_can_wakeup_device = true;\n\n\tswitch (ds1307->type) {\n\tcase ds_1337:\n\tcase ds_1339:\n\tcase ds_1341:\n\tcase ds_3231:\n\t\t \n\t\terr = regmap_bulk_read(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t\t       regs, 2);\n\t\tif (err) {\n\t\t\tdev_dbg(ds1307->dev, \"read error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (regs[0] & DS1337_BIT_nEOSC)\n\t\t\tregs[0] &= ~DS1337_BIT_nEOSC;\n\n\t\t \n\t\tif (want_irq || ds1307_can_wakeup_device) {\n\t\t\tregs[0] |= DS1337_BIT_INTCN | chip->bbsqi_bit;\n\t\t\tregs[0] &= ~(DS1337_BIT_A2IE | DS1337_BIT_A1IE);\n\t\t}\n\n\t\tregmap_write(ds1307->regmap, DS1337_REG_CONTROL,\n\t\t\t     regs[0]);\n\n\t\t \n\t\tif (regs[1] & DS1337_BIT_OSF) {\n\t\t\tregmap_write(ds1307->regmap, DS1337_REG_STATUS,\n\t\t\t\t     regs[1] & ~DS1337_BIT_OSF);\n\t\t\tdev_warn(ds1307->dev, \"SET TIME!\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase rx_8025:\n\t\terr = regmap_bulk_read(ds1307->regmap,\n\t\t\t\t       RX8025_REG_CTRL1 << 4 | 0x08, regs, 2);\n\t\tif (err) {\n\t\t\tdev_dbg(ds1307->dev, \"read error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (!(regs[1] & RX8025_BIT_XST)) {\n\t\t\tregs[1] |= RX8025_BIT_XST;\n\t\t\tregmap_write(ds1307->regmap,\n\t\t\t\t     RX8025_REG_CTRL2 << 4 | 0x08,\n\t\t\t\t     regs[1]);\n\t\t\tdev_warn(ds1307->dev,\n\t\t\t\t \"oscillator stop detected - SET TIME!\\n\");\n\t\t}\n\n\t\tif (regs[1] & RX8025_BIT_PON) {\n\t\t\tregs[1] &= ~RX8025_BIT_PON;\n\t\t\tregmap_write(ds1307->regmap,\n\t\t\t\t     RX8025_REG_CTRL2 << 4 | 0x08,\n\t\t\t\t     regs[1]);\n\t\t\tdev_warn(ds1307->dev, \"power-on detected\\n\");\n\t\t}\n\n\t\tif (regs[1] & RX8025_BIT_VDET) {\n\t\t\tregs[1] &= ~RX8025_BIT_VDET;\n\t\t\tregmap_write(ds1307->regmap,\n\t\t\t\t     RX8025_REG_CTRL2 << 4 | 0x08,\n\t\t\t\t     regs[1]);\n\t\t\tdev_warn(ds1307->dev, \"voltage drop detected\\n\");\n\t\t}\n\n\t\t \n\t\tif (!(regs[0] & RX8025_BIT_2412)) {\n\t\t\tu8 hour;\n\n\t\t\t \n\t\t\tregmap_write(ds1307->regmap,\n\t\t\t\t     RX8025_REG_CTRL1 << 4 | 0x08,\n\t\t\t\t     regs[0] | RX8025_BIT_2412);\n\n\t\t\terr = regmap_bulk_read(ds1307->regmap,\n\t\t\t\t\t       RX8025_REG_CTRL1 << 4 | 0x08,\n\t\t\t\t\t       regs, 2);\n\t\t\tif (err) {\n\t\t\t\tdev_dbg(ds1307->dev, \"read error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t \n\t\t\thour = bcd2bin(regs[DS1307_REG_HOUR]);\n\t\t\tif (hour == 12)\n\t\t\t\thour = 0;\n\t\t\tif (regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\n\t\t\t\thour += 12;\n\n\t\t\tregmap_write(ds1307->regmap,\n\t\t\t\t     DS1307_REG_HOUR << 4 | 0x08, hour);\n\t\t}\n\t\tbreak;\n\tcase ds_1388:\n\t\terr = regmap_read(ds1307->regmap, DS1388_REG_CONTROL, &tmp);\n\t\tif (err) {\n\t\t\tdev_dbg(ds1307->dev, \"read error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (tmp & DS1388_BIT_nEOSC) {\n\t\t\ttmp &= ~DS1388_BIT_nEOSC;\n\t\t\tregmap_write(ds1307->regmap, DS1388_REG_CONTROL, tmp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\terr = regmap_bulk_read(ds1307->regmap, chip->offset, regs,\n\t\t\t       sizeof(regs));\n\tif (err) {\n\t\tdev_dbg(ds1307->dev, \"read error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\tif (ds1307->type == mcp794xx &&\n\t    !(regs[DS1307_REG_WDAY] & MCP794XX_BIT_VBATEN)) {\n\t\tregmap_write(ds1307->regmap, DS1307_REG_WDAY,\n\t\t\t     regs[DS1307_REG_WDAY] |\n\t\t\t     MCP794XX_BIT_VBATEN);\n\t}\n\n\ttmp = regs[DS1307_REG_HOUR];\n\tswitch (ds1307->type) {\n\tcase ds_1340:\n\tcase m41t0:\n\tcase m41t00:\n\tcase m41t11:\n\t\t \n\t\tbreak;\n\tcase rx_8025:\n\t\tbreak;\n\tdefault:\n\t\tif (!(tmp & DS1307_BIT_12HR))\n\t\t\tbreak;\n\n\t\t \n\t\ttmp = bcd2bin(tmp & 0x1f);\n\t\tif (tmp == 12)\n\t\t\ttmp = 0;\n\t\tif (regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\n\t\t\ttmp += 12;\n\t\tregmap_write(ds1307->regmap, chip->offset + DS1307_REG_HOUR,\n\t\t\t     bin2bcd(tmp));\n\t}\n\n\tds1307->rtc = devm_rtc_allocate_device(ds1307->dev);\n\tif (IS_ERR(ds1307->rtc))\n\t\treturn PTR_ERR(ds1307->rtc);\n\n\tif (want_irq || ds1307_can_wakeup_device)\n\t\tdevice_set_wakeup_capable(ds1307->dev, true);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, ds1307->rtc->features);\n\n\tif (ds1307_can_wakeup_device && !want_irq) {\n\t\tdev_info(ds1307->dev,\n\t\t\t \"'wakeup-source' is set, request for an IRQ is disabled!\\n\");\n\t\t \n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, ds1307->rtc->features);\n\t}\n\n\tif (want_irq) {\n\t\terr = devm_request_threaded_irq(ds1307->dev, client->irq, NULL,\n\t\t\t\t\t\tchip->irq_handler ?: ds1307_irq,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\tds1307->name, ds1307);\n\t\tif (err) {\n\t\t\tclient->irq = 0;\n\t\t\tdevice_set_wakeup_capable(ds1307->dev, false);\n\t\t\tclear_bit(RTC_FEATURE_ALARM, ds1307->rtc->features);\n\t\t\tdev_err(ds1307->dev, \"unable to request IRQ!\\n\");\n\t\t} else {\n\t\t\tdev_dbg(ds1307->dev, \"got IRQ %d\\n\", client->irq);\n\t\t}\n\t}\n\n\tds1307->rtc->ops = chip->rtc_ops ?: &ds13xx_rtc_ops;\n\terr = ds1307_add_frequency_test(ds1307);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_rtc_register_device(ds1307->rtc);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->nvram_size) {\n\t\tstruct nvmem_config nvmem_cfg = {\n\t\t\t.name = \"ds1307_nvram\",\n\t\t\t.word_size = 1,\n\t\t\t.stride = 1,\n\t\t\t.size = chip->nvram_size,\n\t\t\t.reg_read = ds1307_nvram_read,\n\t\t\t.reg_write = ds1307_nvram_write,\n\t\t\t.priv = ds1307,\n\t\t};\n\n\t\tdevm_rtc_nvmem_register(ds1307->rtc, &nvmem_cfg);\n\t}\n\n\tds1307_hwmon_register(ds1307);\n\tds1307_clks_register(ds1307);\n\tds1307_wdt_register(ds1307);\n\n\treturn 0;\n\nexit:\n\treturn err;\n}\n\nstatic struct i2c_driver ds1307_driver = {\n\t.driver = {\n\t\t.name\t= \"rtc-ds1307\",\n\t\t.of_match_table = ds1307_of_match,\n\t},\n\t.probe\t\t= ds1307_probe,\n\t.id_table\t= ds1307_id,\n};\n\nmodule_i2c_driver(ds1307_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for DS1307 and similar chips\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}