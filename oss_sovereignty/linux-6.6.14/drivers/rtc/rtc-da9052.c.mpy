{
  "module_name": "rtc-da9052.c",
  "hash_id": "e5de9bc29a66faa96ad7eb37ea2b28a489ff0fbdb238bef7206cee09167d0736",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-da9052.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/reg.h>\n\n#define rtc_err(rtc, fmt, ...) \\\n\t\tdev_err(rtc->da9052->dev, \"%s: \" fmt, __func__, ##__VA_ARGS__)\n\n#define DA9052_GET_TIME_RETRIES 5\n\nstruct da9052_rtc {\n\tstruct rtc_device *rtc;\n\tstruct da9052 *da9052;\n};\n\nstatic int da9052_rtc_enable_alarm(struct da9052_rtc *rtc, bool enable)\n{\n\tint ret;\n\tif (enable) {\n\t\tret = da9052_reg_update(rtc->da9052, DA9052_ALARM_Y_REG,\n\t\t\t\tDA9052_ALARM_Y_ALARM_ON|DA9052_ALARM_Y_TICK_ON,\n\t\t\t\tDA9052_ALARM_Y_ALARM_ON);\n\t\tif (ret != 0)\n\t\t\trtc_err(rtc, \"Failed to enable ALM: %d\\n\", ret);\n\t} else {\n\t\tret = da9052_reg_update(rtc->da9052, DA9052_ALARM_Y_REG,\n\t\t\tDA9052_ALARM_Y_ALARM_ON|DA9052_ALARM_Y_TICK_ON, 0);\n\t\tif (ret != 0)\n\t\t\trtc_err(rtc, \"Write error: %d\\n\", ret);\n\t}\n\treturn ret;\n}\n\nstatic irqreturn_t da9052_rtc_irq(int irq, void *data)\n{\n\tstruct da9052_rtc *rtc = data;\n\n\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9052_read_alarm(struct da9052_rtc *rtc, struct rtc_time *rtc_tm)\n{\n\tint ret;\n\tuint8_t v[2][5];\n\tint idx = 1;\n\tint timeout = DA9052_GET_TIME_RETRIES;\n\n\tret = da9052_group_read(rtc->da9052, DA9052_ALARM_MI_REG, 5, &v[0][0]);\n\tif (ret) {\n\t\trtc_err(rtc, \"Failed to group read ALM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tret = da9052_group_read(rtc->da9052,\n\t\t\t\t\tDA9052_ALARM_MI_REG, 5, &v[idx][0]);\n\t\tif (ret) {\n\t\t\trtc_err(rtc, \"Failed to group read ALM: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(&v[0][0], &v[1][0], 5) == 0) {\n\t\t\trtc_tm->tm_year = (v[0][4] & DA9052_RTC_YEAR) + 100;\n\t\t\trtc_tm->tm_mon  = (v[0][3] & DA9052_RTC_MONTH) - 1;\n\t\t\trtc_tm->tm_mday = v[0][2] & DA9052_RTC_DAY;\n\t\t\trtc_tm->tm_hour = v[0][1] & DA9052_RTC_HOUR;\n\t\t\trtc_tm->tm_min  = v[0][0] & DA9052_RTC_MIN;\n\t\t\trtc_tm->tm_sec = 0;\n\n\t\t\tret = rtc_valid_tm(rtc_tm);\n\t\t\treturn ret;\n\t\t}\n\n\t\tidx = (1-idx);\n\t\tmsleep(20);\n\n\t} while (timeout--);\n\n\trtc_err(rtc, \"Timed out reading alarm time\\n\");\n\n\treturn -EIO;\n}\n\nstatic int da9052_set_alarm(struct da9052_rtc *rtc, struct rtc_time *rtc_tm)\n{\n\tstruct da9052 *da9052 = rtc->da9052;\n\tunsigned long alm_time;\n\tint ret;\n\tuint8_t v[3];\n\n\talm_time = rtc_tm_to_time64(rtc_tm);\n\n\tif (rtc_tm->tm_sec > 0) {\n\t\talm_time += 60 - rtc_tm->tm_sec;\n\t\trtc_time64_to_tm(alm_time, rtc_tm);\n\t}\n\tBUG_ON(rtc_tm->tm_sec);  \n\n\trtc_tm->tm_year -= 100;\n\trtc_tm->tm_mon += 1;\n\n\tret = da9052_reg_update(da9052, DA9052_ALARM_MI_REG,\n\t\t\t\tDA9052_RTC_MIN, rtc_tm->tm_min);\n\tif (ret != 0) {\n\t\trtc_err(rtc, \"Failed to write ALRM MIN: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tv[0] = rtc_tm->tm_hour;\n\tv[1] = rtc_tm->tm_mday;\n\tv[2] = rtc_tm->tm_mon;\n\n\tret = da9052_group_write(da9052, DA9052_ALARM_H_REG, 3, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da9052_reg_update(da9052, DA9052_ALARM_Y_REG,\n\t\t\t\tDA9052_RTC_YEAR, rtc_tm->tm_year);\n\tif (ret != 0)\n\t\trtc_err(rtc, \"Failed to write ALRM YEAR: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int da9052_rtc_get_alarm_status(struct da9052_rtc *rtc)\n{\n\tint ret;\n\n\tret = da9052_reg_read(rtc->da9052, DA9052_ALARM_Y_REG);\n\tif (ret < 0) {\n\t\trtc_err(rtc, \"Failed to read ALM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn !!(ret&DA9052_ALARM_Y_ALARM_ON);\n}\n\nstatic int da9052_rtc_read_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\tuint8_t v[2][6];\n\tint idx = 1;\n\tint timeout = DA9052_GET_TIME_RETRIES;\n\n\tret = da9052_group_read(rtc->da9052, DA9052_COUNT_S_REG, 6, &v[0][0]);\n\tif (ret) {\n\t\trtc_err(rtc, \"Failed to read RTC time : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tret = da9052_group_read(rtc->da9052,\n\t\t\t\t\tDA9052_COUNT_S_REG, 6, &v[idx][0]);\n\t\tif (ret) {\n\t\t\trtc_err(rtc, \"Failed to read RTC time : %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(&v[0][0], &v[1][0], 6) == 0) {\n\t\t\trtc_tm->tm_year = (v[0][5] & DA9052_RTC_YEAR) + 100;\n\t\t\trtc_tm->tm_mon  = (v[0][4] & DA9052_RTC_MONTH) - 1;\n\t\t\trtc_tm->tm_mday = v[0][3] & DA9052_RTC_DAY;\n\t\t\trtc_tm->tm_hour = v[0][2] & DA9052_RTC_HOUR;\n\t\t\trtc_tm->tm_min  = v[0][1] & DA9052_RTC_MIN;\n\t\t\trtc_tm->tm_sec  = v[0][0] & DA9052_RTC_SEC;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tidx = (1-idx);\n\t\tmsleep(20);\n\n\t} while (timeout--);\n\n\trtc_err(rtc, \"Timed out reading time\\n\");\n\n\treturn -EIO;\n}\n\nstatic int da9052_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct da9052_rtc *rtc;\n\tuint8_t v[6];\n\tint ret;\n\n\t \n\tif ((tm->tm_year < 100) || (tm->tm_year > 163))\n\t\treturn -EINVAL;\n\n\trtc = dev_get_drvdata(dev);\n\n\tv[0] = tm->tm_sec;\n\tv[1] = tm->tm_min;\n\tv[2] = tm->tm_hour;\n\tv[3] = tm->tm_mday;\n\tv[4] = tm->tm_mon + 1;\n\tv[5] = tm->tm_year - 100;\n\n\tret = da9052_group_write(rtc->da9052, DA9052_COUNT_S_REG, 6, v);\n\tif (ret < 0)\n\t\trtc_err(rtc, \"failed to set RTC time: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int da9052_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tstruct rtc_time *tm = &alrm->time;\n\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\n\tret = da9052_read_alarm(rtc, tm);\n\tif (ret < 0) {\n\t\trtc_err(rtc, \"failed to read RTC alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talrm->enabled = da9052_rtc_get_alarm_status(rtc);\n\treturn 0;\n}\n\nstatic int da9052_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tstruct rtc_time *tm = &alrm->time;\n\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\n\t \n\tif ((tm->tm_year < 100) || (tm->tm_year > 163))\n\t\treturn -EINVAL;\n\n\tret = da9052_rtc_enable_alarm(rtc, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da9052_set_alarm(rtc, tm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da9052_rtc_enable_alarm(rtc, 1);\n\treturn ret;\n}\n\nstatic int da9052_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct da9052_rtc *rtc = dev_get_drvdata(dev);\n\n\treturn da9052_rtc_enable_alarm(rtc, enabled);\n}\n\nstatic const struct rtc_class_ops da9052_rtc_ops = {\n\t.read_time\t= da9052_rtc_read_time,\n\t.set_time\t= da9052_rtc_set_time,\n\t.read_alarm\t= da9052_rtc_read_alarm,\n\t.set_alarm\t= da9052_rtc_set_alarm,\n\t.alarm_irq_enable = da9052_rtc_alarm_irq_enable,\n};\n\nstatic int da9052_rtc_probe(struct platform_device *pdev)\n{\n\tstruct da9052_rtc *rtc;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(struct da9052_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->da9052 = dev_get_drvdata(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, rtc);\n\n\tret = da9052_reg_write(rtc->da9052, DA9052_BBAT_CONT_REG, 0xFE);\n\tif (ret < 0) {\n\t\trtc_err(rtc,\n\t\t\t\"Failed to setup RTC battery charging: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = da9052_reg_update(rtc->da9052, DA9052_ALARM_Y_REG,\n\t\t\t\tDA9052_ALARM_Y_TICK_ON, 0);\n\tif (ret != 0)\n\t\trtc_err(rtc, \"Failed to disable TICKS: %d\\n\", ret);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc))\n\t\treturn PTR_ERR(rtc->rtc);\n\n\trtc->rtc->ops = &da9052_rtc_ops;\n\trtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->rtc->range_max = RTC_TIMESTAMP_END_2063;\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da9052_request_irq(rtc->da9052, DA9052_IRQ_ALARM, \"ALM\",\n\t\t\t\tda9052_rtc_irq, rtc);\n\tif (ret != 0) {\n\t\trtc_err(rtc, \"irq registration failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_rtc_driver = {\n\t.probe\t= da9052_rtc_probe,\n\t.driver = {\n\t\t.name\t= \"da9052-rtc\",\n\t},\n};\n\nmodule_platform_driver(da9052_rtc_driver);\n\nMODULE_AUTHOR(\"Anthony Olech <Anthony.Olech@diasemi.com>\");\nMODULE_DESCRIPTION(\"RTC driver for Dialog DA9052 PMIC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}