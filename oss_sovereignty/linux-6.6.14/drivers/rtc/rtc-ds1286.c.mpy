{
  "module_name": "rtc-ds1286.c",
  "hash_id": "1b0a6cbc6b15a23576d8c0b2189cd965ef4ec92b2d56b5d3fd8ee504a316f204",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1286.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/bcd.h>\n#include <linux/rtc/ds1286.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\nstruct ds1286_priv {\n\tstruct rtc_device *rtc;\n\tu32 __iomem *rtcregs;\n\tspinlock_t lock;\n};\n\nstatic inline u8 ds1286_rtc_read(struct ds1286_priv *priv, int reg)\n{\n\treturn __raw_readl(&priv->rtcregs[reg]) & 0xff;\n}\n\nstatic inline void ds1286_rtc_write(struct ds1286_priv *priv, u8 data, int reg)\n{\n\t__raw_writel(data, &priv->rtcregs[reg]);\n}\n\n\nstatic int ds1286_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned char val;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tval = ds1286_rtc_read(priv, RTC_CMD);\n\tif (enabled)\n\t\tval &=  ~RTC_TDM;\n\telse\n\t\tval |=  RTC_TDM;\n\tds1286_rtc_write(priv, val, RTC_CMD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_RTC_INTF_DEV\n\nstatic int ds1286_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned char val;\n\n\tswitch (cmd) {\n\tcase RTC_WIE_OFF:\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tval = ds1286_rtc_read(priv, RTC_CMD);\n\t\tval |= RTC_WAM;\n\t\tds1286_rtc_write(priv, val, RTC_CMD);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tbreak;\n\tcase RTC_WIE_ON:\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tval = ds1286_rtc_read(priv, RTC_CMD);\n\t\tval &= ~RTC_WAM;\n\t\tds1286_rtc_write(priv, val, RTC_CMD);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n\n#else\n#define ds1286_ioctl    NULL\n#endif\n\n#ifdef CONFIG_PROC_FS\n\nstatic int ds1286_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned char month, cmd, amode;\n\tconst char *s;\n\n\tmonth = ds1286_rtc_read(priv, RTC_MONTH);\n\tseq_printf(seq,\n\t\t   \"oscillator\\t: %s\\n\"\n\t\t   \"square_wave\\t: %s\\n\",\n\t\t   (month & RTC_EOSC) ? \"disabled\" : \"enabled\",\n\t\t   (month & RTC_ESQW) ? \"disabled\" : \"enabled\");\n\n\tamode = ((ds1286_rtc_read(priv, RTC_MINUTES_ALARM) & 0x80) >> 5) |\n\t\t((ds1286_rtc_read(priv, RTC_HOURS_ALARM) & 0x80) >> 6) |\n\t\t((ds1286_rtc_read(priv, RTC_DAY_ALARM) & 0x80) >> 7);\n\tswitch (amode) {\n\tcase 7:\n\t\ts = \"each minute\";\n\t\tbreak;\n\tcase 3:\n\t\ts = \"minutes match\";\n\t\tbreak;\n\tcase 1:\n\t\ts = \"hours and minutes match\";\n\t\tbreak;\n\tcase 0:\n\t\ts = \"days, hours and minutes match\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(seq, \"alarm_mode\\t: %s\\n\", s);\n\n\tcmd = ds1286_rtc_read(priv, RTC_CMD);\n\tseq_printf(seq,\n\t\t   \"alarm_enable\\t: %s\\n\"\n\t\t   \"wdog_alarm\\t: %s\\n\"\n\t\t   \"alarm_mask\\t: %s\\n\"\n\t\t   \"wdog_alarm_mask\\t: %s\\n\"\n\t\t   \"interrupt_mode\\t: %s\\n\"\n\t\t   \"INTB_mode\\t: %s_active\\n\"\n\t\t   \"interrupt_pins\\t: %s\\n\",\n\t\t   (cmd & RTC_TDF) ? \"yes\" : \"no\",\n\t\t   (cmd & RTC_WAF) ? \"yes\" : \"no\",\n\t\t   (cmd & RTC_TDM) ? \"disabled\" : \"enabled\",\n\t\t   (cmd & RTC_WAM) ? \"disabled\" : \"enabled\",\n\t\t   (cmd & RTC_PU_LVL) ? \"pulse\" : \"level\",\n\t\t   (cmd & RTC_IBH_LO) ? \"low\" : \"high\",\n\t\t   (cmd & RTC_IPSW) ? \"unswapped\" : \"swapped\");\n\treturn 0;\n}\n\n#else\n#define ds1286_proc     NULL\n#endif\n\nstatic int ds1286_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned char save_control;\n\tunsigned long flags;\n\tunsigned long uip_watchdog = jiffies;\n\n\t \n\n\tif (ds1286_rtc_read(priv, RTC_CMD) & RTC_TE)\n\t\twhile (time_before(jiffies, uip_watchdog + 2*HZ/100))\n\t\t\tbarrier();\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tsave_control = ds1286_rtc_read(priv, RTC_CMD);\n\tds1286_rtc_write(priv, (save_control|RTC_TE), RTC_CMD);\n\n\ttm->tm_sec = ds1286_rtc_read(priv, RTC_SECONDS);\n\ttm->tm_min = ds1286_rtc_read(priv, RTC_MINUTES);\n\ttm->tm_hour = ds1286_rtc_read(priv, RTC_HOURS) & 0x3f;\n\ttm->tm_mday = ds1286_rtc_read(priv, RTC_DATE);\n\ttm->tm_mon = ds1286_rtc_read(priv, RTC_MONTH) & 0x1f;\n\ttm->tm_year = ds1286_rtc_read(priv, RTC_YEAR);\n\n\tds1286_rtc_write(priv, save_control, RTC_CMD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon);\n\ttm->tm_year = bcd2bin(tm->tm_year);\n\n\t \n\tif (tm->tm_year < 45)\n\t\ttm->tm_year += 30;\n\ttm->tm_year += 40;\n\tif (tm->tm_year < 70)\n\t\ttm->tm_year += 100;\n\n\ttm->tm_mon--;\n\n\treturn 0;\n}\n\nstatic int ds1286_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned char mon, day, hrs, min, sec;\n\tunsigned char save_control;\n\tunsigned int yrs;\n\tunsigned long flags;\n\n\tyrs = tm->tm_year + 1900;\n\tmon = tm->tm_mon + 1;    \n\tday = tm->tm_mday;\n\thrs = tm->tm_hour;\n\tmin = tm->tm_min;\n\tsec = tm->tm_sec;\n\n\tif (yrs < 1970)\n\t\treturn -EINVAL;\n\n\tyrs -= 1940;\n\tif (yrs > 255)     \n\t\treturn -EINVAL;\n\n\tif (yrs >= 100)\n\t\tyrs -= 100;\n\n\tsec = bin2bcd(sec);\n\tmin = bin2bcd(min);\n\thrs = bin2bcd(hrs);\n\tday = bin2bcd(day);\n\tmon = bin2bcd(mon);\n\tyrs = bin2bcd(yrs);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tsave_control = ds1286_rtc_read(priv, RTC_CMD);\n\tds1286_rtc_write(priv, (save_control|RTC_TE), RTC_CMD);\n\n\tds1286_rtc_write(priv, yrs, RTC_YEAR);\n\tds1286_rtc_write(priv, mon, RTC_MONTH);\n\tds1286_rtc_write(priv, day, RTC_DATE);\n\tds1286_rtc_write(priv, hrs, RTC_HOURS);\n\tds1286_rtc_write(priv, min, RTC_MINUTES);\n\tds1286_rtc_write(priv, sec, RTC_SECONDS);\n\tds1286_rtc_write(priv, 0, RTC_HUNDREDTH_SECOND);\n\n\tds1286_rtc_write(priv, save_control, RTC_CMD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn 0;\n}\n\nstatic int ds1286_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\talm->time.tm_min = ds1286_rtc_read(priv, RTC_MINUTES_ALARM) & 0x7f;\n\talm->time.tm_hour = ds1286_rtc_read(priv, RTC_HOURS_ALARM)  & 0x1f;\n\talm->time.tm_wday = ds1286_rtc_read(priv, RTC_DAY_ALARM)    & 0x07;\n\tds1286_rtc_read(priv, RTC_CMD);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\talm->time.tm_min = bcd2bin(alm->time.tm_min);\n\talm->time.tm_hour = bcd2bin(alm->time.tm_hour);\n\talm->time.tm_sec = 0;\n\treturn 0;\n}\n\nstatic int ds1286_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1286_priv *priv = dev_get_drvdata(dev);\n\tunsigned char hrs, min, sec;\n\n\thrs = alm->time.tm_hour;\n\tmin = alm->time.tm_min;\n\tsec = alm->time.tm_sec;\n\n\tif (hrs >= 24)\n\t\thrs = 0xff;\n\n\tif (min >= 60)\n\t\tmin = 0xff;\n\n\tif (sec != 0)\n\t\treturn -EINVAL;\n\n\tmin = bin2bcd(min);\n\thrs = bin2bcd(hrs);\n\n\tspin_lock(&priv->lock);\n\tds1286_rtc_write(priv, hrs, RTC_HOURS_ALARM);\n\tds1286_rtc_write(priv, min, RTC_MINUTES_ALARM);\n\tspin_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1286_ops = {\n\t.ioctl\t\t= ds1286_ioctl,\n\t.proc\t\t= ds1286_proc,\n\t.read_time\t= ds1286_read_time,\n\t.set_time\t= ds1286_set_time,\n\t.read_alarm\t= ds1286_read_alarm,\n\t.set_alarm\t= ds1286_set_alarm,\n\t.alarm_irq_enable = ds1286_alarm_irq_enable,\n};\n\nstatic int ds1286_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\tstruct ds1286_priv *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct ds1286_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->rtcregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->rtcregs))\n\t\treturn PTR_ERR(priv->rtcregs);\n\n\tspin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\trtc = devm_rtc_device_register(&pdev->dev, \"ds1286\", &ds1286_ops,\n\t\t\t\t\tTHIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\tpriv->rtc = rtc;\n\treturn 0;\n}\n\nstatic struct platform_driver ds1286_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-ds1286\",\n\t},\n\t.probe\t\t= ds1286_probe,\n};\n\nmodule_platform_driver(ds1286_platform_driver);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tsbogend@alpha.franken.de>\");\nMODULE_DESCRIPTION(\"DS1286 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-ds1286\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}