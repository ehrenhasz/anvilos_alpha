{
  "module_name": "rtc-rv3028.c",
  "hash_id": "f14bdbbf413868a4dc6725005117c171e9a7ec83a2650426645c4fb62bb2c411",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rv3028.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define RV3028_SEC\t\t\t0x00\n#define RV3028_MIN\t\t\t0x01\n#define RV3028_HOUR\t\t\t0x02\n#define RV3028_WDAY\t\t\t0x03\n#define RV3028_DAY\t\t\t0x04\n#define RV3028_MONTH\t\t\t0x05\n#define RV3028_YEAR\t\t\t0x06\n#define RV3028_ALARM_MIN\t\t0x07\n#define RV3028_ALARM_HOUR\t\t0x08\n#define RV3028_ALARM_DAY\t\t0x09\n#define RV3028_STATUS\t\t\t0x0E\n#define RV3028_CTRL1\t\t\t0x0F\n#define RV3028_CTRL2\t\t\t0x10\n#define RV3028_EVT_CTRL\t\t\t0x13\n#define RV3028_TS_COUNT\t\t\t0x14\n#define RV3028_TS_SEC\t\t\t0x15\n#define RV3028_RAM1\t\t\t0x1F\n#define RV3028_EEPROM_ADDR\t\t0x25\n#define RV3028_EEPROM_DATA\t\t0x26\n#define RV3028_EEPROM_CMD\t\t0x27\n#define RV3028_CLKOUT\t\t\t0x35\n#define RV3028_OFFSET\t\t\t0x36\n#define RV3028_BACKUP\t\t\t0x37\n\n#define RV3028_STATUS_PORF\t\tBIT(0)\n#define RV3028_STATUS_EVF\t\tBIT(1)\n#define RV3028_STATUS_AF\t\tBIT(2)\n#define RV3028_STATUS_TF\t\tBIT(3)\n#define RV3028_STATUS_UF\t\tBIT(4)\n#define RV3028_STATUS_BSF\t\tBIT(5)\n#define RV3028_STATUS_CLKF\t\tBIT(6)\n#define RV3028_STATUS_EEBUSY\t\tBIT(7)\n\n#define RV3028_CLKOUT_FD_MASK\t\tGENMASK(2, 0)\n#define RV3028_CLKOUT_PORIE\t\tBIT(3)\n#define RV3028_CLKOUT_CLKSY\t\tBIT(6)\n#define RV3028_CLKOUT_CLKOE\t\tBIT(7)\n\n#define RV3028_CTRL1_EERD\t\tBIT(3)\n#define RV3028_CTRL1_WADA\t\tBIT(5)\n\n#define RV3028_CTRL2_RESET\t\tBIT(0)\n#define RV3028_CTRL2_12_24\t\tBIT(1)\n#define RV3028_CTRL2_EIE\t\tBIT(2)\n#define RV3028_CTRL2_AIE\t\tBIT(3)\n#define RV3028_CTRL2_TIE\t\tBIT(4)\n#define RV3028_CTRL2_UIE\t\tBIT(5)\n#define RV3028_CTRL2_TSE\t\tBIT(7)\n\n#define RV3028_EVT_CTRL_TSR\t\tBIT(2)\n\n#define RV3028_EEPROM_CMD_UPDATE\t0x11\n#define RV3028_EEPROM_CMD_WRITE\t\t0x21\n#define RV3028_EEPROM_CMD_READ\t\t0x22\n\n#define RV3028_EEBUSY_POLL\t\t10000\n#define RV3028_EEBUSY_TIMEOUT\t\t100000\n\n#define RV3028_BACKUP_TCE\t\tBIT(5)\n#define RV3028_BACKUP_TCR_MASK\t\tGENMASK(1,0)\n#define RV3028_BACKUP_BSM\t\tGENMASK(3,2)\n\n#define RV3028_BACKUP_BSM_DSM\t\t0x1\n#define RV3028_BACKUP_BSM_LSM\t\t0x3\n\n#define OFFSET_STEP_PPT\t\t\t953674\n\nenum rv3028_type {\n\trv_3028,\n};\n\nstruct rv3028_data {\n\tstruct regmap *regmap;\n\tstruct rtc_device *rtc;\n\tenum rv3028_type type;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw clkout_hw;\n#endif\n};\n\nstatic u16 rv3028_trickle_resistors[] = {3000, 5000, 9000, 15000};\n\nstatic ssize_t timestamp0_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev->parent);\n\n\tregmap_update_bits(rv3028->regmap, RV3028_EVT_CTRL, RV3028_EVT_CTRL_TSR,\n\t\t\t   RV3028_EVT_CTRL_TSR);\n\n\treturn count;\n};\n\nstatic ssize_t timestamp0_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev->parent);\n\tstruct rtc_time tm;\n\tint ret, count;\n\tu8 date[6];\n\n\tret = regmap_read(rv3028->regmap, RV3028_TS_COUNT, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tret = regmap_bulk_read(rv3028->regmap, RV3028_TS_SEC, date,\n\t\t\t       sizeof(date));\n\tif (ret)\n\t\treturn ret;\n\n\ttm.tm_sec = bcd2bin(date[0]);\n\ttm.tm_min = bcd2bin(date[1]);\n\ttm.tm_hour = bcd2bin(date[2]);\n\ttm.tm_mday = bcd2bin(date[3]);\n\ttm.tm_mon = bcd2bin(date[4]) - 1;\n\ttm.tm_year = bcd2bin(date[5]) + 100;\n\n\tret = rtc_valid_tm(&tm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t       (unsigned long long)rtc_tm_to_time64(&tm));\n};\n\nstatic DEVICE_ATTR_RW(timestamp0);\n\nstatic ssize_t timestamp0_count_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev->parent);\n\tint ret, count;\n\n\tret = regmap_read(rv3028->regmap, RV3028_TS_COUNT, &count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", count);\n};\n\nstatic DEVICE_ATTR_RO(timestamp0_count);\n\nstatic struct attribute *rv3028_attrs[] = {\n\t&dev_attr_timestamp0.attr,\n\t&dev_attr_timestamp0_count.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rv3028_attr_group = {\n\t.attrs\t= rv3028_attrs,\n};\n\nstatic int rv3028_exit_eerd(struct rv3028_data *rv3028, u32 eerd)\n{\n\tif (eerd)\n\t\treturn 0;\n\n\treturn regmap_update_bits(rv3028->regmap, RV3028_CTRL1, RV3028_CTRL1_EERD, 0);\n}\n\nstatic int rv3028_enter_eerd(struct rv3028_data *rv3028, u32 *eerd)\n{\n\tu32 ctrl1, status;\n\tint ret;\n\n\tret = regmap_read(rv3028->regmap, RV3028_CTRL1, &ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\t*eerd = ctrl1 & RV3028_CTRL1_EERD;\n\tif (*eerd)\n\t\treturn 0;\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL1,\n\t\t\t\t RV3028_CTRL1_EERD, RV3028_CTRL1_EERD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(rv3028->regmap, RV3028_STATUS, status,\n\t\t\t\t       !(status & RV3028_STATUS_EEBUSY),\n\t\t\t\t       RV3028_EEBUSY_POLL, RV3028_EEBUSY_TIMEOUT);\n\tif (ret) {\n\t\trv3028_exit_eerd(rv3028, *eerd);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3028_update_eeprom(struct rv3028_data *rv3028, u32 eerd)\n{\n\tu32 status;\n\tint ret;\n\n\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD, 0x0);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD, RV3028_EEPROM_CMD_UPDATE);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tusleep_range(63000, RV3028_EEBUSY_TIMEOUT);\n\n\tret = regmap_read_poll_timeout(rv3028->regmap, RV3028_STATUS, status,\n\t\t\t\t       !(status & RV3028_STATUS_EEBUSY),\n\t\t\t\t       RV3028_EEBUSY_POLL, RV3028_EEBUSY_TIMEOUT);\n\nexit_eerd:\n\trv3028_exit_eerd(rv3028, eerd);\n\n\treturn ret;\n}\n\nstatic int rv3028_update_cfg(struct rv3028_data *rv3028, unsigned int reg,\n\t\t\t     unsigned int mask, unsigned int val)\n{\n\tu32 eerd;\n\tint ret;\n\n\tret = rv3028_enter_eerd(rv3028, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3028->regmap, reg, mask, val);\n\tif (ret) {\n\t\trv3028_exit_eerd(rv3028, eerd);\n\t\treturn ret;\n\t}\n\n\treturn rv3028_update_eeprom(rv3028, eerd);\n}\n\nstatic irqreturn_t rv3028_handle_irq(int irq, void *dev_id)\n{\n\tstruct rv3028_data *rv3028 = dev_id;\n\tunsigned long events = 0;\n\tu32 status = 0, ctrl = 0;\n\n\tif (regmap_read(rv3028->regmap, RV3028_STATUS, &status) < 0 ||\n\t   status == 0) {\n\t\treturn IRQ_NONE;\n\t}\n\n\tstatus &= ~RV3028_STATUS_PORF;\n\n\tif (status & RV3028_STATUS_TF) {\n\t\tstatus |= RV3028_STATUS_TF;\n\t\tctrl |= RV3028_CTRL2_TIE;\n\t\tevents |= RTC_PF;\n\t}\n\n\tif (status & RV3028_STATUS_AF) {\n\t\tstatus |= RV3028_STATUS_AF;\n\t\tctrl |= RV3028_CTRL2_AIE;\n\t\tevents |= RTC_AF;\n\t}\n\n\tif (status & RV3028_STATUS_UF) {\n\t\tstatus |= RV3028_STATUS_UF;\n\t\tctrl |= RV3028_CTRL2_UIE;\n\t\tevents |= RTC_UF;\n\t}\n\n\tif (events) {\n\t\trtc_update_irq(rv3028->rtc, 1, events);\n\t\tregmap_update_bits(rv3028->regmap, RV3028_STATUS, status, 0);\n\t\tregmap_update_bits(rv3028->regmap, RV3028_CTRL2, ctrl, 0);\n\t}\n\n\tif (status & RV3028_STATUS_EVF) {\n\t\tsysfs_notify(&rv3028->rtc->dev.kobj, NULL,\n\t\t\t     dev_attr_timestamp0.attr.name);\n\t\tdev_warn(&rv3028->rtc->dev, \"event detected\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rv3028_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret, status;\n\n\tret = regmap_read(rv3028->regmap, RV3028_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & RV3028_STATUS_PORF)\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_read(rv3028->regmap, RV3028_SEC, date, sizeof(date));\n\tif (ret)\n\t\treturn ret;\n\n\ttm->tm_sec  = bcd2bin(date[RV3028_SEC] & 0x7f);\n\ttm->tm_min  = bcd2bin(date[RV3028_MIN] & 0x7f);\n\ttm->tm_hour = bcd2bin(date[RV3028_HOUR] & 0x3f);\n\ttm->tm_wday = date[RV3028_WDAY] & 0x7f;\n\ttm->tm_mday = bcd2bin(date[RV3028_DAY] & 0x3f);\n\ttm->tm_mon  = bcd2bin(date[RV3028_MONTH] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(date[RV3028_YEAR]) + 100;\n\n\treturn 0;\n}\n\nstatic int rv3028_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret;\n\n\tdate[RV3028_SEC]   = bin2bcd(tm->tm_sec);\n\tdate[RV3028_MIN]   = bin2bcd(tm->tm_min);\n\tdate[RV3028_HOUR]  = bin2bcd(tm->tm_hour);\n\tdate[RV3028_WDAY]  = tm->tm_wday;\n\tdate[RV3028_DAY]   = bin2bcd(tm->tm_mday);\n\tdate[RV3028_MONTH] = bin2bcd(tm->tm_mon + 1);\n\tdate[RV3028_YEAR]  = bin2bcd(tm->tm_year - 100);\n\n\t \n\tret = regmap_bulk_write(rv3028->regmap, RV3028_SEC, date,\n\t\t\t\tsizeof(date));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_STATUS,\n\t\t\t\t RV3028_STATUS_PORF, 0);\n\n\treturn ret;\n}\n\nstatic int rv3028_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tint status, ctrl, ret;\n\n\tret = regmap_bulk_read(rv3028->regmap, RV3028_ALARM_MIN, alarmvals,\n\t\t\t       sizeof(alarmvals));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(rv3028->regmap, RV3028_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(rv3028->regmap, RV3028_CTRL2, &ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talrm->time.tm_sec  = 0;\n\talrm->time.tm_min  = bcd2bin(alarmvals[0] & 0x7f);\n\talrm->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\n\talrm->time.tm_mday = bcd2bin(alarmvals[2] & 0x3f);\n\n\talrm->enabled = !!(ctrl & RV3028_CTRL2_AIE);\n\talrm->pending = (status & RV3028_STATUS_AF) && alrm->enabled;\n\n\treturn 0;\n}\n\nstatic int rv3028_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tu8 ctrl = 0;\n\tint ret;\n\n\t \n\tif (alrm->time.tm_sec) {\n\t\ttime64_t alarm_time = rtc_tm_to_time64(&alrm->time);\n\n\t\talarm_time += 60 - alrm->time.tm_sec;\n\t\trtc_time64_to_tm(alarm_time, &alrm->time);\n\t}\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL2,\n\t\t\t\t RV3028_CTRL2_AIE | RV3028_CTRL2_UIE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\talarmvals[0] = bin2bcd(alrm->time.tm_min);\n\talarmvals[1] = bin2bcd(alrm->time.tm_hour);\n\talarmvals[2] = bin2bcd(alrm->time.tm_mday);\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_STATUS,\n\t\t\t\t RV3028_STATUS_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(rv3028->regmap, RV3028_ALARM_MIN, alarmvals,\n\t\t\t\tsizeof(alarmvals));\n\tif (ret)\n\t\treturn ret;\n\n\tif (alrm->enabled) {\n\t\tif (rv3028->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RV3028_CTRL2_UIE;\n\t\tif (rv3028->rtc->aie_timer.enabled)\n\t\t\tctrl |= RV3028_CTRL2_AIE;\n\t}\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL2,\n\t\t\t\t RV3028_CTRL2_UIE | RV3028_CTRL2_AIE, ctrl);\n\n\treturn ret;\n}\n\nstatic int rv3028_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tint ctrl = 0, ret;\n\n\tif (enabled) {\n\t\tif (rv3028->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RV3028_CTRL2_UIE;\n\t\tif (rv3028->rtc->aie_timer.enabled)\n\t\t\tctrl |= RV3028_CTRL2_AIE;\n\t}\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_STATUS,\n\t\t\t\t RV3028_STATUS_AF | RV3028_STATUS_UF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL2,\n\t\t\t\t RV3028_CTRL2_UIE | RV3028_CTRL2_AIE, ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rv3028_read_offset(struct device *dev, long *offset)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tint ret, value, steps;\n\n\tret = regmap_read(rv3028->regmap, RV3028_OFFSET, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsteps = sign_extend32(value << 1, 8);\n\n\tret = regmap_read(rv3028->regmap, RV3028_BACKUP, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsteps += value >> 7;\n\n\t*offset = DIV_ROUND_CLOSEST(steps * OFFSET_STEP_PPT, 1000);\n\n\treturn 0;\n}\n\nstatic int rv3028_set_offset(struct device *dev, long offset)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu32 eerd;\n\tint ret;\n\n\toffset = clamp(offset, -244141L, 243187L) * 1000;\n\toffset = DIV_ROUND_CLOSEST(offset, OFFSET_STEP_PPT);\n\n\tret = rv3028_enter_eerd(rv3028, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rv3028->regmap, RV3028_OFFSET, offset >> 1);\n\tif (ret < 0)\n\t\tgoto exit_eerd;\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_BACKUP, BIT(7),\n\t\t\t\t offset << 7);\n\tif (ret < 0)\n\t\tgoto exit_eerd;\n\n\treturn rv3028_update_eeprom(rv3028, eerd);\n\nexit_eerd:\n\trv3028_exit_eerd(rv3028, eerd);\n\n\treturn ret;\n\n}\n\nstatic int rv3028_param_get(struct device *dev, struct rtc_param *param)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tint ret;\n\tu32 value;\n\n\tswitch(param->param) {\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tret = regmap_read(rv3028->regmap, RV3028_BACKUP, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue = FIELD_GET(RV3028_BACKUP_BSM, value);\n\n\t\tswitch(value) {\n\t\tcase RV3028_BACKUP_BSM_DSM:\n\t\t\tparam->uvalue = RTC_BSM_DIRECT;\n\t\t\tbreak;\n\t\tcase RV3028_BACKUP_BSM_LSM:\n\t\t\tparam->uvalue = RTC_BSM_LEVEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->uvalue = RTC_BSM_DISABLED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3028_param_set(struct device *dev, struct rtc_param *param)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tu8 mode;\n\n\tswitch(param->param) {\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tswitch (param->uvalue) {\n\t\tcase RTC_BSM_DISABLED:\n\t\t\tmode = 0;\n\t\t\tbreak;\n\t\tcase RTC_BSM_DIRECT:\n\t\t\tmode = RV3028_BACKUP_BSM_DSM;\n\t\t\tbreak;\n\t\tcase RTC_BSM_LEVEL:\n\t\t\tmode = RV3028_BACKUP_BSM_LSM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn rv3028_update_cfg(rv3028, RV3028_BACKUP, RV3028_BACKUP_BSM,\n\t\t\t\t\t FIELD_PREP(RV3028_BACKUP_BSM, mode));\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3028_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct rv3028_data *rv3028 = dev_get_drvdata(dev);\n\tint status, ret = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(rv3028->regmap, RV3028_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = status & RV3028_STATUS_PORF ? RTC_VL_DATA_INVALID : 0;\n\t\treturn put_user(status, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int rv3028_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\treturn regmap_bulk_write(priv, RV3028_RAM1 + offset, val, bytes);\n}\n\nstatic int rv3028_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\treturn regmap_bulk_read(priv, RV3028_RAM1 + offset, val, bytes);\n}\n\nstatic int rv3028_eeprom_write(void *priv, unsigned int offset, void *val,\n\t\t\t       size_t bytes)\n{\n\tstruct rv3028_data *rv3028 = priv;\n\tu32 status, eerd;\n\tint i, ret;\n\tu8 *buf = val;\n\n\tret = rv3028_enter_eerd(rv3028, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_ADDR, offset + i);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_DATA, buf[i]);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD, 0x0);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD,\n\t\t\t\t   RV3028_EEPROM_CMD_WRITE);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tusleep_range(RV3028_EEBUSY_POLL, RV3028_EEBUSY_TIMEOUT);\n\n\t\tret = regmap_read_poll_timeout(rv3028->regmap, RV3028_STATUS, status,\n\t\t\t\t\t       !(status & RV3028_STATUS_EEBUSY),\n\t\t\t\t\t       RV3028_EEBUSY_POLL,\n\t\t\t\t\t       RV3028_EEBUSY_TIMEOUT);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\t}\n\nrestore_eerd:\n\trv3028_exit_eerd(rv3028, eerd);\n\n\treturn ret;\n}\n\nstatic int rv3028_eeprom_read(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct rv3028_data *rv3028 = priv;\n\tu32 status, eerd, data;\n\tint i, ret;\n\tu8 *buf = val;\n\n\tret = rv3028_enter_eerd(rv3028, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_ADDR, offset + i);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD, 0x0);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_write(rv3028->regmap, RV3028_EEPROM_CMD,\n\t\t\t\t   RV3028_EEPROM_CMD_READ);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_read_poll_timeout(rv3028->regmap, RV3028_STATUS, status,\n\t\t\t\t\t       !(status & RV3028_STATUS_EEBUSY),\n\t\t\t\t\t       RV3028_EEBUSY_POLL,\n\t\t\t\t\t       RV3028_EEBUSY_TIMEOUT);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\n\t\tret = regmap_read(rv3028->regmap, RV3028_EEPROM_DATA, &data);\n\t\tif (ret)\n\t\t\tgoto restore_eerd;\n\t\tbuf[i] = data;\n\t}\n\nrestore_eerd:\n\trv3028_exit_eerd(rv3028, eerd);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMMON_CLK\n#define clkout_hw_to_rv3028(hw) container_of(hw, struct rv3028_data, clkout_hw)\n\nstatic int clkout_rates[] = {\n\t32768,\n\t8192,\n\t1024,\n\t64,\n\t32,\n\t1,\n};\n\nstatic unsigned long rv3028_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tint clkout, ret;\n\tstruct rv3028_data *rv3028 = clkout_hw_to_rv3028(hw);\n\n\tret = regmap_read(rv3028->regmap, RV3028_CLKOUT, &clkout);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tclkout &= RV3028_CLKOUT_FD_MASK;\n\treturn clkout_rates[clkout];\n}\n\nstatic long rv3028_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] <= rate)\n\t\t\treturn clkout_rates[i];\n\n\treturn 0;\n}\n\nstatic int rv3028_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tint i, ret;\n\tu32 enabled;\n\tstruct rv3028_data *rv3028 = clkout_hw_to_rv3028(hw);\n\n\tret = regmap_read(rv3028->regmap, RV3028_CLKOUT, &enabled);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(rv3028->regmap, RV3028_CLKOUT, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tenabled &= RV3028_CLKOUT_CLKOE;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] == rate)\n\t\t\treturn rv3028_update_cfg(rv3028, RV3028_CLKOUT, 0xff,\n\t\t\t\t\t\t RV3028_CLKOUT_CLKSY | enabled | i);\n\n\treturn -EINVAL;\n}\n\nstatic int rv3028_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct rv3028_data *rv3028 = clkout_hw_to_rv3028(hw);\n\n\treturn regmap_write(rv3028->regmap, RV3028_CLKOUT,\n\t\t\t    RV3028_CLKOUT_CLKSY | RV3028_CLKOUT_CLKOE);\n}\n\nstatic void rv3028_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct rv3028_data *rv3028 = clkout_hw_to_rv3028(hw);\n\n\tregmap_write(rv3028->regmap, RV3028_CLKOUT, 0x0);\n\tregmap_update_bits(rv3028->regmap, RV3028_STATUS,\n\t\t\t   RV3028_STATUS_CLKF, 0);\n}\n\nstatic int rv3028_clkout_is_prepared(struct clk_hw *hw)\n{\n\tint clkout, ret;\n\tstruct rv3028_data *rv3028 = clkout_hw_to_rv3028(hw);\n\n\tret = regmap_read(rv3028->regmap, RV3028_CLKOUT, &clkout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(clkout & RV3028_CLKOUT_CLKOE);\n}\n\nstatic const struct clk_ops rv3028_clkout_ops = {\n\t.prepare = rv3028_clkout_prepare,\n\t.unprepare = rv3028_clkout_unprepare,\n\t.is_prepared = rv3028_clkout_is_prepared,\n\t.recalc_rate = rv3028_clkout_recalc_rate,\n\t.round_rate = rv3028_clkout_round_rate,\n\t.set_rate = rv3028_clkout_set_rate,\n};\n\nstatic int rv3028_clkout_register_clk(struct rv3028_data *rv3028,\n\t\t\t\t      struct i2c_client *client)\n{\n\tint ret;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tstruct device_node *node = client->dev.of_node;\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_STATUS,\n\t\t\t\t RV3028_STATUS_CLKF, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit.name = \"rv3028-clkout\";\n\tinit.ops = &rv3028_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\trv3028->clkout_hw.init = &init;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = devm_clk_register(&client->dev, &rv3028->clkout_hw);\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct rtc_class_ops rv3028_rtc_ops = {\n\t.read_time = rv3028_get_time,\n\t.set_time = rv3028_set_time,\n\t.read_alarm = rv3028_get_alarm,\n\t.set_alarm = rv3028_set_alarm,\n\t.alarm_irq_enable = rv3028_alarm_irq_enable,\n\t.read_offset = rv3028_read_offset,\n\t.set_offset = rv3028_set_offset,\n\t.ioctl = rv3028_ioctl,\n\t.param_get = rv3028_param_get,\n\t.param_set = rv3028_param_set,\n};\n\nstatic const struct regmap_config regmap_config = {\n        .reg_bits = 8,\n        .val_bits = 8,\n        .max_register = 0x37,\n};\n\nstatic u8 rv3028_set_trickle_charger(struct rv3028_data *rv3028,\n\t\t\t\t     struct i2c_client *client)\n{\n\tint ret, val_old, val;\n\tu32 ohms, chargeable;\n\n\tret = regmap_read(rv3028->regmap, RV3028_BACKUP, &val_old);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval_old = val_old & (RV3028_BACKUP_TCE | RV3028_BACKUP_TCR_MASK);\n\tval = val_old;\n\n\t \n\tif (!device_property_read_u32(&client->dev, \"trickle-resistor-ohms\",\n\t\t\t\t      &ohms)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rv3028_trickle_resistors); i++)\n\t\t\tif (ohms == rv3028_trickle_resistors[i])\n\t\t\t\tbreak;\n\n\t\tif (i < ARRAY_SIZE(rv3028_trickle_resistors)) {\n\t\t\t \n\t\t\tval = RV3028_BACKUP_TCE | i;\n\t\t} else {\n\t\t\tdev_warn(&client->dev, \"invalid trickle resistor value\\n\");\n\t\t}\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"aux-voltage-chargeable\",\n\t\t\t\t      &chargeable)) {\n\t\tswitch (chargeable) {\n\t\tcase 0:\n\t\t\tval &= ~RV3028_BACKUP_TCE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval |= RV3028_BACKUP_TCE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"unsupported aux-voltage-chargeable value\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (val_old != val) {\n\t\tret = rv3028_update_cfg(rv3028, RV3028_BACKUP, RV3028_BACKUP_TCE |\n\t\t\t\t\t\tRV3028_BACKUP_TCR_MASK, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rv3028_probe(struct i2c_client *client)\n{\n\tstruct rv3028_data *rv3028;\n\tint ret, status;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"rv3028_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = 2,\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.reg_read = rv3028_nvram_read,\n\t\t.reg_write = rv3028_nvram_write,\n\t};\n\tstruct nvmem_config eeprom_cfg = {\n\t\t.name = \"rv3028_eeprom\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = 43,\n\t\t.type = NVMEM_TYPE_EEPROM,\n\t\t.reg_read = rv3028_eeprom_read,\n\t\t.reg_write = rv3028_eeprom_write,\n\t};\n\n\trv3028 = devm_kzalloc(&client->dev, sizeof(struct rv3028_data),\n\t\t\t      GFP_KERNEL);\n\tif (!rv3028)\n\t\treturn -ENOMEM;\n\n\trv3028->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(rv3028->regmap))\n\t\treturn PTR_ERR(rv3028->regmap);\n\n\ti2c_set_clientdata(client, rv3028);\n\n\tret = regmap_read(rv3028->regmap, RV3028_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & RV3028_STATUS_AF)\n\t\tdev_warn(&client->dev, \"An alarm may have been missed.\\n\");\n\n\trv3028->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rv3028->rtc))\n\t\treturn PTR_ERR(rv3028->rtc);\n\n\tif (client->irq > 0) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tif (dev_fwnode(&client->dev))\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = IRQF_TRIGGER_LOW;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, rv3028_handle_irq,\n\t\t\t\t\t\tflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"rv3028\", rv3028);\n\t\tif (ret) {\n\t\t\tdev_warn(&client->dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\tif (!client->irq)\n\t\tclear_bit(RTC_FEATURE_ALARM, rv3028->rtc->features);\n\n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL1,\n\t\t\t\t RV3028_CTRL1_WADA, RV3028_CTRL1_WADA);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(rv3028->regmap, RV3028_CTRL2,\n\t\t\t\t RV3028_CTRL2_EIE | RV3028_CTRL2_TSE,\n\t\t\t\t RV3028_CTRL2_EIE | RV3028_CTRL2_TSE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv3028_set_trickle_charger(rv3028, client);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtc_add_group(rv3028->rtc, &rv3028_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(RTC_FEATURE_BACKUP_SWITCH_MODE, rv3028->rtc->features);\n\n\trv3028->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trv3028->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\trv3028->rtc->ops = &rv3028_rtc_ops;\n\tret = devm_rtc_register_device(rv3028->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tnvmem_cfg.priv = rv3028->regmap;\n\tdevm_rtc_nvmem_register(rv3028->rtc, &nvmem_cfg);\n\teeprom_cfg.priv = rv3028;\n\tdevm_rtc_nvmem_register(rv3028->rtc, &eeprom_cfg);\n\n\trv3028->rtc->max_user_freq = 1;\n\n#ifdef CONFIG_COMMON_CLK\n\trv3028_clkout_register_clk(rv3028, client);\n#endif\n\treturn 0;\n}\n\nstatic const struct acpi_device_id rv3028_i2c_acpi_match[] = {\n\t{ \"MCRY3028\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rv3028_i2c_acpi_match);\n\nstatic const __maybe_unused struct of_device_id rv3028_of_match[] = {\n\t{ .compatible = \"microcrystal,rv3028\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rv3028_of_match);\n\nstatic const struct i2c_device_id rv3028_id_table[] = {\n\t{ .name = \"rv3028\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rv3028_id_table);\n\nstatic struct i2c_driver rv3028_driver = {\n\t.driver = {\n\t\t.name = \"rtc-rv3028\",\n\t\t.acpi_match_table = rv3028_i2c_acpi_match,\n\t\t.of_match_table = of_match_ptr(rv3028_of_match),\n\t},\n\t.id_table\t= rv3028_id_table,\n\t.probe\t\t= rv3028_probe,\n};\nmodule_i2c_driver(rv3028_driver);\n\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_DESCRIPTION(\"Micro Crystal RV3028 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}