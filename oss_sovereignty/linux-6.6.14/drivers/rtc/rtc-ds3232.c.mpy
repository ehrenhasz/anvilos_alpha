{
  "module_name": "rtc-ds3232.c",
  "hash_id": "92e5a2f7f4bda5f22bb94fd13cd8bc9a4b30ae93a15466b90c4006999105e3df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds3232.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/hwmon.h>\n\n#define DS3232_REG_SECONDS      0x00\n#define DS3232_REG_MINUTES      0x01\n#define DS3232_REG_HOURS        0x02\n#define DS3232_REG_AMPM         0x02\n#define DS3232_REG_DAY          0x03\n#define DS3232_REG_DATE         0x04\n#define DS3232_REG_MONTH        0x05\n#define DS3232_REG_CENTURY      0x05\n#define DS3232_REG_YEAR         0x06\n#define DS3232_REG_ALARM1       0x07        \n#define DS3232_REG_ALARM2       0x0B        \n#define DS3232_REG_CR           0x0E        \n#       define DS3232_REG_CR_nEOSC   0x80\n#       define DS3232_REG_CR_INTCN   0x04\n#       define DS3232_REG_CR_A2IE    0x02\n#       define DS3232_REG_CR_A1IE    0x01\n\n#define DS3232_REG_SR           0x0F        \n#       define DS3232_REG_SR_OSF     0x80\n#       define DS3232_REG_SR_BSY     0x04\n#       define DS3232_REG_SR_A2F     0x02\n#       define DS3232_REG_SR_A1F     0x01\n\n#define DS3232_REG_TEMPERATURE\t0x11\n#define DS3232_REG_SRAM_START   0x14\n#define DS3232_REG_SRAM_END     0xFF\n\n#define DS3232_REG_SRAM_SIZE    236\n\nstruct ds3232 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tint irq;\n\tstruct rtc_device *rtc;\n\n\tbool suspended;\n};\n\nstatic int ds3232_check_rtc_status(struct device *dev)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint ret = 0;\n\tint control, stat;\n\n\tret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stat & DS3232_REG_SR_OSF)\n\t\tdev_warn(dev,\n\t\t\t\t\"oscillator discontinuity flagged, \"\n\t\t\t\t\"time unreliable\\n\");\n\n\tstat &= ~(DS3232_REG_SR_OSF | DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);\n\n\tret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\tif (ret)\n\t\treturn ret;\n\n\tcontrol &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);\n\tcontrol |= DS3232_REG_CR_INTCN;\n\n\treturn regmap_write(ds3232->regmap, DS3232_REG_CR, control);\n}\n\nstatic int ds3232_read_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint ret;\n\tu8 buf[7];\n\tunsigned int year, month, day, hour, minute, second;\n\tunsigned int week, twelve_hr, am_pm;\n\tunsigned int century, add_century = 0;\n\n\tret = regmap_bulk_read(ds3232->regmap, DS3232_REG_SECONDS, buf, 7);\n\tif (ret)\n\t\treturn ret;\n\n\tsecond = buf[0];\n\tminute = buf[1];\n\thour = buf[2];\n\tweek = buf[3];\n\tday = buf[4];\n\tmonth = buf[5];\n\tyear = buf[6];\n\n\t \n\n\ttwelve_hr = hour & 0x40;\n\tam_pm = hour & 0x20;\n\tcentury = month & 0x80;\n\n\t \n\n\ttime->tm_sec = bcd2bin(second);\n\ttime->tm_min = bcd2bin(minute);\n\tif (twelve_hr) {\n\t\t \n\t\tif (am_pm)\n\t\t\ttime->tm_hour = bcd2bin(hour & 0x1F) + 12;\n\t\telse\n\t\t\ttime->tm_hour = bcd2bin(hour & 0x1F);\n\t} else {\n\t\ttime->tm_hour = bcd2bin(hour);\n\t}\n\n\t \n\ttime->tm_wday = bcd2bin(week) - 1;\n\ttime->tm_mday = bcd2bin(day);\n\t \n\ttime->tm_mon = bcd2bin(month & 0x7F) - 1;\n\tif (century)\n\t\tadd_century = 100;\n\n\ttime->tm_year = bcd2bin(year) + add_century;\n\n\treturn 0;\n}\n\nstatic int ds3232_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tu8 buf[7];\n\n\t \n\n\tbuf[0] = bin2bcd(time->tm_sec);\n\tbuf[1] = bin2bcd(time->tm_min);\n\tbuf[2] = bin2bcd(time->tm_hour);\n\t \n\tbuf[3] = bin2bcd(time->tm_wday + 1);\n\tbuf[4] = bin2bcd(time->tm_mday);  \n\t \n\tbuf[5] = bin2bcd(time->tm_mon + 1);\n\tif (time->tm_year >= 100) {\n\t\tbuf[5] |= 0x80;\n\t\tbuf[6] = bin2bcd(time->tm_year - 100);\n\t} else {\n\t\tbuf[6] = bin2bcd(time->tm_year);\n\t}\n\n\treturn regmap_bulk_write(ds3232->regmap, DS3232_REG_SECONDS, buf, 7);\n}\n\n \nstatic int ds3232_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint control, stat;\n\tint ret;\n\tu8 buf[4];\n\n\tret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\n\tif (ret)\n\t\tgoto out;\n\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\tif (ret)\n\t\tgoto out;\n\tret = regmap_bulk_read(ds3232->regmap, DS3232_REG_ALARM1, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\n\talarm->time.tm_sec = bcd2bin(buf[0] & 0x7F);\n\talarm->time.tm_min = bcd2bin(buf[1] & 0x7F);\n\talarm->time.tm_hour = bcd2bin(buf[2] & 0x7F);\n\talarm->time.tm_mday = bcd2bin(buf[3] & 0x7F);\n\n\talarm->enabled = !!(control & DS3232_REG_CR_A1IE);\n\talarm->pending = !!(stat & DS3232_REG_SR_A1F);\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic int ds3232_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint control, stat;\n\tint ret;\n\tu8 buf[4];\n\n\tif (ds3232->irq <= 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = bin2bcd(alarm->time.tm_sec);\n\tbuf[1] = bin2bcd(alarm->time.tm_min);\n\tbuf[2] = bin2bcd(alarm->time.tm_hour);\n\tbuf[3] = bin2bcd(alarm->time.tm_mday);\n\n\t \n\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\tif (ret)\n\t\tgoto out;\n\tcontrol &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);\n\tret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\n\tif (ret)\n\t\tgoto out;\n\tstat &= ~(DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);\n\tret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_bulk_write(ds3232->regmap, DS3232_REG_ALARM1, buf, 4);\n\tif (ret)\n\t\tgoto out;\n\n\tif (alarm->enabled) {\n\t\tcontrol |= DS3232_REG_CR_A1IE;\n\t\tret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ds3232_update_alarm(struct device *dev, unsigned int enabled)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint control;\n\tint ret;\n\n\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enabled)\n\t\t \n\t\tcontrol |= DS3232_REG_CR_A1IE;\n\telse\n\t\t \n\t\tcontrol &= ~(DS3232_REG_CR_A1IE);\n\tret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\n\n\treturn ret;\n}\n\n \nstatic int ds3232_hwmon_read_temp(struct device *dev, long int *mC)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tu8 temp_buf[2];\n\ts16 temp;\n\tint ret;\n\n\tret = regmap_bulk_read(ds3232->regmap, DS3232_REG_TEMPERATURE, temp_buf,\n\t\t\t       sizeof(temp_buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttemp = (temp_buf[0] << 8) | temp_buf[1];\n\ttemp >>= 6;\n\t*mC = temp * 250;\n\n\treturn 0;\n}\n\nstatic umode_t ds3232_hwmon_is_visible(const void *data,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ds3232_hwmon_read(struct device *dev,\n\t\t\t     enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *temp)\n{\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\terr = ds3232_hwmon_read_temp(dev, temp);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic u32 ds3232_hwmon_chip_config[] = {\n\tHWMON_C_REGISTER_TZ,\n\t0\n};\n\nstatic const struct hwmon_channel_info ds3232_hwmon_chip = {\n\t.type = hwmon_chip,\n\t.config = ds3232_hwmon_chip_config,\n};\n\nstatic u32 ds3232_hwmon_temp_config[] = {\n\tHWMON_T_INPUT,\n\t0\n};\n\nstatic const struct hwmon_channel_info ds3232_hwmon_temp = {\n\t.type = hwmon_temp,\n\t.config = ds3232_hwmon_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const ds3232_hwmon_info[] = {\n\t&ds3232_hwmon_chip,\n\t&ds3232_hwmon_temp,\n\tNULL\n};\n\nstatic const struct hwmon_ops ds3232_hwmon_hwmon_ops = {\n\t.is_visible = ds3232_hwmon_is_visible,\n\t.read = ds3232_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info ds3232_hwmon_chip_info = {\n\t.ops = &ds3232_hwmon_hwmon_ops,\n\t.info = ds3232_hwmon_info,\n};\n\nstatic void ds3232_hwmon_register(struct device *dev, const char *name)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tstruct device *hwmon_dev;\n\n\tif (!IS_ENABLED(CONFIG_RTC_DRV_DS3232_HWMON))\n\t\treturn;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, name, ds3232,\n\t\t\t\t\t\t\t&ds3232_hwmon_chip_info,\n\t\t\t\t\t\t\tNULL);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tdev_err(dev, \"unable to register hwmon device %ld\\n\",\n\t\t\tPTR_ERR(hwmon_dev));\n\t}\n}\n\nstatic int ds3232_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\n\tif (ds3232->irq <= 0)\n\t\treturn -EINVAL;\n\n\treturn ds3232_update_alarm(dev, enabled);\n}\n\nstatic irqreturn_t ds3232_irq(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\tint ret;\n\tint stat, control;\n\n\trtc_lock(ds3232->rtc);\n\n\tret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (stat & DS3232_REG_SR_A1F) {\n\t\tret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\n\t\tif (ret) {\n\t\t\tdev_warn(ds3232->dev,\n\t\t\t\t \"Read Control Register error %d\\n\", ret);\n\t\t} else {\n\t\t\t \n\t\t\tcontrol &= ~(DS3232_REG_CR_A1IE);\n\t\t\tret = regmap_write(ds3232->regmap, DS3232_REG_CR,\n\t\t\t\t\t   control);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(ds3232->dev,\n\t\t\t\t\t \"Write Control Register error %d\\n\",\n\t\t\t\t\t ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tstat &= ~DS3232_REG_SR_A1F;\n\t\t\tret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(ds3232->dev,\n\t\t\t\t\t \"Write Status Register error %d\\n\",\n\t\t\t\t\t ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\trtc_update_irq(ds3232->rtc, 1, RTC_AF | RTC_IRQF);\n\t\t}\n\t}\n\nunlock:\n\trtc_unlock(ds3232->rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops ds3232_rtc_ops = {\n\t.read_time = ds3232_read_time,\n\t.set_time = ds3232_set_time,\n\t.read_alarm = ds3232_read_alarm,\n\t.set_alarm = ds3232_set_alarm,\n\t.alarm_irq_enable = ds3232_alarm_irq_enable,\n};\n\nstatic int ds3232_nvmem_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct regmap *ds3232_regmap = (struct regmap *)priv;\n\n\treturn regmap_bulk_read(ds3232_regmap, DS3232_REG_SRAM_START + offset,\n\t\t\t\tval, bytes);\n}\n\nstatic int ds3232_nvmem_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct regmap *ds3232_regmap = (struct regmap *)priv;\n\n\treturn regmap_bulk_write(ds3232_regmap, DS3232_REG_SRAM_START + offset,\n\t\t\t\t val, bytes);\n}\n\nstatic int ds3232_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t\tconst char *name)\n{\n\tstruct ds3232 *ds3232;\n\tint ret;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"ds3232_sram\",\n\t\t.stride = 1,\n\t\t.size = DS3232_REG_SRAM_SIZE,\n\t\t.word_size = 1,\n\t\t.reg_read = ds3232_nvmem_read,\n\t\t.reg_write = ds3232_nvmem_write,\n\t\t.priv = regmap,\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED\n\t};\n\n\tds3232 = devm_kzalloc(dev, sizeof(*ds3232), GFP_KERNEL);\n\tif (!ds3232)\n\t\treturn -ENOMEM;\n\n\tds3232->regmap = regmap;\n\tds3232->irq = irq;\n\tds3232->dev = dev;\n\tdev_set_drvdata(dev, ds3232);\n\n\tret = ds3232_check_rtc_status(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ds3232->irq > 0)\n\t\tdevice_init_wakeup(dev, 1);\n\n\tds3232_hwmon_register(dev, name);\n\n\tds3232->rtc = devm_rtc_device_register(dev, name, &ds3232_rtc_ops,\n\t\t\t\t\t\tTHIS_MODULE);\n\tif (IS_ERR(ds3232->rtc))\n\t\treturn PTR_ERR(ds3232->rtc);\n\n\tret = devm_rtc_nvmem_register(ds3232->rtc, &nvmem_cfg);\n\tif(ret)\n\t\treturn ret;\n\n\tif (ds3232->irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, ds3232->irq, NULL,\n\t\t\t\t\t\tds3232_irq,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\tname, dev);\n\t\tif (ret) {\n\t\t\tdevice_set_wakeup_capable(dev, 0);\n\t\t\tds3232->irq = 0;\n\t\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ds3232_suspend(struct device *dev)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (enable_irq_wake(ds3232->irq))\n\t\t\tdev_warn_once(dev, \"Cannot set wakeup source\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3232_resume(struct device *dev)\n{\n\tstruct ds3232 *ds3232 = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(ds3232->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops ds3232_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ds3232_suspend, ds3232_resume)\n};\n\n#if IS_ENABLED(CONFIG_I2C)\n\nstatic int ds3232_i2c_probe(struct i2c_client *client)\n{\n\tstruct regmap *regmap;\n\tstatic const struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = DS3232_REG_SRAM_END,\n\t};\n\n\tregmap = devm_regmap_init_i2c(client, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"%s: regmap allocation failed: %ld\\n\",\n\t\t\t__func__, PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn ds3232_probe(&client->dev, regmap, client->irq, client->name);\n}\n\nstatic const struct i2c_device_id ds3232_id[] = {\n\t{ \"ds3232\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds3232_id);\n\nstatic const  __maybe_unused struct of_device_id ds3232_of_match[] = {\n\t{ .compatible = \"dallas,ds3232\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ds3232_of_match);\n\nstatic struct i2c_driver ds3232_driver = {\n\t.driver = {\n\t\t.name = \"rtc-ds3232\",\n\t\t.of_match_table = of_match_ptr(ds3232_of_match),\n\t\t.pm\t= &ds3232_pm_ops,\n\t},\n\t.probe = ds3232_i2c_probe,\n\t.id_table = ds3232_id,\n};\n\nstatic int ds3232_register_driver(void)\n{\n\treturn i2c_add_driver(&ds3232_driver);\n}\n\nstatic void ds3232_unregister_driver(void)\n{\n\ti2c_del_driver(&ds3232_driver);\n}\n\n#else\n\nstatic int ds3232_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void ds3232_unregister_driver(void)\n{\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_SPI_MASTER)\n\nstatic int ds3234_probe(struct spi_device *spi)\n{\n\tint res;\n\tunsigned int tmp;\n\tstatic const struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = DS3232_REG_SRAM_END,\n\t\t.write_flag_mask = 0x80,\n\t};\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_spi(spi, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"%s: regmap allocation failed: %ld\\n\",\n\t\t\t__func__, PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tspi->mode = SPI_MODE_3;\n\tspi->bits_per_word = 8;\n\tspi_setup(spi);\n\n\tres = regmap_read(regmap, DS3232_REG_SECONDS, &tmp);\n\tif (res)\n\t\treturn res;\n\n\t \n\tres = regmap_read(regmap, DS3232_REG_CR, &tmp);\n\tif (res)\n\t\treturn res;\n\tres = regmap_write(regmap, DS3232_REG_CR, tmp & 0x1c);\n\tif (res)\n\t\treturn res;\n\n\tres = regmap_read(regmap, DS3232_REG_SR, &tmp);\n\tif (res)\n\t\treturn res;\n\tres = regmap_write(regmap, DS3232_REG_SR, tmp & 0x88);\n\tif (res)\n\t\treturn res;\n\n\t \n\tres = regmap_read(regmap, DS3232_REG_CR, &tmp);\n\tif (res)\n\t\treturn res;\n\tdev_info(&spi->dev, \"Control Reg: 0x%02x\\n\", tmp);\n\n\tres = regmap_read(regmap, DS3232_REG_SR, &tmp);\n\tif (res)\n\t\treturn res;\n\tdev_info(&spi->dev, \"Ctrl/Stat Reg: 0x%02x\\n\", tmp);\n\n\treturn ds3232_probe(&spi->dev, regmap, spi->irq, \"ds3234\");\n}\n\nstatic struct spi_driver ds3234_driver = {\n\t.driver = {\n\t\t.name\t = \"ds3234\",\n\t},\n\t.probe\t = ds3234_probe,\n};\n\nstatic int ds3234_register_driver(void)\n{\n\treturn spi_register_driver(&ds3234_driver);\n}\n\nstatic void ds3234_unregister_driver(void)\n{\n\tspi_unregister_driver(&ds3234_driver);\n}\n\n#else\n\nstatic int ds3234_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void ds3234_unregister_driver(void)\n{\n}\n\n#endif\n\nstatic int __init ds323x_init(void)\n{\n\tint ret;\n\n\tret = ds3232_register_driver();\n\tif (ret) {\n\t\tpr_err(\"Failed to register ds3232 driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ds3234_register_driver();\n\tif (ret) {\n\t\tpr_err(\"Failed to register ds3234 driver: %d\\n\", ret);\n\t\tds3232_unregister_driver();\n\t}\n\n\treturn ret;\n}\nmodule_init(ds323x_init)\n\nstatic void __exit ds323x_exit(void)\n{\n\tds3234_unregister_driver();\n\tds3232_unregister_driver();\n}\nmodule_exit(ds323x_exit)\n\nMODULE_AUTHOR(\"Srikanth Srinivasan <srikanth.srinivasan@freescale.com>\");\nMODULE_AUTHOR(\"Dennis Aberilla <denzzzhome@yahoo.com>\");\nMODULE_DESCRIPTION(\"Maxim/Dallas DS3232/DS3234 RTC Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:ds3234\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}