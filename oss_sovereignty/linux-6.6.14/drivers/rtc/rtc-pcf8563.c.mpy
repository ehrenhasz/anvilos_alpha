{
  "module_name": "rtc-pcf8563.c",
  "hash_id": "07ddf7fec297c1443d36dec7e809109ca8531e3d4fdc63dff53079dcee089878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf8563.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/err.h>\n\n#define PCF8563_REG_ST1\t\t0x00  \n#define PCF8563_REG_ST2\t\t0x01\n#define PCF8563_BIT_AIE\t\tBIT(1)\n#define PCF8563_BIT_AF\t\tBIT(3)\n#define PCF8563_BITS_ST2_N\t(7 << 5)\n\n#define PCF8563_REG_SC\t\t0x02  \n#define PCF8563_REG_MN\t\t0x03\n#define PCF8563_REG_HR\t\t0x04\n#define PCF8563_REG_DM\t\t0x05\n#define PCF8563_REG_DW\t\t0x06\n#define PCF8563_REG_MO\t\t0x07\n#define PCF8563_REG_YR\t\t0x08\n\n#define PCF8563_REG_AMN\t\t0x09  \n\n#define PCF8563_REG_CLKO\t\t0x0D  \n#define PCF8563_REG_CLKO_FE\t\t0x80  \n#define PCF8563_REG_CLKO_F_MASK\t\t0x03  \n#define PCF8563_REG_CLKO_F_32768HZ\t0x00\n#define PCF8563_REG_CLKO_F_1024HZ\t0x01\n#define PCF8563_REG_CLKO_F_32HZ\t\t0x02\n#define PCF8563_REG_CLKO_F_1HZ\t\t0x03\n\n#define PCF8563_REG_TMRC\t0x0E  \n#define PCF8563_TMRC_ENABLE\tBIT(7)\n#define PCF8563_TMRC_4096\t0\n#define PCF8563_TMRC_64\t\t1\n#define PCF8563_TMRC_1\t\t2\n#define PCF8563_TMRC_1_60\t3\n#define PCF8563_TMRC_MASK\t3\n\n#define PCF8563_REG_TMR\t\t0x0F  \n\n#define PCF8563_SC_LV\t\t0x80  \n#define PCF8563_MO_C\t\t0x80  \n\nstatic struct i2c_driver pcf8563_driver;\n\nstruct pcf8563 {\n\tstruct rtc_device *rtc;\n\t \n\tint c_polarity;\t \n\n\tstruct i2c_client *client;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw\t\tclkout_hw;\n#endif\n};\n\nstatic int pcf8563_read_block_data(struct i2c_client *client, unsigned char reg,\n\t\t\t\t   unsigned char length, unsigned char *buf)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = length,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\tif ((i2c_transfer(client->adapter, msgs, 2)) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf8563_write_block_data(struct i2c_client *client,\n\t\t\t\t   unsigned char reg, unsigned char length,\n\t\t\t\t   unsigned char *buf)\n{\n\tint i, err;\n\n\tfor (i = 0; i < length; i++) {\n\t\tunsigned char data[2] = { reg + i, buf[i] };\n\n\t\terr = i2c_master_send(client, data, sizeof(data));\n\t\tif (err != sizeof(data)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: err=%d addr=%02x, data=%02x\\n\",\n\t\t\t\t__func__, err, data[0], data[1]);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf8563_set_alarm_mode(struct i2c_client *client, bool on)\n{\n\tunsigned char buf;\n\tint err;\n\n\terr = pcf8563_read_block_data(client, PCF8563_REG_ST2, 1, &buf);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (on)\n\t\tbuf |= PCF8563_BIT_AIE;\n\telse\n\t\tbuf &= ~PCF8563_BIT_AIE;\n\n\tbuf &= ~(PCF8563_BIT_AF | PCF8563_BITS_ST2_N);\n\n\terr = pcf8563_write_block_data(client, PCF8563_REG_ST2, 1, &buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s: write error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf8563_get_alarm_mode(struct i2c_client *client, unsigned char *en,\n\t\t\t\t  unsigned char *pen)\n{\n\tunsigned char buf;\n\tint err;\n\n\terr = pcf8563_read_block_data(client, PCF8563_REG_ST2, 1, &buf);\n\tif (err)\n\t\treturn err;\n\n\tif (en)\n\t\t*en = !!(buf & PCF8563_BIT_AIE);\n\tif (pen)\n\t\t*pen = !!(buf & PCF8563_BIT_AF);\n\n\treturn 0;\n}\n\nstatic irqreturn_t pcf8563_irq(int irq, void *dev_id)\n{\n\tstruct pcf8563 *pcf8563 = i2c_get_clientdata(dev_id);\n\tint err;\n\tchar pending;\n\n\terr = pcf8563_get_alarm_mode(pcf8563->client, NULL, &pending);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (pending) {\n\t\trtc_update_irq(pcf8563->rtc, 1, RTC_IRQF | RTC_AF);\n\t\tpcf8563_set_alarm_mode(pcf8563->client, 1);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int pcf8563_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf8563 *pcf8563 = i2c_get_clientdata(client);\n\tunsigned char buf[9];\n\tint err;\n\n\terr = pcf8563_read_block_data(client, PCF8563_REG_ST1, 9, buf);\n\tif (err)\n\t\treturn err;\n\n\tif (buf[PCF8563_REG_SC] & PCF8563_SC_LV) {\n\t\tdev_err(&client->dev,\n\t\t\t\"low voltage detected, date/time is not reliable.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"%s: raw data is st1=%02x, st2=%02x, sec=%02x, min=%02x, hr=%02x, \"\n\t\t\"mday=%02x, wday=%02x, mon=%02x, year=%02x\\n\",\n\t\t__func__,\n\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\tbuf[4], buf[5], buf[6], buf[7],\n\t\tbuf[8]);\n\n\n\ttm->tm_sec = bcd2bin(buf[PCF8563_REG_SC] & 0x7F);\n\ttm->tm_min = bcd2bin(buf[PCF8563_REG_MN] & 0x7F);\n\ttm->tm_hour = bcd2bin(buf[PCF8563_REG_HR] & 0x3F);  \n\ttm->tm_mday = bcd2bin(buf[PCF8563_REG_DM] & 0x3F);\n\ttm->tm_wday = buf[PCF8563_REG_DW] & 0x07;\n\ttm->tm_mon = bcd2bin(buf[PCF8563_REG_MO] & 0x1F) - 1;  \n\ttm->tm_year = bcd2bin(buf[PCF8563_REG_YR]) + 100;\n\t \n\tpcf8563->c_polarity = (buf[PCF8563_REG_MO] & PCF8563_MO_C) ?\n\t\t(tm->tm_year >= 100) : (tm->tm_year < 100);\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int pcf8563_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf8563 *pcf8563 = i2c_get_clientdata(client);\n\tunsigned char buf[9];\n\n\tdev_dbg(&client->dev, \"%s: secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\t \n\tbuf[PCF8563_REG_SC] = bin2bcd(tm->tm_sec);\n\tbuf[PCF8563_REG_MN] = bin2bcd(tm->tm_min);\n\tbuf[PCF8563_REG_HR] = bin2bcd(tm->tm_hour);\n\n\tbuf[PCF8563_REG_DM] = bin2bcd(tm->tm_mday);\n\n\t \n\tbuf[PCF8563_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[PCF8563_REG_YR] = bin2bcd(tm->tm_year - 100);\n\tif (pcf8563->c_polarity ? (tm->tm_year >= 100) : (tm->tm_year < 100))\n\t\tbuf[PCF8563_REG_MO] |= PCF8563_MO_C;\n\n\tbuf[PCF8563_REG_DW] = tm->tm_wday & 0x07;\n\n\treturn pcf8563_write_block_data(client, PCF8563_REG_SC,\n\t\t\t\t9 - PCF8563_REG_SC, buf + PCF8563_REG_SC);\n}\n\nstatic int pcf8563_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = i2c_smbus_read_byte_data(client, PCF8563_REG_SC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn put_user(ret & PCF8563_SC_LV ? RTC_VL_DATA_INVALID : 0,\n\t\t\t\t(unsigned int __user *)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int pcf8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[4];\n\tint err;\n\n\terr = pcf8563_read_block_data(client, PCF8563_REG_AMN, 4, buf);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(&client->dev,\n\t\t\"%s: raw data is min=%02x, hr=%02x, mday=%02x, wday=%02x\\n\",\n\t\t__func__, buf[0], buf[1], buf[2], buf[3]);\n\n\ttm->time.tm_sec = 0;\n\ttm->time.tm_min = bcd2bin(buf[0] & 0x7F);\n\ttm->time.tm_hour = bcd2bin(buf[1] & 0x3F);\n\ttm->time.tm_mday = bcd2bin(buf[2] & 0x3F);\n\ttm->time.tm_wday = bcd2bin(buf[3] & 0x7);\n\n\terr = pcf8563_get_alarm_mode(client, &tm->enabled, &tm->pending);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(&client->dev, \"%s: tm is mins=%d, hours=%d, mday=%d, wday=%d,\"\n\t\t\" enabled=%d, pending=%d\\n\", __func__, tm->time.tm_min,\n\t\ttm->time.tm_hour, tm->time.tm_mday, tm->time.tm_wday,\n\t\ttm->enabled, tm->pending);\n\n\treturn 0;\n}\n\nstatic int pcf8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[4];\n\tint err;\n\n\tbuf[0] = bin2bcd(tm->time.tm_min);\n\tbuf[1] = bin2bcd(tm->time.tm_hour);\n\tbuf[2] = bin2bcd(tm->time.tm_mday);\n\tbuf[3] = tm->time.tm_wday & 0x07;\n\n\terr = pcf8563_write_block_data(client, PCF8563_REG_AMN, 4, buf);\n\tif (err)\n\t\treturn err;\n\n\treturn pcf8563_set_alarm_mode(client, !!tm->enabled);\n}\n\nstatic int pcf8563_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tdev_dbg(dev, \"%s: en=%d\\n\", __func__, enabled);\n\treturn pcf8563_set_alarm_mode(to_i2c_client(dev), !!enabled);\n}\n\n#ifdef CONFIG_COMMON_CLK\n \n\n#define clkout_hw_to_pcf8563(_hw) container_of(_hw, struct pcf8563, clkout_hw)\n\nstatic const int clkout_rates[] = {\n\t32768,\n\t1024,\n\t32,\n\t1,\n};\n\nstatic unsigned long pcf8563_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\n\tstruct i2c_client *client = pcf8563->client;\n\tunsigned char buf;\n\tint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\tbuf &= PCF8563_REG_CLKO_F_MASK;\n\treturn clkout_rates[buf];\n}\n\nstatic long pcf8563_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] <= rate)\n\t\t\treturn clkout_rates[i];\n\n\treturn 0;\n}\n\nstatic int pcf8563_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\n\tstruct i2c_client *client = pcf8563->client;\n\tunsigned char buf;\n\tint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\tint i;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] == rate) {\n\t\t\tbuf &= ~PCF8563_REG_CLKO_F_MASK;\n\t\t\tbuf |= i;\n\t\t\tret = pcf8563_write_block_data(client,\n\t\t\t\t\t\t       PCF8563_REG_CLKO, 1,\n\t\t\t\t\t\t       &buf);\n\t\t\treturn ret;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int pcf8563_clkout_control(struct clk_hw *hw, bool enable)\n{\n\tstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\n\tstruct i2c_client *client = pcf8563->client;\n\tunsigned char buf;\n\tint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable)\n\t\tbuf |= PCF8563_REG_CLKO_FE;\n\telse\n\t\tbuf &= ~PCF8563_REG_CLKO_FE;\n\n\tret = pcf8563_write_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\treturn ret;\n}\n\nstatic int pcf8563_clkout_prepare(struct clk_hw *hw)\n{\n\treturn pcf8563_clkout_control(hw, 1);\n}\n\nstatic void pcf8563_clkout_unprepare(struct clk_hw *hw)\n{\n\tpcf8563_clkout_control(hw, 0);\n}\n\nstatic int pcf8563_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\n\tstruct i2c_client *client = pcf8563->client;\n\tunsigned char buf;\n\tint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(buf & PCF8563_REG_CLKO_FE);\n}\n\nstatic const struct clk_ops pcf8563_clkout_ops = {\n\t.prepare = pcf8563_clkout_prepare,\n\t.unprepare = pcf8563_clkout_unprepare,\n\t.is_prepared = pcf8563_clkout_is_prepared,\n\t.recalc_rate = pcf8563_clkout_recalc_rate,\n\t.round_rate = pcf8563_clkout_round_rate,\n\t.set_rate = pcf8563_clkout_set_rate,\n};\n\nstatic struct clk *pcf8563_clkout_register_clk(struct pcf8563 *pcf8563)\n{\n\tstruct i2c_client *client = pcf8563->client;\n\tstruct device_node *node = client->dev.of_node;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tint ret;\n\tunsigned char buf;\n\n\t \n\tbuf = 0;\n\tret = pcf8563_write_block_data(client, PCF8563_REG_CLKO, 1, &buf);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tinit.name = \"pcf8563-clkout\";\n\tinit.ops = &pcf8563_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tpcf8563->clkout_hw.init = &init;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = devm_clk_register(&client->dev, &pcf8563->clkout_hw);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#endif\n\nstatic const struct rtc_class_ops pcf8563_rtc_ops = {\n\t.ioctl\t\t= pcf8563_rtc_ioctl,\n\t.read_time\t= pcf8563_rtc_read_time,\n\t.set_time\t= pcf8563_rtc_set_time,\n\t.read_alarm\t= pcf8563_rtc_read_alarm,\n\t.set_alarm\t= pcf8563_rtc_set_alarm,\n\t.alarm_irq_enable = pcf8563_irq_enable,\n};\n\nstatic int pcf8563_probe(struct i2c_client *client)\n{\n\tstruct pcf8563 *pcf8563;\n\tint err;\n\tunsigned char buf;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tpcf8563 = devm_kzalloc(&client->dev, sizeof(struct pcf8563),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcf8563)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, pcf8563);\n\tpcf8563->client = client;\n\tdevice_set_wakeup_capable(&client->dev, 1);\n\n\t \n\tbuf = PCF8563_TMRC_1_60;\n\terr = pcf8563_write_block_data(client, PCF8563_REG_TMRC, 1, &buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s: write error\\n\", __func__);\n\t\treturn err;\n\t}\n\n\t \n\tbuf = 0;\n\terr = pcf8563_write_block_data(client, PCF8563_REG_ST2, 1, &buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s: write error\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tpcf8563->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(pcf8563->rtc))\n\t\treturn PTR_ERR(pcf8563->rtc);\n\n\tpcf8563->rtc->ops = &pcf8563_rtc_ops;\n\t \n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, pcf8563->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, pcf8563->rtc->features);\n\tpcf8563->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpcf8563->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tpcf8563->rtc->set_start_time = true;\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\tNULL, pcf8563_irq,\n\t\t\t\tIRQF_SHARED | IRQF_ONESHOT | irqflags,\n\t\t\t\tpcf8563_driver.driver.name, client);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"unable to request IRQ %d\\n\",\n\t\t\t\t\t\t\t\tclient->irq);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tclear_bit(RTC_FEATURE_ALARM, pcf8563->rtc->features);\n\t}\n\n\terr = devm_rtc_register_device(pcf8563->rtc);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_COMMON_CLK\n\t \n\tpcf8563_clkout_register_clk(pcf8563);\n#endif\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id pcf8563_id[] = {\n\t{ \"pcf8563\", 0 },\n\t{ \"rtc8564\", 0 },\n\t{ \"pca8565\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf8563_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pcf8563_of_match[] = {\n\t{ .compatible = \"nxp,pcf8563\" },\n\t{ .compatible = \"epson,rtc8564\" },\n\t{ .compatible = \"microcrystal,rv8564\" },\n\t{ .compatible = \"nxp,pca8565\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pcf8563_of_match);\n#endif\n\nstatic struct i2c_driver pcf8563_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-pcf8563\",\n\t\t.of_match_table = of_match_ptr(pcf8563_of_match),\n\t},\n\t.probe\t\t= pcf8563_probe,\n\t.id_table\t= pcf8563_id,\n};\n\nmodule_i2c_driver(pcf8563_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"Philips PCF8563/Epson RTC8564 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}