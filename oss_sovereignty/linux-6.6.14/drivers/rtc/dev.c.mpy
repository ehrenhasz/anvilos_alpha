{
  "module_name": "dev.c",
  "hash_id": "5cda014e257721389e03abad12994683e9dd37dd4f19c111f812450cfec12a8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/sched/signal.h>\n#include \"rtc-core.h\"\n\nstatic dev_t rtc_devt;\n\n#define RTC_DEV_MAX 16  \n\nstatic int rtc_dev_open(struct inode *inode, struct file *file)\n{\n\tstruct rtc_device *rtc = container_of(inode->i_cdev,\n\t\t\t\t\tstruct rtc_device, char_dev);\n\n\tif (test_and_set_bit_lock(RTC_DEV_BUSY, &rtc->flags))\n\t\treturn -EBUSY;\n\n\tfile->private_data = rtc;\n\n\tspin_lock_irq(&rtc->irq_lock);\n\trtc->irq_data = 0;\n\tspin_unlock_irq(&rtc->irq_lock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n \nstatic void rtc_uie_task(struct work_struct *work)\n{\n\tstruct rtc_device *rtc =\n\t\tcontainer_of(work, struct rtc_device, uie_task);\n\tstruct rtc_time tm;\n\tint num = 0;\n\tint err;\n\n\terr = rtc_read_time(rtc, &tm);\n\n\tspin_lock_irq(&rtc->irq_lock);\n\tif (rtc->stop_uie_polling || err) {\n\t\trtc->uie_task_active = 0;\n\t} else if (rtc->oldsecs != tm.tm_sec) {\n\t\tnum = (tm.tm_sec + 60 - rtc->oldsecs) % 60;\n\t\trtc->oldsecs = tm.tm_sec;\n\t\trtc->uie_timer.expires = jiffies + HZ - (HZ / 10);\n\t\trtc->uie_timer_active = 1;\n\t\trtc->uie_task_active = 0;\n\t\tadd_timer(&rtc->uie_timer);\n\t} else if (schedule_work(&rtc->uie_task) == 0) {\n\t\trtc->uie_task_active = 0;\n\t}\n\tspin_unlock_irq(&rtc->irq_lock);\n\tif (num)\n\t\trtc_handle_legacy_irq(rtc, num, RTC_UF);\n}\n\nstatic void rtc_uie_timer(struct timer_list *t)\n{\n\tstruct rtc_device *rtc = from_timer(rtc, t, uie_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc->irq_lock, flags);\n\trtc->uie_timer_active = 0;\n\trtc->uie_task_active = 1;\n\tif ((schedule_work(&rtc->uie_task) == 0))\n\t\trtc->uie_task_active = 0;\n\tspin_unlock_irqrestore(&rtc->irq_lock, flags);\n}\n\nstatic int clear_uie(struct rtc_device *rtc)\n{\n\tspin_lock_irq(&rtc->irq_lock);\n\tif (rtc->uie_irq_active) {\n\t\trtc->stop_uie_polling = 1;\n\t\tif (rtc->uie_timer_active) {\n\t\t\tspin_unlock_irq(&rtc->irq_lock);\n\t\t\tdel_timer_sync(&rtc->uie_timer);\n\t\t\tspin_lock_irq(&rtc->irq_lock);\n\t\t\trtc->uie_timer_active = 0;\n\t\t}\n\t\tif (rtc->uie_task_active) {\n\t\t\tspin_unlock_irq(&rtc->irq_lock);\n\t\t\tflush_work(&rtc->uie_task);\n\t\t\tspin_lock_irq(&rtc->irq_lock);\n\t\t}\n\t\trtc->uie_irq_active = 0;\n\t}\n\tspin_unlock_irq(&rtc->irq_lock);\n\treturn 0;\n}\n\nstatic int set_uie(struct rtc_device *rtc)\n{\n\tstruct rtc_time tm;\n\tint err;\n\n\terr = rtc_read_time(rtc, &tm);\n\tif (err)\n\t\treturn err;\n\tspin_lock_irq(&rtc->irq_lock);\n\tif (!rtc->uie_irq_active) {\n\t\trtc->uie_irq_active = 1;\n\t\trtc->stop_uie_polling = 0;\n\t\trtc->oldsecs = tm.tm_sec;\n\t\trtc->uie_task_active = 1;\n\t\tif (schedule_work(&rtc->uie_task) == 0)\n\t\t\trtc->uie_task_active = 0;\n\t}\n\trtc->irq_data = 0;\n\tspin_unlock_irq(&rtc->irq_lock);\n\treturn 0;\n}\n\nint rtc_dev_update_irq_enable_emul(struct rtc_device *rtc, unsigned int enabled)\n{\n\tif (enabled)\n\t\treturn set_uie(rtc);\n\telse\n\t\treturn clear_uie(rtc);\n}\nEXPORT_SYMBOL(rtc_dev_update_irq_enable_emul);\n\n#endif  \n\nstatic ssize_t\nrtc_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long data;\n\tssize_t ret;\n\n\tif (count != sizeof(unsigned int) && count < sizeof(unsigned long))\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&rtc->irq_queue, &wait);\n\tdo {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tspin_lock_irq(&rtc->irq_lock);\n\t\tdata = rtc->irq_data;\n\t\trtc->irq_data = 0;\n\t\tspin_unlock_irq(&rtc->irq_lock);\n\n\t\tif (data != 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t} while (1);\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&rtc->irq_queue, &wait);\n\n\tif (ret == 0) {\n\t\tif (sizeof(int) != sizeof(long) &&\n\t\t    count == sizeof(unsigned int))\n\t\t\tret = put_user(data, (unsigned int __user *)buf) ?:\n\t\t\t\tsizeof(unsigned int);\n\t\telse\n\t\t\tret = put_user(data, (unsigned long __user *)buf) ?:\n\t\t\t\tsizeof(unsigned long);\n\t}\n\treturn ret;\n}\n\nstatic __poll_t rtc_dev_poll(struct file *file, poll_table *wait)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\tunsigned long data;\n\n\tpoll_wait(file, &rtc->irq_queue, wait);\n\n\tdata = rtc->irq_data;\n\n\treturn (data != 0) ? (EPOLLIN | EPOLLRDNORM) : 0;\n}\n\nstatic long rtc_dev_ioctl(struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tint err = 0;\n\tstruct rtc_device *rtc = file->private_data;\n\tconst struct rtc_class_ops *ops = rtc->ops;\n\tstruct rtc_time tm;\n\tstruct rtc_wkalrm alarm;\n\tstruct rtc_param param;\n\tvoid __user *uarg = (void __user *)arg;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch (cmd) {\n\tcase RTC_EPOCH_SET:\n\tcase RTC_SET_TIME:\n\tcase RTC_PARAM_SET:\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\terr = -EACCES;\n\t\tbreak;\n\n\tcase RTC_IRQP_SET:\n\t\tif (arg > rtc->max_user_freq && !capable(CAP_SYS_RESOURCE))\n\t\t\terr = -EACCES;\n\t\tbreak;\n\n\tcase RTC_PIE_ON:\n\t\tif (rtc->irq_freq > rtc->max_user_freq &&\n\t\t    !capable(CAP_SYS_RESOURCE))\n\t\t\terr = -EACCES;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tgoto done;\n\n\t \n\n\tswitch (cmd) {\n\tcase RTC_ALM_READ:\n\t\tmutex_unlock(&rtc->ops_lock);\n\n\t\terr = rtc_read_alarm(rtc, &alarm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (copy_to_user(uarg, &alarm.time, sizeof(tm)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\n\tcase RTC_ALM_SET:\n\t\tmutex_unlock(&rtc->ops_lock);\n\n\t\tif (copy_from_user(&alarm.time, uarg, sizeof(tm)))\n\t\t\treturn -EFAULT;\n\n\t\talarm.enabled = 0;\n\t\talarm.pending = 0;\n\t\talarm.time.tm_wday = -1;\n\t\talarm.time.tm_yday = -1;\n\t\talarm.time.tm_isdst = -1;\n\n\t\t \n\t\t{\n\t\t\ttime64_t now, then;\n\n\t\t\terr = rtc_read_time(rtc, &tm);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tnow = rtc_tm_to_time64(&tm);\n\n\t\t\talarm.time.tm_mday = tm.tm_mday;\n\t\t\talarm.time.tm_mon = tm.tm_mon;\n\t\t\talarm.time.tm_year = tm.tm_year;\n\t\t\terr  = rtc_valid_tm(&alarm.time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tthen = rtc_tm_to_time64(&alarm.time);\n\n\t\t\t \n\t\t\tif (then < now) {\n\t\t\t\trtc_time64_to_tm(now + 24 * 60 * 60, &tm);\n\t\t\t\talarm.time.tm_mday = tm.tm_mday;\n\t\t\t\talarm.time.tm_mon = tm.tm_mon;\n\t\t\t\talarm.time.tm_year = tm.tm_year;\n\t\t\t}\n\t\t}\n\n\t\treturn rtc_set_alarm(rtc, &alarm);\n\n\tcase RTC_RD_TIME:\n\t\tmutex_unlock(&rtc->ops_lock);\n\n\t\terr = rtc_read_time(rtc, &tm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (copy_to_user(uarg, &tm, sizeof(tm)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\n\tcase RTC_SET_TIME:\n\t\tmutex_unlock(&rtc->ops_lock);\n\n\t\tif (copy_from_user(&tm, uarg, sizeof(tm)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rtc_set_time(rtc, &tm);\n\n\tcase RTC_PIE_ON:\n\t\terr = rtc_irq_set_state(rtc, 1);\n\t\tbreak;\n\n\tcase RTC_PIE_OFF:\n\t\terr = rtc_irq_set_state(rtc, 0);\n\t\tbreak;\n\n\tcase RTC_AIE_ON:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_alarm_irq_enable(rtc, 1);\n\n\tcase RTC_AIE_OFF:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_alarm_irq_enable(rtc, 0);\n\n\tcase RTC_UIE_ON:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_update_irq_enable(rtc, 1);\n\n\tcase RTC_UIE_OFF:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_update_irq_enable(rtc, 0);\n\n\tcase RTC_IRQP_SET:\n\t\terr = rtc_irq_set_freq(rtc, arg);\n\t\tbreak;\n\tcase RTC_IRQP_READ:\n\t\terr = put_user(rtc->irq_freq, (unsigned long __user *)uarg);\n\t\tbreak;\n\n\tcase RTC_WKALM_SET:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\tif (copy_from_user(&alarm, uarg, sizeof(alarm)))\n\t\t\treturn -EFAULT;\n\n\t\treturn rtc_set_alarm(rtc, &alarm);\n\n\tcase RTC_WKALM_RD:\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\terr = rtc_read_alarm(rtc, &alarm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (copy_to_user(uarg, &alarm, sizeof(alarm)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\n\tcase RTC_PARAM_GET:\n\t\tif (copy_from_user(&param, uarg, sizeof(param))) {\n\t\t\tmutex_unlock(&rtc->ops_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch(param.param) {\n\t\tcase RTC_PARAM_FEATURES:\n\t\t\tif (param.index != 0)\n\t\t\t\terr = -EINVAL;\n\t\t\tparam.uvalue = rtc->features[0];\n\t\t\tbreak;\n\n\t\tcase RTC_PARAM_CORRECTION: {\n\t\t\tlong offset;\n\t\t\tmutex_unlock(&rtc->ops_lock);\n\t\t\tif (param.index != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = rtc_read_offset(rtc, &offset);\n\t\t\tmutex_lock(&rtc->ops_lock);\n\t\t\tif (err == 0)\n\t\t\t\tparam.svalue = offset;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (rtc->ops->param_get)\n\t\t\t\terr = rtc->ops->param_get(rtc->dev.parent, &param);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tif (!err)\n\t\t\tif (copy_to_user(uarg, &param, sizeof(param)))\n\t\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase RTC_PARAM_SET:\n\t\tif (copy_from_user(&param, uarg, sizeof(param))) {\n\t\t\tmutex_unlock(&rtc->ops_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch(param.param) {\n\t\tcase RTC_PARAM_FEATURES:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RTC_PARAM_CORRECTION:\n\t\t\tmutex_unlock(&rtc->ops_lock);\n\t\t\tif (param.index != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn rtc_set_offset(rtc, param.svalue);\n\n\t\tdefault:\n\t\t\tif (rtc->ops->param_set)\n\t\t\t\terr = rtc->ops->param_set(rtc->dev.parent, &param);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (ops->ioctl) {\n\t\t\terr = ops->ioctl(rtc->dev.parent, cmd, arg);\n\t\t\tif (err == -ENOIOCTLCMD)\n\t\t\t\terr = -ENOTTY;\n\t\t} else {\n\t\t\terr = -ENOTTY;\n\t\t}\n\t\tbreak;\n\t}\n\ndone:\n\tmutex_unlock(&rtc->ops_lock);\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n#define RTC_IRQP_SET32\t\t_IOW('p', 0x0c, __u32)\n#define RTC_IRQP_READ32\t\t_IOR('p', 0x0b, __u32)\n#define RTC_EPOCH_SET32\t\t_IOW('p', 0x0e, __u32)\n\nstatic long rtc_dev_compat_ioctl(struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\tvoid __user *uarg = compat_ptr(arg);\n\n\tswitch (cmd) {\n\tcase RTC_IRQP_READ32:\n\t\treturn put_user(rtc->irq_freq, (__u32 __user *)uarg);\n\n\tcase RTC_IRQP_SET32:\n\t\t \n\t\treturn rtc_dev_ioctl(file, RTC_IRQP_SET, arg);\n\n\tcase RTC_EPOCH_SET32:\n\t\t \n\t\treturn rtc_dev_ioctl(file, RTC_EPOCH_SET, arg);\n\t}\n\n\treturn rtc_dev_ioctl(file, cmd, (unsigned long)uarg);\n}\n#endif\n\nstatic int rtc_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &rtc->async_queue);\n}\n\nstatic int rtc_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\n\t \n\n\t \n\trtc_dev_ioctl(file, RTC_UIE_OFF, 0);\n\trtc_update_irq_enable(rtc, 0);\n\trtc_irq_set_state(rtc, 0);\n\n\tclear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);\n\treturn 0;\n}\n\nstatic const struct file_operations rtc_dev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= rtc_dev_read,\n\t.poll\t\t= rtc_dev_poll,\n\t.unlocked_ioctl\t= rtc_dev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= rtc_dev_compat_ioctl,\n#endif\n\t.open\t\t= rtc_dev_open,\n\t.release\t= rtc_dev_release,\n\t.fasync\t\t= rtc_dev_fasync,\n};\n\n \n\nvoid rtc_dev_prepare(struct rtc_device *rtc)\n{\n\tif (!rtc_devt)\n\t\treturn;\n\n\tif (rtc->id >= RTC_DEV_MAX) {\n\t\tdev_dbg(&rtc->dev, \"too many RTC devices\\n\");\n\t\treturn;\n\t}\n\n\trtc->dev.devt = MKDEV(MAJOR(rtc_devt), rtc->id);\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tINIT_WORK(&rtc->uie_task, rtc_uie_task);\n\ttimer_setup(&rtc->uie_timer, rtc_uie_timer, 0);\n#endif\n\n\tcdev_init(&rtc->char_dev, &rtc_dev_fops);\n\trtc->char_dev.owner = rtc->owner;\n}\n\nvoid __init rtc_dev_init(void)\n{\n\tint err;\n\n\terr = alloc_chrdev_region(&rtc_devt, 0, RTC_DEV_MAX, \"rtc\");\n\tif (err < 0)\n\t\tpr_err(\"failed to allocate char dev region\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}