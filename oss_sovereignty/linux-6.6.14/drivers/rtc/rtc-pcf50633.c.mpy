{
  "module_name": "rtc-pcf50633.c",
  "hash_id": "9a1ee7ce8311792e682f483ee9d1be144abc4336a0ad8bbf5e07a3522d690912",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf50633.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/err.h>\n\n#include <linux/mfd/pcf50633/core.h>\n\n#define PCF50633_REG_RTCSC\t0x59  \n#define PCF50633_REG_RTCMN\t0x5a  \n#define PCF50633_REG_RTCHR\t0x5b  \n#define PCF50633_REG_RTCWD\t0x5c  \n#define PCF50633_REG_RTCDT\t0x5d  \n#define PCF50633_REG_RTCMT\t0x5e  \n#define PCF50633_REG_RTCYR\t0x5f  \n#define PCF50633_REG_RTCSCA\t0x60  \n#define PCF50633_REG_RTCMNA\t0x61  \n#define PCF50633_REG_RTCHRA\t0x62  \n#define PCF50633_REG_RTCWDA\t0x63  \n#define PCF50633_REG_RTCDTA\t0x64  \n#define PCF50633_REG_RTCMTA\t0x65  \n#define PCF50633_REG_RTCYRA\t0x66  \n\nenum pcf50633_time_indexes {\n\tPCF50633_TI_SEC,\n\tPCF50633_TI_MIN,\n\tPCF50633_TI_HOUR,\n\tPCF50633_TI_WKDAY,\n\tPCF50633_TI_DAY,\n\tPCF50633_TI_MONTH,\n\tPCF50633_TI_YEAR,\n\tPCF50633_TI_EXTENT  \n};\n\nstruct pcf50633_time {\n\tu_int8_t time[PCF50633_TI_EXTENT];\n};\n\nstruct pcf50633_rtc {\n\tint alarm_enabled;\n\tint alarm_pending;\n\n\tstruct pcf50633 *pcf;\n\tstruct rtc_device *rtc_dev;\n};\n\nstatic void pcf2rtc_time(struct rtc_time *rtc, struct pcf50633_time *pcf)\n{\n\trtc->tm_sec = bcd2bin(pcf->time[PCF50633_TI_SEC]);\n\trtc->tm_min = bcd2bin(pcf->time[PCF50633_TI_MIN]);\n\trtc->tm_hour = bcd2bin(pcf->time[PCF50633_TI_HOUR]);\n\trtc->tm_wday = bcd2bin(pcf->time[PCF50633_TI_WKDAY]);\n\trtc->tm_mday = bcd2bin(pcf->time[PCF50633_TI_DAY]);\n\trtc->tm_mon = bcd2bin(pcf->time[PCF50633_TI_MONTH]) - 1;\n\trtc->tm_year = bcd2bin(pcf->time[PCF50633_TI_YEAR]) + 100;\n}\n\nstatic void rtc2pcf_time(struct pcf50633_time *pcf, struct rtc_time *rtc)\n{\n\tpcf->time[PCF50633_TI_SEC] = bin2bcd(rtc->tm_sec);\n\tpcf->time[PCF50633_TI_MIN] = bin2bcd(rtc->tm_min);\n\tpcf->time[PCF50633_TI_HOUR] = bin2bcd(rtc->tm_hour);\n\tpcf->time[PCF50633_TI_WKDAY] = bin2bcd(rtc->tm_wday);\n\tpcf->time[PCF50633_TI_DAY] = bin2bcd(rtc->tm_mday);\n\tpcf->time[PCF50633_TI_MONTH] = bin2bcd(rtc->tm_mon + 1);\n\tpcf->time[PCF50633_TI_YEAR] = bin2bcd(rtc->tm_year % 100);\n}\n\nstatic int\npcf50633_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct pcf50633_rtc *rtc = dev_get_drvdata(dev);\n\tint err;\n\n\tif (enabled)\n\t\terr = pcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);\n\telse\n\t\terr = pcf50633_irq_mask(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\tif (err < 0)\n\t\treturn err;\n\n\trtc->alarm_enabled = enabled;\n\n\treturn 0;\n}\n\nstatic int pcf50633_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf50633_rtc *rtc;\n\tstruct pcf50633_time pcf_tm;\n\tint ret;\n\n\trtc = dev_get_drvdata(dev);\n\n\tret = pcf50633_read_block(rtc->pcf, PCF50633_REG_RTCSC,\n\t\t\t\t\t    PCF50633_TI_EXTENT,\n\t\t\t\t\t    &pcf_tm.time[0]);\n\tif (ret != PCF50633_TI_EXTENT) {\n\t\tdev_err(dev, \"Failed to read time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\\n\",\n\t\tpcf_tm.time[PCF50633_TI_DAY],\n\t\tpcf_tm.time[PCF50633_TI_MONTH],\n\t\tpcf_tm.time[PCF50633_TI_YEAR],\n\t\tpcf_tm.time[PCF50633_TI_HOUR],\n\t\tpcf_tm.time[PCF50633_TI_MIN],\n\t\tpcf_tm.time[PCF50633_TI_SEC]);\n\n\tpcf2rtc_time(tm, &pcf_tm);\n\n\tdev_dbg(dev, \"RTC_TIME: %ptRr\\n\", tm);\n\n\treturn 0;\n}\n\nstatic int pcf50633_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf50633_rtc *rtc;\n\tstruct pcf50633_time pcf_tm;\n\tint alarm_masked, ret = 0;\n\n\trtc = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"RTC_TIME: %ptRr\\n\", tm);\n\n\trtc2pcf_time(&pcf_tm, tm);\n\n\tdev_dbg(dev, \"PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\\n\",\n\t\tpcf_tm.time[PCF50633_TI_DAY],\n\t\tpcf_tm.time[PCF50633_TI_MONTH],\n\t\tpcf_tm.time[PCF50633_TI_YEAR],\n\t\tpcf_tm.time[PCF50633_TI_HOUR],\n\t\tpcf_tm.time[PCF50633_TI_MIN],\n\t\tpcf_tm.time[PCF50633_TI_SEC]);\n\n\n\talarm_masked = pcf50633_irq_mask_get(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\tif (!alarm_masked)\n\t\tpcf50633_irq_mask(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\t \n\tret = pcf50633_write_block(rtc->pcf, PCF50633_REG_RTCSC,\n\t\t\t\t\t     PCF50633_TI_EXTENT,\n\t\t\t\t\t     &pcf_tm.time[0]);\n\n\tif (!alarm_masked)\n\t\tpcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\treturn ret;\n}\n\nstatic int pcf50633_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf50633_rtc *rtc;\n\tstruct pcf50633_time pcf_tm;\n\tint ret = 0;\n\n\trtc = dev_get_drvdata(dev);\n\n\talrm->enabled = rtc->alarm_enabled;\n\talrm->pending = rtc->alarm_pending;\n\n\tret = pcf50633_read_block(rtc->pcf, PCF50633_REG_RTCSCA,\n\t\t\t\tPCF50633_TI_EXTENT, &pcf_tm.time[0]);\n\tif (ret != PCF50633_TI_EXTENT) {\n\t\tdev_err(dev, \"Failed to read time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpcf2rtc_time(&alrm->time, &pcf_tm);\n\n\treturn rtc_valid_tm(&alrm->time);\n}\n\nstatic int pcf50633_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf50633_rtc *rtc;\n\tstruct pcf50633_time pcf_tm;\n\tint alarm_masked, ret = 0;\n\n\trtc = dev_get_drvdata(dev);\n\n\trtc2pcf_time(&pcf_tm, &alrm->time);\n\n\t \n\tpcf_tm.time[PCF50633_TI_WKDAY] = 7;\n\n\talarm_masked = pcf50633_irq_mask_get(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\t \n\tif (!alarm_masked)\n\t\tpcf50633_irq_mask(rtc->pcf, PCF50633_IRQ_ALARM);\n\n\t \n\tret = pcf50633_write_block(rtc->pcf, PCF50633_REG_RTCSCA,\n\t\t\t\tPCF50633_TI_EXTENT, &pcf_tm.time[0]);\n\tif (!alrm->enabled)\n\t\trtc->alarm_pending = 0;\n\n\tif (!alarm_masked || alrm->enabled)\n\t\tpcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);\n\trtc->alarm_enabled = alrm->enabled;\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops pcf50633_rtc_ops = {\n\t.read_time\t\t= pcf50633_rtc_read_time,\n\t.set_time\t\t= pcf50633_rtc_set_time,\n\t.read_alarm\t\t= pcf50633_rtc_read_alarm,\n\t.set_alarm\t\t= pcf50633_rtc_set_alarm,\n\t.alarm_irq_enable\t= pcf50633_rtc_alarm_irq_enable,\n};\n\nstatic void pcf50633_rtc_irq(int irq, void *data)\n{\n\tstruct pcf50633_rtc *rtc = data;\n\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\n\trtc->alarm_pending = 1;\n}\n\nstatic int pcf50633_rtc_probe(struct platform_device *pdev)\n{\n\tstruct pcf50633_rtc *rtc;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->pcf = dev_to_pcf50633(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, rtc);\n\trtc->rtc_dev = devm_rtc_device_register(&pdev->dev, \"pcf50633-rtc\",\n\t\t\t\t&pcf50633_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tpcf50633_register_irq(rtc->pcf, PCF50633_IRQ_ALARM,\n\t\t\t\t\tpcf50633_rtc_irq, rtc);\n\treturn 0;\n}\n\nstatic void pcf50633_rtc_remove(struct platform_device *pdev)\n{\n\tstruct pcf50633_rtc *rtc;\n\n\trtc = platform_get_drvdata(pdev);\n\tpcf50633_free_irq(rtc->pcf, PCF50633_IRQ_ALARM);\n}\n\nstatic struct platform_driver pcf50633_rtc_driver = {\n\t.driver = {\n\t\t.name = \"pcf50633-rtc\",\n\t},\n\t.probe = pcf50633_rtc_probe,\n\t.remove_new = pcf50633_rtc_remove,\n};\n\nmodule_platform_driver(pcf50633_rtc_driver);\n\nMODULE_DESCRIPTION(\"PCF50633 RTC driver\");\nMODULE_AUTHOR(\"Balaji Rao <balajirrao@openmoko.org>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}