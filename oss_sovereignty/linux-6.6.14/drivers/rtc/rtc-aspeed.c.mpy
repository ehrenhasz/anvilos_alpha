{
  "module_name": "rtc-aspeed.c",
  "hash_id": "9c7bcefc2c3e12201f8eaa39fcda2752f09bcbb2ad0102d6c38caf7cc8a6104b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-aspeed.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/io.h>\n\nstruct aspeed_rtc {\n\tstruct rtc_device *rtc_dev;\n\tvoid __iomem *base;\n};\n\n#define RTC_TIME\t0x00\n#define RTC_YEAR\t0x04\n#define RTC_CTRL\t0x10\n\n#define RTC_UNLOCK\tBIT(1)\n#define RTC_ENABLE\tBIT(0)\n\nstatic int aspeed_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct aspeed_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int cent, year;\n\tu32 reg1, reg2;\n\n\tif (!(readl(rtc->base + RTC_CTRL) & RTC_ENABLE)) {\n\t\tdev_dbg(dev, \"%s failing as rtc disabled\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\treg2 = readl(rtc->base + RTC_YEAR);\n\t\treg1 = readl(rtc->base + RTC_TIME);\n\t} while (reg2 != readl(rtc->base + RTC_YEAR));\n\n\ttm->tm_mday = (reg1 >> 24) & 0x1f;\n\ttm->tm_hour = (reg1 >> 16) & 0x1f;\n\ttm->tm_min = (reg1 >> 8) & 0x3f;\n\ttm->tm_sec = (reg1 >> 0) & 0x3f;\n\n\tcent = (reg2 >> 16) & 0x1f;\n\tyear = (reg2 >> 8) & 0x7f;\n\ttm->tm_mon = ((reg2 >>  0) & 0x0f) - 1;\n\ttm->tm_year = year + (cent * 100) - 1900;\n\n\tdev_dbg(dev, \"%s %ptR\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic int aspeed_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct aspeed_rtc *rtc = dev_get_drvdata(dev);\n\tu32 reg1, reg2, ctrl;\n\tint year, cent;\n\n\tcent = (tm->tm_year + 1900) / 100;\n\tyear = tm->tm_year % 100;\n\n\treg1 = (tm->tm_mday << 24) | (tm->tm_hour << 16) | (tm->tm_min << 8) |\n\t\ttm->tm_sec;\n\n\treg2 = ((cent & 0x1f) << 16) | ((year & 0x7f) << 8) |\n\t\t((tm->tm_mon + 1) & 0xf);\n\n\tctrl = readl(rtc->base + RTC_CTRL);\n\twritel(ctrl | RTC_UNLOCK, rtc->base + RTC_CTRL);\n\n\twritel(reg1, rtc->base + RTC_TIME);\n\twritel(reg2, rtc->base + RTC_YEAR);\n\n\t \n\twritel(ctrl | RTC_ENABLE, rtc->base + RTC_CTRL);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops aspeed_rtc_ops = {\n\t.read_time = aspeed_rtc_read_time,\n\t.set_time = aspeed_rtc_set_time,\n};\n\nstatic int aspeed_rtc_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_rtc *rtc;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base))\n\t\treturn PTR_ERR(rtc->base);\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev->ops = &aspeed_rtc_ops;\n\trtc->rtc_dev->range_min = RTC_TIMESTAMP_BEGIN_1900;\n\trtc->rtc_dev->range_max = 38814989399LL;  \n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\nstatic const struct of_device_id aspeed_rtc_match[] = {\n\t{ .compatible = \"aspeed,ast2400-rtc\", },\n\t{ .compatible = \"aspeed,ast2500-rtc\", },\n\t{ .compatible = \"aspeed,ast2600-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, aspeed_rtc_match);\n\nstatic struct platform_driver aspeed_rtc_driver = {\n\t.driver = {\n\t\t.name = \"aspeed-rtc\",\n\t\t.of_match_table = aspeed_rtc_match,\n\t},\n};\n\nmodule_platform_driver_probe(aspeed_rtc_driver, aspeed_rtc_probe);\n\nMODULE_DESCRIPTION(\"ASPEED RTC driver\");\nMODULE_AUTHOR(\"Joel Stanley <joel@jms.id.au>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}