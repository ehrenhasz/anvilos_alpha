{
  "module_name": "rtc-s3c.c",
  "hash_id": "ec2a04aa51add5bb44b186e20168b46e363fa636717f7fb648c4d741c611ce1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-s3c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/clk.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n#include \"rtc-s3c.h\"\n\nstruct s3c_rtc {\n\tstruct device *dev;\n\tstruct rtc_device *rtc;\n\n\tvoid __iomem *base;\n\tstruct clk *rtc_clk;\n\tstruct clk *rtc_src_clk;\n\tbool alarm_enabled;\n\n\tconst struct s3c_rtc_data *data;\n\n\tint irq_alarm;\n\tspinlock_t alarm_lock;\n\n\tbool wake_en;\n};\n\nstruct s3c_rtc_data {\n\tbool needs_src_clk;\n\n\tvoid (*irq_handler) (struct s3c_rtc *info, int mask);\n\tvoid (*enable) (struct s3c_rtc *info);\n\tvoid (*disable) (struct s3c_rtc *info);\n};\n\nstatic int s3c_rtc_enable_clk(struct s3c_rtc *info)\n{\n\tint ret;\n\n\tret = clk_enable(info->rtc_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->data->needs_src_clk) {\n\t\tret = clk_enable(info->rtc_src_clk);\n\t\tif (ret) {\n\t\t\tclk_disable(info->rtc_clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void s3c_rtc_disable_clk(struct s3c_rtc *info)\n{\n\tif (info->data->needs_src_clk)\n\t\tclk_disable(info->rtc_src_clk);\n\tclk_disable(info->rtc_clk);\n}\n\n \nstatic irqreturn_t s3c_rtc_alarmirq(int irq, void *id)\n{\n\tstruct s3c_rtc *info = (struct s3c_rtc *)id;\n\n\tif (info->data->irq_handler)\n\t\tinfo->data->irq_handler(info, S3C2410_INTP_ALM);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int s3c_rtc_setaie(struct device *dev, unsigned int enabled)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned int tmp;\n\tint ret;\n\n\tdev_dbg(info->dev, \"%s: aie=%d\\n\", __func__, enabled);\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = readb(info->base + S3C2410_RTCALM) & ~S3C2410_RTCALM_ALMEN;\n\n\tif (enabled)\n\t\ttmp |= S3C2410_RTCALM_ALMEN;\n\n\twriteb(tmp, info->base + S3C2410_RTCALM);\n\n\tspin_lock_irqsave(&info->alarm_lock, flags);\n\n\tif (info->alarm_enabled && !enabled)\n\t\ts3c_rtc_disable_clk(info);\n\telse if (!info->alarm_enabled && enabled)\n\t\tret = s3c_rtc_enable_clk(info);\n\n\tinfo->alarm_enabled = enabled;\n\tspin_unlock_irqrestore(&info->alarm_lock, flags);\n\n\ts3c_rtc_disable_clk(info);\n\n\treturn ret;\n}\n\n \nstatic int s3c_rtc_read_time(struct s3c_rtc *info, struct rtc_time *tm)\n{\n\tunsigned int have_retried = 0;\n\tint ret;\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\nretry_get_time:\n\ttm->tm_min  = readb(info->base + S3C2410_RTCMIN);\n\ttm->tm_hour = readb(info->base + S3C2410_RTCHOUR);\n\ttm->tm_mday = readb(info->base + S3C2410_RTCDATE);\n\ttm->tm_mon  = readb(info->base + S3C2410_RTCMON);\n\ttm->tm_year = readb(info->base + S3C2410_RTCYEAR);\n\ttm->tm_sec  = readb(info->base + S3C2410_RTCSEC);\n\n\t \n\tif (tm->tm_sec == 0 && !have_retried) {\n\t\thave_retried = 1;\n\t\tgoto retry_get_time;\n\t}\n\n\ts3c_rtc_disable_clk(info);\n\n\ttm->tm_sec  = bcd2bin(tm->tm_sec);\n\ttm->tm_min  = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon  = bcd2bin(tm->tm_mon);\n\ttm->tm_year = bcd2bin(tm->tm_year);\n\n\treturn 0;\n}\n\n \nstatic int s3c_rtc_write_time(struct s3c_rtc *info, const struct rtc_time *tm)\n{\n\tint ret;\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\twriteb(bin2bcd(tm->tm_sec),  info->base + S3C2410_RTCSEC);\n\twriteb(bin2bcd(tm->tm_min),  info->base + S3C2410_RTCMIN);\n\twriteb(bin2bcd(tm->tm_hour), info->base + S3C2410_RTCHOUR);\n\twriteb(bin2bcd(tm->tm_mday), info->base + S3C2410_RTCDATE);\n\twriteb(bin2bcd(tm->tm_mon),  info->base + S3C2410_RTCMON);\n\twriteb(bin2bcd(tm->tm_year), info->base + S3C2410_RTCYEAR);\n\n\ts3c_rtc_disable_clk(info);\n\n\treturn 0;\n}\n\nstatic int s3c_rtc_gettime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = s3c_rtc_read_time(info, tm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttm->tm_year += 100;\n\ttm->tm_mon -= 1;\n\n\tdev_dbg(dev, \"read time %ptR\\n\", tm);\n\treturn 0;\n}\n\nstatic int s3c_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tstruct rtc_time rtc_tm = *tm;\n\n\tdev_dbg(dev, \"set time %ptR\\n\", tm);\n\n\t \n\trtc_tm.tm_year -= 100;\n\trtc_tm.tm_mon += 1;\n\n\treturn s3c_rtc_write_time(info, &rtc_tm);\n}\n\nstatic int s3c_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tstruct rtc_time *alm_tm = &alrm->time;\n\tunsigned int alm_en;\n\tint ret;\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\talm_tm->tm_sec  = readb(info->base + S3C2410_ALMSEC);\n\talm_tm->tm_min  = readb(info->base + S3C2410_ALMMIN);\n\talm_tm->tm_hour = readb(info->base + S3C2410_ALMHOUR);\n\talm_tm->tm_mon  = readb(info->base + S3C2410_ALMMON);\n\talm_tm->tm_mday = readb(info->base + S3C2410_ALMDATE);\n\talm_tm->tm_year = readb(info->base + S3C2410_ALMYEAR);\n\n\talm_en = readb(info->base + S3C2410_RTCALM);\n\n\ts3c_rtc_disable_clk(info);\n\n\talrm->enabled = (alm_en & S3C2410_RTCALM_ALMEN) ? 1 : 0;\n\n\tdev_dbg(dev, \"read alarm %d, %ptR\\n\", alm_en, alm_tm);\n\n\t \n\tif (alm_en & S3C2410_RTCALM_SECEN)\n\t\talm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);\n\n\tif (alm_en & S3C2410_RTCALM_MINEN)\n\t\talm_tm->tm_min = bcd2bin(alm_tm->tm_min);\n\n\tif (alm_en & S3C2410_RTCALM_HOUREN)\n\t\talm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);\n\n\tif (alm_en & S3C2410_RTCALM_DAYEN)\n\t\talm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);\n\n\tif (alm_en & S3C2410_RTCALM_MONEN) {\n\t\talm_tm->tm_mon = bcd2bin(alm_tm->tm_mon);\n\t\talm_tm->tm_mon -= 1;\n\t}\n\n\tif (alm_en & S3C2410_RTCALM_YEAREN)\n\t\talm_tm->tm_year = bcd2bin(alm_tm->tm_year);\n\n\treturn 0;\n}\n\nstatic int s3c_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned int alrm_en;\n\tint ret;\n\n\tdev_dbg(dev, \"s3c_rtc_setalarm: %d, %ptR\\n\", alrm->enabled, tm);\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\talrm_en = readb(info->base + S3C2410_RTCALM) & S3C2410_RTCALM_ALMEN;\n\twriteb(0x00, info->base + S3C2410_RTCALM);\n\n\tif (tm->tm_sec < 60 && tm->tm_sec >= 0) {\n\t\talrm_en |= S3C2410_RTCALM_SECEN;\n\t\twriteb(bin2bcd(tm->tm_sec), info->base + S3C2410_ALMSEC);\n\t}\n\n\tif (tm->tm_min < 60 && tm->tm_min >= 0) {\n\t\talrm_en |= S3C2410_RTCALM_MINEN;\n\t\twriteb(bin2bcd(tm->tm_min), info->base + S3C2410_ALMMIN);\n\t}\n\n\tif (tm->tm_hour < 24 && tm->tm_hour >= 0) {\n\t\talrm_en |= S3C2410_RTCALM_HOUREN;\n\t\twriteb(bin2bcd(tm->tm_hour), info->base + S3C2410_ALMHOUR);\n\t}\n\n\tif (tm->tm_mon < 12 && tm->tm_mon >= 0) {\n\t\talrm_en |= S3C2410_RTCALM_MONEN;\n\t\twriteb(bin2bcd(tm->tm_mon + 1), info->base + S3C2410_ALMMON);\n\t}\n\n\tif (tm->tm_mday <= 31 && tm->tm_mday >= 1) {\n\t\talrm_en |= S3C2410_RTCALM_DAYEN;\n\t\twriteb(bin2bcd(tm->tm_mday), info->base + S3C2410_ALMDATE);\n\t}\n\n\tdev_dbg(dev, \"setting S3C2410_RTCALM to %08x\\n\", alrm_en);\n\n\twriteb(alrm_en, info->base + S3C2410_RTCALM);\n\n\ts3c_rtc_setaie(dev, alrm->enabled);\n\n\ts3c_rtc_disable_clk(info);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops s3c_rtcops = {\n\t.read_time\t= s3c_rtc_gettime,\n\t.set_time\t= s3c_rtc_settime,\n\t.read_alarm\t= s3c_rtc_getalarm,\n\t.set_alarm\t= s3c_rtc_setalarm,\n\t.alarm_irq_enable = s3c_rtc_setaie,\n};\n\nstatic void s3c24xx_rtc_enable(struct s3c_rtc *info)\n{\n\tunsigned int con, tmp;\n\n\tcon = readw(info->base + S3C2410_RTCCON);\n\t \n\tif ((con & S3C2410_RTCCON_RTCEN) == 0) {\n\t\tdev_info(info->dev, \"rtc disabled, re-enabling\\n\");\n\n\t\ttmp = readw(info->base + S3C2410_RTCCON);\n\t\twritew(tmp | S3C2410_RTCCON_RTCEN, info->base + S3C2410_RTCCON);\n\t}\n\n\tif (con & S3C2410_RTCCON_CNTSEL) {\n\t\tdev_info(info->dev, \"removing RTCCON_CNTSEL\\n\");\n\n\t\ttmp = readw(info->base + S3C2410_RTCCON);\n\t\twritew(tmp & ~S3C2410_RTCCON_CNTSEL,\n\t\t       info->base + S3C2410_RTCCON);\n\t}\n\n\tif (con & S3C2410_RTCCON_CLKRST) {\n\t\tdev_info(info->dev, \"removing RTCCON_CLKRST\\n\");\n\n\t\ttmp = readw(info->base + S3C2410_RTCCON);\n\t\twritew(tmp & ~S3C2410_RTCCON_CLKRST,\n\t\t       info->base + S3C2410_RTCCON);\n\t}\n}\n\nstatic void s3c24xx_rtc_disable(struct s3c_rtc *info)\n{\n\tunsigned int con;\n\n\tcon = readw(info->base + S3C2410_RTCCON);\n\tcon &= ~S3C2410_RTCCON_RTCEN;\n\twritew(con, info->base + S3C2410_RTCCON);\n\n\tcon = readb(info->base + S3C2410_TICNT);\n\tcon &= ~S3C2410_TICNT_ENABLE;\n\twriteb(con, info->base + S3C2410_TICNT);\n}\n\nstatic void s3c6410_rtc_disable(struct s3c_rtc *info)\n{\n\tunsigned int con;\n\n\tcon = readw(info->base + S3C2410_RTCCON);\n\tcon &= ~S3C64XX_RTCCON_TICEN;\n\tcon &= ~S3C2410_RTCCON_RTCEN;\n\twritew(con, info->base + S3C2410_RTCCON);\n}\n\nstatic void s3c_rtc_remove(struct platform_device *pdev)\n{\n\tstruct s3c_rtc *info = platform_get_drvdata(pdev);\n\n\ts3c_rtc_setaie(info->dev, 0);\n\n\tif (info->data->needs_src_clk)\n\t\tclk_unprepare(info->rtc_src_clk);\n\tclk_unprepare(info->rtc_clk);\n}\n\nstatic int s3c_rtc_probe(struct platform_device *pdev)\n{\n\tstruct s3c_rtc *info = NULL;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\tinfo->data = of_device_get_match_data(&pdev->dev);\n\tif (!info->data) {\n\t\tdev_err(&pdev->dev, \"failed getting s3c_rtc_data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_init(&info->alarm_lock);\n\n\tplatform_set_drvdata(pdev, info);\n\n\tinfo->irq_alarm = platform_get_irq(pdev, 0);\n\tif (info->irq_alarm < 0)\n\t\treturn info->irq_alarm;\n\n\tdev_dbg(&pdev->dev, \"s3c2410_rtc: alarm irq %d\\n\", info->irq_alarm);\n\n\t \n\tinfo->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->base))\n\t\treturn PTR_ERR(info->base);\n\n\tinfo->rtc_clk = devm_clk_get(&pdev->dev, \"rtc\");\n\tif (IS_ERR(info->rtc_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->rtc_clk),\n\t\t\t\t     \"failed to find rtc clock\\n\");\n\tret = clk_prepare_enable(info->rtc_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->data->needs_src_clk) {\n\t\tinfo->rtc_src_clk = devm_clk_get(&pdev->dev, \"rtc_src\");\n\t\tif (IS_ERR(info->rtc_src_clk)) {\n\t\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(info->rtc_src_clk),\n\t\t\t\t\t    \"failed to find rtc source clock\\n\");\n\t\t\tgoto err_src_clk;\n\t\t}\n\t\tret = clk_prepare_enable(info->rtc_src_clk);\n\t\tif (ret)\n\t\t\tgoto err_src_clk;\n\t}\n\n\t \n\tif (info->data->disable)\n\t\tinfo->data->disable(info);\n\n\t \n\tif (info->data->enable)\n\t\tinfo->data->enable(info);\n\n\tdev_dbg(&pdev->dev, \"s3c2410_rtc: RTCCON=%02x\\n\",\n\t\treadw(info->base + S3C2410_RTCCON));\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tinfo->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc)) {\n\t\tret = PTR_ERR(info->rtc);\n\t\tgoto err_nortc;\n\t}\n\n\tinfo->rtc->ops = &s3c_rtcops;\n\tinfo->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tinfo->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tret = devm_rtc_register_device(info->rtc);\n\tif (ret)\n\t\tgoto err_nortc;\n\n\tret = devm_request_irq(&pdev->dev, info->irq_alarm, s3c_rtc_alarmirq,\n\t\t\t       0, \"s3c2410-rtc alarm\", info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ%d error %d\\n\", info->irq_alarm, ret);\n\t\tgoto err_nortc;\n\t}\n\n\ts3c_rtc_disable_clk(info);\n\n\treturn 0;\n\nerr_nortc:\n\tif (info->data->disable)\n\t\tinfo->data->disable(info);\n\n\tif (info->data->needs_src_clk)\n\t\tclk_disable_unprepare(info->rtc_src_clk);\nerr_src_clk:\n\tclk_disable_unprepare(info->rtc_clk);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int s3c_rtc_suspend(struct device *dev)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = s3c_rtc_enable_clk(info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->data->disable)\n\t\tinfo->data->disable(info);\n\n\tif (device_may_wakeup(dev) && !info->wake_en) {\n\t\tif (enable_irq_wake(info->irq_alarm) == 0)\n\t\t\tinfo->wake_en = true;\n\t\telse\n\t\t\tdev_err(dev, \"enable_irq_wake failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c_rtc_resume(struct device *dev)\n{\n\tstruct s3c_rtc *info = dev_get_drvdata(dev);\n\n\tif (info->data->enable)\n\t\tinfo->data->enable(info);\n\n\ts3c_rtc_disable_clk(info);\n\n\tif (device_may_wakeup(dev) && info->wake_en) {\n\t\tdisable_irq_wake(info->irq_alarm);\n\t\tinfo->wake_en = false;\n\t}\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(s3c_rtc_pm_ops, s3c_rtc_suspend, s3c_rtc_resume);\n\nstatic void s3c24xx_rtc_irq(struct s3c_rtc *info, int mask)\n{\n\trtc_update_irq(info->rtc, 1, RTC_AF | RTC_IRQF);\n}\n\nstatic void s3c6410_rtc_irq(struct s3c_rtc *info, int mask)\n{\n\trtc_update_irq(info->rtc, 1, RTC_AF | RTC_IRQF);\n\twriteb(mask, info->base + S3C2410_INTP);\n}\n\nstatic struct s3c_rtc_data const s3c2410_rtc_data = {\n\t.irq_handler\t\t= s3c24xx_rtc_irq,\n\t.enable\t\t\t= s3c24xx_rtc_enable,\n\t.disable\t\t= s3c24xx_rtc_disable,\n};\n\nstatic struct s3c_rtc_data const s3c2416_rtc_data = {\n\t.irq_handler\t\t= s3c24xx_rtc_irq,\n\t.enable\t\t\t= s3c24xx_rtc_enable,\n\t.disable\t\t= s3c24xx_rtc_disable,\n};\n\nstatic struct s3c_rtc_data const s3c2443_rtc_data = {\n\t.irq_handler\t\t= s3c24xx_rtc_irq,\n\t.enable\t\t\t= s3c24xx_rtc_enable,\n\t.disable\t\t= s3c24xx_rtc_disable,\n};\n\nstatic struct s3c_rtc_data const s3c6410_rtc_data = {\n\t.needs_src_clk\t\t= true,\n\t.irq_handler\t\t= s3c6410_rtc_irq,\n\t.enable\t\t\t= s3c24xx_rtc_enable,\n\t.disable\t\t= s3c6410_rtc_disable,\n};\n\nstatic const __maybe_unused struct of_device_id s3c_rtc_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,s3c2410-rtc\",\n\t\t.data = &s3c2410_rtc_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2416-rtc\",\n\t\t.data = &s3c2416_rtc_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2443-rtc\",\n\t\t.data = &s3c2443_rtc_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c6410-rtc\",\n\t\t.data = &s3c6410_rtc_data,\n\t}, {\n\t\t.compatible = \"samsung,exynos3250-rtc\",\n\t\t.data = &s3c6410_rtc_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, s3c_rtc_dt_match);\n\nstatic struct platform_driver s3c_rtc_driver = {\n\t.probe\t\t= s3c_rtc_probe,\n\t.remove_new\t= s3c_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c-rtc\",\n\t\t.pm\t= &s3c_rtc_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(s3c_rtc_dt_match),\n\t},\n};\nmodule_platform_driver(s3c_rtc_driver);\n\nMODULE_DESCRIPTION(\"Samsung S3C RTC Driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:s3c2410-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}