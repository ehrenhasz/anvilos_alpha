{
  "module_name": "rtc-as3722.c",
  "hash_id": "d7365406e937ca4a82d641ee06a1b024dfcb8512311e287227efc10c4842d9b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-as3722.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/as3722.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/time.h>\n\n#define AS3722_RTC_START_YEAR\t  2000\nstruct as3722_rtc {\n\tstruct rtc_device\t*rtc;\n\tstruct device\t\t*dev;\n\tstruct as3722\t\t*as3722;\n\tint\t\t\talarm_irq;\n\tbool\t\t\tirq_enable;\n};\n\nstatic void as3722_time_to_reg(u8 *rbuff, struct rtc_time *tm)\n{\n\trbuff[0] = bin2bcd(tm->tm_sec);\n\trbuff[1] = bin2bcd(tm->tm_min);\n\trbuff[2] = bin2bcd(tm->tm_hour);\n\trbuff[3] = bin2bcd(tm->tm_mday);\n\trbuff[4] = bin2bcd(tm->tm_mon + 1);\n\trbuff[5] = bin2bcd(tm->tm_year - (AS3722_RTC_START_YEAR - 1900));\n}\n\nstatic void as3722_reg_to_time(u8 *rbuff, struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(rbuff[0] & 0x7F);\n\ttm->tm_min = bcd2bin(rbuff[1] & 0x7F);\n\ttm->tm_hour = bcd2bin(rbuff[2] & 0x3F);\n\ttm->tm_mday = bcd2bin(rbuff[3] & 0x3F);\n\ttm->tm_mon = bcd2bin(rbuff[4] & 0x1F) - 1;\n\ttm->tm_year = (AS3722_RTC_START_YEAR - 1900) + bcd2bin(rbuff[5] & 0x7F);\n\treturn;\n}\n\nstatic int as3722_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\tstruct as3722 *as3722 = as3722_rtc->as3722;\n\tu8 as_time_array[6];\n\tint ret;\n\n\tret = as3722_block_read(as3722, AS3722_RTC_SECOND_REG,\n\t\t\t6, as_time_array);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_SECOND reg block read failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tas3722_reg_to_time(as_time_array, tm);\n\treturn 0;\n}\n\nstatic int as3722_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\tstruct as3722 *as3722 = as3722_rtc->as3722;\n\tu8 as_time_array[6];\n\tint ret;\n\n\tif (tm->tm_year < (AS3722_RTC_START_YEAR - 1900))\n\t\treturn -EINVAL;\n\n\tas3722_time_to_reg(as_time_array, tm);\n\tret = as3722_block_write(as3722, AS3722_RTC_SECOND_REG, 6,\n\t\t\tas_time_array);\n\tif (ret < 0)\n\t\tdev_err(dev, \"RTC_SECOND reg block write failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int as3722_rtc_alarm_irq_enable(struct device *dev,\n\t\tunsigned int enabled)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\n\tif (enabled && !as3722_rtc->irq_enable) {\n\t\tenable_irq(as3722_rtc->alarm_irq);\n\t\tas3722_rtc->irq_enable = true;\n\t} else if (!enabled && as3722_rtc->irq_enable)  {\n\t\tdisable_irq(as3722_rtc->alarm_irq);\n\t\tas3722_rtc->irq_enable = false;\n\t}\n\treturn 0;\n}\n\nstatic int as3722_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\tstruct as3722 *as3722 = as3722_rtc->as3722;\n\tu8 as_time_array[6];\n\tint ret;\n\n\tret = as3722_block_read(as3722, AS3722_RTC_ALARM_SECOND_REG, 6,\n\t\t\tas_time_array);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_ALARM_SECOND block read failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tas3722_reg_to_time(as_time_array, &alrm->time);\n\treturn 0;\n}\n\nstatic int as3722_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\tstruct as3722 *as3722 = as3722_rtc->as3722;\n\tu8 as_time_array[6];\n\tint ret;\n\n\tif (alrm->time.tm_year < (AS3722_RTC_START_YEAR - 1900))\n\t\treturn -EINVAL;\n\n\tret = as3722_rtc_alarm_irq_enable(dev, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Disable RTC alarm failed\\n\");\n\t\treturn ret;\n\t}\n\n\tas3722_time_to_reg(as_time_array, &alrm->time);\n\tret = as3722_block_write(as3722, AS3722_RTC_ALARM_SECOND_REG, 6,\n\t\t\tas_time_array);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_ALARM_SECOND block write failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (alrm->enabled)\n\t\tret = as3722_rtc_alarm_irq_enable(dev, alrm->enabled);\n\treturn ret;\n}\n\nstatic irqreturn_t as3722_alarm_irq(int irq, void *data)\n{\n\tstruct as3722_rtc *as3722_rtc = data;\n\n\trtc_update_irq(as3722_rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops as3722_rtc_ops = {\n\t.read_time = as3722_rtc_read_time,\n\t.set_time = as3722_rtc_set_time,\n\t.read_alarm = as3722_rtc_read_alarm,\n\t.set_alarm = as3722_rtc_set_alarm,\n\t.alarm_irq_enable = as3722_rtc_alarm_irq_enable,\n};\n\nstatic int as3722_rtc_probe(struct platform_device *pdev)\n{\n\tstruct as3722 *as3722 = dev_get_drvdata(pdev->dev.parent);\n\tstruct as3722_rtc *as3722_rtc;\n\tint ret;\n\n\tas3722_rtc = devm_kzalloc(&pdev->dev, sizeof(*as3722_rtc), GFP_KERNEL);\n\tif (!as3722_rtc)\n\t\treturn -ENOMEM;\n\n\tas3722_rtc->as3722 = as3722;\n\tas3722_rtc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, as3722_rtc);\n\n\t \n\tret = as3722_update_bits(as3722, AS3722_RTC_CONTROL_REG,\n\t\t\tAS3722_RTC_ON | AS3722_RTC_ALARM_WAKEUP_EN,\n\t\t\tAS3722_RTC_ON | AS3722_RTC_ALARM_WAKEUP_EN);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"RTC_CONTROL reg write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tas3722_rtc->rtc = devm_rtc_device_register(&pdev->dev, \"as3722-rtc\",\n\t\t\t\t&as3722_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(as3722_rtc->rtc)) {\n\t\tret = PTR_ERR(as3722_rtc->rtc);\n\t\tdev_err(&pdev->dev, \"RTC register failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tas3722_rtc->alarm_irq = platform_get_irq(pdev, 0);\n\tdev_info(&pdev->dev, \"RTC interrupt %d\\n\", as3722_rtc->alarm_irq);\n\n\tret = devm_request_threaded_irq(&pdev->dev, as3722_rtc->alarm_irq, NULL,\n\t\t\tas3722_alarm_irq, IRQF_ONESHOT,\n\t\t\t\"rtc-alarm\", as3722_rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ %d: %d\\n\",\n\t\t\t\tas3722_rtc->alarm_irq, ret);\n\t\treturn ret;\n\t}\n\tdisable_irq(as3722_rtc->alarm_irq);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int as3722_rtc_suspend(struct device *dev)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(as3722_rtc->alarm_irq);\n\n\treturn 0;\n}\n\nstatic int as3722_rtc_resume(struct device *dev)\n{\n\tstruct as3722_rtc *as3722_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(as3722_rtc->alarm_irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(as3722_rtc_pm_ops, as3722_rtc_suspend,\n\t\t\t as3722_rtc_resume);\n\nstatic struct platform_driver as3722_rtc_driver = {\n\t.probe = as3722_rtc_probe,\n\t.driver = {\n\t\t.name = \"as3722-rtc\",\n\t\t.pm = &as3722_rtc_pm_ops,\n\t},\n};\nmodule_platform_driver(as3722_rtc_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for AS3722 PMICs\");\nMODULE_ALIAS(\"platform:as3722-rtc\");\nMODULE_AUTHOR(\"Florian Lobmaier <florian.lobmaier@ams.com>\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}