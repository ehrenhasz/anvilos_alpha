{
  "module_name": "rtc-sunxi.c",
  "hash_id": "106f2da071365778ca265d47577c74f4516287a5fb542155beee8aa38dbed65a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sunxi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/types.h>\n\n#define SUNXI_LOSC_CTRL\t\t\t\t0x0000\n#define SUNXI_LOSC_CTRL_RTC_HMS_ACC\t\tBIT(8)\n#define SUNXI_LOSC_CTRL_RTC_YMD_ACC\t\tBIT(7)\n\n#define SUNXI_RTC_YMD\t\t\t\t0x0004\n\n#define SUNXI_RTC_HMS\t\t\t\t0x0008\n\n#define SUNXI_ALRM_DHMS\t\t\t\t0x000c\n\n#define SUNXI_ALRM_EN\t\t\t\t0x0014\n#define SUNXI_ALRM_EN_CNT_EN\t\t\tBIT(8)\n\n#define SUNXI_ALRM_IRQ_EN\t\t\t0x0018\n#define SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN\t\tBIT(0)\n\n#define SUNXI_ALRM_IRQ_STA\t\t\t0x001c\n#define SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND\t\tBIT(0)\n\n#define SUNXI_MASK_DH\t\t\t\t0x0000001f\n#define SUNXI_MASK_SM\t\t\t\t0x0000003f\n#define SUNXI_MASK_M\t\t\t\t0x0000000f\n#define SUNXI_MASK_LY\t\t\t\t0x00000001\n#define SUNXI_MASK_D\t\t\t\t0x00000ffe\n#define SUNXI_MASK_M\t\t\t\t0x0000000f\n\n#define SUNXI_GET(x, mask, shift)\t\t(((x) & ((mask) << (shift))) \\\n\t\t\t\t\t\t\t>> (shift))\n\n#define SUNXI_SET(x, mask, shift)\t\t(((x) & (mask)) << (shift))\n\n \n#define SUNXI_DATE_GET_DAY_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_DH, 0)\n#define SUNXI_DATE_GET_MON_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_M, 8)\n#define SUNXI_DATE_GET_YEAR_VALUE(x, mask)\tSUNXI_GET(x, mask, 16)\n\n \n#define SUNXI_TIME_GET_SEC_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_SM, 0)\n#define SUNXI_TIME_GET_MIN_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_SM, 8)\n#define SUNXI_TIME_GET_HOUR_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_DH, 16)\n\n \n#define SUNXI_ALRM_GET_SEC_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_SM, 0)\n#define SUNXI_ALRM_GET_MIN_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_SM, 8)\n#define SUNXI_ALRM_GET_HOUR_VALUE(x)\t\tSUNXI_GET(x, SUNXI_MASK_DH, 16)\n\n \n#define SUNXI_DATE_SET_DAY_VALUE(x)\t\tSUNXI_DATE_GET_DAY_VALUE(x)\n#define SUNXI_DATE_SET_MON_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_M, 8)\n#define SUNXI_DATE_SET_YEAR_VALUE(x, mask)\tSUNXI_SET(x, mask, 16)\n#define SUNXI_LEAP_SET_VALUE(x, shift)\t\tSUNXI_SET(x, SUNXI_MASK_LY, shift)\n\n \n#define SUNXI_TIME_SET_SEC_VALUE(x)\t\tSUNXI_TIME_GET_SEC_VALUE(x)\n#define SUNXI_TIME_SET_MIN_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_SM, 8)\n#define SUNXI_TIME_SET_HOUR_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_DH, 16)\n\n \n#define SUNXI_ALRM_SET_SEC_VALUE(x)\t\tSUNXI_ALRM_GET_SEC_VALUE(x)\n#define SUNXI_ALRM_SET_MIN_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_SM, 8)\n#define SUNXI_ALRM_SET_HOUR_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_DH, 16)\n#define SUNXI_ALRM_SET_DAY_VALUE(x)\t\tSUNXI_SET(x, SUNXI_MASK_D, 21)\n\n \n#define SEC_IN_MIN\t\t\t\t60\n#define SEC_IN_HOUR\t\t\t\t(60 * SEC_IN_MIN)\n#define SEC_IN_DAY\t\t\t\t(24 * SEC_IN_HOUR)\n\n \n#define SUNXI_YEAR_OFF(x)\t\t\t((x)->min - 1900)\n\n \nstruct sunxi_rtc_data_year {\n\tunsigned int min;\t\t \n\tunsigned int max;\t\t \n\tunsigned int mask;\t\t \n\tunsigned char leap_shift;\t \n};\n\nstatic const struct sunxi_rtc_data_year data_year_param[] = {\n\t[0] = {\n\t\t.min\t\t= 2010,\n\t\t.max\t\t= 2073,\n\t\t.mask\t\t= 0x3f,\n\t\t.leap_shift\t= 22,\n\t},\n\t[1] = {\n\t\t.min\t\t= 1970,\n\t\t.max\t\t= 2225,\n\t\t.mask\t\t= 0xff,\n\t\t.leap_shift\t= 24,\n\t},\n};\n\nstruct sunxi_rtc_dev {\n\tstruct rtc_device *rtc;\n\tstruct device *dev;\n\tconst struct sunxi_rtc_data_year *data_year;\n\tvoid __iomem *base;\n\tint irq;\n};\n\nstatic irqreturn_t sunxi_rtc_alarmirq(int irq, void *id)\n{\n\tstruct sunxi_rtc_dev *chip = (struct sunxi_rtc_dev *) id;\n\tu32 val;\n\n\tval = readl(chip->base + SUNXI_ALRM_IRQ_STA);\n\n\tif (val & SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND) {\n\t\tval |= SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND;\n\t\twritel(val, chip->base + SUNXI_ALRM_IRQ_STA);\n\n\t\trtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void sunxi_rtc_setaie(unsigned int to, struct sunxi_rtc_dev *chip)\n{\n\tu32 alrm_val = 0;\n\tu32 alrm_irq_val = 0;\n\n\tif (to) {\n\t\talrm_val = readl(chip->base + SUNXI_ALRM_EN);\n\t\talrm_val |= SUNXI_ALRM_EN_CNT_EN;\n\n\t\talrm_irq_val = readl(chip->base + SUNXI_ALRM_IRQ_EN);\n\t\talrm_irq_val |= SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN;\n\t} else {\n\t\twritel(SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND,\n\t\t\t\tchip->base + SUNXI_ALRM_IRQ_STA);\n\t}\n\n\twritel(alrm_val, chip->base + SUNXI_ALRM_EN);\n\twritel(alrm_irq_val, chip->base + SUNXI_ALRM_IRQ_EN);\n}\n\nstatic int sunxi_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct rtc_time *alrm_tm = &wkalrm->time;\n\tu32 alrm;\n\tu32 alrm_en;\n\tu32 date;\n\n\talrm = readl(chip->base + SUNXI_ALRM_DHMS);\n\tdate = readl(chip->base + SUNXI_RTC_YMD);\n\n\talrm_tm->tm_sec = SUNXI_ALRM_GET_SEC_VALUE(alrm);\n\talrm_tm->tm_min = SUNXI_ALRM_GET_MIN_VALUE(alrm);\n\talrm_tm->tm_hour = SUNXI_ALRM_GET_HOUR_VALUE(alrm);\n\n\talrm_tm->tm_mday = SUNXI_DATE_GET_DAY_VALUE(date);\n\talrm_tm->tm_mon = SUNXI_DATE_GET_MON_VALUE(date);\n\talrm_tm->tm_year = SUNXI_DATE_GET_YEAR_VALUE(date,\n\t\t\tchip->data_year->mask);\n\n\talrm_tm->tm_mon -= 1;\n\n\t \n\talrm_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);\n\n\talrm_en = readl(chip->base + SUNXI_ALRM_IRQ_EN);\n\tif (alrm_en & SUNXI_ALRM_EN_CNT_EN)\n\t\twkalrm->enabled = 1;\n\n\treturn 0;\n}\n\nstatic int sunxi_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\n\tu32 date, time;\n\n\t \n\tdo {\n\t\tdate = readl(chip->base + SUNXI_RTC_YMD);\n\t\ttime = readl(chip->base + SUNXI_RTC_HMS);\n\t} while ((date != readl(chip->base + SUNXI_RTC_YMD)) ||\n\t\t (time != readl(chip->base + SUNXI_RTC_HMS)));\n\n\trtc_tm->tm_sec  = SUNXI_TIME_GET_SEC_VALUE(time);\n\trtc_tm->tm_min  = SUNXI_TIME_GET_MIN_VALUE(time);\n\trtc_tm->tm_hour = SUNXI_TIME_GET_HOUR_VALUE(time);\n\n\trtc_tm->tm_mday = SUNXI_DATE_GET_DAY_VALUE(date);\n\trtc_tm->tm_mon  = SUNXI_DATE_GET_MON_VALUE(date);\n\trtc_tm->tm_year = SUNXI_DATE_GET_YEAR_VALUE(date,\n\t\t\t\t\tchip->data_year->mask);\n\n\trtc_tm->tm_mon  -= 1;\n\n\t \n\trtc_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);\n\n\treturn 0;\n}\n\nstatic int sunxi_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct rtc_time *alrm_tm = &wkalrm->time;\n\tstruct rtc_time tm_now;\n\tu32 alrm;\n\ttime64_t diff;\n\tunsigned long time_gap;\n\tunsigned long time_gap_day;\n\tunsigned long time_gap_hour;\n\tunsigned long time_gap_min;\n\tint ret;\n\n\tret = sunxi_rtc_gettime(dev, &tm_now);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error in getting time\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdiff = rtc_tm_sub(alrm_tm, &tm_now);\n\tif (diff <= 0) {\n\t\tdev_err(dev, \"Date to set in the past\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (diff > 255 * SEC_IN_DAY) {\n\t\tdev_err(dev, \"Day must be in the range 0 - 255\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttime_gap = diff;\n\ttime_gap_day = time_gap / SEC_IN_DAY;\n\ttime_gap -= time_gap_day * SEC_IN_DAY;\n\ttime_gap_hour = time_gap / SEC_IN_HOUR;\n\ttime_gap -= time_gap_hour * SEC_IN_HOUR;\n\ttime_gap_min = time_gap / SEC_IN_MIN;\n\ttime_gap -= time_gap_min * SEC_IN_MIN;\n\n\tsunxi_rtc_setaie(0, chip);\n\twritel(0, chip->base + SUNXI_ALRM_DHMS);\n\tusleep_range(100, 300);\n\n\talrm = SUNXI_ALRM_SET_SEC_VALUE(time_gap) |\n\t\tSUNXI_ALRM_SET_MIN_VALUE(time_gap_min) |\n\t\tSUNXI_ALRM_SET_HOUR_VALUE(time_gap_hour) |\n\t\tSUNXI_ALRM_SET_DAY_VALUE(time_gap_day);\n\twritel(alrm, chip->base + SUNXI_ALRM_DHMS);\n\n\twritel(0, chip->base + SUNXI_ALRM_IRQ_EN);\n\twritel(SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN, chip->base + SUNXI_ALRM_IRQ_EN);\n\n\tsunxi_rtc_setaie(wkalrm->enabled, chip);\n\n\treturn 0;\n}\n\nstatic int sunxi_rtc_wait(struct sunxi_rtc_dev *chip, int offset,\n\t\t\t  unsigned int mask, unsigned int ms_timeout)\n{\n\tconst unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);\n\tu32 reg;\n\n\tdo {\n\t\treg = readl(chip->base + offset);\n\t\treg &= mask;\n\n\t\tif (reg == mask)\n\t\t\treturn 0;\n\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int sunxi_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\n\tu32 date = 0;\n\tu32 time = 0;\n\tunsigned int year;\n\n\t \n\n\tyear = rtc_tm->tm_year + 1900;\n\tif (year < chip->data_year->min || year > chip->data_year->max) {\n\t\tdev_err(dev, \"rtc only supports year in range %u - %u\\n\",\n\t\t\tchip->data_year->min, chip->data_year->max);\n\t\treturn -EINVAL;\n\t}\n\n\trtc_tm->tm_year -= SUNXI_YEAR_OFF(chip->data_year);\n\trtc_tm->tm_mon += 1;\n\n\tdate = SUNXI_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |\n\t\tSUNXI_DATE_SET_MON_VALUE(rtc_tm->tm_mon)  |\n\t\tSUNXI_DATE_SET_YEAR_VALUE(rtc_tm->tm_year,\n\t\t\t\tchip->data_year->mask);\n\n\tif (is_leap_year(year))\n\t\tdate |= SUNXI_LEAP_SET_VALUE(1, chip->data_year->leap_shift);\n\n\ttime = SUNXI_TIME_SET_SEC_VALUE(rtc_tm->tm_sec)  |\n\t\tSUNXI_TIME_SET_MIN_VALUE(rtc_tm->tm_min)  |\n\t\tSUNXI_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);\n\n\twritel(0, chip->base + SUNXI_RTC_HMS);\n\twritel(0, chip->base + SUNXI_RTC_YMD);\n\n\twritel(time, chip->base + SUNXI_RTC_HMS);\n\n\t \n\n\tif (sunxi_rtc_wait(chip, SUNXI_LOSC_CTRL,\n\t\t\t\tSUNXI_LOSC_CTRL_RTC_HMS_ACC, 50)) {\n\t\tdev_err(dev, \"Failed to set rtc time.\\n\");\n\t\treturn -1;\n\t}\n\n\twritel(date, chip->base + SUNXI_RTC_YMD);\n\n\t \n\n\tif (sunxi_rtc_wait(chip, SUNXI_LOSC_CTRL,\n\t\t\t\tSUNXI_LOSC_CTRL_RTC_YMD_ACC, 50)) {\n\t\tdev_err(dev, \"Failed to set rtc time.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\n\n\tif (!enabled)\n\t\tsunxi_rtc_setaie(enabled, chip);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sunxi_rtc_ops = {\n\t.read_time\t\t= sunxi_rtc_gettime,\n\t.set_time\t\t= sunxi_rtc_settime,\n\t.read_alarm\t\t= sunxi_rtc_getalarm,\n\t.set_alarm\t\t= sunxi_rtc_setalarm,\n\t.alarm_irq_enable\t= sunxi_rtc_alarm_irq_enable\n};\n\nstatic const struct of_device_id sunxi_rtc_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-rtc\", .data = &data_year_param[0] },\n\t{ .compatible = \"allwinner,sun7i-a20-rtc\", .data = &data_year_param[1] },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sunxi_rtc_dt_ids);\n\nstatic int sunxi_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sunxi_rtc_dev *chip;\n\tint ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\tchip->dev = &pdev->dev;\n\n\tchip->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(chip->rtc))\n\t\treturn PTR_ERR(chip->rtc);\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base))\n\t\treturn PTR_ERR(chip->base);\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tif (chip->irq < 0)\n\t\treturn chip->irq;\n\tret = devm_request_irq(&pdev->dev, chip->irq, sunxi_rtc_alarmirq,\n\t\t\t0, dev_name(&pdev->dev), chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tchip->data_year = of_device_get_match_data(&pdev->dev);\n\tif (!chip->data_year) {\n\t\tdev_err(&pdev->dev, \"Unable to setup RTC data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\twritel(0, chip->base + SUNXI_ALRM_DHMS);\n\n\t \n\twritel(0, chip->base + SUNXI_ALRM_EN);\n\n\t \n\twritel(0, chip->base + SUNXI_ALRM_IRQ_EN);\n\n\t \n\twritel(SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND, chip->base +\n\t\t\tSUNXI_ALRM_IRQ_STA);\n\n\tchip->rtc->ops = &sunxi_rtc_ops;\n\n\treturn devm_rtc_register_device(chip->rtc);\n}\n\nstatic struct platform_driver sunxi_rtc_driver = {\n\t.probe\t\t= sunxi_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sunxi-rtc\",\n\t\t.of_match_table = sunxi_rtc_dt_ids,\n\t},\n};\n\nmodule_platform_driver(sunxi_rtc_driver);\n\nMODULE_DESCRIPTION(\"sunxi RTC driver\");\nMODULE_AUTHOR(\"Carlo Caione <carlo.caione@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}