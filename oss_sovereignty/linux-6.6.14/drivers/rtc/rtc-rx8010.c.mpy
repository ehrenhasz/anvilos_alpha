{
  "module_name": "rtc-rx8010.c",
  "hash_id": "ce40ba2aa112131343762cde5a38fc57c44fa4869bc287501ab6692a83711ae3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rx8010.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define RX8010_SEC\t\t0x10\n#define RX8010_MIN\t\t0x11\n#define RX8010_HOUR\t\t0x12\n#define RX8010_WDAY\t\t0x13\n#define RX8010_MDAY\t\t0x14\n#define RX8010_MONTH\t\t0x15\n#define RX8010_YEAR\t\t0x16\n#define RX8010_RESV17\t\t0x17\n#define RX8010_ALMIN\t\t0x18\n#define RX8010_ALHOUR\t\t0x19\n#define RX8010_ALWDAY\t\t0x1A\n#define RX8010_TCOUNT0\t\t0x1B\n#define RX8010_TCOUNT1\t\t0x1C\n#define RX8010_EXT\t\t0x1D\n#define RX8010_FLAG\t\t0x1E\n#define RX8010_CTRL\t\t0x1F\n \n#define RX8010_RESV30\t\t0x30\n#define RX8010_RESV31\t\t0x31\n#define RX8010_IRQ\t\t0x32\n\n#define RX8010_EXT_WADA\t\tBIT(3)\n\n#define RX8010_FLAG_VLF\t\tBIT(1)\n#define RX8010_FLAG_AF\t\tBIT(3)\n#define RX8010_FLAG_TF\t\tBIT(4)\n#define RX8010_FLAG_UF\t\tBIT(5)\n\n#define RX8010_CTRL_AIE\t\tBIT(3)\n#define RX8010_CTRL_UIE\t\tBIT(5)\n#define RX8010_CTRL_STOP\tBIT(6)\n#define RX8010_CTRL_TEST\tBIT(7)\n\n#define RX8010_ALARM_AE\t\tBIT(7)\n\nstatic const struct i2c_device_id rx8010_id[] = {\n\t{ \"rx8010\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rx8010_id);\n\nstatic const __maybe_unused struct of_device_id rx8010_of_match[] = {\n\t{ .compatible = \"epson,rx8010\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rx8010_of_match);\n\nstruct rx8010_data {\n\tstruct regmap *regs;\n\tstruct rtc_device *rtc;\n\tu8 ctrlreg;\n};\n\nstatic irqreturn_t rx8010_irq_1_handler(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct rx8010_data *rx8010 = i2c_get_clientdata(client);\n\tint flagreg, err;\n\n\trtc_lock(rx8010->rtc);\n\n\terr = regmap_read(rx8010->regs, RX8010_FLAG, &flagreg);\n\tif (err) {\n\t\trtc_unlock(rx8010->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (flagreg & RX8010_FLAG_VLF)\n\t\tdev_warn(&client->dev, \"Frequency stop detected\\n\");\n\n\tif (flagreg & RX8010_FLAG_TF) {\n\t\tflagreg &= ~RX8010_FLAG_TF;\n\t\trtc_update_irq(rx8010->rtc, 1, RTC_PF | RTC_IRQF);\n\t}\n\n\tif (flagreg & RX8010_FLAG_AF) {\n\t\tflagreg &= ~RX8010_FLAG_AF;\n\t\trtc_update_irq(rx8010->rtc, 1, RTC_AF | RTC_IRQF);\n\t}\n\n\tif (flagreg & RX8010_FLAG_UF) {\n\t\tflagreg &= ~RX8010_FLAG_UF;\n\t\trtc_update_irq(rx8010->rtc, 1, RTC_UF | RTC_IRQF);\n\t}\n\n\terr = regmap_write(rx8010->regs, RX8010_FLAG, flagreg);\n\trtc_unlock(rx8010->rtc);\n\treturn err ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic int rx8010_get_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tu8 date[RX8010_YEAR - RX8010_SEC + 1];\n\tint flagreg, err;\n\n\terr = regmap_read(rx8010->regs, RX8010_FLAG, &flagreg);\n\tif (err)\n\t\treturn err;\n\n\tif (flagreg & RX8010_FLAG_VLF) {\n\t\tdev_warn(dev, \"Frequency stop detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = regmap_bulk_read(rx8010->regs, RX8010_SEC, date, sizeof(date));\n\tif (err)\n\t\treturn err;\n\n\tdt->tm_sec = bcd2bin(date[RX8010_SEC - RX8010_SEC] & 0x7f);\n\tdt->tm_min = bcd2bin(date[RX8010_MIN - RX8010_SEC] & 0x7f);\n\tdt->tm_hour = bcd2bin(date[RX8010_HOUR - RX8010_SEC] & 0x3f);\n\tdt->tm_mday = bcd2bin(date[RX8010_MDAY - RX8010_SEC] & 0x3f);\n\tdt->tm_mon = bcd2bin(date[RX8010_MONTH - RX8010_SEC] & 0x1f) - 1;\n\tdt->tm_year = bcd2bin(date[RX8010_YEAR - RX8010_SEC]) + 100;\n\tdt->tm_wday = ffs(date[RX8010_WDAY - RX8010_SEC] & 0x7f);\n\n\treturn 0;\n}\n\nstatic int rx8010_set_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tu8 date[RX8010_YEAR - RX8010_SEC + 1];\n\tint err;\n\n\t \n\terr = regmap_set_bits(rx8010->regs, RX8010_CTRL, RX8010_CTRL_STOP);\n\tif (err)\n\t\treturn err;\n\n\tdate[RX8010_SEC - RX8010_SEC] = bin2bcd(dt->tm_sec);\n\tdate[RX8010_MIN - RX8010_SEC] = bin2bcd(dt->tm_min);\n\tdate[RX8010_HOUR - RX8010_SEC] = bin2bcd(dt->tm_hour);\n\tdate[RX8010_MDAY - RX8010_SEC] = bin2bcd(dt->tm_mday);\n\tdate[RX8010_MONTH - RX8010_SEC] = bin2bcd(dt->tm_mon + 1);\n\tdate[RX8010_YEAR - RX8010_SEC] = bin2bcd(dt->tm_year - 100);\n\tdate[RX8010_WDAY - RX8010_SEC] = bin2bcd(1 << dt->tm_wday);\n\n\terr = regmap_bulk_write(rx8010->regs, RX8010_SEC, date, sizeof(date));\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_clear_bits(rx8010->regs, RX8010_CTRL, RX8010_CTRL_STOP);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_clear_bits(rx8010->regs, RX8010_FLAG, RX8010_FLAG_VLF);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int rx8010_init(struct device *dev)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tu8 ctrl[2];\n\tint need_clear = 0, err;\n\n\t \n\terr = regmap_write(rx8010->regs, RX8010_RESV17, 0xD8);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(rx8010->regs, RX8010_RESV30, 0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(rx8010->regs, RX8010_RESV31, 0x08);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(rx8010->regs, RX8010_IRQ, 0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_bulk_read(rx8010->regs, RX8010_FLAG, ctrl, 2);\n\tif (err)\n\t\treturn err;\n\n\tif (ctrl[0] & RX8010_FLAG_VLF)\n\t\tdev_warn(dev, \"Frequency stop was detected\\n\");\n\n\tif (ctrl[0] & RX8010_FLAG_AF) {\n\t\tdev_warn(dev, \"Alarm was detected\\n\");\n\t\tneed_clear = 1;\n\t}\n\n\tif (ctrl[0] & RX8010_FLAG_TF)\n\t\tneed_clear = 1;\n\n\tif (ctrl[0] & RX8010_FLAG_UF)\n\t\tneed_clear = 1;\n\n\tif (need_clear) {\n\t\tctrl[0] &= ~(RX8010_FLAG_AF | RX8010_FLAG_TF | RX8010_FLAG_UF);\n\t\terr = regmap_write(rx8010->regs, RX8010_FLAG, ctrl[0]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\trx8010->ctrlreg = (ctrl[1] & ~RX8010_CTRL_TEST);\n\n\treturn 0;\n}\n\nstatic int rx8010_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tint flagreg, err;\n\n\terr = regmap_bulk_read(rx8010->regs, RX8010_ALMIN, alarmvals, 3);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(rx8010->regs, RX8010_FLAG, &flagreg);\n\tif (err)\n\t\treturn err;\n\n\tt->time.tm_sec = 0;\n\tt->time.tm_min = bcd2bin(alarmvals[0] & 0x7f);\n\tt->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\n\n\tif (!(alarmvals[2] & RX8010_ALARM_AE))\n\t\tt->time.tm_mday = bcd2bin(alarmvals[2] & 0x7f);\n\n\tt->enabled = !!(rx8010->ctrlreg & RX8010_CTRL_AIE);\n\tt->pending = (flagreg & RX8010_FLAG_AF) && t->enabled;\n\n\treturn 0;\n}\n\nstatic int rx8010_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tint err;\n\n\tif (rx8010->ctrlreg & (RX8010_CTRL_AIE | RX8010_CTRL_UIE)) {\n\t\trx8010->ctrlreg &= ~(RX8010_CTRL_AIE | RX8010_CTRL_UIE);\n\t\terr = regmap_write(rx8010->regs, RX8010_CTRL, rx8010->ctrlreg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = regmap_clear_bits(rx8010->regs, RX8010_FLAG, RX8010_FLAG_AF);\n\tif (err)\n\t\treturn err;\n\n\talarmvals[0] = bin2bcd(t->time.tm_min);\n\talarmvals[1] = bin2bcd(t->time.tm_hour);\n\talarmvals[2] = bin2bcd(t->time.tm_mday);\n\n\terr = regmap_bulk_write(rx8010->regs, RX8010_ALMIN, alarmvals, 2);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_clear_bits(rx8010->regs, RX8010_EXT, RX8010_EXT_WADA);\n\tif (err)\n\t\treturn err;\n\n\tif (alarmvals[2] == 0)\n\t\talarmvals[2] |= RX8010_ALARM_AE;\n\n\terr = regmap_write(rx8010->regs, RX8010_ALWDAY, alarmvals[2]);\n\tif (err)\n\t\treturn err;\n\n\tif (t->enabled) {\n\t\tif (rx8010->rtc->uie_rtctimer.enabled)\n\t\t\trx8010->ctrlreg |= RX8010_CTRL_UIE;\n\t\tif (rx8010->rtc->aie_timer.enabled)\n\t\t\trx8010->ctrlreg |=\n\t\t\t\t(RX8010_CTRL_AIE | RX8010_CTRL_UIE);\n\n\t\terr = regmap_write(rx8010->regs, RX8010_CTRL, rx8010->ctrlreg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rx8010_alarm_irq_enable(struct device *dev,\n\t\t\t\t   unsigned int enabled)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tint err;\n\tu8 ctrl;\n\n\tctrl = rx8010->ctrlreg;\n\n\tif (enabled) {\n\t\tif (rx8010->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RX8010_CTRL_UIE;\n\t\tif (rx8010->rtc->aie_timer.enabled)\n\t\t\tctrl |= (RX8010_CTRL_AIE | RX8010_CTRL_UIE);\n\t} else {\n\t\tif (!rx8010->rtc->uie_rtctimer.enabled)\n\t\t\tctrl &= ~RX8010_CTRL_UIE;\n\t\tif (!rx8010->rtc->aie_timer.enabled)\n\t\t\tctrl &= ~RX8010_CTRL_AIE;\n\t}\n\n\terr = regmap_clear_bits(rx8010->regs, RX8010_FLAG, RX8010_FLAG_AF);\n\tif (err)\n\t\treturn err;\n\n\tif (ctrl != rx8010->ctrlreg) {\n\t\trx8010->ctrlreg = ctrl;\n\t\terr = regmap_write(rx8010->regs, RX8010_CTRL, rx8010->ctrlreg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rx8010_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct rx8010_data *rx8010 = dev_get_drvdata(dev);\n\tint tmp, flagreg, err;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\terr = regmap_read(rx8010->regs, RX8010_FLAG, &flagreg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttmp = flagreg & RX8010_FLAG_VLF ? RTC_VL_DATA_INVALID : 0;\n\t\treturn put_user(tmp, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct rtc_class_ops rx8010_rtc_ops = {\n\t.read_time = rx8010_get_time,\n\t.set_time = rx8010_set_time,\n\t.ioctl = rx8010_ioctl,\n\t.read_alarm = rx8010_read_alarm,\n\t.set_alarm = rx8010_set_alarm,\n\t.alarm_irq_enable = rx8010_alarm_irq_enable,\n};\n\nstatic const struct regmap_config rx8010_regmap_config = {\n\t.name = \"rx8010-rtc\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int rx8010_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct rx8010_data *rx8010;\n\tint err = 0;\n\n\trx8010 = devm_kzalloc(dev, sizeof(*rx8010), GFP_KERNEL);\n\tif (!rx8010)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, rx8010);\n\n\trx8010->regs = devm_regmap_init_i2c(client, &rx8010_regmap_config);\n\tif (IS_ERR(rx8010->regs))\n\t\treturn PTR_ERR(rx8010->regs);\n\n\terr = rx8010_init(dev);\n\tif (err)\n\t\treturn err;\n\n\trx8010->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rx8010->rtc))\n\t\treturn PTR_ERR(rx8010->rtc);\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\terr = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\trx8010_irq_1_handler,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"rx8010\", client);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tclear_bit(RTC_FEATURE_ALARM, rx8010->rtc->features);\n\t}\n\n\trx8010->rtc->ops = &rx8010_rtc_ops;\n\trx8010->rtc->max_user_freq = 1;\n\trx8010->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trx8010->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\treturn devm_rtc_register_device(rx8010->rtc);\n}\n\nstatic struct i2c_driver rx8010_driver = {\n\t.driver = {\n\t\t.name = \"rtc-rx8010\",\n\t\t.of_match_table = of_match_ptr(rx8010_of_match),\n\t},\n\t.probe\t\t= rx8010_probe,\n\t.id_table\t= rx8010_id,\n};\n\nmodule_i2c_driver(rx8010_driver);\n\nMODULE_AUTHOR(\"Akshay Bhat <akshay.bhat@timesys.com>\");\nMODULE_DESCRIPTION(\"Epson RX8010SJ RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}