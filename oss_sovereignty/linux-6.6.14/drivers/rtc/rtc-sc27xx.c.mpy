{
  "module_name": "rtc-sc27xx.c",
  "hash_id": "c402e7b962cbd56bc311b8231e6eb01ebca256a40c49f30ea243529701915938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sc27xx.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define SPRD_RTC_SEC_CNT_VALUE\t\t0x0\n#define SPRD_RTC_MIN_CNT_VALUE\t\t0x4\n#define SPRD_RTC_HOUR_CNT_VALUE\t\t0x8\n#define SPRD_RTC_DAY_CNT_VALUE\t\t0xc\n#define SPRD_RTC_SEC_CNT_UPD\t\t0x10\n#define SPRD_RTC_MIN_CNT_UPD\t\t0x14\n#define SPRD_RTC_HOUR_CNT_UPD\t\t0x18\n#define SPRD_RTC_DAY_CNT_UPD\t\t0x1c\n#define SPRD_RTC_SEC_ALM_UPD\t\t0x20\n#define SPRD_RTC_MIN_ALM_UPD\t\t0x24\n#define SPRD_RTC_HOUR_ALM_UPD\t\t0x28\n#define SPRD_RTC_DAY_ALM_UPD\t\t0x2c\n#define SPRD_RTC_INT_EN\t\t\t0x30\n#define SPRD_RTC_INT_RAW_STS\t\t0x34\n#define SPRD_RTC_INT_CLR\t\t0x38\n#define SPRD_RTC_INT_MASK_STS\t\t0x3C\n#define SPRD_RTC_SEC_ALM_VALUE\t\t0x40\n#define SPRD_RTC_MIN_ALM_VALUE\t\t0x44\n#define SPRD_RTC_HOUR_ALM_VALUE\t\t0x48\n#define SPRD_RTC_DAY_ALM_VALUE\t\t0x4c\n#define SPRD_RTC_SPG_VALUE\t\t0x50\n#define SPRD_RTC_SPG_UPD\t\t0x54\n#define SPRD_RTC_PWR_CTRL\t\t0x58\n#define SPRD_RTC_PWR_STS\t\t0x5c\n#define SPRD_RTC_SEC_AUXALM_UPD\t\t0x60\n#define SPRD_RTC_MIN_AUXALM_UPD\t\t0x64\n#define SPRD_RTC_HOUR_AUXALM_UPD\t0x68\n#define SPRD_RTC_DAY_AUXALM_UPD\t\t0x6c\n\n \n#define SPRD_RTC_SEC_EN\t\t\tBIT(0)\n#define SPRD_RTC_MIN_EN\t\t\tBIT(1)\n#define SPRD_RTC_HOUR_EN\t\tBIT(2)\n#define SPRD_RTC_DAY_EN\t\t\tBIT(3)\n#define SPRD_RTC_ALARM_EN\t\tBIT(4)\n#define SPRD_RTC_HRS_FORMAT_EN\t\tBIT(5)\n#define SPRD_RTC_AUXALM_EN\t\tBIT(6)\n#define SPRD_RTC_SPG_UPD_EN\t\tBIT(7)\n#define SPRD_RTC_SEC_UPD_EN\t\tBIT(8)\n#define SPRD_RTC_MIN_UPD_EN\t\tBIT(9)\n#define SPRD_RTC_HOUR_UPD_EN\t\tBIT(10)\n#define SPRD_RTC_DAY_UPD_EN\t\tBIT(11)\n#define SPRD_RTC_ALMSEC_UPD_EN\t\tBIT(12)\n#define SPRD_RTC_ALMMIN_UPD_EN\t\tBIT(13)\n#define SPRD_RTC_ALMHOUR_UPD_EN\t\tBIT(14)\n#define SPRD_RTC_ALMDAY_UPD_EN\t\tBIT(15)\n#define SPRD_RTC_INT_MASK\t\tGENMASK(15, 0)\n\n#define SPRD_RTC_TIME_INT_MASK\t\t\t\t\\\n\t(SPRD_RTC_SEC_UPD_EN | SPRD_RTC_MIN_UPD_EN |\t\\\n\t SPRD_RTC_HOUR_UPD_EN | SPRD_RTC_DAY_UPD_EN)\n\n#define SPRD_RTC_ALMTIME_INT_MASK\t\t\t\t\\\n\t(SPRD_RTC_ALMSEC_UPD_EN | SPRD_RTC_ALMMIN_UPD_EN |\t\\\n\t SPRD_RTC_ALMHOUR_UPD_EN | SPRD_RTC_ALMDAY_UPD_EN)\n\n#define SPRD_RTC_ALM_INT_MASK\t\t\t\\\n\t(SPRD_RTC_SEC_EN | SPRD_RTC_MIN_EN |\t\\\n\t SPRD_RTC_HOUR_EN | SPRD_RTC_DAY_EN |\t\\\n\t SPRD_RTC_ALARM_EN | SPRD_RTC_AUXALM_EN)\n\n \n#define SPRD_RTC_SEC_MASK\t\tGENMASK(5, 0)\n#define SPRD_RTC_MIN_MASK\t\tGENMASK(5, 0)\n#define SPRD_RTC_HOUR_MASK\t\tGENMASK(4, 0)\n#define SPRD_RTC_DAY_MASK\t\tGENMASK(15, 0)\n\n \n#define SPRD_RTC_ALMLOCK_MASK\t\tGENMASK(7, 0)\n#define SPRD_RTC_ALM_UNLOCK\t\t0xa5\n#define SPRD_RTC_ALM_LOCK\t\t(~SPRD_RTC_ALM_UNLOCK &\t\\\n\t\t\t\t\t SPRD_RTC_ALMLOCK_MASK)\n\n \n#define SPRD_RTC_POWEROFF_ALM_FLAG\tBIT(8)\n\n \n#define SPRD_RTC_POWER_RESET_VALUE\t0x96\n#define SPRD_RTC_POWER_STS_CLEAR\tGENMASK(7, 0)\n#define SPRD_RTC_POWER_STS_SHIFT\t8\n#define SPRD_RTC_POWER_STS_VALID\t\\\n\t(~SPRD_RTC_POWER_RESET_VALUE << SPRD_RTC_POWER_STS_SHIFT)\n\n \n#define SPRD_RTC_POLL_TIMEOUT\t\t200000\n#define SPRD_RTC_POLL_DELAY_US\t\t20000\n\nstruct sprd_rtc {\n\tstruct rtc_device\t*rtc;\n\tstruct regmap\t\t*regmap;\n\tstruct device\t\t*dev;\n\tu32\t\t\tbase;\n\tint\t\t\tirq;\n\tbool\t\t\tvalid;\n};\n\n \nenum sprd_rtc_reg_types {\n\tSPRD_RTC_TIME,\n\tSPRD_RTC_ALARM,\n\tSPRD_RTC_AUX_ALARM,\n};\n\nstatic int sprd_rtc_clear_alarm_ints(struct sprd_rtc *rtc)\n{\n\treturn regmap_write(rtc->regmap, rtc->base + SPRD_RTC_INT_CLR,\n\t\t\t    SPRD_RTC_ALM_INT_MASK);\n}\n\nstatic int sprd_rtc_lock_alarm(struct sprd_rtc *rtc, bool lock)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(rtc->regmap, rtc->base + SPRD_RTC_SPG_VALUE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~SPRD_RTC_ALMLOCK_MASK;\n\tif (lock)\n\t\tval |= SPRD_RTC_ALM_LOCK;\n\telse\n\t\tval |= SPRD_RTC_ALM_UNLOCK | SPRD_RTC_POWEROFF_ALM_FLAG;\n\n\tret = regmap_write(rtc->regmap, rtc->base + SPRD_RTC_SPG_UPD, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(rtc->regmap,\n\t\t\t\t       rtc->base + SPRD_RTC_INT_RAW_STS, val,\n\t\t\t\t       (val & SPRD_RTC_SPG_UPD_EN),\n\t\t\t\t       SPRD_RTC_POLL_DELAY_US,\n\t\t\t\t       SPRD_RTC_POLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(rtc->dev, \"failed to update SPG value:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn regmap_write(rtc->regmap, rtc->base + SPRD_RTC_INT_CLR,\n\t\t\t    SPRD_RTC_SPG_UPD_EN);\n}\n\nstatic int sprd_rtc_get_secs(struct sprd_rtc *rtc, enum sprd_rtc_reg_types type,\n\t\t\t     time64_t *secs)\n{\n\tu32 sec_reg, min_reg, hour_reg, day_reg;\n\tu32 val, sec, min, hour, day;\n\tint ret;\n\n\tswitch (type) {\n\tcase SPRD_RTC_TIME:\n\t\tsec_reg = SPRD_RTC_SEC_CNT_VALUE;\n\t\tmin_reg = SPRD_RTC_MIN_CNT_VALUE;\n\t\thour_reg = SPRD_RTC_HOUR_CNT_VALUE;\n\t\tday_reg = SPRD_RTC_DAY_CNT_VALUE;\n\t\tbreak;\n\tcase SPRD_RTC_ALARM:\n\t\tsec_reg = SPRD_RTC_SEC_ALM_VALUE;\n\t\tmin_reg = SPRD_RTC_MIN_ALM_VALUE;\n\t\thour_reg = SPRD_RTC_HOUR_ALM_VALUE;\n\t\tday_reg = SPRD_RTC_DAY_ALM_VALUE;\n\t\tbreak;\n\tcase SPRD_RTC_AUX_ALARM:\n\t\tsec_reg = SPRD_RTC_SEC_AUXALM_UPD;\n\t\tmin_reg = SPRD_RTC_MIN_AUXALM_UPD;\n\t\thour_reg = SPRD_RTC_HOUR_AUXALM_UPD;\n\t\tday_reg = SPRD_RTC_DAY_AUXALM_UPD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(rtc->regmap, rtc->base + sec_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tsec = val & SPRD_RTC_SEC_MASK;\n\n\tret = regmap_read(rtc->regmap, rtc->base + min_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmin = val & SPRD_RTC_MIN_MASK;\n\n\tret = regmap_read(rtc->regmap, rtc->base + hour_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\thour = val & SPRD_RTC_HOUR_MASK;\n\n\tret = regmap_read(rtc->regmap, rtc->base + day_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tday = val & SPRD_RTC_DAY_MASK;\n\t*secs = (((time64_t)(day * 24) + hour) * 60 + min) * 60 + sec;\n\treturn 0;\n}\n\nstatic int sprd_rtc_set_secs(struct sprd_rtc *rtc, enum sprd_rtc_reg_types type,\n\t\t\t     time64_t secs)\n{\n\tu32 sec_reg, min_reg, hour_reg, day_reg, sts_mask;\n\tu32 sec, min, hour, day, val;\n\tint ret, rem;\n\n\t \n\tday = div_s64_rem(secs, 86400, &rem);\n\thour = rem / 3600;\n\trem -= hour * 3600;\n\tmin = rem / 60;\n\tsec = rem - min * 60;\n\n\tswitch (type) {\n\tcase SPRD_RTC_TIME:\n\t\tsec_reg = SPRD_RTC_SEC_CNT_UPD;\n\t\tmin_reg = SPRD_RTC_MIN_CNT_UPD;\n\t\thour_reg = SPRD_RTC_HOUR_CNT_UPD;\n\t\tday_reg = SPRD_RTC_DAY_CNT_UPD;\n\t\tsts_mask = SPRD_RTC_TIME_INT_MASK;\n\t\tbreak;\n\tcase SPRD_RTC_ALARM:\n\t\tsec_reg = SPRD_RTC_SEC_ALM_UPD;\n\t\tmin_reg = SPRD_RTC_MIN_ALM_UPD;\n\t\thour_reg = SPRD_RTC_HOUR_ALM_UPD;\n\t\tday_reg = SPRD_RTC_DAY_ALM_UPD;\n\t\tsts_mask = SPRD_RTC_ALMTIME_INT_MASK;\n\t\tbreak;\n\tcase SPRD_RTC_AUX_ALARM:\n\t\tsec_reg = SPRD_RTC_SEC_AUXALM_UPD;\n\t\tmin_reg = SPRD_RTC_MIN_AUXALM_UPD;\n\t\thour_reg = SPRD_RTC_HOUR_AUXALM_UPD;\n\t\tday_reg = SPRD_RTC_DAY_AUXALM_UPD;\n\t\tsts_mask = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(rtc->regmap, rtc->base + sec_reg, sec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rtc->regmap, rtc->base + min_reg, min);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rtc->regmap, rtc->base + hour_reg, hour);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rtc->regmap, rtc->base + day_reg, day);\n\tif (ret)\n\t\treturn ret;\n\n\tif (type == SPRD_RTC_AUX_ALARM)\n\t\treturn 0;\n\n\t \n\tret = regmap_read_poll_timeout(rtc->regmap,\n\t\t\t\t       rtc->base + SPRD_RTC_INT_RAW_STS, val,\n\t\t\t\t       ((val & sts_mask) == sts_mask),\n\t\t\t\t       SPRD_RTC_POLL_DELAY_US,\n\t\t\t\t       SPRD_RTC_POLL_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(rtc->dev, \"set time/alarm values timeout\\n\");\n\t\treturn ret;\n\t}\n\n\treturn regmap_write(rtc->regmap, rtc->base + SPRD_RTC_INT_CLR,\n\t\t\t    sts_mask);\n}\n\nstatic int sprd_rtc_set_aux_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t secs = rtc_tm_to_time64(&alrm->time);\n\tint ret;\n\n\t \n\tret = regmap_write(rtc->regmap, rtc->base + SPRD_RTC_INT_CLR,\n\t\t\t   SPRD_RTC_AUXALM_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sprd_rtc_set_secs(rtc, SPRD_RTC_AUX_ALARM, secs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (alrm->enabled) {\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t\t SPRD_RTC_AUXALM_EN,\n\t\t\t\t\t SPRD_RTC_AUXALM_EN);\n\t} else {\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t\t SPRD_RTC_AUXALM_EN, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int sprd_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t secs;\n\tint ret;\n\n\tif (!rtc->valid) {\n\t\tdev_warn(dev, \"RTC values are invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = sprd_rtc_get_secs(rtc, SPRD_RTC_TIME, &secs);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_time64_to_tm(secs, tm);\n\treturn 0;\n}\n\nstatic int sprd_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t secs = rtc_tm_to_time64(tm);\n\tint ret;\n\n\tret = sprd_rtc_set_secs(rtc, SPRD_RTC_TIME, secs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!rtc->valid) {\n\t\t \n\t\tret = regmap_write(rtc->regmap, rtc->base + SPRD_RTC_PWR_CTRL,\n\t\t\t\t   SPRD_RTC_POWER_STS_CLEAR);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_write(rtc->regmap, rtc->base + SPRD_RTC_PWR_CTRL,\n\t\t\t\t   SPRD_RTC_POWER_STS_VALID);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trtc->valid = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t secs;\n\tint ret;\n\tu32 val;\n\n\t \n\tret = sprd_rtc_get_secs(rtc, SPRD_RTC_ALARM, &secs);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_time64_to_tm(secs, &alrm->time);\n\n\tret = regmap_read(rtc->regmap, rtc->base + SPRD_RTC_INT_EN, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled = !!(val & SPRD_RTC_ALARM_EN);\n\n\tret = regmap_read(rtc->regmap, rtc->base + SPRD_RTC_INT_RAW_STS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talrm->pending = !!(val & SPRD_RTC_ALARM_EN);\n\treturn 0;\n}\n\nstatic int sprd_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t secs = rtc_tm_to_time64(&alrm->time);\n\tstruct rtc_time aie_time =\n\t\trtc_ktime_to_tm(rtc->rtc->aie_timer.node.expires);\n\tint ret;\n\n\t \n\tif (!rtc->rtc->aie_timer.enabled || rtc_tm_sub(&aie_time, &alrm->time))\n\t\treturn sprd_rtc_set_aux_alarm(dev, alrm);\n\n\t \n\tret = regmap_write(rtc->regmap, rtc->base + SPRD_RTC_INT_CLR,\n\t\t\t   SPRD_RTC_ALARM_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sprd_rtc_set_secs(rtc, SPRD_RTC_ALARM, secs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (alrm->enabled) {\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t\t SPRD_RTC_ALARM_EN,\n\t\t\t\t\t SPRD_RTC_ALARM_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = sprd_rtc_lock_alarm(rtc, false);\n\t} else {\n\t\tregmap_update_bits(rtc->regmap,\n\t\t\t\t   rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t   SPRD_RTC_ALARM_EN, 0);\n\n\t\t \n\t\tret = sprd_rtc_lock_alarm(rtc, true);\n\t}\n\n\treturn ret;\n}\n\nstatic int sprd_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct sprd_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (enabled) {\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t\t SPRD_RTC_ALARM_EN | SPRD_RTC_AUXALM_EN,\n\t\t\t\t\t SPRD_RTC_ALARM_EN | SPRD_RTC_AUXALM_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = sprd_rtc_lock_alarm(rtc, false);\n\t} else {\n\t\tregmap_update_bits(rtc->regmap, rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t   SPRD_RTC_ALARM_EN | SPRD_RTC_AUXALM_EN, 0);\n\n\t\tret = sprd_rtc_lock_alarm(rtc, true);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops sprd_rtc_ops = {\n\t.read_time = sprd_rtc_read_time,\n\t.set_time = sprd_rtc_set_time,\n\t.read_alarm = sprd_rtc_read_alarm,\n\t.set_alarm = sprd_rtc_set_alarm,\n\t.alarm_irq_enable = sprd_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t sprd_rtc_handler(int irq, void *dev_id)\n{\n\tstruct sprd_rtc *rtc = dev_id;\n\tint ret;\n\n\tret = sprd_rtc_clear_alarm_ints(rtc);\n\tif (ret)\n\t\treturn IRQ_RETVAL(ret);\n\n\trtc_update_irq(rtc->rtc, 1, RTC_AF | RTC_IRQF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int sprd_rtc_check_power_down(struct sprd_rtc *rtc)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(rtc->regmap, rtc->base + SPRD_RTC_PWR_STS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trtc->valid = val != SPRD_RTC_POWER_RESET_VALUE;\n\treturn 0;\n}\n\nstatic int sprd_rtc_check_alarm_int(struct sprd_rtc *rtc)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(rtc->regmap, rtc->base + SPRD_RTC_SPG_VALUE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(val & SPRD_RTC_POWEROFF_ALM_FLAG))\n\t\treturn 0;\n\n\treturn regmap_update_bits(rtc->regmap, rtc->base + SPRD_RTC_INT_EN,\n\t\t\t\t  SPRD_RTC_ALARM_EN, SPRD_RTC_ALARM_EN);\n}\n\nstatic int sprd_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct sprd_rtc *rtc;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!rtc->regmap)\n\t\treturn -ENODEV;\n\n\tret = of_property_read_u32(node, \"reg\", &rtc->base);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get RTC base address\\n\");\n\t\treturn ret;\n\t}\n\n\trtc->irq = platform_get_irq(pdev, 0);\n\tif (rtc->irq < 0)\n\t\treturn rtc->irq;\n\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc))\n\t\treturn PTR_ERR(rtc->rtc);\n\n\trtc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, rtc);\n\n\t \n\tret = sprd_rtc_check_alarm_int(rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to check RTC alarm interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sprd_rtc_check_power_down(rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to check RTC time values\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\n\t\t\t\t\tsprd_rtc_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_EARLY_RESUME,\n\t\t\t\t\tpdev->name, rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request RTC irq\\n\");\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\trtc->rtc->ops = &sprd_rtc_ops;\n\trtc->rtc->range_min = 0;\n\trtc->rtc->range_max = 5662310399LL;\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret) {\n\t\tdevice_init_wakeup(&pdev->dev, 0);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_rtc_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-rtc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_rtc_of_match);\n\nstatic struct platform_driver sprd_rtc_driver = {\n\t.driver = {\n\t\t.name = \"sprd-rtc\",\n\t\t.of_match_table = sprd_rtc_of_match,\n\t},\n\t.probe\t= sprd_rtc_probe,\n};\nmodule_platform_driver(sprd_rtc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Spreadtrum RTC Device Driver\");\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@spreadtrum.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}