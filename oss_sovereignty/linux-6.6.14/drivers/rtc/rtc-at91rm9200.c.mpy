{
  "module_name": "rtc-at91rm9200.c",
  "hash_id": "6bc6d58e4b744abd5d91a2e2db60619ccb17d4b421fec1114565a739c3767f16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-at91rm9200.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/spinlock.h>\n#include <linux/suspend.h>\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define\tAT91_RTC_CR\t\t0x00\t\t\t \n#define\t\tAT91_RTC_UPDTIM\t\tBIT(0)\t\t \n#define\t\tAT91_RTC_UPDCAL\t\tBIT(1)\t\t \n\n#define\tAT91_RTC_MR\t\t0x04\t\t\t \n#define\t\tAT91_RTC_HRMOD\t\tBIT(0)\t\t \n#define\t\tAT91_RTC_NEGPPM\t\tBIT(4)\t\t \n#define\t\tAT91_RTC_CORRECTION\tGENMASK(14, 8)\t \n#define\t\tAT91_RTC_HIGHPPM\tBIT(15)\t\t \n\n#define\tAT91_RTC_TIMR\t\t0x08\t\t\t \n#define\t\tAT91_RTC_SEC\t\tGENMASK(6, 0)\t \n#define\t\tAT91_RTC_MIN\t\tGENMASK(14, 8)\t \n#define\t\tAT91_RTC_HOUR\t\tGENMASK(21, 16)\t \n#define\t\tAT91_RTC_AMPM\t\tBIT(22)\t\t \n\n#define\tAT91_RTC_CALR\t\t0x0c\t\t\t \n#define\t\tAT91_RTC_CENT\t\tGENMASK(6, 0)\t \n#define\t\tAT91_RTC_YEAR\t\tGENMASK(15, 8)\t \n#define\t\tAT91_RTC_MONTH\t\tGENMASK(20, 16)\t \n#define\t\tAT91_RTC_DAY\t\tGENMASK(23, 21)\t \n#define\t\tAT91_RTC_DATE\t\tGENMASK(29, 24)\t \n\n#define\tAT91_RTC_TIMALR\t\t0x10\t\t\t \n#define\t\tAT91_RTC_SECEN\t\tBIT(7)\t\t \n#define\t\tAT91_RTC_MINEN\t\tBIT(15)\t\t \n#define\t\tAT91_RTC_HOUREN\t\tBIT(23)\t\t \n\n#define\tAT91_RTC_CALALR\t\t0x14\t\t\t \n#define\t\tAT91_RTC_MTHEN\t\tBIT(23)\t\t \n#define\t\tAT91_RTC_DATEEN\t\tBIT(31)\t\t \n\n#define\tAT91_RTC_SR\t\t0x18\t\t\t \n#define\t\tAT91_RTC_ACKUPD\t\tBIT(0)\t\t \n#define\t\tAT91_RTC_ALARM\t\tBIT(1)\t\t \n#define\t\tAT91_RTC_SECEV\t\tBIT(2)\t\t \n#define\t\tAT91_RTC_TIMEV\t\tBIT(3)\t\t \n#define\t\tAT91_RTC_CALEV\t\tBIT(4)\t\t \n\n#define\tAT91_RTC_SCCR\t\t0x1c\t\t\t \n#define\tAT91_RTC_IER\t\t0x20\t\t\t \n#define\tAT91_RTC_IDR\t\t0x24\t\t\t \n#define\tAT91_RTC_IMR\t\t0x28\t\t\t \n\n#define\tAT91_RTC_VER\t\t0x2c\t\t\t \n#define\t\tAT91_RTC_NVTIM\t\tBIT(0)\t\t \n#define\t\tAT91_RTC_NVCAL\t\tBIT(1)\t\t \n#define\t\tAT91_RTC_NVTIMALR\tBIT(2)\t\t \n#define\t\tAT91_RTC_NVCALALR\tBIT(3)\t\t \n\n#define AT91_RTC_CORR_DIVIDEND\t\t3906000\n#define AT91_RTC_CORR_LOW_RATIO\t\t20\n\n#define at91_rtc_read(field) \\\n\treadl_relaxed(at91_rtc_regs + field)\n#define at91_rtc_write(field, val) \\\n\twritel_relaxed((val), at91_rtc_regs + field)\n\nstruct at91_rtc_config {\n\tbool use_shadow_imr;\n\tbool has_correction;\n};\n\nstatic const struct at91_rtc_config *at91_rtc_config;\nstatic DECLARE_COMPLETION(at91_rtc_updated);\nstatic DECLARE_COMPLETION(at91_rtc_upd_rdy);\nstatic void __iomem *at91_rtc_regs;\nstatic int irq;\nstatic DEFINE_SPINLOCK(at91_rtc_lock);\nstatic u32 at91_rtc_shadow_imr;\nstatic bool suspended;\nstatic DEFINE_SPINLOCK(suspended_lock);\nstatic unsigned long cached_events;\nstatic u32 at91_rtc_imr;\nstatic struct clk *sclk;\n\nstatic void at91_rtc_write_ier(u32 mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&at91_rtc_lock, flags);\n\tat91_rtc_shadow_imr |= mask;\n\tat91_rtc_write(AT91_RTC_IER, mask);\n\tspin_unlock_irqrestore(&at91_rtc_lock, flags);\n}\n\nstatic void at91_rtc_write_idr(u32 mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&at91_rtc_lock, flags);\n\tat91_rtc_write(AT91_RTC_IDR, mask);\n\t \n\tat91_rtc_read(AT91_RTC_SR);\n\tat91_rtc_shadow_imr &= ~mask;\n\tspin_unlock_irqrestore(&at91_rtc_lock, flags);\n}\n\nstatic u32 at91_rtc_read_imr(void)\n{\n\tunsigned long flags;\n\tu32 mask;\n\n\tif (at91_rtc_config->use_shadow_imr) {\n\t\tspin_lock_irqsave(&at91_rtc_lock, flags);\n\t\tmask = at91_rtc_shadow_imr;\n\t\tspin_unlock_irqrestore(&at91_rtc_lock, flags);\n\t} else {\n\t\tmask = at91_rtc_read(AT91_RTC_IMR);\n\t}\n\n\treturn mask;\n}\n\n \nstatic void at91_rtc_decodetime(unsigned int timereg, unsigned int calreg,\n\t\t\t\tstruct rtc_time *tm)\n{\n\tunsigned int time, date;\n\n\t \n\tdo {\n\t\ttime = at91_rtc_read(timereg);\n\t\tdate = at91_rtc_read(calreg);\n\t} while ((time != at91_rtc_read(timereg)) ||\n\t\t\t(date != at91_rtc_read(calreg)));\n\n\ttm->tm_sec  = bcd2bin(FIELD_GET(AT91_RTC_SEC, time));\n\ttm->tm_min  = bcd2bin(FIELD_GET(AT91_RTC_MIN, time));\n\ttm->tm_hour = bcd2bin(FIELD_GET(AT91_RTC_HOUR, time));\n\n\t \n\ttm->tm_year  = bcd2bin(date & AT91_RTC_CENT) * 100;\t \n\ttm->tm_year += bcd2bin(FIELD_GET(AT91_RTC_YEAR, date));\t \n\n\ttm->tm_wday = bcd2bin(FIELD_GET(AT91_RTC_DAY, date)) - 1;\t \n\ttm->tm_mon  = bcd2bin(FIELD_GET(AT91_RTC_MONTH, date)) - 1;\n\ttm->tm_mday = bcd2bin(FIELD_GET(AT91_RTC_DATE, date));\n}\n\n \nstatic int at91_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tat91_rtc_decodetime(AT91_RTC_TIMR, AT91_RTC_CALR, tm);\n\ttm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\n\ttm->tm_year = tm->tm_year - 1900;\n\n\tdev_dbg(dev, \"%s(): %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\n \nstatic int at91_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long cr;\n\n\tdev_dbg(dev, \"%s(): %ptR\\n\", __func__, tm);\n\n\twait_for_completion(&at91_rtc_upd_rdy);\n\n\t \n\tcr = at91_rtc_read(AT91_RTC_CR);\n\tat91_rtc_write(AT91_RTC_CR, cr | AT91_RTC_UPDCAL | AT91_RTC_UPDTIM);\n\n\tat91_rtc_write_ier(AT91_RTC_ACKUPD);\n\twait_for_completion(&at91_rtc_updated);\t \n\tat91_rtc_write_idr(AT91_RTC_ACKUPD);\n\n\tat91_rtc_write(AT91_RTC_TIMR,\n\t\t\t  FIELD_PREP(AT91_RTC_SEC, bin2bcd(tm->tm_sec))\n\t\t\t| FIELD_PREP(AT91_RTC_MIN, bin2bcd(tm->tm_min))\n\t\t\t| FIELD_PREP(AT91_RTC_HOUR, bin2bcd(tm->tm_hour)));\n\n\tat91_rtc_write(AT91_RTC_CALR,\n\t\t\t  FIELD_PREP(AT91_RTC_CENT,\n\t\t\t\t     bin2bcd((tm->tm_year + 1900) / 100))\n\t\t\t| FIELD_PREP(AT91_RTC_YEAR, bin2bcd(tm->tm_year % 100))\n\t\t\t| FIELD_PREP(AT91_RTC_MONTH, bin2bcd(tm->tm_mon + 1))\n\t\t\t| FIELD_PREP(AT91_RTC_DAY, bin2bcd(tm->tm_wday + 1))\n\t\t\t| FIELD_PREP(AT91_RTC_DATE, bin2bcd(tm->tm_mday)));\n\n\t \n\tcr = at91_rtc_read(AT91_RTC_CR);\n\tat91_rtc_write(AT91_RTC_SCCR, AT91_RTC_SECEV);\n\tat91_rtc_write(AT91_RTC_CR, cr & ~(AT91_RTC_UPDCAL | AT91_RTC_UPDTIM));\n\tat91_rtc_write_ier(AT91_RTC_SECEV);\n\n\treturn 0;\n}\n\n \nstatic int at91_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_time *tm = &alrm->time;\n\n\tat91_rtc_decodetime(AT91_RTC_TIMALR, AT91_RTC_CALALR, tm);\n\ttm->tm_year = -1;\n\n\talrm->enabled = (at91_rtc_read_imr() & AT91_RTC_ALARM)\n\t\t\t? 1 : 0;\n\n\tdev_dbg(dev, \"%s(): %ptR %sabled\\n\", __func__, tm,\n\t\talrm->enabled ? \"en\" : \"dis\");\n\n\treturn 0;\n}\n\n \nstatic int at91_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_time tm = alrm->time;\n\n\tat91_rtc_write_idr(AT91_RTC_ALARM);\n\tat91_rtc_write(AT91_RTC_TIMALR,\n\t\t  FIELD_PREP(AT91_RTC_SEC, bin2bcd(alrm->time.tm_sec))\n\t\t| FIELD_PREP(AT91_RTC_MIN, bin2bcd(alrm->time.tm_min))\n\t\t| FIELD_PREP(AT91_RTC_HOUR, bin2bcd(alrm->time.tm_hour))\n\t\t| AT91_RTC_HOUREN | AT91_RTC_MINEN | AT91_RTC_SECEN);\n\tat91_rtc_write(AT91_RTC_CALALR,\n\t\t  FIELD_PREP(AT91_RTC_MONTH, bin2bcd(alrm->time.tm_mon + 1))\n\t\t| FIELD_PREP(AT91_RTC_DATE, bin2bcd(alrm->time.tm_mday))\n\t\t| AT91_RTC_DATEEN | AT91_RTC_MTHEN);\n\n\tif (alrm->enabled) {\n\t\tat91_rtc_write(AT91_RTC_SCCR, AT91_RTC_ALARM);\n\t\tat91_rtc_write_ier(AT91_RTC_ALARM);\n\t}\n\n\tdev_dbg(dev, \"%s(): %ptR\\n\", __func__, &tm);\n\n\treturn 0;\n}\n\nstatic int at91_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tdev_dbg(dev, \"%s(): cmd=%08x\\n\", __func__, enabled);\n\n\tif (enabled) {\n\t\tat91_rtc_write(AT91_RTC_SCCR, AT91_RTC_ALARM);\n\t\tat91_rtc_write_ier(AT91_RTC_ALARM);\n\t} else\n\t\tat91_rtc_write_idr(AT91_RTC_ALARM);\n\n\treturn 0;\n}\n\nstatic int at91_rtc_readoffset(struct device *dev, long *offset)\n{\n\tu32 mr = at91_rtc_read(AT91_RTC_MR);\n\tlong val = FIELD_GET(AT91_RTC_CORRECTION, mr);\n\n\tif (!val) {\n\t\t*offset = 0;\n\t\treturn 0;\n\t}\n\n\tval++;\n\n\tif (!(mr & AT91_RTC_NEGPPM))\n\t\tval = -val;\n\n\tif (!(mr & AT91_RTC_HIGHPPM))\n\t\tval *= AT91_RTC_CORR_LOW_RATIO;\n\n\t*offset = DIV_ROUND_CLOSEST(AT91_RTC_CORR_DIVIDEND, val);\n\n\treturn 0;\n}\n\nstatic int at91_rtc_setoffset(struct device *dev, long offset)\n{\n\tlong corr;\n\tu32 mr;\n\n\tif (offset > AT91_RTC_CORR_DIVIDEND / 2)\n\t\treturn -ERANGE;\n\tif (offset < -AT91_RTC_CORR_DIVIDEND / 2)\n\t\treturn -ERANGE;\n\n\tmr = at91_rtc_read(AT91_RTC_MR);\n\tmr &= ~(AT91_RTC_NEGPPM | AT91_RTC_CORRECTION | AT91_RTC_HIGHPPM);\n\n\tif (offset > 0)\n\t\tmr |= AT91_RTC_NEGPPM;\n\telse\n\t\toffset = -offset;\n\n\t \n\tif (offset < 764) {\n\t\tat91_rtc_write(AT91_RTC_MR, mr & ~AT91_RTC_NEGPPM);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (offset < 29208) {\n\t\tcorr = DIV_ROUND_CLOSEST(AT91_RTC_CORR_DIVIDEND, offset * AT91_RTC_CORR_LOW_RATIO);\n\t} else {\n\t\tcorr = DIV_ROUND_CLOSEST(AT91_RTC_CORR_DIVIDEND, offset);\n\t\tmr |= AT91_RTC_HIGHPPM;\n\t}\n\n\tif (corr > 128)\n\t\tcorr = 128;\n\n\tmr |= FIELD_PREP(AT91_RTC_CORRECTION, corr - 1);\n\n\tat91_rtc_write(AT91_RTC_MR, mr);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t at91_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct rtc_device *rtc = platform_get_drvdata(pdev);\n\tunsigned int rtsr;\n\tunsigned long events = 0;\n\tint ret = IRQ_NONE;\n\n\tspin_lock(&suspended_lock);\n\trtsr = at91_rtc_read(AT91_RTC_SR) & at91_rtc_read_imr();\n\tif (rtsr) {\t\t \n\t\tif (rtsr & AT91_RTC_ALARM)\n\t\t\tevents |= (RTC_AF | RTC_IRQF);\n\t\tif (rtsr & AT91_RTC_SECEV) {\n\t\t\tcomplete(&at91_rtc_upd_rdy);\n\t\t\tat91_rtc_write_idr(AT91_RTC_SECEV);\n\t\t}\n\t\tif (rtsr & AT91_RTC_ACKUPD)\n\t\t\tcomplete(&at91_rtc_updated);\n\n\t\tat91_rtc_write(AT91_RTC_SCCR, rtsr);\t \n\n\t\tif (!suspended) {\n\t\t\trtc_update_irq(rtc, 1, events);\n\n\t\t\tdev_dbg(&pdev->dev, \"%s(): num=%ld, events=0x%02lx\\n\",\n\t\t\t\t__func__, events >> 8, events & 0x000000FF);\n\t\t} else {\n\t\t\tcached_events |= events;\n\t\t\tat91_rtc_write_idr(at91_rtc_imr);\n\t\t\tpm_system_wakeup();\n\t\t}\n\n\t\tret = IRQ_HANDLED;\n\t}\n\tspin_unlock(&suspended_lock);\n\n\treturn ret;\n}\n\nstatic const struct at91_rtc_config at91rm9200_config = {\n};\n\nstatic const struct at91_rtc_config at91sam9x5_config = {\n\t.use_shadow_imr\t= true,\n};\n\nstatic const struct at91_rtc_config sama5d4_config = {\n\t.has_correction = true,\n};\n\nstatic const struct of_device_id at91_rtc_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91rm9200-rtc\",\n\t\t.data = &at91rm9200_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9x5-rtc\",\n\t\t.data = &at91sam9x5_config,\n\t}, {\n\t\t.compatible = \"atmel,sama5d4-rtc\",\n\t\t.data = &sama5d4_config,\n\t}, {\n\t\t.compatible = \"atmel,sama5d2-rtc\",\n\t\t.data = &sama5d4_config,\n\t}, {\n\t\t.compatible = \"microchip,sam9x60-rtc\",\n\t\t.data = &sama5d4_config,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, at91_rtc_dt_ids);\n\nstatic const struct rtc_class_ops at91_rtc_ops = {\n\t.read_time\t= at91_rtc_readtime,\n\t.set_time\t= at91_rtc_settime,\n\t.read_alarm\t= at91_rtc_readalarm,\n\t.set_alarm\t= at91_rtc_setalarm,\n\t.alarm_irq_enable = at91_rtc_alarm_irq_enable,\n};\n\nstatic const struct rtc_class_ops sama5d4_rtc_ops = {\n\t.read_time\t= at91_rtc_readtime,\n\t.set_time\t= at91_rtc_settime,\n\t.read_alarm\t= at91_rtc_readalarm,\n\t.set_alarm\t= at91_rtc_setalarm,\n\t.alarm_irq_enable = at91_rtc_alarm_irq_enable,\n\t.set_offset\t= at91_rtc_setoffset,\n\t.read_offset\t= at91_rtc_readoffset,\n};\n\n \nstatic int __init at91_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\tstruct resource *regs;\n\tint ret = 0;\n\n\tat91_rtc_config = of_device_get_match_data(&pdev->dev);\n\tif (!at91_rtc_config)\n\t\treturn -ENODEV;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"no mmio resource defined\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\tat91_rtc_regs = devm_ioremap(&pdev->dev, regs->start,\n\t\t\t\t     resource_size(regs));\n\tif (!at91_rtc_regs) {\n\t\tdev_err(&pdev->dev, \"failed to map registers, aborting.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\tplatform_set_drvdata(pdev, rtc);\n\n\tsclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sclk))\n\t\treturn PTR_ERR(sclk);\n\n\tret = clk_prepare_enable(sclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not enable slow clock\\n\");\n\t\treturn ret;\n\t}\n\n\tat91_rtc_write(AT91_RTC_CR, 0);\n\tat91_rtc_write(AT91_RTC_MR, at91_rtc_read(AT91_RTC_MR) & ~AT91_RTC_HRMOD);\n\n\t \n\tat91_rtc_write_idr(AT91_RTC_ACKUPD | AT91_RTC_ALARM |\n\t\t\t\t\tAT91_RTC_SECEV | AT91_RTC_TIMEV |\n\t\t\t\t\tAT91_RTC_CALEV);\n\n\tret = devm_request_irq(&pdev->dev, irq, at91_rtc_interrupt,\n\t\t\t       IRQF_SHARED | IRQF_COND_SUSPEND,\n\t\t\t       \"at91_rtc\", pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ %d already in use.\\n\", irq);\n\t\tgoto err_clk;\n\t}\n\n\t \n\tif (!device_can_wakeup(&pdev->dev))\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tif (at91_rtc_config->has_correction)\n\t\trtc->ops = &sama5d4_rtc_ops;\n\telse\n\t\trtc->ops = &at91_rtc_ops;\n\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_1900;\n\trtc->range_max = RTC_TIMESTAMP_END_2099;\n\tret = devm_rtc_register_device(rtc);\n\tif (ret)\n\t\tgoto err_clk;\n\n\t \n\tat91_rtc_write_ier(AT91_RTC_SECEV);\n\n\tdev_info(&pdev->dev, \"AT91 Real Time Clock driver.\\n\");\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(sclk);\n\n\treturn ret;\n}\n\n \nstatic int __exit at91_rtc_remove(struct platform_device *pdev)\n{\n\t \n\tat91_rtc_write_idr(AT91_RTC_ACKUPD | AT91_RTC_ALARM |\n\t\t\t\t\tAT91_RTC_SECEV | AT91_RTC_TIMEV |\n\t\t\t\t\tAT91_RTC_CALEV);\n\n\tclk_disable_unprepare(sclk);\n\n\treturn 0;\n}\n\nstatic void at91_rtc_shutdown(struct platform_device *pdev)\n{\n\t \n\tat91_rtc_write(AT91_RTC_IDR, AT91_RTC_ACKUPD | AT91_RTC_ALARM |\n\t\t\t\t\tAT91_RTC_SECEV | AT91_RTC_TIMEV |\n\t\t\t\t\tAT91_RTC_CALEV);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\n \n\nstatic int at91_rtc_suspend(struct device *dev)\n{\n\t \n\tat91_rtc_write(AT91_RTC_SCCR, AT91_RTC_ALARM);\n\n\tat91_rtc_imr = at91_rtc_read_imr()\n\t\t\t& (AT91_RTC_ALARM|AT91_RTC_SECEV);\n\tif (at91_rtc_imr) {\n\t\tif (device_may_wakeup(dev)) {\n\t\t\tunsigned long flags;\n\n\t\t\tenable_irq_wake(irq);\n\n\t\t\tspin_lock_irqsave(&suspended_lock, flags);\n\t\t\tsuspended = true;\n\t\t\tspin_unlock_irqrestore(&suspended_lock, flags);\n\t\t} else {\n\t\t\tat91_rtc_write_idr(at91_rtc_imr);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int at91_rtc_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc = dev_get_drvdata(dev);\n\n\tif (at91_rtc_imr) {\n\t\tif (device_may_wakeup(dev)) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&suspended_lock, flags);\n\n\t\t\tif (cached_events) {\n\t\t\t\trtc_update_irq(rtc, 1, cached_events);\n\t\t\t\tcached_events = 0;\n\t\t\t}\n\n\t\t\tsuspended = false;\n\t\t\tspin_unlock_irqrestore(&suspended_lock, flags);\n\n\t\t\tdisable_irq_wake(irq);\n\t\t}\n\t\tat91_rtc_write_ier(at91_rtc_imr);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(at91_rtc_pm_ops, at91_rtc_suspend, at91_rtc_resume);\n\nstatic struct platform_driver at91_rtc_driver = {\n\t.remove\t\t= __exit_p(at91_rtc_remove),\n\t.shutdown\t= at91_rtc_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"at91_rtc\",\n\t\t.pm\t= &at91_rtc_pm_ops,\n\t\t.of_match_table = at91_rtc_dt_ids,\n\t},\n};\n\nmodule_platform_driver_probe(at91_rtc_driver, at91_rtc_probe);\n\nMODULE_AUTHOR(\"Rick Bronson\");\nMODULE_DESCRIPTION(\"RTC driver for Atmel AT91RM9200\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:at91_rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}