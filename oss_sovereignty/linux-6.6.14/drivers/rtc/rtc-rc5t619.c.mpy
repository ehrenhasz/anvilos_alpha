{
  "module_name": "rtc-rc5t619.c",
  "hash_id": "aa4f6e55cde05d2c71638025e2380020b50afeef562b160f42e0288e0a79ba57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rc5t619.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mfd/rn5t618.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n\nstruct rc5t619_rtc {\n\tint\t\t\tirq;\n\tstruct rtc_device\t*rtc;\n\tstruct rn5t618 *rn5t618;\n};\n\n#define CTRL1_ALARM_ENABLED 0x40\n#define CTRL1_24HR 0x20\n#define CTRL1_PERIODIC_MASK 0xf\n\n#define CTRL2_PON 0x10\n#define CTRL2_ALARM_STATUS 0x80\n#define CTRL2_CTFG 0x4\n#define CTRL2_CTC 0x1\n\n#define MONTH_CENTFLAG 0x80\n#define HOUR_PMFLAG 0x20\n#define MDAY_DAL_EXT 0x80\n\nstatic uint8_t rtc5t619_12hour_bcd2bin(uint8_t hour)\n{\n\tif (hour & HOUR_PMFLAG) {\n\t\thour = bcd2bin(hour & ~HOUR_PMFLAG);\n\t\treturn hour == 12 ? 12 : 12 + hour;\n\t}\n\n\thour = bcd2bin(hour);\n\treturn hour == 12 ? 0 : hour;\n}\n\nstatic uint8_t rtc5t619_12hour_bin2bcd(uint8_t hour)\n{\n\tif (!hour)\n\t\treturn 0x12;\n\n\tif (hour < 12)\n\t\treturn bin2bcd(hour);\n\n\tif (hour == 12)\n\t\treturn 0x12 | HOUR_PMFLAG;\n\n\treturn bin2bcd(hour - 12) | HOUR_PMFLAG;\n}\n\nstatic int rc5t619_rtc_periodic_disable(struct device *dev)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tint err;\n\n\t \n\terr = regmap_update_bits(rtc->rn5t618->regmap,\n\t\t\t\t RN5T618_RTC_CTRL1, CTRL1_PERIODIC_MASK, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2,\n\t\t\t\t CTRL2_ALARM_STATUS | CTRL2_CTFG | CTRL2_CTC,\n\t\t\t\t 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int rc5t619_rtc_pon_setup(struct device *dev)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tint err;\n\tunsigned int reg_data;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2, &reg_data);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treg_data &= ~(CTRL2_PON | CTRL2_CTC | 0x4a);\t \n\treg_data |= 0x20;\t \n\terr = regmap_write(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2, reg_data);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_write(rtc->rn5t618->regmap, RN5T618_RTC_ADJUST, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_update_bits(rtc->rn5t618->regmap,\n\t\t\t\t\tRN5T618_RTC_CTRL1,\n\t\t\t\t\tCTRL1_24HR, CTRL1_24HR);\n}\n\nstatic int rc5t619_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tu8 buff[7];\n\tint err;\n\tint cent_flag;\n\tunsigned int ctrl1;\n\tunsigned int ctrl2;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2, &ctrl2);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ctrl2 & CTRL2_PON)\n\t\treturn -EINVAL;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL1, &ctrl1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_bulk_read(rtc->rn5t618->regmap, RN5T618_RTC_SECONDS,\n\t\t\t       buff, sizeof(buff));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (buff[5] & MONTH_CENTFLAG)\n\t\tcent_flag = 1;\n\telse\n\t\tcent_flag = 0;\n\n\ttm->tm_sec  = bcd2bin(buff[0]);\n\ttm->tm_min  = bcd2bin(buff[1]);\n\n\tif (ctrl1 & CTRL1_24HR)\n\t\ttm->tm_hour = bcd2bin(buff[2]);\n\telse\n\t\ttm->tm_hour = rtc5t619_12hour_bcd2bin(buff[2]);\n\n\ttm->tm_wday = bcd2bin(buff[3]);\n\ttm->tm_mday = bcd2bin(buff[4]);\n\ttm->tm_mon  = bcd2bin(buff[5] & 0x1f) - 1;  \n\ttm->tm_year = bcd2bin(buff[6]) + 100 * cent_flag;\n\n\treturn 0;\n}\n\nstatic int rc5t619_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tu8 buff[7];\n\tint err;\n\tint cent_flag;\n\tunsigned int ctrl1;\n\tunsigned int ctrl2;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2, &ctrl2);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ctrl2 & CTRL2_PON)\n\t\trc5t619_rtc_pon_setup(dev);\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL1, &ctrl1);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tm->tm_year >= 100)\n\t\tcent_flag = 1;\n\telse\n\t\tcent_flag = 0;\n\n\tbuff[0] = bin2bcd(tm->tm_sec);\n\tbuff[1] = bin2bcd(tm->tm_min);\n\n\tif (ctrl1 & CTRL1_24HR)\n\t\tbuff[2] = bin2bcd(tm->tm_hour);\n\telse\n\t\tbuff[2] = rtc5t619_12hour_bin2bcd(tm->tm_hour);\n\n\tbuff[3] = bin2bcd(tm->tm_wday);\n\tbuff[4] = bin2bcd(tm->tm_mday);\n\tbuff[5] = bin2bcd(tm->tm_mon + 1);\t \n\tbuff[6] = bin2bcd(tm->tm_year - cent_flag * 100);\n\n\tif (cent_flag)\n\t\tbuff[5] |= MONTH_CENTFLAG;\n\n\terr = regmap_bulk_write(rtc->rn5t618->regmap, RN5T618_RTC_SECONDS,\n\t\t\t\tbuff, sizeof(buff));\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to program new time: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rc5t619_rtc_alarm_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(rtc->rn5t618->regmap,\n\t\t\tRN5T618_RTC_CTRL1,\n\t\t\tCTRL1_ALARM_ENABLED,\n\t\t\tenabled ? CTRL1_ALARM_ENABLED : 0);\n}\n\nstatic int rc5t619_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tu8 buff[6];\n\tunsigned int buff_cent;\n\tint err;\n\tint cent_flag;\n\tunsigned int ctrl1;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL1, &ctrl1);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_MONTH, &buff_cent);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to read time: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (buff_cent & MONTH_CENTFLAG)\n\t\tcent_flag = 1;\n\telse\n\t\tcent_flag = 0;\n\n\terr = regmap_bulk_read(rtc->rn5t618->regmap, RN5T618_RTC_ALARM_Y_SEC,\n\t\t\t       buff, sizeof(buff));\n\tif (err)\n\t\treturn err;\n\n\tbuff[3] = buff[3] & 0x3f;\n\n\talrm->time.tm_sec  = bcd2bin(buff[0]);\n\talrm->time.tm_min  = bcd2bin(buff[1]);\n\n\tif (ctrl1 & CTRL1_24HR)\n\t\talrm->time.tm_hour = bcd2bin(buff[2]);\n\telse\n\t\talrm->time.tm_hour = rtc5t619_12hour_bcd2bin(buff[2]);\n\n\talrm->time.tm_mday = bcd2bin(buff[3]);\n\talrm->time.tm_mon  = bcd2bin(buff[4]) - 1;\n\talrm->time.tm_year = bcd2bin(buff[5]) + 100 * cent_flag;\n\talrm->enabled = !!(ctrl1 & CTRL1_ALARM_ENABLED);\n\tdev_dbg(dev, \"read alarm: %ptR\\n\", &alrm->time);\n\n\treturn 0;\n}\n\nstatic int rc5t619_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\tu8 buff[6];\n\tint err;\n\tint cent_flag;\n\tunsigned int ctrl1;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL1, &ctrl1);\n\tif (err)\n\t\treturn err;\n\n\terr = rc5t619_rtc_alarm_enable(dev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rtc->irq == -1)\n\t\treturn -EINVAL;\n\n\tif (alrm->enabled == 0)\n\t\treturn 0;\n\n\tif (alrm->time.tm_year >= 100)\n\t\tcent_flag = 1;\n\telse\n\t\tcent_flag = 0;\n\n\talrm->time.tm_mon += 1;\n\tbuff[0] = bin2bcd(alrm->time.tm_sec);\n\tbuff[1] = bin2bcd(alrm->time.tm_min);\n\n\tif (ctrl1 & CTRL1_24HR)\n\t\tbuff[2] = bin2bcd(alrm->time.tm_hour);\n\telse\n\t\tbuff[2] = rtc5t619_12hour_bin2bcd(alrm->time.tm_hour);\n\n\tbuff[3] = bin2bcd(alrm->time.tm_mday);\n\tbuff[4] = bin2bcd(alrm->time.tm_mon);\n\tbuff[5] = bin2bcd(alrm->time.tm_year - 100 * cent_flag);\n\tbuff[3] |= MDAY_DAL_EXT;\n\n\terr = regmap_bulk_write(rtc->rn5t618->regmap, RN5T618_RTC_ALARM_Y_SEC,\n\t\t\t\tbuff, sizeof(buff));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn rc5t619_rtc_alarm_enable(dev, alrm->enabled);\n}\n\nstatic const struct rtc_class_ops rc5t619_rtc_ops = {\n\t.read_time\t= rc5t619_rtc_read_time,\n\t.set_time\t= rc5t619_rtc_set_time,\n\t.set_alarm\t= rc5t619_rtc_set_alarm,\n\t.read_alarm\t= rc5t619_rtc_read_alarm,\n\t.alarm_irq_enable = rc5t619_rtc_alarm_enable,\n};\n\nstatic int rc5t619_rtc_alarm_flag_clr(struct device *dev)\n{\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\n\t \n\treturn regmap_update_bits(rtc->rn5t618->regmap,\n\t\t\t\tRN5T618_RTC_CTRL2,\n\t\t\t\tCTRL2_ALARM_STATUS | CTRL2_CTC, 0);\n}\n\nstatic irqreturn_t rc5t619_rtc_irq(int irq, void *data)\n{\n\tstruct device *dev = data;\n\tstruct rc5t619_rtc *rtc = dev_get_drvdata(dev);\n\n\trc5t619_rtc_alarm_flag_clr(dev);\n\n\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int rc5t619_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rn5t618 *rn5t618 = dev_get_drvdata(pdev->dev.parent);\n\tstruct rc5t619_rtc *rtc;\n\tunsigned int ctrl2;\n\tint err;\n\n\trtc = devm_kzalloc(dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->rn5t618 = rn5t618;\n\n\tdev_set_drvdata(dev, rtc);\n\trtc->irq = -1;\n\n\tif (rn5t618->irq_data)\n\t\trtc->irq = regmap_irq_get_virq(rn5t618->irq_data,\n\t\t\t\t\t       RN5T618_IRQ_RTC);\n\n\tif (rtc->irq  < 0)\n\t\trtc->irq = -1;\n\n\terr = regmap_read(rtc->rn5t618->regmap, RN5T618_RTC_CTRL2, &ctrl2);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = rc5t619_rtc_periodic_disable(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tif (ctrl2 & CTRL2_PON) {\n\t\terr = rc5t619_rtc_alarm_flag_clr(&pdev->dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc)) {\n\t\terr = PTR_ERR(rtc->rtc);\n\t\tdev_err(dev, \"RTC device register: err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\trtc->rtc->ops = &rc5t619_rtc_ops;\n\trtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_1900;\n\trtc->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\t \n\tif (rtc->irq != -1) {\n\t\terr = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\n\t\t\t\t\t\trc5t619_rtc_irq,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"rtc-rc5t619\",\n\t\t\t\t\t\t&pdev->dev);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"request IRQ:%d fail\\n\", rtc->irq);\n\t\t\trtc->irq = -1;\n\n\t\t\terr = rc5t619_rtc_alarm_enable(&pdev->dev, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else {\n\t\t\t \n\t\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t\t\tenable_irq_wake(rtc->irq);\n\t\t}\n\t} else {\n\t\t \n\t\terr = rc5t619_rtc_alarm_enable(&pdev->dev, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_warn(&pdev->dev, \"rc5t619 interrupt is disabled\\n\");\n\t}\n\n\treturn devm_rtc_register_device(rtc->rtc);\n}\n\nstatic struct platform_driver rc5t619_rtc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rc5t619-rtc\",\n\t},\n\t.probe\t= rc5t619_rtc_probe,\n};\n\nmodule_platform_driver(rc5t619_rtc_driver);\nMODULE_ALIAS(\"platform:rc5t619-rtc\");\nMODULE_DESCRIPTION(\"RICOH RC5T619 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}