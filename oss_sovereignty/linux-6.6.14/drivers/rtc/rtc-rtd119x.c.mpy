{
  "module_name": "rtc-rtd119x.c",
  "hash_id": "802d97239d60910255c74732acad46da289ee0201e7e86d1bbd72e282c0b1bea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rtd119x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/spinlock.h>\n\n#define RTD_RTCSEC\t\t0x00\n#define RTD_RTCMIN\t\t0x04\n#define RTD_RTCHR\t\t0x08\n#define RTD_RTCDATE1\t\t0x0c\n#define RTD_RTCDATE2\t\t0x10\n#define RTD_RTCACR\t\t0x28\n#define RTD_RTCEN\t\t0x2c\n#define RTD_RTCCR\t\t0x30\n\n#define RTD_RTCSEC_RTCSEC_MASK\t\t0x7f\n\n#define RTD_RTCMIN_RTCMIN_MASK\t\t0x3f\n\n#define RTD_RTCHR_RTCHR_MASK\t\t0x1f\n\n#define RTD_RTCDATE1_RTCDATE1_MASK\t0xff\n\n#define RTD_RTCDATE2_RTCDATE2_MASK\t0x7f\n\n#define RTD_RTCACR_RTCPWR\t\tBIT(7)\n\n#define RTD_RTCEN_RTCEN_MASK\t\t0xff\n\n#define RTD_RTCCR_RTCRST\t\tBIT(6)\n\nstruct rtd119x_rtc {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct rtc_device *rtcdev;\n\tunsigned int base_year;\n};\n\nstatic inline int rtd119x_rtc_days_in_year(int year)\n{\n\treturn 365 + (is_leap_year(year) ? 1 : 0);\n}\n\nstatic void rtd119x_rtc_reset(struct device *dev)\n{\n\tstruct rtd119x_rtc *data = dev_get_drvdata(dev);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + RTD_RTCCR);\n\tval |= RTD_RTCCR_RTCRST;\n\twritel_relaxed(val, data->base + RTD_RTCCR);\n\n\tval &= ~RTD_RTCCR_RTCRST;\n\twritel(val, data->base + RTD_RTCCR);\n}\n\nstatic void rtd119x_rtc_set_enabled(struct device *dev, bool enable)\n{\n\tstruct rtd119x_rtc *data = dev_get_drvdata(dev);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + RTD_RTCEN);\n\tif (enable) {\n\t\tif ((val & RTD_RTCEN_RTCEN_MASK) == 0x5a)\n\t\t\treturn;\n\t\twritel_relaxed(0x5a, data->base + RTD_RTCEN);\n\t} else {\n\t\twritel_relaxed(0, data->base + RTD_RTCEN);\n\t}\n}\n\nstatic int rtd119x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtd119x_rtc *data = dev_get_drvdata(dev);\n\ts32 day;\n\tu32 sec;\n\tunsigned int year;\n\tint tries = 0;\n\n\twhile (true) {\n\t\ttm->tm_sec = (readl_relaxed(data->base + RTD_RTCSEC) & RTD_RTCSEC_RTCSEC_MASK) >> 1;\n\t\ttm->tm_min  = readl_relaxed(data->base + RTD_RTCMIN) & RTD_RTCMIN_RTCMIN_MASK;\n\t\ttm->tm_hour = readl_relaxed(data->base + RTD_RTCHR) & RTD_RTCHR_RTCHR_MASK;\n\t\tday  =  readl_relaxed(data->base + RTD_RTCDATE1) & RTD_RTCDATE1_RTCDATE1_MASK;\n\t\tday |= (readl_relaxed(data->base + RTD_RTCDATE2) & RTD_RTCDATE2_RTCDATE2_MASK) << 8;\n\t\tsec  = (readl_relaxed(data->base + RTD_RTCSEC) & RTD_RTCSEC_RTCSEC_MASK) >> 1;\n\t\ttries++;\n\n\t\tif (sec == tm->tm_sec)\n\t\t\tbreak;\n\n\t\tif (tries >= 3)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tries > 1)\n\t\tdev_dbg(dev, \"%s: needed %i tries\\n\", __func__, tries);\n\n\tyear = data->base_year;\n\twhile (day >= rtd119x_rtc_days_in_year(year)) {\n\t\tday -= rtd119x_rtc_days_in_year(year);\n\t\tyear++;\n\t}\n\ttm->tm_year = year - 1900;\n\ttm->tm_yday = day;\n\n\ttm->tm_mon = 0;\n\twhile (day >= rtc_month_days(tm->tm_mon, year)) {\n\t\tday -= rtc_month_days(tm->tm_mon, year);\n\t\ttm->tm_mon++;\n\t}\n\ttm->tm_mday = day + 1;\n\n\treturn 0;\n}\n\nstatic int rtd119x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtd119x_rtc *data = dev_get_drvdata(dev);\n\tunsigned int day;\n\tint i;\n\n\tif (1900 + tm->tm_year < data->base_year)\n\t\treturn -EINVAL;\n\n\tday = 0;\n\tfor (i = data->base_year; i < 1900 + tm->tm_year; i++)\n\t\tday += rtd119x_rtc_days_in_year(i);\n\n\tday += tm->tm_yday;\n\tif (day > 0x7fff)\n\t\treturn -EINVAL;\n\n\trtd119x_rtc_set_enabled(dev, false);\n\n\twritel_relaxed((tm->tm_sec << 1) & RTD_RTCSEC_RTCSEC_MASK, data->base + RTD_RTCSEC);\n\twritel_relaxed(tm->tm_min & RTD_RTCMIN_RTCMIN_MASK, data->base + RTD_RTCMIN);\n\twritel_relaxed(tm->tm_hour & RTD_RTCHR_RTCHR_MASK, data->base + RTD_RTCHR);\n\twritel_relaxed(day & RTD_RTCDATE1_RTCDATE1_MASK, data->base + RTD_RTCDATE1);\n\twritel_relaxed((day >> 8) & RTD_RTCDATE2_RTCDATE2_MASK, data->base + RTD_RTCDATE2);\n\n\trtd119x_rtc_set_enabled(dev, true);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops rtd119x_rtc_ops = {\n\t.read_time\t= rtd119x_rtc_read_time,\n\t.set_time\t= rtd119x_rtc_set_time,\n};\n\nstatic const struct of_device_id rtd119x_rtc_dt_ids[] = {\n\t { .compatible = \"realtek,rtd1295-rtc\" },\n\t { }\n};\n\nstatic int rtd119x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtd119x_rtc *data;\n\tu32 val;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\tdata->base_year = 2014;\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\tdata->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tret = clk_prepare_enable(data->clk);\n\tif (ret) {\n\t\tclk_put(data->clk);\n\t\treturn ret;\n\t}\n\n\tval = readl_relaxed(data->base + RTD_RTCACR);\n\tif (!(val & RTD_RTCACR_RTCPWR)) {\n\t\twritel_relaxed(RTD_RTCACR_RTCPWR, data->base + RTD_RTCACR);\n\n\t\trtd119x_rtc_reset(&pdev->dev);\n\n\t\twritel_relaxed(0, data->base + RTD_RTCMIN);\n\t\twritel_relaxed(0, data->base + RTD_RTCHR);\n\t\twritel_relaxed(0, data->base + RTD_RTCDATE1);\n\t\twritel_relaxed(0, data->base + RTD_RTCDATE2);\n\t}\n\n\trtd119x_rtc_set_enabled(&pdev->dev, true);\n\n\tdata->rtcdev = devm_rtc_device_register(&pdev->dev, \"rtc\",\n\t\t\t\t\t\t&rtd119x_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(data->rtcdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register rtc device\");\n\t\tclk_disable_unprepare(data->clk);\n\t\tclk_put(data->clk);\n\t\treturn PTR_ERR(data->rtcdev);\n\t}\n\n\treturn 0;\n}\n\nstatic void rtd119x_rtc_remove(struct platform_device *pdev)\n{\n\tstruct rtd119x_rtc *data = platform_get_drvdata(pdev);\n\n\trtd119x_rtc_set_enabled(&pdev->dev, false);\n\n\tclk_disable_unprepare(data->clk);\n\tclk_put(data->clk);\n}\n\nstatic struct platform_driver rtd119x_rtc_driver = {\n\t.probe = rtd119x_rtc_probe,\n\t.remove_new = rtd119x_rtc_remove,\n\t.driver = {\n\t\t.name = \"rtd1295-rtc\",\n\t\t.of_match_table\t= rtd119x_rtc_dt_ids,\n\t},\n};\nbuiltin_platform_driver(rtd119x_rtc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}