{
  "module_name": "rtc-mt6397.c",
  "hash_id": "e7ff9b3628d2aa283ac33b29831d07394a069d31974b447c6e5d144c215e29db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mt6397.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/mt6397/core.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/mfd/mt6397/rtc.h>\n#include <linux/mod_devicetable.h>\n\nstatic int mtk_rtc_write_trigger(struct mt6397_rtc *rtc)\n{\n\tint ret;\n\tu32 data;\n\n\tret = regmap_write(rtc->regmap, rtc->addr_base + rtc->data->wrtgr, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(rtc->regmap,\n\t\t\t\t\trtc->addr_base + RTC_BBPU, data,\n\t\t\t\t\t!(data & RTC_BBPU_CBUSY),\n\t\t\t\t\tMTK_RTC_POLL_DELAY_US,\n\t\t\t\t\tMTK_RTC_POLL_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(rtc->rtc_dev->dev.parent,\n\t\t\t\"failed to write WRTGR: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic irqreturn_t mtk_rtc_irq_handler_thread(int irq, void *data)\n{\n\tstruct mt6397_rtc *rtc = data;\n\tu32 irqsta, irqen;\n\tint ret;\n\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_IRQ_STA, &irqsta);\n\tif ((ret >= 0) && (irqsta & RTC_IRQ_STA_AL)) {\n\t\trtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\t\tirqen = irqsta & ~RTC_IRQ_EN_AL;\n\t\tmutex_lock(&rtc->lock);\n\t\tif (regmap_write(rtc->regmap, rtc->addr_base + RTC_IRQ_EN,\n\t\t\t\t irqen) == 0)\n\t\t\tmtk_rtc_write_trigger(rtc);\n\t\tmutex_unlock(&rtc->lock);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int __mtk_rtc_read_time(struct mt6397_rtc *rtc,\n\t\t\t       struct rtc_time *tm, int *sec)\n{\n\tint ret;\n\tu16 data[RTC_OFFSET_COUNT];\n\n\tmutex_lock(&rtc->lock);\n\tret = regmap_bulk_read(rtc->regmap, rtc->addr_base + RTC_TC_SEC,\n\t\t\t       data, RTC_OFFSET_COUNT);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\ttm->tm_sec = data[RTC_OFFSET_SEC];\n\ttm->tm_min = data[RTC_OFFSET_MIN];\n\ttm->tm_hour = data[RTC_OFFSET_HOUR];\n\ttm->tm_mday = data[RTC_OFFSET_DOM];\n\ttm->tm_mon = data[RTC_OFFSET_MTH] & RTC_TC_MTH_MASK;\n\ttm->tm_year = data[RTC_OFFSET_YEAR];\n\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_TC_SEC, sec);\nexit:\n\tmutex_unlock(&rtc->lock);\n\treturn ret;\n}\n\nstatic int mtk_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\ttime64_t time;\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\tint days, sec, ret;\n\n\tdo {\n\t\tret = __mtk_rtc_read_time(rtc, tm, &sec);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t} while (sec < tm->tm_sec);\n\n\t \n\ttm->tm_year += RTC_MIN_YEAR_OFFSET;\n\n\t \n\ttm->tm_mon--;\n\ttime = rtc_tm_to_time64(tm);\n\n\t \n\tdays = div_s64(time, 86400);\n\ttm->tm_wday = (days + 4) % 7;\n\nexit:\n\treturn ret;\n}\n\nstatic int mtk_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu16 data[RTC_OFFSET_COUNT];\n\n\ttm->tm_year -= RTC_MIN_YEAR_OFFSET;\n\ttm->tm_mon++;\n\n\tdata[RTC_OFFSET_SEC] = tm->tm_sec;\n\tdata[RTC_OFFSET_MIN] = tm->tm_min;\n\tdata[RTC_OFFSET_HOUR] = tm->tm_hour;\n\tdata[RTC_OFFSET_DOM] = tm->tm_mday;\n\tdata[RTC_OFFSET_MTH] = tm->tm_mon;\n\tdata[RTC_OFFSET_YEAR] = tm->tm_year;\n\n\tmutex_lock(&rtc->lock);\n\tret = regmap_bulk_write(rtc->regmap, rtc->addr_base + RTC_TC_SEC,\n\t\t\t\tdata, RTC_OFFSET_COUNT);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tret = mtk_rtc_write_trigger(rtc);\n\nexit:\n\tmutex_unlock(&rtc->lock);\n\treturn ret;\n}\n\nstatic int mtk_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rtc_time *tm = &alm->time;\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\tu32 irqen, pdn2;\n\tint ret;\n\tu16 data[RTC_OFFSET_COUNT];\n\n\tmutex_lock(&rtc->lock);\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_IRQ_EN, &irqen);\n\tif (ret < 0)\n\t\tgoto err_exit;\n\tret = regmap_read(rtc->regmap, rtc->addr_base + RTC_PDN2, &pdn2);\n\tif (ret < 0)\n\t\tgoto err_exit;\n\n\tret = regmap_bulk_read(rtc->regmap, rtc->addr_base + RTC_AL_SEC,\n\t\t\t       data, RTC_OFFSET_COUNT);\n\tif (ret < 0)\n\t\tgoto err_exit;\n\n\talm->enabled = !!(irqen & RTC_IRQ_EN_AL);\n\talm->pending = !!(pdn2 & RTC_PDN2_PWRON_ALARM);\n\tmutex_unlock(&rtc->lock);\n\n\ttm->tm_sec = data[RTC_OFFSET_SEC] & RTC_AL_SEC_MASK;\n\ttm->tm_min = data[RTC_OFFSET_MIN] & RTC_AL_MIN_MASK;\n\ttm->tm_hour = data[RTC_OFFSET_HOUR] & RTC_AL_HOU_MASK;\n\ttm->tm_mday = data[RTC_OFFSET_DOM] & RTC_AL_DOM_MASK;\n\ttm->tm_mon = data[RTC_OFFSET_MTH] & RTC_AL_MTH_MASK;\n\ttm->tm_year = data[RTC_OFFSET_YEAR] & RTC_AL_YEA_MASK;\n\n\ttm->tm_year += RTC_MIN_YEAR_OFFSET;\n\ttm->tm_mon--;\n\n\treturn 0;\nerr_exit:\n\tmutex_unlock(&rtc->lock);\n\treturn ret;\n}\n\nstatic int mtk_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rtc_time *tm = &alm->time;\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu16 data[RTC_OFFSET_COUNT];\n\n\ttm->tm_year -= RTC_MIN_YEAR_OFFSET;\n\ttm->tm_mon++;\n\n\tmutex_lock(&rtc->lock);\n\tret = regmap_bulk_read(rtc->regmap, rtc->addr_base + RTC_AL_SEC,\n\t\t\t       data, RTC_OFFSET_COUNT);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tdata[RTC_OFFSET_SEC] = ((data[RTC_OFFSET_SEC] & ~(RTC_AL_SEC_MASK)) |\n\t\t\t\t(tm->tm_sec & RTC_AL_SEC_MASK));\n\tdata[RTC_OFFSET_MIN] = ((data[RTC_OFFSET_MIN] & ~(RTC_AL_MIN_MASK)) |\n\t\t\t\t(tm->tm_min & RTC_AL_MIN_MASK));\n\tdata[RTC_OFFSET_HOUR] = ((data[RTC_OFFSET_HOUR] & ~(RTC_AL_HOU_MASK)) |\n\t\t\t\t(tm->tm_hour & RTC_AL_HOU_MASK));\n\tdata[RTC_OFFSET_DOM] = ((data[RTC_OFFSET_DOM] & ~(RTC_AL_DOM_MASK)) |\n\t\t\t\t(tm->tm_mday & RTC_AL_DOM_MASK));\n\tdata[RTC_OFFSET_MTH] = ((data[RTC_OFFSET_MTH] & ~(RTC_AL_MTH_MASK)) |\n\t\t\t\t(tm->tm_mon & RTC_AL_MTH_MASK));\n\tdata[RTC_OFFSET_YEAR] = ((data[RTC_OFFSET_YEAR] & ~(RTC_AL_YEA_MASK)) |\n\t\t\t\t(tm->tm_year & RTC_AL_YEA_MASK));\n\n\tif (alm->enabled) {\n\t\tret = regmap_bulk_write(rtc->regmap,\n\t\t\t\t\trtc->addr_base + RTC_AL_SEC,\n\t\t\t\t\tdata, RTC_OFFSET_COUNT);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tret = regmap_write(rtc->regmap, rtc->addr_base + RTC_AL_MASK,\n\t\t\t\t   RTC_AL_MASK_DOW);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->addr_base + RTC_IRQ_EN,\n\t\t\t\t\t RTC_IRQ_EN_ONESHOT_AL,\n\t\t\t\t\t RTC_IRQ_EN_ONESHOT_AL);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t} else {\n\t\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t\t rtc->addr_base + RTC_IRQ_EN,\n\t\t\t\t\t RTC_IRQ_EN_ONESHOT_AL, 0);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tret = mtk_rtc_write_trigger(rtc);\nexit:\n\tmutex_unlock(&rtc->lock);\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops mtk_rtc_ops = {\n\t.read_time  = mtk_rtc_read_time,\n\t.set_time   = mtk_rtc_set_time,\n\t.read_alarm = mtk_rtc_read_alarm,\n\t.set_alarm  = mtk_rtc_set_alarm,\n};\n\nstatic int mtk_rtc_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct mt6397_chip *mt6397_chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct mt6397_rtc *rtc;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(struct mt6397_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\trtc->addr_base = res->start;\n\n\trtc->data = of_device_get_match_data(&pdev->dev);\n\n\trtc->irq = platform_get_irq(pdev, 0);\n\tif (rtc->irq < 0)\n\t\treturn rtc->irq;\n\n\trtc->regmap = mt6397_chip->regmap;\n\tmutex_init(&rtc->lock);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\n\t\t\t\t\tmtk_rtc_irq_handler_thread,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t\t\t\"mt6397-rtc\", rtc);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ: %d: %d\\n\",\n\t\t\trtc->irq, ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\trtc->rtc_dev->ops = &mtk_rtc_ops;\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mt6397_rtc_suspend(struct device *dev)\n{\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(rtc->irq);\n\n\treturn 0;\n}\n\nstatic int mt6397_rtc_resume(struct device *dev)\n{\n\tstruct mt6397_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(rtc->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mt6397_pm_ops, mt6397_rtc_suspend,\n\t\t\tmt6397_rtc_resume);\n\nstatic const struct mtk_rtc_data mt6358_rtc_data = {\n\t.wrtgr = RTC_WRTGR_MT6358,\n};\n\nstatic const struct mtk_rtc_data mt6397_rtc_data = {\n\t.wrtgr = RTC_WRTGR_MT6397,\n};\n\nstatic const struct of_device_id mt6397_rtc_of_match[] = {\n\t{ .compatible = \"mediatek,mt6323-rtc\", .data = &mt6397_rtc_data },\n\t{ .compatible = \"mediatek,mt6358-rtc\", .data = &mt6358_rtc_data },\n\t{ .compatible = \"mediatek,mt6397-rtc\", .data = &mt6397_rtc_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mt6397_rtc_of_match);\n\nstatic struct platform_driver mtk_rtc_driver = {\n\t.driver = {\n\t\t.name = \"mt6397-rtc\",\n\t\t.of_match_table = mt6397_rtc_of_match,\n\t\t.pm = &mt6397_pm_ops,\n\t},\n\t.probe\t= mtk_rtc_probe,\n};\n\nmodule_platform_driver(mtk_rtc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tianping Fang <tianping.fang@mediatek.com>\");\nMODULE_DESCRIPTION(\"RTC Driver for MediaTek MT6397 PMIC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}