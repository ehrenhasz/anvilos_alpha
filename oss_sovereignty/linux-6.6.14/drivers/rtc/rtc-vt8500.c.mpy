{
  "module_name": "rtc-vt8500.c",
  "hash_id": "c30c87c88fe214fdc3717e7838ec692ffdacf1efac9335a43e00c8eaea584143",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-vt8500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/bcd.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n \n#define VT8500_RTC_TS\t\t0x00\t \n#define VT8500_RTC_DS\t\t0x04\t \n#define VT8500_RTC_AS\t\t0x08\t \n#define VT8500_RTC_CR\t\t0x0c\t \n#define VT8500_RTC_TR\t\t0x10\t \n#define VT8500_RTC_DR\t\t0x14\t \n#define VT8500_RTC_WS\t\t0x18\t \n#define VT8500_RTC_CL\t\t0x20\t \n#define VT8500_RTC_IS\t\t0x24\t \n#define VT8500_RTC_ST\t\t0x28\t \n\n#define INVALID_TIME_BIT\t(1 << 31)\n\n#define DATE_CENTURY_S\t\t19\n#define DATE_YEAR_S\t\t11\n#define DATE_YEAR_MASK\t\t(0xff << DATE_YEAR_S)\n#define DATE_MONTH_S\t\t6\n#define DATE_MONTH_MASK\t\t(0x1f << DATE_MONTH_S)\n#define DATE_DAY_MASK\t\t0x3f\n\n#define TIME_DOW_S\t\t20\n#define TIME_DOW_MASK\t\t(0x07 << TIME_DOW_S)\n#define TIME_HOUR_S\t\t14\n#define TIME_HOUR_MASK\t\t(0x3f << TIME_HOUR_S)\n#define TIME_MIN_S\t\t7\n#define TIME_MIN_MASK\t\t(0x7f << TIME_MIN_S)\n#define TIME_SEC_MASK\t\t0x7f\n\n#define ALARM_DAY_S\t\t20\n#define ALARM_DAY_MASK\t\t(0x3f << ALARM_DAY_S)\n\n#define ALARM_DAY_BIT\t\t(1 << 29)\n#define ALARM_HOUR_BIT\t\t(1 << 28)\n#define ALARM_MIN_BIT\t\t(1 << 27)\n#define ALARM_SEC_BIT\t\t(1 << 26)\n\n#define ALARM_ENABLE_MASK\t(ALARM_DAY_BIT \\\n\t\t\t\t| ALARM_HOUR_BIT \\\n\t\t\t\t| ALARM_MIN_BIT \\\n\t\t\t\t| ALARM_SEC_BIT)\n\n#define VT8500_RTC_CR_ENABLE\t(1 << 0)\t \n#define VT8500_RTC_CR_12H\t(1 << 1)\t \n#define VT8500_RTC_CR_SM_ENABLE\t(1 << 2)\t \n#define VT8500_RTC_CR_SM_SEC\t(1 << 3)\t \n#define VT8500_RTC_CR_CALIB\t(1 << 4)\t \n\n#define VT8500_RTC_IS_ALARM\t(1 << 0)\t \n\nstruct vt8500_rtc {\n\tvoid __iomem\t\t*regbase;\n\tint\t\t\tirq_alarm;\n\tstruct rtc_device\t*rtc;\n\tspinlock_t\t\tlock;\t\t \n};\n\nstatic irqreturn_t vt8500_rtc_irq(int irq, void *dev_id)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_id;\n\tu32 isr;\n\tunsigned long events = 0;\n\n\tspin_lock(&vt8500_rtc->lock);\n\n\t \n\tisr = readl(vt8500_rtc->regbase + VT8500_RTC_IS);\n\twritel(isr, vt8500_rtc->regbase + VT8500_RTC_IS);\n\n\tspin_unlock(&vt8500_rtc->lock);\n\n\tif (isr & VT8500_RTC_IS_ALARM)\n\t\tevents |= RTC_AF | RTC_IRQF;\n\n\trtc_update_irq(vt8500_rtc->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vt8500_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_get_drvdata(dev);\n\tu32 date, time;\n\n\tdate = readl(vt8500_rtc->regbase + VT8500_RTC_DR);\n\ttime = readl(vt8500_rtc->regbase + VT8500_RTC_TR);\n\n\ttm->tm_sec = bcd2bin(time & TIME_SEC_MASK);\n\ttm->tm_min = bcd2bin((time & TIME_MIN_MASK) >> TIME_MIN_S);\n\ttm->tm_hour = bcd2bin((time & TIME_HOUR_MASK) >> TIME_HOUR_S);\n\ttm->tm_mday = bcd2bin(date & DATE_DAY_MASK);\n\ttm->tm_mon = bcd2bin((date & DATE_MONTH_MASK) >> DATE_MONTH_S) - 1;\n\ttm->tm_year = bcd2bin((date & DATE_YEAR_MASK) >> DATE_YEAR_S)\n\t\t\t+ ((date >> DATE_CENTURY_S) & 1 ? 200 : 100);\n\ttm->tm_wday = (time & TIME_DOW_MASK) >> TIME_DOW_S;\n\n\treturn 0;\n}\n\nstatic int vt8500_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_get_drvdata(dev);\n\n\twritel((bin2bcd(tm->tm_year % 100) << DATE_YEAR_S)\n\t\t| (bin2bcd(tm->tm_mon + 1) << DATE_MONTH_S)\n\t\t| (bin2bcd(tm->tm_mday))\n\t\t| ((tm->tm_year >= 200) << DATE_CENTURY_S),\n\t\tvt8500_rtc->regbase + VT8500_RTC_DS);\n\twritel((bin2bcd(tm->tm_wday) << TIME_DOW_S)\n\t\t| (bin2bcd(tm->tm_hour) << TIME_HOUR_S)\n\t\t| (bin2bcd(tm->tm_min) << TIME_MIN_S)\n\t\t| (bin2bcd(tm->tm_sec)),\n\t\tvt8500_rtc->regbase + VT8500_RTC_TS);\n\n\treturn 0;\n}\n\nstatic int vt8500_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_get_drvdata(dev);\n\tu32 isr, alarm;\n\n\talarm = readl(vt8500_rtc->regbase + VT8500_RTC_AS);\n\tisr = readl(vt8500_rtc->regbase + VT8500_RTC_IS);\n\n\talrm->time.tm_mday = bcd2bin((alarm & ALARM_DAY_MASK) >> ALARM_DAY_S);\n\talrm->time.tm_hour = bcd2bin((alarm & TIME_HOUR_MASK) >> TIME_HOUR_S);\n\talrm->time.tm_min = bcd2bin((alarm & TIME_MIN_MASK) >> TIME_MIN_S);\n\talrm->time.tm_sec = bcd2bin((alarm & TIME_SEC_MASK));\n\n\talrm->enabled = (alarm & ALARM_ENABLE_MASK) ? 1 : 0;\n\talrm->pending = (isr & VT8500_RTC_IS_ALARM) ? 1 : 0;\n\n\treturn rtc_valid_tm(&alrm->time);\n}\n\nstatic int vt8500_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_get_drvdata(dev);\n\n\twritel((alrm->enabled ? ALARM_ENABLE_MASK : 0)\n\t\t| (bin2bcd(alrm->time.tm_mday) << ALARM_DAY_S)\n\t\t| (bin2bcd(alrm->time.tm_hour) << TIME_HOUR_S)\n\t\t| (bin2bcd(alrm->time.tm_min) << TIME_MIN_S)\n\t\t| (bin2bcd(alrm->time.tm_sec)),\n\t\tvt8500_rtc->regbase + VT8500_RTC_AS);\n\n\treturn 0;\n}\n\nstatic int vt8500_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct vt8500_rtc *vt8500_rtc = dev_get_drvdata(dev);\n\tunsigned long tmp = readl(vt8500_rtc->regbase + VT8500_RTC_AS);\n\n\tif (enabled)\n\t\ttmp |= ALARM_ENABLE_MASK;\n\telse\n\t\ttmp &= ~ALARM_ENABLE_MASK;\n\n\twritel(tmp, vt8500_rtc->regbase + VT8500_RTC_AS);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops vt8500_rtc_ops = {\n\t.read_time = vt8500_rtc_read_time,\n\t.set_time = vt8500_rtc_set_time,\n\t.read_alarm = vt8500_rtc_read_alarm,\n\t.set_alarm = vt8500_rtc_set_alarm,\n\t.alarm_irq_enable = vt8500_alarm_irq_enable,\n};\n\nstatic int vt8500_rtc_probe(struct platform_device *pdev)\n{\n\tstruct vt8500_rtc *vt8500_rtc;\n\tint ret;\n\n\tvt8500_rtc = devm_kzalloc(&pdev->dev,\n\t\t\t   sizeof(struct vt8500_rtc), GFP_KERNEL);\n\tif (!vt8500_rtc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&vt8500_rtc->lock);\n\tplatform_set_drvdata(pdev, vt8500_rtc);\n\n\tvt8500_rtc->irq_alarm = platform_get_irq(pdev, 0);\n\tif (vt8500_rtc->irq_alarm < 0)\n\t\treturn vt8500_rtc->irq_alarm;\n\n\tvt8500_rtc->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vt8500_rtc->regbase))\n\t\treturn PTR_ERR(vt8500_rtc->regbase);\n\n\t \n\twritel(VT8500_RTC_CR_ENABLE,\n\t       vt8500_rtc->regbase + VT8500_RTC_CR);\n\n\tvt8500_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(vt8500_rtc->rtc))\n\t\treturn PTR_ERR(vt8500_rtc->rtc);\n\n\tvt8500_rtc->rtc->ops = &vt8500_rtc_ops;\n\tvt8500_rtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tvt8500_rtc->rtc->range_max = RTC_TIMESTAMP_END_2199;\n\n\tret = devm_request_irq(&pdev->dev, vt8500_rtc->irq_alarm,\n\t\t\t\tvt8500_rtc_irq, 0, \"rtc alarm\", vt8500_rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can't get irq %i, err %d\\n\",\n\t\t\tvt8500_rtc->irq_alarm, ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_rtc_register_device(vt8500_rtc->rtc);\n}\n\nstatic void vt8500_rtc_remove(struct platform_device *pdev)\n{\n\tstruct vt8500_rtc *vt8500_rtc = platform_get_drvdata(pdev);\n\n\t \n\twritel(0, vt8500_rtc->regbase + VT8500_RTC_IS);\n}\n\nstatic const struct of_device_id wmt_dt_ids[] = {\n\t{ .compatible = \"via,vt8500-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wmt_dt_ids);\n\nstatic struct platform_driver vt8500_rtc_driver = {\n\t.probe\t\t= vt8500_rtc_probe,\n\t.remove_new\t= vt8500_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vt8500-rtc\",\n\t\t.of_match_table = wmt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(vt8500_rtc_driver);\n\nMODULE_AUTHOR(\"Alexey Charkov <alchark@gmail.com>\");\nMODULE_DESCRIPTION(\"VIA VT8500 SoC Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:vt8500-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}