{
  "module_name": "rtc-goldfish.c",
  "hash_id": "13a9508095186bb90dee8a6cf6f7601f0b21c79e758427b60fe077b525266cc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-goldfish.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/goldfish.h>\n#include <clocksource/timer-goldfish.h>\n\nstruct goldfish_rtc {\n\tvoid __iomem *base;\n\tint irq;\n\tstruct rtc_device *rtc;\n};\n\nstatic int goldfish_rtc_read_alarm(struct device *dev,\n\t\t\t\t   struct rtc_wkalrm *alrm)\n{\n\tu64 rtc_alarm;\n\tu64 rtc_alarm_low;\n\tu64 rtc_alarm_high;\n\tvoid __iomem *base;\n\tstruct goldfish_rtc *rtcdrv;\n\n\trtcdrv = dev_get_drvdata(dev);\n\tbase = rtcdrv->base;\n\n\trtc_alarm_low = gf_ioread32(base + TIMER_ALARM_LOW);\n\trtc_alarm_high = gf_ioread32(base + TIMER_ALARM_HIGH);\n\trtc_alarm = (rtc_alarm_high << 32) | rtc_alarm_low;\n\n\tdo_div(rtc_alarm, NSEC_PER_SEC);\n\tmemset(alrm, 0, sizeof(struct rtc_wkalrm));\n\n\trtc_time64_to_tm(rtc_alarm, &alrm->time);\n\n\tif (gf_ioread32(base + TIMER_ALARM_STATUS))\n\t\talrm->enabled = 1;\n\telse\n\t\talrm->enabled = 0;\n\n\treturn 0;\n}\n\nstatic int goldfish_rtc_set_alarm(struct device *dev,\n\t\t\t\t  struct rtc_wkalrm *alrm)\n{\n\tstruct goldfish_rtc *rtcdrv;\n\tu64 rtc_alarm64;\n\tu64 rtc_status_reg;\n\tvoid __iomem *base;\n\n\trtcdrv = dev_get_drvdata(dev);\n\tbase = rtcdrv->base;\n\n\tif (alrm->enabled) {\n\t\trtc_alarm64 = rtc_tm_to_time64(&alrm->time) * NSEC_PER_SEC;\n\t\tgf_iowrite32((rtc_alarm64 >> 32), base + TIMER_ALARM_HIGH);\n\t\tgf_iowrite32(rtc_alarm64, base + TIMER_ALARM_LOW);\n\t\tgf_iowrite32(1, base + TIMER_IRQ_ENABLED);\n\t} else {\n\t\t \n\t\trtc_status_reg = gf_ioread32(base + TIMER_ALARM_STATUS);\n\t\tif (rtc_status_reg)\n\t\t\tgf_iowrite32(1, base + TIMER_CLEAR_ALARM);\n\t}\n\n\treturn 0;\n}\n\nstatic int goldfish_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enabled)\n{\n\tvoid __iomem *base;\n\tstruct goldfish_rtc *rtcdrv;\n\n\trtcdrv = dev_get_drvdata(dev);\n\tbase = rtcdrv->base;\n\n\tif (enabled)\n\t\tgf_iowrite32(1, base + TIMER_IRQ_ENABLED);\n\telse\n\t\tgf_iowrite32(0, base + TIMER_IRQ_ENABLED);\n\n\treturn 0;\n}\n\nstatic irqreturn_t goldfish_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct goldfish_rtc *rtcdrv = dev_id;\n\tvoid __iomem *base = rtcdrv->base;\n\n\tgf_iowrite32(1, base + TIMER_CLEAR_INTERRUPT);\n\n\trtc_update_irq(rtcdrv->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int goldfish_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct goldfish_rtc *rtcdrv;\n\tvoid __iomem *base;\n\tu64 time_high;\n\tu64 time_low;\n\tu64 time;\n\n\trtcdrv = dev_get_drvdata(dev);\n\tbase = rtcdrv->base;\n\n\ttime_low = gf_ioread32(base + TIMER_TIME_LOW);\n\ttime_high = gf_ioread32(base + TIMER_TIME_HIGH);\n\ttime = (time_high << 32) | time_low;\n\n\tdo_div(time, NSEC_PER_SEC);\n\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\nstatic int goldfish_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct goldfish_rtc *rtcdrv;\n\tvoid __iomem *base;\n\tu64 now64;\n\n\trtcdrv = dev_get_drvdata(dev);\n\tbase = rtcdrv->base;\n\n\tnow64 = rtc_tm_to_time64(tm) * NSEC_PER_SEC;\n\tgf_iowrite32((now64 >> 32), base + TIMER_TIME_HIGH);\n\tgf_iowrite32(now64, base + TIMER_TIME_LOW);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops goldfish_rtc_ops = {\n\t.read_time\t= goldfish_rtc_read_time,\n\t.set_time\t= goldfish_rtc_set_time,\n\t.read_alarm\t= goldfish_rtc_read_alarm,\n\t.set_alarm\t= goldfish_rtc_set_alarm,\n\t.alarm_irq_enable = goldfish_rtc_alarm_irq_enable\n};\n\nstatic int goldfish_rtc_probe(struct platform_device *pdev)\n{\n\tstruct goldfish_rtc *rtcdrv;\n\tint err;\n\n\trtcdrv = devm_kzalloc(&pdev->dev, sizeof(*rtcdrv), GFP_KERNEL);\n\tif (!rtcdrv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rtcdrv);\n\trtcdrv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtcdrv->base))\n\t\treturn PTR_ERR(rtcdrv->base);\n\n\trtcdrv->irq = platform_get_irq(pdev, 0);\n\tif (rtcdrv->irq < 0)\n\t\treturn -ENODEV;\n\n\trtcdrv->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtcdrv->rtc))\n\t\treturn PTR_ERR(rtcdrv->rtc);\n\n\trtcdrv->rtc->ops = &goldfish_rtc_ops;\n\trtcdrv->rtc->range_max = U64_MAX / NSEC_PER_SEC;\n\n\terr = devm_request_irq(&pdev->dev, rtcdrv->irq,\n\t\t\t       goldfish_rtc_interrupt,\n\t\t\t       0, pdev->name, rtcdrv);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_rtc_register_device(rtcdrv->rtc);\n}\n\nstatic const struct of_device_id goldfish_rtc_of_match[] = {\n\t{ .compatible = \"google,goldfish-rtc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, goldfish_rtc_of_match);\n\nstatic struct platform_driver goldfish_rtc = {\n\t.probe = goldfish_rtc_probe,\n\t.driver = {\n\t\t.name = \"goldfish_rtc\",\n\t\t.of_match_table = goldfish_rtc_of_match,\n\t}\n};\n\nmodule_platform_driver(goldfish_rtc);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}