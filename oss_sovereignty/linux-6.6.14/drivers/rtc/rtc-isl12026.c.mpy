{
  "module_name": "rtc-isl12026.c",
  "hash_id": "17cc0d83db01ac54be38fde33268b368bcf29fa0bb47cbb307892e4bd276a7f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-isl12026.c",
  "human_readable_source": "\n \n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n \n#define ISL12026_REG_PWR\t0x14\n# define ISL12026_REG_PWR_BSW\tBIT(6)\n# define ISL12026_REG_PWR_SBIB\tBIT(7)\n#define ISL12026_REG_SC\t\t0x30\n#define ISL12026_REG_HR\t\t0x32\n# define ISL12026_REG_HR_MIL\tBIT(7)\t \n#define ISL12026_REG_SR\t\t0x3f\n# define ISL12026_REG_SR_RTCF\tBIT(0)\n# define ISL12026_REG_SR_WEL\tBIT(1)\n# define ISL12026_REG_SR_RWEL\tBIT(2)\n# define ISL12026_REG_SR_MBZ\tBIT(3)\n# define ISL12026_REG_SR_OSCF\tBIT(4)\n\n \n#define ISL12026_EEPROM_ADDR\t0x57\n\n#define ISL12026_PAGESIZE 16\n#define ISL12026_NVMEM_WRITE_TIME 20\n\nstruct isl12026 {\n\tstruct rtc_device *rtc;\n\tstruct i2c_client *nvm_client;\n};\n\nstatic int isl12026_read_reg(struct i2c_client *client, int reg)\n{\n\tu8 addr[] = {0, reg};\n\tu8 val;\n\tint ret;\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= sizeof(addr),\n\t\t\t.buf\t= addr\n\t\t}, {\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &val\n\t\t}\n\t};\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, \"read reg error, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t} else {\n\t\tret = val;\n\t}\n\n\treturn ret;\n}\n\nstatic int isl12026_arm_write(struct i2c_client *client)\n{\n\tint ret;\n\tu8 op[3];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= 1,\n\t\t.buf\t= op\n\t};\n\n\t \n\top[0] = 0;\n\top[1] = ISL12026_REG_SR;\n\top[2] = ISL12026_REG_SR_WEL;\n\tmsg.len = 3;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev, \"write error SR.WEL, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\top[2] = ISL12026_REG_SR_WEL | ISL12026_REG_SR_RWEL;\n\tmsg.len = 3;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev,\n\t\t\t\"write error SR.WEL|SR.RWEL, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int isl12026_disarm_write(struct i2c_client *client)\n{\n\tint ret;\n\tu8 op[3] = {0, ISL12026_REG_SR, 0};\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= sizeof(op),\n\t\t.buf\t= op\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev,\n\t\t\t\"write error SR, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int isl12026_write_reg(struct i2c_client *client, int reg, u8 val)\n{\n\tint ret;\n\tu8 op[3] = {0, reg, val};\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= sizeof(op),\n\t\t.buf\t= op\n\t};\n\n\tret = isl12026_arm_write(client);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev, \"write error CCR, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\tmsleep(ISL12026_NVMEM_WRITE_TIME);\n\n\tret = isl12026_disarm_write(client);\nout:\n\treturn ret;\n}\n\nstatic int isl12026_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\tu8 op[10];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= sizeof(op),\n\t\t.buf\t= op\n\t};\n\n\tret = isl12026_arm_write(client);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\top[0] = 0;\n\top[1] = ISL12026_REG_SC;\n\top[2] = bin2bcd(tm->tm_sec);  \n\top[3] = bin2bcd(tm->tm_min);  \n\top[4] = bin2bcd(tm->tm_hour) | ISL12026_REG_HR_MIL;  \n\top[5] = bin2bcd(tm->tm_mday);  \n\top[6] = bin2bcd(tm->tm_mon + 1);  \n\top[7] = bin2bcd(tm->tm_year % 100);  \n\top[8] = bin2bcd(tm->tm_wday & 7);  \n\top[9] = bin2bcd(tm->tm_year >= 100 ? 20 : 19);  \n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev, \"write error CCR, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\tret = isl12026_disarm_write(client);\nout:\n\treturn ret;\n}\n\nstatic int isl12026_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 ccr[8];\n\tu8 addr[2];\n\tu8 sr;\n\tint ret;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= sizeof(addr),\n\t\t\t.buf\t= addr\n\t\t}, {\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t}\n\t};\n\n\t \n\taddr[0] = 0;\n\taddr[1] = ISL12026_REG_SR;\n\tmsgs[1].len = 1;\n\tmsgs[1].buf = &sr;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, \"read error, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\tif (sr & ISL12026_REG_SR_RTCF)\n\t\tdev_warn(&client->dev, \"Real-Time Clock Failure on read\\n\");\n\tif (sr & ISL12026_REG_SR_OSCF)\n\t\tdev_warn(&client->dev, \"Oscillator Failure on read\\n\");\n\n\t \n\taddr[0] = 0;\n\taddr[1] = ISL12026_REG_SC;\n\tmsgs[1].len = sizeof(ccr);\n\tmsgs[1].buf = ccr;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, \"read error, ret=%d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto out;\n\t}\n\n\ttm->tm_sec = bcd2bin(ccr[0] & 0x7F);\n\ttm->tm_min = bcd2bin(ccr[1] & 0x7F);\n\tif (ccr[2] & ISL12026_REG_HR_MIL)\n\t\ttm->tm_hour = bcd2bin(ccr[2] & 0x3F);\n\telse\n\t\ttm->tm_hour = bcd2bin(ccr[2] & 0x1F) +\n\t\t\t((ccr[2] & 0x20) ? 12 : 0);\n\ttm->tm_mday = bcd2bin(ccr[3] & 0x3F);\n\ttm->tm_mon = bcd2bin(ccr[4] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(ccr[5]);\n\tif (bcd2bin(ccr[7]) == 20)\n\t\ttm->tm_year += 100;\n\ttm->tm_wday = ccr[6] & 0x07;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops isl12026_rtc_ops = {\n\t.read_time\t= isl12026_rtc_read_time,\n\t.set_time\t= isl12026_rtc_set_time,\n};\n\nstatic int isl12026_nvm_read(void *p, unsigned int offset,\n\t\t\t     void *val, size_t bytes)\n{\n\tstruct isl12026 *priv = p;\n\tint ret;\n\tu8 addr[2];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= priv->nvm_client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= sizeof(addr),\n\t\t\t.buf\t= addr\n\t\t}, {\n\t\t\t.addr\t= priv->nvm_client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf\t= val\n\t\t}\n\t};\n\n\t \n\tret = mutex_lock_interruptible(&priv->rtc->ops_lock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\taddr[0] = offset >> 8;\n\taddr[1] = offset;\n\tmsgs[1].len = bytes;\n\tret = i2c_transfer(priv->nvm_client->adapter, msgs, ARRAY_SIZE(msgs));\n\n\tmutex_unlock(&priv->rtc->ops_lock);\n\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&priv->nvm_client->dev,\n\t\t\t\"nvmem read error, ret=%d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int isl12026_nvm_write(void *p, unsigned int offset,\n\t\t\t      void *val, size_t bytes)\n{\n\tstruct isl12026 *priv = p;\n\tint ret;\n\tu8 *v = val;\n\tsize_t chunk_size, num_written;\n\tu8 payload[ISL12026_PAGESIZE + 2];  \n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= priv->nvm_client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.buf\t= payload\n\t\t}\n\t};\n\n\t \n\tret = mutex_lock_interruptible(&priv->rtc->ops_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tnum_written = 0;\n\twhile (bytes) {\n\t\tchunk_size = round_down(offset, ISL12026_PAGESIZE) +\n\t\t\tISL12026_PAGESIZE - offset;\n\t\tchunk_size = min(bytes, chunk_size);\n\t\t \n\t\tmemcpy(payload + 2, v + num_written, chunk_size);\n\t\tpayload[0] = offset >> 8;\n\t\tpayload[1] = offset;\n\t\tmsgs[0].len = chunk_size + 2;\n\t\tret = i2c_transfer(priv->nvm_client->adapter,\n\t\t\t\t   msgs, ARRAY_SIZE(msgs));\n\t\tif (ret != ARRAY_SIZE(msgs)) {\n\t\t\tdev_err(&priv->nvm_client->dev,\n\t\t\t\t\"nvmem write error, ret=%d\\n\", ret);\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbytes -= chunk_size;\n\t\toffset += chunk_size;\n\t\tnum_written += chunk_size;\n\t\tmsleep(ISL12026_NVMEM_WRITE_TIME);\n\t}\n\n\tmutex_unlock(&priv->rtc->ops_lock);\n\n\treturn ret;\n}\n\nstatic void isl12026_force_power_modes(struct i2c_client *client)\n{\n\tint ret;\n\tint pwr, requested_pwr;\n\tu32 bsw_val, sbib_val;\n\tbool set_bsw, set_sbib;\n\n\t \n\tret = of_property_read_u32(client->dev.of_node,\n\t\t\t\t   \"isil,pwr-bsw\", &bsw_val);\n\tset_bsw = (ret == 0);\n\n\tret = of_property_read_u32(client->dev.of_node,\n\t\t\t\t   \"isil,pwr-sbib\", &sbib_val);\n\tset_sbib = (ret == 0);\n\n\t \n\tif (!set_bsw && !set_sbib)\n\t\treturn;\n\n\tpwr = isl12026_read_reg(client, ISL12026_REG_PWR);\n\tif (pwr < 0) {\n\t\tdev_warn(&client->dev, \"Error: Failed to read PWR %d\\n\", pwr);\n\t\treturn;\n\t}\n\n\trequested_pwr = pwr;\n\n\tif (set_bsw) {\n\t\tif (bsw_val)\n\t\t\trequested_pwr |= ISL12026_REG_PWR_BSW;\n\t\telse\n\t\t\trequested_pwr &= ~ISL12026_REG_PWR_BSW;\n\t}  \n\n\tif (set_sbib) {\n\t\tif (sbib_val)\n\t\t\trequested_pwr |= ISL12026_REG_PWR_SBIB;\n\t\telse\n\t\t\trequested_pwr &= ~ISL12026_REG_PWR_SBIB;\n\t}  \n\n\tif (pwr >= 0 && pwr != requested_pwr) {\n\t\tdev_dbg(&client->dev, \"PWR: %02x\\n\", pwr);\n\t\tdev_dbg(&client->dev, \"Updating PWR to: %02x\\n\", requested_pwr);\n\t\tisl12026_write_reg(client, ISL12026_REG_PWR, requested_pwr);\n\t}\n}\n\nstatic int isl12026_probe(struct i2c_client *client)\n{\n\tstruct isl12026 *priv;\n\tint ret;\n\tstruct nvmem_config nvm_cfg = {\n\t\t.name = \"isl12026-\",\n\t\t.base_dev = &client->dev,\n\t\t.stride = 1,\n\t\t.word_size = 1,\n\t\t.size = 512,\n\t\t.reg_read = isl12026_nvm_read,\n\t\t.reg_write = isl12026_nvm_write,\n\t};\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, priv);\n\n\tisl12026_force_power_modes(client);\n\n\tpriv->nvm_client = i2c_new_dummy_device(client->adapter, ISL12026_EEPROM_ADDR);\n\tif (IS_ERR(priv->nvm_client))\n\t\treturn PTR_ERR(priv->nvm_client);\n\n\tpriv->rtc = devm_rtc_allocate_device(&client->dev);\n\tret = PTR_ERR_OR_ZERO(priv->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->rtc->ops = &isl12026_rtc_ops;\n\tnvm_cfg.priv = priv;\n\tret = devm_rtc_nvmem_register(priv->rtc, &nvm_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_register_device(priv->rtc);\n}\n\nstatic void isl12026_remove(struct i2c_client *client)\n{\n\tstruct isl12026 *priv = i2c_get_clientdata(client);\n\n\ti2c_unregister_device(priv->nvm_client);\n}\n\nstatic const struct of_device_id isl12026_dt_match[] = {\n\t{ .compatible = \"isil,isl12026\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, isl12026_dt_match);\n\nstatic struct i2c_driver isl12026_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-isl12026\",\n\t\t.of_match_table = isl12026_dt_match,\n\t},\n\t.probe\t\t= isl12026_probe,\n\t.remove\t\t= isl12026_remove,\n};\n\nmodule_i2c_driver(isl12026_driver);\n\nMODULE_DESCRIPTION(\"ISL 12026 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}