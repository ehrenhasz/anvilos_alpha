{
  "module_name": "rtc-pcf85363.c",
  "hash_id": "b99a47250c2da7cc80c0f57384d077d8176ec34b5a1744acaf43b17940f7beca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf85363.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/bcd.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define DT_100THS\t0x00\n#define DT_SECS\t\t0x01\n#define DT_MINUTES\t0x02\n#define DT_HOURS\t0x03\n#define DT_DAYS\t\t0x04\n#define DT_WEEKDAYS\t0x05\n#define DT_MONTHS\t0x06\n#define DT_YEARS\t0x07\n\n \n#define DT_SECOND_ALM1\t0x08\n#define DT_MINUTE_ALM1\t0x09\n#define DT_HOUR_ALM1\t0x0a\n#define DT_DAY_ALM1\t0x0b\n#define DT_MONTH_ALM1\t0x0c\n#define DT_MINUTE_ALM2\t0x0d\n#define DT_HOUR_ALM2\t0x0e\n#define DT_WEEKDAY_ALM2\t0x0f\n#define DT_ALARM_EN\t0x10\n\n \n#define DT_TIMESTAMP1\t0x11\n#define DT_TIMESTAMP2\t0x17\n#define DT_TIMESTAMP3\t0x1d\n#define DT_TS_MODE\t0x23\n\n \n#define CTRL_OFFSET\t0x24\n#define CTRL_OSCILLATOR\t0x25\n#define CTRL_BATTERY\t0x26\n#define CTRL_PIN_IO\t0x27\n#define CTRL_FUNCTION\t0x28\n#define CTRL_INTA_EN\t0x29\n#define CTRL_INTB_EN\t0x2a\n#define CTRL_FLAGS\t0x2b\n#define CTRL_RAMBYTE\t0x2c\n#define CTRL_WDOG\t0x2d\n#define CTRL_STOP_EN\t0x2e\n#define CTRL_RESETS\t0x2f\n#define CTRL_RAM\t0x40\n\n#define ALRM_SEC_A1E\tBIT(0)\n#define ALRM_MIN_A1E\tBIT(1)\n#define ALRM_HR_A1E\tBIT(2)\n#define ALRM_DAY_A1E\tBIT(3)\n#define ALRM_MON_A1E\tBIT(4)\n#define ALRM_MIN_A2E\tBIT(5)\n#define ALRM_HR_A2E\tBIT(6)\n#define ALRM_DAY_A2E\tBIT(7)\n\n#define INT_WDIE\tBIT(0)\n#define INT_BSIE\tBIT(1)\n#define INT_TSRIE\tBIT(2)\n#define INT_A2IE\tBIT(3)\n#define INT_A1IE\tBIT(4)\n#define INT_OIE\t\tBIT(5)\n#define INT_PIE\t\tBIT(6)\n#define INT_ILP\t\tBIT(7)\n\n#define FLAGS_TSR1F\tBIT(0)\n#define FLAGS_TSR2F\tBIT(1)\n#define FLAGS_TSR3F\tBIT(2)\n#define FLAGS_BSF\tBIT(3)\n#define FLAGS_WDF\tBIT(4)\n#define FLAGS_A1F\tBIT(5)\n#define FLAGS_A2F\tBIT(6)\n#define FLAGS_PIF\tBIT(7)\n\n#define PIN_IO_INTAPM\tGENMASK(1, 0)\n#define PIN_IO_INTA_CLK\t0\n#define PIN_IO_INTA_BAT\t1\n#define PIN_IO_INTA_OUT\t2\n#define PIN_IO_INTA_HIZ\t3\n\n#define OSC_CAP_SEL\tGENMASK(1, 0)\n#define OSC_CAP_6000\t0x01\n#define OSC_CAP_12500\t0x02\n\n#define STOP_EN_STOP\tBIT(0)\n\n#define RESET_CPR\t0xa4\n\n#define NVRAM_SIZE\t0x40\n\nstruct pcf85363 {\n\tstruct rtc_device\t*rtc;\n\tstruct regmap\t\t*regmap;\n};\n\nstruct pcf85x63_config {\n\tstruct regmap_config regmap;\n\tunsigned int num_nvram;\n};\n\nstatic int pcf85363_load_capacitance(struct pcf85363 *pcf85363, struct device_node *node)\n{\n\tu32 load = 7000;\n\tu8 value = 0;\n\n\tof_property_read_u32(node, \"quartz-load-femtofarads\", &load);\n\n\tswitch (load) {\n\tdefault:\n\t\tdev_warn(&pcf85363->rtc->dev, \"Unknown quartz-load-femtofarads value: %d. Assuming 7000\",\n\t\t\t load);\n\t\tfallthrough;\n\tcase 7000:\n\t\tbreak;\n\tcase 6000:\n\t\tvalue = OSC_CAP_6000;\n\t\tbreak;\n\tcase 12500:\n\t\tvalue = OSC_CAP_12500;\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(pcf85363->regmap, CTRL_OSCILLATOR,\n\t\t\t\t  OSC_CAP_SEL, value);\n}\n\nstatic int pcf85363_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf85363 *pcf85363 = dev_get_drvdata(dev);\n\tunsigned char buf[DT_YEARS + 1];\n\tint ret, len = sizeof(buf);\n\n\t \n\tret = regmap_bulk_read(pcf85363->regmap, DT_100THS, buf, len);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: error %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_year = bcd2bin(buf[DT_YEARS]);\n\t \n\ttm->tm_year += 100;\n\n\ttm->tm_wday = buf[DT_WEEKDAYS] & 7;\n\tbuf[DT_SECS] &= 0x7F;\n\ttm->tm_sec = bcd2bin(buf[DT_SECS]);\n\tbuf[DT_MINUTES] &= 0x7F;\n\ttm->tm_min = bcd2bin(buf[DT_MINUTES]);\n\ttm->tm_hour = bcd2bin(buf[DT_HOURS]);\n\ttm->tm_mday = bcd2bin(buf[DT_DAYS]);\n\ttm->tm_mon = bcd2bin(buf[DT_MONTHS]) - 1;\n\n\treturn 0;\n}\n\nstatic int pcf85363_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf85363 *pcf85363 = dev_get_drvdata(dev);\n\tunsigned char tmp[11];\n\tunsigned char *buf = &tmp[2];\n\tint ret;\n\n\ttmp[0] = STOP_EN_STOP;\n\ttmp[1] = RESET_CPR;\n\n\tbuf[DT_100THS] = 0;\n\tbuf[DT_SECS] = bin2bcd(tm->tm_sec);\n\tbuf[DT_MINUTES] = bin2bcd(tm->tm_min);\n\tbuf[DT_HOURS] = bin2bcd(tm->tm_hour);\n\tbuf[DT_DAYS] = bin2bcd(tm->tm_mday);\n\tbuf[DT_WEEKDAYS] = tm->tm_wday;\n\tbuf[DT_MONTHS] = bin2bcd(tm->tm_mon + 1);\n\tbuf[DT_YEARS] = bin2bcd(tm->tm_year % 100);\n\n\tret = regmap_bulk_write(pcf85363->regmap, CTRL_STOP_EN,\n\t\t\t\ttmp, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(pcf85363->regmap, DT_100THS,\n\t\t\t\tbuf, sizeof(tmp) - 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(pcf85363->regmap, CTRL_STOP_EN, 0);\n}\n\nstatic int pcf85363_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf85363 *pcf85363 = dev_get_drvdata(dev);\n\tunsigned char buf[DT_MONTH_ALM1 - DT_SECOND_ALM1 + 1];\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_bulk_read(pcf85363->regmap, DT_SECOND_ALM1, buf,\n\t\t\t       sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\talrm->time.tm_sec = bcd2bin(buf[0]);\n\talrm->time.tm_min = bcd2bin(buf[1]);\n\talrm->time.tm_hour = bcd2bin(buf[2]);\n\talrm->time.tm_mday = bcd2bin(buf[3]);\n\talrm->time.tm_mon = bcd2bin(buf[4]) - 1;\n\n\tret = regmap_read(pcf85363->regmap, CTRL_INTA_EN, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled =  !!(val & INT_A1IE);\n\n\treturn 0;\n}\n\nstatic int _pcf85363_rtc_alarm_irq_enable(struct pcf85363 *pcf85363, unsigned\n\t\t\t\t\t  int enabled)\n{\n\tunsigned int alarm_flags = ALRM_SEC_A1E | ALRM_MIN_A1E | ALRM_HR_A1E |\n\t\t\t\t   ALRM_DAY_A1E | ALRM_MON_A1E;\n\tint ret;\n\n\tret = regmap_update_bits(pcf85363->regmap, DT_ALARM_EN, alarm_flags,\n\t\t\t\t enabled ? alarm_flags : 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(pcf85363->regmap, CTRL_INTA_EN,\n\t\t\t\t INT_A1IE, enabled ? INT_A1IE : 0);\n\n\tif (ret || enabled)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(pcf85363->regmap, CTRL_FLAGS, FLAGS_A1F, 0);\n}\n\nstatic int pcf85363_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enabled)\n{\n\tstruct pcf85363 *pcf85363 = dev_get_drvdata(dev);\n\n\treturn _pcf85363_rtc_alarm_irq_enable(pcf85363, enabled);\n}\n\nstatic int pcf85363_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf85363 *pcf85363 = dev_get_drvdata(dev);\n\tunsigned char buf[DT_MONTH_ALM1 - DT_SECOND_ALM1 + 1];\n\tint ret;\n\n\tbuf[0] = bin2bcd(alrm->time.tm_sec);\n\tbuf[1] = bin2bcd(alrm->time.tm_min);\n\tbuf[2] = bin2bcd(alrm->time.tm_hour);\n\tbuf[3] = bin2bcd(alrm->time.tm_mday);\n\tbuf[4] = bin2bcd(alrm->time.tm_mon + 1);\n\n\t \n\tret = _pcf85363_rtc_alarm_irq_enable(pcf85363, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(pcf85363->regmap, DT_SECOND_ALM1, buf,\n\t\t\t\tsizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn _pcf85363_rtc_alarm_irq_enable(pcf85363, alrm->enabled);\n}\n\nstatic irqreturn_t pcf85363_rtc_handle_irq(int irq, void *dev_id)\n{\n\tstruct pcf85363 *pcf85363 = i2c_get_clientdata(dev_id);\n\tunsigned int flags;\n\tint err;\n\n\terr = regmap_read(pcf85363->regmap, CTRL_FLAGS, &flags);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (flags & FLAGS_A1F) {\n\t\trtc_update_irq(pcf85363->rtc, 1, RTC_IRQF | RTC_AF);\n\t\tregmap_update_bits(pcf85363->regmap, CTRL_FLAGS, FLAGS_A1F, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct rtc_class_ops rtc_ops = {\n\t.read_time\t= pcf85363_rtc_read_time,\n\t.set_time\t= pcf85363_rtc_set_time,\n\t.read_alarm\t= pcf85363_rtc_read_alarm,\n\t.set_alarm\t= pcf85363_rtc_set_alarm,\n\t.alarm_irq_enable = pcf85363_rtc_alarm_irq_enable,\n};\n\nstatic int pcf85363_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t       size_t bytes)\n{\n\tstruct pcf85363 *pcf85363 = priv;\n\n\treturn regmap_bulk_read(pcf85363->regmap, CTRL_RAM + offset,\n\t\t\t\tval, bytes);\n}\n\nstatic int pcf85363_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t\tsize_t bytes)\n{\n\tstruct pcf85363 *pcf85363 = priv;\n\n\treturn regmap_bulk_write(pcf85363->regmap, CTRL_RAM + offset,\n\t\t\t\t val, bytes);\n}\n\nstatic int pcf85x63_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t       size_t bytes)\n{\n\tstruct pcf85363 *pcf85363 = priv;\n\tunsigned int tmp_val;\n\tint ret;\n\n\tret = regmap_read(pcf85363->regmap, CTRL_RAMBYTE, &tmp_val);\n\t(*(unsigned char *) val) = (unsigned char) tmp_val;\n\n\treturn ret;\n}\n\nstatic int pcf85x63_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t\tsize_t bytes)\n{\n\tstruct pcf85363 *pcf85363 = priv;\n\tunsigned char tmp_val;\n\n\ttmp_val = *((unsigned char *)val);\n\treturn regmap_write(pcf85363->regmap, CTRL_RAMBYTE,\n\t\t\t\t(unsigned int)tmp_val);\n}\n\nstatic const struct pcf85x63_config pcf_85263_config = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x2f,\n\t},\n\t.num_nvram = 1\n};\n\nstatic const struct pcf85x63_config pcf_85363_config = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x7f,\n\t},\n\t.num_nvram = 2\n};\n\nstatic int pcf85363_probe(struct i2c_client *client)\n{\n\tstruct pcf85363 *pcf85363;\n\tconst struct pcf85x63_config *config = &pcf_85363_config;\n\tconst void *data = of_device_get_match_data(&client->dev);\n\tstatic struct nvmem_config nvmem_cfg[] = {\n\t\t{\n\t\t\t.name = \"pcf85x63-\",\n\t\t\t.word_size = 1,\n\t\t\t.stride = 1,\n\t\t\t.size = 1,\n\t\t\t.reg_read = pcf85x63_nvram_read,\n\t\t\t.reg_write = pcf85x63_nvram_write,\n\t\t}, {\n\t\t\t.name = \"pcf85363-\",\n\t\t\t.word_size = 1,\n\t\t\t.stride = 1,\n\t\t\t.size = NVRAM_SIZE,\n\t\t\t.reg_read = pcf85363_nvram_read,\n\t\t\t.reg_write = pcf85363_nvram_write,\n\t\t},\n\t};\n\tint ret, i, err;\n\tbool wakeup_source;\n\n\tif (data)\n\t\tconfig = data;\n\n\tpcf85363 = devm_kzalloc(&client->dev, sizeof(struct pcf85363),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcf85363)\n\t\treturn -ENOMEM;\n\n\tpcf85363->regmap = devm_regmap_init_i2c(client, &config->regmap);\n\tif (IS_ERR(pcf85363->regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(pcf85363->regmap);\n\t}\n\n\ti2c_set_clientdata(client, pcf85363);\n\n\tpcf85363->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(pcf85363->rtc))\n\t\treturn PTR_ERR(pcf85363->rtc);\n\n\terr = pcf85363_load_capacitance(pcf85363, client->dev.of_node);\n\tif (err < 0)\n\t\tdev_warn(&client->dev, \"failed to set xtal load capacitance: %d\",\n\t\t\t err);\n\n\tpcf85363->rtc->ops = &rtc_ops;\n\tpcf85363->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpcf85363->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\twakeup_source = device_property_read_bool(&client->dev,\n\t\t\t\t\t\t  \"wakeup-source\");\n\tif (client->irq > 0 || wakeup_source) {\n\t\tregmap_write(pcf85363->regmap, CTRL_FLAGS, 0);\n\t\tregmap_update_bits(pcf85363->regmap, CTRL_PIN_IO,\n\t\t\t\t   PIN_IO_INTAPM, PIN_IO_INTA_OUT);\n\t}\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, pcf85363_rtc_handle_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"pcf85363\", client);\n\t\tif (ret) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\n\tif (client->irq > 0 || wakeup_source) {\n\t\tdevice_init_wakeup(&client->dev, true);\n\t\tset_bit(RTC_FEATURE_ALARM, pcf85363->rtc->features);\n\t} else {\n\t\tclear_bit(RTC_FEATURE_ALARM, pcf85363->rtc->features);\n\t}\n\n\tret = devm_rtc_register_device(pcf85363->rtc);\n\n\tfor (i = 0; i < config->num_nvram; i++) {\n\t\tnvmem_cfg[i].priv = pcf85363;\n\t\tdevm_rtc_nvmem_register(pcf85363->rtc, &nvmem_cfg[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic const __maybe_unused struct of_device_id dev_ids[] = {\n\t{ .compatible = \"nxp,pcf85263\", .data = &pcf_85263_config },\n\t{ .compatible = \"nxp,pcf85363\", .data = &pcf_85363_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dev_ids);\n\nstatic struct i2c_driver pcf85363_driver = {\n\t.driver\t= {\n\t\t.name\t= \"pcf85363\",\n\t\t.of_match_table = of_match_ptr(dev_ids),\n\t},\n\t.probe = pcf85363_probe,\n};\n\nmodule_i2c_driver(pcf85363_driver);\n\nMODULE_AUTHOR(\"Eric Nelson\");\nMODULE_DESCRIPTION(\"pcf85263/pcf85363 I2C RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}