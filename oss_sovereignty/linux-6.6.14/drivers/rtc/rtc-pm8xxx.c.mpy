{
  "module_name": "rtc-pm8xxx.c",
  "hash_id": "b1f58027ec37016774827f28806d0299442174661be2ad851c84c9a9714819d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pm8xxx.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/init.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <asm/unaligned.h>\n\n \n#define PM8xxx_RTC_ENABLE\t\tBIT(7)\n#define PM8xxx_RTC_ALARM_CLEAR\t\tBIT(0)\n#define PM8xxx_RTC_ALARM_ENABLE\t\tBIT(7)\n\n#define NUM_8_BIT_RTC_REGS\t\t0x4\n\n \nstruct pm8xxx_rtc_regs {\n\tunsigned int ctrl;\n\tunsigned int write;\n\tunsigned int read;\n\tunsigned int alarm_ctrl;\n\tunsigned int alarm_ctrl2;\n\tunsigned int alarm_rw;\n\tunsigned int alarm_en;\n};\n\n \nstruct pm8xxx_rtc {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\tbool allow_set_time;\n\tint alarm_irq;\n\tconst struct pm8xxx_rtc_regs *regs;\n\tstruct device *dev;\n\tstruct nvmem_cell *nvmem_cell;\n\tu32 offset;\n};\n\nstatic int pm8xxx_rtc_read_nvmem_offset(struct pm8xxx_rtc *rtc_dd)\n{\n\tsize_t len;\n\tvoid *buf;\n\tint rc;\n\n\tbuf = nvmem_cell_read(rtc_dd->nvmem_cell, &len);\n\tif (IS_ERR(buf)) {\n\t\trc = PTR_ERR(buf);\n\t\tdev_dbg(rtc_dd->dev, \"failed to read nvmem offset: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (len != sizeof(u32)) {\n\t\tdev_dbg(rtc_dd->dev, \"unexpected nvmem cell size %zu\\n\", len);\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\n\trtc_dd->offset = get_unaligned_le32(buf);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_write_nvmem_offset(struct pm8xxx_rtc *rtc_dd, u32 offset)\n{\n\tu8 buf[sizeof(u32)];\n\tint rc;\n\n\tput_unaligned_le32(offset, buf);\n\n\trc = nvmem_cell_write(rtc_dd->nvmem_cell, buf, sizeof(buf));\n\tif (rc < 0) {\n\t\tdev_dbg(rtc_dd->dev, \"failed to write nvmem offset: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_read_offset(struct pm8xxx_rtc *rtc_dd)\n{\n\tif (!rtc_dd->nvmem_cell)\n\t\treturn 0;\n\n\treturn pm8xxx_rtc_read_nvmem_offset(rtc_dd);\n}\n\nstatic int pm8xxx_rtc_read_raw(struct pm8xxx_rtc *rtc_dd, u32 *secs)\n{\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tunsigned int reg;\n\tint rc;\n\n\trc = regmap_bulk_read(rtc_dd->regmap, regs->read, value, sizeof(value));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_read(rtc_dd->regmap, regs->read, &reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (reg < value[0]) {\n\t\trc = regmap_bulk_read(rtc_dd->regmap, regs->read, value,\n\t\t\t\t      sizeof(value));\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*secs = get_unaligned_le32(value);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_update_offset(struct pm8xxx_rtc *rtc_dd, u32 secs)\n{\n\tu32 raw_secs;\n\tu32 offset;\n\tint rc;\n\n\tif (!rtc_dd->nvmem_cell)\n\t\treturn -ENODEV;\n\n\trc = pm8xxx_rtc_read_raw(rtc_dd, &raw_secs);\n\tif (rc)\n\t\treturn rc;\n\n\toffset = secs - raw_secs;\n\n\tif (offset == rtc_dd->offset)\n\t\treturn 0;\n\n\trc = pm8xxx_rtc_write_nvmem_offset(rtc_dd, offset);\n\tif (rc)\n\t\treturn rc;\n\n\trtc_dd->offset = offset;\n\n\treturn 0;\n}\n\n \nstatic int __pm8xxx_rtc_set_time(struct pm8xxx_rtc *rtc_dd, u32 secs)\n{\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tbool alarm_enabled;\n\tint rc;\n\n\tput_unaligned_le32(secs, value);\n\n\trc = regmap_update_bits_check(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\t      regs->alarm_en, 0, &alarm_enabled);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_update_bits(rtc_dd->regmap, regs->ctrl, PM8xxx_RTC_ENABLE, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write(rtc_dd->regmap, regs->write, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_bulk_write(rtc_dd->regmap, regs->write + 1,\n\t\t\t       &value[1], sizeof(value) - 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_write(rtc_dd->regmap, regs->write, value[0]);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = regmap_update_bits(rtc_dd->regmap, regs->ctrl, PM8xxx_RTC_ENABLE,\n\t\t\t\tPM8xxx_RTC_ENABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (alarm_enabled) {\n\t\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\t\tregs->alarm_en, regs->alarm_en);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tu32 secs;\n\tint rc;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\tif (rtc_dd->allow_set_time)\n\t\trc = __pm8xxx_rtc_set_time(rtc_dd, secs);\n\telse\n\t\trc = pm8xxx_rtc_update_offset(rtc_dd, secs);\n\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(dev, \"set time: %ptRd %ptRt (%u + %u)\\n\", tm, tm,\n\t\t\tsecs - rtc_dd->offset, rtc_dd->offset);\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tu32 secs;\n\tint rc;\n\n\trc = pm8xxx_rtc_read_raw(rtc_dd, &secs);\n\tif (rc)\n\t\treturn rc;\n\n\tsecs += rtc_dd->offset;\n\trtc_time64_to_tm(secs, tm);\n\n\tdev_dbg(dev, \"read time: %ptRd %ptRt (%u + %u)\\n\", tm, tm,\n\t\t\tsecs - rtc_dd->offset, rtc_dd->offset);\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tu32 secs;\n\tint rc;\n\n\tsecs = rtc_tm_to_time64(&alarm->time);\n\tsecs -= rtc_dd->offset;\n\tput_unaligned_le32(secs, value);\n\n\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\tregs->alarm_en, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regmap_bulk_write(rtc_dd->regmap, regs->alarm_rw, value,\n\t\t\t       sizeof(value));\n\tif (rc)\n\t\treturn rc;\n\n\tif (alarm->enabled) {\n\t\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\t\tregs->alarm_en, regs->alarm_en);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tdev_dbg(dev, \"set alarm: %ptRd %ptRt\\n\", &alarm->time, &alarm->time);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tu8 value[NUM_8_BIT_RTC_REGS];\n\tunsigned int ctrl_reg;\n\tu32 secs;\n\tint rc;\n\n\trc = regmap_bulk_read(rtc_dd->regmap, regs->alarm_rw, value,\n\t\t\t      sizeof(value));\n\tif (rc)\n\t\treturn rc;\n\n\tsecs = get_unaligned_le32(value);\n\tsecs += rtc_dd->offset;\n\trtc_time64_to_tm(secs, &alarm->time);\n\n\trc = regmap_read(rtc_dd->regmap, regs->alarm_ctrl, &ctrl_reg);\n\tif (rc)\n\t\treturn rc;\n\n\talarm->enabled = !!(ctrl_reg & PM8xxx_RTC_ALARM_ENABLE);\n\n\tdev_dbg(dev, \"read alarm: %ptRd %ptRt\\n\", &alarm->time, &alarm->time);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_get_drvdata(dev);\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tu8 value[NUM_8_BIT_RTC_REGS] = {0};\n\tunsigned int val;\n\tint rc;\n\n\tif (enable)\n\t\tval = regs->alarm_en;\n\telse\n\t\tval = 0;\n\n\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\tregs->alarm_en, val);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!enable) {\n\t\trc = regmap_bulk_write(rtc_dd->regmap, regs->alarm_rw, value,\n\t\t\t\t       sizeof(value));\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pm8xxx_rtc_ops = {\n\t.read_time\t= pm8xxx_rtc_read_time,\n\t.set_time\t= pm8xxx_rtc_set_time,\n\t.set_alarm\t= pm8xxx_rtc_set_alarm,\n\t.read_alarm\t= pm8xxx_rtc_read_alarm,\n\t.alarm_irq_enable = pm8xxx_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t pm8xxx_alarm_trigger(int irq, void *dev_id)\n{\n\tstruct pm8xxx_rtc *rtc_dd = dev_id;\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\tint rc;\n\n\trtc_update_irq(rtc_dd->rtc, 1, RTC_IRQF | RTC_AF);\n\n\t \n\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl,\n\t\t\t\tregs->alarm_en, 0);\n\tif (rc)\n\t\treturn IRQ_NONE;\n\n\t \n\trc = regmap_update_bits(rtc_dd->regmap, regs->alarm_ctrl2,\n\t\t\t\tPM8xxx_RTC_ALARM_CLEAR, 0);\n\tif (rc)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm8xxx_rtc_enable(struct pm8xxx_rtc *rtc_dd)\n{\n\tconst struct pm8xxx_rtc_regs *regs = rtc_dd->regs;\n\n\treturn regmap_update_bits(rtc_dd->regmap, regs->ctrl, PM8xxx_RTC_ENABLE,\n\t\t\t\t  PM8xxx_RTC_ENABLE);\n}\n\nstatic const struct pm8xxx_rtc_regs pm8921_regs = {\n\t.ctrl\t\t= 0x11d,\n\t.write\t\t= 0x11f,\n\t.read\t\t= 0x123,\n\t.alarm_rw\t= 0x127,\n\t.alarm_ctrl\t= 0x11d,\n\t.alarm_ctrl2\t= 0x11e,\n\t.alarm_en\t= BIT(1),\n};\n\nstatic const struct pm8xxx_rtc_regs pm8058_regs = {\n\t.ctrl\t\t= 0x1e8,\n\t.write\t\t= 0x1ea,\n\t.read\t\t= 0x1ee,\n\t.alarm_rw\t= 0x1f2,\n\t.alarm_ctrl\t= 0x1e8,\n\t.alarm_ctrl2\t= 0x1e9,\n\t.alarm_en\t= BIT(1),\n};\n\nstatic const struct pm8xxx_rtc_regs pm8941_regs = {\n\t.ctrl\t\t= 0x6046,\n\t.write\t\t= 0x6040,\n\t.read\t\t= 0x6048,\n\t.alarm_rw\t= 0x6140,\n\t.alarm_ctrl\t= 0x6146,\n\t.alarm_ctrl2\t= 0x6148,\n\t.alarm_en\t= BIT(7),\n};\n\nstatic const struct pm8xxx_rtc_regs pmk8350_regs = {\n\t.ctrl\t\t= 0x6146,\n\t.write\t\t= 0x6140,\n\t.read\t\t= 0x6148,\n\t.alarm_rw\t= 0x6240,\n\t.alarm_ctrl\t= 0x6246,\n\t.alarm_ctrl2\t= 0x6248,\n\t.alarm_en\t= BIT(7),\n};\n\nstatic const struct of_device_id pm8xxx_id_table[] = {\n\t{ .compatible = \"qcom,pm8921-rtc\", .data = &pm8921_regs },\n\t{ .compatible = \"qcom,pm8058-rtc\", .data = &pm8058_regs },\n\t{ .compatible = \"qcom,pm8941-rtc\", .data = &pm8941_regs },\n\t{ .compatible = \"qcom,pmk8350-rtc\", .data = &pmk8350_regs },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_id_table);\n\nstatic int pm8xxx_rtc_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct pm8xxx_rtc *rtc_dd;\n\tint rc;\n\n\tmatch = of_match_node(pm8xxx_id_table, pdev->dev.of_node);\n\tif (!match)\n\t\treturn -ENXIO;\n\n\trtc_dd = devm_kzalloc(&pdev->dev, sizeof(*rtc_dd), GFP_KERNEL);\n\tif (rtc_dd == NULL)\n\t\treturn -ENOMEM;\n\n\trtc_dd->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!rtc_dd->regmap)\n\t\treturn -ENXIO;\n\n\trtc_dd->alarm_irq = platform_get_irq(pdev, 0);\n\tif (rtc_dd->alarm_irq < 0)\n\t\treturn -ENXIO;\n\n\trtc_dd->allow_set_time = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t      \"allow-set-time\");\n\n\trtc_dd->nvmem_cell = devm_nvmem_cell_get(&pdev->dev, \"offset\");\n\tif (IS_ERR(rtc_dd->nvmem_cell)) {\n\t\trc = PTR_ERR(rtc_dd->nvmem_cell);\n\t\tif (rc != -ENOENT)\n\t\t\treturn rc;\n\t\trtc_dd->nvmem_cell = NULL;\n\t}\n\n\trtc_dd->regs = match->data;\n\trtc_dd->dev = &pdev->dev;\n\n\tif (!rtc_dd->allow_set_time) {\n\t\trc = pm8xxx_rtc_read_offset(rtc_dd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = pm8xxx_rtc_enable(rtc_dd);\n\tif (rc)\n\t\treturn rc;\n\n\tplatform_set_drvdata(pdev, rtc_dd);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\trtc_dd->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc_dd->rtc))\n\t\treturn PTR_ERR(rtc_dd->rtc);\n\n\trtc_dd->rtc->ops = &pm8xxx_rtc_ops;\n\trtc_dd->rtc->range_max = U32_MAX;\n\n\trc = devm_request_any_context_irq(&pdev->dev, rtc_dd->alarm_irq,\n\t\t\t\t\t  pm8xxx_alarm_trigger,\n\t\t\t\t\t  IRQF_TRIGGER_RISING,\n\t\t\t\t\t  \"pm8xxx_rtc_alarm\", rtc_dd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = devm_rtc_register_device(rtc_dd->rtc);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dev_pm_set_wake_irq(&pdev->dev, rtc_dd->alarm_irq);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void pm8xxx_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n}\n\nstatic struct platform_driver pm8xxx_rtc_driver = {\n\t.probe\t\t= pm8xxx_rtc_probe,\n\t.remove_new\t= pm8xxx_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"rtc-pm8xxx\",\n\t\t.of_match_table\t= pm8xxx_id_table,\n\t},\n};\n\nmodule_platform_driver(pm8xxx_rtc_driver);\n\nMODULE_ALIAS(\"platform:rtc-pm8xxx\");\nMODULE_DESCRIPTION(\"PMIC8xxx RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Anirudh Ghayal <aghayal@codeaurora.org>\");\nMODULE_AUTHOR(\"Johan Hovold <johan@kernel.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}