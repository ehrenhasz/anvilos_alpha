{
  "module_name": "rtc-stmp3xxx.c",
  "hash_id": "f4e8645e6ae276f1fdda9c42d729bcd29ce94c070103aea557d25bd90528a015",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-stmp3xxx.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/stmp_device.h>\n#include <linux/stmp3xxx_rtc_wdt.h>\n\n#define STMP3XXX_RTC_CTRL\t\t\t0x0\n#define STMP3XXX_RTC_CTRL_ALARM_IRQ_EN\t\t0x00000001\n#define STMP3XXX_RTC_CTRL_ONEMSEC_IRQ_EN\t0x00000002\n#define STMP3XXX_RTC_CTRL_ALARM_IRQ\t\t0x00000004\n#define STMP3XXX_RTC_CTRL_WATCHDOGEN\t\t0x00000010\n\n#define STMP3XXX_RTC_STAT\t\t\t0x10\n#define STMP3XXX_RTC_STAT_STALE_SHIFT\t\t16\n#define STMP3XXX_RTC_STAT_RTC_PRESENT\t\t0x80000000\n#define STMP3XXX_RTC_STAT_XTAL32000_PRESENT\t0x10000000\n#define STMP3XXX_RTC_STAT_XTAL32768_PRESENT\t0x08000000\n\n#define STMP3XXX_RTC_SECONDS\t\t\t0x30\n\n#define STMP3XXX_RTC_ALARM\t\t\t0x40\n\n#define STMP3XXX_RTC_WATCHDOG\t\t\t0x50\n\n#define STMP3XXX_RTC_PERSISTENT0\t\t0x60\n#define STMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE\t\t(1 << 0)\n#define STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN\t\t(1 << 1)\n#define STMP3XXX_RTC_PERSISTENT0_ALARM_EN\t\t(1 << 2)\n#define STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP\t(1 << 4)\n#define STMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP\t(1 << 5)\n#define STMP3XXX_RTC_PERSISTENT0_XTAL32_FREQ\t\t(1 << 6)\n#define STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE\t\t(1 << 7)\n\n#define STMP3XXX_RTC_PERSISTENT1\t\t0x70\n \n#define STMP3XXX_RTC_PERSISTENT1_FORCE_UPDATER\t0x80000000\n\nstruct stmp3xxx_rtc_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *io;\n\tint irq_alarm;\n};\n\n#if IS_ENABLED(CONFIG_STMP3XXX_RTC_WATCHDOG)\n \n\nstatic void stmp3xxx_wdt_set_timeout(struct device *dev, u32 timeout)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tif (timeout) {\n\t\twritel(timeout, rtc_data->io + STMP3XXX_RTC_WATCHDOG);\n\t\twritel(STMP3XXX_RTC_CTRL_WATCHDOGEN,\n\t\t       rtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_SET);\n\t\twritel(STMP3XXX_RTC_PERSISTENT1_FORCE_UPDATER,\n\t\t       rtc_data->io + STMP3XXX_RTC_PERSISTENT1 + STMP_OFFSET_REG_SET);\n\t} else {\n\t\twritel(STMP3XXX_RTC_CTRL_WATCHDOGEN,\n\t\t       rtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\n\t\twritel(STMP3XXX_RTC_PERSISTENT1_FORCE_UPDATER,\n\t\t       rtc_data->io + STMP3XXX_RTC_PERSISTENT1 + STMP_OFFSET_REG_CLR);\n\t}\n}\n\nstatic struct stmp3xxx_wdt_pdata wdt_pdata = {\n\t.wdt_set_timeout = stmp3xxx_wdt_set_timeout,\n};\n\nstatic void stmp3xxx_wdt_register(struct platform_device *rtc_pdev)\n{\n\tint rc = -1;\n\tstruct platform_device *wdt_pdev =\n\t\tplatform_device_alloc(\"stmp3xxx_rtc_wdt\", rtc_pdev->id);\n\n\tif (wdt_pdev) {\n\t\twdt_pdev->dev.parent = &rtc_pdev->dev;\n\t\twdt_pdev->dev.platform_data = &wdt_pdata;\n\t\trc = platform_device_add(wdt_pdev);\n\t\tif (rc)\n\t\t\tplatform_device_put(wdt_pdev);\n\t}\n\n\tif (rc)\n\t\tdev_err(&rtc_pdev->dev,\n\t\t\t\"failed to register stmp3xxx_rtc_wdt\\n\");\n}\n#else\nstatic void stmp3xxx_wdt_register(struct platform_device *rtc_pdev)\n{\n}\n#endif  \n\nstatic int stmp3xxx_wait_time(struct stmp3xxx_rtc_data *rtc_data)\n{\n\tint timeout = 5000;  \n\t \n\tdo {\n\t\tif (!(readl(rtc_data->io + STMP3XXX_RTC_STAT) &\n\t\t\t\t(0x80 << STMP3XXX_RTC_STAT_STALE_SHIFT)))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t} while (--timeout > 0);\n\treturn (readl(rtc_data->io + STMP3XXX_RTC_STAT) &\n\t\t(0x80 << STMP3XXX_RTC_STAT_STALE_SHIFT)) ? -ETIME : 0;\n}\n\n \nstatic int stmp3xxx_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tint ret;\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tret = stmp3xxx_wait_time(rtc_data);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_time64_to_tm(readl(rtc_data->io + STMP3XXX_RTC_SECONDS), rtc_tm);\n\treturn 0;\n}\n\nstatic int stmp3xxx_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(rtc_tm), rtc_data->io + STMP3XXX_RTC_SECONDS);\n\treturn stmp3xxx_wait_time(rtc_data);\n}\n\n \nstatic irqreturn_t stmp3xxx_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev_id);\n\tu32 status = readl(rtc_data->io + STMP3XXX_RTC_CTRL);\n\n\tif (status & STMP3XXX_RTC_CTRL_ALARM_IRQ) {\n\t\twritel(STMP3XXX_RTC_CTRL_ALARM_IRQ,\n\t\t\trtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\n\t\trtc_update_irq(rtc_data->rtc, 1, RTC_AF | RTC_IRQF);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int stmp3xxx_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tif (enabled) {\n\t\twritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\n\t\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN,\n\t\t\trtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\n\t\t\t\tSTMP_OFFSET_REG_SET);\n\t\twritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\n\t\t\trtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_SET);\n\t} else {\n\t\twritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\n\t\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN,\n\t\t\trtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\n\t\t\t\tSTMP_OFFSET_REG_CLR);\n\t\twritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\n\t\t\trtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\n\t}\n\treturn 0;\n}\n\nstatic int stmp3xxx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(rtc_data->io + STMP3XXX_RTC_ALARM), &alm->time);\n\treturn 0;\n}\n\nstatic int stmp3xxx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(&alm->time), rtc_data->io + STMP3XXX_RTC_ALARM);\n\n\tstmp3xxx_alarm_irq_enable(dev, alm->enabled);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops stmp3xxx_rtc_ops = {\n\t.alarm_irq_enable =\n\t\t\t  stmp3xxx_alarm_irq_enable,\n\t.read_time\t= stmp3xxx_rtc_gettime,\n\t.set_time\t= stmp3xxx_rtc_settime,\n\t.read_alarm\t= stmp3xxx_rtc_read_alarm,\n\t.set_alarm\t= stmp3xxx_rtc_set_alarm,\n};\n\nstatic void stmp3xxx_rtc_remove(struct platform_device *pdev)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = platform_get_drvdata(pdev);\n\n\tif (!rtc_data)\n\t\treturn;\n\n\twritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\n\t\trtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\n}\n\nstatic int stmp3xxx_rtc_probe(struct platform_device *pdev)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data;\n\tstruct resource *r;\n\tu32 rtc_stat;\n\tu32 pers0_set, pers0_clr;\n\tu32 crystalfreq = 0;\n\tint err;\n\n\trtc_data = devm_kzalloc(&pdev->dev, sizeof(*rtc_data), GFP_KERNEL);\n\tif (!rtc_data)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"failed to get resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\trtc_data->io = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!rtc_data->io) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\trtc_data->irq_alarm = platform_get_irq(pdev, 0);\n\n\trtc_stat = readl(rtc_data->io + STMP3XXX_RTC_STAT);\n\tif (!(rtc_stat & STMP3XXX_RTC_STAT_RTC_PRESENT)) {\n\t\tdev_err(&pdev->dev, \"no device onboard\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform_set_drvdata(pdev, rtc_data);\n\n\t \n\tif (readl(rtc_data->io + STMP3XXX_RTC_CTRL) &\n\t    STMP3XXX_RTC_CTRL_WATCHDOGEN) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Watchdog is running, skip resetting rtc\\n\");\n\t} else {\n\t\terr = stmp_reset_block(rtc_data->io);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"stmp_reset_block failed: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (rtc_stat & STMP3XXX_RTC_STAT_XTAL32000_PRESENT)\n\t\tcrystalfreq = 32000;\n\telse if (rtc_stat & STMP3XXX_RTC_STAT_XTAL32768_PRESENT)\n\t\tcrystalfreq = 32768;\n\n\tof_property_read_u32(pdev->dev.of_node, \"stmp,crystal-freq\",\n\t\t\t     &crystalfreq);\n\n\tswitch (crystalfreq) {\n\tcase 32000:\n\t\t \n\t\tpers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL32_FREQ |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\n\t\tpers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP;\n\t\tbreak;\n\tcase 32768:\n\t\t \n\t\tpers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\n\t\tpers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_XTAL32_FREQ;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"invalid crystal-freq specified in device-tree. Assuming no crystal\\n\");\n\t\tfallthrough;\n\tcase 0:\n\t\t \n\t\tpers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP;\n\t\tpers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\n\t}\n\n\twritel(pers0_set, rtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\n\t\t\tSTMP_OFFSET_REG_SET);\n\n\twritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE | pers0_clr,\n\t\trtc_data->io + STMP3XXX_RTC_PERSISTENT0 + STMP_OFFSET_REG_CLR);\n\n\twritel(STMP3XXX_RTC_CTRL_ONEMSEC_IRQ_EN |\n\t\t\tSTMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\n\t\trtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\n\n\trtc_data->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc_data->rtc))\n\t\treturn PTR_ERR(rtc_data->rtc);\n\n\terr = devm_request_irq(&pdev->dev, rtc_data->irq_alarm,\n\t\t\tstmp3xxx_rtc_interrupt, 0, \"RTC alarm\", &pdev->dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot claim IRQ%d\\n\",\n\t\t\trtc_data->irq_alarm);\n\t\treturn err;\n\t}\n\n\trtc_data->rtc->ops = &stmp3xxx_rtc_ops;\n\trtc_data->rtc->range_max = U32_MAX;\n\n\terr = devm_rtc_register_device(rtc_data->rtc);\n\tif (err)\n\t\treturn err;\n\n\tstmp3xxx_wdt_register(pdev);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stmp3xxx_rtc_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int stmp3xxx_rtc_resume(struct device *dev)\n{\n\tstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tstmp_reset_block(rtc_data->io);\n\twritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |\n\t\t\tSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE,\n\t\trtc_data->io + STMP3XXX_RTC_PERSISTENT0 + STMP_OFFSET_REG_CLR);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(stmp3xxx_rtc_pm_ops, stmp3xxx_rtc_suspend,\n\t\t\tstmp3xxx_rtc_resume);\n\nstatic const struct of_device_id rtc_dt_ids[] = {\n\t{ .compatible = \"fsl,stmp3xxx-rtc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rtc_dt_ids);\n\nstatic struct platform_driver stmp3xxx_rtcdrv = {\n\t.probe\t\t= stmp3xxx_rtc_probe,\n\t.remove_new\t= stmp3xxx_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"stmp3xxx-rtc\",\n\t\t.pm\t= &stmp3xxx_rtc_pm_ops,\n\t\t.of_match_table = rtc_dt_ids,\n\t},\n};\n\nmodule_platform_driver(stmp3xxx_rtcdrv);\n\nMODULE_DESCRIPTION(\"STMP3xxx RTC Driver\");\nMODULE_AUTHOR(\"dmitry pervushin <dpervushin@embeddedalley.com> and \"\n\t\t\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}