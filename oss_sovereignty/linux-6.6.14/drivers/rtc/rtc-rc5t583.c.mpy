{
  "module_name": "rtc-rc5t583.c",
  "hash_id": "dcb2b05680186a0139bc01ff235744e0a19be4b323fcb1292d47fb5e5d7e49f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rc5t583.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/rc5t583.h>\n\nstruct rc5t583_rtc {\n\tstruct rtc_device\t*rtc;\n\t \n\tu32 irqen;\n};\n\n \n#define NUM_TIME_REGS\t(RC5T583_RTC_YEAR - RC5T583_RTC_SEC + 1)\n\n \n#define NUM_YAL_REGS\t(RC5T583_RTC_AY_YEAR - RC5T583_RTC_AY_MIN + 1)\n\n \n#define SET_YAL BIT(5)\n\n \n#define GET_YAL_STATUS BIT(3)\n\nstatic int rc5t583_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tu8 val;\n\n\t \n\tval = enabled ? SET_YAL : 0;\n\n\treturn regmap_update_bits(rc5t583->regmap, RC5T583_RTC_CTL1, SET_YAL,\n\t\tval);\n}\n\n \nstatic int rc5t583_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tu8 rtc_data[NUM_TIME_REGS];\n\tint ret;\n\n\tret = regmap_bulk_read(rc5t583->regmap, RC5T583_RTC_SEC, rtc_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC read time failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec = bcd2bin(rtc_data[0]);\n\ttm->tm_min = bcd2bin(rtc_data[1]);\n\ttm->tm_hour = bcd2bin(rtc_data[2]);\n\ttm->tm_wday = bcd2bin(rtc_data[3]);\n\ttm->tm_mday = bcd2bin(rtc_data[4]);\n\ttm->tm_mon = bcd2bin(rtc_data[5]) - 1;\n\ttm->tm_year = bcd2bin(rtc_data[6]) + 100;\n\n\treturn ret;\n}\n\nstatic int rc5t583_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tunsigned char rtc_data[NUM_TIME_REGS];\n\tint ret;\n\n\trtc_data[0] = bin2bcd(tm->tm_sec);\n\trtc_data[1] = bin2bcd(tm->tm_min);\n\trtc_data[2] = bin2bcd(tm->tm_hour);\n\trtc_data[3] = bin2bcd(tm->tm_wday);\n\trtc_data[4] = bin2bcd(tm->tm_mday);\n\trtc_data[5] = bin2bcd(tm->tm_mon + 1);\n\trtc_data[6] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(rc5t583->regmap, RC5T583_RTC_SEC, rtc_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC set time failed with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rc5t583_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tunsigned char alarm_data[NUM_YAL_REGS];\n\tu32 interrupt_enable;\n\tint ret;\n\n\tret = regmap_bulk_read(rc5t583->regmap, RC5T583_RTC_AY_MIN, alarm_data,\n\t\tNUM_YAL_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_read_alarm error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talm->time.tm_sec = 0;\n\talm->time.tm_min = bcd2bin(alarm_data[0]);\n\talm->time.tm_hour = bcd2bin(alarm_data[1]);\n\talm->time.tm_mday = bcd2bin(alarm_data[2]);\n\talm->time.tm_mon = bcd2bin(alarm_data[3]) - 1;\n\talm->time.tm_year = bcd2bin(alarm_data[4]) + 100;\n\n\tret = regmap_read(rc5t583->regmap, RC5T583_RTC_CTL1, &interrupt_enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (interrupt_enable & SET_YAL)\n\t\talm->enabled = 1;\n\n\treturn ret;\n}\n\nstatic int rc5t583_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tunsigned char alarm_data[NUM_YAL_REGS];\n\tint ret;\n\n\tret = rc5t583_rtc_alarm_irq_enable(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\talarm_data[0] = bin2bcd(alm->time.tm_min);\n\talarm_data[1] = bin2bcd(alm->time.tm_hour);\n\talarm_data[2] = bin2bcd(alm->time.tm_mday);\n\talarm_data[3] = bin2bcd(alm->time.tm_mon + 1);\n\talarm_data[4] = bin2bcd(alm->time.tm_year - 100);\n\n\tret = regmap_bulk_write(rc5t583->regmap, RC5T583_RTC_AY_MIN, alarm_data,\n\t\tNUM_YAL_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"rtc_set_alarm error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (alm->enabled)\n\t\tret = rc5t583_rtc_alarm_irq_enable(dev, 1);\n\n\treturn ret;\n}\n\nstatic irqreturn_t rc5t583_rtc_interrupt(int irq, void *rtc)\n{\n\tstruct device *dev = rtc;\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tstruct rc5t583_rtc *rc5t583_rtc = dev_get_drvdata(dev);\n\tunsigned long events = 0;\n\tint ret;\n\tu32 rtc_reg;\n\n\tret = regmap_read(rc5t583->regmap, RC5T583_RTC_CTL2, &rtc_reg);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tif (rtc_reg & GET_YAL_STATUS) {\n\t\tevents = RTC_IRQF | RTC_AF;\n\t\t \n\t\trtc_reg &= ~GET_YAL_STATUS;\n\t}\n\n\tret = regmap_write(rc5t583->regmap, RC5T583_RTC_CTL2, rtc_reg);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\trtc_update_irq(rc5t583_rtc->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops rc5t583_rtc_ops = {\n\t.read_time\t= rc5t583_rtc_read_time,\n\t.set_time\t= rc5t583_rtc_set_time,\n\t.read_alarm\t= rc5t583_rtc_read_alarm,\n\t.set_alarm\t= rc5t583_rtc_set_alarm,\n\t.alarm_irq_enable = rc5t583_rtc_alarm_irq_enable,\n};\n\nstatic int rc5t583_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);\n\tstruct rc5t583_rtc *ricoh_rtc;\n\tstruct rc5t583_platform_data *pmic_plat_data;\n\tint ret;\n\tint irq;\n\n\tricoh_rtc = devm_kzalloc(&pdev->dev, sizeof(struct rc5t583_rtc),\n\t\t\tGFP_KERNEL);\n\tif (!ricoh_rtc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ricoh_rtc);\n\n\t \n\tret = regmap_write(rc5t583->regmap, RC5T583_RTC_CTL2, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(rc5t583->regmap, RC5T583_RTC_ADJ, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to program rtc_adjust reg\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpmic_plat_data = dev_get_platdata(rc5t583->dev);\n\tirq = pmic_plat_data->irq_base;\n\tif (irq <= 0) {\n\t\tdev_warn(&pdev->dev, \"Wake up is not possible as irq = %d\\n\",\n\t\t\tirq);\n\t\treturn ret;\n\t}\n\n\tirq += RC5T583_IRQ_YALE;\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\trc5t583_rtc_interrupt, IRQF_TRIGGER_LOW,\n\t\t\"rtc-rc5t583\", &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"IRQ is not free.\\n\");\n\t\treturn ret;\n\t}\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tricoh_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t&rc5t583_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(ricoh_rtc->rtc)) {\n\t\tret = PTR_ERR(ricoh_rtc->rtc);\n\t\tdev_err(&pdev->dev, \"RTC device register: err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rc5t583_rtc_remove(struct platform_device *pdev)\n{\n\tstruct rc5t583_rtc *rc5t583_rtc = platform_get_drvdata(pdev);\n\n\trc5t583_rtc_alarm_irq_enable(&rc5t583_rtc->rtc->dev, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rc5t583_rtc_suspend(struct device *dev)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tstruct rc5t583_rtc *rc5t583_rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regmap_read(rc5t583->regmap, RC5T583_RTC_CTL1,\n\t\t&rc5t583_rtc->irqen);\n\treturn ret;\n}\n\nstatic int rc5t583_rtc_resume(struct device *dev)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);\n\tstruct rc5t583_rtc *rc5t583_rtc = dev_get_drvdata(dev);\n\n\t \n\treturn regmap_write(rc5t583->regmap, RC5T583_RTC_CTL1,\n\t\trc5t583_rtc->irqen);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(rc5t583_rtc_pm_ops, rc5t583_rtc_suspend,\n\t\t\trc5t583_rtc_resume);\n\nstatic struct platform_driver rc5t583_rtc_driver = {\n\t.probe\t\t= rc5t583_rtc_probe,\n\t.remove_new\t= rc5t583_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-rc5t583\",\n\t\t.pm\t= &rc5t583_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rc5t583_rtc_driver);\nMODULE_ALIAS(\"platform:rtc-rc5t583\");\nMODULE_AUTHOR(\"Venu Byravarasu <vbyravarasu@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}