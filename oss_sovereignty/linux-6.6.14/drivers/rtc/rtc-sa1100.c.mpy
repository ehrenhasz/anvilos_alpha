{
  "module_name": "rtc-sa1100.c",
  "hash_id": "81b5d9949b912386347ce11b627eadff97e5e9531c91643a2d27c86f03c7ed18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sa1100.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n\n#define RTSR_HZE\t\tBIT(3)\t \n#define RTSR_ALE\t\tBIT(2)\t \n#define RTSR_HZ\t\t\tBIT(1)\t \n#define RTSR_AL\t\t\tBIT(0)\t \n\n#include \"rtc-sa1100.h\"\n\n#define RTC_DEF_DIVIDER\t\t(32768 - 1)\n#define RTC_DEF_TRIM\t\t0\n#define RTC_FREQ\t\t1024\n\n\nstatic irqreturn_t sa1100_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev_id);\n\tstruct rtc_device *rtc = info->rtc;\n\tunsigned int rtsr;\n\tunsigned long events = 0;\n\n\tspin_lock(&info->lock);\n\n\trtsr = readl_relaxed(info->rtsr);\n\t \n\twritel_relaxed(0, info->rtsr);\n\t \n\tif (rtsr & (RTSR_ALE | RTSR_HZE)) {\n\t\t \n\t\twritel_relaxed((RTSR_AL | RTSR_HZ) & (rtsr >> 2), info->rtsr);\n\t} else {\n\t\t \n\t\twritel_relaxed(RTSR_AL | RTSR_HZ, info->rtsr);\n\t}\n\n\t \n\tif (rtsr & RTSR_AL)\n\t\trtsr &= ~RTSR_ALE;\n\twritel_relaxed(rtsr & (RTSR_ALE | RTSR_HZE), info->rtsr);\n\n\t \n\tif (rtsr & RTSR_AL)\n\t\tevents |= RTC_AF | RTC_IRQF;\n\tif (rtsr & RTSR_HZ)\n\t\tevents |= RTC_UF | RTC_IRQF;\n\n\trtc_update_irq(rtc, 1, events);\n\n\tspin_unlock(&info->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sa1100_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tu32 rtsr;\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&info->lock);\n\trtsr = readl_relaxed(info->rtsr);\n\tif (enabled)\n\t\trtsr |= RTSR_ALE;\n\telse\n\t\trtsr &= ~RTSR_ALE;\n\twritel_relaxed(rtsr, info->rtsr);\n\tspin_unlock_irq(&info->lock);\n\treturn 0;\n}\n\nstatic int sa1100_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl_relaxed(info->rcnr), tm);\n\treturn 0;\n}\n\nstatic int sa1100_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\twritel_relaxed(rtc_tm_to_time64(tm), info->rcnr);\n\n\treturn 0;\n}\n\nstatic int sa1100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tu32\trtsr;\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\trtsr = readl_relaxed(info->rtsr);\n\talrm->enabled = (rtsr & RTSR_ALE) ? 1 : 0;\n\talrm->pending = (rtsr & RTSR_AL) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int sa1100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&info->lock);\n\twritel_relaxed(readl_relaxed(info->rtsr) &\n\t\t(RTSR_HZE | RTSR_ALE | RTSR_AL), info->rtsr);\n\twritel_relaxed(rtc_tm_to_time64(&alrm->time), info->rtar);\n\tif (alrm->enabled)\n\t\twritel_relaxed(readl_relaxed(info->rtsr) | RTSR_ALE, info->rtsr);\n\telse\n\t\twritel_relaxed(readl_relaxed(info->rtsr) & ~RTSR_ALE, info->rtsr);\n\tspin_unlock_irq(&info->lock);\n\n\treturn 0;\n}\n\nstatic int sa1100_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\n\tseq_printf(seq, \"trim/divider\\t\\t: 0x%08x\\n\", readl_relaxed(info->rttr));\n\tseq_printf(seq, \"RTSR\\t\\t\\t: 0x%08x\\n\", readl_relaxed(info->rtsr));\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sa1100_rtc_ops = {\n\t.read_time = sa1100_rtc_read_time,\n\t.set_time = sa1100_rtc_set_time,\n\t.read_alarm = sa1100_rtc_read_alarm,\n\t.set_alarm = sa1100_rtc_set_alarm,\n\t.proc = sa1100_rtc_proc,\n\t.alarm_irq_enable = sa1100_rtc_alarm_irq_enable,\n};\n\nint sa1100_rtc_init(struct platform_device *pdev, struct sa1100_rtc *info)\n{\n\tint ret;\n\n\tspin_lock_init(&info->lock);\n\n\tinfo->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(info->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to find rtc clock source\\n\");\n\t\treturn PTR_ERR(info->clk);\n\t}\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (readl_relaxed(info->rttr) == 0) {\n\t\twritel_relaxed(RTC_DEF_DIVIDER + (RTC_DEF_TRIM << 16), info->rttr);\n\t\tdev_warn(&pdev->dev, \"warning: \"\n\t\t\t\"initializing default clock divider/trim value\\n\");\n\t\t \n\t\twritel_relaxed(0, info->rcnr);\n\t}\n\n\tinfo->rtc->ops = &sa1100_rtc_ops;\n\tinfo->rtc->max_user_freq = RTC_FREQ;\n\tinfo->rtc->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(info->rtc);\n\tif (ret) {\n\t\tclk_disable_unprepare(info->clk);\n\t\treturn ret;\n\t}\n\n\t \n\twritel_relaxed(RTSR_AL | RTSR_HZ, info->rtsr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sa1100_rtc_init);\n\nstatic int sa1100_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sa1100_rtc *info;\n\tvoid __iomem *base;\n\tint irq_1hz, irq_alarm;\n\tint ret;\n\n\tirq_1hz = platform_get_irq_byname(pdev, \"rtc 1Hz\");\n\tirq_alarm = platform_get_irq_byname(pdev, \"rtc alarm\");\n\tif (irq_1hz < 0 || irq_alarm < 0)\n\t\treturn -ENODEV;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct sa1100_rtc), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->irq_1hz = irq_1hz;\n\tinfo->irq_alarm = irq_alarm;\n\n\tinfo->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc))\n\t\treturn PTR_ERR(info->rtc);\n\n\tret = devm_request_irq(&pdev->dev, irq_1hz, sa1100_rtc_interrupt, 0,\n\t\t\t       \"rtc 1Hz\", &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ %d already in use.\\n\", irq_1hz);\n\t\treturn ret;\n\t}\n\tret = devm_request_irq(&pdev->dev, irq_alarm, sa1100_rtc_interrupt, 0,\n\t\t\t       \"rtc Alrm\", &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ %d already in use.\\n\", irq_alarm);\n\t\treturn ret;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (IS_ENABLED(CONFIG_ARCH_SA1100) ||\n\t    of_device_is_compatible(pdev->dev.of_node, \"mrvl,sa1100-rtc\")) {\n\t\tinfo->rcnr = base + 0x04;\n\t\tinfo->rtsr = base + 0x10;\n\t\tinfo->rtar = base + 0x00;\n\t\tinfo->rttr = base + 0x08;\n\t} else {\n\t\tinfo->rcnr = base + 0x0;\n\t\tinfo->rtsr = base + 0x8;\n\t\tinfo->rtar = base + 0x4;\n\t\tinfo->rttr = base + 0xc;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn sa1100_rtc_init(pdev, info);\n}\n\nstatic void sa1100_rtc_remove(struct platform_device *pdev)\n{\n\tstruct sa1100_rtc *info = platform_get_drvdata(pdev);\n\n\tif (info) {\n\t\tspin_lock_irq(&info->lock);\n\t\twritel_relaxed(0, info->rtsr);\n\t\tspin_unlock_irq(&info->lock);\n\t\tclk_disable_unprepare(info->clk);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sa1100_rtc_suspend(struct device *dev)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(info->irq_alarm);\n\treturn 0;\n}\n\nstatic int sa1100_rtc_resume(struct device *dev)\n{\n\tstruct sa1100_rtc *info = dev_get_drvdata(dev);\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(info->irq_alarm);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sa1100_rtc_pm_ops, sa1100_rtc_suspend,\n\t\t\tsa1100_rtc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sa1100_rtc_dt_ids[] = {\n\t{ .compatible = \"mrvl,sa1100-rtc\", },\n\t{ .compatible = \"mrvl,mmp-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sa1100_rtc_dt_ids);\n#endif\n\nstatic struct platform_driver sa1100_rtc_driver = {\n\t.probe\t\t= sa1100_rtc_probe,\n\t.remove_new\t= sa1100_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sa1100-rtc\",\n\t\t.pm\t= &sa1100_rtc_pm_ops,\n\t\t.of_match_table = of_match_ptr(sa1100_rtc_dt_ids),\n\t},\n};\n\nmodule_platform_driver(sa1100_rtc_driver);\n\nMODULE_AUTHOR(\"Richard Purdie <rpurdie@rpsys.net>\");\nMODULE_DESCRIPTION(\"SA11x0/PXA2xx Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sa1100-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}