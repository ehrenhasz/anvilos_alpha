{
  "module_name": "rtc-max6900.c",
  "hash_id": "914a1f9ab4f2dc59cee861a856f9fdedb58173780f195e0f83bcce3ebbf4a738",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-max6900.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n\n \n#define MAX6900_REG_SC\t\t\t0\t \n#define MAX6900_REG_MN\t\t\t1\t \n#define MAX6900_REG_HR\t\t\t2\t \n#define MAX6900_REG_DT\t\t\t3\t \n#define MAX6900_REG_MO\t\t\t4\t \n#define MAX6900_REG_DW\t\t\t5\t \n#define MAX6900_REG_YR\t\t\t6\t \n#define MAX6900_REG_CT\t\t\t7\t \n\t\t\t\t\t\t \n#define MAX6900_REG_CENTURY\t\t9\t \n#define MAX6900_REG_LEN\t\t\t10\n\n#define MAX6900_BURST_LEN\t\t8\t \n\n#define MAX6900_REG_CT_WP\t\t(1 << 7)\t \n\n \n#define MAX6900_REG_CONTROL_WRITE\t0x8e\n#define MAX6900_REG_CENTURY_WRITE\t0x92\n#define MAX6900_REG_CENTURY_READ\t0x93\n#define MAX6900_REG_RESERVED_READ\t0x96\n#define MAX6900_REG_BURST_WRITE\t\t0xbe\n#define MAX6900_REG_BURST_READ\t\t0xbf\n\n#define MAX6900_IDLE_TIME_AFTER_WRITE\t3\t \n\nstatic struct i2c_driver max6900_driver;\n\nstatic int max6900_i2c_read_regs(struct i2c_client *client, u8 *buf)\n{\n\tu8 reg_burst_read[1] = { MAX6900_REG_BURST_READ };\n\tu8 reg_century_read[1] = { MAX6900_REG_CENTURY_READ };\n\tstruct i2c_msg msgs[4] = {\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = 0,\t \n\t\t .len = sizeof(reg_burst_read),\n\t\t .buf = reg_burst_read}\n\t\t,\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = I2C_M_RD,\n\t\t .len = MAX6900_BURST_LEN,\n\t\t .buf = buf}\n\t\t,\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = 0,\t \n\t\t .len = sizeof(reg_century_read),\n\t\t .buf = reg_century_read}\n\t\t,\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = I2C_M_RD,\n\t\t .len = sizeof(buf[MAX6900_REG_CENTURY]),\n\t\t .buf = &buf[MAX6900_REG_CENTURY]\n\t\t }\n\t};\n\tint rc;\n\n\trc = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (rc != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, \"%s: register read failed\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int max6900_i2c_write_regs(struct i2c_client *client, u8 const *buf)\n{\n\tu8 i2c_century_buf[1 + 1] = { MAX6900_REG_CENTURY_WRITE };\n\tstruct i2c_msg century_msgs[1] = {\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = 0,\t \n\t\t .len = sizeof(i2c_century_buf),\n\t\t .buf = i2c_century_buf}\n\t};\n\tu8 i2c_burst_buf[MAX6900_BURST_LEN + 1] = { MAX6900_REG_BURST_WRITE };\n\tstruct i2c_msg burst_msgs[1] = {\n\t\t{\n\t\t .addr = client->addr,\n\t\t .flags = 0,\t \n\t\t .len = sizeof(i2c_burst_buf),\n\t\t .buf = i2c_burst_buf}\n\t};\n\tint rc;\n\n\t \n\ti2c_century_buf[1] = buf[MAX6900_REG_CENTURY];\n\n\trc = i2c_transfer(client->adapter, century_msgs,\n\t\t\t  ARRAY_SIZE(century_msgs));\n\tif (rc != ARRAY_SIZE(century_msgs))\n\t\tgoto write_failed;\n\n\tmsleep(MAX6900_IDLE_TIME_AFTER_WRITE);\n\n\tmemcpy(&i2c_burst_buf[1], buf, MAX6900_BURST_LEN);\n\n\trc = i2c_transfer(client->adapter, burst_msgs, ARRAY_SIZE(burst_msgs));\n\tif (rc != ARRAY_SIZE(burst_msgs))\n\t\tgoto write_failed;\n\tmsleep(MAX6900_IDLE_TIME_AFTER_WRITE);\n\n\treturn 0;\n\n write_failed:\n\tdev_err(&client->dev, \"%s: register write failed\\n\", __func__);\n\treturn -EIO;\n}\n\nstatic int max6900_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint rc;\n\tu8 regs[MAX6900_REG_LEN];\n\n\trc = max6900_i2c_read_regs(client, regs);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttm->tm_sec = bcd2bin(regs[MAX6900_REG_SC]);\n\ttm->tm_min = bcd2bin(regs[MAX6900_REG_MN]);\n\ttm->tm_hour = bcd2bin(regs[MAX6900_REG_HR] & 0x3f);\n\ttm->tm_mday = bcd2bin(regs[MAX6900_REG_DT]);\n\ttm->tm_mon = bcd2bin(regs[MAX6900_REG_MO]) - 1;\n\ttm->tm_year = bcd2bin(regs[MAX6900_REG_YR]) +\n\t\t      bcd2bin(regs[MAX6900_REG_CENTURY]) * 100 - 1900;\n\ttm->tm_wday = bcd2bin(regs[MAX6900_REG_DW]);\n\n\treturn 0;\n}\n\nstatic int max6900_i2c_clear_write_protect(struct i2c_client *client)\n{\n\treturn i2c_smbus_write_byte_data(client, MAX6900_REG_CONTROL_WRITE, 0);\n}\n\nstatic int max6900_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 regs[MAX6900_REG_LEN];\n\tint rc;\n\n\trc = max6900_i2c_clear_write_protect(client);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tregs[MAX6900_REG_SC] = bin2bcd(tm->tm_sec);\n\tregs[MAX6900_REG_MN] = bin2bcd(tm->tm_min);\n\tregs[MAX6900_REG_HR] = bin2bcd(tm->tm_hour);\n\tregs[MAX6900_REG_DT] = bin2bcd(tm->tm_mday);\n\tregs[MAX6900_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\tregs[MAX6900_REG_DW] = bin2bcd(tm->tm_wday);\n\tregs[MAX6900_REG_YR] = bin2bcd(tm->tm_year % 100);\n\tregs[MAX6900_REG_CENTURY] = bin2bcd((tm->tm_year + 1900) / 100);\n\t \n\tregs[MAX6900_REG_CT] = MAX6900_REG_CT_WP;\n\n\trc = max6900_i2c_write_regs(client, regs);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops max6900_rtc_ops = {\n\t.read_time = max6900_rtc_read_time,\n\t.set_time = max6900_rtc_set_time,\n};\n\nstatic int max6900_probe(struct i2c_client *client)\n{\n\tstruct rtc_device *rtc;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\trtc = devm_rtc_device_register(&client->dev, max6900_driver.driver.name,\n\t\t\t\t\t&max6900_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\ti2c_set_clientdata(client, rtc);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max6900_id[] = {\n\t{ \"max6900\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max6900_id);\n\nstatic struct i2c_driver max6900_driver = {\n\t.driver = {\n\t\t   .name = \"rtc-max6900\",\n\t\t   },\n\t.probe = max6900_probe,\n\t.id_table = max6900_id,\n};\n\nmodule_i2c_driver(max6900_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX6900 RTC driver\");\nMODULE_AUTHOR(\"Dale Farnsworth <dale@farnsworth.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}