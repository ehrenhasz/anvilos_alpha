{
  "module_name": "rtc-da9055.c",
  "hash_id": "c7239d3882f4f89b96a3c5e4b2ffe6bb1a47d99bc055dad56b089d94fc7f4b48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-da9055.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n#include <linux/mfd/da9055/pdata.h>\n\nstruct da9055_rtc {\n\tstruct rtc_device *rtc;\n\tstruct da9055 *da9055;\n\tint alarm_enable;\n};\n\nstatic int da9055_rtc_enable_alarm(struct da9055_rtc *rtc, bool enable)\n{\n\tint ret;\n\tif (enable) {\n\t\tret = da9055_reg_update(rtc->da9055, DA9055_REG_ALARM_Y,\n\t\t\t\t\tDA9055_RTC_ALM_EN,\n\t\t\t\t\tDA9055_RTC_ALM_EN);\n\t\tif (ret != 0)\n\t\t\tdev_err(rtc->da9055->dev, \"Failed to enable ALM: %d\\n\",\n\t\t\t\tret);\n\t\trtc->alarm_enable = 1;\n\t} else {\n\t\tret = da9055_reg_update(rtc->da9055, DA9055_REG_ALARM_Y,\n\t\t\t\t\tDA9055_RTC_ALM_EN, 0);\n\t\tif (ret != 0)\n\t\t\tdev_err(rtc->da9055->dev,\n\t\t\t\t\"Failed to disable ALM: %d\\n\", ret);\n\t\trtc->alarm_enable = 0;\n\t}\n\treturn ret;\n}\n\nstatic irqreturn_t da9055_rtc_alm_irq(int irq, void *data)\n{\n\tstruct da9055_rtc *rtc = data;\n\n\tda9055_rtc_enable_alarm(rtc, 0);\n\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9055_read_alarm(struct da9055 *da9055, struct rtc_time *rtc_tm)\n{\n\tint ret;\n\tuint8_t v[5];\n\n\tret = da9055_group_read(da9055, DA9055_REG_ALARM_MI, 5, v);\n\tif (ret != 0) {\n\t\tdev_err(da9055->dev, \"Failed to group read ALM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtc_tm->tm_year = (v[4] & DA9055_RTC_ALM_YEAR) + 100;\n\trtc_tm->tm_mon  = (v[3] & DA9055_RTC_ALM_MONTH) - 1;\n\trtc_tm->tm_mday = v[2] & DA9055_RTC_ALM_DAY;\n\trtc_tm->tm_hour = v[1] & DA9055_RTC_ALM_HOUR;\n\trtc_tm->tm_min  = v[0] & DA9055_RTC_ALM_MIN;\n\trtc_tm->tm_sec = 0;\n\n\treturn rtc_valid_tm(rtc_tm);\n}\n\nstatic int da9055_set_alarm(struct da9055 *da9055, struct rtc_time *rtc_tm)\n{\n\tint ret;\n\tuint8_t v[2];\n\n\trtc_tm->tm_year -= 100;\n\trtc_tm->tm_mon += 1;\n\n\tret = da9055_reg_update(da9055, DA9055_REG_ALARM_MI,\n\t\t\t\tDA9055_RTC_ALM_MIN, rtc_tm->tm_min);\n\tif (ret != 0) {\n\t\tdev_err(da9055->dev, \"Failed to write ALRM MIN: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tv[0] = rtc_tm->tm_hour;\n\tv[1] = rtc_tm->tm_mday;\n\n\tret = da9055_group_write(da9055, DA9055_REG_ALARM_H, 2, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da9055_reg_update(da9055, DA9055_REG_ALARM_MO,\n\t\t\t\tDA9055_RTC_ALM_MONTH, rtc_tm->tm_mon);\n\tif (ret < 0)\n\t\tdev_err(da9055->dev, \"Failed to write ALM Month:%d\\n\", ret);\n\n\tret = da9055_reg_update(da9055, DA9055_REG_ALARM_Y,\n\t\t\t\tDA9055_RTC_ALM_YEAR, rtc_tm->tm_year);\n\tif (ret < 0)\n\t\tdev_err(da9055->dev, \"Failed to write ALM Year:%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int da9055_rtc_get_alarm_status(struct da9055 *da9055)\n{\n\tint ret;\n\n\tret = da9055_reg_read(da9055, DA9055_REG_ALARM_Y);\n\tif (ret < 0) {\n\t\tdev_err(da9055->dev, \"Failed to read ALM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret &= DA9055_RTC_ALM_EN;\n\treturn (ret > 0) ? 1 : 0;\n}\n\nstatic int da9055_rtc_read_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct da9055_rtc *rtc = dev_get_drvdata(dev);\n\tuint8_t v[6];\n\tint ret;\n\n\tret = da9055_reg_read(rtc->da9055, DA9055_REG_COUNT_S);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!(ret & DA9055_RTC_READ))\n\t\treturn -EBUSY;\n\n\tret = da9055_group_read(rtc->da9055, DA9055_REG_COUNT_S, 6, v);\n\tif (ret < 0) {\n\t\tdev_err(rtc->da9055->dev, \"Failed to read RTC time : %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trtc_tm->tm_year = (v[5] & DA9055_RTC_YEAR) + 100;\n\trtc_tm->tm_mon  = (v[4] & DA9055_RTC_MONTH) - 1;\n\trtc_tm->tm_mday = v[3] & DA9055_RTC_DAY;\n\trtc_tm->tm_hour = v[2] & DA9055_RTC_HOUR;\n\trtc_tm->tm_min  = v[1] & DA9055_RTC_MIN;\n\trtc_tm->tm_sec  = v[0] & DA9055_RTC_SEC;\n\n\treturn 0;\n}\n\nstatic int da9055_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct da9055_rtc *rtc;\n\tuint8_t v[6];\n\n\trtc = dev_get_drvdata(dev);\n\n\tv[0] = tm->tm_sec;\n\tv[1] = tm->tm_min;\n\tv[2] = tm->tm_hour;\n\tv[3] = tm->tm_mday;\n\tv[4] = tm->tm_mon + 1;\n\tv[5] = tm->tm_year - 100;\n\n\treturn da9055_group_write(rtc->da9055, DA9055_REG_COUNT_S, 6, v);\n}\n\nstatic int da9055_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tstruct rtc_time *tm = &alrm->time;\n\tstruct da9055_rtc *rtc = dev_get_drvdata(dev);\n\n\tret = da9055_read_alarm(rtc->da9055, tm);\n\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled = da9055_rtc_get_alarm_status(rtc->da9055);\n\n\treturn 0;\n}\n\nstatic int da9055_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tstruct rtc_time *tm = &alrm->time;\n\tstruct da9055_rtc *rtc = dev_get_drvdata(dev);\n\n\tret = da9055_rtc_enable_alarm(rtc, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = da9055_set_alarm(rtc->da9055, tm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da9055_rtc_enable_alarm(rtc, 1);\n\n\treturn ret;\n}\n\nstatic int da9055_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct da9055_rtc *rtc = dev_get_drvdata(dev);\n\n\treturn da9055_rtc_enable_alarm(rtc, enabled);\n}\n\nstatic const struct rtc_class_ops da9055_rtc_ops = {\n\t.read_time\t= da9055_rtc_read_time,\n\t.set_time\t= da9055_rtc_set_time,\n\t.read_alarm\t= da9055_rtc_read_alarm,\n\t.set_alarm\t= da9055_rtc_set_alarm,\n\t.alarm_irq_enable = da9055_rtc_alarm_irq_enable,\n};\n\nstatic int da9055_rtc_device_init(struct da9055 *da9055,\n\t\t\t\t\tstruct da9055_pdata *pdata)\n{\n\tint ret;\n\n\t \n\tret = da9055_reg_update(da9055, DA9055_REG_CONTROL_B,\n\t\t\t\tDA9055_RTC_EN, DA9055_RTC_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = da9055_reg_update(da9055, DA9055_REG_EN_32K,\n\t\t\t\tDA9055_CRYSTAL_EN, DA9055_CRYSTAL_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = da9055_reg_update(da9055, DA9055_REG_CONTROL_B,\n\t\t\t\tDA9055_RTC_MODE_PD, DA9055_RTC_MODE_PD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (pdata && pdata->reset_enable) {\n\t\tret = da9055_reg_update(da9055, DA9055_REG_CONTROL_B,\n\t\t\t\t\tDA9055_RTC_MODE_SD,\n\t\t\t\t\tDA9055_RTC_MODE_SD <<\n\t\t\t\t\tDA9055_RTC_MODE_SD_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = da9055_reg_update(da9055, DA9055_REG_ALARM_MO,\n\t\t\t\tDA9055_RTC_TICK_WAKE_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int da9055_rtc_probe(struct platform_device *pdev)\n{\n\tstruct da9055_rtc *rtc;\n\tstruct da9055_pdata *pdata = NULL;\n\tint ret, alm_irq;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(struct da9055_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->da9055 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(rtc->da9055->dev);\n\tplatform_set_drvdata(pdev, rtc);\n\n\tret = da9055_rtc_device_init(rtc->da9055, pdata);\n\tif (ret < 0)\n\t\tgoto err_rtc;\n\n\tret = da9055_reg_read(rtc->da9055, DA9055_REG_ALARM_Y);\n\tif (ret < 0)\n\t\tgoto err_rtc;\n\n\tif (ret & DA9055_RTC_ALM_EN)\n\t\trtc->alarm_enable = 1;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\trtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\t&da9055_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc->rtc)) {\n\t\tret = PTR_ERR(rtc->rtc);\n\t\tgoto err_rtc;\n\t}\n\n\talm_irq = platform_get_irq_byname(pdev, \"ALM\");\n\tif (alm_irq < 0)\n\t\treturn alm_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL,\n\t\t\t\t\tda9055_rtc_alm_irq,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"ALM\", rtc);\n\tif (ret != 0)\n\t\tdev_err(rtc->da9055->dev, \"irq registration failed: %d\\n\", ret);\n\nerr_rtc:\n\treturn ret;\n\n}\n\n#ifdef CONFIG_PM\n \nstatic int da9055_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);\n\tint ret;\n\n\tif (!device_may_wakeup(&pdev->dev)) {\n\t\t \n\t\tret = da9055_rtc_enable_alarm(rtc, 0);\n\t\tif (ret < 0)\n\t\t\tdev_err(&pdev->dev, \"Failed to disable RTC ALM\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int da9055_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);\n\tint ret;\n\n\tif (!device_may_wakeup(&pdev->dev)) {\n\t\tif (rtc->alarm_enable) {\n\t\t\tret = da9055_rtc_enable_alarm(rtc, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Failed to restart RTC ALM\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int da9055_rtc_freeze(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);\n\tint ret;\n\n\tret = da9055_rtc_enable_alarm(rtc, 0);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to freeze RTC ALMs\\n\");\n\n\treturn 0;\n\n}\n#else\n#define da9055_rtc_suspend NULL\n#define da9055_rtc_resume NULL\n#define da9055_rtc_freeze NULL\n#endif\n\nstatic const struct dev_pm_ops da9055_rtc_pm_ops = {\n\t.suspend = da9055_rtc_suspend,\n\t.resume = da9055_rtc_resume,\n\n\t.freeze = da9055_rtc_freeze,\n\t.thaw = da9055_rtc_resume,\n\t.restore = da9055_rtc_resume,\n\n\t.poweroff = da9055_rtc_suspend,\n};\n\nstatic struct platform_driver da9055_rtc_driver = {\n\t.probe  = da9055_rtc_probe,\n\t.driver = {\n\t\t.name   = \"da9055-rtc\",\n\t\t.pm = &da9055_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(da9055_rtc_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"RTC driver for Dialog DA9055 PMIC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}