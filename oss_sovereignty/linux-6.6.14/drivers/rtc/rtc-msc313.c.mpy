{
  "module_name": "rtc-msc313.c",
  "hash_id": "d5c44e95eec92d2a8fb16f1e66d05b5ddcf4e9a380e74fb1ef9be9eb1397af51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-msc313.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n \n#define REG_RTC_CTRL\t\t0x00\n#define REG_RTC_FREQ_CW_L\t0x04\n#define REG_RTC_FREQ_CW_H\t0x08\n#define REG_RTC_LOAD_VAL_L\t0x0C\n#define REG_RTC_LOAD_VAL_H\t0x10\n#define REG_RTC_MATCH_VAL_L\t0x14\n#define REG_RTC_MATCH_VAL_H\t0x18\n#define REG_RTC_STATUS_INT\t0x1C\n#define REG_RTC_CNT_VAL_L\t0x20\n#define REG_RTC_CNT_VAL_H\t0x24\n\n \n#define SOFT_RSTZ_BIT\t\tBIT(0)\n#define CNT_EN_BIT\t\tBIT(1)\n#define WRAP_EN_BIT\t\tBIT(2)\n#define LOAD_EN_BIT\t\tBIT(3)\n#define READ_EN_BIT\t\tBIT(4)\n#define INT_MASK_BIT\t\tBIT(5)\n#define INT_FORCE_BIT\t\tBIT(6)\n#define INT_CLEAR_BIT\t\tBIT(7)\n\n \n#define RAW_INT_BIT\t\tBIT(0)\n#define ALM_INT_BIT\t\tBIT(1)\n\nstruct msc313_rtc {\n\tstruct rtc_device *rtc_dev;\n\tvoid __iomem *rtc_base;\n};\n\nstatic int msc313_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev);\n\tunsigned long seconds;\n\n\tseconds = readw(priv->rtc_base + REG_RTC_MATCH_VAL_L)\n\t\t\t| ((unsigned long)readw(priv->rtc_base + REG_RTC_MATCH_VAL_H) << 16);\n\n\trtc_time64_to_tm(seconds, &alarm->time);\n\n\tif (!(readw(priv->rtc_base + REG_RTC_CTRL) & INT_MASK_BIT))\n\t\talarm->enabled = 1;\n\n\treturn 0;\n}\n\nstatic int msc313_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev);\n\tu16 reg;\n\n\treg = readw(priv->rtc_base + REG_RTC_CTRL);\n\tif (enabled)\n\t\treg &= ~INT_MASK_BIT;\n\telse\n\t\treg |= INT_MASK_BIT;\n\twritew(reg, priv->rtc_base + REG_RTC_CTRL);\n\treturn 0;\n}\n\nstatic int msc313_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev);\n\tunsigned long seconds;\n\n\tseconds = rtc_tm_to_time64(&alarm->time);\n\twritew((seconds & 0xFFFF), priv->rtc_base + REG_RTC_MATCH_VAL_L);\n\twritew((seconds >> 16) & 0xFFFF, priv->rtc_base + REG_RTC_MATCH_VAL_H);\n\n\tmsc313_rtc_alarm_irq_enable(dev, alarm->enabled);\n\n\treturn 0;\n}\n\nstatic bool msc313_rtc_get_enabled(struct msc313_rtc *priv)\n{\n\treturn readw(priv->rtc_base + REG_RTC_CTRL) & CNT_EN_BIT;\n}\n\nstatic void msc313_rtc_set_enabled(struct msc313_rtc *priv)\n{\n\tu16 reg;\n\n\treg = readw(priv->rtc_base + REG_RTC_CTRL);\n\treg |= CNT_EN_BIT;\n\twritew(reg, priv->rtc_base + REG_RTC_CTRL);\n}\n\nstatic int msc313_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev);\n\tu32 seconds;\n\tu16 reg;\n\n\tif (!msc313_rtc_get_enabled(priv))\n\t\treturn -EINVAL;\n\n\treg = readw(priv->rtc_base + REG_RTC_CTRL);\n\twritew(reg | READ_EN_BIT, priv->rtc_base + REG_RTC_CTRL);\n\n\t \n\twhile (readw(priv->rtc_base + REG_RTC_CTRL) & READ_EN_BIT)\n\t\tudelay(1);\n\n\tseconds = readw(priv->rtc_base + REG_RTC_CNT_VAL_L)\n\t\t\t| ((unsigned long)readw(priv->rtc_base + REG_RTC_CNT_VAL_H) << 16);\n\n\trtc_time64_to_tm(seconds, tm);\n\n\treturn 0;\n}\n\nstatic int msc313_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev);\n\tunsigned long seconds;\n\tu16 reg;\n\n\tseconds = rtc_tm_to_time64(tm);\n\twritew(seconds & 0xFFFF, priv->rtc_base + REG_RTC_LOAD_VAL_L);\n\twritew((seconds >> 16) & 0xFFFF, priv->rtc_base + REG_RTC_LOAD_VAL_H);\n\n\t \n\treg = readw(priv->rtc_base + REG_RTC_CTRL);\n\twritew(reg | LOAD_EN_BIT, priv->rtc_base + REG_RTC_CTRL);\n\n\t \n\twhile (readw(priv->rtc_base + REG_RTC_CTRL) & LOAD_EN_BIT)\n\t\tudelay(1);\n\tmsc313_rtc_set_enabled(priv);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops msc313_rtc_ops = {\n\t.read_time = msc313_rtc_read_time,\n\t.set_time = msc313_rtc_set_time,\n\t.read_alarm = msc313_rtc_read_alarm,\n\t.set_alarm = msc313_rtc_set_alarm,\n\t.alarm_irq_enable = msc313_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t msc313_rtc_interrupt(s32 irq, void *dev_id)\n{\n\tstruct msc313_rtc *priv = dev_get_drvdata(dev_id);\n\tu16 reg;\n\n\treg = readw(priv->rtc_base + REG_RTC_STATUS_INT);\n\tif (!(reg & ALM_INT_BIT))\n\t\treturn IRQ_NONE;\n\n\treg = readw(priv->rtc_base + REG_RTC_CTRL);\n\treg |= INT_CLEAR_BIT;\n\treg &= ~INT_FORCE_BIT;\n\twritew(reg, priv->rtc_base + REG_RTC_CTRL);\n\n\trtc_update_irq(priv->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int msc313_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct msc313_rtc *priv;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret;\n\tint irq;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct msc313_rtc), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->rtc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->rtc_base))\n\t\treturn PTR_ERR(priv->rtc_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tpriv->rtc_dev = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(priv->rtc_dev))\n\t\treturn PTR_ERR(priv->rtc_dev);\n\n\tpriv->rtc_dev->ops = &msc313_rtc_ops;\n\tpriv->rtc_dev->range_max = U32_MAX;\n\n\tret = devm_request_irq(dev, irq, msc313_rtc_interrupt, IRQF_SHARED,\n\t\t\t       dev_name(&pdev->dev), &pdev->dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"No input reference clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\trate = clk_get_rate(clk);\n\twritew(rate & 0xFFFF, priv->rtc_base + REG_RTC_FREQ_CW_L);\n\twritew((rate >> 16) & 0xFFFF, priv->rtc_base + REG_RTC_FREQ_CW_H);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_rtc_register_device(priv->rtc_dev);\n}\n\nstatic const struct of_device_id msc313_rtc_of_match_table[] = {\n\t{ .compatible = \"mstar,msc313-rtc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, msc313_rtc_of_match_table);\n\nstatic struct platform_driver msc313_rtc_driver = {\n\t.probe = msc313_rtc_probe,\n\t.driver = {\n\t\t.name = \"msc313-rtc\",\n\t\t.of_match_table = msc313_rtc_of_match_table,\n\t},\n};\n\nmodule_platform_driver(msc313_rtc_driver);\n\nMODULE_AUTHOR(\"Daniel Palmer <daniel@thingy.jp>\");\nMODULE_AUTHOR(\"Romain Perier <romain.perier@gmail.com>\");\nMODULE_DESCRIPTION(\"MStar RTC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}