{
  "module_name": "rtc-tps65910.c",
  "hash_id": "65b2c61e935fdbedfd687485fb20c98add69082dde62080f0a786c7aff3f8e58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-tps65910.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/math64.h>\n#include <linux/property.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/tps65910.h>\n\nstruct tps65910_rtc {\n\tstruct rtc_device\t*rtc;\n\tint irq;\n};\n\n \n#define NUM_TIME_REGS\t(TPS65910_YEARS - TPS65910_SECONDS + 1)\n\n \n#define NUM_COMP_REGS\t(TPS65910_RTC_COMP_MSB - TPS65910_RTC_COMP_LSB + 1)\n\n \n#define MIN_OFFSET\t(-277761)\n#define MAX_OFFSET\t(277778)\n\n \n#define TICKS_PER_HOUR\t(32768 * 3600)\n\n \n#define PPB_MULT\t(1000000000LL)\n\nstatic int tps65910_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enabled)\n{\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tu8 val = 0;\n\n\tif (enabled)\n\t\tval = TPS65910_RTC_INTERRUPTS_IT_ALARM;\n\n\treturn regmap_write(tps->regmap, TPS65910_RTC_INTERRUPTS, val);\n}\n\n \nstatic int tps65910_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char rtc_data[NUM_TIME_REGS];\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(tps->regmap, TPS65910_RTC_CTRL,\n\t\tTPS65910_RTC_CTRL_GET_TIME, TPS65910_RTC_CTRL_GET_TIME);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC CTRL reg update failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(tps->regmap, TPS65910_SECONDS, rtc_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"reading from RTC failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec = bcd2bin(rtc_data[0]);\n\ttm->tm_min = bcd2bin(rtc_data[1]);\n\ttm->tm_hour = bcd2bin(rtc_data[2]);\n\ttm->tm_mday = bcd2bin(rtc_data[3]);\n\ttm->tm_mon = bcd2bin(rtc_data[4]) - 1;\n\ttm->tm_year = bcd2bin(rtc_data[5]) + 100;\n\n\treturn ret;\n}\n\nstatic int tps65910_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char rtc_data[NUM_TIME_REGS];\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\trtc_data[0] = bin2bcd(tm->tm_sec);\n\trtc_data[1] = bin2bcd(tm->tm_min);\n\trtc_data[2] = bin2bcd(tm->tm_hour);\n\trtc_data[3] = bin2bcd(tm->tm_mday);\n\trtc_data[4] = bin2bcd(tm->tm_mon + 1);\n\trtc_data[5] = bin2bcd(tm->tm_year - 100);\n\n\t \n\tret = regmap_update_bits(tps->regmap, TPS65910_RTC_CTRL,\n\t\tTPS65910_RTC_CTRL_STOP_RTC, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC stop failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_bulk_write(tps->regmap, TPS65910_SECONDS, rtc_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_set_time error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(tps->regmap, TPS65910_RTC_CTRL,\n\t\tTPS65910_RTC_CTRL_STOP_RTC, 1);\n\tif (ret < 0)\n\t\tdev_err(dev, \"RTC start failed with err:%d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int tps65910_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tunsigned char alarm_data[NUM_TIME_REGS];\n\tu32 int_val;\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tret = regmap_bulk_read(tps->regmap, TPS65910_ALARM_SECONDS, alarm_data,\n\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_read_alarm error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talm->time.tm_sec = bcd2bin(alarm_data[0]);\n\talm->time.tm_min = bcd2bin(alarm_data[1]);\n\talm->time.tm_hour = bcd2bin(alarm_data[2]);\n\talm->time.tm_mday = bcd2bin(alarm_data[3]);\n\talm->time.tm_mon = bcd2bin(alarm_data[4]) - 1;\n\talm->time.tm_year = bcd2bin(alarm_data[5]) + 100;\n\n\tret = regmap_read(tps->regmap, TPS65910_RTC_INTERRUPTS, &int_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (int_val & TPS65910_RTC_INTERRUPTS_IT_ALARM)\n\t\talm->enabled = 1;\n\n\treturn ret;\n}\n\nstatic int tps65910_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tunsigned char alarm_data[NUM_TIME_REGS];\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tret = tps65910_rtc_alarm_irq_enable(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\talarm_data[0] = bin2bcd(alm->time.tm_sec);\n\talarm_data[1] = bin2bcd(alm->time.tm_min);\n\talarm_data[2] = bin2bcd(alm->time.tm_hour);\n\talarm_data[3] = bin2bcd(alm->time.tm_mday);\n\talarm_data[4] = bin2bcd(alm->time.tm_mon + 1);\n\talarm_data[5] = bin2bcd(alm->time.tm_year - 100);\n\n\t \n\tret = regmap_bulk_write(tps->regmap, TPS65910_ALARM_SECONDS,\n\t\talarm_data, NUM_TIME_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"rtc_set_alarm error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (alm->enabled)\n\t\tret = tps65910_rtc_alarm_irq_enable(dev, 1);\n\n\treturn ret;\n}\n\nstatic int tps65910_rtc_set_calibration(struct device *dev, int calibration)\n{\n\tunsigned char comp_data[NUM_COMP_REGS];\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\ts16 value;\n\tint ret;\n\n\t \n\tif ((calibration < -32768) || (calibration > 32766)) {\n\t\tdev_err(dev, \"RTC calibration value out of range: %d\\n\",\n\t\t\tcalibration);\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = (s16)calibration;\n\n\tcomp_data[0] = (u16)value & 0xFF;\n\tcomp_data[1] = ((u16)value >> 8) & 0xFF;\n\n\t \n\tret = regmap_bulk_write(tps->regmap, TPS65910_RTC_COMP_LSB,\n\t\tcomp_data, NUM_COMP_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_set_calibration error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(tps->regmap, TPS65910_RTC_CTRL,\n\t\tTPS65910_RTC_CTRL_AUTO_COMP, TPS65910_RTC_CTRL_AUTO_COMP);\n\tif (ret < 0)\n\t\tdev_err(dev, \"auto_comp enable failed with error: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tps65910_rtc_get_calibration(struct device *dev, int *calibration)\n{\n\tunsigned char comp_data[NUM_COMP_REGS];\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tunsigned int ctrl;\n\tu16 value;\n\tint ret;\n\n\tret = regmap_read(tps->regmap, TPS65910_RTC_CTRL, &ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!(ctrl & TPS65910_RTC_CTRL_AUTO_COMP)) {\n\t\t*calibration = 0;\n\t\treturn 0;\n\t}\n\n\tret = regmap_bulk_read(tps->regmap, TPS65910_RTC_COMP_LSB, comp_data,\n\t\tNUM_COMP_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_get_calibration error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvalue = (u16)comp_data[0] | ((u16)comp_data[1] << 8);\n\n\t*calibration = (s16)value;\n\n\treturn 0;\n}\n\nstatic int tps65910_read_offset(struct device *dev, long *offset)\n{\n\tint calibration;\n\ts64 tmp;\n\tint ret;\n\n\tret = tps65910_rtc_get_calibration(dev, &calibration);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttmp = calibration * (s64)PPB_MULT;\n\tif (tmp < 0)\n\t\ttmp -= TICKS_PER_HOUR / 2LL;\n\telse\n\t\ttmp += TICKS_PER_HOUR / 2LL;\n\ttmp = div_s64(tmp, TICKS_PER_HOUR);\n\n\t \n\t*offset = (long)-tmp;\n\n\treturn 0;\n}\n\nstatic int tps65910_set_offset(struct device *dev, long offset)\n{\n\tint calibration;\n\ts64 tmp;\n\tint ret;\n\n\t \n\tif (offset < MIN_OFFSET || offset > MAX_OFFSET)\n\t\treturn -ERANGE;\n\n\t \n\ttmp = offset * (s64)TICKS_PER_HOUR;\n\tif (tmp < 0)\n\t\ttmp -= PPB_MULT / 2LL;\n\telse\n\t\ttmp += PPB_MULT / 2LL;\n\ttmp = div_s64(tmp, PPB_MULT);\n\n\t \n\tcalibration = (int)-tmp;\n\n\tret = tps65910_rtc_set_calibration(dev, calibration);\n\n\treturn ret;\n}\n\nstatic irqreturn_t tps65910_rtc_interrupt(int irq, void *rtc)\n{\n\tstruct device *dev = rtc;\n\tunsigned long events = 0;\n\tstruct tps65910 *tps = dev_get_drvdata(dev->parent);\n\tstruct tps65910_rtc *tps_rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu32 rtc_reg;\n\n\tret = regmap_read(tps->regmap, TPS65910_RTC_STATUS, &rtc_reg);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (rtc_reg & TPS65910_RTC_STATUS_ALARM)\n\t\tevents = RTC_IRQF | RTC_AF;\n\n\tret = regmap_write(tps->regmap, TPS65910_RTC_STATUS, rtc_reg);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\trtc_update_irq(tps_rtc->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops tps65910_rtc_ops = {\n\t.read_time\t= tps65910_rtc_read_time,\n\t.set_time\t= tps65910_rtc_set_time,\n\t.read_alarm\t= tps65910_rtc_read_alarm,\n\t.set_alarm\t= tps65910_rtc_set_alarm,\n\t.alarm_irq_enable = tps65910_rtc_alarm_irq_enable,\n\t.read_offset\t= tps65910_read_offset,\n\t.set_offset\t= tps65910_set_offset,\n};\n\nstatic int tps65910_rtc_probe(struct platform_device *pdev)\n{\n\tstruct tps65910 *tps65910 = NULL;\n\tstruct tps65910_rtc *tps_rtc = NULL;\n\tint ret;\n\tint irq;\n\tu32 rtc_reg;\n\n\ttps65910 = dev_get_drvdata(pdev->dev.parent);\n\n\ttps_rtc = devm_kzalloc(&pdev->dev, sizeof(struct tps65910_rtc),\n\t\t\tGFP_KERNEL);\n\tif (!tps_rtc)\n\t\treturn -ENOMEM;\n\n\ttps_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(tps_rtc->rtc))\n\t\treturn PTR_ERR(tps_rtc->rtc);\n\n\t \n\tret = regmap_read(tps65910->regmap, TPS65910_RTC_STATUS, &rtc_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(tps65910->regmap, TPS65910_RTC_STATUS, rtc_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&pdev->dev, \"Enabling rtc-tps65910.\\n\");\n\n\t \n\tret = regmap_update_bits(tps65910->regmap, TPS65910_DEVCTRL,\n\t\tDEVCTRL_RTC_PWDN_MASK, 0 << DEVCTRL_RTC_PWDN_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trtc_reg = TPS65910_RTC_CTRL_STOP_RTC;\n\tret = regmap_write(tps65910->regmap, TPS65910_RTC_CTRL, rtc_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, tps_rtc);\n\n\tirq  = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\ttps65910_rtc_interrupt, IRQF_TRIGGER_LOW,\n\t\tdev_name(&pdev->dev), &pdev->dev);\n\tif (ret < 0)\n\t\tirq = -1;\n\n\ttps_rtc->irq = irq;\n\tif (irq != -1) {\n\t\tif (device_property_present(tps65910->dev, \"wakeup-source\"))\n\t\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t\telse\n\t\t\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\t} else {\n\t\tclear_bit(RTC_FEATURE_ALARM, tps_rtc->rtc->features);\n\t}\n\n\ttps_rtc->rtc->ops = &tps65910_rtc_ops;\n\ttps_rtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\ttps_rtc->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\treturn devm_rtc_register_device(tps_rtc->rtc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tps65910_rtc_suspend(struct device *dev)\n{\n\tstruct tps65910_rtc *tps_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(tps_rtc->irq);\n\treturn 0;\n}\n\nstatic int tps65910_rtc_resume(struct device *dev)\n{\n\tstruct tps65910_rtc *tps_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(tps_rtc->irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tps65910_rtc_pm_ops, tps65910_rtc_suspend,\n\t\t\ttps65910_rtc_resume);\n\nstatic struct platform_driver tps65910_rtc_driver = {\n\t.probe\t\t= tps65910_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"tps65910-rtc\",\n\t\t.pm\t= &tps65910_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(tps65910_rtc_driver);\nMODULE_ALIAS(\"platform:tps65910-rtc\");\nMODULE_AUTHOR(\"Venu Byravarasu <vbyravarasu@nvidia.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}