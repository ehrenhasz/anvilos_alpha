{
  "module_name": "rtc-mxc.c",
  "hash_id": "3b1193ed5e4787b25b01036c2efa2d524c67a0249ec006e45daaebdb2b9485c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mxc.c",
  "human_readable_source": "\n\n\n\n#include <linux/io.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n\n#define RTC_INPUT_CLK_32768HZ\t(0x00 << 5)\n#define RTC_INPUT_CLK_32000HZ\t(0x01 << 5)\n#define RTC_INPUT_CLK_38400HZ\t(0x02 << 5)\n\n#define RTC_SW_BIT      (1 << 0)\n#define RTC_ALM_BIT     (1 << 2)\n#define RTC_1HZ_BIT     (1 << 4)\n#define RTC_2HZ_BIT     (1 << 7)\n#define RTC_SAM0_BIT    (1 << 8)\n#define RTC_SAM1_BIT    (1 << 9)\n#define RTC_SAM2_BIT    (1 << 10)\n#define RTC_SAM3_BIT    (1 << 11)\n#define RTC_SAM4_BIT    (1 << 12)\n#define RTC_SAM5_BIT    (1 << 13)\n#define RTC_SAM6_BIT    (1 << 14)\n#define RTC_SAM7_BIT    (1 << 15)\n#define PIT_ALL_ON      (RTC_2HZ_BIT | RTC_SAM0_BIT | RTC_SAM1_BIT | \\\n\t\t\t RTC_SAM2_BIT | RTC_SAM3_BIT | RTC_SAM4_BIT | \\\n\t\t\t RTC_SAM5_BIT | RTC_SAM6_BIT | RTC_SAM7_BIT)\n\n#define RTC_ENABLE_BIT  (1 << 7)\n\n#define MAX_PIE_NUM     9\n#define MAX_PIE_FREQ    512\n\n#define MXC_RTC_TIME\t0\n#define MXC_RTC_ALARM\t1\n\n#define RTC_HOURMIN\t0x00\t \n#define RTC_SECOND\t0x04\t \n#define RTC_ALRM_HM\t0x08\t \n#define RTC_ALRM_SEC\t0x0C\t \n#define RTC_RTCCTL\t0x10\t \n#define RTC_RTCISR\t0x14\t \n#define RTC_RTCIENR\t0x18\t \n#define RTC_STPWCH\t0x1C\t \n#define RTC_DAYR\t0x20\t \n#define RTC_DAYALARM\t0x24\t \n#define RTC_TEST1\t0x28\t \n#define RTC_TEST2\t0x2C\t \n#define RTC_TEST3\t0x30\t \n\nenum imx_rtc_type {\n\tIMX1_RTC,\n\tIMX21_RTC,\n};\n\nstruct rtc_plat_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n\tint irq;\n\tstruct clk *clk_ref;\n\tstruct clk *clk_ipg;\n\tstruct rtc_time g_rtc_alarm;\n\tenum imx_rtc_type devtype;\n};\n\nstatic const struct of_device_id imx_rtc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx1-rtc\", .data = (const void *)IMX1_RTC },\n\t{ .compatible = \"fsl,imx21-rtc\", .data = (const void *)IMX21_RTC },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, imx_rtc_dt_ids);\n\nstatic inline int is_imx1_rtc(struct rtc_plat_data *data)\n{\n\treturn data->devtype == IMX1_RTC;\n}\n\n \nstatic time64_t get_alarm_or_time(struct device *dev, int time_alarm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32 day = 0, hr = 0, min = 0, sec = 0, hr_min = 0;\n\n\tswitch (time_alarm) {\n\tcase MXC_RTC_TIME:\n\t\tday = readw(ioaddr + RTC_DAYR);\n\t\thr_min = readw(ioaddr + RTC_HOURMIN);\n\t\tsec = readw(ioaddr + RTC_SECOND);\n\t\tbreak;\n\tcase MXC_RTC_ALARM:\n\t\tday = readw(ioaddr + RTC_DAYALARM);\n\t\thr_min = readw(ioaddr + RTC_ALRM_HM) & 0xffff;\n\t\tsec = readw(ioaddr + RTC_ALRM_SEC);\n\t\tbreak;\n\t}\n\n\thr = hr_min >> 8;\n\tmin = hr_min & 0xff;\n\n\treturn ((((time64_t)day * 24 + hr) * 60) + min) * 60 + sec;\n}\n\n \nstatic void set_alarm_or_time(struct device *dev, int time_alarm, time64_t time)\n{\n\tu32 tod, day, hr, min, sec, temp;\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\n\tday = div_s64_rem(time, 86400, &tod);\n\n\t \n\thr = tod / 3600;\n\ttod -= hr * 3600;\n\n\t \n\tmin = tod / 60;\n\tsec = tod - min * 60;\n\n\ttemp = (hr << 8) + min;\n\n\tswitch (time_alarm) {\n\tcase MXC_RTC_TIME:\n\t\twritew(day, ioaddr + RTC_DAYR);\n\t\twritew(sec, ioaddr + RTC_SECOND);\n\t\twritew(temp, ioaddr + RTC_HOURMIN);\n\t\tbreak;\n\tcase MXC_RTC_ALARM:\n\t\twritew(day, ioaddr + RTC_DAYALARM);\n\t\twritew(sec, ioaddr + RTC_ALRM_SEC);\n\t\twritew(temp, ioaddr + RTC_ALRM_HM);\n\t\tbreak;\n\t}\n}\n\n \nstatic void rtc_update_alarm(struct device *dev, struct rtc_time *alrm)\n{\n\ttime64_t time;\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\n\ttime = rtc_tm_to_time64(alrm);\n\n\t \n\twritew(readw(ioaddr + RTC_RTCISR), ioaddr + RTC_RTCISR);\n\tset_alarm_or_time(dev, MXC_RTC_ALARM, time);\n}\n\nstatic void mxc_rtc_irq_enable(struct device *dev, unsigned int bit,\n\t\t\t\tunsigned int enabled)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32 reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->rtc->irq_lock, flags);\n\treg = readw(ioaddr + RTC_RTCIENR);\n\n\tif (enabled)\n\t\treg |= bit;\n\telse\n\t\treg &= ~bit;\n\n\twritew(reg, ioaddr + RTC_RTCIENR);\n\tspin_unlock_irqrestore(&pdata->rtc->irq_lock, flags);\n}\n\n \nstatic irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32 status;\n\tu32 events = 0;\n\n\tspin_lock(&pdata->rtc->irq_lock);\n\tstatus = readw(ioaddr + RTC_RTCISR) & readw(ioaddr + RTC_RTCIENR);\n\t \n\twritew(status, ioaddr + RTC_RTCISR);\n\n\t \n\tif (status & RTC_ALM_BIT) {\n\t\tevents |= (RTC_AF | RTC_IRQF);\n\t\t \n\t\tmxc_rtc_irq_enable(&pdev->dev, RTC_ALM_BIT, 0);\n\t}\n\n\tif (status & PIT_ALL_ON)\n\t\tevents |= (RTC_PF | RTC_IRQF);\n\n\trtc_update_irq(pdata->rtc, 1, events);\n\tspin_unlock(&pdata->rtc->irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxc_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tmxc_rtc_irq_enable(dev, RTC_ALM_BIT, enabled);\n\treturn 0;\n}\n\n \nstatic int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\ttime64_t val;\n\n\t \n\tdo {\n\t\tval = get_alarm_or_time(dev, MXC_RTC_TIME);\n\t} while (val != get_alarm_or_time(dev, MXC_RTC_TIME));\n\n\trtc_time64_to_tm(val, tm);\n\n\treturn 0;\n}\n\n \nstatic int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\ttime64_t time = rtc_tm_to_time64(tm);\n\n\t \n\tdo {\n\t\tset_alarm_or_time(dev, MXC_RTC_TIME, time);\n\t} while (time != get_alarm_or_time(dev, MXC_RTC_TIME));\n\n\treturn 0;\n}\n\n \nstatic int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\n\trtc_time64_to_tm(get_alarm_or_time(dev, MXC_RTC_ALARM), &alrm->time);\n\talrm->pending = ((readw(ioaddr + RTC_RTCISR) & RTC_ALM_BIT)) ? 1 : 0;\n\n\treturn 0;\n}\n\n \nstatic int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\trtc_update_alarm(dev, &alrm->time);\n\n\tmemcpy(&pdata->g_rtc_alarm, &alrm->time, sizeof(struct rtc_time));\n\tmxc_rtc_irq_enable(dev, RTC_ALM_BIT, alrm->enabled);\n\n\treturn 0;\n}\n\n \nstatic const struct rtc_class_ops mxc_rtc_ops = {\n\t.read_time\t\t= mxc_rtc_read_time,\n\t.set_time\t\t= mxc_rtc_set_time,\n\t.read_alarm\t\t= mxc_rtc_read_alarm,\n\t.set_alarm\t\t= mxc_rtc_set_alarm,\n\t.alarm_irq_enable\t= mxc_rtc_alarm_irq_enable,\n};\n\nstatic int mxc_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\tstruct rtc_plat_data *pdata = NULL;\n\tu32 reg;\n\tunsigned long rate;\n\tint ret;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->devtype = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tpdata->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->ioaddr))\n\t\treturn PTR_ERR(pdata->ioaddr);\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tpdata->rtc = rtc;\n\trtc->ops = &mxc_rtc_ops;\n\tif (is_imx1_rtc(pdata)) {\n\t\tstruct rtc_time tm;\n\n\t\t \n\t\trtc->range_max = (1 << 9) * 86400 - 1;\n\n\t\t \n\t\trtc_time64_to_tm(ktime_get_real_seconds(), &tm);\n\t\trtc->start_secs =  mktime64(tm.tm_year, 1, 1, 0, 0, 0);\n\t\trtc->set_start_time = true;\n\t} else {\n\t\t \n\t\trtc->range_max = (1 << 16) * 86400ULL - 1;\n\t}\n\n\tpdata->clk_ipg = devm_clk_get_enabled(&pdev->dev, \"ipg\");\n\tif (IS_ERR(pdata->clk_ipg)) {\n\t\tdev_err(&pdev->dev, \"unable to get ipg clock!\\n\");\n\t\treturn PTR_ERR(pdata->clk_ipg);\n\t}\n\n\tpdata->clk_ref = devm_clk_get_enabled(&pdev->dev, \"ref\");\n\tif (IS_ERR(pdata->clk_ref)) {\n\t\tdev_err(&pdev->dev, \"unable to get ref clock!\\n\");\n\t\treturn PTR_ERR(pdata->clk_ref);\n\t}\n\n\trate = clk_get_rate(pdata->clk_ref);\n\n\tif (rate == 32768)\n\t\treg = RTC_INPUT_CLK_32768HZ;\n\telse if (rate == 32000)\n\t\treg = RTC_INPUT_CLK_32000HZ;\n\telse if (rate == 38400)\n\t\treg = RTC_INPUT_CLK_38400HZ;\n\telse {\n\t\tdev_err(&pdev->dev, \"rtc clock is not valid (%lu)\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\treg |= RTC_ENABLE_BIT;\n\twritew(reg, (pdata->ioaddr + RTC_RTCCTL));\n\tif (((readw(pdata->ioaddr + RTC_RTCCTL)) & RTC_ENABLE_BIT) == 0) {\n\t\tdev_err(&pdev->dev, \"hardware module can't be enabled!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tplatform_set_drvdata(pdev, pdata);\n\n\t \n\tpdata->irq = platform_get_irq(pdev, 0);\n\n\tif (pdata->irq >= 0 &&\n\t    devm_request_irq(&pdev->dev, pdata->irq, mxc_rtc_interrupt,\n\t\t\t     IRQF_SHARED, pdev->name, pdev) < 0) {\n\t\tdev_warn(&pdev->dev, \"interrupt not available.\\n\");\n\t\tpdata->irq = -1;\n\t}\n\n\tif (pdata->irq >= 0) {\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t\tret = dev_pm_set_wake_irq(&pdev->dev, pdata->irq);\n\t\tif (ret)\n\t\t\tdev_err(&pdev->dev, \"failed to enable irq wake\\n\");\n\t}\n\n\tret = devm_rtc_register_device(rtc);\n\n\treturn ret;\n}\n\nstatic struct platform_driver mxc_rtc_driver = {\n\t.driver = {\n\t\t   .name\t= \"mxc_rtc\",\n\t\t   .of_match_table = imx_rtc_dt_ids,\n\t},\n\t.probe = mxc_rtc_probe,\n};\n\nmodule_platform_driver(mxc_rtc_driver)\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@caiaq.de>\");\nMODULE_DESCRIPTION(\"RTC driver for Freescale MXC\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}