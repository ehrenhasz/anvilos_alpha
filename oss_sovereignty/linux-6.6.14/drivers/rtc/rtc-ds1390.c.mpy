{
  "module_name": "rtc-ds1390.c",
  "hash_id": "c5e906ff9de76ca0a25e6eef5bee98ff80fdc530fbb9ed302d5dd2187379ea6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1390.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/spi/spi.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#define DS1390_REG_100THS\t\t0x00\n#define DS1390_REG_SECONDS\t\t0x01\n#define DS1390_REG_MINUTES\t\t0x02\n#define DS1390_REG_HOURS\t\t0x03\n#define DS1390_REG_DAY\t\t\t0x04\n#define DS1390_REG_DATE\t\t\t0x05\n#define DS1390_REG_MONTH_CENT\t\t0x06\n#define DS1390_REG_YEAR\t\t\t0x07\n\n#define DS1390_REG_ALARM_100THS\t\t0x08\n#define DS1390_REG_ALARM_SECONDS\t0x09\n#define DS1390_REG_ALARM_MINUTES\t0x0A\n#define DS1390_REG_ALARM_HOURS\t\t0x0B\n#define DS1390_REG_ALARM_DAY_DATE\t0x0C\n\n#define DS1390_REG_CONTROL\t\t0x0D\n#define DS1390_REG_STATUS\t\t0x0E\n#define DS1390_REG_TRICKLE\t\t0x0F\n\n#define DS1390_TRICKLE_CHARGER_ENABLE\t0xA0\n#define DS1390_TRICKLE_CHARGER_250_OHM\t0x01\n#define DS1390_TRICKLE_CHARGER_2K_OHM\t0x02\n#define DS1390_TRICKLE_CHARGER_4K_OHM\t0x03\n#define DS1390_TRICKLE_CHARGER_NO_DIODE\t0x04\n#define DS1390_TRICKLE_CHARGER_DIODE\t0x08\n\nstruct ds1390 {\n\tstruct rtc_device *rtc;\n\tu8 txrx_buf[9];\t \n};\n\nstatic void ds1390_set_reg(struct device *dev, unsigned char address,\n\t\t\t   unsigned char data)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tunsigned char buf[2];\n\n\t \n\tbuf[0] = address | 0x80;\n\tbuf[1] = data;\n\n\tspi_write(spi, buf, 2);\n}\n\nstatic int ds1390_get_reg(struct device *dev, unsigned char address,\n\t\t\t\tunsigned char *data)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct ds1390 *chip = dev_get_drvdata(dev);\n\tint status;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\t \n\tchip->txrx_buf[0] = address & 0x7f;\n\t \n\tstatus = spi_write_then_read(spi, chip->txrx_buf, 1, chip->txrx_buf, 1);\n\tif (status != 0)\n\t\treturn status;\n\n\t*data = chip->txrx_buf[0];\n\n\treturn 0;\n}\n\nstatic void ds1390_trickle_of_init(struct spi_device *spi)\n{\n\tu32 ohms = 0;\n\tu8 value;\n\n\tif (of_property_read_u32(spi->dev.of_node, \"trickle-resistor-ohms\",\n\t\t\t\t &ohms))\n\t\tgoto out;\n\n\t \n\tvalue = DS1390_TRICKLE_CHARGER_ENABLE;\n\tif (of_property_read_bool(spi->dev.of_node, \"trickle-diode-disable\"))\n\t\tvalue |= DS1390_TRICKLE_CHARGER_NO_DIODE;\n\telse\n\t\tvalue |= DS1390_TRICKLE_CHARGER_DIODE;\n\n\t \n\tswitch (ohms) {\n\tcase 250:\n\t\tvalue |= DS1390_TRICKLE_CHARGER_250_OHM;\n\t\tbreak;\n\tcase 2000:\n\t\tvalue |= DS1390_TRICKLE_CHARGER_2K_OHM;\n\t\tbreak;\n\tcase 4000:\n\t\tvalue |= DS1390_TRICKLE_CHARGER_4K_OHM;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&spi->dev,\n\t\t\t \"Unsupported ohm value %02ux in dt\\n\", ohms);\n\t\treturn;\n\t}\n\n\tds1390_set_reg(&spi->dev, DS1390_REG_TRICKLE, value);\n\nout:\n\treturn;\n}\n\nstatic int ds1390_read_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct ds1390 *chip = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\tchip->txrx_buf[0] = DS1390_REG_SECONDS;\n\n\t \n\tstatus = spi_write_then_read(spi, chip->txrx_buf, 1, chip->txrx_buf, 8);\n\tif (status != 0)\n\t\treturn status;\n\n\t \n\tdt->tm_sec\t= bcd2bin(chip->txrx_buf[0]);\n\tdt->tm_min\t= bcd2bin(chip->txrx_buf[1]);\n\tdt->tm_hour\t= bcd2bin(chip->txrx_buf[2]);\n\tdt->tm_wday\t= bcd2bin(chip->txrx_buf[3]);\n\tdt->tm_mday\t= bcd2bin(chip->txrx_buf[4]);\n\t \n\tdt->tm_mon\t= bcd2bin(chip->txrx_buf[5] & 0x7f) - 1;\n\t \n\tdt->tm_year = bcd2bin(chip->txrx_buf[6]) + ((chip->txrx_buf[5] & 0x80) ? 100 : 0);\n\n\treturn 0;\n}\n\nstatic int ds1390_set_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct ds1390 *chip = dev_get_drvdata(dev);\n\n\t \n\tchip->txrx_buf[0] = DS1390_REG_SECONDS | 0x80;\n\tchip->txrx_buf[1] = bin2bcd(dt->tm_sec);\n\tchip->txrx_buf[2] = bin2bcd(dt->tm_min);\n\tchip->txrx_buf[3] = bin2bcd(dt->tm_hour);\n\tchip->txrx_buf[4] = bin2bcd(dt->tm_wday);\n\tchip->txrx_buf[5] = bin2bcd(dt->tm_mday);\n\tchip->txrx_buf[6] = bin2bcd(dt->tm_mon + 1) |\n\t\t\t\t((dt->tm_year > 99) ? 0x80 : 0x00);\n\tchip->txrx_buf[7] = bin2bcd(dt->tm_year % 100);\n\n\t \n\treturn spi_write_then_read(spi, chip->txrx_buf, 8, NULL, 0);\n}\n\nstatic const struct rtc_class_ops ds1390_rtc_ops = {\n\t.read_time\t= ds1390_read_time,\n\t.set_time\t= ds1390_set_time,\n};\n\nstatic int ds1390_probe(struct spi_device *spi)\n{\n\tunsigned char tmp;\n\tstruct ds1390 *chip;\n\tint res;\n\n\tspi->mode = SPI_MODE_3;\n\tspi->bits_per_word = 8;\n\tspi_setup(spi);\n\n\tchip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, chip);\n\n\tres = ds1390_get_reg(&spi->dev, DS1390_REG_SECONDS, &tmp);\n\tif (res != 0) {\n\t\tdev_err(&spi->dev, \"unable to read device\\n\");\n\t\treturn res;\n\t}\n\n\tif (spi->dev.of_node)\n\t\tds1390_trickle_of_init(spi);\n\n\tchip->rtc = devm_rtc_device_register(&spi->dev, \"ds1390\",\n\t\t\t\t\t&ds1390_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(chip->rtc)) {\n\t\tdev_err(&spi->dev, \"unable to register device\\n\");\n\t\tres = PTR_ERR(chip->rtc);\n\t}\n\n\treturn res;\n}\n\nstatic const struct of_device_id ds1390_of_match[] __maybe_unused = {\n\t{ .compatible = \"dallas,ds1390\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ds1390_of_match);\n\nstatic const struct spi_device_id ds1390_spi_ids[] = {\n\t{ .name = \"ds1390\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, ds1390_spi_ids);\n\nstatic struct spi_driver ds1390_driver = {\n\t.driver = {\n\t\t.name\t= \"rtc-ds1390\",\n\t\t.of_match_table = of_match_ptr(ds1390_of_match),\n\t},\n\t.probe\t= ds1390_probe,\n\t.id_table = ds1390_spi_ids,\n};\n\nmodule_spi_driver(ds1390_driver);\n\nMODULE_DESCRIPTION(\"Dallas/Maxim DS1390/93/94 SPI RTC driver\");\nMODULE_AUTHOR(\"Mark Jackson <mpfj@mimc.co.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:rtc-ds1390\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}