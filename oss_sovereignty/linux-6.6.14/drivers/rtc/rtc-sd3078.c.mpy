{
  "module_name": "rtc-sd3078.c",
  "hash_id": "97d195d38f0cbed84e2e4708115df04371855a53005ad7a3a256c8f61e62a414",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sd3078.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#define SD3078_REG_SC\t\t\t0x00\n#define SD3078_REG_MN\t\t\t0x01\n#define SD3078_REG_HR\t\t\t0x02\n#define SD3078_REG_DW\t\t\t0x03\n#define SD3078_REG_DM\t\t\t0x04\n#define SD3078_REG_MO\t\t\t0x05\n#define SD3078_REG_YR\t\t\t0x06\n\n#define SD3078_REG_CTRL1\t\t0x0f\n#define SD3078_REG_CTRL2\t\t0x10\n#define SD3078_REG_CTRL3\t\t0x11\n\n#define KEY_WRITE1\t\t0x80\n#define KEY_WRITE2\t\t0x04\n#define KEY_WRITE3\t\t0x80\n\n#define NUM_TIME_REGS   (SD3078_REG_YR - SD3078_REG_SC + 1)\n\n \n#define WRITE_PROTECT_EN\t0\n\nstruct sd3078 {\n\tstruct rtc_device\t*rtc;\n\tstruct regmap\t\t*regmap;\n};\n\n \nstatic void sd3078_enable_reg_write(struct sd3078 *sd3078)\n{\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL2,\n\t\t\t   KEY_WRITE1, KEY_WRITE1);\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL1,\n\t\t\t   KEY_WRITE2, KEY_WRITE2);\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL1,\n\t\t\t   KEY_WRITE3, KEY_WRITE3);\n}\n\n#if WRITE_PROTECT_EN\n \nstatic void sd3078_disable_reg_write(struct sd3078 *sd3078)\n{\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL1,\n\t\t\t   KEY_WRITE2, 0);\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL1,\n\t\t\t   KEY_WRITE3, 0);\n\tregmap_update_bits(sd3078->regmap, SD3078_REG_CTRL2,\n\t\t\t   KEY_WRITE1, 0);\n}\n#endif\n\nstatic int sd3078_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char hour;\n\tunsigned char rtc_data[NUM_TIME_REGS] = {0};\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct sd3078 *sd3078 = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = regmap_bulk_read(sd3078->regmap, SD3078_REG_SC, rtc_data,\n\t\t\t       NUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"reading from RTC failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec\t= bcd2bin(rtc_data[SD3078_REG_SC] & 0x7F);\n\ttm->tm_min\t= bcd2bin(rtc_data[SD3078_REG_MN] & 0x7F);\n\n\t \n\thour = rtc_data[SD3078_REG_HR];\n\tif (hour & 0x80)  \n\t\ttm->tm_hour = bcd2bin(rtc_data[SD3078_REG_HR] & 0x3F);\n\telse if (hour & 0x20)  \n\t\ttm->tm_hour = bcd2bin(rtc_data[SD3078_REG_HR] & 0x1F) + 12;\n\telse  \n\t\ttm->tm_hour = bcd2bin(rtc_data[SD3078_REG_HR] & 0x1F);\n\n\ttm->tm_mday = bcd2bin(rtc_data[SD3078_REG_DM] & 0x3F);\n\ttm->tm_wday = rtc_data[SD3078_REG_DW] & 0x07;\n\ttm->tm_mon\t= bcd2bin(rtc_data[SD3078_REG_MO] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(rtc_data[SD3078_REG_YR]) + 100;\n\n\treturn 0;\n}\n\nstatic int sd3078_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char rtc_data[NUM_TIME_REGS];\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct sd3078 *sd3078 = i2c_get_clientdata(client);\n\tint ret;\n\n\trtc_data[SD3078_REG_SC] = bin2bcd(tm->tm_sec);\n\trtc_data[SD3078_REG_MN] = bin2bcd(tm->tm_min);\n\trtc_data[SD3078_REG_HR] = bin2bcd(tm->tm_hour) | 0x80;\n\trtc_data[SD3078_REG_DM] = bin2bcd(tm->tm_mday);\n\trtc_data[SD3078_REG_DW] = tm->tm_wday & 0x07;\n\trtc_data[SD3078_REG_MO] = bin2bcd(tm->tm_mon) + 1;\n\trtc_data[SD3078_REG_YR] = bin2bcd(tm->tm_year - 100);\n\n#if WRITE_PROTECT_EN\n\tsd3078_enable_reg_write(sd3078);\n#endif\n\n\tret = regmap_bulk_write(sd3078->regmap, SD3078_REG_SC, rtc_data,\n\t\t\t\tNUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"writing to RTC failed with err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n#if WRITE_PROTECT_EN\n\tsd3078_disable_reg_write(sd3078);\n#endif\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sd3078_rtc_ops = {\n\t.read_time\t= sd3078_rtc_read_time,\n\t.set_time\t= sd3078_rtc_set_time,\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x11,\n};\n\nstatic int sd3078_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct sd3078 *sd3078;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tsd3078 = devm_kzalloc(&client->dev, sizeof(*sd3078), GFP_KERNEL);\n\tif (!sd3078)\n\t\treturn -ENOMEM;\n\n\tsd3078->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(sd3078->regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(sd3078->regmap);\n\t}\n\n\ti2c_set_clientdata(client, sd3078);\n\n\tsd3078->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(sd3078->rtc))\n\t\treturn PTR_ERR(sd3078->rtc);\n\n\tsd3078->rtc->ops = &sd3078_rtc_ops;\n\tsd3078->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tsd3078->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tret = devm_rtc_register_device(sd3078->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tsd3078_enable_reg_write(sd3078);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id sd3078_id[] = {\n\t{\"sd3078\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sd3078_id);\n\nstatic const __maybe_unused struct of_device_id rtc_dt_match[] = {\n\t{ .compatible = \"whwave,sd3078\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rtc_dt_match);\n\nstatic struct i2c_driver sd3078_driver = {\n\t.driver     = {\n\t\t.name   = \"sd3078\",\n\t\t.of_match_table = of_match_ptr(rtc_dt_match),\n\t},\n\t.probe      = sd3078_probe,\n\t.id_table   = sd3078_id,\n};\n\nmodule_i2c_driver(sd3078_driver);\n\nMODULE_AUTHOR(\"Dianlong Li <long17.cool@163.com>\");\nMODULE_DESCRIPTION(\"SD3078 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}