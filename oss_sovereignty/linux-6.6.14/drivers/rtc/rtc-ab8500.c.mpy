{
  "module_name": "rtc-ab8500.c",
  "hash_id": "0b2f619ffedb468937d4f59ee3d8babf889237ef33096e1cc6e252b927551f9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ab8500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n\n#define AB8500_RTC_SOFF_STAT_REG\t0x00\n#define AB8500_RTC_CC_CONF_REG\t\t0x01\n#define AB8500_RTC_READ_REQ_REG\t\t0x02\n#define AB8500_RTC_WATCH_TSECMID_REG\t0x03\n#define AB8500_RTC_WATCH_TSECHI_REG\t0x04\n#define AB8500_RTC_WATCH_TMIN_LOW_REG\t0x05\n#define AB8500_RTC_WATCH_TMIN_MID_REG\t0x06\n#define AB8500_RTC_WATCH_TMIN_HI_REG\t0x07\n#define AB8500_RTC_ALRM_MIN_LOW_REG\t0x08\n#define AB8500_RTC_ALRM_MIN_MID_REG\t0x09\n#define AB8500_RTC_ALRM_MIN_HI_REG\t0x0A\n#define AB8500_RTC_STAT_REG\t\t0x0B\n#define AB8500_RTC_BKUP_CHG_REG\t\t0x0C\n#define AB8500_RTC_FORCE_BKUP_REG\t0x0D\n#define AB8500_RTC_CALIB_REG\t\t0x0E\n#define AB8500_RTC_SWITCH_STAT_REG\t0x0F\n\n \n#define RTC_READ_REQUEST\t\t0x01\n#define RTC_WRITE_REQUEST\t\t0x02\n\n \n#define RTC_ALARM_ENA\t\t\t0x04\n#define RTC_STATUS_DATA\t\t\t0x01\n\n#define COUNTS_PER_SEC\t\t\t(0xF000 / 60)\n\nstatic const u8 ab8500_rtc_time_regs[] = {\n\tAB8500_RTC_WATCH_TMIN_HI_REG, AB8500_RTC_WATCH_TMIN_MID_REG,\n\tAB8500_RTC_WATCH_TMIN_LOW_REG, AB8500_RTC_WATCH_TSECHI_REG,\n\tAB8500_RTC_WATCH_TSECMID_REG\n};\n\nstatic const u8 ab8500_rtc_alarm_regs[] = {\n\tAB8500_RTC_ALRM_MIN_HI_REG, AB8500_RTC_ALRM_MIN_MID_REG,\n\tAB8500_RTC_ALRM_MIN_LOW_REG\n};\n\nstatic int ab8500_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long timeout = jiffies + HZ;\n\tint retval, i;\n\tunsigned long mins, secs;\n\tunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\n\tu8 value;\n\n\t \n\tretval = abx500_set_register_interruptible(dev,\n\t\tAB8500_RTC, AB8500_RTC_READ_REQ_REG, RTC_READ_REQUEST);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tretval = abx500_get_register_interruptible(dev,\n\t\t\tAB8500_RTC, AB8500_RTC_READ_REQ_REG, &value);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (!(value & RTC_READ_REQUEST))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 5000);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\n\t\tretval = abx500_get_register_interruptible(dev,\n\t\t\tAB8500_RTC, ab8500_rtc_time_regs[i], &value);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tbuf[i] = value;\n\t}\n\n\tmins = (buf[0] << 16) | (buf[1] << 8) | buf[2];\n\n\tsecs =\t(buf[3] << 8) | buf[4];\n\tsecs =\tsecs / COUNTS_PER_SEC;\n\tsecs =\tsecs + (mins * 60);\n\n\trtc_time64_to_tm(secs, tm);\n\treturn 0;\n}\n\nstatic int ab8500_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tint retval, i;\n\tunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\n\tunsigned long no_secs, no_mins, secs = 0;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\tno_mins = secs / 60;\n\n\tno_secs = secs % 60;\n\t \n\tno_secs = no_secs * COUNTS_PER_SEC;\n\n\tbuf[4] = no_secs & 0xFF;\n\tbuf[3] = (no_secs >> 8) & 0xFF;\n\n\tbuf[2] = no_mins & 0xFF;\n\tbuf[1] = (no_mins >> 8) & 0xFF;\n\tbuf[0] = (no_mins >> 16) & 0xFF;\n\n\tfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\n\t\tretval = abx500_set_register_interruptible(dev, AB8500_RTC,\n\t\t\tab8500_rtc_time_regs[i], buf[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\t \n\treturn abx500_set_register_interruptible(dev, AB8500_RTC,\n\t\tAB8500_RTC_READ_REQ_REG, RTC_WRITE_REQUEST);\n}\n\nstatic int ab8500_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tint retval, i;\n\tu8 rtc_ctrl, value;\n\tunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\n\tunsigned long secs, mins;\n\n\t \n\tretval = abx500_get_register_interruptible(dev, AB8500_RTC,\n\t\tAB8500_RTC_STAT_REG, &rtc_ctrl);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (rtc_ctrl & RTC_ALARM_ENA)\n\t\talarm->enabled = 1;\n\telse\n\t\talarm->enabled = 0;\n\n\talarm->pending = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\n\t\tretval = abx500_get_register_interruptible(dev, AB8500_RTC,\n\t\t\tab8500_rtc_alarm_regs[i], &value);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tbuf[i] = value;\n\t}\n\n\tmins = (buf[0] << 16) | (buf[1] << 8) | (buf[2]);\n\tsecs = mins * 60;\n\n\trtc_time64_to_tm(secs, &alarm->time);\n\n\treturn 0;\n}\n\nstatic int ab8500_rtc_irq_enable(struct device *dev, unsigned int enabled)\n{\n\treturn abx500_mask_and_set_register_interruptible(dev, AB8500_RTC,\n\t\tAB8500_RTC_STAT_REG, RTC_ALARM_ENA,\n\t\tenabled ? RTC_ALARM_ENA : 0);\n}\n\nstatic int ab8500_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tint retval, i;\n\tunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\n\tunsigned long mins;\n\n\tmins = (unsigned long)rtc_tm_to_time64(&alarm->time) / 60;\n\n\tbuf[2] = mins & 0xFF;\n\tbuf[1] = (mins >> 8) & 0xFF;\n\tbuf[0] = (mins >> 16) & 0xFF;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\n\t\tretval = abx500_set_register_interruptible(dev, AB8500_RTC,\n\t\t\tab8500_rtc_alarm_regs[i], buf[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn ab8500_rtc_irq_enable(dev, alarm->enabled);\n}\n\nstatic int ab8500_rtc_set_calibration(struct device *dev, int calibration)\n{\n\tint retval;\n\tu8  rtccal = 0;\n\n\t \n\tif ((calibration < -127) || (calibration > 127)) {\n\t\tdev_err(dev, \"RtcCalibration value outside permitted range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (calibration >= 0)\n\t\trtccal = 0x7F & calibration;\n\telse\n\t\trtccal = ~(calibration - 1) | 0x80;\n\n\tretval = abx500_set_register_interruptible(dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CALIB_REG, rtccal);\n\n\treturn retval;\n}\n\nstatic int ab8500_rtc_get_calibration(struct device *dev, int *calibration)\n{\n\tint retval;\n\tu8  rtccal = 0;\n\n\tretval =  abx500_get_register_interruptible(dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CALIB_REG, &rtccal);\n\tif (retval >= 0) {\n\t\t \n\t\tif (rtccal & 0x80)\n\t\t\t*calibration = 0 - (rtccal & 0x7F);\n\t\telse\n\t\t\t*calibration = 0x7F & rtccal;\n\t}\n\n\treturn retval;\n}\n\nstatic ssize_t ab8500_sysfs_store_rtc_calibration(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint retval;\n\tint calibration = 0;\n\n\tif (sscanf(buf, \" %i \", &calibration) != 1) {\n\t\tdev_err(dev, \"Failed to store RTC calibration attribute\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = ab8500_rtc_set_calibration(dev, calibration);\n\n\treturn retval ? retval : count;\n}\n\nstatic ssize_t ab8500_sysfs_show_rtc_calibration(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint  retval = 0;\n\tint  calibration = 0;\n\n\tretval = ab8500_rtc_get_calibration(dev, &calibration);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Failed to read RTC calibration attribute\\n\");\n\t\tsprintf(buf, \"0\\n\");\n\t\treturn retval;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", calibration);\n}\n\nstatic DEVICE_ATTR(rtc_calibration, S_IRUGO | S_IWUSR,\n\t\t   ab8500_sysfs_show_rtc_calibration,\n\t\t   ab8500_sysfs_store_rtc_calibration);\n\nstatic struct attribute *ab8500_rtc_attrs[] = {\n\t&dev_attr_rtc_calibration.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ab8500_rtc_sysfs_files = {\n\t.attrs\t= ab8500_rtc_attrs,\n};\n\nstatic irqreturn_t rtc_alarm_handler(int irq, void *data)\n{\n\tstruct rtc_device *rtc = data;\n\tunsigned long events = RTC_IRQF | RTC_AF;\n\n\tdev_dbg(&rtc->dev, \"%s\\n\", __func__);\n\trtc_update_irq(rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops ab8500_rtc_ops = {\n\t.read_time\t\t= ab8500_rtc_read_time,\n\t.set_time\t\t= ab8500_rtc_set_time,\n\t.read_alarm\t\t= ab8500_rtc_read_alarm,\n\t.set_alarm\t\t= ab8500_rtc_set_alarm,\n\t.alarm_irq_enable\t= ab8500_rtc_irq_enable,\n};\n\nstatic const struct platform_device_id ab85xx_rtc_ids[] = {\n\t{ \"ab8500-rtc\", (kernel_ulong_t)&ab8500_rtc_ops, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, ab85xx_rtc_ids);\n\nstatic int ab8500_rtc_probe(struct platform_device *pdev)\n{\n\tconst struct platform_device_id *platid = platform_get_device_id(pdev);\n\tint err;\n\tstruct rtc_device *rtc;\n\tu8 rtc_ctrl;\n\tint irq;\n\n\tirq = platform_get_irq_byname(pdev, \"ALARM\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\terr = abx500_mask_and_set_register_interruptible(&pdev->dev, AB8500_RTC,\n\t\tAB8500_RTC_STAT_REG, RTC_STATUS_DATA, RTC_STATUS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(1000, 5000);\n\n\terr = abx500_get_register_interruptible(&pdev->dev, AB8500_RTC,\n\t\tAB8500_RTC_STAT_REG, &rtc_ctrl);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!(rtc_ctrl & RTC_STATUS_DATA)) {\n\t\tdev_err(&pdev->dev, \"RTC supply failure\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\trtc->ops = (struct rtc_class_ops *)platid->driver_data;\n\n\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\trtc_alarm_handler, IRQF_ONESHOT,\n\t\t\t\"ab8500-rtc\", rtc);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_pm_set_wake_irq(&pdev->dev, irq);\n\tplatform_set_drvdata(pdev, rtc);\n\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\n\trtc->range_max = (1ULL << 24) * 60 - 1; \n\trtc->start_secs = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->set_start_time = true;\n\n\terr = rtc_add_group(rtc, &ab8500_rtc_sysfs_files);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic void ab8500_rtc_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n}\n\nstatic struct platform_driver ab8500_rtc_driver = {\n\t.driver = {\n\t\t.name = \"ab8500-rtc\",\n\t},\n\t.probe\t= ab8500_rtc_probe,\n\t.remove_new = ab8500_rtc_remove,\n\t.id_table = ab85xx_rtc_ids,\n};\n\nmodule_platform_driver(ab8500_rtc_driver);\n\nMODULE_AUTHOR(\"Virupax Sadashivpetimath <virupax.sadashivpetimath@stericsson.com>\");\nMODULE_DESCRIPTION(\"AB8500 RTC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}