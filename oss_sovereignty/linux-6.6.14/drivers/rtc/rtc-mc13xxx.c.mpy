{
  "module_name": "rtc-mc13xxx.c",
  "hash_id": "b06bc35aca1c4297bf770dc093ffc6a719b90b37a17a047c2ad9113b6721d991",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mc13xxx.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/mc13xxx.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n\n#define DRIVER_NAME \"mc13xxx-rtc\"\n\n#define MC13XXX_RTCTOD\t20\n#define MC13XXX_RTCTODA\t21\n#define MC13XXX_RTCDAY\t22\n#define MC13XXX_RTCDAYA\t23\n\n#define SEC_PER_DAY\t(24 * 60 * 60)\n\nstruct mc13xxx_rtc {\n\tstruct rtc_device *rtc;\n\tstruct mc13xxx *mc13xxx;\n\tint valid;\n};\n\nstatic int mc13xxx_rtc_irq_enable_unlocked(struct device *dev,\n\t\tunsigned int enabled, int irq)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\tint (*func)(struct mc13xxx *mc13xxx, int irq);\n\n\tif (!priv->valid)\n\t\treturn -ENODATA;\n\n\tfunc = enabled ? mc13xxx_irq_unmask : mc13xxx_irq_mask;\n\treturn func(priv->mc13xxx, irq);\n}\n\nstatic int mc13xxx_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\tret = mc13xxx_rtc_irq_enable_unlocked(dev, enabled, MC13XXX_IRQ_TODA);\n\n\tmc13xxx_unlock(priv->mc13xxx);\n\n\treturn ret;\n}\n\nstatic int mc13xxx_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\tunsigned int seconds, days1, days2;\n\n\tif (!priv->valid)\n\t\treturn -ENODATA;\n\n\tdo {\n\t\tint ret;\n\n\t\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCDAY, &days1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCTOD, &seconds);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCDAY, &days2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (days1 != days2);\n\n\trtc_time64_to_tm((time64_t)days1 * SEC_PER_DAY + seconds, tm);\n\n\treturn 0;\n}\n\nstatic int mc13xxx_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\tunsigned int seconds, days;\n\tunsigned int alarmseconds;\n\tint ret;\n\n\tdays = div_s64_rem(rtc_tm_to_time64(tm), SEC_PER_DAY, &seconds);\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\t \n\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCTODA, &alarmseconds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tif (alarmseconds < SEC_PER_DAY) {\n\t\tret = mc13xxx_reg_write(priv->mc13xxx,\n\t\t\t\tMC13XXX_RTCTODA, 0x1ffff);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCTOD, 0);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCDAY, days);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCTOD, seconds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\t \n\tif (alarmseconds < SEC_PER_DAY) {\n\t\tret = mc13xxx_reg_write(priv->mc13xxx,\n\t\t\t\tMC13XXX_RTCTODA, alarmseconds);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tif (!priv->valid) {\n\t\tret = mc13xxx_irq_ack(priv->mc13xxx, MC13XXX_IRQ_RTCRST);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\tret = mc13xxx_irq_unmask(priv->mc13xxx, MC13XXX_IRQ_RTCRST);\n\t}\n\nout:\n\tpriv->valid = !ret;\n\n\tmc13xxx_unlock(priv->mc13xxx);\n\n\treturn ret;\n}\n\nstatic int mc13xxx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\tunsigned int seconds, days;\n\ttime64_t s1970;\n\tint enabled, pending;\n\tint ret;\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCTODA, &seconds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tif (seconds >= SEC_PER_DAY) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tret = mc13xxx_reg_read(priv->mc13xxx, MC13XXX_RTCDAY, &days);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = mc13xxx_irq_status(priv->mc13xxx, MC13XXX_IRQ_TODA,\n\t\t\t&enabled, &pending);\n\nout:\n\tmc13xxx_unlock(priv->mc13xxx);\n\n\tif (ret)\n\t\treturn ret;\n\n\talarm->enabled = enabled;\n\talarm->pending = pending;\n\n\ts1970 = (time64_t)days * SEC_PER_DAY + seconds;\n\n\trtc_time64_to_tm(s1970, &alarm->time);\n\tdev_dbg(dev, \"%s: %lld\\n\", __func__, (long long)s1970);\n\n\treturn 0;\n}\n\nstatic int mc13xxx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct mc13xxx_rtc *priv = dev_get_drvdata(dev);\n\ttime64_t s1970;\n\tu32 seconds, days;\n\tint ret;\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\t \n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCTODA, 0x1ffff);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = mc13xxx_irq_ack(priv->mc13xxx, MC13XXX_IRQ_TODA);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\ts1970 = rtc_tm_to_time64(&alarm->time);\n\n\tdev_dbg(dev, \"%s: %s %lld\\n\", __func__, alarm->enabled ? \"on\" : \"off\",\n\t\t\t(long long)s1970);\n\n\tret = mc13xxx_rtc_irq_enable_unlocked(dev, alarm->enabled,\n\t\t\tMC13XXX_IRQ_TODA);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tdays = div_s64_rem(s1970, SEC_PER_DAY, &seconds);\n\n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCDAYA, days);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = mc13xxx_reg_write(priv->mc13xxx, MC13XXX_RTCTODA, seconds);\n\nout:\n\tmc13xxx_unlock(priv->mc13xxx);\n\n\treturn ret;\n}\n\nstatic irqreturn_t mc13xxx_rtc_alarm_handler(int irq, void *dev)\n{\n\tstruct mc13xxx_rtc *priv = dev;\n\tstruct mc13xxx *mc13xxx = priv->mc13xxx;\n\n\trtc_update_irq(priv->rtc, 1, RTC_IRQF | RTC_AF);\n\n\tmc13xxx_irq_ack(mc13xxx, irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops mc13xxx_rtc_ops = {\n\t.read_time = mc13xxx_rtc_read_time,\n\t.set_time = mc13xxx_rtc_set_time,\n\t.read_alarm = mc13xxx_rtc_read_alarm,\n\t.set_alarm = mc13xxx_rtc_set_alarm,\n\t.alarm_irq_enable = mc13xxx_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t mc13xxx_rtc_reset_handler(int irq, void *dev)\n{\n\tstruct mc13xxx_rtc *priv = dev;\n\tstruct mc13xxx *mc13xxx = priv->mc13xxx;\n\n\tpriv->valid = 0;\n\n\tmc13xxx_irq_mask(mc13xxx, irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init mc13xxx_rtc_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct mc13xxx_rtc *priv;\n\tstruct mc13xxx *mc13xxx;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmc13xxx = dev_get_drvdata(pdev->dev.parent);\n\tpriv->mc13xxx = mc13xxx;\n\tpriv->valid = 1;\n\n\tpriv->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(priv->rtc))\n\t\treturn PTR_ERR(priv->rtc);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->rtc->ops = &mc13xxx_rtc_ops;\n\t \n\tpriv->rtc->range_max = (timeu64_t)(1 << 15) * SEC_PER_DAY - 1;\n\n\tmc13xxx_lock(mc13xxx);\n\n\tmc13xxx_irq_ack(mc13xxx, MC13XXX_IRQ_RTCRST);\n\n\tret = mc13xxx_irq_request(mc13xxx, MC13XXX_IRQ_RTCRST,\n\t\t\tmc13xxx_rtc_reset_handler, DRIVER_NAME, priv);\n\tif (ret)\n\t\tgoto err_irq_request;\n\n\tret = mc13xxx_irq_request_nounmask(mc13xxx, MC13XXX_IRQ_TODA,\n\t\t\tmc13xxx_rtc_alarm_handler, DRIVER_NAME, priv);\n\tif (ret)\n\t\tgoto err_irq_request;\n\n\tmc13xxx_unlock(mc13xxx);\n\n\tret = devm_rtc_register_device(priv->rtc);\n\tif (ret) {\n\t\tmc13xxx_lock(mc13xxx);\n\t\tgoto err_irq_request;\n\t}\n\n\treturn 0;\n\nerr_irq_request:\n\tmc13xxx_irq_free(mc13xxx, MC13XXX_IRQ_TODA, priv);\n\tmc13xxx_irq_free(mc13xxx, MC13XXX_IRQ_RTCRST, priv);\n\n\tmc13xxx_unlock(mc13xxx);\n\n\treturn ret;\n}\n\nstatic void mc13xxx_rtc_remove(struct platform_device *pdev)\n{\n\tstruct mc13xxx_rtc *priv = platform_get_drvdata(pdev);\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\tmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_TODA, priv);\n\tmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_RTCRST, priv);\n\n\tmc13xxx_unlock(priv->mc13xxx);\n}\n\nstatic const struct platform_device_id mc13xxx_rtc_idtable[] = {\n\t{\n\t\t.name = \"mc13783-rtc\",\n\t}, {\n\t\t.name = \"mc13892-rtc\",\n\t}, {\n\t\t.name = \"mc34708-rtc\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, mc13xxx_rtc_idtable);\n\nstatic struct platform_driver mc13xxx_rtc_driver = {\n\t.id_table = mc13xxx_rtc_idtable,\n\t.remove_new = mc13xxx_rtc_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t},\n};\n\nmodule_platform_driver_probe(mc13xxx_rtc_driver, &mc13xxx_rtc_probe);\n\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_DESCRIPTION(\"RTC driver for Freescale MC13XXX PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}