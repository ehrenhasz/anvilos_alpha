{
  "module_name": "rtc-palmas.c",
  "hash_id": "2925c2f3c97448fe96aac9e0876a129d9ef3930cb9ae19af20dab9ca7fb0524d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-palmas.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/palmas.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n\nstruct palmas_rtc {\n\tstruct rtc_device\t*rtc;\n\tstruct device\t\t*dev;\n\tunsigned int\t\tirq;\n};\n\n \n#define PALMAS_NUM_TIME_REGS\t(PALMAS_YEARS_REG - PALMAS_SECONDS_REG + 1)\n\nstatic int palmas_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char rtc_data[PALMAS_NUM_TIME_REGS];\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\t \n\tret = palmas_update_bits(palmas, PALMAS_RTC_BASE, PALMAS_RTC_CTRL_REG,\n\t\tPALMAS_RTC_CTRL_REG_GET_TIME, PALMAS_RTC_CTRL_REG_GET_TIME);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC CTRL reg update failed, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_bulk_read(palmas, PALMAS_RTC_BASE, PALMAS_SECONDS_REG,\n\t\t\trtc_data, PALMAS_NUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_SECONDS reg read failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec = bcd2bin(rtc_data[0]);\n\ttm->tm_min = bcd2bin(rtc_data[1]);\n\ttm->tm_hour = bcd2bin(rtc_data[2]);\n\ttm->tm_mday = bcd2bin(rtc_data[3]);\n\ttm->tm_mon = bcd2bin(rtc_data[4]) - 1;\n\ttm->tm_year = bcd2bin(rtc_data[5]) + 100;\n\n\treturn ret;\n}\n\nstatic int palmas_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char rtc_data[PALMAS_NUM_TIME_REGS];\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\trtc_data[0] = bin2bcd(tm->tm_sec);\n\trtc_data[1] = bin2bcd(tm->tm_min);\n\trtc_data[2] = bin2bcd(tm->tm_hour);\n\trtc_data[3] = bin2bcd(tm->tm_mday);\n\trtc_data[4] = bin2bcd(tm->tm_mon + 1);\n\trtc_data[5] = bin2bcd(tm->tm_year - 100);\n\n\t \n\tret = palmas_update_bits(palmas, PALMAS_RTC_BASE, PALMAS_RTC_CTRL_REG,\n\t\tPALMAS_RTC_CTRL_REG_STOP_RTC, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC stop failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_bulk_write(palmas, PALMAS_RTC_BASE, PALMAS_SECONDS_REG,\n\t\trtc_data, PALMAS_NUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_SECONDS reg write failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = palmas_update_bits(palmas, PALMAS_RTC_BASE, PALMAS_RTC_CTRL_REG,\n\t\tPALMAS_RTC_CTRL_REG_STOP_RTC, PALMAS_RTC_CTRL_REG_STOP_RTC);\n\tif (ret < 0)\n\t\tdev_err(dev, \"RTC start failed, err = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int palmas_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)\n{\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tu8 val;\n\n\tval = enabled ? PALMAS_RTC_INTERRUPTS_REG_IT_ALARM : 0;\n\treturn palmas_write(palmas, PALMAS_RTC_BASE,\n\t\tPALMAS_RTC_INTERRUPTS_REG, val);\n}\n\nstatic int palmas_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tunsigned char alarm_data[PALMAS_NUM_TIME_REGS];\n\tu32 int_val;\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tret = palmas_bulk_read(palmas, PALMAS_RTC_BASE,\n\t\t\tPALMAS_ALARM_SECONDS_REG,\n\t\t\talarm_data, PALMAS_NUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_ALARM_SECONDS read failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talm->time.tm_sec = bcd2bin(alarm_data[0]);\n\talm->time.tm_min = bcd2bin(alarm_data[1]);\n\talm->time.tm_hour = bcd2bin(alarm_data[2]);\n\talm->time.tm_mday = bcd2bin(alarm_data[3]);\n\talm->time.tm_mon = bcd2bin(alarm_data[4]) - 1;\n\talm->time.tm_year = bcd2bin(alarm_data[5]) + 100;\n\n\tret = palmas_read(palmas, PALMAS_RTC_BASE, PALMAS_RTC_INTERRUPTS_REG,\n\t\t\t&int_val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_INTERRUPTS reg read failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (int_val & PALMAS_RTC_INTERRUPTS_REG_IT_ALARM)\n\t\talm->enabled = 1;\n\treturn ret;\n}\n\nstatic int palmas_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tunsigned char alarm_data[PALMAS_NUM_TIME_REGS];\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tret = palmas_rtc_alarm_irq_enable(dev, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Disable RTC alarm failed\\n\");\n\t\treturn ret;\n\t}\n\n\talarm_data[0] = bin2bcd(alm->time.tm_sec);\n\talarm_data[1] = bin2bcd(alm->time.tm_min);\n\talarm_data[2] = bin2bcd(alm->time.tm_hour);\n\talarm_data[3] = bin2bcd(alm->time.tm_mday);\n\talarm_data[4] = bin2bcd(alm->time.tm_mon + 1);\n\talarm_data[5] = bin2bcd(alm->time.tm_year - 100);\n\n\tret = palmas_bulk_write(palmas, PALMAS_RTC_BASE,\n\t\tPALMAS_ALARM_SECONDS_REG, alarm_data, PALMAS_NUM_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"ALARM_SECONDS_REG write failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (alm->enabled)\n\t\tret = palmas_rtc_alarm_irq_enable(dev, 1);\n\treturn ret;\n}\n\nstatic int palmas_clear_interrupts(struct device *dev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(dev->parent);\n\tunsigned int rtc_reg;\n\tint ret;\n\n\tret = palmas_read(palmas, PALMAS_RTC_BASE, PALMAS_RTC_STATUS_REG,\n\t\t\t\t&rtc_reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_STATUS read failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = palmas_write(palmas, PALMAS_RTC_BASE, PALMAS_RTC_STATUS_REG,\n\t\t\trtc_reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC_STATUS write failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t palmas_rtc_interrupt(int irq, void *context)\n{\n\tstruct palmas_rtc *palmas_rtc = context;\n\tstruct device *dev = palmas_rtc->dev;\n\tint ret;\n\n\tret = palmas_clear_interrupts(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"RTC interrupt clear failed, err = %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\trtc_update_irq(palmas_rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops palmas_rtc_ops = {\n\t.read_time\t= palmas_rtc_read_time,\n\t.set_time\t= palmas_rtc_set_time,\n\t.read_alarm\t= palmas_rtc_read_alarm,\n\t.set_alarm\t= palmas_rtc_set_alarm,\n\t.alarm_irq_enable = palmas_rtc_alarm_irq_enable,\n};\n\nstatic int palmas_rtc_probe(struct platform_device *pdev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\n\tstruct palmas_rtc *palmas_rtc = NULL;\n\tint ret;\n\tbool enable_bb_charging = false;\n\tbool high_bb_charging = false;\n\n\tif (pdev->dev.of_node) {\n\t\tenable_bb_charging = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\"ti,backup-battery-chargeable\");\n\t\thigh_bb_charging = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\"ti,backup-battery-charge-high-current\");\n\t}\n\n\tpalmas_rtc = devm_kzalloc(&pdev->dev, sizeof(struct palmas_rtc),\n\t\t\tGFP_KERNEL);\n\tif (!palmas_rtc)\n\t\treturn -ENOMEM;\n\n\t \n\tret = palmas_clear_interrupts(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"clear RTC int failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpalmas_rtc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, palmas_rtc);\n\n\tif (enable_bb_charging) {\n\t\tunsigned reg = PALMAS_BACKUP_BATTERY_CTRL_BBS_BBC_LOW_ICHRG;\n\n\t\tif (high_bb_charging)\n\t\t\treg = 0;\n\n\t\tret = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\n\t\t\tPALMAS_BACKUP_BATTERY_CTRL,\n\t\t\tPALMAS_BACKUP_BATTERY_CTRL_BBS_BBC_LOW_ICHRG, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"BACKUP_BATTERY_CTRL update failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\n\t\t\tPALMAS_BACKUP_BATTERY_CTRL,\n\t\t\tPALMAS_BACKUP_BATTERY_CTRL_BB_CHG_EN,\n\t\t\tPALMAS_BACKUP_BATTERY_CTRL_BB_CHG_EN);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"BACKUP_BATTERY_CTRL update failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = palmas_update_bits(palmas, PALMAS_RTC_BASE, PALMAS_RTC_CTRL_REG,\n\t\t\tPALMAS_RTC_CTRL_REG_STOP_RTC,\n\t\t\tPALMAS_RTC_CTRL_REG_STOP_RTC);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"RTC_CTRL write failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpalmas_rtc->irq = platform_get_irq(pdev, 0);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tpalmas_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t&palmas_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(palmas_rtc->rtc)) {\n\t\tret = PTR_ERR(palmas_rtc->rtc);\n\t\tdev_err(&pdev->dev, \"RTC register failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, palmas_rtc->irq, NULL,\n\t\t\tpalmas_rtc_interrupt,\n\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\tdev_name(&pdev->dev), palmas_rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"IRQ request failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void palmas_rtc_remove(struct platform_device *pdev)\n{\n\tpalmas_rtc_alarm_irq_enable(&pdev->dev, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int palmas_rtc_suspend(struct device *dev)\n{\n\tstruct palmas_rtc *palmas_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(palmas_rtc->irq);\n\treturn 0;\n}\n\nstatic int palmas_rtc_resume(struct device *dev)\n{\n\tstruct palmas_rtc *palmas_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(palmas_rtc->irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(palmas_rtc_pm_ops, palmas_rtc_suspend,\n\t\t\t palmas_rtc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_palmas_rtc_match[] = {\n\t{ .compatible = \"ti,palmas-rtc\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_palmas_rtc_match);\n#endif\n\nstatic struct platform_driver palmas_rtc_driver = {\n\t.probe\t\t= palmas_rtc_probe,\n\t.remove_new\t= palmas_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"palmas-rtc\",\n\t\t.pm\t= &palmas_rtc_pm_ops,\n\t\t.of_match_table = of_match_ptr(of_palmas_rtc_match),\n\t},\n};\n\nmodule_platform_driver(palmas_rtc_driver);\n\nMODULE_ALIAS(\"platform:palmas_rtc\");\nMODULE_DESCRIPTION(\"TI PALMAS series RTC driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}