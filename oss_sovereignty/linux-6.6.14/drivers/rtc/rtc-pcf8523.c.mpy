{
  "module_name": "rtc-pcf8523.c",
  "hash_id": "61e979d7c9bfd6d9d9297f1ad05f11bfa98e7ea5478f7812203f513d46ca697a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf8523.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n\n#define PCF8523_REG_CONTROL1 0x00\n#define PCF8523_CONTROL1_CAP_SEL BIT(7)\n#define PCF8523_CONTROL1_STOP    BIT(5)\n#define PCF8523_CONTROL1_AIE    BIT(1)\n\n#define PCF8523_REG_CONTROL2 0x01\n#define PCF8523_CONTROL2_AF BIT(3)\n\n#define PCF8523_REG_CONTROL3 0x02\n#define PCF8523_CONTROL3_PM  GENMASK(7, 5)\n#define PCF8523_PM_STANDBY   0x7\n#define PCF8523_CONTROL3_BLF BIT(2)  \n#define PCF8523_CONTROL3_BSF BIT(3)\n\n#define PCF8523_REG_SECONDS  0x03\n#define PCF8523_SECONDS_OS BIT(7)\n\n#define PCF8523_REG_MINUTES  0x04\n#define PCF8523_REG_HOURS    0x05\n#define PCF8523_REG_DAYS     0x06\n#define PCF8523_REG_WEEKDAYS 0x07\n#define PCF8523_REG_MONTHS   0x08\n#define PCF8523_REG_YEARS    0x09\n\n#define PCF8523_REG_MINUTE_ALARM\t0x0a\n#define PCF8523_REG_HOUR_ALARM\t\t0x0b\n#define PCF8523_REG_DAY_ALARM\t\t0x0c\n#define PCF8523_REG_WEEKDAY_ALARM\t0x0d\n#define ALARM_DIS BIT(7)\n\n#define PCF8523_REG_OFFSET   0x0e\n#define PCF8523_OFFSET_MODE BIT(7)\n\n#define PCF8523_TMR_CLKOUT_CTRL 0x0f\n\nstruct pcf8523 {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n};\n\nstatic int pcf8523_load_capacitance(struct pcf8523 *pcf8523, struct device_node *node)\n{\n\tu32 load, value = 0;\n\n\tload = 12500;\n\tof_property_read_u32(node, \"quartz-load-femtofarads\", &load);\n\n\tswitch (load) {\n\tdefault:\n\t\tdev_warn(&pcf8523->rtc->dev, \"Unknown quartz-load-femtofarads value: %d. Assuming 12500\",\n\t\t\t load);\n\t\tfallthrough;\n\tcase 12500:\n\t\tvalue = PCF8523_CONTROL1_CAP_SEL;\n\t\tbreak;\n\tcase 7000:\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL1,\n\t\t\t\t  PCF8523_CONTROL1_CAP_SEL, value);\n}\n\nstatic irqreturn_t pcf8523_irq(int irq, void *dev_id)\n{\n\tstruct pcf8523 *pcf8523 = dev_id;\n\tu32 value;\n\tint err;\n\n\terr = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL2, &value);\n\tif (err < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (value & PCF8523_CONTROL2_AF) {\n\t\tvalue &= ~PCF8523_CONTROL2_AF;\n\t\tregmap_write(pcf8523->regmap, PCF8523_REG_CONTROL2, value);\n\t\trtc_update_irq(pcf8523->rtc, 1, RTC_IRQF | RTC_AF);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int pcf8523_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tu8 regs[10];\n\tint err;\n\n\terr = regmap_bulk_read(pcf8523->regmap, PCF8523_REG_CONTROL1, regs,\n\t\t\t       sizeof(regs));\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((regs[0] & PCF8523_CONTROL1_STOP) || (regs[3] & PCF8523_SECONDS_OS))\n\t\treturn -EINVAL;\n\n\ttm->tm_sec = bcd2bin(regs[3] & 0x7f);\n\ttm->tm_min = bcd2bin(regs[4] & 0x7f);\n\ttm->tm_hour = bcd2bin(regs[5] & 0x3f);\n\ttm->tm_mday = bcd2bin(regs[6] & 0x3f);\n\ttm->tm_wday = regs[7] & 0x7;\n\ttm->tm_mon = bcd2bin(regs[8] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(regs[9]) + 100;\n\n\treturn 0;\n}\n\nstatic int pcf8523_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tu8 regs[7];\n\tint err;\n\n\terr = regmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL1,\n\t\t\t\t PCF8523_CONTROL1_STOP, PCF8523_CONTROL1_STOP);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tregs[0] = bin2bcd(tm->tm_sec);\n\tregs[1] = bin2bcd(tm->tm_min);\n\tregs[2] = bin2bcd(tm->tm_hour);\n\tregs[3] = bin2bcd(tm->tm_mday);\n\tregs[4] = tm->tm_wday;\n\tregs[5] = bin2bcd(tm->tm_mon + 1);\n\tregs[6] = bin2bcd(tm->tm_year - 100);\n\n\terr = regmap_bulk_write(pcf8523->regmap, PCF8523_REG_SECONDS, regs,\n\t\t\t\tsizeof(regs));\n\tif (err < 0) {\n\t\t \n\t\tregmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL1,\n\t\t\t\t   PCF8523_CONTROL1_STOP, 0);\n\t\treturn err;\n\t}\n\n\treturn regmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL1,\n\t\t\t\t PCF8523_CONTROL1_STOP, 0);\n}\n\nstatic int pcf8523_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tu8 regs[4];\n\tu32 value;\n\tint err;\n\n\terr = regmap_bulk_read(pcf8523->regmap, PCF8523_REG_MINUTE_ALARM, regs,\n\t\t\t       sizeof(regs));\n\tif (err < 0)\n\t\treturn err;\n\n\ttm->time.tm_sec = 0;\n\ttm->time.tm_min = bcd2bin(regs[0] & 0x7F);\n\ttm->time.tm_hour = bcd2bin(regs[1] & 0x3F);\n\ttm->time.tm_mday = bcd2bin(regs[2] & 0x3F);\n\ttm->time.tm_wday = bcd2bin(regs[3] & 0x7);\n\n\terr = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL1, &value);\n\tif (err < 0)\n\t\treturn err;\n\ttm->enabled = !!(value & PCF8523_CONTROL1_AIE);\n\n\terr = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL2, &value);\n\tif (err < 0)\n\t\treturn err;\n\ttm->pending = !!(value & PCF8523_CONTROL2_AF);\n\n\treturn 0;\n}\n\nstatic int pcf8523_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL1,\n\t\t\t\t  PCF8523_CONTROL1_AIE, enabled ?\n\t\t\t\t  PCF8523_CONTROL1_AIE : 0);\n}\n\nstatic int pcf8523_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tu8 regs[5];\n\tint err;\n\n\terr = pcf8523_irq_enable(dev, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(pcf8523->regmap, PCF8523_REG_CONTROL2, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tregs[0] = bin2bcd(tm->time.tm_min);\n\tregs[1] = bin2bcd(tm->time.tm_hour);\n\tregs[2] = bin2bcd(tm->time.tm_mday);\n\tregs[3] = ALARM_DIS;\n\n\terr = regmap_bulk_write(pcf8523->regmap, PCF8523_REG_MINUTE_ALARM, regs,\n\t\t\t\tsizeof(regs));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tm->enabled)\n\t\treturn pcf8523_irq_enable(dev, tm->enabled);\n\n\treturn 0;\n}\n\nstatic int pcf8523_param_get(struct device *dev, struct rtc_param *param)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tint ret;\n\tu32 value;\n\n\tswitch (param->param) {\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tret = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL3, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue = FIELD_GET(PCF8523_CONTROL3_PM, value);\n\n\t\tswitch (value) {\n\t\tcase 0x0:\n\t\tcase 0x4:\n\t\t\tparam->uvalue = RTC_BSM_LEVEL;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\tcase 0x5:\n\t\t\tparam->uvalue = RTC_BSM_DIRECT;\n\t\t\tbreak;\n\t\tcase PCF8523_PM_STANDBY:\n\t\t\tparam->uvalue = RTC_BSM_STANDBY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->uvalue = RTC_BSM_DISABLED;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf8523_param_set(struct device *dev, struct rtc_param *param)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tu8 mode;\n\n\tswitch (param->param) {\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tswitch (param->uvalue) {\n\t\tcase RTC_BSM_DISABLED:\n\t\t\tmode = 0x2;\n\t\t\tbreak;\n\t\tcase RTC_BSM_DIRECT:\n\t\t\tmode = 0x1;\n\t\t\tbreak;\n\t\tcase RTC_BSM_LEVEL:\n\t\t\tmode = 0x0;\n\t\t\tbreak;\n\t\tcase RTC_BSM_STANDBY:\n\t\t\tmode = PCF8523_PM_STANDBY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn regmap_update_bits(pcf8523->regmap, PCF8523_REG_CONTROL3,\n\t\t\t\t\t  PCF8523_CONTROL3_PM,\n\t\t\t\t\t  FIELD_PREP(PCF8523_CONTROL3_PM, mode));\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf8523_rtc_ioctl(struct device *dev, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tunsigned int flags = 0;\n\tu32 value;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL3, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (value & PCF8523_CONTROL3_BLF)\n\t\t\tflags |= RTC_VL_BACKUP_LOW;\n\n\t\tret = regmap_read(pcf8523->regmap, PCF8523_REG_SECONDS, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (value & PCF8523_SECONDS_OS)\n\t\t\tflags |= RTC_VL_DATA_INVALID;\n\n\t\treturn put_user(flags, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int pcf8523_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tint err;\n\tu32 value;\n\ts8 val;\n\n\terr = regmap_read(pcf8523->regmap, PCF8523_REG_OFFSET, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tval = value << 1;\n\t*offset = (value & PCF8523_OFFSET_MODE ? 4069 : 4340) * (val >> 1);\n\n\treturn 0;\n}\n\nstatic int pcf8523_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct pcf8523 *pcf8523 = dev_get_drvdata(dev);\n\tlong reg_m0, reg_m1;\n\tu32 value;\n\n\treg_m0 = clamp(DIV_ROUND_CLOSEST(offset, 4340), -64L, 63L);\n\treg_m1 = clamp(DIV_ROUND_CLOSEST(offset, 4069), -64L, 63L);\n\n\tif (abs(reg_m0 * 4340 - offset) < abs(reg_m1 * 4069 - offset))\n\t\tvalue = reg_m0 & 0x7f;\n\telse\n\t\tvalue = (reg_m1 & 0x7f) | PCF8523_OFFSET_MODE;\n\n\treturn regmap_write(pcf8523->regmap, PCF8523_REG_OFFSET, value);\n}\n\nstatic const struct rtc_class_ops pcf8523_rtc_ops = {\n\t.read_time = pcf8523_rtc_read_time,\n\t.set_time = pcf8523_rtc_set_time,\n\t.read_alarm = pcf8523_rtc_read_alarm,\n\t.set_alarm = pcf8523_rtc_set_alarm,\n\t.alarm_irq_enable = pcf8523_irq_enable,\n\t.ioctl = pcf8523_rtc_ioctl,\n\t.read_offset = pcf8523_rtc_read_offset,\n\t.set_offset = pcf8523_rtc_set_offset,\n\t.param_get = pcf8523_param_get,\n\t.param_set = pcf8523_param_set,\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x13,\n};\n\nstatic int pcf8523_probe(struct i2c_client *client)\n{\n\tstruct pcf8523 *pcf8523;\n\tstruct rtc_device *rtc;\n\tbool wakeup_source = false;\n\tu32 value;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tpcf8523 = devm_kzalloc(&client->dev, sizeof(struct pcf8523), GFP_KERNEL);\n\tif (!pcf8523)\n\t\treturn -ENOMEM;\n\n\tpcf8523->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(pcf8523->regmap))\n\t\treturn PTR_ERR(pcf8523->regmap);\n\n\ti2c_set_clientdata(client, pcf8523);\n\n\trtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\tpcf8523->rtc = rtc;\n\n\terr = pcf8523_load_capacitance(pcf8523, client->dev.of_node);\n\tif (err < 0)\n\t\tdev_warn(&client->dev, \"failed to set xtal load capacitance: %d\",\n\t\t\t err);\n\n\terr = regmap_read(pcf8523->regmap, PCF8523_REG_SECONDS, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (value & PCF8523_SECONDS_OS) {\n\t\terr = regmap_read(pcf8523->regmap, PCF8523_REG_CONTROL3, &value);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (FIELD_GET(PCF8523_CONTROL3_PM, value) == PCF8523_PM_STANDBY) {\n\t\t\terr = regmap_write(pcf8523->regmap, PCF8523_REG_CONTROL3,\n\t\t\t\t\t   value & ~PCF8523_CONTROL3_PM);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\trtc->ops = &pcf8523_rtc_ops;\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->range_max = RTC_TIMESTAMP_END_2099;\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\terr = regmap_write(pcf8523->regmap, PCF8523_TMR_CLKOUT_CTRL, 0x38);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, pcf8523_irq,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT | irqflags,\n\t\t\t\t\t\tdev_name(&rtc->dev), pcf8523);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_pm_set_wake_irq(&client->dev, client->irq);\n\t}\n\n\twakeup_source = of_property_read_bool(client->dev.of_node, \"wakeup-source\");\n\tif (client->irq > 0 || wakeup_source)\n\t\tdevice_init_wakeup(&client->dev, true);\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic const struct i2c_device_id pcf8523_id[] = {\n\t{ \"pcf8523\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf8523_id);\n\nstatic const struct of_device_id pcf8523_of_match[] = {\n\t{ .compatible = \"nxp,pcf8523\" },\n\t{ .compatible = \"microcrystal,rv8523\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pcf8523_of_match);\n\nstatic struct i2c_driver pcf8523_driver = {\n\t.driver = {\n\t\t.name = \"rtc-pcf8523\",\n\t\t.of_match_table = pcf8523_of_match,\n\t},\n\t.probe = pcf8523_probe,\n\t.id_table = pcf8523_id,\n};\nmodule_i2c_driver(pcf8523_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <thierry.reding@avionic-design.de>\");\nMODULE_DESCRIPTION(\"NXP PCF8523 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}