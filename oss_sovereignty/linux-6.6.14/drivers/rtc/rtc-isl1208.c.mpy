{
  "module_name": "rtc-isl1208.c",
  "hash_id": "bc9290ad72397701fa3536f6ed28fcc348ea6d3ea83f405ab271cb5b050d3d5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-isl1208.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/rtc.h>\n\n \n \n#define ISL1208_REG_SC  0x00\n#define ISL1208_REG_MN  0x01\n#define ISL1208_REG_HR  0x02\n#define ISL1208_REG_HR_MIL     (1<<7)\t \n#define ISL1208_REG_HR_PM      (1<<5)\t \n#define ISL1208_REG_DT  0x03\n#define ISL1208_REG_MO  0x04\n#define ISL1208_REG_YR  0x05\n#define ISL1208_REG_DW  0x06\n#define ISL1208_RTC_SECTION_LEN 7\n\n \n#define ISL1208_REG_SR  0x07\n#define ISL1208_REG_SR_ARST    (1<<7)\t \n#define ISL1208_REG_SR_XTOSCB  (1<<6)\t \n#define ISL1208_REG_SR_WRTC    (1<<4)\t \n#define ISL1208_REG_SR_EVT     (1<<3)\t \n#define ISL1208_REG_SR_ALM     (1<<2)\t \n#define ISL1208_REG_SR_BAT     (1<<1)\t \n#define ISL1208_REG_SR_RTCF    (1<<0)\t \n#define ISL1208_REG_INT 0x08\n#define ISL1208_REG_INT_ALME   (1<<6)    \n#define ISL1208_REG_INT_IM     (1<<7)    \n#define ISL1219_REG_EV  0x09\n#define ISL1219_REG_EV_EVEN    (1<<4)    \n#define ISL1219_REG_EV_EVIENB  (1<<7)    \n#define ISL1208_REG_ATR 0x0a\n#define ISL1208_REG_DTR 0x0b\n\n \n#define ISL1208_REG_SCA 0x0c\n#define ISL1208_REG_MNA 0x0d\n#define ISL1208_REG_HRA 0x0e\n#define ISL1208_REG_DTA 0x0f\n#define ISL1208_REG_MOA 0x10\n#define ISL1208_REG_DWA 0x11\n#define ISL1208_ALARM_SECTION_LEN 6\n\n \n#define ISL1208_REG_USR1 0x12\n#define ISL1208_REG_USR2 0x13\n#define ISL1208_USR_SECTION_LEN 2\n\n \n#define ISL1219_REG_SCT 0x14\n#define ISL1219_REG_MNT 0x15\n#define ISL1219_REG_HRT 0x16\n#define ISL1219_REG_DTT 0x17\n#define ISL1219_REG_MOT 0x18\n#define ISL1219_REG_YRT 0x19\n#define ISL1219_EVT_SECTION_LEN 6\n\nstatic struct i2c_driver isl1208_driver;\n\n \nstruct isl1208_config {\n\tunsigned int\tnvmem_length;\n\tunsigned\thas_tamper:1;\n\tunsigned\thas_timestamp:1;\n\tunsigned\thas_inverted_osc_bit:1;\n};\n\nstatic const struct isl1208_config config_isl1208 = {\n\t.nvmem_length = 2,\n\t.has_tamper = false,\n\t.has_timestamp = false\n};\n\nstatic const struct isl1208_config config_isl1209 = {\n\t.nvmem_length = 2,\n\t.has_tamper = true,\n\t.has_timestamp = false\n};\n\nstatic const struct isl1208_config config_isl1218 = {\n\t.nvmem_length = 8,\n\t.has_tamper = false,\n\t.has_timestamp = false\n};\n\nstatic const struct isl1208_config config_isl1219 = {\n\t.nvmem_length = 2,\n\t.has_tamper = true,\n\t.has_timestamp = true\n};\n\nstatic const struct isl1208_config config_raa215300_a0 = {\n\t.nvmem_length = 2,\n\t.has_tamper = false,\n\t.has_timestamp = false,\n\t.has_inverted_osc_bit = true\n};\n\nstatic const struct i2c_device_id isl1208_id[] = {\n\t{ \"isl1208\", .driver_data = (kernel_ulong_t)&config_isl1208 },\n\t{ \"isl1209\", .driver_data = (kernel_ulong_t)&config_isl1209 },\n\t{ \"isl1218\", .driver_data = (kernel_ulong_t)&config_isl1218 },\n\t{ \"isl1219\", .driver_data = (kernel_ulong_t)&config_isl1219 },\n\t{ \"raa215300_a0\", .driver_data = (kernel_ulong_t)&config_raa215300_a0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, isl1208_id);\n\nstatic const __maybe_unused struct of_device_id isl1208_of_match[] = {\n\t{ .compatible = \"isil,isl1208\", .data = &config_isl1208 },\n\t{ .compatible = \"isil,isl1209\", .data = &config_isl1209 },\n\t{ .compatible = \"isil,isl1218\", .data = &config_isl1218 },\n\t{ .compatible = \"isil,isl1219\", .data = &config_isl1219 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, isl1208_of_match);\n\n \nstruct isl1208_state {\n\tstruct nvmem_config nvmem_config;\n\tstruct rtc_device *rtc;\n\tconst struct isl1208_config *config;\n};\n\n \nstatic int\nisl1208_i2c_read_regs(struct i2c_client *client, u8 reg, u8 buf[],\n\t\t      unsigned len)\n{\n\tint ret;\n\n\tWARN_ON(reg > ISL1219_REG_YRT);\n\tWARN_ON(reg + len > ISL1219_REG_YRT + 1);\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, len, buf);\n\treturn (ret < 0) ? ret : 0;\n}\n\n \nstatic int\nisl1208_i2c_set_regs(struct i2c_client *client, u8 reg, u8 const buf[],\n\t\t     unsigned len)\n{\n\tint ret;\n\n\tWARN_ON(reg > ISL1219_REG_YRT);\n\tWARN_ON(reg + len > ISL1219_REG_YRT + 1);\n\n\tret = i2c_smbus_write_i2c_block_data(client, reg, len, buf);\n\treturn (ret < 0) ? ret : 0;\n}\n\n \nstatic int\nisl1208_i2c_validate_client(struct i2c_client *client)\n{\n\tu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\n\tu8 zero_mask[ISL1208_RTC_SECTION_LEN] = {\n\t\t0x80, 0x80, 0x40, 0xc0, 0xe0, 0x00, 0xf8\n\t};\n\tint i;\n\tint ret;\n\n\tret = isl1208_i2c_read_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ISL1208_RTC_SECTION_LEN; ++i) {\n\t\tif (regs[i] & zero_mask[i])\t \n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int isl1208_set_xtoscb(struct i2c_client *client, int sr, int xtosb_val)\n{\n\t \n\tif (!!(sr & ISL1208_REG_SR_XTOSCB) == xtosb_val)\n\t\treturn 0;\n\n\tif (xtosb_val)\n\t\tsr |= ISL1208_REG_SR_XTOSCB;\n\telse\n\t\tsr &= ~ISL1208_REG_SR_XTOSCB;\n\n\treturn i2c_smbus_write_byte_data(client, ISL1208_REG_SR, sr);\n}\n\nstatic int\nisl1208_i2c_get_sr(struct i2c_client *client)\n{\n\treturn i2c_smbus_read_byte_data(client, ISL1208_REG_SR);\n}\n\nstatic int\nisl1208_i2c_get_atr(struct i2c_client *client)\n{\n\tint atr = i2c_smbus_read_byte_data(client, ISL1208_REG_ATR);\n\tif (atr < 0)\n\t\treturn atr;\n\n\t \n\n\tatr &= 0x3f;\t\t \n\tatr ^= 1 << 5;\t\t \n\tatr += 2 * 9;\t\t \n\n\treturn atr;\n}\n\n \nstatic int\nisl1208_i2c_get_dtr(struct i2c_client *client)\n{\n\tint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\n\tif (dtr < 0)\n\t\treturn -EIO;\n\n\t \n\tdtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\n\n\treturn dtr + 100;\n}\n\nstatic int\nisl1208_i2c_get_usr(struct i2c_client *client)\n{\n\tu8 buf[ISL1208_USR_SECTION_LEN] = { 0, };\n\tint ret;\n\n\tret = isl1208_i2c_read_regs(client, ISL1208_REG_USR1, buf,\n\t\t\t\t    ISL1208_USR_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (buf[1] << 8) | buf[0];\n}\n\nstatic int\nisl1208_i2c_set_usr(struct i2c_client *client, u16 usr)\n{\n\tu8 buf[ISL1208_USR_SECTION_LEN];\n\n\tbuf[0] = usr & 0xff;\n\tbuf[1] = (usr >> 8) & 0xff;\n\n\treturn isl1208_i2c_set_regs(client, ISL1208_REG_USR1, buf,\n\t\t\t\t    ISL1208_USR_SECTION_LEN);\n}\n\nstatic int\nisl1208_rtc_toggle_alarm(struct i2c_client *client, int enable)\n{\n\tint icr = i2c_smbus_read_byte_data(client, ISL1208_REG_INT);\n\n\tif (icr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading INT failed\\n\", __func__);\n\t\treturn icr;\n\t}\n\n\tif (enable)\n\t\ticr |= ISL1208_REG_INT_ALME | ISL1208_REG_INT_IM;\n\telse\n\t\ticr &= ~(ISL1208_REG_INT_ALME | ISL1208_REG_INT_IM);\n\n\ticr = i2c_smbus_write_byte_data(client, ISL1208_REG_INT, icr);\n\tif (icr < 0) {\n\t\tdev_err(&client->dev, \"%s: writing INT failed\\n\", __func__);\n\t\treturn icr;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nisl1208_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct i2c_client *const client = to_i2c_client(dev);\n\tint sr, dtr, atr, usr;\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\tseq_printf(seq, \"status_reg\\t:%s%s%s%s%s%s (0x%.2x)\\n\",\n\t\t   (sr & ISL1208_REG_SR_RTCF) ? \" RTCF\" : \"\",\n\t\t   (sr & ISL1208_REG_SR_BAT) ? \" BAT\" : \"\",\n\t\t   (sr & ISL1208_REG_SR_ALM) ? \" ALM\" : \"\",\n\t\t   (sr & ISL1208_REG_SR_WRTC) ? \" WRTC\" : \"\",\n\t\t   (sr & ISL1208_REG_SR_XTOSCB) ? \" XTOSCB\" : \"\",\n\t\t   (sr & ISL1208_REG_SR_ARST) ? \" ARST\" : \"\", sr);\n\n\tseq_printf(seq, \"batt_status\\t: %s\\n\",\n\t\t   (sr & ISL1208_REG_SR_RTCF) ? \"bad\" : \"okay\");\n\n\tdtr = isl1208_i2c_get_dtr(client);\n\tif (dtr >= 0)\n\t\tseq_printf(seq, \"digital_trim\\t: %d ppm\\n\", dtr - 100);\n\n\tatr = isl1208_i2c_get_atr(client);\n\tif (atr >= 0)\n\t\tseq_printf(seq, \"analog_trim\\t: %d.%.2d pF\\n\",\n\t\t\t   atr >> 2, (atr & 0x3) * 25);\n\n\tusr = isl1208_i2c_get_usr(client);\n\tif (usr >= 0)\n\t\tseq_printf(seq, \"user_data\\t: 0x%.4x\\n\", usr);\n\n\treturn 0;\n}\n\nstatic int\nisl1208_i2c_read_time(struct i2c_client *client, struct rtc_time *tm)\n{\n\tint sr;\n\tu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsr = isl1208_i2c_read_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading RTC section failed\\n\",\n\t\t\t__func__);\n\t\treturn sr;\n\t}\n\n\ttm->tm_sec = bcd2bin(regs[ISL1208_REG_SC]);\n\ttm->tm_min = bcd2bin(regs[ISL1208_REG_MN]);\n\n\t \n\t{\n\t\tconst u8 _hr = regs[ISL1208_REG_HR];\n\t\tif (_hr & ISL1208_REG_HR_MIL)\t \n\t\t\ttm->tm_hour = bcd2bin(_hr & 0x3f);\n\t\telse {\n\t\t\t \n\t\t\ttm->tm_hour = bcd2bin(_hr & 0x1f);\n\t\t\tif (_hr & ISL1208_REG_HR_PM)\t \n\t\t\t\ttm->tm_hour += 12;\n\t\t}\n\t}\n\n\ttm->tm_mday = bcd2bin(regs[ISL1208_REG_DT]);\n\ttm->tm_mon = bcd2bin(regs[ISL1208_REG_MO]) - 1;\t \n\ttm->tm_year = bcd2bin(regs[ISL1208_REG_YR]) + 100;\n\ttm->tm_wday = bcd2bin(regs[ISL1208_REG_DW]);\n\n\treturn 0;\n}\n\nstatic int\nisl1208_i2c_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alarm)\n{\n\tstruct rtc_time *const tm = &alarm->time;\n\tu8 regs[ISL1208_ALARM_SECTION_LEN] = { 0, };\n\tint icr, yr, sr = isl1208_i2c_get_sr(client);\n\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\tsr = isl1208_i2c_read_regs(client, ISL1208_REG_SCA, regs,\n\t\t\t\t   ISL1208_ALARM_SECTION_LEN);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading alarm section failed\\n\",\n\t\t\t__func__);\n\t\treturn sr;\n\t}\n\n\t \n\ttm->tm_sec = bcd2bin(regs[ISL1208_REG_SCA - ISL1208_REG_SCA] & 0x7f);\n\ttm->tm_min = bcd2bin(regs[ISL1208_REG_MNA - ISL1208_REG_SCA] & 0x7f);\n\ttm->tm_hour = bcd2bin(regs[ISL1208_REG_HRA - ISL1208_REG_SCA] & 0x3f);\n\ttm->tm_mday = bcd2bin(regs[ISL1208_REG_DTA - ISL1208_REG_SCA] & 0x3f);\n\ttm->tm_mon =\n\t\tbcd2bin(regs[ISL1208_REG_MOA - ISL1208_REG_SCA] & 0x1f) - 1;\n\ttm->tm_wday = bcd2bin(regs[ISL1208_REG_DWA - ISL1208_REG_SCA] & 0x03);\n\n\t \n\tyr = i2c_smbus_read_byte_data(client, ISL1208_REG_YR);\n\tif (yr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading RTC YR failed\\n\", __func__);\n\t\treturn yr;\n\t}\n\ttm->tm_year = bcd2bin(yr) + 100;\n\n\ticr = i2c_smbus_read_byte_data(client, ISL1208_REG_INT);\n\tif (icr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading INT failed\\n\", __func__);\n\t\treturn icr;\n\t}\n\talarm->enabled = !!(icr & ISL1208_REG_INT_ALME);\n\n\treturn 0;\n}\n\nstatic int\nisl1208_i2c_set_alarm(struct i2c_client *client, struct rtc_wkalrm *alarm)\n{\n\tstruct rtc_time *alarm_tm = &alarm->time;\n\tu8 regs[ISL1208_ALARM_SECTION_LEN] = { 0, };\n\tconst int offs = ISL1208_REG_SCA;\n\tstruct rtc_time rtc_tm;\n\tint err, enable;\n\n\terr = isl1208_i2c_read_time(client, &rtc_tm);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!alarm->enabled || rtc_tm_sub(alarm_tm, &rtc_tm) <= 0)\n\t\tenable = 0x00;\n\telse\n\t\tenable = 0x80;\n\n\t \n\tregs[ISL1208_REG_SCA - offs] = bin2bcd(alarm_tm->tm_sec) | enable;\n\tregs[ISL1208_REG_MNA - offs] = bin2bcd(alarm_tm->tm_min) | enable;\n\tregs[ISL1208_REG_HRA - offs] = bin2bcd(alarm_tm->tm_hour) |\n\t\tISL1208_REG_HR_MIL | enable;\n\n\tregs[ISL1208_REG_DTA - offs] = bin2bcd(alarm_tm->tm_mday) | enable;\n\tregs[ISL1208_REG_MOA - offs] = bin2bcd(alarm_tm->tm_mon + 1) | enable;\n\tregs[ISL1208_REG_DWA - offs] = bin2bcd(alarm_tm->tm_wday & 7) | enable;\n\n\t \n\terr = isl1208_i2c_set_regs(client, offs, regs,\n\t\t\t\t  ISL1208_ALARM_SECTION_LEN);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s: writing ALARM section failed\\n\",\n\t\t\t__func__);\n\t\treturn err;\n\t}\n\n\terr = isl1208_rtc_toggle_alarm(client, enable);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nisl1208_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\treturn isl1208_i2c_read_time(to_i2c_client(dev), tm);\n}\n\nstatic int\nisl1208_i2c_set_time(struct i2c_client *client, struct rtc_time const *tm)\n{\n\tint sr;\n\tu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\n\n\t \n\tif (tm->tm_year < 100)\n\t\treturn -EINVAL;\n\n\tregs[ISL1208_REG_SC] = bin2bcd(tm->tm_sec);\n\tregs[ISL1208_REG_MN] = bin2bcd(tm->tm_min);\n\tregs[ISL1208_REG_HR] = bin2bcd(tm->tm_hour) | ISL1208_REG_HR_MIL;\n\n\tregs[ISL1208_REG_DT] = bin2bcd(tm->tm_mday);\n\tregs[ISL1208_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\tregs[ISL1208_REG_YR] = bin2bcd(tm->tm_year - 100);\n\n\tregs[ISL1208_REG_DW] = bin2bcd(tm->tm_wday & 7);\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\t \n\tsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR,\n\t\t\t\t       sr | ISL1208_REG_SR_WRTC);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: writing SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\t \n\tsr = isl1208_i2c_set_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: writing RTC section failed\\n\",\n\t\t\t__func__);\n\t\treturn sr;\n\t}\n\n\t \n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\tsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR,\n\t\t\t\t       sr & ~ISL1208_REG_SR_WRTC);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"%s: writing SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nisl1208_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\treturn isl1208_i2c_set_time(to_i2c_client(dev), tm);\n}\n\nstatic int\nisl1208_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\treturn isl1208_i2c_read_alarm(to_i2c_client(dev), alarm);\n}\n\nstatic int\nisl1208_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\treturn isl1208_i2c_set_alarm(to_i2c_client(dev), alarm);\n}\n\nstatic ssize_t timestamp0_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tint sr;\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\tsr &= ~ISL1208_REG_SR_EVT;\n\n\tsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR, sr);\n\tif (sr < 0)\n\t\tdev_err(dev, \"%s: writing SR failed\\n\",\n\t\t\t__func__);\n\n\treturn count;\n};\n\nstatic ssize_t timestamp0_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tu8 regs[ISL1219_EVT_SECTION_LEN] = { 0, };\n\tstruct rtc_time tm;\n\tint sr;\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(dev, \"%s: reading SR failed\\n\", __func__);\n\t\treturn sr;\n\t}\n\n\tif (!(sr & ISL1208_REG_SR_EVT))\n\t\treturn 0;\n\n\tsr = isl1208_i2c_read_regs(client, ISL1219_REG_SCT, regs,\n\t\t\t\t   ISL1219_EVT_SECTION_LEN);\n\tif (sr < 0) {\n\t\tdev_err(dev, \"%s: reading event section failed\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\t \n\ttm.tm_sec = bcd2bin(regs[ISL1219_REG_SCT - ISL1219_REG_SCT] & 0x7f);\n\ttm.tm_min = bcd2bin(regs[ISL1219_REG_MNT - ISL1219_REG_SCT] & 0x7f);\n\ttm.tm_hour = bcd2bin(regs[ISL1219_REG_HRT - ISL1219_REG_SCT] & 0x3f);\n\ttm.tm_mday = bcd2bin(regs[ISL1219_REG_DTT - ISL1219_REG_SCT] & 0x3f);\n\ttm.tm_mon =\n\t\tbcd2bin(regs[ISL1219_REG_MOT - ISL1219_REG_SCT] & 0x1f) - 1;\n\ttm.tm_year = bcd2bin(regs[ISL1219_REG_YRT - ISL1219_REG_SCT]) + 100;\n\n\tsr = rtc_valid_tm(&tm);\n\tif (sr)\n\t\treturn sr;\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t\t\t(unsigned long long)rtc_tm_to_time64(&tm));\n};\n\nstatic DEVICE_ATTR_RW(timestamp0);\n\nstatic irqreturn_t\nisl1208_rtc_interrupt(int irq, void *data)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\tstruct i2c_client *client = data;\n\tstruct isl1208_state *isl1208 = i2c_get_clientdata(client);\n\tint handled = 0, sr, err;\n\n\t \n\twhile (1) {\n\t\tsr = isl1208_i2c_get_sr(client);\n\t\tif (sr >= 0)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&client->dev, \"%s: reading SR failed\\n\",\n\t\t\t\t__func__);\n\t\t\treturn sr;\n\t\t}\n\t}\n\n\tif (sr & ISL1208_REG_SR_ALM) {\n\t\tdev_dbg(&client->dev, \"alarm!\\n\");\n\n\t\trtc_update_irq(isl1208->rtc, 1, RTC_IRQF | RTC_AF);\n\n\t\t \n\t\tsr &= ~ISL1208_REG_SR_ALM;\n\t\tsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR, sr);\n\t\tif (sr < 0)\n\t\t\tdev_err(&client->dev, \"%s: writing SR failed\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\thandled = 1;\n\n\t\t \n\t\terr = isl1208_rtc_toggle_alarm(client, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (isl1208->config->has_tamper && (sr & ISL1208_REG_SR_EVT)) {\n\t\tdev_warn(&client->dev, \"event detected\");\n\t\thandled = 1;\n\t\tif (isl1208->config->has_timestamp)\n\t\t\tsysfs_notify(&isl1208->rtc->dev.kobj, NULL,\n\t\t\t\t     dev_attr_timestamp0.attr.name);\n\t}\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic const struct rtc_class_ops isl1208_rtc_ops = {\n\t.proc = isl1208_rtc_proc,\n\t.read_time = isl1208_rtc_read_time,\n\t.set_time = isl1208_rtc_set_time,\n\t.read_alarm = isl1208_rtc_read_alarm,\n\t.set_alarm = isl1208_rtc_set_alarm,\n};\n\n \n\nstatic ssize_t\nisl1208_sysfs_show_atrim(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint atr = isl1208_i2c_get_atr(to_i2c_client(dev->parent));\n\tif (atr < 0)\n\t\treturn atr;\n\n\treturn sprintf(buf, \"%d.%.2d pF\\n\", atr >> 2, (atr & 0x3) * 25);\n}\n\nstatic DEVICE_ATTR(atrim, S_IRUGO, isl1208_sysfs_show_atrim, NULL);\n\nstatic ssize_t\nisl1208_sysfs_show_dtrim(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint dtr = isl1208_i2c_get_dtr(to_i2c_client(dev->parent));\n\tif (dtr < 0)\n\t\treturn dtr;\n\n\treturn sprintf(buf, \"%d ppm\\n\", dtr - 100);\n}\n\nstatic DEVICE_ATTR(dtrim, S_IRUGO, isl1208_sysfs_show_dtrim, NULL);\n\nstatic ssize_t\nisl1208_sysfs_show_usr(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tint usr = isl1208_i2c_get_usr(to_i2c_client(dev->parent));\n\tif (usr < 0)\n\t\treturn usr;\n\n\treturn sprintf(buf, \"0x%.4x\\n\", usr);\n}\n\nstatic ssize_t\nisl1208_sysfs_store_usr(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint usr = -1;\n\n\tif (buf[0] == '0' && (buf[1] == 'x' || buf[1] == 'X')) {\n\t\tif (sscanf(buf, \"%x\", &usr) != 1)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sscanf(buf, \"%d\", &usr) != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (usr < 0 || usr > 0xffff)\n\t\treturn -EINVAL;\n\n\tif (isl1208_i2c_set_usr(to_i2c_client(dev->parent), usr))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(usr, S_IRUGO | S_IWUSR, isl1208_sysfs_show_usr,\n\t\t   isl1208_sysfs_store_usr);\n\nstatic struct attribute *isl1208_rtc_attrs[] = {\n\t&dev_attr_atrim.attr,\n\t&dev_attr_dtrim.attr,\n\t&dev_attr_usr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group isl1208_rtc_sysfs_files = {\n\t.attrs\t= isl1208_rtc_attrs,\n};\n\nstatic struct attribute *isl1219_rtc_attrs[] = {\n\t&dev_attr_timestamp0.attr,\n\tNULL\n};\n\nstatic const struct attribute_group isl1219_rtc_sysfs_files = {\n\t.attrs\t= isl1219_rtc_attrs,\n};\n\nstatic int isl1208_nvmem_read(void *priv, unsigned int off, void *buf,\n\t\t\t      size_t count)\n{\n\tstruct isl1208_state *isl1208 = priv;\n\tstruct i2c_client *client = to_i2c_client(isl1208->rtc->dev.parent);\n\tint ret;\n\n\t \n\tif (!count)\n\t\treturn count;\n\tret = isl1208_i2c_read_regs(client, ISL1208_REG_USR1 + off, buf,\n\t\t\t\t    count);\n\treturn ret == 0 ? count : ret;\n}\n\nstatic int isl1208_nvmem_write(void *priv, unsigned int off, void *buf,\n\t\t\t       size_t count)\n{\n\tstruct isl1208_state *isl1208 = priv;\n\tstruct i2c_client *client = to_i2c_client(isl1208->rtc->dev.parent);\n\tint ret;\n\n\t \n\tif (!count)\n\t\treturn count;\n\tret = isl1208_i2c_set_regs(client, ISL1208_REG_USR1 + off, buf,\n\t\t\t\t   count);\n\n\treturn ret == 0 ? count : ret;\n}\n\nstatic const struct nvmem_config isl1208_nvmem_config = {\n\t.name = \"isl1208_nvram\",\n\t.word_size = 1,\n\t.stride = 1,\n\t \n\t.reg_read = isl1208_nvmem_read,\n\t.reg_write = isl1208_nvmem_write,\n};\n\nstatic int isl1208_setup_irq(struct i2c_client *client, int irq)\n{\n\tint rc = devm_request_threaded_irq(&client->dev, irq, NULL,\n\t\t\t\t\tisl1208_rtc_interrupt,\n\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\tisl1208_driver.driver.name,\n\t\t\t\t\tclient);\n\tif (!rc) {\n\t\tdevice_init_wakeup(&client->dev, 1);\n\t\tenable_irq_wake(irq);\n\t} else {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to request irq %d, no alarm support\\n\",\n\t\t\tirq);\n\t}\n\treturn rc;\n}\n\nstatic int\nisl1208_clk_present(struct i2c_client *client, const char *name)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get_optional(&client->dev, name);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\treturn !!clk;\n}\n\nstatic int\nisl1208_probe(struct i2c_client *client)\n{\n\tstruct isl1208_state *isl1208;\n\tint evdet_irq = -1;\n\tint xtosb_val = 0;\n\tint rc = 0;\n\tint sr;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tif (isl1208_i2c_validate_client(client) < 0)\n\t\treturn -ENODEV;\n\n\t \n\tisl1208 = devm_kzalloc(&client->dev, sizeof(*isl1208), GFP_KERNEL);\n\tif (!isl1208)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(client, isl1208);\n\n\t \n\tisl1208->config = i2c_get_match_data(client);\n\tif (!isl1208->config)\n\t\treturn -ENODEV;\n\n\trc = isl1208_clk_present(client, \"xin\");\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!rc) {\n\t\trc = isl1208_clk_present(client, \"clkin\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc)\n\t\t\txtosb_val = 1;\n\t}\n\n\tisl1208->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(isl1208->rtc))\n\t\treturn PTR_ERR(isl1208->rtc);\n\n\tisl1208->rtc->ops = &isl1208_rtc_ops;\n\n\t \n\tisl1208->nvmem_config = isl1208_nvmem_config;\n\tisl1208->nvmem_config.size = isl1208->config->nvmem_length;\n\tisl1208->nvmem_config.priv = isl1208;\n\n\tsr = isl1208_i2c_get_sr(client);\n\tif (sr < 0) {\n\t\tdev_err(&client->dev, \"reading status failed\\n\");\n\t\treturn sr;\n\t}\n\n\tif (isl1208->config->has_inverted_osc_bit)\n\t\txtosb_val = !xtosb_val;\n\n\trc = isl1208_set_xtoscb(client, sr, xtosb_val);\n\tif (rc)\n\t\treturn rc;\n\n\tif (sr & ISL1208_REG_SR_RTCF)\n\t\tdev_warn(&client->dev, \"rtc power failure detected, \"\n\t\t\t \"please set clock.\\n\");\n\n\tif (isl1208->config->has_tamper) {\n\t\tstruct device_node *np = client->dev.of_node;\n\t\tu32 evienb;\n\n\t\trc = i2c_smbus_read_byte_data(client, ISL1219_REG_EV);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&client->dev, \"failed to read EV reg\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc |= ISL1219_REG_EV_EVEN;\n\t\tif (!of_property_read_u32(np, \"isil,ev-evienb\", &evienb)) {\n\t\t\tif (evienb)\n\t\t\t\trc |= ISL1219_REG_EV_EVIENB;\n\t\t\telse\n\t\t\t\trc &= ~ISL1219_REG_EV_EVIENB;\n\t\t}\n\t\trc = i2c_smbus_write_byte_data(client, ISL1219_REG_EV, rc);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&client->dev, \"could not enable tamper detection\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tevdet_irq = of_irq_get_byname(np, \"evdet\");\n\t}\n\tif (isl1208->config->has_timestamp) {\n\t\trc = rtc_add_group(isl1208->rtc, &isl1219_rtc_sysfs_files);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = rtc_add_group(isl1208->rtc, &isl1208_rtc_sysfs_files);\n\tif (rc)\n\t\treturn rc;\n\n\tif (client->irq > 0) {\n\t\trc = isl1208_setup_irq(client, client->irq);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, isl1208->rtc->features);\n\t}\n\n\tif (evdet_irq > 0 && evdet_irq != client->irq)\n\t\trc = isl1208_setup_irq(client, evdet_irq);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_rtc_nvmem_register(isl1208->rtc, &isl1208->nvmem_config);\n\tif (rc)\n\t\treturn rc;\n\n\treturn devm_rtc_register_device(isl1208->rtc);\n}\n\nstatic struct i2c_driver isl1208_driver = {\n\t.driver = {\n\t\t.name = \"rtc-isl1208\",\n\t\t.of_match_table = of_match_ptr(isl1208_of_match),\n\t},\n\t.probe = isl1208_probe,\n\t.id_table = isl1208_id,\n};\n\nmodule_i2c_driver(isl1208_driver);\n\nMODULE_AUTHOR(\"Herbert Valerio Riedel <hvr@gnu.org>\");\nMODULE_DESCRIPTION(\"Intersil ISL1208 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}