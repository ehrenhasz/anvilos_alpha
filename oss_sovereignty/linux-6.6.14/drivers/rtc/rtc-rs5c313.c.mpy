{
  "module_name": "rtc-rs5c313.c",
  "hash_id": "a6c2cb38710a037e95a3d47c7e7037b25db4b92c04c5567f9905e5d0c0d8a8e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rs5c313.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#define DRV_NAME\t\"rs5c313\"\n\n#ifdef CONFIG_SH_LANDISK\n \n \n \n\n#define SCSMR1\t\t0xFFE00000\n#define SCSCR1\t\t0xFFE00008\n#define SCSMR1_CA\t0x80\n#define SCSCR1_CKE\t0x03\n#define SCSPTR1\t\t0xFFE0001C\n#define SCSPTR1_EIO\t0x80\n#define SCSPTR1_SPB1IO\t0x08\n#define SCSPTR1_SPB1DT\t0x04\n#define SCSPTR1_SPB0IO\t0x02\n#define SCSPTR1_SPB0DT\t0x01\n\n#define SDA_OEN\t\tSCSPTR1_SPB1IO\n#define SDA\t\tSCSPTR1_SPB1DT\n#define SCL_OEN\t\tSCSPTR1_SPB0IO\n#define SCL\t\tSCSPTR1_SPB0DT\n\n \n#define RS5C313_CE\t0xB0000003\n\n \n#define RS5C313_CE_RTCCE\t0x02\n\n \nunsigned char scsptr1_data;\n\n#define RS5C313_CEENABLE    __raw_writeb(RS5C313_CE_RTCCE, RS5C313_CE);\n#define RS5C313_CEDISABLE   __raw_writeb(0x00, RS5C313_CE)\n#define RS5C313_MISCOP      __raw_writeb(0x02, 0xB0000008)\n\nstatic void rs5c313_init_port(void)\n{\n\t \n\t__raw_writeb(__raw_readb(SCSMR1) & ~SCSMR1_CA, SCSMR1);\n\t__raw_writeb(__raw_readb(SCSCR1) & ~SCSCR1_CKE, SCSCR1);\n\n\t \n\tscsptr1_data = __raw_readb(SCSPTR1) | SCL;\t \n\t__raw_writeb(scsptr1_data, SCSPTR1);\n\tscsptr1_data = __raw_readb(SCSPTR1) | SCL_OEN;\t \n\t__raw_writeb(scsptr1_data, SCSPTR1);\n\tRS5C313_CEDISABLE;\t \n}\n\nstatic void rs5c313_write_data(unsigned char data)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tscsptr1_data = (scsptr1_data & ~SDA) |\n\t\t\t\t((((0x80 >> i) & data) >> (7 - i)) << 2);\n\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t\tif (i == 0) {\n\t\t\tscsptr1_data |= SDA_OEN;\t \n\t\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t\t}\n\t\tndelay(700);\n\t\tscsptr1_data &= ~SCL;\t \n\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t\tndelay(700);\n\t\tscsptr1_data |= SCL;\t \n\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t}\n\n\tscsptr1_data &= ~SDA_OEN;\t \n\t__raw_writeb(scsptr1_data, SCSPTR1);\n}\n\nstatic unsigned char rs5c313_read_data(void)\n{\n\tint i;\n\tunsigned char data = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tndelay(700);\n\t\t \n\t\tdata |= ((__raw_readb(SCSPTR1) & SDA) >> 2) << (7 - i);\n\t\tscsptr1_data &= ~SCL;\t \n\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t\tndelay(700);\n\t\tscsptr1_data |= SCL;\t \n\t\t__raw_writeb(scsptr1_data, SCSPTR1);\n\t}\n\treturn data & 0x0F;\n}\n\n#endif  \n\n \n \n \n\n \n#define RS5C313_ADDR_SEC\t0x00\n#define RS5C313_ADDR_SEC10\t0x01\n#define RS5C313_ADDR_MIN\t0x02\n#define RS5C313_ADDR_MIN10\t0x03\n#define RS5C313_ADDR_HOUR\t0x04\n#define RS5C313_ADDR_HOUR10\t0x05\n#define RS5C313_ADDR_WEEK\t0x06\n#define RS5C313_ADDR_INTINTVREG\t0x07\n#define RS5C313_ADDR_DAY\t0x08\n#define RS5C313_ADDR_DAY10\t0x09\n#define RS5C313_ADDR_MON\t0x0A\n#define RS5C313_ADDR_MON10\t0x0B\n#define RS5C313_ADDR_YEAR\t0x0C\n#define RS5C313_ADDR_YEAR10\t0x0D\n#define RS5C313_ADDR_CNTREG\t0x0E\n#define RS5C313_ADDR_TESTREG\t0x0F\n\n \n#define RS5C313_CNTREG_ADJ_BSY\t0x01\n#define RS5C313_CNTREG_WTEN_XSTP\t0x02\n#define RS5C313_CNTREG_12_24\t0x04\n#define RS5C313_CNTREG_CTFG\t0x08\n\n \n#define RS5C313_TESTREG_TEST\t0x01\n\n \n#define RS5C313_CNTBIT_READ\t0x40\n#define RS5C313_CNTBIT_AD\t0x20\n#define RS5C313_CNTBIT_DT\t0x10\n\nstatic unsigned char rs5c313_read_reg(unsigned char addr)\n{\n\n\trs5c313_write_data(addr | RS5C313_CNTBIT_READ | RS5C313_CNTBIT_AD);\n\treturn rs5c313_read_data();\n}\n\nstatic void rs5c313_write_reg(unsigned char addr, unsigned char data)\n{\n\tdata &= 0x0f;\n\trs5c313_write_data(addr | RS5C313_CNTBIT_AD);\n\trs5c313_write_data(data | RS5C313_CNTBIT_DT);\n\treturn;\n}\n\nstatic inline unsigned char rs5c313_read_cntreg(void)\n{\n\treturn rs5c313_read_reg(RS5C313_ADDR_CNTREG);\n}\n\nstatic inline void rs5c313_write_cntreg(unsigned char data)\n{\n\trs5c313_write_reg(RS5C313_ADDR_CNTREG, data);\n}\n\nstatic inline void rs5c313_write_intintvreg(unsigned char data)\n{\n\trs5c313_write_reg(RS5C313_ADDR_INTINTVREG, data);\n}\n\nstatic int rs5c313_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tint data;\n\tint cnt;\n\n\tcnt = 0;\n\twhile (1) {\n\t\tRS5C313_CEENABLE;\t \n\n\t\t \n\t\trs5c313_write_cntreg(0x04);\n\n\t\tif (!(rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY))\n\t\t\tbreak;\n\n\t\tRS5C313_CEDISABLE;\n\t\tndelay(700);\t \n\n\t\tif (cnt++ > 100) {\n\t\t\tdev_err(dev, \"%s: timeout error\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_SEC);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_SEC10) << 4);\n\ttm->tm_sec = bcd2bin(data);\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_MIN);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_MIN10) << 4);\n\ttm->tm_min = bcd2bin(data);\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_HOUR);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_HOUR10) << 4);\n\ttm->tm_hour = bcd2bin(data);\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_DAY);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_DAY10) << 4);\n\ttm->tm_mday = bcd2bin(data);\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_MON);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_MON10) << 4);\n\ttm->tm_mon = bcd2bin(data) - 1;\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_YEAR);\n\tdata |= (rs5c313_read_reg(RS5C313_ADDR_YEAR10) << 4);\n\ttm->tm_year = bcd2bin(data);\n\n\tif (tm->tm_year < 70)\n\t\ttm->tm_year += 100;\n\n\tdata = rs5c313_read_reg(RS5C313_ADDR_WEEK);\n\ttm->tm_wday = bcd2bin(data);\n\n\tRS5C313_CEDISABLE;\n\tndelay(700);\t\t \n\n\treturn 0;\n}\n\nstatic int rs5c313_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tint data;\n\tint cnt;\n\n\tcnt = 0;\n\t \n\twhile (1) {\n\t\tRS5C313_CEENABLE;\t \n\n\t\t \n\t\trs5c313_write_cntreg(0x04);\n\n\t\tif (!(rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY))\n\t\t\tbreak;\n\t\tRS5C313_MISCOP;\n\t\tRS5C313_CEDISABLE;\n\t\tndelay(700);\t \n\n\t\tif (cnt++ > 100) {\n\t\t\tdev_err(dev, \"%s: timeout error\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdata = bin2bcd(tm->tm_sec);\n\trs5c313_write_reg(RS5C313_ADDR_SEC, data);\n\trs5c313_write_reg(RS5C313_ADDR_SEC10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_min);\n\trs5c313_write_reg(RS5C313_ADDR_MIN, data);\n\trs5c313_write_reg(RS5C313_ADDR_MIN10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_hour);\n\trs5c313_write_reg(RS5C313_ADDR_HOUR, data);\n\trs5c313_write_reg(RS5C313_ADDR_HOUR10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_mday);\n\trs5c313_write_reg(RS5C313_ADDR_DAY, data);\n\trs5c313_write_reg(RS5C313_ADDR_DAY10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_mon + 1);\n\trs5c313_write_reg(RS5C313_ADDR_MON, data);\n\trs5c313_write_reg(RS5C313_ADDR_MON10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_year % 100);\n\trs5c313_write_reg(RS5C313_ADDR_YEAR, data);\n\trs5c313_write_reg(RS5C313_ADDR_YEAR10, (data >> 4));\n\n\tdata = bin2bcd(tm->tm_wday);\n\trs5c313_write_reg(RS5C313_ADDR_WEEK, data);\n\n\tRS5C313_CEDISABLE;\t \n\tndelay(700);\n\n\treturn 0;\n}\n\nstatic void rs5c313_check_xstp_bit(void)\n{\n\tstruct rtc_time tm;\n\tint cnt;\n\n\tRS5C313_CEENABLE;\t \n\tif (rs5c313_read_cntreg() & RS5C313_CNTREG_WTEN_XSTP) {\n\t\t \n\t\trs5c313_write_intintvreg(0x00);\n\t\t \n\t\trs5c313_write_cntreg(0x07);\n\n\t\t \n\t\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\t\tif (!(rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY))\n\t\t\t\tbreak;\n\t\t\tRS5C313_MISCOP;\n\t\t}\n\n\t\tmemset(&tm, 0, sizeof(struct rtc_time));\n\t\ttm.tm_mday\t= 1;\n\t\ttm.tm_mon\t= 1 - 1;\n\t\ttm.tm_year\t= 2000 - 1900;\n\n\t\trs5c313_rtc_set_time(NULL, &tm);\n\t\tpr_err(\"invalid value, resetting to 1 Jan 2000\\n\");\n\t}\n\tRS5C313_CEDISABLE;\n\tndelay(700);\t\t \n}\n\nstatic const struct rtc_class_ops rs5c313_rtc_ops = {\n\t.read_time = rs5c313_rtc_read_time,\n\t.set_time = rs5c313_rtc_set_time,\n};\n\nstatic int rs5c313_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\n\trs5c313_init_port();\n\trs5c313_check_xstp_bit();\n\n\trtc = devm_rtc_device_register(&pdev->dev, \"rs5c313\", &rs5c313_rtc_ops,\n\t\t\t\t       THIS_MODULE);\n\n\treturn PTR_ERR_OR_ZERO(rtc);\n}\n\nstatic struct platform_driver rs5c313_rtc_platform_driver = {\n\t.driver         = {\n\t\t.name   = DRV_NAME,\n\t},\n\t.probe\t= rs5c313_rtc_probe,\n};\n\nmodule_platform_driver(rs5c313_rtc_platform_driver);\n\nMODULE_AUTHOR(\"kogiidena , Nobuhiro Iwamatsu <iwamatsu@nigauri.org>\");\nMODULE_DESCRIPTION(\"Ricoh RS5C313 RTC device driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}