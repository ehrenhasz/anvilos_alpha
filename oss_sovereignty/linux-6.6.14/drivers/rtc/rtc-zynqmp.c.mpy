{
  "module_name": "rtc-zynqmp.c",
  "hash_id": "95e40c8d9165dda9b371d9360e5ada0e4e00debbd5646d2b187cf5ae3a2d3217",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-zynqmp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n \n#define RTC_SET_TM_WR\t\t0x00\n#define RTC_SET_TM_RD\t\t0x04\n#define RTC_CALIB_WR\t\t0x08\n#define RTC_CALIB_RD\t\t0x0C\n#define RTC_CUR_TM\t\t0x10\n#define RTC_CUR_TICK\t\t0x14\n#define RTC_ALRM\t\t0x18\n#define RTC_INT_STS\t\t0x20\n#define RTC_INT_MASK\t\t0x24\n#define RTC_INT_EN\t\t0x28\n#define RTC_INT_DIS\t\t0x2C\n#define RTC_CTRL\t\t0x40\n\n#define RTC_FR_EN\t\tBIT(20)\n#define RTC_FR_DATSHIFT\t\t16\n#define RTC_TICK_MASK\t\t0xFFFF\n#define RTC_INT_SEC\t\tBIT(0)\n#define RTC_INT_ALRM\t\tBIT(1)\n#define RTC_OSC_EN\t\tBIT(24)\n#define RTC_BATT_EN\t\tBIT(31)\n\n#define RTC_CALIB_DEF\t\t0x7FFF\n#define RTC_CALIB_MASK\t\t0x1FFFFF\n#define RTC_ALRM_MASK          BIT(1)\n#define RTC_MSEC               1000\n#define RTC_FR_MASK\t\t0xF0000\n#define RTC_FR_MAX_TICKS\t16\n#define RTC_PPB\t\t\t1000000000LL\n#define RTC_MIN_OFFSET\t\t-32768000\n#define RTC_MAX_OFFSET\t\t32767000\n\nstruct xlnx_rtc_dev {\n\tstruct rtc_device\t*rtc;\n\tvoid __iomem\t\t*reg_base;\n\tint\t\t\talarm_irq;\n\tint\t\t\tsec_irq;\n\tstruct clk\t\t*rtc_clk;\n\tunsigned int\t\tfreq;\n};\n\nstatic int xlnx_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\tunsigned long new_time;\n\n\t \n\tnew_time = rtc_tm_to_time64(tm) + 1;\n\n\twritel(new_time, xrtcdev->reg_base + RTC_SET_TM_WR);\n\n\t \n\twritel(RTC_INT_SEC, xrtcdev->reg_base + RTC_INT_STS);\n\n\treturn 0;\n}\n\nstatic int xlnx_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tu32 status;\n\tunsigned long read_time;\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\n\tstatus = readl(xrtcdev->reg_base + RTC_INT_STS);\n\n\tif (status & RTC_INT_SEC) {\n\t\t \n\t\tread_time = readl(xrtcdev->reg_base + RTC_CUR_TM);\n\t} else {\n\t\t \n\t\tread_time = readl(xrtcdev->reg_base + RTC_SET_TM_RD) - 1;\n\t}\n\trtc_time64_to_tm(read_time, tm);\n\n\treturn 0;\n}\n\nstatic int xlnx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(xrtcdev->reg_base + RTC_ALRM), &alrm->time);\n\talrm->enabled = readl(xrtcdev->reg_base + RTC_INT_MASK) & RTC_INT_ALRM;\n\n\treturn 0;\n}\n\nstatic int xlnx_rtc_alarm_irq_enable(struct device *dev, u32 enabled)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\tunsigned int status;\n\tulong timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(RTC_MSEC);\n\n\tif (enabled) {\n\t\twhile (1) {\n\t\t\tstatus = readl(xrtcdev->reg_base + RTC_INT_STS);\n\t\t\tif (!((status & RTC_ALRM_MASK) == RTC_ALRM_MASK))\n\t\t\t\tbreak;\n\n\t\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\t\tdev_err(dev, \"Time out occur, while clearing alarm status bit\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\twritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_STS);\n\t\t}\n\n\t\twritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_EN);\n\t} else {\n\t\twritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_DIS);\n\t}\n\n\treturn 0;\n}\n\nstatic int xlnx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\tunsigned long alarm_time;\n\n\talarm_time = rtc_tm_to_time64(&alrm->time);\n\n\twritel((u32)alarm_time, (xrtcdev->reg_base + RTC_ALRM));\n\n\txlnx_rtc_alarm_irq_enable(dev, alrm->enabled);\n\n\treturn 0;\n}\n\nstatic void xlnx_init_rtc(struct xlnx_rtc_dev *xrtcdev)\n{\n\tu32 rtc_ctrl;\n\n\t \n\trtc_ctrl = readl(xrtcdev->reg_base + RTC_CTRL);\n\trtc_ctrl |= RTC_BATT_EN;\n\twritel(rtc_ctrl, xrtcdev->reg_base + RTC_CTRL);\n}\n\nstatic int xlnx_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\tunsigned long long rtc_ppb = RTC_PPB;\n\tunsigned int tick_mult = do_div(rtc_ppb, xrtcdev->freq);\n\tunsigned int calibval;\n\tlong offset_val;\n\n\tcalibval = readl(xrtcdev->reg_base + RTC_CALIB_RD);\n\t \n\toffset_val = calibval & RTC_TICK_MASK;\n\toffset_val = offset_val - RTC_CALIB_DEF;\n\toffset_val = offset_val * tick_mult;\n\n\t \n\tif (calibval & RTC_FR_EN)\n\t\toffset_val += ((calibval & RTC_FR_MASK) >> RTC_FR_DATSHIFT)\n\t\t\t* (tick_mult / RTC_FR_MAX_TICKS);\n\t*offset = offset_val;\n\n\treturn 0;\n}\n\nstatic int xlnx_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\tunsigned long long rtc_ppb = RTC_PPB;\n\tunsigned int tick_mult = do_div(rtc_ppb, xrtcdev->freq);\n\tunsigned char fract_tick = 0;\n\tunsigned int calibval;\n\tshort int  max_tick;\n\tint fract_offset;\n\n\tif (offset < RTC_MIN_OFFSET || offset > RTC_MAX_OFFSET)\n\t\treturn -ERANGE;\n\n\t \n\tmax_tick = div_s64_rem(offset, tick_mult, &fract_offset);\n\n\t \n\tif (fract_offset) {\n\t\tif (fract_offset < 0) {\n\t\t\tfract_offset = fract_offset + tick_mult;\n\t\t\tmax_tick--;\n\t\t}\n\t\tif (fract_offset > (tick_mult / RTC_FR_MAX_TICKS)) {\n\t\t\tfor (fract_tick = 1; fract_tick < 16; fract_tick++) {\n\t\t\t\tif (fract_offset <=\n\t\t\t\t    (fract_tick *\n\t\t\t\t     (tick_mult / RTC_FR_MAX_TICKS)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tcalibval = max_tick + RTC_CALIB_DEF;\n\n\tif (fract_tick)\n\t\tcalibval |= RTC_FR_EN;\n\n\tcalibval |= (fract_tick << RTC_FR_DATSHIFT);\n\n\twritel(calibval, (xrtcdev->reg_base + RTC_CALIB_WR));\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops xlnx_rtc_ops = {\n\t.set_time\t  = xlnx_rtc_set_time,\n\t.read_time\t  = xlnx_rtc_read_time,\n\t.read_alarm\t  = xlnx_rtc_read_alarm,\n\t.set_alarm\t  = xlnx_rtc_set_alarm,\n\t.alarm_irq_enable = xlnx_rtc_alarm_irq_enable,\n\t.read_offset\t  = xlnx_rtc_read_offset,\n\t.set_offset\t  = xlnx_rtc_set_offset,\n};\n\nstatic irqreturn_t xlnx_rtc_interrupt(int irq, void *id)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = (struct xlnx_rtc_dev *)id;\n\tunsigned int status;\n\n\tstatus = readl(xrtcdev->reg_base + RTC_INT_STS);\n\t \n\tif (!(status & (RTC_INT_SEC | RTC_INT_ALRM)))\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(RTC_INT_ALRM, xrtcdev->reg_base + RTC_INT_DIS);\n\n\tif (status & RTC_INT_ALRM)\n\t\trtc_update_irq(xrtcdev->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xlnx_rtc_probe(struct platform_device *pdev)\n{\n\tstruct xlnx_rtc_dev *xrtcdev;\n\tint ret;\n\n\txrtcdev = devm_kzalloc(&pdev->dev, sizeof(*xrtcdev), GFP_KERNEL);\n\tif (!xrtcdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, xrtcdev);\n\n\txrtcdev->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(xrtcdev->rtc))\n\t\treturn PTR_ERR(xrtcdev->rtc);\n\n\txrtcdev->rtc->ops = &xlnx_rtc_ops;\n\txrtcdev->rtc->range_max = U32_MAX;\n\n\txrtcdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xrtcdev->reg_base))\n\t\treturn PTR_ERR(xrtcdev->reg_base);\n\n\txrtcdev->alarm_irq = platform_get_irq_byname(pdev, \"alarm\");\n\tif (xrtcdev->alarm_irq < 0)\n\t\treturn xrtcdev->alarm_irq;\n\tret = devm_request_irq(&pdev->dev, xrtcdev->alarm_irq,\n\t\t\t       xlnx_rtc_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), xrtcdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\txrtcdev->sec_irq = platform_get_irq_byname(pdev, \"sec\");\n\tif (xrtcdev->sec_irq < 0)\n\t\treturn xrtcdev->sec_irq;\n\tret = devm_request_irq(&pdev->dev, xrtcdev->sec_irq,\n\t\t\t       xlnx_rtc_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), xrtcdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\txrtcdev->rtc_clk = devm_clk_get_optional(&pdev->dev, \"rtc_clk\");\n\tif (IS_ERR(xrtcdev->rtc_clk)) {\n\t\tif (PTR_ERR(xrtcdev->rtc_clk) != -EPROBE_DEFER)\n\t\t\tdev_warn(&pdev->dev, \"Device clock not found.\\n\");\n\t}\n\txrtcdev->freq = clk_get_rate(xrtcdev->rtc_clk);\n\tif (!xrtcdev->freq) {\n\t\tret = of_property_read_u32(pdev->dev.of_node, \"calibration\",\n\t\t\t\t\t   &xrtcdev->freq);\n\t\tif (ret)\n\t\t\txrtcdev->freq = RTC_CALIB_DEF;\n\t}\n\tret = readl(xrtcdev->reg_base + RTC_CALIB_RD);\n\tif (!ret)\n\t\twritel(xrtcdev->freq, (xrtcdev->reg_base + RTC_CALIB_WR));\n\n\txlnx_init_rtc(xrtcdev);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn devm_rtc_register_device(xrtcdev->rtc);\n}\n\nstatic void xlnx_rtc_remove(struct platform_device *pdev)\n{\n\txlnx_rtc_alarm_irq_enable(&pdev->dev, 0);\n\tdevice_init_wakeup(&pdev->dev, 0);\n}\n\nstatic int __maybe_unused xlnx_rtc_suspend(struct device *dev)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(xrtcdev->alarm_irq);\n\telse\n\t\txlnx_rtc_alarm_irq_enable(dev, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xlnx_rtc_resume(struct device *dev)\n{\n\tstruct xlnx_rtc_dev *xrtcdev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(xrtcdev->alarm_irq);\n\telse\n\t\txlnx_rtc_alarm_irq_enable(dev, 1);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(xlnx_rtc_pm_ops, xlnx_rtc_suspend, xlnx_rtc_resume);\n\nstatic const struct of_device_id xlnx_rtc_of_match[] = {\n\t{.compatible = \"xlnx,zynqmp-rtc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xlnx_rtc_of_match);\n\nstatic struct platform_driver xlnx_rtc_driver = {\n\t.probe\t\t= xlnx_rtc_probe,\n\t.remove_new\t= xlnx_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.pm\t= &xlnx_rtc_pm_ops,\n\t\t.of_match_table\t= xlnx_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(xlnx_rtc_driver);\n\nMODULE_DESCRIPTION(\"Xilinx Zynq MPSoC RTC driver\");\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}