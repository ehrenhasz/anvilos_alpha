{
  "module_name": "rtc-s35390a.c",
  "hash_id": "2739a32523b61f62f86c4f2e96d5600bd8c1bf686dbee32331be18f5ffc1b89f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-s35390a.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/i2c.h>\n#include <linux/bitrev.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#define S35390A_CMD_STATUS1\t0\n#define S35390A_CMD_STATUS2\t1\n#define S35390A_CMD_TIME1\t2\n#define S35390A_CMD_TIME2\t3\n#define S35390A_CMD_INT2_REG1\t5\n\n#define S35390A_BYTE_YEAR\t0\n#define S35390A_BYTE_MONTH\t1\n#define S35390A_BYTE_DAY\t2\n#define S35390A_BYTE_WDAY\t3\n#define S35390A_BYTE_HOURS\t4\n#define S35390A_BYTE_MINS\t5\n#define S35390A_BYTE_SECS\t6\n\n#define S35390A_ALRM_BYTE_WDAY\t0\n#define S35390A_ALRM_BYTE_HOURS\t1\n#define S35390A_ALRM_BYTE_MINS\t2\n\n \n#define S35390A_FLAG_POC\tBIT(0)\n#define S35390A_FLAG_BLD\tBIT(1)\n#define S35390A_FLAG_INT2\tBIT(2)\n#define S35390A_FLAG_24H\tBIT(6)\n#define S35390A_FLAG_RESET\tBIT(7)\n\n \n#define S35390A_FLAG_TEST\tBIT(0)\n\n \n#define S35390A_INT2_MODE_MASK\t\t0x0E\n#define S35390A_INT2_MODE_NOINTR\t0x00\n#define S35390A_INT2_MODE_ALARM\t\tBIT(1)  \n#define S35390A_INT2_MODE_PMIN_EDG\tBIT(2)  \n#define S35390A_INT2_MODE_FREQ\t\tBIT(3)  \n#define S35390A_INT2_MODE_PMIN\t\t(BIT(3) | BIT(2))  \n\nstatic const struct i2c_device_id s35390a_id[] = {\n\t{ \"s35390a\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, s35390a_id);\n\nstatic const __maybe_unused struct of_device_id s35390a_of_match[] = {\n\t{ .compatible = \"s35390a\" },\n\t{ .compatible = \"sii,s35390a\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, s35390a_of_match);\n\nstruct s35390a {\n\tstruct i2c_client *client[8];\n\tstruct rtc_device *rtc;\n\tint twentyfourhour;\n};\n\nstatic int s35390a_set_reg(struct s35390a *s35390a, int reg, char *buf, int len)\n{\n\tstruct i2c_client *client = s35390a->client[reg];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = len,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\tif ((i2c_transfer(client->adapter, msg, 1)) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int s35390a_get_reg(struct s35390a *s35390a, int reg, char *buf, int len)\n{\n\tstruct i2c_client *client = s35390a->client[reg];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\tif ((i2c_transfer(client->adapter, msg, 1)) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int s35390a_init(struct s35390a *s35390a)\n{\n\tu8 buf;\n\tint ret;\n\tunsigned initcount = 0;\n\n\t \ninitialize:\n\tbuf = S35390A_FLAG_RESET | S35390A_FLAG_24H;\n\tret = s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, &buf, 1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, &buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buf & (S35390A_FLAG_POC | S35390A_FLAG_BLD)) {\n\t\t \n\t\tif (initcount < 5) {\n\t\t\t++initcount;\n\t\t\tgoto initialize;\n\t\t} else\n\t\t\treturn -EIO;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int s35390a_read_status(struct s35390a *s35390a, char *status1)\n{\n\tint ret;\n\n\tret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, status1, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (*status1 & S35390A_FLAG_POC) {\n\t\t \n\t\tmsleep(500);\n\t\treturn 1;\n\t} else if (*status1 & S35390A_FLAG_BLD)\n\t\treturn 1;\n\t \n\treturn 0;\n}\n\nstatic int s35390a_disable_test_mode(struct s35390a *s35390a)\n{\n\tchar buf[1];\n\n\tif (s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf)) < 0)\n\t\treturn -EIO;\n\n\tif (!(buf[0] & S35390A_FLAG_TEST))\n\t\treturn 0;\n\n\tbuf[0] &= ~S35390A_FLAG_TEST;\n\treturn s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf));\n}\n\nstatic char s35390a_hr2reg(struct s35390a *s35390a, int hour)\n{\n\tif (s35390a->twentyfourhour)\n\t\treturn bin2bcd(hour);\n\n\tif (hour < 12)\n\t\treturn bin2bcd(hour);\n\n\treturn 0x40 | bin2bcd(hour - 12);\n}\n\nstatic int s35390a_reg2hr(struct s35390a *s35390a, char reg)\n{\n\tunsigned hour;\n\n\tif (s35390a->twentyfourhour)\n\t\treturn bcd2bin(reg & 0x3f);\n\n\thour = bcd2bin(reg & 0x3f);\n\tif (reg & 0x40)\n\t\thour += 12;\n\n\treturn hour;\n}\n\nstatic int s35390a_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct s35390a\t*s35390a = i2c_get_clientdata(client);\n\tint i;\n\tchar buf[7], status;\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d mday=%d, \"\n\t\t\"mon=%d, year=%d, wday=%d\\n\", __func__, tm->tm_sec,\n\t\ttm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\n\t\ttm->tm_wday);\n\n\tif (s35390a_read_status(s35390a, &status) == 1)\n\t\ts35390a_init(s35390a);\n\n\tbuf[S35390A_BYTE_YEAR] = bin2bcd(tm->tm_year - 100);\n\tbuf[S35390A_BYTE_MONTH] = bin2bcd(tm->tm_mon + 1);\n\tbuf[S35390A_BYTE_DAY] = bin2bcd(tm->tm_mday);\n\tbuf[S35390A_BYTE_WDAY] = bin2bcd(tm->tm_wday);\n\tbuf[S35390A_BYTE_HOURS] = s35390a_hr2reg(s35390a, tm->tm_hour);\n\tbuf[S35390A_BYTE_MINS] = bin2bcd(tm->tm_min);\n\tbuf[S35390A_BYTE_SECS] = bin2bcd(tm->tm_sec);\n\n\t \n\tfor (i = 0; i < 7; ++i)\n\t\tbuf[i] = bitrev8(buf[i]);\n\n\treturn s35390a_set_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\n}\n\nstatic int s35390a_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct s35390a *s35390a = i2c_get_clientdata(client);\n\tchar buf[7], status;\n\tint i, err;\n\n\tif (s35390a_read_status(s35390a, &status) == 1)\n\t\treturn -EINVAL;\n\n\terr = s35390a_get_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < 7; ++i)\n\t\tbuf[i] = bitrev8(buf[i]);\n\n\ttm->tm_sec = bcd2bin(buf[S35390A_BYTE_SECS]);\n\ttm->tm_min = bcd2bin(buf[S35390A_BYTE_MINS]);\n\ttm->tm_hour = s35390a_reg2hr(s35390a, buf[S35390A_BYTE_HOURS]);\n\ttm->tm_wday = bcd2bin(buf[S35390A_BYTE_WDAY]);\n\ttm->tm_mday = bcd2bin(buf[S35390A_BYTE_DAY]);\n\ttm->tm_mon = bcd2bin(buf[S35390A_BYTE_MONTH]) - 1;\n\ttm->tm_year = bcd2bin(buf[S35390A_BYTE_YEAR]) + 100;\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d, mday=%d, \"\n\t\t\"mon=%d, year=%d, wday=%d\\n\", __func__, tm->tm_sec,\n\t\ttm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\n\t\ttm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int s35390a_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct s35390a *s35390a = i2c_get_clientdata(client);\n\tchar buf[3], sts = 0;\n\tint err, i;\n\n\tdev_dbg(&client->dev, \"%s: alm is secs=%d, mins=%d, hours=%d mday=%d, \"\\\n\t\t\"mon=%d, year=%d, wday=%d\\n\", __func__, alm->time.tm_sec,\n\t\talm->time.tm_min, alm->time.tm_hour, alm->time.tm_mday,\n\t\talm->time.tm_mon, alm->time.tm_year, alm->time.tm_wday);\n\n\t \n\terr = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, &sts, sizeof(sts));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (alm->enabled)\n\t\tsts = S35390A_INT2_MODE_ALARM;\n\telse\n\t\tsts = S35390A_INT2_MODE_NOINTR;\n\n\t \n\terr = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (alm->time.tm_wday != -1)\n\t\tbuf[S35390A_ALRM_BYTE_WDAY] = bin2bcd(alm->time.tm_wday) | 0x80;\n\telse\n\t\tbuf[S35390A_ALRM_BYTE_WDAY] = 0;\n\n\tbuf[S35390A_ALRM_BYTE_HOURS] = s35390a_hr2reg(s35390a,\n\t\t\talm->time.tm_hour) | 0x80;\n\tbuf[S35390A_ALRM_BYTE_MINS] = bin2bcd(alm->time.tm_min) | 0x80;\n\n\tif (alm->time.tm_hour >= 12)\n\t\tbuf[S35390A_ALRM_BYTE_HOURS] |= 0x40;\n\n\tfor (i = 0; i < 3; ++i)\n\t\tbuf[i] = bitrev8(buf[i]);\n\n\terr = s35390a_set_reg(s35390a, S35390A_CMD_INT2_REG1, buf,\n\t\t\t\t\t\t\t\tsizeof(buf));\n\n\treturn err;\n}\n\nstatic int s35390a_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct s35390a *s35390a = i2c_get_clientdata(client);\n\tchar buf[3], sts;\n\tint i, err;\n\n\terr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, &sts, sizeof(sts));\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((sts & S35390A_INT2_MODE_MASK) != S35390A_INT2_MODE_ALARM) {\n\t\t \n\t\talm->enabled = 0;\n\t\treturn 0;\n\t} else {\n\t\talm->enabled = 1;\n\t}\n\n\terr = s35390a_get_reg(s35390a, S35390A_CMD_INT2_REG1, buf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < 3; ++i)\n\t\tbuf[i] = bitrev8(buf[i]);\n\n\t \n\tif (buf[S35390A_ALRM_BYTE_WDAY] & 0x80)\n\t\talm->time.tm_wday =\n\t\t\tbcd2bin(buf[S35390A_ALRM_BYTE_WDAY] & ~0x80);\n\n\tif (buf[S35390A_ALRM_BYTE_HOURS] & 0x80)\n\t\talm->time.tm_hour =\n\t\t\ts35390a_reg2hr(s35390a,\n\t\t\t\t       buf[S35390A_ALRM_BYTE_HOURS] & ~0x80);\n\n\tif (buf[S35390A_ALRM_BYTE_MINS] & 0x80)\n\t\talm->time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS] & ~0x80);\n\n\t \n\talm->time.tm_sec = 0;\n\n\tdev_dbg(&client->dev, \"%s: alm is mins=%d, hours=%d, wday=%d\\n\",\n\t\t\t__func__, alm->time.tm_min, alm->time.tm_hour,\n\t\t\talm->time.tm_wday);\n\n\treturn 0;\n}\n\nstatic int s35390a_rtc_ioctl(struct device *dev, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct s35390a *s35390a = i2c_get_clientdata(client);\n\tchar sts;\n\tint err;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\t \n\t\terr = s35390a_read_status(s35390a, &sts);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_to_user((void __user *)arg, &err, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase RTC_VL_CLR:\n\t\t \n\t\terr = s35390a_init(s35390a);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops s35390a_rtc_ops = {\n\t.read_time\t= s35390a_rtc_read_time,\n\t.set_time\t= s35390a_rtc_set_time,\n\t.set_alarm\t= s35390a_rtc_set_alarm,\n\t.read_alarm\t= s35390a_rtc_read_alarm,\n\t.ioctl          = s35390a_rtc_ioctl,\n};\n\nstatic int s35390a_probe(struct i2c_client *client)\n{\n\tint err, err_read;\n\tunsigned int i;\n\tstruct s35390a *s35390a;\n\tchar buf, status1;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\ts35390a = devm_kzalloc(dev, sizeof(struct s35390a), GFP_KERNEL);\n\tif (!s35390a)\n\t\treturn -ENOMEM;\n\n\ts35390a->client[0] = client;\n\ti2c_set_clientdata(client, s35390a);\n\n\t \n\tfor (i = 1; i < 8; ++i) {\n\t\ts35390a->client[i] = devm_i2c_new_dummy_device(dev,\n\t\t\t\t\t\t\t       client->adapter,\n\t\t\t\t\t\t\t       client->addr + i);\n\t\tif (IS_ERR(s35390a->client[i])) {\n\t\t\tdev_err(dev, \"Address %02x unavailable\\n\",\n\t\t\t\tclient->addr + i);\n\t\t\treturn PTR_ERR(s35390a->client[i]);\n\t\t}\n\t}\n\n\ts35390a->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(s35390a->rtc))\n\t\treturn PTR_ERR(s35390a->rtc);\n\n\terr_read = s35390a_read_status(s35390a, &status1);\n\tif (err_read < 0) {\n\t\tdev_err(dev, \"error resetting chip\\n\");\n\t\treturn err_read;\n\t}\n\n\tif (status1 & S35390A_FLAG_24H)\n\t\ts35390a->twentyfourhour = 1;\n\telse\n\t\ts35390a->twentyfourhour = 0;\n\n\tif (status1 & S35390A_FLAG_INT2) {\n\t\t \n\t\tbuf = 0;\n\t\terr = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &buf, 1);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"error disabling alarm\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\terr = s35390a_disable_test_mode(s35390a);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"error disabling test mode\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdevice_set_wakeup_capable(dev, 1);\n\n\ts35390a->rtc->ops = &s35390a_rtc_ops;\n\ts35390a->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\ts35390a->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, s35390a->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, s35390a->rtc->features );\n\n\tif (status1 & S35390A_FLAG_INT2)\n\t\trtc_update_irq(s35390a->rtc, 1, RTC_AF);\n\n\treturn devm_rtc_register_device(s35390a->rtc);\n}\n\nstatic struct i2c_driver s35390a_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-s35390a\",\n\t\t.of_match_table = of_match_ptr(s35390a_of_match),\n\t},\n\t.probe\t\t= s35390a_probe,\n\t.id_table\t= s35390a_id,\n};\n\nmodule_i2c_driver(s35390a_driver);\n\nMODULE_AUTHOR(\"Byron Bradley <byron.bbradley@gmail.com>\");\nMODULE_DESCRIPTION(\"S35390A RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}