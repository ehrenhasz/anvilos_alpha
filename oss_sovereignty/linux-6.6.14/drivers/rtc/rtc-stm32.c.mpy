{
  "module_name": "rtc-stm32.c",
  "hash_id": "38fc3b630dc349931cb0f5e22cf595dc55f09530d88400011d304d5e5d3c7f9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-stm32.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define DRIVER_NAME \"stm32_rtc\"\n\n \n#define STM32_RTC_TR_SEC_SHIFT\t\t0\n#define STM32_RTC_TR_SEC\t\tGENMASK(6, 0)\n#define STM32_RTC_TR_MIN_SHIFT\t\t8\n#define STM32_RTC_TR_MIN\t\tGENMASK(14, 8)\n#define STM32_RTC_TR_HOUR_SHIFT\t\t16\n#define STM32_RTC_TR_HOUR\t\tGENMASK(21, 16)\n\n \n#define STM32_RTC_DR_DATE_SHIFT\t\t0\n#define STM32_RTC_DR_DATE\t\tGENMASK(5, 0)\n#define STM32_RTC_DR_MONTH_SHIFT\t8\n#define STM32_RTC_DR_MONTH\t\tGENMASK(12, 8)\n#define STM32_RTC_DR_WDAY_SHIFT\t\t13\n#define STM32_RTC_DR_WDAY\t\tGENMASK(15, 13)\n#define STM32_RTC_DR_YEAR_SHIFT\t\t16\n#define STM32_RTC_DR_YEAR\t\tGENMASK(23, 16)\n\n \n#define STM32_RTC_CR_FMT\t\tBIT(6)\n#define STM32_RTC_CR_ALRAE\t\tBIT(8)\n#define STM32_RTC_CR_ALRAIE\t\tBIT(12)\n\n \n#define STM32_RTC_ISR_ALRAWF\t\tBIT(0)\n#define STM32_RTC_ISR_INITS\t\tBIT(4)\n#define STM32_RTC_ISR_RSF\t\tBIT(5)\n#define STM32_RTC_ISR_INITF\t\tBIT(6)\n#define STM32_RTC_ISR_INIT\t\tBIT(7)\n#define STM32_RTC_ISR_ALRAF\t\tBIT(8)\n\n \n#define STM32_RTC_PRER_PRED_S_SHIFT\t0\n#define STM32_RTC_PRER_PRED_S\t\tGENMASK(14, 0)\n#define STM32_RTC_PRER_PRED_A_SHIFT\t16\n#define STM32_RTC_PRER_PRED_A\t\tGENMASK(22, 16)\n\n \n#define STM32_RTC_ALRMXR_SEC_SHIFT\t0\n#define STM32_RTC_ALRMXR_SEC\t\tGENMASK(6, 0)\n#define STM32_RTC_ALRMXR_SEC_MASK\tBIT(7)\n#define STM32_RTC_ALRMXR_MIN_SHIFT\t8\n#define STM32_RTC_ALRMXR_MIN\t\tGENMASK(14, 8)\n#define STM32_RTC_ALRMXR_MIN_MASK\tBIT(15)\n#define STM32_RTC_ALRMXR_HOUR_SHIFT\t16\n#define STM32_RTC_ALRMXR_HOUR\t\tGENMASK(21, 16)\n#define STM32_RTC_ALRMXR_PM\t\tBIT(22)\n#define STM32_RTC_ALRMXR_HOUR_MASK\tBIT(23)\n#define STM32_RTC_ALRMXR_DATE_SHIFT\t24\n#define STM32_RTC_ALRMXR_DATE\t\tGENMASK(29, 24)\n#define STM32_RTC_ALRMXR_WDSEL\t\tBIT(30)\n#define STM32_RTC_ALRMXR_WDAY_SHIFT\t24\n#define STM32_RTC_ALRMXR_WDAY\t\tGENMASK(27, 24)\n#define STM32_RTC_ALRMXR_DATE_MASK\tBIT(31)\n\n \n#define STM32_RTC_SR_ALRA\t\tBIT(0)\n\n \n#define STM32_RTC_VERR_MINREV_SHIFT\t0\n#define STM32_RTC_VERR_MINREV\t\tGENMASK(3, 0)\n#define STM32_RTC_VERR_MAJREV_SHIFT\t4\n#define STM32_RTC_VERR_MAJREV\t\tGENMASK(7, 4)\n\n \n#define RTC_WPR_1ST_KEY\t\t\t0xCA\n#define RTC_WPR_2ND_KEY\t\t\t0x53\n#define RTC_WPR_WRONG_KEY\t\t0xFF\n\n \n#define UNDEF_REG\t\t\t0xFFFF\n\n \n#define SEC_PER_DAY\t\t(24 * 60 * 60)\n\nstruct stm32_rtc;\n\nstruct stm32_rtc_registers {\n\tu16 tr;\n\tu16 dr;\n\tu16 cr;\n\tu16 isr;\n\tu16 prer;\n\tu16 alrmar;\n\tu16 wpr;\n\tu16 sr;\n\tu16 scr;\n\tu16 verr;\n};\n\nstruct stm32_rtc_events {\n\tu32 alra;\n};\n\nstruct stm32_rtc_data {\n\tconst struct stm32_rtc_registers regs;\n\tconst struct stm32_rtc_events events;\n\tvoid (*clear_events)(struct stm32_rtc *rtc, unsigned int flags);\n\tbool has_pclk;\n\tbool need_dbp;\n\tbool need_accuracy;\n};\n\nstruct stm32_rtc {\n\tstruct rtc_device *rtc_dev;\n\tvoid __iomem *base;\n\tstruct regmap *dbp;\n\tunsigned int dbp_reg;\n\tunsigned int dbp_mask;\n\tstruct clk *pclk;\n\tstruct clk *rtc_ck;\n\tconst struct stm32_rtc_data *data;\n\tint irq_alarm;\n};\n\nstatic void stm32_rtc_wpr_unlock(struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\n\twritel_relaxed(RTC_WPR_1ST_KEY, rtc->base + regs->wpr);\n\twritel_relaxed(RTC_WPR_2ND_KEY, rtc->base + regs->wpr);\n}\n\nstatic void stm32_rtc_wpr_lock(struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\n\twritel_relaxed(RTC_WPR_WRONG_KEY, rtc->base + regs->wpr);\n}\n\nstatic int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int isr = readl_relaxed(rtc->base + regs->isr);\n\n\tif (!(isr & STM32_RTC_ISR_INITF)) {\n\t\tisr |= STM32_RTC_ISR_INIT;\n\t\twritel_relaxed(isr, rtc->base + regs->isr);\n\n\t\t \n\t\treturn readl_relaxed_poll_timeout_atomic(rtc->base + regs->isr, isr,\n\t\t\t\t\t\t\t (isr & STM32_RTC_ISR_INITF),\n\t\t\t\t\t\t\t 10, 100000);\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_rtc_exit_init_mode(struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int isr = readl_relaxed(rtc->base + regs->isr);\n\n\tisr &= ~STM32_RTC_ISR_INIT;\n\twritel_relaxed(isr, rtc->base + regs->isr);\n}\n\nstatic int stm32_rtc_wait_sync(struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int isr = readl_relaxed(rtc->base + regs->isr);\n\n\tisr &= ~STM32_RTC_ISR_RSF;\n\twritel_relaxed(isr, rtc->base + regs->isr);\n\n\t \n\treturn readl_relaxed_poll_timeout_atomic(rtc->base + regs->isr,\n\t\t\t\t\t\t isr,\n\t\t\t\t\t\t (isr & STM32_RTC_ISR_RSF),\n\t\t\t\t\t\t 10, 100000);\n}\n\nstatic void stm32_rtc_clear_event_flags(struct stm32_rtc *rtc,\n\t\t\t\t\tunsigned int flags)\n{\n\trtc->data->clear_events(rtc, flags);\n}\n\nstatic irqreturn_t stm32_rtc_alarm_irq(int irq, void *dev_id)\n{\n\tstruct stm32_rtc *rtc = (struct stm32_rtc *)dev_id;\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tconst struct stm32_rtc_events *evts = &rtc->data->events;\n\tunsigned int status, cr;\n\n\trtc_lock(rtc->rtc_dev);\n\n\tstatus = readl_relaxed(rtc->base + regs->sr);\n\tcr = readl_relaxed(rtc->base + regs->cr);\n\n\tif ((status & evts->alra) &&\n\t    (cr & STM32_RTC_CR_ALRAIE)) {\n\t\t \n\t\tdev_dbg(&rtc->rtc_dev->dev, \"Alarm occurred\\n\");\n\n\t\t \n\t\trtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\t\t \n\t\tstm32_rtc_clear_event_flags(rtc, evts->alra);\n\t}\n\n\trtc_unlock(rtc->rtc_dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void tm2bcd(struct rtc_time *tm)\n{\n\ttm->tm_sec = bin2bcd(tm->tm_sec);\n\ttm->tm_min = bin2bcd(tm->tm_min);\n\ttm->tm_hour = bin2bcd(tm->tm_hour);\n\n\ttm->tm_mday = bin2bcd(tm->tm_mday);\n\ttm->tm_mon = bin2bcd(tm->tm_mon + 1);\n\ttm->tm_year = bin2bcd(tm->tm_year - 100);\n\t \n\ttm->tm_wday = (!tm->tm_wday) ? 7 : tm->tm_wday;\n}\n\n \nstatic void bcd2tm(struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon) - 1;\n\ttm->tm_year = bcd2bin(tm->tm_year) + 100;\n\t \n\ttm->tm_wday %= 7;\n}\n\nstatic int stm32_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int tr, dr;\n\n\t \n\ttr = readl_relaxed(rtc->base + regs->tr);\n\tdr = readl_relaxed(rtc->base + regs->dr);\n\n\ttm->tm_sec = (tr & STM32_RTC_TR_SEC) >> STM32_RTC_TR_SEC_SHIFT;\n\ttm->tm_min = (tr & STM32_RTC_TR_MIN) >> STM32_RTC_TR_MIN_SHIFT;\n\ttm->tm_hour = (tr & STM32_RTC_TR_HOUR) >> STM32_RTC_TR_HOUR_SHIFT;\n\n\ttm->tm_mday = (dr & STM32_RTC_DR_DATE) >> STM32_RTC_DR_DATE_SHIFT;\n\ttm->tm_mon = (dr & STM32_RTC_DR_MONTH) >> STM32_RTC_DR_MONTH_SHIFT;\n\ttm->tm_year = (dr & STM32_RTC_DR_YEAR) >> STM32_RTC_DR_YEAR_SHIFT;\n\ttm->tm_wday = (dr & STM32_RTC_DR_WDAY) >> STM32_RTC_DR_WDAY_SHIFT;\n\n\t \n\n\tbcd2tm(tm);\n\n\treturn 0;\n}\n\nstatic int stm32_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int tr, dr;\n\tint ret = 0;\n\n\ttm2bcd(tm);\n\n\t \n\ttr = ((tm->tm_sec << STM32_RTC_TR_SEC_SHIFT) & STM32_RTC_TR_SEC) |\n\t     ((tm->tm_min << STM32_RTC_TR_MIN_SHIFT) & STM32_RTC_TR_MIN) |\n\t     ((tm->tm_hour << STM32_RTC_TR_HOUR_SHIFT) & STM32_RTC_TR_HOUR);\n\n\t \n\tdr = ((tm->tm_mday << STM32_RTC_DR_DATE_SHIFT) & STM32_RTC_DR_DATE) |\n\t     ((tm->tm_mon << STM32_RTC_DR_MONTH_SHIFT) & STM32_RTC_DR_MONTH) |\n\t     ((tm->tm_year << STM32_RTC_DR_YEAR_SHIFT) & STM32_RTC_DR_YEAR) |\n\t     ((tm->tm_wday << STM32_RTC_DR_WDAY_SHIFT) & STM32_RTC_DR_WDAY);\n\n\tstm32_rtc_wpr_unlock(rtc);\n\n\tret = stm32_rtc_enter_init_mode(rtc);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't enter in init mode. Set time aborted.\\n\");\n\t\tgoto end;\n\t}\n\n\twritel_relaxed(tr, rtc->base + regs->tr);\n\twritel_relaxed(dr, rtc->base + regs->dr);\n\n\tstm32_rtc_exit_init_mode(rtc);\n\n\tret = stm32_rtc_wait_sync(rtc);\nend:\n\tstm32_rtc_wpr_lock(rtc);\n\n\treturn ret;\n}\n\nstatic int stm32_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tconst struct stm32_rtc_events *evts = &rtc->data->events;\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned int alrmar, cr, status;\n\n\talrmar = readl_relaxed(rtc->base + regs->alrmar);\n\tcr = readl_relaxed(rtc->base + regs->cr);\n\tstatus = readl_relaxed(rtc->base + regs->sr);\n\n\tif (alrmar & STM32_RTC_ALRMXR_DATE_MASK) {\n\t\t \n\t\ttm->tm_mday = -1;\n\t\ttm->tm_wday = -1;\n\t} else {\n\t\tif (alrmar & STM32_RTC_ALRMXR_WDSEL) {\n\t\t\t \n\t\t\ttm->tm_mday = -1;\n\t\t\ttm->tm_wday = (alrmar & STM32_RTC_ALRMXR_WDAY) >>\n\t\t\t\t      STM32_RTC_ALRMXR_WDAY_SHIFT;\n\t\t\ttm->tm_wday %= 7;\n\t\t} else {\n\t\t\t \n\t\t\ttm->tm_wday = -1;\n\t\t\ttm->tm_mday = (alrmar & STM32_RTC_ALRMXR_DATE) >>\n\t\t\t\t       STM32_RTC_ALRMXR_DATE_SHIFT;\n\t\t}\n\t}\n\n\tif (alrmar & STM32_RTC_ALRMXR_HOUR_MASK) {\n\t\t \n\t\ttm->tm_hour = -1;\n\t} else {\n\t\ttm->tm_hour = (alrmar & STM32_RTC_ALRMXR_HOUR) >>\n\t\t\t       STM32_RTC_ALRMXR_HOUR_SHIFT;\n\t\tif (alrmar & STM32_RTC_ALRMXR_PM)\n\t\t\ttm->tm_hour += 12;\n\t}\n\n\tif (alrmar & STM32_RTC_ALRMXR_MIN_MASK) {\n\t\t \n\t\ttm->tm_min = -1;\n\t} else {\n\t\ttm->tm_min = (alrmar & STM32_RTC_ALRMXR_MIN) >>\n\t\t\t      STM32_RTC_ALRMXR_MIN_SHIFT;\n\t}\n\n\tif (alrmar & STM32_RTC_ALRMXR_SEC_MASK) {\n\t\t \n\t\ttm->tm_sec = -1;\n\t} else {\n\t\ttm->tm_sec = (alrmar & STM32_RTC_ALRMXR_SEC) >>\n\t\t\t      STM32_RTC_ALRMXR_SEC_SHIFT;\n\t}\n\n\tbcd2tm(tm);\n\n\talrm->enabled = (cr & STM32_RTC_CR_ALRAE) ? 1 : 0;\n\talrm->pending = (status & evts->alra) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int stm32_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tconst struct stm32_rtc_events *evts = &rtc->data->events;\n\tunsigned int cr;\n\n\tcr = readl_relaxed(rtc->base + regs->cr);\n\n\tstm32_rtc_wpr_unlock(rtc);\n\n\t \n\tif (enabled)\n\t\tcr |= (STM32_RTC_CR_ALRAIE | STM32_RTC_CR_ALRAE);\n\telse\n\t\tcr &= ~(STM32_RTC_CR_ALRAIE | STM32_RTC_CR_ALRAE);\n\twritel_relaxed(cr, rtc->base + regs->cr);\n\n\t \n\tstm32_rtc_clear_event_flags(rtc, evts->alra);\n\n\tstm32_rtc_wpr_lock(rtc);\n\n\treturn 0;\n}\n\nstatic int stm32_rtc_valid_alrm(struct device *dev, struct rtc_time *tm)\n{\n\tstatic struct rtc_time now;\n\ttime64_t max_alarm_time64;\n\tint max_day_forward;\n\tint next_month;\n\tint next_year;\n\n\t \n\tstm32_rtc_read_time(dev, &now);\n\n\t \n\tnext_month = now.tm_mon + 1;\n\tif (next_month == 12) {\n\t\tnext_month = 0;\n\t\tnext_year = now.tm_year + 1;\n\t} else {\n\t\tnext_year = now.tm_year;\n\t}\n\n\t \n\tmax_day_forward = rtc_month_days(now.tm_mon, now.tm_year)\n\t\t\t - now.tm_mday\n\t\t\t + min(rtc_month_days(next_month, next_year), now.tm_mday);\n\n\t \n\tmax_alarm_time64 = rtc_tm_to_time64(&now) + max_day_forward * SEC_PER_DAY;\n\treturn rtc_tm_to_time64(tm) <= max_alarm_time64 ? 0 : -EINVAL;\n}\n\nstatic int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned int cr, isr, alrmar;\n\tint ret = 0;\n\n\t \n\tif (stm32_rtc_valid_alrm(dev, tm) < 0) {\n\t\tdev_err(dev, \"Alarm can be set only on upcoming month.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttm2bcd(tm);\n\n\talrmar = 0;\n\t \n\talrmar |= (tm->tm_mday << STM32_RTC_ALRMXR_DATE_SHIFT) &\n\t\t  STM32_RTC_ALRMXR_DATE;\n\t \n\talrmar &= ~STM32_RTC_ALRMXR_PM;\n\talrmar |= (tm->tm_hour << STM32_RTC_ALRMXR_HOUR_SHIFT) &\n\t\t  STM32_RTC_ALRMXR_HOUR;\n\talrmar |= (tm->tm_min << STM32_RTC_ALRMXR_MIN_SHIFT) &\n\t\t  STM32_RTC_ALRMXR_MIN;\n\talrmar |= (tm->tm_sec << STM32_RTC_ALRMXR_SEC_SHIFT) &\n\t\t  STM32_RTC_ALRMXR_SEC;\n\n\tstm32_rtc_wpr_unlock(rtc);\n\n\t \n\tcr = readl_relaxed(rtc->base + regs->cr);\n\tcr &= ~STM32_RTC_CR_ALRAE;\n\twritel_relaxed(cr, rtc->base + regs->cr);\n\n\t \n\tret = readl_relaxed_poll_timeout_atomic(rtc->base + regs->isr,\n\t\t\t\t\t\tisr,\n\t\t\t\t\t\t(isr & STM32_RTC_ISR_ALRAWF),\n\t\t\t\t\t\t10, 100000);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Alarm update not allowed\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\twritel_relaxed(alrmar, rtc->base + regs->alrmar);\n\n\tstm32_rtc_alarm_irq_enable(dev, alrm->enabled);\nend:\n\tstm32_rtc_wpr_lock(rtc);\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops stm32_rtc_ops = {\n\t.read_time\t= stm32_rtc_read_time,\n\t.set_time\t= stm32_rtc_set_time,\n\t.read_alarm\t= stm32_rtc_read_alarm,\n\t.set_alarm\t= stm32_rtc_set_alarm,\n\t.alarm_irq_enable = stm32_rtc_alarm_irq_enable,\n};\n\nstatic void stm32_rtc_clear_events(struct stm32_rtc *rtc,\n\t\t\t\t   unsigned int flags)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\n\t \n\twritel_relaxed(readl_relaxed(rtc->base + regs->isr) & ~flags,\n\t\t       rtc->base + regs->isr);\n}\n\nstatic const struct stm32_rtc_data stm32_rtc_data = {\n\t.has_pclk = false,\n\t.need_dbp = true,\n\t.need_accuracy = false,\n\t.regs = {\n\t\t.tr = 0x00,\n\t\t.dr = 0x04,\n\t\t.cr = 0x08,\n\t\t.isr = 0x0C,\n\t\t.prer = 0x10,\n\t\t.alrmar = 0x1C,\n\t\t.wpr = 0x24,\n\t\t.sr = 0x0C,  \n\t\t.scr = UNDEF_REG,\n\t\t.verr = UNDEF_REG,\n\t},\n\t.events = {\n\t\t.alra = STM32_RTC_ISR_ALRAF,\n\t},\n\t.clear_events = stm32_rtc_clear_events,\n};\n\nstatic const struct stm32_rtc_data stm32h7_rtc_data = {\n\t.has_pclk = true,\n\t.need_dbp = true,\n\t.need_accuracy = false,\n\t.regs = {\n\t\t.tr = 0x00,\n\t\t.dr = 0x04,\n\t\t.cr = 0x08,\n\t\t.isr = 0x0C,\n\t\t.prer = 0x10,\n\t\t.alrmar = 0x1C,\n\t\t.wpr = 0x24,\n\t\t.sr = 0x0C,  \n\t\t.scr = UNDEF_REG,\n\t\t.verr = UNDEF_REG,\n\t},\n\t.events = {\n\t\t.alra = STM32_RTC_ISR_ALRAF,\n\t},\n\t.clear_events = stm32_rtc_clear_events,\n};\n\nstatic void stm32mp1_rtc_clear_events(struct stm32_rtc *rtc,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct stm32_rtc_registers regs = rtc->data->regs;\n\n\t \n\twritel_relaxed(flags, rtc->base + regs.scr);\n}\n\nstatic const struct stm32_rtc_data stm32mp1_data = {\n\t.has_pclk = true,\n\t.need_dbp = false,\n\t.need_accuracy = true,\n\t.regs = {\n\t\t.tr = 0x00,\n\t\t.dr = 0x04,\n\t\t.cr = 0x18,\n\t\t.isr = 0x0C,  \n\t\t.prer = 0x10,\n\t\t.alrmar = 0x40,\n\t\t.wpr = 0x24,\n\t\t.sr = 0x50,\n\t\t.scr = 0x5C,\n\t\t.verr = 0x3F4,\n\t},\n\t.events = {\n\t\t.alra = STM32_RTC_SR_ALRA,\n\t},\n\t.clear_events = stm32mp1_rtc_clear_events,\n};\n\nstatic const struct of_device_id stm32_rtc_of_match[] = {\n\t{ .compatible = \"st,stm32-rtc\", .data = &stm32_rtc_data },\n\t{ .compatible = \"st,stm32h7-rtc\", .data = &stm32h7_rtc_data },\n\t{ .compatible = \"st,stm32mp1-rtc\", .data = &stm32mp1_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_rtc_of_match);\n\nstatic int stm32_rtc_init(struct platform_device *pdev,\n\t\t\t  struct stm32_rtc *rtc)\n{\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int prer, pred_a, pred_s, pred_a_max, pred_s_max, cr;\n\tunsigned int rate;\n\tint ret;\n\n\trate = clk_get_rate(rtc->rtc_ck);\n\n\t \n\tpred_a_max = STM32_RTC_PRER_PRED_A >> STM32_RTC_PRER_PRED_A_SHIFT;\n\tpred_s_max = STM32_RTC_PRER_PRED_S >> STM32_RTC_PRER_PRED_S_SHIFT;\n\n\tif (rate > (pred_a_max + 1) * (pred_s_max + 1)) {\n\t\tdev_err(&pdev->dev, \"rtc_ck rate is too high: %dHz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rtc->data->need_accuracy) {\n\t\tfor (pred_a = 0; pred_a <= pred_a_max; pred_a++) {\n\t\t\tpred_s = (rate / (pred_a + 1)) - 1;\n\n\t\t\tif (pred_s <= pred_s_max && ((pred_s + 1) * (pred_a + 1)) == rate)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {\n\t\t\tpred_s = (rate / (pred_a + 1)) - 1;\n\n\t\t\tif (((pred_s + 1) * (pred_a + 1)) == rate)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (pred_s > pred_s_max || pred_a > pred_a_max) {\n\t\tpred_a = pred_a_max;\n\t\tpred_s = (rate / (pred_a + 1)) - 1;\n\n\t\tdev_warn(&pdev->dev, \"rtc_ck is %s\\n\",\n\t\t\t (rate < ((pred_a + 1) * (pred_s + 1))) ?\n\t\t\t \"fast\" : \"slow\");\n\t}\n\n\tcr = readl_relaxed(rtc->base + regs->cr);\n\n\tprer = readl_relaxed(rtc->base + regs->prer);\n\tprer &= STM32_RTC_PRER_PRED_S | STM32_RTC_PRER_PRED_A;\n\n\tpred_s = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) &\n\t\t STM32_RTC_PRER_PRED_S;\n\tpred_a = (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) &\n\t\t STM32_RTC_PRER_PRED_A;\n\n\t \n\tif ((cr & STM32_RTC_CR_FMT) == 0 && prer == (pred_s | pred_a))\n\t\treturn 0;\n\n\tstm32_rtc_wpr_unlock(rtc);\n\n\tret = stm32_rtc_enter_init_mode(rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't enter in init mode. Prescaler config failed.\\n\");\n\t\tgoto end;\n\t}\n\n\twritel_relaxed(pred_s, rtc->base + regs->prer);\n\twritel_relaxed(pred_a | pred_s, rtc->base + regs->prer);\n\n\t \n\tcr &= ~STM32_RTC_CR_FMT;\n\twritel_relaxed(cr, rtc->base + regs->cr);\n\n\tstm32_rtc_exit_init_mode(rtc);\n\n\tret = stm32_rtc_wait_sync(rtc);\nend:\n\tstm32_rtc_wpr_lock(rtc);\n\n\treturn ret;\n}\n\nstatic int stm32_rtc_probe(struct platform_device *pdev)\n{\n\tstruct stm32_rtc *rtc;\n\tconst struct stm32_rtc_registers *regs;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base))\n\t\treturn PTR_ERR(rtc->base);\n\n\trtc->data = (struct stm32_rtc_data *)\n\t\t    of_device_get_match_data(&pdev->dev);\n\tregs = &rtc->data->regs;\n\n\tif (rtc->data->need_dbp) {\n\t\trtc->dbp = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t   \"st,syscfg\");\n\t\tif (IS_ERR(rtc->dbp)) {\n\t\t\tdev_err(&pdev->dev, \"no st,syscfg\\n\");\n\t\t\treturn PTR_ERR(rtc->dbp);\n\t\t}\n\n\t\tret = of_property_read_u32_index(pdev->dev.of_node, \"st,syscfg\",\n\t\t\t\t\t\t 1, &rtc->dbp_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"can't read DBP register offset\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = of_property_read_u32_index(pdev->dev.of_node, \"st,syscfg\",\n\t\t\t\t\t\t 2, &rtc->dbp_mask);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"can't read DBP register mask\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!rtc->data->has_pclk) {\n\t\trtc->pclk = NULL;\n\t\trtc->rtc_ck = devm_clk_get(&pdev->dev, NULL);\n\t} else {\n\t\trtc->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\t\tif (IS_ERR(rtc->pclk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rtc->pclk), \"no pclk clock\");\n\n\t\trtc->rtc_ck = devm_clk_get(&pdev->dev, \"rtc_ck\");\n\t}\n\tif (IS_ERR(rtc->rtc_ck))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rtc->rtc_ck), \"no rtc_ck clock\");\n\n\tif (rtc->data->has_pclk) {\n\t\tret = clk_prepare_enable(rtc->pclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(rtc->rtc_ck);\n\tif (ret)\n\t\tgoto err_no_rtc_ck;\n\n\tif (rtc->data->need_dbp)\n\t\tregmap_update_bits(rtc->dbp, rtc->dbp_reg,\n\t\t\t\t   rtc->dbp_mask, rtc->dbp_mask);\n\n\t \n\tret = stm32_rtc_init(pdev, rtc);\n\tif (ret)\n\t\tgoto err;\n\n\trtc->irq_alarm = platform_get_irq(pdev, 0);\n\tif (rtc->irq_alarm <= 0) {\n\t\tret = rtc->irq_alarm;\n\t\tgoto err;\n\t}\n\n\tret = device_init_wakeup(&pdev->dev, true);\n\tif (ret)\n\t\tgoto err;\n\n\tret = dev_pm_set_wake_irq(&pdev->dev, rtc->irq_alarm);\n\tif (ret)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\t\t&stm32_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc->rtc_dev)) {\n\t\tret = PTR_ERR(rtc->rtc_dev);\n\t\tdev_err(&pdev->dev, \"rtc device registration failed, err=%d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(&pdev->dev, rtc->irq_alarm, NULL,\n\t\t\t\t\tstm32_rtc_alarm_irq, IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ%d (alarm interrupt) already claimed\\n\",\n\t\t\trtc->irq_alarm);\n\t\tgoto err;\n\t}\n\n\t \n\tif (!(readl_relaxed(rtc->base + regs->isr) & STM32_RTC_ISR_INITS))\n\t\tdev_warn(&pdev->dev, \"Date/Time must be initialized\\n\");\n\n\tif (regs->verr != UNDEF_REG) {\n\t\tu32 ver = readl_relaxed(rtc->base + regs->verr);\n\n\t\tdev_info(&pdev->dev, \"registered rev:%d.%d\\n\",\n\t\t\t (ver >> STM32_RTC_VERR_MAJREV_SHIFT) & 0xF,\n\t\t\t (ver >> STM32_RTC_VERR_MINREV_SHIFT) & 0xF);\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(rtc->rtc_ck);\nerr_no_rtc_ck:\n\tif (rtc->data->has_pclk)\n\t\tclk_disable_unprepare(rtc->pclk);\n\n\tif (rtc->data->need_dbp)\n\t\tregmap_update_bits(rtc->dbp, rtc->dbp_reg, rtc->dbp_mask, 0);\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\n\treturn ret;\n}\n\nstatic void stm32_rtc_remove(struct platform_device *pdev)\n{\n\tstruct stm32_rtc *rtc = platform_get_drvdata(pdev);\n\tconst struct stm32_rtc_registers *regs = &rtc->data->regs;\n\tunsigned int cr;\n\n\t \n\tstm32_rtc_wpr_unlock(rtc);\n\tcr = readl_relaxed(rtc->base + regs->cr);\n\tcr &= ~STM32_RTC_CR_ALRAIE;\n\twritel_relaxed(cr, rtc->base + regs->cr);\n\tstm32_rtc_wpr_lock(rtc);\n\n\tclk_disable_unprepare(rtc->rtc_ck);\n\tif (rtc->data->has_pclk)\n\t\tclk_disable_unprepare(rtc->pclk);\n\n\t \n\tif (rtc->data->need_dbp)\n\t\tregmap_update_bits(rtc->dbp, rtc->dbp_reg, rtc->dbp_mask, 0);\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n}\n\nstatic int stm32_rtc_suspend(struct device *dev)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->data->has_pclk)\n\t\tclk_disable_unprepare(rtc->pclk);\n\n\treturn 0;\n}\n\nstatic int stm32_rtc_resume(struct device *dev)\n{\n\tstruct stm32_rtc *rtc = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (rtc->data->has_pclk) {\n\t\tret = clk_prepare_enable(rtc->pclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = stm32_rtc_wait_sync(rtc);\n\tif (ret < 0) {\n\t\tif (rtc->data->has_pclk)\n\t\t\tclk_disable_unprepare(rtc->pclk);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops stm32_rtc_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_rtc_suspend, stm32_rtc_resume)\n};\n\nstatic struct platform_driver stm32_rtc_driver = {\n\t.probe\t\t= stm32_rtc_probe,\n\t.remove_new\t= stm32_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &stm32_rtc_pm_ops,\n\t\t.of_match_table = stm32_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(stm32_rtc_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Real Time Clock driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}