{
  "module_name": "rtc-m48t86.c",
  "hash_id": "313e0819e442120afd2d97d9c9dde98828dcf9e01f60dca9c2418d6094718d20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-m48t86.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/bcd.h>\n#include <linux/io.h>\n\n#define M48T86_SEC\t\t0x00\n#define M48T86_SECALRM\t\t0x01\n#define M48T86_MIN\t\t0x02\n#define M48T86_MINALRM\t\t0x03\n#define M48T86_HOUR\t\t0x04\n#define M48T86_HOURALRM\t\t0x05\n#define M48T86_DOW\t\t0x06  \n#define M48T86_DOM\t\t0x07\n#define M48T86_MONTH\t\t0x08  \n#define M48T86_YEAR\t\t0x09  \n#define M48T86_A\t\t0x0a\n#define M48T86_B\t\t0x0b\n#define M48T86_B_SET\t\tBIT(7)\n#define M48T86_B_DM\t\tBIT(2)\n#define M48T86_B_H24\t\tBIT(1)\n#define M48T86_C\t\t0x0c\n#define M48T86_D\t\t0x0d\n#define M48T86_D_VRT\t\tBIT(7)\n#define M48T86_NVRAM(x)\t\t(0x0e + (x))\n#define M48T86_NVRAM_LEN\t114\n\nstruct m48t86_rtc_info {\n\tvoid __iomem *index_reg;\n\tvoid __iomem *data_reg;\n\tstruct rtc_device *rtc;\n};\n\nstatic unsigned char m48t86_readb(struct device *dev, unsigned long addr)\n{\n\tstruct m48t86_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char value;\n\n\twriteb(addr, info->index_reg);\n\tvalue = readb(info->data_reg);\n\n\treturn value;\n}\n\nstatic void m48t86_writeb(struct device *dev,\n\t\t\t  unsigned char value, unsigned long addr)\n{\n\tstruct m48t86_rtc_info *info = dev_get_drvdata(dev);\n\n\twriteb(addr, info->index_reg);\n\twriteb(value, info->data_reg);\n}\n\nstatic int m48t86_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char reg;\n\n\treg = m48t86_readb(dev, M48T86_B);\n\n\tif (reg & M48T86_B_DM) {\n\t\t \n\t\ttm->tm_sec\t= m48t86_readb(dev, M48T86_SEC);\n\t\ttm->tm_min\t= m48t86_readb(dev, M48T86_MIN);\n\t\ttm->tm_hour\t= m48t86_readb(dev, M48T86_HOUR) & 0x3f;\n\t\ttm->tm_mday\t= m48t86_readb(dev, M48T86_DOM);\n\t\t \n\t\ttm->tm_mon\t= m48t86_readb(dev, M48T86_MONTH) - 1;\n\t\ttm->tm_year\t= m48t86_readb(dev, M48T86_YEAR) + 100;\n\t\ttm->tm_wday\t= m48t86_readb(dev, M48T86_DOW);\n\t} else {\n\t\t \n\t\ttm->tm_sec\t= bcd2bin(m48t86_readb(dev, M48T86_SEC));\n\t\ttm->tm_min\t= bcd2bin(m48t86_readb(dev, M48T86_MIN));\n\t\ttm->tm_hour\t= bcd2bin(m48t86_readb(dev, M48T86_HOUR) &\n\t\t\t\t\t  0x3f);\n\t\ttm->tm_mday\t= bcd2bin(m48t86_readb(dev, M48T86_DOM));\n\t\t \n\t\ttm->tm_mon\t= bcd2bin(m48t86_readb(dev, M48T86_MONTH)) - 1;\n\t\ttm->tm_year\t= bcd2bin(m48t86_readb(dev, M48T86_YEAR)) + 100;\n\t\ttm->tm_wday\t= bcd2bin(m48t86_readb(dev, M48T86_DOW));\n\t}\n\n\t \n\tif (!(reg & M48T86_B_H24))\n\t\tif (m48t86_readb(dev, M48T86_HOUR) & 0x80)\n\t\t\ttm->tm_hour += 12;\n\n\treturn 0;\n}\n\nstatic int m48t86_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned char reg;\n\n\treg = m48t86_readb(dev, M48T86_B);\n\n\t \n\treg |= M48T86_B_SET | M48T86_B_H24;\n\tm48t86_writeb(dev, reg, M48T86_B);\n\n\tif (reg & M48T86_B_DM) {\n\t\t \n\t\tm48t86_writeb(dev, tm->tm_sec, M48T86_SEC);\n\t\tm48t86_writeb(dev, tm->tm_min, M48T86_MIN);\n\t\tm48t86_writeb(dev, tm->tm_hour, M48T86_HOUR);\n\t\tm48t86_writeb(dev, tm->tm_mday, M48T86_DOM);\n\t\tm48t86_writeb(dev, tm->tm_mon + 1, M48T86_MONTH);\n\t\tm48t86_writeb(dev, tm->tm_year % 100, M48T86_YEAR);\n\t\tm48t86_writeb(dev, tm->tm_wday, M48T86_DOW);\n\t} else {\n\t\t \n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_sec), M48T86_SEC);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_min), M48T86_MIN);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_hour), M48T86_HOUR);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_mday), M48T86_DOM);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_mon + 1), M48T86_MONTH);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_year % 100), M48T86_YEAR);\n\t\tm48t86_writeb(dev, bin2bcd(tm->tm_wday), M48T86_DOW);\n\t}\n\n\t \n\treg &= ~M48T86_B_SET;\n\tm48t86_writeb(dev, reg, M48T86_B);\n\n\treturn 0;\n}\n\nstatic int m48t86_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tunsigned char reg;\n\n\treg = m48t86_readb(dev, M48T86_B);\n\n\tseq_printf(seq, \"mode\\t\\t: %s\\n\",\n\t\t   (reg & M48T86_B_DM) ? \"binary\" : \"bcd\");\n\n\treg = m48t86_readb(dev, M48T86_D);\n\n\tseq_printf(seq, \"battery\\t\\t: %s\\n\",\n\t\t   (reg & M48T86_D_VRT) ? \"ok\" : \"exhausted\");\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops m48t86_rtc_ops = {\n\t.read_time\t= m48t86_rtc_read_time,\n\t.set_time\t= m48t86_rtc_set_time,\n\t.proc\t\t= m48t86_rtc_proc,\n};\n\nstatic int m48t86_nvram_read(void *priv, unsigned int off, void *buf,\n\t\t\t     size_t count)\n{\n\tstruct device *dev = priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\t((u8 *)buf)[i] = m48t86_readb(dev, M48T86_NVRAM(off + i));\n\n\treturn 0;\n}\n\nstatic int m48t86_nvram_write(void *priv, unsigned int off, void *buf,\n\t\t\t      size_t count)\n{\n\tstruct device *dev = priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tm48t86_writeb(dev, ((u8 *)buf)[i], M48T86_NVRAM(off + i));\n\n\treturn 0;\n}\n\n \nstatic bool m48t86_verify_chip(struct platform_device *pdev)\n{\n\tunsigned int offset0 = M48T86_NVRAM(M48T86_NVRAM_LEN - 2);\n\tunsigned int offset1 = M48T86_NVRAM(M48T86_NVRAM_LEN - 1);\n\tunsigned char tmp0, tmp1;\n\n\ttmp0 = m48t86_readb(&pdev->dev, offset0);\n\ttmp1 = m48t86_readb(&pdev->dev, offset1);\n\n\tm48t86_writeb(&pdev->dev, 0x00, offset0);\n\tm48t86_writeb(&pdev->dev, 0x55, offset1);\n\tif (m48t86_readb(&pdev->dev, offset1) == 0x55) {\n\t\tm48t86_writeb(&pdev->dev, 0xaa, offset1);\n\t\tif (m48t86_readb(&pdev->dev, offset1) == 0xaa &&\n\t\t    m48t86_readb(&pdev->dev, offset0) == 0x00) {\n\t\t\tm48t86_writeb(&pdev->dev, tmp0, offset0);\n\t\t\tm48t86_writeb(&pdev->dev, tmp1, offset1);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int m48t86_rtc_probe(struct platform_device *pdev)\n{\n\tstruct m48t86_rtc_info *info;\n\tunsigned char reg;\n\tint err;\n\tstruct nvmem_config m48t86_nvmem_cfg = {\n\t\t.name = \"m48t86_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = M48T86_NVRAM_LEN,\n\t\t.reg_read = m48t86_nvram_read,\n\t\t.reg_write = m48t86_nvram_write,\n\t\t.priv = &pdev->dev,\n\t};\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->index_reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->index_reg))\n\t\treturn PTR_ERR(info->index_reg);\n\n\tinfo->data_reg = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(info->data_reg))\n\t\treturn PTR_ERR(info->data_reg);\n\n\tdev_set_drvdata(&pdev->dev, info);\n\n\tif (!m48t86_verify_chip(pdev)) {\n\t\tdev_info(&pdev->dev, \"RTC not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc))\n\t\treturn PTR_ERR(info->rtc);\n\n\tinfo->rtc->ops = &m48t86_rtc_ops;\n\n\terr = devm_rtc_register_device(info->rtc);\n\tif (err)\n\t\treturn err;\n\n\tdevm_rtc_nvmem_register(info->rtc, &m48t86_nvmem_cfg);\n\n\t \n\treg = m48t86_readb(&pdev->dev, M48T86_D);\n\tdev_info(&pdev->dev, \"battery %s\\n\",\n\t\t (reg & M48T86_D_VRT) ? \"ok\" : \"exhausted\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id m48t86_rtc_of_ids[] = {\n\t{ .compatible = \"st,m48t86\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, m48t86_rtc_of_ids);\n\nstatic struct platform_driver m48t86_rtc_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-m48t86\",\n\t\t.of_match_table = m48t86_rtc_of_ids,\n\t},\n\t.probe\t\t= m48t86_rtc_probe,\n};\n\nmodule_platform_driver(m48t86_rtc_platform_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"M48T86 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-m48t86\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}