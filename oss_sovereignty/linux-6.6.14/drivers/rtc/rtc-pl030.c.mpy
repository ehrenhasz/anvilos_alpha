{
  "module_name": "rtc-pl030.c",
  "hash_id": "f57637c22399bfddd321e542aae6d2c82cad6473d0583e3113b2c5f3ec5aa668",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pl030.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/amba/bus.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#define RTC_DR\t\t(0)\n#define RTC_MR\t\t(4)\n#define RTC_STAT\t(8)\n#define RTC_EOI\t\t(8)\n#define RTC_LR\t\t(12)\n#define RTC_CR\t\t(16)\n#define RTC_CR_MIE\t(1 << 0)\n\nstruct pl030_rtc {\n\tstruct rtc_device\t*rtc;\n\tvoid __iomem\t\t*base;\n};\n\nstatic irqreturn_t pl030_interrupt(int irq, void *dev_id)\n{\n\tstruct pl030_rtc *rtc = dev_id;\n\twritel(0, rtc->base + RTC_EOI);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pl030_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pl030_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(rtc->base + RTC_MR), &alrm->time);\n\treturn 0;\n}\n\nstatic int pl030_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pl030_rtc *rtc = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(&alrm->time), rtc->base + RTC_MR);\n\n\treturn 0;\n}\n\nstatic int pl030_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pl030_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(rtc->base + RTC_DR), tm);\n\n\treturn 0;\n}\n\n \nstatic int pl030_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pl030_rtc *rtc = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(tm) + 1, rtc->base + RTC_LR);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pl030_ops = {\n\t.read_time\t= pl030_read_time,\n\t.set_time\t= pl030_set_time,\n\t.read_alarm\t= pl030_read_alarm,\n\t.set_alarm\t= pl030_set_alarm,\n};\n\nstatic int pl030_probe(struct amba_device *dev, const struct amba_id *id)\n{\n\tstruct pl030_rtc *rtc;\n\tint ret;\n\n\tret = amba_request_regions(dev, NULL);\n\tif (ret)\n\t\tgoto err_req;\n\n\trtc = devm_kzalloc(&dev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rtc;\n\t}\n\n\trtc->rtc = devm_rtc_allocate_device(&dev->dev);\n\tif (IS_ERR(rtc->rtc)) {\n\t\tret = PTR_ERR(rtc->rtc);\n\t\tgoto err_rtc;\n\t}\n\n\trtc->rtc->ops = &pl030_ops;\n\trtc->rtc->range_max = U32_MAX;\n\trtc->base = ioremap(dev->res.start, resource_size(&dev->res));\n\tif (!rtc->base) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rtc;\n\t}\n\n\t__raw_writel(0, rtc->base + RTC_CR);\n\t__raw_writel(0, rtc->base + RTC_EOI);\n\n\tamba_set_drvdata(dev, rtc);\n\n\tret = request_irq(dev->irq[0], pl030_interrupt, 0,\n\t\t\t  \"rtc-pl030\", rtc);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\tgoto err_reg;\n\n\treturn 0;\n\n err_reg:\n\tfree_irq(dev->irq[0], rtc);\n err_irq:\n\tiounmap(rtc->base);\n err_rtc:\n\tamba_release_regions(dev);\n err_req:\n\treturn ret;\n}\n\nstatic void pl030_remove(struct amba_device *dev)\n{\n\tstruct pl030_rtc *rtc = amba_get_drvdata(dev);\n\n\twritel(0, rtc->base + RTC_CR);\n\n\tfree_irq(dev->irq[0], rtc);\n\tiounmap(rtc->base);\n\tamba_release_regions(dev);\n}\n\nstatic struct amba_id pl030_ids[] = {\n\t{\n\t\t.id\t= 0x00041030,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, pl030_ids);\n\nstatic struct amba_driver pl030_driver = {\n\t.drv\t\t= {\n\t\t.name\t= \"rtc-pl030\",\n\t},\n\t.probe\t\t= pl030_probe,\n\t.remove\t\t= pl030_remove,\n\t.id_table\t= pl030_ids,\n};\n\nmodule_amba_driver(pl030_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"ARM AMBA PL030 RTC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}