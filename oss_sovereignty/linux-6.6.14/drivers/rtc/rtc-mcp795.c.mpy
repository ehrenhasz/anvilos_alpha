{
  "module_name": "rtc-mcp795.c",
  "hash_id": "30cb7795ee75093f05834754e605d7effc76c61a0b895338f7ea064a1d61356d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mcp795.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/printk.h>\n#include <linux/spi/spi.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n#include <linux/bcd.h>\n#include <linux/delay.h>\n\n \n#define MCP795_EEREAD\t0x03\n#define MCP795_EEWRITE\t0x02\n#define MCP795_EEWRDI\t0x04\n#define MCP795_EEWREN\t0x06\n#define MCP795_SRREAD\t0x05\n#define MCP795_SRWRITE\t0x01\n#define MCP795_READ\t0x13\n#define MCP795_WRITE\t0x12\n#define MCP795_UNLOCK\t0x14\n#define MCP795_IDWRITE\t0x32\n#define MCP795_IDREAD\t0x33\n#define MCP795_CLRWDT\t0x44\n#define MCP795_CLRRAM\t0x54\n\n \n#define MCP795_REG_SECONDS\t0x01\n#define MCP795_REG_DAY\t\t0x04\n#define MCP795_REG_MONTH\t0x06\n#define MCP795_REG_CONTROL\t0x08\n#define MCP795_REG_ALM0_SECONDS\t0x0C\n#define MCP795_REG_ALM0_DAY\t0x0F\n\n#define MCP795_ST_BIT\t\tBIT(7)\n#define MCP795_24_BIT\t\tBIT(6)\n#define MCP795_LP_BIT\t\tBIT(5)\n#define MCP795_EXTOSC_BIT\tBIT(3)\n#define MCP795_OSCON_BIT\tBIT(5)\n#define MCP795_ALM0_BIT\t\tBIT(4)\n#define MCP795_ALM1_BIT\t\tBIT(5)\n#define MCP795_ALM0IF_BIT\tBIT(3)\n#define MCP795_ALM0C0_BIT\tBIT(4)\n#define MCP795_ALM0C1_BIT\tBIT(5)\n#define MCP795_ALM0C2_BIT\tBIT(6)\n\n#define SEC_PER_DAY\t\t(24 * 60 * 60)\n\nstatic int mcp795_rtcc_read(struct device *dev, u8 addr, u8 *buf, u8 count)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tint ret;\n\tu8 tx[2];\n\n\ttx[0] = MCP795_READ;\n\ttx[1] = addr;\n\tret = spi_write_then_read(spi, tx, sizeof(tx), buf, count);\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed reading %d bytes from address %x.\\n\",\n\t\t\t\t\tcount, addr);\n\n\treturn ret;\n}\n\nstatic int mcp795_rtcc_write(struct device *dev, u8 addr, u8 *data, u8 count)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tint ret;\n\tu8 tx[257];\n\n\ttx[0] = MCP795_WRITE;\n\ttx[1] = addr;\n\tmemcpy(&tx[2], data, count);\n\n\tret = spi_write(spi, tx, 2 + count);\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to write %d bytes to address %x.\\n\",\n\t\t\t\t\tcount, addr);\n\n\treturn ret;\n}\n\nstatic int mcp795_rtcc_set_bits(struct device *dev, u8 addr, u8 mask, u8 state)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = mcp795_rtcc_read(dev, addr, &tmp, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((tmp & mask) != state) {\n\t\ttmp = (tmp & ~mask) | state;\n\t\tret = mcp795_rtcc_write(dev, addr, &tmp, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int mcp795_stop_oscillator(struct device *dev, bool *extosc)\n{\n\tint retries = 5;\n\tint ret;\n\tu8 data;\n\n\tret = mcp795_rtcc_set_bits(dev, MCP795_REG_SECONDS, MCP795_ST_BIT, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = mcp795_rtcc_read(dev, MCP795_REG_CONTROL, &data, 1);\n\tif (ret)\n\t\treturn ret;\n\t*extosc = !!(data & MCP795_EXTOSC_BIT);\n\tret = mcp795_rtcc_set_bits(\n\t\t\t\tdev, MCP795_REG_CONTROL, MCP795_EXTOSC_BIT, 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\tdo {\n\t\tusleep_range(700, 800);\n\t\tret = mcp795_rtcc_read(dev, MCP795_REG_DAY, &data, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(data & MCP795_OSCON_BIT))\n\t\t\tbreak;\n\n\t} while (--retries);\n\n\treturn !retries ? -EIO : ret;\n}\n\nstatic int mcp795_start_oscillator(struct device *dev, bool *extosc)\n{\n\tif (extosc) {\n\t\tu8 data = *extosc ? MCP795_EXTOSC_BIT : 0;\n\t\tint ret;\n\n\t\tret = mcp795_rtcc_set_bits(\n\t\t\tdev, MCP795_REG_CONTROL, MCP795_EXTOSC_BIT, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn mcp795_rtcc_set_bits(\n\t\t\tdev, MCP795_REG_SECONDS, MCP795_ST_BIT, MCP795_ST_BIT);\n}\n\n \nstatic int mcp795_update_alarm(struct device *dev, bool enable)\n{\n\tint ret;\n\n\tdev_dbg(dev, \"%s alarm\\n\", enable ? \"Enable\" : \"Disable\");\n\n\tif (enable) {\n\t\t \n\t\tret = mcp795_rtcc_set_bits(dev, MCP795_REG_ALM0_DAY,\n\t\t\t\t\tMCP795_ALM0IF_BIT, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = mcp795_rtcc_set_bits(dev, MCP795_REG_CONTROL,\n\t\t\t\t\tMCP795_ALM0_BIT, MCP795_ALM0_BIT);\n\t} else {\n\t\t \n\t\tret = mcp795_rtcc_set_bits(dev, MCP795_REG_CONTROL,\n\t\t\t\t\tMCP795_ALM0_BIT | MCP795_ALM1_BIT, 0);\n\t}\n\treturn ret;\n}\n\nstatic int mcp795_set_time(struct device *dev, struct rtc_time *tim)\n{\n\tint ret;\n\tu8 data[7];\n\tbool extosc;\n\n\t \n\tret = mcp795_stop_oscillator(dev, &extosc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mcp795_rtcc_read(dev, MCP795_REG_SECONDS, data, sizeof(data));\n\n\tif (ret)\n\t\treturn ret;\n\n\tdata[0] = (data[0] & 0x80) | bin2bcd(tim->tm_sec);\n\tdata[1] = (data[1] & 0x80) | bin2bcd(tim->tm_min);\n\tdata[2] = bin2bcd(tim->tm_hour);\n\tdata[3] = (data[3] & 0xF8) | bin2bcd(tim->tm_wday + 1);\n\tdata[4] = bin2bcd(tim->tm_mday);\n\tdata[5] = (data[5] & MCP795_LP_BIT) | bin2bcd(tim->tm_mon + 1);\n\n\tif (tim->tm_year > 100)\n\t\ttim->tm_year -= 100;\n\n\tdata[6] = bin2bcd(tim->tm_year);\n\n\t \n\tret = mcp795_rtcc_write(dev, MCP795_REG_SECONDS, data, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mcp795_rtcc_write(dev, MCP795_REG_MONTH, &data[5], 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mcp795_start_oscillator(dev, extosc ? &extosc : NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"Set mcp795: %ptR\\n\", tim);\n\n\treturn 0;\n}\n\nstatic int mcp795_read_time(struct device *dev, struct rtc_time *tim)\n{\n\tint ret;\n\tu8 data[7];\n\n\tret = mcp795_rtcc_read(dev, MCP795_REG_SECONDS, data, sizeof(data));\n\n\tif (ret)\n\t\treturn ret;\n\n\ttim->tm_sec\t= bcd2bin(data[0] & 0x7F);\n\ttim->tm_min\t= bcd2bin(data[1] & 0x7F);\n\ttim->tm_hour\t= bcd2bin(data[2] & 0x3F);\n\ttim->tm_wday\t= bcd2bin(data[3] & 0x07) - 1;\n\ttim->tm_mday\t= bcd2bin(data[4] & 0x3F);\n\ttim->tm_mon\t= bcd2bin(data[5] & 0x1F) - 1;\n\ttim->tm_year\t= bcd2bin(data[6]) + 100;  \n\n\tdev_dbg(dev, \"Read from mcp795: %ptR\\n\", tim);\n\n\treturn 0;\n}\n\nstatic int mcp795_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rtc_time now_tm;\n\ttime64_t now;\n\ttime64_t later;\n\tu8 tmp[6];\n\tint ret;\n\n\t \n\tret = mcp795_read_time(dev, &now_tm);\n\tif (ret)\n\t\treturn ret;\n\t \n\tnow = rtc_tm_to_time64(&now_tm);\n\tlater = rtc_tm_to_time64(&alm->time);\n\tif (later <= now)\n\t\treturn -EINVAL;\n\t \n\tif ((later - now) >=\n\t\t(SEC_PER_DAY * (365 + is_leap_year(alm->time.tm_year))))\n\t\treturn -EDOM;\n\t \n\tret = mcp795_update_alarm(dev, false);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = mcp795_rtcc_read(dev, MCP795_REG_ALM0_SECONDS, tmp, sizeof(tmp));\n\tif (ret)\n\t\treturn ret;\n\n\talm->time.tm_year\t= -1;\n\talm->time.tm_isdst\t= -1;\n\talm->time.tm_yday\t= -1;\n\n\ttmp[0] = (tmp[0] & 0x80) | bin2bcd(alm->time.tm_sec);\n\ttmp[1] = (tmp[1] & 0x80) | bin2bcd(alm->time.tm_min);\n\ttmp[2] = (tmp[2] & 0xE0) | bin2bcd(alm->time.tm_hour);\n\ttmp[3] = (tmp[3] & 0x80) | bin2bcd(alm->time.tm_wday + 1);\n\t \n\ttmp[3] |= (MCP795_ALM0C2_BIT | MCP795_ALM0C1_BIT | MCP795_ALM0C0_BIT);\n\ttmp[4] = (tmp[4] & 0xC0) | bin2bcd(alm->time.tm_mday);\n\ttmp[5] = (tmp[5] & 0xE0) | bin2bcd(alm->time.tm_mon + 1);\n\n\tret = mcp795_rtcc_write(dev, MCP795_REG_ALM0_SECONDS, tmp, sizeof(tmp));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (alm->enabled) {\n\t\tret = mcp795_update_alarm(dev, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_dbg(dev, \"Alarm IRQ armed\\n\");\n\t}\n\tdev_dbg(dev, \"Set alarm: %ptRdr(%d) %ptRt\\n\",\n\t\t&alm->time, alm->time.tm_wday, &alm->time);\n\treturn 0;\n}\n\nstatic int mcp795_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tu8 data[6];\n\tint ret;\n\n\tret = mcp795_rtcc_read(\n\t\t\tdev, MCP795_REG_ALM0_SECONDS, data, sizeof(data));\n\tif (ret)\n\t\treturn ret;\n\n\talm->time.tm_sec\t= bcd2bin(data[0] & 0x7F);\n\talm->time.tm_min\t= bcd2bin(data[1] & 0x7F);\n\talm->time.tm_hour\t= bcd2bin(data[2] & 0x1F);\n\talm->time.tm_wday\t= bcd2bin(data[3] & 0x07) - 1;\n\talm->time.tm_mday\t= bcd2bin(data[4] & 0x3F);\n\talm->time.tm_mon\t= bcd2bin(data[5] & 0x1F) - 1;\n\talm->time.tm_year\t= -1;\n\talm->time.tm_isdst\t= -1;\n\talm->time.tm_yday\t= -1;\n\n\tdev_dbg(dev, \"Read alarm: %ptRdr(%d) %ptRt\\n\",\n\t\t&alm->time, alm->time.tm_wday, &alm->time);\n\treturn 0;\n}\n\nstatic int mcp795_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\treturn mcp795_update_alarm(dev, !!enabled);\n}\n\nstatic irqreturn_t mcp795_irq(int irq, void *data)\n{\n\tstruct spi_device *spi = data;\n\tstruct rtc_device *rtc = spi_get_drvdata(spi);\n\tint ret;\n\n\trtc_lock(rtc);\n\n\t \n\tret = mcp795_update_alarm(&spi->dev, false);\n\tif (ret)\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed to disable alarm in IRQ (ret=%d)\\n\", ret);\n\trtc_update_irq(rtc, 1, RTC_AF | RTC_IRQF);\n\n\trtc_unlock(rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops mcp795_rtc_ops = {\n\t\t.read_time = mcp795_read_time,\n\t\t.set_time = mcp795_set_time,\n\t\t.read_alarm = mcp795_read_alarm,\n\t\t.set_alarm = mcp795_set_alarm,\n\t\t.alarm_irq_enable = mcp795_alarm_irq_enable\n};\n\nstatic int mcp795_probe(struct spi_device *spi)\n{\n\tstruct rtc_device *rtc;\n\tint ret;\n\n\tspi->mode = SPI_MODE_0;\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmcp795_start_oscillator(&spi->dev, NULL);\n\t \n\tmcp795_rtcc_set_bits(&spi->dev, 0x03, MCP795_24_BIT, 0);\n\n\trtc = devm_rtc_device_register(&spi->dev, \"rtc-mcp795\",\n\t\t\t\t\t&mcp795_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tspi_set_drvdata(spi, rtc);\n\n\tif (spi->irq > 0) {\n\t\tdev_dbg(&spi->dev, \"Alarm support enabled\\n\");\n\n\t\t \n\t\tmcp795_rtcc_set_bits(&spi->dev, MCP795_REG_ALM0_DAY,\n\t\t\t\t\tMCP795_ALM0IF_BIT, 0);\n\t\tret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,\n\t\t\t\tmcp795_irq, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\tdev_name(&rtc->dev), spi);\n\t\tif (ret)\n\t\t\tdev_err(&spi->dev, \"Failed to request IRQ: %d: %d\\n\",\n\t\t\t\t\t\tspi->irq, ret);\n\t\telse\n\t\t\tdevice_init_wakeup(&spi->dev, true);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mcp795_of_match[] = {\n\t{ .compatible = \"maxim,mcp795\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp795_of_match);\n#endif\n\nstatic const struct spi_device_id mcp795_spi_ids[] = {\n\t{ .name = \"mcp795\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mcp795_spi_ids);\n\nstatic struct spi_driver mcp795_driver = {\n\t\t.driver = {\n\t\t\t\t.name = \"rtc-mcp795\",\n\t\t\t\t.of_match_table = of_match_ptr(mcp795_of_match),\n\t\t},\n\t\t.probe = mcp795_probe,\n\t\t.id_table = mcp795_spi_ids,\n};\n\nmodule_spi_driver(mcp795_driver);\n\nMODULE_DESCRIPTION(\"MCP795 RTC SPI Driver\");\nMODULE_AUTHOR(\"Josef Gajdusek <atx@atx.name>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:mcp795\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}