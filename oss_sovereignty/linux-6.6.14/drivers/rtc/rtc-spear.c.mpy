{
  "module_name": "rtc-spear.c",
  "hash_id": "abe009ae4cfa0a3ebbb27a0b5f0c8aedee211bbbb61faeff155baa297ebfe732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-spear.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n \n#define TIME_REG\t\t0x00\n#define DATE_REG\t\t0x04\n#define ALARM_TIME_REG\t\t0x08\n#define ALARM_DATE_REG\t\t0x0C\n#define CTRL_REG\t\t0x10\n#define STATUS_REG\t\t0x14\n\n \n#define SECONDS_UNITS\t\t(0xf<<0)\t \n#define SECONDS_TENS\t\t(0x7<<4)\t \n#define MINUTES_UNITS\t\t(0xf<<8)\t \n#define MINUTES_TENS\t\t(0x7<<12)\t \n#define HOURS_UNITS\t\t(0xf<<16)\t \n#define HOURS_TENS\t\t(0x3<<20)\t \n\n \n#define DAYS_UNITS\t\t(0xf<<0)\t \n#define DAYS_TENS\t\t(0x3<<4)\t \n#define MONTHS_UNITS\t\t(0xf<<8)\t \n#define MONTHS_TENS\t\t(0x1<<12)\t \n#define YEARS_UNITS\t\t(0xf<<16)\t \n#define YEARS_TENS\t\t(0xf<<20)\t \n#define YEARS_HUNDREDS\t\t(0xf<<24)\t \n#define YEARS_MILLENIUMS\t(0xf<<28)\t \n\n \n#define SECOND_SHIFT\t\t0x00\t\t \n#define MINUTE_SHIFT\t\t0x08\t\t \n#define HOUR_SHIFT\t\t0x10\t\t \n#define MDAY_SHIFT\t\t0x00\t\t \n#define MONTH_SHIFT\t\t0x08\t\t \n#define YEAR_SHIFT\t\t0x10\t\t \n\n#define SECOND_MASK\t\t0x7F\n#define MIN_MASK\t\t0x7F\n#define HOUR_MASK\t\t0x3F\n#define DAY_MASK\t\t0x3F\n#define MONTH_MASK\t\t0x7F\n#define YEAR_MASK\t\t0xFFFF\n\n \n#define TIME_BYP\t\t(1<<9)\n#define INT_ENABLE\t\t(1<<31)\t\t \n\n \n#define CLK_UNCONNECTED\t\t(1<<0)\n#define PEND_WR_TIME\t\t(1<<2)\n#define PEND_WR_DATE\t\t(1<<3)\n#define LOST_WR_TIME\t\t(1<<4)\n#define LOST_WR_DATE\t\t(1<<5)\n#define RTC_INT_MASK\t\t(1<<31)\n#define STATUS_BUSY\t\t(PEND_WR_TIME | PEND_WR_DATE)\n#define STATUS_FAIL\t\t(LOST_WR_TIME | LOST_WR_DATE)\n\nstruct spear_rtc_config {\n\tstruct rtc_device *rtc;\n\tstruct clk *clk;\n\tspinlock_t lock;\n\tvoid __iomem *ioaddr;\n\tunsigned int irq_wake;\n};\n\nstatic inline void spear_rtc_clear_interrupt(struct spear_rtc_config *config)\n{\n\tunsigned int val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&config->lock, flags);\n\tval = readl(config->ioaddr + STATUS_REG);\n\tval |= RTC_INT_MASK;\n\twritel(val, config->ioaddr + STATUS_REG);\n\tspin_unlock_irqrestore(&config->lock, flags);\n}\n\nstatic inline void spear_rtc_enable_interrupt(struct spear_rtc_config *config)\n{\n\tunsigned int val;\n\n\tval = readl(config->ioaddr + CTRL_REG);\n\tif (!(val & INT_ENABLE)) {\n\t\tspear_rtc_clear_interrupt(config);\n\t\tval |= INT_ENABLE;\n\t\twritel(val, config->ioaddr + CTRL_REG);\n\t}\n}\n\nstatic inline void spear_rtc_disable_interrupt(struct spear_rtc_config *config)\n{\n\tunsigned int val;\n\n\tval = readl(config->ioaddr + CTRL_REG);\n\tif (val & INT_ENABLE) {\n\t\tval &= ~INT_ENABLE;\n\t\twritel(val, config->ioaddr + CTRL_REG);\n\t}\n}\n\nstatic inline int is_write_complete(struct spear_rtc_config *config)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&config->lock, flags);\n\tif ((readl(config->ioaddr + STATUS_REG)) & STATUS_FAIL)\n\t\tret = -EIO;\n\tspin_unlock_irqrestore(&config->lock, flags);\n\n\treturn ret;\n}\n\nstatic void rtc_wait_not_busy(struct spear_rtc_config *config)\n{\n\tint status, count = 0;\n\tunsigned long flags;\n\n\t \n\tfor (count = 0; count < 80; count++) {\n\t\tspin_lock_irqsave(&config->lock, flags);\n\t\tstatus = readl(config->ioaddr + STATUS_REG);\n\t\tspin_unlock_irqrestore(&config->lock, flags);\n\t\tif ((status & STATUS_BUSY) == 0)\n\t\t\tbreak;\n\t\t \n\t\tmsleep(1);\n\t}\n}\n\nstatic irqreturn_t spear_rtc_irq(int irq, void *dev_id)\n{\n\tstruct spear_rtc_config *config = dev_id;\n\tunsigned long events = 0;\n\tunsigned int irq_data;\n\n\tspin_lock(&config->lock);\n\tirq_data = readl(config->ioaddr + STATUS_REG);\n\tspin_unlock(&config->lock);\n\n\tif ((irq_data & RTC_INT_MASK)) {\n\t\tspear_rtc_clear_interrupt(config);\n\t\tevents = RTC_IRQF | RTC_AF;\n\t\trtc_update_irq(config->rtc, 1, events);\n\t\treturn IRQ_HANDLED;\n\t} else\n\t\treturn IRQ_NONE;\n\n}\n\nstatic void tm2bcd(struct rtc_time *tm)\n{\n\ttm->tm_sec = bin2bcd(tm->tm_sec);\n\ttm->tm_min = bin2bcd(tm->tm_min);\n\ttm->tm_hour = bin2bcd(tm->tm_hour);\n\ttm->tm_mday = bin2bcd(tm->tm_mday);\n\ttm->tm_mon = bin2bcd(tm->tm_mon + 1);\n\ttm->tm_year = bin2bcd(tm->tm_year);\n}\n\nstatic void bcd2tm(struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon) - 1;\n\t \n\ttm->tm_year = bcd2bin(tm->tm_year);\n}\n\n \nstatic int spear_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct spear_rtc_config *config = dev_get_drvdata(dev);\n\tunsigned int time, date;\n\n\t \n\trtc_wait_not_busy(config);\n\n\tdo {\n\t\ttime = readl(config->ioaddr + TIME_REG);\n\t\tdate = readl(config->ioaddr + DATE_REG);\n\t} while (time == readl(config->ioaddr + TIME_REG));\n\ttm->tm_sec = (time >> SECOND_SHIFT) & SECOND_MASK;\n\ttm->tm_min = (time >> MINUTE_SHIFT) & MIN_MASK;\n\ttm->tm_hour = (time >> HOUR_SHIFT) & HOUR_MASK;\n\ttm->tm_mday = (date >> MDAY_SHIFT) & DAY_MASK;\n\ttm->tm_mon = (date >> MONTH_SHIFT) & MONTH_MASK;\n\ttm->tm_year = (date >> YEAR_SHIFT) & YEAR_MASK;\n\n\tbcd2tm(tm);\n\treturn 0;\n}\n\n \nstatic int spear_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct spear_rtc_config *config = dev_get_drvdata(dev);\n\tunsigned int time, date;\n\n\ttm2bcd(tm);\n\n\trtc_wait_not_busy(config);\n\ttime = (tm->tm_sec << SECOND_SHIFT) | (tm->tm_min << MINUTE_SHIFT) |\n\t\t(tm->tm_hour << HOUR_SHIFT);\n\tdate = (tm->tm_mday << MDAY_SHIFT) | (tm->tm_mon << MONTH_SHIFT) |\n\t\t(tm->tm_year << YEAR_SHIFT);\n\twritel(time, config->ioaddr + TIME_REG);\n\twritel(date, config->ioaddr + DATE_REG);\n\n\treturn is_write_complete(config);\n}\n\n \nstatic int spear_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct spear_rtc_config *config = dev_get_drvdata(dev);\n\tunsigned int time, date;\n\n\trtc_wait_not_busy(config);\n\n\ttime = readl(config->ioaddr + ALARM_TIME_REG);\n\tdate = readl(config->ioaddr + ALARM_DATE_REG);\n\talm->time.tm_sec = (time >> SECOND_SHIFT) & SECOND_MASK;\n\talm->time.tm_min = (time >> MINUTE_SHIFT) & MIN_MASK;\n\talm->time.tm_hour = (time >> HOUR_SHIFT) & HOUR_MASK;\n\talm->time.tm_mday = (date >> MDAY_SHIFT) & DAY_MASK;\n\talm->time.tm_mon = (date >> MONTH_SHIFT) & MONTH_MASK;\n\talm->time.tm_year = (date >> YEAR_SHIFT) & YEAR_MASK;\n\n\tbcd2tm(&alm->time);\n\talm->enabled = readl(config->ioaddr + CTRL_REG) & INT_ENABLE;\n\n\treturn 0;\n}\n\n \nstatic int spear_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct spear_rtc_config *config = dev_get_drvdata(dev);\n\tunsigned int time, date;\n\tint err;\n\n\ttm2bcd(&alm->time);\n\n\trtc_wait_not_busy(config);\n\n\ttime = (alm->time.tm_sec << SECOND_SHIFT) | (alm->time.tm_min <<\n\t\t\tMINUTE_SHIFT) |\t(alm->time.tm_hour << HOUR_SHIFT);\n\tdate = (alm->time.tm_mday << MDAY_SHIFT) | (alm->time.tm_mon <<\n\t\t\tMONTH_SHIFT) | (alm->time.tm_year << YEAR_SHIFT);\n\n\twritel(time, config->ioaddr + ALARM_TIME_REG);\n\twritel(date, config->ioaddr + ALARM_DATE_REG);\n\terr = is_write_complete(config);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (alm->enabled)\n\t\tspear_rtc_enable_interrupt(config);\n\telse\n\t\tspear_rtc_disable_interrupt(config);\n\n\treturn 0;\n}\n\nstatic int spear_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct spear_rtc_config *config = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tspear_rtc_clear_interrupt(config);\n\n\tswitch (enabled) {\n\tcase 0:\n\t\t \n\t\tspear_rtc_disable_interrupt(config);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tspear_rtc_enable_interrupt(config);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops spear_rtc_ops = {\n\t.read_time = spear_rtc_read_time,\n\t.set_time = spear_rtc_set_time,\n\t.read_alarm = spear_rtc_read_alarm,\n\t.set_alarm = spear_rtc_set_alarm,\n\t.alarm_irq_enable = spear_alarm_irq_enable,\n};\n\nstatic int spear_rtc_probe(struct platform_device *pdev)\n{\n\tstruct spear_rtc_config *config;\n\tint status = 0;\n\tint irq;\n\n\tconfig = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\tconfig->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(config->rtc))\n\t\treturn PTR_ERR(config->rtc);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tstatus = devm_request_irq(&pdev->dev, irq, spear_rtc_irq, 0, pdev->name,\n\t\t\tconfig);\n\tif (status) {\n\t\tdev_err(&pdev->dev, \"Alarm interrupt IRQ%d already claimed\\n\",\n\t\t\t\tirq);\n\t\treturn status;\n\t}\n\n\tconfig->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(config->ioaddr))\n\t\treturn PTR_ERR(config->ioaddr);\n\n\tconfig->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(config->clk))\n\t\treturn PTR_ERR(config->clk);\n\n\tstatus = clk_prepare_enable(config->clk);\n\tif (status < 0)\n\t\treturn status;\n\n\tspin_lock_init(&config->lock);\n\tplatform_set_drvdata(pdev, config);\n\n\tconfig->rtc->ops = &spear_rtc_ops;\n\tconfig->rtc->range_min = RTC_TIMESTAMP_BEGIN_0000;\n\tconfig->rtc->range_max = RTC_TIMESTAMP_END_9999;\n\n\tstatus = devm_rtc_register_device(config->rtc);\n\tif (status)\n\t\tgoto err_disable_clock;\n\n\tif (!device_can_wakeup(&pdev->dev))\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n\nerr_disable_clock:\n\tclk_disable_unprepare(config->clk);\n\n\treturn status;\n}\n\nstatic void spear_rtc_remove(struct platform_device *pdev)\n{\n\tstruct spear_rtc_config *config = platform_get_drvdata(pdev);\n\n\tspear_rtc_disable_interrupt(config);\n\tclk_disable_unprepare(config->clk);\n\tdevice_init_wakeup(&pdev->dev, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int spear_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spear_rtc_config *config = platform_get_drvdata(pdev);\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (!enable_irq_wake(irq))\n\t\t\tconfig->irq_wake = 1;\n\t} else {\n\t\tspear_rtc_disable_interrupt(config);\n\t\tclk_disable(config->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int spear_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spear_rtc_config *config = platform_get_drvdata(pdev);\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (config->irq_wake) {\n\t\t\tdisable_irq_wake(irq);\n\t\t\tconfig->irq_wake = 0;\n\t\t}\n\t} else {\n\t\tclk_enable(config->clk);\n\t\tspear_rtc_enable_interrupt(config);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(spear_rtc_pm_ops, spear_rtc_suspend, spear_rtc_resume);\n\nstatic void spear_rtc_shutdown(struct platform_device *pdev)\n{\n\tstruct spear_rtc_config *config = platform_get_drvdata(pdev);\n\n\tspear_rtc_disable_interrupt(config);\n\tclk_disable(config->clk);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spear_rtc_id_table[] = {\n\t{ .compatible = \"st,spear600-rtc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spear_rtc_id_table);\n#endif\n\nstatic struct platform_driver spear_rtc_driver = {\n\t.probe = spear_rtc_probe,\n\t.remove_new = spear_rtc_remove,\n\t.shutdown = spear_rtc_shutdown,\n\t.driver = {\n\t\t.name = \"rtc-spear\",\n\t\t.pm = &spear_rtc_pm_ops,\n\t\t.of_match_table = of_match_ptr(spear_rtc_id_table),\n\t},\n};\n\nmodule_platform_driver(spear_rtc_driver);\n\nMODULE_ALIAS(\"platform:rtc-spear\");\nMODULE_AUTHOR(\"Rajeev Kumar <rajeev-dlh.kumar@st.com>\");\nMODULE_DESCRIPTION(\"ST SPEAr Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}