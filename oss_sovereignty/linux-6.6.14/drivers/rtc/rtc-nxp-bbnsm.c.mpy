{
  "module_name": "rtc-nxp-bbnsm.c",
  "hash_id": "4f858a6bdd8e5e3fe6f6a8a5b8c32820a40f0d9f00e10fe5dc170dac875a490f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-nxp-bbnsm.c",
  "human_readable_source": "\n\n\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define BBNSM_CTRL\t0x8\n#define BBNSM_INT_EN\t0x10\n#define BBNSM_EVENTS\t0x14\n#define BBNSM_RTC_LS\t0x40\n#define BBNSM_RTC_MS\t0x44\n#define BBNSM_TA\t0x50\n\n#define RTC_EN\t\t0x2\n#define RTC_EN_MSK\t0x3\n#define TA_EN\t\t(0x2 << 2)\n#define TA_DIS\t\t(0x1 << 2)\n#define TA_EN_MSK\t(0x3 << 2)\n#define RTC_INT_EN\t0x2\n#define TA_INT_EN\t(0x2 << 2)\n\n#define BBNSM_EVENT_TA\t(0x2 << 2)\n\n#define CNTR_TO_SECS_SH\t15\n\nstruct bbnsm_rtc {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\tint irq;\n\tstruct clk *clk;\n};\n\nstatic u32 bbnsm_read_counter(struct bbnsm_rtc *bbnsm)\n{\n\tu32 rtc_msb, rtc_lsb;\n\tunsigned int timeout = 100;\n\tu32 time;\n\tu32 tmp = 0;\n\n\tdo {\n\t\ttime = tmp;\n\t\t \n\t\tregmap_read(bbnsm->regmap, BBNSM_RTC_MS, &rtc_msb);\n\t\t \n\t\tregmap_read(bbnsm->regmap, BBNSM_RTC_LS, &rtc_lsb);\n\t\t \n\t\ttmp = (rtc_msb << 17) | (rtc_lsb >> 15);\n\t} while (tmp != time && --timeout);\n\n\treturn time;\n}\n\nstatic int bbnsm_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bbnsm_rtc *bbnsm = dev_get_drvdata(dev);\n\tunsigned long time;\n\tu32 val;\n\n\tregmap_read(bbnsm->regmap, BBNSM_CTRL, &val);\n\tif ((val & RTC_EN_MSK) != RTC_EN)\n\t\treturn -EINVAL;\n\n\ttime = bbnsm_read_counter(bbnsm);\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\nstatic int bbnsm_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bbnsm_rtc *bbnsm = dev_get_drvdata(dev);\n\tunsigned long time = rtc_tm_to_time64(tm);\n\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_CTRL, RTC_EN_MSK, 0);\n\n\t \n\tregmap_write(bbnsm->regmap, BBNSM_RTC_LS, time << CNTR_TO_SECS_SH);\n\tregmap_write(bbnsm->regmap, BBNSM_RTC_MS, time >> (32 - CNTR_TO_SECS_SH));\n\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_CTRL, RTC_EN_MSK, RTC_EN);\n\n\treturn 0;\n}\n\nstatic int bbnsm_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct bbnsm_rtc *bbnsm = dev_get_drvdata(dev);\n\tu32 bbnsm_events, bbnsm_ta;\n\n\tregmap_read(bbnsm->regmap, BBNSM_TA, &bbnsm_ta);\n\trtc_time64_to_tm(bbnsm_ta, &alrm->time);\n\n\tregmap_read(bbnsm->regmap, BBNSM_EVENTS, &bbnsm_events);\n\talrm->pending = (bbnsm_events & BBNSM_EVENT_TA) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int bbnsm_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct bbnsm_rtc *bbnsm = dev_get_drvdata(dev);\n\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_CTRL, TA_EN_MSK, enable ? TA_EN : TA_DIS);\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_INT_EN, TA_EN_MSK, enable ? TA_EN : TA_DIS);\n\n\treturn 0;\n}\n\nstatic int bbnsm_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct bbnsm_rtc *bbnsm = dev_get_drvdata(dev);\n\tunsigned long time = rtc_tm_to_time64(&alrm->time);\n\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_CTRL, TA_EN, TA_EN);\n\n\t \n\tregmap_write(bbnsm->regmap, BBNSM_TA, time);\n\n\treturn bbnsm_rtc_alarm_irq_enable(dev, alrm->enabled);\n}\n\nstatic const struct rtc_class_ops bbnsm_rtc_ops = {\n\t.read_time = bbnsm_rtc_read_time,\n\t.set_time = bbnsm_rtc_set_time,\n\t.read_alarm = bbnsm_rtc_read_alarm,\n\t.set_alarm = bbnsm_rtc_set_alarm,\n\t.alarm_irq_enable = bbnsm_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t bbnsm_rtc_irq_handler(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct bbnsm_rtc  *bbnsm = dev_get_drvdata(dev);\n\tu32 val;\n\n\tregmap_read(bbnsm->regmap, BBNSM_EVENTS, &val);\n\tif (val & BBNSM_EVENT_TA) {\n\t\tbbnsm_rtc_alarm_irq_enable(dev, false);\n\t\t \n\t\tregmap_write_bits(bbnsm->regmap, BBNSM_EVENTS, TA_EN_MSK, BBNSM_EVENT_TA);\n\t\trtc_update_irq(bbnsm->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int bbnsm_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct bbnsm_rtc *bbnsm;\n\tint ret;\n\n\tbbnsm = devm_kzalloc(&pdev->dev, sizeof(*bbnsm), GFP_KERNEL);\n\tif (!bbnsm)\n\t\treturn -ENOMEM;\n\n\tbbnsm->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(bbnsm->rtc))\n\t\treturn PTR_ERR(bbnsm->rtc);\n\n\tbbnsm->regmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(bbnsm->regmap)) {\n\t\tdev_dbg(&pdev->dev, \"bbnsm get regmap failed\\n\");\n\t\treturn PTR_ERR(bbnsm->regmap);\n\t}\n\n\tbbnsm->irq = platform_get_irq(pdev, 0);\n\tif (bbnsm->irq < 0)\n\t\treturn bbnsm->irq;\n\n\tplatform_set_drvdata(pdev, bbnsm);\n\n\t \n\tregmap_write(bbnsm->regmap, BBNSM_EVENTS, 0x7A);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tdev_pm_set_wake_irq(&pdev->dev, bbnsm->irq);\n\n\tret = devm_request_irq(&pdev->dev, bbnsm->irq, bbnsm_rtc_irq_handler,\n\t\t\t       IRQF_SHARED, \"rtc alarm\", &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request irq %d: %d\\n\",\n\t\t\tbbnsm->irq, ret);\n\t\treturn ret;\n\t}\n\n\tbbnsm->rtc->ops = &bbnsm_rtc_ops;\n\tbbnsm->rtc->range_max = U32_MAX;\n\n\treturn devm_rtc_register_device(bbnsm->rtc);\n}\n\nstatic const struct of_device_id bbnsm_dt_ids[] = {\n\t{ .compatible = \"nxp,imx93-bbnsm-rtc\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bbnsm_dt_ids);\n\nstatic struct platform_driver bbnsm_rtc_driver = {\n\t.driver = {\n\t\t.name = \"bbnsm_rtc\",\n\t\t.of_match_table = bbnsm_dt_ids,\n\t},\n\t.probe = bbnsm_rtc_probe,\n};\nmodule_platform_driver(bbnsm_rtc_driver);\n\nMODULE_AUTHOR(\"Jacky Bai <ping.bai@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP BBNSM RTC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}