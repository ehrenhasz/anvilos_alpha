{
  "module_name": "rtc-rp5c01.c",
  "hash_id": "f77a0b16692c88a1739d2a10cf48bed481ae1d58f92dad001ce450f7d3c380a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rp5c01.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n\nenum {\n\tRP5C01_1_SECOND\t\t= 0x0,\t \n\tRP5C01_10_SECOND\t= 0x1,\t \n\tRP5C01_1_MINUTE\t\t= 0x2,\t \n\tRP5C01_10_MINUTE\t= 0x3,\t \n\tRP5C01_1_HOUR\t\t= 0x4,\t \n\tRP5C01_10_HOUR\t\t= 0x5,\t \n\tRP5C01_DAY_OF_WEEK\t= 0x6,\t \n\tRP5C01_1_DAY\t\t= 0x7,\t \n\tRP5C01_10_DAY\t\t= 0x8,\t \n\tRP5C01_1_MONTH\t\t= 0x9,\t \n\tRP5C01_10_MONTH\t\t= 0xa,\t \n\tRP5C01_1_YEAR\t\t= 0xb,\t \n\tRP5C01_10_YEAR\t\t= 0xc,\t \n\n\tRP5C01_12_24_SELECT\t= 0xa,\t \n\tRP5C01_LEAP_YEAR\t= 0xb,\t \n\n\tRP5C01_MODE\t\t= 0xd,\t \n\tRP5C01_TEST\t\t= 0xe,\t \n\tRP5C01_RESET\t\t= 0xf,\t \n};\n\n#define RP5C01_12_24_SELECT_12\t(0 << 0)\n#define RP5C01_12_24_SELECT_24\t(1 << 0)\n\n#define RP5C01_10_HOUR_AM\t(0 << 1)\n#define RP5C01_10_HOUR_PM\t(1 << 1)\n\n#define RP5C01_MODE_TIMER_EN\t(1 << 3)\t \n#define RP5C01_MODE_ALARM_EN\t(1 << 2)\t \n\n#define RP5C01_MODE_MODE_MASK\t(3 << 0)\n#define RP5C01_MODE_MODE00\t(0 << 0)\t \n#define RP5C01_MODE_MODE01\t(1 << 0)\t \n#define RP5C01_MODE_RAM_BLOCK10\t(2 << 0)\t \n#define RP5C01_MODE_RAM_BLOCK11\t(3 << 0)\t \n\n#define RP5C01_RESET_1HZ_PULSE\t(1 << 3)\n#define RP5C01_RESET_16HZ_PULSE\t(1 << 2)\n#define RP5C01_RESET_SECOND\t(1 << 1)\t \n\t\t\t\t\t\t \n#define RP5C01_RESET_ALARM\t(1 << 0)\t \n\n\nstruct rp5c01_priv {\n\tu32 __iomem *regs;\n\tstruct rtc_device *rtc;\n\tspinlock_t lock;\t \n};\n\nstatic inline unsigned int rp5c01_read(struct rp5c01_priv *priv,\n\t\t\t\t       unsigned int reg)\n{\n\treturn __raw_readl(&priv->regs[reg]) & 0xf;\n}\n\nstatic inline void rp5c01_write(struct rp5c01_priv *priv, unsigned int val,\n\t\t\t\tunsigned int reg)\n{\n\t__raw_writel(val, &priv->regs[reg]);\n}\n\nstatic void rp5c01_lock(struct rp5c01_priv *priv)\n{\n\trp5c01_write(priv, RP5C01_MODE_MODE00, RP5C01_MODE);\n}\n\nstatic void rp5c01_unlock(struct rp5c01_priv *priv)\n{\n\trp5c01_write(priv, RP5C01_MODE_TIMER_EN | RP5C01_MODE_MODE01,\n\t\t     RP5C01_MODE);\n}\n\nstatic int rp5c01_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rp5c01_priv *priv = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&priv->lock);\n\trp5c01_lock(priv);\n\n\ttm->tm_sec  = rp5c01_read(priv, RP5C01_10_SECOND) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_SECOND);\n\ttm->tm_min  = rp5c01_read(priv, RP5C01_10_MINUTE) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_MINUTE);\n\ttm->tm_hour = rp5c01_read(priv, RP5C01_10_HOUR) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_HOUR);\n\ttm->tm_mday = rp5c01_read(priv, RP5C01_10_DAY) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_DAY);\n\ttm->tm_wday = rp5c01_read(priv, RP5C01_DAY_OF_WEEK);\n\ttm->tm_mon  = rp5c01_read(priv, RP5C01_10_MONTH) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_MONTH) - 1;\n\ttm->tm_year = rp5c01_read(priv, RP5C01_10_YEAR) * 10 +\n\t\t      rp5c01_read(priv, RP5C01_1_YEAR);\n\tif (tm->tm_year <= 69)\n\t\ttm->tm_year += 100;\n\n\trp5c01_unlock(priv);\n\tspin_unlock_irq(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rp5c01_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rp5c01_priv *priv = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&priv->lock);\n\trp5c01_lock(priv);\n\n\trp5c01_write(priv, tm->tm_sec / 10, RP5C01_10_SECOND);\n\trp5c01_write(priv, tm->tm_sec % 10, RP5C01_1_SECOND);\n\trp5c01_write(priv, tm->tm_min / 10, RP5C01_10_MINUTE);\n\trp5c01_write(priv, tm->tm_min % 10, RP5C01_1_MINUTE);\n\trp5c01_write(priv, tm->tm_hour / 10, RP5C01_10_HOUR);\n\trp5c01_write(priv, tm->tm_hour % 10, RP5C01_1_HOUR);\n\trp5c01_write(priv, tm->tm_mday / 10, RP5C01_10_DAY);\n\trp5c01_write(priv, tm->tm_mday % 10, RP5C01_1_DAY);\n\tif (tm->tm_wday != -1)\n\t\trp5c01_write(priv, tm->tm_wday, RP5C01_DAY_OF_WEEK);\n\trp5c01_write(priv, (tm->tm_mon + 1) / 10, RP5C01_10_MONTH);\n\trp5c01_write(priv, (tm->tm_mon + 1) % 10, RP5C01_1_MONTH);\n\tif (tm->tm_year >= 100)\n\t\ttm->tm_year -= 100;\n\trp5c01_write(priv, tm->tm_year / 10, RP5C01_10_YEAR);\n\trp5c01_write(priv, tm->tm_year % 10, RP5C01_1_YEAR);\n\n\trp5c01_unlock(priv);\n\tspin_unlock_irq(&priv->lock);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops rp5c01_rtc_ops = {\n\t.read_time\t= rp5c01_read_time,\n\t.set_time\t= rp5c01_set_time,\n};\n\n\n \n\nstatic int rp5c01_nvram_read(void *_priv, unsigned int pos, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct rp5c01_priv *priv = _priv;\n\tu8 *buf = val;\n\n\tspin_lock_irq(&priv->lock);\n\n\tfor (; bytes; bytes--) {\n\t\tu8 data;\n\n\t\trp5c01_write(priv,\n\t\t\t     RP5C01_MODE_TIMER_EN | RP5C01_MODE_RAM_BLOCK10,\n\t\t\t     RP5C01_MODE);\n\t\tdata = rp5c01_read(priv, pos) << 4;\n\t\trp5c01_write(priv,\n\t\t\t     RP5C01_MODE_TIMER_EN | RP5C01_MODE_RAM_BLOCK11,\n\t\t\t     RP5C01_MODE);\n\t\tdata |= rp5c01_read(priv, pos++);\n\t\trp5c01_write(priv, RP5C01_MODE_TIMER_EN | RP5C01_MODE_MODE01,\n\t\t\t     RP5C01_MODE);\n\t\t*buf++ = data;\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\treturn 0;\n}\n\nstatic int rp5c01_nvram_write(void *_priv, unsigned int pos, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct rp5c01_priv *priv = _priv;\n\tu8 *buf = val;\n\n\tspin_lock_irq(&priv->lock);\n\n\tfor (; bytes; bytes--) {\n\t\tu8 data = *buf++;\n\n\t\trp5c01_write(priv,\n\t\t\t     RP5C01_MODE_TIMER_EN | RP5C01_MODE_RAM_BLOCK10,\n\t\t\t     RP5C01_MODE);\n\t\trp5c01_write(priv, data >> 4, pos);\n\t\trp5c01_write(priv,\n\t\t\t     RP5C01_MODE_TIMER_EN | RP5C01_MODE_RAM_BLOCK11,\n\t\t\t     RP5C01_MODE);\n\t\trp5c01_write(priv, data & 0xf, pos++);\n\t\trp5c01_write(priv, RP5C01_MODE_TIMER_EN | RP5C01_MODE_MODE01,\n\t\t\t     RP5C01_MODE);\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\treturn 0;\n}\n\nstatic int __init rp5c01_rtc_probe(struct platform_device *dev)\n{\n\tstruct resource *res;\n\tstruct rp5c01_priv *priv;\n\tstruct rtc_device *rtc;\n\tint error;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"rp5c01_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = RP5C01_MODE,\n\t\t.reg_read = rp5c01_nvram_read,\n\t\t.reg_write = rp5c01_nvram_write,\n\t};\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = devm_ioremap(&dev->dev, res->start, resource_size(res));\n\tif (!priv->regs)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\n\tplatform_set_drvdata(dev, priv);\n\n\trtc = devm_rtc_allocate_device(&dev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\trtc->ops = &rp5c01_rtc_ops;\n\n\tpriv->rtc = rtc;\n\n\tnvmem_cfg.priv = priv;\n\terror = devm_rtc_nvmem_register(rtc, &nvmem_cfg);\n\tif (error)\n\t\treturn error;\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic struct platform_driver rp5c01_rtc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rtc-rp5c01\",\n\t},\n};\n\nmodule_platform_driver_probe(rp5c01_rtc_driver, rp5c01_rtc_probe);\n\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert@linux-m68k.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Ricoh RP5C01 RTC driver\");\nMODULE_ALIAS(\"platform:rtc-rp5c01\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}