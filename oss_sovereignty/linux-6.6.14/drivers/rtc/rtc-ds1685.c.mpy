{
  "module_name": "rtc-ds1685.c",
  "hash_id": "27b0f3d1cd021bce1605b64966da4647516c710be51e47be6a7a666685834959",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1685.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/workqueue.h>\n\n#include <linux/rtc/ds1685.h>\n\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#endif\n\n\n \n \n\n \nstatic u8\nds1685_read(struct ds1685_priv *rtc, int reg)\n{\n\treturn readb((u8 __iomem *)rtc->regs +\n\t\t     (reg * rtc->regstep));\n}\n\n \nstatic void\nds1685_write(struct ds1685_priv *rtc, int reg, u8 value)\n{\n\twriteb(value, ((u8 __iomem *)rtc->regs +\n\t\t       (reg * rtc->regstep)));\n}\n \n\n \n\n \nstatic u8\nds1685_indirect_read(struct ds1685_priv *rtc, int reg)\n{\n\twriteb(reg, rtc->regs);\n\treturn readb(rtc->data);\n}\n\n \nstatic void\nds1685_indirect_write(struct ds1685_priv *rtc, int reg, u8 value)\n{\n\twriteb(reg, rtc->regs);\n\twriteb(value, rtc->data);\n}\n\n \n \n\n \nstatic inline u8\nds1685_rtc_bcd2bin(struct ds1685_priv *rtc, u8 val, u8 bcd_mask, u8 bin_mask)\n{\n\tif (rtc->bcd_mode)\n\t\treturn (bcd2bin(val) & bcd_mask);\n\n\treturn (val & bin_mask);\n}\n\n \nstatic inline u8\nds1685_rtc_bin2bcd(struct ds1685_priv *rtc, u8 val, u8 bin_mask, u8 bcd_mask)\n{\n\tif (rtc->bcd_mode)\n\t\treturn (bin2bcd(val) & bcd_mask);\n\n\treturn (val & bin_mask);\n}\n\n \nstatic inline int\nds1685_rtc_check_mday(struct ds1685_priv *rtc, u8 mday)\n{\n\tif (rtc->bcd_mode) {\n\t\tif (mday < 0x01 || mday > 0x31 || (mday & 0x0f) > 0x09)\n\t\t\treturn -EDOM;\n\t} else {\n\t\tif (mday < 1 || mday > 31)\n\t\t\treturn -EDOM;\n\t}\n\treturn 0;\n}\n\n \nstatic inline void\nds1685_rtc_switch_to_bank0(struct ds1685_priv *rtc)\n{\n\trtc->write(rtc, RTC_CTRL_A,\n\t\t   (rtc->read(rtc, RTC_CTRL_A) & ~(RTC_CTRL_A_DV0)));\n}\n\n \nstatic inline void\nds1685_rtc_switch_to_bank1(struct ds1685_priv *rtc)\n{\n\trtc->write(rtc, RTC_CTRL_A,\n\t\t   (rtc->read(rtc, RTC_CTRL_A) | RTC_CTRL_A_DV0));\n}\n\n \nstatic inline void\nds1685_rtc_begin_data_access(struct ds1685_priv *rtc)\n{\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) | RTC_CTRL_B_SET));\n\n\t \n\tds1685_rtc_switch_to_bank1(rtc);\n\n\t \n\twhile (rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_INCR)\n\t\tcpu_relax();\n}\n\n \nstatic inline void\nds1685_rtc_end_data_access(struct ds1685_priv *rtc)\n{\n\t \n\tds1685_rtc_switch_to_bank0(rtc);\n\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_SET)));\n}\n\n \nstatic inline void\nds1685_rtc_get_ssn(struct ds1685_priv *rtc, u8 *ssn)\n{\n\tssn[0] = rtc->read(rtc, RTC_BANK1_SSN_MODEL);\n\tssn[1] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_1);\n\tssn[2] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_2);\n\tssn[3] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_3);\n\tssn[4] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_4);\n\tssn[5] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_5);\n\tssn[6] = rtc->read(rtc, RTC_BANK1_SSN_BYTE_6);\n\tssn[7] = rtc->read(rtc, RTC_BANK1_SSN_CRC);\n}\n \n\n\n \n \n\n \nstatic int\nds1685_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\tu8 century;\n\tu8 seconds, minutes, hours, wday, mday, month, years;\n\n\t \n\tds1685_rtc_begin_data_access(rtc);\n\tseconds = rtc->read(rtc, RTC_SECS);\n\tminutes = rtc->read(rtc, RTC_MINS);\n\thours   = rtc->read(rtc, RTC_HRS);\n\twday    = rtc->read(rtc, RTC_WDAY);\n\tmday    = rtc->read(rtc, RTC_MDAY);\n\tmonth   = rtc->read(rtc, RTC_MONTH);\n\tyears   = rtc->read(rtc, RTC_YEAR);\n\tcentury = rtc->read(rtc, RTC_CENTURY);\n\tds1685_rtc_end_data_access(rtc);\n\n\t \n\tyears        = ds1685_rtc_bcd2bin(rtc, years, RTC_YEAR_BCD_MASK,\n\t\t\t\t\t  RTC_YEAR_BIN_MASK);\n\tcentury      = ds1685_rtc_bcd2bin(rtc, century, RTC_CENTURY_MASK,\n\t\t\t\t\t  RTC_CENTURY_MASK);\n\ttm->tm_sec   = ds1685_rtc_bcd2bin(rtc, seconds, RTC_SECS_BCD_MASK,\n\t\t\t\t\t  RTC_SECS_BIN_MASK);\n\ttm->tm_min   = ds1685_rtc_bcd2bin(rtc, minutes, RTC_MINS_BCD_MASK,\n\t\t\t\t\t  RTC_MINS_BIN_MASK);\n\ttm->tm_hour  = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_24_BCD_MASK,\n\t\t\t\t\t  RTC_HRS_24_BIN_MASK);\n\ttm->tm_wday  = (ds1685_rtc_bcd2bin(rtc, wday, RTC_WDAY_MASK,\n\t\t\t\t\t   RTC_WDAY_MASK) - 1);\n\ttm->tm_mday  = ds1685_rtc_bcd2bin(rtc, mday, RTC_MDAY_BCD_MASK,\n\t\t\t\t\t  RTC_MDAY_BIN_MASK);\n\ttm->tm_mon   = (ds1685_rtc_bcd2bin(rtc, month, RTC_MONTH_BCD_MASK,\n\t\t\t\t\t   RTC_MONTH_BIN_MASK) - 1);\n\ttm->tm_year  = ((years + (century * 100)) - 1900);\n\ttm->tm_yday  = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\n\ttm->tm_isdst = 0;  \n\n\treturn 0;\n}\n\n \nstatic int\nds1685_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\tu8 ctrlb, seconds, minutes, hours, wday, mday, month, years, century;\n\n\t \n\tseconds = ds1685_rtc_bin2bcd(rtc, tm->tm_sec, RTC_SECS_BIN_MASK,\n\t\t\t\t     RTC_SECS_BCD_MASK);\n\tminutes = ds1685_rtc_bin2bcd(rtc, tm->tm_min, RTC_MINS_BIN_MASK,\n\t\t\t\t     RTC_MINS_BCD_MASK);\n\thours   = ds1685_rtc_bin2bcd(rtc, tm->tm_hour, RTC_HRS_24_BIN_MASK,\n\t\t\t\t     RTC_HRS_24_BCD_MASK);\n\twday    = ds1685_rtc_bin2bcd(rtc, (tm->tm_wday + 1), RTC_WDAY_MASK,\n\t\t\t\t     RTC_WDAY_MASK);\n\tmday    = ds1685_rtc_bin2bcd(rtc, tm->tm_mday, RTC_MDAY_BIN_MASK,\n\t\t\t\t     RTC_MDAY_BCD_MASK);\n\tmonth   = ds1685_rtc_bin2bcd(rtc, (tm->tm_mon + 1), RTC_MONTH_BIN_MASK,\n\t\t\t\t     RTC_MONTH_BCD_MASK);\n\tyears   = ds1685_rtc_bin2bcd(rtc, (tm->tm_year % 100),\n\t\t\t\t     RTC_YEAR_BIN_MASK, RTC_YEAR_BCD_MASK);\n\tcentury = ds1685_rtc_bin2bcd(rtc, ((tm->tm_year + 1900) / 100),\n\t\t\t\t     RTC_CENTURY_MASK, RTC_CENTURY_MASK);\n\n\t \n\tif ((tm->tm_mon > 11) || (mday == 0))\n\t\treturn -EDOM;\n\n\tif (tm->tm_mday > rtc_month_days(tm->tm_mon, tm->tm_year))\n\t\treturn -EDOM;\n\n\tif ((tm->tm_hour >= 24) || (tm->tm_min >= 60) ||\n\t    (tm->tm_sec >= 60)  || (wday > 7))\n\t\treturn -EDOM;\n\n\t \n\tds1685_rtc_begin_data_access(rtc);\n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\tif (rtc->bcd_mode)\n\t\tctrlb &= ~(RTC_CTRL_B_DM);\n\telse\n\t\tctrlb |= RTC_CTRL_B_DM;\n\trtc->write(rtc, RTC_CTRL_B, ctrlb);\n\trtc->write(rtc, RTC_SECS, seconds);\n\trtc->write(rtc, RTC_MINS, minutes);\n\trtc->write(rtc, RTC_HRS, hours);\n\trtc->write(rtc, RTC_WDAY, wday);\n\trtc->write(rtc, RTC_MDAY, mday);\n\trtc->write(rtc, RTC_MONTH, month);\n\trtc->write(rtc, RTC_YEAR, years);\n\trtc->write(rtc, RTC_CENTURY, century);\n\tds1685_rtc_end_data_access(rtc);\n\n\treturn 0;\n}\n\n \nstatic int\nds1685_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\tu8 seconds, minutes, hours, mday, ctrlb, ctrlc;\n\tint ret;\n\n\t \n\tds1685_rtc_begin_data_access(rtc);\n\tseconds\t= rtc->read(rtc, RTC_SECS_ALARM);\n\tminutes\t= rtc->read(rtc, RTC_MINS_ALARM);\n\thours\t= rtc->read(rtc, RTC_HRS_ALARM);\n\tmday\t= rtc->read(rtc, RTC_MDAY_ALARM);\n\tctrlb\t= rtc->read(rtc, RTC_CTRL_B);\n\tctrlc\t= rtc->read(rtc, RTC_CTRL_C);\n\tds1685_rtc_end_data_access(rtc);\n\n\t \n\tret = ds1685_rtc_check_mday(rtc, mday);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (likely(seconds < 0xc0))\n\t\talrm->time.tm_sec = ds1685_rtc_bcd2bin(rtc, seconds,\n\t\t\t\t\t\t       RTC_SECS_BCD_MASK,\n\t\t\t\t\t\t       RTC_SECS_BIN_MASK);\n\n\tif (likely(minutes < 0xc0))\n\t\talrm->time.tm_min = ds1685_rtc_bcd2bin(rtc, minutes,\n\t\t\t\t\t\t       RTC_MINS_BCD_MASK,\n\t\t\t\t\t\t       RTC_MINS_BIN_MASK);\n\n\tif (likely(hours < 0xc0))\n\t\talrm->time.tm_hour = ds1685_rtc_bcd2bin(rtc, hours,\n\t\t\t\t\t\t\tRTC_HRS_24_BCD_MASK,\n\t\t\t\t\t\t\tRTC_HRS_24_BIN_MASK);\n\n\t \n\talrm->time.tm_mday = ds1685_rtc_bcd2bin(rtc, mday, RTC_MDAY_BCD_MASK,\n\t\t\t\t\t\tRTC_MDAY_BIN_MASK);\n\talrm->enabled = !!(ctrlb & RTC_CTRL_B_AIE);\n\talrm->pending = !!(ctrlc & RTC_CTRL_C_AF);\n\n\treturn 0;\n}\n\n \nstatic int\nds1685_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\tu8 ctrlb, seconds, minutes, hours, mday;\n\tint ret;\n\n\t \n\tseconds\t= ds1685_rtc_bin2bcd(rtc, alrm->time.tm_sec,\n\t\t\t\t     RTC_SECS_BIN_MASK,\n\t\t\t\t     RTC_SECS_BCD_MASK);\n\tminutes\t= ds1685_rtc_bin2bcd(rtc, alrm->time.tm_min,\n\t\t\t\t     RTC_MINS_BIN_MASK,\n\t\t\t\t     RTC_MINS_BCD_MASK);\n\thours\t= ds1685_rtc_bin2bcd(rtc, alrm->time.tm_hour,\n\t\t\t\t     RTC_HRS_24_BIN_MASK,\n\t\t\t\t     RTC_HRS_24_BCD_MASK);\n\tmday\t= ds1685_rtc_bin2bcd(rtc, alrm->time.tm_mday,\n\t\t\t\t     RTC_MDAY_BIN_MASK,\n\t\t\t\t     RTC_MDAY_BCD_MASK);\n\n\t \n\tret = ds1685_rtc_check_mday(rtc, mday);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (unlikely(seconds >= 0xc0))\n\t\tseconds = 0xff;\n\n\tif (unlikely(minutes >= 0xc0))\n\t\tminutes = 0xff;\n\n\tif (unlikely(hours >= 0xc0))\n\t\thours = 0xff;\n\n\talrm->time.tm_mon\t= -1;\n\talrm->time.tm_year\t= -1;\n\talrm->time.tm_wday\t= -1;\n\talrm->time.tm_yday\t= -1;\n\talrm->time.tm_isdst\t= -1;\n\n\t \n\tds1685_rtc_begin_data_access(rtc);\n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\trtc->write(rtc, RTC_CTRL_B, (ctrlb & ~(RTC_CTRL_B_AIE)));\n\n\t \n\trtc->read(rtc, RTC_CTRL_C);\n\n\t \n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\tif (rtc->bcd_mode)\n\t\tctrlb &= ~(RTC_CTRL_B_DM);\n\telse\n\t\tctrlb |= RTC_CTRL_B_DM;\n\trtc->write(rtc, RTC_CTRL_B, ctrlb);\n\trtc->write(rtc, RTC_SECS_ALARM, seconds);\n\trtc->write(rtc, RTC_MINS_ALARM, minutes);\n\trtc->write(rtc, RTC_HRS_ALARM, hours);\n\trtc->write(rtc, RTC_MDAY_ALARM, mday);\n\n\t \n\tif (alrm->enabled) {\n\t\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\t\tctrlb |= RTC_CTRL_B_AIE;\n\t\trtc->write(rtc, RTC_CTRL_B, ctrlb);\n\t}\n\n\t \n\tds1685_rtc_end_data_access(rtc);\n\n\treturn 0;\n}\n \n\n\n \n \n\n \nstatic int\nds1685_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\n\t \n\tif (enabled)\n\t\trtc->write(rtc, RTC_CTRL_B, (rtc->read(rtc, RTC_CTRL_B) |\n\t\t\t\t\t     RTC_CTRL_B_AIE));\n\telse\n\t\trtc->write(rtc, RTC_CTRL_B, (rtc->read(rtc, RTC_CTRL_B) &\n\t\t\t\t\t     ~(RTC_CTRL_B_AIE)));\n\n\t \n\trtc->read(rtc, RTC_CTRL_C);\n\n\treturn 0;\n}\n \n\n\n \n \n\n \nstatic void\nds1685_rtc_extended_irq(struct ds1685_priv *rtc, struct platform_device *pdev)\n{\n\tu8 ctrl4a, ctrl4b;\n\n\tds1685_rtc_switch_to_bank1(rtc);\n\tctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\n\tctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\n\n\t \n\tif ((ctrl4b & RTC_CTRL_4B_KSE) && (ctrl4a & RTC_CTRL_4A_KF)) {\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) &\n\t\t\t    ~(RTC_CTRL_4B_KSE)));\n\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (ctrl4a & ~(RTC_CTRL_4A_KF)));\n\n\n\t\t \n\t\tmsleep(500);\n\t\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) |\n\t\t\t    RTC_CTRL_4B_KSE));\n\n\t\t \n\t\tif (rtc->prepare_poweroff != NULL)\n\t\t\trtc->prepare_poweroff();\n\t\telse\n\t\t\tds1685_rtc_poweroff(pdev);\n\t}\n\n\t \n\tif ((ctrl4b & RTC_CTRL_4B_WIE) && (ctrl4a & RTC_CTRL_4A_WF)) {\n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (ctrl4a & ~(RTC_CTRL_4A_WF)));\n\n\t\t \n\t\tif (rtc->wake_alarm != NULL)\n\t\t\trtc->wake_alarm();\n\t\telse\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Wake Alarm IRQ just occurred!\\n\");\n\t}\n\n\t \n\tif ((ctrl4b & RTC_CTRL_4B_RIE) && (ctrl4a & RTC_CTRL_4A_RF)) {\n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (ctrl4a & ~(RTC_CTRL_4A_RF)));\n\t\tmsleep(150);\n\n\t\t \n\t\tif (rtc->post_ram_clear != NULL)\n\t\t\trtc->post_ram_clear();\n\t\telse\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"RAM-Clear IRQ just occurred!\\n\");\n\t}\n\tds1685_rtc_switch_to_bank0(rtc);\n}\n\n \nstatic irqreturn_t\nds1685_rtc_irq_handler(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\n\tu8 ctrlb, ctrlc;\n\tunsigned long events = 0;\n\tu8 num_irqs = 0;\n\n\t \n\tif (unlikely(!rtc))\n\t\treturn IRQ_HANDLED;\n\n\trtc_lock(rtc->dev);\n\n\t \n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\tctrlc = rtc->read(rtc, RTC_CTRL_C);\n\n\t \n\tif (likely(ctrlc & RTC_CTRL_C_IRQF)) {\n\t\t \n\t\tif (likely(ctrlc & RTC_CTRL_B_PAU_MASK)) {\n\t\t\tevents = RTC_IRQF;\n\n\t\t\t \n\t\t\tif ((ctrlb & RTC_CTRL_B_PIE) &&\n\t\t\t    (ctrlc & RTC_CTRL_C_PF)) {\n\t\t\t\tevents |= RTC_PF;\n\t\t\t\tnum_irqs++;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((ctrlb & RTC_CTRL_B_AIE) &&\n\t\t\t    (ctrlc & RTC_CTRL_C_AF)) {\n\t\t\t\tevents |= RTC_AF;\n\t\t\t\tnum_irqs++;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((ctrlb & RTC_CTRL_B_UIE) &&\n\t\t\t    (ctrlc & RTC_CTRL_C_UF)) {\n\t\t\t\tevents |= RTC_UF;\n\t\t\t\tnum_irqs++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tds1685_rtc_extended_irq(rtc, pdev);\n\t\t}\n\t}\n\trtc_update_irq(rtc->dev, num_irqs, events);\n\trtc_unlock(rtc->dev);\n\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}\n \n\n\n \n \n\n#ifdef CONFIG_PROC_FS\n#define NUM_REGS\t6\t \n#define NUM_BITS\t8\t \n#define NUM_SPACES\t4\t \n\n \nstatic const char *ds1685_rtc_pirq_rate[16] = {\n\t\"none\", \"3.90625ms\", \"7.8125ms\", \"0.122070ms\", \"0.244141ms\",\n\t\"0.488281ms\", \"0.9765625ms\", \"1.953125ms\", \"3.90625ms\", \"7.8125ms\",\n\t\"15.625ms\", \"31.25ms\", \"62.5ms\", \"125ms\", \"250ms\", \"500ms\"\n};\n\n \nstatic const char *ds1685_rtc_sqw_freq[16] = {\n\t\"none\", \"256Hz\", \"128Hz\", \"8192Hz\", \"4096Hz\", \"2048Hz\", \"1024Hz\",\n\t\"512Hz\", \"256Hz\", \"128Hz\", \"64Hz\", \"32Hz\", \"16Hz\", \"8Hz\", \"4Hz\", \"2Hz\"\n};\n\n \nstatic int\nds1685_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev);\n\tu8 ctrla, ctrlb, ctrld, ctrl4a, ctrl4b, ssn[8];\n\tchar *model;\n\n\t \n\tds1685_rtc_switch_to_bank1(rtc);\n\tds1685_rtc_get_ssn(rtc, ssn);\n\tctrla = rtc->read(rtc, RTC_CTRL_A);\n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\tctrld = rtc->read(rtc, RTC_CTRL_D);\n\tctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\n\tctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\n\tds1685_rtc_switch_to_bank0(rtc);\n\n\t \n\tswitch (ssn[0]) {\n\tcase RTC_MODEL_DS1685:\n\t\tmodel = \"DS1685/DS1687\\0\";\n\t\tbreak;\n\tcase RTC_MODEL_DS1689:\n\t\tmodel = \"DS1689/DS1693\\0\";\n\t\tbreak;\n\tcase RTC_MODEL_DS17285:\n\t\tmodel = \"DS17285/DS17287\\0\";\n\t\tbreak;\n\tcase RTC_MODEL_DS17485:\n\t\tmodel = \"DS17485/DS17487\\0\";\n\t\tbreak;\n\tcase RTC_MODEL_DS17885:\n\t\tmodel = \"DS17885/DS17887\\0\";\n\t\tbreak;\n\tdefault:\n\t\tmodel = \"Unknown\\0\";\n\t\tbreak;\n\t}\n\n\t \n\tseq_printf(seq,\n\t   \"Model\\t\\t: %s\\n\"\n\t   \"Oscillator\\t: %s\\n\"\n\t   \"12/24hr\\t\\t: %s\\n\"\n\t   \"DST\\t\\t: %s\\n\"\n\t   \"Data mode\\t: %s\\n\"\n\t   \"Battery\\t\\t: %s\\n\"\n\t   \"Aux batt\\t: %s\\n\"\n\t   \"Update IRQ\\t: %s\\n\"\n\t   \"Periodic IRQ\\t: %s\\n\"\n\t   \"Periodic Rate\\t: %s\\n\"\n\t   \"SQW Freq\\t: %s\\n\"\n\t   \"Serial #\\t: %8phC\\n\",\n\t   model,\n\t   ((ctrla & RTC_CTRL_A_DV1) ? \"enabled\" : \"disabled\"),\n\t   ((ctrlb & RTC_CTRL_B_2412) ? \"24-hour\" : \"12-hour\"),\n\t   ((ctrlb & RTC_CTRL_B_DSE) ? \"enabled\" : \"disabled\"),\n\t   ((ctrlb & RTC_CTRL_B_DM) ? \"binary\" : \"BCD\"),\n\t   ((ctrld & RTC_CTRL_D_VRT) ? \"ok\" : \"exhausted or n/a\"),\n\t   ((ctrl4a & RTC_CTRL_4A_VRT2) ? \"ok\" : \"exhausted or n/a\"),\n\t   ((ctrlb & RTC_CTRL_B_UIE) ? \"yes\" : \"no\"),\n\t   ((ctrlb & RTC_CTRL_B_PIE) ? \"yes\" : \"no\"),\n\t   (!(ctrl4b & RTC_CTRL_4B_E32K) ?\n\t    ds1685_rtc_pirq_rate[(ctrla & RTC_CTRL_A_RS_MASK)] : \"none\"),\n\t   (!((ctrl4b & RTC_CTRL_4B_E32K)) ?\n\t    ds1685_rtc_sqw_freq[(ctrla & RTC_CTRL_A_RS_MASK)] : \"32768Hz\"),\n\t   ssn);\n\treturn 0;\n}\n#else\n#define ds1685_rtc_proc NULL\n#endif  \n \n\n\n \n \n\nstatic const struct rtc_class_ops\nds1685_rtc_ops = {\n\t.proc = ds1685_rtc_proc,\n\t.read_time = ds1685_rtc_read_time,\n\t.set_time = ds1685_rtc_set_time,\n\t.read_alarm = ds1685_rtc_read_alarm,\n\t.set_alarm = ds1685_rtc_set_alarm,\n\t.alarm_irq_enable = ds1685_rtc_alarm_irq_enable,\n};\n \n\nstatic int ds1685_nvram_read(void *priv, unsigned int pos, void *val,\n\t\t\t     size_t size)\n{\n\tstruct ds1685_priv *rtc = priv;\n\tstruct mutex *rtc_mutex = &rtc->dev->ops_lock;\n\tssize_t count;\n\tu8 *buf = val;\n\tint err;\n\n\terr = mutex_lock_interruptible(rtc_mutex);\n\tif (err)\n\t\treturn err;\n\n\tds1685_rtc_switch_to_bank0(rtc);\n\n\t \n\tfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ_BANK0;\n\t     count++, size--) {\n\t\tif (count < NVRAM_SZ_TIME)\n\t\t\t*buf++ = rtc->read(rtc, (NVRAM_TIME_BASE + pos++));\n\t\telse\n\t\t\t*buf++ = rtc->read(rtc, (NVRAM_BANK0_BASE + pos++));\n\t}\n\n#ifndef CONFIG_RTC_DRV_DS1689\n\tif (size > 0) {\n\t\tds1685_rtc_switch_to_bank1(rtc);\n\n#ifndef CONFIG_RTC_DRV_DS1685\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) |\n\t\t\t    RTC_CTRL_4A_BME));\n\n\t\t \n\t\trtc->write(rtc, RTC_BANK1_RAM_ADDR_LSB,\n\t\t\t   (pos - NVRAM_TOTAL_SZ_BANK0));\n#endif\n\n\t\t \n\t\tfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ;\n\t\t     count++, size--) {\n#ifdef CONFIG_RTC_DRV_DS1685\n\t\t\t \n\t\t\trtc->write(rtc, RTC_BANK1_RAM_ADDR,\n\t\t\t\t   (pos - NVRAM_TOTAL_SZ_BANK0));\n#endif\n\t\t\t*buf++ = rtc->read(rtc, RTC_BANK1_RAM_DATA_PORT);\n\t\t\tpos++;\n\t\t}\n\n#ifndef CONFIG_RTC_DRV_DS1685\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) &\n\t\t\t    ~(RTC_CTRL_4A_BME)));\n#endif\n\t\tds1685_rtc_switch_to_bank0(rtc);\n\t}\n#endif  \n\tmutex_unlock(rtc_mutex);\n\n\treturn 0;\n}\n\nstatic int ds1685_nvram_write(void *priv, unsigned int pos, void *val,\n\t\t\t      size_t size)\n{\n\tstruct ds1685_priv *rtc = priv;\n\tstruct mutex *rtc_mutex = &rtc->dev->ops_lock;\n\tssize_t count;\n\tu8 *buf = val;\n\tint err;\n\n\terr = mutex_lock_interruptible(rtc_mutex);\n\tif (err)\n\t\treturn err;\n\n\tds1685_rtc_switch_to_bank0(rtc);\n\n\t \n\tfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ_BANK0;\n\t     count++, size--)\n\t\tif (count < NVRAM_SZ_TIME)\n\t\t\trtc->write(rtc, (NVRAM_TIME_BASE + pos++),\n\t\t\t\t   *buf++);\n\t\telse\n\t\t\trtc->write(rtc, (NVRAM_BANK0_BASE), *buf++);\n\n#ifndef CONFIG_RTC_DRV_DS1689\n\tif (size > 0) {\n\t\tds1685_rtc_switch_to_bank1(rtc);\n\n#ifndef CONFIG_RTC_DRV_DS1685\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) |\n\t\t\t    RTC_CTRL_4A_BME));\n\n\t\t \n\t\trtc->write(rtc, RTC_BANK1_RAM_ADDR_LSB,\n\t\t\t   (pos - NVRAM_TOTAL_SZ_BANK0));\n#endif\n\n\t\t \n\t\tfor (count = 0; size > 0 && pos < NVRAM_TOTAL_SZ;\n\t\t     count++, size--) {\n#ifdef CONFIG_RTC_DRV_DS1685\n\t\t\t \n\t\t\trtc->write(rtc, RTC_BANK1_RAM_ADDR,\n\t\t\t\t   (pos - NVRAM_TOTAL_SZ_BANK0));\n#endif\n\t\t\trtc->write(rtc, RTC_BANK1_RAM_DATA_PORT, *buf++);\n\t\t\tpos++;\n\t\t}\n\n#ifndef CONFIG_RTC_DRV_DS1685\n\t\t \n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) &\n\t\t\t    ~(RTC_CTRL_4A_BME)));\n#endif\n\t\tds1685_rtc_switch_to_bank0(rtc);\n\t}\n#endif  \n\tmutex_unlock(rtc_mutex);\n\n\treturn 0;\n}\n\n \n \n\n \nstatic ssize_t\nds1685_rtc_sysfs_battery_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev->parent);\n\tu8 ctrld;\n\n\tctrld = rtc->read(rtc, RTC_CTRL_D);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\t(ctrld & RTC_CTRL_D_VRT) ? \"ok\" : \"not ok or N/A\");\n}\nstatic DEVICE_ATTR(battery, S_IRUGO, ds1685_rtc_sysfs_battery_show, NULL);\n\n \nstatic ssize_t\nds1685_rtc_sysfs_auxbatt_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev->parent);\n\tu8 ctrl4a;\n\n\tds1685_rtc_switch_to_bank1(rtc);\n\tctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\n\tds1685_rtc_switch_to_bank0(rtc);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\t(ctrl4a & RTC_CTRL_4A_VRT2) ? \"ok\" : \"not ok or N/A\");\n}\nstatic DEVICE_ATTR(auxbatt, S_IRUGO, ds1685_rtc_sysfs_auxbatt_show, NULL);\n\n \nstatic ssize_t\nds1685_rtc_sysfs_serial_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ds1685_priv *rtc = dev_get_drvdata(dev->parent);\n\tu8 ssn[8];\n\n\tds1685_rtc_switch_to_bank1(rtc);\n\tds1685_rtc_get_ssn(rtc, ssn);\n\tds1685_rtc_switch_to_bank0(rtc);\n\n\treturn sprintf(buf, \"%8phC\\n\", ssn);\n}\nstatic DEVICE_ATTR(serial, S_IRUGO, ds1685_rtc_sysfs_serial_show, NULL);\n\n \nstatic struct attribute*\nds1685_rtc_sysfs_misc_attrs[] = {\n\t&dev_attr_battery.attr,\n\t&dev_attr_auxbatt.attr,\n\t&dev_attr_serial.attr,\n\tNULL,\n};\n\n \nstatic const struct attribute_group\nds1685_rtc_sysfs_misc_grp = {\n\t.name = \"misc\",\n\t.attrs = ds1685_rtc_sysfs_misc_attrs,\n};\n\n \n \n\n \nstatic int\nds1685_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc_dev;\n\tstruct ds1685_priv *rtc;\n\tstruct ds1685_rtc_platform_data *pdata;\n\tu8 ctrla, ctrlb, hours;\n\tunsigned char am_pm;\n\tint ret = 0;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"ds1685_nvram\",\n\t\t.size = NVRAM_TOTAL_SZ,\n\t\t.reg_read = ds1685_nvram_read,\n\t\t.reg_write = ds1685_nvram_write,\n\t};\n\n\t \n\tpdata = (struct ds1685_rtc_platform_data *) pdev->dev.platform_data;\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\t \n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (pdata->access_type) {\n\tcase ds1685_reg_direct:\n\t\trtc->regs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(rtc->regs))\n\t\t\treturn PTR_ERR(rtc->regs);\n\t\trtc->read = ds1685_read;\n\t\trtc->write = ds1685_write;\n\t\tbreak;\n\tcase ds1685_reg_indirect:\n\t\trtc->regs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(rtc->regs))\n\t\t\treturn PTR_ERR(rtc->regs);\n\t\trtc->data = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(rtc->data))\n\t\t\treturn PTR_ERR(rtc->data);\n\t\trtc->read = ds1685_indirect_read;\n\t\trtc->write = ds1685_indirect_write;\n\t\tbreak;\n\t}\n\n\tif (!rtc->read || !rtc->write)\n\t\treturn -ENXIO;\n\n\t \n\tif (pdata->regstep > 0)\n\t\trtc->regstep = pdata->regstep;\n\telse\n\t\trtc->regstep = 1;\n\n\t \n\tif (pdata->plat_prepare_poweroff)\n\t\trtc->prepare_poweroff = pdata->plat_prepare_poweroff;\n\n\t \n\tif (pdata->plat_wake_alarm)\n\t\trtc->wake_alarm = pdata->plat_wake_alarm;\n\n\t \n\tif (pdata->plat_post_ram_clear)\n\t\trtc->post_ram_clear = pdata->plat_post_ram_clear;\n\n\t \n\tplatform_set_drvdata(pdev, rtc);\n\n\t \n\tctrla = rtc->read(rtc, RTC_CTRL_A);\n\tif (!(ctrla & RTC_CTRL_A_DV1))\n\t\tctrla |= RTC_CTRL_A_DV1;\n\n\t \n\tctrla &= ~(RTC_CTRL_A_DV2);\n\n\t \n\tctrla &= ~(RTC_CTRL_A_RS_MASK);\n\n\t \n\tctrla |= RTC_CTRL_A_DV0;\n\trtc->write(rtc, RTC_CTRL_A, ctrla);\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) | RTC_CTRL_4B_E32K));\n\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) | RTC_CTRL_B_SET));\n\n\t \n\twhile (rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_INCR)\n\t\tcpu_relax();\n\n\t \n\tctrlb = rtc->read(rtc, RTC_CTRL_B);\n\tif (pdata->bcd_mode)\n\t\tctrlb &= ~(RTC_CTRL_B_DM);\n\telse\n\t\tctrlb |= RTC_CTRL_B_DM;\n\trtc->bcd_mode = pdata->bcd_mode;\n\n\t \n\tif (ctrlb & RTC_CTRL_B_DSE)\n\t\tctrlb &= ~(RTC_CTRL_B_DSE);\n\n\t \n\tif (!(ctrlb & RTC_CTRL_B_2412)) {\n\t\t \n\t\thours = rtc->read(rtc, RTC_HRS);\n\t\tam_pm = hours & RTC_HRS_AMPM_MASK;\n\t\thours = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_12_BCD_MASK,\n\t\t\t\t\t   RTC_HRS_12_BIN_MASK);\n\t\thours = ((hours == 12) ? 0 : ((am_pm) ? hours + 12 : hours));\n\n\t\t \n\t\tctrlb |= RTC_CTRL_B_2412;\n\n\t\t \n\t\trtc->write(rtc, RTC_CTRL_B, ctrlb);\n\n\t\t \n\t\trtc->write(rtc, RTC_HRS,\n\t\t\t   ds1685_rtc_bin2bcd(rtc, hours,\n\t\t\t\t\t      RTC_HRS_24_BIN_MASK,\n\t\t\t\t\t      RTC_HRS_24_BCD_MASK));\n\n\t\t \n\t\thours = rtc->read(rtc, RTC_HRS_ALARM);\n\t\tam_pm = hours & RTC_HRS_AMPM_MASK;\n\t\thours = ds1685_rtc_bcd2bin(rtc, hours, RTC_HRS_12_BCD_MASK,\n\t\t\t\t\t   RTC_HRS_12_BIN_MASK);\n\t\thours = ((hours == 12) ? 0 : ((am_pm) ? hours + 12 : hours));\n\n\t\t \n\t\trtc->write(rtc, RTC_HRS_ALARM,\n\t\t\t   ds1685_rtc_bin2bcd(rtc, hours,\n\t\t\t\t\t      RTC_HRS_24_BIN_MASK,\n\t\t\t\t\t      RTC_HRS_24_BCD_MASK));\n\t} else {\n\t\t \n\t\trtc->write(rtc, RTC_CTRL_B, ctrlb);\n\t}\n\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_SET)));\n\n\t \n\tif (!(rtc->read(rtc, RTC_CTRL_D) & RTC_CTRL_D_VRT))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Main battery is exhausted! RTC may be invalid!\\n\");\n\n\t \n\tif (!(rtc->read(rtc, RTC_EXT_CTRL_4A) & RTC_CTRL_4A_VRT2))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Aux battery is exhausted or not available.\\n\");\n\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) & ~(RTC_CTRL_B_PAU_MASK)));\n\n\t \n\trtc->read(rtc, RTC_CTRL_C);\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) & ~(RTC_CTRL_4B_RWK_MASK)));\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) & ~(RTC_CTRL_4A_RWK_MASK)));\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) | RTC_CTRL_4B_KSE));\n\n\trtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc_dev))\n\t\treturn PTR_ERR(rtc_dev);\n\n\trtc_dev->ops = &ds1685_rtc_ops;\n\n\t \n\trtc_dev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc_dev->range_max = RTC_TIMESTAMP_END_2099;\n\n\t \n\trtc_dev->max_user_freq = RTC_MAX_USER_FREQ;\n\n\t \n\tif (pdata->uie_unsupported)\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc_dev->features);\n\n\trtc->dev = rtc_dev;\n\n\t \n\trtc->irq_num = platform_get_irq(pdev, 0);\n\tif (rtc->irq_num <= 0) {\n\t\tclear_bit(RTC_FEATURE_ALARM, rtc_dev->features);\n\t} else {\n\t\t \n\t\tret = devm_request_threaded_irq(&pdev->dev, rtc->irq_num,\n\t\t\t\t       NULL, ds1685_rtc_irq_handler,\n\t\t\t\t       IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t       pdev->name, pdev);\n\n\t\t \n\t\tif (unlikely(ret)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"RTC interrupt not available\\n\");\n\t\t\trtc->irq_num = 0;\n\t\t}\n\t}\n\n\t \n\tds1685_rtc_switch_to_bank0(rtc);\n\n\tret = rtc_add_group(rtc_dev, &ds1685_rtc_sysfs_misc_grp);\n\tif (ret)\n\t\treturn ret;\n\n\tnvmem_cfg.priv = rtc;\n\tret = devm_rtc_nvmem_register(rtc_dev, &nvmem_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_register_device(rtc_dev);\n}\n\n \nstatic void\nds1685_rtc_remove(struct platform_device *pdev)\n{\n\tstruct ds1685_priv *rtc = platform_get_drvdata(pdev);\n\n\t \n\trtc->write(rtc, RTC_CTRL_B,\n\t\t   (rtc->read(rtc, RTC_CTRL_B) &\n\t\t    ~(RTC_CTRL_B_PAU_MASK)));\n\n\t \n\trtc->read(rtc, RTC_CTRL_C);\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4B,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4B) &\n\t\t    ~(RTC_CTRL_4B_RWK_MASK)));\n\n\t \n\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t   (rtc->read(rtc, RTC_EXT_CTRL_4A) &\n\t\t    ~(RTC_CTRL_4A_RWK_MASK)));\n}\n\n \nstatic struct platform_driver ds1685_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-ds1685\",\n\t},\n\t.probe\t\t= ds1685_rtc_probe,\n\t.remove_new\t= ds1685_rtc_remove,\n};\nmodule_platform_driver(ds1685_rtc_driver);\n \n\n\n \n \n\n \nvoid __noreturn\nds1685_rtc_poweroff(struct platform_device *pdev)\n{\n\tu8 ctrla, ctrl4a, ctrl4b;\n\tstruct ds1685_priv *rtc;\n\n\t \n\tif (unlikely(!pdev)) {\n\t\tpr_emerg(\"platform device data not available, spinning forever ...\\n\");\n\t\twhile(1);\n\t\tunreachable();\n\t} else {\n\t\t \n\t\trtc = platform_get_drvdata(pdev);\n\n\t\t \n\t\tif (rtc->irq_num)\n\t\t\tdisable_irq_nosync(rtc->irq_num);\n\n\t\t \n\t\tctrla = rtc->read(rtc, RTC_CTRL_A);\n\t\tctrla |= RTC_CTRL_A_DV1;\n\t\tctrla &= ~(RTC_CTRL_A_DV2);\n\t\trtc->write(rtc, RTC_CTRL_A, ctrla);\n\n\t\t \n\t\tds1685_rtc_switch_to_bank1(rtc);\n\t\tctrl4a = rtc->read(rtc, RTC_EXT_CTRL_4A);\n\t\tif (ctrl4a & RTC_CTRL_4A_VRT2) {\n\t\t\t \n\t\t\tctrl4a &= ~(RTC_CTRL_4A_RWK_MASK);\n\t\t\trtc->write(rtc, RTC_EXT_CTRL_4A, ctrl4a);\n\n\t\t\t \n\t\t\tctrl4b = rtc->read(rtc, RTC_EXT_CTRL_4B);\n\t\t\tctrl4b |= (RTC_CTRL_4B_ABE | RTC_CTRL_4B_WIE |\n\t\t\t\t   RTC_CTRL_4B_KSE);\n\t\t\trtc->write(rtc, RTC_EXT_CTRL_4B, ctrl4b);\n\t\t}\n\n\t\t \n\t\tdev_warn(&pdev->dev, \"Powerdown.\\n\");\n\t\tmsleep(20);\n\t\trtc->write(rtc, RTC_EXT_CTRL_4A,\n\t\t\t   (ctrl4a | RTC_CTRL_4A_PAB));\n\n\t\t \n\t\twhile(1);\n\t\tunreachable();\n\t}\n}\nEXPORT_SYMBOL_GPL(ds1685_rtc_poweroff);\n \n\n\nMODULE_AUTHOR(\"Joshua Kinard <kumba@gentoo.org>\");\nMODULE_AUTHOR(\"Matthias Fuchs <matthias.fuchs@esd-electronics.com>\");\nMODULE_DESCRIPTION(\"Dallas/Maxim DS1685/DS1687-series RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-ds1685\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}