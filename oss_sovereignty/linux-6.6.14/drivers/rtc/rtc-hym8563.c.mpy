{
  "module_name": "rtc-hym8563.c",
  "hash_id": "345e79cff3da031e9c280bb9d9ee5dcac625bc8daf4c2ba74112a363dbb165b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-hym8563.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n\n#define HYM8563_CTL1\t\t0x00\n#define HYM8563_CTL1_TEST\tBIT(7)\n#define HYM8563_CTL1_STOP\tBIT(5)\n#define HYM8563_CTL1_TESTC\tBIT(3)\n\n#define HYM8563_CTL2\t\t0x01\n#define HYM8563_CTL2_TI_TP\tBIT(4)\n#define HYM8563_CTL2_AF\t\tBIT(3)\n#define HYM8563_CTL2_TF\t\tBIT(2)\n#define HYM8563_CTL2_AIE\tBIT(1)\n#define HYM8563_CTL2_TIE\tBIT(0)\n\n#define HYM8563_SEC\t\t0x02\n#define HYM8563_SEC_VL\t\tBIT(7)\n#define HYM8563_SEC_MASK\t0x7f\n\n#define HYM8563_MIN\t\t0x03\n#define HYM8563_MIN_MASK\t0x7f\n\n#define HYM8563_HOUR\t\t0x04\n#define HYM8563_HOUR_MASK\t0x3f\n\n#define HYM8563_DAY\t\t0x05\n#define HYM8563_DAY_MASK\t0x3f\n\n#define HYM8563_WEEKDAY\t\t0x06\n#define HYM8563_WEEKDAY_MASK\t0x07\n\n#define HYM8563_MONTH\t\t0x07\n#define HYM8563_MONTH_CENTURY\tBIT(7)\n#define HYM8563_MONTH_MASK\t0x1f\n\n#define HYM8563_YEAR\t\t0x08\n\n#define HYM8563_ALM_MIN\t\t0x09\n#define HYM8563_ALM_HOUR\t0x0a\n#define HYM8563_ALM_DAY\t\t0x0b\n#define HYM8563_ALM_WEEK\t0x0c\n\n \n#define HYM8563_ALM_BIT_DISABLE\tBIT(7)\n\n#define HYM8563_CLKOUT\t\t0x0d\n#define HYM8563_CLKOUT_ENABLE\tBIT(7)\n#define HYM8563_CLKOUT_32768\t0\n#define HYM8563_CLKOUT_1024\t1\n#define HYM8563_CLKOUT_32\t2\n#define HYM8563_CLKOUT_1\t3\n#define HYM8563_CLKOUT_MASK\t3\n\n#define HYM8563_TMR_CTL\t\t0x0e\n#define HYM8563_TMR_CTL_ENABLE\tBIT(7)\n#define HYM8563_TMR_CTL_4096\t0\n#define HYM8563_TMR_CTL_64\t1\n#define HYM8563_TMR_CTL_1\t2\n#define HYM8563_TMR_CTL_1_60\t3\n#define HYM8563_TMR_CTL_MASK\t3\n\n#define HYM8563_TMR_CNT\t\t0x0f\n\nstruct hym8563 {\n\tstruct i2c_client\t*client;\n\tstruct rtc_device\t*rtc;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw\t\tclkout_hw;\n#endif\n};\n\n \n\nstatic int hym8563_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 buf[7];\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, HYM8563_SEC, 7, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buf[0] & HYM8563_SEC_VL) {\n\t\tdev_warn(&client->dev,\n\t\t\t \"no valid clock/calendar values available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttm->tm_sec = bcd2bin(buf[0] & HYM8563_SEC_MASK);\n\ttm->tm_min = bcd2bin(buf[1] & HYM8563_MIN_MASK);\n\ttm->tm_hour = bcd2bin(buf[2] & HYM8563_HOUR_MASK);\n\ttm->tm_mday = bcd2bin(buf[3] & HYM8563_DAY_MASK);\n\ttm->tm_wday = bcd2bin(buf[4] & HYM8563_WEEKDAY_MASK);  \n\ttm->tm_mon = bcd2bin(buf[5] & HYM8563_MONTH_MASK) - 1;  \n\ttm->tm_year = bcd2bin(buf[6]) + 100;\n\n\treturn 0;\n}\n\nstatic int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 buf[7];\n\tint ret;\n\n\t \n\tif (tm->tm_year < 100 || tm->tm_year >= 200)\n\t\treturn -EINVAL;\n\n\tbuf[0] = bin2bcd(tm->tm_sec);\n\tbuf[1] = bin2bcd(tm->tm_min);\n\tbuf[2] = bin2bcd(tm->tm_hour);\n\tbuf[3] = bin2bcd(tm->tm_mday);\n\tbuf[4] = bin2bcd(tm->tm_wday);\n\tbuf[5] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[6] = bin2bcd(tm->tm_year - 100);\n\n\t \n\tret = i2c_smbus_write_byte_data(client, HYM8563_CTL1,\n\t\t\t\t\t\tHYM8563_CTL1_STOP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_i2c_block_data(client, HYM8563_SEC, 7, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, HYM8563_CTL1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hym8563_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint data;\n\n\tdata = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\n\tif (data < 0)\n\t\treturn data;\n\n\tif (enabled)\n\t\tdata |= HYM8563_CTL2_AIE;\n\telse\n\t\tdata &= ~HYM8563_CTL2_AIE;\n\n\treturn i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);\n};\n\nstatic int hym8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rtc_time *alm_tm = &alm->time;\n\tu8 buf[4];\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\talm_tm->tm_sec = 0;\n\n\talm_tm->tm_min = (buf[0] & HYM8563_ALM_BIT_DISABLE) ?\n\t\t\t\t\t-1 :\n\t\t\t\t\tbcd2bin(buf[0] & HYM8563_MIN_MASK);\n\talm_tm->tm_hour = (buf[1] & HYM8563_ALM_BIT_DISABLE) ?\n\t\t\t\t\t-1 :\n\t\t\t\t\tbcd2bin(buf[1] & HYM8563_HOUR_MASK);\n\talm_tm->tm_mday = (buf[2] & HYM8563_ALM_BIT_DISABLE) ?\n\t\t\t\t\t-1 :\n\t\t\t\t\tbcd2bin(buf[2] & HYM8563_DAY_MASK);\n\talm_tm->tm_wday = (buf[3] & HYM8563_ALM_BIT_DISABLE) ?\n\t\t\t\t\t-1 :\n\t\t\t\t\tbcd2bin(buf[3] & HYM8563_WEEKDAY_MASK);\n\n\tret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & HYM8563_CTL2_AIE)\n\t\talm->enabled = 1;\n\n\treturn 0;\n}\n\nstatic int hym8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rtc_time *alm_tm = &alm->time;\n\tu8 buf[4];\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~HYM8563_CTL2_AIE;\n\n\tret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf[0] = (alm_tm->tm_min < 60 && alm_tm->tm_min >= 0) ?\n\t\t\tbin2bcd(alm_tm->tm_min) : HYM8563_ALM_BIT_DISABLE;\n\n\tbuf[1] = (alm_tm->tm_hour < 24 && alm_tm->tm_hour >= 0) ?\n\t\t\tbin2bcd(alm_tm->tm_hour) : HYM8563_ALM_BIT_DISABLE;\n\n\tbuf[2] = (alm_tm->tm_mday <= 31 && alm_tm->tm_mday >= 1) ?\n\t\t\tbin2bcd(alm_tm->tm_mday) : HYM8563_ALM_BIT_DISABLE;\n\n\tbuf[3] = (alm_tm->tm_wday < 7 && alm_tm->tm_wday >= 0) ?\n\t\t\tbin2bcd(alm_tm->tm_wday) : HYM8563_ALM_BIT_DISABLE;\n\n\tret = i2c_smbus_write_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn hym8563_rtc_alarm_irq_enable(dev, alm->enabled);\n}\n\nstatic const struct rtc_class_ops hym8563_rtc_ops = {\n\t.read_time\t\t= hym8563_rtc_read_time,\n\t.set_time\t\t= hym8563_rtc_set_time,\n\t.alarm_irq_enable\t= hym8563_rtc_alarm_irq_enable,\n\t.read_alarm\t\t= hym8563_rtc_read_alarm,\n\t.set_alarm\t\t= hym8563_rtc_set_alarm,\n};\n\n \n\n#ifdef CONFIG_COMMON_CLK\n#define clkout_hw_to_hym8563(_hw) container_of(_hw, struct hym8563, clkout_hw)\n\nstatic int clkout_rates[] = {\n\t32768,\n\t1024,\n\t32,\n\t1,\n};\n\nstatic unsigned long hym8563_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\n\tstruct i2c_client *client = hym8563->client;\n\tint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret &= HYM8563_CLKOUT_MASK;\n\treturn clkout_rates[ret];\n}\n\nstatic long hym8563_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] <= rate)\n\t\t\treturn clkout_rates[i];\n\n\treturn 0;\n}\n\nstatic int hym8563_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\n\tstruct i2c_client *client = hym8563->client;\n\tint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\n\tint i;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] == rate) {\n\t\t\tret &= ~HYM8563_CLKOUT_MASK;\n\t\t\tret |= i;\n\t\t\treturn i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t\t HYM8563_CLKOUT, ret);\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hym8563_clkout_control(struct clk_hw *hw, bool enable)\n{\n\tstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\n\tstruct i2c_client *client = hym8563->client;\n\tint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable)\n\t\tret |= HYM8563_CLKOUT_ENABLE;\n\telse\n\t\tret &= ~HYM8563_CLKOUT_ENABLE;\n\n\treturn i2c_smbus_write_byte_data(client, HYM8563_CLKOUT, ret);\n}\n\nstatic int hym8563_clkout_prepare(struct clk_hw *hw)\n{\n\treturn hym8563_clkout_control(hw, 1);\n}\n\nstatic void hym8563_clkout_unprepare(struct clk_hw *hw)\n{\n\thym8563_clkout_control(hw, 0);\n}\n\nstatic int hym8563_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\n\tstruct i2c_client *client = hym8563->client;\n\tint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & HYM8563_CLKOUT_ENABLE);\n}\n\nstatic const struct clk_ops hym8563_clkout_ops = {\n\t.prepare = hym8563_clkout_prepare,\n\t.unprepare = hym8563_clkout_unprepare,\n\t.is_prepared = hym8563_clkout_is_prepared,\n\t.recalc_rate = hym8563_clkout_recalc_rate,\n\t.round_rate = hym8563_clkout_round_rate,\n\t.set_rate = hym8563_clkout_set_rate,\n};\n\nstatic struct clk *hym8563_clkout_register_clk(struct hym8563 *hym8563)\n{\n\tstruct i2c_client *client = hym8563->client;\n\tstruct device_node *node = client->dev.of_node;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, HYM8563_CLKOUT,\n\t\t\t\t\t\t0);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tinit.name = \"hym8563-clkout\";\n\tinit.ops = &hym8563_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\thym8563->clkout_hw.init = &init;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = clk_register(&client->dev, &hym8563->clkout_hw);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#endif\n\n \nstatic irqreturn_t hym8563_irq(int irq, void *dev_id)\n{\n\tstruct hym8563 *hym8563 = (struct hym8563 *)dev_id;\n\tstruct i2c_client *client = hym8563->client;\n\tint data, ret;\n\n\trtc_lock(hym8563->rtc);\n\n\t \n\n\tdata = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\n\tif (data < 0) {\n\t\tdev_err(&client->dev, \"%s: error reading i2c data %d\\n\",\n\t\t\t__func__, data);\n\t\tgoto out;\n\t}\n\n\tdata &= ~HYM8563_CTL2_AF;\n\n\tret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: error writing i2c data %d\\n\",\n\t\t\t__func__, ret);\n\t}\n\nout:\n\trtc_unlock(hym8563->rtc);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hym8563_init_device(struct i2c_client *client)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, HYM8563_CTL1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret &= ~HYM8563_CTL2_AIE;\n\tret &= ~HYM8563_CTL2_TIE;\n\n\t \n\tif (ret & HYM8563_CTL2_AF)\n\t\tret &= ~HYM8563_CTL2_AF;\n\n\tif (ret & HYM8563_CTL2_TF)\n\t\tret &= ~HYM8563_CTL2_TF;\n\n\tret &= ~HYM8563_CTL2_TI_TP;\n\n\treturn i2c_smbus_write_byte_data(client, HYM8563_CTL2, ret);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hym8563_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tif (device_may_wakeup(dev)) {\n\t\tret = enable_irq_wake(client->irq);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"enable_irq_wake failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hym8563_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(client->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(hym8563_pm_ops, hym8563_suspend, hym8563_resume);\n\nstatic int hym8563_probe(struct i2c_client *client)\n{\n\tstruct hym8563 *hym8563;\n\tint ret;\n\n\thym8563 = devm_kzalloc(&client->dev, sizeof(*hym8563), GFP_KERNEL);\n\tif (!hym8563)\n\t\treturn -ENOMEM;\n\n\thym8563->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(hym8563->rtc))\n\t\treturn PTR_ERR(hym8563->rtc);\n\n\thym8563->client = client;\n\ti2c_set_clientdata(client, hym8563);\n\n\tret = hym8563_init_device(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"could not init device, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, hym8563_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, hym8563);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"irq %d request failed, %d\\n\",\n\t\t\t\tclient->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (client->irq > 0 ||\n\t    device_property_read_bool(&client->dev, \"wakeup-source\")) {\n\t\tdevice_init_wakeup(&client->dev, true);\n\t}\n\n\t \n\tret = i2c_smbus_read_byte_data(client, HYM8563_SEC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&client->dev, \"rtc information is %s\\n\",\n\t\t(ret & HYM8563_SEC_VL) ? \"invalid\" : \"valid\");\n\n\thym8563->rtc->ops = &hym8563_rtc_ops;\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, hym8563->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, hym8563->rtc->features);\n\n#ifdef CONFIG_COMMON_CLK\n\thym8563_clkout_register_clk(hym8563);\n#endif\n\n\treturn devm_rtc_register_device(hym8563->rtc);\n}\n\nstatic const struct i2c_device_id hym8563_id[] = {\n\t{ \"hym8563\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, hym8563_id);\n\nstatic const struct of_device_id hym8563_dt_idtable[] = {\n\t{ .compatible = \"haoyu,hym8563\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hym8563_dt_idtable);\n\nstatic struct i2c_driver hym8563_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-hym8563\",\n\t\t.pm\t= &hym8563_pm_ops,\n\t\t.of_match_table\t= hym8563_dt_idtable,\n\t},\n\t.probe\t\t= hym8563_probe,\n\t.id_table\t= hym8563_id,\n};\n\nmodule_i2c_driver(hym8563_driver);\n\nMODULE_AUTHOR(\"Heiko Stuebner <heiko@sntech.de>\");\nMODULE_DESCRIPTION(\"HYM8563 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}