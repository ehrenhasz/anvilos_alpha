{
  "module_name": "rtc-au1xxx.c",
  "hash_id": "1c58a6444ec3e5850f8ca6523e7e12b88ffecbbe10ec16d881956a61f3a04cdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-au1xxx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <asm/mach-au1x00/au1000.h>\n\n \n#define CNTR_OK (SYS_CNTRL_E0 | SYS_CNTRL_32S)\n\nstatic int au1xtoy_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long t;\n\n\tt = alchemy_rdsys(AU1000_SYS_TOYREAD);\n\n\trtc_time64_to_tm(t, tm);\n\n\treturn 0;\n}\n\nstatic int au1xtoy_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long t;\n\n\tt = rtc_tm_to_time64(tm);\n\n\talchemy_wrsys(t, AU1000_SYS_TOYWRITE);\n\n\t \n\twhile (alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_C0S)\n\t\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops au1xtoy_rtc_ops = {\n\t.read_time\t= au1xtoy_rtc_read_time,\n\t.set_time\t= au1xtoy_rtc_set_time,\n};\n\nstatic int au1xtoy_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtcdev;\n\tunsigned long t;\n\n\tt = alchemy_rdsys(AU1000_SYS_CNTRCTRL);\n\tif (!(t & CNTR_OK)) {\n\t\tdev_err(&pdev->dev, \"counters not working; aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (alchemy_rdsys(AU1000_SYS_TOYTRIM) != 32767) {\n\t\t \n\t\tt = 0x00100000;\n\t\twhile ((alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_T0S) && --t)\n\t\t\tmsleep(1);\n\n\t\tif (!t) {\n\t\t\t \n\t\t\tdev_err(&pdev->dev, \"timeout waiting for access\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\talchemy_wrsys(32767, AU1000_SYS_TOYTRIM);\n\t}\n\n\t \n\twhile (alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_C0S)\n\t\tmsleep(1);\n\n\trtcdev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtcdev))\n\t\treturn PTR_ERR(rtcdev);\n\n\trtcdev->ops = &au1xtoy_rtc_ops;\n\trtcdev->range_max = U32_MAX;\n\n\tplatform_set_drvdata(pdev, rtcdev);\n\n\treturn devm_rtc_register_device(rtcdev);\n}\n\nstatic struct platform_driver au1xrtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-au1xxx\",\n\t},\n};\n\nmodule_platform_driver_probe(au1xrtc_driver, au1xtoy_rtc_probe);\n\nMODULE_DESCRIPTION(\"Au1xxx TOY-counter-based RTC driver\");\nMODULE_AUTHOR(\"Manuel Lauss <manuel.lauss@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-au1xxx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}