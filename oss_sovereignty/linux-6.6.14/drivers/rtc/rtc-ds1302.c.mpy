{
  "module_name": "rtc-ds1302.c",
  "hash_id": "8e93abdb5eae006c746591100e97b1e98e8e14d68f643a21e7e742384c964ccf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1302.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/spi/spi.h>\n\n#define\tRTC_CMD_READ\t0x81\t\t \n#define\tRTC_CMD_WRITE\t0x80\t\t \n\n#define\tRTC_CMD_WRITE_ENABLE\t0x00\t\t \n#define\tRTC_CMD_WRITE_DISABLE\t0x80\t\t \n\n#define RTC_ADDR_RAM0\t0x20\t\t \n#define RTC_ADDR_TCR\t0x08\t\t \n#define RTC_CLCK_BURST\t0x1F\t\t \n#define\tRTC_CLCK_LEN\t0x08\t\t \n#define\tRTC_ADDR_CTRL\t0x07\t\t \n#define\tRTC_ADDR_YEAR\t0x06\t\t \n#define\tRTC_ADDR_DAY\t0x05\t\t \n#define\tRTC_ADDR_MON\t0x04\t\t \n#define\tRTC_ADDR_DATE\t0x03\t\t \n#define\tRTC_ADDR_HOUR\t0x02\t\t \n#define\tRTC_ADDR_MIN\t0x01\t\t \n#define\tRTC_ADDR_SEC\t0x00\t\t \n\nstatic int ds1302_rtc_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct spi_device\t*spi = dev_get_drvdata(dev);\n\tu8\t\tbuf[1 + RTC_CLCK_LEN];\n\tu8\t\t*bp;\n\tint\t\tstatus;\n\n\t \n\tbp = buf;\n\t*bp++ = RTC_ADDR_CTRL << 1 | RTC_CMD_WRITE;\n\t*bp++ = RTC_CMD_WRITE_ENABLE;\n\n\tstatus = spi_write_then_read(spi, buf, 2,\n\t\t\tNULL, 0);\n\tif (status)\n\t\treturn status;\n\n\t \n\tbp = buf;\n\t*bp++ = RTC_CLCK_BURST << 1 | RTC_CMD_WRITE;\n\n\t*bp++ = bin2bcd(time->tm_sec);\n\t*bp++ = bin2bcd(time->tm_min);\n\t*bp++ = bin2bcd(time->tm_hour);\n\t*bp++ = bin2bcd(time->tm_mday);\n\t*bp++ = bin2bcd(time->tm_mon + 1);\n\t*bp++ = time->tm_wday + 1;\n\t*bp++ = bin2bcd(time->tm_year % 100);\n\t*bp++ = RTC_CMD_WRITE_DISABLE;\n\n\t \n\treturn spi_write_then_read(spi, buf, sizeof(buf),\n\t\t\tNULL, 0);\n}\n\nstatic int ds1302_rtc_get_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct spi_device\t*spi = dev_get_drvdata(dev);\n\tu8\t\taddr = RTC_CLCK_BURST << 1 | RTC_CMD_READ;\n\tu8\t\tbuf[RTC_CLCK_LEN - 1];\n\tint\t\tstatus;\n\n\t \n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tbuf, sizeof(buf));\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\ttime->tm_sec = bcd2bin(buf[RTC_ADDR_SEC]);\n\ttime->tm_min = bcd2bin(buf[RTC_ADDR_MIN]);\n\ttime->tm_hour = bcd2bin(buf[RTC_ADDR_HOUR]);\n\ttime->tm_wday = buf[RTC_ADDR_DAY] - 1;\n\ttime->tm_mday = bcd2bin(buf[RTC_ADDR_DATE]);\n\ttime->tm_mon = bcd2bin(buf[RTC_ADDR_MON]) - 1;\n\ttime->tm_year = bcd2bin(buf[RTC_ADDR_YEAR]) + 100;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1302_rtc_ops = {\n\t.read_time\t= ds1302_rtc_get_time,\n\t.set_time\t= ds1302_rtc_set_time,\n};\n\nstatic int ds1302_probe(struct spi_device *spi)\n{\n\tstruct rtc_device\t*rtc;\n\tu8\t\taddr;\n\tu8\t\tbuf[4];\n\tu8\t\t*bp;\n\tint\t\tstatus;\n\n\t \n\tif (spi->bits_per_word && (spi->bits_per_word != 8)) {\n\t\tdev_err(&spi->dev, \"bad word length\\n\");\n\t\treturn -EINVAL;\n\t} else if (spi->max_speed_hz > 2000000) {\n\t\tdev_err(&spi->dev, \"speed is too high\\n\");\n\t\treturn -EINVAL;\n\t} else if (spi->mode & SPI_CPHA) {\n\t\tdev_err(&spi->dev, \"bad mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = RTC_ADDR_CTRL << 1 | RTC_CMD_READ;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr), buf, 1);\n\tif (status < 0) {\n\t\tdev_err(&spi->dev, \"control register read error %d\\n\",\n\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tif ((buf[0] & ~RTC_CMD_WRITE_DISABLE) != 0) {\n\t\tstatus = spi_write_then_read(spi, &addr, sizeof(addr), buf, 1);\n\t\tif (status < 0) {\n\t\t\tdev_err(&spi->dev, \"control register read error %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\tif ((buf[0] & ~RTC_CMD_WRITE_DISABLE) != 0) {\n\t\t\tdev_err(&spi->dev, \"junk in control register\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (buf[0] == 0) {\n\t\tbp = buf;\n\t\t*bp++ = RTC_ADDR_CTRL << 1 | RTC_CMD_WRITE;\n\t\t*bp++ = RTC_CMD_WRITE_DISABLE;\n\n\t\tstatus = spi_write_then_read(spi, buf, 2, NULL, 0);\n\t\tif (status < 0) {\n\t\t\tdev_err(&spi->dev, \"control register write error %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\taddr = RTC_ADDR_CTRL << 1 | RTC_CMD_READ;\n\t\tstatus = spi_write_then_read(spi, &addr, sizeof(addr), buf, 1);\n\t\tif (status < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"error %d reading control register\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (buf[0] != RTC_CMD_WRITE_DISABLE) {\n\t\t\tdev_err(&spi->dev, \"failed to detect chip\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tspi_set_drvdata(spi, spi);\n\n\trtc = devm_rtc_device_register(&spi->dev, \"ds1302\",\n\t\t\t&ds1302_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc)) {\n\t\tstatus = PTR_ERR(rtc);\n\t\tdev_err(&spi->dev, \"error %d registering rtc\\n\", status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ds1302_dt_ids[] = {\n\t{ .compatible = \"maxim,ds1302\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ds1302_dt_ids);\n#endif\n\nstatic const struct spi_device_id ds1302_spi_ids[] = {\n\t{ .name = \"ds1302\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, ds1302_spi_ids);\n\nstatic struct spi_driver ds1302_driver = {\n\t.driver.name\t= \"rtc-ds1302\",\n\t.driver.of_match_table = of_match_ptr(ds1302_dt_ids),\n\t.probe\t\t= ds1302_probe,\n\t.id_table\t= ds1302_spi_ids,\n};\n\nmodule_spi_driver(ds1302_driver);\n\nMODULE_DESCRIPTION(\"Dallas DS1302 RTC driver\");\nMODULE_AUTHOR(\"Paul Mundt, David McCullough\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}