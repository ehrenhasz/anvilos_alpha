{
  "module_name": "rtc-ds1216.c",
  "hash_id": "e42c9de85ebdca022782a4238fa9ff719e6e839314695e8c9f3e114e3c0d8031",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1216.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n\nstruct ds1216_regs {\n\tu8 tsec;\n\tu8 sec;\n\tu8 min;\n\tu8 hour;\n\tu8 wday;\n\tu8 mday;\n\tu8 month;\n\tu8 year;\n};\n\n#define DS1216_HOUR_1224\t(1 << 7)\n#define DS1216_HOUR_AMPM\t(1 << 5)\n\nstruct ds1216_priv {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n};\n\nstatic const u8 magic[] = {\n\t0xc5, 0x3a, 0xa3, 0x5c, 0xc5, 0x3a, 0xa3, 0x5c\n};\n\n \nstatic void ds1216_read(u8 __iomem *ioaddr, u8 *buf)\n{\n\tunsigned char c;\n\tint i, j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tc = 0;\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tc |= (readb(ioaddr) & 0x1) << j;\n\t\tbuf[i] = c;\n\t}\n}\n\nstatic void ds1216_write(u8 __iomem *ioaddr, const u8 *buf)\n{\n\tunsigned char c;\n\tint i, j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tc = buf[i];\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\twriteb(c, ioaddr);\n\t\t\tc = c >> 1;\n\t\t}\n\t}\n}\n\nstatic void ds1216_switch_ds_to_clock(u8 __iomem *ioaddr)\n{\n\t \n\treadb(ioaddr);\n\t \n\tds1216_write(ioaddr, magic);\n}\n\nstatic int ds1216_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1216_priv *priv = dev_get_drvdata(dev);\n\tstruct ds1216_regs regs;\n\n\tds1216_switch_ds_to_clock(priv->ioaddr);\n\tds1216_read(priv->ioaddr, (u8 *)&regs);\n\n\ttm->tm_sec = bcd2bin(regs.sec);\n\ttm->tm_min = bcd2bin(regs.min);\n\tif (regs.hour & DS1216_HOUR_1224) {\n\t\t \n\t\ttm->tm_hour = bcd2bin(regs.hour & 0x1f);\n\t\tif (regs.hour & DS1216_HOUR_AMPM)\n\t\t\ttm->tm_hour += 12;\n\t} else\n\t\ttm->tm_hour = bcd2bin(regs.hour & 0x3f);\n\ttm->tm_wday = (regs.wday & 7) - 1;\n\ttm->tm_mday = bcd2bin(regs.mday & 0x3f);\n\ttm->tm_mon = bcd2bin(regs.month & 0x1f);\n\ttm->tm_year = bcd2bin(regs.year);\n\tif (tm->tm_year < 70)\n\t\ttm->tm_year += 100;\n\n\treturn 0;\n}\n\nstatic int ds1216_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ds1216_priv *priv = dev_get_drvdata(dev);\n\tstruct ds1216_regs regs;\n\n\tds1216_switch_ds_to_clock(priv->ioaddr);\n\tds1216_read(priv->ioaddr, (u8 *)&regs);\n\n\tregs.tsec = 0;  \n\tregs.sec = bin2bcd(tm->tm_sec);\n\tregs.min = bin2bcd(tm->tm_min);\n\tregs.hour &= DS1216_HOUR_1224;\n\tif (regs.hour && tm->tm_hour > 12) {\n\t\tregs.hour |= DS1216_HOUR_AMPM;\n\t\ttm->tm_hour -= 12;\n\t}\n\tregs.hour |= bin2bcd(tm->tm_hour);\n\tregs.wday &= ~7;\n\tregs.wday |= tm->tm_wday;\n\tregs.mday = bin2bcd(tm->tm_mday);\n\tregs.month = bin2bcd(tm->tm_mon);\n\tregs.year = bin2bcd(tm->tm_year % 100);\n\n\tds1216_switch_ds_to_clock(priv->ioaddr);\n\tds1216_write(priv->ioaddr, (u8 *)&regs);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1216_rtc_ops = {\n\t.read_time\t= ds1216_rtc_read_time,\n\t.set_time\t= ds1216_rtc_set_time,\n};\n\nstatic int __init ds1216_rtc_probe(struct platform_device *pdev)\n{\n\tstruct ds1216_priv *priv;\n\tu8 dummy[8];\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->ioaddr))\n\t\treturn PTR_ERR(priv->ioaddr);\n\n\tpriv->rtc = devm_rtc_device_register(&pdev->dev, \"ds1216\",\n\t\t\t\t\t&ds1216_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(priv->rtc))\n\t\treturn PTR_ERR(priv->rtc);\n\n\t \n\tds1216_read(priv->ioaddr, dummy);\n\treturn 0;\n}\n\nstatic struct platform_driver ds1216_rtc_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-ds1216\",\n\t},\n};\n\nmodule_platform_driver_probe(ds1216_rtc_platform_driver, ds1216_rtc_probe);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tsbogend@alpha.franken.de>\");\nMODULE_DESCRIPTION(\"DS1216 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-ds1216\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}