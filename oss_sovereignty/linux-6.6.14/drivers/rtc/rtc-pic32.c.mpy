{
  "module_name": "rtc-pic32.c",
  "hash_id": "a8dedb4ec22c1ab23d0f18a3319fff9fbf6f8ab4175504ab85841381bbf788cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pic32.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n\n#include <asm/mach-pic32/pic32.h>\n\n#define PIC32_RTCCON\t\t0x00\n#define PIC32_RTCCON_ON\t\tBIT(15)\n#define PIC32_RTCCON_SIDL\tBIT(13)\n#define PIC32_RTCCON_RTCCLKSEL\t(3 << 9)\n#define PIC32_RTCCON_RTCCLKON\tBIT(6)\n#define PIC32_RTCCON_RTCWREN\tBIT(3)\n#define PIC32_RTCCON_RTCSYNC\tBIT(2)\n#define PIC32_RTCCON_HALFSEC\tBIT(1)\n#define PIC32_RTCCON_RTCOE\tBIT(0)\n\n#define PIC32_RTCALRM\t\t0x10\n#define PIC32_RTCALRM_ALRMEN\tBIT(15)\n#define PIC32_RTCALRM_CHIME\tBIT(14)\n#define PIC32_RTCALRM_PIV\tBIT(13)\n#define PIC32_RTCALRM_ALARMSYNC\tBIT(12)\n#define PIC32_RTCALRM_AMASK\t0x0F00\n#define PIC32_RTCALRM_ARPT\t0xFF\n\n#define PIC32_RTCHOUR\t\t0x23\n#define PIC32_RTCMIN\t\t0x22\n#define PIC32_RTCSEC\t\t0x21\n#define PIC32_RTCYEAR\t\t0x33\n#define PIC32_RTCMON\t\t0x32\n#define PIC32_RTCDAY\t\t0x31\n\n#define PIC32_ALRMTIME\t\t0x40\n#define PIC32_ALRMDATE\t\t0x50\n\n#define PIC32_ALRMHOUR\t\t0x43\n#define PIC32_ALRMMIN\t\t0x42\n#define PIC32_ALRMSEC\t\t0x41\n#define PIC32_ALRMYEAR\t\t0x53\n#define PIC32_ALRMMON\t\t0x52\n#define PIC32_ALRMDAY\t\t0x51\n\nstruct pic32_rtc_dev {\n\tstruct rtc_device\t*rtc;\n\tvoid __iomem\t\t*reg_base;\n\tstruct clk\t\t*clk;\n\tspinlock_t\t\talarm_lock;\n\tint\t\t\talarm_irq;\n\tbool\t\t\talarm_clk_enabled;\n};\n\nstatic void pic32_rtc_alarm_clk_enable(struct pic32_rtc_dev *pdata,\n\t\t\t\t       bool enable)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->alarm_lock, flags);\n\tif (enable) {\n\t\tif (!pdata->alarm_clk_enabled) {\n\t\t\tclk_enable(pdata->clk);\n\t\t\tpdata->alarm_clk_enabled = true;\n\t\t}\n\t} else {\n\t\tif (pdata->alarm_clk_enabled) {\n\t\t\tclk_disable(pdata->clk);\n\t\t\tpdata->alarm_clk_enabled = false;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pdata->alarm_lock, flags);\n}\n\nstatic irqreturn_t pic32_rtc_alarmirq(int irq, void *id)\n{\n\tstruct pic32_rtc_dev *pdata = (struct pic32_rtc_dev *)id;\n\n\tclk_enable(pdata->clk);\n\trtc_update_irq(pdata->rtc, 1, RTC_AF | RTC_IRQF);\n\tclk_disable(pdata->clk);\n\n\tpic32_rtc_alarm_clk_enable(pdata, false);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pic32_rtc_setaie(struct device *dev, unsigned int enabled)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *base = pdata->reg_base;\n\n\tclk_enable(pdata->clk);\n\n\twritel(PIC32_RTCALRM_ALRMEN,\n\t       base + (enabled ? PIC32_SET(PIC32_RTCALRM) :\n\t\t       PIC32_CLR(PIC32_RTCALRM)));\n\n\tclk_disable(pdata->clk);\n\n\tpic32_rtc_alarm_clk_enable(pdata, enabled);\n\n\treturn 0;\n}\n\nstatic int pic32_rtc_setfreq(struct device *dev, int freq)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *base = pdata->reg_base;\n\n\tclk_enable(pdata->clk);\n\n\twritel(PIC32_RTCALRM_AMASK, base + PIC32_CLR(PIC32_RTCALRM));\n\twritel(freq << 8, base + PIC32_SET(PIC32_RTCALRM));\n\twritel(PIC32_RTCALRM_CHIME, base + PIC32_SET(PIC32_RTCALRM));\n\n\tclk_disable(pdata->clk);\n\n\treturn 0;\n}\n\nstatic int pic32_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *base = pdata->reg_base;\n\tunsigned int tries = 0;\n\n\tclk_enable(pdata->clk);\n\n\tdo {\n\t\trtc_tm->tm_hour = readb(base + PIC32_RTCHOUR);\n\t\trtc_tm->tm_min = readb(base + PIC32_RTCMIN);\n\t\trtc_tm->tm_mon  = readb(base + PIC32_RTCMON);\n\t\trtc_tm->tm_mday = readb(base + PIC32_RTCDAY);\n\t\trtc_tm->tm_year = readb(base + PIC32_RTCYEAR);\n\t\trtc_tm->tm_sec  = readb(base + PIC32_RTCSEC);\n\n\t\t \n\t\ttries += 1;\n\t} while (rtc_tm->tm_sec == 0 && tries < 2);\n\n\trtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);\n\trtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);\n\trtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);\n\trtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);\n\trtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon) - 1;\n\trtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);\n\n\trtc_tm->tm_year += 100;\n\n\tdev_dbg(dev, \"read time %ptR\\n\", rtc_tm);\n\n\tclk_disable(pdata->clk);\n\treturn 0;\n}\n\nstatic int pic32_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *base = pdata->reg_base;\n\n\tdev_dbg(dev, \"set time %ptR\\n\", tm);\n\n\tclk_enable(pdata->clk);\n\twriteb(bin2bcd(tm->tm_sec),  base + PIC32_RTCSEC);\n\twriteb(bin2bcd(tm->tm_min),  base + PIC32_RTCMIN);\n\twriteb(bin2bcd(tm->tm_hour), base + PIC32_RTCHOUR);\n\twriteb(bin2bcd(tm->tm_mday), base + PIC32_RTCDAY);\n\twriteb(bin2bcd(tm->tm_mon + 1), base + PIC32_RTCMON);\n\twriteb(bin2bcd(tm->tm_year - 100), base + PIC32_RTCYEAR);\n\tclk_disable(pdata->clk);\n\n\treturn 0;\n}\n\nstatic int pic32_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tstruct rtc_time *alm_tm = &alrm->time;\n\tvoid __iomem *base = pdata->reg_base;\n\tunsigned int alm_en;\n\n\tclk_enable(pdata->clk);\n\talm_tm->tm_sec  = readb(base + PIC32_ALRMSEC);\n\talm_tm->tm_min  = readb(base + PIC32_ALRMMIN);\n\talm_tm->tm_hour = readb(base + PIC32_ALRMHOUR);\n\talm_tm->tm_mon  = readb(base + PIC32_ALRMMON);\n\talm_tm->tm_mday = readb(base + PIC32_ALRMDAY);\n\talm_tm->tm_year = readb(base + PIC32_ALRMYEAR);\n\n\talm_en = readb(base + PIC32_RTCALRM);\n\n\talrm->enabled = (alm_en & PIC32_RTCALRM_ALRMEN) ? 1 : 0;\n\n\tdev_dbg(dev, \"getalarm: %d, %ptR\\n\", alm_en, alm_tm);\n\n\talm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);\n\talm_tm->tm_min = bcd2bin(alm_tm->tm_min);\n\talm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);\n\talm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);\n\talm_tm->tm_mon = bcd2bin(alm_tm->tm_mon) - 1;\n\talm_tm->tm_year = bcd2bin(alm_tm->tm_year);\n\n\tclk_disable(pdata->clk);\n\treturn 0;\n}\n\nstatic int pic32_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tvoid __iomem *base = pdata->reg_base;\n\n\tclk_enable(pdata->clk);\n\tdev_dbg(dev, \"setalarm: %d, %ptR\\n\", alrm->enabled, tm);\n\n\twritel(0x00, base + PIC32_ALRMTIME);\n\twritel(0x00, base + PIC32_ALRMDATE);\n\n\tpic32_rtc_setaie(dev, alrm->enabled);\n\n\tclk_disable(pdata->clk);\n\treturn 0;\n}\n\nstatic int pic32_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *base = pdata->reg_base;\n\tunsigned int repeat;\n\n\tclk_enable(pdata->clk);\n\n\trepeat = readw(base + PIC32_RTCALRM);\n\trepeat &= PIC32_RTCALRM_ARPT;\n\tseq_printf(seq, \"periodic_IRQ\\t: %s\\n\", repeat  ? \"yes\" : \"no\");\n\n\tclk_disable(pdata->clk);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pic32_rtcops = {\n\t.read_time\t  = pic32_rtc_gettime,\n\t.set_time\t  = pic32_rtc_settime,\n\t.read_alarm\t  = pic32_rtc_getalarm,\n\t.set_alarm\t  = pic32_rtc_setalarm,\n\t.proc\t\t  = pic32_rtc_proc,\n\t.alarm_irq_enable = pic32_rtc_setaie,\n};\n\nstatic void pic32_rtc_enable(struct pic32_rtc_dev *pdata, int en)\n{\n\tvoid __iomem *base = pdata->reg_base;\n\n\tif (!base)\n\t\treturn;\n\n\tclk_enable(pdata->clk);\n\tif (!en) {\n\t\twritel(PIC32_RTCCON_ON, base + PIC32_CLR(PIC32_RTCCON));\n\t} else {\n\t\tpic32_syskey_unlock();\n\n\t\twritel(PIC32_RTCCON_RTCWREN, base + PIC32_SET(PIC32_RTCCON));\n\t\twritel(3 << 9, base + PIC32_CLR(PIC32_RTCCON));\n\n\t\tif (!(readl(base + PIC32_RTCCON) & PIC32_RTCCON_ON))\n\t\t\twritel(PIC32_RTCCON_ON, base + PIC32_SET(PIC32_RTCCON));\n\t}\n\tclk_disable(pdata->clk);\n}\n\nstatic void pic32_rtc_remove(struct platform_device *pdev)\n{\n\tstruct pic32_rtc_dev *pdata = platform_get_drvdata(pdev);\n\n\tpic32_rtc_setaie(&pdev->dev, 0);\n\tclk_unprepare(pdata->clk);\n\tpdata->clk = NULL;\n}\n\nstatic int pic32_rtc_probe(struct platform_device *pdev)\n{\n\tstruct pic32_rtc_dev *pdata;\n\tint ret;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pdata);\n\n\tpdata->alarm_irq = platform_get_irq(pdev, 0);\n\tif (pdata->alarm_irq < 0)\n\t\treturn pdata->alarm_irq;\n\n\tpdata->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->reg_base))\n\t\treturn PTR_ERR(pdata->reg_base);\n\n\tpdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pdata->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to find rtc clock source\\n\");\n\t\tret = PTR_ERR(pdata->clk);\n\t\tpdata->clk = NULL;\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&pdata->alarm_lock);\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc))\n\t\treturn PTR_ERR(pdata->rtc);\n\n\tclk_prepare_enable(pdata->clk);\n\n\tpic32_rtc_enable(pdata, 1);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tpdata->rtc->ops = &pic32_rtcops;\n\tpdata->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpdata->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tret = devm_rtc_register_device(pdata->rtc);\n\tif (ret)\n\t\tgoto err_nortc;\n\n\tpdata->rtc->max_user_freq = 128;\n\n\tpic32_rtc_setfreq(&pdev->dev, 1);\n\tret = devm_request_irq(&pdev->dev, pdata->alarm_irq,\n\t\t\t       pic32_rtc_alarmirq, 0,\n\t\t\t       dev_name(&pdev->dev), pdata);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"IRQ %d error %d\\n\", pdata->alarm_irq, ret);\n\t\tgoto err_nortc;\n\t}\n\n\tclk_disable(pdata->clk);\n\n\treturn 0;\n\nerr_nortc:\n\tpic32_rtc_enable(pdata, 0);\n\tclk_disable_unprepare(pdata->clk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id pic32_rtc_dt_ids[] = {\n\t{ .compatible = \"microchip,pic32mzda-rtc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pic32_rtc_dt_ids);\n\nstatic struct platform_driver pic32_rtc_driver = {\n\t.probe\t\t= pic32_rtc_probe,\n\t.remove_new\t= pic32_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pic32-rtc\",\n\t\t.of_match_table\t= of_match_ptr(pic32_rtc_dt_ids),\n\t},\n};\nmodule_platform_driver(pic32_rtc_driver);\n\nMODULE_DESCRIPTION(\"Microchip PIC32 RTC Driver\");\nMODULE_AUTHOR(\"Joshua Henderson <joshua.henderson@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}