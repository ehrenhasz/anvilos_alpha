{
  "module_name": "rtc-omap.c",
  "hash_id": "dcdb5a7b523bb0b55b7e79cb916ca5d3e15bd963cf60f94c0f76bbfc30ed1d0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-omap.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rtc.h>\n#include <linux/rtc/rtc-omap.h>\n\n \n\n \n#define OMAP_RTC_SECONDS_REG\t\t0x00\n#define OMAP_RTC_MINUTES_REG\t\t0x04\n#define OMAP_RTC_HOURS_REG\t\t0x08\n#define OMAP_RTC_DAYS_REG\t\t0x0C\n#define OMAP_RTC_MONTHS_REG\t\t0x10\n#define OMAP_RTC_YEARS_REG\t\t0x14\n#define OMAP_RTC_WEEKS_REG\t\t0x18\n\n#define OMAP_RTC_ALARM_SECONDS_REG\t0x20\n#define OMAP_RTC_ALARM_MINUTES_REG\t0x24\n#define OMAP_RTC_ALARM_HOURS_REG\t0x28\n#define OMAP_RTC_ALARM_DAYS_REG\t\t0x2c\n#define OMAP_RTC_ALARM_MONTHS_REG\t0x30\n#define OMAP_RTC_ALARM_YEARS_REG\t0x34\n\n#define OMAP_RTC_CTRL_REG\t\t0x40\n#define OMAP_RTC_STATUS_REG\t\t0x44\n#define OMAP_RTC_INTERRUPTS_REG\t\t0x48\n\n#define OMAP_RTC_COMP_LSB_REG\t\t0x4c\n#define OMAP_RTC_COMP_MSB_REG\t\t0x50\n#define OMAP_RTC_OSC_REG\t\t0x54\n\n#define OMAP_RTC_SCRATCH0_REG\t\t0x60\n#define OMAP_RTC_SCRATCH1_REG\t\t0x64\n#define OMAP_RTC_SCRATCH2_REG\t\t0x68\n\n#define OMAP_RTC_KICK0_REG\t\t0x6c\n#define OMAP_RTC_KICK1_REG\t\t0x70\n\n#define OMAP_RTC_IRQWAKEEN\t\t0x7c\n\n#define OMAP_RTC_ALARM2_SECONDS_REG\t0x80\n#define OMAP_RTC_ALARM2_MINUTES_REG\t0x84\n#define OMAP_RTC_ALARM2_HOURS_REG\t0x88\n#define OMAP_RTC_ALARM2_DAYS_REG\t0x8c\n#define OMAP_RTC_ALARM2_MONTHS_REG\t0x90\n#define OMAP_RTC_ALARM2_YEARS_REG\t0x94\n\n#define OMAP_RTC_PMIC_REG\t\t0x98\n\n \n#define OMAP_RTC_CTRL_SPLIT\t\tBIT(7)\n#define OMAP_RTC_CTRL_DISABLE\t\tBIT(6)\n#define OMAP_RTC_CTRL_SET_32_COUNTER\tBIT(5)\n#define OMAP_RTC_CTRL_TEST\t\tBIT(4)\n#define OMAP_RTC_CTRL_MODE_12_24\tBIT(3)\n#define OMAP_RTC_CTRL_AUTO_COMP\t\tBIT(2)\n#define OMAP_RTC_CTRL_ROUND_30S\t\tBIT(1)\n#define OMAP_RTC_CTRL_STOP\t\tBIT(0)\n\n \n#define OMAP_RTC_STATUS_POWER_UP\tBIT(7)\n#define OMAP_RTC_STATUS_ALARM2\t\tBIT(7)\n#define OMAP_RTC_STATUS_ALARM\t\tBIT(6)\n#define OMAP_RTC_STATUS_1D_EVENT\tBIT(5)\n#define OMAP_RTC_STATUS_1H_EVENT\tBIT(4)\n#define OMAP_RTC_STATUS_1M_EVENT\tBIT(3)\n#define OMAP_RTC_STATUS_1S_EVENT\tBIT(2)\n#define OMAP_RTC_STATUS_RUN\t\tBIT(1)\n#define OMAP_RTC_STATUS_BUSY\t\tBIT(0)\n\n \n#define OMAP_RTC_INTERRUPTS_IT_ALARM2\tBIT(4)\n#define OMAP_RTC_INTERRUPTS_IT_ALARM\tBIT(3)\n#define OMAP_RTC_INTERRUPTS_IT_TIMER\tBIT(2)\n\n \n#define OMAP_RTC_OSC_32KCLK_EN\t\tBIT(6)\n#define OMAP_RTC_OSC_SEL_32KCLK_SRC\tBIT(3)\n#define OMAP_RTC_OSC_OSC32K_GZ_DISABLE\tBIT(4)\n\n \n#define OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN\tBIT(1)\n\n \n#define OMAP_RTC_PMIC_POWER_EN_EN\tBIT(16)\n#define OMAP_RTC_PMIC_EXT_WKUP_EN(x)\tBIT(x)\n#define OMAP_RTC_PMIC_EXT_WKUP_POL(x)\tBIT(4 + x)\n\n \n#define\tKICK0_VALUE\t\t\t0x83e70b13\n#define\tKICK1_VALUE\t\t\t0x95a4f1e0\n\nstruct omap_rtc;\n\nstruct omap_rtc_device_type {\n\tbool has_32kclk_en;\n\tbool has_irqwakeen;\n\tbool has_pmic_mode;\n\tbool has_power_up_reset;\n\tvoid (*lock)(struct omap_rtc *rtc);\n\tvoid (*unlock)(struct omap_rtc *rtc);\n};\n\nstruct omap_rtc {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tint irq_alarm;\n\tint irq_timer;\n\tu8 interrupts_reg;\n\tbool is_pmic_controller;\n\tbool has_ext_clk;\n\tbool is_suspending;\n\tconst struct omap_rtc_device_type *type;\n\tstruct pinctrl_dev *pctldev;\n};\n\nstatic inline u8 rtc_read(struct omap_rtc *rtc, unsigned int reg)\n{\n\treturn readb(rtc->base + reg);\n}\n\nstatic inline u32 rtc_readl(struct omap_rtc *rtc, unsigned int reg)\n{\n\treturn readl(rtc->base + reg);\n}\n\nstatic inline void rtc_write(struct omap_rtc *rtc, unsigned int reg, u8 val)\n{\n\twriteb(val, rtc->base + reg);\n}\n\nstatic inline void rtc_writel(struct omap_rtc *rtc, unsigned int reg, u32 val)\n{\n\twritel(val, rtc->base + reg);\n}\n\nstatic void am3352_rtc_unlock(struct omap_rtc *rtc)\n{\n\trtc_writel(rtc, OMAP_RTC_KICK0_REG, KICK0_VALUE);\n\trtc_writel(rtc, OMAP_RTC_KICK1_REG, KICK1_VALUE);\n}\n\nstatic void am3352_rtc_lock(struct omap_rtc *rtc)\n{\n\trtc_writel(rtc, OMAP_RTC_KICK0_REG, 0);\n\trtc_writel(rtc, OMAP_RTC_KICK1_REG, 0);\n}\n\nstatic void default_rtc_unlock(struct omap_rtc *rtc)\n{\n}\n\nstatic void default_rtc_lock(struct omap_rtc *rtc)\n{\n}\n\n \nstatic void rtc_wait_not_busy(struct omap_rtc *rtc)\n{\n\tint count;\n\tu8 status;\n\n\t \n\tfor (count = 0; count < 50; count++) {\n\t\tstatus = rtc_read(rtc, OMAP_RTC_STATUS_REG);\n\t\tif (!(status & OMAP_RTC_STATUS_BUSY))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\t \n}\n\nstatic irqreturn_t rtc_irq(int irq, void *dev_id)\n{\n\tstruct omap_rtc\t*rtc = dev_id;\n\tunsigned long events = 0;\n\tu8 irq_data;\n\n\tirq_data = rtc_read(rtc, OMAP_RTC_STATUS_REG);\n\n\t \n\tif (irq_data & OMAP_RTC_STATUS_ALARM) {\n\t\trtc->type->unlock(rtc);\n\t\trtc_write(rtc, OMAP_RTC_STATUS_REG, OMAP_RTC_STATUS_ALARM);\n\t\trtc->type->lock(rtc);\n\t\tevents |= RTC_IRQF | RTC_AF;\n\t}\n\n\t \n\tif (irq_data & OMAP_RTC_STATUS_1S_EVENT)\n\t\tevents |= RTC_IRQF | RTC_UF;\n\n\trtc_update_irq(rtc->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int omap_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\tu8 reg, irqwake_reg = 0;\n\n\tlocal_irq_disable();\n\trtc_wait_not_busy(rtc);\n\treg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\tif (rtc->type->has_irqwakeen)\n\t\tirqwake_reg = rtc_read(rtc, OMAP_RTC_IRQWAKEEN);\n\n\tif (enabled) {\n\t\treg |= OMAP_RTC_INTERRUPTS_IT_ALARM;\n\t\tirqwake_reg |= OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\n\t} else {\n\t\treg &= ~OMAP_RTC_INTERRUPTS_IT_ALARM;\n\t\tirqwake_reg &= ~OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\n\t}\n\trtc_wait_not_busy(rtc);\n\trtc->type->unlock(rtc);\n\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, reg);\n\tif (rtc->type->has_irqwakeen)\n\t\trtc_write(rtc, OMAP_RTC_IRQWAKEEN, irqwake_reg);\n\trtc->type->lock(rtc);\n\tlocal_irq_enable();\n\n\treturn 0;\n}\n\n \nstatic void tm2bcd(struct rtc_time *tm)\n{\n\ttm->tm_sec = bin2bcd(tm->tm_sec);\n\ttm->tm_min = bin2bcd(tm->tm_min);\n\ttm->tm_hour = bin2bcd(tm->tm_hour);\n\ttm->tm_mday = bin2bcd(tm->tm_mday);\n\n\ttm->tm_mon = bin2bcd(tm->tm_mon + 1);\n\ttm->tm_year = bin2bcd(tm->tm_year - 100);\n}\n\nstatic void bcd2tm(struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon) - 1;\n\t \n\ttm->tm_year = bcd2bin(tm->tm_year) + 100;\n}\n\nstatic void omap_rtc_read_time_raw(struct omap_rtc *rtc, struct rtc_time *tm)\n{\n\ttm->tm_sec = rtc_read(rtc, OMAP_RTC_SECONDS_REG);\n\ttm->tm_min = rtc_read(rtc, OMAP_RTC_MINUTES_REG);\n\ttm->tm_hour = rtc_read(rtc, OMAP_RTC_HOURS_REG);\n\ttm->tm_mday = rtc_read(rtc, OMAP_RTC_DAYS_REG);\n\ttm->tm_mon = rtc_read(rtc, OMAP_RTC_MONTHS_REG);\n\ttm->tm_year = rtc_read(rtc, OMAP_RTC_YEARS_REG);\n}\n\nstatic int omap_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\n\t \n\tlocal_irq_disable();\n\trtc_wait_not_busy(rtc);\n\tomap_rtc_read_time_raw(rtc, tm);\n\tlocal_irq_enable();\n\n\tbcd2tm(tm);\n\n\treturn 0;\n}\n\nstatic int omap_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\n\ttm2bcd(tm);\n\n\tlocal_irq_disable();\n\trtc_wait_not_busy(rtc);\n\n\trtc->type->unlock(rtc);\n\trtc_write(rtc, OMAP_RTC_YEARS_REG, tm->tm_year);\n\trtc_write(rtc, OMAP_RTC_MONTHS_REG, tm->tm_mon);\n\trtc_write(rtc, OMAP_RTC_DAYS_REG, tm->tm_mday);\n\trtc_write(rtc, OMAP_RTC_HOURS_REG, tm->tm_hour);\n\trtc_write(rtc, OMAP_RTC_MINUTES_REG, tm->tm_min);\n\trtc_write(rtc, OMAP_RTC_SECONDS_REG, tm->tm_sec);\n\trtc->type->lock(rtc);\n\n\tlocal_irq_enable();\n\n\treturn 0;\n}\n\nstatic int omap_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\tu8 interrupts;\n\n\tlocal_irq_disable();\n\trtc_wait_not_busy(rtc);\n\n\talm->time.tm_sec = rtc_read(rtc, OMAP_RTC_ALARM_SECONDS_REG);\n\talm->time.tm_min = rtc_read(rtc, OMAP_RTC_ALARM_MINUTES_REG);\n\talm->time.tm_hour = rtc_read(rtc, OMAP_RTC_ALARM_HOURS_REG);\n\talm->time.tm_mday = rtc_read(rtc, OMAP_RTC_ALARM_DAYS_REG);\n\talm->time.tm_mon = rtc_read(rtc, OMAP_RTC_ALARM_MONTHS_REG);\n\talm->time.tm_year = rtc_read(rtc, OMAP_RTC_ALARM_YEARS_REG);\n\n\tlocal_irq_enable();\n\n\tbcd2tm(&alm->time);\n\n\tinterrupts = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\talm->enabled = !!(interrupts & OMAP_RTC_INTERRUPTS_IT_ALARM);\n\n\treturn 0;\n}\n\nstatic int omap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\tu8 reg, irqwake_reg = 0;\n\n\ttm2bcd(&alm->time);\n\n\tlocal_irq_disable();\n\trtc_wait_not_busy(rtc);\n\n\trtc->type->unlock(rtc);\n\trtc_write(rtc, OMAP_RTC_ALARM_YEARS_REG, alm->time.tm_year);\n\trtc_write(rtc, OMAP_RTC_ALARM_MONTHS_REG, alm->time.tm_mon);\n\trtc_write(rtc, OMAP_RTC_ALARM_DAYS_REG, alm->time.tm_mday);\n\trtc_write(rtc, OMAP_RTC_ALARM_HOURS_REG, alm->time.tm_hour);\n\trtc_write(rtc, OMAP_RTC_ALARM_MINUTES_REG, alm->time.tm_min);\n\trtc_write(rtc, OMAP_RTC_ALARM_SECONDS_REG, alm->time.tm_sec);\n\n\treg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\tif (rtc->type->has_irqwakeen)\n\t\tirqwake_reg = rtc_read(rtc, OMAP_RTC_IRQWAKEEN);\n\n\tif (alm->enabled) {\n\t\treg |= OMAP_RTC_INTERRUPTS_IT_ALARM;\n\t\tirqwake_reg |= OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\n\t} else {\n\t\treg &= ~OMAP_RTC_INTERRUPTS_IT_ALARM;\n\t\tirqwake_reg &= ~OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\n\t}\n\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, reg);\n\tif (rtc->type->has_irqwakeen)\n\t\trtc_write(rtc, OMAP_RTC_IRQWAKEEN, irqwake_reg);\n\trtc->type->lock(rtc);\n\n\tlocal_irq_enable();\n\n\treturn 0;\n}\n\nstatic struct omap_rtc *omap_rtc_power_off_rtc;\n\n \nint omap_rtc_power_off_program(struct device *dev)\n{\n\tstruct omap_rtc *rtc = omap_rtc_power_off_rtc;\n\tstruct rtc_time tm;\n\tunsigned long now;\n\tint seconds;\n\tu32 val;\n\n\trtc->type->unlock(rtc);\n\t \n\tval = rtc_readl(rtc, OMAP_RTC_PMIC_REG);\n\trtc_writel(rtc, OMAP_RTC_PMIC_REG, val | OMAP_RTC_PMIC_POWER_EN_EN);\n\nagain:\n\t \n\trtc_writel(rtc, OMAP_RTC_STATUS_REG, OMAP_RTC_STATUS_ALARM2);\n\n\t \n\tomap_rtc_read_time_raw(rtc, &tm);\n\tseconds = tm.tm_sec;\n\tbcd2tm(&tm);\n\tnow = rtc_tm_to_time64(&tm);\n\trtc_time64_to_tm(now + 1, &tm);\n\n\ttm2bcd(&tm);\n\n\trtc_wait_not_busy(rtc);\n\n\trtc_write(rtc, OMAP_RTC_ALARM2_SECONDS_REG, tm.tm_sec);\n\trtc_write(rtc, OMAP_RTC_ALARM2_MINUTES_REG, tm.tm_min);\n\trtc_write(rtc, OMAP_RTC_ALARM2_HOURS_REG, tm.tm_hour);\n\trtc_write(rtc, OMAP_RTC_ALARM2_DAYS_REG, tm.tm_mday);\n\trtc_write(rtc, OMAP_RTC_ALARM2_MONTHS_REG, tm.tm_mon);\n\trtc_write(rtc, OMAP_RTC_ALARM2_YEARS_REG, tm.tm_year);\n\n\t \n\tval = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\trtc_writel(rtc, OMAP_RTC_INTERRUPTS_REG,\n\t\t\tval | OMAP_RTC_INTERRUPTS_IT_ALARM2);\n\n\t \n\tif (rtc_read(rtc, OMAP_RTC_SECONDS_REG) != seconds) {\n\t\tval = rtc_read(rtc, OMAP_RTC_STATUS_REG);\n\t\tif (!(val & OMAP_RTC_STATUS_ALARM2))\n\t\t\tgoto again;\n\t}\n\n\trtc->type->lock(rtc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(omap_rtc_power_off_program);\n\n \nstatic void omap_rtc_power_off(void)\n{\n\tstruct rtc_device *rtc = omap_rtc_power_off_rtc->rtc;\n\tu32 val;\n\n\tomap_rtc_power_off_program(rtc->dev.parent);\n\n\t \n\tomap_rtc_power_off_rtc->type->unlock(omap_rtc_power_off_rtc);\n\tval = rtc_readl(omap_rtc_power_off_rtc, OMAP_RTC_PMIC_REG);\n\tval |= OMAP_RTC_PMIC_POWER_EN_EN | OMAP_RTC_PMIC_EXT_WKUP_POL(0) |\n\t\t\tOMAP_RTC_PMIC_EXT_WKUP_EN(0);\n\trtc_writel(omap_rtc_power_off_rtc, OMAP_RTC_PMIC_REG, val);\n\tomap_rtc_power_off_rtc->type->lock(omap_rtc_power_off_rtc);\n\n\t \n\tmdelay(1500);\n}\n\nstatic const struct rtc_class_ops omap_rtc_ops = {\n\t.read_time\t= omap_rtc_read_time,\n\t.set_time\t= omap_rtc_set_time,\n\t.read_alarm\t= omap_rtc_read_alarm,\n\t.set_alarm\t= omap_rtc_set_alarm,\n\t.alarm_irq_enable = omap_rtc_alarm_irq_enable,\n};\n\nstatic const struct omap_rtc_device_type omap_rtc_default_type = {\n\t.has_power_up_reset = true,\n\t.lock\t\t= default_rtc_lock,\n\t.unlock\t\t= default_rtc_unlock,\n};\n\nstatic const struct omap_rtc_device_type omap_rtc_am3352_type = {\n\t.has_32kclk_en\t= true,\n\t.has_irqwakeen\t= true,\n\t.has_pmic_mode\t= true,\n\t.lock\t\t= am3352_rtc_lock,\n\t.unlock\t\t= am3352_rtc_unlock,\n};\n\nstatic const struct omap_rtc_device_type omap_rtc_da830_type = {\n\t.lock\t\t= am3352_rtc_lock,\n\t.unlock\t\t= am3352_rtc_unlock,\n};\n\nstatic const struct platform_device_id omap_rtc_id_table[] = {\n\t{\n\t\t.name\t= \"omap_rtc\",\n\t\t.driver_data = (kernel_ulong_t)&omap_rtc_default_type,\n\t}, {\n\t\t.name\t= \"am3352-rtc\",\n\t\t.driver_data = (kernel_ulong_t)&omap_rtc_am3352_type,\n\t}, {\n\t\t.name\t= \"da830-rtc\",\n\t\t.driver_data = (kernel_ulong_t)&omap_rtc_da830_type,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, omap_rtc_id_table);\n\nstatic const struct of_device_id omap_rtc_of_match[] = {\n\t{\n\t\t.compatible\t= \"ti,am3352-rtc\",\n\t\t.data\t\t= &omap_rtc_am3352_type,\n\t}, {\n\t\t.compatible\t= \"ti,da830-rtc\",\n\t\t.data\t\t= &omap_rtc_da830_type,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, omap_rtc_of_match);\n\nstatic const struct pinctrl_pin_desc rtc_pins_desc[] = {\n\tPINCTRL_PIN(0, \"ext_wakeup0\"),\n\tPINCTRL_PIN(1, \"ext_wakeup1\"),\n\tPINCTRL_PIN(2, \"ext_wakeup2\"),\n\tPINCTRL_PIN(3, \"ext_wakeup3\"),\n};\n\nstatic int rtc_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 0;\n}\n\nstatic const char *rtc_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int group)\n{\n\treturn NULL;\n}\n\nstatic const struct pinctrl_ops rtc_pinctrl_ops = {\n\t.get_groups_count = rtc_pinctrl_get_groups_count,\n\t.get_group_name = rtc_pinctrl_get_group_name,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\n#define PIN_CONFIG_ACTIVE_HIGH\t\t(PIN_CONFIG_END + 1)\n\nstatic const struct pinconf_generic_params rtc_params[] = {\n\t{\"ti,active-high\", PIN_CONFIG_ACTIVE_HIGH, 0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item rtc_conf_items[ARRAY_SIZE(rtc_params)] = {\n\tPCONFDUMP(PIN_CONFIG_ACTIVE_HIGH, \"input active high\", NULL, false),\n};\n#endif\n\nstatic int rtc_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\tunsigned int pin, unsigned long *config)\n{\n\tstruct omap_rtc *rtc = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tu32 val;\n\tu16 arg = 0;\n\n\tval = rtc_readl(rtc, OMAP_RTC_PMIC_REG);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (!(val & OMAP_RTC_PMIC_EXT_WKUP_EN(pin)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_ACTIVE_HIGH:\n\t\tif (val & OMAP_RTC_PMIC_EXT_WKUP_POL(pin))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int rtc_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\tunsigned int pin, unsigned long *configs,\n\t\t\tunsigned int num_configs)\n{\n\tstruct omap_rtc *rtc = pinctrl_dev_get_drvdata(pctldev);\n\tu32 val;\n\tunsigned int param;\n\tu32 param_val;\n\tint i;\n\n\tval = rtc_readl(rtc, OMAP_RTC_PMIC_REG);\n\n\t \n\tval |= OMAP_RTC_PMIC_EXT_WKUP_POL(pin);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tparam_val = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tif (param_val)\n\t\t\t\tval |= OMAP_RTC_PMIC_EXT_WKUP_EN(pin);\n\t\t\telse\n\t\t\t\tval &= ~OMAP_RTC_PMIC_EXT_WKUP_EN(pin);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_ACTIVE_HIGH:\n\t\t\tval &= ~OMAP_RTC_PMIC_EXT_WKUP_POL(pin);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&rtc->rtc->dev, \"Property %u not supported\\n\",\n\t\t\t\tparam);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\trtc->type->unlock(rtc);\n\trtc_writel(rtc, OMAP_RTC_PMIC_REG, val);\n\trtc->type->lock(rtc);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops rtc_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = rtc_pinconf_get,\n\t.pin_config_set = rtc_pinconf_set,\n};\n\nstatic struct pinctrl_desc rtc_pinctrl_desc = {\n\t.pins = rtc_pins_desc,\n\t.npins = ARRAY_SIZE(rtc_pins_desc),\n\t.pctlops = &rtc_pinctrl_ops,\n\t.confops = &rtc_pinconf_ops,\n\t.custom_params = rtc_params,\n\t.num_custom_params = ARRAY_SIZE(rtc_params),\n#ifdef CONFIG_DEBUG_FS\n\t.custom_conf_items = rtc_conf_items,\n#endif\n\t.owner = THIS_MODULE,\n};\n\nstatic int omap_rtc_scratch_read(void *priv, unsigned int offset, void *_val,\n\t\t\t\t size_t bytes)\n{\n\tstruct omap_rtc\t*rtc = priv;\n\tu32 *val = _val;\n\tint i;\n\n\tfor (i = 0; i < bytes / 4; i++)\n\t\tval[i] = rtc_readl(rtc,\n\t\t\t\t   OMAP_RTC_SCRATCH0_REG + offset + (i * 4));\n\n\treturn 0;\n}\n\nstatic int omap_rtc_scratch_write(void *priv, unsigned int offset, void *_val,\n\t\t\t\t  size_t bytes)\n{\n\tstruct omap_rtc\t*rtc = priv;\n\tu32 *val = _val;\n\tint i;\n\n\trtc->type->unlock(rtc);\n\tfor (i = 0; i < bytes / 4; i++)\n\t\trtc_writel(rtc,\n\t\t\t   OMAP_RTC_SCRATCH0_REG + offset + (i * 4), val[i]);\n\trtc->type->lock(rtc);\n\n\treturn 0;\n}\n\nstatic struct nvmem_config omap_rtc_nvmem_config = {\n\t.name = \"omap_rtc_scratch\",\n\t.word_size = 4,\n\t.stride = 4,\n\t.size = OMAP_RTC_KICK0_REG - OMAP_RTC_SCRATCH0_REG,\n\t.reg_read = omap_rtc_scratch_read,\n\t.reg_write = omap_rtc_scratch_write,\n};\n\nstatic int omap_rtc_probe(struct platform_device *pdev)\n{\n\tstruct omap_rtc\t*rtc;\n\tu8 reg, mask, new_ctrl;\n\tconst struct platform_device_id *id_entry;\n\tconst struct of_device_id *of_id;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(omap_rtc_of_match, &pdev->dev);\n\tif (of_id) {\n\t\trtc->type = of_id->data;\n\t\trtc->is_pmic_controller = rtc->type->has_pmic_mode &&\n\t\t\tof_device_is_system_power_controller(pdev->dev.of_node);\n\t} else {\n\t\tid_entry = platform_get_device_id(pdev);\n\t\trtc->type = (void *)id_entry->driver_data;\n\t}\n\n\trtc->irq_timer = platform_get_irq(pdev, 0);\n\tif (rtc->irq_timer < 0)\n\t\treturn rtc->irq_timer;\n\n\trtc->irq_alarm = platform_get_irq(pdev, 1);\n\tif (rtc->irq_alarm < 0)\n\t\treturn rtc->irq_alarm;\n\n\trtc->clk = devm_clk_get(&pdev->dev, \"ext-clk\");\n\tif (!IS_ERR(rtc->clk))\n\t\trtc->has_ext_clk = true;\n\telse\n\t\trtc->clk = devm_clk_get(&pdev->dev, \"int-clk\");\n\n\tif (!IS_ERR(rtc->clk))\n\t\tclk_prepare_enable(rtc->clk);\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base)) {\n\t\tclk_disable_unprepare(rtc->clk);\n\t\treturn PTR_ERR(rtc->base);\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\trtc->type->unlock(rtc);\n\n\t \n\trtc_writel(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\n\n\t \n\tif (rtc->type->has_32kclk_en) {\n\t\treg = rtc_read(rtc, OMAP_RTC_OSC_REG);\n\t\trtc_write(rtc, OMAP_RTC_OSC_REG, reg | OMAP_RTC_OSC_32KCLK_EN);\n\t}\n\n\t \n\treg = rtc_read(rtc, OMAP_RTC_STATUS_REG);\n\n\tmask = OMAP_RTC_STATUS_ALARM;\n\n\tif (rtc->type->has_pmic_mode)\n\t\tmask |= OMAP_RTC_STATUS_ALARM2;\n\n\tif (rtc->type->has_power_up_reset) {\n\t\tmask |= OMAP_RTC_STATUS_POWER_UP;\n\t\tif (reg & OMAP_RTC_STATUS_POWER_UP)\n\t\t\tdev_info(&pdev->dev, \"RTC power up reset detected\\n\");\n\t}\n\n\tif (reg & mask)\n\t\trtc_write(rtc, OMAP_RTC_STATUS_REG, reg & mask);\n\n\t \n\treg = rtc_read(rtc, OMAP_RTC_CTRL_REG);\n\tif (reg & OMAP_RTC_CTRL_STOP)\n\t\tdev_info(&pdev->dev, \"already running\\n\");\n\n\t \n\tnew_ctrl = reg & (OMAP_RTC_CTRL_SPLIT | OMAP_RTC_CTRL_AUTO_COMP);\n\tnew_ctrl |= OMAP_RTC_CTRL_STOP;\n\n\t \n\n\tif (new_ctrl & OMAP_RTC_CTRL_SPLIT)\n\t\tdev_info(&pdev->dev, \"split power mode\\n\");\n\n\tif (reg != new_ctrl)\n\t\trtc_write(rtc, OMAP_RTC_CTRL_REG, new_ctrl);\n\n\t \n\tif (rtc->has_ext_clk) {\n\t\treg = rtc_read(rtc, OMAP_RTC_OSC_REG);\n\t\treg &= ~OMAP_RTC_OSC_OSC32K_GZ_DISABLE;\n\t\treg |= OMAP_RTC_OSC_32KCLK_EN | OMAP_RTC_OSC_SEL_32KCLK_SRC;\n\t\trtc_write(rtc, OMAP_RTC_OSC_REG, reg);\n\t}\n\n\trtc->type->lock(rtc);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc)) {\n\t\tret = PTR_ERR(rtc->rtc);\n\t\tgoto err;\n\t}\n\n\trtc->rtc->ops = &omap_rtc_ops;\n\trtc->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tomap_rtc_nvmem_config.priv = rtc;\n\n\t \n\tret = devm_request_irq(&pdev->dev, rtc->irq_timer, rtc_irq, 0,\n\t\t\tdev_name(&rtc->rtc->dev), rtc);\n\tif (ret)\n\t\tgoto err;\n\n\tif (rtc->irq_timer != rtc->irq_alarm) {\n\t\tret = devm_request_irq(&pdev->dev, rtc->irq_alarm, rtc_irq, 0,\n\t\t\t\tdev_name(&rtc->rtc->dev), rtc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\trtc_pinctrl_desc.name = dev_name(&pdev->dev);\n\n\trtc->pctldev = devm_pinctrl_register(&pdev->dev, &rtc_pinctrl_desc, rtc);\n\tif (IS_ERR(rtc->pctldev)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\tret = PTR_ERR(rtc->pctldev);\n\t\tgoto err;\n\t}\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\tgoto err;\n\n\tdevm_rtc_nvmem_register(rtc->rtc, &omap_rtc_nvmem_config);\n\n\tif (rtc->is_pmic_controller) {\n\t\tif (!pm_power_off) {\n\t\t\tomap_rtc_power_off_rtc = rtc;\n\t\t\tpm_power_off = omap_rtc_power_off;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(rtc->clk);\n\tdevice_init_wakeup(&pdev->dev, false);\n\trtc->type->lock(rtc);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void omap_rtc_remove(struct platform_device *pdev)\n{\n\tstruct omap_rtc *rtc = platform_get_drvdata(pdev);\n\tu8 reg;\n\n\tif (pm_power_off == omap_rtc_power_off &&\n\t\t\tomap_rtc_power_off_rtc == rtc) {\n\t\tpm_power_off = NULL;\n\t\tomap_rtc_power_off_rtc = NULL;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\n\tif (!IS_ERR(rtc->clk))\n\t\tclk_disable_unprepare(rtc->clk);\n\n\trtc->type->unlock(rtc);\n\t \n\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\n\n\tif (rtc->has_ext_clk) {\n\t\treg = rtc_read(rtc, OMAP_RTC_OSC_REG);\n\t\treg &= ~OMAP_RTC_OSC_SEL_32KCLK_SRC;\n\t\trtc_write(rtc, OMAP_RTC_OSC_REG, reg);\n\t}\n\n\trtc->type->lock(rtc);\n\n\t \n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused omap_rtc_suspend(struct device *dev)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc->interrupts_reg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\n\trtc->type->unlock(rtc);\n\t \n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(rtc->irq_alarm);\n\telse\n\t\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\n\trtc->type->lock(rtc);\n\n\trtc->is_suspending = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_rtc_resume(struct device *dev)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc->type->unlock(rtc);\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(rtc->irq_alarm);\n\telse\n\t\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, rtc->interrupts_reg);\n\trtc->type->lock(rtc);\n\n\trtc->is_suspending = false;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_rtc_runtime_suspend(struct device *dev)\n{\n\tstruct omap_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->is_suspending && !rtc->has_ext_clk)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_rtc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(omap_rtc_suspend, omap_rtc_resume)\n\tSET_RUNTIME_PM_OPS(omap_rtc_runtime_suspend, NULL, NULL)\n};\n\nstatic void omap_rtc_shutdown(struct platform_device *pdev)\n{\n\tstruct omap_rtc *rtc = platform_get_drvdata(pdev);\n\tu8 mask;\n\n\t \n\trtc->type->unlock(rtc);\n\tmask = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\n\tmask &= OMAP_RTC_INTERRUPTS_IT_ALARM;\n\trtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, mask);\n\trtc->type->lock(rtc);\n}\n\nstatic struct platform_driver omap_rtc_driver = {\n\t.probe\t\t= omap_rtc_probe,\n\t.remove_new\t= omap_rtc_remove,\n\t.shutdown\t= omap_rtc_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"omap_rtc\",\n\t\t.pm\t= &omap_rtc_pm_ops,\n\t\t.of_match_table = omap_rtc_of_match,\n\t},\n\t.id_table\t= omap_rtc_id_table,\n};\n\nmodule_platform_driver(omap_rtc_driver);\n\nMODULE_AUTHOR(\"George G. Davis (and others)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}