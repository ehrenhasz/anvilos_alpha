{
  "module_name": "rtc-ftrtc010.c",
  "hash_id": "5a721322c7f093c6497be560b5a5505a56edcb85b7b8a0aca399312a62f8f78e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ftrtc010.c",
  "human_readable_source": "\n \n\n#include <linux/rtc.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/clk.h>\n\n#define DRV_NAME        \"rtc-ftrtc010\"\n\nMODULE_AUTHOR(\"Hans Ulli Kroll <ulli.kroll@googlemail.com>\");\nMODULE_DESCRIPTION(\"RTC driver for Gemini SoC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n\nstruct ftrtc010_rtc {\n\tstruct rtc_device\t*rtc_dev;\n\tvoid __iomem\t\t*rtc_base;\n\tint\t\t\trtc_irq;\n\tstruct clk\t\t*pclk;\n\tstruct clk\t\t*extclk;\n};\n\nenum ftrtc010_rtc_offsets {\n\tFTRTC010_RTC_SECOND\t\t= 0x00,\n\tFTRTC010_RTC_MINUTE\t\t= 0x04,\n\tFTRTC010_RTC_HOUR\t\t= 0x08,\n\tFTRTC010_RTC_DAYS\t\t= 0x0C,\n\tFTRTC010_RTC_ALARM_SECOND\t= 0x10,\n\tFTRTC010_RTC_ALARM_MINUTE\t= 0x14,\n\tFTRTC010_RTC_ALARM_HOUR\t\t= 0x18,\n\tFTRTC010_RTC_RECORD\t\t= 0x1C,\n\tFTRTC010_RTC_CR\t\t\t= 0x20,\n};\n\nstatic irqreturn_t ftrtc010_rtc_interrupt(int irq, void *dev)\n{\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int ftrtc010_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ftrtc010_rtc *rtc = dev_get_drvdata(dev);\n\n\tu32 days, hour, min, sec, offset;\n\ttimeu64_t time;\n\n\tsec  = readl(rtc->rtc_base + FTRTC010_RTC_SECOND);\n\tmin  = readl(rtc->rtc_base + FTRTC010_RTC_MINUTE);\n\thour = readl(rtc->rtc_base + FTRTC010_RTC_HOUR);\n\tdays = readl(rtc->rtc_base + FTRTC010_RTC_DAYS);\n\toffset = readl(rtc->rtc_base + FTRTC010_RTC_RECORD);\n\n\ttime = offset + days * 86400 + hour * 3600 + min * 60 + sec;\n\n\trtc_time64_to_tm(time, tm);\n\n\treturn 0;\n}\n\nstatic int ftrtc010_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ftrtc010_rtc *rtc = dev_get_drvdata(dev);\n\tu32 sec, min, hour, day, offset;\n\ttimeu64_t time;\n\n\ttime = rtc_tm_to_time64(tm);\n\n\tsec = readl(rtc->rtc_base + FTRTC010_RTC_SECOND);\n\tmin = readl(rtc->rtc_base + FTRTC010_RTC_MINUTE);\n\thour = readl(rtc->rtc_base + FTRTC010_RTC_HOUR);\n\tday = readl(rtc->rtc_base + FTRTC010_RTC_DAYS);\n\n\toffset = time - (day * 86400 + hour * 3600 + min * 60 + sec);\n\n\twritel(offset, rtc->rtc_base + FTRTC010_RTC_RECORD);\n\twritel(0x01, rtc->rtc_base + FTRTC010_RTC_CR);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ftrtc010_rtc_ops = {\n\t.read_time     = ftrtc010_rtc_read_time,\n\t.set_time      = ftrtc010_rtc_set_time,\n};\n\nstatic int ftrtc010_rtc_probe(struct platform_device *pdev)\n{\n\tu32 days, hour, min, sec;\n\tstruct ftrtc010_rtc *rtc;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (unlikely(!rtc))\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->pclk = devm_clk_get(dev, \"PCLK\");\n\tif (IS_ERR(rtc->pclk)) {\n\t\tdev_err(dev, \"could not get PCLK\\n\");\n\t} else {\n\t\tret = clk_prepare_enable(rtc->pclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable PCLK\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\trtc->extclk = devm_clk_get(dev, \"EXTCLK\");\n\tif (IS_ERR(rtc->extclk)) {\n\t\tdev_err(dev, \"could not get EXTCLK\\n\");\n\t} else {\n\t\tret = clk_prepare_enable(rtc->extclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable EXTCLK\\n\");\n\t\t\tgoto err_disable_pclk;\n\t\t}\n\t}\n\n\trtc->rtc_irq = platform_get_irq(pdev, 0);\n\tif (rtc->rtc_irq < 0) {\n\t\tret = rtc->rtc_irq;\n\t\tgoto err_disable_extclk;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto err_disable_extclk;\n\t}\n\n\trtc->rtc_base = devm_ioremap(dev, res->start,\n\t\t\t\t     resource_size(res));\n\tif (!rtc->rtc_base) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_extclk;\n\t}\n\n\trtc->rtc_dev = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc->rtc_dev)) {\n\t\tret = PTR_ERR(rtc->rtc_dev);\n\t\tgoto err_disable_extclk;\n\t}\n\n\trtc->rtc_dev->ops = &ftrtc010_rtc_ops;\n\n\tsec  = readl(rtc->rtc_base + FTRTC010_RTC_SECOND);\n\tmin  = readl(rtc->rtc_base + FTRTC010_RTC_MINUTE);\n\thour = readl(rtc->rtc_base + FTRTC010_RTC_HOUR);\n\tdays = readl(rtc->rtc_base + FTRTC010_RTC_DAYS);\n\n\trtc->rtc_dev->range_min = (u64)days * 86400 + hour * 3600 +\n\t\t\t\t  min * 60 + sec;\n\trtc->rtc_dev->range_max = U32_MAX + rtc->rtc_dev->range_min;\n\n\tret = devm_request_irq(dev, rtc->rtc_irq, ftrtc010_rtc_interrupt,\n\t\t\t       IRQF_SHARED, pdev->name, dev);\n\tif (unlikely(ret))\n\t\tgoto err_disable_extclk;\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n\nerr_disable_extclk:\n\tclk_disable_unprepare(rtc->extclk);\nerr_disable_pclk:\n\tclk_disable_unprepare(rtc->pclk);\n\treturn ret;\n}\n\nstatic void ftrtc010_rtc_remove(struct platform_device *pdev)\n{\n\tstruct ftrtc010_rtc *rtc = platform_get_drvdata(pdev);\n\n\tif (!IS_ERR(rtc->extclk))\n\t\tclk_disable_unprepare(rtc->extclk);\n\tif (!IS_ERR(rtc->pclk))\n\t\tclk_disable_unprepare(rtc->pclk);\n}\n\nstatic const struct of_device_id ftrtc010_rtc_dt_match[] = {\n\t{ .compatible = \"cortina,gemini-rtc\" },\n\t{ .compatible = \"faraday,ftrtc010\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ftrtc010_rtc_dt_match);\n\nstatic struct platform_driver ftrtc010_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = ftrtc010_rtc_dt_match,\n\t},\n\t.probe\t\t= ftrtc010_rtc_probe,\n\t.remove_new\t= ftrtc010_rtc_remove,\n};\n\nmodule_platform_driver_probe(ftrtc010_rtc_driver, ftrtc010_rtc_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}