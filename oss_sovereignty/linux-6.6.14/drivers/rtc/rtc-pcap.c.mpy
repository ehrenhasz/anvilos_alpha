{
  "module_name": "rtc-pcap.c",
  "hash_id": "b93f9c7dbb1dfadfbfa067f34131bdb0a1046de1250bbaf608ce4af948f56d39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcap.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mfd/ezx-pcap.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n\nstruct pcap_rtc {\n\tstruct pcap_chip *pcap;\n\tstruct rtc_device *rtc;\n};\n\nstatic irqreturn_t pcap_rtc_irq(int irq, void *_pcap_rtc)\n{\n\tstruct pcap_rtc *pcap_rtc = _pcap_rtc;\n\tunsigned long rtc_events;\n\n\tif (irq == pcap_to_irq(pcap_rtc->pcap, PCAP_IRQ_1HZ))\n\t\trtc_events = RTC_IRQF | RTC_UF;\n\telse if (irq == pcap_to_irq(pcap_rtc->pcap, PCAP_IRQ_TODA))\n\t\trtc_events = RTC_IRQF | RTC_AF;\n\telse\n\t\trtc_events = 0;\n\n\trtc_update_irq(pcap_rtc->rtc, 1, rtc_events);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcap_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcap_rtc *pcap_rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned long secs;\n\tu32 tod;\t \n\tu32 days;\t \n\n\tezx_pcap_read(pcap_rtc->pcap, PCAP_REG_RTC_TODA, &tod);\n\tsecs = tod & PCAP_RTC_TOD_MASK;\n\n\tezx_pcap_read(pcap_rtc->pcap, PCAP_REG_RTC_DAYA, &days);\n\tsecs += (days & PCAP_RTC_DAY_MASK) * SEC_PER_DAY;\n\n\trtc_time64_to_tm(secs, tm);\n\n\treturn 0;\n}\n\nstatic int pcap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcap_rtc *pcap_rtc = dev_get_drvdata(dev);\n\tunsigned long secs = rtc_tm_to_time64(&alrm->time);\n\tu32 tod, days;\n\n\ttod = secs % SEC_PER_DAY;\n\tezx_pcap_write(pcap_rtc->pcap, PCAP_REG_RTC_TODA, tod);\n\n\tdays = secs / SEC_PER_DAY;\n\tezx_pcap_write(pcap_rtc->pcap, PCAP_REG_RTC_DAYA, days);\n\n\treturn 0;\n}\n\nstatic int pcap_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcap_rtc *pcap_rtc = dev_get_drvdata(dev);\n\tunsigned long secs;\n\tu32 tod, days;\n\n\tezx_pcap_read(pcap_rtc->pcap, PCAP_REG_RTC_TOD, &tod);\n\tsecs = tod & PCAP_RTC_TOD_MASK;\n\n\tezx_pcap_read(pcap_rtc->pcap, PCAP_REG_RTC_DAY, &days);\n\tsecs += (days & PCAP_RTC_DAY_MASK) * SEC_PER_DAY;\n\n\trtc_time64_to_tm(secs, tm);\n\n\treturn 0;\n}\n\nstatic int pcap_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcap_rtc *pcap_rtc = dev_get_drvdata(dev);\n\tunsigned long secs = rtc_tm_to_time64(tm);\n\tu32 tod, days;\n\n\ttod = secs % SEC_PER_DAY;\n\tezx_pcap_write(pcap_rtc->pcap, PCAP_REG_RTC_TOD, tod);\n\n\tdays = secs / SEC_PER_DAY;\n\tezx_pcap_write(pcap_rtc->pcap, PCAP_REG_RTC_DAY, days);\n\n\treturn 0;\n}\n\nstatic int pcap_rtc_irq_enable(struct device *dev, int pirq, unsigned int en)\n{\n\tstruct pcap_rtc *pcap_rtc = dev_get_drvdata(dev);\n\n\tif (en)\n\t\tenable_irq(pcap_to_irq(pcap_rtc->pcap, pirq));\n\telse\n\t\tdisable_irq(pcap_to_irq(pcap_rtc->pcap, pirq));\n\n\treturn 0;\n}\n\nstatic int pcap_rtc_alarm_irq_enable(struct device *dev, unsigned int en)\n{\n\treturn pcap_rtc_irq_enable(dev, PCAP_IRQ_TODA, en);\n}\n\nstatic const struct rtc_class_ops pcap_rtc_ops = {\n\t.read_time = pcap_rtc_read_time,\n\t.set_time = pcap_rtc_set_time,\n\t.read_alarm = pcap_rtc_read_alarm,\n\t.set_alarm = pcap_rtc_set_alarm,\n\t.alarm_irq_enable = pcap_rtc_alarm_irq_enable,\n};\n\nstatic int __init pcap_rtc_probe(struct platform_device *pdev)\n{\n\tstruct pcap_rtc *pcap_rtc;\n\tint timer_irq, alarm_irq;\n\tint err = -ENOMEM;\n\n\tpcap_rtc = devm_kzalloc(&pdev->dev, sizeof(struct pcap_rtc),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcap_rtc)\n\t\treturn err;\n\n\tpcap_rtc->pcap = dev_get_drvdata(pdev->dev.parent);\n\n\tplatform_set_drvdata(pdev, pcap_rtc);\n\n\tpcap_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pcap_rtc->rtc))\n\t\treturn PTR_ERR(pcap_rtc->rtc);\n\n\tpcap_rtc->rtc->ops = &pcap_rtc_ops;\n\tpcap_rtc->rtc->range_max = (1 << 14) * 86400ULL - 1;\n\n\ttimer_irq = pcap_to_irq(pcap_rtc->pcap, PCAP_IRQ_1HZ);\n\talarm_irq = pcap_to_irq(pcap_rtc->pcap, PCAP_IRQ_TODA);\n\n\terr = devm_request_irq(&pdev->dev, timer_irq, pcap_rtc_irq, 0,\n\t\t\t\t\"RTC Timer\", pcap_rtc);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_irq(&pdev->dev, alarm_irq, pcap_rtc_irq, 0,\n\t\t\t\t\"RTC Alarm\", pcap_rtc);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_rtc_register_device(pcap_rtc->rtc);\n}\n\nstatic int __exit pcap_rtc_remove(struct platform_device *pdev)\n{\n\treturn 0;\n}\n\nstatic struct platform_driver pcap_rtc_driver = {\n\t.remove = __exit_p(pcap_rtc_remove),\n\t.driver = {\n\t\t.name  = \"pcap-rtc\",\n\t},\n};\n\nmodule_platform_driver_probe(pcap_rtc_driver, pcap_rtc_probe);\n\nMODULE_DESCRIPTION(\"Motorola pcap rtc driver\");\nMODULE_AUTHOR(\"guiming zhuo <gmzhuo@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}