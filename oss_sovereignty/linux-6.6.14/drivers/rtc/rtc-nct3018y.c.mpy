{
  "module_name": "rtc-nct3018y.c",
  "hash_id": "09d1afc447cc7c512838bd352a2057c8d9f1e78373cca14ecef857c5d4e0699d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-nct3018y.c",
  "human_readable_source": "\n\n\n#include <linux/bcd.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#define NCT3018Y_REG_SC\t\t0x00  \n#define NCT3018Y_REG_SCA\t0x01  \n#define NCT3018Y_REG_MN\t\t0x02\n#define NCT3018Y_REG_MNA\t0x03  \n#define NCT3018Y_REG_HR\t\t0x04\n#define NCT3018Y_REG_HRA\t0x05  \n#define NCT3018Y_REG_DW\t\t0x06\n#define NCT3018Y_REG_DM\t\t0x07\n#define NCT3018Y_REG_MO\t\t0x08\n#define NCT3018Y_REG_YR\t\t0x09\n#define NCT3018Y_REG_CTRL\t0x0A  \n#define NCT3018Y_REG_ST\t\t0x0B  \n#define NCT3018Y_REG_CLKO\t0x0C  \n\n#define NCT3018Y_BIT_AF\t\tBIT(7)\n#define NCT3018Y_BIT_ST\t\tBIT(7)\n#define NCT3018Y_BIT_DM\t\tBIT(6)\n#define NCT3018Y_BIT_HF\t\tBIT(5)\n#define NCT3018Y_BIT_DSM\tBIT(4)\n#define NCT3018Y_BIT_AIE\tBIT(3)\n#define NCT3018Y_BIT_OFIE\tBIT(2)\n#define NCT3018Y_BIT_CIE\tBIT(1)\n#define NCT3018Y_BIT_TWO\tBIT(0)\n\n#define NCT3018Y_REG_BAT_MASK\t\t0x07\n#define NCT3018Y_REG_CLKO_F_MASK\t0x03  \n#define NCT3018Y_REG_CLKO_CKE\t\t0x80  \n\nstruct nct3018y {\n\tstruct rtc_device *rtc;\n\tstruct i2c_client *client;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw clkout_hw;\n#endif\n};\n\nstatic int nct3018y_set_alarm_mode(struct i2c_client *client, bool on)\n{\n\tint err, flags;\n\n\tdev_dbg(&client->dev, \"%s:on:%d\\n\", __func__, on);\n\n\tflags =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_CTRL);\n\tif (flags < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Failed to read NCT3018Y_REG_CTRL\\n\");\n\t\treturn flags;\n\t}\n\n\tif (on)\n\t\tflags |= NCT3018Y_BIT_AIE;\n\telse\n\t\tflags &= ~NCT3018Y_BIT_AIE;\n\n\tflags |= NCT3018Y_BIT_CIE;\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_CTRL, flags);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_CTRL\\n\");\n\t\treturn err;\n\t}\n\n\tflags =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_ST);\n\tif (flags < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Failed to read NCT3018Y_REG_ST\\n\");\n\t\treturn flags;\n\t}\n\n\tflags &= ~(NCT3018Y_BIT_AF);\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_ST, flags);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_ST\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nct3018y_get_alarm_mode(struct i2c_client *client, unsigned char *alarm_enable,\n\t\t\t\t   unsigned char *alarm_flag)\n{\n\tint flags;\n\n\tif (alarm_enable) {\n\t\tdev_dbg(&client->dev, \"%s:NCT3018Y_REG_CTRL\\n\", __func__);\n\t\tflags =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_CTRL);\n\t\tif (flags < 0)\n\t\t\treturn flags;\n\t\t*alarm_enable = flags & NCT3018Y_BIT_AIE;\n\t}\n\n\tif (alarm_flag) {\n\t\tdev_dbg(&client->dev, \"%s:NCT3018Y_REG_ST\\n\", __func__);\n\t\tflags =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_ST);\n\t\tif (flags < 0)\n\t\t\treturn flags;\n\t\t*alarm_flag = flags & NCT3018Y_BIT_AF;\n\t}\n\n\tdev_dbg(&client->dev, \"%s:alarm_enable:%x alarm_flag:%x\\n\",\n\t\t__func__, *alarm_enable, *alarm_flag);\n\n\treturn 0;\n}\n\nstatic irqreturn_t nct3018y_irq(int irq, void *dev_id)\n{\n\tstruct nct3018y *nct3018y = i2c_get_clientdata(dev_id);\n\tstruct i2c_client *client = nct3018y->client;\n\tint err;\n\tunsigned char alarm_flag;\n\tunsigned char alarm_enable;\n\n\tdev_dbg(&client->dev, \"%s:irq:%d\\n\", __func__, irq);\n\terr = nct3018y_get_alarm_mode(nct3018y->client, &alarm_enable, &alarm_flag);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (alarm_flag) {\n\t\tdev_dbg(&client->dev, \"%s:alarm flag:%x\\n\",\n\t\t\t__func__, alarm_flag);\n\t\trtc_update_irq(nct3018y->rtc, 1, RTC_IRQF | RTC_AF);\n\t\tnct3018y_set_alarm_mode(nct3018y->client, 0);\n\t\tdev_dbg(&client->dev, \"%s:IRQ_HANDLED\\n\", __func__);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int nct3018y_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[10];\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(client, NCT3018Y_REG_ST, 1, buf);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!buf[0]) {\n\t\tdev_dbg(&client->dev, \" voltage <=1.7, date/time is not reliable.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = i2c_smbus_read_i2c_block_data(client, NCT3018Y_REG_SC, sizeof(buf), buf);\n\tif (err < 0)\n\t\treturn err;\n\n\ttm->tm_sec = bcd2bin(buf[0] & 0x7F);\n\ttm->tm_min = bcd2bin(buf[2] & 0x7F);\n\ttm->tm_hour = bcd2bin(buf[4] & 0x3F);\n\ttm->tm_wday = buf[6] & 0x07;\n\ttm->tm_mday = bcd2bin(buf[7] & 0x3F);\n\ttm->tm_mon = bcd2bin(buf[8] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(buf[9]) + 100;\n\n\treturn 0;\n}\n\nstatic int nct3018y_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[4] = {0};\n\tint err;\n\n\tbuf[0] = bin2bcd(tm->tm_sec);\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_SC, buf[0]);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_SC\\n\");\n\t\treturn err;\n\t}\n\n\tbuf[0] = bin2bcd(tm->tm_min);\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_MN, buf[0]);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_MN\\n\");\n\t\treturn err;\n\t}\n\n\tbuf[0] = bin2bcd(tm->tm_hour);\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_HR, buf[0]);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_HR\\n\");\n\t\treturn err;\n\t}\n\n\tbuf[0] = tm->tm_wday & 0x07;\n\tbuf[1] = bin2bcd(tm->tm_mday);\n\tbuf[2] = bin2bcd(tm->tm_mon + 1);\n\tbuf[3] = bin2bcd(tm->tm_year - 100);\n\terr = i2c_smbus_write_i2c_block_data(client, NCT3018Y_REG_DW,\n\t\t\t\t\t     sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write for day and mon and year\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn err;\n}\n\nstatic int nct3018y_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[5];\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(client, NCT3018Y_REG_SCA,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to read date\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev, \"%s: raw data is sec=%02x, min=%02x hr=%02x\\n\",\n\t\t__func__, buf[0], buf[2], buf[4]);\n\n\ttm->time.tm_sec = bcd2bin(buf[0] & 0x7F);\n\ttm->time.tm_min = bcd2bin(buf[2] & 0x7F);\n\ttm->time.tm_hour = bcd2bin(buf[4] & 0x3F);\n\n\terr = nct3018y_get_alarm_mode(client, &tm->enabled, &tm->pending);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(&client->dev, \"%s:s=%d m=%d, hr=%d, enabled=%d, pending=%d\\n\",\n\t\t__func__, tm->time.tm_sec, tm->time.tm_min,\n\t\ttm->time.tm_hour, tm->enabled, tm->pending);\n\n\treturn 0;\n}\n\nstatic int nct3018y_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint err;\n\n\tdev_dbg(dev, \"%s, sec=%d, min=%d hour=%d tm->enabled:%d\\n\",\n\t\t__func__, tm->time.tm_sec, tm->time.tm_min, tm->time.tm_hour,\n\t\ttm->enabled);\n\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_SCA, bin2bcd(tm->time.tm_sec));\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_SCA\\n\");\n\t\treturn err;\n\t}\n\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_MNA, bin2bcd(tm->time.tm_min));\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_MNA\\n\");\n\t\treturn err;\n\t}\n\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_HRA, bin2bcd(tm->time.tm_hour));\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_HRA\\n\");\n\t\treturn err;\n\t}\n\n\treturn nct3018y_set_alarm_mode(client, tm->enabled);\n}\n\nstatic int nct3018y_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tdev_dbg(dev, \"%s: alarm enable=%d\\n\", __func__, enabled);\n\n\treturn nct3018y_set_alarm_mode(to_i2c_client(dev), enabled);\n}\n\nstatic int nct3018y_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint status, flags = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tstatus = i2c_smbus_read_byte_data(client, NCT3018Y_REG_ST);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (!(status & NCT3018Y_REG_BAT_MASK))\n\t\t\tflags |= RTC_VL_DATA_INVALID;\n\n\t\treturn put_user(flags, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMMON_CLK\n \n\n#define clkout_hw_to_nct3018y(_hw) container_of(_hw, struct nct3018y, clkout_hw)\n\nstatic const int clkout_rates[] = {\n\t32768,\n\t1024,\n\t32,\n\t1,\n};\n\nstatic unsigned long nct3018y_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct nct3018y *nct3018y = clkout_hw_to_nct3018y(hw);\n\tstruct i2c_client *client = nct3018y->client;\n\tint flags;\n\n\tflags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CLKO);\n\tif (flags < 0)\n\t\treturn 0;\n\n\tflags &= NCT3018Y_REG_CLKO_F_MASK;\n\treturn clkout_rates[flags];\n}\n\nstatic long nct3018y_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] <= rate)\n\t\t\treturn clkout_rates[i];\n\n\treturn 0;\n}\n\nstatic int nct3018y_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct nct3018y *nct3018y = clkout_hw_to_nct3018y(hw);\n\tstruct i2c_client *client = nct3018y->client;\n\tint i, flags;\n\n\tflags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CLKO);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] == rate) {\n\t\t\tflags &= ~NCT3018Y_REG_CLKO_F_MASK;\n\t\t\tflags |= i;\n\t\t\treturn i2c_smbus_write_byte_data(client, NCT3018Y_REG_CLKO, flags);\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nct3018y_clkout_control(struct clk_hw *hw, bool enable)\n{\n\tstruct nct3018y *nct3018y = clkout_hw_to_nct3018y(hw);\n\tstruct i2c_client *client = nct3018y->client;\n\tint flags;\n\n\tflags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CLKO);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (enable)\n\t\tflags |= NCT3018Y_REG_CLKO_CKE;\n\telse\n\t\tflags &= ~NCT3018Y_REG_CLKO_CKE;\n\n\treturn i2c_smbus_write_byte_data(client, NCT3018Y_REG_CLKO, flags);\n}\n\nstatic int nct3018y_clkout_prepare(struct clk_hw *hw)\n{\n\treturn nct3018y_clkout_control(hw, 1);\n}\n\nstatic void nct3018y_clkout_unprepare(struct clk_hw *hw)\n{\n\tnct3018y_clkout_control(hw, 0);\n}\n\nstatic int nct3018y_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct nct3018y *nct3018y = clkout_hw_to_nct3018y(hw);\n\tstruct i2c_client *client = nct3018y->client;\n\tint flags;\n\n\tflags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CLKO);\n\tif (flags < 0)\n\t\treturn flags;\n\n\treturn flags & NCT3018Y_REG_CLKO_CKE;\n}\n\nstatic const struct clk_ops nct3018y_clkout_ops = {\n\t.prepare = nct3018y_clkout_prepare,\n\t.unprepare = nct3018y_clkout_unprepare,\n\t.is_prepared = nct3018y_clkout_is_prepared,\n\t.recalc_rate = nct3018y_clkout_recalc_rate,\n\t.round_rate = nct3018y_clkout_round_rate,\n\t.set_rate = nct3018y_clkout_set_rate,\n};\n\nstatic struct clk *nct3018y_clkout_register_clk(struct nct3018y *nct3018y)\n{\n\tstruct i2c_client *client = nct3018y->client;\n\tstruct device_node *node = client->dev.of_node;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\n\tinit.name = \"nct3018y-clkout\";\n\tinit.ops = &nct3018y_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tnct3018y->clkout_hw.init = &init;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = devm_clk_register(&client->dev, &nct3018y->clkout_hw);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#endif\n\nstatic const struct rtc_class_ops nct3018y_rtc_ops = {\n\t.read_time\t= nct3018y_rtc_read_time,\n\t.set_time\t= nct3018y_rtc_set_time,\n\t.read_alarm\t= nct3018y_rtc_read_alarm,\n\t.set_alarm\t= nct3018y_rtc_set_alarm,\n\t.alarm_irq_enable = nct3018y_irq_enable,\n\t.ioctl\t\t= nct3018y_ioctl,\n};\n\nstatic int nct3018y_probe(struct i2c_client *client)\n{\n\tstruct nct3018y *nct3018y;\n\tint err, flags;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tnct3018y = devm_kzalloc(&client->dev, sizeof(struct nct3018y),\n\t\t\t\tGFP_KERNEL);\n\tif (!nct3018y)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, nct3018y);\n\tnct3018y->client = client;\n\tdevice_set_wakeup_capable(&client->dev, 1);\n\n\tflags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CTRL);\n\tif (flags < 0) {\n\t\tdev_dbg(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn flags;\n\t} else if (flags & NCT3018Y_BIT_TWO) {\n\t\tdev_dbg(&client->dev, \"%s: NCT3018Y_BIT_TWO is set\\n\", __func__);\n\t}\n\n\tflags = NCT3018Y_BIT_TWO;\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_CTRL, flags);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"Unable to write NCT3018Y_REG_CTRL\\n\");\n\t\treturn err;\n\t}\n\n\tflags = 0;\n\terr = i2c_smbus_write_byte_data(client, NCT3018Y_REG_ST, flags);\n\tif (err < 0) {\n\t\tdev_dbg(&client->dev, \"%s: write error\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tnct3018y->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(nct3018y->rtc))\n\t\treturn PTR_ERR(nct3018y->rtc);\n\n\tnct3018y->rtc->ops = &nct3018y_rtc_ops;\n\tnct3018y->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tnct3018y->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tif (client->irq > 0) {\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, nct3018y_irq,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_FALLING,\n\t\t\t\t\t\t\"nct3018y\", client);\n\t\tif (err) {\n\t\t\tdev_dbg(&client->dev, \"unable to request IRQ %d\\n\", client->irq);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, nct3018y->rtc->features);\n\t\tclear_bit(RTC_FEATURE_ALARM, nct3018y->rtc->features);\n\t}\n\n#ifdef CONFIG_COMMON_CLK\n\t \n\tnct3018y_clkout_register_clk(nct3018y);\n#endif\n\n\treturn devm_rtc_register_device(nct3018y->rtc);\n}\n\nstatic const struct i2c_device_id nct3018y_id[] = {\n\t{ \"nct3018y\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nct3018y_id);\n\nstatic const struct of_device_id nct3018y_of_match[] = {\n\t{ .compatible = \"nuvoton,nct3018y\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nct3018y_of_match);\n\nstatic struct i2c_driver nct3018y_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-nct3018y\",\n\t\t.of_match_table = nct3018y_of_match,\n\t},\n\t.probe\t\t= nct3018y_probe,\n\t.id_table\t= nct3018y_id,\n};\n\nmodule_i2c_driver(nct3018y_driver);\n\nMODULE_AUTHOR(\"Medad CChien <ctcchien@nuvoton.com>\");\nMODULE_AUTHOR(\"Mia Lin <mimi05633@gmail.com>\");\nMODULE_DESCRIPTION(\"Nuvoton NCT3018Y RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}