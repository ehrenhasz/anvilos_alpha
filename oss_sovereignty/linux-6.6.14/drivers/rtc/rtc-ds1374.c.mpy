{
  "module_name": "rtc-ds1374.c",
  "hash_id": "f91b96a61d69f4961422e56bd4cd12e04c43b140c0052afcea73664dedd7cf20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1374.c",
  "human_readable_source": "\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#ifdef CONFIG_RTC_DRV_DS1374_WDT\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/miscdevice.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n#endif\n\n#define DS1374_REG_TOD0\t\t0x00  \n#define DS1374_REG_TOD1\t\t0x01\n#define DS1374_REG_TOD2\t\t0x02\n#define DS1374_REG_TOD3\t\t0x03\n#define DS1374_REG_WDALM0\t0x04  \n#define DS1374_REG_WDALM1\t0x05\n#define DS1374_REG_WDALM2\t0x06\n#define DS1374_REG_CR\t\t0x07  \n#define DS1374_REG_CR_AIE\t0x01  \n#define DS1374_REG_CR_WDSTR\t0x08  \n#define DS1374_REG_CR_WDALM\t0x20  \n#define DS1374_REG_CR_WACE\t0x40  \n#define DS1374_REG_SR\t\t0x08  \n#define DS1374_REG_SR_OSF\t0x80  \n#define DS1374_REG_SR_AF\t0x01  \n#define DS1374_REG_TCR\t\t0x09  \n\nstatic const struct i2c_device_id ds1374_id[] = {\n\t{ \"ds1374\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds1374_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ds1374_of_match[] = {\n\t{ .compatible = \"dallas,ds1374\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ds1374_of_match);\n#endif\n\nstruct ds1374 {\n\tstruct i2c_client *client;\n\tstruct rtc_device *rtc;\n\tstruct work_struct work;\n#ifdef CONFIG_RTC_DRV_DS1374_WDT\n\tstruct watchdog_device wdt;\n#endif\n\t \n\tstruct mutex mutex;\n\tint exiting;\n};\n\nstatic struct i2c_driver ds1374_driver;\n\nstatic int ds1374_read_rtc(struct i2c_client *client, u32 *time,\n\t\t\t   int reg, int nbytes)\n{\n\tu8 buf[4];\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(nbytes > 4))\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, nbytes, buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < nbytes)\n\t\treturn -EIO;\n\n\tfor (i = nbytes - 1, *time = 0; i >= 0; i--)\n\t\t*time = (*time << 8) | buf[i];\n\n\treturn 0;\n}\n\nstatic int ds1374_write_rtc(struct i2c_client *client, u32 time,\n\t\t\t    int reg, int nbytes)\n{\n\tu8 buf[4];\n\tint i;\n\n\tif (nbytes > 4) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nbytes; i++) {\n\t\tbuf[i] = time & 0xff;\n\t\ttime >>= 8;\n\t}\n\n\treturn i2c_smbus_write_i2c_block_data(client, reg, nbytes, buf);\n}\n\nstatic int ds1374_check_rtc_status(struct i2c_client *client)\n{\n\tint ret = 0;\n\tint control, stat;\n\n\tstat = i2c_smbus_read_byte_data(client, DS1374_REG_SR);\n\tif (stat < 0)\n\t\treturn stat;\n\n\tif (stat & DS1374_REG_SR_OSF)\n\t\tdev_warn(&client->dev,\n\t\t\t \"oscillator discontinuity flagged, time unreliable\\n\");\n\n\tstat &= ~(DS1374_REG_SR_OSF | DS1374_REG_SR_AF);\n\n\tret = i2c_smbus_write_byte_data(client, DS1374_REG_SR, stat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tcontrol = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (control < 0)\n\t\treturn control;\n\n\tcontrol &= ~(DS1374_REG_CR_WACE | DS1374_REG_CR_AIE);\n\treturn i2c_smbus_write_byte_data(client, DS1374_REG_CR, control);\n}\n\nstatic int ds1374_read_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu32 itime;\n\tint ret;\n\n\tret = ds1374_read_rtc(client, &itime, DS1374_REG_TOD0, 4);\n\tif (!ret)\n\t\trtc_time64_to_tm(itime, time);\n\n\treturn ret;\n}\n\nstatic int ds1374_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long itime = rtc_tm_to_time64(time);\n\n\treturn ds1374_write_rtc(client, itime, DS1374_REG_TOD0, 4);\n}\n\n#ifndef CONFIG_RTC_DRV_DS1374_WDT\n \nstatic int ds1374_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ds1374 *ds1374 = i2c_get_clientdata(client);\n\tu32 now, cur_alarm;\n\tint cr, sr;\n\tint ret = 0;\n\n\tif (client->irq <= 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ds1374->mutex);\n\n\tcr = ret = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsr = ret = i2c_smbus_read_byte_data(client, DS1374_REG_SR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = ds1374_read_rtc(client, &now, DS1374_REG_TOD0, 4);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ds1374_read_rtc(client, &cur_alarm, DS1374_REG_WDALM0, 3);\n\tif (ret)\n\t\tgoto out;\n\n\trtc_time64_to_tm(now + cur_alarm, &alarm->time);\n\talarm->enabled = !!(cr & DS1374_REG_CR_WACE);\n\talarm->pending = !!(sr & DS1374_REG_SR_AF);\n\nout:\n\tmutex_unlock(&ds1374->mutex);\n\treturn ret;\n}\n\nstatic int ds1374_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ds1374 *ds1374 = i2c_get_clientdata(client);\n\tstruct rtc_time now;\n\tunsigned long new_alarm, itime;\n\tint cr;\n\tint ret = 0;\n\n\tif (client->irq <= 0)\n\t\treturn -EINVAL;\n\n\tret = ds1374_read_time(dev, &now);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew_alarm = rtc_tm_to_time64(&alarm->time);\n\titime = rtc_tm_to_time64(&now);\n\n\t \n\tif (time_before_eq(new_alarm, itime))\n\t\tnew_alarm = 1;\n\telse\n\t\tnew_alarm -= itime;\n\n\tmutex_lock(&ds1374->mutex);\n\n\tret = cr = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tcr &= ~DS1374_REG_CR_WACE;\n\n\tret = i2c_smbus_write_byte_data(client, DS1374_REG_CR, cr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = ds1374_write_rtc(client, new_alarm, DS1374_REG_WDALM0, 3);\n\tif (ret)\n\t\tgoto out;\n\n\tif (alarm->enabled) {\n\t\tcr |= DS1374_REG_CR_WACE | DS1374_REG_CR_AIE;\n\t\tcr &= ~DS1374_REG_CR_WDALM;\n\n\t\tret = i2c_smbus_write_byte_data(client, DS1374_REG_CR, cr);\n\t}\n\nout:\n\tmutex_unlock(&ds1374->mutex);\n\treturn ret;\n}\n#endif\n\nstatic irqreturn_t ds1374_irq(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct ds1374 *ds1374 = i2c_get_clientdata(client);\n\n\tdisable_irq_nosync(irq);\n\tschedule_work(&ds1374->work);\n\treturn IRQ_HANDLED;\n}\n\nstatic void ds1374_work(struct work_struct *work)\n{\n\tstruct ds1374 *ds1374 = container_of(work, struct ds1374, work);\n\tstruct i2c_client *client = ds1374->client;\n\tint stat, control;\n\n\tmutex_lock(&ds1374->mutex);\n\n\tstat = i2c_smbus_read_byte_data(client, DS1374_REG_SR);\n\tif (stat < 0)\n\t\tgoto unlock;\n\n\tif (stat & DS1374_REG_SR_AF) {\n\t\tstat &= ~DS1374_REG_SR_AF;\n\t\ti2c_smbus_write_byte_data(client, DS1374_REG_SR, stat);\n\n\t\tcontrol = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\t\tif (control < 0)\n\t\t\tgoto out;\n\n\t\tcontrol &= ~(DS1374_REG_CR_WACE | DS1374_REG_CR_AIE);\n\t\ti2c_smbus_write_byte_data(client, DS1374_REG_CR, control);\n\n\t\trtc_update_irq(ds1374->rtc, 1, RTC_AF | RTC_IRQF);\n\t}\n\nout:\n\tif (!ds1374->exiting)\n\t\tenable_irq(client->irq);\nunlock:\n\tmutex_unlock(&ds1374->mutex);\n}\n\n#ifndef CONFIG_RTC_DRV_DS1374_WDT\nstatic int ds1374_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ds1374 *ds1374 = i2c_get_clientdata(client);\n\tint ret;\n\n\tmutex_lock(&ds1374->mutex);\n\n\tret = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (enabled) {\n\t\tret |= DS1374_REG_CR_WACE | DS1374_REG_CR_AIE;\n\t\tret &= ~DS1374_REG_CR_WDALM;\n\t} else {\n\t\tret &= ~DS1374_REG_CR_WACE;\n\t}\n\tret = i2c_smbus_write_byte_data(client, DS1374_REG_CR, ret);\n\nout:\n\tmutex_unlock(&ds1374->mutex);\n\treturn ret;\n}\n#endif\n\nstatic const struct rtc_class_ops ds1374_rtc_ops = {\n\t.read_time = ds1374_read_time,\n\t.set_time = ds1374_set_time,\n#ifndef CONFIG_RTC_DRV_DS1374_WDT\n\t.read_alarm = ds1374_read_alarm,\n\t.set_alarm = ds1374_set_alarm,\n\t.alarm_irq_enable = ds1374_alarm_irq_enable,\n#endif\n};\n\n#ifdef CONFIG_RTC_DRV_DS1374_WDT\n \n \n#define TIMER_MARGIN_DEFAULT\t32\n#define TIMER_MARGIN_MIN\t1\n#define TIMER_MARGIN_MAX\t4095  \n\nstatic int wdt_margin;\nmodule_param(wdt_margin, int, 0);\nMODULE_PARM_DESC(wdt_margin, \"Watchdog timeout in seconds (default 32s)\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default =\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT)\")\");\n\nstatic const struct watchdog_info ds1374_wdt_info = {\n\t.identity       = \"DS1374 Watchdog\",\n\t.options        = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\t\t\tWDIOF_MAGICCLOSE,\n};\n\nstatic int ds1374_wdt_settimeout(struct watchdog_device *wdt, unsigned int timeout)\n{\n\tstruct ds1374 *ds1374 = watchdog_get_drvdata(wdt);\n\tstruct i2c_client *client = ds1374->client;\n\tint ret, cr;\n\n\twdt->timeout = timeout;\n\n\tcr = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (cr < 0)\n\t\treturn cr;\n\n\t \n\tcr &= ~DS1374_REG_CR_WACE;\n\n\tret = i2c_smbus_write_byte_data(client, DS1374_REG_CR, cr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttimeout = timeout * 4096;\n\tret = ds1374_write_rtc(client, timeout, DS1374_REG_WDALM0, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcr |= DS1374_REG_CR_WACE | DS1374_REG_CR_WDALM;\n\tcr &= ~DS1374_REG_CR_WDSTR; \n\tcr &= ~DS1374_REG_CR_AIE;\n\n\tret = i2c_smbus_write_byte_data(client, DS1374_REG_CR, cr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int ds1374_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct ds1374 *ds1374 = watchdog_get_drvdata(wdt);\n\tu32 val;\n\n\treturn ds1374_read_rtc(ds1374->client, &val, DS1374_REG_WDALM0, 3);\n}\n\nstatic int ds1374_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct ds1374 *ds1374 = watchdog_get_drvdata(wdt);\n\tstruct i2c_client *client = ds1374->client;\n\tint cr;\n\n\tcr = i2c_smbus_read_byte_data(client, DS1374_REG_CR);\n\tif (cr < 0)\n\t\treturn cr;\n\n\t \n\tcr &= ~DS1374_REG_CR_WACE;\n\n\treturn i2c_smbus_write_byte_data(client, DS1374_REG_CR, cr);\n}\n\nstatic const struct watchdog_ops ds1374_wdt_ops = {\n\t.owner          = THIS_MODULE,\n\t.start          = ds1374_wdt_start,\n\t.stop           = ds1374_wdt_stop,\n\t.set_timeout    = ds1374_wdt_settimeout,\n};\n#endif  \n \nstatic int ds1374_probe(struct i2c_client *client)\n{\n\tstruct ds1374 *ds1374;\n\tint ret;\n\n\tds1374 = devm_kzalloc(&client->dev, sizeof(struct ds1374), GFP_KERNEL);\n\tif (!ds1374)\n\t\treturn -ENOMEM;\n\n\tds1374->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(ds1374->rtc))\n\t\treturn PTR_ERR(ds1374->rtc);\n\n\tds1374->client = client;\n\ti2c_set_clientdata(client, ds1374);\n\n\tINIT_WORK(&ds1374->work, ds1374_work);\n\tmutex_init(&ds1374->mutex);\n\n\tret = ds1374_check_rtc_status(client);\n\tif (ret)\n\t\treturn ret;\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_irq(&client->dev, client->irq, ds1374_irq, 0,\n\t\t\t\t\t\"ds1374\", client);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"unable to request IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdevice_set_wakeup_capable(&client->dev, 1);\n\t}\n\n\tds1374->rtc->ops = &ds1374_rtc_ops;\n\tds1374->rtc->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(ds1374->rtc);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_RTC_DRV_DS1374_WDT\n\tds1374->wdt.info = &ds1374_wdt_info;\n\tds1374->wdt.ops = &ds1374_wdt_ops;\n\tds1374->wdt.timeout = TIMER_MARGIN_DEFAULT;\n\tds1374->wdt.min_timeout = TIMER_MARGIN_MIN;\n\tds1374->wdt.max_timeout = TIMER_MARGIN_MAX;\n\n\twatchdog_init_timeout(&ds1374->wdt, wdt_margin, &client->dev);\n\twatchdog_set_nowayout(&ds1374->wdt, nowayout);\n\twatchdog_stop_on_reboot(&ds1374->wdt);\n\twatchdog_stop_on_unregister(&ds1374->wdt);\n\twatchdog_set_drvdata(&ds1374->wdt, ds1374);\n\tds1374_wdt_settimeout(&ds1374->wdt, ds1374->wdt.timeout);\n\n\tret = devm_watchdog_register_device(&client->dev, &ds1374->wdt);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\n\nstatic void ds1374_remove(struct i2c_client *client)\n{\n\tstruct ds1374 *ds1374 = i2c_get_clientdata(client);\n\n\tif (client->irq > 0) {\n\t\tmutex_lock(&ds1374->mutex);\n\t\tds1374->exiting = 1;\n\t\tmutex_unlock(&ds1374->mutex);\n\n\t\tdevm_free_irq(&client->dev, client->irq, client);\n\t\tcancel_work_sync(&ds1374->work);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ds1374_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq > 0 && device_may_wakeup(&client->dev))\n\t\tenable_irq_wake(client->irq);\n\treturn 0;\n}\n\nstatic int ds1374_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq > 0 && device_may_wakeup(&client->dev))\n\t\tdisable_irq_wake(client->irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ds1374_pm, ds1374_suspend, ds1374_resume);\n\nstatic struct i2c_driver ds1374_driver = {\n\t.driver = {\n\t\t.name = \"rtc-ds1374\",\n\t\t.of_match_table = of_match_ptr(ds1374_of_match),\n\t\t.pm = &ds1374_pm,\n\t},\n\t.probe = ds1374_probe,\n\t.remove = ds1374_remove,\n\t.id_table = ds1374_id,\n};\n\nmodule_i2c_driver(ds1374_driver);\n\nMODULE_AUTHOR(\"Scott Wood <scottwood@freescale.com>\");\nMODULE_DESCRIPTION(\"Maxim/Dallas DS1374 RTC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}