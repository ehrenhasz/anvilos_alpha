{
  "module_name": "rtc-pcf85063.c",
  "hash_id": "152ab5dbf9ad41b89bf9932e479451d8dd8e74e44222bb928f3deb6316cef188",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf85063.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n\n \n\n#define PCF85063_REG_CTRL1\t\t0x00  \n#define PCF85063_REG_CTRL1_CAP_SEL\tBIT(0)\n#define PCF85063_REG_CTRL1_STOP\t\tBIT(5)\n#define PCF85063_REG_CTRL1_EXT_TEST\tBIT(7)\n\n#define PCF85063_REG_CTRL2\t\t0x01\n#define PCF85063_CTRL2_AF\t\tBIT(6)\n#define PCF85063_CTRL2_AIE\t\tBIT(7)\n\n#define PCF85063_REG_OFFSET\t\t0x02\n#define PCF85063_OFFSET_SIGN_BIT\t6\t \n#define PCF85063_OFFSET_MODE\t\tBIT(7)\n#define PCF85063_OFFSET_STEP0\t\t4340\n#define PCF85063_OFFSET_STEP1\t\t4069\n\n#define PCF85063_REG_CLKO_F_MASK\t0x07  \n#define PCF85063_REG_CLKO_F_32768HZ\t0x00\n#define PCF85063_REG_CLKO_F_OFF\t\t0x07\n\n#define PCF85063_REG_RAM\t\t0x03\n\n#define PCF85063_REG_SC\t\t\t0x04  \n#define PCF85063_REG_SC_OS\t\t0x80\n\n#define PCF85063_REG_ALM_S\t\t0x0b\n#define PCF85063_AEN\t\t\tBIT(7)\n\nstruct pcf85063_config {\n\tstruct regmap_config regmap;\n\tunsigned has_alarms:1;\n\tunsigned force_cap_7000:1;\n};\n\nstruct pcf85063 {\n\tstruct rtc_device\t*rtc;\n\tstruct regmap\t\t*regmap;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw\t\tclkout_hw;\n#endif\n};\n\nstatic int pcf85063_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tint rc;\n\tu8 regs[7];\n\n\t \n\trc = regmap_bulk_read(pcf85063->regmap, PCF85063_REG_SC, regs,\n\t\t\t      sizeof(regs));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (regs[0] & PCF85063_REG_SC_OS) {\n\t\tdev_warn(&pcf85063->rtc->dev, \"Power loss detected, invalid time\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttm->tm_sec = bcd2bin(regs[0] & 0x7F);\n\ttm->tm_min = bcd2bin(regs[1] & 0x7F);\n\ttm->tm_hour = bcd2bin(regs[2] & 0x3F);  \n\ttm->tm_mday = bcd2bin(regs[3] & 0x3F);\n\ttm->tm_wday = regs[4] & 0x07;\n\ttm->tm_mon = bcd2bin(regs[5] & 0x1F) - 1;  \n\ttm->tm_year = bcd2bin(regs[6]);\n\ttm->tm_year += 100;\n\n\treturn 0;\n}\n\nstatic int pcf85063_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tint rc;\n\tu8 regs[7];\n\n\t \n\trc = regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL1,\n\t\t\t\tPCF85063_REG_CTRL1_EXT_TEST |\n\t\t\t\tPCF85063_REG_CTRL1_STOP,\n\t\t\t\tPCF85063_REG_CTRL1_STOP);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tregs[0] = bin2bcd(tm->tm_sec) & 0x7F;  \n\n\tregs[1] = bin2bcd(tm->tm_min);\n\tregs[2] = bin2bcd(tm->tm_hour);\n\n\t \n\tregs[3] = bin2bcd(tm->tm_mday);\n\n\t \n\tregs[4] = tm->tm_wday & 0x07;\n\n\t \n\tregs[5] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tregs[6] = bin2bcd(tm->tm_year - 100);\n\n\t \n\trc = regmap_bulk_write(pcf85063->regmap, PCF85063_REG_SC,\n\t\t\t       regs, sizeof(regs));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL1,\n\t\t\t\t  PCF85063_REG_CTRL1_STOP, 0);\n}\n\nstatic int pcf85063_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tu8 buf[4];\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_bulk_read(pcf85063->regmap, PCF85063_REG_ALM_S,\n\t\t\t       buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\talrm->time.tm_sec = bcd2bin(buf[0] & 0x7f);\n\talrm->time.tm_min = bcd2bin(buf[1] & 0x7f);\n\talrm->time.tm_hour = bcd2bin(buf[2] & 0x3f);\n\talrm->time.tm_mday = bcd2bin(buf[3] & 0x3f);\n\n\tret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled =  !!(val & PCF85063_CTRL2_AIE);\n\n\treturn 0;\n}\n\nstatic int pcf85063_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tu8 buf[5];\n\tint ret;\n\n\tbuf[0] = bin2bcd(alrm->time.tm_sec);\n\tbuf[1] = bin2bcd(alrm->time.tm_min);\n\tbuf[2] = bin2bcd(alrm->time.tm_hour);\n\tbuf[3] = bin2bcd(alrm->time.tm_mday);\n\tbuf[4] = PCF85063_AEN;  \n\n\tret = regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,\n\t\t\t\t PCF85063_CTRL2_AIE | PCF85063_CTRL2_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(pcf85063->regmap, PCF85063_REG_ALM_S,\n\t\t\t\tbuf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,\n\t\t\t\t  PCF85063_CTRL2_AIE | PCF85063_CTRL2_AF,\n\t\t\t\t  alrm->enabled ? PCF85063_CTRL2_AIE | PCF85063_CTRL2_AF : PCF85063_CTRL2_AF);\n}\n\nstatic int pcf85063_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enabled)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,\n\t\t\t\t  PCF85063_CTRL2_AIE,\n\t\t\t\t  enabled ? PCF85063_CTRL2_AIE : 0);\n}\n\nstatic irqreturn_t pcf85063_rtc_handle_irq(int irq, void *dev_id)\n{\n\tstruct pcf85063 *pcf85063 = dev_id;\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &val);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (val & PCF85063_CTRL2_AF) {\n\t\trtc_update_irq(pcf85063->rtc, 1, RTC_IRQF | RTC_AF);\n\t\tregmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,\n\t\t\t\t   PCF85063_CTRL2_AIE | PCF85063_CTRL2_AF,\n\t\t\t\t   0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int pcf85063_read_offset(struct device *dev, long *offset)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tlong val;\n\tu32 reg;\n\tint ret;\n\n\tret = regmap_read(pcf85063->regmap, PCF85063_REG_OFFSET, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = sign_extend32(reg & ~PCF85063_OFFSET_MODE,\n\t\t\t    PCF85063_OFFSET_SIGN_BIT);\n\n\tif (reg & PCF85063_OFFSET_MODE)\n\t\t*offset = val * PCF85063_OFFSET_STEP1;\n\telse\n\t\t*offset = val * PCF85063_OFFSET_STEP0;\n\n\treturn 0;\n}\n\nstatic int pcf85063_set_offset(struct device *dev, long offset)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\ts8 mode0, mode1, reg;\n\tunsigned int error0, error1;\n\n\tif (offset > PCF85063_OFFSET_STEP0 * 63)\n\t\treturn -ERANGE;\n\tif (offset < PCF85063_OFFSET_STEP0 * -64)\n\t\treturn -ERANGE;\n\n\tmode0 = DIV_ROUND_CLOSEST(offset, PCF85063_OFFSET_STEP0);\n\tmode1 = DIV_ROUND_CLOSEST(offset, PCF85063_OFFSET_STEP1);\n\n\terror0 = abs(offset - (mode0 * PCF85063_OFFSET_STEP0));\n\terror1 = abs(offset - (mode1 * PCF85063_OFFSET_STEP1));\n\tif (mode1 > 63 || mode1 < -64 || error0 < error1)\n\t\treg = mode0 & ~PCF85063_OFFSET_MODE;\n\telse\n\t\treg = mode1 | PCF85063_OFFSET_MODE;\n\n\treturn regmap_write(pcf85063->regmap, PCF85063_REG_OFFSET, reg);\n}\n\nstatic int pcf85063_ioctl(struct device *dev, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct pcf85063 *pcf85063 = dev_get_drvdata(dev);\n\tint status, ret = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(pcf85063->regmap, PCF85063_REG_SC, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = (status & PCF85063_REG_SC_OS) ? RTC_VL_DATA_INVALID : 0;\n\n\t\treturn put_user(status, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct rtc_class_ops pcf85063_rtc_ops = {\n\t.read_time\t= pcf85063_rtc_read_time,\n\t.set_time\t= pcf85063_rtc_set_time,\n\t.read_offset\t= pcf85063_read_offset,\n\t.set_offset\t= pcf85063_set_offset,\n\t.read_alarm\t= pcf85063_rtc_read_alarm,\n\t.set_alarm\t= pcf85063_rtc_set_alarm,\n\t.alarm_irq_enable = pcf85063_rtc_alarm_irq_enable,\n\t.ioctl\t\t= pcf85063_ioctl,\n};\n\nstatic int pcf85063_nvmem_read(void *priv, unsigned int offset,\n\t\t\t       void *val, size_t bytes)\n{\n\treturn regmap_read(priv, PCF85063_REG_RAM, val);\n}\n\nstatic int pcf85063_nvmem_write(void *priv, unsigned int offset,\n\t\t\t\tvoid *val, size_t bytes)\n{\n\treturn regmap_write(priv, PCF85063_REG_RAM, *(u8 *)val);\n}\n\nstatic int pcf85063_load_capacitance(struct pcf85063 *pcf85063,\n\t\t\t\t     const struct device_node *np,\n\t\t\t\t     unsigned int force_cap)\n{\n\tu32 load = 7000;\n\tu8 reg = 0;\n\n\tif (force_cap)\n\t\tload = force_cap;\n\telse\n\t\tof_property_read_u32(np, \"quartz-load-femtofarads\", &load);\n\n\tswitch (load) {\n\tdefault:\n\t\tdev_warn(&pcf85063->rtc->dev, \"Unknown quartz-load-femtofarads value: %d. Assuming 7000\",\n\t\t\t load);\n\t\tfallthrough;\n\tcase 7000:\n\t\tbreak;\n\tcase 12500:\n\t\treg = PCF85063_REG_CTRL1_CAP_SEL;\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL1,\n\t\t\t\t  PCF85063_REG_CTRL1_CAP_SEL, reg);\n}\n\n#ifdef CONFIG_COMMON_CLK\n \n\n#define clkout_hw_to_pcf85063(_hw) container_of(_hw, struct pcf85063, clkout_hw)\n\nstatic int clkout_rates[] = {\n\t32768,\n\t16384,\n\t8192,\n\t4096,\n\t2048,\n\t1024,\n\t1,\n\t0\n};\n\nstatic unsigned long pcf85063_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);\n\tunsigned int buf;\n\tint ret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &buf);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\tbuf &= PCF85063_REG_CLKO_F_MASK;\n\treturn clkout_rates[buf];\n}\n\nstatic long pcf85063_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] <= rate)\n\t\t\treturn clkout_rates[i];\n\n\treturn 0;\n}\n\nstatic int pcf85063_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\n\t\tif (clkout_rates[i] == rate)\n\t\t\treturn regmap_update_bits(pcf85063->regmap,\n\t\t\t\tPCF85063_REG_CTRL2,\n\t\t\t\tPCF85063_REG_CLKO_F_MASK, i);\n\n\treturn -EINVAL;\n}\n\nstatic int pcf85063_clkout_control(struct clk_hw *hw, bool enable)\n{\n\tstruct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);\n\tunsigned int buf;\n\tint ret;\n\n\tret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf &= PCF85063_REG_CLKO_F_MASK;\n\n\tif (enable) {\n\t\tif (buf == PCF85063_REG_CLKO_F_OFF)\n\t\t\tbuf = PCF85063_REG_CLKO_F_32768HZ;\n\t\telse\n\t\t\treturn 0;\n\t} else {\n\t\tif (buf != PCF85063_REG_CLKO_F_OFF)\n\t\t\tbuf = PCF85063_REG_CLKO_F_OFF;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,\n\t\t\t\t\tPCF85063_REG_CLKO_F_MASK, buf);\n}\n\nstatic int pcf85063_clkout_prepare(struct clk_hw *hw)\n{\n\treturn pcf85063_clkout_control(hw, 1);\n}\n\nstatic void pcf85063_clkout_unprepare(struct clk_hw *hw)\n{\n\tpcf85063_clkout_control(hw, 0);\n}\n\nstatic int pcf85063_clkout_is_prepared(struct clk_hw *hw)\n{\n\tstruct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);\n\tunsigned int buf;\n\tint ret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &buf);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn (buf & PCF85063_REG_CLKO_F_MASK) != PCF85063_REG_CLKO_F_OFF;\n}\n\nstatic const struct clk_ops pcf85063_clkout_ops = {\n\t.prepare = pcf85063_clkout_prepare,\n\t.unprepare = pcf85063_clkout_unprepare,\n\t.is_prepared = pcf85063_clkout_is_prepared,\n\t.recalc_rate = pcf85063_clkout_recalc_rate,\n\t.round_rate = pcf85063_clkout_round_rate,\n\t.set_rate = pcf85063_clkout_set_rate,\n};\n\nstatic struct clk *pcf85063_clkout_register_clk(struct pcf85063 *pcf85063)\n{\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tstruct device_node *node = pcf85063->rtc->dev.parent->of_node;\n\tstruct device_node *fixed_clock;\n\n\tfixed_clock = of_get_child_by_name(node, \"clock\");\n\tif (fixed_clock) {\n\t\t \n\t\tof_node_put(fixed_clock);\n\t\treturn NULL;\n\t}\n\n\tinit.name = \"pcf85063-clkout\";\n\tinit.ops = &pcf85063_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tpcf85063->clkout_hw.init = &init;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = devm_clk_register(&pcf85063->rtc->dev, &pcf85063->clkout_hw);\n\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#endif\n\nstatic const struct pcf85063_config config_pcf85063 = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x0a,\n\t},\n};\n\nstatic const struct pcf85063_config config_pcf85063tp = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x0a,\n\t},\n};\n\nstatic const struct pcf85063_config config_pcf85063a = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x11,\n\t},\n\t.has_alarms = 1,\n};\n\nstatic const struct pcf85063_config config_rv8263 = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x11,\n\t},\n\t.has_alarms = 1,\n\t.force_cap_7000 = 1,\n};\n\nstatic int pcf85063_probe(struct i2c_client *client)\n{\n\tstruct pcf85063 *pcf85063;\n\tunsigned int tmp;\n\tint err;\n\tconst struct pcf85063_config *config;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"pcf85063_nvram\",\n\t\t.reg_read = pcf85063_nvmem_read,\n\t\t.reg_write = pcf85063_nvmem_write,\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.size = 1,\n\t};\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tpcf85063 = devm_kzalloc(&client->dev, sizeof(struct pcf85063),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcf85063)\n\t\treturn -ENOMEM;\n\n\tconfig = i2c_get_match_data(client);\n\tif (!config)\n\t\treturn -ENODEV;\n\n\tpcf85063->regmap = devm_regmap_init_i2c(client, &config->regmap);\n\tif (IS_ERR(pcf85063->regmap))\n\t\treturn PTR_ERR(pcf85063->regmap);\n\n\ti2c_set_clientdata(client, pcf85063);\n\n\terr = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL1, &tmp);\n\tif (err) {\n\t\tdev_err(&client->dev, \"RTC chip is not present\\n\");\n\t\treturn err;\n\t}\n\n\tpcf85063->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(pcf85063->rtc))\n\t\treturn PTR_ERR(pcf85063->rtc);\n\n\terr = pcf85063_load_capacitance(pcf85063, client->dev.of_node,\n\t\t\t\t\tconfig->force_cap_7000 ? 7000 : 0);\n\tif (err < 0)\n\t\tdev_warn(&client->dev, \"failed to set xtal load capacitance: %d\",\n\t\t\t err);\n\n\tpcf85063->rtc->ops = &pcf85063_rtc_ops;\n\tpcf85063->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpcf85063->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tset_bit(RTC_FEATURE_ALARM_RES_2S, pcf85063->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, pcf85063->rtc->features);\n\tclear_bit(RTC_FEATURE_ALARM, pcf85063->rtc->features);\n\n\tif (config->has_alarms && client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, pcf85063_rtc_handle_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"pcf85063\", pcf85063);\n\t\tif (err) {\n\t\t\tdev_warn(&pcf85063->rtc->dev,\n\t\t\t\t \"unable to request IRQ, alarms disabled\\n\");\n\t\t} else {\n\t\t\tset_bit(RTC_FEATURE_ALARM, pcf85063->rtc->features);\n\t\t\tdevice_init_wakeup(&client->dev, true);\n\t\t\terr = dev_pm_set_wake_irq(&client->dev, client->irq);\n\t\t\tif (err)\n\t\t\t\tdev_err(&pcf85063->rtc->dev,\n\t\t\t\t\t\"failed to enable irq wake\\n\");\n\t\t}\n\t}\n\n\tnvmem_cfg.priv = pcf85063->regmap;\n\tdevm_rtc_nvmem_register(pcf85063->rtc, &nvmem_cfg);\n\n#ifdef CONFIG_COMMON_CLK\n\t \n\tpcf85063_clkout_register_clk(pcf85063);\n#endif\n\n\treturn devm_rtc_register_device(pcf85063->rtc);\n}\n\nstatic const struct i2c_device_id pcf85063_ids[] = {\n\t{ \"pca85073a\", .driver_data = (kernel_ulong_t)&config_pcf85063a },\n\t{ \"pcf85063\", .driver_data = (kernel_ulong_t)&config_pcf85063 },\n\t{ \"pcf85063tp\", .driver_data = (kernel_ulong_t)&config_pcf85063tp },\n\t{ \"pcf85063a\", .driver_data = (kernel_ulong_t)&config_pcf85063a },\n\t{ \"rv8263\", .driver_data = (kernel_ulong_t)&config_rv8263 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pcf85063_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pcf85063_of_match[] = {\n\t{ .compatible = \"nxp,pca85073a\", .data = &config_pcf85063a },\n\t{ .compatible = \"nxp,pcf85063\", .data = &config_pcf85063 },\n\t{ .compatible = \"nxp,pcf85063tp\", .data = &config_pcf85063tp },\n\t{ .compatible = \"nxp,pcf85063a\", .data = &config_pcf85063a },\n\t{ .compatible = \"microcrystal,rv8263\", .data = &config_rv8263 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pcf85063_of_match);\n#endif\n\nstatic struct i2c_driver pcf85063_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-pcf85063\",\n\t\t.of_match_table = of_match_ptr(pcf85063_of_match),\n\t},\n\t.probe\t\t= pcf85063_probe,\n\t.id_table\t= pcf85063_ids,\n};\n\nmodule_i2c_driver(pcf85063_driver);\n\nMODULE_AUTHOR(\"S\u00f8ren Andersen <san@rosetechnology.dk>\");\nMODULE_DESCRIPTION(\"PCF85063 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}