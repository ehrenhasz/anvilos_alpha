{
  "module_name": "rtc-ep93xx.c",
  "hash_id": "9cab46547aedcade51e52477000fca11107cccdbd7b64023c3dd714fb804f27b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ep93xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n\n#define EP93XX_RTC_DATA\t\t\t0x000\n#define EP93XX_RTC_MATCH\t\t0x004\n#define EP93XX_RTC_STATUS\t\t0x008\n#define  EP93XX_RTC_STATUS_INTR\t\t BIT(0)\n#define EP93XX_RTC_LOAD\t\t\t0x00C\n#define EP93XX_RTC_CONTROL\t\t0x010\n#define  EP93XX_RTC_CONTROL_MIE\t\t BIT(0)\n#define EP93XX_RTC_SWCOMP\t\t0x108\n#define  EP93XX_RTC_SWCOMP_DEL_MASK\t 0x001f0000\n#define  EP93XX_RTC_SWCOMP_DEL_SHIFT\t 16\n#define  EP93XX_RTC_SWCOMP_INT_MASK\t 0x0000ffff\n#define  EP93XX_RTC_SWCOMP_INT_SHIFT\t 0\n\nstruct ep93xx_rtc {\n\tvoid __iomem\t*mmio_base;\n\tstruct rtc_device *rtc;\n};\n\nstatic int ep93xx_rtc_get_swcomp(struct device *dev, unsigned short *preload,\n\t\t\t\t unsigned short *delete)\n{\n\tstruct ep93xx_rtc *ep93xx_rtc = dev_get_drvdata(dev);\n\tunsigned long comp;\n\n\tcomp = readl(ep93xx_rtc->mmio_base + EP93XX_RTC_SWCOMP);\n\n\tif (preload)\n\t\t*preload = (comp & EP93XX_RTC_SWCOMP_INT_MASK)\n\t\t\t\t>> EP93XX_RTC_SWCOMP_INT_SHIFT;\n\n\tif (delete)\n\t\t*delete = (comp & EP93XX_RTC_SWCOMP_DEL_MASK)\n\t\t\t\t>> EP93XX_RTC_SWCOMP_DEL_SHIFT;\n\n\treturn 0;\n}\n\nstatic int ep93xx_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ep93xx_rtc *ep93xx_rtc = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\ttime = readl(ep93xx_rtc->mmio_base + EP93XX_RTC_DATA);\n\n\trtc_time64_to_tm(time, tm);\n\treturn 0;\n}\n\nstatic int ep93xx_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ep93xx_rtc *ep93xx_rtc = dev_get_drvdata(dev);\n\tunsigned long secs = rtc_tm_to_time64(tm);\n\n\twritel(secs + 1, ep93xx_rtc->mmio_base + EP93XX_RTC_LOAD);\n\treturn 0;\n}\n\nstatic int ep93xx_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tunsigned short preload, delete;\n\n\tep93xx_rtc_get_swcomp(dev, &preload, &delete);\n\n\tseq_printf(seq, \"preload\\t\\t: %d\\n\", preload);\n\tseq_printf(seq, \"delete\\t\\t: %d\\n\", delete);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ep93xx_rtc_ops = {\n\t.read_time\t= ep93xx_rtc_read_time,\n\t.set_time\t= ep93xx_rtc_set_time,\n\t.proc\t\t= ep93xx_rtc_proc,\n};\n\nstatic ssize_t comp_preload_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned short preload;\n\n\tep93xx_rtc_get_swcomp(dev->parent, &preload, NULL);\n\n\treturn sprintf(buf, \"%d\\n\", preload);\n}\nstatic DEVICE_ATTR_RO(comp_preload);\n\nstatic ssize_t comp_delete_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned short delete;\n\n\tep93xx_rtc_get_swcomp(dev->parent, NULL, &delete);\n\n\treturn sprintf(buf, \"%d\\n\", delete);\n}\nstatic DEVICE_ATTR_RO(comp_delete);\n\nstatic struct attribute *ep93xx_rtc_attrs[] = {\n\t&dev_attr_comp_preload.attr,\n\t&dev_attr_comp_delete.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ep93xx_rtc_sysfs_files = {\n\t.attrs\t= ep93xx_rtc_attrs,\n};\n\nstatic int ep93xx_rtc_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_rtc *ep93xx_rtc;\n\tint err;\n\n\tep93xx_rtc = devm_kzalloc(&pdev->dev, sizeof(*ep93xx_rtc), GFP_KERNEL);\n\tif (!ep93xx_rtc)\n\t\treturn -ENOMEM;\n\n\tep93xx_rtc->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ep93xx_rtc->mmio_base))\n\t\treturn PTR_ERR(ep93xx_rtc->mmio_base);\n\n\tplatform_set_drvdata(pdev, ep93xx_rtc);\n\n\tep93xx_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(ep93xx_rtc->rtc))\n\t\treturn PTR_ERR(ep93xx_rtc->rtc);\n\n\tep93xx_rtc->rtc->ops = &ep93xx_rtc_ops;\n\tep93xx_rtc->rtc->range_max = U32_MAX;\n\n\terr = rtc_add_group(ep93xx_rtc->rtc, &ep93xx_rtc_sysfs_files);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_rtc_register_device(ep93xx_rtc->rtc);\n}\n\nstatic struct platform_driver ep93xx_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ep93xx-rtc\",\n\t},\n\t.probe\t\t= ep93xx_rtc_probe,\n};\n\nmodule_platform_driver(ep93xx_rtc_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"EP93XX RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ep93xx-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}