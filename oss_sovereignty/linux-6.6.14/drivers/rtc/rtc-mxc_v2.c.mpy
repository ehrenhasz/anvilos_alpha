{
  "module_name": "rtc-mxc_v2.c",
  "hash_id": "f6932b49441cd2211e89cff61c165b38b6a1f94d09edc5ba75cbcf9f61a64d93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mxc_v2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/rtc.h>\n\n#define SRTC_LPPDR_INIT       0x41736166\t \n\n#define SRTC_LPCR_EN_LP       BIT(3)\t \n#define SRTC_LPCR_WAE         BIT(4)\t \n#define SRTC_LPCR_ALP         BIT(7)\t \n#define SRTC_LPCR_NSA         BIT(11)\t \n#define SRTC_LPCR_NVE         BIT(14)\t \n#define SRTC_LPCR_IE          BIT(15)\t \n\n#define SRTC_LPSR_ALP         BIT(3)\t \n#define SRTC_LPSR_NVES        BIT(14)\t \n#define SRTC_LPSR_IES         BIT(15)\t \n\n#define SRTC_LPSCMR\t0x00\t \n#define SRTC_LPSCLR\t0x04\t \n#define SRTC_LPSAR\t0x08\t \n#define SRTC_LPCR\t0x10\t \n#define SRTC_LPSR\t0x14\t \n#define SRTC_LPPDR\t0x18\t \n\n \n#define REG_READ_TIMEOUT 2000\n\nstruct mxc_rtc_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n\tstruct clk *clk;\n\tspinlock_t lock;  \n\tint irq;\n};\n\n \nstatic void mxc_rtc_sync_lp_locked(struct device *dev, void __iomem *ioaddr)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tconst u32 count = readl(ioaddr + SRTC_LPSCLR);\n\t\tunsigned int timeout = REG_READ_TIMEOUT;\n\n\t\twhile ((readl(ioaddr + SRTC_LPSCLR)) == count) {\n\t\t\tif (!--timeout) {\n\t\t\t\tdev_err_once(dev, \"SRTC_LPSCLR stuck! Check your hw.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32 lp_status;\n\tu32 lp_cr;\n\n\tspin_lock(&pdata->lock);\n\tif (clk_enable(pdata->clk)) {\n\t\tspin_unlock(&pdata->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tlp_status = readl(ioaddr + SRTC_LPSR);\n\tlp_cr = readl(ioaddr + SRTC_LPCR);\n\n\t \n\tif (lp_status & SRTC_LPSR_ALP) {\n\t\tif (lp_cr & SRTC_LPCR_ALP)\n\t\t\trtc_update_irq(pdata->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\t \n\t\tlp_cr &= ~(SRTC_LPCR_ALP | SRTC_LPCR_WAE);\n\t}\n\n\t \n\twritel(lp_cr, ioaddr + SRTC_LPCR);\n\n\t \n\twritel(lp_status, ioaddr + SRTC_LPSR);\n\n\tmxc_rtc_sync_lp_locked(dev, ioaddr);\n\tclk_disable(pdata->clk);\n\tspin_unlock(&pdata->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int mxc_rtc_lock(struct mxc_rtc_data *const pdata)\n{\n\tint ret;\n\n\tspin_lock_irq(&pdata->lock);\n\tret = clk_enable(pdata->clk);\n\tif (ret) {\n\t\tspin_unlock_irq(&pdata->lock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int mxc_rtc_unlock(struct mxc_rtc_data *const pdata)\n{\n\tclk_disable(pdata->clk);\n\tspin_unlock_irq(&pdata->lock);\n\treturn 0;\n}\n\n \nstatic int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\tconst int clk_failed = clk_enable(pdata->clk);\n\n\tif (!clk_failed) {\n\t\tconst time64_t now = readl(pdata->ioaddr + SRTC_LPSCMR);\n\n\t\trtc_time64_to_tm(now, tm);\n\t\tclk_disable(pdata->clk);\n\t\treturn 0;\n\t}\n\treturn clk_failed;\n}\n\n \nstatic int mxc_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\ttime64_t time = rtc_tm_to_time64(tm);\n\tint ret;\n\n\tret = mxc_rtc_lock(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(time, pdata->ioaddr + SRTC_LPSCMR);\n\tmxc_rtc_sync_lp_locked(dev, pdata->ioaddr);\n\treturn mxc_rtc_unlock(pdata);\n}\n\n \nstatic int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tint ret;\n\n\tret = mxc_rtc_lock(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_time64_to_tm(readl(ioaddr + SRTC_LPSAR), &alrm->time);\n\talrm->pending = !!(readl(ioaddr + SRTC_LPSR) & SRTC_LPSR_ALP);\n\treturn mxc_rtc_unlock(pdata);\n}\n\n \nstatic void mxc_rtc_alarm_irq_enable_locked(struct mxc_rtc_data *pdata,\n\t\t\t\t\t    unsigned int enable)\n{\n\tu32 lp_cr = readl(pdata->ioaddr + SRTC_LPCR);\n\n\tif (enable)\n\t\tlp_cr |= (SRTC_LPCR_ALP | SRTC_LPCR_WAE);\n\telse\n\t\tlp_cr &= ~(SRTC_LPCR_ALP | SRTC_LPCR_WAE);\n\n\twritel(lp_cr, pdata->ioaddr + SRTC_LPCR);\n}\n\nstatic int mxc_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\tint ret = mxc_rtc_lock(pdata);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmxc_rtc_alarm_irq_enable_locked(pdata, enable);\n\treturn mxc_rtc_unlock(pdata);\n}\n\n \nstatic int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tconst time64_t time = rtc_tm_to_time64(&alrm->time);\n\tstruct mxc_rtc_data *pdata = dev_get_drvdata(dev);\n\tint ret = mxc_rtc_lock(pdata);\n\n\tif (ret)\n\t\treturn ret;\n\n\twritel((u32)time, pdata->ioaddr + SRTC_LPSAR);\n\n\t \n\twritel(SRTC_LPSR_ALP, pdata->ioaddr + SRTC_LPSR);\n\tmxc_rtc_sync_lp_locked(dev, pdata->ioaddr);\n\n\tmxc_rtc_alarm_irq_enable_locked(pdata, alrm->enabled);\n\tmxc_rtc_sync_lp_locked(dev, pdata->ioaddr);\n\tmxc_rtc_unlock(pdata);\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops mxc_rtc_ops = {\n\t.read_time = mxc_rtc_read_time,\n\t.set_time = mxc_rtc_set_time,\n\t.read_alarm = mxc_rtc_read_alarm,\n\t.set_alarm = mxc_rtc_set_alarm,\n\t.alarm_irq_enable = mxc_rtc_alarm_irq_enable,\n};\n\nstatic int mxc_rtc_wait_for_flag(void __iomem *ioaddr, int flag)\n{\n\tunsigned int timeout = REG_READ_TIMEOUT;\n\n\twhile (!(readl(ioaddr) & flag)) {\n\t\tif (!--timeout)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int mxc_rtc_probe(struct platform_device *pdev)\n{\n\tstruct mxc_rtc_data *pdata;\n\tvoid __iomem *ioaddr;\n\tint ret = 0;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->ioaddr))\n\t\treturn PTR_ERR(pdata->ioaddr);\n\n\tioaddr = pdata->ioaddr;\n\n\tpdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pdata->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to get rtc clock!\\n\");\n\t\treturn PTR_ERR(pdata->clk);\n\t}\n\n\tspin_lock_init(&pdata->lock);\n\tpdata->irq = platform_get_irq(pdev, 0);\n\tif (pdata->irq < 0)\n\t\treturn pdata->irq;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tret = dev_pm_set_wake_irq(&pdev->dev, pdata->irq);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to enable irq wake\\n\");\n\n\tret = clk_prepare_enable(pdata->clk);\n\tif (ret)\n\t\treturn ret;\n\t \n\twritel(SRTC_LPPDR_INIT, ioaddr + SRTC_LPPDR);\n\n\t \n\twritel(0xFFFFFFFF, ioaddr + SRTC_LPSR);\n\n\t \n\twritel((SRTC_LPCR_IE | SRTC_LPCR_NSA), ioaddr + SRTC_LPCR);\n\tret = mxc_rtc_wait_for_flag(ioaddr + SRTC_LPSR, SRTC_LPSR_IES);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Timeout waiting for SRTC_LPSR_IES\\n\");\n\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\n\t \n\twritel((SRTC_LPCR_IE | SRTC_LPCR_NVE | SRTC_LPCR_NSA |\n\t\tSRTC_LPCR_EN_LP), ioaddr + SRTC_LPCR);\n\tret = mxc_rtc_wait_for_flag(ioaddr + SRTC_LPSR, SRTC_LPSR_NVES);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Timeout waiting for SRTC_LPSR_NVES\\n\");\n\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc)) {\n\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn PTR_ERR(pdata->rtc);\n\t}\n\n\tpdata->rtc->ops = &mxc_rtc_ops;\n\tpdata->rtc->range_max = U32_MAX;\n\n\tclk_disable(pdata->clk);\n\tplatform_set_drvdata(pdev, pdata);\n\tret =\n\t    devm_request_irq(&pdev->dev, pdata->irq, mxc_rtc_interrupt, 0,\n\t\t\t     pdev->name, &pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"interrupt not available.\\n\");\n\t\tclk_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\n\tret = devm_rtc_register_device(pdata->rtc);\n\tif (ret < 0)\n\t\tclk_unprepare(pdata->clk);\n\n\treturn ret;\n}\n\nstatic void mxc_rtc_remove(struct platform_device *pdev)\n{\n\tstruct mxc_rtc_data *pdata = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(pdata->clk);\n}\n\nstatic const struct of_device_id mxc_ids[] = {\n\t{ .compatible = \"fsl,imx53-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mxc_ids);\n\nstatic struct platform_driver mxc_rtc_driver = {\n\t.driver = {\n\t\t.name = \"mxc_rtc_v2\",\n\t\t.of_match_table = mxc_ids,\n\t},\n\t.probe = mxc_rtc_probe,\n\t.remove_new = mxc_rtc_remove,\n};\n\nmodule_platform_driver(mxc_rtc_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Real Time Clock (RTC) Driver for i.MX53\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}