{
  "module_name": "rtc-cadence.c",
  "hash_id": "0908e0d56d9753e79e472a1cac729fadc481ef13a22acffa5da4495ab2418e96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-cadence.c",
  "human_readable_source": "\n\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/rtc.h>\n#include <linux/clk.h>\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/pm_wakeirq.h>\n\n \n#define CDNS_RTC_CTLR\t\t0x00\n#define CDNS_RTC_HMR\t\t0x04\n#define CDNS_RTC_TIMR\t\t0x08\n#define CDNS_RTC_CALR\t\t0x0C\n#define CDNS_RTC_TIMAR\t\t0x10\n#define CDNS_RTC_CALAR\t\t0x14\n#define CDNS_RTC_AENR\t\t0x18\n#define CDNS_RTC_EFLR\t\t0x1C\n#define CDNS_RTC_IENR\t\t0x20\n#define CDNS_RTC_IDISR\t\t0x24\n#define CDNS_RTC_IMSKR\t\t0x28\n#define CDNS_RTC_STSR\t\t0x2C\n#define CDNS_RTC_KRTCR\t\t0x30\n\n \n#define CDNS_RTC_CTLR_TIME\tBIT(0)\n#define CDNS_RTC_CTLR_CAL\tBIT(1)\n#define CDNS_RTC_CTLR_TIME_CAL\t(CDNS_RTC_CTLR_TIME | CDNS_RTC_CTLR_CAL)\n\n \n#define CDNS_RTC_STSR_VT\tBIT(0)\n#define CDNS_RTC_STSR_VC\tBIT(1)\n#define CDNS_RTC_STSR_VTA\tBIT(2)\n#define CDNS_RTC_STSR_VCA\tBIT(3)\n#define CDNS_RTC_STSR_VT_VC\t(CDNS_RTC_STSR_VT | CDNS_RTC_STSR_VC)\n#define CDNS_RTC_STSR_VTA_VCA\t(CDNS_RTC_STSR_VTA | CDNS_RTC_STSR_VCA)\n\n \n#define CDNS_RTC_KRTCR_KRTC\tBIT(0)\n\n \n#define CDNS_RTC_AEI_HOS\tBIT(0)\n#define CDNS_RTC_AEI_SEC\tBIT(1)\n#define CDNS_RTC_AEI_MIN\tBIT(2)\n#define CDNS_RTC_AEI_HOUR\tBIT(3)\n#define CDNS_RTC_AEI_DATE\tBIT(4)\n#define CDNS_RTC_AEI_MNTH\tBIT(5)\n#define CDNS_RTC_AEI_ALRM\tBIT(6)\n\n \n#define CDNS_RTC_TIME_H\t\tGENMASK(7, 0)\n#define CDNS_RTC_TIME_S\t\tGENMASK(14, 8)\n#define CDNS_RTC_TIME_M\t\tGENMASK(22, 16)\n#define CDNS_RTC_TIME_HR\tGENMASK(29, 24)\n#define CDNS_RTC_TIME_PM\tBIT(30)\n#define CDNS_RTC_TIME_CH\tBIT(31)\n\n \n#define CDNS_RTC_CAL_DAY\tGENMASK(2, 0)\n#define CDNS_RTC_CAL_M\t\tGENMASK(7, 3)\n#define CDNS_RTC_CAL_D\t\tGENMASK(13, 8)\n#define CDNS_RTC_CAL_Y\t\tGENMASK(23, 16)\n#define CDNS_RTC_CAL_C\t\tGENMASK(29, 24)\n#define CDNS_RTC_CAL_CH\t\tBIT(31)\n\n#define CDNS_RTC_MAX_REGS_TRIES\t3\n\nstruct cdns_rtc {\n\tstruct rtc_device *rtc_dev;\n\tstruct clk *pclk;\n\tstruct clk *ref_clk;\n\tvoid __iomem *regs;\n\tint irq;\n};\n\nstatic void cdns_rtc_set_enabled(struct cdns_rtc *crtc, bool enabled)\n{\n\tu32 reg = enabled ? 0x0 : CDNS_RTC_CTLR_TIME_CAL;\n\n\twritel(reg, crtc->regs + CDNS_RTC_CTLR);\n}\n\nstatic bool cdns_rtc_get_enabled(struct cdns_rtc *crtc)\n{\n\treturn !(readl(crtc->regs + CDNS_RTC_CTLR) & CDNS_RTC_CTLR_TIME_CAL);\n}\n\nstatic irqreturn_t cdns_rtc_irq_handler(int irq, void *id)\n{\n\tstruct device *dev = id;\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\n\t \n\tif (!(readl(crtc->regs + CDNS_RTC_EFLR) & CDNS_RTC_AEI_ALRM))\n\t\treturn IRQ_NONE;\n\n\trtc_update_irq(crtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 cdns_rtc_time2reg(struct rtc_time *tm)\n{\n\treturn FIELD_PREP(CDNS_RTC_TIME_S,  bin2bcd(tm->tm_sec))\n\t     | FIELD_PREP(CDNS_RTC_TIME_M,  bin2bcd(tm->tm_min))\n\t     | FIELD_PREP(CDNS_RTC_TIME_HR, bin2bcd(tm->tm_hour));\n}\n\nstatic void cdns_rtc_reg2time(u32 reg, struct rtc_time *tm)\n{\n\ttm->tm_sec  = bcd2bin(FIELD_GET(CDNS_RTC_TIME_S, reg));\n\ttm->tm_min  = bcd2bin(FIELD_GET(CDNS_RTC_TIME_M, reg));\n\ttm->tm_hour = bcd2bin(FIELD_GET(CDNS_RTC_TIME_HR, reg));\n}\n\nstatic int cdns_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\tu32 reg;\n\n\t \n\tif (!cdns_rtc_get_enabled(crtc))\n\t\treturn -EINVAL;\n\n\tcdns_rtc_set_enabled(crtc, false);\n\n\treg = readl(crtc->regs + CDNS_RTC_TIMR);\n\tcdns_rtc_reg2time(reg, tm);\n\n\treg = readl(crtc->regs + CDNS_RTC_CALR);\n\ttm->tm_mday = bcd2bin(FIELD_GET(CDNS_RTC_CAL_D, reg));\n\ttm->tm_mon  = bcd2bin(FIELD_GET(CDNS_RTC_CAL_M, reg)) - 1;\n\ttm->tm_year = bcd2bin(FIELD_GET(CDNS_RTC_CAL_Y, reg))\n\t\t    + bcd2bin(FIELD_GET(CDNS_RTC_CAL_C, reg)) * 100 - 1900;\n\ttm->tm_wday = bcd2bin(FIELD_GET(CDNS_RTC_CAL_DAY, reg)) - 1;\n\n\tcdns_rtc_set_enabled(crtc, true);\n\treturn 0;\n}\n\nstatic int cdns_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\tu32 timr, calr, stsr;\n\tint ret = -EIO;\n\tint year = tm->tm_year + 1900;\n\tint tries;\n\n\tcdns_rtc_set_enabled(crtc, false);\n\n\ttimr = cdns_rtc_time2reg(tm);\n\n\tcalr = FIELD_PREP(CDNS_RTC_CAL_D, bin2bcd(tm->tm_mday))\n\t     | FIELD_PREP(CDNS_RTC_CAL_M, bin2bcd(tm->tm_mon + 1))\n\t     | FIELD_PREP(CDNS_RTC_CAL_Y, bin2bcd(year % 100))\n\t     | FIELD_PREP(CDNS_RTC_CAL_C, bin2bcd(year / 100))\n\t     | FIELD_PREP(CDNS_RTC_CAL_DAY, tm->tm_wday + 1);\n\n\t \n\tfor (tries = 0; tries < CDNS_RTC_MAX_REGS_TRIES; tries++) {\n\t\twritel(timr, crtc->regs + CDNS_RTC_TIMR);\n\t\twritel(calr, crtc->regs + CDNS_RTC_CALR);\n\t\tstsr = readl(crtc->regs + CDNS_RTC_STSR);\n\n\t\tif ((stsr & CDNS_RTC_STSR_VT_VC) == CDNS_RTC_STSR_VT_VC) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcdns_rtc_set_enabled(crtc, true);\n\treturn ret;\n}\n\nstatic int cdns_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\n\tif (enabled) {\n\t\twritel((CDNS_RTC_AEI_SEC | CDNS_RTC_AEI_MIN | CDNS_RTC_AEI_HOUR\n\t\t\t| CDNS_RTC_AEI_DATE | CDNS_RTC_AEI_MNTH),\n\t\t       crtc->regs + CDNS_RTC_AENR);\n\t\twritel(CDNS_RTC_AEI_ALRM, crtc->regs + CDNS_RTC_IENR);\n\t} else {\n\t\twritel(0, crtc->regs + CDNS_RTC_AENR);\n\t\twritel(CDNS_RTC_AEI_ALRM, crtc->regs + CDNS_RTC_IDISR);\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\tu32 reg;\n\n\treg = readl(crtc->regs + CDNS_RTC_TIMAR);\n\tcdns_rtc_reg2time(reg, &alarm->time);\n\n\treg = readl(crtc->regs + CDNS_RTC_CALAR);\n\talarm->time.tm_mday = bcd2bin(FIELD_GET(CDNS_RTC_CAL_D, reg));\n\talarm->time.tm_mon  = bcd2bin(FIELD_GET(CDNS_RTC_CAL_M, reg)) - 1;\n\n\treturn 0;\n}\n\nstatic int cdns_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\tint ret = -EIO;\n\tint tries;\n\tu32 timar, calar, stsr;\n\n\tcdns_rtc_alarm_irq_enable(dev, 0);\n\n\ttimar = cdns_rtc_time2reg(&alarm->time);\n\tcalar = FIELD_PREP(CDNS_RTC_CAL_D, bin2bcd(alarm->time.tm_mday))\n\t      | FIELD_PREP(CDNS_RTC_CAL_M, bin2bcd(alarm->time.tm_mon + 1));\n\n\t \n\tfor (tries = 0; tries < CDNS_RTC_MAX_REGS_TRIES; tries++) {\n\t\twritel(timar, crtc->regs + CDNS_RTC_TIMAR);\n\t\twritel(calar, crtc->regs + CDNS_RTC_CALAR);\n\t\tstsr = readl(crtc->regs + CDNS_RTC_STSR);\n\n\t\tif ((stsr & CDNS_RTC_STSR_VTA_VCA) == CDNS_RTC_STSR_VTA_VCA) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tcdns_rtc_alarm_irq_enable(dev, alarm->enabled);\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops cdns_rtc_ops = {\n\t.read_time\t= cdns_rtc_read_time,\n\t.set_time\t= cdns_rtc_set_time,\n\t.read_alarm\t= cdns_rtc_read_alarm,\n\t.set_alarm\t= cdns_rtc_set_alarm,\n\t.alarm_irq_enable = cdns_rtc_alarm_irq_enable,\n};\n\nstatic int cdns_rtc_probe(struct platform_device *pdev)\n{\n\tstruct cdns_rtc *crtc;\n\tint ret;\n\tunsigned long ref_clk_freq;\n\n\tcrtc = devm_kzalloc(&pdev->dev, sizeof(*crtc), GFP_KERNEL);\n\tif (!crtc)\n\t\treturn -ENOMEM;\n\n\tcrtc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(crtc->regs))\n\t\treturn PTR_ERR(crtc->regs);\n\n\tcrtc->irq = platform_get_irq(pdev, 0);\n\tif (crtc->irq < 0)\n\t\treturn -EINVAL;\n\n\tcrtc->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(crtc->pclk)) {\n\t\tret = PTR_ERR(crtc->pclk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to retrieve the peripheral clock, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcrtc->ref_clk = devm_clk_get(&pdev->dev, \"ref_clk\");\n\tif (IS_ERR(crtc->ref_clk)) {\n\t\tret = PTR_ERR(crtc->ref_clk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to retrieve the reference clock, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcrtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(crtc->rtc_dev))\n\t\treturn PTR_ERR(crtc->rtc_dev);\n\n\tplatform_set_drvdata(pdev, crtc);\n\n\tret = clk_prepare_enable(crtc->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable the peripheral clock, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(crtc->ref_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to enable the reference clock, %d\\n\", ret);\n\t\tgoto err_disable_pclk;\n\t}\n\n\tref_clk_freq = clk_get_rate(crtc->ref_clk);\n\tif ((ref_clk_freq != 1) && (ref_clk_freq != 100)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Invalid reference clock frequency %lu Hz.\\n\",\n\t\t\tref_clk_freq);\n\t\tret = -EINVAL;\n\t\tgoto err_disable_ref_clk;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, crtc->irq,\n\t\t\t       cdns_rtc_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request interrupt for the device, %d\\n\",\n\t\t\tret);\n\t\tgoto err_disable_ref_clk;\n\t}\n\n\t \n\tcrtc->rtc_dev->range_min = mktime64(1900,  1,  1,  0,  0,  0);\n\tcrtc->rtc_dev->range_max = mktime64(2999, 12, 31, 23, 59, 59);\n\n\tcrtc->rtc_dev->ops = &cdns_rtc_ops;\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\t \n\twritel(0, crtc->regs + CDNS_RTC_HMR);\n\twritel(CDNS_RTC_KRTCR_KRTC, crtc->regs + CDNS_RTC_KRTCR);\n\n\tret = devm_rtc_register_device(crtc->rtc_dev);\n\tif (ret)\n\t\tgoto err_disable_wakeup;\n\n\treturn 0;\n\nerr_disable_wakeup:\n\tdevice_init_wakeup(&pdev->dev, false);\n\nerr_disable_ref_clk:\n\tclk_disable_unprepare(crtc->ref_clk);\n\nerr_disable_pclk:\n\tclk_disable_unprepare(crtc->pclk);\n\n\treturn ret;\n}\n\nstatic void cdns_rtc_remove(struct platform_device *pdev)\n{\n\tstruct cdns_rtc *crtc = platform_get_drvdata(pdev);\n\n\tcdns_rtc_alarm_irq_enable(&pdev->dev, 0);\n\tdevice_init_wakeup(&pdev->dev, 0);\n\n\tclk_disable_unprepare(crtc->pclk);\n\tclk_disable_unprepare(crtc->ref_clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cdns_rtc_suspend(struct device *dev)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(crtc->irq);\n\n\treturn 0;\n}\n\nstatic int cdns_rtc_resume(struct device *dev)\n{\n\tstruct cdns_rtc *crtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(crtc->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cdns_rtc_pm_ops, cdns_rtc_suspend, cdns_rtc_resume);\n\nstatic const struct of_device_id cdns_rtc_of_match[] = {\n\t{ .compatible = \"cdns,rtc-r109v3\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cdns_rtc_of_match);\n\nstatic struct platform_driver cdns_rtc_driver = {\n\t.driver = {\n\t\t.name = \"cdns-rtc\",\n\t\t.of_match_table = cdns_rtc_of_match,\n\t\t.pm = &cdns_rtc_pm_ops,\n\t},\n\t.probe = cdns_rtc_probe,\n\t.remove_new = cdns_rtc_remove,\n};\nmodule_platform_driver(cdns_rtc_driver);\n\nMODULE_AUTHOR(\"Jan Kotas <jank@cadence.com>\");\nMODULE_DESCRIPTION(\"Cadence RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:cdns-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}