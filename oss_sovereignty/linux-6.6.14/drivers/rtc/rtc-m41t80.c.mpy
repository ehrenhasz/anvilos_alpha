{
  "module_name": "rtc-m41t80.c",
  "hash_id": "2174dd13ea66efca5d3a4e6c509d2c7998598e6eff680c07491f93676607a0a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-m41t80.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bcd.h>\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/miscdevice.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n#endif\n\n#define M41T80_REG_SSEC\t\t0x00\n#define M41T80_REG_SEC\t\t0x01\n#define M41T80_REG_MIN\t\t0x02\n#define M41T80_REG_HOUR\t\t0x03\n#define M41T80_REG_WDAY\t\t0x04\n#define M41T80_REG_DAY\t\t0x05\n#define M41T80_REG_MON\t\t0x06\n#define M41T80_REG_YEAR\t\t0x07\n#define M41T80_REG_ALARM_MON\t0x0a\n#define M41T80_REG_ALARM_DAY\t0x0b\n#define M41T80_REG_ALARM_HOUR\t0x0c\n#define M41T80_REG_ALARM_MIN\t0x0d\n#define M41T80_REG_ALARM_SEC\t0x0e\n#define M41T80_REG_FLAGS\t0x0f\n#define M41T80_REG_SQW\t\t0x13\n\n#define M41T80_DATETIME_REG_SIZE\t(M41T80_REG_YEAR + 1)\n#define M41T80_ALARM_REG_SIZE\t\\\n\t(M41T80_REG_ALARM_SEC + 1 - M41T80_REG_ALARM_MON)\n\n#define M41T80_SQW_MAX_FREQ\t32768\n\n#define M41T80_SEC_ST\t\tBIT(7)\t \n#define M41T80_ALMON_AFE\tBIT(7)\t \n#define M41T80_ALMON_SQWE\tBIT(6)\t \n#define M41T80_ALHOUR_HT\tBIT(6)\t \n#define M41T80_FLAGS_OF\t\tBIT(2)\t \n#define M41T80_FLAGS_AF\t\tBIT(6)\t \n#define M41T80_FLAGS_BATT_LOW\tBIT(4)\t \n#define M41T80_WATCHDOG_RB2\tBIT(7)\t \n#define M41T80_WATCHDOG_RB1\tBIT(1)\t \n#define M41T80_WATCHDOG_RB0\tBIT(0)\t \n\n#define M41T80_FEATURE_HT\tBIT(0)\t \n#define M41T80_FEATURE_BL\tBIT(1)\t \n#define M41T80_FEATURE_SQ\tBIT(2)\t \n#define M41T80_FEATURE_WD\tBIT(3)\t \n#define M41T80_FEATURE_SQ_ALT\tBIT(4)\t \n\nstatic const struct i2c_device_id m41t80_id[] = {\n\t{ \"m41t62\", M41T80_FEATURE_SQ | M41T80_FEATURE_SQ_ALT },\n\t{ \"m41t65\", M41T80_FEATURE_HT | M41T80_FEATURE_WD },\n\t{ \"m41t80\", M41T80_FEATURE_SQ },\n\t{ \"m41t81\", M41T80_FEATURE_HT | M41T80_FEATURE_SQ},\n\t{ \"m41t81s\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"m41t82\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"m41t83\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"m41st84\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"m41st85\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"m41st87\", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },\n\t{ \"rv4162\", M41T80_FEATURE_SQ | M41T80_FEATURE_WD | M41T80_FEATURE_SQ_ALT },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, m41t80_id);\n\nstatic const __maybe_unused struct of_device_id m41t80_of_match[] = {\n\t{\n\t\t.compatible = \"st,m41t62\",\n\t\t.data = (void *)(M41T80_FEATURE_SQ | M41T80_FEATURE_SQ_ALT)\n\t},\n\t{\n\t\t.compatible = \"st,m41t65\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_WD)\n\t},\n\t{\n\t\t.compatible = \"st,m41t80\",\n\t\t.data = (void *)(M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t81\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t81s\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t82\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t83\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t84\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t85\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"st,m41t87\",\n\t\t.data = (void *)(M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ)\n\t},\n\t{\n\t\t.compatible = \"microcrystal,rv4162\",\n\t\t.data = (void *)(M41T80_FEATURE_SQ | M41T80_FEATURE_WD | M41T80_FEATURE_SQ_ALT)\n\t},\n\t \n\t{\n\t\t.compatible = \"st,rv4162\",\n\t\t.data = (void *)(M41T80_FEATURE_SQ | M41T80_FEATURE_WD | M41T80_FEATURE_SQ_ALT)\n\t},\n\t{\n\t\t.compatible = \"rv4162\",\n\t\t.data = (void *)(M41T80_FEATURE_SQ | M41T80_FEATURE_WD | M41T80_FEATURE_SQ_ALT)\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, m41t80_of_match);\n\nstruct m41t80_data {\n\tunsigned long features;\n\tstruct i2c_client *client;\n\tstruct rtc_device *rtc;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw sqw;\n\tunsigned long freq;\n\tunsigned int sqwe;\n#endif\n};\n\nstatic irqreturn_t m41t80_handle_irq(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct m41t80_data *m41t80 = i2c_get_clientdata(client);\n\tunsigned long events = 0;\n\tint flags, flags_afe;\n\n\trtc_lock(m41t80->rtc);\n\n\tflags_afe = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\n\tif (flags_afe < 0) {\n\t\trtc_unlock(m41t80->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (flags <= 0) {\n\t\trtc_unlock(m41t80->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (flags & M41T80_FLAGS_AF) {\n\t\tflags &= ~M41T80_FLAGS_AF;\n\t\tflags_afe &= ~M41T80_ALMON_AFE;\n\t\tevents |= RTC_AF;\n\t}\n\n\tif (events) {\n\t\trtc_update_irq(m41t80->rtc, 1, events);\n\t\ti2c_smbus_write_byte_data(client, M41T80_REG_FLAGS, flags);\n\t\ti2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\t  flags_afe);\n\t}\n\n\trtc_unlock(m41t80->rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int m41t80_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[8];\n\tint err, flags;\n\n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (flags & M41T80_FLAGS_OF) {\n\t\tdev_err(&client->dev, \"Oscillator failure, data is invalid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = i2c_smbus_read_i2c_block_data(client, M41T80_REG_SSEC,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to read date\\n\");\n\t\treturn err;\n\t}\n\n\ttm->tm_sec = bcd2bin(buf[M41T80_REG_SEC] & 0x7f);\n\ttm->tm_min = bcd2bin(buf[M41T80_REG_MIN] & 0x7f);\n\ttm->tm_hour = bcd2bin(buf[M41T80_REG_HOUR] & 0x3f);\n\ttm->tm_mday = bcd2bin(buf[M41T80_REG_DAY] & 0x3f);\n\ttm->tm_wday = buf[M41T80_REG_WDAY] & 0x07;\n\ttm->tm_mon = bcd2bin(buf[M41T80_REG_MON] & 0x1f) - 1;\n\n\t \n\ttm->tm_year = bcd2bin(buf[M41T80_REG_YEAR]) + 100;\n\treturn 0;\n}\n\nstatic int m41t80_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct m41t80_data *clientdata = i2c_get_clientdata(client);\n\tunsigned char buf[8];\n\tint err, flags;\n\n\tbuf[M41T80_REG_SSEC] = 0;\n\tbuf[M41T80_REG_SEC] = bin2bcd(tm->tm_sec);\n\tbuf[M41T80_REG_MIN] = bin2bcd(tm->tm_min);\n\tbuf[M41T80_REG_HOUR] = bin2bcd(tm->tm_hour);\n\tbuf[M41T80_REG_DAY] = bin2bcd(tm->tm_mday);\n\tbuf[M41T80_REG_MON] = bin2bcd(tm->tm_mon + 1);\n\tbuf[M41T80_REG_YEAR] = bin2bcd(tm->tm_year - 100);\n\tbuf[M41T80_REG_WDAY] = tm->tm_wday;\n\n\t \n\tif (clientdata->features & M41T80_FEATURE_SQ_ALT) {\n\t\tint val;\n\n\t\tval = i2c_smbus_read_byte_data(client, M41T80_REG_WDAY);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tbuf[M41T80_REG_WDAY] |= (val & 0xf0);\n\t}\n\n\terr = i2c_smbus_write_i2c_block_data(client, M41T80_REG_SSEC,\n\t\t\t\t\t     sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write to date registers\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (flags < 0)\n\t\treturn flags;\n\n\terr = i2c_smbus_write_byte_data(client, M41T80_REG_FLAGS,\n\t\t\t\t\tflags & ~M41T80_FLAGS_OF);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write flags register\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int m41t80_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct m41t80_data *clientdata = i2c_get_clientdata(client);\n\tint reg;\n\n\tif (clientdata->features & M41T80_FEATURE_BL) {\n\t\treg = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tseq_printf(seq, \"battery\\t\\t: %s\\n\",\n\t\t\t   (reg & M41T80_FLAGS_BATT_LOW) ? \"exhausted\" : \"ok\");\n\t}\n\treturn 0;\n}\n\nstatic int m41t80_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint flags, retval;\n\n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (enabled)\n\t\tflags |= M41T80_ALMON_AFE;\n\telse\n\t\tflags &= ~M41T80_ALMON_AFE;\n\n\tretval = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON, flags);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Unable to enable alarm IRQ %d\\n\", retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\nstatic int m41t80_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 alarmvals[5];\n\tint ret, err;\n\n\talarmvals[0] = bin2bcd(alrm->time.tm_mon + 1);\n\talarmvals[1] = bin2bcd(alrm->time.tm_mday);\n\talarmvals[2] = bin2bcd(alrm->time.tm_hour);\n\talarmvals[3] = bin2bcd(alrm->time.tm_min);\n\talarmvals[4] = bin2bcd(alrm->time.tm_sec);\n\n\t \n\tret = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\n\tif (ret < 0)\n\t\treturn ret;\n\terr = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\tret & ~(M41T80_ALMON_AFE));\n\tif (err < 0) {\n\t\tdev_err(dev, \"Unable to clear AFE bit\\n\");\n\t\treturn err;\n\t}\n\n\t \n\talarmvals[0] |= (ret & M41T80_ALMON_SQWE);\n\n\tret = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\terr = i2c_smbus_write_byte_data(client, M41T80_REG_FLAGS,\n\t\t\t\t\tret & ~(M41T80_FLAGS_AF));\n\tif (err < 0) {\n\t\tdev_err(dev, \"Unable to clear AF bit\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = i2c_smbus_write_i2c_block_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\t     5, alarmvals);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (alrm->enabled) {\n\t\talarmvals[0] |= M41T80_ALMON_AFE;\n\t\terr = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\t\talarmvals[0]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int m41t80_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 alarmvals[5];\n\tint flags, ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\t    5, alarmvals);\n\tif (ret != 5)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\n\tif (flags < 0)\n\t\treturn flags;\n\n\talrm->time.tm_sec  = bcd2bin(alarmvals[4] & 0x7f);\n\talrm->time.tm_min  = bcd2bin(alarmvals[3] & 0x7f);\n\talrm->time.tm_hour = bcd2bin(alarmvals[2] & 0x3f);\n\talrm->time.tm_mday = bcd2bin(alarmvals[1] & 0x3f);\n\talrm->time.tm_mon  = bcd2bin(alarmvals[0] & 0x3f) - 1;\n\n\talrm->enabled = !!(alarmvals[0] & M41T80_ALMON_AFE);\n\talrm->pending = (flags & M41T80_FLAGS_AF) && alrm->enabled;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops m41t80_rtc_ops = {\n\t.read_time = m41t80_rtc_read_time,\n\t.set_time = m41t80_rtc_set_time,\n\t.proc = m41t80_rtc_proc,\n\t.read_alarm = m41t80_read_alarm,\n\t.set_alarm = m41t80_set_alarm,\n\t.alarm_irq_enable = m41t80_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int m41t80_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq >= 0 && device_may_wakeup(dev))\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int m41t80_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq >= 0 && device_may_wakeup(dev))\n\t\tdisable_irq_wake(client->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(m41t80_pm, m41t80_suspend, m41t80_resume);\n\n#ifdef CONFIG_COMMON_CLK\n#define sqw_to_m41t80_data(_hw) container_of(_hw, struct m41t80_data, sqw)\n\nstatic unsigned long m41t80_decode_freq(int setting)\n{\n\treturn (setting == 0) ? 0 : (setting == 1) ? M41T80_SQW_MAX_FREQ :\n\t\tM41T80_SQW_MAX_FREQ >> setting;\n}\n\nstatic unsigned long m41t80_get_freq(struct m41t80_data *m41t80)\n{\n\tstruct i2c_client *client = m41t80->client;\n\tint reg_sqw = (m41t80->features & M41T80_FEATURE_SQ_ALT) ?\n\t\tM41T80_REG_WDAY : M41T80_REG_SQW;\n\tint ret = i2c_smbus_read_byte_data(client, reg_sqw);\n\n\tif (ret < 0)\n\t\treturn 0;\n\treturn m41t80_decode_freq(ret >> 4);\n}\n\nstatic unsigned long m41t80_sqw_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\treturn sqw_to_m41t80_data(hw)->freq;\n}\n\nstatic long m41t80_sqw_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long *prate)\n{\n\tif (rate >= M41T80_SQW_MAX_FREQ)\n\t\treturn M41T80_SQW_MAX_FREQ;\n\tif (rate >= M41T80_SQW_MAX_FREQ / 4)\n\t\treturn M41T80_SQW_MAX_FREQ / 4;\n\tif (!rate)\n\t\treturn 0;\n\treturn 1 << ilog2(rate);\n}\n\nstatic int m41t80_sqw_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t       unsigned long parent_rate)\n{\n\tstruct m41t80_data *m41t80 = sqw_to_m41t80_data(hw);\n\tstruct i2c_client *client = m41t80->client;\n\tint reg_sqw = (m41t80->features & M41T80_FEATURE_SQ_ALT) ?\n\t\tM41T80_REG_WDAY : M41T80_REG_SQW;\n\tint reg, ret, val = 0;\n\n\tif (rate >= M41T80_SQW_MAX_FREQ)\n\t\tval = 1;\n\telse if (rate >= M41T80_SQW_MAX_FREQ / 4)\n\t\tval = 2;\n\telse if (rate)\n\t\tval = 15 - ilog2(rate);\n\n\treg = i2c_smbus_read_byte_data(client, reg_sqw);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg = (reg & 0x0f) | (val << 4);\n\n\tret = i2c_smbus_write_byte_data(client, reg_sqw, reg);\n\tif (!ret)\n\t\tm41t80->freq = m41t80_decode_freq(val);\n\treturn ret;\n}\n\nstatic int m41t80_sqw_control(struct clk_hw *hw, bool enable)\n{\n\tstruct m41t80_data *m41t80 = sqw_to_m41t80_data(hw);\n\tstruct i2c_client *client = m41t80->client;\n\tint ret = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable)\n\t\tret |= M41T80_ALMON_SQWE;\n\telse\n\t\tret &= ~M41T80_ALMON_SQWE;\n\n\tret = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON, ret);\n\tif (!ret)\n\t\tm41t80->sqwe = enable;\n\treturn ret;\n}\n\nstatic int m41t80_sqw_prepare(struct clk_hw *hw)\n{\n\treturn m41t80_sqw_control(hw, 1);\n}\n\nstatic void m41t80_sqw_unprepare(struct clk_hw *hw)\n{\n\tm41t80_sqw_control(hw, 0);\n}\n\nstatic int m41t80_sqw_is_prepared(struct clk_hw *hw)\n{\n\treturn sqw_to_m41t80_data(hw)->sqwe;\n}\n\nstatic const struct clk_ops m41t80_sqw_ops = {\n\t.prepare = m41t80_sqw_prepare,\n\t.unprepare = m41t80_sqw_unprepare,\n\t.is_prepared = m41t80_sqw_is_prepared,\n\t.recalc_rate = m41t80_sqw_recalc_rate,\n\t.round_rate = m41t80_sqw_round_rate,\n\t.set_rate = m41t80_sqw_set_rate,\n};\n\nstatic struct clk *m41t80_sqw_register_clk(struct m41t80_data *m41t80)\n{\n\tstruct i2c_client *client = m41t80->client;\n\tstruct device_node *node = client->dev.of_node;\n\tstruct device_node *fixed_clock;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tint ret;\n\n\tfixed_clock = of_get_child_by_name(node, \"clock\");\n\tif (fixed_clock) {\n\t\t \n\t\tof_node_put(fixed_clock);\n\t\treturn NULL;\n\t}\n\n\t \n\tret = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tret = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\n\t\t\t\t\tret & ~(M41T80_ALMON_SQWE));\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tinit.name = \"m41t80-sqw\";\n\tinit.ops = &m41t80_sqw_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\tm41t80->sqw.init = &init;\n\tm41t80->freq = m41t80_get_freq(m41t80);\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\t \n\tclk = clk_register(&client->dev, &m41t80->sqw);\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#endif\n\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\n \nstatic DEFINE_MUTEX(m41t80_rtc_mutex);\nstatic struct i2c_client *save_client;\n\n \n#define WD_TIMO 60\t\t \n\nstatic int wdt_margin = WD_TIMO;\nmodule_param(wdt_margin, int, 0);\nMODULE_PARM_DESC(wdt_margin, \"Watchdog timeout in seconds (default 60s)\");\n\nstatic unsigned long wdt_is_open;\nstatic int boot_flag;\n\n \nstatic void wdt_ping(void)\n{\n\tunsigned char i2c_data[2];\n\tstruct i2c_msg msgs1[1] = {\n\t\t{\n\t\t\t.addr\t= save_client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 2,\n\t\t\t.buf\t= i2c_data,\n\t\t},\n\t};\n\tstruct m41t80_data *clientdata = i2c_get_clientdata(save_client);\n\n\ti2c_data[0] = 0x09;\t\t \n\n\tif (wdt_margin > 31)\n\t\ti2c_data[1] = (wdt_margin & 0xFC) | 0x83;  \n\telse\n\t\t \n\t\ti2c_data[1] = wdt_margin << 2 | 0x82;\n\n\t \n\tif (clientdata->features & M41T80_FEATURE_WD)\n\t\ti2c_data[1] &= ~M41T80_WATCHDOG_RB2;\n\n\ti2c_transfer(save_client->adapter, msgs1, 1);\n}\n\n \nstatic void wdt_disable(void)\n{\n\tunsigned char i2c_data[2], i2c_buf[0x10];\n\tstruct i2c_msg msgs0[2] = {\n\t\t{\n\t\t\t.addr\t= save_client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= i2c_data,\n\t\t},\n\t\t{\n\t\t\t.addr\t= save_client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= i2c_buf,\n\t\t},\n\t};\n\tstruct i2c_msg msgs1[1] = {\n\t\t{\n\t\t\t.addr\t= save_client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 2,\n\t\t\t.buf\t= i2c_data,\n\t\t},\n\t};\n\n\ti2c_data[0] = 0x09;\n\ti2c_transfer(save_client->adapter, msgs0, 2);\n\n\ti2c_data[0] = 0x09;\n\ti2c_data[1] = 0x00;\n\ti2c_transfer(save_client->adapter, msgs1, 1);\n}\n\n \nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\twdt_ping();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t wdt_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\n \nstatic int wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tint new_margin, rv;\n\tstatic struct watchdog_info ident = {\n\t\t.options = WDIOF_POWERUNDER | WDIOF_KEEPALIVEPING |\n\t\t\tWDIOF_SETTIMEOUT,\n\t\t.firmware_version = 1,\n\t\t.identity = \"M41T80 WTD\"\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user((struct watchdog_info __user *)arg, &ident,\n\t\t\t\t    sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(boot_flag, (int __user *)arg);\n\tcase WDIOC_KEEPALIVE:\n\t\twdt_ping();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_margin, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (new_margin < 1 || new_margin > 124)\n\t\t\treturn -EINVAL;\n\t\twdt_margin = new_margin;\n\t\twdt_ping();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(wdt_margin, (int __user *)arg);\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (copy_from_user(&rv, (int __user *)arg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (rv & WDIOS_DISABLECARD) {\n\t\t\tpr_info(\"disable watchdog\\n\");\n\t\t\twdt_disable();\n\t\t}\n\n\t\tif (rv & WDIOS_ENABLECARD) {\n\t\t\tpr_info(\"enable watchdog\\n\");\n\t\t\twdt_ping();\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\treturn -ENOTTY;\n}\n\nstatic long wdt_unlocked_ioctl(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&m41t80_rtc_mutex);\n\tret = wdt_ioctl(file, cmd, arg);\n\tmutex_unlock(&m41t80_rtc_mutex);\n\n\treturn ret;\n}\n\n \nstatic int wdt_open(struct inode *inode, struct file *file)\n{\n\tif (iminor(inode) == WATCHDOG_MINOR) {\n\t\tmutex_lock(&m41t80_rtc_mutex);\n\t\tif (test_and_set_bit(0, &wdt_is_open)) {\n\t\t\tmutex_unlock(&m41t80_rtc_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\twdt_is_open = 1;\n\t\tmutex_unlock(&m41t80_rtc_mutex);\n\t\treturn stream_open(inode, file);\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic int wdt_release(struct inode *inode, struct file *file)\n{\n\tif (iminor(inode) == WATCHDOG_MINOR)\n\t\tclear_bit(0, &wdt_is_open);\n\treturn 0;\n}\n\n \nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t  void *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\t \n\t\twdt_disable();\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct file_operations wdt_fops = {\n\t.owner\t= THIS_MODULE,\n\t.read\t= wdt_read,\n\t.unlocked_ioctl = wdt_unlocked_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.write\t= wdt_write,\n\t.open\t= wdt_open,\n\t.release = wdt_release,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice wdt_dev = {\n\t.minor = WATCHDOG_MINOR,\n\t.name = \"watchdog\",\n\t.fops = &wdt_fops,\n};\n\n \nstatic struct notifier_block wdt_notifier = {\n\t.notifier_call = wdt_notify_sys,\n};\n#endif  \n\n \n\nstatic int m41t80_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint rc = 0;\n\tstruct rtc_time tm;\n\tstruct m41t80_data *m41t80_data = NULL;\n\tbool wakeup_source = false;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&adapter->dev, \"doesn't support I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tm41t80_data = devm_kzalloc(&client->dev, sizeof(*m41t80_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!m41t80_data)\n\t\treturn -ENOMEM;\n\n\tm41t80_data->client = client;\n\tif (client->dev.of_node) {\n\t\tm41t80_data->features = (unsigned long)\n\t\t\tof_device_get_match_data(&client->dev);\n\t} else {\n\t\tconst struct i2c_device_id *id = i2c_match_id(m41t80_id, client);\n\t\tm41t80_data->features = id->driver_data;\n\t}\n\ti2c_set_clientdata(client, m41t80_data);\n\n\tm41t80_data->rtc =  devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(m41t80_data->rtc))\n\t\treturn PTR_ERR(m41t80_data->rtc);\n\n#ifdef CONFIG_OF\n\twakeup_source = of_property_read_bool(client->dev.of_node,\n\t\t\t\t\t      \"wakeup-source\");\n#endif\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\trc = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t       NULL, m41t80_handle_irq,\n\t\t\t\t\t       irqflags | IRQF_ONESHOT,\n\t\t\t\t\t       \"m41t80\", client);\n\t\tif (rc) {\n\t\t\tdev_warn(&client->dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t\twakeup_source = false;\n\t\t}\n\t}\n\tif (client->irq > 0 || wakeup_source)\n\t\tdevice_init_wakeup(&client->dev, true);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, m41t80_data->rtc->features);\n\n\tm41t80_data->rtc->ops = &m41t80_rtc_ops;\n\tm41t80_data->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tm41t80_data->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tif (client->irq <= 0)\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, m41t80_data->rtc->features);\n\n\t \n\trc = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_HOUR);\n\n\tif (rc >= 0 && rc & M41T80_ALHOUR_HT) {\n\t\tif (m41t80_data->features & M41T80_FEATURE_HT) {\n\t\t\tm41t80_rtc_read_time(&client->dev, &tm);\n\t\t\tdev_info(&client->dev, \"HT bit was set!\\n\");\n\t\t\tdev_info(&client->dev, \"Power Down at %ptR\\n\", &tm);\n\t\t}\n\t\trc = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_HOUR,\n\t\t\t\t\t       rc & ~M41T80_ALHOUR_HT);\n\t}\n\n\tif (rc < 0) {\n\t\tdev_err(&client->dev, \"Can't clear HT bit\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\trc = i2c_smbus_read_byte_data(client, M41T80_REG_SEC);\n\n\tif (rc >= 0 && rc & M41T80_SEC_ST)\n\t\trc = i2c_smbus_write_byte_data(client, M41T80_REG_SEC,\n\t\t\t\t\t       rc & ~M41T80_SEC_ST);\n\tif (rc < 0) {\n\t\tdev_err(&client->dev, \"Can't clear ST bit\\n\");\n\t\treturn rc;\n\t}\n\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\n\tif (m41t80_data->features & M41T80_FEATURE_HT) {\n\t\tsave_client = client;\n\t\trc = misc_register(&wdt_dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = register_reboot_notifier(&wdt_notifier);\n\t\tif (rc) {\n\t\t\tmisc_deregister(&wdt_dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n#endif\n#ifdef CONFIG_COMMON_CLK\n\tif (m41t80_data->features & M41T80_FEATURE_SQ)\n\t\tm41t80_sqw_register_clk(m41t80_data);\n#endif\n\n\trc = devm_rtc_register_device(m41t80_data->rtc);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void m41t80_remove(struct i2c_client *client)\n{\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\n\tstruct m41t80_data *clientdata = i2c_get_clientdata(client);\n\n\tif (clientdata->features & M41T80_FEATURE_HT) {\n\t\tmisc_deregister(&wdt_dev);\n\t\tunregister_reboot_notifier(&wdt_notifier);\n\t}\n#endif\n}\n\nstatic struct i2c_driver m41t80_driver = {\n\t.driver = {\n\t\t.name = \"rtc-m41t80\",\n\t\t.of_match_table = of_match_ptr(m41t80_of_match),\n\t\t.pm = &m41t80_pm,\n\t},\n\t.probe = m41t80_probe,\n\t.remove = m41t80_remove,\n\t.id_table = m41t80_id,\n};\n\nmodule_i2c_driver(m41t80_driver);\n\nMODULE_AUTHOR(\"Alexander Bigga <ab@mycable.de>\");\nMODULE_DESCRIPTION(\"ST Microelectronics M41T80 series RTC I2C Client Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}