{
  "module_name": "proc.c",
  "hash_id": "293efa545208c031592d91d6a20c045017acdd74b28ba3698ed4847e46da19ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/proc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include \"rtc-core.h\"\n\n#define NAME_SIZE\t10\n\n#if defined(CONFIG_RTC_HCTOSYS_DEVICE)\nstatic bool is_rtc_hctosys(struct rtc_device *rtc)\n{\n\tint size;\n\tchar name[NAME_SIZE];\n\n\tsize = snprintf(name, NAME_SIZE, \"rtc%d\", rtc->id);\n\tif (size >= NAME_SIZE)\n\t\treturn false;\n\n\treturn !strncmp(name, CONFIG_RTC_HCTOSYS_DEVICE, NAME_SIZE);\n}\n#else\nstatic bool is_rtc_hctosys(struct rtc_device *rtc)\n{\n\treturn (rtc->id == 0);\n}\n#endif\n\nstatic int rtc_proc_show(struct seq_file *seq, void *offset)\n{\n\tint err;\n\tstruct rtc_device *rtc = seq->private;\n\tconst struct rtc_class_ops *ops = rtc->ops;\n\tstruct rtc_wkalrm alrm;\n\tstruct rtc_time tm;\n\n\terr = rtc_read_time(rtc, &tm);\n\tif (err == 0) {\n\t\tseq_printf(seq,\n\t\t\t   \"rtc_time\\t: %ptRt\\n\"\n\t\t\t   \"rtc_date\\t: %ptRd\\n\",\n\t\t\t   &tm, &tm);\n\t}\n\n\terr = rtc_read_alarm(rtc, &alrm);\n\tif (err == 0) {\n\t\tseq_printf(seq, \"alrm_time\\t: %ptRt\\n\", &alrm.time);\n\t\tseq_printf(seq, \"alrm_date\\t: %ptRd\\n\", &alrm.time);\n\t\tseq_printf(seq, \"alarm_IRQ\\t: %s\\n\",\n\t\t\t   alrm.enabled ? \"yes\" : \"no\");\n\t\tseq_printf(seq, \"alrm_pending\\t: %s\\n\",\n\t\t\t   alrm.pending ? \"yes\" : \"no\");\n\t\tseq_printf(seq, \"update IRQ enabled\\t: %s\\n\",\n\t\t\t   (rtc->uie_rtctimer.enabled) ? \"yes\" : \"no\");\n\t\tseq_printf(seq, \"periodic IRQ enabled\\t: %s\\n\",\n\t\t\t   (rtc->pie_enabled) ? \"yes\" : \"no\");\n\t\tseq_printf(seq, \"periodic IRQ frequency\\t: %d\\n\",\n\t\t\t   rtc->irq_freq);\n\t\tseq_printf(seq, \"max user IRQ frequency\\t: %d\\n\",\n\t\t\t   rtc->max_user_freq);\n\t}\n\n\tseq_printf(seq, \"24hr\\t\\t: yes\\n\");\n\n\tif (ops->proc)\n\t\tops->proc(rtc->dev.parent, seq);\n\n\treturn 0;\n}\n\nvoid rtc_proc_add_device(struct rtc_device *rtc)\n{\n\tif (is_rtc_hctosys(rtc))\n\t\tproc_create_single_data(\"driver/rtc\", 0, NULL, rtc_proc_show,\n\t\t\t\t\trtc);\n}\n\nvoid rtc_proc_del_device(struct rtc_device *rtc)\n{\n\tif (is_rtc_hctosys(rtc))\n\t\tremove_proc_entry(\"driver/rtc\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}