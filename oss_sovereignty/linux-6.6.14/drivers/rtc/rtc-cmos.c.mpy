{
  "module_name": "rtc-cmos.c",
  "hash_id": "521f6120505e4b6c23784eb68835eca3c993309966bb7a22d900a3685d2349d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-cmos.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/log2.h>\n#include <linux/pm.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#ifdef CONFIG_X86\n#include <asm/i8259.h>\n#include <asm/processor.h>\n#include <linux/dmi.h>\n#endif\n\n \n#include <linux/mc146818rtc.h>\n\n#ifdef CONFIG_ACPI\n \n\nstatic bool use_acpi_alarm;\nmodule_param(use_acpi_alarm, bool, 0444);\n\nstatic inline int cmos_use_acpi_alarm(void)\n{\n\treturn use_acpi_alarm;\n}\n#else  \n\nstatic inline int cmos_use_acpi_alarm(void)\n{\n\treturn 0;\n}\n#endif\n\nstruct cmos_rtc {\n\tstruct rtc_device\t*rtc;\n\tstruct device\t\t*dev;\n\tint\t\t\tirq;\n\tstruct resource\t\t*iomem;\n\ttime64_t\t\talarm_expires;\n\n\tvoid\t\t\t(*wake_on)(struct device *);\n\tvoid\t\t\t(*wake_off)(struct device *);\n\n\tu8\t\t\tenabled_wake;\n\tu8\t\t\tsuspend_ctrl;\n\n\t \n\tu8\t\t\tday_alrm;\n\tu8\t\t\tmon_alrm;\n\tu8\t\t\tcentury;\n\n\tstruct rtc_wkalrm\tsaved_wkalrm;\n};\n\n \n#define is_valid_irq(n)\t\t((n) > 0)\n\nstatic const char driver_name[] = \"rtc_cmos\";\n\n \n#define\tRTC_IRQMASK\t(RTC_PF | RTC_AF | RTC_UF)\n\nstatic inline int is_intr(u8 rtc_intr)\n{\n\tif (!(rtc_intr & RTC_IRQF))\n\t\treturn 0;\n\treturn rtc_intr & RTC_IRQMASK;\n}\n\n \n\n \n#ifdef CONFIG_HPET_EMULATE_RTC\n#include <asm/hpet.h>\n#else\n\nstatic inline int is_hpet_enabled(void)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_mask_rtc_irq_bit(unsigned long mask)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_set_rtc_irq_bit(unsigned long mask)\n{\n\treturn 0;\n}\n\nstatic inline int\nhpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_set_periodic_freq(unsigned long freq)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_rtc_dropped_irq(void)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_rtc_timer_init(void)\n{\n\treturn 0;\n}\n\nextern irq_handler_t hpet_rtc_interrupt;\n\nstatic inline int hpet_register_irq_handler(irq_handler_t handler)\n{\n\treturn 0;\n}\n\nstatic inline int hpet_unregister_irq_handler(irq_handler_t handler)\n{\n\treturn 0;\n}\n\n#endif\n\n \nstatic inline int use_hpet_alarm(void)\n{\n\treturn is_hpet_enabled() && !cmos_use_acpi_alarm();\n}\n\n \n\n#ifdef RTC_PORT\n\n \n#define can_bank2\ttrue\n\nstatic inline unsigned char cmos_read_bank2(unsigned char addr)\n{\n\toutb(addr, RTC_PORT(2));\n\treturn inb(RTC_PORT(3));\n}\n\nstatic inline void cmos_write_bank2(unsigned char val, unsigned char addr)\n{\n\toutb(addr, RTC_PORT(2));\n\toutb(val, RTC_PORT(3));\n}\n\n#else\n\n#define can_bank2\tfalse\n\nstatic inline unsigned char cmos_read_bank2(unsigned char addr)\n{\n\treturn 0;\n}\n\nstatic inline void cmos_write_bank2(unsigned char val, unsigned char addr)\n{\n}\n\n#endif\n\n \n\nstatic int cmos_read_time(struct device *dev, struct rtc_time *t)\n{\n\tint ret;\n\n\t \n\tif (!pm_trace_rtc_valid())\n\t\treturn -EIO;\n\n\tret = mc146818_get_time(t);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(dev, \"unable to read current time\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cmos_set_time(struct device *dev, struct rtc_time *t)\n{\n\t \n\treturn mc146818_set_time(t);\n}\n\nstruct cmos_read_alarm_callback_param {\n\tstruct cmos_rtc *cmos;\n\tstruct rtc_time *time;\n\tunsigned char\trtc_control;\n};\n\nstatic void cmos_read_alarm_callback(unsigned char __always_unused seconds,\n\t\t\t\t     void *param_in)\n{\n\tstruct cmos_read_alarm_callback_param *p =\n\t\t(struct cmos_read_alarm_callback_param *)param_in;\n\tstruct rtc_time *time = p->time;\n\n\ttime->tm_sec = CMOS_READ(RTC_SECONDS_ALARM);\n\ttime->tm_min = CMOS_READ(RTC_MINUTES_ALARM);\n\ttime->tm_hour = CMOS_READ(RTC_HOURS_ALARM);\n\n\tif (p->cmos->day_alrm) {\n\t\t \n\t\ttime->tm_mday = CMOS_READ(p->cmos->day_alrm) & 0x3f;\n\t\tif (!time->tm_mday)\n\t\t\ttime->tm_mday = -1;\n\n\t\tif (p->cmos->mon_alrm) {\n\t\t\ttime->tm_mon = CMOS_READ(p->cmos->mon_alrm);\n\t\t\tif (!time->tm_mon)\n\t\t\t\ttime->tm_mon = -1;\n\t\t}\n\t}\n\n\tp->rtc_control = CMOS_READ(RTC_CONTROL);\n}\n\nstatic int cmos_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tstruct cmos_read_alarm_callback_param p = {\n\t\t.cmos = cmos,\n\t\t.time = &t->time,\n\t};\n\n\t \n\tif (!is_valid_irq(cmos->irq))\n\t\treturn -EIO;\n\n\t \n\n\t \n\tif (!mc146818_avoid_UIP(cmos_read_alarm_callback, &p))\n\t\treturn -EIO;\n\n\tif (!(p.rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {\n\t\tif (((unsigned)t->time.tm_sec) < 0x60)\n\t\t\tt->time.tm_sec = bcd2bin(t->time.tm_sec);\n\t\telse\n\t\t\tt->time.tm_sec = -1;\n\t\tif (((unsigned)t->time.tm_min) < 0x60)\n\t\t\tt->time.tm_min = bcd2bin(t->time.tm_min);\n\t\telse\n\t\t\tt->time.tm_min = -1;\n\t\tif (((unsigned)t->time.tm_hour) < 0x24)\n\t\t\tt->time.tm_hour = bcd2bin(t->time.tm_hour);\n\t\telse\n\t\t\tt->time.tm_hour = -1;\n\n\t\tif (cmos->day_alrm) {\n\t\t\tif (((unsigned)t->time.tm_mday) <= 0x31)\n\t\t\t\tt->time.tm_mday = bcd2bin(t->time.tm_mday);\n\t\t\telse\n\t\t\t\tt->time.tm_mday = -1;\n\n\t\t\tif (cmos->mon_alrm) {\n\t\t\t\tif (((unsigned)t->time.tm_mon) <= 0x12)\n\t\t\t\t\tt->time.tm_mon = bcd2bin(t->time.tm_mon)-1;\n\t\t\t\telse\n\t\t\t\t\tt->time.tm_mon = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tt->enabled = !!(p.rtc_control & RTC_AIE);\n\tt->pending = 0;\n\n\treturn 0;\n}\n\nstatic void cmos_checkintr(struct cmos_rtc *cmos, unsigned char rtc_control)\n{\n\tunsigned char\trtc_intr;\n\n\t \n\trtc_intr = CMOS_READ(RTC_INTR_FLAGS);\n\n\tif (use_hpet_alarm())\n\t\treturn;\n\n\trtc_intr &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;\n\tif (is_intr(rtc_intr))\n\t\trtc_update_irq(cmos->rtc, 1, rtc_intr);\n}\n\nstatic void cmos_irq_enable(struct cmos_rtc *cmos, unsigned char mask)\n{\n\tunsigned char\trtc_control;\n\n\t \n\trtc_control = CMOS_READ(RTC_CONTROL);\n\tcmos_checkintr(cmos, rtc_control);\n\n\trtc_control |= mask;\n\tCMOS_WRITE(rtc_control, RTC_CONTROL);\n\tif (use_hpet_alarm())\n\t\thpet_set_rtc_irq_bit(mask);\n\n\tif ((mask & RTC_AIE) && cmos_use_acpi_alarm()) {\n\t\tif (cmos->wake_on)\n\t\t\tcmos->wake_on(cmos->dev);\n\t}\n\n\tcmos_checkintr(cmos, rtc_control);\n}\n\nstatic void cmos_irq_disable(struct cmos_rtc *cmos, unsigned char mask)\n{\n\tunsigned char\trtc_control;\n\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\trtc_control &= ~mask;\n\tCMOS_WRITE(rtc_control, RTC_CONTROL);\n\tif (use_hpet_alarm())\n\t\thpet_mask_rtc_irq_bit(mask);\n\n\tif ((mask & RTC_AIE) && cmos_use_acpi_alarm()) {\n\t\tif (cmos->wake_off)\n\t\t\tcmos->wake_off(cmos->dev);\n\t}\n\n\tcmos_checkintr(cmos, rtc_control);\n}\n\nstatic int cmos_validate_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct cmos_rtc *cmos = dev_get_drvdata(dev);\n\tstruct rtc_time now;\n\n\tcmos_read_time(dev, &now);\n\n\tif (!cmos->day_alrm) {\n\t\ttime64_t t_max_date;\n\t\ttime64_t t_alrm;\n\n\t\tt_max_date = rtc_tm_to_time64(&now);\n\t\tt_max_date += 24 * 60 * 60 - 1;\n\t\tt_alrm = rtc_tm_to_time64(&t->time);\n\t\tif (t_alrm > t_max_date) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Alarms can be up to one day in the future\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!cmos->mon_alrm) {\n\t\tstruct rtc_time max_date = now;\n\t\ttime64_t t_max_date;\n\t\ttime64_t t_alrm;\n\t\tint max_mday;\n\n\t\tif (max_date.tm_mon == 11) {\n\t\t\tmax_date.tm_mon = 0;\n\t\t\tmax_date.tm_year += 1;\n\t\t} else {\n\t\t\tmax_date.tm_mon += 1;\n\t\t}\n\t\tmax_mday = rtc_month_days(max_date.tm_mon, max_date.tm_year);\n\t\tif (max_date.tm_mday > max_mday)\n\t\t\tmax_date.tm_mday = max_mday;\n\n\t\tt_max_date = rtc_tm_to_time64(&max_date);\n\t\tt_max_date -= 1;\n\t\tt_alrm = rtc_tm_to_time64(&t->time);\n\t\tif (t_alrm > t_max_date) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Alarms can be up to one month in the future\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tstruct rtc_time max_date = now;\n\t\ttime64_t t_max_date;\n\t\ttime64_t t_alrm;\n\t\tint max_mday;\n\n\t\tmax_date.tm_year += 1;\n\t\tmax_mday = rtc_month_days(max_date.tm_mon, max_date.tm_year);\n\t\tif (max_date.tm_mday > max_mday)\n\t\t\tmax_date.tm_mday = max_mday;\n\n\t\tt_max_date = rtc_tm_to_time64(&max_date);\n\t\tt_max_date -= 1;\n\t\tt_alrm = rtc_tm_to_time64(&t->time);\n\t\tif (t_alrm > t_max_date) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Alarms can be up to one year in the future\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct cmos_set_alarm_callback_param {\n\tstruct cmos_rtc *cmos;\n\tunsigned char mon, mday, hrs, min, sec;\n\tstruct rtc_wkalrm *t;\n};\n\n \nstatic void cmos_set_alarm_callback(unsigned char __always_unused seconds,\n\t\t\t\t    void *param_in)\n{\n\tstruct cmos_set_alarm_callback_param *p =\n\t\t(struct cmos_set_alarm_callback_param *)param_in;\n\n\t \n\tcmos_irq_disable(p->cmos, RTC_AIE);\n\n\t \n\tCMOS_WRITE(p->hrs, RTC_HOURS_ALARM);\n\tCMOS_WRITE(p->min, RTC_MINUTES_ALARM);\n\tCMOS_WRITE(p->sec, RTC_SECONDS_ALARM);\n\n\t \n\tif (p->cmos->day_alrm) {\n\t\tCMOS_WRITE(p->mday, p->cmos->day_alrm);\n\t\tif (p->cmos->mon_alrm)\n\t\t\tCMOS_WRITE(p->mon, p->cmos->mon_alrm);\n\t}\n\n\tif (use_hpet_alarm()) {\n\t\t \n\t\thpet_set_alarm_time(p->t->time.tm_hour, p->t->time.tm_min,\n\t\t\t\t    p->t->time.tm_sec);\n\t}\n\n\tif (p->t->enabled)\n\t\tcmos_irq_enable(p->cmos, RTC_AIE);\n}\n\nstatic int cmos_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tstruct cmos_set_alarm_callback_param p = {\n\t\t.cmos = cmos,\n\t\t.t = t\n\t};\n\tunsigned char rtc_control;\n\tint ret;\n\n\t \n\tif (!is_valid_irq(cmos->irq))\n\t\treturn -EIO;\n\n\tret = cmos_validate_alarm(dev, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tp.mon = t->time.tm_mon + 1;\n\tp.mday = t->time.tm_mday;\n\tp.hrs = t->time.tm_hour;\n\tp.min = t->time.tm_min;\n\tp.sec = t->time.tm_sec;\n\n\tspin_lock_irq(&rtc_lock);\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\tspin_unlock_irq(&rtc_lock);\n\n\tif (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {\n\t\t \n\t\tp.mon = (p.mon <= 12) ? bin2bcd(p.mon) : 0xff;\n\t\tp.mday = (p.mday >= 1 && p.mday <= 31) ? bin2bcd(p.mday) : 0xff;\n\t\tp.hrs = (p.hrs < 24) ? bin2bcd(p.hrs) : 0xff;\n\t\tp.min = (p.min < 60) ? bin2bcd(p.min) : 0xff;\n\t\tp.sec = (p.sec < 60) ? bin2bcd(p.sec) : 0xff;\n\t}\n\n\t \n\tif (!mc146818_avoid_UIP(cmos_set_alarm_callback, &p))\n\t\treturn -EIO;\n\n\tcmos->alarm_expires = rtc_tm_to_time64(&t->time);\n\n\treturn 0;\n}\n\nstatic int cmos_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\n\tif (enabled)\n\t\tcmos_irq_enable(cmos, RTC_AIE);\n\telse\n\t\tcmos_irq_disable(cmos, RTC_AIE);\n\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_RTC_INTF_PROC)\n\nstatic int cmos_procfs(struct device *dev, struct seq_file *seq)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tunsigned char\trtc_control, valid;\n\n\tspin_lock_irq(&rtc_lock);\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\tvalid = CMOS_READ(RTC_VALID);\n\tspin_unlock_irq(&rtc_lock);\n\n\t \n\tseq_printf(seq,\n\t\t   \"periodic_IRQ\\t: %s\\n\"\n\t\t   \"update_IRQ\\t: %s\\n\"\n\t\t   \"HPET_emulated\\t: %s\\n\"\n\t\t   \n\t\t   \"BCD\\t\\t: %s\\n\"\n\t\t   \"DST_enable\\t: %s\\n\"\n\t\t   \"periodic_freq\\t: %d\\n\"\n\t\t   \"batt_status\\t: %s\\n\",\n\t\t   (rtc_control & RTC_PIE) ? \"yes\" : \"no\",\n\t\t   (rtc_control & RTC_UIE) ? \"yes\" : \"no\",\n\t\t   use_hpet_alarm() ? \"yes\" : \"no\",\n\t\t   \n\t\t   (rtc_control & RTC_DM_BINARY) ? \"no\" : \"yes\",\n\t\t   (rtc_control & RTC_DST_EN) ? \"yes\" : \"no\",\n\t\t   cmos->rtc->irq_freq,\n\t\t   (valid & RTC_VRT) ? \"okay\" : \"dead\");\n\n\treturn 0;\n}\n\n#else\n#define\tcmos_procfs\tNULL\n#endif\n\nstatic const struct rtc_class_ops cmos_rtc_ops = {\n\t.read_time\t\t= cmos_read_time,\n\t.set_time\t\t= cmos_set_time,\n\t.read_alarm\t\t= cmos_read_alarm,\n\t.set_alarm\t\t= cmos_set_alarm,\n\t.proc\t\t\t= cmos_procfs,\n\t.alarm_irq_enable\t= cmos_alarm_irq_enable,\n};\n\n \n\n \n\n#define NVRAM_OFFSET\t(RTC_REG_D + 1)\n\nstatic int cmos_nvram_read(void *priv, unsigned int off, void *val,\n\t\t\t   size_t count)\n{\n\tunsigned char *buf = val;\n\tint\tretval;\n\n\toff += NVRAM_OFFSET;\n\tspin_lock_irq(&rtc_lock);\n\tfor (retval = 0; count; count--, off++, retval++) {\n\t\tif (off < 128)\n\t\t\t*buf++ = CMOS_READ(off);\n\t\telse if (can_bank2)\n\t\t\t*buf++ = cmos_read_bank2(off);\n\t\telse\n\t\t\tbreak;\n\t}\n\tspin_unlock_irq(&rtc_lock);\n\n\treturn retval;\n}\n\nstatic int cmos_nvram_write(void *priv, unsigned int off, void *val,\n\t\t\t    size_t count)\n{\n\tstruct cmos_rtc\t*cmos = priv;\n\tunsigned char\t*buf = val;\n\tint\t\tretval;\n\n\t \n\toff += NVRAM_OFFSET;\n\tspin_lock_irq(&rtc_lock);\n\tfor (retval = 0; count; count--, off++, retval++) {\n\t\t \n\t\tif (off == cmos->day_alrm\n\t\t\t\t|| off == cmos->mon_alrm\n\t\t\t\t|| off == cmos->century)\n\t\t\tbuf++;\n\t\telse if (off < 128)\n\t\t\tCMOS_WRITE(*buf++, off);\n\t\telse if (can_bank2)\n\t\t\tcmos_write_bank2(*buf++, off);\n\t\telse\n\t\t\tbreak;\n\t}\n\tspin_unlock_irq(&rtc_lock);\n\n\treturn retval;\n}\n\n \n\nstatic struct cmos_rtc\tcmos_rtc;\n\nstatic irqreturn_t cmos_interrupt(int irq, void *p)\n{\n\tu8\t\tirqstat;\n\tu8\t\trtc_control;\n\n\tspin_lock(&rtc_lock);\n\n\t \n\tirqstat = CMOS_READ(RTC_INTR_FLAGS);\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\tif (use_hpet_alarm())\n\t\tirqstat = (unsigned long)irq & 0xF0;\n\n\t \n\tif (!cmos_rtc.suspend_ctrl)\n\t\tirqstat &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;\n\telse\n\t\tirqstat &= (cmos_rtc.suspend_ctrl & RTC_IRQMASK) | RTC_IRQF;\n\n\t \n\tif (irqstat & RTC_AIE) {\n\t\tcmos_rtc.suspend_ctrl &= ~RTC_AIE;\n\t\trtc_control &= ~RTC_AIE;\n\t\tCMOS_WRITE(rtc_control, RTC_CONTROL);\n\t\tif (use_hpet_alarm())\n\t\t\thpet_mask_rtc_irq_bit(RTC_AIE);\n\t\tCMOS_READ(RTC_INTR_FLAGS);\n\t}\n\tspin_unlock(&rtc_lock);\n\n\tif (is_intr(irqstat)) {\n\t\trtc_update_irq(p, 1, irqstat);\n\t\treturn IRQ_HANDLED;\n\t} else\n\t\treturn IRQ_NONE;\n}\n\n#ifdef\tCONFIG_ACPI\n\n#include <linux/acpi.h>\n\nstatic u32 rtc_handler(void *context)\n{\n\tstruct device *dev = context;\n\tstruct cmos_rtc *cmos = dev_get_drvdata(dev);\n\tunsigned char rtc_control = 0;\n\tunsigned char rtc_intr;\n\tunsigned long flags;\n\n\n\t \n\tif (cmos_use_acpi_alarm())\n\t\tcmos_interrupt(0, (void *)cmos->rtc);\n\telse {\n\t\t \n\t\tspin_lock_irqsave(&rtc_lock, flags);\n\t\tif (cmos_rtc.suspend_ctrl)\n\t\t\trtc_control = CMOS_READ(RTC_CONTROL);\n\t\tif (rtc_control & RTC_AIE) {\n\t\t\tcmos_rtc.suspend_ctrl &= ~RTC_AIE;\n\t\t\tCMOS_WRITE(rtc_control, RTC_CONTROL);\n\t\t\trtc_intr = CMOS_READ(RTC_INTR_FLAGS);\n\t\t\trtc_update_irq(cmos->rtc, 1, rtc_intr);\n\t\t}\n\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\t}\n\n\tpm_wakeup_hard_event(dev);\n\tacpi_clear_event(ACPI_EVENT_RTC);\n\tacpi_disable_event(ACPI_EVENT_RTC, 0);\n\treturn ACPI_INTERRUPT_HANDLED;\n}\n\nstatic void acpi_rtc_event_setup(struct device *dev)\n{\n\tif (acpi_disabled)\n\t\treturn;\n\n\tacpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, dev);\n\t \n\tacpi_clear_event(ACPI_EVENT_RTC);\n\tacpi_disable_event(ACPI_EVENT_RTC, 0);\n}\n\nstatic void acpi_rtc_event_cleanup(void)\n{\n\tif (acpi_disabled)\n\t\treturn;\n\n\tacpi_remove_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler);\n}\n\nstatic void rtc_wake_on(struct device *dev)\n{\n\tacpi_clear_event(ACPI_EVENT_RTC);\n\tacpi_enable_event(ACPI_EVENT_RTC, 0);\n}\n\nstatic void rtc_wake_off(struct device *dev)\n{\n\tacpi_disable_event(ACPI_EVENT_RTC, 0);\n}\n\n#ifdef CONFIG_X86\n \nstatic void use_acpi_alarm_quirks(void)\n{\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn;\n\n\tif (!is_hpet_enabled())\n\t\treturn;\n\n\tif (dmi_get_bios_year() < 2015)\n\t\treturn;\n\n\tuse_acpi_alarm = true;\n}\n#else\nstatic inline void use_acpi_alarm_quirks(void) { }\n#endif\n\nstatic void acpi_cmos_wake_setup(struct device *dev)\n{\n\tif (acpi_disabled)\n\t\treturn;\n\n\tuse_acpi_alarm_quirks();\n\n\tcmos_rtc.wake_on = rtc_wake_on;\n\tcmos_rtc.wake_off = rtc_wake_off;\n\n\t \n\tif (acpi_gbl_FADT.month_alarm && !acpi_gbl_FADT.day_alarm) {\n\t\tdev_dbg(dev, \"bogus FADT month_alarm (%d)\\n\",\n\t\t\tacpi_gbl_FADT.month_alarm);\n\t\tacpi_gbl_FADT.month_alarm = 0;\n\t}\n\n\tcmos_rtc.day_alrm = acpi_gbl_FADT.day_alarm;\n\tcmos_rtc.mon_alrm = acpi_gbl_FADT.month_alarm;\n\tcmos_rtc.century = acpi_gbl_FADT.century;\n\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)\n\t\tdev_info(dev, \"RTC can wake from S4\\n\");\n\n\t \n\tdevice_init_wakeup(dev, 1);\n}\n\nstatic void cmos_check_acpi_rtc_status(struct device *dev,\n\t\t\t\t\t      unsigned char *rtc_control)\n{\n\tstruct cmos_rtc *cmos = dev_get_drvdata(dev);\n\tacpi_event_status rtc_status;\n\tacpi_status status;\n\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_FIXED_RTC)\n\t\treturn;\n\n\tstatus = acpi_get_event_status(ACPI_EVENT_RTC, &rtc_status);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"Could not get RTC status\\n\");\n\t} else if (rtc_status & ACPI_EVENT_FLAG_SET) {\n\t\tunsigned char mask;\n\t\t*rtc_control &= ~RTC_AIE;\n\t\tCMOS_WRITE(*rtc_control, RTC_CONTROL);\n\t\tmask = CMOS_READ(RTC_INTR_FLAGS);\n\t\trtc_update_irq(cmos->rtc, 1, mask);\n\t}\n}\n\n#else  \n\nstatic inline void acpi_rtc_event_setup(struct device *dev)\n{\n}\n\nstatic inline void acpi_rtc_event_cleanup(void)\n{\n}\n\nstatic inline void acpi_cmos_wake_setup(struct device *dev)\n{\n}\n\nstatic inline void cmos_check_acpi_rtc_status(struct device *dev,\n\t\t\t\t\t      unsigned char *rtc_control)\n{\n}\n#endif  \n\n#ifdef\tCONFIG_PNP\n#define\tINITSECTION\n\n#else\n#define\tINITSECTION\t__init\n#endif\n\n#define SECS_PER_DAY\t(24 * 60 * 60)\n#define SECS_PER_MONTH\t(28 * SECS_PER_DAY)\n#define SECS_PER_YEAR\t(365 * SECS_PER_DAY)\n\nstatic int INITSECTION\ncmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)\n{\n\tstruct cmos_rtc_board_info\t*info = dev_get_platdata(dev);\n\tint\t\t\t\tretval = 0;\n\tunsigned char\t\t\trtc_control;\n\tunsigned\t\t\taddress_space;\n\tu32\t\t\t\tflags = 0;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"cmos_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.reg_read = cmos_nvram_read,\n\t\t.reg_write = cmos_nvram_write,\n\t\t.priv = &cmos_rtc,\n\t};\n\n\t \n\tif (cmos_rtc.dev)\n\t\treturn -EBUSY;\n\n\tif (!ports)\n\t\treturn -ENODEV;\n\n\t \n\tif (RTC_IOMAPPED)\n\t\tports = request_region(ports->start, resource_size(ports),\n\t\t\t\t       driver_name);\n\telse\n\t\tports = request_mem_region(ports->start, resource_size(ports),\n\t\t\t\t\t   driver_name);\n\tif (!ports) {\n\t\tdev_dbg(dev, \"i/o registers already in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmos_rtc.irq = rtc_irq;\n\tcmos_rtc.iomem = ports;\n\n\t \n#if\tdefined(CONFIG_ATARI)\n\taddress_space = 64;\n#elif defined(__i386__) || defined(__x86_64__) || defined(__arm__) \\\n\t\t\t|| defined(__sparc__) || defined(__mips__) \\\n\t\t\t|| defined(__powerpc__)\n\taddress_space = 128;\n#else\n#warning Assuming 128 bytes of RTC+NVRAM address space, not 64 bytes.\n\taddress_space = 128;\n#endif\n\tif (can_bank2 && ports->end > (ports->start + 1))\n\t\taddress_space = 256;\n\n\t \n\tif (info) {\n\t\tif (info->flags)\n\t\t\tflags = info->flags;\n\t\tif (info->address_space)\n\t\t\taddress_space = info->address_space;\n\n\t\tcmos_rtc.day_alrm = info->rtc_day_alarm;\n\t\tcmos_rtc.mon_alrm = info->rtc_mon_alarm;\n\t\tcmos_rtc.century = info->rtc_century;\n\n\t\tif (info->wake_on && info->wake_off) {\n\t\t\tcmos_rtc.wake_on = info->wake_on;\n\t\t\tcmos_rtc.wake_off = info->wake_off;\n\t\t}\n\t} else {\n\t\tacpi_cmos_wake_setup(dev);\n\t}\n\n\tif (cmos_rtc.day_alrm >= 128)\n\t\tcmos_rtc.day_alrm = 0;\n\n\tif (cmos_rtc.mon_alrm >= 128)\n\t\tcmos_rtc.mon_alrm = 0;\n\n\tif (cmos_rtc.century >= 128)\n\t\tcmos_rtc.century = 0;\n\n\tcmos_rtc.dev = dev;\n\tdev_set_drvdata(dev, &cmos_rtc);\n\n\tcmos_rtc.rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(cmos_rtc.rtc)) {\n\t\tretval = PTR_ERR(cmos_rtc.rtc);\n\t\tgoto cleanup0;\n\t}\n\n\tif (cmos_rtc.mon_alrm)\n\t\tcmos_rtc.rtc->alarm_offset_max = SECS_PER_YEAR - 1;\n\telse if (cmos_rtc.day_alrm)\n\t\tcmos_rtc.rtc->alarm_offset_max = SECS_PER_MONTH - 1;\n\telse\n\t\tcmos_rtc.rtc->alarm_offset_max = SECS_PER_DAY - 1;\n\n\trename_region(ports, dev_name(&cmos_rtc.rtc->dev));\n\n\tif (!mc146818_does_rtc_work()) {\n\t\tdev_warn(dev, \"broken or not accessible\\n\");\n\t\tretval = -ENXIO;\n\t\tgoto cleanup1;\n\t}\n\n\tspin_lock_irq(&rtc_lock);\n\n\tif (!(flags & CMOS_RTC_FLAGS_NOFREQ)) {\n\t\t \n\t\tcmos_rtc.rtc->irq_freq = 1024;\n\t\tif (use_hpet_alarm())\n\t\t\thpet_set_periodic_freq(cmos_rtc.rtc->irq_freq);\n\t\tCMOS_WRITE(RTC_REF_CLCK_32KHZ | 0x06, RTC_FREQ_SELECT);\n\t}\n\n\t \n\tif (is_valid_irq(rtc_irq))\n\t\tcmos_irq_disable(&cmos_rtc, RTC_PIE | RTC_AIE | RTC_UIE);\n\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\n\tspin_unlock_irq(&rtc_lock);\n\n\tif (is_valid_irq(rtc_irq) && !(rtc_control & RTC_24H)) {\n\t\tdev_warn(dev, \"only 24-hr supported\\n\");\n\t\tretval = -ENXIO;\n\t\tgoto cleanup1;\n\t}\n\n\tif (use_hpet_alarm())\n\t\thpet_rtc_timer_init();\n\n\tif (is_valid_irq(rtc_irq)) {\n\t\tirq_handler_t rtc_cmos_int_handler;\n\n\t\tif (use_hpet_alarm()) {\n\t\t\trtc_cmos_int_handler = hpet_rtc_interrupt;\n\t\t\tretval = hpet_register_irq_handler(cmos_interrupt);\n\t\t\tif (retval) {\n\t\t\t\thpet_mask_rtc_irq_bit(RTC_IRQMASK);\n\t\t\t\tdev_warn(dev, \"hpet_register_irq_handler \"\n\t\t\t\t\t\t\" failed in rtc_init().\");\n\t\t\t\tgoto cleanup1;\n\t\t\t}\n\t\t} else\n\t\t\trtc_cmos_int_handler = cmos_interrupt;\n\n\t\tretval = request_irq(rtc_irq, rtc_cmos_int_handler,\n\t\t\t\t0, dev_name(&cmos_rtc.rtc->dev),\n\t\t\t\tcmos_rtc.rtc);\n\t\tif (retval < 0) {\n\t\t\tdev_dbg(dev, \"IRQ %d is already in use\\n\", rtc_irq);\n\t\t\tgoto cleanup1;\n\t\t}\n\t} else {\n\t\tclear_bit(RTC_FEATURE_ALARM, cmos_rtc.rtc->features);\n\t}\n\n\tcmos_rtc.rtc->ops = &cmos_rtc_ops;\n\n\tretval = devm_rtc_register_device(cmos_rtc.rtc);\n\tif (retval)\n\t\tgoto cleanup2;\n\n\t \n\tcmos_rtc.rtc->set_offset_nsec = NSEC_PER_SEC / 2;\n\n\t \n\tnvmem_cfg.size = address_space - NVRAM_OFFSET;\n\tdevm_rtc_nvmem_register(cmos_rtc.rtc, &nvmem_cfg);\n\n\t \n\tif (!info)\n\t\tacpi_rtc_event_setup(dev);\n\n\tdev_info(dev, \"%s%s, %d bytes nvram%s\\n\",\n\t\t !is_valid_irq(rtc_irq) ? \"no alarms\" :\n\t\t cmos_rtc.mon_alrm ? \"alarms up to one year\" :\n\t\t cmos_rtc.day_alrm ? \"alarms up to one month\" :\n\t\t \"alarms up to one day\",\n\t\t cmos_rtc.century ? \", y3k\" : \"\",\n\t\t nvmem_cfg.size,\n\t\t use_hpet_alarm() ? \", hpet irqs\" : \"\");\n\n\treturn 0;\n\ncleanup2:\n\tif (is_valid_irq(rtc_irq))\n\t\tfree_irq(rtc_irq, cmos_rtc.rtc);\ncleanup1:\n\tcmos_rtc.dev = NULL;\ncleanup0:\n\tif (RTC_IOMAPPED)\n\t\trelease_region(ports->start, resource_size(ports));\n\telse\n\t\trelease_mem_region(ports->start, resource_size(ports));\n\treturn retval;\n}\n\nstatic void cmos_do_shutdown(int rtc_irq)\n{\n\tspin_lock_irq(&rtc_lock);\n\tif (is_valid_irq(rtc_irq))\n\t\tcmos_irq_disable(&cmos_rtc, RTC_IRQMASK);\n\tspin_unlock_irq(&rtc_lock);\n}\n\nstatic void cmos_do_remove(struct device *dev)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tstruct resource *ports;\n\n\tcmos_do_shutdown(cmos->irq);\n\n\tif (is_valid_irq(cmos->irq)) {\n\t\tfree_irq(cmos->irq, cmos->rtc);\n\t\tif (use_hpet_alarm())\n\t\t\thpet_unregister_irq_handler(cmos_interrupt);\n\t}\n\n\tif (!dev_get_platdata(dev))\n\t\tacpi_rtc_event_cleanup();\n\n\tcmos->rtc = NULL;\n\n\tports = cmos->iomem;\n\tif (RTC_IOMAPPED)\n\t\trelease_region(ports->start, resource_size(ports));\n\telse\n\t\trelease_mem_region(ports->start, resource_size(ports));\n\tcmos->iomem = NULL;\n\n\tcmos->dev = NULL;\n}\n\nstatic int cmos_aie_poweroff(struct device *dev)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tstruct rtc_time now;\n\ttime64_t t_now;\n\tint retval = 0;\n\tunsigned char rtc_control;\n\n\tif (!cmos->alarm_expires)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&rtc_lock);\n\trtc_control = CMOS_READ(RTC_CONTROL);\n\tspin_unlock_irq(&rtc_lock);\n\n\t \n\tif (rtc_control & RTC_AIE)\n\t\treturn -EBUSY;\n\n\tcmos_read_time(dev, &now);\n\tt_now = rtc_tm_to_time64(&now);\n\n\t \n\tif (cmos->alarm_expires == t_now + 1) {\n\t\tstruct rtc_wkalrm alarm;\n\n\t\t \n\t\trtc_time64_to_tm(t_now - 1, &alarm.time);\n\t\talarm.enabled = 0;\n\t\tretval = cmos_set_alarm(dev, &alarm);\n\t} else if (cmos->alarm_expires > t_now + 1) {\n\t\tretval = -EBUSY;\n\t}\n\n\treturn retval;\n}\n\nstatic int cmos_suspend(struct device *dev)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tunsigned char\ttmp;\n\n\t \n\tspin_lock_irq(&rtc_lock);\n\tcmos->suspend_ctrl = tmp = CMOS_READ(RTC_CONTROL);\n\tif (tmp & (RTC_PIE|RTC_AIE|RTC_UIE)) {\n\t\tunsigned char\tmask;\n\n\t\tif (device_may_wakeup(dev))\n\t\t\tmask = RTC_IRQMASK & ~RTC_AIE;\n\t\telse\n\t\t\tmask = RTC_IRQMASK;\n\t\ttmp &= ~mask;\n\t\tCMOS_WRITE(tmp, RTC_CONTROL);\n\t\tif (use_hpet_alarm())\n\t\t\thpet_mask_rtc_irq_bit(mask);\n\t\tcmos_checkintr(cmos, tmp);\n\t}\n\tspin_unlock_irq(&rtc_lock);\n\n\tif ((tmp & RTC_AIE) && !cmos_use_acpi_alarm()) {\n\t\tcmos->enabled_wake = 1;\n\t\tif (cmos->wake_on)\n\t\t\tcmos->wake_on(dev);\n\t\telse\n\t\t\tenable_irq_wake(cmos->irq);\n\t}\n\n\tmemset(&cmos->saved_wkalrm, 0, sizeof(struct rtc_wkalrm));\n\tcmos_read_alarm(dev, &cmos->saved_wkalrm);\n\n\tdev_dbg(dev, \"suspend%s, ctrl %02x\\n\",\n\t\t\t(tmp & RTC_AIE) ? \", alarm may wake\" : \"\",\n\t\t\ttmp);\n\n\treturn 0;\n}\n\n \nstatic inline int cmos_poweroff(struct device *dev)\n{\n\tif (!IS_ENABLED(CONFIG_PM))\n\t\treturn -ENOSYS;\n\n\treturn cmos_suspend(dev);\n}\n\nstatic void cmos_check_wkalrm(struct device *dev)\n{\n\tstruct cmos_rtc *cmos = dev_get_drvdata(dev);\n\tstruct rtc_wkalrm current_alarm;\n\ttime64_t t_now;\n\ttime64_t t_current_expires;\n\ttime64_t t_saved_expires;\n\tstruct rtc_time now;\n\n\t \n\tif (!(cmos->suspend_ctrl & RTC_AIE))\n\t\treturn;\n\n\tcmos_read_time(dev, &now);\n\tt_now = rtc_tm_to_time64(&now);\n\n\t \n\tif (t_now >= cmos->alarm_expires && cmos_use_acpi_alarm()) {\n\t\tlocal_irq_disable();\n\t\tcmos_interrupt(0, (void *)cmos->rtc);\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\tmemset(&current_alarm, 0, sizeof(struct rtc_wkalrm));\n\tcmos_read_alarm(dev, &current_alarm);\n\tt_current_expires = rtc_tm_to_time64(&current_alarm.time);\n\tt_saved_expires = rtc_tm_to_time64(&cmos->saved_wkalrm.time);\n\tif (t_current_expires != t_saved_expires ||\n\t    cmos->saved_wkalrm.enabled != current_alarm.enabled) {\n\t\tcmos_set_alarm(dev, &cmos->saved_wkalrm);\n\t}\n}\n\nstatic int __maybe_unused cmos_resume(struct device *dev)\n{\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\tunsigned char tmp;\n\n\tif (cmos->enabled_wake && !cmos_use_acpi_alarm()) {\n\t\tif (cmos->wake_off)\n\t\t\tcmos->wake_off(dev);\n\t\telse\n\t\t\tdisable_irq_wake(cmos->irq);\n\t\tcmos->enabled_wake = 0;\n\t}\n\n\t \n\tcmos_check_wkalrm(dev);\n\n\tspin_lock_irq(&rtc_lock);\n\ttmp = cmos->suspend_ctrl;\n\tcmos->suspend_ctrl = 0;\n\t \n\tif (tmp & RTC_IRQMASK) {\n\t\tunsigned char\tmask;\n\n\t\tif (device_may_wakeup(dev) && use_hpet_alarm())\n\t\t\thpet_rtc_timer_init();\n\n\t\tdo {\n\t\t\tCMOS_WRITE(tmp, RTC_CONTROL);\n\t\t\tif (use_hpet_alarm())\n\t\t\t\thpet_set_rtc_irq_bit(tmp & RTC_IRQMASK);\n\n\t\t\tmask = CMOS_READ(RTC_INTR_FLAGS);\n\t\t\tmask &= (tmp & RTC_IRQMASK) | RTC_IRQF;\n\t\t\tif (!use_hpet_alarm() || !is_intr(mask))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\trtc_update_irq(cmos->rtc, 1, mask);\n\t\t\ttmp &= ~RTC_AIE;\n\t\t\thpet_mask_rtc_irq_bit(RTC_AIE);\n\t\t} while (mask & RTC_AIE);\n\n\t\tif (tmp & RTC_AIE)\n\t\t\tcmos_check_acpi_rtc_status(dev, &tmp);\n\t}\n\tspin_unlock_irq(&rtc_lock);\n\n\tdev_dbg(dev, \"resume, ctrl %02x\\n\", tmp);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cmos_pm_ops, cmos_suspend, cmos_resume);\n\n \n\n \n\n#ifdef\tCONFIG_PNP\n\n#include <linux/pnp.h>\n\nstatic int cmos_pnp_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)\n{\n\tint irq;\n\n\tif (pnp_port_start(pnp, 0) == 0x70 && !pnp_irq_valid(pnp, 0)) {\n\t\tirq = 0;\n#ifdef CONFIG_X86\n\t\t \n\t\tif (nr_legacy_irqs())\n\t\t\tirq = RTC_IRQ;\n#endif\n\t} else {\n\t\tirq = pnp_irq(pnp, 0);\n\t}\n\n\treturn cmos_do_probe(&pnp->dev, pnp_get_resource(pnp, IORESOURCE_IO, 0), irq);\n}\n\nstatic void cmos_pnp_remove(struct pnp_dev *pnp)\n{\n\tcmos_do_remove(&pnp->dev);\n}\n\nstatic void cmos_pnp_shutdown(struct pnp_dev *pnp)\n{\n\tstruct device *dev = &pnp->dev;\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tint retval = cmos_poweroff(dev);\n\n\t\tif (cmos_aie_poweroff(dev) < 0 && !retval)\n\t\t\treturn;\n\t}\n\n\tcmos_do_shutdown(cmos->irq);\n}\n\nstatic const struct pnp_device_id rtc_ids[] = {\n\t{ .id = \"PNP0b00\", },\n\t{ .id = \"PNP0b01\", },\n\t{ .id = \"PNP0b02\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pnp, rtc_ids);\n\nstatic struct pnp_driver cmos_pnp_driver = {\n\t.name\t\t= driver_name,\n\t.id_table\t= rtc_ids,\n\t.probe\t\t= cmos_pnp_probe,\n\t.remove\t\t= cmos_pnp_remove,\n\t.shutdown\t= cmos_pnp_shutdown,\n\n\t \n\t.flags\t\t= PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.driver\t\t= {\n\t\t\t.pm = &cmos_pm_ops,\n\t},\n};\n\n#endif\t \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_cmos_match[] = {\n\t{\n\t\t.compatible = \"motorola,mc146818\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_cmos_match);\n\nstatic __init void cmos_of_init(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst __be32 *val;\n\n\tif (!node)\n\t\treturn;\n\n\tval = of_get_property(node, \"ctrl-reg\", NULL);\n\tif (val)\n\t\tCMOS_WRITE(be32_to_cpup(val), RTC_CONTROL);\n\n\tval = of_get_property(node, \"freq-reg\", NULL);\n\tif (val)\n\t\tCMOS_WRITE(be32_to_cpup(val), RTC_FREQ_SELECT);\n}\n#else\nstatic inline void cmos_of_init(struct platform_device *pdev) {}\n#endif\n \n\n \n\nstatic int __init cmos_platform_probe(struct platform_device *pdev)\n{\n\tstruct resource *resource;\n\tint irq;\n\n\tcmos_of_init(pdev);\n\n\tif (RTC_IOMAPPED)\n\t\tresource = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\telse\n\t\tresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\tirq = -1;\n\n\treturn cmos_do_probe(&pdev->dev, resource, irq);\n}\n\nstatic void cmos_platform_remove(struct platform_device *pdev)\n{\n\tcmos_do_remove(&pdev->dev);\n}\n\nstatic void cmos_platform_shutdown(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cmos_rtc\t*cmos = dev_get_drvdata(dev);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tint retval = cmos_poweroff(dev);\n\n\t\tif (cmos_aie_poweroff(dev) < 0 && !retval)\n\t\t\treturn;\n\t}\n\n\tcmos_do_shutdown(cmos->irq);\n}\n\n \nMODULE_ALIAS(\"platform:rtc_cmos\");\n\nstatic struct platform_driver cmos_platform_driver = {\n\t.remove_new\t= cmos_platform_remove,\n\t.shutdown\t= cmos_platform_shutdown,\n\t.driver = {\n\t\t.name\t\t= driver_name,\n\t\t.pm\t\t= &cmos_pm_ops,\n\t\t.of_match_table = of_match_ptr(of_cmos_match),\n\t}\n};\n\n#ifdef CONFIG_PNP\nstatic bool pnp_driver_registered;\n#endif\nstatic bool platform_driver_registered;\n\nstatic int __init cmos_init(void)\n{\n\tint retval = 0;\n\n#ifdef\tCONFIG_PNP\n\tretval = pnp_register_driver(&cmos_pnp_driver);\n\tif (retval == 0)\n\t\tpnp_driver_registered = true;\n#endif\n\n\tif (!cmos_rtc.dev) {\n\t\tretval = platform_driver_probe(&cmos_platform_driver,\n\t\t\t\t\t       cmos_platform_probe);\n\t\tif (retval == 0)\n\t\t\tplatform_driver_registered = true;\n\t}\n\n\tif (retval == 0)\n\t\treturn 0;\n\n#ifdef\tCONFIG_PNP\n\tif (pnp_driver_registered)\n\t\tpnp_unregister_driver(&cmos_pnp_driver);\n#endif\n\treturn retval;\n}\nmodule_init(cmos_init);\n\nstatic void __exit cmos_exit(void)\n{\n#ifdef\tCONFIG_PNP\n\tif (pnp_driver_registered)\n\t\tpnp_unregister_driver(&cmos_pnp_driver);\n#endif\n\tif (platform_driver_registered)\n\t\tplatform_driver_unregister(&cmos_platform_driver);\n}\nmodule_exit(cmos_exit);\n\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"Driver for PC-style 'CMOS' RTCs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}