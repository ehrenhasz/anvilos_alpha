{
  "module_name": "class.c",
  "hash_id": "13e591e6f8fe6a1723e300c9e2ab33a52660d883bf6750f0ed9dd77b4d9c5ffe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/class.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/kdev_t.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"rtc-core.h\"\n\nstatic DEFINE_IDA(rtc_ida);\nstruct class *rtc_class;\n\nstatic void rtc_device_release(struct device *dev)\n{\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct timerqueue_head *head = &rtc->timerqueue;\n\tstruct timerqueue_node *node;\n\n\tmutex_lock(&rtc->ops_lock);\n\twhile ((node = timerqueue_getnext(head)))\n\t\ttimerqueue_del(head, node);\n\tmutex_unlock(&rtc->ops_lock);\n\n\tcancel_work_sync(&rtc->irqwork);\n\n\tida_free(&rtc_ida, rtc->id);\n\tmutex_destroy(&rtc->ops_lock);\n\tkfree(rtc);\n}\n\n#ifdef CONFIG_RTC_HCTOSYS_DEVICE\n \nint rtc_hctosys_ret = -ENODEV;\n\n \n\nstatic void rtc_hctosys(struct rtc_device *rtc)\n{\n\tint err;\n\tstruct rtc_time tm;\n\tstruct timespec64 tv64 = {\n\t\t.tv_nsec = NSEC_PER_SEC >> 1,\n\t};\n\n\terr = rtc_read_time(rtc, &tm);\n\tif (err) {\n\t\tdev_err(rtc->dev.parent,\n\t\t\t\"hctosys: unable to read the hardware clock\\n\");\n\t\tgoto err_read;\n\t}\n\n\ttv64.tv_sec = rtc_tm_to_time64(&tm);\n\n#if BITS_PER_LONG == 32\n\tif (tv64.tv_sec > INT_MAX) {\n\t\terr = -ERANGE;\n\t\tgoto err_read;\n\t}\n#endif\n\n\terr = do_settimeofday64(&tv64);\n\n\tdev_info(rtc->dev.parent, \"setting system clock to %ptR UTC (%lld)\\n\",\n\t\t &tm, (long long)tv64.tv_sec);\n\nerr_read:\n\trtc_hctosys_ret = err;\n}\n#endif\n\n#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_RTC_HCTOSYS_DEVICE)\n \n\nstatic struct timespec64 old_rtc, old_system, old_delta;\n\nstatic int rtc_suspend(struct device *dev)\n{\n\tstruct rtc_device\t*rtc = to_rtc_device(dev);\n\tstruct rtc_time\t\ttm;\n\tstruct timespec64\tdelta, delta_delta;\n\tint err;\n\n\tif (timekeeping_rtc_skipsuspend())\n\t\treturn 0;\n\n\tif (strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)\n\t\treturn 0;\n\n\t \n\terr = rtc_read_time(rtc, &tm);\n\tif (err < 0) {\n\t\tpr_debug(\"%s:  fail to read rtc time\\n\", dev_name(&rtc->dev));\n\t\treturn 0;\n\t}\n\n\tktime_get_real_ts64(&old_system);\n\told_rtc.tv_sec = rtc_tm_to_time64(&tm);\n\n\t \n\tdelta = timespec64_sub(old_system, old_rtc);\n\tdelta_delta = timespec64_sub(delta, old_delta);\n\tif (delta_delta.tv_sec < -2 || delta_delta.tv_sec >= 2) {\n\t\t \n\t\told_delta = delta;\n\t} else {\n\t\t \n\t\told_system = timespec64_sub(old_system, delta_delta);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtc_resume(struct device *dev)\n{\n\tstruct rtc_device\t*rtc = to_rtc_device(dev);\n\tstruct rtc_time\t\ttm;\n\tstruct timespec64\tnew_system, new_rtc;\n\tstruct timespec64\tsleep_time;\n\tint err;\n\n\tif (timekeeping_rtc_skipresume())\n\t\treturn 0;\n\n\trtc_hctosys_ret = -ENODEV;\n\tif (strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)\n\t\treturn 0;\n\n\t \n\tktime_get_real_ts64(&new_system);\n\terr = rtc_read_time(rtc, &tm);\n\tif (err < 0) {\n\t\tpr_debug(\"%s:  fail to read rtc time\\n\", dev_name(&rtc->dev));\n\t\treturn 0;\n\t}\n\n\tnew_rtc.tv_sec = rtc_tm_to_time64(&tm);\n\tnew_rtc.tv_nsec = 0;\n\n\tif (new_rtc.tv_sec < old_rtc.tv_sec) {\n\t\tpr_debug(\"%s:  time travel!\\n\", dev_name(&rtc->dev));\n\t\treturn 0;\n\t}\n\n\t \n\tsleep_time = timespec64_sub(new_rtc, old_rtc);\n\n\t \n\tsleep_time = timespec64_sub(sleep_time,\n\t\t\t\t    timespec64_sub(new_system, old_system));\n\n\tif (sleep_time.tv_sec >= 0)\n\t\ttimekeeping_inject_sleeptime64(&sleep_time);\n\trtc_hctosys_ret = 0;\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rtc_class_dev_pm_ops, rtc_suspend, rtc_resume);\n#define RTC_CLASS_DEV_PM_OPS\t(&rtc_class_dev_pm_ops)\n#else\n#define RTC_CLASS_DEV_PM_OPS\tNULL\n#endif\n\n \nstatic struct rtc_device *rtc_allocate_device(void)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = kzalloc(sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn NULL;\n\n\tdevice_initialize(&rtc->dev);\n\n\t \n\trtc->set_offset_nsec = NSEC_PER_SEC + 5 * NSEC_PER_MSEC;\n\n\trtc->irq_freq = 1;\n\trtc->max_user_freq = 64;\n\trtc->dev.class = rtc_class;\n\trtc->dev.groups = rtc_get_dev_attribute_groups();\n\trtc->dev.release = rtc_device_release;\n\n\tmutex_init(&rtc->ops_lock);\n\tspin_lock_init(&rtc->irq_lock);\n\tinit_waitqueue_head(&rtc->irq_queue);\n\n\t \n\ttimerqueue_init_head(&rtc->timerqueue);\n\tINIT_WORK(&rtc->irqwork, rtc_timer_do_work);\n\t \n\trtc_timer_init(&rtc->aie_timer, rtc_aie_update_irq, rtc);\n\t \n\trtc_timer_init(&rtc->uie_rtctimer, rtc_uie_update_irq, rtc);\n\t \n\thrtimer_init(&rtc->pie_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trtc->pie_timer.function = rtc_pie_update_irq;\n\trtc->pie_enabled = 0;\n\n\tset_bit(RTC_FEATURE_ALARM, rtc->features);\n\tset_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\n\treturn rtc;\n}\n\nstatic int rtc_device_get_id(struct device *dev)\n{\n\tint of_id = -1, id = -1;\n\n\tif (dev->of_node)\n\t\tof_id = of_alias_get_id(dev->of_node, \"rtc\");\n\telse if (dev->parent && dev->parent->of_node)\n\t\tof_id = of_alias_get_id(dev->parent->of_node, \"rtc\");\n\n\tif (of_id >= 0) {\n\t\tid = ida_simple_get(&rtc_ida, of_id, of_id + 1, GFP_KERNEL);\n\t\tif (id < 0)\n\t\t\tdev_warn(dev, \"/aliases ID %d not available\\n\", of_id);\n\t}\n\n\tif (id < 0)\n\t\tid = ida_alloc(&rtc_ida, GFP_KERNEL);\n\n\treturn id;\n}\n\nstatic void rtc_device_get_offset(struct rtc_device *rtc)\n{\n\ttime64_t range_secs;\n\tu32 start_year;\n\tint ret;\n\n\t \n\tif (rtc->range_min == rtc->range_max)\n\t\treturn;\n\n\tret = device_property_read_u32(rtc->dev.parent, \"start-year\",\n\t\t\t\t       &start_year);\n\tif (!ret) {\n\t\trtc->start_secs = mktime64(start_year, 1, 1, 0, 0, 0);\n\t\trtc->set_start_time = true;\n\t}\n\n\t \n\tif (!rtc->set_start_time)\n\t\treturn;\n\n\trange_secs = rtc->range_max - rtc->range_min + 1;\n\n\t \n\tif (rtc->start_secs > rtc->range_max ||\n\t    rtc->start_secs + range_secs - 1 < rtc->range_min)\n\t\trtc->offset_secs = rtc->start_secs - rtc->range_min;\n\telse if (rtc->start_secs > rtc->range_min)\n\t\trtc->offset_secs = range_secs;\n\telse if (rtc->start_secs < rtc->range_min)\n\t\trtc->offset_secs = -range_secs;\n\telse\n\t\trtc->offset_secs = 0;\n}\n\nstatic void devm_rtc_unregister_device(void *data)\n{\n\tstruct rtc_device *rtc = data;\n\n\tmutex_lock(&rtc->ops_lock);\n\t \n\trtc_proc_del_device(rtc);\n\tif (!test_bit(RTC_NO_CDEV, &rtc->flags))\n\t\tcdev_device_del(&rtc->char_dev, &rtc->dev);\n\trtc->ops = NULL;\n\tmutex_unlock(&rtc->ops_lock);\n}\n\nstatic void devm_rtc_release_device(void *res)\n{\n\tstruct rtc_device *rtc = res;\n\n\tput_device(&rtc->dev);\n}\n\nstruct rtc_device *devm_rtc_allocate_device(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\tint id, err;\n\n\tid = rtc_device_get_id(dev);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\trtc = rtc_allocate_device();\n\tif (!rtc) {\n\t\tida_free(&rtc_ida, id);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trtc->id = id;\n\trtc->dev.parent = dev;\n\terr = devm_add_action_or_reset(dev, devm_rtc_release_device, rtc);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = dev_set_name(&rtc->dev, \"rtc%d\", id);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn rtc;\n}\nEXPORT_SYMBOL_GPL(devm_rtc_allocate_device);\n\nint __devm_rtc_register_device(struct module *owner, struct rtc_device *rtc)\n{\n\tstruct rtc_wkalrm alrm;\n\tint err;\n\n\tif (!rtc->ops) {\n\t\tdev_dbg(&rtc->dev, \"no ops set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rtc->ops->set_alarm)\n\t\tclear_bit(RTC_FEATURE_ALARM, rtc->features);\n\n\tif (rtc->ops->set_offset)\n\t\tset_bit(RTC_FEATURE_CORRECTION, rtc->features);\n\n\trtc->owner = owner;\n\trtc_device_get_offset(rtc);\n\n\t \n\terr = __rtc_read_alarm(rtc, &alrm);\n\tif (!err && !rtc_valid_tm(&alrm.time))\n\t\trtc_initialize_alarm(rtc, &alrm);\n\n\trtc_dev_prepare(rtc);\n\n\terr = cdev_device_add(&rtc->char_dev, &rtc->dev);\n\tif (err) {\n\t\tset_bit(RTC_NO_CDEV, &rtc->flags);\n\t\tdev_warn(rtc->dev.parent, \"failed to add char device %d:%d\\n\",\n\t\t\t MAJOR(rtc->dev.devt), rtc->id);\n\t} else {\n\t\tdev_dbg(rtc->dev.parent, \"char device (%d:%d)\\n\",\n\t\t\tMAJOR(rtc->dev.devt), rtc->id);\n\t}\n\n\trtc_proc_add_device(rtc);\n\n\tdev_info(rtc->dev.parent, \"registered as %s\\n\",\n\t\t dev_name(&rtc->dev));\n\n#ifdef CONFIG_RTC_HCTOSYS_DEVICE\n\tif (!strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE))\n\t\trtc_hctosys(rtc);\n#endif\n\n\treturn devm_add_action_or_reset(rtc->dev.parent,\n\t\t\t\t\tdevm_rtc_unregister_device, rtc);\n}\nEXPORT_SYMBOL_GPL(__devm_rtc_register_device);\n\n \nstruct rtc_device *devm_rtc_device_register(struct device *dev,\n\t\t\t\t\t    const char *name,\n\t\t\t\t\t    const struct rtc_class_ops *ops,\n\t\t\t\t\t    struct module *owner)\n{\n\tstruct rtc_device *rtc;\n\tint err;\n\n\trtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc))\n\t\treturn rtc;\n\n\trtc->ops = ops;\n\n\terr = __devm_rtc_register_device(owner, rtc);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn rtc;\n}\nEXPORT_SYMBOL_GPL(devm_rtc_device_register);\n\nstatic int __init rtc_init(void)\n{\n\trtc_class = class_create(\"rtc\");\n\tif (IS_ERR(rtc_class)) {\n\t\tpr_err(\"couldn't create class\\n\");\n\t\treturn PTR_ERR(rtc_class);\n\t}\n\trtc_class->pm = RTC_CLASS_DEV_PM_OPS;\n\trtc_dev_init();\n\treturn 0;\n}\nsubsys_initcall(rtc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}