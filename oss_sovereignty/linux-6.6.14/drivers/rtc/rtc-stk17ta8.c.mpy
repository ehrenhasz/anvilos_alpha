{
  "module_name": "rtc-stk17ta8.c",
  "hash_id": "fb105721c72556e4d79fd74109d1f2af18d85ecfa4ed27ae02e0a80ecaaf26d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-stk17ta8.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#define RTC_REG_SIZE\t\t0x20000\n#define RTC_OFFSET\t\t0x1fff0\n\n#define RTC_FLAGS\t\t(RTC_OFFSET + 0)\n#define RTC_CENTURY\t\t(RTC_OFFSET + 1)\n#define RTC_SECONDS_ALARM\t(RTC_OFFSET + 2)\n#define RTC_MINUTES_ALARM\t(RTC_OFFSET + 3)\n#define RTC_HOURS_ALARM\t\t(RTC_OFFSET + 4)\n#define RTC_DATE_ALARM\t\t(RTC_OFFSET + 5)\n#define RTC_INTERRUPTS\t\t(RTC_OFFSET + 6)\n#define RTC_WATCHDOG\t\t(RTC_OFFSET + 7)\n#define RTC_CALIBRATION\t\t(RTC_OFFSET + 8)\n#define RTC_SECONDS\t\t(RTC_OFFSET + 9)\n#define RTC_MINUTES\t\t(RTC_OFFSET + 10)\n#define RTC_HOURS\t\t(RTC_OFFSET + 11)\n#define RTC_DAY\t\t\t(RTC_OFFSET + 12)\n#define RTC_DATE\t\t(RTC_OFFSET + 13)\n#define RTC_MONTH\t\t(RTC_OFFSET + 14)\n#define RTC_YEAR\t\t(RTC_OFFSET + 15)\n\n#define RTC_SECONDS_MASK\t0x7f\n#define RTC_DAY_MASK\t\t0x07\n#define RTC_CAL_MASK\t\t0x3f\n\n \n#define RTC_STOP\t\t0x80\n\n \n#define RTC_FLAGS_AF\t\t0x40\n#define RTC_FLAGS_PF\t\t0x20\n#define RTC_WRITE\t\t0x02\n#define RTC_READ\t\t0x01\n\n \n#define RTC_INTS_AIE\t\t0x40\n\nstruct rtc_plat_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n\tunsigned long last_jiffies;\n\tint irq;\n\tunsigned int irqen;\n\tint alrm_sec;\n\tint alrm_min;\n\tint alrm_hour;\n\tint alrm_mday;\n\tspinlock_t lock;\n};\n\nstatic int stk17ta8_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu8 flags;\n\n\tflags = readb(pdata->ioaddr + RTC_FLAGS);\n\twriteb(flags | RTC_WRITE, pdata->ioaddr + RTC_FLAGS);\n\n\twriteb(bin2bcd(tm->tm_year % 100), ioaddr + RTC_YEAR);\n\twriteb(bin2bcd(tm->tm_mon + 1), ioaddr + RTC_MONTH);\n\twriteb(bin2bcd(tm->tm_wday) & RTC_DAY_MASK, ioaddr + RTC_DAY);\n\twriteb(bin2bcd(tm->tm_mday), ioaddr + RTC_DATE);\n\twriteb(bin2bcd(tm->tm_hour), ioaddr + RTC_HOURS);\n\twriteb(bin2bcd(tm->tm_min), ioaddr + RTC_MINUTES);\n\twriteb(bin2bcd(tm->tm_sec) & RTC_SECONDS_MASK, ioaddr + RTC_SECONDS);\n\twriteb(bin2bcd((tm->tm_year + 1900) / 100), ioaddr + RTC_CENTURY);\n\n\twriteb(flags & ~RTC_WRITE, pdata->ioaddr + RTC_FLAGS);\n\treturn 0;\n}\n\nstatic int stk17ta8_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tunsigned int year, month, day, hour, minute, second, week;\n\tunsigned int century;\n\tu8 flags;\n\n\t \n\tif (pdata->last_jiffies == jiffies)\n\t\tmsleep(1);\n\tpdata->last_jiffies = jiffies;\n\n\tflags = readb(pdata->ioaddr + RTC_FLAGS);\n\twriteb(flags | RTC_READ, ioaddr + RTC_FLAGS);\n\tsecond = readb(ioaddr + RTC_SECONDS) & RTC_SECONDS_MASK;\n\tminute = readb(ioaddr + RTC_MINUTES);\n\thour = readb(ioaddr + RTC_HOURS);\n\tday = readb(ioaddr + RTC_DATE);\n\tweek = readb(ioaddr + RTC_DAY) & RTC_DAY_MASK;\n\tmonth = readb(ioaddr + RTC_MONTH);\n\tyear = readb(ioaddr + RTC_YEAR);\n\tcentury = readb(ioaddr + RTC_CENTURY);\n\twriteb(flags & ~RTC_READ, ioaddr + RTC_FLAGS);\n\ttm->tm_sec = bcd2bin(second);\n\ttm->tm_min = bcd2bin(minute);\n\ttm->tm_hour = bcd2bin(hour);\n\ttm->tm_mday = bcd2bin(day);\n\ttm->tm_wday = bcd2bin(week);\n\ttm->tm_mon = bcd2bin(month) - 1;\n\t \n\ttm->tm_year = bcd2bin(year) + bcd2bin(century) * 100 - 1900;\n\n\treturn 0;\n}\n\nstatic void stk17ta8_rtc_update_alarm(struct rtc_plat_data *pdata)\n{\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tunsigned long irqflags;\n\tu8 flags;\n\n\tspin_lock_irqsave(&pdata->lock, irqflags);\n\n\tflags = readb(ioaddr + RTC_FLAGS);\n\twriteb(flags | RTC_WRITE, ioaddr + RTC_FLAGS);\n\n\twriteb(pdata->alrm_mday < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_mday),\n\t       ioaddr + RTC_DATE_ALARM);\n\twriteb(pdata->alrm_hour < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_hour),\n\t       ioaddr + RTC_HOURS_ALARM);\n\twriteb(pdata->alrm_min < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_min),\n\t       ioaddr + RTC_MINUTES_ALARM);\n\twriteb(pdata->alrm_sec < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_sec),\n\t       ioaddr + RTC_SECONDS_ALARM);\n\twriteb(pdata->irqen ? RTC_INTS_AIE : 0, ioaddr + RTC_INTERRUPTS);\n\treadb(ioaddr + RTC_FLAGS);\t \n\twriteb(flags & ~RTC_WRITE, ioaddr + RTC_FLAGS);\n\tspin_unlock_irqrestore(&pdata->lock, irqflags);\n}\n\nstatic int stk17ta8_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\tpdata->alrm_mday = alrm->time.tm_mday;\n\tpdata->alrm_hour = alrm->time.tm_hour;\n\tpdata->alrm_min = alrm->time.tm_min;\n\tpdata->alrm_sec = alrm->time.tm_sec;\n\tif (alrm->enabled)\n\t\tpdata->irqen |= RTC_AF;\n\tstk17ta8_rtc_update_alarm(pdata);\n\treturn 0;\n}\n\nstatic int stk17ta8_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\talrm->time.tm_mday = pdata->alrm_mday < 0 ? 0 : pdata->alrm_mday;\n\talrm->time.tm_hour = pdata->alrm_hour < 0 ? 0 : pdata->alrm_hour;\n\talrm->time.tm_min = pdata->alrm_min < 0 ? 0 : pdata->alrm_min;\n\talrm->time.tm_sec = pdata->alrm_sec < 0 ? 0 : pdata->alrm_sec;\n\talrm->enabled = (pdata->irqen & RTC_AF) ? 1 : 0;\n\treturn 0;\n}\n\nstatic irqreturn_t stk17ta8_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tunsigned long events = 0;\n\n\tspin_lock(&pdata->lock);\n\t \n\tif (readb(ioaddr + RTC_FLAGS) & RTC_FLAGS_AF) {\n\t\tevents = RTC_IRQF;\n\t\tif (readb(ioaddr + RTC_SECONDS_ALARM) & 0x80)\n\t\t\tevents |= RTC_UF;\n\t\telse\n\t\t\tevents |= RTC_AF;\n\t\trtc_update_irq(pdata->rtc, 1, events);\n\t}\n\tspin_unlock(&pdata->lock);\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int stk17ta8_rtc_alarm_irq_enable(struct device *dev,\n\tunsigned int enabled)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\tif (enabled)\n\t\tpdata->irqen |= RTC_AF;\n\telse\n\t\tpdata->irqen &= ~RTC_AF;\n\tstk17ta8_rtc_update_alarm(pdata);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops stk17ta8_rtc_ops = {\n\t.read_time\t\t= stk17ta8_rtc_read_time,\n\t.set_time\t\t= stk17ta8_rtc_set_time,\n\t.read_alarm\t\t= stk17ta8_rtc_read_alarm,\n\t.set_alarm\t\t= stk17ta8_rtc_set_alarm,\n\t.alarm_irq_enable\t= stk17ta8_rtc_alarm_irq_enable,\n};\n\nstatic int stk17ta8_nvram_read(void *priv, unsigned int pos, void *val,\n\t\t\t       size_t bytes)\n{\n\tstruct rtc_plat_data *pdata = priv;\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu8 *buf = val;\n\n\tfor (; bytes; bytes--)\n\t\t*buf++ = readb(ioaddr + pos++);\n\treturn 0;\n}\n\nstatic int stk17ta8_nvram_write(void *priv, unsigned int pos, void *val,\n\t\t\t\tsize_t bytes)\n{\n\tstruct rtc_plat_data *pdata = priv;\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu8 *buf = val;\n\n\tfor (; bytes; bytes--)\n\t\twriteb(*buf++, ioaddr + pos++);\n\treturn 0;\n}\n\nstatic int stk17ta8_rtc_probe(struct platform_device *pdev)\n{\n\tunsigned int cal;\n\tunsigned int flags;\n\tstruct rtc_plat_data *pdata;\n\tvoid __iomem *ioaddr;\n\tint ret = 0;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"stk17ta8_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = RTC_OFFSET,\n\t\t.reg_read = stk17ta8_nvram_read,\n\t\t.reg_write = stk17ta8_nvram_write,\n\t};\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ioaddr))\n\t\treturn PTR_ERR(ioaddr);\n\tpdata->ioaddr = ioaddr;\n\tpdata->irq = platform_get_irq(pdev, 0);\n\n\t \n\tcal = readb(ioaddr + RTC_CALIBRATION);\n\tif (cal & RTC_STOP) {\n\t\tcal &= RTC_CAL_MASK;\n\t\tflags = readb(ioaddr + RTC_FLAGS);\n\t\twriteb(flags | RTC_WRITE, ioaddr + RTC_FLAGS);\n\t\twriteb(cal, ioaddr + RTC_CALIBRATION);\n\t\twriteb(flags & ~RTC_WRITE, ioaddr + RTC_FLAGS);\n\t}\n\tif (readb(ioaddr + RTC_FLAGS) & RTC_FLAGS_PF)\n\t\tdev_warn(&pdev->dev, \"voltage-low detected.\\n\");\n\n\tspin_lock_init(&pdata->lock);\n\tpdata->last_jiffies = jiffies;\n\tplatform_set_drvdata(pdev, pdata);\n\tif (pdata->irq > 0) {\n\t\twriteb(0, ioaddr + RTC_INTERRUPTS);\n\t\tif (devm_request_irq(&pdev->dev, pdata->irq,\n\t\t\t\tstk17ta8_rtc_interrupt,\n\t\t\t\tIRQF_SHARED,\n\t\t\t\tpdev->name, pdev) < 0) {\n\t\t\tdev_warn(&pdev->dev, \"interrupt not available.\\n\");\n\t\t\tpdata->irq = 0;\n\t\t}\n\t}\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc))\n\t\treturn PTR_ERR(pdata->rtc);\n\n\tpdata->rtc->ops = &stk17ta8_rtc_ops;\n\n\tnvmem_cfg.priv = pdata;\n\tret = devm_rtc_nvmem_register(pdata->rtc, &nvmem_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_register_device(pdata->rtc);\n}\n\n \nMODULE_ALIAS(\"platform:stk17ta8\");\n\nstatic struct platform_driver stk17ta8_rtc_driver = {\n\t.probe\t\t= stk17ta8_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"stk17ta8\",\n\t},\n};\n\nmodule_platform_driver(stk17ta8_rtc_driver);\n\nMODULE_AUTHOR(\"Thomas Hommel <thomas.hommel@ge.com>\");\nMODULE_DESCRIPTION(\"Simtek STK17TA8 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}