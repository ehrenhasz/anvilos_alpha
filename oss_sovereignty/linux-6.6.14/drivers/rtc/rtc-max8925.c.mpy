{
  "module_name": "rtc-max8925.c",
  "hash_id": "0e2a5e446dad87423468c50b13ae195f923695c359c8c2de1ec9015e608aefdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-max8925.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/max8925.h>\n\nenum {\n\tRTC_SEC = 0,\n\tRTC_MIN,\n\tRTC_HOUR,\n\tRTC_WEEKDAY,\n\tRTC_DATE,\n\tRTC_MONTH,\n\tRTC_YEAR1,\n\tRTC_YEAR2,\n};\n\n#define MAX8925_RTC_SEC\t\t\t0x00\n#define MAX8925_RTC_MIN\t\t\t0x01\n#define MAX8925_RTC_HOUR\t\t0x02\n#define MAX8925_RTC_WEEKDAY\t\t0x03\n#define MAX8925_RTC_DATE\t\t0x04\n#define MAX8925_RTC_MONTH\t\t0x05\n#define MAX8925_RTC_YEAR1\t\t0x06\n#define MAX8925_RTC_YEAR2\t\t0x07\n#define MAX8925_ALARM0_SEC\t\t0x08\n#define MAX8925_ALARM0_MIN\t\t0x09\n#define MAX8925_ALARM0_HOUR\t\t0x0a\n#define MAX8925_ALARM0_WEEKDAY\t\t0x0b\n#define MAX8925_ALARM0_DATE\t\t0x0c\n#define MAX8925_ALARM0_MON\t\t0x0d\n#define MAX8925_ALARM0_YEAR1\t\t0x0e\n#define MAX8925_ALARM0_YEAR2\t\t0x0f\n#define MAX8925_ALARM1_SEC\t\t0x10\n#define MAX8925_ALARM1_MIN\t\t0x11\n#define MAX8925_ALARM1_HOUR\t\t0x12\n#define MAX8925_ALARM1_WEEKDAY\t\t0x13\n#define MAX8925_ALARM1_DATE\t\t0x14\n#define MAX8925_ALARM1_MON\t\t0x15\n#define MAX8925_ALARM1_YEAR1\t\t0x16\n#define MAX8925_ALARM1_YEAR2\t\t0x17\n#define MAX8925_RTC_CNTL\t\t0x1b\n#define MAX8925_RTC_STATUS\t\t0x20\n\n#define TIME_NUM\t\t\t8\n#define ALARM_1SEC\t\t\t(1 << 7)\n#define HOUR_12\t\t\t\t(1 << 7)\n#define HOUR_AM_PM\t\t\t(1 << 5)\n#define ALARM0_IRQ\t\t\t(1 << 3)\n#define ALARM1_IRQ\t\t\t(1 << 2)\n#define ALARM0_STATUS\t\t\t(1 << 2)\n#define ALARM1_STATUS\t\t\t(1 << 1)\n\n\nstruct max8925_rtc_info {\n\tstruct rtc_device\t*rtc_dev;\n\tstruct max8925_chip\t*chip;\n\tstruct i2c_client\t*rtc;\n\tstruct device\t\t*dev;\n\tint\t\t\tirq;\n};\n\nstatic irqreturn_t rtc_update_handler(int irq, void *data)\n{\n\tstruct max8925_rtc_info *info = (struct max8925_rtc_info *)data;\n\n\t \n\tmax8925_set_bits(info->rtc, MAX8925_ALARM0_CNTL, 0x7f, 0);\n\trtc_update_irq(info->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int tm_calc(struct rtc_time *tm, unsigned char *buf, int len)\n{\n\tif (len < TIME_NUM)\n\t\treturn -EINVAL;\n\ttm->tm_year = (buf[RTC_YEAR2] >> 4) * 1000\n\t\t\t+ (buf[RTC_YEAR2] & 0xf) * 100\n\t\t\t+ (buf[RTC_YEAR1] >> 4) * 10\n\t\t\t+ (buf[RTC_YEAR1] & 0xf);\n\ttm->tm_year -= 1900;\n\ttm->tm_mon = ((buf[RTC_MONTH] >> 4) & 0x01) * 10\n\t\t\t+ (buf[RTC_MONTH] & 0x0f);\n\ttm->tm_mday = ((buf[RTC_DATE] >> 4) & 0x03) * 10\n\t\t\t+ (buf[RTC_DATE] & 0x0f);\n\ttm->tm_wday = buf[RTC_WEEKDAY] & 0x07;\n\tif (buf[RTC_HOUR] & HOUR_12) {\n\t\ttm->tm_hour = ((buf[RTC_HOUR] >> 4) & 0x1) * 10\n\t\t\t\t+ (buf[RTC_HOUR] & 0x0f);\n\t\tif (buf[RTC_HOUR] & HOUR_AM_PM)\n\t\t\ttm->tm_hour += 12;\n\t} else\n\t\ttm->tm_hour = ((buf[RTC_HOUR] >> 4) & 0x03) * 10\n\t\t\t\t+ (buf[RTC_HOUR] & 0x0f);\n\ttm->tm_min = ((buf[RTC_MIN] >> 4) & 0x7) * 10\n\t\t\t+ (buf[RTC_MIN] & 0x0f);\n\ttm->tm_sec = ((buf[RTC_SEC] >> 4) & 0x7) * 10\n\t\t\t+ (buf[RTC_SEC] & 0x0f);\n\treturn 0;\n}\n\nstatic int data_calc(unsigned char *buf, struct rtc_time *tm, int len)\n{\n\tunsigned char high, low;\n\n\tif (len < TIME_NUM)\n\t\treturn -EINVAL;\n\n\thigh = (tm->tm_year + 1900) / 1000;\n\tlow = (tm->tm_year + 1900) / 100;\n\tlow = low - high * 10;\n\tbuf[RTC_YEAR2] = (high << 4) + low;\n\thigh = (tm->tm_year + 1900) / 10;\n\tlow = tm->tm_year + 1900;\n\tlow = low - high * 10;\n\thigh = high - (high / 10) * 10;\n\tbuf[RTC_YEAR1] = (high << 4) + low;\n\thigh = tm->tm_mon / 10;\n\tlow = tm->tm_mon;\n\tlow = low - high * 10;\n\tbuf[RTC_MONTH] = (high << 4) + low;\n\thigh = tm->tm_mday / 10;\n\tlow = tm->tm_mday;\n\tlow = low - high * 10;\n\tbuf[RTC_DATE] = (high << 4) + low;\n\tbuf[RTC_WEEKDAY] = tm->tm_wday;\n\thigh = tm->tm_hour / 10;\n\tlow = tm->tm_hour;\n\tlow = low - high * 10;\n\tbuf[RTC_HOUR] = (high << 4) + low;\n\thigh = tm->tm_min / 10;\n\tlow = tm->tm_min;\n\tlow = low - high * 10;\n\tbuf[RTC_MIN] = (high << 4) + low;\n\thigh = tm->tm_sec / 10;\n\tlow = tm->tm_sec;\n\tlow = low - high * 10;\n\tbuf[RTC_SEC] = (high << 4) + low;\n\treturn 0;\n}\n\nstatic int max8925_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8925_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[TIME_NUM];\n\tint ret;\n\n\tret = max8925_bulk_read(info->rtc, MAX8925_RTC_SEC, TIME_NUM, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = tm_calc(tm, buf, TIME_NUM);\nout:\n\treturn ret;\n}\n\nstatic int max8925_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8925_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[TIME_NUM];\n\tint ret;\n\n\tret = data_calc(buf, tm, TIME_NUM);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = max8925_bulk_write(info->rtc, MAX8925_RTC_SEC, TIME_NUM, buf);\nout:\n\treturn ret;\n}\n\nstatic int max8925_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8925_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[TIME_NUM];\n\tint ret;\n\n\tret = max8925_bulk_read(info->rtc, MAX8925_ALARM0_SEC, TIME_NUM, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = tm_calc(&alrm->time, buf, TIME_NUM);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = max8925_reg_read(info->rtc, MAX8925_RTC_IRQ_MASK);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret & ALARM0_IRQ) {\n\t\talrm->enabled = 0;\n\t} else {\n\t\tret = max8925_reg_read(info->rtc, MAX8925_ALARM0_CNTL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\talrm->enabled = 0;\n\t\telse\n\t\t\talrm->enabled = 1;\n\t}\n\tret = max8925_reg_read(info->rtc, MAX8925_RTC_STATUS);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret & ALARM0_STATUS)\n\t\talrm->pending = 1;\n\telse\n\t\talrm->pending = 0;\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int max8925_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8925_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[TIME_NUM];\n\tint ret;\n\n\tret = data_calc(buf, &alrm->time, TIME_NUM);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = max8925_bulk_write(info->rtc, MAX8925_ALARM0_SEC, TIME_NUM, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (alrm->enabled)\n\t\t \n\t\tret = max8925_reg_write(info->rtc, MAX8925_ALARM0_CNTL, 0x77);\n\telse\n\t\tret = max8925_reg_write(info->rtc, MAX8925_ALARM0_CNTL, 0x0);\nout:\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops max8925_rtc_ops = {\n\t.read_time\t= max8925_rtc_read_time,\n\t.set_time\t= max8925_rtc_set_time,\n\t.read_alarm\t= max8925_rtc_read_alarm,\n\t.set_alarm\t= max8925_rtc_set_alarm,\n};\n\nstatic int max8925_rtc_probe(struct platform_device *pdev)\n{\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8925_rtc_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct max8925_rtc_info),\n\t\t\t    GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->chip = chip;\n\tinfo->rtc = chip->rtc;\n\tinfo->dev = &pdev->dev;\n\tinfo->irq = platform_get_irq(pdev, 0);\n\n\tret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\n\t\t\t\t\trtc_update_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"rtc-alarm0\", info);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq, ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, info);\n\t \n\tplatform_set_drvdata(pdev, info);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tinfo->rtc_dev = devm_rtc_device_register(&pdev->dev, \"max8925-rtc\",\n\t\t\t\t\t&max8925_rtc_ops, THIS_MODULE);\n\tret = PTR_ERR(info->rtc_dev);\n\tif (IS_ERR(info->rtc_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register RTC device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max8925_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag |= 1 << MAX8925_IRQ_RTC_ALARM0;\n\treturn 0;\n}\nstatic int max8925_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag &= ~(1 << MAX8925_IRQ_RTC_ALARM0);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(max8925_rtc_pm_ops, max8925_rtc_suspend, max8925_rtc_resume);\n\nstatic struct platform_driver max8925_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8925-rtc\",\n\t\t.pm     = &max8925_rtc_pm_ops,\n\t},\n\t.probe\t\t= max8925_rtc_probe,\n};\n\nmodule_platform_driver(max8925_rtc_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX8925 RTC driver\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}