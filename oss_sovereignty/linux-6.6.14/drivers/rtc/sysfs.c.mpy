{
  "module_name": "sysfs.c",
  "hash_id": "fce4f98a50f1e6943251e3bdb9cc650301131a50859395eb6a1db8d0517be6fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n\n#include \"rtc-core.h\"\n\n \n\n \n\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s %s\\n\", dev_driver_string(dev->parent),\n\t\t       dev_name(dev->parent));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t\ndate_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tssize_t retval;\n\tstruct rtc_time tm;\n\n\tretval = rtc_read_time(to_rtc_device(dev), &tm);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sprintf(buf, \"%ptRd\\n\", &tm);\n}\nstatic DEVICE_ATTR_RO(date);\n\nstatic ssize_t\ntime_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tssize_t retval;\n\tstruct rtc_time tm;\n\n\tretval = rtc_read_time(to_rtc_device(dev), &tm);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sprintf(buf, \"%ptRt\\n\", &tm);\n}\nstatic DEVICE_ATTR_RO(time);\n\nstatic ssize_t\nsince_epoch_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tssize_t retval;\n\tstruct rtc_time tm;\n\n\tretval = rtc_read_time(to_rtc_device(dev), &tm);\n\tif (retval == 0) {\n\t\ttime64_t time;\n\n\t\ttime = rtc_tm_to_time64(&tm);\n\t\tretval = sprintf(buf, \"%lld\\n\", time);\n\t}\n\n\treturn retval;\n}\nstatic DEVICE_ATTR_RO(since_epoch);\n\nstatic ssize_t\nmax_user_freq_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", to_rtc_device(dev)->max_user_freq);\n}\n\nstatic ssize_t\nmax_user_freq_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t n)\n{\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 0, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val >= 4096 || val == 0)\n\t\treturn -EINVAL;\n\n\trtc->max_user_freq = (int)val;\n\n\treturn n;\n}\nstatic DEVICE_ATTR_RW(max_user_freq);\n\n \nstatic ssize_t\nhctosys_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n#ifdef CONFIG_RTC_HCTOSYS_DEVICE\n\tif (rtc_hctosys_ret == 0 &&\n\t    strcmp(dev_name(&to_rtc_device(dev)->dev),\n\t\t   CONFIG_RTC_HCTOSYS_DEVICE) == 0)\n\t\treturn sprintf(buf, \"1\\n\");\n#endif\n\treturn sprintf(buf, \"0\\n\");\n}\nstatic DEVICE_ATTR_RO(hctosys);\n\nstatic ssize_t\nwakealarm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tssize_t retval;\n\ttime64_t alarm;\n\tstruct rtc_wkalrm alm;\n\n\t \n\tretval = rtc_read_alarm(to_rtc_device(dev), &alm);\n\tif (retval == 0 && alm.enabled) {\n\t\talarm = rtc_tm_to_time64(&alm.time);\n\t\tretval = sprintf(buf, \"%lld\\n\", alarm);\n\t}\n\n\treturn retval;\n}\n\nstatic ssize_t\nwakealarm_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t n)\n{\n\tssize_t retval;\n\ttime64_t now, alarm;\n\ttime64_t push = 0;\n\tstruct rtc_wkalrm alm;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tconst char *buf_ptr;\n\tint adjust = 0;\n\n\t \n\tretval = rtc_read_time(rtc, &alm.time);\n\tif (retval < 0)\n\t\treturn retval;\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tbuf_ptr = buf;\n\tif (*buf_ptr == '+') {\n\t\tbuf_ptr++;\n\t\tif (*buf_ptr == '=') {\n\t\t\tbuf_ptr++;\n\t\t\tpush = 1;\n\t\t} else {\n\t\t\tadjust = 1;\n\t\t}\n\t}\n\tretval = kstrtos64(buf_ptr, 0, &alarm);\n\tif (retval)\n\t\treturn retval;\n\tif (adjust)\n\t\talarm += now;\n\tif (alarm > now || push) {\n\t\t \n\t\tretval = rtc_read_alarm(rtc, &alm);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (alm.enabled) {\n\t\t\tif (push) {\n\t\t\t\tpush = rtc_tm_to_time64(&alm.time);\n\t\t\t\talarm += push;\n\t\t\t} else\n\t\t\t\treturn -EBUSY;\n\t\t} else if (push)\n\t\t\treturn -EINVAL;\n\t\talm.enabled = 1;\n\t} else {\n\t\talm.enabled = 0;\n\n\t\t \n\t\talarm = now + 300;\n\t}\n\trtc_time64_to_tm(alarm, &alm.time);\n\n\tretval = rtc_set_alarm(rtc, &alm);\n\treturn (retval < 0) ? retval : n;\n}\nstatic DEVICE_ATTR_RW(wakealarm);\n\nstatic ssize_t\noffset_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tssize_t retval;\n\tlong offset;\n\n\tretval = rtc_read_offset(to_rtc_device(dev), &offset);\n\tif (retval == 0)\n\t\tretval = sprintf(buf, \"%ld\\n\", offset);\n\n\treturn retval;\n}\n\nstatic ssize_t\noffset_store(struct device *dev, struct device_attribute *attr,\n\t     const char *buf, size_t n)\n{\n\tssize_t retval;\n\tlong offset;\n\n\tretval = kstrtol(buf, 10, &offset);\n\tif (retval == 0)\n\t\tretval = rtc_set_offset(to_rtc_device(dev), offset);\n\n\treturn (retval < 0) ? retval : n;\n}\nstatic DEVICE_ATTR_RW(offset);\n\nstatic ssize_t\nrange_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"[%lld,%llu]\\n\", to_rtc_device(dev)->range_min,\n\t\t       to_rtc_device(dev)->range_max);\n}\nstatic DEVICE_ATTR_RO(range);\n\nstatic struct attribute *rtc_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_date.attr,\n\t&dev_attr_time.attr,\n\t&dev_attr_since_epoch.attr,\n\t&dev_attr_max_user_freq.attr,\n\t&dev_attr_hctosys.attr,\n\t&dev_attr_wakealarm.attr,\n\t&dev_attr_offset.attr,\n\t&dev_attr_range.attr,\n\tNULL,\n};\n\n \nstatic bool rtc_does_wakealarm(struct rtc_device *rtc)\n{\n\tif (!device_can_wakeup(rtc->dev.parent))\n\t\treturn false;\n\n\treturn !!test_bit(RTC_FEATURE_ALARM, rtc->features);\n}\n\nstatic umode_t rtc_attr_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_wakealarm.attr) {\n\t\tif (!rtc_does_wakealarm(rtc))\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_offset.attr) {\n\t\tif (!rtc->ops->set_offset)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_range.attr) {\n\t\tif (!(rtc->range_max - rtc->range_min))\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic struct attribute_group rtc_attr_group = {\n\t.is_visible\t= rtc_attr_is_visible,\n\t.attrs\t\t= rtc_attrs,\n};\n\nstatic const struct attribute_group *rtc_attr_groups[] = {\n\t&rtc_attr_group,\n\tNULL\n};\n\nconst struct attribute_group **rtc_get_dev_attribute_groups(void)\n{\n\treturn rtc_attr_groups;\n}\n\nint rtc_add_groups(struct rtc_device *rtc, const struct attribute_group **grps)\n{\n\tsize_t old_cnt = 0, add_cnt = 0, new_cnt;\n\tconst struct attribute_group **groups, **old;\n\n\tif (!grps)\n\t\treturn -EINVAL;\n\n\tgroups = rtc->dev.groups;\n\tif (groups)\n\t\tfor (; *groups; groups++)\n\t\t\told_cnt++;\n\n\tfor (groups = grps; *groups; groups++)\n\t\tadd_cnt++;\n\n\tnew_cnt = old_cnt + add_cnt + 1;\n\tgroups = devm_kcalloc(&rtc->dev, new_cnt, sizeof(*groups), GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\tmemcpy(groups, rtc->dev.groups, old_cnt * sizeof(*groups));\n\tmemcpy(groups + old_cnt, grps, add_cnt * sizeof(*groups));\n\tgroups[old_cnt + add_cnt] = NULL;\n\n\told = rtc->dev.groups;\n\trtc->dev.groups = groups;\n\tif (old && old != rtc_attr_groups)\n\t\tdevm_kfree(&rtc->dev, old);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtc_add_groups);\n\nint rtc_add_group(struct rtc_device *rtc, const struct attribute_group *grp)\n{\n\tconst struct attribute_group *groups[] = { grp, NULL };\n\n\treturn rtc_add_groups(rtc, groups);\n}\nEXPORT_SYMBOL(rtc_add_group);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}