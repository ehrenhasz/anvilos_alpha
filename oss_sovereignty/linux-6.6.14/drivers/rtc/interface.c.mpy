{
  "module_name": "interface.c",
  "hash_id": "6a0da059bcca6ec12558c96898f84eb2734e1ddbebd529c8d0a2c6c6156063ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/interface.c",
  "human_readable_source": "\n \n\n#include <linux/rtc.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include <linux/workqueue.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/rtc.h>\n\nstatic int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer);\nstatic void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer);\n\nstatic void rtc_add_offset(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\ttime64_t secs;\n\n\tif (!rtc->offset_secs)\n\t\treturn;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\t \n\tif ((rtc->start_secs > rtc->range_min && secs >= rtc->start_secs) ||\n\t    (rtc->start_secs < rtc->range_min &&\n\t     secs <= (rtc->start_secs + rtc->range_max - rtc->range_min)))\n\t\treturn;\n\n\trtc_time64_to_tm(secs + rtc->offset_secs, tm);\n}\n\nstatic void rtc_subtract_offset(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\ttime64_t secs;\n\n\tif (!rtc->offset_secs)\n\t\treturn;\n\n\tsecs = rtc_tm_to_time64(tm);\n\n\t \n\tif (secs >= rtc->range_min && secs <= rtc->range_max)\n\t\treturn;\n\n\trtc_time64_to_tm(secs - rtc->offset_secs, tm);\n}\n\nstatic int rtc_valid_range(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\tif (rtc->range_min != rtc->range_max) {\n\t\ttime64_t time = rtc_tm_to_time64(tm);\n\t\ttime64_t range_min = rtc->set_start_time ? rtc->start_secs :\n\t\t\trtc->range_min;\n\t\ttimeu64_t range_max = rtc->set_start_time ?\n\t\t\t(rtc->start_secs + rtc->range_max - rtc->range_min) :\n\t\t\trtc->range_max;\n\n\t\tif (time < range_min || time > range_max)\n\t\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\tint err;\n\n\tif (!rtc->ops) {\n\t\terr = -ENODEV;\n\t} else if (!rtc->ops->read_time) {\n\t\terr = -EINVAL;\n\t} else {\n\t\tmemset(tm, 0, sizeof(struct rtc_time));\n\t\terr = rtc->ops->read_time(rtc->dev.parent, tm);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(&rtc->dev, \"read_time: fail to read: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\trtc_add_offset(rtc, tm);\n\n\t\terr = rtc_valid_tm(tm);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&rtc->dev, \"read_time: rtc_time isn't valid\\n\");\n\t}\n\treturn err;\n}\n\nint rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\terr = __rtc_read_time(rtc, tm);\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_read_time(rtc_tm_to_time64(tm), err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_read_time);\n\nint rtc_set_time(struct rtc_device *rtc, struct rtc_time *tm)\n{\n\tint err, uie;\n\n\terr = rtc_valid_tm(tm);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = rtc_valid_range(rtc, tm);\n\tif (err)\n\t\treturn err;\n\n\trtc_subtract_offset(rtc, tm);\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tuie = rtc->uie_rtctimer.enabled || rtc->uie_irq_active;\n#else\n\tuie = rtc->uie_rtctimer.enabled;\n#endif\n\tif (uie) {\n\t\terr = rtc_update_irq_enable(rtc, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (!rtc->ops)\n\t\terr = -ENODEV;\n\telse if (rtc->ops->set_time)\n\t\terr = rtc->ops->set_time(rtc->dev.parent, tm);\n\telse\n\t\terr = -EINVAL;\n\n\tpm_stay_awake(rtc->dev.parent);\n\tmutex_unlock(&rtc->ops_lock);\n\t \n\tschedule_work(&rtc->irqwork);\n\n\tif (uie) {\n\t\terr = rtc_update_irq_enable(rtc, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ttrace_rtc_set_time(rtc_tm_to_time64(tm), err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_set_time);\n\nstatic int rtc_read_alarm_internal(struct rtc_device *rtc,\n\t\t\t\t   struct rtc_wkalrm *alarm)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (!rtc->ops) {\n\t\terr = -ENODEV;\n\t} else if (!test_bit(RTC_FEATURE_ALARM, rtc->features) || !rtc->ops->read_alarm) {\n\t\terr = -EINVAL;\n\t} else {\n\t\talarm->enabled = 0;\n\t\talarm->pending = 0;\n\t\talarm->time.tm_sec = -1;\n\t\talarm->time.tm_min = -1;\n\t\talarm->time.tm_hour = -1;\n\t\talarm->time.tm_mday = -1;\n\t\talarm->time.tm_mon = -1;\n\t\talarm->time.tm_year = -1;\n\t\talarm->time.tm_wday = -1;\n\t\talarm->time.tm_yday = -1;\n\t\talarm->time.tm_isdst = -1;\n\t\terr = rtc->ops->read_alarm(rtc->dev.parent, alarm);\n\t}\n\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_read_alarm(rtc_tm_to_time64(&alarm->time), err);\n\treturn err;\n}\n\nint __rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)\n{\n\tint err;\n\tstruct rtc_time before, now;\n\tint first_time = 1;\n\ttime64_t t_now, t_alm;\n\tenum { none, day, month, year } missing = none;\n\tunsigned int days;\n\n\t \n\n\t \n\terr = rtc_read_time(rtc, &before);\n\tif (err < 0)\n\t\treturn err;\n\tdo {\n\t\tif (!first_time)\n\t\t\tmemcpy(&before, &now, sizeof(struct rtc_time));\n\t\tfirst_time = 0;\n\n\t\t \n\t\terr = rtc_read_alarm_internal(rtc, alarm);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (rtc_valid_tm(&alarm->time) == 0) {\n\t\t\trtc_add_offset(rtc, &alarm->time);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\terr = rtc_read_time(rtc, &now);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t} while (before.tm_min  != now.tm_min ||\n\t\t before.tm_hour != now.tm_hour ||\n\t\t before.tm_mon  != now.tm_mon ||\n\t\t before.tm_year != now.tm_year);\n\n\t \n\tif (alarm->time.tm_sec == -1)\n\t\talarm->time.tm_sec = now.tm_sec;\n\tif (alarm->time.tm_min == -1)\n\t\talarm->time.tm_min = now.tm_min;\n\tif (alarm->time.tm_hour == -1)\n\t\talarm->time.tm_hour = now.tm_hour;\n\n\t \n\tif (alarm->time.tm_mday < 1 || alarm->time.tm_mday > 31) {\n\t\talarm->time.tm_mday = now.tm_mday;\n\t\tmissing = day;\n\t}\n\tif ((unsigned int)alarm->time.tm_mon >= 12) {\n\t\talarm->time.tm_mon = now.tm_mon;\n\t\tif (missing == none)\n\t\t\tmissing = month;\n\t}\n\tif (alarm->time.tm_year == -1) {\n\t\talarm->time.tm_year = now.tm_year;\n\t\tif (missing == none)\n\t\t\tmissing = year;\n\t}\n\n\t \n\terr = rtc_valid_tm(&alarm->time);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tt_now = rtc_tm_to_time64(&now);\n\tt_alm = rtc_tm_to_time64(&alarm->time);\n\tif (t_now < t_alm)\n\t\tgoto done;\n\n\tswitch (missing) {\n\t \n\tcase day:\n\t\tdev_dbg(&rtc->dev, \"alarm rollover: %s\\n\", \"day\");\n\t\tt_alm += 24 * 60 * 60;\n\t\trtc_time64_to_tm(t_alm, &alarm->time);\n\t\tbreak;\n\n\t \n\tcase month:\n\t\tdev_dbg(&rtc->dev, \"alarm rollover: %s\\n\", \"month\");\n\t\tdo {\n\t\t\tif (alarm->time.tm_mon < 11) {\n\t\t\t\talarm->time.tm_mon++;\n\t\t\t} else {\n\t\t\t\talarm->time.tm_mon = 0;\n\t\t\t\talarm->time.tm_year++;\n\t\t\t}\n\t\t\tdays = rtc_month_days(alarm->time.tm_mon,\n\t\t\t\t\t      alarm->time.tm_year);\n\t\t} while (days < alarm->time.tm_mday);\n\t\tbreak;\n\n\t \n\tcase year:\n\t\tdev_dbg(&rtc->dev, \"alarm rollover: %s\\n\", \"year\");\n\t\tdo {\n\t\t\talarm->time.tm_year++;\n\t\t} while (!is_leap_year(alarm->time.tm_year + 1900) &&\n\t\t\t rtc_valid_tm(&alarm->time) != 0);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&rtc->dev, \"alarm rollover not handled\\n\");\n\t}\n\n\terr = rtc_valid_tm(&alarm->time);\n\ndone:\n\tif (err && alarm->enabled)\n\t\tdev_warn(&rtc->dev, \"invalid alarm value: %ptR\\n\",\n\t\t\t &alarm->time);\n\n\treturn err;\n}\n\nint rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\tif (!rtc->ops) {\n\t\terr = -ENODEV;\n\t} else if (!test_bit(RTC_FEATURE_ALARM, rtc->features)) {\n\t\terr = -EINVAL;\n\t} else {\n\t\tmemset(alarm, 0, sizeof(struct rtc_wkalrm));\n\t\talarm->enabled = rtc->aie_timer.enabled;\n\t\talarm->time = rtc_ktime_to_tm(rtc->aie_timer.node.expires);\n\t}\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_read_alarm(rtc_tm_to_time64(&alarm->time), err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_read_alarm);\n\nstatic int __rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)\n{\n\tstruct rtc_time tm;\n\ttime64_t now, scheduled;\n\tint err;\n\n\terr = rtc_valid_tm(&alarm->time);\n\tif (err)\n\t\treturn err;\n\n\tscheduled = rtc_tm_to_time64(&alarm->time);\n\n\t \n\terr = __rtc_read_time(rtc, &tm);\n\tif (err)\n\t\treturn err;\n\tnow = rtc_tm_to_time64(&tm);\n\n\tif (scheduled <= now)\n\t\treturn -ETIME;\n\t \n\n\trtc_subtract_offset(rtc, &alarm->time);\n\n\tif (!rtc->ops)\n\t\terr = -ENODEV;\n\telse if (!test_bit(RTC_FEATURE_ALARM, rtc->features))\n\t\terr = -EINVAL;\n\telse\n\t\terr = rtc->ops->set_alarm(rtc->dev.parent, alarm);\n\n\ttrace_rtc_set_alarm(rtc_tm_to_time64(&alarm->time), err);\n\treturn err;\n}\n\nint rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)\n{\n\tktime_t alarm_time;\n\tint err;\n\n\tif (!rtc->ops)\n\t\treturn -ENODEV;\n\telse if (!test_bit(RTC_FEATURE_ALARM, rtc->features))\n\t\treturn -EINVAL;\n\n\terr = rtc_valid_tm(&alarm->time);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = rtc_valid_range(rtc, &alarm->time);\n\tif (err)\n\t\treturn err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\tif (rtc->aie_timer.enabled)\n\t\trtc_timer_remove(rtc, &rtc->aie_timer);\n\n\talarm_time = rtc_tm_to_ktime(alarm->time);\n\t \n\tif (test_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->features))\n\t\talarm_time = ktime_sub_ns(alarm_time, (u64)alarm->time.tm_sec * NSEC_PER_SEC);\n\n\trtc->aie_timer.node.expires = alarm_time;\n\trtc->aie_timer.period = 0;\n\tif (alarm->enabled)\n\t\terr = rtc_timer_enqueue(rtc, &rtc->aie_timer);\n\n\tmutex_unlock(&rtc->ops_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_set_alarm);\n\n \nint rtc_initialize_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)\n{\n\tint err;\n\tstruct rtc_time now;\n\n\terr = rtc_valid_tm(&alarm->time);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = rtc_read_time(rtc, &now);\n\tif (err)\n\t\treturn err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\trtc->aie_timer.node.expires = rtc_tm_to_ktime(alarm->time);\n\trtc->aie_timer.period = 0;\n\n\t \n\tif (alarm->enabled && (rtc_tm_to_ktime(now) <\n\t\t\t rtc->aie_timer.node.expires)) {\n\t\trtc->aie_timer.enabled = 1;\n\t\ttimerqueue_add(&rtc->timerqueue, &rtc->aie_timer.node);\n\t\ttrace_rtc_timer_enqueue(&rtc->aie_timer);\n\t}\n\tmutex_unlock(&rtc->ops_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_initialize_alarm);\n\nint rtc_alarm_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (rtc->aie_timer.enabled != enabled) {\n\t\tif (enabled)\n\t\t\terr = rtc_timer_enqueue(rtc, &rtc->aie_timer);\n\t\telse\n\t\t\trtc_timer_remove(rtc, &rtc->aie_timer);\n\t}\n\n\tif (err)\n\t\t ;\n\telse if (!rtc->ops)\n\t\terr = -ENODEV;\n\telse if (!test_bit(RTC_FEATURE_ALARM, rtc->features) || !rtc->ops->alarm_irq_enable)\n\t\terr = -EINVAL;\n\telse\n\t\terr = rtc->ops->alarm_irq_enable(rtc->dev.parent, enabled);\n\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_alarm_irq_enable(enabled, err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_alarm_irq_enable);\n\nint rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tif (enabled == 0 && rtc->uie_irq_active) {\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, 0);\n\t}\n#endif\n\t \n\tif (rtc->uie_rtctimer.enabled == enabled)\n\t\tgoto out;\n\n\tif (!test_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features) ||\n\t    !test_bit(RTC_FEATURE_ALARM, rtc->features)) {\n\t\tmutex_unlock(&rtc->ops_lock);\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, enabled);\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tif (enabled) {\n\t\tstruct rtc_time tm;\n\t\tktime_t now, onesec;\n\n\t\terr = __rtc_read_time(rtc, &tm);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tonesec = ktime_set(1, 0);\n\t\tnow = rtc_tm_to_ktime(tm);\n\t\trtc->uie_rtctimer.node.expires = ktime_add(now, onesec);\n\t\trtc->uie_rtctimer.period = ktime_set(1, 0);\n\t\terr = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);\n\t} else {\n\t\trtc_timer_remove(rtc, &rtc->uie_rtctimer);\n\t}\n\nout:\n\tmutex_unlock(&rtc->ops_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtc_update_irq_enable);\n\n \nvoid rtc_handle_legacy_irq(struct rtc_device *rtc, int num, int mode)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&rtc->irq_lock, flags);\n\trtc->irq_data = (rtc->irq_data + (num << 8)) | (RTC_IRQF | mode);\n\tspin_unlock_irqrestore(&rtc->irq_lock, flags);\n\n\twake_up_interruptible(&rtc->irq_queue);\n\tkill_fasync(&rtc->async_queue, SIGIO, POLL_IN);\n}\n\n \nvoid rtc_aie_update_irq(struct rtc_device *rtc)\n{\n\trtc_handle_legacy_irq(rtc, 1, RTC_AF);\n}\n\n \nvoid rtc_uie_update_irq(struct rtc_device *rtc)\n{\n\trtc_handle_legacy_irq(rtc, 1,  RTC_UF);\n}\n\n \nenum hrtimer_restart rtc_pie_update_irq(struct hrtimer *timer)\n{\n\tstruct rtc_device *rtc;\n\tktime_t period;\n\tu64 count;\n\n\trtc = container_of(timer, struct rtc_device, pie_timer);\n\n\tperiod = NSEC_PER_SEC / rtc->irq_freq;\n\tcount = hrtimer_forward_now(timer, period);\n\n\trtc_handle_legacy_irq(rtc, count, RTC_PF);\n\n\treturn HRTIMER_RESTART;\n}\n\n \nvoid rtc_update_irq(struct rtc_device *rtc,\n\t\t    unsigned long num, unsigned long events)\n{\n\tif (IS_ERR_OR_NULL(rtc))\n\t\treturn;\n\n\tpm_stay_awake(rtc->dev.parent);\n\tschedule_work(&rtc->irqwork);\n}\nEXPORT_SYMBOL_GPL(rtc_update_irq);\n\nstruct rtc_device *rtc_class_open(const char *name)\n{\n\tstruct device *dev;\n\tstruct rtc_device *rtc = NULL;\n\n\tdev = class_find_device_by_name(rtc_class, name);\n\tif (dev)\n\t\trtc = to_rtc_device(dev);\n\n\tif (rtc) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tput_device(dev);\n\t\t\trtc = NULL;\n\t\t}\n\t}\n\n\treturn rtc;\n}\nEXPORT_SYMBOL_GPL(rtc_class_open);\n\nvoid rtc_class_close(struct rtc_device *rtc)\n{\n\tmodule_put(rtc->owner);\n\tput_device(&rtc->dev);\n}\nEXPORT_SYMBOL_GPL(rtc_class_close);\n\nstatic int rtc_update_hrtimer(struct rtc_device *rtc, int enabled)\n{\n\t \n\tif (hrtimer_try_to_cancel(&rtc->pie_timer) < 0)\n\t\treturn -1;\n\n\tif (enabled) {\n\t\tktime_t period = NSEC_PER_SEC / rtc->irq_freq;\n\n\t\thrtimer_start(&rtc->pie_timer, period, HRTIMER_MODE_REL);\n\t}\n\treturn 0;\n}\n\n \nint rtc_irq_set_state(struct rtc_device *rtc, int enabled)\n{\n\tint err = 0;\n\n\twhile (rtc_update_hrtimer(rtc, enabled) < 0)\n\t\tcpu_relax();\n\n\trtc->pie_enabled = enabled;\n\n\ttrace_rtc_irq_set_state(enabled, err);\n\treturn err;\n}\n\n \nint rtc_irq_set_freq(struct rtc_device *rtc, int freq)\n{\n\tint err = 0;\n\n\tif (freq <= 0 || freq > RTC_MAX_FREQ)\n\t\treturn -EINVAL;\n\n\trtc->irq_freq = freq;\n\twhile (rtc->pie_enabled && rtc_update_hrtimer(rtc, 1) < 0)\n\t\tcpu_relax();\n\n\ttrace_rtc_irq_set_freq(freq, err);\n\treturn err;\n}\n\n \nstatic int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)\n{\n\tstruct timerqueue_node *next = timerqueue_getnext(&rtc->timerqueue);\n\tstruct rtc_time tm;\n\tktime_t now;\n\tint err;\n\n\terr = __rtc_read_time(rtc, &tm);\n\tif (err)\n\t\treturn err;\n\n\ttimer->enabled = 1;\n\tnow = rtc_tm_to_ktime(tm);\n\n\t \n\twhile (next) {\n\t\tif (next->expires >= now)\n\t\t\tbreak;\n\t\tnext = timerqueue_iterate_next(next);\n\t}\n\n\ttimerqueue_add(&rtc->timerqueue, &timer->node);\n\ttrace_rtc_timer_enqueue(timer);\n\tif (!next || ktime_before(timer->node.expires, next->expires)) {\n\t\tstruct rtc_wkalrm alarm;\n\n\t\talarm.time = rtc_ktime_to_tm(timer->node.expires);\n\t\talarm.enabled = 1;\n\t\terr = __rtc_set_alarm(rtc, &alarm);\n\t\tif (err == -ETIME) {\n\t\t\tpm_stay_awake(rtc->dev.parent);\n\t\t\tschedule_work(&rtc->irqwork);\n\t\t} else if (err) {\n\t\t\ttimerqueue_del(&rtc->timerqueue, &timer->node);\n\t\t\ttrace_rtc_timer_dequeue(timer);\n\t\t\ttimer->enabled = 0;\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void rtc_alarm_disable(struct rtc_device *rtc)\n{\n\tif (!rtc->ops || !test_bit(RTC_FEATURE_ALARM, rtc->features) || !rtc->ops->alarm_irq_enable)\n\t\treturn;\n\n\trtc->ops->alarm_irq_enable(rtc->dev.parent, false);\n\ttrace_rtc_alarm_irq_enable(0, 0);\n}\n\n \nstatic void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer)\n{\n\tstruct timerqueue_node *next = timerqueue_getnext(&rtc->timerqueue);\n\n\ttimerqueue_del(&rtc->timerqueue, &timer->node);\n\ttrace_rtc_timer_dequeue(timer);\n\ttimer->enabled = 0;\n\tif (next == &timer->node) {\n\t\tstruct rtc_wkalrm alarm;\n\t\tint err;\n\n\t\tnext = timerqueue_getnext(&rtc->timerqueue);\n\t\tif (!next) {\n\t\t\trtc_alarm_disable(rtc);\n\t\t\treturn;\n\t\t}\n\t\talarm.time = rtc_ktime_to_tm(next->expires);\n\t\talarm.enabled = 1;\n\t\terr = __rtc_set_alarm(rtc, &alarm);\n\t\tif (err == -ETIME) {\n\t\t\tpm_stay_awake(rtc->dev.parent);\n\t\t\tschedule_work(&rtc->irqwork);\n\t\t}\n\t}\n}\n\n \nvoid rtc_timer_do_work(struct work_struct *work)\n{\n\tstruct rtc_timer *timer;\n\tstruct timerqueue_node *next;\n\tktime_t now;\n\tstruct rtc_time tm;\n\n\tstruct rtc_device *rtc =\n\t\tcontainer_of(work, struct rtc_device, irqwork);\n\n\tmutex_lock(&rtc->ops_lock);\nagain:\n\t__rtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\twhile ((next = timerqueue_getnext(&rtc->timerqueue))) {\n\t\tif (next->expires > now)\n\t\t\tbreak;\n\n\t\t \n\t\ttimer = container_of(next, struct rtc_timer, node);\n\t\ttimerqueue_del(&rtc->timerqueue, &timer->node);\n\t\ttrace_rtc_timer_dequeue(timer);\n\t\ttimer->enabled = 0;\n\t\tif (timer->func)\n\t\t\ttimer->func(timer->rtc);\n\n\t\ttrace_rtc_timer_fired(timer);\n\t\t \n\t\tif (ktime_to_ns(timer->period)) {\n\t\t\ttimer->node.expires = ktime_add(timer->node.expires,\n\t\t\t\t\t\t\ttimer->period);\n\t\t\ttimer->enabled = 1;\n\t\t\ttimerqueue_add(&rtc->timerqueue, &timer->node);\n\t\t\ttrace_rtc_timer_enqueue(timer);\n\t\t}\n\t}\n\n\t \n\tif (next) {\n\t\tstruct rtc_wkalrm alarm;\n\t\tint err;\n\t\tint retry = 3;\n\n\t\talarm.time = rtc_ktime_to_tm(next->expires);\n\t\talarm.enabled = 1;\nreprogram:\n\t\terr = __rtc_set_alarm(rtc, &alarm);\n\t\tif (err == -ETIME) {\n\t\t\tgoto again;\n\t\t} else if (err) {\n\t\t\tif (retry-- > 0)\n\t\t\t\tgoto reprogram;\n\n\t\t\ttimer = container_of(next, struct rtc_timer, node);\n\t\t\ttimerqueue_del(&rtc->timerqueue, &timer->node);\n\t\t\ttrace_rtc_timer_dequeue(timer);\n\t\t\ttimer->enabled = 0;\n\t\t\tdev_err(&rtc->dev, \"__rtc_set_alarm: err=%d\\n\", err);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\trtc_alarm_disable(rtc);\n\t}\n\n\tpm_relax(rtc->dev.parent);\n\tmutex_unlock(&rtc->ops_lock);\n}\n\n \nvoid rtc_timer_init(struct rtc_timer *timer, void (*f)(struct rtc_device *r),\n\t\t    struct rtc_device *rtc)\n{\n\ttimerqueue_init(&timer->node);\n\ttimer->enabled = 0;\n\ttimer->func = f;\n\ttimer->rtc = rtc;\n}\n\n \nint rtc_timer_start(struct rtc_device *rtc, struct rtc_timer *timer,\n\t\t    ktime_t expires, ktime_t period)\n{\n\tint ret = 0;\n\n\tmutex_lock(&rtc->ops_lock);\n\tif (timer->enabled)\n\t\trtc_timer_remove(rtc, timer);\n\n\ttimer->node.expires = expires;\n\ttimer->period = period;\n\n\tret = rtc_timer_enqueue(rtc, timer);\n\n\tmutex_unlock(&rtc->ops_lock);\n\treturn ret;\n}\n\n \nvoid rtc_timer_cancel(struct rtc_device *rtc, struct rtc_timer *timer)\n{\n\tmutex_lock(&rtc->ops_lock);\n\tif (timer->enabled)\n\t\trtc_timer_remove(rtc, timer);\n\tmutex_unlock(&rtc->ops_lock);\n}\n\n \nint rtc_read_offset(struct rtc_device *rtc, long *offset)\n{\n\tint ret;\n\n\tif (!rtc->ops)\n\t\treturn -ENODEV;\n\n\tif (!rtc->ops->read_offset)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rtc->ops_lock);\n\tret = rtc->ops->read_offset(rtc->dev.parent, offset);\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_read_offset(*offset, ret);\n\treturn ret;\n}\n\n \nint rtc_set_offset(struct rtc_device *rtc, long offset)\n{\n\tint ret;\n\n\tif (!rtc->ops)\n\t\treturn -ENODEV;\n\n\tif (!rtc->ops->set_offset)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rtc->ops_lock);\n\tret = rtc->ops->set_offset(rtc->dev.parent, offset);\n\tmutex_unlock(&rtc->ops_lock);\n\n\ttrace_rtc_set_offset(offset, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}