{
  "module_name": "rtc-rx8581.c",
  "hash_id": "27f243de1242eef3705231b6ea9538a6ff5d46b78946a529a863404cd88ea986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rx8581.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/log2.h>\n\n#define RX8581_REG_SC\t\t0x00  \n#define RX8581_REG_MN\t\t0x01  \n#define RX8581_REG_HR\t\t0x02  \n#define RX8581_REG_DW\t\t0x03  \n#define RX8581_REG_DM\t\t0x04  \n#define RX8581_REG_MO\t\t0x05  \n#define RX8581_REG_YR\t\t0x06  \n#define RX8581_REG_RAM\t\t0x07  \n#define RX8581_REG_AMN\t\t0x08  \n#define RX8581_REG_AHR\t\t0x09  \n#define RX8581_REG_ADM\t\t0x0A\n#define RX8581_REG_ADW\t\t0x0A\n#define RX8581_REG_TMR0\t\t0x0B\n#define RX8581_REG_TMR1\t\t0x0C\n#define RX8581_REG_EXT\t\t0x0D  \n#define RX8581_REG_FLAG\t\t0x0E  \n#define RX8581_REG_CTRL\t\t0x0F  \n\n\n \n#define RX8581_FLAG_UF\t\t0x20  \n#define RX8581_FLAG_TF\t\t0x10  \n#define RX8581_FLAG_AF\t\t0x08  \n#define RX8581_FLAG_VLF\t\t0x02  \n\n \n#define RX8581_CTRL_UIE\t\t0x20  \n#define RX8581_CTRL_TIE\t\t0x10  \n#define RX8581_CTRL_AIE\t\t0x08  \n#define RX8581_CTRL_STOP\t0x02  \n#define RX8581_CTRL_RESET\t0x01  \n\n#define RX8571_USER_RAM\t\t0x10\n#define RX8571_NVRAM_SIZE\t0x10\n\nstruct rx8581 {\n\tstruct regmap\t\t*regmap;\n\tstruct rtc_device\t*rtc;\n};\n\nstruct rx85x1_config {\n\tstruct regmap_config regmap;\n\tunsigned int num_nvram;\n};\n\n \nstatic int rx8581_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char date[7];\n\tunsigned int data;\n\tint err;\n\tstruct rx8581 *rx8581 = i2c_get_clientdata(client);\n\n\t \n\terr = regmap_read(rx8581->regmap, RX8581_REG_FLAG, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (data & RX8581_FLAG_VLF) {\n\t\tdev_warn(dev,\n\t\t\t \"low voltage detected, date/time is not reliable.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\t \n\t\tif (data & RX8581_FLAG_UF) {\n\t\t\terr = regmap_write(rx8581->regmap, RX8581_REG_FLAG,\n\t\t\t\t\t  data & ~RX8581_FLAG_UF);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = regmap_bulk_read(rx8581->regmap, RX8581_REG_SC, date,\n\t\t\t\t       sizeof(date));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = regmap_read(rx8581->regmap, RX8581_REG_FLAG, &data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} while (data & RX8581_FLAG_UF);\n\n\tdev_dbg(dev, \"%s: raw data is sec=%02x, min=%02x, hr=%02x, \"\n\t\t\"wday=%02x, mday=%02x, mon=%02x, year=%02x\\n\",\n\t\t__func__,\n\t\tdate[0], date[1], date[2], date[3], date[4], date[5], date[6]);\n\n\ttm->tm_sec = bcd2bin(date[RX8581_REG_SC] & 0x7F);\n\ttm->tm_min = bcd2bin(date[RX8581_REG_MN] & 0x7F);\n\ttm->tm_hour = bcd2bin(date[RX8581_REG_HR] & 0x3F);  \n\ttm->tm_wday = ilog2(date[RX8581_REG_DW] & 0x7F);\n\ttm->tm_mday = bcd2bin(date[RX8581_REG_DM] & 0x3F);\n\ttm->tm_mon = bcd2bin(date[RX8581_REG_MO] & 0x1F) - 1;  \n\ttm->tm_year = bcd2bin(date[RX8581_REG_YR]) + 100;\n\n\tdev_dbg(dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int rx8581_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint err;\n\tunsigned char buf[7];\n\tstruct rx8581 *rx8581 = i2c_get_clientdata(client);\n\n\tdev_dbg(dev, \"%s: secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\t \n\tbuf[RX8581_REG_SC] = bin2bcd(tm->tm_sec);\n\tbuf[RX8581_REG_MN] = bin2bcd(tm->tm_min);\n\tbuf[RX8581_REG_HR] = bin2bcd(tm->tm_hour);\n\n\tbuf[RX8581_REG_DM] = bin2bcd(tm->tm_mday);\n\n\t \n\tbuf[RX8581_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[RX8581_REG_YR] = bin2bcd(tm->tm_year - 100);\n\tbuf[RX8581_REG_DW] = (0x1 << tm->tm_wday);\n\n\t \n\terr = regmap_update_bits(rx8581->regmap, RX8581_REG_CTRL,\n\t\t\t\t RX8581_CTRL_STOP, RX8581_CTRL_STOP);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_bulk_write(rx8581->regmap, RX8581_REG_SC,\n\t\t\t\tbuf, sizeof(buf));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(rx8581->regmap, RX8581_REG_FLAG,\n\t\t\t\t RX8581_FLAG_VLF, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn regmap_update_bits(rx8581->regmap, RX8581_REG_CTRL,\n\t\t\t\t RX8581_CTRL_STOP, 0);\n}\n\nstatic const struct rtc_class_ops rx8581_rtc_ops = {\n\t.read_time\t= rx8581_rtc_read_time,\n\t.set_time\t= rx8581_rtc_set_time,\n};\n\nstatic int rx8571_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct rx8581 *rx8581 = priv;\n\n\treturn regmap_bulk_read(rx8581->regmap, RX8571_USER_RAM + offset,\n\t\t\t\tval, bytes);\n}\n\nstatic int rx8571_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct rx8581 *rx8581 = priv;\n\n\treturn regmap_bulk_write(rx8581->regmap, RX8571_USER_RAM + offset,\n\t\t\t\t val, bytes);\n}\n\nstatic int rx85x1_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct rx8581 *rx8581 = priv;\n\tunsigned int tmp_val;\n\tint ret;\n\n\tret = regmap_read(rx8581->regmap, RX8581_REG_RAM, &tmp_val);\n\t(*(unsigned char *)val) = (unsigned char) tmp_val;\n\n\treturn ret;\n}\n\nstatic int rx85x1_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct rx8581 *rx8581 = priv;\n\tunsigned char tmp_val;\n\n\ttmp_val = *((unsigned char *)val);\n\treturn regmap_write(rx8581->regmap, RX8581_REG_RAM,\n\t\t\t\t(unsigned int)tmp_val);\n}\n\nstatic const struct rx85x1_config rx8581_config = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xf,\n\t},\n\t.num_nvram = 1\n};\n\nstatic const struct rx85x1_config rx8571_config = {\n\t.regmap = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x1f,\n\t},\n\t.num_nvram = 2\n};\n\nstatic int rx8581_probe(struct i2c_client *client)\n{\n\tstruct rx8581 *rx8581;\n\tconst struct rx85x1_config *config = &rx8581_config;\n\tconst void *data = of_device_get_match_data(&client->dev);\n\tstatic struct nvmem_config nvmem_cfg[] = {\n\t\t{\n\t\t\t.name = \"rx85x1-\",\n\t\t\t.word_size = 1,\n\t\t\t.stride = 1,\n\t\t\t.size = 1,\n\t\t\t.reg_read = rx85x1_nvram_read,\n\t\t\t.reg_write = rx85x1_nvram_write,\n\t\t}, {\n\t\t\t.name = \"rx8571-\",\n\t\t\t.word_size = 1,\n\t\t\t.stride = 1,\n\t\t\t.size = RX8571_NVRAM_SIZE,\n\t\t\t.reg_read = rx8571_nvram_read,\n\t\t\t.reg_write = rx8571_nvram_write,\n\t\t},\n\t};\n\tint ret, i;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tif (data)\n\t\tconfig = data;\n\n\trx8581 = devm_kzalloc(&client->dev, sizeof(struct rx8581), GFP_KERNEL);\n\tif (!rx8581)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, rx8581);\n\n\trx8581->regmap = devm_regmap_init_i2c(client, &config->regmap);\n\tif (IS_ERR(rx8581->regmap))\n\t\treturn PTR_ERR(rx8581->regmap);\n\n\trx8581->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rx8581->rtc))\n\t\treturn PTR_ERR(rx8581->rtc);\n\n\trx8581->rtc->ops = &rx8581_rtc_ops;\n\trx8581->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trx8581->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\trx8581->rtc->start_secs = 0;\n\trx8581->rtc->set_start_time = true;\n\n\tret = devm_rtc_register_device(rx8581->rtc);\n\n\tfor (i = 0; i < config->num_nvram; i++) {\n\t\tnvmem_cfg[i].priv = rx8581;\n\t\tdevm_rtc_nvmem_register(rx8581->rtc, &nvmem_cfg[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id rx8581_id[] = {\n\t{ \"rx8581\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rx8581_id);\n\nstatic const __maybe_unused struct of_device_id rx8581_of_match[] = {\n\t{ .compatible = \"epson,rx8571\", .data = &rx8571_config },\n\t{ .compatible = \"epson,rx8581\", .data = &rx8581_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rx8581_of_match);\n\nstatic struct i2c_driver rx8581_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-rx8581\",\n\t\t.of_match_table = of_match_ptr(rx8581_of_match),\n\t},\n\t.probe\t\t= rx8581_probe,\n\t.id_table\t= rx8581_id,\n};\n\nmodule_i2c_driver(rx8581_driver);\n\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@ge.com>\");\nMODULE_DESCRIPTION(\"Epson RX-8571/RX-8581 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}