{
  "module_name": "rtc-ab-eoz9.c",
  "hash_id": "cb0f3eb520a5f9acc331f451af01ed977fc6bc5459fb82a88e384a453ae313c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ab-eoz9.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n\n#define ABEOZ9_REG_CTRL1\t\t0x00\n#define ABEOZ9_REG_CTRL1_MASK\t\tGENMASK(7, 0)\n#define ABEOZ9_REG_CTRL1_WE\t\tBIT(0)\n#define ABEOZ9_REG_CTRL1_TE\t\tBIT(1)\n#define ABEOZ9_REG_CTRL1_TAR\t\tBIT(2)\n#define ABEOZ9_REG_CTRL1_EERE\t\tBIT(3)\n#define ABEOZ9_REG_CTRL1_SRON\t\tBIT(4)\n#define ABEOZ9_REG_CTRL1_TD0\t\tBIT(5)\n#define ABEOZ9_REG_CTRL1_TD1\t\tBIT(6)\n#define ABEOZ9_REG_CTRL1_CLKINT\t\tBIT(7)\n\n#define ABEOZ9_REG_CTRL_INT\t\t0x01\n#define ABEOZ9_REG_CTRL_INT_AIE\t\tBIT(0)\n#define ABEOZ9_REG_CTRL_INT_TIE\t\tBIT(1)\n#define ABEOZ9_REG_CTRL_INT_V1IE\tBIT(2)\n#define ABEOZ9_REG_CTRL_INT_V2IE\tBIT(3)\n#define ABEOZ9_REG_CTRL_INT_SRIE\tBIT(4)\n\n#define ABEOZ9_REG_CTRL_INT_FLAG\t0x02\n#define ABEOZ9_REG_CTRL_INT_FLAG_AF\tBIT(0)\n#define ABEOZ9_REG_CTRL_INT_FLAG_TF\tBIT(1)\n#define ABEOZ9_REG_CTRL_INT_FLAG_V1IF\tBIT(2)\n#define ABEOZ9_REG_CTRL_INT_FLAG_V2IF\tBIT(3)\n#define ABEOZ9_REG_CTRL_INT_FLAG_SRF\tBIT(4)\n\n#define ABEOZ9_REG_CTRL_STATUS\t\t0x03\n#define ABEOZ9_REG_CTRL_STATUS_V1F\tBIT(2)\n#define ABEOZ9_REG_CTRL_STATUS_V2F\tBIT(3)\n#define ABEOZ9_REG_CTRL_STATUS_SR\tBIT(4)\n#define ABEOZ9_REG_CTRL_STATUS_PON\tBIT(5)\n#define ABEOZ9_REG_CTRL_STATUS_EEBUSY\tBIT(7)\n\n#define ABEOZ9_REG_SEC\t\t\t0x08\n#define ABEOZ9_REG_MIN\t\t\t0x09\n#define ABEOZ9_REG_HOURS\t\t0x0A\n#define ABEOZ9_HOURS_PM\t\t\tBIT(6)\n#define ABEOZ9_REG_DAYS\t\t\t0x0B\n#define ABEOZ9_REG_WEEKDAYS\t\t0x0C\n#define ABEOZ9_REG_MONTHS\t\t0x0D\n#define ABEOZ9_REG_YEARS\t\t0x0E\n\n#define ABEOZ9_SEC_LEN\t\t\t7\n\n#define ABEOZ9_REG_ALARM_SEC\t\t0x10\n#define ABEOZ9_BIT_ALARM_SEC\t\tGENMASK(6, 0)\n#define ABEOZ9_REG_ALARM_MIN\t\t0x11\n#define ABEOZ9_BIT_ALARM_MIN\t\tGENMASK(6, 0)\n#define ABEOZ9_REG_ALARM_HOURS\t\t0x12\n#define ABEOZ9_BIT_ALARM_HOURS_PM\tBIT(5)\n#define ABEOZ9_BIT_ALARM_HOURS\t\tGENMASK(4, 0)\n#define ABEOZ9_REG_ALARM_DAYS\t\t0x13\n#define ABEOZ9_BIT_ALARM_DAYS\t\tGENMASK(5, 0)\n#define ABEOZ9_REG_ALARM_WEEKDAYS\t0x14\n#define ABEOZ9_BIT_ALARM_WEEKDAYS\tGENMASK(2, 0)\n#define ABEOZ9_REG_ALARM_MONTHS\t\t0x15\n#define ABEOZ9_BIT_ALARM_MONTHS\t\tGENMASK(4, 0)\n#define ABEOZ9_REG_ALARM_YEARS\t\t0x16\n\n#define ABEOZ9_ALARM_LEN\t\t7\n#define ABEOZ9_BIT_ALARM_AE\t\tBIT(7)\n\n#define ABEOZ9_REG_REG_TEMP\t\t0x20\n#define ABEOZ953_TEMP_MAX\t\t120\n#define ABEOZ953_TEMP_MIN\t\t-60\n\n#define ABEOZ9_REG_EEPROM\t\t0x30\n#define ABEOZ9_REG_EEPROM_MASK\t\tGENMASK(8, 0)\n#define ABEOZ9_REG_EEPROM_THP\t\tBIT(0)\n#define ABEOZ9_REG_EEPROM_THE\t\tBIT(1)\n#define ABEOZ9_REG_EEPROM_FD0\t\tBIT(2)\n#define ABEOZ9_REG_EEPROM_FD1\t\tBIT(3)\n#define ABEOZ9_REG_EEPROM_R1K\t\tBIT(4)\n#define ABEOZ9_REG_EEPROM_R5K\t\tBIT(5)\n#define ABEOZ9_REG_EEPROM_R20K\t\tBIT(6)\n#define ABEOZ9_REG_EEPROM_R80K\t\tBIT(7)\n\nstruct abeoz9_rtc_data {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\tstruct device *hwmon_dev;\n};\n\nstatic int abeoz9_check_validity(struct device *dev)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret;\n\tint val;\n\n\tret = regmap_read(regmap, ABEOZ9_REG_CTRL_STATUS, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"unable to get CTRL_STATUS register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val & ABEOZ9_REG_CTRL_STATUS_PON) {\n\t\tdev_warn(dev, \"power-on reset detected, date is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (val & ABEOZ9_REG_CTRL_STATUS_V1F) {\n\t\tdev_warn(dev,\n\t\t\t \"voltage drops below VLOW1 threshold, date is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((val & ABEOZ9_REG_CTRL_STATUS_V2F)) {\n\t\tdev_warn(dev,\n\t\t\t \"voltage drops below VLOW2 threshold, date is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int abeoz9_reset_validity(struct regmap *regmap)\n{\n\treturn regmap_update_bits(regmap, ABEOZ9_REG_CTRL_STATUS,\n\t\t\t\t  ABEOZ9_REG_CTRL_STATUS_V1F |\n\t\t\t\t  ABEOZ9_REG_CTRL_STATUS_V2F |\n\t\t\t\t  ABEOZ9_REG_CTRL_STATUS_PON,\n\t\t\t\t  0);\n}\n\nstatic int abeoz9_rtc_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tu8 regs[ABEOZ9_SEC_LEN];\n\tint ret;\n\n\tret = abeoz9_check_validity(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(data->regmap, ABEOZ9_REG_SEC,\n\t\t\t       regs,\n\t\t\t       sizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"reading RTC time failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec = bcd2bin(regs[ABEOZ9_REG_SEC - ABEOZ9_REG_SEC] & 0x7F);\n\ttm->tm_min = bcd2bin(regs[ABEOZ9_REG_MIN - ABEOZ9_REG_SEC] & 0x7F);\n\n\tif (regs[ABEOZ9_REG_HOURS - ABEOZ9_REG_SEC] & ABEOZ9_HOURS_PM) {\n\t\ttm->tm_hour =\n\t\t\tbcd2bin(regs[ABEOZ9_REG_HOURS - ABEOZ9_REG_SEC] & 0x1f);\n\t\tif (regs[ABEOZ9_REG_HOURS - ABEOZ9_REG_SEC] & ABEOZ9_HOURS_PM)\n\t\t\ttm->tm_hour += 12;\n\t} else {\n\t\ttm->tm_hour = bcd2bin(regs[ABEOZ9_REG_HOURS - ABEOZ9_REG_SEC]);\n\t}\n\n\ttm->tm_mday = bcd2bin(regs[ABEOZ9_REG_DAYS - ABEOZ9_REG_SEC]);\n\ttm->tm_wday = bcd2bin(regs[ABEOZ9_REG_WEEKDAYS - ABEOZ9_REG_SEC]);\n\ttm->tm_mon  = bcd2bin(regs[ABEOZ9_REG_MONTHS - ABEOZ9_REG_SEC]) - 1;\n\ttm->tm_year = bcd2bin(regs[ABEOZ9_REG_YEARS - ABEOZ9_REG_SEC]) + 100;\n\n\treturn ret;\n}\n\nstatic int abeoz9_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu8 regs[ABEOZ9_SEC_LEN];\n\tint ret;\n\n\tregs[ABEOZ9_REG_SEC - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_sec);\n\tregs[ABEOZ9_REG_MIN - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_min);\n\tregs[ABEOZ9_REG_HOURS - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_hour);\n\tregs[ABEOZ9_REG_DAYS - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_mday);\n\tregs[ABEOZ9_REG_WEEKDAYS - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_wday);\n\tregs[ABEOZ9_REG_MONTHS - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_mon + 1);\n\tregs[ABEOZ9_REG_YEARS - ABEOZ9_REG_SEC] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(data->regmap, ABEOZ9_REG_SEC,\n\t\t\t\tregs,\n\t\t\t\tsizeof(regs));\n\n\tif (ret) {\n\t\tdev_err(dev, \"set RTC time failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn abeoz9_reset_validity(regmap);\n}\n\nstatic int abeoz9_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tu8 regs[ABEOZ9_ALARM_LEN];\n\tu8 val[2];\n\tint ret;\n\n\tret = abeoz9_check_validity(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(regmap, ABEOZ9_REG_CTRL_INT, val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\talarm->enabled = val[0] & ABEOZ9_REG_CTRL_INT_AIE;\n\talarm->pending = val[1] & ABEOZ9_REG_CTRL_INT_FLAG_AF;\n\n\tret = regmap_bulk_read(regmap, ABEOZ9_REG_ALARM_SEC, regs, sizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\talarm->time.tm_sec = bcd2bin(FIELD_GET(ABEOZ9_BIT_ALARM_SEC, regs[0]));\n\talarm->time.tm_min = bcd2bin(FIELD_GET(ABEOZ9_BIT_ALARM_MIN, regs[1]));\n\talarm->time.tm_hour = bcd2bin(FIELD_GET(ABEOZ9_BIT_ALARM_HOURS, regs[2]));\n\tif (FIELD_GET(ABEOZ9_BIT_ALARM_HOURS_PM, regs[2]))\n\t\talarm->time.tm_hour += 12;\n\n\talarm->time.tm_mday = bcd2bin(FIELD_GET(ABEOZ9_BIT_ALARM_DAYS, regs[3]));\n\n\treturn 0;\n}\n\nstatic int abeoz9_rtc_alarm_irq_enable(struct device *dev, u32 enable)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(data->regmap, ABEOZ9_REG_CTRL_INT,\n\t\t\t\t  ABEOZ9_REG_CTRL_INT_AIE,\n\t\t\t\t  FIELD_PREP(ABEOZ9_REG_CTRL_INT_AIE, enable));\n}\n\nstatic int abeoz9_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tu8 regs[ABEOZ9_ALARM_LEN] = {0};\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, ABEOZ9_REG_CTRL_INT_FLAG,\n\t\t\t\t ABEOZ9_REG_CTRL_INT_FLAG_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tregs[0] = ABEOZ9_BIT_ALARM_AE | FIELD_PREP(ABEOZ9_BIT_ALARM_SEC,\n\t\t\t\t\t\t   bin2bcd(alarm->time.tm_sec));\n\tregs[1] = ABEOZ9_BIT_ALARM_AE | FIELD_PREP(ABEOZ9_BIT_ALARM_MIN,\n\t\t\t\t\t\t   bin2bcd(alarm->time.tm_min));\n\tregs[2] = ABEOZ9_BIT_ALARM_AE | FIELD_PREP(ABEOZ9_BIT_ALARM_HOURS,\n\t\t\t\t\t\t   bin2bcd(alarm->time.tm_hour));\n\tregs[3] = ABEOZ9_BIT_ALARM_AE | FIELD_PREP(ABEOZ9_BIT_ALARM_DAYS,\n\t\t\t\t\t\t   bin2bcd(alarm->time.tm_mday));\n\n\tret = regmap_bulk_write(data->regmap, ABEOZ9_REG_ALARM_SEC, regs,\n\t\t\t\tsizeof(regs));\n\tif (ret)\n\t\treturn ret;\n\n\treturn abeoz9_rtc_alarm_irq_enable(dev, alarm->enabled);\n}\n\nstatic irqreturn_t abeoz9_rtc_irq(int irq, void *dev)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(data->regmap, ABEOZ9_REG_CTRL_INT_FLAG, &val);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (!FIELD_GET(ABEOZ9_REG_CTRL_INT_FLAG_AF, val))\n\t\treturn IRQ_NONE;\n\n\tregmap_update_bits(data->regmap, ABEOZ9_REG_CTRL_INT_FLAG,\n\t\t\t   ABEOZ9_REG_CTRL_INT_FLAG_AF, 0);\n\n\trtc_update_irq(data->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int abeoz9_trickle_parse_dt(struct device_node *node)\n{\n\tu32 ohms = 0;\n\n\tif (of_property_read_u32(node, \"trickle-resistor-ohms\", &ohms))\n\t\treturn 0;\n\n\tswitch (ohms) {\n\tcase 1000:\n\t\treturn ABEOZ9_REG_EEPROM_R1K;\n\tcase 5000:\n\t\treturn ABEOZ9_REG_EEPROM_R5K;\n\tcase 20000:\n\t\treturn ABEOZ9_REG_EEPROM_R20K;\n\tcase 80000:\n\t\treturn ABEOZ9_REG_EEPROM_R80K;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int abeoz9_rtc_setup(struct device *dev, struct device_node *node)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, ABEOZ9_REG_CTRL1,\n\t\t\t\t ABEOZ9_REG_CTRL1_MASK,\n\t\t\t\t ABEOZ9_REG_CTRL1_WE |\n\t\t\t\t ABEOZ9_REG_CTRL1_EERE |\n\t\t\t\t ABEOZ9_REG_CTRL1_SRON);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to set CTRL_1 register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(regmap, ABEOZ9_REG_CTRL_INT, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"unable to set control CTRL_INT register (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(regmap, ABEOZ9_REG_CTRL_INT_FLAG, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"unable to set control CTRL_INT_FLAG register (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = abeoz9_trickle_parse_dt(node);\n\n\t \n\tret |= ABEOZ9_REG_EEPROM_THE;\n\n\tret = regmap_update_bits(regmap, ABEOZ9_REG_EEPROM,\n\t\t\t\t ABEOZ9_REG_EEPROM_MASK,\n\t\t\t\t ret);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to set EEPROM register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops rtc_ops = {\n\t.read_time = abeoz9_rtc_get_time,\n\t.set_time = abeoz9_rtc_set_time,\n\t.read_alarm = abeoz9_rtc_read_alarm,\n\t.set_alarm = abeoz9_rtc_set_alarm,\n\t.alarm_irq_enable = abeoz9_rtc_alarm_irq_enable,\n};\n\nstatic const struct regmap_config abeoz9_rtc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x3f,\n};\n\n#if IS_REACHABLE(CONFIG_HWMON)\n\nstatic int abeoz9z3_temp_read(struct device *dev,\n\t\t\t      enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long *temp)\n{\n\tstruct abeoz9_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(regmap, ABEOZ9_REG_CTRL_STATUS, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & ABEOZ9_REG_CTRL_STATUS_V1F) ||\n\t    (val & ABEOZ9_REG_CTRL_STATUS_V2F)) {\n\t\tdev_err(dev,\n\t\t\t\"thermometer might be disabled due to low voltage\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tret = regmap_read(regmap, ABEOZ9_REG_REG_TEMP, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*temp = 1000 * (val + ABEOZ953_TEMP_MIN);\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\t*temp = 1000 * ABEOZ953_TEMP_MAX;\n\t\treturn 0;\n\tcase hwmon_temp_min:\n\t\t*temp = 1000 * ABEOZ953_TEMP_MIN;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t abeoz9_is_visible(const void *data,\n\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_min:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const u32 abeoz9_chip_config[] = {\n\tHWMON_C_REGISTER_TZ,\n\t0\n};\n\nstatic const struct hwmon_channel_info abeoz9_chip = {\n\t.type = hwmon_chip,\n\t.config = abeoz9_chip_config,\n};\n\nstatic const u32 abeoz9_temp_config[] = {\n\tHWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MIN,\n\t0\n};\n\nstatic const struct hwmon_channel_info abeoz9_temp = {\n\t.type = hwmon_temp,\n\t.config = abeoz9_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const abeoz9_info[] = {\n\t&abeoz9_chip,\n\t&abeoz9_temp,\n\tNULL\n};\n\nstatic const struct hwmon_ops abeoz9_hwmon_ops = {\n\t.is_visible = abeoz9_is_visible,\n\t.read = abeoz9z3_temp_read,\n};\n\nstatic const struct hwmon_chip_info abeoz9_chip_info = {\n\t.ops = &abeoz9_hwmon_ops,\n\t.info = abeoz9_info,\n};\n\nstatic void abeoz9_hwmon_register(struct device *dev,\n\t\t\t\t  struct abeoz9_rtc_data *data)\n{\n\tdata->hwmon_dev =\n\t\tdevm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t     \"abeoz9\",\n\t\t\t\t\t\t     data,\n\t\t\t\t\t\t     &abeoz9_chip_info,\n\t\t\t\t\t\t     NULL);\n\tif (IS_ERR(data->hwmon_dev)) {\n\t\tdev_warn(dev, \"unable to register hwmon device %ld\\n\",\n\t\t\t PTR_ERR(data->hwmon_dev));\n\t}\n}\n\n#else\n\nstatic void abeoz9_hwmon_register(struct device *dev,\n\t\t\t\t  struct abeoz9_rtc_data *data)\n{\n}\n\n#endif\n\nstatic int abeoz9_probe(struct i2c_client *client)\n{\n\tstruct abeoz9_rtc_data *data = NULL;\n\tstruct device *dev = &client->dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(client, &abeoz9_rtc_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"regmap allocation failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\tdev_set_drvdata(dev, data);\n\n\tret = abeoz9_rtc_setup(dev, client->dev.of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->rtc = devm_rtc_allocate_device(dev);\n\tret = PTR_ERR_OR_ZERO(data->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->rtc->ops = &rtc_ops;\n\tdata->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tdata->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tclear_bit(RTC_FEATURE_ALARM, data->rtc->features);\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tabeoz9_rtc_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request alarm irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, data->rtc->features);\n\t}\n\n\tif (client->irq > 0 || device_property_read_bool(dev, \"wakeup-source\")) {\n\t\tret = device_init_wakeup(dev, true);\n\t\tset_bit(RTC_FEATURE_ALARM, data->rtc->features);\n\t}\n\n\tret = devm_rtc_register_device(data->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tabeoz9_hwmon_register(dev, data);\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id abeoz9_dt_match[] = {\n\t{ .compatible = \"abracon,abeoz9\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, abeoz9_dt_match);\n#endif\n\nstatic const struct i2c_device_id abeoz9_id[] = {\n\t{ \"abeoz9\", 0 },\n\t{ }\n};\n\nstatic struct i2c_driver abeoz9_driver = {\n\t.driver = {\n\t\t.name = \"rtc-ab-eoz9\",\n\t\t.of_match_table = of_match_ptr(abeoz9_dt_match),\n\t},\n\t.probe = abeoz9_probe,\n\t.id_table = abeoz9_id,\n};\n\nmodule_i2c_driver(abeoz9_driver);\n\nMODULE_AUTHOR(\"Artem Panfilov <panfilov.artyom@gmail.com>\");\nMODULE_DESCRIPTION(\"Abracon AB-RTCMC-32.768kHz-EOZ9 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}