{
  "module_name": "rtc-88pm80x.c",
  "hash_id": "f7dc94fc2438e1d757bb9a7393e03ada6c4bead5a0f47a8504028741116ed6d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-88pm80x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/rtc.h>\n\n#define PM800_RTC_COUNTER1\t\t(0xD1)\n#define PM800_RTC_COUNTER2\t\t(0xD2)\n#define PM800_RTC_COUNTER3\t\t(0xD3)\n#define PM800_RTC_COUNTER4\t\t(0xD4)\n#define PM800_RTC_EXPIRE1_1\t\t(0xD5)\n#define PM800_RTC_EXPIRE1_2\t\t(0xD6)\n#define PM800_RTC_EXPIRE1_3\t\t(0xD7)\n#define PM800_RTC_EXPIRE1_4\t\t(0xD8)\n#define PM800_RTC_TRIM1\t\t\t(0xD9)\n#define PM800_RTC_TRIM2\t\t\t(0xDA)\n#define PM800_RTC_TRIM3\t\t\t(0xDB)\n#define PM800_RTC_TRIM4\t\t\t(0xDC)\n#define PM800_RTC_EXPIRE2_1\t\t(0xDD)\n#define PM800_RTC_EXPIRE2_2\t\t(0xDE)\n#define PM800_RTC_EXPIRE2_3\t\t(0xDF)\n#define PM800_RTC_EXPIRE2_4\t\t(0xE0)\n\n#define PM800_POWER_DOWN_LOG1\t(0xE5)\n#define PM800_POWER_DOWN_LOG2\t(0xE6)\n\nstruct pm80x_rtc_info {\n\tstruct pm80x_chip *chip;\n\tstruct regmap *map;\n\tstruct rtc_device *rtc_dev;\n\tstruct device *dev;\n\n\tint irq;\n};\n\nstatic irqreturn_t rtc_update_handler(int irq, void *data)\n{\n\tstruct pm80x_rtc_info *info = (struct pm80x_rtc_info *)data;\n\tint mask;\n\n\tmask = PM800_ALARM | PM800_ALARM_WAKEUP;\n\tregmap_update_bits(info->map, PM800_RTC_CONTROL, mask | PM800_ALARM1_EN,\n\t\t\t   mask);\n\trtc_update_irq(info->rtc_dev, 1, RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm80x_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\tregmap_update_bits(info->map, PM800_RTC_CONTROL,\n\t\t\t\t   PM800_ALARM1_EN, PM800_ALARM1_EN);\n\telse\n\t\tregmap_update_bits(info->map, PM800_RTC_CONTROL,\n\t\t\t\t   PM800_ALARM1_EN, 0);\n\treturn 0;\n}\n\n \nstatic void rtc_next_alarm_time(struct rtc_time *next, struct rtc_time *now,\n\t\t\t\tstruct rtc_time *alrm)\n{\n\tunsigned long next_time;\n\tunsigned long now_time;\n\n\tnext->tm_year = now->tm_year;\n\tnext->tm_mon = now->tm_mon;\n\tnext->tm_mday = now->tm_mday;\n\tnext->tm_hour = alrm->tm_hour;\n\tnext->tm_min = alrm->tm_min;\n\tnext->tm_sec = alrm->tm_sec;\n\n\tnow_time = rtc_tm_to_time64(now);\n\tnext_time = rtc_tm_to_time64(next);\n\n\tif (next_time < now_time) {\n\t\t \n\t\tnext_time += 60 * 60 * 24;\n\t\trtc_time64_to_tm(next_time, next);\n\t}\n}\n\nstatic int pm80x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tunsigned long ticks, base, data;\n\tregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\n\tbase = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tdev_dbg(info->dev, \"%x-%x-%x-%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\n\t \n\tregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tticks = base + data;\n\tdev_dbg(info->dev, \"get base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\trtc_time64_to_tm(ticks, tm);\n\treturn 0;\n}\n\nstatic int pm80x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tunsigned long ticks, base, data;\n\n\tticks = rtc_tm_to_time64(tm);\n\n\t \n\tregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tbase = ticks - data;\n\tdev_dbg(info->dev, \"set base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\tbuf[0] = base & 0xFF;\n\tbuf[1] = (base >> 8) & 0xFF;\n\tbuf[2] = (base >> 16) & 0xFF;\n\tbuf[3] = (base >> 24) & 0xFF;\n\tregmap_raw_write(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\n\n\treturn 0;\n}\n\nstatic int pm80x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tunsigned long ticks, base, data;\n\tint ret;\n\n\tregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\n\tbase = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tdev_dbg(info->dev, \"%x-%x-%x-%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\n\tregmap_raw_read(info->map, PM800_RTC_EXPIRE1_1, buf, 4);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tticks = base + data;\n\tdev_dbg(info->dev, \"get base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\n\trtc_time64_to_tm(ticks, &alrm->time);\n\tregmap_read(info->map, PM800_RTC_CONTROL, &ret);\n\talrm->enabled = (ret & PM800_ALARM1_EN) ? 1 : 0;\n\talrm->pending = (ret & (PM800_ALARM | PM800_ALARM_WAKEUP)) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int pm80x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\n\tstruct rtc_time now_tm, alarm_tm;\n\tunsigned long ticks, base, data;\n\tunsigned char buf[4];\n\tint mask;\n\n\tregmap_update_bits(info->map, PM800_RTC_CONTROL, PM800_ALARM1_EN, 0);\n\n\tregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\n\tbase = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tdev_dbg(info->dev, \"%x-%x-%x-%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\n\t \n\tregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tticks = base + data;\n\tdev_dbg(info->dev, \"get base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\n\trtc_time64_to_tm(ticks, &now_tm);\n\tdev_dbg(info->dev, \"%s, now time : %lu\\n\", __func__, ticks);\n\trtc_next_alarm_time(&alarm_tm, &now_tm, &alrm->time);\n\t \n\tticks = rtc_tm_to_time64(&alarm_tm);\n\tdev_dbg(info->dev, \"%s, alarm time: %lu\\n\", __func__, ticks);\n\tdata = ticks - base;\n\n\tbuf[0] = data & 0xff;\n\tbuf[1] = (data >> 8) & 0xff;\n\tbuf[2] = (data >> 16) & 0xff;\n\tbuf[3] = (data >> 24) & 0xff;\n\tregmap_raw_write(info->map, PM800_RTC_EXPIRE1_1, buf, 4);\n\tif (alrm->enabled) {\n\t\tmask = PM800_ALARM | PM800_ALARM_WAKEUP | PM800_ALARM1_EN;\n\t\tregmap_update_bits(info->map, PM800_RTC_CONTROL, mask, mask);\n\t} else {\n\t\tmask = PM800_ALARM | PM800_ALARM_WAKEUP | PM800_ALARM1_EN;\n\t\tregmap_update_bits(info->map, PM800_RTC_CONTROL, mask,\n\t\t\t\t   PM800_ALARM | PM800_ALARM_WAKEUP);\n\t}\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pm80x_rtc_ops = {\n\t.read_time = pm80x_rtc_read_time,\n\t.set_time = pm80x_rtc_set_time,\n\t.read_alarm = pm80x_rtc_read_alarm,\n\t.set_alarm = pm80x_rtc_set_alarm,\n\t.alarm_irq_enable = pm80x_rtc_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pm80x_rtc_suspend(struct device *dev)\n{\n\treturn pm80x_dev_suspend(dev);\n}\n\nstatic int pm80x_rtc_resume(struct device *dev)\n{\n\treturn pm80x_dev_resume(dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pm80x_rtc_pm_ops, pm80x_rtc_suspend, pm80x_rtc_resume);\n\nstatic int pm80x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm80x_rtc_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct pm80x_rtc_info *info;\n\tstruct device_node *node = pdev->dev.of_node;\n\tint ret;\n\n\tif (!pdata && !node) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"pm80x-rtc requires platform data or of_node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata) {\n\t\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tdev_err(&pdev->dev, \"failed to allocate memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tinfo =\n\t    devm_kzalloc(&pdev->dev, sizeof(struct pm80x_rtc_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->irq = platform_get_irq(pdev, 0);\n\tif (info->irq < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo->chip = chip;\n\tinfo->map = chip->regmap;\n\tif (!info->map) {\n\t\tdev_err(&pdev->dev, \"no regmap!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, info);\n\n\tinfo->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc_dev))\n\t\treturn PTR_ERR(info->rtc_dev);\n\n\tret = pm80x_request_irq(chip, info->irq, rtc_update_handler,\n\t\t\t\tIRQF_ONESHOT, \"rtc\", info);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq, ret);\n\t\tgoto out;\n\t}\n\n\tinfo->rtc_dev->ops = &pm80x_rtc_ops;\n\tinfo->rtc_dev->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(info->rtc_dev);\n\tif (ret)\n\t\tgoto out_rtc;\n\n\t \n\tregmap_update_bits(info->map, PM800_RTC_CONTROL, PM800_RTC1_USE_XO,\n\t\t\t   PM800_RTC1_USE_XO);\n\n\t \n\tinfo->rtc_dev->dev.platform_data = &pdata->rtc_wakeup;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\nout_rtc:\n\tpm80x_free_irq(chip, info->irq, info);\nout:\n\treturn ret;\n}\n\nstatic void pm80x_rtc_remove(struct platform_device *pdev)\n{\n\tstruct pm80x_rtc_info *info = platform_get_drvdata(pdev);\n\tpm80x_free_irq(info->chip, info->irq, info);\n}\n\nstatic struct platform_driver pm80x_rtc_driver = {\n\t.driver = {\n\t\t   .name = \"88pm80x-rtc\",\n\t\t   .pm = &pm80x_rtc_pm_ops,\n\t\t   },\n\t.probe = pm80x_rtc_probe,\n\t.remove_new = pm80x_rtc_remove,\n};\n\nmodule_platform_driver(pm80x_rtc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Marvell 88PM80x RTC driver\");\nMODULE_AUTHOR(\"Qiao Zhou <zhouqiao@marvell.com>\");\nMODULE_ALIAS(\"platform:88pm80x-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}