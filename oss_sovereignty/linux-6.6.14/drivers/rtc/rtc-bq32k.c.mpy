{
  "module_name": "rtc-bq32k.c",
  "hash_id": "84c5627c058409b1d48e92347694ba2e75f1122a120831a4ed329e38b5e974fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-bq32k.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/kstrtox.h>\n#include <linux/errno.h>\n#include <linux/bcd.h>\n\n#define BQ32K_SECONDS\t\t0x00\t \n#define BQ32K_SECONDS_MASK\t0x7F\t \n#define BQ32K_STOP\t\t0x80\t \n\n#define BQ32K_MINUTES\t\t0x01\t \n#define BQ32K_MINUTES_MASK\t0x7F\t \n#define BQ32K_OF\t\t0x80\t \n\n#define BQ32K_HOURS_MASK\t0x3F\t \n#define BQ32K_CENT\t\t0x40\t \n#define BQ32K_CENT_EN\t\t0x80\t \n\n#define BQ32K_CALIBRATION\t0x07\t \n#define BQ32K_TCH2\t\t0x08\t \n#define BQ32K_CFG2\t\t0x09\t \n#define BQ32K_TCFE\t\tBIT(6)\t \n\n#define MAX_LEN\t\t\t10\t \n\nstruct bq32k_regs {\n\tuint8_t\t\tseconds;\n\tuint8_t\t\tminutes;\n\tuint8_t\t\tcent_hours;\n\tuint8_t\t\tday;\n\tuint8_t\t\tdate;\n\tuint8_t\t\tmonth;\n\tuint8_t\t\tyears;\n};\n\nstatic struct i2c_driver bq32k_driver;\n\nstatic int bq32k_read(struct device *dev, void *data, uint8_t off, uint8_t len)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &off,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = data,\n\t\t}\n\t};\n\n\tif (i2c_transfer(client->adapter, msgs, 2) == 2)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int bq32k_write(struct device *dev, void *data, uint8_t off, uint8_t len)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tuint8_t buffer[MAX_LEN + 1];\n\n\tbuffer[0] = off;\n\tmemcpy(&buffer[1], data, len);\n\n\tif (i2c_master_send(client, buffer, len + 1) == len + 1)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int bq32k_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bq32k_regs regs;\n\tint error;\n\n\terror = bq32k_read(dev, &regs, 0, sizeof(regs));\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (regs.minutes & BQ32K_OF)\n\t\treturn -EINVAL;\n\n\ttm->tm_sec = bcd2bin(regs.seconds & BQ32K_SECONDS_MASK);\n\ttm->tm_min = bcd2bin(regs.minutes & BQ32K_MINUTES_MASK);\n\ttm->tm_hour = bcd2bin(regs.cent_hours & BQ32K_HOURS_MASK);\n\ttm->tm_mday = bcd2bin(regs.date);\n\ttm->tm_wday = bcd2bin(regs.day) - 1;\n\ttm->tm_mon = bcd2bin(regs.month) - 1;\n\ttm->tm_year = bcd2bin(regs.years) +\n\t\t\t\t((regs.cent_hours & BQ32K_CENT) ? 100 : 0);\n\n\treturn 0;\n}\n\nstatic int bq32k_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bq32k_regs regs;\n\n\tregs.seconds = bin2bcd(tm->tm_sec);\n\tregs.minutes = bin2bcd(tm->tm_min);\n\tregs.cent_hours = bin2bcd(tm->tm_hour) | BQ32K_CENT_EN;\n\tregs.day = bin2bcd(tm->tm_wday + 1);\n\tregs.date = bin2bcd(tm->tm_mday);\n\tregs.month = bin2bcd(tm->tm_mon + 1);\n\n\tif (tm->tm_year >= 100) {\n\t\tregs.cent_hours |= BQ32K_CENT;\n\t\tregs.years = bin2bcd(tm->tm_year - 100);\n\t} else\n\t\tregs.years = bin2bcd(tm->tm_year);\n\n\treturn bq32k_write(dev, &regs, 0, sizeof(regs));\n}\n\nstatic const struct rtc_class_ops bq32k_rtc_ops = {\n\t.read_time\t= bq32k_rtc_read_time,\n\t.set_time\t= bq32k_rtc_set_time,\n};\n\nstatic int trickle_charger_of_init(struct device *dev, struct device_node *node)\n{\n\tunsigned char reg;\n\tint error;\n\tu32 ohms = 0;\n\n\tif (of_property_read_u32(node, \"trickle-resistor-ohms\" , &ohms))\n\t\treturn 0;\n\n\tswitch (ohms) {\n\tcase 180+940:\n\t\t \n\n\t\tif (of_property_read_bool(node, \"trickle-diode-disable\")) {\n\t\t\tdev_err(dev, \"diode and resistor mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treg = 0x05;\n\t\tbreak;\n\n\tcase 180+20000:\n\t\t \n\n\t\tif (!of_property_read_bool(node, \"trickle-diode-disable\")) {\n\t\t\tdev_err(dev, \"bq32k: diode and resistor mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treg = 0x45;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"invalid resistor value (%d)\\n\", ohms);\n\t\treturn -EINVAL;\n\t}\n\n\terror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\n\tif (error)\n\t\treturn error;\n\n\treg = 0x20;\n\terror = bq32k_write(dev, &reg, BQ32K_TCH2, 1);\n\tif (error)\n\t\treturn error;\n\n\tdev_info(dev, \"Enabled trickle RTC battery charge.\\n\");\n\treturn 0;\n}\n\nstatic ssize_t bq32k_sysfs_show_tricklecharge_bypass(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tint reg, error;\n\n\terror = bq32k_read(dev, &reg, BQ32K_CFG2, 1);\n\tif (error)\n\t\treturn error;\n\n\treturn sprintf(buf, \"%d\\n\", (reg & BQ32K_TCFE) ? 1 : 0);\n}\n\nstatic ssize_t bq32k_sysfs_store_tricklecharge_bypass(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint reg, enable, error;\n\n\tif (kstrtoint(buf, 0, &enable))\n\t\treturn -EINVAL;\n\n\terror = bq32k_read(dev, &reg, BQ32K_CFG2, 1);\n\tif (error)\n\t\treturn error;\n\n\tif (enable) {\n\t\treg |= BQ32K_TCFE;\n\t\terror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdev_info(dev, \"Enabled trickle charge FET bypass.\\n\");\n\t} else {\n\t\treg &= ~BQ32K_TCFE;\n\t\terror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdev_info(dev, \"Disabled trickle charge FET bypass.\\n\");\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(trickle_charge_bypass, 0644,\n\t\t   bq32k_sysfs_show_tricklecharge_bypass,\n\t\t   bq32k_sysfs_store_tricklecharge_bypass);\n\nstatic int bq32k_sysfs_register(struct device *dev)\n{\n\treturn device_create_file(dev, &dev_attr_trickle_charge_bypass);\n}\n\nstatic void bq32k_sysfs_unregister(struct device *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_trickle_charge_bypass);\n}\n\nstatic int bq32k_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct rtc_device *rtc;\n\tuint8_t reg;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\t \n\terror = bq32k_read(dev, &reg, BQ32K_SECONDS, 1);\n\tif (!error && (reg & BQ32K_STOP)) {\n\t\tdev_warn(dev, \"Oscillator was halted. Restarting...\\n\");\n\t\treg &= ~BQ32K_STOP;\n\t\terror = bq32k_write(dev, &reg, BQ32K_SECONDS, 1);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = bq32k_read(dev, &reg, BQ32K_MINUTES, 1);\n\tif (error)\n\t\treturn error;\n\tif (reg & BQ32K_OF)\n\t\tdev_warn(dev, \"Oscillator Failure. Check RTC battery.\\n\");\n\n\tif (client->dev.of_node)\n\t\ttrickle_charger_of_init(dev, client->dev.of_node);\n\n\trtc = devm_rtc_device_register(&client->dev, bq32k_driver.driver.name,\n\t\t\t\t\t\t&bq32k_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\terror = bq32k_sysfs_register(&client->dev);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to create sysfs entries for rtc bq32000\\n\");\n\t\treturn error;\n\t}\n\n\n\ti2c_set_clientdata(client, rtc);\n\n\treturn 0;\n}\n\nstatic void bq32k_remove(struct i2c_client *client)\n{\n\tbq32k_sysfs_unregister(&client->dev);\n}\n\nstatic const struct i2c_device_id bq32k_id[] = {\n\t{ \"bq32000\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, bq32k_id);\n\nstatic const __maybe_unused struct of_device_id bq32k_of_match[] = {\n\t{ .compatible = \"ti,bq32000\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bq32k_of_match);\n\nstatic struct i2c_driver bq32k_driver = {\n\t.driver = {\n\t\t.name\t= \"bq32k\",\n\t\t.of_match_table = of_match_ptr(bq32k_of_match),\n\t},\n\t.probe\t\t= bq32k_probe,\n\t.remove\t\t= bq32k_remove,\n\t.id_table\t= bq32k_id,\n};\n\nmodule_i2c_driver(bq32k_driver);\n\nMODULE_AUTHOR(\"Semihalf, Piotr Ziecik <kosmo@semihalf.com>\");\nMODULE_DESCRIPTION(\"TI BQ32000 I2C RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}