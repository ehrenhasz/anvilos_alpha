{
  "module_name": "rtc-rs5c372.c",
  "hash_id": "709ea8ff7c53cecb2879fa9187b65f2a0635e4bf6df6d4f5cec64aae5ed45c60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rs5c372.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n \n#define RS5C372_REG_SECS\t0\n#define RS5C372_REG_MINS\t1\n#define RS5C372_REG_HOURS\t2\n#define RS5C372_REG_WDAY\t3\n#define RS5C372_REG_DAY\t\t4\n#define RS5C372_REG_MONTH\t5\n#define RS5C372_REG_YEAR\t6\n#define RS5C372_REG_TRIM\t7\n#\tdefine RS5C372_TRIM_XSL\t\t0x80\t\t \n#\tdefine RS5C372_TRIM_MASK\t0x7F\n#\tdefine R2221TL_TRIM_DEV\t\t(1 << 7)\t \n#\tdefine RS5C372_TRIM_DECR\t(1 << 6)\n\n#define RS5C_REG_ALARM_A_MIN\t8\t\t\t \n#define RS5C_REG_ALARM_A_HOURS\t9\n#define RS5C_REG_ALARM_A_WDAY\t10\n\n#define RS5C_REG_ALARM_B_MIN\t11\t\t\t \n#define RS5C_REG_ALARM_B_HOURS\t12\n#define RS5C_REG_ALARM_B_WDAY\t13\t\t\t \n\n#define RS5C_REG_CTRL1\t\t14\n#\tdefine RS5C_CTRL1_AALE\t\t(1 << 7)\t \n#\tdefine RS5C_CTRL1_BALE\t\t(1 << 6)\t \n#\tdefine RV5C387_CTRL1_24\t\t(1 << 5)\n#\tdefine RS5C372A_CTRL1_SL1\t(1 << 5)\n#\tdefine RS5C_CTRL1_CT_MASK\t(7 << 0)\n#\tdefine RS5C_CTRL1_CT0\t\t(0 << 0)\t \n#\tdefine RS5C_CTRL1_CT4\t\t(4 << 0)\t \n#define RS5C_REG_CTRL2\t\t15\n#\tdefine RS5C372_CTRL2_24\t\t(1 << 5)\n#\tdefine RS5C_CTRL2_XSTP\t\t(1 << 4)\t \n#\tdefine R2x2x_CTRL2_VDET\t\t(1 << 6)\t \n#\tdefine R2x2x_CTRL2_XSTP\t\t(1 << 5)\t \n#\tdefine R2x2x_CTRL2_PON\t\t(1 << 4)\t \n#\tdefine RS5C_CTRL2_CTFG\t\t(1 << 2)\n#\tdefine RS5C_CTRL2_AAFG\t\t(1 << 1)\t \n#\tdefine RS5C_CTRL2_BAFG\t\t(1 << 0)\t \n\n\n \n#define RS5C_ADDR(R)\t\t(((R) << 4) | 0)\n\n\nenum rtc_type {\n\trtc_undef = 0,\n\trtc_r2025sd,\n\trtc_r2221tl,\n\trtc_rs5c372a,\n\trtc_rs5c372b,\n\trtc_rv5c386,\n\trtc_rv5c387a,\n};\n\nstatic const struct i2c_device_id rs5c372_id[] = {\n\t{ \"r2025sd\", rtc_r2025sd },\n\t{ \"r2221tl\", rtc_r2221tl },\n\t{ \"rs5c372a\", rtc_rs5c372a },\n\t{ \"rs5c372b\", rtc_rs5c372b },\n\t{ \"rv5c386\", rtc_rv5c386 },\n\t{ \"rv5c387a\", rtc_rv5c387a },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rs5c372_id);\n\nstatic const __maybe_unused struct of_device_id rs5c372_of_match[] = {\n\t{\n\t\t.compatible = \"ricoh,r2025sd\",\n\t\t.data = (void *)rtc_r2025sd\n\t},\n\t{\n\t\t.compatible = \"ricoh,r2221tl\",\n\t\t.data = (void *)rtc_r2221tl\n\t},\n\t{\n\t\t.compatible = \"ricoh,rs5c372a\",\n\t\t.data = (void *)rtc_rs5c372a\n\t},\n\t{\n\t\t.compatible = \"ricoh,rs5c372b\",\n\t\t.data = (void *)rtc_rs5c372b\n\t},\n\t{\n\t\t.compatible = \"ricoh,rv5c386\",\n\t\t.data = (void *)rtc_rv5c386\n\t},\n\t{\n\t\t.compatible = \"ricoh,rv5c387a\",\n\t\t.data = (void *)rtc_rv5c387a\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rs5c372_of_match);\n\n \nstruct rs5c372 {\n\tstruct i2c_client\t*client;\n\tstruct rtc_device\t*rtc;\n\tenum rtc_type\t\ttype;\n\tunsigned\t\ttime24:1;\n\tunsigned\t\thas_irq:1;\n\tunsigned\t\tsmbus:1;\n\tchar\t\t\tbuf[17];\n\tchar\t\t\t*regs;\n};\n\nstatic int rs5c_get_regs(struct rs5c372 *rs5c)\n{\n\tstruct i2c_client\t*client = rs5c->client;\n\tstruct i2c_msg\t\tmsgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(rs5c->buf),\n\t\t\t.buf = rs5c->buf\n\t\t},\n\t};\n\n\t \n\tif (rs5c->smbus) {\n\t\tint addr = RS5C_ADDR(RS5C372_REG_SECS);\n\t\tint size = sizeof(rs5c->buf) - 1;\n\n\t\tif (i2c_smbus_read_i2c_block_data(client, addr, size,\n\t\t\t\t\t\t  rs5c->buf + 1) != size) {\n\t\t\tdev_warn(&client->dev, \"can't read registers\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tif ((i2c_transfer(client->adapter, msgs, 1)) != 1) {\n\t\t\tdev_warn(&client->dev, \"can't read registers\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"%3ph (%02x) %3ph (%02x), %3ph, %3ph; %02x %02x\\n\",\n\t\trs5c->regs + 0, rs5c->regs[3],\n\t\trs5c->regs + 4, rs5c->regs[7],\n\t\trs5c->regs + 8, rs5c->regs + 11,\n\t\trs5c->regs[14], rs5c->regs[15]);\n\n\treturn 0;\n}\n\nstatic unsigned rs5c_reg2hr(struct rs5c372 *rs5c, unsigned reg)\n{\n\tunsigned\thour;\n\n\tif (rs5c->time24)\n\t\treturn bcd2bin(reg & 0x3f);\n\n\thour = bcd2bin(reg & 0x1f);\n\tif (hour == 12)\n\t\thour = 0;\n\tif (reg & 0x20)\n\t\thour += 12;\n\treturn hour;\n}\n\nstatic unsigned rs5c_hr2reg(struct rs5c372 *rs5c, unsigned hour)\n{\n\tif (rs5c->time24)\n\t\treturn bin2bcd(hour);\n\n\tif (hour > 12)\n\t\treturn 0x20 | bin2bcd(hour - 12);\n\tif (hour == 12)\n\t\treturn 0x20 | bin2bcd(12);\n\tif (hour == 0)\n\t\treturn bin2bcd(12);\n\treturn bin2bcd(hour);\n}\n\nstatic int rs5c372_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rs5c372\t*rs5c = i2c_get_clientdata(client);\n\tint\t\tstatus = rs5c_get_regs(rs5c);\n\tunsigned char ctrl2 = rs5c->regs[RS5C_REG_CTRL2];\n\n\tif (status < 0)\n\t\treturn status;\n\n\tswitch (rs5c->type) {\n\tcase rtc_r2025sd:\n\tcase rtc_r2221tl:\n\t\tif ((rs5c->type == rtc_r2025sd && !(ctrl2 & R2x2x_CTRL2_XSTP)) ||\n\t\t    (rs5c->type == rtc_r2221tl &&  (ctrl2 & R2x2x_CTRL2_XSTP))) {\n\t\t\tdev_warn(&client->dev, \"rtc oscillator interruption detected. Please reset the rtc clock.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (ctrl2 & RS5C_CTRL2_XSTP) {\n\t\t\tdev_warn(&client->dev, \"rtc oscillator interruption detected. Please reset the rtc clock.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttm->tm_sec = bcd2bin(rs5c->regs[RS5C372_REG_SECS] & 0x7f);\n\ttm->tm_min = bcd2bin(rs5c->regs[RS5C372_REG_MINS] & 0x7f);\n\ttm->tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C372_REG_HOURS]);\n\n\ttm->tm_wday = bcd2bin(rs5c->regs[RS5C372_REG_WDAY] & 0x07);\n\ttm->tm_mday = bcd2bin(rs5c->regs[RS5C372_REG_DAY] & 0x3f);\n\n\t \n\ttm->tm_mon = bcd2bin(rs5c->regs[RS5C372_REG_MONTH] & 0x1f) - 1;\n\n\t \n\ttm->tm_year = bcd2bin(rs5c->regs[RS5C372_REG_YEAR]) + 100;\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int rs5c372_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rs5c372\t*rs5c = i2c_get_clientdata(client);\n\tunsigned char\tbuf[7];\n\tunsigned char\tctrl2;\n\tint\t\taddr;\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\taddr   = RS5C_ADDR(RS5C372_REG_SECS);\n\tbuf[0] = bin2bcd(tm->tm_sec);\n\tbuf[1] = bin2bcd(tm->tm_min);\n\tbuf[2] = rs5c_hr2reg(rs5c, tm->tm_hour);\n\tbuf[3] = bin2bcd(tm->tm_wday);\n\tbuf[4] = bin2bcd(tm->tm_mday);\n\tbuf[5] = bin2bcd(tm->tm_mon + 1);\n\tbuf[6] = bin2bcd(tm->tm_year - 100);\n\n\tif (i2c_smbus_write_i2c_block_data(client, addr, sizeof(buf), buf) < 0) {\n\t\tdev_dbg(&client->dev, \"%s: write error in line %i\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\taddr = RS5C_ADDR(RS5C_REG_CTRL2);\n\tctrl2 = i2c_smbus_read_byte_data(client, addr);\n\n\t \n\tswitch (rs5c->type) {\n\tcase rtc_r2025sd:\n\tcase rtc_r2221tl:\n\t\tctrl2 &= ~(R2x2x_CTRL2_VDET | R2x2x_CTRL2_PON);\n\t\tif (rs5c->type == rtc_r2025sd)\n\t\t\tctrl2 |= R2x2x_CTRL2_XSTP;\n\t\telse\n\t\t\tctrl2 &= ~R2x2x_CTRL2_XSTP;\n\t\tbreak;\n\tdefault:\n\t\tctrl2 &= ~RS5C_CTRL2_XSTP;\n\t\tbreak;\n\t}\n\n\tif (i2c_smbus_write_byte_data(client, addr, ctrl2) < 0) {\n\t\tdev_dbg(&client->dev, \"%s: write error in line %i\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_RTC_INTF_PROC)\n#define\tNEED_TRIM\n#endif\n\n#if IS_ENABLED(CONFIG_RTC_INTF_SYSFS)\n#define\tNEED_TRIM\n#endif\n\n#ifdef\tNEED_TRIM\nstatic int rs5c372_get_trim(struct i2c_client *client, int *osc, int *trim)\n{\n\tstruct rs5c372 *rs5c372 = i2c_get_clientdata(client);\n\tu8 tmp = rs5c372->regs[RS5C372_REG_TRIM];\n\n\tif (osc) {\n\t\tif (rs5c372->type == rtc_rs5c372a || rs5c372->type == rtc_rs5c372b)\n\t\t\t*osc = (tmp & RS5C372_TRIM_XSL) ? 32000 : 32768;\n\t\telse\n\t\t\t*osc = 32768;\n\t}\n\n\tif (trim) {\n\t\tdev_dbg(&client->dev, \"%s: raw trim=%x\\n\", __func__, tmp);\n\t\ttmp &= RS5C372_TRIM_MASK;\n\t\tif (tmp & 0x3e) {\n\t\t\tint t = tmp & 0x3f;\n\n\t\t\tif (tmp & 0x40)\n\t\t\t\tt = (~t | (s8)0xc0) + 1;\n\t\t\telse\n\t\t\t\tt = t - 1;\n\n\t\t\ttmp = t * 2;\n\t\t} else\n\t\t\ttmp = 0;\n\t\t*trim = tmp;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int rs5c_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client\t*client = to_i2c_client(dev);\n\tstruct rs5c372\t\t*rs5c = i2c_get_clientdata(client);\n\tunsigned char\t\tbuf;\n\tint\t\t\tstatus, addr;\n\n\tbuf = rs5c->regs[RS5C_REG_CTRL1];\n\n\tif (!rs5c->has_irq)\n\t\treturn -EINVAL;\n\n\tstatus = rs5c_get_regs(rs5c);\n\tif (status < 0)\n\t\treturn status;\n\n\taddr = RS5C_ADDR(RS5C_REG_CTRL1);\n\tif (enabled)\n\t\tbuf |= RS5C_CTRL1_AALE;\n\telse\n\t\tbuf &= ~RS5C_CTRL1_AALE;\n\n\tif (i2c_smbus_write_byte_data(client, addr, buf) < 0) {\n\t\tdev_warn(dev, \"can't update alarm\\n\");\n\t\tstatus = -EIO;\n\t} else\n\t\trs5c->regs[RS5C_REG_CTRL1] = buf;\n\n\treturn status;\n}\n\n\n \n\nstatic int rs5c_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client\t*client = to_i2c_client(dev);\n\tstruct rs5c372\t\t*rs5c = i2c_get_clientdata(client);\n\tint\t\t\tstatus;\n\n\tstatus = rs5c_get_regs(rs5c);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tt->time.tm_sec = 0;\n\tt->time.tm_min = bcd2bin(rs5c->regs[RS5C_REG_ALARM_A_MIN] & 0x7f);\n\tt->time.tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C_REG_ALARM_A_HOURS]);\n\n\t \n\tt->enabled = !!(rs5c->regs[RS5C_REG_CTRL1] & RS5C_CTRL1_AALE);\n\tt->pending = !!(rs5c->regs[RS5C_REG_CTRL2] & RS5C_CTRL2_AAFG);\n\n\treturn 0;\n}\n\nstatic int rs5c_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client\t*client = to_i2c_client(dev);\n\tstruct rs5c372\t\t*rs5c = i2c_get_clientdata(client);\n\tint\t\t\tstatus, addr, i;\n\tunsigned char\t\tbuf[3];\n\n\t \n\tif (t->time.tm_mday != -1\n\t\t\t|| t->time.tm_mon != -1\n\t\t\t|| t->time.tm_year != -1)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tstatus = rs5c_get_regs(rs5c);\n\tif (status < 0)\n\t\treturn status;\n\tif (rs5c->regs[RS5C_REG_CTRL1] & RS5C_CTRL1_AALE) {\n\t\taddr = RS5C_ADDR(RS5C_REG_CTRL1);\n\t\tbuf[0] = rs5c->regs[RS5C_REG_CTRL1] & ~RS5C_CTRL1_AALE;\n\t\tif (i2c_smbus_write_byte_data(client, addr, buf[0]) < 0) {\n\t\t\tdev_dbg(dev, \"can't disable alarm\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\trs5c->regs[RS5C_REG_CTRL1] = buf[0];\n\t}\n\n\t \n\tbuf[0] = bin2bcd(t->time.tm_min);\n\tbuf[1] = rs5c_hr2reg(rs5c, t->time.tm_hour);\n\tbuf[2] = 0x7f;\t \n\n\tfor (i = 0; i < sizeof(buf); i++) {\n\t\taddr = RS5C_ADDR(RS5C_REG_ALARM_A_MIN + i);\n\t\tif (i2c_smbus_write_byte_data(client, addr, buf[i]) < 0) {\n\t\t\tdev_dbg(dev, \"can't set alarm time\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tif (t->enabled) {\n\t\taddr = RS5C_ADDR(RS5C_REG_CTRL1);\n\t\tbuf[0] = rs5c->regs[RS5C_REG_CTRL1] | RS5C_CTRL1_AALE;\n\t\tif (i2c_smbus_write_byte_data(client, addr, buf[0]) < 0)\n\t\t\tdev_warn(dev, \"can't enable alarm\\n\");\n\t\trs5c->regs[RS5C_REG_CTRL1] = buf[0];\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_RTC_INTF_PROC)\n\nstatic int rs5c372_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tint err, osc, trim;\n\n\terr = rs5c372_get_trim(to_i2c_client(dev), &osc, &trim);\n\tif (err == 0) {\n\t\tseq_printf(seq, \"crystal\\t\\t: %d.%03d KHz\\n\",\n\t\t\t\tosc / 1000, osc % 1000);\n\t\tseq_printf(seq, \"trim\\t\\t: %d\\n\", trim);\n\t}\n\n\treturn 0;\n}\n\n#else\n#define\trs5c372_rtc_proc\tNULL\n#endif\n\n#ifdef CONFIG_RTC_INTF_DEV\nstatic int rs5c372_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct rs5c372\t*rs5c = i2c_get_clientdata(to_i2c_client(dev));\n\tunsigned char\tctrl2;\n\tint\t\taddr;\n\tunsigned int\tflags;\n\n\tdev_dbg(dev, \"%s: cmd=%x\\n\", __func__, cmd);\n\n\taddr = RS5C_ADDR(RS5C_REG_CTRL2);\n\tctrl2 = i2c_smbus_read_byte_data(rs5c->client, addr);\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tflags = 0;\n\n\t\tswitch (rs5c->type) {\n\t\tcase rtc_r2025sd:\n\t\tcase rtc_r2221tl:\n\t\t\tif ((rs5c->type == rtc_r2025sd && !(ctrl2 & R2x2x_CTRL2_XSTP)) ||\n\t\t\t\t(rs5c->type == rtc_r2221tl &&  (ctrl2 & R2x2x_CTRL2_XSTP))) {\n\t\t\t\tflags |= RTC_VL_DATA_INVALID;\n\t\t\t}\n\t\t\tif (ctrl2 & R2x2x_CTRL2_VDET)\n\t\t\t\tflags |= RTC_VL_BACKUP_LOW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ctrl2 & RS5C_CTRL2_XSTP)\n\t\t\t\tflags |= RTC_VL_DATA_INVALID;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn put_user(flags, (unsigned int __user *)arg);\n\tcase RTC_VL_CLR:\n\t\t \n\t\tif (rs5c->type == rtc_r2025sd || rs5c->type == rtc_r2221tl) {\n\t\t\tctrl2 &= ~R2x2x_CTRL2_VDET;\n\t\t\tif (i2c_smbus_write_byte_data(rs5c->client, addr, ctrl2) < 0) {\n\t\t\t\tdev_dbg(&rs5c->client->dev, \"%s: write error in line %i\\n\",\n\t\t\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n#else\n#define rs5c372_ioctl\tNULL\n#endif\n\nstatic int rs5c372_read_offset(struct device *dev, long *offset)\n{\n\tstruct rs5c372 *rs5c = i2c_get_clientdata(to_i2c_client(dev));\n\tu8 val = rs5c->regs[RS5C372_REG_TRIM];\n\tlong ppb_per_step = 0;\n\tbool decr = val & RS5C372_TRIM_DECR;\n\n\tswitch (rs5c->type) {\n\tcase rtc_r2221tl:\n\t\tppb_per_step = val & R2221TL_TRIM_DEV ? 1017 : 3051;\n\t\tbreak;\n\tcase rtc_rs5c372a:\n\tcase rtc_rs5c372b:\n\t\tppb_per_step = val & RS5C372_TRIM_XSL ? 3125 : 3051;\n\t\tbreak;\n\tdefault:\n\t\tppb_per_step = 3051;\n\t\tbreak;\n\t}\n\n\t \n\tval &= 0x3F;\n\n\t \n\tif (!(val & 0x3E)) {\n\t\t*offset = 0;\n\t} else {\n\t\tif (decr)\n\t\t\t*offset = -(((~val) & 0x3F) + 1) * ppb_per_step;\n\t\telse\n\t\t\t*offset = (val - 1) * ppb_per_step;\n\t}\n\n\treturn 0;\n}\n\nstatic int rs5c372_set_offset(struct device *dev, long offset)\n{\n\tstruct rs5c372 *rs5c = i2c_get_clientdata(to_i2c_client(dev));\n\tint addr = RS5C_ADDR(RS5C372_REG_TRIM);\n\tu8 val = 0;\n\tu8 tmp = 0;\n\tlong ppb_per_step = 3051;\n\tlong steps = LONG_MIN;\n\n\tswitch (rs5c->type) {\n\tcase rtc_rs5c372a:\n\tcase rtc_rs5c372b:\n\t\ttmp = rs5c->regs[RS5C372_REG_TRIM];\n\t\tif (tmp & RS5C372_TRIM_XSL) {\n\t\t\tppb_per_step = 3125;\n\t\t\tval |= RS5C372_TRIM_XSL;\n\t\t}\n\t\tbreak;\n\tcase rtc_r2221tl:\n\t\t \n\t\tsteps = DIV_ROUND_CLOSEST(offset, 1017);\n\t\tif (steps >= -0x3E && steps <= 0x3E) {\n\t\t\tppb_per_step = 1017;\n\t\t\tval |= R2221TL_TRIM_DEV;\n\t\t} else {\n\t\t\t \n\t\t\tsteps = LONG_MIN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (steps == LONG_MIN) {\n\t\tsteps = DIV_ROUND_CLOSEST(offset, ppb_per_step);\n\t\tif (steps > 0x3E || steps < -0x3E)\n\t\t\treturn -ERANGE;\n\t}\n\n\tif (steps > 0) {\n\t\tval |= steps + 1;\n\t} else {\n\t\tval |= RS5C372_TRIM_DECR;\n\t\tval |= (~(-steps - 1)) & 0x3F;\n\t}\n\n\tif (!steps || !(val & 0x3E)) {\n\t\t \n\t\tif (rs5c->type == rtc_rs5c372a || rs5c->type == rtc_rs5c372b)\n\t\t\tval &= RS5C372_TRIM_XSL;\n\t\telse\n\t\t\tval = 0;\n\t}\n\n\tdev_dbg(&rs5c->client->dev, \"write 0x%x for offset %ld\\n\", val, offset);\n\n\tif (i2c_smbus_write_byte_data(rs5c->client, addr, val) < 0) {\n\t\tdev_err(&rs5c->client->dev, \"failed to write 0x%x to reg %d\\n\", val, addr);\n\t\treturn -EIO;\n\t}\n\n\trs5c->regs[RS5C372_REG_TRIM] = val;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops rs5c372_rtc_ops = {\n\t.proc\t\t= rs5c372_rtc_proc,\n\t.read_time\t= rs5c372_rtc_read_time,\n\t.set_time\t= rs5c372_rtc_set_time,\n\t.read_alarm\t= rs5c_read_alarm,\n\t.set_alarm\t= rs5c_set_alarm,\n\t.alarm_irq_enable = rs5c_rtc_alarm_irq_enable,\n\t.ioctl\t\t= rs5c372_ioctl,\n\t.read_offset    = rs5c372_read_offset,\n\t.set_offset     = rs5c372_set_offset,\n};\n\n#if IS_ENABLED(CONFIG_RTC_INTF_SYSFS)\n\nstatic ssize_t rs5c372_sysfs_show_trim(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint err, trim;\n\n\terr = rs5c372_get_trim(to_i2c_client(dev), NULL, &trim);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", trim);\n}\nstatic DEVICE_ATTR(trim, S_IRUGO, rs5c372_sysfs_show_trim, NULL);\n\nstatic ssize_t rs5c372_sysfs_show_osc(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint err, osc;\n\n\terr = rs5c372_get_trim(to_i2c_client(dev), &osc, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d.%03d KHz\\n\", osc / 1000, osc % 1000);\n}\nstatic DEVICE_ATTR(osc, S_IRUGO, rs5c372_sysfs_show_osc, NULL);\n\nstatic int rs5c_sysfs_register(struct device *dev)\n{\n\tint err;\n\n\terr = device_create_file(dev, &dev_attr_trim);\n\tif (err)\n\t\treturn err;\n\terr = device_create_file(dev, &dev_attr_osc);\n\tif (err)\n\t\tdevice_remove_file(dev, &dev_attr_trim);\n\n\treturn err;\n}\n\nstatic void rs5c_sysfs_unregister(struct device *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_trim);\n\tdevice_remove_file(dev, &dev_attr_osc);\n}\n\n#else\nstatic int rs5c_sysfs_register(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic void rs5c_sysfs_unregister(struct device *dev)\n{\n\t \n}\n#endif\t \n\nstatic struct i2c_driver rs5c372_driver;\n\nstatic int rs5c_oscillator_setup(struct rs5c372 *rs5c372)\n{\n\tunsigned char buf[2];\n\tint addr, i, ret = 0;\n\n\taddr   = RS5C_ADDR(RS5C_REG_CTRL1);\n\tbuf[0] = rs5c372->regs[RS5C_REG_CTRL1];\n\tbuf[1] = rs5c372->regs[RS5C_REG_CTRL2];\n\n\tswitch (rs5c372->type) {\n\tcase rtc_r2025sd:\n\t\tif (buf[1] & R2x2x_CTRL2_XSTP)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase rtc_r2221tl:\n\t\tif (!(buf[1] & R2x2x_CTRL2_XSTP))\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tif (!(buf[1] & RS5C_CTRL2_XSTP))\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (rs5c372->type) {\n\tcase rtc_rs5c372a:\n\tcase rtc_rs5c372b:\n\t\tbuf[1] |= RS5C372_CTRL2_24;\n\t\trs5c372->time24 = 1;\n\t\tbreak;\n\tcase rtc_r2025sd:\n\tcase rtc_r2221tl:\n\tcase rtc_rv5c386:\n\tcase rtc_rv5c387a:\n\t\tbuf[0] |= RV5C387_CTRL1_24;\n\t\trs5c372->time24 = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < sizeof(buf); i++) {\n\t\taddr = RS5C_ADDR(RS5C_REG_CTRL1 + i);\n\t\tret = i2c_smbus_write_byte_data(rs5c372->client, addr, buf[i]);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t}\n\n\trs5c372->regs[RS5C_REG_CTRL1] = buf[0];\n\trs5c372->regs[RS5C_REG_CTRL2] = buf[1];\n\n\treturn 0;\n}\n\nstatic int rs5c372_probe(struct i2c_client *client)\n{\n\tint err = 0;\n\tint smbus_mode = 0;\n\tstruct rs5c372 *rs5c372;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\t \n\t\tif (i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK))\n\t\t\tsmbus_mode = 1;\n\t\telse {\n\t\t\t \n\t\t\terr = -ENODEV;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trs5c372 = devm_kzalloc(&client->dev, sizeof(struct rs5c372),\n\t\t\t\tGFP_KERNEL);\n\tif (!rs5c372) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trs5c372->client = client;\n\ti2c_set_clientdata(client, rs5c372);\n\tif (client->dev.of_node) {\n\t\trs5c372->type = (uintptr_t)of_device_get_match_data(&client->dev);\n\t} else {\n\t\tconst struct i2c_device_id *id = i2c_match_id(rs5c372_id, client);\n\t\trs5c372->type = id->driver_data;\n\t}\n\n\t \n\trs5c372->regs = &rs5c372->buf[1];\n\trs5c372->smbus = smbus_mode;\n\n\terr = rs5c_get_regs(rs5c372);\n\tif (err < 0)\n\t\tgoto exit;\n\n\t \n\tswitch (rs5c372->type) {\n\tcase rtc_rs5c372a:\n\tcase rtc_rs5c372b:\n\t\t \n\t\tif (rs5c372->regs[RS5C_REG_CTRL2] & RS5C372_CTRL2_24)\n\t\t\trs5c372->time24 = 1;\n\t\tbreak;\n\tcase rtc_r2025sd:\n\tcase rtc_r2221tl:\n\tcase rtc_rv5c386:\n\tcase rtc_rv5c387a:\n\t\tif (rs5c372->regs[RS5C_REG_CTRL1] & RV5C387_CTRL1_24)\n\t\t\trs5c372->time24 = 1;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"unknown RTC type\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\terr = rs5c_oscillator_setup(rs5c372);\n\tif (unlikely(err < 0)) {\n\t\tdev_err(&client->dev, \"setup error\\n\");\n\t\tgoto exit;\n\t}\n\n\tdev_info(&client->dev, \"%s found, %s\\n\",\n\t\t\t({ char *s; switch (rs5c372->type) {\n\t\t\tcase rtc_r2025sd:\ts = \"r2025sd\"; break;\n\t\t\tcase rtc_r2221tl:\ts = \"r2221tl\"; break;\n\t\t\tcase rtc_rs5c372a:\ts = \"rs5c372a\"; break;\n\t\t\tcase rtc_rs5c372b:\ts = \"rs5c372b\"; break;\n\t\t\tcase rtc_rv5c386:\ts = \"rv5c386\"; break;\n\t\t\tcase rtc_rv5c387a:\ts = \"rv5c387a\"; break;\n\t\t\tdefault:\t\ts = \"chip\"; break;\n\t\t\t}; s;}),\n\t\t\trs5c372->time24 ? \"24hr\" : \"am/pm\"\n\t\t\t);\n\n\t \n\trs5c372->rtc = devm_rtc_device_register(&client->dev,\n\t\t\t\t\trs5c372_driver.driver.name,\n\t\t\t\t\t&rs5c372_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(rs5c372->rtc)) {\n\t\terr = PTR_ERR(rs5c372->rtc);\n\t\tgoto exit;\n\t}\n\n\terr = rs5c_sysfs_register(&client->dev);\n\tif (err)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\treturn err;\n}\n\nstatic void rs5c372_remove(struct i2c_client *client)\n{\n\trs5c_sysfs_unregister(&client->dev);\n}\n\nstatic struct i2c_driver rs5c372_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-rs5c372\",\n\t\t.of_match_table = of_match_ptr(rs5c372_of_match),\n\t},\n\t.probe\t\t= rs5c372_probe,\n\t.remove\t\t= rs5c372_remove,\n\t.id_table\t= rs5c372_id,\n};\n\nmodule_i2c_driver(rs5c372_driver);\n\nMODULE_AUTHOR(\n\t\t\"Pavel Mironchik <pmironchik@optifacio.net>, \"\n\t\t\"Alessandro Zummo <a.zummo@towertech.it>, \"\n\t\t\"Paul Mundt <lethal@linux-sh.org>\");\nMODULE_DESCRIPTION(\"Ricoh RS5C372 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}