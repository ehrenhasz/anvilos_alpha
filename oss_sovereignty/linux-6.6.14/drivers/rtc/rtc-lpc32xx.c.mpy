{
  "module_name": "rtc-lpc32xx.c",
  "hash_id": "ee46904d334d08373c686f49223994495bc67e6d34d52c58460a69d1f84d4e7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-lpc32xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n \n#define LPC32XX_RTC_UCOUNT\t\t0x00\n#define LPC32XX_RTC_DCOUNT\t\t0x04\n#define LPC32XX_RTC_MATCH0\t\t0x08\n#define LPC32XX_RTC_MATCH1\t\t0x0C\n#define LPC32XX_RTC_CTRL\t\t0x10\n#define LPC32XX_RTC_INTSTAT\t\t0x14\n#define LPC32XX_RTC_KEY\t\t\t0x18\n#define LPC32XX_RTC_SRAM\t\t0x80\n\n#define LPC32XX_RTC_CTRL_MATCH0\t\t(1 << 0)\n#define LPC32XX_RTC_CTRL_MATCH1\t\t(1 << 1)\n#define LPC32XX_RTC_CTRL_ONSW_MATCH0\t(1 << 2)\n#define LPC32XX_RTC_CTRL_ONSW_MATCH1\t(1 << 3)\n#define LPC32XX_RTC_CTRL_SW_RESET\t(1 << 4)\n#define LPC32XX_RTC_CTRL_CNTR_DIS\t(1 << 6)\n#define LPC32XX_RTC_CTRL_ONSW_FORCE_HI\t(1 << 7)\n\n#define LPC32XX_RTC_INTSTAT_MATCH0\t(1 << 0)\n#define LPC32XX_RTC_INTSTAT_MATCH1\t(1 << 1)\n#define LPC32XX_RTC_INTSTAT_ONSW\t(1 << 2)\n\n#define LPC32XX_RTC_KEY_ONSW_LOADVAL\t0xB5C13F27\n\n#define rtc_readl(dev, reg) \\\n\t__raw_readl((dev)->rtc_base + (reg))\n#define rtc_writel(dev, reg, val) \\\n\t__raw_writel((val), (dev)->rtc_base + (reg))\n\nstruct lpc32xx_rtc {\n\tvoid __iomem *rtc_base;\n\tint irq;\n\tunsigned char alarm_enabled;\n\tstruct rtc_device *rtc;\n\tspinlock_t lock;\n};\n\nstatic int lpc32xx_rtc_read_time(struct device *dev, struct rtc_time *time)\n{\n\tunsigned long elapsed_sec;\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\telapsed_sec = rtc_readl(rtc, LPC32XX_RTC_UCOUNT);\n\trtc_time64_to_tm(elapsed_sec, time);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_rtc_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\tu32 secs = rtc_tm_to_time64(time);\n\tu32 tmp;\n\n\tspin_lock_irq(&rtc->lock);\n\n\t \n\ttmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\n\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp | LPC32XX_RTC_CTRL_CNTR_DIS);\n\trtc_writel(rtc, LPC32XX_RTC_UCOUNT, secs);\n\trtc_writel(rtc, LPC32XX_RTC_DCOUNT, 0xFFFFFFFF - secs);\n\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp &= ~LPC32XX_RTC_CTRL_CNTR_DIS);\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_rtc_read_alarm(struct device *dev,\n\tstruct rtc_wkalrm *wkalrm)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(rtc_readl(rtc, LPC32XX_RTC_MATCH0), &wkalrm->time);\n\twkalrm->enabled = rtc->alarm_enabled;\n\twkalrm->pending = !!(rtc_readl(rtc, LPC32XX_RTC_INTSTAT) &\n\t\tLPC32XX_RTC_INTSTAT_MATCH0);\n\n\treturn rtc_valid_tm(&wkalrm->time);\n}\n\nstatic int lpc32xx_rtc_set_alarm(struct device *dev,\n\tstruct rtc_wkalrm *wkalrm)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long alarmsecs;\n\tu32 tmp;\n\n\talarmsecs = rtc_tm_to_time64(&wkalrm->time);\n\n\tspin_lock_irq(&rtc->lock);\n\n\t \n\ttmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\n\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp & ~LPC32XX_RTC_CTRL_MATCH0);\n\n\trtc_writel(rtc, LPC32XX_RTC_MATCH0, alarmsecs);\n\n\trtc->alarm_enabled = wkalrm->enabled;\n\tif (wkalrm->enabled) {\n\t\trtc_writel(rtc, LPC32XX_RTC_INTSTAT,\n\t\t\t   LPC32XX_RTC_INTSTAT_MATCH0);\n\t\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp |\n\t\t\t   LPC32XX_RTC_CTRL_MATCH0);\n\t}\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_rtc_alarm_irq_enable(struct device *dev,\n\tunsigned int enabled)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\tu32 tmp;\n\n\tspin_lock_irq(&rtc->lock);\n\ttmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\n\n\tif (enabled) {\n\t\trtc->alarm_enabled = 1;\n\t\ttmp |= LPC32XX_RTC_CTRL_MATCH0;\n\t} else {\n\t\trtc->alarm_enabled = 0;\n\t\ttmp &= ~LPC32XX_RTC_CTRL_MATCH0;\n\t}\n\n\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp);\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic irqreturn_t lpc32xx_rtc_alarm_interrupt(int irq, void *dev)\n{\n\tstruct lpc32xx_rtc *rtc = dev;\n\n\tspin_lock(&rtc->lock);\n\n\t \n\trtc_writel(rtc, LPC32XX_RTC_CTRL,\n\t\trtc_readl(rtc, LPC32XX_RTC_CTRL) &\n\t\t\t  ~LPC32XX_RTC_CTRL_MATCH0);\n\trtc->alarm_enabled = 0;\n\n\t \n\trtc_writel(rtc, LPC32XX_RTC_MATCH0, 0xFFFFFFFF);\n\trtc_writel(rtc, LPC32XX_RTC_INTSTAT, LPC32XX_RTC_INTSTAT_MATCH0);\n\n\tspin_unlock(&rtc->lock);\n\n\trtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops lpc32xx_rtc_ops = {\n\t.read_time\t\t= lpc32xx_rtc_read_time,\n\t.set_time\t\t= lpc32xx_rtc_set_time,\n\t.read_alarm\t\t= lpc32xx_rtc_read_alarm,\n\t.set_alarm\t\t= lpc32xx_rtc_set_alarm,\n\t.alarm_irq_enable\t= lpc32xx_rtc_alarm_irq_enable,\n};\n\nstatic int lpc32xx_rtc_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_rtc *rtc;\n\tint err;\n\tu32 tmp;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (unlikely(!rtc))\n\t\treturn -ENOMEM;\n\n\trtc->rtc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->rtc_base))\n\t\treturn PTR_ERR(rtc->rtc_base);\n\n\tspin_lock_init(&rtc->lock);\n\n\t \n\ttmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\n\tif (rtc_readl(rtc, LPC32XX_RTC_KEY) != LPC32XX_RTC_KEY_ONSW_LOADVAL) {\n\t\ttmp &= ~(LPC32XX_RTC_CTRL_SW_RESET |\n\t\t\tLPC32XX_RTC_CTRL_CNTR_DIS |\n\t\t\tLPC32XX_RTC_CTRL_MATCH0 |\n\t\t\tLPC32XX_RTC_CTRL_MATCH1 |\n\t\t\tLPC32XX_RTC_CTRL_ONSW_MATCH0 |\n\t\t\tLPC32XX_RTC_CTRL_ONSW_MATCH1 |\n\t\t\tLPC32XX_RTC_CTRL_ONSW_FORCE_HI);\n\t\trtc_writel(rtc, LPC32XX_RTC_CTRL, tmp);\n\n\t\t \n\t\trtc_writel(rtc, LPC32XX_RTC_MATCH0, 0xFFFFFFFF);\n\t\trtc_writel(rtc, LPC32XX_RTC_INTSTAT,\n\t\t\t   LPC32XX_RTC_INTSTAT_MATCH0 |\n\t\t\t   LPC32XX_RTC_INTSTAT_MATCH1 |\n\t\t\t   LPC32XX_RTC_INTSTAT_ONSW);\n\n\t\t \n\t\trtc_writel(rtc, LPC32XX_RTC_KEY,\n\t\t\t   LPC32XX_RTC_KEY_ONSW_LOADVAL);\n\t} else {\n\t\trtc_writel(rtc, LPC32XX_RTC_CTRL,\n\t\t\t   tmp & ~LPC32XX_RTC_CTRL_MATCH0);\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc))\n\t\treturn PTR_ERR(rtc->rtc);\n\n\trtc->rtc->ops = &lpc32xx_rtc_ops;\n\trtc->rtc->range_max = U32_MAX;\n\n\terr = devm_rtc_register_device(rtc->rtc);\n\tif (err)\n\t\treturn err;\n\n\t \n\trtc->irq = platform_get_irq(pdev, 0);\n\tif (rtc->irq < 0) {\n\t\tdev_warn(&pdev->dev, \"Can't get interrupt resource\\n\");\n\t} else {\n\t\tif (devm_request_irq(&pdev->dev, rtc->irq,\n\t\t\t\t     lpc32xx_rtc_alarm_interrupt,\n\t\t\t\t     0, pdev->name, rtc) < 0) {\n\t\t\tdev_warn(&pdev->dev, \"Can't request interrupt.\\n\");\n\t\t\trtc->irq = -1;\n\t\t} else {\n\t\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int lpc32xx_rtc_suspend(struct device *dev)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->irq >= 0) {\n\t\tif (device_may_wakeup(dev))\n\t\t\tenable_irq_wake(rtc->irq);\n\t\telse\n\t\t\tdisable_irq_wake(rtc->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc32xx_rtc_resume(struct device *dev)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->irq >= 0 && device_may_wakeup(dev))\n\t\tdisable_irq_wake(rtc->irq);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_rtc_freeze(struct device *dev)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&rtc->lock);\n\n\trtc_writel(rtc, LPC32XX_RTC_CTRL,\n\t\trtc_readl(rtc, LPC32XX_RTC_CTRL) &\n\t\t\t  ~LPC32XX_RTC_CTRL_MATCH0);\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_rtc_thaw(struct device *dev)\n{\n\tstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->alarm_enabled) {\n\t\tspin_lock_irq(&rtc->lock);\n\n\t\trtc_writel(rtc, LPC32XX_RTC_CTRL,\n\t\t\t   rtc_readl(rtc, LPC32XX_RTC_CTRL) |\n\t\t\t   LPC32XX_RTC_CTRL_MATCH0);\n\n\t\tspin_unlock_irq(&rtc->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lpc32xx_rtc_pm_ops = {\n\t.suspend = lpc32xx_rtc_suspend,\n\t.resume = lpc32xx_rtc_resume,\n\t.freeze = lpc32xx_rtc_freeze,\n\t.thaw = lpc32xx_rtc_thaw,\n\t.restore = lpc32xx_rtc_resume\n};\n\n#define LPC32XX_RTC_PM_OPS (&lpc32xx_rtc_pm_ops)\n#else\n#define LPC32XX_RTC_PM_OPS NULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lpc32xx_rtc_match[] = {\n\t{ .compatible = \"nxp,lpc3220-rtc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_rtc_match);\n#endif\n\nstatic struct platform_driver lpc32xx_rtc_driver = {\n\t.probe\t\t= lpc32xx_rtc_probe,\n\t.driver = {\n\t\t.name\t= \"rtc-lpc32xx\",\n\t\t.pm\t= LPC32XX_RTC_PM_OPS,\n\t\t.of_match_table = of_match_ptr(lpc32xx_rtc_match),\n\t},\n};\n\nmodule_platform_driver(lpc32xx_rtc_driver);\n\nMODULE_AUTHOR(\"Kevin Wells <wellsk40@gmail.com\");\nMODULE_DESCRIPTION(\"RTC driver for the LPC32xx SoC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-lpc32xx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}