{
  "module_name": "rtc-pxa.c",
  "hash_id": "7f8271f5b7630533abbf548fd9e0145bf61b70d85952acf29335ec92aa8fb10b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pxa.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include \"rtc-sa1100.h\"\n\n#define RTC_DEF_DIVIDER\t\t(32768 - 1)\n#define RTC_DEF_TRIM\t\t0\n#define MAXFREQ_PERIODIC\t1000\n\n \n#define RTSR_PICE\t(1 << 15)\t \n#define RTSR_PIALE\t(1 << 14)\t \n#define RTSR_PIAL\t(1 << 13)\t \n#define RTSR_SWALE2\t(1 << 11)\t \n#define RTSR_SWAL2\t(1 << 10)\t \n#define RTSR_SWALE1\t(1 << 9)\t \n#define RTSR_SWAL1\t(1 << 8)\t \n#define RTSR_RDALE2\t(1 << 7)\t \n#define RTSR_RDAL2\t(1 << 6)\t \n#define RTSR_RDALE1\t(1 << 5)\t \n#define RTSR_RDAL1\t(1 << 4)\t \n#define RTSR_HZE\t(1 << 3)\t \n#define RTSR_ALE\t(1 << 2)\t \n#define RTSR_HZ\t\t(1 << 1)\t \n#define RTSR_AL\t\t(1 << 0)\t \n#define RTSR_TRIG_MASK\t(RTSR_AL | RTSR_HZ | RTSR_RDAL1 | RTSR_RDAL2\\\n\t\t\t | RTSR_SWAL1 | RTSR_SWAL2)\n#define RYxR_YEAR_S\t9\n#define RYxR_YEAR_MASK\t(0xfff << RYxR_YEAR_S)\n#define RYxR_MONTH_S\t5\n#define RYxR_MONTH_MASK\t(0xf << RYxR_MONTH_S)\n#define RYxR_DAY_MASK\t0x1f\n#define RDxR_WOM_S     20\n#define RDxR_WOM_MASK  (0x7 << RDxR_WOM_S)\n#define RDxR_DOW_S     17\n#define RDxR_DOW_MASK  (0x7 << RDxR_DOW_S)\n#define RDxR_HOUR_S\t12\n#define RDxR_HOUR_MASK\t(0x1f << RDxR_HOUR_S)\n#define RDxR_MIN_S\t6\n#define RDxR_MIN_MASK\t(0x3f << RDxR_MIN_S)\n#define RDxR_SEC_MASK\t0x3f\n\n#define RTSR\t\t0x08\n#define RTTR\t\t0x0c\n#define RDCR\t\t0x10\n#define RYCR\t\t0x14\n#define RDAR1\t\t0x18\n#define RYAR1\t\t0x1c\n#define RTCPICR\t\t0x34\n#define PIAR\t\t0x38\n\n#define rtc_readl(pxa_rtc, reg)\t\\\n\t__raw_readl((pxa_rtc)->base + (reg))\n#define rtc_writel(pxa_rtc, reg, value)\t\\\n\t__raw_writel((value), (pxa_rtc)->base + (reg))\n\nstruct pxa_rtc {\n\tstruct sa1100_rtc sa1100_rtc;\n\tstruct resource\t*ress;\n\tvoid __iomem\t\t*base;\n\tstruct rtc_device\t*rtc;\n\tspinlock_t\t\tlock;\t\t \n};\n\n\nstatic u32 ryxr_calc(struct rtc_time *tm)\n{\n\treturn ((tm->tm_year + 1900) << RYxR_YEAR_S)\n\t\t| ((tm->tm_mon + 1) << RYxR_MONTH_S)\n\t\t| tm->tm_mday;\n}\n\nstatic u32 rdxr_calc(struct rtc_time *tm)\n{\n\treturn ((((tm->tm_mday + 6) / 7) << RDxR_WOM_S) & RDxR_WOM_MASK)\n\t\t| (((tm->tm_wday + 1) << RDxR_DOW_S) & RDxR_DOW_MASK)\n\t\t| (tm->tm_hour << RDxR_HOUR_S)\n\t\t| (tm->tm_min << RDxR_MIN_S)\n\t\t| tm->tm_sec;\n}\n\nstatic void tm_calc(u32 rycr, u32 rdcr, struct rtc_time *tm)\n{\n\ttm->tm_year = ((rycr & RYxR_YEAR_MASK) >> RYxR_YEAR_S) - 1900;\n\ttm->tm_mon = (((rycr & RYxR_MONTH_MASK) >> RYxR_MONTH_S)) - 1;\n\ttm->tm_mday = (rycr & RYxR_DAY_MASK);\n\ttm->tm_wday = ((rycr & RDxR_DOW_MASK) >> RDxR_DOW_S) - 1;\n\ttm->tm_hour = (rdcr & RDxR_HOUR_MASK) >> RDxR_HOUR_S;\n\ttm->tm_min = (rdcr & RDxR_MIN_MASK) >> RDxR_MIN_S;\n\ttm->tm_sec = rdcr & RDxR_SEC_MASK;\n}\n\nstatic void rtsr_clear_bits(struct pxa_rtc *pxa_rtc, u32 mask)\n{\n\tu32 rtsr;\n\n\trtsr = rtc_readl(pxa_rtc, RTSR);\n\trtsr &= ~RTSR_TRIG_MASK;\n\trtsr &= ~mask;\n\trtc_writel(pxa_rtc, RTSR, rtsr);\n}\n\nstatic void rtsr_set_bits(struct pxa_rtc *pxa_rtc, u32 mask)\n{\n\tu32 rtsr;\n\n\trtsr = rtc_readl(pxa_rtc, RTSR);\n\trtsr &= ~RTSR_TRIG_MASK;\n\trtsr |= mask;\n\trtc_writel(pxa_rtc, RTSR, rtsr);\n}\n\nstatic irqreturn_t pxa_rtc_irq(int irq, void *dev_id)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev_id);\n\tu32 rtsr;\n\tunsigned long events = 0;\n\n\tspin_lock(&pxa_rtc->lock);\n\n\t \n\trtsr = rtc_readl(pxa_rtc, RTSR);\n\trtc_writel(pxa_rtc, RTSR, rtsr);\n\n\t \n\trtsr_clear_bits(pxa_rtc, RTSR_RDALE1 | RTSR_PIALE | RTSR_HZE);\n\n\t \n\tif (rtsr & RTSR_RDAL1)\n\t\trtsr &= ~RTSR_RDALE1;\n\n\t \n\tif (rtsr & RTSR_RDAL1)\n\t\tevents |= RTC_AF | RTC_IRQF;\n\tif (rtsr & RTSR_HZ)\n\t\tevents |= RTC_UF | RTC_IRQF;\n\tif (rtsr & RTSR_PIAL)\n\t\tevents |= RTC_PF | RTC_IRQF;\n\n\trtc_update_irq(pxa_rtc->rtc, 1, events);\n\n\t \n\trtc_writel(pxa_rtc, RTSR, rtsr & ~RTSR_TRIG_MASK);\n\n\tspin_unlock(&pxa_rtc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pxa_rtc_open(struct device *dev)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = request_irq(pxa_rtc->sa1100_rtc.irq_1hz, pxa_rtc_irq, 0,\n\t\t\t  \"rtc 1Hz\", dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't get irq %i, err %d\\n\",\n\t\t\tpxa_rtc->sa1100_rtc.irq_1hz, ret);\n\t\tgoto err_irq_1Hz;\n\t}\n\tret = request_irq(pxa_rtc->sa1100_rtc.irq_alarm, pxa_rtc_irq, 0,\n\t\t\t  \"rtc Alrm\", dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't get irq %i, err %d\\n\",\n\t\t\tpxa_rtc->sa1100_rtc.irq_alarm, ret);\n\t\tgoto err_irq_Alrm;\n\t}\n\n\treturn 0;\n\nerr_irq_Alrm:\n\tfree_irq(pxa_rtc->sa1100_rtc.irq_1hz, dev);\nerr_irq_1Hz:\n\treturn ret;\n}\n\nstatic void pxa_rtc_release(struct device *dev)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&pxa_rtc->lock);\n\trtsr_clear_bits(pxa_rtc, RTSR_PIALE | RTSR_RDALE1 | RTSR_HZE);\n\tspin_unlock_irq(&pxa_rtc->lock);\n\n\tfree_irq(pxa_rtc->sa1100_rtc.irq_1hz, dev);\n\tfree_irq(pxa_rtc->sa1100_rtc.irq_alarm, dev);\n}\n\nstatic int pxa_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\tspin_lock_irq(&pxa_rtc->lock);\n\n\tif (enabled)\n\t\trtsr_set_bits(pxa_rtc, RTSR_RDALE1);\n\telse\n\t\trtsr_clear_bits(pxa_rtc, RTSR_RDALE1);\n\n\tspin_unlock_irq(&pxa_rtc->lock);\n\treturn 0;\n}\n\nstatic int pxa_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\tu32 rycr, rdcr;\n\n\trycr = rtc_readl(pxa_rtc, RYCR);\n\trdcr = rtc_readl(pxa_rtc, RDCR);\n\n\ttm_calc(rycr, rdcr, tm);\n\treturn 0;\n}\n\nstatic int pxa_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\trtc_writel(pxa_rtc, RYCR, ryxr_calc(tm));\n\trtc_writel(pxa_rtc, RDCR, rdxr_calc(tm));\n\n\treturn 0;\n}\n\nstatic int pxa_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\tu32 rtsr, ryar, rdar;\n\n\tryar = rtc_readl(pxa_rtc, RYAR1);\n\trdar = rtc_readl(pxa_rtc, RDAR1);\n\ttm_calc(ryar, rdar, &alrm->time);\n\n\trtsr = rtc_readl(pxa_rtc, RTSR);\n\talrm->enabled = (rtsr & RTSR_RDALE1) ? 1 : 0;\n\talrm->pending = (rtsr & RTSR_RDAL1) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int pxa_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\tu32 rtsr;\n\n\tspin_lock_irq(&pxa_rtc->lock);\n\n\trtc_writel(pxa_rtc, RYAR1, ryxr_calc(&alrm->time));\n\trtc_writel(pxa_rtc, RDAR1, rdxr_calc(&alrm->time));\n\n\trtsr = rtc_readl(pxa_rtc, RTSR);\n\tif (alrm->enabled)\n\t\trtsr |= RTSR_RDALE1;\n\telse\n\t\trtsr &= ~RTSR_RDALE1;\n\trtc_writel(pxa_rtc, RTSR, rtsr);\n\n\tspin_unlock_irq(&pxa_rtc->lock);\n\n\treturn 0;\n}\n\nstatic int pxa_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\tseq_printf(seq, \"trim/divider\\t: 0x%08x\\n\", rtc_readl(pxa_rtc, RTTR));\n\tseq_printf(seq, \"update_IRQ\\t: %s\\n\",\n\t\t   (rtc_readl(pxa_rtc, RTSR) & RTSR_HZE) ? \"yes\" : \"no\");\n\tseq_printf(seq, \"periodic_IRQ\\t: %s\\n\",\n\t\t   (rtc_readl(pxa_rtc, RTSR) & RTSR_PIALE) ? \"yes\" : \"no\");\n\tseq_printf(seq, \"periodic_freq\\t: %u\\n\", rtc_readl(pxa_rtc, PIAR));\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pxa_rtc_ops = {\n\t.read_time = pxa_rtc_read_time,\n\t.set_time = pxa_rtc_set_time,\n\t.read_alarm = pxa_rtc_read_alarm,\n\t.set_alarm = pxa_rtc_set_alarm,\n\t.alarm_irq_enable = pxa_alarm_irq_enable,\n\t.proc = pxa_rtc_proc,\n};\n\nstatic int __init pxa_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pxa_rtc *pxa_rtc;\n\tstruct sa1100_rtc *sa1100_rtc;\n\tint ret;\n\n\tpxa_rtc = devm_kzalloc(dev, sizeof(*pxa_rtc), GFP_KERNEL);\n\tif (!pxa_rtc)\n\t\treturn -ENOMEM;\n\tsa1100_rtc = &pxa_rtc->sa1100_rtc;\n\n\tspin_lock_init(&pxa_rtc->lock);\n\tplatform_set_drvdata(pdev, pxa_rtc);\n\n\tpxa_rtc->ress = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!pxa_rtc->ress) {\n\t\tdev_err(dev, \"No I/O memory resource defined\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tsa1100_rtc->irq_1hz = platform_get_irq(pdev, 0);\n\tif (sa1100_rtc->irq_1hz < 0)\n\t\treturn -ENXIO;\n\tsa1100_rtc->irq_alarm = platform_get_irq(pdev, 1);\n\tif (sa1100_rtc->irq_alarm < 0)\n\t\treturn -ENXIO;\n\n\tsa1100_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(sa1100_rtc->rtc))\n\t\treturn PTR_ERR(sa1100_rtc->rtc);\n\n\tpxa_rtc->base = devm_ioremap(dev, pxa_rtc->ress->start,\n\t\t\t\tresource_size(pxa_rtc->ress));\n\tif (!pxa_rtc->base) {\n\t\tdev_err(dev, \"Unable to map pxa RTC I/O memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpxa_rtc_open(dev);\n\n\tsa1100_rtc->rcnr = pxa_rtc->base + 0x0;\n\tsa1100_rtc->rtsr = pxa_rtc->base + 0x8;\n\tsa1100_rtc->rtar = pxa_rtc->base + 0x4;\n\tsa1100_rtc->rttr = pxa_rtc->base + 0xc;\n\tret = sa1100_rtc_init(pdev, sa1100_rtc);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to init SA1100 RTC sub-device\\n\");\n\t\treturn ret;\n\t}\n\n\trtsr_clear_bits(pxa_rtc, RTSR_PIALE | RTSR_RDALE1 | RTSR_HZE);\n\n\tpxa_rtc->rtc = devm_rtc_device_register(&pdev->dev, \"pxa-rtc\",\n\t\t\t\t\t\t&pxa_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(pxa_rtc->rtc)) {\n\t\tret = PTR_ERR(pxa_rtc->rtc);\n\t\tdev_err(dev, \"Failed to register RTC device -> %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(dev, 1);\n\n\treturn 0;\n}\n\nstatic int __exit pxa_rtc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tpxa_rtc_release(dev);\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_rtc_dt_ids[] = {\n\t{ .compatible = \"marvell,pxa-rtc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pxa_rtc_dt_ids);\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pxa_rtc_suspend(struct device *dev)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(pxa_rtc->sa1100_rtc.irq_alarm);\n\treturn 0;\n}\n\nstatic int pxa_rtc_resume(struct device *dev)\n{\n\tstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(pxa_rtc->sa1100_rtc.irq_alarm);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pxa_rtc_pm_ops, pxa_rtc_suspend, pxa_rtc_resume);\n\nstatic struct platform_driver pxa_rtc_driver = {\n\t.remove\t\t= __exit_p(pxa_rtc_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"pxa-rtc\",\n\t\t.of_match_table = of_match_ptr(pxa_rtc_dt_ids),\n\t\t.pm\t= &pxa_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver_probe(pxa_rtc_driver, pxa_rtc_probe);\n\nMODULE_AUTHOR(\"Robert Jarzmik <robert.jarzmik@free.fr>\");\nMODULE_DESCRIPTION(\"PXA27x/PXA3xx Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}