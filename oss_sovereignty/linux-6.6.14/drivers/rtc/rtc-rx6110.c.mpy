{
  "module_name": "rtc-rx6110.c",
  "hash_id": "70e4a50740ef4dc34bb787eddc0007b3d4180555663e17c4e1ce24e46a3b871f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rx6110.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/i2c.h>\n\n \n#define RX6110_REG_SEC\t\t0x10\n#define RX6110_REG_MIN\t\t0x11\n#define RX6110_REG_HOUR\t\t0x12\n#define RX6110_REG_WDAY\t\t0x13\n#define RX6110_REG_MDAY\t\t0x14\n#define RX6110_REG_MONTH\t0x15\n#define RX6110_REG_YEAR\t\t0x16\n#define RX6110_REG_RES1\t\t0x17\n#define RX6110_REG_ALMIN\t0x18\n#define RX6110_REG_ALHOUR\t0x19\n#define RX6110_REG_ALWDAY\t0x1A\n#define RX6110_REG_TCOUNT0\t0x1B\n#define RX6110_REG_TCOUNT1\t0x1C\n#define RX6110_REG_EXT\t\t0x1D\n#define RX6110_REG_FLAG\t\t0x1E\n#define RX6110_REG_CTRL\t\t0x1F\n#define RX6110_REG_USER0\t0x20\n#define RX6110_REG_USER1\t0x21\n#define RX6110_REG_USER2\t0x22\n#define RX6110_REG_USER3\t0x23\n#define RX6110_REG_USER4\t0x24\n#define RX6110_REG_USER5\t0x25\n#define RX6110_REG_USER6\t0x26\n#define RX6110_REG_USER7\t0x27\n#define RX6110_REG_USER8\t0x28\n#define RX6110_REG_USER9\t0x29\n#define RX6110_REG_USERA\t0x2A\n#define RX6110_REG_USERB\t0x2B\n#define RX6110_REG_USERC\t0x2C\n#define RX6110_REG_USERD\t0x2D\n#define RX6110_REG_USERE\t0x2E\n#define RX6110_REG_USERF\t0x2F\n#define RX6110_REG_RES2\t\t0x30\n#define RX6110_REG_RES3\t\t0x31\n#define RX6110_REG_IRQ\t\t0x32\n\n#define RX6110_BIT_ALARM_EN\t\tBIT(7)\n\n \n#define RX6110_BIT_EXT_TSEL0\t\tBIT(0)\n#define RX6110_BIT_EXT_TSEL1\t\tBIT(1)\n#define RX6110_BIT_EXT_TSEL2\t\tBIT(2)\n#define RX6110_BIT_EXT_WADA\t\tBIT(3)\n#define RX6110_BIT_EXT_TE\t\tBIT(4)\n#define RX6110_BIT_EXT_USEL\t\tBIT(5)\n#define RX6110_BIT_EXT_FSEL0\t\tBIT(6)\n#define RX6110_BIT_EXT_FSEL1\t\tBIT(7)\n\n \n#define RX6110_BIT_FLAG_VLF\t\tBIT(1)\n#define RX6110_BIT_FLAG_AF\t\tBIT(3)\n#define RX6110_BIT_FLAG_TF\t\tBIT(4)\n#define RX6110_BIT_FLAG_UF\t\tBIT(5)\n\n \n#define RX6110_BIT_CTRL_TBKE\t\tBIT(0)\n#define RX6110_BIT_CTRL_TBKON\t\tBIT(1)\n#define RX6110_BIT_CTRL_TSTP\t\tBIT(2)\n#define RX6110_BIT_CTRL_AIE\t\tBIT(3)\n#define RX6110_BIT_CTRL_TIE\t\tBIT(4)\n#define RX6110_BIT_CTRL_UIE\t\tBIT(5)\n#define RX6110_BIT_CTRL_STOP\t\tBIT(6)\n#define RX6110_BIT_CTRL_TEST\t\tBIT(7)\n\nenum {\n\tRTC_SEC = 0,\n\tRTC_MIN,\n\tRTC_HOUR,\n\tRTC_WDAY,\n\tRTC_MDAY,\n\tRTC_MONTH,\n\tRTC_YEAR,\n\tRTC_NR_TIME\n};\n\n#define RX6110_DRIVER_NAME\t\t\"rx6110\"\n\nstruct rx6110_data {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n};\n\n \nstatic int rx6110_rtc_tm_to_data(struct rtc_time *tm, u8 *data)\n{\n\tpr_debug(\"%s: date %ptRr\\n\", __func__, tm);\n\n\t \n\tif (tm->tm_year < 100 || tm->tm_year >= 200)\n\t\treturn -EINVAL;\n\n\tdata[RTC_SEC] = bin2bcd(tm->tm_sec);\n\tdata[RTC_MIN] = bin2bcd(tm->tm_min);\n\tdata[RTC_HOUR] = bin2bcd(tm->tm_hour);\n\tdata[RTC_WDAY] = BIT(bin2bcd(tm->tm_wday));\n\tdata[RTC_MDAY] = bin2bcd(tm->tm_mday);\n\tdata[RTC_MONTH] = bin2bcd(tm->tm_mon + 1);\n\tdata[RTC_YEAR] = bin2bcd(tm->tm_year % 100);\n\n\treturn 0;\n}\n\n \nstatic int rx6110_data_to_rtc_tm(u8 *data, struct rtc_time *tm)\n{\n\ttm->tm_sec = bcd2bin(data[RTC_SEC] & 0x7f);\n\ttm->tm_min = bcd2bin(data[RTC_MIN] & 0x7f);\n\t \n\ttm->tm_hour = bcd2bin(data[RTC_HOUR] & 0x3f);\n\ttm->tm_wday = ffs(data[RTC_WDAY] & 0x7f);\n\ttm->tm_mday = bcd2bin(data[RTC_MDAY] & 0x3f);\n\ttm->tm_mon = bcd2bin(data[RTC_MONTH] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(data[RTC_YEAR]) + 100;\n\n\tpr_debug(\"%s: date %ptRr\\n\", __func__, tm);\n\n\t \n\tif (tm->tm_year < 100 || tm->tm_year >= 200)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int rx6110_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rx6110_data *rx6110 = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tint ret;\n\n\tret = rx6110_rtc_tm_to_data(tm, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(rx6110->regmap, RX6110_REG_CTRL,\n\t\t\t\t RX6110_BIT_CTRL_STOP, RX6110_BIT_CTRL_STOP);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(rx6110->regmap, RX6110_REG_SEC, data,\n\t\t\t\tRTC_NR_TIME);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(rx6110->regmap, RX6110_REG_FLAG,\n\t\t\t\t RX6110_BIT_FLAG_VLF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(rx6110->regmap, RX6110_REG_CTRL,\n\t\t\t\t RX6110_BIT_CTRL_STOP, 0);\n\n\treturn ret;\n}\n\n \nstatic int rx6110_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rx6110_data *rx6110 = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tint flags;\n\tint ret;\n\n\tret = regmap_read(rx6110->regmap, RX6110_REG_FLAG, &flags);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & RX6110_BIT_FLAG_VLF)) {\n\t\tdev_warn(dev, \"Voltage low, data is invalid.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_bulk_read(rx6110->regmap, RX6110_REG_SEC, data,\n\t\t\t       RTC_NR_TIME);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rx6110_data_to_rtc_tm(data, tm);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"%s: date %ptRr\\n\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence rx6110_default_regs[] = {\n\t{ RX6110_REG_RES1,   0xB8 },\n\t{ RX6110_REG_RES2,   0x00 },\n\t{ RX6110_REG_RES3,   0x10 },\n\t{ RX6110_REG_IRQ,    0x00 },\n\t{ RX6110_REG_ALMIN,  0x00 },\n\t{ RX6110_REG_ALHOUR, 0x00 },\n\t{ RX6110_REG_ALWDAY, 0x00 },\n};\n\n \nstatic int rx6110_init(struct rx6110_data *rx6110)\n{\n\tstruct rtc_device *rtc = rx6110->rtc;\n\tint flags;\n\tint ret;\n\n\tret = regmap_update_bits(rx6110->regmap, RX6110_REG_EXT,\n\t\t\t\t RX6110_BIT_EXT_TE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_register_patch(rx6110->regmap, rx6110_default_regs,\n\t\t\t\t    ARRAY_SIZE(rx6110_default_regs));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(rx6110->regmap, RX6110_REG_FLAG, &flags);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((flags & RX6110_BIT_FLAG_VLF))\n\t\tdev_warn(&rtc->dev, \"Voltage low, data loss detected.\\n\");\n\n\t \n\tif (flags & RX6110_BIT_FLAG_AF)\n\t\tdev_warn(&rtc->dev, \"An alarm may have been missed.\\n\");\n\n\t \n\tif (flags & RX6110_BIT_FLAG_TF)\n\t\tdev_warn(&rtc->dev, \"Periodic timer was detected\\n\");\n\n\t \n\tif (flags & RX6110_BIT_FLAG_UF)\n\t\tdev_warn(&rtc->dev, \"Update timer was detected\\n\");\n\n\t \n\tret = regmap_update_bits(rx6110->regmap, RX6110_REG_FLAG,\n\t\t\t\t RX6110_BIT_FLAG_AF |\n\t\t\t\t RX6110_BIT_FLAG_UF |\n\t\t\t\t RX6110_BIT_FLAG_TF,\n\t\t\t\t 0);\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops rx6110_rtc_ops = {\n\t.read_time = rx6110_get_time,\n\t.set_time = rx6110_set_time,\n};\n\nstatic int rx6110_probe(struct rx6110_data *rx6110, struct device *dev)\n{\n\tint err;\n\n\trx6110->rtc = devm_rtc_device_register(dev,\n\t\t\t\t\t       RX6110_DRIVER_NAME,\n\t\t\t\t\t       &rx6110_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(rx6110->rtc))\n\t\treturn PTR_ERR(rx6110->rtc);\n\n\terr = rx6110_init(rx6110);\n\tif (err)\n\t\treturn err;\n\n\trx6110->rtc->max_user_freq = 1;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SPI_MASTER)\nstatic struct regmap_config regmap_spi_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RX6110_REG_IRQ,\n\t.read_flag_mask = 0x80,\n};\n\n \nstatic int rx6110_spi_probe(struct spi_device *spi)\n{\n\tstruct rx6110_data *rx6110;\n\n\tif ((spi->bits_per_word && spi->bits_per_word != 8) ||\n\t    (spi->max_speed_hz > 2000000) ||\n\t    (spi->mode != (SPI_CS_HIGH | SPI_CPOL | SPI_CPHA))) {\n\t\tdev_warn(&spi->dev, \"SPI settings: bits_per_word: %d, max_speed_hz: %d, mode: %xh\\n\",\n\t\t\t spi->bits_per_word, spi->max_speed_hz, spi->mode);\n\t\tdev_warn(&spi->dev, \"driving device in an unsupported mode\");\n\t}\n\n\trx6110 = devm_kzalloc(&spi->dev, sizeof(*rx6110), GFP_KERNEL);\n\tif (!rx6110)\n\t\treturn -ENOMEM;\n\n\trx6110->regmap = devm_regmap_init_spi(spi, &regmap_spi_config);\n\tif (IS_ERR(rx6110->regmap)) {\n\t\tdev_err(&spi->dev, \"regmap init failed for rtc rx6110\\n\");\n\t\treturn PTR_ERR(rx6110->regmap);\n\t}\n\n\tspi_set_drvdata(spi, rx6110);\n\n\treturn rx6110_probe(rx6110, &spi->dev);\n}\n\nstatic const struct spi_device_id rx6110_spi_id[] = {\n\t{ \"rx6110\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, rx6110_spi_id);\n\nstatic const __maybe_unused struct of_device_id rx6110_spi_of_match[] = {\n\t{ .compatible = \"epson,rx6110\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rx6110_spi_of_match);\n\nstatic struct spi_driver rx6110_spi_driver = {\n\t.driver = {\n\t\t.name = RX6110_DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(rx6110_spi_of_match),\n\t},\n\t.probe\t\t= rx6110_spi_probe,\n\t.id_table\t= rx6110_spi_id,\n};\n\nstatic int rx6110_spi_register(void)\n{\n\treturn spi_register_driver(&rx6110_spi_driver);\n}\n\nstatic void rx6110_spi_unregister(void)\n{\n\tspi_unregister_driver(&rx6110_spi_driver);\n}\n#else\nstatic int rx6110_spi_register(void)\n{\n\treturn 0;\n}\n\nstatic void rx6110_spi_unregister(void)\n{\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_I2C)\nstatic struct regmap_config regmap_i2c_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RX6110_REG_IRQ,\n\t.read_flag_mask = 0x80,\n};\n\nstatic int rx6110_i2c_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct rx6110_data *rx6110;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t| I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"doesn't support required functionality\\n\");\n\t\treturn -EIO;\n\t}\n\n\trx6110 = devm_kzalloc(&client->dev, sizeof(*rx6110), GFP_KERNEL);\n\tif (!rx6110)\n\t\treturn -ENOMEM;\n\n\trx6110->regmap = devm_regmap_init_i2c(client, &regmap_i2c_config);\n\tif (IS_ERR(rx6110->regmap)) {\n\t\tdev_err(&client->dev, \"regmap init failed for rtc rx6110\\n\");\n\t\treturn PTR_ERR(rx6110->regmap);\n\t}\n\n\ti2c_set_clientdata(client, rx6110);\n\n\treturn rx6110_probe(rx6110, &client->dev);\n}\n\nstatic const struct acpi_device_id rx6110_i2c_acpi_match[] = {\n\t{ \"SECC6110\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rx6110_i2c_acpi_match);\n\nstatic const struct i2c_device_id rx6110_i2c_id[] = {\n\t{ \"rx6110\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rx6110_i2c_id);\n\nstatic struct i2c_driver rx6110_i2c_driver = {\n\t.driver = {\n\t\t.name = RX6110_DRIVER_NAME,\n\t\t.acpi_match_table = rx6110_i2c_acpi_match,\n\t},\n\t.probe\t\t= rx6110_i2c_probe,\n\t.id_table\t= rx6110_i2c_id,\n};\n\nstatic int rx6110_i2c_register(void)\n{\n\treturn i2c_add_driver(&rx6110_i2c_driver);\n}\n\nstatic void rx6110_i2c_unregister(void)\n{\n\ti2c_del_driver(&rx6110_i2c_driver);\n}\n#else\nstatic int rx6110_i2c_register(void)\n{\n\treturn 0;\n}\n\nstatic void rx6110_i2c_unregister(void)\n{\n}\n#endif  \n\nstatic int __init rx6110_module_init(void)\n{\n\tint ret;\n\n\tret = rx6110_spi_register();\n\tif (ret)\n\t\treturn ret;\n\n\tret = rx6110_i2c_register();\n\tif (ret)\n\t\trx6110_spi_unregister();\n\n\treturn ret;\n}\nmodule_init(rx6110_module_init);\n\nstatic void __exit rx6110_module_exit(void)\n{\n\trx6110_spi_unregister();\n\trx6110_i2c_unregister();\n}\nmodule_exit(rx6110_module_exit);\n\nMODULE_AUTHOR(\"Val Krutov <val.krutov@erd.epson.com>\");\nMODULE_DESCRIPTION(\"RX-6110 SA RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}