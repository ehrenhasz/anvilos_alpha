{
  "module_name": "rtc-ds1343.c",
  "hash_id": "cf4de73d943a4fbf3fd75a62d5caf2da74fe1e59febf3f11a533d1f5e735b27d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1343.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/slab.h>\n\n#define DALLAS_MAXIM_DS1343\t0\n#define DALLAS_MAXIM_DS1344\t1\n\n \n#define DS1343_SECONDS_REG\t0x00\n#define DS1343_MINUTES_REG\t0x01\n#define DS1343_HOURS_REG\t0x02\n#define DS1343_DAY_REG\t\t0x03\n#define DS1343_DATE_REG\t\t0x04\n#define DS1343_MONTH_REG\t0x05\n#define DS1343_YEAR_REG\t\t0x06\n#define DS1343_ALM0_SEC_REG\t0x07\n#define DS1343_ALM0_MIN_REG\t0x08\n#define DS1343_ALM0_HOUR_REG\t0x09\n#define DS1343_ALM0_DAY_REG\t0x0A\n#define DS1343_ALM1_SEC_REG\t0x0B\n#define DS1343_ALM1_MIN_REG\t0x0C\n#define DS1343_ALM1_HOUR_REG\t0x0D\n#define DS1343_ALM1_DAY_REG\t0x0E\n#define DS1343_CONTROL_REG\t0x0F\n#define DS1343_STATUS_REG\t0x10\n#define DS1343_TRICKLE_REG\t0x11\n#define DS1343_NVRAM\t\t0x20\n\n#define DS1343_NVRAM_LEN\t96\n\n \n#define DS1343_EOSC\t\t0x80\n#define DS1343_DOSF\t\t0x20\n#define DS1343_EGFIL\t\t0x10\n#define DS1343_SQW\t\t0x08\n#define DS1343_INTCN\t\t0x04\n#define DS1343_A1IE\t\t0x02\n#define DS1343_A0IE\t\t0x01\n\n \n#define DS1343_OSF\t\t0x80\n#define DS1343_IRQF1\t\t0x02\n#define DS1343_IRQF0\t\t0x01\n\n \n#define DS1343_TRICKLE_MAGIC\t0xa0\n#define DS1343_TRICKLE_DS1\t0x08\n#define DS1343_TRICKLE_1K\t0x01\n#define DS1343_TRICKLE_2K\t0x02\n#define DS1343_TRICKLE_4K\t0x03\n\nstatic const struct spi_device_id ds1343_id[] = {\n\t{ \"ds1343\", DALLAS_MAXIM_DS1343 },\n\t{ \"ds1344\", DALLAS_MAXIM_DS1344 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ds1343_id);\n\nstruct ds1343_priv {\n\tstruct rtc_device *rtc;\n\tstruct regmap *map;\n\tint irq;\n};\n\nstatic ssize_t ds1343_show_glitchfilter(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev->parent);\n\tint glitch_filt_status, data;\n\tint res;\n\n\tres = regmap_read(priv->map, DS1343_CONTROL_REG, &data);\n\tif (res)\n\t\treturn res;\n\n\tglitch_filt_status = !!(data & DS1343_EGFIL);\n\n\tif (glitch_filt_status)\n\t\treturn sprintf(buf, \"enabled\\n\");\n\telse\n\t\treturn sprintf(buf, \"disabled\\n\");\n}\n\nstatic ssize_t ds1343_store_glitchfilter(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev->parent);\n\tint data = 0;\n\tint res;\n\n\tif (strncmp(buf, \"enabled\", 7) == 0)\n\t\tdata = DS1343_EGFIL;\n\telse if (strncmp(buf, \"disabled\", 8))\n\t\treturn -EINVAL;\n\n\tres = regmap_update_bits(priv->map, DS1343_CONTROL_REG,\n\t\t\t\t DS1343_EGFIL, data);\n\tif (res)\n\t\treturn res;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(glitch_filter, S_IRUGO | S_IWUSR, ds1343_show_glitchfilter,\n\t\t\tds1343_store_glitchfilter);\n\nstatic int ds1343_nvram_write(void *priv, unsigned int off, void *val,\n\t\t\t      size_t bytes)\n{\n\tstruct ds1343_priv *ds1343 = priv;\n\n\treturn regmap_bulk_write(ds1343->map, DS1343_NVRAM + off, val, bytes);\n}\n\nstatic int ds1343_nvram_read(void *priv, unsigned int off, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct ds1343_priv *ds1343 = priv;\n\n\treturn regmap_bulk_read(ds1343->map, DS1343_NVRAM + off, val, bytes);\n}\n\nstatic ssize_t ds1343_show_tricklecharger(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev->parent);\n\tint res, data;\n\tchar *diodes = \"disabled\", *resistors = \" \";\n\n\tres = regmap_read(priv->map, DS1343_TRICKLE_REG, &data);\n\tif (res)\n\t\treturn res;\n\n\tif ((data & 0xf0) == DS1343_TRICKLE_MAGIC) {\n\t\tswitch (data & 0x0c) {\n\t\tcase DS1343_TRICKLE_DS1:\n\t\t\tdiodes = \"one diode,\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdiodes = \"no diode,\";\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (data & 0x03) {\n\t\tcase DS1343_TRICKLE_1K:\n\t\t\tresistors = \"1k Ohm\";\n\t\t\tbreak;\n\n\t\tcase DS1343_TRICKLE_2K:\n\t\t\tresistors = \"2k Ohm\";\n\t\t\tbreak;\n\n\t\tcase DS1343_TRICKLE_4K:\n\t\t\tresistors = \"4k Ohm\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdiodes = \"disabled\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sprintf(buf, \"%s %s\\n\", diodes, resistors);\n}\n\nstatic DEVICE_ATTR(trickle_charger, S_IRUGO, ds1343_show_tricklecharger, NULL);\n\nstatic struct attribute *ds1343_attrs[] = {\n\t&dev_attr_glitch_filter.attr,\n\t&dev_attr_trickle_charger.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ds1343_attr_group = {\n\t.attrs  = ds1343_attrs,\n};\n\nstatic int ds1343_read_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\tunsigned char buf[7];\n\tint res;\n\n\tres = regmap_bulk_read(priv->map, DS1343_SECONDS_REG, buf, 7);\n\tif (res)\n\t\treturn res;\n\n\tdt->tm_sec\t= bcd2bin(buf[0]);\n\tdt->tm_min\t= bcd2bin(buf[1]);\n\tdt->tm_hour\t= bcd2bin(buf[2] & 0x3F);\n\tdt->tm_wday\t= bcd2bin(buf[3]) - 1;\n\tdt->tm_mday\t= bcd2bin(buf[4]);\n\tdt->tm_mon\t= bcd2bin(buf[5] & 0x1F) - 1;\n\tdt->tm_year\t= bcd2bin(buf[6]) + 100;  \n\n\treturn 0;\n}\n\nstatic int ds1343_set_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\tu8 buf[7];\n\n\tbuf[0] = bin2bcd(dt->tm_sec);\n\tbuf[1] = bin2bcd(dt->tm_min);\n\tbuf[2] = bin2bcd(dt->tm_hour) & 0x3F;\n\tbuf[3] = bin2bcd(dt->tm_wday + 1);\n\tbuf[4] = bin2bcd(dt->tm_mday);\n\tbuf[5] = bin2bcd(dt->tm_mon + 1);\n\tbuf[6] = bin2bcd(dt->tm_year - 100);\n\n\treturn regmap_bulk_write(priv->map, DS1343_SECONDS_REG,\n\t\t\t\t buf, sizeof(buf));\n}\n\nstatic int ds1343_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tunsigned int val;\n\tint res;\n\n\tif (priv->irq <= 0)\n\t\treturn -EINVAL;\n\n\tres = regmap_read(priv->map, DS1343_STATUS_REG, &val);\n\tif (res)\n\t\treturn res;\n\n\talarm->pending = !!(val & DS1343_IRQF0);\n\n\tres = regmap_read(priv->map, DS1343_CONTROL_REG, &val);\n\tif (res)\n\t\treturn res;\n\talarm->enabled = !!(val & DS1343_A0IE);\n\n\tres = regmap_bulk_read(priv->map, DS1343_ALM0_SEC_REG, buf, 4);\n\tif (res)\n\t\treturn res;\n\n\talarm->time.tm_sec = bcd2bin(buf[0]) & 0x7f;\n\talarm->time.tm_min = bcd2bin(buf[1]) & 0x7f;\n\talarm->time.tm_hour = bcd2bin(buf[2]) & 0x3f;\n\talarm->time.tm_mday = bcd2bin(buf[3]) & 0x3f;\n\n\treturn 0;\n}\n\nstatic int ds1343_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tint res = 0;\n\n\tif (priv->irq <= 0)\n\t\treturn -EINVAL;\n\n\tres = regmap_update_bits(priv->map, DS1343_CONTROL_REG, DS1343_A0IE, 0);\n\tif (res)\n\t\treturn res;\n\n\tbuf[0] = bin2bcd(alarm->time.tm_sec);\n\tbuf[1] = bin2bcd(alarm->time.tm_min);\n\tbuf[2] = bin2bcd(alarm->time.tm_hour);\n\tbuf[3] = bin2bcd(alarm->time.tm_mday);\n\n\tres = regmap_bulk_write(priv->map, DS1343_ALM0_SEC_REG, buf, 4);\n\tif (res)\n\t\treturn res;\n\n\tif (alarm->enabled)\n\t\tres = regmap_update_bits(priv->map, DS1343_CONTROL_REG,\n\t\t\t\t\t DS1343_A0IE, DS1343_A0IE);\n\n\treturn res;\n}\n\nstatic int ds1343_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1343_priv *priv = dev_get_drvdata(dev);\n\n\tif (priv->irq <= 0)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(priv->map, DS1343_CONTROL_REG,\n\t\t\t\t  DS1343_A0IE, enabled ? DS1343_A0IE : 0);\n}\n\nstatic irqreturn_t ds1343_thread(int irq, void *dev_id)\n{\n\tstruct ds1343_priv *priv = dev_id;\n\tunsigned int stat;\n\tint res = 0;\n\n\trtc_lock(priv->rtc);\n\n\tres = regmap_read(priv->map, DS1343_STATUS_REG, &stat);\n\tif (res)\n\t\tgoto out;\n\n\tif (stat & DS1343_IRQF0) {\n\t\tstat &= ~DS1343_IRQF0;\n\t\tregmap_write(priv->map, DS1343_STATUS_REG, stat);\n\n\t\trtc_update_irq(priv->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\tregmap_update_bits(priv->map, DS1343_CONTROL_REG,\n\t\t\t\t   DS1343_A0IE, 0);\n\t}\n\nout:\n\trtc_unlock(priv->rtc);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops ds1343_rtc_ops = {\n\t.read_time\t= ds1343_read_time,\n\t.set_time\t= ds1343_set_time,\n\t.read_alarm\t= ds1343_read_alarm,\n\t.set_alarm\t= ds1343_set_alarm,\n\t.alarm_irq_enable = ds1343_alarm_irq_enable,\n};\n\nstatic int ds1343_probe(struct spi_device *spi)\n{\n\tstruct ds1343_priv *priv;\n\tstruct regmap_config config = { .reg_bits = 8, .val_bits = 8,\n\t\t\t\t\t.write_flag_mask = 0x80, };\n\tunsigned int data;\n\tint res;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"ds1343-\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = DS1343_NVRAM_LEN,\n\t\t.reg_read = ds1343_nvram_read,\n\t\t.reg_write = ds1343_nvram_write,\n\t};\n\n\tpriv = devm_kzalloc(&spi->dev, sizeof(struct ds1343_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tspi->mode |= SPI_MODE_3;\n\tspi->mode ^= SPI_CS_HIGH;\n\tspi->bits_per_word = 8;\n\tres = spi_setup(spi);\n\tif (res)\n\t\treturn res;\n\n\tspi_set_drvdata(spi, priv);\n\n\tpriv->map = devm_regmap_init_spi(spi, &config);\n\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(&spi->dev, \"spi regmap init failed for rtc ds1343\\n\");\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tres = regmap_read(priv->map, DS1343_SECONDS_REG, &data);\n\tif (res)\n\t\treturn res;\n\n\tregmap_read(priv->map, DS1343_CONTROL_REG, &data);\n\tdata |= DS1343_INTCN;\n\tdata &= ~(DS1343_EOSC | DS1343_A1IE | DS1343_A0IE);\n\tregmap_write(priv->map, DS1343_CONTROL_REG, data);\n\n\tregmap_read(priv->map, DS1343_STATUS_REG, &data);\n\tdata &= ~(DS1343_OSF | DS1343_IRQF1 | DS1343_IRQF0);\n\tregmap_write(priv->map, DS1343_STATUS_REG, data);\n\n\tpriv->rtc = devm_rtc_allocate_device(&spi->dev);\n\tif (IS_ERR(priv->rtc))\n\t\treturn PTR_ERR(priv->rtc);\n\n\tpriv->rtc->ops = &ds1343_rtc_ops;\n\tpriv->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpriv->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tres = rtc_add_group(priv->rtc, &ds1343_attr_group);\n\tif (res)\n\t\tdev_err(&spi->dev,\n\t\t\t\"unable to create sysfs entries for rtc ds1343\\n\");\n\n\tres = devm_rtc_register_device(priv->rtc);\n\tif (res)\n\t\treturn res;\n\n\tnvmem_cfg.priv = priv;\n\tdevm_rtc_nvmem_register(priv->rtc, &nvmem_cfg);\n\n\tpriv->irq = spi->irq;\n\n\tif (priv->irq >= 0) {\n\t\tres = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,\n\t\t\t\t\t\tds1343_thread, IRQF_ONESHOT,\n\t\t\t\t\t\t\"ds1343\", priv);\n\t\tif (res) {\n\t\t\tpriv->irq = -1;\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"unable to request irq for rtc ds1343\\n\");\n\t\t} else {\n\t\t\tdevice_init_wakeup(&spi->dev, true);\n\t\t\tdev_pm_set_wake_irq(&spi->dev, spi->irq);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ds1343_remove(struct spi_device *spi)\n{\n\tdev_pm_clear_wake_irq(&spi->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int ds1343_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\tif (spi->irq >= 0 && device_may_wakeup(dev))\n\t\tenable_irq_wake(spi->irq);\n\n\treturn 0;\n}\n\nstatic int ds1343_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\tif (spi->irq >= 0 && device_may_wakeup(dev))\n\t\tdisable_irq_wake(spi->irq);\n\n\treturn 0;\n}\n\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ds1343_pm, ds1343_suspend, ds1343_resume);\n\nstatic struct spi_driver ds1343_driver = {\n\t.driver = {\n\t\t.name = \"ds1343\",\n\t\t.pm = &ds1343_pm,\n\t},\n\t.probe = ds1343_probe,\n\t.remove = ds1343_remove,\n\t.id_table = ds1343_id,\n};\n\nmodule_spi_driver(ds1343_driver);\n\nMODULE_DESCRIPTION(\"DS1343 RTC SPI Driver\");\nMODULE_AUTHOR(\"Raghavendra Chandra Ganiga <ravi23ganiga@gmail.com>,\"\n\t\t\"Ankur Srivastava <sankurece@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}