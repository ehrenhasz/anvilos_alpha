{
  "module_name": "rtc-sun6i.c",
  "hash_id": "bad444e02bbd78edbcd49b887ff5b633af0ba9dee4be5bf86dfac163f391354e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sun6i.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clk/sunxi-ng.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define SUN6I_LOSC_CTRL\t\t\t\t0x0000\n#define SUN6I_LOSC_CTRL_KEY\t\t\t(0x16aa << 16)\n#define SUN6I_LOSC_CTRL_AUTO_SWT_BYPASS\t\tBIT(15)\n#define SUN6I_LOSC_CTRL_ALM_DHMS_ACC\t\tBIT(9)\n#define SUN6I_LOSC_CTRL_RTC_HMS_ACC\t\tBIT(8)\n#define SUN6I_LOSC_CTRL_RTC_YMD_ACC\t\tBIT(7)\n#define SUN6I_LOSC_CTRL_EXT_LOSC_EN\t\tBIT(4)\n#define SUN6I_LOSC_CTRL_EXT_OSC\t\t\tBIT(0)\n#define SUN6I_LOSC_CTRL_ACC_MASK\t\tGENMASK(9, 7)\n\n#define SUN6I_LOSC_CLK_PRESCAL\t\t\t0x0008\n\n \n#define SUN6I_RTC_YMD\t\t\t\t0x0010\n#define SUN6I_RTC_HMS\t\t\t\t0x0014\n\n \n#define SUN6I_ALRM_COUNTER\t\t\t0x0020\n \n#define SUN6I_ALRM_COUNTER_HMS\t\t\t0x0024\n#define SUN6I_ALRM_EN\t\t\t\t0x0028\n#define SUN6I_ALRM_EN_CNT_EN\t\t\tBIT(0)\n#define SUN6I_ALRM_IRQ_EN\t\t\t0x002c\n#define SUN6I_ALRM_IRQ_EN_CNT_IRQ_EN\t\tBIT(0)\n#define SUN6I_ALRM_IRQ_STA\t\t\t0x0030\n#define SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND\t\tBIT(0)\n\n \n#define SUN6I_ALRM1_EN\t\t\t\t0x0044\n#define SUN6I_ALRM1_IRQ_EN\t\t\t0x0048\n#define SUN6I_ALRM1_IRQ_STA\t\t\t0x004c\n#define SUN6I_ALRM1_IRQ_STA_WEEK_IRQ_PEND\tBIT(0)\n\n \n#define SUN6I_ALARM_CONFIG\t\t\t0x0050\n#define SUN6I_ALARM_CONFIG_WAKEUP\t\tBIT(0)\n\n#define SUN6I_LOSC_OUT_GATING\t\t\t0x0060\n#define SUN6I_LOSC_OUT_GATING_EN_OFFSET\t\t0\n\n \n#define SUN6I_GP_DATA\t\t\t\t0x0100\n#define SUN6I_GP_DATA_SIZE\t\t\t0x20\n\n \n#define SUN6I_DATE_GET_DAY_VALUE(x)\t\t((x)  & 0x0000001f)\n#define SUN6I_DATE_GET_MON_VALUE(x)\t\t(((x) & 0x00000f00) >> 8)\n#define SUN6I_DATE_GET_YEAR_VALUE(x)\t\t(((x) & 0x003f0000) >> 16)\n#define SUN6I_LEAP_GET_VALUE(x)\t\t\t(((x) & 0x00400000) >> 22)\n\n \n#define SUN6I_TIME_GET_SEC_VALUE(x)\t\t((x)  & 0x0000003f)\n#define SUN6I_TIME_GET_MIN_VALUE(x)\t\t(((x) & 0x00003f00) >> 8)\n#define SUN6I_TIME_GET_HOUR_VALUE(x)\t\t(((x) & 0x001f0000) >> 16)\n\n \n#define SUN6I_DATE_SET_DAY_VALUE(x)\t\t((x)       & 0x0000001f)\n#define SUN6I_DATE_SET_MON_VALUE(x)\t\t((x) <<  8 & 0x00000f00)\n#define SUN6I_DATE_SET_YEAR_VALUE(x)\t\t((x) << 16 & 0x003f0000)\n#define SUN6I_LEAP_SET_VALUE(x)\t\t\t((x) << 22 & 0x00400000)\n\n \n#define SUN6I_TIME_SET_SEC_VALUE(x)\t\t((x)       & 0x0000003f)\n#define SUN6I_TIME_SET_MIN_VALUE(x)\t\t((x) <<  8 & 0x00003f00)\n#define SUN6I_TIME_SET_HOUR_VALUE(x)\t\t((x) << 16 & 0x001f0000)\n\n \n#define SUN6I_YEAR_MIN\t\t\t\t1970\n#define SUN6I_YEAR_OFF\t\t\t\t(SUN6I_YEAR_MIN - 1900)\n\n#define SECS_PER_DAY\t\t\t\t(24 * 3600ULL)\n\n \nstruct sun6i_rtc_clk_data {\n\tunsigned long rc_osc_rate;\n\tunsigned int fixed_prescaler : 16;\n\tunsigned int has_prescaler : 1;\n\tunsigned int has_out_clk : 1;\n\tunsigned int has_losc_en : 1;\n\tunsigned int has_auto_swt : 1;\n};\n\n#define RTC_LINEAR_DAY\tBIT(0)\n\nstruct sun6i_rtc_dev {\n\tstruct rtc_device *rtc;\n\tconst struct sun6i_rtc_clk_data *data;\n\tvoid __iomem *base;\n\tint irq;\n\ttime64_t alarm;\n\tunsigned long flags;\n\n\tstruct clk_hw hw;\n\tstruct clk_hw *int_osc;\n\tstruct clk *losc;\n\tstruct clk *ext_losc;\n\n\tspinlock_t lock;\n};\n\nstatic struct sun6i_rtc_dev *sun6i_rtc;\n\nstatic unsigned long sun6i_rtc_osc_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\n\tu32 val = 0;\n\n\tval = readl(rtc->base + SUN6I_LOSC_CTRL);\n\tif (val & SUN6I_LOSC_CTRL_EXT_OSC)\n\t\treturn parent_rate;\n\n\tif (rtc->data->fixed_prescaler)\n\t\tparent_rate /= rtc->data->fixed_prescaler;\n\n\tif (rtc->data->has_prescaler) {\n\t\tval = readl(rtc->base + SUN6I_LOSC_CLK_PRESCAL);\n\t\tval &= GENMASK(4, 0);\n\t}\n\n\treturn parent_rate / (val + 1);\n}\n\nstatic u8 sun6i_rtc_osc_get_parent(struct clk_hw *hw)\n{\n\tstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\n\n\treturn readl(rtc->base + SUN6I_LOSC_CTRL) & SUN6I_LOSC_CTRL_EXT_OSC;\n}\n\nstatic int sun6i_rtc_osc_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\n\tunsigned long flags;\n\tu32 val;\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\tval = readl(rtc->base + SUN6I_LOSC_CTRL);\n\tval &= ~SUN6I_LOSC_CTRL_EXT_OSC;\n\tval |= SUN6I_LOSC_CTRL_KEY;\n\tval |= index ? SUN6I_LOSC_CTRL_EXT_OSC : 0;\n\tif (rtc->data->has_losc_en) {\n\t\tval &= ~SUN6I_LOSC_CTRL_EXT_LOSC_EN;\n\t\tval |= index ? SUN6I_LOSC_CTRL_EXT_LOSC_EN : 0;\n\t}\n\twritel(val, rtc->base + SUN6I_LOSC_CTRL);\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops sun6i_rtc_osc_ops = {\n\t.recalc_rate\t= sun6i_rtc_osc_recalc_rate,\n\t.determine_rate\t= clk_hw_determine_rate_no_reparent,\n\n\t.get_parent\t= sun6i_rtc_osc_get_parent,\n\t.set_parent\t= sun6i_rtc_osc_set_parent,\n};\n\nstatic void __init sun6i_rtc_clk_init(struct device_node *node,\n\t\t\t\t      const struct sun6i_rtc_clk_data *data)\n{\n\tstruct clk_hw_onecell_data *clk_data;\n\tstruct sun6i_rtc_dev *rtc;\n\tstruct clk_init_data init = {\n\t\t.ops\t\t= &sun6i_rtc_osc_ops,\n\t\t.name\t\t= \"losc\",\n\t};\n\tconst char *iosc_name = \"rtc-int-osc\";\n\tconst char *clkout_name = \"osc32k-out\";\n\tconst char *parents[2];\n\tu32 reg;\n\n\trtc = kzalloc(sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn;\n\n\trtc->data = data;\n\tclk_data = kzalloc(struct_size(clk_data, hws, 3), GFP_KERNEL);\n\tif (!clk_data) {\n\t\tkfree(rtc);\n\t\treturn;\n\t}\n\n\tspin_lock_init(&rtc->lock);\n\n\trtc->base = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(rtc->base)) {\n\t\tpr_crit(\"Can't map RTC registers\");\n\t\tgoto err;\n\t}\n\n\treg = SUN6I_LOSC_CTRL_KEY;\n\tif (rtc->data->has_auto_swt) {\n\t\t \n\t\treg |= SUN6I_LOSC_CTRL_AUTO_SWT_BYPASS;\n\t\twritel(reg, rtc->base + SUN6I_LOSC_CTRL);\n\t}\n\n\t \n\tif (of_property_present(node, \"clocks\")) {\n\t\treg |= SUN6I_LOSC_CTRL_EXT_OSC;\n\t\tif (rtc->data->has_losc_en)\n\t\t\treg |= SUN6I_LOSC_CTRL_EXT_LOSC_EN;\n\t}\n\twritel(reg, rtc->base + SUN6I_LOSC_CTRL);\n\n\t \n\tsun6i_rtc = rtc;\n\n\tof_property_read_string_index(node, \"clock-output-names\", 2,\n\t\t\t\t      &iosc_name);\n\n\trtc->int_osc = clk_hw_register_fixed_rate_with_accuracy(NULL,\n\t\t\t\t\t\t\t\tiosc_name,\n\t\t\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\t\t\trtc->data->rc_osc_rate,\n\t\t\t\t\t\t\t\t300000000);\n\tif (IS_ERR(rtc->int_osc)) {\n\t\tpr_crit(\"Couldn't register the internal oscillator\\n\");\n\t\tgoto err;\n\t}\n\n\tparents[0] = clk_hw_get_name(rtc->int_osc);\n\t \n\tparents[1] = of_clk_get_parent_name(node, 0);\n\n\trtc->hw.init = &init;\n\n\tinit.parent_names = parents;\n\t \n\tinit.num_parents = of_clk_get_parent_count(node) + 1;\n\tof_property_read_string_index(node, \"clock-output-names\", 0,\n\t\t\t\t      &init.name);\n\n\trtc->losc = clk_register(NULL, &rtc->hw);\n\tif (IS_ERR(rtc->losc)) {\n\t\tpr_crit(\"Couldn't register the LOSC clock\\n\");\n\t\tgoto err_register;\n\t}\n\n\tof_property_read_string_index(node, \"clock-output-names\", 1,\n\t\t\t\t      &clkout_name);\n\trtc->ext_losc = clk_register_gate(NULL, clkout_name, init.name,\n\t\t\t\t\t  0, rtc->base + SUN6I_LOSC_OUT_GATING,\n\t\t\t\t\t  SUN6I_LOSC_OUT_GATING_EN_OFFSET, 0,\n\t\t\t\t\t  &rtc->lock);\n\tif (IS_ERR(rtc->ext_losc)) {\n\t\tpr_crit(\"Couldn't register the LOSC external gate\\n\");\n\t\tgoto err_register;\n\t}\n\n\tclk_data->num = 3;\n\tclk_data->hws[0] = &rtc->hw;\n\tclk_data->hws[1] = __clk_get_hw(rtc->ext_losc);\n\tclk_data->hws[2] = rtc->int_osc;\n\tof_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\n\treturn;\n\nerr_register:\n\tclk_hw_unregister_fixed_rate(rtc->int_osc);\nerr:\n\tkfree(clk_data);\n}\n\nstatic const struct sun6i_rtc_clk_data sun6i_a31_rtc_data = {\n\t.rc_osc_rate = 667000,  \n\t.has_prescaler = 1,\n};\n\nstatic void __init sun6i_a31_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun6i_a31_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun6i_a31_rtc_clk, \"allwinner,sun6i-a31-rtc\",\n\t\t      sun6i_a31_rtc_clk_init);\n\nstatic const struct sun6i_rtc_clk_data sun8i_a23_rtc_data = {\n\t.rc_osc_rate = 667000,  \n\t.has_prescaler = 1,\n\t.has_out_clk = 1,\n};\n\nstatic void __init sun8i_a23_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun8i_a23_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun8i_a23_rtc_clk, \"allwinner,sun8i-a23-rtc\",\n\t\t      sun8i_a23_rtc_clk_init);\n\nstatic const struct sun6i_rtc_clk_data sun8i_h3_rtc_data = {\n\t.rc_osc_rate = 16000000,\n\t.fixed_prescaler = 32,\n\t.has_prescaler = 1,\n\t.has_out_clk = 1,\n};\n\nstatic void __init sun8i_h3_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun8i_h3_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun8i_h3_rtc_clk, \"allwinner,sun8i-h3-rtc\",\n\t\t      sun8i_h3_rtc_clk_init);\n \nCLK_OF_DECLARE_DRIVER(sun50i_h5_rtc_clk, \"allwinner,sun50i-h5-rtc\",\n\t\t      sun8i_h3_rtc_clk_init);\n\nstatic const struct sun6i_rtc_clk_data sun50i_h6_rtc_data = {\n\t.rc_osc_rate = 16000000,\n\t.fixed_prescaler = 32,\n\t.has_prescaler = 1,\n\t.has_out_clk = 1,\n\t.has_losc_en = 1,\n\t.has_auto_swt = 1,\n};\n\nstatic void __init sun50i_h6_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun50i_h6_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun50i_h6_rtc_clk, \"allwinner,sun50i-h6-rtc\",\n\t\t      sun50i_h6_rtc_clk_init);\n\n \nstatic const struct sun6i_rtc_clk_data sun8i_r40_rtc_data = {\n\t.rc_osc_rate = 16000000,\n\t.fixed_prescaler = 512,\n};\nstatic void __init sun8i_r40_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun8i_r40_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun8i_r40_rtc_clk, \"allwinner,sun8i-r40-rtc\",\n\t\t      sun8i_r40_rtc_clk_init);\n\nstatic const struct sun6i_rtc_clk_data sun8i_v3_rtc_data = {\n\t.rc_osc_rate = 32000,\n\t.has_out_clk = 1,\n};\n\nstatic void __init sun8i_v3_rtc_clk_init(struct device_node *node)\n{\n\tsun6i_rtc_clk_init(node, &sun8i_v3_rtc_data);\n}\nCLK_OF_DECLARE_DRIVER(sun8i_v3_rtc_clk, \"allwinner,sun8i-v3-rtc\",\n\t\t      sun8i_v3_rtc_clk_init);\n\nstatic irqreturn_t sun6i_rtc_alarmirq(int irq, void *id)\n{\n\tstruct sun6i_rtc_dev *chip = (struct sun6i_rtc_dev *) id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 val;\n\n\tspin_lock(&chip->lock);\n\tval = readl(chip->base + SUN6I_ALRM_IRQ_STA);\n\n\tif (val & SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND) {\n\t\tval |= SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND;\n\t\twritel(val, chip->base + SUN6I_ALRM_IRQ_STA);\n\n\t\trtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\tspin_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)\n{\n\tu32 alrm_val = 0;\n\tu32 alrm_irq_val = 0;\n\tu32 alrm_wake_val = 0;\n\tunsigned long flags;\n\n\tif (to) {\n\t\talrm_val = SUN6I_ALRM_EN_CNT_EN;\n\t\talrm_irq_val = SUN6I_ALRM_IRQ_EN_CNT_IRQ_EN;\n\t\talrm_wake_val = SUN6I_ALARM_CONFIG_WAKEUP;\n\t} else {\n\t\twritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\n\t\t       chip->base + SUN6I_ALRM_IRQ_STA);\n\t}\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\twritel(alrm_val, chip->base + SUN6I_ALRM_EN);\n\twritel(alrm_irq_val, chip->base + SUN6I_ALRM_IRQ_EN);\n\twritel(alrm_wake_val, chip->base + SUN6I_ALARM_CONFIG);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic int sun6i_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\tu32 date, time;\n\n\t \n\tdo {\n\t\tdate = readl(chip->base + SUN6I_RTC_YMD);\n\t\ttime = readl(chip->base + SUN6I_RTC_HMS);\n\t} while ((date != readl(chip->base + SUN6I_RTC_YMD)) ||\n\t\t (time != readl(chip->base + SUN6I_RTC_HMS)));\n\n\tif (chip->flags & RTC_LINEAR_DAY) {\n\t\t \n\t\trtc_time64_to_tm((date & 0xffff) * SECS_PER_DAY, rtc_tm);\n\t} else {\n\t\trtc_tm->tm_mday = SUN6I_DATE_GET_DAY_VALUE(date);\n\t\trtc_tm->tm_mon  = SUN6I_DATE_GET_MON_VALUE(date) - 1;\n\t\trtc_tm->tm_year = SUN6I_DATE_GET_YEAR_VALUE(date);\n\n\t\t \n\t\trtc_tm->tm_year += SUN6I_YEAR_OFF;\n\t}\n\n\trtc_tm->tm_sec  = SUN6I_TIME_GET_SEC_VALUE(time);\n\trtc_tm->tm_min  = SUN6I_TIME_GET_MIN_VALUE(time);\n\trtc_tm->tm_hour = SUN6I_TIME_GET_HOUR_VALUE(time);\n\n\treturn 0;\n}\n\nstatic int sun6i_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 alrm_st;\n\tu32 alrm_en;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\talrm_en = readl(chip->base + SUN6I_ALRM_IRQ_EN);\n\talrm_st = readl(chip->base + SUN6I_ALRM_IRQ_STA);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\twkalrm->enabled = !!(alrm_en & SUN6I_ALRM_EN_CNT_EN);\n\twkalrm->pending = !!(alrm_st & SUN6I_ALRM_EN_CNT_EN);\n\trtc_time64_to_tm(chip->alarm, &wkalrm->time);\n\n\treturn 0;\n}\n\nstatic int sun6i_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\tstruct rtc_time *alrm_tm = &wkalrm->time;\n\tstruct rtc_time tm_now;\n\ttime64_t time_set;\n\tu32 counter_val, counter_val_hms;\n\tint ret;\n\n\ttime_set = rtc_tm_to_time64(alrm_tm);\n\n\tif (chip->flags & RTC_LINEAR_DAY) {\n\t\t \n\t\tcounter_val_hms = SUN6I_TIME_SET_SEC_VALUE(alrm_tm->tm_sec)  |\n\t\t\t\t  SUN6I_TIME_SET_MIN_VALUE(alrm_tm->tm_min)  |\n\t\t\t\t  SUN6I_TIME_SET_HOUR_VALUE(alrm_tm->tm_hour);\n\t\t \n\t\tcounter_val = div_u64(rtc_tm_to_time64(alrm_tm), SECS_PER_DAY);\n\t} else {\n\t\t \n\t\ttime64_t time_now;\n\n\t\tret = sun6i_rtc_gettime(dev, &tm_now);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error in getting time\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttime_now = rtc_tm_to_time64(&tm_now);\n\t\tif (time_set <= time_now) {\n\t\t\tdev_err(dev, \"Date to set in the past\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((time_set - time_now) > U32_MAX) {\n\t\t\tdev_err(dev, \"Date too far in the future\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcounter_val = time_set - time_now;\n\t}\n\n\tsun6i_rtc_setaie(0, chip);\n\twritel(0, chip->base + SUN6I_ALRM_COUNTER);\n\tif (chip->flags & RTC_LINEAR_DAY)\n\t\twritel(0, chip->base + SUN6I_ALRM_COUNTER_HMS);\n\tusleep_range(100, 300);\n\n\twritel(counter_val, chip->base + SUN6I_ALRM_COUNTER);\n\tif (chip->flags & RTC_LINEAR_DAY)\n\t\twritel(counter_val_hms, chip->base + SUN6I_ALRM_COUNTER_HMS);\n\tchip->alarm = time_set;\n\n\tsun6i_rtc_setaie(wkalrm->enabled, chip);\n\n\treturn 0;\n}\n\nstatic int sun6i_rtc_wait(struct sun6i_rtc_dev *chip, int offset,\n\t\t\t  unsigned int mask, unsigned int ms_timeout)\n{\n\tconst unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);\n\tu32 reg;\n\n\tdo {\n\t\treg = readl(chip->base + offset);\n\t\treg &= mask;\n\n\t\tif (!reg)\n\t\t\treturn 0;\n\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int sun6i_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\tu32 date = 0;\n\tu32 time = 0;\n\n\ttime = SUN6I_TIME_SET_SEC_VALUE(rtc_tm->tm_sec)  |\n\t\tSUN6I_TIME_SET_MIN_VALUE(rtc_tm->tm_min)  |\n\t\tSUN6I_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);\n\n\tif (chip->flags & RTC_LINEAR_DAY) {\n\t\t \n\t\tdate = div_u64(rtc_tm_to_time64(rtc_tm), SECS_PER_DAY);\n\t} else {\n\t\trtc_tm->tm_year -= SUN6I_YEAR_OFF;\n\t\trtc_tm->tm_mon += 1;\n\n\t\tdate = SUN6I_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |\n\t\t\tSUN6I_DATE_SET_MON_VALUE(rtc_tm->tm_mon)  |\n\t\t\tSUN6I_DATE_SET_YEAR_VALUE(rtc_tm->tm_year);\n\n\t\tif (is_leap_year(rtc_tm->tm_year + SUN6I_YEAR_MIN))\n\t\t\tdate |= SUN6I_LEAP_SET_VALUE(1);\n\t}\n\n\t \n\tif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\n\t\t\t   SUN6I_LOSC_CTRL_ACC_MASK, 50)) {\n\t\tdev_err(dev, \"rtc is still busy.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twritel(time, chip->base + SUN6I_RTC_HMS);\n\n\t \n\n\tif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\n\t\t\t   SUN6I_LOSC_CTRL_RTC_HMS_ACC, 50)) {\n\t\tdev_err(dev, \"Failed to set rtc time.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twritel(date, chip->base + SUN6I_RTC_YMD);\n\n\t \n\n\tif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\n\t\t\t   SUN6I_LOSC_CTRL_RTC_YMD_ACC, 50)) {\n\t\tdev_err(dev, \"Failed to set rtc time.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun6i_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\n\tif (!enabled)\n\t\tsun6i_rtc_setaie(enabled, chip);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sun6i_rtc_ops = {\n\t.read_time\t\t= sun6i_rtc_gettime,\n\t.set_time\t\t= sun6i_rtc_settime,\n\t.read_alarm\t\t= sun6i_rtc_getalarm,\n\t.set_alarm\t\t= sun6i_rtc_setalarm,\n\t.alarm_irq_enable\t= sun6i_rtc_alarm_irq_enable\n};\n\nstatic int sun6i_rtc_nvmem_read(void *priv, unsigned int offset, void *_val, size_t bytes)\n{\n\tstruct sun6i_rtc_dev *chip = priv;\n\tu32 *val = _val;\n\tint i;\n\n\tfor (i = 0; i < bytes / 4; ++i)\n\t\tval[i] = readl(chip->base + SUN6I_GP_DATA + offset + 4 * i);\n\n\treturn 0;\n}\n\nstatic int sun6i_rtc_nvmem_write(void *priv, unsigned int offset, void *_val, size_t bytes)\n{\n\tstruct sun6i_rtc_dev *chip = priv;\n\tu32 *val = _val;\n\tint i;\n\n\tfor (i = 0; i < bytes / 4; ++i)\n\t\twritel(val[i], chip->base + SUN6I_GP_DATA + offset + 4 * i);\n\n\treturn 0;\n}\n\nstatic struct nvmem_config sun6i_rtc_nvmem_cfg = {\n\t.type\t\t= NVMEM_TYPE_BATTERY_BACKED,\n\t.reg_read\t= sun6i_rtc_nvmem_read,\n\t.reg_write\t= sun6i_rtc_nvmem_write,\n\t.size\t\t= SUN6I_GP_DATA_SIZE,\n\t.word_size\t= 4,\n\t.stride\t\t= 4,\n};\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int sun6i_rtc_suspend(struct device *dev)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(chip->irq);\n\n\treturn 0;\n}\n\n \nstatic int sun6i_rtc_resume(struct device *dev)\n{\n\tstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(chip->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sun6i_rtc_pm_ops,\n\tsun6i_rtc_suspend, sun6i_rtc_resume);\n\nstatic void sun6i_rtc_bus_clk_cleanup(void *data)\n{\n\tstruct clk *bus_clk = data;\n\n\tclk_disable_unprepare(bus_clk);\n}\n\nstatic int sun6i_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sun6i_rtc_dev *chip = sun6i_rtc;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *bus_clk;\n\tint ret;\n\n\tbus_clk = devm_clk_get_optional(dev, \"bus\");\n\tif (IS_ERR(bus_clk))\n\t\treturn PTR_ERR(bus_clk);\n\n\tif (bus_clk) {\n\t\tret = clk_prepare_enable(bus_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(dev, sun6i_rtc_bus_clk_cleanup,\n\t\t\t\t\t       bus_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!chip) {\n\t\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\t\tif (!chip)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&chip->lock);\n\n\t\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(chip->base))\n\t\t\treturn PTR_ERR(chip->base);\n\n\t\tif (IS_REACHABLE(CONFIG_SUN6I_RTC_CCU)) {\n\t\t\tret = sun6i_rtc_ccu_probe(dev, chip->base);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, chip);\n\n\tchip->flags = (unsigned long)of_device_get_match_data(&pdev->dev);\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tif (chip->irq < 0)\n\t\treturn chip->irq;\n\n\tret = devm_request_irq(&pdev->dev, chip->irq, sun6i_rtc_alarmirq,\n\t\t\t       0, dev_name(&pdev->dev), chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(0, chip->base + SUN6I_ALRM_COUNTER);\n\n\t \n\twritel(0, chip->base + SUN6I_ALRM_EN);\n\n\t \n\twritel(0, chip->base + SUN6I_ALRM_IRQ_EN);\n\n\t \n\twritel(0, chip->base + SUN6I_ALRM1_EN);\n\n\t \n\twritel(0, chip->base + SUN6I_ALRM1_IRQ_EN);\n\n\t \n\twritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\n\t       chip->base + SUN6I_ALRM_IRQ_STA);\n\n\t \n\twritel(SUN6I_ALRM1_IRQ_STA_WEEK_IRQ_PEND,\n\t       chip->base + SUN6I_ALRM1_IRQ_STA);\n\n\t \n\twritel(0, chip->base + SUN6I_ALARM_CONFIG);\n\n\tclk_prepare_enable(chip->losc);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tchip->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(chip->rtc))\n\t\treturn PTR_ERR(chip->rtc);\n\n\tchip->rtc->ops = &sun6i_rtc_ops;\n\tif (chip->flags & RTC_LINEAR_DAY)\n\t\tchip->rtc->range_max = (65536 * SECS_PER_DAY) - 1;\n\telse\n\t\tchip->rtc->range_max = 2019686399LL;  \n\n\tret = devm_rtc_register_device(chip->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tsun6i_rtc_nvmem_cfg.priv = chip;\n\tret = devm_rtc_nvmem_register(chip->rtc, &sun6i_rtc_nvmem_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id sun6i_rtc_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-rtc\" },\n\t{ .compatible = \"allwinner,sun8i-a23-rtc\" },\n\t{ .compatible = \"allwinner,sun8i-h3-rtc\" },\n\t{ .compatible = \"allwinner,sun8i-r40-rtc\" },\n\t{ .compatible = \"allwinner,sun8i-v3-rtc\" },\n\t{ .compatible = \"allwinner,sun50i-h5-rtc\" },\n\t{ .compatible = \"allwinner,sun50i-h6-rtc\" },\n\t{ .compatible = \"allwinner,sun50i-h616-rtc\",\n\t\t.data = (void *)RTC_LINEAR_DAY },\n\t{ .compatible = \"allwinner,sun50i-r329-rtc\",\n\t\t.data = (void *)RTC_LINEAR_DAY },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sun6i_rtc_dt_ids);\n\nstatic struct platform_driver sun6i_rtc_driver = {\n\t.probe\t\t= sun6i_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"sun6i-rtc\",\n\t\t.of_match_table = sun6i_rtc_dt_ids,\n\t\t.pm = &sun6i_rtc_pm_ops,\n\t},\n};\nbuiltin_platform_driver(sun6i_rtc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}