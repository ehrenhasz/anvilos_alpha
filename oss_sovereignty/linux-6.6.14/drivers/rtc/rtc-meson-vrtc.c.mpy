{
  "module_name": "rtc-meson-vrtc.c",
  "hash_id": "e36acc945328782e62f8238a55cd1d8c2c768ec3c44c2331b688c08f6e4496a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-meson-vrtc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/time64.h>\n\nstruct meson_vrtc_data {\n\tvoid __iomem *io_alarm;\n\tstruct rtc_device *rtc;\n\tunsigned long alarm_time;\n\tbool enabled;\n};\n\nstatic int meson_vrtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct timespec64 time;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tktime_get_real_ts64(&time);\n\trtc_time64_to_tm(time.tv_sec, tm);\n\n\treturn 0;\n}\n\nstatic void meson_vrtc_set_wakeup_time(struct meson_vrtc_data *vrtc,\n\t\t\t\t       unsigned long time)\n{\n\twritel_relaxed(time, vrtc->io_alarm);\n}\n\nstatic int meson_vrtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct meson_vrtc_data *vrtc = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s: alarm->enabled=%d\\n\", __func__, alarm->enabled);\n\tif (alarm->enabled)\n\t\tvrtc->alarm_time = rtc_tm_to_time64(&alarm->time);\n\telse\n\t\tvrtc->alarm_time = 0;\n\n\treturn 0;\n}\n\nstatic int meson_vrtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct meson_vrtc_data *vrtc = dev_get_drvdata(dev);\n\n\tvrtc->enabled = enabled;\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops meson_vrtc_ops = {\n\t.read_time = meson_vrtc_read_time,\n\t.set_alarm = meson_vrtc_set_alarm,\n\t.alarm_irq_enable = meson_vrtc_alarm_irq_enable,\n};\n\nstatic int meson_vrtc_probe(struct platform_device *pdev)\n{\n\tstruct meson_vrtc_data *vrtc;\n\n\tvrtc = devm_kzalloc(&pdev->dev, sizeof(*vrtc), GFP_KERNEL);\n\tif (!vrtc)\n\t\treturn -ENOMEM;\n\n\tvrtc->io_alarm = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vrtc->io_alarm))\n\t\treturn PTR_ERR(vrtc->io_alarm);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tplatform_set_drvdata(pdev, vrtc);\n\n\tvrtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(vrtc->rtc))\n\t\treturn PTR_ERR(vrtc->rtc);\n\n\tvrtc->rtc->ops = &meson_vrtc_ops;\n\treturn devm_rtc_register_device(vrtc->rtc);\n}\n\nstatic int __maybe_unused meson_vrtc_suspend(struct device *dev)\n{\n\tstruct meson_vrtc_data *vrtc = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tif (vrtc->alarm_time) {\n\t\tunsigned long local_time;\n\t\tlong alarm_secs;\n\t\tstruct timespec64 time;\n\n\t\tktime_get_real_ts64(&time);\n\t\tlocal_time = time.tv_sec;\n\n\t\tdev_dbg(dev, \"alarm_time = %lus, local_time=%lus\\n\",\n\t\t\tvrtc->alarm_time, local_time);\n\t\talarm_secs = vrtc->alarm_time - local_time;\n\t\tif (alarm_secs > 0) {\n\t\t\tmeson_vrtc_set_wakeup_time(vrtc, alarm_secs);\n\t\t\tdev_dbg(dev, \"system will wakeup in %lds.\\n\",\n\t\t\t\talarm_secs);\n\t\t} else {\n\t\t\tdev_err(dev, \"alarm time already passed: %lds.\\n\",\n\t\t\t\talarm_secs);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused meson_vrtc_resume(struct device *dev)\n{\n\tstruct meson_vrtc_data *vrtc = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tvrtc->alarm_time = 0;\n\tmeson_vrtc_set_wakeup_time(vrtc, 0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(meson_vrtc_pm_ops,\n\t\t\t meson_vrtc_suspend, meson_vrtc_resume);\n\nstatic const struct of_device_id meson_vrtc_dt_match[] = {\n\t{ .compatible = \"amlogic,meson-vrtc\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, meson_vrtc_dt_match);\n\nstatic struct platform_driver meson_vrtc_driver = {\n\t.probe = meson_vrtc_probe,\n\t.driver = {\n\t\t.name = \"meson-vrtc\",\n\t\t.of_match_table = meson_vrtc_dt_match,\n\t\t.pm = &meson_vrtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(meson_vrtc_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Virtual Wakeup RTC Timer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}