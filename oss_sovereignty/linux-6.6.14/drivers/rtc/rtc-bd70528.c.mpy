{
  "module_name": "rtc-bd70528.c",
  "hash_id": "43196d02afb73cfb98d1b753241d9a6ef2559214f25f9041174ae10320a39e63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-bd70528.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bcd.h>\n#include <linux/mfd/rohm-bd71815.h>\n#include <linux/mfd/rohm-bd71828.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n \n#define BD718XX_ALM_EN_OFFSET 14\n\n \nstruct bd70528_rtc_day {\n\tu8 sec;\n\tu8 min;\n\tu8 hour;\n} __packed;\n\nstruct bd70528_rtc_data {\n\tstruct bd70528_rtc_day time;\n\tu8 week;\n\tu8 day;\n\tu8 month;\n\tu8 year;\n} __packed;\n\nstruct bd71828_rtc_alm {\n\tstruct bd70528_rtc_data alm0;\n\tstruct bd70528_rtc_data alm1;\n\tu8 alm_mask;\n\tu8 alm1_mask;\n} __packed;\n\nstruct bd70528_rtc {\n\tstruct rohm_regmap_dev *parent;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tu8 reg_time_start;\n\tu8 bd718xx_alm_block_start;\n};\n\nstatic inline void tmday2rtc(struct rtc_time *t, struct bd70528_rtc_day *d)\n{\n\td->sec &= ~BD70528_MASK_RTC_SEC;\n\td->min &= ~BD70528_MASK_RTC_MINUTE;\n\td->hour &= ~BD70528_MASK_RTC_HOUR;\n\td->sec |= bin2bcd(t->tm_sec);\n\td->min |= bin2bcd(t->tm_min);\n\td->hour |= bin2bcd(t->tm_hour);\n}\n\nstatic inline void tm2rtc(struct rtc_time *t, struct bd70528_rtc_data *r)\n{\n\tr->day &= ~BD70528_MASK_RTC_DAY;\n\tr->week &= ~BD70528_MASK_RTC_WEEK;\n\tr->month &= ~BD70528_MASK_RTC_MONTH;\n\t \n\tr->time.hour &= ~(BD70528_MASK_RTC_HOUR_PM | BD70528_MASK_RTC_HOUR_24H);\n\n\ttmday2rtc(t, &r->time);\n\t \n\tr->time.hour |= BD70528_MASK_RTC_HOUR_24H;\n\tr->day |= bin2bcd(t->tm_mday);\n\tr->week |= bin2bcd(t->tm_wday);\n\tr->month |= bin2bcd(t->tm_mon + 1);\n\tr->year = bin2bcd(t->tm_year - 100);\n}\n\nstatic inline void rtc2tm(struct bd70528_rtc_data *r, struct rtc_time *t)\n{\n\tt->tm_sec = bcd2bin(r->time.sec & BD70528_MASK_RTC_SEC);\n\tt->tm_min = bcd2bin(r->time.min & BD70528_MASK_RTC_MINUTE);\n\tt->tm_hour = bcd2bin(r->time.hour & BD70528_MASK_RTC_HOUR);\n\t \n\tif (!(r->time.hour & BD70528_MASK_RTC_HOUR_24H)) {\n\t\tt->tm_hour %= 12;\n\t\tif (r->time.hour & BD70528_MASK_RTC_HOUR_PM)\n\t\t\tt->tm_hour += 12;\n\t}\n\tt->tm_mday = bcd2bin(r->day & BD70528_MASK_RTC_DAY);\n\tt->tm_mon = bcd2bin(r->month & BD70528_MASK_RTC_MONTH) - 1;\n\tt->tm_year = 100 + bcd2bin(r->year & BD70528_MASK_RTC_YEAR);\n\tt->tm_wday = bcd2bin(r->week & BD70528_MASK_RTC_WEEK);\n}\n\nstatic int bd71828_set_alarm(struct device *dev, struct rtc_wkalrm *a)\n{\n\tint ret;\n\tstruct bd71828_rtc_alm alm;\n\tstruct bd70528_rtc *r = dev_get_drvdata(dev);\n\n\tret = regmap_bulk_read(r->regmap, r->bd718xx_alm_block_start, &alm,\n\t\t\t       sizeof(alm));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read alarm regs\\n\");\n\t\treturn ret;\n\t}\n\n\ttm2rtc(&a->time, &alm.alm0);\n\n\tif (!a->enabled)\n\t\talm.alm_mask &= ~BD70528_MASK_ALM_EN;\n\telse\n\t\talm.alm_mask |= BD70528_MASK_ALM_EN;\n\n\tret = regmap_bulk_write(r->regmap, r->bd718xx_alm_block_start, &alm,\n\t\t\t\tsizeof(alm));\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set alarm time\\n\");\n\n\treturn ret;\n\n}\n\nstatic int bd71828_read_alarm(struct device *dev, struct rtc_wkalrm *a)\n{\n\tint ret;\n\tstruct bd71828_rtc_alm alm;\n\tstruct bd70528_rtc *r = dev_get_drvdata(dev);\n\n\tret = regmap_bulk_read(r->regmap, r->bd718xx_alm_block_start, &alm,\n\t\t\t       sizeof(alm));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read alarm regs\\n\");\n\t\treturn ret;\n\t}\n\n\trtc2tm(&alm.alm0, &a->time);\n\ta->time.tm_mday = -1;\n\ta->time.tm_mon = -1;\n\ta->time.tm_year = -1;\n\ta->enabled = !!(alm.alm_mask & BD70528_MASK_ALM_EN);\n\ta->pending = 0;\n\n\treturn 0;\n}\n\nstatic int bd71828_set_time(struct device *dev, struct rtc_time *t)\n{\n\tint ret;\n\tstruct bd70528_rtc_data rtc_data;\n\tstruct bd70528_rtc *r = dev_get_drvdata(dev);\n\n\tret = regmap_bulk_read(r->regmap, r->reg_time_start, &rtc_data,\n\t\t\t       sizeof(rtc_data));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read RTC time registers\\n\");\n\t\treturn ret;\n\t}\n\ttm2rtc(t, &rtc_data);\n\n\tret = regmap_bulk_write(r->regmap, r->reg_time_start, &rtc_data,\n\t\t\t\tsizeof(rtc_data));\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set RTC time\\n\");\n\n\treturn ret;\n}\n\nstatic int bd70528_get_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct bd70528_rtc *r = dev_get_drvdata(dev);\n\tstruct bd70528_rtc_data rtc_data;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(r->regmap, r->reg_time_start, &rtc_data,\n\t\t\t       sizeof(rtc_data));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read RTC time (err %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtc2tm(&rtc_data, t);\n\n\treturn 0;\n}\n\nstatic int bd71828_alm_enable(struct device *dev, unsigned int enabled)\n{\n\tint ret;\n\tstruct bd70528_rtc *r = dev_get_drvdata(dev);\n\tunsigned int enableval = BD70528_MASK_ALM_EN;\n\n\tif (!enabled)\n\t\tenableval = 0;\n\n\tret = regmap_update_bits(r->regmap, r->bd718xx_alm_block_start +\n\t\t\t\t BD718XX_ALM_EN_OFFSET, BD70528_MASK_ALM_EN,\n\t\t\t\t enableval);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to change alarm state\\n\");\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops bd71828_rtc_ops = {\n\t.read_time\t\t= bd70528_get_time,\n\t.set_time\t\t= bd71828_set_time,\n\t.read_alarm\t\t= bd71828_read_alarm,\n\t.set_alarm\t\t= bd71828_set_alarm,\n\t.alarm_irq_enable\t= bd71828_alm_enable,\n};\n\nstatic irqreturn_t alm_hndlr(int irq, void *data)\n{\n\tstruct rtc_device *rtc = data;\n\n\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF | RTC_PF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bd70528_probe(struct platform_device *pdev)\n{\n\tstruct bd70528_rtc *bd_rtc;\n\tconst struct rtc_class_ops *rtc_ops;\n\tconst char *irq_name;\n\tint ret;\n\tstruct rtc_device *rtc;\n\tint irq;\n\tunsigned int hr;\n\tu8 hour_reg;\n\tenum rohm_chip_type chip = platform_get_device_id(pdev)->driver_data;\n\n\tbd_rtc = devm_kzalloc(&pdev->dev, sizeof(*bd_rtc), GFP_KERNEL);\n\tif (!bd_rtc)\n\t\treturn -ENOMEM;\n\n\tbd_rtc->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!bd_rtc->regmap) {\n\t\tdev_err(&pdev->dev, \"No regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbd_rtc->dev = &pdev->dev;\n\trtc_ops = &bd71828_rtc_ops;\n\n\tswitch (chip) {\n\tcase ROHM_CHIP_TYPE_BD71815:\n\t\tirq_name = \"bd71815-rtc-alm-0\";\n\t\tbd_rtc->reg_time_start = BD71815_REG_RTC_START;\n\n\t\t \n\t\tbd_rtc->bd718xx_alm_block_start = BD71815_REG_RTC_ALM_START;\n\t\thour_reg = BD71815_REG_HOUR;\n\t\tbreak;\n\tcase ROHM_CHIP_TYPE_BD71828:\n\t\tirq_name = \"bd71828-rtc-alm-0\";\n\t\tbd_rtc->reg_time_start = BD71828_REG_RTC_START;\n\t\tbd_rtc->bd718xx_alm_block_start = BD71828_REG_RTC_ALM_START;\n\t\thour_reg = BD71828_REG_RTC_HOUR;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown chip\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tirq = platform_get_irq_byname(pdev, irq_name);\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tplatform_set_drvdata(pdev, bd_rtc);\n\n\tret = regmap_read(bd_rtc->regmap, hour_reg, &hr);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to reag RTC clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(hr & BD70528_MASK_RTC_HOUR_24H)) {\n\t\tstruct rtc_time t;\n\n\t\tret = rtc_ops->read_time(&pdev->dev, &t);\n\n\t\tif (!ret)\n\t\t\tret = rtc_ops->set_time(&pdev->dev, &t);\n\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Setting 24H clock for RTC failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\tdevice_wakeup_enable(&pdev->dev);\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc)) {\n\t\tdev_err(&pdev->dev, \"RTC device creation failed\\n\");\n\t\treturn PTR_ERR(rtc);\n\t}\n\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->range_max = RTC_TIMESTAMP_END_2099;\n\trtc->ops = rtc_ops;\n\n\t \n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL, &alm_hndlr,\n\t\t\t\t\tIRQF_ONESHOT, \"bd70528-rtc\", rtc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic const struct platform_device_id bd718x7_rtc_id[] = {\n\t{ \"bd71828-rtc\", ROHM_CHIP_TYPE_BD71828 },\n\t{ \"bd71815-rtc\", ROHM_CHIP_TYPE_BD71815 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, bd718x7_rtc_id);\n\nstatic struct platform_driver bd70528_rtc = {\n\t.driver = {\n\t\t.name = \"bd70528-rtc\"\n\t},\n\t.probe = bd70528_probe,\n\t.id_table = bd718x7_rtc_id,\n};\n\nmodule_platform_driver(bd70528_rtc);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD71828 and BD71815 PMIC RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bd70528-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}