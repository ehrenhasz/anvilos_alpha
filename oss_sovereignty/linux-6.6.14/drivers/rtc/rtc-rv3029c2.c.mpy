{
  "module_name": "rtc-rv3029c2.c",
  "hash_id": "f5e1825e072474c72f51eb47f9174074605b3ea1ccf9f11cc351b4b79ef197ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rv3029c2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kstrtox.h>\n#include <linux/regmap.h>\n\n \n \n#define RV3029_ONOFF_CTRL\t\t0x00\n#define RV3029_ONOFF_CTRL_WE\t\tBIT(0)\n#define RV3029_ONOFF_CTRL_TE\t\tBIT(1)\n#define RV3029_ONOFF_CTRL_TAR\t\tBIT(2)\n#define RV3029_ONOFF_CTRL_EERE\t\tBIT(3)\n#define RV3029_ONOFF_CTRL_SRON\t\tBIT(4)\n#define RV3029_ONOFF_CTRL_TD0\t\tBIT(5)\n#define RV3029_ONOFF_CTRL_TD1\t\tBIT(6)\n#define RV3029_ONOFF_CTRL_CLKINT\tBIT(7)\n#define RV3029_IRQ_CTRL\t\t\t0x01\n#define RV3029_IRQ_CTRL_AIE\t\tBIT(0)\n#define RV3029_IRQ_CTRL_TIE\t\tBIT(1)\n#define RV3029_IRQ_CTRL_V1IE\t\tBIT(2)\n#define RV3029_IRQ_CTRL_V2IE\t\tBIT(3)\n#define RV3029_IRQ_CTRL_SRIE\t\tBIT(4)\n#define RV3029_IRQ_FLAGS\t\t0x02\n#define RV3029_IRQ_FLAGS_AF\t\tBIT(0)\n#define RV3029_IRQ_FLAGS_TF\t\tBIT(1)\n#define RV3029_IRQ_FLAGS_V1IF\t\tBIT(2)\n#define RV3029_IRQ_FLAGS_V2IF\t\tBIT(3)\n#define RV3029_IRQ_FLAGS_SRF\t\tBIT(4)\n#define RV3029_STATUS\t\t\t0x03\n#define RV3029_STATUS_VLOW1\t\tBIT(2)\n#define RV3029_STATUS_VLOW2\t\tBIT(3)\n#define RV3029_STATUS_SR\t\tBIT(4)\n#define RV3029_STATUS_PON\t\tBIT(5)\n#define RV3029_STATUS_EEBUSY\t\tBIT(7)\n#define RV3029_RST_CTRL\t\t\t0x04\n#define RV3029_RST_CTRL_SYSR\t\tBIT(4)\n#define RV3029_CONTROL_SECTION_LEN\t0x05\n\n \n#define RV3029_W_SEC\t\t\t0x08\n#define RV3029_W_MINUTES\t\t0x09\n#define RV3029_W_HOURS\t\t\t0x0A\n#define RV3029_REG_HR_12_24\t\tBIT(6)  \n#define RV3029_REG_HR_PM\t\tBIT(5)  \n#define RV3029_W_DATE\t\t\t0x0B\n#define RV3029_W_DAYS\t\t\t0x0C\n#define RV3029_W_MONTHS\t\t\t0x0D\n#define RV3029_W_YEARS\t\t\t0x0E\n#define RV3029_WATCH_SECTION_LEN\t0x07\n\n \n#define RV3029_A_SC\t\t\t0x10\n#define RV3029_A_MN\t\t\t0x11\n#define RV3029_A_HR\t\t\t0x12\n#define RV3029_A_DT\t\t\t0x13\n#define RV3029_A_DW\t\t\t0x14\n#define RV3029_A_MO\t\t\t0x15\n#define RV3029_A_YR\t\t\t0x16\n#define RV3029_A_AE_X\t\t\tBIT(7)\n#define RV3029_ALARM_SECTION_LEN\t0x07\n\n \n#define RV3029_TIMER_LOW\t\t0x18\n#define RV3029_TIMER_HIGH\t\t0x19\n\n \n#define RV3029_TEMP_PAGE\t\t0x20\n\n \n#define RV3029_E2P_EEDATA1\t\t0x28\n#define RV3029_E2P_EEDATA2\t\t0x29\n#define RV3029_E2PDATA_SECTION_LEN\t0x02\n\n \n#define RV3029_CONTROL_E2P_EECTRL\t0x30\n#define RV3029_EECTRL_THP\t\tBIT(0)  \n#define RV3029_EECTRL_THE\t\tBIT(1)  \n#define RV3029_EECTRL_FD0\t\tBIT(2)  \n#define RV3029_EECTRL_FD1\t\tBIT(3)  \n#define RV3029_TRICKLE_1K\t\tBIT(4)  \n#define RV3029_TRICKLE_5K\t\tBIT(5)  \n#define RV3029_TRICKLE_20K\t\tBIT(6)  \n#define RV3029_TRICKLE_80K\t\tBIT(7)  \n#define RV3029_TRICKLE_MASK\t\t(RV3029_TRICKLE_1K |\\\n\t\t\t\t\t RV3029_TRICKLE_5K |\\\n\t\t\t\t\t RV3029_TRICKLE_20K |\\\n\t\t\t\t\t RV3029_TRICKLE_80K)\n#define RV3029_TRICKLE_SHIFT\t\t4\n#define RV3029_CONTROL_E2P_XOFFS\t0x31  \n#define RV3029_CONTROL_E2P_XOFFS_SIGN\tBIT(7)  \n#define RV3029_CONTROL_E2P_QCOEF\t0x32  \n#define RV3029_CONTROL_E2P_TURNOVER\t0x33  \n#define RV3029_CONTROL_E2P_TOV_MASK\t0x3F  \n\n \n#define RV3029_RAM_PAGE\t\t\t0x38\n#define RV3029_RAM_SECTION_LEN\t\t8\n\nstruct rv3029_data {\n\tstruct device\t\t*dev;\n\tstruct rtc_device\t*rtc;\n\tstruct regmap\t\t*regmap;\n\tint irq;\n};\n\nstatic int rv3029_eeprom_busywait(struct rv3029_data *rv3029)\n{\n\tunsigned int sr;\n\tint i, ret;\n\n\tfor (i = 100; i > 0; i--) {\n\t\tret = regmap_read(rv3029->regmap, RV3029_STATUS, &sr);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (!(sr & RV3029_STATUS_EEBUSY))\n\t\t\tbreak;\n\t\tusleep_range(1000, 10000);\n\t}\n\tif (i <= 0) {\n\t\tdev_err(rv3029->dev, \"EEPROM busy wait timeout.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int rv3029_eeprom_exit(struct rv3029_data *rv3029)\n{\n\t \n\treturn regmap_update_bits(rv3029->regmap, RV3029_ONOFF_CTRL,\n\t\t\t\t  RV3029_ONOFF_CTRL_EERE,\n\t\t\t\t  RV3029_ONOFF_CTRL_EERE);\n}\n\nstatic int rv3029_eeprom_enter(struct rv3029_data *rv3029)\n{\n\tunsigned int sr;\n\tint ret;\n\n\t \n\tret = regmap_read(rv3029->regmap, RV3029_STATUS, &sr);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (sr & RV3029_STATUS_VLOW2)\n\t\treturn -ENODEV;\n\tif (sr & RV3029_STATUS_VLOW1) {\n\t\t \n\t\tret = regmap_update_bits(rv3029->regmap, RV3029_STATUS,\n\t\t\t\t\t RV3029_STATUS_VLOW1, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tusleep_range(1000, 10000);\n\t\tret = regmap_read(rv3029->regmap, RV3029_STATUS, &sr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (sr & RV3029_STATUS_VLOW1) {\n\t\t\tdev_err(rv3029->dev,\n\t\t\t\t\"Supply voltage is too low to safely access the EEPROM.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tret = regmap_update_bits(rv3029->regmap, RV3029_ONOFF_CTRL,\n\t\t\t\t RV3029_ONOFF_CTRL_EERE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rv3029_eeprom_busywait(rv3029);\n\tif (ret < 0)\n\t\trv3029_eeprom_exit(rv3029);\n\n\treturn ret;\n}\n\nstatic int rv3029_eeprom_read(struct rv3029_data *rv3029, u8 reg,\n\t\t\t      u8 buf[], size_t len)\n{\n\tint ret, err;\n\n\terr = rv3029_eeprom_enter(rv3029);\n\tif (err < 0)\n\t\treturn err;\n\n\tret = regmap_bulk_read(rv3029->regmap, reg, buf, len);\n\n\terr = rv3029_eeprom_exit(rv3029);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn ret;\n}\n\nstatic int rv3029_eeprom_write(struct rv3029_data *rv3029, u8 reg,\n\t\t\t       u8 const buf[], size_t len)\n{\n\tunsigned int tmp;\n\tint ret, err;\n\tsize_t i;\n\n\terr = rv3029_eeprom_enter(rv3029);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < len; i++, reg++) {\n\t\tret = regmap_read(rv3029->regmap, reg, &tmp);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (tmp != buf[i]) {\n\t\t\ttmp = buf[i];\n\t\t\tret = regmap_write(rv3029->regmap, reg, tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = rv3029_eeprom_busywait(rv3029);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\terr = rv3029_eeprom_exit(rv3029);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn ret;\n}\n\nstatic int rv3029_eeprom_update_bits(struct rv3029_data *rv3029,\n\t\t\t\t     u8 reg, u8 mask, u8 set)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = rv3029_eeprom_read(rv3029, reg, &buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf &= ~mask;\n\tbuf |= set & mask;\n\tret = rv3029_eeprom_write(rv3029, reg, &buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic irqreturn_t rv3029_handle_irq(int irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tunsigned int flags, controls;\n\tunsigned long events = 0;\n\tint ret;\n\n\trtc_lock(rv3029->rtc);\n\n\tret = regmap_read(rv3029->regmap, RV3029_IRQ_CTRL, &controls);\n\tif (ret) {\n\t\tdev_warn(dev, \"Read IRQ Control Register error %d\\n\", ret);\n\t\trtc_unlock(rv3029->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(rv3029->regmap, RV3029_IRQ_FLAGS, &flags);\n\tif (ret) {\n\t\tdev_warn(dev, \"Read IRQ Flags Register error %d\\n\", ret);\n\t\trtc_unlock(rv3029->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (flags & RV3029_IRQ_FLAGS_AF) {\n\t\tflags &= ~RV3029_IRQ_FLAGS_AF;\n\t\tcontrols &= ~RV3029_IRQ_CTRL_AIE;\n\t\tevents |= RTC_AF;\n\t}\n\n\tif (events) {\n\t\trtc_update_irq(rv3029->rtc, 1, events);\n\t\tregmap_write(rv3029->regmap, RV3029_IRQ_FLAGS, flags);\n\t\tregmap_write(rv3029->regmap, RV3029_IRQ_CTRL, controls);\n\t}\n\trtc_unlock(rv3029->rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rv3029_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tunsigned int sr;\n\tint ret;\n\tu8 regs[RV3029_WATCH_SECTION_LEN] = { 0, };\n\n\tret = regmap_read(rv3029->regmap, RV3029_STATUS, &sr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sr & (RV3029_STATUS_VLOW2 | RV3029_STATUS_PON))\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_read(rv3029->regmap, RV3029_W_SEC, regs,\n\t\t\t       RV3029_WATCH_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttm->tm_sec = bcd2bin(regs[RV3029_W_SEC - RV3029_W_SEC]);\n\ttm->tm_min = bcd2bin(regs[RV3029_W_MINUTES - RV3029_W_SEC]);\n\n\t \n\t{\n\t\tconst u8 _hr = regs[RV3029_W_HOURS - RV3029_W_SEC];\n\n\t\tif (_hr & RV3029_REG_HR_12_24) {\n\t\t\t \n\t\t\ttm->tm_hour = bcd2bin(_hr & 0x1f);\n\t\t\tif (_hr & RV3029_REG_HR_PM)\t \n\t\t\t\ttm->tm_hour += 12;\n\t\t} else  \n\t\t\ttm->tm_hour = bcd2bin(_hr & 0x3f);\n\t}\n\n\ttm->tm_mday = bcd2bin(regs[RV3029_W_DATE - RV3029_W_SEC]);\n\ttm->tm_mon = bcd2bin(regs[RV3029_W_MONTHS - RV3029_W_SEC]) - 1;\n\ttm->tm_year = bcd2bin(regs[RV3029_W_YEARS - RV3029_W_SEC]) + 100;\n\ttm->tm_wday = bcd2bin(regs[RV3029_W_DAYS - RV3029_W_SEC]) - 1;\n\n\treturn 0;\n}\n\nstatic int rv3029_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tstruct rtc_time *const tm = &alarm->time;\n\tunsigned int controls, flags;\n\tint ret;\n\tu8 regs[8];\n\n\tret = regmap_bulk_read(rv3029->regmap, RV3029_A_SC, regs,\n\t\t\t       RV3029_ALARM_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(rv3029->regmap, RV3029_IRQ_CTRL, &controls);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(rv3029->regmap, RV3029_IRQ_FLAGS, &flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttm->tm_sec = bcd2bin(regs[RV3029_A_SC - RV3029_A_SC] & 0x7f);\n\ttm->tm_min = bcd2bin(regs[RV3029_A_MN - RV3029_A_SC] & 0x7f);\n\ttm->tm_hour = bcd2bin(regs[RV3029_A_HR - RV3029_A_SC] & 0x3f);\n\ttm->tm_mday = bcd2bin(regs[RV3029_A_DT - RV3029_A_SC] & 0x3f);\n\ttm->tm_mon = bcd2bin(regs[RV3029_A_MO - RV3029_A_SC] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(regs[RV3029_A_YR - RV3029_A_SC] & 0x7f) + 100;\n\ttm->tm_wday = bcd2bin(regs[RV3029_A_DW - RV3029_A_SC] & 0x07) - 1;\n\n\talarm->enabled = !!(controls & RV3029_IRQ_CTRL_AIE);\n\talarm->pending = (flags & RV3029_IRQ_FLAGS_AF) && alarm->enabled;\n\n\treturn 0;\n}\n\nstatic int rv3029_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(rv3029->regmap, RV3029_IRQ_CTRL,\n\t\t\t\t  RV3029_IRQ_CTRL_AIE,\n\t\t\t\t  enable ? RV3029_IRQ_CTRL_AIE : 0);\n}\n\nstatic int rv3029_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tstruct rtc_time *const tm = &alarm->time;\n\tint ret;\n\tu8 regs[8];\n\n\t \n\tregs[RV3029_A_SC - RV3029_A_SC] = bin2bcd(tm->tm_sec) | RV3029_A_AE_X;\n\tregs[RV3029_A_MN - RV3029_A_SC] = bin2bcd(tm->tm_min) | RV3029_A_AE_X;\n\tregs[RV3029_A_HR - RV3029_A_SC] = (bin2bcd(tm->tm_hour) & 0x3f)\n\t\t| RV3029_A_AE_X;\n\tregs[RV3029_A_DT - RV3029_A_SC] = (bin2bcd(tm->tm_mday) & 0x3f)\n\t\t| RV3029_A_AE_X;\n\tregs[RV3029_A_MO - RV3029_A_SC] = (bin2bcd(tm->tm_mon + 1) & 0x1f)\n\t\t| RV3029_A_AE_X;\n\tregs[RV3029_A_DW - RV3029_A_SC] = (bin2bcd(tm->tm_wday + 1) & 0x7)\n\t\t| RV3029_A_AE_X;\n\tregs[RV3029_A_YR - RV3029_A_SC] = (bin2bcd(tm->tm_year - 100))\n\t\t| RV3029_A_AE_X;\n\n\t \n\tret = regmap_bulk_write(rv3029->regmap, RV3029_A_SC, regs,\n\t\t\t\tRV3029_ALARM_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rv3029_alarm_irq_enable(dev, alarm->enabled);\n}\n\nstatic int rv3029_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tu8 regs[8];\n\tint ret;\n\n\tregs[RV3029_W_SEC - RV3029_W_SEC] = bin2bcd(tm->tm_sec);\n\tregs[RV3029_W_MINUTES - RV3029_W_SEC] = bin2bcd(tm->tm_min);\n\tregs[RV3029_W_HOURS - RV3029_W_SEC] = bin2bcd(tm->tm_hour);\n\tregs[RV3029_W_DATE - RV3029_W_SEC] = bin2bcd(tm->tm_mday);\n\tregs[RV3029_W_MONTHS - RV3029_W_SEC] = bin2bcd(tm->tm_mon + 1);\n\tregs[RV3029_W_DAYS - RV3029_W_SEC] = bin2bcd(tm->tm_wday + 1) & 0x7;\n\tregs[RV3029_W_YEARS - RV3029_W_SEC] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(rv3029->regmap, RV3029_W_SEC, regs,\n\t\t\t\tRV3029_WATCH_SECTION_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(rv3029->regmap, RV3029_STATUS,\n\t\t\t\t  RV3029_STATUS_PON | RV3029_STATUS_VLOW2, 0);\n}\n\nstatic int rv3029_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tunsigned long vl = 0;\n\tint sr, ret = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(rv3029->regmap, RV3029_STATUS, &sr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (sr & RV3029_STATUS_VLOW1)\n\t\t\tvl = RTC_VL_ACCURACY_LOW;\n\n\t\tif (sr & (RV3029_STATUS_VLOW2 | RV3029_STATUS_PON))\n\t\t\tvl |= RTC_VL_DATA_INVALID;\n\n\t\treturn put_user(vl, (unsigned int __user *)arg);\n\n\tcase RTC_VL_CLR:\n\t\treturn regmap_update_bits(rv3029->regmap, RV3029_STATUS,\n\t\t\t\t\t  RV3029_STATUS_VLOW1, 0);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int rv3029_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\treturn regmap_bulk_write(priv, RV3029_RAM_PAGE + offset, val, bytes);\n}\n\nstatic int rv3029_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\treturn regmap_bulk_read(priv, RV3029_RAM_PAGE + offset, val, bytes);\n}\n\nstatic const struct rv3029_trickle_tab_elem {\n\tu32 r;\t\t \n\tu8 conf;\t \n} rv3029_trickle_tab[] = {\n\t{\n\t\t.r\t= 1076,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |\n\t\t\t  RV3029_TRICKLE_20K | RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 1091,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |\n\t\t\t  RV3029_TRICKLE_20K,\n\t}, {\n\t\t.r\t= 1137,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |\n\t\t\t  RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 1154,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K,\n\t}, {\n\t\t.r\t= 1371,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_20K |\n\t\t\t  RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 1395,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_20K,\n\t}, {\n\t\t.r\t= 1472,\n\t\t.conf\t= RV3029_TRICKLE_1K | RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 1500,\n\t\t.conf\t= RV3029_TRICKLE_1K,\n\t}, {\n\t\t.r\t= 3810,\n\t\t.conf\t= RV3029_TRICKLE_5K | RV3029_TRICKLE_20K |\n\t\t\t  RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 4000,\n\t\t.conf\t= RV3029_TRICKLE_5K | RV3029_TRICKLE_20K,\n\t}, {\n\t\t.r\t= 4706,\n\t\t.conf\t= RV3029_TRICKLE_5K | RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 5000,\n\t\t.conf\t= RV3029_TRICKLE_5K,\n\t}, {\n\t\t.r\t= 16000,\n\t\t.conf\t= RV3029_TRICKLE_20K | RV3029_TRICKLE_80K,\n\t}, {\n\t\t.r\t= 20000,\n\t\t.conf\t= RV3029_TRICKLE_20K,\n\t}, {\n\t\t.r\t= 80000,\n\t\t.conf\t= RV3029_TRICKLE_80K,\n\t},\n};\n\nstatic void rv3029_trickle_config(struct device *dev)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tstruct device_node *of_node = dev->of_node;\n\tconst struct rv3029_trickle_tab_elem *elem;\n\tint i, err;\n\tu32 ohms;\n\tu8 trickle_set_bits;\n\n\tif (!of_node)\n\t\treturn;\n\n\t \n\terr = of_property_read_u32(of_node, \"trickle-resistor-ohms\", &ohms);\n\tif (err) {\n\t\t \n\t\ttrickle_set_bits = 0;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(rv3029_trickle_tab); i++) {\n\t\t\telem = &rv3029_trickle_tab[i];\n\t\t\tif (elem->r >= ohms)\n\t\t\t\tbreak;\n\t\t}\n\t\ttrickle_set_bits = elem->conf;\n\t\tdev_info(dev,\n\t\t\t \"Trickle charger enabled at %d ohms resistance.\\n\",\n\t\t\t elem->r);\n\t}\n\terr = rv3029_eeprom_update_bits(rv3029, RV3029_CONTROL_E2P_EECTRL,\n\t\t\t\t\tRV3029_TRICKLE_MASK,\n\t\t\t\t\ttrickle_set_bits);\n\tif (err < 0)\n\t\tdev_err(dev, \"Failed to update trickle charger config\\n\");\n}\n\n#ifdef CONFIG_RTC_DRV_RV3029_HWMON\n\nstatic int rv3029_read_temp(struct rv3029_data *rv3029, int *temp_mC)\n{\n\tunsigned int temp;\n\tint ret;\n\n\tret = regmap_read(rv3029->regmap, RV3029_TEMP_PAGE, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*temp_mC = ((int)temp - 60) * 1000;\n\n\treturn 0;\n}\n\nstatic ssize_t rv3029_hwmon_show_temp(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tint ret, temp_mC;\n\n\tret = rv3029_read_temp(rv3029, &temp_mC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", temp_mC);\n}\n\nstatic ssize_t rv3029_hwmon_set_update_interval(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf,\n\t\t\t\t\t\tsize_t count)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tunsigned int th_set_bits = 0;\n\tunsigned long interval_ms;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &interval_ms);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (interval_ms != 0) {\n\t\tth_set_bits |= RV3029_EECTRL_THE;\n\t\tif (interval_ms >= 16000)\n\t\t\tth_set_bits |= RV3029_EECTRL_THP;\n\t}\n\tret = rv3029_eeprom_update_bits(rv3029, RV3029_CONTROL_E2P_EECTRL,\n\t\t\t\t\tRV3029_EECTRL_THE | RV3029_EECTRL_THP,\n\t\t\t\t\tth_set_bits);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t rv3029_hwmon_show_update_interval(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tint ret, interval_ms;\n\tu8 eectrl;\n\n\tret = rv3029_eeprom_read(rv3029, RV3029_CONTROL_E2P_EECTRL,\n\t\t\t\t &eectrl, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (eectrl & RV3029_EECTRL_THE) {\n\t\tif (eectrl & RV3029_EECTRL_THP)\n\t\t\tinterval_ms = 16000;\n\t\telse\n\t\t\tinterval_ms = 1000;\n\t} else {\n\t\tinterval_ms = 0;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", interval_ms);\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, rv3029_hwmon_show_temp,\n\t\t\t  NULL, 0);\nstatic SENSOR_DEVICE_ATTR(update_interval, S_IWUSR | S_IRUGO,\n\t\t\t  rv3029_hwmon_show_update_interval,\n\t\t\t  rv3029_hwmon_set_update_interval, 0);\n\nstatic struct attribute *rv3029_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_update_interval.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(rv3029_hwmon);\n\nstatic void rv3029_hwmon_register(struct device *dev, const char *name)\n{\n\tstruct rv3029_data *rv3029 = dev_get_drvdata(dev);\n\tstruct device *hwmon_dev;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(dev, name, rv3029,\n\t\t\t\t\t\t\t   rv3029_hwmon_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tdev_warn(dev, \"unable to register hwmon device %ld\\n\",\n\t\t\t PTR_ERR(hwmon_dev));\n\t}\n}\n\n#else  \n\nstatic void rv3029_hwmon_register(struct device *dev, const char *name)\n{\n}\n\n#endif  \n\nstatic const struct rtc_class_ops rv3029_rtc_ops = {\n\t.read_time\t= rv3029_read_time,\n\t.set_time\t= rv3029_set_time,\n\t.ioctl\t\t= rv3029_ioctl,\n\t.read_alarm\t= rv3029_read_alarm,\n\t.set_alarm\t= rv3029_set_alarm,\n\t.alarm_irq_enable = rv3029_alarm_irq_enable,\n};\n\nstatic int rv3029_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t\tconst char *name)\n{\n\tstruct rv3029_data *rv3029;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"rv3029_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = RV3029_RAM_SECTION_LEN,\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.reg_read = rv3029_nvram_read,\n\t\t.reg_write = rv3029_nvram_write,\n\t};\n\tint rc = 0;\n\n\trv3029 = devm_kzalloc(dev, sizeof(*rv3029), GFP_KERNEL);\n\tif (!rv3029)\n\t\treturn -ENOMEM;\n\n\trv3029->regmap = regmap;\n\trv3029->irq = irq;\n\trv3029->dev = dev;\n\tdev_set_drvdata(dev, rv3029);\n\n\trv3029_trickle_config(dev);\n\trv3029_hwmon_register(dev, name);\n\n\trv3029->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rv3029->rtc))\n\t\treturn PTR_ERR(rv3029->rtc);\n\n\tif (rv3029->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(dev))\n\t\t\tirqflags = 0;\n\n\t\trc = devm_request_threaded_irq(dev, rv3029->irq,\n\t\t\t\t\t       NULL, rv3029_handle_irq,\n\t\t\t\t\t       irqflags | IRQF_ONESHOT,\n\t\t\t\t\t       \"rv3029\", dev);\n\t\tif (rc) {\n\t\t\tdev_warn(dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\trv3029->irq = 0;\n\t\t}\n\t}\n\tif (!rv3029->irq)\n\t\tclear_bit(RTC_FEATURE_ALARM, rv3029->rtc->features);\n\n\trv3029->rtc->ops = &rv3029_rtc_ops;\n\trv3029->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trv3029->rtc->range_max = RTC_TIMESTAMP_END_2079;\n\n\trc = devm_rtc_register_device(rv3029->rtc);\n\tif (rc)\n\t\treturn rc;\n\n\tnvmem_cfg.priv = rv3029->regmap;\n\tdevm_rtc_nvmem_register(rv3029->rtc, &nvmem_cfg);\n\n\treturn 0;\n}\n\nstatic const struct regmap_range rv3029_holes_range[] = {\n\tregmap_reg_range(0x05, 0x07),\n\tregmap_reg_range(0x0f, 0x0f),\n\tregmap_reg_range(0x17, 0x17),\n\tregmap_reg_range(0x1a, 0x1f),\n\tregmap_reg_range(0x21, 0x27),\n\tregmap_reg_range(0x34, 0x37),\n};\n\nstatic const struct regmap_access_table rv3029_regs = {\n\t.no_ranges =\trv3029_holes_range,\n\t.n_no_ranges =\tARRAY_SIZE(rv3029_holes_range),\n};\n\nstatic const struct regmap_config config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.rd_table = &rv3029_regs,\n\t.wr_table = &rv3029_regs,\n\t.max_register = 0x3f,\n};\n\n#if IS_ENABLED(CONFIG_I2C)\n\nstatic int rv3029_i2c_probe(struct i2c_client *client)\n{\n\tstruct regmap *regmap;\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE)) {\n\t\tdev_err(&client->dev, \"Adapter does not support SMBUS_I2C_BLOCK or SMBUS_I2C_BYTE\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rv3029_probe(&client->dev, regmap, client->irq, client->name);\n}\n\nstatic const struct i2c_device_id rv3029_id[] = {\n\t{ \"rv3029\", 0 },\n\t{ \"rv3029c2\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rv3029_id);\n\nstatic const __maybe_unused struct of_device_id rv3029_of_match[] = {\n\t{ .compatible = \"microcrystal,rv3029\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rv3029_of_match);\n\nstatic struct i2c_driver rv3029_driver = {\n\t.driver = {\n\t\t.name = \"rv3029\",\n\t\t.of_match_table = of_match_ptr(rv3029_of_match),\n\t},\n\t.probe\t\t= rv3029_i2c_probe,\n\t.id_table\t= rv3029_id,\n};\n\nstatic int __init rv3029_register_driver(void)\n{\n\treturn i2c_add_driver(&rv3029_driver);\n}\n\nstatic void rv3029_unregister_driver(void)\n{\n\ti2c_del_driver(&rv3029_driver);\n}\n\n#else\n\nstatic int __init rv3029_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void rv3029_unregister_driver(void)\n{\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_SPI_MASTER)\n\nstatic int rv3049_probe(struct spi_device *spi)\n{\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init_spi(spi, &config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rv3029_probe(&spi->dev, regmap, spi->irq, \"rv3049\");\n}\n\nstatic struct spi_driver rv3049_driver = {\n\t.driver = {\n\t\t.name    = \"rv3049\",\n\t},\n\t.probe   = rv3049_probe,\n};\n\nstatic int __init rv3049_register_driver(void)\n{\n\treturn spi_register_driver(&rv3049_driver);\n}\n\nstatic void __exit rv3049_unregister_driver(void)\n{\n\tspi_unregister_driver(&rv3049_driver);\n}\n\n#else\n\nstatic int __init rv3049_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void __exit rv3049_unregister_driver(void)\n{\n}\n\n#endif\n\nstatic int __init rv30x9_init(void)\n{\n\tint ret;\n\n\tret = rv3029_register_driver();\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv3049_register_driver();\n\tif (ret)\n\t\trv3029_unregister_driver();\n\n\treturn ret;\n}\nmodule_init(rv30x9_init)\n\nstatic void __exit rv30x9_exit(void)\n{\n\trv3049_unregister_driver();\n\trv3029_unregister_driver();\n}\nmodule_exit(rv30x9_exit)\n\nMODULE_AUTHOR(\"Gregory Hermant <gregory.hermant@calao-systems.com>\");\nMODULE_AUTHOR(\"Michael Buesch <m@bues.ch>\");\nMODULE_DESCRIPTION(\"Micro Crystal RV3029/RV3049 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:rv3049\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}