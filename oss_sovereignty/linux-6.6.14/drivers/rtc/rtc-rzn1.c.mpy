{
  "module_name": "rtc-rzn1.c",
  "hash_id": "9d3404756f238ec17e2466ccd618fe614d975d675e20d286cf076b9554a6654b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rzn1.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rtc.h>\n\n#define RZN1_RTC_CTL0 0x00\n#define   RZN1_RTC_CTL0_SLSB_SUBU 0\n#define   RZN1_RTC_CTL0_SLSB_SCMP BIT(4)\n#define   RZN1_RTC_CTL0_AMPM BIT(5)\n#define   RZN1_RTC_CTL0_CE BIT(7)\n\n#define RZN1_RTC_CTL1 0x04\n#define   RZN1_RTC_CTL1_ALME BIT(4)\n\n#define RZN1_RTC_CTL2 0x08\n#define   RZN1_RTC_CTL2_WAIT BIT(0)\n#define   RZN1_RTC_CTL2_WST BIT(1)\n#define   RZN1_RTC_CTL2_WUST BIT(5)\n#define   RZN1_RTC_CTL2_STOPPED (RZN1_RTC_CTL2_WAIT | RZN1_RTC_CTL2_WST)\n\n#define RZN1_RTC_SEC 0x14\n#define RZN1_RTC_MIN 0x18\n#define RZN1_RTC_HOUR 0x1c\n#define RZN1_RTC_WEEK 0x20\n#define RZN1_RTC_DAY 0x24\n#define RZN1_RTC_MONTH 0x28\n#define RZN1_RTC_YEAR 0x2c\n\n#define RZN1_RTC_SUBU 0x38\n#define   RZN1_RTC_SUBU_DEV BIT(7)\n#define   RZN1_RTC_SUBU_DECR BIT(6)\n\n#define RZN1_RTC_ALM 0x40\n#define RZN1_RTC_ALH 0x44\n#define RZN1_RTC_ALW 0x48\n\n#define RZN1_RTC_SECC 0x4c\n#define RZN1_RTC_MINC 0x50\n#define RZN1_RTC_HOURC 0x54\n#define RZN1_RTC_WEEKC 0x58\n#define RZN1_RTC_DAYC 0x5c\n#define RZN1_RTC_MONTHC 0x60\n#define RZN1_RTC_YEARC 0x64\n\nstruct rzn1_rtc {\n\tstruct rtc_device *rtcdev;\n\tvoid __iomem *base;\n};\n\nstatic void rzn1_rtc_get_time_snapshot(struct rzn1_rtc *rtc, struct rtc_time *tm)\n{\n\ttm->tm_sec = readl(rtc->base + RZN1_RTC_SECC);\n\ttm->tm_min = readl(rtc->base + RZN1_RTC_MINC);\n\ttm->tm_hour = readl(rtc->base + RZN1_RTC_HOURC);\n\ttm->tm_wday = readl(rtc->base + RZN1_RTC_WEEKC);\n\ttm->tm_mday = readl(rtc->base + RZN1_RTC_DAYC);\n\ttm->tm_mon = readl(rtc->base + RZN1_RTC_MONTHC);\n\ttm->tm_year = readl(rtc->base + RZN1_RTC_YEARC);\n}\n\nstatic unsigned int rzn1_rtc_tm_to_wday(struct rtc_time *tm)\n{\n\ttime64_t time;\n\tunsigned int days;\n\tu32 secs;\n\n\ttime = rtc_tm_to_time64(tm);\n\tdays = div_s64_rem(time, 86400, &secs);\n\n\t \n\treturn (days + 4) % 7;\n}\n\nstatic int rzn1_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tu32 val, secs;\n\n\t \n\tval = readl(rtc->base + RZN1_RTC_CTL2);\n\tif (val & RZN1_RTC_CTL2_STOPPED)\n\t\treturn -EINVAL;\n\n\trzn1_rtc_get_time_snapshot(rtc, tm);\n\tsecs = readl(rtc->base + RZN1_RTC_SECC);\n\tif (tm->tm_sec != secs)\n\t\trzn1_rtc_get_time_snapshot(rtc, tm);\n\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_wday = bcd2bin(tm->tm_wday);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon);\n\ttm->tm_year = bcd2bin(tm->tm_year);\n\n\treturn 0;\n}\n\nstatic int rzn1_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tu32 val;\n\tint ret;\n\n\ttm->tm_sec = bin2bcd(tm->tm_sec);\n\ttm->tm_min = bin2bcd(tm->tm_min);\n\ttm->tm_hour = bin2bcd(tm->tm_hour);\n\ttm->tm_wday = bin2bcd(rzn1_rtc_tm_to_wday(tm));\n\ttm->tm_mday = bin2bcd(tm->tm_mday);\n\ttm->tm_mon = bin2bcd(tm->tm_mon);\n\ttm->tm_year = bin2bcd(tm->tm_year);\n\n\tval = readl(rtc->base + RZN1_RTC_CTL2);\n\tif (!(val & RZN1_RTC_CTL2_STOPPED)) {\n\t\t \n\t\twritel(RZN1_RTC_CTL2_WAIT, rtc->base + RZN1_RTC_CTL2);\n\n\t\t \n\t\tusleep_range(61, 100);\n\t\tret = readl_poll_timeout(rtc->base + RZN1_RTC_CTL2, val,\n\t\t\t\t\t val & RZN1_RTC_CTL2_WST, 0, 100);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twritel(tm->tm_sec, rtc->base + RZN1_RTC_SEC);\n\twritel(tm->tm_min, rtc->base + RZN1_RTC_MIN);\n\twritel(tm->tm_hour, rtc->base + RZN1_RTC_HOUR);\n\twritel(tm->tm_wday, rtc->base + RZN1_RTC_WEEK);\n\twritel(tm->tm_mday, rtc->base + RZN1_RTC_DAY);\n\twritel(tm->tm_mon, rtc->base + RZN1_RTC_MONTH);\n\twritel(tm->tm_year, rtc->base + RZN1_RTC_YEAR);\n\twritel(0, rtc->base + RZN1_RTC_CTL2);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rzn1_rtc_alarm_irq(int irq, void *dev_id)\n{\n\tstruct rzn1_rtc *rtc = dev_id;\n\n\trtc_update_irq(rtc->rtcdev, 1, RTC_AF | RTC_IRQF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rzn1_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tu32 ctl1 = readl(rtc->base + RZN1_RTC_CTL1);\n\n\tif (enable)\n\t\tctl1 |= RZN1_RTC_CTL1_ALME;\n\telse\n\t\tctl1 &= ~RZN1_RTC_CTL1_ALME;\n\n\twritel(ctl1, rtc->base + RZN1_RTC_CTL1);\n\n\treturn 0;\n}\n\nstatic int rzn1_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned int min, hour, wday, delta_days;\n\ttime64_t alarm;\n\tu32 ctl1;\n\tint ret;\n\n\tret = rzn1_rtc_read_time(dev, tm);\n\tif (ret)\n\t\treturn ret;\n\n\tmin = readl(rtc->base + RZN1_RTC_ALM);\n\thour = readl(rtc->base + RZN1_RTC_ALH);\n\twday = readl(rtc->base + RZN1_RTC_ALW);\n\n\ttm->tm_sec = 0;\n\ttm->tm_min = bcd2bin(min);\n\ttm->tm_hour = bcd2bin(hour);\n\tdelta_days = ((fls(wday) - 1) - tm->tm_wday + 7) % 7;\n\ttm->tm_wday = fls(wday) - 1;\n\n\tif (delta_days) {\n\t\talarm = rtc_tm_to_time64(tm) + (delta_days * 86400);\n\t\trtc_time64_to_tm(alarm, tm);\n\t}\n\n\tctl1 = readl(rtc->base + RZN1_RTC_CTL1);\n\talrm->enabled = !!(ctl1 & RZN1_RTC_CTL1_ALME);\n\n\treturn 0;\n}\n\nstatic int rzn1_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time, tm_now;\n\tunsigned long alarm, farest;\n\tunsigned int days_ahead, wday;\n\tint ret;\n\n\tret = rzn1_rtc_read_time(dev, &tm_now);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfarest = rtc_tm_to_time64(&tm_now) + rtc->rtcdev->alarm_offset_max;\n\talarm = rtc_tm_to_time64(tm);\n\tif (time_after(alarm, farest))\n\t\treturn -ERANGE;\n\n\t \n\tdays_ahead = tm->tm_mday - tm_now.tm_mday;\n\twday = (tm_now.tm_wday + days_ahead) % 7;\n\n\twritel(bin2bcd(tm->tm_min), rtc->base + RZN1_RTC_ALM);\n\twritel(bin2bcd(tm->tm_hour), rtc->base + RZN1_RTC_ALH);\n\twritel(BIT(wday), rtc->base + RZN1_RTC_ALW);\n\n\trzn1_rtc_alarm_irq_enable(dev, alrm->enabled);\n\n\treturn 0;\n}\n\nstatic int rzn1_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int ppb_per_step;\n\tbool subtract;\n\tu32 val;\n\n\tval = readl(rtc->base + RZN1_RTC_SUBU);\n\tppb_per_step = val & RZN1_RTC_SUBU_DEV ? 1017 : 3051;\n\tsubtract = val & RZN1_RTC_SUBU_DECR;\n\tval &= 0x3F;\n\n\tif (!val)\n\t\t*offset = 0;\n\telse if (subtract)\n\t\t*offset = -(((~val) & 0x3F) + 1) * ppb_per_step;\n\telse\n\t\t*offset = (val - 1) * ppb_per_step;\n\n\treturn 0;\n}\n\nstatic int rzn1_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct rzn1_rtc *rtc = dev_get_drvdata(dev);\n\tint stepsh, stepsl, steps;\n\tu32 subu = 0, ctl2;\n\tint ret;\n\n\t \n\tstepsh = DIV_ROUND_CLOSEST(offset, 1017);\n\tstepsl = DIV_ROUND_CLOSEST(offset, 3051);\n\n\tif (stepsh >= -0x3E && stepsh <= 0x3E) {\n\t\t \n\t\tsteps = stepsh;\n\t\tsubu |= RZN1_RTC_SUBU_DEV;\n\t} else if (stepsl >= -0x3E && stepsl <= 0x3E) {\n\t\t \n\t\tsteps = stepsl;\n\t} else {\n\t\treturn -ERANGE;\n\t}\n\n\tif (!steps)\n\t\treturn 0;\n\n\tif (steps > 0) {\n\t\tsubu |= steps + 1;\n\t} else {\n\t\tsubu |= RZN1_RTC_SUBU_DECR;\n\t\tsubu |= (~(-steps - 1)) & 0x3F;\n\t}\n\n\tret = readl_poll_timeout(rtc->base + RZN1_RTC_CTL2, ctl2,\n\t\t\t\t !(ctl2 & RZN1_RTC_CTL2_WUST), 100, 2000000);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(subu, rtc->base + RZN1_RTC_SUBU);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops rzn1_rtc_ops = {\n\t.read_time = rzn1_rtc_read_time,\n\t.set_time = rzn1_rtc_set_time,\n\t.read_alarm = rzn1_rtc_read_alarm,\n\t.set_alarm = rzn1_rtc_set_alarm,\n\t.alarm_irq_enable = rzn1_rtc_alarm_irq_enable,\n\t.read_offset = rzn1_rtc_read_offset,\n\t.set_offset = rzn1_rtc_set_offset,\n};\n\nstatic int rzn1_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rzn1_rtc *rtc;\n\tint alarm_irq;\n\tint ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rtc->base), \"Missing reg\\n\");\n\n\talarm_irq = platform_get_irq(pdev, 0);\n\tif (alarm_irq < 0)\n\t\treturn alarm_irq;\n\n\trtc->rtcdev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtcdev))\n\t\treturn PTR_ERR(rtc->rtcdev);\n\n\trtc->rtcdev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->rtcdev->range_max = RTC_TIMESTAMP_END_2099;\n\trtc->rtcdev->alarm_offset_max = 7 * 86400;\n\trtc->rtcdev->ops = &rzn1_rtc_ops;\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->rtcdev->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->rtcdev->features);\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twritel(RZN1_RTC_CTL0_CE | RZN1_RTC_CTL0_AMPM | RZN1_RTC_CTL0_SLSB_SUBU,\n\t       rtc->base + RZN1_RTC_CTL0);\n\n\t \n\twritel(0, rtc->base + RZN1_RTC_CTL1);\n\n\tret = devm_request_irq(&pdev->dev, alarm_irq, rzn1_rtc_alarm_irq, 0,\n\t\t\t       dev_name(&pdev->dev), rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"RTC timer interrupt not available\\n\");\n\t\tgoto dis_runtime_pm;\n\t}\n\n\tret = devm_rtc_register_device(rtc->rtcdev);\n\tif (ret)\n\t\tgoto dis_runtime_pm;\n\n\treturn 0;\n\ndis_runtime_pm:\n\tpm_runtime_put(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void rzn1_rtc_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put(&pdev->dev);\n}\n\nstatic const struct of_device_id rzn1_rtc_of_match[] = {\n\t{ .compatible\t= \"renesas,rzn1-rtc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rzn1_rtc_of_match);\n\nstatic struct platform_driver rzn1_rtc_driver = {\n\t.probe = rzn1_rtc_probe,\n\t.remove_new = rzn1_rtc_remove,\n\t.driver = {\n\t\t.name\t= \"rzn1-rtc\",\n\t\t.of_match_table = rzn1_rtc_of_match,\n\t},\n};\nmodule_platform_driver(rzn1_rtc_driver);\n\nMODULE_AUTHOR(\"Michel Pollet <Michel.Pollet@bp.renesas.com\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com\");\nMODULE_DESCRIPTION(\"RZ/N1 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}