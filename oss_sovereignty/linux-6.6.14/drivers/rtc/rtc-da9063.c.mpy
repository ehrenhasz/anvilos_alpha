{
  "module_name": "rtc-da9063.c",
  "hash_id": "d5634184c5f1c25058963430b2918858ad2b3f65c2f8a1bf751fe44ff1a570fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-da9063.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/da9062/registers.h>\n#include <linux/mfd/da9063/registers.h>\n#include <linux/mfd/da9063/core.h>\n\n#define YEARS_TO_DA9063(year)\t\t((year) - 100)\n#define MONTHS_TO_DA9063(month)\t\t((month) + 1)\n#define YEARS_FROM_DA9063(year)\t\t((year) + 100)\n#define MONTHS_FROM_DA9063(month)\t((month) - 1)\n\nenum {\n\tRTC_SEC\t= 0,\n\tRTC_MIN\t= 1,\n\tRTC_HOUR = 2,\n\tRTC_DAY\t= 3,\n\tRTC_MONTH = 4,\n\tRTC_YEAR = 5,\n\tRTC_DATA_LEN\n};\n\nstruct da9063_compatible_rtc_regmap {\n\t \n\tint rtc_enable_reg;\n\tint rtc_enable_32k_crystal_reg;\n\tint rtc_alarm_secs_reg;\n\tint rtc_alarm_year_reg;\n\tint rtc_count_secs_reg;\n\tint rtc_count_year_reg;\n\tint rtc_event_reg;\n\t \n\tint rtc_enable_mask;\n\tint rtc_crystal_mask;\n\tint rtc_event_alarm_mask;\n\tint rtc_alarm_on_mask;\n\tint rtc_alarm_status_mask;\n\tint rtc_tick_on_mask;\n\tint rtc_ready_to_read_mask;\n\tint rtc_count_sec_mask;\n\tint rtc_count_min_mask;\n\tint rtc_count_hour_mask;\n\tint rtc_count_day_mask;\n\tint rtc_count_month_mask;\n\tint rtc_count_year_mask;\n\t \n\tint rtc_data_start;\n\tint rtc_alarm_len;\n};\n\nstruct da9063_compatible_rtc {\n\tstruct rtc_device *rtc_dev;\n\tstruct rtc_time alarm_time;\n\tstruct regmap *regmap;\n\tconst struct da9063_compatible_rtc_regmap *config;\n\tbool rtc_sync;\n};\n\nstatic const struct da9063_compatible_rtc_regmap da9063_ad_regs = {\n\t \n\t.rtc_enable_reg             = DA9063_REG_CONTROL_E,\n\t.rtc_alarm_secs_reg         = DA9063_AD_REG_ALARM_MI,\n\t.rtc_alarm_year_reg         = DA9063_AD_REG_ALARM_Y,\n\t.rtc_count_secs_reg         = DA9063_REG_COUNT_S,\n\t.rtc_count_year_reg         = DA9063_REG_COUNT_Y,\n\t.rtc_event_reg              = DA9063_REG_EVENT_A,\n\t \n\t.rtc_enable_mask            = DA9063_RTC_EN,\n\t.rtc_crystal_mask           = DA9063_CRYSTAL,\n\t.rtc_enable_32k_crystal_reg = DA9063_REG_EN_32K,\n\t.rtc_event_alarm_mask       = DA9063_E_ALARM,\n\t.rtc_alarm_on_mask          = DA9063_ALARM_ON,\n\t.rtc_alarm_status_mask      = DA9063_ALARM_STATUS_ALARM |\n\t\t\t\t      DA9063_ALARM_STATUS_TICK,\n\t.rtc_tick_on_mask           = DA9063_TICK_ON,\n\t.rtc_ready_to_read_mask     = DA9063_RTC_READ,\n\t.rtc_count_sec_mask         = DA9063_COUNT_SEC_MASK,\n\t.rtc_count_min_mask         = DA9063_COUNT_MIN_MASK,\n\t.rtc_count_hour_mask        = DA9063_COUNT_HOUR_MASK,\n\t.rtc_count_day_mask         = DA9063_COUNT_DAY_MASK,\n\t.rtc_count_month_mask       = DA9063_COUNT_MONTH_MASK,\n\t.rtc_count_year_mask        = DA9063_COUNT_YEAR_MASK,\n\t \n\t.rtc_data_start             = RTC_MIN,\n\t.rtc_alarm_len              = RTC_DATA_LEN - 1,\n};\n\nstatic const struct da9063_compatible_rtc_regmap da9063_bb_regs = {\n\t \n\t.rtc_enable_reg             = DA9063_REG_CONTROL_E,\n\t.rtc_alarm_secs_reg         = DA9063_BB_REG_ALARM_S,\n\t.rtc_alarm_year_reg         = DA9063_BB_REG_ALARM_Y,\n\t.rtc_count_secs_reg         = DA9063_REG_COUNT_S,\n\t.rtc_count_year_reg         = DA9063_REG_COUNT_Y,\n\t.rtc_event_reg              = DA9063_REG_EVENT_A,\n\t \n\t.rtc_enable_mask            = DA9063_RTC_EN,\n\t.rtc_crystal_mask           = DA9063_CRYSTAL,\n\t.rtc_enable_32k_crystal_reg = DA9063_REG_EN_32K,\n\t.rtc_event_alarm_mask       = DA9063_E_ALARM,\n\t.rtc_alarm_on_mask          = DA9063_ALARM_ON,\n\t.rtc_alarm_status_mask      = DA9063_ALARM_STATUS_ALARM |\n\t\t\t\t      DA9063_ALARM_STATUS_TICK,\n\t.rtc_tick_on_mask           = DA9063_TICK_ON,\n\t.rtc_ready_to_read_mask     = DA9063_RTC_READ,\n\t.rtc_count_sec_mask         = DA9063_COUNT_SEC_MASK,\n\t.rtc_count_min_mask         = DA9063_COUNT_MIN_MASK,\n\t.rtc_count_hour_mask        = DA9063_COUNT_HOUR_MASK,\n\t.rtc_count_day_mask         = DA9063_COUNT_DAY_MASK,\n\t.rtc_count_month_mask       = DA9063_COUNT_MONTH_MASK,\n\t.rtc_count_year_mask        = DA9063_COUNT_YEAR_MASK,\n\t \n\t.rtc_data_start             = RTC_SEC,\n\t.rtc_alarm_len              = RTC_DATA_LEN,\n};\n\nstatic const struct da9063_compatible_rtc_regmap da9062_aa_regs = {\n\t \n\t.rtc_enable_reg             = DA9062AA_CONTROL_E,\n\t.rtc_alarm_secs_reg         = DA9062AA_ALARM_S,\n\t.rtc_alarm_year_reg         = DA9062AA_ALARM_Y,\n\t.rtc_count_secs_reg         = DA9062AA_COUNT_S,\n\t.rtc_count_year_reg         = DA9062AA_COUNT_Y,\n\t.rtc_event_reg              = DA9062AA_EVENT_A,\n\t \n\t.rtc_enable_mask            = DA9062AA_RTC_EN_MASK,\n\t.rtc_crystal_mask           = DA9062AA_CRYSTAL_MASK,\n\t.rtc_enable_32k_crystal_reg = DA9062AA_EN_32K,\n\t.rtc_event_alarm_mask       = DA9062AA_M_ALARM_MASK,\n\t.rtc_alarm_on_mask          = DA9062AA_ALARM_ON_MASK,\n\t.rtc_alarm_status_mask      = (0x02 << 6),\n\t.rtc_tick_on_mask           = DA9062AA_TICK_ON_MASK,\n\t.rtc_ready_to_read_mask     = DA9062AA_RTC_READ_MASK,\n\t.rtc_count_sec_mask         = DA9062AA_COUNT_SEC_MASK,\n\t.rtc_count_min_mask         = DA9062AA_COUNT_MIN_MASK,\n\t.rtc_count_hour_mask        = DA9062AA_COUNT_HOUR_MASK,\n\t.rtc_count_day_mask         = DA9062AA_COUNT_DAY_MASK,\n\t.rtc_count_month_mask       = DA9062AA_COUNT_MONTH_MASK,\n\t.rtc_count_year_mask        = DA9062AA_COUNT_YEAR_MASK,\n\t \n\t.rtc_data_start             = RTC_SEC,\n\t.rtc_alarm_len              = RTC_DATA_LEN,\n};\n\nstatic const struct of_device_id da9063_compatible_reg_id_table[] = {\n\t{ .compatible = \"dlg,da9063-rtc\", .data = &da9063_bb_regs },\n\t{ .compatible = \"dlg,da9062-rtc\", .data = &da9062_aa_regs },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, da9063_compatible_reg_id_table);\n\nstatic void da9063_data_to_tm(u8 *data, struct rtc_time *tm,\n\t\t\t      struct da9063_compatible_rtc *rtc)\n{\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\n\ttm->tm_sec  = data[RTC_SEC]  & config->rtc_count_sec_mask;\n\ttm->tm_min  = data[RTC_MIN]  & config->rtc_count_min_mask;\n\ttm->tm_hour = data[RTC_HOUR] & config->rtc_count_hour_mask;\n\ttm->tm_mday = data[RTC_DAY]  & config->rtc_count_day_mask;\n\ttm->tm_mon  = MONTHS_FROM_DA9063(data[RTC_MONTH] &\n\t\t\t\t\t config->rtc_count_month_mask);\n\ttm->tm_year = YEARS_FROM_DA9063(data[RTC_YEAR] &\n\t\t\t\t\tconfig->rtc_count_year_mask);\n}\n\nstatic void da9063_tm_to_data(struct rtc_time *tm, u8 *data,\n\t\t\t      struct da9063_compatible_rtc *rtc)\n{\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\n\tdata[RTC_SEC]   = tm->tm_sec & config->rtc_count_sec_mask;\n\tdata[RTC_MIN]   = tm->tm_min & config->rtc_count_min_mask;\n\tdata[RTC_HOUR]  = tm->tm_hour & config->rtc_count_hour_mask;\n\tdata[RTC_DAY]   = tm->tm_mday & config->rtc_count_day_mask;\n\tdata[RTC_MONTH] = MONTHS_TO_DA9063(tm->tm_mon) &\n\t\t\t\tconfig->rtc_count_month_mask;\n\tdata[RTC_YEAR]  = YEARS_TO_DA9063(tm->tm_year) &\n\t\t\t\tconfig->rtc_count_year_mask;\n}\n\nstatic int da9063_rtc_stop_alarm(struct device *dev)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\n\treturn regmap_update_bits(rtc->regmap,\n\t\t\t\t  config->rtc_alarm_year_reg,\n\t\t\t\t  config->rtc_alarm_on_mask,\n\t\t\t\t  0);\n}\n\nstatic int da9063_rtc_start_alarm(struct device *dev)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\n\treturn regmap_update_bits(rtc->regmap,\n\t\t\t\t  config->rtc_alarm_year_reg,\n\t\t\t\t  config->rtc_alarm_on_mask,\n\t\t\t\t  config->rtc_alarm_on_mask);\n}\n\nstatic int da9063_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\tunsigned long tm_secs;\n\tunsigned long al_secs;\n\tu8 data[RTC_DATA_LEN];\n\tint ret;\n\n\tret = regmap_bulk_read(rtc->regmap,\n\t\t\t       config->rtc_count_secs_reg,\n\t\t\t       data, RTC_DATA_LEN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read RTC time data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!(data[RTC_SEC] & config->rtc_ready_to_read_mask)) {\n\t\tdev_dbg(dev, \"RTC not yet ready to be read by the host\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tda9063_data_to_tm(data, tm, rtc);\n\n\ttm_secs = rtc_tm_to_time64(tm);\n\tal_secs = rtc_tm_to_time64(&rtc->alarm_time);\n\n\t \n\tif (rtc->rtc_sync && al_secs - tm_secs == 1)\n\t\tmemcpy(tm, &rtc->alarm_time, sizeof(struct rtc_time));\n\telse\n\t\trtc->rtc_sync = false;\n\n\treturn 0;\n}\n\nstatic int da9063_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\tu8 data[RTC_DATA_LEN];\n\tint ret;\n\n\tda9063_tm_to_data(tm, data, rtc);\n\tret = regmap_bulk_write(rtc->regmap,\n\t\t\t\tconfig->rtc_count_secs_reg,\n\t\t\t\tdata, RTC_DATA_LEN);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set RTC time data: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int da9063_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\tu8 data[RTC_DATA_LEN];\n\tint ret;\n\tunsigned int val;\n\n\tdata[RTC_SEC] = 0;\n\tret = regmap_bulk_read(rtc->regmap,\n\t\t\t       config->rtc_alarm_secs_reg,\n\t\t\t       &data[config->rtc_data_start],\n\t\t\t       config->rtc_alarm_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tda9063_data_to_tm(data, &alrm->time, rtc);\n\n\talrm->enabled = !!(data[RTC_YEAR] & config->rtc_alarm_on_mask);\n\n\tret = regmap_read(rtc->regmap,\n\t\t\t  config->rtc_event_reg,\n\t\t\t  &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & config->rtc_event_alarm_mask)\n\t\talrm->pending = 1;\n\telse\n\t\talrm->pending = 0;\n\n\treturn 0;\n}\n\nstatic int da9063_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\tu8 data[RTC_DATA_LEN];\n\tint ret;\n\n\tda9063_tm_to_data(&alrm->time, data, rtc);\n\n\tret = da9063_rtc_stop_alarm(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to stop alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_write(rtc->regmap,\n\t\t\t\tconfig->rtc_alarm_secs_reg,\n\t\t\t\t&data[config->rtc_data_start],\n\t\t\t\tconfig->rtc_alarm_len);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to write alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tda9063_data_to_tm(data, &rtc->alarm_time, rtc);\n\n\tif (alrm->enabled) {\n\t\tret = da9063_rtc_start_alarm(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to start alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int da9063_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t       unsigned int enabled)\n{\n\tif (enabled)\n\t\treturn da9063_rtc_start_alarm(dev);\n\telse\n\t\treturn da9063_rtc_stop_alarm(dev);\n}\n\nstatic irqreturn_t da9063_alarm_event(int irq, void *data)\n{\n\tstruct da9063_compatible_rtc *rtc = data;\n\tconst struct da9063_compatible_rtc_regmap *config = rtc->config;\n\n\tregmap_update_bits(rtc->regmap,\n\t\t\t   config->rtc_alarm_year_reg,\n\t\t\t   config->rtc_alarm_on_mask,\n\t\t\t   0);\n\n\trtc->rtc_sync = true;\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops da9063_rtc_ops = {\n\t.read_time = da9063_rtc_read_time,\n\t.set_time = da9063_rtc_set_time,\n\t.read_alarm = da9063_rtc_read_alarm,\n\t.set_alarm = da9063_rtc_set_alarm,\n\t.alarm_irq_enable = da9063_rtc_alarm_irq_enable,\n};\n\nstatic int da9063_rtc_probe(struct platform_device *pdev)\n{\n\tstruct da9063_compatible_rtc *rtc;\n\tconst struct da9063_compatible_rtc_regmap *config;\n\tconst struct of_device_id *match;\n\tint irq_alarm;\n\tu8 data[RTC_DATA_LEN];\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENXIO;\n\n\tmatch = of_match_node(da9063_compatible_reg_id_table,\n\t\t\t      pdev->dev.of_node);\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->config = match->data;\n\tif (of_device_is_compatible(pdev->dev.of_node, \"dlg,da9063-rtc\")) {\n\t\tstruct da9063 *chip = dev_get_drvdata(pdev->dev.parent);\n\n\t\tif (chip->variant_code == PMIC_DA9063_AD)\n\t\t\trtc->config = &da9063_ad_regs;\n\t}\n\n\trtc->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!rtc->regmap) {\n\t\tdev_warn(&pdev->dev, \"Parent regmap unavailable.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tconfig = rtc->config;\n\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t config->rtc_enable_reg,\n\t\t\t\t config->rtc_enable_mask,\n\t\t\t\t config->rtc_enable_mask);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable RTC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t config->rtc_enable_32k_crystal_reg,\n\t\t\t\t config->rtc_crystal_mask,\n\t\t\t\t config->rtc_crystal_mask);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to run 32kHz oscillator\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t config->rtc_alarm_secs_reg,\n\t\t\t\t config->rtc_alarm_status_mask,\n\t\t\t\t 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to access RTC alarm register\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t config->rtc_alarm_secs_reg,\n\t\t\t\t DA9063_ALARM_STATUS_ALARM,\n\t\t\t\t DA9063_ALARM_STATUS_ALARM);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to access RTC alarm register\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(rtc->regmap,\n\t\t\t\t config->rtc_alarm_year_reg,\n\t\t\t\t config->rtc_tick_on_mask,\n\t\t\t\t 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to disable TICKs\\n\");\n\t\treturn ret;\n\t}\n\n\tdata[RTC_SEC] = 0;\n\tret = regmap_bulk_read(rtc->regmap,\n\t\t\t       config->rtc_alarm_secs_reg,\n\t\t\t       &data[config->rtc_data_start],\n\t\t\t       config->rtc_alarm_len);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to read initial alarm data: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\trtc->rtc_dev->ops = &da9063_rtc_ops;\n\trtc->rtc_dev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->rtc_dev->range_max = RTC_TIMESTAMP_END_2063;\n\n\tda9063_data_to_tm(data, &rtc->alarm_time, rtc);\n\trtc->rtc_sync = false;\n\n\tif (config->rtc_data_start != RTC_SEC) {\n\t\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->rtc_dev->features);\n\t\t \n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->rtc_dev->features);\n\t}\n\n\tirq_alarm = platform_get_irq_byname(pdev, \"ALARM\");\n\tif (irq_alarm < 0)\n\t\treturn irq_alarm;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq_alarm, NULL,\n\t\t\t\t\tda9063_alarm_event,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"ALARM\", rtc);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to request ALARM IRQ %d: %d\\n\",\n\t\t\tirq_alarm, ret);\n\n\tret = dev_pm_set_wake_irq(&pdev->dev, irq_alarm);\n\tif (ret)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to set IRQ %d as a wake IRQ: %d\\n\",\n\t\t\t irq_alarm, ret);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\nstatic struct platform_driver da9063_rtc_driver = {\n\t.probe\t\t= da9063_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= DA9063_DRVNAME_RTC,\n\t\t.of_match_table = da9063_compatible_reg_id_table,\n\t},\n};\n\nmodule_platform_driver(da9063_rtc_driver);\n\nMODULE_AUTHOR(\"S Twiss <stwiss.opensource@diasemi.com>\");\nMODULE_DESCRIPTION(\"Real time clock device driver for Dialog DA9063\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DA9063_DRVNAME_RTC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}