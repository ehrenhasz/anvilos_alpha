{
  "module_name": "rtc-wm831x.c",
  "hash_id": "3e56c171d9750d1cdd604a18a177d35b429d8976e7208886ef0ba47d511a63b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-wm831x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/bcd.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/completion.h>\n#include <linux/mfd/wm831x/core.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/random.h>\n\n \n#define WM831X_RTC_WR_CNT_MASK                  0xFFFF   \n#define WM831X_RTC_WR_CNT_SHIFT                      0   \n#define WM831X_RTC_WR_CNT_WIDTH                     16   \n\n \n#define WM831X_RTC_TIME_MASK                    0xFFFF   \n#define WM831X_RTC_TIME_SHIFT                        0   \n#define WM831X_RTC_TIME_WIDTH                       16   \n\n \n#define WM831X_RTC_TIME_MASK                    0xFFFF   \n#define WM831X_RTC_TIME_SHIFT                        0   \n#define WM831X_RTC_TIME_WIDTH                       16   \n\n \n#define WM831X_RTC_ALM_MASK                     0xFFFF   \n#define WM831X_RTC_ALM_SHIFT                         0   \n#define WM831X_RTC_ALM_WIDTH                        16   \n\n \n#define WM831X_RTC_ALM_MASK                     0xFFFF   \n#define WM831X_RTC_ALM_SHIFT                         0   \n#define WM831X_RTC_ALM_WIDTH                        16   \n\n \n#define WM831X_RTC_VALID                        0x8000   \n#define WM831X_RTC_VALID_MASK                   0x8000   \n#define WM831X_RTC_VALID_SHIFT                      15   \n#define WM831X_RTC_VALID_WIDTH                       1   \n#define WM831X_RTC_SYNC_BUSY                    0x4000   \n#define WM831X_RTC_SYNC_BUSY_MASK               0x4000   \n#define WM831X_RTC_SYNC_BUSY_SHIFT                  14   \n#define WM831X_RTC_SYNC_BUSY_WIDTH                   1   \n#define WM831X_RTC_ALM_ENA                      0x0400   \n#define WM831X_RTC_ALM_ENA_MASK                 0x0400   \n#define WM831X_RTC_ALM_ENA_SHIFT                    10   \n#define WM831X_RTC_ALM_ENA_WIDTH                     1   \n#define WM831X_RTC_PINT_FREQ_MASK               0x0070   \n#define WM831X_RTC_PINT_FREQ_SHIFT                   4   \n#define WM831X_RTC_PINT_FREQ_WIDTH                   3   \n\n \n#define WM831X_RTC_TRIM_MASK                    0x03FF   \n#define WM831X_RTC_TRIM_SHIFT                        0   \n#define WM831X_RTC_TRIM_WIDTH                       10   \n\n#define WM831X_SET_TIME_RETRIES\t5\n#define WM831X_GET_TIME_RETRIES\t5\n\nstruct wm831x_rtc {\n\tstruct wm831x *wm831x;\n\tstruct rtc_device *rtc;\n\tunsigned int alarm_enabled:1;\n};\n\nstatic void wm831x_rtc_add_randomness(struct wm831x *wm831x)\n{\n\tint ret;\n\tu16 reg;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_RTC_WRITE_COUNTER);\n\tif (ret >= 0) {\n\t\treg = ret;\n\t\tadd_device_randomness(&reg, sizeof(reg));\n\t} else {\n\t\tdev_warn(wm831x->dev, \"Failed to read RTC write counter: %d\\n\",\n\t\t\t ret);\n\t}\n}\n\n \nstatic int wm831x_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tstruct wm831x *wm831x = wm831x_rtc->wm831x;\n\tu16 time1[2], time2[2];\n\tint ret;\n\tint count = 0;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_RTC_CONTROL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (!(ret & WM831X_RTC_VALID)) {\n\t\tdev_dbg(dev, \"RTC not yet configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdo {\n\t\tret = wm831x_bulk_read(wm831x, WM831X_RTC_TIME_1,\n\t\t\t\t       2, time1);\n\t\tif (ret != 0)\n\t\t\tcontinue;\n\n\t\tret = wm831x_bulk_read(wm831x, WM831X_RTC_TIME_1,\n\t\t\t\t       2, time2);\n\t\tif (ret != 0)\n\t\t\tcontinue;\n\n\t\tif (memcmp(time1, time2, sizeof(time1)) == 0) {\n\t\t\tu32 time = (time1[0] << 16) | time1[1];\n\n\t\t\trtc_time64_to_tm(time, tm);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (++count < WM831X_GET_TIME_RETRIES);\n\n\tdev_err(dev, \"Timed out reading current time\\n\");\n\n\treturn -EIO;\n}\n\n \nstatic int wm831x_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tstruct wm831x *wm831x = wm831x_rtc->wm831x;\n\tstruct rtc_time new_tm;\n\tunsigned long time, new_time;\n\tint ret;\n\tint count = 0;\n\n\ttime = rtc_tm_to_time64(tm);\n\n\tret = wm831x_reg_write(wm831x, WM831X_RTC_TIME_1,\n\t\t\t       (time >> 16) & 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to write TIME_1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm831x_reg_write(wm831x, WM831X_RTC_TIME_2, time & 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to write TIME_2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdo {\n\t\tmsleep(1);\n\n\t\tret = wm831x_reg_read(wm831x, WM831X_RTC_CONTROL);\n\t\tif (ret < 0)\n\t\t\tret = WM831X_RTC_SYNC_BUSY;\n\t} while (!(ret & WM831X_RTC_SYNC_BUSY) &&\n\t\t ++count < WM831X_SET_TIME_RETRIES);\n\n\tif (ret & WM831X_RTC_SYNC_BUSY) {\n\t\tdev_err(dev, \"Timed out writing RTC update\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = wm831x_rtc_readtime(dev, &new_tm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew_time = rtc_tm_to_time64(&new_tm);\n\n\t \n\tif (new_time - time > 1) {\n\t\tdev_err(dev, \"RTC update not permitted by hardware\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wm831x_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret;\n\tu16 data[2];\n\tu32 time;\n\n\tret = wm831x_bulk_read(wm831x_rtc->wm831x, WM831X_RTC_ALARM_1,\n\t\t\t       2, data);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to read alarm time: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttime = (data[0] << 16) | data[1];\n\n\trtc_time64_to_tm(time, &alrm->time);\n\n\tret = wm831x_reg_read(wm831x_rtc->wm831x, WM831X_RTC_CONTROL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret & WM831X_RTC_ALM_ENA)\n\t\talrm->enabled = 1;\n\telse\n\t\talrm->enabled = 0;\n\n\treturn 0;\n}\n\nstatic int wm831x_rtc_stop_alarm(struct wm831x_rtc *wm831x_rtc)\n{\n\twm831x_rtc->alarm_enabled = 0;\n\n\treturn wm831x_set_bits(wm831x_rtc->wm831x, WM831X_RTC_CONTROL,\n\t\t\t       WM831X_RTC_ALM_ENA, 0);\n}\n\nstatic int wm831x_rtc_start_alarm(struct wm831x_rtc *wm831x_rtc)\n{\n\twm831x_rtc->alarm_enabled = 1;\n\n\treturn wm831x_set_bits(wm831x_rtc->wm831x, WM831X_RTC_CONTROL,\n\t\t\t       WM831X_RTC_ALM_ENA, WM831X_RTC_ALM_ENA);\n}\n\nstatic int wm831x_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tstruct wm831x *wm831x = wm831x_rtc->wm831x;\n\tint ret;\n\tunsigned long time;\n\n\ttime = rtc_tm_to_time64(&alrm->time);\n\n\tret = wm831x_rtc_stop_alarm(wm831x_rtc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to stop alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm831x_reg_write(wm831x, WM831X_RTC_ALARM_1,\n\t\t\t       (time >> 16) & 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to write ALARM_1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm831x_reg_write(wm831x, WM831X_RTC_ALARM_2, time & 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to write ALARM_2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (alrm->enabled) {\n\t\tret = wm831x_rtc_start_alarm(wm831x_rtc);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to start alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t       unsigned int enabled)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\treturn wm831x_rtc_start_alarm(wm831x_rtc);\n\telse\n\t\treturn wm831x_rtc_stop_alarm(wm831x_rtc);\n}\n\nstatic irqreturn_t wm831x_alm_irq(int irq, void *data)\n{\n\tstruct wm831x_rtc *wm831x_rtc = data;\n\n\trtc_update_irq(wm831x_rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops wm831x_rtc_ops = {\n\t.read_time = wm831x_rtc_readtime,\n\t.set_time = wm831x_rtc_settime,\n\t.read_alarm = wm831x_rtc_readalarm,\n\t.set_alarm = wm831x_rtc_setalarm,\n\t.alarm_irq_enable = wm831x_rtc_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM\n \nstatic int wm831x_rtc_suspend(struct device *dev)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret, enable;\n\n\tif (wm831x_rtc->alarm_enabled && device_may_wakeup(dev))\n\t\tenable = WM831X_RTC_ALM_ENA;\n\telse\n\t\tenable = 0;\n\n\tret = wm831x_set_bits(wm831x_rtc->wm831x, WM831X_RTC_CONTROL,\n\t\t\t      WM831X_RTC_ALM_ENA, enable);\n\tif (ret != 0)\n\t\tdev_err(dev, \"Failed to update RTC alarm: %d\\n\", ret);\n\n\treturn 0;\n}\n\n \nstatic int wm831x_rtc_resume(struct device *dev)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (wm831x_rtc->alarm_enabled) {\n\t\tret = wm831x_rtc_start_alarm(wm831x_rtc);\n\t\tif (ret != 0)\n\t\t\tdev_err(dev, \"Failed to restart RTC alarm: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wm831x_rtc_freeze(struct device *dev)\n{\n\tstruct wm831x_rtc *wm831x_rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = wm831x_set_bits(wm831x_rtc->wm831x, WM831X_RTC_CONTROL,\n\t\t\t      WM831X_RTC_ALM_ENA, 0);\n\tif (ret != 0)\n\t\tdev_err(dev, \"Failed to stop RTC alarm: %d\\n\", ret);\n\n\treturn 0;\n}\n#else\n#define wm831x_rtc_suspend NULL\n#define wm831x_rtc_resume NULL\n#define wm831x_rtc_freeze NULL\n#endif\n\nstatic int wm831x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_rtc *wm831x_rtc;\n\tint alm_irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"ALM\"));\n\tint ret = 0;\n\n\twm831x_rtc = devm_kzalloc(&pdev->dev, sizeof(*wm831x_rtc), GFP_KERNEL);\n\tif (wm831x_rtc == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, wm831x_rtc);\n\twm831x_rtc->wm831x = wm831x;\n\n\tret = wm831x_reg_read(wm831x, WM831X_RTC_CONTROL);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to read RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret & WM831X_RTC_ALM_ENA)\n\t\twm831x_rtc->alarm_enabled = 1;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\twm831x_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(wm831x_rtc->rtc))\n\t\treturn PTR_ERR(wm831x_rtc->rtc);\n\n\twm831x_rtc->rtc->ops = &wm831x_rtc_ops;\n\twm831x_rtc->rtc->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(wm831x_rtc->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL,\n\t\t\t\twm831x_alm_irq,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\"RTC alarm\",\n\t\t\t\twm831x_rtc);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ %d: %d\\n\",\n\t\t\talm_irq, ret);\n\t}\n\n\twm831x_rtc_add_randomness(wm831x);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wm831x_rtc_pm_ops = {\n\t.suspend = wm831x_rtc_suspend,\n\t.resume = wm831x_rtc_resume,\n\n\t.freeze = wm831x_rtc_freeze,\n\t.thaw = wm831x_rtc_resume,\n\t.restore = wm831x_rtc_resume,\n\n\t.poweroff = wm831x_rtc_suspend,\n};\n\nstatic struct platform_driver wm831x_rtc_driver = {\n\t.probe = wm831x_rtc_probe,\n\t.driver = {\n\t\t.name = \"wm831x-rtc\",\n\t\t.pm = &wm831x_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(wm831x_rtc_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"RTC driver for the WM831x series PMICs\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}