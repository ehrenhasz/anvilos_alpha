{
  "module_name": "rtc-sh.c",
  "hash_id": "1e2ec9d1659b7618d81befc0e20d053d9b68625f829c00c043368e3c51716a0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-sh.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#ifdef CONFIG_SUPERH\n#include <asm/rtc.h>\n#else\n \n#define rtc_reg_size\t\tsizeof(u16)\n#define RTC_BIT_INVERTED        0\t \n#define RTC_CAP_4_DIGIT_YEAR    (1 << 0)\n#define RTC_DEF_CAPABILITIES    RTC_CAP_4_DIGIT_YEAR\n#endif\n\n#define DRV_NAME\t\"sh-rtc\"\n\n#define RTC_REG(r)\t((r) * rtc_reg_size)\n\n#define R64CNT\t\tRTC_REG(0)\n\n#define RSECCNT\t\tRTC_REG(1)\t \n#define RMINCNT\t\tRTC_REG(2)\t \n#define RHRCNT\t\tRTC_REG(3)\t \n#define RWKCNT\t\tRTC_REG(4)\t \n#define RDAYCNT\t\tRTC_REG(5)\t \n#define RMONCNT\t\tRTC_REG(6)\t \n#define RYRCNT\t\tRTC_REG(7)\t \n#define RSECAR\t\tRTC_REG(8)\t \n#define RMINAR\t\tRTC_REG(9)\t \n#define RHRAR\t\tRTC_REG(10)\t \n#define RWKAR\t\tRTC_REG(11)\t \n#define RDAYAR\t\tRTC_REG(12)\t \n#define RMONAR\t\tRTC_REG(13)\t \n#define RCR1\t\tRTC_REG(14)\t \n#define RCR2\t\tRTC_REG(15)\t \n\n \n\n \n#define AR_ENB\t\t0x80\t \n\n \n#define PF_HP\t\t0x100\t \n#define PF_COUNT\t0x200\t \n#define PF_OXS\t\t0x400\t \n#define PF_KOU\t\t0x800\t \n#define PF_MASK\t\t0xf00\n\n \n#define RCR1_CF\t\t0x80\t \n#define RCR1_CIE\t0x10\t \n#define RCR1_AIE\t0x08\t \n#define RCR1_AF\t\t0x01\t \n\n \n#define RCR2_PEF\t0x80\t \n#define RCR2_PESMASK\t0x70\t \n#define RCR2_RTCEN\t0x08\t \n#define RCR2_ADJ\t0x04\t \n#define RCR2_RESET\t0x02\t \n#define RCR2_START\t0x01\t \n\nstruct sh_rtc {\n\tvoid __iomem\t\t*regbase;\n\tunsigned long\t\tregsize;\n\tstruct resource\t\t*res;\n\tint\t\t\talarm_irq;\n\tint\t\t\tperiodic_irq;\n\tint\t\t\tcarry_irq;\n\tstruct clk\t\t*clk;\n\tstruct rtc_device\t*rtc_dev;\n\tspinlock_t\t\tlock;\n\tunsigned long\t\tcapabilities;\t \n\tunsigned short\t\tperiodic_freq;\n};\n\nstatic int __sh_rtc_interrupt(struct sh_rtc *rtc)\n{\n\tunsigned int tmp, pending;\n\n\ttmp = readb(rtc->regbase + RCR1);\n\tpending = tmp & RCR1_CF;\n\ttmp &= ~RCR1_CF;\n\twriteb(tmp, rtc->regbase + RCR1);\n\n\t \n\tif (pending && rtc->periodic_freq & PF_OXS)\n\t\trtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);\n\n\treturn pending;\n}\n\nstatic int __sh_rtc_alarm(struct sh_rtc *rtc)\n{\n\tunsigned int tmp, pending;\n\n\ttmp = readb(rtc->regbase + RCR1);\n\tpending = tmp & RCR1_AF;\n\ttmp &= ~(RCR1_AF | RCR1_AIE);\n\twriteb(tmp, rtc->regbase + RCR1);\n\n\tif (pending)\n\t\trtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\n\n\treturn pending;\n}\n\nstatic int __sh_rtc_periodic(struct sh_rtc *rtc)\n{\n\tunsigned int tmp, pending;\n\n\ttmp = readb(rtc->regbase + RCR2);\n\tpending = tmp & RCR2_PEF;\n\ttmp &= ~RCR2_PEF;\n\twriteb(tmp, rtc->regbase + RCR2);\n\n\tif (!pending)\n\t\treturn 0;\n\n\t \n\tif ((rtc->periodic_freq & PF_HP) && (rtc->periodic_freq & PF_COUNT))\n\t\trtc->periodic_freq &= ~PF_COUNT;\n\telse {\n\t\tif (rtc->periodic_freq & PF_HP)\n\t\t\trtc->periodic_freq |= PF_COUNT;\n\t\trtc_update_irq(rtc->rtc_dev, 1, RTC_PF | RTC_IRQF);\n\t}\n\n\treturn pending;\n}\n\nstatic irqreturn_t sh_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct sh_rtc *rtc = dev_id;\n\tint ret;\n\n\tspin_lock(&rtc->lock);\n\tret = __sh_rtc_interrupt(rtc);\n\tspin_unlock(&rtc->lock);\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic irqreturn_t sh_rtc_alarm(int irq, void *dev_id)\n{\n\tstruct sh_rtc *rtc = dev_id;\n\tint ret;\n\n\tspin_lock(&rtc->lock);\n\tret = __sh_rtc_alarm(rtc);\n\tspin_unlock(&rtc->lock);\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic irqreturn_t sh_rtc_periodic(int irq, void *dev_id)\n{\n\tstruct sh_rtc *rtc = dev_id;\n\tint ret;\n\n\tspin_lock(&rtc->lock);\n\tret = __sh_rtc_periodic(rtc);\n\tspin_unlock(&rtc->lock);\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic irqreturn_t sh_rtc_shared(int irq, void *dev_id)\n{\n\tstruct sh_rtc *rtc = dev_id;\n\tint ret;\n\n\tspin_lock(&rtc->lock);\n\tret = __sh_rtc_interrupt(rtc);\n\tret |= __sh_rtc_alarm(rtc);\n\tret |= __sh_rtc_periodic(rtc);\n\tspin_unlock(&rtc->lock);\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic inline void sh_rtc_setaie(struct device *dev, unsigned int enable)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\n\tspin_lock_irq(&rtc->lock);\n\n\ttmp = readb(rtc->regbase + RCR1);\n\n\tif (enable)\n\t\ttmp |= RCR1_AIE;\n\telse\n\t\ttmp &= ~RCR1_AIE;\n\n\twriteb(tmp, rtc->regbase + RCR1);\n\n\tspin_unlock_irq(&rtc->lock);\n}\n\nstatic int sh_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\n\ttmp = readb(rtc->regbase + RCR1);\n\tseq_printf(seq, \"carry_IRQ\\t: %s\\n\", (tmp & RCR1_CIE) ? \"yes\" : \"no\");\n\n\ttmp = readb(rtc->regbase + RCR2);\n\tseq_printf(seq, \"periodic_IRQ\\t: %s\\n\",\n\t\t   (tmp & RCR2_PESMASK) ? \"yes\" : \"no\");\n\n\treturn 0;\n}\n\nstatic inline void sh_rtc_setcie(struct device *dev, unsigned int enable)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\n\tspin_lock_irq(&rtc->lock);\n\n\ttmp = readb(rtc->regbase + RCR1);\n\n\tif (!enable)\n\t\ttmp &= ~RCR1_CIE;\n\telse\n\t\ttmp |= RCR1_CIE;\n\n\twriteb(tmp, rtc->regbase + RCR1);\n\n\tspin_unlock_irq(&rtc->lock);\n}\n\nstatic int sh_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tsh_rtc_setaie(dev, enabled);\n\treturn 0;\n}\n\nstatic int sh_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int sec128, sec2, yr, yr100, cf_bit;\n\n\tif (!(readb(rtc->regbase + RCR2) & RCR2_RTCEN))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tunsigned int tmp;\n\n\t\tspin_lock_irq(&rtc->lock);\n\n\t\ttmp = readb(rtc->regbase + RCR1);\n\t\ttmp &= ~RCR1_CF;  \n\t\ttmp |= RCR1_CIE;\n\t\twriteb(tmp, rtc->regbase + RCR1);\n\n\t\tsec128 = readb(rtc->regbase + R64CNT);\n\n\t\ttm->tm_sec\t= bcd2bin(readb(rtc->regbase + RSECCNT));\n\t\ttm->tm_min\t= bcd2bin(readb(rtc->regbase + RMINCNT));\n\t\ttm->tm_hour\t= bcd2bin(readb(rtc->regbase + RHRCNT));\n\t\ttm->tm_wday\t= bcd2bin(readb(rtc->regbase + RWKCNT));\n\t\ttm->tm_mday\t= bcd2bin(readb(rtc->regbase + RDAYCNT));\n\t\ttm->tm_mon\t= bcd2bin(readb(rtc->regbase + RMONCNT)) - 1;\n\n\t\tif (rtc->capabilities & RTC_CAP_4_DIGIT_YEAR) {\n\t\t\tyr  = readw(rtc->regbase + RYRCNT);\n\t\t\tyr100 = bcd2bin(yr >> 8);\n\t\t\tyr &= 0xff;\n\t\t} else {\n\t\t\tyr  = readb(rtc->regbase + RYRCNT);\n\t\t\tyr100 = bcd2bin((yr == 0x99) ? 0x19 : 0x20);\n\t\t}\n\n\t\ttm->tm_year = (yr100 * 100 + bcd2bin(yr)) - 1900;\n\n\t\tsec2 = readb(rtc->regbase + R64CNT);\n\t\tcf_bit = readb(rtc->regbase + RCR1) & RCR1_CF;\n\n\t\tspin_unlock_irq(&rtc->lock);\n\t} while (cf_bit != 0 || ((sec128 ^ sec2) & RTC_BIT_INVERTED) != 0);\n\n#if RTC_BIT_INVERTED != 0\n\tif ((sec128 & RTC_BIT_INVERTED))\n\t\ttm->tm_sec--;\n#endif\n\n\t \n\tif (!(rtc->periodic_freq & PF_OXS))\n\t\tsh_rtc_setcie(dev, 0);\n\n\tdev_dbg(dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon + 1, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int sh_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int tmp;\n\tint year;\n\n\tspin_lock_irq(&rtc->lock);\n\n\t \n\ttmp = readb(rtc->regbase + RCR2);\n\ttmp |= RCR2_RESET;\n\ttmp &= ~RCR2_START;\n\twriteb(tmp, rtc->regbase + RCR2);\n\n\twriteb(bin2bcd(tm->tm_sec),  rtc->regbase + RSECCNT);\n\twriteb(bin2bcd(tm->tm_min),  rtc->regbase + RMINCNT);\n\twriteb(bin2bcd(tm->tm_hour), rtc->regbase + RHRCNT);\n\twriteb(bin2bcd(tm->tm_wday), rtc->regbase + RWKCNT);\n\twriteb(bin2bcd(tm->tm_mday), rtc->regbase + RDAYCNT);\n\twriteb(bin2bcd(tm->tm_mon + 1), rtc->regbase + RMONCNT);\n\n\tif (rtc->capabilities & RTC_CAP_4_DIGIT_YEAR) {\n\t\tyear = (bin2bcd((tm->tm_year + 1900) / 100) << 8) |\n\t\t\tbin2bcd(tm->tm_year % 100);\n\t\twritew(year, rtc->regbase + RYRCNT);\n\t} else {\n\t\tyear = tm->tm_year % 100;\n\t\twriteb(bin2bcd(year), rtc->regbase + RYRCNT);\n\t}\n\n\t \n\ttmp = readb(rtc->regbase + RCR2);\n\ttmp &= ~RCR2_RESET;\n\ttmp |= RCR2_RTCEN | RCR2_START;\n\twriteb(tmp, rtc->regbase + RCR2);\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic inline int sh_rtc_read_alarm_value(struct sh_rtc *rtc, int reg_off)\n{\n\tunsigned int byte;\n\tint value = -1;\t\t\t \n\n\tbyte = readb(rtc->regbase + reg_off);\n\tif (byte & AR_ENB) {\n\t\tbyte &= ~AR_ENB;\t \n\t\tvalue = bcd2bin(byte);\n\t}\n\n\treturn value;\n}\n\nstatic int sh_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &wkalrm->time;\n\n\tspin_lock_irq(&rtc->lock);\n\n\ttm->tm_sec\t= sh_rtc_read_alarm_value(rtc, RSECAR);\n\ttm->tm_min\t= sh_rtc_read_alarm_value(rtc, RMINAR);\n\ttm->tm_hour\t= sh_rtc_read_alarm_value(rtc, RHRAR);\n\ttm->tm_wday\t= sh_rtc_read_alarm_value(rtc, RWKAR);\n\ttm->tm_mday\t= sh_rtc_read_alarm_value(rtc, RDAYAR);\n\ttm->tm_mon\t= sh_rtc_read_alarm_value(rtc, RMONAR);\n\tif (tm->tm_mon > 0)\n\t\ttm->tm_mon -= 1;  \n\n\twkalrm->enabled = (readb(rtc->regbase + RCR1) & RCR1_AIE) ? 1 : 0;\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic inline void sh_rtc_write_alarm_value(struct sh_rtc *rtc,\n\t\t\t\t\t    int value, int reg_off)\n{\n\t \n\tif (value < 0)\n\t\twriteb(0, rtc->regbase + reg_off);\n\telse\n\t\twriteb(bin2bcd(value) | AR_ENB,  rtc->regbase + reg_off);\n}\n\nstatic int sh_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned int rcr1;\n\tstruct rtc_time *tm = &wkalrm->time;\n\tint mon;\n\n\tspin_lock_irq(&rtc->lock);\n\n\t \n\trcr1 = readb(rtc->regbase + RCR1);\n\trcr1 &= ~(RCR1_AF | RCR1_AIE);\n\twriteb(rcr1, rtc->regbase + RCR1);\n\n\t \n\tsh_rtc_write_alarm_value(rtc, tm->tm_sec,  RSECAR);\n\tsh_rtc_write_alarm_value(rtc, tm->tm_min,  RMINAR);\n\tsh_rtc_write_alarm_value(rtc, tm->tm_hour, RHRAR);\n\tsh_rtc_write_alarm_value(rtc, tm->tm_wday, RWKAR);\n\tsh_rtc_write_alarm_value(rtc, tm->tm_mday, RDAYAR);\n\tmon = tm->tm_mon;\n\tif (mon >= 0)\n\t\tmon += 1;\n\tsh_rtc_write_alarm_value(rtc, mon, RMONAR);\n\n\tif (wkalrm->enabled) {\n\t\trcr1 |= RCR1_AIE;\n\t\twriteb(rcr1, rtc->regbase + RCR1);\n\t}\n\n\tspin_unlock_irq(&rtc->lock);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops sh_rtc_ops = {\n\t.read_time\t= sh_rtc_read_time,\n\t.set_time\t= sh_rtc_set_time,\n\t.read_alarm\t= sh_rtc_read_alarm,\n\t.set_alarm\t= sh_rtc_set_alarm,\n\t.proc\t\t= sh_rtc_proc,\n\t.alarm_irq_enable = sh_rtc_alarm_irq_enable,\n};\n\nstatic int __init sh_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sh_rtc *rtc;\n\tstruct resource *res;\n\tchar clk_name[6];\n\tint clk_id, ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (unlikely(!rtc))\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&rtc->lock);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (unlikely(ret <= 0)) {\n\t\tdev_err(&pdev->dev, \"No IRQ resource\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\trtc->periodic_irq = ret;\n\trtc->carry_irq = platform_get_irq(pdev, 1);\n\trtc->alarm_irq = platform_get_irq(pdev, 2);\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(res == NULL)) {\n\t\tdev_err(&pdev->dev, \"No IO resource\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\trtc->regsize = resource_size(res);\n\n\trtc->res = devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t\trtc->regsize, pdev->name);\n\tif (unlikely(!rtc->res))\n\t\treturn -EBUSY;\n\n\trtc->regbase = devm_ioremap(&pdev->dev, rtc->res->start, rtc->regsize);\n\tif (unlikely(!rtc->regbase))\n\t\treturn -EINVAL;\n\n\tif (!pdev->dev.of_node) {\n\t\tclk_id = pdev->id;\n\t\t \n\t\tif (clk_id < 0)\n\t\t\tclk_id = 0;\n\n\t\tsnprintf(clk_name, sizeof(clk_name), \"rtc%d\", clk_id);\n\t} else\n\t\tsnprintf(clk_name, sizeof(clk_name), \"fck\");\n\n\trtc->clk = devm_clk_get(&pdev->dev, clk_name);\n\tif (IS_ERR(rtc->clk)) {\n\t\t \n\t\trtc->clk = NULL;\n\t}\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tclk_enable(rtc->clk);\n\n\trtc->capabilities = RTC_DEF_CAPABILITIES;\n\n#ifdef CONFIG_SUPERH\n\tif (dev_get_platdata(&pdev->dev)) {\n\t\tstruct sh_rtc_platform_info *pinfo =\n\t\t\tdev_get_platdata(&pdev->dev);\n\n\t\t \n\t\trtc->capabilities |= pinfo->capabilities;\n\t}\n#endif\n\n\tif (rtc->carry_irq <= 0) {\n\t\t \n\t\tret = devm_request_irq(&pdev->dev, rtc->periodic_irq,\n\t\t\t\tsh_rtc_shared, 0, \"sh-rtc\", rtc);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"request IRQ failed with %d, IRQ %d\\n\", ret,\n\t\t\t\trtc->periodic_irq);\n\t\t\tgoto err_unmap;\n\t\t}\n\t} else {\n\t\t \n\t\tret = devm_request_irq(&pdev->dev, rtc->periodic_irq,\n\t\t\t\tsh_rtc_periodic, 0, \"sh-rtc period\", rtc);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"request period IRQ failed with %d, IRQ %d\\n\",\n\t\t\t\tret, rtc->periodic_irq);\n\t\t\tgoto err_unmap;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, rtc->carry_irq,\n\t\t\t\tsh_rtc_interrupt, 0, \"sh-rtc carry\", rtc);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"request carry IRQ failed with %d, IRQ %d\\n\",\n\t\t\t\tret, rtc->carry_irq);\n\t\t\tgoto err_unmap;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, rtc->alarm_irq,\n\t\t\t\tsh_rtc_alarm, 0, \"sh-rtc alarm\", rtc);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"request alarm IRQ failed with %d, IRQ %d\\n\",\n\t\t\t\tret, rtc->alarm_irq);\n\t\t\tgoto err_unmap;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\t \n\tsh_rtc_setaie(&pdev->dev, 0);\n\tsh_rtc_setcie(&pdev->dev, 0);\n\n\trtc->rtc_dev->ops = &sh_rtc_ops;\n\trtc->rtc_dev->max_user_freq = 256;\n\n\tif (rtc->capabilities & RTC_CAP_4_DIGIT_YEAR) {\n\t\trtc->rtc_dev->range_min = RTC_TIMESTAMP_BEGIN_1900;\n\t\trtc->rtc_dev->range_max = RTC_TIMESTAMP_END_9999;\n\t} else {\n\t\trtc->rtc_dev->range_min = mktime64(1999, 1, 1, 0, 0, 0);\n\t\trtc->rtc_dev->range_max = mktime64(2098, 12, 31, 23, 59, 59);\n\t}\n\n\tret = devm_rtc_register_device(rtc->rtc_dev);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\treturn 0;\n\nerr_unmap:\n\tclk_disable(rtc->clk);\n\n\treturn ret;\n}\n\nstatic int __exit sh_rtc_remove(struct platform_device *pdev)\n{\n\tstruct sh_rtc *rtc = platform_get_drvdata(pdev);\n\n\tsh_rtc_setaie(&pdev->dev, 0);\n\tsh_rtc_setcie(&pdev->dev, 0);\n\n\tclk_disable(rtc->clk);\n\n\treturn 0;\n}\n\nstatic void sh_rtc_set_irq_wake(struct device *dev, int enabled)\n{\n\tstruct sh_rtc *rtc = dev_get_drvdata(dev);\n\n\tirq_set_irq_wake(rtc->periodic_irq, enabled);\n\n\tif (rtc->carry_irq > 0) {\n\t\tirq_set_irq_wake(rtc->carry_irq, enabled);\n\t\tirq_set_irq_wake(rtc->alarm_irq, enabled);\n\t}\n}\n\nstatic int __maybe_unused sh_rtc_suspend(struct device *dev)\n{\n\tif (device_may_wakeup(dev))\n\t\tsh_rtc_set_irq_wake(dev, 1);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sh_rtc_resume(struct device *dev)\n{\n\tif (device_may_wakeup(dev))\n\t\tsh_rtc_set_irq_wake(dev, 0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sh_rtc_pm_ops, sh_rtc_suspend, sh_rtc_resume);\n\nstatic const struct of_device_id sh_rtc_of_match[] = {\n\t{ .compatible = \"renesas,sh-rtc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sh_rtc_of_match);\n\nstatic struct platform_driver sh_rtc_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.pm\t= &sh_rtc_pm_ops,\n\t\t.of_match_table = sh_rtc_of_match,\n\t},\n\t.remove\t\t= __exit_p(sh_rtc_remove),\n};\n\nmodule_platform_driver_probe(sh_rtc_platform_driver, sh_rtc_probe);\n\nMODULE_DESCRIPTION(\"SuperH on-chip RTC driver\");\nMODULE_AUTHOR(\"Paul Mundt <lethal@linux-sh.org>, \"\n\t      \"Jamie Lenehan <lenehan@twibble.org>, \"\n\t      \"Angelo Castello <angelo.castello@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}