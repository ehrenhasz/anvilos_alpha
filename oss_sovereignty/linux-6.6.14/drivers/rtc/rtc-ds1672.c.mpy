{
  "module_name": "rtc-ds1672.c",
  "hash_id": "18ef462f65c72ff314ce7bed21a88fb9cd463c215afe2c659d9076d77372c0ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1672.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n\n \n\n#define DS1672_REG_CNT_BASE\t0\n#define DS1672_REG_CONTROL\t4\n#define DS1672_REG_TRICKLE\t5\n\n#define DS1672_REG_CONTROL_EOSC\t0x80\n\n \nstatic int ds1672_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned long time;\n\tunsigned char addr = DS1672_REG_CONTROL;\n\tunsigned char buf[4];\n\n\tstruct i2c_msg msgs[] = {\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t},\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\t \n\tif ((i2c_transfer(client->adapter, &msgs[0], 2)) != 2) {\n\t\tdev_warn(&client->dev, \"Unable to read the control register\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (buf[0] & DS1672_REG_CONTROL_EOSC) {\n\t\tdev_warn(&client->dev, \"Oscillator not enabled. Set time to enable.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = DS1672_REG_CNT_BASE;\n\tmsgs[1].len = 4;\n\n\t \n\tif ((i2c_transfer(client->adapter, &msgs[0], 2)) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"%s: raw read data - counters=%02x,%02x,%02x,%02x\\n\",\n\t\t__func__, buf[0], buf[1], buf[2], buf[3]);\n\n\ttime = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t       (buf[1] << 8) | buf[0];\n\n\trtc_time64_to_tm(time, tm);\n\n\tdev_dbg(&client->dev, \"%s: tm is %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic int ds1672_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint xfer;\n\tunsigned char buf[6];\n\tunsigned long secs = rtc_tm_to_time64(tm);\n\n\tbuf[0] = DS1672_REG_CNT_BASE;\n\tbuf[1] = secs & 0x000000FF;\n\tbuf[2] = (secs & 0x0000FF00) >> 8;\n\tbuf[3] = (secs & 0x00FF0000) >> 16;\n\tbuf[4] = (secs & 0xFF000000) >> 24;\n\tbuf[5] = 0;\t\t \n\n\txfer = i2c_master_send(client, buf, 6);\n\tif (xfer != 6) {\n\t\tdev_err(&client->dev, \"%s: send: %d\\n\", __func__, xfer);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1672_rtc_ops = {\n\t.read_time = ds1672_read_time,\n\t.set_time = ds1672_set_time,\n};\n\nstatic int ds1672_probe(struct i2c_client *client)\n{\n\tint err = 0;\n\tstruct rtc_device *rtc;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\trtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\trtc->ops = &ds1672_rtc_ops;\n\trtc->range_max = U32_MAX;\n\n\terr = devm_rtc_register_device(rtc);\n\tif (err)\n\t\treturn err;\n\n\ti2c_set_clientdata(client, rtc);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ds1672_id[] = {\n\t{ \"ds1672\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ds1672_id);\n\nstatic const __maybe_unused struct of_device_id ds1672_of_match[] = {\n\t{ .compatible = \"dallas,ds1672\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ds1672_of_match);\n\nstatic struct i2c_driver ds1672_driver = {\n\t.driver = {\n\t\t   .name = \"rtc-ds1672\",\n\t\t   .of_match_table = of_match_ptr(ds1672_of_match),\n\t},\n\t.probe = ds1672_probe,\n\t.id_table = ds1672_id,\n};\n\nmodule_i2c_driver(ds1672_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"Dallas/Maxim DS1672 timekeeper driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}