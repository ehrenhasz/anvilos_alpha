{
  "module_name": "rtc-jz4740.c",
  "hash_id": "7023dc694c5e16e872a3a01d083170469f7fc5d0dc57ffbfdf6e74dde597a8fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-jz4740.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/property.h>\n#include <linux/reboot.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define JZ_REG_RTC_CTRL\t\t0x00\n#define JZ_REG_RTC_SEC\t\t0x04\n#define JZ_REG_RTC_SEC_ALARM\t0x08\n#define JZ_REG_RTC_REGULATOR\t0x0C\n#define JZ_REG_RTC_HIBERNATE\t0x20\n#define JZ_REG_RTC_WAKEUP_FILTER\t0x24\n#define JZ_REG_RTC_RESET_COUNTER\t0x28\n#define JZ_REG_RTC_SCRATCHPAD\t0x34\n#define JZ_REG_RTC_CKPCR\t0x40\n\n \n#define JZ_REG_RTC_WENR\t0x3C\n#define JZ_RTC_WENR_WEN\tBIT(31)\n\n#define JZ_RTC_CTRL_WRDY\tBIT(7)\n#define JZ_RTC_CTRL_1HZ\t\tBIT(6)\n#define JZ_RTC_CTRL_1HZ_IRQ\tBIT(5)\n#define JZ_RTC_CTRL_AF\t\tBIT(4)\n#define JZ_RTC_CTRL_AF_IRQ\tBIT(3)\n#define JZ_RTC_CTRL_AE\t\tBIT(2)\n#define JZ_RTC_CTRL_ENABLE\tBIT(0)\n\n \n#define JZ_RTC_WENR_MAGIC\t0xA55A\n\n#define JZ_RTC_WAKEUP_FILTER_MASK\t0x0000FFE0\n#define JZ_RTC_RESET_COUNTER_MASK\t0x00000FE0\n\n#define JZ_RTC_CKPCR_CK32PULL_DIS\tBIT(4)\n#define JZ_RTC_CKPCR_CK32CTL_EN\t\t(BIT(2) | BIT(1))\n\nenum jz4740_rtc_type {\n\tID_JZ4740,\n\tID_JZ4760,\n\tID_JZ4780,\n};\n\nstruct jz4740_rtc {\n\tvoid __iomem *base;\n\tenum jz4740_rtc_type type;\n\n\tstruct rtc_device *rtc;\n\n\tstruct clk_hw clk32k;\n\n\tspinlock_t lock;\n};\n\nstatic struct device *dev_for_power_off;\n\nstatic inline uint32_t jz4740_rtc_reg_read(struct jz4740_rtc *rtc, size_t reg)\n{\n\treturn readl(rtc->base + reg);\n}\n\nstatic int jz4740_rtc_wait_write_ready(struct jz4740_rtc *rtc)\n{\n\tuint32_t ctrl;\n\n\treturn readl_poll_timeout(rtc->base + JZ_REG_RTC_CTRL, ctrl,\n\t\t\t\t  ctrl & JZ_RTC_CTRL_WRDY, 0, 1000);\n}\n\nstatic inline int jz4780_rtc_enable_write(struct jz4740_rtc *rtc)\n{\n\tuint32_t ctrl;\n\tint ret;\n\n\tret = jz4740_rtc_wait_write_ready(rtc);\n\tif (ret != 0)\n\t\treturn ret;\n\n\twritel(JZ_RTC_WENR_MAGIC, rtc->base + JZ_REG_RTC_WENR);\n\n\treturn readl_poll_timeout(rtc->base + JZ_REG_RTC_WENR, ctrl,\n\t\t\t\t  ctrl & JZ_RTC_WENR_WEN, 0, 1000);\n}\n\nstatic inline int jz4740_rtc_reg_write(struct jz4740_rtc *rtc, size_t reg,\n\tuint32_t val)\n{\n\tint ret = 0;\n\n\tif (rtc->type >= ID_JZ4760)\n\t\tret = jz4780_rtc_enable_write(rtc);\n\tif (ret == 0)\n\t\tret = jz4740_rtc_wait_write_ready(rtc);\n\tif (ret == 0)\n\t\twritel(val, rtc->base + reg);\n\n\treturn ret;\n}\n\nstatic int jz4740_rtc_ctrl_set_bits(struct jz4740_rtc *rtc, uint32_t mask,\n\tbool set)\n{\n\tint ret;\n\tunsigned long flags;\n\tuint32_t ctrl;\n\n\tspin_lock_irqsave(&rtc->lock, flags);\n\n\tctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\n\n\t \n\tctrl |= JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF;\n\n\tif (set)\n\t\tctrl |= mask;\n\telse\n\t\tctrl &= ~mask;\n\n\tret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_CTRL, ctrl);\n\n\tspin_unlock_irqrestore(&rtc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int jz4740_rtc_read_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\tuint32_t secs, secs2;\n\tint timeout = 5;\n\n\tif (jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SCRATCHPAD) != 0x12345678)\n\t\treturn -EINVAL;\n\n\t \n\tsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\n\tsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\n\n\twhile (secs != secs2 && --timeout) {\n\t\tsecs = secs2;\n\t\tsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\n\t}\n\n\tif (timeout == 0)\n\t\treturn -EIO;\n\n\trtc_time64_to_tm(secs, time);\n\n\treturn 0;\n}\n\nstatic int jz4740_rtc_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC, rtc_tm_to_time64(time));\n\tif (ret)\n\t\treturn ret;\n\n\treturn jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SCRATCHPAD, 0x12345678);\n}\n\nstatic int jz4740_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\tuint32_t secs;\n\tuint32_t ctrl;\n\n\tsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC_ALARM);\n\n\tctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\n\n\talrm->enabled = !!(ctrl & JZ_RTC_CTRL_AE);\n\talrm->pending = !!(ctrl & JZ_RTC_CTRL_AF);\n\n\trtc_time64_to_tm(secs, &alrm->time);\n\n\treturn 0;\n}\n\nstatic int jz4740_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\tuint32_t secs = lower_32_bits(rtc_tm_to_time64(&alrm->time));\n\n\tret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC_ALARM, secs);\n\tif (!ret)\n\t\tret = jz4740_rtc_ctrl_set_bits(rtc,\n\t\t\tJZ_RTC_CTRL_AE | JZ_RTC_CTRL_AF_IRQ, alrm->enabled);\n\n\treturn ret;\n}\n\nstatic int jz4740_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\treturn jz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_AF_IRQ, enable);\n}\n\nstatic const struct rtc_class_ops jz4740_rtc_ops = {\n\t.read_time\t= jz4740_rtc_read_time,\n\t.set_time\t= jz4740_rtc_set_time,\n\t.read_alarm\t= jz4740_rtc_read_alarm,\n\t.set_alarm\t= jz4740_rtc_set_alarm,\n\t.alarm_irq_enable = jz4740_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t jz4740_rtc_irq(int irq, void *data)\n{\n\tstruct jz4740_rtc *rtc = data;\n\tuint32_t ctrl;\n\tunsigned long events = 0;\n\n\tctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\n\n\tif (ctrl & JZ_RTC_CTRL_1HZ)\n\t\tevents |= (RTC_UF | RTC_IRQF);\n\n\tif (ctrl & JZ_RTC_CTRL_AF)\n\t\tevents |= (RTC_AF | RTC_IRQF);\n\n\trtc_update_irq(rtc->rtc, 1, events);\n\n\tjz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF, false);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void jz4740_rtc_poweroff(struct device *dev)\n{\n\tstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\n\tjz4740_rtc_reg_write(rtc, JZ_REG_RTC_HIBERNATE, 1);\n}\n\nstatic void jz4740_rtc_power_off(void)\n{\n\tjz4740_rtc_poweroff(dev_for_power_off);\n\tkernel_halt();\n}\n\nstatic const struct of_device_id jz4740_rtc_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-rtc\", .data = (void *)ID_JZ4740 },\n\t{ .compatible = \"ingenic,jz4760-rtc\", .data = (void *)ID_JZ4760 },\n\t{ .compatible = \"ingenic,jz4770-rtc\", .data = (void *)ID_JZ4780 },\n\t{ .compatible = \"ingenic,jz4780-rtc\", .data = (void *)ID_JZ4780 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4740_rtc_of_match);\n\nstatic void jz4740_rtc_set_wakeup_params(struct jz4740_rtc *rtc,\n\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t unsigned long rate)\n{\n\tunsigned long wakeup_ticks, reset_ticks;\n\tunsigned int min_wakeup_pin_assert_time = 60;  \n\tunsigned int reset_pin_assert_time = 100;  \n\n\tof_property_read_u32(np, \"ingenic,reset-pin-assert-time-ms\",\n\t\t\t     &reset_pin_assert_time);\n\tof_property_read_u32(np, \"ingenic,min-wakeup-pin-assert-time-ms\",\n\t\t\t     &min_wakeup_pin_assert_time);\n\n\t \n\twakeup_ticks = (min_wakeup_pin_assert_time * rate) / 1000;\n\tif (wakeup_ticks < JZ_RTC_WAKEUP_FILTER_MASK)\n\t\twakeup_ticks &= JZ_RTC_WAKEUP_FILTER_MASK;\n\telse\n\t\twakeup_ticks = JZ_RTC_WAKEUP_FILTER_MASK;\n\tjz4740_rtc_reg_write(rtc, JZ_REG_RTC_WAKEUP_FILTER, wakeup_ticks);\n\n\t \n\treset_ticks = (reset_pin_assert_time * rate) / 1000;\n\tif (reset_ticks < JZ_RTC_RESET_COUNTER_MASK)\n\t\treset_ticks &= JZ_RTC_RESET_COUNTER_MASK;\n\telse\n\t\treset_ticks = JZ_RTC_RESET_COUNTER_MASK;\n\tjz4740_rtc_reg_write(rtc, JZ_REG_RTC_RESET_COUNTER, reset_ticks);\n}\n\nstatic int jz4740_rtc_clk32k_enable(struct clk_hw *hw)\n{\n\tstruct jz4740_rtc *rtc = container_of(hw, struct jz4740_rtc, clk32k);\n\n\treturn jz4740_rtc_reg_write(rtc, JZ_REG_RTC_CKPCR,\n\t\t\t\t    JZ_RTC_CKPCR_CK32PULL_DIS |\n\t\t\t\t    JZ_RTC_CKPCR_CK32CTL_EN);\n}\n\nstatic void jz4740_rtc_clk32k_disable(struct clk_hw *hw)\n{\n\tstruct jz4740_rtc *rtc = container_of(hw, struct jz4740_rtc, clk32k);\n\n\tjz4740_rtc_reg_write(rtc, JZ_REG_RTC_CKPCR, 0);\n}\n\nstatic int jz4740_rtc_clk32k_is_enabled(struct clk_hw *hw)\n{\n\tstruct jz4740_rtc *rtc = container_of(hw, struct jz4740_rtc, clk32k);\n\tu32 ckpcr;\n\n\tckpcr = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CKPCR);\n\n\treturn !!(ckpcr & JZ_RTC_CKPCR_CK32CTL_EN);\n}\n\nstatic const struct clk_ops jz4740_rtc_clk32k_ops = {\n\t.enable = jz4740_rtc_clk32k_enable,\n\t.disable = jz4740_rtc_clk32k_disable,\n\t.is_enabled = jz4740_rtc_clk32k_is_enabled,\n};\n\nstatic int jz4740_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct jz4740_rtc *rtc;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret, irq;\n\n\trtc = devm_kzalloc(dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->type = (uintptr_t)device_get_match_data(dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base))\n\t\treturn PTR_ERR(rtc->base);\n\n\tclk = devm_clk_get_enabled(dev, \"rtc\");\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"Failed to get RTC clock\\n\");\n\n\tspin_lock_init(&rtc->lock);\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\tdevice_init_wakeup(dev, 1);\n\n\tret = dev_pm_set_wake_irq(dev, irq);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set wake irq\\n\");\n\n\trtc->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc->rtc))\n\t\treturn dev_err_probe(dev, PTR_ERR(rtc->rtc),\n\t\t\t\t     \"Failed to allocate rtc device\\n\");\n\n\trtc->rtc->ops = &jz4740_rtc_ops;\n\trtc->rtc->range_max = U32_MAX;\n\n\trate = clk_get_rate(clk);\n\tjz4740_rtc_set_wakeup_params(rtc, np, rate);\n\n\t \n\tjz4740_rtc_reg_write(rtc, JZ_REG_RTC_REGULATOR, rate - 1);\n\n\tret = devm_rtc_register_device(rtc->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, irq, jz4740_rtc_irq, 0,\n\t\t\t       pdev->name, rtc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request rtc irq\\n\");\n\n\tif (of_device_is_system_power_controller(np)) {\n\t\tdev_for_power_off = dev;\n\n\t\tif (!pm_power_off)\n\t\t\tpm_power_off = jz4740_rtc_power_off;\n\t\telse\n\t\t\tdev_warn(dev, \"Poweroff handler already present!\\n\");\n\t}\n\n\tif (device_property_present(dev, \"#clock-cells\")) {\n\t\trtc->clk32k.init = CLK_HW_INIT_HW(\"clk32k\", __clk_get_hw(clk),\n\t\t\t\t\t\t  &jz4740_rtc_clk32k_ops, 0);\n\n\t\tret = devm_clk_hw_register(dev, &rtc->clk32k);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Unable to register clk32k clock\\n\");\n\n\t\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t\t  &rtc->clk32k);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Unable to register clk32k clock provider\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver jz4740_rtc_driver = {\n\t.probe\t = jz4740_rtc_probe,\n\t.driver\t = {\n\t\t.name  = \"jz4740-rtc\",\n\t\t.of_match_table = jz4740_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(jz4740_rtc_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RTC driver for the JZ4740 SoC\\n\");\nMODULE_ALIAS(\"platform:jz4740-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}