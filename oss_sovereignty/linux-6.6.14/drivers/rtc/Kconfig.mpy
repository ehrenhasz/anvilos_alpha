{
  "module_name": "Kconfig",
  "hash_id": "512a7a21f91f81559edb57f37a002103fb0cbf42f9fa1cc63db5d4c228b0969d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# RTC class/drivers configuration\n#\n\nconfig RTC_LIB\n\tbool\n\nconfig RTC_MC146818_LIB\n\tbool\n\tselect RTC_LIB\n\nmenuconfig RTC_CLASS\n\tbool \"Real Time Clock\"\n\tdefault n\n\tdepends on !S390\n\tselect RTC_LIB\n\thelp\n\t  Generic RTC class support. If you say yes here, you will\n\t  be allowed to plug one or more RTCs to your system. You will\n\t  probably want to enable one or more of the interfaces below.\n\nif RTC_CLASS\n\nconfig RTC_HCTOSYS\n\tbool \"Set system time from RTC on startup and resume\"\n\tdefault y\n\thelp\n\t  If you say yes here, the system time (wall clock) will be set using\n\t  the value read from a specified RTC device. This is useful to avoid\n\t  unnecessary fsck runs at boot time, and to network better.\n\nconfig RTC_HCTOSYS_DEVICE\n\tstring \"RTC used to set the system time\"\n\tdepends on RTC_HCTOSYS\n\tdefault \"rtc0\"\n\thelp\n\t  The RTC device that will be used to (re)initialize the system\n\t  clock, usually rtc0. Initialization is done when the system\n\t  starts up, and when it resumes from a low power state. This\n\t  device should record time in UTC, since the kernel won't do\n\t  timezone correction.\n\n\t  This clock should be battery-backed, so that it reads the correct\n\t  time when the system boots from a power-off state. Otherwise, your\n\t  system will need an external clock source (like an NTP server).\n\n\t  If the clock you specify here is not battery backed, it may still\n\t  be useful to reinitialize system time when resuming from system\n\t  sleep states. Do not specify an RTC here unless it stays powered\n\t  during all this system's supported sleep states.\n\nconfig RTC_SYSTOHC\n\tbool \"Set the RTC time based on NTP synchronization\"\n\tdefault y\n\thelp\n\t  If you say yes here, the system time (wall clock) will be stored\n\t  in the RTC specified by RTC_HCTOSYS_DEVICE approximately every 11\n\t  minutes if userspace reports synchronized NTP status.\n\nconfig RTC_SYSTOHC_DEVICE\n\tstring \"RTC used to synchronize NTP adjustment\"\n\tdepends on RTC_SYSTOHC\n\tdefault RTC_HCTOSYS_DEVICE if RTC_HCTOSYS\n\tdefault \"rtc0\"\n\thelp\n\t  The RTC device used for NTP synchronization. The main difference\n\t  between RTC_HCTOSYS_DEVICE and RTC_SYSTOHC_DEVICE is that this\n\t  one can sleep when setting time, because it runs in the workqueue\n\t  context.\n\nconfig RTC_DEBUG\n\tbool \"RTC debug support\"\n\thelp\n\t  Say yes here to enable debugging support in the RTC framework\n\t  and individual RTC drivers.\n\nconfig RTC_LIB_KUNIT_TEST\n\ttristate \"KUnit test for RTC lib functions\" if !KUNIT_ALL_TESTS\n\tdepends on KUNIT\n\tdefault KUNIT_ALL_TESTS\n\thelp\n\t  Enable this option to test RTC library functions.\n\n\t  If unsure, say N.\n\nconfig RTC_NVMEM\n\tbool \"RTC non volatile storage support\"\n\tselect NVMEM\n\tdefault RTC_CLASS\n\thelp\n\t  Say yes here to add support for the non volatile (often battery\n\t  backed) storage present on RTCs.\n\ncomment \"RTC interfaces\"\n\nconfig RTC_INTF_SYSFS\n\tbool \"/sys/class/rtc/rtcN (sysfs)\"\n\tdepends on SYSFS\n\tdefault RTC_CLASS\n\thelp\n\t  Say yes here if you want to use your RTCs using sysfs interfaces,\n\t  /sys/class/rtc/rtc0 through /sys/.../rtcN.\n\n\t  If unsure, say Y.\n\nconfig RTC_INTF_PROC\n\tbool \"/proc/driver/rtc (procfs for rtcN)\"\n\tdepends on PROC_FS\n\tdefault RTC_CLASS\n\thelp\n\t  Say yes here if you want to use your system clock RTC through\n\t  the proc interface, /proc/driver/rtc.\n\t  Other RTCs will not be available through that API.\n\t  If there is no RTC for the system clock, then the first RTC(rtc0)\n\t  is used by default.\n\n\t  If unsure, say Y.\n\nconfig RTC_INTF_DEV\n\tbool \"/dev/rtcN (character devices)\"\n\tdefault RTC_CLASS\n\thelp\n\t  Say yes here if you want to use your RTCs using the /dev\n\t  interfaces, which \"udev\" sets up as /dev/rtc0 through\n\t  /dev/rtcN.\n\n\t  You may want to set up a symbolic link so one of these\n\t  can be accessed as /dev/rtc, which is a name\n\t  expected by \"hwclock\" and some other programs. Recent\n\t  versions of \"udev\" are known to set up the symlink for you.\n\n\t  If unsure, say Y.\n\nconfig RTC_INTF_DEV_UIE_EMUL\n\tbool \"RTC UIE emulation on dev interface\"\n\tdepends on RTC_INTF_DEV\n\thelp\n\t  Provides an emulation for RTC_UIE if the underlying rtc chip\n\t  driver does not expose RTC_UIE ioctls. Those requests generate\n\t  once-per-second update interrupts, used for synchronization.\n\n\t  The emulation code will read the time from the hardware\n\t  clock several times per second, please enable this option\n\t  only if you know that you really need it.\n\nconfig RTC_DRV_TEST\n\ttristate \"Test driver/device\"\n\thelp\n\t  If you say yes here you get support for the\n\t  RTC test driver. It's a software RTC which can be\n\t  used to test the RTC subsystem APIs. It gets\n\t  the time from the system clock.\n\t  You want this driver only if you are doing development\n\t  on the RTC subsystem. Please read the source code\n\t  for further details.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-test.\n\ncomment \"I2C RTC drivers\"\n\nif I2C\n\nconfig RTC_DRV_88PM860X\n\ttristate \"Marvell 88PM860x\"\n\tdepends on MFD_88PM860X\n\thelp\n\t  If you say yes here you get support for RTC function in Marvell\n\t  88PM860x chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-88pm860x.\n\nconfig RTC_DRV_88PM80X\n\ttristate \"Marvell 88PM80x\"\n\tdepends on MFD_88PM800\n\thelp\n\t  If you say yes here you get support for RTC function in Marvell\n\t  88PM80x chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-88pm80x.\n\nconfig RTC_DRV_ABB5ZES3\n\tselect REGMAP_I2C\n\ttristate \"Abracon AB-RTCMC-32.768kHz-B5ZE-S3\"\n\thelp\n\t  If you say yes here you get support for the Abracon\n\t  AB-RTCMC-32.768kHz-B5ZE-S3 I2C RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ab-b5ze-s3.\n\nconfig RTC_DRV_ABEOZ9\n\tselect REGMAP_I2C\n\ttristate \"Abracon AB-RTCMC-32.768kHz-EOZ9\"\n\thelp\n\t  If you say yes here you get support for the Abracon\n\t  AB-RTCMC-32.768kHz-EOA9 I2C RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ab-e0z9.\n\nconfig RTC_DRV_ABX80X\n\ttristate \"Abracon ABx80x\"\n\tselect WATCHDOG_CORE if WATCHDOG\n\thelp\n\t  If you say yes here you get support for Abracon AB080X and AB180X\n\t  families of ultra-low-power  battery- and capacitor-backed real-time\n\t  clock chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-abx80x.\n\nconfig RTC_DRV_AC100\n\ttristate \"X-Powers AC100\"\n\tdepends on MFD_AC100\n\thelp\n\t  If you say yes here you get support for the real-time clock found\n\t  in X-Powers AC100 family peripheral ICs.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ac100.\n\nconfig RTC_DRV_BRCMSTB\n\ttristate \"Broadcom STB wake-timer\"\n\tdepends on ARCH_BRCMSTB || BMIPS_GENERIC || COMPILE_TEST\n\tdefault ARCH_BRCMSTB || BMIPS_GENERIC\n\thelp\n\t  If you say yes here you get support for the wake-timer found on\n\t  Broadcom STB SoCs (BCM7xxx).\n\n\t  This driver can also be built as a module. If so, the module will\n\t  be called rtc-brcmstb-waketimer.\n\nconfig RTC_DRV_AS3722\n\ttristate \"ams AS3722 RTC driver\"\n\tdepends on MFD_AS3722\n\thelp\n\t  If you say yes here you get support for the RTC of ams AS3722 PMIC\n\t  chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-as3722.\n\nconfig RTC_DRV_DS1307\n\ttristate \"Dallas/Maxim DS1307/37/38/39/40/41, ST M41T00, EPSON RX-8025, ISL12057\"\n\tselect REGMAP_I2C\n\tselect WATCHDOG_CORE if WATCHDOG\n\thelp\n\t  If you say yes here you get support for various compatible RTC\n\t  chips (often with battery backup) connected with I2C. This driver\n\t  should handle DS1307, DS1337, DS1338, DS1339, DS1340, DS1341,\n\t  ST M41T00, EPSON RX-8025, Intersil ISL12057 and probably other chips.\n\t  In some cases the RTC must already have been initialized (by\n\t  manufacturing or a bootloader).\n\n\t  The first seven registers on these chips hold an RTC, and other\n\t  registers may add features such as NVRAM, a trickle charger for\n\t  the RTC/NVRAM backup power, and alarms. NVRAM is visible in\n\t  sysfs, but other chip features may not be available.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1307.\n\nconfig RTC_DRV_DS1307_CENTURY\n\tbool \"Century bit support for rtc-ds1307\"\n\tdepends on RTC_DRV_DS1307\n\tdefault n\n\thelp\n\t  The DS1307 driver suffered from a bug where it was enabling the\n\t  century bit inconditionnally but never used it when reading the time.\n\t  It made the driver unable to support dates beyond 2099.\n\t  Setting this option will add proper support for the century bit but if\n\t  the time was previously set using a kernel predating this option,\n\t  reading the date will return a date in the next century.\n\t  To solve that, you could boot a kernel without this option set, set\n\t  the RTC date and then boot a kernel with this option set.\n\nconfig RTC_DRV_DS1374\n\ttristate \"Dallas/Maxim DS1374\"\n\thelp\n\t  If you say yes here you get support for Dallas Semiconductor\n\t  DS1374 real-time clock chips. If an interrupt is associated\n\t  with the device, the alarm functionality is supported.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1374.\n\nconfig RTC_DRV_DS1374_WDT\n\tbool \"Dallas/Maxim DS1374 watchdog timer\"\n\tdepends on RTC_DRV_DS1374 && WATCHDOG\n\tselect WATCHDOG_CORE\n\thelp\n\t  If you say Y here you will get support for the\n\t  watchdog timer in the Dallas Semiconductor DS1374\n\t  real-time clock chips.\n\nconfig RTC_DRV_DS1672\n\ttristate \"Dallas/Maxim DS1672\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas/Maxim DS1672 timekeeping chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1672.\n\nconfig RTC_DRV_HYM8563\n\ttristate \"Haoyu Microelectronics HYM8563\"\n\tdepends on OF\n\thelp\n\t  Say Y to enable support for the HYM8563 I2C RTC chip. Apart\n\t  from the usual rtc functions it provides a clock output of\n\t  up to 32kHz.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-hym8563.\n\nconfig RTC_DRV_LP8788\n\ttristate \"TI LP8788 RTC driver\"\n\tdepends on MFD_LP8788\n\thelp\n\t  Say Y to enable support for the LP8788 RTC/ALARM driver.\n\nconfig RTC_DRV_MAX6900\n\ttristate \"Maxim MAX6900\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  Maxim MAX6900 I2C RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max6900.\n\nconfig RTC_DRV_MAX8907\n\ttristate \"Maxim MAX8907\"\n\tdepends on MFD_MAX8907 || COMPILE_TEST\n\tselect REGMAP_IRQ\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Maxim MAX8907 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max8907.\n\nconfig RTC_DRV_MAX8925\n\ttristate \"Maxim MAX8925\"\n\tdepends on MFD_MAX8925\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Maxim MAX8925 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max8925.\n\nconfig RTC_DRV_MAX8998\n\ttristate \"Maxim MAX8998\"\n\tdepends on MFD_MAX8998\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Maxim MAX8998 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max8998.\n\nconfig RTC_DRV_MAX8997\n\ttristate \"Maxim MAX8997\"\n\tdepends on MFD_MAX8997\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Maxim MAX8997 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max8997.\n\nconfig RTC_DRV_MAX77686\n\ttristate \"Maxim MAX77686\"\n\tdepends on MFD_MAX77686 || MFD_MAX77620 || MFD_MAX77714 || COMPILE_TEST\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Maxim MAX77686/MAX77620/MAX77802 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max77686.\n\nconfig RTC_DRV_NCT3018Y\n\ttristate \"Nuvoton NCT3018Y\"\n\tdepends on OF\n\thelp\n\t   If you say yes here you get support for the Nuvoton NCT3018Y I2C RTC\n\t   chip.\n\n\t   This driver can also be built as a module, if so, the module will be\n\t   called \"rtc-nct3018y\".\n\nconfig RTC_DRV_RK808\n\ttristate \"Rockchip RK805/RK808/RK809/RK817/RK818 RTC\"\n\tdepends on MFD_RK8XX\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of RK805, RK809 and RK817, RK808 and RK818 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rk808-rtc.\n\nconfig RTC_DRV_RS5C372\n\ttristate \"Ricoh R2025S/D, RS5C372A/B, RV5C386, RV5C387A\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Ricoh R2025S/D, RS5C372A, RS5C372B, RV5C386, and RV5C387A RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rs5c372.\n\nconfig RTC_DRV_ISL1208\n\ttristate \"Intersil ISL1208\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Intersil ISL1208 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-isl1208.\n\nconfig RTC_DRV_ISL12022\n\ttristate \"Intersil ISL12022\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the\n\t  Intersil ISL12022 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-isl12022.\n\nconfig RTC_DRV_ISL12026\n\ttristate \"Intersil ISL12026\"\n\tdepends on OF\n\thelp\n\t  If you say yes here you get support for the\n\t  Intersil ISL12026 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-isl12026.\n\nconfig RTC_DRV_X1205\n\ttristate \"Xicor/Intersil X1205\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Xicor/Intersil X1205 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-x1205.\n\nconfig RTC_DRV_PCF8523\n\ttristate \"NXP PCF8523\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the NXP PCF8523 RTC\n\t  chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf8523.\n\nconfig RTC_DRV_PCF85063\n\ttristate \"NXP PCF85063\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the PCF85063 RTC chip\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf85063.\n\nconfig RTC_DRV_PCF85363\n\ttristate \"NXP PCF85363\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the PCF85363 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf85363.\n\n\t  The nvmem interface will be named pcf85363-#, where # is the\n\t  zero-based instance number.\n\nconfig RTC_DRV_PCF8563\n\ttristate \"Philips PCF8563/Epson RTC8564\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Philips PCF8563 RTC chip. The Epson RTC8564\n\t  should work as well.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf8563.\n\nconfig RTC_DRV_PCF8583\n\ttristate \"Philips PCF8583\"\n\thelp\n\t  If you say yes here you get support for the Philips PCF8583\n\t  RTC chip found on Acorn RiscPCs. This driver supports the\n\t  platform specific method of retrieving the current year from\n\t  the RTC's SRAM. It will work on other platforms with the same\n\t  chip, but the year will probably have to be tweaked.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf8583.\n\nconfig RTC_DRV_M41T80\n\ttristate \"ST M41T62/65/M41T80/81/82/83/84/85/87 and compatible\"\n\thelp\n\t  If you say Y here you will get support for the ST M41T60\n\t  and M41T80 RTC chips series. Currently, the following chips are\n\t  supported: M41T62, M41T65, M41T80, M41T81, M41T82, M41T83, M41ST84,\n\t  M41ST85, M41ST87, and MicroCrystal RV4162.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-m41t80.\n\nconfig RTC_DRV_M41T80_WDT\n\tbool \"ST M41T65/M41T80 series RTC watchdog timer\"\n\tdepends on RTC_DRV_M41T80\n\thelp\n\t  If you say Y here you will get support for the\n\t  watchdog timer in the ST M41T60 and M41T80 RTC chips series.\n\nconfig RTC_DRV_BD70528\n\ttristate \"ROHM BD71815 and BD71828 PMIC RTC\"\n\tdepends on MFD_ROHM_BD71828\n\thelp\n\t  If you say Y here you will get support for the RTC\n\t  block on ROHM BD71815 and BD71828 Power Management IC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-bd70528.\n\nconfig RTC_DRV_BQ32K\n\ttristate \"TI BQ32000\"\n\thelp\n\t  If you say Y here you will get support for the TI\n\t  BQ32000 I2C RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-bq32k.\n\nconfig RTC_DRV_TWL92330\n\tbool \"TI TWL92330/Menelaus\"\n\tdepends on MENELAUS\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  TWL92330 \"Menelaus\" power management chip, used with OMAP2\n\t  platforms. The support is integrated with the rest of\n\t  the Menelaus driver; it's not separate module.\n\nconfig RTC_DRV_TWL4030\n\ttristate \"TI TWL4030/TWL5030/TWL6030/TPS659x0\"\n\tdepends on TWL4030_CORE\n\tdepends on OF\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  TWL4030/TWL5030/TWL6030 family chips, used mostly with OMAP3 platforms.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-twl.\n\nconfig RTC_DRV_PALMAS\n\ttristate \"TI Palmas RTC driver\"\n\tdepends on MFD_PALMAS\n\thelp\n\t  If you say yes here you get support for the RTC of TI PALMA series PMIC\n\t  chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-palma.\n\nconfig RTC_DRV_TPS6586X\n\ttristate \"TI TPS6586X RTC driver\"\n\tdepends on MFD_TPS6586X\n\thelp\n\t  TI Power Management IC TPS6586X supports RTC functionality\n\t  along with alarm. This driver supports the RTC driver for\n\t  the TPS6586X RTC module.\n\nconfig RTC_DRV_TPS65910\n\ttristate \"TI TPS65910 RTC driver\"\n\tdepends on MFD_TPS65910\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  TPS65910 chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-tps65910.\n\nconfig RTC_DRV_RC5T583\n\ttristate \"RICOH 5T583 RTC driver\"\n\tdepends on MFD_RC5T583\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  RICOH 5T583 chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rc5t583.\n\nconfig RTC_DRV_RC5T619\n\ttristate \"RICOH RC5T619 RTC driver\"\n\tdepends on MFD_RN5T618\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  RICOH RC5T619 chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rc5t619.\n\nconfig RTC_DRV_S35390A\n\ttristate \"Seiko Instruments S-35390A\"\n\tselect BITREVERSE\n\thelp\n\t  If you say yes here you will get support for the Seiko\n\t  Instruments S-35390A.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-s35390a.\n\nconfig RTC_DRV_FM3130\n\ttristate \"Ramtron FM3130\"\n\thelp\n\t  If you say Y here you will get support for the\n\t  Ramtron FM3130 RTC chips.\n\t  Ramtron FM3130 is a chip with two separate devices inside,\n\t  RTC clock and FRAM. This driver provides only RTC functionality.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-fm3130.\n\nconfig RTC_DRV_RX8010\n\ttristate \"Epson RX8010SJ\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the Epson RX8010SJ RTC\n\t  chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rx8010.\n\nconfig RTC_DRV_RX8581\n\ttristate \"Epson RX-8571/RX-8581\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you will get support for the Epson RX-8571/\n\t  RX-8581.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-rx8581.\n\nconfig RTC_DRV_RX8025\n\ttristate \"Epson RX-8025SA/NB\"\n\thelp\n\t  If you say yes here you get support for the Epson\n\t  RX-8025SA/NB RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rx8025.\n\nconfig RTC_DRV_EM3027\n\ttristate \"EM Microelectronic EM3027\"\n\thelp\n\t  If you say yes here you get support for the EM\n\t  Microelectronic EM3027 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-em3027.\n\nconfig RTC_DRV_RV3028\n\ttristate \"Micro Crystal RV3028\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the Micro Crystal\n\t  RV3028.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rv3028.\n\nconfig RTC_DRV_RV3032\n\ttristate \"Micro Crystal RV3032\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the Micro Crystal\n\t  RV3032.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rv3032.\n\nconfig RTC_DRV_RV8803\n\ttristate \"Micro Crystal RV8803, Epson RX8900\"\n\thelp\n\t  If you say yes here you get support for the Micro Crystal RV8803 and\n\t  Epson RX8900 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rv8803.\n\nconfig RTC_DRV_S5M\n\ttristate \"Samsung S2M/S5M series\"\n\tdepends on MFD_SEC_CORE || COMPILE_TEST\n\tselect REGMAP_IRQ\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of Samsung S2MPS14 and S5M PMIC series.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-s5m.\n\nconfig RTC_DRV_SD3078\n\ttristate \"ZXW Shenzhen whwave SD3078\"\n\tselect REGMAP_I2C\n\thelp\n\t  If you say yes here you get support for the ZXW Shenzhen whwave\n\t  SD3078 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-sd3078\n\nendif # I2C\n\ncomment \"SPI RTC drivers\"\n\nif SPI_MASTER\n\nconfig RTC_DRV_M41T93\n\ttristate \"ST M41T93\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  ST M41T93 SPI RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-m41t93.\n\nconfig RTC_DRV_M41T94\n\ttristate \"ST M41T94\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  ST M41T94 SPI RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-m41t94.\n\nconfig RTC_DRV_DS1302\n\ttristate \"Dallas/Maxim DS1302\"\n\tdepends on SPI\n\thelp\n\t  If you say yes here you get support for the Dallas DS1302 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1302.\n\nconfig RTC_DRV_DS1305\n\ttristate \"Dallas/Maxim DS1305/DS1306\"\n\thelp\n\t  Select this driver to get support for the Dallas/Maxim DS1305\n\t  and DS1306 real time clock chips. These support a trickle\n\t  charger, alarms, and NVRAM in addition to the clock.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1305.\n\nconfig RTC_DRV_DS1343\n\tselect REGMAP_SPI\n\ttristate \"Dallas/Maxim DS1343/DS1344\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas/Maxim DS1343 and DS1344 real time clock chips.\n\t  Support for trickle charger, alarm is provided.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1343.\n\nconfig RTC_DRV_DS1347\n\tselect REGMAP_SPI\n\ttristate \"Dallas/Maxim DS1347\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas/Maxim DS1347 chips.\n\n\t  This driver only supports the RTC feature, and not other chip\n\t  features such as alarms.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1347.\n\nconfig RTC_DRV_DS1390\n\ttristate \"Dallas/Maxim DS1390/93/94\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas/Maxim DS1390/93/94 chips.\n\n\t  This driver supports the RTC feature and trickle charging but not\n\t  other chip features such as alarms.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1390.\n\nconfig RTC_DRV_MAX6916\n\ttristate \"Maxim MAX6916\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  Maxim MAX6916 SPI RTC chip.\n\n\t  This driver only supports the RTC feature, and not other chip\n\t  features such as alarms.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max6916.\n\nconfig RTC_DRV_R9701\n\ttristate \"Epson RTC-9701JE\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  Epson RTC-9701JE SPI RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-r9701.\n\nconfig RTC_DRV_RX4581\n\ttristate \"Epson RX-4581\"\n\thelp\n\t  If you say yes here you will get support for the Epson RX-4581.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-rx4581.\n\nconfig RTC_DRV_RS5C348\n\ttristate \"Ricoh RS5C348A/B\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Ricoh RS5C348A and RS5C348B RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rs5c348.\n\nconfig RTC_DRV_MAX6902\n\ttristate \"Maxim MAX6902\"\n\thelp\n\t  If you say yes here you will get support for the\n\t  Maxim MAX6902 SPI RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-max6902.\n\nconfig RTC_DRV_PCF2123\n\ttristate \"NXP PCF2123\"\n\tselect REGMAP_SPI\n\thelp\n\t  If you say yes here you get support for the NXP PCF2123\n\t  RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf2123.\n\nconfig RTC_DRV_MCP795\n\ttristate \"Microchip MCP795\"\n\thelp\n\t  If you say yes here you will get support for the Microchip MCP795.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-mcp795.\n\nendif # SPI_MASTER\n\n#\n# Helper to resolve issues with configs that have SPI enabled but I2C\n# modular.  See SND_SOC_I2C_AND_SPI for more information\n#\nconfig RTC_I2C_AND_SPI\n\ttristate\n\tdefault m if I2C=m\n\tdefault y if I2C=y\n\tdefault y if SPI_MASTER=y\n\ncomment \"SPI and I2C RTC drivers\"\n\nconfig RTC_DRV_DS3232\n\ttristate \"Dallas/Maxim DS3232/DS3234\"\n\tdepends on RTC_I2C_AND_SPI\n\tselect REGMAP_I2C if I2C\n\tselect REGMAP_SPI if SPI_MASTER\n\thelp\n\t  If you say yes here you get support for Dallas Semiconductor\n\t  DS3232 and DS3234 real-time clock chips. If an interrupt is associated\n\t  with the device, the alarm functionality is supported.\n\n\t  This driver can also be built as a module.  If so, the module\n\t  will be called rtc-ds3232.\n\nconfig RTC_DRV_DS3232_HWMON\n\tbool \"HWMON support for Dallas/Maxim DS3232/DS3234\"\n\tdepends on RTC_DRV_DS3232 && HWMON && !(RTC_DRV_DS3232=y && HWMON=m)\n\tdefault y\n\thelp\n\t  Say Y here if you want to expose temperature sensor data on\n\t  rtc-ds3232\n\nconfig RTC_DRV_PCF2127\n\ttristate \"NXP PCF2127\"\n\tdepends on RTC_I2C_AND_SPI\n\tselect REGMAP_I2C if I2C\n\tselect REGMAP_SPI if SPI_MASTER\n\tselect WATCHDOG_CORE if WATCHDOG\n\thelp\n\t  If you say yes here you get support for the NXP PCF2127/29/31 RTC\n\t  chips with integrated quartz crystal for industrial applications.\n\t  These chips also have watchdog timer and tamper switch detection\n\t  features.\n\n\t  PCF2127 has an additional feature of 512 bytes battery backed\n\t  memory that's accessible using nvmem interface.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-pcf2127.\n\nconfig RTC_DRV_RV3029C2\n\ttristate \"Micro Crystal RV3029/3049\"\n\tdepends on RTC_I2C_AND_SPI\n\tselect REGMAP_I2C if I2C\n\tselect REGMAP_SPI if SPI_MASTER\n\thelp\n\t  If you say yes here you get support for the Micro Crystal\n\t  RV3029 and RV3049 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rv3029c2.\n\nconfig RTC_DRV_RV3029_HWMON\n\tbool \"HWMON support for RV3029/3049\"\n\tdepends on RTC_DRV_RV3029C2 && HWMON\n\tdepends on !(RTC_DRV_RV3029C2=y && HWMON=m)\n\tdefault y\n\thelp\n\t  Say Y here if you want to expose temperature sensor data on\n\t  rtc-rv3029.\n\nconfig RTC_DRV_RX6110\n\ttristate \"Epson RX-6110\"\n\tdepends on RTC_I2C_AND_SPI\n\tselect REGMAP_SPI if SPI_MASTER\n\tselect REGMAP_I2C if I2C\n\thelp\n\t  If you say yes here you will get support for the Epson RX-6110.\n\n\t  This driver can also be built as a module. If so the module\n\t  will be called rtc-rx6110.\n\ncomment \"Platform RTC drivers\"\n\n# this 'CMOS' RTC driver is arch dependent because it requires\n# <asm/mc146818rtc.h> defining CMOS_READ/CMOS_WRITE, and a\n# global rtc_lock ... it's not yet just another platform_device.\n\nconfig RTC_DRV_CMOS\n\ttristate \"PC-style 'CMOS'\"\n\tdepends on X86 || ARM || PPC || MIPS || SPARC64\n\tdepends on HAS_IOPORT || MACH_DECSTATION\n\tdefault y if X86\n\tselect RTC_MC146818_LIB\n\thelp\n\t  Say \"yes\" here to get direct support for the real time clock\n\t  found in every PC or ACPI-based system, and some other boards.\n\t  Specifically the original MC146818, compatibles like those in\n\t  PC south bridges, the DS12887 or M48T86, some multifunction\n\t  or LPC bus chips, and so on.\n\n\t  Your system will need to define the platform device used by\n\t  this driver, otherwise it won't be accessible. This means\n\t  you can safely enable this driver if you don't know whether\n\t  or not your board has this kind of hardware.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-cmos.\n\nconfig RTC_DRV_ALPHA\n\tbool \"Alpha PC-style CMOS\"\n\tdepends on ALPHA\n\tdepends on HAS_IOPORT\n\tselect RTC_MC146818_LIB\n\tdefault y\n\thelp\n\t  Direct support for the real-time clock found on every Alpha\n\t  system, specifically MC146818 compatibles.  If in doubt, say Y.\n\nconfig RTC_DRV_DS1216\n\ttristate \"Dallas DS1216\"\n\tdepends on SNI_RM\n\thelp\n\t  If you say yes here you get support for the Dallas DS1216 RTC chips.\n\nconfig RTC_DRV_DS1286\n\ttristate \"Dallas DS1286\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the Dallas DS1286 RTC chips.\n\nconfig RTC_DRV_DS1511\n\ttristate \"Dallas DS1511\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas DS1511 timekeeping/watchdog chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1511.\n\nconfig RTC_DRV_DS1553\n\ttristate \"Maxim/Dallas DS1553\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the\n\t  Maxim/Dallas DS1553 timekeeping chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1553.\n\nconfig RTC_DRV_DS1685_FAMILY\n\ttristate \"Dallas/Maxim DS1685 Family\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the Dallas/Maxim DS1685\n\t  family of real time chips.  This family includes the DS1685/DS1687,\n\t  DS1689/DS1693, DS17285/DS17287, DS17485/DS17487, and\n\t  DS17885/DS17887 chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1685.\n\nchoice\n\tprompt \"Subtype\"\n\tdepends on RTC_DRV_DS1685_FAMILY\n\tdefault RTC_DRV_DS1685\n\nconfig RTC_DRV_DS1685\n\tbool \"DS1685/DS1687\"\n\thelp\n\t  This enables support for the Dallas/Maxim DS1685/DS1687 real time\n\t  clock chip.\n\n\t  This chip is commonly found in SGI O2 (IP32) and SGI Octane (IP30)\n\t  systems, as well as EPPC-405-UC modules by electronic system design\n\t  GmbH.\n\nconfig RTC_DRV_DS1689\n\tbool \"DS1689/DS1693\"\n\thelp\n\t  This enables support for the Dallas/Maxim DS1689/DS1693 real time\n\t  clock chip.\n\n\t  This is an older RTC chip, supplanted by the DS1685/DS1687 above,\n\t  which supports a few minor features such as Vcc, Vbat, and Power\n\t  Cycle counters, plus a customer-specific, 8-byte ROM/Serial number.\n\n\t  It also works for the even older DS1688/DS1691 RTC chips, which are\n\t  virtually the same and carry the same model number.  Both chips\n\t  have 114 bytes of user NVRAM.\n\nconfig RTC_DRV_DS17285\n\tbool \"DS17285/DS17287\"\n\thelp\n\t  This enables support for the Dallas/Maxim DS17285/DS17287 real time\n\t  clock chip.\n\n\t  This chip features 2kb of extended NV-SRAM.  It may possibly be\n\t  found in some SGI O2 systems (rare).\n\nconfig RTC_DRV_DS17485\n\tbool \"DS17485/DS17487\"\n\thelp\n\t  This enables support for the Dallas/Maxim DS17485/DS17487 real time\n\t  clock chip.\n\n\t  This chip features 4kb of extended NV-SRAM.\n\nconfig RTC_DRV_DS17885\n\tbool \"DS17885/DS17887\"\n\thelp\n\t  This enables support for the Dallas/Maxim DS17885/DS17887 real time\n\t  clock chip.\n\n\t  This chip features 8kb of extended NV-SRAM.\n\nendchoice\n\nconfig RTC_DRV_DS1742\n\ttristate \"Maxim/Dallas DS1742/1743\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the\n\t  Maxim/Dallas DS1742/1743 timekeeping chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds1742.\n\nconfig RTC_DRV_DS2404\n\ttristate \"Maxim/Dallas DS2404\"\n\thelp\n\t  If you say yes here you get support for the\n\t  Dallas DS2404 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ds2404.\n\nconfig RTC_DRV_DA9052\n\ttristate \"Dialog DA9052/DA9053 RTC\"\n\tdepends on PMIC_DA9052\n\thelp\n\t  Say y here to support the RTC driver for Dialog Semiconductor\n\t  DA9052-BC and DA9053-AA/Bx PMICs.\n\nconfig RTC_DRV_DA9055\n\ttristate \"Dialog Semiconductor DA9055 RTC\"\n\tdepends on MFD_DA9055\n\thelp\n\t  If you say yes here you will get support for the\n\t  RTC of the Dialog DA9055 PMIC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-da9055\n\nconfig RTC_DRV_DA9063\n\ttristate \"Dialog Semiconductor DA9063/DA9062 RTC\"\n\tdepends on MFD_DA9063 || MFD_DA9062\n\thelp\n\t  If you say yes here you will get support for the RTC subsystem\n\t  for the Dialog Semiconductor PMIC chips DA9063 and DA9062.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called \"rtc-da9063\".\n\nconfig RTC_DRV_EFI\n\ttristate \"EFI RTC\"\n\tdepends on EFI && !X86\n\thelp\n\t  If you say yes here you will get support for the EFI\n\t  Real Time Clock.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-efi.\n\nconfig RTC_DRV_STK17TA8\n\ttristate \"Simtek STK17TA8\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the\n\t  Simtek STK17TA8 timekeeping chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-stk17ta8.\n\nconfig RTC_DRV_M48T86\n\ttristate \"ST M48T86/Dallas DS12887\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say Y here you will get support for the\n\t  ST M48T86 and Dallas DS12887 RTC chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-m48t86.\n\nconfig RTC_DRV_M48T35\n\ttristate \"ST M48T35\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say Y here you will get support for the\n\t  ST M48T35 RTC chip.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-m48t35\".\n\nconfig RTC_DRV_M48T59\n\ttristate \"ST M48T59/M48T08/M48T02\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say Y here you will get support for the\n\t  ST M48T59 RTC chip and compatible ST M48T08 and M48T02.\n\n\t  These chips are usually found in Sun SPARC and UltraSPARC\n\t  workstations.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-m48t59\".\n\nconfig RTC_DRV_MSM6242\n\ttristate \"Oki MSM6242\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the Oki MSM6242\n\t  timekeeping chip. It is used in some Amiga models (e.g. A2000).\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-msm6242.\n\nconfig RTC_DRV_BQ4802\n\ttristate \"TI BQ4802\"\n\tdepends on HAS_IOMEM && HAS_IOPORT\n\tdepends on SPARC || COMPILE_TEST\n\thelp\n\t  If you say Y here you will get support for the TI\n\t  BQ4802 RTC chip.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-bq4802.\n\nconfig RTC_DRV_RP5C01\n\ttristate \"Ricoh RP5C01\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the Ricoh RP5C01\n\t  timekeeping chip. It is used in some Amiga models (e.g. A3000\n\t  and A4000).\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-rp5c01.\n\nconfig RTC_DRV_GAMECUBE\n\ttristate \"Nintendo GameCube, Wii and Wii U RTC\"\n\tdepends on GAMECUBE || WII || COMPILE_TEST\n\tselect REGMAP\n\thelp\n\t  If you say yes here you will get support for the RTC subsystem\n\t  of the Nintendo GameCube, Wii and Wii U.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called \"rtc-gamecube\".\n\nconfig RTC_DRV_WM831X\n\ttristate \"Wolfson Microelectronics WM831x RTC\"\n\tdepends on MFD_WM831X\n\thelp\n\t  If you say yes here you will get support for the RTC subsystem\n\t  of the Wolfson Microelectronics WM831X series PMICs.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called \"rtc-wm831x\".\n\nconfig RTC_DRV_WM8350\n\ttristate \"Wolfson Microelectronics WM8350 RTC\"\n\tdepends on MFD_WM8350\n\thelp\n\t  If you say yes here you will get support for the RTC subsystem\n\t  of the Wolfson Microelectronics WM8350.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called \"rtc-wm8350\".\n\nconfig RTC_DRV_SC27XX\n\ttristate \"Spreadtrum SC27xx RTC\"\n\tdepends on MFD_SC27XX_PMIC || COMPILE_TEST\n\thelp\n\t  If you say Y here you will get support for the RTC subsystem\n\t  of the Spreadtrum SC27xx series PMICs. The SC27xx series PMICs\n\t  includes the SC2720, SC2721, SC2723, SC2730 and SC2731 chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-sc27xx.\n\nconfig RTC_DRV_SPEAR\n\ttristate \"SPEAR ST RTC\"\n\tdepends on PLAT_SPEAR || COMPILE_TEST\n\tdefault y\n\thelp\n\t If you say Y here you will get support for the RTC found on\n\t spear\n\nconfig RTC_DRV_PCF50633\n\tdepends on MFD_PCF50633\n\ttristate \"NXP PCF50633 RTC\"\n\thelp\n\t  If you say yes here you get support for the RTC subsystem of the\n\t  NXP PCF50633 used in embedded systems.\n\nconfig RTC_DRV_AB8500\n\ttristate \"ST-Ericsson AB8500 RTC\"\n\tdepends on AB8500_CORE\n\tselect RTC_INTF_DEV\n\tselect RTC_INTF_DEV_UIE_EMUL\n\thelp\n\t  Select this to enable the ST-Ericsson AB8500 power management IC RTC\n\t  support. This chip contains a battery- and capacitor-backed RTC.\n\nconfig RTC_DRV_OPAL\n\ttristate \"IBM OPAL RTC driver\"\n\tdepends on PPC_POWERNV\n\tdefault y\n\thelp\n\t  If you say yes here you get support for the PowerNV platform RTC\n\t  driver based on OPAL interfaces.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-opal.\n\nconfig RTC_DRV_OPTEE\n\ttristate \"OP-TEE based RTC driver\"\n\tdepends on OPTEE\n\thelp\n\t  Select this to get support for OP-TEE based RTC control on SoCs where\n\t  RTC are not accessible to the normal world (Linux).\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-optee.\n\nconfig RTC_DRV_ZYNQMP\n\ttristate \"Xilinx Zynq Ultrascale+ MPSoC RTC\"\n\tdepends on OF && HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the RTC controller found on\n\t  Xilinx Zynq Ultrascale+ MPSoC.\n\nconfig RTC_DRV_CROS_EC\n\ttristate \"Chrome OS EC RTC driver\"\n\tdepends on CROS_EC\n\thelp\n\t  If you say yes here you will get support for the\n\t  Chrome OS Embedded Controller's RTC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-cros-ec.\n\nconfig RTC_DRV_NTXEC\n\ttristate \"Netronix embedded controller RTC\"\n\tdepends on MFD_NTXEC\n\thelp\n\t  Say yes here if you want to support the RTC functionality of the\n\t  embedded controller found in certain e-book readers designed by the\n\t  original design manufacturer Netronix.\n\ncomment \"on-CPU RTC drivers\"\n\nconfig RTC_DRV_ASM9260\n\ttristate \"Alphascale asm9260 RTC\"\n\tdepends on MACH_ASM9260 || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the RTC on the\n\t  Alphascale asm9260 SoC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-asm9260.\n\nconfig RTC_DRV_DIGICOLOR\n\ttristate \"Conexant Digicolor RTC\"\n\tdepends on ARCH_DIGICOLOR || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the RTC on Conexant\n\t  Digicolor platforms. This currently includes the CX92755 SoC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-digicolor.\n\nconfig RTC_DRV_IMXDI\n\ttristate \"Freescale IMX DryIce Real Time Clock\"\n\tdepends on ARCH_MXC\n\tdepends on OF\n\thelp\n\t   Support for Freescale IMX DryIce RTC\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-imxdi\".\n\nconfig RTC_DRV_FSL_FTM_ALARM\n\ttristate \"Freescale FlexTimer alarm timer\"\n\tdepends on ARCH_LAYERSCAPE || SOC_LS1021A || COMPILE_TEST\n\thelp\n\t   For the FlexTimer in LS1012A, LS1021A, LS1028A, LS1043A, LS1046A,\n\t   LS1088A, LS208xA, we can use FTM as the wakeup source.\n\n\t   Say y here to enable FTM alarm support. The FTM alarm provides\n\t   alarm functions for wakeup system from deep sleep.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-fsl-ftm-alarm\".\n\nconfig RTC_DRV_MESON\n\ttristate \"Amlogic Meson RTC\"\n\tdepends on (ARM && ARCH_MESON) || COMPILE_TEST\n\tselect REGMAP_MMIO\n\thelp\n\t   Support for the RTC block on the Amlogic Meson6, Meson8, Meson8b\n\t   and Meson8m2 SoCs.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-meson\".\n\nconfig RTC_DRV_MESON_VRTC\n\ttristate \"Amlogic Meson Virtual RTC\"\n\tdepends on ARCH_MESON || COMPILE_TEST\n\tdefault m if ARCH_MESON\n\thelp\n\t  If you say yes here you will get support for the\n\t  Virtual RTC of Amlogic SoCs.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-meson-vrtc.\n\nconfig RTC_DRV_OMAP\n\ttristate \"TI OMAP Real Time Clock\"\n\tdepends on ARCH_OMAP || ARCH_DAVINCI || COMPILE_TEST\n\tdepends on OF\n\tdepends on PINCTRL\n\tselect GENERIC_PINCONF\n\thelp\n\t  Say \"yes\" here to support the on chip real time clock\n\t  present on TI OMAP1, AM33xx, DA8xx/OMAP-L13x, AM43xx and DRA7xx.\n\n\t  This driver can also be built as a module, if so, module\n\t  will be called rtc-omap.\n\nconfig RTC_DRV_S3C\n\ttristate \"Samsung S3C series SoC RTC\"\n\tdepends on ARCH_EXYNOS || ARCH_S3C64XX || ARCH_S5PV210 || \\\n\t\t   COMPILE_TEST\n\thelp\n\t  RTC (Realtime Clock) driver for the clock inbuilt into the\n\t  Samsung S3C64XX series of SoCs. This can provide periodic\n\t  interrupt rates from 1Hz to 64Hz for user programs, and\n\t  wakeup from Alarm.\n\n\t  This driver can also be build as a module. If so, the module\n\t  will be called rtc-s3c.\n\nconfig RTC_DRV_EP93XX\n\ttristate \"Cirrus Logic EP93XX\"\n\tdepends on ARCH_EP93XX || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the\n\t  RTC embedded in the Cirrus Logic EP93XX processors.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ep93xx.\n\nconfig RTC_DRV_SA1100\n\ttristate \"SA11x0/PXA2xx/PXA910\"\n\tdepends on ARCH_SA1100 || ARCH_PXA || ARCH_MMP\n\thelp\n\t  If you say Y here you will get access to the real time clock\n\t  built into your SA11x0 or PXA2xx CPU.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-sa1100.\n\nconfig RTC_DRV_SH\n\ttristate \"SuperH On-Chip RTC\"\n\tdepends on SUPERH || ARCH_RENESAS\n\thelp\n\t  Say Y here to enable support for the on-chip RTC found in\n\t  most SuperH processors. This RTC is also found in RZ/A SoCs.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-sh.\n\nconfig RTC_DRV_SUNPLUS\n\ttristate \"Sunplus SP7021 RTC\"\n\tdepends on SOC_SP7021\n\thelp\n\t  Say 'yes' to get support for the real-time clock present in\n\t  Sunplus SP7021 - a SoC for industrial applications. It provides\n\t  RTC status check, timer/alarm functionalities, user data\n\t  reservation with the battery over 2.5V, RTC power status check\n\t  and battery charge.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-sunplus.\n\nconfig RTC_DRV_PL030\n\ttristate \"ARM AMBA PL030 RTC\"\n\tdepends on ARM_AMBA\n\thelp\n\t  If you say Y here you will get access to ARM AMBA\n\t  PrimeCell PL030 RTC found on certain ARM SOCs.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-pl030.\n\nconfig RTC_DRV_PL031\n\ttristate \"ARM AMBA PL031 RTC\"\n\tdepends on ARM_AMBA\n\thelp\n\t  If you say Y here you will get access to ARM AMBA\n\t  PrimeCell PL031 RTC found on certain ARM SOCs.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-pl031.\n\nconfig RTC_DRV_AT91RM9200\n\ttristate \"AT91RM9200 or some AT91SAM9 RTC\"\n\tdepends on ARCH_AT91 || COMPILE_TEST\n\tdepends on OF\n\thelp\n\t  Driver for the internal RTC (Realtime Clock) module found on\n\t  Atmel AT91RM9200's and some  AT91SAM9 chips. On AT91SAM9 chips\n\t  this is powered by the backup power supply.\n\nconfig RTC_DRV_AT91SAM9\n\ttristate \"AT91SAM9 RTT as RTC\"\n\tdepends on ARCH_AT91 || COMPILE_TEST\n\tdepends on OF && HAS_IOMEM\n\tselect MFD_SYSCON\n\thelp\n\t  Some AT91SAM9 SoCs provide an RTT (Real Time Timer) block which\n\t  can be used as an RTC thanks to the backup power supply (e.g. a\n\t  small coin cell battery) which keeps this block and the GPBR\n\t  (General Purpose Backup Registers) block powered when the device\n\t  is shutdown.\n\t  Some AT91SAM9 SoCs provide a real RTC block, on those ones you'd\n\t  probably want to use the real RTC block instead of the \"RTT as an\n\t  RTC\" driver.\n\nconfig RTC_DRV_AU1XXX\n\ttristate \"Au1xxx Counter0 RTC support\"\n\tdepends on MIPS_ALCHEMY\n\thelp\n\t  This is a driver for the Au1xxx on-chip Counter0 (Time-Of-Year\n\t  counter) to be used as a RTC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-au1xxx.\n\nconfig RTC_DRV_RS5C313\n\ttristate \"Ricoh RS5C313\"\n\tdepends on SH_LANDISK\n\thelp\n\t  If you say yes here you get support for the Ricoh RS5C313 RTC chips.\n\nconfig RTC_DRV_RZN1\n\ttristate \"Renesas RZ/N1 RTC\"\n\tdepends on ARCH_RZN1 || COMPILE_TEST\n\tdepends on OF && HAS_IOMEM\n\thelp\n\t  If you say yes here you get support for the Renesas RZ/N1 RTC.\n\nconfig RTC_DRV_GENERIC\n\ttristate \"Generic RTC support\"\n\t# Please consider writing a new RTC driver instead of using the generic\n\t# RTC abstraction\n\tdepends on PARISC || M68K || PPC || SUPERH || COMPILE_TEST\n\thelp\n\t  Say Y or M here to enable RTC support on systems using the generic\n\t  RTC abstraction. If you do not know what you are doing, you should\n\t  just say Y.\n\nconfig RTC_DRV_PXA\n\ttristate \"PXA27x/PXA3xx\"\n\tdepends on ARCH_PXA\n\tselect RTC_DRV_SA1100\n\thelp\n\t If you say Y here you will get access to the real time clock\n\t built into your PXA27x or PXA3xx CPU. This RTC is actually 2 RTCs\n\t consisting of an SA1100 compatible RTC and the extended PXA RTC.\n\n\t This RTC driver uses PXA RTC registers available since pxa27x\n\t series (RDxR, RYxR) instead of legacy RCNR, RTAR.\n\nconfig RTC_DRV_VT8500\n\ttristate \"VIA/WonderMedia 85xx SoC RTC\"\n\tdepends on ARCH_VT8500 || COMPILE_TEST\n\thelp\n\t  If you say Y here you will get access to the real time clock\n\t  built into your VIA VT8500 SoC or its relatives.\n\n\nconfig RTC_DRV_SUN4V\n\tbool \"SUN4V Hypervisor RTC\"\n\tdepends on SPARC64\n\thelp\n\t  If you say Y here you will get support for the Hypervisor\n\t  based RTC on SUN4V systems.\n\nconfig RTC_DRV_SUN6I\n\tbool \"Allwinner A31 RTC\"\n\tdefault MACH_SUN6I || MACH_SUN8I\n\tdepends on COMMON_CLK\n\tdepends on ARCH_SUNXI || COMPILE_TEST\n\thelp\n\t  If you say Y here you will get support for the RTC found in\n\t  some Allwinner SoCs like the A31 or the A64.\n\nconfig RTC_DRV_SUNXI\n\ttristate \"Allwinner sun4i/sun7i RTC\"\n\tdepends on MACH_SUN4I || MACH_SUN7I || COMPILE_TEST\n\thelp\n\t  If you say Y here you will get support for the RTC found on\n\t  Allwinner A10/A20.\n\nconfig RTC_DRV_STARFIRE\n\tbool \"Starfire RTC\"\n\tdepends on SPARC64\n\thelp\n\t  If you say Y here you will get support for the RTC found on\n\t  Starfire systems.\n\nconfig RTC_DRV_MV\n\ttristate \"Marvell SoC RTC\"\n\tdepends on ARCH_DOVE || ARCH_MVEBU || COMPILE_TEST\n\thelp\n\t  If you say yes here you will get support for the in-chip RTC\n\t  that can be found in some of Marvell's SoC devices, such as\n\t  the Kirkwood 88F6281 and 88F6192.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-mv.\n\nconfig RTC_DRV_ARMADA38X\n\ttristate \"Armada 38x Marvell SoC RTC\"\n\tdepends on ARCH_MVEBU || COMPILE_TEST\n\tdepends on OF\n\thelp\n\t  If you say yes here you will get support for the in-chip RTC\n\t  that can be found in the Armada 38x Marvell's SoC device\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called armada38x-rtc.\n\nconfig RTC_DRV_CADENCE\n\ttristate \"Cadence RTC driver\"\n\tdepends on OF && HAS_IOMEM\n\thelp\n\t  If you say Y here you will get access to Cadence RTC IP\n\t  found on certain SOCs.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-cadence.\n\nconfig RTC_DRV_FTRTC010\n\ttristate \"Faraday Technology FTRTC010 RTC\"\n\tdepends on HAS_IOMEM\n\tdefault ARCH_GEMINI\n\thelp\n\t  If you say Y here you will get support for the\n\t  Faraday Technolog FTRTC010 found on e.g. Gemini SoC's.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ftrtc010.\n\nconfig RTC_DRV_PS3\n\ttristate \"PS3 RTC\"\n\tdepends on PPC_PS3\n\thelp\n\t  If you say yes here you will get support for the RTC on PS3.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-ps3.\n\nconfig RTC_DRV_STMP\n\ttristate \"Freescale STMP3xxx/i.MX23/i.MX28 RTC\"\n\tdepends on ARCH_MXS || COMPILE_TEST\n\tselect STMP_DEVICE\n\thelp\n\t  If you say yes here you will get support for the onboard\n\t  STMP3xxx/i.MX23/i.MX28 RTC.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-stmp3xxx.\n\nconfig RTC_DRV_PCAP\n\ttristate \"PCAP RTC\"\n\tdepends on EZX_PCAP\n\thelp\n\t  If you say Y here you will get support for the RTC found on\n\t  the PCAP2 ASIC used on some Motorola phones.\n\nconfig RTC_DRV_MC13XXX\n\tdepends on MFD_MC13XXX\n\ttristate \"Freescale MC13xxx RTC\"\n\thelp\n\t  This enables support for the RTCs found on Freescale's PMICs\n\t  MC13783 and MC13892.\n\nconfig RTC_DRV_MPC5121\n\ttristate \"Freescale MPC5121 built-in RTC\"\n\tdepends on PPC_MPC512x || PPC_MPC52xx\n\thelp\n\t  If you say yes here you will get support for the\n\t  built-in RTC on MPC5121 or on MPC5200.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-mpc5121.\n\nconfig RTC_DRV_JZ4740\n\ttristate \"Ingenic JZ4740 SoC\"\n\tdepends on MIPS || COMPILE_TEST\n\tdepends on OF && COMMON_CLK\n\thelp\n\t  If you say yes here you get support for the Ingenic JZ47xx SoCs RTC\n\t  controllers.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-jz4740.\n\nconfig RTC_DRV_LOONGSON\n\ttristate \"Loongson On-chip RTC\"\n\tdepends on MACH_LOONGSON32 || MACH_LOONGSON64 || COMPILE_TEST\n\tselect REGMAP_MMIO\n\thelp\n\t  This is a driver for the Loongson on-chip Counter0 (Time-Of-Year\n\t  counter) to be used as a RTC.\n\t  It can be found on Loongson-1 series cpu, Loongson-2K series cpu\n\t  and Loongson LS7A bridge chips.\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-loongson.\n\nconfig RTC_DRV_LPC24XX\n\ttristate \"NXP RTC for LPC178x/18xx/408x/43xx\"\n\tdepends on ARCH_LPC18XX || COMPILE_TEST\n\tdepends on OF && HAS_IOMEM\n\thelp\n\t  This enables support for the NXP RTC found which can be found on\n\t  NXP LPC178x/18xx/408x/43xx devices.\n\n\t  If you have one of the devices above enable this driver to use\n\t  the hardware RTC. This driver can also be built as a module. If\n\t  so, the module will be called rtc-lpc24xx.\n\nconfig RTC_DRV_LPC32XX\n\tdepends on ARCH_LPC32XX || COMPILE_TEST\n\ttristate \"NXP LPC32XX RTC\"\n\thelp\n\t  This enables support for the NXP RTC in the LPC32XX\n\n\t  This driver can also be built as a module. If so, the module\n\t  will be called rtc-lpc32xx.\n\nconfig RTC_DRV_PM8XXX\n\ttristate \"Qualcomm PMIC8XXX RTC\"\n\tdepends on MFD_PM8XXX || MFD_SPMI_PMIC || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the\n\t  Qualcomm PMIC8XXX RTC.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-pm8xxx.\n\nconfig RTC_DRV_TEGRA\n\ttristate \"NVIDIA Tegra Internal RTC driver\"\n\tdepends on ARCH_TEGRA || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the\n\t  Tegra 200 series internal RTC module.\n\n\t  This drive can also be built as a module. If so, the module\n\t  will be called rtc-tegra.\n\nconfig RTC_DRV_MXC\n\ttristate \"Freescale MXC Real Time Clock\"\n\tdepends on ARCH_MXC || COMPILE_TEST\n\tdepends on HAS_IOMEM\n\tdepends on OF\n\thelp\n\t   If you say yes here you get support for the Freescale MXC\n\t   RTC module.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-mxc\".\n\nconfig RTC_DRV_MXC_V2\n\ttristate \"Freescale MXC Real Time Clock for i.MX53\"\n\tdepends on ARCH_MXC || COMPILE_TEST\n\tdepends on HAS_IOMEM\n\tdepends on OF\n\thelp\n\t   If you say yes here you get support for the Freescale MXC\n\t   SRTC module in i.MX53 processor.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-mxc_v2\".\n\nconfig RTC_DRV_SNVS\n\ttristate \"Freescale SNVS RTC support\"\n\tselect REGMAP_MMIO\n\tdepends on ARCH_MXC || COMPILE_TEST\n\tdepends on HAS_IOMEM\n\tdepends on OF\n\thelp\n\t   If you say yes here you get support for the Freescale SNVS\n\t   Low Power (LP) RTC module.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-snvs\".\n\nconfig RTC_DRV_BBNSM\n\ttristate \"NXP BBNSM RTC support\"\n\tselect REGMAP_MMIO\n\tdepends on ARCH_MXC || COMPILE_TEST\n\tdepends on HAS_IOMEM\n\tdepends on OF\n\thelp\n\t   If you say yes here you get support for the NXP BBNSM RTC module.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-bbnsm\".\n\nconfig RTC_DRV_IMX_SC\n\tdepends on IMX_SCU\n\tdepends on HAVE_ARM_SMCCC\n\ttristate \"NXP i.MX System Controller RTC support\"\n\thelp\n\t   If you say yes here you get support for the NXP i.MX System\n\t   Controller RTC module.\n\nconfig RTC_DRV_ST_LPC\n\ttristate \"STMicroelectronics LPC RTC\"\n\tdepends on ARCH_STI\n\tdepends on OF\n\thelp\n\t  Say Y here to include STMicroelectronics Low Power Controller\n\t  (LPC) based RTC support.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rtc-st-lpc.\n\nconfig RTC_DRV_MOXART\n\ttristate \"MOXA ART RTC\"\n\tdepends on ARCH_MOXART || COMPILE_TEST\n\thelp\n\t   If you say yes here you get support for the MOXA ART\n\t   RTC module.\n\n\t   This driver can also be built as a module. If so, the module\n\t   will be called rtc-moxart\n\nconfig RTC_DRV_MT2712\n\ttristate \"MediaTek MT2712 SoC based RTC\"\n\tdepends on ARCH_MEDIATEK || COMPILE_TEST\n\thelp\n\t  This enables support for the real time clock built in the MediaTek\n\t  SoCs for MT2712.\n\n\t  This drive can also be built as a module. If so, the module\n\t  will be called rtc-mt2712.\n\nconfig RTC_DRV_MT6397\n\ttristate \"MediaTek PMIC based RTC\"\n\tdepends on MFD_MT6397 || (COMPILE_TEST && IRQ_DOMAIN)\n\thelp\n\t  This selects the MediaTek(R) RTC driver. RTC is part of MediaTek\n\t  MT6397 PMIC. You should enable MT6397 PMIC MFD before select\n\t  MediaTek(R) RTC driver.\n\n\t  If you want to use MediaTek(R) RTC interface, select Y or M here.\n\nconfig RTC_DRV_MT7622\n\ttristate \"MediaTek SoC based RTC\"\n\tdepends on ARCH_MEDIATEK || COMPILE_TEST\n\thelp\n\t  This enables support for the real time clock built in the MediaTek\n\t  SoCs.\n\n\t  This drive can also be built as a module. If so, the module\n\t  will be called rtc-mt7622.\n\nconfig RTC_DRV_XGENE\n\ttristate \"APM X-Gene RTC\"\n\tdepends on HAS_IOMEM\n\tdepends on ARCH_XGENE || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the APM X-Gene SoC real time\n\t  clock.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-xgene\".\n\nconfig RTC_DRV_PIC32\n\ttristate \"Microchip PIC32 RTC\"\n\tdepends on MACH_PIC32\n\tdefault y\n\thelp\n\t   If you say yes here you get support for the PIC32 RTC module.\n\n\t   This driver can also be built as a module. If so, the module\n\t   will be called rtc-pic32\n\nconfig RTC_DRV_R7301\n\ttristate \"EPSON TOYOCOM RTC-7301SF/DG\"\n\tselect REGMAP_MMIO\n\tdepends on OF && HAS_IOMEM\n\thelp\n\t   If you say yes here you get support for the EPSON TOYOCOM\n\t   RTC-7301SF/DG chips.\n\n\t   This driver can also be built as a module. If so, the module\n\t   will be called rtc-r7301.\n\nconfig RTC_DRV_STM32\n\ttristate \"STM32 RTC\"\n\tselect REGMAP_MMIO\n\tdepends on ARCH_STM32 || COMPILE_TEST\n\thelp\n\t   If you say yes here you get support for the STM32 On-Chip\n\t   Real Time Clock.\n\n\t   This driver can also be built as a module, if so, the module\n\t   will be called \"rtc-stm32\".\n\nconfig RTC_DRV_CPCAP\n\tdepends on MFD_CPCAP\n\ttristate \"Motorola CPCAP RTC\"\n\thelp\n\t   Say y here for CPCAP rtc found on some Motorola phones\n\t   and tablets such as Droid 4.\n\nconfig RTC_DRV_RTD119X\n\tbool \"Realtek RTD129x RTC\"\n\tdepends on ARCH_REALTEK || COMPILE_TEST\n\tdefault ARCH_REALTEK\n\thelp\n\t  If you say yes here, you get support for the RTD1295 SoC\n\t  Real Time Clock.\n\nconfig RTC_DRV_ASPEED\n\ttristate \"ASPEED RTC\"\n\tdepends on OF\n\tdepends on ARCH_ASPEED || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the ASPEED BMC SoC real time\n\t  clocks.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-aspeed\".\n\nconfig RTC_DRV_TI_K3\n\ttristate \"TI K3 RTC\"\n\tdepends on ARCH_K3 || COMPILE_TEST\n\tselect REGMAP_MMIO\n\thelp\n\t  If you say yes here you get support for the Texas Instruments's\n\t  Real Time Clock for K3 architecture.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-ti-k3\".\n\ncomment \"HID Sensor RTC drivers\"\n\nconfig RTC_DRV_HID_SENSOR_TIME\n\ttristate \"HID Sensor Time\"\n\tdepends on USB_HID\n\tdepends on HID_SENSOR_HUB && IIO\n\tselect HID_SENSOR_IIO_COMMON\n\thelp\n\t  Say yes here to build support for the HID Sensors of type Time.\n\t  This drivers makes such sensors available as RTCs.\n\n\t  If this driver is compiled as a module, it will be named\n\t  rtc-hid-sensor-time.\n\nconfig RTC_DRV_GOLDFISH\n\ttristate \"Goldfish Real Time Clock\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  Say yes to enable RTC driver for the Goldfish based virtual platform.\n\n\t  Goldfish is a code name for the virtual platform developed by Google\n\t  for Android emulation.\n\nconfig RTC_DRV_WILCO_EC\n\ttristate \"Wilco EC RTC\"\n\tdepends on WILCO_EC\n\tdefault m\n\thelp\n\t  If you say yes here, you get read/write support for the Real Time\n\t  Clock on the Wilco Embedded Controller (Wilco is a kind of Chromebook)\n\n\t  This can also be built as a module. If so, the module will\n\t  be named \"rtc_wilco_ec\".\n\nconfig RTC_DRV_MSC313\n\ttristate \"MStar MSC313 RTC\"\n        depends on ARCH_MSTARV7 || COMPILE_TEST\n\thelp\n\t  If you say yes here you get support for the Mstar MSC313e On-Chip\n\t  Real Time Clock.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-msc313\".\n\nconfig RTC_DRV_POLARFIRE_SOC\n\ttristate \"Microchip PolarFire SoC built-in RTC\"\n\tdepends on ARCH_MICROCHIP_POLARFIRE\n\thelp\n\t  If you say yes here you will get support for the\n\t  built-in RTC on Polarfire SoC.\n\n\t  This driver can also be built as a module, if so, the module\n\t  will be called \"rtc-mpfs\".\n\nendif # RTC_CLASS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}