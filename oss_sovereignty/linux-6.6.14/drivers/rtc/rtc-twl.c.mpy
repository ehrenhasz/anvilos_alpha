{
  "module_name": "rtc-twl.c",
  "hash_id": "fa9bb4ed5ab220e6f02b96f2482d8f42d04041ad7fc4780da2348b6664722967",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-twl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n\n#include <linux/mfd/twl.h>\n\nenum twl_class {\n\tTWL_4030 = 0,\n\tTWL_6030,\n};\n\n \nenum {\n\tREG_SECONDS_REG = 0,\n\tREG_MINUTES_REG,\n\tREG_HOURS_REG,\n\tREG_DAYS_REG,\n\tREG_MONTHS_REG,\n\tREG_YEARS_REG,\n\tREG_WEEKS_REG,\n\n\tREG_ALARM_SECONDS_REG,\n\tREG_ALARM_MINUTES_REG,\n\tREG_ALARM_HOURS_REG,\n\tREG_ALARM_DAYS_REG,\n\tREG_ALARM_MONTHS_REG,\n\tREG_ALARM_YEARS_REG,\n\n\tREG_RTC_CTRL_REG,\n\tREG_RTC_STATUS_REG,\n\tREG_RTC_INTERRUPTS_REG,\n\n\tREG_RTC_COMP_LSB_REG,\n\tREG_RTC_COMP_MSB_REG,\n};\nstatic const u8 twl4030_rtc_reg_map[] = {\n\t[REG_SECONDS_REG] = 0x00,\n\t[REG_MINUTES_REG] = 0x01,\n\t[REG_HOURS_REG] = 0x02,\n\t[REG_DAYS_REG] = 0x03,\n\t[REG_MONTHS_REG] = 0x04,\n\t[REG_YEARS_REG] = 0x05,\n\t[REG_WEEKS_REG] = 0x06,\n\n\t[REG_ALARM_SECONDS_REG] = 0x07,\n\t[REG_ALARM_MINUTES_REG] = 0x08,\n\t[REG_ALARM_HOURS_REG] = 0x09,\n\t[REG_ALARM_DAYS_REG] = 0x0A,\n\t[REG_ALARM_MONTHS_REG] = 0x0B,\n\t[REG_ALARM_YEARS_REG] = 0x0C,\n\n\t[REG_RTC_CTRL_REG] = 0x0D,\n\t[REG_RTC_STATUS_REG] = 0x0E,\n\t[REG_RTC_INTERRUPTS_REG] = 0x0F,\n\n\t[REG_RTC_COMP_LSB_REG] = 0x10,\n\t[REG_RTC_COMP_MSB_REG] = 0x11,\n};\nstatic const u8 twl6030_rtc_reg_map[] = {\n\t[REG_SECONDS_REG] = 0x00,\n\t[REG_MINUTES_REG] = 0x01,\n\t[REG_HOURS_REG] = 0x02,\n\t[REG_DAYS_REG] = 0x03,\n\t[REG_MONTHS_REG] = 0x04,\n\t[REG_YEARS_REG] = 0x05,\n\t[REG_WEEKS_REG] = 0x06,\n\n\t[REG_ALARM_SECONDS_REG] = 0x08,\n\t[REG_ALARM_MINUTES_REG] = 0x09,\n\t[REG_ALARM_HOURS_REG] = 0x0A,\n\t[REG_ALARM_DAYS_REG] = 0x0B,\n\t[REG_ALARM_MONTHS_REG] = 0x0C,\n\t[REG_ALARM_YEARS_REG] = 0x0D,\n\n\t[REG_RTC_CTRL_REG] = 0x10,\n\t[REG_RTC_STATUS_REG] = 0x11,\n\t[REG_RTC_INTERRUPTS_REG] = 0x12,\n\n\t[REG_RTC_COMP_LSB_REG] = 0x13,\n\t[REG_RTC_COMP_MSB_REG] = 0x14,\n};\n\n \n#define BIT_RTC_CTRL_REG_STOP_RTC_M              0x01\n#define BIT_RTC_CTRL_REG_ROUND_30S_M             0x02\n#define BIT_RTC_CTRL_REG_AUTO_COMP_M             0x04\n#define BIT_RTC_CTRL_REG_MODE_12_24_M            0x08\n#define BIT_RTC_CTRL_REG_TEST_MODE_M             0x10\n#define BIT_RTC_CTRL_REG_SET_32_COUNTER_M        0x20\n#define BIT_RTC_CTRL_REG_GET_TIME_M              0x40\n#define BIT_RTC_CTRL_REG_RTC_V_OPT               0x80\n\n \n#define BIT_RTC_STATUS_REG_RUN_M                 0x02\n#define BIT_RTC_STATUS_REG_1S_EVENT_M            0x04\n#define BIT_RTC_STATUS_REG_1M_EVENT_M            0x08\n#define BIT_RTC_STATUS_REG_1H_EVENT_M            0x10\n#define BIT_RTC_STATUS_REG_1D_EVENT_M            0x20\n#define BIT_RTC_STATUS_REG_ALARM_M               0x40\n#define BIT_RTC_STATUS_REG_POWER_UP_M            0x80\n\n \n#define BIT_RTC_INTERRUPTS_REG_EVERY_M           0x03\n#define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M        0x04\n#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M        0x08\n\n\n \n#define ALL_TIME_REGS\t\t6\n\n \nstruct twl_rtc {\n\tstruct device *dev;\n\tstruct rtc_device *rtc;\n\tu8 *reg_map;\n\t \n\tunsigned char rtc_irq_bits;\n\tbool wake_enabled;\n#ifdef CONFIG_PM_SLEEP\n\tunsigned char irqstat;\n#endif\n\tenum twl_class class;\n};\n\n \nstatic int twl_rtc_read_u8(struct twl_rtc *twl_rtc, u8 *data, u8 reg)\n{\n\tint ret;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_RTC, data, (twl_rtc->reg_map[reg]));\n\tif (ret < 0)\n\t\tpr_err(\"Could not read TWL register %X - error %d\\n\", reg, ret);\n\treturn ret;\n}\n\n \nstatic int twl_rtc_write_u8(struct twl_rtc *twl_rtc, u8 data, u8 reg)\n{\n\tint ret;\n\n\tret = twl_i2c_write_u8(TWL_MODULE_RTC, data, (twl_rtc->reg_map[reg]));\n\tif (ret < 0)\n\t\tpr_err(\"Could not write TWL register %X - error %d\\n\",\n\t\t       reg, ret);\n\treturn ret;\n}\n\n \nstatic int set_rtc_irq_bit(struct twl_rtc *twl_rtc, unsigned char bit)\n{\n\tunsigned char val;\n\tint ret;\n\n\t \n\tif (twl_rtc->rtc_irq_bits & bit)\n\t\treturn 0;\n\n\tval = twl_rtc->rtc_irq_bits | bit;\n\tval &= ~BIT_RTC_INTERRUPTS_REG_EVERY_M;\n\tret = twl_rtc_write_u8(twl_rtc, val, REG_RTC_INTERRUPTS_REG);\n\tif (ret == 0)\n\t\ttwl_rtc->rtc_irq_bits = val;\n\n\treturn ret;\n}\n\n \nstatic int mask_rtc_irq_bit(struct twl_rtc *twl_rtc, unsigned char bit)\n{\n\tunsigned char val;\n\tint ret;\n\n\t \n\tif (!(twl_rtc->rtc_irq_bits & bit))\n\t\treturn 0;\n\n\tval = twl_rtc->rtc_irq_bits & ~bit;\n\tret = twl_rtc_write_u8(twl_rtc, val, REG_RTC_INTERRUPTS_REG);\n\tif (ret == 0)\n\t\ttwl_rtc->rtc_irq_bits = val;\n\n\treturn ret;\n}\n\nstatic int twl_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\tint irq = platform_get_irq(pdev, 0);\n\tint ret;\n\n\tif (enabled) {\n\t\tret = set_rtc_irq_bit(twl_rtc,\n\t\t\t\t      BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);\n\t\tif (device_can_wakeup(dev) && !twl_rtc->wake_enabled) {\n\t\t\tenable_irq_wake(irq);\n\t\t\ttwl_rtc->wake_enabled = true;\n\t\t}\n\t} else {\n\t\tret = mask_rtc_irq_bit(twl_rtc,\n\t\t\t\t       BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);\n\t\tif (twl_rtc->wake_enabled) {\n\t\t\tdisable_irq_wake(irq);\n\t\t\ttwl_rtc->wake_enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int twl_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\tunsigned char rtc_data[ALL_TIME_REGS];\n\tint ret;\n\tu8 save_control;\n\tu8 rtc_control;\n\n\tret = twl_rtc_read_u8(twl_rtc, &save_control, REG_RTC_CTRL_REG);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: reading CTRL_REG, error %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\t \n\tif (twl_rtc->class == TWL_6030) {\n\t\tif (save_control & BIT_RTC_CTRL_REG_GET_TIME_M) {\n\t\t\tsave_control &= ~BIT_RTC_CTRL_REG_GET_TIME_M;\n\t\t\tret = twl_rtc_write_u8(twl_rtc, save_control,\n\t\t\t\t\t       REG_RTC_CTRL_REG);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"%s clr GET_TIME, error %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trtc_control = save_control | BIT_RTC_CTRL_REG_GET_TIME_M;\n\n\t \n\tif (twl_rtc->class == TWL_6030)\n\t\trtc_control |= BIT_RTC_CTRL_REG_RTC_V_OPT;\n\n\tret = twl_rtc_write_u8(twl_rtc, rtc_control, REG_RTC_CTRL_REG);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: writing CTRL_REG, error %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = twl_i2c_read(TWL_MODULE_RTC, rtc_data,\n\t\t\t(twl_rtc->reg_map[REG_SECONDS_REG]), ALL_TIME_REGS);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: reading data, error %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (twl_rtc->class == TWL_6030) {\n\t\tret = twl_rtc_write_u8(twl_rtc, save_control, REG_RTC_CTRL_REG);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: restore CTRL_REG, error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttm->tm_sec = bcd2bin(rtc_data[0]);\n\ttm->tm_min = bcd2bin(rtc_data[1]);\n\ttm->tm_hour = bcd2bin(rtc_data[2]);\n\ttm->tm_mday = bcd2bin(rtc_data[3]);\n\ttm->tm_mon = bcd2bin(rtc_data[4]) - 1;\n\ttm->tm_year = bcd2bin(rtc_data[5]) + 100;\n\n\treturn ret;\n}\n\nstatic int twl_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\tunsigned char save_control;\n\tunsigned char rtc_data[ALL_TIME_REGS];\n\tint ret;\n\n\trtc_data[0] = bin2bcd(tm->tm_sec);\n\trtc_data[1] = bin2bcd(tm->tm_min);\n\trtc_data[2] = bin2bcd(tm->tm_hour);\n\trtc_data[3] = bin2bcd(tm->tm_mday);\n\trtc_data[4] = bin2bcd(tm->tm_mon + 1);\n\trtc_data[5] = bin2bcd(tm->tm_year - 100);\n\n\t \n\tret = twl_rtc_read_u8(twl_rtc, &save_control, REG_RTC_CTRL_REG);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsave_control &= ~BIT_RTC_CTRL_REG_STOP_RTC_M;\n\tret = twl_rtc_write_u8(twl_rtc, save_control, REG_RTC_CTRL_REG);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = twl_i2c_write(TWL_MODULE_RTC, rtc_data,\n\t\t(twl_rtc->reg_map[REG_SECONDS_REG]), ALL_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_set_time error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tsave_control |= BIT_RTC_CTRL_REG_STOP_RTC_M;\n\tret = twl_rtc_write_u8(twl_rtc, save_control, REG_RTC_CTRL_REG);\n\nout:\n\treturn ret;\n}\n\n \nstatic int twl_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\tunsigned char rtc_data[ALL_TIME_REGS];\n\tint ret;\n\n\tret = twl_i2c_read(TWL_MODULE_RTC, rtc_data,\n\t\t\ttwl_rtc->reg_map[REG_ALARM_SECONDS_REG], ALL_TIME_REGS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rtc_read_alarm error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\talm->time.tm_sec = bcd2bin(rtc_data[0]);\n\talm->time.tm_min = bcd2bin(rtc_data[1]);\n\talm->time.tm_hour = bcd2bin(rtc_data[2]);\n\talm->time.tm_mday = bcd2bin(rtc_data[3]);\n\talm->time.tm_mon = bcd2bin(rtc_data[4]) - 1;\n\talm->time.tm_year = bcd2bin(rtc_data[5]) + 100;\n\n\t \n\tif (twl_rtc->rtc_irq_bits & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M)\n\t\talm->enabled = 1;\n\n\treturn ret;\n}\n\nstatic int twl_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\n\tunsigned char alarm_data[ALL_TIME_REGS];\n\tint ret;\n\n\tret = twl_rtc_alarm_irq_enable(dev, 0);\n\tif (ret)\n\t\tgoto out;\n\n\talarm_data[0] = bin2bcd(alm->time.tm_sec);\n\talarm_data[1] = bin2bcd(alm->time.tm_min);\n\talarm_data[2] = bin2bcd(alm->time.tm_hour);\n\talarm_data[3] = bin2bcd(alm->time.tm_mday);\n\talarm_data[4] = bin2bcd(alm->time.tm_mon + 1);\n\talarm_data[5] = bin2bcd(alm->time.tm_year - 100);\n\n\t \n\tret = twl_i2c_write(TWL_MODULE_RTC, alarm_data,\n\t\t\ttwl_rtc->reg_map[REG_ALARM_SECONDS_REG], ALL_TIME_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"rtc_set_alarm error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (alm->enabled)\n\t\tret = twl_rtc_alarm_irq_enable(dev, 1);\nout:\n\treturn ret;\n}\n\nstatic irqreturn_t twl_rtc_interrupt(int irq, void *data)\n{\n\tstruct twl_rtc *twl_rtc = data;\n\tunsigned long events;\n\tint ret = IRQ_NONE;\n\tint res;\n\tu8 rd_reg;\n\n\tres = twl_rtc_read_u8(twl_rtc, &rd_reg, REG_RTC_STATUS_REG);\n\tif (res)\n\t\tgoto out;\n\t \n\tif (rd_reg & BIT_RTC_STATUS_REG_ALARM_M)\n\t\tevents = RTC_IRQF | RTC_AF;\n\telse\n\t\tevents = RTC_IRQF | RTC_PF;\n\n\tres = twl_rtc_write_u8(twl_rtc, BIT_RTC_STATUS_REG_ALARM_M,\n\t\t\t       REG_RTC_STATUS_REG);\n\tif (res)\n\t\tgoto out;\n\n\tif (twl_rtc->class == TWL_4030) {\n\t\t \n\t\tres = twl_i2c_read_u8(TWL4030_MODULE_INT,\n\t\t\t&rd_reg, TWL4030_INT_PWR_ISR1);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\t \n\trtc_update_irq(twl_rtc->rtc, 1, events);\n\n\tret = IRQ_HANDLED;\nout:\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops twl_rtc_ops = {\n\t.read_time\t= twl_rtc_read_time,\n\t.set_time\t= twl_rtc_set_time,\n\t.read_alarm\t= twl_rtc_read_alarm,\n\t.set_alarm\t= twl_rtc_set_alarm,\n\t.alarm_irq_enable = twl_rtc_alarm_irq_enable,\n};\n\nstatic int twl_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t  size_t bytes)\n{\n\treturn twl_i2c_read((long)priv, val, offset, bytes);\n}\n\nstatic int twl_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t   size_t bytes)\n{\n\treturn twl_i2c_write((long)priv, val, offset, bytes);\n}\n\n \n\nstatic int twl_rtc_probe(struct platform_device *pdev)\n{\n\tstruct twl_rtc *twl_rtc;\n\tstruct nvmem_config nvmem_cfg;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret = -EINVAL;\n\tint irq = platform_get_irq(pdev, 0);\n\tu8 rd_reg;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"no DT info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq <= 0)\n\t\treturn ret;\n\n\ttwl_rtc = devm_kzalloc(&pdev->dev, sizeof(*twl_rtc), GFP_KERNEL);\n\tif (!twl_rtc)\n\t\treturn -ENOMEM;\n\n\tif (twl_class_is_4030()) {\n\t\ttwl_rtc->class = TWL_4030;\n\t\ttwl_rtc->reg_map = (u8 *)twl4030_rtc_reg_map;\n\t} else if (twl_class_is_6030()) {\n\t\ttwl_rtc->class = TWL_6030;\n\t\ttwl_rtc->reg_map = (u8 *)twl6030_rtc_reg_map;\n\t} else {\n\t\tdev_err(&pdev->dev, \"TWL Class not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = twl_rtc_read_u8(twl_rtc, &rd_reg, REG_RTC_STATUS_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rd_reg & BIT_RTC_STATUS_REG_POWER_UP_M)\n\t\tdev_warn(&pdev->dev, \"Power up reset detected.\\n\");\n\n\tif (rd_reg & BIT_RTC_STATUS_REG_ALARM_M)\n\t\tdev_warn(&pdev->dev, \"Pending Alarm interrupt detected.\\n\");\n\n\t \n\tret = twl_rtc_write_u8(twl_rtc, rd_reg, REG_RTC_STATUS_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (twl_rtc->class == TWL_6030) {\n\t\ttwl6030_interrupt_unmask(TWL6030_RTC_INT_MASK,\n\t\t\tREG_INT_MSK_LINE_A);\n\t\ttwl6030_interrupt_unmask(TWL6030_RTC_INT_MASK,\n\t\t\tREG_INT_MSK_STS_A);\n\t}\n\n\tret = twl_rtc_write_u8(twl_rtc, BIT_RTC_CTRL_REG_STOP_RTC_M,\n\t\t\t       REG_RTC_CTRL_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = twl_rtc_write_u8(twl_rtc, 0, REG_RTC_INTERRUPTS_REG);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"unable to disable interrupt\\n\");\n\n\t \n\tret = twl_rtc_read_u8(twl_rtc, &twl_rtc->rtc_irq_bits,\n\t\t\t      REG_RTC_INTERRUPTS_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, twl_rtc);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\ttwl_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\n\t\t\t\t\t&twl_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(twl_rtc->rtc))\n\t\treturn PTR_ERR(twl_rtc->rtc);\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\ttwl_rtc_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&twl_rtc->rtc->dev), twl_rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"IRQ is not free.\\n\");\n\t\treturn ret;\n\t}\n\n\tmemset(&nvmem_cfg, 0, sizeof(nvmem_cfg));\n\tnvmem_cfg.name = \"twl-secured-\";\n\tnvmem_cfg.type = NVMEM_TYPE_BATTERY_BACKED;\n\tnvmem_cfg.reg_read = twl_nvram_read,\n\tnvmem_cfg.reg_write = twl_nvram_write,\n\tnvmem_cfg.word_size = 1;\n\tnvmem_cfg.stride = 1;\n\tif (twl_class_is_4030()) {\n\t\t \n\t\tnvmem_cfg.size = 20;\n\t\tnvmem_cfg.priv = (void *)TWL_MODULE_SECURED_REG;\n\t\tdevm_rtc_nvmem_register(twl_rtc->rtc, &nvmem_cfg);\n\t\t \n\t\tnvmem_cfg.name = \"twl-backup-\";\n\t\tnvmem_cfg.size = 8;\n\t\tnvmem_cfg.priv = (void *)TWL4030_MODULE_BACKUP;\n\t\tdevm_rtc_nvmem_register(twl_rtc->rtc, &nvmem_cfg);\n\t} else {\n\t\t \n\t\tnvmem_cfg.size = 8;\n\t\tnvmem_cfg.priv = (void *)TWL_MODULE_SECURED_REG;\n\t\tdevm_rtc_nvmem_register(twl_rtc->rtc, &nvmem_cfg);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void twl_rtc_remove(struct platform_device *pdev)\n{\n\tstruct twl_rtc *twl_rtc = platform_get_drvdata(pdev);\n\n\t \n\tmask_rtc_irq_bit(twl_rtc, BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);\n\tmask_rtc_irq_bit(twl_rtc, BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);\n\tif (twl_rtc->class == TWL_6030) {\n\t\ttwl6030_interrupt_mask(TWL6030_RTC_INT_MASK,\n\t\t\tREG_INT_MSK_LINE_A);\n\t\ttwl6030_interrupt_mask(TWL6030_RTC_INT_MASK,\n\t\t\tREG_INT_MSK_STS_A);\n\t}\n}\n\nstatic void twl_rtc_shutdown(struct platform_device *pdev)\n{\n\tstruct twl_rtc *twl_rtc = platform_get_drvdata(pdev);\n\n\t \n\tmask_rtc_irq_bit(twl_rtc, BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int twl_rtc_suspend(struct device *dev)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\n\ttwl_rtc->irqstat = twl_rtc->rtc_irq_bits;\n\n\tmask_rtc_irq_bit(twl_rtc, BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);\n\treturn 0;\n}\n\nstatic int twl_rtc_resume(struct device *dev)\n{\n\tstruct twl_rtc *twl_rtc = dev_get_drvdata(dev);\n\n\tset_rtc_irq_bit(twl_rtc, twl_rtc->irqstat);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(twl_rtc_pm_ops, twl_rtc_suspend, twl_rtc_resume);\n\nstatic const struct of_device_id twl_rtc_of_match[] = {\n\t{.compatible = \"ti,twl4030-rtc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl_rtc_of_match);\n\nstatic struct platform_driver twl4030rtc_driver = {\n\t.probe\t\t= twl_rtc_probe,\n\t.remove_new\t= twl_rtc_remove,\n\t.shutdown\t= twl_rtc_shutdown,\n\t.driver\t\t= {\n\t\t.name\t\t= \"twl_rtc\",\n\t\t.pm\t\t= &twl_rtc_pm_ops,\n\t\t.of_match_table = twl_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(twl4030rtc_driver);\n\nMODULE_AUTHOR(\"Texas Instruments, MontaVista Software\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}