{
  "module_name": "rtc-gamecube.c",
  "hash_id": "ffd344e6f39a6e1819f7f517825a1e5cc15359a7d886f8437a8de03506bcc93c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-gamecube.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/time.h>\n\n \n#define EXICSR\t0\n#define EXICR\t12\n#define EXIDATA\t16\n\n \n#define EXICSR_DEV\t\t0x380\n\t#define EXICSR_DEV1\t0x100\n#define EXICSR_CLK\t\t0x070\n\t#define EXICSR_CLK_1MHZ\t0x000\n\t#define EXICSR_CLK_2MHZ\t0x010\n\t#define EXICSR_CLK_4MHZ\t0x020\n\t#define EXICSR_CLK_8MHZ\t0x030\n\t#define EXICSR_CLK_16MHZ 0x040\n\t#define EXICSR_CLK_32MHZ 0x050\n#define EXICSR_INT\t\t0x008\n\t#define EXICSR_INTSET\t0x008\n\n#define EXICR_TSTART\t\t0x001\n#define EXICR_TRSMODE\t\t0x002\n\t#define EXICR_TRSMODE_IMM 0x000\n#define EXICR_TRSTYPE\t\t0x00C\n\t#define EXICR_TRSTYPE_R\t0x000\n\t#define EXICR_TRSTYPE_W\t0x004\n#define EXICR_TLEN\t\t0x030\n\t#define EXICR_TLEN32\t0x030\n\n \n#define RTC_EXICSR\t(EXICSR_DEV1 | EXICSR_CLK_8MHZ | EXICSR_INTSET)\n#define RTC_EXICR_W\t(EXICR_TSTART | EXICR_TRSMODE_IMM | EXICR_TRSTYPE_W | EXICR_TLEN32)\n#define RTC_EXICR_R\t(EXICR_TSTART | EXICR_TRSMODE_IMM | EXICR_TRSTYPE_R | EXICR_TLEN32)\n#define RTC_EXIDATA_W\t0x80000000\n\n \n#define RTC_COUNTER\t0x200000\n#define RTC_SRAM\t0x200001\n#define RTC_SRAM_BIAS\t0x200004\n#define RTC_SNAPSHOT\t0x204000\n#define RTC_ONTMR\t0x210000\n#define RTC_OFFTMR\t0x210001\n#define RTC_TEST0\t0x210004\n#define RTC_TEST1\t0x210005\n#define RTC_TEST2\t0x210006\n#define RTC_TEST3\t0x210007\n#define RTC_CONTROL0\t0x21000c\n#define RTC_CONTROL1\t0x21000d\n\n \n#define RTC_CONTROL0_UNSTABLE_POWER\t0x00000800\n#define RTC_CONTROL0_LOW_BATTERY\t0x00000200\n\nstruct priv {\n\tstruct regmap *regmap;\n\tvoid __iomem *iob;\n\tu32 rtc_bias;\n};\n\nstatic int exi_read(void *context, u32 reg, u32 *data)\n{\n\tstruct priv *d = (struct priv *)context;\n\tvoid __iomem *iob = d->iob;\n\n\t \n\n\t \n\tiowrite32be(RTC_EXICSR, iob + EXICSR);\n\tiowrite32be(reg << 8, iob + EXIDATA);\n\tiowrite32be(RTC_EXICR_W, iob + EXICR);\n\twhile (!(ioread32be(iob + EXICSR) & EXICSR_INTSET))\n\t\tcpu_relax();\n\n\t \n\tiowrite32be(RTC_EXICSR, iob + EXICSR);\n\tiowrite32be(RTC_EXICR_R, iob + EXICR);\n\twhile (!(ioread32be(iob + EXICSR) & EXICSR_INTSET))\n\t\tcpu_relax();\n\t*data = ioread32be(iob + EXIDATA);\n\n\t \n\tiowrite32be(0, iob + EXICSR);\n\n\treturn 0;\n}\n\nstatic int exi_write(void *context, u32 reg, u32 data)\n{\n\tstruct priv *d = (struct priv *)context;\n\tvoid __iomem *iob = d->iob;\n\n\t \n\n\t \n\tiowrite32be(RTC_EXICSR, iob + EXICSR);\n\tiowrite32be(RTC_EXIDATA_W | (reg << 8), iob + EXIDATA);\n\tiowrite32be(RTC_EXICR_W, iob + EXICR);\n\twhile (!(ioread32be(iob + EXICSR) & EXICSR_INTSET))\n\t\tcpu_relax();\n\n\t \n\tiowrite32be(RTC_EXICSR, iob + EXICSR);\n\tiowrite32be(data, iob + EXIDATA);\n\tiowrite32be(RTC_EXICR_W, iob + EXICR);\n\twhile (!(ioread32be(iob + EXICSR) & EXICSR_INTSET))\n\t\tcpu_relax();\n\n\t \n\tiowrite32be(0, iob + EXICSR);\n\n\treturn 0;\n}\n\nstatic const struct regmap_bus exi_bus = {\n\t \n\t.fast_io = true,\n\t.reg_read = exi_read,\n\t.reg_write = exi_write,\n};\n\nstatic int gamecube_rtc_read_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct priv *d = dev_get_drvdata(dev);\n\tint ret;\n\tu32 counter;\n\ttime64_t timestamp;\n\n\tret = regmap_read(d->regmap, RTC_COUNTER, &counter);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimestamp = (time64_t)d->rtc_bias + counter;\n\trtc_time64_to_tm(timestamp, t);\n\n\treturn 0;\n}\n\nstatic int gamecube_rtc_set_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct priv *d = dev_get_drvdata(dev);\n\ttime64_t timestamp;\n\n\t \n\ttimestamp = rtc_tm_to_time64(t);\n\treturn regmap_write(d->regmap, RTC_COUNTER, timestamp - d->rtc_bias);\n}\n\nstatic int gamecube_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct priv *d = dev_get_drvdata(dev);\n\tint value;\n\tint control0;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(d->regmap, RTC_CONTROL0, &control0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvalue = 0;\n\t\tif (control0 & RTC_CONTROL0_UNSTABLE_POWER)\n\t\t\tvalue |= RTC_VL_DATA_INVALID;\n\t\tif (control0 & RTC_CONTROL0_LOW_BATTERY)\n\t\t\tvalue |= RTC_VL_BACKUP_LOW;\n\t\treturn put_user(value, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct rtc_class_ops gamecube_rtc_ops = {\n\t.read_time\t= gamecube_rtc_read_time,\n\t.set_time\t= gamecube_rtc_set_time,\n\t.ioctl\t\t= gamecube_rtc_ioctl,\n};\n\nstatic int gamecube_rtc_read_offset_from_sram(struct priv *d)\n{\n\tstruct device_node *np;\n\tint ret;\n\tstruct resource res;\n\tvoid __iomem *hw_srnprot;\n\tu32 old;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"nintendo,latte-srnprot\");\n\tif (!np)\n\t\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t     \"nintendo,hollywood-srnprot\");\n\tif (!np) {\n\t\tpr_info(\"HW_SRNPROT not found, assuming a GameCube\\n\");\n\t\treturn regmap_read(d->regmap, RTC_SRAM_BIAS, &d->rtc_bias);\n\t}\n\n\tret = of_address_to_resource(np, 0, &res);\n\tof_node_put(np);\n\tif (ret) {\n\t\tpr_err(\"no io memory range found\\n\");\n\t\treturn -1;\n\t}\n\n\thw_srnprot = ioremap(res.start, resource_size(&res));\n\told = ioread32be(hw_srnprot);\n\n\t \n\tif (old != 0x7bf)\n\t\tiowrite32be(0x7bf, hw_srnprot);\n\n\t \n\tret = regmap_read(d->regmap, RTC_SRAM_BIAS, &d->rtc_bias);\n\n\t \n\tif (old != 0x7bf)\n\t\tiowrite32be(old, hw_srnprot);\n\n\tiounmap(hw_srnprot);\n\n\tif (ret)\n\t\tpr_err(\"failed to get the RTC bias\\n\");\n\n\treturn ret;\n}\n\nstatic const struct regmap_range rtc_rd_ranges[] = {\n\tregmap_reg_range(0x200000, 0x200010),\n\tregmap_reg_range(0x204000, 0x204000),\n\tregmap_reg_range(0x210000, 0x210001),\n\tregmap_reg_range(0x210004, 0x210007),\n\tregmap_reg_range(0x21000c, 0x21000d),\n};\n\nstatic const struct regmap_access_table rtc_rd_regs = {\n\t.yes_ranges =\trtc_rd_ranges,\n\t.n_yes_ranges =\tARRAY_SIZE(rtc_rd_ranges),\n};\n\nstatic const struct regmap_range rtc_wr_ranges[] = {\n\tregmap_reg_range(0x200000, 0x200010),\n\tregmap_reg_range(0x204000, 0x204000),\n\tregmap_reg_range(0x210000, 0x210001),\n\tregmap_reg_range(0x21000d, 0x21000d),\n};\n\nstatic const struct regmap_access_table rtc_wr_regs = {\n\t.yes_ranges =\trtc_wr_ranges,\n\t.n_yes_ranges =\tARRAY_SIZE(rtc_wr_ranges),\n};\n\nstatic const struct regmap_config gamecube_rtc_regmap_config = {\n\t.reg_bits = 24,\n\t.val_bits = 32,\n\t.rd_table = &rtc_rd_regs,\n\t.wr_table = &rtc_wr_regs,\n\t.max_register = 0x21000d,\n\t.name = \"gamecube-rtc\",\n};\n\nstatic int gamecube_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rtc_device *rtc;\n\tstruct priv *d;\n\tint ret;\n\n\td = devm_kzalloc(dev, sizeof(struct priv), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->iob = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(d->iob))\n\t\treturn PTR_ERR(d->iob);\n\n\td->regmap = devm_regmap_init(dev, &exi_bus, d,\n\t\t\t\t     &gamecube_rtc_regmap_config);\n\tif (IS_ERR(d->regmap))\n\t\treturn PTR_ERR(d->regmap);\n\n\tret = gamecube_rtc_read_offset_from_sram(d);\n\tif (ret)\n\t\treturn ret;\n\tdev_dbg(dev, \"SRAM bias: 0x%x\", d->rtc_bias);\n\n\tdev_set_drvdata(dev, d);\n\n\trtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\t \n\trtc->range_min = 0;\n\trtc->range_max = U32_MAX;\n\trtc->ops = &gamecube_rtc_ops;\n\n\tdevm_rtc_register_device(rtc);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gamecube_rtc_of_match[] = {\n\t{.compatible = \"nintendo,latte-exi\" },\n\t{.compatible = \"nintendo,hollywood-exi\" },\n\t{.compatible = \"nintendo,flipper-exi\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gamecube_rtc_of_match);\n\nstatic struct platform_driver gamecube_rtc_driver = {\n\t.probe\t\t= gamecube_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-gamecube\",\n\t\t.of_match_table\t= gamecube_rtc_of_match,\n\t},\n};\nmodule_platform_driver(gamecube_rtc_driver);\n\nMODULE_AUTHOR(\"Emmanuel Gil Peyrot <linkmauve@linkmauve.fr>\");\nMODULE_DESCRIPTION(\"Nintendo GameCube, Wii and Wii U RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}