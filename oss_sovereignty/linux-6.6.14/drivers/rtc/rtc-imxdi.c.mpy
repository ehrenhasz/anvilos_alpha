{
  "module_name": "rtc-imxdi.c",
  "hash_id": "55a92b37d93df1df562dc610cbf939440dfd5039e7c0db56b602dff3b7630bd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-imxdi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/rtc.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n\n \n\n#define DTCMR     0x00            \n#define DTCLR     0x04            \n\n#define DCAMR     0x08            \n#define DCALR     0x0c            \n#define DCAMR_UNSET  0xFFFFFFFF   \n\n#define DCR       0x10            \n#define DCR_TDCHL (1 << 30)       \n#define DCR_TDCSL (1 << 29)       \n#define DCR_KSSL  (1 << 27)       \n#define DCR_MCHL  (1 << 20)       \n#define DCR_MCSL  (1 << 19)       \n#define DCR_TCHL  (1 << 18)       \n#define DCR_TCSL  (1 << 17)       \n#define DCR_FSHL  (1 << 16)       \n#define DCR_TCE   (1 << 3)        \n#define DCR_MCE   (1 << 2)        \n\n#define DSR       0x14            \n#define DSR_WTD   (1 << 23)       \n#define DSR_ETBD  (1 << 22)       \n#define DSR_ETAD  (1 << 21)       \n#define DSR_EBD   (1 << 20)       \n#define DSR_SAD   (1 << 19)       \n#define DSR_TTD   (1 << 18)       \n#define DSR_CTD   (1 << 17)       \n#define DSR_VTD   (1 << 16)       \n#define DSR_WBF   (1 << 10)       \n#define DSR_WNF   (1 << 9)        \n#define DSR_WCF   (1 << 8)        \n#define DSR_WEF   (1 << 7)        \n#define DSR_CAF   (1 << 4)        \n#define DSR_MCO   (1 << 3)        \n#define DSR_TCO   (1 << 2)        \n#define DSR_NVF   (1 << 1)        \n#define DSR_SVF   (1 << 0)        \n\n#define DIER      0x18            \n#define DIER_WNIE (1 << 9)        \n#define DIER_WCIE (1 << 8)        \n#define DIER_WEIE (1 << 7)        \n#define DIER_CAIE (1 << 4)        \n#define DIER_SVIE (1 << 0)        \n\n#define DMCR      0x1c            \n\n#define DTCR      0x28            \n#define DTCR_MOE  (1 << 9)        \n#define DTCR_TOE  (1 << 8)        \n#define DTCR_WTE  (1 << 7)        \n#define DTCR_ETBE (1 << 6)        \n#define DTCR_ETAE (1 << 5)        \n#define DTCR_EBE  (1 << 4)        \n#define DTCR_SAIE (1 << 3)        \n#define DTCR_TTE  (1 << 2)        \n#define DTCR_CTE  (1 << 1)        \n#define DTCR_VTE  (1 << 0)        \n\n#define DGPR      0x3c            \n\n \nstruct imxdi_dev {\n\tstruct platform_device *pdev;\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n\tstruct clk *clk;\n\tu32 dsr;\n\tspinlock_t irq_lock;\n\twait_queue_head_t write_wait;\n\tstruct mutex write_mutex;\n\tstruct work_struct work;\n};\n\n \n\n \nstatic void di_write_busy_wait(const struct imxdi_dev *imxdi, u32 val,\n\t\t\t       unsigned reg)\n{\n\t \n\twritel(val, imxdi->ioaddr + reg);\n\n\t \n\tusleep_range(130, 200);\n}\n\nstatic void di_report_tamper_info(struct imxdi_dev *imxdi,  u32 dsr)\n{\n\tu32 dtcr;\n\n\tdtcr = readl(imxdi->ioaddr + DTCR);\n\n\tdev_emerg(&imxdi->pdev->dev, \"DryIce tamper event detected\\n\");\n\t \n\tif (dsr & DSR_VTD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sVoltage Tamper Event\\n\",\n\t\t\t  dtcr & DTCR_VTE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_CTD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%s32768 Hz Clock Tamper Event\\n\",\n\t\t\t  dtcr & DTCR_CTE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_TTD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sTemperature Tamper Event\\n\",\n\t\t\t  dtcr & DTCR_TTE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_SAD)\n\t\tdev_emerg(&imxdi->pdev->dev,\n\t\t\t  \"%sSecure Controller Alarm Event\\n\",\n\t\t\t  dtcr & DTCR_SAIE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_EBD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sExternal Boot Tamper Event\\n\",\n\t\t\t  dtcr & DTCR_EBE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_ETAD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sExternal Tamper A Event\\n\",\n\t\t\t  dtcr & DTCR_ETAE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_ETBD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sExternal Tamper B Event\\n\",\n\t\t\t  dtcr & DTCR_ETBE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_WTD)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sWire-mesh Tamper Event\\n\",\n\t\t\t  dtcr & DTCR_WTE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_MCO)\n\t\tdev_emerg(&imxdi->pdev->dev,\n\t\t\t  \"%sMonotonic-counter Overflow Event\\n\",\n\t\t\t  dtcr & DTCR_MOE ? \"\" : \"Spurious \");\n\n\tif (dsr & DSR_TCO)\n\t\tdev_emerg(&imxdi->pdev->dev, \"%sTimer-counter Overflow Event\\n\",\n\t\t\t  dtcr & DTCR_TOE ? \"\" : \"Spurious \");\n}\n\nstatic void di_what_is_to_be_done(struct imxdi_dev *imxdi,\n\t\t\t\t  const char *power_supply)\n{\n\tdev_emerg(&imxdi->pdev->dev, \"Please cycle the %s power supply in order to get the DryIce/RTC unit working again\\n\",\n\t\t  power_supply);\n}\n\nstatic int di_handle_failure_state(struct imxdi_dev *imxdi, u32 dsr)\n{\n\tu32 dcr;\n\n\tdev_dbg(&imxdi->pdev->dev, \"DSR register reports: %08X\\n\", dsr);\n\n\t \n\tdi_report_tamper_info(imxdi, dsr);\n\n\tdcr = readl(imxdi->ioaddr + DCR);\n\n\tif (dcr & DCR_FSHL) {\n\t\t \n\t\tdi_what_is_to_be_done(imxdi, \"battery\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tdi_what_is_to_be_done(imxdi, \"main\");\n\n\treturn -ENODEV;\n}\n\nstatic int di_handle_valid_state(struct imxdi_dev *imxdi, u32 dsr)\n{\n\t \n\tdi_write_busy_wait(imxdi, DCAMR_UNSET, DCAMR);\n\tdi_write_busy_wait(imxdi, 0, DCALR);\n\n\t \n\tif (dsr & DSR_CAF)\n\t\tdi_write_busy_wait(imxdi, DSR_CAF, DSR);\n\n\treturn 0;\n}\n\nstatic int di_handle_invalid_state(struct imxdi_dev *imxdi, u32 dsr)\n{\n\tu32 dcr, sec;\n\n\t \n\tdi_write_busy_wait(imxdi, 0x00000000, DTCR);\n\t \n\tdi_write_busy_wait(imxdi, DCR_TDCSL, DCR);\n\n\tsec = readl(imxdi->ioaddr + DTCMR);\n\tif (sec != 0)\n\t\tdev_warn(&imxdi->pdev->dev,\n\t\t\t \"The security violation has happened at %u seconds\\n\",\n\t\t\t sec);\n\t \n\tdcr = readl(imxdi->ioaddr + DCR);\n\tif (!(dcr & DCR_TCE)) {\n\t\tif (dcr & DCR_TCHL) {\n\t\t\t \n\t\t\tdi_what_is_to_be_done(imxdi, \"battery\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (dcr & DCR_TCSL) {\n\t\t\tdi_what_is_to_be_done(imxdi, \"main\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\t \n\t \n\tdi_write_busy_wait(imxdi, DSR_NVF, DSR);\n\t \n\tdi_write_busy_wait(imxdi, DSR_TCO, DSR);\n\t \n\tdi_write_busy_wait(imxdi, dcr | DCR_TCE, DCR);\n\t \n\tdi_write_busy_wait(imxdi, sec, DTCMR);\n\n\t \n\treturn di_handle_valid_state(imxdi, __raw_readl(imxdi->ioaddr + DSR));\n}\n\nstatic int di_handle_invalid_and_failure_state(struct imxdi_dev *imxdi, u32 dsr)\n{\n\tu32 dcr;\n\n\t \n\tif (dsr & (DSR_WTD | DSR_ETBD | DSR_ETAD | DSR_EBD | DSR_SAD |\n\t\t\tDSR_TTD | DSR_CTD | DSR_VTD | DSR_MCO | DSR_TCO)) {\n\t\tdcr = __raw_readl(imxdi->ioaddr + DCR);\n\t\tif (dcr & DCR_TDCHL) {\n\t\t\t \n\t\t\t \n\t\t\tdi_what_is_to_be_done(imxdi, \"battery\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (dcr & DCR_TDCSL) {\n\t\t\t \n\t\t\tdi_what_is_to_be_done(imxdi, \"main\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tdi_write_busy_wait(imxdi, 0x00000000, DTCR);\n\n\t \n\tdi_write_busy_wait(imxdi, dsr & (DSR_WTD | DSR_ETBD | DSR_ETAD |\n\t\t\tDSR_EBD | DSR_SAD | DSR_TTD | DSR_CTD | DSR_VTD |\n\t\t\tDSR_MCO | DSR_TCO), DSR);\n\n\tdsr = readl(imxdi->ioaddr + DSR);\n\tif ((dsr & ~(DSR_NVF | DSR_SVF | DSR_WBF | DSR_WNF |\n\t\t\tDSR_WCF | DSR_WEF)) != 0)\n\t\tdev_warn(&imxdi->pdev->dev,\n\t\t\t \"There are still some sources of pain in DSR: %08x!\\n\",\n\t\t\t dsr & ~(DSR_NVF | DSR_SVF | DSR_WBF | DSR_WNF |\n\t\t\t\t DSR_WCF | DSR_WEF));\n\n\t \n\tdi_write_busy_wait(imxdi, DSR_SVF, DSR);\n\n\t \n\tdsr = readl(imxdi->ioaddr + DSR);\n\tif (dsr & DSR_SVF) {\n\t\tdev_crit(&imxdi->pdev->dev,\n\t\t\t \"Cannot clear the security violation flag. We are ending up in an endless loop!\\n\");\n\t\t \n\t\tdi_what_is_to_be_done(imxdi, \"battery\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\treturn di_handle_invalid_state(imxdi, dsr);\n}\n\nstatic int di_handle_state(struct imxdi_dev *imxdi)\n{\n\tint rc;\n\tu32 dsr;\n\n\tdsr = readl(imxdi->ioaddr + DSR);\n\n\tswitch (dsr & (DSR_NVF | DSR_SVF)) {\n\tcase DSR_NVF:\n\t\tdev_warn(&imxdi->pdev->dev, \"Invalid stated unit detected\\n\");\n\t\trc = di_handle_invalid_state(imxdi, dsr);\n\t\tbreak;\n\tcase DSR_SVF:\n\t\tdev_warn(&imxdi->pdev->dev, \"Failure stated unit detected\\n\");\n\t\trc = di_handle_failure_state(imxdi, dsr);\n\t\tbreak;\n\tcase DSR_NVF | DSR_SVF:\n\t\tdev_warn(&imxdi->pdev->dev,\n\t\t\t \"Failure+Invalid stated unit detected\\n\");\n\t\trc = di_handle_invalid_and_failure_state(imxdi, dsr);\n\t\tbreak;\n\tdefault:\n\t\tdev_notice(&imxdi->pdev->dev, \"Unlocked unit detected\\n\");\n\t\trc = di_handle_valid_state(imxdi, dsr);\n\t}\n\n\treturn rc;\n}\n\n \nstatic void di_int_enable(struct imxdi_dev *imxdi, u32 intr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdi->irq_lock, flags);\n\twritel(readl(imxdi->ioaddr + DIER) | intr,\n\t       imxdi->ioaddr + DIER);\n\tspin_unlock_irqrestore(&imxdi->irq_lock, flags);\n}\n\n \nstatic void di_int_disable(struct imxdi_dev *imxdi, u32 intr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&imxdi->irq_lock, flags);\n\twritel(readl(imxdi->ioaddr + DIER) & ~intr,\n\t       imxdi->ioaddr + DIER);\n\tspin_unlock_irqrestore(&imxdi->irq_lock, flags);\n}\n\n \nstatic void clear_write_error(struct imxdi_dev *imxdi)\n{\n\tint cnt;\n\n\tdev_warn(&imxdi->pdev->dev, \"WARNING: Register write error!\\n\");\n\n\t \n\twritel(DSR_WEF, imxdi->ioaddr + DSR);\n\n\t \n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tif ((readl(imxdi->ioaddr + DSR) & DSR_WEF) == 0)\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\tdev_err(&imxdi->pdev->dev,\n\t\t\t\"ERROR: Cannot clear write-error flag!\\n\");\n}\n\n \nstatic int di_write_wait(struct imxdi_dev *imxdi, u32 val, int reg)\n{\n\tint ret;\n\tint rc = 0;\n\n\t \n\tmutex_lock(&imxdi->write_mutex);\n\n\t \n\tdi_int_enable(imxdi, DIER_WCIE);\n\n\timxdi->dsr = 0;\n\n\t \n\twritel(val, imxdi->ioaddr + reg);\n\n\t \n\tret = wait_event_interruptible_timeout(imxdi->write_wait,\n\t\t\timxdi->dsr & (DSR_WCF | DSR_WEF), msecs_to_jiffies(1));\n\tif (ret < 0) {\n\t\trc = ret;\n\t\tgoto out;\n\t} else if (ret == 0) {\n\t\tdev_warn(&imxdi->pdev->dev,\n\t\t\t\t\"Write-wait timeout \"\n\t\t\t\t\"val = 0x%08x reg = 0x%08x\\n\", val, reg);\n\t}\n\n\t \n\tif (imxdi->dsr & DSR_WEF) {\n\t\tclear_write_error(imxdi);\n\t\trc = -EIO;\n\t}\n\nout:\n\tmutex_unlock(&imxdi->write_mutex);\n\n\treturn rc;\n}\n\n \nstatic int dryice_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\n\tunsigned long now;\n\n\tnow = readl(imxdi->ioaddr + DTCMR);\n\trtc_time64_to_tm(now, tm);\n\n\treturn 0;\n}\n\n \nstatic int dryice_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\n\tu32 dcr, dsr;\n\tint rc;\n\n\tdcr = readl(imxdi->ioaddr + DCR);\n\tdsr = readl(imxdi->ioaddr + DSR);\n\n\tif (!(dcr & DCR_TCE) || (dsr & DSR_SVF)) {\n\t\tif (dcr & DCR_TCHL) {\n\t\t\t \n\t\t\tdi_what_is_to_be_done(imxdi, \"battery\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif ((dcr & DCR_TCSL) || (dsr & DSR_SVF)) {\n\t\t\t \n\t\t\tdi_what_is_to_be_done(imxdi, \"main\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t \n\trc = di_write_wait(imxdi, 0, DTCLR);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = di_write_wait(imxdi, rtc_tm_to_time64(tm), DTCMR);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn di_write_wait(imxdi, readl(imxdi->ioaddr + DCR) | DCR_TCE, DCR);\n}\n\nstatic int dryice_rtc_alarm_irq_enable(struct device *dev,\n\t\tunsigned int enabled)\n{\n\tstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\tdi_int_enable(imxdi, DIER_CAIE);\n\telse\n\t\tdi_int_disable(imxdi, DIER_CAIE);\n\n\treturn 0;\n}\n\n \nstatic int dryice_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\n\tu32 dcamr;\n\n\tdcamr = readl(imxdi->ioaddr + DCAMR);\n\trtc_time64_to_tm(dcamr, &alarm->time);\n\n\t \n\talarm->enabled = (readl(imxdi->ioaddr + DIER) & DIER_CAIE) != 0;\n\n\t \n\tmutex_lock(&imxdi->write_mutex);\n\n\t \n\talarm->pending = (readl(imxdi->ioaddr + DSR) & DSR_CAF) != 0;\n\n\tmutex_unlock(&imxdi->write_mutex);\n\n\treturn 0;\n}\n\n \nstatic int dryice_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\n\tint rc;\n\n\t \n\trc = di_write_wait(imxdi, rtc_tm_to_time64(&alarm->time), DCAMR);\n\tif (rc)\n\t\treturn rc;\n\n\tif (alarm->enabled)\n\t\tdi_int_enable(imxdi, DIER_CAIE);   \n\telse\n\t\tdi_int_disable(imxdi, DIER_CAIE);  \n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops dryice_rtc_ops = {\n\t.read_time\t\t= dryice_rtc_read_time,\n\t.set_time\t\t= dryice_rtc_set_time,\n\t.alarm_irq_enable\t= dryice_rtc_alarm_irq_enable,\n\t.read_alarm\t\t= dryice_rtc_read_alarm,\n\t.set_alarm\t\t= dryice_rtc_set_alarm,\n};\n\n \nstatic irqreturn_t dryice_irq(int irq, void *dev_id)\n{\n\tstruct imxdi_dev *imxdi = dev_id;\n\tu32 dsr, dier;\n\tirqreturn_t rc = IRQ_NONE;\n\n\tdier = readl(imxdi->ioaddr + DIER);\n\tdsr = readl(imxdi->ioaddr + DSR);\n\n\t \n\tif (dier & DIER_SVIE) {\n\t\tif (dsr & DSR_SVF) {\n\t\t\t \n\t\t\tdi_int_disable(imxdi, DIER_SVIE);\n\t\t\t \n\t\t\tdi_report_tamper_info(imxdi, dsr);\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif (dier & DIER_WCIE) {\n\t\t \n\t\tif (list_empty_careful(&imxdi->write_wait.head))\n\t\t\treturn rc;\n\n\t\t \n\t\tif (dsr & (DSR_WCF | DSR_WEF)) {\n\t\t\t \n\t\t\tdi_int_disable(imxdi, DIER_WCIE);\n\n\t\t\t \n\t\t\timxdi->dsr |= dsr;\n\n\t\t\twake_up_interruptible(&imxdi->write_wait);\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif (dier & DIER_CAIE) {\n\t\t \n\t\tif (dsr & DSR_CAF) {\n\t\t\t \n\t\t\tdi_int_disable(imxdi, DIER_CAIE);\n\n\t\t\t \n\t\t\tschedule_work(&imxdi->work);\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic void dryice_work(struct work_struct *work)\n{\n\tstruct imxdi_dev *imxdi = container_of(work,\n\t\t\tstruct imxdi_dev, work);\n\n\t \n\tdi_write_wait(imxdi, DSR_CAF, DSR);\n\n\t \n\trtc_update_irq(imxdi->rtc, 1, RTC_AF | RTC_IRQF);\n}\n\n \nstatic int __init dryice_rtc_probe(struct platform_device *pdev)\n{\n\tstruct imxdi_dev *imxdi;\n\tint norm_irq, sec_irq;\n\tint rc;\n\n\timxdi = devm_kzalloc(&pdev->dev, sizeof(*imxdi), GFP_KERNEL);\n\tif (!imxdi)\n\t\treturn -ENOMEM;\n\n\timxdi->pdev = pdev;\n\n\timxdi->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imxdi->ioaddr))\n\t\treturn PTR_ERR(imxdi->ioaddr);\n\n\tspin_lock_init(&imxdi->irq_lock);\n\n\tnorm_irq = platform_get_irq(pdev, 0);\n\tif (norm_irq < 0)\n\t\treturn norm_irq;\n\n\t \n\tsec_irq = platform_get_irq(pdev, 1);\n\tif (sec_irq <= 0)\n\t\tsec_irq = IRQ_NOTCONNECTED;\n\n\tinit_waitqueue_head(&imxdi->write_wait);\n\n\tINIT_WORK(&imxdi->work, dryice_work);\n\n\tmutex_init(&imxdi->write_mutex);\n\n\timxdi->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(imxdi->rtc))\n\t\treturn PTR_ERR(imxdi->rtc);\n\n\timxdi->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(imxdi->clk))\n\t\treturn PTR_ERR(imxdi->clk);\n\trc = clk_prepare_enable(imxdi->clk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\t \n\twritel(0, imxdi->ioaddr + DIER);\n\n\trc = di_handle_state(imxdi);\n\tif (rc != 0)\n\t\tgoto err;\n\n\trc = devm_request_irq(&pdev->dev, norm_irq, dryice_irq,\n\t\t\t      IRQF_SHARED, pdev->name, imxdi);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"interrupt not available.\\n\");\n\t\tgoto err;\n\t}\n\n\trc = devm_request_irq(&pdev->dev, sec_irq, dryice_irq,\n\t\t\t      IRQF_SHARED, pdev->name, imxdi);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"security violation interrupt not available.\\n\");\n\t\t \n\t}\n\n\tplatform_set_drvdata(pdev, imxdi);\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tdev_pm_set_wake_irq(&pdev->dev, norm_irq);\n\n\timxdi->rtc->ops = &dryice_rtc_ops;\n\timxdi->rtc->range_max = U32_MAX;\n\n\trc = devm_rtc_register_device(imxdi->rtc);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(imxdi->clk);\n\n\treturn rc;\n}\n\nstatic int __exit dryice_rtc_remove(struct platform_device *pdev)\n{\n\tstruct imxdi_dev *imxdi = platform_get_drvdata(pdev);\n\n\tflush_work(&imxdi->work);\n\n\t \n\twritel(0, imxdi->ioaddr + DIER);\n\n\tclk_disable_unprepare(imxdi->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dryice_dt_ids[] = {\n\t{ .compatible = \"fsl,imx25-rtc\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, dryice_dt_ids);\n\nstatic struct platform_driver dryice_rtc_driver = {\n\t.driver = {\n\t\t   .name = \"imxdi_rtc\",\n\t\t   .of_match_table = dryice_dt_ids,\n\t\t   },\n\t.remove = __exit_p(dryice_rtc_remove),\n};\n\nmodule_platform_driver_probe(dryice_rtc_driver, dryice_rtc_probe);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"IMX DryIce Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}