{
  "module_name": "rtc-pl031.c",
  "hash_id": "94b960946928f95ce4f2329b6c8ffec203ab3102e3d0ea5a490a046674d51291",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pl031.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/amba/bus.h>\n#include <linux/io.h>\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/slab.h>\n\n \n#define\tRTC_DR\t\t0x00\t \n#define\tRTC_MR\t\t0x04\t \n#define\tRTC_LR\t\t0x08\t \n#define\tRTC_CR\t\t0x0c\t \n#define\tRTC_IMSC\t0x10\t \n#define\tRTC_RIS\t\t0x14\t \n#define\tRTC_MIS\t\t0x18\t \n#define\tRTC_ICR\t\t0x1c\t \n \n#define RTC_TDR\t\t0x20\t \n#define RTC_TLR\t\t0x24\t \n#define RTC_TCR\t\t0x28\t \n#define RTC_YDR\t\t0x30\t \n#define RTC_YMR\t\t0x34\t \n#define RTC_YLR\t\t0x38\t \n\n#define RTC_CR_EN\t(1 << 0)\t \n#define RTC_CR_CWEN\t(1 << 26)\t \n\n#define RTC_TCR_EN\t(1 << 1)  \n\n \n#define RTC_BIT_AI\t(1 << 0)  \n#define RTC_BIT_PI\t(1 << 1)  \n\n \n#define RTC_SEC_SHIFT 0\n#define RTC_SEC_MASK (0x3F << RTC_SEC_SHIFT)  \n#define RTC_MIN_SHIFT 6\n#define RTC_MIN_MASK (0x3F << RTC_MIN_SHIFT)  \n#define RTC_HOUR_SHIFT 12\n#define RTC_HOUR_MASK (0x1F << RTC_HOUR_SHIFT)  \n#define RTC_WDAY_SHIFT 17\n#define RTC_WDAY_MASK (0x7 << RTC_WDAY_SHIFT)  \n#define RTC_MDAY_SHIFT 20\n#define RTC_MDAY_MASK (0x1F << RTC_MDAY_SHIFT)  \n#define RTC_MON_SHIFT 25\n#define RTC_MON_MASK (0xF << RTC_MON_SHIFT)  \n\n#define RTC_TIMER_FREQ 32768\n\n \nstruct pl031_vendor_data {\n\tstruct rtc_class_ops ops;\n\tbool clockwatch;\n\tbool st_weekday;\n\tunsigned long irqflags;\n\ttime64_t range_min;\n\ttimeu64_t range_max;\n};\n\nstruct pl031_local {\n\tstruct pl031_vendor_data *vendor;\n\tstruct rtc_device *rtc;\n\tvoid __iomem *base;\n};\n\nstatic int pl031_alarm_irq_enable(struct device *dev,\n\tunsigned int enabled)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\tunsigned long imsc;\n\n\t \n\twritel(RTC_BIT_AI, ldata->base + RTC_ICR);\n\n\timsc = readl(ldata->base + RTC_IMSC);\n\n\tif (enabled == 1)\n\t\twritel(imsc | RTC_BIT_AI, ldata->base + RTC_IMSC);\n\telse\n\t\twritel(imsc & ~RTC_BIT_AI, ldata->base + RTC_IMSC);\n\n\treturn 0;\n}\n\n \nstatic int pl031_stv2_tm_to_time(struct device *dev,\n\t\t\t\t struct rtc_time *tm, unsigned long *st_time,\n\tunsigned long *bcd_year)\n{\n\tint year = tm->tm_year + 1900;\n\tint wday = tm->tm_wday;\n\n\t \n\tif (wday < -1 || wday > 6) {\n\t\tdev_err(dev, \"invalid wday value %d\\n\", tm->tm_wday);\n\t\treturn -EINVAL;\n\t} else if (wday == -1) {\n\t\t \n\t\tstruct rtc_time calc_tm;\n\n\t\trtc_time64_to_tm(rtc_tm_to_time64(tm), &calc_tm);\n\t\twday = calc_tm.tm_wday;\n\t}\n\n\t*bcd_year = (bin2bcd(year % 100) | bin2bcd(year / 100) << 8);\n\n\t*st_time = ((tm->tm_mon + 1) << RTC_MON_SHIFT)\n\t\t\t|\t(tm->tm_mday << RTC_MDAY_SHIFT)\n\t\t\t|\t((wday + 1) << RTC_WDAY_SHIFT)\n\t\t\t|\t(tm->tm_hour << RTC_HOUR_SHIFT)\n\t\t\t|\t(tm->tm_min << RTC_MIN_SHIFT)\n\t\t\t|\t(tm->tm_sec << RTC_SEC_SHIFT);\n\n\treturn 0;\n}\n\n \nstatic int pl031_stv2_time_to_tm(unsigned long st_time, unsigned long bcd_year,\n\tstruct rtc_time *tm)\n{\n\ttm->tm_year = bcd2bin(bcd_year) + (bcd2bin(bcd_year >> 8) * 100);\n\ttm->tm_mon  = ((st_time & RTC_MON_MASK) >> RTC_MON_SHIFT) - 1;\n\ttm->tm_mday = ((st_time & RTC_MDAY_MASK) >> RTC_MDAY_SHIFT);\n\ttm->tm_wday = ((st_time & RTC_WDAY_MASK) >> RTC_WDAY_SHIFT) - 1;\n\ttm->tm_hour = ((st_time & RTC_HOUR_MASK) >> RTC_HOUR_SHIFT);\n\ttm->tm_min  = ((st_time & RTC_MIN_MASK) >> RTC_MIN_SHIFT);\n\ttm->tm_sec  = ((st_time & RTC_SEC_MASK) >> RTC_SEC_SHIFT);\n\n\ttm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\n\ttm->tm_year -= 1900;\n\n\treturn 0;\n}\n\nstatic int pl031_stv2_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\n\tpl031_stv2_time_to_tm(readl(ldata->base + RTC_DR),\n\t\t\treadl(ldata->base + RTC_YDR), tm);\n\n\treturn 0;\n}\n\nstatic int pl031_stv2_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long time;\n\tunsigned long bcd_year;\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pl031_stv2_tm_to_time(dev, tm, &time, &bcd_year);\n\tif (ret == 0) {\n\t\twritel(bcd_year, ldata->base + RTC_YLR);\n\t\twritel(time, ldata->base + RTC_LR);\n\t}\n\n\treturn ret;\n}\n\nstatic int pl031_stv2_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pl031_stv2_time_to_tm(readl(ldata->base + RTC_MR),\n\t\t\treadl(ldata->base + RTC_YMR), &alarm->time);\n\n\talarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;\n\talarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;\n\n\treturn ret;\n}\n\nstatic int pl031_stv2_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\tunsigned long time;\n\tunsigned long bcd_year;\n\tint ret;\n\n\tret = pl031_stv2_tm_to_time(dev, &alarm->time,\n\t\t\t\t    &time, &bcd_year);\n\tif (ret == 0) {\n\t\twritel(bcd_year, ldata->base + RTC_YMR);\n\t\twritel(time, ldata->base + RTC_MR);\n\n\t\tpl031_alarm_irq_enable(dev, alarm->enabled);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t pl031_interrupt(int irq, void *dev_id)\n{\n\tstruct pl031_local *ldata = dev_id;\n\tunsigned long rtcmis;\n\tunsigned long events = 0;\n\n\trtcmis = readl(ldata->base + RTC_MIS);\n\tif (rtcmis & RTC_BIT_AI) {\n\t\twritel(RTC_BIT_AI, ldata->base + RTC_ICR);\n\t\tevents |= (RTC_AF | RTC_IRQF);\n\t\trtc_update_irq(ldata->rtc, 1, events);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int pl031_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(ldata->base + RTC_DR), tm);\n\n\treturn 0;\n}\n\nstatic int pl031_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(tm), ldata->base + RTC_LR);\n\n\treturn 0;\n}\n\nstatic int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(ldata->base + RTC_MR), &alarm->time);\n\n\talarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;\n\talarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;\n\n\treturn 0;\n}\n\nstatic int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(dev);\n\n\twritel(rtc_tm_to_time64(&alarm->time), ldata->base + RTC_MR);\n\tpl031_alarm_irq_enable(dev, alarm->enabled);\n\n\treturn 0;\n}\n\nstatic void pl031_remove(struct amba_device *adev)\n{\n\tstruct pl031_local *ldata = dev_get_drvdata(&adev->dev);\n\n\tdev_pm_clear_wake_irq(&adev->dev);\n\tdevice_init_wakeup(&adev->dev, false);\n\tif (adev->irq[0])\n\t\tfree_irq(adev->irq[0], ldata);\n\tamba_release_regions(adev);\n}\n\nstatic int pl031_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret;\n\tstruct pl031_local *ldata;\n\tstruct pl031_vendor_data *vendor = id->data;\n\tstruct rtc_class_ops *ops;\n\tunsigned long time, data;\n\n\tret = amba_request_regions(adev, NULL);\n\tif (ret)\n\t\tgoto err_req;\n\n\tldata = devm_kzalloc(&adev->dev, sizeof(struct pl031_local),\n\t\t\t     GFP_KERNEL);\n\tops = devm_kmemdup(&adev->dev, &vendor->ops, sizeof(vendor->ops),\n\t\t\t   GFP_KERNEL);\n\tif (!ldata || !ops) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tldata->vendor = vendor;\n\tldata->base = devm_ioremap(&adev->dev, adev->res.start,\n\t\t\t\t   resource_size(&adev->res));\n\tif (!ldata->base) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tamba_set_drvdata(adev, ldata);\n\n\tdev_dbg(&adev->dev, \"designer ID = 0x%02x\\n\", amba_manf(adev));\n\tdev_dbg(&adev->dev, \"revision = 0x%01x\\n\", amba_rev(adev));\n\n\tdata = readl(ldata->base + RTC_CR);\n\t \n\tif (vendor->clockwatch)\n\t\tdata |= RTC_CR_CWEN;\n\telse\n\t\tdata |= RTC_CR_EN;\n\twritel(data, ldata->base + RTC_CR);\n\n\t \n\tif (vendor->st_weekday) {\n\t\tif (readl(ldata->base + RTC_YDR) == 0x2000) {\n\t\t\ttime = readl(ldata->base + RTC_DR);\n\t\t\tif ((time &\n\t\t\t     (RTC_MON_MASK | RTC_MDAY_MASK | RTC_WDAY_MASK))\n\t\t\t    == 0x02120000) {\n\t\t\t\ttime = time | (0x7 << RTC_WDAY_SHIFT);\n\t\t\t\twritel(0x2000, ldata->base + RTC_YLR);\n\t\t\t\twritel(time, ldata->base + RTC_LR);\n\t\t\t}\n\t\t}\n\t}\n\n\tdevice_init_wakeup(&adev->dev, true);\n\tldata->rtc = devm_rtc_allocate_device(&adev->dev);\n\tif (IS_ERR(ldata->rtc)) {\n\t\tret = PTR_ERR(ldata->rtc);\n\t\tgoto out;\n\t}\n\n\tif (!adev->irq[0])\n\t\tclear_bit(RTC_FEATURE_ALARM, ldata->rtc->features);\n\n\tldata->rtc->ops = ops;\n\tldata->rtc->range_min = vendor->range_min;\n\tldata->rtc->range_max = vendor->range_max;\n\n\tret = devm_rtc_register_device(ldata->rtc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (adev->irq[0]) {\n\t\tret = request_irq(adev->irq[0], pl031_interrupt,\n\t\t\t\t  vendor->irqflags, \"rtc-pl031\", ldata);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdev_pm_set_wake_irq(&adev->dev, adev->irq[0]);\n\t}\n\treturn 0;\n\nout:\n\tamba_release_regions(adev);\nerr_req:\n\n\treturn ret;\n}\n\n \nstatic struct pl031_vendor_data arm_pl031 = {\n\t.ops = {\n\t\t.read_time = pl031_read_time,\n\t\t.set_time = pl031_set_time,\n\t\t.read_alarm = pl031_read_alarm,\n\t\t.set_alarm = pl031_set_alarm,\n\t\t.alarm_irq_enable = pl031_alarm_irq_enable,\n\t},\n\t.range_max = U32_MAX,\n};\n\n \nstatic struct pl031_vendor_data stv1_pl031 = {\n\t.ops = {\n\t\t.read_time = pl031_read_time,\n\t\t.set_time = pl031_set_time,\n\t\t.read_alarm = pl031_read_alarm,\n\t\t.set_alarm = pl031_set_alarm,\n\t\t.alarm_irq_enable = pl031_alarm_irq_enable,\n\t},\n\t.clockwatch = true,\n\t.st_weekday = true,\n\t.range_max = U32_MAX,\n};\n\n \nstatic struct pl031_vendor_data stv2_pl031 = {\n\t.ops = {\n\t\t.read_time = pl031_stv2_read_time,\n\t\t.set_time = pl031_stv2_set_time,\n\t\t.read_alarm = pl031_stv2_read_alarm,\n\t\t.set_alarm = pl031_stv2_set_alarm,\n\t\t.alarm_irq_enable = pl031_alarm_irq_enable,\n\t},\n\t.clockwatch = true,\n\t.st_weekday = true,\n\t \n\t.irqflags = IRQF_SHARED | IRQF_COND_SUSPEND,\n\t.range_min = RTC_TIMESTAMP_BEGIN_0000,\n\t.range_max = RTC_TIMESTAMP_END_9999,\n};\n\nstatic const struct amba_id pl031_ids[] = {\n\t{\n\t\t.id = 0x00041031,\n\t\t.mask = 0x000fffff,\n\t\t.data = &arm_pl031,\n\t},\n\t \n\t{\n\t\t.id = 0x00180031,\n\t\t.mask = 0x00ffffff,\n\t\t.data = &stv1_pl031,\n\t},\n\t{\n\t\t.id = 0x00280031,\n\t\t.mask = 0x00ffffff,\n\t\t.data = &stv2_pl031,\n\t},\n\t{0, 0},\n};\n\nMODULE_DEVICE_TABLE(amba, pl031_ids);\n\nstatic struct amba_driver pl031_driver = {\n\t.drv = {\n\t\t.name = \"rtc-pl031\",\n\t},\n\t.id_table = pl031_ids,\n\t.probe = pl031_probe,\n\t.remove = pl031_remove,\n};\n\nmodule_amba_driver(pl031_driver);\n\nMODULE_AUTHOR(\"Deepak Saxena <dsaxena@plexity.net>\");\nMODULE_DESCRIPTION(\"ARM AMBA PL031 RTC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}