{
  "module_name": "rtc-asm9260.c",
  "hash_id": "51c94c32d72fcdca9637f00cd62dd49e11a4ef6b7f5f387881b8784b31d0f078",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-asm9260.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n \n \n#define HW_ILR\t\t\t0x00\n#define BM_RTCALF\t\tBIT(1)\n#define BM_RTCCIF\t\tBIT(0)\n\n \n#define HW_CCR\t\t\t0x08\n \n#define BM_CCALOFF\t\tBIT(4)\n \n#define BM_CTCRST\t\tBIT(1)\n \n#define BM_CLKEN\t\tBIT(0)\n\n \n#define HW_CIIR\t\t\t0x0C\n#define BM_CIIR_IMYEAR\t\tBIT(7)\n#define BM_CIIR_IMMON\t\tBIT(6)\n#define BM_CIIR_IMDOY\t\tBIT(5)\n#define BM_CIIR_IMDOW\t\tBIT(4)\n#define BM_CIIR_IMDOM\t\tBIT(3)\n#define BM_CIIR_IMHOUR\t\tBIT(2)\n#define BM_CIIR_IMMIN\t\tBIT(1)\n#define BM_CIIR_IMSEC\t\tBIT(0)\n\n \n#define HW_AMR\t\t\t0x10\n#define BM_AMR_IMYEAR\t\tBIT(7)\n#define BM_AMR_IMMON\t\tBIT(6)\n#define BM_AMR_IMDOY\t\tBIT(5)\n#define BM_AMR_IMDOW\t\tBIT(4)\n#define BM_AMR_IMDOM\t\tBIT(3)\n#define BM_AMR_IMHOUR\t\tBIT(2)\n#define BM_AMR_IMMIN\t\tBIT(1)\n#define BM_AMR_IMSEC\t\tBIT(0)\n#define BM_AMR_OFF\t\t0xff\n\n \n#define HW_CTIME0\t\t0x14\n#define BM_CTIME0_DOW_S\t\t24\n#define BM_CTIME0_DOW_M\t\t0x7\n#define BM_CTIME0_HOUR_S\t16\n#define BM_CTIME0_HOUR_M\t0x1f\n#define BM_CTIME0_MIN_S\t\t8\n#define BM_CTIME0_MIN_M\t\t0x3f\n#define BM_CTIME0_SEC_S\t\t0\n#define BM_CTIME0_SEC_M\t\t0x3f\n\n#define HW_CTIME1\t\t0x18\n#define BM_CTIME1_YEAR_S\t16\n#define BM_CTIME1_YEAR_M\t0xfff\n#define BM_CTIME1_MON_S\t\t8\n#define BM_CTIME1_MON_M\t\t0xf\n#define BM_CTIME1_DOM_S\t\t0\n#define BM_CTIME1_DOM_M\t\t0x1f\n\n#define HW_CTIME2\t\t0x1C\n#define BM_CTIME2_DOY_S\t\t0\n#define BM_CTIME2_DOY_M\t\t0xfff\n\n \n#define HW_SEC\t\t\t0x20\n#define HW_MIN\t\t\t0x24\n#define HW_HOUR\t\t\t0x28\n#define HW_DOM\t\t\t0x2C\n#define HW_DOW\t\t\t0x30\n#define HW_DOY\t\t\t0x34\n#define HW_MONTH\t\t0x38\n#define HW_YEAR\t\t\t0x3C\n\n#define HW_CALIBRATION\t\t0x40\n#define BM_CALDIR_BACK\t\tBIT(17)\n#define BM_CALVAL_M\t\t0x1ffff\n\n \n#define HW_GPREG0\t\t0x44\n#define HW_GPREG1\t\t0x48\n#define HW_GPREG2\t\t0x4C\n#define HW_GPREG3\t\t0x50\n#define HW_GPREG4\t\t0x54\n\n \n#define HW_ALSEC\t\t0x60\n#define HW_ALMIN\t\t0x64\n#define HW_ALHOUR\t\t0x68\n#define HW_ALDOM\t\t0x6C\n#define HW_ALDOW\t\t0x70\n#define HW_ALDOY\t\t0x74\n#define HW_ALMON\t\t0x78\n#define HW_ALYEAR\t\t0x7C\n\nstruct asm9260_rtc_priv {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*iobase;\n\tstruct rtc_device\t*rtc;\n\tstruct clk\t\t*clk;\n};\n\nstatic irqreturn_t asm9260_rtc_irq(int irq, void *dev_id)\n{\n\tstruct asm9260_rtc_priv *priv = dev_id;\n\tu32 isr;\n\tunsigned long events = 0;\n\n\trtc_lock(priv->rtc);\n\tisr = ioread32(priv->iobase + HW_CIIR);\n\tif (!isr) {\n\t\trtc_unlock(priv->rtc);\n\t\treturn IRQ_NONE;\n\t}\n\n\tiowrite32(0, priv->iobase + HW_CIIR);\n\trtc_unlock(priv->rtc);\n\n\tevents |= RTC_AF | RTC_IRQF;\n\n\trtc_update_irq(priv->rtc, 1, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int asm9260_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\n\tu32 ctime0, ctime1, ctime2;\n\n\tctime0 = ioread32(priv->iobase + HW_CTIME0);\n\tctime1 = ioread32(priv->iobase + HW_CTIME1);\n\tctime2 = ioread32(priv->iobase + HW_CTIME2);\n\n\tif (ctime1 != ioread32(priv->iobase + HW_CTIME1)) {\n\t\t \n\t\tctime0 = ioread32(priv->iobase + HW_CTIME0);\n\t\tctime1 = ioread32(priv->iobase + HW_CTIME1);\n\t\tctime2 = ioread32(priv->iobase + HW_CTIME2);\n\t}\n\n\ttm->tm_sec  = (ctime0 >> BM_CTIME0_SEC_S)  & BM_CTIME0_SEC_M;\n\ttm->tm_min  = (ctime0 >> BM_CTIME0_MIN_S)  & BM_CTIME0_MIN_M;\n\ttm->tm_hour = (ctime0 >> BM_CTIME0_HOUR_S) & BM_CTIME0_HOUR_M;\n\ttm->tm_wday = (ctime0 >> BM_CTIME0_DOW_S)  & BM_CTIME0_DOW_M;\n\n\ttm->tm_mday = (ctime1 >> BM_CTIME1_DOM_S)  & BM_CTIME1_DOM_M;\n\ttm->tm_mon  = (ctime1 >> BM_CTIME1_MON_S)  & BM_CTIME1_MON_M;\n\ttm->tm_year = (ctime1 >> BM_CTIME1_YEAR_S) & BM_CTIME1_YEAR_M;\n\n\ttm->tm_yday = (ctime2 >> BM_CTIME2_DOY_S)  & BM_CTIME2_DOY_M;\n\n\treturn 0;\n}\n\nstatic int asm9260_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tiowrite32(0, priv->iobase + HW_SEC);\n\n\tiowrite32(tm->tm_year, priv->iobase + HW_YEAR);\n\tiowrite32(tm->tm_mon,  priv->iobase + HW_MONTH);\n\tiowrite32(tm->tm_mday, priv->iobase + HW_DOM);\n\tiowrite32(tm->tm_wday, priv->iobase + HW_DOW);\n\tiowrite32(tm->tm_yday, priv->iobase + HW_DOY);\n\tiowrite32(tm->tm_hour, priv->iobase + HW_HOUR);\n\tiowrite32(tm->tm_min,  priv->iobase + HW_MIN);\n\tiowrite32(tm->tm_sec,  priv->iobase + HW_SEC);\n\n\treturn 0;\n}\n\nstatic int asm9260_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\n\n\talrm->time.tm_year = ioread32(priv->iobase + HW_ALYEAR);\n\talrm->time.tm_mon  = ioread32(priv->iobase + HW_ALMON);\n\talrm->time.tm_mday = ioread32(priv->iobase + HW_ALDOM);\n\talrm->time.tm_wday = ioread32(priv->iobase + HW_ALDOW);\n\talrm->time.tm_yday = ioread32(priv->iobase + HW_ALDOY);\n\talrm->time.tm_hour = ioread32(priv->iobase + HW_ALHOUR);\n\talrm->time.tm_min  = ioread32(priv->iobase + HW_ALMIN);\n\talrm->time.tm_sec  = ioread32(priv->iobase + HW_ALSEC);\n\n\talrm->enabled = ioread32(priv->iobase + HW_AMR) ? 1 : 0;\n\talrm->pending = ioread32(priv->iobase + HW_CIIR) ? 1 : 0;\n\n\treturn rtc_valid_tm(&alrm->time);\n}\n\nstatic int asm9260_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tiowrite32(alrm->time.tm_year, priv->iobase + HW_ALYEAR);\n\tiowrite32(alrm->time.tm_mon,  priv->iobase + HW_ALMON);\n\tiowrite32(alrm->time.tm_mday, priv->iobase + HW_ALDOM);\n\tiowrite32(alrm->time.tm_wday, priv->iobase + HW_ALDOW);\n\tiowrite32(alrm->time.tm_yday, priv->iobase + HW_ALDOY);\n\tiowrite32(alrm->time.tm_hour, priv->iobase + HW_ALHOUR);\n\tiowrite32(alrm->time.tm_min,  priv->iobase + HW_ALMIN);\n\tiowrite32(alrm->time.tm_sec,  priv->iobase + HW_ALSEC);\n\n\tiowrite32(alrm->enabled ? 0 : BM_AMR_OFF, priv->iobase + HW_AMR);\n\n\treturn 0;\n}\n\nstatic int asm9260_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tiowrite32(enabled ? 0 : BM_AMR_OFF, priv->iobase + HW_AMR);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops asm9260_rtc_ops = {\n\t.read_time\t\t= asm9260_rtc_read_time,\n\t.set_time\t\t= asm9260_rtc_set_time,\n\t.read_alarm\t\t= asm9260_rtc_read_alarm,\n\t.set_alarm\t\t= asm9260_rtc_set_alarm,\n\t.alarm_irq_enable\t= asm9260_alarm_irq_enable,\n};\n\nstatic int asm9260_rtc_probe(struct platform_device *pdev)\n{\n\tstruct asm9260_rtc_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tint irq_alarm, ret;\n\tu32 ccr;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct asm9260_rtc_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, priv);\n\n\tirq_alarm = platform_get_irq(pdev, 0);\n\tif (irq_alarm < 0)\n\t\treturn irq_alarm;\n\n\tpriv->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->iobase))\n\t\treturn PTR_ERR(priv->iobase);\n\n\tpriv->clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clk!\\n\");\n\t\treturn ret;\n\t}\n\n\tccr = ioread32(priv->iobase + HW_CCR);\n\t \n\tif ((ccr & (BM_CLKEN | BM_CTCRST)) != BM_CLKEN) {\n\t\tiowrite32(BM_CTCRST, priv->iobase + HW_CCR);\n\t\tccr = 0;\n\t}\n\n\tiowrite32(BM_CLKEN | ccr, priv->iobase + HW_CCR);\n\tiowrite32(0, priv->iobase + HW_CIIR);\n\tiowrite32(BM_AMR_OFF, priv->iobase + HW_AMR);\n\n\tpriv->rtc = devm_rtc_device_register(dev, dev_name(dev),\n\t\t\t\t\t     &asm9260_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(priv->rtc)) {\n\t\tret = PTR_ERR(priv->rtc);\n\t\tdev_err(dev, \"Failed to register RTC device: %d\\n\", ret);\n\t\tgoto err_return;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq_alarm, NULL,\n\t\t\t\t\tasm9260_rtc_irq, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't get irq %i, err %d\\n\",\n\t\t\tirq_alarm, ret);\n\t\tgoto err_return;\n\t}\n\n\treturn 0;\n\nerr_return:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic void asm9260_rtc_remove(struct platform_device *pdev)\n{\n\tstruct asm9260_rtc_priv *priv = platform_get_drvdata(pdev);\n\n\t \n\tiowrite32(BM_AMR_OFF, priv->iobase + HW_AMR);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic const struct of_device_id asm9260_dt_ids[] = {\n\t{ .compatible = \"alphascale,asm9260-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, asm9260_dt_ids);\n\nstatic struct platform_driver asm9260_rtc_driver = {\n\t.probe\t\t= asm9260_rtc_probe,\n\t.remove_new\t= asm9260_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"asm9260-rtc\",\n\t\t.of_match_table = asm9260_dt_ids,\n\t},\n};\n\nmodule_platform_driver(asm9260_rtc_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <linux@rempel-privat.de>\");\nMODULE_DESCRIPTION(\"Alphascale asm9260 SoC Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}