{
  "module_name": "rtc-isl12022.c",
  "hash_id": "6be35c94dc8b2f982b021816fa56d23db82944fe3fd230f7fe3e9c22794d13a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-isl12022.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n#include <asm/byteorder.h>\n\n \n#define ISL12022_REG_SC\t\t0x00\n#define ISL12022_REG_MN\t\t0x01\n#define ISL12022_REG_HR\t\t0x02\n#define ISL12022_REG_DT\t\t0x03\n#define ISL12022_REG_MO\t\t0x04\n#define ISL12022_REG_YR\t\t0x05\n#define ISL12022_REG_DW\t\t0x06\n\n#define ISL12022_REG_SR\t\t0x07\n#define ISL12022_REG_INT\t0x08\n\n#define ISL12022_REG_PWR_VBAT\t0x0a\n\n#define ISL12022_REG_BETA\t0x0d\n#define ISL12022_REG_TEMP_L\t0x28\n\n \n#define ISL12022_HR_MIL\t\t(1 << 7)\t \n\n#define ISL12022_SR_LBAT85\t(1 << 2)\n#define ISL12022_SR_LBAT75\t(1 << 1)\n\n#define ISL12022_INT_WRTC\t(1 << 6)\n#define ISL12022_INT_FO_MASK\tGENMASK(3, 0)\n#define ISL12022_INT_FO_OFF\t0x0\n#define ISL12022_INT_FO_32K\t0x1\n\n#define ISL12022_REG_VB85_MASK\tGENMASK(5, 3)\n#define ISL12022_REG_VB75_MASK\tGENMASK(2, 0)\n\n#define ISL12022_BETA_TSE\t(1 << 7)\n\nstatic umode_t isl12022_hwmon_is_visible(const void *data,\n\t\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t\t u32 attr, int channel)\n{\n\tif (type == hwmon_temp && attr == hwmon_temp_input)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\n \nstatic int isl12022_hwmon_read_temp(struct device *dev, long *mC)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tint temp, ret;\n\t__le16 buf;\n\n\tret = regmap_bulk_read(regmap, ISL12022_REG_TEMP_L, &buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\t \n\ttemp = le16_to_cpu(buf);\n\ttemp *= 500;\n\ttemp -= 273000;\n\n\t*mC = temp;\n\n\treturn 0;\n}\n\nstatic int isl12022_hwmon_read(struct device *dev,\n\t\t\t       enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel, long *val)\n{\n\tif (type == hwmon_temp && attr == hwmon_temp_input)\n\t\treturn isl12022_hwmon_read_temp(dev, val);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_channel_info * const isl12022_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops isl12022_hwmon_ops = {\n\t.is_visible = isl12022_hwmon_is_visible,\n\t.read = isl12022_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info isl12022_hwmon_chip_info = {\n\t.ops = &isl12022_hwmon_ops,\n\t.info = isl12022_hwmon_info,\n};\n\nstatic void isl12022_hwmon_register(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tstruct device *hwmon;\n\tint ret;\n\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn;\n\n\tret = regmap_update_bits(regmap, ISL12022_REG_BETA,\n\t\t\t\t ISL12022_BETA_TSE, ISL12022_BETA_TSE);\n\tif (ret) {\n\t\tdev_warn(dev, \"unable to enable temperature sensor\\n\");\n\t\treturn;\n\t}\n\n\thwmon = devm_hwmon_device_register_with_info(dev, \"isl12022\", regmap,\n\t\t\t\t\t\t     &isl12022_hwmon_chip_info,\n\t\t\t\t\t\t     NULL);\n\tif (IS_ERR(hwmon))\n\t\tdev_warn(dev, \"unable to register hwmon device: %pe\\n\", hwmon);\n}\n\n \nstatic int isl12022_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tuint8_t buf[ISL12022_REG_INT + 1];\n\tint ret;\n\n\tret = regmap_bulk_read(regmap, ISL12022_REG_SC, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev,\n\t\t\"raw data is sec=%02x, min=%02x, hr=%02x, mday=%02x, mon=%02x, year=%02x, wday=%02x, sr=%02x, int=%02x\",\n\t\tbuf[ISL12022_REG_SC],\n\t\tbuf[ISL12022_REG_MN],\n\t\tbuf[ISL12022_REG_HR],\n\t\tbuf[ISL12022_REG_DT],\n\t\tbuf[ISL12022_REG_MO],\n\t\tbuf[ISL12022_REG_YR],\n\t\tbuf[ISL12022_REG_DW],\n\t\tbuf[ISL12022_REG_SR],\n\t\tbuf[ISL12022_REG_INT]);\n\n\ttm->tm_sec = bcd2bin(buf[ISL12022_REG_SC] & 0x7F);\n\ttm->tm_min = bcd2bin(buf[ISL12022_REG_MN] & 0x7F);\n\ttm->tm_hour = bcd2bin(buf[ISL12022_REG_HR] & 0x3F);\n\ttm->tm_mday = bcd2bin(buf[ISL12022_REG_DT] & 0x3F);\n\ttm->tm_wday = buf[ISL12022_REG_DW] & 0x07;\n\ttm->tm_mon = bcd2bin(buf[ISL12022_REG_MO] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(buf[ISL12022_REG_YR]) + 100;\n\n\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic int isl12022_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tint ret;\n\tuint8_t buf[ISL12022_REG_DW + 1];\n\n\tdev_dbg(dev, \"%s: %ptR\\n\", __func__, tm);\n\n\t \n\tret = regmap_update_bits(regmap, ISL12022_REG_INT,\n\t\t\t\t ISL12022_INT_WRTC, ISL12022_INT_WRTC);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuf[ISL12022_REG_SC] = bin2bcd(tm->tm_sec);\n\tbuf[ISL12022_REG_MN] = bin2bcd(tm->tm_min);\n\tbuf[ISL12022_REG_HR] = bin2bcd(tm->tm_hour) | ISL12022_HR_MIL;\n\n\tbuf[ISL12022_REG_DT] = bin2bcd(tm->tm_mday);\n\n\t \n\tbuf[ISL12022_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[ISL12022_REG_YR] = bin2bcd(tm->tm_year % 100);\n\n\tbuf[ISL12022_REG_DW] = tm->tm_wday & 0x07;\n\n\treturn regmap_bulk_write(regmap, ISL12022_REG_SC, buf, sizeof(buf));\n}\n\nstatic int isl12022_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tu32 user, val;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(regmap, ISL12022_REG_SR, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tuser = 0;\n\t\tif (val & ISL12022_SR_LBAT85)\n\t\t\tuser |= RTC_VL_BACKUP_LOW;\n\n\t\tif (val & ISL12022_SR_LBAT75)\n\t\t\tuser |= RTC_VL_BACKUP_EMPTY;\n\n\t\treturn put_user(user, (u32 __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct rtc_class_ops isl12022_rtc_ops = {\n\t.ioctl\t\t= isl12022_rtc_ioctl,\n\t.read_time\t= isl12022_rtc_read_time,\n\t.set_time\t= isl12022_rtc_set_time,\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.use_single_write = true,\n};\n\nstatic int isl12022_register_clock(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tstruct clk_hw *hw;\n\tint ret;\n\n\tif (!device_property_present(dev, \"#clock-cells\")) {\n\t\t \n\t\tregmap_update_bits(regmap, ISL12022_REG_INT, ISL12022_INT_FO_MASK,\n\t\t\t\t   ISL12022_INT_FO_OFF);\n\n\t\treturn 0;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_COMMON_CLK))\n\t\treturn 0;\n\n\t \n\tret = regmap_update_bits(regmap, ISL12022_REG_INT,\n\t\t\t\t ISL12022_INT_FO_MASK, ISL12022_INT_FO_32K);\n\tif (ret)\n\t\treturn ret;\n\n\thw = devm_clk_hw_register_fixed_rate(dev, \"isl12022\", NULL, 0, 32768);\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, hw);\n}\n\nstatic const u32 trip_levels[2][7] = {\n\t{ 2125000, 2295000, 2550000, 2805000, 3060000, 4250000, 4675000 },\n\t{ 1875000, 2025000, 2250000, 2475000, 2700000, 3750000, 4125000 },\n};\n\nstatic void isl12022_set_trip_levels(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_drvdata(dev);\n\tu32 levels[2] = {0, 0};\n\tint ret, i, j, x[2];\n\tu8 val, mask;\n\n\tdevice_property_read_u32_array(dev, \"isil,battery-trip-levels-microvolt\",\n\t\t\t\t       levels, 2);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(trip_levels[i]) - 1; j++) {\n\t\t\tif (levels[i] <= trip_levels[i][j])\n\t\t\t\tbreak;\n\t\t}\n\t\tx[i] = j;\n\t}\n\n\tval = FIELD_PREP(ISL12022_REG_VB85_MASK, x[0]) |\n\t\tFIELD_PREP(ISL12022_REG_VB75_MASK, x[1]);\n\tmask = ISL12022_REG_VB85_MASK | ISL12022_REG_VB75_MASK;\n\n\tret = regmap_update_bits(regmap, ISL12022_REG_PWR_VBAT, mask, val);\n\tif (ret)\n\t\tdev_warn(dev, \"unable to set battery alarm levels: %d\\n\", ret);\n\n\t \n\tregmap_write_bits(regmap, ISL12022_REG_BETA,\n\t\t\t  ISL12022_BETA_TSE, ISL12022_BETA_TSE);\n}\n\nstatic int isl12022_probe(struct i2c_client *client)\n{\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tdev_set_drvdata(&client->dev, regmap);\n\n\tret = isl12022_register_clock(&client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tisl12022_set_trip_levels(&client->dev);\n\tisl12022_hwmon_register(&client->dev);\n\n\trtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\trtc->ops = &isl12022_rtc_ops;\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic const struct of_device_id isl12022_dt_match[] = {\n\t{ .compatible = \"isl,isl12022\" },  \n\t{ .compatible = \"isil,isl12022\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, isl12022_dt_match);\n\nstatic const struct i2c_device_id isl12022_id[] = {\n\t{ \"isl12022\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, isl12022_id);\n\nstatic struct i2c_driver isl12022_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-isl12022\",\n\t\t.of_match_table = isl12022_dt_match,\n\t},\n\t.probe\t\t= isl12022_probe,\n\t.id_table\t= isl12022_id,\n};\n\nmodule_i2c_driver(isl12022_driver);\n\nMODULE_AUTHOR(\"roman.fietze@telemotive.de\");\nMODULE_DESCRIPTION(\"ISL 12022 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}