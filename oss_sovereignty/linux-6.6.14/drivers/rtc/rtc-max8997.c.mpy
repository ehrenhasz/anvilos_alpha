{
  "module_name": "rtc-max8997.c",
  "hash_id": "2c6471648be96473d2a20dd04c17f1e52db15a7f425c3d32965b13d17725e4b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-max8997.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/max8997-private.h>\n#include <linux/irqdomain.h>\n\n \nstatic int wtsr_en = 1;\nmodule_param(wtsr_en, int, 0444);\nMODULE_PARM_DESC(wtsr_en, \"Watchdog Timeout & Software Reset (default=on)\");\n \nstatic int smpl_en = 1;\nmodule_param(smpl_en, int, 0444);\nMODULE_PARM_DESC(smpl_en, \"Sudden Momentary Power Loss (default=on)\");\n\n \n#define BCD_EN_SHIFT\t\t\t0\n#define BCD_EN_MASK\t\t\t(1 << BCD_EN_SHIFT)\n#define MODEL24_SHIFT\t\t\t1\n#define MODEL24_MASK\t\t\t(1 << MODEL24_SHIFT)\n \n#define RTC_UDR_SHIFT\t\t\t0\n#define RTC_UDR_MASK\t\t\t(1 << RTC_UDR_SHIFT)\n \n#define WTSRT_SHIFT\t\t\t0\n#define SMPLT_SHIFT\t\t\t2\n#define WTSR_EN_SHIFT\t\t\t6\n#define SMPL_EN_SHIFT\t\t\t7\n#define WTSRT_MASK\t\t\t(3 << WTSRT_SHIFT)\n#define SMPLT_MASK\t\t\t(3 << SMPLT_SHIFT)\n#define WTSR_EN_MASK\t\t\t(1 << WTSR_EN_SHIFT)\n#define SMPL_EN_MASK\t\t\t(1 << SMPL_EN_SHIFT)\n \n#define HOUR_PM_SHIFT\t\t\t6\n#define HOUR_PM_MASK\t\t\t(1 << HOUR_PM_SHIFT)\n \n#define ALARM_ENABLE_SHIFT\t\t7\n#define ALARM_ENABLE_MASK\t\t(1 << ALARM_ENABLE_SHIFT)\n\nenum {\n\tRTC_SEC = 0,\n\tRTC_MIN,\n\tRTC_HOUR,\n\tRTC_WEEKDAY,\n\tRTC_MONTH,\n\tRTC_YEAR,\n\tRTC_DATE,\n\tRTC_NR_TIME\n};\n\nstruct max8997_rtc_info {\n\tstruct device\t\t*dev;\n\tstruct max8997_dev\t*max8997;\n\tstruct i2c_client\t*rtc;\n\tstruct rtc_device\t*rtc_dev;\n\tstruct mutex\t\tlock;\n\tint virq;\n\tint rtc_24hr_mode;\n};\n\nstatic void max8997_rtc_data_to_tm(u8 *data, struct rtc_time *tm,\n\t\t\t\t   int rtc_24hr_mode)\n{\n\ttm->tm_sec = data[RTC_SEC] & 0x7f;\n\ttm->tm_min = data[RTC_MIN] & 0x7f;\n\tif (rtc_24hr_mode)\n\t\ttm->tm_hour = data[RTC_HOUR] & 0x1f;\n\telse {\n\t\ttm->tm_hour = data[RTC_HOUR] & 0x0f;\n\t\tif (data[RTC_HOUR] & HOUR_PM_MASK)\n\t\t\ttm->tm_hour += 12;\n\t}\n\n\ttm->tm_wday = fls(data[RTC_WEEKDAY] & 0x7f) - 1;\n\ttm->tm_mday = data[RTC_DATE] & 0x1f;\n\ttm->tm_mon = (data[RTC_MONTH] & 0x0f) - 1;\n\ttm->tm_year = (data[RTC_YEAR] & 0x7f) + 100;\n\ttm->tm_yday = 0;\n\ttm->tm_isdst = 0;\n}\n\nstatic int max8997_rtc_tm_to_data(struct rtc_time *tm, u8 *data)\n{\n\tdata[RTC_SEC] = tm->tm_sec;\n\tdata[RTC_MIN] = tm->tm_min;\n\tdata[RTC_HOUR] = tm->tm_hour;\n\tdata[RTC_WEEKDAY] = 1 << tm->tm_wday;\n\tdata[RTC_DATE] = tm->tm_mday;\n\tdata[RTC_MONTH] = tm->tm_mon + 1;\n\tdata[RTC_YEAR] = tm->tm_year > 100 ? (tm->tm_year - 100) : 0;\n\n\tif (tm->tm_year < 100) {\n\t\tpr_warn(\"RTC cannot handle the year %d.  Assume it's 2000.\\n\",\n\t\t\t1900 + tm->tm_year);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic inline int max8997_rtc_set_update_reg(struct max8997_rtc_info *info)\n{\n\tint ret;\n\n\tret = max8997_write_reg(info->rtc, MAX8997_RTC_UPDATE1,\n\t\t\t\t\t\tRTC_UDR_MASK);\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"%s: fail to write update reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\telse {\n\t\t \n\t\tmsleep(20);\n\t}\n\n\treturn ret;\n}\n\nstatic int max8997_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8997_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = max8997_bulk_read(info->rtc, MAX8997_RTC_SEC, RTC_NR_TIME, data);\n\tmutex_unlock(&info->lock);\n\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to read time reg(%d)\\n\", __func__,\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmax8997_rtc_data_to_tm(data, tm, info->rtc_24hr_mode);\n\n\treturn 0;\n}\n\nstatic int max8997_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct max8997_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tint ret;\n\n\tret = max8997_rtc_tm_to_data(tm, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&info->lock);\n\n\tret = max8997_bulk_write(info->rtc, MAX8997_RTC_SEC, RTC_NR_TIME, data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write time reg(%d)\\n\", __func__,\n\t\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = max8997_rtc_set_update_reg(info);\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int max8997_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8997_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tu8 val;\n\tint i, ret;\n\n\tmutex_lock(&info->lock);\n\n\tret = max8997_bulk_read(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\tdata);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s:%d fail to read alarm reg(%d)\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\tgoto out;\n\t}\n\n\tmax8997_rtc_data_to_tm(data, &alrm->time, info->rtc_24hr_mode);\n\n\talrm->enabled = 0;\n\tfor (i = 0; i < RTC_NR_TIME; i++) {\n\t\tif (data[i] & ALARM_ENABLE_MASK) {\n\t\t\talrm->enabled = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\talrm->pending = 0;\n\tret = max8997_read_reg(info->max8997->i2c, MAX8997_REG_STATUS1, &val);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s:%d fail to read status1 reg(%d)\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\tgoto out;\n\t}\n\n\tif (val & (1 << 4))  \n\t\talrm->pending = 1;\n\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int max8997_rtc_stop_alarm(struct max8997_rtc_info *info)\n{\n\tu8 data[RTC_NR_TIME];\n\tint ret, i;\n\n\tif (!mutex_is_locked(&info->lock))\n\t\tdev_warn(info->dev, \"%s: should have mutex locked\\n\", __func__);\n\n\tret = max8997_bulk_read(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\t\tdata);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to read alarm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < RTC_NR_TIME; i++)\n\t\tdata[i] &= ~ALARM_ENABLE_MASK;\n\n\tret = max8997_bulk_write(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\t\t data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write alarm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tret = max8997_rtc_set_update_reg(info);\nout:\n\treturn ret;\n}\n\nstatic int max8997_rtc_start_alarm(struct max8997_rtc_info *info)\n{\n\tu8 data[RTC_NR_TIME];\n\tint ret;\n\n\tif (!mutex_is_locked(&info->lock))\n\t\tdev_warn(info->dev, \"%s: should have mutex locked\\n\", __func__);\n\n\tret = max8997_bulk_read(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\t\tdata);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to read alarm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tdata[RTC_SEC] |= (1 << ALARM_ENABLE_SHIFT);\n\tdata[RTC_MIN] |= (1 << ALARM_ENABLE_SHIFT);\n\tdata[RTC_HOUR] |= (1 << ALARM_ENABLE_SHIFT);\n\tdata[RTC_WEEKDAY] &= ~ALARM_ENABLE_MASK;\n\tif (data[RTC_MONTH] & 0xf)\n\t\tdata[RTC_MONTH] |= (1 << ALARM_ENABLE_SHIFT);\n\tif (data[RTC_YEAR] & 0x7f)\n\t\tdata[RTC_YEAR] |= (1 << ALARM_ENABLE_SHIFT);\n\tif (data[RTC_DATE] & 0x1f)\n\t\tdata[RTC_DATE] |= (1 << ALARM_ENABLE_SHIFT);\n\n\tret = max8997_bulk_write(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\t\t data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write alarm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tret = max8997_rtc_set_update_reg(info);\nout:\n\treturn ret;\n}\nstatic int max8997_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct max8997_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_NR_TIME];\n\tint ret;\n\n\tret = max8997_rtc_tm_to_data(&alrm->time, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(info->dev, \"%s: %d-%02d-%02d %02d:%02d:%02d\\n\", __func__,\n\t\t\tdata[RTC_YEAR] + 2000, data[RTC_MONTH], data[RTC_DATE],\n\t\t\tdata[RTC_HOUR], data[RTC_MIN], data[RTC_SEC]);\n\n\tmutex_lock(&info->lock);\n\n\tret = max8997_rtc_stop_alarm(info);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = max8997_bulk_write(info->rtc, MAX8997_RTC_ALARM1_SEC, RTC_NR_TIME,\n\t\t\t\tdata);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write alarm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tret = max8997_rtc_set_update_reg(info);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (alrm->enabled)\n\t\tret = max8997_rtc_start_alarm(info);\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int max8997_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct max8997_rtc_info *info = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tif (enabled)\n\t\tret = max8997_rtc_start_alarm(info);\n\telse\n\t\tret = max8997_rtc_stop_alarm(info);\n\tmutex_unlock(&info->lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t max8997_rtc_alarm_irq(int irq, void *data)\n{\n\tstruct max8997_rtc_info *info = data;\n\n\tdev_info(info->dev, \"%s:irq(%d)\\n\", __func__, irq);\n\n\trtc_update_irq(info->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops max8997_rtc_ops = {\n\t.read_time = max8997_rtc_read_time,\n\t.set_time = max8997_rtc_set_time,\n\t.read_alarm = max8997_rtc_read_alarm,\n\t.set_alarm = max8997_rtc_set_alarm,\n\t.alarm_irq_enable = max8997_rtc_alarm_irq_enable,\n};\n\nstatic void max8997_rtc_enable_wtsr(struct max8997_rtc_info *info, bool enable)\n{\n\tint ret;\n\tu8 val, mask;\n\n\tif (!wtsr_en)\n\t\treturn;\n\n\tif (enable)\n\t\tval = (1 << WTSR_EN_SHIFT) | (3 << WTSRT_SHIFT);\n\telse\n\t\tval = 0;\n\n\tmask = WTSR_EN_MASK | WTSRT_MASK;\n\n\tdev_info(info->dev, \"%s: %s WTSR\\n\", __func__,\n\t\t\tenable ? \"enable\" : \"disable\");\n\n\tret = max8997_update_reg(info->rtc, MAX8997_RTC_WTSR_SMPL, val, mask);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to update WTSR reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn;\n\t}\n\n\tmax8997_rtc_set_update_reg(info);\n}\n\nstatic void max8997_rtc_enable_smpl(struct max8997_rtc_info *info, bool enable)\n{\n\tint ret;\n\tu8 val, mask;\n\n\tif (!smpl_en)\n\t\treturn;\n\n\tif (enable)\n\t\tval = (1 << SMPL_EN_SHIFT) | (0 << SMPLT_SHIFT);\n\telse\n\t\tval = 0;\n\n\tmask = SMPL_EN_MASK | SMPLT_MASK;\n\n\tdev_info(info->dev, \"%s: %s SMPL\\n\", __func__,\n\t\t\tenable ? \"enable\" : \"disable\");\n\n\tret = max8997_update_reg(info->rtc, MAX8997_RTC_WTSR_SMPL, val, mask);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to update SMPL reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn;\n\t}\n\n\tmax8997_rtc_set_update_reg(info);\n\n\tval = 0;\n\tmax8997_read_reg(info->rtc, MAX8997_RTC_WTSR_SMPL, &val);\n\tpr_info(\"WTSR_SMPL(0x%02x)\\n\", val);\n}\n\nstatic int max8997_rtc_init_reg(struct max8997_rtc_info *info)\n{\n\tu8 data[2];\n\tint ret;\n\n\t \n\tdata[0] = (1 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\n\tdata[1] = (0 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\n\n\tinfo->rtc_24hr_mode = 1;\n\n\tret = max8997_bulk_write(info->rtc, MAX8997_RTC_CTRLMASK, 2, data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write controlm reg(%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = max8997_rtc_set_update_reg(info);\n\treturn ret;\n}\n\nstatic int max8997_rtc_probe(struct platform_device *pdev)\n{\n\tstruct max8997_dev *max8997 = dev_get_drvdata(pdev->dev.parent);\n\tstruct max8997_rtc_info *info;\n\tint ret, virq;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct max8997_rtc_info),\n\t\t\tGFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&info->lock);\n\tinfo->dev = &pdev->dev;\n\tinfo->max8997 = max8997;\n\tinfo->rtc = max8997->rtc;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = max8997_rtc_init_reg(info);\n\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize RTC reg:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax8997_rtc_enable_wtsr(info, true);\n\tmax8997_rtc_enable_smpl(info, true);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tinfo->rtc_dev = devm_rtc_device_register(&pdev->dev, \"max8997-rtc\",\n\t\t\t\t\t&max8997_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(info->rtc_dev)) {\n\t\tret = PTR_ERR(info->rtc_dev);\n\t\tdev_err(&pdev->dev, \"Failed to register RTC device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvirq = irq_create_mapping(max8997->irq_domain, MAX8997_PMICIRQ_RTCA1);\n\tif (!virq) {\n\t\tdev_err(&pdev->dev, \"Failed to create mapping alarm IRQ\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_out;\n\t}\n\tinfo->virq = virq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, virq, NULL,\n\t\t\t\tmax8997_rtc_alarm_irq, 0,\n\t\t\t\t\"rtc-alarm0\", info);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ: %d: %d\\n\",\n\t\t\tinfo->virq, ret);\n\nerr_out:\n\treturn ret;\n}\n\nstatic void max8997_rtc_shutdown(struct platform_device *pdev)\n{\n\tstruct max8997_rtc_info *info = platform_get_drvdata(pdev);\n\n\tmax8997_rtc_enable_wtsr(info, false);\n\tmax8997_rtc_enable_smpl(info, false);\n}\n\nstatic const struct platform_device_id rtc_id[] = {\n\t{ \"max8997-rtc\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, rtc_id);\n\nstatic struct platform_driver max8997_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8997-rtc\",\n\t},\n\t.probe\t\t= max8997_rtc_probe,\n\t.shutdown\t= max8997_rtc_shutdown,\n\t.id_table\t= rtc_id,\n};\n\nmodule_platform_driver(max8997_rtc_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX8997 RTC driver\");\nMODULE_AUTHOR(\"<ms925.kim@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}