{
  "module_name": "rtc-hid-sensor-time.c",
  "hash_id": "becf38904828ea49f96a136f39601f14506c391fdaaad5eb2909ddb12d675549",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-hid-sensor-time.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/hid-sensor-hub.h>\n#include <linux/iio/iio.h>\n#include <linux/rtc.h>\n\nenum hid_time_channel {\n\tCHANNEL_SCAN_INDEX_YEAR,\n\tCHANNEL_SCAN_INDEX_MONTH,\n\tCHANNEL_SCAN_INDEX_DAY,\n\tCHANNEL_SCAN_INDEX_HOUR,\n\tCHANNEL_SCAN_INDEX_MINUTE,\n\tCHANNEL_SCAN_INDEX_SECOND,\n\tTIME_RTC_CHANNEL_MAX,\n};\n\nstruct hid_time_state {\n\tstruct hid_sensor_hub_callbacks callbacks;\n\tstruct hid_sensor_common common_attributes;\n\tstruct hid_sensor_hub_attribute_info info[TIME_RTC_CHANNEL_MAX];\n\tstruct rtc_time last_time;\n\tspinlock_t lock_last_time;\n\tstruct completion comp_last_time;\n\tstruct rtc_time time_buf;\n\tstruct rtc_device *rtc;\n};\n\nstatic const u32 hid_time_addresses[TIME_RTC_CHANNEL_MAX] = {\n\tHID_USAGE_SENSOR_TIME_YEAR,\n\tHID_USAGE_SENSOR_TIME_MONTH,\n\tHID_USAGE_SENSOR_TIME_DAY,\n\tHID_USAGE_SENSOR_TIME_HOUR,\n\tHID_USAGE_SENSOR_TIME_MINUTE,\n\tHID_USAGE_SENSOR_TIME_SECOND,\n};\n\n \nstatic const char * const hid_time_channel_names[TIME_RTC_CHANNEL_MAX] = {\n\t\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\",\n};\n\n \nstatic int hid_time_proc_event(struct hid_sensor_hub_device *hsdev,\n\t\t\t\tunsigned usage_id, void *priv)\n{\n\tunsigned long flags;\n\tstruct hid_time_state *time_state = platform_get_drvdata(priv);\n\n\tspin_lock_irqsave(&time_state->lock_last_time, flags);\n\ttime_state->last_time = time_state->time_buf;\n\tspin_unlock_irqrestore(&time_state->lock_last_time, flags);\n\tcomplete(&time_state->comp_last_time);\n\treturn 0;\n}\n\nstatic u32 hid_time_value(size_t raw_len, char *raw_data)\n{\n\tswitch (raw_len) {\n\tcase 1:\n\t\treturn *(u8 *)raw_data;\n\tcase 2:\n\t\treturn *(u16 *)raw_data;\n\tcase 4:\n\t\treturn *(u32 *)raw_data;\n\tdefault:\n\t\treturn (u32)(~0U);  \n\t}\n}\n\nstatic int hid_time_capture_sample(struct hid_sensor_hub_device *hsdev,\n\t\t\t\tunsigned usage_id, size_t raw_len,\n\t\t\t\tchar *raw_data, void *priv)\n{\n\tstruct hid_time_state *time_state = platform_get_drvdata(priv);\n\tstruct rtc_time *time_buf = &time_state->time_buf;\n\n\tswitch (usage_id) {\n\tcase HID_USAGE_SENSOR_TIME_YEAR:\n\t\t \n\t\tif (raw_len == 1) {\n\t\t\ttime_buf->tm_year = *(u8 *)raw_data;\n\t\t\tif (time_buf->tm_year < 70)\n\t\t\t\t \n\t\t\t\ttime_buf->tm_year += 100;\n\t\t} else\n\t\t\ttime_buf->tm_year =\n\t\t\t\t(int)hid_time_value(raw_len, raw_data)-1900;\n\t\tbreak;\n\tcase HID_USAGE_SENSOR_TIME_MONTH:\n\t\t \n\t\ttime_buf->tm_mon = (int)hid_time_value(raw_len, raw_data)-1;\n\t\tbreak;\n\tcase HID_USAGE_SENSOR_TIME_DAY:\n\t\ttime_buf->tm_mday = (int)hid_time_value(raw_len, raw_data);\n\t\tbreak;\n\tcase HID_USAGE_SENSOR_TIME_HOUR:\n\t\ttime_buf->tm_hour = (int)hid_time_value(raw_len, raw_data);\n\t\tbreak;\n\tcase HID_USAGE_SENSOR_TIME_MINUTE:\n\t\ttime_buf->tm_min = (int)hid_time_value(raw_len, raw_data);\n\t\tbreak;\n\tcase HID_USAGE_SENSOR_TIME_SECOND:\n\t\ttime_buf->tm_sec = (int)hid_time_value(raw_len, raw_data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic const char *hid_time_attrib_name(u32 attrib_id)\n{\n\tstatic const char unknown[] = \"unknown\";\n\tunsigned i;\n\n\tfor (i = 0; i < TIME_RTC_CHANNEL_MAX; ++i) {\n\t\tif (hid_time_addresses[i] == attrib_id)\n\t\t\treturn hid_time_channel_names[i];\n\t}\n\treturn unknown;  \n}\n\nstatic int hid_time_parse_report(struct platform_device *pdev,\n\t\t\t\tstruct hid_sensor_hub_device *hsdev,\n\t\t\t\tunsigned usage_id,\n\t\t\t\tstruct hid_time_state *time_state)\n{\n\tint report_id, i;\n\n\tfor (i = 0; i < TIME_RTC_CHANNEL_MAX; ++i)\n\t\tif (sensor_hub_input_get_attribute_info(hsdev,\n\t\t\t\tHID_INPUT_REPORT, usage_id,\n\t\t\t\thid_time_addresses[i],\n\t\t\t\t&time_state->info[i]) < 0)\n\t\t\treturn -EINVAL;\n\t \n\treport_id = time_state->info[0].report_id;\n\tif (report_id < 0) {\n\t\tdev_err(&pdev->dev, \"bad report ID!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < TIME_RTC_CHANNEL_MAX; ++i) {\n\t\tif (time_state->info[i].report_id != report_id) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"not all needed attributes inside the same report!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (time_state->info[i].size == 3 ||\n\t\t\t\ttime_state->info[i].size > 4) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"attribute '%s' not 8, 16 or 32 bits wide!\\n\",\n\t\t\t\thid_time_attrib_name(\n\t\t\t\t\ttime_state->info[i].attrib_id));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (time_state->info[i].units !=\n\t\t\t\tHID_USAGE_SENSOR_UNITS_NOT_SPECIFIED &&\n\t\t\t\t \n\t\t\t\t!(time_state->info[i].attrib_id ==\n\t\t\t\tHID_USAGE_SENSOR_TIME_SECOND &&\n\t\t\t\ttime_state->info[i].units ==\n\t\t\t\tHID_USAGE_SENSOR_UNITS_SECOND)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"attribute '%s' hasn't a unit of type 'none'!\\n\",\n\t\t\t\thid_time_attrib_name(\n\t\t\t\t\ttime_state->info[i].attrib_id));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (time_state->info[i].unit_expo) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"attribute '%s' hasn't a unit exponent of 1!\\n\",\n\t\t\t\thid_time_attrib_name(\n\t\t\t\t\ttime_state->info[i].attrib_id));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hid_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tunsigned long flags;\n\tstruct hid_time_state *time_state = dev_get_drvdata(dev);\n\tint ret;\n\n\treinit_completion(&time_state->comp_last_time);\n\t \n\tsensor_hub_input_attr_get_raw_value(time_state->common_attributes.hsdev,\n\t\t\tHID_USAGE_SENSOR_TIME, hid_time_addresses[0],\n\t\t\ttime_state->info[0].report_id, SENSOR_HUB_SYNC, false);\n\t \n\tret = wait_for_completion_killable_timeout(\n\t\t\t&time_state->comp_last_time, HZ*6);\n\tif (ret > 0) {\n\t\t \n\t\tspin_lock_irqsave(&time_state->lock_last_time, flags);\n\t\t*tm = time_state->last_time;\n\t\tspin_unlock_irqrestore(&time_state->lock_last_time, flags);\n\t\treturn 0;\n\t}\n\tif (!ret)\n\t\treturn -EIO;  \n\treturn ret;  \n}\n\nstatic const struct rtc_class_ops hid_time_rtc_ops = {\n\t.read_time = hid_rtc_read_time,\n};\n\nstatic int hid_time_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct hid_sensor_hub_device *hsdev = dev_get_platdata(&pdev->dev);\n\tstruct hid_time_state *time_state = devm_kzalloc(&pdev->dev,\n\t\tsizeof(struct hid_time_state), GFP_KERNEL);\n\n\tif (time_state == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, time_state);\n\n\tspin_lock_init(&time_state->lock_last_time);\n\tinit_completion(&time_state->comp_last_time);\n\ttime_state->common_attributes.hsdev = hsdev;\n\ttime_state->common_attributes.pdev = pdev;\n\n\tret = hid_sensor_parse_common_attributes(hsdev,\n\t\t\t\tHID_USAGE_SENSOR_TIME,\n\t\t\t\t&time_state->common_attributes,\n\t\t\t\tNULL,\n\t\t\t\t0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to setup common attributes!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_time_parse_report(pdev, hsdev, HID_USAGE_SENSOR_TIME,\n\t\t\t\t\ttime_state);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to setup attributes!\\n\");\n\t\treturn ret;\n\t}\n\n\ttime_state->callbacks.send_event = hid_time_proc_event;\n\ttime_state->callbacks.capture_sample = hid_time_capture_sample;\n\ttime_state->callbacks.pdev = pdev;\n\tret = sensor_hub_register_callback(hsdev, HID_USAGE_SENSOR_TIME,\n\t\t\t\t\t&time_state->callbacks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"register callback failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sensor_hub_device_open(hsdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to open sensor hub device!\\n\");\n\t\tgoto err_open;\n\t}\n\n\t \n\thid_device_io_start(hsdev->hdev);\n\n\ttime_state->rtc = devm_rtc_device_register(&pdev->dev,\n\t\t\t\t\t\"hid-sensor-time\", &hid_time_rtc_ops,\n\t\t\t\t\tTHIS_MODULE);\n\n\tif (IS_ERR(time_state->rtc)) {\n\t\thid_device_io_stop(hsdev->hdev);\n\t\tret = PTR_ERR(time_state->rtc);\n\t\ttime_state->rtc = NULL;\n\t\tdev_err(&pdev->dev, \"rtc device register failed!\\n\");\n\t\tgoto err_rtc;\n\t}\n\n\treturn ret;\n\nerr_rtc:\n\tsensor_hub_device_close(hsdev);\nerr_open:\n\tsensor_hub_remove_callback(hsdev, HID_USAGE_SENSOR_TIME);\n\treturn ret;\n}\n\nstatic void hid_time_remove(struct platform_device *pdev)\n{\n\tstruct hid_sensor_hub_device *hsdev = dev_get_platdata(&pdev->dev);\n\n\tsensor_hub_device_close(hsdev);\n\tsensor_hub_remove_callback(hsdev, HID_USAGE_SENSOR_TIME);\n}\n\nstatic const struct platform_device_id hid_time_ids[] = {\n\t{\n\t\t \n\t\t.name = \"HID-SENSOR-2000a0\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, hid_time_ids);\n\nstatic struct platform_driver hid_time_platform_driver = {\n\t.id_table = hid_time_ids,\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t},\n\t.probe\t\t= hid_time_probe,\n\t.remove_new\t= hid_time_remove,\n};\nmodule_platform_driver(hid_time_platform_driver);\n\nMODULE_DESCRIPTION(\"HID Sensor Time\");\nMODULE_AUTHOR(\"Alexander Holler <holler@ahsoftware.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IIO_HID);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}