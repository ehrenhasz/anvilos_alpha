{
  "module_name": "rtc-wm8350.c",
  "hash_id": "034549757ebdcd00b6a138d6643e2b1ab2f8e4e5a8419b1ac39a95bbcb8e959c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-wm8350.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/completion.h>\n#include <linux/mfd/wm8350/rtc.h>\n#include <linux/mfd/wm8350/core.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n\n#define WM8350_SET_ALM_RETRIES\t5\n#define WM8350_SET_TIME_RETRIES\t5\n#define WM8350_GET_TIME_RETRIES\t5\n\n \nstatic int wm8350_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tu16 time1[4], time2[4];\n\tint retries = WM8350_GET_TIME_RETRIES, ret;\n\n\t \n\tdo {\n\t\tret = wm8350_block_read(wm8350, WM8350_RTC_SECONDS_MINUTES,\n\t\t\t\t\t4, time1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = wm8350_block_read(wm8350, WM8350_RTC_SECONDS_MINUTES,\n\t\t\t\t\t4, time2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (memcmp(time1, time2, sizeof(time1)) == 0) {\n\t\t\ttm->tm_sec = time1[0] & WM8350_RTC_SECS_MASK;\n\n\t\t\ttm->tm_min = (time1[0] & WM8350_RTC_MINS_MASK)\n\t\t\t    >> WM8350_RTC_MINS_SHIFT;\n\n\t\t\ttm->tm_hour = time1[1] & WM8350_RTC_HRS_MASK;\n\n\t\t\ttm->tm_wday = ((time1[1] >> WM8350_RTC_DAY_SHIFT)\n\t\t\t\t       & 0x7) - 1;\n\n\t\t\ttm->tm_mon = ((time1[2] & WM8350_RTC_MTH_MASK)\n\t\t\t\t      >> WM8350_RTC_MTH_SHIFT) - 1;\n\n\t\t\ttm->tm_mday = (time1[2] & WM8350_RTC_DATE_MASK);\n\n\t\t\ttm->tm_year = ((time1[3] & WM8350_RTC_YHUNDREDS_MASK)\n\t\t\t\t       >> WM8350_RTC_YHUNDREDS_SHIFT) * 100;\n\t\t\ttm->tm_year += time1[3] & WM8350_RTC_YUNITS_MASK;\n\n\t\t\ttm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon,\n\t\t\t\t\t\t    tm->tm_year);\n\t\t\ttm->tm_year -= 1900;\n\n\t\t\tdev_dbg(dev, \"Read (%d left): %04x %04x %04x %04x\\n\",\n\t\t\t\tretries,\n\t\t\t\ttime1[0], time1[1], time1[2], time1[3]);\n\n\t\t\treturn 0;\n\t\t}\n\t} while (retries--);\n\n\tdev_err(dev, \"timed out reading RTC time\\n\");\n\treturn -EIO;\n}\n\n \nstatic int wm8350_rtc_settime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tu16 time[4];\n\tu16 rtc_ctrl;\n\tint ret, retries = WM8350_SET_TIME_RETRIES;\n\n\ttime[0] = tm->tm_sec;\n\ttime[0] |= tm->tm_min << WM8350_RTC_MINS_SHIFT;\n\ttime[1] = tm->tm_hour;\n\ttime[1] |= (tm->tm_wday + 1) << WM8350_RTC_DAY_SHIFT;\n\ttime[2] = tm->tm_mday;\n\ttime[2] |= (tm->tm_mon + 1) << WM8350_RTC_MTH_SHIFT;\n\ttime[3] = ((tm->tm_year + 1900) / 100) << WM8350_RTC_YHUNDREDS_SHIFT;\n\ttime[3] |= (tm->tm_year + 1900) % 100;\n\n\tdev_dbg(dev, \"Setting: %04x %04x %04x %04x\\n\",\n\t\ttime[0], time[1], time[2], time[3]);\n\n\t \n\tret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL, WM8350_RTC_SET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\trtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(1));\n\t} while (--retries && !(rtc_ctrl & WM8350_RTC_STS));\n\n\tif (!retries) {\n\t\tdev_err(dev, \"timed out on set confirmation\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = wm8350_block_write(wm8350, WM8350_RTC_SECONDS_MINUTES, 4, time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\n\t\t\t\tWM8350_RTC_SET);\n\treturn ret;\n}\n\n \nstatic int wm8350_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tu16 time[4];\n\tint ret;\n\n\tret = wm8350_block_read(wm8350, WM8350_ALARM_SECONDS_MINUTES, 4, time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttm->tm_sec = time[0] & WM8350_RTC_ALMSECS_MASK;\n\tif (tm->tm_sec == WM8350_RTC_ALMSECS_MASK)\n\t\ttm->tm_sec = -1;\n\n\ttm->tm_min = time[0] & WM8350_RTC_ALMMINS_MASK;\n\tif (tm->tm_min == WM8350_RTC_ALMMINS_MASK)\n\t\ttm->tm_min = -1;\n\telse\n\t\ttm->tm_min >>= WM8350_RTC_ALMMINS_SHIFT;\n\n\ttm->tm_hour = time[1] & WM8350_RTC_ALMHRS_MASK;\n\tif (tm->tm_hour == WM8350_RTC_ALMHRS_MASK)\n\t\ttm->tm_hour = -1;\n\n\ttm->tm_wday = ((time[1] >> WM8350_RTC_ALMDAY_SHIFT) & 0x7) - 1;\n\tif (tm->tm_wday > 7)\n\t\ttm->tm_wday = -1;\n\n\ttm->tm_mon = time[2] & WM8350_RTC_ALMMTH_MASK;\n\tif (tm->tm_mon == WM8350_RTC_ALMMTH_MASK)\n\t\ttm->tm_mon = -1;\n\telse\n\t\ttm->tm_mon = (tm->tm_mon >> WM8350_RTC_ALMMTH_SHIFT) - 1;\n\n\ttm->tm_mday = (time[2] & WM8350_RTC_ALMDATE_MASK);\n\tif (tm->tm_mday == WM8350_RTC_ALMDATE_MASK)\n\t\ttm->tm_mday = -1;\n\n\ttm->tm_year = -1;\n\n\talrm->enabled = !(time[3] & WM8350_RTC_ALMSTS);\n\n\treturn 0;\n}\n\nstatic int wm8350_rtc_stop_alarm(struct wm8350 *wm8350)\n{\n\tint retries = WM8350_SET_ALM_RETRIES;\n\tu16 rtc_ctrl;\n\tint ret;\n\n\t \n\tret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL,\n\t\t\t      WM8350_RTC_ALMSET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\trtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(1));\n\t} while (retries-- && !(rtc_ctrl & WM8350_RTC_ALMSTS));\n\n\tif (!(rtc_ctrl & WM8350_RTC_ALMSTS))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int wm8350_rtc_start_alarm(struct wm8350 *wm8350)\n{\n\tint ret;\n\tint retries = WM8350_SET_ALM_RETRIES;\n\tu16 rtc_ctrl;\n\n\tret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\n\t\t\t\tWM8350_RTC_ALMSET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\trtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(1));\n\t} while (retries-- && rtc_ctrl & WM8350_RTC_ALMSTS);\n\n\tif (rtc_ctrl & WM8350_RTC_ALMSTS)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int wm8350_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t       unsigned int enabled)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\treturn wm8350_rtc_start_alarm(wm8350);\n\telse\n\t\treturn wm8350_rtc_stop_alarm(wm8350);\n}\n\nstatic int wm8350_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tu16 time[3];\n\tint ret;\n\n\tmemset(time, 0, sizeof(time));\n\n\tif (tm->tm_sec != -1)\n\t\ttime[0] |= tm->tm_sec;\n\telse\n\t\ttime[0] |= WM8350_RTC_ALMSECS_MASK;\n\n\tif (tm->tm_min != -1)\n\t\ttime[0] |= tm->tm_min << WM8350_RTC_ALMMINS_SHIFT;\n\telse\n\t\ttime[0] |= WM8350_RTC_ALMMINS_MASK;\n\n\tif (tm->tm_hour != -1)\n\t\ttime[1] |= tm->tm_hour;\n\telse\n\t\ttime[1] |= WM8350_RTC_ALMHRS_MASK;\n\n\tif (tm->tm_wday != -1)\n\t\ttime[1] |= (tm->tm_wday + 1) << WM8350_RTC_ALMDAY_SHIFT;\n\telse\n\t\ttime[1] |= WM8350_RTC_ALMDAY_MASK;\n\n\tif (tm->tm_mday != -1)\n\t\ttime[2] |= tm->tm_mday;\n\telse\n\t\ttime[2] |= WM8350_RTC_ALMDATE_MASK;\n\n\tif (tm->tm_mon != -1)\n\t\ttime[2] |= (tm->tm_mon + 1) << WM8350_RTC_ALMMTH_SHIFT;\n\telse\n\t\ttime[2] |= WM8350_RTC_ALMMTH_MASK;\n\n\tret = wm8350_rtc_stop_alarm(wm8350);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wm8350_block_write(wm8350, WM8350_ALARM_SECONDS_MINUTES,\n\t\t\t\t 3, time);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (alrm->enabled)\n\t\tret = wm8350_rtc_start_alarm(wm8350);\n\n\treturn ret;\n}\n\nstatic irqreturn_t wm8350_rtc_alarm_handler(int irq, void *data)\n{\n\tstruct wm8350 *wm8350 = data;\n\tstruct rtc_device *rtc = wm8350->rtc.rtc;\n\tint ret;\n\n\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\n\n\t \n\tret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL,\n\t\t\t      WM8350_RTC_ALMSET);\n\tif (ret != 0) {\n\t\tdev_err(&(wm8350->rtc.pdev->dev),\n\t\t\t\"Failed to disable alarm: %d\\n\", ret);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wm8350_rtc_update_handler(int irq, void *data)\n{\n\tstruct wm8350 *wm8350 = data;\n\tstruct rtc_device *rtc = wm8350->rtc.rtc;\n\n\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_UF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops wm8350_rtc_ops = {\n\t.read_time = wm8350_rtc_readtime,\n\t.set_time = wm8350_rtc_settime,\n\t.read_alarm = wm8350_rtc_readalarm,\n\t.set_alarm = wm8350_rtc_setalarm,\n\t.alarm_irq_enable = wm8350_rtc_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int wm8350_rtc_suspend(struct device *dev)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tint ret = 0;\n\tu16 reg;\n\n\treg = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\n\tif (device_may_wakeup(&wm8350->rtc.pdev->dev) &&\n\t    reg & WM8350_RTC_ALMSTS) {\n\t\tret = wm8350_rtc_stop_alarm(wm8350);\n\t\tif (ret != 0)\n\t\t\tdev_err(dev, \"Failed to stop RTC alarm: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int wm8350_rtc_resume(struct device *dev)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (wm8350->rtc.alarm_enabled) {\n\t\tret = wm8350_rtc_start_alarm(wm8350);\n\t\tif (ret != 0)\n\t\t\tdev_err(dev, \"Failed to restart RTC alarm: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int wm8350_rtc_probe(struct platform_device *pdev)\n{\n\tstruct wm8350 *wm8350 = platform_get_drvdata(pdev);\n\tstruct wm8350_rtc *wm_rtc = &wm8350->rtc;\n\tint ret = 0;\n\tu16 timectl, power5;\n\n\ttimectl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\n\tif (timectl & WM8350_RTC_BCD) {\n\t\tdev_err(&pdev->dev, \"RTC BCD mode not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (timectl & WM8350_RTC_12HR) {\n\t\tdev_err(&pdev->dev, \"RTC 12 hour mode not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpower5 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\n\tif (!(power5 &  WM8350_RTC_TICK_ENA)) {\n\t\twm8350_reg_unlock(wm8350);\n\n\t\tret = wm8350_set_bits(wm8350, WM8350_POWER_MGMT_5,\n\t\t\t\t      WM8350_RTC_TICK_ENA);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to enable RTC: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twm8350_reg_lock(wm8350);\n\t}\n\n\tif (timectl & WM8350_RTC_STS) {\n\t\tint retries;\n\n\t\tret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\n\t\t\t\t\tWM8350_RTC_SET);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to start: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tretries = WM8350_SET_TIME_RETRIES;\n\t\tdo {\n\t\t\ttimectl = wm8350_reg_read(wm8350,\n\t\t\t\t\t\t  WM8350_RTC_TIME_CONTROL);\n\t\t} while (timectl & WM8350_RTC_STS && --retries);\n\n\t\tif (retries == 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to start: timeout\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\twm_rtc->rtc = devm_rtc_device_register(&pdev->dev, \"wm8350\",\n\t\t\t\t\t&wm8350_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(wm_rtc->rtc))\n\t\treturn PTR_ERR(wm_rtc->rtc);\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_RTC_SEC,\n\t\t\t    wm8350_rtc_update_handler, 0,\n\t\t\t    \"RTC Seconds\", wm8350);\n\tif (ret)\n\t\treturn ret;\n\n\twm8350_mask_irq(wm8350, WM8350_IRQ_RTC_SEC);\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_RTC_ALM,\n\t\t\t    wm8350_rtc_alarm_handler, 0,\n\t\t\t    \"RTC Alarm\", wm8350);\n\tif (ret) {\n\t\twm8350_free_irq(wm8350, WM8350_IRQ_RTC_SEC, wm8350);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void wm8350_rtc_remove(struct platform_device *pdev)\n{\n\tstruct wm8350 *wm8350 = platform_get_drvdata(pdev);\n\n\twm8350_free_irq(wm8350, WM8350_IRQ_RTC_SEC, wm8350);\n\twm8350_free_irq(wm8350, WM8350_IRQ_RTC_ALM, wm8350);\n}\n\nstatic SIMPLE_DEV_PM_OPS(wm8350_rtc_pm_ops, wm8350_rtc_suspend,\n\t\t\twm8350_rtc_resume);\n\nstatic struct platform_driver wm8350_rtc_driver = {\n\t.probe = wm8350_rtc_probe,\n\t.remove_new = wm8350_rtc_remove,\n\t.driver = {\n\t\t.name = \"wm8350-rtc\",\n\t\t.pm = &wm8350_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(wm8350_rtc_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"RTC driver for the WM8350\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8350-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}