{
  "module_name": "lib.c",
  "hash_id": "f530e308f13a06b342f9a148d194070b6a0a3b4633d7fca1fad4bbabb1f4d7d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/lib.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/rtc.h>\n\nstatic const unsigned char rtc_days_in_month[] = {\n\t31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n};\n\nstatic const unsigned short rtc_ydays[2][13] = {\n\t \n\t{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },\n\t \n\t{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }\n};\n\n \nint rtc_month_days(unsigned int month, unsigned int year)\n{\n\treturn rtc_days_in_month[month] + (is_leap_year(year) && month == 1);\n}\nEXPORT_SYMBOL(rtc_month_days);\n\n \nint rtc_year_days(unsigned int day, unsigned int month, unsigned int year)\n{\n\treturn rtc_ydays[is_leap_year(year)][month] + day - 1;\n}\nEXPORT_SYMBOL(rtc_year_days);\n\n \nvoid rtc_time64_to_tm(time64_t time, struct rtc_time *tm)\n{\n\tunsigned int secs;\n\tint days;\n\n\tu64 u64tmp;\n\tu32 u32tmp, udays, century, day_of_century, year_of_century, year,\n\t\tday_of_year, month, day;\n\tbool is_Jan_or_Feb, is_leap_year;\n\n\t \n\tdays = div_s64_rem(time, 86400, &secs);\n\n\t \n\ttm->tm_wday = (days + 4) % 7;\n\n\t \n\n\tudays\t\t= ((u32) days) + 719468;\n\n\tu32tmp\t\t= 4 * udays + 3;\n\tcentury\t\t= u32tmp / 146097;\n\tday_of_century\t= u32tmp % 146097 / 4;\n\n\tu32tmp\t\t= 4 * day_of_century + 3;\n\tu64tmp\t\t= 2939745ULL * u32tmp;\n\tyear_of_century\t= upper_32_bits(u64tmp);\n\tday_of_year\t= lower_32_bits(u64tmp) / 2939745 / 4;\n\n\tyear\t\t= 100 * century + year_of_century;\n\tis_leap_year\t= year_of_century != 0 ?\n\t\tyear_of_century % 4 == 0 : century % 4 == 0;\n\n\tu32tmp\t\t= 2141 * day_of_year + 132377;\n\tmonth\t\t= u32tmp >> 16;\n\tday\t\t= ((u16) u32tmp) / 2141;\n\n\t \n\tis_Jan_or_Feb\t= day_of_year >= 306;\n\n\t \n\tyear\t\t= year + is_Jan_or_Feb;\n\tmonth\t\t= is_Jan_or_Feb ? month - 12 : month;\n\tday\t\t= day + 1;\n\n\tday_of_year\t= is_Jan_or_Feb ?\n\t\tday_of_year - 306 : day_of_year + 31 + 28 + is_leap_year;\n\n\t \n\ttm->tm_year\t= (int) (year - 1900);\n\ttm->tm_mon\t= (int) month;\n\ttm->tm_mday\t= (int) day;\n\ttm->tm_yday\t= (int) day_of_year + 1;\n\n\ttm->tm_hour = secs / 3600;\n\tsecs -= tm->tm_hour * 3600;\n\ttm->tm_min = secs / 60;\n\ttm->tm_sec = secs - tm->tm_min * 60;\n\n\ttm->tm_isdst = 0;\n}\nEXPORT_SYMBOL(rtc_time64_to_tm);\n\n \nint rtc_valid_tm(struct rtc_time *tm)\n{\n\tif (tm->tm_year < 70 ||\n\t    tm->tm_year > (INT_MAX - 1900) ||\n\t    ((unsigned int)tm->tm_mon) >= 12 ||\n\t    tm->tm_mday < 1 ||\n\t    tm->tm_mday > rtc_month_days(tm->tm_mon,\n\t\t\t\t\t ((unsigned int)tm->tm_year + 1900)) ||\n\t    ((unsigned int)tm->tm_hour) >= 24 ||\n\t    ((unsigned int)tm->tm_min) >= 60 ||\n\t    ((unsigned int)tm->tm_sec) >= 60)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtc_valid_tm);\n\n \ntime64_t rtc_tm_to_time64(struct rtc_time *tm)\n{\n\treturn mktime64(((unsigned int)tm->tm_year + 1900), tm->tm_mon + 1,\n\t\t\ttm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n}\nEXPORT_SYMBOL(rtc_tm_to_time64);\n\n \nktime_t rtc_tm_to_ktime(struct rtc_time tm)\n{\n\treturn ktime_set(rtc_tm_to_time64(&tm), 0);\n}\nEXPORT_SYMBOL_GPL(rtc_tm_to_ktime);\n\n \nstruct rtc_time rtc_ktime_to_tm(ktime_t kt)\n{\n\tstruct timespec64 ts;\n\tstruct rtc_time ret;\n\n\tts = ktime_to_timespec64(kt);\n\t \n\tif (ts.tv_nsec)\n\t\tts.tv_sec++;\n\trtc_time64_to_tm(ts.tv_sec, &ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rtc_ktime_to_tm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}