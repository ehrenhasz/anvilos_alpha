{
  "module_name": "rtc-rx8025.c",
  "hash_id": "a8db182aa3f6bf27d9e7eb23cdb7b7823a818cf01783c554d5b9f16310649207",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rx8025.c",
  "human_readable_source": "\n \n#include <linux/bcd.h>\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n\n \n#define RX8025_REG_SEC\t\t0x00\n#define RX8025_REG_MIN\t\t0x01\n#define RX8025_REG_HOUR\t\t0x02\n#define RX8025_REG_WDAY\t\t0x03\n#define RX8025_REG_MDAY\t\t0x04\n#define RX8025_REG_MONTH\t0x05\n#define RX8025_REG_YEAR\t\t0x06\n#define RX8025_REG_DIGOFF\t0x07\n#define RX8025_REG_ALWMIN\t0x08\n#define RX8025_REG_ALWHOUR\t0x09\n#define RX8025_REG_ALWWDAY\t0x0a\n#define RX8025_REG_ALDMIN\t0x0b\n#define RX8025_REG_ALDHOUR\t0x0c\n \n#define RX8025_REG_CTRL1\t0x0e\n#define RX8025_REG_CTRL2\t0x0f\n\n#define RX8025_BIT_CTRL1_CT\t(7 << 0)\n \n#define RX8025_BIT_CTRL1_CT_1HZ\t4\n#define RX8025_BIT_CTRL1_TEST\tBIT(3)\n#define RX8025_BIT_CTRL1_1224\tBIT(5)\n#define RX8025_BIT_CTRL1_DALE\tBIT(6)\n#define RX8025_BIT_CTRL1_WALE\tBIT(7)\n\n#define RX8025_BIT_CTRL2_DAFG\tBIT(0)\n#define RX8025_BIT_CTRL2_WAFG\tBIT(1)\n#define RX8025_BIT_CTRL2_CTFG\tBIT(2)\n#define RX8025_BIT_CTRL2_PON\tBIT(4)\n#define RX8025_BIT_CTRL2_XST\tBIT(5)\n#define RX8025_BIT_CTRL2_VDET\tBIT(6)\n\n#define RX8035_BIT_HOUR_1224\tBIT(7)\n\n \n#define RX8025_ADJ_RESOLUTION\t3050  \n#define RX8025_ADJ_DATA_MAX\t62\n#define RX8025_ADJ_DATA_MIN\t-62\n\nenum rx_model {\n\tmodel_rx_unknown,\n\tmodel_rx_8025,\n\tmodel_rx_8035,\n\tmodel_last\n};\n\nstatic const struct i2c_device_id rx8025_id[] = {\n\t{ \"rx8025\", model_rx_8025 },\n\t{ \"rx8035\", model_rx_8035 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rx8025_id);\n\nstruct rx8025_data {\n\tstruct rtc_device *rtc;\n\tenum rx_model model;\n\tu8 ctrl1;\n\tint is_24;\n};\n\nstatic s32 rx8025_read_reg(const struct i2c_client *client, u8 number)\n{\n\treturn i2c_smbus_read_byte_data(client, number << 4);\n}\n\nstatic int rx8025_read_regs(const struct i2c_client *client,\n\t\t\t    u8 number, u8 length, u8 *values)\n{\n\tint ret = i2c_smbus_read_i2c_block_data(client, number << 4, length,\n\t\t\t\t\t\tvalues);\n\tif (ret != length)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic s32 rx8025_write_reg(const struct i2c_client *client, u8 number,\n\t\t\t    u8 value)\n{\n\treturn i2c_smbus_write_byte_data(client, number << 4, value);\n}\n\nstatic s32 rx8025_write_regs(const struct i2c_client *client,\n\t\t\t     u8 number, u8 length, const u8 *values)\n{\n\treturn i2c_smbus_write_i2c_block_data(client, number << 4,\n\t\t\t\t\t      length, values);\n}\n\nstatic int rx8025_is_osc_stopped(enum rx_model model, int ctrl2)\n{\n\tint xstp = ctrl2 & RX8025_BIT_CTRL2_XST;\n\t \n\n\tif (model == model_rx_8025)\n\t\txstp = !xstp;\n\n\treturn xstp;\n}\n\nstatic int rx8025_check_validity(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *drvdata = dev_get_drvdata(dev);\n\tint ctrl2;\n\tint xstp;\n\n\tctrl2 = rx8025_read_reg(client, RX8025_REG_CTRL2);\n\tif (ctrl2 < 0)\n\t\treturn ctrl2;\n\n\tif (ctrl2 & RX8025_BIT_CTRL2_VDET)\n\t\tdev_warn(dev, \"power voltage drop detected\\n\");\n\n\tif (ctrl2 & RX8025_BIT_CTRL2_PON) {\n\t\tdev_warn(dev, \"power-on reset detected, date is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txstp = rx8025_is_osc_stopped(drvdata->model, ctrl2);\n\tif (xstp) {\n\t\tdev_warn(dev, \"crystal stopped, date is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rx8025_reset_validity(struct i2c_client *client)\n{\n\tstruct rx8025_data *drvdata = i2c_get_clientdata(client);\n\tint ctrl2 = rx8025_read_reg(client, RX8025_REG_CTRL2);\n\n\tif (ctrl2 < 0)\n\t\treturn ctrl2;\n\n\tctrl2 &= ~(RX8025_BIT_CTRL2_PON | RX8025_BIT_CTRL2_VDET);\n\n\tif (drvdata->model == model_rx_8025)\n\t\tctrl2 |= RX8025_BIT_CTRL2_XST;\n\telse\n\t\tctrl2 &= ~(RX8025_BIT_CTRL2_XST);\n\n\treturn rx8025_write_reg(client, RX8025_REG_CTRL2,\n\t\t\t\tctrl2);\n}\n\nstatic irqreturn_t rx8025_handle_irq(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\n\tint status, xstp;\n\n\trtc_lock(rx8025->rtc);\n\tstatus = rx8025_read_reg(client, RX8025_REG_CTRL2);\n\tif (status < 0)\n\t\tgoto out;\n\n\txstp = rx8025_is_osc_stopped(rx8025->model, status);\n\tif (xstp)\n\t\tdev_warn(&client->dev, \"Oscillation stop was detected,\"\n\t\t\t \"you may have to readjust the clock\\n\");\n\n\tif (status & RX8025_BIT_CTRL2_CTFG) {\n\t\t \n\t\tstatus &= ~RX8025_BIT_CTRL2_CTFG;\n\t\trtc_update_irq(rx8025->rtc, 1, RTC_PF | RTC_IRQF);\n\t}\n\n\tif (status & RX8025_BIT_CTRL2_DAFG) {\n\t\t \n\t\tstatus &= RX8025_BIT_CTRL2_DAFG;\n\t\tif (rx8025_write_reg(client, RX8025_REG_CTRL1,\n\t\t\t\t     rx8025->ctrl1 & ~RX8025_BIT_CTRL1_DALE))\n\t\t\tgoto out;\n\t\trtc_update_irq(rx8025->rtc, 1, RTC_AF | RTC_IRQF);\n\t}\n\nout:\n\trtc_unlock(rx8025->rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rx8025_get_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint err;\n\n\terr = rx8025_check_validity(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = rx8025_read_regs(client, RX8025_REG_SEC, 7, date);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(dev, \"%s: read %7ph\\n\", __func__, date);\n\n\tdt->tm_sec = bcd2bin(date[RX8025_REG_SEC] & 0x7f);\n\tdt->tm_min = bcd2bin(date[RX8025_REG_MIN] & 0x7f);\n\tif (rx8025->is_24)\n\t\tdt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x3f);\n\telse\n\t\tdt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x1f) % 12\n\t\t\t+ (date[RX8025_REG_HOUR] & 0x20 ? 12 : 0);\n\n\tdt->tm_mday = bcd2bin(date[RX8025_REG_MDAY] & 0x3f);\n\tdt->tm_mon = bcd2bin(date[RX8025_REG_MONTH] & 0x1f) - 1;\n\tdt->tm_year = bcd2bin(date[RX8025_REG_YEAR]) + 100;\n\n\tdev_dbg(dev, \"%s: date %ptRr\\n\", __func__, dt);\n\n\treturn 0;\n}\n\nstatic int rx8025_set_time(struct device *dev, struct rtc_time *dt)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret;\n\n\t \n\tdate[RX8025_REG_SEC] = bin2bcd(dt->tm_sec);\n\tdate[RX8025_REG_MIN] = bin2bcd(dt->tm_min);\n\tif (rx8025->is_24)\n\t\tdate[RX8025_REG_HOUR] = bin2bcd(dt->tm_hour);\n\telse\n\t\tdate[RX8025_REG_HOUR] = (dt->tm_hour >= 12 ? 0x20 : 0)\n\t\t\t| bin2bcd((dt->tm_hour + 11) % 12 + 1);\n\n\tdate[RX8025_REG_WDAY] = bin2bcd(dt->tm_wday);\n\tdate[RX8025_REG_MDAY] = bin2bcd(dt->tm_mday);\n\tdate[RX8025_REG_MONTH] = bin2bcd(dt->tm_mon + 1);\n\tdate[RX8025_REG_YEAR] = bin2bcd(dt->tm_year - 100);\n\n\tdev_dbg(dev, \"%s: write %7ph\\n\", __func__, date);\n\n\tret = rx8025_write_regs(client, RX8025_REG_SEC, 7, date);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rx8025_reset_validity(client);\n}\n\nstatic int rx8025_init_client(struct i2c_client *client)\n{\n\tstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\n\tu8 ctrl[2], ctrl2;\n\tint need_clear = 0;\n\tint hour_reg;\n\tint err;\n\n\terr = rx8025_read_regs(client, RX8025_REG_CTRL1, 2, ctrl);\n\tif (err)\n\t\tgoto out;\n\n\t \n\trx8025->ctrl1 = ctrl[0] & ~RX8025_BIT_CTRL1_TEST;\n\n\tif (ctrl[1] & (RX8025_BIT_CTRL2_DAFG | RX8025_BIT_CTRL2_WAFG)) {\n\t\tdev_warn(&client->dev, \"Alarm was detected\\n\");\n\t\tneed_clear = 1;\n\t}\n\n\tif (ctrl[1] & RX8025_BIT_CTRL2_CTFG)\n\t\tneed_clear = 1;\n\n\tif (need_clear) {\n\t\tctrl2 = ctrl[1];\n\t\tctrl2 &= ~(RX8025_BIT_CTRL2_CTFG | RX8025_BIT_CTRL2_WAFG |\n\t\t\t   RX8025_BIT_CTRL2_DAFG);\n\n\t\terr = rx8025_write_reg(client, RX8025_REG_CTRL2, ctrl2);\n\t}\n\n\tif (rx8025->model == model_rx_8035) {\n\t\t \n\t\thour_reg = rx8025_read_reg(client, RX8025_REG_HOUR);\n\t\tif (hour_reg < 0)\n\t\t\treturn hour_reg;\n\t\trx8025->is_24 = (hour_reg & RX8035_BIT_HOUR_1224);\n\t} else {\n\t\trx8025->is_24 = (ctrl[1] & RX8025_BIT_CTRL1_1224);\n\t}\nout:\n\treturn err;\n}\n\n \nstatic int rx8025_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 ald[2];\n\tint ctrl2, err;\n\n\terr = rx8025_read_regs(client, RX8025_REG_ALDMIN, 2, ald);\n\tif (err)\n\t\treturn err;\n\n\tctrl2 = rx8025_read_reg(client, RX8025_REG_CTRL2);\n\tif (ctrl2 < 0)\n\t\treturn ctrl2;\n\n\tdev_dbg(dev, \"%s: read alarm 0x%02x 0x%02x ctrl2 %02x\\n\",\n\t\t__func__, ald[0], ald[1], ctrl2);\n\n\t \n\tt->time.tm_sec = 0;\n\tt->time.tm_min = bcd2bin(ald[0] & 0x7f);\n\tif (rx8025->is_24)\n\t\tt->time.tm_hour = bcd2bin(ald[1] & 0x3f);\n\telse\n\t\tt->time.tm_hour = bcd2bin(ald[1] & 0x1f) % 12\n\t\t\t+ (ald[1] & 0x20 ? 12 : 0);\n\n\tdev_dbg(dev, \"%s: date: %ptRr\\n\", __func__, &t->time);\n\tt->enabled = !!(rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE);\n\tt->pending = (ctrl2 & RX8025_BIT_CTRL2_DAFG) && t->enabled;\n\n\treturn err;\n}\n\nstatic int rx8025_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 ald[2];\n\tint err;\n\n\tald[0] = bin2bcd(t->time.tm_min);\n\tif (rx8025->is_24)\n\t\tald[1] = bin2bcd(t->time.tm_hour);\n\telse\n\t\tald[1] = (t->time.tm_hour >= 12 ? 0x20 : 0)\n\t\t\t| bin2bcd((t->time.tm_hour + 11) % 12 + 1);\n\n\tdev_dbg(dev, \"%s: write 0x%02x 0x%02x\\n\", __func__, ald[0], ald[1]);\n\n\tif (rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE) {\n\t\trx8025->ctrl1 &= ~RX8025_BIT_CTRL1_DALE;\n\t\terr = rx8025_write_reg(client, RX8025_REG_CTRL1,\n\t\t\t\t       rx8025->ctrl1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = rx8025_write_regs(client, RX8025_REG_ALDMIN, 2, ald);\n\tif (err)\n\t\treturn err;\n\n\tif (t->enabled) {\n\t\trx8025->ctrl1 |= RX8025_BIT_CTRL1_DALE;\n\t\terr = rx8025_write_reg(client, RX8025_REG_CTRL1,\n\t\t\t\t       rx8025->ctrl1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rx8025_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\n\tu8 ctrl1;\n\tint err;\n\n\tctrl1 = rx8025->ctrl1;\n\tif (enabled)\n\t\tctrl1 |= RX8025_BIT_CTRL1_DALE;\n\telse\n\t\tctrl1 &= ~RX8025_BIT_CTRL1_DALE;\n\n\tif (ctrl1 != rx8025->ctrl1) {\n\t\trx8025->ctrl1 = ctrl1;\n\t\terr = rx8025_write_reg(client, RX8025_REG_CTRL1,\n\t\t\t\t       rx8025->ctrl1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int rx8025_read_offset(struct device *dev, long *offset)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint digoff;\n\n\tdigoff = rx8025_read_reg(client, RX8025_REG_DIGOFF);\n\tif (digoff < 0)\n\t\treturn digoff;\n\n\t*offset = digoff >= 64 ? digoff - 128 : digoff;\n\tif (*offset > 0)\n\t\t(*offset)--;\n\t*offset *= RX8025_ADJ_RESOLUTION;\n\n\treturn 0;\n}\n\nstatic int rx8025_set_offset(struct device *dev, long offset)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 digoff;\n\n\toffset /= RX8025_ADJ_RESOLUTION;\n\tif (offset > RX8025_ADJ_DATA_MAX)\n\t\toffset = RX8025_ADJ_DATA_MAX;\n\telse if (offset < RX8025_ADJ_DATA_MIN)\n\t\toffset = RX8025_ADJ_DATA_MIN;\n\telse if (offset > 0)\n\t\toffset++;\n\telse if (offset < 0)\n\t\toffset += 128;\n\tdigoff = offset;\n\n\treturn rx8025_write_reg(client, RX8025_REG_DIGOFF, digoff);\n}\n\nstatic const struct rtc_class_ops rx8025_rtc_ops = {\n\t.read_time = rx8025_get_time,\n\t.set_time = rx8025_set_time,\n\t.read_alarm = rx8025_read_alarm,\n\t.set_alarm = rx8025_set_alarm,\n\t.alarm_irq_enable = rx8025_alarm_irq_enable,\n\t.read_offset = rx8025_read_offset,\n\t.set_offset = rx8025_set_offset,\n};\n\nstatic ssize_t rx8025_sysfs_show_clock_adjust(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tlong adj;\n\tint err;\n\n\tdev_warn_once(dev, \"clock_adjust_ppb is deprecated, use offset\\n\");\n\terr = rx8025_read_offset(dev, &adj);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%ld\\n\", -adj);\n}\n\nstatic ssize_t rx8025_sysfs_store_clock_adjust(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t count)\n{\n\tlong adj;\n\tint err;\n\n\tdev_warn_once(dev, \"clock_adjust_ppb is deprecated, use offset\\n\");\n\tif (kstrtol(buf, 10, &adj) != 0)\n\t\treturn -EINVAL;\n\n\terr = rx8025_set_offset(dev, -adj);\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR(clock_adjust_ppb, S_IRUGO | S_IWUSR,\n\t\t   rx8025_sysfs_show_clock_adjust,\n\t\t   rx8025_sysfs_store_clock_adjust);\n\nstatic struct attribute *rx8025_attrs[] = {\n\t&dev_attr_clock_adjust_ppb.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rx8025_attr_group = {\n\t.attrs\t= rx8025_attrs,\n};\n\nstatic int rx8025_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_match_id(rx8025_id, client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct rx8025_data *rx8025;\n\tint err = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"doesn't support required functionality\\n\");\n\t\treturn -EIO;\n\t}\n\n\trx8025 = devm_kzalloc(&client->dev, sizeof(*rx8025), GFP_KERNEL);\n\tif (!rx8025)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, rx8025);\n\n\tif (id)\n\t\trx8025->model = id->driver_data;\n\n\terr = rx8025_init_client(client);\n\tif (err)\n\t\treturn err;\n\n\trx8025->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rx8025->rtc))\n\t\treturn PTR_ERR(rx8025->rtc);\n\n\trx8025->rtc->ops = &rx8025_rtc_ops;\n\trx8025->rtc->range_min = RTC_TIMESTAMP_BEGIN_1900;\n\trx8025->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tif (client->irq > 0) {\n\t\tdev_info(&client->dev, \"IRQ %d supplied\\n\", client->irq);\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t\trx8025_handle_irq,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"rx8025\", client);\n\t\tif (err)\n\t\t\tclear_bit(RTC_FEATURE_ALARM, rx8025->rtc->features);\n\t}\n\n\trx8025->rtc->max_user_freq = 1;\n\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rx8025->rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rx8025->rtc->features);\n\n\terr = rtc_add_group(rx8025->rtc, &rx8025_attr_group);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_rtc_register_device(rx8025->rtc);\n}\n\nstatic struct i2c_driver rx8025_driver = {\n\t.driver = {\n\t\t.name = \"rtc-rx8025\",\n\t},\n\t.probe\t\t= rx8025_probe,\n\t.id_table\t= rx8025_id,\n};\n\nmodule_i2c_driver(rx8025_driver);\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"RX-8025 SA/NB RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}