{
  "module_name": "rtc-mv.c",
  "hash_id": "cc0be4fea5527d86fd1f8bd8a02a1673e7bdf0c8bb99444aa60c9925cc5eb1e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-mv.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n\n\n#define RTC_TIME_REG_OFFS\t0\n#define RTC_SECONDS_OFFS\t0\n#define RTC_MINUTES_OFFS\t8\n#define RTC_HOURS_OFFS\t\t16\n#define RTC_WDAY_OFFS\t\t24\n#define RTC_HOURS_12H_MODE\tBIT(22)  \n\n#define RTC_DATE_REG_OFFS\t4\n#define RTC_MDAY_OFFS\t\t0\n#define RTC_MONTH_OFFS\t\t8\n#define RTC_YEAR_OFFS\t\t16\n\n#define RTC_ALARM_TIME_REG_OFFS\t8\n#define RTC_ALARM_DATE_REG_OFFS\t0xc\n#define RTC_ALARM_VALID\t\tBIT(7)\n\n#define RTC_ALARM_INTERRUPT_MASK_REG_OFFS\t0x10\n#define RTC_ALARM_INTERRUPT_CASUE_REG_OFFS\t0x14\n\nstruct rtc_plat_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\n\tint\t\tirq;\n\tstruct clk\t*clk;\n};\n\nstatic int mv_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32\trtc_reg;\n\n\trtc_reg = (bin2bcd(tm->tm_sec) << RTC_SECONDS_OFFS) |\n\t\t(bin2bcd(tm->tm_min) << RTC_MINUTES_OFFS) |\n\t\t(bin2bcd(tm->tm_hour) << RTC_HOURS_OFFS) |\n\t\t(bin2bcd(tm->tm_wday) << RTC_WDAY_OFFS);\n\twritel(rtc_reg, ioaddr + RTC_TIME_REG_OFFS);\n\n\trtc_reg = (bin2bcd(tm->tm_mday) << RTC_MDAY_OFFS) |\n\t\t(bin2bcd(tm->tm_mon + 1) << RTC_MONTH_OFFS) |\n\t\t(bin2bcd(tm->tm_year - 100) << RTC_YEAR_OFFS);\n\twritel(rtc_reg, ioaddr + RTC_DATE_REG_OFFS);\n\n\treturn 0;\n}\n\nstatic int mv_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32\trtc_time, rtc_date;\n\tunsigned int year, month, day, hour, minute, second, wday;\n\n\trtc_time = readl(ioaddr + RTC_TIME_REG_OFFS);\n\trtc_date = readl(ioaddr + RTC_DATE_REG_OFFS);\n\n\tsecond = rtc_time & 0x7f;\n\tminute = (rtc_time >> RTC_MINUTES_OFFS) & 0x7f;\n\thour = (rtc_time >> RTC_HOURS_OFFS) & 0x3f;  \n\twday = (rtc_time >> RTC_WDAY_OFFS) & 0x7;\n\n\tday = rtc_date & 0x3f;\n\tmonth = (rtc_date >> RTC_MONTH_OFFS) & 0x3f;\n\tyear = (rtc_date >> RTC_YEAR_OFFS) & 0xff;\n\n\ttm->tm_sec = bcd2bin(second);\n\ttm->tm_min = bcd2bin(minute);\n\ttm->tm_hour = bcd2bin(hour);\n\ttm->tm_mday = bcd2bin(day);\n\ttm->tm_wday = bcd2bin(wday);\n\ttm->tm_mon = bcd2bin(month) - 1;\n\t \n\ttm->tm_year = bcd2bin(year) + 100;\n\n\treturn 0;\n}\n\nstatic int mv_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32\trtc_time, rtc_date;\n\tunsigned int year, month, day, hour, minute, second, wday;\n\n\trtc_time = readl(ioaddr + RTC_ALARM_TIME_REG_OFFS);\n\trtc_date = readl(ioaddr + RTC_ALARM_DATE_REG_OFFS);\n\n\tsecond = rtc_time & 0x7f;\n\tminute = (rtc_time >> RTC_MINUTES_OFFS) & 0x7f;\n\thour = (rtc_time >> RTC_HOURS_OFFS) & 0x3f;  \n\twday = (rtc_time >> RTC_WDAY_OFFS) & 0x7;\n\n\tday = rtc_date & 0x3f;\n\tmonth = (rtc_date >> RTC_MONTH_OFFS) & 0x3f;\n\tyear = (rtc_date >> RTC_YEAR_OFFS) & 0xff;\n\n\talm->time.tm_sec = bcd2bin(second);\n\talm->time.tm_min = bcd2bin(minute);\n\talm->time.tm_hour = bcd2bin(hour);\n\talm->time.tm_mday = bcd2bin(day);\n\talm->time.tm_wday = bcd2bin(wday);\n\talm->time.tm_mon = bcd2bin(month) - 1;\n\t \n\talm->time.tm_year = bcd2bin(year) + 100;\n\n\talm->enabled = !!readl(ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\n\n\treturn rtc_valid_tm(&alm->time);\n}\n\nstatic int mv_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\tu32 rtc_reg = 0;\n\n\tif (alm->time.tm_sec >= 0)\n\t\trtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_sec))\n\t\t\t<< RTC_SECONDS_OFFS;\n\tif (alm->time.tm_min >= 0)\n\t\trtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_min))\n\t\t\t<< RTC_MINUTES_OFFS;\n\tif (alm->time.tm_hour >= 0)\n\t\trtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_hour))\n\t\t\t<< RTC_HOURS_OFFS;\n\n\twritel(rtc_reg, ioaddr + RTC_ALARM_TIME_REG_OFFS);\n\n\tif (alm->time.tm_mday >= 0)\n\t\trtc_reg = (RTC_ALARM_VALID | bin2bcd(alm->time.tm_mday))\n\t\t\t<< RTC_MDAY_OFFS;\n\telse\n\t\trtc_reg = 0;\n\n\tif (alm->time.tm_mon >= 0)\n\t\trtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_mon + 1))\n\t\t\t<< RTC_MONTH_OFFS;\n\n\tif (alm->time.tm_year >= 0)\n\t\trtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_year - 100))\n\t\t\t<< RTC_YEAR_OFFS;\n\n\twritel(rtc_reg, ioaddr + RTC_ALARM_DATE_REG_OFFS);\n\twritel(0, ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS);\n\twritel(alm->enabled ? 1 : 0,\n\t       ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\n\n\treturn 0;\n}\n\nstatic int mv_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\n\tif (pdata->irq < 0)\n\t\treturn -EINVAL;  \n\n\tif (enabled)\n\t\twritel(1, ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\n\telse\n\t\twritel(0, ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\n\treturn 0;\n}\n\nstatic irqreturn_t mv_rtc_interrupt(int irq, void *data)\n{\n\tstruct rtc_plat_data *pdata = data;\n\tvoid __iomem *ioaddr = pdata->ioaddr;\n\n\t \n\tif (!readl(ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS))\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(0, ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS);\n\trtc_update_irq(pdata->rtc, 1, RTC_IRQF | RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops mv_rtc_ops = {\n\t.read_time\t= mv_rtc_read_time,\n\t.set_time\t= mv_rtc_set_time,\n\t.read_alarm\t= mv_rtc_read_alarm,\n\t.set_alarm\t= mv_rtc_set_alarm,\n\t.alarm_irq_enable = mv_rtc_alarm_irq_enable,\n};\n\nstatic int __init mv_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_plat_data *pdata;\n\tu32 rtc_time;\n\tint ret = 0;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->ioaddr))\n\t\treturn PTR_ERR(pdata->ioaddr);\n\n\tpdata->clk = devm_clk_get(&pdev->dev, NULL);\n\t \n\tif (!IS_ERR(pdata->clk))\n\t\tclk_prepare_enable(pdata->clk);\n\n\t \n\trtc_time = readl(pdata->ioaddr + RTC_TIME_REG_OFFS);\n\tif (rtc_time & RTC_HOURS_12H_MODE) {\n\t\tdev_err(&pdev->dev, \"12 Hour mode is enabled but not supported.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rtc_time == 0x01000000) {\n\t\tssleep(1);\n\t\trtc_time = readl(pdata->ioaddr + RTC_TIME_REG_OFFS);\n\t\tif (rtc_time == 0x01000000) {\n\t\t\tdev_err(&pdev->dev, \"internal RTC not ticking\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpdata->irq = platform_get_irq(pdev, 0);\n\n\tplatform_set_drvdata(pdev, pdata);\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc)) {\n\t\tret = PTR_ERR(pdata->rtc);\n\t\tgoto out;\n\t}\n\n\tif (pdata->irq >= 0) {\n\t\twritel(0, pdata->ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\n\t\tif (devm_request_irq(&pdev->dev, pdata->irq, mv_rtc_interrupt,\n\t\t\t\t     IRQF_SHARED,\n\t\t\t\t     pdev->name, pdata) < 0) {\n\t\t\tdev_warn(&pdev->dev, \"interrupt not available.\\n\");\n\t\t\tpdata->irq = -1;\n\t\t}\n\t}\n\n\tif (pdata->irq >= 0)\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, pdata->rtc->features);\n\n\tpdata->rtc->ops = &mv_rtc_ops;\n\tpdata->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpdata->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\tret = devm_rtc_register_device(pdata->rtc);\n\tif (!ret)\n\t\treturn 0;\nout:\n\tif (!IS_ERR(pdata->clk))\n\t\tclk_disable_unprepare(pdata->clk);\n\n\treturn ret;\n}\n\nstatic int __exit mv_rtc_remove(struct platform_device *pdev)\n{\n\tstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\n\n\tif (pdata->irq >= 0)\n\t\tdevice_init_wakeup(&pdev->dev, 0);\n\n\tif (!IS_ERR(pdata->clk))\n\t\tclk_disable_unprepare(pdata->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rtc_mv_of_match_table[] = {\n\t{ .compatible = \"marvell,orion-rtc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rtc_mv_of_match_table);\n#endif\n\nstatic struct platform_driver mv_rtc_driver = {\n\t.remove\t\t= __exit_p(mv_rtc_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-mv\",\n\t\t.of_match_table = of_match_ptr(rtc_mv_of_match_table),\n\t},\n};\n\nmodule_platform_driver_probe(mv_rtc_driver, mv_rtc_probe);\n\nMODULE_AUTHOR(\"Saeed Bishara <saeed@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-mv\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}