{
  "module_name": "rtc-ds1511.c",
  "hash_id": "9394f9a0baa163e3f49df8d51aa1bd3292b5eb26503f0604f8bac6f0c2a7da49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1511.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\nenum ds1511reg {\n\tDS1511_SEC = 0x0,\n\tDS1511_MIN = 0x1,\n\tDS1511_HOUR = 0x2,\n\tDS1511_DOW = 0x3,\n\tDS1511_DOM = 0x4,\n\tDS1511_MONTH = 0x5,\n\tDS1511_YEAR = 0x6,\n\tDS1511_CENTURY = 0x7,\n\tDS1511_AM1_SEC = 0x8,\n\tDS1511_AM2_MIN = 0x9,\n\tDS1511_AM3_HOUR = 0xa,\n\tDS1511_AM4_DATE = 0xb,\n\tDS1511_WD_MSEC = 0xc,\n\tDS1511_WD_SEC = 0xd,\n\tDS1511_CONTROL_A = 0xe,\n\tDS1511_CONTROL_B = 0xf,\n\tDS1511_RAMADDR_LSB = 0x10,\n\tDS1511_RAMDATA = 0x13\n};\n\n#define DS1511_BLF1\t0x80\n#define DS1511_BLF2\t0x40\n#define DS1511_PRS\t0x20\n#define DS1511_PAB\t0x10\n#define DS1511_TDF\t0x08\n#define DS1511_KSF\t0x04\n#define DS1511_WDF\t0x02\n#define DS1511_IRQF\t0x01\n#define DS1511_TE\t0x80\n#define DS1511_CS\t0x40\n#define DS1511_BME\t0x20\n#define DS1511_TPE\t0x10\n#define DS1511_TIE\t0x08\n#define DS1511_KIE\t0x04\n#define DS1511_WDE\t0x02\n#define DS1511_WDS\t0x01\n#define DS1511_RAM_MAX\t0x100\n\n#define RTC_CMD\t\tDS1511_CONTROL_B\n#define RTC_CMD1\tDS1511_CONTROL_A\n\n#define RTC_ALARM_SEC\tDS1511_AM1_SEC\n#define RTC_ALARM_MIN\tDS1511_AM2_MIN\n#define RTC_ALARM_HOUR\tDS1511_AM3_HOUR\n#define RTC_ALARM_DATE\tDS1511_AM4_DATE\n\n#define RTC_SEC\t\tDS1511_SEC\n#define RTC_MIN\t\tDS1511_MIN\n#define RTC_HOUR\tDS1511_HOUR\n#define RTC_DOW\t\tDS1511_DOW\n#define RTC_DOM\t\tDS1511_DOM\n#define RTC_MON\t\tDS1511_MONTH\n#define RTC_YEAR\tDS1511_YEAR\n#define RTC_CENTURY\tDS1511_CENTURY\n\n#define RTC_TIE\tDS1511_TIE\n#define RTC_TE\tDS1511_TE\n\nstruct rtc_plat_data {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *ioaddr;\t\t \n\tint irq;\n\tunsigned int irqen;\n\tint alrm_sec;\n\tint alrm_min;\n\tint alrm_hour;\n\tint alrm_mday;\n\tspinlock_t lock;\n};\n\nstatic DEFINE_SPINLOCK(ds1511_lock);\n\nstatic __iomem char *ds1511_base;\nstatic u32 reg_spacing = 1;\n\nstatic noinline void\nrtc_write(uint8_t val, uint32_t reg)\n{\n\twriteb(val, ds1511_base + (reg * reg_spacing));\n}\n\nstatic noinline uint8_t\nrtc_read(enum ds1511reg reg)\n{\n\treturn readb(ds1511_base + (reg * reg_spacing));\n}\n\nstatic inline void\nrtc_disable_update(void)\n{\n\trtc_write((rtc_read(RTC_CMD) & ~RTC_TE), RTC_CMD);\n}\n\nstatic void\nrtc_enable_update(void)\n{\n\trtc_write((rtc_read(RTC_CMD) | RTC_TE), RTC_CMD);\n}\n\n \n#ifdef DS1511_WDOG_RESET_SUPPORT\n \nvoid\nds1511_wdog_set(unsigned long deciseconds)\n{\n\t \n\tdeciseconds %= 10000;\n\t \n\trtc_write(bin2bcd(deciseconds % 100), DS1511_WD_MSEC);\n\trtc_write(bin2bcd(deciseconds / 100), DS1511_WD_SEC);\n\t \n\trtc_write(rtc_read(RTC_CMD) | DS1511_WDE | DS1511_WDS, RTC_CMD);\n}\n\nvoid\nds1511_wdog_disable(void)\n{\n\t \n\trtc_write(rtc_read(RTC_CMD) & ~(DS1511_WDE | DS1511_WDS), RTC_CMD);\n\t \n\trtc_write(0, DS1511_WD_MSEC);\n\trtc_write(0, DS1511_WD_SEC);\n}\n#endif\n\n \nstatic int ds1511_rtc_set_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tu8 mon, day, dow, hrs, min, sec, yrs, cen;\n\tunsigned long flags;\n\n\t \n\tif (rtc_tm->tm_year < 1900)\n\t\trtc_tm->tm_year += 1900;\n\n\tif (rtc_tm->tm_year < 1970)\n\t\treturn -EINVAL;\n\n\tyrs = rtc_tm->tm_year % 100;\n\tcen = rtc_tm->tm_year / 100;\n\tmon = rtc_tm->tm_mon + 1;    \n\tday = rtc_tm->tm_mday;\n\tdow = rtc_tm->tm_wday & 0x7;  \n\thrs = rtc_tm->tm_hour;\n\tmin = rtc_tm->tm_min;\n\tsec = rtc_tm->tm_sec;\n\n\tif ((mon > 12) || (day == 0))\n\t\treturn -EINVAL;\n\n\tif (day > rtc_month_days(rtc_tm->tm_mon, rtc_tm->tm_year))\n\t\treturn -EINVAL;\n\n\tif ((hrs >= 24) || (min >= 60) || (sec >= 60))\n\t\treturn -EINVAL;\n\n\t \n\tsec = bin2bcd(sec) & 0x7f;\n\tmin = bin2bcd(min) & 0x7f;\n\thrs = bin2bcd(hrs) & 0x3f;\n\tday = bin2bcd(day) & 0x3f;\n\tmon = bin2bcd(mon) & 0x1f;\n\tyrs = bin2bcd(yrs) & 0xff;\n\tcen = bin2bcd(cen) & 0xff;\n\n\tspin_lock_irqsave(&ds1511_lock, flags);\n\trtc_disable_update();\n\trtc_write(cen, RTC_CENTURY);\n\trtc_write(yrs, RTC_YEAR);\n\trtc_write((rtc_read(RTC_MON) & 0xe0) | mon, RTC_MON);\n\trtc_write(day, RTC_DOM);\n\trtc_write(hrs, RTC_HOUR);\n\trtc_write(min, RTC_MIN);\n\trtc_write(sec, RTC_SEC);\n\trtc_write(dow, RTC_DOW);\n\trtc_enable_update();\n\tspin_unlock_irqrestore(&ds1511_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ds1511_rtc_read_time(struct device *dev, struct rtc_time *rtc_tm)\n{\n\tunsigned int century;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds1511_lock, flags);\n\trtc_disable_update();\n\n\trtc_tm->tm_sec = rtc_read(RTC_SEC) & 0x7f;\n\trtc_tm->tm_min = rtc_read(RTC_MIN) & 0x7f;\n\trtc_tm->tm_hour = rtc_read(RTC_HOUR) & 0x3f;\n\trtc_tm->tm_mday = rtc_read(RTC_DOM) & 0x3f;\n\trtc_tm->tm_wday = rtc_read(RTC_DOW) & 0x7;\n\trtc_tm->tm_mon = rtc_read(RTC_MON) & 0x1f;\n\trtc_tm->tm_year = rtc_read(RTC_YEAR) & 0x7f;\n\tcentury = rtc_read(RTC_CENTURY);\n\n\trtc_enable_update();\n\tspin_unlock_irqrestore(&ds1511_lock, flags);\n\n\trtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);\n\trtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);\n\trtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);\n\trtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);\n\trtc_tm->tm_wday = bcd2bin(rtc_tm->tm_wday);\n\trtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon);\n\trtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);\n\tcentury = bcd2bin(century) * 100;\n\n\t \n\tcentury += rtc_tm->tm_year;\n\trtc_tm->tm_year = century - 1900;\n\n\trtc_tm->tm_mon--;\n\n\treturn 0;\n}\n\n \nstatic void\nds1511_rtc_update_alarm(struct rtc_plat_data *pdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->lock, flags);\n\trtc_write(pdata->alrm_mday < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_mday) & 0x3f,\n\t       RTC_ALARM_DATE);\n\trtc_write(pdata->alrm_hour < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_hour) & 0x3f,\n\t       RTC_ALARM_HOUR);\n\trtc_write(pdata->alrm_min < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_min) & 0x7f,\n\t       RTC_ALARM_MIN);\n\trtc_write(pdata->alrm_sec < 0 || (pdata->irqen & RTC_UF) ?\n\t       0x80 : bin2bcd(pdata->alrm_sec) & 0x7f,\n\t       RTC_ALARM_SEC);\n\trtc_write(rtc_read(RTC_CMD) | (pdata->irqen ? RTC_TIE : 0), RTC_CMD);\n\trtc_read(RTC_CMD1);\t \n\tspin_unlock_irqrestore(&pdata->lock, flags);\n}\n\nstatic int\nds1511_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\n\tpdata->alrm_mday = alrm->time.tm_mday;\n\tpdata->alrm_hour = alrm->time.tm_hour;\n\tpdata->alrm_min = alrm->time.tm_min;\n\tpdata->alrm_sec = alrm->time.tm_sec;\n\tif (alrm->enabled)\n\t\tpdata->irqen |= RTC_AF;\n\n\tds1511_rtc_update_alarm(pdata);\n\treturn 0;\n}\n\nstatic int\nds1511_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\n\talrm->time.tm_mday = pdata->alrm_mday < 0 ? 0 : pdata->alrm_mday;\n\talrm->time.tm_hour = pdata->alrm_hour < 0 ? 0 : pdata->alrm_hour;\n\talrm->time.tm_min = pdata->alrm_min < 0 ? 0 : pdata->alrm_min;\n\talrm->time.tm_sec = pdata->alrm_sec < 0 ? 0 : pdata->alrm_sec;\n\talrm->enabled = (pdata->irqen & RTC_AF) ? 1 : 0;\n\treturn 0;\n}\n\nstatic irqreturn_t\nds1511_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\n\tunsigned long events = 0;\n\n\tspin_lock(&pdata->lock);\n\t \n\tif (rtc_read(RTC_CMD1) & DS1511_IRQF) {\n\t\tevents = RTC_IRQF;\n\t\tif (rtc_read(RTC_ALARM_SEC) & 0x80)\n\t\t\tevents |= RTC_UF;\n\t\telse\n\t\t\tevents |= RTC_AF;\n\t\trtc_update_irq(pdata->rtc, 1, events);\n\t}\n\tspin_unlock(&pdata->lock);\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int ds1511_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\n\n\tif (pdata->irq <= 0)\n\t\treturn -EINVAL;\n\tif (enabled)\n\t\tpdata->irqen |= RTC_AF;\n\telse\n\t\tpdata->irqen &= ~RTC_AF;\n\tds1511_rtc_update_alarm(pdata);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops ds1511_rtc_ops = {\n\t.read_time\t\t= ds1511_rtc_read_time,\n\t.set_time\t\t= ds1511_rtc_set_time,\n\t.read_alarm\t\t= ds1511_rtc_read_alarm,\n\t.set_alarm\t\t= ds1511_rtc_set_alarm,\n\t.alarm_irq_enable\t= ds1511_rtc_alarm_irq_enable,\n};\n\nstatic int ds1511_nvram_read(void *priv, unsigned int pos, void *buf,\n\t\t\t     size_t size)\n{\n\tint i;\n\n\trtc_write(pos, DS1511_RAMADDR_LSB);\n\tfor (i = 0; i < size; i++)\n\t\t*(char *)buf++ = rtc_read(DS1511_RAMDATA);\n\n\treturn 0;\n}\n\nstatic int ds1511_nvram_write(void *priv, unsigned int pos, void *buf,\n\t\t\t      size_t size)\n{\n\tint i;\n\n\trtc_write(pos, DS1511_RAMADDR_LSB);\n\tfor (i = 0; i < size; i++)\n\t\trtc_write(*(char *)buf++, DS1511_RAMDATA);\n\n\treturn 0;\n}\n\nstatic int ds1511_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_plat_data *pdata;\n\tint ret = 0;\n\tstruct nvmem_config ds1511_nvmem_cfg = {\n\t\t.name = \"ds1511_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = DS1511_RAM_MAX,\n\t\t.reg_read = ds1511_nvram_read,\n\t\t.reg_write = ds1511_nvram_write,\n\t\t.priv = &pdev->dev,\n\t};\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tds1511_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ds1511_base))\n\t\treturn PTR_ERR(ds1511_base);\n\tpdata->ioaddr = ds1511_base;\n\tpdata->irq = platform_get_irq(pdev, 0);\n\n\t \n\trtc_write(DS1511_BME, RTC_CMD);\n\trtc_write(0, RTC_CMD1);\n\t \n\trtc_write(0, DS1511_WD_MSEC);\n\trtc_write(0, DS1511_WD_SEC);\n\t \n\trtc_enable_update();\n\n\t \n\tif (rtc_read(RTC_CMD1) & DS1511_BLF1)\n\t\tdev_warn(&pdev->dev, \"voltage-low detected.\\n\");\n\n\tspin_lock_init(&pdata->lock);\n\tplatform_set_drvdata(pdev, pdata);\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc))\n\t\treturn PTR_ERR(pdata->rtc);\n\n\tpdata->rtc->ops = &ds1511_rtc_ops;\n\n\tret = devm_rtc_register_device(pdata->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tdevm_rtc_nvmem_register(pdata->rtc, &ds1511_nvmem_cfg);\n\n\t \n\tif (pdata->irq > 0) {\n\t\trtc_read(RTC_CMD1);\n\t\tif (devm_request_irq(&pdev->dev, pdata->irq, ds1511_interrupt,\n\t\t\tIRQF_SHARED, pdev->name, pdev) < 0) {\n\n\t\t\tdev_warn(&pdev->dev, \"interrupt not available.\\n\");\n\t\t\tpdata->irq = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nMODULE_ALIAS(\"platform:ds1511\");\n\nstatic struct platform_driver ds1511_rtc_driver = {\n\t.probe\t\t= ds1511_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ds1511\",\n\t},\n};\n\nmodule_platform_driver(ds1511_rtc_driver);\n\nMODULE_AUTHOR(\"Andrew Sharp <andy.sharp@lsi.com>\");\nMODULE_DESCRIPTION(\"Dallas DS1511 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}