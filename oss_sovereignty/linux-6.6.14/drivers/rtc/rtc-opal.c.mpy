{
  "module_name": "rtc-opal.c",
  "hash_id": "97b513beca476287c6b002da6924e3977882a89fe541f013b64dbfe818f69ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-opal.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRVNAME\t\t\"rtc-opal\"\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n#include <linux/bcd.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <asm/opal.h>\n#include <asm/firmware.h>\n\nstatic void opal_to_tm(u32 y_m_d, u64 h_m_s_ms, struct rtc_time *tm)\n{\n\ttm->tm_year = ((bcd2bin(y_m_d >> 24) * 100) +\n\t\t       bcd2bin((y_m_d >> 16) & 0xff)) - 1900;\n\ttm->tm_mon  = bcd2bin((y_m_d >> 8) & 0xff) - 1;\n\ttm->tm_mday = bcd2bin(y_m_d & 0xff);\n\ttm->tm_hour = bcd2bin((h_m_s_ms >> 56) & 0xff);\n\ttm->tm_min  = bcd2bin((h_m_s_ms >> 48) & 0xff);\n\ttm->tm_sec  = bcd2bin((h_m_s_ms >> 40) & 0xff);\n\n\ttm->tm_wday = -1;\n}\n\nstatic void tm_to_opal(struct rtc_time *tm, u32 *y_m_d, u64 *h_m_s_ms)\n{\n\t*y_m_d |= ((u32)bin2bcd((tm->tm_year + 1900) / 100)) << 24;\n\t*y_m_d |= ((u32)bin2bcd((tm->tm_year + 1900) % 100)) << 16;\n\t*y_m_d |= ((u32)bin2bcd((tm->tm_mon + 1))) << 8;\n\t*y_m_d |= ((u32)bin2bcd(tm->tm_mday));\n\n\t*h_m_s_ms |= ((u64)bin2bcd(tm->tm_hour)) << 56;\n\t*h_m_s_ms |= ((u64)bin2bcd(tm->tm_min)) << 48;\n\t*h_m_s_ms |= ((u64)bin2bcd(tm->tm_sec)) << 40;\n}\n\nstatic int opal_get_rtc_time(struct device *dev, struct rtc_time *tm)\n{\n\ts64 rc = OPAL_BUSY;\n\tint retries = 10;\n\tu32 y_m_d;\n\tu64 h_m_s_ms;\n\t__be32 __y_m_d;\n\t__be64 __h_m_s_ms;\n\n\twhile (rc == OPAL_BUSY || rc == OPAL_BUSY_EVENT) {\n\t\trc = opal_rtc_read(&__y_m_d, &__h_m_s_ms);\n\t\tif (rc == OPAL_BUSY_EVENT) {\n\t\t\tmsleep(OPAL_BUSY_DELAY_MS);\n\t\t\topal_poll_events(NULL);\n\t\t} else if (rc == OPAL_BUSY) {\n\t\t\tmsleep(OPAL_BUSY_DELAY_MS);\n\t\t} else if (rc == OPAL_HARDWARE || rc == OPAL_INTERNAL_ERROR) {\n\t\t\tif (retries--) {\n\t\t\t\tmsleep(10);  \n\t\t\t\trc = OPAL_BUSY;  \n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc != OPAL_SUCCESS)\n\t\treturn -EIO;\n\n\ty_m_d = be32_to_cpu(__y_m_d);\n\th_m_s_ms = be64_to_cpu(__h_m_s_ms);\n\topal_to_tm(y_m_d, h_m_s_ms, tm);\n\n\treturn 0;\n}\n\nstatic int opal_set_rtc_time(struct device *dev, struct rtc_time *tm)\n{\n\ts64 rc = OPAL_BUSY;\n\tint retries = 10;\n\tu32 y_m_d = 0;\n\tu64 h_m_s_ms = 0;\n\n\ttm_to_opal(tm, &y_m_d, &h_m_s_ms);\n\n\twhile (rc == OPAL_BUSY || rc == OPAL_BUSY_EVENT) {\n\t\trc = opal_rtc_write(y_m_d, h_m_s_ms);\n\t\tif (rc == OPAL_BUSY_EVENT) {\n\t\t\tmsleep(OPAL_BUSY_DELAY_MS);\n\t\t\topal_poll_events(NULL);\n\t\t} else if (rc == OPAL_BUSY) {\n\t\t\tmsleep(OPAL_BUSY_DELAY_MS);\n\t\t} else if (rc == OPAL_HARDWARE || rc == OPAL_INTERNAL_ERROR) {\n\t\t\tif (retries--) {\n\t\t\t\tmsleep(10);  \n\t\t\t\trc = OPAL_BUSY;  \n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc == OPAL_SUCCESS ? 0 : -EIO;\n}\n\n \nstatic int opal_get_tpo_time(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\t__be32 __y_m_d, __h_m;\n\tstruct opal_msg msg;\n\tint rc, token;\n\tu64 h_m_s_ms;\n\tu32 y_m_d;\n\n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tpr_err(\"Failed to get the async token\\n\");\n\n\t\treturn token;\n\t}\n\n\trc = opal_tpo_read(token, &__y_m_d, &__h_m);\n\tif (rc != OPAL_ASYNC_COMPLETION) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\trc = opal_async_wait_response(token, &msg);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\trc = opal_get_async_rc(msg);\n\tif (rc != OPAL_SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\ty_m_d = be32_to_cpu(__y_m_d);\n\th_m_s_ms = ((u64)be32_to_cpu(__h_m) << 32);\n\n\t \n\tif (y_m_d == 0 && h_m_s_ms == 0) {\n\t\tpr_debug(\"No alarm is set\\n\");\n\t\trc = -ENOENT;\n\t\tgoto exit;\n\t} else {\n\t\tpr_debug(\"Alarm set to %x %llx\\n\", y_m_d, h_m_s_ms);\n\t}\n\n\topal_to_tm(y_m_d, h_m_s_ms, &alarm->time);\n\nexit:\n\topal_async_release_token(token);\n\treturn rc;\n}\n\n \nstatic int opal_set_tpo_time(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tu64 h_m_s_ms = 0;\n\tstruct opal_msg msg;\n\tu32 y_m_d = 0;\n\tint token, rc;\n\n\t \n\tif (alarm->enabled) {\n\t\ttm_to_opal(&alarm->time, &y_m_d, &h_m_s_ms);\n\t\tpr_debug(\"Alarm set to %x %llx\\n\", y_m_d, h_m_s_ms);\n\n\t} else {\n\t\tpr_debug(\"Alarm getting disabled\\n\");\n\t}\n\n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tpr_err(\"Failed to get the async token\\n\");\n\n\t\treturn token;\n\t}\n\n\t \n\trc = opal_tpo_write(token, y_m_d,\n\t\t\t    (u32)((h_m_s_ms >> 32) & 0xffff0000));\n\tif (rc != OPAL_ASYNC_COMPLETION) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\trc = opal_async_wait_response(token, &msg);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\trc = opal_get_async_rc(msg);\n\tif (rc != OPAL_SUCCESS)\n\t\trc = -EIO;\n\nexit:\n\topal_async_release_token(token);\n\treturn rc;\n}\n\nstatic int opal_tpo_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rtc_wkalrm alarm = { .enabled = 0 };\n\n\t \n\treturn enabled ? 0 : opal_set_tpo_time(dev, &alarm);\n}\n\nstatic const struct rtc_class_ops opal_rtc_ops = {\n\t.read_time\t= opal_get_rtc_time,\n\t.set_time\t= opal_set_rtc_time,\n\t.read_alarm\t= opal_get_tpo_time,\n\t.set_alarm\t= opal_set_tpo_time,\n\t.alarm_irq_enable = opal_tpo_alarm_irq_enable,\n};\n\nstatic int opal_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tif (pdev->dev.of_node &&\n\t    (of_property_read_bool(pdev->dev.of_node, \"wakeup-source\") ||\n\t     of_property_read_bool(pdev->dev.of_node, \"has-tpo\") ))\n\t\tdevice_set_wakeup_capable(&pdev->dev, true);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, rtc->features);\n\n\trtc->ops = &opal_rtc_ops;\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_0000;\n\trtc->range_max = RTC_TIMESTAMP_END_9999;\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic const struct of_device_id opal_rtc_match[] = {\n\t{\n\t\t.compatible\t= \"ibm,opal-rtc\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, opal_rtc_match);\n\nstatic const struct platform_device_id opal_rtc_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"opal-rtc\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, opal_rtc_driver_ids);\n\nstatic struct platform_driver opal_rtc_driver = {\n\t.probe\t\t= opal_rtc_probe,\n\t.id_table\t= opal_rtc_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t\t= DRVNAME,\n\t\t.of_match_table\t= opal_rtc_match,\n\t},\n};\n\nstatic int __init opal_rtc_init(void)\n{\n\tif (!firmware_has_feature(FW_FEATURE_OPAL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&opal_rtc_driver);\n}\n\nstatic void __exit opal_rtc_exit(void)\n{\n\tplatform_driver_unregister(&opal_rtc_driver);\n}\n\nMODULE_AUTHOR(\"Neelesh Gupta <neelegup@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM OPAL RTC driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(opal_rtc_init);\nmodule_exit(opal_rtc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}