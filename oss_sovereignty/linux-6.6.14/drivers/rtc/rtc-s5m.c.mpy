{
  "module_name": "rtc-s5m.c",
  "hash_id": "9af9d0220223fad1a6ee31949352ca228338e7afdb369be36ca2b6136ff6574f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-s5m.c",
  "human_readable_source": "\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/samsung/core.h>\n#include <linux/mfd/samsung/irq.h>\n#include <linux/mfd/samsung/rtc.h>\n#include <linux/mfd/samsung/s2mps14.h>\n\n \n#define UDR_READ_RETRY_CNT\t5\n\nenum {\n\tRTC_SEC = 0,\n\tRTC_MIN,\n\tRTC_HOUR,\n\tRTC_WEEKDAY,\n\tRTC_DATE,\n\tRTC_MONTH,\n\tRTC_YEAR1,\n\tRTC_YEAR2,\n\t \n\tRTC_MAX_NUM_TIME_REGS\n};\n\n \nstruct s5m_rtc_reg_config {\n\t \n\tunsigned int regs_count;\n\t \n\tunsigned int time;\n\t \n\tunsigned int ctrl;\n\t \n\tunsigned int alarm0;\n\t \n\tunsigned int alarm1;\n\t \n\tunsigned int udr_update;\n\t \n\tunsigned int autoclear_udr_mask;\n\t \n\tunsigned int read_time_udr_mask;\n\tunsigned int write_time_udr_mask;\n\tunsigned int write_alarm_udr_mask;\n};\n\n \nstatic const struct s5m_rtc_reg_config s5m_rtc_regs = {\n\t.regs_count\t\t= 8,\n\t.time\t\t\t= S5M_RTC_SEC,\n\t.ctrl\t\t\t= S5M_ALARM1_CONF,\n\t.alarm0\t\t\t= S5M_ALARM0_SEC,\n\t.alarm1\t\t\t= S5M_ALARM1_SEC,\n\t.udr_update\t\t= S5M_RTC_UDR_CON,\n\t.autoclear_udr_mask\t= S5M_RTC_UDR_MASK,\n\t.read_time_udr_mask\t= 0,  \n\t.write_time_udr_mask\t= S5M_RTC_UDR_MASK | S5M_RTC_TIME_EN_MASK,\n\t.write_alarm_udr_mask\t= S5M_RTC_UDR_MASK,\n};\n\n \nstatic const struct s5m_rtc_reg_config s2mps13_rtc_regs = {\n\t.regs_count\t\t= 7,\n\t.time\t\t\t= S2MPS_RTC_SEC,\n\t.ctrl\t\t\t= S2MPS_RTC_CTRL,\n\t.alarm0\t\t\t= S2MPS_ALARM0_SEC,\n\t.alarm1\t\t\t= S2MPS_ALARM1_SEC,\n\t.udr_update\t\t= S2MPS_RTC_UDR_CON,\n\t.autoclear_udr_mask\t= S2MPS_RTC_WUDR_MASK,\n\t.read_time_udr_mask\t= S2MPS_RTC_RUDR_MASK,\n\t.write_time_udr_mask\t= S2MPS_RTC_WUDR_MASK,\n\t.write_alarm_udr_mask\t= S2MPS_RTC_WUDR_MASK | S2MPS13_RTC_AUDR_MASK,\n};\n\n \nstatic const struct s5m_rtc_reg_config s2mps14_rtc_regs = {\n\t.regs_count\t\t= 7,\n\t.time\t\t\t= S2MPS_RTC_SEC,\n\t.ctrl\t\t\t= S2MPS_RTC_CTRL,\n\t.alarm0\t\t\t= S2MPS_ALARM0_SEC,\n\t.alarm1\t\t\t= S2MPS_ALARM1_SEC,\n\t.udr_update\t\t= S2MPS_RTC_UDR_CON,\n\t.autoclear_udr_mask\t= S2MPS_RTC_WUDR_MASK,\n\t.read_time_udr_mask\t= S2MPS_RTC_RUDR_MASK,\n\t.write_time_udr_mask\t= S2MPS_RTC_WUDR_MASK,\n\t.write_alarm_udr_mask\t= S2MPS_RTC_WUDR_MASK | S2MPS_RTC_RUDR_MASK,\n};\n\n \nstatic const struct s5m_rtc_reg_config s2mps15_rtc_regs = {\n\t.regs_count\t\t= 7,\n\t.time\t\t\t= S2MPS_RTC_SEC,\n\t.ctrl\t\t\t= S2MPS_RTC_CTRL,\n\t.alarm0\t\t\t= S2MPS_ALARM0_SEC,\n\t.alarm1\t\t\t= S2MPS_ALARM1_SEC,\n\t.udr_update\t\t= S2MPS_RTC_UDR_CON,\n\t.autoclear_udr_mask\t= S2MPS_RTC_WUDR_MASK,\n\t.read_time_udr_mask\t= S2MPS_RTC_RUDR_MASK,\n\t.write_time_udr_mask\t= S2MPS15_RTC_WUDR_MASK,\n\t.write_alarm_udr_mask\t= S2MPS15_RTC_AUDR_MASK,\n};\n\nstruct s5m_rtc_info {\n\tstruct device *dev;\n\tstruct i2c_client *i2c;\n\tstruct sec_pmic_dev *s5m87xx;\n\tstruct regmap *regmap;\n\tstruct rtc_device *rtc_dev;\n\tint irq;\n\tenum sec_device_type device_type;\n\tint rtc_24hr_mode;\n\tconst struct s5m_rtc_reg_config\t*regs;\n};\n\nstatic const struct regmap_config s5m_rtc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S5M_RTC_REG_MAX,\n};\n\nstatic const struct regmap_config s2mps14_rtc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPS_RTC_REG_MAX,\n};\n\nstatic void s5m8767_data_to_tm(u8 *data, struct rtc_time *tm,\n\t\t\t       int rtc_24hr_mode)\n{\n\ttm->tm_sec = data[RTC_SEC] & 0x7f;\n\ttm->tm_min = data[RTC_MIN] & 0x7f;\n\tif (rtc_24hr_mode) {\n\t\ttm->tm_hour = data[RTC_HOUR] & 0x1f;\n\t} else {\n\t\ttm->tm_hour = data[RTC_HOUR] & 0x0f;\n\t\tif (data[RTC_HOUR] & HOUR_PM_MASK)\n\t\t\ttm->tm_hour += 12;\n\t}\n\n\ttm->tm_wday = ffs(data[RTC_WEEKDAY] & 0x7f);\n\ttm->tm_mday = data[RTC_DATE] & 0x1f;\n\ttm->tm_mon = (data[RTC_MONTH] & 0x0f) - 1;\n\ttm->tm_year = (data[RTC_YEAR1] & 0x7f) + 100;\n\ttm->tm_yday = 0;\n\ttm->tm_isdst = 0;\n}\n\nstatic int s5m8767_tm_to_data(struct rtc_time *tm, u8 *data)\n{\n\tdata[RTC_SEC] = tm->tm_sec;\n\tdata[RTC_MIN] = tm->tm_min;\n\n\tif (tm->tm_hour >= 12)\n\t\tdata[RTC_HOUR] = tm->tm_hour | HOUR_PM_MASK;\n\telse\n\t\tdata[RTC_HOUR] = tm->tm_hour & ~HOUR_PM_MASK;\n\n\tdata[RTC_WEEKDAY] = 1 << tm->tm_wday;\n\tdata[RTC_DATE] = tm->tm_mday;\n\tdata[RTC_MONTH] = tm->tm_mon + 1;\n\tdata[RTC_YEAR1] = tm->tm_year - 100;\n\n\treturn 0;\n}\n\n \nstatic int s5m8767_wait_for_udr_update(struct s5m_rtc_info *info)\n{\n\tint ret, retry = UDR_READ_RETRY_CNT;\n\tunsigned int data;\n\n\tdo {\n\t\tret = regmap_read(info->regmap, info->regs->udr_update, &data);\n\t} while (--retry && (data & info->regs->autoclear_udr_mask) && !ret);\n\n\tif (!retry)\n\t\tdev_err(info->dev, \"waiting for UDR update, reached max number of retries\\n\");\n\n\treturn ret;\n}\n\nstatic int s5m_check_peding_alarm_interrupt(struct s5m_rtc_info *info,\n\t\tstruct rtc_wkalrm *alarm)\n{\n\tint ret;\n\tunsigned int val;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\t\tret = regmap_read(info->regmap, S5M_RTC_STATUS, &val);\n\t\tval &= S5M_ALARM0_STATUS;\n\t\tbreak;\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tret = regmap_read(info->s5m87xx->regmap_pmic, S2MPS14_REG_ST2,\n\t\t\t\t&val);\n\t\tval &= S2MPS_ALARM0_STATUS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val)\n\t\talarm->pending = 1;\n\telse\n\t\talarm->pending = 0;\n\n\treturn 0;\n}\n\nstatic int s5m8767_rtc_set_time_reg(struct s5m_rtc_info *info)\n{\n\tint ret;\n\tunsigned int data;\n\n\tret = regmap_read(info->regmap, info->regs->udr_update, &data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"failed to read update reg(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata |= info->regs->write_time_udr_mask;\n\n\tret = regmap_write(info->regmap, info->regs->udr_update, data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"failed to write update reg(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = s5m8767_wait_for_udr_update(info);\n\n\treturn ret;\n}\n\nstatic int s5m8767_rtc_set_alarm_reg(struct s5m_rtc_info *info)\n{\n\tint ret;\n\tunsigned int data;\n\n\tret = regmap_read(info->regmap, info->regs->udr_update, &data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to read update reg(%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tdata |= info->regs->write_alarm_udr_mask;\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\t\tdata &= ~S5M_RTC_TIME_EN_MASK;\n\t\tbreak;\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(info->regmap, info->regs->udr_update, data);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write update reg(%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = s5m8767_wait_for_udr_update(info);\n\n\t \n\tif (info->device_type == S2MPS13X)\n\t\tregmap_update_bits(info->regmap, info->regs->udr_update,\n\t\t\t\t   S2MPS13_RTC_AUDR_MASK, 0);\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tint ret;\n\n\tif (info->regs->read_time_udr_mask) {\n\t\tret = regmap_update_bits(info->regmap,\n\t\t\t\tinfo->regs->udr_update,\n\t\t\t\tinfo->regs->read_time_udr_mask,\n\t\t\t\tinfo->regs->read_time_udr_mask);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to prepare registers for time reading: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = regmap_bulk_read(info->regmap, info->regs->time, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\ts5m8767_data_to_tm(data, tm, info->rtc_24hr_mode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s: %ptR(%d)\\n\", __func__, tm, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int s5m_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tint ret = 0;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tret = s5m8767_tm_to_data(tm, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"%s: %ptR(%d)\\n\", __func__, tm, tm->tm_wday);\n\n\tret = regmap_raw_write(info->regmap, info->regs->time, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5m8767_rtc_set_time_reg(info);\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tint ret, i;\n\n\tret = regmap_bulk_read(info->regmap, info->regs->alarm0, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\ts5m8767_data_to_tm(data, &alrm->time, info->rtc_24hr_mode);\n\t\talrm->enabled = 0;\n\t\tfor (i = 0; i < info->regs->regs_count; i++) {\n\t\t\tif (data[i] & ALARM_ENABLE_MASK) {\n\t\t\t\talrm->enabled = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s: %ptR(%d)\\n\", __func__, &alrm->time, alrm->time.tm_wday);\n\n\treturn s5m_check_peding_alarm_interrupt(info, alrm);\n}\n\nstatic int s5m_rtc_stop_alarm(struct s5m_rtc_info *info)\n{\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tint ret, i;\n\tstruct rtc_time tm;\n\n\tret = regmap_bulk_read(info->regmap, info->regs->alarm0, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts5m8767_data_to_tm(data, &tm, info->rtc_24hr_mode);\n\tdev_dbg(info->dev, \"%s: %ptR(%d)\\n\", __func__, &tm, tm.tm_wday);\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tfor (i = 0; i < info->regs->regs_count; i++)\n\t\t\tdata[i] &= ~ALARM_ENABLE_MASK;\n\n\t\tret = regmap_raw_write(info->regmap, info->regs->alarm0, data,\n\t\t\t\tinfo->regs->regs_count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = s5m8767_rtc_set_alarm_reg(info);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_start_alarm(struct s5m_rtc_info *info)\n{\n\tint ret;\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tstruct rtc_time tm;\n\n\tret = regmap_bulk_read(info->regmap, info->regs->alarm0, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts5m8767_data_to_tm(data, &tm, info->rtc_24hr_mode);\n\tdev_dbg(info->dev, \"%s: %ptR(%d)\\n\", __func__, &tm, tm.tm_wday);\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tdata[RTC_SEC] |= ALARM_ENABLE_MASK;\n\t\tdata[RTC_MIN] |= ALARM_ENABLE_MASK;\n\t\tdata[RTC_HOUR] |= ALARM_ENABLE_MASK;\n\t\tdata[RTC_WEEKDAY] &= ~ALARM_ENABLE_MASK;\n\t\tif (data[RTC_DATE] & 0x1f)\n\t\t\tdata[RTC_DATE] |= ALARM_ENABLE_MASK;\n\t\tif (data[RTC_MONTH] & 0xf)\n\t\t\tdata[RTC_MONTH] |= ALARM_ENABLE_MASK;\n\t\tif (data[RTC_YEAR1] & 0x7f)\n\t\t\tdata[RTC_YEAR1] |= ALARM_ENABLE_MASK;\n\n\t\tret = regmap_raw_write(info->regmap, info->regs->alarm0, data,\n\t\t\t\tinfo->regs->regs_count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = s5m8767_rtc_set_alarm_reg(info);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tu8 data[RTC_MAX_NUM_TIME_REGS];\n\tint ret;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\ts5m8767_tm_to_data(&alrm->time, data);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s: %ptR(%d)\\n\", __func__, &alrm->time, alrm->time.tm_wday);\n\n\tret = s5m_rtc_stop_alarm(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_raw_write(info->regmap, info->regs->alarm0, data,\n\t\t\tinfo->regs->regs_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5m8767_rtc_set_alarm_reg(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (alrm->enabled)\n\t\tret = s5m_rtc_start_alarm(info);\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t    unsigned int enabled)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\treturn s5m_rtc_start_alarm(info);\n\telse\n\t\treturn s5m_rtc_stop_alarm(info);\n}\n\nstatic irqreturn_t s5m_rtc_alarm_irq(int irq, void *data)\n{\n\tstruct s5m_rtc_info *info = data;\n\n\trtc_update_irq(info->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops s5m_rtc_ops = {\n\t.read_time = s5m_rtc_read_time,\n\t.set_time = s5m_rtc_set_time,\n\t.read_alarm = s5m_rtc_read_alarm,\n\t.set_alarm = s5m_rtc_set_alarm,\n\t.alarm_irq_enable = s5m_rtc_alarm_irq_enable,\n};\n\nstatic int s5m8767_rtc_init_reg(struct s5m_rtc_info *info)\n{\n\tu8 data[2];\n\tint ret;\n\n\tswitch (info->device_type) {\n\tcase S5M8767X:\n\t\t \n\t\tret = regmap_update_bits(info->regmap, S5M_RTC_UDR_CON,\n\t\t\t\tS5M_RTC_UDR_T_MASK, S5M_RTC_UDR_T_450_US);\n\t\tif (ret < 0)\n\t\t\tdev_err(info->dev, \"%s: fail to change UDR time: %d\\n\",\n\t\t\t\t\t__func__, ret);\n\n\t\t \n\t\tdata[0] = (1 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\n\t\tdata[1] = (0 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\n\n\t\tret = regmap_raw_write(info->regmap, S5M_ALARM0_CONF, data, 2);\n\t\tbreak;\n\n\tcase S2MPS15X:\n\tcase S2MPS14X:\n\tcase S2MPS13X:\n\t\tdata[0] = (0 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\n\t\tret = regmap_write(info->regmap, info->regs->ctrl, data[0]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tret = s5m8767_rtc_set_alarm_reg(info);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->rtc_24hr_mode = 1;\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"%s: fail to write controlm reg(%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_probe(struct platform_device *pdev)\n{\n\tstruct sec_pmic_dev *s5m87xx = dev_get_drvdata(pdev->dev.parent);\n\tstruct s5m_rtc_info *info;\n\tconst struct regmap_config *regmap_cfg;\n\tint ret, alarm_irq;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tswitch (platform_get_device_id(pdev)->driver_data) {\n\tcase S2MPS15X:\n\t\tregmap_cfg = &s2mps14_rtc_regmap_config;\n\t\tinfo->regs = &s2mps15_rtc_regs;\n\t\talarm_irq = S2MPS14_IRQ_RTCA0;\n\t\tbreak;\n\tcase S2MPS14X:\n\t\tregmap_cfg = &s2mps14_rtc_regmap_config;\n\t\tinfo->regs = &s2mps14_rtc_regs;\n\t\talarm_irq = S2MPS14_IRQ_RTCA0;\n\t\tbreak;\n\tcase S2MPS13X:\n\t\tregmap_cfg = &s2mps14_rtc_regmap_config;\n\t\tinfo->regs = &s2mps13_rtc_regs;\n\t\talarm_irq = S2MPS14_IRQ_RTCA0;\n\t\tbreak;\n\tcase S5M8767X:\n\t\tregmap_cfg = &s5m_rtc_regmap_config;\n\t\tinfo->regs = &s5m_rtc_regs;\n\t\talarm_irq = S5M8767_IRQ_RTCA1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Device type %lu is not supported by RTC driver\\n\",\n\t\t\t\tplatform_get_device_id(pdev)->driver_data);\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->i2c = devm_i2c_new_dummy_device(&pdev->dev, s5m87xx->i2c->adapter,\n\t\t\t\t\t      RTC_I2C_ADDR);\n\tif (IS_ERR(info->i2c)) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate I2C for RTC\\n\");\n\t\treturn PTR_ERR(info->i2c);\n\t}\n\n\tinfo->regmap = devm_regmap_init_i2c(info->i2c, regmap_cfg);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(&pdev->dev, \"Failed to allocate RTC register map: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tinfo->dev = &pdev->dev;\n\tinfo->s5m87xx = s5m87xx;\n\tinfo->device_type = platform_get_device_id(pdev)->driver_data;\n\n\tif (s5m87xx->irq_data) {\n\t\tinfo->irq = regmap_irq_get_virq(s5m87xx->irq_data, alarm_irq);\n\t\tif (info->irq <= 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get virtual IRQ %d\\n\",\n\t\t\t\talarm_irq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = s5m8767_rtc_init_reg(info);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc_dev))\n\t\treturn PTR_ERR(info->rtc_dev);\n\n\tinfo->rtc_dev->ops = &s5m_rtc_ops;\n\n\tinfo->rtc_dev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tinfo->rtc_dev->range_max = RTC_TIMESTAMP_END_2099;\n\n\tif (!info->irq) {\n\t\tclear_bit(RTC_FEATURE_ALARM, info->rtc_dev->features);\n\t} else {\n\t\tret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\n\t\t\t\t\t\ts5m_rtc_alarm_irq, 0, \"rtc-alarm0\",\n\t\t\t\t\t\tinfo);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ: %d: %d\\n\",\n\t\t\t\tinfo->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\t}\n\n\treturn devm_rtc_register_device(info->rtc_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int s5m_rtc_resume(struct device *dev)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (info->irq && device_may_wakeup(dev))\n\t\tret = disable_irq_wake(info->irq);\n\n\treturn ret;\n}\n\nstatic int s5m_rtc_suspend(struct device *dev)\n{\n\tstruct s5m_rtc_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (info->irq && device_may_wakeup(dev))\n\t\tret = enable_irq_wake(info->irq);\n\n\treturn ret;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(s5m_rtc_pm_ops, s5m_rtc_suspend, s5m_rtc_resume);\n\nstatic const struct platform_device_id s5m_rtc_id[] = {\n\t{ \"s5m-rtc\",\t\tS5M8767X },\n\t{ \"s2mps13-rtc\",\tS2MPS13X },\n\t{ \"s2mps14-rtc\",\tS2MPS14X },\n\t{ \"s2mps15-rtc\",\tS2MPS15X },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, s5m_rtc_id);\n\nstatic struct platform_driver s5m_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"s5m-rtc\",\n\t\t.pm\t= &s5m_rtc_pm_ops,\n\t},\n\t.probe\t\t= s5m_rtc_probe,\n\t.id_table\t= s5m_rtc_id,\n};\n\nmodule_platform_driver(s5m_rtc_driver);\n\n \nMODULE_AUTHOR(\"Sangbeom Kim <sbkim73@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S5M/S2MPS14 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}