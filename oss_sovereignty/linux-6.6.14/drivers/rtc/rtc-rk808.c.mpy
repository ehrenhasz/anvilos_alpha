{
  "module_name": "rtc-rk808.c",
  "hash_id": "674e74a3cbc8d72988dce8cc1423b93bdd037086fe01c3a182345809ae9b3ecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rk808.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/mfd/rk808.h>\n#include <linux/platform_device.h>\n\n \n#define BIT_RTC_CTRL_REG_STOP_RTC_M\t\tBIT(0)\n\n \n#define BIT_RTC_CTRL_REG_RTC_GET_TIME\t\tBIT(6)\n#define BIT_RTC_CTRL_REG_RTC_READSEL_M\t\tBIT(7)\n#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M\tBIT(3)\n#define RTC_STATUS_MASK\t\t0xFE\n\n#define SECONDS_REG_MSK\t\t0x7F\n#define MINUTES_REG_MAK\t\t0x7F\n#define HOURS_REG_MSK\t\t0x3F\n#define DAYS_REG_MSK\t\t0x3F\n#define MONTHS_REG_MSK\t\t0x1F\n#define YEARS_REG_MSK\t\t0xFF\n#define WEEKS_REG_MSK\t\t0x7\n\n \n\n#define NUM_TIME_REGS\t(RK808_WEEKS_REG - RK808_SECONDS_REG + 1)\n#define NUM_ALARM_REGS\t(RK808_ALARM_YEARS_REG - RK808_ALARM_SECONDS_REG + 1)\n\nstruct rk_rtc_compat_reg {\n\tunsigned int ctrl_reg;\n\tunsigned int status_reg;\n\tunsigned int alarm_seconds_reg;\n\tunsigned int int_reg;\n\tunsigned int seconds_reg;\n};\n\nstruct rk808_rtc {\n\tstruct regmap *regmap;\n\tstruct rtc_device *rtc;\n\tstruct rk_rtc_compat_reg *creg;\n\tint irq;\n};\n\n \nstatic time64_t nov2dec_transitions(struct rtc_time *tm)\n{\n\treturn (tm->tm_year + 1900) - 2016 + (tm->tm_mon + 1 > 11 ? 1 : 0);\n}\n\nstatic void rockchip_to_gregorian(struct rtc_time *tm)\n{\n\t \n\ttime64_t time = rtc_tm_to_time64(tm);\n\trtc_time64_to_tm(time + nov2dec_transitions(tm) * 86400, tm);\n}\n\nstatic void gregorian_to_rockchip(struct rtc_time *tm)\n{\n\ttime64_t extra_days = nov2dec_transitions(tm);\n\ttime64_t time = rtc_tm_to_time64(tm);\n\trtc_time64_to_tm(time - extra_days * 86400, tm);\n\n\t \n\tif (nov2dec_transitions(tm) < extra_days) {\n\t\tif (tm->tm_mon + 1 == 11)\n\t\t\ttm->tm_mday++;\t \n\t\telse\n\t\t\trtc_time64_to_tm(time - (extra_days - 1) * 86400, tm);\n\t}\n}\n\n \nstatic int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\tu8 rtc_data[NUM_TIME_REGS];\n\tint ret;\n\n\t \n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->ctrl_reg,\n\t\t\t\t BIT_RTC_CTRL_REG_RTC_GET_TIME,\n\t\t\t\t BIT_RTC_CTRL_REG_RTC_GET_TIME);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to update bits rtc_ctrl: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->ctrl_reg,\n\t\t\t\t BIT_RTC_CTRL_REG_RTC_GET_TIME,\n\t\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to update bits rtc_ctrl: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(rk808_rtc->regmap, rk808_rtc->creg->seconds_reg,\n\t\t\t       rtc_data, NUM_TIME_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bulk read rtc_data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttm->tm_sec = bcd2bin(rtc_data[0] & SECONDS_REG_MSK);\n\ttm->tm_min = bcd2bin(rtc_data[1] & MINUTES_REG_MAK);\n\ttm->tm_hour = bcd2bin(rtc_data[2] & HOURS_REG_MSK);\n\ttm->tm_mday = bcd2bin(rtc_data[3] & DAYS_REG_MSK);\n\ttm->tm_mon = (bcd2bin(rtc_data[4] & MONTHS_REG_MSK)) - 1;\n\ttm->tm_year = (bcd2bin(rtc_data[5] & YEARS_REG_MSK)) + 100;\n\ttm->tm_wday = bcd2bin(rtc_data[6] & WEEKS_REG_MSK);\n\trockchip_to_gregorian(tm);\n\tdev_dbg(dev, \"RTC date/time %ptRd(%d) %ptRt\\n\", tm, tm->tm_wday, tm);\n\n\treturn ret;\n}\n\n \nstatic int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\tu8 rtc_data[NUM_TIME_REGS];\n\tint ret;\n\n\tdev_dbg(dev, \"set RTC date/time %ptRd(%d) %ptRt\\n\", tm, tm->tm_wday, tm);\n\tgregorian_to_rockchip(tm);\n\trtc_data[0] = bin2bcd(tm->tm_sec);\n\trtc_data[1] = bin2bcd(tm->tm_min);\n\trtc_data[2] = bin2bcd(tm->tm_hour);\n\trtc_data[3] = bin2bcd(tm->tm_mday);\n\trtc_data[4] = bin2bcd(tm->tm_mon + 1);\n\trtc_data[5] = bin2bcd(tm->tm_year - 100);\n\trtc_data[6] = bin2bcd(tm->tm_wday);\n\n\t \n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->ctrl_reg,\n\t\t\t\t BIT_RTC_CTRL_REG_STOP_RTC_M,\n\t\t\t\t BIT_RTC_CTRL_REG_STOP_RTC_M);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to update RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_write(rk808_rtc->regmap, rk808_rtc->creg->seconds_reg,\n\t\t\t\trtc_data, NUM_TIME_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bull write rtc_data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->ctrl_reg,\n\t\t\t\t BIT_RTC_CTRL_REG_STOP_RTC_M, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to update RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\tu8 alrm_data[NUM_ALARM_REGS];\n\tuint32_t int_reg;\n\tint ret;\n\n\tret = regmap_bulk_read(rk808_rtc->regmap,\n\t\t\t       rk808_rtc->creg->alarm_seconds_reg,\n\t\t\t       alrm_data, NUM_ALARM_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read RTC alarm date REG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\talrm->time.tm_sec = bcd2bin(alrm_data[0] & SECONDS_REG_MSK);\n\talrm->time.tm_min = bcd2bin(alrm_data[1] & MINUTES_REG_MAK);\n\talrm->time.tm_hour = bcd2bin(alrm_data[2] & HOURS_REG_MSK);\n\talrm->time.tm_mday = bcd2bin(alrm_data[3] & DAYS_REG_MSK);\n\talrm->time.tm_mon = (bcd2bin(alrm_data[4] & MONTHS_REG_MSK)) - 1;\n\talrm->time.tm_year = (bcd2bin(alrm_data[5] & YEARS_REG_MSK)) + 100;\n\trockchip_to_gregorian(&alrm->time);\n\n\tret = regmap_read(rk808_rtc->regmap, rk808_rtc->creg->int_reg, &int_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read RTC INT REG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"alrm read RTC date/time %ptRd(%d) %ptRt\\n\",\n\t\t&alrm->time, alrm->time.tm_wday, &alrm->time);\n\n\talrm->enabled = (int_reg & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int rk808_rtc_stop_alarm(struct rk808_rtc *rk808_rtc)\n{\n\tint ret;\n\n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->int_reg,\n\t\t\t\t BIT_RTC_INTERRUPTS_REG_IT_ALARM_M, 0);\n\n\treturn ret;\n}\n\nstatic int rk808_rtc_start_alarm(struct rk808_rtc *rk808_rtc)\n{\n\tint ret;\n\n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->int_reg,\n\t\t\t\t BIT_RTC_INTERRUPTS_REG_IT_ALARM_M,\n\t\t\t\t BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);\n\n\treturn ret;\n}\n\nstatic int rk808_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\tu8 alrm_data[NUM_ALARM_REGS];\n\tint ret;\n\n\tret = rk808_rtc_stop_alarm(rk808_rtc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to stop alarm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"alrm set RTC date/time %ptRd(%d) %ptRt\\n\",\n\t\t&alrm->time, alrm->time.tm_wday, &alrm->time);\n\n\tgregorian_to_rockchip(&alrm->time);\n\talrm_data[0] = bin2bcd(alrm->time.tm_sec);\n\talrm_data[1] = bin2bcd(alrm->time.tm_min);\n\talrm_data[2] = bin2bcd(alrm->time.tm_hour);\n\talrm_data[3] = bin2bcd(alrm->time.tm_mday);\n\talrm_data[4] = bin2bcd(alrm->time.tm_mon + 1);\n\talrm_data[5] = bin2bcd(alrm->time.tm_year - 100);\n\n\tret = regmap_bulk_write(rk808_rtc->regmap,\n\t\t\t\trk808_rtc->creg->alarm_seconds_reg,\n\t\t\t\talrm_data, NUM_ALARM_REGS);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bulk write: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (alrm->enabled) {\n\t\tret = rk808_rtc_start_alarm(rk808_rtc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to start alarm: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rk808_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t      unsigned int enabled)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\treturn rk808_rtc_start_alarm(rk808_rtc);\n\n\treturn rk808_rtc_stop_alarm(rk808_rtc);\n}\n\n \nstatic irqreturn_t rk808_alarm_irq(int irq, void *data)\n{\n\tstruct rk808_rtc *rk808_rtc = data;\n\tint ret;\n\n\tret = regmap_write(rk808_rtc->regmap, rk808_rtc->creg->status_reg,\n\t\t\t   RTC_STATUS_MASK);\n\tif (ret) {\n\t\tdev_err(&rk808_rtc->rtc->dev,\n\t\t\t\"%s:Failed to update RTC status: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\trtc_update_irq(rk808_rtc->rtc, 1, RTC_IRQF | RTC_AF);\n\tdev_dbg(&rk808_rtc->rtc->dev,\n\t\t \"%s:irq=%d\\n\", __func__, irq);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops rk808_rtc_ops = {\n\t.read_time = rk808_rtc_readtime,\n\t.set_time = rk808_rtc_set_time,\n\t.read_alarm = rk808_rtc_readalarm,\n\t.set_alarm = rk808_rtc_setalarm,\n\t.alarm_irq_enable = rk808_rtc_alarm_irq_enable,\n};\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int rk808_rtc_suspend(struct device *dev)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(rk808_rtc->irq);\n\n\treturn 0;\n}\n\n \nstatic int rk808_rtc_resume(struct device *dev)\n{\n\tstruct rk808_rtc *rk808_rtc = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(rk808_rtc->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(rk808_rtc_pm_ops,\n\trk808_rtc_suspend, rk808_rtc_resume);\n\nstatic struct rk_rtc_compat_reg rk808_creg = {\n\t.ctrl_reg = RK808_RTC_CTRL_REG,\n\t.status_reg = RK808_RTC_STATUS_REG,\n\t.alarm_seconds_reg = RK808_ALARM_SECONDS_REG,\n\t.int_reg = RK808_RTC_INT_REG,\n\t.seconds_reg = RK808_SECONDS_REG,\n};\n\nstatic struct rk_rtc_compat_reg rk817_creg = {\n\t.ctrl_reg = RK817_RTC_CTRL_REG,\n\t.status_reg = RK817_RTC_STATUS_REG,\n\t.alarm_seconds_reg = RK817_ALARM_SECONDS_REG,\n\t.int_reg = RK817_RTC_INT_REG,\n\t.seconds_reg = RK817_SECONDS_REG,\n};\n\nstatic int rk808_rtc_probe(struct platform_device *pdev)\n{\n\tstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\n\tstruct rk808_rtc *rk808_rtc;\n\tint ret;\n\n\trk808_rtc = devm_kzalloc(&pdev->dev, sizeof(*rk808_rtc), GFP_KERNEL);\n\tif (rk808_rtc == NULL)\n\t\treturn -ENOMEM;\n\n\tswitch (rk808->variant) {\n\tcase RK809_ID:\n\tcase RK817_ID:\n\t\trk808_rtc->creg = &rk817_creg;\n\t\tbreak;\n\tdefault:\n\t\trk808_rtc->creg = &rk808_creg;\n\t\tbreak;\n\t}\n\tplatform_set_drvdata(pdev, rk808_rtc);\n\trk808_rtc->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!rk808_rtc->regmap)\n\t\treturn -ENODEV;\n\n\t \n\tret = regmap_update_bits(rk808_rtc->regmap, rk808_rtc->creg->ctrl_reg,\n\t\t\t\t BIT_RTC_CTRL_REG_STOP_RTC_M |\n\t\t\t\t BIT_RTC_CTRL_REG_RTC_READSEL_M,\n\t\t\t\t BIT_RTC_CTRL_REG_RTC_READSEL_M);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to update RTC control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(rk808_rtc->regmap, rk808_rtc->creg->status_reg,\n\t\t\t   RTC_STATUS_MASK);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to write RTC status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\trk808_rtc->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rk808_rtc->rtc))\n\t\treturn PTR_ERR(rk808_rtc->rtc);\n\n\trk808_rtc->rtc->ops = &rk808_rtc_ops;\n\n\trk808_rtc->irq = platform_get_irq(pdev, 0);\n\tif (rk808_rtc->irq < 0)\n\t\treturn rk808_rtc->irq;\n\n\t \n\tret = devm_request_threaded_irq(&pdev->dev, rk808_rtc->irq, NULL,\n\t\t\t\t\trk808_alarm_irq, 0,\n\t\t\t\t\t\"RTC alarm\", rk808_rtc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request alarm IRQ %d: %d\\n\",\n\t\t\trk808_rtc->irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_rtc_register_device(rk808_rtc->rtc);\n}\n\nstatic struct platform_driver rk808_rtc_driver = {\n\t.probe = rk808_rtc_probe,\n\t.driver = {\n\t\t.name = \"rk808-rtc\",\n\t\t.pm = &rk808_rtc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rk808_rtc_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for the rk808 series PMICs\");\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_AUTHOR(\"Zhang Qing <zhangqing@rock-chips.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rk808-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}