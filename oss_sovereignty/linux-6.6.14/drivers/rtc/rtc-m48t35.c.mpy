{
  "module_name": "rtc-m48t35.c",
  "hash_id": "628f4da4ee62939d23d88445f678257edc15bc42d747689c5011b0056b748887",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-m48t35.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/bcd.h>\n#include <linux/io.h>\n#include <linux/err.h>\n\nstruct m48t35_rtc {\n\tu8\tpad[0x7ff8];     \n#ifdef CONFIG_SGI_IP27\n\tu8\thour;\n\tu8\tmin;\n\tu8\tsec;\n\tu8\tcontrol;\n\tu8\tyear;\n\tu8\tmonth;\n\tu8\tdate;\n\tu8\tday;\n#else\n\tu8\tcontrol;\n\tu8\tsec;\n\tu8\tmin;\n\tu8\thour;\n\tu8\tday;\n\tu8\tdate;\n\tu8\tmonth;\n\tu8\tyear;\n#endif\n};\n\n#define M48T35_RTC_SET\t\t0x80\n#define M48T35_RTC_READ\t\t0x40\n\nstruct m48t35_priv {\n\tstruct rtc_device *rtc;\n\tstruct m48t35_rtc __iomem *reg;\n\tsize_t size;\n\tunsigned long baseaddr;\n\tspinlock_t lock;\n};\n\nstatic int m48t35_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct m48t35_priv *priv = dev_get_drvdata(dev);\n\tu8 control;\n\n\t \n\tspin_lock_irq(&priv->lock);\n\tcontrol = readb(&priv->reg->control);\n\twriteb(control | M48T35_RTC_READ, &priv->reg->control);\n\ttm->tm_sec = readb(&priv->reg->sec);\n\ttm->tm_min = readb(&priv->reg->min);\n\ttm->tm_hour = readb(&priv->reg->hour);\n\ttm->tm_mday = readb(&priv->reg->date);\n\ttm->tm_mon = readb(&priv->reg->month);\n\ttm->tm_year = readb(&priv->reg->year);\n\twriteb(control, &priv->reg->control);\n\tspin_unlock_irq(&priv->lock);\n\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon);\n\ttm->tm_year = bcd2bin(tm->tm_year);\n\n\t \n\ttm->tm_year += 70;\n\tif (tm->tm_year <= 69)\n\t\ttm->tm_year += 100;\n\n\ttm->tm_mon--;\n\treturn 0;\n}\n\nstatic int m48t35_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct m48t35_priv *priv = dev_get_drvdata(dev);\n\tunsigned char mon, day, hrs, min, sec;\n\tunsigned int yrs;\n\tu8 control;\n\n\tyrs = tm->tm_year + 1900;\n\tmon = tm->tm_mon + 1;    \n\tday = tm->tm_mday;\n\thrs = tm->tm_hour;\n\tmin = tm->tm_min;\n\tsec = tm->tm_sec;\n\n\tif (yrs < 1970)\n\t\treturn -EINVAL;\n\n\tyrs -= 1970;\n\tif (yrs > 255)     \n\t\treturn -EINVAL;\n\n\tif (yrs > 169)\n\t\treturn -EINVAL;\n\n\tif (yrs >= 100)\n\t\tyrs -= 100;\n\n\tsec = bin2bcd(sec);\n\tmin = bin2bcd(min);\n\thrs = bin2bcd(hrs);\n\tday = bin2bcd(day);\n\tmon = bin2bcd(mon);\n\tyrs = bin2bcd(yrs);\n\n\tspin_lock_irq(&priv->lock);\n\tcontrol = readb(&priv->reg->control);\n\twriteb(control | M48T35_RTC_SET, &priv->reg->control);\n\twriteb(yrs, &priv->reg->year);\n\twriteb(mon, &priv->reg->month);\n\twriteb(day, &priv->reg->date);\n\twriteb(hrs, &priv->reg->hour);\n\twriteb(min, &priv->reg->min);\n\twriteb(sec, &priv->reg->sec);\n\twriteb(control, &priv->reg->control);\n\tspin_unlock_irq(&priv->lock);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops m48t35_ops = {\n\t.read_time\t= m48t35_read_time,\n\t.set_time\t= m48t35_set_time,\n};\n\nstatic int m48t35_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct m48t35_priv *priv;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct m48t35_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->size = resource_size(res);\n\tif (!devm_request_mem_region(&pdev->dev, res->start, priv->size,\n\t\t\t\t     pdev->name))\n\t\treturn -EBUSY;\n\n\tpriv->baseaddr = res->start;\n\tpriv->reg = devm_ioremap(&pdev->dev, priv->baseaddr, priv->size);\n\tif (!priv->reg)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->rtc = devm_rtc_device_register(&pdev->dev, \"m48t35\",\n\t\t\t\t  &m48t35_ops, THIS_MODULE);\n\treturn PTR_ERR_OR_ZERO(priv->rtc);\n}\n\nstatic struct platform_driver m48t35_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-m48t35\",\n\t},\n\t.probe\t\t= m48t35_probe,\n};\n\nmodule_platform_driver(m48t35_platform_driver);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tsbogend@alpha.franken.de>\");\nMODULE_DESCRIPTION(\"M48T35 RTC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rtc-m48t35\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}