{
  "module_name": "rtc-ab-b5ze-s3.c",
  "hash_id": "ce24b28fca1273708ea0a1a3d7efb5c0bd622c30bb1cc0534a5df306012ea1bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ab-b5ze-s3.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n\n#define DRV_NAME \"rtc-ab-b5ze-s3\"\n\n \n#define ABB5ZES3_REG_CTRL1\t   0x00\t    \n#define ABB5ZES3_REG_CTRL1_CIE\t   BIT(0)   \n#define ABB5ZES3_REG_CTRL1_AIE\t   BIT(1)   \n#define ABB5ZES3_REG_CTRL1_SIE\t   BIT(2)   \n#define ABB5ZES3_REG_CTRL1_PM\t   BIT(3)   \n#define ABB5ZES3_REG_CTRL1_SR\t   BIT(4)   \n#define ABB5ZES3_REG_CTRL1_STOP\t   BIT(5)   \n#define ABB5ZES3_REG_CTRL1_CAP\t   BIT(7)\n\n#define ABB5ZES3_REG_CTRL2\t   0x01\t    \n#define ABB5ZES3_REG_CTRL2_CTBIE   BIT(0)   \n#define ABB5ZES3_REG_CTRL2_CTAIE   BIT(1)   \n#define ABB5ZES3_REG_CTRL2_WTAIE   BIT(2)   \n#define ABB5ZES3_REG_CTRL2_AF\t   BIT(3)   \n#define ABB5ZES3_REG_CTRL2_SF\t   BIT(4)   \n#define ABB5ZES3_REG_CTRL2_CTBF\t   BIT(5)   \n#define ABB5ZES3_REG_CTRL2_CTAF\t   BIT(6)   \n#define ABB5ZES3_REG_CTRL2_WTAF\t   BIT(7)   \n\n#define ABB5ZES3_REG_CTRL3\t   0x02\t    \n#define ABB5ZES3_REG_CTRL3_PM2\t   BIT(7)   \n#define ABB5ZES3_REG_CTRL3_PM1\t   BIT(6)   \n#define ABB5ZES3_REG_CTRL3_PM0\t   BIT(5)   \n#define ABB5ZES3_REG_CTRL3_BSF\t   BIT(3)   \n#define ABB5ZES3_REG_CTRL3_BLF\t   BIT(2)   \n#define ABB5ZES3_REG_CTRL3_BSIE\t   BIT(1)   \n#define ABB5ZES3_REG_CTRL3_BLIE\t   BIT(0)   \n\n#define ABB5ZES3_CTRL_SEC_LEN\t   3\n\n \n#define ABB5ZES3_REG_RTC_SC\t   0x03\t    \n#define ABB5ZES3_REG_RTC_SC_OSC\t   BIT(7)   \n#define ABB5ZES3_REG_RTC_MN\t   0x04\t    \n#define ABB5ZES3_REG_RTC_HR\t   0x05\t    \n#define ABB5ZES3_REG_RTC_HR_PM\t   BIT(5)   \n#define ABB5ZES3_REG_RTC_DT\t   0x06\t    \n#define ABB5ZES3_REG_RTC_DW\t   0x07\t    \n#define ABB5ZES3_REG_RTC_MO\t   0x08\t    \n#define ABB5ZES3_REG_RTC_YR\t   0x09\t    \n\n#define ABB5ZES3_RTC_SEC_LEN\t   7\n\n \n#define ABB5ZES3_REG_ALRM_MN\t   0x0A\t    \n#define ABB5ZES3_REG_ALRM_MN_AE\t   BIT(7)   \n#define ABB5ZES3_REG_ALRM_HR\t   0x0B\t    \n#define ABB5ZES3_REG_ALRM_HR_AE\t   BIT(7)   \n#define ABB5ZES3_REG_ALRM_DT\t   0x0C\t    \n#define ABB5ZES3_REG_ALRM_DT_AE\t   BIT(7)   \n#define ABB5ZES3_REG_ALRM_DW\t   0x0D\t    \n#define ABB5ZES3_REG_ALRM_DW_AE\t   BIT(7)   \n\n#define ABB5ZES3_ALRM_SEC_LEN\t   4\n\n \n#define ABB5ZES3_REG_FREQ_OF\t   0x0E\t    \n#define ABB5ZES3_REG_FREQ_OF_MODE  0x0E\t    \n\n \n#define ABB5ZES3_REG_TIM_CLK\t   0x0F\t    \n#define ABB5ZES3_REG_TIM_CLK_TAM   BIT(7)   \n#define ABB5ZES3_REG_TIM_CLK_TBM   BIT(6)   \n#define ABB5ZES3_REG_TIM_CLK_COF2  BIT(5)   \n#define ABB5ZES3_REG_TIM_CLK_COF1  BIT(4)   \n#define ABB5ZES3_REG_TIM_CLK_COF0  BIT(3)   \n#define ABB5ZES3_REG_TIM_CLK_TAC1  BIT(2)   \n#define ABB5ZES3_REG_TIM_CLK_TAC0  BIT(1)   \n#define ABB5ZES3_REG_TIM_CLK_TBC   BIT(0)   \n\n \n#define ABB5ZES3_REG_TIMA_CLK\t   0x10\t    \n#define ABB5ZES3_REG_TIMA_CLK_TAQ2 BIT(2)   \n#define ABB5ZES3_REG_TIMA_CLK_TAQ1 BIT(1)   \n#define ABB5ZES3_REG_TIMA_CLK_TAQ0 BIT(0)   \n#define ABB5ZES3_REG_TIMA\t   0x11\t    \n\n#define ABB5ZES3_TIMA_SEC_LEN\t   2\n\n \n#define ABB5ZES3_REG_TIMB_CLK\t   0x12\t    \n#define ABB5ZES3_REG_TIMB_CLK_TBW2 BIT(6)\n#define ABB5ZES3_REG_TIMB_CLK_TBW1 BIT(5)\n#define ABB5ZES3_REG_TIMB_CLK_TBW0 BIT(4)\n#define ABB5ZES3_REG_TIMB_CLK_TAQ2 BIT(2)\n#define ABB5ZES3_REG_TIMB_CLK_TAQ1 BIT(1)\n#define ABB5ZES3_REG_TIMB_CLK_TAQ0 BIT(0)\n#define ABB5ZES3_REG_TIMB\t   0x13\t    \n#define ABB5ZES3_TIMB_SEC_LEN\t   2\n\n#define ABB5ZES3_MEM_MAP_LEN\t   0x14\n\nstruct abb5zes3_rtc_data {\n\tstruct rtc_device *rtc;\n\tstruct regmap *regmap;\n\n\tint irq;\n\n\tbool battery_low;\n\tbool timer_alarm;  \n};\n\n \nstatic int abb5zes3_i2c_validate_chip(struct regmap *regmap)\n{\n\tu8 regs[ABB5ZES3_MEM_MAP_LEN];\n\tstatic const u8 mask[ABB5ZES3_MEM_MAP_LEN] = { 0x00, 0x00, 0x10, 0x00,\n\t\t\t\t\t\t       0x80, 0xc0, 0xc0, 0xf8,\n\t\t\t\t\t\t       0xe0, 0x00, 0x00, 0x40,\n\t\t\t\t\t\t       0x40, 0x78, 0x00, 0x00,\n\t\t\t\t\t\t       0xf8, 0x00, 0x88, 0x00 };\n\tint ret, i;\n\n\tret = regmap_bulk_read(regmap, 0, regs, ABB5ZES3_MEM_MAP_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ABB5ZES3_MEM_MAP_LEN; ++i) {\n\t\tif (regs[i] & mask[i])  \n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int _abb5zes3_rtc_clear_alarm(struct device *dev)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL2,\n\t\t\t\t ABB5ZES3_REG_CTRL2_AF, 0);\n\tif (ret)\n\t\tdev_err(dev, \"%s: clearing alarm failed (%d)\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int _abb5zes3_rtc_update_alarm(struct device *dev, bool enable)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL1,\n\t\t\t\t ABB5ZES3_REG_CTRL1_AIE,\n\t\t\t\t enable ? ABB5ZES3_REG_CTRL1_AIE : 0);\n\tif (ret)\n\t\tdev_err(dev, \"%s: writing alarm INT failed (%d)\\n\",\n\t\t\t__func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int _abb5zes3_rtc_update_timer(struct device *dev, bool enable)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL2,\n\t\t\t\t ABB5ZES3_REG_CTRL2_WTAIE,\n\t\t\t\t enable ? ABB5ZES3_REG_CTRL2_WTAIE : 0);\n\tif (ret)\n\t\tdev_err(dev, \"%s: writing timer INT failed (%d)\\n\",\n\t\t\t__func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int _abb5zes3_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tu8 regs[ABB5ZES3_REG_RTC_SC + ABB5ZES3_RTC_SEC_LEN];\n\tint ret = 0;\n\n\t \n\tret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_CTRL1, regs,\n\t\t\t       sizeof(regs));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: reading RTC time failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (regs[ABB5ZES3_REG_RTC_SC] & ABB5ZES3_REG_RTC_SC_OSC)\n\t\treturn -ENODATA;\n\n\ttm->tm_sec = bcd2bin(regs[ABB5ZES3_REG_RTC_SC] & 0x7F);\n\ttm->tm_min = bcd2bin(regs[ABB5ZES3_REG_RTC_MN]);\n\n\tif (regs[ABB5ZES3_REG_CTRL1] & ABB5ZES3_REG_CTRL1_PM) {  \n\t\ttm->tm_hour = bcd2bin(regs[ABB5ZES3_REG_RTC_HR] & 0x1f);\n\t\tif (regs[ABB5ZES3_REG_RTC_HR] & ABB5ZES3_REG_RTC_HR_PM)  \n\t\t\ttm->tm_hour += 12;\n\t} else {\t\t\t\t\t\t \n\t\ttm->tm_hour = bcd2bin(regs[ABB5ZES3_REG_RTC_HR]);\n\t}\n\n\ttm->tm_mday = bcd2bin(regs[ABB5ZES3_REG_RTC_DT]);\n\ttm->tm_wday = bcd2bin(regs[ABB5ZES3_REG_RTC_DW]);\n\ttm->tm_mon  = bcd2bin(regs[ABB5ZES3_REG_RTC_MO]) - 1;  \n\ttm->tm_year = bcd2bin(regs[ABB5ZES3_REG_RTC_YR]) + 100;\n\n\treturn ret;\n}\n\nstatic int abb5zes3_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tu8 regs[ABB5ZES3_REG_RTC_SC + ABB5ZES3_RTC_SEC_LEN];\n\tint ret;\n\n\tregs[ABB5ZES3_REG_RTC_SC] = bin2bcd(tm->tm_sec);  \n\tregs[ABB5ZES3_REG_RTC_MN] = bin2bcd(tm->tm_min);\n\tregs[ABB5ZES3_REG_RTC_HR] = bin2bcd(tm->tm_hour);  \n\tregs[ABB5ZES3_REG_RTC_DT] = bin2bcd(tm->tm_mday);\n\tregs[ABB5ZES3_REG_RTC_DW] = bin2bcd(tm->tm_wday);\n\tregs[ABB5ZES3_REG_RTC_MO] = bin2bcd(tm->tm_mon + 1);\n\tregs[ABB5ZES3_REG_RTC_YR] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_RTC_SC,\n\t\t\t\tregs + ABB5ZES3_REG_RTC_SC,\n\t\t\t\tABB5ZES3_RTC_SEC_LEN);\n\n\treturn ret;\n}\n\n \nstatic inline void sec_to_timer_a(u8 secs, u8 *taq, u8 *timer_a)\n{\n\t*taq = ABB5ZES3_REG_TIMA_CLK_TAQ1;  \n\t*timer_a = secs;\n}\n\n \nstatic inline int sec_from_timer_a(u8 *secs, u8 taq, u8 timer_a)\n{\n\tif (taq != ABB5ZES3_REG_TIMA_CLK_TAQ1)  \n\t\treturn -EINVAL;\n\n\t*secs = timer_a;\n\n\treturn 0;\n}\n\n \nstatic int _abb5zes3_rtc_read_timer(struct device *dev,\n\t\t\t\t    struct rtc_wkalrm *alarm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tstruct rtc_time rtc_tm, *alarm_tm = &alarm->time;\n\tu8 regs[ABB5ZES3_TIMA_SEC_LEN + 1];\n\tunsigned long rtc_secs;\n\tunsigned int reg;\n\tu8 timer_secs;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_TIM_CLK, regs,\n\t\t\t       ABB5ZES3_TIMA_SEC_LEN + 1);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: reading Timer A section failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trtc_secs = rtc_tm_to_time64(&rtc_tm);\n\n\t \n\tret = sec_from_timer_a(&timer_secs, regs[1], regs[2]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trtc_time64_to_tm(rtc_secs + timer_secs, alarm_tm);\n\n\tret = regmap_read(data->regmap, ABB5ZES3_REG_CTRL2, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: reading ctrl reg failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\talarm->enabled = !!(reg & ABB5ZES3_REG_CTRL2_WTAIE);\n\n\treturn 0;\n}\n\n \nstatic int _abb5zes3_rtc_read_alarm(struct device *dev,\n\t\t\t\t    struct rtc_wkalrm *alarm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tstruct rtc_time rtc_tm, *alarm_tm = &alarm->time;\n\tunsigned long rtc_secs, alarm_secs;\n\tu8 regs[ABB5ZES3_ALRM_SEC_LEN];\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_ALRM_MN, regs,\n\t\t\t       ABB5ZES3_ALRM_SEC_LEN);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: reading alarm section failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\talarm_tm->tm_sec  = 0;\n\talarm_tm->tm_min  = bcd2bin(regs[0] & 0x7f);\n\talarm_tm->tm_hour = bcd2bin(regs[1] & 0x3f);\n\talarm_tm->tm_mday = bcd2bin(regs[2] & 0x3f);\n\talarm_tm->tm_wday = -1;\n\n\t \n\tret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\n\tif (ret)\n\t\treturn ret;\n\n\talarm_tm->tm_year = rtc_tm.tm_year;\n\talarm_tm->tm_mon = rtc_tm.tm_mon;\n\n\trtc_secs = rtc_tm_to_time64(&rtc_tm);\n\talarm_secs = rtc_tm_to_time64(alarm_tm);\n\n\tif (alarm_secs < rtc_secs) {\n\t\tif (alarm_tm->tm_mon == 11) {\n\t\t\talarm_tm->tm_mon = 0;\n\t\t\talarm_tm->tm_year += 1;\n\t\t} else {\n\t\t\talarm_tm->tm_mon += 1;\n\t\t}\n\t}\n\n\tret = regmap_read(data->regmap, ABB5ZES3_REG_CTRL1, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: reading ctrl reg failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\talarm->enabled = !!(reg & ABB5ZES3_REG_CTRL1_AIE);\n\n\treturn 0;\n}\n\n \nstatic int abb5zes3_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (data->timer_alarm)\n\t\tret = _abb5zes3_rtc_read_timer(dev, alarm);\n\telse\n\t\tret = _abb5zes3_rtc_read_alarm(dev, alarm);\n\n\treturn ret;\n}\n\n \nstatic int _abb5zes3_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tstruct rtc_time *alarm_tm = &alarm->time;\n\tu8 regs[ABB5ZES3_ALRM_SEC_LEN];\n\tstruct rtc_time rtc_tm;\n\tint ret, enable = 1;\n\n\tif (!alarm->enabled) {\n\t\tenable = 0;\n\t} else {\n\t\tunsigned long rtc_secs, alarm_secs;\n\n\t\t \n\t\tret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rtc_tm.tm_mon == 11) {  \n\t\t\trtc_tm.tm_mon = 0;\n\t\t\trtc_tm.tm_year += 1;\n\t\t} else {\n\t\t\trtc_tm.tm_mon += 1;\n\t\t}\n\n\t\trtc_secs = rtc_tm_to_time64(&rtc_tm);\n\t\talarm_secs = rtc_tm_to_time64(alarm_tm);\n\n\t\tif (alarm_secs > rtc_secs) {\n\t\t\tdev_err(dev, \"%s: alarm maximum is one month in the future (%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tregs[0] = bin2bcd(alarm_tm->tm_min) & 0x7f;\n\tregs[1] = bin2bcd(alarm_tm->tm_hour) & 0x3f;\n\tregs[2] = bin2bcd(alarm_tm->tm_mday) & 0x3f;\n\tregs[3] = ABB5ZES3_REG_ALRM_DW_AE;  \n\n\tret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_ALRM_MN, regs,\n\t\t\t\tABB5ZES3_ALRM_SEC_LEN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: writing ALARM section failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdata->timer_alarm = 0;\n\n\t \n\treturn _abb5zes3_rtc_update_alarm(dev, enable);\n}\n\n \nstatic int _abb5zes3_rtc_set_timer(struct device *dev, struct rtc_wkalrm *alarm,\n\t\t\t\t   u8 secs)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tu8 regs[ABB5ZES3_TIMA_SEC_LEN];\n\tu8 mask = ABB5ZES3_REG_TIM_CLK_TAC0 | ABB5ZES3_REG_TIM_CLK_TAC1;\n\tint ret = 0;\n\n\t \n\tsec_to_timer_a(secs, &regs[0], &regs[1]);\n\tret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_TIMA_CLK, regs,\n\t\t\t\tABB5ZES3_TIMA_SEC_LEN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: writing timer section failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, ABB5ZES3_REG_TIM_CLK,\n\t\t\t\t mask, ABB5ZES3_REG_TIM_CLK_TAC1);\n\tif (ret)\n\t\tdev_err(dev, \"%s: failed to update timer\\n\", __func__);\n\n\t \n\tdata->timer_alarm = 1;\n\n\t \n\treturn _abb5zes3_rtc_update_timer(dev, alarm->enabled);\n}\n\n \nstatic int abb5zes3_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tstruct rtc_time *alarm_tm = &alarm->time;\n\tunsigned long rtc_secs, alarm_secs;\n\tstruct rtc_time rtc_tm;\n\tint ret;\n\n\tret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\n\tif (ret)\n\t\treturn ret;\n\n\trtc_secs = rtc_tm_to_time64(&rtc_tm);\n\talarm_secs = rtc_tm_to_time64(alarm_tm);\n\n\t \n\tret = _abb5zes3_rtc_update_alarm(dev, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to disable alarm (%d)\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tret = _abb5zes3_rtc_update_timer(dev, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to disable timer (%d)\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdata->timer_alarm = 0;\n\n\t \n\tif ((alarm_secs > rtc_secs) && ((alarm_secs - rtc_secs) <= 240))\n\t\tret = _abb5zes3_rtc_set_timer(dev, alarm,\n\t\t\t\t\t      alarm_secs - rtc_secs);\n\telse\n\t\tret = _abb5zes3_rtc_set_alarm(dev, alarm);\n\n\tif (ret)\n\t\tdev_err(dev, \"%s: unable to configure alarm (%d)\\n\", __func__,\n\t\t\tret);\n\n\treturn ret;\n}\n\n \nstatic inline int _abb5zes3_rtc_battery_low_irq_enable(struct regmap *regmap,\n\t\t\t\t\t\t       bool enable)\n{\n\treturn regmap_update_bits(regmap, ABB5ZES3_REG_CTRL3,\n\t\t\t\t  ABB5ZES3_REG_CTRL3_BLIE,\n\t\t\t\t  enable ? ABB5ZES3_REG_CTRL3_BLIE : 0);\n}\n\n \nstatic int abb5zes3_rtc_check_setup(struct device *dev)\n{\n\tstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int reg;\n\tint ret;\n\tu8 mask;\n\n\t \n\tmask = (ABB5ZES3_REG_TIM_CLK_TBC | ABB5ZES3_REG_TIM_CLK_TAC0 |\n\t\tABB5ZES3_REG_TIM_CLK_TAC1 | ABB5ZES3_REG_TIM_CLK_COF0 |\n\t\tABB5ZES3_REG_TIM_CLK_COF1 | ABB5ZES3_REG_TIM_CLK_COF2 |\n\t\tABB5ZES3_REG_TIM_CLK_TBM | ABB5ZES3_REG_TIM_CLK_TAM);\n\tret = regmap_update_bits(regmap, ABB5ZES3_REG_TIM_CLK, mask,\n\t\t\t\t ABB5ZES3_REG_TIM_CLK_COF0 |\n\t\t\t\t ABB5ZES3_REG_TIM_CLK_COF1 |\n\t\t\t\t ABB5ZES3_REG_TIM_CLK_COF2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to initialize clkout register (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmask = (ABB5ZES3_REG_ALRM_MN_AE | ABB5ZES3_REG_ALRM_HR_AE |\n\t\tABB5ZES3_REG_ALRM_DT_AE | ABB5ZES3_REG_ALRM_DW_AE);\n\tret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL2, mask, mask);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to disable alarm setting (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmask = (ABB5ZES3_REG_CTRL1_CIE | ABB5ZES3_REG_CTRL1_AIE |\n\t\tABB5ZES3_REG_CTRL1_SIE | ABB5ZES3_REG_CTRL1_PM |\n\t\tABB5ZES3_REG_CTRL1_CAP | ABB5ZES3_REG_CTRL1_STOP);\n\tret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL1, mask, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to initialize CTRL1 register (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmask = (ABB5ZES3_REG_CTRL2_CTBIE | ABB5ZES3_REG_CTRL2_CTAIE |\n\t\tABB5ZES3_REG_CTRL2_WTAIE | ABB5ZES3_REG_CTRL2_AF |\n\t\tABB5ZES3_REG_CTRL2_SF | ABB5ZES3_REG_CTRL2_CTBF |\n\t\tABB5ZES3_REG_CTRL2_CTAF);\n\tret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL2, mask, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to initialize CTRL2 register (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmask = (ABB5ZES3_REG_CTRL3_PM0  | ABB5ZES3_REG_CTRL3_PM1 |\n\t\tABB5ZES3_REG_CTRL3_PM2  | ABB5ZES3_REG_CTRL3_BLIE |\n\t\tABB5ZES3_REG_CTRL3_BSIE | ABB5ZES3_REG_CTRL3_BSF);\n\tret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL3, mask, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to initialize CTRL3 register (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(regmap, ABB5ZES3_REG_RTC_SC, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to read osc. integrity flag (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tif (reg & ABB5ZES3_REG_RTC_SC_OSC) {\n\t\tdev_err(dev, \"clock integrity not guaranteed. Osc. has stopped or has been interrupted.\\n\");\n\t\tdev_err(dev, \"change battery (if not already done) and then set time to reset osc. failure flag.\\n\");\n\t}\n\n\t \n\tret = regmap_read(regmap, ABB5ZES3_REG_CTRL3, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to read battery low flag (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tdata->battery_low = reg & ABB5ZES3_REG_CTRL3_BLF;\n\tif (data->battery_low) {\n\t\tdev_err(dev, \"RTC battery is low; please, consider changing it!\\n\");\n\n\t\tret = _abb5zes3_rtc_battery_low_irq_enable(regmap, false);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"%s: disabling battery low interrupt generation failed (%d)\\n\",\n\t\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int abb5zes3_rtc_alarm_irq_enable(struct device *dev,\n\t\t\t\t\t unsigned int enable)\n{\n\tstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (rtc_data->irq) {\n\t\tif (rtc_data->timer_alarm)\n\t\t\tret = _abb5zes3_rtc_update_timer(dev, enable);\n\t\telse\n\t\t\tret = _abb5zes3_rtc_update_alarm(dev, enable);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t _abb5zes3_rtc_interrupt(int irq, void *data)\n{\n\tstruct i2c_client *client = data;\n\tstruct device *dev = &client->dev;\n\tstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\n\tstruct rtc_device *rtc = rtc_data->rtc;\n\tu8 regs[ABB5ZES3_CTRL_SEC_LEN];\n\tint ret, handled = IRQ_NONE;\n\n\tret = regmap_bulk_read(rtc_data->regmap, 0, regs,\n\t\t\t       ABB5ZES3_CTRL_SEC_LEN);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: unable to read control section (%d)!\\n\",\n\t\t\t__func__, ret);\n\t\treturn handled;\n\t}\n\n\t \n\tif (regs[ABB5ZES3_REG_CTRL3] & ABB5ZES3_REG_CTRL3_BLF) {\n\t\tdev_err(dev, \"RTC battery is low; please change it!\\n\");\n\n\t\t_abb5zes3_rtc_battery_low_irq_enable(rtc_data->regmap, false);\n\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\t \n\tif (regs[ABB5ZES3_REG_CTRL2] & ABB5ZES3_REG_CTRL2_AF) {\n\t\tdev_dbg(dev, \"RTC alarm!\\n\");\n\n\t\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\n\n\t\t \n\t\t_abb5zes3_rtc_clear_alarm(dev);\n\t\t_abb5zes3_rtc_update_alarm(dev, 0);\n\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\t \n\tif (regs[ABB5ZES3_REG_CTRL2] & ABB5ZES3_REG_CTRL2_WTAF) {\n\t\tdev_dbg(dev, \"RTC timer!\\n\");\n\n\t\trtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\n\n\t\t \n\t\t_abb5zes3_rtc_update_timer(dev, 0);\n\n\t\trtc_data->timer_alarm = 0;\n\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\treturn handled;\n}\n\nstatic const struct rtc_class_ops rtc_ops = {\n\t.read_time = _abb5zes3_rtc_read_time,\n\t.set_time = abb5zes3_rtc_set_time,\n\t.read_alarm = abb5zes3_rtc_read_alarm,\n\t.set_alarm = abb5zes3_rtc_set_alarm,\n\t.alarm_irq_enable = abb5zes3_rtc_alarm_irq_enable,\n};\n\nstatic const struct regmap_config abb5zes3_rtc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int abb5zes3_probe(struct i2c_client *client)\n{\n\tstruct abb5zes3_rtc_data *data = NULL;\n\tstruct device *dev = &client->dev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tregmap = devm_regmap_init_i2c(client, &abb5zes3_rtc_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"%s: regmap allocation failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = abb5zes3_i2c_validate_chip(regmap);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\tdev_set_drvdata(dev, data);\n\n\tret = abb5zes3_rtc_check_setup(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->rtc = devm_rtc_allocate_device(dev);\n\tret = PTR_ERR_OR_ZERO(data->rtc);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: unable to allocate RTC device (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\t_abb5zes3_rtc_interrupt,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\tDRV_NAME, client);\n\t\tif (!ret) {\n\t\t\tdevice_init_wakeup(dev, true);\n\t\t\tdata->irq = client->irq;\n\t\t\tdev_dbg(dev, \"%s: irq %d used by RTC\\n\", __func__,\n\t\t\t\tclient->irq);\n\t\t} else {\n\t\t\tdev_err(dev, \"%s: irq %d unavailable (%d)\\n\",\n\t\t\t\t__func__, client->irq, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdata->rtc->ops = &rtc_ops;\n\tdata->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tdata->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\n\t \n\tif (!data->battery_low && data->irq) {\n\t\tret = _abb5zes3_rtc_battery_low_irq_enable(regmap, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: enabling battery low interrupt generation failed (%d)\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = devm_rtc_register_device(data->rtc);\n\nerr:\n\tif (ret && data->irq)\n\t\tdevice_init_wakeup(dev, false);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int abb5zes3_rtc_suspend(struct device *dev)\n{\n\tstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn enable_irq_wake(rtc_data->irq);\n\n\treturn 0;\n}\n\nstatic int abb5zes3_rtc_resume(struct device *dev)\n{\n\tstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn disable_irq_wake(rtc_data->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(abb5zes3_rtc_pm_ops, abb5zes3_rtc_suspend,\n\t\t\t abb5zes3_rtc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id abb5zes3_dt_match[] = {\n\t{ .compatible = \"abracon,abb5zes3\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, abb5zes3_dt_match);\n#endif\n\nstatic const struct i2c_device_id abb5zes3_id[] = {\n\t{ \"abb5zes3\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, abb5zes3_id);\n\nstatic struct i2c_driver abb5zes3_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &abb5zes3_rtc_pm_ops,\n\t\t.of_match_table = of_match_ptr(abb5zes3_dt_match),\n\t},\n\t.probe = abb5zes3_probe,\n\t.id_table = abb5zes3_id,\n};\nmodule_i2c_driver(abb5zes3_driver);\n\nMODULE_AUTHOR(\"Arnaud EBALARD <arno@natisbad.org>\");\nMODULE_DESCRIPTION(\"Abracon AB-RTCMC-32.768kHz-B5ZE-S3 RTC/Alarm driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}