{
  "module_name": "rtc-pcf8583.c",
  "hash_id": "d281bc3ad4f3332587a35722225bf681d434153d6e7f043b3dc6f43c14d4420b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf8583.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/bcd.h>\n\nstruct rtc_mem {\n\tunsigned int\tloc;\n\tunsigned int\tnr;\n\tunsigned char\t*data;\n};\n\nstruct pcf8583 {\n\tstruct rtc_device *rtc;\n\tunsigned char ctrl;\n};\n\n#define CTRL_STOP\t0x80\n#define CTRL_HOLD\t0x40\n#define CTRL_32KHZ\t0x00\n#define CTRL_MASK\t0x08\n#define CTRL_ALARMEN\t0x04\n#define CTRL_ALARM\t0x02\n#define CTRL_TIMER\t0x01\n\n\nstatic struct i2c_driver pcf8583_driver;\n\n#define get_ctrl(x)    ((struct pcf8583 *)i2c_get_clientdata(x))->ctrl\n#define set_ctrl(x, v) get_ctrl(x) = v\n\n#define CMOS_YEAR\t(64 + 128)\n#define CMOS_CHECKSUM\t(63)\n\nstatic int pcf8583_get_datetime(struct i2c_client *client, struct rtc_time *dt)\n{\n\tunsigned char buf[8], addr[1] = { 1 };\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = addr,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 6,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret == 2) {\n\t\tdt->tm_year = buf[4] >> 6;\n\t\tdt->tm_wday = buf[5] >> 5;\n\n\t\tbuf[4] &= 0x3f;\n\t\tbuf[5] &= 0x1f;\n\n\t\tdt->tm_sec = bcd2bin(buf[1]);\n\t\tdt->tm_min = bcd2bin(buf[2]);\n\t\tdt->tm_hour = bcd2bin(buf[3]);\n\t\tdt->tm_mday = bcd2bin(buf[4]);\n\t\tdt->tm_mon = bcd2bin(buf[5]) - 1;\n\t}\n\n\treturn ret == 2 ? 0 : -EIO;\n}\n\nstatic int pcf8583_set_datetime(struct i2c_client *client, struct rtc_time *dt, int datetoo)\n{\n\tunsigned char buf[8];\n\tint ret, len = 6;\n\n\tbuf[0] = 0;\n\tbuf[1] = get_ctrl(client) | 0x80;\n\tbuf[2] = 0;\n\tbuf[3] = bin2bcd(dt->tm_sec);\n\tbuf[4] = bin2bcd(dt->tm_min);\n\tbuf[5] = bin2bcd(dt->tm_hour);\n\n\tif (datetoo) {\n\t\tlen = 8;\n\t\tbuf[6] = bin2bcd(dt->tm_mday) | (dt->tm_year << 6);\n\t\tbuf[7] = bin2bcd(dt->tm_mon + 1)  | (dt->tm_wday << 5);\n\t}\n\n\tret = i2c_master_send(client, (char *)buf, len);\n\tif (ret != len)\n\t\treturn -EIO;\n\n\tbuf[1] = get_ctrl(client);\n\tret = i2c_master_send(client, (char *)buf, 2);\n\n\treturn ret == 2 ? 0 : -EIO;\n}\n\nstatic int pcf8583_get_ctrl(struct i2c_client *client, unsigned char *ctrl)\n{\n\t*ctrl = get_ctrl(client);\n\treturn 0;\n}\n\nstatic int pcf8583_set_ctrl(struct i2c_client *client, unsigned char *ctrl)\n{\n\tunsigned char buf[2];\n\n\tbuf[0] = 0;\n\tbuf[1] = *ctrl;\n\tset_ctrl(client, *ctrl);\n\n\treturn i2c_master_send(client, (char *)buf, 2);\n}\n\nstatic int pcf8583_read_mem(struct i2c_client *client, struct rtc_mem *mem)\n{\n\tunsigned char addr[1];\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = addr,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = mem->nr,\n\t\t\t.buf = mem->data,\n\t\t}\n\t};\n\n\tif (mem->loc < 8)\n\t\treturn -EINVAL;\n\n\taddr[0] = mem->loc;\n\n\treturn i2c_transfer(client->adapter, msgs, 2) == 2 ? 0 : -EIO;\n}\n\nstatic int pcf8583_write_mem(struct i2c_client *client, struct rtc_mem *mem)\n{\n\tunsigned char buf[9];\n\tint ret;\n\n\tif (mem->loc < 8 || mem->nr > 8)\n\t\treturn -EINVAL;\n\n\tbuf[0] = mem->loc;\n\tmemcpy(buf + 1, mem->data, mem->nr);\n\n\tret = i2c_master_send(client, buf, mem->nr + 1);\n\treturn ret == mem->nr + 1 ? 0 : -EIO;\n}\n\nstatic int pcf8583_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char ctrl, year[2];\n\tstruct rtc_mem mem = {\n\t\t.loc = CMOS_YEAR,\n\t\t.nr = sizeof(year),\n\t\t.data = year\n\t};\n\tint real_year, year_offset, err;\n\n\t \n\tpcf8583_get_ctrl(client, &ctrl);\n\tif (ctrl & (CTRL_STOP | CTRL_HOLD)) {\n\t\tunsigned char new_ctrl = ctrl & ~(CTRL_STOP | CTRL_HOLD);\n\n\t\tdev_warn(dev, \"resetting control %02x -> %02x\\n\",\n\t\t\tctrl, new_ctrl);\n\n\t\terr = pcf8583_set_ctrl(client, &new_ctrl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (pcf8583_get_datetime(client, tm) ||\n\t    pcf8583_read_mem(client, &mem))\n\t\treturn -EIO;\n\n\treal_year = year[0];\n\n\t \n\tyear_offset = tm->tm_year - (real_year & 3);\n\tif (year_offset < 0)\n\t\t \n\t\tyear_offset += 4;\n\n\ttm->tm_year = (real_year + year_offset + year[1] * 100) - 1900;\n\n\treturn 0;\n}\n\nstatic int pcf8583_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char year[2], chk;\n\tstruct rtc_mem cmos_year  = {\n\t\t.loc = CMOS_YEAR,\n\t\t.nr = sizeof(year),\n\t\t.data = year\n\t};\n\tstruct rtc_mem cmos_check = {\n\t\t.loc = CMOS_CHECKSUM,\n\t\t.nr = 1,\n\t\t.data = &chk\n\t};\n\tunsigned int proper_year = tm->tm_year + 1900;\n\tint ret;\n\n\t \n\n\tret = pcf8583_set_datetime(client, tm, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcf8583_read_mem(client, &cmos_check);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcf8583_read_mem(client, &cmos_year);\n\tif (ret)\n\t\treturn ret;\n\n\tchk -= year[1] + year[0];\n\n\tyear[1] = proper_year / 100;\n\tyear[0] = proper_year % 100;\n\n\tchk += year[1] + year[0];\n\n\tret = pcf8583_write_mem(client, &cmos_year);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcf8583_write_mem(client, &cmos_check);\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops pcf8583_rtc_ops = {\n\t.read_time\t= pcf8583_rtc_read_time,\n\t.set_time\t= pcf8583_rtc_set_time,\n};\n\nstatic int pcf8583_probe(struct i2c_client *client)\n{\n\tstruct pcf8583 *pcf8583;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tpcf8583 = devm_kzalloc(&client->dev, sizeof(struct pcf8583),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcf8583)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, pcf8583);\n\n\tpcf8583->rtc = devm_rtc_device_register(&client->dev,\n\t\t\t\tpcf8583_driver.driver.name,\n\t\t\t\t&pcf8583_rtc_ops, THIS_MODULE);\n\n\treturn PTR_ERR_OR_ZERO(pcf8583->rtc);\n}\n\nstatic const struct i2c_device_id pcf8583_id[] = {\n\t{ \"pcf8583\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf8583_id);\n\nstatic struct i2c_driver pcf8583_driver = {\n\t.driver = {\n\t\t.name\t= \"pcf8583\",\n\t},\n\t.probe\t\t= pcf8583_probe,\n\t.id_table\t= pcf8583_id,\n};\n\nmodule_i2c_driver(pcf8583_driver);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"PCF8583 I2C RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}