{
  "module_name": "rtc-pcf2123.c",
  "hash_id": "97d456c7b76714ed08ec9b0163f8e5feefb35a13932d7877f13e135fd77d3e8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf2123.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/spi/spi.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n \n#define PCF2123_REG_CTRL1\t(0x00)\t \n#define PCF2123_REG_CTRL2\t(0x01)\t \n#define PCF2123_REG_SC\t\t(0x02)\t \n#define PCF2123_REG_MN\t\t(0x03)\n#define PCF2123_REG_HR\t\t(0x04)\n#define PCF2123_REG_DM\t\t(0x05)\n#define PCF2123_REG_DW\t\t(0x06)\n#define PCF2123_REG_MO\t\t(0x07)\n#define PCF2123_REG_YR\t\t(0x08)\n#define PCF2123_REG_ALRM_MN\t(0x09)\t \n#define PCF2123_REG_ALRM_HR\t(0x0a)\n#define PCF2123_REG_ALRM_DM\t(0x0b)\n#define PCF2123_REG_ALRM_DW\t(0x0c)\n#define PCF2123_REG_OFFSET\t(0x0d)\t \n#define PCF2123_REG_TMR_CLKOUT\t(0x0e)\t \n#define PCF2123_REG_CTDWN_TMR\t(0x0f)\n\n \n#define CTRL1_CLEAR\t\t(0)\t \n#define CTRL1_CORR_INT\t\tBIT(1)\t \n#define CTRL1_12_HOUR\t\tBIT(2)\t \n#define CTRL1_SW_RESET\t(BIT(3) | BIT(4) | BIT(6))\t \n#define CTRL1_STOP\t\tBIT(5)\t \n#define CTRL1_EXT_TEST\t\tBIT(7)\t \n\n \n#define CTRL2_TIE\t\tBIT(0)\t \n#define CTRL2_AIE\t\tBIT(1)\t \n#define CTRL2_TF\t\tBIT(2)\t \n#define CTRL2_AF\t\tBIT(3)\t \n#define CTRL2_TI_TP\t\tBIT(4)\t \n#define CTRL2_MSF\t\tBIT(5)\t \n#define CTRL2_SI\t\tBIT(6)\t \n#define CTRL2_MI\t\tBIT(7)\t \n\n \n#define OSC_HAS_STOPPED\t\tBIT(7)\t \n\n \n#define ALRM_DISABLE\t\tBIT(7)\t \n\n \n#define CD_TMR_4096KHZ\t\t(0)\t \n#define CD_TMR_64HZ\t\t(1)\t \n#define CD_TMR_1HZ\t\t(2)\t \n#define CD_TMR_60th_HZ\t\t(3)\t \n#define CD_TMR_TE\t\tBIT(3)\t \n\n \n#define OFFSET_SIGN_BIT\t\t6\t \n#define OFFSET_COARSE\t\tBIT(7)\t \n#define OFFSET_STEP\t\t(2170)\t \n#define OFFSET_MASK\t\tGENMASK(6, 0)\t \n\n \n#define PCF2123_WRITE\t\tBIT(4)\n#define PCF2123_READ\t\t(BIT(4) | BIT(7))\n\n\nstatic struct spi_driver pcf2123_driver;\n\nstruct pcf2123_data {\n\tstruct rtc_device *rtc;\n\tstruct regmap *map;\n};\n\nstatic const struct regmap_config pcf2123_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.read_flag_mask = PCF2123_READ,\n\t.write_flag_mask = PCF2123_WRITE,\n\t.max_register = PCF2123_REG_CTDWN_TMR,\n};\n\nstatic int pcf2123_read_offset(struct device *dev, long *offset)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tint ret, val;\n\tunsigned int reg;\n\n\tret = regmap_read(pcf2123->map, PCF2123_REG_OFFSET, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval = sign_extend32((reg & OFFSET_MASK), OFFSET_SIGN_BIT);\n\n\tif (reg & OFFSET_COARSE)\n\t\tval *= 2;\n\n\t*offset = ((long)val) * OFFSET_STEP;\n\n\treturn 0;\n}\n\n \nstatic int pcf2123_set_offset(struct device *dev, long offset)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\ts8 reg;\n\n\tif (offset > OFFSET_STEP * 127)\n\t\treg = 127;\n\telse if (offset < OFFSET_STEP * -128)\n\t\treg = -128;\n\telse\n\t\treg = DIV_ROUND_CLOSEST(offset, OFFSET_STEP);\n\n\t \n\tif (reg & 1 && reg <= 63 && reg >= -64) {\n\t\t \n\t\treg &= ~OFFSET_COARSE;\n\t} else {\n\t\t \n\t\treg >>= 1;\n\t\treg |= OFFSET_COARSE;\n\t}\n\n\treturn regmap_write(pcf2123->map, PCF2123_REG_OFFSET, (unsigned int)reg);\n}\n\nstatic int pcf2123_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tu8 rxbuf[7];\n\tint ret;\n\n\tret = regmap_bulk_read(pcf2123->map, PCF2123_REG_SC, rxbuf,\n\t\t\t\tsizeof(rxbuf));\n\tif (ret)\n\t\treturn ret;\n\n\tif (rxbuf[0] & OSC_HAS_STOPPED) {\n\t\tdev_info(dev, \"clock was stopped. Time is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttm->tm_sec = bcd2bin(rxbuf[0] & 0x7F);\n\ttm->tm_min = bcd2bin(rxbuf[1] & 0x7F);\n\ttm->tm_hour = bcd2bin(rxbuf[2] & 0x3F);  \n\ttm->tm_mday = bcd2bin(rxbuf[3] & 0x3F);\n\ttm->tm_wday = rxbuf[4] & 0x07;\n\ttm->tm_mon = bcd2bin(rxbuf[5] & 0x1F) - 1;  \n\ttm->tm_year = bcd2bin(rxbuf[6]) + 100;\n\n\tdev_dbg(dev, \"%s: tm is %ptR\\n\", __func__, tm);\n\n\treturn 0;\n}\n\nstatic int pcf2123_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tu8 txbuf[7];\n\tint ret;\n\n\tdev_dbg(dev, \"%s: tm is %ptR\\n\", __func__, tm);\n\n\t \n\tret = regmap_write(pcf2123->map, PCF2123_REG_CTRL1, CTRL1_STOP);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttxbuf[0] = bin2bcd(tm->tm_sec & 0x7F);\n\ttxbuf[1] = bin2bcd(tm->tm_min & 0x7F);\n\ttxbuf[2] = bin2bcd(tm->tm_hour & 0x3F);\n\ttxbuf[3] = bin2bcd(tm->tm_mday & 0x3F);\n\ttxbuf[4] = tm->tm_wday & 0x07;\n\ttxbuf[5] = bin2bcd((tm->tm_mon + 1) & 0x1F);  \n\ttxbuf[6] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(pcf2123->map, PCF2123_REG_SC, txbuf,\n\t\t\t\tsizeof(txbuf));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(pcf2123->map, PCF2123_REG_CTRL1, CTRL1_CLEAR);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int pcf2123_rtc_alarm_irq_enable(struct device *dev, unsigned int en)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\n\treturn regmap_update_bits(pcf2123->map, PCF2123_REG_CTRL2, CTRL2_AIE,\n\t\t\t\t  en ? CTRL2_AIE : 0);\n}\n\nstatic int pcf2123_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tu8 rxbuf[4];\n\tint ret;\n\tunsigned int val = 0;\n\n\tret = regmap_bulk_read(pcf2123->map, PCF2123_REG_ALRM_MN, rxbuf,\n\t\t\t\tsizeof(rxbuf));\n\tif (ret)\n\t\treturn ret;\n\n\talm->time.tm_min = bcd2bin(rxbuf[0] & 0x7F);\n\talm->time.tm_hour = bcd2bin(rxbuf[1] & 0x3F);\n\talm->time.tm_mday = bcd2bin(rxbuf[2] & 0x3F);\n\talm->time.tm_wday = bcd2bin(rxbuf[3] & 0x07);\n\n\tdev_dbg(dev, \"%s: alm is %ptR\\n\", __func__, &alm->time);\n\n\tret = regmap_read(pcf2123->map, PCF2123_REG_CTRL2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\talm->enabled = !!(val & CTRL2_AIE);\n\n\treturn 0;\n}\n\nstatic int pcf2123_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tu8 txbuf[4];\n\tint ret;\n\n\tdev_dbg(dev, \"%s: alm is %ptR\\n\", __func__, &alm->time);\n\n\t \n\tret = regmap_update_bits(pcf2123->map, PCF2123_REG_CTRL2, CTRL2_AIE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(pcf2123->map, PCF2123_REG_CTRL2, CTRL2_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttxbuf[0] = bin2bcd(alm->time.tm_min & 0x7F);\n\ttxbuf[1] = bin2bcd(alm->time.tm_hour & 0x3F);\n\ttxbuf[2] = bin2bcd(alm->time.tm_mday & 0x3F);\n\ttxbuf[3] = ALRM_DISABLE;\n\n\tret = regmap_bulk_write(pcf2123->map, PCF2123_REG_ALRM_MN, txbuf,\n\t\t\t\tsizeof(txbuf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn pcf2123_rtc_alarm_irq_enable(dev, alm->enabled);\n}\n\nstatic irqreturn_t pcf2123_rtc_irq(int irq, void *dev)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tunsigned int val = 0;\n\tint ret = IRQ_NONE;\n\n\trtc_lock(pcf2123->rtc);\n\tregmap_read(pcf2123->map, PCF2123_REG_CTRL2, &val);\n\n\t \n\tif (val & CTRL2_AF) {\n\t\tret = IRQ_HANDLED;\n\n\t\t \n\t\tregmap_update_bits(pcf2123->map, PCF2123_REG_CTRL2, CTRL2_AF, 0);\n\n\t\trtc_update_irq(pcf2123->rtc, 1, RTC_IRQF | RTC_AF);\n\t}\n\n\trtc_unlock(pcf2123->rtc);\n\n\treturn ret;\n}\n\nstatic int pcf2123_reset(struct device *dev)\n{\n\tstruct pcf2123_data *pcf2123 = dev_get_drvdata(dev);\n\tint ret;\n\tunsigned int val = 0;\n\n\tret = regmap_write(pcf2123->map, PCF2123_REG_CTRL1, CTRL1_SW_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_dbg(dev, \"stopping RTC\\n\");\n\tret = regmap_write(pcf2123->map, PCF2123_REG_CTRL1, CTRL1_STOP);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_dbg(dev, \"checking for presence of RTC\\n\");\n\tret = regmap_read(pcf2123->map, PCF2123_REG_CTRL1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"received data from RTC (0x%08X)\\n\", val);\n\tif (!(val & CTRL1_STOP))\n\t\treturn -ENODEV;\n\n\t \n\tret = regmap_write(pcf2123->map, PCF2123_REG_CTRL1, CTRL1_CLEAR);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pcf2123_rtc_ops = {\n\t.read_time\t= pcf2123_rtc_read_time,\n\t.set_time\t= pcf2123_rtc_set_time,\n\t.read_offset\t= pcf2123_read_offset,\n\t.set_offset\t= pcf2123_set_offset,\n\t.read_alarm\t= pcf2123_rtc_read_alarm,\n\t.set_alarm\t= pcf2123_rtc_set_alarm,\n\t.alarm_irq_enable = pcf2123_rtc_alarm_irq_enable,\n};\n\nstatic int pcf2123_probe(struct spi_device *spi)\n{\n\tstruct rtc_device *rtc;\n\tstruct rtc_time tm;\n\tstruct pcf2123_data *pcf2123;\n\tint ret = 0;\n\n\tpcf2123 = devm_kzalloc(&spi->dev, sizeof(struct pcf2123_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcf2123)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&spi->dev, pcf2123);\n\n\tpcf2123->map = devm_regmap_init_spi(spi, &pcf2123_regmap_config);\n\tif (IS_ERR(pcf2123->map)) {\n\t\tdev_err(&spi->dev, \"regmap init failed.\\n\");\n\t\treturn PTR_ERR(pcf2123->map);\n\t}\n\n\tret = pcf2123_rtc_read_time(&spi->dev, &tm);\n\tif (ret < 0) {\n\t\tret = pcf2123_reset(&spi->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&spi->dev, \"chip not found\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_info(&spi->dev, \"spiclk %u KHz.\\n\",\n\t\t\t(spi->max_speed_hz + 500) / 1000);\n\n\t \n\trtc = devm_rtc_allocate_device(&spi->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tpcf2123->rtc = rtc;\n\n\t \n\tif (spi->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&spi->dev))\n\t\t\tirqflags = 0;\n\n\t\tret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,\n\t\t\t\tpcf2123_rtc_irq,\n\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\tpcf2123_driver.driver.name, &spi->dev);\n\t\tif (!ret)\n\t\t\tdevice_init_wakeup(&spi->dev, true);\n\t\telse\n\t\t\tdev_err(&spi->dev, \"could not request irq.\\n\");\n\t}\n\n\t \n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rtc->features);\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\trtc->ops = &pcf2123_rtc_ops;\n\trtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trtc->range_max = RTC_TIMESTAMP_END_2099;\n\trtc->set_start_time = true;\n\n\tret = devm_rtc_register_device(rtc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pcf2123_dt_ids[] = {\n\t{ .compatible = \"nxp,pcf2123\", },\n\t{ .compatible = \"microcrystal,rv2123\", },\n\t \n\t{ .compatible = \"nxp,rtc-pcf2123\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pcf2123_dt_ids);\n#endif\n\nstatic const struct spi_device_id pcf2123_spi_ids[] = {\n\t{ .name = \"pcf2123\", },\n\t{ .name = \"rv2123\", },\n\t{ .name = \"rtc-pcf2123\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, pcf2123_spi_ids);\n\nstatic struct spi_driver pcf2123_driver = {\n\t.driver\t= {\n\t\t\t.name\t= \"rtc-pcf2123\",\n\t\t\t.of_match_table = of_match_ptr(pcf2123_dt_ids),\n\t},\n\t.probe\t= pcf2123_probe,\n\t.id_table = pcf2123_spi_ids,\n};\n\nmodule_spi_driver(pcf2123_driver);\n\nMODULE_AUTHOR(\"Chris Verges <chrisv@cyberswitching.com>\");\nMODULE_DESCRIPTION(\"NXP PCF2123 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}