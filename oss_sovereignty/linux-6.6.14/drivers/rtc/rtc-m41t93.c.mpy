{
  "module_name": "rtc-m41t93.c",
  "hash_id": "82d4546dfd69e0e5e951aa48b0d4e00ffffab976f7b809d1fde651478c1322d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-m41t93.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/spi/spi.h>\n\n#define M41T93_REG_SSEC\t\t\t0\n#define M41T93_REG_ST_SEC\t\t1\n#define M41T93_REG_MIN\t\t\t2\n#define M41T93_REG_CENT_HOUR\t\t3\n#define M41T93_REG_WDAY\t\t\t4\n#define M41T93_REG_DAY\t\t\t5\n#define M41T93_REG_MON\t\t\t6\n#define M41T93_REG_YEAR\t\t\t7\n\n\n#define M41T93_REG_ALM_HOUR_HT\t\t0xc\n#define M41T93_REG_FLAGS\t\t0xf\n\n#define M41T93_FLAG_ST\t\t\t(1 << 7)\n#define M41T93_FLAG_OF\t\t\t(1 << 2)\n#define M41T93_FLAG_BL\t\t\t(1 << 4)\n#define M41T93_FLAG_HT\t\t\t(1 << 6)\n\nstatic inline int m41t93_set_reg(struct spi_device *spi, u8 addr, u8 data)\n{\n\tu8 buf[2];\n\n\t \n\tbuf[0] = addr | 0x80;\n\tbuf[1] = data;\n\n\treturn spi_write(spi, buf, sizeof(buf));\n}\n\nstatic int m41t93_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tint tmp;\n\tu8 buf[9] = {0x80};         \n\tu8 * const data = &buf[1];  \n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"write\", tm->tm_sec, tm->tm_min,\n\t\ttm->tm_hour, tm->tm_mday,\n\t\ttm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\tif (tm->tm_year < 100) {\n\t\tdev_warn(&spi->dev, \"unsupported date (before 2000-01-01).\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = spi_w8r8(spi, M41T93_REG_FLAGS);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tif (tmp & M41T93_FLAG_OF) {\n\t\tdev_warn(&spi->dev, \"OF bit is set, resetting.\\n\");\n\t\tm41t93_set_reg(spi, M41T93_REG_FLAGS, tmp & ~M41T93_FLAG_OF);\n\n\t\ttmp = spi_w8r8(spi, M41T93_REG_FLAGS);\n\t\tif (tmp < 0) {\n\t\t\treturn tmp;\n\t\t} else if (tmp & M41T93_FLAG_OF) {\n\t\t\t \n\t\t\tu8 reset_osc = buf[M41T93_REG_ST_SEC] | M41T93_FLAG_ST;\n\n\t\t\tdev_warn(&spi->dev,\n\t\t\t\t \"OF bit is still set, kickstarting clock.\\n\");\n\t\t\tm41t93_set_reg(spi, M41T93_REG_ST_SEC, reset_osc);\n\t\t\treset_osc &= ~M41T93_FLAG_ST;\n\t\t\tm41t93_set_reg(spi, M41T93_REG_ST_SEC, reset_osc);\n\t\t}\n\t}\n\n\tdata[M41T93_REG_SSEC]\t\t= 0;\n\tdata[M41T93_REG_ST_SEC]\t\t= bin2bcd(tm->tm_sec);\n\tdata[M41T93_REG_MIN]\t\t= bin2bcd(tm->tm_min);\n\tdata[M41T93_REG_CENT_HOUR]\t= bin2bcd(tm->tm_hour) |\n\t\t\t\t\t\t((tm->tm_year/100-1) << 6);\n\tdata[M41T93_REG_DAY]\t\t= bin2bcd(tm->tm_mday);\n\tdata[M41T93_REG_WDAY]\t\t= bin2bcd(tm->tm_wday + 1);\n\tdata[M41T93_REG_MON]\t\t= bin2bcd(tm->tm_mon + 1);\n\tdata[M41T93_REG_YEAR]\t\t= bin2bcd(tm->tm_year % 100);\n\n\treturn spi_write(spi, buf, sizeof(buf));\n}\n\n\nstatic int m41t93_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tconst u8 start_addr = 0;\n\tu8 buf[8];\n\tint century_after_1900;\n\tint tmp;\n\tint ret = 0;\n\n\t \n\ttmp = spi_w8r8(spi, M41T93_REG_ALM_HOUR_HT);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tif (tmp & M41T93_FLAG_HT) {\n\t\tdev_dbg(&spi->dev, \"HT bit is set, reenable clock update.\\n\");\n\t\tm41t93_set_reg(spi, M41T93_REG_ALM_HOUR_HT,\n\t\t\t       tmp & ~M41T93_FLAG_HT);\n\t}\n\n\ttmp = spi_w8r8(spi, M41T93_REG_FLAGS);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tif (tmp & M41T93_FLAG_OF) {\n\t\tret = -EINVAL;\n\t\tdev_warn(&spi->dev, \"OF bit is set, write time to restart.\\n\");\n\t}\n\n\tif (tmp & M41T93_FLAG_BL)\n\t\tdev_warn(&spi->dev, \"BL bit is set, replace battery.\\n\");\n\n\t \n\ttmp = spi_write_then_read(spi, &start_addr, 1, buf, sizeof(buf));\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\ttm->tm_sec\t= bcd2bin(buf[M41T93_REG_ST_SEC]);\n\ttm->tm_min\t= bcd2bin(buf[M41T93_REG_MIN]);\n\ttm->tm_hour\t= bcd2bin(buf[M41T93_REG_CENT_HOUR] & 0x3f);\n\ttm->tm_mday\t= bcd2bin(buf[M41T93_REG_DAY]);\n\ttm->tm_mon\t= bcd2bin(buf[M41T93_REG_MON]) - 1;\n\ttm->tm_wday\t= bcd2bin(buf[M41T93_REG_WDAY] & 0x0f) - 1;\n\n\tcentury_after_1900 = (buf[M41T93_REG_CENT_HOUR] >> 6) + 1;\n\ttm->tm_year = bcd2bin(buf[M41T93_REG_YEAR]) + century_after_1900 * 100;\n\n\tdev_dbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"read\", tm->tm_sec, tm->tm_min,\n\t\ttm->tm_hour, tm->tm_mday,\n\t\ttm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn ret;\n}\n\n\nstatic const struct rtc_class_ops m41t93_rtc_ops = {\n\t.read_time\t= m41t93_get_time,\n\t.set_time\t= m41t93_set_time,\n};\n\nstatic struct spi_driver m41t93_driver;\n\nstatic int m41t93_probe(struct spi_device *spi)\n{\n\tstruct rtc_device *rtc;\n\tint res;\n\n\tspi->bits_per_word = 8;\n\tspi_setup(spi);\n\n\tres = spi_w8r8(spi, M41T93_REG_WDAY);\n\tif (res < 0 || (res & 0xf8) != 0) {\n\t\tdev_err(&spi->dev, \"not found 0x%x.\\n\", res);\n\t\treturn -ENODEV;\n\t}\n\n\trtc = devm_rtc_device_register(&spi->dev, m41t93_driver.driver.name,\n\t\t\t\t\t&m41t93_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tspi_set_drvdata(spi, rtc);\n\n\treturn 0;\n}\n\nstatic struct spi_driver m41t93_driver = {\n\t.driver = {\n\t\t.name\t= \"rtc-m41t93\",\n\t},\n\t.probe\t= m41t93_probe,\n};\n\nmodule_spi_driver(m41t93_driver);\n\nMODULE_AUTHOR(\"Nikolaus Voss <n.voss@weinmann.de>\");\nMODULE_DESCRIPTION(\"Driver for ST M41T93 SPI RTC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:rtc-m41t93\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}