{
  "module_name": "rtc-xgene.c",
  "hash_id": "b0f1932d0f3d90657ac00dacd4be67896404ae631bc3f881f4d2b7b79db4b250",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-xgene.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n \n#define RTC_CCVR\t\t0x00\n#define RTC_CMR\t\t\t0x04\n#define RTC_CLR\t\t\t0x08\n#define RTC_CCR\t\t\t0x0C\n#define  RTC_CCR_IE\t\tBIT(0)\n#define  RTC_CCR_MASK\t\tBIT(1)\n#define  RTC_CCR_EN\t\tBIT(2)\n#define  RTC_CCR_WEN\t\tBIT(3)\n#define RTC_STAT\t\t0x10\n#define  RTC_STAT_BIT\t\tBIT(0)\n#define RTC_RSTAT\t\t0x14\n#define RTC_EOI\t\t\t0x18\n#define RTC_VER\t\t\t0x1C\n\nstruct xgene_rtc_dev {\n\tstruct rtc_device *rtc;\n\tvoid __iomem *csr_base;\n\tstruct clk *clk;\n\tunsigned int irq_wake;\n\tunsigned int irq_enabled;\n};\n\nstatic int xgene_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\n\trtc_time64_to_tm(readl(pdata->csr_base + RTC_CCVR), tm);\n\treturn 0;\n}\n\nstatic int xgene_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\n\t \n\twritel((u32)rtc_tm_to_time64(tm), pdata->csr_base + RTC_CLR);\n\treadl(pdata->csr_base + RTC_CLR);  \n\n\treturn 0;\n}\n\nstatic int xgene_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\n\t \n\trtc_time64_to_tm(0, &alrm->time);\n\talrm->enabled = readl(pdata->csr_base + RTC_CCR) & RTC_CCR_IE;\n\n\treturn 0;\n}\n\nstatic int xgene_rtc_alarm_irq_enable(struct device *dev, u32 enabled)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\tu32 ccr;\n\n\tccr = readl(pdata->csr_base + RTC_CCR);\n\tif (enabled) {\n\t\tccr &= ~RTC_CCR_MASK;\n\t\tccr |= RTC_CCR_IE;\n\t} else {\n\t\tccr &= ~RTC_CCR_IE;\n\t\tccr |= RTC_CCR_MASK;\n\t}\n\twritel(ccr, pdata->csr_base + RTC_CCR);\n\n\treturn 0;\n}\n\nstatic int xgene_rtc_alarm_irq_enabled(struct device *dev)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\n\treturn readl(pdata->csr_base + RTC_CCR) & RTC_CCR_IE ? 1 : 0;\n}\n\nstatic int xgene_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct xgene_rtc_dev *pdata = dev_get_drvdata(dev);\n\n\twritel((u32)rtc_tm_to_time64(&alrm->time), pdata->csr_base + RTC_CMR);\n\n\txgene_rtc_alarm_irq_enable(dev, alrm->enabled);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops xgene_rtc_ops = {\n\t.read_time\t= xgene_rtc_read_time,\n\t.set_time\t= xgene_rtc_set_time,\n\t.read_alarm\t= xgene_rtc_read_alarm,\n\t.set_alarm\t= xgene_rtc_set_alarm,\n\t.alarm_irq_enable = xgene_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t xgene_rtc_interrupt(int irq, void *id)\n{\n\tstruct xgene_rtc_dev *pdata = id;\n\n\t \n\tif (!(readl(pdata->csr_base + RTC_STAT) & RTC_STAT_BIT))\n\t\treturn IRQ_NONE;\n\n\t \n\treadl(pdata->csr_base + RTC_EOI);\n\n\trtc_update_irq(pdata->rtc, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xgene_rtc_probe(struct platform_device *pdev)\n{\n\tstruct xgene_rtc_dev *pdata;\n\tint ret;\n\tint irq;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, pdata);\n\n\tpdata->csr_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdata->csr_base))\n\t\treturn PTR_ERR(pdata->csr_base);\n\n\tpdata->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(pdata->rtc))\n\t\treturn PTR_ERR(pdata->rtc);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(&pdev->dev, irq, xgene_rtc_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), pdata);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pdata->clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get the clock for RTC\\n\");\n\t\treturn -ENODEV;\n\t}\n\tret = clk_prepare_enable(pdata->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(RTC_CCR_EN, pdata->csr_base + RTC_CCR);\n\n\tret = device_init_wakeup(&pdev->dev, 1);\n\tif (ret) {\n\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\n\tpdata->rtc->ops = &xgene_rtc_ops;\n\tpdata->rtc->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(pdata->rtc);\n\tif (ret) {\n\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_rtc_remove(struct platform_device *pdev)\n{\n\tstruct xgene_rtc_dev *pdata = platform_get_drvdata(pdev);\n\n\txgene_rtc_alarm_irq_enable(&pdev->dev, 0);\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tclk_disable_unprepare(pdata->clk);\n}\n\nstatic int __maybe_unused xgene_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct xgene_rtc_dev *pdata = platform_get_drvdata(pdev);\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\n\t \n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (!enable_irq_wake(irq))\n\t\t\tpdata->irq_wake = 1;\n\t} else {\n\t\tpdata->irq_enabled = xgene_rtc_alarm_irq_enabled(dev);\n\t\txgene_rtc_alarm_irq_enable(dev, 0);\n\t\tclk_disable_unprepare(pdata->clk);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused xgene_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct xgene_rtc_dev *pdata = platform_get_drvdata(pdev);\n\tint irq;\n\tint rc;\n\n\tirq = platform_get_irq(pdev, 0);\n\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (pdata->irq_wake) {\n\t\t\tdisable_irq_wake(irq);\n\t\t\tpdata->irq_wake = 0;\n\t\t}\n\t} else {\n\t\trc = clk_prepare_enable(pdata->clk);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Unable to enable clock error %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\txgene_rtc_alarm_irq_enable(dev, pdata->irq_enabled);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(xgene_rtc_pm_ops, xgene_rtc_suspend, xgene_rtc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id xgene_rtc_of_match[] = {\n\t{.compatible = \"apm,xgene-rtc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xgene_rtc_of_match);\n#endif\n\nstatic struct platform_driver xgene_rtc_driver = {\n\t.probe\t\t= xgene_rtc_probe,\n\t.remove_new\t= xgene_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"xgene-rtc\",\n\t\t.pm = &xgene_rtc_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(xgene_rtc_of_match),\n\t},\n};\n\nmodule_platform_driver(xgene_rtc_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene SoC RTC driver\");\nMODULE_AUTHOR(\"Rameshwar Sahu <rsahu@apm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}