{
  "module_name": "rtc-lp8788.c",
  "hash_id": "3a78805e291b6d92c703f1bd6827c63dc6f5361a7f563f5844de0bbcef11f7d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-lp8788.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n\n \n#define LP8788_INTEN_3\t\t\t0x05\n#define LP8788_RTC_UNLOCK\t\t0x64\n#define LP8788_RTC_SEC\t\t\t0x70\n#define LP8788_ALM1_SEC\t\t\t0x77\n#define LP8788_ALM1_EN\t\t\t0x7D\n#define LP8788_ALM2_SEC\t\t\t0x7E\n#define LP8788_ALM2_EN\t\t\t0x84\n\n \n#define LP8788_INT_RTC_ALM1_M\t\tBIT(1)\t \n#define LP8788_INT_RTC_ALM1_S\t\t1\n#define LP8788_INT_RTC_ALM2_M\t\tBIT(2)\t \n#define LP8788_INT_RTC_ALM2_S\t\t2\n#define LP8788_ALM_EN_M\t\t\tBIT(7)\t \n#define LP8788_ALM_EN_S\t\t\t7\n\n#define DEFAULT_ALARM_SEL\t\tLP8788_ALARM_1\n#define LP8788_MONTH_OFFSET\t\t1\n#define LP8788_BASE_YEAR\t\t2000\n#define MAX_WDAY_BITS\t\t\t7\n#define LP8788_WDAY_SET\t\t\t1\n#define RTC_UNLOCK\t\t\t0x1\n#define RTC_LATCH\t\t\t0x2\n#define ALARM_IRQ_FLAG\t\t\t(RTC_IRQF | RTC_AF)\n\nenum lp8788_time {\n\tLPTIME_SEC,\n\tLPTIME_MIN,\n\tLPTIME_HOUR,\n\tLPTIME_MDAY,\n\tLPTIME_MON,\n\tLPTIME_YEAR,\n\tLPTIME_WDAY,\n\tLPTIME_MAX,\n};\n\nstruct lp8788_rtc {\n\tstruct lp8788 *lp;\n\tstruct rtc_device *rdev;\n\tenum lp8788_alarm_sel alarm;\n\tint irq;\n};\n\nstatic const u8 addr_alarm_sec[LP8788_ALARM_MAX] = {\n\tLP8788_ALM1_SEC,\n\tLP8788_ALM2_SEC,\n};\n\nstatic const u8 addr_alarm_en[LP8788_ALARM_MAX] = {\n\tLP8788_ALM1_EN,\n\tLP8788_ALM2_EN,\n};\n\nstatic const u8 mask_alarm_en[LP8788_ALARM_MAX] = {\n\tLP8788_INT_RTC_ALM1_M,\n\tLP8788_INT_RTC_ALM2_M,\n};\n\nstatic const u8 shift_alarm_en[LP8788_ALARM_MAX] = {\n\tLP8788_INT_RTC_ALM1_S,\n\tLP8788_INT_RTC_ALM2_S,\n};\n\nstatic int _to_tm_wday(u8 lp8788_wday)\n{\n\tint i;\n\n\tif (lp8788_wday == 0)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < MAX_WDAY_BITS; i++) {\n\t\tif ((lp8788_wday >> i) == LP8788_WDAY_SET)\n\t\t\tbreak;\n\t}\n\n\treturn i + 1;\n}\n\nstatic inline int _to_lp8788_wday(int tm_wday)\n{\n\treturn LP8788_WDAY_SET << (tm_wday - 1);\n}\n\nstatic void lp8788_rtc_unlock(struct lp8788 *lp)\n{\n\tlp8788_write_byte(lp, LP8788_RTC_UNLOCK, RTC_UNLOCK);\n\tlp8788_write_byte(lp, LP8788_RTC_UNLOCK, RTC_LATCH);\n}\n\nstatic int lp8788_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\n\tstruct lp8788 *lp = rtc->lp;\n\tu8 data[LPTIME_MAX];\n\tint ret;\n\n\tlp8788_rtc_unlock(lp);\n\n\tret = lp8788_read_multi_bytes(lp, LP8788_RTC_SEC, data,\tLPTIME_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\ttm->tm_sec  = data[LPTIME_SEC];\n\ttm->tm_min  = data[LPTIME_MIN];\n\ttm->tm_hour = data[LPTIME_HOUR];\n\ttm->tm_mday = data[LPTIME_MDAY];\n\ttm->tm_mon  = data[LPTIME_MON] - LP8788_MONTH_OFFSET;\n\ttm->tm_year = data[LPTIME_YEAR] + LP8788_BASE_YEAR - 1900;\n\ttm->tm_wday = _to_tm_wday(data[LPTIME_WDAY]);\n\n\treturn 0;\n}\n\nstatic int lp8788_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\n\tstruct lp8788 *lp = rtc->lp;\n\tu8 data[LPTIME_MAX - 1];\n\tint ret, i, year;\n\n\tyear = tm->tm_year + 1900 - LP8788_BASE_YEAR;\n\tif (year < 0) {\n\t\tdev_err(lp->dev, \"invalid year: %d\\n\", year);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata[LPTIME_SEC]  = tm->tm_sec;\n\tdata[LPTIME_MIN]  = tm->tm_min;\n\tdata[LPTIME_HOUR] = tm->tm_hour;\n\tdata[LPTIME_MDAY] = tm->tm_mday;\n\tdata[LPTIME_MON]  = tm->tm_mon + LP8788_MONTH_OFFSET;\n\tdata[LPTIME_YEAR] = year;\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\tret = lp8788_write_byte(lp, LP8788_RTC_SEC + i, data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\n\tstruct lp8788 *lp = rtc->lp;\n\tstruct rtc_time *tm = &alarm->time;\n\tu8 addr, data[LPTIME_MAX];\n\tint ret;\n\n\taddr = addr_alarm_sec[rtc->alarm];\n\tret = lp8788_read_multi_bytes(lp, addr, data, LPTIME_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\ttm->tm_sec  = data[LPTIME_SEC];\n\ttm->tm_min  = data[LPTIME_MIN];\n\ttm->tm_hour = data[LPTIME_HOUR];\n\ttm->tm_mday = data[LPTIME_MDAY];\n\ttm->tm_mon  = data[LPTIME_MON] - LP8788_MONTH_OFFSET;\n\ttm->tm_year = data[LPTIME_YEAR] + LP8788_BASE_YEAR - 1900;\n\ttm->tm_wday = _to_tm_wday(data[LPTIME_WDAY]);\n\talarm->enabled = data[LPTIME_WDAY] & LP8788_ALM_EN_M;\n\n\treturn 0;\n}\n\nstatic int lp8788_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\n\tstruct lp8788 *lp = rtc->lp;\n\tstruct rtc_time *tm = &alarm->time;\n\tu8 addr, data[LPTIME_MAX];\n\tint ret, i, year;\n\n\tyear = tm->tm_year + 1900 - LP8788_BASE_YEAR;\n\tif (year < 0) {\n\t\tdev_err(lp->dev, \"invalid year: %d\\n\", year);\n\t\treturn -EINVAL;\n\t}\n\n\tdata[LPTIME_SEC]  = tm->tm_sec;\n\tdata[LPTIME_MIN]  = tm->tm_min;\n\tdata[LPTIME_HOUR] = tm->tm_hour;\n\tdata[LPTIME_MDAY] = tm->tm_mday;\n\tdata[LPTIME_MON]  = tm->tm_mon + LP8788_MONTH_OFFSET;\n\tdata[LPTIME_YEAR] = year;\n\tdata[LPTIME_WDAY] = _to_lp8788_wday(tm->tm_wday);\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\taddr = addr_alarm_sec[rtc->alarm] + i;\n\t\tret = lp8788_write_byte(lp, addr, data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\talarm->enabled = 1;\n\taddr = addr_alarm_en[rtc->alarm];\n\n\treturn lp8788_update_bits(lp, addr, LP8788_ALM_EN_M,\n\t\t\t\talarm->enabled << LP8788_ALM_EN_S);\n}\n\nstatic int lp8788_alarm_irq_enable(struct device *dev, unsigned int enable)\n{\n\tstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\n\tstruct lp8788 *lp = rtc->lp;\n\tu8 mask, shift;\n\n\tif (!rtc->irq)\n\t\treturn -EIO;\n\n\tmask = mask_alarm_en[rtc->alarm];\n\tshift = shift_alarm_en[rtc->alarm];\n\n\treturn lp8788_update_bits(lp, LP8788_INTEN_3, mask, enable << shift);\n}\n\nstatic const struct rtc_class_ops lp8788_rtc_ops = {\n\t.read_time = lp8788_rtc_read_time,\n\t.set_time = lp8788_rtc_set_time,\n\t.read_alarm = lp8788_read_alarm,\n\t.set_alarm = lp8788_set_alarm,\n\t.alarm_irq_enable = lp8788_alarm_irq_enable,\n};\n\nstatic irqreturn_t lp8788_alarm_irq_handler(int irq, void *ptr)\n{\n\tstruct lp8788_rtc *rtc = ptr;\n\n\trtc_update_irq(rtc->rdev, 1, ALARM_IRQ_FLAG);\n\treturn IRQ_HANDLED;\n}\n\nstatic int lp8788_alarm_irq_register(struct platform_device *pdev,\n\t\t\t\tstruct lp8788_rtc *rtc)\n{\n\tstruct resource *r;\n\tstruct lp8788 *lp = rtc->lp;\n\tstruct irq_domain *irqdm = lp->irqdm;\n\tint irq;\n\n\trtc->irq = 0;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, LP8788_ALM_IRQ);\n\tif (!r)\n\t\treturn 0;\n\n\tif (rtc->alarm == LP8788_ALARM_1)\n\t\tirq = r->start;\n\telse\n\t\tirq = r->end;\n\n\trtc->irq = irq_create_mapping(irqdm, irq);\n\n\treturn devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\n\t\t\t\tlp8788_alarm_irq_handler,\n\t\t\t\t0, LP8788_ALM_IRQ, rtc);\n}\n\nstatic int lp8788_rtc_probe(struct platform_device *pdev)\n{\n\tstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\n\tstruct lp8788_rtc *rtc;\n\tstruct device *dev = &pdev->dev;\n\n\trtc = devm_kzalloc(dev, sizeof(struct lp8788_rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->lp = lp;\n\trtc->alarm = lp->pdata ? lp->pdata->alarm_sel : DEFAULT_ALARM_SEL;\n\tplatform_set_drvdata(pdev, rtc);\n\n\tdevice_init_wakeup(dev, 1);\n\n\trtc->rdev = devm_rtc_device_register(dev, \"lp8788_rtc\",\n\t\t\t\t\t&lp8788_rtc_ops, THIS_MODULE);\n\tif (IS_ERR(rtc->rdev)) {\n\t\tdev_err(dev, \"can not register rtc device\\n\");\n\t\treturn PTR_ERR(rtc->rdev);\n\t}\n\n\tif (lp8788_alarm_irq_register(pdev, rtc))\n\t\tdev_warn(lp->dev, \"no rtc irq handler\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver lp8788_rtc_driver = {\n\t.probe = lp8788_rtc_probe,\n\t.driver = {\n\t\t.name = LP8788_DEV_RTC,\n\t},\n};\nmodule_platform_driver(lp8788_rtc_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments LP8788 RTC Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lp8788-rtc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}