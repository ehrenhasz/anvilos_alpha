{
  "module_name": "rtc-rv3032.c",
  "hash_id": "d5a6742a2730ca504411d51999e251f8368d29aee5d74a7a002a2bd230d5bb2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-rv3032.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n#define RV3032_SEC\t\t\t0x01\n#define RV3032_MIN\t\t\t0x02\n#define RV3032_HOUR\t\t\t0x03\n#define RV3032_WDAY\t\t\t0x04\n#define RV3032_DAY\t\t\t0x05\n#define RV3032_MONTH\t\t\t0x06\n#define RV3032_YEAR\t\t\t0x07\n#define RV3032_ALARM_MIN\t\t0x08\n#define RV3032_ALARM_HOUR\t\t0x09\n#define RV3032_ALARM_DAY\t\t0x0A\n#define RV3032_STATUS\t\t\t0x0D\n#define RV3032_TLSB\t\t\t0x0E\n#define RV3032_TMSB\t\t\t0x0F\n#define RV3032_CTRL1\t\t\t0x10\n#define RV3032_CTRL2\t\t\t0x11\n#define RV3032_CTRL3\t\t\t0x12\n#define RV3032_TS_CTRL\t\t\t0x13\n#define RV3032_CLK_IRQ\t\t\t0x14\n#define RV3032_EEPROM_ADDR\t\t0x3D\n#define RV3032_EEPROM_DATA\t\t0x3E\n#define RV3032_EEPROM_CMD\t\t0x3F\n#define RV3032_RAM1\t\t\t0x40\n#define RV3032_PMU\t\t\t0xC0\n#define RV3032_OFFSET\t\t\t0xC1\n#define RV3032_CLKOUT1\t\t\t0xC2\n#define RV3032_CLKOUT2\t\t\t0xC3\n#define RV3032_TREF0\t\t\t0xC4\n#define RV3032_TREF1\t\t\t0xC5\n\n#define RV3032_STATUS_VLF\t\tBIT(0)\n#define RV3032_STATUS_PORF\t\tBIT(1)\n#define RV3032_STATUS_EVF\t\tBIT(2)\n#define RV3032_STATUS_AF\t\tBIT(3)\n#define RV3032_STATUS_TF\t\tBIT(4)\n#define RV3032_STATUS_UF\t\tBIT(5)\n#define RV3032_STATUS_TLF\t\tBIT(6)\n#define RV3032_STATUS_THF\t\tBIT(7)\n\n#define RV3032_TLSB_CLKF\t\tBIT(1)\n#define RV3032_TLSB_EEBUSY\t\tBIT(2)\n#define RV3032_TLSB_TEMP\t\tGENMASK(7, 4)\n\n#define RV3032_CLKOUT2_HFD_MSK\t\tGENMASK(4, 0)\n#define RV3032_CLKOUT2_FD_MSK\t\tGENMASK(6, 5)\n#define RV3032_CLKOUT2_OS\t\tBIT(7)\n\n#define RV3032_CTRL1_EERD\t\tBIT(3)\n#define RV3032_CTRL1_WADA\t\tBIT(5)\n\n#define RV3032_CTRL2_STOP\t\tBIT(0)\n#define RV3032_CTRL2_EIE\t\tBIT(2)\n#define RV3032_CTRL2_AIE\t\tBIT(3)\n#define RV3032_CTRL2_TIE\t\tBIT(4)\n#define RV3032_CTRL2_UIE\t\tBIT(5)\n#define RV3032_CTRL2_CLKIE\t\tBIT(6)\n#define RV3032_CTRL2_TSE\t\tBIT(7)\n\n#define RV3032_PMU_TCM\t\t\tGENMASK(1, 0)\n#define RV3032_PMU_TCR\t\t\tGENMASK(3, 2)\n#define RV3032_PMU_BSM\t\t\tGENMASK(5, 4)\n#define RV3032_PMU_NCLKE\t\tBIT(6)\n\n#define RV3032_PMU_BSM_DSM\t\t1\n#define RV3032_PMU_BSM_LSM\t\t2\n\n#define RV3032_OFFSET_MSK\t\tGENMASK(5, 0)\n\n#define RV3032_EVT_CTRL_TSR\t\tBIT(2)\n\n#define RV3032_EEPROM_CMD_UPDATE\t0x11\n#define RV3032_EEPROM_CMD_WRITE\t\t0x21\n#define RV3032_EEPROM_CMD_READ\t\t0x22\n\n#define RV3032_EEPROM_USER\t\t0xCB\n\n#define RV3032_EEBUSY_POLL\t\t10000\n#define RV3032_EEBUSY_TIMEOUT\t\t100000\n\n#define OFFSET_STEP_PPT\t\t\t238419\n\nstruct rv3032_data {\n\tstruct regmap *regmap;\n\tstruct rtc_device *rtc;\n\tbool trickle_charger_set;\n#ifdef CONFIG_COMMON_CLK\n\tstruct clk_hw clkout_hw;\n#endif\n};\n\nstatic u16 rv3032_trickle_resistors[] = {1000, 2000, 7000, 11000};\nstatic u16 rv3032_trickle_voltages[] = {0, 1750, 3000, 4400};\n\nstatic int rv3032_exit_eerd(struct rv3032_data *rv3032, u32 eerd)\n{\n\tif (eerd)\n\t\treturn 0;\n\n\treturn regmap_update_bits(rv3032->regmap, RV3032_CTRL1, RV3032_CTRL1_EERD, 0);\n}\n\nstatic int rv3032_enter_eerd(struct rv3032_data *rv3032, u32 *eerd)\n{\n\tu32 ctrl1, status;\n\tint ret;\n\n\tret = regmap_read(rv3032->regmap, RV3032_CTRL1, &ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\t*eerd = ctrl1 & RV3032_CTRL1_EERD;\n\tif (*eerd)\n\t\treturn 0;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL1,\n\t\t\t\t RV3032_CTRL1_EERD, RV3032_CTRL1_EERD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(rv3032->regmap, RV3032_TLSB, status,\n\t\t\t\t       !(status & RV3032_TLSB_EEBUSY),\n\t\t\t\t       RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\tif (ret) {\n\t\trv3032_exit_eerd(rv3032, *eerd);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3032_update_cfg(struct rv3032_data *rv3032, unsigned int reg,\n\t\t\t     unsigned int mask, unsigned int val)\n{\n\tu32 status, eerd;\n\tint ret;\n\n\tret = rv3032_enter_eerd(rv3032, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3032->regmap, reg, mask, val);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_CMD, RV3032_EEPROM_CMD_UPDATE);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tusleep_range(46000, RV3032_EEBUSY_TIMEOUT);\n\n\tret = regmap_read_poll_timeout(rv3032->regmap, RV3032_TLSB, status,\n\t\t\t\t       !(status & RV3032_TLSB_EEBUSY),\n\t\t\t\t       RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\nexit_eerd:\n\trv3032_exit_eerd(rv3032, eerd);\n\n\treturn ret;\n}\n\nstatic irqreturn_t rv3032_handle_irq(int irq, void *dev_id)\n{\n\tstruct rv3032_data *rv3032 = dev_id;\n\tunsigned long events = 0;\n\tu32 status = 0, ctrl = 0;\n\n\tif (regmap_read(rv3032->regmap, RV3032_STATUS, &status) < 0 ||\n\t    status == 0) {\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status & RV3032_STATUS_TF) {\n\t\tstatus |= RV3032_STATUS_TF;\n\t\tctrl |= RV3032_CTRL2_TIE;\n\t\tevents |= RTC_PF;\n\t}\n\n\tif (status & RV3032_STATUS_AF) {\n\t\tstatus |= RV3032_STATUS_AF;\n\t\tctrl |= RV3032_CTRL2_AIE;\n\t\tevents |= RTC_AF;\n\t}\n\n\tif (status & RV3032_STATUS_UF) {\n\t\tstatus |= RV3032_STATUS_UF;\n\t\tctrl |= RV3032_CTRL2_UIE;\n\t\tevents |= RTC_UF;\n\t}\n\n\tif (events) {\n\t\trtc_update_irq(rv3032->rtc, 1, events);\n\t\tregmap_update_bits(rv3032->regmap, RV3032_STATUS, status, 0);\n\t\tregmap_update_bits(rv3032->regmap, RV3032_CTRL2, ctrl, 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rv3032_get_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret, status;\n\n\tret = regmap_read(rv3032->regmap, RV3032_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (status & (RV3032_STATUS_PORF | RV3032_STATUS_VLF))\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_read(rv3032->regmap, RV3032_SEC, date, sizeof(date));\n\tif (ret)\n\t\treturn ret;\n\n\ttm->tm_sec  = bcd2bin(date[0] & 0x7f);\n\ttm->tm_min  = bcd2bin(date[1] & 0x7f);\n\ttm->tm_hour = bcd2bin(date[2] & 0x3f);\n\ttm->tm_wday = date[3] & 0x7;\n\ttm->tm_mday = bcd2bin(date[4] & 0x3f);\n\ttm->tm_mon  = bcd2bin(date[5] & 0x1f) - 1;\n\ttm->tm_year = bcd2bin(date[6]) + 100;\n\n\treturn 0;\n}\n\nstatic int rv3032_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tu8 date[7];\n\tint ret;\n\n\tdate[0] = bin2bcd(tm->tm_sec);\n\tdate[1] = bin2bcd(tm->tm_min);\n\tdate[2] = bin2bcd(tm->tm_hour);\n\tdate[3] = tm->tm_wday;\n\tdate[4] = bin2bcd(tm->tm_mday);\n\tdate[5] = bin2bcd(tm->tm_mon + 1);\n\tdate[6] = bin2bcd(tm->tm_year - 100);\n\n\tret = regmap_bulk_write(rv3032->regmap, RV3032_SEC, date,\n\t\t\t\tsizeof(date));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_STATUS,\n\t\t\t\t RV3032_STATUS_PORF | RV3032_STATUS_VLF, 0);\n\n\treturn ret;\n}\n\nstatic int rv3032_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tint status, ctrl, ret;\n\n\tret = regmap_bulk_read(rv3032->regmap, RV3032_ALARM_MIN, alarmvals,\n\t\t\t       sizeof(alarmvals));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(rv3032->regmap, RV3032_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(rv3032->regmap, RV3032_CTRL2, &ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talrm->time.tm_sec  = 0;\n\talrm->time.tm_min  = bcd2bin(alarmvals[0] & 0x7f);\n\talrm->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\n\talrm->time.tm_mday = bcd2bin(alarmvals[2] & 0x3f);\n\n\talrm->enabled = !!(ctrl & RV3032_CTRL2_AIE);\n\talrm->pending = (status & RV3032_STATUS_AF) && alrm->enabled;\n\n\treturn 0;\n}\n\nstatic int rv3032_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tu8 alarmvals[3];\n\tu8 ctrl = 0;\n\tint ret;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL2,\n\t\t\t\t RV3032_CTRL2_AIE | RV3032_CTRL2_UIE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\talarmvals[0] = bin2bcd(alrm->time.tm_min);\n\talarmvals[1] = bin2bcd(alrm->time.tm_hour);\n\talarmvals[2] = bin2bcd(alrm->time.tm_mday);\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_STATUS,\n\t\t\t\t RV3032_STATUS_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_write(rv3032->regmap, RV3032_ALARM_MIN, alarmvals,\n\t\t\t\tsizeof(alarmvals));\n\tif (ret)\n\t\treturn ret;\n\n\tif (alrm->enabled) {\n\t\tif (rv3032->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RV3032_CTRL2_UIE;\n\t\tif (rv3032->rtc->aie_timer.enabled)\n\t\t\tctrl |= RV3032_CTRL2_AIE;\n\t}\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL2,\n\t\t\t\t RV3032_CTRL2_UIE | RV3032_CTRL2_AIE, ctrl);\n\n\treturn ret;\n}\n\nstatic int rv3032_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tint ctrl = 0, ret;\n\n\tif (enabled) {\n\t\tif (rv3032->rtc->uie_rtctimer.enabled)\n\t\t\tctrl |= RV3032_CTRL2_UIE;\n\t\tif (rv3032->rtc->aie_timer.enabled)\n\t\t\tctrl |= RV3032_CTRL2_AIE;\n\t}\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_STATUS,\n\t\t\t\t RV3032_STATUS_AF | RV3032_STATUS_UF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL2,\n\t\t\t\t RV3032_CTRL2_UIE | RV3032_CTRL2_AIE, ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rv3032_read_offset(struct device *dev, long *offset)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tint ret, value, steps;\n\n\tret = regmap_read(rv3032->regmap, RV3032_OFFSET, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsteps = sign_extend32(FIELD_GET(RV3032_OFFSET_MSK, value), 5);\n\n\t*offset = DIV_ROUND_CLOSEST(steps * OFFSET_STEP_PPT, 1000);\n\n\treturn 0;\n}\n\nstatic int rv3032_set_offset(struct device *dev, long offset)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\n\toffset = clamp(offset, -7629L, 7391L) * 1000;\n\toffset = DIV_ROUND_CLOSEST(offset, OFFSET_STEP_PPT);\n\n\treturn rv3032_update_cfg(rv3032, RV3032_OFFSET, RV3032_OFFSET_MSK,\n\t\t\t\t FIELD_PREP(RV3032_OFFSET_MSK, offset));\n}\n\nstatic int rv3032_param_get(struct device *dev, struct rtc_param *param)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch(param->param) {\n\t\tu32 value;\n\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tret = regmap_read(rv3032->regmap, RV3032_PMU, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvalue = FIELD_GET(RV3032_PMU_BSM, value);\n\n\t\tswitch(value) {\n\t\tcase RV3032_PMU_BSM_DSM:\n\t\t\tparam->uvalue = RTC_BSM_DIRECT;\n\t\t\tbreak;\n\t\tcase RV3032_PMU_BSM_LSM:\n\t\t\tparam->uvalue = RTC_BSM_LEVEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->uvalue = RTC_BSM_DISABLED;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3032_param_set(struct device *dev, struct rtc_param *param)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\n\tswitch(param->param) {\n\t\tu8 mode;\n\tcase RTC_PARAM_BACKUP_SWITCH_MODE:\n\t\tif (rv3032->trickle_charger_set)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (param->uvalue) {\n\t\tcase RTC_BSM_DISABLED:\n\t\t\tmode = 0;\n\t\t\tbreak;\n\t\tcase RTC_BSM_DIRECT:\n\t\t\tmode = RV3032_PMU_BSM_DSM;\n\t\t\tbreak;\n\t\tcase RTC_BSM_LEVEL:\n\t\t\tmode = RV3032_PMU_BSM_LSM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn rv3032_update_cfg(rv3032, RV3032_PMU, RV3032_PMU_BSM,\n\t\t\t\t\t FIELD_PREP(RV3032_PMU_BSM, mode));\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rv3032_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tint status, val = 0, ret = 0;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(rv3032->regmap, RV3032_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (status & (RV3032_STATUS_PORF | RV3032_STATUS_VLF))\n\t\t\tval = RTC_VL_DATA_INVALID;\n\t\treturn put_user(val, (unsigned int __user *)arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int rv3032_nvram_write(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\treturn regmap_bulk_write(priv, RV3032_RAM1 + offset, val, bytes);\n}\n\nstatic int rv3032_nvram_read(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\treturn regmap_bulk_read(priv, RV3032_RAM1 + offset, val, bytes);\n}\n\nstatic int rv3032_eeprom_write(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct rv3032_data *rv3032 = priv;\n\tu32 status, eerd;\n\tint i, ret;\n\tu8 *buf = val;\n\n\tret = rv3032_enter_eerd(rv3032, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_ADDR,\n\t\t\t\t   RV3032_EEPROM_USER + offset + i);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_DATA, buf[i]);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_CMD,\n\t\t\t\t   RV3032_EEPROM_CMD_WRITE);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tusleep_range(RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\n\t\tret = regmap_read_poll_timeout(rv3032->regmap, RV3032_TLSB, status,\n\t\t\t\t\t       !(status & RV3032_TLSB_EEBUSY),\n\t\t\t\t\t       RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\t}\n\nexit_eerd:\n\trv3032_exit_eerd(rv3032, eerd);\n\n\treturn ret;\n}\n\nstatic int rv3032_eeprom_read(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct rv3032_data *rv3032 = priv;\n\tu32 status, eerd, data;\n\tint i, ret;\n\tu8 *buf = val;\n\n\tret = rv3032_enter_eerd(rv3032, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bytes; i++) {\n\t\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_ADDR,\n\t\t\t\t   RV3032_EEPROM_USER + offset + i);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_CMD,\n\t\t\t\t   RV3032_EEPROM_CMD_READ);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tret = regmap_read_poll_timeout(rv3032->regmap, RV3032_TLSB, status,\n\t\t\t\t\t       !(status & RV3032_TLSB_EEBUSY),\n\t\t\t\t\t       RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\n\t\tret = regmap_read(rv3032->regmap, RV3032_EEPROM_DATA, &data);\n\t\tif (ret)\n\t\t\tgoto exit_eerd;\n\t\tbuf[i] = data;\n\t}\n\nexit_eerd:\n\trv3032_exit_eerd(rv3032, eerd);\n\n\treturn ret;\n}\n\nstatic int rv3032_trickle_charger_setup(struct device *dev, struct rv3032_data *rv3032)\n{\n\tu32 val, ohms, voltage;\n\tint i;\n\n\tval = FIELD_PREP(RV3032_PMU_TCM, 1) | FIELD_PREP(RV3032_PMU_BSM, RV3032_PMU_BSM_DSM);\n\tif (!device_property_read_u32(dev, \"trickle-voltage-millivolt\", &voltage)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(rv3032_trickle_voltages); i++)\n\t\t\tif (voltage == rv3032_trickle_voltages[i])\n\t\t\t\tbreak;\n\t\tif (i < ARRAY_SIZE(rv3032_trickle_voltages))\n\t\t\tval = FIELD_PREP(RV3032_PMU_TCM, i) |\n\t\t\t      FIELD_PREP(RV3032_PMU_BSM, RV3032_PMU_BSM_LSM);\n\t}\n\n\tif (device_property_read_u32(dev, \"trickle-resistor-ohms\", &ohms))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(rv3032_trickle_resistors); i++)\n\t\tif (ohms == rv3032_trickle_resistors[i])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(rv3032_trickle_resistors)) {\n\t\tdev_warn(dev, \"invalid trickle resistor value\\n\");\n\n\t\treturn 0;\n\t}\n\n\trv3032->trickle_charger_set = true;\n\n\treturn rv3032_update_cfg(rv3032, RV3032_PMU,\n\t\t\t\t RV3032_PMU_TCR | RV3032_PMU_TCM | RV3032_PMU_BSM,\n\t\t\t\t val | FIELD_PREP(RV3032_PMU_TCR, i));\n}\n\n#ifdef CONFIG_COMMON_CLK\n#define clkout_hw_to_rv3032(hw) container_of(hw, struct rv3032_data, clkout_hw)\n\nstatic int clkout_xtal_rates[] = {\n\t32768,\n\t1024,\n\t64,\n\t1,\n};\n\n#define RV3032_HFD_STEP 8192\n\nstatic unsigned long rv3032_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tint clkout, ret;\n\tstruct rv3032_data *rv3032 = clkout_hw_to_rv3032(hw);\n\n\tret = regmap_read(rv3032->regmap, RV3032_CLKOUT2, &clkout);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (clkout & RV3032_CLKOUT2_OS) {\n\t\tunsigned long rate = FIELD_GET(RV3032_CLKOUT2_HFD_MSK, clkout) << 8;\n\n\t\tret = regmap_read(rv3032->regmap, RV3032_CLKOUT1, &clkout);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\n\t\trate += clkout + 1;\n\n\t\treturn rate * RV3032_HFD_STEP;\n\t}\n\n\treturn clkout_xtal_rates[FIELD_GET(RV3032_CLKOUT2_FD_MSK, clkout)];\n}\n\nstatic long rv3032_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tint i, hfd;\n\n\tif (rate < RV3032_HFD_STEP)\n\t\tfor (i = 0; i < ARRAY_SIZE(clkout_xtal_rates); i++)\n\t\t\tif (clkout_xtal_rates[i] <= rate)\n\t\t\t\treturn clkout_xtal_rates[i];\n\n\thfd = DIV_ROUND_CLOSEST(rate, RV3032_HFD_STEP);\n\n\treturn RV3032_HFD_STEP * clamp(hfd, 0, 8192);\n}\n\nstatic int rv3032_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct rv3032_data *rv3032 = clkout_hw_to_rv3032(hw);\n\tu32 status, eerd;\n\tint i, hfd, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(clkout_xtal_rates); i++) {\n\t\tif (clkout_xtal_rates[i] == rate) {\n\t\t\treturn rv3032_update_cfg(rv3032, RV3032_CLKOUT2, 0xff,\n\t\t\t\t\t\t FIELD_PREP(RV3032_CLKOUT2_FD_MSK, i));\n\t\t}\n\t}\n\n\thfd = DIV_ROUND_CLOSEST(rate, RV3032_HFD_STEP);\n\thfd = clamp(hfd, 1, 8192) - 1;\n\n\tret = rv3032_enter_eerd(rv3032, &eerd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rv3032->regmap, RV3032_CLKOUT1, hfd & 0xff);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tret = regmap_write(rv3032->regmap, RV3032_CLKOUT2, RV3032_CLKOUT2_OS |\n\t\t\t    FIELD_PREP(RV3032_CLKOUT2_HFD_MSK, hfd >> 8));\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tret = regmap_write(rv3032->regmap, RV3032_EEPROM_CMD, RV3032_EEPROM_CMD_UPDATE);\n\tif (ret)\n\t\tgoto exit_eerd;\n\n\tusleep_range(46000, RV3032_EEBUSY_TIMEOUT);\n\n\tret = regmap_read_poll_timeout(rv3032->regmap, RV3032_TLSB, status,\n\t\t\t\t       !(status & RV3032_TLSB_EEBUSY),\n\t\t\t\t       RV3032_EEBUSY_POLL, RV3032_EEBUSY_TIMEOUT);\n\nexit_eerd:\n\trv3032_exit_eerd(rv3032, eerd);\n\n\treturn ret;\n}\n\nstatic int rv3032_clkout_prepare(struct clk_hw *hw)\n{\n\tstruct rv3032_data *rv3032 = clkout_hw_to_rv3032(hw);\n\n\treturn rv3032_update_cfg(rv3032, RV3032_PMU, RV3032_PMU_NCLKE, 0);\n}\n\nstatic void rv3032_clkout_unprepare(struct clk_hw *hw)\n{\n\tstruct rv3032_data *rv3032 = clkout_hw_to_rv3032(hw);\n\n\trv3032_update_cfg(rv3032, RV3032_PMU, RV3032_PMU_NCLKE, RV3032_PMU_NCLKE);\n}\n\nstatic int rv3032_clkout_is_prepared(struct clk_hw *hw)\n{\n\tint val, ret;\n\tstruct rv3032_data *rv3032 = clkout_hw_to_rv3032(hw);\n\n\tret = regmap_read(rv3032->regmap, RV3032_PMU, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !(val & RV3032_PMU_NCLKE);\n}\n\nstatic const struct clk_ops rv3032_clkout_ops = {\n\t.prepare = rv3032_clkout_prepare,\n\t.unprepare = rv3032_clkout_unprepare,\n\t.is_prepared = rv3032_clkout_is_prepared,\n\t.recalc_rate = rv3032_clkout_recalc_rate,\n\t.round_rate = rv3032_clkout_round_rate,\n\t.set_rate = rv3032_clkout_set_rate,\n};\n\nstatic int rv3032_clkout_register_clk(struct rv3032_data *rv3032,\n\t\t\t\t      struct i2c_client *client)\n{\n\tint ret;\n\tstruct clk *clk;\n\tstruct clk_init_data init;\n\tstruct device_node *node = client->dev.of_node;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_TLSB, RV3032_TLSB_CLKF, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL2, RV3032_CTRL2_CLKIE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(rv3032->regmap, RV3032_CLK_IRQ, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit.name = \"rv3032-clkout\";\n\tinit.ops = &rv3032_clkout_ops;\n\tinit.flags = 0;\n\tinit.parent_names = NULL;\n\tinit.num_parents = 0;\n\trv3032->clkout_hw.init = &init;\n\n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\tclk = devm_clk_register(&client->dev, &rv3032->clkout_hw);\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(node, of_clk_src_simple_get, clk);\n\n\treturn 0;\n}\n#endif\n\nstatic int rv3032_hwmon_read_temp(struct device *dev, long *mC)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\tu8 buf[2];\n\tint temp, prev = 0;\n\tint ret;\n\n\tret = regmap_bulk_read(rv3032->regmap, RV3032_TLSB, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = sign_extend32(buf[1], 7) << 4;\n\ttemp |= FIELD_GET(RV3032_TLSB_TEMP, buf[0]);\n\n\t \n\tdo {\n\t\tprev = temp;\n\n\t\tret = regmap_bulk_read(rv3032->regmap, RV3032_TLSB, buf, sizeof(buf));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttemp = sign_extend32(buf[1], 7) << 4;\n\t\ttemp |= FIELD_GET(RV3032_TLSB_TEMP, buf[0]);\n\t} while (temp != prev);\n\n\t*mC = (temp * 1000) / 16;\n\n\treturn 0;\n}\n\nstatic umode_t rv3032_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int rv3032_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *temp)\n{\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\terr = rv3032_hwmon_read_temp(dev, temp);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct hwmon_channel_info * const rv3032_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST),\n\tNULL\n};\n\nstatic const struct hwmon_ops rv3032_hwmon_hwmon_ops = {\n\t.is_visible = rv3032_hwmon_is_visible,\n\t.read = rv3032_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info rv3032_hwmon_chip_info = {\n\t.ops = &rv3032_hwmon_hwmon_ops,\n\t.info = rv3032_hwmon_info,\n};\n\nstatic void rv3032_hwmon_register(struct device *dev)\n{\n\tstruct rv3032_data *rv3032 = dev_get_drvdata(dev);\n\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn;\n\n\tdevm_hwmon_device_register_with_info(dev, \"rv3032\", rv3032, &rv3032_hwmon_chip_info, NULL);\n}\n\nstatic const struct rtc_class_ops rv3032_rtc_ops = {\n\t.read_time = rv3032_get_time,\n\t.set_time = rv3032_set_time,\n\t.read_offset = rv3032_read_offset,\n\t.set_offset = rv3032_set_offset,\n\t.ioctl = rv3032_ioctl,\n\t.read_alarm = rv3032_get_alarm,\n\t.set_alarm = rv3032_set_alarm,\n\t.alarm_irq_enable = rv3032_alarm_irq_enable,\n\t.param_get = rv3032_param_get,\n\t.param_set = rv3032_param_set,\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xCA,\n};\n\nstatic int rv3032_probe(struct i2c_client *client)\n{\n\tstruct rv3032_data *rv3032;\n\tint ret, status;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"rv3032_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = 16,\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.reg_read = rv3032_nvram_read,\n\t\t.reg_write = rv3032_nvram_write,\n\t};\n\tstruct nvmem_config eeprom_cfg = {\n\t\t.name = \"rv3032_eeprom\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = 32,\n\t\t.type = NVMEM_TYPE_EEPROM,\n\t\t.reg_read = rv3032_eeprom_read,\n\t\t.reg_write = rv3032_eeprom_write,\n\t};\n\n\trv3032 = devm_kzalloc(&client->dev, sizeof(struct rv3032_data),\n\t\t\t      GFP_KERNEL);\n\tif (!rv3032)\n\t\treturn -ENOMEM;\n\n\trv3032->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(rv3032->regmap))\n\t\treturn PTR_ERR(rv3032->regmap);\n\n\ti2c_set_clientdata(client, rv3032);\n\n\tret = regmap_read(rv3032->regmap, RV3032_STATUS, &status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trv3032->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(rv3032->rtc))\n\t\treturn PTR_ERR(rv3032->rtc);\n\n\tif (client->irq > 0) {\n\t\tunsigned long irqflags = IRQF_TRIGGER_LOW;\n\n\t\tif (dev_fwnode(&client->dev))\n\t\t\tirqflags = 0;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, rv3032_handle_irq,\n\t\t\t\t\t\tirqflags | IRQF_ONESHOT,\n\t\t\t\t\t\t\"rv3032\", rv3032);\n\t\tif (ret) {\n\t\t\tdev_warn(&client->dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\tif (!client->irq)\n\t\tclear_bit(RTC_FEATURE_ALARM, rv3032->rtc->features);\n\n\tret = regmap_update_bits(rv3032->regmap, RV3032_CTRL1,\n\t\t\t\t RV3032_CTRL1_WADA, RV3032_CTRL1_WADA);\n\tif (ret)\n\t\treturn ret;\n\n\trv3032_trickle_charger_setup(&client->dev, rv3032);\n\n\tset_bit(RTC_FEATURE_BACKUP_SWITCH_MODE, rv3032->rtc->features);\n\tset_bit(RTC_FEATURE_ALARM_RES_MINUTE, rv3032->rtc->features);\n\n\trv3032->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\trv3032->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\trv3032->rtc->ops = &rv3032_rtc_ops;\n\tret = devm_rtc_register_device(rv3032->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\tnvmem_cfg.priv = rv3032->regmap;\n\tdevm_rtc_nvmem_register(rv3032->rtc, &nvmem_cfg);\n\teeprom_cfg.priv = rv3032;\n\tdevm_rtc_nvmem_register(rv3032->rtc, &eeprom_cfg);\n\n\trv3032->rtc->max_user_freq = 1;\n\n#ifdef CONFIG_COMMON_CLK\n\trv3032_clkout_register_clk(rv3032, client);\n#endif\n\n\trv3032_hwmon_register(&client->dev);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id rv3032_i2c_acpi_match[] = {\n\t{ \"MCRY3032\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rv3032_i2c_acpi_match);\n\nstatic const __maybe_unused struct of_device_id rv3032_of_match[] = {\n\t{ .compatible = \"microcrystal,rv3032\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rv3032_of_match);\n\nstatic struct i2c_driver rv3032_driver = {\n\t.driver = {\n\t\t.name = \"rtc-rv3032\",\n\t\t.acpi_match_table = rv3032_i2c_acpi_match,\n\t\t.of_match_table = of_match_ptr(rv3032_of_match),\n\t},\n\t.probe\t\t= rv3032_probe,\n};\nmodule_i2c_driver(rv3032_driver);\n\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_DESCRIPTION(\"Micro Crystal RV3032 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}