{
  "module_name": "rtc-brcmstb-waketimer.c",
  "hash_id": "e18be664b049872603fa8b8622d6739b3cc73ef5a5af3a12a850bf69d4b06c50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-brcmstb-waketimer.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeup.h>\n#include <linux/reboot.h>\n#include <linux/rtc.h>\n#include <linux/stat.h>\n#include <linux/suspend.h>\n\nstruct brcmstb_waketmr {\n\tstruct rtc_device *rtc;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned int wake_irq;\n\tunsigned int alarm_irq;\n\tstruct notifier_block reboot_notifier;\n\tstruct clk *clk;\n\tu32 rate;\n\tunsigned long rtc_alarm;\n\tbool alarm_en;\n\tbool alarm_expired;\n};\n\n#define BRCMSTB_WKTMR_EVENT\t\t0x00\n#define  WKTMR_ALARM_EVENT\t\tBIT(0)\n#define BRCMSTB_WKTMR_COUNTER\t\t0x04\n#define BRCMSTB_WKTMR_ALARM\t\t0x08\n#define BRCMSTB_WKTMR_PRESCALER\t\t0x0C\n#define BRCMSTB_WKTMR_PRESCALER_VAL\t0x10\n\n#define BRCMSTB_WKTMR_DEFAULT_FREQ\t27000000\n\nstatic inline bool brcmstb_waketmr_is_pending(struct brcmstb_waketmr *timer)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(timer->base + BRCMSTB_WKTMR_EVENT);\n\treturn !!(reg & WKTMR_ALARM_EVENT);\n}\n\nstatic inline void brcmstb_waketmr_clear_alarm(struct brcmstb_waketmr *timer)\n{\n\tu32 reg;\n\n\tif (timer->alarm_en && timer->alarm_irq)\n\t\tdisable_irq(timer->alarm_irq);\n\ttimer->alarm_en = false;\n\treg = readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER);\n\twritel_relaxed(reg - 1, timer->base + BRCMSTB_WKTMR_ALARM);\n\twritel_relaxed(WKTMR_ALARM_EVENT, timer->base + BRCMSTB_WKTMR_EVENT);\n\t(void)readl_relaxed(timer->base + BRCMSTB_WKTMR_EVENT);\n\tif (timer->alarm_expired) {\n\t\ttimer->alarm_expired = false;\n\t\t \n\t\tenable_irq(timer->alarm_irq);\n\t}\n}\n\nstatic void brcmstb_waketmr_set_alarm(struct brcmstb_waketmr *timer,\n\t\t\t\t      unsigned int secs)\n{\n\tunsigned int now;\n\n\tbrcmstb_waketmr_clear_alarm(timer);\n\n\t \n\twritel_relaxed(timer->rate, timer->base + BRCMSTB_WKTMR_PRESCALER);\n\n\twritel_relaxed(secs, timer->base + BRCMSTB_WKTMR_ALARM);\n\tnow = readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER);\n\n\twhile ((int)(secs - now) <= 0 &&\n\t\t!brcmstb_waketmr_is_pending(timer)) {\n\t\tsecs = now + 1;\n\t\twritel_relaxed(secs, timer->base + BRCMSTB_WKTMR_ALARM);\n\t\tnow = readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER);\n\t}\n}\n\nstatic irqreturn_t brcmstb_waketmr_irq(int irq, void *data)\n{\n\tstruct brcmstb_waketmr *timer = data;\n\n\tif (!timer->alarm_irq)\n\t\tpm_wakeup_event(timer->dev, 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t brcmstb_alarm_irq(int irq, void *data)\n{\n\tstruct brcmstb_waketmr *timer = data;\n\n\t \n\tif (!brcmstb_waketmr_is_pending(timer))\n\t\treturn IRQ_HANDLED;\n\n\tif (timer->alarm_en) {\n\t\tif (device_may_wakeup(timer->dev)) {\n\t\t\tdisable_irq_nosync(irq);\n\t\t\ttimer->alarm_expired = true;\n\t\t} else {\n\t\t\twritel_relaxed(WKTMR_ALARM_EVENT,\n\t\t\t\t       timer->base + BRCMSTB_WKTMR_EVENT);\n\t\t}\n\t\trtc_update_irq(timer->rtc, 1, RTC_IRQF | RTC_AF);\n\t} else {\n\t\twritel_relaxed(WKTMR_ALARM_EVENT,\n\t\t\t       timer->base + BRCMSTB_WKTMR_EVENT);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstruct wktmr_time {\n\tu32 sec;\n\tu32 pre;\n};\n\nstatic void wktmr_read(struct brcmstb_waketmr *timer,\n\t\t       struct wktmr_time *t)\n{\n\tu32 tmp;\n\n\tdo {\n\t\tt->sec = readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER);\n\t\ttmp = readl_relaxed(timer->base + BRCMSTB_WKTMR_PRESCALER_VAL);\n\t} while (tmp >= timer->rate);\n\n\tt->pre = timer->rate - tmp;\n}\n\nstatic int brcmstb_waketmr_prepare_suspend(struct brcmstb_waketmr *timer)\n{\n\tstruct device *dev = timer->dev;\n\tint ret;\n\n\tif (device_may_wakeup(dev)) {\n\t\tret = enable_irq_wake(timer->wake_irq);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable wake-up interrupt\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (timer->alarm_en && timer->alarm_irq) {\n\t\t\tret = enable_irq_wake(timer->alarm_irq);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"failed to enable rtc interrupt\\n\");\n\t\t\t\tdisable_irq_wake(timer->wake_irq);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int brcmstb_waketmr_reboot(struct notifier_block *nb,\n\t\tunsigned long action, void *data)\n{\n\tstruct brcmstb_waketmr *timer;\n\n\ttimer = container_of(nb, struct brcmstb_waketmr, reboot_notifier);\n\n\t \n\tif (action == SYS_POWER_OFF)\n\t\tbrcmstb_waketmr_prepare_suspend(timer);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int brcmstb_waketmr_gettime(struct device *dev,\n\t\t\t\t   struct rtc_time *tm)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\tstruct wktmr_time now;\n\n\twktmr_read(timer, &now);\n\n\trtc_time64_to_tm(now.sec, tm);\n\n\treturn 0;\n}\n\nstatic int brcmstb_waketmr_settime(struct device *dev,\n\t\t\t\t   struct rtc_time *tm)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\ttime64_t sec;\n\n\tsec = rtc_tm_to_time64(tm);\n\n\twritel_relaxed(sec, timer->base + BRCMSTB_WKTMR_COUNTER);\n\n\treturn 0;\n}\n\nstatic int brcmstb_waketmr_getalarm(struct device *dev,\n\t\t\t\t    struct rtc_wkalrm *alarm)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\n\talarm->enabled = timer->alarm_en;\n\trtc_time64_to_tm(timer->rtc_alarm, &alarm->time);\n\n\talarm->pending = brcmstb_waketmr_is_pending(timer);\n\n\treturn 0;\n}\n\nstatic int brcmstb_waketmr_alarm_enable(struct device *dev,\n\t\t\t\t\tunsigned int enabled)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\n\tif (enabled && !timer->alarm_en) {\n\t\tif ((int)(readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER) -\n\t\t    readl_relaxed(timer->base + BRCMSTB_WKTMR_ALARM)) >= 0 &&\n\t\t    !brcmstb_waketmr_is_pending(timer))\n\t\t\treturn -EINVAL;\n\t\ttimer->alarm_en = true;\n\t\tif (timer->alarm_irq) {\n\t\t\tif (timer->alarm_expired) {\n\t\t\t\ttimer->alarm_expired = false;\n\t\t\t\t \n\t\t\t\tenable_irq(timer->alarm_irq);\n\t\t\t}\n\t\t\tenable_irq(timer->alarm_irq);\n\t\t}\n\t} else if (!enabled && timer->alarm_en) {\n\t\tif (timer->alarm_irq)\n\t\t\tdisable_irq(timer->alarm_irq);\n\t\ttimer->alarm_en = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmstb_waketmr_setalarm(struct device *dev,\n\t\t\t\t     struct rtc_wkalrm *alarm)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\n\ttimer->rtc_alarm = rtc_tm_to_time64(&alarm->time);\n\n\tbrcmstb_waketmr_set_alarm(timer, timer->rtc_alarm);\n\n\treturn brcmstb_waketmr_alarm_enable(dev, alarm->enabled);\n}\n\nstatic const struct rtc_class_ops brcmstb_waketmr_ops = {\n\t.read_time\t= brcmstb_waketmr_gettime,\n\t.set_time\t= brcmstb_waketmr_settime,\n\t.read_alarm\t= brcmstb_waketmr_getalarm,\n\t.set_alarm\t= brcmstb_waketmr_setalarm,\n\t.alarm_irq_enable = brcmstb_waketmr_alarm_enable,\n};\n\nstatic int brcmstb_waketmr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct brcmstb_waketmr *timer;\n\tint ret;\n\n\ttimer = devm_kzalloc(dev, sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, timer);\n\ttimer->dev = dev;\n\n\ttimer->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(timer->base))\n\t\treturn PTR_ERR(timer->base);\n\n\ttimer->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(timer->rtc))\n\t\treturn PTR_ERR(timer->rtc);\n\n\t \n\tdevice_init_wakeup(dev, true);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\ttimer->wake_irq = (unsigned int)ret;\n\n\ttimer->clk = devm_clk_get(dev, NULL);\n\tif (!IS_ERR(timer->clk)) {\n\t\tret = clk_prepare_enable(timer->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttimer->rate = clk_get_rate(timer->clk);\n\t\tif (!timer->rate)\n\t\t\ttimer->rate = BRCMSTB_WKTMR_DEFAULT_FREQ;\n\t} else {\n\t\ttimer->rate = BRCMSTB_WKTMR_DEFAULT_FREQ;\n\t\ttimer->clk = NULL;\n\t}\n\n\tret = devm_request_irq(dev, timer->wake_irq, brcmstb_waketmr_irq, 0,\n\t\t\t       \"brcmstb-waketimer\", timer);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tbrcmstb_waketmr_clear_alarm(timer);\n\n\t \n\tret = platform_get_irq(pdev, 1);\n\tif (ret > 0) {\n\t\ttimer->alarm_irq = (unsigned int)ret;\n\t\tret = devm_request_irq(dev, timer->alarm_irq, brcmstb_alarm_irq,\n\t\t\t\t       IRQF_NO_AUTOEN, \"brcmstb-waketimer-rtc\",\n\t\t\t\t       timer);\n\t\tif (ret < 0)\n\t\t\ttimer->alarm_irq = 0;\n\t}\n\n\ttimer->reboot_notifier.notifier_call = brcmstb_waketmr_reboot;\n\tregister_reboot_notifier(&timer->reboot_notifier);\n\n\ttimer->rtc->ops = &brcmstb_waketmr_ops;\n\ttimer->rtc->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(timer->rtc);\n\tif (ret)\n\t\tgoto err_notifier;\n\n\treturn 0;\n\nerr_notifier:\n\tunregister_reboot_notifier(&timer->reboot_notifier);\n\nerr_clk:\n\tclk_disable_unprepare(timer->clk);\n\n\treturn ret;\n}\n\nstatic void brcmstb_waketmr_remove(struct platform_device *pdev)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(&pdev->dev);\n\n\tunregister_reboot_notifier(&timer->reboot_notifier);\n\tclk_disable_unprepare(timer->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int brcmstb_waketmr_suspend(struct device *dev)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\n\treturn brcmstb_waketmr_prepare_suspend(timer);\n}\n\nstatic int brcmstb_waketmr_suspend_noirq(struct device *dev)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\n\t \n\tif (timer->alarm_expired && device_may_wakeup(dev))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int brcmstb_waketmr_resume(struct device *dev)\n{\n\tstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!device_may_wakeup(dev))\n\t\treturn 0;\n\n\tret = disable_irq_wake(timer->wake_irq);\n\tif (timer->alarm_en && timer->alarm_irq)\n\t\tdisable_irq_wake(timer->alarm_irq);\n\n\tbrcmstb_waketmr_clear_alarm(timer);\n\n\treturn ret;\n}\n#else\n#define brcmstb_waketmr_suspend\t\tNULL\n#define brcmstb_waketmr_suspend_noirq\tNULL\n#define brcmstb_waketmr_resume\t\tNULL\n#endif  \n\nstatic const struct dev_pm_ops brcmstb_waketmr_pm_ops = {\n\t.suspend\t= brcmstb_waketmr_suspend,\n\t.suspend_noirq\t= brcmstb_waketmr_suspend_noirq,\n\t.resume\t\t= brcmstb_waketmr_resume,\n};\n\nstatic const __maybe_unused struct of_device_id brcmstb_waketmr_of_match[] = {\n\t{ .compatible = \"brcm,brcmstb-waketimer\" },\n\t{   },\n};\n\nstatic struct platform_driver brcmstb_waketmr_driver = {\n\t.probe\t\t\t= brcmstb_waketmr_probe,\n\t.remove_new\t\t= brcmstb_waketmr_remove,\n\t.driver = {\n\t\t.name\t\t= \"brcmstb-waketimer\",\n\t\t.pm\t\t= &brcmstb_waketmr_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(brcmstb_waketmr_of_match),\n\t}\n};\nmodule_platform_driver(brcmstb_waketmr_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_AUTHOR(\"Markus Mayer\");\nMODULE_AUTHOR(\"Doug Berger\");\nMODULE_DESCRIPTION(\"Wake-up timer driver for STB chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}