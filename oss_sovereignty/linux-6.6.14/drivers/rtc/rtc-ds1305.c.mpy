{
  "module_name": "rtc-ds1305.c",
  "hash_id": "a78c43642dc8fa2e8a6ebeaf9bf2b4c7abc74c898c7233bc4e94ef1d9fef5f8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ds1305.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/workqueue.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/ds1305.h>\n#include <linux/module.h>\n\n\n \n#define DS1305_WRITE\t\t0x80\n\n\n \n#define DS1305_RTC_LEN\t\t7\t\t \n\n#define DS1305_SEC\t\t0x00\t\t \n#define DS1305_MIN\t\t0x01\n#define DS1305_HOUR\t\t0x02\n#\tdefine DS1305_HR_12\t\t0x40\t \n#\tdefine DS1305_HR_PM\t\t0x20\t \n#define DS1305_WDAY\t\t0x03\n#define DS1305_MDAY\t\t0x04\n#define DS1305_MON\t\t0x05\n#define DS1305_YEAR\t\t0x06\n\n\n \n#define DS1305_ALM_LEN\t\t4\t\t \n#define DS1305_ALM_DISABLE\t0x80\n\n#define DS1305_ALM0(r)\t\t(0x07 + (r))\t \n#define DS1305_ALM1(r)\t\t(0x0b + (r))\n\n\n \n#define DS1305_CONTROL_LEN\t3\t\t \n\n#define DS1305_CONTROL\t\t0x0f\t\t \n#\tdefine DS1305_nEOSC\t\t0x80\t \n#\tdefine DS1305_WP\t\t0x40\t \n#\tdefine DS1305_INTCN\t\t0x04\t \n#\tdefine DS1306_1HZ\t\t0x04\t \n#\tdefine DS1305_AEI1\t\t0x02\t \n#\tdefine DS1305_AEI0\t\t0x01\t \n#define DS1305_STATUS\t\t0x10\n \n#define DS1305_TRICKLE\t\t0x11\n \n\n \n#define DS1305_NVRAM_LEN\t96\t\t \n\n#define DS1305_NVRAM\t\t0x20\t\t \n\n\nstruct ds1305 {\n\tstruct spi_device\t*spi;\n\tstruct rtc_device\t*rtc;\n\n\tstruct work_struct\twork;\n\n\tunsigned long\t\tflags;\n#define FLAG_EXITING\t0\n\n\tbool\t\t\thr12;\n\tu8\t\t\tctrl[DS1305_CONTROL_LEN];\n};\n\n\n \n\n \n\nstatic unsigned bcd2hour(u8 bcd)\n{\n\tif (bcd & DS1305_HR_12) {\n\t\tunsigned\thour = 0;\n\n\t\tbcd &= ~DS1305_HR_12;\n\t\tif (bcd & DS1305_HR_PM) {\n\t\t\thour = 12;\n\t\t\tbcd &= ~DS1305_HR_PM;\n\t\t}\n\t\thour += bcd2bin(bcd);\n\t\treturn hour - 1;\n\t}\n\treturn bcd2bin(bcd);\n}\n\nstatic u8 hour2bcd(bool hr12, int hour)\n{\n\tif (hr12) {\n\t\thour++;\n\t\tif (hour <= 12)\n\t\t\treturn DS1305_HR_12 | bin2bcd(hour);\n\t\thour -= 12;\n\t\treturn DS1305_HR_12 | DS1305_HR_PM | bin2bcd(hour);\n\t}\n\treturn bin2bcd(hour);\n}\n\n \n\n \n\nstatic int ds1305_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\tbuf[2];\n\tlong\t\terr = -EINVAL;\n\n\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\tbuf[1] = ds1305->ctrl[0];\n\n\tif (enabled) {\n\t\tif (ds1305->ctrl[0] & DS1305_AEI0)\n\t\t\tgoto done;\n\t\tbuf[1] |= DS1305_AEI0;\n\t} else {\n\t\tif (!(buf[1] & DS1305_AEI0))\n\t\t\tgoto done;\n\t\tbuf[1] &= ~DS1305_AEI0;\n\t}\n\terr = spi_write_then_read(ds1305->spi, buf, sizeof(buf), NULL, 0);\n\tif (err >= 0)\n\t\tds1305->ctrl[0] = buf[1];\ndone:\n\treturn err;\n\n}\n\n\n \n\nstatic int ds1305_get_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\taddr = DS1305_SEC;\n\tu8\t\tbuf[DS1305_RTC_LEN];\n\tint\t\tstatus;\n\n\t \n\tstatus = spi_write_then_read(ds1305->spi, &addr, sizeof(addr),\n\t\t\tbuf, sizeof(buf));\n\tif (status < 0)\n\t\treturn status;\n\n\tdev_vdbg(dev, \"%s: %3ph, %4ph\\n\", \"read\", &buf[0], &buf[3]);\n\n\t \n\ttime->tm_sec = bcd2bin(buf[DS1305_SEC]);\n\ttime->tm_min = bcd2bin(buf[DS1305_MIN]);\n\ttime->tm_hour = bcd2hour(buf[DS1305_HOUR]);\n\ttime->tm_wday = buf[DS1305_WDAY] - 1;\n\ttime->tm_mday = bcd2bin(buf[DS1305_MDAY]);\n\ttime->tm_mon = bcd2bin(buf[DS1305_MON]) - 1;\n\ttime->tm_year = bcd2bin(buf[DS1305_YEAR]) + 100;\n\n\tdev_vdbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"read\", time->tm_sec, time->tm_min,\n\t\ttime->tm_hour, time->tm_mday,\n\t\ttime->tm_mon, time->tm_year, time->tm_wday);\n\n\treturn 0;\n}\n\nstatic int ds1305_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\tbuf[1 + DS1305_RTC_LEN];\n\tu8\t\t*bp = buf;\n\n\tdev_vdbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"write\", time->tm_sec, time->tm_min,\n\t\ttime->tm_hour, time->tm_mday,\n\t\ttime->tm_mon, time->tm_year, time->tm_wday);\n\n\t \n\t*bp++ = DS1305_WRITE | DS1305_SEC;\n\n\t*bp++ = bin2bcd(time->tm_sec);\n\t*bp++ = bin2bcd(time->tm_min);\n\t*bp++ = hour2bcd(ds1305->hr12, time->tm_hour);\n\t*bp++ = (time->tm_wday < 7) ? (time->tm_wday + 1) : 1;\n\t*bp++ = bin2bcd(time->tm_mday);\n\t*bp++ = bin2bcd(time->tm_mon + 1);\n\t*bp++ = bin2bcd(time->tm_year - 100);\n\n\tdev_dbg(dev, \"%s: %3ph, %4ph\\n\", \"write\", &buf[1], &buf[4]);\n\n\t \n\treturn spi_write_then_read(ds1305->spi, buf, sizeof(buf),\n\t\t\tNULL, 0);\n}\n\n \n\n \nstatic int ds1305_get_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tstruct spi_device *spi = ds1305->spi;\n\tu8\t\taddr;\n\tint\t\tstatus;\n\tu8\t\tbuf[DS1305_ALM_LEN];\n\n\t \n\taddr = DS1305_CONTROL;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tds1305->ctrl, sizeof(ds1305->ctrl));\n\tif (status < 0)\n\t\treturn status;\n\n\talm->enabled = !!(ds1305->ctrl[0] & DS1305_AEI0);\n\talm->pending = !!(ds1305->ctrl[1] & DS1305_AEI0);\n\n\t \n\taddr = DS1305_ALM0(DS1305_SEC);\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tbuf, sizeof(buf));\n\tif (status < 0)\n\t\treturn status;\n\n\tdev_vdbg(dev, \"%s: %02x %02x %02x %02x\\n\",\n\t\t\"alm0 read\", buf[DS1305_SEC], buf[DS1305_MIN],\n\t\tbuf[DS1305_HOUR], buf[DS1305_WDAY]);\n\n\tif ((DS1305_ALM_DISABLE & buf[DS1305_SEC])\n\t\t\t|| (DS1305_ALM_DISABLE & buf[DS1305_MIN])\n\t\t\t|| (DS1305_ALM_DISABLE & buf[DS1305_HOUR]))\n\t\treturn -EIO;\n\n\t \n\talm->time.tm_sec = bcd2bin(buf[DS1305_SEC]);\n\talm->time.tm_min = bcd2bin(buf[DS1305_MIN]);\n\talm->time.tm_hour = bcd2hour(buf[DS1305_HOUR]);\n\n\treturn 0;\n}\n\n \nstatic int ds1305_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tstruct spi_device *spi = ds1305->spi;\n\tunsigned long\tnow, later;\n\tstruct rtc_time\ttm;\n\tint\t\tstatus;\n\tu8\t\tbuf[1 + DS1305_ALM_LEN];\n\n\t \n\tlater = rtc_tm_to_time64(&alm->time);\n\n\t \n\tstatus = ds1305_get_time(dev, &tm);\n\tif (status < 0)\n\t\treturn status;\n\tnow = rtc_tm_to_time64(&tm);\n\n\t \n\tif (later <= now)\n\t\treturn -EINVAL;\n\tif ((later - now) > ds1305->rtc->alarm_offset_max)\n\t\treturn -ERANGE;\n\n\t \n\tif (ds1305->ctrl[0] & DS1305_AEI0) {\n\t\tds1305->ctrl[0] &= ~DS1305_AEI0;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t \n\tbuf[0] = DS1305_WRITE | DS1305_ALM0(DS1305_SEC);\n\tbuf[1 + DS1305_SEC] = bin2bcd(alm->time.tm_sec);\n\tbuf[1 + DS1305_MIN] = bin2bcd(alm->time.tm_min);\n\tbuf[1 + DS1305_HOUR] = hour2bcd(ds1305->hr12, alm->time.tm_hour);\n\tbuf[1 + DS1305_WDAY] = DS1305_ALM_DISABLE;\n\n\tdev_dbg(dev, \"%s: %02x %02x %02x %02x\\n\",\n\t\t\"alm0 write\", buf[1 + DS1305_SEC], buf[1 + DS1305_MIN],\n\t\tbuf[1 + DS1305_HOUR], buf[1 + DS1305_WDAY]);\n\n\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tif (alm->enabled) {\n\t\tds1305->ctrl[0] |= DS1305_AEI0;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\n\t}\n\n\treturn status;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic int ds1305_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tchar\t\t*diodes = \"no\";\n\tchar\t\t*resistors = \"\";\n\n\t \n\tif ((ds1305->ctrl[2] & 0xf0) == DS1305_TRICKLE_MAGIC) {\n\t\tswitch (ds1305->ctrl[2] & 0x0c) {\n\t\tcase DS1305_TRICKLE_DS2:\n\t\t\tdiodes = \"2 diodes, \";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_DS1:\n\t\t\tdiodes = \"1 diode, \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t\tswitch (ds1305->ctrl[2] & 0x03) {\n\t\tcase DS1305_TRICKLE_2K:\n\t\t\tresistors = \"2k Ohm\";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_4K:\n\t\t\tresistors = \"4k Ohm\";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_8K:\n\t\t\tresistors = \"8k Ohm\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdiodes = \"no\";\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tseq_printf(seq, \"trickle_charge\\t: %s%s\\n\", diodes, resistors);\n\n\treturn 0;\n}\n\n#else\n#define ds1305_proc\tNULL\n#endif\n\nstatic const struct rtc_class_ops ds1305_ops = {\n\t.read_time\t= ds1305_get_time,\n\t.set_time\t= ds1305_set_time,\n\t.read_alarm\t= ds1305_get_alarm,\n\t.set_alarm\t= ds1305_set_alarm,\n\t.proc\t\t= ds1305_proc,\n\t.alarm_irq_enable = ds1305_alarm_irq_enable,\n};\n\nstatic void ds1305_work(struct work_struct *work)\n{\n\tstruct ds1305\t*ds1305 = container_of(work, struct ds1305, work);\n\tstruct spi_device *spi = ds1305->spi;\n\tu8\t\tbuf[3];\n\tint\t\tstatus;\n\n\t \n\trtc_lock(ds1305->rtc);\n\n\t \n\tds1305->ctrl[0] &= ~(DS1305_AEI1 | DS1305_AEI0);\n\tds1305->ctrl[1] = 0;\n\n\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\tbuf[1] = ds1305->ctrl[0];\n\tbuf[2] = 0;\n\n\tstatus = spi_write_then_read(spi, buf, sizeof(buf),\n\t\t\tNULL, 0);\n\tif (status < 0)\n\t\tdev_dbg(&spi->dev, \"clear irq --> %d\\n\", status);\n\n\trtc_unlock(ds1305->rtc);\n\n\tif (!test_bit(FLAG_EXITING, &ds1305->flags))\n\t\tenable_irq(spi->irq);\n\n\trtc_update_irq(ds1305->rtc, 1, RTC_AF | RTC_IRQF);\n}\n\n \nstatic irqreturn_t ds1305_irq(int irq, void *p)\n{\n\tstruct ds1305\t\t*ds1305 = p;\n\n\tdisable_irq(irq);\n\tschedule_work(&ds1305->work);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\nstatic void msg_init(struct spi_message *m, struct spi_transfer *x,\n\t\tu8 *addr, size_t count, char *tx, char *rx)\n{\n\tspi_message_init(m);\n\tmemset(x, 0, 2 * sizeof(*x));\n\n\tx->tx_buf = addr;\n\tx->len = 1;\n\tspi_message_add_tail(x, m);\n\n\tx++;\n\n\tx->tx_buf = tx;\n\tx->rx_buf = rx;\n\tx->len = count;\n\tspi_message_add_tail(x, m);\n}\n\nstatic int ds1305_nvram_read(void *priv, unsigned int off, void *buf,\n\t\t\t     size_t count)\n{\n\tstruct ds1305\t\t*ds1305 = priv;\n\tstruct spi_device\t*spi = ds1305->spi;\n\tu8\t\t\taddr;\n\tstruct spi_message\tm;\n\tstruct spi_transfer\tx[2];\n\n\taddr = DS1305_NVRAM + off;\n\tmsg_init(&m, x, &addr, count, NULL, buf);\n\n\treturn spi_sync(spi, &m);\n}\n\nstatic int ds1305_nvram_write(void *priv, unsigned int off, void *buf,\n\t\t\t      size_t count)\n{\n\tstruct ds1305\t\t*ds1305 = priv;\n\tstruct spi_device\t*spi = ds1305->spi;\n\tu8\t\t\taddr;\n\tstruct spi_message\tm;\n\tstruct spi_transfer\tx[2];\n\n\taddr = (DS1305_WRITE | DS1305_NVRAM) + off;\n\tmsg_init(&m, x, &addr, count, buf, NULL);\n\n\treturn spi_sync(spi, &m);\n}\n\n \n\n \n\nstatic int ds1305_probe(struct spi_device *spi)\n{\n\tstruct ds1305\t\t\t*ds1305;\n\tint\t\t\t\tstatus;\n\tu8\t\t\t\taddr, value;\n\tstruct ds1305_platform_data\t*pdata = dev_get_platdata(&spi->dev);\n\tbool\t\t\t\twrite_ctrl = false;\n\tstruct nvmem_config ds1305_nvmem_cfg = {\n\t\t.name = \"ds1305_nvram\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.size = DS1305_NVRAM_LEN,\n\t\t.reg_read = ds1305_nvram_read,\n\t\t.reg_write = ds1305_nvram_write,\n\t};\n\n\t \n\tif ((spi->bits_per_word && spi->bits_per_word != 8)\n\t\t\t|| (spi->max_speed_hz > 2000000)\n\t\t\t|| !(spi->mode & SPI_CPHA))\n\t\treturn -EINVAL;\n\n\t \n\tds1305 = devm_kzalloc(&spi->dev, sizeof(*ds1305), GFP_KERNEL);\n\tif (!ds1305)\n\t\treturn -ENOMEM;\n\tds1305->spi = spi;\n\tspi_set_drvdata(spi, ds1305);\n\n\t \n\taddr = DS1305_CONTROL;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tds1305->ctrl, sizeof(ds1305->ctrl));\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"can't %s, %d\\n\",\n\t\t\t\t\"read\", status);\n\t\treturn status;\n\t}\n\n\tdev_dbg(&spi->dev, \"ctrl %s: %3ph\\n\", \"read\", ds1305->ctrl);\n\n\t \n\tif ((ds1305->ctrl[0] & 0x38) != 0 || (ds1305->ctrl[1] & 0xfc) != 0) {\n\t\tdev_dbg(&spi->dev, \"RTC chip is not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (ds1305->ctrl[2] == 0)\n\t\tdev_dbg(&spi->dev, \"chip may not be present\\n\");\n\n\t \n\tif (ds1305->ctrl[0] & DS1305_WP) {\n\t\tu8\t\tbuf[2];\n\n\t\tds1305->ctrl[0] &= ~DS1305_WP;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\n\t\tdev_dbg(&spi->dev, \"clear WP --> %d\\n\", status);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t \n\tif (ds1305->ctrl[0] & DS1305_nEOSC) {\n\t\tds1305->ctrl[0] &= ~DS1305_nEOSC;\n\t\twrite_ctrl = true;\n\t\tdev_warn(&spi->dev, \"SET TIME!\\n\");\n\t}\n\n\t \n\tif (ds1305->ctrl[1]) {\n\t\tds1305->ctrl[1] = 0;\n\t\twrite_ctrl = true;\n\t}\n\n\t \n\tif (pdata) {\n\t\t \n\t\tif (((ds1305->ctrl[2] & 0xf0) != DS1305_TRICKLE_MAGIC)) {\n\t\t\tds1305->ctrl[2] = DS1305_TRICKLE_MAGIC\n\t\t\t\t\t\t| pdata->trickle;\n\t\t\twrite_ctrl = true;\n\t\t}\n\n\t\t \n\t\tif (pdata->is_ds1306) {\n\t\t\tif (pdata->en_1hz) {\n\t\t\t\tif (!(ds1305->ctrl[0] & DS1306_1HZ)) {\n\t\t\t\t\tds1305->ctrl[0] |= DS1306_1HZ;\n\t\t\t\t\twrite_ctrl = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ds1305->ctrl[0] & DS1306_1HZ) {\n\t\t\t\t\tds1305->ctrl[0] &= ~DS1306_1HZ;\n\t\t\t\t\twrite_ctrl = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (write_ctrl) {\n\t\tu8\t\tbuf[4];\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tbuf[2] = ds1305->ctrl[1];\n\t\tbuf[3] = ds1305->ctrl[2];\n\t\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&spi->dev, \"can't %s, %d\\n\",\n\t\t\t\t\t\"write\", status);\n\t\t\treturn status;\n\t\t}\n\n\t\tdev_dbg(&spi->dev, \"ctrl %s: %3ph\\n\", \"write\", ds1305->ctrl);\n\t}\n\n\t \n\taddr = DS1305_HOUR;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\t\t&value, sizeof(value));\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"read HOUR --> %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tds1305->hr12 = (DS1305_HR_12 & value) != 0;\n\tif (ds1305->hr12)\n\t\tdev_dbg(&spi->dev, \"AM/PM\\n\");\n\n\t \n\tds1305->rtc = devm_rtc_allocate_device(&spi->dev);\n\tif (IS_ERR(ds1305->rtc))\n\t\treturn PTR_ERR(ds1305->rtc);\n\n\tds1305->rtc->ops = &ds1305_ops;\n\tds1305->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tds1305->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tds1305->rtc->alarm_offset_max = 24 * 60 * 60;\n\n\tds1305_nvmem_cfg.priv = ds1305;\n\tstatus = devm_rtc_register_device(ds1305->rtc);\n\tif (status)\n\t\treturn status;\n\n\tdevm_rtc_nvmem_register(ds1305->rtc, &ds1305_nvmem_cfg);\n\n\t \n\tif (spi->irq) {\n\t\tINIT_WORK(&ds1305->work, ds1305_work);\n\t\tstatus = devm_request_irq(&spi->dev, spi->irq, ds1305_irq,\n\t\t\t\t0, dev_name(&ds1305->rtc->dev), ds1305);\n\t\tif (status < 0) {\n\t\t\tdev_err(&spi->dev, \"request_irq %d --> %d\\n\",\n\t\t\t\t\tspi->irq, status);\n\t\t} else {\n\t\t\tdevice_set_wakeup_capable(&spi->dev, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ds1305_remove(struct spi_device *spi)\n{\n\tstruct ds1305 *ds1305 = spi_get_drvdata(spi);\n\n\t \n\tif (spi->irq) {\n\t\tset_bit(FLAG_EXITING, &ds1305->flags);\n\t\tdevm_free_irq(&spi->dev, spi->irq, ds1305);\n\t\tcancel_work_sync(&ds1305->work);\n\t}\n}\n\nstatic struct spi_driver ds1305_driver = {\n\t.driver.name\t= \"rtc-ds1305\",\n\t.probe\t\t= ds1305_probe,\n\t.remove\t\t= ds1305_remove,\n\t \n};\n\nmodule_spi_driver(ds1305_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for DS1305 and DS1306 chips\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:rtc-ds1305\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}