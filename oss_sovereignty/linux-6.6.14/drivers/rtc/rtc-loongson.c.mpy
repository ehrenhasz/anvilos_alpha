{
  "module_name": "rtc-loongson.c",
  "hash_id": "27fb9eb8a54b73cae71049f3b854fcdf695e99fb4f25044b1631db834f91a729",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-loongson.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n#include <linux/acpi.h>\n\n \n#define TOY_TRIM_REG\t\t0x20  \n#define TOY_WRITE0_REG\t\t0x24  \n#define TOY_WRITE1_REG\t\t0x28  \n#define TOY_READ0_REG\t\t0x2c  \n#define TOY_READ1_REG\t\t0x30  \n#define TOY_MATCH0_REG\t\t0x34  \n#define TOY_MATCH1_REG\t\t0x38  \n#define TOY_MATCH2_REG\t\t0x3c  \n\n \n#define RTC_CTRL_REG\t\t0x40  \n#define RTC_TRIM_REG\t\t0x60  \n#define RTC_WRITE0_REG\t\t0x64  \n#define RTC_READ0_REG\t\t0x68  \n#define RTC_MATCH0_REG\t\t0x6c  \n#define RTC_MATCH1_REG\t\t0x70  \n#define RTC_MATCH2_REG\t\t0x74  \n\n \n#define TOY_MON\t\t\tGENMASK(31, 26)\n#define TOY_DAY\t\t\tGENMASK(25, 21)\n#define TOY_HOUR\t\tGENMASK(20, 16)\n#define TOY_MIN\t\t\tGENMASK(15, 10)\n#define TOY_SEC\t\t\tGENMASK(9, 4)\n#define TOY_MSEC\t\tGENMASK(3, 0)\n\n \n#define TOY_MATCH_YEAR\t\tGENMASK(31, 26)\n#define TOY_MATCH_MON\t\tGENMASK(25, 22)\n#define TOY_MATCH_DAY\t\tGENMASK(21, 17)\n#define TOY_MATCH_HOUR\t\tGENMASK(16, 12)\n#define TOY_MATCH_MIN\t\tGENMASK(11, 6)\n#define TOY_MATCH_SEC\t\tGENMASK(5, 0)\n\n \n#define RTC_ENABLE\t\tBIT(13)  \n#define TOY_ENABLE\t\tBIT(11)  \n#define OSC_ENABLE\t\tBIT(8)  \n#define TOY_ENABLE_MASK\t\t(TOY_ENABLE | OSC_ENABLE)\n\n \n#define PM1_STS_REG\t\t0x0c\t \n#define RTC_STS\t\t\tBIT(10)\t \n#define PM1_EN_REG\t\t0x10\t \n#define RTC_EN\t\t\tBIT(10)\t \n\n \n#define LS1C_RTC_CTRL_WORKAROUND\tBIT(0)\n\nstruct loongson_rtc_config {\n\tu32 pm_offset;\t \n\tu32 flags;\t \n};\n\nstruct loongson_rtc_priv {\n\tspinlock_t lock;\t \n\tu32 fix_year;\t\t \n\tstruct rtc_device *rtcdev;\n\tstruct regmap *regmap;\n\tvoid __iomem *pm_base;\t \n\tconst struct loongson_rtc_config *config;\n};\n\nstatic const struct loongson_rtc_config ls1b_rtc_config = {\n\t.pm_offset = 0,\n\t.flags = 0,\n};\n\nstatic const struct loongson_rtc_config ls1c_rtc_config = {\n\t.pm_offset = 0,\n\t.flags = LS1C_RTC_CTRL_WORKAROUND,\n};\n\nstatic const struct loongson_rtc_config generic_rtc_config = {\n\t.pm_offset = 0x100,\n\t.flags = 0,\n};\n\nstatic const struct loongson_rtc_config ls2k1000_rtc_config = {\n\t.pm_offset = 0x800,\n\t.flags = 0,\n};\n\nstatic const struct regmap_config loongson_rtc_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\n \nstatic irqreturn_t loongson_rtc_isr(int irq, void *id)\n{\n\tstruct loongson_rtc_priv *priv = (struct loongson_rtc_priv *)id;\n\n\trtc_update_irq(priv->rtcdev, 1, RTC_AF | RTC_IRQF);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic u32 loongson_rtc_handler(void *id)\n{\n\tstruct loongson_rtc_priv *priv = (struct loongson_rtc_priv *)id;\n\n\tspin_lock(&priv->lock);\n\t \n\twritel(readl(priv->pm_base + PM1_EN_REG) & ~RTC_EN,\n\t       priv->pm_base + PM1_EN_REG);\n\n\t \n\twritel(RTC_STS, priv->pm_base + PM1_STS_REG);\n\tspin_unlock(&priv->lock);\n\n\t \n\treturn regmap_write(priv->regmap, TOY_MATCH0_REG, 0);\n}\n\nstatic int loongson_rtc_set_enabled(struct device *dev)\n{\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tif (priv->config->flags & LS1C_RTC_CTRL_WORKAROUND)\n\t\treturn 0;\n\n\t \n\treturn regmap_update_bits(priv->regmap, RTC_CTRL_REG, TOY_ENABLE_MASK,\n\t\t\t\t  TOY_ENABLE_MASK);\n}\n\nstatic bool loongson_rtc_get_enabled(struct device *dev)\n{\n\tint ret;\n\tu32 ctrl_data;\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tif (priv->config->flags & LS1C_RTC_CTRL_WORKAROUND)\n\t\treturn true;\n\n\tret = regmap_read(priv->regmap, RTC_CTRL_REG, &ctrl_data);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn ctrl_data & TOY_ENABLE_MASK;\n}\n\nstatic int loongson_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tint ret;\n\tu32 rtc_data[2];\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tif (!loongson_rtc_get_enabled(dev))\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_read(priv->regmap, TOY_READ0_REG, rtc_data,\n\t\t\t       ARRAY_SIZE(rtc_data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttm->tm_sec = FIELD_GET(TOY_SEC, rtc_data[0]);\n\ttm->tm_min = FIELD_GET(TOY_MIN, rtc_data[0]);\n\ttm->tm_hour = FIELD_GET(TOY_HOUR, rtc_data[0]);\n\ttm->tm_mday = FIELD_GET(TOY_DAY, rtc_data[0]);\n\ttm->tm_mon = FIELD_GET(TOY_MON, rtc_data[0]) - 1;\n\ttm->tm_year = rtc_data[1];\n\n\t \n\tpriv->fix_year = tm->tm_year / 64 * 64;\n\treturn 0;\n}\n\nstatic int loongson_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tint ret;\n\tu32 rtc_data[2];\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\trtc_data[0] = FIELD_PREP(TOY_SEC, tm->tm_sec)\n\t\t    | FIELD_PREP(TOY_MIN, tm->tm_min)\n\t\t    | FIELD_PREP(TOY_HOUR, tm->tm_hour)\n\t\t    | FIELD_PREP(TOY_DAY, tm->tm_mday)\n\t\t    | FIELD_PREP(TOY_MON, tm->tm_mon + 1);\n\trtc_data[1] = tm->tm_year;\n\n\tret = regmap_bulk_write(priv->regmap, TOY_WRITE0_REG, rtc_data,\n\t\t\t\tARRAY_SIZE(rtc_data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn loongson_rtc_set_enabled(dev);\n}\n\nstatic int loongson_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tu32 alarm_data;\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tret = regmap_read(priv->regmap, TOY_MATCH0_REG, &alarm_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talrm->time.tm_sec = FIELD_GET(TOY_MATCH_SEC, alarm_data);\n\talrm->time.tm_min = FIELD_GET(TOY_MATCH_MIN, alarm_data);\n\talrm->time.tm_hour = FIELD_GET(TOY_MATCH_HOUR, alarm_data);\n\talrm->time.tm_mday = FIELD_GET(TOY_MATCH_DAY, alarm_data);\n\talrm->time.tm_mon = FIELD_GET(TOY_MATCH_MON, alarm_data) - 1;\n\t \n\talrm->time.tm_year = FIELD_GET(TOY_MATCH_YEAR, alarm_data) + priv->fix_year;\n\n\talrm->enabled = !!(readl(priv->pm_base + PM1_EN_REG) & RTC_EN);\n\treturn 0;\n}\n\nstatic int loongson_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tu32 val;\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tspin_lock(&priv->lock);\n\tval = readl(priv->pm_base + PM1_EN_REG);\n\t \n\twritel(enabled ? val | RTC_EN : val & ~RTC_EN,\n\t       priv->pm_base + PM1_EN_REG);\n\tspin_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int loongson_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint ret;\n\tu32 alarm_data;\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\talarm_data = FIELD_PREP(TOY_MATCH_SEC, alrm->time.tm_sec)\n\t\t   | FIELD_PREP(TOY_MATCH_MIN, alrm->time.tm_min)\n\t\t   | FIELD_PREP(TOY_MATCH_HOUR, alrm->time.tm_hour)\n\t\t   | FIELD_PREP(TOY_MATCH_DAY, alrm->time.tm_mday)\n\t\t   | FIELD_PREP(TOY_MATCH_MON, alrm->time.tm_mon + 1)\n\t\t   | FIELD_PREP(TOY_MATCH_YEAR, alrm->time.tm_year - priv->fix_year);\n\n\tret = regmap_write(priv->regmap, TOY_MATCH0_REG, alarm_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn loongson_rtc_alarm_irq_enable(dev, alrm->enabled);\n}\n\nstatic const struct rtc_class_ops loongson_rtc_ops = {\n\t.read_time = loongson_rtc_read_time,\n\t.set_time = loongson_rtc_set_time,\n\t.read_alarm = loongson_rtc_read_alarm,\n\t.set_alarm = loongson_rtc_set_alarm,\n\t.alarm_irq_enable = loongson_rtc_alarm_irq_enable,\n};\n\nstatic int loongson_rtc_probe(struct platform_device *pdev)\n{\n\tint ret, alarm_irq;\n\tvoid __iomem *regs;\n\tstruct loongson_rtc_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn dev_err_probe(dev, PTR_ERR(regs),\n\t\t\t\t     \"devm_platform_ioremap_resource failed\\n\");\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t     &loongson_rtc_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->regmap),\n\t\t\t\t     \"devm_regmap_init_mmio failed\\n\");\n\n\tpriv->config = device_get_match_data(dev);\n\tspin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->rtcdev = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(priv->rtcdev))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->rtcdev),\n\t\t\t\t     \"devm_rtc_allocate_device failed\\n\");\n\n\t \n\talarm_irq = platform_get_irq(pdev, 0);\n\tif (alarm_irq > 0) {\n\t\tret = devm_request_irq(dev, alarm_irq, loongson_rtc_isr,\n\t\t\t\t       0, \"loongson-alarm\", priv);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Unable to request irq %d\\n\",\n\t\t\t\t\t     alarm_irq);\n\n\t\tpriv->pm_base = regs - priv->config->pm_offset;\n\t\tdevice_init_wakeup(dev, 1);\n\n\t\tif (has_acpi_companion(dev))\n\t\t\tacpi_install_fixed_event_handler(ACPI_EVENT_RTC,\n\t\t\t\t\t\t\t loongson_rtc_handler, priv);\n\t} else {\n\t\t \n\t\tclear_bit(RTC_FEATURE_ALARM, priv->rtcdev->features);\n\t}\n\n\t \n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, priv->rtcdev->features);\n\tpriv->rtcdev->ops = &loongson_rtc_ops;\n\tpriv->rtcdev->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpriv->rtcdev->range_max = RTC_TIMESTAMP_END_2099;\n\n\treturn devm_rtc_register_device(priv->rtcdev);\n}\n\nstatic void loongson_rtc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct loongson_rtc_priv *priv = dev_get_drvdata(dev);\n\n\tif (!test_bit(RTC_FEATURE_ALARM, priv->rtcdev->features))\n\t\treturn;\n\n\tif (has_acpi_companion(dev))\n\t\tacpi_remove_fixed_event_handler(ACPI_EVENT_RTC,\n\t\t\t\t\t\tloongson_rtc_handler);\n\n\tdevice_init_wakeup(dev, 0);\n\tloongson_rtc_alarm_irq_enable(dev, 0);\n}\n\nstatic const struct of_device_id loongson_rtc_of_match[] = {\n\t{ .compatible = \"loongson,ls1b-rtc\", .data = &ls1b_rtc_config },\n\t{ .compatible = \"loongson,ls1c-rtc\", .data = &ls1c_rtc_config },\n\t{ .compatible = \"loongson,ls7a-rtc\", .data = &generic_rtc_config },\n\t{ .compatible = \"loongson,ls2k1000-rtc\", .data = &ls2k1000_rtc_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, loongson_rtc_of_match);\n\nstatic const struct acpi_device_id loongson_rtc_acpi_match[] = {\n\t{ \"LOON0001\", .driver_data = (kernel_ulong_t)&generic_rtc_config },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, loongson_rtc_acpi_match);\n\nstatic struct platform_driver loongson_rtc_driver = {\n\t.probe\t\t= loongson_rtc_probe,\n\t.remove_new\t= loongson_rtc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"loongson-rtc\",\n\t\t.of_match_table = loongson_rtc_of_match,\n\t\t.acpi_match_table = loongson_rtc_acpi_match,\n\t},\n};\nmodule_platform_driver(loongson_rtc_driver);\n\nMODULE_DESCRIPTION(\"Loongson RTC driver\");\nMODULE_AUTHOR(\"Binbin Zhou <zhoubinbin@loongson.cn>\");\nMODULE_AUTHOR(\"WANG Xuerui <git@xen0n.name>\");\nMODULE_AUTHOR(\"Huacai Chen <chenhuacai@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}