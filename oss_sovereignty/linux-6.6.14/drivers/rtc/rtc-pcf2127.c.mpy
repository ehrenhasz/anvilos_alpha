{
  "module_name": "rtc-pcf2127.c",
  "hash_id": "64ea95c747fa8adeba1cf83237062825123d47acd6771708855e9d1bbec0182f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-pcf2127.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n \n#define PCF2127_REG_CTRL1\t\t0x00\n#define PCF2127_BIT_CTRL1_POR_OVRD\t\tBIT(3)\n#define PCF2127_BIT_CTRL1_TSF1\t\t\tBIT(4)\n#define PCF2127_BIT_CTRL1_STOP\t\t\tBIT(5)\n \n#define PCF2127_REG_CTRL2\t\t0x01\n#define PCF2127_BIT_CTRL2_AIE\t\t\tBIT(1)\n#define PCF2127_BIT_CTRL2_TSIE\t\t\tBIT(2)\n#define PCF2127_BIT_CTRL2_AF\t\t\tBIT(4)\n#define PCF2127_BIT_CTRL2_TSF2\t\t\tBIT(5)\n#define PCF2127_BIT_CTRL2_WDTF\t\t\tBIT(6)\n \n#define PCF2127_REG_CTRL3\t\t0x02\n#define PCF2127_BIT_CTRL3_BLIE\t\t\tBIT(0)\n#define PCF2127_BIT_CTRL3_BIE\t\t\tBIT(1)\n#define PCF2127_BIT_CTRL3_BLF\t\t\tBIT(2)\n#define PCF2127_BIT_CTRL3_BF\t\t\tBIT(3)\n#define PCF2127_BIT_CTRL3_BTSE\t\t\tBIT(4)\n \n#define PCF2127_REG_TIME_BASE\t\t0x03\n#define PCF2127_BIT_SC_OSF\t\t\tBIT(7)\n \n#define PCF2127_REG_ALARM_BASE\t\t0x0A\n#define PCF2127_BIT_ALARM_AE\t\t\tBIT(7)\n \n#define PCF2127_REG_CLKOUT\t\t0x0f\n#define PCF2127_BIT_CLKOUT_OTPR\t\t\tBIT(5)\n \n#define PCF2127_REG_WD_CTL\t\t0x10\n#define PCF2127_BIT_WD_CTL_TF0\t\t\tBIT(0)\n#define PCF2127_BIT_WD_CTL_TF1\t\t\tBIT(1)\n#define PCF2127_BIT_WD_CTL_CD0\t\t\tBIT(6)\n#define PCF2127_BIT_WD_CTL_CD1\t\t\tBIT(7)\n#define PCF2127_REG_WD_VAL\t\t0x11\n \n#define PCF2127_REG_TS1_BASE\t\t0x12\n#define PCF2127_BIT_TS_CTRL_TSOFF\t\tBIT(6)\n#define PCF2127_BIT_TS_CTRL_TSM\t\t\tBIT(7)\n \n#define PCF2127_REG_RAM_ADDR_MSB\t0x1A\n#define PCF2127_REG_RAM_WRT_CMD\t\t0x1C\n#define PCF2127_REG_RAM_RD_CMD\t\t0x1D\n\n \n#define PCF2127_WD_VAL_STOP\t\t0\n \n#define PCF2127_WD_CLOCK_HZ_X1000\t1000  \n#define PCF2127_WD_MIN_HW_HEARTBEAT_MS\t500\n \n#define PCF2131_WD_CLOCK_HZ_X1000\t250   \n#define PCF2131_WD_MIN_HW_HEARTBEAT_MS\t4000\n\n#define PCF2127_WD_DEFAULT_TIMEOUT_S\t60\n\n \n#define PCF2127_CTRL1_IRQ_MASK (PCF2127_BIT_CTRL1_TSF1)\n#define PCF2127_CTRL2_IRQ_MASK ( \\\n\t\tPCF2127_BIT_CTRL2_AF | \\\n\t\tPCF2127_BIT_CTRL2_WDTF | \\\n\t\tPCF2127_BIT_CTRL2_TSF2)\n\n#define PCF2127_MAX_TS_SUPPORTED\t4\n\n \n#define PCF2131_REG_CTRL4\t\t0x03\n#define PCF2131_BIT_CTRL4_TSF4\t\t\tBIT(4)\n#define PCF2131_BIT_CTRL4_TSF3\t\t\tBIT(5)\n#define PCF2131_BIT_CTRL4_TSF2\t\t\tBIT(6)\n#define PCF2131_BIT_CTRL4_TSF1\t\t\tBIT(7)\n \n#define PCF2131_REG_CTRL5\t\t0x04\n#define PCF2131_BIT_CTRL5_TSIE4\t\t\tBIT(4)\n#define PCF2131_BIT_CTRL5_TSIE3\t\t\tBIT(5)\n#define PCF2131_BIT_CTRL5_TSIE2\t\t\tBIT(6)\n#define PCF2131_BIT_CTRL5_TSIE1\t\t\tBIT(7)\n \n#define PCF2131_REG_SR_RESET\t\t0x05\n#define PCF2131_SR_RESET_READ_PATTERN\t(BIT(2) | BIT(5))\n#define PCF2131_SR_RESET_CPR_CMD\t(PCF2131_SR_RESET_READ_PATTERN | BIT(7))\n \n#define PCF2131_REG_TIME_BASE\t\t0x07\n \n#define PCF2131_REG_ALARM_BASE\t\t0x0E\n \n#define PCF2131_REG_CLKOUT\t\t0x13\n \n#define PCF2131_REG_WD_CTL\t\t0x35\n#define PCF2131_REG_WD_VAL\t\t0x36\n \n#define PCF2131_REG_TS1_BASE\t\t0x14\n \n#define PCF2131_REG_TS2_BASE\t\t0x1B\n \n#define PCF2131_REG_TS3_BASE\t\t0x22\n \n#define PCF2131_REG_TS4_BASE\t\t0x29\n \n#define PCF2131_REG_INT_A_MASK1\t\t0x31\n#define PCF2131_REG_INT_A_MASK2\t\t0x32\n#define PCF2131_REG_INT_B_MASK1\t\t0x33\n#define PCF2131_REG_INT_B_MASK2\t\t0x34\n#define PCF2131_BIT_INT_BLIE\t\tBIT(0)\n#define PCF2131_BIT_INT_BIE\t\tBIT(1)\n#define PCF2131_BIT_INT_AIE\t\tBIT(2)\n#define PCF2131_BIT_INT_WD_CD\t\tBIT(3)\n#define PCF2131_BIT_INT_SI\t\tBIT(4)\n#define PCF2131_BIT_INT_MI\t\tBIT(5)\n#define PCF2131_CTRL2_IRQ_MASK ( \\\n\t\tPCF2127_BIT_CTRL2_AF | \\\n\t\tPCF2127_BIT_CTRL2_WDTF)\n#define PCF2131_CTRL4_IRQ_MASK ( \\\n\t\tPCF2131_BIT_CTRL4_TSF4 | \\\n\t\tPCF2131_BIT_CTRL4_TSF3 | \\\n\t\tPCF2131_BIT_CTRL4_TSF2 | \\\n\t\tPCF2131_BIT_CTRL4_TSF1)\n\nenum pcf21xx_type {\n\tPCF2127,\n\tPCF2129,\n\tPCF2131,\n\tPCF21XX_LAST_ID\n};\n\nstruct pcf21xx_ts_config {\n\tu8 reg_base;  \n\n\t \n\tu8 gnd_detect_reg;  \n\tu8 gnd_detect_bit;  \n\n\t \n\tu8 inter_detect_reg;  \n\tu8 inter_detect_bit;  \n\n\tu8 ie_reg;  \n\tu8 ie_bit;  \n};\n\nstruct pcf21xx_config {\n\tint type;  \n\tint max_register;\n\tunsigned int has_nvmem:1;\n\tunsigned int has_bit_wd_ctl_cd0:1;\n\tunsigned int wd_val_reg_readable:1;  \n\tunsigned int has_int_a_b:1;  \n\tu8 reg_time_base;  \n\tu8 regs_alarm_base;  \n\tu8 reg_wd_ctl;  \n\tu8 reg_wd_val;  \n\tu8 reg_clkout;  \n\tint wdd_clock_hz_x1000;  \n\tint wdd_min_hw_heartbeat_ms;\n\tunsigned int ts_count;\n\tstruct pcf21xx_ts_config ts[PCF2127_MAX_TS_SUPPORTED];\n\tstruct attribute_group attribute_group;\n};\n\nstruct pcf2127 {\n\tstruct rtc_device *rtc;\n\tstruct watchdog_device wdd;\n\tstruct regmap *regmap;\n\tconst struct pcf21xx_config *cfg;\n\tbool irq_enabled;\n\ttime64_t ts[PCF2127_MAX_TS_SUPPORTED];  \n\tbool ts_valid[PCF2127_MAX_TS_SUPPORTED];   \n};\n\n \nstatic int pcf2127_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tunsigned char buf[7];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(pcf2127->regmap, pcf2127->cfg->reg_time_base,\n\t\t\t       buf, sizeof(buf));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: read error\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tif (buf[0] & PCF2127_BIT_SC_OSF) {\n\t\t \n\t\tdev_warn(dev,\n\t\t\t \"oscillator stop detected, date/time is not reliable\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev,\n\t\t\"%s: raw data is sec=%02x, min=%02x, hr=%02x, \"\n\t\t\"mday=%02x, wday=%02x, mon=%02x, year=%02x\\n\",\n\t\t__func__, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);\n\n\ttm->tm_sec = bcd2bin(buf[0] & 0x7F);\n\ttm->tm_min = bcd2bin(buf[1] & 0x7F);\n\ttm->tm_hour = bcd2bin(buf[2] & 0x3F);\n\ttm->tm_mday = bcd2bin(buf[3] & 0x3F);\n\ttm->tm_wday = buf[4] & 0x07;\n\ttm->tm_mon = bcd2bin(buf[5] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(buf[6]);\n\ttm->tm_year += 100;\n\n\tdev_dbg(dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int pcf2127_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tunsigned char buf[7];\n\tint i = 0, err;\n\n\tdev_dbg(dev, \"%s: secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\t \n\tbuf[i++] = bin2bcd(tm->tm_sec);\t \n\tbuf[i++] = bin2bcd(tm->tm_min);\n\tbuf[i++] = bin2bcd(tm->tm_hour);\n\tbuf[i++] = bin2bcd(tm->tm_mday);\n\tbuf[i++] = tm->tm_wday & 0x07;\n\n\t \n\tbuf[i++] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[i++] = bin2bcd(tm->tm_year - 100);\n\n\t \n\tif (pcf2127->cfg->type == PCF2131) {\n\t\terr = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,\n\t\t\t\t\t PCF2127_BIT_CTRL1_STOP,\n\t\t\t\t\t PCF2127_BIT_CTRL1_STOP);\n\t\tif (err) {\n\t\t\tdev_dbg(dev, \"setting STOP bit failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = regmap_write(pcf2127->regmap, PCF2131_REG_SR_RESET,\n\t\t\t\t   PCF2131_SR_RESET_CPR_CMD);\n\t\tif (err) {\n\t\t\tdev_dbg(dev, \"sending CPR cmd failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = regmap_bulk_write(pcf2127->regmap, pcf2127->cfg->reg_time_base, buf, i);\n\tif (err) {\n\t\tdev_dbg(dev, \"%s: err=%d\", __func__, err);\n\t\treturn err;\n\t}\n\n\tif (pcf2127->cfg->type == PCF2131) {\n\t\t \n\t\terr = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,\n\t\t\t\t\t PCF2127_BIT_CTRL1_STOP, 0);\n\t\tif (err) {\n\t\t\tdev_dbg(dev, \"clearing STOP bit failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcf2127_rtc_ioctl(struct device *dev,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tint val, touser = 0;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL3, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val & PCF2127_BIT_CTRL3_BLF)\n\t\t\ttouser |= RTC_VL_BACKUP_LOW;\n\n\t\tif (val & PCF2127_BIT_CTRL3_BF)\n\t\t\ttouser |= RTC_VL_BACKUP_SWITCH;\n\n\t\treturn put_user(touser, (unsigned int __user *)arg);\n\n\tcase RTC_VL_CLR:\n\t\treturn regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL3,\n\t\t\t\t\t  PCF2127_BIT_CTRL3_BF, 0);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int pcf2127_nvmem_read(void *priv, unsigned int offset,\n\t\t\t      void *val, size_t bytes)\n{\n\tstruct pcf2127 *pcf2127 = priv;\n\tint ret;\n\tunsigned char offsetbuf[] = { offset >> 8, offset };\n\n\tret = regmap_bulk_write(pcf2127->regmap, PCF2127_REG_RAM_ADDR_MSB,\n\t\t\t\toffsetbuf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_bulk_read(pcf2127->regmap, PCF2127_REG_RAM_RD_CMD,\n\t\t\t\tval, bytes);\n}\n\nstatic int pcf2127_nvmem_write(void *priv, unsigned int offset,\n\t\t\t       void *val, size_t bytes)\n{\n\tstruct pcf2127 *pcf2127 = priv;\n\tint ret;\n\tunsigned char offsetbuf[] = { offset >> 8, offset };\n\n\tret = regmap_bulk_write(pcf2127->regmap, PCF2127_REG_RAM_ADDR_MSB,\n\t\t\t\toffsetbuf, 2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_bulk_write(pcf2127->regmap, PCF2127_REG_RAM_WRT_CMD,\n\t\t\t\t val, bytes);\n}\n\n \n\nstatic int pcf2127_wdt_ping(struct watchdog_device *wdd)\n{\n\tint wd_val;\n\tstruct pcf2127 *pcf2127 = watchdog_get_drvdata(wdd);\n\n\t \n\twd_val = ((wdd->timeout * pcf2127->cfg->wdd_clock_hz_x1000) / 1000) + 1;\n\n\treturn regmap_write(pcf2127->regmap, pcf2127->cfg->reg_wd_val, wd_val);\n}\n\n \nstatic int pcf2127_wdt_active_ping(struct watchdog_device *wdd)\n{\n\tint ret = 0;\n\n\tif (watchdog_active(wdd)) {\n\t\tret = pcf2127_wdt_ping(wdd);\n\t\tif (ret)\n\t\t\tdev_err(wdd->parent,\n\t\t\t\t\"%s: watchdog restart failed, ret=%d\\n\",\n\t\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int pcf2127_wdt_start(struct watchdog_device *wdd)\n{\n\treturn pcf2127_wdt_ping(wdd);\n}\n\nstatic int pcf2127_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct pcf2127 *pcf2127 = watchdog_get_drvdata(wdd);\n\n\treturn regmap_write(pcf2127->regmap, pcf2127->cfg->reg_wd_val,\n\t\t\t    PCF2127_WD_VAL_STOP);\n}\n\nstatic int pcf2127_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int new_timeout)\n{\n\tdev_dbg(wdd->parent, \"new watchdog timeout: %is (old: %is)\\n\",\n\t\tnew_timeout, wdd->timeout);\n\n\twdd->timeout = new_timeout;\n\n\treturn pcf2127_wdt_active_ping(wdd);\n}\n\nstatic const struct watchdog_info pcf2127_wdt_info = {\n\t.identity = \"NXP PCF2127/PCF2129 Watchdog\",\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,\n};\n\nstatic const struct watchdog_ops pcf2127_watchdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = pcf2127_wdt_start,\n\t.stop = pcf2127_wdt_stop,\n\t.ping = pcf2127_wdt_ping,\n\t.set_timeout = pcf2127_wdt_set_timeout,\n};\n\n \nstatic int pcf2127_watchdog_get_period(int n, int f1000)\n{\n\treturn (1000 * (n - 1)) / f1000;\n}\n\nstatic int pcf2127_watchdog_init(struct device *dev, struct pcf2127 *pcf2127)\n{\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_WATCHDOG) ||\n\t    !device_property_read_bool(dev, \"reset-source\"))\n\t\treturn 0;\n\n\tpcf2127->wdd.parent = dev;\n\tpcf2127->wdd.info = &pcf2127_wdt_info;\n\tpcf2127->wdd.ops = &pcf2127_watchdog_ops;\n\n\tpcf2127->wdd.min_timeout =\n\t\tpcf2127_watchdog_get_period(\n\t\t\t2, pcf2127->cfg->wdd_clock_hz_x1000);\n\tpcf2127->wdd.max_timeout =\n\t\tpcf2127_watchdog_get_period(\n\t\t\t255, pcf2127->cfg->wdd_clock_hz_x1000);\n\tpcf2127->wdd.timeout = PCF2127_WD_DEFAULT_TIMEOUT_S;\n\n\tdev_dbg(dev, \"%s clock = %d Hz / 1000\\n\", __func__,\n\t\tpcf2127->cfg->wdd_clock_hz_x1000);\n\n\tpcf2127->wdd.min_hw_heartbeat_ms = pcf2127->cfg->wdd_min_hw_heartbeat_ms;\n\tpcf2127->wdd.status = WATCHDOG_NOWAYOUT_INIT_STATUS;\n\n\twatchdog_set_drvdata(&pcf2127->wdd, pcf2127);\n\n\t \n\tif (pcf2127->cfg->wd_val_reg_readable) {\n\t\tu32 wdd_timeout;\n\n\t\tret = regmap_read(pcf2127->regmap, pcf2127->cfg->reg_wd_val,\n\t\t\t\t  &wdd_timeout);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (wdd_timeout)\n\t\t\tset_bit(WDOG_HW_RUNNING, &pcf2127->wdd.status);\n\t}\n\n\treturn devm_watchdog_register_device(dev, &pcf2127->wdd);\n}\n\n \nstatic int pcf2127_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tu8 buf[5];\n\tunsigned int ctrl2;\n\tint ret;\n\n\tret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL2, &ctrl2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcf2127_wdt_active_ping(&pcf2127->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(pcf2127->regmap, pcf2127->cfg->regs_alarm_base,\n\t\t\t       buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\talrm->enabled = ctrl2 & PCF2127_BIT_CTRL2_AIE;\n\talrm->pending = ctrl2 & PCF2127_BIT_CTRL2_AF;\n\n\talrm->time.tm_sec = bcd2bin(buf[0] & 0x7F);\n\talrm->time.tm_min = bcd2bin(buf[1] & 0x7F);\n\talrm->time.tm_hour = bcd2bin(buf[2] & 0x3F);\n\talrm->time.tm_mday = bcd2bin(buf[3] & 0x3F);\n\n\treturn 0;\n}\n\nstatic int pcf2127_rtc_alarm_irq_enable(struct device *dev, u32 enable)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL2,\n\t\t\t\t PCF2127_BIT_CTRL2_AIE,\n\t\t\t\t enable ? PCF2127_BIT_CTRL2_AIE : 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pcf2127_wdt_active_ping(&pcf2127->wdd);\n}\n\nstatic int pcf2127_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tuint8_t buf[5];\n\tint ret;\n\n\tret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL2,\n\t\t\t\t PCF2127_BIT_CTRL2_AF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcf2127_wdt_active_ping(&pcf2127->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf[0] = bin2bcd(alrm->time.tm_sec);\n\tbuf[1] = bin2bcd(alrm->time.tm_min);\n\tbuf[2] = bin2bcd(alrm->time.tm_hour);\n\tbuf[3] = bin2bcd(alrm->time.tm_mday);\n\tbuf[4] = PCF2127_BIT_ALARM_AE;  \n\n\tret = regmap_bulk_write(pcf2127->regmap, pcf2127->cfg->regs_alarm_base,\n\t\t\t\tbuf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn pcf2127_rtc_alarm_irq_enable(dev, alrm->enabled);\n}\n\n \nstatic int pcf2127_rtc_ts_read(struct device *dev, time64_t *ts,\n\t\t\t       int ts_id)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tstruct rtc_time tm;\n\tint ret;\n\tunsigned char data[7];\n\n\tret = regmap_bulk_read(pcf2127->regmap, pcf2127->cfg->ts[ts_id].reg_base,\n\t\t\t       data, sizeof(data));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: read error ret=%d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev,\n\t\t\"%s: raw data is ts_sc=%02x, ts_mn=%02x, ts_hr=%02x, ts_dm=%02x, ts_mo=%02x, ts_yr=%02x\\n\",\n\t\t__func__, data[1], data[2], data[3], data[4], data[5], data[6]);\n\n\ttm.tm_sec = bcd2bin(data[1] & 0x7F);\n\ttm.tm_min = bcd2bin(data[2] & 0x7F);\n\ttm.tm_hour = bcd2bin(data[3] & 0x3F);\n\ttm.tm_mday = bcd2bin(data[4] & 0x3F);\n\t \n\ttm.tm_mon = bcd2bin(data[5] & 0x1F) - 1;\n\ttm.tm_year = bcd2bin(data[6]);\n\tif (tm.tm_year < 70)\n\t\ttm.tm_year += 100;  \n\n\tret = rtc_valid_tm(&tm);\n\tif (ret) {\n\t\tdev_err(dev, \"Invalid timestamp. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*ts = rtc_tm_to_time64(&tm);\n\treturn 0;\n};\n\nstatic void pcf2127_rtc_ts_snapshot(struct device *dev, int ts_id)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (ts_id >= pcf2127->cfg->ts_count)\n\t\treturn;\n\n\t \n\tif (pcf2127->ts_valid[ts_id])\n\t\treturn;\n\n\tret = pcf2127_rtc_ts_read(dev, &pcf2127->ts[ts_id], ts_id);\n\tif (!ret)\n\t\tpcf2127->ts_valid[ts_id] = true;\n}\n\nstatic irqreturn_t pcf2127_rtc_irq(int irq, void *dev)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tunsigned int ctrl2;\n\tint ret = 0;\n\n\tret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL2, &ctrl2);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (pcf2127->cfg->ts_count == 1) {\n\t\t \n\t\tunsigned int ctrl1;\n\n\t\tret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL1, &ctrl1);\n\t\tif (ret)\n\t\t\treturn IRQ_NONE;\n\n\t\tif (!(ctrl1 & PCF2127_CTRL1_IRQ_MASK || ctrl2 & PCF2127_CTRL2_IRQ_MASK))\n\t\t\treturn IRQ_NONE;\n\n\t\tif (ctrl1 & PCF2127_BIT_CTRL1_TSF1 || ctrl2 & PCF2127_BIT_CTRL2_TSF2)\n\t\t\tpcf2127_rtc_ts_snapshot(dev, 0);\n\n\t\tif (ctrl1 & PCF2127_CTRL1_IRQ_MASK)\n\t\t\tregmap_write(pcf2127->regmap, PCF2127_REG_CTRL1,\n\t\t\t\t     ctrl1 & ~PCF2127_CTRL1_IRQ_MASK);\n\n\t\tif (ctrl2 & PCF2127_CTRL2_IRQ_MASK)\n\t\t\tregmap_write(pcf2127->regmap, PCF2127_REG_CTRL2,\n\t\t\t\t     ctrl2 & ~PCF2127_CTRL2_IRQ_MASK);\n\t} else {\n\t\t \n\t\tunsigned int ctrl4;\n\n\t\tret = regmap_read(pcf2127->regmap, PCF2131_REG_CTRL4, &ctrl4);\n\t\tif (ret)\n\t\t\treturn IRQ_NONE;\n\n\t\tif (!(ctrl4 & PCF2131_CTRL4_IRQ_MASK || ctrl2 & PCF2131_CTRL2_IRQ_MASK))\n\t\t\treturn IRQ_NONE;\n\n\t\tif (ctrl4 & PCF2131_CTRL4_IRQ_MASK) {\n\t\t\tint i;\n\t\t\tint tsf_bit = PCF2131_BIT_CTRL4_TSF1;  \n\n\t\t\tfor (i = 0; i < pcf2127->cfg->ts_count; i++) {\n\t\t\t\tif (ctrl4 & tsf_bit)\n\t\t\t\t\tpcf2127_rtc_ts_snapshot(dev, i);\n\n\t\t\t\ttsf_bit = tsf_bit >> 1;\n\t\t\t}\n\n\t\t\tregmap_write(pcf2127->regmap, PCF2131_REG_CTRL4,\n\t\t\t\t     ctrl4 & ~PCF2131_CTRL4_IRQ_MASK);\n\t\t}\n\n\t\tif (ctrl2 & PCF2131_CTRL2_IRQ_MASK)\n\t\t\tregmap_write(pcf2127->regmap, PCF2127_REG_CTRL2,\n\t\t\t\t     ctrl2 & ~PCF2131_CTRL2_IRQ_MASK);\n\t}\n\n\tif (ctrl2 & PCF2127_BIT_CTRL2_AF)\n\t\trtc_update_irq(pcf2127->rtc, 1, RTC_IRQF | RTC_AF);\n\n\tpcf2127_wdt_active_ping(&pcf2127->wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops pcf2127_rtc_ops = {\n\t.ioctl            = pcf2127_rtc_ioctl,\n\t.read_time        = pcf2127_rtc_read_time,\n\t.set_time         = pcf2127_rtc_set_time,\n\t.read_alarm       = pcf2127_rtc_read_alarm,\n\t.set_alarm        = pcf2127_rtc_set_alarm,\n\t.alarm_irq_enable = pcf2127_rtc_alarm_irq_enable,\n};\n\n \n\nstatic ssize_t timestamp_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count, int ts_id)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tif (ts_id >= pcf2127->cfg->ts_count)\n\t\treturn 0;\n\n\tif (pcf2127->irq_enabled) {\n\t\tpcf2127->ts_valid[ts_id] = false;\n\t} else {\n\t\t \n\t\tret = regmap_update_bits(pcf2127->regmap,\n\t\t\t\t\t pcf2127->cfg->ts[ts_id].gnd_detect_reg,\n\t\t\t\t\t pcf2127->cfg->ts[ts_id].gnd_detect_bit,\n\t\t\t\t\t 0);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: update TS gnd detect ret=%d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (pcf2127->cfg->ts[ts_id].inter_detect_bit) {\n\t\t\t \n\t\t\tret = regmap_update_bits(pcf2127->regmap,\n\t\t\t\t\t\t pcf2127->cfg->ts[ts_id].inter_detect_reg,\n\t\t\t\t\t\t pcf2127->cfg->ts[ts_id].inter_detect_bit,\n\t\t\t\t\t\t 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"%s: update TS intermediate level detect ret=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = pcf2127_wdt_active_ping(&pcf2127->wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t timestamp0_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn timestamp_store(dev, attr, buf, count, 0);\n};\n\nstatic ssize_t timestamp1_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn timestamp_store(dev, attr, buf, count, 1);\n};\n\nstatic ssize_t timestamp2_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn timestamp_store(dev, attr, buf, count, 2);\n};\n\nstatic ssize_t timestamp3_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn timestamp_store(dev, attr, buf, count, 3);\n};\n\nstatic ssize_t timestamp_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf,\n\t\t\t      int ts_id)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);\n\tint ret;\n\ttime64_t ts;\n\n\tif (ts_id >= pcf2127->cfg->ts_count)\n\t\treturn 0;\n\n\tif (pcf2127->irq_enabled) {\n\t\tif (!pcf2127->ts_valid[ts_id])\n\t\t\treturn 0;\n\t\tts = pcf2127->ts[ts_id];\n\t} else {\n\t\tu8 valid_low = 0;\n\t\tu8 valid_inter = 0;\n\t\tunsigned int ctrl;\n\n\t\t \n\t\tret = regmap_read(pcf2127->regmap,\n\t\t\t\t  pcf2127->cfg->ts[ts_id].gnd_detect_reg,\n\t\t\t\t  &ctrl);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tvalid_low = ctrl & pcf2127->cfg->ts[ts_id].gnd_detect_bit;\n\n\t\tif (pcf2127->cfg->ts[ts_id].inter_detect_bit) {\n\t\t\t \n\t\t\tret = regmap_read(pcf2127->regmap,\n\t\t\t\t\t  pcf2127->cfg->ts[ts_id].inter_detect_reg,\n\t\t\t\t\t  &ctrl);\n\t\t\tif (ret)\n\t\t\t\treturn 0;\n\n\t\t\tvalid_inter = ctrl & pcf2127->cfg->ts[ts_id].inter_detect_bit;\n\t\t}\n\n\t\tif (!valid_low && !valid_inter)\n\t\t\treturn 0;\n\n\t\tret = pcf2127_rtc_ts_read(dev->parent, &ts, ts_id);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = pcf2127_wdt_active_ping(&pcf2127->wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)ts);\n}\n\nstatic ssize_t timestamp0_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn timestamp_show(dev, attr, buf, 0);\n};\n\nstatic ssize_t timestamp1_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn timestamp_show(dev, attr, buf, 1);\n};\n\nstatic ssize_t timestamp2_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn timestamp_show(dev, attr, buf, 2);\n};\n\nstatic ssize_t timestamp3_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn timestamp_show(dev, attr, buf, 3);\n};\n\nstatic DEVICE_ATTR_RW(timestamp0);\nstatic DEVICE_ATTR_RW(timestamp1);\nstatic DEVICE_ATTR_RW(timestamp2);\nstatic DEVICE_ATTR_RW(timestamp3);\n\nstatic struct attribute *pcf2127_attrs[] = {\n\t&dev_attr_timestamp0.attr,\n\tNULL\n};\n\nstatic struct attribute *pcf2131_attrs[] = {\n\t&dev_attr_timestamp0.attr,\n\t&dev_attr_timestamp1.attr,\n\t&dev_attr_timestamp2.attr,\n\t&dev_attr_timestamp3.attr,\n\tNULL\n};\n\nstatic struct pcf21xx_config pcf21xx_cfg[] = {\n\t[PCF2127] = {\n\t\t.type = PCF2127,\n\t\t.max_register = 0x1d,\n\t\t.has_nvmem = 1,\n\t\t.has_bit_wd_ctl_cd0 = 1,\n\t\t.wd_val_reg_readable = 1,\n\t\t.has_int_a_b = 0,\n\t\t.reg_time_base = PCF2127_REG_TIME_BASE,\n\t\t.regs_alarm_base = PCF2127_REG_ALARM_BASE,\n\t\t.reg_wd_ctl = PCF2127_REG_WD_CTL,\n\t\t.reg_wd_val = PCF2127_REG_WD_VAL,\n\t\t.reg_clkout = PCF2127_REG_CLKOUT,\n\t\t.wdd_clock_hz_x1000 = PCF2127_WD_CLOCK_HZ_X1000,\n\t\t.wdd_min_hw_heartbeat_ms = PCF2127_WD_MIN_HW_HEARTBEAT_MS,\n\t\t.ts_count = 1,\n\t\t.ts[0] = {\n\t\t\t.reg_base  = PCF2127_REG_TS1_BASE,\n\t\t\t.gnd_detect_reg = PCF2127_REG_CTRL1,\n\t\t\t.gnd_detect_bit = PCF2127_BIT_CTRL1_TSF1,\n\t\t\t.inter_detect_reg = PCF2127_REG_CTRL2,\n\t\t\t.inter_detect_bit = PCF2127_BIT_CTRL2_TSF2,\n\t\t\t.ie_reg    = PCF2127_REG_CTRL2,\n\t\t\t.ie_bit    = PCF2127_BIT_CTRL2_TSIE,\n\t\t},\n\t\t.attribute_group = {\n\t\t\t.attrs\t= pcf2127_attrs,\n\t\t},\n\t},\n\t[PCF2129] = {\n\t\t.type = PCF2129,\n\t\t.max_register = 0x19,\n\t\t.has_nvmem = 0,\n\t\t.has_bit_wd_ctl_cd0 = 0,\n\t\t.wd_val_reg_readable = 1,\n\t\t.has_int_a_b = 0,\n\t\t.reg_time_base = PCF2127_REG_TIME_BASE,\n\t\t.regs_alarm_base = PCF2127_REG_ALARM_BASE,\n\t\t.reg_wd_ctl = PCF2127_REG_WD_CTL,\n\t\t.reg_wd_val = PCF2127_REG_WD_VAL,\n\t\t.reg_clkout = PCF2127_REG_CLKOUT,\n\t\t.wdd_clock_hz_x1000 = PCF2127_WD_CLOCK_HZ_X1000,\n\t\t.wdd_min_hw_heartbeat_ms = PCF2127_WD_MIN_HW_HEARTBEAT_MS,\n\t\t.ts_count = 1,\n\t\t.ts[0] = {\n\t\t\t.reg_base  = PCF2127_REG_TS1_BASE,\n\t\t\t.gnd_detect_reg = PCF2127_REG_CTRL1,\n\t\t\t.gnd_detect_bit = PCF2127_BIT_CTRL1_TSF1,\n\t\t\t.inter_detect_reg = PCF2127_REG_CTRL2,\n\t\t\t.inter_detect_bit = PCF2127_BIT_CTRL2_TSF2,\n\t\t\t.ie_reg    = PCF2127_REG_CTRL2,\n\t\t\t.ie_bit    = PCF2127_BIT_CTRL2_TSIE,\n\t\t},\n\t\t.attribute_group = {\n\t\t\t.attrs\t= pcf2127_attrs,\n\t\t},\n\t},\n\t[PCF2131] = {\n\t\t.type = PCF2131,\n\t\t.max_register = 0x36,\n\t\t.has_nvmem = 0,\n\t\t.has_bit_wd_ctl_cd0 = 0,\n\t\t.wd_val_reg_readable = 0,\n\t\t.has_int_a_b = 1,\n\t\t.reg_time_base = PCF2131_REG_TIME_BASE,\n\t\t.regs_alarm_base = PCF2131_REG_ALARM_BASE,\n\t\t.reg_wd_ctl = PCF2131_REG_WD_CTL,\n\t\t.reg_wd_val = PCF2131_REG_WD_VAL,\n\t\t.reg_clkout = PCF2131_REG_CLKOUT,\n\t\t.wdd_clock_hz_x1000 = PCF2131_WD_CLOCK_HZ_X1000,\n\t\t.wdd_min_hw_heartbeat_ms = PCF2131_WD_MIN_HW_HEARTBEAT_MS,\n\t\t.ts_count = 4,\n\t\t.ts[0] = {\n\t\t\t.reg_base  = PCF2131_REG_TS1_BASE,\n\t\t\t.gnd_detect_reg = PCF2131_REG_CTRL4,\n\t\t\t.gnd_detect_bit = PCF2131_BIT_CTRL4_TSF1,\n\t\t\t.inter_detect_bit = 0,\n\t\t\t.ie_reg    = PCF2131_REG_CTRL5,\n\t\t\t.ie_bit    = PCF2131_BIT_CTRL5_TSIE1,\n\t\t},\n\t\t.ts[1] = {\n\t\t\t.reg_base  = PCF2131_REG_TS2_BASE,\n\t\t\t.gnd_detect_reg = PCF2131_REG_CTRL4,\n\t\t\t.gnd_detect_bit = PCF2131_BIT_CTRL4_TSF2,\n\t\t\t.inter_detect_bit = 0,\n\t\t\t.ie_reg    = PCF2131_REG_CTRL5,\n\t\t\t.ie_bit    = PCF2131_BIT_CTRL5_TSIE2,\n\t\t},\n\t\t.ts[2] = {\n\t\t\t.reg_base  = PCF2131_REG_TS3_BASE,\n\t\t\t.gnd_detect_reg = PCF2131_REG_CTRL4,\n\t\t\t.gnd_detect_bit = PCF2131_BIT_CTRL4_TSF3,\n\t\t\t.inter_detect_bit = 0,\n\t\t\t.ie_reg    = PCF2131_REG_CTRL5,\n\t\t\t.ie_bit    = PCF2131_BIT_CTRL5_TSIE3,\n\t\t},\n\t\t.ts[3] = {\n\t\t\t.reg_base  = PCF2131_REG_TS4_BASE,\n\t\t\t.gnd_detect_reg = PCF2131_REG_CTRL4,\n\t\t\t.gnd_detect_bit = PCF2131_BIT_CTRL4_TSF4,\n\t\t\t.inter_detect_bit = 0,\n\t\t\t.ie_reg    = PCF2131_REG_CTRL5,\n\t\t\t.ie_bit    = PCF2131_BIT_CTRL5_TSIE4,\n\t\t},\n\t\t.attribute_group = {\n\t\t\t.attrs\t= pcf2131_attrs,\n\t\t},\n\t},\n};\n\n \nstatic int pcf2127_enable_ts(struct device *dev, int ts_id)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (ts_id >= pcf2127->cfg->ts_count) {\n\t\tdev_err(dev, \"%s: invalid tamper detection ID (%d)\\n\",\n\t\t\t__func__, ts_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_update_bits(pcf2127->regmap,\n\t\t\t\t pcf2127->cfg->ts[ts_id].reg_base,\n\t\t\t\t PCF2127_BIT_TS_CTRL_TSOFF |\n\t\t\t\t PCF2127_BIT_TS_CTRL_TSM,\n\t\t\t\t PCF2127_BIT_TS_CTRL_TSM);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: tamper detection config (ts%d_ctrl) failed\\n\",\n\t\t\t__func__, ts_id);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(pcf2127->regmap, pcf2127->cfg->ts[ts_id].ie_reg,\n\t\t\t\t pcf2127->cfg->ts[ts_id].ie_bit,\n\t\t\t\t pcf2127->cfg->ts[ts_id].ie_bit);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: tamper detection TSIE%d config failed\\n\",\n\t\t\t__func__, ts_id);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int pcf2127_configure_interrupt_pins(struct device *dev)\n{\n\tstruct pcf2127 *pcf2127 = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regmap_write(pcf2127->regmap,\n\t\t\t   PCF2131_REG_INT_A_MASK1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(pcf2127->regmap,\n\t\t\t   PCF2131_REG_INT_A_MASK2, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int pcf2127_probe(struct device *dev, struct regmap *regmap,\n\t\t\t int alarm_irq, const struct pcf21xx_config *config)\n{\n\tstruct pcf2127 *pcf2127;\n\tint ret = 0;\n\tunsigned int val;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tpcf2127 = devm_kzalloc(dev, sizeof(*pcf2127), GFP_KERNEL);\n\tif (!pcf2127)\n\t\treturn -ENOMEM;\n\n\tpcf2127->regmap = regmap;\n\tpcf2127->cfg = config;\n\n\tdev_set_drvdata(dev, pcf2127);\n\n\tpcf2127->rtc = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(pcf2127->rtc))\n\t\treturn PTR_ERR(pcf2127->rtc);\n\n\tpcf2127->rtc->ops = &pcf2127_rtc_ops;\n\tpcf2127->rtc->range_min = RTC_TIMESTAMP_BEGIN_2000;\n\tpcf2127->rtc->range_max = RTC_TIMESTAMP_END_2099;\n\tpcf2127->rtc->set_start_time = true;  \n\n\t \n\tif (pcf2127->cfg->type == PCF2127 || pcf2127->cfg->type == PCF2129) {\n\t\tset_bit(RTC_FEATURE_ALARM_RES_2S, pcf2127->rtc->features);\n\t\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, pcf2127->rtc->features);\n\t}\n\n\tclear_bit(RTC_FEATURE_ALARM, pcf2127->rtc->features);\n\n\tif (alarm_irq > 0) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tif (dev_fwnode(dev))\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = IRQF_TRIGGER_LOW;\n\n\t\tret = devm_request_threaded_irq(dev, alarm_irq, NULL,\n\t\t\t\t\t\tpcf2127_rtc_irq,\n\t\t\t\t\t\tflags | IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request alarm irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tpcf2127->irq_enabled = true;\n\t}\n\n\tif (alarm_irq > 0 || device_property_read_bool(dev, \"wakeup-source\")) {\n\t\tdevice_init_wakeup(dev, true);\n\t\tset_bit(RTC_FEATURE_ALARM, pcf2127->rtc->features);\n\t}\n\n\tif (pcf2127->cfg->has_int_a_b) {\n\t\t \n\t\tret = pcf2127_configure_interrupt_pins(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to configure interrupt pins\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pcf2127->cfg->has_nvmem) {\n\t\tstruct nvmem_config nvmem_cfg = {\n\t\t\t.priv = pcf2127,\n\t\t\t.reg_read = pcf2127_nvmem_read,\n\t\t\t.reg_write = pcf2127_nvmem_write,\n\t\t\t.size = 512,\n\t\t};\n\n\t\tret = devm_rtc_nvmem_register(pcf2127->rtc, &nvmem_cfg);\n\t}\n\n\t \n\tret = regmap_clear_bits(pcf2127->regmap, PCF2127_REG_CTRL1,\n\t\t\t\tPCF2127_BIT_CTRL1_POR_OVRD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(pcf2127->regmap, pcf2127->cfg->reg_clkout, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(val & PCF2127_BIT_CLKOUT_OTPR)) {\n\t\tret = regmap_set_bits(pcf2127->regmap, pcf2127->cfg->reg_clkout,\n\t\t\t\t      PCF2127_BIT_CLKOUT_OTPR);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmsleep(100);\n\t}\n\n\t \n\tret = regmap_update_bits(pcf2127->regmap, pcf2127->cfg->reg_wd_ctl,\n\t\t\t\t PCF2127_BIT_WD_CTL_CD1 |\n\t\t\t\t PCF2127_BIT_WD_CTL_CD0 |\n\t\t\t\t PCF2127_BIT_WD_CTL_TF1 |\n\t\t\t\t PCF2127_BIT_WD_CTL_TF0,\n\t\t\t\t PCF2127_BIT_WD_CTL_CD1 |\n\t\t\t\t (pcf2127->cfg->has_bit_wd_ctl_cd0 ? PCF2127_BIT_WD_CTL_CD0 : 0) |\n\t\t\t\t PCF2127_BIT_WD_CTL_TF1);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: watchdog config (wd_ctl) failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpcf2127_watchdog_init(dev, pcf2127);\n\n\t \n\tret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL3,\n\t\t\t\t PCF2127_BIT_CTRL3_BTSE |\n\t\t\t\t PCF2127_BIT_CTRL3_BIE |\n\t\t\t\t PCF2127_BIT_CTRL3_BLIE, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: interrupt config (ctrl3) failed\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (int i = 0; i < pcf2127->cfg->ts_count; i++) {\n\t\tret = pcf2127_enable_ts(dev, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rtc_add_group(pcf2127->rtc, &pcf2127->cfg->attribute_group);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: tamper sysfs registering failed\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn devm_rtc_register_device(pcf2127->rtc);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pcf2127_of_match[] = {\n\t{ .compatible = \"nxp,pcf2127\", .data = &pcf21xx_cfg[PCF2127] },\n\t{ .compatible = \"nxp,pcf2129\", .data = &pcf21xx_cfg[PCF2129] },\n\t{ .compatible = \"nxp,pca2129\", .data = &pcf21xx_cfg[PCF2129] },\n\t{ .compatible = \"nxp,pcf2131\", .data = &pcf21xx_cfg[PCF2131] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pcf2127_of_match);\n#endif\n\n#if IS_ENABLED(CONFIG_I2C)\n\nstatic int pcf2127_i2c_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_master_send(client, data, count);\n\tif (ret != count)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int pcf2127_i2c_gather_write(void *context,\n\t\t\t\tconst void *reg, size_t reg_size,\n\t\t\t\tconst void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\tvoid *buf;\n\n\tif (WARN_ON(reg_size != 1))\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(val_size + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, reg, 1);\n\tmemcpy(buf + 1, val, val_size);\n\n\tret = i2c_master_send(client, buf, val_size + 1);\n\n\tkfree(buf);\n\n\tif (ret != val_size + 1)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int pcf2127_i2c_read(void *context, const void *reg, size_t reg_size,\n\t\t\t\tvoid *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tif (WARN_ON(reg_size != 1))\n\t\treturn -EINVAL;\n\n\tret = i2c_master_send(client, reg, 1);\n\tif (ret != 1)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tret = i2c_master_recv(client, val, val_size);\n\tif (ret != val_size)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\n \nstatic const struct regmap_bus pcf2127_i2c_regmap = {\n\t.write = pcf2127_i2c_write,\n\t.gather_write = pcf2127_i2c_gather_write,\n\t.read = pcf2127_i2c_read,\n};\n\nstatic struct i2c_driver pcf2127_i2c_driver;\n\nstatic const struct i2c_device_id pcf2127_i2c_id[] = {\n\t{ \"pcf2127\", PCF2127 },\n\t{ \"pcf2129\", PCF2129 },\n\t{ \"pca2129\", PCF2129 },\n\t{ \"pcf2131\", PCF2131 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf2127_i2c_id);\n\nstatic int pcf2127_i2c_probe(struct i2c_client *client)\n{\n\tstruct regmap *regmap;\n\tstatic struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\tconst struct pcf21xx_config *variant;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tif (client->dev.of_node) {\n\t\tvariant = of_device_get_match_data(&client->dev);\n\t\tif (!variant)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tenum pcf21xx_type type =\n\t\t\ti2c_match_id(pcf2127_i2c_id, client)->driver_data;\n\n\t\tif (type >= PCF21XX_LAST_ID)\n\t\t\treturn -ENODEV;\n\t\tvariant = &pcf21xx_cfg[type];\n\t}\n\n\tconfig.max_register = variant->max_register,\n\n\tregmap = devm_regmap_init(&client->dev, &pcf2127_i2c_regmap,\n\t\t\t\t\t&client->dev, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"%s: regmap allocation failed: %ld\\n\",\n\t\t\t__func__, PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn pcf2127_probe(&client->dev, regmap, client->irq, variant);\n}\n\nstatic struct i2c_driver pcf2127_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-pcf2127-i2c\",\n\t\t.of_match_table = of_match_ptr(pcf2127_of_match),\n\t},\n\t.probe\t\t= pcf2127_i2c_probe,\n\t.id_table\t= pcf2127_i2c_id,\n};\n\nstatic int pcf2127_i2c_register_driver(void)\n{\n\treturn i2c_add_driver(&pcf2127_i2c_driver);\n}\n\nstatic void pcf2127_i2c_unregister_driver(void)\n{\n\ti2c_del_driver(&pcf2127_i2c_driver);\n}\n\n#else\n\nstatic int pcf2127_i2c_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void pcf2127_i2c_unregister_driver(void)\n{\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_SPI_MASTER)\n\nstatic struct spi_driver pcf2127_spi_driver;\nstatic const struct spi_device_id pcf2127_spi_id[];\n\nstatic int pcf2127_spi_probe(struct spi_device *spi)\n{\n\tstatic struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.read_flag_mask = 0xa0,\n\t\t.write_flag_mask = 0x20,\n\t};\n\tstruct regmap *regmap;\n\tconst struct pcf21xx_config *variant;\n\n\tif (spi->dev.of_node) {\n\t\tvariant = of_device_get_match_data(&spi->dev);\n\t\tif (!variant)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tenum pcf21xx_type type = spi_get_device_id(spi)->driver_data;\n\n\t\tif (type >= PCF21XX_LAST_ID)\n\t\t\treturn -ENODEV;\n\t\tvariant = &pcf21xx_cfg[type];\n\t}\n\n\tconfig.max_register = variant->max_register,\n\n\tregmap = devm_regmap_init_spi(spi, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&spi->dev, \"%s: regmap allocation failed: %ld\\n\",\n\t\t\t__func__, PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn pcf2127_probe(&spi->dev, regmap, spi->irq, variant);\n}\n\nstatic const struct spi_device_id pcf2127_spi_id[] = {\n\t{ \"pcf2127\", PCF2127 },\n\t{ \"pcf2129\", PCF2129 },\n\t{ \"pca2129\", PCF2129 },\n\t{ \"pcf2131\", PCF2131 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, pcf2127_spi_id);\n\nstatic struct spi_driver pcf2127_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-pcf2127-spi\",\n\t\t.of_match_table = of_match_ptr(pcf2127_of_match),\n\t},\n\t.probe\t\t= pcf2127_spi_probe,\n\t.id_table\t= pcf2127_spi_id,\n};\n\nstatic int pcf2127_spi_register_driver(void)\n{\n\treturn spi_register_driver(&pcf2127_spi_driver);\n}\n\nstatic void pcf2127_spi_unregister_driver(void)\n{\n\tspi_unregister_driver(&pcf2127_spi_driver);\n}\n\n#else\n\nstatic int pcf2127_spi_register_driver(void)\n{\n\treturn 0;\n}\n\nstatic void pcf2127_spi_unregister_driver(void)\n{\n}\n\n#endif\n\nstatic int __init pcf2127_init(void)\n{\n\tint ret;\n\n\tret = pcf2127_i2c_register_driver();\n\tif (ret) {\n\t\tpr_err(\"Failed to register pcf2127 i2c driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcf2127_spi_register_driver();\n\tif (ret) {\n\t\tpr_err(\"Failed to register pcf2127 spi driver: %d\\n\", ret);\n\t\tpcf2127_i2c_unregister_driver();\n\t}\n\n\treturn ret;\n}\nmodule_init(pcf2127_init)\n\nstatic void __exit pcf2127_exit(void)\n{\n\tpcf2127_spi_unregister_driver();\n\tpcf2127_i2c_unregister_driver();\n}\nmodule_exit(pcf2127_exit)\n\nMODULE_AUTHOR(\"Renaud Cerrato <r.cerrato@til-technologies.fr>\");\nMODULE_DESCRIPTION(\"NXP PCF2127/29/31 RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}