{
  "module_name": "rtc-m48t59.c",
  "hash_id": "cc1248a98a652177bfaf8272ac8a61bc7ab91de65e5351c80e27567920686bba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-m48t59.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/rtc/m48t59.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n\n#ifndef NO_IRQ\n#define NO_IRQ\t(-1)\n#endif\n\n#define M48T59_READ(reg) (pdata->read_byte(dev, pdata->offset + reg))\n#define M48T59_WRITE(val, reg) \\\n\t(pdata->write_byte(dev, pdata->offset + reg, val))\n\n#define M48T59_SET_BITS(mask, reg)\t\\\n\tM48T59_WRITE((M48T59_READ(reg) | (mask)), (reg))\n#define M48T59_CLEAR_BITS(mask, reg)\t\\\n\tM48T59_WRITE((M48T59_READ(reg) & ~(mask)), (reg))\n\nstruct m48t59_private {\n\tvoid __iomem *ioaddr;\n\tint irq;\n\tstruct rtc_device *rtc;\n\tspinlock_t lock;  \n};\n\n \nstatic void\nm48t59_mem_writeb(struct device *dev, u32 ofs, u8 val)\n{\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\n\twriteb(val, m48t59->ioaddr+ofs);\n}\n\nstatic u8\nm48t59_mem_readb(struct device *dev, u32 ofs)\n{\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\n\treturn readb(m48t59->ioaddr+ofs);\n}\n\n \nstatic int m48t59_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\t \n\tM48T59_SET_BITS(M48T59_CNTL_READ, M48T59_CNTL);\n\n\ttm->tm_year\t= bcd2bin(M48T59_READ(M48T59_YEAR));\n\t \n\ttm->tm_mon\t= bcd2bin(M48T59_READ(M48T59_MONTH)) - 1;\n\ttm->tm_mday\t= bcd2bin(M48T59_READ(M48T59_MDAY));\n\n\tval = M48T59_READ(M48T59_WDAY);\n\tif ((pdata->type == M48T59RTC_TYPE_M48T59) &&\n\t    (val & M48T59_WDAY_CEB) && (val & M48T59_WDAY_CB)) {\n\t\tdev_dbg(dev, \"Century bit is enabled\\n\");\n\t\ttm->tm_year += 100;\t \n\t}\n#ifdef CONFIG_SPARC\n\t \n\ttm->tm_year += 68;\n#endif\n\n\ttm->tm_wday\t= bcd2bin(val & 0x07);\n\ttm->tm_hour\t= bcd2bin(M48T59_READ(M48T59_HOUR) & 0x3F);\n\ttm->tm_min\t= bcd2bin(M48T59_READ(M48T59_MIN) & 0x7F);\n\ttm->tm_sec\t= bcd2bin(M48T59_READ(M48T59_SEC) & 0x7F);\n\n\t \n\tM48T59_CLEAR_BITS(M48T59_CNTL_READ, M48T59_CNTL);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\tdev_dbg(dev, \"RTC read time %ptR\\n\", tm);\n\treturn 0;\n}\n\nstatic int m48t59_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu8 val = 0;\n\tint year = tm->tm_year;\n\n#ifdef CONFIG_SPARC\n\t \n\tyear -= 68;\n#endif\n\n\tdev_dbg(dev, \"RTC set time %04d-%02d-%02d %02d/%02d/%02d\\n\",\n\t\tyear + 1900, tm->tm_mon, tm->tm_mday,\n\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\n\tif (year < 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\t \n\tM48T59_SET_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\n\n\tM48T59_WRITE((bin2bcd(tm->tm_sec) & 0x7F), M48T59_SEC);\n\tM48T59_WRITE((bin2bcd(tm->tm_min) & 0x7F), M48T59_MIN);\n\tM48T59_WRITE((bin2bcd(tm->tm_hour) & 0x3F), M48T59_HOUR);\n\tM48T59_WRITE((bin2bcd(tm->tm_mday) & 0x3F), M48T59_MDAY);\n\t \n\tM48T59_WRITE((bin2bcd(tm->tm_mon + 1) & 0x1F), M48T59_MONTH);\n\tM48T59_WRITE(bin2bcd(year % 100), M48T59_YEAR);\n\n\tif (pdata->type == M48T59RTC_TYPE_M48T59 && (year / 100))\n\t\tval = (M48T59_WDAY_CEB | M48T59_WDAY_CB);\n\tval |= (bin2bcd(tm->tm_wday) & 0x07);\n\tM48T59_WRITE(val, M48T59_WDAY);\n\n\t \n\tM48T59_CLEAR_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\treturn 0;\n}\n\n \nstatic int m48t59_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tunsigned long flags;\n\tu8 val;\n\n\t \n\tif (m48t59->irq == NO_IRQ)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\t \n\tM48T59_SET_BITS(M48T59_CNTL_READ, M48T59_CNTL);\n\n\ttm->tm_year = bcd2bin(M48T59_READ(M48T59_YEAR));\n#ifdef CONFIG_SPARC\n\t \n\ttm->tm_year += 68;\n#endif\n\t \n\ttm->tm_mon = bcd2bin(M48T59_READ(M48T59_MONTH)) - 1;\n\n\tval = M48T59_READ(M48T59_WDAY);\n\tif ((val & M48T59_WDAY_CEB) && (val & M48T59_WDAY_CB))\n\t\ttm->tm_year += 100;\t \n\n\ttm->tm_mday = bcd2bin(M48T59_READ(M48T59_ALARM_DATE));\n\ttm->tm_hour = bcd2bin(M48T59_READ(M48T59_ALARM_HOUR));\n\ttm->tm_min = bcd2bin(M48T59_READ(M48T59_ALARM_MIN));\n\ttm->tm_sec = bcd2bin(M48T59_READ(M48T59_ALARM_SEC));\n\n\t \n\tM48T59_CLEAR_BITS(M48T59_CNTL_READ, M48T59_CNTL);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\tdev_dbg(dev, \"RTC read alarm time %ptR\\n\", tm);\n\treturn rtc_valid_tm(tm);\n}\n\n \nstatic int m48t59_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tstruct rtc_time *tm = &alrm->time;\n\tu8 mday, hour, min, sec;\n\tunsigned long flags;\n\tint year = tm->tm_year;\n\n#ifdef CONFIG_SPARC\n\t \n\tyear -= 68;\n#endif\n\n\t \n\tif (m48t59->irq == NO_IRQ)\n\t\treturn -EIO;\n\n\tif (year < 0)\n\t\treturn -EINVAL;\n\n\t \n\tmday = tm->tm_mday;\n\tmday = (mday >= 1 && mday <= 31) ? bin2bcd(mday) : 0xff;\n\tif (mday == 0xff)\n\t\tmday = M48T59_READ(M48T59_MDAY);\n\n\thour = tm->tm_hour;\n\thour = (hour < 24) ? bin2bcd(hour) : 0x00;\n\n\tmin = tm->tm_min;\n\tmin = (min < 60) ? bin2bcd(min) : 0x00;\n\n\tsec = tm->tm_sec;\n\tsec = (sec < 60) ? bin2bcd(sec) : 0x00;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\t \n\tM48T59_SET_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\n\n\tM48T59_WRITE(mday, M48T59_ALARM_DATE);\n\tM48T59_WRITE(hour, M48T59_ALARM_HOUR);\n\tM48T59_WRITE(min, M48T59_ALARM_MIN);\n\tM48T59_WRITE(sec, M48T59_ALARM_SEC);\n\n\t \n\tM48T59_CLEAR_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\tdev_dbg(dev, \"RTC set alarm time %04d-%02d-%02d %02d/%02d/%02d\\n\",\n\t\tyear + 1900, tm->tm_mon, tm->tm_mday,\n\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\treturn 0;\n}\n\n \nstatic int m48t59_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\tif (enabled)\n\t\tM48T59_WRITE(M48T59_INTR_AFE, M48T59_INTR);\n\telse\n\t\tM48T59_WRITE(0x00, M48T59_INTR);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\treturn 0;\n}\n\nstatic int m48t59_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\tval = M48T59_READ(M48T59_FLAGS);\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\tseq_printf(seq, \"battery\\t\\t: %s\\n\",\n\t\t (val & M48T59_FLAGS_BF) ? \"low\" : \"normal\");\n\treturn 0;\n}\n\n \nstatic irqreturn_t m48t59_rtc_interrupt(int irq, void *dev_id)\n{\n\tstruct device *dev = (struct device *)dev_id;\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(dev);\n\tstruct m48t59_private *m48t59 = dev_get_drvdata(dev);\n\tu8 event;\n\n\tspin_lock(&m48t59->lock);\n\tevent = M48T59_READ(M48T59_FLAGS);\n\tspin_unlock(&m48t59->lock);\n\n\tif (event & M48T59_FLAGS_AF) {\n\t\trtc_update_irq(m48t59->rtc, 1, (RTC_AF | RTC_IRQF));\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct rtc_class_ops m48t59_rtc_ops = {\n\t.read_time\t= m48t59_rtc_read_time,\n\t.set_time\t= m48t59_rtc_set_time,\n\t.read_alarm\t= m48t59_rtc_readalarm,\n\t.set_alarm\t= m48t59_rtc_setalarm,\n\t.proc\t\t= m48t59_rtc_proc,\n\t.alarm_irq_enable = m48t59_rtc_alarm_irq_enable,\n};\n\nstatic int m48t59_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t size)\n{\n\tstruct platform_device *pdev = priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\n\tssize_t cnt = 0;\n\tunsigned long flags;\n\tu8 *buf = val;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\n\tfor (; cnt < size; cnt++)\n\t\t*buf++ = M48T59_READ(cnt);\n\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\treturn 0;\n}\n\nstatic int m48t59_nvram_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t size)\n{\n\tstruct platform_device *pdev = priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\n\tssize_t cnt = 0;\n\tunsigned long flags;\n\tu8 *buf = val;\n\n\tspin_lock_irqsave(&m48t59->lock, flags);\n\n\tfor (; cnt < size; cnt++)\n\t\tM48T59_WRITE(*buf++, cnt);\n\n\tspin_unlock_irqrestore(&m48t59->lock, flags);\n\n\treturn 0;\n}\n\nstatic int m48t59_rtc_probe(struct platform_device *pdev)\n{\n\tstruct m48t59_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct m48t59_private *m48t59 = NULL;\n\tstruct resource *res;\n\tint ret = -ENOMEM;\n\tstruct nvmem_config nvmem_cfg = {\n\t\t.name = \"m48t59-\",\n\t\t.word_size = 1,\n\t\t.stride = 1,\n\t\t.reg_read = m48t59_nvram_read,\n\t\t.reg_write = m48t59_nvram_write,\n\t\t.priv = pdev,\n\t};\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\t\tif (!res)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\t \n\t\tif (!pdata || !pdata->write_byte || !pdata->read_byte)\n\t\t\treturn -EINVAL;\n\t} else if (res->flags & IORESOURCE_MEM) {\n\t\t \n\t\tif (!pdata) {\n\t\t\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!pdata)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tpdev->dev.platform_data = pdata;\n\t\t}\n\t\tif (!pdata->type)\n\t\t\tpdata->type = M48T59RTC_TYPE_M48T59;\n\n\t\t \n\t\tif (!pdata->write_byte)\n\t\t\tpdata->write_byte = m48t59_mem_writeb;\n\t\tif (!pdata->read_byte)\n\t\t\tpdata->read_byte = m48t59_mem_readb;\n\t}\n\n\tm48t59 = devm_kzalloc(&pdev->dev, sizeof(*m48t59), GFP_KERNEL);\n\tif (!m48t59)\n\t\treturn -ENOMEM;\n\n\tm48t59->ioaddr = pdata->ioaddr;\n\n\tif (!m48t59->ioaddr) {\n\t\t \n\t\tm48t59->ioaddr = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\t\tif (!m48t59->ioaddr)\n\t\t\treturn ret;\n\t}\n\n\t \n\tm48t59->irq = platform_get_irq_optional(pdev, 0);\n\tif (m48t59->irq <= 0)\n\t\tm48t59->irq = NO_IRQ;\n\n\tif (m48t59->irq != NO_IRQ) {\n\t\tret = devm_request_irq(&pdev->dev, m48t59->irq,\n\t\t\t\tm48t59_rtc_interrupt, IRQF_SHARED,\n\t\t\t\t\"rtc-m48t59\", &pdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tm48t59->rtc = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(m48t59->rtc))\n\t\treturn PTR_ERR(m48t59->rtc);\n\n\tswitch (pdata->type) {\n\tcase M48T59RTC_TYPE_M48T59:\n\t\tpdata->offset = 0x1ff0;\n\t\tbreak;\n\tcase M48T59RTC_TYPE_M48T02:\n\t\tclear_bit(RTC_FEATURE_ALARM, m48t59->rtc->features);\n\t\tpdata->offset = 0x7f0;\n\t\tbreak;\n\tcase M48T59RTC_TYPE_M48T08:\n\t\tclear_bit(RTC_FEATURE_ALARM, m48t59->rtc->features);\n\t\tpdata->offset = 0x1ff0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown RTC type\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&m48t59->lock);\n\tplatform_set_drvdata(pdev, m48t59);\n\n\tm48t59->rtc->ops = &m48t59_rtc_ops;\n\n\tnvmem_cfg.size = pdata->offset;\n\tret = devm_rtc_nvmem_register(m48t59->rtc, &nvmem_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_rtc_register_device(m48t59->rtc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nMODULE_ALIAS(\"platform:rtc-m48t59\");\n\nstatic struct platform_driver m48t59_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-m48t59\",\n\t},\n\t.probe\t\t= m48t59_rtc_probe,\n};\n\nmodule_platform_driver(m48t59_rtc_driver);\n\nMODULE_AUTHOR(\"Mark Zhan <rongkai.zhan@windriver.com>\");\nMODULE_DESCRIPTION(\"M48T59/M48T02/M48T08 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}