{
  "module_name": "rtc-fsl-ftm-alarm.c",
  "hash_id": "4624c9067b2260daa352d9acc92b7a456bd578c2ad0de06911304486d64e8f01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-fsl-ftm-alarm.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/fsl/ftm.h>\n#include <linux/rtc.h>\n#include <linux/time.h>\n#include <linux/acpi.h>\n#include <linux/pm_wakeirq.h>\n\n#define FTM_SC_CLK(c)\t\t((c) << FTM_SC_CLK_MASK_SHIFT)\n\n \n#define FTM_SC_CLKS_FIXED_FREQ\t0x02\n#define FIXED_FREQ_CLK\t\t32000\n\n \n#define MAX_FREQ_DIV\t\t(1 << FTM_SC_PS_MASK)\n\n \n#define MAX_COUNT_VAL\t\t0xffff\n\nstruct ftm_rtc {\n\tstruct rtc_device *rtc_dev;\n\tvoid __iomem *base;\n\tbool big_endian;\n\tu32 alarm_freq;\n};\n\nstatic inline u32 rtc_readl(struct ftm_rtc *dev, u32 reg)\n{\n\tif (dev->big_endian)\n\t\treturn ioread32be(dev->base + reg);\n\telse\n\t\treturn ioread32(dev->base + reg);\n}\n\nstatic inline void rtc_writel(struct ftm_rtc *dev, u32 reg, u32 val)\n{\n\tif (dev->big_endian)\n\t\tiowrite32be(val, dev->base + reg);\n\telse\n\t\tiowrite32(val, dev->base + reg);\n}\n\nstatic inline void ftm_counter_enable(struct ftm_rtc *rtc)\n{\n\tu32 val;\n\n\t \n\tval = rtc_readl(rtc, FTM_SC);\n\tval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\n\tval |= (FTM_SC_PS_MASK | FTM_SC_CLK(FTM_SC_CLKS_FIXED_FREQ));\n\trtc_writel(rtc, FTM_SC, val);\n}\n\nstatic inline void ftm_counter_disable(struct ftm_rtc *rtc)\n{\n\tu32 val;\n\n\t \n\tval = rtc_readl(rtc, FTM_SC);\n\tval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\n\trtc_writel(rtc, FTM_SC, val);\n}\n\nstatic inline void ftm_irq_acknowledge(struct ftm_rtc *rtc)\n{\n\tunsigned int timeout = 100;\n\n\t \n\twhile ((FTM_SC_TOF & rtc_readl(rtc, FTM_SC)) && timeout--)\n\t\trtc_writel(rtc, FTM_SC, rtc_readl(rtc, FTM_SC) & (~FTM_SC_TOF));\n}\n\nstatic inline void ftm_irq_enable(struct ftm_rtc *rtc)\n{\n\tu32 val;\n\n\tval = rtc_readl(rtc, FTM_SC);\n\tval |= FTM_SC_TOIE;\n\trtc_writel(rtc, FTM_SC, val);\n}\n\nstatic inline void ftm_irq_disable(struct ftm_rtc *rtc)\n{\n\tu32 val;\n\n\tval = rtc_readl(rtc, FTM_SC);\n\tval &= ~FTM_SC_TOIE;\n\trtc_writel(rtc, FTM_SC, val);\n}\n\nstatic inline void ftm_reset_counter(struct ftm_rtc *rtc)\n{\n\t \n\trtc_writel(rtc, FTM_CNT, 0x00);\n}\n\nstatic void ftm_clean_alarm(struct ftm_rtc *rtc)\n{\n\tftm_counter_disable(rtc);\n\n\trtc_writel(rtc, FTM_CNTIN, 0x00);\n\trtc_writel(rtc, FTM_MOD, ~0U);\n\n\tftm_reset_counter(rtc);\n}\n\nstatic irqreturn_t ftm_rtc_alarm_interrupt(int irq, void *dev)\n{\n\tstruct ftm_rtc *rtc = dev;\n\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\tftm_irq_acknowledge(rtc);\n\tftm_irq_disable(rtc);\n\tftm_clean_alarm(rtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ftm_rtc_alarm_irq_enable(struct device *dev,\n\t\tunsigned int enabled)\n{\n\tstruct ftm_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\tftm_irq_enable(rtc);\n\telse\n\t\tftm_irq_disable(rtc);\n\n\treturn 0;\n}\n\n \nstatic int ftm_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\trtc_time64_to_tm(ktime_get_real_seconds(), tm);\n\n\treturn 0;\n}\n\nstatic int ftm_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\treturn 0;\n}\n\n \nstatic int ftm_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\ttime64_t alm_time;\n\tunsigned long long cycle;\n\tstruct ftm_rtc *rtc = dev_get_drvdata(dev);\n\n\talm_time = rtc_tm_to_time64(&alm->time);\n\n\tftm_clean_alarm(rtc);\n\tcycle = (alm_time - ktime_get_real_seconds()) * rtc->alarm_freq;\n\tif (cycle > MAX_COUNT_VAL) {\n\t\tpr_err(\"Out of alarm range {0~262} seconds.\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tftm_irq_disable(rtc);\n\n\t \n\trtc_writel(rtc, FTM_MOD, cycle - 1);\n\n\tftm_counter_enable(rtc);\n\tftm_irq_enable(rtc);\n\n\treturn 0;\n\n}\n\nstatic const struct rtc_class_ops ftm_rtc_ops = {\n\t.read_time\t\t= ftm_rtc_read_time,\n\t.read_alarm\t\t= ftm_rtc_read_alarm,\n\t.set_alarm\t\t= ftm_rtc_set_alarm,\n\t.alarm_irq_enable\t= ftm_rtc_alarm_irq_enable,\n};\n\nstatic int ftm_rtc_probe(struct platform_device *pdev)\n{\n\tint irq;\n\tint ret;\n\tstruct ftm_rtc *rtc;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (unlikely(!rtc)) {\n\t\tdev_err(&pdev->dev, \"cannot alloc memory for rtc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\trtc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->base)) {\n\t\tdev_err(&pdev->dev, \"cannot ioremap resource for rtc\\n\");\n\t\treturn PTR_ERR(rtc->base);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, ftm_rtc_alarm_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), rtc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\trtc->big_endian =\n\t\tdevice_property_read_bool(&pdev->dev, \"big-endian\");\n\n\trtc->alarm_freq = (u32)FIXED_FREQ_CLK / (u32)MAX_FREQ_DIV;\n\trtc->rtc_dev->ops = &ftm_rtc_ops;\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tret = dev_pm_set_wake_irq(&pdev->dev, irq);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to enable irq wake\\n\");\n\n\tret = devm_rtc_register_device(rtc->rtc_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't register rtc device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ftm_rtc_match[] = {\n\t{ .compatible = \"fsl,ls1012a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls1021a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls1028a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls1043a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls1046a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls1088a-ftm-alarm\", },\n\t{ .compatible = \"fsl,ls208xa-ftm-alarm\", },\n\t{ .compatible = \"fsl,lx2160a-ftm-alarm\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ftm_rtc_match);\n\nstatic const struct acpi_device_id ftm_imx_acpi_ids[] = {\n\t{\"NXP0014\",},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ftm_imx_acpi_ids);\n\nstatic struct platform_driver ftm_rtc_driver = {\n\t.probe\t\t= ftm_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ftm-alarm\",\n\t\t.of_match_table = ftm_rtc_match,\n\t\t.acpi_match_table = ACPI_PTR(ftm_imx_acpi_ids),\n\t},\n};\n\nmodule_platform_driver(ftm_rtc_driver);\n\nMODULE_DESCRIPTION(\"NXP/Freescale FlexTimer alarm driver\");\nMODULE_AUTHOR(\"Biwen Li <biwen.li@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}