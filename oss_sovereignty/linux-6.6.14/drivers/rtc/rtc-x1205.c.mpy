{
  "module_name": "rtc-x1205.c",
  "hash_id": "ab17d2e94832626c4e0bb229e7bfddff6c9cfea1c48ebc1264e6f34d4b56cce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-x1205.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/bcd.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n\n \n\n#define CCR_SEC\t\t\t0\n#define CCR_MIN\t\t\t1\n#define CCR_HOUR\t\t2\n#define CCR_MDAY\t\t3\n#define CCR_MONTH\t\t4\n#define CCR_YEAR\t\t5\n#define CCR_WDAY\t\t6\n#define CCR_Y2K\t\t\t7\n\n#define X1205_REG_SR\t\t0x3F\t \n#define X1205_REG_Y2K\t\t0x37\n#define X1205_REG_DW\t\t0x36\n#define X1205_REG_YR\t\t0x35\n#define X1205_REG_MO\t\t0x34\n#define X1205_REG_DT\t\t0x33\n#define X1205_REG_HR\t\t0x32\n#define X1205_REG_MN\t\t0x31\n#define X1205_REG_SC\t\t0x30\n#define X1205_REG_DTR\t\t0x13\n#define X1205_REG_ATR\t\t0x12\n#define X1205_REG_INT\t\t0x11\n#define X1205_REG_0\t\t0x10\n#define X1205_REG_Y2K1\t\t0x0F\n#define X1205_REG_DWA1\t\t0x0E\n#define X1205_REG_YRA1\t\t0x0D\n#define X1205_REG_MOA1\t\t0x0C\n#define X1205_REG_DTA1\t\t0x0B\n#define X1205_REG_HRA1\t\t0x0A\n#define X1205_REG_MNA1\t\t0x09\n#define X1205_REG_SCA1\t\t0x08\n#define X1205_REG_Y2K0\t\t0x07\n#define X1205_REG_DWA0\t\t0x06\n#define X1205_REG_YRA0\t\t0x05\n#define X1205_REG_MOA0\t\t0x04\n#define X1205_REG_DTA0\t\t0x03\n#define X1205_REG_HRA0\t\t0x02\n#define X1205_REG_MNA0\t\t0x01\n#define X1205_REG_SCA0\t\t0x00\n\n#define X1205_CCR_BASE\t\t0x30\t \n#define X1205_ALM0_BASE\t\t0x00\t \n\n#define X1205_SR_RTCF\t\t0x01\t \n#define X1205_SR_WEL\t\t0x02\t \n#define X1205_SR_RWEL\t\t0x04\t \n#define X1205_SR_AL0\t\t0x20\t \n\n#define X1205_DTR_DTR0\t\t0x01\n#define X1205_DTR_DTR1\t\t0x02\n#define X1205_DTR_DTR2\t\t0x04\n\n#define X1205_HR_MIL\t\t0x80\t \n\n#define X1205_INT_AL0E\t\t0x20\t \n\nstatic struct i2c_driver x1205_driver;\n\n \nstatic int x1205_get_datetime(struct i2c_client *client, struct rtc_time *tm,\n\t\t\t\tunsigned char reg_base)\n{\n\tunsigned char dt_addr[2] = { 0, reg_base };\n\tunsigned char buf[8];\n\tint i;\n\n\tstruct i2c_msg msgs[] = {\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.len = 2,\n\t\t\t.buf = dt_addr\n\t\t},\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 8,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\n\t \n\tif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"%s: raw read data - sec=%02x, min=%02x, hr=%02x, \"\n\t\t\"mday=%02x, mon=%02x, year=%02x, wday=%02x, y2k=%02x\\n\",\n\t\t__func__,\n\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\tbuf[4], buf[5], buf[6], buf[7]);\n\n\t \n\tif (reg_base < X1205_CCR_BASE)\n\t\tfor (i = 0; i <= 4; i++)\n\t\t\tbuf[i] &= 0x7F;\n\n\ttm->tm_sec = bcd2bin(buf[CCR_SEC]);\n\ttm->tm_min = bcd2bin(buf[CCR_MIN]);\n\ttm->tm_hour = bcd2bin(buf[CCR_HOUR] & 0x3F);  \n\ttm->tm_mday = bcd2bin(buf[CCR_MDAY]);\n\ttm->tm_mon = bcd2bin(buf[CCR_MONTH]) - 1;  \n\ttm->tm_year = bcd2bin(buf[CCR_YEAR])\n\t\t\t+ (bcd2bin(buf[CCR_Y2K]) * 100) - 1900;\n\ttm->tm_wday = buf[CCR_WDAY];\n\n\tdev_dbg(&client->dev, \"%s: tm is secs=%d, mins=%d, hours=%d, \"\n\t\t\"mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t__func__,\n\t\ttm->tm_sec, tm->tm_min, tm->tm_hour,\n\t\ttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\treturn 0;\n}\n\nstatic int x1205_get_status(struct i2c_client *client, unsigned char *sr)\n{\n\tstatic unsigned char sr_addr[2] = { 0, X1205_REG_SR };\n\n\tstruct i2c_msg msgs[] = {\n\t\t{      \n\t\t\t.addr = client->addr,\n\t\t\t.len = 2,\n\t\t\t.buf = sr_addr\n\t\t},\n\t\t{     \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = sr\n\t\t},\n\t};\n\n\t \n\tif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int x1205_set_datetime(struct i2c_client *client, struct rtc_time *tm,\n\t\t\tu8 reg_base, unsigned char alm_enable)\n{\n\tint i, xfer;\n\tunsigned char rdata[10] = { 0, reg_base };\n\tunsigned char *buf = rdata + 2;\n\n\tstatic const unsigned char wel[3] = { 0, X1205_REG_SR,\n\t\t\t\t\t\tX1205_SR_WEL };\n\n\tstatic const unsigned char rwel[3] = { 0, X1205_REG_SR,\n\t\t\t\t\t\tX1205_SR_WEL | X1205_SR_RWEL };\n\n\tstatic const unsigned char diswe[3] = { 0, X1205_REG_SR, 0 };\n\n\tdev_dbg(&client->dev,\n\t\t\"%s: sec=%d min=%d hour=%d mday=%d mon=%d year=%d wday=%d\\n\",\n\t\t__func__, tm->tm_sec, tm->tm_min, tm->tm_hour, tm->tm_mday,\n\t\ttm->tm_mon, tm->tm_year, tm->tm_wday);\n\n\tbuf[CCR_SEC] = bin2bcd(tm->tm_sec);\n\tbuf[CCR_MIN] = bin2bcd(tm->tm_min);\n\n\t \n\tbuf[CCR_HOUR] = bin2bcd(tm->tm_hour) | X1205_HR_MIL;\n\n\tbuf[CCR_MDAY] = bin2bcd(tm->tm_mday);\n\n\t \n\tbuf[CCR_MONTH] = bin2bcd(tm->tm_mon + 1);\n\n\t \n\tbuf[CCR_YEAR] = bin2bcd(tm->tm_year % 100);\n\tbuf[CCR_WDAY] = tm->tm_wday & 0x07;\n\tbuf[CCR_Y2K] = bin2bcd((tm->tm_year + 1900) / 100);\n\n\t \n\tif (reg_base < X1205_CCR_BASE)\n\t\tfor (i = 0; i <= 4; i++)\n\t\t\tbuf[i] |= 0x80;\n\n\t \n\txfer = i2c_master_send(client, wel, 3);\n\tif (xfer != 3) {\n\t\tdev_err(&client->dev, \"%s: wel - %d\\n\", __func__, xfer);\n\t\treturn -EIO;\n\t}\n\n\txfer = i2c_master_send(client, rwel, 3);\n\tif (xfer != 3) {\n\t\tdev_err(&client->dev, \"%s: rwel - %d\\n\", __func__, xfer);\n\t\treturn -EIO;\n\t}\n\n\txfer = i2c_master_send(client, rdata, sizeof(rdata));\n\tif (xfer != sizeof(rdata)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: result=%d addr=%02x, data=%02x\\n\",\n\t\t\t__func__,\n\t\t\t xfer, rdata[1], rdata[2]);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (reg_base < X1205_CCR_BASE) {\n\t\tunsigned char al0e[3] = { 0, X1205_REG_INT, 0 };\n\n\t\tmsleep(10);\n\n\t\t \n\n\t\t \n\t\txfer = i2c_master_send(client, rwel, 3);\n\t\tif (xfer != 3) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: aloe rwel - %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\txfer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (alm_enable)\n\t\t\tal0e[2] = X1205_INT_AL0E;\n\n\t\txfer = i2c_master_send(client, al0e, 3);\n\t\tif (xfer != 3) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: al0e - %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\txfer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmsleep(10);\n\t}\n\n\t \n\txfer = i2c_master_send(client, diswe, 3);\n\tif (xfer != 3) {\n\t\tdev_err(&client->dev, \"%s: diswe - %d\\n\", __func__, xfer);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int x1205_fix_osc(struct i2c_client *client)\n{\n\tint err;\n\tstruct rtc_time tm;\n\n\tmemset(&tm, 0, sizeof(tm));\n\n\terr = x1205_set_datetime(client, &tm, X1205_CCR_BASE, 0);\n\tif (err < 0)\n\t\tdev_err(&client->dev, \"unable to restart the oscillator\\n\");\n\n\treturn err;\n}\n\nstatic int x1205_get_dtrim(struct i2c_client *client, int *trim)\n{\n\tunsigned char dtr;\n\tstatic unsigned char dtr_addr[2] = { 0, X1205_REG_DTR };\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\t \n\t\t\t.addr = client->addr,\n\t\t\t.len = 2,\n\t\t\t.buf = dtr_addr\n\t\t},\n\t\t{       \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &dtr\n\t\t},\n\t};\n\n\t \n\tif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev, \"%s: raw dtr=%x\\n\", __func__, dtr);\n\n\t*trim = 0;\n\n\tif (dtr & X1205_DTR_DTR0)\n\t\t*trim += 20;\n\n\tif (dtr & X1205_DTR_DTR1)\n\t\t*trim += 10;\n\n\tif (dtr & X1205_DTR_DTR2)\n\t\t*trim = -*trim;\n\n\treturn 0;\n}\n\nstatic int x1205_get_atrim(struct i2c_client *client, int *trim)\n{\n\ts8 atr;\n\tstatic unsigned char atr_addr[2] = { 0, X1205_REG_ATR };\n\n\tstruct i2c_msg msgs[] = {\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.len = 2,\n\t\t\t.buf = atr_addr\n\t\t},\n\t\t{ \n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &atr\n\t\t},\n\t};\n\n\t \n\tif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&client->dev, \"%s: raw atr=%x\\n\", __func__, atr);\n\n\t \n\tatr = sign_extend32(atr, 5);\n\n\tdev_dbg(&client->dev, \"%s: raw atr=%x (%d)\\n\", __func__, atr, atr);\n\n\t*trim = (atr * 250) + 11000;\n\n\tdev_dbg(&client->dev, \"%s: real=%d\\n\", __func__, *trim);\n\n\treturn 0;\n}\n\nstruct x1205_limit {\n\tunsigned char reg, mask, min, max;\n};\n\nstatic int x1205_validate_client(struct i2c_client *client)\n{\n\tint i, xfer;\n\n\t \n\tstatic const unsigned char probe_zero_pattern[] = {\n\t\t \n\t\tX1205_REG_SR,\t0x18,\n\t\tX1205_REG_DTR,\t0xF8,\n\t\tX1205_REG_ATR,\t0xC0,\n\t\tX1205_REG_INT,\t0x18,\n\t\tX1205_REG_0,\t0xFF,\n\t};\n\n\tstatic const struct x1205_limit probe_limits_pattern[] = {\n\t\t \n\t\t{ X1205_REG_Y2K,\t0xFF,\t19,\t20\t},\n\t\t{ X1205_REG_DW,\t\t0xFF,\t0,\t6\t},\n\t\t{ X1205_REG_YR,\t\t0xFF,\t0,\t99\t},\n\t\t{ X1205_REG_MO,\t\t0xFF,\t0,\t12\t},\n\t\t{ X1205_REG_DT,\t\t0xFF,\t0,\t31\t},\n\t\t{ X1205_REG_HR,\t\t0x7F,\t0,\t23\t},\n\t\t{ X1205_REG_MN,\t\t0xFF,\t0,\t59\t},\n\t\t{ X1205_REG_SC,\t\t0xFF,\t0,\t59\t},\n\t\t{ X1205_REG_Y2K1,\t0xFF,\t19,\t20\t},\n\t\t{ X1205_REG_Y2K0,\t0xFF,\t19,\t20\t},\n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(probe_zero_pattern); i += 2) {\n\t\tunsigned char buf;\n\n\t\tunsigned char addr[2] = { 0, probe_zero_pattern[i] };\n\n\t\tstruct i2c_msg msgs[2] = {\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = 2,\n\t\t\t\t.buf = addr\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t.len = 1,\n\t\t\t\t.buf = &buf\n\t\t\t},\n\t\t};\n\n\t\txfer = i2c_transfer(client->adapter, msgs, 2);\n\t\tif (xfer != 2) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: could not read register %x\\n\",\n\t\t\t\t__func__, probe_zero_pattern[i]);\n\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif ((buf & probe_zero_pattern[i+1]) != 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: register=%02x, zero pattern=%d, value=%x\\n\",\n\t\t\t\t__func__, probe_zero_pattern[i], i, buf);\n\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(probe_limits_pattern); i++) {\n\t\tunsigned char reg, value;\n\n\t\tunsigned char addr[2] = { 0, probe_limits_pattern[i].reg };\n\n\t\tstruct i2c_msg msgs[2] = {\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = 2,\n\t\t\t\t.buf = addr\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t.len = 1,\n\t\t\t\t.buf = &reg\n\t\t\t},\n\t\t};\n\n\t\txfer = i2c_transfer(client->adapter, msgs, 2);\n\t\tif (xfer != 2) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: could not read register %x\\n\",\n\t\t\t\t__func__, probe_limits_pattern[i].reg);\n\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tvalue = bcd2bin(reg & probe_limits_pattern[i].mask);\n\n\t\tif (value > probe_limits_pattern[i].max ||\n\t\t\tvalue < probe_limits_pattern[i].min) {\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"%s: register=%x, lim pattern=%d, value=%d\\n\",\n\t\t\t\t__func__, probe_limits_pattern[i].reg,\n\t\t\t\ti, value);\n\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int x1205_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tint err;\n\tunsigned char intreg, status;\n\tstatic unsigned char int_addr[2] = { 0, X1205_REG_INT };\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_msg msgs[] = {\n\t\t{  \n\t\t\t.addr = client->addr,\n\t\t\t.len = 2,\n\t\t\t.buf = int_addr\n\t\t},\n\t\t{ \n\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &intreg\n\t\t},\n\t};\n\n\t \n\tif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\n\t\tdev_err(&client->dev, \"%s: read error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\terr = x1205_get_status(client, &status);\n\tif (err == 0) {\n\t\talrm->pending = (status & X1205_SR_AL0) ? 1 : 0;\n\t\talrm->enabled = (intreg & X1205_INT_AL0E) ? 1 : 0;\n\t\terr = x1205_get_datetime(client, &alrm->time, X1205_ALM0_BASE);\n\t}\n\treturn err;\n}\n\nstatic int x1205_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\treturn x1205_set_datetime(to_i2c_client(dev),\n\t\t&alrm->time, X1205_ALM0_BASE, alrm->enabled);\n}\n\nstatic int x1205_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\treturn x1205_get_datetime(to_i2c_client(dev),\n\t\ttm, X1205_CCR_BASE);\n}\n\nstatic int x1205_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\treturn x1205_set_datetime(to_i2c_client(dev),\n\t\ttm, X1205_CCR_BASE, 0);\n}\n\nstatic int x1205_rtc_proc(struct device *dev, struct seq_file *seq)\n{\n\tint err, dtrim, atrim;\n\n\terr = x1205_get_dtrim(to_i2c_client(dev), &dtrim);\n\tif (!err)\n\t\tseq_printf(seq, \"digital_trim\\t: %d ppm\\n\", dtrim);\n\n\terr = x1205_get_atrim(to_i2c_client(dev), &atrim);\n\tif (!err)\n\t\tseq_printf(seq, \"analog_trim\\t: %d.%02d pF\\n\",\n\t\t\tatrim / 1000, atrim % 1000);\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops x1205_rtc_ops = {\n\t.proc\t\t= x1205_rtc_proc,\n\t.read_time\t= x1205_rtc_read_time,\n\t.set_time\t= x1205_rtc_set_time,\n\t.read_alarm\t= x1205_rtc_read_alarm,\n\t.set_alarm\t= x1205_rtc_set_alarm,\n};\n\nstatic ssize_t x1205_sysfs_show_atrim(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint err, atrim;\n\n\terr = x1205_get_atrim(to_i2c_client(dev), &atrim);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d.%02d pF\\n\", atrim / 1000, atrim % 1000);\n}\nstatic DEVICE_ATTR(atrim, S_IRUGO, x1205_sysfs_show_atrim, NULL);\n\nstatic ssize_t x1205_sysfs_show_dtrim(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint err, dtrim;\n\n\terr = x1205_get_dtrim(to_i2c_client(dev), &dtrim);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d ppm\\n\", dtrim);\n}\nstatic DEVICE_ATTR(dtrim, S_IRUGO, x1205_sysfs_show_dtrim, NULL);\n\nstatic int x1205_sysfs_register(struct device *dev)\n{\n\tint err;\n\n\terr = device_create_file(dev, &dev_attr_atrim);\n\tif (err)\n\t\treturn err;\n\n\terr = device_create_file(dev, &dev_attr_dtrim);\n\tif (err)\n\t\tdevice_remove_file(dev, &dev_attr_atrim);\n\n\treturn err;\n}\n\nstatic void x1205_sysfs_unregister(struct device *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_atrim);\n\tdevice_remove_file(dev, &dev_attr_dtrim);\n}\n\n\nstatic int x1205_probe(struct i2c_client *client)\n{\n\tint err = 0;\n\tunsigned char sr;\n\tstruct rtc_device *rtc;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tif (x1205_validate_client(client) < 0)\n\t\treturn -ENODEV;\n\n\trtc = devm_rtc_device_register(&client->dev, x1205_driver.driver.name,\n\t\t\t\t\t&x1205_rtc_ops, THIS_MODULE);\n\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\ti2c_set_clientdata(client, rtc);\n\n\t \n\terr = x1205_get_status(client, &sr);\n\tif (!err) {\n\t\tif (sr & X1205_SR_RTCF) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"power failure detected, \"\n\t\t\t\t\"please set the clock\\n\");\n\t\t\tudelay(50);\n\t\t\tx1205_fix_osc(client);\n\t\t}\n\t} else {\n\t\tdev_err(&client->dev, \"couldn't read status\\n\");\n\t}\n\n\terr = x1205_sysfs_register(&client->dev);\n\tif (err)\n\t\tdev_err(&client->dev, \"Unable to create sysfs entries\\n\");\n\n\treturn 0;\n}\n\nstatic void x1205_remove(struct i2c_client *client)\n{\n\tx1205_sysfs_unregister(&client->dev);\n}\n\nstatic const struct i2c_device_id x1205_id[] = {\n\t{ \"x1205\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, x1205_id);\n\nstatic const struct of_device_id x1205_dt_ids[] = {\n\t{ .compatible = \"xircom,x1205\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, x1205_dt_ids);\n\nstatic struct i2c_driver x1205_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-x1205\",\n\t\t.of_match_table = x1205_dt_ids,\n\t},\n\t.probe\t\t= x1205_probe,\n\t.remove\t\t= x1205_remove,\n\t.id_table\t= x1205_id,\n};\n\nmodule_i2c_driver(x1205_driver);\n\nMODULE_AUTHOR(\n\t\"Karen Spearel <kas111 at gmail dot com>, \"\n\t\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"Xicor/Intersil X1205 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}