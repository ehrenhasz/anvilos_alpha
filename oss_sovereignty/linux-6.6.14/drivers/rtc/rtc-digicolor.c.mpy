{
  "module_name": "rtc-digicolor.c",
  "hash_id": "43f1665c1749ee242121f1a223237eeb65ea691a0be2d62c9d80690011970244",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-digicolor.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/of.h>\n\n#define DC_RTC_CONTROL\t\t0x0\n#define DC_RTC_TIME\t\t0x8\n#define DC_RTC_REFERENCE\t0xc\n#define DC_RTC_ALARM\t\t0x10\n#define DC_RTC_INTFLAG_CLEAR\t0x14\n#define DC_RTC_INTENABLE\t0x16\n\n#define DC_RTC_CMD_MASK\t\t0xf\n#define DC_RTC_GO_BUSY\t\tBIT(7)\n\n#define CMD_NOP\t\t\t0\n#define CMD_RESET\t\t1\n#define CMD_WRITE\t\t3\n#define CMD_READ\t\t4\n\n#define CMD_DELAY_US\t\t(10*1000)\n#define CMD_TIMEOUT_US\t\t(500*CMD_DELAY_US)\n\nstruct dc_rtc {\n\tstruct rtc_device\t*rtc_dev;\n\tvoid __iomem\t\t*regs;\n};\n\nstatic int dc_rtc_cmds(struct dc_rtc *rtc, const u8 *cmds, int len)\n{\n\tu8 val;\n\tint i, ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\twriteb_relaxed((cmds[i] & DC_RTC_CMD_MASK) | DC_RTC_GO_BUSY,\n\t\t\t       rtc->regs + DC_RTC_CONTROL);\n\t\tret = readb_relaxed_poll_timeout(\n\t\t\trtc->regs + DC_RTC_CONTROL, val,\n\t\t\t!(val & DC_RTC_GO_BUSY), CMD_DELAY_US, CMD_TIMEOUT_US);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dc_rtc_read(struct dc_rtc *rtc, unsigned long *val)\n{\n\tstatic const u8 read_cmds[] = {CMD_READ, CMD_NOP};\n\tu32 reference, time1, time2;\n\tint ret;\n\n\tret = dc_rtc_cmds(rtc, read_cmds, ARRAY_SIZE(read_cmds));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\n\ttime1 = readl_relaxed(rtc->regs + DC_RTC_TIME);\n\t \n\twhile (1) {\n\t\ttime2 = readl_relaxed(rtc->regs + DC_RTC_TIME);\n\t\tif (time1 == time2)\n\t\t\tbreak;\n\t\ttime1 = time2;\n\t}\n\n\t*val = reference + time1;\n\treturn 0;\n}\n\nstatic int dc_rtc_write(struct dc_rtc *rtc, u32 val)\n{\n\tstatic const u8 write_cmds[] = {CMD_WRITE, CMD_NOP, CMD_RESET, CMD_NOP};\n\n\twritel_relaxed(val, rtc->regs + DC_RTC_REFERENCE);\n\treturn dc_rtc_cmds(rtc, write_cmds, ARRAY_SIZE(write_cmds));\n}\n\nstatic int dc_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct dc_rtc *rtc = dev_get_drvdata(dev);\n\tunsigned long now;\n\tint ret;\n\n\tret = dc_rtc_read(rtc, &now);\n\tif (ret < 0)\n\t\treturn ret;\n\trtc_time64_to_tm(now, tm);\n\n\treturn 0;\n}\n\nstatic int dc_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct dc_rtc *rtc = dev_get_drvdata(dev);\n\n\treturn dc_rtc_write(rtc, rtc_tm_to_time64(tm));\n}\n\nstatic int dc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct dc_rtc *rtc = dev_get_drvdata(dev);\n\tu32 alarm_reg, reference;\n\tunsigned long now;\n\tint ret;\n\n\talarm_reg = readl_relaxed(rtc->regs + DC_RTC_ALARM);\n\treference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\n\trtc_time64_to_tm(reference + alarm_reg, &alarm->time);\n\n\tret = dc_rtc_read(rtc, &now);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talarm->pending = alarm_reg + reference > now;\n\talarm->enabled = readl_relaxed(rtc->regs + DC_RTC_INTENABLE);\n\n\treturn 0;\n}\n\nstatic int dc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct dc_rtc *rtc = dev_get_drvdata(dev);\n\ttime64_t alarm_time;\n\tu32 reference;\n\n\talarm_time = rtc_tm_to_time64(&alarm->time);\n\n\treference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\n\twritel_relaxed(alarm_time - reference, rtc->regs + DC_RTC_ALARM);\n\n\twriteb_relaxed(!!alarm->enabled, rtc->regs + DC_RTC_INTENABLE);\n\n\treturn 0;\n}\n\nstatic int dc_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct dc_rtc *rtc = dev_get_drvdata(dev);\n\n\twriteb_relaxed(!!enabled, rtc->regs + DC_RTC_INTENABLE);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops dc_rtc_ops = {\n\t.read_time\t\t= dc_rtc_read_time,\n\t.set_time\t\t= dc_rtc_set_time,\n\t.read_alarm\t\t= dc_rtc_read_alarm,\n\t.set_alarm\t\t= dc_rtc_set_alarm,\n\t.alarm_irq_enable\t= dc_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t dc_rtc_irq(int irq, void *dev_id)\n{\n\tstruct dc_rtc *rtc = dev_id;\n\n\twriteb_relaxed(1, rtc->regs + DC_RTC_INTFLAG_CLEAR);\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init dc_rtc_probe(struct platform_device *pdev)\n{\n\tstruct dc_rtc *rtc;\n\tint irq, ret;\n\n\trtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc->regs))\n\t\treturn PTR_ERR(rtc->regs);\n\n\trtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(&pdev->dev, irq, dc_rtc_irq, 0, pdev->name, rtc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, rtc);\n\n\trtc->rtc_dev->ops = &dc_rtc_ops;\n\trtc->rtc_dev->range_max = U32_MAX;\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\nstatic const __maybe_unused struct of_device_id dc_dt_ids[] = {\n\t{ .compatible = \"cnxt,cx92755-rtc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dc_dt_ids);\n\nstatic struct platform_driver dc_rtc_driver = {\n\t.driver = {\n\t\t.name = \"digicolor_rtc\",\n\t\t.of_match_table = of_match_ptr(dc_dt_ids),\n\t},\n};\nmodule_platform_driver_probe(dc_rtc_driver, dc_rtc_probe);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Conexant Digicolor Realtime Clock Driver (RTC)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}