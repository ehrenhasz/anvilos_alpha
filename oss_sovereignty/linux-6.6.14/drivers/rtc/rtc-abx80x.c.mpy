{
  "module_name": "rtc-abx80x.c",
  "hash_id": "c00df305393f385d957b045aaddb73071e6780af53268c0d04eadbeb8120bba9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-abx80x.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/rtc.h>\n#include <linux/watchdog.h>\n\n#define ABX8XX_REG_HTH\t\t0x00\n#define ABX8XX_REG_SC\t\t0x01\n#define ABX8XX_REG_MN\t\t0x02\n#define ABX8XX_REG_HR\t\t0x03\n#define ABX8XX_REG_DA\t\t0x04\n#define ABX8XX_REG_MO\t\t0x05\n#define ABX8XX_REG_YR\t\t0x06\n#define ABX8XX_REG_WD\t\t0x07\n\n#define ABX8XX_REG_AHTH\t\t0x08\n#define ABX8XX_REG_ASC\t\t0x09\n#define ABX8XX_REG_AMN\t\t0x0a\n#define ABX8XX_REG_AHR\t\t0x0b\n#define ABX8XX_REG_ADA\t\t0x0c\n#define ABX8XX_REG_AMO\t\t0x0d\n#define ABX8XX_REG_AWD\t\t0x0e\n\n#define ABX8XX_REG_STATUS\t0x0f\n#define ABX8XX_STATUS_AF\tBIT(2)\n#define ABX8XX_STATUS_BLF\tBIT(4)\n#define ABX8XX_STATUS_WDT\tBIT(6)\n\n#define ABX8XX_REG_CTRL1\t0x10\n#define ABX8XX_CTRL_WRITE\tBIT(0)\n#define ABX8XX_CTRL_ARST\tBIT(2)\n#define ABX8XX_CTRL_12_24\tBIT(6)\n\n#define ABX8XX_REG_CTRL2\t0x11\n#define ABX8XX_CTRL2_RSVD\tBIT(5)\n\n#define ABX8XX_REG_IRQ\t\t0x12\n#define ABX8XX_IRQ_AIE\t\tBIT(2)\n#define ABX8XX_IRQ_IM_1_4\t(0x3 << 5)\n\n#define ABX8XX_REG_CD_TIMER_CTL\t0x18\n\n#define ABX8XX_REG_OSC\t\t0x1c\n#define ABX8XX_OSC_FOS\t\tBIT(3)\n#define ABX8XX_OSC_BOS\t\tBIT(4)\n#define ABX8XX_OSC_ACAL_512\tBIT(5)\n#define ABX8XX_OSC_ACAL_1024\tBIT(6)\n\n#define ABX8XX_OSC_OSEL\t\tBIT(7)\n\n#define ABX8XX_REG_OSS\t\t0x1d\n#define ABX8XX_OSS_OF\t\tBIT(1)\n#define ABX8XX_OSS_OMODE\tBIT(4)\n\n#define ABX8XX_REG_WDT\t\t0x1b\n#define ABX8XX_WDT_WDS\t\tBIT(7)\n#define ABX8XX_WDT_BMB_MASK\t0x7c\n#define ABX8XX_WDT_BMB_SHIFT\t2\n#define ABX8XX_WDT_MAX_TIME\t(ABX8XX_WDT_BMB_MASK >> ABX8XX_WDT_BMB_SHIFT)\n#define ABX8XX_WDT_WRB_MASK\t0x03\n#define ABX8XX_WDT_WRB_1HZ\t0x02\n\n#define ABX8XX_REG_CFG_KEY\t0x1f\n#define ABX8XX_CFG_KEY_OSC\t0xa1\n#define ABX8XX_CFG_KEY_MISC\t0x9d\n\n#define ABX8XX_REG_ID0\t\t0x28\n\n#define ABX8XX_REG_OUT_CTRL\t0x30\n#define ABX8XX_OUT_CTRL_EXDS\tBIT(4)\n\n#define ABX8XX_REG_TRICKLE\t0x20\n#define ABX8XX_TRICKLE_CHARGE_ENABLE\t0xa0\n#define ABX8XX_TRICKLE_STANDARD_DIODE\t0x8\n#define ABX8XX_TRICKLE_SCHOTTKY_DIODE\t0x4\n\n#define ABX8XX_REG_EXTRAM\t0x3f\n#define ABX8XX_EXTRAM_XADS\tGENMASK(1, 0)\n\n#define ABX8XX_SRAM_BASE\t0x40\n#define ABX8XX_SRAM_WIN_SIZE\t0x40\n#define ABX8XX_RAM_SIZE\t\t256\n\n#define NVMEM_ADDR_LOWER\tGENMASK(5, 0)\n#define NVMEM_ADDR_UPPER\tGENMASK(7, 6)\n\nstatic u8 trickle_resistors[] = {0, 3, 6, 11};\n\nenum abx80x_chip {AB0801, AB0803, AB0804, AB0805,\n\tAB1801, AB1803, AB1804, AB1805, RV1805, ABX80X};\n\nstruct abx80x_cap {\n\tu16 pn;\n\tbool has_tc;\n\tbool has_wdog;\n};\n\nstatic struct abx80x_cap abx80x_caps[] = {\n\t[AB0801] = {.pn = 0x0801},\n\t[AB0803] = {.pn = 0x0803},\n\t[AB0804] = {.pn = 0x0804, .has_tc = true, .has_wdog = true},\n\t[AB0805] = {.pn = 0x0805, .has_tc = true, .has_wdog = true},\n\t[AB1801] = {.pn = 0x1801},\n\t[AB1803] = {.pn = 0x1803},\n\t[AB1804] = {.pn = 0x1804, .has_tc = true, .has_wdog = true},\n\t[AB1805] = {.pn = 0x1805, .has_tc = true, .has_wdog = true},\n\t[RV1805] = {.pn = 0x1805, .has_tc = true, .has_wdog = true},\n\t[ABX80X] = {.pn = 0}\n};\n\nstruct abx80x_priv {\n\tstruct rtc_device *rtc;\n\tstruct i2c_client *client;\n\tstruct watchdog_device wdog;\n};\n\nstatic int abx80x_write_config_key(struct i2c_client *client, u8 key)\n{\n\tif (i2c_smbus_write_byte_data(client, ABX8XX_REG_CFG_KEY, key) < 0) {\n\t\tdev_err(&client->dev, \"Unable to write configuration key\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int abx80x_is_rc_mode(struct i2c_client *client)\n{\n\tint flags = 0;\n\n\tflags =  i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\n\tif (flags < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read autocalibration attribute\\n\");\n\t\treturn flags;\n\t}\n\n\treturn (flags & ABX8XX_OSS_OMODE) ? 1 : 0;\n}\n\nstatic int abx80x_enable_trickle_charger(struct i2c_client *client,\n\t\t\t\t\t u8 trickle_cfg)\n{\n\tint err;\n\n\t \n\tif (abx80x_write_config_key(client, ABX8XX_CFG_KEY_MISC) < 0)\n\t\treturn -EIO;\n\n\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_TRICKLE,\n\t\t\t\t\tABX8XX_TRICKLE_CHARGE_ENABLE |\n\t\t\t\t\ttrickle_cfg);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write trickle register\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int abx80x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[8];\n\tint err, flags, rc_mode = 0;\n\n\t \n\trc_mode = abx80x_is_rc_mode(client);\n\tif (rc_mode < 0)\n\t\treturn rc_mode;\n\n\tif (!rc_mode) {\n\t\tflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\n\t\tif (flags < 0)\n\t\t\treturn flags;\n\n\t\tif (flags & ABX8XX_OSS_OF) {\n\t\t\tdev_err(dev, \"Oscillator failure, data is invalid.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_HTH,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to read date\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttm->tm_sec = bcd2bin(buf[ABX8XX_REG_SC] & 0x7F);\n\ttm->tm_min = bcd2bin(buf[ABX8XX_REG_MN] & 0x7F);\n\ttm->tm_hour = bcd2bin(buf[ABX8XX_REG_HR] & 0x3F);\n\ttm->tm_wday = buf[ABX8XX_REG_WD] & 0x7;\n\ttm->tm_mday = bcd2bin(buf[ABX8XX_REG_DA] & 0x3F);\n\ttm->tm_mon = bcd2bin(buf[ABX8XX_REG_MO] & 0x1F) - 1;\n\ttm->tm_year = bcd2bin(buf[ABX8XX_REG_YR]) + 100;\n\n\treturn 0;\n}\n\nstatic int abx80x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[8];\n\tint err, flags;\n\n\tif (tm->tm_year < 100)\n\t\treturn -EINVAL;\n\n\tbuf[ABX8XX_REG_HTH] = 0;\n\tbuf[ABX8XX_REG_SC] = bin2bcd(tm->tm_sec);\n\tbuf[ABX8XX_REG_MN] = bin2bcd(tm->tm_min);\n\tbuf[ABX8XX_REG_HR] = bin2bcd(tm->tm_hour);\n\tbuf[ABX8XX_REG_DA] = bin2bcd(tm->tm_mday);\n\tbuf[ABX8XX_REG_MO] = bin2bcd(tm->tm_mon + 1);\n\tbuf[ABX8XX_REG_YR] = bin2bcd(tm->tm_year - 100);\n\tbuf[ABX8XX_REG_WD] = tm->tm_wday;\n\n\terr = i2c_smbus_write_i2c_block_data(client, ABX8XX_REG_HTH,\n\t\t\t\t\t     sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write to date registers\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\n\tif (flags < 0)\n\t\treturn flags;\n\n\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSS,\n\t\t\t\t\tflags & ~ABX8XX_OSS_OF);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write oscillator status register\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t abx80x_handle_irq(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct abx80x_priv *priv = i2c_get_clientdata(client);\n\tstruct rtc_device *rtc = priv->rtc;\n\tint status;\n\n\tstatus = i2c_smbus_read_byte_data(client, ABX8XX_REG_STATUS);\n\tif (status < 0)\n\t\treturn IRQ_NONE;\n\n\tif (status & ABX8XX_STATUS_AF)\n\t\trtc_update_irq(rtc, 1, RTC_AF | RTC_IRQF);\n\n\t \n\tif (status & ABX8XX_STATUS_WDT)\n\t\tdev_alert(&client->dev, \"watchdog timeout interrupt.\\n\");\n\n\ti2c_smbus_write_byte_data(client, ABX8XX_REG_STATUS, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int abx80x_read_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned char buf[7];\n\n\tint irq_mask, err;\n\n\tif (client->irq <= 0)\n\t\treturn -EINVAL;\n\n\terr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_ASC,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err)\n\t\treturn err;\n\n\tirq_mask = i2c_smbus_read_byte_data(client, ABX8XX_REG_IRQ);\n\tif (irq_mask < 0)\n\t\treturn irq_mask;\n\n\tt->time.tm_sec = bcd2bin(buf[0] & 0x7F);\n\tt->time.tm_min = bcd2bin(buf[1] & 0x7F);\n\tt->time.tm_hour = bcd2bin(buf[2] & 0x3F);\n\tt->time.tm_mday = bcd2bin(buf[3] & 0x3F);\n\tt->time.tm_mon = bcd2bin(buf[4] & 0x1F) - 1;\n\tt->time.tm_wday = buf[5] & 0x7;\n\n\tt->enabled = !!(irq_mask & ABX8XX_IRQ_AIE);\n\tt->pending = (buf[6] & ABX8XX_STATUS_AF) && t->enabled;\n\n\treturn err;\n}\n\nstatic int abx80x_set_alarm(struct device *dev, struct rtc_wkalrm *t)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 alarm[6];\n\tint err;\n\n\tif (client->irq <= 0)\n\t\treturn -EINVAL;\n\n\talarm[0] = 0x0;\n\talarm[1] = bin2bcd(t->time.tm_sec);\n\talarm[2] = bin2bcd(t->time.tm_min);\n\talarm[3] = bin2bcd(t->time.tm_hour);\n\talarm[4] = bin2bcd(t->time.tm_mday);\n\talarm[5] = bin2bcd(t->time.tm_mon + 1);\n\n\terr = i2c_smbus_write_i2c_block_data(client, ABX8XX_REG_AHTH,\n\t\t\t\t\t     sizeof(alarm), alarm);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write alarm registers\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (t->enabled) {\n\t\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\n\t\t\t\t\t\t(ABX8XX_IRQ_IM_1_4 |\n\t\t\t\t\t\t ABX8XX_IRQ_AIE));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int abx80x_rtc_set_autocalibration(struct device *dev,\n\t\t\t\t\t  int autocalibration)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint retval, flags = 0;\n\n\tif ((autocalibration != 0) && (autocalibration != 1024) &&\n\t    (autocalibration != 512)) {\n\t\tdev_err(dev, \"autocalibration value outside permitted range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (autocalibration == 0) {\n\t\tflags &= ~(ABX8XX_OSC_ACAL_512 | ABX8XX_OSC_ACAL_1024);\n\t} else if (autocalibration == 1024) {\n\t\t \n\t\tflags |= ABX8XX_OSC_ACAL_1024;\n\t\tflags &= ~(ABX8XX_OSC_ACAL_512);\n\t} else {\n\t\t \n\t\tflags |= (ABX8XX_OSC_ACAL_1024 | ABX8XX_OSC_ACAL_512);\n\t}\n\n\t \n\tif (abx80x_write_config_key(client, ABX8XX_CFG_KEY_OSC) < 0)\n\t\treturn -EIO;\n\n\tretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSC, flags);\n\n\treturn retval;\n}\n\nstatic int abx80x_rtc_get_autocalibration(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint flags = 0, autocalibration;\n\n\tflags =  i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (flags & ABX8XX_OSC_ACAL_512)\n\t\tautocalibration = 512;\n\telse if (flags & ABX8XX_OSC_ACAL_1024)\n\t\tautocalibration = 1024;\n\telse\n\t\tautocalibration = 0;\n\n\treturn autocalibration;\n}\n\nstatic ssize_t autocalibration_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint retval;\n\tunsigned long autocalibration = 0;\n\n\tretval = kstrtoul(buf, 10, &autocalibration);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Failed to store RTC autocalibration attribute\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = abx80x_rtc_set_autocalibration(dev->parent, autocalibration);\n\n\treturn retval ? retval : count;\n}\n\nstatic ssize_t autocalibration_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint autocalibration = 0;\n\n\tautocalibration = abx80x_rtc_get_autocalibration(dev->parent);\n\tif (autocalibration < 0) {\n\t\tdev_err(dev, \"Failed to read RTC autocalibration\\n\");\n\t\tsprintf(buf, \"0\\n\");\n\t\treturn autocalibration;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", autocalibration);\n}\n\nstatic DEVICE_ATTR_RW(autocalibration);\n\nstatic ssize_t oscillator_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tint retval, flags, rc_mode = 0;\n\n\tif (strncmp(buf, \"rc\", 2) == 0) {\n\t\trc_mode = 1;\n\t} else if (strncmp(buf, \"xtal\", 4) == 0) {\n\t\trc_mode = 0;\n\t} else {\n\t\tdev_err(dev, \"Oscillator selection value outside permitted ones\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflags =  i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\n\tif (flags < 0)\n\t\treturn flags;\n\n\tif (rc_mode == 0)\n\t\tflags &= ~(ABX8XX_OSC_OSEL);\n\telse\n\t\tflags |= (ABX8XX_OSC_OSEL);\n\n\t \n\tif (abx80x_write_config_key(client, ABX8XX_CFG_KEY_OSC) < 0)\n\t\treturn -EIO;\n\n\tretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSC, flags);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Failed to write Oscillator Control register\\n\");\n\t\treturn retval;\n\t}\n\n\treturn retval ? retval : count;\n}\n\nstatic ssize_t oscillator_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint rc_mode = 0;\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\n\trc_mode = abx80x_is_rc_mode(client);\n\n\tif (rc_mode < 0) {\n\t\tdev_err(dev, \"Failed to read RTC oscillator selection\\n\");\n\t\tsprintf(buf, \"\\n\");\n\t\treturn rc_mode;\n\t}\n\n\tif (rc_mode)\n\t\treturn sprintf(buf, \"rc\\n\");\n\telse\n\t\treturn sprintf(buf, \"xtal\\n\");\n}\n\nstatic DEVICE_ATTR_RW(oscillator);\n\nstatic struct attribute *rtc_calib_attrs[] = {\n\t&dev_attr_autocalibration.attr,\n\t&dev_attr_oscillator.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtc_calib_attr_group = {\n\t.attrs\t\t= rtc_calib_attrs,\n};\n\nstatic int abx80x_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint err;\n\n\tif (enabled)\n\t\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\n\t\t\t\t\t\t(ABX8XX_IRQ_IM_1_4 |\n\t\t\t\t\t\t ABX8XX_IRQ_AIE));\n\telse\n\t\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\n\t\t\t\t\t\tABX8XX_IRQ_IM_1_4);\n\treturn err;\n}\n\nstatic int abx80x_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint status, tmp;\n\n\tswitch (cmd) {\n\tcase RTC_VL_READ:\n\t\tstatus = i2c_smbus_read_byte_data(client, ABX8XX_REG_STATUS);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\ttmp = status & ABX8XX_STATUS_BLF ? RTC_VL_BACKUP_LOW : 0;\n\n\t\treturn put_user(tmp, (unsigned int __user *)arg);\n\n\tcase RTC_VL_CLR:\n\t\tstatus = i2c_smbus_read_byte_data(client, ABX8XX_REG_STATUS);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tstatus &= ~ABX8XX_STATUS_BLF;\n\n\t\ttmp = i2c_smbus_write_byte_data(client, ABX8XX_REG_STATUS, 0);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct rtc_class_ops abx80x_rtc_ops = {\n\t.read_time\t= abx80x_rtc_read_time,\n\t.set_time\t= abx80x_rtc_set_time,\n\t.read_alarm\t= abx80x_read_alarm,\n\t.set_alarm\t= abx80x_set_alarm,\n\t.alarm_irq_enable = abx80x_alarm_irq_enable,\n\t.ioctl\t\t= abx80x_ioctl,\n};\n\nstatic int abx80x_dt_trickle_cfg(struct i2c_client *client)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tconst char *diode;\n\tint trickle_cfg = 0;\n\tint i, ret;\n\tu32 tmp;\n\n\tret = of_property_read_string(np, \"abracon,tc-diode\", &diode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!strcmp(diode, \"standard\")) {\n\t\ttrickle_cfg |= ABX8XX_TRICKLE_STANDARD_DIODE;\n\t} else if (!strcmp(diode, \"schottky\")) {\n\t\ttrickle_cfg |= ABX8XX_TRICKLE_SCHOTTKY_DIODE;\n\t} else {\n\t\tdev_dbg(&client->dev, \"Invalid tc-diode value: %s\\n\", diode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(np, \"abracon,tc-resistor\", &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < sizeof(trickle_resistors); i++)\n\t\tif (trickle_resistors[i] == tmp)\n\t\t\tbreak;\n\n\tif (i == sizeof(trickle_resistors)) {\n\t\tdev_dbg(&client->dev, \"Invalid tc-resistor value: %u\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn (trickle_cfg | i);\n}\n\n#ifdef CONFIG_WATCHDOG\n\nstatic inline u8 timeout_bits(unsigned int timeout)\n{\n\treturn ((timeout << ABX8XX_WDT_BMB_SHIFT) & ABX8XX_WDT_BMB_MASK) |\n\t\t ABX8XX_WDT_WRB_1HZ;\n}\n\nstatic int __abx80x_wdog_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t     unsigned int timeout)\n{\n\tstruct abx80x_priv *priv = watchdog_get_drvdata(wdog);\n\tu8 val = ABX8XX_WDT_WDS | timeout_bits(timeout);\n\n\t \n\treturn i2c_smbus_write_byte_data(priv->client, ABX8XX_REG_WDT, val);\n}\n\nstatic int abx80x_wdog_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t   unsigned int new_timeout)\n{\n\tint err = 0;\n\n\tif (watchdog_hw_running(wdog))\n\t\terr = __abx80x_wdog_set_timeout(wdog, new_timeout);\n\n\tif (err == 0)\n\t\twdog->timeout = new_timeout;\n\n\treturn err;\n}\n\nstatic int abx80x_wdog_ping(struct watchdog_device *wdog)\n{\n\treturn __abx80x_wdog_set_timeout(wdog, wdog->timeout);\n}\n\nstatic int abx80x_wdog_start(struct watchdog_device *wdog)\n{\n\treturn __abx80x_wdog_set_timeout(wdog, wdog->timeout);\n}\n\nstatic int abx80x_wdog_stop(struct watchdog_device *wdog)\n{\n\treturn __abx80x_wdog_set_timeout(wdog, 0);\n}\n\nstatic const struct watchdog_info abx80x_wdog_info = {\n\t.identity = \"abx80x watchdog\",\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops abx80x_wdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = abx80x_wdog_start,\n\t.stop = abx80x_wdog_stop,\n\t.ping = abx80x_wdog_ping,\n\t.set_timeout = abx80x_wdog_set_timeout,\n};\n\nstatic int abx80x_setup_watchdog(struct abx80x_priv *priv)\n{\n\tpriv->wdog.parent = &priv->client->dev;\n\tpriv->wdog.ops = &abx80x_wdog_ops;\n\tpriv->wdog.info = &abx80x_wdog_info;\n\tpriv->wdog.min_timeout = 1;\n\tpriv->wdog.max_timeout = ABX8XX_WDT_MAX_TIME;\n\tpriv->wdog.timeout = ABX8XX_WDT_MAX_TIME;\n\n\twatchdog_set_drvdata(&priv->wdog, priv);\n\n\treturn devm_watchdog_register_device(&priv->client->dev, &priv->wdog);\n}\n#else\nstatic int abx80x_setup_watchdog(struct abx80x_priv *priv)\n{\n\treturn 0;\n}\n#endif\n\nstatic int abx80x_nvmem_xfer(struct abx80x_priv *priv, unsigned int offset,\n\t\t\t     void *val, size_t bytes, bool write)\n{\n\tint ret;\n\n\twhile (bytes) {\n\t\tu8 extram, reg, len, lower, upper;\n\n\t\tlower = FIELD_GET(NVMEM_ADDR_LOWER, offset);\n\t\tupper = FIELD_GET(NVMEM_ADDR_UPPER, offset);\n\t\textram = FIELD_PREP(ABX8XX_EXTRAM_XADS, upper);\n\t\treg = ABX8XX_SRAM_BASE + lower;\n\t\tlen = min(lower + bytes, (size_t)ABX8XX_SRAM_WIN_SIZE) - lower;\n\t\tlen = min_t(u8, len, I2C_SMBUS_BLOCK_MAX);\n\n\t\tret = i2c_smbus_write_byte_data(priv->client, ABX8XX_REG_EXTRAM,\n\t\t\t\t\t\textram);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (write)\n\t\t\tret = i2c_smbus_write_i2c_block_data(priv->client, reg,\n\t\t\t\t\t\t\t     len, val);\n\t\telse\n\t\t\tret = i2c_smbus_read_i2c_block_data(priv->client, reg,\n\t\t\t\t\t\t\t    len, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toffset += len;\n\t\tval += len;\n\t\tbytes -= len;\n\t}\n\n\treturn 0;\n}\n\nstatic int abx80x_nvmem_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\treturn abx80x_nvmem_xfer(priv, offset, val, bytes, false);\n}\n\nstatic int abx80x_nvmem_write(void *priv, unsigned int offset, void *val,\n\t\t\t      size_t bytes)\n{\n\treturn abx80x_nvmem_xfer(priv, offset, val, bytes, true);\n}\n\nstatic int abx80x_setup_nvmem(struct abx80x_priv *priv)\n{\n\tstruct nvmem_config config = {\n\t\t.type = NVMEM_TYPE_BATTERY_BACKED,\n\t\t.reg_read = abx80x_nvmem_read,\n\t\t.reg_write = abx80x_nvmem_write,\n\t\t.size = ABX8XX_RAM_SIZE,\n\t\t.priv = priv,\n\t};\n\n\treturn devm_rtc_nvmem_register(priv->rtc, &config);\n}\n\nstatic const struct i2c_device_id abx80x_id[] = {\n\t{ \"abx80x\", ABX80X },\n\t{ \"ab0801\", AB0801 },\n\t{ \"ab0803\", AB0803 },\n\t{ \"ab0804\", AB0804 },\n\t{ \"ab0805\", AB0805 },\n\t{ \"ab1801\", AB1801 },\n\t{ \"ab1803\", AB1803 },\n\t{ \"ab1804\", AB1804 },\n\t{ \"ab1805\", AB1805 },\n\t{ \"rv1805\", RV1805 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, abx80x_id);\n\nstatic int abx80x_probe(struct i2c_client *client)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tstruct abx80x_priv *priv;\n\tint i, data, err, trickle_cfg = -EINVAL;\n\tchar buf[7];\n\tconst struct i2c_device_id *id = i2c_match_id(abx80x_id, client);\n\tunsigned int part = id->driver_data;\n\tunsigned int partnumber;\n\tunsigned int majrev, minrev;\n\tunsigned int lot;\n\tunsigned int wafer;\n\tunsigned int uid;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\terr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_ID0,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to read partnumber\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpartnumber = (buf[0] << 8) | buf[1];\n\tmajrev = buf[2] >> 3;\n\tminrev = buf[2] & 0x7;\n\tlot = ((buf[4] & 0x80) << 2) | ((buf[6] & 0x80) << 1) | buf[3];\n\tuid = ((buf[4] & 0x7f) << 8) | buf[5];\n\twafer = (buf[6] & 0x7c) >> 2;\n\tdev_info(&client->dev, \"model %04x, revision %u.%u, lot %x, wafer %x, uid %x\\n\",\n\t\t partnumber, majrev, minrev, lot, wafer, uid);\n\n\tdata = i2c_smbus_read_byte_data(client, ABX8XX_REG_CTRL1);\n\tif (data < 0) {\n\t\tdev_err(&client->dev, \"Unable to read control register\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CTRL1,\n\t\t\t\t\t((data & ~(ABX8XX_CTRL_12_24 |\n\t\t\t\t\t\t   ABX8XX_CTRL_ARST)) |\n\t\t\t\t\t ABX8XX_CTRL_WRITE));\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Unable to write control register\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (part == RV1805) {\n\t\t \n\t\tdata = i2c_smbus_read_byte_data(client, ABX8XX_REG_CTRL2);\n\t\tif (data < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to read control2 register\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CTRL2,\n\t\t\t\t\t\tdata & ~ABX8XX_CTRL2_RSVD);\n\t\tif (err < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to write control2 register\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tdata = i2c_smbus_read_byte_data(client, ABX8XX_REG_OUT_CTRL);\n\t\tif (data < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to read output control register\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (abx80x_write_config_key(client, ABX8XX_CFG_KEY_MISC) < 0)\n\t\t\treturn -EIO;\n\n\t\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_OUT_CTRL,\n\t\t\t\t\t\tdata | ABX8XX_OUT_CTRL_EXDS);\n\t\tif (err < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to write output control register\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tif (part == ABX80X) {\n\t\tfor (i = 0; abx80x_caps[i].pn; i++)\n\t\t\tif (partnumber == abx80x_caps[i].pn)\n\t\t\t\tbreak;\n\t\tif (abx80x_caps[i].pn == 0) {\n\t\t\tdev_err(&client->dev, \"Unknown part: %04x\\n\",\n\t\t\t\tpartnumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpart = i;\n\t}\n\n\tif (partnumber != abx80x_caps[part].pn) {\n\t\tdev_err(&client->dev, \"partnumber mismatch %04x != %04x\\n\",\n\t\t\tpartnumber, abx80x_caps[part].pn);\n\t\treturn -EINVAL;\n\t}\n\n\tif (np && abx80x_caps[part].has_tc)\n\t\ttrickle_cfg = abx80x_dt_trickle_cfg(client);\n\n\tif (trickle_cfg > 0) {\n\t\tdev_info(&client->dev, \"Enabling trickle charger: %02x\\n\",\n\t\t\t trickle_cfg);\n\t\tabx80x_enable_trickle_charger(client, trickle_cfg);\n\t}\n\n\terr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CD_TIMER_CTL,\n\t\t\t\t\tBIT(2));\n\tif (err)\n\t\treturn err;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv->rtc = devm_rtc_allocate_device(&client->dev);\n\tif (IS_ERR(priv->rtc))\n\t\treturn PTR_ERR(priv->rtc);\n\n\tpriv->rtc->ops = &abx80x_rtc_ops;\n\tpriv->client = client;\n\n\ti2c_set_clientdata(client, priv);\n\n\tif (abx80x_caps[part].has_wdog) {\n\t\terr = abx80x_setup_watchdog(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = abx80x_setup_nvmem(priv);\n\tif (err)\n\t\treturn err;\n\n\tif (client->irq > 0) {\n\t\tdev_info(&client->dev, \"IRQ %d supplied\\n\", client->irq);\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t\tabx80x_handle_irq,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\t\"abx8xx\",\n\t\t\t\t\t\tclient);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"unable to request IRQ, alarms disabled\\n\");\n\t\t\tclient->irq = 0;\n\t\t}\n\t}\n\n\terr = rtc_add_group(priv->rtc, &rtc_calib_attr_group);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to create sysfs group: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn devm_rtc_register_device(priv->rtc);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id abx80x_of_match[] = {\n\t{\n\t\t.compatible = \"abracon,abx80x\",\n\t\t.data = (void *)ABX80X\n\t},\n\t{\n\t\t.compatible = \"abracon,ab0801\",\n\t\t.data = (void *)AB0801\n\t},\n\t{\n\t\t.compatible = \"abracon,ab0803\",\n\t\t.data = (void *)AB0803\n\t},\n\t{\n\t\t.compatible = \"abracon,ab0804\",\n\t\t.data = (void *)AB0804\n\t},\n\t{\n\t\t.compatible = \"abracon,ab0805\",\n\t\t.data = (void *)AB0805\n\t},\n\t{\n\t\t.compatible = \"abracon,ab1801\",\n\t\t.data = (void *)AB1801\n\t},\n\t{\n\t\t.compatible = \"abracon,ab1803\",\n\t\t.data = (void *)AB1803\n\t},\n\t{\n\t\t.compatible = \"abracon,ab1804\",\n\t\t.data = (void *)AB1804\n\t},\n\t{\n\t\t.compatible = \"abracon,ab1805\",\n\t\t.data = (void *)AB1805\n\t},\n\t{\n\t\t.compatible = \"microcrystal,rv1805\",\n\t\t.data = (void *)RV1805\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, abx80x_of_match);\n#endif\n\nstatic struct i2c_driver abx80x_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-abx80x\",\n\t\t.of_match_table = of_match_ptr(abx80x_of_match),\n\t},\n\t.probe\t\t= abx80x_probe,\n\t.id_table\t= abx80x_id,\n};\n\nmodule_i2c_driver(abx80x_driver);\n\nMODULE_AUTHOR(\"Philippe De Muyter <phdm@macqel.be>\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_DESCRIPTION(\"Abracon ABX80X RTC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}