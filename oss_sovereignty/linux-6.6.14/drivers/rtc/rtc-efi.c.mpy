{
  "module_name": "rtc-efi.c",
  "hash_id": "657b67a0e47a5f5da32d85c451403a3fb1ab8a7c93a07097aab4a3808677a2b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-efi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/stringify.h>\n#include <linux/time.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/efi.h>\n\n#define EFI_ISDST (EFI_TIME_ADJUST_DAYLIGHT|EFI_TIME_IN_DAYLIGHT)\n\n \nstatic inline int\ncompute_yday(efi_time_t *eft)\n{\n\t \n\treturn rtc_year_days(eft->day, eft->month - 1, eft->year);\n}\n\n \nstatic int\ncompute_wday(efi_time_t *eft, int yday)\n{\n\tint ndays = eft->year * (365 % 7)\n\t\t    + (eft->year - 1) / 4\n\t\t    - (eft->year - 1) / 100\n\t\t    + (eft->year - 1) / 400\n\t\t    + yday;\n\n\t \n\treturn ndays % 7;\n}\n\nstatic void\nconvert_to_efi_time(struct rtc_time *wtime, efi_time_t *eft)\n{\n\teft->year\t= wtime->tm_year + 1900;\n\teft->month\t= wtime->tm_mon + 1;\n\teft->day\t= wtime->tm_mday;\n\teft->hour\t= wtime->tm_hour;\n\teft->minute\t= wtime->tm_min;\n\teft->second\t= wtime->tm_sec;\n\teft->nanosecond = 0;\n\teft->daylight\t= wtime->tm_isdst ? EFI_ISDST : 0;\n\teft->timezone\t= EFI_UNSPECIFIED_TIMEZONE;\n}\n\nstatic bool\nconvert_from_efi_time(efi_time_t *eft, struct rtc_time *wtime)\n{\n\tmemset(wtime, 0, sizeof(*wtime));\n\n\tif (eft->second >= 60)\n\t\treturn false;\n\twtime->tm_sec  = eft->second;\n\n\tif (eft->minute >= 60)\n\t\treturn false;\n\twtime->tm_min  = eft->minute;\n\n\tif (eft->hour >= 24)\n\t\treturn false;\n\twtime->tm_hour = eft->hour;\n\n\tif (!eft->day || eft->day > 31)\n\t\treturn false;\n\twtime->tm_mday = eft->day;\n\n\tif (!eft->month || eft->month > 12)\n\t\treturn false;\n\twtime->tm_mon  = eft->month - 1;\n\n\tif (eft->year < 1900 || eft->year > 9999)\n\t\treturn false;\n\twtime->tm_year = eft->year - 1900;\n\n\t \n\twtime->tm_yday = compute_yday(eft);\n\n\t \n\twtime->tm_wday = compute_wday(eft, wtime->tm_yday);\n\n\tswitch (eft->daylight & EFI_ISDST) {\n\tcase EFI_ISDST:\n\t\twtime->tm_isdst = 1;\n\t\tbreak;\n\tcase EFI_TIME_ADJUST_DAYLIGHT:\n\t\twtime->tm_isdst = 0;\n\t\tbreak;\n\tdefault:\n\t\twtime->tm_isdst = -1;\n\t}\n\n\treturn true;\n}\n\nstatic int efi_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tefi_time_t eft;\n\tefi_status_t status;\n\n\t \n\tstatus = efi.get_wakeup_time((efi_bool_t *)&wkalrm->enabled,\n\t\t\t\t     (efi_bool_t *)&wkalrm->pending, &eft);\n\n\tif (status != EFI_SUCCESS)\n\t\treturn -EINVAL;\n\n\tif (!convert_from_efi_time(&eft, &wkalrm->time))\n\t\treturn -EIO;\n\n\treturn rtc_valid_tm(&wkalrm->time);\n}\n\nstatic int efi_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\n{\n\tefi_time_t eft;\n\tefi_status_t status;\n\n\tconvert_to_efi_time(&wkalrm->time, &eft);\n\n\t \n\tstatus = efi.set_wakeup_time((efi_bool_t)wkalrm->enabled, &eft);\n\n\tdev_warn(dev, \"write status is %d\\n\", (int)status);\n\n\treturn status == EFI_SUCCESS ? 0 : -EINVAL;\n}\n\nstatic int efi_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tefi_status_t status;\n\tefi_time_t eft;\n\tefi_time_cap_t cap;\n\n\tstatus = efi.get_time(&eft, &cap);\n\n\tif (status != EFI_SUCCESS) {\n\t\t \n\t\tdev_err_once(dev, \"can't read time\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!convert_from_efi_time(&eft, tm))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int efi_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tefi_status_t status;\n\tefi_time_t eft;\n\n\tconvert_to_efi_time(tm, &eft);\n\n\tstatus = efi.set_time(&eft);\n\n\treturn status == EFI_SUCCESS ? 0 : -EINVAL;\n}\n\nstatic int efi_procfs(struct device *dev, struct seq_file *seq)\n{\n\tefi_time_t        eft, alm;\n\tefi_time_cap_t    cap;\n\tefi_bool_t        enabled, pending;\n\tstruct rtc_device *rtc = dev_get_drvdata(dev);\n\n\tmemset(&eft, 0, sizeof(eft));\n\tmemset(&alm, 0, sizeof(alm));\n\tmemset(&cap, 0, sizeof(cap));\n\n\tefi.get_time(&eft, &cap);\n\tefi.get_wakeup_time(&enabled, &pending, &alm);\n\n\tseq_printf(seq,\n\t\t   \"Time\\t\\t: %u:%u:%u.%09u\\n\"\n\t\t   \"Date\\t\\t: %u-%u-%u\\n\"\n\t\t   \"Daylight\\t: %u\\n\",\n\t\t   eft.hour, eft.minute, eft.second, eft.nanosecond,\n\t\t   eft.year, eft.month, eft.day,\n\t\t   eft.daylight);\n\n\tif (eft.timezone == EFI_UNSPECIFIED_TIMEZONE)\n\t\tseq_puts(seq, \"Timezone\\t: unspecified\\n\");\n\telse\n\t\t \n\t\tseq_printf(seq, \"Timezone\\t: %u\\n\", eft.timezone);\n\n\tif (test_bit(RTC_FEATURE_ALARM, rtc->features)) {\n\t\tseq_printf(seq,\n\t\t\t   \"Alarm Time\\t: %u:%u:%u.%09u\\n\"\n\t\t\t   \"Alarm Date\\t: %u-%u-%u\\n\"\n\t\t\t   \"Alarm Daylight\\t: %u\\n\"\n\t\t\t   \"Enabled\\t\\t: %s\\n\"\n\t\t\t   \"Pending\\t\\t: %s\\n\",\n\t\t\t   alm.hour, alm.minute, alm.second, alm.nanosecond,\n\t\t\t   alm.year, alm.month, alm.day,\n\t\t\t   alm.daylight,\n\t\t\t   enabled == 1 ? \"yes\" : \"no\",\n\t\t\t   pending == 1 ? \"yes\" : \"no\");\n\n\t\tif (eft.timezone == EFI_UNSPECIFIED_TIMEZONE)\n\t\t\tseq_puts(seq, \"Timezone\\t: unspecified\\n\");\n\t\telse\n\t\t\t \n\t\t\tseq_printf(seq, \"Timezone\\t: %u\\n\", alm.timezone);\n\t}\n\n\t \n\tseq_printf(seq,\n\t\t   \"Resolution\\t: %u\\n\"\n\t\t   \"Accuracy\\t: %u\\n\"\n\t\t   \"SetstoZero\\t: %u\\n\",\n\t\t   cap.resolution, cap.accuracy, cap.sets_to_zero);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops efi_rtc_ops = {\n\t.read_time\t= efi_read_time,\n\t.set_time\t= efi_set_time,\n\t.read_alarm\t= efi_read_alarm,\n\t.set_alarm\t= efi_set_alarm,\n\t.proc\t\t= efi_procfs,\n};\n\nstatic int __init efi_rtc_probe(struct platform_device *dev)\n{\n\tstruct rtc_device *rtc;\n\tefi_time_t eft;\n\tefi_time_cap_t cap;\n\n\t \n\tif (efi.get_time(&eft, &cap) != EFI_SUCCESS)\n\t\treturn -ENODEV;\n\n\trtc = devm_rtc_allocate_device(&dev->dev);\n\tif (IS_ERR(rtc))\n\t\treturn PTR_ERR(rtc);\n\n\tplatform_set_drvdata(dev, rtc);\n\n\trtc->ops = &efi_rtc_ops;\n\tclear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->features);\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_WAKEUP_SERVICES))\n\t\tset_bit(RTC_FEATURE_ALARM_WAKEUP_ONLY, rtc->features);\n\telse\n\t\tclear_bit(RTC_FEATURE_ALARM, rtc->features);\n\n\tdevice_init_wakeup(&dev->dev, true);\n\n\treturn devm_rtc_register_device(rtc);\n}\n\nstatic struct platform_driver efi_rtc_driver = {\n\t.driver = {\n\t\t.name = \"rtc-efi\",\n\t},\n};\n\nmodule_platform_driver_probe(efi_rtc_driver, efi_rtc_probe);\n\nMODULE_AUTHOR(\"dann frazier <dannf@dannf.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"EFI RTC driver\");\nMODULE_ALIAS(\"platform:rtc-efi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}