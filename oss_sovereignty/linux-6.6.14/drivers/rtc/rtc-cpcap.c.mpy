{
  "module_name": "rtc-cpcap.c",
  "hash_id": "95ef98a2e5f8dcbfbb3507f0b5ade341c74a22f522356a0b4ca1766435bf3d5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-cpcap.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n#include <linux/mfd/motorola-cpcap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define SECS_PER_DAY 86400\n#define DAY_MASK  0x7FFF\n#define TOD1_MASK 0x00FF\n#define TOD2_MASK 0x01FF\n\nstruct cpcap_time {\n\tint day;\n\tint tod1;\n\tint tod2;\n};\n\nstruct cpcap_rtc {\n\tstruct regmap *regmap;\n\tstruct rtc_device *rtc_dev;\n\tu16 vendor;\n\tint alarm_irq;\n\tbool alarm_enabled;\n\tint update_irq;\n\tbool update_enabled;\n};\n\nstatic void cpcap2rtc_time(struct rtc_time *rtc, struct cpcap_time *cpcap)\n{\n\tunsigned long int tod;\n\tunsigned long int time;\n\n\ttod = (cpcap->tod1 & TOD1_MASK) | ((cpcap->tod2 & TOD2_MASK) << 8);\n\ttime = tod + ((cpcap->day & DAY_MASK) * SECS_PER_DAY);\n\n\trtc_time64_to_tm(time, rtc);\n}\n\nstatic void rtc2cpcap_time(struct cpcap_time *cpcap, struct rtc_time *rtc)\n{\n\tunsigned long time;\n\n\ttime = rtc_tm_to_time64(rtc);\n\n\tcpcap->day = time / SECS_PER_DAY;\n\ttime %= SECS_PER_DAY;\n\tcpcap->tod2 = (time >> 8) & TOD2_MASK;\n\tcpcap->tod1 = time & TOD1_MASK;\n}\n\nstatic int cpcap_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct cpcap_rtc *rtc = dev_get_drvdata(dev);\n\n\tif (rtc->alarm_enabled == enabled)\n\t\treturn 0;\n\n\tif (enabled)\n\t\tenable_irq(rtc->alarm_irq);\n\telse\n\t\tdisable_irq(rtc->alarm_irq);\n\n\trtc->alarm_enabled = !!enabled;\n\n\treturn 0;\n}\n\nstatic int cpcap_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cpcap_rtc *rtc;\n\tstruct cpcap_time cpcap_tm;\n\tint temp_tod2;\n\tint ret;\n\n\trtc = dev_get_drvdata(dev);\n\n\tret = regmap_read(rtc->regmap, CPCAP_REG_TOD2, &temp_tod2);\n\tret |= regmap_read(rtc->regmap, CPCAP_REG_DAY, &cpcap_tm.day);\n\tret |= regmap_read(rtc->regmap, CPCAP_REG_TOD1, &cpcap_tm.tod1);\n\tret |= regmap_read(rtc->regmap, CPCAP_REG_TOD2, &cpcap_tm.tod2);\n\n\tif (temp_tod2 > cpcap_tm.tod2)\n\t\tret |= regmap_read(rtc->regmap, CPCAP_REG_DAY, &cpcap_tm.day);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tcpcap2rtc_time(tm, &cpcap_tm);\n\n\treturn 0;\n}\n\nstatic int cpcap_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct cpcap_rtc *rtc;\n\tstruct cpcap_time cpcap_tm;\n\tint ret = 0;\n\n\trtc = dev_get_drvdata(dev);\n\n\trtc2cpcap_time(&cpcap_tm, tm);\n\n\tif (rtc->alarm_enabled)\n\t\tdisable_irq(rtc->alarm_irq);\n\tif (rtc->update_enabled)\n\t\tdisable_irq(rtc->update_irq);\n\n\tif (rtc->vendor == CPCAP_VENDOR_ST) {\n\t\t \n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TOD1,\n\t\t\t\t\t  TOD1_MASK, cpcap_tm.tod1);\n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TOD2,\n\t\t\t\t\t  TOD2_MASK, cpcap_tm.tod2);\n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_DAY,\n\t\t\t\t\t  DAY_MASK, cpcap_tm.day);\n\t} else {\n\t\t \n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TOD1,\n\t\t\t\t\t  TOD1_MASK, 0);\n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_DAY,\n\t\t\t\t\t  DAY_MASK, cpcap_tm.day);\n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TOD2,\n\t\t\t\t\t  TOD2_MASK, cpcap_tm.tod2);\n\t\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TOD1,\n\t\t\t\t\t  TOD1_MASK, cpcap_tm.tod1);\n\t}\n\n\tif (rtc->update_enabled)\n\t\tenable_irq(rtc->update_irq);\n\tif (rtc->alarm_enabled)\n\t\tenable_irq(rtc->alarm_irq);\n\n\treturn ret;\n}\n\nstatic int cpcap_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct cpcap_rtc *rtc;\n\tstruct cpcap_time cpcap_tm;\n\tint ret;\n\n\trtc = dev_get_drvdata(dev);\n\n\talrm->enabled = rtc->alarm_enabled;\n\n\tret = regmap_read(rtc->regmap, CPCAP_REG_DAYA, &cpcap_tm.day);\n\tret |= regmap_read(rtc->regmap, CPCAP_REG_TODA2, &cpcap_tm.tod2);\n\tret |= regmap_read(rtc->regmap, CPCAP_REG_TODA1, &cpcap_tm.tod1);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read time\\n\");\n\t\treturn -EIO;\n\t}\n\n\tcpcap2rtc_time(&alrm->time, &cpcap_tm);\n\treturn rtc_valid_tm(&alrm->time);\n}\n\nstatic int cpcap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct cpcap_rtc *rtc;\n\tstruct cpcap_time cpcap_tm;\n\tint ret;\n\n\trtc = dev_get_drvdata(dev);\n\n\trtc2cpcap_time(&cpcap_tm, &alrm->time);\n\n\tif (rtc->alarm_enabled)\n\t\tdisable_irq(rtc->alarm_irq);\n\n\tret = regmap_update_bits(rtc->regmap, CPCAP_REG_DAYA, DAY_MASK,\n\t\t\t\t cpcap_tm.day);\n\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TODA2, TOD2_MASK,\n\t\t\t\t  cpcap_tm.tod2);\n\tret |= regmap_update_bits(rtc->regmap, CPCAP_REG_TODA1, TOD1_MASK,\n\t\t\t\t  cpcap_tm.tod1);\n\n\tif (!ret) {\n\t\tenable_irq(rtc->alarm_irq);\n\t\trtc->alarm_enabled = true;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct rtc_class_ops cpcap_rtc_ops = {\n\t.read_time\t\t= cpcap_rtc_read_time,\n\t.set_time\t\t= cpcap_rtc_set_time,\n\t.read_alarm\t\t= cpcap_rtc_read_alarm,\n\t.set_alarm\t\t= cpcap_rtc_set_alarm,\n\t.alarm_irq_enable\t= cpcap_rtc_alarm_irq_enable,\n};\n\nstatic irqreturn_t cpcap_rtc_alarm_irq(int irq, void *data)\n{\n\tstruct cpcap_rtc *rtc = data;\n\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cpcap_rtc_update_irq(int irq, void *data)\n{\n\tstruct cpcap_rtc *rtc = data;\n\n\trtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int cpcap_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cpcap_rtc *rtc;\n\tint err;\n\n\trtc = devm_kzalloc(dev, sizeof(*rtc), GFP_KERNEL);\n\tif (!rtc)\n\t\treturn -ENOMEM;\n\n\trtc->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!rtc->regmap)\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(pdev, rtc);\n\trtc->rtc_dev = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(rtc->rtc_dev))\n\t\treturn PTR_ERR(rtc->rtc_dev);\n\n\trtc->rtc_dev->ops = &cpcap_rtc_ops;\n\trtc->rtc_dev->range_max = (timeu64_t) (DAY_MASK + 1) * SECS_PER_DAY - 1;\n\n\terr = cpcap_get_vendor(dev, rtc->regmap, &rtc->vendor);\n\tif (err)\n\t\treturn err;\n\n\trtc->alarm_irq = platform_get_irq(pdev, 0);\n\terr = devm_request_threaded_irq(dev, rtc->alarm_irq, NULL,\n\t\t\t\t\tcpcap_rtc_alarm_irq,\n\t\t\t\t\tIRQF_TRIGGER_NONE | IRQF_ONESHOT,\n\t\t\t\t\t\"rtc_alarm\", rtc);\n\tif (err) {\n\t\tdev_err(dev, \"Could not request alarm irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\tdisable_irq(rtc->alarm_irq);\n\n\t \n\trtc->update_irq = platform_get_irq(pdev, 1);\n\terr = devm_request_threaded_irq(dev, rtc->update_irq, NULL,\n\t\t\t\t\tcpcap_rtc_update_irq,\n\t\t\t\t\tIRQF_TRIGGER_NONE | IRQF_ONESHOT,\n\t\t\t\t\t\"rtc_1hz\", rtc);\n\tif (err) {\n\t\tdev_err(dev, \"Could not request update irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\tdisable_irq(rtc->update_irq);\n\n\terr = device_init_wakeup(dev, 1);\n\tif (err) {\n\t\tdev_err(dev, \"wakeup initialization failed (%d)\\n\", err);\n\t\t \n\t}\n\n\treturn devm_rtc_register_device(rtc->rtc_dev);\n}\n\nstatic const struct of_device_id cpcap_rtc_of_match[] = {\n\t{ .compatible = \"motorola,cpcap-rtc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_rtc_of_match);\n\nstatic struct platform_driver cpcap_rtc_driver = {\n\t.probe\t\t= cpcap_rtc_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"cpcap-rtc\",\n\t\t.of_match_table = cpcap_rtc_of_match,\n\t},\n};\n\nmodule_platform_driver(cpcap_rtc_driver);\n\nMODULE_ALIAS(\"platform:cpcap-rtc\");\nMODULE_DESCRIPTION(\"CPCAP RTC driver\");\nMODULE_AUTHOR(\"Sebastian Reichel <sre@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}