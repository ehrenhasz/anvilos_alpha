{
  "module_name": "rtc-ti-k3.c",
  "hash_id": "16e7e32402517782a19560b519b81b0a8240d1af0ee5aec3b2f024c7bfee5074",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-ti-k3.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sys_soc.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/rtc.h>\n\n \n#define REG_K3RTC_S_CNT_LSW\t\t0x08\n#define REG_K3RTC_S_CNT_MSW\t\t0x0c\n#define REG_K3RTC_COMP\t\t\t0x10\n#define REG_K3RTC_ON_OFF_S_CNT_LSW\t0x20\n#define REG_K3RTC_ON_OFF_S_CNT_MSW\t0x24\n#define REG_K3RTC_SCRATCH0\t\t0x30\n#define REG_K3RTC_SCRATCH7\t\t0x4c\n#define REG_K3RTC_GENERAL_CTL\t\t0x50\n#define REG_K3RTC_IRQSTATUS_RAW_SYS\t0x54\n#define REG_K3RTC_IRQSTATUS_SYS\t\t0x58\n#define REG_K3RTC_IRQENABLE_SET_SYS\t0x5c\n#define REG_K3RTC_IRQENABLE_CLR_SYS\t0x60\n#define REG_K3RTC_SYNCPEND\t\t0x68\n#define REG_K3RTC_KICK0\t\t\t0x70\n#define REG_K3RTC_KICK1\t\t\t0x74\n\n \n#define K3RTC_CNT_FMODE_S_CNT_VALUE\t(0x2 << 24)\n\n \n#define K3RTC_KICK0_UNLOCK_VALUE\t0x83e70b13\n#define K3RTC_KICK1_UNLOCK_VALUE\t0x95a4f1e0\n\n \n#define K3RTC_PPB_MULT\t\t\t(1000000000LL)\n \n#define K3RTC_MIN_OFFSET\t\t(-277761)\n#define K3RTC_MAX_OFFSET\t\t(277778)\n\nstatic const struct regmap_config ti_k3_rtc_regmap_config = {\n\t.name = \"peripheral-registers\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = REG_K3RTC_KICK1,\n};\n\nenum ti_k3_rtc_fields {\n\tK3RTC_KICK0,\n\tK3RTC_KICK1,\n\tK3RTC_S_CNT_LSW,\n\tK3RTC_S_CNT_MSW,\n\tK3RTC_O32K_OSC_DEP_EN,\n\tK3RTC_UNLOCK,\n\tK3RTC_CNT_FMODE,\n\tK3RTC_PEND,\n\tK3RTC_RELOAD_FROM_BBD,\n\tK3RTC_COMP,\n\n\tK3RTC_ALM_S_CNT_LSW,\n\tK3RTC_ALM_S_CNT_MSW,\n\tK3RTC_IRQ_STATUS_RAW,\n\tK3RTC_IRQ_STATUS,\n\tK3RTC_IRQ_ENABLE_SET,\n\tK3RTC_IRQ_ENABLE_CLR,\n\n\tK3RTC_IRQ_STATUS_ALT,\n\tK3RTC_IRQ_ENABLE_CLR_ALT,\n\n\tK3_RTC_MAX_FIELDS\n};\n\nstatic const struct reg_field ti_rtc_reg_fields[] = {\n\t[K3RTC_KICK0] = REG_FIELD(REG_K3RTC_KICK0, 0, 31),\n\t[K3RTC_KICK1] = REG_FIELD(REG_K3RTC_KICK1, 0, 31),\n\t[K3RTC_S_CNT_LSW] = REG_FIELD(REG_K3RTC_S_CNT_LSW, 0, 31),\n\t[K3RTC_S_CNT_MSW] = REG_FIELD(REG_K3RTC_S_CNT_MSW, 0, 15),\n\t[K3RTC_O32K_OSC_DEP_EN] = REG_FIELD(REG_K3RTC_GENERAL_CTL, 21, 21),\n\t[K3RTC_UNLOCK] = REG_FIELD(REG_K3RTC_GENERAL_CTL, 23, 23),\n\t[K3RTC_CNT_FMODE] = REG_FIELD(REG_K3RTC_GENERAL_CTL, 24, 25),\n\t[K3RTC_PEND] = REG_FIELD(REG_K3RTC_SYNCPEND, 0, 1),\n\t[K3RTC_RELOAD_FROM_BBD] = REG_FIELD(REG_K3RTC_SYNCPEND, 31, 31),\n\t[K3RTC_COMP] = REG_FIELD(REG_K3RTC_COMP, 0, 31),\n\n\t \n\t[K3RTC_ALM_S_CNT_LSW] = REG_FIELD(REG_K3RTC_ON_OFF_S_CNT_LSW, 0, 31),\n\t[K3RTC_ALM_S_CNT_MSW] = REG_FIELD(REG_K3RTC_ON_OFF_S_CNT_MSW, 0, 15),\n\t[K3RTC_IRQ_STATUS_RAW] = REG_FIELD(REG_K3RTC_IRQSTATUS_RAW_SYS, 0, 0),\n\t[K3RTC_IRQ_STATUS] = REG_FIELD(REG_K3RTC_IRQSTATUS_SYS, 0, 0),\n\t[K3RTC_IRQ_ENABLE_SET] = REG_FIELD(REG_K3RTC_IRQENABLE_SET_SYS, 0, 0),\n\t[K3RTC_IRQ_ENABLE_CLR] = REG_FIELD(REG_K3RTC_IRQENABLE_CLR_SYS, 0, 0),\n\t \n\t[K3RTC_IRQ_STATUS_ALT] = REG_FIELD(REG_K3RTC_IRQSTATUS_SYS, 1, 1),\n\t[K3RTC_IRQ_ENABLE_CLR_ALT] = REG_FIELD(REG_K3RTC_IRQENABLE_CLR_SYS, 1, 1),\n};\n\n \nstruct ti_k3_rtc {\n\tunsigned int irq;\n\tu32 sync_timeout_us;\n\tunsigned long rate_32k;\n\tstruct rtc_device *rtc_dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *r_fields[K3_RTC_MAX_FIELDS];\n};\n\nstatic int k3rtc_field_read(struct ti_k3_rtc *priv, enum ti_k3_rtc_fields f)\n{\n\tint ret;\n\tint val;\n\n\tret = regmap_field_read(priv->r_fields[f], &val);\n\t \n\tif (WARN_ON_ONCE(ret))\n\t\treturn ret;\n\treturn val;\n}\n\nstatic void k3rtc_field_write(struct ti_k3_rtc *priv, enum ti_k3_rtc_fields f, u32 val)\n{\n\tregmap_field_write(priv->r_fields[f], val);\n}\n\n \nstatic int k3rtc_fence(struct ti_k3_rtc *priv)\n{\n\tint ret;\n\n\tret = regmap_field_read_poll_timeout(priv->r_fields[K3RTC_PEND], ret,\n\t\t\t\t\t     !ret, 2, priv->sync_timeout_us);\n\n\treturn ret;\n}\n\nstatic inline int k3rtc_check_unlocked(struct ti_k3_rtc *priv)\n{\n\tint ret;\n\n\tret = k3rtc_field_read(priv, K3RTC_UNLOCK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret) ? 0 : 1;\n}\n\nstatic int k3rtc_unlock_rtc(struct ti_k3_rtc *priv)\n{\n\tint ret;\n\n\tret = k3rtc_check_unlocked(priv);\n\tif (!ret)\n\t\treturn ret;\n\n\tk3rtc_field_write(priv, K3RTC_KICK0, K3RTC_KICK0_UNLOCK_VALUE);\n\tk3rtc_field_write(priv, K3RTC_KICK1, K3RTC_KICK1_UNLOCK_VALUE);\n\n\t \n\tret = regmap_field_read_poll_timeout(priv->r_fields[K3RTC_UNLOCK], ret,\n\t\t\t\t\t     ret, 2, priv->sync_timeout_us);\n\n\treturn ret;\n}\n\n \nstatic const struct soc_device_attribute has_erratum_i2327[] = {\n\t{ .family = \"AM62X\", .revision = \"SR1.0\" },\n\t{   }\n};\n\nstatic int k3rtc_configure(struct device *dev)\n{\n\tint ret;\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\n\t \n\tif (soc_device_match(has_erratum_i2327)) {\n\t\tret = k3rtc_check_unlocked(priv);\n\t\t \n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\tHW_ERR \"Erratum i2327 unlock QUIRK! Cannot operate!!\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\t \n\t\tret = k3rtc_unlock_rtc(priv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to unlock(%d)!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tk3rtc_field_write(priv, K3RTC_O32K_OSC_DEP_EN, 0x1);\n\n\t \n\tusleep_range(priv->sync_timeout_us, priv->sync_timeout_us + 5);\n\n\t \n\tret = k3rtc_fence(priv);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed fence osc_dep enable(%d) - is 32k clk working?!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tk3rtc_field_write(priv, K3RTC_CNT_FMODE, K3RTC_CNT_FMODE_S_CNT_VALUE);\n\n\t \n\tk3rtc_field_write(priv, K3RTC_IRQ_STATUS_ALT, 0x1);\n\tk3rtc_field_write(priv, K3RTC_IRQ_STATUS, 0x1);\n\t \n\tk3rtc_field_write(priv, K3RTC_IRQ_ENABLE_CLR_ALT, 0x1);\n\tk3rtc_field_write(priv, K3RTC_IRQ_ENABLE_CLR, 0x1);\n\n\t \n\treturn k3rtc_fence(priv);\n}\n\nstatic int ti_k3_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 seconds_lo, seconds_hi;\n\n\tseconds_lo = k3rtc_field_read(priv, K3RTC_S_CNT_LSW);\n\tseconds_hi = k3rtc_field_read(priv, K3RTC_S_CNT_MSW);\n\n\trtc_time64_to_tm((((time64_t)seconds_hi) << 32) | (time64_t)seconds_lo, tm);\n\n\treturn 0;\n}\n\nstatic int ti_k3_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\ttime64_t seconds;\n\n\tseconds = rtc_tm_to_time64(tm);\n\n\t \n\tregmap_write(priv->regmap, REG_K3RTC_S_CNT_LSW, seconds);\n\tregmap_write(priv->regmap, REG_K3RTC_S_CNT_MSW, seconds >> 32);\n\n\treturn k3rtc_fence(priv);\n}\n\nstatic int ti_k3_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 reg;\n\tu32 offset = enabled ? K3RTC_IRQ_ENABLE_SET : K3RTC_IRQ_ENABLE_CLR;\n\n\treg = k3rtc_field_read(priv, K3RTC_IRQ_ENABLE_SET);\n\tif ((enabled && reg) || (!enabled && !reg))\n\t\treturn 0;\n\n\tk3rtc_field_write(priv, offset, 0x1);\n\n\t \n\treturn k3rtc_fence(priv);\n}\n\nstatic int ti_k3_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 seconds_lo, seconds_hi;\n\n\tseconds_lo = k3rtc_field_read(priv, K3RTC_ALM_S_CNT_LSW);\n\tseconds_hi = k3rtc_field_read(priv, K3RTC_ALM_S_CNT_MSW);\n\n\trtc_time64_to_tm((((time64_t)seconds_hi) << 32) | (time64_t)seconds_lo, &alarm->time);\n\n\talarm->enabled = k3rtc_field_read(priv, K3RTC_IRQ_ENABLE_SET);\n\n\treturn 0;\n}\n\nstatic int ti_k3_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\ttime64_t seconds;\n\tint ret;\n\n\tseconds = rtc_tm_to_time64(&alarm->time);\n\n\tk3rtc_field_write(priv, K3RTC_ALM_S_CNT_LSW, seconds);\n\tk3rtc_field_write(priv, K3RTC_ALM_S_CNT_MSW, (seconds >> 32));\n\n\t \n\tret = k3rtc_fence(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to fence(%d)! Potential config issue?\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn ti_k3_rtc_alarm_irq_enable(dev, alarm->enabled);\n}\n\nstatic int ti_k3_rtc_read_offset(struct device *dev, long *offset)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 ticks_per_hr = priv->rate_32k * 3600;\n\tint comp;\n\ts64 tmp;\n\n\tcomp = k3rtc_field_read(priv, K3RTC_COMP);\n\n\t \n\ttmp = comp * (s64)K3RTC_PPB_MULT;\n\tif (tmp < 0)\n\t\ttmp -= ticks_per_hr / 2LL;\n\telse\n\t\ttmp += ticks_per_hr / 2LL;\n\ttmp = div_s64(tmp, ticks_per_hr);\n\n\t \n\t*offset = (long)-tmp;\n\n\treturn 0;\n}\n\nstatic int ti_k3_rtc_set_offset(struct device *dev, long offset)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 ticks_per_hr = priv->rate_32k * 3600;\n\tint comp;\n\ts64 tmp;\n\n\t \n\tif (offset < K3RTC_MIN_OFFSET || offset > K3RTC_MAX_OFFSET)\n\t\treturn -ERANGE;\n\n\t \n\ttmp = offset * (s64)ticks_per_hr;\n\tif (tmp < 0)\n\t\ttmp -= K3RTC_PPB_MULT / 2LL;\n\telse\n\t\ttmp += K3RTC_PPB_MULT / 2LL;\n\ttmp = div_s64(tmp, K3RTC_PPB_MULT);\n\n\t \n\tcomp = (int)-tmp;\n\n\tk3rtc_field_write(priv, K3RTC_COMP, comp);\n\n\treturn k3rtc_fence(priv);\n}\n\nstatic irqreturn_t ti_k3_rtc_interrupt(s32 irq, void *dev_id)\n{\n\tstruct device *dev = dev_id;\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\tu32 reg;\n\tint ret;\n\n\t \n\tusleep_range(priv->sync_timeout_us, priv->sync_timeout_us + 2);\n\n\t \n\treg = k3rtc_field_read(priv, K3RTC_IRQ_STATUS);\n\n\tif (!reg) {\n\t\tu32 raw = k3rtc_field_read(priv, K3RTC_IRQ_STATUS_RAW);\n\n\t\tdev_err(dev,\n\t\t\tHW_ERR\n\t\t\t\"Erratum i2327/IRQ trig: status: 0x%08x / 0x%08x\\n\", reg, raw);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tregmap_write(priv->regmap, REG_K3RTC_IRQSTATUS_SYS, 0x1);\n\n\t \n\tret = k3rtc_fence(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to fence irq status clr(%d)!\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tk3rtc_field_write(priv, K3RTC_RELOAD_FROM_BBD, 0x1);\n\n\t \n\tret = k3rtc_fence(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to fence reload from bbd(%d)!\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tret = regmap_field_read_poll_timeout(priv->r_fields[K3RTC_IRQ_STATUS],\n\t\t\t\t\t     ret, !ret, 2, priv->sync_timeout_us);\n\tif (ret) {\n\t\tdev_err(dev, \"Time out waiting for status clear\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\trtc_update_irq(priv->rtc_dev, 1, RTC_IRQF | RTC_AF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct rtc_class_ops ti_k3_rtc_ops = {\n\t.read_time = ti_k3_rtc_read_time,\n\t.set_time = ti_k3_rtc_set_time,\n\t.read_alarm = ti_k3_rtc_read_alarm,\n\t.set_alarm = ti_k3_rtc_set_alarm,\n\t.read_offset = ti_k3_rtc_read_offset,\n\t.set_offset = ti_k3_rtc_set_offset,\n\t.alarm_irq_enable = ti_k3_rtc_alarm_irq_enable,\n};\n\nstatic int ti_k3_rtc_scratch_read(void *priv_data, unsigned int offset,\n\t\t\t\t  void *val, size_t bytes)\n{\n\tstruct ti_k3_rtc *priv = (struct ti_k3_rtc *)priv_data;\n\n\treturn regmap_bulk_read(priv->regmap, REG_K3RTC_SCRATCH0 + offset, val, bytes / 4);\n}\n\nstatic int ti_k3_rtc_scratch_write(void *priv_data, unsigned int offset,\n\t\t\t\t   void *val, size_t bytes)\n{\n\tstruct ti_k3_rtc *priv = (struct ti_k3_rtc *)priv_data;\n\tint ret;\n\n\tret = regmap_bulk_write(priv->regmap, REG_K3RTC_SCRATCH0 + offset, val, bytes / 4);\n\tif (ret)\n\t\treturn ret;\n\n\treturn k3rtc_fence(priv);\n}\n\nstatic struct nvmem_config ti_k3_rtc_nvmem_config = {\n\t.name = \"ti_k3_rtc_scratch\",\n\t.word_size = 4,\n\t.stride = 4,\n\t.size = REG_K3RTC_SCRATCH7 - REG_K3RTC_SCRATCH0 + 4,\n\t.reg_read = ti_k3_rtc_scratch_read,\n\t.reg_write = ti_k3_rtc_scratch_write,\n};\n\nstatic int k3rtc_get_32kclk(struct device *dev, struct ti_k3_rtc *priv)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get_enabled(dev, \"osc32k\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tpriv->rate_32k = clk_get_rate(clk);\n\n\t \n\tif (priv->rate_32k != 32768)\n\t\tdev_warn(dev, \"Clock rate %ld is not 32768! Could misbehave!\\n\",\n\t\t\t priv->rate_32k);\n\n\t \n\tpriv->sync_timeout_us = (u32)(DIV_ROUND_UP_ULL(1000000, priv->rate_32k) * 4);\n\n\treturn 0;\n}\n\nstatic int k3rtc_get_vbusclk(struct device *dev, struct ti_k3_rtc *priv)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = devm_clk_get_enabled(dev, \"vbus\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\treturn 0;\n}\n\nstatic int ti_k3_rtc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ti_k3_rtc *priv;\n\tvoid __iomem *rtc_base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct ti_k3_rtc), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\trtc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rtc_base))\n\t\treturn PTR_ERR(rtc_base);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, rtc_base, &ti_k3_rtc_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tret = devm_regmap_field_bulk_alloc(dev, priv->regmap, priv->r_fields,\n\t\t\t\t\t   ti_rtc_reg_fields, K3_RTC_MAX_FIELDS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = k3rtc_get_32kclk(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\tret = k3rtc_get_vbusclk(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tpriv->irq = (unsigned int)ret;\n\n\tpriv->rtc_dev = devm_rtc_allocate_device(dev);\n\tif (IS_ERR(priv->rtc_dev))\n\t\treturn PTR_ERR(priv->rtc_dev);\n\n\tpriv->rtc_dev->ops = &ti_k3_rtc_ops;\n\tpriv->rtc_dev->range_max = (1ULL << 48) - 1;\t \n\tti_k3_rtc_nvmem_config.priv = priv;\n\n\tret = devm_request_threaded_irq(dev, priv->irq, NULL,\n\t\t\t\t\tti_k3_rtc_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not request IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = k3rtc_configure(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_present(dev, \"wakeup-source\"))\n\t\tdevice_init_wakeup(dev, true);\n\telse\n\t\tdevice_set_wakeup_capable(dev, true);\n\n\tret = devm_rtc_register_device(priv->rtc_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_rtc_nvmem_register(priv->rtc_dev, &ti_k3_rtc_nvmem_config);\n}\n\nstatic const struct of_device_id ti_k3_rtc_of_match_table[] = {\n\t{.compatible = \"ti,am62-rtc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ti_k3_rtc_of_match_table);\n\nstatic int __maybe_unused ti_k3_rtc_suspend(struct device *dev)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn enable_irq_wake(priv->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ti_k3_rtc_resume(struct device *dev)\n{\n\tstruct ti_k3_rtc *priv = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(priv->irq);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ti_k3_rtc_pm_ops, ti_k3_rtc_suspend, ti_k3_rtc_resume);\n\nstatic struct platform_driver ti_k3_rtc_driver = {\n\t.probe = ti_k3_rtc_probe,\n\t.driver = {\n\t\t   .name = \"rtc-ti-k3\",\n\t\t   .of_match_table = ti_k3_rtc_of_match_table,\n\t\t   .pm = &ti_k3_rtc_pm_ops,\n\t},\n};\nmodule_platform_driver(ti_k3_rtc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TI K3 RTC driver\");\nMODULE_AUTHOR(\"Nishanth Menon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}