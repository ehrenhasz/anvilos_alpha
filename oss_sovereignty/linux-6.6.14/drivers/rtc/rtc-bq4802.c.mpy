{
  "module_name": "rtc-bq4802.c",
  "hash_id": "51d6cd64c903474f7a1282a78e5852c9ddff5eeadd8b3453a63656f4458d4025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-bq4802.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_DESCRIPTION(\"TI BQ4802 RTC driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct bq4802 {\n\tvoid __iomem\t\t*regs;\n\tunsigned long\t\tioport;\n\tstruct rtc_device\t*rtc;\n\tspinlock_t\t\tlock;\n\tstruct resource\t\t*r;\n\tu8 (*read)(struct bq4802 *, int);\n\tvoid (*write)(struct bq4802 *, int, u8);\n};\n\nstatic u8 bq4802_read_io(struct bq4802 *p, int off)\n{\n\treturn inb(p->ioport + off);\n}\n\nstatic void bq4802_write_io(struct bq4802 *p, int off, u8 val)\n{\n\toutb(val, p->ioport + off);\n}\n\nstatic u8 bq4802_read_mem(struct bq4802 *p, int off)\n{\n\treturn readb(p->regs + off);\n}\n\nstatic void bq4802_write_mem(struct bq4802 *p, int off, u8 val)\n{\n\twriteb(val, p->regs + off);\n}\n\nstatic int bq4802_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bq4802 *p = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned int century;\n\tu8 val;\n\n\tspin_lock_irqsave(&p->lock, flags);\n\n\tval = p->read(p, 0x0e);\n\tp->write(p, 0xe, val | 0x08);\n\n\ttm->tm_sec = p->read(p, 0x00);\n\ttm->tm_min = p->read(p, 0x02);\n\ttm->tm_hour = p->read(p, 0x04);\n\ttm->tm_mday = p->read(p, 0x06);\n\ttm->tm_mon = p->read(p, 0x09);\n\ttm->tm_year = p->read(p, 0x0a);\n\ttm->tm_wday = p->read(p, 0x08);\n\tcentury = p->read(p, 0x0f);\n\n\tp->write(p, 0x0e, val);\n\n\tspin_unlock_irqrestore(&p->lock, flags);\n\n\ttm->tm_sec = bcd2bin(tm->tm_sec);\n\ttm->tm_min = bcd2bin(tm->tm_min);\n\ttm->tm_hour = bcd2bin(tm->tm_hour);\n\ttm->tm_mday = bcd2bin(tm->tm_mday);\n\ttm->tm_mon = bcd2bin(tm->tm_mon);\n\ttm->tm_year = bcd2bin(tm->tm_year);\n\ttm->tm_wday = bcd2bin(tm->tm_wday);\n\tcentury = bcd2bin(century);\n\n\ttm->tm_year += (century * 100);\n\ttm->tm_year -= 1900;\n\n\ttm->tm_mon--;\n\n\treturn 0;\n}\n\nstatic int bq4802_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct bq4802 *p = dev_get_drvdata(dev);\n\tu8 sec, min, hrs, day, mon, yrs, century, val;\n\tunsigned long flags;\n\tunsigned int year;\n\n\tyear = tm->tm_year + 1900;\n\tcentury = year / 100;\n\tyrs = year % 100;\n\n\tmon = tm->tm_mon + 1;    \n\tday = tm->tm_mday;\n\thrs = tm->tm_hour;\n\tmin = tm->tm_min;\n\tsec = tm->tm_sec;\n\n\tsec = bin2bcd(sec);\n\tmin = bin2bcd(min);\n\thrs = bin2bcd(hrs);\n\tday = bin2bcd(day);\n\tmon = bin2bcd(mon);\n\tyrs = bin2bcd(yrs);\n\tcentury = bin2bcd(century);\n\n\tspin_lock_irqsave(&p->lock, flags);\n\n\tval = p->read(p, 0x0e);\n\tp->write(p, 0x0e, val | 0x08);\n\n\tp->write(p, 0x00, sec);\n\tp->write(p, 0x02, min);\n\tp->write(p, 0x04, hrs);\n\tp->write(p, 0x06, day);\n\tp->write(p, 0x09, mon);\n\tp->write(p, 0x0a, yrs);\n\tp->write(p, 0x0f, century);\n\n\tp->write(p, 0x0e, val);\n\n\tspin_unlock_irqrestore(&p->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops bq4802_ops = {\n\t.read_time\t= bq4802_read_time,\n\t.set_time\t= bq4802_set_time,\n};\n\nstatic int bq4802_probe(struct platform_device *pdev)\n{\n\tstruct bq4802 *p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tint err = -ENOMEM;\n\n\tif (!p)\n\t\tgoto out;\n\n\tspin_lock_init(&p->lock);\n\n\tp->r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!p->r) {\n\t\tp->r = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\t\terr = -EINVAL;\n\t\tif (!p->r)\n\t\t\tgoto out;\n\t}\n\tif (p->r->flags & IORESOURCE_IO) {\n\t\tp->ioport = p->r->start;\n\t\tp->read = bq4802_read_io;\n\t\tp->write = bq4802_write_io;\n\t} else if (p->r->flags & IORESOURCE_MEM) {\n\t\tp->regs = devm_ioremap(&pdev->dev, p->r->start,\n\t\t\t\t\tresource_size(p->r));\n\t\tif (!p->regs){\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tp->read = bq4802_read_mem;\n\t\tp->write = bq4802_write_mem;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tplatform_set_drvdata(pdev, p);\n\n\tp->rtc = devm_rtc_device_register(&pdev->dev, \"bq4802\",\n\t\t\t\t\t&bq4802_ops, THIS_MODULE);\n\tif (IS_ERR(p->rtc)) {\n\t\terr = PTR_ERR(p->rtc);\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n\n}\n\n \nMODULE_ALIAS(\"platform:rtc-bq4802\");\n\nstatic struct platform_driver bq4802_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rtc-bq4802\",\n\t},\n\t.probe\t\t= bq4802_probe,\n};\n\nmodule_platform_driver(bq4802_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}