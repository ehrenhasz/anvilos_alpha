{
  "module_name": "rtc-88pm860x.c",
  "hash_id": "5949631a83e269daa313426cb3208d92b45cedfca96551d9533b44173c86ed3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rtc/rtc-88pm860x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/rtc.h>\n#include <linux/delay.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/88pm860x.h>\n\n#define VRTC_CALIBRATION\n\nstruct pm860x_rtc_info {\n\tstruct pm860x_chip\t*chip;\n\tstruct i2c_client\t*i2c;\n\tstruct rtc_device\t*rtc_dev;\n\tstruct device\t\t*dev;\n\tstruct delayed_work\tcalib_work;\n\n\tint\t\t\tirq;\n\tint\t\t\tvrtc;\n};\n\n#define REG_VRTC_MEAS1\t\t0x7D\n\n#define REG0_ADDR\t\t0xB0\n#define REG1_ADDR\t\t0xB2\n#define REG2_ADDR\t\t0xB4\n#define REG3_ADDR\t\t0xB6\n\n#define REG0_DATA\t\t0xB1\n#define REG1_DATA\t\t0xB3\n#define REG2_DATA\t\t0xB5\n#define REG3_DATA\t\t0xB7\n\n \n#define MEAS2_VRTC\t\t(1 << 0)\n\n \n#define ALARM_EN\t\t(1 << 3)\n#define ALARM_WAKEUP\t\t(1 << 4)\n#define ALARM\t\t\t(1 << 5)\n#define RTC1_USE_XO\t\t(1 << 7)\n\n#define VRTC_CALIB_INTERVAL\t(HZ * 60 * 10)\t\t \n\nstatic irqreturn_t rtc_update_handler(int irq, void *data)\n{\n\tstruct pm860x_rtc_info *info = (struct pm860x_rtc_info *)data;\n\tint mask;\n\n\tmask = ALARM | ALARM_WAKEUP;\n\tpm860x_set_bits(info->i2c, PM8607_RTC1, mask | ALARM_EN, mask);\n\trtc_update_irq(info->rtc_dev, 1, RTC_AF);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm860x_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\n\n\tif (enabled)\n\t\tpm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, ALARM_EN);\n\telse\n\t\tpm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, 0);\n\treturn 0;\n}\n\nstatic int pm860x_rtc_read_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[8];\n\tunsigned long ticks, base, data;\n\n\tpm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\n\tdev_dbg(info->dev, \"%x-%x-%x-%x-%x-%x-%x-%x\\n\", buf[0], buf[1],\n\t\tbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\n\tbase = ((unsigned long)buf[1] << 24) | (buf[3] << 16) |\n\t\t(buf[5] << 8) | buf[7];\n\n\t \n\tpm860x_bulk_read(info->i2c, PM8607_RTC_COUNTER1, 4, buf);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tticks = base + data;\n\tdev_dbg(info->dev, \"get base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\n\trtc_time64_to_tm(ticks, tm);\n\n\treturn 0;\n}\n\nstatic int pm860x_rtc_set_time(struct device *dev, struct rtc_time *tm)\n{\n\tstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[4];\n\tunsigned long ticks, base, data;\n\n\tticks = rtc_tm_to_time64(tm);\n\n\t \n\tpm860x_bulk_read(info->i2c, PM8607_RTC_COUNTER1, 4, buf);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tbase = ticks - data;\n\tdev_dbg(info->dev, \"set base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\n\tpm860x_page_reg_write(info->i2c, REG0_DATA, (base >> 24) & 0xFF);\n\tpm860x_page_reg_write(info->i2c, REG1_DATA, (base >> 16) & 0xFF);\n\tpm860x_page_reg_write(info->i2c, REG2_DATA, (base >> 8) & 0xFF);\n\tpm860x_page_reg_write(info->i2c, REG3_DATA, base & 0xFF);\n\n\treturn 0;\n}\n\nstatic int pm860x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned char buf[8];\n\tunsigned long ticks, base, data;\n\tint ret;\n\n\tpm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\n\tdev_dbg(info->dev, \"%x-%x-%x-%x-%x-%x-%x-%x\\n\", buf[0], buf[1],\n\t\tbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\n\tbase = ((unsigned long)buf[1] << 24) | (buf[3] << 16) |\n\t\t(buf[5] << 8) | buf[7];\n\n\tpm860x_bulk_read(info->i2c, PM8607_RTC_EXPIRE1, 4, buf);\n\tdata = ((unsigned long)buf[3] << 24) | (buf[2] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\tticks = base + data;\n\tdev_dbg(info->dev, \"get base:0x%lx, RO count:0x%lx, ticks:0x%lx\\n\",\n\t\tbase, data, ticks);\n\n\trtc_time64_to_tm(ticks, &alrm->time);\n\tret = pm860x_reg_read(info->i2c, PM8607_RTC1);\n\talrm->enabled = (ret & ALARM_EN) ? 1 : 0;\n\talrm->pending = (ret & (ALARM | ALARM_WAKEUP)) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int pm860x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\n{\n\tstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\n\tunsigned long ticks, base, data;\n\tunsigned char buf[8];\n\tint mask;\n\n\tpm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, 0);\n\n\tpm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\n\tdev_dbg(info->dev, \"%x-%x-%x-%x-%x-%x-%x-%x\\n\", buf[0], buf[1],\n\t\tbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\n\tbase = ((unsigned long)buf[1] << 24) | (buf[3] << 16) |\n\t\t(buf[5] << 8) | buf[7];\n\n\tticks = rtc_tm_to_time64(&alrm->time);\n\tdata = ticks - base;\n\n\tbuf[0] = data & 0xff;\n\tbuf[1] = (data >> 8) & 0xff;\n\tbuf[2] = (data >> 16) & 0xff;\n\tbuf[3] = (data >> 24) & 0xff;\n\tpm860x_bulk_write(info->i2c, PM8607_RTC_EXPIRE1, 4, buf);\n\tif (alrm->enabled) {\n\t\tmask = ALARM | ALARM_WAKEUP | ALARM_EN;\n\t\tpm860x_set_bits(info->i2c, PM8607_RTC1, mask, mask);\n\t} else {\n\t\tmask = ALARM | ALARM_WAKEUP | ALARM_EN;\n\t\tpm860x_set_bits(info->i2c, PM8607_RTC1, mask,\n\t\t\t\tALARM | ALARM_WAKEUP);\n\t}\n\treturn 0;\n}\n\nstatic const struct rtc_class_ops pm860x_rtc_ops = {\n\t.read_time\t= pm860x_rtc_read_time,\n\t.set_time\t= pm860x_rtc_set_time,\n\t.read_alarm\t= pm860x_rtc_read_alarm,\n\t.set_alarm\t= pm860x_rtc_set_alarm,\n\t.alarm_irq_enable = pm860x_rtc_alarm_irq_enable,\n};\n\n#ifdef VRTC_CALIBRATION\nstatic void calibrate_vrtc_work(struct work_struct *work)\n{\n\tstruct pm860x_rtc_info *info = container_of(work,\n\t\tstruct pm860x_rtc_info, calib_work.work);\n\tunsigned char buf[2];\n\tunsigned int sum, data, mean, vrtc_set;\n\tint i;\n\n\tfor (i = 0, sum = 0; i < 16; i++) {\n\t\tmsleep(100);\n\t\tpm860x_bulk_read(info->i2c, REG_VRTC_MEAS1, 2, buf);\n\t\tdata = (buf[0] << 4) | buf[1];\n\t\tdata = (data * 5400) >> 12;\t \n\t\tsum += data;\n\t}\n\tmean = sum >> 4;\n\tvrtc_set = 2700 + (info->vrtc & 0x3) * 200;\n\tdev_dbg(info->dev, \"mean:%d, vrtc_set:%d\\n\", mean, vrtc_set);\n\n\tsum = pm860x_reg_read(info->i2c, PM8607_RTC_MISC1);\n\tdata = sum & 0x3;\n\tif ((mean + 200) < vrtc_set) {\n\t\t \n\t\tif (++data == 4)\n\t\t\tgoto out;\n\t\tdata = (sum & 0xf8) | (data & 0x3);\n\t\tpm860x_reg_write(info->i2c, PM8607_RTC_MISC1, data);\n\t} else if ((mean - 200) > vrtc_set) {\n\t\t \n\t\tif (data-- == 0)\n\t\t\tgoto out;\n\t\tdata = (sum & 0xf8) | (data & 0x3);\n\t\tpm860x_reg_write(info->i2c, PM8607_RTC_MISC1, data);\n\t} else\n\t\tgoto out;\n\tdev_dbg(info->dev, \"set 0x%x to RTC_MISC1\\n\", data);\n\t \n\tschedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);\n\treturn;\nout:\n\t \n\tpm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, 0);\n\tdev_dbg(info->dev, \"finish VRTC calibration\\n\");\n\treturn;\n}\n#endif\n\n#ifdef CONFIG_OF\nstatic int pm860x_rtc_dt_init(struct platform_device *pdev,\n\t\t\t      struct pm860x_rtc_info *info)\n{\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tint ret;\n\tif (!np)\n\t\treturn -ENODEV;\n\tnp = of_get_child_by_name(np, \"rtc\");\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"failed to find rtc node\\n\");\n\t\treturn -ENODEV;\n\t}\n\tret = of_property_read_u32(np, \"marvell,88pm860x-vrtc\", &info->vrtc);\n\tif (ret)\n\t\tinfo->vrtc = 0;\n\tof_node_put(np);\n\treturn 0;\n}\n#else\n#define pm860x_rtc_dt_init(x, y)\tdo { } while (0)\n#endif\n\nstatic int pm860x_rtc_probe(struct platform_device *pdev)\n{\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm860x_rtc_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_rtc_info),\n\t\t\t    GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->irq = platform_get_irq(pdev, 0);\n\tif (info->irq < 0)\n\t\treturn info->irq;\n\n\tinfo->chip = chip;\n\tinfo->i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\n\tinfo->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, info);\n\n\tinfo->rtc_dev = devm_rtc_allocate_device(&pdev->dev);\n\tif (IS_ERR(info->rtc_dev))\n\t\treturn PTR_ERR(info->rtc_dev);\n\n\tret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\n\t\t\t\t\trtc_update_handler, IRQF_ONESHOT, \"rtc\",\n\t\t\t\t\tinfo);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm860x_page_reg_write(info->i2c, REG0_ADDR, REG0_DATA);\n\tpm860x_page_reg_write(info->i2c, REG1_ADDR, REG1_DATA);\n\tpm860x_page_reg_write(info->i2c, REG2_ADDR, REG2_DATA);\n\tpm860x_page_reg_write(info->i2c, REG3_ADDR, REG3_DATA);\n\n\tpm860x_rtc_dt_init(pdev, info);\n\n\tinfo->rtc_dev->ops = &pm860x_rtc_ops;\n\tinfo->rtc_dev->range_max = U32_MAX;\n\n\tret = devm_rtc_register_device(info->rtc_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpm860x_set_bits(info->i2c, PM8607_RTC1, RTC1_USE_XO, RTC1_USE_XO);\n\n#ifdef VRTC_CALIBRATION\n\t \n\tpm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, MEAS2_VRTC);\n\n\t \n\tINIT_DELAYED_WORK(&info->calib_work, calibrate_vrtc_work);\n\tschedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);\n#endif\t \n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic void pm860x_rtc_remove(struct platform_device *pdev)\n{\n\tstruct pm860x_rtc_info *info = platform_get_drvdata(pdev);\n\n#ifdef VRTC_CALIBRATION\n\tcancel_delayed_work_sync(&info->calib_work);\n\t \n\tpm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, 0);\n#endif\t \n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pm860x_rtc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag |= 1 << PM8607_IRQ_RTC;\n\treturn 0;\n}\nstatic int pm860x_rtc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag &= ~(1 << PM8607_IRQ_RTC);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pm860x_rtc_pm_ops, pm860x_rtc_suspend, pm860x_rtc_resume);\n\nstatic struct platform_driver pm860x_rtc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"88pm860x-rtc\",\n\t\t.pm\t= &pm860x_rtc_pm_ops,\n\t},\n\t.probe\t\t= pm860x_rtc_probe,\n\t.remove_new\t= pm860x_rtc_remove,\n};\n\nmodule_platform_driver(pm860x_rtc_driver);\n\nMODULE_DESCRIPTION(\"Marvell 88PM860x RTC driver\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}