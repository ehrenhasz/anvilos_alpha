{
  "module_name": "bq25980_charger.c",
  "hash_id": "b64d9e4821351f3f4b5e9f6846a6ff7a55d38cde5ffca690d9759175e2ab3c65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq25980_charger.c",
  "human_readable_source": "\n\n\n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n\n#include \"bq25980_charger.h\"\n\nstruct bq25980_state {\n\tbool dischg;\n\tbool ovp;\n\tbool ocp;\n\tbool wdt;\n\tbool tflt;\n\tbool online;\n\tbool ce;\n\tbool hiz;\n\tbool bypass;\n\n\tu32 vbat_adc;\n\tu32 vsys_adc;\n\tu32 ibat_adc;\n};\n\nenum bq25980_id {\n\tBQ25980,\n\tBQ25975,\n\tBQ25960,\n};\n\nstruct bq25980_chip_info {\n\n\tint model_id;\n\n\tconst struct regmap_config *regmap_config;\n\n\tint busocp_def;\n\tint busocp_sc_max;\n\tint busocp_byp_max;\n\tint busocp_sc_min;\n\tint busocp_byp_min;\n\n\tint busovp_sc_def;\n\tint busovp_byp_def;\n\tint busovp_sc_step;\n\n\tint busovp_sc_offset;\n\tint busovp_byp_step;\n\tint busovp_byp_offset;\n\tint busovp_sc_min;\n\tint busovp_sc_max;\n\tint busovp_byp_min;\n\tint busovp_byp_max;\n\n\tint batovp_def;\n\tint batovp_max;\n\tint batovp_min;\n\tint batovp_step;\n\tint batovp_offset;\n\n\tint batocp_def;\n\tint batocp_max;\n};\n\nstruct bq25980_init_data {\n\tu32 ichg;\n\tu32 bypass_ilim;\n\tu32 sc_ilim;\n\tu32 vreg;\n\tu32 iterm;\n\tu32 iprechg;\n\tu32 bypass_vlim;\n\tu32 sc_vlim;\n\tu32 ichg_max;\n\tu32 vreg_max;\n};\n\nstruct bq25980_device {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct power_supply *charger;\n\tstruct power_supply *battery;\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\n\tchar model_name[I2C_NAME_SIZE];\n\n\tstruct bq25980_init_data init_data;\n\tconst struct bq25980_chip_info *chip_info;\n\tstruct bq25980_state state;\n\tint watchdog_timer;\n};\n\nstatic struct reg_default bq25980_reg_defs[] = {\n\t{BQ25980_BATOVP, 0x5A},\n\t{BQ25980_BATOVP_ALM, 0x46},\n\t{BQ25980_BATOCP, 0x51},\n\t{BQ25980_BATOCP_ALM, 0x50},\n\t{BQ25980_BATUCP_ALM, 0x28},\n\t{BQ25980_CHRGR_CTRL_1, 0x0},\n\t{BQ25980_BUSOVP, 0x26},\n\t{BQ25980_BUSOVP_ALM, 0x22},\n\t{BQ25980_BUSOCP, 0xD},\n\t{BQ25980_BUSOCP_ALM, 0xC},\n\t{BQ25980_TEMP_CONTROL, 0x30},\n\t{BQ25980_TDIE_ALM, 0xC8},\n\t{BQ25980_TSBUS_FLT, 0x15},\n\t{BQ25980_TSBAT_FLG, 0x15},\n\t{BQ25980_VAC_CONTROL, 0x0},\n\t{BQ25980_CHRGR_CTRL_2, 0x0},\n\t{BQ25980_CHRGR_CTRL_3, 0x20},\n\t{BQ25980_CHRGR_CTRL_4, 0x1D},\n\t{BQ25980_CHRGR_CTRL_5, 0x18},\n\t{BQ25980_STAT1, 0x0},\n\t{BQ25980_STAT2, 0x0},\n\t{BQ25980_STAT3, 0x0},\n\t{BQ25980_STAT4, 0x0},\n\t{BQ25980_STAT5, 0x0},\n\t{BQ25980_FLAG1, 0x0},\n\t{BQ25980_FLAG2, 0x0},\n\t{BQ25980_FLAG3, 0x0},\n\t{BQ25980_FLAG4, 0x0},\n\t{BQ25980_FLAG5, 0x0},\n\t{BQ25980_MASK1, 0x0},\n\t{BQ25980_MASK2, 0x0},\n\t{BQ25980_MASK3, 0x0},\n\t{BQ25980_MASK4, 0x0},\n\t{BQ25980_MASK5, 0x0},\n\t{BQ25980_DEVICE_INFO, 0x8},\n\t{BQ25980_ADC_CONTROL1, 0x0},\n\t{BQ25980_ADC_CONTROL2, 0x0},\n\t{BQ25980_IBUS_ADC_LSB, 0x0},\n\t{BQ25980_IBUS_ADC_MSB, 0x0},\n\t{BQ25980_VBUS_ADC_LSB, 0x0},\n\t{BQ25980_VBUS_ADC_MSB, 0x0},\n\t{BQ25980_VAC1_ADC_LSB, 0x0},\n\t{BQ25980_VAC2_ADC_LSB, 0x0},\n\t{BQ25980_VOUT_ADC_LSB, 0x0},\n\t{BQ25980_VBAT_ADC_LSB, 0x0},\n\t{BQ25980_IBAT_ADC_MSB, 0x0},\n\t{BQ25980_IBAT_ADC_LSB, 0x0},\n\t{BQ25980_TSBUS_ADC_LSB, 0x0},\n\t{BQ25980_TSBAT_ADC_LSB, 0x0},\n\t{BQ25980_TDIE_ADC_LSB, 0x0},\n\t{BQ25980_DEGLITCH_TIME, 0x0},\n\t{BQ25980_CHRGR_CTRL_6, 0x0},\n};\n\nstatic struct reg_default bq25975_reg_defs[] = {\n\t{BQ25980_BATOVP, 0x5A},\n\t{BQ25980_BATOVP_ALM, 0x46},\n\t{BQ25980_BATOCP, 0x51},\n\t{BQ25980_BATOCP_ALM, 0x50},\n\t{BQ25980_BATUCP_ALM, 0x28},\n\t{BQ25980_CHRGR_CTRL_1, 0x0},\n\t{BQ25980_BUSOVP, 0x26},\n\t{BQ25980_BUSOVP_ALM, 0x22},\n\t{BQ25980_BUSOCP, 0xD},\n\t{BQ25980_BUSOCP_ALM, 0xC},\n\t{BQ25980_TEMP_CONTROL, 0x30},\n\t{BQ25980_TDIE_ALM, 0xC8},\n\t{BQ25980_TSBUS_FLT, 0x15},\n\t{BQ25980_TSBAT_FLG, 0x15},\n\t{BQ25980_VAC_CONTROL, 0x0},\n\t{BQ25980_CHRGR_CTRL_2, 0x0},\n\t{BQ25980_CHRGR_CTRL_3, 0x20},\n\t{BQ25980_CHRGR_CTRL_4, 0x1D},\n\t{BQ25980_CHRGR_CTRL_5, 0x18},\n\t{BQ25980_STAT1, 0x0},\n\t{BQ25980_STAT2, 0x0},\n\t{BQ25980_STAT3, 0x0},\n\t{BQ25980_STAT4, 0x0},\n\t{BQ25980_STAT5, 0x0},\n\t{BQ25980_FLAG1, 0x0},\n\t{BQ25980_FLAG2, 0x0},\n\t{BQ25980_FLAG3, 0x0},\n\t{BQ25980_FLAG4, 0x0},\n\t{BQ25980_FLAG5, 0x0},\n\t{BQ25980_MASK1, 0x0},\n\t{BQ25980_MASK2, 0x0},\n\t{BQ25980_MASK3, 0x0},\n\t{BQ25980_MASK4, 0x0},\n\t{BQ25980_MASK5, 0x0},\n\t{BQ25980_DEVICE_INFO, 0x8},\n\t{BQ25980_ADC_CONTROL1, 0x0},\n\t{BQ25980_ADC_CONTROL2, 0x0},\n\t{BQ25980_IBUS_ADC_LSB, 0x0},\n\t{BQ25980_IBUS_ADC_MSB, 0x0},\n\t{BQ25980_VBUS_ADC_LSB, 0x0},\n\t{BQ25980_VBUS_ADC_MSB, 0x0},\n\t{BQ25980_VAC1_ADC_LSB, 0x0},\n\t{BQ25980_VAC2_ADC_LSB, 0x0},\n\t{BQ25980_VOUT_ADC_LSB, 0x0},\n\t{BQ25980_VBAT_ADC_LSB, 0x0},\n\t{BQ25980_IBAT_ADC_MSB, 0x0},\n\t{BQ25980_IBAT_ADC_LSB, 0x0},\n\t{BQ25980_TSBUS_ADC_LSB, 0x0},\n\t{BQ25980_TSBAT_ADC_LSB, 0x0},\n\t{BQ25980_TDIE_ADC_LSB, 0x0},\n\t{BQ25980_DEGLITCH_TIME, 0x0},\n\t{BQ25980_CHRGR_CTRL_6, 0x0},\n};\n\nstatic struct reg_default bq25960_reg_defs[] = {\n\t{BQ25980_BATOVP, 0x5A},\n\t{BQ25980_BATOVP_ALM, 0x46},\n\t{BQ25980_BATOCP, 0x51},\n\t{BQ25980_BATOCP_ALM, 0x50},\n\t{BQ25980_BATUCP_ALM, 0x28},\n\t{BQ25980_CHRGR_CTRL_1, 0x0},\n\t{BQ25980_BUSOVP, 0x26},\n\t{BQ25980_BUSOVP_ALM, 0x22},\n\t{BQ25980_BUSOCP, 0xD},\n\t{BQ25980_BUSOCP_ALM, 0xC},\n\t{BQ25980_TEMP_CONTROL, 0x30},\n\t{BQ25980_TDIE_ALM, 0xC8},\n\t{BQ25980_TSBUS_FLT, 0x15},\n\t{BQ25980_TSBAT_FLG, 0x15},\n\t{BQ25980_VAC_CONTROL, 0x0},\n\t{BQ25980_CHRGR_CTRL_2, 0x0},\n\t{BQ25980_CHRGR_CTRL_3, 0x20},\n\t{BQ25980_CHRGR_CTRL_4, 0x1D},\n\t{BQ25980_CHRGR_CTRL_5, 0x18},\n\t{BQ25980_STAT1, 0x0},\n\t{BQ25980_STAT2, 0x0},\n\t{BQ25980_STAT3, 0x0},\n\t{BQ25980_STAT4, 0x0},\n\t{BQ25980_STAT5, 0x0},\n\t{BQ25980_FLAG1, 0x0},\n\t{BQ25980_FLAG2, 0x0},\n\t{BQ25980_FLAG3, 0x0},\n\t{BQ25980_FLAG4, 0x0},\n\t{BQ25980_FLAG5, 0x0},\n\t{BQ25980_MASK1, 0x0},\n\t{BQ25980_MASK2, 0x0},\n\t{BQ25980_MASK3, 0x0},\n\t{BQ25980_MASK4, 0x0},\n\t{BQ25980_MASK5, 0x0},\n\t{BQ25980_DEVICE_INFO, 0x8},\n\t{BQ25980_ADC_CONTROL1, 0x0},\n\t{BQ25980_ADC_CONTROL2, 0x0},\n\t{BQ25980_IBUS_ADC_LSB, 0x0},\n\t{BQ25980_IBUS_ADC_MSB, 0x0},\n\t{BQ25980_VBUS_ADC_LSB, 0x0},\n\t{BQ25980_VBUS_ADC_MSB, 0x0},\n\t{BQ25980_VAC1_ADC_LSB, 0x0},\n\t{BQ25980_VAC2_ADC_LSB, 0x0},\n\t{BQ25980_VOUT_ADC_LSB, 0x0},\n\t{BQ25980_VBAT_ADC_LSB, 0x0},\n\t{BQ25980_IBAT_ADC_MSB, 0x0},\n\t{BQ25980_IBAT_ADC_LSB, 0x0},\n\t{BQ25980_TSBUS_ADC_LSB, 0x0},\n\t{BQ25980_TSBAT_ADC_LSB, 0x0},\n\t{BQ25980_TDIE_ADC_LSB, 0x0},\n\t{BQ25980_DEGLITCH_TIME, 0x0},\n\t{BQ25980_CHRGR_CTRL_6, 0x0},\n};\n\nstatic int bq25980_watchdog_time[BQ25980_NUM_WD_VAL] = {5000, 10000, 50000,\n\t\t\t\t\t\t\t300000};\n\nstatic int bq25980_get_input_curr_lim(struct bq25980_device *bq)\n{\n\tunsigned int busocp_reg_code;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_BUSOCP, &busocp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (busocp_reg_code * BQ25980_BUSOCP_STEP_uA) + BQ25980_BUSOCP_OFFSET_uA;\n}\n\nstatic int bq25980_set_hiz(struct bq25980_device *bq, int setting)\n{\n\treturn regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\tBQ25980_EN_HIZ, setting);\n}\n\nstatic int bq25980_set_input_curr_lim(struct bq25980_device *bq, int busocp)\n{\n\tunsigned int busocp_reg_code;\n\tint ret;\n\n\tif (!busocp)\n\t\treturn bq25980_set_hiz(bq, BQ25980_ENABLE_HIZ);\n\n\tbq25980_set_hiz(bq, BQ25980_DISABLE_HIZ);\n\n\tif (busocp < BQ25980_BUSOCP_MIN_uA)\n\t\tbusocp = BQ25980_BUSOCP_MIN_uA;\n\n\tif (bq->state.bypass)\n\t\tbusocp = min(busocp, bq->chip_info->busocp_sc_max);\n\telse\n\t\tbusocp = min(busocp, bq->chip_info->busocp_byp_max);\n\n\tbusocp_reg_code = (busocp - BQ25980_BUSOCP_OFFSET_uA)\n\t\t\t\t\t\t/ BQ25980_BUSOCP_STEP_uA;\n\n\tret = regmap_write(bq->regmap, BQ25980_BUSOCP, busocp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(bq->regmap, BQ25980_BUSOCP_ALM, busocp_reg_code);\n}\n\nstatic int bq25980_get_input_volt_lim(struct bq25980_device *bq)\n{\n\tunsigned int busovp_reg_code;\n\tunsigned int busovp_offset;\n\tunsigned int busovp_step;\n\tint ret;\n\n\tif (bq->state.bypass) {\n\t\tbusovp_step = bq->chip_info->busovp_byp_step;\n\t\tbusovp_offset = bq->chip_info->busovp_byp_offset;\n\t} else {\n\t\tbusovp_step = bq->chip_info->busovp_sc_step;\n\t\tbusovp_offset = bq->chip_info->busovp_sc_offset;\n\t}\n\n\tret = regmap_read(bq->regmap, BQ25980_BUSOVP, &busovp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (busovp_reg_code * busovp_step) + busovp_offset;\n}\n\nstatic int bq25980_set_input_volt_lim(struct bq25980_device *bq, int busovp)\n{\n\tunsigned int busovp_reg_code;\n\tunsigned int busovp_step;\n\tunsigned int busovp_offset;\n\tint ret;\n\n\tif (bq->state.bypass) {\n\t\tbusovp_step = bq->chip_info->busovp_byp_step;\n\t\tbusovp_offset = bq->chip_info->busovp_byp_offset;\n\t\tif (busovp > bq->chip_info->busovp_byp_max)\n\t\t\tbusovp = bq->chip_info->busovp_byp_max;\n\t\telse if (busovp < bq->chip_info->busovp_byp_min)\n\t\t\tbusovp = bq->chip_info->busovp_byp_min;\n\t} else {\n\t\tbusovp_step = bq->chip_info->busovp_sc_step;\n\t\tbusovp_offset = bq->chip_info->busovp_sc_offset;\n\t\tif (busovp > bq->chip_info->busovp_sc_max)\n\t\t\tbusovp = bq->chip_info->busovp_sc_max;\n\t\telse if (busovp < bq->chip_info->busovp_sc_min)\n\t\t\tbusovp = bq->chip_info->busovp_sc_min;\n\t}\n\n\tbusovp_reg_code = (busovp - busovp_offset) / busovp_step;\n\n\tret = regmap_write(bq->regmap, BQ25980_BUSOVP, busovp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(bq->regmap, BQ25980_BUSOVP_ALM, busovp_reg_code);\n}\n\nstatic int bq25980_get_const_charge_curr(struct bq25980_device *bq)\n{\n\tunsigned int batocp_reg_code;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_BATOCP, &batocp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (batocp_reg_code & BQ25980_BATOCP_MASK) *\n\t\t\t\t\t\tBQ25980_BATOCP_STEP_uA;\n}\n\nstatic int bq25980_set_const_charge_curr(struct bq25980_device *bq, int batocp)\n{\n\tunsigned int batocp_reg_code;\n\tint ret;\n\n\tbatocp = max(batocp, BQ25980_BATOCP_MIN_uA);\n\tbatocp = min(batocp, bq->chip_info->batocp_max);\n\n\tbatocp_reg_code = batocp / BQ25980_BATOCP_STEP_uA;\n\n\tret = regmap_update_bits(bq->regmap, BQ25980_BATOCP,\n\t\t\t\tBQ25980_BATOCP_MASK, batocp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(bq->regmap, BQ25980_BATOCP_ALM,\n\t\t\t\tBQ25980_BATOCP_MASK, batocp_reg_code);\n}\n\nstatic int bq25980_get_const_charge_volt(struct bq25980_device *bq)\n{\n\tunsigned int batovp_reg_code;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_BATOVP, &batovp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ((batovp_reg_code * bq->chip_info->batovp_step) +\n\t\t\tbq->chip_info->batovp_offset);\n}\n\nstatic int bq25980_set_const_charge_volt(struct bq25980_device *bq, int batovp)\n{\n\tunsigned int batovp_reg_code;\n\tint ret;\n\n\tif (batovp < bq->chip_info->batovp_min)\n\t\tbatovp = bq->chip_info->batovp_min;\n\n\tif (batovp > bq->chip_info->batovp_max)\n\t\tbatovp = bq->chip_info->batovp_max;\n\n\tbatovp_reg_code = (batovp - bq->chip_info->batovp_offset) /\n\t\t\t\t\t\tbq->chip_info->batovp_step;\n\n\tret = regmap_write(bq->regmap, BQ25980_BATOVP, batovp_reg_code);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(bq->regmap, BQ25980_BATOVP_ALM, batovp_reg_code);\n}\n\nstatic int bq25980_set_bypass(struct bq25980_device *bq, bool en_bypass)\n{\n\tint ret;\n\n\tif (en_bypass)\n\t\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\t\t\tBQ25980_EN_BYPASS, BQ25980_EN_BYPASS);\n\telse\n\t\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\t\t\tBQ25980_EN_BYPASS, en_bypass);\n\tif (ret)\n\t\treturn ret;\n\n\tbq->state.bypass = en_bypass;\n\n\treturn bq->state.bypass;\n}\n\nstatic int bq25980_set_chg_en(struct bq25980_device *bq, bool en_chg)\n{\n\tint ret;\n\n\tif (en_chg)\n\t\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\t\t\tBQ25980_CHG_EN, BQ25980_CHG_EN);\n\telse\n\t\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\t\t\tBQ25980_CHG_EN, en_chg);\n\tif (ret)\n\t\treturn ret;\n\n\tbq->state.ce = en_chg;\n\n\treturn 0;\n}\n\nstatic int bq25980_get_adc_ibus(struct bq25980_device *bq)\n{\n\tint ibus_adc_lsb, ibus_adc_msb;\n\tu16 ibus_adc;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_IBUS_ADC_MSB, &ibus_adc_msb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_IBUS_ADC_LSB, &ibus_adc_lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tibus_adc = (ibus_adc_msb << 8) | ibus_adc_lsb;\n\n\tif (ibus_adc_msb & BQ25980_ADC_POLARITY_BIT)\n\t\treturn ((ibus_adc ^ 0xffff) + 1) * BQ25980_ADC_CURR_STEP_uA;\n\n\treturn ibus_adc * BQ25980_ADC_CURR_STEP_uA;\n}\n\nstatic int bq25980_get_adc_vbus(struct bq25980_device *bq)\n{\n\tint vbus_adc_lsb, vbus_adc_msb;\n\tu16 vbus_adc;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_VBUS_ADC_MSB, &vbus_adc_msb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_VBUS_ADC_LSB, &vbus_adc_lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tvbus_adc = (vbus_adc_msb << 8) | vbus_adc_lsb;\n\n\treturn vbus_adc * BQ25980_ADC_VOLT_STEP_uV;\n}\n\nstatic int bq25980_get_ibat_adc(struct bq25980_device *bq)\n{\n\tint ret;\n\tint ibat_adc_lsb, ibat_adc_msb;\n\tint ibat_adc;\n\n\tret = regmap_read(bq->regmap, BQ25980_IBAT_ADC_MSB, &ibat_adc_msb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_IBAT_ADC_LSB, &ibat_adc_lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tibat_adc = (ibat_adc_msb << 8) | ibat_adc_lsb;\n\n\tif (ibat_adc_msb & BQ25980_ADC_POLARITY_BIT)\n\t\treturn ((ibat_adc ^ 0xffff) + 1) * BQ25980_ADC_CURR_STEP_uA;\n\n\treturn ibat_adc * BQ25980_ADC_CURR_STEP_uA;\n}\n\nstatic int bq25980_get_adc_vbat(struct bq25980_device *bq)\n{\n\tint vsys_adc_lsb, vsys_adc_msb;\n\tu16 vsys_adc;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_VBAT_ADC_MSB, &vsys_adc_msb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_VBAT_ADC_LSB, &vsys_adc_lsb);\n\tif (ret)\n\t\treturn ret;\n\n\tvsys_adc = (vsys_adc_msb << 8) | vsys_adc_lsb;\n\n\treturn vsys_adc * BQ25980_ADC_VOLT_STEP_uV;\n}\n\nstatic int bq25980_get_state(struct bq25980_device *bq,\n\t\t\t\tstruct bq25980_state *state)\n{\n\tunsigned int chg_ctrl_2;\n\tunsigned int stat1;\n\tunsigned int stat2;\n\tunsigned int stat3;\n\tunsigned int stat4;\n\tunsigned int ibat_adc_msb;\n\tint ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_STAT1, &stat1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_STAT2, &stat2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_STAT3, &stat3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_STAT4, &stat4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_CHRGR_CTRL_2, &chg_ctrl_2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(bq->regmap, BQ25980_IBAT_ADC_MSB, &ibat_adc_msb);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->dischg = ibat_adc_msb & BQ25980_ADC_POLARITY_BIT;\n\tstate->ovp = (stat1 & BQ25980_STAT1_OVP_MASK) |\n\t\t(stat3 & BQ25980_STAT3_OVP_MASK);\n\tstate->ocp = (stat1 & BQ25980_STAT1_OCP_MASK) |\n\t\t(stat2 & BQ25980_STAT2_OCP_MASK);\n\tstate->tflt = stat4 & BQ25980_STAT4_TFLT_MASK;\n\tstate->wdt = stat4 & BQ25980_WD_STAT;\n\tstate->online = stat3 & BQ25980_PRESENT_MASK;\n\tstate->ce = chg_ctrl_2 & BQ25980_CHG_EN;\n\tstate->hiz = chg_ctrl_2 & BQ25980_EN_HIZ;\n\tstate->bypass = chg_ctrl_2 & BQ25980_EN_BYPASS;\n\n\treturn 0;\n}\n\nstatic int bq25980_get_battery_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct bq25980_device *bq = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = bq->init_data.ichg_max;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = bq->init_data.vreg_max;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = bq25980_get_ibat_adc(bq);\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = bq25980_get_adc_vbat(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int bq25980_set_charger_property(struct power_supply *psy,\n\t\tenum power_supply_property prop,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct bq25980_device *bq = power_supply_get_drvdata(psy);\n\tint ret = -EINVAL;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq25980_set_input_curr_lim(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = bq25980_set_input_volt_lim(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = bq25980_set_bypass(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq25980_set_chg_en(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq25980_set_const_charge_curr(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq25980_set_const_charge_volt(bq, val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int bq25980_get_charger_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct bq25980_device *bq = power_supply_get_drvdata(psy);\n\tstruct bq25980_state state;\n\tint ret = 0;\n\n\tmutex_lock(&bq->lock);\n\tret = bq25980_get_state(bq, &state);\n\tmutex_unlock(&bq->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BQ25980_MANUFACTURER;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bq->model_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = state.online;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = bq25980_get_input_volt_lim(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq25980_get_input_curr_lim(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\n\t\tif (state.tflt)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (state.ovp)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\telse if (state.ocp)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERCURRENT;\n\t\telse if (state.wdt)\n\t\t\tval->intval =\n\t\t\t\tPOWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\t\tif ((state.ce) && (!state.hiz))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (state.dischg)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (!state.ce)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\n\t\tif (!state.ce)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\telse if (state.bypass)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_BYPASS;\n\t\telse if (!state.bypass)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = bq25980_get_adc_ibus(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = bq25980_get_adc_vbus(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq25980_get_const_charge_curr(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq25980_get_const_charge_volt(bq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic bool bq25980_state_changed(struct bq25980_device *bq,\n\t\t\t\t  struct bq25980_state *new_state)\n{\n\tstruct bq25980_state old_state;\n\n\tmutex_lock(&bq->lock);\n\told_state = bq->state;\n\tmutex_unlock(&bq->lock);\n\n\treturn (old_state.dischg != new_state->dischg ||\n\t\told_state.ovp != new_state->ovp ||\n\t\told_state.ocp != new_state->ocp ||\n\t\told_state.online != new_state->online ||\n\t\told_state.wdt != new_state->wdt ||\n\t\told_state.tflt != new_state->tflt ||\n\t\told_state.ce != new_state->ce ||\n\t\told_state.hiz != new_state->hiz ||\n\t\told_state.bypass != new_state->bypass);\n}\n\nstatic irqreturn_t bq25980_irq_handler_thread(int irq, void *private)\n{\n\tstruct bq25980_device *bq = private;\n\tstruct bq25980_state state;\n\tint ret;\n\n\tret = bq25980_get_state(bq, &state);\n\tif (ret < 0)\n\t\tgoto irq_out;\n\n\tif (!bq25980_state_changed(bq, &state))\n\t\tgoto irq_out;\n\n\tmutex_lock(&bq->lock);\n\tbq->state = state;\n\tmutex_unlock(&bq->lock);\n\n\tpower_supply_changed(bq->charger);\n\nirq_out:\n\treturn IRQ_HANDLED;\n}\n\nstatic enum power_supply_property bq25980_power_supply_props[] = {\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\nstatic enum power_supply_property bq25980_battery_props[] = {\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\nstatic char *bq25980_charger_supplied_to[] = {\n\t\"main-battery\",\n};\n\nstatic int bq25980_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property prop)\n{\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct power_supply_desc bq25980_power_supply_desc = {\n\t.name = \"bq25980-charger\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = bq25980_power_supply_props,\n\t.num_properties = ARRAY_SIZE(bq25980_power_supply_props),\n\t.get_property = bq25980_get_charger_property,\n\t.set_property = bq25980_set_charger_property,\n\t.property_is_writeable = bq25980_property_is_writeable,\n};\n\nstatic struct power_supply_desc bq25980_battery_desc = {\n\t.name\t\t\t= \"bq25980-battery\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t\t= bq25980_get_battery_property,\n\t.properties\t\t= bq25980_battery_props,\n\t.num_properties\t\t= ARRAY_SIZE(bq25980_battery_props),\n\t.property_is_writeable\t= bq25980_property_is_writeable,\n};\n\n\nstatic bool bq25980_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BQ25980_CHRGR_CTRL_2:\n\tcase BQ25980_STAT1...BQ25980_FLAG5:\n\tcase BQ25980_ADC_CONTROL1...BQ25980_TDIE_ADC_LSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config bq25980_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = BQ25980_CHRGR_CTRL_6,\n\t.reg_defaults\t= bq25980_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(bq25980_reg_defs),\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = bq25980_is_volatile_reg,\n};\n\nstatic const struct regmap_config bq25975_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = BQ25980_CHRGR_CTRL_6,\n\t.reg_defaults\t= bq25975_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(bq25975_reg_defs),\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = bq25980_is_volatile_reg,\n};\n\nstatic const struct regmap_config bq25960_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = BQ25980_CHRGR_CTRL_6,\n\t.reg_defaults\t= bq25960_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(bq25960_reg_defs),\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = bq25980_is_volatile_reg,\n};\n\nstatic const struct bq25980_chip_info bq25980_chip_info_tbl[] = {\n\t[BQ25980] = {\n\t\t.model_id = BQ25980,\n\t\t.regmap_config = &bq25980_regmap_config,\n\n\t\t.busocp_def = BQ25980_BUSOCP_DFLT_uA,\n\t\t.busocp_sc_min = BQ25960_BUSOCP_SC_MAX_uA,\n\t\t.busocp_sc_max = BQ25980_BUSOCP_SC_MAX_uA,\n\t\t.busocp_byp_max = BQ25980_BUSOCP_BYP_MAX_uA,\n\t\t.busocp_byp_min = BQ25980_BUSOCP_MIN_uA,\n\n\t\t.busovp_sc_def = BQ25980_BUSOVP_DFLT_uV,\n\t\t.busovp_byp_def = BQ25980_BUSOVP_BYPASS_DFLT_uV,\n\t\t.busovp_sc_step = BQ25980_BUSOVP_SC_STEP_uV,\n\t\t.busovp_sc_offset = BQ25980_BUSOVP_SC_OFFSET_uV,\n\t\t.busovp_byp_step = BQ25980_BUSOVP_BYP_STEP_uV,\n\t\t.busovp_byp_offset = BQ25980_BUSOVP_BYP_OFFSET_uV,\n\t\t.busovp_sc_min = BQ25980_BUSOVP_SC_MIN_uV,\n\t\t.busovp_sc_max = BQ25980_BUSOVP_SC_MAX_uV,\n\t\t.busovp_byp_min = BQ25980_BUSOVP_BYP_MIN_uV,\n\t\t.busovp_byp_max = BQ25980_BUSOVP_BYP_MAX_uV,\n\n\t\t.batovp_def = BQ25980_BATOVP_DFLT_uV,\n\t\t.batovp_max = BQ25980_BATOVP_MAX_uV,\n\t\t.batovp_min = BQ25980_BATOVP_MIN_uV,\n\t\t.batovp_step = BQ25980_BATOVP_STEP_uV,\n\t\t.batovp_offset = BQ25980_BATOVP_OFFSET_uV,\n\n\t\t.batocp_def = BQ25980_BATOCP_DFLT_uA,\n\t\t.batocp_max = BQ25980_BATOCP_MAX_uA,\n\t},\n\n\t[BQ25975] = {\n\t\t.model_id = BQ25975,\n\t\t.regmap_config = &bq25975_regmap_config,\n\n\t\t.busocp_def = BQ25975_BUSOCP_DFLT_uA,\n\t\t.busocp_sc_min = BQ25975_BUSOCP_SC_MAX_uA,\n\t\t.busocp_sc_max = BQ25975_BUSOCP_SC_MAX_uA,\n\t\t.busocp_byp_min = BQ25980_BUSOCP_MIN_uA,\n\t\t.busocp_byp_max = BQ25975_BUSOCP_BYP_MAX_uA,\n\n\t\t.busovp_sc_def = BQ25975_BUSOVP_DFLT_uV,\n\t\t.busovp_byp_def = BQ25975_BUSOVP_BYPASS_DFLT_uV,\n\t\t.busovp_sc_step = BQ25975_BUSOVP_SC_STEP_uV,\n\t\t.busovp_sc_offset = BQ25975_BUSOVP_SC_OFFSET_uV,\n\t\t.busovp_byp_step = BQ25975_BUSOVP_BYP_STEP_uV,\n\t\t.busovp_byp_offset = BQ25975_BUSOVP_BYP_OFFSET_uV,\n\t\t.busovp_sc_min = BQ25975_BUSOVP_SC_MIN_uV,\n\t\t.busovp_sc_max = BQ25975_BUSOVP_SC_MAX_uV,\n\t\t.busovp_byp_min = BQ25975_BUSOVP_BYP_MIN_uV,\n\t\t.busovp_byp_max = BQ25975_BUSOVP_BYP_MAX_uV,\n\n\t\t.batovp_def = BQ25975_BATOVP_DFLT_uV,\n\t\t.batovp_max = BQ25975_BATOVP_MAX_uV,\n\t\t.batovp_min = BQ25975_BATOVP_MIN_uV,\n\t\t.batovp_step = BQ25975_BATOVP_STEP_uV,\n\t\t.batovp_offset = BQ25975_BATOVP_OFFSET_uV,\n\n\t\t.batocp_def = BQ25980_BATOCP_DFLT_uA,\n\t\t.batocp_max = BQ25980_BATOCP_MAX_uA,\n\t},\n\n\t[BQ25960] = {\n\t\t.model_id = BQ25960,\n\t\t.regmap_config = &bq25960_regmap_config,\n\n\t\t.busocp_def = BQ25960_BUSOCP_DFLT_uA,\n\t\t.busocp_sc_min = BQ25960_BUSOCP_SC_MAX_uA,\n\t\t.busocp_sc_max = BQ25960_BUSOCP_SC_MAX_uA,\n\t\t.busocp_byp_min = BQ25960_BUSOCP_SC_MAX_uA,\n\t\t.busocp_byp_max = BQ25960_BUSOCP_BYP_MAX_uA,\n\n\t\t.busovp_sc_def = BQ25975_BUSOVP_DFLT_uV,\n\t\t.busovp_byp_def = BQ25975_BUSOVP_BYPASS_DFLT_uV,\n\t\t.busovp_sc_step = BQ25960_BUSOVP_SC_STEP_uV,\n\t\t.busovp_sc_offset = BQ25960_BUSOVP_SC_OFFSET_uV,\n\t\t.busovp_byp_step = BQ25960_BUSOVP_BYP_STEP_uV,\n\t\t.busovp_byp_offset = BQ25960_BUSOVP_BYP_OFFSET_uV,\n\t\t.busovp_sc_min = BQ25960_BUSOVP_SC_MIN_uV,\n\t\t.busovp_sc_max = BQ25960_BUSOVP_SC_MAX_uV,\n\t\t.busovp_byp_min = BQ25960_BUSOVP_BYP_MIN_uV,\n\t\t.busovp_byp_max = BQ25960_BUSOVP_BYP_MAX_uV,\n\n\t\t.batovp_def = BQ25960_BATOVP_DFLT_uV,\n\t\t.batovp_max = BQ25960_BATOVP_MAX_uV,\n\t\t.batovp_min = BQ25960_BATOVP_MIN_uV,\n\t\t.batovp_step = BQ25960_BATOVP_STEP_uV,\n\t\t.batovp_offset = BQ25960_BATOVP_OFFSET_uV,\n\n\t\t.batocp_def = BQ25960_BATOCP_DFLT_uA,\n\t\t.batocp_max = BQ25960_BATOCP_MAX_uA,\n\t},\n};\n\nstatic int bq25980_power_supply_init(struct bq25980_device *bq,\n\t\t\t\t\t\t\tstruct device *dev)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = bq,\n\t\t\t\t\t\t.of_node = dev->of_node, };\n\n\tpsy_cfg.supplied_to = bq25980_charger_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(bq25980_charger_supplied_to);\n\n\tbq->charger = devm_power_supply_register(bq->dev,\n\t\t\t\t\t\t &bq25980_power_supply_desc,\n\t\t\t\t\t\t &psy_cfg);\n\tif (IS_ERR(bq->charger))\n\t\treturn -EINVAL;\n\n\tbq->battery = devm_power_supply_register(bq->dev,\n\t\t\t\t\t\t      &bq25980_battery_desc,\n\t\t\t\t\t\t      &psy_cfg);\n\tif (IS_ERR(bq->battery))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int bq25980_hw_init(struct bq25980_device *bq)\n{\n\tstruct power_supply_battery_info *bat_info;\n\tint wd_reg_val = BQ25980_WATCHDOG_DIS;\n\tint wd_max_val = BQ25980_NUM_WD_VAL - 1;\n\tint ret = 0;\n\tint curr_val;\n\tint volt_val;\n\tint i;\n\n\tif (bq->watchdog_timer) {\n\t\tif (bq->watchdog_timer >= bq25980_watchdog_time[wd_max_val])\n\t\t\twd_reg_val = wd_max_val;\n\t\telse {\n\t\t\tfor (i = 0; i < wd_max_val; i++) {\n\t\t\t\tif (bq->watchdog_timer > bq25980_watchdog_time[i] &&\n\t\t\t\t    bq->watchdog_timer < bq25980_watchdog_time[i + 1]) {\n\t\t\t\t\twd_reg_val = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_3,\n\t\t\t\t BQ25980_WATCHDOG_MASK, wd_reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = power_supply_get_battery_info(bq->charger, &bat_info);\n\tif (ret) {\n\t\tdev_warn(bq->dev, \"battery info missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbq->init_data.ichg_max = bat_info->constant_charge_current_max_ua;\n\tbq->init_data.vreg_max = bat_info->constant_charge_voltage_max_uv;\n\n\tif (bq->state.bypass) {\n\t\tret = regmap_update_bits(bq->regmap, BQ25980_CHRGR_CTRL_2,\n\t\t\t\t\tBQ25980_EN_BYPASS, BQ25980_EN_BYPASS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcurr_val = bq->init_data.bypass_ilim;\n\t\tvolt_val = bq->init_data.bypass_vlim;\n\t} else {\n\t\tcurr_val = bq->init_data.sc_ilim;\n\t\tvolt_val = bq->init_data.sc_vlim;\n\t}\n\n\tret = bq25980_set_input_curr_lim(bq, curr_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bq25980_set_input_volt_lim(bq, volt_val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(bq->regmap, BQ25980_ADC_CONTROL1,\n\t\t\t\t BQ25980_ADC_EN, BQ25980_ADC_EN);\n}\n\nstatic int bq25980_parse_dt(struct bq25980_device *bq)\n{\n\tint ret;\n\n\tret = device_property_read_u32(bq->dev, \"ti,watchdog-timeout-ms\",\n\t\t\t\t       &bq->watchdog_timer);\n\tif (ret)\n\t\tbq->watchdog_timer = BQ25980_WATCHDOG_MIN;\n\n\tif (bq->watchdog_timer > BQ25980_WATCHDOG_MAX ||\n\t    bq->watchdog_timer < BQ25980_WATCHDOG_MIN)\n\t\treturn -EINVAL;\n\n\tret = device_property_read_u32(bq->dev,\n\t\t\t\t       \"ti,sc-ovp-limit-microvolt\",\n\t\t\t\t       &bq->init_data.sc_vlim);\n\tif (ret)\n\t\tbq->init_data.sc_vlim = bq->chip_info->busovp_sc_def;\n\n\tif (bq->init_data.sc_vlim > bq->chip_info->busovp_sc_max ||\n\t    bq->init_data.sc_vlim < bq->chip_info->busovp_sc_min) {\n\t\tdev_err(bq->dev, \"SC ovp limit is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32(bq->dev,\n\t\t\t\t       \"ti,sc-ocp-limit-microamp\",\n\t\t\t\t       &bq->init_data.sc_ilim);\n\tif (ret)\n\t\tbq->init_data.sc_ilim = bq->chip_info->busocp_def;\n\n\tif (bq->init_data.sc_ilim > bq->chip_info->busocp_sc_max ||\n\t    bq->init_data.sc_ilim < bq->chip_info->busocp_sc_min) {\n\t\tdev_err(bq->dev, \"SC ocp limit is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32(bq->dev,\n\t\t\t\t       \"ti,bypass-ovp-limit-microvolt\",\n\t\t\t\t       &bq->init_data.bypass_vlim);\n\tif (ret)\n\t\tbq->init_data.bypass_vlim = bq->chip_info->busovp_byp_def;\n\n\tif (bq->init_data.bypass_vlim > bq->chip_info->busovp_byp_max ||\n\t    bq->init_data.bypass_vlim < bq->chip_info->busovp_byp_min) {\n\t\tdev_err(bq->dev, \"Bypass ovp limit is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32(bq->dev,\n\t\t\t\t       \"ti,bypass-ocp-limit-microamp\",\n\t\t\t\t       &bq->init_data.bypass_ilim);\n\tif (ret)\n\t\tbq->init_data.bypass_ilim = bq->chip_info->busocp_def;\n\n\tif (bq->init_data.bypass_ilim > bq->chip_info->busocp_byp_max ||\n\t    bq->init_data.bypass_ilim < bq->chip_info->busocp_byp_min) {\n\t\tdev_err(bq->dev, \"Bypass ocp limit is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\n\tbq->state.bypass = device_property_read_bool(bq->dev,\n\t\t\t\t\t\t      \"ti,bypass-enable\");\n\treturn 0;\n}\n\nstatic int bq25980_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct bq25980_device *bq;\n\tint ret;\n\n\tbq = devm_kzalloc(dev, sizeof(*bq), GFP_KERNEL);\n\tif (!bq)\n\t\treturn -ENOMEM;\n\n\tbq->client = client;\n\tbq->dev = dev;\n\n\tmutex_init(&bq->lock);\n\n\tstrncpy(bq->model_name, id->name, I2C_NAME_SIZE);\n\tbq->chip_info = &bq25980_chip_info_tbl[id->driver_data];\n\n\tbq->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t  bq->chip_info->regmap_config);\n\tif (IS_ERR(bq->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(bq->regmap);\n\t}\n\n\ti2c_set_clientdata(client, bq);\n\n\tret = bq25980_parse_dt(bq);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read device tree properties%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tbq25980_irq_handler_thread,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&client->dev), bq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = bq25980_power_supply_init(bq, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register power supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bq25980_hw_init(bq);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot initialize the chip.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id bq25980_i2c_ids[] = {\n\t{ \"bq25980\", BQ25980 },\n\t{ \"bq25975\", BQ25975 },\n\t{ \"bq25960\", BQ25960 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, bq25980_i2c_ids);\n\nstatic const struct of_device_id bq25980_of_match[] = {\n\t{ .compatible = \"ti,bq25980\", .data = (void *)BQ25980 },\n\t{ .compatible = \"ti,bq25975\", .data = (void *)BQ25975 },\n\t{ .compatible = \"ti,bq25960\", .data = (void *)BQ25960 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bq25980_of_match);\n\nstatic struct i2c_driver bq25980_driver = {\n\t.driver = {\n\t\t.name = \"bq25980-charger\",\n\t\t.of_match_table = bq25980_of_match,\n\t},\n\t.probe = bq25980_probe,\n\t.id_table = bq25980_i2c_ids,\n};\nmodule_i2c_driver(bq25980_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_AUTHOR(\"Ricardo Rivera-Matos <r-rivera-matos@ti.com>\");\nMODULE_DESCRIPTION(\"bq25980 charger driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}