{
  "module_name": "ab8500_btemp.c",
  "hash_id": "3220c298d22ff8d77791c460b29654b5569880e3da8158aa84481c2093e64783",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ab8500_btemp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/component.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/of.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/thermal.h>\n#include <linux/iio/consumer.h>\n#include <linux/fixp-arith.h>\n\n#include \"ab8500-bm.h\"\n\n#define BTEMP_THERMAL_LOW_LIMIT\t\t-10\n#define BTEMP_THERMAL_MED_LIMIT\t\t0\n#define BTEMP_THERMAL_HIGH_LIMIT_52\t52\n#define BTEMP_THERMAL_HIGH_LIMIT_57\t57\n#define BTEMP_THERMAL_HIGH_LIMIT_62\t62\n\n#define BTEMP_BATCTRL_CURR_SRC_7UA\t7\n#define BTEMP_BATCTRL_CURR_SRC_20UA\t20\n\n#define BTEMP_BATCTRL_CURR_SRC_16UA\t16\n#define BTEMP_BATCTRL_CURR_SRC_18UA\t18\n\n#define BTEMP_BATCTRL_CURR_SRC_60UA\t60\n#define BTEMP_BATCTRL_CURR_SRC_120UA\t120\n\n \nstruct ab8500_btemp_interrupts {\n\tchar *name;\n\tirqreturn_t (*isr)(int irq, void *data);\n};\n\nstruct ab8500_btemp_events {\n\tbool batt_rem;\n\tbool btemp_high;\n\tbool btemp_medhigh;\n\tbool btemp_lowmed;\n\tbool btemp_low;\n\tbool ac_conn;\n\tbool usb_conn;\n};\n\nstruct ab8500_btemp_ranges {\n\tint btemp_high_limit;\n\tint btemp_med_limit;\n\tint btemp_low_limit;\n};\n\n \nstruct ab8500_btemp {\n\tstruct device *dev;\n\tstruct list_head node;\n\tint curr_source;\n\tint bat_temp;\n\tint prev_bat_temp;\n\tstruct ab8500 *parent;\n\tstruct thermal_zone_device *tz;\n\tstruct iio_channel *bat_ctrl;\n\tstruct ab8500_fg *fg;\n\tstruct ab8500_bm_data *bm;\n\tstruct power_supply *btemp_psy;\n\tstruct ab8500_btemp_events events;\n\tstruct ab8500_btemp_ranges btemp_ranges;\n\tstruct workqueue_struct *btemp_wq;\n\tstruct delayed_work btemp_periodic_work;\n\tbool initialized;\n};\n\n \nstatic enum power_supply_property ab8500_btemp_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic LIST_HEAD(ab8500_btemp_list);\n\n \nstatic int ab8500_btemp_batctrl_volt_to_res(struct ab8500_btemp *di,\n\tint v_batctrl, int inst_curr)\n{\n\tif (is_ab8500_1p1_or_earlier(di->parent)) {\n\t\t \n\t\treturn (450000 * (v_batctrl)) / (1800 - v_batctrl);\n\t}\n\n\t \n\treturn (80000 * (v_batctrl)) / (1800 - v_batctrl);\n}\n\n \nstatic int ab8500_btemp_read_batctrl_voltage(struct ab8500_btemp *di)\n{\n\tint vbtemp, ret;\n\tstatic int prev;\n\n\tret = iio_read_channel_processed(di->bat_ctrl, &vbtemp);\n\tif (ret < 0) {\n\t\tdev_err(di->dev,\n\t\t\t\"%s ADC conversion failed, using previous value\",\n\t\t\t__func__);\n\t\treturn prev;\n\t}\n\tprev = vbtemp;\n\treturn vbtemp;\n}\n\n \nstatic int ab8500_btemp_get_batctrl_res(struct ab8500_btemp *di)\n{\n\tint ret;\n\tint batctrl = 0;\n\tint res;\n\tint inst_curr;\n\tint i;\n\n\tif (!di->fg)\n\t\tdi->fg = ab8500_fg_get();\n\tif (!di->fg) {\n\t\tdev_err(di->dev, \"No fg found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ab8500_fg_inst_curr_start(di->fg);\n\n\tif (ret) {\n\t\tdev_err(di->dev, \"Failed to start current measurement\\n\");\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tmsleep(20);\n\t} while (!ab8500_fg_inst_curr_started(di->fg));\n\n\ti = 0;\n\n\tdo {\n\t\tbatctrl += ab8500_btemp_read_batctrl_voltage(di);\n\t\ti++;\n\t\tmsleep(20);\n\t} while (!ab8500_fg_inst_curr_done(di->fg));\n\tbatctrl /= i;\n\n\tret = ab8500_fg_inst_curr_finalize(di->fg, &inst_curr);\n\tif (ret) {\n\t\tdev_err(di->dev, \"Failed to finalize current measurement\\n\");\n\t\treturn ret;\n\t}\n\n\tres = ab8500_btemp_batctrl_volt_to_res(di, batctrl, inst_curr);\n\n\tdev_dbg(di->dev, \"%s batctrl: %d res: %d inst_curr: %d samples: %d\\n\",\n\t\t__func__, batctrl, res, inst_curr, i);\n\n\treturn res;\n}\n\n \nstatic int ab8500_btemp_id(struct ab8500_btemp *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\tint res;\n\n\tdi->curr_source = BTEMP_BATCTRL_CURR_SRC_7UA;\n\n\tres =  ab8500_btemp_get_batctrl_res(di);\n\tif (res < 0) {\n\t\tdev_err(di->dev, \"%s get batctrl res failed\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (power_supply_battery_bti_in_range(bi, res)) {\n\t\tdev_info(di->dev, \"Battery detected on BATCTRL (pin C3)\"\n\t\t\t \" resistance %d Ohm = %d Ohm +/- %d%%\\n\",\n\t\t\t res, bi->bti_resistance_ohm,\n\t\t\t bi->bti_resistance_tolerance);\n\t} else {\n\t\tdev_warn(di->dev, \"Battery identified as unknown\"\n\t\t\t \", resistance %d Ohm\\n\", res);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ab8500_btemp_periodic_work(struct work_struct *work)\n{\n\tint interval;\n\tint bat_temp;\n\tstruct ab8500_btemp *di = container_of(work,\n\t\tstruct ab8500_btemp, btemp_periodic_work.work);\n\t \n\tstatic int prev = 25;\n\tint ret;\n\n\tif (!di->initialized) {\n\t\t \n\t\tif (ab8500_btemp_id(di) < 0)\n\t\t\tdev_warn(di->dev, \"failed to identify the battery\\n\");\n\t}\n\n\t \n\tret = thermal_zone_get_temp(di->tz, &bat_temp);\n\tif (ret) {\n\t\tdev_err(di->dev, \"error reading temperature\\n\");\n\t\tbat_temp = prev;\n\t} else {\n\t\t \n\t\tbat_temp /= 1000;\n\t\tprev = bat_temp;\n\t}\n\n\t \n\tif ((bat_temp == di->prev_bat_temp) || !di->initialized) {\n\t\tif ((di->bat_temp != di->prev_bat_temp) || !di->initialized) {\n\t\t\tdi->initialized = true;\n\t\t\tdi->bat_temp = bat_temp;\n\t\t\tpower_supply_changed(di->btemp_psy);\n\t\t}\n\t} else if (bat_temp < di->prev_bat_temp) {\n\t\tdi->bat_temp--;\n\t\tpower_supply_changed(di->btemp_psy);\n\t} else if (bat_temp > di->prev_bat_temp) {\n\t\tdi->bat_temp++;\n\t\tpower_supply_changed(di->btemp_psy);\n\t}\n\tdi->prev_bat_temp = bat_temp;\n\n\tif (di->events.ac_conn || di->events.usb_conn)\n\t\tinterval = di->bm->temp_interval_chg;\n\telse\n\t\tinterval = di->bm->temp_interval_nochg;\n\n\t \n\tqueue_delayed_work(di->btemp_wq,\n\t\t&di->btemp_periodic_work,\n\t\tround_jiffies(interval * HZ));\n}\n\n \nstatic irqreturn_t ab8500_btemp_batctrlindb_handler(int irq, void *_di)\n{\n\tstruct ab8500_btemp *di = _di;\n\tdev_err(di->dev, \"Battery removal detected!\\n\");\n\n\tdi->events.batt_rem = true;\n\tpower_supply_changed(di->btemp_psy);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_btemp_templow_handler(int irq, void *_di)\n{\n\tstruct ab8500_btemp *di = _di;\n\n\tif (is_ab8500_3p3_or_earlier(di->parent)) {\n\t\tdev_dbg(di->dev, \"Ignore false btemp low irq\"\n\t\t\t\" for ABB cut 1.0, 1.1, 2.0 and 3.3\\n\");\n\t} else {\n\t\tdev_crit(di->dev, \"Battery temperature lower than -10deg c\\n\");\n\n\t\tdi->events.btemp_low = true;\n\t\tdi->events.btemp_high = false;\n\t\tdi->events.btemp_medhigh = false;\n\t\tdi->events.btemp_lowmed = false;\n\t\tpower_supply_changed(di->btemp_psy);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_btemp_temphigh_handler(int irq, void *_di)\n{\n\tstruct ab8500_btemp *di = _di;\n\n\tdev_crit(di->dev, \"Battery temperature is higher than MAX temp\\n\");\n\n\tdi->events.btemp_high = true;\n\tdi->events.btemp_medhigh = false;\n\tdi->events.btemp_lowmed = false;\n\tdi->events.btemp_low = false;\n\tpower_supply_changed(di->btemp_psy);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_btemp_lowmed_handler(int irq, void *_di)\n{\n\tstruct ab8500_btemp *di = _di;\n\n\tdev_dbg(di->dev, \"Battery temperature is between low and medium\\n\");\n\n\tdi->events.btemp_lowmed = true;\n\tdi->events.btemp_medhigh = false;\n\tdi->events.btemp_high = false;\n\tdi->events.btemp_low = false;\n\tpower_supply_changed(di->btemp_psy);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_btemp_medhigh_handler(int irq, void *_di)\n{\n\tstruct ab8500_btemp *di = _di;\n\n\tdev_dbg(di->dev, \"Battery temperature is between medium and high\\n\");\n\n\tdi->events.btemp_medhigh = true;\n\tdi->events.btemp_lowmed = false;\n\tdi->events.btemp_high = false;\n\tdi->events.btemp_low = false;\n\tpower_supply_changed(di->btemp_psy);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ab8500_btemp_periodic(struct ab8500_btemp *di,\n\tbool enable)\n{\n\tdev_dbg(di->dev, \"Enable periodic temperature measurements: %d\\n\",\n\t\tenable);\n\t \n\tcancel_delayed_work_sync(&di->btemp_periodic_work);\n\n\tif (enable)\n\t\tqueue_delayed_work(di->btemp_wq, &di->btemp_periodic_work, 0);\n}\n\n \nstatic int ab8500_btemp_get_temp(struct ab8500_btemp *di)\n{\n\tint temp = 0;\n\n\t \n\tif (is_ab8500_3p3_or_earlier(di->parent)) {\n\t\ttemp = di->bat_temp * 10;\n\t} else {\n\t\tif (di->events.btemp_low) {\n\t\t\tif (temp > di->btemp_ranges.btemp_low_limit)\n\t\t\t\ttemp = di->btemp_ranges.btemp_low_limit * 10;\n\t\t\telse\n\t\t\t\ttemp = di->bat_temp * 10;\n\t\t} else if (di->events.btemp_high) {\n\t\t\tif (temp < di->btemp_ranges.btemp_high_limit)\n\t\t\t\ttemp = di->btemp_ranges.btemp_high_limit * 10;\n\t\t\telse\n\t\t\t\ttemp = di->bat_temp * 10;\n\t\t} else if (di->events.btemp_lowmed) {\n\t\t\tif (temp > di->btemp_ranges.btemp_med_limit)\n\t\t\t\ttemp = di->btemp_ranges.btemp_med_limit * 10;\n\t\t\telse\n\t\t\t\ttemp = di->bat_temp * 10;\n\t\t} else if (di->events.btemp_medhigh) {\n\t\t\tif (temp < di->btemp_ranges.btemp_med_limit)\n\t\t\t\ttemp = di->btemp_ranges.btemp_med_limit * 10;\n\t\t\telse\n\t\t\t\ttemp = di->bat_temp * 10;\n\t\t} else\n\t\t\ttemp = di->bat_temp * 10;\n\t}\n\treturn temp;\n}\n\n \nstatic int ab8500_btemp_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct ab8500_btemp *di = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tif (di->events.batt_rem)\n\t\t\tval->intval = 0;\n\t\telse\n\t\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = ab8500_btemp_get_temp(di);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ab8500_btemp_get_ext_psy_data(struct device *dev, void *data)\n{\n\tstruct power_supply *psy;\n\tstruct power_supply *ext = dev_get_drvdata(dev);\n\tconst char **supplicants = (const char **)ext->supplied_to;\n\tstruct ab8500_btemp *di;\n\tunion power_supply_propval ret;\n\tint j;\n\n\tpsy = (struct power_supply *)data;\n\tdi = power_supply_get_drvdata(psy);\n\n\t \n\tj = match_string(supplicants, ext->num_supplicants, psy->desc->name);\n\tif (j < 0)\n\t\treturn 0;\n\n\t \n\tfor (j = 0; j < ext->desc->num_properties; j++) {\n\t\tenum power_supply_property prop;\n\t\tprop = ext->desc->properties[j];\n\n\t\tif (power_supply_get_property(ext, prop, &ret))\n\t\t\tcontinue;\n\n\t\tswitch (prop) {\n\t\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\t \n\t\t\t\tif (!ret.intval && di->events.ac_conn) {\n\t\t\t\t\tdi->events.ac_conn = false;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval && !di->events.ac_conn) {\n\t\t\t\t\tdi->events.ac_conn = true;\n\t\t\t\t\tif (!di->events.usb_conn)\n\t\t\t\t\t\tab8500_btemp_periodic(di, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\t \n\t\t\t\tif (!ret.intval && di->events.usb_conn) {\n\t\t\t\t\tdi->events.usb_conn = false;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval && !di->events.usb_conn) {\n\t\t\t\t\tdi->events.usb_conn = true;\n\t\t\t\t\tif (!di->events.ac_conn)\n\t\t\t\t\t\tab8500_btemp_periodic(di, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void ab8500_btemp_external_power_changed(struct power_supply *psy)\n{\n\tclass_for_each_device(power_supply_class, NULL, psy,\n\t\t\t      ab8500_btemp_get_ext_psy_data);\n}\n\n \nstatic struct ab8500_btemp_interrupts ab8500_btemp_irq[] = {\n\t{\"BAT_CTRL_INDB\", ab8500_btemp_batctrlindb_handler},\n\t{\"BTEMP_LOW\", ab8500_btemp_templow_handler},\n\t{\"BTEMP_HIGH\", ab8500_btemp_temphigh_handler},\n\t{\"BTEMP_LOW_MEDIUM\", ab8500_btemp_lowmed_handler},\n\t{\"BTEMP_MEDIUM_HIGH\", ab8500_btemp_medhigh_handler},\n};\n\nstatic int __maybe_unused ab8500_btemp_resume(struct device *dev)\n{\n\tstruct ab8500_btemp *di = dev_get_drvdata(dev);\n\n\tab8500_btemp_periodic(di, true);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ab8500_btemp_suspend(struct device *dev)\n{\n\tstruct ab8500_btemp *di = dev_get_drvdata(dev);\n\n\tab8500_btemp_periodic(di, false);\n\n\treturn 0;\n}\n\nstatic char *supply_interface[] = {\n\t\"ab8500_chargalg\",\n\t\"ab8500_fg\",\n};\n\nstatic const struct power_supply_desc ab8500_btemp_desc = {\n\t.name\t\t\t= \"ab8500_btemp\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_UNKNOWN,\n\t.properties\t\t= ab8500_btemp_props,\n\t.num_properties\t\t= ARRAY_SIZE(ab8500_btemp_props),\n\t.get_property\t\t= ab8500_btemp_get_property,\n\t.external_power_changed\t= ab8500_btemp_external_power_changed,\n};\n\nstatic int ab8500_btemp_bind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\tstruct ab8500_btemp *di = dev_get_drvdata(dev);\n\n\t \n\tdi->btemp_wq =\n\t\talloc_workqueue(\"ab8500_btemp_wq\", WQ_MEM_RECLAIM, 0);\n\tif (di->btemp_wq == NULL) {\n\t\tdev_err(dev, \"failed to create work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tab8500_btemp_periodic(di, true);\n\n\treturn 0;\n}\n\nstatic void ab8500_btemp_unbind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n\tstruct ab8500_btemp *di = dev_get_drvdata(dev);\n\n\t \n\tdestroy_workqueue(di->btemp_wq);\n}\n\nstatic const struct component_ops ab8500_btemp_component_ops = {\n\t.bind = ab8500_btemp_bind,\n\t.unbind = ab8500_btemp_unbind,\n};\n\nstatic int ab8500_btemp_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct device *dev = &pdev->dev;\n\tstruct ab8500_btemp *di;\n\tint irq, i, ret = 0;\n\tu8 val;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->bm = &ab8500_bm_data;\n\n\t \n\tdi->dev = dev;\n\tdi->parent = dev_get_drvdata(pdev->dev.parent);\n\n\t \n\tdi->tz = thermal_zone_get_zone_by_name(\"battery-thermal\");\n\tif (IS_ERR(di->tz)) {\n\t\tret = PTR_ERR(di->tz);\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tret = -EPROBE_DEFER;\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get battery thermal zone\\n\");\n\t}\n\tdi->bat_ctrl = devm_iio_channel_get(dev, \"bat_ctrl\");\n\tif (IS_ERR(di->bat_ctrl)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(di->bat_ctrl),\n\t\t\t\t    \"failed to get BAT CTRL ADC channel\\n\");\n\t\treturn ret;\n\t}\n\n\tdi->initialized = false;\n\n\tpsy_cfg.supplied_to = supply_interface;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\n\tpsy_cfg.drv_data = di;\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->btemp_periodic_work,\n\t\tab8500_btemp_periodic_work);\n\n\t \n\tdi->btemp_ranges.btemp_low_limit = BTEMP_THERMAL_LOW_LIMIT;\n\tdi->btemp_ranges.btemp_med_limit = BTEMP_THERMAL_MED_LIMIT;\n\n\tret = abx500_get_register_interruptible(dev, AB8500_CHARGER,\n\t\tAB8500_BTEMP_HIGH_TH, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\tswitch (val) {\n\tcase BTEMP_HIGH_TH_57_0:\n\tcase BTEMP_HIGH_TH_57_1:\n\t\tdi->btemp_ranges.btemp_high_limit =\n\t\t\tBTEMP_THERMAL_HIGH_LIMIT_57;\n\t\tbreak;\n\tcase BTEMP_HIGH_TH_52:\n\t\tdi->btemp_ranges.btemp_high_limit =\n\t\t\tBTEMP_THERMAL_HIGH_LIMIT_52;\n\t\tbreak;\n\tcase BTEMP_HIGH_TH_62:\n\t\tdi->btemp_ranges.btemp_high_limit =\n\t\t\tBTEMP_THERMAL_HIGH_LIMIT_62;\n\t\tbreak;\n\t}\n\n\t \n\tdi->btemp_psy = devm_power_supply_register(dev, &ab8500_btemp_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(di->btemp_psy)) {\n\t\tdev_err(dev, \"failed to register BTEMP psy\\n\");\n\t\treturn PTR_ERR(di->btemp_psy);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_btemp_irq); i++) {\n\t\tirq = platform_get_irq_byname(pdev, ab8500_btemp_irq[i].name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\tab8500_btemp_irq[i].isr,\n\t\t\tIRQF_SHARED | IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\tab8500_btemp_irq[i].name, di);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request %s IRQ %d: %d\\n\"\n\t\t\t\t, ab8500_btemp_irq[i].name, irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev, \"Requested %s IRQ %d: %d\\n\",\n\t\t\tab8500_btemp_irq[i].name, irq, ret);\n\t}\n\n\tplatform_set_drvdata(pdev, di);\n\n\tlist_add_tail(&di->node, &ab8500_btemp_list);\n\n\treturn component_add(dev, &ab8500_btemp_component_ops);\n}\n\nstatic int ab8500_btemp_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &ab8500_btemp_component_ops);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ab8500_btemp_pm_ops, ab8500_btemp_suspend, ab8500_btemp_resume);\n\nstatic const struct of_device_id ab8500_btemp_match[] = {\n\t{ .compatible = \"stericsson,ab8500-btemp\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ab8500_btemp_match);\n\nstruct platform_driver ab8500_btemp_driver = {\n\t.probe = ab8500_btemp_probe,\n\t.remove = ab8500_btemp_remove,\n\t.driver = {\n\t\t.name = \"ab8500-btemp\",\n\t\t.of_match_table = ab8500_btemp_match,\n\t\t.pm = &ab8500_btemp_pm_ops,\n\t},\n};\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Johan Palsson, Karl Komierowski, Arun R Murthy\");\nMODULE_ALIAS(\"platform:ab8500-btemp\");\nMODULE_DESCRIPTION(\"AB8500 battery temperature driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}