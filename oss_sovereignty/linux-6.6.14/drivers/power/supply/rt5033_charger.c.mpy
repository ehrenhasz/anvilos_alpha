{
  "module_name": "rt5033_charger.c",
  "hash_id": "79d7c6451f4a50963b0d9f6c532f9b0d2409b4c6b761b623ccb99e59b05dbad8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/rt5033_charger.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/mfd/rt5033-private.h>\n\nstruct rt5033_charger_data {\n\tunsigned int pre_uamp;\n\tunsigned int pre_uvolt;\n\tunsigned int const_uvolt;\n\tunsigned int eoc_uamp;\n\tunsigned int fast_uamp;\n};\n\nstruct rt5033_charger {\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct power_supply\t\t*psy;\n\tstruct rt5033_charger_data\t*chg;\n};\n\nstatic int rt5033_get_charger_state(struct rt5033_charger *charger)\n{\n\tstruct regmap *regmap = charger->regmap;\n\tunsigned int reg_data;\n\tint state;\n\n\tif (!regmap)\n\t\treturn POWER_SUPPLY_STATUS_UNKNOWN;\n\n\tregmap_read(regmap, RT5033_REG_CHG_STAT, &reg_data);\n\n\tswitch (reg_data & RT5033_CHG_STAT_MASK) {\n\tcase RT5033_CHG_STAT_DISCHARGING:\n\t\tstate = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase RT5033_CHG_STAT_CHARGING:\n\t\tstate = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase RT5033_CHG_STAT_FULL:\n\t\tstate = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase RT5033_CHG_STAT_NOT_CHARGING:\n\t\tstate = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tdefault:\n\t\tstate = POWER_SUPPLY_STATUS_UNKNOWN;\n\t}\n\n\treturn state;\n}\n\nstatic int rt5033_get_charger_type(struct rt5033_charger *charger)\n{\n\tstruct regmap *regmap = charger->regmap;\n\tunsigned int reg_data;\n\tint state;\n\n\tregmap_read(regmap, RT5033_REG_CHG_STAT, &reg_data);\n\n\tswitch (reg_data & RT5033_CHG_STAT_TYPE_MASK) {\n\tcase RT5033_CHG_STAT_TYPE_FAST:\n\t\tstate = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\tbreak;\n\tcase RT5033_CHG_STAT_TYPE_PRE:\n\t\tstate = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tdefault:\n\t\tstate = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t}\n\n\treturn state;\n}\n\nstatic int rt5033_get_charger_current_limit(struct rt5033_charger *charger)\n{\n\tstruct regmap *regmap = charger->regmap;\n\tunsigned int state, reg_data, data;\n\n\tregmap_read(regmap, RT5033_REG_CHG_CTRL5, &reg_data);\n\n\tstate = (reg_data & RT5033_CHGCTRL5_ICHG_MASK)\n\t\t >> RT5033_CHGCTRL5_ICHG_SHIFT;\n\n\tdata = RT5033_CHARGER_FAST_CURRENT_MIN +\n\t\tRT5033_CHARGER_FAST_CURRENT_STEP_NUM * state;\n\n\treturn data;\n}\n\nstatic int rt5033_get_charger_const_voltage(struct rt5033_charger *charger)\n{\n\tstruct regmap *regmap = charger->regmap;\n\tunsigned int state, reg_data, data;\n\n\tregmap_read(regmap, RT5033_REG_CHG_CTRL2, &reg_data);\n\n\tstate = (reg_data & RT5033_CHGCTRL2_CV_MASK)\n\t\t >> RT5033_CHGCTRL2_CV_SHIFT;\n\n\tdata = RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MIN +\n\t\tRT5033_CHARGER_CONST_VOLTAGE_STEP_NUM * state;\n\n\treturn data;\n}\n\nstatic inline int rt5033_init_const_charge(struct rt5033_charger *charger)\n{\n\tstruct rt5033_charger_data *chg = charger->chg;\n\tint ret;\n\tunsigned int val;\n\tu8 reg_data;\n\n\t \n\tif (chg->const_uvolt < RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MIN ||\n\t    chg->const_uvolt > RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MAX) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Value 'constant-charge-voltage-max-microvolt' out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg->const_uvolt == RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MIN)\n\t\treg_data = 0x00;\n\telse if (chg->const_uvolt == RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MAX)\n\t\treg_data = RT5033_CV_MAX_VOLTAGE;\n\telse {\n\t\tval = chg->const_uvolt;\n\t\tval -= RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MIN;\n\t\tval /= RT5033_CHARGER_CONST_VOLTAGE_STEP_NUM;\n\t\treg_data = val;\n\t}\n\n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL2,\n\t\t\tRT5033_CHGCTRL2_CV_MASK,\n\t\t\treg_data << RT5033_CHGCTRL2_CV_SHIFT);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chg->eoc_uamp < RT5033_CHARGER_EOC_MIN ||\n\t    chg->eoc_uamp > RT5033_CHARGER_EOC_MAX) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Value 'charge-term-current-microamp' out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg->eoc_uamp == RT5033_CHARGER_EOC_MIN)\n\t\treg_data = 0x01;\n\telse if (chg->eoc_uamp == RT5033_CHARGER_EOC_MAX)\n\t\treg_data = 0x07;\n\telse {\n\t\tval = chg->eoc_uamp;\n\t\tif (val < RT5033_CHARGER_EOC_REF) {\n\t\t\tval -= RT5033_CHARGER_EOC_MIN;\n\t\t\tval /= RT5033_CHARGER_EOC_STEP_NUM1;\n\t\t\treg_data = 0x01 + val;\n\t\t} else if (val > RT5033_CHARGER_EOC_REF) {\n\t\t\tval -= RT5033_CHARGER_EOC_REF;\n\t\t\tval /= RT5033_CHARGER_EOC_STEP_NUM2;\n\t\t\treg_data = 0x04 + val;\n\t\t} else {\n\t\t\treg_data = 0x04;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL4,\n\t\t\tRT5033_CHGCTRL4_EOC_MASK, reg_data);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int rt5033_init_fast_charge(struct rt5033_charger *charger)\n{\n\tstruct rt5033_charger_data *chg = charger->chg;\n\tint ret;\n\tunsigned int val;\n\tu8 reg_data;\n\n\t \n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL1,\n\t\t\tRT5033_CHGCTRL1_IAICR_MASK, RT5033_AICR_2000_MODE);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chg->fast_uamp < RT5033_CHARGER_FAST_CURRENT_MIN ||\n\t    chg->fast_uamp > RT5033_CHARGER_FAST_CURRENT_MAX) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Value 'constant-charge-current-max-microamp' out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg->fast_uamp == RT5033_CHARGER_FAST_CURRENT_MIN)\n\t\treg_data = 0x00;\n\telse if (chg->fast_uamp == RT5033_CHARGER_FAST_CURRENT_MAX)\n\t\treg_data = RT5033_CHG_MAX_CURRENT;\n\telse {\n\t\tval = chg->fast_uamp;\n\t\tval -= RT5033_CHARGER_FAST_CURRENT_MIN;\n\t\tval /= RT5033_CHARGER_FAST_CURRENT_STEP_NUM;\n\t\treg_data = val;\n\t}\n\n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL5,\n\t\t\tRT5033_CHGCTRL5_ICHG_MASK,\n\t\t\treg_data << RT5033_CHGCTRL5_ICHG_SHIFT);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int rt5033_init_pre_charge(struct rt5033_charger *charger)\n{\n\tstruct rt5033_charger_data *chg = charger->chg;\n\tint ret;\n\tunsigned int val;\n\tu8 reg_data;\n\n\t \n\tif (chg->pre_uvolt < RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MIN ||\n\t    chg->pre_uvolt > RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MAX) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Value 'precharge-upper-limit-microvolt' out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg->pre_uvolt == RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MIN)\n\t\treg_data = 0x00;\n\telse if (chg->pre_uvolt == RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MAX)\n\t\treg_data = 0x0f;\n\telse {\n\t\tval = chg->pre_uvolt;\n\t\tval -= RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MIN;\n\t\tval /= RT5033_CHARGER_PRE_THRESHOLD_STEP_NUM;\n\t\treg_data = val;\n\t}\n\n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL5,\n\t\t\tRT5033_CHGCTRL5_VPREC_MASK, reg_data);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chg->pre_uamp < RT5033_CHARGER_PRE_CURRENT_LIMIT_MIN ||\n\t    chg->pre_uamp > RT5033_CHARGER_PRE_CURRENT_LIMIT_MAX) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Value 'precharge-current-microamp' out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chg->pre_uamp == RT5033_CHARGER_PRE_CURRENT_LIMIT_MIN)\n\t\treg_data = 0x00;\n\telse if (chg->pre_uamp == RT5033_CHARGER_PRE_CURRENT_LIMIT_MAX)\n\t\treg_data = RT5033_CHG_MAX_PRE_CURRENT;\n\telse {\n\t\tval = chg->pre_uamp;\n\t\tval -= RT5033_CHARGER_PRE_CURRENT_LIMIT_MIN;\n\t\tval /= RT5033_CHARGER_PRE_CURRENT_STEP_NUM;\n\t\treg_data = val;\n\t}\n\n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL4,\n\t\t\tRT5033_CHGCTRL4_IPREC_MASK,\n\t\t\treg_data << RT5033_CHGCTRL4_IPREC_SHIFT);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed regmap update\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt5033_charger_reg_init(struct rt5033_charger *charger)\n{\n\tint ret = 0;\n\n\t \n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL1,\n\t\t\tRT5033_CHGCTRL1_TE_EN_MASK, RT5033_TE_ENABLE);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed to enable charging termination.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_update_bits(charger->regmap, RT5033_REG_CHG_CTRL4,\n\t\t\tRT5033_CHGCTRL4_MIVR_MASK, RT5033_CHARGER_MIVR_DISABLE);\n\tif (ret) {\n\t\tdev_err(charger->dev, \"Failed to disable MIVR.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rt5033_init_pre_charge(charger);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt5033_init_fast_charge(charger);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt5033_init_const_charge(charger);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic enum power_supply_property rt5033_charger_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic int rt5033_charger_get_property(struct power_supply *psy,\n\t\t\tenum power_supply_property psp,\n\t\t\tunion power_supply_propval *val)\n{\n\tstruct rt5033_charger *charger = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = rt5033_get_charger_state(charger);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = rt5033_get_charger_type(charger);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = rt5033_get_charger_current_limit(charger);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tval->intval = rt5033_get_charger_const_voltage(charger);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = RT5033_CHARGER_MODEL;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = RT5033_MANUFACTURER;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = (rt5033_get_charger_state(charger) ==\n\t\t\t\tPOWER_SUPPLY_STATUS_CHARGING);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct rt5033_charger_data *rt5033_charger_dt_init(\n\t\t\t\t\t\tstruct rt5033_charger *charger)\n{\n\tstruct rt5033_charger_data *chg;\n\tstruct power_supply_battery_info *info;\n\tint ret;\n\n\tchg = devm_kzalloc(charger->dev, sizeof(*chg), GFP_KERNEL);\n\tif (!chg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = power_supply_get_battery_info(charger->psy, &info);\n\tif (ret)\n\t\treturn ERR_PTR(dev_err_probe(charger->dev, -EINVAL,\n\t\t\t       \"missing battery info\\n\"));\n\n\t \n\tchg->pre_uamp = info->precharge_current_ua;\n\tchg->fast_uamp = info->constant_charge_current_max_ua;\n\tchg->eoc_uamp = info->charge_term_current_ua;\n\tchg->pre_uvolt = info->precharge_voltage_max_uv;\n\tchg->const_uvolt = info->constant_charge_voltage_max_uv;\n\n\treturn chg;\n}\n\nstatic const struct power_supply_desc rt5033_charger_desc = {\n\t.name = \"rt5033-charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = rt5033_charger_props,\n\t.num_properties = ARRAY_SIZE(rt5033_charger_props),\n\t.get_property = rt5033_charger_get_property,\n};\n\nstatic int rt5033_charger_probe(struct platform_device *pdev)\n{\n\tstruct rt5033_charger *charger;\n\tstruct power_supply_config psy_cfg = {};\n\tint ret;\n\n\tcharger = devm_kzalloc(&pdev->dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, charger);\n\tcharger->dev = &pdev->dev;\n\tcharger->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = charger;\n\n\tcharger->psy = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t  &rt5033_charger_desc,\n\t\t\t\t\t\t  &psy_cfg);\n\tif (IS_ERR(charger->psy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(charger->psy),\n\t\t\t\t     \"Failed to register power supply\\n\");\n\n\tcharger->chg = rt5033_charger_dt_init(charger);\n\tif (IS_ERR_OR_NULL(charger->chg))\n\t\treturn PTR_ERR(charger->chg);\n\n\tret = rt5033_charger_reg_init(charger);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id rt5033_charger_id[] = {\n\t{ \"rt5033-charger\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, rt5033_charger_id);\n\nstatic const struct of_device_id rt5033_charger_of_match[] = {\n\t{ .compatible = \"richtek,rt5033-charger\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rt5033_charger_of_match);\n\nstatic struct platform_driver rt5033_charger_driver = {\n\t.driver = {\n\t\t.name = \"rt5033-charger\",\n\t\t.of_match_table = rt5033_charger_of_match,\n\t},\n\t.probe = rt5033_charger_probe,\n\t.id_table = rt5033_charger_id,\n};\nmodule_platform_driver(rt5033_charger_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT5033 charger driver\");\nMODULE_AUTHOR(\"Beomho Seo <beomho.seo@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}