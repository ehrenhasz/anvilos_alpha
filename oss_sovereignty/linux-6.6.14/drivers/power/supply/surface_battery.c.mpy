{
  "module_name": "surface_battery.c",
  "hash_id": "425f52c179fd871326bc747239fd155fd644217d845b3c1b41da0188314df25d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/surface_battery.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/device.h>\n\n\n \n\nenum sam_event_cid_bat {\n\tSAM_EVENT_CID_BAT_BIX         = 0x15,\n\tSAM_EVENT_CID_BAT_BST         = 0x16,\n\tSAM_EVENT_CID_BAT_ADP         = 0x17,\n\tSAM_EVENT_CID_BAT_PROT        = 0x18,\n\tSAM_EVENT_CID_BAT_DPTF        = 0x53,\n};\n\nenum sam_battery_sta {\n\tSAM_BATTERY_STA_OK            = 0x0f,\n\tSAM_BATTERY_STA_PRESENT\t      = 0x10,\n};\n\nenum sam_battery_state {\n\tSAM_BATTERY_STATE_DISCHARGING = BIT(0),\n\tSAM_BATTERY_STATE_CHARGING    = BIT(1),\n\tSAM_BATTERY_STATE_CRITICAL    = BIT(2),\n};\n\nenum sam_battery_power_unit {\n\tSAM_BATTERY_POWER_UNIT_mW     = 0,\n\tSAM_BATTERY_POWER_UNIT_mA     = 1,\n};\n\n \nstruct spwr_bix {\n\tu8  revision;\n\t__le32 power_unit;\n\t__le32 design_cap;\n\t__le32 last_full_charge_cap;\n\t__le32 technology;\n\t__le32 design_voltage;\n\t__le32 design_cap_warn;\n\t__le32 design_cap_low;\n\t__le32 cycle_count;\n\t__le32 measurement_accuracy;\n\t__le32 max_sampling_time;\n\t__le32 min_sampling_time;\n\t__le32 max_avg_interval;\n\t__le32 min_avg_interval;\n\t__le32 bat_cap_granularity_1;\n\t__le32 bat_cap_granularity_2;\n\t__u8 model[21];\n\t__u8 serial[11];\n\t__u8 type[5];\n\t__u8 oem_info[21];\n} __packed;\n\nstatic_assert(sizeof(struct spwr_bix) == 119);\n\n \nstruct spwr_bst {\n\t__le32 state;\n\t__le32 present_rate;\n\t__le32 remaining_cap;\n\t__le32 present_voltage;\n} __packed;\n\nstatic_assert(sizeof(struct spwr_bst) == 16);\n\n#define SPWR_BIX_REVISION\t\t0\n#define SPWR_BATTERY_VALUE_UNKNOWN\t0xffffffff\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_R(ssam_bat_get_sta, __le32, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x01,\n});\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_R(ssam_bat_get_bix, struct spwr_bix, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x02,\n});\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_R(ssam_bat_get_bst, struct spwr_bst, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x03,\n});\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_W(ssam_bat_set_btp, __le32, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x04,\n});\n\n\n \n\nstruct spwr_psy_properties {\n\tconst char *name;\n\tstruct ssam_event_registry registry;\n};\n\nstruct spwr_battery_device {\n\tstruct ssam_device *sdev;\n\n\tchar name[32];\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\n\tstruct delayed_work update_work;\n\n\tstruct ssam_event_notifier notif;\n\n\tstruct mutex lock;   \n\tunsigned long timestamp;\n\n\t__le32 sta;\n\tstruct spwr_bix bix;\n\tstruct spwr_bst bst;\n\tu32 alarm;\n};\n\n\n \n\nstatic unsigned int cache_time = 1000;\nmodule_param(cache_time, uint, 0644);\nMODULE_PARM_DESC(cache_time, \"battery state caching time in milliseconds [default: 1000]\");\n\n\n \n\n \n#define SPWR_AC_BAT_UPDATE_DELAY\tmsecs_to_jiffies(5000)\n\nstatic bool spwr_battery_present(struct spwr_battery_device *bat)\n{\n\tlockdep_assert_held(&bat->lock);\n\n\treturn le32_to_cpu(bat->sta) & SAM_BATTERY_STA_PRESENT;\n}\n\nstatic int spwr_battery_load_sta(struct spwr_battery_device *bat)\n{\n\tlockdep_assert_held(&bat->lock);\n\n\treturn ssam_retry(ssam_bat_get_sta, bat->sdev, &bat->sta);\n}\n\nstatic int spwr_battery_load_bix(struct spwr_battery_device *bat)\n{\n\tint status;\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (!spwr_battery_present(bat))\n\t\treturn 0;\n\n\tstatus = ssam_retry(ssam_bat_get_bix, bat->sdev, &bat->bix);\n\n\t \n\tbat->bix.model[ARRAY_SIZE(bat->bix.model) - 1] = 0;\n\tbat->bix.serial[ARRAY_SIZE(bat->bix.serial) - 1] = 0;\n\tbat->bix.type[ARRAY_SIZE(bat->bix.type) - 1] = 0;\n\tbat->bix.oem_info[ARRAY_SIZE(bat->bix.oem_info) - 1] = 0;\n\n\treturn status;\n}\n\nstatic int spwr_battery_load_bst(struct spwr_battery_device *bat)\n{\n\tlockdep_assert_held(&bat->lock);\n\n\tif (!spwr_battery_present(bat))\n\t\treturn 0;\n\n\treturn ssam_retry(ssam_bat_get_bst, bat->sdev, &bat->bst);\n}\n\nstatic int spwr_battery_set_alarm_unlocked(struct spwr_battery_device *bat, u32 value)\n{\n\t__le32 value_le = cpu_to_le32(value);\n\n\tlockdep_assert_held(&bat->lock);\n\n\tbat->alarm = value;\n\treturn ssam_retry(ssam_bat_set_btp, bat->sdev, &value_le);\n}\n\nstatic int spwr_battery_update_bst_unlocked(struct spwr_battery_device *bat, bool cached)\n{\n\tunsigned long cache_deadline = bat->timestamp + msecs_to_jiffies(cache_time);\n\tint status;\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (cached && bat->timestamp && time_is_after_jiffies(cache_deadline))\n\t\treturn 0;\n\n\tstatus = spwr_battery_load_sta(bat);\n\tif (status)\n\t\treturn status;\n\n\tstatus = spwr_battery_load_bst(bat);\n\tif (status)\n\t\treturn status;\n\n\tbat->timestamp = jiffies;\n\treturn 0;\n}\n\nstatic int spwr_battery_update_bst(struct spwr_battery_device *bat, bool cached)\n{\n\tint status;\n\n\tmutex_lock(&bat->lock);\n\tstatus = spwr_battery_update_bst_unlocked(bat, cached);\n\tmutex_unlock(&bat->lock);\n\n\treturn status;\n}\n\nstatic int spwr_battery_update_bix_unlocked(struct spwr_battery_device *bat)\n{\n\tint status;\n\n\tlockdep_assert_held(&bat->lock);\n\n\tstatus = spwr_battery_load_sta(bat);\n\tif (status)\n\t\treturn status;\n\n\tstatus = spwr_battery_load_bix(bat);\n\tif (status)\n\t\treturn status;\n\n\tstatus = spwr_battery_load_bst(bat);\n\tif (status)\n\t\treturn status;\n\n\tif (bat->bix.revision != SPWR_BIX_REVISION)\n\t\tdev_warn(&bat->sdev->dev, \"unsupported battery revision: %u\\n\", bat->bix.revision);\n\n\tbat->timestamp = jiffies;\n\treturn 0;\n}\n\nstatic u32 sprw_battery_get_full_cap_safe(struct spwr_battery_device *bat)\n{\n\tu32 full_cap = get_unaligned_le32(&bat->bix.last_full_charge_cap);\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (full_cap == 0 || full_cap == SPWR_BATTERY_VALUE_UNKNOWN)\n\t\tfull_cap = get_unaligned_le32(&bat->bix.design_cap);\n\n\treturn full_cap;\n}\n\nstatic bool spwr_battery_is_full(struct spwr_battery_device *bat)\n{\n\tu32 state = get_unaligned_le32(&bat->bst.state);\n\tu32 full_cap = sprw_battery_get_full_cap_safe(bat);\n\tu32 remaining_cap = get_unaligned_le32(&bat->bst.remaining_cap);\n\n\tlockdep_assert_held(&bat->lock);\n\n\treturn full_cap != SPWR_BATTERY_VALUE_UNKNOWN && full_cap != 0 &&\n\t\tremaining_cap != SPWR_BATTERY_VALUE_UNKNOWN &&\n\t\tremaining_cap >= full_cap &&\n\t\tstate == 0;\n}\n\nstatic int spwr_battery_recheck_full(struct spwr_battery_device *bat)\n{\n\tbool present;\n\tu32 unit;\n\tint status;\n\n\tmutex_lock(&bat->lock);\n\tunit = get_unaligned_le32(&bat->bix.power_unit);\n\tpresent = spwr_battery_present(bat);\n\n\tstatus = spwr_battery_update_bix_unlocked(bat);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tif (!present && spwr_battery_present(bat)) {\n\t\tu32 cap_warn = get_unaligned_le32(&bat->bix.design_cap_warn);\n\n\t\tstatus = spwr_battery_set_alarm_unlocked(bat, cap_warn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\t \n\tWARN_ON(unit != get_unaligned_le32(&bat->bix.power_unit));\n\nout:\n\tmutex_unlock(&bat->lock);\n\n\tif (!status)\n\t\tpower_supply_changed(bat->psy);\n\n\treturn status;\n}\n\nstatic int spwr_battery_recheck_status(struct spwr_battery_device *bat)\n{\n\tint status;\n\n\tstatus = spwr_battery_update_bst(bat, false);\n\tif (!status)\n\t\tpower_supply_changed(bat->psy);\n\n\treturn status;\n}\n\nstatic u32 spwr_notify_bat(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct spwr_battery_device *bat = container_of(nf, struct spwr_battery_device, notif);\n\tint status;\n\n\t \n\tif (event->instance_id != bat->sdev->uid.instance)\n\t\treturn 0;\n\n\tdev_dbg(&bat->sdev->dev, \"power event (cid = %#04x, iid = %#04x, tid = %#04x)\\n\",\n\t\tevent->command_id, event->instance_id, event->target_id);\n\n\tswitch (event->command_id) {\n\tcase SAM_EVENT_CID_BAT_BIX:\n\t\tstatus = spwr_battery_recheck_full(bat);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_BST:\n\t\tstatus = spwr_battery_recheck_status(bat);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_PROT:\n\t\t \n\t\tstatus = 0;\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_DPTF:\n\t\t \n\t\tstatus = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn ssam_notifier_from_errno(status) | SSAM_NOTIF_HANDLED;\n}\n\nstatic void spwr_battery_update_bst_workfn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct spwr_battery_device *bat;\n\tint status;\n\n\tbat = container_of(dwork, struct spwr_battery_device, update_work);\n\n\tstatus = spwr_battery_update_bst(bat, false);\n\tif (status) {\n\t\tdev_err(&bat->sdev->dev, \"failed to update battery state: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tpower_supply_changed(bat->psy);\n}\n\nstatic void spwr_external_power_changed(struct power_supply *psy)\n{\n\tstruct spwr_battery_device *bat = power_supply_get_drvdata(psy);\n\n\t \n\n\tschedule_delayed_work(&bat->update_work, SPWR_AC_BAT_UPDATE_DELAY);\n}\n\n\n \n\nstatic const enum power_supply_property spwr_battery_props_chg[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic const enum power_supply_property spwr_battery_props_eng[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic int spwr_battery_prop_status(struct spwr_battery_device *bat)\n{\n\tu32 state = get_unaligned_le32(&bat->bst.state);\n\tu32 present_rate = get_unaligned_le32(&bat->bst.present_rate);\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (state & SAM_BATTERY_STATE_DISCHARGING)\n\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\n\tif (state & SAM_BATTERY_STATE_CHARGING)\n\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\n\tif (spwr_battery_is_full(bat))\n\t\treturn POWER_SUPPLY_STATUS_FULL;\n\n\tif (present_rate == 0)\n\t\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\treturn POWER_SUPPLY_STATUS_UNKNOWN;\n}\n\nstatic int spwr_battery_prop_technology(struct spwr_battery_device *bat)\n{\n\tlockdep_assert_held(&bat->lock);\n\n\tif (!strcasecmp(\"NiCd\", bat->bix.type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiCd;\n\n\tif (!strcasecmp(\"NiMH\", bat->bix.type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_NiMH;\n\n\tif (!strcasecmp(\"LION\", bat->bix.type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\n\tif (!strncasecmp(\"LI-ION\", bat->bix.type, 6))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\n\tif (!strcasecmp(\"LiP\", bat->bix.type))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LIPO;\n\n\treturn POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n}\n\nstatic int spwr_battery_prop_capacity(struct spwr_battery_device *bat)\n{\n\tu32 full_cap = sprw_battery_get_full_cap_safe(bat);\n\tu32 remaining_cap = get_unaligned_le32(&bat->bst.remaining_cap);\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (full_cap == 0 || full_cap == SPWR_BATTERY_VALUE_UNKNOWN)\n\t\treturn -ENODATA;\n\n\tif (remaining_cap == SPWR_BATTERY_VALUE_UNKNOWN)\n\t\treturn -ENODATA;\n\n\treturn remaining_cap * 100 / full_cap;\n}\n\nstatic int spwr_battery_prop_capacity_level(struct spwr_battery_device *bat)\n{\n\tu32 state = get_unaligned_le32(&bat->bst.state);\n\tu32 remaining_cap = get_unaligned_le32(&bat->bst.remaining_cap);\n\n\tlockdep_assert_held(&bat->lock);\n\n\tif (state & SAM_BATTERY_STATE_CRITICAL)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\n\tif (spwr_battery_is_full(bat))\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\n\tif (remaining_cap <= bat->alarm)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\n\treturn POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n}\n\nstatic int spwr_battery_get_property(struct power_supply *psy, enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct spwr_battery_device *bat = power_supply_get_drvdata(psy);\n\tu32 value;\n\tint status;\n\n\tmutex_lock(&bat->lock);\n\n\tstatus = spwr_battery_update_bst_unlocked(bat, true);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tif (!spwr_battery_present(bat) && psp != POWER_SUPPLY_PROP_PRESENT) {\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = spwr_battery_prop_status(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = spwr_battery_present(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = spwr_battery_prop_technology(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tvalue = get_unaligned_le32(&bat->bix.cycle_count);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tvalue = get_unaligned_le32(&bat->bix.design_voltage);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tvalue = get_unaligned_le32(&bat->bst.present_voltage);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\tvalue = get_unaligned_le32(&bat->bst.present_rate);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tvalue = get_unaligned_le32(&bat->bix.design_cap);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tvalue = get_unaligned_le32(&bat->bix.last_full_charge_cap);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tvalue = get_unaligned_le32(&bat->bst.remaining_cap);\n\t\tif (value != SPWR_BATTERY_VALUE_UNKNOWN)\n\t\t\tval->intval = value * 1000;\n\t\telse\n\t\t\tstatus = -ENODATA;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = spwr_battery_prop_capacity(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tval->intval = spwr_battery_prop_capacity_level(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bat->bix.model;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = bat->bix.oem_info;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tval->strval = bat->bix.serial;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&bat->lock);\n\treturn status;\n}\n\n\n \n\nstatic ssize_t alarm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct spwr_battery_device *bat = power_supply_get_drvdata(psy);\n\tint status;\n\n\tmutex_lock(&bat->lock);\n\tstatus = sysfs_emit(buf, \"%d\\n\", bat->alarm * 1000);\n\tmutex_unlock(&bat->lock);\n\n\treturn status;\n}\n\nstatic ssize_t alarm_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t\t\t   size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct spwr_battery_device *bat = power_supply_get_drvdata(psy);\n\tunsigned long value;\n\tint status;\n\n\tstatus = kstrtoul(buf, 0, &value);\n\tif (status)\n\t\treturn status;\n\n\tmutex_lock(&bat->lock);\n\n\tif (!spwr_battery_present(bat)) {\n\t\tmutex_unlock(&bat->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = spwr_battery_set_alarm_unlocked(bat, value / 1000);\n\tif (status) {\n\t\tmutex_unlock(&bat->lock);\n\t\treturn status;\n\t}\n\n\tmutex_unlock(&bat->lock);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(alarm);\n\nstatic struct attribute *spwr_battery_attrs[] = {\n\t&dev_attr_alarm.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(spwr_battery);\n\n\n \n\nstatic void spwr_battery_init(struct spwr_battery_device *bat, struct ssam_device *sdev,\n\t\t\t      struct ssam_event_registry registry, const char *name)\n{\n\tmutex_init(&bat->lock);\n\tstrncpy(bat->name, name, ARRAY_SIZE(bat->name) - 1);\n\n\tbat->sdev = sdev;\n\n\tbat->notif.base.priority = 1;\n\tbat->notif.base.fn = spwr_notify_bat;\n\tbat->notif.event.reg = registry;\n\tbat->notif.event.id.target_category = sdev->uid.category;\n\tbat->notif.event.id.instance = 0;\t \n\tbat->notif.event.mask = SSAM_EVENT_MASK_TARGET;\n\tbat->notif.event.flags = SSAM_EVENT_SEQUENCED;\n\n\tbat->psy_desc.name = bat->name;\n\tbat->psy_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tbat->psy_desc.get_property = spwr_battery_get_property;\n\n\tINIT_DELAYED_WORK(&bat->update_work, spwr_battery_update_bst_workfn);\n}\n\nstatic int spwr_battery_register(struct spwr_battery_device *bat)\n{\n\tstruct power_supply_config psy_cfg = {};\n\t__le32 sta;\n\tint status;\n\n\t \n\tstatus = ssam_retry(ssam_bat_get_sta, bat->sdev, &sta);\n\tif (status)\n\t\treturn status;\n\n\tif ((le32_to_cpu(sta) & SAM_BATTERY_STA_OK) != SAM_BATTERY_STA_OK)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&bat->lock);\n\n\tstatus = spwr_battery_update_bix_unlocked(bat);\n\tif (status) {\n\t\tmutex_unlock(&bat->lock);\n\t\treturn status;\n\t}\n\n\tif (spwr_battery_present(bat)) {\n\t\tu32 cap_warn = get_unaligned_le32(&bat->bix.design_cap_warn);\n\n\t\tstatus = spwr_battery_set_alarm_unlocked(bat, cap_warn);\n\t\tif (status) {\n\t\t\tmutex_unlock(&bat->lock);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tmutex_unlock(&bat->lock);\n\n\tbat->psy_desc.external_power_changed = spwr_external_power_changed;\n\n\tswitch (get_unaligned_le32(&bat->bix.power_unit)) {\n\tcase SAM_BATTERY_POWER_UNIT_mW:\n\t\tbat->psy_desc.properties = spwr_battery_props_eng;\n\t\tbat->psy_desc.num_properties = ARRAY_SIZE(spwr_battery_props_eng);\n\t\tbreak;\n\n\tcase SAM_BATTERY_POWER_UNIT_mA:\n\t\tbat->psy_desc.properties = spwr_battery_props_chg;\n\t\tbat->psy_desc.num_properties = ARRAY_SIZE(spwr_battery_props_chg);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&bat->sdev->dev, \"unsupported battery power unit: %u\\n\",\n\t\t\tget_unaligned_le32(&bat->bix.power_unit));\n\t\treturn -EINVAL;\n\t}\n\n\tpsy_cfg.drv_data = bat;\n\tpsy_cfg.attr_grp = spwr_battery_groups;\n\n\tbat->psy = devm_power_supply_register(&bat->sdev->dev, &bat->psy_desc, &psy_cfg);\n\tif (IS_ERR(bat->psy))\n\t\treturn PTR_ERR(bat->psy);\n\n\treturn ssam_device_notifier_register(bat->sdev, &bat->notif);\n}\n\n\n \n\nstatic int __maybe_unused surface_battery_resume(struct device *dev)\n{\n\treturn spwr_battery_recheck_full(dev_get_drvdata(dev));\n}\nstatic SIMPLE_DEV_PM_OPS(surface_battery_pm_ops, NULL, surface_battery_resume);\n\nstatic int surface_battery_probe(struct ssam_device *sdev)\n{\n\tconst struct spwr_psy_properties *p;\n\tstruct spwr_battery_device *bat;\n\n\tp = ssam_device_get_match_data(sdev);\n\tif (!p)\n\t\treturn -ENODEV;\n\n\tbat = devm_kzalloc(&sdev->dev, sizeof(*bat), GFP_KERNEL);\n\tif (!bat)\n\t\treturn -ENOMEM;\n\n\tspwr_battery_init(bat, sdev, p->registry, p->name);\n\tssam_device_set_drvdata(sdev, bat);\n\n\treturn spwr_battery_register(bat);\n}\n\nstatic void surface_battery_remove(struct ssam_device *sdev)\n{\n\tstruct spwr_battery_device *bat = ssam_device_get_drvdata(sdev);\n\n\tssam_device_notifier_unregister(sdev, &bat->notif);\n\tcancel_delayed_work_sync(&bat->update_work);\n}\n\nstatic const struct spwr_psy_properties spwr_psy_props_bat1 = {\n\t.name = \"BAT1\",\n\t.registry = SSAM_EVENT_REGISTRY_SAM,\n};\n\nstatic const struct spwr_psy_properties spwr_psy_props_bat2_sb3 = {\n\t.name = \"BAT2\",\n\t.registry = SSAM_EVENT_REGISTRY_KIP,\n};\n\nstatic const struct ssam_device_id surface_battery_match[] = {\n\t{ SSAM_SDEV(BAT, SAM, 0x01, 0x00), (unsigned long)&spwr_psy_props_bat1     },\n\t{ SSAM_SDEV(BAT, KIP, 0x01, 0x00), (unsigned long)&spwr_psy_props_bat2_sb3 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(ssam, surface_battery_match);\n\nstatic struct ssam_device_driver surface_battery_driver = {\n\t.probe = surface_battery_probe,\n\t.remove = surface_battery_remove,\n\t.match_table = surface_battery_match,\n\t.driver = {\n\t\t.name = \"surface_battery\",\n\t\t.pm = &surface_battery_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_ssam_device_driver(surface_battery_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Battery driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}