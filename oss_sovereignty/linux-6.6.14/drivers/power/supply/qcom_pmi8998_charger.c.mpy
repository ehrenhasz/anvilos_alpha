{
  "module_name": "qcom_pmi8998_charger.c",
  "hash_id": "3b0c9c666a2fab4f89aa678d36cc1f4f80aab269b322581c947ee013882d2f55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/qcom_pmi8998_charger.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/devm-helpers.h>\n#include <linux/iio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/of.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n \n#define BATTERY_CHARGER_STATUS_1\t\t\t0x06\n#define BVR_INITIAL_RAMP_BIT\t\t\t\tBIT(7)\n#define CC_SOFT_TERMINATE_BIT\t\t\t\tBIT(6)\n#define STEP_CHARGING_STATUS_SHIFT\t\t\t3\n#define STEP_CHARGING_STATUS_MASK\t\t\tGENMASK(5, 3)\n#define BATTERY_CHARGER_STATUS_MASK\t\t\tGENMASK(2, 0)\n\n#define BATTERY_CHARGER_STATUS_2\t\t\t0x07\n#define INPUT_CURRENT_LIMITED_BIT\t\t\tBIT(7)\n#define CHARGER_ERROR_STATUS_SFT_EXPIRE_BIT\t\tBIT(6)\n#define CHARGER_ERROR_STATUS_BAT_OV_BIT\t\t\tBIT(5)\n#define CHARGER_ERROR_STATUS_BAT_TERM_MISSING_BIT\tBIT(4)\n#define BAT_TEMP_STATUS_MASK\t\t\t\tGENMASK(3, 0)\n#define BAT_TEMP_STATUS_SOFT_LIMIT_MASK\t\t\tGENMASK(3, 2)\n#define BAT_TEMP_STATUS_HOT_SOFT_LIMIT_BIT\t\tBIT(3)\n#define BAT_TEMP_STATUS_COLD_SOFT_LIMIT_BIT\t\tBIT(2)\n#define BAT_TEMP_STATUS_TOO_HOT_BIT\t\t\tBIT(1)\n#define BAT_TEMP_STATUS_TOO_COLD_BIT\t\t\tBIT(0)\n\n#define BATTERY_CHARGER_STATUS_4\t\t\t0x0A\n#define CHARGE_CURRENT_POST_JEITA_MASK\t\t\tGENMASK(7, 0)\n\n#define BATTERY_CHARGER_STATUS_7\t\t\t0x0D\n#define ENABLE_TRICKLE_BIT\t\t\t\tBIT(7)\n#define ENABLE_PRE_CHARGING_BIT\t\t\t\tBIT(6)\n#define ENABLE_FAST_CHARGING_BIT\t\t\tBIT(5)\n#define ENABLE_FULLON_MODE_BIT\t\t\t\tBIT(4)\n#define TOO_COLD_ADC_BIT\t\t\t\tBIT(3)\n#define TOO_HOT_ADC_BIT\t\t\t\t\tBIT(2)\n#define HOT_SL_ADC_BIT\t\t\t\t\tBIT(1)\n#define COLD_SL_ADC_BIT\t\t\t\t\tBIT(0)\n\n#define CHARGING_ENABLE_CMD\t\t\t\t0x42\n#define CHARGING_ENABLE_CMD_BIT\t\t\t\tBIT(0)\n\n#define CHGR_CFG2\t\t\t\t\t0x51\n#define CHG_EN_SRC_BIT\t\t\t\t\tBIT(7)\n#define CHG_EN_POLARITY_BIT\t\t\t\tBIT(6)\n#define PRETOFAST_TRANSITION_CFG_BIT\t\t\tBIT(5)\n#define BAT_OV_ECC_BIT\t\t\t\t\tBIT(4)\n#define I_TERM_BIT\t\t\t\t\tBIT(3)\n#define AUTO_RECHG_BIT\t\t\t\t\tBIT(2)\n#define EN_ANALOG_DROP_IN_VBATT_BIT\t\t\tBIT(1)\n#define CHARGER_INHIBIT_BIT\t\t\t\tBIT(0)\n\n#define PRE_CHARGE_CURRENT_CFG\t\t\t\t0x60\n#define PRE_CHARGE_CURRENT_SETTING_MASK\t\t\tGENMASK(5, 0)\n\n#define FAST_CHARGE_CURRENT_CFG\t\t\t\t0x61\n#define FAST_CHARGE_CURRENT_SETTING_MASK\t\tGENMASK(7, 0)\n\n#define FLOAT_VOLTAGE_CFG\t\t\t\t0x70\n#define FLOAT_VOLTAGE_SETTING_MASK\t\t\tGENMASK(7, 0)\n\n#define FG_UPDATE_CFG_2_SEL\t\t\t\t0x7D\n#define SOC_LT_OTG_THRESH_SEL_BIT\t\t\tBIT(3)\n#define SOC_LT_CHG_RECHARGE_THRESH_SEL_BIT\t\tBIT(2)\n#define VBT_LT_CHG_RECHARGE_THRESH_SEL_BIT\t\tBIT(1)\n#define IBT_LT_CHG_TERM_THRESH_SEL_BIT\t\t\tBIT(0)\n\n#define JEITA_EN_CFG\t\t\t\t\t0x90\n#define JEITA_EN_HARDLIMIT_BIT\t\t\t\tBIT(4)\n#define JEITA_EN_HOT_SL_FCV_BIT\t\t\t\tBIT(3)\n#define JEITA_EN_COLD_SL_FCV_BIT\t\t\tBIT(2)\n#define JEITA_EN_HOT_SL_CCC_BIT\t\t\t\tBIT(1)\n#define JEITA_EN_COLD_SL_CCC_BIT\t\t\tBIT(0)\n\n#define INT_RT_STS\t\t\t\t\t0x310\n#define TYPE_C_CHANGE_RT_STS_BIT\t\t\tBIT(7)\n#define USBIN_ICL_CHANGE_RT_STS_BIT\t\t\tBIT(6)\n#define USBIN_SOURCE_CHANGE_RT_STS_BIT\t\t\tBIT(5)\n#define USBIN_PLUGIN_RT_STS_BIT\t\t\t\tBIT(4)\n#define USBIN_OV_RT_STS_BIT\t\t\t\tBIT(3)\n#define USBIN_UV_RT_STS_BIT\t\t\t\tBIT(2)\n#define USBIN_LT_3P6V_RT_STS_BIT\t\t\tBIT(1)\n#define USBIN_COLLAPSE_RT_STS_BIT\t\t\tBIT(0)\n\n#define OTG_CFG\t\t\t\t\t\t0x153\n#define OTG_RESERVED_MASK\t\t\t\tGENMASK(7, 6)\n#define DIS_OTG_ON_TLIM_BIT\t\t\t\tBIT(5)\n#define QUICKSTART_OTG_FASTROLESWAP_BIT\t\t\tBIT(4)\n#define INCREASE_DFP_TIME_BIT\t\t\t\tBIT(3)\n#define ENABLE_OTG_IN_DEBUG_MODE_BIT\t\t\tBIT(2)\n#define OTG_EN_SRC_CFG_BIT\t\t\t\tBIT(1)\n#define CONCURRENT_MODE_CFG_BIT\t\t\t\tBIT(0)\n\n#define OTG_ENG_OTG_CFG\t\t\t\t\t0x1C0\n#define ENG_BUCKBOOST_HALT1_8_MODE_BIT\t\t\tBIT(0)\n\n#define APSD_STATUS\t\t\t\t\t0x307\n#define APSD_STATUS_7_BIT\t\t\t\tBIT(7)\n#define HVDCP_CHECK_TIMEOUT_BIT\t\t\t\tBIT(6)\n#define SLOW_PLUGIN_TIMEOUT_BIT\t\t\t\tBIT(5)\n#define ENUMERATION_DONE_BIT\t\t\t\tBIT(4)\n#define VADP_CHANGE_DONE_AFTER_AUTH_BIT\t\t\tBIT(3)\n#define QC_AUTH_DONE_STATUS_BIT\t\t\t\tBIT(2)\n#define QC_CHARGER_BIT\t\t\t\t\tBIT(1)\n#define APSD_DTC_STATUS_DONE_BIT\t\t\tBIT(0)\n\n#define APSD_RESULT_STATUS\t\t\t\t0x308\n#define ICL_OVERRIDE_LATCH_BIT\t\t\t\tBIT(7)\n#define APSD_RESULT_STATUS_MASK\t\t\t\tGENMASK(6, 0)\n#define QC_3P0_BIT\t\t\t\t\tBIT(6)\n#define QC_2P0_BIT\t\t\t\t\tBIT(5)\n#define FLOAT_CHARGER_BIT\t\t\t\tBIT(4)\n#define DCP_CHARGER_BIT\t\t\t\t\tBIT(3)\n#define CDP_CHARGER_BIT\t\t\t\t\tBIT(2)\n#define OCP_CHARGER_BIT\t\t\t\t\tBIT(1)\n#define SDP_CHARGER_BIT\t\t\t\t\tBIT(0)\n\n#define TYPE_C_STATUS_1\t\t\t\t\t0x30B\n#define UFP_TYPEC_MASK\t\t\t\t\tGENMASK(7, 5)\n#define UFP_TYPEC_RDSTD_BIT\t\t\t\tBIT(7)\n#define UFP_TYPEC_RD1P5_BIT\t\t\t\tBIT(6)\n#define UFP_TYPEC_RD3P0_BIT\t\t\t\tBIT(5)\n#define UFP_TYPEC_FMB_255K_BIT\t\t\t\tBIT(4)\n#define UFP_TYPEC_FMB_301K_BIT\t\t\t\tBIT(3)\n#define UFP_TYPEC_FMB_523K_BIT\t\t\t\tBIT(2)\n#define UFP_TYPEC_FMB_619K_BIT\t\t\t\tBIT(1)\n#define UFP_TYPEC_OPEN_OPEN_BIT\t\t\t\tBIT(0)\n\n#define TYPE_C_STATUS_2\t\t\t\t\t0x30C\n#define DFP_RA_OPEN_BIT\t\t\t\t\tBIT(7)\n#define TIMER_STAGE_BIT\t\t\t\t\tBIT(6)\n#define EXIT_UFP_MODE_BIT\t\t\t\tBIT(5)\n#define EXIT_DFP_MODE_BIT\t\t\t\tBIT(4)\n#define DFP_TYPEC_MASK\t\t\t\t\tGENMASK(3, 0)\n#define DFP_RD_OPEN_BIT\t\t\t\t\tBIT(3)\n#define DFP_RD_RA_VCONN_BIT\t\t\t\tBIT(2)\n#define DFP_RD_RD_BIT\t\t\t\t\tBIT(1)\n#define DFP_RA_RA_BIT\t\t\t\t\tBIT(0)\n\n#define TYPE_C_STATUS_3\t\t\t\t\t0x30D\n#define ENABLE_BANDGAP_BIT\t\t\t\tBIT(7)\n#define U_USB_GND_NOVBUS_BIT\t\t\t\tBIT(6)\n#define U_USB_FLOAT_NOVBUS_BIT\t\t\t\tBIT(5)\n#define U_USB_GND_BIT\t\t\t\t\tBIT(4)\n#define U_USB_FMB1_BIT\t\t\t\t\tBIT(3)\n#define U_USB_FLOAT1_BIT\t\t\t\tBIT(2)\n#define U_USB_FMB2_BIT\t\t\t\t\tBIT(1)\n#define U_USB_FLOAT2_BIT\t\t\t\tBIT(0)\n\n#define TYPE_C_STATUS_4\t\t\t\t\t0x30E\n#define UFP_DFP_MODE_STATUS_BIT\t\t\t\tBIT(7)\n#define TYPEC_VBUS_STATUS_BIT\t\t\t\tBIT(6)\n#define TYPEC_VBUS_ERROR_STATUS_BIT\t\t\tBIT(5)\n#define TYPEC_DEBOUNCE_DONE_STATUS_BIT\t\t\tBIT(4)\n#define TYPEC_UFP_AUDIO_ADAPT_STATUS_BIT\t\tBIT(3)\n#define TYPEC_VCONN_OVERCURR_STATUS_BIT\t\t\tBIT(2)\n#define CC_ORIENTATION_BIT\t\t\t\tBIT(1)\n#define CC_ATTACHED_BIT\t\t\t\t\tBIT(0)\n\n#define TYPE_C_STATUS_5\t\t\t\t\t0x30F\n#define TRY_SOURCE_FAILED_BIT\t\t\t\tBIT(6)\n#define TRY_SINK_FAILED_BIT\t\t\t\tBIT(5)\n#define TIMER_STAGE_2_BIT\t\t\t\tBIT(4)\n#define TYPEC_LEGACY_CABLE_STATUS_BIT\t\t\tBIT(3)\n#define TYPEC_NONCOMP_LEGACY_CABLE_STATUS_BIT\t\tBIT(2)\n#define TYPEC_TRYSOURCE_DETECT_STATUS_BIT\t\tBIT(1)\n#define TYPEC_TRYSINK_DETECT_STATUS_BIT\t\t\tBIT(0)\n\n#define CMD_APSD\t\t\t\t\t0x341\n#define ICL_OVERRIDE_BIT\t\t\t\tBIT(1)\n#define APSD_RERUN_BIT\t\t\t\t\tBIT(0)\n\n#define TYPE_C_CFG\t\t\t\t\t0x358\n#define APSD_START_ON_CC_BIT\t\t\t\tBIT(7)\n#define WAIT_FOR_APSD_BIT\t\t\t\tBIT(6)\n#define FACTORY_MODE_DETECTION_EN_BIT\t\t\tBIT(5)\n#define FACTORY_MODE_ICL_3A_4A_BIT\t\t\tBIT(4)\n#define FACTORY_MODE_DIS_CHGING_CFG_BIT\t\t\tBIT(3)\n#define SUSPEND_NON_COMPLIANT_CFG_BIT\t\t\tBIT(2)\n#define VCONN_OC_CFG_BIT\t\t\t\tBIT(1)\n#define TYPE_C_OR_U_USB_BIT\t\t\t\tBIT(0)\n\n#define TYPE_C_CFG_2\t\t\t\t\t0x359\n#define TYPE_C_DFP_CURRSRC_MODE_BIT\t\t\tBIT(7)\n#define DFP_CC_1P4V_OR_1P6V_BIT\t\t\t\tBIT(6)\n#define VCONN_SOFTSTART_CFG_MASK\t\t\tGENMASK(5, 4)\n#define EN_TRY_SOURCE_MODE_BIT\t\t\t\tBIT(3)\n#define USB_FACTORY_MODE_ENABLE_BIT\t\t\tBIT(2)\n#define TYPE_C_UFP_MODE_BIT\t\t\t\tBIT(1)\n#define EN_80UA_180UA_CUR_SOURCE_BIT\t\t\tBIT(0)\n\n#define TYPE_C_CFG_3\t\t\t\t\t0x35A\n#define TVBUS_DEBOUNCE_BIT\t\t\t\tBIT(7)\n#define TYPEC_LEGACY_CABLE_INT_EN_BIT\t\t\tBIT(6)\n#define TYPEC_NONCOMPLIANT_LEGACY_CABLE_INT_EN_B\tBIT(5)\n#define TYPEC_TRYSOURCE_DETECT_INT_EN_BIT\t\tBIT(4)\n#define TYPEC_TRYSINK_DETECT_INT_EN_BIT\t\t\tBIT(3)\n#define EN_TRYSINK_MODE_BIT\t\t\t\tBIT(2)\n#define EN_LEGACY_CABLE_DETECTION_BIT\t\t\tBIT(1)\n#define ALLOW_PD_DRING_UFP_TCCDB_BIT\t\t\tBIT(0)\n\n#define USBIN_OPTIONS_1_CFG\t\t\t\t0x362\n#define CABLE_R_SEL_BIT\t\t\t\t\tBIT(7)\n#define HVDCP_AUTH_ALG_EN_CFG_BIT\t\t\tBIT(6)\n#define HVDCP_AUTONOMOUS_MODE_EN_CFG_BIT\t\tBIT(5)\n#define INPUT_PRIORITY_BIT\t\t\t\tBIT(4)\n#define AUTO_SRC_DETECT_BIT\t\t\t\tBIT(3)\n#define HVDCP_EN_BIT\t\t\t\t\tBIT(2)\n#define VADP_INCREMENT_VOLTAGE_LIMIT_BIT\t\tBIT(1)\n#define VADP_TAPER_TIMER_EN_BIT\t\t\t\tBIT(0)\n\n#define USBIN_OPTIONS_2_CFG\t\t\t\t0x363\n#define WIPWR_RST_EUD_CFG_BIT\t\t\t\tBIT(7)\n#define SWITCHER_START_CFG_BIT\t\t\t\tBIT(6)\n#define DCD_TIMEOUT_SEL_BIT\t\t\t\tBIT(5)\n#define OCD_CURRENT_SEL_BIT\t\t\t\tBIT(4)\n#define SLOW_PLUGIN_TIMER_EN_CFG_BIT\t\t\tBIT(3)\n#define FLOAT_OPTIONS_MASK\t\t\t\tGENMASK(2, 0)\n#define FLOAT_DIS_CHGING_CFG_BIT\t\t\tBIT(2)\n#define SUSPEND_FLOAT_CFG_BIT\t\t\t\tBIT(1)\n#define FORCE_FLOAT_SDP_CFG_BIT\t\t\t\tBIT(0)\n\n#define TAPER_TIMER_SEL_CFG\t\t\t\t0x364\n#define TYPEC_SPARE_CFG_BIT\t\t\t\tBIT(7)\n#define TYPEC_DRP_DFP_TIME_CFG_BIT\t\t\tBIT(5)\n#define TAPER_TIMER_SEL_MASK\t\t\t\tGENMASK(1, 0)\n\n#define USBIN_LOAD_CFG\t\t\t\t\t0x365\n#define USBIN_OV_CH_LOAD_OPTION_BIT\t\t\tBIT(7)\n#define ICL_OVERRIDE_AFTER_APSD_BIT\t\t\tBIT(4)\n\n#define USBIN_ICL_OPTIONS\t\t\t\t0x366\n#define CFG_USB3P0_SEL_BIT\t\t\t\tBIT(2)\n#define USB51_MODE_BIT\t\t\t\t\tBIT(1)\n#define USBIN_MODE_CHG_BIT\t\t\t\tBIT(0)\n\n#define TYPE_C_INTRPT_ENB_SOFTWARE_CTRL\t\t\t0x368\n#define EXIT_SNK_BASED_ON_CC_BIT\t\t\tBIT(7)\n#define VCONN_EN_ORIENTATION_BIT\t\t\tBIT(6)\n#define TYPEC_VCONN_OVERCURR_INT_EN_BIT\t\t\tBIT(5)\n#define VCONN_EN_SRC_BIT\t\t\t\tBIT(4)\n#define VCONN_EN_VALUE_BIT\t\t\t\tBIT(3)\n#define TYPEC_POWER_ROLE_CMD_MASK\t\t\tGENMASK(2, 0)\n#define UFP_EN_CMD_BIT\t\t\t\t\tBIT(2)\n#define DFP_EN_CMD_BIT\t\t\t\t\tBIT(1)\n#define TYPEC_DISABLE_CMD_BIT\t\t\t\tBIT(0)\n\n#define USBIN_CURRENT_LIMIT_CFG\t\t\t\t0x370\n#define USBIN_CURRENT_LIMIT_MASK\t\t\tGENMASK(7, 0)\n\n#define USBIN_AICL_OPTIONS_CFG\t\t\t\t0x380\n#define SUSPEND_ON_COLLAPSE_USBIN_BIT\t\t\tBIT(7)\n#define USBIN_AICL_HDC_EN_BIT\t\t\t\tBIT(6)\n#define USBIN_AICL_START_AT_MAX_BIT\t\t\tBIT(5)\n#define USBIN_AICL_RERUN_EN_BIT\t\t\t\tBIT(4)\n#define USBIN_AICL_ADC_EN_BIT\t\t\t\tBIT(3)\n#define USBIN_AICL_EN_BIT\t\t\t\tBIT(2)\n#define USBIN_HV_COLLAPSE_RESPONSE_BIT\t\t\tBIT(1)\n#define USBIN_LV_COLLAPSE_RESPONSE_BIT\t\t\tBIT(0)\n\n#define USBIN_5V_AICL_THRESHOLD_CFG\t\t\t0x381\n#define USBIN_5V_AICL_THRESHOLD_CFG_MASK\t\tGENMASK(2, 0)\n\n#define USBIN_CONT_AICL_THRESHOLD_CFG\t\t\t0x384\n#define USBIN_CONT_AICL_THRESHOLD_CFG_MASK\t\tGENMASK(5, 0)\n\n#define DC_ENG_SSUPPLY_CFG2\t\t\t\t0x4C1\n#define ENG_SSUPPLY_IVREF_OTG_SS_MASK\t\t\tGENMASK(2, 0)\n#define OTG_SS_SLOW\t\t\t\t\t0x3\n\n#define DCIN_AICL_REF_SEL_CFG\t\t\t\t0x481\n#define DCIN_CONT_AICL_THRESHOLD_CFG_MASK\t\tGENMASK(5, 0)\n\n#define WI_PWR_OPTIONS\t\t\t\t\t0x495\n#define CHG_OK_BIT\t\t\t\t\tBIT(7)\n#define WIPWR_UVLO_IRQ_OPT_BIT\t\t\t\tBIT(6)\n#define BUCK_HOLDOFF_ENABLE_BIT\t\t\t\tBIT(5)\n#define CHG_OK_HW_SW_SELECT_BIT\t\t\t\tBIT(4)\n#define WIPWR_RST_ENABLE_BIT\t\t\t\tBIT(3)\n#define DCIN_WIPWR_IRQ_SELECT_BIT\t\t\tBIT(2)\n#define AICL_SWITCH_ENABLE_BIT\t\t\t\tBIT(1)\n#define ZIN_ICL_ENABLE_BIT\t\t\t\tBIT(0)\n\n#define ICL_STATUS\t\t\t\t\t0x607\n#define INPUT_CURRENT_LIMIT_MASK\t\t\tGENMASK(7, 0)\n\n#define POWER_PATH_STATUS\t\t\t\t0x60B\n#define P_PATH_INPUT_SS_DONE_BIT\t\t\tBIT(7)\n#define P_PATH_USBIN_SUSPEND_STS_BIT\t\t\tBIT(6)\n#define P_PATH_DCIN_SUSPEND_STS_BIT\t\t\tBIT(5)\n#define P_PATH_USE_USBIN_BIT\t\t\t\tBIT(4)\n#define P_PATH_USE_DCIN_BIT\t\t\t\tBIT(3)\n#define P_PATH_POWER_PATH_MASK\t\t\t\tGENMASK(2, 1)\n#define P_PATH_VALID_INPUT_POWER_SOURCE_STS_BIT\t\tBIT(0)\n\n#define BARK_BITE_WDOG_PET\t\t\t\t0x643\n#define BARK_BITE_WDOG_PET_BIT\t\t\t\tBIT(0)\n\n#define WD_CFG\t\t\t\t\t\t0x651\n#define WATCHDOG_TRIGGER_AFP_EN_BIT\t\t\tBIT(7)\n#define BARK_WDOG_INT_EN_BIT\t\t\t\tBIT(6)\n#define BITE_WDOG_INT_EN_BIT\t\t\t\tBIT(5)\n#define SFT_AFTER_WDOG_IRQ_MASK\t\t\t\tGENMASK(4, 3)\n#define WDOG_IRQ_SFT_BIT\t\t\t\tBIT(2)\n#define WDOG_TIMER_EN_ON_PLUGIN_BIT\t\t\tBIT(1)\n#define WDOG_TIMER_EN_BIT\t\t\t\tBIT(0)\n\n#define SNARL_BARK_BITE_WD_CFG\t\t\t\t0x653\n#define BITE_WDOG_DISABLE_CHARGING_CFG_BIT\t\tBIT(7)\n#define SNARL_WDOG_TIMEOUT_MASK\t\t\t\tGENMASK(6, 4)\n#define BARK_WDOG_TIMEOUT_MASK\t\t\t\tGENMASK(3, 2)\n#define BITE_WDOG_TIMEOUT_MASK\t\t\t\tGENMASK(1, 0)\n\n#define AICL_RERUN_TIME_CFG\t\t\t\t0x661\n#define AICL_RERUN_TIME_MASK\t\t\t\tGENMASK(1, 0)\n\n#define STAT_CFG\t\t\t\t\t0x690\n#define STAT_SW_OVERRIDE_VALUE_BIT\t\t\tBIT(7)\n#define STAT_SW_OVERRIDE_CFG_BIT\t\t\tBIT(6)\n#define STAT_PARALLEL_OFF_DG_CFG_MASK\t\t\tGENMASK(5, 4)\n#define STAT_POLARITY_CFG_BIT\t\t\t\tBIT(3)\n#define STAT_PARALLEL_CFG_BIT\t\t\t\tBIT(2)\n#define STAT_FUNCTION_CFG_BIT\t\t\t\tBIT(1)\n#define STAT_IRQ_PULSING_EN_BIT\t\t\t\tBIT(0)\n\n#define SDP_CURRENT_UA\t\t\t\t\t500000\n#define CDP_CURRENT_UA\t\t\t\t\t1500000\n#define DCP_CURRENT_UA\t\t\t\t\t1500000\n#define CURRENT_MAX_UA\t\t\t\t\tDCP_CURRENT_UA\n\n \n#define CURRENT_SCALE_FACTOR\t\t\t\t25000\n \n\nenum charger_status {\n\tTRICKLE_CHARGE = 0,\n\tPRE_CHARGE,\n\tFAST_CHARGE,\n\tFULLON_CHARGE,\n\tTAPER_CHARGE,\n\tTERMINATE_CHARGE,\n\tINHIBIT_CHARGE,\n\tDISABLE_CHARGE,\n};\n\nstruct smb2_register {\n\tu16 addr;\n\tu8 mask;\n\tu8 val;\n};\n\n \nstruct smb2_chip {\n\tstruct device *dev;\n\tconst char *name;\n\tunsigned int base;\n\tstruct regmap *regmap;\n\tstruct power_supply_battery_info *batt_info;\n\n\tstruct delayed_work status_change_work;\n\tint cable_irq;\n\tbool wakeup_enabled;\n\n\tstruct iio_channel *usb_in_i_chan;\n\tstruct iio_channel *usb_in_v_chan;\n\n\tstruct power_supply *chg_psy;\n};\n\nstatic enum power_supply_property smb2_properties[] = {\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n};\n\nstatic enum power_supply_usb_type smb2_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n};\n\nstatic int smb2_get_prop_usb_online(struct smb2_chip *chip, int *val)\n{\n\tunsigned int stat;\n\tint rc;\n\n\trc = regmap_read(chip->regmap, chip->base + POWER_PATH_STATUS, &stat);\n\tif (rc < 0) {\n\t\tdev_err(chip->dev, \"Couldn't read power path status: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t*val = (stat & P_PATH_USE_USBIN_BIT) &&\n\t       (stat & P_PATH_VALID_INPUT_POWER_SOURCE_STS_BIT);\n\treturn 0;\n}\n\n \nstatic int smb2_apsd_get_charger_type(struct smb2_chip *chip, int *val)\n{\n\tunsigned int apsd_stat, stat;\n\tint usb_online = 0;\n\tint rc;\n\n\trc = smb2_get_prop_usb_online(chip, &usb_online);\n\tif (!usb_online) {\n\t\t*val = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\treturn rc;\n\t}\n\n\trc = regmap_read(chip->regmap, chip->base + APSD_STATUS, &apsd_stat);\n\tif (rc < 0) {\n\t\tdev_err(chip->dev, \"Failed to read apsd status, rc = %d\", rc);\n\t\treturn rc;\n\t}\n\tif (!(apsd_stat & APSD_DTC_STATUS_DONE_BIT)) {\n\t\tdev_dbg(chip->dev, \"Apsd not ready\");\n\t\treturn -EAGAIN;\n\t}\n\n\trc = regmap_read(chip->regmap, chip->base + APSD_RESULT_STATUS, &stat);\n\tif (rc < 0) {\n\t\tdev_err(chip->dev, \"Failed to read apsd result, rc = %d\", rc);\n\t\treturn rc;\n\t}\n\n\tstat &= APSD_RESULT_STATUS_MASK;\n\n\tif (stat & CDP_CHARGER_BIT)\n\t\t*val = POWER_SUPPLY_USB_TYPE_CDP;\n\telse if (stat & (DCP_CHARGER_BIT | OCP_CHARGER_BIT | FLOAT_CHARGER_BIT))\n\t\t*val = POWER_SUPPLY_USB_TYPE_DCP;\n\telse  \n\t\t*val = POWER_SUPPLY_USB_TYPE_SDP;\n\n\treturn 0;\n}\n\nstatic int smb2_get_prop_status(struct smb2_chip *chip, int *val)\n{\n\tunsigned char stat[2];\n\tint usb_online = 0;\n\tint rc;\n\n\trc = smb2_get_prop_usb_online(chip, &usb_online);\n\tif (!usb_online) {\n\t\t*val = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn rc;\n\t}\n\n\trc = regmap_bulk_read(chip->regmap,\n\t\t\t      chip->base + BATTERY_CHARGER_STATUS_1, &stat, 2);\n\tif (rc < 0) {\n\t\tdev_err(chip->dev, \"Failed to read charging status ret=%d\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tif (stat[1] & CHARGER_ERROR_STATUS_BAT_OV_BIT) {\n\t\t*val = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\treturn 0;\n\t}\n\n\tstat[0] = stat[0] & BATTERY_CHARGER_STATUS_MASK;\n\n\tswitch (stat[0]) {\n\tcase TRICKLE_CHARGE:\n\tcase PRE_CHARGE:\n\tcase FAST_CHARGE:\n\tcase FULLON_CHARGE:\n\tcase TAPER_CHARGE:\n\t\t*val = POWER_SUPPLY_STATUS_CHARGING;\n\t\treturn rc;\n\tcase DISABLE_CHARGE:\n\t\t*val = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\treturn rc;\n\tcase TERMINATE_CHARGE:\n\tcase INHIBIT_CHARGE:\n\t\t*val = POWER_SUPPLY_STATUS_FULL;\n\t\treturn rc;\n\tdefault:\n\t\t*val = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\treturn rc;\n\t}\n}\n\nstatic inline int smb2_get_current_limit(struct smb2_chip *chip,\n\t\t\t\t\t unsigned int *val)\n{\n\tint rc = regmap_read(chip->regmap, chip->base + ICL_STATUS, val);\n\n\tif (rc >= 0)\n\t\t*val *= CURRENT_SCALE_FACTOR;\n\treturn rc;\n}\n\nstatic int smb2_set_current_limit(struct smb2_chip *chip, unsigned int val)\n{\n\tunsigned char val_raw;\n\n\tif (val > 4800000) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Can't set current limit higher than 4800000uA\");\n\t\treturn -EINVAL;\n\t}\n\tval_raw = val / CURRENT_SCALE_FACTOR;\n\n\treturn regmap_write(chip->regmap, chip->base + USBIN_CURRENT_LIMIT_CFG,\n\t\t\t    val_raw);\n}\n\nstatic void smb2_status_change_work(struct work_struct *work)\n{\n\tunsigned int charger_type, current_ua;\n\tint usb_online = 0;\n\tint count, rc;\n\tstruct smb2_chip *chip;\n\n\tchip = container_of(work, struct smb2_chip, status_change_work.work);\n\n\tsmb2_get_prop_usb_online(chip, &usb_online);\n\tif (!usb_online)\n\t\treturn;\n\n\tfor (count = 0; count < 3; count++) {\n\t\tdev_dbg(chip->dev, \"get charger type retry %d\\n\", count);\n\t\trc = smb2_apsd_get_charger_type(chip, &charger_type);\n\t\tif (rc != -EAGAIN)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tif (rc < 0 && rc != -EAGAIN) {\n\t\tdev_err(chip->dev, \"get charger type failed: %d\\n\", rc);\n\t\treturn;\n\t}\n\n\tif (rc < 0) {\n\t\trc = regmap_update_bits(chip->regmap, chip->base + CMD_APSD,\n\t\t\t\t\tAPSD_RERUN_BIT, APSD_RERUN_BIT);\n\t\tschedule_delayed_work(&chip->status_change_work,\n\t\t\t\t      msecs_to_jiffies(1000));\n\t\tdev_dbg(chip->dev, \"get charger type failed, rerun apsd\\n\");\n\t\treturn;\n\t}\n\n\tswitch (charger_type) {\n\tcase POWER_SUPPLY_USB_TYPE_CDP:\n\t\tcurrent_ua = CDP_CURRENT_UA;\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_DCP:\n\t\tcurrent_ua = DCP_CURRENT_UA;\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_SDP:\n\tdefault:\n\t\tcurrent_ua = SDP_CURRENT_UA;\n\t\tbreak;\n\t}\n\n\tsmb2_set_current_limit(chip, current_ua);\n\tpower_supply_changed(chip->chg_psy);\n}\n\nstatic int smb2_get_iio_chan(struct smb2_chip *chip, struct iio_channel *chan,\n\t\t\t     int *val)\n{\n\tint rc;\n\tunion power_supply_propval status;\n\n\trc = power_supply_get_property(chip->chg_psy, POWER_SUPPLY_PROP_STATUS,\n\t\t\t\t       &status);\n\tif (rc < 0 || status.intval != POWER_SUPPLY_STATUS_CHARGING) {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\n\tif (IS_ERR(chan)) {\n\t\tdev_err(chip->dev, \"Failed to chan, err = %li\", PTR_ERR(chan));\n\t\treturn PTR_ERR(chan);\n\t}\n\n\treturn iio_read_channel_processed(chan, val);\n}\n\nstatic int smb2_get_prop_health(struct smb2_chip *chip, int *val)\n{\n\tint rc;\n\tunsigned int stat;\n\n\trc = regmap_read(chip->regmap, chip->base + BATTERY_CHARGER_STATUS_2,\n\t\t\t &stat);\n\tif (rc < 0) {\n\t\tdev_err(chip->dev, \"Couldn't read charger status rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tswitch (stat) {\n\tcase CHARGER_ERROR_STATUS_BAT_OV_BIT:\n\t\t*val = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\treturn 0;\n\tcase BAT_TEMP_STATUS_TOO_COLD_BIT:\n\t\t*val = POWER_SUPPLY_HEALTH_COLD;\n\t\treturn 0;\n\tcase BAT_TEMP_STATUS_TOO_HOT_BIT:\n\t\t*val = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\treturn 0;\n\tcase BAT_TEMP_STATUS_COLD_SOFT_LIMIT_BIT:\n\t\t*val = POWER_SUPPLY_HEALTH_COOL;\n\t\treturn 0;\n\tcase BAT_TEMP_STATUS_HOT_SOFT_LIMIT_BIT:\n\t\t*val = POWER_SUPPLY_HEALTH_WARM;\n\t\treturn 0;\n\tdefault:\n\t\t*val = POWER_SUPPLY_HEALTH_GOOD;\n\t\treturn 0;\n\t}\n}\n\nstatic int smb2_get_property(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     union power_supply_propval *val)\n{\n\tstruct smb2_chip *chip = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = \"Qualcomm\";\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = chip->name;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn smb2_get_current_limit(chip, &val->intval);\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn smb2_get_iio_chan(chip, chip->usb_in_i_chan,\n\t\t\t\t\t &val->intval);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\treturn smb2_get_iio_chan(chip, chip->usb_in_v_chan,\n\t\t\t\t\t &val->intval);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn smb2_get_prop_usb_online(chip, &val->intval);\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn smb2_get_prop_status(chip, &val->intval);\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\treturn smb2_get_prop_health(chip, &val->intval);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn smb2_apsd_get_charger_type(chip, &val->intval);\n\tdefault:\n\t\tdev_err(chip->dev, \"invalid property: %d\\n\", psp);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int smb2_set_property(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     const union power_supply_propval *val)\n{\n\tstruct smb2_chip *chip = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn smb2_set_current_limit(chip, val->intval);\n\tdefault:\n\t\tdev_err(chip->dev, \"No setter for property: %d\\n\", psp);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int smb2_property_is_writable(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic irqreturn_t smb2_handle_batt_overvoltage(int irq, void *data)\n{\n\tstruct smb2_chip *chip = data;\n\tunsigned int status;\n\n\tregmap_read(chip->regmap, chip->base + BATTERY_CHARGER_STATUS_2,\n\t\t    &status);\n\n\tif (status & CHARGER_ERROR_STATUS_BAT_OV_BIT) {\n\t\t \n\t\tdev_err(chip->dev, \"battery overvoltage detected\\n\");\n\t\tpower_supply_changed(chip->chg_psy);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smb2_handle_usb_plugin(int irq, void *data)\n{\n\tstruct smb2_chip *chip = data;\n\n\tpower_supply_changed(chip->chg_psy);\n\n\tschedule_delayed_work(&chip->status_change_work,\n\t\t\t      msecs_to_jiffies(1500));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smb2_handle_usb_icl_change(int irq, void *data)\n{\n\tstruct smb2_chip *chip = data;\n\n\tpower_supply_changed(chip->chg_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smb2_handle_wdog_bark(int irq, void *data)\n{\n\tstruct smb2_chip *chip = data;\n\tint rc;\n\n\tpower_supply_changed(chip->chg_psy);\n\n\trc = regmap_write(chip->regmap, BARK_BITE_WDOG_PET,\n\t\t\t  BARK_BITE_WDOG_PET_BIT);\n\tif (rc < 0)\n\t\tdev_err(chip->dev, \"Couldn't pet the dog rc=%d\\n\", rc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct power_supply_desc smb2_psy_desc = {\n\t.name = \"pmi8998_charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.usb_types = smb2_usb_types,\n\t.num_usb_types = ARRAY_SIZE(smb2_usb_types),\n\t.properties = smb2_properties,\n\t.num_properties = ARRAY_SIZE(smb2_properties),\n\t.get_property = smb2_get_property,\n\t.set_property = smb2_set_property,\n\t.property_is_writeable = smb2_property_is_writable,\n};\n\n \nstatic const struct smb2_register smb2_init_seq[] = {\n\t{ .addr = AICL_RERUN_TIME_CFG, .mask = AICL_RERUN_TIME_MASK, .val = 0 },\n\t \n\t{ .addr = TYPE_C_INTRPT_ENB_SOFTWARE_CTRL,\n\t  .mask = TYPEC_POWER_ROLE_CMD_MASK | VCONN_EN_SRC_BIT |\n\t\t  VCONN_EN_VALUE_BIT,\n\t  .val = VCONN_EN_SRC_BIT },\n\t \n\t{ .addr = TYPE_C_CFG,\n\t  .mask = FACTORY_MODE_DETECTION_EN_BIT | VCONN_OC_CFG_BIT,\n\t  .val = 0 },\n\t \n\t{ .addr = OTG_CFG, .mask = OTG_EN_SRC_CFG_BIT, .val = 0 },\n\t \n\t{ .addr = FG_UPDATE_CFG_2_SEL,\n\t  .mask = SOC_LT_CHG_RECHARGE_THRESH_SEL_BIT |\n\t\t  VBT_LT_CHG_RECHARGE_THRESH_SEL_BIT,\n\t  .val = VBT_LT_CHG_RECHARGE_THRESH_SEL_BIT },\n\t \n\t{ .addr = USBIN_OPTIONS_1_CFG, .mask = HVDCP_EN_BIT, .val = 0 },\n\t{ .addr = CHARGING_ENABLE_CMD,\n\t  .mask = CHARGING_ENABLE_CMD_BIT,\n\t  .val = CHARGING_ENABLE_CMD_BIT },\n\t \n\t{ .addr = CHGR_CFG2,\n\t  .mask = CHG_EN_SRC_BIT | CHG_EN_POLARITY_BIT |\n\t\t  PRETOFAST_TRANSITION_CFG_BIT | BAT_OV_ECC_BIT | I_TERM_BIT |\n\t\t  AUTO_RECHG_BIT | EN_ANALOG_DROP_IN_VBATT_BIT |\n\t\t  CHARGER_INHIBIT_BIT,\n\t  .val = CHARGER_INHIBIT_BIT },\n\t \n\t{ .addr = STAT_CFG,\n\t  .mask = STAT_SW_OVERRIDE_CFG_BIT,\n\t  .val = STAT_SW_OVERRIDE_CFG_BIT },\n\t \n\t{ .addr = USBIN_ICL_OPTIONS,\n\t  .mask = USB51_MODE_BIT | USBIN_MODE_CHG_BIT,\n\t  .val = USB51_MODE_BIT },\n\t \n\t{ .addr = SNARL_BARK_BITE_WD_CFG, .mask = 0xff, .val = 0 },\n\t{ .addr = WD_CFG,\n\t  .mask = WATCHDOG_TRIGGER_AFP_EN_BIT | WDOG_TIMER_EN_ON_PLUGIN_BIT |\n\t\t  BARK_WDOG_INT_EN_BIT,\n\t  .val = 0 },\n\t \n\t{ .addr = USBIN_5V_AICL_THRESHOLD_CFG,\n\t  .mask = USBIN_5V_AICL_THRESHOLD_CFG_MASK,\n\t  .val = 0x3 },\n\t{ .addr = USBIN_CONT_AICL_THRESHOLD_CFG,\n\t  .mask = USBIN_CONT_AICL_THRESHOLD_CFG_MASK,\n\t  .val = 0x3 },\n\t \n\t{ .addr = USBIN_AICL_OPTIONS_CFG,\n\t  .mask = USBIN_AICL_START_AT_MAX_BIT | USBIN_AICL_ADC_EN_BIT |\n\t\t  USBIN_AICL_EN_BIT | SUSPEND_ON_COLLAPSE_USBIN_BIT |\n\t\t  USBIN_HV_COLLAPSE_RESPONSE_BIT |\n\t\t  USBIN_LV_COLLAPSE_RESPONSE_BIT,\n\t  .val = USBIN_HV_COLLAPSE_RESPONSE_BIT |\n\t\t USBIN_LV_COLLAPSE_RESPONSE_BIT | USBIN_AICL_EN_BIT },\n\t \n\t{ .addr = PRE_CHARGE_CURRENT_CFG,\n\t  .mask = PRE_CHARGE_CURRENT_SETTING_MASK,\n\t  .val = 500000 / CURRENT_SCALE_FACTOR },\n\t \n\t{ .addr = FAST_CHARGE_CURRENT_CFG,\n\t  .mask = FAST_CHARGE_CURRENT_SETTING_MASK,\n\t  .val = 1000000 / CURRENT_SCALE_FACTOR },\n};\n\nstatic int smb2_init_hw(struct smb2_chip *chip)\n{\n\tint rc, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(smb2_init_seq); i++) {\n\t\tdev_dbg(chip->dev, \"%d: Writing 0x%02x to 0x%02x\\n\", i,\n\t\t\tsmb2_init_seq[i].val, smb2_init_seq[i].addr);\n\t\trc = regmap_update_bits(chip->regmap,\n\t\t\t\t\tchip->base + smb2_init_seq[i].addr,\n\t\t\t\t\tsmb2_init_seq[i].mask,\n\t\t\t\t\tsmb2_init_seq[i].val);\n\t\tif (rc < 0)\n\t\t\treturn dev_err_probe(chip->dev, rc,\n\t\t\t\t\t     \"%s: init command %d failed\\n\",\n\t\t\t\t\t     __func__, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_init_irq(struct smb2_chip *chip, int *irq, const char *name,\n\t\t\t irqreturn_t (*handler)(int irq, void *data))\n{\n\tint irqnum;\n\tint rc;\n\n\tirqnum = platform_get_irq_byname(to_platform_device(chip->dev), name);\n\tif (irqnum < 0)\n\t\treturn dev_err_probe(chip->dev, irqnum,\n\t\t\t\t     \"Couldn't get irq %s byname\\n\", name);\n\n\trc = devm_request_threaded_irq(chip->dev, irqnum, NULL, handler,\n\t\t\t\t       IRQF_ONESHOT, name, chip);\n\tif (rc < 0)\n\t\treturn dev_err_probe(chip->dev, rc, \"Couldn't request irq %s\\n\",\n\t\t\t\t     name);\n\n\tif (irq)\n\t\t*irq = irqnum;\n\n\treturn 0;\n}\n\nstatic int smb2_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config supply_config = {};\n\tstruct power_supply_desc *desc;\n\tstruct smb2_chip *chip;\n\tint rc, irq;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &pdev->dev;\n\tchip->name = pdev->name;\n\n\tchip->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chip->regmap)\n\t\treturn dev_err_probe(chip->dev, -ENODEV,\n\t\t\t\t     \"failed to locate the regmap\\n\");\n\n\trc = device_property_read_u32(chip->dev, \"reg\", &chip->base);\n\tif (rc < 0)\n\t\treturn dev_err_probe(chip->dev, rc,\n\t\t\t\t     \"Couldn't read base address\\n\");\n\n\tchip->usb_in_v_chan = devm_iio_channel_get(chip->dev, \"usbin_v\");\n\tif (IS_ERR(chip->usb_in_v_chan))\n\t\treturn dev_err_probe(chip->dev, PTR_ERR(chip->usb_in_v_chan),\n\t\t\t\t     \"Couldn't get usbin_v IIO channel\\n\");\n\n\tchip->usb_in_i_chan = devm_iio_channel_get(chip->dev, \"usbin_i\");\n\tif (IS_ERR(chip->usb_in_i_chan)) {\n\t\treturn dev_err_probe(chip->dev, PTR_ERR(chip->usb_in_i_chan),\n\t\t\t\t     \"Couldn't get usbin_i IIO channel\\n\");\n\t}\n\n\trc = smb2_init_hw(chip);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsupply_config.drv_data = chip;\n\tsupply_config.of_node = pdev->dev.of_node;\n\n\tdesc = devm_kzalloc(chip->dev, sizeof(smb2_psy_desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\tmemcpy(desc, &smb2_psy_desc, sizeof(smb2_psy_desc));\n\tdesc->name =\n\t\tdevm_kasprintf(chip->dev, GFP_KERNEL, \"%s-charger\",\n\t\t\t       (const char *)device_get_match_data(chip->dev));\n\tif (!desc->name)\n\t\treturn -ENOMEM;\n\n\tchip->chg_psy =\n\t\tdevm_power_supply_register(chip->dev, desc, &supply_config);\n\tif (IS_ERR(chip->chg_psy))\n\t\treturn dev_err_probe(chip->dev, PTR_ERR(chip->chg_psy),\n\t\t\t\t     \"failed to register power supply\\n\");\n\n\trc = power_supply_get_battery_info(chip->chg_psy, &chip->batt_info);\n\tif (rc)\n\t\treturn dev_err_probe(chip->dev, rc,\n\t\t\t\t     \"Failed to get battery info\\n\");\n\n\trc = devm_delayed_work_autocancel(chip->dev, &chip->status_change_work,\n\t\t\t\t\t  smb2_status_change_work);\n\tif (rc)\n\t\treturn dev_err_probe(chip->dev, rc,\n\t\t\t\t     \"Failed to init status change work\\n\");\n\n\trc = (chip->batt_info->voltage_max_design_uv - 3487500) / 7500 + 1;\n\trc = regmap_update_bits(chip->regmap, chip->base + FLOAT_VOLTAGE_CFG,\n\t\t\t\tFLOAT_VOLTAGE_SETTING_MASK, rc);\n\tif (rc < 0)\n\t\treturn dev_err_probe(chip->dev, rc, \"Couldn't set vbat max\\n\");\n\n\trc = smb2_init_irq(chip, &irq, \"bat-ov\", smb2_handle_batt_overvoltage);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = smb2_init_irq(chip, &chip->cable_irq, \"usb-plugin\",\n\t\t\t   smb2_handle_usb_plugin);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = smb2_init_irq(chip, &irq, \"usbin-icl-change\",\n\t\t\t   smb2_handle_usb_icl_change);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = smb2_init_irq(chip, &irq, \"wdog-bark\", smb2_handle_wdog_bark);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = dev_pm_set_wake_irq(chip->dev, chip->cable_irq);\n\tif (rc < 0)\n\t\treturn dev_err_probe(chip->dev, rc, \"Couldn't set wake irq\\n\");\n\n\tplatform_set_drvdata(pdev, chip);\n\n\t \n\tschedule_delayed_work(&chip->status_change_work, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id smb2_match_id_table[] = {\n\t{ .compatible = \"qcom,pmi8998-charger\", .data = \"pmi8998\" },\n\t{ .compatible = \"qcom,pm660-charger\", .data = \"pm660\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, smb2_match_id_table);\n\nstatic struct platform_driver qcom_spmi_smb2 = {\n\t.probe = smb2_probe,\n\t.driver = {\n\t\t.name = \"qcom-pmi8998/pm660-charger\",\n\t\t.of_match_table = smb2_match_id_table,\n\t\t},\n};\n\nmodule_platform_driver(qcom_spmi_smb2);\n\nMODULE_AUTHOR(\"Caleb Connolly <caleb.connolly@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm SMB2 Charger Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}