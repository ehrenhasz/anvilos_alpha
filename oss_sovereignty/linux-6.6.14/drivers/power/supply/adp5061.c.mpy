{
  "module_name": "adp5061.c",
  "hash_id": "4db1310f9d359e2697720c6621627b7534c605f341d6318cd3899f78648cdebf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/adp5061.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/power_supply.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define ADP5061_ID\t\t\t0x00\n#define ADP5061_REV\t\t\t0x01\n#define ADP5061_VINX_SET\t\t0x02\n#define ADP5061_TERM_SET\t\t0x03\n#define ADP5061_CHG_CURR\t\t0x04\n#define ADP5061_VOLTAGE_TH\t\t0x05\n#define ADP5061_TIMER_SET\t\t0x06\n#define ADP5061_FUNC_SET_1\t\t0x07\n#define ADP5061_FUNC_SET_2\t\t0x08\n#define ADP5061_INT_EN\t\t\t0x09\n#define ADP5061_INT_ACT\t\t\t0x0A\n#define ADP5061_CHG_STATUS_1\t\t0x0B\n#define ADP5061_CHG_STATUS_2\t\t0x0C\n#define ADP5061_FAULT\t\t\t0x0D\n#define ADP5061_BATTERY_SHORT\t\t0x10\n#define ADP5061_IEND\t\t\t0x11\n\n \n#define ADP5061_VINX_SET_ILIM_MSK\t\tGENMASK(3, 0)\n#define ADP5061_VINX_SET_ILIM_MODE(x)\t\t(((x) & 0x0F) << 0)\n\n \n#define ADP5061_TERM_SET_VTRM_MSK\t\tGENMASK(7, 2)\n#define ADP5061_TERM_SET_VTRM_MODE(x)\t\t(((x) & 0x3F) << 2)\n#define ADP5061_TERM_SET_CHG_VLIM_MSK\t\tGENMASK(1, 0)\n#define ADP5061_TERM_SET_CHG_VLIM_MODE(x)\t(((x) & 0x03) << 0)\n\n \n#define ADP5061_CHG_CURR_ICHG_MSK\t\tGENMASK(6, 2)\n#define ADP5061_CHG_CURR_ICHG_MODE(x)\t\t(((x) & 0x1F) << 2)\n#define ADP5061_CHG_CURR_ITRK_DEAD_MSK\t\tGENMASK(1, 0)\n#define ADP5061_CHG_CURR_ITRK_DEAD_MODE(x)\t(((x) & 0x03) << 0)\n\n \n#define ADP5061_VOLTAGE_TH_DIS_RCH_MSK\t\tBIT(7)\n#define ADP5061_VOLTAGE_TH_DIS_RCH_MODE(x)\t(((x) & 0x01) << 7)\n#define ADP5061_VOLTAGE_TH_VRCH_MSK\t\tGENMASK(6, 5)\n#define ADP5061_VOLTAGE_TH_VRCH_MODE(x)\t\t(((x) & 0x03) << 5)\n#define ADP5061_VOLTAGE_TH_VTRK_DEAD_MSK\tGENMASK(4, 3)\n#define ADP5061_VOLTAGE_TH_VTRK_DEAD_MODE(x)\t(((x) & 0x03) << 3)\n#define ADP5061_VOLTAGE_TH_VWEAK_MSK\t\tGENMASK(2, 0)\n#define ADP5061_VOLTAGE_TH_VWEAK_MODE(x)\t(((x) & 0x07) << 0)\n\n \n#define ADP5061_CHG_STATUS_1_VIN_OV(x)\t\t(((x) >> 7) & 0x1)\n#define ADP5061_CHG_STATUS_1_VIN_OK(x)\t\t(((x) >> 6) & 0x1)\n#define ADP5061_CHG_STATUS_1_VIN_ILIM(x)\t(((x) >> 5) & 0x1)\n#define ADP5061_CHG_STATUS_1_THERM_LIM(x)\t(((x) >> 4) & 0x1)\n#define ADP5061_CHG_STATUS_1_CHDONE(x)\t\t(((x) >> 3) & 0x1)\n#define ADP5061_CHG_STATUS_1_CHG_STATUS(x)\t(((x) >> 0) & 0x7)\n\n \n#define ADP5061_CHG_STATUS_2_THR_STATUS(x)\t(((x) >> 5) & 0x7)\n#define ADP5061_CHG_STATUS_2_RCH_LIM_INFO(x)\t(((x) >> 3) & 0x1)\n#define ADP5061_CHG_STATUS_2_BAT_STATUS(x)\t(((x) >> 0) & 0x7)\n\n \n#define ADP5061_IEND_IEND_MSK\t\t\tGENMASK(7, 5)\n#define ADP5061_IEND_IEND_MODE(x)\t\t(((x) & 0x07) << 5)\n\n#define ADP5061_NO_BATTERY\t0x01\n#define ADP5061_ICHG_MAX\t1300 \n\nenum adp5061_chg_status {\n\tADP5061_CHG_OFF,\n\tADP5061_CHG_TRICKLE,\n\tADP5061_CHG_FAST_CC,\n\tADP5061_CHG_FAST_CV,\n\tADP5061_CHG_COMPLETE,\n\tADP5061_CHG_LDO_MODE,\n\tADP5061_CHG_TIMER_EXP,\n\tADP5061_CHG_BAT_DET,\n};\n\nstatic const int adp5061_chg_type[4] = {\n\t[ADP5061_CHG_OFF] = POWER_SUPPLY_CHARGE_TYPE_NONE,\n\t[ADP5061_CHG_TRICKLE] = POWER_SUPPLY_CHARGE_TYPE_TRICKLE,\n\t[ADP5061_CHG_FAST_CC] = POWER_SUPPLY_CHARGE_TYPE_FAST,\n\t[ADP5061_CHG_FAST_CV] = POWER_SUPPLY_CHARGE_TYPE_FAST,\n};\n\nstatic const int adp5061_vweak_th[8] = {\n\t2700, 2800, 2900, 3000, 3100, 3200, 3300, 3400,\n};\n\nstatic const int adp5061_prechg_current[4] = {\n\t5, 10, 20, 80,\n};\n\nstatic const int adp5061_vmin[4] = {\n\t2000, 2500, 2600, 2900,\n};\n\nstatic const int adp5061_const_chg_vmax[4] = {\n\t3200, 3400, 3700, 3800,\n};\n\nstatic const int adp5061_const_ichg[24] = {\n\t50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650,\n\t700, 750, 800, 850, 900, 950, 1000, 1050, 1100, 1200, 1300,\n};\n\nstatic const int adp5061_vmax[36] = {\n\t3800, 3820, 3840, 3860, 3880, 3900, 3920, 3940, 3960, 3980,\n\t4000, 4020, 4040, 4060, 4080, 4100, 4120, 4140, 4160, 4180,\n\t4200, 4220, 4240, 4260, 4280, 4300, 4320, 4340, 4360, 4380,\n\t4400, 4420, 4440, 4460, 4480, 4500,\n};\n\nstatic const int adp5061_in_current_lim[16] = {\n\t100, 150, 200, 250, 300, 400, 500, 600, 700,\n\t800, 900, 1000, 1200, 1500, 1800, 2100,\n};\n\nstatic const int adp5061_iend[8] = {\n\t12500, 32500, 52500, 72500, 92500, 117500, 142500, 170000,\n};\n\nstruct adp5061_state {\n\tstruct i2c_client\t\t*client;\n\tstruct regmap\t\t\t*regmap;\n\tstruct power_supply\t\t*psy;\n};\n\nstatic int adp5061_get_array_index(const int *array, u8 size, int val)\n{\n\tint i;\n\n\tfor (i = 1; i < size; i++) {\n\t\tif (val < array[i])\n\t\t\tbreak;\n\t}\n\n\treturn i-1;\n}\n\nstatic int adp5061_get_status(struct adp5061_state *st,\n\t\t\t      u8 *status1, u8 *status2)\n{\n\tu8 buf[2];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(st->regmap, ADP5061_CHG_STATUS_1,\n\t\t\t       &buf[0], 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*status1 = buf[0];\n\t*status2 = buf[1];\n\n\treturn ret;\n}\n\nstatic int adp5061_get_input_current_limit(struct adp5061_state *st,\n\t\tunion power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint mode, ret;\n\n\tret = regmap_read(st->regmap, ADP5061_VINX_SET, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode = ADP5061_VINX_SET_ILIM_MODE(regval);\n\tval->intval = adp5061_in_current_lim[mode] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_set_input_current_limit(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\t \n\tval /= 1000;\n\tindex = adp5061_get_array_index(adp5061_in_current_lim,\n\t\t\t\t\tARRAY_SIZE(adp5061_in_current_lim),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_VINX_SET,\n\t\t\t\t  ADP5061_VINX_SET_ILIM_MSK,\n\t\t\t\t  ADP5061_VINX_SET_ILIM_MODE(index));\n}\n\nstatic int adp5061_set_min_voltage(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\t \n\tval /= 1000;\n\tindex = adp5061_get_array_index(adp5061_vmin,\n\t\t\t\t\tARRAY_SIZE(adp5061_vmin),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_VOLTAGE_TH,\n\t\t\t\t  ADP5061_VOLTAGE_TH_VTRK_DEAD_MSK,\n\t\t\t\t  ADP5061_VOLTAGE_TH_VTRK_DEAD_MODE(index));\n}\n\nstatic int adp5061_get_min_voltage(struct adp5061_state *st,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_VOLTAGE_TH, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ((regval & ADP5061_VOLTAGE_TH_VTRK_DEAD_MSK) >> 3);\n\tval->intval = adp5061_vmin[regval] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_get_chg_volt_lim(struct adp5061_state *st,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint mode, ret;\n\n\tret = regmap_read(st->regmap, ADP5061_TERM_SET, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode = ADP5061_TERM_SET_CHG_VLIM_MODE(regval);\n\tval->intval = adp5061_const_chg_vmax[mode] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_get_max_voltage(struct adp5061_state *st,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_TERM_SET, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ((regval & ADP5061_TERM_SET_VTRM_MSK) >> 2) - 0x0F;\n\tif (regval >= ARRAY_SIZE(adp5061_vmax))\n\t\tregval = ARRAY_SIZE(adp5061_vmax) - 1;\n\n\tval->intval = adp5061_vmax[regval] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_set_max_voltage(struct adp5061_state *st, int val)\n{\n\tint vmax_index;\n\n\t \n\tval /= 1000;\n\tif (val > 4500)\n\t\tval = 4500;\n\n\tvmax_index = adp5061_get_array_index(adp5061_vmax,\n\t\t\t\t\t     ARRAY_SIZE(adp5061_vmax), val);\n\tif (vmax_index < 0)\n\t\treturn vmax_index;\n\n\tvmax_index += 0x0F;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_TERM_SET,\n\t\t\t\t  ADP5061_TERM_SET_VTRM_MSK,\n\t\t\t\t  ADP5061_TERM_SET_VTRM_MODE(vmax_index));\n}\n\nstatic int adp5061_set_const_chg_vmax(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\t \n\tval /= 1000;\n\tindex = adp5061_get_array_index(adp5061_const_chg_vmax,\n\t\t\t\t\tARRAY_SIZE(adp5061_const_chg_vmax),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_TERM_SET,\n\t\t\t\t  ADP5061_TERM_SET_CHG_VLIM_MSK,\n\t\t\t\t  ADP5061_TERM_SET_CHG_VLIM_MODE(index));\n}\n\nstatic int adp5061_set_const_chg_current(struct adp5061_state *st, int val)\n{\n\n\tint index;\n\n\t \n\tval /= 1000;\n\tif (val > ADP5061_ICHG_MAX)\n\t\tval = ADP5061_ICHG_MAX;\n\n\tindex = adp5061_get_array_index(adp5061_const_ichg,\n\t\t\t\t\tARRAY_SIZE(adp5061_const_ichg),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_CHG_CURR,\n\t\t\t\t  ADP5061_CHG_CURR_ICHG_MSK,\n\t\t\t\t  ADP5061_CHG_CURR_ICHG_MODE(index));\n}\n\nstatic int adp5061_get_const_chg_current(struct adp5061_state *st,\n\t\tunion power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_CHG_CURR, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = ((regval & ADP5061_CHG_CURR_ICHG_MSK) >> 2);\n\tif (regval >= ARRAY_SIZE(adp5061_const_ichg))\n\t\tregval = ARRAY_SIZE(adp5061_const_ichg) - 1;\n\n\tval->intval = adp5061_const_ichg[regval] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_get_prechg_current(struct adp5061_state *st,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_CHG_CURR, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval &= ADP5061_CHG_CURR_ITRK_DEAD_MSK;\n\tval->intval = adp5061_prechg_current[regval] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_set_prechg_current(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\t \n\tval /= 1000;\n\tindex = adp5061_get_array_index(adp5061_prechg_current,\n\t\t\t\t\tARRAY_SIZE(adp5061_prechg_current),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_CHG_CURR,\n\t\t\t\t  ADP5061_CHG_CURR_ITRK_DEAD_MSK,\n\t\t\t\t  ADP5061_CHG_CURR_ITRK_DEAD_MODE(index));\n}\n\nstatic int adp5061_get_vweak_th(struct adp5061_state *st,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_VOLTAGE_TH, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval &= ADP5061_VOLTAGE_TH_VWEAK_MSK;\n\tval->intval = adp5061_vweak_th[regval] * 1000;\n\n\treturn ret;\n}\n\nstatic int adp5061_set_vweak_th(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\t \n\tval /= 1000;\n\tindex = adp5061_get_array_index(adp5061_vweak_th,\n\t\t\t\t\tARRAY_SIZE(adp5061_vweak_th),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_VOLTAGE_TH,\n\t\t\t\t  ADP5061_VOLTAGE_TH_VWEAK_MSK,\n\t\t\t\t  ADP5061_VOLTAGE_TH_VWEAK_MODE(index));\n}\n\nstatic int adp5061_get_chg_type(struct adp5061_state *st,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tu8 status1, status2;\n\tint chg_type, ret;\n\n\tret = adp5061_get_status(st, &status1, &status2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchg_type = ADP5061_CHG_STATUS_1_CHG_STATUS(status1);\n\tif (chg_type >= ARRAY_SIZE(adp5061_chg_type))\n\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\telse\n\t\tval->intval = adp5061_chg_type[chg_type];\n\n\treturn ret;\n}\n\nstatic int adp5061_get_charger_status(struct adp5061_state *st,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tu8 status1, status2;\n\tint ret;\n\n\tret = adp5061_get_status(st, &status1, &status2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ADP5061_CHG_STATUS_1_CHG_STATUS(status1)) {\n\tcase ADP5061_CHG_OFF:\n\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase ADP5061_CHG_TRICKLE:\n\tcase ADP5061_CHG_FAST_CC:\n\tcase ADP5061_CHG_FAST_CV:\n\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase ADP5061_CHG_COMPLETE:\n\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase ADP5061_CHG_TIMER_EXP:\n\t\t \n\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t}\n\n\treturn ret;\n}\n\nstatic int adp5061_get_battery_status(struct adp5061_state *st,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tu8 status1, status2;\n\tint ret;\n\n\tret = adp5061_get_status(st, &status1, &status2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ADP5061_CHG_STATUS_2_BAT_STATUS(status2)) {\n\tcase 0x0:  \n\tcase 0x1:  \n\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\tbreak;\n\tcase 0x2:  \n\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\tbreak;\n\tcase 0x3:  \n\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\tbreak;\n\tcase 0x4:  \n\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int adp5061_get_termination_current(struct adp5061_state *st,\n\t\t\t\t\t   union power_supply_propval *val)\n{\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(st->regmap, ADP5061_IEND, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregval = (regval & ADP5061_IEND_IEND_MSK) >> 5;\n\tval->intval = adp5061_iend[regval];\n\n\treturn ret;\n}\n\nstatic int adp5061_set_termination_current(struct adp5061_state *st, int val)\n{\n\tint index;\n\n\tindex = adp5061_get_array_index(adp5061_iend,\n\t\t\t\t\tARRAY_SIZE(adp5061_iend),\n\t\t\t\t\tval);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn regmap_update_bits(st->regmap, ADP5061_IEND,\n\t\t\t\t  ADP5061_IEND_IEND_MSK,\n\t\t\t\t  ADP5061_IEND_IEND_MODE(index));\n}\n\nstatic int adp5061_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct adp5061_state *st = power_supply_get_drvdata(psy);\n\tu8 status1, status2;\n\tint mode, ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tret = adp5061_get_status(st, &status1, &status2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmode = ADP5061_CHG_STATUS_2_BAT_STATUS(status2);\n\t\tif (mode == ADP5061_NO_BATTERY)\n\t\t\tval->intval = 0;\n\t\telse\n\t\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\treturn adp5061_get_chg_type(st, val);\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\t \n\t\treturn adp5061_get_input_current_limit(st, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\t \n\t\treturn adp5061_get_max_voltage(st, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\t \n\t\treturn adp5061_get_min_voltage(st, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\t \n\t\treturn adp5061_get_chg_volt_lim(st, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\t \n\t\treturn adp5061_get_const_chg_current(st, val);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\t \n\t\treturn adp5061_get_prechg_current(st, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\t \n\t\treturn adp5061_get_vweak_th(st, val);\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\t \n\t\treturn adp5061_get_charger_status(st, val);\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\t \n\t\treturn adp5061_get_battery_status(st, val);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\t \n\t\treturn adp5061_get_termination_current(st, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int adp5061_set_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct adp5061_state *st = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn adp5061_set_input_current_limit(st, val->intval);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\treturn adp5061_set_max_voltage(st, val->intval);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\treturn adp5061_set_min_voltage(st, val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\treturn adp5061_set_const_chg_vmax(st, val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn adp5061_set_const_chg_current(st, val->intval);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn adp5061_set_prechg_current(st, val->intval);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\treturn adp5061_set_vweak_th(st, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn adp5061_set_termination_current(st, val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int adp5061_prop_writeable(struct power_supply *psy,\n\t\t\t\t  enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum power_supply_property adp5061_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n};\n\nstatic const struct regmap_config adp5061_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct power_supply_desc adp5061_desc = {\n\t.name\t\t\t= \"adp5061\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.get_property\t\t= adp5061_get_property,\n\t.set_property\t\t= adp5061_set_property,\n\t.property_is_writeable\t= adp5061_prop_writeable,\n\t.properties\t\t= adp5061_props,\n\t.num_properties\t\t= ARRAY_SIZE(adp5061_props),\n};\n\nstatic int adp5061_probe(struct i2c_client *client)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct adp5061_state *st;\n\n\tst = devm_kzalloc(&client->dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->client = client;\n\tst->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t  &adp5061_regmap_config);\n\tif (IS_ERR(st->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize register map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_set_clientdata(client, st);\n\tpsy_cfg.drv_data = st;\n\n\tst->psy = devm_power_supply_register(&client->dev,\n\t\t\t\t\t     &adp5061_desc,\n\t\t\t\t\t     &psy_cfg);\n\n\tif (IS_ERR(st->psy)) {\n\t\tdev_err(&client->dev, \"Failed to register power supply\\n\");\n\t\treturn PTR_ERR(st->psy);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id adp5061_id[] = {\n\t{ \"adp5061\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adp5061_id);\n\nstatic struct i2c_driver adp5061_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n\t.probe = adp5061_probe,\n\t.id_table = adp5061_id,\n};\nmodule_i2c_driver(adp5061_driver);\n\nMODULE_DESCRIPTION(\"Analog Devices adp5061 battery charger driver\");\nMODULE_AUTHOR(\"Stefan Popa <stefan.popa@analog.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}