{
  "module_name": "ds2760_battery.c",
  "hash_id": "6cbb06973132c20ddce2d4b6a4db5e93e6f35966d5ce5b4131f483b506962e88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ds2760_battery.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/param.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/suspend.h>\n#include <linux/w1.h>\n#include <linux/of.h>\n\nstatic unsigned int cache_time = 1000;\nmodule_param(cache_time, uint, 0644);\nMODULE_PARM_DESC(cache_time, \"cache time in milliseconds\");\n\nstatic bool pmod_enabled;\nmodule_param(pmod_enabled, bool, 0644);\nMODULE_PARM_DESC(pmod_enabled, \"PMOD enable bit\");\n\nstatic unsigned int rated_capacity;\nmodule_param(rated_capacity, uint, 0644);\nMODULE_PARM_DESC(rated_capacity, \"rated battery capacity, 10*mAh or index\");\n\nstatic unsigned int current_accum;\nmodule_param(current_accum, uint, 0644);\nMODULE_PARM_DESC(current_accum, \"current accumulator value\");\n\n#define W1_FAMILY_DS2760\t\t0x30\n\n \n#define W1_DS2760_SWAP\t\t\t0xAA\n#define W1_DS2760_READ_DATA\t\t0x69\n#define W1_DS2760_WRITE_DATA\t\t0x6C\n#define W1_DS2760_COPY_DATA\t\t0x48\n#define W1_DS2760_RECALL_DATA\t\t0xB8\n#define W1_DS2760_LOCK\t\t\t0x6A\n\n \n#define DS2760_DATA_SIZE\t\t0x40\n\n#define DS2760_PROTECTION_REG\t\t0x00\n\n#define DS2760_STATUS_REG\t\t0x01\n#define DS2760_STATUS_IE\t\t(1 << 2)\n#define DS2760_STATUS_SWEN\t\t(1 << 3)\n#define DS2760_STATUS_RNAOP\t\t(1 << 4)\n#define DS2760_STATUS_PMOD\t\t(1 << 5)\n\n#define DS2760_EEPROM_REG\t\t0x07\n#define DS2760_SPECIAL_FEATURE_REG\t0x08\n#define DS2760_VOLTAGE_MSB\t\t0x0c\n#define DS2760_VOLTAGE_LSB\t\t0x0d\n#define DS2760_CURRENT_MSB\t\t0x0e\n#define DS2760_CURRENT_LSB\t\t0x0f\n#define DS2760_CURRENT_ACCUM_MSB\t0x10\n#define DS2760_CURRENT_ACCUM_LSB\t0x11\n#define DS2760_TEMP_MSB\t\t\t0x18\n#define DS2760_TEMP_LSB\t\t\t0x19\n#define DS2760_EEPROM_BLOCK0\t\t0x20\n#define DS2760_ACTIVE_FULL\t\t0x20\n#define DS2760_EEPROM_BLOCK1\t\t0x30\n#define DS2760_STATUS_WRITE_REG\t\t0x31\n#define DS2760_RATED_CAPACITY\t\t0x32\n#define DS2760_CURRENT_OFFSET_BIAS\t0x33\n#define DS2760_ACTIVE_EMPTY\t\t0x3b\n\nstruct ds2760_device_info {\n\tstruct device *dev;\n\n\t \n\tunsigned long update_time;\t \n\tchar raw[DS2760_DATA_SIZE];\t \n\tint voltage_raw;\t\t \n\tint voltage_uV;\t\t\t \n\tint current_raw;\t\t \n\tint current_uA;\t\t\t \n\tint accum_current_raw;\t\t \n\tint accum_current_uAh;\t\t \n\tint temp_raw;\t\t\t \n\tint temp_C;\t\t\t \n\tint rated_capacity;\t\t \n\tint rem_capacity;\t\t \n\tint full_active_uAh;\t\t \n\tint empty_uAh;\t\t\t \n\tint life_sec;\t\t\t \n\tint charge_status;\t\t \n\n\tint full_counter;\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct workqueue_struct *monitor_wqueue;\n\tstruct delayed_work monitor_work;\n\tstruct delayed_work set_charged_work;\n\tstruct notifier_block pm_notifier;\n};\n\nstatic int w1_ds2760_io(struct device *dev, char *buf, int addr, size_t count,\n\t\t\tint io)\n{\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\n\tif (!dev)\n\t\treturn 0;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (addr > DS2760_DATA_SIZE || addr < 0) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\tif (addr + count > DS2760_DATA_SIZE)\n\t\tcount = DS2760_DATA_SIZE - addr;\n\n\tif (!w1_reset_select_slave(sl)) {\n\t\tif (!io) {\n\t\t\tw1_write_8(sl->master, W1_DS2760_READ_DATA);\n\t\t\tw1_write_8(sl->master, addr);\n\t\t\tcount = w1_read_block(sl->master, buf, count);\n\t\t} else {\n\t\t\tw1_write_8(sl->master, W1_DS2760_WRITE_DATA);\n\t\t\tw1_write_8(sl->master, addr);\n\t\t\tw1_write_block(sl->master, buf, count);\n\t\t\t \n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&sl->master->bus_mutex);\n\n\treturn count;\n}\n\nstatic int w1_ds2760_read(struct device *dev,\n\t\t\t  char *buf, int addr,\n\t\t\t  size_t count)\n{\n\treturn w1_ds2760_io(dev, buf, addr, count, 0);\n}\n\nstatic int w1_ds2760_write(struct device *dev,\n\t\t\t   char *buf,\n\t\t\t   int addr, size_t count)\n{\n\treturn w1_ds2760_io(dev, buf, addr, count, 1);\n}\n\nstatic int w1_ds2760_eeprom_cmd(struct device *dev, int addr, int cmd)\n{\n\tstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sl->master->bus_mutex);\n\n\tif (w1_reset_select_slave(sl) == 0) {\n\t\tw1_write_8(sl->master, cmd);\n\t\tw1_write_8(sl->master, addr);\n\t}\n\n\tmutex_unlock(&sl->master->bus_mutex);\n\treturn 0;\n}\n\nstatic int w1_ds2760_store_eeprom(struct device *dev, int addr)\n{\n\treturn w1_ds2760_eeprom_cmd(dev, addr, W1_DS2760_COPY_DATA);\n}\n\nstatic int w1_ds2760_recall_eeprom(struct device *dev, int addr)\n{\n\treturn w1_ds2760_eeprom_cmd(dev, addr, W1_DS2760_RECALL_DATA);\n}\n\nstatic ssize_t w1_slave_read(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t     loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\treturn w1_ds2760_read(dev, buf, off, count);\n}\n\nstatic BIN_ATTR_RO(w1_slave, DS2760_DATA_SIZE);\n\nstatic struct bin_attribute *w1_ds2760_bin_attrs[] = {\n\t&bin_attr_w1_slave,\n\tNULL,\n};\n\nstatic const struct attribute_group w1_ds2760_group = {\n\t.bin_attrs = w1_ds2760_bin_attrs,\n};\n\nstatic const struct attribute_group *w1_ds2760_groups[] = {\n\t&w1_ds2760_group,\n\tNULL,\n};\n \nstatic int rated_capacities[] = {\n\t0,\n\t920,\t \n\t920,\t \n\t920,\t \n\t920,\t \n\t1440,\t \n\t1440,\t \n\t1440,\t \n\t1440,\t \n\t2880,\t \n\t2880,\t \n\t2880,\t \n\t2880,\t \n};\n\n \nstatic int battery_interpolate(int array[], int temp)\n{\n\tint index, dt;\n\n\tif (temp <= 0)\n\t\treturn array[0];\n\tif (temp >= 40)\n\t\treturn array[4];\n\n\tindex = temp / 10;\n\tdt    = temp % 10;\n\n\treturn array[index] + (((array[index + 1] - array[index]) * dt) / 10);\n}\n\nstatic int ds2760_battery_read_status(struct ds2760_device_info *di)\n{\n\tint ret, i, start, count, scale[5];\n\n\tif (di->update_time && time_before(jiffies, di->update_time +\n\t\t\t\t\t   msecs_to_jiffies(cache_time)))\n\t\treturn 0;\n\n\t \n\tif (di->update_time == 0) {\n\t\tstart = 0;\n\t\tcount = DS2760_DATA_SIZE;\n\t} else {\n\t\tstart = DS2760_VOLTAGE_MSB;\n\t\tcount = DS2760_TEMP_LSB - start + 1;\n\t}\n\n\tret = w1_ds2760_read(di->dev, di->raw + start, start, count);\n\tif (ret != count) {\n\t\tdev_warn(di->dev, \"call to w1_ds2760_read failed (0x%p)\\n\",\n\t\t\t di->dev);\n\t\treturn 1;\n\t}\n\n\tdi->update_time = jiffies;\n\n\t \n\tdi->voltage_raw = (di->raw[DS2760_VOLTAGE_MSB] << 3) |\n\t\t\t  (di->raw[DS2760_VOLTAGE_LSB] >> 5);\n\tdi->voltage_uV = di->voltage_raw * 4880;\n\n\t \n\tdi->current_raw =\n\t    (((signed char)di->raw[DS2760_CURRENT_MSB]) << 5) |\n\t\t\t  (di->raw[DS2760_CURRENT_LSB] >> 3);\n\tdi->current_uA = di->current_raw * 625;\n\n\t \n\tdi->accum_current_raw =\n\t    (((signed char)di->raw[DS2760_CURRENT_ACCUM_MSB]) << 8) |\n\t\t\t   di->raw[DS2760_CURRENT_ACCUM_LSB];\n\tdi->accum_current_uAh = di->accum_current_raw * 250;\n\n\t \n\tdi->temp_raw = (((signed char)di->raw[DS2760_TEMP_MSB]) << 3) |\n\t\t\t\t     (di->raw[DS2760_TEMP_LSB] >> 5);\n\tdi->temp_C = di->temp_raw + (di->temp_raw / 4);\n\n\t \n\tif (di->raw[DS2760_RATED_CAPACITY] < ARRAY_SIZE(rated_capacities))\n\t\tdi->rated_capacity = rated_capacities[\n\t\t\t(unsigned int)di->raw[DS2760_RATED_CAPACITY]];\n\telse\n\t\tdi->rated_capacity = di->raw[DS2760_RATED_CAPACITY] * 10;\n\n\tdi->rated_capacity *= 1000;  \n\n\t \n\tdi->full_active_uAh = di->raw[DS2760_ACTIVE_FULL] << 8 |\n\t\t\t      di->raw[DS2760_ACTIVE_FULL + 1];\n\n\t \n\tif (di->full_active_uAh == 0)\n\t\tdi->full_active_uAh = di->rated_capacity / 1000L;\n\n\tscale[0] = di->full_active_uAh;\n\tfor (i = 1; i < 5; i++)\n\t\tscale[i] = scale[i - 1] + di->raw[DS2760_ACTIVE_FULL + 1 + i];\n\n\tdi->full_active_uAh = battery_interpolate(scale, di->temp_C / 10);\n\tdi->full_active_uAh *= 1000;  \n\n\t \n\tscale[4] = di->raw[DS2760_ACTIVE_EMPTY + 4];\n\tfor (i = 3; i >= 0; i--)\n\t\tscale[i] = scale[i + 1] + di->raw[DS2760_ACTIVE_EMPTY + i];\n\n\tdi->empty_uAh = battery_interpolate(scale, di->temp_C / 10);\n\tdi->empty_uAh *= 1000;  \n\n\tif (di->full_active_uAh == di->empty_uAh)\n\t\tdi->rem_capacity = 0;\n\telse\n\t\t \n\t\tdi->rem_capacity = ((di->accum_current_uAh - di->empty_uAh) * 100L) /\n\t\t\t\t    (di->full_active_uAh - di->empty_uAh);\n\n\tif (di->rem_capacity < 0)\n\t\tdi->rem_capacity = 0;\n\tif (di->rem_capacity > 100)\n\t\tdi->rem_capacity = 100;\n\n\tif (di->current_uA < -100L)\n\t\tdi->life_sec = -((di->accum_current_uAh - di->empty_uAh) * 36L)\n\t\t\t\t\t/ (di->current_uA / 100L);\n\telse\n\t\tdi->life_sec = 0;\n\n\treturn 0;\n}\n\nstatic void ds2760_battery_set_current_accum(struct ds2760_device_info *di,\n\t\t\t\t\t     unsigned int acr_val)\n{\n\tunsigned char acr[2];\n\n\t \n\tacr_val *= 4L;\n\tacr_val /= 1000;\n\n\tacr[0] = acr_val >> 8;\n\tacr[1] = acr_val & 0xff;\n\n\tif (w1_ds2760_write(di->dev, acr, DS2760_CURRENT_ACCUM_MSB, 2) < 2)\n\t\tdev_warn(di->dev, \"ACR write failed\\n\");\n}\n\nstatic void ds2760_battery_update_status(struct ds2760_device_info *di)\n{\n\tint old_charge_status = di->charge_status;\n\n\tds2760_battery_read_status(di);\n\n\tif (di->charge_status == POWER_SUPPLY_STATUS_UNKNOWN)\n\t\tdi->full_counter = 0;\n\n\tif (power_supply_am_i_supplied(di->bat)) {\n\t\tif (di->current_uA > 10000) {\n\t\t\tdi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tdi->full_counter = 0;\n\t\t} else if (di->current_uA < -5000) {\n\t\t\tif (di->charge_status != POWER_SUPPLY_STATUS_NOT_CHARGING)\n\t\t\t\tdev_notice(di->dev, \"not enough power to \"\n\t\t\t\t\t   \"charge\\n\");\n\t\t\tdi->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tdi->full_counter = 0;\n\t\t} else if (di->current_uA < 10000 &&\n\t\t\t    di->charge_status != POWER_SUPPLY_STATUS_FULL) {\n\n\t\t\t \n\n\t\t\tdi->full_counter++;\n\n\t\t\tif (di->full_counter < 2) {\n\t\t\t\tdi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\t} else {\n\t\t\t\tdi->charge_status = POWER_SUPPLY_STATUS_FULL;\n\t\t\t\tds2760_battery_set_current_accum(di,\n\t\t\t\t\t\tdi->full_active_uAh);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tdi->full_counter = 0;\n\t}\n\n\tif (di->charge_status != old_charge_status)\n\t\tpower_supply_changed(di->bat);\n}\n\nstatic void ds2760_battery_write_status(struct ds2760_device_info *di,\n\t\t\t\t\tchar status)\n{\n\tif (status == di->raw[DS2760_STATUS_REG])\n\t\treturn;\n\n\tw1_ds2760_write(di->dev, &status, DS2760_STATUS_WRITE_REG, 1);\n\tw1_ds2760_store_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n\tw1_ds2760_recall_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n}\n\nstatic void ds2760_battery_write_rated_capacity(struct ds2760_device_info *di,\n\t\t\t\t\t\tunsigned char rated_capacity)\n{\n\tif (rated_capacity == di->raw[DS2760_RATED_CAPACITY])\n\t\treturn;\n\n\tw1_ds2760_write(di->dev, &rated_capacity, DS2760_RATED_CAPACITY, 1);\n\tw1_ds2760_store_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n\tw1_ds2760_recall_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n}\n\nstatic void ds2760_battery_write_active_full(struct ds2760_device_info *di,\n\t\t\t\t\t     int active_full)\n{\n\tunsigned char tmp[2] = {\n\t\tactive_full >> 8,\n\t\tactive_full & 0xff\n\t};\n\n\tif (tmp[0] == di->raw[DS2760_ACTIVE_FULL] &&\n\t    tmp[1] == di->raw[DS2760_ACTIVE_FULL + 1])\n\t\treturn;\n\n\tw1_ds2760_write(di->dev, tmp, DS2760_ACTIVE_FULL, sizeof(tmp));\n\tw1_ds2760_store_eeprom(di->dev, DS2760_EEPROM_BLOCK0);\n\tw1_ds2760_recall_eeprom(di->dev, DS2760_EEPROM_BLOCK0);\n\n\t \n\tdi->raw[DS2760_ACTIVE_FULL] = tmp[0];\n\tdi->raw[DS2760_ACTIVE_FULL + 1] = tmp[1];\n}\n\nstatic void ds2760_battery_work(struct work_struct *work)\n{\n\tstruct ds2760_device_info *di = container_of(work,\n\t\tstruct ds2760_device_info, monitor_work.work);\n\tconst int interval = HZ * 60;\n\n\tdev_dbg(di->dev, \"%s\\n\", __func__);\n\n\tds2760_battery_update_status(di);\n\tqueue_delayed_work(di->monitor_wqueue, &di->monitor_work, interval);\n}\n\nstatic void ds2760_battery_external_power_changed(struct power_supply *psy)\n{\n\tstruct ds2760_device_info *di = power_supply_get_drvdata(psy);\n\n\tdev_dbg(di->dev, \"%s\\n\", __func__);\n\n\tmod_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ/10);\n}\n\n\nstatic void ds2760_battery_set_charged_work(struct work_struct *work)\n{\n\tchar bias;\n\tstruct ds2760_device_info *di = container_of(work,\n\t\tstruct ds2760_device_info, set_charged_work.work);\n\n\tdev_dbg(di->dev, \"%s\\n\", __func__);\n\n\tds2760_battery_read_status(di);\n\n\t \n\n\tif (!power_supply_am_i_supplied(di->bat))\n\t\treturn;\n\n\tbias = (signed char) di->current_raw +\n\t\t(signed char) di->raw[DS2760_CURRENT_OFFSET_BIAS];\n\n\tdev_dbg(di->dev, \"%s: bias = %d\\n\", __func__, bias);\n\n\tw1_ds2760_write(di->dev, &bias, DS2760_CURRENT_OFFSET_BIAS, 1);\n\tw1_ds2760_store_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n\tw1_ds2760_recall_eeprom(di->dev, DS2760_EEPROM_BLOCK1);\n\n\t \n\tdi->raw[DS2760_CURRENT_OFFSET_BIAS] = bias;\n}\n\nstatic void ds2760_battery_set_charged(struct power_supply *psy)\n{\n\tstruct ds2760_device_info *di = power_supply_get_drvdata(psy);\n\n\t \n\tmod_delayed_work(di->monitor_wqueue, &di->set_charged_work, HZ * 20);\n}\n\nstatic int ds2760_battery_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct ds2760_device_info *di = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = di->charge_status;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tds2760_battery_read_status(di);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = di->voltage_uV;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = di->current_uA;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval = di->rated_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tval->intval = di->full_active_uAh;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\tval->intval = di->empty_uAh;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tval->intval = di->accum_current_uAh;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = di->temp_C;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\t\tval->intval = di->life_sec;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = di->rem_capacity;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds2760_battery_set_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct ds2760_device_info *di = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\t \n\t\tds2760_battery_write_active_full(di, val->intval / 1000L);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\t \n\t\tds2760_battery_set_current_accum(di, val->intval);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds2760_battery_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\treturn 1;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property ds2760_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_EMPTY,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n};\n\nstatic int ds2760_pm_notifier(struct notifier_block *notifier,\n\t\t\t      unsigned long pm_event,\n\t\t\t      void *unused)\n{\n\tstruct ds2760_device_info *di =\n\t\tcontainer_of(notifier, struct ds2760_device_info, pm_notifier);\n\n\tswitch (pm_event) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tpower_supply_changed(di->bat);\n\t\tmod_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ);\n\n\t\tbreak;\n\n\tcase PM_RESTORE_PREPARE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int w1_ds2760_add_slave(struct w1_slave *sl)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ds2760_device_info *di;\n\tstruct device *dev = &sl->dev;\n\tint retval = 0;\n\tchar name[32];\n\tchar status;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di) {\n\t\tretval = -ENOMEM;\n\t\tgoto di_alloc_failed;\n\t}\n\n\tsnprintf(name, sizeof(name), \"ds2760-battery.%d\", dev->id);\n\n\tdi->dev\t\t\t\t= dev;\n\tdi->bat_desc.name\t\t= name;\n\tdi->bat_desc.type\t\t= POWER_SUPPLY_TYPE_BATTERY;\n\tdi->bat_desc.properties\t\t= ds2760_battery_props;\n\tdi->bat_desc.num_properties\t= ARRAY_SIZE(ds2760_battery_props);\n\tdi->bat_desc.get_property\t= ds2760_battery_get_property;\n\tdi->bat_desc.set_property\t= ds2760_battery_set_property;\n\tdi->bat_desc.property_is_writeable =\n\t\t\t\t  ds2760_battery_property_is_writeable;\n\tdi->bat_desc.set_charged\t= ds2760_battery_set_charged;\n\tdi->bat_desc.external_power_changed =\n\t\t\t\t  ds2760_battery_external_power_changed;\n\n\tpsy_cfg.drv_data = di;\n\n\tif (dev->of_node) {\n\t\tu32 tmp;\n\n\t\tpsy_cfg.of_node = dev->of_node;\n\n\t\tif (!of_property_read_bool(dev->of_node, \"maxim,pmod-enabled\"))\n\t\t\tpmod_enabled = true;\n\n\t\tif (!of_property_read_u32(dev->of_node,\n\t\t\t\t\t  \"maxim,cache-time-ms\", &tmp))\n\t\t\tcache_time = tmp;\n\n\t\tif (!of_property_read_u32(dev->of_node,\n\t\t\t\t\t  \"rated-capacity-microamp-hours\",\n\t\t\t\t\t  &tmp))\n\t\t\trated_capacity = tmp / 10;  \n\t}\n\n\tdi->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\tsl->family_data = di;\n\n\t \n\tds2760_battery_read_status(di);\n\tstatus = di->raw[DS2760_STATUS_REG];\n\tif (pmod_enabled)\n\t\tstatus |= DS2760_STATUS_PMOD;\n\telse\n\t\tstatus &= ~DS2760_STATUS_PMOD;\n\n\tds2760_battery_write_status(di, status);\n\n\t \n\tif (rated_capacity)\n\t\tds2760_battery_write_rated_capacity(di, rated_capacity);\n\n\t \n\tif (current_accum)\n\t\tds2760_battery_set_current_accum(di, current_accum);\n\n\tdi->bat = power_supply_register(dev, &di->bat_desc, &psy_cfg);\n\tif (IS_ERR(di->bat)) {\n\t\tdev_err(di->dev, \"failed to register battery\\n\");\n\t\tretval = PTR_ERR(di->bat);\n\t\tgoto batt_failed;\n\t}\n\n\tINIT_DELAYED_WORK(&di->monitor_work, ds2760_battery_work);\n\tINIT_DELAYED_WORK(&di->set_charged_work,\n\t\t\t  ds2760_battery_set_charged_work);\n\tdi->monitor_wqueue = alloc_ordered_workqueue(name, WQ_MEM_RECLAIM);\n\tif (!di->monitor_wqueue) {\n\t\tretval = -ESRCH;\n\t\tgoto workqueue_failed;\n\t}\n\tqueue_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ * 1);\n\n\tdi->pm_notifier.notifier_call = ds2760_pm_notifier;\n\tregister_pm_notifier(&di->pm_notifier);\n\n\tgoto success;\n\nworkqueue_failed:\n\tpower_supply_unregister(di->bat);\nbatt_failed:\ndi_alloc_failed:\nsuccess:\n\treturn retval;\n}\n\nstatic void w1_ds2760_remove_slave(struct w1_slave *sl)\n{\n\tstruct ds2760_device_info *di = sl->family_data;\n\n\tunregister_pm_notifier(&di->pm_notifier);\n\tcancel_delayed_work_sync(&di->monitor_work);\n\tcancel_delayed_work_sync(&di->set_charged_work);\n\tdestroy_workqueue(di->monitor_wqueue);\n\tpower_supply_unregister(di->bat);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id w1_ds2760_of_ids[] = {\n\t{ .compatible = \"maxim,ds2760\" },\n\t{}\n};\n#endif\n\nstatic const struct w1_family_ops w1_ds2760_fops = {\n\t.add_slave\t= w1_ds2760_add_slave,\n\t.remove_slave\t= w1_ds2760_remove_slave,\n\t.groups\t\t= w1_ds2760_groups,\n};\n\nstatic struct w1_family w1_ds2760_family = {\n\t.fid\t\t= W1_FAMILY_DS2760,\n\t.fops\t\t= &w1_ds2760_fops,\n\t.of_match_table\t= of_match_ptr(w1_ds2760_of_ids),\n};\nmodule_w1_family(w1_ds2760_family);\n\nMODULE_AUTHOR(\"Szabolcs Gyurko <szabolcs.gyurko@tlt.hu>, \"\n\t      \"Matt Reimer <mreimer@vpop.net>, \"\n\t      \"Anton Vorontsov <cbou@mail.ru>\");\nMODULE_DESCRIPTION(\"1-wire Driver Dallas 2760 battery monitor chip\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_FAMILY_DS2760));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}