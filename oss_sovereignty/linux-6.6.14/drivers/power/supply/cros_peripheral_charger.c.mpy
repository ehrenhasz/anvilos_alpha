{
  "module_name": "cros_peripheral_charger.c",
  "hash_id": "2b362337e073c2c0f47c8663cc85cc1ecce47ffc9b5364b471d058fae777576b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/cros_peripheral_charger.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/stringify.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n\n#define DRV_NAME\t\t\"cros-ec-pchg\"\n#define PCHG_DIR_PREFIX\t\t\"peripheral\"\n#define PCHG_DIR_NAME\t\tPCHG_DIR_PREFIX \"%d\"\n#define PCHG_DIR_NAME_LENGTH \\\n\t\tsizeof(PCHG_DIR_PREFIX __stringify(EC_PCHG_MAX_PORTS))\n#define PCHG_CACHE_UPDATE_DELAY\tmsecs_to_jiffies(500)\n\nstruct port_data {\n\tint port_number;\n\tchar name[PCHG_DIR_NAME_LENGTH];\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tint psy_status;\n\tint battery_percentage;\n\tint charge_type;\n\tstruct charger_data *charger;\n\tunsigned long last_update;\n};\n\nstruct charger_data {\n\tstruct device *dev;\n\tstruct cros_ec_dev *ec_dev;\n\tstruct cros_ec_device *ec_device;\n\tint num_registered_psy;\n\tstruct port_data *ports[EC_PCHG_MAX_PORTS];\n\tstruct notifier_block notifier;\n};\n\nstatic enum power_supply_property cros_pchg_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic int cros_pchg_ec_command(const struct charger_data *charger,\n\t\t\t\tunsigned int version,\n\t\t\t\tunsigned int command,\n\t\t\t\tconst void *outdata,\n\t\t\t\tunsigned int outsize,\n\t\t\t\tvoid *indata,\n\t\t\t\tunsigned int insize)\n{\n\tstruct cros_ec_dev *ec_dev = charger->ec_dev;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(struct_size(msg, data, max(outsize, insize)), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = version;\n\tmsg->command = ec_dev->cmd_offset + command;\n\tmsg->outsize = outsize;\n\tmsg->insize = insize;\n\n\tif (outsize)\n\t\tmemcpy(msg->data, outdata, outsize);\n\n\tret = cros_ec_cmd_xfer_status(charger->ec_device, msg);\n\tif (ret >= 0 && insize)\n\t\tmemcpy(indata, msg->data, insize);\n\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic const unsigned int pchg_cmd_version = 1;\n\nstatic bool cros_pchg_cmd_ver_check(const struct charger_data *charger)\n{\n\tstruct ec_params_get_cmd_versions_v1 req;\n\tstruct ec_response_get_cmd_versions rsp;\n\tint ret;\n\n\treq.cmd = EC_CMD_PCHG;\n\tret = cros_pchg_ec_command(charger, 1, EC_CMD_GET_CMD_VERSIONS,\n\t\t\t\t   &req, sizeof(req), &rsp, sizeof(rsp));\n\tif (ret < 0) {\n\t\tdev_warn(charger->dev,\n\t\t\t \"Unable to get versions of EC_CMD_PCHG (err:%d)\\n\",\n\t\t\t ret);\n\t\treturn false;\n\t}\n\n\treturn !!(rsp.version_mask & BIT(pchg_cmd_version));\n}\n\nstatic int cros_pchg_port_count(const struct charger_data *charger)\n{\n\tstruct ec_response_pchg_count rsp;\n\tint ret;\n\n\tret = cros_pchg_ec_command(charger, 0, EC_CMD_PCHG_COUNT,\n\t\t\t\t   NULL, 0, &rsp, sizeof(rsp));\n\tif (ret < 0) {\n\t\tdev_warn(charger->dev,\n\t\t\t \"Unable to get number or ports (err:%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn rsp.port_count;\n}\n\nstatic int cros_pchg_get_status(struct port_data *port)\n{\n\tstruct charger_data *charger = port->charger;\n\tstruct ec_params_pchg req;\n\tstruct ec_response_pchg rsp;\n\tstruct device *dev = charger->dev;\n\tint old_status = port->psy_status;\n\tint old_percentage = port->battery_percentage;\n\tint ret;\n\n\treq.port = port->port_number;\n\tret = cros_pchg_ec_command(charger, pchg_cmd_version, EC_CMD_PCHG,\n\t\t\t\t   &req, sizeof(req), &rsp, sizeof(rsp));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to get port.%d status (err:%d)\\n\",\n\t\t\tport->port_number, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (rsp.state) {\n\tcase PCHG_STATE_RESET:\n\tcase PCHG_STATE_INITIALIZED:\n\tcase PCHG_STATE_ENABLED:\n\tdefault:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tport->charge_type = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tcase PCHG_STATE_DETECTED:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tport->charge_type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase PCHG_STATE_CHARGING:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tport->charge_type = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\tbreak;\n\tcase PCHG_STATE_FULL:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_FULL;\n\t\tport->charge_type = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\t}\n\n\tport->battery_percentage = rsp.battery_percentage;\n\n\tif (port->psy_status != old_status ||\n\t\t\tport->battery_percentage != old_percentage)\n\t\tpower_supply_changed(port->psy);\n\n\tdev_dbg(dev,\n\t\t\"Port %d: state=%d battery=%d%%\\n\",\n\t\tport->port_number, rsp.state, rsp.battery_percentage);\n\n\treturn 0;\n}\n\nstatic int cros_pchg_get_port_status(struct port_data *port, bool ratelimit)\n{\n\tint ret;\n\n\tif (ratelimit &&\n\t    time_is_after_jiffies(port->last_update + PCHG_CACHE_UPDATE_DELAY))\n\t\treturn 0;\n\n\tret = cros_pchg_get_status(port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->last_update = jiffies;\n\n\treturn ret;\n}\n\nstatic int cros_pchg_get_prop(struct power_supply *psy,\n\t\t\t      enum power_supply_property psp,\n\t\t\t      union power_supply_propval *val)\n{\n\tstruct port_data *port = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tcros_pchg_get_port_status(port, true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = port->psy_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = port->battery_percentage;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = port->charge_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_pchg_event(const struct charger_data *charger)\n{\n\tint i;\n\n\tfor (i = 0; i < charger->num_registered_psy; i++)\n\t\tcros_pchg_get_port_status(charger->ports[i], false);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int cros_ec_notify(struct notifier_block *nb,\n\t\t\t  unsigned long queued_during_suspend,\n\t\t\t  void *data)\n{\n\tstruct cros_ec_device *ec_dev = data;\n\tstruct charger_data *charger =\n\t\t\tcontainer_of(nb, struct charger_data, notifier);\n\tu32 host_event;\n\n\tif (ec_dev->event_data.event_type != EC_MKBP_EVENT_PCHG ||\n\t\t\tec_dev->event_size != sizeof(host_event))\n\t\treturn NOTIFY_DONE;\n\n\thost_event = get_unaligned_le32(&ec_dev->event_data.data.host_event);\n\n\tif (!(host_event & EC_MKBP_PCHG_DEVICE_EVENT))\n\t\treturn NOTIFY_DONE;\n\n\treturn cros_pchg_event(charger);\n}\n\nstatic int cros_pchg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);\n\tstruct cros_ec_device *ec_device = ec_dev->ec_dev;\n\tstruct power_supply_desc *psy_desc;\n\tstruct charger_data *charger;\n\tstruct power_supply *psy;\n\tstruct port_data *port;\n\tstruct notifier_block *nb;\n\tint num_ports;\n\tint ret;\n\tint i;\n\n\tcharger = devm_kzalloc(dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tcharger->dev = dev;\n\tcharger->ec_dev = ec_dev;\n\tcharger->ec_device = ec_device;\n\n\tplatform_set_drvdata(pdev, charger);\n\n\tret = cros_pchg_port_count(charger);\n\tif (ret <= 0) {\n\t\t \n\t\tdev_info(dev, \"No peripheral charge ports (err:%d)\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!cros_pchg_cmd_ver_check(charger)) {\n\t\tdev_err(dev, \"EC_CMD_PCHG version %d isn't available.\\n\",\n\t\t\tpchg_cmd_version);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnum_ports = ret;\n\tif (num_ports > EC_PCHG_MAX_PORTS) {\n\t\tdev_err(dev, \"Too many peripheral charge ports (%d)\\n\",\n\t\t\tnum_ports);\n\t\treturn -ENOBUFS;\n\t}\n\n\tdev_info(dev, \"%d peripheral charge ports found\\n\", num_ports);\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tstruct power_supply_config psy_cfg = {};\n\n\t\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\t\tif (!port)\n\t\t\treturn -ENOMEM;\n\n\t\tport->charger = charger;\n\t\tport->port_number = i;\n\t\tsnprintf(port->name, sizeof(port->name), PCHG_DIR_NAME, i);\n\n\t\tpsy_desc = &port->psy_desc;\n\t\tpsy_desc->name = port->name;\n\t\tpsy_desc->type = POWER_SUPPLY_TYPE_BATTERY;\n\t\tpsy_desc->get_property = cros_pchg_get_prop;\n\t\tpsy_desc->external_power_changed = NULL;\n\t\tpsy_desc->properties = cros_pchg_props;\n\t\tpsy_desc->num_properties = ARRAY_SIZE(cros_pchg_props);\n\t\tpsy_cfg.drv_data = port;\n\n\t\tpsy = devm_power_supply_register(dev, psy_desc, &psy_cfg);\n\t\tif (IS_ERR(psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(psy),\n\t\t\t\t\t\"Failed to register power supply\\n\");\n\t\tport->psy = psy;\n\n\t\tcharger->ports[charger->num_registered_psy++] = port;\n\t}\n\n\tif (!charger->num_registered_psy)\n\t\treturn -ENODEV;\n\n\tnb = &charger->notifier;\n\tnb->notifier_call = cros_ec_notify;\n\tret = blocking_notifier_chain_register(&ec_dev->ec_dev->event_notifier,\n\t\t\t\t\t       nb);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register notifier (err:%d)\\n\", ret);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int __maybe_unused cros_pchg_resume(struct device *dev)\n{\n\tstruct charger_data *charger = dev_get_drvdata(dev);\n\n\t \n\tcros_pchg_event(charger);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_pchg_pm_ops, NULL, cros_pchg_resume);\n\nstatic struct platform_driver cros_pchg_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_pchg_pm_ops,\n\t},\n\t.probe = cros_pchg_probe\n};\n\nmodule_platform_driver(cros_pchg_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS EC peripheral device charger\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}