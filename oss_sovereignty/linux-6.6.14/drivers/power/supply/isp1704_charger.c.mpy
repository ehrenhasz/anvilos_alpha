{
  "module_name": "isp1704_charger.c",
  "hash_id": "908ebfd5859434c91982733c71b1bf1fc2070defda353813cec8e6240c6ec540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/isp1704_charger.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/ulpi.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n \n#define ISP1704_PWR_CTRL\t\t0x3d\n#define ISP1704_PWR_CTRL_SWCTRL\t\t(1 << 0)\n#define ISP1704_PWR_CTRL_DET_COMP\t(1 << 1)\n#define ISP1704_PWR_CTRL_BVALID_RISE\t(1 << 2)\n#define ISP1704_PWR_CTRL_BVALID_FALL\t(1 << 3)\n#define ISP1704_PWR_CTRL_DP_WKPU_EN\t(1 << 4)\n#define ISP1704_PWR_CTRL_VDAT_DET\t(1 << 5)\n#define ISP1704_PWR_CTRL_DPVSRC_EN\t(1 << 6)\n#define ISP1704_PWR_CTRL_HWDETECT\t(1 << 7)\n\n#define NXP_VENDOR_ID\t\t\t0x04cc\n\nstatic u16 isp170x_id[] = {\n\t0x1704,\n\t0x1707,\n};\n\nstruct isp1704_charger {\n\tstruct device\t\t\t*dev;\n\tstruct power_supply\t\t*psy;\n\tstruct power_supply_desc\tpsy_desc;\n\tstruct gpio_desc\t\t*enable_gpio;\n\tstruct usb_phy\t\t\t*phy;\n\tstruct notifier_block\t\tnb;\n\tstruct work_struct\t\twork;\n\n\t \n\tchar\t\t\tmodel[8];\n\tunsigned\t\tpresent:1;\n\tunsigned\t\tonline:1;\n\tunsigned\t\tcurrent_max;\n};\n\nstatic inline int isp1704_read(struct isp1704_charger *isp, u32 reg)\n{\n\treturn usb_phy_io_read(isp->phy, reg);\n}\n\nstatic inline int isp1704_write(struct isp1704_charger *isp, u32 reg, u32 val)\n{\n\treturn usb_phy_io_write(isp->phy, val, reg);\n}\n\nstatic void isp1704_charger_set_power(struct isp1704_charger *isp, bool on)\n{\n\tgpiod_set_value(isp->enable_gpio, on);\n}\n\n \nstatic inline int isp1704_charger_type(struct isp1704_charger *isp)\n{\n\tu8 reg;\n\tu8 func_ctrl;\n\tu8 otg_ctrl;\n\tint type = POWER_SUPPLY_TYPE_USB_DCP;\n\n\tfunc_ctrl = isp1704_read(isp, ULPI_FUNC_CTRL);\n\totg_ctrl = isp1704_read(isp, ULPI_OTG_CTRL);\n\n\t \n\treg = ULPI_OTG_CTRL_DM_PULLDOWN | ULPI_OTG_CTRL_DP_PULLDOWN;\n\tisp1704_write(isp, ULPI_CLR(ULPI_OTG_CTRL), reg);\n\n\t \n\tisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\n\t\t\tULPI_FUNC_CTRL_XCVRSEL_MASK);\n\tisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL),\n\t\t\tULPI_FUNC_CTRL_FULL_SPEED);\n\n\t \n\treg = ULPI_FUNC_CTRL_TERMSELECT | ULPI_FUNC_CTRL_RESET;\n\tisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL), reg);\n\tusleep_range(1000, 2000);\n\n\treg = isp1704_read(isp, ULPI_DEBUG);\n\tif ((reg & 3) != 3)\n\t\ttype = POWER_SUPPLY_TYPE_USB_CDP;\n\n\t \n\tisp1704_write(isp, ULPI_FUNC_CTRL, func_ctrl);\n\tisp1704_write(isp, ULPI_OTG_CTRL, otg_ctrl);\n\n\treturn type;\n}\n\n \nstatic inline int isp1704_charger_verify(struct isp1704_charger *isp)\n{\n\tint\tret = 0;\n\tu8\tr;\n\n\t \n\tr = isp1704_read(isp, ULPI_FUNC_CTRL);\n\tr |= ULPI_FUNC_CTRL_RESET;\n\tisp1704_write(isp, ULPI_FUNC_CTRL, r);\n\tusleep_range(1000, 2000);\n\n\t \n\tr &= ~(ULPI_FUNC_CTRL_RESET | ULPI_FUNC_CTRL_OPMODE_MASK);\n\tisp1704_write(isp, ULPI_FUNC_CTRL, r);\n\n\t \n\tr = ULPI_OTG_CTRL_DP_PULLDOWN | ULPI_OTG_CTRL_DM_PULLDOWN;\n\tisp1704_write(isp, ULPI_CLR(ULPI_OTG_CTRL), r);\n\n\t \n\tr = ULPI_FUNC_CTRL_TERMSELECT | ULPI_FUNC_CTRL_RESET;\n\tisp1704_write(isp, ULPI_SET(ULPI_FUNC_CTRL), r);\n\tusleep_range(1000, 2000);\n\n\t \n\tif (!isp1704_read(isp, ULPI_DEBUG)) {\n\t\t \n\t\tisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\n\t\t\t\tULPI_FUNC_CTRL_TERMSELECT);\n\t\treturn 1;\n\t}\n\n\t \n\n\t \n\tisp1704_write(isp, ULPI_SET(ISP1704_PWR_CTRL),\n\t\t\tISP1704_PWR_CTRL_DP_WKPU_EN);\n\n\t \n\tisp1704_write(isp, ULPI_CLR(ULPI_FUNC_CTRL),\n\t\t\tULPI_FUNC_CTRL_TERMSELECT);\n\n\t \n\tisp1704_write(isp, ULPI_SET(ULPI_OTG_CTRL),\n\t\t\tULPI_OTG_CTRL_DM_PULLDOWN);\n\n\t \n\tif (!(isp1704_read(isp, ULPI_DEBUG)))\n\t\tret = 1;\n\n\t \n\tisp1704_write(isp, ULPI_CLR(ISP1704_PWR_CTRL),\n\t\t\tISP1704_PWR_CTRL_DP_WKPU_EN);\n\n\treturn ret;\n}\n\nstatic inline int isp1704_charger_detect(struct isp1704_charger *isp)\n{\n\tunsigned long\ttimeout;\n\tu8\t\tpwr_ctrl;\n\tint\t\tret = 0;\n\n\tpwr_ctrl = isp1704_read(isp, ISP1704_PWR_CTRL);\n\n\t \n\tisp1704_write(isp, ISP1704_PWR_CTRL,\n\t\t\tISP1704_PWR_CTRL_SWCTRL);\n\n\t \n\tisp1704_write(isp, ULPI_SET(ISP1704_PWR_CTRL),\n\t\t\tISP1704_PWR_CTRL_SWCTRL\n\t\t\t| ISP1704_PWR_CTRL_DPVSRC_EN);\n\tusleep_range(1000, 2000);\n\n\ttimeout = jiffies + msecs_to_jiffies(300);\n\tdo {\n\t\t \n\t\tif (isp1704_read(isp, ISP1704_PWR_CTRL)\n\t\t\t\t& ISP1704_PWR_CTRL_VDAT_DET) {\n\t\t\tret = isp1704_charger_verify(isp);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, timeout) && isp->online);\n\n\t \n\tisp1704_write(isp, ISP1704_PWR_CTRL, pwr_ctrl);\n\n\treturn ret;\n}\n\nstatic inline int isp1704_charger_detect_dcp(struct isp1704_charger *isp)\n{\n\tif (isp1704_charger_detect(isp) &&\n\t\t\tisp1704_charger_type(isp) == POWER_SUPPLY_TYPE_USB_DCP)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void isp1704_charger_work(struct work_struct *data)\n{\n\tstruct isp1704_charger\t*isp =\n\t\tcontainer_of(data, struct isp1704_charger, work);\n\tstatic DEFINE_MUTEX(lock);\n\n\tmutex_lock(&lock);\n\n\tswitch (isp->phy->last_event) {\n\tcase USB_EVENT_VBUS:\n\t\t \n\t\tif (!isp->present) {\n\t\t\tisp->online = true;\n\t\t\tisp->present = 1;\n\t\t\tisp1704_charger_set_power(isp, 1);\n\n\t\t\t \n\t\t\tif (isp1704_charger_detect_dcp(isp)) {\n\t\t\t\tisp->psy_desc.type = POWER_SUPPLY_TYPE_USB_DCP;\n\t\t\t\tisp->current_max = 1800;\n\t\t\t} else {\n\t\t\t\tisp->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\t\t\t\tisp->current_max = 500;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (isp->phy->otg->gadget)\n\t\t\t\tusb_gadget_connect(isp->phy->otg->gadget);\n\t\t}\n\n\t\tif (isp->psy_desc.type != POWER_SUPPLY_TYPE_USB_DCP) {\n\t\t\t \n\t\t\tif (isp->current_max > 500)\n\t\t\t\tisp->current_max = 500;\n\n\t\t\tif (isp->current_max > 100)\n\t\t\t\tisp->psy_desc.type = POWER_SUPPLY_TYPE_USB_CDP;\n\t\t}\n\t\tbreak;\n\tcase USB_EVENT_NONE:\n\t\tisp->online = false;\n\t\tisp->present = 0;\n\t\tisp->current_max = 0;\n\t\tisp->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\n\t\t \n\t\tif (isp->phy->otg->gadget)\n\t\t\tusb_gadget_disconnect(isp->phy->otg->gadget);\n\n\t\tisp1704_charger_set_power(isp, 0);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tpower_supply_changed(isp->psy);\nout:\n\tmutex_unlock(&lock);\n}\n\nstatic int isp1704_notifier_call(struct notifier_block *nb,\n\t\tunsigned long val, void *v)\n{\n\tstruct isp1704_charger *isp =\n\t\tcontainer_of(nb, struct isp1704_charger, nb);\n\n\tschedule_work(&isp->work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int isp1704_charger_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct isp1704_charger *isp = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = isp->present;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = isp->online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = isp->current_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = isp->model;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = \"NXP\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property power_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic inline int isp1704_test_ulpi(struct isp1704_charger *isp)\n{\n\tint vendor;\n\tint product;\n\tint i;\n\tint ret;\n\n\t \n\tret = isp1704_write(isp, ULPI_SCRATCH, 0xaa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = isp1704_read(isp, ULPI_SCRATCH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != 0xaa)\n\t\treturn -ENODEV;\n\n\t \n\tvendor = isp1704_read(isp, ULPI_VENDOR_ID_LOW);\n\tvendor |= isp1704_read(isp, ULPI_VENDOR_ID_HIGH) << 8;\n\tif (vendor != NXP_VENDOR_ID)\n\t\treturn -ENODEV;\n\n\tproduct = isp1704_read(isp, ULPI_PRODUCT_ID_LOW);\n\tproduct |= isp1704_read(isp, ULPI_PRODUCT_ID_HIGH) << 8;\n\n\tfor (i = 0; i < ARRAY_SIZE(isp170x_id); i++) {\n\t\tif (product == isp170x_id[i]) {\n\t\t\tsprintf(isp->model, \"isp%x\", product);\n\t\t\treturn product;\n\t\t}\n\t}\n\n\tdev_err(isp->dev, \"product id %x not matching known ids\", product);\n\n\treturn -ENODEV;\n}\n\nstatic int isp1704_charger_probe(struct platform_device *pdev)\n{\n\tstruct isp1704_charger\t*isp;\n\tint\t\t\tret = -ENODEV;\n\tstruct power_supply_config psy_cfg = {};\n\n\tisp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);\n\tif (!isp)\n\t\treturn -ENOMEM;\n\n\tisp->enable_gpio = devm_gpiod_get(&pdev->dev, \"nxp,enable\",\n\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(isp->enable_gpio)) {\n\t\tret = PTR_ERR(isp->enable_gpio);\n\t\tdev_err(&pdev->dev, \"Could not get reset gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdev->dev.of_node)\n\t\tisp->phy = devm_usb_get_phy_by_phandle(&pdev->dev, \"usb-phy\", 0);\n\telse\n\t\tisp->phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\n\n\tif (IS_ERR(isp->phy)) {\n\t\tret = PTR_ERR(isp->phy);\n\t\tdev_err(&pdev->dev, \"usb_get_phy failed\\n\");\n\t\tgoto fail0;\n\t}\n\n\tisp->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, isp);\n\n\tisp1704_charger_set_power(isp, 1);\n\n\tret = isp1704_test_ulpi(isp);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"isp1704_test_ulpi failed\\n\");\n\t\tgoto fail1;\n\t}\n\n\tisp->psy_desc.name\t\t= \"isp1704\";\n\tisp->psy_desc.type\t\t= POWER_SUPPLY_TYPE_USB;\n\tisp->psy_desc.properties\t= power_props;\n\tisp->psy_desc.num_properties\t= ARRAY_SIZE(power_props);\n\tisp->psy_desc.get_property\t= isp1704_charger_get_property;\n\n\tpsy_cfg.drv_data\t\t= isp;\n\n\tisp->psy = power_supply_register(isp->dev, &isp->psy_desc, &psy_cfg);\n\tif (IS_ERR(isp->psy)) {\n\t\tret = PTR_ERR(isp->psy);\n\t\tdev_err(&pdev->dev, \"power_supply_register failed\\n\");\n\t\tgoto fail1;\n\t}\n\n\t \n\tINIT_WORK(&isp->work, isp1704_charger_work);\n\n\tisp->nb.notifier_call = isp1704_notifier_call;\n\n\tret = usb_register_notifier(isp->phy, &isp->nb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"usb_register_notifier failed\\n\");\n\t\tgoto fail2;\n\t}\n\n\tdev_info(isp->dev, \"registered with product id %s\\n\", isp->model);\n\n\t \n\tif (isp->phy->otg->gadget)\n\t\tusb_gadget_disconnect(isp->phy->otg->gadget);\n\n\tif (isp->phy->last_event == USB_EVENT_NONE)\n\t\tisp1704_charger_set_power(isp, 0);\n\n\t \n\tif (isp->phy->last_event == USB_EVENT_VBUS &&\n\t\t\t!isp->phy->otg->default_a)\n\t\tschedule_work(&isp->work);\n\n\treturn 0;\nfail2:\n\tpower_supply_unregister(isp->psy);\nfail1:\n\tisp1704_charger_set_power(isp, 0);\nfail0:\n\tdev_err(&pdev->dev, \"failed to register isp1704 with error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int isp1704_charger_remove(struct platform_device *pdev)\n{\n\tstruct isp1704_charger *isp = platform_get_drvdata(pdev);\n\n\tusb_unregister_notifier(isp->phy, &isp->nb);\n\tpower_supply_unregister(isp->psy);\n\tisp1704_charger_set_power(isp, 0);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id omap_isp1704_of_match[] = {\n\t{ .compatible = \"nxp,isp1704\", },\n\t{ .compatible = \"nxp,isp1707\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_isp1704_of_match);\n#endif\n\nstatic struct platform_driver isp1704_charger_driver = {\n\t.driver = {\n\t\t.name = \"isp1704_charger\",\n\t\t.of_match_table = of_match_ptr(omap_isp1704_of_match),\n\t},\n\t.probe = isp1704_charger_probe,\n\t.remove = isp1704_charger_remove,\n};\n\nmodule_platform_driver(isp1704_charger_driver);\n\nMODULE_ALIAS(\"platform:isp1704_charger\");\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"ISP170x USB Charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}