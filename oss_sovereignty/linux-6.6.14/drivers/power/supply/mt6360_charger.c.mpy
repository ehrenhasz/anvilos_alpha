{
  "module_name": "mt6360_charger.c",
  "hash_id": "a9bbb43565b21669df2179af6cbc96906b21a45c67bf8986273a0b689fd2a4cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/mt6360_charger.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/linear_range.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\n#define MT6360_PMU_CHG_CTRL1\t0x311\n#define MT6360_PMU_CHG_CTRL2\t0x312\n#define MT6360_PMU_CHG_CTRL3\t0x313\n#define MT6360_PMU_CHG_CTRL4\t0x314\n#define MT6360_PMU_CHG_CTRL5\t0x315\n#define MT6360_PMU_CHG_CTRL6\t0x316\n#define MT6360_PMU_CHG_CTRL7\t0x317\n#define MT6360_PMU_CHG_CTRL8\t0x318\n#define MT6360_PMU_CHG_CTRL9\t0x319\n#define MT6360_PMU_CHG_CTRL10\t0x31A\n#define MT6360_PMU_DEVICE_TYPE\t0x322\n#define MT6360_PMU_USB_STATUS1\t0x327\n#define MT6360_PMU_CHG_STAT\t0x34A\n#define MT6360_PMU_CHG_CTRL19\t0x361\n#define MT6360_PMU_FOD_STAT\t0x3E7\n\n \n#define MT6360_FSLP_SHFT\t(3)\n#define MT6360_FSLP_MASK\tBIT(MT6360_FSLP_SHFT)\n#define MT6360_OPA_MODE_SHFT\t(0)\n#define MT6360_OPA_MODE_MASK\tBIT(MT6360_OPA_MODE_SHFT)\n \n#define MT6360_IINLMTSEL_SHFT\t(2)\n#define MT6360_IINLMTSEL_MASK\tGENMASK(3, 2)\n \n#define MT6360_IAICR_SHFT\t(2)\n#define MT6360_IAICR_MASK\tGENMASK(7, 2)\n#define MT6360_ILIM_EN_MASK\tBIT(0)\n \n#define MT6360_VOREG_SHFT\t(1)\n#define MT6360_VOREG_MASK\tGENMASK(7, 1)\n \n#define MT6360_VOBST_MASK\tGENMASK(7, 2)\n \n#define MT6360_VMIVR_SHFT      (1)\n#define MT6360_VMIVR_MASK      GENMASK(7, 1)\n \n#define MT6360_ICHG_SHFT\t(2)\n#define MT6360_ICHG_MASK\tGENMASK(7, 2)\n \n#define MT6360_IPREC_SHFT\t(0)\n#define MT6360_IPREC_MASK\tGENMASK(3, 0)\n \n#define MT6360_IEOC_SHFT\t(4)\n#define MT6360_IEOC_MASK\tGENMASK(7, 4)\n \n#define MT6360_OTG_OC_MASK\tGENMASK(3, 0)\n \n#define MT6360_USBCHGEN_MASK\tBIT(7)\n \n#define MT6360_USB_STATUS_SHFT\t(4)\n#define MT6360_USB_STATUS_MASK\tGENMASK(6, 4)\n \n#define MT6360_CHG_STAT_SHFT\t(6)\n#define MT6360_CHG_STAT_MASK\tGENMASK(7, 6)\n#define MT6360_VBAT_LVL_MASK\tBIT(5)\n \n#define MT6360_VINOVP_SHFT\t(5)\n#define MT6360_VINOVP_MASK\tGENMASK(6, 5)\n \n#define MT6360_CHRDET_EXT_MASK\tBIT(4)\n\n \n#define MT6360_VMIVR_MIN\t3900000\n#define MT6360_VMIVR_MAX\t13400000\n#define MT6360_VMIVR_STEP\t100000\n \n#define MT6360_ICHG_MIN\t\t100000\n#define MT6360_ICHG_MAX\t\t5000000\n#define MT6360_ICHG_STEP\t100000\n \n#define MT6360_VOREG_MIN\t3900000\n#define MT6360_VOREG_MAX\t4710000\n#define MT6360_VOREG_STEP\t10000\n \n#define MT6360_AICR_MIN\t\t100000\n#define MT6360_AICR_MAX\t\t3250000\n#define MT6360_AICR_STEP\t50000\n \n#define MT6360_IPREC_MIN\t100000\n#define MT6360_IPREC_MAX\t850000\n#define MT6360_IPREC_STEP\t50000\n \n#define MT6360_IEOC_MIN\t\t100000\n#define MT6360_IEOC_MAX\t\t850000\n#define MT6360_IEOC_STEP\t50000\n\nenum {\n\tMT6360_RANGE_VMIVR,\n\tMT6360_RANGE_ICHG,\n\tMT6360_RANGE_VOREG,\n\tMT6360_RANGE_AICR,\n\tMT6360_RANGE_IPREC,\n\tMT6360_RANGE_IEOC,\n\tMT6360_RANGE_MAX,\n};\n\nstatic const struct linear_range mt6360_chg_range[MT6360_RANGE_MAX] = {\n\tLINEAR_RANGE_IDX(MT6360_RANGE_VMIVR, 3900000, 0, 0x5F, 100000),\n\tLINEAR_RANGE_IDX(MT6360_RANGE_ICHG, 100000, 0, 0x31, 100000),\n\tLINEAR_RANGE_IDX(MT6360_RANGE_VOREG, 3900000, 0, 0x51, 10000),\n\tLINEAR_RANGE_IDX(MT6360_RANGE_AICR, 100000, 0, 0x3F, 50000),\n\tLINEAR_RANGE_IDX(MT6360_RANGE_IPREC, 100000, 0, 0x0F, 50000),\n\tLINEAR_RANGE_IDX(MT6360_RANGE_IEOC, 100000, 0, 0x0F, 50000),\n};\n\nstruct mt6360_chg_info {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct power_supply_desc psy_desc;\n\tstruct power_supply *psy;\n\tstruct regulator_dev *otg_rdev;\n\tstruct mutex chgdet_lock;\n\tu32 vinovp;\n\tbool pwr_rdy;\n\tbool bc12_en;\n\tint psy_usb_type;\n\tstruct work_struct chrdet_work;\n};\n\nenum mt6360_iinlmtsel {\n\tMT6360_IINLMTSEL_AICR_3250 = 0,\n\tMT6360_IINLMTSEL_CHG_TYPE,\n\tMT6360_IINLMTSEL_AICR,\n\tMT6360_IINLMTSEL_LOWER_LEVEL,\n};\n\nenum mt6360_pmu_chg_type {\n\tMT6360_CHG_TYPE_NOVBUS = 0,\n\tMT6360_CHG_TYPE_UNDER_GOING,\n\tMT6360_CHG_TYPE_SDP,\n\tMT6360_CHG_TYPE_SDPNSTD,\n\tMT6360_CHG_TYPE_DCP,\n\tMT6360_CHG_TYPE_CDP,\n\tMT6360_CHG_TYPE_DISABLE_BC12,\n\tMT6360_CHG_TYPE_MAX,\n};\n\nstatic enum power_supply_usb_type mt6360_charger_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n};\n\nstatic int mt6360_get_chrdet_ext_stat(struct mt6360_chg_info *mci,\n\t\t\t\t\t     bool *pwr_rdy)\n{\n\tint ret;\n\tunsigned int regval;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_FOD_STAT, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\t*pwr_rdy = (regval & MT6360_CHRDET_EXT_MASK) ? true : false;\n\treturn 0;\n}\n\nstatic int mt6360_charger_get_online(struct mt6360_chg_info *mci,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tint ret;\n\tbool pwr_rdy;\n\n\tret = mt6360_get_chrdet_ext_stat(mci, &pwr_rdy);\n\tif (ret < 0)\n\t\treturn ret;\n\tval->intval = pwr_rdy ? true : false;\n\treturn 0;\n}\n\nstatic int mt6360_charger_get_status(struct mt6360_chg_info *mci,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tint status, ret;\n\tunsigned int regval;\n\tbool pwr_rdy;\n\n\tret = mt6360_get_chrdet_ext_stat(mci, &pwr_rdy);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!pwr_rdy) {\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tgoto out;\n\t}\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_STAT, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\tregval &= MT6360_CHG_STAT_MASK;\n\tregval >>= MT6360_CHG_STAT_SHFT;\n\tswitch (regval) {\n\tcase 0x0:\n\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase 0x1:\n\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase 0x2:\n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\nout:\n\tif (!ret)\n\t\tval->intval = status;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_charge_type(struct mt6360_chg_info *mci,\n\t\t\t\t\t  union power_supply_propval *val)\n{\n\tint type, ret;\n\tunsigned int regval;\n\tu8 chg_stat;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_STAT, &regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchg_stat = (regval & MT6360_CHG_STAT_MASK) >> MT6360_CHG_STAT_SHFT;\n\tswitch (chg_stat) {\n\tcase 0x01:  \n\t\tif (regval & MT6360_VBAT_LVL_MASK)\n\t\t\ttype = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\telse\n\t\t\ttype = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase 0x00:  \n\tcase 0x02:  \n\tcase 0x03:  \n\tdefault:\n\t\ttype = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\t}\n\n\tval->intval = type;\n\treturn 0;\n}\n\nstatic int mt6360_charger_get_ichg(struct mt6360_chg_info *mci,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL7, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_ICHG_MASK) >> MT6360_ICHG_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_ICHG], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_max_ichg(struct mt6360_chg_info *mci,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tval->intval = MT6360_ICHG_MAX;\n\treturn 0;\n}\n\nstatic int mt6360_charger_get_cv(struct mt6360_chg_info *mci,\n\t\t\t\t union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL4, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_VOREG_MASK) >> MT6360_VOREG_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_VOREG], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_max_cv(struct mt6360_chg_info *mci,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tval->intval = MT6360_VOREG_MAX;\n\treturn 0;\n}\n\nstatic int mt6360_charger_get_aicr(struct mt6360_chg_info *mci,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL3, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_IAICR_MASK) >> MT6360_IAICR_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_AICR], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_mivr(struct mt6360_chg_info *mci,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL6, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_VMIVR_MASK) >> MT6360_VMIVR_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_VMIVR], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_iprechg(struct mt6360_chg_info *mci,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL8, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_IPREC_MASK) >> MT6360_IPREC_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_IPREC], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_get_ieoc(struct mt6360_chg_info *mci,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tu32 sel, value;\n\n\tret = regmap_read(mci->regmap, MT6360_PMU_CHG_CTRL9, &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\tsel = (sel & MT6360_IEOC_MASK) >> MT6360_IEOC_SHFT;\n\tret = linear_range_get_value(&mt6360_chg_range[MT6360_RANGE_IEOC], sel, &value);\n\tif (!ret)\n\t\tval->intval = value;\n\treturn ret;\n}\n\nstatic int mt6360_charger_set_online(struct mt6360_chg_info *mci,\n\t\t\t\t     const union power_supply_propval *val)\n{\n\tu8 force_sleep = val->intval ? 0 : 1;\n\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL1,\n\t\t\t\t  MT6360_FSLP_MASK,\n\t\t\t\t  force_sleep << MT6360_FSLP_SHFT);\n}\n\nstatic int mt6360_charger_set_ichg(struct mt6360_chg_info *mci,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_ICHG], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL7,\n\t\t\t\t  MT6360_ICHG_MASK,\n\t\t\t\t  sel << MT6360_ICHG_SHFT);\n}\n\nstatic int mt6360_charger_set_cv(struct mt6360_chg_info *mci,\n\t\t\t\t const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_VOREG], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL4,\n\t\t\t\t  MT6360_VOREG_MASK,\n\t\t\t\t  sel << MT6360_VOREG_SHFT);\n}\n\nstatic int mt6360_charger_set_aicr(struct mt6360_chg_info *mci,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_AICR], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL3,\n\t\t\t\t  MT6360_IAICR_MASK,\n\t\t\t\t  sel << MT6360_IAICR_SHFT);\n}\n\nstatic int mt6360_charger_set_mivr(struct mt6360_chg_info *mci,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_VMIVR], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL3,\n\t\t\t\t  MT6360_VMIVR_MASK,\n\t\t\t\t  sel << MT6360_VMIVR_SHFT);\n}\n\nstatic int mt6360_charger_set_iprechg(struct mt6360_chg_info *mci,\n\t\t\t\t      const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_IPREC], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL8,\n\t\t\t\t  MT6360_IPREC_MASK,\n\t\t\t\t  sel << MT6360_IPREC_SHFT);\n}\n\nstatic int mt6360_charger_set_ieoc(struct mt6360_chg_info *mci,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tu32 sel;\n\n\tlinear_range_get_selector_within(&mt6360_chg_range[MT6360_RANGE_IEOC], val->intval, &sel);\n\treturn regmap_update_bits(mci->regmap,\n\t\t\t\t  MT6360_PMU_CHG_CTRL9,\n\t\t\t\t  MT6360_IEOC_MASK,\n\t\t\t\t  sel << MT6360_IEOC_SHFT);\n}\n\nstatic int mt6360_charger_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct mt6360_chg_info *mci = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = mt6360_charger_get_online(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = mt6360_charger_get_status(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = mt6360_charger_get_charge_type(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = mt6360_charger_get_ichg(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tret = mt6360_charger_get_max_ichg(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = mt6360_charger_get_cv(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tret = mt6360_charger_get_max_cv(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = mt6360_charger_get_aicr(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = mt6360_charger_get_mivr(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tret = mt6360_charger_get_iprechg(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = mt6360_charger_get_ieoc(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = mci->psy_usb_type;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\treturn ret;\n}\n\nstatic int mt6360_charger_set_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct mt6360_chg_info *mci = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = mt6360_charger_set_online(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = mt6360_charger_set_ichg(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = mt6360_charger_set_cv(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = mt6360_charger_set_aicr(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = mt6360_charger_set_mivr(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tret = mt6360_charger_set_iprechg(mci, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = mt6360_charger_set_ieoc(mci, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int mt6360_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t       enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum power_supply_property mt6360_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n};\n\nstatic const struct power_supply_desc mt6360_charger_desc = {\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= mt6360_charger_properties,\n\t.num_properties\t\t= ARRAY_SIZE(mt6360_charger_properties),\n\t.get_property\t\t= mt6360_charger_get_property,\n\t.set_property\t\t= mt6360_charger_set_property,\n\t.property_is_writeable\t= mt6360_charger_property_is_writeable,\n\t.usb_types\t\t= mt6360_charger_usb_types,\n\t.num_usb_types\t\t= ARRAY_SIZE(mt6360_charger_usb_types),\n};\n\nstatic const struct regulator_ops mt6360_chg_otg_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\nstatic const struct regulator_desc mt6360_otg_rdesc = {\n\t.of_match = \"usb-otg-vbus\",\n\t.name = \"usb-otg-vbus\",\n\t.ops = &mt6360_chg_otg_ops,\n\t.owner = THIS_MODULE,\n\t.type = REGULATOR_VOLTAGE,\n\t.min_uV = 4425000,\n\t.uV_step = 25000,\n\t.n_voltages = 57,\n\t.vsel_reg = MT6360_PMU_CHG_CTRL5,\n\t.vsel_mask = MT6360_VOBST_MASK,\n\t.enable_reg = MT6360_PMU_CHG_CTRL1,\n\t.enable_mask = MT6360_OPA_MODE_MASK,\n};\n\nstatic irqreturn_t mt6360_pmu_attach_i_handler(int irq, void *data)\n{\n\tstruct mt6360_chg_info *mci = data;\n\tint ret;\n\tunsigned int usb_status;\n\tint last_usb_type;\n\n\tmutex_lock(&mci->chgdet_lock);\n\tif (!mci->bc12_en) {\n\t\tdev_warn(mci->dev, \"Received attach interrupt, bc12 disabled, ignore irq\\n\");\n\t\tgoto out;\n\t}\n\tlast_usb_type = mci->psy_usb_type;\n\t \n\tret = regmap_read(mci->regmap, MT6360_PMU_USB_STATUS1, &usb_status);\n\tif (ret < 0)\n\t\tgoto out;\n\tusb_status &= MT6360_USB_STATUS_MASK;\n\tusb_status >>= MT6360_USB_STATUS_SHFT;\n\tswitch (usb_status) {\n\tcase MT6360_CHG_TYPE_NOVBUS:\n\t\tdev_dbg(mci->dev, \"Received attach interrupt, no vbus\\n\");\n\t\tgoto out;\n\tcase MT6360_CHG_TYPE_UNDER_GOING:\n\t\tdev_dbg(mci->dev, \"Received attach interrupt, under going...\\n\");\n\t\tgoto out;\n\tcase MT6360_CHG_TYPE_SDP:\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase MT6360_CHG_TYPE_SDPNSTD:\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase MT6360_CHG_TYPE_CDP:\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tbreak;\n\tcase MT6360_CHG_TYPE_DCP:\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase MT6360_CHG_TYPE_DISABLE_BC12:\n\t\tdev_dbg(mci->dev, \"Received attach interrupt, bc12 detect not enable\\n\");\n\t\tgoto out;\n\tdefault:\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tdev_dbg(mci->dev, \"Received attach interrupt, reserved address\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_dbg(mci->dev, \"Received attach interrupt, chg_type = %d\\n\", mci->psy_usb_type);\n\tif (last_usb_type != mci->psy_usb_type)\n\t\tpower_supply_changed(mci->psy);\nout:\n\tmutex_unlock(&mci->chgdet_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mt6360_handle_chrdet_ext_evt(struct mt6360_chg_info *mci)\n{\n\tint ret;\n\tbool pwr_rdy;\n\n\tmutex_lock(&mci->chgdet_lock);\n\tret = mt6360_get_chrdet_ext_stat(mci, &pwr_rdy);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (mci->pwr_rdy == pwr_rdy) {\n\t\tdev_dbg(mci->dev, \"Received vbus interrupt, pwr_rdy is same(%d)\\n\", pwr_rdy);\n\t\tgoto out;\n\t}\n\tmci->pwr_rdy = pwr_rdy;\n\tdev_dbg(mci->dev, \"Received vbus interrupt, pwr_rdy = %d\\n\", pwr_rdy);\n\tif (!pwr_rdy) {\n\t\tmci->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tpower_supply_changed(mci->psy);\n\n\t}\n\tret = regmap_update_bits(mci->regmap,\n\t\t\t\t MT6360_PMU_DEVICE_TYPE,\n\t\t\t\t MT6360_USBCHGEN_MASK,\n\t\t\t\t pwr_rdy ? MT6360_USBCHGEN_MASK : 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tmci->bc12_en = pwr_rdy;\nout:\n\tmutex_unlock(&mci->chgdet_lock);\n}\n\nstatic void mt6360_chrdet_work(struct work_struct *work)\n{\n\tstruct mt6360_chg_info *mci = (struct mt6360_chg_info *)container_of(\n\t\t\t\t     work, struct mt6360_chg_info, chrdet_work);\n\n\tmt6360_handle_chrdet_ext_evt(mci);\n}\n\nstatic irqreturn_t mt6360_pmu_chrdet_ext_evt_handler(int irq, void *data)\n{\n\tstruct mt6360_chg_info *mci = data;\n\n\tmt6360_handle_chrdet_ext_evt(mci);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mt6360_chg_irq_register(struct platform_device *pdev)\n{\n\tconst struct {\n\t\tconst char *name;\n\t\tirq_handler_t handler;\n\t} irq_descs[] = {\n\t\t{ \"attach_i\", mt6360_pmu_attach_i_handler },\n\t\t{ \"chrdet_ext_evt\", mt6360_pmu_chrdet_ext_evt_handler }\n\t};\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(irq_descs); i++) {\n\t\tret = platform_get_irq_byname(pdev, irq_descs[i].name);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, ret, NULL,\n\t\t\t\t\t\tirq_descs[i].handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\tirq_descs[i].name,\n\t\t\t\t\t\tplatform_get_drvdata(pdev));\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to request %s irq\\n\",\n\t\t\t\t\t     irq_descs[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 mt6360_vinovp_trans_to_sel(u32 val)\n{\n\tu32 vinovp_tbl[] = { 5500000, 6500000, 11000000, 14500000 };\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vinovp_tbl)-1; i++) {\n\t\tif (val < vinovp_tbl[i+1])\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int mt6360_chg_init_setting(struct mt6360_chg_info *mci)\n{\n\tint ret;\n\tu32 sel;\n\n\tsel = mt6360_vinovp_trans_to_sel(mci->vinovp);\n\tret = regmap_update_bits(mci->regmap, MT6360_PMU_CHG_CTRL19,\n\t\t\t\t  MT6360_VINOVP_MASK, sel << MT6360_VINOVP_SHFT);\n\tif (ret)\n\t\treturn dev_err_probe(mci->dev, ret, \"%s: Failed to apply vinovp\\n\", __func__);\n\tret = regmap_update_bits(mci->regmap, MT6360_PMU_DEVICE_TYPE,\n\t\t\t\t MT6360_USBCHGEN_MASK, 0);\n\tif (ret)\n\t\treturn dev_err_probe(mci->dev, ret, \"%s: Failed to disable bc12\\n\", __func__);\n\tret = regmap_update_bits(mci->regmap, MT6360_PMU_CHG_CTRL2,\n\t\t\t\t MT6360_IINLMTSEL_MASK,\n\t\t\t\t MT6360_IINLMTSEL_AICR <<\n\t\t\t\t\tMT6360_IINLMTSEL_SHFT);\n\tif (ret)\n\t\treturn dev_err_probe(mci->dev, ret,\n\t\t\t\t     \"%s: Failed to switch iinlmtsel to aicr\\n\", __func__);\n\tusleep_range(5000, 6000);\n\tret = regmap_update_bits(mci->regmap, MT6360_PMU_CHG_CTRL3,\n\t\t\t\t MT6360_ILIM_EN_MASK, 0);\n\tif (ret)\n\t\treturn dev_err_probe(mci->dev, ret,\n\t\t\t\t     \"%s: Failed to disable ilim\\n\", __func__);\n\tret = regmap_update_bits(mci->regmap, MT6360_PMU_CHG_CTRL10,\n\t\t\t\t MT6360_OTG_OC_MASK, MT6360_OTG_OC_MASK);\n\tif (ret)\n\t\treturn dev_err_probe(mci->dev, ret,\n\t\t\t\t     \"%s: Failed to config otg oc to 3A\\n\", __func__);\n\treturn 0;\n}\n\nstatic int mt6360_charger_probe(struct platform_device *pdev)\n{\n\tstruct mt6360_chg_info *mci;\n\tstruct power_supply_config charger_cfg = {};\n\tstruct regulator_config config = { };\n\tint ret;\n\n\tmci = devm_kzalloc(&pdev->dev, sizeof(*mci), GFP_KERNEL);\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->dev = &pdev->dev;\n\tmci->vinovp = 6500000;\n\tmutex_init(&mci->chgdet_lock);\n\tplatform_set_drvdata(pdev, mci);\n\tret = devm_work_autocancel(&pdev->dev, &mci->chrdet_work, mt6360_chrdet_work);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to set delayed work\\n\");\n\n\tret = device_property_read_u32(&pdev->dev, \"richtek,vinovp-microvolt\", &mci->vinovp);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"Failed to parse vinovp in DT, keep default 6.5v\\n\");\n\n\tmci->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!mci->regmap)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV, \"Failed to get parent regmap\\n\");\n\n\tret = mt6360_chg_init_setting(mci);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to initial setting\\n\");\n\n\tmemcpy(&mci->psy_desc, &mt6360_charger_desc, sizeof(mci->psy_desc));\n\tmci->psy_desc.name = dev_name(&pdev->dev);\n\tcharger_cfg.drv_data = mci;\n\tcharger_cfg.of_node = pdev->dev.of_node;\n\tmci->psy = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t      &mci->psy_desc, &charger_cfg);\n\tif (IS_ERR(mci->psy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(mci->psy),\n\t\t\t\t     \"Failed to register power supply dev\\n\");\n\n\n\tret = mt6360_chg_irq_register(pdev);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register irqs\\n\");\n\n\tconfig.dev = &pdev->dev;\n\tconfig.regmap = mci->regmap;\n\tmci->otg_rdev = devm_regulator_register(&pdev->dev, &mt6360_otg_rdesc,\n\t\t\t\t\t\t&config);\n\tif (IS_ERR(mci->otg_rdev))\n\t\treturn PTR_ERR(mci->otg_rdev);\n\n\tschedule_work(&mci->chrdet_work);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused mt6360_charger_of_id[] = {\n\t{ .compatible = \"mediatek,mt6360-chg\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt6360_charger_of_id);\n\nstatic const struct platform_device_id mt6360_charger_id[] = {\n\t{ \"mt6360-chg\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, mt6360_charger_id);\n\nstatic struct platform_driver mt6360_charger_driver = {\n\t.driver = {\n\t\t.name = \"mt6360-chg\",\n\t\t.of_match_table = of_match_ptr(mt6360_charger_of_id),\n\t},\n\t.probe = mt6360_charger_probe,\n\t.id_table = mt6360_charger_id,\n};\nmodule_platform_driver(mt6360_charger_driver);\n\nMODULE_AUTHOR(\"Gene Chen <gene_chen@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6360 Charger Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}