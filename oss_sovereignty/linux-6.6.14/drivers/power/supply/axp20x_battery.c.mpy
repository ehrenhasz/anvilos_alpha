{
  "module_name": "axp20x_battery.c",
  "hash_id": "3de34111edd1cb834f7ebed63164148cdf877ac8eece62c5d6c8ad3068d4df10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/axp20x_battery.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/consumer.h>\n#include <linux/mfd/axp20x.h>\n\n#define AXP20X_PWR_STATUS_BAT_CHARGING\tBIT(2)\n\n#define AXP20X_PWR_OP_BATT_PRESENT\tBIT(5)\n#define AXP20X_PWR_OP_BATT_ACTIVATED\tBIT(3)\n\n#define AXP209_FG_PERCENT\t\tGENMASK(6, 0)\n#define AXP22X_FG_VALID\t\t\tBIT(7)\n\n#define AXP20X_CHRG_CTRL1_ENABLE\tBIT(7)\n#define AXP20X_CHRG_CTRL1_TGT_VOLT\tGENMASK(6, 5)\n#define AXP20X_CHRG_CTRL1_TGT_4_1V\t(0 << 5)\n#define AXP20X_CHRG_CTRL1_TGT_4_15V\t(1 << 5)\n#define AXP20X_CHRG_CTRL1_TGT_4_2V\t(2 << 5)\n#define AXP20X_CHRG_CTRL1_TGT_4_36V\t(3 << 5)\n\n#define AXP22X_CHRG_CTRL1_TGT_4_22V\t(1 << 5)\n#define AXP22X_CHRG_CTRL1_TGT_4_24V\t(3 << 5)\n\n#define AXP813_CHRG_CTRL1_TGT_4_35V\t(3 << 5)\n\n#define AXP20X_CHRG_CTRL1_TGT_CURR\tGENMASK(3, 0)\n\n#define AXP20X_V_OFF_MASK\t\tGENMASK(2, 0)\n\nstruct axp20x_batt_ps;\n\nstruct axp_data {\n\tint\tccc_scale;\n\tint\tccc_offset;\n\tbool\thas_fg_valid;\n\tint\t(*get_max_voltage)(struct axp20x_batt_ps *batt, int *val);\n\tint\t(*set_max_voltage)(struct axp20x_batt_ps *batt, int val);\n};\n\nstruct axp20x_batt_ps {\n\tstruct regmap *regmap;\n\tstruct power_supply *batt;\n\tstruct device *dev;\n\tstruct iio_channel *batt_chrg_i;\n\tstruct iio_channel *batt_dischrg_i;\n\tstruct iio_channel *batt_v;\n\t \n\tunsigned int max_ccc;\n\tconst struct axp_data\t*data;\n};\n\nstatic int axp20x_battery_get_max_voltage(struct axp20x_batt_ps *axp20x_batt,\n\t\t\t\t\t  int *val)\n{\n\tint ret, reg;\n\n\tret = regmap_read(axp20x_batt->regmap, AXP20X_CHRG_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & AXP20X_CHRG_CTRL1_TGT_VOLT) {\n\tcase AXP20X_CHRG_CTRL1_TGT_4_1V:\n\t\t*val = 4100000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_15V:\n\t\t*val = 4150000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_2V:\n\t\t*val = 4200000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_36V:\n\t\t*val = 4360000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int axp22x_battery_get_max_voltage(struct axp20x_batt_ps *axp20x_batt,\n\t\t\t\t\t  int *val)\n{\n\tint ret, reg;\n\n\tret = regmap_read(axp20x_batt->regmap, AXP20X_CHRG_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & AXP20X_CHRG_CTRL1_TGT_VOLT) {\n\tcase AXP20X_CHRG_CTRL1_TGT_4_1V:\n\t\t*val = 4100000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_2V:\n\t\t*val = 4200000;\n\t\tbreak;\n\tcase AXP22X_CHRG_CTRL1_TGT_4_22V:\n\t\t*val = 4220000;\n\t\tbreak;\n\tcase AXP22X_CHRG_CTRL1_TGT_4_24V:\n\t\t*val = 4240000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int axp813_battery_get_max_voltage(struct axp20x_batt_ps *axp20x_batt,\n\t\t\t\t\t  int *val)\n{\n\tint ret, reg;\n\n\tret = regmap_read(axp20x_batt->regmap, AXP20X_CHRG_CTRL1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & AXP20X_CHRG_CTRL1_TGT_VOLT) {\n\tcase AXP20X_CHRG_CTRL1_TGT_4_1V:\n\t\t*val = 4100000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_15V:\n\t\t*val = 4150000;\n\t\tbreak;\n\tcase AXP20X_CHRG_CTRL1_TGT_4_2V:\n\t\t*val = 4200000;\n\t\tbreak;\n\tcase AXP813_CHRG_CTRL1_TGT_4_35V:\n\t\t*val = 4350000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int axp20x_get_constant_charge_current(struct axp20x_batt_ps *axp,\n\t\t\t\t\t      int *val)\n{\n\tint ret;\n\n\tret = regmap_read(axp->regmap, AXP20X_CHRG_CTRL1, val);\n\tif (ret)\n\t\treturn ret;\n\n\t*val &= AXP20X_CHRG_CTRL1_TGT_CURR;\n\n\t*val = *val * axp->data->ccc_scale + axp->data->ccc_offset;\n\n\treturn 0;\n}\n\nstatic int axp20x_battery_get_prop(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct axp20x_batt_ps *axp20x_batt = power_supply_get_drvdata(psy);\n\tint ret = 0, reg, val1;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,\n\t\t\t\t  &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = !!(reg & AXP20X_PWR_OP_BATT_PRESENT);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_INPUT_STATUS,\n\t\t\t\t  &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & AXP20X_PWR_STATUS_BAT_CHARGING) {\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = iio_read_channel_processed(axp20x_batt->batt_dischrg_i,\n\t\t\t\t\t\t &val1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val1) {\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_FG_RES, &val1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif ((val1 & AXP209_FG_PERCENT) == 100)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,\n\t\t\t\t  &val1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val1 & AXP20X_PWR_OP_BATT_ACTIVATED) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\t\treturn 0;\n\t\t}\n\n\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = axp20x_get_constant_charge_current(axp20x_batt,\n\t\t\t\t\t\t\t &val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = axp20x_batt->max_ccc;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_INPUT_STATUS,\n\t\t\t\t  &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & AXP20X_PWR_STATUS_BAT_CHARGING) {\n\t\t\tret = iio_read_channel_processed(axp20x_batt->batt_chrg_i, &val->intval);\n\t\t} else {\n\t\t\tret = iio_read_channel_processed(axp20x_batt->batt_dischrg_i, &val1);\n\t\t\tval->intval = -val1;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval *= 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\t \n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,\n\t\t\t\t  &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(reg & AXP20X_PWR_OP_BATT_PRESENT)) {\n\t\t\tval->intval = 100;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_FG_RES, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (axp20x_batt->data->has_fg_valid && !(reg & AXP22X_FG_VALID))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tval->intval = reg & AXP209_FG_PERCENT;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\treturn axp20x_batt->data->get_max_voltage(axp20x_batt,\n\t\t\t\t\t\t\t  &val->intval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tret = regmap_read(axp20x_batt->regmap, AXP20X_V_OFF, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = 2600000 + 100000 * (reg & AXP20X_V_OFF_MASK);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = iio_read_channel_processed(axp20x_batt->batt_v,\n\t\t\t\t\t\t &val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval *= 1000;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int axp22x_battery_set_max_voltage(struct axp20x_batt_ps *axp20x_batt,\n\t\t\t\t\t  int val)\n{\n\tswitch (val) {\n\tcase 4100000:\n\t\tval = AXP20X_CHRG_CTRL1_TGT_4_1V;\n\t\tbreak;\n\n\tcase 4200000:\n\t\tval = AXP20X_CHRG_CTRL1_TGT_4_2V;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\t  AXP20X_CHRG_CTRL1_TGT_VOLT, val);\n}\n\nstatic int axp20x_battery_set_max_voltage(struct axp20x_batt_ps *axp20x_batt,\n\t\t\t\t\t  int val)\n{\n\tswitch (val) {\n\tcase 4100000:\n\t\tval = AXP20X_CHRG_CTRL1_TGT_4_1V;\n\t\tbreak;\n\n\tcase 4150000:\n\t\tval = AXP20X_CHRG_CTRL1_TGT_4_15V;\n\t\tbreak;\n\n\tcase 4200000:\n\t\tval = AXP20X_CHRG_CTRL1_TGT_4_2V;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\t  AXP20X_CHRG_CTRL1_TGT_VOLT, val);\n}\n\nstatic int axp20x_set_constant_charge_current(struct axp20x_batt_ps *axp_batt,\n\t\t\t\t\t      int charge_current)\n{\n\tif (charge_current > axp_batt->max_ccc)\n\t\treturn -EINVAL;\n\n\tcharge_current = (charge_current - axp_batt->data->ccc_offset) /\n\t\taxp_batt->data->ccc_scale;\n\n\tif (charge_current > AXP20X_CHRG_CTRL1_TGT_CURR || charge_current < 0)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(axp_batt->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\t  AXP20X_CHRG_CTRL1_TGT_CURR, charge_current);\n}\n\nstatic int axp20x_set_max_constant_charge_current(struct axp20x_batt_ps *axp,\n\t\t\t\t\t\t  int charge_current)\n{\n\tbool lower_max = false;\n\n\tcharge_current = (charge_current - axp->data->ccc_offset) /\n\t\taxp->data->ccc_scale;\n\n\tif (charge_current > AXP20X_CHRG_CTRL1_TGT_CURR || charge_current < 0)\n\t\treturn -EINVAL;\n\n\tcharge_current = charge_current * axp->data->ccc_scale +\n\t\taxp->data->ccc_offset;\n\n\tif (charge_current > axp->max_ccc)\n\t\tdev_warn(axp->dev,\n\t\t\t \"Setting max constant charge current higher than previously defined. Note that increasing the constant charge current may damage your battery.\\n\");\n\telse\n\t\tlower_max = true;\n\n\taxp->max_ccc = charge_current;\n\n\tif (lower_max) {\n\t\tint current_cc;\n\n\t\taxp20x_get_constant_charge_current(axp, &current_cc);\n\t\tif (current_cc > charge_current)\n\t\t\taxp20x_set_constant_charge_current(axp, charge_current);\n\t}\n\n\treturn 0;\n}\nstatic int axp20x_set_voltage_min_design(struct axp20x_batt_ps *axp_batt,\n\t\t\t\t\t int min_voltage)\n{\n\tint val1 = (min_voltage - 2600000) / 100000;\n\n\tif (val1 < 0 || val1 > AXP20X_V_OFF_MASK)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(axp_batt->regmap, AXP20X_V_OFF,\n\t\t\t\t  AXP20X_V_OFF_MASK, val1);\n}\n\nstatic int axp20x_battery_set_prop(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tstruct axp20x_batt_ps *axp20x_batt = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\treturn axp20x_set_voltage_min_design(axp20x_batt, val->intval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\treturn axp20x_batt->data->set_max_voltage(axp20x_batt, val->intval);\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn axp20x_set_constant_charge_current(axp20x_batt,\n\t\t\t\t\t\t\t  val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\treturn axp20x_set_max_constant_charge_current(axp20x_batt,\n\t\t\t\t\t\t\t      val->intval);\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tswitch (val->intval) {\n\t\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\t\treturn regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\tAXP20X_CHRG_CTRL1_ENABLE, AXP20X_CHRG_CTRL1_ENABLE);\n\n\t\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\tcase POWER_SUPPLY_STATUS_NOT_CHARGING:\n\t\t\treturn regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\tAXP20X_CHRG_CTRL1_ENABLE, 0);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic enum power_supply_property axp20x_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n};\n\nstatic int axp20x_battery_prop_writeable(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_STATUS ||\n\t       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN ||\n\t       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN ||\n\t       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||\n\t       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;\n}\n\nstatic const struct power_supply_desc axp20x_batt_ps_desc = {\n\t.name = \"axp20x-battery\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = axp20x_battery_props,\n\t.num_properties = ARRAY_SIZE(axp20x_battery_props),\n\t.property_is_writeable = axp20x_battery_prop_writeable,\n\t.get_property = axp20x_battery_get_prop,\n\t.set_property = axp20x_battery_set_prop,\n};\n\nstatic const struct axp_data axp209_data = {\n\t.ccc_scale = 100000,\n\t.ccc_offset = 300000,\n\t.get_max_voltage = axp20x_battery_get_max_voltage,\n\t.set_max_voltage = axp20x_battery_set_max_voltage,\n};\n\nstatic const struct axp_data axp221_data = {\n\t.ccc_scale = 150000,\n\t.ccc_offset = 300000,\n\t.has_fg_valid = true,\n\t.get_max_voltage = axp22x_battery_get_max_voltage,\n\t.set_max_voltage = axp22x_battery_set_max_voltage,\n};\n\nstatic const struct axp_data axp813_data = {\n\t.ccc_scale = 200000,\n\t.ccc_offset = 200000,\n\t.has_fg_valid = true,\n\t.get_max_voltage = axp813_battery_get_max_voltage,\n\t.set_max_voltage = axp20x_battery_set_max_voltage,\n};\n\nstatic const struct of_device_id axp20x_battery_ps_id[] = {\n\t{\n\t\t.compatible = \"x-powers,axp209-battery-power-supply\",\n\t\t.data = (void *)&axp209_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp221-battery-power-supply\",\n\t\t.data = (void *)&axp221_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp813-battery-power-supply\",\n\t\t.data = (void *)&axp813_data,\n\t}, {   },\n};\nMODULE_DEVICE_TABLE(of, axp20x_battery_ps_id);\n\nstatic int axp20x_power_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_batt_ps *axp20x_batt;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct power_supply_battery_info *info;\n\tstruct device *dev = &pdev->dev;\n\n\tif (!of_device_is_available(pdev->dev.of_node))\n\t\treturn -ENODEV;\n\n\taxp20x_batt = devm_kzalloc(&pdev->dev, sizeof(*axp20x_batt),\n\t\t\t\t   GFP_KERNEL);\n\tif (!axp20x_batt)\n\t\treturn -ENOMEM;\n\n\taxp20x_batt->dev = &pdev->dev;\n\n\taxp20x_batt->batt_v = devm_iio_channel_get(&pdev->dev, \"batt_v\");\n\tif (IS_ERR(axp20x_batt->batt_v)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_v) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_v);\n\t}\n\n\taxp20x_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev,\n\t\t\t\t\t\t\t\"batt_chrg_i\");\n\tif (IS_ERR(axp20x_batt->batt_chrg_i)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_chrg_i) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_chrg_i);\n\t}\n\n\taxp20x_batt->batt_dischrg_i = devm_iio_channel_get(&pdev->dev,\n\t\t\t\t\t\t\t   \"batt_dischrg_i\");\n\tif (IS_ERR(axp20x_batt->batt_dischrg_i)) {\n\t\tif (PTR_ERR(axp20x_batt->batt_dischrg_i) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(axp20x_batt->batt_dischrg_i);\n\t}\n\n\taxp20x_batt->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tplatform_set_drvdata(pdev, axp20x_batt);\n\n\tpsy_cfg.drv_data = axp20x_batt;\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\n\taxp20x_batt->data = (struct axp_data *)of_device_get_match_data(dev);\n\n\taxp20x_batt->batt = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t       &axp20x_batt_ps_desc,\n\t\t\t\t\t\t       &psy_cfg);\n\tif (IS_ERR(axp20x_batt->batt)) {\n\t\tdev_err(&pdev->dev, \"failed to register power supply: %ld\\n\",\n\t\t\tPTR_ERR(axp20x_batt->batt));\n\t\treturn PTR_ERR(axp20x_batt->batt);\n\t}\n\n\tif (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {\n\t\tint vmin = info->voltage_min_design_uv;\n\t\tint ccc = info->constant_charge_current_max_ua;\n\n\t\tif (vmin > 0 && axp20x_set_voltage_min_design(axp20x_batt,\n\t\t\t\t\t\t\t      vmin))\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"couldn't set voltage_min_design\\n\");\n\n\t\t \n\t\taxp20x_batt->max_ccc = ccc;\n\n\t\tif (ccc <= 0 || axp20x_set_constant_charge_current(axp20x_batt,\n\t\t\t\t\t\t\t\t   ccc)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"couldn't set constant charge current from DT: fallback to minimum value\\n\");\n\t\t\tccc = 300000;\n\t\t\taxp20x_batt->max_ccc = ccc;\n\t\t\taxp20x_set_constant_charge_current(axp20x_batt, ccc);\n\t\t}\n\t}\n\n\t \n\taxp20x_get_constant_charge_current(axp20x_batt,\n\t\t\t\t\t   &axp20x_batt->max_ccc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver axp20x_batt_driver = {\n\t.probe    = axp20x_power_probe,\n\t.driver   = {\n\t\t.name  = \"axp20x-battery-power-supply\",\n\t\t.of_match_table = axp20x_battery_ps_id,\n\t},\n};\n\nmodule_platform_driver(axp20x_batt_driver);\n\nMODULE_DESCRIPTION(\"Battery power supply driver for AXP20X and AXP22X PMICs\");\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}