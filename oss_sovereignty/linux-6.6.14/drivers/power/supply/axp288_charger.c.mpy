{
  "module_name": "axp288_charger.c",
  "hash_id": "cd53083d4633626e44d149f9dbb5631c73cb85304ac3137bc47d437279039f30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/axp288_charger.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/usb/otg.h>\n#include <linux/notifier.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/extcon.h>\n#include <linux/dmi.h>\n#include <asm/iosf_mbi.h>\n\n#define PS_STAT_VBUS_TRIGGER\t\tBIT(0)\n#define PS_STAT_BAT_CHRG_DIR\t\tBIT(2)\n#define PS_STAT_VBAT_ABOVE_VHOLD\tBIT(3)\n#define PS_STAT_VBUS_VALID\t\tBIT(4)\n#define PS_STAT_VBUS_PRESENT\t\tBIT(5)\n\n#define CHRG_STAT_BAT_SAFE_MODE\t\tBIT(3)\n#define CHRG_STAT_BAT_VALID\t\tBIT(4)\n#define CHRG_STAT_BAT_PRESENT\t\tBIT(5)\n#define CHRG_STAT_CHARGING\t\tBIT(6)\n#define CHRG_STAT_PMIC_OTP\t\tBIT(7)\n\n#define VBUS_ISPOUT_CUR_LIM_MASK\t0x03\n#define VBUS_ISPOUT_CUR_LIM_BIT_POS\t0\n#define VBUS_ISPOUT_CUR_LIM_900MA\t0x0\t \n#define VBUS_ISPOUT_CUR_LIM_1500MA\t0x1\t \n#define VBUS_ISPOUT_CUR_LIM_2000MA\t0x2\t \n#define VBUS_ISPOUT_CUR_NO_LIM\t\t0x3\t \n#define VBUS_ISPOUT_VHOLD_SET_MASK\t0x38\n#define VBUS_ISPOUT_VHOLD_SET_BIT_POS\t0x3\n#define VBUS_ISPOUT_VHOLD_SET_OFFSET\t4000\t \n#define VBUS_ISPOUT_VHOLD_SET_LSB_RES\t100\t \n#define VBUS_ISPOUT_VHOLD_SET_4400MV\t0x4\t \n#define VBUS_ISPOUT_VBUS_PATH_DIS\tBIT(7)\n\n#define CHRG_CCCV_CC_MASK\t\t0xf\t\t \n#define CHRG_CCCV_CC_BIT_POS\t\t0\n#define CHRG_CCCV_CC_OFFSET\t\t200\t\t \n#define CHRG_CCCV_CC_LSB_RES\t\t200\t\t \n#define CHRG_CCCV_ITERM_20P\t\tBIT(4)\t\t \n#define CHRG_CCCV_CV_MASK\t\t0x60\t\t \n#define CHRG_CCCV_CV_BIT_POS\t\t5\n#define CHRG_CCCV_CV_4100MV\t\t0x0\t\t \n#define CHRG_CCCV_CV_4150MV\t\t0x1\t\t \n#define CHRG_CCCV_CV_4200MV\t\t0x2\t\t \n#define CHRG_CCCV_CV_4350MV\t\t0x3\t\t \n#define CHRG_CCCV_CHG_EN\t\tBIT(7)\n\n#define CNTL2_CC_TIMEOUT_MASK\t\t0x3\t \n#define CNTL2_CC_TIMEOUT_OFFSET\t\t6\t \n#define CNTL2_CC_TIMEOUT_LSB_RES\t2\t \n#define CNTL2_CC_TIMEOUT_12HRS\t\t0x3\t \n#define CNTL2_CHGLED_TYPEB\t\tBIT(4)\n#define CNTL2_CHG_OUT_TURNON\t\tBIT(5)\n#define CNTL2_PC_TIMEOUT_MASK\t\t0xC0\n#define CNTL2_PC_TIMEOUT_OFFSET\t\t40\t \n#define CNTL2_PC_TIMEOUT_LSB_RES\t10\t \n#define CNTL2_PC_TIMEOUT_70MINS\t\t0x3\n\n#define CHRG_ILIM_TEMP_LOOP_EN\t\tBIT(3)\n#define CHRG_VBUS_ILIM_MASK\t\t0xf0\n#define CHRG_VBUS_ILIM_BIT_POS\t\t4\n#define CHRG_VBUS_ILIM_100MA\t\t0x0\t \n#define CHRG_VBUS_ILIM_500MA\t\t0x1\t \n#define CHRG_VBUS_ILIM_900MA\t\t0x2\t \n#define CHRG_VBUS_ILIM_1500MA\t\t0x3\t \n#define CHRG_VBUS_ILIM_2000MA\t\t0x4\t \n#define CHRG_VBUS_ILIM_2500MA\t\t0x5\t \n#define CHRG_VBUS_ILIM_3000MA\t\t0x6\t \n#define CHRG_VBUS_ILIM_3500MA\t\t0x7\t \n#define CHRG_VBUS_ILIM_4000MA\t\t0x8\t \n\n#define CHRG_VLTFC_0C\t\t\t0xA5\t \n#define CHRG_VHTFC_45C\t\t\t0x1F\t \n\n#define FG_CNTL_OCV_ADJ_EN\t\tBIT(3)\n\n#define CV_4100MV\t\t\t4100\t \n#define CV_4150MV\t\t\t4150\t \n#define CV_4200MV\t\t\t4200\t \n#define CV_4350MV\t\t\t4350\t \n\n#define AXP288_REG_UPDATE_INTERVAL\t(60 * HZ)\n\n#define AXP288_EXTCON_DEV_NAME\t\t\"axp288_extcon\"\n#define USB_HOST_EXTCON_HID\t\t\"INT3496\"\n#define USB_HOST_EXTCON_NAME\t\t\"INT3496:00\"\n\nenum {\n\tVBUS_OV_IRQ = 0,\n\tCHARGE_DONE_IRQ,\n\tCHARGE_CHARGING_IRQ,\n\tBAT_SAFE_QUIT_IRQ,\n\tBAT_SAFE_ENTER_IRQ,\n\tQCBTU_IRQ,\n\tCBTU_IRQ,\n\tQCBTO_IRQ,\n\tCBTO_IRQ,\n\tCHRG_INTR_END,\n};\n\nstruct axp288_chrg_info {\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *regmap_irqc;\n\tint irq[CHRG_INTR_END];\n\tstruct power_supply *psy_usb;\n\tstruct mutex lock;\n\n\t \n\tstruct {\n\t\tstruct work_struct work;\n\t\tstruct extcon_dev *cable;\n\t\tstruct notifier_block id_nb;\n\t\tbool id_short;\n\t} otg;\n\n\t \n\tstruct {\n\t\tstruct extcon_dev *edev;\n\t\tstruct notifier_block nb;\n\t\tstruct work_struct work;\n\t} cable;\n\n\tint cc;\n\tint cv;\n\tint max_cc;\n\tint max_cv;\n\n\tunsigned long last_updated;\n\tunsigned int input_status;\n\tunsigned int op_mode;\n\tunsigned int backend_control;\n\tbool valid;\n};\n\nstatic inline int axp288_charger_set_cc(struct axp288_chrg_info *info, int cc)\n{\n\tu8 reg_val;\n\tint ret;\n\n\tif (cc < CHRG_CCCV_CC_OFFSET)\n\t\tcc = CHRG_CCCV_CC_OFFSET;\n\telse if (cc > info->max_cc)\n\t\tcc = info->max_cc;\n\n\treg_val = (cc - CHRG_CCCV_CC_OFFSET) / CHRG_CCCV_CC_LSB_RES;\n\tcc = (reg_val * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\n\treg_val = reg_val << CHRG_CCCV_CC_BIT_POS;\n\n\tret = regmap_update_bits(info->regmap,\n\t\t\t\tAXP20X_CHRG_CTRL1,\n\t\t\t\tCHRG_CCCV_CC_MASK, reg_val);\n\tif (ret >= 0)\n\t\tinfo->cc = cc;\n\n\treturn ret;\n}\n\nstatic inline int axp288_charger_set_cv(struct axp288_chrg_info *info, int cv)\n{\n\tu8 reg_val;\n\tint ret;\n\n\tif (cv <= CV_4100MV) {\n\t\treg_val = CHRG_CCCV_CV_4100MV;\n\t\tcv = CV_4100MV;\n\t} else if (cv <= CV_4150MV) {\n\t\treg_val = CHRG_CCCV_CV_4150MV;\n\t\tcv = CV_4150MV;\n\t} else if (cv <= CV_4200MV) {\n\t\treg_val = CHRG_CCCV_CV_4200MV;\n\t\tcv = CV_4200MV;\n\t} else {\n\t\treg_val = CHRG_CCCV_CV_4350MV;\n\t\tcv = CV_4350MV;\n\t}\n\n\treg_val = reg_val << CHRG_CCCV_CV_BIT_POS;\n\n\tret = regmap_update_bits(info->regmap,\n\t\t\t\tAXP20X_CHRG_CTRL1,\n\t\t\t\tCHRG_CCCV_CV_MASK, reg_val);\n\n\tif (ret >= 0)\n\t\tinfo->cv = cv;\n\n\treturn ret;\n}\n\nstatic int axp288_charger_get_vbus_inlmt(struct axp288_chrg_info *info)\n{\n\tunsigned int val;\n\n\tval = info->backend_control;\n\n\tval >>= CHRG_VBUS_ILIM_BIT_POS;\n\tswitch (val) {\n\tcase CHRG_VBUS_ILIM_100MA:\n\t\treturn 100000;\n\tcase CHRG_VBUS_ILIM_500MA:\n\t\treturn 500000;\n\tcase CHRG_VBUS_ILIM_900MA:\n\t\treturn 900000;\n\tcase CHRG_VBUS_ILIM_1500MA:\n\t\treturn 1500000;\n\tcase CHRG_VBUS_ILIM_2000MA:\n\t\treturn 2000000;\n\tcase CHRG_VBUS_ILIM_2500MA:\n\t\treturn 2500000;\n\tcase CHRG_VBUS_ILIM_3000MA:\n\t\treturn 3000000;\n\tcase CHRG_VBUS_ILIM_3500MA:\n\t\treturn 3500000;\n\tdefault:\n\t\t \n\t\treturn 4000000;\n\t}\n}\n\nstatic inline int axp288_charger_set_vbus_inlmt(struct axp288_chrg_info *info,\n\t\t\t\t\t   int inlmt)\n{\n\tint ret;\n\tu8 reg_val;\n\n\tif (inlmt >= 4000000)\n\t\treg_val = CHRG_VBUS_ILIM_4000MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 3500000)\n\t\treg_val = CHRG_VBUS_ILIM_3500MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 3000000)\n\t\treg_val = CHRG_VBUS_ILIM_3000MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 2500000)\n\t\treg_val = CHRG_VBUS_ILIM_2500MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 2000000)\n\t\treg_val = CHRG_VBUS_ILIM_2000MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 1500000)\n\t\treg_val = CHRG_VBUS_ILIM_1500MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 900000)\n\t\treg_val = CHRG_VBUS_ILIM_900MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse if (inlmt >= 500000)\n\t\treg_val = CHRG_VBUS_ILIM_500MA << CHRG_VBUS_ILIM_BIT_POS;\n\telse\n\t\treg_val = CHRG_VBUS_ILIM_100MA << CHRG_VBUS_ILIM_BIT_POS;\n\n\tret = regmap_update_bits(info->regmap, AXP20X_CHRG_BAK_CTRL,\n\t\t\t\t CHRG_VBUS_ILIM_MASK, reg_val);\n\tif (ret < 0)\n\t\tdev_err(&info->pdev->dev, \"charger BAK control %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int axp288_charger_vbus_path_select(struct axp288_chrg_info *info,\n\t\t\t\t\t\t\t\tbool enable)\n{\n\tint ret;\n\n\tif (enable)\n\t\tret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\n\t\t\t\t\tVBUS_ISPOUT_VBUS_PATH_DIS, 0);\n\telse\n\t\tret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\n\t\t\tVBUS_ISPOUT_VBUS_PATH_DIS, VBUS_ISPOUT_VBUS_PATH_DIS);\n\n\tif (ret < 0)\n\t\tdev_err(&info->pdev->dev, \"axp288 vbus path select %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int axp288_charger_enable_charger(struct axp288_chrg_info *info,\n\t\t\t\t\t\t\t\tbool enable)\n{\n\tint ret;\n\n\tif (enable)\n\t\tret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\tCHRG_CCCV_CHG_EN, CHRG_CCCV_CHG_EN);\n\telse\n\t\tret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\n\t\t\t\tCHRG_CCCV_CHG_EN, 0);\n\tif (ret < 0)\n\t\tdev_err(&info->pdev->dev, \"axp288 enable charger %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int axp288_get_charger_health(struct axp288_chrg_info *info)\n{\n\tif (!(info->input_status & PS_STAT_VBUS_PRESENT))\n\t\treturn POWER_SUPPLY_HEALTH_UNKNOWN;\n\n\tif (!(info->input_status & PS_STAT_VBUS_VALID))\n\t\treturn POWER_SUPPLY_HEALTH_DEAD;\n\telse if (info->op_mode & CHRG_STAT_PMIC_OTP)\n\t\treturn POWER_SUPPLY_HEALTH_OVERHEAT;\n\telse if (info->op_mode & CHRG_STAT_BAT_SAFE_MODE)\n\t\treturn POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\telse\n\t\treturn POWER_SUPPLY_HEALTH_GOOD;\n}\n\nstatic int axp288_charger_usb_set_property(struct power_supply *psy,\n\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t    const union power_supply_propval *val)\n{\n\tstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tint scaled_val;\n\n\tmutex_lock(&info->lock);\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tscaled_val = min(val->intval, info->max_cc);\n\t\tscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\n\t\tret = axp288_charger_set_cc(info, scaled_val);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&info->pdev->dev, \"set charge current failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tscaled_val = min(val->intval, info->max_cv);\n\t\tscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\n\t\tret = axp288_charger_set_cv(info, scaled_val);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&info->pdev->dev, \"set charge voltage failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = axp288_charger_set_vbus_inlmt(info, val->intval);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&info->pdev->dev, \"set input current limit failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->valid = false;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int axp288_charger_reg_readb(struct axp288_chrg_info *info, int reg, unsigned int *ret_val)\n{\n\tint ret;\n\n\tret = regmap_read(info->regmap, reg, ret_val);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"Error %d on reading value from register 0x%04x\\n\",\n\t\t\tret,\n\t\t\treg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int axp288_charger_usb_update_property(struct axp288_chrg_info *info)\n{\n\tint ret = 0;\n\n\tif (info->valid && time_before(jiffies, info->last_updated + AXP288_REG_UPDATE_INTERVAL))\n\t\treturn 0;\n\n\tdev_dbg(&info->pdev->dev, \"Charger updating register values...\\n\");\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = axp288_charger_reg_readb(info, AXP20X_PWR_INPUT_STATUS, &info->input_status);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = axp288_charger_reg_readb(info, AXP20X_PWR_OP_MODE, &info->op_mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = axp288_charger_reg_readb(info, AXP20X_CHRG_BAK_CTRL, &info->backend_control);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tinfo->last_updated = jiffies;\n\tinfo->valid = true;\nout:\n\tiosf_mbi_unblock_punit_i2c_access();\n\treturn ret;\n}\n\nstatic int axp288_charger_usb_get_property(struct power_supply *psy,\n\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = axp288_charger_usb_update_property(info);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\t \n\t\tif (info->otg.id_short) {\n\t\t\tval->intval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tval->intval = (info->input_status & PS_STAT_VBUS_PRESENT) ? 1 : 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\t \n\t\tif (info->otg.id_short) {\n\t\t\tval->intval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tval->intval = (info->input_status & PS_STAT_VBUS_VALID) ? 1 : 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = axp288_get_charger_health(info);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tval->intval = info->cc * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = info->max_cc * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tval->intval = info->cv * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = info->max_cv * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tval->intval = axp288_charger_get_vbus_inlmt(info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int axp288_charger_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property axp288_usb_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n};\n\nstatic const struct power_supply_desc axp288_charger_desc = {\n\t.name\t\t\t= \"axp288_charger\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= axp288_usb_props,\n\t.num_properties\t\t= ARRAY_SIZE(axp288_usb_props),\n\t.get_property\t\t= axp288_charger_usb_get_property,\n\t.set_property\t\t= axp288_charger_usb_set_property,\n\t.property_is_writeable\t= axp288_charger_property_is_writeable,\n};\n\nstatic irqreturn_t axp288_charger_irq_thread_handler(int irq, void *dev)\n{\n\tstruct axp288_chrg_info *info = dev;\n\tint i;\n\n\tfor (i = 0; i < CHRG_INTR_END; i++) {\n\t\tif (info->irq[i] == irq)\n\t\t\tbreak;\n\t}\n\n\tif (i >= CHRG_INTR_END) {\n\t\tdev_warn(&info->pdev->dev, \"spurious interrupt!!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tswitch (i) {\n\tcase VBUS_OV_IRQ:\n\t\tdev_dbg(&info->pdev->dev, \"VBUS Over Voltage INTR\\n\");\n\t\tbreak;\n\tcase CHARGE_DONE_IRQ:\n\t\tdev_dbg(&info->pdev->dev, \"Charging Done INTR\\n\");\n\t\tbreak;\n\tcase CHARGE_CHARGING_IRQ:\n\t\tdev_dbg(&info->pdev->dev, \"Start Charging IRQ\\n\");\n\t\tbreak;\n\tcase BAT_SAFE_QUIT_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Quit Safe Mode(restart timer) Charging IRQ\\n\");\n\t\tbreak;\n\tcase BAT_SAFE_ENTER_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Enter Safe Mode(timer expire) Charging IRQ\\n\");\n\t\tbreak;\n\tcase QCBTU_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Quit Battery Under Temperature(CHRG) INTR\\n\");\n\t\tbreak;\n\tcase CBTU_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Hit Battery Under Temperature(CHRG) INTR\\n\");\n\t\tbreak;\n\tcase QCBTO_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Quit Battery Over Temperature(CHRG) INTR\\n\");\n\t\tbreak;\n\tcase CBTO_IRQ:\n\t\tdev_dbg(&info->pdev->dev,\n\t\t\t\"Hit Battery Over Temperature(CHRG) INTR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&info->pdev->dev, \"Spurious Interrupt!!!\\n\");\n\t\tgoto out;\n\t}\n\tmutex_lock(&info->lock);\n\tinfo->valid = false;\n\tmutex_unlock(&info->lock);\n\tpower_supply_changed(info->psy_usb);\nout:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct dmi_system_id axp288_hp_x2_dmi_ids[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion x2 Detachable\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"815D\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion x2 Detachable\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"813E\"),\n\t\t},\n\t},\n\t{}  \n};\n\nstatic void axp288_charger_extcon_evt_worker(struct work_struct *work)\n{\n\tstruct axp288_chrg_info *info =\n\t    container_of(work, struct axp288_chrg_info, cable.work);\n\tint ret, current_limit;\n\tstruct extcon_dev *edev = info->cable.edev;\n\tunsigned int val;\n\n\tret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"Error reading status (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tif (!(val & PS_STAT_VBUS_VALID)) {\n\t\tdev_dbg(&info->pdev->dev, \"USB charger disconnected\\n\");\n\t\taxp288_charger_enable_charger(info, false);\n\t\tmutex_lock(&info->lock);\n\t\tinfo->valid = false;\n\t\tmutex_unlock(&info->lock);\n\t\tpower_supply_changed(info->psy_usb);\n\t\treturn;\n\t}\n\n\t \n\tif (dmi_check_system(axp288_hp_x2_dmi_ids)) {\n\t\t \n\t\tdev_dbg(&info->pdev->dev, \"HP X2 with Type-C, setting inlmt to 3A\\n\");\n\t\tcurrent_limit = 3000000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_SDP) > 0) {\n\t\tdev_dbg(&info->pdev->dev, \"USB SDP charger is connected\\n\");\n\t\tcurrent_limit = 500000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_CDP) > 0) {\n\t\tdev_dbg(&info->pdev->dev, \"USB CDP charger is connected\\n\");\n\t\tcurrent_limit = 1500000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_DCP) > 0) {\n\t\tdev_dbg(&info->pdev->dev, \"USB DCP charger is connected\\n\");\n\t\tcurrent_limit = 2000000;\n\t} else {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tret = axp288_charger_set_vbus_inlmt(info, current_limit);\n\tif (ret == 0)\n\t\taxp288_charger_enable_charger(info, true);\n\telse\n\t\tdev_err(&info->pdev->dev,\n\t\t\t\"error setting current limit (%d)\\n\", ret);\n\n\tmutex_lock(&info->lock);\n\tinfo->valid = false;\n\tmutex_unlock(&info->lock);\n\tpower_supply_changed(info->psy_usb);\n}\n\nstatic int axp288_charger_handle_cable_evt(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long event, void *param)\n{\n\tstruct axp288_chrg_info *info =\n\t\tcontainer_of(nb, struct axp288_chrg_info, cable.nb);\n\tschedule_work(&info->cable.work);\n\treturn NOTIFY_OK;\n}\n\nstatic void axp288_charger_otg_evt_worker(struct work_struct *work)\n{\n\tstruct axp288_chrg_info *info =\n\t    container_of(work, struct axp288_chrg_info, otg.work);\n\tstruct extcon_dev *edev = info->otg.cable;\n\tint ret, usb_host = extcon_get_state(edev, EXTCON_USB_HOST);\n\n\tdev_dbg(&info->pdev->dev, \"external connector USB-Host is %s\\n\",\n\t\t\t\tusb_host ? \"attached\" : \"detached\");\n\n\t \n\tinfo->otg.id_short = usb_host;\n\n\t \n\tret = axp288_charger_vbus_path_select(info, !info->otg.id_short);\n\tif (ret < 0)\n\t\tdev_warn(&info->pdev->dev, \"vbus path disable failed\\n\");\n}\n\nstatic int axp288_charger_handle_otg_evt(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *param)\n{\n\tstruct axp288_chrg_info *info =\n\t    container_of(nb, struct axp288_chrg_info, otg.id_nb);\n\n\tschedule_work(&info->otg.work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int charger_init_hw_regs(struct axp288_chrg_info *info)\n{\n\tint ret, cc, cv;\n\tunsigned int val;\n\n\t \n\tret = regmap_write(info->regmap, AXP20X_V_LTF_CHRG, CHRG_VLTFC_0C);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\t\t\t\tAXP20X_V_LTF_CHRG, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(info->regmap, AXP20X_V_HTF_CHRG, CHRG_VHTFC_45C);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\t\t\t\tAXP20X_V_HTF_CHRG, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap,\n\t\t\t\tAXP20X_CHRG_CTRL2,\n\t\t\t\tCNTL2_CHG_OUT_TURNON, CNTL2_CHG_OUT_TURNON);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\t\t\tAXP20X_CHRG_CTRL2, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap,\n\t\t\t\tAXP20X_CHRG_CTRL1,\n\t\t\t\tCHRG_CCCV_ITERM_20P, 0);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\t\t\tAXP20X_CHRG_CTRL1, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap,\n\t\t\t\tAXP20X_CC_CTRL,\n\t\t\t\tFG_CNTL_OCV_ADJ_EN, 0);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\t\t\tAXP20X_CC_CTRL, ret);\n\t\treturn ret;\n\t}\n\n\tif (dmi_check_system(axp288_hp_x2_dmi_ids)) {\n\t\t \n\t\tret = axp288_charger_vbus_path_select(info, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tval = VBUS_ISPOUT_VHOLD_SET_4400MV << VBUS_ISPOUT_VHOLD_SET_BIT_POS;\n\t\tret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\n\t\t\t\t\t VBUS_ISPOUT_VHOLD_SET_MASK, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&info->pdev->dev, \"register(%x) write error(%d)\\n\",\n\t\t\t\tAXP20X_VBUS_IPSOUT_MGMT, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = regmap_read(info->regmap, AXP20X_CHRG_CTRL1, &val);\n\tif (ret < 0) {\n\t\tdev_err(&info->pdev->dev, \"register(%x) read error(%d)\\n\",\n\t\t\tAXP20X_CHRG_CTRL1, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcv = (val & CHRG_CCCV_CV_MASK) >> CHRG_CCCV_CV_BIT_POS;\n\tswitch (cv) {\n\tcase CHRG_CCCV_CV_4100MV:\n\t\tinfo->cv = CV_4100MV;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4150MV:\n\t\tinfo->cv = CV_4150MV;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4200MV:\n\t\tinfo->cv = CV_4200MV;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4350MV:\n\t\tinfo->cv = CV_4350MV;\n\t\tbreak;\n\t}\n\n\t \n\tcc = (val & CHRG_CCCV_CC_MASK) >> CHRG_CCCV_CC_BIT_POS;\n\tcc = (cc * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\n\tinfo->cc = cc;\n\n\t \n\tinfo->max_cv = info->cv;\n\tinfo->max_cc = info->cc;\n\n\treturn 0;\n}\n\nstatic void axp288_charger_cancel_work(void *data)\n{\n\tstruct axp288_chrg_info *info = data;\n\n\tcancel_work_sync(&info->otg.work);\n\tcancel_work_sync(&info->cable.work);\n}\n\nstatic int axp288_charger_probe(struct platform_device *pdev)\n{\n\tint ret, i, pirq;\n\tstruct axp288_chrg_info *info;\n\tstruct device *dev = &pdev->dev;\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config charger_cfg = {};\n\tconst char *extcon_name = NULL;\n\tunsigned int val;\n\n\t \n\tif (!acpi_quirk_skip_acpi_ac_and_battery())\n\t\treturn -ENODEV;\n\n\t \n\tret = regmap_read(axp20x->regmap, AXP20X_CC_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val == 0)\n\t\treturn -ENODEV;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&info->lock);\n\tinfo->pdev = pdev;\n\tinfo->regmap = axp20x->regmap;\n\tinfo->regmap_irqc = axp20x->regmap_irqc;\n\n\tinfo->cable.edev = extcon_get_extcon_dev(AXP288_EXTCON_DEV_NAME);\n\tif (IS_ERR(info->cable.edev)) {\n\t\tdev_err_probe(dev, PTR_ERR(info->cable.edev),\n\t\t\t      \"extcon_get_extcon_dev(%s) failed\\n\",\n\t\t\t      AXP288_EXTCON_DEV_NAME);\n\t\treturn PTR_ERR(info->cable.edev);\n\t}\n\n\t \n\tif (acpi_quirk_skip_gpio_event_handlers())\n\t\textcon_name = \"intel-int3496\";\n\telse if (acpi_dev_present(USB_HOST_EXTCON_HID, NULL, -1))\n\t\textcon_name = USB_HOST_EXTCON_NAME;\n\n\tif (extcon_name) {\n\t\tinfo->otg.cable = extcon_get_extcon_dev(extcon_name);\n\t\tif (IS_ERR(info->otg.cable)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(info->otg.cable),\n\t\t\t\t      \"extcon_get_extcon_dev(%s) failed\\n\",\n\t\t\t\t      USB_HOST_EXTCON_NAME);\n\t\t\treturn PTR_ERR(info->otg.cable);\n\t\t}\n\t\tdev_info(dev, \"Using \" USB_HOST_EXTCON_HID \" extcon for usb-id\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = charger_init_hw_regs(info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcharger_cfg.drv_data = info;\n\tinfo->psy_usb = devm_power_supply_register(dev, &axp288_charger_desc,\n\t\t\t\t\t\t   &charger_cfg);\n\tif (IS_ERR(info->psy_usb)) {\n\t\tret = PTR_ERR(info->psy_usb);\n\t\tdev_err(dev, \"failed to register power supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_add_action(dev, axp288_charger_cancel_work, info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tINIT_WORK(&info->cable.work, axp288_charger_extcon_evt_worker);\n\tinfo->cable.nb.notifier_call = axp288_charger_handle_cable_evt;\n\tret = devm_extcon_register_notifier_all(dev, info->cable.edev,\n\t\t\t\t\t\t&info->cable.nb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register cable extcon notifier\\n\");\n\t\treturn ret;\n\t}\n\tschedule_work(&info->cable.work);\n\n\t \n\tINIT_WORK(&info->otg.work, axp288_charger_otg_evt_worker);\n\tinfo->otg.id_nb.notifier_call = axp288_charger_handle_otg_evt;\n\tif (info->otg.cable) {\n\t\tret = devm_extcon_register_notifier(dev, info->otg.cable,\n\t\t\t\t\tEXTCON_USB_HOST, &info->otg.id_nb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to register EXTCON_USB_HOST notifier\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tschedule_work(&info->otg.work);\n\t}\n\n\t \n\tfor (i = 0; i < CHRG_INTR_END; i++) {\n\t\tpirq = platform_get_irq(info->pdev, i);\n\t\tif (pirq < 0)\n\t\t\treturn pirq;\n\n\t\tinfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\n\t\tif (info->irq[i] < 0) {\n\t\t\tdev_warn(&info->pdev->dev,\n\t\t\t\t\"failed to get virtual interrupt=%d\\n\", pirq);\n\t\t\treturn info->irq[i];\n\t\t}\n\t\tret = devm_request_threaded_irq(&info->pdev->dev, info->irq[i],\n\t\t\t\t\tNULL, axp288_charger_irq_thread_handler,\n\t\t\t\t\tIRQF_ONESHOT, info->pdev->name, info);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to request interrupt=%d\\n\",\n\t\t\t\t\t\t\t\tinfo->irq[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id axp288_charger_id_table[] = {\n\t{ .name = \"axp288_charger\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, axp288_charger_id_table);\n\nstatic struct platform_driver axp288_charger_driver = {\n\t.probe = axp288_charger_probe,\n\t.id_table = axp288_charger_id_table,\n\t.driver = {\n\t\t.name = \"axp288_charger\",\n\t},\n};\n\nmodule_platform_driver(axp288_charger_driver);\n\nMODULE_AUTHOR(\"Ramakrishna Pallala <ramakrishna.pallala@intel.com>\");\nMODULE_DESCRIPTION(\"X-power AXP288 Charger Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}