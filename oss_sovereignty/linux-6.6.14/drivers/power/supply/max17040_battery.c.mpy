{
  "module_name": "max17040_battery.c",
  "hash_id": "0403179fca48e759b24e09e394e966fba7115bcb18b16771a997612a3735c00c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max17040_battery.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/power_supply.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define MAX17040_VCELL\t0x02\n#define MAX17040_SOC\t0x04\n#define MAX17040_MODE\t0x06\n#define MAX17040_VER\t0x08\n#define MAX17040_CONFIG\t0x0C\n#define MAX17040_STATUS\t0x1A\n#define MAX17040_CMD\t0xFE\n\n\n#define MAX17040_DELAY\t\t1000\n#define MAX17040_BATTERY_FULL\t95\n#define MAX17040_RCOMP_DEFAULT  0x9700\n\n#define MAX17040_ATHD_MASK\t\t0x3f\n#define MAX17040_ALSC_MASK\t\t0x40\n#define MAX17040_ATHD_DEFAULT_POWER_UP\t4\n#define MAX17040_STATUS_HD_MASK\t\t0x1000\n#define MAX17040_STATUS_SC_MASK\t\t0x2000\n#define MAX17040_CFG_RCOMP_MASK\t\t0xff00\n\nenum chip_id {\n\tID_MAX17040,\n\tID_MAX17041,\n\tID_MAX17043,\n\tID_MAX17044,\n\tID_MAX17048,\n\tID_MAX17049,\n\tID_MAX17058,\n\tID_MAX17059,\n};\n\n \nstruct chip_data {\n\tu16 reset_val;\n\tu16 vcell_shift;\n\tu16 vcell_mul;\n\tu16 vcell_div;\n\tu8  has_low_soc_alert;\n\tu8  rcomp_bytes;\n\tu8  has_soc_alert;\n};\n\nstatic struct chip_data max17040_family[] = {\n\t[ID_MAX17040] = {\n\t\t.reset_val = 0x0054,\n\t\t.vcell_shift = 4,\n\t\t.vcell_mul = 1250,\n\t\t.vcell_div = 1,\n\t\t.has_low_soc_alert = 0,\n\t\t.rcomp_bytes = 2,\n\t\t.has_soc_alert = 0,\n\t},\n\t[ID_MAX17041] = {\n\t\t.reset_val = 0x0054,\n\t\t.vcell_shift = 4,\n\t\t.vcell_mul = 2500,\n\t\t.vcell_div = 1,\n\t\t.has_low_soc_alert = 0,\n\t\t.rcomp_bytes = 2,\n\t\t.has_soc_alert = 0,\n\t},\n\t[ID_MAX17043] = {\n\t\t.reset_val = 0x0054,\n\t\t.vcell_shift = 4,\n\t\t.vcell_mul = 1250,\n\t\t.vcell_div = 1,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 0,\n\t},\n\t[ID_MAX17044] = {\n\t\t.reset_val = 0x0054,\n\t\t.vcell_shift = 4,\n\t\t.vcell_mul = 2500,\n\t\t.vcell_div = 1,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 0,\n\t},\n\t[ID_MAX17048] = {\n\t\t.reset_val = 0x5400,\n\t\t.vcell_shift = 0,\n\t\t.vcell_mul = 625,\n\t\t.vcell_div = 8,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 1,\n\t},\n\t[ID_MAX17049] = {\n\t\t.reset_val = 0x5400,\n\t\t.vcell_shift = 0,\n\t\t.vcell_mul = 625,\n\t\t.vcell_div = 4,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 1,\n\t},\n\t[ID_MAX17058] = {\n\t\t.reset_val = 0x5400,\n\t\t.vcell_shift = 0,\n\t\t.vcell_mul = 625,\n\t\t.vcell_div = 8,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 0,\n\t},\n\t[ID_MAX17059] = {\n\t\t.reset_val = 0x5400,\n\t\t.vcell_shift = 0,\n\t\t.vcell_mul = 625,\n\t\t.vcell_div = 4,\n\t\t.has_low_soc_alert = 1,\n\t\t.rcomp_bytes = 1,\n\t\t.has_soc_alert = 0,\n\t},\n};\n\nstruct max17040_chip {\n\tstruct i2c_client\t\t*client;\n\tstruct regmap\t\t\t*regmap;\n\tstruct delayed_work\t\twork;\n\tstruct power_supply\t\t*battery;\n\tstruct chip_data\t\tdata;\n\n\t \n\tint soc;\n\t \n\tu32 low_soc_alert;\n\t \n\tbool quirk_double_soc;\n\t \n\tu16 rcomp;\n};\n\nstatic int max17040_reset(struct max17040_chip *chip)\n{\n\treturn regmap_write(chip->regmap, MAX17040_CMD, chip->data.reset_val);\n}\n\nstatic int max17040_set_low_soc_alert(struct max17040_chip *chip, u32 level)\n{\n\tlevel = 32 - level * (chip->quirk_double_soc ? 2 : 1);\n\treturn regmap_update_bits(chip->regmap, MAX17040_CONFIG,\n\t\t\tMAX17040_ATHD_MASK, level);\n}\n\nstatic int max17040_set_soc_alert(struct max17040_chip *chip, bool enable)\n{\n\treturn regmap_update_bits(chip->regmap, MAX17040_CONFIG,\n\t\t\tMAX17040_ALSC_MASK, enable ? MAX17040_ALSC_MASK : 0);\n}\n\nstatic int max17040_set_rcomp(struct max17040_chip *chip, u16 rcomp)\n{\n\tu16 mask = chip->data.rcomp_bytes == 2 ?\n\t\t0xffff : MAX17040_CFG_RCOMP_MASK;\n\n\treturn regmap_update_bits(chip->regmap, MAX17040_CONFIG, mask, rcomp);\n}\n\nstatic int max17040_raw_vcell_to_uvolts(struct max17040_chip *chip, u16 vcell)\n{\n\tstruct chip_data *d = &chip->data;\n\n\treturn (vcell >> d->vcell_shift) * d->vcell_mul / d->vcell_div;\n}\n\n\nstatic int max17040_get_vcell(struct max17040_chip *chip)\n{\n\tu32 vcell;\n\n\tregmap_read(chip->regmap, MAX17040_VCELL, &vcell);\n\n\treturn max17040_raw_vcell_to_uvolts(chip, vcell);\n}\n\nstatic int max17040_get_soc(struct max17040_chip *chip)\n{\n\tu32 soc;\n\n\tregmap_read(chip->regmap, MAX17040_SOC, &soc);\n\n\treturn soc >> (chip->quirk_double_soc ? 9 : 8);\n}\n\nstatic int max17040_get_version(struct max17040_chip *chip)\n{\n\tint ret;\n\tu32 version;\n\n\tret = regmap_read(chip->regmap, MAX17040_VER, &version);\n\n\treturn ret ? ret : version;\n}\n\nstatic int max17040_get_online(struct max17040_chip *chip)\n{\n\treturn 1;\n}\n\nstatic int max17040_get_of_data(struct max17040_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tstruct chip_data *data = &max17040_family[\n\t\t(uintptr_t) of_device_get_match_data(dev)];\n\tint rcomp_len;\n\tu8 rcomp[2];\n\n\tchip->quirk_double_soc = device_property_read_bool(dev,\n\t\t\t\t\t\t\t   \"maxim,double-soc\");\n\n\tchip->low_soc_alert = MAX17040_ATHD_DEFAULT_POWER_UP;\n\tdevice_property_read_u32(dev,\n\t\t\t\t \"maxim,alert-low-soc-level\",\n\t\t\t\t &chip->low_soc_alert);\n\n\tif (chip->low_soc_alert <= 0 ||\n\t    chip->low_soc_alert > (chip->quirk_double_soc ? 16 : 32)) {\n\t\tdev_err(dev, \"maxim,alert-low-soc-level out of bounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trcomp_len = device_property_count_u8(dev, \"maxim,rcomp\");\n\tchip->rcomp = MAX17040_RCOMP_DEFAULT;\n\tif (rcomp_len == data->rcomp_bytes) {\n\t\tif (!device_property_read_u8_array(dev, \"maxim,rcomp\",\n\t\t\t\t\t\t   rcomp, rcomp_len))\n\t\t\tchip->rcomp = rcomp_len == 2 ? rcomp[0] << 8 | rcomp[1] :\n\t\t\t\t      rcomp[0] << 8;\n\t} else if (rcomp_len > 0) {\n\t\tdev_err(dev, \"maxim,rcomp has incorrect length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void max17040_check_changes(struct max17040_chip *chip)\n{\n\tchip->soc = max17040_get_soc(chip);\n}\n\nstatic void max17040_queue_work(struct max17040_chip *chip)\n{\n\tqueue_delayed_work(system_power_efficient_wq, &chip->work,\n\t\t\t   MAX17040_DELAY);\n}\n\nstatic void max17040_stop_work(void *data)\n{\n\tstruct max17040_chip *chip = data;\n\n\tcancel_delayed_work_sync(&chip->work);\n}\n\nstatic void max17040_work(struct work_struct *work)\n{\n\tstruct max17040_chip *chip;\n\tint last_soc;\n\n\tchip = container_of(work, struct max17040_chip, work.work);\n\n\t \n\tlast_soc = chip->soc;\n\tmax17040_check_changes(chip);\n\n\t \n\tif (last_soc != chip->soc)\n\t\tpower_supply_changed(chip->battery);\n\n\tmax17040_queue_work(chip);\n}\n\n \nstatic bool max17040_handle_soc_alert(struct max17040_chip *chip)\n{\n\tbool ret = true;\n\tu32 data;\n\n\tregmap_read(chip->regmap, MAX17040_STATUS, &data);\n\n\tif (data & MAX17040_STATUS_HD_MASK) {\n\t\t\n\t\tret = false;\n\t}\n\tif (data & MAX17040_STATUS_SC_MASK) {\n\t\t\n\t\tregmap_write(chip->regmap, MAX17040_STATUS,\n\t\t\t\tdata & ~MAX17040_STATUS_SC_MASK);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t max17040_thread_handler(int id, void *dev)\n{\n\tstruct max17040_chip *chip = dev;\n\n\tif (!(chip->data.has_soc_alert && max17040_handle_soc_alert(chip)))\n\t\tdev_warn(&chip->client->dev, \"IRQ: Alert battery low level\\n\");\n\n\t \n\tmax17040_check_changes(chip);\n\n\t \n\tpower_supply_changed(chip->battery);\n\n\t \n\tmax17040_set_low_soc_alert(chip, chip->low_soc_alert);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max17040_enable_alert_irq(struct max17040_chip *chip)\n{\n\tstruct i2c_client *client = chip->client;\n\tint ret;\n\n\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\tmax17040_thread_handler, IRQF_ONESHOT,\n\t\t\t\t\tchip->battery->desc->name, chip);\n\n\treturn ret;\n}\n\nstatic int max17040_prop_writeable(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int max17040_set_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    const union power_supply_propval *val)\n{\n\tstruct max17040_chip *chip = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\t \n\t\tif ((val->intval < 1) ||\n\t\t    (val->intval > (chip->quirk_double_soc ? 16 : 32))) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = max17040_set_low_soc_alert(chip, val->intval);\n\t\tchip->low_soc_alert = val->intval;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int max17040_get_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tstruct max17040_chip *chip = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = max17040_get_online(chip);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = max17040_get_vcell(chip);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = max17040_get_soc(chip);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\tval->intval = chip->low_soc_alert;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct regmap_config max17040_regmap = {\n\t.reg_bits\t= 8,\n\t.reg_stride\t= 2,\n\t.val_bits\t= 16,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic enum power_supply_property max17040_battery_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_ALERT_MIN,\n};\n\nstatic const struct power_supply_desc max17040_battery_desc = {\n\t.name\t\t\t= \"battery\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t\t= max17040_get_property,\n\t.set_property\t\t= max17040_set_property,\n\t.property_is_writeable  = max17040_prop_writeable,\n\t.properties\t\t= max17040_battery_props,\n\t.num_properties\t\t= ARRAY_SIZE(max17040_battery_props),\n};\n\nstatic int max17040_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct max17040_chip *chip;\n\tenum chip_id chip_id;\n\tbool enable_irq = false;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -EIO;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tchip->regmap = devm_regmap_init_i2c(client, &max17040_regmap);\n\tif (IS_ERR(chip->regmap))\n\t\treturn PTR_ERR(chip->regmap);\n\tchip_id = (enum chip_id) id->driver_data;\n\tif (client->dev.of_node) {\n\t\tret = max17040_get_of_data(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tchip_id = (uintptr_t)of_device_get_match_data(&client->dev);\n\t}\n\tchip->data = max17040_family[chip_id];\n\n\ti2c_set_clientdata(client, chip);\n\tpsy_cfg.drv_data = chip;\n\n\tchip->battery = devm_power_supply_register(&client->dev,\n\t\t\t\t&max17040_battery_desc, &psy_cfg);\n\tif (IS_ERR(chip->battery)) {\n\t\tdev_err(&client->dev, \"failed: power supply register\\n\");\n\t\treturn PTR_ERR(chip->battery);\n\t}\n\n\tret = max17040_get_version(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_dbg(&chip->client->dev, \"MAX17040 Fuel-Gauge Ver 0x%x\\n\", ret);\n\n\tif (chip_id == ID_MAX17040 || chip_id == ID_MAX17041)\n\t\tmax17040_reset(chip);\n\n\tmax17040_set_rcomp(chip, chip->rcomp);\n\n\t \n\tif (client->irq && chip->data.has_low_soc_alert) {\n\t\tret = max17040_set_low_soc_alert(chip, chip->low_soc_alert);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to set low SOC alert: err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tenable_irq = true;\n\t}\n\n\tif (client->irq && chip->data.has_soc_alert) {\n\t\tret = max17040_set_soc_alert(chip, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to set SOC alert: err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tenable_irq = true;\n\t} else {\n\t\t \n\t\tINIT_DEFERRABLE_WORK(&chip->work, max17040_work);\n\t\tret = devm_add_action(&client->dev, max17040_stop_work, chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmax17040_queue_work(chip);\n\t}\n\n\tif (enable_irq) {\n\t\tret = max17040_enable_alert_irq(chip);\n\t\tif (ret) {\n\t\t\tclient->irq = 0;\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"Failed to get IRQ err %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int max17040_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max17040_chip *chip = i2c_get_clientdata(client);\n\n\tif (client->irq && chip->data.has_soc_alert)\n\t\t\n\t\tmax17040_set_soc_alert(chip, 0);\n\telse\n\t\tcancel_delayed_work(&chip->work);\n\n\tif (client->irq && device_may_wakeup(dev))\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int max17040_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct max17040_chip *chip = i2c_get_clientdata(client);\n\n\tif (client->irq && device_may_wakeup(dev))\n\t\tdisable_irq_wake(client->irq);\n\n\tif (client->irq && chip->data.has_soc_alert)\n\t\tmax17040_set_soc_alert(chip, 1);\n\telse\n\t\tmax17040_queue_work(chip);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(max17040_pm_ops, max17040_suspend, max17040_resume);\n#define MAX17040_PM_OPS (&max17040_pm_ops)\n\n#else\n\n#define MAX17040_PM_OPS NULL\n\n#endif  \n\nstatic const struct i2c_device_id max17040_id[] = {\n\t{ \"max17040\", ID_MAX17040 },\n\t{ \"max17041\", ID_MAX17041 },\n\t{ \"max17043\", ID_MAX17043 },\n\t{ \"max77836-battery\", ID_MAX17043 },\n\t{ \"max17044\", ID_MAX17044 },\n\t{ \"max17048\", ID_MAX17048 },\n\t{ \"max17049\", ID_MAX17049 },\n\t{ \"max17058\", ID_MAX17058 },\n\t{ \"max17059\", ID_MAX17059 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, max17040_id);\n\nstatic const struct of_device_id max17040_of_match[] = {\n\t{ .compatible = \"maxim,max17040\", .data = (void *) ID_MAX17040 },\n\t{ .compatible = \"maxim,max17041\", .data = (void *) ID_MAX17041 },\n\t{ .compatible = \"maxim,max17043\", .data = (void *) ID_MAX17043 },\n\t{ .compatible = \"maxim,max77836-battery\", .data = (void *) ID_MAX17043 },\n\t{ .compatible = \"maxim,max17044\", .data = (void *) ID_MAX17044 },\n\t{ .compatible = \"maxim,max17048\", .data = (void *) ID_MAX17048 },\n\t{ .compatible = \"maxim,max17049\", .data = (void *) ID_MAX17049 },\n\t{ .compatible = \"maxim,max17058\", .data = (void *) ID_MAX17058 },\n\t{ .compatible = \"maxim,max17059\", .data = (void *) ID_MAX17059 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, max17040_of_match);\n\nstatic struct i2c_driver max17040_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"max17040\",\n\t\t.of_match_table = max17040_of_match,\n\t\t.pm\t= MAX17040_PM_OPS,\n\t},\n\t.probe\t\t= max17040_probe,\n\t.id_table\t= max17040_id,\n};\nmodule_i2c_driver(max17040_i2c_driver);\n\nMODULE_AUTHOR(\"Minkyu Kang <mk7.kang@samsung.com>\");\nMODULE_DESCRIPTION(\"MAX17040 Fuel Gauge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}