{
  "module_name": "ab8500_fg.c",
  "hash_id": "79e2f7f0a27868c89a97c4d4c8d0b9aa6f2c05541596fcc53f8205c1e621cfea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ab8500_fg.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/time64.h>\n#include <linux/of.h>\n#include <linux/completion.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/iio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/fixp-arith.h>\n\n#include \"ab8500-bm.h\"\n\n#define FG_LSB_IN_MA\t\t\t1627\n#define QLSB_NANO_AMP_HOURS_X10\t\t1071\n#define INS_CURR_TIMEOUT\t\t(3 * HZ)\n\n#define SEC_TO_SAMPLE(S)\t\t(S * 4)\n\n#define NBR_AVG_SAMPLES\t\t\t20\n#define WAIT_FOR_INST_CURRENT_MAX\t70\n \n#define IGNORE_VBAT_HIGHCUR\t\t-500000\n\n#define LOW_BAT_CHECK_INTERVAL\t\t(HZ / 16)  \n\n#define VALID_CAPACITY_SEC\t\t(45 * 60)  \n#define BATT_OK_MIN\t\t\t2360  \n#define BATT_OK_INCREMENT\t\t50  \n#define BATT_OK_MAX_NR_INCREMENTS\t0xE\n\n \n#define BATT_OVV\t\t\t0x01\n\n \nstruct ab8500_fg_interrupts {\n\tchar *name;\n\tirqreturn_t (*isr)(int irq, void *data);\n};\n\nenum ab8500_fg_discharge_state {\n\tAB8500_FG_DISCHARGE_INIT,\n\tAB8500_FG_DISCHARGE_INITMEASURING,\n\tAB8500_FG_DISCHARGE_INIT_RECOVERY,\n\tAB8500_FG_DISCHARGE_RECOVERY,\n\tAB8500_FG_DISCHARGE_READOUT_INIT,\n\tAB8500_FG_DISCHARGE_READOUT,\n\tAB8500_FG_DISCHARGE_WAKEUP,\n};\n\nstatic char *discharge_state[] = {\n\t\"DISCHARGE_INIT\",\n\t\"DISCHARGE_INITMEASURING\",\n\t\"DISCHARGE_INIT_RECOVERY\",\n\t\"DISCHARGE_RECOVERY\",\n\t\"DISCHARGE_READOUT_INIT\",\n\t\"DISCHARGE_READOUT\",\n\t\"DISCHARGE_WAKEUP\",\n};\n\nenum ab8500_fg_charge_state {\n\tAB8500_FG_CHARGE_INIT,\n\tAB8500_FG_CHARGE_READOUT,\n};\n\nstatic char *charge_state[] = {\n\t\"CHARGE_INIT\",\n\t\"CHARGE_READOUT\",\n};\n\nenum ab8500_fg_calibration_state {\n\tAB8500_FG_CALIB_INIT,\n\tAB8500_FG_CALIB_WAIT,\n\tAB8500_FG_CALIB_END,\n};\n\nstruct ab8500_fg_avg_cap {\n\tint avg;\n\tint samples[NBR_AVG_SAMPLES];\n\ttime64_t time_stamps[NBR_AVG_SAMPLES];\n\tint pos;\n\tint nbr_samples;\n\tint sum;\n};\n\nstruct ab8500_fg_cap_scaling {\n\tbool enable;\n\tint cap_to_scale[2];\n\tint disable_cap_level;\n\tint scaled_cap;\n};\n\nstruct ab8500_fg_battery_capacity {\n\tint max_mah_design;\n\tint max_mah;\n\tint mah;\n\tint permille;\n\tint level;\n\tint prev_mah;\n\tint prev_percent;\n\tint prev_level;\n\tint user_mah;\n\tstruct ab8500_fg_cap_scaling cap_scale;\n};\n\nstruct ab8500_fg_flags {\n\tbool fg_enabled;\n\tbool conv_done;\n\tbool charging;\n\tbool fully_charged;\n\tbool force_full;\n\tbool low_bat_delay;\n\tbool low_bat;\n\tbool bat_ovv;\n\tbool batt_unknown;\n\tbool calibrate;\n\tbool user_cap;\n\tbool batt_id_received;\n};\n\nstruct inst_curr_result_list {\n\tstruct list_head list;\n\tint *result;\n};\n\n \nstruct ab8500_fg {\n\tstruct device *dev;\n\tstruct list_head node;\n\tint irq;\n\tint vbat_uv;\n\tint vbat_nom_uv;\n\tint inst_curr_ua;\n\tint avg_curr_ua;\n\tint bat_temp;\n\tint fg_samples;\n\tint accu_charge;\n\tint recovery_cnt;\n\tint high_curr_cnt;\n\tint init_cnt;\n\tint low_bat_cnt;\n\tint nbr_cceoc_irq_cnt;\n\tu32 line_impedance_uohm;\n\tbool recovery_needed;\n\tbool high_curr_mode;\n\tbool init_capacity;\n\tbool turn_off_fg;\n\tenum ab8500_fg_calibration_state calib_state;\n\tenum ab8500_fg_discharge_state discharge_state;\n\tenum ab8500_fg_charge_state charge_state;\n\tstruct completion ab8500_fg_started;\n\tstruct completion ab8500_fg_complete;\n\tstruct ab8500_fg_flags flags;\n\tstruct ab8500_fg_battery_capacity bat_cap;\n\tstruct ab8500_fg_avg_cap avg_cap;\n\tstruct ab8500 *parent;\n\tstruct iio_channel *main_bat_v;\n\tstruct ab8500_bm_data *bm;\n\tstruct power_supply *fg_psy;\n\tstruct workqueue_struct *fg_wq;\n\tstruct delayed_work fg_periodic_work;\n\tstruct delayed_work fg_low_bat_work;\n\tstruct delayed_work fg_reinit_work;\n\tstruct work_struct fg_work;\n\tstruct work_struct fg_acc_cur_work;\n\tstruct delayed_work fg_check_hw_failure_work;\n\tstruct mutex cc_lock;\n\tstruct kobject fg_kobject;\n};\nstatic LIST_HEAD(ab8500_fg_list);\n\n \nstruct ab8500_fg *ab8500_fg_get(void)\n{\n\treturn list_first_entry_or_null(&ab8500_fg_list, struct ab8500_fg,\n\t\t\t\t\tnode);\n}\n\n \nstatic enum power_supply_property ab8500_fg_props[] = {\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n};\n\n \nstatic int ab8500_fg_lowbat_voltage_map[] = {\n\t2300000,\n\t2325000,\n\t2350000,\n\t2375000,\n\t2400000,\n\t2425000,\n\t2450000,\n\t2475000,\n\t2500000,\n\t2525000,\n\t2550000,\n\t2575000,\n\t2600000,\n\t2625000,\n\t2650000,\n\t2675000,\n\t2700000,\n\t2725000,\n\t2750000,\n\t2775000,\n\t2800000,\n\t2825000,\n\t2850000,\n\t2875000,\n\t2900000,\n\t2925000,\n\t2950000,\n\t2975000,\n\t3000000,\n\t3025000,\n\t3050000,\n\t3075000,\n\t3100000,\n\t3125000,\n\t3150000,\n\t3175000,\n\t3200000,\n\t3225000,\n\t3250000,\n\t3275000,\n\t3300000,\n\t3325000,\n\t3350000,\n\t3375000,\n\t3400000,\n\t3425000,\n\t3450000,\n\t3475000,\n\t3500000,\n\t3525000,\n\t3550000,\n\t3575000,\n\t3600000,\n\t3625000,\n\t3650000,\n\t3675000,\n\t3700000,\n\t3725000,\n\t3750000,\n\t3775000,\n\t3800000,\n\t3825000,\n\t3850000,\n\t3850000,\n};\n\nstatic u8 ab8500_volt_to_regval(int voltage_uv)\n{\n\tint i;\n\n\tif (voltage_uv < ab8500_fg_lowbat_voltage_map[0])\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ab8500_fg_lowbat_voltage_map); i++) {\n\t\tif (voltage_uv < ab8500_fg_lowbat_voltage_map[i])\n\t\t\treturn (u8) i - 1;\n\t}\n\n\t \n\treturn (u8) ARRAY_SIZE(ab8500_fg_lowbat_voltage_map) - 1;\n}\n\n \nstatic int ab8500_fg_is_low_curr(struct ab8500_fg *di, int curr_ua)\n{\n\t \n\tif (curr_ua > -di->bm->fg_params->high_curr_threshold_ua)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic int ab8500_fg_add_cap_sample(struct ab8500_fg *di, int sample)\n{\n\ttime64_t now = ktime_get_boottime_seconds();\n\tstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\n\n\tdo {\n\t\tavg->sum += sample - avg->samples[avg->pos];\n\t\tavg->samples[avg->pos] = sample;\n\t\tavg->time_stamps[avg->pos] = now;\n\t\tavg->pos++;\n\n\t\tif (avg->pos == NBR_AVG_SAMPLES)\n\t\t\tavg->pos = 0;\n\n\t\tif (avg->nbr_samples < NBR_AVG_SAMPLES)\n\t\t\tavg->nbr_samples++;\n\n\t\t \n\t} while (now - VALID_CAPACITY_SEC > avg->time_stamps[avg->pos]);\n\n\tavg->avg = avg->sum / avg->nbr_samples;\n\n\treturn avg->avg;\n}\n\n \nstatic void ab8500_fg_clear_cap_samples(struct ab8500_fg *di)\n{\n\tint i;\n\tstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\n\n\tavg->pos = 0;\n\tavg->nbr_samples = 0;\n\tavg->sum = 0;\n\tavg->avg = 0;\n\n\tfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\n\t\tavg->samples[i] = 0;\n\t\tavg->time_stamps[i] = 0;\n\t}\n}\n\n \nstatic void ab8500_fg_fill_cap_sample(struct ab8500_fg *di, int sample)\n{\n\tint i;\n\ttime64_t now;\n\tstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\n\n\tnow = ktime_get_boottime_seconds();\n\n\tfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\n\t\tavg->samples[i] = sample;\n\t\tavg->time_stamps[i] = now;\n\t}\n\n\tavg->pos = 0;\n\tavg->nbr_samples = NBR_AVG_SAMPLES;\n\tavg->sum = sample * NBR_AVG_SAMPLES;\n\tavg->avg = sample;\n}\n\n \nstatic int ab8500_fg_coulomb_counter(struct ab8500_fg *di, bool enable)\n{\n\tint ret = 0;\n\tmutex_lock(&di->cc_lock);\n\tif (enable) {\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CC_CONF_REG, 0x00);\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\n\t\t\tdi->fg_samples);\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CC_CONF_REG,\n\t\t\t(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\tdi->flags.fg_enabled = true;\n\t} else {\n\t\t \n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\n\t\t\t(RESET_ACCU | READ_REQ), 0);\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU_CTRL, 0);\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CC_CONF_REG, 0);\n\t\tif (ret)\n\t\t\tgoto cc_err;\n\n\t\tdi->flags.fg_enabled = false;\n\n\t}\n\tdev_dbg(di->dev, \" CC enabled: %d Samples: %d\\n\",\n\t\tenable, di->fg_samples);\n\n\tmutex_unlock(&di->cc_lock);\n\n\treturn ret;\ncc_err:\n\tdev_err(di->dev, \"%s Enabling coulomb counter failed\\n\", __func__);\n\tmutex_unlock(&di->cc_lock);\n\treturn ret;\n}\n\n \nint ab8500_fg_inst_curr_start(struct ab8500_fg *di)\n{\n\tu8 reg_val;\n\tint ret;\n\n\tmutex_lock(&di->cc_lock);\n\n\tdi->nbr_cceoc_irq_cnt = 0;\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8500_RTC_CC_CONF_REG, &reg_val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (!(reg_val & CC_PWR_UP_ENA)) {\n\t\tdev_dbg(di->dev, \"%s Enable FG\\n\", __func__);\n\t\tdi->turn_off_fg = true;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\n\t\t\tSEC_TO_SAMPLE(10));\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CC_CONF_REG,\n\t\t\t(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\n\t\tif (ret)\n\t\t\tgoto fail;\n\t} else {\n\t\tdi->turn_off_fg = false;\n\t}\n\n\t \n\treinit_completion(&di->ab8500_fg_started);\n\treinit_completion(&di->ab8500_fg_complete);\n\tenable_irq(di->irq);\n\n\t \n\treturn 0;\nfail:\n\tmutex_unlock(&di->cc_lock);\n\treturn ret;\n}\n\n \nint ab8500_fg_inst_curr_started(struct ab8500_fg *di)\n{\n\treturn completion_done(&di->ab8500_fg_started);\n}\n\n \nint ab8500_fg_inst_curr_done(struct ab8500_fg *di)\n{\n\treturn completion_done(&di->ab8500_fg_complete);\n}\n\n \nint ab8500_fg_inst_curr_finalize(struct ab8500_fg *di, int *curr_ua)\n{\n\tu8 low, high;\n\tint val;\n\tint ret;\n\tunsigned long timeout;\n\n\tif (!completion_done(&di->ab8500_fg_complete)) {\n\t\ttimeout = wait_for_completion_timeout(\n\t\t\t&di->ab8500_fg_complete,\n\t\t\tINS_CURR_TIMEOUT);\n\t\tdev_dbg(di->dev, \"Finalize time: %d ms\\n\",\n\t\t\tjiffies_to_msecs(INS_CURR_TIMEOUT - timeout));\n\t\tif (!timeout) {\n\t\t\tret = -ETIME;\n\t\t\tdisable_irq(di->irq);\n\t\t\tdi->nbr_cceoc_irq_cnt = 0;\n\t\t\tdev_err(di->dev, \"completion timed out [%d]\\n\",\n\t\t\t\t__LINE__);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdisable_irq(di->irq);\n\tdi->nbr_cceoc_irq_cnt = 0;\n\n\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\n\t\t\tREAD_REQ, READ_REQ);\n\n\t \n\tusleep_range(100, 100);\n\n\t \n\tret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_SMPL_CNVL_REG,  &low);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_SMPL_CNVH_REG,  &high);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tif (high & 0x10)\n\t\tval = (low | (high << 8) | 0xFFFFE000);\n\telse\n\t\tval = (low | (high << 8));\n\n\t \n\tval = (val * QLSB_NANO_AMP_HOURS_X10 * 36 * 4) / di->bm->fg_res;\n\n\tif (di->turn_off_fg) {\n\t\tdev_dbg(di->dev, \"%s Disable FG\\n\", __func__);\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG, 0);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8500_RTC_CC_CONF_REG, 0);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\tmutex_unlock(&di->cc_lock);\n\t*curr_ua = val;\n\n\treturn 0;\nfail:\n\tmutex_unlock(&di->cc_lock);\n\treturn ret;\n}\n\n \nint ab8500_fg_inst_curr_blocking(struct ab8500_fg *di)\n{\n\tint ret;\n\tunsigned long timeout;\n\tint curr_ua = 0;\n\n\tret = ab8500_fg_inst_curr_start(di);\n\tif (ret) {\n\t\tdev_err(di->dev, \"Failed to initialize fg_inst\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!completion_done(&di->ab8500_fg_started)) {\n\t\ttimeout = wait_for_completion_timeout(\n\t\t\t&di->ab8500_fg_started,\n\t\t\tINS_CURR_TIMEOUT);\n\t\tdev_dbg(di->dev, \"Start time: %d ms\\n\",\n\t\t\tjiffies_to_msecs(INS_CURR_TIMEOUT - timeout));\n\t\tif (!timeout) {\n\t\t\tret = -ETIME;\n\t\t\tdev_err(di->dev, \"completion timed out [%d]\\n\",\n\t\t\t\t__LINE__);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tret = ab8500_fg_inst_curr_finalize(di, &curr_ua);\n\tif (ret) {\n\t\tdev_err(di->dev, \"Failed to finalize fg_inst\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(di->dev, \"%s instant current: %d uA\", __func__, curr_ua);\n\treturn curr_ua;\nfail:\n\tdisable_irq(di->irq);\n\tmutex_unlock(&di->cc_lock);\n\treturn ret;\n}\n\n \nstatic void ab8500_fg_acc_cur_work(struct work_struct *work)\n{\n\tint val;\n\tint ret;\n\tu8 low, med, high;\n\n\tstruct ab8500_fg *di = container_of(work,\n\t\tstruct ab8500_fg, fg_acc_cur_work);\n\n\tmutex_lock(&di->cc_lock);\n\tret = abx500_set_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_NCOV_ACCU_CTRL, RD_NCONV_ACCU_REQ);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_NCOV_ACCU_LOW,  &low);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_NCOV_ACCU_MED,  &med);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\n\t\tAB8500_GASG_CC_NCOV_ACCU_HIGH, &high);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tif (high & 0x10)\n\t\tval = (low | (med << 8) | (high << 16) | 0xFFE00000);\n\telse\n\t\tval = (low | (med << 8) | (high << 16));\n\n\t \n\tdi->accu_charge = (val * QLSB_NANO_AMP_HOURS_X10) /\n\t\t(100 * di->bm->fg_res);\n\n\t \n\tdi->avg_curr_ua = (val * QLSB_NANO_AMP_HOURS_X10 * 36) /\n\t\t(di->bm->fg_res * (di->fg_samples / 4));\n\n\tdi->flags.conv_done = true;\n\n\tmutex_unlock(&di->cc_lock);\n\n\tqueue_work(di->fg_wq, &di->fg_work);\n\n\tdev_dbg(di->dev, \"fg_res: %d, fg_samples: %d, gasg: %d, accu_charge: %d \\n\",\n\t\t\t\tdi->bm->fg_res, di->fg_samples, val, di->accu_charge);\n\treturn;\nexit:\n\tdev_err(di->dev,\n\t\t\"Failed to read or write gas gauge registers\\n\");\n\tmutex_unlock(&di->cc_lock);\n\tqueue_work(di->fg_wq, &di->fg_work);\n}\n\n \nstatic int ab8500_fg_bat_voltage(struct ab8500_fg *di)\n{\n\tint vbat, ret;\n\tstatic int prev;\n\n\tret = iio_read_channel_processed(di->main_bat_v, &vbat);\n\tif (ret < 0) {\n\t\tdev_err(di->dev,\n\t\t\t\"%s ADC conversion failed, using previous value\\n\",\n\t\t\t__func__);\n\t\treturn prev;\n\t}\n\n\t \n\tvbat *= 1000;\n\tprev = vbat;\n\treturn vbat;\n}\n\n \nstatic int ab8500_fg_volt_to_capacity(struct ab8500_fg *di, int voltage_uv)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\n\t \n\treturn power_supply_batinfo_ocv2cap(bi, voltage_uv, di->bat_temp) *  10;\n}\n\n \nstatic int ab8500_fg_uncomp_volt_to_capacity(struct ab8500_fg *di)\n{\n\tdi->vbat_uv = ab8500_fg_bat_voltage(di);\n\treturn ab8500_fg_volt_to_capacity(di, di->vbat_uv);\n}\n\n \nstatic int ab8500_fg_battery_resistance(struct ab8500_fg *di, int vbat_uncomp_uv)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\tint resistance_percent = 0;\n\tint resistance;\n\n\t \n\tif (power_supply_supports_vbat2ri(bi)) {\n\t\tresistance = power_supply_vbat2ri(bi, vbat_uncomp_uv, di->flags.charging);\n\t\t \n\t\tresistance = resistance / 1000;\n\t} else if (power_supply_supports_temp2ri(bi)) {\n\t\tresistance_percent = power_supply_temp2resist_simple(bi->resist_table,\n\t\t\t\t\t\t\t\t     bi->resist_table_size,\n\t\t\t\t\t\t\t\t     di->bat_temp / 10);\n\t\t \n\t\tresistance = bi->factory_internal_resistance_uohm / 1000;\n\t\tresistance = resistance * resistance_percent / 100;\n\t} else {\n\t\t \n\t\tresistance = bi->factory_internal_resistance_uohm / 1000;\n\t}\n\n\t \n\tresistance += (di->line_impedance_uohm / 1000);\n\n\tdev_dbg(di->dev, \"%s Temp: %d battery internal resistance: %d\"\n\t    \" fg resistance %d, total: %d (mOhm)\\n\",\n\t\t__func__, di->bat_temp, resistance, di->bm->fg_res / 10,\n\t\t(di->bm->fg_res / 10) + resistance);\n\n\t \n\tresistance += di->bm->fg_res / 10;\n\n\treturn resistance;\n}\n\n \nstatic int ab8500_load_comp_fg_bat_voltage(struct ab8500_fg *di, bool always)\n{\n\tint i = 0;\n\tint vbat_uv = 0;\n\tint rcomp;\n\n\t \n\tab8500_fg_inst_curr_start(di);\n\n\tdo {\n\t\tvbat_uv += ab8500_fg_bat_voltage(di);\n\t\ti++;\n\t\tusleep_range(5000, 6000);\n\t} while (!ab8500_fg_inst_curr_done(di) &&\n\t\t i <= WAIT_FOR_INST_CURRENT_MAX);\n\n\tif (i > WAIT_FOR_INST_CURRENT_MAX) {\n\t\tdev_err(di->dev,\n\t\t\t\"TIMEOUT: return uncompensated measurement of VBAT\\n\");\n\t\tdi->vbat_uv = vbat_uv / i;\n\t\treturn di->vbat_uv;\n\t}\n\n\tab8500_fg_inst_curr_finalize(di, &di->inst_curr_ua);\n\n\t \n\tif (!always && di->inst_curr_ua < IGNORE_VBAT_HIGHCUR)\n\t\treturn -EINVAL;\n\n\tvbat_uv = vbat_uv / i;\n\n\t \n\trcomp = ab8500_fg_battery_resistance(di, vbat_uv);\n\tvbat_uv = vbat_uv - (di->inst_curr_ua * rcomp) / 1000;\n\n\t \n\tdi->vbat_uv = vbat_uv;\n\n\treturn vbat_uv;\n}\n\n \nstatic int ab8500_fg_load_comp_volt_to_capacity(struct ab8500_fg *di)\n{\n\tint vbat_comp_uv;\n\n\tvbat_comp_uv = ab8500_load_comp_fg_bat_voltage(di, true);\n\n\treturn ab8500_fg_volt_to_capacity(di, vbat_comp_uv);\n}\n\n \nstatic int ab8500_fg_convert_mah_to_permille(struct ab8500_fg *di, int cap_mah)\n{\n\treturn (cap_mah * 1000) / di->bat_cap.max_mah_design;\n}\n\n \nstatic int ab8500_fg_convert_permille_to_mah(struct ab8500_fg *di, int cap_pm)\n{\n\treturn cap_pm * di->bat_cap.max_mah_design / 1000;\n}\n\n \nstatic int ab8500_fg_convert_mah_to_uwh(struct ab8500_fg *di, int cap_mah)\n{\n\tu64 div_res;\n\tu32 div_rem;\n\n\t \n\tdiv_res = ((u64) cap_mah) * ((u64) di->vbat_nom_uv);\n\tdiv_rem = do_div(div_res, 1000000);\n\n\t \n\tif (div_rem >= 1000000 / 2)\n\t\tdiv_res++;\n\n\treturn (int) div_res;\n}\n\n \nstatic int ab8500_fg_calc_cap_charging(struct ab8500_fg *di)\n{\n\tdev_dbg(di->dev, \"%s cap_mah %d accu_charge %d\\n\",\n\t\t__func__,\n\t\tdi->bat_cap.mah,\n\t\tdi->accu_charge);\n\n\t \n\tif (di->bat_cap.mah + di->accu_charge > 0)\n\t\tdi->bat_cap.mah += di->accu_charge;\n\telse\n\t\tdi->bat_cap.mah = 0;\n\t \n\tif (di->bat_cap.mah >= di->bat_cap.max_mah_design ||\n\t\tdi->flags.force_full) {\n\t\tdi->bat_cap.mah = di->bat_cap.max_mah_design;\n\t}\n\n\tab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\n\tdi->bat_cap.permille =\n\t\tab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\n\n\t \n\tdi->vbat_uv = ab8500_fg_bat_voltage(di);\n\tdi->inst_curr_ua = ab8500_fg_inst_curr_blocking(di);\n\n\treturn di->bat_cap.mah;\n}\n\n \nstatic int ab8500_fg_calc_cap_discharge_voltage(struct ab8500_fg *di)\n{\n\tint permille, mah;\n\n\tpermille = ab8500_fg_load_comp_volt_to_capacity(di);\n\n\tmah = ab8500_fg_convert_permille_to_mah(di, permille);\n\n\tdi->bat_cap.mah = ab8500_fg_add_cap_sample(di, mah);\n\tdi->bat_cap.permille =\n\t\tab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\n\n\treturn di->bat_cap.mah;\n}\n\n \nstatic int ab8500_fg_calc_cap_discharge_fg(struct ab8500_fg *di)\n{\n\tint permille_volt, permille;\n\n\tdev_dbg(di->dev, \"%s cap_mah %d accu_charge %d\\n\",\n\t\t__func__,\n\t\tdi->bat_cap.mah,\n\t\tdi->accu_charge);\n\n\t \n\tif (di->bat_cap.mah + di->accu_charge > 0)\n\t\tdi->bat_cap.mah += di->accu_charge;\n\telse\n\t\tdi->bat_cap.mah = 0;\n\n\tif (di->bat_cap.mah >= di->bat_cap.max_mah_design)\n\t\tdi->bat_cap.mah = di->bat_cap.max_mah_design;\n\n\t \n\tpermille = ab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\n\tpermille_volt = ab8500_fg_uncomp_volt_to_capacity(di);\n\n\tif (permille < permille_volt) {\n\t\tdi->bat_cap.permille = permille_volt;\n\t\tdi->bat_cap.mah = ab8500_fg_convert_permille_to_mah(di,\n\t\t\tdi->bat_cap.permille);\n\n\t\tdev_dbg(di->dev, \"%s voltage based: perm %d perm_volt %d\\n\",\n\t\t\t__func__,\n\t\t\tpermille,\n\t\t\tpermille_volt);\n\n\t\tab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\n\t} else {\n\t\tab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\n\t\tdi->bat_cap.permille =\n\t\t\tab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\n\t}\n\n\treturn di->bat_cap.mah;\n}\n\n \nstatic int ab8500_fg_capacity_level(struct ab8500_fg *di)\n{\n\tint ret, percent;\n\n\tpercent = DIV_ROUND_CLOSEST(di->bat_cap.permille, 10);\n\n\tif (percent <= di->bm->cap_levels->critical ||\n\t\tdi->flags.low_bat)\n\t\tret = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\telse if (percent <= di->bm->cap_levels->low)\n\t\tret = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\telse if (percent <= di->bm->cap_levels->normal)\n\t\tret = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\telse if (percent <= di->bm->cap_levels->high)\n\t\tret = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\n\telse\n\t\tret = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\n\treturn ret;\n}\n\n \nstatic int ab8500_fg_calculate_scaled_capacity(struct ab8500_fg *di)\n{\n\tstruct ab8500_fg_cap_scaling *cs = &di->bat_cap.cap_scale;\n\tint capacity = di->bat_cap.prev_percent;\n\n\tif (!cs->enable)\n\t\treturn capacity;\n\n\t \n\tif (di->flags.fully_charged) {\n\t\tcs->cap_to_scale[0] = 100;\n\t\tcs->cap_to_scale[1] =\n\t\t\tmax(capacity, di->bm->fg_params->maint_thres);\n\t\tdev_dbg(di->dev, \"Scale cap with %d/%d\\n\",\n\t\t\t cs->cap_to_scale[0], cs->cap_to_scale[1]);\n\t}\n\n\t \n\tif ((cs->cap_to_scale[0] != cs->cap_to_scale[1])\n\t\t\t\t\t&& (cs->cap_to_scale[1] > 0))\n\t\tcapacity = min(100,\n\t\t\t\t DIV_ROUND_CLOSEST(di->bat_cap.prev_percent *\n\t\t\t\t\t\t cs->cap_to_scale[0],\n\t\t\t\t\t\t cs->cap_to_scale[1]));\n\n\tif (di->flags.charging) {\n\t\tif (capacity < cs->disable_cap_level) {\n\t\t\tcs->disable_cap_level = capacity;\n\t\t\tdev_dbg(di->dev, \"Cap to stop scale lowered %d%%\\n\",\n\t\t\t\tcs->disable_cap_level);\n\t\t} else if (!di->flags.fully_charged) {\n\t\t\tif (di->bat_cap.prev_percent >=\n\t\t\t    cs->disable_cap_level) {\n\t\t\t\tdev_dbg(di->dev, \"Disabling scaled capacity\\n\");\n\t\t\t\tcs->enable = false;\n\t\t\t\tcapacity = di->bat_cap.prev_percent;\n\t\t\t} else {\n\t\t\t\tdev_dbg(di->dev,\n\t\t\t\t\t\"Waiting in cap to level %d%%\\n\",\n\t\t\t\t\tcs->disable_cap_level);\n\t\t\t\tcapacity = cs->disable_cap_level;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn capacity;\n}\n\n \nstatic void ab8500_fg_update_cap_scalers(struct ab8500_fg *di)\n{\n\tstruct ab8500_fg_cap_scaling *cs = &di->bat_cap.cap_scale;\n\n\tif (!cs->enable)\n\t\treturn;\n\tif (di->flags.charging) {\n\t\tdi->bat_cap.cap_scale.disable_cap_level =\n\t\t\tdi->bat_cap.cap_scale.scaled_cap;\n\t\tdev_dbg(di->dev, \"Cap to stop scale at charge %d%%\\n\",\n\t\t\t\tdi->bat_cap.cap_scale.disable_cap_level);\n\t} else {\n\t\tif (cs->scaled_cap != 100) {\n\t\t\tcs->cap_to_scale[0] = cs->scaled_cap;\n\t\t\tcs->cap_to_scale[1] = di->bat_cap.prev_percent;\n\t\t} else {\n\t\t\tcs->cap_to_scale[0] = 100;\n\t\t\tcs->cap_to_scale[1] =\n\t\t\t\tmax(di->bat_cap.prev_percent,\n\t\t\t\t    di->bm->fg_params->maint_thres);\n\t\t}\n\n\t\tdev_dbg(di->dev, \"Cap to scale at discharge %d/%d\\n\",\n\t\t\t\tcs->cap_to_scale[0], cs->cap_to_scale[1]);\n\t}\n}\n\n \nstatic void ab8500_fg_check_capacity_limits(struct ab8500_fg *di, bool init)\n{\n\tbool changed = false;\n\tint percent = DIV_ROUND_CLOSEST(di->bat_cap.permille, 10);\n\n\tdi->bat_cap.level = ab8500_fg_capacity_level(di);\n\n\tif (di->bat_cap.level != di->bat_cap.prev_level) {\n\t\t \n\t\tif (!(!di->flags.charging && di->bat_cap.level >\n\t\t\tdi->bat_cap.prev_level) || init) {\n\t\t\tdev_dbg(di->dev, \"level changed from %d to %d\\n\",\n\t\t\t\tdi->bat_cap.prev_level,\n\t\t\t\tdi->bat_cap.level);\n\t\t\tdi->bat_cap.prev_level = di->bat_cap.level;\n\t\t\tchanged = true;\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"level not allowed to go up \"\n\t\t\t\t\"since no charger is connected: %d to %d\\n\",\n\t\t\t\tdi->bat_cap.prev_level,\n\t\t\t\tdi->bat_cap.level);\n\t\t}\n\t}\n\n\t \n\tif (di->flags.low_bat) {\n\t\tdev_dbg(di->dev, \"Battery low, set capacity to 0\\n\");\n\t\tdi->bat_cap.prev_percent = 0;\n\t\tdi->bat_cap.permille = 0;\n\t\tpercent = 0;\n\t\tdi->bat_cap.prev_mah = 0;\n\t\tdi->bat_cap.mah = 0;\n\t\tchanged = true;\n\t} else if (di->flags.fully_charged) {\n\t\t \n\t\tif (di->flags.force_full) {\n\t\t\tdi->bat_cap.prev_percent = percent;\n\t\t\tdi->bat_cap.prev_mah = di->bat_cap.mah;\n\n\t\t\tchanged = true;\n\n\t\t\tif (!di->bat_cap.cap_scale.enable &&\n\t\t\t\t\t\tdi->bm->capacity_scaling) {\n\t\t\t\tdi->bat_cap.cap_scale.enable = true;\n\t\t\t\tdi->bat_cap.cap_scale.cap_to_scale[0] = 100;\n\t\t\t\tdi->bat_cap.cap_scale.cap_to_scale[1] =\n\t\t\t\t\t\tdi->bat_cap.prev_percent;\n\t\t\t\tdi->bat_cap.cap_scale.disable_cap_level = 100;\n\t\t\t}\n\t\t} else if (di->bat_cap.prev_percent != percent) {\n\t\t\tdev_dbg(di->dev,\n\t\t\t\t\"battery reported full \"\n\t\t\t\t\"but capacity dropping: %d\\n\",\n\t\t\t\tpercent);\n\t\t\tdi->bat_cap.prev_percent = percent;\n\t\t\tdi->bat_cap.prev_mah = di->bat_cap.mah;\n\n\t\t\tchanged = true;\n\t\t}\n\t} else if (di->bat_cap.prev_percent != percent) {\n\t\tif (percent == 0) {\n\t\t\t \n\t\t\tdi->bat_cap.prev_percent = 1;\n\t\t\tpercent = 1;\n\n\t\t\tchanged = true;\n\t\t} else if (!(!di->flags.charging &&\n\t\t\tpercent > di->bat_cap.prev_percent) || init) {\n\t\t\t \n\t\t\tdev_dbg(di->dev,\n\t\t\t\t\"capacity changed from %d to %d (%d)\\n\",\n\t\t\t\tdi->bat_cap.prev_percent,\n\t\t\t\tpercent,\n\t\t\t\tdi->bat_cap.permille);\n\t\t\tdi->bat_cap.prev_percent = percent;\n\t\t\tdi->bat_cap.prev_mah = di->bat_cap.mah;\n\n\t\t\tchanged = true;\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"capacity not allowed to go up since \"\n\t\t\t\t\"no charger is connected: %d to %d (%d)\\n\",\n\t\t\t\tdi->bat_cap.prev_percent,\n\t\t\t\tpercent,\n\t\t\t\tdi->bat_cap.permille);\n\t\t}\n\t}\n\n\tif (changed) {\n\t\tif (di->bm->capacity_scaling) {\n\t\t\tdi->bat_cap.cap_scale.scaled_cap =\n\t\t\t\tab8500_fg_calculate_scaled_capacity(di);\n\n\t\t\tdev_info(di->dev, \"capacity=%d (%d)\\n\",\n\t\t\t\tdi->bat_cap.prev_percent,\n\t\t\t\tdi->bat_cap.cap_scale.scaled_cap);\n\t\t}\n\t\tpower_supply_changed(di->fg_psy);\n\t\tif (di->flags.fully_charged && di->flags.force_full) {\n\t\t\tdev_dbg(di->dev, \"Battery full, notifying.\\n\");\n\t\t\tdi->flags.force_full = false;\n\t\t\tsysfs_notify(&di->fg_kobject, NULL, \"charge_full\");\n\t\t}\n\t\tsysfs_notify(&di->fg_kobject, NULL, \"charge_now\");\n\t}\n}\n\nstatic void ab8500_fg_charge_state_to(struct ab8500_fg *di,\n\tenum ab8500_fg_charge_state new_state)\n{\n\tdev_dbg(di->dev, \"Charge state from %d [%s] to %d [%s]\\n\",\n\t\tdi->charge_state,\n\t\tcharge_state[di->charge_state],\n\t\tnew_state,\n\t\tcharge_state[new_state]);\n\n\tdi->charge_state = new_state;\n}\n\nstatic void ab8500_fg_discharge_state_to(struct ab8500_fg *di,\n\tenum ab8500_fg_discharge_state new_state)\n{\n\tdev_dbg(di->dev, \"Discharge state from %d [%s] to %d [%s]\\n\",\n\t\tdi->discharge_state,\n\t\tdischarge_state[di->discharge_state],\n\t\tnew_state,\n\t\tdischarge_state[new_state]);\n\n\tdi->discharge_state = new_state;\n}\n\n \nstatic void ab8500_fg_algorithm_charging(struct ab8500_fg *di)\n{\n\t \n\tif (di->discharge_state != AB8500_FG_DISCHARGE_INIT_RECOVERY)\n\t\tab8500_fg_discharge_state_to(di,\n\t\t\tAB8500_FG_DISCHARGE_INIT_RECOVERY);\n\n\tswitch (di->charge_state) {\n\tcase AB8500_FG_CHARGE_INIT:\n\t\tdi->fg_samples = SEC_TO_SAMPLE(\n\t\t\tdi->bm->fg_params->accu_charging);\n\n\t\tab8500_fg_coulomb_counter(di, true);\n\t\tab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_READOUT);\n\n\t\tbreak;\n\n\tcase AB8500_FG_CHARGE_READOUT:\n\t\t \n\t\tmutex_lock(&di->cc_lock);\n\t\tif (!di->flags.conv_done && !di->flags.force_full) {\n\t\t\t \n\t\t\tmutex_unlock(&di->cc_lock);\n\t\t\tdev_dbg(di->dev, \"%s CC conv not done\\n\",\n\t\t\t\t__func__);\n\n\t\t\tbreak;\n\t\t}\n\t\tdi->flags.conv_done = false;\n\t\tmutex_unlock(&di->cc_lock);\n\n\t\tab8500_fg_calc_cap_charging(di);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tab8500_fg_check_capacity_limits(di, false);\n}\n\nstatic void force_capacity(struct ab8500_fg *di)\n{\n\tint cap;\n\n\tab8500_fg_clear_cap_samples(di);\n\tcap = di->bat_cap.user_mah;\n\tif (cap > di->bat_cap.max_mah_design) {\n\t\tdev_dbg(di->dev, \"Remaining cap %d can't be bigger than total\"\n\t\t\t\" %d\\n\", cap, di->bat_cap.max_mah_design);\n\t\tcap = di->bat_cap.max_mah_design;\n\t}\n\tab8500_fg_fill_cap_sample(di, di->bat_cap.user_mah);\n\tdi->bat_cap.permille = ab8500_fg_convert_mah_to_permille(di, cap);\n\tdi->bat_cap.mah = cap;\n\tab8500_fg_check_capacity_limits(di, true);\n}\n\nstatic bool check_sysfs_capacity(struct ab8500_fg *di)\n{\n\tint cap, lower, upper;\n\tint cap_permille;\n\n\tcap = di->bat_cap.user_mah;\n\n\tcap_permille = ab8500_fg_convert_mah_to_permille(di,\n\t\tdi->bat_cap.user_mah);\n\n\tlower = di->bat_cap.permille - di->bm->fg_params->user_cap_limit * 10;\n\tupper = di->bat_cap.permille + di->bm->fg_params->user_cap_limit * 10;\n\n\tif (lower < 0)\n\t\tlower = 0;\n\t \n\tif (upper > 1000)\n\t\tupper = 1000;\n\n\tdev_dbg(di->dev, \"Capacity limits:\"\n\t\t\" (Lower: %d User: %d Upper: %d) [user: %d, was: %d]\\n\",\n\t\tlower, cap_permille, upper, cap, di->bat_cap.mah);\n\n\t \n\tif (cap_permille > lower && cap_permille < upper) {\n\t\tdev_dbg(di->dev, \"OK! Using users cap %d uAh now\\n\", cap);\n\t\tforce_capacity(di);\n\t\treturn true;\n\t}\n\tdev_dbg(di->dev, \"Capacity from user out of limits, ignoring\");\n\treturn false;\n}\n\n \nstatic void ab8500_fg_algorithm_discharging(struct ab8500_fg *di)\n{\n\tint sleep_time;\n\n\t \n\tif (di->charge_state != AB8500_FG_CHARGE_INIT)\n\t\tab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\n\n\tswitch (di->discharge_state) {\n\tcase AB8500_FG_DISCHARGE_INIT:\n\t\t \n\t\tdi->init_cnt = 0;\n\t\tdi->fg_samples = SEC_TO_SAMPLE(di->bm->fg_params->init_timer);\n\t\tab8500_fg_coulomb_counter(di, true);\n\t\tab8500_fg_discharge_state_to(di,\n\t\t\tAB8500_FG_DISCHARGE_INITMEASURING);\n\n\t\tfallthrough;\n\tcase AB8500_FG_DISCHARGE_INITMEASURING:\n\t\t \n\t\tsleep_time = di->bm->fg_params->init_timer;\n\n\t\t \n\t\tif (di->init_cnt > di->bm->fg_params->init_discard_time) {\n\t\t\tab8500_fg_calc_cap_discharge_voltage(di);\n\n\t\t\tab8500_fg_check_capacity_limits(di, true);\n\t\t}\n\n\t\tdi->init_cnt += sleep_time;\n\t\tif (di->init_cnt > di->bm->fg_params->init_total_time)\n\t\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\tAB8500_FG_DISCHARGE_READOUT_INIT);\n\n\t\tbreak;\n\n\tcase AB8500_FG_DISCHARGE_INIT_RECOVERY:\n\t\tdi->recovery_cnt = 0;\n\t\tdi->recovery_needed = true;\n\t\tab8500_fg_discharge_state_to(di,\n\t\t\tAB8500_FG_DISCHARGE_RECOVERY);\n\n\t\tfallthrough;\n\n\tcase AB8500_FG_DISCHARGE_RECOVERY:\n\t\tsleep_time = di->bm->fg_params->recovery_sleep_timer;\n\n\t\t \n\t\tdi->inst_curr_ua = ab8500_fg_inst_curr_blocking(di);\n\n\t\tif (ab8500_fg_is_low_curr(di, di->inst_curr_ua)) {\n\t\t\tif (di->recovery_cnt >\n\t\t\t\tdi->bm->fg_params->recovery_total_time) {\n\t\t\t\tdi->fg_samples = SEC_TO_SAMPLE(\n\t\t\t\t\tdi->bm->fg_params->accu_high_curr);\n\t\t\t\tab8500_fg_coulomb_counter(di, true);\n\t\t\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\t\tAB8500_FG_DISCHARGE_READOUT);\n\t\t\t\tdi->recovery_needed = false;\n\t\t\t} else {\n\t\t\t\tqueue_delayed_work(di->fg_wq,\n\t\t\t\t\t&di->fg_periodic_work,\n\t\t\t\t\tsleep_time * HZ);\n\t\t\t}\n\t\t\tdi->recovery_cnt += sleep_time;\n\t\t} else {\n\t\t\tdi->fg_samples = SEC_TO_SAMPLE(\n\t\t\t\tdi->bm->fg_params->accu_high_curr);\n\t\t\tab8500_fg_coulomb_counter(di, true);\n\t\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\tAB8500_FG_DISCHARGE_READOUT);\n\t\t}\n\t\tbreak;\n\n\tcase AB8500_FG_DISCHARGE_READOUT_INIT:\n\t\tdi->fg_samples = SEC_TO_SAMPLE(\n\t\t\tdi->bm->fg_params->accu_high_curr);\n\t\tab8500_fg_coulomb_counter(di, true);\n\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\tAB8500_FG_DISCHARGE_READOUT);\n\t\tbreak;\n\n\tcase AB8500_FG_DISCHARGE_READOUT:\n\t\tdi->inst_curr_ua = ab8500_fg_inst_curr_blocking(di);\n\n\t\tif (ab8500_fg_is_low_curr(di, di->inst_curr_ua)) {\n\t\t\t \n\t\t\tif (di->high_curr_mode) {\n\t\t\t\tdi->high_curr_mode = false;\n\t\t\t\tdi->high_curr_cnt = 0;\n\t\t\t}\n\n\t\t\tif (di->recovery_needed) {\n\t\t\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\t\tAB8500_FG_DISCHARGE_INIT_RECOVERY);\n\n\t\t\t\tqueue_delayed_work(di->fg_wq,\n\t\t\t\t\t&di->fg_periodic_work, 0);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tab8500_fg_calc_cap_discharge_voltage(di);\n\t\t} else {\n\t\t\tmutex_lock(&di->cc_lock);\n\t\t\tif (!di->flags.conv_done) {\n\t\t\t\t \n\t\t\t\tmutex_unlock(&di->cc_lock);\n\t\t\t\tdev_dbg(di->dev, \"%s CC conv not done\\n\",\n\t\t\t\t\t__func__);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdi->flags.conv_done = false;\n\t\t\tmutex_unlock(&di->cc_lock);\n\n\t\t\t \n\t\t\tif (!di->high_curr_mode) {\n\t\t\t\tdi->high_curr_mode = true;\n\t\t\t\tdi->high_curr_cnt = 0;\n\t\t\t}\n\n\t\t\tdi->high_curr_cnt +=\n\t\t\t\tdi->bm->fg_params->accu_high_curr;\n\t\t\tif (di->high_curr_cnt >\n\t\t\t\tdi->bm->fg_params->high_curr_time)\n\t\t\t\tdi->recovery_needed = true;\n\n\t\t\tab8500_fg_calc_cap_discharge_fg(di);\n\t\t}\n\n\t\tab8500_fg_check_capacity_limits(di, false);\n\n\t\tbreak;\n\n\tcase AB8500_FG_DISCHARGE_WAKEUP:\n\t\tab8500_fg_calc_cap_discharge_voltage(di);\n\n\t\tdi->fg_samples = SEC_TO_SAMPLE(\n\t\t\tdi->bm->fg_params->accu_high_curr);\n\t\tab8500_fg_coulomb_counter(di, true);\n\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\tAB8500_FG_DISCHARGE_READOUT);\n\n\t\tab8500_fg_check_capacity_limits(di, false);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ab8500_fg_algorithm_calibrate(struct ab8500_fg *di)\n{\n\tint ret;\n\n\tswitch (di->calib_state) {\n\tcase AB8500_FG_CALIB_INIT:\n\t\tdev_dbg(di->dev, \"Calibration ongoing...\\n\");\n\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\n\t\t\tCC_INT_CAL_N_AVG_MASK, CC_INT_CAL_SAMPLES_8);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\n\t\t\tCC_INTAVGOFFSET_ENA, CC_INTAVGOFFSET_ENA);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdi->calib_state = AB8500_FG_CALIB_WAIT;\n\t\tbreak;\n\tcase AB8500_FG_CALIB_END:\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\n\t\t\tCC_MUXOFFSET, CC_MUXOFFSET);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdi->flags.calibrate = false;\n\t\tdev_dbg(di->dev, \"Calibration done...\\n\");\n\t\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\t\tbreak;\n\tcase AB8500_FG_CALIB_WAIT:\n\t\tdev_dbg(di->dev, \"Calibration WFI\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\nerr:\n\t \n\tdev_err(di->dev, \"failed to calibrate the CC\\n\");\n\tdi->flags.calibrate = false;\n\tdi->calib_state = AB8500_FG_CALIB_INIT;\n\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n}\n\n \nstatic void ab8500_fg_algorithm(struct ab8500_fg *di)\n{\n\tif (di->flags.calibrate)\n\t\tab8500_fg_algorithm_calibrate(di);\n\telse {\n\t\tif (di->flags.charging)\n\t\t\tab8500_fg_algorithm_charging(di);\n\t\telse\n\t\t\tab8500_fg_algorithm_discharging(di);\n\t}\n\n\tdev_dbg(di->dev, \"[FG_DATA] %d %d %d %d %d %d %d %d %d %d \"\n\t\t\"%d %d %d %d %d %d %d\\n\",\n\t\tdi->bat_cap.max_mah_design,\n\t\tdi->bat_cap.max_mah,\n\t\tdi->bat_cap.mah,\n\t\tdi->bat_cap.permille,\n\t\tdi->bat_cap.level,\n\t\tdi->bat_cap.prev_mah,\n\t\tdi->bat_cap.prev_percent,\n\t\tdi->bat_cap.prev_level,\n\t\tdi->vbat_uv,\n\t\tdi->inst_curr_ua,\n\t\tdi->avg_curr_ua,\n\t\tdi->accu_charge,\n\t\tdi->flags.charging,\n\t\tdi->charge_state,\n\t\tdi->discharge_state,\n\t\tdi->high_curr_mode,\n\t\tdi->recovery_needed);\n}\n\n \nstatic void ab8500_fg_periodic_work(struct work_struct *work)\n{\n\tstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\n\t\tfg_periodic_work.work);\n\n\tif (di->init_capacity) {\n\t\t \n\t\tab8500_fg_calc_cap_discharge_voltage(di);\n\t\tab8500_fg_check_capacity_limits(di, true);\n\t\tdi->init_capacity = false;\n\n\t\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\t} else if (di->flags.user_cap) {\n\t\tif (check_sysfs_capacity(di)) {\n\t\t\tab8500_fg_check_capacity_limits(di, true);\n\t\t\tif (di->flags.charging)\n\t\t\t\tab8500_fg_charge_state_to(di,\n\t\t\t\t\tAB8500_FG_CHARGE_INIT);\n\t\t\telse\n\t\t\t\tab8500_fg_discharge_state_to(di,\n\t\t\t\t\tAB8500_FG_DISCHARGE_READOUT_INIT);\n\t\t}\n\t\tdi->flags.user_cap = false;\n\t\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\t} else\n\t\tab8500_fg_algorithm(di);\n\n}\n\n \nstatic void ab8500_fg_check_hw_failure_work(struct work_struct *work)\n{\n\tint ret;\n\tu8 reg_value;\n\n\tstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\n\t\tfg_check_hw_failure_work.work);\n\n\t \n\tret = abx500_get_register_interruptible(di->dev,\n\t\tAB8500_CHARGER, AB8500_CH_STAT_REG,\n\t\t&reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif ((reg_value & BATT_OVV) == BATT_OVV) {\n\t\tif (!di->flags.bat_ovv) {\n\t\t\tdev_dbg(di->dev, \"Battery OVV\\n\");\n\t\t\tdi->flags.bat_ovv = true;\n\t\t\tpower_supply_changed(di->fg_psy);\n\t\t}\n\t\t \n\t\tqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work,\n\t\t\t\t   HZ);\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"Battery recovered from OVV\\n\");\n\t\t\tdi->flags.bat_ovv = false;\n\t\t\tpower_supply_changed(di->fg_psy);\n\t}\n}\n\n \nstatic void ab8500_fg_low_bat_work(struct work_struct *work)\n{\n\tint vbat_uv;\n\n\tstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\n\t\tfg_low_bat_work.work);\n\n\tvbat_uv = ab8500_fg_bat_voltage(di);\n\n\t \n\tif (vbat_uv < di->bm->fg_params->lowbat_threshold_uv) {\n\t\t \n\t\tif (di->low_bat_cnt < 1) {\n\t\t\tdi->flags.low_bat = true;\n\t\t\tdev_warn(di->dev, \"Shut down pending...\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tdi->low_bat_cnt--;\n\t\t\tdev_warn(di->dev, \"Battery voltage still LOW\\n\");\n\t\t\tqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\n\t\t\t\tround_jiffies(LOW_BAT_CHECK_INTERVAL));\n\t\t}\n\t} else {\n\t\tdi->flags.low_bat_delay = false;\n\t\tdi->low_bat_cnt = 10;\n\t\tdev_warn(di->dev, \"Battery voltage OK again\\n\");\n\t}\n\n\t \n\tab8500_fg_check_capacity_limits(di, false);\n}\n\n \n\nstatic int ab8500_fg_battok_calc(struct ab8500_fg *di, int target)\n{\n\tif (target > BATT_OK_MIN +\n\t\t(BATT_OK_INCREMENT * BATT_OK_MAX_NR_INCREMENTS))\n\t\treturn BATT_OK_MAX_NR_INCREMENTS;\n\tif (target < BATT_OK_MIN)\n\t\treturn 0;\n\treturn (target - BATT_OK_MIN) / BATT_OK_INCREMENT;\n}\n\n \n\nstatic int ab8500_fg_battok_init_hw_register(struct ab8500_fg *di)\n{\n\tint selected;\n\tint sel0;\n\tint sel1;\n\tint cbp_sel0;\n\tint cbp_sel1;\n\tint ret;\n\tint new_val;\n\n\tsel0 = di->bm->fg_params->battok_falling_th_sel0;\n\tsel1 = di->bm->fg_params->battok_raising_th_sel1;\n\n\tcbp_sel0 = ab8500_fg_battok_calc(di, sel0);\n\tcbp_sel1 = ab8500_fg_battok_calc(di, sel1);\n\n\tselected = BATT_OK_MIN + cbp_sel0 * BATT_OK_INCREMENT;\n\n\tif (selected != sel0)\n\t\tdev_warn(di->dev, \"Invalid voltage step:%d, using %d %d\\n\",\n\t\t\tsel0, selected, cbp_sel0);\n\n\tselected = BATT_OK_MIN + cbp_sel1 * BATT_OK_INCREMENT;\n\n\tif (selected != sel1)\n\t\tdev_warn(di->dev, \"Invalid voltage step:%d, using %d %d\\n\",\n\t\t\tsel1, selected, cbp_sel1);\n\n\tnew_val = cbp_sel0 | (cbp_sel1 << 4);\n\n\tdev_dbg(di->dev, \"using: %x %d %d\\n\", new_val, cbp_sel0, cbp_sel1);\n\tret = abx500_set_register_interruptible(di->dev, AB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_BATT_OK_REG, new_val);\n\treturn ret;\n}\n\n \nstatic void ab8500_fg_instant_work(struct work_struct *work)\n{\n\tstruct ab8500_fg *di = container_of(work, struct ab8500_fg, fg_work);\n\n\tab8500_fg_algorithm(di);\n}\n\n \nstatic irqreturn_t ab8500_fg_cc_data_end_handler(int irq, void *_di)\n{\n\tstruct ab8500_fg *di = _di;\n\tif (!di->nbr_cceoc_irq_cnt) {\n\t\tdi->nbr_cceoc_irq_cnt++;\n\t\tcomplete(&di->ab8500_fg_started);\n\t} else {\n\t\tdi->nbr_cceoc_irq_cnt = 0;\n\t\tcomplete(&di->ab8500_fg_complete);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_fg_cc_int_calib_handler(int irq, void *_di)\n{\n\tstruct ab8500_fg *di = _di;\n\tdi->calib_state = AB8500_FG_CALIB_END;\n\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_fg_cc_convend_handler(int irq, void *_di)\n{\n\tstruct ab8500_fg *di = _di;\n\n\tqueue_work(di->fg_wq, &di->fg_acc_cur_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_fg_batt_ovv_handler(int irq, void *_di)\n{\n\tstruct ab8500_fg *di = _di;\n\n\tdev_dbg(di->dev, \"Battery OVV\\n\");\n\n\t \n\tqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_fg_lowbatf_handler(int irq, void *_di)\n{\n\tstruct ab8500_fg *di = _di;\n\n\t \n\tif (!di->flags.low_bat_delay) {\n\t\tdev_warn(di->dev, \"Battery voltage is below LOW threshold\\n\");\n\t\tdi->flags.low_bat_delay = true;\n\t\t \n\t\tqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\n\t\t\tround_jiffies(LOW_BAT_CHECK_INTERVAL));\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ab8500_fg_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\t \n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tif (di->flags.bat_ovv)\n\t\t\tval->intval = BATT_OVV_VALUE;\n\t\telse\n\t\t\tval->intval = di->vbat_uv;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = di->inst_curr_ua;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tval->intval = di->avg_curr_ua;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tval->intval = ab8500_fg_convert_mah_to_uwh(di,\n\t\t\t\tdi->bat_cap.max_mah_design);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tval->intval = ab8500_fg_convert_mah_to_uwh(di,\n\t\t\t\tdi->bat_cap.max_mah);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\n\t\t\t\tdi->flags.batt_id_received)\n\t\t\tval->intval = ab8500_fg_convert_mah_to_uwh(di,\n\t\t\t\t\tdi->bat_cap.max_mah);\n\t\telse\n\t\t\tval->intval = ab8500_fg_convert_mah_to_uwh(di,\n\t\t\t\t\tdi->bat_cap.prev_mah);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval = di->bat_cap.max_mah_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tval->intval = di->bat_cap.max_mah;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\n\t\t\t\tdi->flags.batt_id_received)\n\t\t\tval->intval = di->bat_cap.max_mah;\n\t\telse\n\t\t\tval->intval = di->bat_cap.prev_mah;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\n\t\t\t\tdi->flags.batt_id_received)\n\t\t\tval->intval = 100;\n\t\telse\n\t\t\tval->intval = di->bat_cap.prev_percent;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\n\t\t\t\tdi->flags.batt_id_received)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\telse\n\t\t\tval->intval = di->bat_cap.prev_level;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ab8500_fg_get_ext_psy_data(struct device *dev, void *data)\n{\n\tstruct power_supply *psy;\n\tstruct power_supply *ext = dev_get_drvdata(dev);\n\tconst char **supplicants = (const char **)ext->supplied_to;\n\tstruct ab8500_fg *di;\n\tstruct power_supply_battery_info *bi;\n\tunion power_supply_propval ret;\n\tint j;\n\n\tpsy = (struct power_supply *)data;\n\tdi = power_supply_get_drvdata(psy);\n\tbi = di->bm->bi;\n\n\t \n\tj = match_string(supplicants, ext->num_supplicants, psy->desc->name);\n\tif (j < 0)\n\t\treturn 0;\n\n\t \n\tfor (j = 0; j < ext->desc->num_properties; j++) {\n\t\tenum power_supply_property prop;\n\t\tprop = ext->desc->properties[j];\n\n\t\tif (power_supply_get_property(ext, prop, &ret))\n\t\t\tcontinue;\n\n\t\tswitch (prop) {\n\t\tcase POWER_SUPPLY_PROP_STATUS:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tswitch (ret.intval) {\n\t\t\t\tcase POWER_SUPPLY_STATUS_UNKNOWN:\n\t\t\t\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\t\t\tcase POWER_SUPPLY_STATUS_NOT_CHARGING:\n\t\t\t\t\tif (!di->flags.charging)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdi->flags.charging = false;\n\t\t\t\t\tdi->flags.fully_charged = false;\n\t\t\t\t\tif (di->bm->capacity_scaling)\n\t\t\t\t\t\tab8500_fg_update_cap_scalers(di);\n\t\t\t\t\tqueue_work(di->fg_wq, &di->fg_work);\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_STATUS_FULL:\n\t\t\t\t\tif (di->flags.fully_charged)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdi->flags.fully_charged = true;\n\t\t\t\t\tdi->flags.force_full = true;\n\t\t\t\t\t \n\t\t\t\t\tdi->bat_cap.max_mah = di->bat_cap.mah;\n\t\t\t\t\tqueue_work(di->fg_wq, &di->fg_work);\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\t\t\t\tif (di->flags.charging &&\n\t\t\t\t\t\t!di->flags.fully_charged)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdi->flags.charging = true;\n\t\t\t\t\tdi->flags.fully_charged = false;\n\t\t\t\t\tif (di->bm->capacity_scaling)\n\t\t\t\t\t\tab8500_fg_update_cap_scalers(di);\n\t\t\t\t\tqueue_work(di->fg_wq, &di->fg_work);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tif (!di->flags.batt_id_received &&\n\t\t\t\t    (bi && (bi->technology !=\n\t\t\t\t\t    POWER_SUPPLY_TECHNOLOGY_UNKNOWN))) {\n\t\t\t\t\tdi->flags.batt_id_received = true;\n\n\t\t\t\t\tdi->bat_cap.max_mah_design =\n\t\t\t\t\t\tdi->bm->bi->charge_full_design_uah;\n\n\t\t\t\t\tdi->bat_cap.max_mah =\n\t\t\t\t\t\tdi->bat_cap.max_mah_design;\n\n\t\t\t\t\tdi->vbat_nom_uv =\n\t\t\t\t\t\tdi->bm->bi->voltage_max_design_uv;\n\t\t\t\t}\n\n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->flags.batt_unknown = false;\n\t\t\t\telse\n\t\t\t\t\tdi->flags.batt_unknown = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_TEMP:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tif (di->flags.batt_id_received)\n\t\t\t\t\tdi->bat_temp = ret.intval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int ab8500_fg_init_hw_registers(struct ab8500_fg *di)\n{\n\tint ret;\n\n\t \n\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\tAB8500_CHARGER,\n\t\tAB8500_BATT_OVV,\n\t\tBATT_OVV_TH_4P75,\n\t\tBATT_OVV_TH_4P75);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to set BATT_OVV\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\tAB8500_CHARGER,\n\t\tAB8500_BATT_OVV,\n\t\tBATT_OVV_ENA,\n\t\tBATT_OVV_ENA);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to enable BATT_OVV\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_LOW_BAT_REG,\n\t\tab8500_volt_to_regval(\n\t\t\tdi->bm->fg_params->lowbat_threshold_uv) << 1 |\n\t\tLOW_BAT_ENABLE);\n\tif (ret) {\n\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ab8500_fg_battok_init_hw_register(di);\n\tif (ret) {\n\t\tdev_err(di->dev, \"BattOk init write failed.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (is_ab8505(di->parent)) {\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8505_RTC_PCUT_MAX_TIME_REG, di->bm->fg_params->pcut_max_time);\n\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed AB8505_RTC_PCUT_MAX_TIME_REG\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8505_RTC_PCUT_FLAG_TIME_REG, di->bm->fg_params->pcut_flag_time);\n\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed AB8505_RTC_PCUT_FLAG_TIME_REG\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8505_RTC_PCUT_RESTART_REG, di->bm->fg_params->pcut_max_restart);\n\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed AB8505_RTC_PCUT_RESTART_REG\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8505_RTC_PCUT_DEBOUNCE_REG, di->bm->fg_params->pcut_debounce_time);\n\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed AB8505_RTC_PCUT_DEBOUNCE_REG\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\tAB8505_RTC_PCUT_CTL_STATUS_REG, di->bm->fg_params->pcut_enable);\n\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed AB8505_RTC_PCUT_CTL_STATUS_REG\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic void ab8500_fg_external_power_changed(struct power_supply *psy)\n{\n\tclass_for_each_device(power_supply_class, NULL, psy,\n\t\t\t      ab8500_fg_get_ext_psy_data);\n}\n\n \nstatic void ab8500_fg_reinit_work(struct work_struct *work)\n{\n\tstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\n\t\tfg_reinit_work.work);\n\n\tif (!di->flags.calibrate) {\n\t\tdev_dbg(di->dev, \"Resetting FG state machine to init.\\n\");\n\t\tab8500_fg_clear_cap_samples(di);\n\t\tab8500_fg_calc_cap_discharge_voltage(di);\n\t\tab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\n\t\tab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\n\t\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\n\t} else {\n\t\tdev_err(di->dev, \"Residual offset calibration ongoing \"\n\t\t\t\"retrying..\\n\");\n\t\t \n\t\tqueue_delayed_work(di->fg_wq, &di->fg_reinit_work,\n\t\t\tround_jiffies(1));\n\t}\n}\n\n \n\nstruct ab8500_fg_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct ab8500_fg *, char *);\n\tssize_t (*store)(struct ab8500_fg *, const char *, size_t);\n};\n\nstatic ssize_t charge_full_show(struct ab8500_fg *di, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", di->bat_cap.max_mah);\n}\n\nstatic ssize_t charge_full_store(struct ab8500_fg *di, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long charge_full;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &charge_full);\n\tif (ret)\n\t\treturn ret;\n\n\tdi->bat_cap.max_mah = (int) charge_full;\n\treturn count;\n}\n\nstatic ssize_t charge_now_show(struct ab8500_fg *di, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", di->bat_cap.prev_mah);\n}\n\nstatic ssize_t charge_now_store(struct ab8500_fg *di, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long charge_now;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &charge_now);\n\tif (ret)\n\t\treturn ret;\n\n\tdi->bat_cap.user_mah = (int) charge_now;\n\tdi->flags.user_cap = true;\n\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\treturn count;\n}\n\nstatic struct ab8500_fg_sysfs_entry charge_full_attr =\n\t__ATTR(charge_full, 0644, charge_full_show, charge_full_store);\n\nstatic struct ab8500_fg_sysfs_entry charge_now_attr =\n\t__ATTR(charge_now, 0644, charge_now_show, charge_now_store);\n\nstatic ssize_t\nab8500_fg_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct ab8500_fg_sysfs_entry *entry;\n\tstruct ab8500_fg *di;\n\n\tentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\n\tdi = container_of(kobj, struct ab8500_fg, fg_kobject);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(di, buf);\n}\nstatic ssize_t\nab8500_fg_store(struct kobject *kobj, struct attribute *attr, const char *buf,\n\t\tsize_t count)\n{\n\tstruct ab8500_fg_sysfs_entry *entry;\n\tstruct ab8500_fg *di;\n\n\tentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\n\tdi = container_of(kobj, struct ab8500_fg, fg_kobject);\n\n\tif (!entry->store)\n\t\treturn -EIO;\n\n\treturn entry->store(di, buf, count);\n}\n\nstatic const struct sysfs_ops ab8500_fg_sysfs_ops = {\n\t.show = ab8500_fg_show,\n\t.store = ab8500_fg_store,\n};\n\nstatic struct attribute *ab8500_fg_attrs[] = {\n\t&charge_full_attr.attr,\n\t&charge_now_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ab8500_fg);\n\nstatic struct kobj_type ab8500_fg_ktype = {\n\t.sysfs_ops = &ab8500_fg_sysfs_ops,\n\t.default_groups = ab8500_fg_groups,\n};\n\n \nstatic void ab8500_fg_sysfs_exit(struct ab8500_fg *di)\n{\n\tkobject_del(&di->fg_kobject);\n}\n\n \nstatic int ab8500_fg_sysfs_init(struct ab8500_fg *di)\n{\n\tint ret = 0;\n\n\tret = kobject_init_and_add(&di->fg_kobject,\n\t\t&ab8500_fg_ktype,\n\t\tNULL, \"battery\");\n\tif (ret < 0) {\n\t\tkobject_put(&di->fg_kobject);\n\t\tdev_err(di->dev, \"failed to create sysfs entry\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_flagtime_read(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8505_RTC_PCUT_FLAG_TIME_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_FLAG_TIME_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0x7F));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_flagtime_write(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\tint reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tif (kstrtoint(buf, 10, &reg_value))\n\t\tgoto fail;\n\n\tif (reg_value > 0x7F) {\n\t\tdev_err(dev, \"Incorrect parameter, echo 0 (1.98s) - 127 (15.625ms) for flagtime\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8505_RTC_PCUT_FLAG_TIME_REG, (u8)reg_value);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set AB8505_RTC_PCUT_FLAG_TIME_REG\\n\");\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t ab8505_powercut_maxtime_read(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8505_RTC_PCUT_MAX_TIME_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_MAX_TIME_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0x7F));\n\nfail:\n\treturn ret;\n\n}\n\nstatic ssize_t ab8505_powercut_maxtime_write(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint ret;\n\tint reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tif (kstrtoint(buf, 10, &reg_value))\n\t\tgoto fail;\n\n\tif (reg_value > 0x7F) {\n\t\tdev_err(dev, \"Incorrect parameter, echo 0 (0.0s) - 127 (1.98s) for maxtime\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8505_RTC_PCUT_MAX_TIME_REG, (u8)reg_value);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set AB8505_RTC_PCUT_MAX_TIME_REG\\n\");\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t ab8505_powercut_restart_read(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\tAB8505_RTC_PCUT_RESTART_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_RESTART_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0xF));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_restart_write(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tint ret;\n\tint reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tif (kstrtoint(buf, 10, &reg_value))\n\t\tgoto fail;\n\n\tif (reg_value > 0xF) {\n\t\tdev_err(dev, \"Incorrect parameter, echo 0 - 15 for number of restart\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_RESTART_REG, (u8)reg_value);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set AB8505_RTC_PCUT_RESTART_REG\\n\");\n\nfail:\n\treturn count;\n\n}\n\nstatic ssize_t ab8505_powercut_timer_read(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_TIME_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_TIME_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0x7F));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_restart_counter_read(struct device *dev,\n\t\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t\t    char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_RESTART_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_RESTART_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0xF0) >> 4);\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_read(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_CTL_STATUS_REG, &reg_value);\n\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0x1));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_write(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint ret;\n\tint reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tif (kstrtoint(buf, 10, &reg_value))\n\t\tgoto fail;\n\n\tif (reg_value > 0x1) {\n\t\tdev_err(dev, \"Incorrect parameter, echo 0/1 to disable/enable Pcut feature\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_CTL_STATUS_REG, (u8)reg_value);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set AB8505_RTC_PCUT_CTL_STATUS_REG\\n\");\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t ab8505_powercut_flag_read(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_CTL_STATUS_REG,  &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_CTL_STATUS_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", ((reg_value & 0x10) >> 4));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_debounce_read(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_DEBOUNCE_REG,  &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_DEBOUNCE_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", (reg_value & 0x7));\n\nfail:\n\treturn ret;\n}\n\nstatic ssize_t ab8505_powercut_debounce_write(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint ret;\n\tint reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tif (kstrtoint(buf, 10, &reg_value))\n\t\tgoto fail;\n\n\tif (reg_value > 0x7) {\n\t\tdev_err(dev, \"Incorrect parameter, echo 0 to 7 for debounce setting\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_DEBOUNCE_REG, (u8)reg_value);\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to set AB8505_RTC_PCUT_DEBOUNCE_REG\\n\");\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t ab8505_powercut_enable_status_read(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  char *buf)\n{\n\tint ret;\n\tu8 reg_value;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct ab8500_fg *di = power_supply_get_drvdata(psy);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\n\t\t\t\t\t\tAB8505_RTC_PCUT_CTL_STATUS_REG, &reg_value);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read AB8505_RTC_PCUT_CTL_STATUS_REG\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", ((reg_value & 0x20) >> 5));\n\nfail:\n\treturn ret;\n}\n\nstatic struct device_attribute ab8505_fg_sysfs_psy_attrs[] = {\n\t__ATTR(powercut_flagtime, (S_IRUGO | S_IWUSR | S_IWGRP),\n\t\tab8505_powercut_flagtime_read, ab8505_powercut_flagtime_write),\n\t__ATTR(powercut_maxtime, (S_IRUGO | S_IWUSR | S_IWGRP),\n\t\tab8505_powercut_maxtime_read, ab8505_powercut_maxtime_write),\n\t__ATTR(powercut_restart_max, (S_IRUGO | S_IWUSR | S_IWGRP),\n\t\tab8505_powercut_restart_read, ab8505_powercut_restart_write),\n\t__ATTR(powercut_timer, S_IRUGO, ab8505_powercut_timer_read, NULL),\n\t__ATTR(powercut_restart_counter, S_IRUGO,\n\t\tab8505_powercut_restart_counter_read, NULL),\n\t__ATTR(powercut_enable, (S_IRUGO | S_IWUSR | S_IWGRP),\n\t\tab8505_powercut_read, ab8505_powercut_write),\n\t__ATTR(powercut_flag, S_IRUGO, ab8505_powercut_flag_read, NULL),\n\t__ATTR(powercut_debounce_time, (S_IRUGO | S_IWUSR | S_IWGRP),\n\t\tab8505_powercut_debounce_read, ab8505_powercut_debounce_write),\n\t__ATTR(powercut_enable_status, S_IRUGO,\n\t\tab8505_powercut_enable_status_read, NULL),\n};\n\nstatic int ab8500_fg_sysfs_psy_create_attrs(struct ab8500_fg *di)\n{\n\tunsigned int i;\n\n\tif (is_ab8505(di->parent)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)\n\t\t\tif (device_create_file(&di->fg_psy->dev,\n\t\t\t\t\t       &ab8505_fg_sysfs_psy_attrs[i]))\n\t\t\t\tgoto sysfs_psy_create_attrs_failed_ab8505;\n\t}\n\treturn 0;\nsysfs_psy_create_attrs_failed_ab8505:\n\tdev_err(&di->fg_psy->dev, \"Failed creating sysfs psy attrs for ab8505.\\n\");\n\twhile (i--)\n\t\tdevice_remove_file(&di->fg_psy->dev,\n\t\t\t\t   &ab8505_fg_sysfs_psy_attrs[i]);\n\n\treturn -EIO;\n}\n\nstatic void ab8500_fg_sysfs_psy_remove_attrs(struct ab8500_fg *di)\n{\n\tunsigned int i;\n\n\tif (is_ab8505(di->parent)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)\n\t\t\t(void)device_remove_file(&di->fg_psy->dev,\n\t\t\t\t\t\t &ab8505_fg_sysfs_psy_attrs[i]);\n\t}\n}\n\n \n\nstatic int __maybe_unused ab8500_fg_resume(struct device *dev)\n{\n\tstruct ab8500_fg *di = dev_get_drvdata(dev);\n\n\t \n\tif (!di->flags.charging) {\n\t\tab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_WAKEUP);\n\t\tqueue_work(di->fg_wq, &di->fg_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ab8500_fg_suspend(struct device *dev)\n{\n\tstruct ab8500_fg *di = dev_get_drvdata(dev);\n\n\tflush_delayed_work(&di->fg_periodic_work);\n\tflush_work(&di->fg_work);\n\tflush_work(&di->fg_acc_cur_work);\n\tflush_delayed_work(&di->fg_reinit_work);\n\tflush_delayed_work(&di->fg_low_bat_work);\n\tflush_delayed_work(&di->fg_check_hw_failure_work);\n\n\t \n\tif (di->flags.fg_enabled && !di->flags.charging)\n\t\tab8500_fg_coulomb_counter(di, false);\n\n\treturn 0;\n}\n\n \nstatic struct ab8500_fg_interrupts ab8500_fg_irq[] = {\n\t{\"NCONV_ACCU\", ab8500_fg_cc_convend_handler},\n\t{\"BATT_OVV\", ab8500_fg_batt_ovv_handler},\n\t{\"LOW_BAT_F\", ab8500_fg_lowbatf_handler},\n\t{\"CC_INT_CALIB\", ab8500_fg_cc_int_calib_handler},\n\t{\"CCEOC\", ab8500_fg_cc_data_end_handler},\n};\n\nstatic char *supply_interface[] = {\n\t\"ab8500_chargalg\",\n\t\"ab8500_usb\",\n};\n\nstatic const struct power_supply_desc ab8500_fg_desc = {\n\t.name\t\t\t= \"ab8500_fg\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= ab8500_fg_props,\n\t.num_properties\t\t= ARRAY_SIZE(ab8500_fg_props),\n\t.get_property\t\t= ab8500_fg_get_property,\n\t.external_power_changed\t= ab8500_fg_external_power_changed,\n};\n\nstatic int ab8500_fg_bind(struct device *dev, struct device *master,\n\t\t\t  void *data)\n{\n\tstruct ab8500_fg *di = dev_get_drvdata(dev);\n\n\tdi->bat_cap.max_mah_design = di->bm->bi->charge_full_design_uah;\n\tdi->bat_cap.max_mah = di->bat_cap.max_mah_design;\n\tdi->vbat_nom_uv = di->bm->bi->voltage_max_design_uv;\n\n\t \n\tab8500_fg_coulomb_counter(di, true);\n\t \n\tqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\n\n\treturn 0;\n}\n\nstatic void ab8500_fg_unbind(struct device *dev, struct device *master,\n\t\t\t     void *data)\n{\n\tstruct ab8500_fg *di = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = ab8500_fg_coulomb_counter(di, false);\n\tif (ret)\n\t\tdev_err(dev, \"failed to disable coulomb counter\\n\");\n\n\tflush_workqueue(di->fg_wq);\n}\n\nstatic const struct component_ops ab8500_fg_component_ops = {\n\t.bind = ab8500_fg_bind,\n\t.unbind = ab8500_fg_unbind,\n};\n\nstatic int ab8500_fg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ab8500_fg *di;\n\tint i, irq;\n\tint ret = 0;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->bm = &ab8500_bm_data;\n\n\tmutex_init(&di->cc_lock);\n\n\t \n\tdi->dev = dev;\n\tdi->parent = dev_get_drvdata(pdev->dev.parent);\n\n\tdi->main_bat_v = devm_iio_channel_get(dev, \"main_bat_v\");\n\tif (IS_ERR(di->main_bat_v)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(di->main_bat_v),\n\t\t\t\t    \"failed to get main battery ADC channel\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"line-impedance-micro-ohms\",\n\t\t\t\t  &di->line_impedance_uohm))\n\t\tdev_info(dev, \"line impedance: %u uOhm\\n\",\n\t\t\t di->line_impedance_uohm);\n\n\tpsy_cfg.supplied_to = supply_interface;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\n\tpsy_cfg.drv_data = di;\n\n\tdi->init_capacity = true;\n\n\tab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\n\tab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\n\n\t \n\tdi->fg_wq = alloc_ordered_workqueue(\"ab8500_fg_wq\", WQ_MEM_RECLAIM);\n\tif (di->fg_wq == NULL) {\n\t\tdev_err(dev, \"failed to create work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tINIT_WORK(&di->fg_work, ab8500_fg_instant_work);\n\n\t \n\tINIT_WORK(&di->fg_acc_cur_work, ab8500_fg_acc_cur_work);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->fg_reinit_work,\n\t\tab8500_fg_reinit_work);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->fg_periodic_work,\n\t\tab8500_fg_periodic_work);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->fg_low_bat_work,\n\t\tab8500_fg_low_bat_work);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->fg_check_hw_failure_work,\n\t\tab8500_fg_check_hw_failure_work);\n\n\t \n\tdi->flags.low_bat = false;\n\n\t \n\tdi->low_bat_cnt = 10;\n\n\t \n\tret = ab8500_fg_init_hw_registers(di);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize registers\\n\");\n\t\tdestroy_workqueue(di->fg_wq);\n\t\treturn ret;\n\t}\n\n\t \n\tdi->flags.batt_unknown = true;\n\tdi->flags.batt_id_received = false;\n\n\t \n\tdi->fg_psy = devm_power_supply_register(dev, &ab8500_fg_desc, &psy_cfg);\n\tif (IS_ERR(di->fg_psy)) {\n\t\tdev_err(dev, \"failed to register FG psy\\n\");\n\t\tdestroy_workqueue(di->fg_wq);\n\t\treturn PTR_ERR(di->fg_psy);\n\t}\n\n\tdi->fg_samples = SEC_TO_SAMPLE(di->bm->fg_params->init_timer);\n\n\t \n\tinit_completion(&di->ab8500_fg_started);\n\tinit_completion(&di->ab8500_fg_complete);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_fg_irq); i++) {\n\t\tirq = platform_get_irq_byname(pdev, ab8500_fg_irq[i].name);\n\t\tif (irq < 0) {\n\t\t\tdestroy_workqueue(di->fg_wq);\n\t\t\treturn irq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t  ab8500_fg_irq[i].isr,\n\t\t\t\t  IRQF_SHARED | IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t  ab8500_fg_irq[i].name, di);\n\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"failed to request %s IRQ %d: %d\\n\",\n\t\t\t\tab8500_fg_irq[i].name, irq, ret);\n\t\t\tdestroy_workqueue(di->fg_wq);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev, \"Requested %s IRQ %d: %d\\n\",\n\t\t\tab8500_fg_irq[i].name, irq, ret);\n\t}\n\n\tdi->irq = platform_get_irq_byname(pdev, \"CCEOC\");\n\tdisable_irq(di->irq);\n\tdi->nbr_cceoc_irq_cnt = 0;\n\n\tplatform_set_drvdata(pdev, di);\n\n\tret = ab8500_fg_sysfs_init(di);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create sysfs entry\\n\");\n\t\tdestroy_workqueue(di->fg_wq);\n\t\treturn ret;\n\t}\n\n\tret = ab8500_fg_sysfs_psy_create_attrs(di);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create FG psy\\n\");\n\t\tab8500_fg_sysfs_exit(di);\n\t\tdestroy_workqueue(di->fg_wq);\n\t\treturn ret;\n\t}\n\n\t \n\tdi->flags.calibrate = true;\n\tdi->calib_state = AB8500_FG_CALIB_INIT;\n\n\t \n\tdi->bat_temp = 210;\n\n\tlist_add_tail(&di->node, &ab8500_fg_list);\n\n\treturn component_add(dev, &ab8500_fg_component_ops);\n}\n\nstatic int ab8500_fg_remove(struct platform_device *pdev)\n{\n\tstruct ab8500_fg *di = platform_get_drvdata(pdev);\n\n\tdestroy_workqueue(di->fg_wq);\n\tcomponent_del(&pdev->dev, &ab8500_fg_component_ops);\n\tlist_del(&di->node);\n\tab8500_fg_sysfs_exit(di);\n\tab8500_fg_sysfs_psy_remove_attrs(di);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ab8500_fg_pm_ops, ab8500_fg_suspend, ab8500_fg_resume);\n\nstatic const struct of_device_id ab8500_fg_match[] = {\n\t{ .compatible = \"stericsson,ab8500-fg\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ab8500_fg_match);\n\nstruct platform_driver ab8500_fg_driver = {\n\t.probe = ab8500_fg_probe,\n\t.remove = ab8500_fg_remove,\n\t.driver = {\n\t\t.name = \"ab8500-fg\",\n\t\t.of_match_table = ab8500_fg_match,\n\t\t.pm = &ab8500_fg_pm_ops,\n\t},\n};\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Johan Palsson, Karl Komierowski\");\nMODULE_ALIAS(\"platform:ab8500-fg\");\nMODULE_DESCRIPTION(\"AB8500 Fuel Gauge driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}