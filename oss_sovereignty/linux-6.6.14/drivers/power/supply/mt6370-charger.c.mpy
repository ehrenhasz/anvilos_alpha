{
  "module_name": "mt6370-charger.c",
  "hash_id": "8cd3149b8b0d0a3dbd8de6729e0d71fa377f100b2830bfd436ec6f9a3059e33b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/mt6370-charger.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/devm-helpers.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/linear_range.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/workqueue.h>\n\n#define MT6370_REG_CHG_CTRL1\t\t0x111\n#define MT6370_REG_CHG_CTRL2\t\t0x112\n#define MT6370_REG_CHG_CTRL3\t\t0x113\n#define MT6370_REG_CHG_CTRL4\t\t0x114\n#define MT6370_REG_CHG_CTRL5\t\t0x115\n#define MT6370_REG_CHG_CTRL6\t\t0x116\n#define MT6370_REG_CHG_CTRL7\t\t0x117\n#define MT6370_REG_CHG_CTRL8\t\t0x118\n#define MT6370_REG_CHG_CTRL9\t\t0x119\n#define MT6370_REG_CHG_CTRL10\t\t0x11A\n#define MT6370_REG_DEVICE_TYPE\t\t0x122\n#define MT6370_REG_USB_STATUS1\t\t0x127\n#define MT6370_REG_CHG_STAT\t\t0x14A\n#define MT6370_REG_FLED_EN\t\t0x17E\n#define MT6370_REG_CHG_STAT1\t\t0X1D0\n#define MT6370_REG_OVPCTRL_STAT\t\t0x1D8\n\n#define MT6370_VOBST_MASK\t\tGENMASK(7, 2)\n#define MT6370_OTG_PIN_EN_MASK\t\tBIT(1)\n#define MT6370_OPA_MODE_MASK\t\tBIT(0)\n#define MT6370_OTG_OC_MASK\t\tGENMASK(2, 0)\n\n#define MT6370_MIVR_IBUS_TH_100_mA\t100000\n#define MT6370_ADC_CHAN_IBUS\t\t5\n#define MT6370_ADC_CHAN_MAX\t\t9\n\nenum mt6370_chg_reg_field {\n\t \n\tF_IINLMTSEL, F_CFO_EN, F_CHG_EN,\n\t \n\tF_IAICR, F_AICR_EN, F_ILIM_EN,\n\t \n\tF_VOREG,\n\t \n\tF_VMIVR,\n\t \n\tF_ICHG,\n\t \n\tF_IPREC,\n\t \n\tF_IEOC,\n\t \n\tF_USBCHGEN,\n\t \n\tF_USB_STAT, F_CHGDET,\n\t \n\tF_CHG_STAT, F_BOOST_STAT, F_VBAT_LVL,\n\t \n\tF_FL_STROBE,\n\t \n\tF_CHG_MIVR_STAT,\n\t \n\tF_UVP_D_STAT,\n\tF_MAX\n};\n\nenum mt6370_irq {\n\tMT6370_IRQ_ATTACH_I = 0,\n\tMT6370_IRQ_UVP_D_EVT,\n\tMT6370_IRQ_MIVR,\n\tMT6370_IRQ_MAX\n};\n\nstruct mt6370_priv {\n\tstruct device *dev;\n\tstruct iio_channel *iio_adcs;\n\tstruct mutex attach_lock;\n\tstruct power_supply *psy;\n\tstruct regmap *regmap;\n\tstruct regmap_field *rmap_fields[F_MAX];\n\tstruct regulator_dev *rdev;\n\tstruct workqueue_struct *wq;\n\tstruct work_struct bc12_work;\n\tstruct delayed_work mivr_dwork;\n\tunsigned int irq_nums[MT6370_IRQ_MAX];\n\tint attach;\n\tint psy_usb_type;\n\tbool pwr_rdy;\n};\n\nenum mt6370_usb_status {\n\tMT6370_USB_STAT_NO_VBUS = 0,\n\tMT6370_USB_STAT_VBUS_FLOW_IS_UNDER_GOING,\n\tMT6370_USB_STAT_SDP,\n\tMT6370_USB_STAT_SDP_NSTD,\n\tMT6370_USB_STAT_DCP,\n\tMT6370_USB_STAT_CDP,\n\tMT6370_USB_STAT_MAX\n};\n\nstruct mt6370_chg_field {\n\tconst char *name;\n\tconst struct linear_range *range;\n\tstruct reg_field field;\n};\n\nenum {\n\tMT6370_RANGE_F_IAICR = 0,\n\tMT6370_RANGE_F_VOREG,\n\tMT6370_RANGE_F_VMIVR,\n\tMT6370_RANGE_F_ICHG,\n\tMT6370_RANGE_F_IPREC,\n\tMT6370_RANGE_F_IEOC,\n\tMT6370_RANGE_F_MAX\n};\n\nstatic const struct linear_range mt6370_chg_ranges[MT6370_RANGE_F_MAX] = {\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_IAICR, 100000, 0x0, 0x3F, 50000),\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_VOREG, 3900000, 0x0, 0x51, 10000),\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_VMIVR, 3900000, 0x0, 0x5F, 100000),\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_ICHG, 900000, 0x08, 0x31, 100000),\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_IPREC, 100000, 0x0, 0x0F, 50000),\n\tLINEAR_RANGE_IDX(MT6370_RANGE_F_IEOC, 100000, 0x0, 0x0F, 50000),\n};\n\n#define MT6370_CHG_FIELD(_fd, _reg, _lsb, _msb)\t\t\t\t\\\n[_fd] = {\t\t\t\t\t\t\t\t\\\n\t.name = #_fd,\t\t\t\t\t\t\t\\\n\t.range = NULL,\t\t\t\t\t\t\t\\\n\t.field = REG_FIELD(_reg, _lsb, _msb),\t\t\t\t\\\n}\n\n#define MT6370_CHG_FIELD_RANGE(_fd, _reg, _lsb, _msb)\t\t\t\\\n[_fd] = {\t\t\t\t\t\t\t\t\\\n\t.name = #_fd,\t\t\t\t\t\t\t\\\n\t.range = &mt6370_chg_ranges[MT6370_RANGE_##_fd],\t\t\\\n\t.field = REG_FIELD(_reg, _lsb, _msb),\t\t\t\t\\\n}\n\nstatic const struct mt6370_chg_field mt6370_chg_fields[F_MAX] = {\n\tMT6370_CHG_FIELD(F_IINLMTSEL, MT6370_REG_CHG_CTRL2, 2, 3),\n\tMT6370_CHG_FIELD(F_CFO_EN, MT6370_REG_CHG_CTRL2, 1, 1),\n\tMT6370_CHG_FIELD(F_CHG_EN, MT6370_REG_CHG_CTRL2, 0, 0),\n\tMT6370_CHG_FIELD_RANGE(F_IAICR, MT6370_REG_CHG_CTRL3, 2, 7),\n\tMT6370_CHG_FIELD(F_AICR_EN, MT6370_REG_CHG_CTRL3, 1, 1),\n\tMT6370_CHG_FIELD(F_ILIM_EN, MT6370_REG_CHG_CTRL3, 0, 0),\n\tMT6370_CHG_FIELD_RANGE(F_VOREG, MT6370_REG_CHG_CTRL4, 1, 7),\n\tMT6370_CHG_FIELD_RANGE(F_VMIVR, MT6370_REG_CHG_CTRL6, 1, 7),\n\tMT6370_CHG_FIELD_RANGE(F_ICHG, MT6370_REG_CHG_CTRL7, 2, 7),\n\tMT6370_CHG_FIELD_RANGE(F_IPREC, MT6370_REG_CHG_CTRL8, 0, 3),\n\tMT6370_CHG_FIELD_RANGE(F_IEOC, MT6370_REG_CHG_CTRL9, 4, 7),\n\tMT6370_CHG_FIELD(F_USBCHGEN, MT6370_REG_DEVICE_TYPE, 7, 7),\n\tMT6370_CHG_FIELD(F_USB_STAT, MT6370_REG_USB_STATUS1, 4, 6),\n\tMT6370_CHG_FIELD(F_CHGDET, MT6370_REG_USB_STATUS1, 3, 3),\n\tMT6370_CHG_FIELD(F_CHG_STAT, MT6370_REG_CHG_STAT, 6, 7),\n\tMT6370_CHG_FIELD(F_BOOST_STAT, MT6370_REG_CHG_STAT, 3, 3),\n\tMT6370_CHG_FIELD(F_VBAT_LVL, MT6370_REG_CHG_STAT, 5, 5),\n\tMT6370_CHG_FIELD(F_FL_STROBE, MT6370_REG_FLED_EN, 2, 2),\n\tMT6370_CHG_FIELD(F_CHG_MIVR_STAT, MT6370_REG_CHG_STAT1, 6, 6),\n\tMT6370_CHG_FIELD(F_UVP_D_STAT, MT6370_REG_OVPCTRL_STAT, 4, 4),\n};\n\nstatic inline int mt6370_chg_field_get(struct mt6370_priv *priv,\n\t\t\t\t       enum mt6370_chg_reg_field fd,\n\t\t\t\t       unsigned int *val)\n{\n\tint ret;\n\tunsigned int reg_val;\n\n\tret = regmap_field_read(priv->rmap_fields[fd], &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mt6370_chg_fields[fd].range)\n\t\treturn linear_range_get_value(mt6370_chg_fields[fd].range,\n\t\t\t\t\t       reg_val, val);\n\n\t*val = reg_val;\n\treturn 0;\n}\n\nstatic inline int mt6370_chg_field_set(struct mt6370_priv *priv,\n\t\t\t\t       enum mt6370_chg_reg_field fd,\n\t\t\t\t       unsigned int val)\n{\n\tint ret;\n\tbool f;\n\tconst struct linear_range *r;\n\n\tif (mt6370_chg_fields[fd].range) {\n\t\tr = mt6370_chg_fields[fd].range;\n\n\t\tif (fd == F_VMIVR) {\n\t\t\tret = linear_range_get_selector_high(r, val, &val, &f);\n\t\t\tif (ret)\n\t\t\t\tval = r->max_sel;\n\t\t} else {\n\t\t\tlinear_range_get_selector_within(r, val, &val);\n\t\t}\n\t}\n\n\treturn regmap_field_write(priv->rmap_fields[fd], val);\n}\n\nenum {\n\tMT6370_CHG_STAT_READY = 0,\n\tMT6370_CHG_STAT_CHARGE_IN_PROGRESS,\n\tMT6370_CHG_STAT_DONE,\n\tMT6370_CHG_STAT_FAULT,\n\tMT6370_CHG_STAT_MAX\n};\n\nenum {\n\tMT6370_ATTACH_STAT_DETACH = 0,\n\tMT6370_ATTACH_STAT_ATTACH_WAIT_FOR_BC12,\n\tMT6370_ATTACH_STAT_ATTACH_BC12_DONE,\n\tMT6370_ATTACH_STAT_ATTACH_MAX\n};\n\nstatic int mt6370_chg_otg_of_parse_cb(struct device_node *of,\n\t\t\t\t      const struct regulator_desc *rdesc,\n\t\t\t\t      struct regulator_config *rcfg)\n{\n\tstruct mt6370_priv *priv = rcfg->driver_data;\n\n\trcfg->ena_gpiod = fwnode_gpiod_get_index(of_fwnode_handle(of),\n\t\t\t\t\t\t \"enable\", 0, GPIOD_OUT_LOW |\n\t\t\t\t\t\t GPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\t\t\t rdesc->name);\n\tif (IS_ERR(rcfg->ena_gpiod)) {\n\t\trcfg->ena_gpiod = NULL;\n\t\treturn 0;\n\t}\n\n\treturn regmap_update_bits(priv->regmap, MT6370_REG_CHG_CTRL1,\n\t\t\t\t  MT6370_OTG_PIN_EN_MASK,\n\t\t\t\t  MT6370_OTG_PIN_EN_MASK);\n}\n\nstatic void mt6370_chg_bc12_work_func(struct work_struct *work)\n{\n\tstruct mt6370_priv *priv = container_of(work, struct mt6370_priv,\n\t\t\t\t\t\tbc12_work);\n\tint ret;\n\tbool rpt_psy = false;\n\tunsigned int attach, usb_stat;\n\n\tmutex_lock(&priv->attach_lock);\n\tattach = priv->attach;\n\n\tswitch (attach) {\n\tcase MT6370_ATTACH_STAT_DETACH:\n\t\tusb_stat = 0;\n\t\tbreak;\n\tcase MT6370_ATTACH_STAT_ATTACH_WAIT_FOR_BC12:\n\t\tret = mt6370_chg_field_set(priv, F_USBCHGEN, attach);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev, \"Failed to enable USB CHG EN\\n\");\n\t\tgoto bc12_work_func_out;\n\tcase MT6370_ATTACH_STAT_ATTACH_BC12_DONE:\n\t\tret = mt6370_chg_field_get(priv, F_USB_STAT, &usb_stat);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to get USB status\\n\");\n\t\t\tgoto bc12_work_func_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"Invalid attach state\\n\");\n\t\tgoto bc12_work_func_out;\n\t}\n\n\trpt_psy = true;\n\n\tswitch (usb_stat) {\n\tcase MT6370_USB_STAT_SDP:\n\tcase MT6370_USB_STAT_SDP_NSTD:\n\t\tpriv->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase MT6370_USB_STAT_DCP:\n\t\tpriv->psy_usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase MT6370_USB_STAT_CDP:\n\t\tpriv->psy_usb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tbreak;\n\tcase MT6370_USB_STAT_NO_VBUS:\n\tcase MT6370_USB_STAT_VBUS_FLOW_IS_UNDER_GOING:\n\tdefault:\n\t\tpriv->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tbreak;\n\t}\n\nbc12_work_func_out:\n\tmutex_unlock(&priv->attach_lock);\n\n\tif (rpt_psy)\n\t\tpower_supply_changed(priv->psy);\n}\n\nstatic int mt6370_chg_toggle_cfo(struct mt6370_priv *priv)\n{\n\tint ret;\n\tunsigned int fl_strobe;\n\n\t \n\tret = mt6370_chg_field_get(priv, F_FL_STROBE, &fl_strobe);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get FL_STROBE_EN\\n\");\n\t\treturn ret;\n\t}\n\n\tif (fl_strobe) {\n\t\tdev_err(priv->dev, \"Flash led is still in strobe mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = mt6370_chg_field_set(priv, F_CFO_EN, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to disable CFO_EN\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt6370_chg_field_set(priv, F_CFO_EN, 1);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to enable CFO_EN\\n\");\n\n\treturn ret;\n}\n\nstatic int mt6370_chg_read_adc_chan(struct mt6370_priv *priv, unsigned int chan,\n\t\t\t\t    int *val)\n{\n\tint ret;\n\n\tif (chan >= MT6370_ADC_CHAN_MAX)\n\t\treturn -EINVAL;\n\n\tret = iio_read_channel_processed(&priv->iio_adcs[chan], val);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to read ADC\\n\");\n\n\treturn ret;\n}\n\nstatic void mt6370_chg_mivr_dwork_func(struct work_struct *work)\n{\n\tstruct mt6370_priv *priv = container_of(work, struct mt6370_priv,\n\t\t\t\t\t\tmivr_dwork.work);\n\tint ret;\n\tunsigned int mivr_stat, ibus;\n\n\tret = mt6370_chg_field_get(priv, F_CHG_MIVR_STAT, &mivr_stat);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get mivr state\\n\");\n\t\tgoto mivr_handler_out;\n\t}\n\n\tif (!mivr_stat)\n\t\tgoto mivr_handler_out;\n\n\tret = mt6370_chg_read_adc_chan(priv, MT6370_ADC_CHAN_IBUS, &ibus);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get ibus\\n\");\n\t\tgoto mivr_handler_out;\n\t}\n\n\tif (ibus < MT6370_MIVR_IBUS_TH_100_mA) {\n\t\tret = mt6370_chg_toggle_cfo(priv);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev, \"Failed to toggle cfo\\n\");\n\t}\n\nmivr_handler_out:\n\tenable_irq(priv->irq_nums[MT6370_IRQ_MIVR]);\n\tpm_relax(priv->dev);\n}\n\nstatic void mt6370_chg_pwr_rdy_check(struct mt6370_priv *priv)\n{\n\tint ret;\n\tunsigned int opposite_pwr_rdy, otg_en;\n\tunion power_supply_propval val;\n\n\t \n\tret = mt6370_chg_field_get(priv, F_BOOST_STAT, &otg_en);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get OTG state\\n\");\n\t\treturn;\n\t}\n\n\tif (otg_en)\n\t\treturn;\n\n\tret = mt6370_chg_field_get(priv, F_UVP_D_STAT, &opposite_pwr_rdy);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get opposite power ready state\\n\");\n\t\treturn;\n\t}\n\n\tval.intval = opposite_pwr_rdy ?\n\t\t     MT6370_ATTACH_STAT_DETACH :\n\t\t     MT6370_ATTACH_STAT_ATTACH_WAIT_FOR_BC12;\n\n\tret = power_supply_set_property(priv->psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t\t&val);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to start attach/detach flow\\n\");\n}\n\nstatic int mt6370_chg_get_online(struct mt6370_priv *priv,\n\t\t\t\t union power_supply_propval *val)\n{\n\tmutex_lock(&priv->attach_lock);\n\tval->intval = !!priv->attach;\n\tmutex_unlock(&priv->attach_lock);\n\n\treturn 0;\n}\n\nstatic int mt6370_chg_get_status(struct mt6370_priv *priv,\n\t\t\t\t union power_supply_propval *val)\n{\n\tint ret;\n\tunsigned int chg_stat;\n\tunion power_supply_propval online;\n\n\tret = power_supply_get_property(priv->psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t\t&online);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get online status\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!online.intval) {\n\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn 0;\n\t}\n\n\tret = mt6370_chg_field_get(priv, F_CHG_STAT, &chg_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (chg_stat) {\n\tcase MT6370_CHG_STAT_READY:\n\tcase MT6370_CHG_STAT_FAULT:\n\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\treturn ret;\n\tcase MT6370_CHG_STAT_CHARGE_IN_PROGRESS:\n\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\treturn ret;\n\tcase MT6370_CHG_STAT_DONE:\n\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\treturn ret;\n\tdefault:\n\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\treturn ret;\n\t}\n}\n\nstatic int mt6370_chg_get_charge_type(struct mt6370_priv *priv,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tint type, ret;\n\tunsigned int chg_stat, vbat_lvl;\n\n\tret = mt6370_chg_field_get(priv, F_CHG_STAT, &chg_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt6370_chg_field_get(priv, F_VBAT_LVL, &vbat_lvl);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (chg_stat) {\n\tcase MT6370_CHG_STAT_CHARGE_IN_PROGRESS:\n\t\tif (vbat_lvl)\n\t\t\ttype = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\telse\n\t\t\ttype = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase MT6370_CHG_STAT_READY:\n\tcase MT6370_CHG_STAT_DONE:\n\tcase MT6370_CHG_STAT_FAULT:\n\tdefault:\n\t\ttype = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\t}\n\n\tval->intval = type;\n\n\treturn 0;\n}\n\nstatic int mt6370_chg_set_online(struct mt6370_priv *priv,\n\t\t\t\t const union power_supply_propval *val)\n{\n\tbool pwr_rdy = !!val->intval;\n\n\tmutex_lock(&priv->attach_lock);\n\tif (pwr_rdy == !!priv->attach) {\n\t\tdev_err(priv->dev, \"pwr_rdy is same(%d)\\n\", pwr_rdy);\n\t\tmutex_unlock(&priv->attach_lock);\n\t\treturn 0;\n\t}\n\n\tpriv->attach = pwr_rdy;\n\tmutex_unlock(&priv->attach_lock);\n\n\tif (!queue_work(priv->wq, &priv->bc12_work))\n\t\tdev_err(priv->dev, \"bc12 work has already queued\\n\");\n\n\treturn 0;\n}\n\nstatic int mt6370_chg_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct mt6370_priv *priv = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn mt6370_chg_get_online(priv, val);\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn mt6370_chg_get_status(priv, val);\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\treturn mt6370_chg_get_charge_type(priv, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn mt6370_chg_field_get(priv, F_ICHG, &val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = linear_range_get_max_value(&mt6370_chg_ranges[MT6370_RANGE_F_ICHG]);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn mt6370_chg_field_get(priv, F_VOREG, &val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = linear_range_get_max_value(&mt6370_chg_ranges[MT6370_RANGE_F_VOREG]);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn mt6370_chg_field_get(priv, F_IAICR, &val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn mt6370_chg_field_get(priv, F_VMIVR, &val->intval);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn mt6370_chg_field_get(priv, F_IPREC, &val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn mt6370_chg_field_get(priv, F_IEOC, &val->intval);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = priv->psy_usb_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt6370_chg_set_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tstruct mt6370_priv *priv = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn mt6370_chg_set_online(priv, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn mt6370_chg_field_set(priv, F_ICHG, val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn mt6370_chg_field_set(priv, F_VOREG, val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn mt6370_chg_field_set(priv, F_IAICR, val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn mt6370_chg_field_set(priv, F_VMIVR, val->intval);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn mt6370_chg_field_set(priv, F_IPREC, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn mt6370_chg_field_set(priv, F_IEOC, val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt6370_chg_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t    enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum power_supply_property mt6370_chg_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n};\n\nstatic enum power_supply_usb_type mt6370_chg_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n};\n\nstatic const struct power_supply_desc mt6370_chg_psy_desc = {\n\t.name = \"mt6370-charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = mt6370_chg_properties,\n\t.num_properties = ARRAY_SIZE(mt6370_chg_properties),\n\t.get_property = mt6370_chg_get_property,\n\t.set_property = mt6370_chg_set_property,\n\t.property_is_writeable = mt6370_chg_property_is_writeable,\n\t.usb_types = mt6370_chg_usb_types,\n\t.num_usb_types = ARRAY_SIZE(mt6370_chg_usb_types),\n};\n\nstatic const struct regulator_ops mt6370_chg_otg_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n};\n\nstatic const u32 mt6370_chg_otg_oc_ma[] = {\n\t500000, 700000, 1100000, 1300000, 1800000, 2100000, 2400000,\n};\n\nstatic const struct regulator_desc mt6370_chg_otg_rdesc = {\n\t.of_match = \"usb-otg-vbus-regulator\",\n\t.of_parse_cb = mt6370_chg_otg_of_parse_cb,\n\t.name = \"mt6370-usb-otg-vbus\",\n\t.ops = &mt6370_chg_otg_ops,\n\t.owner = THIS_MODULE,\n\t.type = REGULATOR_VOLTAGE,\n\t.min_uV = 4425000,\n\t.uV_step = 25000,\n\t.n_voltages = 57,\n\t.vsel_reg = MT6370_REG_CHG_CTRL5,\n\t.vsel_mask = MT6370_VOBST_MASK,\n\t.enable_reg = MT6370_REG_CHG_CTRL1,\n\t.enable_mask = MT6370_OPA_MODE_MASK,\n\t.curr_table = mt6370_chg_otg_oc_ma,\n\t.n_current_limits = ARRAY_SIZE(mt6370_chg_otg_oc_ma),\n\t.csel_reg = MT6370_REG_CHG_CTRL10,\n\t.csel_mask = MT6370_OTG_OC_MASK,\n};\n\nstatic int mt6370_chg_init_rmap_fields(struct mt6370_priv *priv)\n{\n\tint i;\n\tconst struct mt6370_chg_field *fds = mt6370_chg_fields;\n\n\tfor (i = 0; i < F_MAX; i++) {\n\t\tpriv->rmap_fields[i] = devm_regmap_field_alloc(priv->dev,\n\t\t\t\t\t\t\t       priv->regmap,\n\t\t\t\t\t\t\t       fds[i].field);\n\t\tif (IS_ERR(priv->rmap_fields[i]))\n\t\t\treturn dev_err_probe(priv->dev,\n\t\t\t\t\tPTR_ERR(priv->rmap_fields[i]),\n\t\t\t\t\t\"Failed to allocate regmapfield[%s]\\n\",\n\t\t\t\t\tfds[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt6370_chg_init_setting(struct mt6370_priv *priv)\n{\n\tint ret;\n\n\t \n\tret = mt6370_chg_field_set(priv, F_USBCHGEN, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to disable usb_chg_en\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt6370_chg_field_set(priv, F_ILIM_EN, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to disable input current limit\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt6370_chg_field_set(priv, F_ICHG, 900000);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set ICHG to 900mA\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt6370_chg_field_set(priv, F_IINLMTSEL, 2);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to set IINLMTSEL\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define MT6370_CHG_DT_PROP_DECL(_name, _type, _field)\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = \"mediatek,chg-\" #_name,\t\t\t\\\n\t.type = MT6370_PARSE_TYPE_##_type,\t\t\\\n\t.fd = _field,\t\t\t\t\t\\\n}\n\nstatic int mt6370_chg_init_otg_regulator(struct mt6370_priv *priv)\n{\n\tstruct regulator_config rcfg = {\n\t\t.dev = priv->dev,\n\t\t.regmap = priv->regmap,\n\t\t.driver_data = priv,\n\t};\n\n\tpriv->rdev = devm_regulator_register(priv->dev, &mt6370_chg_otg_rdesc,\n\t\t\t\t\t     &rcfg);\n\n\treturn PTR_ERR_OR_ZERO(priv->rdev);\n}\n\nstatic int mt6370_chg_init_psy(struct mt6370_priv *priv)\n{\n\tstruct power_supply_config cfg = {\n\t\t.drv_data = priv,\n\t\t.of_node = dev_of_node(priv->dev),\n\t};\n\n\tpriv->psy = devm_power_supply_register(priv->dev, &mt6370_chg_psy_desc,\n\t\t\t\t\t       &cfg);\n\n\treturn PTR_ERR_OR_ZERO(priv->psy);\n}\n\nstatic void mt6370_chg_destroy_attach_lock(void *data)\n{\n\tstruct mutex *attach_lock = data;\n\n\tmutex_destroy(attach_lock);\n}\n\nstatic void mt6370_chg_destroy_wq(void *data)\n{\n\tstruct workqueue_struct *wq = data;\n\n\tflush_workqueue(wq);\n\tdestroy_workqueue(wq);\n}\n\nstatic irqreturn_t mt6370_attach_i_handler(int irq, void *data)\n{\n\tstruct mt6370_priv *priv = data;\n\tunsigned int otg_en;\n\tint ret;\n\n\t \n\tret = mt6370_chg_field_get(priv, F_BOOST_STAT, &otg_en);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get OTG state\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (otg_en)\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&priv->attach_lock);\n\tpriv->attach = MT6370_ATTACH_STAT_ATTACH_BC12_DONE;\n\tmutex_unlock(&priv->attach_lock);\n\n\tif (!queue_work(priv->wq, &priv->bc12_work))\n\t\tdev_err(priv->dev, \"bc12 work has already queued\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mt6370_uvp_d_evt_handler(int irq, void *data)\n{\n\tstruct mt6370_priv *priv = data;\n\n\tmt6370_chg_pwr_rdy_check(priv);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mt6370_mivr_handler(int irq, void *data)\n{\n\tstruct mt6370_priv *priv = data;\n\n\tpm_stay_awake(priv->dev);\n\tdisable_irq_nosync(priv->irq_nums[MT6370_IRQ_MIVR]);\n\tschedule_delayed_work(&priv->mivr_dwork, msecs_to_jiffies(200));\n\n\treturn IRQ_HANDLED;\n}\n\n#define MT6370_CHG_IRQ(_name)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.name = #_name,\t\t\t\t\t\t\t\\\n\t.handler = mt6370_##_name##_handler,\t\t\t\t\\\n}\n\nstatic int mt6370_chg_init_irq(struct mt6370_priv *priv)\n{\n\tint i, ret;\n\tconst struct {\n\t\tchar *name;\n\t\tirq_handler_t handler;\n\t} mt6370_chg_irqs[] = {\n\t\tMT6370_CHG_IRQ(attach_i),\n\t\tMT6370_CHG_IRQ(uvp_d_evt),\n\t\tMT6370_CHG_IRQ(mivr),\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(mt6370_chg_irqs); i++) {\n\t\tret = platform_get_irq_byname(to_platform_device(priv->dev),\n\t\t\t\t\t      mt6370_chg_irqs[i].name);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(priv->dev, ret,\n\t\t\t\t\t     \"Failed to get irq %s\\n\",\n\t\t\t\t\t     mt6370_chg_irqs[i].name);\n\n\t\tpriv->irq_nums[i] = ret;\n\t\tret = devm_request_threaded_irq(priv->dev, ret, NULL,\n\t\t\t\t\t\tmt6370_chg_irqs[i].handler,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\t\tdev_name(priv->dev), priv);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(priv->dev, ret,\n\t\t\t\t\t     \"Failed to request irq %s\\n\",\n\t\t\t\t\t     mt6370_chg_irqs[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt6370_chg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mt6370_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\tpriv->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!priv->regmap)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to get regmap\\n\");\n\n\tret = mt6370_chg_init_rmap_fields(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init regmap fields\\n\");\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->iio_adcs = devm_iio_channel_get_all(priv->dev);\n\tif (IS_ERR(priv->iio_adcs))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->iio_adcs),\n\t\t\t\t     \"Failed to get iio adc\\n\");\n\n\tret = mt6370_chg_init_otg_regulator(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init OTG regulator\\n\");\n\n\tret = mt6370_chg_init_psy(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init psy\\n\");\n\n\tmutex_init(&priv->attach_lock);\n\tret = devm_add_action_or_reset(dev, mt6370_chg_destroy_attach_lock,\n\t\t\t\t       &priv->attach_lock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init attach lock\\n\");\n\n\tpriv->attach = MT6370_ATTACH_STAT_DETACH;\n\n\tpriv->wq = create_singlethread_workqueue(dev_name(priv->dev));\n\tif (!priv->wq)\n\t\treturn dev_err_probe(dev, -ENOMEM,\n\t\t\t\t     \"Failed to create workqueue\\n\");\n\n\tret = devm_add_action_or_reset(dev, mt6370_chg_destroy_wq, priv->wq);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init wq\\n\");\n\n\tret = devm_work_autocancel(dev, &priv->bc12_work, mt6370_chg_bc12_work_func);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init bc12 work\\n\");\n\n\tret = devm_delayed_work_autocancel(dev, &priv->mivr_dwork, mt6370_chg_mivr_dwork_func);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init mivr delayed work\\n\");\n\n\tret = mt6370_chg_init_setting(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to init mt6370 charger setting\\n\");\n\n\tret = mt6370_chg_init_irq(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmt6370_chg_pwr_rdy_check(priv);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mt6370_chg_of_match[] = {\n\t{ .compatible = \"mediatek,mt6370-charger\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6370_chg_of_match);\n\nstatic struct platform_driver mt6370_chg_driver = {\n\t.probe = mt6370_chg_probe,\n\t.driver = {\n\t\t.name = \"mt6370-charger\",\n\t\t.of_match_table = mt6370_chg_of_match,\n\t},\n};\nmodule_platform_driver(mt6370_chg_driver);\n\nMODULE_AUTHOR(\"ChiaEn Wu <chiaen_wu@richtek.com>\");\nMODULE_DESCRIPTION(\"MediaTek MT6370 Charger Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}