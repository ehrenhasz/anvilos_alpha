{
  "module_name": "88pm860x_charger.c",
  "hash_id": "10fbcb6e1c1e3dc414b0ea92353fc915be2da84b4fde93e41d0b98962375d952",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/88pm860x_charger.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/power_supply.h>\n#include <linux/mfd/88pm860x.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <asm/div64.h>\n\n \n#define STATUS2_CHG\t\t(1 << 2)\n\n \n#define RESET_SW_PD\t\t(1 << 7)\n\n \n#define PREREG1_90MA\t\t(0x0)\n#define PREREG1_180MA\t\t(0x1)\n#define PREREG1_450MA\t\t(0x4)\n#define PREREG1_540MA\t\t(0x5)\n#define PREREG1_1350MA\t\t(0xE)\n#define PREREG1_VSYS_4_5V\t(3 << 4)\n\n \n#define CC1_MODE_OFF\t\t(0)\n#define CC1_MODE_PRECHARGE\t(1)\n#define CC1_MODE_FASTCHARGE\t(2)\n#define CC1_MODE_PULSECHARGE\t(3)\n#define CC1_ITERM_20MA\t\t(0 << 2)\n#define CC1_ITERM_60MA\t\t(2 << 2)\n#define CC1_VFCHG_4_2V\t\t(9 << 4)\n\n \n#define CC2_ICHG_100MA\t\t(0x1)\n#define CC2_ICHG_500MA\t\t(0x9)\n#define CC2_ICHG_1000MA\t\t(0x13)\n\n \n#define CC3_180MIN_TIMEOUT\t(0x6 << 4)\n#define CC3_270MIN_TIMEOUT\t(0x7 << 4)\n#define CC3_360MIN_TIMEOUT\t(0xA << 4)\n#define CC3_DISABLE_TIMEOUT\t(0xF << 4)\n\n \n#define CC4_IPRE_40MA\t\t(7)\n#define CC4_VPCHG_3_2V\t\t(3 << 4)\n#define CC4_IFCHG_MON_EN\t(1 << 6)\n#define CC4_BTEMP_MON_EN\t(1 << 7)\n\n \n#define CC6_BAT_OV_EN\t\t(1 << 2)\n#define CC6_BAT_UV_EN\t\t(1 << 3)\n#define CC6_UV_VBAT_SET\t\t(0x3 << 6)\t \n\n \n#define CC7_BAT_REM_EN\t\t(1 << 3)\n#define CC7_IFSM_EN\t\t(1 << 7)\n\n \n#define MEAS1_VBAT\t\t(1 << 0)\n\n \n#define MEAS3_IBAT_EN\t\t(1 << 0)\n#define MEAS3_CC_EN\t\t(1 << 2)\n\n#define FSM_INIT\t\t0\n#define FSM_DISCHARGE\t\t1\n#define FSM_PRECHARGE\t\t2\n#define FSM_FASTCHARGE\t\t3\n\n#define PRECHARGE_THRESHOLD\t3100\n#define POWEROFF_THRESHOLD\t3400\n#define CHARGE_THRESHOLD\t4000\n#define DISCHARGE_THRESHOLD\t4180\n\n \n#define OVER_TEMP_FLAG\t\t(1 << 6)\n#define OVTEMP_AUTORECOVER\t(1 << 3)\n\n \n#define VCHG_NORMAL_LOW\t\t4200\n#define VCHG_NORMAL_CHECK\t5800\n#define VCHG_NORMAL_HIGH\t6000\n#define VCHG_OVP_LOW\t\t5500\n\nstruct pm860x_charger_info {\n\tstruct pm860x_chip *chip;\n\tstruct i2c_client *i2c;\n\tstruct i2c_client *i2c_8606;\n\tstruct device *dev;\n\n\tstruct power_supply *usb;\n\tstruct mutex lock;\n\tint irq_nums;\n\tint irq[7];\n\tunsigned state:3;\t \n\tunsigned online:1;\t \n\tunsigned present:1;\t \n\tunsigned allowed:1;\n};\n\nstatic char *pm860x_supplied_to[] = {\n\t\"battery-monitor\",\n};\n\nstatic int measure_vchg(struct pm860x_charger_info *info, int *data)\n{\n\tunsigned char buf[2];\n\tint ret = 0;\n\n\tret = pm860x_bulk_read(info->i2c, PM8607_VCHG_MEAS1, 2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);\n\t \n\t*data = ((*data & 0xfff) * 9 * 125) >> 9;\n\n\tdev_dbg(info->dev, \"%s, vchg: %d mv\\n\", __func__, *data);\n\n\treturn ret;\n}\n\nstatic void set_vchg_threshold(struct pm860x_charger_info *info,\n\t\t\t       int min, int max)\n{\n\tint data;\n\n\t \n\tif (min <= 0)\n\t\tdata = 0;\n\telse\n\t\tdata = (min << 5) / 1125;\n\tpm860x_reg_write(info->i2c, PM8607_VCHG_LOWTH, data);\n\tdev_dbg(info->dev, \"VCHG_LOWTH:%dmv, 0x%x\\n\", min, data);\n\n\tif (max <= 0)\n\t\tdata = 0xff;\n\telse\n\t\tdata = (max << 5) / 1125;\n\tpm860x_reg_write(info->i2c, PM8607_VCHG_HIGHTH, data);\n\tdev_dbg(info->dev, \"VCHG_HIGHTH:%dmv, 0x%x\\n\", max, data);\n\n}\n\nstatic void set_vbatt_threshold(struct pm860x_charger_info *info,\n\t\t\t\tint min, int max)\n{\n\tint data;\n\n\t \n\tif (min <= 0)\n\t\tdata = 0;\n\telse\n\t\tdata = (min << 5) / 675;\n\tpm860x_reg_write(info->i2c, PM8607_VBAT_LOWTH, data);\n\tdev_dbg(info->dev, \"VBAT Min:%dmv, LOWTH:0x%x\\n\", min, data);\n\n\tif (max <= 0)\n\t\tdata = 0xff;\n\telse\n\t\tdata = (max << 5) / 675;\n\tpm860x_reg_write(info->i2c, PM8607_VBAT_HIGHTH, data);\n\tdev_dbg(info->dev, \"VBAT Max:%dmv, HIGHTH:0x%x\\n\", max, data);\n\n\treturn;\n}\n\nstatic int start_precharge(struct pm860x_charger_info *info)\n{\n\tint ret;\n\n\tdev_dbg(info->dev, \"Start Pre-charging!\\n\");\n\tset_vbatt_threshold(info, 0, 0);\n\n\tret = pm860x_reg_write(info->i2c_8606, PM8606_PREREGULATORA,\n\t\t\t       PREREG1_1350MA | PREREG1_VSYS_4_5V);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\n\t\t\t      CC1_MODE_OFF);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL3, (0xf << 4),\n\t\t\t      CC3_270MIN_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_reg_write(info->i2c, PM8607_CHG_CTRL4,\n\t\t\t       CC4_IPRE_40MA | CC4_VPCHG_3_2V |\n\t\t\t       CC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL7,\n\t\t\t      CC7_BAT_REM_EN | CC7_IFSM_EN,\n\t\t\t      CC7_BAT_REM_EN | CC7_IFSM_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\n\t\t\t      CC1_MODE_PRECHARGE);\nout:\n\treturn ret;\n}\n\nstatic int start_fastcharge(struct pm860x_charger_info *info)\n{\n\tint ret;\n\n\tdev_dbg(info->dev, \"Start Fast-charging!\\n\");\n\n\t \n\tret = pm860x_reg_write(info->i2c, PM8607_CHG_CTRL1,\n\t\t\t       CC1_MODE_OFF | CC1_ITERM_60MA |\n\t\t\t       CC1_VFCHG_4_2V);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_reg_write(info->i2c_8606, PM8606_PREREGULATORA,\n\t\t\t       PREREG1_540MA | PREREG1_VSYS_4_5V);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL2, 0x1f,\n\t\t\t      CC2_ICHG_500MA);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL3, (0xf << 4),\n\t\t\t      CC3_270MIN_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL4,\n\t\t\t      CC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN,\n\t\t\t      CC4_IFCHG_MON_EN | CC4_BTEMP_MON_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL6,\n\t\t\t      CC6_BAT_OV_EN | CC6_BAT_UV_EN |\n\t\t\t      CC6_UV_VBAT_SET,\n\t\t\t      CC6_BAT_OV_EN | CC6_BAT_UV_EN |\n\t\t\t      CC6_UV_VBAT_SET);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL7,\n\t\t\t      CC7_BAT_REM_EN | CC7_IFSM_EN,\n\t\t\t      CC7_BAT_REM_EN | CC7_IFSM_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3,\n\t\t\t      CC1_MODE_FASTCHARGE);\n\t \n\tset_vchg_threshold(info, VCHG_NORMAL_LOW, VCHG_NORMAL_HIGH);\nout:\n\treturn ret;\n}\n\nstatic void stop_charge(struct pm860x_charger_info *info, int vbatt)\n{\n\tdev_dbg(info->dev, \"Stop charging!\\n\");\n\tpm860x_set_bits(info->i2c, PM8607_CHG_CTRL1, 3, CC1_MODE_OFF);\n\tif (vbatt > CHARGE_THRESHOLD && info->online)\n\t\tset_vbatt_threshold(info, CHARGE_THRESHOLD, 0);\n}\n\nstatic void power_off_notification(struct pm860x_charger_info *info)\n{\n\tdev_dbg(info->dev, \"Power-off notification!\\n\");\n}\n\nstatic int set_charging_fsm(struct pm860x_charger_info *info)\n{\n\tstruct power_supply *psy;\n\tunion power_supply_propval data;\n\tunsigned char fsm_state[][16] = { \"init\", \"discharge\", \"precharge\",\n\t\t\"fastcharge\",\n\t};\n\tint ret;\n\tint vbatt;\n\n\tpsy = power_supply_get_by_name(pm860x_supplied_to[0]);\n\tif (!psy)\n\t\treturn -EINVAL;\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_VOLTAGE_NOW,\n\t\t\t&data);\n\tif (ret) {\n\t\tpower_supply_put(psy);\n\t\treturn ret;\n\t}\n\tvbatt = data.intval / 1000;\n\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_PRESENT, &data);\n\tif (ret) {\n\t\tpower_supply_put(psy);\n\t\treturn ret;\n\t}\n\tpower_supply_put(psy);\n\n\tmutex_lock(&info->lock);\n\tinfo->present = data.intval;\n\n\tdev_dbg(info->dev, \"Entering FSM:%s, Charger:%s, Battery:%s, \"\n\t\t\"Allowed:%d\\n\",\n\t\t&fsm_state[info->state][0],\n\t\t(info->online) ? \"online\" : \"N/A\",\n\t\t(info->present) ? \"present\" : \"N/A\", info->allowed);\n\tdev_dbg(info->dev, \"set_charging_fsm:vbatt:%d(mV)\\n\", vbatt);\n\n\tswitch (info->state) {\n\tcase FSM_INIT:\n\t\tif (info->online && info->present && info->allowed) {\n\t\t\tif (vbatt < PRECHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_PRECHARGE;\n\t\t\t\tstart_precharge(info);\n\t\t\t} else if (vbatt > DISCHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_DISCHARGE;\n\t\t\t\tstop_charge(info, vbatt);\n\t\t\t} else if (vbatt < DISCHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_FASTCHARGE;\n\t\t\t\tstart_fastcharge(info);\n\t\t\t}\n\t\t} else {\n\t\t\tif (vbatt < POWEROFF_THRESHOLD) {\n\t\t\t\tpower_off_notification(info);\n\t\t\t} else {\n\t\t\t\tinfo->state = FSM_DISCHARGE;\n\t\t\t\tstop_charge(info, vbatt);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FSM_PRECHARGE:\n\t\tif (info->online && info->present && info->allowed) {\n\t\t\tif (vbatt > PRECHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_FASTCHARGE;\n\t\t\t\tstart_fastcharge(info);\n\t\t\t}\n\t\t} else {\n\t\t\tinfo->state = FSM_DISCHARGE;\n\t\t\tstop_charge(info, vbatt);\n\t\t}\n\t\tbreak;\n\tcase FSM_FASTCHARGE:\n\t\tif (info->online && info->present && info->allowed) {\n\t\t\tif (vbatt < PRECHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_PRECHARGE;\n\t\t\t\tstart_precharge(info);\n\t\t\t}\n\t\t} else {\n\t\t\tinfo->state = FSM_DISCHARGE;\n\t\t\tstop_charge(info, vbatt);\n\t\t}\n\t\tbreak;\n\tcase FSM_DISCHARGE:\n\t\tif (info->online && info->present && info->allowed) {\n\t\t\tif (vbatt < PRECHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_PRECHARGE;\n\t\t\t\tstart_precharge(info);\n\t\t\t} else if (vbatt < DISCHARGE_THRESHOLD) {\n\t\t\t\tinfo->state = FSM_FASTCHARGE;\n\t\t\t\tstart_fastcharge(info);\n\t\t\t}\n\t\t} else {\n\t\t\tif (vbatt < POWEROFF_THRESHOLD)\n\t\t\t\tpower_off_notification(info);\n\t\t\telse if (vbatt > CHARGE_THRESHOLD && info->online)\n\t\t\t\tset_vbatt_threshold(info, CHARGE_THRESHOLD, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(info->dev, \"FSM meets wrong state:%d\\n\",\n\t\t\t info->state);\n\t\tbreak;\n\t}\n\tdev_dbg(info->dev,\n\t\t\"Out FSM:%s, Charger:%s, Battery:%s, Allowed:%d\\n\",\n\t\t&fsm_state[info->state][0],\n\t\t(info->online) ? \"online\" : \"N/A\",\n\t\t(info->present) ? \"present\" : \"N/A\", info->allowed);\n\tmutex_unlock(&info->lock);\n\n\treturn 0;\n}\n\nstatic irqreturn_t pm860x_charger_handler(int irq, void *data)\n{\n\tstruct pm860x_charger_info *info = data;\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\n\tif (ret < 0) {\n\t\tmutex_unlock(&info->lock);\n\t\tgoto out;\n\t}\n\tif (ret & STATUS2_CHG) {\n\t\tinfo->online = 1;\n\t\tinfo->allowed = 1;\n\t} else {\n\t\tinfo->online = 0;\n\t\tinfo->allowed = 0;\n\t}\n\tmutex_unlock(&info->lock);\n\tdev_dbg(info->dev, \"%s, Charger:%s, Allowed:%d\\n\", __func__,\n\t\t(info->online) ? \"online\" : \"N/A\", info->allowed);\n\n\tset_charging_fsm(info);\n\n\tpower_supply_changed(info->usb);\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_temp_handler(int irq, void *data)\n{\n\tstruct power_supply *psy;\n\tstruct pm860x_charger_info *info = data;\n\tunion power_supply_propval temp;\n\tint value;\n\tint ret;\n\n\tpsy = power_supply_get_by_name(pm860x_supplied_to[0]);\n\tif (!psy)\n\t\treturn IRQ_HANDLED;\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_TEMP, &temp);\n\tif (ret)\n\t\tgoto out;\n\tvalue = temp.intval / 10;\n\n\tmutex_lock(&info->lock);\n\t \n\tif (value < -10 || value > 40)\n\t\tinfo->allowed = 0;\n\telse\n\t\tinfo->allowed = 1;\n\tdev_dbg(info->dev, \"%s, Allowed: %d\\n\", __func__, info->allowed);\n\tmutex_unlock(&info->lock);\n\n\tset_charging_fsm(info);\nout:\n\tpower_supply_put(psy);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_exception_handler(int irq, void *data)\n{\n\tstruct pm860x_charger_info *info = data;\n\n\tmutex_lock(&info->lock);\n\tinfo->allowed = 0;\n\tmutex_unlock(&info->lock);\n\tdev_dbg(info->dev, \"%s, irq: %d\\n\", __func__, irq);\n\n\tset_charging_fsm(info);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_done_handler(int irq, void *data)\n{\n\tstruct pm860x_charger_info *info = data;\n\tstruct power_supply *psy;\n\tunion power_supply_propval val;\n\tint ret;\n\tint vbatt;\n\n\tmutex_lock(&info->lock);\n\t \n\tif (info->state == FSM_PRECHARGE) {\n\t\tinfo->allowed = 1;\n\t\tgoto out;\n\t}\n\t \n\tmdelay(5);\n\tinfo->allowed = 0;\n\tpsy = power_supply_get_by_name(pm860x_supplied_to[0]);\n\tif (!psy)\n\t\tgoto out;\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_VOLTAGE_NOW,\n\t\t\t&val);\n\tif (ret)\n\t\tgoto out_psy_put;\n\tvbatt = val.intval / 1000;\n\t \n\tret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\n\tif (ret < 0)\n\t\tgoto out_psy_put;\n\tif (vbatt > CHARGE_THRESHOLD && ret & STATUS2_CHG)\n\t\tpower_supply_set_property(psy, POWER_SUPPLY_PROP_CHARGE_FULL,\n\t\t\t\t&val);\n\nout_psy_put:\n\tpower_supply_put(psy);\nout:\n\tmutex_unlock(&info->lock);\n\tdev_dbg(info->dev, \"%s, Allowed: %d\\n\", __func__, info->allowed);\n\tset_charging_fsm(info);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_vbattery_handler(int irq, void *data)\n{\n\tstruct pm860x_charger_info *info = data;\n\n\tmutex_lock(&info->lock);\n\n\tset_vbatt_threshold(info, 0, 0);\n\n\tif (info->present && info->online)\n\t\tinfo->allowed = 1;\n\telse\n\t\tinfo->allowed = 0;\n\tmutex_unlock(&info->lock);\n\tdev_dbg(info->dev, \"%s, Allowed: %d\\n\", __func__, info->allowed);\n\n\tset_charging_fsm(info);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_vchg_handler(int irq, void *data)\n{\n\tstruct pm860x_charger_info *info = data;\n\tint vchg = 0;\n\n\tif (info->present)\n\t\tgoto out;\n\n\tmeasure_vchg(info, &vchg);\n\n\tmutex_lock(&info->lock);\n\tif (!info->online) {\n\t\tint status;\n\t\t \n\t\tstatus = pm860x_reg_read(info->i2c_8606, PM8606_FLAGS);\n\t\tif (status & OVER_TEMP_FLAG) {\n\t\t\t \n\t\t\tpm860x_set_bits(info->i2c_8606, PM8606_FLAGS,\n\t\t\t\t\tOVER_TEMP_FLAG, OVER_TEMP_FLAG);\n\t\t\tpm860x_set_bits(info->i2c_8606,\n\t\t\t\t\tPM8606_VSYS,\n\t\t\t\t\tOVTEMP_AUTORECOVER,\n\t\t\t\t\tOVTEMP_AUTORECOVER);\n\t\t\tdev_dbg(info->dev,\n\t\t\t\t\"%s, pm8606 over-temp occurred\\n\", __func__);\n\t\t}\n\t}\n\n\tif (vchg > VCHG_NORMAL_CHECK) {\n\t\tset_vchg_threshold(info, VCHG_OVP_LOW, 0);\n\t\tinfo->allowed = 0;\n\t\tdev_dbg(info->dev,\n\t\t\t\"%s,pm8607 over-vchg occurred,vchg = %dmv\\n\",\n\t\t\t__func__, vchg);\n\t} else if (vchg < VCHG_OVP_LOW) {\n\t\tset_vchg_threshold(info, VCHG_NORMAL_LOW,\n\t\t\t\t   VCHG_NORMAL_HIGH);\n\t\tinfo->allowed = 1;\n\t\tdev_dbg(info->dev,\n\t\t\t\"%s,pm8607 over-vchg recover,vchg = %dmv\\n\",\n\t\t\t__func__, vchg);\n\t}\n\tmutex_unlock(&info->lock);\n\n\tdev_dbg(info->dev, \"%s, Allowed: %d\\n\", __func__, info->allowed);\n\tset_charging_fsm(info);\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm860x_usb_get_prop(struct power_supply *psy,\n\t\t\t       enum power_supply_property psp,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct pm860x_charger_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (info->state == FSM_FASTCHARGE ||\n\t\t\t\tinfo->state == FSM_PRECHARGE)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = info->online;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property pm860x_usb_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic int pm860x_init_charger(struct pm860x_charger_info *info)\n{\n\tint ret;\n\n\tret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&info->lock);\n\tinfo->state = FSM_INIT;\n\tif (ret & STATUS2_CHG) {\n\t\tinfo->online = 1;\n\t\tinfo->allowed = 1;\n\t} else {\n\t\tinfo->online = 0;\n\t\tinfo->allowed = 0;\n\t}\n\tmutex_unlock(&info->lock);\n\n\tset_charging_fsm(info);\n\treturn 0;\n}\n\nstatic struct pm860x_irq_desc {\n\tconst char *name;\n\tirqreturn_t (*handler)(int irq, void *data);\n} pm860x_irq_descs[] = {\n\t{ \"usb supply detect\", pm860x_charger_handler },\n\t{ \"charge done\", pm860x_done_handler },\n\t{ \"charge timeout\", pm860x_exception_handler },\n\t{ \"charge fault\", pm860x_exception_handler },\n\t{ \"temperature\", pm860x_temp_handler },\n\t{ \"vbatt\", pm860x_vbattery_handler },\n\t{ \"vchg\", pm860x_vchg_handler },\n};\n\nstatic const struct power_supply_desc pm860x_charger_desc = {\n\t.name\t\t= \"usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t= pm860x_usb_props,\n\t.num_properties\t= ARRAY_SIZE(pm860x_usb_props),\n\t.get_property\t= pm860x_usb_get_prop,\n};\n\nstatic int pm860x_charger_probe(struct platform_device *pdev)\n{\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config psy_cfg = {};\n\tstruct pm860x_charger_info *info;\n\tint ret;\n\tint count;\n\tint i;\n\tint j;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tcount = pdev->num_resources;\n\tfor (i = 0, j = 0; i < count; i++) {\n\t\tinfo->irq[j] = platform_get_irq(pdev, i);\n\t\tif (info->irq[j] < 0)\n\t\t\tcontinue;\n\t\tj++;\n\t}\n\tinfo->irq_nums = j;\n\n\tinfo->chip = chip;\n\tinfo->i2c =\n\t    (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\n\tinfo->i2c_8606 =\n\t    (chip->id == CHIP_PM8607) ? chip->companion : chip->client;\n\tif (!info->i2c_8606) {\n\t\tdev_err(&pdev->dev, \"Missed I2C address of 88PM8606!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinfo->dev = &pdev->dev;\n\n\t \n\tset_vchg_threshold(info, VCHG_NORMAL_LOW, VCHG_OVP_LOW);\n\n\tmutex_init(&info->lock);\n\tplatform_set_drvdata(pdev, info);\n\n\tpsy_cfg.drv_data = info;\n\tpsy_cfg.supplied_to = pm860x_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);\n\tinfo->usb = devm_power_supply_register(&pdev->dev, &pm860x_charger_desc,\n\t\t\t\t\t       &psy_cfg);\n\tif (IS_ERR(info->usb)) {\n\t\treturn PTR_ERR(info->usb);\n\t}\n\n\tpm860x_init_charger(info);\n\n\tfor (i = 0; i < ARRAY_SIZE(info->irq); i++) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, info->irq[i], NULL,\n\t\t\t\t\t\tpm860x_irq_descs[i].handler,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tpm860x_irq_descs[i].name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\t\tinfo->irq[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver pm860x_charger_driver = {\n\t.driver = {\n\t\t   .name = \"88pm860x-charger\",\n\t},\n\t.probe = pm860x_charger_probe,\n};\nmodule_platform_driver(pm860x_charger_driver);\n\nMODULE_DESCRIPTION(\"Marvell 88PM860x Charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}