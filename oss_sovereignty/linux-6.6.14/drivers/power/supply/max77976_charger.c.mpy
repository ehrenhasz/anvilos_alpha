{
  "module_name": "max77976_charger.c",
  "hash_id": "c78761626093ef59cc8779233d12d2f6e9d86a681acb7272cfedbce6bc4dd7bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max77976_charger.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n\n#define MAX77976_DRIVER_NAME\t\"max77976-charger\"\n#define MAX77976_CHIP_ID\t0x76\n\nstatic const char *max77976_manufacturer\t= \"Maxim Integrated\";\nstatic const char *max77976_model\t\t= \"MAX77976\";\n\n \n\n#define MAX77976_REG_CHIP_ID\t\t0x00\n#define MAX77976_REG_CHIP_REVISION\t0x01\n#define MAX77976_REG_CHG_INT_OK\t\t0x12\n#define MAX77976_REG_CHG_DETAILS_01\t0x14\n#define MAX77976_REG_CHG_CNFG_00\t0x16\n#define MAX77976_REG_CHG_CNFG_02\t0x18\n#define MAX77976_REG_CHG_CNFG_06\t0x1c\n#define MAX77976_REG_CHG_CNFG_09\t0x1f\n\n \nenum max77976_charging_state {\n\tMAX77976_CHARGING_PREQUALIFICATION = 0x0,\n\tMAX77976_CHARGING_FAST_CONST_CURRENT,\n\tMAX77976_CHARGING_FAST_CONST_VOLTAGE,\n\tMAX77976_CHARGING_TOP_OFF,\n\tMAX77976_CHARGING_DONE,\n\tMAX77976_CHARGING_RESERVED_05,\n\tMAX77976_CHARGING_TIMER_FAULT,\n\tMAX77976_CHARGING_SUSPENDED_QBATT_OFF,\n\tMAX77976_CHARGING_OFF,\n\tMAX77976_CHARGING_RESERVED_09,\n\tMAX77976_CHARGING_THERMAL_SHUTDOWN,\n\tMAX77976_CHARGING_WATCHDOG_EXPIRED,\n\tMAX77976_CHARGING_SUSPENDED_JEITA,\n\tMAX77976_CHARGING_SUSPENDED_THM_REMOVAL,\n\tMAX77976_CHARGING_SUSPENDED_PIN,\n\tMAX77976_CHARGING_RESERVED_0F,\n};\n\n \nenum max77976_battery_state {\n\tMAX77976_BATTERY_BATTERY_REMOVAL = 0x0,\n\tMAX77976_BATTERY_PREQUALIFICATION,\n\tMAX77976_BATTERY_TIMER_FAULT,\n\tMAX77976_BATTERY_REGULAR_VOLTAGE,\n\tMAX77976_BATTERY_LOW_VOLTAGE,\n\tMAX77976_BATTERY_OVERVOLTAGE,\n\tMAX77976_BATTERY_RESERVED,\n\tMAX77976_BATTERY_BATTERY_ONLY, \n};\n\n \nenum max77976_mode {\n\tMAX77976_MODE_CHARGER_BUCK\t\t= 0x5,\n\tMAX77976_MODE_BOOST\t\t\t= 0x9,\n};\n\n \n#define MAX77976_CHG_CC_STEP\t\t\t  50000U\n#define MAX77976_CHG_CC_MIN\t\t\t 100000U\n#define MAX77976_CHG_CC_MAX\t\t\t5500000U\n\n \n#define MAX77976_CHGIN_ILIM_STEP\t\t 100000U\n#define MAX77976_CHGIN_ILIM_MIN\t\t\t 100000U\n#define MAX77976_CHGIN_ILIM_MAX\t\t\t3200000U\n\nenum max77976_field_idx {\n\tVERSION, REVISION,                       \n\tCHGIN_OK,                                \n\tBAT_DTLS, CHG_DTLS,                      \n\tMODE,                                    \n\tCHG_CC,                                  \n\tCHGPROT,                                 \n\tCHGIN_ILIM,                              \n\tMAX77976_N_REGMAP_FIELDS\n};\n\nstatic const struct reg_field max77976_reg_field[MAX77976_N_REGMAP_FIELDS] = {\n\t[VERSION]        = REG_FIELD(MAX77976_REG_CHIP_REVISION,   4, 7),\n\t[REVISION]       = REG_FIELD(MAX77976_REG_CHIP_REVISION,   0, 3),\n\t[CHGIN_OK]       = REG_FIELD(MAX77976_REG_CHG_INT_OK,      6, 6),\n\t[CHG_DTLS]       = REG_FIELD(MAX77976_REG_CHG_DETAILS_01,  0, 3),\n\t[BAT_DTLS]       = REG_FIELD(MAX77976_REG_CHG_DETAILS_01,  4, 6),\n\t[MODE]           = REG_FIELD(MAX77976_REG_CHG_CNFG_00,     0, 3),\n\t[CHG_CC]         = REG_FIELD(MAX77976_REG_CHG_CNFG_02,     0, 6),\n\t[CHGPROT]        = REG_FIELD(MAX77976_REG_CHG_CNFG_06,     2, 3),\n\t[CHGIN_ILIM]     = REG_FIELD(MAX77976_REG_CHG_CNFG_09,     0, 5),\n};\n\nstatic const struct regmap_config max77976_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x24,\n};\n\n \n\nstruct max77976 {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tstruct regmap_field\t*rfield[MAX77976_N_REGMAP_FIELDS];\n};\n\n \n\nstatic int max77976_get_status(struct max77976 *chg, int *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_field_read(chg->rfield[CHG_DTLS], &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (regval) {\n\tcase MAX77976_CHARGING_PREQUALIFICATION:\n\tcase MAX77976_CHARGING_FAST_CONST_CURRENT:\n\tcase MAX77976_CHARGING_FAST_CONST_VOLTAGE:\n\tcase MAX77976_CHARGING_TOP_OFF:\n\t\t*val = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase MAX77976_CHARGING_DONE:\n\t\t*val = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase MAX77976_CHARGING_TIMER_FAULT:\n\tcase MAX77976_CHARGING_SUSPENDED_QBATT_OFF:\n\tcase MAX77976_CHARGING_SUSPENDED_JEITA:\n\tcase MAX77976_CHARGING_SUSPENDED_THM_REMOVAL:\n\tcase MAX77976_CHARGING_SUSPENDED_PIN:\n\t\t*val = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase MAX77976_CHARGING_OFF:\n\tcase MAX77976_CHARGING_THERMAL_SHUTDOWN:\n\tcase MAX77976_CHARGING_WATCHDOG_EXPIRED:\n\t\t*val = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tdefault:\n\t\t*val = POWER_SUPPLY_STATUS_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77976_get_charge_type(struct max77976 *chg, int *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_field_read(chg->rfield[CHG_DTLS], &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (regval) {\n\tcase MAX77976_CHARGING_PREQUALIFICATION:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase MAX77976_CHARGING_FAST_CONST_CURRENT:\n\tcase MAX77976_CHARGING_FAST_CONST_VOLTAGE:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\tbreak;\n\tcase MAX77976_CHARGING_TOP_OFF:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\tbreak;\n\tcase MAX77976_CHARGING_DONE:\n\tcase MAX77976_CHARGING_TIMER_FAULT:\n\tcase MAX77976_CHARGING_SUSPENDED_QBATT_OFF:\n\tcase MAX77976_CHARGING_OFF:\n\tcase MAX77976_CHARGING_THERMAL_SHUTDOWN:\n\tcase MAX77976_CHARGING_WATCHDOG_EXPIRED:\n\tcase MAX77976_CHARGING_SUSPENDED_JEITA:\n\tcase MAX77976_CHARGING_SUSPENDED_THM_REMOVAL:\n\tcase MAX77976_CHARGING_SUSPENDED_PIN:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tdefault:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77976_get_health(struct max77976 *chg, int *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_field_read(chg->rfield[BAT_DTLS], &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (regval) {\n\tcase MAX77976_BATTERY_BATTERY_REMOVAL:\n\t\t*val = POWER_SUPPLY_HEALTH_NO_BATTERY;\n\t\tbreak;\n\tcase MAX77976_BATTERY_LOW_VOLTAGE:\n\tcase MAX77976_BATTERY_REGULAR_VOLTAGE:\n\t\t*val = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\tcase MAX77976_BATTERY_TIMER_FAULT:\n\t\t*val = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\t\tbreak;\n\tcase MAX77976_BATTERY_OVERVOLTAGE:\n\t\t*val = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\tbreak;\n\tcase MAX77976_BATTERY_PREQUALIFICATION:\n\tcase MAX77976_BATTERY_BATTERY_ONLY:\n\t\t*val = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\tbreak;\n\tdefault:\n\t\t*val = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77976_get_online(struct max77976 *chg, int *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_field_read(chg->rfield[CHGIN_OK], &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = (regval ? 1 : 0);\n\n\treturn 0;\n}\n\nstatic int max77976_get_integer(struct max77976 *chg, enum max77976_field_idx fidx,\n\t\t\t\tunsigned int clamp_min, unsigned int clamp_max,\n\t\t\t\tunsigned int mult, int *val)\n{\n\tunsigned int regval;\n\tint err;\n\n\terr = regmap_field_read(chg->rfield[fidx], &regval);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = clamp_val(regval * mult, clamp_min, clamp_max);\n\n\treturn 0;\n}\n\nstatic int max77976_set_integer(struct max77976 *chg, enum max77976_field_idx fidx,\n\t\t\t\tunsigned int clamp_min, unsigned int clamp_max,\n\t\t\t\tunsigned int div, int val)\n{\n\tunsigned int regval;\n\n\tregval = clamp_val(val, clamp_min, clamp_max) / div;\n\n\treturn regmap_field_write(chg->rfield[fidx], regval);\n}\n\nstatic int max77976_get_property(struct power_supply *psy,\n\t\t\t\t enum power_supply_property psp,\n\t\t\t\t union power_supply_propval *val)\n{\n\tstruct max77976 *chg = power_supply_get_drvdata(psy);\n\tint err = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\terr = max77976_get_status(chg, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\terr = max77976_get_charge_type(chg, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\terr = max77976_get_health(chg, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\terr = max77976_get_online(chg, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\n\t\tval->intval = MAX77976_CHG_CC_MAX;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\terr = max77976_get_integer(chg, CHG_CC,\n\t\t\t\t\t   MAX77976_CHG_CC_MIN,\n\t\t\t\t\t   MAX77976_CHG_CC_MAX,\n\t\t\t\t\t   MAX77976_CHG_CC_STEP,\n\t\t\t\t\t   &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\terr = max77976_get_integer(chg, CHGIN_ILIM,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_MIN,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_MAX,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_STEP,\n\t\t\t\t\t   &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = max77976_model;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = max77976_manufacturer;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int max77976_set_property(struct power_supply *psy,\n\t\t\t\t enum power_supply_property psp,\n\t\t\t\t const union power_supply_propval *val)\n{\n\tstruct max77976 *chg = power_supply_get_drvdata(psy);\n\tint err = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\terr = max77976_set_integer(chg, CHG_CC,\n\t\t\t\t\t   MAX77976_CHG_CC_MIN,\n\t\t\t\t\t   MAX77976_CHG_CC_MAX,\n\t\t\t\t\t   MAX77976_CHG_CC_STEP,\n\t\t\t\t\t   val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\terr = max77976_set_integer(chg, CHGIN_ILIM,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_MIN,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_MAX,\n\t\t\t\t\t   MAX77976_CHGIN_ILIM_STEP,\n\t\t\t\t\t   val->intval);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n};\n\nstatic int max77976_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum power_supply_property max77976_psy_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic const struct power_supply_desc max77976_psy_desc = {\n\t.name\t\t\t= MAX77976_DRIVER_NAME,\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= max77976_psy_props,\n\t.num_properties\t\t= ARRAY_SIZE(max77976_psy_props),\n\t.get_property\t\t= max77976_get_property,\n\t.set_property\t\t= max77976_set_property,\n\t.property_is_writeable\t= max77976_property_is_writeable,\n};\n\n \n\nstatic int max77976_detect(struct max77976 *chg)\n{\n\tstruct device *dev = &chg->client->dev;\n\tunsigned int id, ver, rev;\n\tint err;\n\n\terr = regmap_read(chg->regmap, MAX77976_REG_CHIP_ID, &id);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"cannot read chip ID\\n\");\n\n\tif (id != MAX77976_CHIP_ID)\n\t\treturn dev_err_probe(dev, -ENXIO, \"unknown model ID 0x%02x\\n\", id);\n\n\terr = regmap_field_read(chg->rfield[VERSION], &ver);\n\tif (!err)\n\t\terr = regmap_field_read(chg->rfield[REVISION], &rev);\n\tif (err)\n\t\treturn dev_err_probe(dev, -ENXIO, \"cannot read version/revision\\n\");\n\n\tdev_info(dev, \"detected model MAX779%02x ver %u rev %u\", id, ver, rev);\n\n\treturn 0;\n}\n\nstatic int max77976_configure(struct max77976 *chg)\n{\n\tstruct device *dev = &chg->client->dev;\n\tint err;\n\n\t \n\terr = regmap_field_write(chg->rfield[CHGPROT], 0x3);\n\tif (err)\n\t\tgoto err;\n\n\t \n\terr = regmap_field_write(chg->rfield[MODE], MAX77976_MODE_CHARGER_BUCK);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn dev_err_probe(dev, err, \"error while configuring\");\n}\n\nstatic int max77976_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct power_supply *psy;\n\tstruct max77976 *chg;\n\tint err;\n\tint i;\n\n\tchg = devm_kzalloc(dev, sizeof(*chg), GFP_KERNEL);\n\tif (!chg)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chg);\n\tpsy_cfg.drv_data = chg;\n\tchg->client = client;\n\n\tchg->regmap = devm_regmap_init_i2c(client, &max77976_regmap_config);\n\tif (IS_ERR(chg->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(chg->regmap),\n\t\t\t\t     \"cannot allocate regmap\\n\");\n\n\tfor (i = 0; i < MAX77976_N_REGMAP_FIELDS; i++) {\n\t\tchg->rfield[i] = devm_regmap_field_alloc(dev, chg->regmap,\n\t\t\t\t\t\t\t max77976_reg_field[i]);\n\t\tif (IS_ERR(chg->rfield[i]))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(chg->rfield[i]),\n\t\t\t\t\t     \"cannot allocate regmap field\\n\");\n\t}\n\n\terr = max77976_detect(chg);\n\tif (err)\n\t\treturn err;\n\n\terr = max77976_configure(chg);\n\tif (err)\n\t\treturn err;\n\n\tpsy = devm_power_supply_register_no_ws(dev, &max77976_psy_desc, &psy_cfg);\n\tif (IS_ERR(psy))\n\t\treturn dev_err_probe(dev, PTR_ERR(psy), \"cannot register\\n\");\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max77976_i2c_id[] = {\n\t{ MAX77976_DRIVER_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, max77976_i2c_id);\n\nstatic const struct of_device_id max77976_of_id[] = {\n\t{ .compatible = \"maxim,max77976\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max77976_of_id);\n\nstatic struct i2c_driver max77976_driver = {\n\t.driver = {\n\t\t.name\t\t= MAX77976_DRIVER_NAME,\n\t\t.of_match_table\t= max77976_of_id,\n\t},\n\t.probe\t\t= max77976_probe,\n\t.id_table\t= max77976_i2c_id,\n};\nmodule_i2c_driver(max77976_driver);\n\nMODULE_AUTHOR(\"Luca Ceresoli <luca.ceresoli@bootlin.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX77976 charger driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}