{
  "module_name": "ltc2941-battery-gauge.c",
  "hash_id": "71e297cb1dbfb915e6e1ae6436630fd6aea0b7cba9ff6280ff58d9477a99c2b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ltc2941-battery-gauge.c",
  "human_readable_source": "\n \n#include <linux/devm-helpers.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/swab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n\n#define I16_MSB(x)\t\t\t((x >> 8) & 0xFF)\n#define I16_LSB(x)\t\t\t(x & 0xFF)\n\n#define LTC294X_WORK_DELAY\t\t10\t \n\n#define LTC294X_MAX_VALUE\t\t0xFFFF\n#define LTC294X_MID_SUPPLY\t\t0x7FFF\n\n#define LTC2941_MAX_PRESCALER_EXP\t7\n#define LTC2943_MAX_PRESCALER_EXP\t6\n\nenum ltc294x_reg {\n\tLTC294X_REG_STATUS\t\t= 0x00,\n\tLTC294X_REG_CONTROL\t\t= 0x01,\n\tLTC294X_REG_ACC_CHARGE_MSB\t= 0x02,\n\tLTC294X_REG_ACC_CHARGE_LSB\t= 0x03,\n\tLTC294X_REG_CHARGE_THR_HIGH_MSB\t= 0x04,\n\tLTC294X_REG_CHARGE_THR_HIGH_LSB\t= 0x05,\n\tLTC294X_REG_CHARGE_THR_LOW_MSB\t= 0x06,\n\tLTC294X_REG_CHARGE_THR_LOW_LSB\t= 0x07,\n\tLTC294X_REG_VOLTAGE_MSB\t\t= 0x08,\n\tLTC294X_REG_VOLTAGE_LSB\t\t= 0x09,\n\tLTC2942_REG_TEMPERATURE_MSB\t= 0x0C,\n\tLTC2942_REG_TEMPERATURE_LSB\t= 0x0D,\n\tLTC2943_REG_CURRENT_MSB\t\t= 0x0E,\n\tLTC2943_REG_CURRENT_LSB\t\t= 0x0F,\n\tLTC2943_REG_TEMPERATURE_MSB\t= 0x14,\n\tLTC2943_REG_TEMPERATURE_LSB\t= 0x15,\n};\n\nenum ltc294x_id {\n\tLTC2941_ID,\n\tLTC2942_ID,\n\tLTC2943_ID,\n\tLTC2944_ID,\n};\n\n#define LTC2941_REG_STATUS_CHIP_ID\tBIT(7)\n\n#define LTC2942_REG_CONTROL_MODE_SCAN\t(BIT(7) | BIT(6))\n#define LTC2943_REG_CONTROL_MODE_SCAN\tBIT(7)\n#define LTC294X_REG_CONTROL_PRESCALER_MASK\t(BIT(5) | BIT(4) | BIT(3))\n#define LTC294X_REG_CONTROL_SHUTDOWN_MASK\t(BIT(0))\n#define LTC294X_REG_CONTROL_PRESCALER_SET(x) \\\n\t((x << 3) & LTC294X_REG_CONTROL_PRESCALER_MASK)\n#define LTC294X_REG_CONTROL_ALCC_CONFIG_DISABLED\t0\n#define LTC294X_REG_CONTROL_ADC_DISABLE(x)\t((x) & ~(BIT(7) | BIT(6)))\n\nstruct ltc294x_info {\n\tstruct i2c_client *client;\t \n\tstruct power_supply *supply;\t \n\tstruct power_supply_desc supply_desc;\t \n\tstruct delayed_work work;\t \n\tenum ltc294x_id id;\t\t \n\tint charge;\t \n\tint r_sense;\t \n\tint Qlsb;\t \n};\n\nstatic inline int convert_bin_to_uAh(\n\tconst struct ltc294x_info *info, int Q)\n{\n\treturn ((Q * (info->Qlsb / 10))) / 100;\n}\n\nstatic inline int convert_uAh_to_bin(\n\tconst struct ltc294x_info *info, int uAh)\n{\n\tint Q;\n\n\tQ = (uAh * 100) / (info->Qlsb/10);\n\treturn (Q < LTC294X_MAX_VALUE) ? Q : LTC294X_MAX_VALUE;\n}\n\nstatic int ltc294x_read_regs(struct i2c_client *client,\n\tenum ltc294x_reg reg, u8 *buf, int num_regs)\n{\n\tint ret;\n\tstruct i2c_msg msgs[2] = { };\n\tu8 reg_start = reg;\n\n\tmsgs[0].addr\t= client->addr;\n\tmsgs[0].len\t= 1;\n\tmsgs[0].buf\t= &reg_start;\n\n\tmsgs[1].addr\t= client->addr;\n\tmsgs[1].len\t= num_regs;\n\tmsgs[1].buf\t= buf;\n\tmsgs[1].flags\t= I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, &msgs[0], 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"ltc2941 read_reg(0x%x[%d]) failed: %pe\\n\",\n\t\t\treg, num_regs, ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&client->dev, \"%s (%#x, %d) -> %#x\\n\",\n\t\t__func__, reg, num_regs, *buf);\n\n\treturn 0;\n}\n\nstatic int ltc294x_write_regs(struct i2c_client *client,\n\tenum ltc294x_reg reg, const u8 *buf, int num_regs)\n{\n\tint ret;\n\tu8 reg_start = reg;\n\n\tret = i2c_smbus_write_i2c_block_data(client, reg_start, num_regs, buf);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"ltc2941 write_reg(0x%x[%d]) failed: %pe\\n\",\n\t\t\treg, num_regs, ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&client->dev, \"%s (%#x, %d) -> %#x\\n\",\n\t\t__func__, reg, num_regs, *buf);\n\n\treturn 0;\n}\n\nstatic int ltc294x_reset(const struct ltc294x_info *info, int prescaler_exp)\n{\n\tint ret;\n\tu8 value;\n\tu8 control;\n\n\t \n\tret = ltc294x_read_regs(info->client, LTC294X_REG_CONTROL, &value, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcontrol = LTC294X_REG_CONTROL_PRESCALER_SET(prescaler_exp) |\n\t\t\t\tLTC294X_REG_CONTROL_ALCC_CONFIG_DISABLED;\n\t \n\tswitch (info->id) {\n\tcase LTC2942_ID:\t \n\t\tcontrol |= LTC2942_REG_CONTROL_MODE_SCAN;\n\t\tbreak;\n\tcase LTC2943_ID:\n\tcase LTC2944_ID:\t \n\t\tcontrol |= LTC2943_REG_CONTROL_MODE_SCAN;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (value != control) {\n\t\tret = ltc294x_write_regs(info->client,\n\t\t\tLTC294X_REG_CONTROL, &control, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc294x_read_charge_register(const struct ltc294x_info *info,\n\t\t\t\t\tenum ltc294x_reg reg)\n {\n\tint ret;\n\tu8 datar[2];\n\n\tret = ltc294x_read_regs(info->client, reg, &datar[0], 2);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (datar[0] << 8) + datar[1];\n}\n\nstatic int ltc294x_get_charge(const struct ltc294x_info *info,\n\t\t\t\tenum ltc294x_reg reg, int *val)\n{\n\tint value = ltc294x_read_charge_register(info, reg);\n\n\tif (value < 0)\n\t\treturn value;\n\t \n\tif (info->Qlsb < 0)\n\t\tvalue -= 0xFFFF;\n\t*val = convert_bin_to_uAh(info, value);\n\treturn 0;\n}\n\nstatic int ltc294x_set_charge_now(const struct ltc294x_info *info, int val)\n{\n\tint ret;\n\tu8 dataw[2];\n\tu8 ctrl_reg;\n\ts32 value;\n\n\tvalue = convert_uAh_to_bin(info, val);\n\t \n\tif (info->Qlsb < 0)\n\t\tvalue += 0xFFFF;\n\tif ((value < 0) || (value > 0xFFFF))  \n\t\treturn -EINVAL;\n\n\t \n\tret = ltc294x_read_regs(info->client,\n\t\tLTC294X_REG_CONTROL, &ctrl_reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tctrl_reg |= LTC294X_REG_CONTROL_SHUTDOWN_MASK;\n\tret = ltc294x_write_regs(info->client,\n\t\tLTC294X_REG_CONTROL, &ctrl_reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tdataw[0] = I16_MSB(value);\n\tdataw[1] = I16_LSB(value);\n\tret = ltc294x_write_regs(info->client,\n\t\tLTC294X_REG_ACC_CHARGE_MSB, &dataw[0], 2);\n\tif (ret < 0)\n\t\tgoto error_exit;\n\t \nerror_exit:\n\tctrl_reg &= ~LTC294X_REG_CONTROL_SHUTDOWN_MASK;\n\tret = ltc294x_write_regs(info->client,\n\t\tLTC294X_REG_CONTROL, &ctrl_reg, 1);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int ltc294x_set_charge_thr(const struct ltc294x_info *info,\n\t\t\t\t\tenum ltc294x_reg reg, int val)\n{\n\tu8 dataw[2];\n\ts32 value;\n\n\tvalue = convert_uAh_to_bin(info, val);\n\t \n\tif (info->Qlsb < 0)\n\t\tvalue += 0xFFFF;\n\tif ((value < 0) || (value > 0xFFFF))  \n\t\treturn -EINVAL;\n\n\t \n\tdataw[0] = I16_MSB(value);\n\tdataw[1] = I16_LSB(value);\n\treturn ltc294x_write_regs(info->client, reg, &dataw[0], 2);\n}\n\nstatic int ltc294x_get_charge_counter(\n\tconst struct ltc294x_info *info, int *val)\n{\n\tint value = ltc294x_read_charge_register(info, LTC294X_REG_ACC_CHARGE_MSB);\n\n\tif (value < 0)\n\t\treturn value;\n\tvalue -= LTC294X_MID_SUPPLY;\n\t*val = convert_bin_to_uAh(info, value);\n\treturn 0;\n}\n\nstatic int ltc294x_get_voltage(const struct ltc294x_info *info, int *val)\n{\n\tint ret;\n\tu8 datar[2];\n\tu32 value;\n\n\tret = ltc294x_read_regs(info->client,\n\t\tLTC294X_REG_VOLTAGE_MSB, &datar[0], 2);\n\tvalue = (datar[0] << 8) | datar[1];\n\tswitch (info->id) {\n\tcase LTC2943_ID:\n\t\tvalue *= 23600 * 2;\n\t\tvalue /= 0xFFFF;\n\t\tvalue *= 1000 / 2;\n\t\tbreak;\n\tcase LTC2944_ID:\n\t\tvalue *= 70800 / 5*4;\n\t\tvalue /= 0xFFFF;\n\t\tvalue *= 1000 * 5/4;\n\t\tbreak;\n\tdefault:\n\t\tvalue *= 6000 * 10;\n\t\tvalue /= 0xFFFF;\n\t\tvalue *= 1000 / 10;\n\t\tbreak;\n\t}\n\t*val = value;\n\treturn ret;\n}\n\nstatic int ltc294x_get_current(const struct ltc294x_info *info, int *val)\n{\n\tint ret;\n\tu8 datar[2];\n\ts32 value;\n\n\tret = ltc294x_read_regs(info->client,\n\t\tLTC2943_REG_CURRENT_MSB, &datar[0], 2);\n\tvalue = (datar[0] << 8) | datar[1];\n\tvalue -= 0x7FFF;\n\tif (info->id == LTC2944_ID)\n\t\tvalue *= 64000;\n\telse\n\t\tvalue *= 60000;\n\t \n\t*val = 1000 * (value / (info->r_sense * 0x7FFF));  \n\treturn ret;\n}\n\nstatic int ltc294x_get_temperature(const struct ltc294x_info *info, int *val)\n{\n\tenum ltc294x_reg reg;\n\tint ret;\n\tu8 datar[2];\n\tu32 value;\n\n\tif (info->id == LTC2942_ID) {\n\t\treg = LTC2942_REG_TEMPERATURE_MSB;\n\t\tvalue = 6000;\t \n\t} else {\n\t\treg = LTC2943_REG_TEMPERATURE_MSB;\n\t\tvalue = 5100;\t \n\t}\n\tret = ltc294x_read_regs(info->client, reg, &datar[0], 2);\n\tvalue *= (datar[0] << 8) | datar[1];\n\t \n\t*val = value / 0xFFFF - 2722;\n\treturn ret;\n}\n\nstatic int ltc294x_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property prop,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct ltc294x_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\treturn ltc294x_get_charge(info, LTC294X_REG_CHARGE_THR_HIGH_MSB,\n\t\t\t\t\t\t&val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\treturn ltc294x_get_charge(info, LTC294X_REG_CHARGE_THR_LOW_MSB,\n\t\t\t\t\t\t&val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\treturn ltc294x_get_charge(info, LTC294X_REG_ACC_CHARGE_MSB,\n\t\t\t\t\t\t&val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\treturn ltc294x_get_charge_counter(info, &val->intval);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\treturn ltc294x_get_voltage(info, &val->intval);\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn ltc294x_get_current(info, &val->intval);\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\treturn ltc294x_get_temperature(info, &val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ltc294x_set_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tconst union power_supply_propval *val)\n{\n\tstruct ltc294x_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\treturn ltc294x_set_charge_thr(info,\n\t\t\tLTC294X_REG_CHARGE_THR_HIGH_MSB, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\treturn ltc294x_set_charge_thr(info,\n\t\t\tLTC294X_REG_CHARGE_THR_LOW_MSB, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\treturn ltc294x_set_charge_now(info, val->intval);\n\tdefault:\n\t\treturn -EPERM;\n\t}\n}\n\nstatic int ltc294x_property_is_writeable(\n\tstruct power_supply *psy, enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ltc294x_update(struct ltc294x_info *info)\n{\n\tint charge = ltc294x_read_charge_register(info, LTC294X_REG_ACC_CHARGE_MSB);\n\n\tif (charge != info->charge) {\n\t\tinfo->charge = charge;\n\t\tpower_supply_changed(info->supply);\n\t}\n}\n\nstatic void ltc294x_work(struct work_struct *work)\n{\n\tstruct ltc294x_info *info;\n\n\tinfo = container_of(work, struct ltc294x_info, work.work);\n\tltc294x_update(info);\n\tschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\n}\n\nstatic enum power_supply_property ltc294x_properties[] = {\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_EMPTY,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic int ltc294x_i2c_probe(struct i2c_client *client)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ltc294x_info *info;\n\tstruct device_node *np;\n\tint ret;\n\tu32 prescaler_exp;\n\ts32 r_sense;\n\tu8 status;\n\n\tinfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, info);\n\n\tnp = of_node_get(client->dev.of_node);\n\n\tinfo->id = (enum ltc294x_id) (uintptr_t) of_device_get_match_data(\n\t\t\t\t\t\t\t&client->dev);\n\tinfo->supply_desc.name = np->name;\n\n\t \n\tret = of_property_read_u32(np, \"lltc,resistor-sense\", &r_sense);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\"Could not find lltc,resistor-sense in devicetree\\n\");\n\tinfo->r_sense = r_sense;\n\n\tret = of_property_read_u32(np, \"lltc,prescaler-exponent\",\n\t\t&prescaler_exp);\n\tif (ret < 0) {\n\t\tdev_warn(&client->dev,\n\t\t\t\"lltc,prescaler-exponent not in devicetree\\n\");\n\t\tprescaler_exp = LTC2941_MAX_PRESCALER_EXP;\n\t}\n\n\tif (info->id == LTC2943_ID) {\n\t\tif (prescaler_exp > LTC2943_MAX_PRESCALER_EXP)\n\t\t\tprescaler_exp = LTC2943_MAX_PRESCALER_EXP;\n\t\tinfo->Qlsb = ((340 * 50000) / r_sense) >>\n\t\t\t     (12 - 2*prescaler_exp);\n\t} else {\n\t\tif (prescaler_exp > LTC2941_MAX_PRESCALER_EXP)\n\t\t\tprescaler_exp = LTC2941_MAX_PRESCALER_EXP;\n\t\tinfo->Qlsb = ((85 * 50000) / r_sense) >>\n\t\t\t     (7 - prescaler_exp);\n\t}\n\n\t \n\tif (info->id == LTC2941_ID || info->id == LTC2942_ID) {\n\t\tret = ltc294x_read_regs(client, LTC294X_REG_STATUS, &status, 1);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t\"Could not read status register\\n\");\n\t\tif (status & LTC2941_REG_STATUS_CHIP_ID)\n\t\t\tinfo->id = LTC2941_ID;\n\t\telse\n\t\t\tinfo->id = LTC2942_ID;\n\t}\n\n\tinfo->client = client;\n\tinfo->supply_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tinfo->supply_desc.properties = ltc294x_properties;\n\tswitch (info->id) {\n\tcase LTC2944_ID:\n\tcase LTC2943_ID:\n\t\tinfo->supply_desc.num_properties =\n\t\t\tARRAY_SIZE(ltc294x_properties);\n\t\tbreak;\n\tcase LTC2942_ID:\n\t\tinfo->supply_desc.num_properties =\n\t\t\tARRAY_SIZE(ltc294x_properties) - 1;\n\t\tbreak;\n\tcase LTC2941_ID:\n\tdefault:\n\t\tinfo->supply_desc.num_properties =\n\t\t\tARRAY_SIZE(ltc294x_properties) - 3;\n\t\tbreak;\n\t}\n\tinfo->supply_desc.get_property = ltc294x_get_property;\n\tinfo->supply_desc.set_property = ltc294x_set_property;\n\tinfo->supply_desc.property_is_writeable = ltc294x_property_is_writeable;\n\tinfo->supply_desc.external_power_changed\t= NULL;\n\n\tpsy_cfg.drv_data = info;\n\n\tret = devm_delayed_work_autocancel(&client->dev, &info->work,\n\t\t\t\t\t   ltc294x_work);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ltc294x_reset(info, prescaler_exp);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\"Communication with chip failed\\n\");\n\n\tinfo->supply = devm_power_supply_register(&client->dev,\n\t\t\t\t\t\t  &info->supply_desc, &psy_cfg);\n\tif (IS_ERR(info->supply))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(info->supply),\n\t\t\t\"failed to register ltc2941\\n\");\n\n\tschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\n\n\treturn 0;\n}\n\nstatic void ltc294x_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct ltc294x_info *info = i2c_get_clientdata(client);\n\tint ret;\n\tu8 value;\n\tu8 control;\n\n\t \n\tif (info->id == LTC2941_ID)\n\t\treturn;\n\n\t \n\tret = ltc294x_read_regs(info->client, LTC294X_REG_CONTROL, &value, 1);\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tcontrol = LTC294X_REG_CONTROL_ADC_DISABLE(value);\n\tif (control != value)\n\t\tltc294x_write_regs(info->client, LTC294X_REG_CONTROL,\n\t\t\t&control, 1);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int ltc294x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ltc294x_info *info = i2c_get_clientdata(client);\n\n\tcancel_delayed_work(&info->work);\n\treturn 0;\n}\n\nstatic int ltc294x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ltc294x_info *info = i2c_get_clientdata(client);\n\n\tschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ltc294x_pm_ops, ltc294x_suspend, ltc294x_resume);\n#define LTC294X_PM_OPS (&ltc294x_pm_ops)\n\n#else\n#define LTC294X_PM_OPS NULL\n#endif  \n\n\nstatic const struct i2c_device_id ltc294x_i2c_id[] = {\n\t{ \"ltc2941\", LTC2941_ID, },\n\t{ \"ltc2942\", LTC2942_ID, },\n\t{ \"ltc2943\", LTC2943_ID, },\n\t{ \"ltc2944\", LTC2944_ID, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, ltc294x_i2c_id);\n\nstatic const struct of_device_id ltc294x_i2c_of_match[] = {\n\t{\n\t\t.compatible = \"lltc,ltc2941\",\n\t\t.data = (void *)LTC2941_ID,\n\t},\n\t{\n\t\t.compatible = \"lltc,ltc2942\",\n\t\t.data = (void *)LTC2942_ID,\n\t},\n\t{\n\t\t.compatible = \"lltc,ltc2943\",\n\t\t.data = (void *)LTC2943_ID,\n\t},\n\t{\n\t\t.compatible = \"lltc,ltc2944\",\n\t\t.data = (void *)LTC2944_ID,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ltc294x_i2c_of_match);\n\nstatic struct i2c_driver ltc294x_driver = {\n\t.driver = {\n\t\t.name\t= \"LTC2941\",\n\t\t.of_match_table = ltc294x_i2c_of_match,\n\t\t.pm\t= LTC294X_PM_OPS,\n\t},\n\t.probe\t\t= ltc294x_i2c_probe,\n\t.shutdown\t= ltc294x_i2c_shutdown,\n\t.id_table\t= ltc294x_i2c_id,\n};\nmodule_i2c_driver(ltc294x_driver);\n\nMODULE_AUTHOR(\"Auryn Verwegen, Topic Embedded Systems\");\nMODULE_AUTHOR(\"Mike Looijmans, Topic Embedded Products\");\nMODULE_DESCRIPTION(\"LTC2941/LTC2942/LTC2943/LTC2944 Battery Gas Gauge IC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}