{
  "module_name": "cpcap-charger.c",
  "hash_id": "2418fbfd57d1454b09354e7355c911f856d3f5721d238a6a2d696fa698b07325",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/cpcap-charger.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/usb/phy_companion.h>\n#include <linux/phy/omap_usb.h>\n#include <linux/usb/otg.h>\n#include <linux/iio/consumer.h>\n#include <linux/mfd/motorola-cpcap.h>\n\n \n#define CPCAP_REG_CRM_UNUSED_641_15\tBIT(15)\t \n#define CPCAP_REG_CRM_UNUSED_641_14\tBIT(14)\t \n#define CPCAP_REG_CRM_CHRG_LED_EN\tBIT(13)\t \n#define CPCAP_REG_CRM_RVRSMODE\t\tBIT(12)\t \n#define CPCAP_REG_CRM_ICHRG_TR1\t\tBIT(11)\t \n#define CPCAP_REG_CRM_ICHRG_TR0\t\tBIT(10)\n#define CPCAP_REG_CRM_FET_OVRD\t\tBIT(9)\t \n#define CPCAP_REG_CRM_FET_CTRL\t\tBIT(8)\t \n#define CPCAP_REG_CRM_VCHRG3\t\tBIT(7)\t \n#define CPCAP_REG_CRM_VCHRG2\t\tBIT(6)\n#define CPCAP_REG_CRM_VCHRG1\t\tBIT(5)\n#define CPCAP_REG_CRM_VCHRG0\t\tBIT(4)\n#define CPCAP_REG_CRM_ICHRG3\t\tBIT(3)\t \n#define CPCAP_REG_CRM_ICHRG2\t\tBIT(2)\n#define CPCAP_REG_CRM_ICHRG1\t\tBIT(1)\n#define CPCAP_REG_CRM_ICHRG0\t\tBIT(0)\n\n \n#define CPCAP_REG_CRM_TR(val)\t\t(((val) & 0x3) << 10)\n#define CPCAP_REG_CRM_TR_0A00\t\tCPCAP_REG_CRM_TR(0x0)\n#define CPCAP_REG_CRM_TR_0A24\t\tCPCAP_REG_CRM_TR(0x1)\n#define CPCAP_REG_CRM_TR_0A48\t\tCPCAP_REG_CRM_TR(0x2)\n#define CPCAP_REG_CRM_TR_0A72\t\tCPCAP_REG_CRM_TR(0x4)\n\n \n#define CPCAP_REG_CRM_VCHRG(val)\t(((val) & 0xf) << 4)\n#define CPCAP_REG_CRM_VCHRG_3V80\tCPCAP_REG_CRM_VCHRG(0x0)\n#define CPCAP_REG_CRM_VCHRG_4V10\tCPCAP_REG_CRM_VCHRG(0x1)\n#define CPCAP_REG_CRM_VCHRG_4V12\tCPCAP_REG_CRM_VCHRG(0x2)\n#define CPCAP_REG_CRM_VCHRG_4V15\tCPCAP_REG_CRM_VCHRG(0x3)\n#define CPCAP_REG_CRM_VCHRG_4V17\tCPCAP_REG_CRM_VCHRG(0x4)\n#define CPCAP_REG_CRM_VCHRG_4V20\tCPCAP_REG_CRM_VCHRG(0x5)\n#define CPCAP_REG_CRM_VCHRG_4V23\tCPCAP_REG_CRM_VCHRG(0x6)\n#define CPCAP_REG_CRM_VCHRG_4V25\tCPCAP_REG_CRM_VCHRG(0x7)\n#define CPCAP_REG_CRM_VCHRG_4V27\tCPCAP_REG_CRM_VCHRG(0x8)\n#define CPCAP_REG_CRM_VCHRG_4V30\tCPCAP_REG_CRM_VCHRG(0x9)\n#define CPCAP_REG_CRM_VCHRG_4V33\tCPCAP_REG_CRM_VCHRG(0xa)\n#define CPCAP_REG_CRM_VCHRG_4V35\tCPCAP_REG_CRM_VCHRG(0xb)\n#define CPCAP_REG_CRM_VCHRG_4V38\tCPCAP_REG_CRM_VCHRG(0xc)\n#define CPCAP_REG_CRM_VCHRG_4V40\tCPCAP_REG_CRM_VCHRG(0xd)\n#define CPCAP_REG_CRM_VCHRG_4V42\tCPCAP_REG_CRM_VCHRG(0xe)\n#define CPCAP_REG_CRM_VCHRG_4V44\tCPCAP_REG_CRM_VCHRG(0xf)\n\n \n#define CPCAP_REG_CRM_ICHRG(val)\t(((val) & 0xf) << 0)\n#define CPCAP_REG_CRM_ICHRG_0A000\tCPCAP_REG_CRM_ICHRG(0x0)\n#define CPCAP_REG_CRM_ICHRG_0A070\tCPCAP_REG_CRM_ICHRG(0x1)\n#define CPCAP_REG_CRM_ICHRG_0A177\tCPCAP_REG_CRM_ICHRG(0x2)\n#define CPCAP_REG_CRM_ICHRG_0A266\tCPCAP_REG_CRM_ICHRG(0x3)\n#define CPCAP_REG_CRM_ICHRG_0A355\tCPCAP_REG_CRM_ICHRG(0x4)\n#define CPCAP_REG_CRM_ICHRG_0A443\tCPCAP_REG_CRM_ICHRG(0x5)\n#define CPCAP_REG_CRM_ICHRG_0A532\tCPCAP_REG_CRM_ICHRG(0x6)\n#define CPCAP_REG_CRM_ICHRG_0A621\tCPCAP_REG_CRM_ICHRG(0x7)\n#define CPCAP_REG_CRM_ICHRG_0A709\tCPCAP_REG_CRM_ICHRG(0x8)\n#define CPCAP_REG_CRM_ICHRG_0A798\tCPCAP_REG_CRM_ICHRG(0x9)\n#define CPCAP_REG_CRM_ICHRG_0A886\tCPCAP_REG_CRM_ICHRG(0xa)\n#define CPCAP_REG_CRM_ICHRG_0A975\tCPCAP_REG_CRM_ICHRG(0xb)\n#define CPCAP_REG_CRM_ICHRG_1A064\tCPCAP_REG_CRM_ICHRG(0xc)\n#define CPCAP_REG_CRM_ICHRG_1A152\tCPCAP_REG_CRM_ICHRG(0xd)\n#define CPCAP_REG_CRM_ICHRG_1A596\tCPCAP_REG_CRM_ICHRG(0xe)\n#define CPCAP_REG_CRM_ICHRG_NO_LIMIT\tCPCAP_REG_CRM_ICHRG(0xf)\n\n \n#define CPCAP_BIT_VBUS_SWITCH\t\tBIT(0)\t \n\nenum {\n\tCPCAP_CHARGER_IIO_BATTDET,\n\tCPCAP_CHARGER_IIO_VOLTAGE,\n\tCPCAP_CHARGER_IIO_VBUS,\n\tCPCAP_CHARGER_IIO_CHRG_CURRENT,\n\tCPCAP_CHARGER_IIO_BATT_CURRENT,\n\tCPCAP_CHARGER_IIO_NR,\n};\n\nstruct cpcap_charger_ddata {\n\tstruct device *dev;\n\tstruct regmap *reg;\n\tstruct list_head irq_list;\n\tstruct delayed_work detect_work;\n\tstruct delayed_work vbus_work;\n\tstruct gpio_desc *gpio[2];\t\t \n\n\tstruct iio_channel *channels[CPCAP_CHARGER_IIO_NR];\n\n\tstruct power_supply *usb;\n\n\tstruct phy_companion comparator;\t \n\tunsigned int vbus_enabled:1;\n\tunsigned int feeding_vbus:1;\n\tatomic_t active;\n\n\tint status;\n\tint voltage;\n\tint limit_current;\n};\n\nstruct cpcap_interrupt_desc {\n\tint irq;\n\tstruct list_head node;\n\tconst char *name;\n};\n\nstruct cpcap_charger_ints_state {\n\tbool chrg_det;\n\tbool rvrs_chrg;\n\tbool vbusov;\n\n\tbool chrg_se1b;\n\tbool rvrs_mode;\n\tbool chrgcurr2;\n\tbool chrgcurr1;\n\tbool vbusvld;\n\n\tbool battdetb;\n};\n\nstatic enum power_supply_property cpcap_charger_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic int cpcap_charger_get_charge_voltage(struct cpcap_charger_ddata *ddata)\n{\n\tstruct iio_channel *channel;\n\tint error, value = 0;\n\n\tchannel = ddata->channels[CPCAP_CHARGER_IIO_VOLTAGE];\n\terror = iio_read_channel_processed(channel, &value);\n\tif (error < 0) {\n\t\tdev_warn(ddata->dev, \"%s failed: %i\\n\", __func__, error);\n\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int cpcap_charger_get_charge_current(struct cpcap_charger_ddata *ddata)\n{\n\tstruct iio_channel *channel;\n\tint error, value = 0;\n\n\tchannel = ddata->channels[CPCAP_CHARGER_IIO_CHRG_CURRENT];\n\terror = iio_read_channel_processed(channel, &value);\n\tif (error < 0) {\n\t\tdev_warn(ddata->dev, \"%s failed: %i\\n\", __func__, error);\n\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int cpcap_charger_get_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct cpcap_charger_ddata *ddata = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = ddata->status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tval->intval = ddata->limit_current;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tval->intval = ddata->voltage;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tif (ddata->status == POWER_SUPPLY_STATUS_CHARGING)\n\t\t\tval->intval = cpcap_charger_get_charge_voltage(ddata) *\n\t\t\t\t1000;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (ddata->status == POWER_SUPPLY_STATUS_CHARGING)\n\t\t\tval->intval = cpcap_charger_get_charge_current(ddata) *\n\t\t\t\t1000;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = ddata->status == POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_charger_match_voltage(int voltage)\n{\n\tswitch (voltage) {\n\tcase 0 ... 4100000 - 1: return 3800000;\n\tcase 4100000 ... 4120000 - 1: return 4100000;\n\tcase 4120000 ... 4150000 - 1: return 4120000;\n\tcase 4150000 ... 4170000 - 1: return 4150000;\n\tcase 4170000 ... 4200000 - 1: return 4170000;\n\tcase 4200000 ... 4230000 - 1: return 4200000;\n\tcase 4230000 ... 4250000 - 1: return 4230000;\n\tcase 4250000 ... 4270000 - 1: return 4250000;\n\tcase 4270000 ... 4300000 - 1: return 4270000;\n\tcase 4300000 ... 4330000 - 1: return 4300000;\n\tcase 4330000 ... 4350000 - 1: return 4330000;\n\tcase 4350000 ... 4380000 - 1: return 4350000;\n\tcase 4380000 ... 4400000 - 1: return 4380000;\n\tcase 4400000 ... 4420000 - 1: return 4400000;\n\tcase 4420000 ... 4440000 - 1: return 4420000;\n\tcase 4440000: return 4440000;\n\tdefault: return 0;\n\t}\n}\n\nstatic int\ncpcap_charger_get_bat_const_charge_voltage(struct cpcap_charger_ddata *ddata)\n{\n\tunion power_supply_propval prop;\n\tstruct power_supply *battery;\n\tint voltage = ddata->voltage;\n\tint error;\n\n\tbattery = power_supply_get_by_name(\"battery\");\n\tif (battery) {\n\t\terror = power_supply_get_property(battery,\n\t\t\t\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\t\t\t\t&prop);\n\t\tif (!error)\n\t\t\tvoltage = prop.intval;\n\n\t\tpower_supply_put(battery);\n\t}\n\n\treturn voltage;\n}\n\nstatic int cpcap_charger_current_to_regval(int microamp)\n{\n\tint miliamp = microamp / 1000;\n\tint res;\n\n\tif (miliamp < 0)\n\t\treturn -EINVAL;\n\tif (miliamp < 70)\n\t\treturn CPCAP_REG_CRM_ICHRG(0x0);\n\tif (miliamp < 177)\n\t\treturn CPCAP_REG_CRM_ICHRG(0x1);\n\tif (miliamp >= 1596)\n\t\treturn CPCAP_REG_CRM_ICHRG(0xe);\n\n\tres = microamp / 88666;\n\tif (res > 0xd)\n\t\tres = 0xd;\n\treturn CPCAP_REG_CRM_ICHRG(res);\n}\n\nstatic int cpcap_charger_set_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      const union power_supply_propval *val)\n{\n\tstruct cpcap_charger_ddata *ddata = dev_get_drvdata(psy->dev.parent);\n\tint voltage, batvolt;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (cpcap_charger_current_to_regval(val->intval) < 0)\n\t\t\treturn -EINVAL;\n\t\tddata->limit_current = val->intval;\n\t\tschedule_delayed_work(&ddata->detect_work, 0);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tvoltage = cpcap_charger_match_voltage(val->intval);\n\t\tbatvolt = cpcap_charger_get_bat_const_charge_voltage(ddata);\n\t\tif (voltage > batvolt)\n\t\t\tvoltage = batvolt;\n\t\tddata->voltage = voltage;\n\t\tschedule_delayed_work(&ddata->detect_work, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t       enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void cpcap_charger_set_cable_path(struct cpcap_charger_ddata *ddata,\n\t\t\t\t\t bool enabled)\n{\n\tif (!ddata->gpio[0])\n\t\treturn;\n\n\tgpiod_set_value(ddata->gpio[0], enabled);\n}\n\nstatic void cpcap_charger_set_inductive_path(struct cpcap_charger_ddata *ddata,\n\t\t\t\t\t     bool enabled)\n{\n\tif (!ddata->gpio[1])\n\t\treturn;\n\n\tgpiod_set_value(ddata->gpio[1], enabled);\n}\n\nstatic void cpcap_charger_update_state(struct cpcap_charger_ddata *ddata,\n\t\t\t\t       int state)\n{\n\tconst char *status;\n\n\tif (state > POWER_SUPPLY_STATUS_FULL) {\n\t\tdev_warn(ddata->dev, \"unknown state: %i\\n\", state);\n\n\t\treturn;\n\t}\n\n\tddata->status = state;\n\n\tswitch (state) {\n\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\tstatus = \"DISCONNECTED\";\n\t\tbreak;\n\tcase POWER_SUPPLY_STATUS_NOT_CHARGING:\n\t\tstatus = \"DETECTING\";\n\t\tbreak;\n\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\tstatus = \"CHARGING\";\n\t\tbreak;\n\tcase POWER_SUPPLY_STATUS_FULL:\n\t\tstatus = \"DONE\";\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tdev_dbg(ddata->dev, \"state: %s\\n\", status);\n}\n\nstatic int cpcap_charger_disable(struct cpcap_charger_ddata *ddata)\n{\n\tint error;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM, 0x3fff,\n\t\t\t\t   CPCAP_REG_CRM_FET_OVRD |\n\t\t\t\t   CPCAP_REG_CRM_FET_CTRL);\n\tif (error)\n\t\tdev_err(ddata->dev, \"%s failed with %i\\n\", __func__, error);\n\n\treturn error;\n}\n\nstatic int cpcap_charger_enable(struct cpcap_charger_ddata *ddata,\n\t\t\t\tint max_voltage, int charge_current,\n\t\t\t\tint trickle_current)\n{\n\tint error;\n\n\tif (!max_voltage || !charge_current)\n\t\treturn -EINVAL;\n\n\tdev_dbg(ddata->dev, \"enable: %i %i %i\\n\",\n\t\tmax_voltage, charge_current, trickle_current);\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM, 0x3fff,\n\t\t\t\t   CPCAP_REG_CRM_CHRG_LED_EN |\n\t\t\t\t   trickle_current |\n\t\t\t\t   CPCAP_REG_CRM_FET_OVRD |\n\t\t\t\t   CPCAP_REG_CRM_FET_CTRL |\n\t\t\t\t   max_voltage |\n\t\t\t\t   charge_current);\n\tif (error)\n\t\tdev_err(ddata->dev, \"%s failed with %i\\n\", __func__, error);\n\n\treturn error;\n}\n\nstatic bool cpcap_charger_vbus_valid(struct cpcap_charger_ddata *ddata)\n{\n\tint error, value = 0;\n\tstruct iio_channel *channel =\n\t\tddata->channels[CPCAP_CHARGER_IIO_VBUS];\n\n\terror = iio_read_channel_processed(channel, &value);\n\tif (error >= 0)\n\t\treturn value > 3900;\n\n\tdev_err(ddata->dev, \"error reading VBUS: %i\\n\", error);\n\n\treturn false;\n}\n\n \nstatic void cpcap_charger_vbus_work(struct work_struct *work)\n{\n\tstruct cpcap_charger_ddata *ddata;\n\tbool vbus = false;\n\tint error;\n\n\tddata = container_of(work, struct cpcap_charger_ddata,\n\t\t\t     vbus_work.work);\n\n\tif (ddata->vbus_enabled) {\n\t\tvbus = cpcap_charger_vbus_valid(ddata);\n\t\tif (vbus) {\n\t\t\tdev_dbg(ddata->dev, \"VBUS already provided\\n\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tddata->feeding_vbus = true;\n\t\tcpcap_charger_set_cable_path(ddata, false);\n\t\tcpcap_charger_set_inductive_path(ddata, false);\n\n\t\terror = cpcap_charger_disable(ddata);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tcpcap_charger_update_state(ddata,\n\t\t\t\t\t   POWER_SUPPLY_STATUS_DISCHARGING);\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_VUSBC,\n\t\t\t\t\t   CPCAP_BIT_VBUS_SWITCH,\n\t\t\t\t\t   CPCAP_BIT_VBUS_SWITCH);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM,\n\t\t\t\t\t   CPCAP_REG_CRM_RVRSMODE,\n\t\t\t\t\t   CPCAP_REG_CRM_RVRSMODE);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t} else {\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_VUSBC,\n\t\t\t\t\t   CPCAP_BIT_VBUS_SWITCH, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM,\n\t\t\t\t\t   CPCAP_REG_CRM_RVRSMODE, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tcpcap_charger_set_cable_path(ddata, true);\n\t\tcpcap_charger_set_inductive_path(ddata, true);\n\t\tddata->feeding_vbus = false;\n\t}\n\n\treturn;\n\nout_err:\n\tcpcap_charger_update_state(ddata, POWER_SUPPLY_STATUS_UNKNOWN);\n\tdev_err(ddata->dev, \"%s could not %s vbus: %i\\n\", __func__,\n\t\tddata->vbus_enabled ? \"enable\" : \"disable\", error);\n}\n\nstatic int cpcap_charger_set_vbus(struct phy_companion *comparator,\n\t\t\t\t  bool enabled)\n{\n\tstruct cpcap_charger_ddata *ddata =\n\t\tcontainer_of(comparator, struct cpcap_charger_ddata,\n\t\t\t     comparator);\n\n\tddata->vbus_enabled = enabled;\n\tschedule_delayed_work(&ddata->vbus_work, 0);\n\n\treturn 0;\n}\n\n \n\nstatic int cpcap_charger_get_ints_state(struct cpcap_charger_ddata *ddata,\n\t\t\t\t\tstruct cpcap_charger_ints_state *s)\n{\n\tint val, error;\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS1, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->chrg_det = val & BIT(13);\n\ts->rvrs_chrg = val & BIT(12);\n\ts->vbusov = val & BIT(11);\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS2, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->chrg_se1b = val & BIT(13);\n\ts->rvrs_mode = val & BIT(6);\n\ts->chrgcurr2 = val & BIT(5);\n\ts->chrgcurr1 = val & BIT(4);\n\ts->vbusvld = val & BIT(3);\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS4, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->battdetb = val & BIT(6);\n\n\treturn 0;\n}\n\nstatic int cpcap_charger_voltage_to_regval(int voltage)\n{\n\tint offset;\n\n\tswitch (voltage) {\n\tcase 0 ... 4100000 - 1:\n\t\treturn 0;\n\tcase 4100000 ... 4200000 - 1:\n\t\toffset = 1;\n\t\tbreak;\n\tcase 4200000 ... 4300000 - 1:\n\t\toffset = 0;\n\t\tbreak;\n\tcase 4300000 ... 4380000 - 1:\n\t\toffset = -1;\n\t\tbreak;\n\tcase 4380000 ... 4440000:\n\t\toffset = -2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn ((voltage - 4100000) / 20000) + offset;\n}\n\nstatic void cpcap_charger_disconnect(struct cpcap_charger_ddata *ddata,\n\t\t\t\t     int state, unsigned long delay)\n{\n\tint error;\n\n\t \n\tswitch (state) {\n\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\tcase POWER_SUPPLY_STATUS_FULL:\n\t\tpower_supply_changed(ddata->usb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terror = cpcap_charger_disable(ddata);\n\tif (error) {\n\t\tcpcap_charger_update_state(ddata, POWER_SUPPLY_STATUS_UNKNOWN);\n\t\treturn;\n\t}\n\n\tcpcap_charger_update_state(ddata, state);\n\tpower_supply_changed(ddata->usb);\n\tschedule_delayed_work(&ddata->detect_work, delay);\n}\n\nstatic void cpcap_usb_detect(struct work_struct *work)\n{\n\tstruct cpcap_charger_ddata *ddata;\n\tstruct cpcap_charger_ints_state s;\n\tint error, new_state;\n\n\tddata = container_of(work, struct cpcap_charger_ddata,\n\t\t\t     detect_work.work);\n\n\terror = cpcap_charger_get_ints_state(ddata, &s);\n\tif (error)\n\t\treturn;\n\n\t \n\tif (!s.chrg_det && s.chrgcurr1 && s.vbusvld) {\n\t\tcpcap_charger_update_state(ddata,\n\t\t\t\t\t   POWER_SUPPLY_STATUS_NOT_CHARGING);\n\n\t\treturn;\n\t}\n\n\t \n\tif (cpcap_charger_get_charge_voltage(ddata) > ddata->voltage) {\n\t\tcpcap_charger_disconnect(ddata,\n\t\t\t\t\t POWER_SUPPLY_STATUS_NOT_CHARGING,\n\t\t\t\t\t HZ * 60 * 10);\n\n\t\treturn;\n\t}\n\n\t \n\tusleep_range(80000, 120000);\n\n\t \n\tswitch (ddata->status) {\n\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\tif (s.chrgcurr2)\n\t\t\tbreak;\n\t\tnew_state = POWER_SUPPLY_STATUS_FULL;\n\n\t\tif (s.chrgcurr1 && s.vbusvld) {\n\t\t\tcpcap_charger_disconnect(ddata, new_state, HZ * 5);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_STATUS_FULL:\n\t\tif (!s.chrgcurr2)\n\t\t\tbreak;\n\t\tif (s.vbusvld)\n\t\t\tnew_state = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse\n\t\t\tnew_state = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t\tcpcap_charger_disconnect(ddata, new_state, HZ * 5);\n\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ddata->feeding_vbus && cpcap_charger_vbus_valid(ddata) &&\n\t    s.chrgcurr1) {\n\t\tint max_current;\n\t\tint vchrg, ichrg;\n\t\tunion power_supply_propval val;\n\t\tstruct power_supply *battery;\n\n\t\tbattery = power_supply_get_by_name(\"battery\");\n\t\tif (IS_ERR_OR_NULL(battery)) {\n\t\t\tdev_err(ddata->dev, \"battery power_supply not available %li\\n\",\n\t\t\t\t\tPTR_ERR(battery));\n\t\t\treturn;\n\t\t}\n\n\t\terror = power_supply_get_property(battery, POWER_SUPPLY_PROP_PRESENT, &val);\n\t\tpower_supply_put(battery);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tif (val.intval) {\n\t\t\tmax_current = 1596000;\n\t\t} else {\n\t\t\tdev_info(ddata->dev, \"battery not inserted, charging disabled\\n\");\n\t\t\tmax_current = 0;\n\t\t}\n\n\t\tif (max_current > ddata->limit_current)\n\t\t\tmax_current = ddata->limit_current;\n\n\t\tichrg = cpcap_charger_current_to_regval(max_current);\n\t\tvchrg = cpcap_charger_voltage_to_regval(ddata->voltage);\n\t\terror = cpcap_charger_enable(ddata,\n\t\t\t\t\t     CPCAP_REG_CRM_VCHRG(vchrg),\n\t\t\t\t\t     ichrg, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tcpcap_charger_update_state(ddata,\n\t\t\t\t\t   POWER_SUPPLY_STATUS_CHARGING);\n\t} else {\n\t\terror = cpcap_charger_disable(ddata);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tcpcap_charger_update_state(ddata,\n\t\t\t\t\t   POWER_SUPPLY_STATUS_DISCHARGING);\n\t}\n\n\tpower_supply_changed(ddata->usb);\n\treturn;\n\nout_err:\n\tcpcap_charger_update_state(ddata, POWER_SUPPLY_STATUS_UNKNOWN);\n\tdev_err(ddata->dev, \"%s failed with %i\\n\", __func__, error);\n}\n\nstatic irqreturn_t cpcap_charger_irq_thread(int irq, void *data)\n{\n\tstruct cpcap_charger_ddata *ddata = data;\n\n\tif (!atomic_read(&ddata->active))\n\t\treturn IRQ_NONE;\n\n\tschedule_delayed_work(&ddata->detect_work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cpcap_usb_init_irq(struct platform_device *pdev,\n\t\t\t      struct cpcap_charger_ddata *ddata,\n\t\t\t      const char *name)\n{\n\tstruct cpcap_interrupt_desc *d;\n\tint irq, error;\n\n\tirq = platform_get_irq_byname(pdev, name);\n\tif (irq < 0)\n\t\treturn -ENODEV;\n\n\terror = devm_request_threaded_irq(ddata->dev, irq, NULL,\n\t\t\t\t\t  cpcap_charger_irq_thread,\n\t\t\t\t\t  IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t  name, ddata);\n\tif (error) {\n\t\tdev_err(ddata->dev, \"could not get irq %s: %i\\n\",\n\t\t\tname, error);\n\n\t\treturn error;\n\t}\n\n\td = devm_kzalloc(ddata->dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->name = name;\n\td->irq = irq;\n\tlist_add(&d->node, &ddata->irq_list);\n\n\treturn 0;\n}\n\nstatic const char * const cpcap_charger_irqs[] = {\n\t \n\t\"chrg_det\", \"rvrs_chrg\",\n\n\t \n\t\"chrg_se1b\", \"se0conn\", \"rvrs_mode\", \"chrgcurr2\", \"chrgcurr1\", \"vbusvld\",\n\n\t \n\t\"battdetb\",\n};\n\nstatic int cpcap_usb_init_interrupts(struct platform_device *pdev,\n\t\t\t\t     struct cpcap_charger_ddata *ddata)\n{\n\tint i, error;\n\n\tfor (i = 0; i < ARRAY_SIZE(cpcap_charger_irqs); i++) {\n\t\terror = cpcap_usb_init_irq(pdev, ddata, cpcap_charger_irqs[i]);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void cpcap_charger_init_optional_gpios(struct cpcap_charger_ddata *ddata)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tddata->gpio[i] = devm_gpiod_get_index(ddata->dev, \"mode\",\n\t\t\t\t\t\t      i, GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(ddata->gpio[i])) {\n\t\t\tdev_info(ddata->dev, \"no mode change GPIO%i: %li\\n\",\n\t\t\t\t i, PTR_ERR(ddata->gpio[i]));\n\t\t\tddata->gpio[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int cpcap_charger_init_iio(struct cpcap_charger_ddata *ddata)\n{\n\tconst char * const names[CPCAP_CHARGER_IIO_NR] = {\n\t\t\"battdetb\", \"battp\", \"vbus\", \"chg_isense\", \"batti\",\n\t};\n\tint error, i;\n\n\tfor (i = 0; i < CPCAP_CHARGER_IIO_NR; i++) {\n\t\tddata->channels[i] = devm_iio_channel_get(ddata->dev,\n\t\t\t\t\t\t\t  names[i]);\n\t\tif (IS_ERR(ddata->channels[i])) {\n\t\t\terror = PTR_ERR(ddata->channels[i]);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!ddata->channels[i]->indio_dev) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\tif (error != -EPROBE_DEFER)\n\t\tdev_err(ddata->dev, \"could not initialize VBUS or ID IIO: %i\\n\",\n\t\t\terror);\n\n\treturn error;\n}\n\nstatic char *cpcap_charger_supplied_to[] = {\n\t\"battery\",\n};\n\nstatic const struct power_supply_desc cpcap_charger_usb_desc = {\n\t.name\t\t= \"usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t= cpcap_charger_props,\n\t.num_properties\t= ARRAY_SIZE(cpcap_charger_props),\n\t.get_property\t= cpcap_charger_get_property,\n\t.set_property\t= cpcap_charger_set_property,\n\t.property_is_writeable = cpcap_charger_property_is_writeable,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cpcap_charger_id_table[] = {\n\t{\n\t\t.compatible = \"motorola,mapphone-cpcap-charger\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_charger_id_table);\n#endif\n\nstatic int cpcap_charger_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_charger_ddata *ddata;\n\tconst struct of_device_id *of_id;\n\tstruct power_supply_config psy_cfg = {};\n\tint error;\n\n\tof_id = of_match_device(of_match_ptr(cpcap_charger_id_table),\n\t\t\t\t&pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->dev = &pdev->dev;\n\tddata->voltage = 4200000;\n\tddata->limit_current = 532000;\n\n\tddata->reg = dev_get_regmap(ddata->dev->parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\tINIT_LIST_HEAD(&ddata->irq_list);\n\tINIT_DELAYED_WORK(&ddata->detect_work, cpcap_usb_detect);\n\tINIT_DELAYED_WORK(&ddata->vbus_work, cpcap_charger_vbus_work);\n\tplatform_set_drvdata(pdev, ddata);\n\n\terror = cpcap_charger_init_iio(ddata);\n\tif (error)\n\t\treturn error;\n\n\tatomic_set(&ddata->active, 1);\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = ddata;\n\tpsy_cfg.supplied_to = cpcap_charger_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(cpcap_charger_supplied_to),\n\n\tddata->usb = devm_power_supply_register(ddata->dev,\n\t\t\t\t\t\t&cpcap_charger_usb_desc,\n\t\t\t\t\t\t&psy_cfg);\n\tif (IS_ERR(ddata->usb)) {\n\t\terror = PTR_ERR(ddata->usb);\n\t\tdev_err(ddata->dev, \"failed to register USB charger: %i\\n\",\n\t\t\terror);\n\n\t\treturn error;\n\t}\n\n\terror = cpcap_usb_init_interrupts(pdev, ddata);\n\tif (error)\n\t\treturn error;\n\n\tddata->comparator.set_vbus = cpcap_charger_set_vbus;\n\terror = omap_usb2_set_comparator(&ddata->comparator);\n\tif (error == -ENODEV) {\n\t\tdev_info(ddata->dev, \"charger needs phy, deferring probe\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tcpcap_charger_init_optional_gpios(ddata);\n\n\tschedule_delayed_work(&ddata->detect_work, 0);\n\n\treturn 0;\n}\n\nstatic void cpcap_charger_shutdown(struct platform_device *pdev)\n{\n\tstruct cpcap_charger_ddata *ddata = platform_get_drvdata(pdev);\n\tint error;\n\n\tatomic_set(&ddata->active, 0);\n\terror = omap_usb2_set_comparator(NULL);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"could not clear USB comparator: %i\\n\",\n\t\t\t error);\n\n\terror = cpcap_charger_disable(ddata);\n\tif (error) {\n\t\tcpcap_charger_update_state(ddata, POWER_SUPPLY_STATUS_UNKNOWN);\n\t\tdev_warn(ddata->dev, \"could not clear charger: %i\\n\",\n\t\t\t error);\n\t}\n\tcpcap_charger_update_state(ddata, POWER_SUPPLY_STATUS_DISCHARGING);\n\tcancel_delayed_work_sync(&ddata->vbus_work);\n\tcancel_delayed_work_sync(&ddata->detect_work);\n}\n\nstatic int cpcap_charger_remove(struct platform_device *pdev)\n{\n\tcpcap_charger_shutdown(pdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpcap_charger_driver = {\n\t.probe = cpcap_charger_probe,\n\t.driver\t= {\n\t\t.name\t= \"cpcap-charger\",\n\t\t.of_match_table = of_match_ptr(cpcap_charger_id_table),\n\t},\n\t.shutdown = cpcap_charger_shutdown,\n\t.remove\t= cpcap_charger_remove,\n};\nmodule_platform_driver(cpcap_charger_driver);\n\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"CPCAP Battery Charger Interface driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:cpcap-charger\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}