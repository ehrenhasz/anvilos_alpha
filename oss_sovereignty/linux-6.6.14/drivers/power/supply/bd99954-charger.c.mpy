{
  "module_name": "bd99954-charger.c",
  "hash_id": "709d7af5d5677b1ca6687f25ecb13ec9c1e632bd2043c26bc8176f8cfc66e2bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bd99954-charger.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/linear_range.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include \"bd99954-charger.h\"\n\nstruct battery_data {\n\tu16 precharge_current;\t \n\tu16 fc_reg_voltage;\t \n\tu16 voltage_min;\n\tu16 voltage_max;\n};\n\n \nstruct bd9995x_init_data {\n\tu16 vsysreg_set;\t \n\tu16 ibus_lim_set;\t \n\tu16 icc_lim_set;\t \n\tu16 itrich_set;\t\t \n\tu16 iprech_set;\t\t \n\tu16 ichg_set;\t\t \n\tu16 vfastchg_reg_set1;\t \n\tu16 vprechg_th_set;\t \n\tu16 vrechg_set;\t\t \n\tu16 vbatovp_set;\t \n\tu16 iterm_set;\t\t \n};\n\nstruct bd9995x_state {\n\tu8 online;\n\tu16 chgstm_status;\n\tu16 vbat_vsys_status;\n\tu16 vbus_vcc_status;\n};\n\nstruct bd9995x_device {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct power_supply *charger;\n\n\tstruct regmap *rmap;\n\tstruct regmap_field *rmap_fields[F_MAX_FIELDS];\n\n\tint chip_id;\n\tint chip_rev;\n\tstruct bd9995x_init_data init_data;\n\tstruct bd9995x_state state;\n\n\tstruct mutex lock;  \n};\n\nstatic const struct regmap_range bd9995x_readonly_reg_ranges[] = {\n\tregmap_reg_range(CHGSTM_STATUS, SEL_ILIM_VAL),\n\tregmap_reg_range(IOUT_DACIN_VAL, IOUT_DACIN_VAL),\n\tregmap_reg_range(VCC_UCD_STATUS, VCC_IDD_STATUS),\n\tregmap_reg_range(VBUS_UCD_STATUS, VBUS_IDD_STATUS),\n\tregmap_reg_range(CHIP_ID, CHIP_REV),\n\tregmap_reg_range(SYSTEM_STATUS, SYSTEM_STATUS),\n\tregmap_reg_range(IBATP_VAL, VBAT_AVE_VAL),\n\tregmap_reg_range(VTH_VAL, EXTIADP_AVE_VAL),\n};\n\nstatic const struct regmap_access_table bd9995x_writeable_regs = {\n\t.no_ranges = bd9995x_readonly_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(bd9995x_readonly_reg_ranges),\n};\n\nstatic const struct regmap_range bd9995x_volatile_reg_ranges[] = {\n\tregmap_reg_range(CHGSTM_STATUS, WDT_STATUS),\n\tregmap_reg_range(VCC_UCD_STATUS, VCC_IDD_STATUS),\n\tregmap_reg_range(VBUS_UCD_STATUS, VBUS_IDD_STATUS),\n\tregmap_reg_range(INT0_STATUS, INT7_STATUS),\n\tregmap_reg_range(SYSTEM_STATUS, SYSTEM_CTRL_SET),\n\tregmap_reg_range(IBATP_VAL, EXTIADP_AVE_VAL),  \n};\n\nstatic const struct regmap_access_table bd9995x_volatile_regs = {\n\t.yes_ranges = bd9995x_volatile_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(bd9995x_volatile_reg_ranges),\n};\n\nstatic const struct regmap_range_cfg regmap_range_cfg[] = {\n\t{\n\t.selector_reg     = MAP_SET,\n\t.selector_mask    = 0xFFFF,\n\t.selector_shift   = 0,\n\t.window_start     = 0,\n\t.window_len       = 0x100,\n\t.range_min        = 0 * 0x100,\n\t.range_max        = 3 * 0x100,\n\t},\n};\n\nstatic const struct regmap_config bd9995x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.reg_stride = 1,\n\n\t.max_register = 3 * 0x100,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.ranges = regmap_range_cfg,\n\t.num_ranges = ARRAY_SIZE(regmap_range_cfg),\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.wr_table = &bd9995x_writeable_regs,\n\t.volatile_table = &bd9995x_volatile_regs,\n};\n\nenum bd9995x_chrg_fault {\n\tCHRG_FAULT_NORMAL,\n\tCHRG_FAULT_INPUT,\n\tCHRG_FAULT_THERMAL_SHUTDOWN,\n\tCHRG_FAULT_TIMER_EXPIRED,\n};\n\nstatic int bd9995x_get_prop_batt_health(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_BATTEMP], &tmp);\n\tif (ret)\n\t\treturn POWER_SUPPLY_HEALTH_UNKNOWN;\n\n\t \n\n\tswitch (tmp) {\n\tcase ROOM:\n\t\treturn POWER_SUPPLY_HEALTH_GOOD;\n\tcase HOT1:\n\tcase HOT2:\n\tcase HOT3:\n\t\treturn POWER_SUPPLY_HEALTH_OVERHEAT;\n\tcase COLD1:\n\tcase COLD2:\n\t\treturn POWER_SUPPLY_HEALTH_COLD;\n\tcase TEMP_DIS:\n\tcase BATT_OPEN:\n\tdefault:\n\t\treturn POWER_SUPPLY_HEALTH_UNKNOWN;\n\t}\n}\n\nstatic int bd9995x_get_prop_charge_type(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_CHGSTM_STATE], &tmp);\n\tif (ret)\n\t\treturn POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\n\tswitch (tmp) {\n\tcase CHGSTM_TRICKLE_CHARGE:\n\tcase CHGSTM_PRE_CHARGE:\n\t\treturn POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\tcase CHGSTM_FAST_CHARGE:\n\t\treturn POWER_SUPPLY_CHARGE_TYPE_FAST;\n\tcase CHGSTM_TOP_OFF:\n\tcase CHGSTM_DONE:\n\tcase CHGSTM_SUSPEND:\n\t\treturn POWER_SUPPLY_CHARGE_TYPE_NONE;\n\tdefault:  \n\t\treturn POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t}\n}\n\nstatic bool bd9995x_get_prop_batt_present(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_BATTEMP], &tmp);\n\tif (ret)\n\t\treturn false;\n\n\treturn tmp != BATT_OPEN;\n}\n\nstatic int bd9995x_get_prop_batt_voltage(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_VBAT_VAL], &tmp);\n\tif (ret)\n\t\treturn 0;\n\n\ttmp = min(tmp, 19200);\n\n\treturn tmp * 1000;\n}\n\nstatic int bd9995x_get_prop_batt_current(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_IBATP_VAL], &tmp);\n\tif (ret)\n\t\treturn 0;\n\n\treturn tmp * 1000;\n}\n\n#define DEFAULT_BATTERY_TEMPERATURE 250\n\nstatic int bd9995x_get_prop_batt_temp(struct bd9995x_device *bd)\n{\n\tint ret, tmp;\n\n\tret = regmap_field_read(bd->rmap_fields[F_THERM_VAL], &tmp);\n\tif (ret)\n\t\treturn DEFAULT_BATTERY_TEMPERATURE;\n\n\treturn (200 - tmp) * 10;\n}\n\nstatic int bd9995x_power_supply_get_property(struct power_supply *psy,\n\t\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t\t     union power_supply_propval *val)\n{\n\tint ret, tmp;\n\tstruct bd9995x_device *bd = power_supply_get_drvdata(psy);\n\tstruct bd9995x_state state;\n\n\tmutex_lock(&bd->lock);\n\tstate = bd->state;\n\tmutex_unlock(&bd->lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tswitch (state.chgstm_status) {\n\t\tcase CHGSTM_TRICKLE_CHARGE:\n\t\tcase CHGSTM_PRE_CHARGE:\n\t\tcase CHGSTM_FAST_CHARGE:\n\t\tcase CHGSTM_TOP_OFF:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\n\t\tcase CHGSTM_DONE:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\t\tbreak;\n\n\t\tcase CHGSTM_SUSPEND:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_1:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_2:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_3:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_4:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_5:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_6:\n\t\tcase CHGSTM_TEMPERATURE_ERROR_7:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_1:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_2:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_3:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_4:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_5:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_6:\n\t\tcase CHGSTM_THERMAL_SHUT_DOWN_7:\n\t\tcase CHGSTM_BATTERY_ERROR:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BD9995X_MANUFACTURER;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = state.online;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = regmap_field_read(bd->rmap_fields[F_IBATP_VAL], &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = tmp * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_AVG:\n\t\tret = regmap_field_read(bd->rmap_fields[F_IBATP_AVE_VAL], &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = tmp * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\t \n\t\tret = regmap_field_read(bd->rmap_fields[F_SEL_ILIM_VAL], &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = tmp * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tif (!state.online) {\n\t\t\tval->intval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = regmap_field_read(bd->rmap_fields[F_VFASTCHG_REG_SET1],\n\t\t\t\t\t&tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval = clamp_val(tmp << 4, 2560, 19200);\n\t\tval->intval *= 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = regmap_field_read(bd->rmap_fields[F_ITERM_SET], &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tval->intval = tmp << 6;\n\t\t \n\t\tval->intval = min(val->intval, 1024);\n\t\tval->intval *= 1000;\n\t\tbreak;\n\n\t \n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = bd9995x_get_prop_batt_present(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = bd9995x_get_prop_batt_voltage(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = bd9995x_get_prop_batt_current(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = bd9995x_get_prop_charge_type(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = bd9995x_get_prop_batt_health(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = bd9995x_get_prop_batt_temp(bd);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = \"bd99954\";\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int bd9995x_get_chip_state(struct bd9995x_device *bd,\n\t\t\t\t  struct bd9995x_state *state)\n{\n\tint i, ret, tmp;\n\tstruct {\n\t\tstruct regmap_field *id;\n\t\tu16 *data;\n\t} state_fields[] = {\n\t\t{\n\t\t\tbd->rmap_fields[F_CHGSTM_STATE], &state->chgstm_status,\n\t\t}, {\n\t\t\tbd->rmap_fields[F_VBAT_VSYS_STATUS],\n\t\t\t&state->vbat_vsys_status,\n\t\t}, {\n\t\t\tbd->rmap_fields[F_VBUS_VCC_STATUS],\n\t\t\t&state->vbus_vcc_status,\n\t\t},\n\t};\n\n\n\tfor (i = 0; i < ARRAY_SIZE(state_fields); i++) {\n\t\tret = regmap_field_read(state_fields[i].id, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*state_fields[i].data = tmp;\n\t}\n\n\tif (state->vbus_vcc_status & STATUS_VCC_DET ||\n\t    state->vbus_vcc_status & STATUS_VBUS_DET)\n\t\tstate->online = 1;\n\telse\n\t\tstate->online = 0;\n\n\treturn 0;\n}\n\nstatic irqreturn_t bd9995x_irq_handler_thread(int irq, void *private)\n{\n\tstruct bd9995x_device *bd = private;\n\tint ret, status, mask, i;\n\tunsigned long tmp;\n\tstruct bd9995x_state state;\n\n\t \n\n\tret = regmap_read(bd->rmap, INT0_STATUS, &status);\n\tif (ret) {\n\t\tdev_err(bd->dev, \"Failed to read IRQ status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_field_read(bd->rmap_fields[F_INT0_SET], &mask);\n\tif (ret) {\n\t\tdev_err(bd->dev, \"Failed to read IRQ mask\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tstatus &= mask;\n\ttmp = status;\n\n\t \n\ttmp >>= 1;\n\n\t \n\tret = regmap_field_write(bd->rmap_fields[F_INT0_SET], 0);\n\tif (ret) {\n\t\tdev_err(bd->dev, \"Failed to mask F_INT0\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_write(bd->rmap, INT0_STATUS, status);\n\tif (ret) {\n\t\tdev_err(bd->dev, \"Failed to ack F_INT0\\n\");\n\t\tgoto err_umask;\n\t}\n\n\tfor_each_set_bit(i, &tmp, 7) {\n\t\tint sub_status, sub_mask;\n\t\tstatic const int sub_status_reg[] = {\n\t\t\tINT1_STATUS, INT2_STATUS, INT3_STATUS, INT4_STATUS,\n\t\t\tINT5_STATUS, INT6_STATUS, INT7_STATUS,\n\t\t};\n\t\tstruct regmap_field *sub_mask_f[] = {\n\t\t\tbd->rmap_fields[F_INT1_SET],\n\t\t\tbd->rmap_fields[F_INT2_SET],\n\t\t\tbd->rmap_fields[F_INT3_SET],\n\t\t\tbd->rmap_fields[F_INT4_SET],\n\t\t\tbd->rmap_fields[F_INT5_SET],\n\t\t\tbd->rmap_fields[F_INT6_SET],\n\t\t\tbd->rmap_fields[F_INT7_SET],\n\t\t};\n\n\t\t \n\t\tret = regmap_read(bd->rmap, sub_status_reg[i], &sub_status);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"Failed to read IRQ sub-status\\n\");\n\t\t\tgoto err_umask;\n\t\t}\n\n\t\tret = regmap_field_read(sub_mask_f[i], &sub_mask);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"Failed to read IRQ sub-mask\\n\");\n\t\t\tgoto err_umask;\n\t\t}\n\n\t\t \n\t\tsub_status &= sub_mask;\n\n\t\tret = regmap_write(bd->rmap, sub_status_reg[i], sub_status);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"Failed to ack sub-IRQ\\n\");\n\t\t\tgoto err_umask;\n\t\t}\n\t}\n\n\tret = regmap_field_write(bd->rmap_fields[F_INT0_SET], mask);\n\tif (ret)\n\t\t \n\t\tgoto err_umask;\n\n\t \n\tret = bd9995x_get_chip_state(bd, &state);\n\tif (ret < 0) {\n\t\tdev_err(bd->dev, \"Failed to read chip state\\n\");\n\t} else {\n\t\tmutex_lock(&bd->lock);\n\t\tbd->state = state;\n\t\tmutex_unlock(&bd->lock);\n\n\t\tpower_supply_changed(bd->charger);\n\t}\n\n\treturn IRQ_HANDLED;\n\nerr_umask:\n\tret = regmap_field_write(bd->rmap_fields[F_INT0_SET], mask);\n\tif (ret)\n\t\tdev_err(bd->dev,\n\t\t\"Failed to un-mask F_INT0 - IRQ permanently disabled\\n\");\n\n\treturn IRQ_NONE;\n}\n\nstatic int __bd9995x_chip_reset(struct bd9995x_device *bd)\n{\n\tint ret, state;\n\tint rst_check_counter = 10;\n\tu16 tmp = ALLRST | OTPLD;\n\n\tret = regmap_raw_write(bd->rmap, SYSTEM_CTRL_SET, &tmp, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdo {\n\t\tret = regmap_field_read(bd->rmap_fields[F_OTPLD_STATE], &state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmsleep(10);\n\t} while (state == 0 && --rst_check_counter);\n\n\tif (!rst_check_counter) {\n\t\tdev_err(bd->dev, \"chip reset not completed\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\ttmp = 0;\n\tret = regmap_raw_write(bd->rmap, SYSTEM_CTRL_SET, &tmp, 2);\n\n\treturn ret;\n}\n\nstatic int bd9995x_hw_init(struct bd9995x_device *bd)\n{\n\tint ret;\n\tint i;\n\tstruct bd9995x_state state;\n\tstruct bd9995x_init_data *id = &bd->init_data;\n\n\tconst struct {\n\t\tenum bd9995x_fields id;\n\t\tu16 value;\n\t} init_data[] = {\n\t\t \n\t\t{F_SDP_CHG_TRIG_EN,\t1},\n\t\t \n\t\t{F_SDP_CHG_TRIG,\t1},\n\t\t \n\t\t{F_VBUS_BC_DISEN,\t1},\n\t\t \n\t\t{F_VCC_BC_DISEN,\t1},\n\t\t \n\t\t{F_ILIM_AUTO_DISEN,\t1},\n\t\t \n\t\t{F_SDP_500_SEL,\t\t1},\n\t\t \n\t\t{F_DCP_2500_SEL,\t1},\n\t\t{F_VSYSREG_SET,\t\tid->vsysreg_set},\n\t\t \n\t\t{F_USB_SUS,\t\t0},\n\t\t \n\t\t{F_DCDC_CLK_SEL,\t3},\n\t\t \n\t\t{F_CHG_EN,\t\t1},\n\t\t \n\t\t{F_EXTIADPEN,\t\t0},\n\t\t \n\t\t{F_VSYS_PRIORITY,\t1},\n\t\t{F_IBUS_LIM_SET,\tid->ibus_lim_set},\n\t\t{F_ICC_LIM_SET,\t\tid->icc_lim_set},\n\t\t \n\t\t{F_ITERM_SET,\t\tid->iterm_set},\n\t\t \n\t\t{F_ITRICH_SET,\t\tid->itrich_set},\n\t\t \n\t\t{F_IPRECH_SET,\t\tid->iprech_set},\n\t\t \n\t\t{F_ICHG_SET,\t\tid->ichg_set},\n\t\t \n\t\t{F_VFASTCHG_REG_SET1,\tid->vfastchg_reg_set1},\n\t\t \n\t\t{F_VPRECHG_TH_SET,\tid->vprechg_th_set},\n\t\t{F_VRECHG_SET,\t\tid->vrechg_set},\n\t\t{F_VBATOVP_SET,\t\tid->vbatovp_set},\n\t\t \n\t\t{F_VRBOOST_SET,\t\t0},\n\t\t \n\t\t{F_WDT_FST,\t\t0},\n\t\t \n\t\t{F_WDT_PRE,\t\t0},\n\t\t \n\t\t{F_POWER_SAVE_MODE,\t0},\n\t\t{F_INT1_SET,\t\tINT1_ALL},\n\t\t{F_INT2_SET,\t\tINT2_ALL},\n\t\t{F_INT3_SET,\t\tINT3_ALL},\n\t\t{F_INT4_SET,\t\tINT4_ALL},\n\t\t{F_INT5_SET,\t\tINT5_ALL},\n\t\t{F_INT6_SET,\t\tINT6_ALL},\n\t\t{F_INT7_SET,\t\tINT7_ALL},\n\t};\n\n\t \n\tret = __bd9995x_chip_reset(bd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\n\t\tret = regmap_field_write(bd->rmap_fields[init_data[i].id],\n\t\t\t\t\t init_data[i].value);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"failed to initialize charger (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = bd9995x_get_chip_state(bd, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&bd->lock);\n\tbd->state = state;\n\tmutex_unlock(&bd->lock);\n\n\treturn 0;\n}\n\nstatic enum power_supply_property bd9995x_power_supply_props[] = {\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_AVG,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\t \n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n};\n\nstatic const struct power_supply_desc bd9995x_power_supply_desc = {\n\t.name = \"bd9995x-charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = bd9995x_power_supply_props,\n\t.num_properties = ARRAY_SIZE(bd9995x_power_supply_props),\n\t.get_property = bd9995x_power_supply_get_property,\n};\n\n \nstatic const struct linear_range input_current_limit_ranges[] = {\n\tLINEAR_RANGE(0, 0x0, 0x1ff, 32000),\n};\n\n \nstatic const struct linear_range charging_current_ranges[] = {\n\tLINEAR_RANGE(0, 0x0, 0x10, 64000),\n\tLINEAR_RANGE(1024000, 0x11, 0x1f, 0),\n};\n\n \nstatic const struct linear_range charge_voltage_regulation_ranges[] = {\n\tLINEAR_RANGE(2560000, 0, 0xA0, 0),\n\tLINEAR_RANGE(2560000, 0xA0, 0x4B0, 16000),\n\tLINEAR_RANGE(19200000, 0x4B0, 0x7FF, 0),\n};\n\n \nstatic const struct linear_range vsys_voltage_regulation_ranges[] = {\n\tLINEAR_RANGE(2560000, 0, 0x28, 0),\n\tLINEAR_RANGE(2560000, 0x28, 0x12C, 64000),\n\tLINEAR_RANGE(19200000, 0x12C, 0x1FF, 0),\n};\n\n \nstatic const struct linear_range trickle_to_pre_threshold_ranges[] = {\n\tLINEAR_RANGE(2048000, 0, 0x20, 0),\n\tLINEAR_RANGE(2048000, 0x20, 0x12C, 64000),\n\tLINEAR_RANGE(19200000, 0x12C, 0x1FF, 0),\n};\n\n \nstatic const struct linear_range fast_charge_current_ranges[] = {\n\tLINEAR_RANGE(0, 0, 0xFF, 64000),\n};\n\nstruct battery_init {\n\tconst char *name;\n\tint *info_data;\n\tconst struct linear_range *range;\n\tint ranges;\n\tu16 *data;\n};\n\nstruct dt_init {\n\tchar *prop;\n\tconst struct linear_range *range;\n\tint ranges;\n\tu16 *data;\n};\n\nstatic int bd9995x_fw_probe(struct bd9995x_device *bd)\n{\n\tint ret;\n\tstruct power_supply_battery_info *info;\n\tu32 property;\n\tint i;\n\tint regval;\n\tbool found;\n\tstruct bd9995x_init_data *init = &bd->init_data;\n\tstruct battery_init battery_inits[] = {\n\t\t{\n\t\t\t.name = \"trickle-charging current\",\n\t\t\t.range = &charging_current_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->itrich_set,\n\t\t}, {\n\t\t\t.name = \"pre-charging current\",\n\t\t\t.range = &charging_current_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->iprech_set,\n\t\t}, {\n\t\t\t.name = \"pre-to-trickle charge voltage threshold\",\n\t\t\t.range = &trickle_to_pre_threshold_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->vprechg_th_set,\n\t\t}, {\n\t\t\t.name = \"charging termination current\",\n\t\t\t.range = &charging_current_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->iterm_set,\n\t\t}, {\n\t\t\t.name = \"charging re-start voltage\",\n\t\t\t.range = &charge_voltage_regulation_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->vrechg_set,\n\t\t}, {\n\t\t\t.name = \"battery overvoltage limit\",\n\t\t\t.range = &charge_voltage_regulation_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->vbatovp_set,\n\t\t}, {\n\t\t\t.name = \"fast-charging max current\",\n\t\t\t.range = &fast_charge_current_ranges[0],\n\t\t\t.ranges = 1,\n\t\t\t.data = &init->ichg_set,\n\t\t}, {\n\t\t\t.name = \"fast-charging voltage\",\n\t\t\t.range = &charge_voltage_regulation_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->vfastchg_reg_set1,\n\t\t},\n\t};\n\tstruct dt_init props[] = {\n\t\t{\n\t\t\t.prop = \"rohm,vsys-regulation-microvolt\",\n\t\t\t.range = &vsys_voltage_regulation_ranges[0],\n\t\t\t.ranges = 2,\n\t\t\t.data = &init->vsysreg_set,\n\t\t}, {\n\t\t\t.prop = \"rohm,vbus-input-current-limit-microamp\",\n\t\t\t.range = &input_current_limit_ranges[0],\n\t\t\t.ranges = 1,\n\t\t\t.data = &init->ibus_lim_set,\n\t\t}, {\n\t\t\t.prop = \"rohm,vcc-input-current-limit-microamp\",\n\t\t\t.range = &input_current_limit_ranges[0],\n\t\t\t.ranges = 1,\n\t\t\t.data = &init->icc_lim_set,\n\t\t},\n\t};\n\n\t \n\tret = power_supply_get_battery_info(bd->charger, &info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbattery_inits[0].info_data = &info->tricklecharge_current_ua;\n\tbattery_inits[1].info_data = &info->precharge_current_ua;\n\tbattery_inits[2].info_data = &info->precharge_voltage_max_uv;\n\tbattery_inits[3].info_data = &info->charge_term_current_ua;\n\tbattery_inits[4].info_data = &info->charge_restart_voltage_uv;\n\tbattery_inits[5].info_data = &info->overvoltage_limit_uv;\n\tbattery_inits[6].info_data = &info->constant_charge_current_max_ua;\n\tbattery_inits[7].info_data = &info->constant_charge_voltage_max_uv;\n\n\tfor (i = 0; i < ARRAY_SIZE(battery_inits); i++) {\n\t\tint val = *battery_inits[i].info_data;\n\t\tconst struct linear_range *range = battery_inits[i].range;\n\t\tint ranges = battery_inits[i].ranges;\n\n\t\tif (val == -EINVAL)\n\t\t\tcontinue;\n\n\t\tret = linear_range_get_selector_low_array(range, ranges, val,\n\t\t\t\t\t\t\t  &regval, &found);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"Unsupported value for %s\\n\",\n\t\t\t\tbattery_inits[i].name);\n\n\t\t\tpower_supply_put_battery_info(bd->charger, info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!found) {\n\t\t\tdev_warn(bd->dev,\n\t\t\t\t \"Unsupported value for %s - using smaller\\n\",\n\t\t\t\t battery_inits[i].name);\n\t\t}\n\t\t*(battery_inits[i].data) = regval;\n\t}\n\n\tpower_supply_put_battery_info(bd->charger, info);\n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tret = device_property_read_u32(bd->dev, props[i].prop,\n\t\t\t\t\t       &property);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bd->dev, \"failed to read %s\", props[i].prop);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = linear_range_get_selector_low_array(props[i].range,\n\t\t\t\t\t\t\t  props[i].ranges,\n\t\t\t\t\t\t\t  property, &regval,\n\t\t\t\t\t\t\t  &found);\n\t\tif (ret) {\n\t\t\tdev_err(bd->dev, \"Unsupported value for '%s'\\n\",\n\t\t\t\tprops[i].prop);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tdev_warn(bd->dev,\n\t\t\t\t \"Unsupported value for '%s' - using smaller\\n\",\n\t\t\t\t props[i].prop);\n\t\t}\n\n\t\t*(props[i].data) = regval;\n\t}\n\n\treturn 0;\n}\n\nstatic void bd9995x_chip_reset(void *bd)\n{\n\t__bd9995x_chip_reset(bd);\n}\n\nstatic int bd9995x_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct bd9995x_device *bd;\n\tstruct power_supply_config psy_cfg = {};\n\tint ret;\n\tint i;\n\n\tbd = devm_kzalloc(dev, sizeof(*bd), GFP_KERNEL);\n\tif (!bd)\n\t\treturn -ENOMEM;\n\n\tbd->client = client;\n\tbd->dev = dev;\n\tpsy_cfg.drv_data = bd;\n\tpsy_cfg.of_node = dev->of_node;\n\n\tmutex_init(&bd->lock);\n\n\tbd->rmap = devm_regmap_init_i2c(client, &bd9995x_regmap_config);\n\tif (IS_ERR(bd->rmap)) {\n\t\tdev_err(dev, \"Failed to setup register access via i2c\\n\");\n\t\treturn PTR_ERR(bd->rmap);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bd9995x_reg_fields); i++) {\n\t\tconst struct reg_field *reg_fields = bd9995x_reg_fields;\n\n\t\tbd->rmap_fields[i] = devm_regmap_field_alloc(dev, bd->rmap,\n\t\t\t\t\t\t\t     reg_fields[i]);\n\t\tif (IS_ERR(bd->rmap_fields[i])) {\n\t\t\tdev_err(dev, \"cannot allocate regmap field\\n\");\n\t\t\treturn PTR_ERR(bd->rmap_fields[i]);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, bd);\n\n\tret = regmap_field_read(bd->rmap_fields[F_CHIP_ID], &bd->chip_id);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot read chip ID.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (bd->chip_id != BD99954_ID) {\n\t\tdev_err(dev, \"Chip with ID=0x%x, not supported!\\n\",\n\t\t\tbd->chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_field_read(bd->rmap_fields[F_CHIP_REV], &bd->chip_rev);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot read revision.\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(bd->dev, \"Found BD99954 chip rev %d\\n\", bd->chip_rev);\n\n\t \n\tbd->charger = devm_power_supply_register(bd->dev,\n\t\t\t\t\t\t &bd9995x_power_supply_desc,\n\t\t\t\t\t\t&psy_cfg);\n\tif (IS_ERR(bd->charger)) {\n\t\tdev_err(dev, \"Failed to register power supply\\n\");\n\t\treturn PTR_ERR(bd->charger);\n\t}\n\n\tret = bd9995x_fw_probe(bd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot read device properties.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bd9995x_hw_init(bd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot initialize the chip.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, bd9995x_chip_reset, bd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t bd9995x_irq_handler_thread,\n\t\t\t\t\t IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t BD9995X_IRQ_PIN, bd);\n}\n\nstatic const struct of_device_id bd9995x_of_match[] = {\n\t{ .compatible = \"rohm,bd99954\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bd9995x_of_match);\n\nstatic struct i2c_driver bd9995x_driver = {\n\t.driver = {\n\t\t.name = \"bd9995x-charger\",\n\t\t.of_match_table = bd9995x_of_match,\n\t},\n\t.probe = bd9995x_probe,\n};\nmodule_i2c_driver(bd9995x_driver);\n\nMODULE_AUTHOR(\"Laine Markus <markus.laine@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD99954 charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}