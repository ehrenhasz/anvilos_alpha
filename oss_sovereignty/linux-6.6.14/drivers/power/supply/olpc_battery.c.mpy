{
  "module_name": "olpc_battery.c",
  "hash_id": "02b1def07530a25882a78b146c215fd21391e672b1ccafe5dd2772f6da865d0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/olpc_battery.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/olpc-ec.h>\n\n\n#define EC_BAT_VOLTAGE\t0x10\t \n#define EC_BAT_CURRENT\t0x11\t \n#define EC_BAT_ACR\t0x12\t \n#define EC_BAT_TEMP\t0x13\t \n#define EC_AMB_TEMP\t0x14\t \n#define EC_BAT_STATUS\t0x15\t \n#define EC_BAT_SOC\t0x16\t \n#define EC_BAT_SERIAL\t0x17\t \n#define EC_BAT_EEPROM\t0x18\t \n#define EC_BAT_ERRCODE\t0x1f\t \n\n#define BAT_STAT_PRESENT\t0x01\n#define BAT_STAT_FULL\t\t0x02\n#define BAT_STAT_LOW\t\t0x04\n#define BAT_STAT_DESTROY\t0x08\n#define BAT_STAT_AC\t\t0x10\n#define BAT_STAT_CHARGING\t0x20\n#define BAT_STAT_DISCHARGING\t0x40\n#define BAT_STAT_TRICKLE\t0x80\n\n#define BAT_ERR_INFOFAIL\t0x02\n#define BAT_ERR_OVERVOLTAGE\t0x04\n#define BAT_ERR_OVERTEMP\t0x05\n#define BAT_ERR_GAUGESTOP\t0x06\n#define BAT_ERR_OUT_OF_CONTROL\t0x07\n#define BAT_ERR_ID_FAIL\t\t0x09\n#define BAT_ERR_ACR_FAIL\t0x10\n\n#define BAT_ADDR_MFR_TYPE\t0x5F\n\nstruct olpc_battery_data {\n\tstruct power_supply *olpc_ac;\n\tstruct power_supply *olpc_bat;\n\tchar bat_serial[17];\n\tbool new_proto;\n\tbool little_endian;\n};\n\n \n\nstatic int olpc_ac_get_prop(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tint ret = 0;\n\tuint8_t status;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = olpc_ec_cmd(EC_BAT_STATUS, NULL, 0, &status, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = !!(status & BAT_STAT_AC);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic enum power_supply_property olpc_ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc olpc_ac_desc = {\n\t.name = \"olpc_ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = olpc_ac_props,\n\t.num_properties = ARRAY_SIZE(olpc_ac_props),\n\t.get_property = olpc_ac_get_prop,\n};\n\nstatic int olpc_bat_get_status(struct olpc_battery_data *data,\n\t\tunion power_supply_propval *val, uint8_t ec_byte)\n{\n\tif (data->new_proto) {\n\t\tif (ec_byte & (BAT_STAT_CHARGING | BAT_STAT_TRICKLE))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (ec_byte & BAT_STAT_DISCHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (ec_byte & BAT_STAT_FULL)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t} else {\n\t\t \n\t\tif (!(ec_byte & BAT_STAT_AC))  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (ec_byte & BAT_STAT_FULL)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t}\n\n\treturn 0;\n}\n\nstatic int olpc_bat_get_health(union power_supply_propval *val)\n{\n\tuint8_t ec_byte;\n\tint ret;\n\n\tret = olpc_ec_cmd(EC_BAT_ERRCODE, NULL, 0, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ec_byte) {\n\tcase 0:\n\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\n\tcase BAT_ERR_OVERTEMP:\n\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\tbreak;\n\n\tcase BAT_ERR_OVERVOLTAGE:\n\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\tbreak;\n\n\tcase BAT_ERR_INFOFAIL:\n\tcase BAT_ERR_OUT_OF_CONTROL:\n\tcase BAT_ERR_ID_FAIL:\n\tcase BAT_ERR_ACR_FAIL:\n\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int olpc_bat_get_mfr(union power_supply_propval *val)\n{\n\tuint8_t ec_byte;\n\tint ret;\n\n\tec_byte = BAT_ADDR_MFR_TYPE;\n\tret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ec_byte >> 4) {\n\tcase 1:\n\t\tval->strval = \"Gold Peak\";\n\t\tbreak;\n\tcase 2:\n\t\tval->strval = \"BYD\";\n\t\tbreak;\n\tdefault:\n\t\tval->strval = \"Unknown\";\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int olpc_bat_get_tech(union power_supply_propval *val)\n{\n\tuint8_t ec_byte;\n\tint ret;\n\n\tec_byte = BAT_ADDR_MFR_TYPE;\n\tret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ec_byte & 0xf) {\n\tcase 1:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_NiMH;\n\t\tbreak;\n\tcase 2:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LiFe;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int olpc_bat_get_charge_full_design(union power_supply_propval *val)\n{\n\tuint8_t ec_byte;\n\tunion power_supply_propval tech;\n\tint ret, mfr;\n\n\tret = olpc_bat_get_tech(&tech);\n\tif (ret)\n\t\treturn ret;\n\n\tec_byte = BAT_ADDR_MFR_TYPE;\n\tret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmfr = ec_byte >> 4;\n\n\tswitch (tech.intval) {\n\tcase POWER_SUPPLY_TECHNOLOGY_NiMH:\n\t\tswitch (mfr) {\n\t\tcase 1:  \n\t\t\tval->intval = 3000000*.8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_TECHNOLOGY_LiFe:\n\t\tswitch (mfr) {\n\t\tcase 1:  \n\t\tcase 2:  \n\t\t\tval->intval = 2800000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int olpc_bat_get_charge_now(union power_supply_propval *val)\n{\n\tuint8_t soc;\n\tunion power_supply_propval full;\n\tint ret;\n\n\tret = olpc_ec_cmd(EC_BAT_SOC, NULL, 0, &soc, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = olpc_bat_get_charge_full_design(&full);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = soc * (full.intval / 100);\n\treturn 0;\n}\n\nstatic int olpc_bat_get_voltage_max_design(union power_supply_propval *val)\n{\n\tuint8_t ec_byte;\n\tunion power_supply_propval tech;\n\tint mfr;\n\tint ret;\n\n\tret = olpc_bat_get_tech(&tech);\n\tif (ret)\n\t\treturn ret;\n\n\tec_byte = BAT_ADDR_MFR_TYPE;\n\tret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmfr = ec_byte >> 4;\n\n\tswitch (tech.intval) {\n\tcase POWER_SUPPLY_TECHNOLOGY_NiMH:\n\t\tswitch (mfr) {\n\t\tcase 1:  \n\t\t\tval->intval = 6000000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_TECHNOLOGY_LiFe:\n\t\tswitch (mfr) {\n\t\tcase 1:  \n\t\t\tval->intval = 6400000;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tval->intval = 6500000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic u16 ecword_to_cpu(struct olpc_battery_data *data, u16 ec_word)\n{\n\tif (data->little_endian)\n\t\treturn le16_to_cpu((__force __le16)ec_word);\n\telse\n\t\treturn be16_to_cpu((__force __be16)ec_word);\n}\n\n \nstatic int olpc_bat_get_property(struct power_supply *psy,\n\t\t\t\t enum power_supply_property psp,\n\t\t\t\t union power_supply_propval *val)\n{\n\tstruct olpc_battery_data *data = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tu16 ec_word;\n\tuint8_t ec_byte;\n\t__be64 ser_buf;\n\n\tret = olpc_ec_cmd(EC_BAT_STATUS, NULL, 0, &ec_byte, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(ec_byte & (BAT_STAT_PRESENT | BAT_STAT_TRICKLE)) &&\n\t\t\tpsp != POWER_SUPPLY_PROP_PRESENT)\n\t\treturn -ENODEV;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = olpc_bat_get_status(data, val, ec_byte);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tif (ec_byte & BAT_STAT_TRICKLE)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\telse if (ec_byte & BAT_STAT_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!(ec_byte & (BAT_STAT_PRESENT |\n\t\t\t\t\t    BAT_STAT_TRICKLE));\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (ec_byte & BAT_STAT_DESTROY)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\telse {\n\t\t\tret = olpc_bat_get_health(val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tret = olpc_bat_get_mfr(val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tret = olpc_bat_get_tech(val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = olpc_ec_cmd(EC_BAT_VOLTAGE, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = ecword_to_cpu(data, ec_word) * 9760L / 32;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = olpc_ec_cmd(EC_BAT_CURRENT, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = ecword_to_cpu(data, ec_word) * 15625L / 120;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = olpc_ec_cmd(EC_BAT_SOC, NULL, 0, &ec_byte, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = ec_byte;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tif (ec_byte & BAT_STAT_FULL)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\telse if (ec_byte & BAT_STAT_LOW)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tret = olpc_bat_get_charge_full_design(val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tret = olpc_bat_get_charge_now(val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = olpc_ec_cmd(EC_BAT_TEMP, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = ecword_to_cpu(data, ec_word) * 10 / 256;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT:\n\t\tret = olpc_ec_cmd(EC_AMB_TEMP, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = (int)ecword_to_cpu(data, ec_word) * 10 / 256;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tret = olpc_ec_cmd(EC_BAT_ACR, NULL, 0, (void *)&ec_word, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = ecword_to_cpu(data, ec_word) * 6250 / 15;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tret = olpc_ec_cmd(EC_BAT_SERIAL, NULL, 0, (void *)&ser_buf, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsprintf(data->bat_serial, \"%016llx\", (long long)be64_to_cpu(ser_buf));\n\t\tval->strval = data->bat_serial;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tret = olpc_bat_get_voltage_max_design(val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property olpc_xo1_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TEMP_AMBIENT,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n};\n\n \nstatic enum power_supply_property olpc_xo15_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n};\n\n \n\n#define EEPROM_START\t0x20\n#define EEPROM_END\t0x80\n#define EEPROM_SIZE\t(EEPROM_END - EEPROM_START)\n\nstatic ssize_t olpc_bat_eeprom_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr, char *buf, loff_t off, size_t count)\n{\n\tuint8_t ec_byte;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tec_byte = EEPROM_START + off + i;\n\t\tret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1, &buf[i], 1);\n\t\tif (ret) {\n\t\t\tpr_err(\"olpc-battery: \"\n\t\t\t       \"EC_BAT_EEPROM cmd @ 0x%x failed - %d!\\n\",\n\t\t\t       ec_byte, ret);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic struct bin_attribute olpc_bat_eeprom = {\n\t.attr = {\n\t\t.name = \"eeprom\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = EEPROM_SIZE,\n\t.read = olpc_bat_eeprom_read,\n};\n\n \n\nstatic ssize_t olpc_bat_error_read(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tuint8_t ec_byte;\n\tssize_t ret;\n\n\tret = olpc_ec_cmd(EC_BAT_ERRCODE, NULL, 0, &ec_byte, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ec_byte);\n}\n\nstatic struct device_attribute olpc_bat_error = {\n\t.attr = {\n\t\t.name = \"error\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = olpc_bat_error_read,\n};\n\nstatic struct attribute *olpc_bat_sysfs_attrs[] = {\n\t&olpc_bat_error.attr,\n\tNULL\n};\n\nstatic struct bin_attribute *olpc_bat_sysfs_bin_attrs[] = {\n\t&olpc_bat_eeprom,\n\tNULL\n};\n\nstatic const struct attribute_group olpc_bat_sysfs_group = {\n\t.attrs = olpc_bat_sysfs_attrs,\n\t.bin_attrs = olpc_bat_sysfs_bin_attrs,\n\n};\n\nstatic const struct attribute_group *olpc_bat_sysfs_groups[] = {\n\t&olpc_bat_sysfs_group,\n\tNULL\n};\n\n \n\nstatic struct power_supply_desc olpc_bat_desc = {\n\t.name = \"olpc_battery\",\n\t.get_property = olpc_bat_get_property,\n\t.use_for_apm = 1,\n};\n\nstatic int olpc_battery_suspend(struct platform_device *pdev,\n\t\t\t\tpm_message_t state)\n{\n\tstruct olpc_battery_data *data = platform_get_drvdata(pdev);\n\n\tif (device_may_wakeup(&data->olpc_ac->dev))\n\t\tolpc_ec_wakeup_set(EC_SCI_SRC_ACPWR);\n\telse\n\t\tolpc_ec_wakeup_clear(EC_SCI_SRC_ACPWR);\n\n\tif (device_may_wakeup(&data->olpc_bat->dev))\n\t\tolpc_ec_wakeup_set(EC_SCI_SRC_BATTERY | EC_SCI_SRC_BATSOC\n\t\t\t\t   | EC_SCI_SRC_BATERR);\n\telse\n\t\tolpc_ec_wakeup_clear(EC_SCI_SRC_BATTERY | EC_SCI_SRC_BATSOC\n\t\t\t\t     | EC_SCI_SRC_BATERR);\n\n\treturn 0;\n}\n\nstatic int olpc_battery_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config bat_psy_cfg = {};\n\tstruct power_supply_config ac_psy_cfg = {};\n\tstruct olpc_battery_data *data;\n\tstruct device_node *np;\n\tuint8_t status;\n\tuint8_t ecver;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tret = olpc_ec_cmd(EC_FIRMWARE_REV, NULL, 0, &ecver, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"olpc,xo1.75-ec\");\n\tif (np) {\n\t\tof_node_put(np);\n\t\t \n\t\tdata->new_proto = true;\n\t\tdata->little_endian = true;\n\t} else if (ecver > 0x44) {\n\t\t \n\t\tdata->new_proto = true;\n\t} else if (ecver < 0x44) {\n\t\t \n\t\tprintk(KERN_NOTICE \"OLPC EC version 0x%02x too old for \"\n\t\t\t\"battery driver.\\n\", ecver);\n\t\treturn -ENXIO;\n\t}\n\n\tret = olpc_ec_cmd(EC_BAT_STATUS, NULL, 0, &status, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tac_psy_cfg.of_node = pdev->dev.of_node;\n\tac_psy_cfg.drv_data = data;\n\n\tdata->olpc_ac = devm_power_supply_register(&pdev->dev, &olpc_ac_desc,\n\t\t\t\t\t\t\t\t&ac_psy_cfg);\n\tif (IS_ERR(data->olpc_ac))\n\t\treturn PTR_ERR(data->olpc_ac);\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"olpc,xo1.5-battery\")) {\n\t\t \n\t\tolpc_bat_desc.properties = olpc_xo15_bat_props;\n\t\tolpc_bat_desc.num_properties = ARRAY_SIZE(olpc_xo15_bat_props);\n\t} else {\n\t\t \n\t\tolpc_bat_desc.properties = olpc_xo1_bat_props;\n\t\tolpc_bat_desc.num_properties = ARRAY_SIZE(olpc_xo1_bat_props);\n\t}\n\n\tbat_psy_cfg.of_node = pdev->dev.of_node;\n\tbat_psy_cfg.drv_data = data;\n\tbat_psy_cfg.attr_grp = olpc_bat_sysfs_groups;\n\n\tdata->olpc_bat = devm_power_supply_register(&pdev->dev, &olpc_bat_desc,\n\t\t\t\t\t\t\t\t&bat_psy_cfg);\n\tif (IS_ERR(data->olpc_bat))\n\t\treturn PTR_ERR(data->olpc_bat);\n\n\tif (olpc_ec_wakeup_available()) {\n\t\tdevice_set_wakeup_capable(&data->olpc_ac->dev, true);\n\t\tdevice_set_wakeup_capable(&data->olpc_bat->dev, true);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id olpc_battery_ids[] = {\n\t{ .compatible = \"olpc,xo1-battery\" },\n\t{ .compatible = \"olpc,xo1.5-battery\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, olpc_battery_ids);\n\nstatic struct platform_driver olpc_battery_driver = {\n\t.driver = {\n\t\t.name = \"olpc-battery\",\n\t\t.of_match_table = olpc_battery_ids,\n\t},\n\t.probe = olpc_battery_probe,\n\t.suspend = olpc_battery_suspend,\n};\n\nmodule_platform_driver(olpc_battery_driver);\n\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Battery driver for One Laptop Per Child 'XO' machine\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}