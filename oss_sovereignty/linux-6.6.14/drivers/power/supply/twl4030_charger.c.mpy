{
  "module_name": "twl4030_charger.c",
  "hash_id": "c44a2588fa76af4f3d3747026ec4dc97db4b6a6957eb5a6dcc341bc1b8b3abe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/twl4030_charger.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/twl.h>\n#include <linux/power_supply.h>\n#include <linux/notifier.h>\n#include <linux/usb/otg.h>\n#include <linux/iio/consumer.h>\n\n#define TWL4030_BCIMDEN\t\t0x00\n#define TWL4030_BCIMDKEY\t0x01\n#define TWL4030_BCIMSTATEC\t0x02\n#define TWL4030_BCIICHG\t\t0x08\n#define TWL4030_BCIVAC\t\t0x0a\n#define TWL4030_BCIVBUS\t\t0x0c\n#define TWL4030_BCIMFSTS3\t0x0F\n#define TWL4030_BCIMFSTS4\t0x10\n#define TWL4030_BCICTL1\t\t0x23\n#define TWL4030_BB_CFG\t\t0x12\n#define TWL4030_BCIIREF1\t0x27\n#define TWL4030_BCIIREF2\t0x28\n#define TWL4030_BCIMFKEY\t0x11\n#define TWL4030_BCIMFEN3\t0x14\n#define TWL4030_BCIMFTH8\t0x1d\n#define TWL4030_BCIMFTH9\t0x1e\n#define TWL4030_BCIWDKEY\t0x21\n\n#define TWL4030_BCIMFSTS1\t0x01\n\n#define TWL4030_BCIAUTOWEN\tBIT(5)\n#define TWL4030_CONFIG_DONE\tBIT(4)\n#define TWL4030_CVENAC\t\tBIT(2)\n#define TWL4030_BCIAUTOUSB\tBIT(1)\n#define TWL4030_BCIAUTOAC\tBIT(0)\n#define TWL4030_CGAIN\t\tBIT(5)\n#define TWL4030_USBFASTMCHG\tBIT(2)\n#define TWL4030_STS_VBUS\tBIT(7)\n#define TWL4030_STS_USB_ID\tBIT(2)\n#define TWL4030_BBCHEN\t\tBIT(4)\n#define TWL4030_BBSEL_MASK\t0x0c\n#define TWL4030_BBSEL_2V5\t0x00\n#define TWL4030_BBSEL_3V0\t0x04\n#define TWL4030_BBSEL_3V1\t0x08\n#define TWL4030_BBSEL_3V2\t0x0c\n#define TWL4030_BBISEL_MASK\t0x03\n#define TWL4030_BBISEL_25uA\t0x00\n#define TWL4030_BBISEL_150uA\t0x01\n#define TWL4030_BBISEL_500uA\t0x02\n#define TWL4030_BBISEL_1000uA\t0x03\n\n#define TWL4030_BATSTSPCHG\tBIT(2)\n#define TWL4030_BATSTSMCHG\tBIT(6)\n\n \n#define TWL4030_WOVF\t\tBIT(0)  \n#define TWL4030_TMOVF\t\tBIT(1)  \n#define TWL4030_ICHGHIGH\tBIT(2)  \n#define TWL4030_ICHGLOW\t\tBIT(3)  \n#define TWL4030_ICHGEOC\t\tBIT(4)  \n#define TWL4030_TBATOR2\t\tBIT(5)  \n#define TWL4030_TBATOR1\t\tBIT(6)  \n#define TWL4030_BATSTS\t\tBIT(7)  \n\n#define TWL4030_VBATLVL\t\tBIT(0)  \n#define TWL4030_VBATOV\t\tBIT(1)  \n#define TWL4030_VBUSOV\t\tBIT(2)  \n#define TWL4030_ACCHGOV\t\tBIT(3)  \n\n#define TWL4030_MSTATEC_USB\t\tBIT(4)\n#define TWL4030_MSTATEC_AC\t\tBIT(5)\n#define TWL4030_MSTATEC_MASK\t\t0x0f\n#define TWL4030_MSTATEC_QUICK1\t\t0x02\n#define TWL4030_MSTATEC_QUICK7\t\t0x07\n#define TWL4030_MSTATEC_COMPLETE1\t0x0b\n#define TWL4030_MSTATEC_COMPLETE4\t0x0e\n\n \nstatic inline int ac_available(struct iio_channel *channel_vac)\n{\n\tint val, err;\n\n\tif (!channel_vac)\n\t\treturn 0;\n\n\terr = iio_read_channel_processed(channel_vac, &val);\n\tif (err < 0)\n\t\treturn 0;\n\treturn val > 4500;\n}\n\nstatic bool allow_usb;\nmodule_param(allow_usb, bool, 0644);\nMODULE_PARM_DESC(allow_usb, \"Allow USB charge drawing default current\");\n\nstruct twl4030_bci {\n\tstruct device\t\t*dev;\n\tstruct power_supply\t*ac;\n\tstruct power_supply\t*usb;\n\tstruct usb_phy\t\t*transceiver;\n\tstruct notifier_block\tusb_nb;\n\tstruct work_struct\twork;\n\tint\t\t\tirq_chg;\n\tint\t\t\tirq_bci;\n\tint\t\t\tusb_enabled;\n\n\t \n\tunsigned int\t\tichg_eoc, ichg_lo, ichg_hi;\n\tunsigned int\t\tusb_cur, ac_cur;\n\tstruct iio_channel\t*channel_vac;\n\tbool\t\t\tac_is_active;\n\tint\t\t\tusb_mode, ac_mode;  \n#define\tCHARGE_OFF\t0\n#define\tCHARGE_AUTO\t1\n#define\tCHARGE_LINEAR\t2\n\n\t \n\tunsigned int\t\tusb_cur_target;\n\tstruct delayed_work\tcurrent_worker;\n#define\tUSB_CUR_STEP\t20000\t \n#define\tUSB_MIN_VOLT\t4750000\t \n#define\tUSB_CUR_DELAY\tmsecs_to_jiffies(100)\n#define\tUSB_MAX_CURRENT\t1700000  \n\n\tunsigned long\t\tevent;\n};\n\n \nstatic const char *modes[] = { \"off\", \"auto\", \"continuous\" };\n\n \nstatic int twl4030_clear_set(u8 mod_no, u8 clear, u8 set, u8 reg)\n{\n\tu8 val = 0;\n\tint ret;\n\n\tret = twl_i2c_read_u8(mod_no, &val, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~clear;\n\tval |= set;\n\n\treturn twl_i2c_write_u8(mod_no, val, reg);\n}\n\nstatic int twl4030_bci_read(u8 reg, u8 *val)\n{\n\treturn twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, val, reg);\n}\n\nstatic int twl4030_clear_set_boot_bci(u8 clear, u8 set)\n{\n\treturn twl4030_clear_set(TWL_MODULE_PM_MASTER, clear,\n\t\t\tTWL4030_CONFIG_DONE | TWL4030_BCIAUTOWEN | set,\n\t\t\tTWL4030_PM_MASTER_BOOT_BCI);\n}\n\nstatic int twl4030bci_read_adc_val(u8 reg)\n{\n\tint ret, temp;\n\tu8 val;\n\n\t \n\tret = twl4030_bci_read(reg + 1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = (int)(val & 0x03) << 8;\n\n\t \n\tret = twl4030_bci_read(reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn temp | val;\n}\n\n \n \nstatic int regval2ua(int regval, bool cgain)\n{\n\tif (cgain)\n\t\treturn (regval * 16618 - 8500 * 1000) / 5;\n\telse\n\t\treturn (regval * 16618 - 8500 * 1000) / 10;\n}\n\n \nstatic int ua2regval(int ua, bool cgain)\n{\n\tint ret;\n\tif (cgain)\n\t\tua /= 2;\n\tret = (ua * 10 + 8500 * 1000) / 16618;\n\t \n\tif (ret < 512)\n\t\tret = 512;\n\treturn ret;\n}\n\nstatic int twl4030_charger_update_current(struct twl4030_bci *bci)\n{\n\tint status;\n\tint cur;\n\tunsigned reg, cur_reg;\n\tu8 bcictl1, oldreg, fullreg;\n\tbool cgain = false;\n\tu8 boot_bci;\n\n\t \n\tif (ac_available(bci->channel_vac)) {\n\t\tcur = bci->ac_cur;\n\t\tbci->ac_is_active = true;\n\t} else {\n\t\tcur = bci->usb_cur;\n\t\tbci->ac_is_active = false;\n\t\tif (cur > bci->usb_cur_target) {\n\t\t\tcur = bci->usb_cur_target;\n\t\t\tbci->usb_cur = cur;\n\t\t}\n\t\tif (cur < bci->usb_cur_target)\n\t\t\tschedule_delayed_work(&bci->current_worker, USB_CUR_DELAY);\n\t}\n\n\t \n\tif (bci->ichg_eoc >= 200000)\n\t\tcgain = true;\n\tif (bci->ichg_lo >= 400000)\n\t\tcgain = true;\n\tif (bci->ichg_hi >= 820000)\n\t\tcgain = true;\n\tif (cur > 852000)\n\t\tcgain = true;\n\n\tstatus = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\n\tif (status < 0)\n\t\treturn status;\n\tif (twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &boot_bci,\n\t\t\t    TWL4030_PM_MASTER_BOOT_BCI) < 0)\n\t\tboot_bci = 0;\n\tboot_bci &= 7;\n\n\tif ((!!cgain) != !!(bcictl1 & TWL4030_CGAIN))\n\t\t \n\t\ttwl4030_clear_set_boot_bci(boot_bci, 0);\n\n\t \n\treg = ua2regval(bci->ichg_eoc, cgain);\n\tif (reg > 0x278)\n\t\treg = 0x278;\n\tif (reg < 0x200)\n\t\treg = 0x200;\n\treg = (reg >> 3) & 0xf;\n\tfullreg = reg << 4;\n\n\t \n\treg = ua2regval(bci->ichg_lo, cgain);\n\tif (reg > 0x2F0)\n\t\treg = 0x2F0;\n\tif (reg < 0x200)\n\t\treg = 0x200;\n\treg = (reg >> 4) & 0xf;\n\tfullreg |= reg;\n\n\t \n\tstatus = twl4030_bci_read(TWL4030_BCIMFTH8, &oldreg);\n\tif (status < 0)\n\t\treturn status;\n\tif (oldreg != fullreg) {\n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xF4,\n\t\t\t\t\t  TWL4030_BCIMFKEY);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\ttwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t fullreg, TWL4030_BCIMFTH8);\n\t}\n\n\t \n\treg = ua2regval(bci->ichg_hi, cgain);\n\tif (reg > 0x3E0)\n\t\treg = 0x3E0;\n\tif (reg < 0x200)\n\t\treg = 0x200;\n\tfullreg = (reg >> 5) & 0xF;\n\tfullreg <<= 4;\n\tstatus = twl4030_bci_read(TWL4030_BCIMFTH9, &oldreg);\n\tif (status < 0)\n\t\treturn status;\n\tif ((oldreg & 0xF0) != fullreg) {\n\t\tfullreg |= (oldreg & 0x0F);\n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\n\t\t\t\t\t  TWL4030_BCIMFKEY);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\ttwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t fullreg, TWL4030_BCIMFTH9);\n\t}\n\n\t \n\treg = ua2regval(cur, cgain);\n\t \n\tif (reg > 0x3ff)\n\t\treg = 0x3ff;\n\tstatus = twl4030_bci_read(TWL4030_BCIIREF1, &oldreg);\n\tif (status < 0)\n\t\treturn status;\n\tcur_reg = oldreg;\n\tstatus = twl4030_bci_read(TWL4030_BCIIREF2, &oldreg);\n\tif (status < 0)\n\t\treturn status;\n\tcur_reg |= oldreg << 8;\n\tif (reg != oldreg) {\n\t\t \n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\n\t\t\t\t\t  TWL4030_BCIMFKEY);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t\t  (reg & 0x100) ? 3 : 2,\n\t\t\t\t\t  TWL4030_BCIIREF2);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\t \n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\n\t\t\t\t\t  TWL4030_BCIMFKEY);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t\t  reg & 0xff,\n\t\t\t\t\t  TWL4030_BCIIREF1);\n\t}\n\tif ((!!cgain) != !!(bcictl1 & TWL4030_CGAIN)) {\n\t\t \n\t\tbcictl1 ^= TWL4030_CGAIN;\n\t\ttwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t bcictl1, TWL4030_BCICTL1);\n\t\ttwl4030_clear_set_boot_bci(0, boot_bci);\n\t}\n\treturn 0;\n}\n\nstatic int twl4030_charger_get_current(void);\n\nstatic void twl4030_current_worker(struct work_struct *data)\n{\n\tint v, curr;\n\tint res;\n\tstruct twl4030_bci *bci = container_of(data, struct twl4030_bci,\n\t\t\t\t\t       current_worker.work);\n\n\tres = twl4030bci_read_adc_val(TWL4030_BCIVBUS);\n\tif (res < 0)\n\t\tv = 0;\n\telse\n\t\t \n\t\tv = res * 6843;\n\tcurr = twl4030_charger_get_current();\n\n\tdev_dbg(bci->dev, \"v=%d cur=%d limit=%d target=%d\\n\", v, curr,\n\t\tbci->usb_cur, bci->usb_cur_target);\n\n\tif (v < USB_MIN_VOLT) {\n\t\t \n\t\tif (bci->usb_cur >= USB_CUR_STEP)\n\t\t\tbci->usb_cur -= USB_CUR_STEP;\n\t\tbci->usb_cur_target = bci->usb_cur;\n\t} else if (bci->usb_cur >= bci->usb_cur_target ||\n\t\t   bci->usb_cur + USB_CUR_STEP > USB_MAX_CURRENT) {\n\t\t \n\t\treturn;\n\t} else {\n\t\tbci->usb_cur += USB_CUR_STEP;\n\t\tschedule_delayed_work(&bci->current_worker, USB_CUR_DELAY);\n\t}\n\ttwl4030_charger_update_current(bci);\n}\n\n \nstatic int twl4030_charger_enable_usb(struct twl4030_bci *bci, bool enable)\n{\n\tint ret;\n\tu32 reg;\n\n\tif (bci->usb_mode == CHARGE_OFF)\n\t\tenable = false;\n\tif (enable && !IS_ERR_OR_NULL(bci->transceiver)) {\n\n\t\ttwl4030_charger_update_current(bci);\n\n\t\t \n\t\tif (!bci->usb_enabled) {\n\t\t\tpm_runtime_get_sync(bci->transceiver->dev);\n\t\t\tbci->usb_enabled = 1;\n\t\t}\n\n\t\tif (bci->usb_mode == CHARGE_AUTO) {\n\t\t\t \n\t\t\treg = ~(u32)(TWL4030_ICHGLOW | TWL4030_ICHGEOC |\n\t\t\t\t\tTWL4030_TBATOR2 | TWL4030_TBATOR1 |\n\t\t\t\t\tTWL4030_BATSTS);\n\t\t\tret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\n\t\t\t\t       TWL4030_INTERRUPTS_BCIIMR1A);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bci->dev,\n\t\t\t\t\t\"failed to unmask interrupts: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t \n\t\t\tret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOUSB);\n\t\t}\n\n\t\t \n\t\tret = twl4030_clear_set(TWL_MODULE_MAIN_CHARGE, 0,\n\t\t\tTWL4030_USBFASTMCHG, TWL4030_BCIMFSTS4);\n\t\tif (bci->usb_mode == CHARGE_LINEAR) {\n\t\t\t \n\t\t\treg = ~(u32)(TWL4030_ICHGLOW | TWL4030_TBATOR2 |\n\t\t\t\t\tTWL4030_TBATOR1 | TWL4030_BATSTS);\n\t\t\tret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\n\t\t\t\t       TWL4030_INTERRUPTS_BCIIMR1A);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bci->dev,\n\t\t\t\t\t\"failed to unmask interrupts: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\ttwl4030_clear_set_boot_bci(TWL4030_BCIAUTOAC|TWL4030_CVENAC, 0);\n\t\t\t \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x33,\n\t\t\t\t\t       TWL4030_BCIWDKEY);\n\t\t\t \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x2a,\n\t\t\t\t\t       TWL4030_BCIMDKEY);\n\t\t\t \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x26,\n\t\t\t\t\t       TWL4030_BCIMDKEY);\n\t\t\t \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xf3,\n\t\t\t\t\t       TWL4030_BCIWDKEY);\n\t\t\t \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x9c,\n\t\t\t\t\t       TWL4030_BCIMFKEY);\n\t\t\t  \n\t\t\tret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xf0,\n\t\t\t\t\t       TWL4030_BCIMFEN3);\n\t\t}\n\t} else {\n\t\tret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOUSB, 0);\n\t\tret |= twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x2a,\n\t\t\t\t\tTWL4030_BCIMDKEY);\n\t\tif (bci->usb_enabled) {\n\t\t\tpm_runtime_mark_last_busy(bci->transceiver->dev);\n\t\t\tpm_runtime_put_autosuspend(bci->transceiver->dev);\n\t\t\tbci->usb_enabled = 0;\n\t\t}\n\t\tbci->usb_cur = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int twl4030_charger_enable_ac(struct twl4030_bci *bci, bool enable)\n{\n\tint ret;\n\n\tif (bci->ac_mode == CHARGE_OFF)\n\t\tenable = false;\n\n\tif (enable)\n\t\tret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOAC);\n\telse\n\t\tret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOAC, 0);\n\n\treturn ret;\n}\n\n \nstatic int twl4030_charger_enable_backup(int uvolt, int uamp)\n{\n\tint ret;\n\tu8 flags;\n\n\tif (uvolt < 2500000 ||\n\t    uamp < 25) {\n\t\t \n\t\tret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\n\t\t\t\t\tTWL4030_BBCHEN, 0, TWL4030_BB_CFG);\n\t\treturn ret;\n\t}\n\n\tflags = TWL4030_BBCHEN;\n\tif (uvolt >= 3200000)\n\t\tflags |= TWL4030_BBSEL_3V2;\n\telse if (uvolt >= 3100000)\n\t\tflags |= TWL4030_BBSEL_3V1;\n\telse if (uvolt >= 3000000)\n\t\tflags |= TWL4030_BBSEL_3V0;\n\telse\n\t\tflags |= TWL4030_BBSEL_2V5;\n\n\tif (uamp >= 1000)\n\t\tflags |= TWL4030_BBISEL_1000uA;\n\telse if (uamp >= 500)\n\t\tflags |= TWL4030_BBISEL_500uA;\n\telse if (uamp >= 150)\n\t\tflags |= TWL4030_BBISEL_150uA;\n\telse\n\t\tflags |= TWL4030_BBISEL_25uA;\n\n\tret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\n\t\t\t\tTWL4030_BBSEL_MASK | TWL4030_BBISEL_MASK,\n\t\t\t\tflags,\n\t\t\t\tTWL4030_BB_CFG);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t twl4030_charger_interrupt(int irq, void *arg)\n{\n\tstruct twl4030_bci *bci = arg;\n\n\tdev_dbg(bci->dev, \"CHG_PRES irq\\n\");\n\t \n\tbci->ac_cur = 500000;\n\ttwl4030_charger_update_current(bci);\n\tpower_supply_changed(bci->ac);\n\tpower_supply_changed(bci->usb);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t twl4030_bci_interrupt(int irq, void *arg)\n{\n\tstruct twl4030_bci *bci = arg;\n\tu8 irqs1, irqs2;\n\tint ret;\n\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs1,\n\t\t\t      TWL4030_INTERRUPTS_BCIISR1A);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs2,\n\t\t\t      TWL4030_INTERRUPTS_BCIISR2A);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tdev_dbg(bci->dev, \"BCI irq %02x %02x\\n\", irqs2, irqs1);\n\n\tif (irqs1 & (TWL4030_ICHGLOW | TWL4030_ICHGEOC)) {\n\t\t \n\t\tpower_supply_changed(bci->ac);\n\t\tpower_supply_changed(bci->usb);\n\t}\n\ttwl4030_charger_update_current(bci);\n\n\t \n\tif (irqs1 & (TWL4030_TBATOR2 | TWL4030_TBATOR1))\n\t\tdev_warn(bci->dev, \"battery temperature out of range\\n\");\n\n\tif (irqs1 & TWL4030_BATSTS)\n\t\tdev_crit(bci->dev, \"battery disconnected\\n\");\n\n\tif (irqs2 & TWL4030_VBATOV)\n\t\tdev_crit(bci->dev, \"VBAT overvoltage\\n\");\n\n\tif (irqs2 & TWL4030_VBUSOV)\n\t\tdev_crit(bci->dev, \"VBUS overvoltage\\n\");\n\n\tif (irqs2 & TWL4030_ACCHGOV)\n\t\tdev_crit(bci->dev, \"Ac charger overvoltage\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void twl4030_bci_usb_work(struct work_struct *data)\n{\n\tstruct twl4030_bci *bci = container_of(data, struct twl4030_bci, work);\n\n\tswitch (bci->event) {\n\tcase USB_EVENT_VBUS:\n\tcase USB_EVENT_CHARGER:\n\t\ttwl4030_charger_enable_usb(bci, true);\n\t\tbreak;\n\tcase USB_EVENT_NONE:\n\t\ttwl4030_charger_enable_usb(bci, false);\n\t\tbreak;\n\t}\n}\n\nstatic int twl4030_bci_usb_ncb(struct notifier_block *nb, unsigned long val,\n\t\t\t       void *priv)\n{\n\tstruct twl4030_bci *bci = container_of(nb, struct twl4030_bci, usb_nb);\n\n\tdev_dbg(bci->dev, \"OTG notify %lu\\n\", val);\n\n\t \n\tif (allow_usb)\n\t\tbci->usb_cur_target = 500000;\n\telse\n\t\tbci->usb_cur_target = 100000;\n\n\tbci->event = val;\n\tschedule_work(&bci->work);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic ssize_t\ntwl4030_bci_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\n\tint mode;\n\tint status;\n\n\tmode = sysfs_match_string(modes, buf);\n\tif (mode < 0)\n\t\treturn mode;\n\n\tif (dev == &bci->ac->dev) {\n\t\tif (mode == 2)\n\t\t\treturn -EINVAL;\n\t\ttwl4030_charger_enable_ac(bci, false);\n\t\tbci->ac_mode = mode;\n\t\tstatus = twl4030_charger_enable_ac(bci, true);\n\t} else {\n\t\ttwl4030_charger_enable_usb(bci, false);\n\t\tbci->usb_mode = mode;\n\t\tstatus = twl4030_charger_enable_usb(bci, true);\n\t}\n\treturn (status == 0) ? n : status;\n}\n\n \nstatic ssize_t\ntwl4030_bci_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\n\tint len = 0;\n\tint i;\n\tint mode = bci->usb_mode;\n\n\tif (dev == &bci->ac->dev)\n\t\tmode = bci->ac_mode;\n\n\tfor (i = 0; i < ARRAY_SIZE(modes); i++)\n\t\tif (mode == i)\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] \", modes[i]);\n\t\telse\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", modes[i]);\n\tbuf[len-1] = '\\n';\n\treturn len;\n}\nstatic DEVICE_ATTR(mode, 0644, twl4030_bci_mode_show,\n\t\t   twl4030_bci_mode_store);\n\nstatic int twl4030_charger_get_current(void)\n{\n\tint curr;\n\tint ret;\n\tu8 bcictl1;\n\n\tcurr = twl4030bci_read_adc_val(TWL4030_BCIICHG);\n\tif (curr < 0)\n\t\treturn curr;\n\n\tret = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regval2ua(curr, bcictl1 & TWL4030_CGAIN);\n}\n\n \nstatic int twl4030bci_state(struct twl4030_bci *bci)\n{\n\tint ret;\n\tu8 state;\n\n\tret = twl4030_bci_read(TWL4030_BCIMSTATEC, &state);\n\tif (ret) {\n\t\tdev_err(bci->dev, \"error reading BCIMSTATEC\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(bci->dev, \"state: %02x\\n\", state);\n\n\treturn state;\n}\n\nstatic int twl4030_bci_state_to_status(int state)\n{\n\tstate &= TWL4030_MSTATEC_MASK;\n\tif (TWL4030_MSTATEC_QUICK1 <= state && state <= TWL4030_MSTATEC_QUICK7)\n\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\telse if (TWL4030_MSTATEC_COMPLETE1 <= state &&\n\t\t\t\t\tstate <= TWL4030_MSTATEC_COMPLETE4)\n\t\treturn POWER_SUPPLY_STATUS_FULL;\n\telse\n\t\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n}\n\nstatic int twl4030_bci_get_property(struct power_supply *psy,\n\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tstruct twl4030_bci *bci = dev_get_drvdata(psy->dev.parent);\n\tint is_charging;\n\tint state;\n\tint ret;\n\n\tstate = twl4030bci_state(bci);\n\tif (state < 0)\n\t\treturn state;\n\n\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\tis_charging = state & TWL4030_MSTATEC_USB;\n\telse\n\t\tis_charging = state & TWL4030_MSTATEC_AC;\n\tif (!is_charging) {\n\t\tu8 s;\n\t\tret = twl4030_bci_read(TWL4030_BCIMDEN, &s);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\t\tis_charging = s & 1;\n\t\telse\n\t\t\tis_charging = s & 2;\n\t\tif (is_charging)\n\t\t\t \n\t\t\tstate = TWL4030_MSTATEC_QUICK1;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (is_charging)\n\t\t\tval->intval = twl4030_bci_state_to_status(state);\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t \n\t\tif (!is_charging)\n\t\t\treturn -ENODATA;\n\t\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB) {\n\t\t\tret = twl4030bci_read_adc_val(TWL4030_BCIVBUS);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tval->intval = ret * 6843;\n\t\t} else {\n\t\t\tret = twl4030bci_read_adc_val(TWL4030_BCIVAC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tval->intval = ret * 9775;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (!is_charging)\n\t\t\treturn -ENODATA;\n\t\t \n\t\tret = twl4030_charger_get_current();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = is_charging &&\n\t\t\ttwl4030_bci_state_to_status(state) !=\n\t\t\t\tPOWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tval->intval = -1;\n\t\tif (psy->desc->type != POWER_SUPPLY_TYPE_USB) {\n\t\t\tif (!bci->ac_is_active)\n\t\t\t\tval->intval = bci->ac_cur;\n\t\t} else {\n\t\t\tif (bci->ac_is_active)\n\t\t\t\tval->intval = bci->usb_cur_target;\n\t\t}\n\t\tif (val->intval < 0) {\n\t\t\tu8 bcictl1;\n\n\t\t\tval->intval = twl4030bci_read_adc_val(TWL4030_BCIIREF1);\n\t\t\tif (val->intval < 0)\n\t\t\t\treturn val->intval;\n\t\t\tret = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tval->intval = regval2ua(val->intval, bcictl1 &\n\t\t\t\t\t\t\tTWL4030_CGAIN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_bci_set_property(struct power_supply *psy,\n\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t    const union power_supply_propval *val)\n{\n\tstruct twl4030_bci *bci = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\t\tbci->usb_cur_target = val->intval;\n\t\telse\n\t\t\tbci->ac_cur = val->intval;\n\t\ttwl4030_charger_update_current(bci);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_bci_property_is_writeable(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum power_supply_property twl4030_charger_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n};\n\n#ifdef CONFIG_OF\nstatic const struct twl4030_bci_platform_data *\ntwl4030_bci_parse_dt(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct twl4030_bci_platform_data *pdata;\n\tu32 num;\n\n\tif (!np)\n\t\treturn NULL;\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn pdata;\n\n\tif (of_property_read_u32(np, \"ti,bb-uvolt\", &num) == 0)\n\t\tpdata->bb_uvolt = num;\n\tif (of_property_read_u32(np, \"ti,bb-uamp\", &num) == 0)\n\t\tpdata->bb_uamp = num;\n\treturn pdata;\n}\n#else\nstatic inline const struct twl4030_bci_platform_data *\ntwl4030_bci_parse_dt(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic const struct power_supply_desc twl4030_bci_ac_desc = {\n\t.name\t\t= \"twl4030_ac\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= twl4030_charger_props,\n\t.num_properties\t= ARRAY_SIZE(twl4030_charger_props),\n\t.get_property\t= twl4030_bci_get_property,\n\t.set_property\t= twl4030_bci_set_property,\n\t.property_is_writeable\t= twl4030_bci_property_is_writeable,\n};\n\nstatic const struct power_supply_desc twl4030_bci_usb_desc = {\n\t.name\t\t= \"twl4030_usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t= twl4030_charger_props,\n\t.num_properties\t= ARRAY_SIZE(twl4030_charger_props),\n\t.get_property\t= twl4030_bci_get_property,\n\t.set_property\t= twl4030_bci_set_property,\n\t.property_is_writeable\t= twl4030_bci_property_is_writeable,\n};\n\nstatic int twl4030_bci_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_bci *bci;\n\tconst struct twl4030_bci_platform_data *pdata = pdev->dev.platform_data;\n\tint ret;\n\tu32 reg;\n\n\tbci = devm_kzalloc(&pdev->dev, sizeof(*bci), GFP_KERNEL);\n\tif (bci == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!pdata)\n\t\tpdata = twl4030_bci_parse_dt(&pdev->dev);\n\n\tbci->ichg_eoc = 80100;  \n\tbci->ichg_lo = 241000;  \n\tbci->ichg_hi = 500000;  \n\tbci->ac_cur = 500000;  \n\tif (allow_usb)\n\t\tbci->usb_cur_target = 500000;   \n\telse\n\t\tbci->usb_cur_target = 100000;   \n\tbci->usb_mode = CHARGE_AUTO;\n\tbci->ac_mode = CHARGE_AUTO;\n\n\tbci->dev = &pdev->dev;\n\tbci->irq_chg = platform_get_irq(pdev, 0);\n\tbci->irq_bci = platform_get_irq(pdev, 1);\n\n\tplatform_set_drvdata(pdev, bci);\n\n\tINIT_WORK(&bci->work, twl4030_bci_usb_work);\n\tINIT_DELAYED_WORK(&bci->current_worker, twl4030_current_worker);\n\n\tbci->channel_vac = devm_iio_channel_get(&pdev->dev, \"vac\");\n\tif (IS_ERR(bci->channel_vac)) {\n\t\tret = PTR_ERR(bci->channel_vac);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\t \n\t\tdev_warn(&pdev->dev, \"could not request vac iio channel (%d)\",\n\t\t\tret);\n\t\tbci->channel_vac = NULL;\n\t}\n\n\tif (bci->dev->of_node) {\n\t\tstruct device_node *phynode;\n\n\t\tphynode = of_get_compatible_child(bci->dev->of_node->parent,\n\t\t\t\t\t\t  \"ti,twl4030-usb\");\n\t\tif (phynode) {\n\t\t\tbci->usb_nb.notifier_call = twl4030_bci_usb_ncb;\n\t\t\tbci->transceiver = devm_usb_get_phy_by_node(\n\t\t\t\tbci->dev, phynode, &bci->usb_nb);\n\t\t\tof_node_put(phynode);\n\t\t\tif (IS_ERR(bci->transceiver)) {\n\t\t\t\tret = PTR_ERR(bci->transceiver);\n\t\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\t\treturn ret;\t \n\t\t\t\tdev_warn(&pdev->dev, \"could not request transceiver (%d)\",\n\t\t\t\t\tret);\n\t\t\t\tbci->transceiver = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbci->ac = devm_power_supply_register(&pdev->dev, &twl4030_bci_ac_desc,\n\t\t\t\t\t     NULL);\n\tif (IS_ERR(bci->ac)) {\n\t\tret = PTR_ERR(bci->ac);\n\t\tdev_err(&pdev->dev, \"failed to register ac: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbci->usb = devm_power_supply_register(&pdev->dev, &twl4030_bci_usb_desc,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(bci->usb)) {\n\t\tret = PTR_ERR(bci->usb);\n\t\tdev_err(&pdev->dev, \"failed to register usb: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, bci->irq_chg, NULL,\n\t\t\ttwl4030_charger_interrupt, IRQF_ONESHOT, pdev->name,\n\t\t\tbci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not request irq %d, status %d\\n\",\n\t\t\tbci->irq_chg, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, bci->irq_bci, NULL,\n\t\t\ttwl4030_bci_interrupt, IRQF_ONESHOT, pdev->name, bci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not request irq %d, status %d\\n\",\n\t\t\tbci->irq_bci, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg = ~(u32)(TWL4030_ICHGLOW | TWL4030_ICHGEOC | TWL4030_TBATOR2 |\n\t\tTWL4030_TBATOR1 | TWL4030_BATSTS);\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\n\t\t\t       TWL4030_INTERRUPTS_BCIIMR1A);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to unmask interrupts: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treg = ~(u32)(TWL4030_VBATOV | TWL4030_VBUSOV | TWL4030_ACCHGOV);\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\n\t\t\t       TWL4030_INTERRUPTS_BCIIMR2A);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"failed to unmask interrupts: %d\\n\", ret);\n\n\ttwl4030_charger_update_current(bci);\n\tif (device_create_file(&bci->usb->dev, &dev_attr_mode))\n\t\tdev_warn(&pdev->dev, \"could not create sysfs file\\n\");\n\tif (device_create_file(&bci->ac->dev, &dev_attr_mode))\n\t\tdev_warn(&pdev->dev, \"could not create sysfs file\\n\");\n\n\ttwl4030_charger_enable_ac(bci, true);\n\tif (!IS_ERR_OR_NULL(bci->transceiver))\n\t\ttwl4030_bci_usb_ncb(&bci->usb_nb,\n\t\t\t\t    bci->transceiver->last_event,\n\t\t\t\t    NULL);\n\telse\n\t\ttwl4030_charger_enable_usb(bci, false);\n\tif (pdata)\n\t\ttwl4030_charger_enable_backup(pdata->bb_uvolt,\n\t\t\t\t\t      pdata->bb_uamp);\n\telse\n\t\ttwl4030_charger_enable_backup(0, 0);\n\n\treturn 0;\n}\n\nstatic int twl4030_bci_remove(struct platform_device *pdev)\n{\n\tstruct twl4030_bci *bci = platform_get_drvdata(pdev);\n\n\ttwl4030_charger_enable_ac(bci, false);\n\ttwl4030_charger_enable_usb(bci, false);\n\ttwl4030_charger_enable_backup(0, 0);\n\n\tdevice_remove_file(&bci->usb->dev, &dev_attr_mode);\n\tdevice_remove_file(&bci->ac->dev, &dev_attr_mode);\n\t \n\ttwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\n\t\t\t TWL4030_INTERRUPTS_BCIIMR1A);\n\ttwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\n\t\t\t TWL4030_INTERRUPTS_BCIIMR2A);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id twl_bci_of_match[] __maybe_unused = {\n\t{.compatible = \"ti,twl4030-bci\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, twl_bci_of_match);\n\nstatic struct platform_driver twl4030_bci_driver = {\n\t.probe = twl4030_bci_probe,\n\t.remove\t= twl4030_bci_remove,\n\t.driver\t= {\n\t\t.name\t= \"twl4030_bci\",\n\t\t.of_match_table = of_match_ptr(twl_bci_of_match),\n\t},\n};\nmodule_platform_driver(twl4030_bci_driver);\n\nMODULE_AUTHOR(\"Gra\u017evydas Ignotas\");\nMODULE_DESCRIPTION(\"TWL4030 Battery Charger Interface driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:twl4030_bci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}