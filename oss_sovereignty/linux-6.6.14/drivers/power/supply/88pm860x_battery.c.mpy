{
  "module_name": "88pm860x_battery.c",
  "hash_id": "ca939dc03d6f4afd88a57e4fbafea754fde86f508d4ed26252d1c152255cf994",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/88pm860x_battery.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/power_supply.h>\n#include <linux/mfd/88pm860x.h>\n#include <linux/delay.h>\n\n \n#define STATUS2_CHG\t\t\t(1 << 2)\n#define STATUS2_BAT\t\t\t(1 << 3)\n#define STATUS2_VBUS\t\t\t(1 << 4)\n\n \n#define MEAS1_TINT\t\t\t(1 << 3)\n#define MEAS1_GP1\t\t\t(1 << 5)\n\n \n#define MEAS3_IBAT\t\t\t(1 << 0)\n#define MEAS3_BAT_DET\t\t\t(1 << 1)\n#define MEAS3_CC\t\t\t(1 << 2)\n\n \n#define MEAS_OFF_SLEEP_EN\t\t(1 << 1)\n\n \n#define GPBIAS2_GPADC1_SET\t\t(2 << 4)\n \n#define GPBIAS2_GPADC1_UA\t\t((GPBIAS2_GPADC1_SET >> 4) * 5 + 1)\n\n \n#define GPMISC1_GPADC_EN\t\t(1 << 0)\n\n \n#define CC6_BAT_DET_GPADC1\t\t1\n\n \n#define CCNT_AVG_SEL\t\t\t(4 << 3)\n\n \n#define RTC_SOC_5LSB\t\t(0x1F << 3)\n\n \n#define RTC_SOC_3MSB\t\t(0x7)\n\n \n#define BAT_WU_LOG\t\t\t(1<<6)\n\n \n#define CCNT_POS1\t\t\t0\n#define CCNT_POS2\t\t\t1\n#define CCNT_NEG1\t\t\t2\n#define CCNT_NEG2\t\t\t3\n#define CCNT_SPOS\t\t\t4\n#define CCNT_SNEG\t\t\t5\n\n \n#define OCV_MODE_ACTIVE\t\t\t0\n#define OCV_MODE_SLEEP\t\t\t1\n\n \n#define LOW_BAT_THRESHOLD\t\t3600\n#define VBATT_RESISTOR_MIN\t\t3800\n#define VBATT_RESISTOR_MAX\t\t4100\n\n \n#define PM860X_TEMP_TINT\t\t(0)\n#define PM860X_TEMP_TBAT\t\t(1)\n\n \n#define TBAT_NEG_25D\t\t127773\t \n#define TBAT_NEG_10D\t\t54564\t \n#define TBAT_0D\t\t\t32330\t \n#define TBAT_10D\t\t19785\t \n#define TBAT_20D\t\t12468\t \n#define TBAT_30D\t\t8072\t \n#define TBAT_40D\t\t5356\t \n\nstruct pm860x_battery_info {\n\tstruct pm860x_chip *chip;\n\tstruct i2c_client *i2c;\n\tstruct device *dev;\n\n\tstruct power_supply *battery;\n\tstruct mutex lock;\n\tint status;\n\tint irq_cc;\n\tint irq_batt;\n\tint max_capacity;\n\tint resistor;\t\t \n\tint last_capacity;\n\tint start_soc;\n\tunsigned present:1;\n\tunsigned temp_type:1;\t \n};\n\nstruct ccnt {\n\tunsigned long long pos;\n\tunsigned long long neg;\n\tunsigned int spos;\n\tunsigned int sneg;\n\n\tint total_chg;\t\t \n\tint total_dischg;\t \n};\n\n \nstatic int array_soc[][2] = {\n\t{4170, 100}, {4154, 99}, {4136, 98}, {4122, 97}, {4107, 96},\n\t{4102, 95}, {4088, 94}, {4081, 93}, {4070, 92}, {4060, 91},\n\t{4053, 90}, {4044, 89}, {4035, 88}, {4028, 87}, {4019, 86},\n\t{4013, 85}, {4006, 84}, {3995, 83}, {3987, 82}, {3982, 81},\n\t{3976, 80}, {3968, 79}, {3962, 78}, {3954, 77}, {3946, 76},\n\t{3941, 75}, {3934, 74}, {3929, 73}, {3922, 72}, {3916, 71},\n\t{3910, 70}, {3904, 69}, {3898, 68}, {3892, 67}, {3887, 66},\n\t{3880, 65}, {3874, 64}, {3868, 63}, {3862, 62}, {3854, 61},\n\t{3849, 60}, {3843, 59}, {3840, 58}, {3833, 57}, {3829, 56},\n\t{3824, 55}, {3818, 54}, {3815, 53}, {3810, 52}, {3808, 51},\n\t{3804, 50}, {3801, 49}, {3798, 48}, {3796, 47}, {3792, 46},\n\t{3789, 45}, {3785, 44}, {3784, 43}, {3782, 42}, {3780, 41},\n\t{3777, 40}, {3776, 39}, {3774, 38}, {3772, 37}, {3771, 36},\n\t{3769, 35}, {3768, 34}, {3764, 33}, {3763, 32}, {3760, 31},\n\t{3760, 30}, {3754, 29}, {3750, 28}, {3749, 27}, {3744, 26},\n\t{3740, 25}, {3734, 24}, {3732, 23}, {3728, 22}, {3726, 21},\n\t{3720, 20}, {3716, 19}, {3709, 18}, {3703, 17}, {3698, 16},\n\t{3692, 15}, {3683, 14}, {3675, 13}, {3670, 12}, {3665, 11},\n\t{3661, 10}, {3649, 9}, {3637, 8}, {3622, 7}, {3609, 6},\n\t{3580, 5}, {3558, 4}, {3540, 3}, {3510, 2}, {3429, 1},\n};\n\nstatic struct ccnt ccnt_data;\n\n \nstatic int measure_12bit_voltage(struct pm860x_battery_info *info,\n\t\t\t\t int offset, int *data)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = pm860x_bulk_read(info->i2c, offset, 2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = ((buf[0] & 0xff) << 4) | (buf[1] & 0x0f);\n\t \n\t*data = ((*data & 0xfff) * 9 * 25) >> 9;\n\treturn 0;\n}\n\nstatic int measure_vbatt(struct pm860x_battery_info *info, int state,\n\t\t\t int *data)\n{\n\tunsigned char buf[5];\n\tint ret;\n\n\tswitch (state) {\n\tcase OCV_MODE_ACTIVE:\n\t\tret = measure_12bit_voltage(info, PM8607_VBAT_MEAS1, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\t*data *= 3;\n\t\tbreak;\n\tcase OCV_MODE_SLEEP:\n\t\t \n\t\tret = pm860x_bulk_read(info->i2c, PM8607_LDO5, 5, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ((buf[4] >> 6) << 10) | ((buf[3] >> 6) << 8)\n\t\t    | ((buf[2] >> 6) << 6) | ((buf[1] >> 6) << 4)\n\t\t    | (buf[0] >> 4);\n\t\t \n\t\t*data = ((*data & 0xff) * 27 * 25) >> 9;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int measure_current(struct pm860x_battery_info *info, int *data)\n{\n\tunsigned char buf[2];\n\tshort s;\n\tint ret;\n\n\tret = pm860x_bulk_read(info->i2c, PM8607_IBAT_MEAS1, 2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts = ((buf[0] & 0xff) << 8) | (buf[1] & 0xff);\n\t \n\t*data = s >> 3;\n\treturn 0;\n}\n\nstatic int set_charger_current(struct pm860x_battery_info *info, int data,\n\t\t\t       int *old)\n{\n\tint ret;\n\n\tif (data < 50 || data > 1600 || !old)\n\t\treturn -EINVAL;\n\n\tdata = ((data - 50) / 50) & 0x1f;\n\t*old = pm860x_reg_read(info->i2c, PM8607_CHG_CTRL2);\n\t*old = (*old & 0x1f) * 50 + 50;\n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL2, 0x1f, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int read_ccnt(struct pm860x_battery_info *info, int offset,\n\t\t     int *ccnt)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = pm860x_set_bits(info->i2c, PM8607_CCNT, 7, offset & 7);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = pm860x_bulk_read(info->i2c, PM8607_CCNT_MEAS1, 2, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\t*ccnt = ((buf[0] & 0xff) << 8) | (buf[1] & 0xff);\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int calc_ccnt(struct pm860x_battery_info *info, struct ccnt *ccnt)\n{\n\tunsigned int sum;\n\tint ret;\n\tint data;\n\n\tret = read_ccnt(info, CCNT_POS1, &data);\n\tif (ret)\n\t\tgoto out;\n\tsum = data & 0xffff;\n\tret = read_ccnt(info, CCNT_POS2, &data);\n\tif (ret)\n\t\tgoto out;\n\tsum |= (data & 0xffff) << 16;\n\tccnt->pos += sum;\n\n\tret = read_ccnt(info, CCNT_NEG1, &data);\n\tif (ret)\n\t\tgoto out;\n\tsum = data & 0xffff;\n\tret = read_ccnt(info, CCNT_NEG2, &data);\n\tif (ret)\n\t\tgoto out;\n\tsum |= (data & 0xffff) << 16;\n\tsum = ~sum + 1;\t\t \n\tccnt->neg += sum;\n\n\tret = read_ccnt(info, CCNT_SPOS, &data);\n\tif (ret)\n\t\tgoto out;\n\tccnt->spos += data;\n\tret = read_ccnt(info, CCNT_SNEG, &data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tccnt->total_chg = (int) ((ccnt->pos * 18236) >> 40);\n\tccnt->total_dischg = (int) ((ccnt->neg * 18236) >> 40);\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int clear_ccnt(struct pm860x_battery_info *info, struct ccnt *ccnt)\n{\n\tint data;\n\n\tmemset(ccnt, 0, sizeof(*ccnt));\n\t \n\tread_ccnt(info, CCNT_POS1, &data);\n\tread_ccnt(info, CCNT_POS2, &data);\n\tread_ccnt(info, CCNT_NEG1, &data);\n\tread_ccnt(info, CCNT_NEG2, &data);\n\tread_ccnt(info, CCNT_SPOS, &data);\n\tread_ccnt(info, CCNT_SNEG, &data);\n\treturn 0;\n}\n\n \nstatic int calc_ocv(struct pm860x_battery_info *info, int *ocv)\n{\n\tint ret;\n\tint i;\n\tint data;\n\tint vbatt_avg;\n\tint vbatt_sum;\n\tint ibatt_avg;\n\tint ibatt_sum;\n\n\tif (!ocv)\n\t\treturn -EINVAL;\n\n\tfor (i = 0, ibatt_sum = 0, vbatt_sum = 0; i < 10; i++) {\n\t\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tvbatt_sum += data;\n\t\tret = measure_current(info, &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tibatt_sum += data;\n\t}\n\tvbatt_avg = vbatt_sum / 10;\n\tibatt_avg = ibatt_sum / 10;\n\n\tmutex_lock(&info->lock);\n\tif (info->present)\n\t\t*ocv = vbatt_avg - ibatt_avg * info->resistor / 1000;\n\telse\n\t\t*ocv = vbatt_avg;\n\tmutex_unlock(&info->lock);\n\tdev_dbg(info->dev, \"VBAT average:%d, OCV:%d\\n\", vbatt_avg, *ocv);\n\treturn 0;\nout:\n\treturn ret;\n}\n\n \nstatic int calc_soc(struct pm860x_battery_info *info, int state, int *soc)\n{\n\tint i;\n\tint ocv;\n\tint count;\n\tint ret = -EINVAL;\n\n\tif (!soc)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase OCV_MODE_ACTIVE:\n\t\tret = calc_ocv(info, &ocv);\n\t\tbreak;\n\tcase OCV_MODE_SLEEP:\n\t\tret = measure_vbatt(info, OCV_MODE_SLEEP, &ocv);\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tcount = ARRAY_SIZE(array_soc);\n\tif (ocv < array_soc[count - 1][0]) {\n\t\t*soc = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (ocv >= array_soc[i][0]) {\n\t\t\t*soc = array_soc[i][1];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t pm860x_coulomb_handler(int irq, void *data)\n{\n\tstruct pm860x_battery_info *info = data;\n\n\tcalc_ccnt(info, &ccnt_data);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm860x_batt_handler(int irq, void *data)\n{\n\tstruct pm860x_battery_info *info = data;\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\tret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\n\tif (ret & STATUS2_BAT) {\n\t\tinfo->present = 1;\n\t\tinfo->temp_type = PM860X_TEMP_TBAT;\n\t} else {\n\t\tinfo->present = 0;\n\t\tinfo->temp_type = PM860X_TEMP_TINT;\n\t}\n\tmutex_unlock(&info->lock);\n\t \n\tclear_ccnt(info, &ccnt_data);\n\treturn IRQ_HANDLED;\n}\n\nstatic void pm860x_init_battery(struct pm860x_battery_info *info)\n{\n\tunsigned char buf[2];\n\tint ret;\n\tint data;\n\tint bat_remove;\n\tint soc = 0;\n\n\t \n\tdata = MEAS1_GP1;\n\tif (info->temp_type == PM860X_TEMP_TINT)\n\t\tdata |= MEAS1_TINT;\n\tret = pm860x_set_bits(info->i2c, PM8607_MEAS_EN1, data, data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tdata = MEAS3_IBAT | MEAS3_BAT_DET | MEAS3_CC;\n\tret = pm860x_set_bits(info->i2c, PM8607_MEAS_EN3, data, data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = pm860x_reg_write(info->i2c, PM8607_MEAS_OFF_TIME1, 0x82);\n\tif (ret)\n\t\tgoto out;\n\tret = pm860x_reg_write(info->i2c, PM8607_MEAS_OFF_TIME2, 0x6c);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_GPADC_MISC1,\n\t\t\t    GPMISC1_GPADC_EN, GPMISC1_GPADC_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_CHG_CTRL6,\n\t\t\t    CC6_BAT_DET_GPADC1, CC6_BAT_DET_GPADC1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = pm860x_set_bits(info->i2c, PM8607_CCNT, 7 << 3,\n\t\t\t      CCNT_AVG_SEL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = pm860x_set_bits(info->i2c, PM8607_GP_BIAS2, 0xF << 4,\n\t\t\t      GPBIAS2_GPADC1_SET);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tmutex_lock(&info->lock);\n\tret = pm860x_reg_read(info->i2c, PM8607_STATUS_2);\n\tif (ret < 0) {\n\t\tmutex_unlock(&info->lock);\n\t\tgoto out;\n\t}\n\tif (ret & STATUS2_BAT) {\n\t\tinfo->present = 1;\n\t\tinfo->temp_type = PM860X_TEMP_TBAT;\n\t} else {\n\t\tinfo->present = 0;\n\t\tinfo->temp_type = PM860X_TEMP_TINT;\n\t}\n\tmutex_unlock(&info->lock);\n\n\tret = calc_soc(info, OCV_MODE_ACTIVE, &soc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata = pm860x_reg_read(info->i2c, PM8607_POWER_UP_LOG);\n\tbat_remove = data & BAT_WU_LOG;\n\n\tdev_dbg(info->dev, \"battery wake up? %s\\n\",\n\t\tbat_remove != 0 ? \"yes\" : \"no\");\n\n\t \n\tif (bat_remove == 0) {\n\t\tbuf[0] = pm860x_reg_read(info->i2c, PM8607_RTC_MISC2);\n\t\tbuf[1] = pm860x_reg_read(info->i2c, PM8607_RTC1);\n\t\tdata = ((buf[1] & 0x3) << 5) | ((buf[0] >> 3) & 0x1F);\n\t\tif (data > soc + 15)\n\t\t\tinfo->start_soc = soc;\n\t\telse if (data < soc - 15)\n\t\t\tinfo->start_soc = soc;\n\t\telse\n\t\t\tinfo->start_soc = data;\n\t\tdev_dbg(info->dev, \"soc_rtc %d, soc_ocv :%d\\n\", data, soc);\n\t} else {\n\t\tpm860x_set_bits(info->i2c, PM8607_POWER_UP_LOG,\n\t\t\t\tBAT_WU_LOG, BAT_WU_LOG);\n\t\tinfo->start_soc = soc;\n\t}\n\tinfo->last_capacity = info->start_soc;\n\tdev_dbg(info->dev, \"init soc : %d\\n\", info->last_capacity);\nout:\n\treturn;\n}\n\nstatic void set_temp_threshold(struct pm860x_battery_info *info,\n\t\t\t       int min, int max)\n{\n\tint data;\n\n\t \n\tif (min <= 0)\n\t\tdata = 0;\n\telse\n\t\tdata = (min << 8) / 1800;\n\tpm860x_reg_write(info->i2c, PM8607_GPADC1_HIGHTH, data);\n\tdev_dbg(info->dev, \"TEMP_HIGHTH : min: %d, 0x%x\\n\", min, data);\n\n\tif (max <= 0)\n\t\tdata = 0xff;\n\telse\n\t\tdata = (max << 8) / 1800;\n\tpm860x_reg_write(info->i2c, PM8607_GPADC1_LOWTH, data);\n\tdev_dbg(info->dev, \"TEMP_LOWTH:max : %d, 0x%x\\n\", max, data);\n}\n\nstatic int measure_temp(struct pm860x_battery_info *info, int *data)\n{\n\tint ret;\n\tint temp;\n\tint min;\n\tint max;\n\n\tif (info->temp_type == PM860X_TEMP_TINT) {\n\t\tret = measure_12bit_voltage(info, PM8607_TINT_MEAS1, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*data = (*data - 884) * 1000 / 3611;\n\t} else {\n\t\tret = measure_12bit_voltage(info, PM8607_GPADC1_MEAS1, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\t*data = (*data * 1000) / GPBIAS2_GPADC1_UA;\n\n\t\tif (*data > TBAT_NEG_25D) {\n\t\t\ttemp = -30;\t \n\t\t\tmax = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, 0, max);\n\t\t} else if (*data > TBAT_NEG_10D) {\n\t\t\ttemp = -15;\t \n\t\t\tmax = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, 0, max);\n\t\t} else if (*data > TBAT_0D) {\n\t\t\ttemp = -5;\t \n\t\t\tmin = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tmax = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, max);\n\t\t} else if (*data > TBAT_10D) {\n\t\t\ttemp = 5;\t \n\t\t\tmin = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tmax = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, max);\n\t\t} else if (*data > TBAT_20D) {\n\t\t\ttemp = 15;\t \n\t\t\tmin = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tmax = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, max);\n\t\t} else if (*data > TBAT_30D) {\n\t\t\ttemp = 25;\t \n\t\t\tmin = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tmax = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, max);\n\t\t} else if (*data > TBAT_40D) {\n\t\t\ttemp = 35;\t \n\t\t\tmin = TBAT_NEG_10D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tmax = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, max);\n\t\t} else {\n\t\t\tmin = TBAT_40D * GPBIAS2_GPADC1_UA / 1000;\n\t\t\tset_temp_threshold(info, min, 0);\n\t\t\ttemp = 45;\t \n\t\t}\n\n\t\tdev_dbg(info->dev, \"temp_C:%d C,temp_mv:%d mv\\n\", temp, *data);\n\t\t*data = temp;\n\t}\n\treturn 0;\n}\n\nstatic int calc_resistor(struct pm860x_battery_info *info)\n{\n\tint vbatt_sum1;\n\tint vbatt_sum2;\n\tint chg_current;\n\tint ibatt_sum1;\n\tint ibatt_sum2;\n\tint data;\n\tint ret;\n\tint i;\n\n\tret = measure_current(info, &data);\n\t \n\tif (ret || data < 0)\n\t\tgoto out;\n\n\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\tif (ret)\n\t\tgoto out;\n\t \n\tif (data < VBATT_RESISTOR_MIN || data > VBATT_RESISTOR_MAX)\n\t\tgoto out;\n\n\t \n\tif (set_charger_current(info, 500, &chg_current))\n\t\tgoto out;\n\n\t \n\tmsleep(500);\n\n\tfor (i = 0, vbatt_sum1 = 0, ibatt_sum1 = 0; i < 10; i++) {\n\t\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\t\tif (ret)\n\t\t\tgoto out_meas;\n\t\tvbatt_sum1 += data;\n\t\tret = measure_current(info, &data);\n\t\tif (ret)\n\t\t\tgoto out_meas;\n\n\t\tif (data < 0)\n\t\t\tibatt_sum1 = ibatt_sum1 - data;\t \n\t\telse\n\t\t\tibatt_sum1 = ibatt_sum1 + data;\t \n\t}\n\n\tif (set_charger_current(info, 100, &ret))\n\t\tgoto out_meas;\n\t \n\tmsleep(500);\n\n\tfor (i = 0, vbatt_sum2 = 0, ibatt_sum2 = 0; i < 10; i++) {\n\t\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\t\tif (ret)\n\t\t\tgoto out_meas;\n\t\tvbatt_sum2 += data;\n\t\tret = measure_current(info, &data);\n\t\tif (ret)\n\t\t\tgoto out_meas;\n\n\t\tif (data < 0)\n\t\t\tibatt_sum2 = ibatt_sum2 - data;\t \n\t\telse\n\t\t\tibatt_sum2 = ibatt_sum2 + data;\t \n\t}\n\n\t \n\tif (set_charger_current(info, chg_current, &ret))\n\t\tgoto out_meas;\n\n\tif ((vbatt_sum1 > vbatt_sum2) && (ibatt_sum1 > ibatt_sum2) &&\n\t\t\t(ibatt_sum2 > 0)) {\n\t\t \n\t\tdata = 1000 * (vbatt_sum1 - vbatt_sum2)\n\t\t    / (ibatt_sum1 - ibatt_sum2);\n\t\tif ((data - info->resistor > 0) &&\n\t\t\t\t(data - info->resistor < info->resistor))\n\t\t\tinfo->resistor = data;\n\t\tif ((info->resistor - data > 0) &&\n\t\t\t\t(info->resistor - data < data))\n\t\t\tinfo->resistor = data;\n\t}\n\treturn 0;\n\nout_meas:\n\tset_charger_current(info, chg_current, &ret);\nout:\n\treturn -EINVAL;\n}\n\nstatic int calc_capacity(struct pm860x_battery_info *info, int *cap)\n{\n\tint ret;\n\tint data;\n\tint ibat;\n\tint cap_ocv = 0;\n\tint cap_cc = 0;\n\n\tret = calc_ccnt(info, &ccnt_data);\n\tif (ret)\n\t\tgoto out;\nsoc:\n\tdata = info->max_capacity * info->start_soc / 100;\n\tif (ccnt_data.total_dischg - ccnt_data.total_chg <= data) {\n\t\tcap_cc =\n\t\t    data + ccnt_data.total_chg - ccnt_data.total_dischg;\n\t} else {\n\t\tclear_ccnt(info, &ccnt_data);\n\t\tcalc_soc(info, OCV_MODE_ACTIVE, &info->start_soc);\n\t\tdev_dbg(info->dev, \"restart soc = %d !\\n\",\n\t\t\tinfo->start_soc);\n\t\tgoto soc;\n\t}\n\n\tcap_cc = cap_cc * 100 / info->max_capacity;\n\tif (cap_cc < 0)\n\t\tcap_cc = 0;\n\telse if (cap_cc > 100)\n\t\tcap_cc = 100;\n\n\tdev_dbg(info->dev, \"%s, last cap : %d\", __func__,\n\t\tinfo->last_capacity);\n\n\tret = measure_current(info, &ibat);\n\tif (ret)\n\t\tgoto out;\n\t \n\tif (ibat < 0) {\n\t\tret = calc_soc(info, OCV_MODE_ACTIVE, &cap_ocv);\n\t\tif (ret)\n\t\t\tcap_ocv = info->last_capacity;\n\t\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (data <= LOW_BAT_THRESHOLD) {\n\t\t\t \n\t\t\t*cap = min(cap_ocv, cap_cc);\n\t\t} else {\n\t\t\t \n\t\t\tif (cap_cc < 15 && cap_ocv - cap_cc > 10)\n\t\t\t\t*cap = cap_ocv;\n\t\t\telse\n\t\t\t\t*cap = cap_cc;\n\t\t}\n\t\t \n\t\tif (*cap > info->last_capacity)\n\t\t\t*cap = info->last_capacity;\n\t} else {\n\t\t*cap = cap_cc;\n\t}\n\tinfo->last_capacity = *cap;\n\n\tdev_dbg(info->dev, \"%s, cap_ocv:%d cap_cc:%d, cap:%d\\n\",\n\t\t(ibat < 0) ? \"discharging\" : \"charging\",\n\t\t cap_ocv, cap_cc, *cap);\n\t \n\tpm860x_set_bits(info->i2c, PM8607_RTC_MISC2, RTC_SOC_5LSB,\n\t\t\t(*cap & 0x1F) << 3);\n\tpm860x_set_bits(info->i2c, PM8607_RTC1, RTC_SOC_3MSB,\n\t\t\t((*cap >> 5) & 0x3));\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic void pm860x_external_power_changed(struct power_supply *psy)\n{\n\tstruct pm860x_battery_info *info = dev_get_drvdata(psy->dev.parent);\n\n\tcalc_resistor(info);\n}\n\nstatic int pm860x_batt_get_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct pm860x_battery_info *info = dev_get_drvdata(psy->dev.parent);\n\tint data;\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = info->present;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = calc_capacity(info, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (data < 0)\n\t\t\tdata = 0;\n\t\telse if (data > 100)\n\t\t\tdata = 100;\n\t\t \n\t\tif (!info->present)\n\t\t\tdata = 100;\n\t\tval->intval = data;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t \n\t\tret = measure_vbatt(info, OCV_MODE_ACTIVE, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = data * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\t \n\t\tret = calc_ocv(info, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = data * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = measure_current(info, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval->intval = data;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tif (info->present) {\n\t\t\tret = measure_temp(info, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdata *= 10;\n\t\t} else {\n\t\t\t \n\t\t\tdata = 250;\n\t\t}\n\t\tval->intval = data;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int pm860x_batt_set_prop(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct pm860x_battery_info *info = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tclear_ccnt(info, &ccnt_data);\n\t\tinfo->start_soc = 100;\n\t\tdev_dbg(info->dev, \"chg done, update soc = %d\\n\",\n\t\t\tinfo->start_soc);\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\n\nstatic enum power_supply_property pm860x_batt_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic const struct power_supply_desc pm860x_battery_desc = {\n\t.name\t\t\t= \"battery-monitor\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= pm860x_batt_props,\n\t.num_properties\t\t= ARRAY_SIZE(pm860x_batt_props),\n\t.get_property\t\t= pm860x_batt_get_prop,\n\t.set_property\t\t= pm860x_batt_set_prop,\n\t.external_power_changed\t= pm860x_external_power_changed,\n};\n\nstatic int pm860x_battery_probe(struct platform_device *pdev)\n{\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm860x_battery_info *info;\n\tstruct pm860x_power_pdata *pdata;\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->irq_cc = platform_get_irq(pdev, 0);\n\tif (info->irq_cc <= 0)\n\t\treturn -EINVAL;\n\n\tinfo->irq_batt = platform_get_irq(pdev, 1);\n\tif (info->irq_batt <= 0)\n\t\treturn -EINVAL;\n\n\tinfo->chip = chip;\n\tinfo->i2c =\n\t    (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\n\tinfo->dev = &pdev->dev;\n\tinfo->status = POWER_SUPPLY_STATUS_UNKNOWN;\n\tpdata = pdev->dev.platform_data;\n\n\tmutex_init(&info->lock);\n\tplatform_set_drvdata(pdev, info);\n\n\tpm860x_init_battery(info);\n\n\tif (pdata && pdata->max_capacity)\n\t\tinfo->max_capacity = pdata->max_capacity;\n\telse\n\t\tinfo->max_capacity = 1500;\t \n\tif (pdata && pdata->resistor)\n\t\tinfo->resistor = pdata->resistor;\n\telse\n\t\tinfo->resistor = 300;\t \n\n\tinfo->battery = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t   &pm860x_battery_desc,\n\t\t\t\t\t\t   NULL);\n\tif (IS_ERR(info->battery))\n\t\treturn PTR_ERR(info->battery);\n\tinfo->battery->dev.parent = &pdev->dev;\n\n\tret = devm_request_threaded_irq(chip->dev, info->irq_cc, NULL,\n\t\t\t\t\tpm860x_coulomb_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"coulomb\", info);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq_cc, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(chip->dev, info->irq_batt, NULL,\n\t\t\t\t\tpm860x_batt_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"battery\", info);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq_batt, ret);\n\t\treturn ret;\n\t}\n\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pm860x_battery_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag |= 1 << PM8607_IRQ_CC;\n\treturn 0;\n}\n\nstatic int pm860x_battery_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\n\tif (device_may_wakeup(dev))\n\t\tchip->wakeup_flag &= ~(1 << PM8607_IRQ_CC);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pm860x_battery_pm_ops,\n\t\t\tpm860x_battery_suspend, pm860x_battery_resume);\n\nstatic struct platform_driver pm860x_battery_driver = {\n\t.driver = {\n\t\t   .name = \"88pm860x-battery\",\n\t\t   .pm = &pm860x_battery_pm_ops,\n\t},\n\t.probe = pm860x_battery_probe,\n};\nmodule_platform_driver(pm860x_battery_driver);\n\nMODULE_DESCRIPTION(\"Marvell 88PM860x Battery driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}