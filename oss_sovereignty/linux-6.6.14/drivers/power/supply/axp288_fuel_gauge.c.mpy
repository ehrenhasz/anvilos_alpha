{
  "module_name": "axp288_fuel_gauge.c",
  "hash_id": "f56df7f6cab5184775de17054646bb18a1447699cdda8b5068ba93d4f0808224",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/axp288_fuel_gauge.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/iio/consumer.h>\n#include <asm/unaligned.h>\n#include <asm/iosf_mbi.h>\n\n#define PS_STAT_VBUS_TRIGGER\t\t\t(1 << 0)\n#define PS_STAT_BAT_CHRG_DIR\t\t\t(1 << 2)\n#define PS_STAT_VBAT_ABOVE_VHOLD\t\t(1 << 3)\n#define PS_STAT_VBUS_VALID\t\t\t(1 << 4)\n#define PS_STAT_VBUS_PRESENT\t\t\t(1 << 5)\n\n#define CHRG_STAT_BAT_SAFE_MODE\t\t\t(1 << 3)\n#define CHRG_STAT_BAT_VALID\t\t\t(1 << 4)\n#define CHRG_STAT_BAT_PRESENT\t\t\t(1 << 5)\n#define CHRG_STAT_CHARGING\t\t\t(1 << 6)\n#define CHRG_STAT_PMIC_OTP\t\t\t(1 << 7)\n\n#define CHRG_CCCV_CC_MASK\t\t\t0xf      \n#define CHRG_CCCV_CC_BIT_POS\t\t\t0\n#define CHRG_CCCV_CC_OFFSET\t\t\t200      \n#define CHRG_CCCV_CC_LSB_RES\t\t\t200      \n#define CHRG_CCCV_ITERM_20P\t\t\t(1 << 4)     \n#define CHRG_CCCV_CV_MASK\t\t\t0x60         \n#define CHRG_CCCV_CV_BIT_POS\t\t\t5\n#define CHRG_CCCV_CV_4100MV\t\t\t0x0      \n#define CHRG_CCCV_CV_4150MV\t\t\t0x1      \n#define CHRG_CCCV_CV_4200MV\t\t\t0x2      \n#define CHRG_CCCV_CV_4350MV\t\t\t0x3      \n#define CHRG_CCCV_CHG_EN\t\t\t(1 << 7)\n\n#define FG_CNTL_OCV_ADJ_STAT\t\t\t(1 << 2)\n#define FG_CNTL_OCV_ADJ_EN\t\t\t(1 << 3)\n#define FG_CNTL_CAP_ADJ_STAT\t\t\t(1 << 4)\n#define FG_CNTL_CAP_ADJ_EN\t\t\t(1 << 5)\n#define FG_CNTL_CC_EN\t\t\t\t(1 << 6)\n#define FG_CNTL_GAUGE_EN\t\t\t(1 << 7)\n\n#define FG_15BIT_WORD_VALID\t\t\t(1 << 15)\n#define FG_15BIT_VAL_MASK\t\t\t0x7fff\n\n#define FG_REP_CAP_VALID\t\t\t(1 << 7)\n#define FG_REP_CAP_VAL_MASK\t\t\t0x7F\n\n#define FG_DES_CAP1_VALID\t\t\t(1 << 7)\n#define FG_DES_CAP_RES_LSB\t\t\t1456     \n\n#define FG_DES_CC_RES_LSB\t\t\t1456     \n\n#define FG_OCV_CAP_VALID\t\t\t(1 << 7)\n#define FG_OCV_CAP_VAL_MASK\t\t\t0x7F\n#define FG_CC_CAP_VALID\t\t\t\t(1 << 7)\n#define FG_CC_CAP_VAL_MASK\t\t\t0x7F\n\n#define FG_LOW_CAP_THR1_MASK\t\t\t0xf0     \n#define FG_LOW_CAP_THR1_VAL\t\t\t0xa0     \n#define FG_LOW_CAP_THR2_MASK\t\t\t0x0f     \n#define FG_LOW_CAP_WARN_THR\t\t\t14   \n#define FG_LOW_CAP_CRIT_THR\t\t\t4    \n#define FG_LOW_CAP_SHDN_THR\t\t\t0    \n\n#define DEV_NAME\t\t\t\t\"axp288_fuel_gauge\"\n\n \n#define VOLTAGE_FROM_ADC(a)\t\t\t((a * 11) / 10)\n \n#define PROP_VOLT(a)\t\t\t\t((a) * 1000)\n#define PROP_CURR(a)\t\t\t\t((a) * 1000)\n\n#define AXP288_REG_UPDATE_INTERVAL\t\t(60 * HZ)\n#define AXP288_FG_INTR_NUM\t\t\t6\n\n#define AXP288_QUIRK_NO_BATTERY\t\t\tBIT(0)\n\nstatic bool no_current_sense_res;\nmodule_param(no_current_sense_res, bool, 0444);\nMODULE_PARM_DESC(no_current_sense_res, \"No (or broken) current sense resistor\");\n\nenum {\n\tQWBTU_IRQ = 0,\n\tWBTU_IRQ,\n\tQWBTO_IRQ,\n\tWBTO_IRQ,\n\tWL2_IRQ,\n\tWL1_IRQ,\n};\n\nenum {\n\tBAT_CHRG_CURR,\n\tBAT_D_CURR,\n\tBAT_VOLT,\n\tIIO_CHANNEL_NUM\n};\n\nstruct axp288_fg_info {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tint irq[AXP288_FG_INTR_NUM];\n\tstruct iio_channel *iio_channel[IIO_CHANNEL_NUM];\n\tstruct power_supply *bat;\n\tstruct mutex lock;\n\tint status;\n\tint max_volt;\n\tint pwr_op;\n\tint low_cap;\n\tstruct dentry *debug_file;\n\n\tchar valid;                  \n\tunsigned long last_updated;  \n\n\tint pwr_stat;\n\tint fg_res;\n\tint bat_volt;\n\tint d_curr;\n\tint c_curr;\n\tint ocv;\n\tint fg_cc_mtr1;\n\tint fg_des_cap1;\n};\n\nstatic enum power_supply_property fuel_gauge_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_ALERT_MIN,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\t \n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic int fuel_gauge_reg_readb(struct axp288_fg_info *info, int reg)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(info->regmap, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"Error reading reg 0x%02x err: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int fuel_gauge_reg_writeb(struct axp288_fg_info *info, int reg, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(info->regmap, reg, (unsigned int)val);\n\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"Error writing reg 0x%02x err: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int fuel_gauge_read_15bit_word(struct axp288_fg_info *info, int reg)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = regmap_bulk_read(info->regmap, reg, buf, 2);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"Error reading reg 0x%02x err: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\tret = get_unaligned_be16(buf);\n\tif (!(ret & FG_15BIT_WORD_VALID)) {\n\t\tdev_err(info->dev, \"Error reg 0x%02x contents not valid\\n\", reg);\n\t\treturn -ENXIO;\n\t}\n\n\treturn ret & FG_15BIT_VAL_MASK;\n}\n\nstatic int fuel_gauge_read_12bit_word(struct axp288_fg_info *info, int reg)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = regmap_bulk_read(info->regmap, reg, buf, 2);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"Error reading reg 0x%02x err: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn (buf[0] << 4) | ((buf[1] >> 4) & 0x0f);\n}\n\nstatic int fuel_gauge_update_registers(struct axp288_fg_info *info)\n{\n\tint ret;\n\n\tif (info->valid && time_before(jiffies, info->last_updated + AXP288_REG_UPDATE_INTERVAL))\n\t\treturn 0;\n\n\tdev_dbg(info->dev, \"Fuel Gauge updating register values...\\n\");\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fuel_gauge_reg_readb(info, AXP20X_PWR_INPUT_STATUS);\n\tif (ret < 0)\n\t\tgoto out;\n\tinfo->pwr_stat = ret;\n\n\tif (no_current_sense_res)\n\t\tret = fuel_gauge_reg_readb(info, AXP288_FG_OCV_CAP_REG);\n\telse\n\t\tret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);\n\tif (ret < 0)\n\t\tgoto out;\n\tinfo->fg_res = ret;\n\n\tret = iio_read_channel_raw(info->iio_channel[BAT_VOLT], &info->bat_volt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = fuel_gauge_read_12bit_word(info, AXP288_FG_OCVH_REG);\n\tif (ret < 0)\n\t\tgoto out;\n\tinfo->ocv = ret;\n\n\tif (no_current_sense_res)\n\t\tgoto out_no_current_sense_res;\n\n\tif (info->pwr_stat & PS_STAT_BAT_CHRG_DIR) {\n\t\tinfo->d_curr = 0;\n\t\tret = iio_read_channel_raw(info->iio_channel[BAT_CHRG_CURR], &info->c_curr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tinfo->c_curr = 0;\n\t\tret = iio_read_channel_raw(info->iio_channel[BAT_D_CURR], &info->d_curr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = fuel_gauge_read_15bit_word(info, AXP288_FG_CC_MTR1_REG);\n\tif (ret < 0)\n\t\tgoto out;\n\tinfo->fg_cc_mtr1 = ret;\n\n\tret = fuel_gauge_read_15bit_word(info, AXP288_FG_DES_CAP1_REG);\n\tif (ret < 0)\n\t\tgoto out;\n\tinfo->fg_des_cap1 = ret;\n\nout_no_current_sense_res:\n\tinfo->last_updated = jiffies;\n\tinfo->valid = 1;\n\tret = 0;\nout:\n\tiosf_mbi_unblock_punit_i2c_access();\n\treturn ret;\n}\n\nstatic void fuel_gauge_get_status(struct axp288_fg_info *info)\n{\n\tint pwr_stat = info->pwr_stat;\n\tint fg_res = info->fg_res;\n\tint curr = info->d_curr;\n\n\t \n\tif (!(pwr_stat & PS_STAT_VBUS_VALID))\n\t\tgoto not_full;\n\n\tif (!(fg_res & FG_REP_CAP_VALID))\n\t\tgoto not_full;\n\n\tfg_res &= ~FG_REP_CAP_VALID;\n\tif (fg_res == 100) {\n\t\tinfo->status = POWER_SUPPLY_STATUS_FULL;\n\t\treturn;\n\t}\n\n\t \n\tif (fg_res < 90 || (pwr_stat & PS_STAT_BAT_CHRG_DIR) || no_current_sense_res)\n\t\tgoto not_full;\n\n\tif (curr == 0) {\n\t\tinfo->status = POWER_SUPPLY_STATUS_FULL;\n\t\treturn;\n\t}\n\nnot_full:\n\tif (pwr_stat & PS_STAT_BAT_CHRG_DIR)\n\t\tinfo->status = POWER_SUPPLY_STATUS_CHARGING;\n\telse\n\t\tinfo->status = POWER_SUPPLY_STATUS_DISCHARGING;\n}\n\nstatic int fuel_gauge_battery_health(struct axp288_fg_info *info)\n{\n\tint vocv = VOLTAGE_FROM_ADC(info->ocv);\n\tint health = POWER_SUPPLY_HEALTH_UNKNOWN;\n\n\tif (vocv > info->max_volt)\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\telse\n\t\thealth = POWER_SUPPLY_HEALTH_GOOD;\n\n\treturn health;\n}\n\nstatic int fuel_gauge_get_property(struct power_supply *ps,\n\t\tenum power_supply_property prop,\n\t\tunion power_supply_propval *val)\n{\n\tstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\n\tint ret, value;\n\n\tmutex_lock(&info->lock);\n\n\tret = fuel_gauge_update_registers(info);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tfuel_gauge_get_status(info);\n\t\tval->intval = info->status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = fuel_gauge_battery_health(info);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tvalue = VOLTAGE_FROM_ADC(info->bat_volt);\n\t\tval->intval = PROP_VOLT(value);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tvalue = VOLTAGE_FROM_ADC(info->ocv);\n\t\tval->intval = PROP_VOLT(value);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (info->d_curr > 0)\n\t\t\tvalue = -1 * info->d_curr;\n\t\telse\n\t\t\tvalue = info->c_curr;\n\n\t\tval->intval = PROP_CURR(value);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tif (info->pwr_op & CHRG_STAT_BAT_PRESENT)\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (!(info->fg_res & FG_REP_CAP_VALID))\n\t\t\tdev_err(info->dev, \"capacity measurement not valid\\n\");\n\t\tval->intval = (info->fg_res & FG_REP_CAP_VAL_MASK);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\tval->intval = (info->low_cap & 0x0f);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tval->intval = info->fg_cc_mtr1 * FG_DES_CAP_RES_LSB;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tval->intval = info->fg_des_cap1 * FG_DES_CAP_RES_LSB;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = PROP_VOLT(info->max_volt);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int fuel_gauge_set_property(struct power_supply *ps,\n\t\tenum power_supply_property prop,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\n\tint new_low_cap, ret = 0;\n\n\tmutex_lock(&info->lock);\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\tif ((val->intval < 0) || (val->intval > 15)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tnew_low_cap = info->low_cap;\n\t\tnew_low_cap &= 0xf0;\n\t\tnew_low_cap |= (val->intval & 0xf);\n\t\tret = fuel_gauge_reg_writeb(info, AXP288_FG_LOW_CAP_REG, new_low_cap);\n\t\tif (ret == 0)\n\t\t\tinfo->low_cap = new_low_cap;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int fuel_gauge_property_is_writeable(struct power_supply *psy,\n\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t fuel_gauge_thread_handler(int irq, void *dev)\n{\n\tstruct axp288_fg_info *info = dev;\n\tint i;\n\n\tfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\n\t\tif (info->irq[i] == irq)\n\t\t\tbreak;\n\t}\n\n\tif (i >= AXP288_FG_INTR_NUM) {\n\t\tdev_warn(info->dev, \"spurious interrupt!!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tswitch (i) {\n\tcase QWBTU_IRQ:\n\t\tdev_info(info->dev, \"Quit Battery under temperature in work mode IRQ (QWBTU)\\n\");\n\t\tbreak;\n\tcase WBTU_IRQ:\n\t\tdev_info(info->dev, \"Battery under temperature in work mode IRQ (WBTU)\\n\");\n\t\tbreak;\n\tcase QWBTO_IRQ:\n\t\tdev_info(info->dev, \"Quit Battery over temperature in work mode IRQ (QWBTO)\\n\");\n\t\tbreak;\n\tcase WBTO_IRQ:\n\t\tdev_info(info->dev, \"Battery over temperature in work mode IRQ (WBTO)\\n\");\n\t\tbreak;\n\tcase WL2_IRQ:\n\t\tdev_info(info->dev, \"Low Batt Warning(2) INTR\\n\");\n\t\tbreak;\n\tcase WL1_IRQ:\n\t\tdev_info(info->dev, \"Low Batt Warning(1) INTR\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(info->dev, \"Spurious Interrupt!!!\\n\");\n\t}\n\n\tmutex_lock(&info->lock);\n\tinfo->valid = 0;  \n\tmutex_unlock(&info->lock);\n\n\tpower_supply_changed(info->bat);\n\treturn IRQ_HANDLED;\n}\n\nstatic void fuel_gauge_external_power_changed(struct power_supply *psy)\n{\n\tstruct axp288_fg_info *info = power_supply_get_drvdata(psy);\n\n\tmutex_lock(&info->lock);\n\tinfo->valid = 0;  \n\tmutex_unlock(&info->lock);\n\tpower_supply_changed(psy);\n}\n\nstatic struct power_supply_desc fuel_gauge_desc = {\n\t.name\t\t\t= DEV_NAME,\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= fuel_gauge_props,\n\t.num_properties\t\t= ARRAY_SIZE(fuel_gauge_props),\n\t.get_property\t\t= fuel_gauge_get_property,\n\t.set_property\t\t= fuel_gauge_set_property,\n\t.property_is_writeable\t= fuel_gauge_property_is_writeable,\n\t.external_power_changed\t= fuel_gauge_external_power_changed,\n};\n\n \nstatic const struct dmi_system_id axp288_quirks[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"To be filled by O.E.M.\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Cherry Trail CR\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"T8\"),\n\t\t\t \n\t\t\tDMI_EXACT_MATCH(DMI_BIOS_VERSION, \"1.000\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"To be filled by O.E.M.\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Cherry Trail CR\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"T11\"),\n\t\t\t \n\t\t\tDMI_EXACT_MATCH(DMI_BIOS_VERSION, \"1.000\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"STK1AW32SC\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"STK1A32SC\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MEEGOPAD T02\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"Mini PC\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Mini PC\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MINIX\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Z83-4\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"T3 MRD\"),\n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"06/14/2018\"),\n\t\t},\n\t\t.driver_data = NULL,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"T3 MRD\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"3\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"American Megatrends Inc.\"),\n\t\t},\n\t\t.driver_data = (void *)AXP288_QUIRK_NO_BATTERY,\n\t},\n\t{}\n};\n\nstatic int axp288_fuel_gauge_read_initial_regs(struct axp288_fg_info *info)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(info->regmap, AXP20X_CC_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val == 0)\n\t\treturn -ENODEV;\n\n\tret = fuel_gauge_reg_readb(info, AXP288_FG_DES_CAP1_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(ret & FG_DES_CAP1_VALID)) {\n\t\tdev_err(info->dev, \"axp288 not configured by firmware\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = fuel_gauge_reg_readb(info, AXP20X_CHRG_CTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\tswitch ((ret & CHRG_CCCV_CV_MASK) >> CHRG_CCCV_CV_BIT_POS) {\n\tcase CHRG_CCCV_CV_4100MV:\n\t\tinfo->max_volt = 4100;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4150MV:\n\t\tinfo->max_volt = 4150;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4200MV:\n\t\tinfo->max_volt = 4200;\n\t\tbreak;\n\tcase CHRG_CCCV_CV_4350MV:\n\t\tinfo->max_volt = 4350;\n\t\tbreak;\n\t}\n\n\tret = fuel_gauge_reg_readb(info, AXP20X_PWR_OP_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\tinfo->pwr_op = ret;\n\n\tret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);\n\tif (ret < 0)\n\t\treturn ret;\n\tinfo->low_cap = ret;\n\n\treturn 0;\n}\n\nstatic void axp288_fuel_gauge_release_iio_chans(void *data)\n{\n\tstruct axp288_fg_info *info = data;\n\tint i;\n\n\tfor (i = 0; i < IIO_CHANNEL_NUM; i++)\n\t\tif (!IS_ERR_OR_NULL(info->iio_channel[i]))\n\t\t\tiio_channel_release(info->iio_channel[i]);\n}\n\nstatic int axp288_fuel_gauge_probe(struct platform_device *pdev)\n{\n\tstruct axp288_fg_info *info;\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config psy_cfg = {};\n\tstatic const char * const iio_chan_name[] = {\n\t\t[BAT_CHRG_CURR] = \"axp288-chrg-curr\",\n\t\t[BAT_D_CURR] = \"axp288-chrg-d-curr\",\n\t\t[BAT_VOLT] = \"axp288-batt-volt\",\n\t};\n\tconst struct dmi_system_id *dmi_id;\n\tstruct device *dev = &pdev->dev;\n\tunsigned long quirks = 0;\n\tint i, pirq, ret;\n\n\t \n\tif (!acpi_quirk_skip_acpi_ac_and_battery())\n\t\treturn -ENODEV;\n\n\tdmi_id = dmi_first_match(axp288_quirks);\n\tif (dmi_id)\n\t\tquirks = (unsigned long)dmi_id->driver_data;\n\n\tif (quirks & AXP288_QUIRK_NO_BATTERY)\n\t\treturn -ENODEV;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->regmap = axp20x->regmap;\n\tinfo->status = POWER_SUPPLY_STATUS_UNKNOWN;\n\tinfo->valid = 0;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tmutex_init(&info->lock);\n\n\tfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\n\t\tpirq = platform_get_irq(pdev, i);\n\t\tif (pirq < 0)\n\t\t\tcontinue;\n\t\tret = regmap_irq_get_virq(axp20x->regmap_irqc, pirq);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"getting vIRQ %d\\n\", pirq);\n\n\t\tinfo->irq[i] = ret;\n\t}\n\n\tfor (i = 0; i < IIO_CHANNEL_NUM; i++) {\n\t\t \n\t\tinfo->iio_channel[i] =\n\t\t\tiio_channel_get(NULL, iio_chan_name[i]);\n\t\tif (IS_ERR(info->iio_channel[i])) {\n\t\t\tret = PTR_ERR(info->iio_channel[i]);\n\t\t\tdev_dbg(dev, \"error getting iiochan %s: %d\\n\", iio_chan_name[i], ret);\n\t\t\t \n\t\t\tif (ret == -ENODEV)\n\t\t\t\tret = -EPROBE_DEFER;\n\n\t\t\taxp288_fuel_gauge_release_iio_chans(info);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_add_action_or_reset(dev, axp288_fuel_gauge_release_iio_chans, info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = axp288_fuel_gauge_read_initial_regs(info);\n\tiosf_mbi_unblock_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpsy_cfg.drv_data = info;\n\tif (no_current_sense_res)\n\t\tfuel_gauge_desc.num_properties = ARRAY_SIZE(fuel_gauge_props) - 3;\n\tinfo->bat = devm_power_supply_register(dev, &fuel_gauge_desc, &psy_cfg);\n\tif (IS_ERR(info->bat)) {\n\t\tret = PTR_ERR(info->bat);\n\t\tdev_err(dev, \"failed to register battery: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\n\t\tret = devm_request_threaded_irq(dev, info->irq[i], NULL,\n\t\t\t\t\t\tfuel_gauge_thread_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, DEV_NAME, info);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"requesting IRQ %d\\n\", info->irq[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id axp288_fg_id_table[] = {\n\t{ .name = DEV_NAME },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, axp288_fg_id_table);\n\nstatic struct platform_driver axp288_fuel_gauge_driver = {\n\t.probe = axp288_fuel_gauge_probe,\n\t.id_table = axp288_fg_id_table,\n\t.driver = {\n\t\t.name = DEV_NAME,\n\t},\n};\n\nmodule_platform_driver(axp288_fuel_gauge_driver);\n\nMODULE_AUTHOR(\"Ramakrishna Pallala <ramakrishna.pallala@intel.com>\");\nMODULE_AUTHOR(\"Todd Brandt <todd.e.brandt@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Xpower AXP288 Fuel Gauge Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}