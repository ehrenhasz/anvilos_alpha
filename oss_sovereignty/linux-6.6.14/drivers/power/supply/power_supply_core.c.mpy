{
  "module_name": "power_supply_core.c",
  "hash_id": "9c76b44d8f6bb5f08e1a687f0b897c3118ab84bf8ae1b0c0f9bbafbfa858f791",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/power_supply_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/notifier.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/thermal.h>\n#include <linux/fixp-arith.h>\n#include \"power_supply.h\"\n#include \"samsung-sdi-battery.h\"\n\n \nstruct class *power_supply_class;\nEXPORT_SYMBOL_GPL(power_supply_class);\n\nBLOCKING_NOTIFIER_HEAD(power_supply_notifier);\nEXPORT_SYMBOL_GPL(power_supply_notifier);\n\nstatic struct device_type power_supply_dev_type;\n\n#define POWER_SUPPLY_DEFERRED_REGISTER_TIME\tmsecs_to_jiffies(10)\n\nstatic bool __power_supply_is_supplied_by(struct power_supply *supplier,\n\t\t\t\t\t struct power_supply *supply)\n{\n\tint i;\n\n\tif (!supply->supplied_from && !supplier->supplied_to)\n\t\treturn false;\n\n\t \n\tif (supply->supplied_from) {\n\t\tif (!supplier->desc->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supply->num_supplies; i++)\n\t\t\tif (!strcmp(supplier->desc->name, supply->supplied_from[i]))\n\t\t\t\treturn true;\n\t} else {\n\t\tif (!supply->desc->name)\n\t\t\treturn false;\n\t\tfor (i = 0; i < supplier->num_supplicants; i++)\n\t\t\tif (!strcmp(supplier->supplied_to[i], supply->desc->name))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __power_supply_changed_work(struct device *dev, void *data)\n{\n\tstruct power_supply *psy = data;\n\tstruct power_supply *pst = dev_get_drvdata(dev);\n\n\tif (__power_supply_is_supplied_by(psy, pst)) {\n\t\tif (pst->desc->external_power_changed)\n\t\t\tpst->desc->external_power_changed(pst);\n\t}\n\n\treturn 0;\n}\n\nstatic void power_supply_changed_work(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct power_supply *psy = container_of(work, struct power_supply,\n\t\t\t\t\t\tchanged_work);\n\n\tdev_dbg(&psy->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&psy->changed_lock, flags);\n\t \n\tif (likely(psy->changed)) {\n\t\tpsy->changed = false;\n\t\tspin_unlock_irqrestore(&psy->changed_lock, flags);\n\t\tclass_for_each_device(power_supply_class, NULL, psy,\n\t\t\t\t      __power_supply_changed_work);\n\t\tpower_supply_update_leds(psy);\n\t\tblocking_notifier_call_chain(&power_supply_notifier,\n\t\t\t\tPSY_EVENT_PROP_CHANGED, psy);\n\t\tkobject_uevent(&psy->dev.kobj, KOBJ_CHANGE);\n\t\tspin_lock_irqsave(&psy->changed_lock, flags);\n\t}\n\n\t \n\tif (likely(!psy->changed))\n\t\tpm_relax(&psy->dev);\n\tspin_unlock_irqrestore(&psy->changed_lock, flags);\n}\n\nvoid power_supply_changed(struct power_supply *psy)\n{\n\tunsigned long flags;\n\n\tdev_dbg(&psy->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&psy->changed_lock, flags);\n\tpsy->changed = true;\n\tpm_stay_awake(&psy->dev);\n\tspin_unlock_irqrestore(&psy->changed_lock, flags);\n\tschedule_work(&psy->changed_work);\n}\nEXPORT_SYMBOL_GPL(power_supply_changed);\n\n \nstatic void power_supply_deferred_register_work(struct work_struct *work)\n{\n\tstruct power_supply *psy = container_of(work, struct power_supply,\n\t\t\t\t\t\tdeferred_register_work.work);\n\n\tif (psy->dev.parent) {\n\t\twhile (!mutex_trylock(&psy->dev.parent->mutex)) {\n\t\t\tif (psy->removing)\n\t\t\t\treturn;\n\t\t\tmsleep(10);\n\t\t}\n\t}\n\n\tpower_supply_changed(psy);\n\n\tif (psy->dev.parent)\n\t\tmutex_unlock(&psy->dev.parent->mutex);\n}\n\n#ifdef CONFIG_OF\nstatic int __power_supply_populate_supplied_from(struct device *dev,\n\t\t\t\t\t\t void *data)\n{\n\tstruct power_supply *psy = data;\n\tstruct power_supply *epsy = dev_get_drvdata(dev);\n\tstruct device_node *np;\n\tint i = 0;\n\n\tdo {\n\t\tnp = of_parse_phandle(psy->of_node, \"power-supplies\", i++);\n\t\tif (!np)\n\t\t\tbreak;\n\n\t\tif (np == epsy->of_node) {\n\t\t\tdev_dbg(&psy->dev, \"%s: Found supply : %s\\n\",\n\t\t\t\tpsy->desc->name, epsy->desc->name);\n\t\t\tpsy->supplied_from[i-1] = (char *)epsy->desc->name;\n\t\t\tpsy->num_supplies++;\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\t\tof_node_put(np);\n\t} while (np);\n\n\treturn 0;\n}\n\nstatic int power_supply_populate_supplied_from(struct power_supply *psy)\n{\n\tint error;\n\n\terror = class_for_each_device(power_supply_class, NULL, psy,\n\t\t\t\t      __power_supply_populate_supplied_from);\n\n\tdev_dbg(&psy->dev, \"%s %d\\n\", __func__, error);\n\n\treturn error;\n}\n\nstatic int  __power_supply_find_supply_from_node(struct device *dev,\n\t\t\t\t\t\t void *data)\n{\n\tstruct device_node *np = data;\n\tstruct power_supply *epsy = dev_get_drvdata(dev);\n\n\t \n\tif (epsy->of_node == np)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int power_supply_find_supply_from_node(struct device_node *supply_node)\n{\n\tint error;\n\n\t \n\terror = class_for_each_device(power_supply_class, NULL, supply_node,\n\t\t\t\t       __power_supply_find_supply_from_node);\n\n\treturn error ? (error == 1 ? 0 : error) : -EPROBE_DEFER;\n}\n\nstatic int power_supply_check_supplies(struct power_supply *psy)\n{\n\tstruct device_node *np;\n\tint cnt = 0;\n\n\t \n\tif (psy->supplied_from && psy->num_supplies > 0)\n\t\treturn 0;\n\n\t \n\tif (!psy->of_node)\n\t\treturn 0;\n\n\tdo {\n\t\tint ret;\n\n\t\tnp = of_parse_phandle(psy->of_node, \"power-supplies\", cnt++);\n\t\tif (!np)\n\t\t\tbreak;\n\n\t\tret = power_supply_find_supply_from_node(np);\n\t\tof_node_put(np);\n\n\t\tif (ret) {\n\t\t\tdev_dbg(&psy->dev, \"Failed to find supply!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} while (np);\n\n\t \n\tif (cnt == 1)\n\t\treturn 0;\n\n\t \n\tpsy->supplied_from = devm_kzalloc(&psy->dev, sizeof(*psy->supplied_from),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!psy->supplied_from)\n\t\treturn -ENOMEM;\n\n\t*psy->supplied_from = devm_kcalloc(&psy->dev,\n\t\t\t\t\t   cnt - 1, sizeof(**psy->supplied_from),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!*psy->supplied_from)\n\t\treturn -ENOMEM;\n\n\treturn power_supply_populate_supplied_from(psy);\n}\n#else\nstatic int power_supply_check_supplies(struct power_supply *psy)\n{\n\tint nval, ret;\n\n\tif (!psy->dev.parent)\n\t\treturn 0;\n\n\tnval = device_property_string_array_count(psy->dev.parent, \"supplied-from\");\n\tif (nval <= 0)\n\t\treturn 0;\n\n\tpsy->supplied_from = devm_kmalloc_array(&psy->dev, nval,\n\t\t\t\t\t\tsizeof(char *), GFP_KERNEL);\n\tif (!psy->supplied_from)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_string_array(psy->dev.parent,\n\t\t\"supplied-from\", (const char **)psy->supplied_from, nval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpsy->num_supplies = nval;\n\n\treturn 0;\n}\n#endif\n\nstruct psy_am_i_supplied_data {\n\tstruct power_supply *psy;\n\tunsigned int count;\n};\n\nstatic int __power_supply_am_i_supplied(struct device *dev, void *_data)\n{\n\tunion power_supply_propval ret = {0,};\n\tstruct power_supply *epsy = dev_get_drvdata(dev);\n\tstruct psy_am_i_supplied_data *data = _data;\n\n\tif (__power_supply_is_supplied_by(epsy, data->psy)) {\n\t\tdata->count++;\n\t\tif (!epsy->desc->get_property(epsy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t\t&ret))\n\t\t\treturn ret.intval;\n\t}\n\n\treturn 0;\n}\n\nint power_supply_am_i_supplied(struct power_supply *psy)\n{\n\tstruct psy_am_i_supplied_data data = { psy, 0 };\n\tint error;\n\n\terror = class_for_each_device(power_supply_class, NULL, &data,\n\t\t\t\t      __power_supply_am_i_supplied);\n\n\tdev_dbg(&psy->dev, \"%s count %u err %d\\n\", __func__, data.count, error);\n\n\tif (data.count == 0)\n\t\treturn -ENODEV;\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(power_supply_am_i_supplied);\n\nstatic int __power_supply_is_system_supplied(struct device *dev, void *data)\n{\n\tunion power_supply_propval ret = {0,};\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tunsigned int *count = data;\n\n\tif (!psy->desc->get_property(psy, POWER_SUPPLY_PROP_SCOPE, &ret))\n\t\tif (ret.intval == POWER_SUPPLY_SCOPE_DEVICE)\n\t\t\treturn 0;\n\n\t(*count)++;\n\tif (psy->desc->type != POWER_SUPPLY_TYPE_BATTERY)\n\t\tif (!psy->desc->get_property(psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t\t&ret))\n\t\t\treturn ret.intval;\n\n\treturn 0;\n}\n\nint power_supply_is_system_supplied(void)\n{\n\tint error;\n\tunsigned int count = 0;\n\n\terror = class_for_each_device(power_supply_class, NULL, &count,\n\t\t\t\t      __power_supply_is_system_supplied);\n\n\t \n\tif (count == 0)\n\t\treturn 1;\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(power_supply_is_system_supplied);\n\nstruct psy_get_supplier_prop_data {\n\tstruct power_supply *psy;\n\tenum power_supply_property psp;\n\tunion power_supply_propval *val;\n};\n\nstatic int __power_supply_get_supplier_property(struct device *dev, void *_data)\n{\n\tstruct power_supply *epsy = dev_get_drvdata(dev);\n\tstruct psy_get_supplier_prop_data *data = _data;\n\n\tif (__power_supply_is_supplied_by(epsy, data->psy))\n\t\tif (!power_supply_get_property(epsy, data->psp, data->val))\n\t\t\treturn 1;  \n\n\treturn 0;  \n}\n\nint power_supply_get_property_from_supplier(struct power_supply *psy,\n\t\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t\t    union power_supply_propval *val)\n{\n\tstruct psy_get_supplier_prop_data data = {\n\t\t.psy = psy,\n\t\t.psp = psp,\n\t\t.val = val,\n\t};\n\tint ret;\n\n\t \n\tret = class_for_each_device(power_supply_class, NULL, &data,\n\t\t\t\t    __power_supply_get_supplier_property);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_property_from_supplier);\n\nint power_supply_set_battery_charged(struct power_supply *psy)\n{\n\tif (atomic_read(&psy->use_cnt) >= 0 &&\n\t\t\tpsy->desc->type == POWER_SUPPLY_TYPE_BATTERY &&\n\t\t\tpsy->desc->set_charged) {\n\t\tpsy->desc->set_charged(psy);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(power_supply_set_battery_charged);\n\nstatic int power_supply_match_device_by_name(struct device *dev, const void *data)\n{\n\tconst char *name = data;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\n\treturn strcmp(psy->desc->name, name) == 0;\n}\n\n \nstruct power_supply *power_supply_get_by_name(const char *name)\n{\n\tstruct power_supply *psy = NULL;\n\tstruct device *dev = class_find_device(power_supply_class, NULL, name,\n\t\t\t\t\tpower_supply_match_device_by_name);\n\n\tif (dev) {\n\t\tpsy = dev_get_drvdata(dev);\n\t\tatomic_inc(&psy->use_cnt);\n\t}\n\n\treturn psy;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_by_name);\n\n \nvoid power_supply_put(struct power_supply *psy)\n{\n\tmight_sleep();\n\n\tatomic_dec(&psy->use_cnt);\n\tput_device(&psy->dev);\n}\nEXPORT_SYMBOL_GPL(power_supply_put);\n\n#ifdef CONFIG_OF\nstatic int power_supply_match_device_node(struct device *dev, const void *data)\n{\n\treturn dev->parent && dev->parent->of_node == data;\n}\n\n \nstruct power_supply *power_supply_get_by_phandle(struct device_node *np,\n\t\t\t\t\t\t\tconst char *property)\n{\n\tstruct device_node *power_supply_np;\n\tstruct power_supply *psy = NULL;\n\tstruct device *dev;\n\n\tpower_supply_np = of_parse_phandle(np, property, 0);\n\tif (!power_supply_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = class_find_device(power_supply_class, NULL, power_supply_np,\n\t\t\t\t\t\tpower_supply_match_device_node);\n\n\tof_node_put(power_supply_np);\n\n\tif (dev) {\n\t\tpsy = dev_get_drvdata(dev);\n\t\tatomic_inc(&psy->use_cnt);\n\t}\n\n\treturn psy;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_by_phandle);\n\nstatic void devm_power_supply_put(struct device *dev, void *res)\n{\n\tstruct power_supply **psy = res;\n\n\tpower_supply_put(*psy);\n}\n\n \nstruct power_supply *devm_power_supply_get_by_phandle(struct device *dev,\n\t\t\t\t\t\t      const char *property)\n{\n\tstruct power_supply **ptr, *psy;\n\n\tif (!dev->of_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tptr = devres_alloc(devm_power_supply_put, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpsy = power_supply_get_by_phandle(dev->of_node, property);\n\tif (IS_ERR_OR_NULL(psy)) {\n\t\tdevres_free(ptr);\n\t} else {\n\t\t*ptr = psy;\n\t\tdevres_add(dev, ptr);\n\t}\n\treturn psy;\n}\nEXPORT_SYMBOL_GPL(devm_power_supply_get_by_phandle);\n#endif  \n\nint power_supply_get_battery_info(struct power_supply *psy,\n\t\t\t\t  struct power_supply_battery_info **info_out)\n{\n\tstruct power_supply_resistance_temp_table *resist_table;\n\tstruct power_supply_battery_info *info;\n\tstruct device_node *battery_np = NULL;\n\tstruct fwnode_reference_args args;\n\tstruct fwnode_handle *fwnode = NULL;\n\tconst char *value;\n\tint err, len, index;\n\tconst __be32 *list;\n\tu32 min_max[2];\n\n\tif (psy->of_node) {\n\t\tbattery_np = of_parse_phandle(psy->of_node, \"monitored-battery\", 0);\n\t\tif (!battery_np)\n\t\t\treturn -ENODEV;\n\n\t\tfwnode = fwnode_handle_get(of_fwnode_handle(battery_np));\n\t} else if (psy->dev.parent) {\n\t\terr = fwnode_property_get_reference_args(\n\t\t\t\t\tdev_fwnode(psy->dev.parent),\n\t\t\t\t\t\"monitored-battery\", NULL, 0, 0, &args);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfwnode = args.fwnode;\n\t}\n\n\tif (!fwnode)\n\t\treturn -ENOENT;\n\n\terr = fwnode_property_read_string(fwnode, \"compatible\", &value);\n\tif (err)\n\t\tgoto out_put_node;\n\n\n\t \n\terr = samsung_sdi_battery_get_info(&psy->dev, value, &info);\n\tif (!err)\n\t\tgoto out_ret_pointer;\n\telse if (err == -ENODEV)\n\t\t \n\t\terr = 0;\n\n\tif (strcmp(\"simple-battery\", value)) {\n\t\terr = -ENODEV;\n\t\tgoto out_put_node;\n\t}\n\n\tinfo = devm_kzalloc(&psy->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tinfo->technology                     = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\tinfo->energy_full_design_uwh         = -EINVAL;\n\tinfo->charge_full_design_uah         = -EINVAL;\n\tinfo->voltage_min_design_uv          = -EINVAL;\n\tinfo->voltage_max_design_uv          = -EINVAL;\n\tinfo->precharge_current_ua           = -EINVAL;\n\tinfo->charge_term_current_ua         = -EINVAL;\n\tinfo->constant_charge_current_max_ua = -EINVAL;\n\tinfo->constant_charge_voltage_max_uv = -EINVAL;\n\tinfo->tricklecharge_current_ua       = -EINVAL;\n\tinfo->precharge_voltage_max_uv       = -EINVAL;\n\tinfo->charge_restart_voltage_uv      = -EINVAL;\n\tinfo->overvoltage_limit_uv           = -EINVAL;\n\tinfo->maintenance_charge             = NULL;\n\tinfo->alert_low_temp_charge_current_ua = -EINVAL;\n\tinfo->alert_low_temp_charge_voltage_uv = -EINVAL;\n\tinfo->alert_high_temp_charge_current_ua = -EINVAL;\n\tinfo->alert_high_temp_charge_voltage_uv = -EINVAL;\n\tinfo->temp_ambient_alert_min         = INT_MIN;\n\tinfo->temp_ambient_alert_max         = INT_MAX;\n\tinfo->temp_alert_min                 = INT_MIN;\n\tinfo->temp_alert_max                 = INT_MAX;\n\tinfo->temp_min                       = INT_MIN;\n\tinfo->temp_max                       = INT_MAX;\n\tinfo->factory_internal_resistance_uohm  = -EINVAL;\n\tinfo->resist_table                   = NULL;\n\tinfo->bti_resistance_ohm             = -EINVAL;\n\tinfo->bti_resistance_tolerance       = -EINVAL;\n\n\tfor (index = 0; index < POWER_SUPPLY_OCV_TEMP_MAX; index++) {\n\t\tinfo->ocv_table[index]       = NULL;\n\t\tinfo->ocv_temp[index]        = -EINVAL;\n\t\tinfo->ocv_table_size[index]  = -EINVAL;\n\t}\n\n\t \n\n\tif (!fwnode_property_read_string(fwnode, \"device-chemistry\", &value)) {\n\t\tif (!strcmp(\"nickel-cadmium\", value))\n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_NiCd;\n\t\telse if (!strcmp(\"nickel-metal-hydride\", value))\n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_NiMH;\n\t\telse if (!strcmp(\"lithium-ion\", value))\n\t\t\t \n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\telse if (!strcmp(\"lithium-ion-polymer\", value))\n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_LIPO;\n\t\telse if (!strcmp(\"lithium-ion-iron-phosphate\", value))\n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_LiFe;\n\t\telse if (!strcmp(\"lithium-ion-manganese-oxide\", value))\n\t\t\tinfo->technology = POWER_SUPPLY_TECHNOLOGY_LiMn;\n\t\telse\n\t\t\tdev_warn(&psy->dev, \"%s unknown battery type\\n\", value);\n\t}\n\n\tfwnode_property_read_u32(fwnode, \"energy-full-design-microwatt-hours\",\n\t\t\t     &info->energy_full_design_uwh);\n\tfwnode_property_read_u32(fwnode, \"charge-full-design-microamp-hours\",\n\t\t\t     &info->charge_full_design_uah);\n\tfwnode_property_read_u32(fwnode, \"voltage-min-design-microvolt\",\n\t\t\t     &info->voltage_min_design_uv);\n\tfwnode_property_read_u32(fwnode, \"voltage-max-design-microvolt\",\n\t\t\t     &info->voltage_max_design_uv);\n\tfwnode_property_read_u32(fwnode, \"trickle-charge-current-microamp\",\n\t\t\t     &info->tricklecharge_current_ua);\n\tfwnode_property_read_u32(fwnode, \"precharge-current-microamp\",\n\t\t\t     &info->precharge_current_ua);\n\tfwnode_property_read_u32(fwnode, \"precharge-upper-limit-microvolt\",\n\t\t\t     &info->precharge_voltage_max_uv);\n\tfwnode_property_read_u32(fwnode, \"charge-term-current-microamp\",\n\t\t\t     &info->charge_term_current_ua);\n\tfwnode_property_read_u32(fwnode, \"re-charge-voltage-microvolt\",\n\t\t\t     &info->charge_restart_voltage_uv);\n\tfwnode_property_read_u32(fwnode, \"over-voltage-threshold-microvolt\",\n\t\t\t     &info->overvoltage_limit_uv);\n\tfwnode_property_read_u32(fwnode, \"constant-charge-current-max-microamp\",\n\t\t\t     &info->constant_charge_current_max_ua);\n\tfwnode_property_read_u32(fwnode, \"constant-charge-voltage-max-microvolt\",\n\t\t\t     &info->constant_charge_voltage_max_uv);\n\tfwnode_property_read_u32(fwnode, \"factory-internal-resistance-micro-ohms\",\n\t\t\t     &info->factory_internal_resistance_uohm);\n\n\tif (!fwnode_property_read_u32_array(fwnode, \"ambient-celsius\",\n\t\t\t\t\t    min_max, ARRAY_SIZE(min_max))) {\n\t\tinfo->temp_ambient_alert_min = min_max[0];\n\t\tinfo->temp_ambient_alert_max = min_max[1];\n\t}\n\tif (!fwnode_property_read_u32_array(fwnode, \"alert-celsius\",\n\t\t\t\t\t    min_max, ARRAY_SIZE(min_max))) {\n\t\tinfo->temp_alert_min = min_max[0];\n\t\tinfo->temp_alert_max = min_max[1];\n\t}\n\tif (!fwnode_property_read_u32_array(fwnode, \"operating-range-celsius\",\n\t\t\t\t\t    min_max, ARRAY_SIZE(min_max))) {\n\t\tinfo->temp_min = min_max[0];\n\t\tinfo->temp_max = min_max[1];\n\t}\n\n\t \n\tif (!battery_np)\n\t\tgoto out_ret_pointer;\n\n\tlen = of_property_count_u32_elems(battery_np, \"ocv-capacity-celsius\");\n\tif (len < 0 && len != -EINVAL) {\n\t\terr = len;\n\t\tgoto out_put_node;\n\t} else if (len > POWER_SUPPLY_OCV_TEMP_MAX) {\n\t\tdev_err(&psy->dev, \"Too many temperature values\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_put_node;\n\t} else if (len > 0) {\n\t\tof_property_read_u32_array(battery_np, \"ocv-capacity-celsius\",\n\t\t\t\t\t   info->ocv_temp, len);\n\t}\n\n\tfor (index = 0; index < len; index++) {\n\t\tstruct power_supply_battery_ocv_table *table;\n\t\tchar *propname;\n\t\tint i, tab_len, size;\n\n\t\tpropname = kasprintf(GFP_KERNEL, \"ocv-capacity-table-%d\", index);\n\t\tif (!propname) {\n\t\t\tpower_supply_put_battery_info(psy, info);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_put_node;\n\t\t}\n\t\tlist = of_get_property(battery_np, propname, &size);\n\t\tif (!list || !size) {\n\t\t\tdev_err(&psy->dev, \"failed to get %s\\n\", propname);\n\t\t\tkfree(propname);\n\t\t\tpower_supply_put_battery_info(psy, info);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_node;\n\t\t}\n\n\t\tkfree(propname);\n\t\ttab_len = size / (2 * sizeof(__be32));\n\t\tinfo->ocv_table_size[index] = tab_len;\n\n\t\ttable = info->ocv_table[index] =\n\t\t\tdevm_kcalloc(&psy->dev, tab_len, sizeof(*table), GFP_KERNEL);\n\t\tif (!info->ocv_table[index]) {\n\t\t\tpower_supply_put_battery_info(psy, info);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_put_node;\n\t\t}\n\n\t\tfor (i = 0; i < tab_len; i++) {\n\t\t\ttable[i].ocv = be32_to_cpu(*list);\n\t\t\tlist++;\n\t\t\ttable[i].capacity = be32_to_cpu(*list);\n\t\t\tlist++;\n\t\t}\n\t}\n\n\tlist = of_get_property(battery_np, \"resistance-temp-table\", &len);\n\tif (!list || !len)\n\t\tgoto out_ret_pointer;\n\n\tinfo->resist_table_size = len / (2 * sizeof(__be32));\n\tresist_table = info->resist_table = devm_kcalloc(&psy->dev,\n\t\t\t\t\t\t\t info->resist_table_size,\n\t\t\t\t\t\t\t sizeof(*resist_table),\n\t\t\t\t\t\t\t GFP_KERNEL);\n\tif (!info->resist_table) {\n\t\tpower_supply_put_battery_info(psy, info);\n\t\terr = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tfor (index = 0; index < info->resist_table_size; index++) {\n\t\tresist_table[index].temp = be32_to_cpu(*list++);\n\t\tresist_table[index].resistance = be32_to_cpu(*list++);\n\t}\n\nout_ret_pointer:\n\t \n\t*info_out = info;\n\nout_put_node:\n\tfwnode_handle_put(fwnode);\n\tof_node_put(battery_np);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_battery_info);\n\nvoid power_supply_put_battery_info(struct power_supply *psy,\n\t\t\t\t   struct power_supply_battery_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < POWER_SUPPLY_OCV_TEMP_MAX; i++) {\n\t\tif (info->ocv_table[i])\n\t\t\tdevm_kfree(&psy->dev, info->ocv_table[i]);\n\t}\n\n\tif (info->resist_table)\n\t\tdevm_kfree(&psy->dev, info->resist_table);\n\n\tdevm_kfree(&psy->dev, info);\n}\nEXPORT_SYMBOL_GPL(power_supply_put_battery_info);\n\nconst enum power_supply_property power_supply_battery_info_properties[] = {\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_TEMP_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_MAX,\n};\nEXPORT_SYMBOL_GPL(power_supply_battery_info_properties);\n\nconst size_t power_supply_battery_info_properties_size = ARRAY_SIZE(power_supply_battery_info_properties);\nEXPORT_SYMBOL_GPL(power_supply_battery_info_properties_size);\n\nbool power_supply_battery_info_has_prop(struct power_supply_battery_info *info,\n\t\t\t\t        enum power_supply_property psp)\n{\n\tif (!info)\n\t\treturn false;\n\n\tswitch (psp) {\n\t\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t\treturn info->technology != POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\t\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\t\treturn info->energy_full_design_uwh >= 0;\n\t\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\t\treturn info->charge_full_design_uah >= 0;\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\t\treturn info->voltage_min_design_uv >= 0;\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\t\treturn info->voltage_max_design_uv >= 0;\n\t\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\t\treturn info->precharge_current_ua >= 0;\n\t\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\t\treturn info->charge_term_current_ua >= 0;\n\t\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\t\treturn info->constant_charge_current_max_ua >= 0;\n\t\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\t\treturn info->constant_charge_voltage_max_uv >= 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:\n\t\t\treturn info->temp_ambient_alert_min > INT_MIN;\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:\n\t\t\treturn info->temp_ambient_alert_max < INT_MAX;\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\t\treturn info->temp_alert_min > INT_MIN;\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\t\treturn info->temp_alert_max < INT_MAX;\n\t\tcase POWER_SUPPLY_PROP_TEMP_MIN:\n\t\t\treturn info->temp_min > INT_MIN;\n\t\tcase POWER_SUPPLY_PROP_TEMP_MAX:\n\t\t\treturn info->temp_max < INT_MAX;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL_GPL(power_supply_battery_info_has_prop);\n\nint power_supply_battery_info_get_prop(struct power_supply_battery_info *info,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tif (!power_supply_battery_info_has_prop(info, psp))\n\t\treturn -EINVAL;\n\n\tswitch (psp) {\n\t\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t\tval->intval = info->technology;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\t\tval->intval = info->energy_full_design_uwh;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\t\tval->intval = info->charge_full_design_uah;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\t\tval->intval = info->voltage_min_design_uv;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\t\tval->intval = info->voltage_max_design_uv;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\t\tval->intval = info->precharge_current_ua;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\t\tval->intval = info->charge_term_current_ua;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\t\tval->intval = info->constant_charge_current_max_ua;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\t\tval->intval = info->constant_charge_voltage_max_uv;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:\n\t\t\tval->intval = info->temp_ambient_alert_min;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:\n\t\t\tval->intval = info->temp_ambient_alert_max;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\t\tval->intval = info->temp_alert_min;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\t\tval->intval = info->temp_alert_max;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_MIN:\n\t\t\tval->intval = info->temp_min;\n\t\t\treturn 0;\n\t\tcase POWER_SUPPLY_PROP_TEMP_MAX:\n\t\t\tval->intval = info->temp_max;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(power_supply_battery_info_get_prop);\n\n \nint power_supply_temp2resist_simple(struct power_supply_resistance_temp_table *table,\n\t\t\t\t    int table_len, int temp)\n{\n\tint i, high, low;\n\n\tfor (i = 0; i < table_len; i++)\n\t\tif (temp > table[i].temp)\n\t\t\tbreak;\n\n\t \n\tif (i == 0)\n\t\thigh = low = i;\n\telse if (i == table_len)\n\t\thigh = low = i - 1;\n\telse\n\t\thigh = (low = i) - 1;\n\n\treturn fixp_linear_interpolate(table[low].temp,\n\t\t\t\t       table[low].resistance,\n\t\t\t\t       table[high].temp,\n\t\t\t\t       table[high].resistance,\n\t\t\t\t       temp);\n}\nEXPORT_SYMBOL_GPL(power_supply_temp2resist_simple);\n\n \nint power_supply_vbat2ri(struct power_supply_battery_info *info,\n\t\t\t int vbat_uv, bool charging)\n{\n\tstruct power_supply_vbat_ri_table *vbat2ri;\n\tint table_len;\n\tint i, high, low;\n\n\t \n\tif (charging && info->vbat2ri_charging) {\n\t\tvbat2ri = info->vbat2ri_charging;\n\t\ttable_len = info->vbat2ri_charging_size;\n\t} else {\n\t\tvbat2ri = info->vbat2ri_discharging;\n\t\ttable_len = info->vbat2ri_discharging_size;\n\t}\n\n\t \n\tif (!vbat2ri || (table_len <= 0) || (vbat_uv > vbat2ri[0].vbat_uv)) {\n\t\tif (charging && (info->factory_internal_resistance_charging_uohm > 0))\n\t\t\treturn info->factory_internal_resistance_charging_uohm;\n\t\telse\n\t\t\treturn info->factory_internal_resistance_uohm;\n\t}\n\n\t \n\tfor (i = 0; i < table_len - 1; i++)\n\t\tif (vbat_uv > vbat2ri[i].vbat_uv)\n\t\t\tbreak;\n\n\t \n\tif ((i == 0) || (i == (table_len - 1)))\n\t\thigh = i;\n\telse\n\t\thigh = i - 1;\n\tlow = i;\n\n\treturn fixp_linear_interpolate(vbat2ri[low].vbat_uv,\n\t\t\t\t       vbat2ri[low].ri_uohm,\n\t\t\t\t       vbat2ri[high].vbat_uv,\n\t\t\t\t       vbat2ri[high].ri_uohm,\n\t\t\t\t       vbat_uv);\n}\nEXPORT_SYMBOL_GPL(power_supply_vbat2ri);\n\nstruct power_supply_maintenance_charge_table *\npower_supply_get_maintenance_charging_setting(struct power_supply_battery_info *info,\n\t\t\t\t\t      int index)\n{\n\tif (index >= info->maintenance_charge_size)\n\t\treturn NULL;\n\treturn &info->maintenance_charge[index];\n}\nEXPORT_SYMBOL_GPL(power_supply_get_maintenance_charging_setting);\n\n \nint power_supply_ocv2cap_simple(struct power_supply_battery_ocv_table *table,\n\t\t\t\tint table_len, int ocv)\n{\n\tint i, high, low;\n\n\tfor (i = 0; i < table_len; i++)\n\t\tif (ocv > table[i].ocv)\n\t\t\tbreak;\n\n\t \n\tif (i == 0)\n\t\thigh = low = i;\n\telse if (i == table_len)\n\t\thigh = low = i - 1;\n\telse\n\t\thigh = (low = i) - 1;\n\n\treturn fixp_linear_interpolate(table[low].ocv,\n\t\t\t\t       table[low].capacity,\n\t\t\t\t       table[high].ocv,\n\t\t\t\t       table[high].capacity,\n\t\t\t\t       ocv);\n}\nEXPORT_SYMBOL_GPL(power_supply_ocv2cap_simple);\n\nstruct power_supply_battery_ocv_table *\npower_supply_find_ocv2cap_table(struct power_supply_battery_info *info,\n\t\t\t\tint temp, int *table_len)\n{\n\tint best_temp_diff = INT_MAX, temp_diff;\n\tu8 i, best_index = 0;\n\n\tif (!info->ocv_table[0])\n\t\treturn NULL;\n\n\tfor (i = 0; i < POWER_SUPPLY_OCV_TEMP_MAX; i++) {\n\t\t \n\t\tif (!info->ocv_table[i])\n\t\t\tbreak;\n\n\t\ttemp_diff = abs(info->ocv_temp[i] - temp);\n\n\t\tif (temp_diff < best_temp_diff) {\n\t\t\tbest_temp_diff = temp_diff;\n\t\t\tbest_index = i;\n\t\t}\n\t}\n\n\t*table_len = info->ocv_table_size[best_index];\n\treturn info->ocv_table[best_index];\n}\nEXPORT_SYMBOL_GPL(power_supply_find_ocv2cap_table);\n\nint power_supply_batinfo_ocv2cap(struct power_supply_battery_info *info,\n\t\t\t\t int ocv, int temp)\n{\n\tstruct power_supply_battery_ocv_table *table;\n\tint table_len;\n\n\ttable = power_supply_find_ocv2cap_table(info, temp, &table_len);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\treturn power_supply_ocv2cap_simple(table, table_len, ocv);\n}\nEXPORT_SYMBOL_GPL(power_supply_batinfo_ocv2cap);\n\nbool power_supply_battery_bti_in_range(struct power_supply_battery_info *info,\n\t\t\t\t       int resistance)\n{\n\tint low, high;\n\n\t \n\tif (info->bti_resistance_ohm <= 0)\n\t\treturn false;\n\n\t \n\tif (info->bti_resistance_tolerance <= 0)\n\t\treturn (info->bti_resistance_ohm == resistance);\n\n\tlow = info->bti_resistance_ohm -\n\t\t(info->bti_resistance_ohm * info->bti_resistance_tolerance) / 100;\n\thigh = info->bti_resistance_ohm +\n\t\t(info->bti_resistance_ohm * info->bti_resistance_tolerance) / 100;\n\n\treturn ((resistance >= low) && (resistance <= high));\n}\nEXPORT_SYMBOL_GPL(power_supply_battery_bti_in_range);\n\nstatic bool psy_has_property(const struct power_supply_desc *psy_desc,\n\t\t\t     enum power_supply_property psp)\n{\n\tbool found = false;\n\tint i;\n\n\tfor (i = 0; i < psy_desc->num_properties; i++) {\n\t\tif (psy_desc->properties[i] == psp) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nint power_supply_get_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tif (atomic_read(&psy->use_cnt) <= 0) {\n\t\tif (!psy->initialized)\n\t\t\treturn -EAGAIN;\n\t\treturn -ENODEV;\n\t}\n\n\tif (psy_has_property(psy->desc, psp))\n\t\treturn psy->desc->get_property(psy, psp, val);\n\telse if (power_supply_battery_info_has_prop(psy->battery_info, psp))\n\t\treturn power_supply_battery_info_get_prop(psy->battery_info, psp, val);\n\telse\n\t\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_property);\n\nint power_supply_set_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    const union power_supply_propval *val)\n{\n\tif (atomic_read(&psy->use_cnt) <= 0 || !psy->desc->set_property)\n\t\treturn -ENODEV;\n\n\treturn psy->desc->set_property(psy, psp, val);\n}\nEXPORT_SYMBOL_GPL(power_supply_set_property);\n\nint power_supply_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp)\n{\n\tif (atomic_read(&psy->use_cnt) <= 0 ||\n\t\t\t!psy->desc->property_is_writeable)\n\t\treturn -ENODEV;\n\n\treturn psy->desc->property_is_writeable(psy, psp);\n}\nEXPORT_SYMBOL_GPL(power_supply_property_is_writeable);\n\nvoid power_supply_external_power_changed(struct power_supply *psy)\n{\n\tif (atomic_read(&psy->use_cnt) <= 0 ||\n\t\t\t!psy->desc->external_power_changed)\n\t\treturn;\n\n\tpsy->desc->external_power_changed(psy);\n}\nEXPORT_SYMBOL_GPL(power_supply_external_power_changed);\n\nint power_supply_powers(struct power_supply *psy, struct device *dev)\n{\n\treturn sysfs_create_link(&psy->dev.kobj, &dev->kobj, \"powers\");\n}\nEXPORT_SYMBOL_GPL(power_supply_powers);\n\nstatic void power_supply_dev_release(struct device *dev)\n{\n\tstruct power_supply *psy = to_power_supply(dev);\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tkfree(psy);\n}\n\nint power_supply_reg_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&power_supply_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(power_supply_reg_notifier);\n\nvoid power_supply_unreg_notifier(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&power_supply_notifier, nb);\n}\nEXPORT_SYMBOL_GPL(power_supply_unreg_notifier);\n\n#ifdef CONFIG_THERMAL\nstatic int power_supply_read_temp(struct thermal_zone_device *tzd,\n\t\tint *temp)\n{\n\tstruct power_supply *psy;\n\tunion power_supply_propval val;\n\tint ret;\n\n\tWARN_ON(tzd == NULL);\n\tpsy = thermal_zone_device_priv(tzd);\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_TEMP, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*temp = val.intval * 100;\n\n\treturn ret;\n}\n\nstatic struct thermal_zone_device_ops psy_tzd_ops = {\n\t.get_temp = power_supply_read_temp,\n};\n\nstatic int psy_register_thermal(struct power_supply *psy)\n{\n\tint ret;\n\n\tif (psy->desc->no_thermal)\n\t\treturn 0;\n\n\t \n\tif (psy_has_property(psy->desc, POWER_SUPPLY_PROP_TEMP)) {\n\t\t \n\t\tstruct thermal_zone_params tzp = {\n\t\t\t.no_hwmon = IS_ENABLED(CONFIG_POWER_SUPPLY_HWMON)\n\t\t};\n\t\tpsy->tzd = thermal_tripless_zone_device_register(psy->desc->name,\n\t\t\t\tpsy, &psy_tzd_ops, &tzp);\n\t\tif (IS_ERR(psy->tzd))\n\t\t\treturn PTR_ERR(psy->tzd);\n\t\tret = thermal_zone_device_enable(psy->tzd);\n\t\tif (ret)\n\t\t\tthermal_zone_device_unregister(psy->tzd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void psy_unregister_thermal(struct power_supply *psy)\n{\n\tif (IS_ERR_OR_NULL(psy->tzd))\n\t\treturn;\n\tthermal_zone_device_unregister(psy->tzd);\n}\n\n#else\nstatic int psy_register_thermal(struct power_supply *psy)\n{\n\treturn 0;\n}\n\nstatic void psy_unregister_thermal(struct power_supply *psy)\n{\n}\n#endif\n\nstatic struct power_supply *__must_check\n__power_supply_register(struct device *parent,\n\t\t\t\t   const struct power_supply_desc *desc,\n\t\t\t\t   const struct power_supply_config *cfg,\n\t\t\t\t   bool ws)\n{\n\tstruct device *dev;\n\tstruct power_supply *psy;\n\tint rc;\n\n\tif (!desc || !desc->name || !desc->properties || !desc->num_properties)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!parent)\n\t\tpr_warn(\"%s: Expected proper parent device for '%s'\\n\",\n\t\t\t__func__, desc->name);\n\n\tif (psy_has_property(desc, POWER_SUPPLY_PROP_USB_TYPE) &&\n\t    (!desc->usb_types || !desc->num_usb_types))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpsy = kzalloc(sizeof(*psy), GFP_KERNEL);\n\tif (!psy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = &psy->dev;\n\n\tdevice_initialize(dev);\n\n\tdev->class = power_supply_class;\n\tdev->type = &power_supply_dev_type;\n\tdev->parent = parent;\n\tdev->release = power_supply_dev_release;\n\tdev_set_drvdata(dev, psy);\n\tpsy->desc = desc;\n\tif (cfg) {\n\t\tdev->groups = cfg->attr_grp;\n\t\tpsy->drv_data = cfg->drv_data;\n\t\tpsy->of_node =\n\t\t\tcfg->fwnode ? to_of_node(cfg->fwnode) : cfg->of_node;\n\t\tpsy->supplied_to = cfg->supplied_to;\n\t\tpsy->num_supplicants = cfg->num_supplicants;\n\t}\n\n\trc = dev_set_name(dev, \"%s\", desc->name);\n\tif (rc)\n\t\tgoto dev_set_name_failed;\n\n\tINIT_WORK(&psy->changed_work, power_supply_changed_work);\n\tINIT_DELAYED_WORK(&psy->deferred_register_work,\n\t\t\t  power_supply_deferred_register_work);\n\n\trc = power_supply_check_supplies(psy);\n\tif (rc) {\n\t\tdev_dbg(dev, \"Not all required supplies found, defer probe\\n\");\n\t\tgoto check_supplies_failed;\n\t}\n\n\t \n\tif (desc->type == POWER_SUPPLY_TYPE_BATTERY) {\n\t\trc = power_supply_get_battery_info(psy, &psy->battery_info);\n\t\tif (rc && rc != -ENODEV && rc != -ENOENT)\n\t\t\tgoto check_supplies_failed;\n\t}\n\n\tspin_lock_init(&psy->changed_lock);\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto device_add_failed;\n\n\trc = device_init_wakeup(dev, ws);\n\tif (rc)\n\t\tgoto wakeup_init_failed;\n\n\trc = psy_register_thermal(psy);\n\tif (rc)\n\t\tgoto register_thermal_failed;\n\n\trc = power_supply_create_triggers(psy);\n\tif (rc)\n\t\tgoto create_triggers_failed;\n\n\trc = power_supply_add_hwmon_sysfs(psy);\n\tif (rc)\n\t\tgoto add_hwmon_sysfs_failed;\n\n\t \n\tatomic_inc(&psy->use_cnt);\n\tpsy->initialized = true;\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &psy->deferred_register_work,\n\t\t\t   POWER_SUPPLY_DEFERRED_REGISTER_TIME);\n\n\treturn psy;\n\nadd_hwmon_sysfs_failed:\n\tpower_supply_remove_triggers(psy);\ncreate_triggers_failed:\n\tpsy_unregister_thermal(psy);\nregister_thermal_failed:\nwakeup_init_failed:\n\tdevice_del(dev);\ndevice_add_failed:\ncheck_supplies_failed:\ndev_set_name_failed:\n\tput_device(dev);\n\treturn ERR_PTR(rc);\n}\n\n \nstruct power_supply *__must_check power_supply_register(struct device *parent,\n\t\tconst struct power_supply_desc *desc,\n\t\tconst struct power_supply_config *cfg)\n{\n\treturn __power_supply_register(parent, desc, cfg, true);\n}\nEXPORT_SYMBOL_GPL(power_supply_register);\n\n \nstruct power_supply *__must_check\npower_supply_register_no_ws(struct device *parent,\n\t\tconst struct power_supply_desc *desc,\n\t\tconst struct power_supply_config *cfg)\n{\n\treturn __power_supply_register(parent, desc, cfg, false);\n}\nEXPORT_SYMBOL_GPL(power_supply_register_no_ws);\n\nstatic void devm_power_supply_release(struct device *dev, void *res)\n{\n\tstruct power_supply **psy = res;\n\n\tpower_supply_unregister(*psy);\n}\n\n \nstruct power_supply *__must_check\ndevm_power_supply_register(struct device *parent,\n\t\tconst struct power_supply_desc *desc,\n\t\tconst struct power_supply_config *cfg)\n{\n\tstruct power_supply **ptr, *psy;\n\n\tptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);\n\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpsy = __power_supply_register(parent, desc, cfg, true);\n\tif (IS_ERR(psy)) {\n\t\tdevres_free(ptr);\n\t} else {\n\t\t*ptr = psy;\n\t\tdevres_add(parent, ptr);\n\t}\n\treturn psy;\n}\nEXPORT_SYMBOL_GPL(devm_power_supply_register);\n\n \nstruct power_supply *__must_check\ndevm_power_supply_register_no_ws(struct device *parent,\n\t\tconst struct power_supply_desc *desc,\n\t\tconst struct power_supply_config *cfg)\n{\n\tstruct power_supply **ptr, *psy;\n\n\tptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);\n\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpsy = __power_supply_register(parent, desc, cfg, false);\n\tif (IS_ERR(psy)) {\n\t\tdevres_free(ptr);\n\t} else {\n\t\t*ptr = psy;\n\t\tdevres_add(parent, ptr);\n\t}\n\treturn psy;\n}\nEXPORT_SYMBOL_GPL(devm_power_supply_register_no_ws);\n\n \nvoid power_supply_unregister(struct power_supply *psy)\n{\n\tWARN_ON(atomic_dec_return(&psy->use_cnt));\n\tpsy->removing = true;\n\tcancel_work_sync(&psy->changed_work);\n\tcancel_delayed_work_sync(&psy->deferred_register_work);\n\tsysfs_remove_link(&psy->dev.kobj, \"powers\");\n\tpower_supply_remove_hwmon_sysfs(psy);\n\tpower_supply_remove_triggers(psy);\n\tpsy_unregister_thermal(psy);\n\tdevice_init_wakeup(&psy->dev, false);\n\tdevice_unregister(&psy->dev);\n}\nEXPORT_SYMBOL_GPL(power_supply_unregister);\n\nvoid *power_supply_get_drvdata(struct power_supply *psy)\n{\n\treturn psy->drv_data;\n}\nEXPORT_SYMBOL_GPL(power_supply_get_drvdata);\n\nstatic int __init power_supply_class_init(void)\n{\n\tpower_supply_class = class_create(\"power_supply\");\n\n\tif (IS_ERR(power_supply_class))\n\t\treturn PTR_ERR(power_supply_class);\n\n\tpower_supply_class->dev_uevent = power_supply_uevent;\n\tpower_supply_init_attrs(&power_supply_dev_type);\n\n\treturn 0;\n}\n\nstatic void __exit power_supply_class_exit(void)\n{\n\tclass_destroy(power_supply_class);\n}\n\nsubsys_initcall(power_supply_class_init);\nmodule_exit(power_supply_class_exit);\n\nMODULE_DESCRIPTION(\"Universal power supply monitor class\");\nMODULE_AUTHOR(\"Ian Molton <spyro@f2s.com>, \"\n\t      \"Szabolcs Gyurko, \"\n\t      \"Anton Vorontsov <cbou@mail.ru>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}