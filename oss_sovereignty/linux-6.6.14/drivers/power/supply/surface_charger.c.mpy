{
  "module_name": "surface_charger.c",
  "hash_id": "a2e97600b9e794249e2343a5f441b0944e1d67caa79f9052f744d1fce8f294c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/surface_charger.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <linux/types.h>\n\n#include <linux/surface_aggregator/device.h>\n\n\n \n\nenum sam_event_cid_bat {\n\tSAM_EVENT_CID_BAT_ADP   = 0x17,\n};\n\nenum sam_battery_sta {\n\tSAM_BATTERY_STA_OK      = 0x0f,\n\tSAM_BATTERY_STA_PRESENT\t= 0x10,\n};\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_R(ssam_bat_get_sta, __le32, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x01,\n});\n\n \nSSAM_DEFINE_SYNC_REQUEST_CL_R(ssam_bat_get_psrc, __le32, {\n\t.target_category = SSAM_SSH_TC_BAT,\n\t.command_id      = 0x0d,\n});\n\n\n \n\nstruct spwr_psy_properties {\n\tconst char *name;\n\tstruct ssam_event_registry registry;\n};\n\nstruct spwr_ac_device {\n\tstruct ssam_device *sdev;\n\n\tchar name[32];\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\n\tstruct ssam_event_notifier notif;\n\n\tstruct mutex lock;   \n\n\t__le32 state;\n};\n\n\n \n\nstatic int spwr_ac_update_unlocked(struct spwr_ac_device *ac)\n{\n\t__le32 old = ac->state;\n\tint status;\n\n\tlockdep_assert_held(&ac->lock);\n\n\tstatus = ssam_retry(ssam_bat_get_psrc, ac->sdev, &ac->state);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn old != ac->state;\n}\n\nstatic int spwr_ac_update(struct spwr_ac_device *ac)\n{\n\tint status;\n\n\tmutex_lock(&ac->lock);\n\tstatus = spwr_ac_update_unlocked(ac);\n\tmutex_unlock(&ac->lock);\n\n\treturn status;\n}\n\nstatic int spwr_ac_recheck(struct spwr_ac_device *ac)\n{\n\tint status;\n\n\tstatus = spwr_ac_update(ac);\n\tif (status > 0)\n\t\tpower_supply_changed(ac->psy);\n\n\treturn status >= 0 ? 0 : status;\n}\n\nstatic u32 spwr_notify_ac(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct spwr_ac_device *ac;\n\tint status;\n\n\tac = container_of(nf, struct spwr_ac_device, notif);\n\n\tdev_dbg(&ac->sdev->dev, \"power event (cid = %#04x, iid = %#04x, tid = %#04x)\\n\",\n\t\tevent->command_id, event->instance_id, event->target_id);\n\n\t \n\n\tswitch (event->command_id) {\n\tcase SAM_EVENT_CID_BAT_ADP:\n\t\tstatus = spwr_ac_recheck(ac);\n\t\treturn ssam_notifier_from_errno(status) | SSAM_NOTIF_HANDLED;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n \n\nstatic const enum power_supply_property spwr_ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic int spwr_ac_get_property(struct power_supply *psy, enum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct spwr_ac_device *ac = power_supply_get_drvdata(psy);\n\tint status;\n\n\tmutex_lock(&ac->lock);\n\n\tstatus = spwr_ac_update_unlocked(ac);\n\tif (status)\n\t\tgoto out;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = !!le32_to_cpu(ac->state);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ac->lock);\n\treturn status;\n}\n\n\n \n\nstatic char *battery_supplied_to[] = {\n\t\"BAT1\",\n\t\"BAT2\",\n};\n\nstatic void spwr_ac_init(struct spwr_ac_device *ac, struct ssam_device *sdev,\n\t\t\t struct ssam_event_registry registry, const char *name)\n{\n\tmutex_init(&ac->lock);\n\tstrncpy(ac->name, name, ARRAY_SIZE(ac->name) - 1);\n\n\tac->sdev = sdev;\n\n\tac->notif.base.priority = 1;\n\tac->notif.base.fn = spwr_notify_ac;\n\tac->notif.event.reg = registry;\n\tac->notif.event.id.target_category = sdev->uid.category;\n\tac->notif.event.id.instance = 0;\n\tac->notif.event.mask = SSAM_EVENT_MASK_NONE;\n\tac->notif.event.flags = SSAM_EVENT_SEQUENCED;\n\n\tac->psy_desc.name = ac->name;\n\tac->psy_desc.type = POWER_SUPPLY_TYPE_MAINS;\n\tac->psy_desc.properties = spwr_ac_props;\n\tac->psy_desc.num_properties = ARRAY_SIZE(spwr_ac_props);\n\tac->psy_desc.get_property = spwr_ac_get_property;\n}\n\nstatic int spwr_ac_register(struct spwr_ac_device *ac)\n{\n\tstruct power_supply_config psy_cfg = {};\n\t__le32 sta;\n\tint status;\n\n\t \n\tstatus = ssam_retry(ssam_bat_get_sta, ac->sdev, &sta);\n\tif (status)\n\t\treturn status;\n\n\tif ((le32_to_cpu(sta) & SAM_BATTERY_STA_OK) != SAM_BATTERY_STA_OK)\n\t\treturn -ENODEV;\n\n\tpsy_cfg.drv_data = ac;\n\tpsy_cfg.supplied_to = battery_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);\n\n\tac->psy = devm_power_supply_register(&ac->sdev->dev, &ac->psy_desc, &psy_cfg);\n\tif (IS_ERR(ac->psy))\n\t\treturn PTR_ERR(ac->psy);\n\n\treturn ssam_device_notifier_register(ac->sdev, &ac->notif);\n}\n\n\n \n\nstatic int __maybe_unused surface_ac_resume(struct device *dev)\n{\n\treturn spwr_ac_recheck(dev_get_drvdata(dev));\n}\nstatic SIMPLE_DEV_PM_OPS(surface_ac_pm_ops, NULL, surface_ac_resume);\n\nstatic int surface_ac_probe(struct ssam_device *sdev)\n{\n\tconst struct spwr_psy_properties *p;\n\tstruct spwr_ac_device *ac;\n\n\tp = ssam_device_get_match_data(sdev);\n\tif (!p)\n\t\treturn -ENODEV;\n\n\tac = devm_kzalloc(&sdev->dev, sizeof(*ac), GFP_KERNEL);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tspwr_ac_init(ac, sdev, p->registry, p->name);\n\tssam_device_set_drvdata(sdev, ac);\n\n\treturn spwr_ac_register(ac);\n}\n\nstatic void surface_ac_remove(struct ssam_device *sdev)\n{\n\tstruct spwr_ac_device *ac = ssam_device_get_drvdata(sdev);\n\n\tssam_device_notifier_unregister(sdev, &ac->notif);\n}\n\nstatic const struct spwr_psy_properties spwr_psy_props_adp1 = {\n\t.name = \"ADP1\",\n\t.registry = SSAM_EVENT_REGISTRY_SAM,\n};\n\nstatic const struct ssam_device_id surface_ac_match[] = {\n\t{ SSAM_SDEV(BAT, SAM, 0x01, 0x01), (unsigned long)&spwr_psy_props_adp1 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(ssam, surface_ac_match);\n\nstatic struct ssam_device_driver surface_ac_driver = {\n\t.probe = surface_ac_probe,\n\t.remove = surface_ac_remove,\n\t.match_table = surface_ac_match,\n\t.driver = {\n\t\t.name = \"surface_ac\",\n\t\t.pm = &surface_ac_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_ssam_device_driver(surface_ac_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"AC driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}