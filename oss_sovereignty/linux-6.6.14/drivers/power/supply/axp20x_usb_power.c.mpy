{
  "module_name": "axp20x_usb_power.c",
  "hash_id": "cf28e778049f9d572afc993c60a85e78f11d42a198c83f862ddf8f95e748b1d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/axp20x_usb_power.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/devm-helpers.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/iio/consumer.h>\n#include <linux/workqueue.h>\n\n#define DRVNAME \"axp20x-usb-power-supply\"\n\n#define AXP192_USB_OTG_STATUS\t\t0x04\n\n#define AXP20X_PWR_STATUS_VBUS_PRESENT\tBIT(5)\n#define AXP20X_PWR_STATUS_VBUS_USED\tBIT(4)\n\n#define AXP20X_USB_STATUS_VBUS_VALID\tBIT(2)\n\n#define AXP20X_VBUS_VHOLD_uV(b)\t\t(4000000 + (((b) >> 3) & 7) * 100000)\n#define AXP20X_VBUS_VHOLD_MASK\t\tGENMASK(5, 3)\n#define AXP20X_VBUS_VHOLD_OFFSET\t3\n\n#define AXP20X_ADC_EN1_VBUS_CURR\tBIT(2)\n#define AXP20X_ADC_EN1_VBUS_VOLT\tBIT(3)\n\n \n#define DEBOUNCE_TIME\t\t\tmsecs_to_jiffies(50)\n\nstruct axp_data {\n\tconst struct power_supply_desc\t*power_desc;\n\tconst char * const\t\t*irq_names;\n\tunsigned int\t\t\tnum_irq_names;\n\tconst int\t\t\t*curr_lim_table;\n\tstruct reg_field\t\tcurr_lim_fld;\n\tstruct reg_field\t\tvbus_valid_bit;\n\tstruct reg_field\t\tvbus_mon_bit;\n\tstruct reg_field\t\tusb_bc_en_bit;\n\tstruct reg_field\t\tvbus_disable_bit;\n\tbool\t\t\t\tvbus_needs_polling: 1;\n};\n\nstruct axp20x_usb_power {\n\tstruct regmap *regmap;\n\tstruct regmap_field *curr_lim_fld;\n\tstruct regmap_field *vbus_valid_bit;\n\tstruct regmap_field *vbus_mon_bit;\n\tstruct regmap_field *usb_bc_en_bit;\n\tstruct regmap_field *vbus_disable_bit;\n\tstruct power_supply *supply;\n\tconst struct axp_data *axp_data;\n\tstruct iio_channel *vbus_v;\n\tstruct iio_channel *vbus_i;\n\tstruct delayed_work vbus_detect;\n\tunsigned int old_status;\n\tunsigned int online;\n\tunsigned int num_irqs;\n\tunsigned int irqs[];\n};\n\nstatic bool axp20x_usb_vbus_needs_polling(struct axp20x_usb_power *power)\n{\n\t \n\tif (power->axp_data->vbus_needs_polling && !power->online)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic irqreturn_t axp20x_usb_power_irq(int irq, void *devid)\n{\n\tstruct axp20x_usb_power *power = devid;\n\n\tpower_supply_changed(power->supply);\n\n\tmod_delayed_work(system_power_efficient_wq, &power->vbus_detect, DEBOUNCE_TIME);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void axp20x_usb_power_poll_vbus(struct work_struct *work)\n{\n\tstruct axp20x_usb_power *power =\n\t\tcontainer_of(work, struct axp20x_usb_power, vbus_detect.work);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &val);\n\tif (ret)\n\t\tgoto out;\n\n\tval &= (AXP20X_PWR_STATUS_VBUS_PRESENT | AXP20X_PWR_STATUS_VBUS_USED);\n\tif (val != power->old_status)\n\t\tpower_supply_changed(power->supply);\n\n\tpower->old_status = val;\n\tpower->online = val & AXP20X_PWR_STATUS_VBUS_USED;\n\nout:\n\tif (axp20x_usb_vbus_needs_polling(power))\n\t\tmod_delayed_work(system_power_efficient_wq, &power->vbus_detect, DEBOUNCE_TIME);\n}\n\nstatic int axp20x_usb_power_get_property(struct power_supply *psy,\n\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\n\tunsigned int input, v;\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tret = regmap_read(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, &v);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = AXP20X_VBUS_VHOLD_uV(v);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tif (IS_ENABLED(CONFIG_AXP20X_ADC)) {\n\t\t\tret = iio_read_channel_processed(power->vbus_v,\n\t\t\t\t\t\t\t &val->intval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tval->intval *= 1000;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = axp20x_read_variable_width(power->regmap,\n\t\t\t\t\t\t AXP20X_VBUS_V_ADC_H, 12);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret * 1700;  \n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tret = regmap_field_read(power->curr_lim_fld, &v);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = power->axp_data->curr_lim_table[v];\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (IS_ENABLED(CONFIG_AXP20X_ADC)) {\n\t\t\tret = iio_read_channel_processed(power->vbus_i,\n\t\t\t\t\t\t\t &val->intval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tval->intval *= 1000;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = axp20x_read_variable_width(power->regmap,\n\t\t\t\t\t\t AXP20X_VBUS_I_ADC_H, 12);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret * 375;  \n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &input);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (!(input & AXP20X_PWR_STATUS_VBUS_PRESENT)) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\n\t\tif (power->vbus_valid_bit) {\n\t\t\tret = regmap_field_read(power->vbus_valid_bit, &v);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (v == 0)\n\t\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\t}\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_PRESENT);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_USED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int axp20x_usb_power_set_voltage_min(struct axp20x_usb_power *power,\n\t\t\t\t\t    int intval)\n{\n\tint val;\n\n\tswitch (intval) {\n\tcase 4000000:\n\tcase 4100000:\n\tcase 4200000:\n\tcase 4300000:\n\tcase 4400000:\n\tcase 4500000:\n\tcase 4600000:\n\tcase 4700000:\n\t\tval = (intval - 4000000) / 100000;\n\t\treturn regmap_update_bits(power->regmap,\n\t\t\t\t\t  AXP20X_VBUS_IPSOUT_MGMT,\n\t\t\t\t\t  AXP20X_VBUS_VHOLD_MASK,\n\t\t\t\t\t  val << AXP20X_VBUS_VHOLD_OFFSET);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int axp20x_usb_power_set_current_max(struct axp20x_usb_power *power, int intval)\n{\n\tconst unsigned int max = GENMASK(power->axp_data->curr_lim_fld.msb,\n\t\t\t\t\t power->axp_data->curr_lim_fld.lsb);\n\n\tif (intval == -1)\n\t\treturn -EINVAL;\n\n\tfor (unsigned int i = 0; i <= max; ++i)\n\t\tif (power->axp_data->curr_lim_table[i] == intval)\n\t\t\treturn regmap_field_write(power->curr_lim_fld, i);\n\n\treturn -EINVAL;\n}\n\nstatic int axp20x_usb_power_set_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t const union power_supply_propval *val)\n{\n\tstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tif (!power->vbus_disable_bit)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_field_write(power->vbus_disable_bit, !val->intval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\treturn axp20x_usb_power_set_voltage_min(power, val->intval);\n\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn axp20x_usb_power_set_current_max(power, val->intval);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int axp20x_usb_power_prop_writeable(struct power_supply *psy,\n\t\t\t\t\t   enum power_supply_property psp)\n{\n\tstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\n\n\t \n\tif (psp == POWER_SUPPLY_PROP_ONLINE)\n\t\treturn power->vbus_disable_bit != NULL;\n\n\treturn psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||\n\t       psp == POWER_SUPPLY_PROP_CURRENT_MAX;\n}\n\nstatic enum power_supply_property axp20x_usb_power_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic enum power_supply_property axp22x_usb_power_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n};\n\nstatic const struct power_supply_desc axp20x_usb_power_desc = {\n\t.name = \"axp20x-usb\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = axp20x_usb_power_properties,\n\t.num_properties = ARRAY_SIZE(axp20x_usb_power_properties),\n\t.property_is_writeable = axp20x_usb_power_prop_writeable,\n\t.get_property = axp20x_usb_power_get_property,\n\t.set_property = axp20x_usb_power_set_property,\n};\n\nstatic const struct power_supply_desc axp22x_usb_power_desc = {\n\t.name = \"axp20x-usb\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = axp22x_usb_power_properties,\n\t.num_properties = ARRAY_SIZE(axp22x_usb_power_properties),\n\t.property_is_writeable = axp20x_usb_power_prop_writeable,\n\t.get_property = axp20x_usb_power_get_property,\n\t.set_property = axp20x_usb_power_set_property,\n};\n\nstatic const char * const axp20x_irq_names[] = {\n\t\"VBUS_PLUGIN\",\n\t\"VBUS_REMOVAL\",\n\t\"VBUS_VALID\",\n\t\"VBUS_NOT_VALID\",\n};\n\nstatic const char * const axp22x_irq_names[] = {\n\t\"VBUS_PLUGIN\",\n\t\"VBUS_REMOVAL\",\n};\n\nstatic int axp192_usb_curr_lim_table[] = {\n\t-1,\n\t-1,\n\t500000,\n\t100000,\n};\n\nstatic int axp20x_usb_curr_lim_table[] = {\n\t900000,\n\t500000,\n\t100000,\n\t-1,\n};\n\nstatic int axp221_usb_curr_lim_table[] = {\n\t900000,\n\t500000,\n\t-1,\n\t-1,\n};\n\nstatic int axp813_usb_curr_lim_table[] = {\n\t900000,\n\t1500000,\n\t2000000,\n\t2500000,\n};\n\nstatic const struct axp_data axp192_data = {\n\t.power_desc\t= &axp20x_usb_power_desc,\n\t.irq_names\t= axp20x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp20x_irq_names),\n\t.curr_lim_table = axp192_usb_curr_lim_table,\n\t.curr_lim_fld   = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 0, 1),\n\t.vbus_valid_bit = REG_FIELD(AXP192_USB_OTG_STATUS, 2, 2),\n\t.vbus_mon_bit   = REG_FIELD(AXP20X_VBUS_MON, 3, 3),\n};\n\nstatic const struct axp_data axp202_data = {\n\t.power_desc\t= &axp20x_usb_power_desc,\n\t.irq_names\t= axp20x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp20x_irq_names),\n\t.curr_lim_table = axp20x_usb_curr_lim_table,\n\t.curr_lim_fld   = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 0, 1),\n\t.vbus_valid_bit = REG_FIELD(AXP20X_USB_OTG_STATUS, 2, 2),\n\t.vbus_mon_bit   = REG_FIELD(AXP20X_VBUS_MON, 3, 3),\n};\n\nstatic const struct axp_data axp221_data = {\n\t.power_desc\t= &axp22x_usb_power_desc,\n\t.irq_names\t= axp22x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp22x_irq_names),\n\t.curr_lim_table = axp221_usb_curr_lim_table,\n\t.curr_lim_fld   = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 0, 1),\n\t.vbus_needs_polling = true,\n};\n\nstatic const struct axp_data axp223_data = {\n\t.power_desc\t= &axp22x_usb_power_desc,\n\t.irq_names\t= axp22x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp22x_irq_names),\n\t.curr_lim_table = axp20x_usb_curr_lim_table,\n\t.curr_lim_fld   = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 0, 1),\n\t.vbus_needs_polling = true,\n};\n\nstatic const struct axp_data axp813_data = {\n\t.power_desc\t= &axp22x_usb_power_desc,\n\t.irq_names\t= axp22x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp22x_irq_names),\n\t.curr_lim_table = axp813_usb_curr_lim_table,\n\t.curr_lim_fld   = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 0, 1),\n\t.usb_bc_en_bit\t= REG_FIELD(AXP288_BC_GLOBAL, 0, 0),\n\t.vbus_disable_bit = REG_FIELD(AXP20X_VBUS_IPSOUT_MGMT, 7, 7),\n\t.vbus_needs_polling = true,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int axp20x_usb_power_suspend(struct device *dev)\n{\n\tstruct axp20x_usb_power *power = dev_get_drvdata(dev);\n\tint i = 0;\n\n\t \n\tif (device_may_wakeup(&power->supply->dev))\n\t\tenable_irq_wake(power->irqs[i++]);\n\twhile (i < power->num_irqs)\n\t\tdisable_irq(power->irqs[i++]);\n\n\treturn 0;\n}\n\nstatic int axp20x_usb_power_resume(struct device *dev)\n{\n\tstruct axp20x_usb_power *power = dev_get_drvdata(dev);\n\tint i = 0;\n\n\tif (device_may_wakeup(&power->supply->dev))\n\t\tdisable_irq_wake(power->irqs[i++]);\n\twhile (i < power->num_irqs)\n\t\tenable_irq(power->irqs[i++]);\n\n\tmod_delayed_work(system_power_efficient_wq, &power->vbus_detect, DEBOUNCE_TIME);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(axp20x_usb_power_pm_ops, axp20x_usb_power_suspend,\n\t\t\t\t\t\t  axp20x_usb_power_resume);\n\nstatic int configure_iio_channels(struct platform_device *pdev,\n\t\t\t\t  struct axp20x_usb_power *power)\n{\n\tpower->vbus_v = devm_iio_channel_get(&pdev->dev, \"vbus_v\");\n\tif (IS_ERR(power->vbus_v)) {\n\t\tif (PTR_ERR(power->vbus_v) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(power->vbus_v);\n\t}\n\n\tpower->vbus_i = devm_iio_channel_get(&pdev->dev, \"vbus_i\");\n\tif (IS_ERR(power->vbus_i)) {\n\t\tif (PTR_ERR(power->vbus_i) == -ENODEV)\n\t\t\treturn -EPROBE_DEFER;\n\t\treturn PTR_ERR(power->vbus_i);\n\t}\n\n\treturn 0;\n}\n\nstatic int configure_adc_registers(struct axp20x_usb_power *power)\n{\n\t \n\treturn regmap_update_bits(power->regmap, AXP20X_ADC_EN1,\n\t\t\t\t  AXP20X_ADC_EN1_VBUS_CURR |\n\t\t\t\t  AXP20X_ADC_EN1_VBUS_VOLT,\n\t\t\t\t  AXP20X_ADC_EN1_VBUS_CURR |\n\t\t\t\t  AXP20X_ADC_EN1_VBUS_VOLT);\n}\n\nstatic int axp20x_regmap_field_alloc_optional(struct device *dev,\n\t\t\t\t\t      struct regmap *regmap,\n\t\t\t\t\t      struct reg_field fdesc,\n\t\t\t\t\t      struct regmap_field **fieldp)\n{\n\tstruct regmap_field *field;\n\n\tif (fdesc.reg == 0) {\n\t\t*fieldp = NULL;\n\t\treturn 0;\n\t}\n\n\tfield = devm_regmap_field_alloc(dev, regmap, fdesc);\n\tif (IS_ERR(field))\n\t\treturn PTR_ERR(field);\n\n\t*fieldp = field;\n\treturn 0;\n}\n\nstatic int axp20x_usb_power_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config psy_cfg = {};\n\tstruct axp20x_usb_power *power;\n\tconst struct axp_data *axp_data;\n\tint i, irq, ret;\n\n\tif (!of_device_is_available(pdev->dev.of_node))\n\t\treturn -ENODEV;\n\n\tif (!axp20x) {\n\t\tdev_err(&pdev->dev, \"Parent drvdata not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taxp_data = of_device_get_match_data(&pdev->dev);\n\n\tpower = devm_kzalloc(&pdev->dev,\n\t\t\t     struct_size(power, irqs, axp_data->num_irq_names),\n\t\t\t     GFP_KERNEL);\n\tif (!power)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, power);\n\n\tpower->axp_data = axp_data;\n\tpower->regmap = axp20x->regmap;\n\tpower->num_irqs = axp_data->num_irq_names;\n\n\tpower->curr_lim_fld = devm_regmap_field_alloc(&pdev->dev, power->regmap,\n\t\t\t\t\t\t      axp_data->curr_lim_fld);\n\tif (IS_ERR(power->curr_lim_fld))\n\t\treturn PTR_ERR(power->curr_lim_fld);\n\n\tret = axp20x_regmap_field_alloc_optional(&pdev->dev, power->regmap,\n\t\t\t\t\t\t axp_data->vbus_valid_bit,\n\t\t\t\t\t\t &power->vbus_valid_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = axp20x_regmap_field_alloc_optional(&pdev->dev, power->regmap,\n\t\t\t\t\t\t axp_data->vbus_mon_bit,\n\t\t\t\t\t\t &power->vbus_mon_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = axp20x_regmap_field_alloc_optional(&pdev->dev, power->regmap,\n\t\t\t\t\t\t axp_data->usb_bc_en_bit,\n\t\t\t\t\t\t &power->usb_bc_en_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = axp20x_regmap_field_alloc_optional(&pdev->dev, power->regmap,\n\t\t\t\t\t\t axp_data->vbus_disable_bit,\n\t\t\t\t\t\t &power->vbus_disable_bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_delayed_work_autocancel(&pdev->dev, &power->vbus_detect,\n\t\t\t\t\t   axp20x_usb_power_poll_vbus);\n\tif (ret)\n\t\treturn ret;\n\n\tif (power->vbus_mon_bit) {\n\t\t \n\t\tret = regmap_field_write(power->vbus_mon_bit, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (IS_ENABLED(CONFIG_AXP20X_ADC))\n\t\t\tret = configure_iio_channels(pdev, power);\n\t\telse\n\t\t\tret = configure_adc_registers(power);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (power->usb_bc_en_bit) {\n\t\t \n\t\tret = regmap_field_write(power->usb_bc_en_bit, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = power;\n\n\tpower->supply = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t   axp_data->power_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(power->supply))\n\t\treturn PTR_ERR(power->supply);\n\n\t \n\tfor (i = 0; i < axp_data->num_irq_names; i++) {\n\t\tirq = platform_get_irq_byname(pdev, axp_data->irq_names[i]);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tpower->irqs[i] = regmap_irq_get_virq(axp20x->regmap_irqc, irq);\n\t\tret = devm_request_any_context_irq(&pdev->dev, power->irqs[i],\n\t\t\t\t\t\t   axp20x_usb_power_irq, 0,\n\t\t\t\t\t\t   DRVNAME, power);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error requesting %s IRQ: %d\\n\",\n\t\t\t\taxp_data->irq_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (axp20x_usb_vbus_needs_polling(power))\n\t\tqueue_delayed_work(system_power_efficient_wq, &power->vbus_detect, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id axp20x_usb_power_match[] = {\n\t{\n\t\t.compatible = \"x-powers,axp192-usb-power-supply\",\n\t\t.data = &axp192_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp202-usb-power-supply\",\n\t\t.data = &axp202_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp221-usb-power-supply\",\n\t\t.data = &axp221_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp223-usb-power-supply\",\n\t\t.data = &axp223_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp813-usb-power-supply\",\n\t\t.data = &axp813_data,\n\t}, {   }\n};\nMODULE_DEVICE_TABLE(of, axp20x_usb_power_match);\n\nstatic struct platform_driver axp20x_usb_power_driver = {\n\t.probe = axp20x_usb_power_probe,\n\t.driver = {\n\t\t.name\t\t= DRVNAME,\n\t\t.of_match_table\t= axp20x_usb_power_match,\n\t\t.pm\t\t= &axp20x_usb_power_pm_ops,\n\t},\n};\n\nmodule_platform_driver(axp20x_usb_power_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"AXP20x PMIC USB power supply status driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}