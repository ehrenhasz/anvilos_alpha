{
  "module_name": "ip5xxx_power.c",
  "hash_id": "b1bf4368d7f46821e5dd7d89392176054aaebd3d0e2bf3e6a6f914b1d862267f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ip5xxx_power.c",
  "human_readable_source": "\n\n\n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n\n#define IP5XXX_SYS_CTL0\t\t\t0x01\n#define IP5XXX_SYS_CTL0_WLED_DET_EN\t\tBIT(4)\n#define IP5XXX_SYS_CTL0_WLED_EN\t\t\tBIT(3)\n#define IP5XXX_SYS_CTL0_BOOST_EN\t\tBIT(2)\n#define IP5XXX_SYS_CTL0_CHARGER_EN\t\tBIT(1)\n#define IP5XXX_SYS_CTL1\t\t\t0x02\n#define IP5XXX_SYS_CTL1_LIGHT_SHDN_EN\t\tBIT(1)\n#define IP5XXX_SYS_CTL1_LOAD_PWRUP_EN\t\tBIT(0)\n#define IP5XXX_SYS_CTL2\t\t\t0x0c\n#define IP5XXX_SYS_CTL2_LIGHT_SHDN_TH\t\tGENMASK(7, 3)\n#define IP5XXX_SYS_CTL3\t\t\t0x03\n#define IP5XXX_SYS_CTL3_LONG_PRESS_TIME_SEL\tGENMASK(7, 6)\n#define IP5XXX_SYS_CTL3_BTN_SHDN_EN\t\tBIT(5)\n#define IP5XXX_SYS_CTL4\t\t\t0x04\n#define IP5XXX_SYS_CTL4_SHDN_TIME_SEL\t\tGENMASK(7, 6)\n#define IP5XXX_SYS_CTL4_VIN_PULLOUT_BOOST_EN\tBIT(5)\n#define IP5XXX_SYS_CTL5\t\t\t0x07\n#define IP5XXX_SYS_CTL5_NTC_DIS\t\t\tBIT(6)\n#define IP5XXX_SYS_CTL5_WLED_MODE_SEL\t\tBIT(1)\n#define IP5XXX_SYS_CTL5_BTN_SHDN_SEL\t\tBIT(0)\n#define IP5XXX_CHG_CTL1\t\t\t0x22\n#define IP5XXX_CHG_CTL1_BOOST_UVP_SEL\t\tGENMASK(3, 2)\n#define IP5XXX_CHG_CTL2\t\t\t0x24\n#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL\t\tGENMASK(6, 5)\n#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V\t(0x0 << 5)\n#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V\t(0x1 << 5)\n#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V\t(0x2 << 5)\n#define IP5XXX_CHG_CTL2_CONST_VOLT_SEL\t\tGENMASK(2, 1)\n#define IP5XXX_CHG_CTL4\t\t\t0x26\n#define IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN\t\tBIT(6)\n#define IP5XXX_CHG_CTL4A\t\t0x25\n#define IP5XXX_CHG_CTL4A_CONST_CUR_SEL\t\tGENMASK(4, 0)\n#define IP5XXX_MFP_CTL0\t\t\t0x51\n#define IP5XXX_MFP_CTL1\t\t\t0x52\n#define IP5XXX_GPIO_CTL2\t\t0x53\n#define IP5XXX_GPIO_CTL2A\t\t0x54\n#define IP5XXX_GPIO_CTL3\t\t0x55\n#define IP5XXX_READ0\t\t\t0x71\n#define IP5XXX_READ0_CHG_STAT\t\t\tGENMASK(7, 5)\n#define IP5XXX_READ0_CHG_STAT_IDLE\t\t(0x0 << 5)\n#define IP5XXX_READ0_CHG_STAT_TRICKLE\t\t(0x1 << 5)\n#define IP5XXX_READ0_CHG_STAT_CONST_VOLT\t(0x2 << 5)\n#define IP5XXX_READ0_CHG_STAT_CONST_CUR\t\t(0x3 << 5)\n#define IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP\t(0x4 << 5)\n#define IP5XXX_READ0_CHG_STAT_FULL\t\t(0x5 << 5)\n#define IP5XXX_READ0_CHG_STAT_TIMEOUT\t\t(0x6 << 5)\n#define IP5XXX_READ0_CHG_OP\t\t\tBIT(4)\n#define IP5XXX_READ0_CHG_END\t\t\tBIT(3)\n#define IP5XXX_READ0_CONST_VOLT_TIMEOUT\t\tBIT(2)\n#define IP5XXX_READ0_CHG_TIMEOUT\t\tBIT(1)\n#define IP5XXX_READ0_TRICKLE_TIMEOUT\t\tBIT(0)\n#define IP5XXX_READ0_TIMEOUT\t\t\tGENMASK(2, 0)\n#define IP5XXX_READ1\t\t\t0x72\n#define IP5XXX_READ1_WLED_PRESENT\t\tBIT(7)\n#define IP5XXX_READ1_LIGHT_LOAD\t\t\tBIT(6)\n#define IP5XXX_READ1_VIN_OVERVOLT\t\tBIT(5)\n#define IP5XXX_READ2\t\t\t0x77\n#define IP5XXX_READ2_BTN_PRESS\t\t\tBIT(3)\n#define IP5XXX_READ2_BTN_LONG_PRESS\t\tBIT(1)\n#define IP5XXX_READ2_BTN_SHORT_PRESS\t\tBIT(0)\n#define IP5XXX_BATVADC_DAT0\t\t0xa2\n#define IP5XXX_BATVADC_DAT1\t\t0xa3\n#define IP5XXX_BATIADC_DAT0\t\t0xa4\n#define IP5XXX_BATIADC_DAT1\t\t0xa5\n#define IP5XXX_BATOCV_DAT0\t\t0xa8\n#define IP5XXX_BATOCV_DAT1\t\t0xa9\n\nstruct ip5xxx {\n\tstruct regmap *regmap;\n\tbool initialized;\n};\n\n \nstatic int ip5xxx_read(struct ip5xxx *ip5xxx, unsigned int reg,\n\t\t       unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(ip5xxx->regmap, reg, val);\n\tif (ret)\n\t\tip5xxx->initialized = false;\n\n\treturn ret;\n}\n\nstatic int ip5xxx_update_bits(struct ip5xxx *ip5xxx, unsigned int reg,\n\t\t\t      unsigned int mask, unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_update_bits(ip5xxx->regmap, reg, mask, val);\n\tif (ret)\n\t\tip5xxx->initialized = false;\n\n\treturn ret;\n}\n\nstatic int ip5xxx_initialize(struct power_supply *psy)\n{\n\tstruct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (ip5xxx->initialized)\n\t\treturn 0;\n\n\t \n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL1,\n\t\t\t\t IP5XXX_SYS_CTL1_LIGHT_SHDN_EN |\n\t\t\t\t IP5XXX_SYS_CTL1_LOAD_PWRUP_EN,\n\t\t\t\t IP5XXX_SYS_CTL1_LOAD_PWRUP_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL3,\n\t\t\t\t IP5XXX_SYS_CTL3_BTN_SHDN_EN,\n\t\t\t\t IP5XXX_SYS_CTL3_BTN_SHDN_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL4,\n\t\t\t\t IP5XXX_SYS_CTL4_VIN_PULLOUT_BOOST_EN,\n\t\t\t\t IP5XXX_SYS_CTL4_VIN_PULLOUT_BOOST_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL5,\n\t\t\t\t IP5XXX_SYS_CTL5_NTC_DIS |\n\t\t\t\t IP5XXX_SYS_CTL5_WLED_MODE_SEL |\n\t\t\t\t IP5XXX_SYS_CTL5_BTN_SHDN_SEL,\n\t\t\t\t IP5XXX_SYS_CTL5_WLED_MODE_SEL |\n\t\t\t\t IP5XXX_SYS_CTL5_BTN_SHDN_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tip5xxx->initialized = true;\n\tdev_dbg(psy->dev.parent, \"Initialized after power on\\n\");\n\n\treturn 0;\n}\n\nstatic const enum power_supply_property ip5xxx_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n};\n\nstatic int ip5xxx_battery_get_status(struct ip5xxx *ip5xxx, int *val)\n{\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_read(ip5xxx, IP5XXX_READ0, &rval);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (rval & IP5XXX_READ0_CHG_STAT) {\n\tcase IP5XXX_READ0_CHG_STAT_IDLE:\n\t\t*val = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase IP5XXX_READ0_CHG_STAT_TRICKLE:\n\tcase IP5XXX_READ0_CHG_STAT_CONST_CUR:\n\tcase IP5XXX_READ0_CHG_STAT_CONST_VOLT:\n\t\t*val = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP:\n\tcase IP5XXX_READ0_CHG_STAT_FULL:\n\t\t*val = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase IP5XXX_READ0_CHG_STAT_TIMEOUT:\n\t\t*val = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_get_charge_type(struct ip5xxx *ip5xxx, int *val)\n{\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_read(ip5xxx, IP5XXX_READ0, &rval);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (rval & IP5XXX_READ0_CHG_STAT) {\n\tcase IP5XXX_READ0_CHG_STAT_IDLE:\n\tcase IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP:\n\tcase IP5XXX_READ0_CHG_STAT_FULL:\n\tcase IP5XXX_READ0_CHG_STAT_TIMEOUT:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tcase IP5XXX_READ0_CHG_STAT_TRICKLE:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase IP5XXX_READ0_CHG_STAT_CONST_CUR:\n\tcase IP5XXX_READ0_CHG_STAT_CONST_VOLT:\n\t\t*val = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_get_health(struct ip5xxx *ip5xxx, int *val)\n{\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_read(ip5xxx, IP5XXX_READ0, &rval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rval & IP5XXX_READ0_TIMEOUT)\n\t\t*val = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\telse\n\t\t*val = POWER_SUPPLY_HEALTH_GOOD;\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_get_voltage_max(struct ip5xxx *ip5xxx, int *val)\n{\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_read(ip5xxx, IP5XXX_CHG_CTL2, &rval);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (rval & IP5XXX_CHG_CTL2_BAT_TYPE_SEL) {\n\tcase IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V:\n\t\t*val = 4200000;\n\t\tbreak;\n\tcase IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V:\n\t\t*val = 4300000;\n\t\tbreak;\n\tcase IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V:\n\t\t*val = 4350000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_read_adc(struct ip5xxx *ip5xxx,\n\t\t\t\t   u8 lo_reg, u8 hi_reg, int *val)\n{\n\tunsigned int hi, lo;\n\tint ret;\n\n\tret = ip5xxx_read(ip5xxx, lo_reg, &lo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip5xxx_read(ip5xxx, hi_reg, &hi);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = sign_extend32(hi << 8 | lo, 13);\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);\n\tint raw, ret, vmax;\n\tunsigned int rval;\n\n\tret = ip5xxx_initialize(psy);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn ip5xxx_battery_get_status(ip5xxx, &val->intval);\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\treturn ip5xxx_battery_get_charge_type(ip5xxx, &val->intval);\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\treturn ip5xxx_battery_get_health(ip5xxx, &val->intval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\treturn ip5xxx_battery_get_voltage_max(ip5xxx, &val->intval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = ip5xxx_battery_read_adc(ip5xxx, IP5XXX_BATVADC_DAT0,\n\t\t\t\t\t      IP5XXX_BATVADC_DAT1, &raw);\n\n\t\tval->intval = 2600000 + DIV_ROUND_CLOSEST(raw * 26855, 100);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tret = ip5xxx_battery_read_adc(ip5xxx, IP5XXX_BATOCV_DAT0,\n\t\t\t\t\t      IP5XXX_BATOCV_DAT1, &raw);\n\n\t\tval->intval = 2600000 + DIV_ROUND_CLOSEST(raw * 26855, 100);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = ip5xxx_battery_read_adc(ip5xxx, IP5XXX_BATIADC_DAT0,\n\t\t\t\t\t      IP5XXX_BATIADC_DAT1, &raw);\n\n\t\tval->intval = DIV_ROUND_CLOSEST(raw * 149197, 200);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = ip5xxx_read(ip5xxx, IP5XXX_CHG_CTL4A, &rval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trval &= IP5XXX_CHG_CTL4A_CONST_CUR_SEL;\n\t\tval->intval = 100000 * rval;\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = 100000 * 0x1f;\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = ip5xxx_battery_get_voltage_max(ip5xxx, &vmax);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ip5xxx_read(ip5xxx, IP5XXX_CHG_CTL2, &rval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trval &= IP5XXX_CHG_CTL2_CONST_VOLT_SEL;\n\t\tval->intval = vmax + 14000 * (rval >> 1);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tret = ip5xxx_battery_get_voltage_max(ip5xxx, &vmax);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = vmax + 14000 * 3;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ip5xxx_battery_set_voltage_max(struct ip5xxx *ip5xxx, int val)\n{\n\tunsigned int rval;\n\tint ret;\n\n\tswitch (val) {\n\tcase 4200000:\n\t\trval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V;\n\t\tbreak;\n\tcase 4300000:\n\t\trval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V;\n\t\tbreak;\n\tcase 4350000:\n\t\trval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_CHG_CTL2,\n\t\t\t\t IP5XXX_CHG_CTL2_BAT_TYPE_SEL, rval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip5xxx_update_bits(ip5xxx, IP5XXX_CHG_CTL4,\n\t\t\t\t IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN,\n\t\t\t\t IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ip5xxx_battery_set_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);\n\tunsigned int rval;\n\tint ret, vmax;\n\n\tret = ip5xxx_initialize(psy);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tswitch (val->intval) {\n\t\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\t\trval = IP5XXX_SYS_CTL0_CHARGER_EN;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\tcase POWER_SUPPLY_STATUS_NOT_CHARGING:\n\t\t\trval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL0,\n\t\t\t\t\t  IP5XXX_SYS_CTL0_CHARGER_EN, rval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\treturn ip5xxx_battery_set_voltage_max(ip5xxx, val->intval);\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\trval = val->intval / 100000;\n\t\treturn ip5xxx_update_bits(ip5xxx, IP5XXX_CHG_CTL4A,\n\t\t\t\t\t  IP5XXX_CHG_CTL4A_CONST_CUR_SEL, rval);\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = ip5xxx_battery_get_voltage_max(ip5xxx, &vmax);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trval = ((val->intval - vmax) / 14000) << 1;\n\t\treturn ip5xxx_update_bits(ip5xxx, IP5XXX_CHG_CTL2,\n\t\t\t\t\t  IP5XXX_CHG_CTL2_CONST_VOLT_SEL, rval);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ip5xxx_battery_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\tenum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_STATUS ||\n\t       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN ||\n\t       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||\n\t       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;\n}\n\nstatic const struct power_supply_desc ip5xxx_battery_desc = {\n\t.name\t\t\t= \"ip5xxx-battery\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= ip5xxx_battery_properties,\n\t.num_properties\t\t= ARRAY_SIZE(ip5xxx_battery_properties),\n\t.get_property\t\t= ip5xxx_battery_get_property,\n\t.set_property\t\t= ip5xxx_battery_set_property,\n\t.property_is_writeable\t= ip5xxx_battery_property_is_writeable,\n};\n\nstatic const enum power_supply_property ip5xxx_boost_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n};\n\nstatic int ip5xxx_boost_get_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_initialize(psy);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = ip5xxx_read(ip5xxx, IP5XXX_SYS_CTL0, &rval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = !!(rval & IP5XXX_SYS_CTL0_BOOST_EN);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tret = ip5xxx_read(ip5xxx, IP5XXX_CHG_CTL1, &rval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trval &= IP5XXX_CHG_CTL1_BOOST_UVP_SEL;\n\t\tval->intval = 4530000 + 100000 * (rval >> 2);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ip5xxx_boost_set_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     const union power_supply_propval *val)\n{\n\tstruct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);\n\tunsigned int rval;\n\tint ret;\n\n\tret = ip5xxx_initialize(psy);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\trval = val->intval ? IP5XXX_SYS_CTL0_BOOST_EN : 0;\n\t\treturn ip5xxx_update_bits(ip5xxx, IP5XXX_SYS_CTL0,\n\t\t\t\t\t  IP5XXX_SYS_CTL0_BOOST_EN, rval);\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\trval = ((val->intval - 4530000) / 100000) << 2;\n\t\treturn ip5xxx_update_bits(ip5xxx, IP5XXX_CHG_CTL1,\n\t\t\t\t\t  IP5XXX_CHG_CTL1_BOOST_UVP_SEL, rval);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ip5xxx_boost_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t      enum power_supply_property psp)\n{\n\treturn true;\n}\n\nstatic const struct power_supply_desc ip5xxx_boost_desc = {\n\t.name\t\t\t= \"ip5xxx-boost\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= ip5xxx_boost_properties,\n\t.num_properties\t\t= ARRAY_SIZE(ip5xxx_boost_properties),\n\t.get_property\t\t= ip5xxx_boost_get_property,\n\t.set_property\t\t= ip5xxx_boost_set_property,\n\t.property_is_writeable\t= ip5xxx_boost_property_is_writeable,\n};\n\nstatic const struct regmap_config ip5xxx_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= IP5XXX_BATOCV_DAT1,\n};\n\nstatic int ip5xxx_power_probe(struct i2c_client *client)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct device *dev = &client->dev;\n\tstruct power_supply *psy;\n\tstruct ip5xxx *ip5xxx;\n\n\tip5xxx = devm_kzalloc(dev, sizeof(*ip5xxx), GFP_KERNEL);\n\tif (!ip5xxx)\n\t\treturn -ENOMEM;\n\n\tip5xxx->regmap = devm_regmap_init_i2c(client, &ip5xxx_regmap_config);\n\tif (IS_ERR(ip5xxx->regmap))\n\t\treturn PTR_ERR(ip5xxx->regmap);\n\n\tpsy_cfg.of_node = dev->of_node;\n\tpsy_cfg.drv_data = ip5xxx;\n\n\tpsy = devm_power_supply_register(dev, &ip5xxx_battery_desc, &psy_cfg);\n\tif (IS_ERR(psy))\n\t\treturn PTR_ERR(psy);\n\n\tpsy = devm_power_supply_register(dev, &ip5xxx_boost_desc, &psy_cfg);\n\tif (IS_ERR(psy))\n\t\treturn PTR_ERR(psy);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ip5xxx_power_of_match[] = {\n\t{ .compatible = \"injoinic,ip5108\" },\n\t{ .compatible = \"injoinic,ip5109\" },\n\t{ .compatible = \"injoinic,ip5207\" },\n\t{ .compatible = \"injoinic,ip5209\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ip5xxx_power_of_match);\n\nstatic struct i2c_driver ip5xxx_power_driver = {\n\t.probe\t\t= ip5xxx_power_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"ip5xxx-power\",\n\t\t.of_match_table\t= ip5xxx_power_of_match,\n\t}\n};\nmodule_i2c_driver(ip5xxx_power_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Injoinic IP5xxx power bank IC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}