{
  "module_name": "lp8788-charger.c",
  "hash_id": "f3770a6935080d02f9a1b8289144b3140c0caab863f808ab2bcadcf4fa5fb874",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/lp8788-charger.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/iio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n \n#define LP8788_CHG_STATUS\t\t0x07\n#define LP8788_CHG_IDCIN\t\t0x13\n#define LP8788_CHG_IBATT\t\t0x14\n#define LP8788_CHG_VTERM\t\t0x15\n#define LP8788_CHG_EOC\t\t\t0x16\n\n \n#define LP8788_CHG_INPUT_STATE_M\t0x03\t \n#define LP8788_CHG_STATE_M\t\t0x3C\n#define LP8788_CHG_STATE_S\t\t2\n#define LP8788_NO_BATT_M\t\tBIT(6)\n#define LP8788_BAD_BATT_M\t\tBIT(7)\n#define LP8788_CHG_IBATT_M\t\t0x1F\t \n#define LP8788_CHG_VTERM_M\t\t0x0F\t \n#define LP8788_CHG_EOC_LEVEL_M\t\t0x30\t \n#define LP8788_CHG_EOC_LEVEL_S\t\t4\n#define LP8788_CHG_EOC_TIME_M\t\t0x0E\n#define LP8788_CHG_EOC_TIME_S\t\t1\n#define LP8788_CHG_EOC_MODE_M\t\tBIT(0)\n\n#define LP8788_CHARGER_NAME\t\t\"charger\"\n#define LP8788_BATTERY_NAME\t\t\"main_batt\"\n\n#define LP8788_CHG_START\t\t0x11\n#define LP8788_CHG_END\t\t\t0x1C\n\n#define LP8788_ISEL_MAX\t\t\t23\n#define LP8788_ISEL_STEP\t\t50\n#define LP8788_VTERM_MIN\t\t4100\n#define LP8788_VTERM_STEP\t\t25\n#define LP8788_MAX_BATT_CAPACITY\t100\n#define LP8788_MAX_CHG_IRQS\t\t11\n\nenum lp8788_charging_state {\n\tLP8788_OFF,\n\tLP8788_WARM_UP,\n\tLP8788_LOW_INPUT = 0x3,\n\tLP8788_PRECHARGE,\n\tLP8788_CC,\n\tLP8788_CV,\n\tLP8788_MAINTENANCE,\n\tLP8788_BATTERY_FAULT,\n\tLP8788_SYSTEM_SUPPORT = 0xC,\n\tLP8788_HIGH_CURRENT = 0xF,\n\tLP8788_MAX_CHG_STATE,\n};\n\nenum lp8788_charger_adc_sel {\n\tLP8788_VBATT,\n\tLP8788_BATT_TEMP,\n\tLP8788_NUM_CHG_ADC,\n};\n\nenum lp8788_charger_input_state {\n\tLP8788_SYSTEM_SUPPLY = 1,\n\tLP8788_FULL_FUNCTION,\n};\n\n \nstruct lp8788_chg_irq {\n\tenum lp8788_int_id which;\n\tint virq;\n};\n\n \nstruct lp8788_charger {\n\tstruct lp8788 *lp;\n\tstruct power_supply *charger;\n\tstruct power_supply *battery;\n\tstruct work_struct charger_work;\n\tstruct iio_channel *chan[LP8788_NUM_CHG_ADC];\n\tstruct lp8788_chg_irq irqs[LP8788_MAX_CHG_IRQS];\n\tint num_irqs;\n\tstruct lp8788_charger_platform_data *pdata;\n};\n\nstatic char *battery_supplied_to[] = {\n\tLP8788_BATTERY_NAME,\n};\n\nstatic enum power_supply_property lp8788_charger_prop[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n};\n\nstatic enum power_supply_property lp8788_battery_prop[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic bool lp8788_is_charger_detected(struct lp8788_charger *pchg)\n{\n\tu8 data;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\n\tdata &= LP8788_CHG_INPUT_STATE_M;\n\n\treturn data == LP8788_SYSTEM_SUPPLY || data == LP8788_FULL_FUNCTION;\n}\n\nstatic int lp8788_charger_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct lp8788_charger *pchg = dev_get_drvdata(psy->dev.parent);\n\tu8 read;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = lp8788_is_charger_detected(pchg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tlp8788_read_byte(pchg->lp, LP8788_CHG_IDCIN, &read);\n\t\tval->intval = LP8788_ISEL_STEP *\n\t\t\t\t(min_t(int, read, LP8788_ISEL_MAX) + 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_get_battery_status(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tenum lp8788_charging_state state;\n\tu8 data;\n\tint ret;\n\n\tret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\n\tswitch (state) {\n\tcase LP8788_OFF:\n\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase LP8788_PRECHARGE:\n\tcase LP8788_CC:\n\tcase LP8788_CV:\n\tcase LP8788_HIGH_CURRENT:\n\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase LP8788_MAINTENANCE:\n\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_get_battery_health(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tu8 data;\n\tint ret;\n\n\tret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data & LP8788_NO_BATT_M)\n\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\telse if (data & LP8788_BAD_BATT_M)\n\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\telse\n\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\n\treturn 0;\n}\n\nstatic int lp8788_get_battery_present(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tu8 data;\n\tint ret;\n\n\tret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = !(data & LP8788_NO_BATT_M);\n\treturn 0;\n}\n\nstatic int lp8788_get_vbatt_adc(struct lp8788_charger *pchg, int *result)\n{\n\tstruct iio_channel *channel = pchg->chan[LP8788_VBATT];\n\n\tif (!channel)\n\t\treturn -EINVAL;\n\n\treturn iio_read_channel_processed(channel, result);\n}\n\nstatic int lp8788_get_battery_voltage(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\treturn lp8788_get_vbatt_adc(pchg, &val->intval);\n}\n\nstatic int lp8788_get_battery_capacity(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct lp8788 *lp = pchg->lp;\n\tstruct lp8788_charger_platform_data *pdata = pchg->pdata;\n\tunsigned int max_vbatt;\n\tint vbatt;\n\tenum lp8788_charging_state state;\n\tu8 data;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tmax_vbatt = pdata->max_vbatt_mv;\n\tif (max_vbatt == 0)\n\t\treturn -EINVAL;\n\n\tret = lp8788_read_byte(lp, LP8788_CHG_STATUS, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\n\n\tif (state == LP8788_MAINTENANCE) {\n\t\tval->intval = LP8788_MAX_BATT_CAPACITY;\n\t} else {\n\t\tret = lp8788_get_vbatt_adc(pchg, &vbatt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = (vbatt * LP8788_MAX_BATT_CAPACITY) / max_vbatt;\n\t\tval->intval = min(val->intval, LP8788_MAX_BATT_CAPACITY);\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_get_battery_temperature(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct iio_channel *channel = pchg->chan[LP8788_BATT_TEMP];\n\tint result;\n\tint ret;\n\n\tif (!channel)\n\t\treturn -EINVAL;\n\n\tret = iio_read_channel_processed(channel, &result);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t \n\tval->intval = result * 10;\n\n\treturn 0;\n}\n\nstatic int lp8788_get_battery_charging_current(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tu8 read;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_IBATT, &read);\n\tread &= LP8788_CHG_IBATT_M;\n\tval->intval = LP8788_ISEL_STEP *\n\t\t\t(min_t(int, read, LP8788_ISEL_MAX) + 1);\n\n\treturn 0;\n}\n\nstatic int lp8788_get_charging_termination_voltage(struct lp8788_charger *pchg,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tu8 read;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_VTERM, &read);\n\tread &= LP8788_CHG_VTERM_M;\n\tval->intval = LP8788_VTERM_MIN + LP8788_VTERM_STEP * read;\n\n\treturn 0;\n}\n\nstatic int lp8788_battery_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct lp8788_charger *pchg = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn lp8788_get_battery_status(pchg, val);\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\treturn lp8788_get_battery_health(pchg, val);\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\treturn lp8788_get_battery_present(pchg, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\treturn lp8788_get_battery_voltage(pchg, val);\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\treturn lp8788_get_battery_capacity(pchg, val);\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\treturn lp8788_get_battery_temperature(pchg, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn lp8788_get_battery_charging_current(pchg, val);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\treturn lp8788_get_charging_termination_voltage(pchg, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline bool lp8788_is_valid_charger_register(u8 addr)\n{\n\treturn addr >= LP8788_CHG_START && addr <= LP8788_CHG_END;\n}\n\nstatic int lp8788_update_charger_params(struct platform_device *pdev,\n\t\t\t\t\tstruct lp8788_charger *pchg)\n{\n\tstruct lp8788 *lp = pchg->lp;\n\tstruct lp8788_charger_platform_data *pdata = pchg->pdata;\n\tstruct lp8788_chg_param *param;\n\tint i;\n\tint ret;\n\n\tif (!pdata || !pdata->chg_params) {\n\t\tdev_info(&pdev->dev, \"skip updating charger parameters\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < pdata->num_chg_params; i++) {\n\t\tparam = pdata->chg_params + i;\n\n\t\tif (lp8788_is_valid_charger_register(param->addr)) {\n\t\t\tret = lp8788_write_byte(lp, param->addr, param->val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct power_supply_desc lp8788_psy_charger_desc = {\n\t.name\t\t= LP8788_CHARGER_NAME,\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= lp8788_charger_prop,\n\t.num_properties\t= ARRAY_SIZE(lp8788_charger_prop),\n\t.get_property\t= lp8788_charger_get_property,\n};\n\nstatic const struct power_supply_desc lp8788_psy_battery_desc = {\n\t.name\t\t= LP8788_BATTERY_NAME,\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= lp8788_battery_prop,\n\t.num_properties\t= ARRAY_SIZE(lp8788_battery_prop),\n\t.get_property\t= lp8788_battery_get_property,\n};\n\nstatic void lp8788_psy_unregister(struct lp8788_charger *pchg)\n{\n\tpower_supply_unregister(pchg->battery);\n\tpower_supply_unregister(pchg->charger);\n}\n\nstatic void lp8788_charger_event(struct work_struct *work)\n{\n\tstruct lp8788_charger *pchg =\n\t\tcontainer_of(work, struct lp8788_charger, charger_work);\n\tstruct lp8788_charger_platform_data *pdata = pchg->pdata;\n\tenum lp8788_charger_event event = lp8788_is_charger_detected(pchg);\n\n\tpdata->charger_event(pchg->lp, event);\n}\n\nstatic bool lp8788_find_irq_id(struct lp8788_charger *pchg, int virq, int *id)\n{\n\tbool found = false;\n\tint i;\n\n\tfor (i = 0; i < pchg->num_irqs; i++) {\n\t\tif (pchg->irqs[i].virq == virq) {\n\t\t\t*id = pchg->irqs[i].which;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic irqreturn_t lp8788_charger_irq_thread(int virq, void *ptr)\n{\n\tstruct lp8788_charger *pchg = ptr;\n\tstruct lp8788_charger_platform_data *pdata = pchg->pdata;\n\tint id = -1;\n\n\tif (!lp8788_find_irq_id(pchg, virq, &id))\n\t\treturn IRQ_NONE;\n\n\tswitch (id) {\n\tcase LP8788_INT_CHG_INPUT_STATE:\n\tcase LP8788_INT_CHG_STATE:\n\tcase LP8788_INT_EOC:\n\tcase LP8788_INT_BATT_LOW:\n\tcase LP8788_INT_NO_BATT:\n\t\tpower_supply_changed(pchg->charger);\n\t\tpower_supply_changed(pchg->battery);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!pdata)\n\t\tgoto irq_handled;\n\n\tif (pdata->charger_event && id == LP8788_INT_CHG_INPUT_STATE)\n\t\tschedule_work(&pchg->charger_work);\n\nirq_handled:\n\treturn IRQ_HANDLED;\n}\n\nstatic int lp8788_set_irqs(struct platform_device *pdev,\n\t\t\tstruct lp8788_charger *pchg, const char *name)\n{\n\tstruct resource *r;\n\tstruct irq_domain *irqdm = pchg->lp->irqdm;\n\tint irq_start;\n\tint irq_end;\n\tint virq;\n\tint nr_irq;\n\tint i;\n\tint ret;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, name);\n\tif (!r)\n\t\treturn 0;\n\n\tirq_start = r->start;\n\tirq_end = r->end;\n\n\tfor (i = irq_start; i <= irq_end; i++) {\n\t\tnr_irq = pchg->num_irqs;\n\n\t\tvirq = irq_create_mapping(irqdm, i);\n\t\tpchg->irqs[nr_irq].virq = virq;\n\t\tpchg->irqs[nr_irq].which = i;\n\t\tpchg->num_irqs++;\n\n\t\tret = request_threaded_irq(virq, NULL,\n\t\t\t\t\tlp8788_charger_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT, name, pchg);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (i <= irq_end)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfor (i = 0; i < pchg->num_irqs; i++)\n\t\tfree_irq(pchg->irqs[i].virq, pchg);\n\treturn ret;\n}\n\nstatic int lp8788_irq_register(struct platform_device *pdev,\n\t\t\t\tstruct lp8788_charger *pchg)\n{\n\tstatic const char * const name[] = {\n\t\tLP8788_CHG_IRQ, LP8788_PRSW_IRQ, LP8788_BATT_IRQ\n\t};\n\tint i;\n\tint ret;\n\n\tINIT_WORK(&pchg->charger_work, lp8788_charger_event);\n\tpchg->num_irqs = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(name); i++) {\n\t\tret = lp8788_set_irqs(pdev, pchg, name[i]);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"irq setup failed: %s\\n\", name[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pchg->num_irqs > LP8788_MAX_CHG_IRQS) {\n\t\tdev_err(&pdev->dev, \"invalid total number of irqs: %d\\n\",\n\t\t\tpchg->num_irqs);\n\t\treturn -EINVAL;\n\t}\n\n\n\treturn 0;\n}\n\nstatic void lp8788_irq_unregister(struct platform_device *pdev,\n\t\t\t\t  struct lp8788_charger *pchg)\n{\n\tint i;\n\tint irq;\n\n\tfor (i = 0; i < pchg->num_irqs; i++) {\n\t\tirq = pchg->irqs[i].virq;\n\t\tif (!irq)\n\t\t\tcontinue;\n\n\t\tfree_irq(irq, pchg);\n\t}\n}\n\nstatic void lp8788_setup_adc_channel(struct device *dev,\n\t\t\t\tstruct lp8788_charger *pchg)\n{\n\tstruct lp8788_charger_platform_data *pdata = pchg->pdata;\n\tstruct iio_channel *chan;\n\n\tif (!pdata)\n\t\treturn;\n\n\t \n\tchan = devm_iio_channel_get(dev, pdata->adc_vbatt);\n\tpchg->chan[LP8788_VBATT] = IS_ERR(chan) ? NULL : chan;\n\n\t \n\tchan = devm_iio_channel_get(dev, pdata->adc_batt_temp);\n\tpchg->chan[LP8788_BATT_TEMP] = IS_ERR(chan) ? NULL : chan;\n}\n\nstatic ssize_t lp8788_show_charger_status(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lp8788_charger *pchg = dev_get_drvdata(dev);\n\tenum lp8788_charging_state state;\n\tstatic const char * const desc[LP8788_MAX_CHG_STATE] = {\n\t\t[LP8788_OFF] = \"CHARGER OFF\",\n\t\t[LP8788_WARM_UP] = \"WARM UP\",\n\t\t[LP8788_LOW_INPUT] = \"LOW INPUT STATE\",\n\t\t[LP8788_PRECHARGE] = \"CHARGING - PRECHARGE\",\n\t\t[LP8788_CC] = \"CHARGING - CC\",\n\t\t[LP8788_CV] = \"CHARGING - CV\",\n\t\t[LP8788_MAINTENANCE] = \"NO CHARGING - MAINTENANCE\",\n\t\t[LP8788_BATTERY_FAULT] = \"BATTERY FAULT\",\n\t\t[LP8788_SYSTEM_SUPPORT] = \"SYSTEM SUPPORT\",\n\t\t[LP8788_HIGH_CURRENT] = \"HIGH CURRENT\",\n\t};\n\tu8 data;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\n\tstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\n\n\treturn sysfs_emit(buf, \"%s\\n\", desc[state]);\n}\n\nstatic ssize_t lp8788_show_eoc_time(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lp8788_charger *pchg = dev_get_drvdata(dev);\n\tstatic const char * const stime[] = {\n\t\t\"400ms\", \"5min\", \"10min\", \"15min\",\n\t\t\"20min\", \"25min\", \"30min\", \"No timeout\"\n\t};\n\tu8 val;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_EOC, &val);\n\tval = (val & LP8788_CHG_EOC_TIME_M) >> LP8788_CHG_EOC_TIME_S;\n\n\treturn sysfs_emit(buf, \"End Of Charge Time: %s\\n\", stime[val]);\n}\n\nstatic ssize_t lp8788_show_eoc_level(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct lp8788_charger *pchg = dev_get_drvdata(dev);\n\tstatic const char * const abs_level[] = {\n\t\t\t\"25mA\", \"49mA\", \"75mA\", \"98mA\"\n\t};\n\tstatic const char * const relative_level[] = {\n\t\t\t\"5%\", \"10%\", \"15%\", \"20%\"\n\t};\n\tconst char *level;\n\tu8 val;\n\tu8 mode;\n\n\tlp8788_read_byte(pchg->lp, LP8788_CHG_EOC, &val);\n\n\tmode = val & LP8788_CHG_EOC_MODE_M;\n\tval = (val & LP8788_CHG_EOC_LEVEL_M) >> LP8788_CHG_EOC_LEVEL_S;\n\tlevel = mode ? abs_level[val] : relative_level[val];\n\n\treturn sysfs_emit(buf, \"End Of Charge Level: %s\\n\", level);\n}\n\nstatic DEVICE_ATTR(charger_status, S_IRUSR, lp8788_show_charger_status, NULL);\nstatic DEVICE_ATTR(eoc_time, S_IRUSR, lp8788_show_eoc_time, NULL);\nstatic DEVICE_ATTR(eoc_level, S_IRUSR, lp8788_show_eoc_level, NULL);\n\nstatic struct attribute *lp8788_charger_sysfs_attrs[] = {\n\t&dev_attr_charger_status.attr,\n\t&dev_attr_eoc_time.attr,\n\t&dev_attr_eoc_level.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(lp8788_charger_sysfs);\n\nstatic int lp8788_psy_register(struct platform_device *pdev,\n\t\t\t\tstruct lp8788_charger *pchg)\n{\n\tstruct power_supply_config charger_cfg = {};\n\n\tcharger_cfg.attr_grp = lp8788_charger_sysfs_groups;\n\tcharger_cfg.supplied_to = battery_supplied_to;\n\tcharger_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);\n\n\tpchg->charger = power_supply_register(&pdev->dev,\n\t\t\t\t\t      &lp8788_psy_charger_desc,\n\t\t\t\t\t      &charger_cfg);\n\tif (IS_ERR(pchg->charger))\n\t\treturn -EPERM;\n\n\tpchg->battery = power_supply_register(&pdev->dev,\n\t\t\t\t\t      &lp8788_psy_battery_desc, NULL);\n\tif (IS_ERR(pchg->battery)) {\n\t\tpower_supply_unregister(pchg->charger);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_charger_probe(struct platform_device *pdev)\n{\n\tstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\n\tstruct lp8788_charger *pchg;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpchg = devm_kzalloc(dev, sizeof(struct lp8788_charger), GFP_KERNEL);\n\tif (!pchg)\n\t\treturn -ENOMEM;\n\n\tpchg->lp = lp;\n\tpchg->pdata = lp->pdata ? lp->pdata->chg_pdata : NULL;\n\tplatform_set_drvdata(pdev, pchg);\n\n\tret = lp8788_update_charger_params(pdev, pchg);\n\tif (ret)\n\t\treturn ret;\n\n\tlp8788_setup_adc_channel(&pdev->dev, pchg);\n\n\tret = lp8788_psy_register(pdev, pchg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp8788_irq_register(pdev, pchg);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to register charger irq: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic int lp8788_charger_remove(struct platform_device *pdev)\n{\n\tstruct lp8788_charger *pchg = platform_get_drvdata(pdev);\n\n\tflush_work(&pchg->charger_work);\n\tlp8788_irq_unregister(pdev, pchg);\n\tlp8788_psy_unregister(pchg);\n\n\treturn 0;\n}\n\nstatic struct platform_driver lp8788_charger_driver = {\n\t.probe = lp8788_charger_probe,\n\t.remove = lp8788_charger_remove,\n\t.driver = {\n\t\t.name = LP8788_DEV_CHARGER,\n\t},\n};\nmodule_platform_driver(lp8788_charger_driver);\n\nMODULE_DESCRIPTION(\"TI LP8788 Charger Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lp8788-charger\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}