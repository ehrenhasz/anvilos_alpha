{
  "module_name": "pcf50633-charger.c",
  "hash_id": "e5a5260bd8327f95d96d8f092f2865f7461739e2c8a8f2182703c3057dd47ca0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/pcf50633-charger.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n\n#include <linux/mfd/pcf50633/core.h>\n#include <linux/mfd/pcf50633/mbc.h>\n\nstruct pcf50633_mbc {\n\tstruct pcf50633 *pcf;\n\n\tint adapter_online;\n\tint usb_online;\n\n\tstruct power_supply *usb;\n\tstruct power_supply *adapter;\n\tstruct power_supply *ac;\n};\n\nint pcf50633_mbc_usb_curlim_set(struct pcf50633 *pcf, int ma)\n{\n\tstruct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);\n\tint ret = 0;\n\tu8 bits;\n\tu8 mbcs2, chgmod;\n\tunsigned int mbcc5;\n\n\tif (ma >= 1000) {\n\t\tbits = PCF50633_MBCC7_USB_1000mA;\n\t\tma = 1000;\n\t} else if (ma >= 500) {\n\t\tbits = PCF50633_MBCC7_USB_500mA;\n\t\tma = 500;\n\t} else if (ma >= 100) {\n\t\tbits = PCF50633_MBCC7_USB_100mA;\n\t\tma = 100;\n\t} else {\n\t\tbits = PCF50633_MBCC7_USB_SUSPEND;\n\t\tma = 0;\n\t}\n\n\tret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC7,\n\t\t\t\t\tPCF50633_MBCC7_USB_MASK, bits);\n\tif (ret)\n\t\tdev_err(pcf->dev, \"error setting usb curlim to %d mA\\n\", ma);\n\telse\n\t\tdev_info(pcf->dev, \"usb curlim to %d mA\\n\", ma);\n\n\t \n\n\tif (mbc->pcf->pdata->charger_reference_current_ma) {\n\t\tmbcc5 = (ma << 8) / mbc->pcf->pdata->charger_reference_current_ma;\n\t\tif (mbcc5 > 255)\n\t\t\tmbcc5 = 255;\n\t\tpcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);\n\t}\n\n\tmbcs2 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2);\n\tchgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);\n\n\t \n\tif (chgmod != PCF50633_MBCS2_MBC_BAT_FULL)\n\t\tpcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,\n\t\t\t\tPCF50633_MBCC1_CHGENA, PCF50633_MBCC1_CHGENA);\n\telse {\n\t\tpcf50633_reg_clear_bits(pcf, PCF50633_REG_MBCC1,\n\t\t\t\tPCF50633_MBCC1_CHGENA);\n\t\tpcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,\n\t\t\t\tPCF50633_MBCC1_CHGENA, PCF50633_MBCC1_CHGENA);\n\t}\n\n\tpower_supply_changed(mbc->usb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pcf50633_mbc_usb_curlim_set);\n\nint pcf50633_mbc_get_status(struct pcf50633 *pcf)\n{\n\tstruct pcf50633_mbc *mbc  = platform_get_drvdata(pcf->mbc_pdev);\n\tint status = 0;\n\tu8 chgmod;\n\n\tif (!mbc)\n\t\treturn 0;\n\n\tchgmod = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2)\n\t\t& PCF50633_MBCS2_MBC_MASK;\n\n\tif (mbc->usb_online)\n\t\tstatus |= PCF50633_MBC_USB_ONLINE;\n\tif (chgmod == PCF50633_MBCS2_MBC_USB_PRE ||\n\t    chgmod == PCF50633_MBCS2_MBC_USB_PRE_WAIT ||\n\t    chgmod == PCF50633_MBCS2_MBC_USB_FAST ||\n\t    chgmod == PCF50633_MBCS2_MBC_USB_FAST_WAIT)\n\t\tstatus |= PCF50633_MBC_USB_ACTIVE;\n\tif (mbc->adapter_online)\n\t\tstatus |= PCF50633_MBC_ADAPTER_ONLINE;\n\tif (chgmod == PCF50633_MBCS2_MBC_ADP_PRE ||\n\t    chgmod == PCF50633_MBCS2_MBC_ADP_PRE_WAIT ||\n\t    chgmod == PCF50633_MBCS2_MBC_ADP_FAST ||\n\t    chgmod == PCF50633_MBCS2_MBC_ADP_FAST_WAIT)\n\t\tstatus |= PCF50633_MBC_ADAPTER_ACTIVE;\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(pcf50633_mbc_get_status);\n\nint pcf50633_mbc_get_usb_online_status(struct pcf50633 *pcf)\n{\n\tstruct pcf50633_mbc *mbc  = platform_get_drvdata(pcf->mbc_pdev);\n\n\tif (!mbc)\n\t\treturn 0;\n\n\treturn mbc->usb_online;\n}\nEXPORT_SYMBOL_GPL(pcf50633_mbc_get_usb_online_status);\n\nstatic ssize_t\nshow_chgmode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\n\n\tu8 mbcs2 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2);\n\tu8 chgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);\n\n\treturn sysfs_emit(buf, \"%d\\n\", chgmod);\n}\nstatic DEVICE_ATTR(chgmode, S_IRUGO, show_chgmode, NULL);\n\nstatic ssize_t\nshow_usblim(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\n\tu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\n\t\t\t\t\t\tPCF50633_MBCC7_USB_MASK;\n\tunsigned int ma;\n\n\tif (usblim == PCF50633_MBCC7_USB_1000mA)\n\t\tma = 1000;\n\telse if (usblim == PCF50633_MBCC7_USB_500mA)\n\t\tma = 500;\n\telse if (usblim == PCF50633_MBCC7_USB_100mA)\n\t\tma = 100;\n\telse\n\t\tma = 0;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ma);\n}\n\nstatic ssize_t set_usblim(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\n\tunsigned long ma;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &ma);\n\tif (ret)\n\t\treturn ret;\n\n\tpcf50633_mbc_usb_curlim_set(mbc->pcf, ma);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(usb_curlim, S_IRUGO | S_IWUSR, show_usblim, set_usblim);\n\nstatic ssize_t\nshow_chglim(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\n\tu8 mbcc5 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC5);\n\tunsigned int ma;\n\n\tif (!mbc->pcf->pdata->charger_reference_current_ma)\n\t\treturn -ENODEV;\n\n\tma = (mbc->pcf->pdata->charger_reference_current_ma *  mbcc5) >> 8;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ma);\n}\n\nstatic ssize_t set_chglim(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\n\tunsigned long ma;\n\tunsigned int mbcc5;\n\tint ret;\n\n\tif (!mbc->pcf->pdata->charger_reference_current_ma)\n\t\treturn -ENODEV;\n\n\tret = kstrtoul(buf, 10, &ma);\n\tif (ret)\n\t\treturn ret;\n\n\tmbcc5 = (ma << 8) / mbc->pcf->pdata->charger_reference_current_ma;\n\tif (mbcc5 > 255)\n\t\tmbcc5 = 255;\n\tpcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR(chg_curlim, S_IRUGO | S_IWUSR, show_chglim, set_chglim);\n\nstatic struct attribute *pcf50633_mbc_sysfs_attrs[] = {\n\t&dev_attr_chgmode.attr,\n\t&dev_attr_usb_curlim.attr,\n\t&dev_attr_chg_curlim.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(pcf50633_mbc_sysfs);\n\nstatic void\npcf50633_mbc_irq_handler(int irq, void *data)\n{\n\tstruct pcf50633_mbc *mbc = data;\n\n\t \n\tif (irq == PCF50633_IRQ_USBINS) {\n\t\tmbc->usb_online = 1;\n\t} else if (irq == PCF50633_IRQ_USBREM) {\n\t\tmbc->usb_online = 0;\n\t\tpcf50633_mbc_usb_curlim_set(mbc->pcf, 0);\n\t}\n\n\t \n\tif (irq == PCF50633_IRQ_ADPINS)\n\t\tmbc->adapter_online = 1;\n\telse if (irq == PCF50633_IRQ_ADPREM)\n\t\tmbc->adapter_online = 0;\n\n\tpower_supply_changed(mbc->ac);\n\tpower_supply_changed(mbc->usb);\n\tpower_supply_changed(mbc->adapter);\n\n\tif (mbc->pcf->pdata->mbc_event_callback)\n\t\tmbc->pcf->pdata->mbc_event_callback(mbc->pcf, irq);\n}\n\nstatic int adapter_get_property(struct power_supply *psy,\n\t\t\tenum power_supply_property psp,\n\t\t\tunion power_supply_propval *val)\n{\n\tstruct pcf50633_mbc *mbc = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval =  mbc->adapter_online;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int usb_get_property(struct power_supply *psy,\n\t\t\tenum power_supply_property psp,\n\t\t\tunion power_supply_propval *val)\n{\n\tstruct pcf50633_mbc *mbc = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\n\t\t\t\t\t\tPCF50633_MBCC7_USB_MASK;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = mbc->usb_online &&\n\t\t\t\t(usblim <= PCF50633_MBCC7_USB_500mA);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ac_get_property(struct power_supply *psy,\n\t\t\tenum power_supply_property psp,\n\t\t\tunion power_supply_propval *val)\n{\n\tstruct pcf50633_mbc *mbc = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\n\t\t\t\t\t\tPCF50633_MBCC7_USB_MASK;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = mbc->usb_online &&\n\t\t\t\t(usblim == PCF50633_MBCC7_USB_1000mA);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic enum power_supply_property power_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const u8 mbc_irq_handlers[] = {\n\tPCF50633_IRQ_ADPINS,\n\tPCF50633_IRQ_ADPREM,\n\tPCF50633_IRQ_USBINS,\n\tPCF50633_IRQ_USBREM,\n\tPCF50633_IRQ_BATFULL,\n\tPCF50633_IRQ_CHGHALT,\n\tPCF50633_IRQ_THLIMON,\n\tPCF50633_IRQ_THLIMOFF,\n\tPCF50633_IRQ_USBLIMON,\n\tPCF50633_IRQ_USBLIMOFF,\n\tPCF50633_IRQ_LOWSYS,\n\tPCF50633_IRQ_LOWBAT,\n};\n\nstatic const struct power_supply_desc pcf50633_mbc_adapter_desc = {\n\t.name\t\t= \"adapter\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= power_props,\n\t.num_properties\t= ARRAY_SIZE(power_props),\n\t.get_property\t= &adapter_get_property,\n};\n\nstatic const struct power_supply_desc pcf50633_mbc_usb_desc = {\n\t.name\t\t= \"usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t= power_props,\n\t.num_properties\t= ARRAY_SIZE(power_props),\n\t.get_property\t= usb_get_property,\n};\n\nstatic const struct power_supply_desc pcf50633_mbc_ac_desc = {\n\t.name\t\t= \"ac\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= power_props,\n\t.num_properties\t= ARRAY_SIZE(power_props),\n\t.get_property\t= ac_get_property,\n};\n\nstatic int pcf50633_mbc_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct power_supply_config usb_psy_cfg;\n\tstruct pcf50633_mbc *mbc;\n\tint i;\n\tu8 mbcs1;\n\n\tmbc = devm_kzalloc(&pdev->dev, sizeof(*mbc), GFP_KERNEL);\n\tif (!mbc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mbc);\n\tmbc->pcf = dev_to_pcf50633(pdev->dev.parent);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)\n\t\tpcf50633_register_irq(mbc->pcf, mbc_irq_handlers[i],\n\t\t\t\t\tpcf50633_mbc_irq_handler, mbc);\n\n\tpsy_cfg.supplied_to\t\t= mbc->pcf->pdata->batteries;\n\tpsy_cfg.num_supplicants\t\t= mbc->pcf->pdata->num_batteries;\n\tpsy_cfg.drv_data\t\t= mbc;\n\n\t \n\tmbc->adapter = power_supply_register(&pdev->dev,\n\t\t\t\t\t     &pcf50633_mbc_adapter_desc,\n\t\t\t\t\t     &psy_cfg);\n\tif (IS_ERR(mbc->adapter)) {\n\t\tdev_err(mbc->pcf->dev, \"failed to register adapter\\n\");\n\t\treturn PTR_ERR(mbc->adapter);\n\t}\n\n\tusb_psy_cfg = psy_cfg;\n\tusb_psy_cfg.attr_grp = pcf50633_mbc_sysfs_groups;\n\n\tmbc->usb = power_supply_register(&pdev->dev, &pcf50633_mbc_usb_desc,\n\t\t\t\t\t &usb_psy_cfg);\n\tif (IS_ERR(mbc->usb)) {\n\t\tdev_err(mbc->pcf->dev, \"failed to register usb\\n\");\n\t\tpower_supply_unregister(mbc->adapter);\n\t\treturn PTR_ERR(mbc->usb);\n\t}\n\n\tmbc->ac = power_supply_register(&pdev->dev, &pcf50633_mbc_ac_desc,\n\t\t\t\t\t&psy_cfg);\n\tif (IS_ERR(mbc->ac)) {\n\t\tdev_err(mbc->pcf->dev, \"failed to register ac\\n\");\n\t\tpower_supply_unregister(mbc->adapter);\n\t\tpower_supply_unregister(mbc->usb);\n\t\treturn PTR_ERR(mbc->ac);\n\t}\n\n\tmbcs1 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS1);\n\tif (mbcs1 & PCF50633_MBCS1_USBPRES)\n\t\tpcf50633_mbc_irq_handler(PCF50633_IRQ_USBINS, mbc);\n\tif (mbcs1 & PCF50633_MBCS1_ADAPTPRES)\n\t\tpcf50633_mbc_irq_handler(PCF50633_IRQ_ADPINS, mbc);\n\n\treturn 0;\n}\n\nstatic int pcf50633_mbc_remove(struct platform_device *pdev)\n{\n\tstruct pcf50633_mbc *mbc = platform_get_drvdata(pdev);\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)\n\t\tpcf50633_free_irq(mbc->pcf, mbc_irq_handlers[i]);\n\n\tpower_supply_unregister(mbc->usb);\n\tpower_supply_unregister(mbc->adapter);\n\tpower_supply_unregister(mbc->ac);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pcf50633_mbc_driver = {\n\t.driver = {\n\t\t.name = \"pcf50633-mbc\",\n\t},\n\t.probe = pcf50633_mbc_probe,\n\t.remove = pcf50633_mbc_remove,\n};\n\nmodule_platform_driver(pcf50633_mbc_driver);\n\nMODULE_AUTHOR(\"Balaji Rao <balajirrao@openmoko.org>\");\nMODULE_DESCRIPTION(\"PCF50633 mbc driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pcf50633-mbc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}