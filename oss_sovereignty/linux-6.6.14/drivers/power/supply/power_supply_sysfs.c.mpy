{
  "module_name": "power_supply_sysfs.c",
  "hash_id": "baa21194d019ba6a824e1a132d7f4edb7f804fd793764f9956d9884ba23d92b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/power_supply_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n\n#include \"power_supply.h\"\n\n#define MAX_PROP_NAME_LEN 30\n\nstruct power_supply_attr {\n\tconst char *prop_name;\n\tchar attr_name[MAX_PROP_NAME_LEN + 1];\n\tstruct device_attribute dev_attr;\n\tconst char * const *text_values;\n\tint text_values_len;\n};\n\n#define _POWER_SUPPLY_ATTR(_name, _text, _len)\t\\\n[POWER_SUPPLY_PROP_ ## _name] =\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.prop_name = #_name,\t\t\t\\\n\t.attr_name = #_name \"\\0\",\t\t\\\n\t.text_values = _text,\t\t\t\\\n\t.text_values_len = _len,\t\t\\\n}\n\n#define POWER_SUPPLY_ATTR(_name) _POWER_SUPPLY_ATTR(_name, NULL, 0)\n#define _POWER_SUPPLY_ENUM_ATTR(_name, _text)\t\\\n\t_POWER_SUPPLY_ATTR(_name, _text, ARRAY_SIZE(_text))\n#define POWER_SUPPLY_ENUM_ATTR(_name)\t\\\n\t_POWER_SUPPLY_ENUM_ATTR(_name, POWER_SUPPLY_ ## _name ## _TEXT)\n\nstatic const char * const POWER_SUPPLY_TYPE_TEXT[] = {\n\t[POWER_SUPPLY_TYPE_UNKNOWN]\t\t= \"Unknown\",\n\t[POWER_SUPPLY_TYPE_BATTERY]\t\t= \"Battery\",\n\t[POWER_SUPPLY_TYPE_UPS]\t\t\t= \"UPS\",\n\t[POWER_SUPPLY_TYPE_MAINS]\t\t= \"Mains\",\n\t[POWER_SUPPLY_TYPE_USB]\t\t\t= \"USB\",\n\t[POWER_SUPPLY_TYPE_USB_DCP]\t\t= \"USB_DCP\",\n\t[POWER_SUPPLY_TYPE_USB_CDP]\t\t= \"USB_CDP\",\n\t[POWER_SUPPLY_TYPE_USB_ACA]\t\t= \"USB_ACA\",\n\t[POWER_SUPPLY_TYPE_USB_TYPE_C]\t\t= \"USB_C\",\n\t[POWER_SUPPLY_TYPE_USB_PD]\t\t= \"USB_PD\",\n\t[POWER_SUPPLY_TYPE_USB_PD_DRP]\t\t= \"USB_PD_DRP\",\n\t[POWER_SUPPLY_TYPE_APPLE_BRICK_ID]\t= \"BrickID\",\n\t[POWER_SUPPLY_TYPE_WIRELESS]\t\t= \"Wireless\",\n};\n\nstatic const char * const POWER_SUPPLY_USB_TYPE_TEXT[] = {\n\t[POWER_SUPPLY_USB_TYPE_UNKNOWN]\t\t= \"Unknown\",\n\t[POWER_SUPPLY_USB_TYPE_SDP]\t\t= \"SDP\",\n\t[POWER_SUPPLY_USB_TYPE_DCP]\t\t= \"DCP\",\n\t[POWER_SUPPLY_USB_TYPE_CDP]\t\t= \"CDP\",\n\t[POWER_SUPPLY_USB_TYPE_ACA]\t\t= \"ACA\",\n\t[POWER_SUPPLY_USB_TYPE_C]\t\t= \"C\",\n\t[POWER_SUPPLY_USB_TYPE_PD]\t\t= \"PD\",\n\t[POWER_SUPPLY_USB_TYPE_PD_DRP]\t\t= \"PD_DRP\",\n\t[POWER_SUPPLY_USB_TYPE_PD_PPS]\t\t= \"PD_PPS\",\n\t[POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID]\t= \"BrickID\",\n};\n\nstatic const char * const POWER_SUPPLY_STATUS_TEXT[] = {\n\t[POWER_SUPPLY_STATUS_UNKNOWN]\t\t= \"Unknown\",\n\t[POWER_SUPPLY_STATUS_CHARGING]\t\t= \"Charging\",\n\t[POWER_SUPPLY_STATUS_DISCHARGING]\t= \"Discharging\",\n\t[POWER_SUPPLY_STATUS_NOT_CHARGING]\t= \"Not charging\",\n\t[POWER_SUPPLY_STATUS_FULL]\t\t= \"Full\",\n};\n\nstatic const char * const POWER_SUPPLY_CHARGE_TYPE_TEXT[] = {\n\t[POWER_SUPPLY_CHARGE_TYPE_UNKNOWN]\t= \"Unknown\",\n\t[POWER_SUPPLY_CHARGE_TYPE_NONE]\t\t= \"N/A\",\n\t[POWER_SUPPLY_CHARGE_TYPE_TRICKLE]\t= \"Trickle\",\n\t[POWER_SUPPLY_CHARGE_TYPE_FAST]\t\t= \"Fast\",\n\t[POWER_SUPPLY_CHARGE_TYPE_STANDARD]\t= \"Standard\",\n\t[POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE]\t= \"Adaptive\",\n\t[POWER_SUPPLY_CHARGE_TYPE_CUSTOM]\t= \"Custom\",\n\t[POWER_SUPPLY_CHARGE_TYPE_LONGLIFE]\t= \"Long Life\",\n\t[POWER_SUPPLY_CHARGE_TYPE_BYPASS]\t= \"Bypass\",\n};\n\nstatic const char * const POWER_SUPPLY_HEALTH_TEXT[] = {\n\t[POWER_SUPPLY_HEALTH_UNKNOWN]\t\t    = \"Unknown\",\n\t[POWER_SUPPLY_HEALTH_GOOD]\t\t    = \"Good\",\n\t[POWER_SUPPLY_HEALTH_OVERHEAT]\t\t    = \"Overheat\",\n\t[POWER_SUPPLY_HEALTH_DEAD]\t\t    = \"Dead\",\n\t[POWER_SUPPLY_HEALTH_OVERVOLTAGE]\t    = \"Over voltage\",\n\t[POWER_SUPPLY_HEALTH_UNSPEC_FAILURE]\t    = \"Unspecified failure\",\n\t[POWER_SUPPLY_HEALTH_COLD]\t\t    = \"Cold\",\n\t[POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE] = \"Watchdog timer expire\",\n\t[POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE]   = \"Safety timer expire\",\n\t[POWER_SUPPLY_HEALTH_OVERCURRENT]\t    = \"Over current\",\n\t[POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED]  = \"Calibration required\",\n\t[POWER_SUPPLY_HEALTH_WARM]\t\t    = \"Warm\",\n\t[POWER_SUPPLY_HEALTH_COOL]\t\t    = \"Cool\",\n\t[POWER_SUPPLY_HEALTH_HOT]\t\t    = \"Hot\",\n\t[POWER_SUPPLY_HEALTH_NO_BATTERY]\t    = \"No battery\",\n};\n\nstatic const char * const POWER_SUPPLY_TECHNOLOGY_TEXT[] = {\n\t[POWER_SUPPLY_TECHNOLOGY_UNKNOWN]\t= \"Unknown\",\n\t[POWER_SUPPLY_TECHNOLOGY_NiMH]\t\t= \"NiMH\",\n\t[POWER_SUPPLY_TECHNOLOGY_LION]\t\t= \"Li-ion\",\n\t[POWER_SUPPLY_TECHNOLOGY_LIPO]\t\t= \"Li-poly\",\n\t[POWER_SUPPLY_TECHNOLOGY_LiFe]\t\t= \"LiFe\",\n\t[POWER_SUPPLY_TECHNOLOGY_NiCd]\t\t= \"NiCd\",\n\t[POWER_SUPPLY_TECHNOLOGY_LiMn]\t\t= \"LiMn\",\n};\n\nstatic const char * const POWER_SUPPLY_CAPACITY_LEVEL_TEXT[] = {\n\t[POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN]\t= \"Unknown\",\n\t[POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL]\t= \"Critical\",\n\t[POWER_SUPPLY_CAPACITY_LEVEL_LOW]\t= \"Low\",\n\t[POWER_SUPPLY_CAPACITY_LEVEL_NORMAL]\t= \"Normal\",\n\t[POWER_SUPPLY_CAPACITY_LEVEL_HIGH]\t= \"High\",\n\t[POWER_SUPPLY_CAPACITY_LEVEL_FULL]\t= \"Full\",\n};\n\nstatic const char * const POWER_SUPPLY_SCOPE_TEXT[] = {\n\t[POWER_SUPPLY_SCOPE_UNKNOWN]\t= \"Unknown\",\n\t[POWER_SUPPLY_SCOPE_SYSTEM]\t= \"System\",\n\t[POWER_SUPPLY_SCOPE_DEVICE]\t= \"Device\",\n};\n\nstatic const char * const POWER_SUPPLY_CHARGE_BEHAVIOUR_TEXT[] = {\n\t[POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO]\t\t= \"auto\",\n\t[POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE]\t= \"inhibit-charge\",\n\t[POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE]\t= \"force-discharge\",\n};\n\nstatic struct power_supply_attr power_supply_attrs[] = {\n\t \n\tPOWER_SUPPLY_ENUM_ATTR(STATUS),\n\tPOWER_SUPPLY_ENUM_ATTR(CHARGE_TYPE),\n\tPOWER_SUPPLY_ENUM_ATTR(HEALTH),\n\tPOWER_SUPPLY_ATTR(PRESENT),\n\tPOWER_SUPPLY_ATTR(ONLINE),\n\tPOWER_SUPPLY_ATTR(AUTHENTIC),\n\tPOWER_SUPPLY_ENUM_ATTR(TECHNOLOGY),\n\tPOWER_SUPPLY_ATTR(CYCLE_COUNT),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_MAX),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_MIN),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_MAX_DESIGN),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_MIN_DESIGN),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_NOW),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_AVG),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_OCV),\n\tPOWER_SUPPLY_ATTR(VOLTAGE_BOOT),\n\tPOWER_SUPPLY_ATTR(CURRENT_MAX),\n\tPOWER_SUPPLY_ATTR(CURRENT_NOW),\n\tPOWER_SUPPLY_ATTR(CURRENT_AVG),\n\tPOWER_SUPPLY_ATTR(CURRENT_BOOT),\n\tPOWER_SUPPLY_ATTR(POWER_NOW),\n\tPOWER_SUPPLY_ATTR(POWER_AVG),\n\tPOWER_SUPPLY_ATTR(CHARGE_FULL_DESIGN),\n\tPOWER_SUPPLY_ATTR(CHARGE_EMPTY_DESIGN),\n\tPOWER_SUPPLY_ATTR(CHARGE_FULL),\n\tPOWER_SUPPLY_ATTR(CHARGE_EMPTY),\n\tPOWER_SUPPLY_ATTR(CHARGE_NOW),\n\tPOWER_SUPPLY_ATTR(CHARGE_AVG),\n\tPOWER_SUPPLY_ATTR(CHARGE_COUNTER),\n\tPOWER_SUPPLY_ATTR(CONSTANT_CHARGE_CURRENT),\n\tPOWER_SUPPLY_ATTR(CONSTANT_CHARGE_CURRENT_MAX),\n\tPOWER_SUPPLY_ATTR(CONSTANT_CHARGE_VOLTAGE),\n\tPOWER_SUPPLY_ATTR(CONSTANT_CHARGE_VOLTAGE_MAX),\n\tPOWER_SUPPLY_ATTR(CHARGE_CONTROL_LIMIT),\n\tPOWER_SUPPLY_ATTR(CHARGE_CONTROL_LIMIT_MAX),\n\tPOWER_SUPPLY_ATTR(CHARGE_CONTROL_START_THRESHOLD),\n\tPOWER_SUPPLY_ATTR(CHARGE_CONTROL_END_THRESHOLD),\n\tPOWER_SUPPLY_ENUM_ATTR(CHARGE_BEHAVIOUR),\n\tPOWER_SUPPLY_ATTR(INPUT_CURRENT_LIMIT),\n\tPOWER_SUPPLY_ATTR(INPUT_VOLTAGE_LIMIT),\n\tPOWER_SUPPLY_ATTR(INPUT_POWER_LIMIT),\n\tPOWER_SUPPLY_ATTR(ENERGY_FULL_DESIGN),\n\tPOWER_SUPPLY_ATTR(ENERGY_EMPTY_DESIGN),\n\tPOWER_SUPPLY_ATTR(ENERGY_FULL),\n\tPOWER_SUPPLY_ATTR(ENERGY_EMPTY),\n\tPOWER_SUPPLY_ATTR(ENERGY_NOW),\n\tPOWER_SUPPLY_ATTR(ENERGY_AVG),\n\tPOWER_SUPPLY_ATTR(CAPACITY),\n\tPOWER_SUPPLY_ATTR(CAPACITY_ALERT_MIN),\n\tPOWER_SUPPLY_ATTR(CAPACITY_ALERT_MAX),\n\tPOWER_SUPPLY_ATTR(CAPACITY_ERROR_MARGIN),\n\tPOWER_SUPPLY_ENUM_ATTR(CAPACITY_LEVEL),\n\tPOWER_SUPPLY_ATTR(TEMP),\n\tPOWER_SUPPLY_ATTR(TEMP_MAX),\n\tPOWER_SUPPLY_ATTR(TEMP_MIN),\n\tPOWER_SUPPLY_ATTR(TEMP_ALERT_MIN),\n\tPOWER_SUPPLY_ATTR(TEMP_ALERT_MAX),\n\tPOWER_SUPPLY_ATTR(TEMP_AMBIENT),\n\tPOWER_SUPPLY_ATTR(TEMP_AMBIENT_ALERT_MIN),\n\tPOWER_SUPPLY_ATTR(TEMP_AMBIENT_ALERT_MAX),\n\tPOWER_SUPPLY_ATTR(TIME_TO_EMPTY_NOW),\n\tPOWER_SUPPLY_ATTR(TIME_TO_EMPTY_AVG),\n\tPOWER_SUPPLY_ATTR(TIME_TO_FULL_NOW),\n\tPOWER_SUPPLY_ATTR(TIME_TO_FULL_AVG),\n\tPOWER_SUPPLY_ENUM_ATTR(TYPE),\n\tPOWER_SUPPLY_ATTR(USB_TYPE),\n\tPOWER_SUPPLY_ENUM_ATTR(SCOPE),\n\tPOWER_SUPPLY_ATTR(PRECHARGE_CURRENT),\n\tPOWER_SUPPLY_ATTR(CHARGE_TERM_CURRENT),\n\tPOWER_SUPPLY_ATTR(CALIBRATE),\n\tPOWER_SUPPLY_ATTR(MANUFACTURE_YEAR),\n\tPOWER_SUPPLY_ATTR(MANUFACTURE_MONTH),\n\tPOWER_SUPPLY_ATTR(MANUFACTURE_DAY),\n\t \n\tPOWER_SUPPLY_ATTR(MODEL_NAME),\n\tPOWER_SUPPLY_ATTR(MANUFACTURER),\n\tPOWER_SUPPLY_ATTR(SERIAL_NUMBER),\n};\n#define POWER_SUPPLY_ATTR_CNT ARRAY_SIZE(power_supply_attrs)\n\nstatic struct attribute *\n__power_supply_attrs[POWER_SUPPLY_ATTR_CNT + 1];\n\nstatic struct power_supply_attr *to_ps_attr(struct device_attribute *attr)\n{\n\treturn container_of(attr, struct power_supply_attr, dev_attr);\n}\n\nstatic enum power_supply_property dev_attr_psp(struct device_attribute *attr)\n{\n\treturn  to_ps_attr(attr) - power_supply_attrs;\n}\n\nstatic ssize_t power_supply_show_usb_type(struct device *dev,\n\t\t\t\t\t  const struct power_supply_desc *desc,\n\t\t\t\t\t  union power_supply_propval *value,\n\t\t\t\t\t  char *buf)\n{\n\tenum power_supply_usb_type usb_type;\n\tssize_t count = 0;\n\tbool match = false;\n\tint i;\n\n\tfor (i = 0; i < desc->num_usb_types; ++i) {\n\t\tusb_type = desc->usb_types[i];\n\n\t\tif (value->intval == usb_type) {\n\t\t\tcount += sysfs_emit_at(buf, count, \"[%s] \",\n\t\t\t\t\t POWER_SUPPLY_USB_TYPE_TEXT[usb_type]);\n\t\t\tmatch = true;\n\t\t} else {\n\t\t\tcount += sysfs_emit_at(buf, count, \"%s \",\n\t\t\t\t\t POWER_SUPPLY_USB_TYPE_TEXT[usb_type]);\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tdev_warn(dev, \"driver reporting unsupported connected type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count)\n\t\tbuf[count - 1] = '\\n';\n\n\treturn count;\n}\n\nstatic ssize_t power_supply_show_property(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf) {\n\tssize_t ret;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct power_supply_attr *ps_attr = to_ps_attr(attr);\n\tenum power_supply_property psp = dev_attr_psp(attr);\n\tunion power_supply_propval value;\n\n\tif (psp == POWER_SUPPLY_PROP_TYPE) {\n\t\tvalue.intval = psy->desc->type;\n\t} else {\n\t\tret = power_supply_get_property(psy, psp, &value);\n\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tdev_dbg_ratelimited(dev,\n\t\t\t\t\t\"driver has no data for `%s' property\\n\",\n\t\t\t\t\tattr->attr.name);\n\t\t\telse if (ret != -ENODEV && ret != -EAGAIN)\n\t\t\t\tdev_err_ratelimited(dev,\n\t\t\t\t\t\"driver failed to report `%s' property: %zd\\n\",\n\t\t\t\t\tattr->attr.name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ps_attr->text_values_len > 0 &&\n\t    value.intval < ps_attr->text_values_len && value.intval >= 0) {\n\t\treturn sysfs_emit(buf, \"%s\\n\", ps_attr->text_values[value.intval]);\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tret = power_supply_show_usb_type(dev, psy->desc,\n\t\t\t\t\t\t&value, buf);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME ... POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tret = sysfs_emit(buf, \"%s\\n\", value.strval);\n\t\tbreak;\n\tdefault:\n\t\tret = sysfs_emit(buf, \"%d\\n\", value.intval);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t power_supply_store_property(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count) {\n\tssize_t ret;\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct power_supply_attr *ps_attr = to_ps_attr(attr);\n\tenum power_supply_property psp = dev_attr_psp(attr);\n\tunion power_supply_propval value;\n\n\tret = -EINVAL;\n\tif (ps_attr->text_values_len > 0) {\n\t\tret = __sysfs_match_string(ps_attr->text_values,\n\t\t\t\t\t   ps_attr->text_values_len, buf);\n\t}\n\n\t \n\tif (ret < 0) {\n\t\tlong long_val;\n\n\t\tret = kstrtol(buf, 10, &long_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = long_val;\n\t}\n\n\tvalue.intval = ret;\n\n\tret = power_supply_set_property(psy, psp, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic umode_t power_supply_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t   struct attribute *attr,\n\t\t\t\t\t   int attrno)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tumode_t mode = S_IRUSR | S_IRGRP | S_IROTH;\n\tint i;\n\n\tif (!power_supply_attrs[attrno].prop_name)\n\t\treturn 0;\n\n\tif (attrno == POWER_SUPPLY_PROP_TYPE)\n\t\treturn mode;\n\n\tfor (i = 0; i < psy->desc->num_properties; i++) {\n\t\tint property = psy->desc->properties[i];\n\n\t\tif (property == attrno) {\n\t\t\tif (psy->desc->property_is_writeable &&\n\t\t\t    psy->desc->property_is_writeable(psy, property) > 0)\n\t\t\t\tmode |= S_IWUSR;\n\n\t\t\treturn mode;\n\t\t}\n\t}\n\n\tif (power_supply_battery_info_has_prop(psy->battery_info, attrno))\n\t\treturn mode;\n\n\treturn 0;\n}\n\nstatic const struct attribute_group power_supply_attr_group = {\n\t.attrs = __power_supply_attrs,\n\t.is_visible = power_supply_attr_is_visible,\n};\n\nstatic const struct attribute_group *power_supply_attr_groups[] = {\n\t&power_supply_attr_group,\n\tNULL,\n};\n\nstatic void str_to_lower(char *str)\n{\n\twhile (*str) {\n\t\t*str = tolower(*str);\n\t\tstr++;\n\t}\n}\n\nvoid power_supply_init_attrs(struct device_type *dev_type)\n{\n\tint i;\n\n\tdev_type->groups = power_supply_attr_groups;\n\n\tfor (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++) {\n\t\tstruct device_attribute *attr;\n\n\t\tif (!power_supply_attrs[i].prop_name) {\n\t\t\tpr_warn(\"%s: Property %d skipped because it is missing from power_supply_attrs\\n\",\n\t\t\t\t__func__, i);\n\t\t\tsprintf(power_supply_attrs[i].attr_name, \"_err_%d\", i);\n\t\t} else {\n\t\t\tstr_to_lower(power_supply_attrs[i].attr_name);\n\t\t}\n\n\t\tattr = &power_supply_attrs[i].dev_attr;\n\n\t\tattr->attr.name = power_supply_attrs[i].attr_name;\n\t\tattr->show = power_supply_show_property;\n\t\tattr->store = power_supply_store_property;\n\t\t__power_supply_attrs[i] = &attr->attr;\n\t}\n}\n\nstatic int add_prop_uevent(const struct device *dev, struct kobj_uevent_env *env,\n\t\t\t   enum power_supply_property prop, char *prop_buf)\n{\n\tint ret = 0;\n\tstruct power_supply_attr *pwr_attr;\n\tstruct device_attribute *dev_attr;\n\tchar *line;\n\n\tpwr_attr = &power_supply_attrs[prop];\n\tdev_attr = &pwr_attr->dev_attr;\n\n\tret = power_supply_show_property((struct device *)dev, dev_attr, prop_buf);\n\tif (ret == -ENODEV || ret == -ENODATA) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tline = strchr(prop_buf, '\\n');\n\tif (line)\n\t\t*line = 0;\n\n\treturn add_uevent_var(env, \"POWER_SUPPLY_%s=%s\",\n\t\t\t      pwr_attr->prop_name, prop_buf);\n}\n\nint power_supply_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct power_supply *psy = dev_get_drvdata(dev);\n\tconst enum power_supply_property *battery_props =\n\t\tpower_supply_battery_info_properties;\n\tunsigned long psy_drv_properties[POWER_SUPPLY_ATTR_CNT /\n\t\t\t\t\t sizeof(unsigned long) + 1] = {0};\n\tint ret = 0, j;\n\tchar *prop_buf;\n\n\tif (!psy || !psy->desc) {\n\t\tdev_dbg(dev, \"No power supply yet\\n\");\n\t\treturn ret;\n\t}\n\n\tret = add_uevent_var(env, \"POWER_SUPPLY_NAME=%s\", psy->desc->name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (psy->removing)\n\t\treturn 0;\n\n\tprop_buf = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!prop_buf)\n\t\treturn -ENOMEM;\n\n\tret = add_prop_uevent(dev, env, POWER_SUPPLY_PROP_TYPE, prop_buf);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (j = 0; j < psy->desc->num_properties; j++) {\n\t\tset_bit(psy->desc->properties[j], psy_drv_properties);\n\t\tret = add_prop_uevent(dev, env, psy->desc->properties[j],\n\t\t\t\t      prop_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tfor (j = 0; j < power_supply_battery_info_properties_size; j++) {\n\t\tif (test_bit(battery_props[j], psy_drv_properties))\n\t\t\tcontinue;\n\t\tif (!power_supply_battery_info_has_prop(psy->battery_info,\n\t\t\t\tbattery_props[j]))\n\t\t\tcontinue;\n\t\tret = add_prop_uevent(dev, env, battery_props[j],\n\t\t\t      prop_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_page((unsigned long)prop_buf);\n\n\treturn ret;\n}\n\nssize_t power_supply_charge_behaviour_show(struct device *dev,\n\t\t\t\t\t   unsigned int available_behaviours,\n\t\t\t\t\t   enum power_supply_charge_behaviour current_behaviour,\n\t\t\t\t\t   char *buf)\n{\n\tbool match = false, available, active;\n\tssize_t count = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(POWER_SUPPLY_CHARGE_BEHAVIOUR_TEXT); i++) {\n\t\tavailable = available_behaviours & BIT(i);\n\t\tactive = i == current_behaviour;\n\n\t\tif (available && active) {\n\t\t\tcount += sysfs_emit_at(buf, count, \"[%s] \",\n\t\t\t\t\t       POWER_SUPPLY_CHARGE_BEHAVIOUR_TEXT[i]);\n\t\t\tmatch = true;\n\t\t} else if (available) {\n\t\t\tcount += sysfs_emit_at(buf, count, \"%s \",\n\t\t\t\t\t       POWER_SUPPLY_CHARGE_BEHAVIOUR_TEXT[i]);\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tdev_warn(dev, \"driver reporting unsupported charge behaviour\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count)\n\t\tbuf[count - 1] = '\\n';\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(power_supply_charge_behaviour_show);\n\nint power_supply_charge_behaviour_parse(unsigned int available_behaviours, const char *buf)\n{\n\tint i = sysfs_match_string(POWER_SUPPLY_CHARGE_BEHAVIOUR_TEXT, buf);\n\n\tif (i < 0)\n\t\treturn i;\n\n\tif (available_behaviours & BIT(i))\n\t\treturn i;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(power_supply_charge_behaviour_parse);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}