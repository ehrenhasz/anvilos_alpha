{
  "module_name": "max14656_charger_detector.c",
  "hash_id": "3e6a9c4c546ff12f5acd76c9cae77524179cf30dd55f23e73a2223e468524cc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max14656_charger_detector.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/power_supply.h>\n#include <linux/devm-helpers.h>\n\n#define MAX14656_MANUFACTURER\t\"Maxim Integrated\"\n#define MAX14656_NAME\t\t\"max14656\"\n\n#define MAX14656_DEVICE_ID\t0x00\n#define MAX14656_INTERRUPT_1\t0x01\n#define MAX14656_INTERRUPT_2\t0x02\n#define MAX14656_STATUS_1\t0x03\n#define MAX14656_STATUS_2\t0x04\n#define MAX14656_INTMASK_1\t0x05\n#define MAX14656_INTMASK_2\t0x06\n#define MAX14656_CONTROL_1\t0x07\n#define MAX14656_CONTROL_2\t0x08\n#define MAX14656_CONTROL_3\t0x09\n\n#define DEVICE_VENDOR_MASK\t0xf0\n#define DEVICE_REV_MASK\t\t0x0f\n#define INT_EN_REG_MASK\t\tBIT(4)\n#define CHG_TYPE_INT_MASK\tBIT(0)\n#define STATUS1_VB_VALID_MASK\tBIT(4)\n#define STATUS1_CHG_TYPE_MASK\t0xf\n#define INT1_DCD_TIMEOUT_MASK\tBIT(7)\n#define CONTROL1_DEFAULT\t0x0d\n#define CONTROL1_INT_EN\t\tBIT(4)\n#define CONTROL1_INT_ACTIVE_HIGH\tBIT(5)\n#define CONTROL1_EDGE\t\tBIT(7)\n#define CONTROL2_DEFAULT\t0x8e\n#define CONTROL2_ADC_EN\t\tBIT(0)\n#define CONTROL3_DEFAULT\t0x8d\n\nenum max14656_chg_type {\n\tMAX14656_NO_CHARGER\t= 0,\n\tMAX14656_SDP_CHARGER,\n\tMAX14656_CDP_CHARGER,\n\tMAX14656_DCP_CHARGER,\n\tMAX14656_APPLE_500MA_CHARGER,\n\tMAX14656_APPLE_1A_CHARGER,\n\tMAX14656_APPLE_2A_CHARGER,\n\tMAX14656_SPECIAL_500MA_CHARGER,\n\tMAX14656_APPLE_12W,\n\tMAX14656_CHARGER_LAST\n};\n\nstatic const struct max14656_chg_type_props {\n\tenum power_supply_type type;\n} chg_type_props[] = {\n\t{ POWER_SUPPLY_TYPE_UNKNOWN },\n\t{ POWER_SUPPLY_TYPE_USB },\n\t{ POWER_SUPPLY_TYPE_USB_CDP },\n\t{ POWER_SUPPLY_TYPE_USB_DCP },\n\t{ POWER_SUPPLY_TYPE_USB_DCP },\n\t{ POWER_SUPPLY_TYPE_USB_DCP },\n\t{ POWER_SUPPLY_TYPE_USB_DCP },\n\t{ POWER_SUPPLY_TYPE_USB_DCP },\n\t{ POWER_SUPPLY_TYPE_USB },\n};\n\nstruct max14656_chip {\n\tstruct i2c_client\t*client;\n\tstruct power_supply\t*detect_psy;\n\tstruct power_supply_desc psy_desc;\n\tstruct delayed_work\tirq_work;\n\n\tint irq;\n\tint online;\n};\n\nstatic int max14656_read_reg(struct i2c_client *client, int reg, u8 *val)\n{\n\ts32 ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"i2c read fail: can't read from %02x: %d\\n\",\n\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\t*val = ret;\n\treturn 0;\n}\n\nstatic int max14656_write_reg(struct i2c_client *client, int reg, u8 val)\n{\n\ts32 ret;\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"i2c write fail: can't write %02x to %02x: %d\\n\",\n\t\t\tval, reg, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int max14656_read_block_reg(struct i2c_client *client, u8 reg,\n\t\t\t\t  u8 length, u8 *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, length, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to block read reg 0x%x: %d\\n\",\n\t\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define        REG_TOTAL_NUM   5\nstatic void max14656_irq_worker(struct work_struct *work)\n{\n\tstruct max14656_chip *chip =\n\t\tcontainer_of(work, struct max14656_chip, irq_work.work);\n\n\tu8 buf[REG_TOTAL_NUM];\n\tu8 chg_type;\n\n\tmax14656_read_block_reg(chip->client, MAX14656_DEVICE_ID,\n\t\t\t\tREG_TOTAL_NUM, buf);\n\n\tif ((buf[MAX14656_STATUS_1] & STATUS1_VB_VALID_MASK) &&\n\t\t(buf[MAX14656_STATUS_1] & STATUS1_CHG_TYPE_MASK)) {\n\t\tchg_type = buf[MAX14656_STATUS_1] & STATUS1_CHG_TYPE_MASK;\n\t\tif (chg_type < MAX14656_CHARGER_LAST)\n\t\t\tchip->psy_desc.type = chg_type_props[chg_type].type;\n\t\telse\n\t\t\tchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\n\t\tchip->online = 1;\n\t} else {\n\t\tchip->online = 0;\n\t\tchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\n\t}\n\n\tpower_supply_changed(chip->detect_psy);\n}\n\nstatic irqreturn_t max14656_irq(int irq, void *dev_id)\n{\n\tstruct max14656_chip *chip = dev_id;\n\n\tschedule_delayed_work(&chip->irq_work, msecs_to_jiffies(100));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max14656_hw_init(struct max14656_chip *chip)\n{\n\tuint8_t val = 0;\n\tuint8_t rev;\n\tstruct i2c_client *client = chip->client;\n\n\tif (max14656_read_reg(client, MAX14656_DEVICE_ID, &val))\n\t\treturn -ENODEV;\n\n\tif ((val & DEVICE_VENDOR_MASK) != 0x20) {\n\t\tdev_err(&client->dev, \"wrong vendor ID %d\\n\",\n\t\t\t((val & DEVICE_VENDOR_MASK) >> 4));\n\t\treturn -ENODEV;\n\t}\n\trev = val & DEVICE_REV_MASK;\n\n\t \n\tif (max14656_write_reg(client, MAX14656_CONTROL_2, CONTROL2_ADC_EN))\n\t\treturn -EINVAL;\n\n\t \n\tif (max14656_write_reg(client, MAX14656_CONTROL_1,\n\t\tCONTROL1_DEFAULT |\n\t\tCONTROL1_INT_EN |\n\t\tCONTROL1_INT_ACTIVE_HIGH |\n\t\tCONTROL1_EDGE))\n\t\treturn -EINVAL;\n\n\tif (max14656_write_reg(client, MAX14656_INTMASK_1, 0x3))\n\t\treturn -EINVAL;\n\n\tif (max14656_write_reg(client, MAX14656_INTMASK_2, 0x1))\n\t\treturn -EINVAL;\n\n\tdev_info(&client->dev, \"detected revision %d\\n\", rev);\n\treturn 0;\n}\n\nstatic int max14656_get_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tstruct max14656_chip *chip = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = chip->online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = MAX14656_NAME;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = MAX14656_MANUFACTURER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property max14656_battery_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic int max14656_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct max14656_chip *chip;\n\tint irq = client->irq;\n\tint ret = 0;\n\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"invalid irq number: %d\\n\", irq);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"No support for SMBUS_BYTE_DATA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tpsy_cfg.drv_data = chip;\n\tchip->client = client;\n\tchip->online = 0;\n\tchip->psy_desc.name = MAX14656_NAME;\n\tchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\n\tchip->psy_desc.properties = max14656_battery_props;\n\tchip->psy_desc.num_properties = ARRAY_SIZE(max14656_battery_props);\n\tchip->psy_desc.get_property = max14656_get_property;\n\tchip->irq = irq;\n\n\tret = max14656_hw_init(chip);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tchip->detect_psy = devm_power_supply_register(dev,\n\t\t       &chip->psy_desc, &psy_cfg);\n\tif (IS_ERR(chip->detect_psy)) {\n\t\tdev_err(dev, \"power_supply_register failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_delayed_work_autocancel(dev, &chip->irq_work,\n\t\t\t\t\t   max14656_irq_worker);\n\tif (ret) {\n\t\tdev_err(dev, \"devm_delayed_work_autocancel %d failed\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, chip->irq, max14656_irq,\n\t\t\t       IRQF_TRIGGER_FALLING,\n\t\t\t       MAX14656_NAME, chip);\n\tif (ret) {\n\t\tdev_err(dev, \"request_irq %d failed\\n\", chip->irq);\n\t\treturn -EINVAL;\n\t}\n\tenable_irq_wake(chip->irq);\n\n\tschedule_delayed_work(&chip->irq_work, msecs_to_jiffies(2000));\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max14656_id[] = {\n\t{ \"max14656\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, max14656_id);\n\nstatic const struct of_device_id max14656_match_table[] = {\n\t{ .compatible = \"maxim,max14656\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, max14656_match_table);\n\nstatic struct i2c_driver max14656_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"max14656\",\n\t\t.of_match_table = max14656_match_table,\n\t},\n\t.probe\t\t= max14656_probe,\n\t.id_table\t= max14656_id,\n};\nmodule_i2c_driver(max14656_i2c_driver);\n\nMODULE_DESCRIPTION(\"MAX14656 USB charger detector\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}