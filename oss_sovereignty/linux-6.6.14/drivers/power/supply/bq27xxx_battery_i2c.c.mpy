{
  "module_name": "bq27xxx_battery_i2c.c",
  "hash_id": "e544dc24559fb6173455118b99c065426316a2c3765a88d752dd5250ea02cd51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq27xxx_battery_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <linux/power/bq27xxx_battery.h>\n\nstatic DEFINE_IDR(battery_id);\nstatic DEFINE_MUTEX(battery_mutex);\n\nstatic irqreturn_t bq27xxx_battery_irq_handler_thread(int irq, void *data)\n{\n\tstruct bq27xxx_device_info *di = data;\n\n\tbq27xxx_battery_update(di);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bq27xxx_battery_i2c_read(struct bq27xxx_device_info *di, u8 reg,\n\t\t\t\t    bool single)\n{\n\tstruct i2c_client *client = to_i2c_client(di->dev);\n\tstruct i2c_msg msg[2];\n\tu8 data[2];\n\tint ret;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = &reg;\n\tmsg[0].len = sizeof(reg);\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = data;\n\tif (single)\n\t\tmsg[1].len = 1;\n\telse\n\t\tmsg[1].len = 2;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!single)\n\t\tret = get_unaligned_le16(data);\n\telse\n\t\tret = data[0];\n\n\treturn ret;\n}\n\nstatic int bq27xxx_battery_i2c_write(struct bq27xxx_device_info *di, u8 reg,\n\t\t\t\t     int value, bool single)\n{\n\tstruct i2c_client *client = to_i2c_client(di->dev);\n\tstruct i2c_msg msg;\n\tu8 data[4];\n\tint ret;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tdata[0] = reg;\n\tif (single) {\n\t\tdata[1] = (u8) value;\n\t\tmsg.len = 2;\n\t} else {\n\t\tput_unaligned_le16(value, &data[1]);\n\t\tmsg.len = 3;\n\t}\n\n\tmsg.buf = data;\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int bq27xxx_battery_i2c_bulk_read(struct bq27xxx_device_info *di, u8 reg,\n\t\t\t\t\t u8 *data, int len)\n{\n\tstruct i2c_client *client = to_i2c_client(di->dev);\n\tint ret;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, len, data);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != len)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int bq27xxx_battery_i2c_bulk_write(struct bq27xxx_device_info *di,\n\t\t\t\t\t  u8 reg, u8 *data, int len)\n{\n\tstruct i2c_client *client = to_i2c_client(di->dev);\n\tstruct i2c_msg msg;\n\tu8 buf[33];\n\tint ret;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], data, len);\n\n\tmsg.buf = buf;\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = len + 1;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int bq27xxx_battery_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct bq27xxx_device_info *di;\n\tint ret;\n\tchar *name;\n\tint num;\n\n\t \n\tmutex_lock(&battery_mutex);\n\tnum = idr_alloc(&battery_id, client, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&battery_mutex);\n\tif (num < 0)\n\t\treturn num;\n\n\tname = devm_kasprintf(&client->dev, GFP_KERNEL, \"%s-%d\", id->name, num);\n\tif (!name)\n\t\tgoto err_mem;\n\n\tdi = devm_kzalloc(&client->dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\tgoto err_mem;\n\n\tdi->id = num;\n\tdi->dev = &client->dev;\n\tdi->chip = id->driver_data;\n\tdi->name = name;\n\n\tdi->bus.read = bq27xxx_battery_i2c_read;\n\tdi->bus.write = bq27xxx_battery_i2c_write;\n\tdi->bus.read_bulk = bq27xxx_battery_i2c_bulk_read;\n\tdi->bus.write_bulk = bq27xxx_battery_i2c_bulk_write;\n\n\tret = bq27xxx_battery_setup(di);\n\tif (ret)\n\t\tgoto err_failed;\n\n\t \n\tschedule_delayed_work(&di->work, 60 * HZ);\n\n\ti2c_set_clientdata(client, di);\n\n\tif (client->irq) {\n\t\tret = request_threaded_irq(client->irq,\n\t\t\t\tNULL, bq27xxx_battery_irq_handler_thread,\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tdi->name, di);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to register IRQ %d error %d\\n\",\n\t\t\t\tclient->irq, ret);\n\t\t\tbq27xxx_battery_teardown(di);\n\t\t\tgoto err_failed;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_mem:\n\tret = -ENOMEM;\n\nerr_failed:\n\tmutex_lock(&battery_mutex);\n\tidr_remove(&battery_id, num);\n\tmutex_unlock(&battery_mutex);\n\n\treturn ret;\n}\n\nstatic void bq27xxx_battery_i2c_remove(struct i2c_client *client)\n{\n\tstruct bq27xxx_device_info *di = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, di);\n\tbq27xxx_battery_teardown(di);\n\n\tmutex_lock(&battery_mutex);\n\tidr_remove(&battery_id, di->id);\n\tmutex_unlock(&battery_mutex);\n}\n\nstatic const struct i2c_device_id bq27xxx_i2c_id_table[] = {\n\t{ \"bq27200\", BQ27000 },\n\t{ \"bq27210\", BQ27010 },\n\t{ \"bq27500\", BQ2750X },\n\t{ \"bq27510\", BQ2751X },\n\t{ \"bq27520\", BQ2752X },\n\t{ \"bq27500-1\", BQ27500 },\n\t{ \"bq27510g1\", BQ27510G1 },\n\t{ \"bq27510g2\", BQ27510G2 },\n\t{ \"bq27510g3\", BQ27510G3 },\n\t{ \"bq27520g1\", BQ27520G1 },\n\t{ \"bq27520g2\", BQ27520G2 },\n\t{ \"bq27520g3\", BQ27520G3 },\n\t{ \"bq27520g4\", BQ27520G4 },\n\t{ \"bq27521\", BQ27521 },\n\t{ \"bq27530\", BQ27530 },\n\t{ \"bq27531\", BQ27531 },\n\t{ \"bq27541\", BQ27541 },\n\t{ \"bq27542\", BQ27542 },\n\t{ \"bq27546\", BQ27546 },\n\t{ \"bq27742\", BQ27742 },\n\t{ \"bq27545\", BQ27545 },\n\t{ \"bq27411\", BQ27411 },\n\t{ \"bq27421\", BQ27421 },\n\t{ \"bq27425\", BQ27425 },\n\t{ \"bq27426\", BQ27426 },\n\t{ \"bq27441\", BQ27441 },\n\t{ \"bq27621\", BQ27621 },\n\t{ \"bq27z561\", BQ27Z561 },\n\t{ \"bq28z610\", BQ28Z610 },\n\t{ \"bq34z100\", BQ34Z100 },\n\t{ \"bq78z100\", BQ78Z100 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, bq27xxx_i2c_id_table);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id bq27xxx_battery_i2c_of_match_table[] = {\n\t{ .compatible = \"ti,bq27200\" },\n\t{ .compatible = \"ti,bq27210\" },\n\t{ .compatible = \"ti,bq27500\" },\n\t{ .compatible = \"ti,bq27510\" },\n\t{ .compatible = \"ti,bq27520\" },\n\t{ .compatible = \"ti,bq27500-1\" },\n\t{ .compatible = \"ti,bq27510g1\" },\n\t{ .compatible = \"ti,bq27510g2\" },\n\t{ .compatible = \"ti,bq27510g3\" },\n\t{ .compatible = \"ti,bq27520g1\" },\n\t{ .compatible = \"ti,bq27520g2\" },\n\t{ .compatible = \"ti,bq27520g3\" },\n\t{ .compatible = \"ti,bq27520g4\" },\n\t{ .compatible = \"ti,bq27521\" },\n\t{ .compatible = \"ti,bq27530\" },\n\t{ .compatible = \"ti,bq27531\" },\n\t{ .compatible = \"ti,bq27541\" },\n\t{ .compatible = \"ti,bq27542\" },\n\t{ .compatible = \"ti,bq27546\" },\n\t{ .compatible = \"ti,bq27742\" },\n\t{ .compatible = \"ti,bq27545\" },\n\t{ .compatible = \"ti,bq27411\" },\n\t{ .compatible = \"ti,bq27421\" },\n\t{ .compatible = \"ti,bq27425\" },\n\t{ .compatible = \"ti,bq27426\" },\n\t{ .compatible = \"ti,bq27441\" },\n\t{ .compatible = \"ti,bq27621\" },\n\t{ .compatible = \"ti,bq27z561\" },\n\t{ .compatible = \"ti,bq28z610\" },\n\t{ .compatible = \"ti,bq34z100\" },\n\t{ .compatible = \"ti,bq78z100\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bq27xxx_battery_i2c_of_match_table);\n#endif\n\nstatic struct i2c_driver bq27xxx_battery_i2c_driver = {\n\t.driver = {\n\t\t.name = \"bq27xxx-battery\",\n\t\t.of_match_table = of_match_ptr(bq27xxx_battery_i2c_of_match_table),\n\t},\n\t.probe = bq27xxx_battery_i2c_probe,\n\t.remove = bq27xxx_battery_i2c_remove,\n\t.id_table = bq27xxx_i2c_id_table,\n};\nmodule_i2c_driver(bq27xxx_battery_i2c_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"BQ27xxx battery monitor i2c driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}