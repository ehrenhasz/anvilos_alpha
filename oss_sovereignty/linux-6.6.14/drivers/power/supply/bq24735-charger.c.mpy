{
  "module_name": "bq24735-charger.c",
  "hash_id": "364d1c18b0455d8a1ef3467f891b6e818efa9836ef674f2a9a6a61bc0ba7c02f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq24735-charger.c",
  "human_readable_source": " \n\n#include <linux/devm-helpers.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n\n#include <linux/power/bq24735-charger.h>\n\n \n#define BQ24735_CHARGE_OPT\t\t0x12\n#define BQ24735_CHARGE_CURRENT\t\t0x14\n#define BQ24735_CHARGE_CURRENT_MASK\t0x1fc0\n#define BQ24735_CHARGE_VOLTAGE\t\t0x15\n#define BQ24735_CHARGE_VOLTAGE_MASK\t0x7ff0\n#define BQ24735_INPUT_CURRENT\t\t0x3f\n#define BQ24735_INPUT_CURRENT_MASK\t0x1f80\n#define BQ24735_MANUFACTURER_ID\t\t0xfe\n#define BQ24735_DEVICE_ID\t\t0xff\n\n \n#define BQ24735_CHARGE_OPT_CHG_DISABLE\t(1 << 0)\n#define BQ24735_CHARGE_OPT_AC_PRESENT\t(1 << 4)\n\nstruct bq24735 {\n\tstruct power_supply\t\t*charger;\n\tstruct power_supply_desc\tcharger_desc;\n\tstruct i2c_client\t\t*client;\n\tstruct bq24735_platform\t\t*pdata;\n\tstruct mutex\t\t\tlock;\n\tstruct gpio_desc\t\t*status_gpio;\n\tstruct delayed_work\t\tpoll;\n\tu32\t\t\t\tpoll_interval;\n\tbool\t\t\t\tcharging;\n};\n\nstatic inline struct bq24735 *to_bq24735(struct power_supply *psy)\n{\n\treturn power_supply_get_drvdata(psy);\n}\n\nstatic enum power_supply_property bq24735_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic int bq24735_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\t enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int bq24735_write_word(struct i2c_client *client, u8 reg,\n\t\t\t\t     u16 value)\n{\n\treturn i2c_smbus_write_word_data(client, reg, value);\n}\n\nstatic inline int bq24735_read_word(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_word_data(client, reg);\n}\n\nstatic int bq24735_update_word(struct i2c_client *client, u8 reg,\n\t\t\t       u16 mask, u16 value)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = bq24735_read_word(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = ret & ~mask;\n\ttmp |= value & mask;\n\n\treturn bq24735_write_word(client, reg, tmp);\n}\n\nstatic int bq24735_config_charger(struct bq24735 *charger)\n{\n\tstruct bq24735_platform *pdata = charger->pdata;\n\tint ret;\n\tu16 value;\n\n\tif (pdata->ext_control)\n\t\treturn 0;\n\n\tif (pdata->charge_current) {\n\t\tvalue = pdata->charge_current & BQ24735_CHARGE_CURRENT_MASK;\n\n\t\tret = bq24735_write_word(charger->client,\n\t\t\t\t\t BQ24735_CHARGE_CURRENT, value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&charger->client->dev,\n\t\t\t\t\"Failed to write charger current : %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pdata->charge_voltage) {\n\t\tvalue = pdata->charge_voltage & BQ24735_CHARGE_VOLTAGE_MASK;\n\n\t\tret = bq24735_write_word(charger->client,\n\t\t\t\t\t BQ24735_CHARGE_VOLTAGE, value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&charger->client->dev,\n\t\t\t\t\"Failed to write charger voltage : %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pdata->input_current) {\n\t\tvalue = pdata->input_current & BQ24735_INPUT_CURRENT_MASK;\n\n\t\tret = bq24735_write_word(charger->client,\n\t\t\t\t\t BQ24735_INPUT_CURRENT, value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&charger->client->dev,\n\t\t\t\t\"Failed to write input current : %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int bq24735_enable_charging(struct bq24735 *charger)\n{\n\tint ret;\n\n\tif (charger->pdata->ext_control)\n\t\treturn 0;\n\n\tret = bq24735_config_charger(charger);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bq24735_update_word(charger->client, BQ24735_CHARGE_OPT,\n\t\t\t\t   BQ24735_CHARGE_OPT_CHG_DISABLE, 0);\n}\n\nstatic inline int bq24735_disable_charging(struct bq24735 *charger)\n{\n\tif (charger->pdata->ext_control)\n\t\treturn 0;\n\n\treturn bq24735_update_word(charger->client, BQ24735_CHARGE_OPT,\n\t\t\t\t   BQ24735_CHARGE_OPT_CHG_DISABLE,\n\t\t\t\t   BQ24735_CHARGE_OPT_CHG_DISABLE);\n}\n\nstatic bool bq24735_charger_is_present(struct bq24735 *charger)\n{\n\tif (charger->status_gpio) {\n\t\treturn !gpiod_get_value_cansleep(charger->status_gpio);\n\t} else {\n\t\tint ac = 0;\n\n\t\tac = bq24735_read_word(charger->client, BQ24735_CHARGE_OPT);\n\t\tif (ac < 0) {\n\t\t\tdev_dbg(&charger->client->dev,\n\t\t\t\t\"Failed to read charger options : %d\\n\",\n\t\t\t\tac);\n\t\t\treturn false;\n\t\t}\n\t\treturn (ac & BQ24735_CHARGE_OPT_AC_PRESENT) ? true : false;\n\t}\n\n\treturn false;\n}\n\nstatic int bq24735_charger_is_charging(struct bq24735 *charger)\n{\n\tint ret;\n\n\tif (!bq24735_charger_is_present(charger))\n\t\treturn 0;\n\n\tret  = bq24735_read_word(charger->client, BQ24735_CHARGE_OPT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !(ret & BQ24735_CHARGE_OPT_CHG_DISABLE);\n}\n\nstatic void bq24735_update(struct bq24735 *charger)\n{\n\tmutex_lock(&charger->lock);\n\n\tif (charger->charging && bq24735_charger_is_present(charger))\n\t\tbq24735_enable_charging(charger);\n\telse\n\t\tbq24735_disable_charging(charger);\n\n\tmutex_unlock(&charger->lock);\n\n\tpower_supply_changed(charger->charger);\n}\n\nstatic irqreturn_t bq24735_charger_isr(int irq, void *devid)\n{\n\tstruct power_supply *psy = devid;\n\tstruct bq24735 *charger = to_bq24735(psy);\n\n\tbq24735_update(charger);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bq24735_poll(struct work_struct *work)\n{\n\tstruct bq24735 *charger = container_of(work, struct bq24735, poll.work);\n\n\tbq24735_update(charger);\n\n\tschedule_delayed_work(&charger->poll,\n\t\t\t      msecs_to_jiffies(charger->poll_interval));\n}\n\nstatic int bq24735_charger_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct bq24735 *charger = to_bq24735(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = bq24735_charger_is_present(charger) ? 1 : 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tswitch (bq24735_charger_is_charging(charger)) {\n\t\tcase 1:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24735_charger_set_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24735 *charger = to_bq24735(psy);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tswitch (val->intval) {\n\t\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\t\tmutex_lock(&charger->lock);\n\t\t\tcharger->charging = true;\n\t\t\tret = bq24735_enable_charging(charger);\n\t\t\tmutex_unlock(&charger->lock);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\tcase POWER_SUPPLY_STATUS_NOT_CHARGING:\n\t\t\tmutex_lock(&charger->lock);\n\t\t\tcharger->charging = false;\n\t\t\tret = bq24735_disable_charging(charger);\n\t\t\tmutex_unlock(&charger->lock);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_supply_changed(psy);\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct bq24735_platform *bq24735_parse_dt_data(struct i2c_client *client)\n{\n\tstruct bq24735_platform *pdata;\n\tstruct device_node *np = client->dev.of_node;\n\tu32 val;\n\tint ret;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Memory alloc for bq24735 pdata failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = of_property_read_u32(np, \"ti,charge-current\", &val);\n\tif (!ret)\n\t\tpdata->charge_current = val;\n\n\tret = of_property_read_u32(np, \"ti,charge-voltage\", &val);\n\tif (!ret)\n\t\tpdata->charge_voltage = val;\n\n\tret = of_property_read_u32(np, \"ti,input-current\", &val);\n\tif (!ret)\n\t\tpdata->input_current = val;\n\n\tpdata->ext_control = of_property_read_bool(np, \"ti,external-control\");\n\n\treturn pdata;\n}\n\nstatic int bq24735_charger_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct bq24735 *charger;\n\tstruct power_supply_desc *supply_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tchar *name;\n\n\tcharger = devm_kzalloc(&client->dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&charger->lock);\n\tcharger->charging = true;\n\tcharger->pdata = client->dev.platform_data;\n\n\tif (IS_ENABLED(CONFIG_OF) && !charger->pdata && client->dev.of_node)\n\t\tcharger->pdata = bq24735_parse_dt_data(client);\n\n\tif (!charger->pdata) {\n\t\tdev_err(&client->dev, \"no platform data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tname = (char *)charger->pdata->name;\n\tif (!name) {\n\t\tname = devm_kasprintf(&client->dev, GFP_KERNEL,\n\t\t\t\t      \"bq24735@%s\",\n\t\t\t\t      dev_name(&client->dev));\n\t\tif (!name) {\n\t\t\tdev_err(&client->dev, \"Failed to alloc device name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tcharger->client = client;\n\n\tsupply_desc = &charger->charger_desc;\n\n\tsupply_desc->name = name;\n\tsupply_desc->type = POWER_SUPPLY_TYPE_MAINS;\n\tsupply_desc->properties = bq24735_charger_properties;\n\tsupply_desc->num_properties = ARRAY_SIZE(bq24735_charger_properties);\n\tsupply_desc->get_property = bq24735_charger_get_property;\n\tsupply_desc->set_property = bq24735_charger_set_property;\n\tsupply_desc->property_is_writeable =\n\t\t\t\tbq24735_charger_property_is_writeable;\n\n\tpsy_cfg.supplied_to = charger->pdata->supplied_to;\n\tpsy_cfg.num_supplicants = charger->pdata->num_supplicants;\n\tpsy_cfg.of_node = client->dev.of_node;\n\tpsy_cfg.drv_data = charger;\n\n\ti2c_set_clientdata(client, charger);\n\n\tcharger->status_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t       \"ti,ac-detect\",\n\t\t\t\t\t\t       GPIOD_IN);\n\tif (IS_ERR(charger->status_gpio)) {\n\t\tret = PTR_ERR(charger->status_gpio);\n\t\tdev_err(&client->dev, \"Getting gpio failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (bq24735_charger_is_present(charger)) {\n\t\tret = bq24735_read_word(client, BQ24735_MANUFACTURER_ID);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to read manufacturer id : %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t} else if (ret != 0x0040) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"manufacturer id mismatch. 0x0040 != 0x%04x\\n\", ret);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = bq24735_read_word(client, BQ24735_DEVICE_ID);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to read device id : %d\\n\", ret);\n\t\t\treturn ret;\n\t\t} else if (ret != 0x000B) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"device id mismatch. 0x000b != 0x%04x\\n\", ret);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = bq24735_enable_charging(charger);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to enable charging\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcharger->charger = devm_power_supply_register(&client->dev, supply_desc,\n\t\t\t\t\t\t      &psy_cfg);\n\tif (IS_ERR(charger->charger)) {\n\t\tret = PTR_ERR(charger->charger);\n\t\tdev_err(&client->dev, \"Failed to register power supply: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, bq24735_charger_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tsupply_desc->name,\n\t\t\t\t\t\tcharger->charger);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to register IRQ %d err %d\\n\",\n\t\t\t\tclient->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = device_property_read_u32(&client->dev, \"poll-interval\",\n\t\t\t\t\t       &charger->poll_interval);\n\t\tif (ret)\n\t\t\treturn 0;\n\t\tif (!charger->poll_interval)\n\t\t\treturn 0;\n\n\t\tret = devm_delayed_work_autocancel(&client->dev, &charger->poll,\n\t\t\t\t\t\t   bq24735_poll);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tschedule_delayed_work(&charger->poll,\n\t\t\t\t      msecs_to_jiffies(charger->poll_interval));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id bq24735_charger_id[] = {\n\t{ \"bq24735-charger\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, bq24735_charger_id);\n\nstatic const struct of_device_id bq24735_match_ids[] = {\n\t{ .compatible = \"ti,bq24735\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bq24735_match_ids);\n\nstatic struct i2c_driver bq24735_charger_driver = {\n\t.driver = {\n\t\t.name = \"bq24735-charger\",\n\t\t.of_match_table = bq24735_match_ids,\n\t},\n\t.probe = bq24735_charger_probe,\n\t.id_table = bq24735_charger_id,\n};\n\nmodule_i2c_driver(bq24735_charger_driver);\n\nMODULE_DESCRIPTION(\"bq24735 battery charging driver\");\nMODULE_AUTHOR(\"Darbha Sriharsha <dsriharsha@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}