{
  "module_name": "cros_usbpd-charger.c",
  "hash_id": "6d328e54ca45d151dcc6cbaf583ee29aefb73f85bf27b63f18c40919cf3c58c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/cros_usbpd-charger.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_data/cros_usbpd_notify.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n\n#define CHARGER_USBPD_DIR_NAME\t\t\t\"CROS_USBPD_CHARGER%d\"\n#define CHARGER_DEDICATED_DIR_NAME\t\t\"CROS_DEDICATED_CHARGER\"\n#define CHARGER_DIR_NAME_LENGTH\t\t(sizeof(CHARGER_USBPD_DIR_NAME) >= \\\n\t\t\t\t\t sizeof(CHARGER_DEDICATED_DIR_NAME) ? \\\n\t\t\t\t\t sizeof(CHARGER_USBPD_DIR_NAME) : \\\n\t\t\t\t\t sizeof(CHARGER_DEDICATED_DIR_NAME))\n#define CHARGER_CACHE_UPDATE_DELAY\t\tmsecs_to_jiffies(500)\n#define CHARGER_MANUFACTURER_MODEL_LENGTH\t32\n\n#define DRV_NAME \"cros-usbpd-charger\"\n\nstruct port_data {\n\tint port_number;\n\tchar name[CHARGER_DIR_NAME_LENGTH];\n\tchar manufacturer[CHARGER_MANUFACTURER_MODEL_LENGTH];\n\tchar model_name[CHARGER_MANUFACTURER_MODEL_LENGTH];\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tint psy_usb_type;\n\tint psy_online;\n\tint psy_status;\n\tint psy_current_max;\n\tint psy_voltage_max_design;\n\tint psy_voltage_now;\n\tint psy_power_max;\n\tstruct charger_data *charger;\n\tunsigned long last_update;\n};\n\nstruct charger_data {\n\tstruct device *dev;\n\tstruct cros_ec_dev *ec_dev;\n\tstruct cros_ec_device *ec_device;\n\tint num_charger_ports;\n\tint num_usbpd_ports;\n\tint num_registered_psy;\n\tstruct port_data *ports[EC_USB_PD_MAX_PORTS];\n\tstruct notifier_block notifier;\n};\n\nstatic enum power_supply_property cros_usbpd_charger_props[] = {\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_USB_TYPE\n};\n\nstatic enum power_supply_property cros_usbpd_dedicated_charger_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\nstatic enum power_supply_usb_type cros_usbpd_charger_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_DRP,\n\tPOWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID\n};\n\n \nstatic u16 input_voltage_limit = EC_POWER_LIMIT_NONE;\nstatic u16 input_current_limit = EC_POWER_LIMIT_NONE;\n\nstatic bool cros_usbpd_charger_port_is_dedicated(struct port_data *port)\n{\n\treturn port->port_number >= port->charger->num_usbpd_ports;\n}\n\nstatic int cros_usbpd_charger_ec_command(struct charger_data *charger,\n\t\t\t\t\t unsigned int version,\n\t\t\t\t\t unsigned int command,\n\t\t\t\t\t void *outdata,\n\t\t\t\t\t unsigned int outsize,\n\t\t\t\t\t void *indata,\n\t\t\t\t\t unsigned int insize)\n{\n\tstruct cros_ec_dev *ec_dev = charger->ec_dev;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(struct_size(msg, data, max(outsize, insize)), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = version;\n\tmsg->command = ec_dev->cmd_offset + command;\n\tmsg->outsize = outsize;\n\tmsg->insize = insize;\n\n\tif (outsize)\n\t\tmemcpy(msg->data, outdata, outsize);\n\n\tret = cros_ec_cmd_xfer_status(charger->ec_device, msg);\n\tif (ret >= 0 && insize)\n\t\tmemcpy(indata, msg->data, insize);\n\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int cros_usbpd_charger_get_num_ports(struct charger_data *charger)\n{\n\tstruct ec_response_charge_port_count resp;\n\tint ret;\n\n\tret = cros_usbpd_charger_ec_command(charger, 0,\n\t\t\t\t\t    EC_CMD_CHARGE_PORT_COUNT,\n\t\t\t\t\t    NULL, 0, &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp.port_count;\n}\n\nstatic int cros_usbpd_charger_get_usbpd_num_ports(struct charger_data *charger)\n{\n\tstruct ec_response_usb_pd_ports resp;\n\tint ret;\n\n\tret = cros_usbpd_charger_ec_command(charger, 0, EC_CMD_USB_PD_PORTS,\n\t\t\t\t\t    NULL, 0, &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp.num_ports;\n}\n\nstatic int cros_usbpd_charger_get_discovery_info(struct port_data *port)\n{\n\tstruct charger_data *charger = port->charger;\n\tstruct ec_params_usb_pd_discovery_entry resp;\n\tstruct ec_params_usb_pd_info_request req;\n\tint ret;\n\n\treq.port = port->port_number;\n\n\tret = cros_usbpd_charger_ec_command(charger, 0,\n\t\t\t\t\t    EC_CMD_USB_PD_DISCOVERY,\n\t\t\t\t\t    &req, sizeof(req),\n\t\t\t\t\t    &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_err(charger->dev,\n\t\t\t\"Unable to query discovery info (err:0x%x)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(charger->dev, \"Port %d: VID = 0x%x, PID=0x%x, PTYPE=0x%x\\n\",\n\t\tport->port_number, resp.vid, resp.pid, resp.ptype);\n\n\tsnprintf(port->manufacturer, sizeof(port->manufacturer), \"%x\",\n\t\t resp.vid);\n\tsnprintf(port->model_name, sizeof(port->model_name), \"%x\", resp.pid);\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_charger_get_power_info(struct port_data *port)\n{\n\tstruct charger_data *charger = port->charger;\n\tstruct ec_response_usb_pd_power_info resp;\n\tstruct ec_params_usb_pd_power_info req;\n\tint last_psy_status, last_psy_usb_type;\n\tstruct device *dev = charger->dev;\n\tint ret;\n\n\treq.port = port->port_number;\n\tret = cros_usbpd_charger_ec_command(charger, 0,\n\t\t\t\t\t    EC_CMD_USB_PD_POWER_INFO,\n\t\t\t\t\t    &req, sizeof(req),\n\t\t\t\t\t    &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to query PD power info (err:0x%x)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlast_psy_status = port->psy_status;\n\tlast_psy_usb_type = port->psy_usb_type;\n\n\tswitch (resp.role) {\n\tcase USB_PD_PORT_POWER_DISCONNECTED:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tport->psy_online = 0;\n\t\tbreak;\n\tcase USB_PD_PORT_POWER_SOURCE:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tport->psy_online = 0;\n\t\tbreak;\n\tcase USB_PD_PORT_POWER_SINK:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tport->psy_online = 1;\n\t\tbreak;\n\tcase USB_PD_PORT_POWER_SINK_NOT_CHARGING:\n\t\tport->psy_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tport->psy_online = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown role %d\\n\", resp.role);\n\t\tbreak;\n\t}\n\n\tport->psy_voltage_max_design = resp.meas.voltage_max;\n\tport->psy_voltage_now = resp.meas.voltage_now;\n\tport->psy_current_max = resp.meas.current_max;\n\tport->psy_power_max = resp.max_power;\n\n\tswitch (resp.type) {\n\tcase USB_CHG_TYPE_BC12_SDP:\n\tcase USB_CHG_TYPE_VBUS:\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase USB_CHG_TYPE_NONE:\n\t\t \n\t\tif (resp.role == USB_PD_PORT_POWER_SOURCE && resp.dualrole)\n\t\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_PD_DRP;\n\t\telse\n\t\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase USB_CHG_TYPE_OTHER:\n\tcase USB_CHG_TYPE_PROPRIETARY:\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID;\n\t\tbreak;\n\tcase USB_CHG_TYPE_C:\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_C;\n\t\tbreak;\n\tcase USB_CHG_TYPE_BC12_DCP:\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase USB_CHG_TYPE_BC12_CDP:\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tbreak;\n\tcase USB_CHG_TYPE_PD:\n\t\tif (resp.dualrole)\n\t\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_PD_DRP;\n\t\telse\n\t\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_PD;\n\t\tbreak;\n\tcase USB_CHG_TYPE_UNKNOWN:\n\t\t \n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tport->psy_voltage_max_design = 0;\n\t\tport->psy_current_max = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Port %d: default case!\\n\", port->port_number);\n\t\tport->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t}\n\n\tif (cros_usbpd_charger_port_is_dedicated(port))\n\t\tport->psy_desc.type = POWER_SUPPLY_TYPE_MAINS;\n\telse\n\t\tport->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\n\tdev_dbg(dev,\n\t\t\"Port %d: type=%d vmax=%d vnow=%d cmax=%d clim=%d pmax=%d\\n\",\n\t\tport->port_number, resp.type, resp.meas.voltage_max,\n\t\tresp.meas.voltage_now, resp.meas.current_max,\n\t\tresp.meas.current_lim, resp.max_power);\n\n\t \n\tif (last_psy_usb_type != port->psy_usb_type ||\n\t    last_psy_status != port->psy_status)\n\t\tpower_supply_changed(port->psy);\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_charger_get_port_status(struct port_data *port,\n\t\t\t\t\t      bool ratelimit)\n{\n\tint ret;\n\n\tif (ratelimit &&\n\t    time_is_after_jiffies(port->last_update +\n\t\t\t\t  CHARGER_CACHE_UPDATE_DELAY))\n\t\treturn 0;\n\n\tret = cros_usbpd_charger_get_power_info(port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!cros_usbpd_charger_port_is_dedicated(port))\n\t\tret = cros_usbpd_charger_get_discovery_info(port);\n\tport->last_update = jiffies;\n\n\treturn ret;\n}\n\nstatic int cros_usbpd_charger_set_ext_power_limit(struct charger_data *charger,\n\t\t\t\t\t\t  u16 current_lim,\n\t\t\t\t\t\t  u16 voltage_lim)\n{\n\tstruct ec_params_external_power_limit_v1 req;\n\tint ret;\n\n\treq.current_lim = current_lim;\n\treq.voltage_lim = voltage_lim;\n\n\tret = cros_usbpd_charger_ec_command(charger, 0,\n\t\t\t\t\t    EC_CMD_EXTERNAL_POWER_LIMIT,\n\t\t\t\t\t    &req, sizeof(req), NULL, 0);\n\tif (ret < 0)\n\t\tdev_err(charger->dev,\n\t\t\t\"Unable to set the 'External Power Limit': %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void cros_usbpd_charger_power_changed(struct power_supply *psy)\n{\n\tstruct port_data *port = power_supply_get_drvdata(psy);\n\tstruct charger_data *charger = port->charger;\n\tint i;\n\n\tfor (i = 0; i < charger->num_registered_psy; i++)\n\t\tcros_usbpd_charger_get_port_status(charger->ports[i], false);\n}\n\nstatic int cros_usbpd_charger_get_prop(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct port_data *port = power_supply_get_drvdata(psy);\n\tstruct charger_data *charger = port->charger;\n\tstruct cros_ec_device *ec_device = charger->ec_device;\n\tstruct device *dev = charger->dev;\n\tint ret;\n\n\t \n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\t \n\t\tif (ec_device->mkbp_event_supported || port->psy_online)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = cros_usbpd_charger_get_port_status(port, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to get port status (err:0x%x)\\n\",\n\t\t\t\tret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = port->psy_online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = port->psy_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = port->psy_current_max * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = port->psy_voltage_max_design * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = port->psy_voltage_now * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = port->psy_usb_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (input_current_limit == EC_POWER_LIMIT_NONE)\n\t\t\tval->intval = -1;\n\t\telse\n\t\t\tval->intval = input_current_limit * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tif (input_voltage_limit == EC_POWER_LIMIT_NONE)\n\t\t\tval->intval = -1;\n\t\telse\n\t\t\tval->intval = input_voltage_limit * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = port->model_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = port->manufacturer;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_charger_set_prop(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct port_data *port = power_supply_get_drvdata(psy);\n\tstruct charger_data *charger = port->charger;\n\tstruct device *dev = charger->dev;\n\tu16 intval;\n\tint ret;\n\n\t \n\tif (val->intval >= U16_MAX * 1000)\n\t\treturn -EINVAL;\n\t \n\tif (val->intval < 0)\n\t\tintval = EC_POWER_LIMIT_NONE;\n\telse\t \n\t\tintval = val->intval / 1000;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = cros_usbpd_charger_set_ext_power_limit(charger, intval,\n\t\t\t\t\t\t\tinput_voltage_limit);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tinput_current_limit = intval;\n\t\tif (input_current_limit == EC_POWER_LIMIT_NONE)\n\t\t\tdev_info(dev,\n\t\t\t  \"External Current Limit cleared for all ports\\n\");\n\t\telse\n\t\t\tdev_info(dev,\n\t\t\t  \"External Current Limit set to %dmA for all ports\\n\",\n\t\t\t  input_current_limit);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = cros_usbpd_charger_set_ext_power_limit(charger,\n\t\t\t\t\t\t\tinput_current_limit,\n\t\t\t\t\t\t\tintval);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tinput_voltage_limit = intval;\n\t\tif (input_voltage_limit == EC_POWER_LIMIT_NONE)\n\t\t\tdev_info(dev,\n\t\t\t  \"External Voltage Limit cleared for all ports\\n\");\n\t\telse\n\t\t\tdev_info(dev,\n\t\t\t  \"External Voltage Limit set to %dmV for all ports\\n\",\n\t\t\t  input_voltage_limit);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cros_usbpd_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int cros_usbpd_charger_ec_event(struct notifier_block *nb,\n\t\t\t\t       unsigned long host_event,\n\t\t\t\t       void *_notify)\n{\n\tstruct charger_data *charger = container_of(nb, struct charger_data,\n\t\t\t\t\t\t    notifier);\n\n\tcros_usbpd_charger_power_changed(charger->ports[0]->psy);\n\treturn NOTIFY_OK;\n}\n\nstatic void cros_usbpd_charger_unregister_notifier(void *data)\n{\n\tstruct charger_data *charger = data;\n\n\tcros_usbpd_unregister_notify(&charger->notifier);\n}\n\nstatic int cros_usbpd_charger_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\tstruct cros_ec_device *ec_device = ec_dev->ec_dev;\n\tstruct power_supply_desc *psy_desc;\n\tstruct device *dev = &pd->dev;\n\tstruct charger_data *charger;\n\tstruct power_supply *psy;\n\tstruct port_data *port;\n\tint ret = -EINVAL;\n\tint i;\n\n\tcharger = devm_kzalloc(dev, sizeof(struct charger_data),\n\t\t\t       GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tcharger->dev = dev;\n\tcharger->ec_dev = ec_dev;\n\tcharger->ec_device = ec_device;\n\n\tplatform_set_drvdata(pd, charger);\n\n\t \n\tcharger->num_usbpd_ports =\n\t\tcros_usbpd_charger_get_usbpd_num_ports(charger);\n\tif (charger->num_usbpd_ports <= 0) {\n\t\t \n\t\tdev_info(dev, \"No USB PD charging ports found\\n\");\n\t}\n\n\tcharger->num_charger_ports = cros_usbpd_charger_get_num_ports(charger);\n\tif (charger->num_charger_ports < 0) {\n\t\t \n\t\tdev_info(dev, \"Could not get charger port count\\n\");\n\t\tcharger->num_charger_ports = charger->num_usbpd_ports;\n\t}\n\n\tif (charger->num_charger_ports <= 0) {\n\t\t \n\t\tdev_info(dev, \"No charging ports found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail_nowarn;\n\t}\n\n\t \n\tif (charger->num_charger_ports < charger->num_usbpd_ports ||\n\t    charger->num_charger_ports > (charger->num_usbpd_ports + 1)) {\n\t\tdev_err(dev, \"Unexpected number of charge port count\\n\");\n\t\tret = -EPROTO;\n\t\tgoto fail_nowarn;\n\t}\n\n\tfor (i = 0; i < charger->num_charger_ports; i++) {\n\t\tstruct power_supply_config psy_cfg = {};\n\n\t\tport = devm_kzalloc(dev, sizeof(struct port_data), GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tport->charger = charger;\n\t\tport->port_number = i;\n\n\t\tpsy_desc = &port->psy_desc;\n\t\tpsy_desc->get_property = cros_usbpd_charger_get_prop;\n\t\tpsy_desc->set_property = cros_usbpd_charger_set_prop;\n\t\tpsy_desc->property_is_writeable =\n\t\t\t\tcros_usbpd_charger_property_is_writeable;\n\t\tpsy_desc->external_power_changed =\n\t\t\t\t\tcros_usbpd_charger_power_changed;\n\t\tpsy_cfg.drv_data = port;\n\n\t\tif (cros_usbpd_charger_port_is_dedicated(port)) {\n\t\t\tsprintf(port->name, CHARGER_DEDICATED_DIR_NAME);\n\t\t\tpsy_desc->type = POWER_SUPPLY_TYPE_MAINS;\n\t\t\tpsy_desc->properties =\n\t\t\t\tcros_usbpd_dedicated_charger_props;\n\t\t\tpsy_desc->num_properties =\n\t\t\t\tARRAY_SIZE(cros_usbpd_dedicated_charger_props);\n\t\t} else {\n\t\t\tsprintf(port->name, CHARGER_USBPD_DIR_NAME, i);\n\t\t\tpsy_desc->type = POWER_SUPPLY_TYPE_USB;\n\t\t\tpsy_desc->properties = cros_usbpd_charger_props;\n\t\t\tpsy_desc->num_properties =\n\t\t\t\tARRAY_SIZE(cros_usbpd_charger_props);\n\t\t\tpsy_desc->usb_types = cros_usbpd_charger_usb_types;\n\t\t\tpsy_desc->num_usb_types =\n\t\t\t\tARRAY_SIZE(cros_usbpd_charger_usb_types);\n\t\t}\n\n\t\tpsy_desc->name = port->name;\n\n\t\tpsy = devm_power_supply_register_no_ws(dev, psy_desc,\n\t\t\t\t\t\t       &psy_cfg);\n\t\tif (IS_ERR(psy)) {\n\t\t\tdev_err(dev, \"Failed to register power supply\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tport->psy = psy;\n\n\t\tcharger->ports[charger->num_registered_psy++] = port;\n\t}\n\n\tif (!charger->num_registered_psy) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"No power supplies registered\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tcharger->notifier.notifier_call = cros_usbpd_charger_ec_event;\n\tret = cros_usbpd_register_notify(&charger->notifier);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"failed to register notifier\\n\");\n\t} else {\n\t\tret = devm_add_action_or_reset(dev,\n\t\t\t\tcros_usbpd_charger_unregister_notifier,\n\t\t\t\tcharger);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tWARN(1, \"%s: Failing probe (err:0x%x)\\n\", dev_name(dev), ret);\n\nfail_nowarn:\n\tdev_info(dev, \"Failing probe (err:0x%x)\\n\", ret);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_usbpd_charger_resume(struct device *dev)\n{\n\tstruct charger_data *charger = dev_get_drvdata(dev);\n\tint i;\n\n\tif (!charger)\n\t\treturn 0;\n\n\tfor (i = 0; i < charger->num_registered_psy; i++) {\n\t\tpower_supply_changed(charger->ports[i]->psy);\n\t\tcharger->ports[i]->last_update =\n\t\t\t\tjiffies - CHARGER_CACHE_UPDATE_DELAY;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_usbpd_charger_pm_ops, NULL,\n\t\t\t cros_usbpd_charger_resume);\n\nstatic struct platform_driver cros_usbpd_charger_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_usbpd_charger_pm_ops,\n\t},\n\t.probe = cros_usbpd_charger_probe\n};\n\nmodule_platform_driver(cros_usbpd_charger_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS EC USBPD charger\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}