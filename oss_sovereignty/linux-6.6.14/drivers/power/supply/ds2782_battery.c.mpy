{
  "module_name": "ds2782_battery.c",
  "hash_id": "35bc857496e799f0d239301aa4862f3ed715fc3ddaba529bc14f04a49c3348a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ds2782_battery.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/swab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/idr.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/ds2782_battery.h>\n\n#define DS2782_REG_RARC\t\t0x06\t \n\n#define DS278x_REG_VOLT_MSB\t0x0c\n#define DS278x_REG_TEMP_MSB\t0x0a\n#define DS278x_REG_CURRENT_MSB\t0x0e\n\n \n#define DS2782_REG_RSNSP\t0x69\t \n\n \n#define DS2782_CURRENT_UNITS\t1563\n\n#define DS2786_REG_RARC\t\t0x02\t \n\n#define DS2786_CURRENT_UNITS\t25\n\n#define DS278x_DELAY\t\t1000\n\nstruct ds278x_info;\n\nstruct ds278x_battery_ops {\n\tint (*get_battery_current)(struct ds278x_info *info, int *current_uA);\n\tint (*get_battery_voltage)(struct ds278x_info *info, int *voltage_uV);\n\tint (*get_battery_capacity)(struct ds278x_info *info, int *capacity);\n};\n\n#define to_ds278x_info(x) power_supply_get_drvdata(x)\n\nstruct ds278x_info {\n\tstruct i2c_client\t*client;\n\tstruct power_supply\t*battery;\n\tstruct power_supply_desc\tbattery_desc;\n\tconst struct ds278x_battery_ops *ops;\n\tstruct delayed_work\tbat_work;\n\tint\t\t\tid;\n\tint                     rsns;\n\tint\t\t\tcapacity;\n\tint\t\t\tstatus;\t\t \n};\n\nstatic DEFINE_IDR(battery_id);\nstatic DEFINE_MUTEX(battery_lock);\n\nstatic inline int ds278x_read_reg(struct ds278x_info *info, int reg, u8 *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(info->client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&info->client->dev, \"register read failed\\n\");\n\t\treturn ret;\n\t}\n\n\t*val = ret;\n\treturn 0;\n}\n\nstatic inline int ds278x_read_reg16(struct ds278x_info *info, int reg_msb,\n\t\t\t\t    s16 *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(info->client, reg_msb);\n\tif (ret < 0) {\n\t\tdev_err(&info->client->dev, \"register read failed\\n\");\n\t\treturn ret;\n\t}\n\n\t*val = swab16(ret);\n\treturn 0;\n}\n\nstatic int ds278x_get_temp(struct ds278x_info *info, int *temp)\n{\n\ts16 raw;\n\tint err;\n\n\t \n\terr = ds278x_read_reg16(info, DS278x_REG_TEMP_MSB, &raw);\n\tif (err)\n\t\treturn err;\n\t*temp = ((raw / 32) * 125) / 100;\n\treturn 0;\n}\n\nstatic int ds2782_get_current(struct ds278x_info *info, int *current_uA)\n{\n\tint sense_res;\n\tint err;\n\tu8 sense_res_raw;\n\ts16 raw;\n\n\t \n\terr = ds278x_read_reg(info, DS2782_REG_RSNSP, &sense_res_raw);\n\tif (err)\n\t\treturn err;\n\tif (sense_res_raw == 0) {\n\t\tdev_err(&info->client->dev, \"sense resistor value is 0\\n\");\n\t\treturn -ENXIO;\n\t}\n\tsense_res = 1000 / sense_res_raw;\n\n\tdev_dbg(&info->client->dev, \"sense resistor = %d milli-ohms\\n\",\n\t\tsense_res);\n\terr = ds278x_read_reg16(info, DS278x_REG_CURRENT_MSB, &raw);\n\tif (err)\n\t\treturn err;\n\t*current_uA = raw * (DS2782_CURRENT_UNITS / sense_res);\n\treturn 0;\n}\n\nstatic int ds2782_get_voltage(struct ds278x_info *info, int *voltage_uV)\n{\n\ts16 raw;\n\tint err;\n\n\t \n\terr = ds278x_read_reg16(info, DS278x_REG_VOLT_MSB, &raw);\n\tif (err)\n\t\treturn err;\n\t*voltage_uV = (raw / 32) * 4800;\n\treturn 0;\n}\n\nstatic int ds2782_get_capacity(struct ds278x_info *info, int *capacity)\n{\n\tint err;\n\tu8 raw;\n\n\terr = ds278x_read_reg(info, DS2782_REG_RARC, &raw);\n\tif (err)\n\t\treturn err;\n\t*capacity = raw;\n\treturn 0;\n}\n\nstatic int ds2786_get_current(struct ds278x_info *info, int *current_uA)\n{\n\tint err;\n\ts16 raw;\n\n\terr = ds278x_read_reg16(info, DS278x_REG_CURRENT_MSB, &raw);\n\tif (err)\n\t\treturn err;\n\t*current_uA = (raw / 16) * (DS2786_CURRENT_UNITS / info->rsns);\n\treturn 0;\n}\n\nstatic int ds2786_get_voltage(struct ds278x_info *info, int *voltage_uV)\n{\n\ts16 raw;\n\tint err;\n\n\t \n\terr = ds278x_read_reg16(info, DS278x_REG_VOLT_MSB, &raw);\n\tif (err)\n\t\treturn err;\n\t*voltage_uV = (raw / 8) * 1220;\n\treturn 0;\n}\n\nstatic int ds2786_get_capacity(struct ds278x_info *info, int *capacity)\n{\n\tint err;\n\tu8 raw;\n\n\terr = ds278x_read_reg(info, DS2786_REG_RARC, &raw);\n\tif (err)\n\t\treturn err;\n\t \n\t*capacity = raw/2 ;\n\treturn 0;\n}\n\nstatic int ds278x_get_status(struct ds278x_info *info, int *status)\n{\n\tint err;\n\tint current_uA;\n\tint capacity;\n\n\terr = info->ops->get_battery_current(info, &current_uA);\n\tif (err)\n\t\treturn err;\n\n\terr = info->ops->get_battery_capacity(info, &capacity);\n\tif (err)\n\t\treturn err;\n\n\tinfo->capacity = capacity;\n\n\tif (capacity == 100)\n\t\t*status = POWER_SUPPLY_STATUS_FULL;\n\telse if (current_uA == 0)\n\t\t*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\telse if (current_uA < 0)\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\telse\n\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\n\treturn 0;\n}\n\nstatic int ds278x_battery_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property prop,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct ds278x_info *info = to_ds278x_info(psy);\n\tint ret;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = ds278x_get_status(info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = info->ops->get_battery_capacity(info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = info->ops->get_battery_voltage(info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = info->ops->get_battery_current(info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = ds278x_get_temp(info, &val->intval);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void ds278x_bat_update(struct ds278x_info *info)\n{\n\tint old_status = info->status;\n\tint old_capacity = info->capacity;\n\n\tds278x_get_status(info, &info->status);\n\n\tif ((old_status != info->status) || (old_capacity != info->capacity))\n\t\tpower_supply_changed(info->battery);\n}\n\nstatic void ds278x_bat_work(struct work_struct *work)\n{\n\tstruct ds278x_info *info;\n\n\tinfo = container_of(work, struct ds278x_info, bat_work.work);\n\tds278x_bat_update(info);\n\n\tschedule_delayed_work(&info->bat_work, DS278x_DELAY);\n}\n\nstatic enum power_supply_property ds278x_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic void ds278x_power_supply_init(struct power_supply_desc *battery)\n{\n\tbattery->type\t\t\t= POWER_SUPPLY_TYPE_BATTERY;\n\tbattery->properties\t\t= ds278x_battery_props;\n\tbattery->num_properties\t\t= ARRAY_SIZE(ds278x_battery_props);\n\tbattery->get_property\t\t= ds278x_battery_get_property;\n\tbattery->external_power_changed\t= NULL;\n}\n\nstatic void ds278x_battery_remove(struct i2c_client *client)\n{\n\tstruct ds278x_info *info = i2c_get_clientdata(client);\n\tint id = info->id;\n\n\tpower_supply_unregister(info->battery);\n\tcancel_delayed_work_sync(&info->bat_work);\n\tkfree(info->battery_desc.name);\n\tkfree(info);\n\n\tmutex_lock(&battery_lock);\n\tidr_remove(&battery_id, id);\n\tmutex_unlock(&battery_lock);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int ds278x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ds278x_info *info = i2c_get_clientdata(client);\n\n\tcancel_delayed_work(&info->bat_work);\n\treturn 0;\n}\n\nstatic int ds278x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ds278x_info *info = i2c_get_clientdata(client);\n\n\tschedule_delayed_work(&info->bat_work, DS278x_DELAY);\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(ds278x_battery_pm_ops, ds278x_suspend, ds278x_resume);\n\nenum ds278x_num_id {\n\tDS2782 = 0,\n\tDS2786,\n};\n\nstatic const struct ds278x_battery_ops ds278x_ops[] = {\n\t[DS2782] = {\n\t\t.get_battery_current  = ds2782_get_current,\n\t\t.get_battery_voltage  = ds2782_get_voltage,\n\t\t.get_battery_capacity = ds2782_get_capacity,\n\t},\n\t[DS2786] = {\n\t\t.get_battery_current  = ds2786_get_current,\n\t\t.get_battery_voltage  = ds2786_get_voltage,\n\t\t.get_battery_capacity = ds2786_get_capacity,\n\t}\n};\n\nstatic int ds278x_battery_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct ds278x_platform_data *pdata = client->dev.platform_data;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ds278x_info *info;\n\tint ret;\n\tint num;\n\n\t \n\tif (id->driver_data == DS2786 && !pdata) {\n\t\tdev_err(&client->dev, \"missing platform data for ds2786\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&battery_lock);\n\tret = idr_alloc(&battery_id, client, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&battery_lock);\n\tif (ret < 0)\n\t\tgoto fail_id;\n\tnum = ret;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_info;\n\t}\n\n\tinfo->battery_desc.name = kasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t\t\t    client->name, num);\n\tif (!info->battery_desc.name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_name;\n\t}\n\n\tif (id->driver_data == DS2786)\n\t\tinfo->rsns = pdata->rsns;\n\n\ti2c_set_clientdata(client, info);\n\tinfo->client = client;\n\tinfo->id = num;\n\tinfo->ops  = &ds278x_ops[id->driver_data];\n\tds278x_power_supply_init(&info->battery_desc);\n\tpsy_cfg.drv_data = info;\n\n\tinfo->capacity = 100;\n\tinfo->status = POWER_SUPPLY_STATUS_FULL;\n\n\tINIT_DELAYED_WORK(&info->bat_work, ds278x_bat_work);\n\n\tinfo->battery = power_supply_register(&client->dev,\n\t\t\t\t\t      &info->battery_desc, &psy_cfg);\n\tif (IS_ERR(info->battery)) {\n\t\tdev_err(&client->dev, \"failed to register battery\\n\");\n\t\tret = PTR_ERR(info->battery);\n\t\tgoto fail_register;\n\t} else {\n\t\tschedule_delayed_work(&info->bat_work, DS278x_DELAY);\n\t}\n\n\treturn 0;\n\nfail_register:\n\tkfree(info->battery_desc.name);\nfail_name:\n\tkfree(info);\nfail_info:\n\tmutex_lock(&battery_lock);\n\tidr_remove(&battery_id, num);\n\tmutex_unlock(&battery_lock);\nfail_id:\n\treturn ret;\n}\n\nstatic const struct i2c_device_id ds278x_id[] = {\n\t{\"ds2782\", DS2782},\n\t{\"ds2786\", DS2786},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ds278x_id);\n\nstatic struct i2c_driver ds278x_battery_driver = {\n\t.driver \t= {\n\t\t.name\t= \"ds2782-battery\",\n\t\t.pm\t= &ds278x_battery_pm_ops,\n\t},\n\t.probe\t\t= ds278x_battery_probe,\n\t.remove\t\t= ds278x_battery_remove,\n\t.id_table\t= ds278x_id,\n};\nmodule_i2c_driver(ds278x_battery_driver);\n\nMODULE_AUTHOR(\"Ryan Mallon\");\nMODULE_DESCRIPTION(\"Maxim/Dallas DS2782 Stand-Alone Fuel Gauge IC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}