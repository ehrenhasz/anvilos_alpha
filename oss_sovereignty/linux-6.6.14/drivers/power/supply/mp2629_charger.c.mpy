{
  "module_name": "mp2629_charger.c",
  "hash_id": "138bb6b3619ccd09c2e851ba106d558bca79e318d3f8874b96388a4c4b415b45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/mp2629_charger.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/mp2629.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n\n#define MP2629_REG_INPUT_ILIM\t\t0x00\n#define MP2629_REG_INPUT_VLIM\t\t0x01\n#define MP2629_REG_CHARGE_CTRL\t\t0x04\n#define MP2629_REG_CHARGE_ILIM\t\t0x05\n#define MP2629_REG_PRECHARGE\t\t0x06\n#define MP2629_REG_TERM_CURRENT\t\t0x06\n#define MP2629_REG_CHARGE_VLIM\t\t0x07\n#define MP2629_REG_TIMER_CTRL\t\t0x08\n#define MP2629_REG_IMPEDANCE_COMP\t0x09\n#define MP2629_REG_INTERRUPT\t\t0x0b\n#define MP2629_REG_STATUS\t\t0x0c\n#define MP2629_REG_FAULT\t\t0x0d\n\n#define MP2629_MASK_INPUT_TYPE\t\tGENMASK(7, 5)\n#define MP2629_MASK_CHARGE_TYPE\t\tGENMASK(4, 3)\n#define MP2629_MASK_CHARGE_CTRL\t\tGENMASK(5, 4)\n#define MP2629_MASK_WDOG_CTRL\t\tGENMASK(5, 4)\n#define MP2629_MASK_IMPEDANCE\t\tGENMASK(7, 4)\n\n#define MP2629_INPUTSOURCE_CHANGE\tGENMASK(7, 5)\n#define MP2629_CHARGING_CHANGE\t\tGENMASK(4, 3)\n#define MP2629_FAULT_BATTERY\t\tBIT(3)\n#define MP2629_FAULT_THERMAL\t\tBIT(4)\n#define MP2629_FAULT_INPUT\t\tBIT(5)\n#define MP2629_FAULT_OTG\t\tBIT(6)\n\n#define MP2629_MAX_BATT_CAPACITY\t100\n\n#define MP2629_PROPS(_idx, _min, _max, _step)\t\t\\\n\t[_idx] = {\t\t\t\t\t\\\n\t\t.min\t= _min,\t\t\t\t\\\n\t\t.max\t= _max,\t\t\t\t\\\n\t\t.step\t= _step,\t\t\t\\\n}\n\nenum mp2629_source_type {\n\tMP2629_SOURCE_TYPE_NO_INPUT,\n\tMP2629_SOURCE_TYPE_NON_STD,\n\tMP2629_SOURCE_TYPE_SDP,\n\tMP2629_SOURCE_TYPE_CDP,\n\tMP2629_SOURCE_TYPE_DCP,\n\tMP2629_SOURCE_TYPE_OTG = 7,\n};\n\nenum mp2629_field {\n\tINPUT_ILIM,\n\tINPUT_VLIM,\n\tCHARGE_ILIM,\n\tCHARGE_VLIM,\n\tPRECHARGE,\n\tTERM_CURRENT,\n\tMP2629_MAX_FIELD\n};\n\nstruct mp2629_charger {\n\tstruct device *dev;\n\tint status;\n\tint fault;\n\n\tstruct regmap *regmap;\n\tstruct regmap_field *regmap_fields[MP2629_MAX_FIELD];\n\tstruct mutex lock;\n\tstruct power_supply *usb;\n\tstruct power_supply *battery;\n\tstruct iio_channel *iiochan[MP2629_ADC_CHAN_END];\n};\n\nstruct mp2629_prop {\n\tint reg;\n\tint mask;\n\tint min;\n\tint max;\n\tint step;\n\tint shift;\n};\n\nstatic enum power_supply_usb_type mp2629_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_PD_DRP,\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN\n};\n\nstatic enum power_supply_property mp2629_charger_usb_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n};\n\nstatic enum power_supply_property mp2629_charger_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n};\n\nstatic struct mp2629_prop props[] = {\n\tMP2629_PROPS(INPUT_ILIM, 100000, 3250000, 50000),\n\tMP2629_PROPS(INPUT_VLIM, 3800000, 5300000, 100000),\n\tMP2629_PROPS(CHARGE_ILIM, 320000, 4520000, 40000),\n\tMP2629_PROPS(CHARGE_VLIM, 3400000, 4670000, 10000),\n\tMP2629_PROPS(PRECHARGE, 120000, 720000, 40000),\n\tMP2629_PROPS(TERM_CURRENT, 80000, 680000, 40000),\n};\n\nstatic const struct reg_field mp2629_reg_fields[] = {\n\t[INPUT_ILIM]\t= REG_FIELD(MP2629_REG_INPUT_ILIM, 0, 5),\n\t[INPUT_VLIM]\t= REG_FIELD(MP2629_REG_INPUT_VLIM, 0, 3),\n\t[CHARGE_ILIM]\t= REG_FIELD(MP2629_REG_CHARGE_ILIM, 0, 6),\n\t[CHARGE_VLIM]\t= REG_FIELD(MP2629_REG_CHARGE_VLIM, 1, 7),\n\t[PRECHARGE]\t= REG_FIELD(MP2629_REG_PRECHARGE, 4, 7),\n\t[TERM_CURRENT]\t= REG_FIELD(MP2629_REG_TERM_CURRENT, 0, 3),\n};\n\nstatic char *adc_chan_name[] = {\n\t\"mp2629-batt-volt\",\n\t\"mp2629-system-volt\",\n\t\"mp2629-input-volt\",\n\t\"mp2629-batt-current\",\n\t\"mp2629-input-current\",\n};\n\nstatic int mp2629_read_adc(struct mp2629_charger *charger,\n\t\t\t   enum mp2629_adc_chan ch,\n\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tint chval;\n\n\tret = iio_read_channel_processed(charger->iiochan[ch], &chval);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = chval * 1000;\n\n\treturn 0;\n}\n\nstatic int mp2629_get_prop(struct mp2629_charger *charger,\n\t\t\t   enum mp2629_field fld,\n\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\tunsigned int rval;\n\n\tret = regmap_field_read(charger->regmap_fields[fld], &rval);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = rval * props[fld].step + props[fld].min;\n\n\treturn 0;\n}\n\nstatic int mp2629_set_prop(struct mp2629_charger *charger,\n\t\t\t   enum mp2629_field fld,\n\t\t\t   const union power_supply_propval *val)\n{\n\tunsigned int rval;\n\n\tif (val->intval < props[fld].min || val->intval > props[fld].max)\n\t\treturn -EINVAL;\n\n\trval = (val->intval - props[fld].min) / props[fld].step;\n\treturn regmap_field_write(charger->regmap_fields[fld], rval);\n}\n\nstatic int mp2629_get_battery_capacity(struct mp2629_charger *charger,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tunion power_supply_propval vnow, vlim;\n\tint ret;\n\n\tret = mp2629_read_adc(charger, MP2629_BATT_VOLT, &vnow);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mp2629_get_prop(charger, CHARGE_VLIM, &vlim);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = (vnow.intval * 100) / vlim.intval;\n\tval->intval = min(val->intval, MP2629_MAX_BATT_CAPACITY);\n\n\treturn 0;\n}\n\nstatic int mp2629_charger_battery_get_prop(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(psy->dev.parent);\n\tunsigned int rval;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = mp2629_read_adc(charger, MP2629_BATT_VOLT, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = mp2629_read_adc(charger, MP2629_BATT_CURRENT, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = 4520000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = 4670000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = mp2629_get_battery_capacity(charger, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = mp2629_get_prop(charger, TERM_CURRENT, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tret = mp2629_get_prop(charger, PRECHARGE, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = mp2629_get_prop(charger, CHARGE_VLIM, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = mp2629_get_prop(charger, CHARGE_ILIM, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (!charger->fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tif (MP2629_FAULT_BATTERY & charger->fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\telse if (MP2629_FAULT_THERMAL & charger->fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (MP2629_FAULT_INPUT & charger->fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = regmap_read(charger->regmap, MP2629_REG_STATUS, &rval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\trval = (rval & MP2629_MASK_CHARGE_TYPE) >> 3;\n\t\tswitch (rval) {\n\t\tcase 0x00:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\tcase 0x10:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 0x11:\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = regmap_read(charger->regmap, MP2629_REG_STATUS, &rval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\trval = (rval & MP2629_MASK_CHARGE_TYPE) >> 3;\n\t\tswitch (rval) {\n\t\tcase 0x00:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mp2629_charger_battery_set_prop(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn mp2629_set_prop(charger, TERM_CURRENT, val);\n\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn mp2629_set_prop(charger, PRECHARGE, val);\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn mp2629_set_prop(charger, CHARGE_VLIM, val);\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn mp2629_set_prop(charger, CHARGE_ILIM, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mp2629_charger_usb_get_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(psy->dev.parent);\n\tunsigned int rval;\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = regmap_read(charger->regmap, MP2629_REG_STATUS, &rval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tval->intval = !!(rval & MP2629_MASK_INPUT_TYPE);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tret = regmap_read(charger->regmap, MP2629_REG_STATUS, &rval);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\trval = (rval & MP2629_MASK_INPUT_TYPE) >> 5;\n\t\tswitch (rval) {\n\t\tcase MP2629_SOURCE_TYPE_SDP:\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_SDP;\n\t\t\tbreak;\n\t\tcase MP2629_SOURCE_TYPE_CDP:\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_CDP;\n\t\t\tbreak;\n\t\tcase MP2629_SOURCE_TYPE_DCP:\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_DCP;\n\t\t\tbreak;\n\t\tcase MP2629_SOURCE_TYPE_OTG:\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_PD_DRP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = mp2629_read_adc(charger, MP2629_INPUT_VOLT, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = mp2629_read_adc(charger, MP2629_INPUT_CURRENT, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\tret = mp2629_get_prop(charger, INPUT_VLIM, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = mp2629_get_prop(charger, INPUT_ILIM, val);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mp2629_charger_usb_set_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(psy->dev.parent);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn mp2629_set_prop(charger, INPUT_VLIM, val);\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn mp2629_set_prop(charger, INPUT_ILIM, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mp2629_charger_battery_prop_writeable(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp)\n{\n\treturn (psp == POWER_SUPPLY_PROP_PRECHARGE_CURRENT) ||\n\t       (psp == POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT) ||\n\t       (psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT) ||\n\t       (psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE);\n}\n\nstatic int mp2629_charger_usb_prop_writeable(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp)\n{\n\treturn (psp == POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT) ||\n\t       (psp == POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT);\n}\n\nstatic irqreturn_t mp2629_irq_handler(int irq, void *dev_id)\n{\n\tstruct mp2629_charger *charger = dev_id;\n\tunsigned int rval;\n\tint ret;\n\n\tmutex_lock(&charger->lock);\n\n\tret = regmap_read(charger->regmap, MP2629_REG_FAULT, &rval);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (rval) {\n\t\tcharger->fault = rval;\n\t\tif (MP2629_FAULT_BATTERY & rval)\n\t\t\tdev_err(charger->dev, \"Battery fault OVP\\n\");\n\t\telse if (MP2629_FAULT_THERMAL & rval)\n\t\t\tdev_err(charger->dev, \"Thermal shutdown fault\\n\");\n\t\telse if (MP2629_FAULT_INPUT & rval)\n\t\t\tdev_err(charger->dev, \"no input or input OVP\\n\");\n\t\telse if (MP2629_FAULT_OTG & rval)\n\t\t\tdev_err(charger->dev, \"VIN overloaded\\n\");\n\n\t\tgoto unlock;\n\t}\n\n\tret = regmap_read(charger->regmap, MP2629_REG_STATUS, &rval);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (rval & MP2629_INPUTSOURCE_CHANGE)\n\t\tpower_supply_changed(charger->usb);\n\telse if (rval & MP2629_CHARGING_CHANGE)\n\t\tpower_supply_changed(charger->battery);\n\nunlock:\n\tmutex_unlock(&charger->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct power_supply_desc mp2629_usb_desc = {\n\t.name\t\t= \"mp2629_usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.usb_types      = mp2629_usb_types,\n\t.num_usb_types  = ARRAY_SIZE(mp2629_usb_types),\n\t.properties\t= mp2629_charger_usb_props,\n\t.num_properties\t= ARRAY_SIZE(mp2629_charger_usb_props),\n\t.get_property\t= mp2629_charger_usb_get_prop,\n\t.set_property\t= mp2629_charger_usb_set_prop,\n\t.property_is_writeable = mp2629_charger_usb_prop_writeable,\n};\n\nstatic const struct power_supply_desc mp2629_battery_desc = {\n\t.name\t\t= \"mp2629_battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= mp2629_charger_bat_props,\n\t.num_properties\t= ARRAY_SIZE(mp2629_charger_bat_props),\n\t.get_property\t= mp2629_charger_battery_get_prop,\n\t.set_property\t= mp2629_charger_battery_set_prop,\n\t.property_is_writeable = mp2629_charger_battery_prop_writeable,\n};\n\nstatic ssize_t batt_impedance_compensation_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(dev->parent);\n\tunsigned int rval;\n\tint ret;\n\n\tret = regmap_read(charger->regmap, MP2629_REG_IMPEDANCE_COMP, &rval);\n\tif (ret)\n\t\treturn ret;\n\n\trval = (rval >> 4) * 10;\n\treturn sysfs_emit(buf, \"%d mohm\\n\", rval);\n}\n\nstatic ssize_t batt_impedance_compensation_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf,\n\t\t\t\t\t    size_t count)\n{\n\tstruct mp2629_charger *charger = dev_get_drvdata(dev->parent);\n\tunsigned int val;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 140)\n\t\treturn -ERANGE;\n\n\t \n\tval = val / 10;\n\tret = regmap_update_bits(charger->regmap, MP2629_REG_IMPEDANCE_COMP,\n\t\t\t\t\tMP2629_MASK_IMPEDANCE, val << 4);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(batt_impedance_compensation);\n\nstatic struct attribute *mp2629_charger_sysfs_attrs[] = {\n\t&dev_attr_batt_impedance_compensation.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(mp2629_charger_sysfs);\n\nstatic void mp2629_charger_disable(void *data)\n{\n\tstruct mp2629_charger *charger = data;\n\n\tregmap_update_bits(charger->regmap, MP2629_REG_CHARGE_CTRL,\n\t\t\t\t\tMP2629_MASK_CHARGE_CTRL, 0);\n}\n\nstatic int mp2629_charger_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mp2629_data *ddata = dev_get_drvdata(dev->parent);\n\tstruct mp2629_charger *charger;\n\tstruct power_supply_config psy_cfg = {};\n\tint ret, i, irq;\n\n\tcharger = devm_kzalloc(dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tcharger->regmap = ddata->regmap;\n\tcharger->dev = dev;\n\tplatform_set_drvdata(pdev, charger);\n\n\tirq = platform_get_irq(to_platform_device(dev->parent), 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tfor (i = 0; i < MP2629_MAX_FIELD; i++) {\n\t\tcharger->regmap_fields[i] = devm_regmap_field_alloc(dev,\n\t\t\t\t\tcharger->regmap, mp2629_reg_fields[i]);\n\t\tif (IS_ERR(charger->regmap_fields[i])) {\n\t\t\tdev_err(dev, \"regmap field alloc fail %d\\n\", i);\n\t\t\treturn PTR_ERR(charger->regmap_fields[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MP2629_ADC_CHAN_END; i++) {\n\t\tcharger->iiochan[i] = devm_iio_channel_get(dev,\n\t\t\t\t\t\t\tadc_chan_name[i]);\n\t\tif (IS_ERR(charger->iiochan[i])) {\n\t\t\tdev_err(dev, \"iio chan get %s err\\n\", adc_chan_name[i]);\n\t\t\treturn PTR_ERR(charger->iiochan[i]);\n\t\t}\n\t}\n\n\tret = devm_add_action_or_reset(dev, mp2629_charger_disable, charger);\n\tif (ret)\n\t\treturn ret;\n\n\tcharger->usb = devm_power_supply_register(dev, &mp2629_usb_desc, NULL);\n\tif (IS_ERR(charger->usb)) {\n\t\tdev_err(dev, \"power supply register usb failed\\n\");\n\t\treturn PTR_ERR(charger->usb);\n\t}\n\n\tpsy_cfg.drv_data = charger;\n\tpsy_cfg.attr_grp = mp2629_charger_sysfs_groups;\n\tcharger->battery = devm_power_supply_register(dev,\n\t\t\t\t\t &mp2629_battery_desc, &psy_cfg);\n\tif (IS_ERR(charger->battery)) {\n\t\tdev_err(dev, \"power supply register battery failed\\n\");\n\t\treturn PTR_ERR(charger->battery);\n\t}\n\n\tret = regmap_update_bits(charger->regmap, MP2629_REG_CHARGE_CTRL,\n\t\t\t\t\tMP2629_MASK_CHARGE_CTRL, BIT(4));\n\tif (ret) {\n\t\tdev_err(dev, \"enable charge fail: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(charger->regmap, MP2629_REG_TIMER_CTRL,\n\t\t\t\t\tMP2629_MASK_WDOG_CTRL, 0);\n\n\tmutex_init(&charger->lock);\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\tmp2629_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"mp2629-charger\", charger);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request gpio IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(charger->regmap, MP2629_REG_INTERRUPT,\n\t\t\t\tGENMASK(6, 5), BIT(6) | BIT(5));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mp2629_charger_of_match[] = {\n\t{ .compatible = \"mps,mp2629_charger\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mp2629_charger_of_match);\n\nstatic struct platform_driver mp2629_charger_driver = {\n\t.driver = {\n\t\t.name = \"mp2629_charger\",\n\t\t.of_match_table = mp2629_charger_of_match,\n\t},\n\t.probe\t\t= mp2629_charger_probe,\n};\nmodule_platform_driver(mp2629_charger_driver);\n\nMODULE_AUTHOR(\"Saravanan Sekar <sravanhome@gmail.com>\");\nMODULE_DESCRIPTION(\"MP2629 Charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}