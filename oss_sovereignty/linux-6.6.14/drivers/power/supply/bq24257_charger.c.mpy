{
  "module_name": "bq24257_charger.c",
  "hash_id": "8cd33db1cd137c8de12f6a3376579ea00a34ae353d8d1721cf057e6e2de498e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq24257_charger.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#include <linux/acpi.h>\n#include <linux/of.h>\n\n#define BQ24257_REG_1\t\t\t0x00\n#define BQ24257_REG_2\t\t\t0x01\n#define BQ24257_REG_3\t\t\t0x02\n#define BQ24257_REG_4\t\t\t0x03\n#define BQ24257_REG_5\t\t\t0x04\n#define BQ24257_REG_6\t\t\t0x05\n#define BQ24257_REG_7\t\t\t0x06\n\n#define BQ24257_MANUFACTURER\t\t\"Texas Instruments\"\n#define BQ24257_PG_GPIO\t\t\t\"pg\"\n\n#define BQ24257_ILIM_SET_DELAY\t\t1000\t \n\n \nenum bq2425x_chip {\n\tBQ24250,\n\tBQ24251,\n\tBQ24257,\n};\n\nstatic const char *const bq2425x_chip_name[] = {\n\t\"bq24250\",\n\t\"bq24251\",\n\t\"bq24257\",\n};\n\nenum bq24257_fields {\n\tF_WD_FAULT, F_WD_EN, F_STAT, F_FAULT,\t\t\t     \n\tF_RESET, F_IILIMIT, F_EN_STAT, F_EN_TERM, F_CE, F_HZ_MODE,   \n\tF_VBAT, F_USB_DET,\t\t\t\t\t     \n\tF_ICHG, F_ITERM,\t\t\t\t\t     \n\tF_LOOP_STATUS, F_LOW_CHG, F_DPDM_EN, F_CE_STATUS, F_VINDPM,  \n\tF_X2_TMR_EN, F_TMR, F_SYSOFF, F_TS_EN, F_TS_STAT,\t     \n\tF_VOVP, F_CLR_VDP, F_FORCE_BATDET, F_FORCE_PTM,\t\t     \n\n\tF_MAX_FIELDS\n};\n\n \nstruct bq24257_init_data {\n\tu8 ichg;\t \n\tu8 vbat;\t \n\tu8 iterm;\t \n\tu8 iilimit;\t \n\tu8 vovp;\t \n\tu8 vindpm;\t \n};\n\nstruct bq24257_state {\n\tu8 status;\n\tu8 fault;\n\tbool power_good;\n};\n\nstruct bq24257_device {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct power_supply *charger;\n\n\tenum bq2425x_chip chip;\n\n\tstruct regmap *rmap;\n\tstruct regmap_field *rmap_fields[F_MAX_FIELDS];\n\n\tstruct gpio_desc *pg;\n\n\tstruct delayed_work iilimit_setup_work;\n\n\tstruct bq24257_init_data init_data;\n\tstruct bq24257_state state;\n\n\tstruct mutex lock;  \n\n\tbool iilimit_autoset_enable;\n};\n\nstatic bool bq24257_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase BQ24257_REG_2:\n\tcase BQ24257_REG_4:\n\t\treturn false;\n\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config bq24257_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = BQ24257_REG_7,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.volatile_reg = bq24257_is_volatile_reg,\n};\n\nstatic const struct reg_field bq24257_reg_fields[] = {\n\t \n\t[F_WD_FAULT]\t\t= REG_FIELD(BQ24257_REG_1, 7, 7),\n\t[F_WD_EN]\t\t= REG_FIELD(BQ24257_REG_1, 6, 6),\n\t[F_STAT]\t\t= REG_FIELD(BQ24257_REG_1, 4, 5),\n\t[F_FAULT]\t\t= REG_FIELD(BQ24257_REG_1, 0, 3),\n\t \n\t[F_RESET]\t\t= REG_FIELD(BQ24257_REG_2, 7, 7),\n\t[F_IILIMIT]\t\t= REG_FIELD(BQ24257_REG_2, 4, 6),\n\t[F_EN_STAT]\t\t= REG_FIELD(BQ24257_REG_2, 3, 3),\n\t[F_EN_TERM]\t\t= REG_FIELD(BQ24257_REG_2, 2, 2),\n\t[F_CE]\t\t\t= REG_FIELD(BQ24257_REG_2, 1, 1),\n\t[F_HZ_MODE]\t\t= REG_FIELD(BQ24257_REG_2, 0, 0),\n\t \n\t[F_VBAT]\t\t= REG_FIELD(BQ24257_REG_3, 2, 7),\n\t[F_USB_DET]\t\t= REG_FIELD(BQ24257_REG_3, 0, 1),\n\t \n\t[F_ICHG]\t\t= REG_FIELD(BQ24257_REG_4, 3, 7),\n\t[F_ITERM]\t\t= REG_FIELD(BQ24257_REG_4, 0, 2),\n\t \n\t[F_LOOP_STATUS]\t\t= REG_FIELD(BQ24257_REG_5, 6, 7),\n\t[F_LOW_CHG]\t\t= REG_FIELD(BQ24257_REG_5, 5, 5),\n\t[F_DPDM_EN]\t\t= REG_FIELD(BQ24257_REG_5, 4, 4),\n\t[F_CE_STATUS]\t\t= REG_FIELD(BQ24257_REG_5, 3, 3),\n\t[F_VINDPM]\t\t= REG_FIELD(BQ24257_REG_5, 0, 2),\n\t \n\t[F_X2_TMR_EN]\t\t= REG_FIELD(BQ24257_REG_6, 7, 7),\n\t[F_TMR]\t\t\t= REG_FIELD(BQ24257_REG_6, 5, 6),\n\t[F_SYSOFF]\t\t= REG_FIELD(BQ24257_REG_6, 4, 4),\n\t[F_TS_EN]\t\t= REG_FIELD(BQ24257_REG_6, 3, 3),\n\t[F_TS_STAT]\t\t= REG_FIELD(BQ24257_REG_6, 0, 2),\n\t \n\t[F_VOVP]\t\t= REG_FIELD(BQ24257_REG_7, 5, 7),\n\t[F_CLR_VDP]\t\t= REG_FIELD(BQ24257_REG_7, 4, 4),\n\t[F_FORCE_BATDET]\t= REG_FIELD(BQ24257_REG_7, 3, 3),\n\t[F_FORCE_PTM]\t\t= REG_FIELD(BQ24257_REG_7, 2, 2)\n};\n\nstatic const u32 bq24257_vbat_map[] = {\n\t3500000, 3520000, 3540000, 3560000, 3580000, 3600000, 3620000, 3640000,\n\t3660000, 3680000, 3700000, 3720000, 3740000, 3760000, 3780000, 3800000,\n\t3820000, 3840000, 3860000, 3880000, 3900000, 3920000, 3940000, 3960000,\n\t3980000, 4000000, 4020000, 4040000, 4060000, 4080000, 4100000, 4120000,\n\t4140000, 4160000, 4180000, 4200000, 4220000, 4240000, 4260000, 4280000,\n\t4300000, 4320000, 4340000, 4360000, 4380000, 4400000, 4420000, 4440000\n};\n\n#define BQ24257_VBAT_MAP_SIZE\t\tARRAY_SIZE(bq24257_vbat_map)\n\nstatic const u32 bq24257_ichg_map[] = {\n\t500000, 550000, 600000, 650000, 700000, 750000, 800000, 850000, 900000,\n\t950000, 1000000, 1050000, 1100000, 1150000, 1200000, 1250000, 1300000,\n\t1350000, 1400000, 1450000, 1500000, 1550000, 1600000, 1650000, 1700000,\n\t1750000, 1800000, 1850000, 1900000, 1950000, 2000000\n};\n\n#define BQ24257_ICHG_MAP_SIZE\t\tARRAY_SIZE(bq24257_ichg_map)\n\nstatic const u32 bq24257_iterm_map[] = {\n\t50000, 75000, 100000, 125000, 150000, 175000, 200000, 225000\n};\n\n#define BQ24257_ITERM_MAP_SIZE\t\tARRAY_SIZE(bq24257_iterm_map)\n\nstatic const u32 bq24257_iilimit_map[] = {\n\t100000, 150000, 500000, 900000, 1500000, 2000000\n};\n\n#define BQ24257_IILIMIT_MAP_SIZE\tARRAY_SIZE(bq24257_iilimit_map)\n\nstatic const u32 bq24257_vovp_map[] = {\n\t6000000, 6500000, 7000000, 8000000, 9000000, 9500000, 10000000,\n\t10500000\n};\n\n#define BQ24257_VOVP_MAP_SIZE\t\tARRAY_SIZE(bq24257_vovp_map)\n\nstatic const u32 bq24257_vindpm_map[] = {\n\t4200000, 4280000, 4360000, 4440000, 4520000, 4600000, 4680000,\n\t4760000\n};\n\n#define BQ24257_VINDPM_MAP_SIZE\t\tARRAY_SIZE(bq24257_vindpm_map)\n\nstatic int bq24257_field_read(struct bq24257_device *bq,\n\t\t\t      enum bq24257_fields field_id)\n{\n\tint ret;\n\tint val;\n\n\tret = regmap_field_read(bq->rmap_fields[field_id], &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int bq24257_field_write(struct bq24257_device *bq,\n\t\t\t       enum bq24257_fields field_id, u8 val)\n{\n\treturn regmap_field_write(bq->rmap_fields[field_id], val);\n}\n\nstatic u8 bq24257_find_idx(u32 value, const u32 *map, u8 map_size)\n{\n\tu8 idx;\n\n\tfor (idx = 1; idx < map_size; idx++)\n\t\tif (value < map[idx])\n\t\t\tbreak;\n\n\treturn idx - 1;\n}\n\nenum bq24257_status {\n\tSTATUS_READY,\n\tSTATUS_CHARGE_IN_PROGRESS,\n\tSTATUS_CHARGE_DONE,\n\tSTATUS_FAULT,\n};\n\nenum bq24257_fault {\n\tFAULT_NORMAL,\n\tFAULT_INPUT_OVP,\n\tFAULT_INPUT_UVLO,\n\tFAULT_SLEEP,\n\tFAULT_BAT_TS,\n\tFAULT_BAT_OVP,\n\tFAULT_TS,\n\tFAULT_TIMER,\n\tFAULT_NO_BAT,\n\tFAULT_ISET,\n\tFAULT_INPUT_LDO_LOW,\n};\n\nstatic int bq24257_get_input_current_limit(struct bq24257_device *bq,\n\t\t\t\t\t   union power_supply_propval *val)\n{\n\tint ret;\n\n\tret = bq24257_field_read(bq, F_IILIMIT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret >= BQ24257_IILIMIT_MAP_SIZE)\n\t\treturn -ENODATA;\n\n\tval->intval = bq24257_iilimit_map[ret];\n\n\treturn 0;\n}\n\nstatic int bq24257_set_input_current_limit(struct bq24257_device *bq,\n\t\t\t\t\tconst union power_supply_propval *val)\n{\n\t \n\tif (bq->iilimit_autoset_enable)\n\t\tcancel_delayed_work_sync(&bq->iilimit_setup_work);\n\n\treturn bq24257_field_write(bq, F_IILIMIT,\n\t\t\t\t   bq24257_find_idx(val->intval,\n\t\t\t\t\t\t    bq24257_iilimit_map,\n\t\t\t\t\t\t    BQ24257_IILIMIT_MAP_SIZE));\n}\n\nstatic int bq24257_power_supply_get_property(struct power_supply *psy,\n\t\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\tstruct bq24257_state state;\n\n\tmutex_lock(&bq->lock);\n\tstate = bq->state;\n\tmutex_unlock(&bq->lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (!state.power_good)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (state.status == STATUS_READY)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse if (state.status == STATUS_CHARGE_IN_PROGRESS)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (state.status == STATUS_CHARGE_DONE)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BQ24257_MANUFACTURER;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bq2425x_chip_name[bq->chip];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = state.power_good;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tswitch (state.fault) {\n\t\tcase FAULT_NORMAL:\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\t\tbreak;\n\n\t\tcase FAULT_INPUT_OVP:\n\t\tcase FAULT_BAT_OVP:\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\t\tbreak;\n\n\t\tcase FAULT_TS:\n\t\tcase FAULT_BAT_TS:\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\n\t\tcase FAULT_TIMER:\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tval->intval = bq24257_ichg_map[bq->init_data.ichg];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = bq24257_ichg_map[BQ24257_ICHG_MAP_SIZE - 1];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tval->intval = bq24257_vbat_map[bq->init_data.vbat];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = bq24257_vbat_map[BQ24257_VBAT_MAP_SIZE - 1];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tval->intval = bq24257_iterm_map[bq->init_data.iterm];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn bq24257_get_input_current_limit(bq, val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24257_power_supply_set_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property prop,\n\t\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn bq24257_set_input_current_limit(bq, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bq24257_power_supply_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int bq24257_get_chip_state(struct bq24257_device *bq,\n\t\t\t\t  struct bq24257_state *state)\n{\n\tint ret;\n\n\tret = bq24257_field_read(bq, F_STAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->status = ret;\n\n\tret = bq24257_field_read(bq, F_FAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->fault = ret;\n\n\tif (bq->pg)\n\t\tstate->power_good = !gpiod_get_value_cansleep(bq->pg);\n\telse\n\t\t \n\t\tswitch (state->fault) {\n\t\tcase FAULT_INPUT_OVP:\n\t\tcase FAULT_INPUT_UVLO:\n\t\tcase FAULT_INPUT_LDO_LOW:\n\t\t\tstate->power_good = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate->power_good = true;\n\t\t}\n\n\treturn 0;\n}\n\nstatic bool bq24257_state_changed(struct bq24257_device *bq,\n\t\t\t\t  struct bq24257_state *new_state)\n{\n\tint ret;\n\n\tmutex_lock(&bq->lock);\n\tret = (bq->state.status != new_state->status ||\n\t       bq->state.fault != new_state->fault ||\n\t       bq->state.power_good != new_state->power_good);\n\tmutex_unlock(&bq->lock);\n\n\treturn ret;\n}\n\nenum bq24257_loop_status {\n\tLOOP_STATUS_NONE,\n\tLOOP_STATUS_IN_DPM,\n\tLOOP_STATUS_IN_CURRENT_LIMIT,\n\tLOOP_STATUS_THERMAL,\n};\n\nenum bq24257_in_ilimit {\n\tIILIMIT_100,\n\tIILIMIT_150,\n\tIILIMIT_500,\n\tIILIMIT_900,\n\tIILIMIT_1500,\n\tIILIMIT_2000,\n\tIILIMIT_EXT,\n\tIILIMIT_NONE,\n};\n\nenum bq24257_vovp {\n\tVOVP_6000,\n\tVOVP_6500,\n\tVOVP_7000,\n\tVOVP_8000,\n\tVOVP_9000,\n\tVOVP_9500,\n\tVOVP_10000,\n\tVOVP_10500\n};\n\nenum bq24257_vindpm {\n\tVINDPM_4200,\n\tVINDPM_4280,\n\tVINDPM_4360,\n\tVINDPM_4440,\n\tVINDPM_4520,\n\tVINDPM_4600,\n\tVINDPM_4680,\n\tVINDPM_4760\n};\n\nenum bq24257_port_type {\n\tPORT_TYPE_DCP,\t\t \n\tPORT_TYPE_CDP,\t\t \n\tPORT_TYPE_SDP,\t\t \n\tPORT_TYPE_NON_STANDARD,\n};\n\nenum bq24257_safety_timer {\n\tSAFETY_TIMER_45,\n\tSAFETY_TIMER_360,\n\tSAFETY_TIMER_540,\n\tSAFETY_TIMER_NONE,\n};\n\nstatic int bq24257_iilimit_autoset(struct bq24257_device *bq)\n{\n\tint loop_status;\n\tint iilimit;\n\tint port_type;\n\tint ret;\n\tconst u8 new_iilimit[] = {\n\t\t[PORT_TYPE_DCP] = IILIMIT_2000,\n\t\t[PORT_TYPE_CDP] = IILIMIT_2000,\n\t\t[PORT_TYPE_SDP] = IILIMIT_500,\n\t\t[PORT_TYPE_NON_STANDARD] = IILIMIT_500\n\t};\n\n\tret = bq24257_field_read(bq, F_LOOP_STATUS);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tloop_status = ret;\n\n\tret = bq24257_field_read(bq, F_IILIMIT);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tiilimit = ret;\n\n\t \n\tif (loop_status == LOOP_STATUS_IN_DPM && iilimit == IILIMIT_500)\n\t\treturn 0;\n\n\tret = bq24257_field_read(bq, F_USB_DET);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tport_type = ret;\n\n\tret = bq24257_field_write(bq, F_IILIMIT, new_iilimit[port_type]);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = bq24257_field_write(bq, F_TMR, SAFETY_TIMER_360);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = bq24257_field_write(bq, F_CLR_VDP, 1);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdev_dbg(bq->dev, \"port/loop = %d/%d -> iilimit = %d\\n\",\n\t\tport_type, loop_status, new_iilimit[port_type]);\n\n\treturn 0;\n\nerror:\n\tdev_err(bq->dev, \"%s: Error communicating with the chip.\\n\", __func__);\n\treturn ret;\n}\n\nstatic void bq24257_iilimit_setup_work(struct work_struct *work)\n{\n\tstruct bq24257_device *bq = container_of(work, struct bq24257_device,\n\t\t\t\t\t\t iilimit_setup_work.work);\n\n\tbq24257_iilimit_autoset(bq);\n}\n\nstatic void bq24257_handle_state_change(struct bq24257_device *bq,\n\t\t\t\t\tstruct bq24257_state *new_state)\n{\n\tint ret;\n\tstruct bq24257_state old_state;\n\n\tmutex_lock(&bq->lock);\n\told_state = bq->state;\n\tmutex_unlock(&bq->lock);\n\n\t \n\tif (!new_state->power_good) {\n\t\tdev_dbg(bq->dev, \"Power removed\\n\");\n\t\tif (bq->iilimit_autoset_enable) {\n\t\t\tcancel_delayed_work_sync(&bq->iilimit_setup_work);\n\n\t\t\t \n\t\t\tret = bq24257_field_write(bq, F_DPDM_EN, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tret = bq24257_field_write(bq, F_IILIMIT, bq->init_data.iilimit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t} else if (!old_state.power_good) {\n\t\tdev_dbg(bq->dev, \"Power inserted\\n\");\n\n\t\tif (bq->iilimit_autoset_enable)\n\t\t\t \n\t\t\tschedule_delayed_work(&bq->iilimit_setup_work,\n\t\t\t\t      msecs_to_jiffies(BQ24257_ILIM_SET_DELAY));\n\t} else if (new_state->fault == FAULT_NO_BAT) {\n\t\tdev_warn(bq->dev, \"Battery removed\\n\");\n\t} else if (new_state->fault == FAULT_TIMER) {\n\t\tdev_err(bq->dev, \"Safety timer expired! Battery dead?\\n\");\n\t}\n\n\treturn;\n\nerror:\n\tdev_err(bq->dev, \"%s: Error communicating with the chip.\\n\", __func__);\n}\n\nstatic irqreturn_t bq24257_irq_handler_thread(int irq, void *private)\n{\n\tint ret;\n\tstruct bq24257_device *bq = private;\n\tstruct bq24257_state state;\n\n\tret = bq24257_get_chip_state(bq, &state);\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (!bq24257_state_changed(bq, &state))\n\t\treturn IRQ_HANDLED;\n\n\tdev_dbg(bq->dev, \"irq(state changed): status/fault/pg = %d/%d/%d\\n\",\n\t\tstate.status, state.fault, state.power_good);\n\n\tbq24257_handle_state_change(bq, &state);\n\n\tmutex_lock(&bq->lock);\n\tbq->state = state;\n\tmutex_unlock(&bq->lock);\n\n\tpower_supply_changed(bq->charger);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bq24257_hw_init(struct bq24257_device *bq)\n{\n\tint ret;\n\tint i;\n\tstruct bq24257_state state;\n\n\tconst struct {\n\t\tint field;\n\t\tu32 value;\n\t} init_data[] = {\n\t\t{F_ICHG, bq->init_data.ichg},\n\t\t{F_VBAT, bq->init_data.vbat},\n\t\t{F_ITERM, bq->init_data.iterm},\n\t\t{F_VOVP, bq->init_data.vovp},\n\t\t{F_VINDPM, bq->init_data.vindpm},\n\t};\n\n\t \n\tret = bq24257_field_write(bq, F_WD_EN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\n\t\tret = bq24257_field_write(bq, init_data[i].field,\n\t\t\t\t\t  init_data[i].value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = bq24257_get_chip_state(bq, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&bq->lock);\n\tbq->state = state;\n\tmutex_unlock(&bq->lock);\n\n\tif (!bq->iilimit_autoset_enable) {\n\t\tdev_dbg(bq->dev, \"manually setting iilimit = %u\\n\",\n\t\t\tbq->init_data.iilimit);\n\n\t\t \n\t\tret = bq24257_field_write(bq, F_IILIMIT,\n\t\t\t\t\t  bq->init_data.iilimit);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (!state.power_good)\n\t\t \n\t\tret = bq24257_field_write(bq, F_DPDM_EN, 1);\n\telse if (state.fault != FAULT_NO_BAT)\n\t\tret = bq24257_iilimit_autoset(bq);\n\n\treturn ret;\n}\n\nstatic enum power_supply_property bq24257_power_supply_props[] = {\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n};\n\nstatic char *bq24257_charger_supplied_to[] = {\n\t\"main-battery\",\n};\n\nstatic const struct power_supply_desc bq24257_power_supply_desc = {\n\t.name = \"bq24257-charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = bq24257_power_supply_props,\n\t.num_properties = ARRAY_SIZE(bq24257_power_supply_props),\n\t.get_property = bq24257_power_supply_get_property,\n\t.set_property = bq24257_power_supply_set_property,\n\t.property_is_writeable = bq24257_power_supply_property_is_writeable,\n};\n\nstatic ssize_t bq24257_show_ovp_voltage(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\n\treturn sysfs_emit(buf, \"%u\\n\", bq24257_vovp_map[bq->init_data.vovp]);\n}\n\nstatic ssize_t bq24257_show_in_dpm_voltage(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\n\treturn sysfs_emit(buf, \"%u\\n\", bq24257_vindpm_map[bq->init_data.vindpm]);\n}\n\nstatic ssize_t bq24257_sysfs_show_enable(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (strcmp(attr->attr.name, \"high_impedance_enable\") == 0)\n\t\tret = bq24257_field_read(bq, F_HZ_MODE);\n\telse if (strcmp(attr->attr.name, \"sysoff_enable\") == 0)\n\t\tret = bq24257_field_read(bq, F_SYSOFF);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t bq24257_sysfs_set_enable(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf,\n\t\t\t\t\tsize_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24257_device *bq = power_supply_get_drvdata(psy);\n\tlong val;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (strcmp(attr->attr.name, \"high_impedance_enable\") == 0)\n\t\tret = bq24257_field_write(bq, F_HZ_MODE, (bool)val);\n\telse if (strcmp(attr->attr.name, \"sysoff_enable\") == 0)\n\t\tret = bq24257_field_write(bq, F_SYSOFF, (bool)val);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(ovp_voltage, S_IRUGO, bq24257_show_ovp_voltage, NULL);\nstatic DEVICE_ATTR(in_dpm_voltage, S_IRUGO, bq24257_show_in_dpm_voltage, NULL);\nstatic DEVICE_ATTR(high_impedance_enable, S_IWUSR | S_IRUGO,\n\t\t   bq24257_sysfs_show_enable, bq24257_sysfs_set_enable);\nstatic DEVICE_ATTR(sysoff_enable, S_IWUSR | S_IRUGO,\n\t\t   bq24257_sysfs_show_enable, bq24257_sysfs_set_enable);\n\nstatic struct attribute *bq24257_charger_sysfs_attrs[] = {\n\t&dev_attr_ovp_voltage.attr,\n\t&dev_attr_in_dpm_voltage.attr,\n\t&dev_attr_high_impedance_enable.attr,\n\t&dev_attr_sysoff_enable.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(bq24257_charger_sysfs);\n\nstatic int bq24257_power_supply_init(struct bq24257_device *bq)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = bq, };\n\n\tpsy_cfg.attr_grp = bq24257_charger_sysfs_groups;\n\tpsy_cfg.supplied_to = bq24257_charger_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(bq24257_charger_supplied_to);\n\n\tbq->charger = devm_power_supply_register(bq->dev,\n\t\t\t\t\t\t &bq24257_power_supply_desc,\n\t\t\t\t\t\t &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(bq->charger);\n}\n\nstatic void bq24257_pg_gpio_probe(struct bq24257_device *bq)\n{\n\tbq->pg = devm_gpiod_get_optional(bq->dev, BQ24257_PG_GPIO, GPIOD_IN);\n\n\tif (PTR_ERR(bq->pg) == -EPROBE_DEFER) {\n\t\tdev_info(bq->dev, \"probe retry requested for PG pin\\n\");\n\t\treturn;\n\t} else if (IS_ERR(bq->pg)) {\n\t\tdev_err(bq->dev, \"error probing PG pin\\n\");\n\t\tbq->pg = NULL;\n\t\treturn;\n\t}\n\n\tif (bq->pg)\n\t\tdev_dbg(bq->dev, \"probed PG pin = %d\\n\", desc_to_gpio(bq->pg));\n}\n\nstatic int bq24257_fw_probe(struct bq24257_device *bq)\n{\n\tint ret;\n\tu32 property;\n\n\t \n\tret = device_property_read_u32(bq->dev, \"ti,charge-current\", &property);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbq->init_data.ichg = bq24257_find_idx(property, bq24257_ichg_map,\n\t\t\t\t\t      BQ24257_ICHG_MAP_SIZE);\n\n\tret = device_property_read_u32(bq->dev, \"ti,battery-regulation-voltage\",\n\t\t\t\t       &property);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbq->init_data.vbat = bq24257_find_idx(property, bq24257_vbat_map,\n\t\t\t\t\t      BQ24257_VBAT_MAP_SIZE);\n\n\tret = device_property_read_u32(bq->dev, \"ti,termination-current\",\n\t\t\t\t       &property);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbq->init_data.iterm = bq24257_find_idx(property, bq24257_iterm_map,\n\t\t\t\t\t       BQ24257_ITERM_MAP_SIZE);\n\n\t \n\tret = device_property_read_u32(bq->dev, \"ti,current-limit\",\n\t\t\t\t       &property);\n\tif (ret < 0) {\n\t\tbq->iilimit_autoset_enable = true;\n\n\t\t \n\t\tbq->init_data.iilimit = IILIMIT_500;\n\t} else\n\t\tbq->init_data.iilimit =\n\t\t\t\tbq24257_find_idx(property,\n\t\t\t\t\t\t bq24257_iilimit_map,\n\t\t\t\t\t\t BQ24257_IILIMIT_MAP_SIZE);\n\n\tret = device_property_read_u32(bq->dev, \"ti,ovp-voltage\",\n\t\t\t\t       &property);\n\tif (ret < 0)\n\t\tbq->init_data.vovp = VOVP_6500;\n\telse\n\t\tbq->init_data.vovp = bq24257_find_idx(property,\n\t\t\t\t\t\t      bq24257_vovp_map,\n\t\t\t\t\t\t      BQ24257_VOVP_MAP_SIZE);\n\n\tret = device_property_read_u32(bq->dev, \"ti,in-dpm-voltage\",\n\t\t\t\t       &property);\n\tif (ret < 0)\n\t\tbq->init_data.vindpm = VINDPM_4360;\n\telse\n\t\tbq->init_data.vindpm =\n\t\t\t\tbq24257_find_idx(property,\n\t\t\t\t\t\t bq24257_vindpm_map,\n\t\t\t\t\t\t BQ24257_VINDPM_MAP_SIZE);\n\n\treturn 0;\n}\n\nstatic int bq24257_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tconst struct acpi_device_id *acpi_id;\n\tstruct bq24257_device *bq;\n\tint ret;\n\tint i;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"No support for SMBUS_BYTE_DATA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbq = devm_kzalloc(dev, sizeof(*bq), GFP_KERNEL);\n\tif (!bq)\n\t\treturn -ENOMEM;\n\n\tbq->client = client;\n\tbq->dev = dev;\n\n\tif (ACPI_HANDLE(dev)) {\n\t\tacpi_id = acpi_match_device(dev->driver->acpi_match_table,\n\t\t\t\t\t    &client->dev);\n\t\tif (!acpi_id) {\n\t\t\tdev_err(dev, \"Failed to match ACPI device\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbq->chip = (enum bq2425x_chip)acpi_id->driver_data;\n\t} else {\n\t\tbq->chip = (enum bq2425x_chip)id->driver_data;\n\t}\n\n\tmutex_init(&bq->lock);\n\n\tbq->rmap = devm_regmap_init_i2c(client, &bq24257_regmap_config);\n\tif (IS_ERR(bq->rmap)) {\n\t\tdev_err(dev, \"failed to allocate register map\\n\");\n\t\treturn PTR_ERR(bq->rmap);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bq24257_reg_fields); i++) {\n\t\tconst struct reg_field *reg_fields = bq24257_reg_fields;\n\n\t\tbq->rmap_fields[i] = devm_regmap_field_alloc(dev, bq->rmap,\n\t\t\t\t\t\t\t     reg_fields[i]);\n\t\tif (IS_ERR(bq->rmap_fields[i])) {\n\t\t\tdev_err(dev, \"cannot allocate regmap field\\n\");\n\t\t\treturn PTR_ERR(bq->rmap_fields[i]);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, bq);\n\n\tif (!dev->platform_data) {\n\t\tret = bq24257_fw_probe(bq);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Cannot read device properties.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (bq->chip == BQ24250)\n\t\tbq->iilimit_autoset_enable = false;\n\n\tif (bq->iilimit_autoset_enable)\n\t\tINIT_DELAYED_WORK(&bq->iilimit_setup_work,\n\t\t\t\t  bq24257_iilimit_setup_work);\n\n\t \n\tif (bq->chip != BQ24250)\n\t\tbq24257_pg_gpio_probe(bq);\n\n\tif (PTR_ERR(bq->pg) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(bq->pg);\n\telse if (!bq->pg)\n\t\tdev_info(bq->dev, \"using SW-based power-good detection\\n\");\n\n\t \n\tret = bq24257_field_write(bq, F_RESET, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = bq24257_field_write(bq, F_RESET, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24257_hw_init(bq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot initialize the chip.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bq24257_power_supply_init(bq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register power supply\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tbq24257_irq_handler_thread,\n\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tbq2425x_chip_name[bq->chip], bq);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request IRQ #%d\\n\", client->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void bq24257_remove(struct i2c_client *client)\n{\n\tstruct bq24257_device *bq = i2c_get_clientdata(client);\n\n\tif (bq->iilimit_autoset_enable)\n\t\tcancel_delayed_work_sync(&bq->iilimit_setup_work);\n\n\tbq24257_field_write(bq, F_RESET, 1);  \n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bq24257_suspend(struct device *dev)\n{\n\tstruct bq24257_device *bq = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (bq->iilimit_autoset_enable)\n\t\tcancel_delayed_work_sync(&bq->iilimit_setup_work);\n\n\t \n\tret = bq24257_field_write(bq, F_RESET, 1);\n\tif (ret < 0)\n\t\tdev_err(bq->dev, \"Cannot reset chip to standalone mode.\\n\");\n\n\treturn ret;\n}\n\nstatic int bq24257_resume(struct device *dev)\n{\n\tint ret;\n\tstruct bq24257_device *bq = dev_get_drvdata(dev);\n\n\tret = regcache_drop_region(bq->rmap, BQ24257_REG_1, BQ24257_REG_7);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24257_field_write(bq, F_RESET, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24257_hw_init(bq);\n\tif (ret < 0) {\n\t\tdev_err(bq->dev, \"Cannot init chip after resume.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpower_supply_changed(bq->charger);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops bq24257_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bq24257_suspend, bq24257_resume)\n};\n\nstatic const struct i2c_device_id bq24257_i2c_ids[] = {\n\t{ \"bq24250\", BQ24250 },\n\t{ \"bq24251\", BQ24251 },\n\t{ \"bq24257\", BQ24257 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, bq24257_i2c_ids);\n\nstatic const struct of_device_id bq24257_of_match[] __maybe_unused = {\n\t{ .compatible = \"ti,bq24250\", },\n\t{ .compatible = \"ti,bq24251\", },\n\t{ .compatible = \"ti,bq24257\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bq24257_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id bq24257_acpi_match[] = {\n\t{ \"BQ242500\", BQ24250 },\n\t{ \"BQ242510\", BQ24251 },\n\t{ \"BQ242570\", BQ24257 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, bq24257_acpi_match);\n#endif\n\nstatic struct i2c_driver bq24257_driver = {\n\t.driver = {\n\t\t.name = \"bq24257-charger\",\n\t\t.of_match_table = of_match_ptr(bq24257_of_match),\n\t\t.acpi_match_table = ACPI_PTR(bq24257_acpi_match),\n\t\t.pm = &bq24257_pm,\n\t},\n\t.probe = bq24257_probe,\n\t.remove = bq24257_remove,\n\t.id_table = bq24257_i2c_ids,\n};\nmodule_i2c_driver(bq24257_driver);\n\nMODULE_AUTHOR(\"Laurentiu Palcu <laurentiu.palcu@intel.com>\");\nMODULE_DESCRIPTION(\"bq24257 charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}