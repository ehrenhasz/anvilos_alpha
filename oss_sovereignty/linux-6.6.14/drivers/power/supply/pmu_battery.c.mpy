{
  "module_name": "pmu_battery.c",
  "hash_id": "f5d9ca5e2638adabac4d74a93f23daf7686c7874e49aafb45e85fd50bddd1fa1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/pmu_battery.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/power_supply.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#include <linux/slab.h>\n\nstatic struct pmu_battery_dev {\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct pmu_battery_info *pbi;\n\tchar name[16];\n\tint propval;\n} *pbats[PMU_MAX_BATTERIES];\n\n#define to_pmu_battery_dev(x) power_supply_get_drvdata(x)\n\n \n\nstatic int pmu_get_ac_prop(struct power_supply *psy,\n\t\t\t   enum power_supply_property psp,\n\t\t\t   union power_supply_propval *val)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = (!!(pmu_power_flags & PMU_PWR_AC_PRESENT)) ||\n\t\t\t      (pmu_battery_count == 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property pmu_ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc pmu_ac_desc = {\n\t.name = \"pmu-ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = pmu_ac_props,\n\t.num_properties = ARRAY_SIZE(pmu_ac_props),\n\t.get_property = pmu_get_ac_prop,\n};\n\nstatic struct power_supply *pmu_ac;\n\n \n\nstatic char *pmu_batt_types[] = {\n\t\"Smart\", \"Comet\", \"Hooper\", \"Unknown\"\n};\n\nstatic char *pmu_bat_get_model_name(struct pmu_battery_info *pbi)\n{\n\tswitch (pbi->flags & PMU_BATT_TYPE_MASK) {\n\tcase PMU_BATT_TYPE_SMART:\n\t\treturn pmu_batt_types[0];\n\tcase PMU_BATT_TYPE_COMET:\n\t\treturn pmu_batt_types[1];\n\tcase PMU_BATT_TYPE_HOOPER:\n\t\treturn pmu_batt_types[2];\n\tdefault: break;\n\t}\n\treturn pmu_batt_types[3];\n}\n\nstatic int pmu_bat_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct pmu_battery_dev *pbat = to_pmu_battery_dev(psy);\n\tstruct pmu_battery_info *pbi = pbat->pbi;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (pbi->flags & PMU_BATT_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (pmu_power_flags & PMU_PWR_AC_PRESENT)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!(pbi->flags & PMU_BATT_PRESENT);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = pmu_bat_get_model_name(pbi);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_AVG:\n\t\tval->intval = pbi->charge     * 1000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tval->intval = pbi->max_charge * 1000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tval->intval = pbi->amperage   * 1000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tval->intval = pbi->voltage    * 1000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\t\tval->intval = pbi->time_remaining;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property pmu_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_ENERGY_AVG,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,\n};\n\n \n\nstatic struct platform_device *bat_pdev;\n\nstatic int __init pmu_bat_init(void)\n{\n\tint ret = 0;\n\tint i;\n\n\tbat_pdev = platform_device_register_simple(\"pmu-battery\",\n\t\t\t\t\t\t   0, NULL, 0);\n\tif (IS_ERR(bat_pdev)) {\n\t\tret = PTR_ERR(bat_pdev);\n\t\tgoto pdev_register_failed;\n\t}\n\n\tpmu_ac = power_supply_register(&bat_pdev->dev, &pmu_ac_desc, NULL);\n\tif (IS_ERR(pmu_ac)) {\n\t\tret = PTR_ERR(pmu_ac);\n\t\tgoto ac_register_failed;\n\t}\n\n\tfor (i = 0; i < pmu_battery_count; i++) {\n\t\tstruct power_supply_config psy_cfg = {};\n\t\tstruct pmu_battery_dev *pbat = kzalloc(sizeof(*pbat),\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!pbat)\n\t\t\tbreak;\n\n\t\tsprintf(pbat->name, \"PMU_battery_%d\", i);\n\t\tpbat->bat_desc.name = pbat->name;\n\t\tpbat->bat_desc.properties = pmu_bat_props;\n\t\tpbat->bat_desc.num_properties = ARRAY_SIZE(pmu_bat_props);\n\t\tpbat->bat_desc.get_property = pmu_bat_get_property;\n\t\tpbat->pbi = &pmu_batteries[i];\n\t\tpsy_cfg.drv_data = pbat;\n\n\t\tpbat->bat = power_supply_register(&bat_pdev->dev,\n\t\t\t\t\t\t  &pbat->bat_desc,\n\t\t\t\t\t\t  &psy_cfg);\n\t\tif (IS_ERR(pbat->bat)) {\n\t\t\tret = PTR_ERR(pbat->bat);\n\t\t\tkfree(pbat);\n\t\t\tgoto battery_register_failed;\n\t\t}\n\t\tpbats[i] = pbat;\n\t}\n\n\tgoto success;\n\nbattery_register_failed:\n\twhile (i--) {\n\t\tif (!pbats[i])\n\t\t\tcontinue;\n\t\tpower_supply_unregister(pbats[i]->bat);\n\t\tkfree(pbats[i]);\n\t}\n\tpower_supply_unregister(pmu_ac);\nac_register_failed:\n\tplatform_device_unregister(bat_pdev);\npdev_register_failed:\nsuccess:\n\treturn ret;\n}\n\nstatic void __exit pmu_bat_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PMU_MAX_BATTERIES; i++) {\n\t\tif (!pbats[i])\n\t\t\tcontinue;\n\t\tpower_supply_unregister(pbats[i]->bat);\n\t\tkfree(pbats[i]);\n\t}\n\tpower_supply_unregister(pmu_ac);\n\tplatform_device_unregister(bat_pdev);\n}\n\nmodule_init(pmu_bat_init);\nmodule_exit(pmu_bat_exit);\n\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PMU battery driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}