{
  "module_name": "axp20x_ac_power.c",
  "hash_id": "c3c155334692126b581c1147ad589d7dc99443776157e639d02028dbecdc8add",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/axp20x_ac_power.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/iio/consumer.h>\n\n#define AXP20X_PWR_STATUS_ACIN_PRESENT\tBIT(7)\n#define AXP20X_PWR_STATUS_ACIN_AVAIL\tBIT(6)\n\n#define AXP813_ACIN_PATH_SEL\t\tBIT(7)\n#define AXP813_ACIN_PATH_SEL_TO_BIT(x)\t(!!(x) << 7)\n\n#define AXP813_VHOLD_MASK\t\tGENMASK(5, 3)\n#define AXP813_VHOLD_UV_TO_BIT(x)\t((((x) / 100000) - 40) << 3)\n#define AXP813_VHOLD_REG_TO_UV(x)\t\\\n\t(((((x) & AXP813_VHOLD_MASK) >> 3) + 40) * 100000)\n\n#define AXP813_CURR_LIMIT_MASK\t\tGENMASK(2, 0)\n#define AXP813_CURR_LIMIT_UA_TO_BIT(x)\t(((x) / 500000) - 3)\n#define AXP813_CURR_LIMIT_REG_TO_UA(x)\t\\\n\t((((x) & AXP813_CURR_LIMIT_MASK) + 3) * 500000)\n\n#define DRVNAME \"axp20x-ac-power-supply\"\n\nstruct axp20x_ac_power {\n\tstruct regmap *regmap;\n\tstruct power_supply *supply;\n\tstruct iio_channel *acin_v;\n\tstruct iio_channel *acin_i;\n\tbool has_acin_path_sel;\n\tunsigned int num_irqs;\n\tunsigned int irqs[];\n};\n\nstatic irqreturn_t axp20x_ac_power_irq(int irq, void *devid)\n{\n\tstruct axp20x_ac_power *power = devid;\n\n\tpower_supply_changed(power->supply);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int axp20x_ac_power_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct axp20x_ac_power *power = power_supply_get_drvdata(psy);\n\tint ret, reg;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & AXP20X_PWR_STATUS_ACIN_PRESENT) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\t\treturn 0;\n\t\t}\n\n\t\tval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = !!(reg & AXP20X_PWR_STATUS_ACIN_PRESENT);\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = !!(reg & AXP20X_PWR_STATUS_ACIN_AVAIL);\n\n\t\t \n\t\tif (val->intval && power->has_acin_path_sel) {\n\t\t\tret = regmap_read(power->regmap, AXP813_ACIN_PATH_CTRL,\n\t\t\t\t\t  &reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tval->intval = !!(reg & AXP813_ACIN_PATH_SEL);\n\t\t}\n\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = iio_read_channel_processed(power->acin_v, &val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval *= 1000;\n\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = iio_read_channel_processed(power->acin_i, &val->intval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval *= 1000;\n\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tret = regmap_read(power->regmap, AXP813_ACIN_PATH_CTRL, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = AXP813_VHOLD_REG_TO_UV(reg);\n\n\t\treturn 0;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = regmap_read(power->regmap, AXP813_ACIN_PATH_CTRL, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval->intval = AXP813_CURR_LIMIT_REG_TO_UA(reg);\n\t\t \n\t\tif (val->intval > 4000000)\n\t\t\tval->intval = 4000000;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int axp813_ac_power_set_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct axp20x_ac_power *power = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn regmap_update_bits(power->regmap, AXP813_ACIN_PATH_CTRL,\n\t\t\t\t\t  AXP813_ACIN_PATH_SEL,\n\t\t\t\t\t  AXP813_ACIN_PATH_SEL_TO_BIT(val->intval));\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tif (val->intval < 4000000 || val->intval > 4700000)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_update_bits(power->regmap, AXP813_ACIN_PATH_CTRL,\n\t\t\t\t\t  AXP813_VHOLD_MASK,\n\t\t\t\t\t  AXP813_VHOLD_UV_TO_BIT(val->intval));\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (val->intval < 1500000 || val->intval > 4000000)\n\t\t\treturn -EINVAL;\n\n\t\treturn regmap_update_bits(power->regmap, AXP813_ACIN_PATH_CTRL,\n\t\t\t\t\t  AXP813_CURR_LIMIT_MASK,\n\t\t\t\t\t  AXP813_CURR_LIMIT_UA_TO_BIT(val->intval));\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int axp813_ac_power_prop_writeable(struct power_supply *psy,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_ONLINE ||\n\t       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||\n\t       psp == POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;\n}\n\nstatic enum power_supply_property axp20x_ac_power_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic enum power_supply_property axp22x_ac_power_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic enum power_supply_property axp813_ac_power_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n};\n\nstatic const struct power_supply_desc axp20x_ac_power_desc = {\n\t.name = \"axp20x-ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = axp20x_ac_power_properties,\n\t.num_properties = ARRAY_SIZE(axp20x_ac_power_properties),\n\t.get_property = axp20x_ac_power_get_property,\n};\n\nstatic const struct power_supply_desc axp22x_ac_power_desc = {\n\t.name = \"axp22x-ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = axp22x_ac_power_properties,\n\t.num_properties = ARRAY_SIZE(axp22x_ac_power_properties),\n\t.get_property = axp20x_ac_power_get_property,\n};\n\nstatic const struct power_supply_desc axp813_ac_power_desc = {\n\t.name = \"axp813-ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = axp813_ac_power_properties,\n\t.num_properties = ARRAY_SIZE(axp813_ac_power_properties),\n\t.property_is_writeable = axp813_ac_power_prop_writeable,\n\t.get_property = axp20x_ac_power_get_property,\n\t.set_property = axp813_ac_power_set_property,\n};\n\nstatic const char * const axp20x_irq_names[] = {\n\t\"ACIN_PLUGIN\",\n\t\"ACIN_REMOVAL\",\n};\n\nstruct axp_data {\n\tconst struct power_supply_desc\t*power_desc;\n\tconst char * const\t\t*irq_names;\n\tunsigned int\t\t\tnum_irq_names;\n\tbool\t\t\t\tacin_adc;\n\tbool\t\t\t\tacin_path_sel;\n};\n\nstatic const struct axp_data axp20x_data = {\n\t.power_desc\t= &axp20x_ac_power_desc,\n\t.irq_names\t= axp20x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp20x_irq_names),\n\t.acin_adc\t= true,\n\t.acin_path_sel\t= false,\n};\n\nstatic const struct axp_data axp22x_data = {\n\t.power_desc\t= &axp22x_ac_power_desc,\n\t.irq_names\t= axp20x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp20x_irq_names),\n\t.acin_adc\t= false,\n\t.acin_path_sel\t= false,\n};\n\nstatic const struct axp_data axp813_data = {\n\t.power_desc\t= &axp813_ac_power_desc,\n\t.irq_names\t= axp20x_irq_names,\n\t.num_irq_names\t= ARRAY_SIZE(axp20x_irq_names),\n\t.acin_adc\t= false,\n\t.acin_path_sel\t= true,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int axp20x_ac_power_suspend(struct device *dev)\n{\n\tstruct axp20x_ac_power *power = dev_get_drvdata(dev);\n\tint i = 0;\n\n\t \n\tif (device_may_wakeup(&power->supply->dev))\n\t\tenable_irq_wake(power->irqs[i++]);\n\twhile (i < power->num_irqs)\n\t\tdisable_irq(power->irqs[i++]);\n\n\treturn 0;\n}\n\nstatic int axp20x_ac_power_resume(struct device *dev)\n{\n\tstruct axp20x_ac_power *power = dev_get_drvdata(dev);\n\tint i = 0;\n\n\tif (device_may_wakeup(&power->supply->dev))\n\t\tdisable_irq_wake(power->irqs[i++]);\n\twhile (i < power->num_irqs)\n\t\tenable_irq(power->irqs[i++]);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(axp20x_ac_power_pm_ops, axp20x_ac_power_suspend,\n\t\t\t\t\t\t axp20x_ac_power_resume);\n\nstatic int axp20x_ac_power_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct power_supply_config psy_cfg = {};\n\tstruct axp20x_ac_power *power;\n\tconst struct axp_data *axp_data;\n\tint i, irq, ret;\n\n\tif (!of_device_is_available(pdev->dev.of_node))\n\t\treturn -ENODEV;\n\n\tif (!axp20x) {\n\t\tdev_err(&pdev->dev, \"Parent drvdata not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taxp_data = of_device_get_match_data(&pdev->dev);\n\n\tpower = devm_kzalloc(&pdev->dev,\n\t\t\t     struct_size(power, irqs, axp_data->num_irq_names),\n\t\t\t     GFP_KERNEL);\n\tif (!power)\n\t\treturn -ENOMEM;\n\n\tif (axp_data->acin_adc) {\n\t\tpower->acin_v = devm_iio_channel_get(&pdev->dev, \"acin_v\");\n\t\tif (IS_ERR(power->acin_v)) {\n\t\t\tif (PTR_ERR(power->acin_v) == -ENODEV)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\treturn PTR_ERR(power->acin_v);\n\t\t}\n\n\t\tpower->acin_i = devm_iio_channel_get(&pdev->dev, \"acin_i\");\n\t\tif (IS_ERR(power->acin_i)) {\n\t\t\tif (PTR_ERR(power->acin_i) == -ENODEV)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\treturn PTR_ERR(power->acin_i);\n\t\t}\n\t}\n\n\tpower->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tpower->has_acin_path_sel = axp_data->acin_path_sel;\n\tpower->num_irqs = axp_data->num_irq_names;\n\n\tplatform_set_drvdata(pdev, power);\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = power;\n\n\tpower->supply = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t   axp_data->power_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(power->supply))\n\t\treturn PTR_ERR(power->supply);\n\n\t \n\tfor (i = 0; i < axp_data->num_irq_names; i++) {\n\t\tirq = platform_get_irq_byname(pdev, axp_data->irq_names[i]);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tpower->irqs[i] = regmap_irq_get_virq(axp20x->regmap_irqc, irq);\n\t\tret = devm_request_any_context_irq(&pdev->dev, power->irqs[i],\n\t\t\t\t\t\t   axp20x_ac_power_irq, 0,\n\t\t\t\t\t\t   DRVNAME, power);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error requesting %s IRQ: %d\\n\",\n\t\t\t\taxp_data->irq_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id axp20x_ac_power_match[] = {\n\t{\n\t\t.compatible = \"x-powers,axp202-ac-power-supply\",\n\t\t.data = &axp20x_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp221-ac-power-supply\",\n\t\t.data = &axp22x_data,\n\t}, {\n\t\t.compatible = \"x-powers,axp813-ac-power-supply\",\n\t\t.data = &axp813_data,\n\t}, {   }\n};\nMODULE_DEVICE_TABLE(of, axp20x_ac_power_match);\n\nstatic struct platform_driver axp20x_ac_power_driver = {\n\t.probe = axp20x_ac_power_probe,\n\t.driver = {\n\t\t.name\t\t= DRVNAME,\n\t\t.of_match_table\t= axp20x_ac_power_match,\n\t\t.pm\t\t= &axp20x_ac_power_pm_ops,\n\t},\n};\n\nmodule_platform_driver(axp20x_ac_power_driver);\n\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_DESCRIPTION(\"AXP20X and AXP22X PMICs' AC power supply driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}