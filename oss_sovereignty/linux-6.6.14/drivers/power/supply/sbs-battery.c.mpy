{
  "module_name": "sbs-battery.c",
  "hash_id": "9b4770a82fa4cbc9c70ec621bc50c76ed4006d3772a413139ae24a470a3e8bc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/sbs-battery.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/devm-helpers.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/of.h>\n#include <linux/power/sbs-battery.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n\nenum {\n\tREG_MANUFACTURER_DATA,\n\tREG_BATTERY_MODE,\n\tREG_TEMPERATURE,\n\tREG_VOLTAGE,\n\tREG_CURRENT_NOW,\n\tREG_CURRENT_AVG,\n\tREG_MAX_ERR,\n\tREG_CAPACITY,\n\tREG_TIME_TO_EMPTY_NOW,\n\tREG_TIME_TO_EMPTY_AVG,\n\tREG_TIME_TO_FULL_AVG,\n\tREG_STATUS,\n\tREG_CAPACITY_LEVEL,\n\tREG_CYCLE_COUNT,\n\tREG_SERIAL_NUMBER,\n\tREG_REMAINING_CAPACITY,\n\tREG_REMAINING_CAPACITY_CHARGE,\n\tREG_FULL_CHARGE_CAPACITY,\n\tREG_FULL_CHARGE_CAPACITY_CHARGE,\n\tREG_DESIGN_CAPACITY,\n\tREG_DESIGN_CAPACITY_CHARGE,\n\tREG_DESIGN_VOLTAGE_MIN,\n\tREG_DESIGN_VOLTAGE_MAX,\n\tREG_CHEMISTRY,\n\tREG_MANUFACTURER,\n\tREG_MODEL_NAME,\n\tREG_CHARGE_CURRENT,\n\tREG_CHARGE_VOLTAGE,\n};\n\n#define REG_ADDR_SPEC_INFO\t\t0x1A\n#define SPEC_INFO_VERSION_MASK\t\tGENMASK(7, 4)\n#define SPEC_INFO_VERSION_SHIFT\t\t4\n\n#define SBS_VERSION_1_0\t\t\t1\n#define SBS_VERSION_1_1\t\t\t2\n#define SBS_VERSION_1_1_WITH_PEC\t3\n\n#define REG_ADDR_MANUFACTURE_DATE\t0x1B\n\n \n#define BATTERY_MODE_OFFSET\t\t0x03\n#define BATTERY_MODE_CAPACITY_MASK\tBIT(15)\nenum sbs_capacity_mode {\n\tCAPACITY_MODE_AMPS = 0,\n\tCAPACITY_MODE_WATTS = BATTERY_MODE_CAPACITY_MASK\n};\n#define BATTERY_MODE_CHARGER_MASK\t(1<<14)\n\n \n#define MANUFACTURER_ACCESS_STATUS\t0x0006\n#define MANUFACTURER_ACCESS_SLEEP\t0x0011\n\n \n#define BATTERY_INITIALIZED\t\t0x80\n#define BATTERY_DISCHARGING\t\t0x40\n#define BATTERY_FULL_CHARGED\t\t0x20\n#define BATTERY_FULL_DISCHARGED\t\t0x10\n\n \n#define SBS_DATA(_psp, _addr, _min_value, _max_value) { \\\n\t.psp = _psp, \\\n\t.addr = _addr, \\\n\t.min_value = _min_value, \\\n\t.max_value = _max_value, \\\n}\n\nstatic const struct chip_data {\n\tenum power_supply_property psp;\n\tu8 addr;\n\tint min_value;\n\tint max_value;\n} sbs_data[] = {\n\t[REG_MANUFACTURER_DATA] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_PRESENT, 0x00, 0, 65535),\n\t[REG_BATTERY_MODE] =\n\t\tSBS_DATA(-1, 0x03, 0, 65535),\n\t[REG_TEMPERATURE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_TEMP, 0x08, 0, 65535),\n\t[REG_VOLTAGE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_VOLTAGE_NOW, 0x09, 0, 65535),\n\t[REG_CURRENT_NOW] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CURRENT_NOW, 0x0A, -32768, 32767),\n\t[REG_CURRENT_AVG] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CURRENT_AVG, 0x0B, -32768, 32767),\n\t[REG_MAX_ERR] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN, 0x0c, 0, 100),\n\t[REG_CAPACITY] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CAPACITY, 0x0D, 0, 100),\n\t[REG_REMAINING_CAPACITY] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_ENERGY_NOW, 0x0F, 0, 65535),\n\t[REG_REMAINING_CAPACITY_CHARGE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CHARGE_NOW, 0x0F, 0, 65535),\n\t[REG_FULL_CHARGE_CAPACITY] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_ENERGY_FULL, 0x10, 0, 65535),\n\t[REG_FULL_CHARGE_CAPACITY_CHARGE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CHARGE_FULL, 0x10, 0, 65535),\n\t[REG_TIME_TO_EMPTY_NOW] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW, 0x11, 0, 65535),\n\t[REG_TIME_TO_EMPTY_AVG] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG, 0x12, 0, 65535),\n\t[REG_TIME_TO_FULL_AVG] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_TIME_TO_FULL_AVG, 0x13, 0, 65535),\n\t[REG_CHARGE_CURRENT] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX, 0x14, 0, 65535),\n\t[REG_CHARGE_VOLTAGE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX, 0x15, 0, 65535),\n\t[REG_STATUS] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_STATUS, 0x16, 0, 65535),\n\t[REG_CAPACITY_LEVEL] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CAPACITY_LEVEL, 0x16, 0, 65535),\n\t[REG_CYCLE_COUNT] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CYCLE_COUNT, 0x17, 0, 65535),\n\t[REG_DESIGN_CAPACITY] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, 0x18, 0, 65535),\n\t[REG_DESIGN_CAPACITY_CHARGE] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN, 0x18, 0, 65535),\n\t[REG_DESIGN_VOLTAGE_MIN] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN, 0x19, 0, 65535),\n\t[REG_DESIGN_VOLTAGE_MAX] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN, 0x19, 0, 65535),\n\t[REG_SERIAL_NUMBER] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_SERIAL_NUMBER, 0x1C, 0, 65535),\n\t \n\t[REG_MANUFACTURER] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_MANUFACTURER, 0x20, 0, 65535),\n\t[REG_MODEL_NAME] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_MODEL_NAME, 0x21, 0, 65535),\n\t[REG_CHEMISTRY] =\n\t\tSBS_DATA(POWER_SUPPLY_PROP_TECHNOLOGY, 0x22, 0, 65535)\n};\n\nstatic const enum power_supply_property sbs_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,\n\tPOWER_SUPPLY_PROP_TIME_TO_FULL_AVG,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_YEAR,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_MONTH,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_DAY,\n\t \n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME\n};\n\n \n#define SBS_FLAGS_TI_BQ20ZX5\t\tBIT(0)\n\nstatic const enum power_supply_property string_properties[] = {\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n};\n\n#define NR_STRING_BUFFERS\tARRAY_SIZE(string_properties)\n\nstruct sbs_info {\n\tstruct i2c_client\t\t*client;\n\tstruct power_supply\t\t*power_supply;\n\tbool\t\t\t\tis_present;\n\tstruct gpio_desc\t\t*gpio_detect;\n\tbool\t\t\t\tcharger_broadcasts;\n\tint\t\t\t\tlast_state;\n\tint\t\t\t\tpoll_time;\n\tu32\t\t\t\ti2c_retry_count;\n\tu32\t\t\t\tpoll_retry_count;\n\tstruct delayed_work\t\twork;\n\tstruct mutex\t\t\tmode_lock;\n\tu32\t\t\t\tflags;\n\tint\t\t\t\ttechnology;\n\tchar\t\t\t\tstrings[NR_STRING_BUFFERS][I2C_SMBUS_BLOCK_MAX + 1];\n};\n\nstatic char *sbs_get_string_buf(struct sbs_info *chip,\n\t\t\t\tenum power_supply_property psp)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < NR_STRING_BUFFERS; i++)\n\t\tif (string_properties[i] == psp)\n\t\t\treturn chip->strings[i];\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void sbs_invalidate_cached_props(struct sbs_info *chip)\n{\n\tint i = 0;\n\n\tchip->technology = -1;\n\n\tfor (i = 0; i < NR_STRING_BUFFERS; i++)\n\t\tchip->strings[i][0] = 0;\n}\n\nstatic bool force_load;\n\nstatic int sbs_read_word_data(struct i2c_client *client, u8 address);\nstatic int sbs_write_word_data(struct i2c_client *client, u8 address, u16 value);\n\nstatic void sbs_disable_charger_broadcasts(struct sbs_info *chip)\n{\n\tint val = sbs_read_word_data(chip->client, BATTERY_MODE_OFFSET);\n\tif (val < 0)\n\t\tgoto exit;\n\n\tval |= BATTERY_MODE_CHARGER_MASK;\n\n\tval = sbs_write_word_data(chip->client, BATTERY_MODE_OFFSET, val);\n\nexit:\n\tif (val < 0)\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"Failed to disable charger broadcasting: %d\\n\", val);\n\telse\n\t\tdev_dbg(&chip->client->dev, \"%s\\n\", __func__);\n}\n\nstatic int sbs_update_presence(struct sbs_info *chip, bool is_present)\n{\n\tstruct i2c_client *client = chip->client;\n\tint retries = chip->i2c_retry_count;\n\ts32 ret = 0;\n\tu8 version;\n\n\tif (chip->is_present == is_present)\n\t\treturn 0;\n\n\tif (!is_present) {\n\t\tchip->is_present = false;\n\t\t \n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t\tsbs_invalidate_cached_props(chip);\n\t\treturn 0;\n\t}\n\n\t \n\twhile (retries > 0) {\n\t\tret = i2c_smbus_read_word_data(client, REG_ADDR_SPEC_INFO);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\n\t\t \n\t\tmsleep(100);\n\n\t\tretries--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"failed to read spec info: %d\\n\", ret);\n\n\t\t \n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t\tchip->is_present = true;\n\n\t\treturn ret;\n\t}\n\n\tversion = (ret & SPEC_INFO_VERSION_MASK) >> SPEC_INFO_VERSION_SHIFT;\n\n\tif (version == SBS_VERSION_1_1_WITH_PEC)\n\t\tclient->flags |= I2C_CLIENT_PEC;\n\telse\n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\n\tif (of_device_is_compatible(client->dev.parent->of_node, \"google,cros-ec-i2c-tunnel\")\n\t    && client->flags & I2C_CLIENT_PEC) {\n\t\tdev_info(&client->dev, \"Disabling PEC because of broken Cros-EC implementation\\n\");\n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t}\n\n\tdev_dbg(&client->dev, \"PEC: %s\\n\", (client->flags & I2C_CLIENT_PEC) ?\n\t\t\"enabled\" : \"disabled\");\n\n\tif (!chip->is_present && is_present && !chip->charger_broadcasts)\n\t\tsbs_disable_charger_broadcasts(chip);\n\n\tchip->is_present = true;\n\n\treturn 0;\n}\n\nstatic int sbs_read_word_data(struct i2c_client *client, u8 address)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\tint retries = chip->i2c_retry_count;\n\ts32 ret = 0;\n\n\twhile (retries > 0) {\n\t\tret = i2c_smbus_read_word_data(client, address);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: i2c read at address 0x%x failed\\n\",\n\t\t\t__func__, address);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sbs_read_string_data_fallback(struct i2c_client *client, u8 address, char *values)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\ts32 ret = 0, block_length = 0;\n\tint retries_length, retries_block;\n\tu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\n\n\tretries_length = chip->i2c_retry_count;\n\tretries_block = chip->i2c_retry_count;\n\n\tdev_warn_once(&client->dev, \"I2C adapter does not support I2C_FUNC_SMBUS_READ_BLOCK_DATA.\\n\"\n\t\t\t\t    \"Fallback method does not support PEC.\\n\");\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK)){\n\t\treturn -ENODEV;\n\t}\n\n\t \n\twhile (retries_length > 0) {\n\t\tret = i2c_smbus_read_byte_data(client, address);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries_length--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: i2c read at address 0x%x failed\\n\",\n\t\t\t__func__, address);\n\t\treturn ret;\n\t}\n\n\t \n\tblock_length = ret;\n\tif (block_length > I2C_SMBUS_BLOCK_MAX) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: Returned block_length is longer than 0x%x\\n\",\n\t\t\t__func__, I2C_SMBUS_BLOCK_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile (retries_block > 0) {\n\t\tret = i2c_smbus_read_i2c_block_data(\n\t\t\t\tclient, address,\n\t\t\t\tblock_length + 1, block_buffer);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries_block--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: i2c read at address 0x%x failed\\n\",\n\t\t\t__func__, address);\n\t\treturn ret;\n\t}\n\n\t \n\tmemcpy(values, block_buffer + 1, block_length);\n\tvalues[block_length] = '\\0';\n\n\treturn ret;\n}\n\nstatic int sbs_read_string_data(struct i2c_client *client, u8 address, char *values)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\tint retries = chip->i2c_retry_count;\n\tint ret = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_BLOCK_DATA)) {\n\t\tbool pec = client->flags & I2C_CLIENT_PEC;\n\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t\tret = sbs_read_string_data_fallback(client, address, values);\n\t\tif (pec)\n\t\t\tclient->flags |= I2C_CLIENT_PEC;\n\t\treturn ret;\n\t}\n\n\twhile (retries > 0) {\n\t\tret = i2c_smbus_read_block_data(client, address, values);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"failed to read block 0x%x: %d\\n\", address, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tvalues[ret] = '\\0';\n\treturn ret;\n}\n\nstatic int sbs_write_word_data(struct i2c_client *client, u8 address,\n\tu16 value)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\tint retries = chip->i2c_retry_count;\n\ts32 ret = 0;\n\n\twhile (retries > 0) {\n\t\tret = i2c_smbus_write_word_data(client, address, value);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tretries--;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: i2c write to address 0x%x failed\\n\",\n\t\t\t__func__, address);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_status_correct(struct i2c_client *client, int *intval)\n{\n\tint ret;\n\n\tret = sbs_read_word_data(client, sbs_data[REG_CURRENT_NOW].addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = (s16)ret;\n\n\t \n\tif (*intval != POWER_SUPPLY_STATUS_FULL && ret == 0)\n\t\t*intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\tif (*intval == POWER_SUPPLY_STATUS_FULL) {\n\t\t \n\t\tif (ret > 0)\n\t\t\t*intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (ret < 0)\n\t\t\t*intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\n\treturn 0;\n}\n\nstatic bool sbs_bat_needs_calibration(struct i2c_client *client)\n{\n\tint ret;\n\n\tret = sbs_read_word_data(client, sbs_data[REG_BATTERY_MODE].addr);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!(ret & BIT(7));\n}\n\nstatic int sbs_get_ti_battery_presence_and_health(\n\tstruct i2c_client *client, enum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\ts32 ret;\n\n\t \n\tret = sbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr,\n\t\t\t\t  MANUFACTURER_ACCESS_STATUS);\n\tif (ret < 0) {\n\t\tif (psp == POWER_SUPPLY_PROP_PRESENT)\n\t\t\tval->intval = 0;  \n\t\treturn ret;\n\t}\n\n\tret = sbs_read_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr);\n\tif (ret < 0) {\n\t\tif (psp == POWER_SUPPLY_PROP_PRESENT)\n\t\t\tval->intval = 0;  \n\t\treturn ret;\n\t}\n\n\tif (ret < sbs_data[REG_MANUFACTURER_DATA].min_value ||\n\t    ret > sbs_data[REG_MANUFACTURER_DATA].max_value) {\n\t\tval->intval = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tret &= 0x0F00;\n\tret >>= 8;\n\tif (psp == POWER_SUPPLY_PROP_PRESENT) {\n\t\tif (ret == 0x0F)\n\t\t\t \n\t\t\tval->intval = 0;\n\t\telse\n\t\t\tval->intval = 1;\n\t} else if (psp == POWER_SUPPLY_PROP_HEALTH) {\n\t\tif (ret == 0x09)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\telse if (ret == 0x0B)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (ret == 0x0C)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\telse if (sbs_bat_needs_calibration(client))\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_get_battery_presence_and_health(\n\tstruct i2c_client *client, enum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\tint ret;\n\n\tif (chip->flags & SBS_FLAGS_TI_BQ20ZX5)\n\t\treturn sbs_get_ti_battery_presence_and_health(client, psp, val);\n\n\t \n\tret = sbs_read_word_data(client, sbs_data[REG_STATUS].addr);\n\n\tif (ret < 0) {  \n\t\tif (psp == POWER_SUPPLY_PROP_PRESENT) {\n\t\t\tval->intval = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (psp == POWER_SUPPLY_PROP_PRESENT)\n\t\tval->intval = 1;  \n\telse {  \n\t\tif (sbs_bat_needs_calibration(client)) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED;\n\t\t} else {\n\t\t\t \n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_get_battery_property(struct i2c_client *client,\n\tint reg_offset, enum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\ts32 ret;\n\n\tret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (sbs_data[reg_offset].min_value < 0)\n\t\tret = (s16)ret;\n\n\tif (ret >= sbs_data[reg_offset].min_value &&\n\t    ret <= sbs_data[reg_offset].max_value) {\n\t\tval->intval = ret;\n\t\tif (psp == POWER_SUPPLY_PROP_CAPACITY_LEVEL) {\n\t\t\tif (!(ret & BATTERY_INITIALIZED))\n\t\t\t\tval->intval =\n\t\t\t\t\tPOWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\t\telse if (ret & BATTERY_FULL_CHARGED)\n\t\t\t\tval->intval =\n\t\t\t\t\tPOWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\t\telse if (ret & BATTERY_FULL_DISCHARGED)\n\t\t\t\tval->intval =\n\t\t\t\t\tPOWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\t\telse\n\t\t\t\tval->intval =\n\t\t\t\t\tPOWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\t\treturn 0;\n\t\t} else if (psp != POWER_SUPPLY_PROP_STATUS) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ret & BATTERY_FULL_CHARGED)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse if (ret & BATTERY_DISCHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\n\t\tsbs_status_correct(client, &val->intval);\n\n\t\tif (chip->poll_time == 0)\n\t\t\tchip->last_state = val->intval;\n\t\telse if (chip->last_state != val->intval) {\n\t\t\tcancel_delayed_work_sync(&chip->work);\n\t\t\tpower_supply_changed(chip->power_supply);\n\t\t\tchip->poll_time = 0;\n\t\t}\n\t} else {\n\t\tif (psp == POWER_SUPPLY_PROP_STATUS)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\telse if (psp == POWER_SUPPLY_PROP_CAPACITY)\n\t\t\t \n\t\t\tval->intval = min(ret, 100);\n\t\telse\n\t\t\tval->intval = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_get_property_index(struct i2c_client *client,\n\tenum power_supply_property psp)\n{\n\tint count;\n\n\tfor (count = 0; count < ARRAY_SIZE(sbs_data); count++)\n\t\tif (psp == sbs_data[count].psp)\n\t\t\treturn count;\n\n\tdev_warn(&client->dev,\n\t\t\"%s: Invalid Property - %d\\n\", __func__, psp);\n\n\treturn -EINVAL;\n}\n\nstatic const char *sbs_get_constant_string(struct sbs_info *chip,\n\t\t\tenum power_supply_property psp)\n{\n\tint ret;\n\tchar *buf;\n\tu8 addr;\n\n\tbuf = sbs_get_string_buf(chip, psp);\n\tif (IS_ERR(buf))\n\t\treturn buf;\n\n\tif (!buf[0]) {\n\t\tret = sbs_get_property_index(chip->client, psp);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\taddr = sbs_data[ret].addr;\n\n\t\tret = sbs_read_string_data(chip->client, addr, buf);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn buf;\n}\n\nstatic void  sbs_unit_adjustment(struct i2c_client *client,\n\tenum power_supply_property psp, union power_supply_propval *val)\n{\n#define BASE_UNIT_CONVERSION\t\t1000\n#define BATTERY_MODE_CAP_MULT_WATT\t(10 * BASE_UNIT_CONVERSION)\n#define TIME_UNIT_CONVERSION\t\t60\n#define TEMP_KELVIN_TO_CELSIUS\t\t2731\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\t \n\t\tval->intval *= BATTERY_MODE_CAP_MULT_WATT;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval *= BASE_UNIT_CONVERSION;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\t \n\t\tval->intval -= TEMP_KELVIN_TO_CELSIUS;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\tcase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\n\t\t \n\t\tval->intval *= TIME_UNIT_CONVERSION;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: no need for unit conversion %d\\n\", __func__, psp);\n\t}\n}\n\nstatic enum sbs_capacity_mode sbs_set_capacity_mode(struct i2c_client *client,\n\tenum sbs_capacity_mode mode)\n{\n\tint ret, original_val;\n\n\toriginal_val = sbs_read_word_data(client, BATTERY_MODE_OFFSET);\n\tif (original_val < 0)\n\t\treturn original_val;\n\n\tif ((original_val & BATTERY_MODE_CAPACITY_MASK) == mode)\n\t\treturn mode;\n\n\tif (mode == CAPACITY_MODE_AMPS)\n\t\tret = original_val & ~BATTERY_MODE_CAPACITY_MASK;\n\telse\n\t\tret = original_val | BATTERY_MODE_CAPACITY_MASK;\n\n\tret = sbs_write_word_data(client, BATTERY_MODE_OFFSET, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\n\treturn original_val & BATTERY_MODE_CAPACITY_MASK;\n}\n\nstatic int sbs_get_battery_capacity(struct i2c_client *client,\n\tint reg_offset, enum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\ts32 ret;\n\tenum sbs_capacity_mode mode = CAPACITY_MODE_WATTS;\n\n\tif (power_supply_is_amp_property(psp))\n\t\tmode = CAPACITY_MODE_AMPS;\n\n\tmode = sbs_set_capacity_mode(client, mode);\n\tif ((int)mode < 0)\n\t\treturn mode;\n\n\tret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = ret;\n\n\tret = sbs_set_capacity_mode(client, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic char sbs_serial[5];\nstatic int sbs_get_battery_serial_number(struct i2c_client *client,\n\tunion power_supply_propval *val)\n{\n\tint ret;\n\n\tret = sbs_read_word_data(client, sbs_data[REG_SERIAL_NUMBER].addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsprintf(sbs_serial, \"%04x\", ret);\n\tval->strval = sbs_serial;\n\n\treturn 0;\n}\n\nstatic int sbs_get_chemistry(struct sbs_info *chip,\n\t\tunion power_supply_propval *val)\n{\n\tconst char *chemistry;\n\n\tif (chip->technology != -1) {\n\t\tval->intval = chip->technology;\n\t\treturn 0;\n\t}\n\n\tchemistry = sbs_get_constant_string(chip, POWER_SUPPLY_PROP_TECHNOLOGY);\n\n\tif (IS_ERR(chemistry))\n\t\treturn PTR_ERR(chemistry);\n\n\tif (!strncasecmp(chemistry, \"LION\", 4))\n\t\tchip->technology = POWER_SUPPLY_TECHNOLOGY_LION;\n\telse if (!strncasecmp(chemistry, \"LiP\", 3))\n\t\tchip->technology = POWER_SUPPLY_TECHNOLOGY_LIPO;\n\telse if (!strncasecmp(chemistry, \"NiCd\", 4))\n\t\tchip->technology = POWER_SUPPLY_TECHNOLOGY_NiCd;\n\telse if (!strncasecmp(chemistry, \"NiMH\", 4))\n\t\tchip->technology = POWER_SUPPLY_TECHNOLOGY_NiMH;\n\telse\n\t\tchip->technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\n\tif (chip->technology == POWER_SUPPLY_TECHNOLOGY_UNKNOWN)\n\t\tdev_warn(&chip->client->dev, \"Unknown chemistry: %s\\n\", chemistry);\n\n\tval->intval = chip->technology;\n\n\treturn 0;\n}\n\nstatic int sbs_get_battery_manufacture_date(struct i2c_client *client,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tint ret;\n\tu16 day, month, year;\n\n\tret = sbs_read_word_data(client, REG_ADDR_MANUFACTURE_DATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tday   = ret   & GENMASK(4,  0);\n\tmonth = (ret  & GENMASK(8,  5)) >> 5;\n\tyear  = ((ret & GENMASK(15, 9)) >> 9) + 1980;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_YEAR:\n\t\tval->intval = year;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_MONTH:\n\t\tval->intval = month;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_DAY:\n\t\tval->intval = day;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tint ret = 0;\n\tstruct sbs_info *chip = power_supply_get_drvdata(psy);\n\tstruct i2c_client *client = chip->client;\n\tconst char *str;\n\n\tif (chip->gpio_detect) {\n\t\tret = gpiod_get_value_cansleep(chip->gpio_detect);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (psp == POWER_SUPPLY_PROP_PRESENT) {\n\t\t\tval->intval = ret;\n\t\t\tsbs_update_presence(chip, ret);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ret == 0)\n\t\t\treturn -ENODATA;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = sbs_get_battery_presence_and_health(client, psp, val);\n\n\t\t \n\t\tif (psp == POWER_SUPPLY_PROP_PRESENT)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tret = sbs_get_chemistry(chip, val);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tgoto done;  \n\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tret = sbs_get_property_index(client, psp);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tmutex_lock(&chip->mode_lock);\n\t\tret = sbs_get_battery_capacity(client, ret, psp, val);\n\t\tmutex_unlock(&chip->mode_lock);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tret = sbs_get_battery_serial_number(client, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\tcase POWER_SUPPLY_PROP_TEMP:\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\tcase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\tcase POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN:\n\t\tret = sbs_get_property_index(client, psp);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = sbs_get_battery_property(client, ret, psp, val);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tstr = sbs_get_constant_string(chip, psp);\n\t\tif (IS_ERR(str))\n\t\t\tret = PTR_ERR(str);\n\t\telse\n\t\t\tval->strval = str;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_YEAR:\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_MONTH:\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_DAY:\n\t\tret = sbs_get_battery_manufacture_date(client, psp, val);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: INVALID property\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!chip->gpio_detect && chip->is_present != (ret >= 0)) {\n\t\tbool old_present = chip->is_present;\n\t\tunion power_supply_propval val;\n\t\tint err = sbs_get_battery_presence_and_health(\n\t\t\t\tclient, POWER_SUPPLY_PROP_PRESENT, &val);\n\n\t\tsbs_update_presence(chip, !err && val.intval);\n\n\t\tif (old_present != chip->is_present)\n\t\t\tpower_supply_changed(chip->power_supply);\n\t}\n\ndone:\n\tif (!ret) {\n\t\t \n\t\tsbs_unit_adjustment(client, psp, val);\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s: property = %d, value = %x\\n\", __func__,\n\t\t\tpsp, val->intval);\n\t} else if (!chip->is_present)  {\n\t\t \n\t\tret = -ENODATA;\n\t}\n\treturn ret;\n}\n\nstatic void sbs_supply_changed(struct sbs_info *chip)\n{\n\tstruct power_supply *battery = chip->power_supply;\n\tint ret;\n\n\tret = gpiod_get_value_cansleep(chip->gpio_detect);\n\tif (ret < 0)\n\t\treturn;\n\tsbs_update_presence(chip, ret);\n\tpower_supply_changed(battery);\n}\n\nstatic irqreturn_t sbs_irq(int irq, void *devid)\n{\n\tsbs_supply_changed(devid);\n\treturn IRQ_HANDLED;\n}\n\nstatic void sbs_alert(struct i2c_client *client, enum i2c_alert_protocol prot,\n\tunsigned int data)\n{\n\tsbs_supply_changed(i2c_get_clientdata(client));\n}\n\nstatic void sbs_external_power_changed(struct power_supply *psy)\n{\n\tstruct sbs_info *chip = power_supply_get_drvdata(psy);\n\n\t \n\tcancel_delayed_work_sync(&chip->work);\n\n\tschedule_delayed_work(&chip->work, HZ);\n\tchip->poll_time = chip->poll_retry_count;\n}\n\nstatic void sbs_delayed_work(struct work_struct *work)\n{\n\tstruct sbs_info *chip;\n\ts32 ret;\n\n\tchip = container_of(work, struct sbs_info, work.work);\n\n\tret = sbs_read_word_data(chip->client, sbs_data[REG_STATUS].addr);\n\t \n\tif (ret < 0) {\n\t\tchip->poll_time = 0;\n\t\treturn;\n\t}\n\n\tif (ret & BATTERY_FULL_CHARGED)\n\t\tret = POWER_SUPPLY_STATUS_FULL;\n\telse if (ret & BATTERY_DISCHARGING)\n\t\tret = POWER_SUPPLY_STATUS_DISCHARGING;\n\telse\n\t\tret = POWER_SUPPLY_STATUS_CHARGING;\n\n\tsbs_status_correct(chip->client, &ret);\n\n\tif (chip->last_state != ret) {\n\t\tchip->poll_time = 0;\n\t\tpower_supply_changed(chip->power_supply);\n\t\treturn;\n\t}\n\tif (chip->poll_time > 0) {\n\t\tschedule_delayed_work(&chip->work, HZ);\n\t\tchip->poll_time--;\n\t\treturn;\n\t}\n}\n\nstatic const struct power_supply_desc sbs_default_desc = {\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = sbs_properties,\n\t.num_properties = ARRAY_SIZE(sbs_properties),\n\t.get_property = sbs_get_property,\n\t.external_power_changed = sbs_external_power_changed,\n};\n\nstatic int sbs_probe(struct i2c_client *client)\n{\n\tstruct sbs_info *chip;\n\tstruct power_supply_desc *sbs_desc;\n\tstruct sbs_platform_data *pdata = client->dev.platform_data;\n\tstruct power_supply_config psy_cfg = {};\n\tint rc;\n\tint irq;\n\n\tsbs_desc = devm_kmemdup(&client->dev, &sbs_default_desc,\n\t\t\tsizeof(*sbs_desc), GFP_KERNEL);\n\tif (!sbs_desc)\n\t\treturn -ENOMEM;\n\n\tsbs_desc->name = devm_kasprintf(&client->dev, GFP_KERNEL, \"sbs-%s\",\n\t\t\tdev_name(&client->dev));\n\tif (!sbs_desc->name)\n\t\treturn -ENOMEM;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(struct sbs_info), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->flags = (u32)(uintptr_t)device_get_match_data(&client->dev);\n\tchip->client = client;\n\tpsy_cfg.of_node = client->dev.of_node;\n\tpsy_cfg.drv_data = chip;\n\tchip->last_state = POWER_SUPPLY_STATUS_UNKNOWN;\n\tsbs_invalidate_cached_props(chip);\n\tmutex_init(&chip->mode_lock);\n\n\t \n\trc = device_property_read_u32(&client->dev, \"sbs,i2c-retry-count\",\n\t\t\t\t      &chip->i2c_retry_count);\n\tif (rc)\n\t\tchip->i2c_retry_count = 0;\n\n\trc = device_property_read_u32(&client->dev, \"sbs,poll-retry-count\",\n\t\t\t\t      &chip->poll_retry_count);\n\tif (rc)\n\t\tchip->poll_retry_count = 0;\n\n\tif (pdata) {\n\t\tchip->poll_retry_count = pdata->poll_retry_count;\n\t\tchip->i2c_retry_count  = pdata->i2c_retry_count;\n\t}\n\tchip->i2c_retry_count = chip->i2c_retry_count + 1;\n\n\tchip->charger_broadcasts = !device_property_read_bool(&client->dev,\n\t\t\t\t\t\"sbs,disable-charger-broadcasts\");\n\n\tchip->gpio_detect = devm_gpiod_get_optional(&client->dev,\n\t\t\t\"sbs,battery-detect\", GPIOD_IN);\n\tif (IS_ERR(chip->gpio_detect))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(chip->gpio_detect),\n\t\t\t\t     \"Failed to get gpio\\n\");\n\n\ti2c_set_clientdata(client, chip);\n\n\tif (!chip->gpio_detect)\n\t\tgoto skip_gpio;\n\n\tirq = gpiod_to_irq(chip->gpio_detect);\n\tif (irq <= 0) {\n\t\tdev_warn(&client->dev, \"Failed to get gpio as irq: %d\\n\", irq);\n\t\tgoto skip_gpio;\n\t}\n\n\trc = devm_request_threaded_irq(&client->dev, irq, NULL, sbs_irq,\n\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\tdev_name(&client->dev), chip);\n\tif (rc) {\n\t\tdev_warn(&client->dev, \"Failed to request irq: %d\\n\", rc);\n\t\tgoto skip_gpio;\n\t}\n\nskip_gpio:\n\t \n\tif (!(force_load || chip->gpio_detect)) {\n\t\tunion power_supply_propval val;\n\n\t\trc = sbs_get_battery_presence_and_health(\n\t\t\t\tclient, POWER_SUPPLY_PROP_PRESENT, &val);\n\t\tif (rc < 0 || !val.intval)\n\t\t\treturn dev_err_probe(&client->dev, -ENODEV,\n\t\t\t\t\t     \"Failed to get present status\\n\");\n\t}\n\n\trc = devm_delayed_work_autocancel(&client->dev, &chip->work,\n\t\t\t\t\t  sbs_delayed_work);\n\tif (rc)\n\t\treturn rc;\n\n\tchip->power_supply = devm_power_supply_register(&client->dev, sbs_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(chip->power_supply))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(chip->power_supply),\n\t\t\t\t     \"Failed to register power supply\\n\");\n\n\tdev_info(&client->dev,\n\t\t\"%s: battery gas gauge device registered\\n\", client->name);\n\n\treturn 0;\n}\n\n#if defined CONFIG_PM_SLEEP\n\nstatic int sbs_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct sbs_info *chip = i2c_get_clientdata(client);\n\tint ret;\n\n\tif (chip->poll_time > 0)\n\t\tcancel_delayed_work_sync(&chip->work);\n\n\tif (chip->flags & SBS_FLAGS_TI_BQ20ZX5) {\n\t\t \n\t\tret = sbs_write_word_data(client,\n\t\t\t\t\t  sbs_data[REG_MANUFACTURER_DATA].addr,\n\t\t\t\t\t  MANUFACTURER_ACCESS_SLEEP);\n\t\tif (chip->is_present && ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sbs_pm_ops, sbs_suspend, NULL);\n#define SBS_PM_OPS (&sbs_pm_ops)\n\n#else\n#define SBS_PM_OPS NULL\n#endif\n\nstatic const struct i2c_device_id sbs_id[] = {\n\t{ \"bq20z65\", 0 },\n\t{ \"bq20z75\", 0 },\n\t{ \"sbs-battery\", 1 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, sbs_id);\n\nstatic const struct of_device_id sbs_dt_ids[] = {\n\t{ .compatible = \"sbs,sbs-battery\" },\n\t{\n\t\t.compatible = \"ti,bq20z65\",\n\t\t.data = (void *)SBS_FLAGS_TI_BQ20ZX5,\n\t},\n\t{\n\t\t.compatible = \"ti,bq20z75\",\n\t\t.data = (void *)SBS_FLAGS_TI_BQ20ZX5,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sbs_dt_ids);\n\nstatic struct i2c_driver sbs_battery_driver = {\n\t.probe\t\t= sbs_probe,\n\t.alert\t\t= sbs_alert,\n\t.id_table\t= sbs_id,\n\t.driver = {\n\t\t.name\t= \"sbs-battery\",\n\t\t.of_match_table = sbs_dt_ids,\n\t\t.pm\t= SBS_PM_OPS,\n\t},\n};\nmodule_i2c_driver(sbs_battery_driver);\n\nMODULE_DESCRIPTION(\"SBS battery monitor driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(force_load, bool, 0444);\nMODULE_PARM_DESC(force_load,\n\t\t \"Attempt to load the driver even if no battery is connected\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}