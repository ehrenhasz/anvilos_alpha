{
  "module_name": "rt9467-charger.c",
  "hash_id": "f72b821caf12f773e90981d060f44a2ed1cdc6dc34d10536a56fd2dc22229c85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/rt9467-charger.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/linear_range.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/units.h>\n#include <linux/sysfs.h>\n\n#define RT9467_REG_CORE_CTRL0\t\t0x00\n#define RT9467_REG_CHG_CTRL1\t\t0x01\n#define RT9467_REG_CHG_CTRL2\t\t0x02\n#define RT9467_REG_CHG_CTRL3\t\t0x03\n#define RT9467_REG_CHG_CTRL4\t\t0x04\n#define RT9467_REG_CHG_CTRL5\t\t0x05\n#define RT9467_REG_CHG_CTRL6\t\t0x06\n#define RT9467_REG_CHG_CTRL7\t\t0x07\n#define RT9467_REG_CHG_CTRL8\t\t0x08\n#define RT9467_REG_CHG_CTRL9\t\t0x09\n#define RT9467_REG_CHG_CTRL10\t\t0x0A\n#define RT9467_REG_CHG_CTRL12\t\t0x0C\n#define RT9467_REG_CHG_CTRL13\t\t0x0D\n#define RT9467_REG_CHG_CTRL14\t\t0x0E\n#define RT9467_REG_CHG_ADC\t\t0x11\n#define RT9467_REG_CHG_DPDM1\t\t0x12\n#define RT9467_REG_CHG_DPDM2\t\t0x13\n#define RT9467_REG_DEVICE_ID\t\t0x40\n#define RT9467_REG_CHG_STAT\t\t0x42\n#define RT9467_REG_ADC_DATA_H\t\t0x44\n#define RT9467_REG_CHG_STATC\t\t0x50\n#define RT9467_REG_CHG_IRQ1\t\t0x53\n#define RT9467_REG_CHG_STATC_CTRL\t0x60\n#define RT9467_REG_CHG_IRQ1_CTRL\t0x63\n\n#define RT9467_MASK_PWR_RDY\t\tBIT(7)\n#define RT9467_MASK_MIVR_STAT\t\tBIT(6)\n#define RT9467_MASK_OTG_CSEL\t\tGENMASK(2, 0)\n#define RT9467_MASK_OTG_VSEL\t\tGENMASK(7, 2)\n#define RT9467_MASK_OTG_EN\t\tBIT(0)\n#define RT9467_MASK_ADC_IN_SEL\t\tGENMASK(7, 4)\n#define RT9467_MASK_ADC_START\t\tBIT(0)\n\n#define RT9467_NUM_IRQ_REGS\t\t4\n#define RT9467_ICHG_MIN_uA\t\t100000\n#define RT9467_ICHG_MAX_uA\t\t5000000\n#define RT9467_CV_MAX_uV\t\t4710000\n#define RT9467_OTG_MIN_uV\t\t4425000\n#define RT9467_OTG_MAX_uV\t\t5825000\n#define RT9467_OTG_STEP_uV\t\t25000\n#define RT9467_NUM_VOTG\t\t\t(RT9467_OTG_MAX_uV - RT9467_OTG_MIN_uV + 1)\n#define RT9467_AICLVTH_GAP_uV\t\t200000\n#define RT9467_ADCCONV_TIME_MS\t\t35\n\n#define RT9466_VID\t\t\t0x8\n#define RT9467_VID\t\t\t0x9\n\n \n#define RT9467_IRQ_TS_STATC\t0\n#define RT9467_IRQ_CHG_FAULT\t1\n#define RT9467_IRQ_CHG_STATC\t2\n#define RT9467_IRQ_CHG_TMR\t3\n#define RT9467_IRQ_CHG_BATABS\t4\n#define RT9467_IRQ_CHG_ADPBAD\t5\n#define RT9467_IRQ_CHG_RVP\t6\n#define RT9467_IRQ_OTP\t\t7\n\n#define RT9467_IRQ_CHG_AICLM\t8\n#define RT9467_IRQ_CHG_ICHGM\t9\n#define RT9467_IRQ_WDTMR\t11\n#define RT9467_IRQ_SSFINISH\t12\n#define RT9467_IRQ_CHG_RECHG\t13\n#define RT9467_IRQ_CHG_TERM\t14\n#define RT9467_IRQ_CHG_IEOC\t15\n\n#define RT9467_IRQ_ADC_DONE\t16\n#define RT9467_IRQ_PUMPX_DONE\t17\n#define RT9467_IRQ_BST_BATUV\t21\n#define RT9467_IRQ_BST_MIDOV\t22\n#define RT9467_IRQ_BST_OLP\t23\n\n#define RT9467_IRQ_ATTACH\t24\n#define RT9467_IRQ_DETACH\t25\n#define RT9467_IRQ_HVDCP_DET\t29\n#define RT9467_IRQ_CHGDET\t30\n#define RT9467_IRQ_DCDT\t\t31\n\nenum rt9467_fields {\n\t \n\tF_RST = 0,\n\t \n\tF_HZ, F_OTG_PIN_EN, F_OPA_MODE,\n\t \n\tF_SHIP_MODE, F_TE, F_IINLMTSEL, F_CFO_EN, F_CHG_EN,\n\t \n\tF_IAICR, F_ILIM_EN,\n\t \n\tF_VOREG,\n\t \n\tF_VMIVR,\n\t \n\tF_ICHG,\n\t \n\tF_IPREC,\n\t \n\tF_IEOC,\n\t \n\tF_WT_FC,\n\t \n\tF_OCP,\n\t \n\tF_AICL_MEAS, F_AICL_VTH,\n\t \n\tF_USBCHGEN,\n\t \n\tF_USB_STATUS,\n\t \n\tF_VENDOR,\n\t \n\tF_CHG_STAT,\n\t \n\tF_PWR_RDY, F_CHG_MIVR,\n\tF_MAX_FIELDS\n};\n\nstatic const struct regmap_irq rt9467_irqs[] = {\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_TS_STATC, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_FAULT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_STATC, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_TMR, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_BATABS, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_ADPBAD, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_RVP, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_OTP, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_AICLM, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_ICHGM, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_WDTMR, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_SSFINISH, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_RECHG, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_TERM, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHG_IEOC, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_ADC_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_PUMPX_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_BST_BATUV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_BST_MIDOV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_BST_OLP, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_ATTACH, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_DETACH, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_HVDCP_DET, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_CHGDET, 8),\n\tREGMAP_IRQ_REG_LINE(RT9467_IRQ_DCDT, 8)\n};\n\nstatic const struct regmap_irq_chip rt9467_irq_chip = {\n\t.name = \"rt9467-irqs\",\n\t.status_base = RT9467_REG_CHG_IRQ1,\n\t.mask_base = RT9467_REG_CHG_IRQ1_CTRL,\n\t.num_regs = RT9467_NUM_IRQ_REGS,\n\t.irqs = rt9467_irqs,\n\t.num_irqs = ARRAY_SIZE(rt9467_irqs),\n};\n\nenum rt9467_ranges {\n\tRT9467_RANGE_IAICR = 0,\n\tRT9467_RANGE_VOREG,\n\tRT9467_RANGE_VMIVR,\n\tRT9467_RANGE_ICHG,\n\tRT9467_RANGE_IPREC,\n\tRT9467_RANGE_IEOC,\n\tRT9467_RANGE_AICL_VTH,\n\tRT9467_RANGES_MAX\n};\n\nstatic const struct linear_range rt9467_ranges[RT9467_RANGES_MAX] = {\n\tLINEAR_RANGE_IDX(RT9467_RANGE_IAICR, 100000, 0x0, 0x3F, 50000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_VOREG, 3900000, 0x0, 0x51, 10000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_VMIVR, 3900000, 0x0, 0x5F, 100000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_ICHG, 900000, 0x08, 0x31, 100000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_IPREC, 100000, 0x0, 0x0F, 50000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_IEOC, 100000, 0x0, 0x0F, 50000),\n\tLINEAR_RANGE_IDX(RT9467_RANGE_AICL_VTH, 4100000, 0x0, 0x7, 100000),\n};\n\nstatic const struct reg_field rt9467_chg_fields[] = {\n\t[F_RST]\t\t\t= REG_FIELD(RT9467_REG_CORE_CTRL0, 7, 7),\n\t[F_HZ]\t\t\t= REG_FIELD(RT9467_REG_CHG_CTRL1, 2, 2),\n\t[F_OTG_PIN_EN]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL1, 1, 1),\n\t[F_OPA_MODE]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL1, 0, 0),\n\t[F_SHIP_MODE]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL2, 7, 7),\n\t[F_TE]\t\t\t= REG_FIELD(RT9467_REG_CHG_CTRL2, 4, 4),\n\t[F_IINLMTSEL]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL2, 2, 3),\n\t[F_CFO_EN]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL2, 1, 1),\n\t[F_CHG_EN]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL2, 0, 0),\n\t[F_IAICR]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL3, 2, 7),\n\t[F_ILIM_EN]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL3, 0, 0),\n\t[F_VOREG]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL4, 1, 7),\n\t[F_VMIVR]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL6, 1, 7),\n\t[F_ICHG]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL7, 2, 7),\n\t[F_IPREC]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL8, 0, 3),\n\t[F_IEOC]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL9, 4, 7),\n\t[F_WT_FC]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL12, 5, 7),\n\t[F_OCP]\t\t\t= REG_FIELD(RT9467_REG_CHG_CTRL13, 2, 2),\n\t[F_AICL_MEAS]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL14, 7, 7),\n\t[F_AICL_VTH]\t\t= REG_FIELD(RT9467_REG_CHG_CTRL14, 0, 2),\n\t[F_USBCHGEN]\t\t= REG_FIELD(RT9467_REG_CHG_DPDM1, 7, 7),\n\t[F_USB_STATUS]\t\t= REG_FIELD(RT9467_REG_CHG_DPDM2, 0, 2),\n\t[F_VENDOR]\t\t= REG_FIELD(RT9467_REG_DEVICE_ID, 4, 7),\n\t[F_CHG_STAT]\t\t= REG_FIELD(RT9467_REG_CHG_STAT, 6, 7),\n\t[F_PWR_RDY]\t\t= REG_FIELD(RT9467_REG_CHG_STATC, 7, 7),\n\t[F_CHG_MIVR]\t\t= REG_FIELD(RT9467_REG_CHG_STATC, 6, 6),\n};\n\nenum {\n\tRT9467_STAT_READY = 0,\n\tRT9467_STAT_PROGRESS,\n\tRT9467_STAT_CHARGE_DONE,\n\tRT9467_STAT_FAULT\n};\n\nenum rt9467_adc_chan {\n\tRT9467_ADC_VBUS_DIV5 = 0,\n\tRT9467_ADC_VBUS_DIV2,\n\tRT9467_ADC_VSYS,\n\tRT9467_ADC_VBAT,\n\tRT9467_ADC_TS_BAT,\n\tRT9467_ADC_IBUS,\n\tRT9467_ADC_IBAT,\n\tRT9467_ADC_REGN,\n\tRT9467_ADC_TEMP_JC\n};\n\nenum rt9467_chg_type {\n\tRT9467_CHG_TYPE_NOVBUS = 0,\n\tRT9467_CHG_TYPE_UNDER_GOING,\n\tRT9467_CHG_TYPE_SDP,\n\tRT9467_CHG_TYPE_SDPNSTD,\n\tRT9467_CHG_TYPE_DCP,\n\tRT9467_CHG_TYPE_CDP,\n\tRT9467_CHG_TYPE_MAX\n};\n\nenum rt9467_iin_limit_sel {\n\tRT9467_IINLMTSEL_3_2A = 0,\n\tRT9467_IINLMTSEL_CHG_TYP,\n\tRT9467_IINLMTSEL_AICR,\n\tRT9467_IINLMTSEL_LOWER_LEVEL,  \n};\n\nstruct rt9467_chg_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *rm_field[F_MAX_FIELDS];\n\tstruct regmap_irq_chip_data *irq_chip_data;\n\tstruct power_supply *psy;\n\tstruct mutex adc_lock;\n\tstruct mutex attach_lock;\n\tstruct mutex ichg_ieoc_lock;\n\tstruct regulator_dev *rdev;\n\tstruct completion aicl_done;\n\tenum power_supply_usb_type psy_usb_type;\n\tunsigned int old_stat;\n\tunsigned int vid;\n\tint ichg_ua;\n\tint ieoc_ua;\n};\n\nstatic int rt9467_otg_of_parse_cb(struct device_node *of,\n\t\t\t\t  const struct regulator_desc *desc,\n\t\t\t\t  struct regulator_config *cfg)\n{\n\tstruct rt9467_chg_data *data = cfg->driver_data;\n\n\tcfg->ena_gpiod = fwnode_gpiod_get_index(of_fwnode_handle(of),\n\t\t\t\t\t\t\"enable\", 0, GPIOD_OUT_LOW |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\t\t\tdesc->name);\n\tif (IS_ERR(cfg->ena_gpiod)) {\n\t\tcfg->ena_gpiod = NULL;\n\t\treturn 0;\n\t}\n\n\treturn regmap_field_write(data->rm_field[F_OTG_PIN_EN], 1);\n}\n\nstatic const struct regulator_ops rt9467_otg_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n};\n\nstatic const u32 rt9467_otg_microamp[] = {\n\t500000, 700000, 1100000, 1300000, 1800000, 2100000, 2400000, 3000000\n};\n\nstatic const struct regulator_desc rt9467_otg_desc = {\n\t.name = \"rt9476-usb-otg-vbus\",\n\t.of_match = \"usb-otg-vbus-regulator\",\n\t.of_parse_cb = rt9467_otg_of_parse_cb,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.min_uV = RT9467_OTG_MIN_uV,\n\t.uV_step = RT9467_OTG_STEP_uV,\n\t.n_voltages = RT9467_NUM_VOTG,\n\t.curr_table = rt9467_otg_microamp,\n\t.n_current_limits = ARRAY_SIZE(rt9467_otg_microamp),\n\t.csel_reg = RT9467_REG_CHG_CTRL10,\n\t.csel_mask = RT9467_MASK_OTG_CSEL,\n\t.vsel_reg = RT9467_REG_CHG_CTRL5,\n\t.vsel_mask = RT9467_MASK_OTG_VSEL,\n\t.enable_reg = RT9467_REG_CHG_CTRL1,\n\t.enable_mask = RT9467_MASK_OTG_EN,\n\t.ops = &rt9467_otg_regulator_ops,\n};\n\nstatic int rt9467_register_otg_regulator(struct rt9467_chg_data *data)\n{\n\tstruct regulator_config cfg = {\n\t\t.dev = data->dev,\n\t\t.regmap = data->regmap,\n\t\t.driver_data = data,\n\t};\n\n\tdata->rdev = devm_regulator_register(data->dev, &rt9467_otg_desc, &cfg);\n\treturn PTR_ERR_OR_ZERO(data->rdev);\n}\n\nstatic int rt9467_get_value_from_ranges(struct rt9467_chg_data *data,\n\t\t\t\t\tenum rt9467_fields field,\n\t\t\t\t\tenum rt9467_ranges rsel,\n\t\t\t\t\tint *value)\n{\n\tconst struct linear_range *range = rt9467_ranges + rsel;\n\tunsigned int sel;\n\tint ret;\n\n\tret = regmap_field_read(data->rm_field[field], &sel);\n\tif (ret)\n\t\treturn ret;\n\n\treturn linear_range_get_value(range, sel, value);\n}\n\nstatic int rt9467_set_value_from_ranges(struct rt9467_chg_data *data,\n\t\t\t\t\tenum rt9467_fields field,\n\t\t\t\t\tenum rt9467_ranges rsel,\n\t\t\t\t\tint value)\n{\n\tconst struct linear_range *range = rt9467_ranges + rsel;\n\tunsigned int sel;\n\tbool found;\n\tint ret;\n\n\tif (rsel == RT9467_RANGE_VMIVR) {\n\t\tret = linear_range_get_selector_high(range, value, &sel, &found);\n\t\tif (ret)\n\t\t\tvalue = range->max_sel;\n\t} else {\n\t\tlinear_range_get_selector_within(range, value, &sel);\n\t}\n\n\treturn regmap_field_write(data->rm_field[field], sel);\n}\n\nstatic int rt9467_get_adc_sel(enum rt9467_adc_chan chan, int *sel)\n{\n\tswitch (chan) {\n\tcase RT9467_ADC_VBUS_DIV5:\n\tcase RT9467_ADC_VBUS_DIV2:\n\tcase RT9467_ADC_VSYS:\n\tcase RT9467_ADC_VBAT:\n\t\t*sel = chan + 1;\n\t\treturn 0;\n\tcase RT9467_ADC_TS_BAT:\n\t\t*sel = chan + 2;\n\t\treturn 0;\n\tcase RT9467_ADC_IBUS:\n\tcase RT9467_ADC_IBAT:\n\t\t*sel = chan + 3;\n\t\treturn 0;\n\tcase RT9467_ADC_REGN:\n\tcase RT9467_ADC_TEMP_JC:\n\t\t*sel = chan + 4;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rt9467_get_adc_raw_data(struct rt9467_chg_data *data,\n\t\t\t\t   enum rt9467_adc_chan chan, int *val)\n{\n\tunsigned int adc_stat, reg_val, adc_sel;\n\t__be16 chan_raw_data;\n\tint ret;\n\n\tmutex_lock(&data->adc_lock);\n\n\tret = rt9467_get_adc_sel(chan, &adc_sel);\n\tif (ret)\n\t\tgoto adc_unlock;\n\n\tret = regmap_write(data->regmap, RT9467_REG_CHG_ADC, 0);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to clear ADC enable\\n\");\n\t\tgoto adc_unlock;\n\t}\n\n\treg_val = RT9467_MASK_ADC_START | FIELD_PREP(RT9467_MASK_ADC_IN_SEL, adc_sel);\n\tret = regmap_write(data->regmap, RT9467_REG_CHG_ADC, reg_val);\n\tif (ret)\n\t\tgoto adc_unlock;\n\n\t \n\tmsleep(RT9467_ADCCONV_TIME_MS);\n\n\tret = regmap_read_poll_timeout(data->regmap, RT9467_REG_CHG_ADC,\n\t\t\t\t       adc_stat,\n\t\t\t\t       !(adc_stat & RT9467_MASK_ADC_START),\n\t\t\t\t       MILLI, RT9467_ADCCONV_TIME_MS * MILLI);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to wait ADC conversion, chan = %d\\n\", chan);\n\t\tgoto adc_unlock;\n\t}\n\n\tret = regmap_raw_read(data->regmap, RT9467_REG_ADC_DATA_H,\n\t\t\t      &chan_raw_data, sizeof(chan_raw_data));\n\tif (ret)\n\t\tgoto adc_unlock;\n\n\t*val = be16_to_cpu(chan_raw_data);\n\nadc_unlock:\n\tmutex_unlock(&data->adc_lock);\n\treturn ret;\n}\n\nstatic int rt9467_get_adc(struct rt9467_chg_data *data,\n\t\t\t  enum rt9467_adc_chan chan, int *val)\n{\n\tunsigned int aicr_ua, ichg_ua;\n\tint ret;\n\n\tret = rt9467_get_adc_raw_data(data, chan, val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (chan) {\n\tcase RT9467_ADC_VBUS_DIV5:\n\t\t*val *= 25000;\n\t\treturn 0;\n\tcase RT9467_ADC_VBUS_DIV2:\n\t\t*val *= 10000;\n\t\treturn 0;\n\tcase RT9467_ADC_VBAT:\n\tcase RT9467_ADC_VSYS:\n\tcase RT9467_ADC_REGN:\n\t\t*val *= 5000;\n\t\treturn 0;\n\tcase RT9467_ADC_TS_BAT:\n\t\t*val /= 400;\n\t\treturn 0;\n\tcase RT9467_ADC_IBUS:\n\t\t \n\t\tret = rt9467_get_value_from_ranges(data, F_IAICR,\n\t\t\t\t\t\t   RT9467_RANGE_IAICR, &aicr_ua);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val *= aicr_ua < 400000 ? 29480 : 50000;\n\t\treturn 0;\n\tcase RT9467_ADC_IBAT:\n\t\t \n\t\tret = rt9467_get_value_from_ranges(data, F_ICHG,\n\t\t\t\t\t\t   RT9467_RANGE_ICHG, &ichg_ua);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val *= ichg_ua <= 400000 ? 28500 :\n\t\t\tichg_ua <= 800000 ? 31500 : 500000;\n\t\treturn 0;\n\tcase RT9467_ADC_TEMP_JC:\n\t\t*val = ((*val * 2) - 40) * 10;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rt9467_psy_get_status(struct rt9467_chg_data *data, int *state)\n{\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_field_read(data->rm_field[F_CHG_STAT], &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status) {\n\tcase RT9467_STAT_READY:\n\t\t*state = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\treturn 0;\n\tcase RT9467_STAT_PROGRESS:\n\t\t*state = POWER_SUPPLY_STATUS_CHARGING;\n\t\treturn 0;\n\tcase RT9467_STAT_CHARGE_DONE:\n\t\t*state = POWER_SUPPLY_STATUS_FULL;\n\t\treturn 0;\n\tdefault:\n\t\t*state = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\treturn 0;\n\t}\n}\n\nstatic int rt9467_psy_set_ichg(struct rt9467_chg_data *data, int microamp)\n{\n\tint ret;\n\n\tmutex_lock(&data->ichg_ieoc_lock);\n\n\tif (microamp < 500000) {\n\t\tdev_err(data->dev, \"Minimum value must be 500mA\\n\");\n\t\tmicroamp = 500000;\n\t}\n\n\tret = rt9467_set_value_from_ranges(data, F_ICHG, RT9467_RANGE_ICHG, microamp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rt9467_get_value_from_ranges(data, F_ICHG, RT9467_RANGE_ICHG,\n\t\t\t\t\t   &data->ichg_ua);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&data->ichg_ieoc_lock);\n\treturn ret;\n}\n\nstatic int rt9467_run_aicl(struct rt9467_chg_data *data)\n{\n\tunsigned int statc, aicl_vth;\n\tint mivr_vth, aicr_get;\n\tint ret = 0;\n\n\n\tret = regmap_read(data->regmap, RT9467_REG_CHG_STATC, &statc);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to read status\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(statc & RT9467_MASK_PWR_RDY) || !(statc & RT9467_MASK_MIVR_STAT)) {\n\t\tdev_info(data->dev, \"Condition not matched %d\\n\", statc);\n\t\treturn 0;\n\t}\n\n\tret = rt9467_get_value_from_ranges(data, F_VMIVR, RT9467_RANGE_VMIVR,\n\t\t\t\t\t   &mivr_vth);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to get mivr\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\taicl_vth = mivr_vth + RT9467_AICLVTH_GAP_uV;\n\tret = rt9467_set_value_from_ranges(data, F_AICL_VTH,\n\t\t\t\t\t   RT9467_RANGE_AICL_VTH, aicl_vth);\n\n\t \n\tret = regmap_field_write(data->rm_field[F_AICL_MEAS], 1);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to set aicl measurement\\n\");\n\t\treturn ret;\n\t}\n\n\treinit_completion(&data->aicl_done);\n\tret = wait_for_completion_timeout(&data->aicl_done, msecs_to_jiffies(3500));\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\tret = rt9467_get_value_from_ranges(data, F_IAICR, RT9467_RANGE_IAICR, &aicr_get);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to get aicr\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(data->dev, \"aicr get = %d uA\\n\", aicr_get);\n\treturn 0;\n}\n\nstatic int rt9467_psy_set_ieoc(struct rt9467_chg_data *data, int microamp)\n{\n\tint ret;\n\n\tmutex_lock(&data->ichg_ieoc_lock);\n\n\tret = rt9467_set_value_from_ranges(data, F_IEOC, RT9467_RANGE_IEOC, microamp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rt9467_get_value_from_ranges(data, F_IEOC, RT9467_RANGE_IEOC, &data->ieoc_ua);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&data->ichg_ieoc_lock);\n\treturn ret;\n}\n\nstatic const enum power_supply_usb_type rt9467_chg_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n};\n\nstatic const enum power_supply_property rt9467_chg_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n};\n\nstatic int rt9467_psy_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct rt9467_chg_data *data = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn rt9467_psy_get_status(data, &val->intval);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn regmap_field_read(data->rm_field[F_PWR_RDY], &val->intval);\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tmutex_lock(&data->attach_lock);\n\t\tif (data->psy_usb_type == POWER_SUPPLY_USB_TYPE_UNKNOWN ||\n\t\t    data->psy_usb_type == POWER_SUPPLY_USB_TYPE_SDP)\n\t\t\tval->intval = 500000;\n\t\telse\n\t\t\tval->intval = 1500000;\n\t\tmutex_unlock(&data->attach_lock);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tmutex_lock(&data->ichg_ieoc_lock);\n\t\tval->intval = data->ichg_ua;\n\t\tmutex_unlock(&data->ichg_ieoc_lock);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = RT9467_ICHG_MAX_uA;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn rt9467_get_value_from_ranges(data, F_VOREG,\n\t\t\t\t\t\t    RT9467_RANGE_VOREG,\n\t\t\t\t\t\t    &val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = RT9467_CV_MAX_uV;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn rt9467_get_value_from_ranges(data, F_IAICR,\n\t\t\t\t\t\t    RT9467_RANGE_IAICR,\n\t\t\t\t\t\t    &val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn rt9467_get_value_from_ranges(data, F_VMIVR,\n\t\t\t\t\t\t    RT9467_RANGE_VMIVR,\n\t\t\t\t\t\t    &val->intval);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tmutex_lock(&data->attach_lock);\n\t\tval->intval = data->psy_usb_type;\n\t\tmutex_unlock(&data->attach_lock);\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn rt9467_get_value_from_ranges(data, F_IPREC,\n\t\t\t\t\t\t    RT9467_RANGE_IPREC,\n\t\t\t\t\t\t    &val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tmutex_lock(&data->ichg_ieoc_lock);\n\t\tval->intval = data->ieoc_ua;\n\t\tmutex_unlock(&data->ichg_ieoc_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic int rt9467_psy_set_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tstruct rt9467_chg_data *data = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn regmap_field_write(data->rm_field[F_CHG_EN], val->intval);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn regmap_field_write(data->rm_field[F_HZ], val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn rt9467_psy_set_ichg(data, val->intval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn rt9467_set_value_from_ranges(data, F_VOREG,\n\t\t\t\t\t\t    RT9467_RANGE_VOREG, val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (val->intval == -1)\n\t\t\treturn rt9467_run_aicl(data);\n\t\telse\n\t\t\treturn rt9467_set_value_from_ranges(data, F_IAICR,\n\t\t\t\t\t\t\t    RT9467_RANGE_IAICR,\n\t\t\t\t\t\t\t    val->intval);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn rt9467_set_value_from_ranges(data, F_VMIVR,\n\t\t\t\t\t\t    RT9467_RANGE_VMIVR, val->intval);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn rt9467_set_value_from_ranges(data, F_IPREC,\n\t\t\t\t\t\t    RT9467_RANGE_IPREC, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn rt9467_psy_set_ieoc(data, val->intval);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn regmap_field_write(data->rm_field[F_USBCHGEN], val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rt9467_chg_prop_is_writeable(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct power_supply_desc rt9467_chg_psy_desc = {\n\t.name = \"rt9467-charger\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.usb_types = rt9467_chg_usb_types,\n\t.num_usb_types = ARRAY_SIZE(rt9467_chg_usb_types),\n\t.properties = rt9467_chg_properties,\n\t.num_properties = ARRAY_SIZE(rt9467_chg_properties),\n\t.property_is_writeable = rt9467_chg_prop_is_writeable,\n\t.get_property = rt9467_psy_get_property,\n\t.set_property = rt9467_psy_set_property,\n};\n\nstatic inline struct rt9467_chg_data *psy_device_to_chip(struct device *dev)\n{\n\treturn power_supply_get_drvdata(to_power_supply(dev));\n}\n\nstatic ssize_t sysoff_enable_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct rt9467_chg_data *data = psy_device_to_chip(dev);\n\tunsigned int sysoff_enable;\n\tint ret;\n\n\tret = regmap_field_read(data->rm_field[F_SHIP_MODE], &sysoff_enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", sysoff_enable);\n}\n\nstatic ssize_t sysoff_enable_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct rt9467_chg_data *data = psy_device_to_chip(dev);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_write(data->rm_field[F_SHIP_MODE], !!tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(sysoff_enable);\n\nstatic struct attribute *rt9467_sysfs_attrs[] = {\n\t&dev_attr_sysoff_enable.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(rt9467_sysfs);\n\nstatic int rt9467_register_psy(struct rt9467_chg_data *data)\n{\n\tstruct power_supply_config cfg = {\n\t\t.drv_data = data,\n\t\t.of_node = dev_of_node(data->dev),\n\t\t.attr_grp = rt9467_sysfs_groups,\n\t};\n\n\tdata->psy = devm_power_supply_register(data->dev, &rt9467_chg_psy_desc,\n\t\t\t\t\t       &cfg);\n\treturn PTR_ERR_OR_ZERO(data->psy);\n}\n\nstatic int rt9467_mivr_handler(struct rt9467_chg_data *data)\n{\n\tunsigned int mivr_act;\n\tint ret, ibus_ma;\n\n\t \n\tret = regmap_field_read(data->rm_field[F_CHG_MIVR], &mivr_act);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to read MIVR stat\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!mivr_act)\n\t\treturn 0;\n\n\tret = rt9467_get_adc(data, RT9467_ADC_IBUS, &ibus_ma);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to get IBUS\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ibus_ma < 100000) {\n\t\tret = regmap_field_write(data->rm_field[F_CFO_EN], 0);\n\t\tret |= regmap_field_write(data->rm_field[F_CFO_EN], 1);\n\t\tif (ret)\n\t\t\tdev_err(data->dev, \"Failed to toggle cfo\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t rt9467_statc_handler(int irq, void *priv)\n{\n\tstruct rt9467_chg_data *data = priv;\n\tunsigned int new_stat, evts = 0;\n\tint ret;\n\n\tret = regmap_read(data->regmap, RT9467_REG_CHG_STATC, &new_stat);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to read chg_statc\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tevts = data->old_stat ^ new_stat;\n\tdata->old_stat = new_stat;\n\n\tif ((evts & new_stat) & RT9467_MASK_MIVR_STAT) {\n\t\tret = rt9467_mivr_handler(data);\n\t\tif (ret)\n\t\t\tdev_err(data->dev, \"Failed to handle mivr stat\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9467_wdt_handler(int irq, void *priv)\n{\n\tstruct rt9467_chg_data *data = priv;\n\tunsigned int dev_id;\n\tint ret;\n\n\t \n\tret = regmap_read(data->regmap, RT9467_REG_DEVICE_ID, &dev_id);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to kick wdt (%d)\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rt9467_report_usb_state(struct rt9467_chg_data *data)\n{\n\tunsigned int usb_stat, power_ready;\n\tbool psy_changed = true;\n\tint ret;\n\n\tret = regmap_field_read(data->rm_field[F_USB_STATUS], &usb_stat);\n\tret |= regmap_field_read(data->rm_field[F_PWR_RDY], &power_ready);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!power_ready)\n\t\tusb_stat = RT9467_CHG_TYPE_NOVBUS;\n\n\tmutex_lock(&data->attach_lock);\n\n\tswitch (usb_stat) {\n\tcase RT9467_CHG_TYPE_NOVBUS:\n\t\tdata->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tbreak;\n\tcase RT9467_CHG_TYPE_SDP:\n\t\tdata->psy_usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase RT9467_CHG_TYPE_SDPNSTD:\n\t\tdata->psy_usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase RT9467_CHG_TYPE_DCP:\n\t\tdata->psy_usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase RT9467_CHG_TYPE_CDP:\n\t\tdata->psy_usb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tbreak;\n\tcase RT9467_CHG_TYPE_UNDER_GOING:\n\tdefault:\n\t\tpsy_changed = false;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->attach_lock);\n\n\tif (psy_changed)\n\t\tpower_supply_changed(data->psy);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rt9467_usb_state_handler(int irq, void *priv)\n{\n\tstruct rt9467_chg_data *data = priv;\n\tint ret;\n\n\tret = rt9467_report_usb_state(data);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to report attach type (%d)\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9467_aiclmeas_handler(int irq, void *priv)\n{\n\tstruct rt9467_chg_data *data = priv;\n\n\tcomplete(&data->aicl_done);\n\treturn IRQ_HANDLED;\n}\n\n#define RT9467_IRQ_DESC(_name, _handler_func, _hwirq)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.name = #_name,\t\t\t\t\t\t\\\n\t.handler = rt9467_##_handler_func##_handler,\t\t\\\n\t.hwirq = _hwirq,\t\t\t\t\t\\\n}\n\nstatic int rt9467_request_interrupt(struct rt9467_chg_data *data)\n{\n\tstruct device *dev = data->dev;\n\tstatic const struct {\n\t\tconst char *name;\n\t\tint hwirq;\n\t\tirq_handler_t handler;\n\t} rt9467_exclusive_irqs[] = {\n\t\tRT9467_IRQ_DESC(statc, statc, RT9467_IRQ_TS_STATC),\n\t\tRT9467_IRQ_DESC(wdt, wdt, RT9467_IRQ_WDTMR),\n\t\tRT9467_IRQ_DESC(attach, usb_state, RT9467_IRQ_ATTACH),\n\t\tRT9467_IRQ_DESC(detach,\tusb_state, RT9467_IRQ_DETACH),\n\t\tRT9467_IRQ_DESC(aiclmeas, aiclmeas, RT9467_IRQ_CHG_AICLM),\n\t}, rt9466_exclusive_irqs[] = {\n\t\tRT9467_IRQ_DESC(statc, statc, RT9467_IRQ_TS_STATC),\n\t\tRT9467_IRQ_DESC(wdt, wdt, RT9467_IRQ_WDTMR),\n\t\tRT9467_IRQ_DESC(aiclmeas, aiclmeas, RT9467_IRQ_CHG_AICLM),\n\t}, *chg_irqs;\n\tint num_chg_irqs, i, virq, ret;\n\n\tif (data->vid == RT9466_VID) {\n\t\tchg_irqs = rt9466_exclusive_irqs;\n\t\tnum_chg_irqs = ARRAY_SIZE(rt9466_exclusive_irqs);\n\t} else {\n\t\tchg_irqs = rt9467_exclusive_irqs;\n\t\tnum_chg_irqs = ARRAY_SIZE(rt9467_exclusive_irqs);\n\t}\n\n\tfor (i = 0; i < num_chg_irqs; i++) {\n\t\tvirq = regmap_irq_get_virq(data->irq_chip_data, chg_irqs[i].hwirq);\n\t\tif (virq <= 0)\n\t\t\treturn dev_err_probe(dev, -EINVAL, \"Failed to get (%s) irq\\n\",\n\t\t\t\t\t     chg_irqs[i].name);\n\n\t\tret = devm_request_threaded_irq(dev, virq, NULL, chg_irqs[i].handler,\n\t\t\t\t\t\tIRQF_ONESHOT, chg_irqs[i].name, data);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to request (%s) irq\\n\",\n\t\t\t\t\t     chg_irqs[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt9467_do_charger_init(struct rt9467_chg_data *data)\n{\n\tstruct device *dev = data->dev;\n\tint ret;\n\n\tret = regmap_write(data->regmap, RT9467_REG_CHG_ADC, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to reset ADC\\n\");\n\n\tret = rt9467_get_value_from_ranges(data, F_ICHG, RT9467_RANGE_ICHG,\n\t\t\t\t\t   &data->ichg_ua);\n\tret |= rt9467_get_value_from_ranges(data, F_IEOC, RT9467_RANGE_IEOC,\n\t\t\t\t\t    &data->ieoc_ua);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init ichg/ieoc value\\n\");\n\n\tret = regmap_update_bits(data->regmap, RT9467_REG_CHG_STATC_CTRL,\n\t\t\t\t RT9467_MASK_PWR_RDY | RT9467_MASK_MIVR_STAT, 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to make statc unmask\\n\");\n\n\t \n\tret = regmap_field_write(data->rm_field[F_IINLMTSEL],\n\t\t\t\t RT9467_IINLMTSEL_AICR);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set iinlmtsel to AICR\\n\");\n\n\t \n\tmsleep(150);\n\n\t \n\tret = regmap_field_write(data->rm_field[F_ILIM_EN], 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to disable hardware ILIM\\n\");\n\n\t \n\tret = regmap_field_write(data->rm_field[F_OCP], 1);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set higher inductor OCP level\\n\");\n\n\t \n\tret = regmap_field_write(data->rm_field[F_TE], 1);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set TE=1\\n\");\n\n\t \n\tret = regmap_field_write(data->rm_field[F_WT_FC], 4);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set WT_FC\\n\");\n\n\t \n\tret = regmap_field_write(data->rm_field[F_USBCHGEN], 0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to disable BC12\\n\");\n\n\treturn regmap_field_write(data->rm_field[F_USBCHGEN], 1);\n}\n\nstatic bool rt9467_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00 ... 0x1A:\n\tcase 0x20 ... 0x38:\n\tcase 0x40 ... 0x49:\n\tcase 0x50 ... 0x57:\n\tcase 0x60 ... 0x67:\n\tcase 0x70 ... 0x79:\n\tcase 0x82 ... 0x85:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt9467_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x85,\n\t.writeable_reg = rt9467_is_accessible_reg,\n\t.readable_reg = rt9467_is_accessible_reg,\n};\n\nstatic int rt9467_check_vendor_info(struct rt9467_chg_data *data)\n{\n\tunsigned int vid;\n\tint ret;\n\n\tret = regmap_field_read(data->rm_field[F_VENDOR], &vid);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to get vid\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((vid != RT9466_VID) && (vid != RT9467_VID))\n\t\treturn dev_err_probe(data->dev, -ENODEV,\n\t\t\t\t     \"VID not correct [0x%02X]\\n\", vid);\n\n\tdata->vid = vid;\n\treturn 0;\n}\n\nstatic int rt9467_reset_chip(struct rt9467_chg_data *data)\n{\n\tint ret;\n\n\t \n\tret = regmap_field_write(data->rm_field[F_HZ], 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_field_write(data->rm_field[F_RST], 1);\n}\n\nstatic void rt9467_chg_destroy_adc_lock(void *data)\n{\n\tstruct mutex *adc_lock = data;\n\n\tmutex_destroy(adc_lock);\n}\n\nstatic void rt9467_chg_destroy_attach_lock(void *data)\n{\n\tstruct mutex *attach_lock = data;\n\n\tmutex_destroy(attach_lock);\n}\n\nstatic void rt9467_chg_destroy_ichg_ieoc_lock(void *data)\n{\n\tstruct mutex *ichg_ieoc_lock = data;\n\n\tmutex_destroy(ichg_ieoc_lock);\n}\n\nstatic void rt9467_chg_complete_aicl_done(void *data)\n{\n\tstruct completion *aicl_done = data;\n\n\tcomplete(aicl_done);\n}\n\nstatic int rt9467_charger_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct rt9467_chg_data *data;\n\tstruct gpio_desc *ceb_gpio;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &i2c->dev;\n\ti2c_set_clientdata(i2c, data);\n\n\t \n\tceb_gpio = devm_gpiod_get_optional(dev, \"charge-enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ceb_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ceb_gpio),\n\t\t\t\t     \"Failed to config charge enable gpio\\n\");\n\n\tdata->regmap = devm_regmap_init_i2c(i2c, &rt9467_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\tret = devm_regmap_field_bulk_alloc(dev, data->regmap,\n\t\t\t\t\t   data->rm_field, rt9467_chg_fields,\n\t\t\t\t\t   ARRAY_SIZE(rt9467_chg_fields));\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to alloc regmap fields\\n\");\n\n\tret = rt9467_check_vendor_info(data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to check vendor info\");\n\n\tret = rt9467_reset_chip(data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to reset chip\\n\");\n\n\tret = devm_regmap_add_irq_chip(dev, data->regmap, i2c->irq,\n\t\t\t\t       IRQF_TRIGGER_LOW | IRQF_ONESHOT, 0,\n\t\t\t\t       &rt9467_irq_chip, &data->irq_chip_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add irq chip\\n\");\n\n\tmutex_init(&data->adc_lock);\n\tret = devm_add_action_or_reset(dev, rt9467_chg_destroy_adc_lock,\n\t\t\t\t       &data->adc_lock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init ADC lock\\n\");\n\n\tmutex_init(&data->attach_lock);\n\tret = devm_add_action_or_reset(dev, rt9467_chg_destroy_attach_lock,\n\t\t\t\t       &data->attach_lock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init attach lock\\n\");\n\n\tmutex_init(&data->ichg_ieoc_lock);\n\tret = devm_add_action_or_reset(dev, rt9467_chg_destroy_ichg_ieoc_lock,\n\t\t\t\t       &data->ichg_ieoc_lock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init ICHG/IEOC lock\\n\");\n\n\tinit_completion(&data->aicl_done);\n\tret = devm_add_action_or_reset(dev, rt9467_chg_complete_aicl_done,\n\t\t\t\t       &data->aicl_done);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init AICL done completion\\n\");\n\n\tret = rt9467_do_charger_init(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt9467_register_otg_regulator(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt9467_register_psy(data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rt9467_request_interrupt(data);\n}\n\nstatic const struct of_device_id rt9467_charger_of_match_table[] = {\n\t{ .compatible = \"richtek,rt9467\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt9467_charger_of_match_table);\n\nstatic struct i2c_driver rt9467_charger_driver = {\n\t.driver = {\n\t\t.name = \"rt9467-charger\",\n\t\t.of_match_table = rt9467_charger_of_match_table,\n\t},\n\t.probe = rt9467_charger_probe,\n};\nmodule_i2c_driver(rt9467_charger_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT9467 Charger Driver\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_AUTHOR(\"ChiaEn Wu <chiaen_wu@richtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}