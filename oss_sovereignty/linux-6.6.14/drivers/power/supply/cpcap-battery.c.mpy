{
  "module_name": "cpcap-battery.c",
  "hash_id": "bd466d09bf6523c1e20f5a744071414c4dd3feaf2443943988923cb79b85c2d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/cpcap-battery.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/moduleparam.h>\n\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n#include <linux/mfd/motorola-cpcap.h>\n\n \n#define CPCAP_REG_BPEOL_BIT_EOL9\tBIT(9)\t \n#define CPCAP_REG_BPEOL_BIT_EOL8\tBIT(8)\t \n#define CPCAP_REG_BPEOL_BIT_UNKNOWN7\tBIT(7)\n#define CPCAP_REG_BPEOL_BIT_UNKNOWN6\tBIT(6)\n#define CPCAP_REG_BPEOL_BIT_UNKNOWN5\tBIT(5)\n#define CPCAP_REG_BPEOL_BIT_EOL_MULTI\tBIT(4)\t \n#define CPCAP_REG_BPEOL_BIT_UNKNOWN3\tBIT(3)\n#define CPCAP_REG_BPEOL_BIT_UNKNOWN2\tBIT(2)\n#define CPCAP_REG_BPEOL_BIT_BATTDETEN\tBIT(1)\t \n#define CPCAP_REG_BPEOL_BIT_EOLSEL\tBIT(0)\t \n\n \n#define CPCAP_REG_CCC1_ACTIVE_MODE1\tBIT(4)\t \n#define CPCAP_REG_CCC1_ACTIVE_MODE0\tBIT(3)\t \n#define CPCAP_REG_CCC1_AUTOCLEAR\tBIT(2)\t \n#define CPCAP_REG_CCC1_CAL_EN\t\tBIT(1)\t \n#define CPCAP_REG_CCC1_PAUSE\t\tBIT(0)\t \n#define CPCAP_REG_CCC1_RESET_MASK\t(CPCAP_REG_CCC1_AUTOCLEAR | \\\n\t\t\t\t\t CPCAP_REG_CCC1_CAL_EN)\n\n#define CPCAP_REG_CCCC2_RATE1\t\tBIT(5)\n#define CPCAP_REG_CCCC2_RATE0\t\tBIT(4)\n#define CPCAP_REG_CCCC2_ENABLE\t\tBIT(3)\n\n#define CPCAP_BATTERY_CC_SAMPLE_PERIOD_MS\t250\n\n#define CPCAP_BATTERY_EB41_HW4X_ID 0x9E\n#define CPCAP_BATTERY_BW8X_ID 0x98\n\nenum {\n\tCPCAP_BATTERY_IIO_BATTDET,\n\tCPCAP_BATTERY_IIO_VOLTAGE,\n\tCPCAP_BATTERY_IIO_CHRG_CURRENT,\n\tCPCAP_BATTERY_IIO_BATT_CURRENT,\n\tCPCAP_BATTERY_IIO_NR,\n};\n\nenum cpcap_battery_irq_action {\n\tCPCAP_BATTERY_IRQ_ACTION_NONE,\n\tCPCAP_BATTERY_IRQ_ACTION_CC_CAL_DONE,\n\tCPCAP_BATTERY_IRQ_ACTION_BATTERY_LOW,\n\tCPCAP_BATTERY_IRQ_ACTION_POWEROFF,\n};\n\nstruct cpcap_interrupt_desc {\n\tconst char *name;\n\tstruct list_head node;\n\tint irq;\n\tenum cpcap_battery_irq_action action;\n};\n\nstruct cpcap_battery_config {\n\tint cd_factor;\n\tstruct power_supply_info info;\n\tstruct power_supply_battery_info bat;\n};\n\nstruct cpcap_coulomb_counter_data {\n\ts32 sample;\t\t \n\ts32 accumulator;\n\ts16 offset;\t\t \n\ts16 integrator;\t\t \n};\n\nenum cpcap_battery_state {\n\tCPCAP_BATTERY_STATE_PREVIOUS,\n\tCPCAP_BATTERY_STATE_LATEST,\n\tCPCAP_BATTERY_STATE_EMPTY,\n\tCPCAP_BATTERY_STATE_FULL,\n\tCPCAP_BATTERY_STATE_NR,\n};\n\nstruct cpcap_battery_state_data {\n\tint voltage;\n\tint current_ua;\n\tint counter_uah;\n\tint temperature;\n\tktime_t time;\n\tstruct cpcap_coulomb_counter_data cc;\n};\n\nstruct cpcap_battery_ddata {\n\tstruct device *dev;\n\tstruct regmap *reg;\n\tstruct list_head irq_list;\n\tstruct iio_channel *channels[CPCAP_BATTERY_IIO_NR];\n\tstruct power_supply *psy;\n\tstruct cpcap_battery_config config;\n\tstruct cpcap_battery_state_data state[CPCAP_BATTERY_STATE_NR];\n\tu32 cc_lsb;\t\t \n\tatomic_t active;\n\tint charge_full;\n\tint status;\n\tu16 vendor;\n\tbool check_nvmem;\n\tunsigned int is_full:1;\n};\n\n#define CPCAP_NO_BATTERY\t-400\n\nstatic bool ignore_temperature_probe;\nmodule_param(ignore_temperature_probe, bool, 0660);\n\nstatic struct cpcap_battery_state_data *\ncpcap_battery_get_state(struct cpcap_battery_ddata *ddata,\n\t\t\tenum cpcap_battery_state state)\n{\n\tif (state >= CPCAP_BATTERY_STATE_NR)\n\t\treturn NULL;\n\n\treturn &ddata->state[state];\n}\n\nstatic struct cpcap_battery_state_data *\ncpcap_battery_latest(struct cpcap_battery_ddata *ddata)\n{\n\treturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_LATEST);\n}\n\nstatic struct cpcap_battery_state_data *\ncpcap_battery_previous(struct cpcap_battery_ddata *ddata)\n{\n\treturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_PREVIOUS);\n}\n\nstatic struct cpcap_battery_state_data *\ncpcap_battery_get_empty(struct cpcap_battery_ddata *ddata)\n{\n\treturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_EMPTY);\n}\n\nstatic struct cpcap_battery_state_data *\ncpcap_battery_get_full(struct cpcap_battery_ddata *ddata)\n{\n\treturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_FULL);\n}\n\nstatic int cpcap_charger_battery_temperature(struct cpcap_battery_ddata *ddata,\n\t\t\t\t\t     int *value)\n{\n\tstruct iio_channel *channel;\n\tint error;\n\n\tchannel = ddata->channels[CPCAP_BATTERY_IIO_BATTDET];\n\terror = iio_read_channel_processed(channel, value);\n\tif (error < 0) {\n\t\tif (!ignore_temperature_probe)\n\t\t\tdev_warn(ddata->dev, \"%s failed: %i\\n\", __func__, error);\n\t\t*value = CPCAP_NO_BATTERY;\n\n\t\treturn error;\n\t}\n\n\t*value /= 100;\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_get_voltage(struct cpcap_battery_ddata *ddata)\n{\n\tstruct iio_channel *channel;\n\tint error, value = 0;\n\n\tchannel = ddata->channels[CPCAP_BATTERY_IIO_VOLTAGE];\n\terror = iio_read_channel_processed(channel, &value);\n\tif (error < 0) {\n\t\tdev_warn(ddata->dev, \"%s failed: %i\\n\", __func__, error);\n\n\t\treturn 0;\n\t}\n\n\treturn value * 1000;\n}\n\nstatic int cpcap_battery_get_current(struct cpcap_battery_ddata *ddata)\n{\n\tstruct iio_channel *channel;\n\tint error, value = 0;\n\n\tchannel = ddata->channels[CPCAP_BATTERY_IIO_BATT_CURRENT];\n\terror = iio_read_channel_processed(channel, &value);\n\tif (error < 0) {\n\t\tdev_warn(ddata->dev, \"%s failed: %i\\n\", __func__, error);\n\n\t\treturn 0;\n\t}\n\n\treturn value * 1000;\n}\n\n \nstatic int cpcap_battery_cc_raw_div(struct cpcap_battery_ddata *ddata,\n\t\t\t\t    s32 sample, s32 accumulator,\n\t\t\t\t    s16 offset, u32 divider)\n{\n\ts64 acc;\n\n\tif (!divider)\n\t\treturn 0;\n\n\tacc = accumulator;\n\tacc -= (s64)sample * offset;\n\tacc *= ddata->cc_lsb;\n\tacc *= -1;\n\tacc = div_s64(acc, divider);\n\n\treturn acc;\n}\n\n \nstatic int cpcap_battery_cc_to_uah(struct cpcap_battery_ddata *ddata,\n\t\t\t\t   s32 sample, s32 accumulator,\n\t\t\t\t   s16 offset)\n{\n\treturn cpcap_battery_cc_raw_div(ddata, sample,\n\t\t\t\t\taccumulator, offset,\n\t\t\t\t\t3600000);\n}\n\nstatic int cpcap_battery_cc_to_ua(struct cpcap_battery_ddata *ddata,\n\t\t\t\t  s32 sample, s32 accumulator,\n\t\t\t\t  s16 offset)\n{\n\treturn cpcap_battery_cc_raw_div(ddata, sample,\n\t\t\t\t\taccumulator, offset,\n\t\t\t\t\tsample *\n\t\t\t\t\tCPCAP_BATTERY_CC_SAMPLE_PERIOD_MS);\n}\n\n \nstatic int\ncpcap_battery_read_accumulated(struct cpcap_battery_ddata *ddata,\n\t\t\t       struct cpcap_coulomb_counter_data *ccd)\n{\n\tu16 buf[7];\t \n\tint error;\n\n\tccd->sample = 0;\n\tccd->accumulator = 0;\n\tccd->offset = 0;\n\tccd->integrator = 0;\n\n\t \n\terror = regmap_bulk_read(ddata->reg, CPCAP_REG_CCS1,\n\t\t\t\t buf, ARRAY_SIZE(buf));\n\tif (error)\n\t\treturn 0;\n\n\t \n\tccd->sample = (buf[1] & 0x0fff) << 16;\n\tccd->sample |= buf[0];\n\tif (ddata->vendor == CPCAP_VENDOR_TI)\n\t\tccd->sample = sign_extend32(24, ccd->sample);\n\n\t \n\tccd->accumulator = ((s16)buf[3]) << 16;\n\tccd->accumulator |= buf[2];\n\n\t \n\tccd->offset = buf[4];\n\tccd->offset = sign_extend32(ccd->offset, 9);\n\n\t \n\tif (ddata->vendor == CPCAP_VENDOR_TI)\n\t\tccd->integrator = sign_extend32(buf[6], 13);\n\telse\n\t\tccd->integrator = (s16)buf[6];\n\n\treturn cpcap_battery_cc_to_uah(ddata,\n\t\t\t\t       ccd->sample,\n\t\t\t\t       ccd->accumulator,\n\t\t\t\t       ccd->offset);\n}\n\n\n \nstatic const struct cpcap_battery_config cpcap_battery_eb41_data = {\n\t.cd_factor = 0x3cc,\n\t.info.technology = POWER_SUPPLY_TECHNOLOGY_LION,\n\t.info.voltage_max_design = 4351000,\n\t.info.voltage_min_design = 3100000,\n\t.info.charge_full_design = 1740000,\n\t.bat.constant_charge_voltage_max_uv = 4200000,\n};\n\n \nstatic const struct cpcap_battery_config cpcap_battery_bw8x_data = {\n\t.cd_factor = 0x3cc,\n\t.info.technology = POWER_SUPPLY_TECHNOLOGY_LION,\n\t.info.voltage_max_design = 4200000,\n\t.info.voltage_min_design = 3200000,\n\t.info.charge_full_design = 2760000,\n\t.bat.constant_charge_voltage_max_uv = 4200000,\n};\n\n \nstatic const struct cpcap_battery_config cpcap_battery_unkown_data = {\n\t.cd_factor = 0x3cc,\n\t.info.technology = POWER_SUPPLY_TECHNOLOGY_LION,\n\t.info.voltage_max_design = 4200000,\n\t.info.voltage_min_design = 3200000,\n\t.info.charge_full_design = 3000000,\n\t.bat.constant_charge_voltage_max_uv = 4200000,\n};\n\nstatic int cpcap_battery_match_nvmem(struct device *dev, const void *data)\n{\n\tif (strcmp(dev_name(dev), \"89-500029ba0f73\") == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void cpcap_battery_detect_battery_type(struct cpcap_battery_ddata *ddata)\n{\n\tstruct nvmem_device *nvmem;\n\tu8 battery_id = 0;\n\n\tddata->check_nvmem = false;\n\n\tnvmem = nvmem_device_find(NULL, &cpcap_battery_match_nvmem);\n\tif (IS_ERR_OR_NULL(nvmem)) {\n\t\tddata->check_nvmem = true;\n\t\tdev_info_once(ddata->dev, \"Can not find battery nvmem device. Assuming generic lipo battery\\n\");\n\t} else if (nvmem_device_read(nvmem, 2, 1, &battery_id) < 0) {\n\t\tbattery_id = 0;\n\t\tddata->check_nvmem = true;\n\t\tdev_warn(ddata->dev, \"Can not read battery nvmem device. Assuming generic lipo battery\\n\");\n\t}\n\n\tswitch (battery_id) {\n\tcase CPCAP_BATTERY_EB41_HW4X_ID:\n\t\tddata->config = cpcap_battery_eb41_data;\n\t\tbreak;\n\tcase CPCAP_BATTERY_BW8X_ID:\n\t\tddata->config = cpcap_battery_bw8x_data;\n\t\tbreak;\n\tdefault:\n\t\tddata->config = cpcap_battery_unkown_data;\n\t}\n}\n\n \nstatic int cpcap_battery_cc_get_avg_current(struct cpcap_battery_ddata *ddata)\n{\n\tint value, acc, error;\n\ts32 sample;\n\ts16 offset;\n\n\t \n\terror = regmap_read(ddata->reg, CPCAP_REG_CCI, &value);\n\tif (error)\n\t\treturn error;\n\n\tif (ddata->vendor == CPCAP_VENDOR_TI) {\n\t\tacc = sign_extend32(value, 13);\n\t\tsample = 1;\n\t} else {\n\t\tacc = (s16)value;\n\t\tsample = 4;\n\t}\n\n\t \n\terror = regmap_read(ddata->reg, CPCAP_REG_CCM, &value);\n\tif (error)\n\t\treturn error;\n\n\toffset = sign_extend32(value, 9);\n\n\treturn cpcap_battery_cc_to_ua(ddata, sample, acc, offset);\n}\n\nstatic int cpcap_battery_get_charger_status(struct cpcap_battery_ddata *ddata,\n\t\t\t\t\t    int *val)\n{\n\tunion power_supply_propval prop;\n\tstruct power_supply *charger;\n\tint error;\n\n\tcharger = power_supply_get_by_name(\"usb\");\n\tif (!charger)\n\t\treturn -ENODEV;\n\n\terror = power_supply_get_property(charger, POWER_SUPPLY_PROP_STATUS,\n\t\t\t\t\t  &prop);\n\tif (error)\n\t\t*val = POWER_SUPPLY_STATUS_UNKNOWN;\n\telse\n\t\t*val = prop.intval;\n\n\tpower_supply_put(charger);\n\n\treturn error;\n}\n\nstatic bool cpcap_battery_full(struct cpcap_battery_ddata *ddata)\n{\n\tstruct cpcap_battery_state_data *state = cpcap_battery_latest(ddata);\n\tunsigned int vfull;\n\tint error, val;\n\n\terror = cpcap_battery_get_charger_status(ddata, &val);\n\tif (!error) {\n\t\tswitch (val) {\n\t\tcase POWER_SUPPLY_STATUS_DISCHARGING:\n\t\t\tdev_dbg(ddata->dev, \"charger disconnected\\n\");\n\t\t\tddata->is_full = 0;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_STATUS_FULL:\n\t\t\tdev_dbg(ddata->dev, \"charger full status\\n\");\n\t\t\tddata->is_full = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tvfull = ddata->config.bat.constant_charge_voltage_max_uv - 120000;\n\n\tif (ddata->is_full && state->voltage < vfull)\n\t\tddata->is_full = 0;\n\n\treturn ddata->is_full;\n}\n\nstatic bool cpcap_battery_low(struct cpcap_battery_ddata *ddata)\n{\n\tstruct cpcap_battery_state_data *state = cpcap_battery_latest(ddata);\n\tstatic bool is_low;\n\n\tif (state->current_ua > 0 && (state->voltage <= 3350000 || is_low))\n\t\tis_low = true;\n\telse\n\t\tis_low = false;\n\n\treturn is_low;\n}\n\nstatic int cpcap_battery_update_status(struct cpcap_battery_ddata *ddata)\n{\n\tstruct cpcap_battery_state_data state, *latest, *previous,\n\t\t\t\t\t*empty, *full;\n\tktime_t now;\n\tint error;\n\n\tmemset(&state, 0, sizeof(state));\n\tnow = ktime_get();\n\n\tlatest = cpcap_battery_latest(ddata);\n\tif (latest) {\n\t\ts64 delta_ms = ktime_to_ms(ktime_sub(now, latest->time));\n\n\t\tif (delta_ms < CPCAP_BATTERY_CC_SAMPLE_PERIOD_MS)\n\t\t\treturn delta_ms;\n\t}\n\n\tstate.time = now;\n\tstate.voltage = cpcap_battery_get_voltage(ddata);\n\tstate.current_ua = cpcap_battery_get_current(ddata);\n\tstate.counter_uah = cpcap_battery_read_accumulated(ddata, &state.cc);\n\n\terror = cpcap_charger_battery_temperature(ddata,\n\t\t\t\t\t\t  &state.temperature);\n\tif (error)\n\t\treturn error;\n\n\tprevious = cpcap_battery_previous(ddata);\n\tmemcpy(previous, latest, sizeof(*previous));\n\tmemcpy(latest, &state, sizeof(*latest));\n\n\tif (cpcap_battery_full(ddata)) {\n\t\tfull = cpcap_battery_get_full(ddata);\n\t\tmemcpy(full, latest, sizeof(*full));\n\n\t\tempty = cpcap_battery_get_empty(ddata);\n\t\tif (empty->voltage && empty->voltage != -1) {\n\t\t\tempty->voltage = -1;\n\t\t\tddata->charge_full =\n\t\t\t\tempty->counter_uah - full->counter_uah;\n\t\t} else if (ddata->charge_full) {\n\t\t\tempty->voltage = -1;\n\t\t\tempty->counter_uah =\n\t\t\t\tfull->counter_uah + ddata->charge_full;\n\t\t}\n\t} else if (cpcap_battery_low(ddata)) {\n\t\tempty = cpcap_battery_get_empty(ddata);\n\t\tmemcpy(empty, latest, sizeof(*empty));\n\n\t\tfull = cpcap_battery_get_full(ddata);\n\t\tif (full->voltage) {\n\t\t\tfull->voltage = 0;\n\t\t\tddata->charge_full =\n\t\t\t\tempty->counter_uah - full->counter_uah;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cpcap_battery_external_power_changed(struct power_supply *psy)\n{\n\tunion power_supply_propval prop;\n\n\tpower_supply_get_property(psy, POWER_SUPPLY_PROP_STATUS, &prop);\n}\n\nstatic enum power_supply_property cpcap_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_POWER_AVG,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic int cpcap_battery_get_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct cpcap_battery_ddata *ddata = power_supply_get_drvdata(psy);\n\tstruct cpcap_battery_state_data *latest, *previous, *empty;\n\tu32 sample;\n\ts32 accumulator;\n\tint cached;\n\ts64 tmp;\n\n\tcached = cpcap_battery_update_status(ddata);\n\tif (cached < 0)\n\t\treturn cached;\n\n\tlatest = cpcap_battery_latest(ddata);\n\tprevious = cpcap_battery_previous(ddata);\n\n\tif (ddata->check_nvmem)\n\t\tcpcap_battery_detect_battery_type(ddata);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tif (latest->temperature > CPCAP_NO_BATTERY || ignore_temperature_probe)\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (cpcap_battery_full(ddata)) {\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (cpcap_battery_cc_get_avg_current(ddata) < 0)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = ddata->config.info.technology;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = cpcap_battery_get_voltage(ddata);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = ddata->config.info.voltage_max_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tval->intval = ddata->config.info.voltage_min_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tval->intval = ddata->config.bat.constant_charge_voltage_max_uv;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tsample = latest->cc.sample - previous->cc.sample;\n\t\tif (!sample) {\n\t\t\tval->intval = cpcap_battery_cc_get_avg_current(ddata);\n\t\t\tbreak;\n\t\t}\n\t\taccumulator = latest->cc.accumulator - previous->cc.accumulator;\n\t\tval->intval = cpcap_battery_cc_to_ua(ddata, sample,\n\t\t\t\t\t\t     accumulator,\n\t\t\t\t\t\t     latest->cc.offset);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = latest->current_ua;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tval->intval = latest->counter_uah;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\ttmp = (latest->voltage / 10000) * latest->current_ua;\n\t\tval->intval = div64_s64(tmp, 100);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_POWER_AVG:\n\t\tsample = latest->cc.sample - previous->cc.sample;\n\t\tif (!sample) {\n\t\t\ttmp = cpcap_battery_cc_get_avg_current(ddata);\n\t\t\ttmp *= (latest->voltage / 10000);\n\t\t\tval->intval = div64_s64(tmp, 100);\n\t\t\tbreak;\n\t\t}\n\t\taccumulator = latest->cc.accumulator - previous->cc.accumulator;\n\t\ttmp = cpcap_battery_cc_to_ua(ddata, sample, accumulator,\n\t\t\t\t\t     latest->cc.offset);\n\t\ttmp *= ((latest->voltage + previous->voltage) / 20000);\n\t\tval->intval = div64_s64(tmp, 100);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tempty = cpcap_battery_get_empty(ddata);\n\t\tif (!empty->voltage || !ddata->charge_full)\n\t\t\treturn -ENODATA;\n\t\t \n\t\tval->intval = empty->counter_uah - latest->counter_uah +\n\t\t\tddata->charge_full / 200;\n\t\tval->intval = clamp(val->intval, 0, ddata->charge_full);\n\t\tval->intval = val->intval * 100 / ddata->charge_full;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tif (cpcap_battery_full(ddata))\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\telse if (latest->voltage >= 3750000)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\n\t\telse if (latest->voltage >= 3300000)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\telse if (latest->voltage > 3100000)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\telse if (latest->voltage <= 3100000)\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tempty = cpcap_battery_get_empty(ddata);\n\t\tif (!empty->voltage)\n\t\t\treturn -ENODATA;\n\t\tval->intval = empty->counter_uah - latest->counter_uah;\n\t\tif (val->intval < 0) {\n\t\t\t \n\t\t\tif (ddata->charge_full && abs(val->intval) > ddata->charge_full/5) {\n\t\t\t\tempty->voltage = 0;\n\t\t\t\tddata->charge_full = 0;\n\t\t\t\treturn -ENODATA;\n\t\t\t}\n\t\t\tval->intval = 0;\n\t\t} else if (ddata->charge_full && ddata->charge_full < val->intval) {\n\t\t\t \n\t\t\tif (val->intval > (6*ddata->charge_full)/5) {\n\t\t\t\tempty->voltage = 0;\n\t\t\t\tddata->charge_full = 0;\n\t\t\t\treturn -ENODATA;\n\t\t\t}\n\t\t\tval->intval = ddata->charge_full;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tif (!ddata->charge_full)\n\t\t\treturn -ENODATA;\n\t\tval->intval = ddata->charge_full;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval = ddata->config.info.charge_full_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tif (ignore_temperature_probe)\n\t\t\treturn -ENODATA;\n\t\tval->intval = latest->temperature;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_update_charger(struct cpcap_battery_ddata *ddata,\n\t\t\t\t\tint const_charge_voltage)\n{\n\tunion power_supply_propval prop;\n\tunion power_supply_propval val;\n\tstruct power_supply *charger;\n\tint error;\n\n\tcharger = power_supply_get_by_name(\"usb\");\n\tif (!charger)\n\t\treturn -ENODEV;\n\n\terror = power_supply_get_property(charger,\n\t\t\t\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\t\t\t\t&prop);\n\tif (error)\n\t\tgoto out_put;\n\n\t \n\tif (const_charge_voltage > prop.intval)\n\t\tgoto out_put;\n\n\tval.intval = const_charge_voltage;\n\n\terror = power_supply_set_property(charger,\n\t\t\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\t\t\t&val);\nout_put:\n\tpower_supply_put(charger);\n\n\treturn error;\n}\n\nstatic int cpcap_battery_set_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      const union power_supply_propval *val)\n{\n\tstruct cpcap_battery_ddata *ddata = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tif (val->intval < ddata->config.info.voltage_min_design)\n\t\t\treturn -EINVAL;\n\t\tif (val->intval > ddata->config.info.voltage_max_design)\n\t\t\treturn -EINVAL;\n\n\t\tddata->config.bat.constant_charge_voltage_max_uv = val->intval;\n\n\t\treturn cpcap_battery_update_charger(ddata, val->intval);\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tif (val->intval < 0)\n\t\t\treturn -EINVAL;\n\t\tif (val->intval > (6*ddata->config.info.charge_full_design)/5)\n\t\t\treturn -EINVAL;\n\n\t\tddata->charge_full = val->intval;\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t       enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic irqreturn_t cpcap_battery_irq_thread(int irq, void *data)\n{\n\tstruct cpcap_battery_ddata *ddata = data;\n\tstruct cpcap_battery_state_data *latest;\n\tstruct cpcap_interrupt_desc *d;\n\n\tif (!atomic_read(&ddata->active))\n\t\treturn IRQ_NONE;\n\n\tlist_for_each_entry(d, &ddata->irq_list, node) {\n\t\tif (irq == d->irq)\n\t\t\tbreak;\n\t}\n\n\tif (list_entry_is_head(d, &ddata->irq_list, node))\n\t\treturn IRQ_NONE;\n\n\tlatest = cpcap_battery_latest(ddata);\n\n\tswitch (d->action) {\n\tcase CPCAP_BATTERY_IRQ_ACTION_CC_CAL_DONE:\n\t\tdev_info(ddata->dev, \"Coulomb counter calibration done\\n\");\n\t\tbreak;\n\tcase CPCAP_BATTERY_IRQ_ACTION_BATTERY_LOW:\n\t\tif (latest->current_ua >= 0)\n\t\t\tdev_warn(ddata->dev, \"Battery low at %imV!\\n\",\n\t\t\t\tlatest->voltage / 1000);\n\t\tbreak;\n\tcase CPCAP_BATTERY_IRQ_ACTION_POWEROFF:\n\t\tif (latest->current_ua >= 0 && latest->voltage <= 3200000) {\n\t\t\tdev_emerg(ddata->dev,\n\t\t\t\t  \"Battery empty at %imV, powering off\\n\",\n\t\t\t\t  latest->voltage / 1000);\n\t\t\torderly_poweroff(true);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpower_supply_changed(ddata->psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cpcap_battery_init_irq(struct platform_device *pdev,\n\t\t\t\t  struct cpcap_battery_ddata *ddata,\n\t\t\t\t  const char *name)\n{\n\tstruct cpcap_interrupt_desc *d;\n\tint irq, error;\n\n\tirq = platform_get_irq_byname(pdev, name);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terror = devm_request_threaded_irq(ddata->dev, irq, NULL,\n\t\t\t\t\t  cpcap_battery_irq_thread,\n\t\t\t\t\t  IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t  name, ddata);\n\tif (error) {\n\t\tdev_err(ddata->dev, \"could not get irq %s: %i\\n\",\n\t\t\tname, error);\n\n\t\treturn error;\n\t}\n\n\td = devm_kzalloc(ddata->dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->name = name;\n\td->irq = irq;\n\n\tif (!strncmp(name, \"cccal\", 5))\n\t\td->action = CPCAP_BATTERY_IRQ_ACTION_CC_CAL_DONE;\n\telse if (!strncmp(name, \"lowbph\", 6))\n\t\td->action = CPCAP_BATTERY_IRQ_ACTION_BATTERY_LOW;\n\telse if (!strncmp(name, \"lowbpl\", 6))\n\t\td->action = CPCAP_BATTERY_IRQ_ACTION_POWEROFF;\n\n\tlist_add(&d->node, &ddata->irq_list);\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_init_interrupts(struct platform_device *pdev,\n\t\t\t\t\t struct cpcap_battery_ddata *ddata)\n{\n\tstatic const char * const cpcap_battery_irqs[] = {\n\t\t\"eol\", \"lowbph\", \"lowbpl\",\n\t\t\"chrgcurr1\", \"battdetb\"\n\t};\n\tint i, error;\n\n\tfor (i = 0; i < ARRAY_SIZE(cpcap_battery_irqs); i++) {\n\t\terror = cpcap_battery_init_irq(pdev, ddata,\n\t\t\t\t\t       cpcap_battery_irqs[i]);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tcpcap_battery_init_irq(pdev, ddata, \"cccal\");\n\n\t \n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_BPEOL,\n\t\t\t\t   0xffff,\n\t\t\t\t   CPCAP_REG_BPEOL_BIT_BATTDETEN);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_init_iio(struct cpcap_battery_ddata *ddata)\n{\n\tconst char * const names[CPCAP_BATTERY_IIO_NR] = {\n\t\t\"battdetb\", \"battp\", \"chg_isense\", \"batti\",\n\t};\n\tint error, i;\n\n\tfor (i = 0; i < CPCAP_BATTERY_IIO_NR; i++) {\n\t\tddata->channels[i] = devm_iio_channel_get(ddata->dev,\n\t\t\t\t\t\t\t  names[i]);\n\t\tif (IS_ERR(ddata->channels[i])) {\n\t\t\terror = PTR_ERR(ddata->channels[i]);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!ddata->channels[i]->indio_dev) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn dev_err_probe(ddata->dev, error,\n\t\t\t     \"could not initialize VBUS or ID IIO\\n\");\n}\n\n \nstatic int cpcap_battery_calibrate(struct cpcap_battery_ddata *ddata)\n{\n\tint error, ccc1, value;\n\tunsigned long timeout;\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_CCC1, &ccc1);\n\tif (error)\n\t\treturn error;\n\n\ttimeout = jiffies + msecs_to_jiffies(6000);\n\n\t \n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CCC1,\n\t\t\t\t   0xffff,\n\t\t\t\t   CPCAP_REG_CCC1_CAL_EN);\n\tif (error)\n\t\tgoto restore;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\terror = regmap_read(ddata->reg, CPCAP_REG_CCC1, &value);\n\t\tif (error)\n\t\t\tgoto restore;\n\n\t\tif (!(value & CPCAP_REG_CCC1_CAL_EN))\n\t\t\tbreak;\n\n\t\terror = regmap_read(ddata->reg, CPCAP_REG_CCM, &value);\n\t\tif (error)\n\t\t\tgoto restore;\n\n\t\tmsleep(300);\n\t}\n\n\t \n\terror = regmap_read(ddata->reg, CPCAP_REG_CCM, &value);\n\tif (error)\n\t\tgoto restore;\n\n\tdev_info(ddata->dev, \"calibration done: 0x%04x\\n\", value);\n\nrestore:\n\tif (error)\n\t\tdev_err(ddata->dev, \"%s: error %i\\n\", __func__, error);\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_CCC1,\n\t\t\t\t   0xffff, ccc1);\n\tif (error)\n\t\tdev_err(ddata->dev, \"%s: restore error %i\\n\",\n\t\t\t__func__, error);\n\n\treturn error;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cpcap_battery_id_table[] = {\n\t{\n\t\t.compatible = \"motorola,cpcap-battery\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_battery_id_table);\n#endif\n\nstatic const struct power_supply_desc cpcap_charger_battery_desc = {\n\t.name\t\t= \"battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= cpcap_battery_props,\n\t.num_properties\t= ARRAY_SIZE(cpcap_battery_props),\n\t.get_property\t= cpcap_battery_get_property,\n\t.set_property\t= cpcap_battery_set_property,\n\t.property_is_writeable = cpcap_battery_property_is_writeable,\n\t.external_power_changed = cpcap_battery_external_power_changed,\n};\n\nstatic int cpcap_battery_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_battery_ddata *ddata;\n\tstruct power_supply_config psy_cfg = {};\n\tint error;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tcpcap_battery_detect_battery_type(ddata);\n\n\tINIT_LIST_HEAD(&ddata->irq_list);\n\tddata->dev = &pdev->dev;\n\n\tddata->reg = dev_get_regmap(ddata->dev->parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\terror = cpcap_get_vendor(ddata->dev, ddata->reg, &ddata->vendor);\n\tif (error)\n\t\treturn error;\n\n\tswitch (ddata->vendor) {\n\tcase CPCAP_VENDOR_ST:\n\t\tddata->cc_lsb = 95374;\t \n\t\tbreak;\n\tcase CPCAP_VENDOR_TI:\n\t\tddata->cc_lsb = 91501;\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tddata->cc_lsb = (ddata->cc_lsb * ddata->config.cd_factor) / 1000;\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\terror = cpcap_battery_init_interrupts(pdev, ddata);\n\tif (error)\n\t\treturn error;\n\n\terror = cpcap_battery_init_iio(ddata);\n\tif (error)\n\t\treturn error;\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = ddata;\n\n\tddata->psy = devm_power_supply_register(ddata->dev,\n\t\t\t\t\t\t&cpcap_charger_battery_desc,\n\t\t\t\t\t\t&psy_cfg);\n\terror = PTR_ERR_OR_ZERO(ddata->psy);\n\tif (error) {\n\t\tdev_err(ddata->dev, \"failed to register power supply\\n\");\n\t\treturn error;\n\t}\n\n\tatomic_set(&ddata->active, 1);\n\n\terror = cpcap_battery_calibrate(ddata);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int cpcap_battery_remove(struct platform_device *pdev)\n{\n\tstruct cpcap_battery_ddata *ddata = platform_get_drvdata(pdev);\n\tint error;\n\n\tatomic_set(&ddata->active, 0);\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_BPEOL,\n\t\t\t\t   0xffff, 0);\n\tif (error)\n\t\tdev_err(&pdev->dev, \"could not disable: %i\\n\", error);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpcap_battery_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"cpcap_battery\",\n\t\t.of_match_table = of_match_ptr(cpcap_battery_id_table),\n\t},\n\t.probe\t= cpcap_battery_probe,\n\t.remove = cpcap_battery_remove,\n};\nmodule_platform_driver(cpcap_battery_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"CPCAP PMIC Battery Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}