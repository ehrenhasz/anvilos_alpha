{
  "module_name": "ab8500_charger.c",
  "hash_id": "540bed88699239f02af2d31c1bed19a954b7f56646adf2b698ceafffc1e811af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ab8500_charger.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/component.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/completion.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/of.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/mfd/abx500.h>\n#include <linux/usb/otg.h>\n#include <linux/mutex.h>\n#include <linux/iio/consumer.h>\n\n#include \"ab8500-bm.h\"\n#include \"ab8500-chargalg.h\"\n\n \n#define NO_PW_CONN\t\t\t0\n#define AC_PW_CONN\t\t\t1\n#define USB_PW_CONN\t\t\t2\n\n#define MAIN_WDOG_ENA\t\t\t0x01\n#define MAIN_WDOG_KICK\t\t\t0x02\n#define MAIN_WDOG_DIS\t\t\t0x00\n#define CHARG_WD_KICK\t\t\t0x01\n#define MAIN_CH_ENA\t\t\t0x01\n#define MAIN_CH_NO_OVERSHOOT_ENA_N\t0x02\n#define USB_CH_ENA\t\t\t0x01\n#define USB_CHG_NO_OVERSHOOT_ENA_N\t0x02\n#define MAIN_CH_DET\t\t\t0x01\n#define MAIN_CH_CV_ON\t\t\t0x04\n#define USB_CH_CV_ON\t\t\t0x08\n#define VBUS_DET_DBNC100\t\t0x02\n#define VBUS_DET_DBNC1\t\t\t0x01\n#define OTP_ENABLE_WD\t\t\t0x01\n#define DROP_COUNT_RESET\t\t0x01\n#define USB_CH_DET\t\t\t0x01\n\n#define MAIN_CH_INPUT_CURR_SHIFT\t4\n#define VBUS_IN_CURR_LIM_SHIFT\t\t4\n#define AUTO_VBUS_IN_CURR_LIM_SHIFT\t4\n#define VBUS_IN_CURR_LIM_RETRY_SET_TIME\t30  \n\n#define LED_INDICATOR_PWM_ENA\t\t0x01\n#define LED_INDICATOR_PWM_DIS\t\t0x00\n#define LED_IND_CUR_5MA\t\t\t0x04\n#define LED_INDICATOR_PWM_DUTY_252_256\t0xBF\n\n \n#define MAIN_CH_TH_PROT\t\t\t0x02\n#define VBUS_CH_NOK\t\t\t0x08\n#define USB_CH_TH_PROT\t\t\t0x02\n#define VBUS_OVV_TH\t\t\t0x01\n#define MAIN_CH_NOK\t\t\t0x01\n#define VBUS_DET\t\t\t0x80\n\n#define MAIN_CH_STATUS2_MAINCHGDROP\t\t0x80\n#define MAIN_CH_STATUS2_MAINCHARGERDETDBNC\t0x40\n#define USB_CH_VBUSDROP\t\t\t\t0x40\n#define USB_CH_VBUSDETDBNC\t\t\t0x01\n\n \n#define AB8500_USB_LINK_STATUS\t\t0x78\n#define AB8505_USB_LINK_STATUS\t\t0xF8\n#define AB8500_STD_HOST_SUSP\t\t0x18\n#define USB_LINK_STATUS_SHIFT\t\t3\n\n \n#define WD_TIMER\t\t\t0x30  \n#define WD_KICK_INTERVAL\t\t(60 * HZ)\n\n \n#define LOW_VOLT_REG\t\t\t0x4E\n\n \n#define STEP_UDELAY\t\t\t1000\n\n#define CHARGER_STATUS_POLL 10  \n\n#define CHG_WD_INTERVAL\t\t\t(60 * HZ)\n\n#define AB8500_SW_CONTROL_FALLBACK\t0x03\n \n#define WAIT_ACA_RID_ENUMERATION\t(5 * 1000)\n \n#define AB8500_SYS_CHARGER_CONTROL_REG\t\t0x52\n#define EXTERNAL_CHARGER_DISABLE_REG_VAL\t0x03\n#define EXTERNAL_CHARGER_ENABLE_REG_VAL\t\t0x07\n\n \nenum ab8500_charger_link_status {\n\tUSB_STAT_NOT_CONFIGURED,\n\tUSB_STAT_STD_HOST_NC,\n\tUSB_STAT_STD_HOST_C_NS,\n\tUSB_STAT_STD_HOST_C_S,\n\tUSB_STAT_HOST_CHG_NM,\n\tUSB_STAT_HOST_CHG_HS,\n\tUSB_STAT_HOST_CHG_HS_CHIRP,\n\tUSB_STAT_DEDICATED_CHG,\n\tUSB_STAT_ACA_RID_A,\n\tUSB_STAT_ACA_RID_B,\n\tUSB_STAT_ACA_RID_C_NM,\n\tUSB_STAT_ACA_RID_C_HS,\n\tUSB_STAT_ACA_RID_C_HS_CHIRP,\n\tUSB_STAT_HM_IDGND,\n\tUSB_STAT_RESERVED,\n\tUSB_STAT_NOT_VALID_LINK,\n\tUSB_STAT_PHY_EN,\n\tUSB_STAT_SUP_NO_IDGND_VBUS,\n\tUSB_STAT_SUP_IDGND_VBUS,\n\tUSB_STAT_CHARGER_LINE_1,\n\tUSB_STAT_CARKIT_1,\n\tUSB_STAT_CARKIT_2,\n\tUSB_STAT_ACA_DOCK_CHARGER,\n};\n\nenum ab8500_usb_state {\n\tAB8500_BM_USB_STATE_RESET_HS,\t \n\tAB8500_BM_USB_STATE_RESET_FS,\t \n\tAB8500_BM_USB_STATE_CONFIGURED,\n\tAB8500_BM_USB_STATE_SUSPEND,\n\tAB8500_BM_USB_STATE_RESUME,\n\tAB8500_BM_USB_STATE_MAX,\n};\n\n \n#define USB_CH_IP_CUR_LVL_0P05\t\t50000\n#define USB_CH_IP_CUR_LVL_0P09\t\t98000\n#define USB_CH_IP_CUR_LVL_0P19\t\t193000\n#define USB_CH_IP_CUR_LVL_0P29\t\t290000\n#define USB_CH_IP_CUR_LVL_0P38\t\t380000\n#define USB_CH_IP_CUR_LVL_0P45\t\t450000\n#define USB_CH_IP_CUR_LVL_0P5\t\t500000\n#define USB_CH_IP_CUR_LVL_0P6\t\t600000\n#define USB_CH_IP_CUR_LVL_0P7\t\t700000\n#define USB_CH_IP_CUR_LVL_0P8\t\t800000\n#define USB_CH_IP_CUR_LVL_0P9\t\t900000\n#define USB_CH_IP_CUR_LVL_1P0\t\t1000000\n#define USB_CH_IP_CUR_LVL_1P1\t\t1100000\n#define USB_CH_IP_CUR_LVL_1P3\t\t1300000\n#define USB_CH_IP_CUR_LVL_1P4\t\t1400000\n#define USB_CH_IP_CUR_LVL_1P5\t\t1500000\n\n#define VBAT_TRESH_IP_CUR_RED\t\t3800000\n\n#define to_ab8500_charger_usb_device_info(x) container_of((x), \\\n\tstruct ab8500_charger, usb_chg)\n#define to_ab8500_charger_ac_device_info(x) container_of((x), \\\n\tstruct ab8500_charger, ac_chg)\n\n \nstruct ab8500_charger_interrupts {\n\tchar *name;\n\tirqreturn_t (*isr)(int irq, void *data);\n};\n\nstruct ab8500_charger_info {\n\tint charger_connected;\n\tint charger_online;\n\tint charger_voltage_uv;\n\tint cv_active;\n\tbool wd_expired;\n\tint charger_current_ua;\n};\n\nstruct ab8500_charger_event_flags {\n\tbool mainextchnotok;\n\tbool main_thermal_prot;\n\tbool usb_thermal_prot;\n\tbool vbus_ovv;\n\tbool usbchargernotok;\n\tbool chgwdexp;\n\tbool vbus_collapse;\n\tbool vbus_drop_end;\n};\n\nstruct ab8500_charger_usb_state {\n\tint usb_current_ua;\n\tint usb_current_tmp_ua;\n\tenum ab8500_usb_state state;\n\tenum ab8500_usb_state state_tmp;\n\tspinlock_t usb_lock;\n};\n\nstruct ab8500_charger_max_usb_in_curr {\n\tint usb_type_max_ua;\n\tint set_max_ua;\n\tint calculated_max_ua;\n};\n\n \nstruct ab8500_charger {\n\tstruct device *dev;\n\tbool vbus_detected;\n\tbool vbus_detected_start;\n\tbool ac_conn;\n\tbool vddadc_en_ac;\n\tbool vddadc_en_usb;\n\tint vbat;\n\tint old_vbat;\n\tbool usb_device_is_unrecognised;\n\tbool autopower;\n\tbool autopower_cfg;\n\tint invalid_charger_detect_state;\n\tint is_aca_rid;\n\tatomic_t current_stepping_sessions;\n\tstruct ab8500 *parent;\n\tstruct iio_channel *adc_main_charger_v;\n\tstruct iio_channel *adc_main_charger_c;\n\tstruct iio_channel *adc_vbus_v;\n\tstruct iio_channel *adc_usb_charger_c;\n\tstruct ab8500_bm_data *bm;\n\tstruct ab8500_charger_event_flags flags;\n\tstruct ab8500_charger_usb_state usb_state;\n\tstruct ab8500_charger_max_usb_in_curr max_usb_in_curr;\n\tstruct ux500_charger ac_chg;\n\tstruct ux500_charger usb_chg;\n\tstruct ab8500_charger_info ac;\n\tstruct ab8500_charger_info usb;\n\tstruct regulator *regu;\n\tstruct workqueue_struct *charger_wq;\n\tstruct mutex usb_ipt_crnt_lock;\n\tstruct delayed_work check_vbat_work;\n\tstruct delayed_work check_hw_failure_work;\n\tstruct delayed_work check_usbchgnotok_work;\n\tstruct delayed_work kick_wd_work;\n\tstruct delayed_work usb_state_changed_work;\n\tstruct delayed_work attach_work;\n\tstruct delayed_work ac_charger_attached_work;\n\tstruct delayed_work usb_charger_attached_work;\n\tstruct delayed_work vbus_drop_end_work;\n\tstruct work_struct ac_work;\n\tstruct work_struct detect_usb_type_work;\n\tstruct work_struct usb_link_status_work;\n\tstruct work_struct check_main_thermal_prot_work;\n\tstruct work_struct check_usb_thermal_prot_work;\n\tstruct usb_phy *usb_phy;\n\tstruct notifier_block nb;\n\tstruct mutex charger_attached_mutex;\n};\n\n \nstatic enum power_supply_property ab8500_charger_ac_props[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\n \nstatic enum power_supply_property ab8500_charger_usb_props[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\n \nstatic void ab8500_enable_disable_sw_fallback(struct ab8500_charger *di,\n\t\tbool fallback)\n{\n\tu8 val;\n\tu8 reg;\n\tu8 bank;\n\tu8 bit;\n\tint ret;\n\n\tdev_dbg(di->dev, \"SW Fallback: %d\\n\", fallback);\n\n\tif (is_ab8500(di->parent)) {\n\t\tbank = 0x15;\n\t\treg = 0x0;\n\t\tbit = 3;\n\t} else {\n\t\tbank = AB8500_SYS_CTRL1_BLOCK;\n\t\treg = AB8500_SW_CONTROL_FALLBACK;\n\t\tbit = 0;\n\t}\n\n\t \n\tret = abx500_get_register_interruptible(di->dev, bank, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%d read failed\\n\", __LINE__);\n\t\treturn;\n\t}\n\n\tif (is_ab8500(di->parent)) {\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, 0x11, 0x00, 0x2);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%d write failed\\n\", __LINE__);\n\t\t\tgoto disable_otp;\n\t\t}\n\t}\n\n\tif (fallback)\n\t\tval |= (1 << bit);\n\telse\n\t\tval &= ~(1 << bit);\n\n\t \n\tret = abx500_set_register_interruptible(di->dev, bank, reg, val);\n\tif (ret) {\n\t\tdev_err(di->dev, \"%d write failed\\n\", __LINE__);\n\t}\n\ndisable_otp:\n\tif (is_ab8500(di->parent)) {\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, 0x11, 0x00, 0x0);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%d write failed\\n\", __LINE__);\n\t\t}\n\t}\n}\n\n \nstatic void ab8500_power_supply_changed(struct ab8500_charger *di,\n\t\t\t\t\tstruct power_supply *psy)\n{\n\t \n\tif (!psy)\n\t\treturn;\n\n\tif (di->autopower_cfg) {\n\t\tif (!di->usb.charger_connected &&\n\t\t    !di->ac.charger_connected &&\n\t\t    di->autopower) {\n\t\t\tdi->autopower = false;\n\t\t\tab8500_enable_disable_sw_fallback(di, false);\n\t\t} else if (!di->autopower &&\n\t\t\t   (di->ac.charger_connected ||\n\t\t\t    di->usb.charger_connected)) {\n\t\t\tdi->autopower = true;\n\t\t\tab8500_enable_disable_sw_fallback(di, true);\n\t\t}\n\t}\n\tpower_supply_changed(psy);\n}\n\nstatic void ab8500_charger_set_usb_connected(struct ab8500_charger *di,\n\tbool connected)\n{\n\tif (connected != di->usb.charger_connected) {\n\t\tdev_dbg(di->dev, \"USB connected:%i\\n\", connected);\n\t\tdi->usb.charger_connected = connected;\n\n\t\tif (!connected)\n\t\t\tdi->flags.vbus_drop_end = false;\n\n\t\t \n\t\tif (di->usb_chg.psy) {\n\t\t\tsysfs_notify(&di->usb_chg.psy->dev.kobj, NULL,\n\t\t\t\t     \"present\");\n\t\t}\n\n\t\tif (connected) {\n\t\t\tmutex_lock(&di->charger_attached_mutex);\n\t\t\tmutex_unlock(&di->charger_attached_mutex);\n\n\t\t\tif (is_ab8500(di->parent))\n\t\t\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t\t   &di->usb_charger_attached_work,\n\t\t\t\t\t   HZ);\n\t\t} else {\n\t\t\tcancel_delayed_work_sync(&di->usb_charger_attached_work);\n\t\t\tmutex_lock(&di->charger_attached_mutex);\n\t\t\tmutex_unlock(&di->charger_attached_mutex);\n\t\t}\n\t}\n}\n\n \nstatic int ab8500_charger_get_ac_voltage(struct ab8500_charger *di)\n{\n\tint vch, ret;\n\n\t \n\tif (di->ac.charger_connected) {\n\t\tret = iio_read_channel_processed(di->adc_main_charger_v, &vch);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"%s ADC conv failed,\\n\", __func__);\n\t} else {\n\t\tvch = 0;\n\t}\n\t \n\treturn vch * 1000;\n}\n\n \nstatic int ab8500_charger_ac_cv(struct ab8500_charger *di)\n{\n\tu8 val;\n\tint ret = 0;\n\n\t \n\tif (di->ac.charger_online) {\n\t\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CH_STATUS1_REG, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val & MAIN_CH_CV_ON)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_get_vbus_voltage(struct ab8500_charger *di)\n{\n\tint vch, ret;\n\n\t \n\tif (di->usb.charger_connected) {\n\t\tret = iio_read_channel_processed(di->adc_vbus_v, &vch);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"%s ADC conv failed,\\n\", __func__);\n\t} else {\n\t\tvch = 0;\n\t}\n\t \n\treturn vch * 1000;\n}\n\n \nstatic int ab8500_charger_get_usb_current(struct ab8500_charger *di)\n{\n\tint ich, ret;\n\n\t \n\tif (di->usb.charger_online) {\n\t\tret = iio_read_channel_processed(di->adc_usb_charger_c, &ich);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"%s ADC conv failed,\\n\", __func__);\n\t} else {\n\t\tich = 0;\n\t}\n\t \n\treturn ich * 1000;\n}\n\n \nstatic int ab8500_charger_get_ac_current(struct ab8500_charger *di)\n{\n\tint ich, ret;\n\n\t \n\tif (di->ac.charger_online) {\n\t\tret = iio_read_channel_processed(di->adc_main_charger_c, &ich);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"%s ADC conv failed,\\n\", __func__);\n\t} else {\n\t\tich = 0;\n\t}\n\t \n\treturn ich * 1000;\n}\n\n \nstatic int ab8500_charger_usb_cv(struct ab8500_charger *di)\n{\n\tint ret;\n\tu8 val;\n\n\t \n\tif (di->usb.charger_online) {\n\t\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CH_USBCH_STAT1_REG, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (val & USB_CH_CV_ON)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_detect_chargers(struct ab8500_charger *di, bool probe)\n{\n\tint result = NO_PW_CONN;\n\tint ret;\n\tu8 val;\n\n\t \n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\tAB8500_CH_STATUS1_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (val & MAIN_CH_DET)\n\t\tresult = AC_PW_CONN;\n\n\t \n\n\tif (!probe) {\n\t\t \n\t\tmsleep(110);\n\t}\n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\tAB8500_CH_USBCH_STAT1_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\tdev_dbg(di->dev,\n\t\t\"%s AB8500_CH_USBCH_STAT1_REG %x\\n\", __func__,\n\t\tval);\n\tif ((val & VBUS_DET_DBNC1) && (val & VBUS_DET_DBNC100))\n\t\tresult |= USB_PW_CONN;\n\n\treturn result;\n}\n\n \nstatic int ab8500_charger_max_usb_curr(struct ab8500_charger *di,\n\t\tenum ab8500_charger_link_status link_status)\n{\n\tint ret = 0;\n\n\tdi->usb_device_is_unrecognised = false;\n\n\t \n\n\tswitch (link_status) {\n\tcase USB_STAT_STD_HOST_NC:\n\tcase USB_STAT_STD_HOST_C_NS:\n\tcase USB_STAT_STD_HOST_C_S:\n\t\tdev_dbg(di->dev, \"USB Type - Standard host is \"\n\t\t\t\"detected through USB driver\\n\");\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_HOST_CHG_HS_CHIRP:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_HOST_CHG_HS:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_ACA_RID_C_HS:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P9;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_ACA_RID_A:\n\t\t \n\t\tdev_dbg(di->dev, \"USB_STAT_ACA_RID_A detected\\n\");\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdi->is_aca_rid = 1;\n\t\tbreak;\n\tcase USB_STAT_ACA_RID_B:\n\t\t \n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_1P3;\n\t\tdev_dbg(di->dev, \"USB Type - 0x%02x MaxCurr: %d\", link_status,\n\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\tdi->is_aca_rid = 1;\n\t\tbreak;\n\tcase USB_STAT_HOST_CHG_NM:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_DEDICATED_CHG:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_1P5;\n\t\tdi->is_aca_rid = 0;\n\t\tbreak;\n\tcase USB_STAT_ACA_RID_C_HS_CHIRP:\n\tcase USB_STAT_ACA_RID_C_NM:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_1P5;\n\t\tdi->is_aca_rid = 1;\n\t\tbreak;\n\tcase USB_STAT_NOT_CONFIGURED:\n\t\tif (di->vbus_detected) {\n\t\t\tdi->usb_device_is_unrecognised = true;\n\t\t\tdev_dbg(di->dev, \"USB Type - Legacy charger.\\n\");\n\t\t\tdi->max_usb_in_curr.usb_type_max_ua =\n\t\t\t\t\t\tUSB_CH_IP_CUR_LVL_1P5;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase USB_STAT_HM_IDGND:\n\t\tdev_err(di->dev, \"USB Type - Charging not allowed\\n\");\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P05;\n\t\tret = -ENXIO;\n\t\tbreak;\n\tcase USB_STAT_RESERVED:\n\t\tif (is_ab8500(di->parent)) {\n\t\t\tdi->flags.vbus_collapse = true;\n\t\t\tdev_err(di->dev, \"USB Type - USB_STAT_RESERVED \"\n\t\t\t\t\t\t\"VBUS has collapsed\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"USB Type - Charging not allowed\\n\");\n\t\t\tdi->max_usb_in_curr.usb_type_max_ua =\n\t\t\t\t\t\tUSB_CH_IP_CUR_LVL_0P05;\n\t\t\tdev_dbg(di->dev, \"USB Type - 0x%02x MaxCurr: %d\",\n\t\t\t\tlink_status,\n\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\tcase USB_STAT_CARKIT_1:\n\tcase USB_STAT_CARKIT_2:\n\tcase USB_STAT_ACA_DOCK_CHARGER:\n\tcase USB_STAT_CHARGER_LINE_1:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tdev_dbg(di->dev, \"USB Type - 0x%02x MaxCurr: %d\", link_status,\n\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\tbreak;\n\tcase USB_STAT_NOT_VALID_LINK:\n\t\tdev_err(di->dev, \"USB Type invalid - try charging anyway\\n\");\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(di->dev, \"USB Type - Unknown\\n\");\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P05;\n\t\tret = -ENXIO;\n\t\tbreak;\n\t}\n\n\tdi->max_usb_in_curr.set_max_ua = di->max_usb_in_curr.usb_type_max_ua;\n\tdev_dbg(di->dev, \"USB Type - 0x%02x MaxCurr: %d\",\n\t\tlink_status, di->max_usb_in_curr.set_max_ua);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_read_usb_type(struct ab8500_charger *di)\n{\n\tint ret;\n\tu8 val;\n\n\tret = abx500_get_register_interruptible(di->dev,\n\t\tAB8500_INTERRUPT, AB8500_IT_SOURCE21_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\tif (is_ab8500(di->parent))\n\t\tret = abx500_get_register_interruptible(di->dev, AB8500_USB,\n\t\t\tAB8500_USB_LINE_STAT_REG, &val);\n\telse\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\tAB8500_USB, AB8500_USB_LINK1_STAT_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tif (is_ab8500(di->parent))\n\t\tval = (val & AB8500_USB_LINK_STATUS) >> USB_LINK_STATUS_SHIFT;\n\telse\n\t\tval = (val & AB8505_USB_LINK_STATUS) >> USB_LINK_STATUS_SHIFT;\n\tret = ab8500_charger_max_usb_curr(di,\n\t\t(enum ab8500_charger_link_status) val);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_detect_usb_type(struct ab8500_charger *di)\n{\n\tint i, ret;\n\tu8 val;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(250);\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\tAB8500_INTERRUPT, AB8500_IT_SOURCE21_REG,\n\t\t\t&val);\n\t\tdev_dbg(di->dev, \"%s AB8500_IT_SOURCE21_REG %x\\n\",\n\t\t\t__func__, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (is_ab8500(di->parent))\n\t\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\tAB8500_USB, AB8500_USB_LINE_STAT_REG, &val);\n\t\telse\n\t\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\tAB8500_USB, AB8500_USB_LINK1_STAT_REG, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(di->dev, \"%s AB8500_USB_LINE_STAT_REG %x\\n\", __func__,\n\t\t\tval);\n\t\t \n\n\t\t \n\t\tif (is_ab8500(di->parent))\n\t\t\tval = (val & AB8500_USB_LINK_STATUS) >>\n\t\t\t\t\t\t\tUSB_LINK_STATUS_SHIFT;\n\t\telse\n\t\t\tval = (val & AB8505_USB_LINK_STATUS) >>\n\t\t\t\t\t\t\tUSB_LINK_STATUS_SHIFT;\n\t\tif (val)\n\t\t\tbreak;\n\t}\n\tret = ab8500_charger_max_usb_curr(di,\n\t\t(enum ab8500_charger_link_status) val);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_voltage_map[] = {\n\t3500000,\n\t3525000,\n\t3550000,\n\t3575000,\n\t3600000,\n\t3625000,\n\t3650000,\n\t3675000,\n\t3700000,\n\t3725000,\n\t3750000,\n\t3775000,\n\t3800000,\n\t3825000,\n\t3850000,\n\t3875000,\n\t3900000,\n\t3925000,\n\t3950000,\n\t3975000,\n\t4000000,\n\t4025000,\n\t4050000,\n\t4060000,\n\t4070000,\n\t4080000,\n\t4090000,\n\t4100000,\n\t4110000,\n\t4120000,\n\t4130000,\n\t4140000,\n\t4150000,\n\t4160000,\n\t4170000,\n\t4180000,\n\t4190000,\n\t4200000,\n\t4210000,\n\t4220000,\n\t4230000,\n\t4240000,\n\t4250000,\n\t4260000,\n\t4270000,\n\t4280000,\n\t4290000,\n\t4300000,\n\t4310000,\n\t4320000,\n\t4330000,\n\t4340000,\n\t4350000,\n\t4360000,\n\t4370000,\n\t4380000,\n\t4390000,\n\t4400000,\n\t4410000,\n\t4420000,\n\t4430000,\n\t4440000,\n\t4450000,\n\t4460000,\n\t4470000,\n\t4480000,\n\t4490000,\n\t4500000,\n\t4510000,\n\t4520000,\n\t4530000,\n\t4540000,\n\t4550000,\n\t4560000,\n\t4570000,\n\t4580000,\n\t4590000,\n\t4600000,\n};\n\nstatic int ab8500_voltage_to_regval(int voltage_uv)\n{\n\tint i;\n\n\t \n\tif (voltage_uv < ab8500_charger_voltage_map[0])\n\t\treturn LOW_VOLT_REG;\n\n\tfor (i = 1; i < ARRAY_SIZE(ab8500_charger_voltage_map); i++) {\n\t\tif (voltage_uv < ab8500_charger_voltage_map[i])\n\t\t\treturn i - 1;\n\t}\n\n\t \n\ti = ARRAY_SIZE(ab8500_charger_voltage_map) - 1;\n\tif (voltage_uv == ab8500_charger_voltage_map[i])\n\t\treturn i;\n\telse\n\t\treturn -1;\n}\n\n \nstatic int ab8500_charge_input_curr_map[] = {\n\t50000, 98000, 193000, 290000, 380000, 450000, 500000, 600000,\n\t700000, 800000, 900000, 1000000, 1100000, 1300000, 1400000, 1500000,\n};\n\n \nstatic int ab8500_charge_output_curr_map[] = {\n\t100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000,\n\t900000, 1000000, 1100000, 1200000, 1300000, 1400000, 1500000, 1500000,\n};\n\nstatic int ab8500_current_to_regval(struct ab8500_charger *di, int curr_ua)\n{\n\tint i;\n\n\tif (curr_ua < ab8500_charge_output_curr_map[0])\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ab8500_charge_output_curr_map); i++) {\n\t\tif (curr_ua < ab8500_charge_output_curr_map[i])\n\t\t\treturn i - 1;\n\t}\n\n\t \n\ti =  ARRAY_SIZE(ab8500_charge_output_curr_map) - 1;\n\tif (curr_ua == ab8500_charge_output_curr_map[i])\n\t\treturn i;\n\telse\n\t\treturn -1;\n}\n\nstatic int ab8500_vbus_in_curr_to_regval(struct ab8500_charger *di, int curr_ua)\n{\n\tint i;\n\n\tif (curr_ua < ab8500_charge_input_curr_map[0])\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ab8500_charge_input_curr_map); i++) {\n\t\tif (curr_ua < ab8500_charge_input_curr_map[i])\n\t\t\treturn i - 1;\n\t}\n\n\t \n\ti =  ARRAY_SIZE(ab8500_charge_input_curr_map) - 1;\n\tif (curr_ua == ab8500_charge_input_curr_map[i])\n\t\treturn i;\n\telse\n\t\treturn -1;\n}\n\n \nstatic int ab8500_charger_get_usb_cur(struct ab8500_charger *di)\n{\n\tint ret = 0;\n\tswitch (di->usb_state.usb_current_ua) {\n\tcase 100000:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P09;\n\t\tbreak;\n\tcase 200000:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P19;\n\t\tbreak;\n\tcase 300000:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P29;\n\t\tbreak;\n\tcase 400000:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P38;\n\t\tbreak;\n\tcase 500000:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P5;\n\t\tbreak;\n\tdefault:\n\t\tdi->max_usb_in_curr.usb_type_max_ua = USB_CH_IP_CUR_LVL_0P05;\n\t\tret = -EPERM;\n\t\tbreak;\n\t}\n\tdi->max_usb_in_curr.set_max_ua = di->max_usb_in_curr.usb_type_max_ua;\n\treturn ret;\n}\n\n \nstatic bool ab8500_charger_check_continue_stepping(struct ab8500_charger *di,\n\t\t\t\t\t\t   int reg)\n{\n\tif (reg == AB8500_USBCH_IPT_CRNTLVL_REG)\n\t\treturn !di->flags.vbus_drop_end;\n\telse\n\t\treturn true;\n}\n\n \nstatic int ab8500_charger_set_current(struct ab8500_charger *di,\n\tint ich_ua, int reg)\n{\n\tint ret = 0;\n\tint curr_index, prev_curr_index, shift_value, i;\n\tu8 reg_value;\n\tu32 step_udelay;\n\tbool no_stepping = false;\n\n\tatomic_inc(&di->current_stepping_sessions);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\treg, &reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s read failed\\n\", __func__);\n\t\tgoto exit_set_current;\n\t}\n\n\tswitch (reg) {\n\tcase AB8500_MCH_IPT_CURLVL_REG:\n\t\tshift_value = MAIN_CH_INPUT_CURR_SHIFT;\n\t\tprev_curr_index = (reg_value >> shift_value);\n\t\tcurr_index = ab8500_current_to_regval(di, ich_ua);\n\t\tstep_udelay = STEP_UDELAY;\n\t\tif (!di->ac.charger_connected)\n\t\t\tno_stepping = true;\n\t\tbreak;\n\tcase AB8500_USBCH_IPT_CRNTLVL_REG:\n\t\tshift_value = VBUS_IN_CURR_LIM_SHIFT;\n\t\tprev_curr_index = (reg_value >> shift_value);\n\t\tcurr_index = ab8500_vbus_in_curr_to_regval(di, ich_ua);\n\t\tstep_udelay = STEP_UDELAY * 100;\n\n\t\tif (!di->usb.charger_connected)\n\t\t\tno_stepping = true;\n\t\tbreak;\n\tcase AB8500_CH_OPT_CRNTLVL_REG:\n\t\tshift_value = 0;\n\t\tprev_curr_index = (reg_value >> shift_value);\n\t\tcurr_index = ab8500_current_to_regval(di, ich_ua);\n\t\tstep_udelay = STEP_UDELAY;\n\t\tif (curr_index && (curr_index - prev_curr_index) > 1)\n\t\t\tstep_udelay *= 100;\n\n\t\tif (!di->usb.charger_connected && !di->ac.charger_connected)\n\t\t\tno_stepping = true;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev, \"%s current register not valid\\n\", __func__);\n\t\tret = -ENXIO;\n\t\tgoto exit_set_current;\n\t}\n\n\tif (curr_index < 0) {\n\t\tdev_err(di->dev, \"requested current limit out-of-range\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit_set_current;\n\t}\n\n\t \n\tif (prev_curr_index == curr_index) {\n\t\tdev_dbg(di->dev, \"%s current not changed for reg: 0x%02x\\n\",\n\t\t\t__func__, reg);\n\t\tret = 0;\n\t\tgoto exit_set_current;\n\t}\n\n\tdev_dbg(di->dev, \"%s set charger current: %d uA for reg: 0x%02x\\n\",\n\t\t__func__, ich_ua, reg);\n\n\tif (no_stepping) {\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\t\t\treg, (u8)curr_index << shift_value);\n\t\tif (ret)\n\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t} else if (prev_curr_index > curr_index) {\n\t\tfor (i = prev_curr_index - 1; i >= curr_index; i--) {\n\t\t\tdev_dbg(di->dev, \"curr change_1 to: %x for 0x%02x\\n\",\n\t\t\t\t(u8) i << shift_value, reg);\n\t\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\t\tAB8500_CHARGER, reg, (u8)i << shift_value);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\t\tgoto exit_set_current;\n\t\t\t}\n\t\t\tif (i != curr_index)\n\t\t\t\tusleep_range(step_udelay, step_udelay * 2);\n\t\t}\n\t} else {\n\t\tbool allow = true;\n\t\tfor (i = prev_curr_index + 1; i <= curr_index && allow; i++) {\n\t\t\tdev_dbg(di->dev, \"curr change_2 to: %x for 0x%02x\\n\",\n\t\t\t\t(u8)i << shift_value, reg);\n\t\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\t\tAB8500_CHARGER, reg, (u8)i << shift_value);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\t\tgoto exit_set_current;\n\t\t\t}\n\t\t\tif (i != curr_index)\n\t\t\t\tusleep_range(step_udelay, step_udelay * 2);\n\n\t\t\tallow = ab8500_charger_check_continue_stepping(di, reg);\n\t\t}\n\t}\n\nexit_set_current:\n\tatomic_dec(&di->current_stepping_sessions);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_set_vbus_in_curr(struct ab8500_charger *di,\n\t\tint ich_in_ua)\n{\n\tint min_value;\n\tint ret;\n\n\t \n\tmin_value = min(di->bm->chg_params->usb_curr_max_ua, ich_in_ua);\n\tif (di->max_usb_in_curr.set_max_ua > 0)\n\t\tmin_value = min(di->max_usb_in_curr.set_max_ua, min_value);\n\n\tif (di->usb_state.usb_current_ua >= 0)\n\t\tmin_value = min(di->usb_state.usb_current_ua, min_value);\n\n\tswitch (min_value) {\n\tcase 100000:\n\t\tif (di->vbat < VBAT_TRESH_IP_CUR_RED)\n\t\t\tmin_value = USB_CH_IP_CUR_LVL_0P05;\n\t\tbreak;\n\tcase 500000:\n\t\tif (di->vbat < VBAT_TRESH_IP_CUR_RED)\n\t\t\tmin_value = USB_CH_IP_CUR_LVL_0P45;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_info(di->dev, \"VBUS input current limit set to %d uA\\n\", min_value);\n\n\tmutex_lock(&di->usb_ipt_crnt_lock);\n\tret = ab8500_charger_set_current(di, min_value,\n\t\tAB8500_USBCH_IPT_CRNTLVL_REG);\n\tmutex_unlock(&di->usb_ipt_crnt_lock);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_set_main_in_curr(struct ab8500_charger *di,\n\tint ich_in_ua)\n{\n\treturn ab8500_charger_set_current(di, ich_in_ua,\n\t\tAB8500_MCH_IPT_CURLVL_REG);\n}\n\n \nstatic int ab8500_charger_set_output_curr(struct ab8500_charger *di,\n\tint ich_out_ua)\n{\n\treturn ab8500_charger_set_current(di, ich_out_ua,\n\t\tAB8500_CH_OPT_CRNTLVL_REG);\n}\n\n \nstatic int ab8500_charger_led_en(struct ab8500_charger *di, int on)\n{\n\tint ret;\n\n\tif (on) {\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_LED_INDICATOR_PWM_CTRL,\n\t\t\t(LED_IND_CUR_5MA | LED_INDICATOR_PWM_ENA));\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"Power ON LED failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_LED_INDICATOR_PWM_DUTY,\n\t\t\tLED_INDICATOR_PWM_DUTY_252_256);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"Set LED PWM duty cycle failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_LED_INDICATOR_PWM_CTRL,\n\t\t\tLED_INDICATOR_PWM_DIS);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"Power-off LED failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_ac_en(struct ux500_charger *charger,\n\tint enable, int vset_uv, int iset_ua)\n{\n\tint ret;\n\tint volt_index;\n\tint curr_index;\n\tint input_curr_index;\n\tu8 overshoot = 0;\n\n\tstruct ab8500_charger *di = to_ab8500_charger_ac_device_info(charger);\n\n\tif (enable) {\n\t\t \n\t\tif (!di->ac.charger_connected) {\n\t\t\tdev_err(di->dev, \"AC charger not connected\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t \n\t\tdev_dbg(di->dev, \"Enable AC: %duV %duA\\n\", vset_uv, iset_ua);\n\n\t\t \n\t\tif (!di->vddadc_en_ac) {\n\t\t\tret = regulator_enable(di->regu);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(di->dev,\n\t\t\t\t\t\"Failed to enable regulator\\n\");\n\t\t\telse\n\t\t\t\tdi->vddadc_en_ac = true;\n\t\t}\n\n\t\t \n\t\tvolt_index = ab8500_voltage_to_regval(vset_uv);\n\t\tcurr_index = ab8500_current_to_regval(di, iset_ua);\n\t\tinput_curr_index = ab8500_current_to_regval(di,\n\t\t\tdi->bm->chg_params->ac_curr_max_ua);\n\t\tif (volt_index < 0 || curr_index < 0 || input_curr_index < 0) {\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"Charger voltage or current too high, \"\n\t\t\t\t\"charging not started\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CH_VOLT_LVL_REG, (u8) volt_index);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = ab8500_charger_set_main_in_curr(di,\n\t\t\tdi->bm->chg_params->ac_curr_max_ua);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s Failed to set MainChInputCurr\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = ab8500_charger_set_output_curr(di, iset_ua);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s \"\n\t\t\t\t\"Failed to set ChOutputCurentLevel\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!di->bm->enable_overshoot)\n\t\t\tovershoot = MAIN_CH_NO_OVERSHOOT_ENA_N;\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_MCH_CTRL1, MAIN_CH_ENA | overshoot);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ab8500_charger_led_en(di, true);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"failed to enable LED\\n\");\n\n\t\tdi->ac.charger_online = 1;\n\t} else {\n\t\t \n\t\tif (is_ab8500_1p1_or_earlier(di->parent)) {\n\t\t\t \n\t\t\tif (di->ac_conn) {\n\t\t\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t\t&di->kick_wd_work,\n\t\t\t\t\tround_jiffies(WD_KICK_INTERVAL));\n\t\t\t}\n\n\t\t\t \n\t\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\t\tAB8500_CHARGER,\n\t\t\t\tAB8500_CH_VOLT_LVL_REG, CH_VOL_LVL_3P5);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(di->dev,\n\t\t\t\t\t\"%s write failed\\n\", __func__);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = ab8500_charger_set_output_curr(di, 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(di->dev, \"%s \"\n\t\t\t\t\t\"Failed to set ChOutputCurentLevel\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\t\tAB8500_CHARGER,\n\t\t\t\tAB8500_MCH_CTRL1, 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(di->dev,\n\t\t\t\t\t\"%s write failed\\n\", __func__);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = ab8500_charger_led_en(di, false);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"failed to disable LED\\n\");\n\n\t\tdi->ac.charger_online = 0;\n\t\tdi->ac.wd_expired = false;\n\n\t\t \n\t\tif (di->vddadc_en_ac) {\n\t\t\tregulator_disable(di->regu);\n\t\t\tdi->vddadc_en_ac = false;\n\t\t}\n\n\t\tdev_dbg(di->dev, \"%s Disabled AC charging\\n\", __func__);\n\t}\n\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_usb_en(struct ux500_charger *charger,\n\tint enable, int vset_uv, int ich_out_ua)\n{\n\tint ret;\n\tint volt_index;\n\tint curr_index;\n\tu8 overshoot = 0;\n\n\tstruct ab8500_charger *di = to_ab8500_charger_usb_device_info(charger);\n\n\tif (enable) {\n\t\t \n\t\tif (!di->usb.charger_connected) {\n\t\t\tdev_err(di->dev, \"USB charger not connected\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t \n\t\tif (!di->vddadc_en_usb) {\n\t\t\tret = regulator_enable(di->regu);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(di->dev,\n\t\t\t\t\t\"Failed to enable regulator\\n\");\n\t\t\telse\n\t\t\t\tdi->vddadc_en_usb = true;\n\t\t}\n\n\t\t \n\t\tdev_dbg(di->dev, \"Enable USB: %d uV %d uA\\n\", vset_uv, ich_out_ua);\n\n\t\t \n\t\tvolt_index = ab8500_voltage_to_regval(vset_uv);\n\t\tcurr_index = ab8500_current_to_regval(di, ich_out_ua);\n\t\tif (volt_index < 0 || curr_index < 0) {\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"Charger voltage or current too high, \"\n\t\t\t\t\"charging not started\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CH_VOLT_LVL_REG, (u8) volt_index);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tif (!di->bm->enable_overshoot)\n\t\t\tovershoot = USB_CHG_NO_OVERSHOOT_ENA_N;\n\n\t\t \n\t\tdev_dbg(di->dev,\n\t\t\t\"Enabling USB with write to AB8500_USBCH_CTRL1_REG\\n\");\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_USBCH_CTRL1_REG, USB_CH_ENA | overshoot);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ab8500_charger_led_en(di, true);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"failed to enable LED\\n\");\n\n\t\tdi->usb.charger_online = 1;\n\n\t\t \n\t\tret = ab8500_charger_set_vbus_in_curr(di,\n\t\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"setting USBChInputCurr failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ab8500_charger_set_output_curr(di, ich_out_ua);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s \"\n\t\t\t\t\"Failed to set ChOutputCurentLevel\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tqueue_delayed_work(di->charger_wq, &di->check_vbat_work, HZ);\n\n\t} else {\n\t\t \n\t\tdev_dbg(di->dev, \"%s Disabled USB charging\\n\", __func__);\n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER,\n\t\t\tAB8500_USBCH_CTRL1_REG, 0);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"%s write failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ab8500_charger_led_en(di, false);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"failed to disable LED\\n\");\n\t\t \n\t\tret = ab8500_charger_set_vbus_in_curr(di, 0);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"setting USBChInputCurr failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ab8500_charger_set_output_curr(di, 0);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev, \"%s \"\n\t\t\t\t\"Failed to reset ChOutputCurentLevel\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\tdi->usb.charger_online = 0;\n\t\tdi->usb.wd_expired = false;\n\n\t\t \n\t\tif (di->vddadc_en_usb) {\n\t\t\tregulator_disable(di->regu);\n\t\t\tdi->vddadc_en_usb = false;\n\t\t}\n\n\t\tdev_dbg(di->dev, \"%s Disabled USB charging\\n\", __func__);\n\n\t\t \n\t\tcancel_delayed_work(&di->check_vbat_work);\n\n\t}\n\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_usb_check_enable(struct ux500_charger *charger,\n\tint vset_uv, int iset_ua)\n{\n\tu8 usbch_ctrl1 = 0;\n\tint ret = 0;\n\n\tstruct ab8500_charger *di = to_ab8500_charger_usb_device_info(charger);\n\n\tif (!di->usb.charger_connected)\n\t\treturn ret;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\t\tAB8500_USBCH_CTRL1_REG, &usbch_ctrl1);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"ab8500 read failed %d\\n\", __LINE__);\n\t\treturn ret;\n\t}\n\tdev_dbg(di->dev, \"USB charger ctrl: 0x%02x\\n\", usbch_ctrl1);\n\n\tif (!(usbch_ctrl1 & USB_CH_ENA)) {\n\t\tdev_info(di->dev, \"Charging has been disabled abnormally and will be re-enabled\\n\");\n\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_CHARGER, AB8500_CHARGER_CTRL,\n\t\t\t\t\tDROP_COUNT_RESET, DROP_COUNT_RESET);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"ab8500 write failed %d\\n\", __LINE__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ab8500_charger_usb_en(&di->usb_chg, true, vset_uv, iset_ua);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"Failed to enable VBUS charger %d\\n\",\n\t\t\t\t\t__LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_ac_check_enable(struct ux500_charger *charger,\n\tint vset_uv, int iset_ua)\n{\n\tu8 mainch_ctrl1 = 0;\n\tint ret = 0;\n\n\tstruct ab8500_charger *di = to_ab8500_charger_ac_device_info(charger);\n\n\tif (!di->ac.charger_connected)\n\t\treturn ret;\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\t\tAB8500_MCH_CTRL1, &mainch_ctrl1);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"ab8500 read failed %d\\n\", __LINE__);\n\t\treturn ret;\n\t}\n\tdev_dbg(di->dev, \"AC charger ctrl: 0x%02x\\n\", mainch_ctrl1);\n\n\tif (!(mainch_ctrl1 & MAIN_CH_ENA)) {\n\t\tdev_info(di->dev, \"Charging has been disabled abnormally and will be re-enabled\\n\");\n\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_CHARGER, AB8500_CHARGER_CTRL,\n\t\t\t\t\tDROP_COUNT_RESET, DROP_COUNT_RESET);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"ab8500 write failed %d\\n\", __LINE__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ab8500_charger_ac_en(&di->usb_chg, true, vset_uv, iset_ua);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"failed to enable AC charger %d\\n\",\n\t\t\t\t__LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_watchdog_kick(struct ux500_charger *charger)\n{\n\tint ret;\n\tstruct ab8500_charger *di;\n\n\tif (charger->psy->desc->type == POWER_SUPPLY_TYPE_MAINS)\n\t\tdi = to_ab8500_charger_ac_device_info(charger);\n\telse if (charger->psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\tdi = to_ab8500_charger_usb_device_info(charger);\n\telse\n\t\treturn -ENXIO;\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\tAB8500_CHARG_WD_CTRL, CHARG_WD_KICK);\n\tif (ret)\n\t\tdev_err(di->dev, \"Failed to kick WD!\\n\");\n\n\treturn ret;\n}\n\n \nstatic int ab8500_charger_update_charger_current(struct ux500_charger *charger,\n\t\tint ich_out_ua)\n{\n\tint ret;\n\tstruct ab8500_charger *di;\n\n\tif (charger->psy->desc->type == POWER_SUPPLY_TYPE_MAINS)\n\t\tdi = to_ab8500_charger_ac_device_info(charger);\n\telse if (charger->psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\tdi = to_ab8500_charger_usb_device_info(charger);\n\telse\n\t\treturn -ENXIO;\n\n\tret = ab8500_charger_set_output_curr(di, ich_out_ua);\n\tif (ret) {\n\t\tdev_err(di->dev, \"%s \"\n\t\t\t\"Failed to set ChOutputCurentLevel\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\t\tAB8500_CHARGER_CTRL, DROP_COUNT_RESET);\n\tif (ret) {\n\t\tdev_err(di->dev, \"%s write failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ab8500_charger_get_ext_psy_data(struct device *dev, void *data)\n{\n\tstruct power_supply *psy;\n\tstruct power_supply *ext = dev_get_drvdata(dev);\n\tconst char **supplicants = (const char **)ext->supplied_to;\n\tstruct ab8500_charger *di;\n\tunion power_supply_propval ret;\n\tint j;\n\tstruct ux500_charger *usb_chg;\n\n\tusb_chg = (struct ux500_charger *)data;\n\tpsy = usb_chg->psy;\n\n\tdi = to_ab8500_charger_usb_device_info(usb_chg);\n\n\t \n\tj = match_string(supplicants, ext->num_supplicants, psy->desc->name);\n\tif (j < 0)\n\t\treturn 0;\n\n\t \n\tfor (j = 0; j < ext->desc->num_properties; j++) {\n\t\tenum power_supply_property prop;\n\t\tprop = ext->desc->properties[j];\n\n\t\tif (power_supply_get_property(ext, prop, &ret))\n\t\t\tcontinue;\n\n\t\tswitch (prop) {\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\t \n\t\t\t\tdev_dbg(di->dev, \"get VBAT from %s\\n\",\n\t\t\t\t\tdev_name(&ext->dev));\n\t\t\t\tdi->vbat = ret.intval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void ab8500_charger_check_vbat_work(struct work_struct *work)\n{\n\tint t = 10;\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, check_vbat_work.work);\n\n\tclass_for_each_device(power_supply_class, NULL,\n\t\t\t      &di->usb_chg, ab8500_charger_get_ext_psy_data);\n\n\t \n\tif (di->old_vbat == 0)\n\t\tdi->old_vbat = di->vbat;\n\n\tif (!((di->old_vbat <= VBAT_TRESH_IP_CUR_RED &&\n\t\tdi->vbat <= VBAT_TRESH_IP_CUR_RED) ||\n\t\t(di->old_vbat > VBAT_TRESH_IP_CUR_RED &&\n\t\tdi->vbat > VBAT_TRESH_IP_CUR_RED))) {\n\n\t\tdev_dbg(di->dev, \"Vbat did cross threshold, curr: %d, new: %d,\"\n\t\t\t\" old: %d\\n\", di->max_usb_in_curr.usb_type_max_ua,\n\t\t\tdi->vbat, di->old_vbat);\n\t\tab8500_charger_set_vbus_in_curr(di,\n\t\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\tpower_supply_changed(di->usb_chg.psy);\n\t}\n\n\tdi->old_vbat = di->vbat;\n\n\t \n\tif (di->vbat < (VBAT_TRESH_IP_CUR_RED + 100000) &&\n\t\t(di->vbat > (VBAT_TRESH_IP_CUR_RED - 100000)))\n\t\t\tt = 1;\n\n\tqueue_delayed_work(di->charger_wq, &di->check_vbat_work, t * HZ);\n}\n\n \nstatic void ab8500_charger_check_hw_failure_work(struct work_struct *work)\n{\n\tint ret;\n\tu8 reg_value;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, check_hw_failure_work.work);\n\n\t \n\tif (di->flags.mainextchnotok) {\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER, AB8500_CH_STATUS2_REG, &reg_value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (!(reg_value & MAIN_CH_NOK)) {\n\t\t\tdi->flags.mainextchnotok = false;\n\t\t\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\t\t}\n\t}\n\tif (di->flags.vbus_ovv) {\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER, AB8500_CH_USBCH_STAT2_REG,\n\t\t\t&reg_value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (!(reg_value & VBUS_OVV_TH)) {\n\t\t\tdi->flags.vbus_ovv = false;\n\t\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t\t}\n\t}\n\t \n\tif (di->flags.mainextchnotok || di->flags.vbus_ovv) {\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t&di->check_hw_failure_work, round_jiffies(HZ));\n\t}\n}\n\n \nstatic void ab8500_charger_kick_watchdog_work(struct work_struct *work)\n{\n\tint ret;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, kick_wd_work.work);\n\n\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\tAB8500_CHARG_WD_CTRL, CHARG_WD_KICK);\n\tif (ret)\n\t\tdev_err(di->dev, \"Failed to kick WD!\\n\");\n\n\t \n\tqueue_delayed_work(di->charger_wq,\n\t\t&di->kick_wd_work, round_jiffies(WD_KICK_INTERVAL));\n}\n\n \nstatic void ab8500_charger_ac_work(struct work_struct *work)\n{\n\tint ret;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, ac_work);\n\n\t \n\tret = ab8500_charger_detect_chargers(di, false);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (ret & AC_PW_CONN) {\n\t\tdi->ac.charger_connected = 1;\n\t\tdi->ac_conn = true;\n\t} else {\n\t\tdi->ac.charger_connected = 0;\n\t}\n\n\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\tsysfs_notify(&di->ac_chg.psy->dev.kobj, NULL, \"present\");\n}\n\nstatic void ab8500_charger_usb_attached_work(struct work_struct *work)\n{\n\tstruct ab8500_charger *di = container_of(work,\n\t\t\t\t\t\t struct ab8500_charger,\n\t\t\t\t\t\t usb_charger_attached_work.work);\n\tint usbch = (USB_CH_VBUSDROP | USB_CH_VBUSDETDBNC);\n\tint ret, i;\n\tu8 statval;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\t\t\t\tAB8500_CHARGER,\n\t\t\t\t\t\t\tAB8500_CH_USBCH_STAT1_REG,\n\t\t\t\t\t\t\t&statval);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"ab8500 read failed %d\\n\", __LINE__);\n\t\t\tgoto reschedule;\n\t\t}\n\t\tif ((statval & usbch) != usbch)\n\t\t\tgoto reschedule;\n\n\t\tmsleep(CHARGER_STATUS_POLL);\n\t}\n\n\tab8500_charger_usb_en(&di->usb_chg, 0, 0, 0);\n\n\tmutex_lock(&di->charger_attached_mutex);\n\tmutex_unlock(&di->charger_attached_mutex);\n\n\treturn;\n\nreschedule:\n\tqueue_delayed_work(di->charger_wq,\n\t\t\t   &di->usb_charger_attached_work,\n\t\t\t   HZ);\n}\n\nstatic void ab8500_charger_ac_attached_work(struct work_struct *work)\n{\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\t\t\t\t\t struct ab8500_charger,\n\t\t\t\t\t\t ac_charger_attached_work.work);\n\tint mainch = (MAIN_CH_STATUS2_MAINCHGDROP |\n\t\t      MAIN_CH_STATUS2_MAINCHARGERDETDBNC);\n\tint ret, i;\n\tu8 statval;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\t\t\t\tAB8500_CHARGER,\n\t\t\t\t\t\t\tAB8500_CH_STATUS2_REG,\n\t\t\t\t\t\t\t&statval);\n\t\tif (ret < 0) {\n\t\t\tdev_err(di->dev, \"ab8500 read failed %d\\n\", __LINE__);\n\t\t\tgoto reschedule;\n\t\t}\n\n\t\tif ((statval & mainch) != mainch)\n\t\t\tgoto reschedule;\n\n\t\tmsleep(CHARGER_STATUS_POLL);\n\t}\n\n\tab8500_charger_ac_en(&di->ac_chg, 0, 0, 0);\n\tqueue_work(di->charger_wq, &di->ac_work);\n\n\tmutex_lock(&di->charger_attached_mutex);\n\tmutex_unlock(&di->charger_attached_mutex);\n\n\treturn;\n\nreschedule:\n\tqueue_delayed_work(di->charger_wq,\n\t\t\t   &di->ac_charger_attached_work,\n\t\t\t   HZ);\n}\n\n \nstatic void ab8500_charger_detect_usb_type_work(struct work_struct *work)\n{\n\tint ret;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, detect_usb_type_work);\n\n\t \n\tret = ab8500_charger_detect_chargers(di, false);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (!(ret & USB_PW_CONN)) {\n\t\tdev_dbg(di->dev, \"%s di->vbus_detected = false\\n\", __func__);\n\t\tdi->vbus_detected = false;\n\t\tab8500_charger_set_usb_connected(di, false);\n\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t} else {\n\t\tdev_dbg(di->dev, \"%s di->vbus_detected = true\\n\", __func__);\n\t\tdi->vbus_detected = true;\n\n\t\tif (is_ab8500_1p1_or_earlier(di->parent)) {\n\t\t\tret = ab8500_charger_detect_usb_type(di);\n\t\t\tif (!ret) {\n\t\t\t\tab8500_charger_set_usb_connected(di, true);\n\t\t\t\tab8500_power_supply_changed(di,\n\t\t\t\t\t\t\t    di->usb_chg.psy);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (di->vbus_detected_start) {\n\t\t\t\tdi->vbus_detected_start = false;\n\t\t\t\tret = ab8500_charger_detect_usb_type(di);\n\t\t\t\tif (!ret) {\n\t\t\t\t\tab8500_charger_set_usb_connected(di,\n\t\t\t\t\t\ttrue);\n\t\t\t\t\tab8500_power_supply_changed(di,\n\t\t\t\t\t\tdi->usb_chg.psy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void ab8500_charger_usb_link_attach_work(struct work_struct *work)\n{\n\tstruct ab8500_charger *di =\n\t\tcontainer_of(work, struct ab8500_charger, attach_work.work);\n\tint ret;\n\n\t \n\tif (!di->usb.charger_online) {\n\t\tret = ab8500_charger_set_vbus_in_curr(di,\n\t\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tab8500_charger_set_usb_connected(di, true);\n\tab8500_power_supply_changed(di, di->usb_chg.psy);\n}\n\n \nstatic void ab8500_charger_usb_link_status_work(struct work_struct *work)\n{\n\tint detected_chargers;\n\tint ret;\n\tu8 val;\n\tu8 link_status;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, usb_link_status_work);\n\n\t \n\tdetected_chargers = ab8500_charger_detect_chargers(di, false);\n\tif (detected_chargers < 0)\n\t\treturn;\n\n\t \n\tif (is_ab8500(di->parent))\n\t\tret = abx500_get_register_interruptible(di->dev, AB8500_USB,\n\t\t\t\t\tAB8500_USB_LINE_STAT_REG, &val);\n\telse\n\t\tret = abx500_get_register_interruptible(di->dev, AB8500_USB,\n\t\t\t\t\tAB8500_USB_LINK1_STAT_REG, &val);\n\n\tif (ret >= 0)\n\t\tdev_dbg(di->dev, \"UsbLineStatus register = 0x%02x\\n\", val);\n\telse\n\t\tdev_dbg(di->dev, \"Error reading USB link status\\n\");\n\n\tif (is_ab8500(di->parent))\n\t\tlink_status = AB8500_USB_LINK_STATUS;\n\telse\n\t\tlink_status = AB8505_USB_LINK_STATUS;\n\n\tif (detected_chargers & USB_PW_CONN) {\n\t\tif (((val & link_status) >> USB_LINK_STATUS_SHIFT) ==\n\t\t\t\tUSB_STAT_NOT_VALID_LINK &&\n\t\t\t\tdi->invalid_charger_detect_state == 0) {\n\t\t\tdev_dbg(di->dev,\n\t\t\t\t\t\"Invalid charger detected, state= 0\\n\");\n\t\t\t \n\t\t\tabx500_mask_and_set_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_CHARGER, AB8500_USBCH_CTRL1_REG,\n\t\t\t\t\tUSB_CH_ENA, USB_CH_ENA);\n\t\t\t \n\t\t\tabx500_mask_and_set_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_USB, AB8500_USB_LINE_CTRL2_REG,\n\t\t\t\t\tUSB_CH_DET, USB_CH_DET);\n\t\t\tdi->invalid_charger_detect_state = 1;\n\t\t\t \n\t\t\treturn;\n\n\t\t}\n\t\tif (di->invalid_charger_detect_state == 1) {\n\t\t\tdev_dbg(di->dev,\n\t\t\t\t\t\"Invalid charger detected, state= 1\\n\");\n\t\t\t \n\t\t\tabx500_mask_and_set_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_USB, AB8500_USB_LINE_CTRL2_REG,\n\t\t\t\t\tUSB_CH_DET, 0x00);\n\t\t\t \n\t\t\tif (is_ab8500(di->parent))\n\t\t\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_USB, AB8500_USB_LINE_STAT_REG,\n\t\t\t\t\t&val);\n\t\t\telse\n\t\t\t\tret = abx500_get_register_interruptible(di->dev,\n\t\t\t\t\tAB8500_USB, AB8500_USB_LINK1_STAT_REG,\n\t\t\t\t\t&val);\n\n\t\t\tdev_dbg(di->dev, \"USB link status= 0x%02x\\n\",\n\t\t\t\t(val & link_status) >> USB_LINK_STATUS_SHIFT);\n\t\t\tdi->invalid_charger_detect_state = 2;\n\t\t}\n\t} else {\n\t\tdi->invalid_charger_detect_state = 0;\n\t}\n\n\tif (!(detected_chargers & USB_PW_CONN)) {\n\t\tdi->vbus_detected = false;\n\t\tab8500_charger_set_usb_connected(di, false);\n\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t\treturn;\n\t}\n\n\tdev_dbg(di->dev,\"%s di->vbus_detected = true\\n\",__func__);\n\tdi->vbus_detected = true;\n\tret = ab8500_charger_read_usb_type(di);\n\tif (ret) {\n\t\tif (ret == -ENXIO) {\n\t\t\t \n\t\t\tab8500_charger_set_usb_connected(di, false);\n\t\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (di->usb_device_is_unrecognised) {\n\t\tdev_dbg(di->dev,\n\t\t\t\"Potential Legacy Charger device. \"\n\t\t\t\"Delay work for %d msec for USB enum \"\n\t\t\t\"to finish\",\n\t\t\tWAIT_ACA_RID_ENUMERATION);\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t   &di->attach_work,\n\t\t\t\t   msecs_to_jiffies(WAIT_ACA_RID_ENUMERATION));\n\t} else if (di->is_aca_rid == 1) {\n\t\t \n\t\tdi->is_aca_rid++;\n\t\tdev_dbg(di->dev,\n\t\t\t\"%s Wait %d msec for USB enum to finish\",\n\t\t\t__func__, WAIT_ACA_RID_ENUMERATION);\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t   &di->attach_work,\n\t\t\t\t   msecs_to_jiffies(WAIT_ACA_RID_ENUMERATION));\n\t} else {\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t   &di->attach_work,\n\t\t\t\t   0);\n\t}\n}\n\nstatic void ab8500_charger_usb_state_changed_work(struct work_struct *work)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, usb_state_changed_work.work);\n\n\tif (!di->vbus_detected)\t{\n\t\tdev_dbg(di->dev,\n\t\t\t\"%s !di->vbus_detected\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&di->usb_state.usb_lock, flags);\n\tdi->usb_state.state = di->usb_state.state_tmp;\n\tdi->usb_state.usb_current_ua = di->usb_state.usb_current_tmp_ua;\n\tspin_unlock_irqrestore(&di->usb_state.usb_lock, flags);\n\n\tdev_dbg(di->dev, \"%s USB state: 0x%02x uA: %d\\n\",\n\t\t__func__, di->usb_state.state, di->usb_state.usb_current_ua);\n\n\tswitch (di->usb_state.state) {\n\tcase AB8500_BM_USB_STATE_RESET_HS:\n\tcase AB8500_BM_USB_STATE_RESET_FS:\n\tcase AB8500_BM_USB_STATE_SUSPEND:\n\tcase AB8500_BM_USB_STATE_MAX:\n\t\tab8500_charger_set_usb_connected(di, false);\n\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t\tbreak;\n\n\tcase AB8500_BM_USB_STATE_RESUME:\n\t\t \n\t\tmsleep(1000);\n\t\tfallthrough;\n\tcase AB8500_BM_USB_STATE_CONFIGURED:\n\t\t \n\t\tif (!ab8500_charger_get_usb_cur(di)) {\n\t\t\t \n\t\t\tret = ab8500_charger_set_vbus_in_curr(di,\n\t\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\n\t\t\tab8500_charger_set_usb_connected(di, true);\n\t\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ab8500_charger_check_usbchargernotok_work(struct work_struct *work)\n{\n\tint ret;\n\tu8 reg_value;\n\tbool prev_status;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, check_usbchgnotok_work.work);\n\n\t \n\tret = abx500_get_register_interruptible(di->dev,\n\t\tAB8500_CHARGER, AB8500_CH_USBCH_STAT2_REG, &reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn;\n\t}\n\tprev_status = di->flags.usbchargernotok;\n\n\tif (reg_value & VBUS_CH_NOK) {\n\t\tdi->flags.usbchargernotok = true;\n\t\t \n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t&di->check_usbchgnotok_work, HZ);\n\t} else {\n\t\tdi->flags.usbchargernotok = false;\n\t\tdi->flags.vbus_collapse = false;\n\t}\n\n\tif (prev_status != di->flags.usbchargernotok)\n\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n}\n\n \nstatic void ab8500_charger_check_main_thermal_prot_work(\n\tstruct work_struct *work)\n{\n\tint ret;\n\tu8 reg_value;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, check_main_thermal_prot_work);\n\n\t \n\tret = abx500_get_register_interruptible(di->dev,\n\t\tAB8500_CHARGER, AB8500_CH_STATUS2_REG, &reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (reg_value & MAIN_CH_TH_PROT)\n\t\tdi->flags.main_thermal_prot = true;\n\telse\n\t\tdi->flags.main_thermal_prot = false;\n\n\tab8500_power_supply_changed(di, di->ac_chg.psy);\n}\n\n \nstatic void ab8500_charger_check_usb_thermal_prot_work(\n\tstruct work_struct *work)\n{\n\tint ret;\n\tu8 reg_value;\n\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, check_usb_thermal_prot_work);\n\n\t \n\tret = abx500_get_register_interruptible(di->dev,\n\t\tAB8500_CHARGER, AB8500_CH_USBCH_STAT2_REG, &reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s ab8500 read failed\\n\", __func__);\n\t\treturn;\n\t}\n\tif (reg_value & USB_CH_TH_PROT)\n\t\tdi->flags.usb_thermal_prot = true;\n\telse\n\t\tdi->flags.usb_thermal_prot = false;\n\n\tab8500_power_supply_changed(di, di->usb_chg.psy);\n}\n\n \nstatic irqreturn_t ab8500_charger_mainchunplugdet_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"Main charger unplugged\\n\");\n\tqueue_work(di->charger_wq, &di->ac_work);\n\n\tcancel_delayed_work_sync(&di->ac_charger_attached_work);\n\tmutex_lock(&di->charger_attached_mutex);\n\tmutex_unlock(&di->charger_attached_mutex);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_mainchplugdet_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"Main charger plugged\\n\");\n\tqueue_work(di->charger_wq, &di->ac_work);\n\n\tmutex_lock(&di->charger_attached_mutex);\n\tmutex_unlock(&di->charger_attached_mutex);\n\n\tif (is_ab8500(di->parent))\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t   &di->ac_charger_attached_work,\n\t\t\t   HZ);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_mainextchnotok_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"Main charger not ok\\n\");\n\tdi->flags.mainextchnotok = true;\n\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\n\t \n\tqueue_delayed_work(di->charger_wq, &di->check_hw_failure_work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_mainchthprotr_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev,\n\t\t\"Die temp above Main charger thermal protection threshold\\n\");\n\tqueue_work(di->charger_wq, &di->check_main_thermal_prot_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_mainchthprotf_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev,\n\t\t\"Die temp ok for Main charger thermal protection threshold\\n\");\n\tqueue_work(di->charger_wq, &di->check_main_thermal_prot_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ab8500_charger_vbus_drop_end_work(struct work_struct *work)\n{\n\tstruct ab8500_charger *di = container_of(work,\n\t\tstruct ab8500_charger, vbus_drop_end_work.work);\n\tint ret, curr_ua;\n\tu8 reg_value;\n\n\tdi->flags.vbus_drop_end = false;\n\n\t \n\tabx500_set_register_interruptible(di->dev,\n\t\t\t\t  AB8500_CHARGER, AB8500_CHARGER_CTRL, 0x01);\n\n\tret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CH_USBCH_STAT2_REG, &reg_value);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s read failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcurr_ua = ab8500_charge_input_curr_map[\n\t\treg_value >> AUTO_VBUS_IN_CURR_LIM_SHIFT];\n\n\tif (di->max_usb_in_curr.calculated_max_ua != curr_ua) {\n\t\t \n\t\tdi->max_usb_in_curr.calculated_max_ua = curr_ua;\n\t\tdev_dbg(di->dev,\n\t\t\t \"VBUS input current limiting to %d uA\\n\",\n\t\t\t di->max_usb_in_curr.calculated_max_ua);\n\t} else {\n\t\t \n\t\tdi->max_usb_in_curr.set_max_ua =\n\t\t\tdi->max_usb_in_curr.calculated_max_ua;\n\t\tdev_dbg(di->dev,\n\t\t\t \"VBUS input current limited to %d uA\\n\",\n\t\t\t di->max_usb_in_curr.set_max_ua);\n\t}\n\n\tif (di->usb.charger_connected)\n\t\tab8500_charger_set_vbus_in_curr(di,\n\t\t\t\t\tdi->max_usb_in_curr.usb_type_max_ua);\n}\n\n \nstatic irqreturn_t ab8500_charger_vbusdetf_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdi->vbus_detected = false;\n\tdev_dbg(di->dev, \"VBUS falling detected\\n\");\n\tqueue_work(di->charger_wq, &di->detect_usb_type_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_vbusdetr_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdi->vbus_detected = true;\n\tdev_dbg(di->dev, \"VBUS rising detected\\n\");\n\n\tqueue_work(di->charger_wq, &di->detect_usb_type_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_usblinkstatus_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"USB link status changed\\n\");\n\n\tqueue_work(di->charger_wq, &di->usb_link_status_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_usbchthprotr_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev,\n\t\t\"Die temp above USB charger thermal protection threshold\\n\");\n\tqueue_work(di->charger_wq, &di->check_usb_thermal_prot_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_usbchthprotf_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev,\n\t\t\"Die temp ok for USB charger thermal protection threshold\\n\");\n\tqueue_work(di->charger_wq, &di->check_usb_thermal_prot_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_usbchargernotokr_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"Not allowed USB charger detected\\n\");\n\tqueue_delayed_work(di->charger_wq, &di->check_usbchgnotok_work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_chwdexp_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"Charger watchdog expired\\n\");\n\n\t \n\tif (di->ac.charger_online) {\n\t\tdi->ac.wd_expired = true;\n\t\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\t}\n\tif (di->usb.charger_online) {\n\t\tdi->usb.wd_expired = true;\n\t\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_vbuschdropend_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"VBUS charger drop ended\\n\");\n\tdi->flags.vbus_drop_end = true;\n\n\t \n\tqueue_delayed_work(di->charger_wq, &di->vbus_drop_end_work,\n\t\t\t   round_jiffies(VBUS_IN_CURR_LIM_RETRY_SET_TIME * HZ));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ab8500_charger_vbusovv_handler(int irq, void *_di)\n{\n\tstruct ab8500_charger *di = _di;\n\n\tdev_dbg(di->dev, \"VBUS overvoltage detected\\n\");\n\tdi->flags.vbus_ovv = true;\n\tab8500_power_supply_changed(di, di->usb_chg.psy);\n\n\t \n\tqueue_delayed_work(di->charger_wq, &di->check_hw_failure_work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ab8500_charger_ac_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct ab8500_charger *di;\n\tint ret;\n\n\tdi = to_ab8500_charger_ac_device_info(psy_to_ux500_charger(psy));\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (di->flags.mainextchnotok)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\telse if (di->ac.wd_expired || di->usb.wd_expired)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\telse if (di->flags.main_thermal_prot)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = di->ac.charger_online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = di->ac.charger_connected;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = ab8500_charger_get_ac_voltage(di);\n\t\tif (ret >= 0)\n\t\t\tdi->ac.charger_voltage_uv = ret;\n\t\t \n\t\tval->intval = di->ac.charger_voltage_uv;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\t \n\t\tdi->ac.cv_active = ab8500_charger_ac_cv(di);\n\t\tval->intval = di->ac.cv_active;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = ab8500_charger_get_ac_current(di);\n\t\tif (ret >= 0)\n\t\t\tdi->ac.charger_current_ua = ret;\n\t\tval->intval = di->ac.charger_current_ua;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int ab8500_charger_usb_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct ab8500_charger *di;\n\tint ret;\n\n\tdi = to_ab8500_charger_usb_device_info(psy_to_ux500_charger(psy));\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (di->flags.usbchargernotok)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\telse if (di->ac.wd_expired || di->usb.wd_expired)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\telse if (di->flags.usb_thermal_prot)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (di->flags.vbus_ovv)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = di->usb.charger_online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = di->usb.charger_connected;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = ab8500_charger_get_vbus_voltage(di);\n\t\tif (ret >= 0)\n\t\t\tdi->usb.charger_voltage_uv = ret;\n\t\tval->intval = di->usb.charger_voltage_uv;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\t \n\t\tdi->usb.cv_active = ab8500_charger_usb_cv(di);\n\t\tval->intval = di->usb.cv_active;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = ab8500_charger_get_usb_current(di);\n\t\tif (ret >= 0)\n\t\t\tdi->usb.charger_current_ua = ret;\n\t\tval->intval = di->usb.charger_current_ua;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\t \n\t\tif (di->flags.vbus_collapse)\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int ab8500_charger_init_hw_registers(struct ab8500_charger *di)\n{\n\tint ret = 0;\n\n\t \n\tif (!is_ab8500_1p1_or_earlier(di->parent)) {\n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER,\n\t\t\tAB8500_CH_VOLT_LVL_MAX_REG, CH_VOL_LVL_4P6);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"failed to set CH_VOLT_LVL_MAX_REG\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER, AB8500_CH_OPT_CRNTLVL_MAX_REG,\n\t\t\tCH_OP_CUR_LVL_1P6);\n\t\tif (ret) {\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"failed to set CH_OPT_CRNTLVL_MAX_REG\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (is_ab8505_2p0(di->parent))\n\t\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER,\n\t\t\tAB8500_USBCH_CTRL2_REG,\n\t\t\tVBUS_AUTO_IN_CURR_LIM_ENA,\n\t\t\tVBUS_AUTO_IN_CURR_LIM_ENA);\n\telse\n\t\t \n\t\tret = abx500_set_register_interruptible(di->dev,\n\t\t\tAB8500_CHARGER,\n\t\t\tAB8500_USBCH_CTRL2_REG,\n\t\t\tVBUS_OVV_SELECT_6P3V | VBUS_AUTO_IN_CURR_LIM_ENA);\n\tif (ret) {\n\t\tdev_err(di->dev,\n\t\t\t\"failed to set automatic current limitation\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_OTP_EMUL, AB8500_OTP_CONF_15, OTP_ENABLE_WD);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to enable main WD in OTP\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WDOG_CTRL_REG, MAIN_WDOG_ENA);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to enable main watchdog\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tudelay(63);\n\n\t \n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WDOG_CTRL_REG,\n\t\t(MAIN_WDOG_ENA | MAIN_WDOG_KICK));\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to kick main watchdog\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WDOG_CTRL_REG, MAIN_WDOG_DIS);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to disable main watchdog\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\tAB8500_CH_WD_TIMER_REG, WD_TIMER);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to set charger watchdog timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tret = ab8500_charger_led_en(di, false);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"failed to disable LED\\n\");\n\t\tgoto out;\n\t}\n\n\tret = abx500_set_register_interruptible(di->dev,\n\t\tAB8500_RTC,\n\t\tAB8500_RTC_BACKUP_CHG_REG,\n\t\t(di->bm->bkup_bat_v & 0x3) | di->bm->bkup_bat_i);\n\tif (ret) {\n\t\tdev_err(di->dev, \"failed to setup backup battery charging\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\tAB8500_RTC, AB8500_RTC_CTRL_REG,\n\t\tRTC_BUP_CH_ENA, RTC_BUP_CH_ENA);\n\tif (ret < 0) {\n\t\tdev_err(di->dev, \"%s mask and set failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic struct ab8500_charger_interrupts ab8500_charger_irq[] = {\n\t{\"MAIN_CH_UNPLUG_DET\", ab8500_charger_mainchunplugdet_handler},\n\t{\"MAIN_CHARGE_PLUG_DET\", ab8500_charger_mainchplugdet_handler},\n\t{\"MAIN_EXT_CH_NOT_OK\", ab8500_charger_mainextchnotok_handler},\n\t{\"MAIN_CH_TH_PROT_R\", ab8500_charger_mainchthprotr_handler},\n\t{\"MAIN_CH_TH_PROT_F\", ab8500_charger_mainchthprotf_handler},\n\t{\"VBUS_DET_F\", ab8500_charger_vbusdetf_handler},\n\t{\"VBUS_DET_R\", ab8500_charger_vbusdetr_handler},\n\t{\"USB_LINK_STATUS\", ab8500_charger_usblinkstatus_handler},\n\t{\"USB_CH_TH_PROT_R\", ab8500_charger_usbchthprotr_handler},\n\t{\"USB_CH_TH_PROT_F\", ab8500_charger_usbchthprotf_handler},\n\t{\"USB_CHARGER_NOT_OKR\", ab8500_charger_usbchargernotokr_handler},\n\t{\"VBUS_OVV\", ab8500_charger_vbusovv_handler},\n\t{\"CH_WD_EXP\", ab8500_charger_chwdexp_handler},\n\t{\"VBUS_CH_DROP_END\", ab8500_charger_vbuschdropend_handler},\n};\n\nstatic int ab8500_charger_usb_notifier_call(struct notifier_block *nb,\n\t\tunsigned long event, void *power)\n{\n\tstruct ab8500_charger *di =\n\t\tcontainer_of(nb, struct ab8500_charger, nb);\n\tenum ab8500_usb_state bm_usb_state;\n\t \n\tunsigned mA = *((unsigned *)power);\n\n\tif (event != USB_EVENT_VBUS) {\n\t\tdev_dbg(di->dev, \"not a standard host, returning\\n\");\n\t\treturn NOTIFY_DONE;\n\t}\n\n\t \n\tif ((di->usb_state.usb_current_ua == 2000) && (mA > 2))\n\t\tbm_usb_state = AB8500_BM_USB_STATE_RESUME;\n\telse if (mA == 0)\n\t\tbm_usb_state = AB8500_BM_USB_STATE_RESET_HS;\n\telse if (mA == 2)\n\t\tbm_usb_state = AB8500_BM_USB_STATE_SUSPEND;\n\telse if (mA >= 8)  \n\t\tbm_usb_state = AB8500_BM_USB_STATE_CONFIGURED;\n\telse  \n\t\tbm_usb_state = AB8500_BM_USB_STATE_RESET_FS;\n\n\tdev_dbg(di->dev, \"%s usb_state: 0x%02x mA: %d\\n\",\n\t\t__func__, bm_usb_state, mA);\n\n\tspin_lock(&di->usb_state.usb_lock);\n\tdi->usb_state.state_tmp = bm_usb_state;\n\t \n\tdi->usb_state.usb_current_tmp_ua = mA * 1000;\n\tspin_unlock(&di->usb_state.usb_lock);\n\n\t \n\tqueue_delayed_work(di->charger_wq, &di->usb_state_changed_work, HZ/2);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int __maybe_unused ab8500_charger_resume(struct device *dev)\n{\n\tint ret;\n\tstruct ab8500_charger *di = dev_get_drvdata(dev);\n\n\t \n\tif (di->ac_conn && is_ab8500_1p1_or_earlier(di->parent)) {\n\t\tret = abx500_set_register_interruptible(di->dev, AB8500_CHARGER,\n\t\t\tAB8500_CHARG_WD_CTRL, CHARG_WD_KICK);\n\t\tif (ret)\n\t\t\tdev_err(di->dev, \"Failed to kick WD!\\n\");\n\n\t\t \n\t\tqueue_delayed_work(di->charger_wq, &di->kick_wd_work,\n\t\t\t\t   round_jiffies(WD_KICK_INTERVAL));\n\t}\n\n\t \n\tif (di->flags.mainextchnotok || di->flags.vbus_ovv) {\n\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t&di->check_hw_failure_work, 0);\n\t}\n\n\tif (di->flags.vbus_drop_end)\n\t\tqueue_delayed_work(di->charger_wq, &di->vbus_drop_end_work, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ab8500_charger_suspend(struct device *dev)\n{\n\tstruct ab8500_charger *di = dev_get_drvdata(dev);\n\n\t \n\tcancel_delayed_work(&di->check_hw_failure_work);\n\tcancel_delayed_work(&di->vbus_drop_end_work);\n\n\tflush_delayed_work(&di->attach_work);\n\tflush_delayed_work(&di->usb_charger_attached_work);\n\tflush_delayed_work(&di->ac_charger_attached_work);\n\tflush_delayed_work(&di->check_usbchgnotok_work);\n\tflush_delayed_work(&di->check_vbat_work);\n\tflush_delayed_work(&di->kick_wd_work);\n\n\tflush_work(&di->usb_link_status_work);\n\tflush_work(&di->ac_work);\n\tflush_work(&di->detect_usb_type_work);\n\n\tif (atomic_read(&di->current_stepping_sessions))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic char *supply_interface[] = {\n\t\"ab8500_chargalg\",\n\t\"ab8500_fg\",\n\t\"ab8500_btemp\",\n};\n\nstatic const struct power_supply_desc ab8500_ac_chg_desc = {\n\t.name\t\t= \"ab8500_ac\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.properties\t= ab8500_charger_ac_props,\n\t.num_properties\t= ARRAY_SIZE(ab8500_charger_ac_props),\n\t.get_property\t= ab8500_charger_ac_get_property,\n};\n\nstatic const struct power_supply_desc ab8500_usb_chg_desc = {\n\t.name\t\t= \"ab8500_usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t= ab8500_charger_usb_props,\n\t.num_properties\t= ARRAY_SIZE(ab8500_charger_usb_props),\n\t.get_property\t= ab8500_charger_usb_get_property,\n};\n\nstatic int ab8500_charger_bind(struct device *dev)\n{\n\tstruct ab8500_charger *di = dev_get_drvdata(dev);\n\tint ch_stat;\n\tint ret;\n\n\t \n\tdi->charger_wq = alloc_ordered_workqueue(\"ab8500_charger_wq\",\n\t\t\t\t\t\t WQ_MEM_RECLAIM);\n\tif (di->charger_wq == NULL) {\n\t\tdev_err(dev, \"failed to create work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tch_stat = ab8500_charger_detect_chargers(di, false);\n\n\tif (ch_stat & AC_PW_CONN) {\n\t\tif (is_ab8500(di->parent))\n\t\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t\t   &di->ac_charger_attached_work,\n\t\t\t\t\t   HZ);\n\t}\n\tif (ch_stat & USB_PW_CONN) {\n\t\tif (is_ab8500(di->parent))\n\t\t\tqueue_delayed_work(di->charger_wq,\n\t\t\t\t\t   &di->usb_charger_attached_work,\n\t\t\t\t\t   HZ);\n\t\tdi->vbus_detected = true;\n\t\tdi->vbus_detected_start = true;\n\t\tqueue_work(di->charger_wq,\n\t\t\t   &di->detect_usb_type_work);\n\t}\n\n\tret = component_bind_all(dev, di);\n\tif (ret) {\n\t\tdev_err(dev, \"can't bind component devices\\n\");\n\t\tdestroy_workqueue(di->charger_wq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ab8500_charger_unbind(struct device *dev)\n{\n\tstruct ab8500_charger *di = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tab8500_charger_ac_en(&di->ac_chg, false, 0, 0);\n\n\t \n\tab8500_charger_usb_en(&di->usb_chg, false, 0, 0);\n\n\t \n\tret = abx500_mask_and_set_register_interruptible(di->dev,\n\t\tAB8500_RTC, AB8500_RTC_CTRL_REG, RTC_BUP_CH_ENA, 0);\n\tif (ret < 0)\n\t\tdev_err(di->dev, \"%s mask and set failed\\n\", __func__);\n\n\t \n\tdestroy_workqueue(di->charger_wq);\n\n\t \n\tcomponent_unbind_all(dev, di);\n}\n\nstatic const struct component_master_ops ab8500_charger_comp_ops = {\n\t.bind = ab8500_charger_bind,\n\t.unbind = ab8500_charger_unbind,\n};\n\nstatic struct platform_driver *const ab8500_charger_component_drivers[] = {\n\t&ab8500_fg_driver,\n\t&ab8500_btemp_driver,\n\t&ab8500_chargalg_driver,\n};\n\nstatic int ab8500_charger_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct component_match *match = NULL;\n\tstruct power_supply_config ac_psy_cfg = {}, usb_psy_cfg = {};\n\tstruct ab8500_charger *di;\n\tint charger_status;\n\tint i, irq;\n\tint ret;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->bm = &ab8500_bm_data;\n\n\tdi->autopower_cfg = of_property_read_bool(np, \"autopower_cfg\");\n\n\t \n\tdi->dev = dev;\n\tdi->parent = dev_get_drvdata(pdev->dev.parent);\n\n\t \n\tif (!is_ab8505(di->parent)) {\n\t\tdi->adc_main_charger_v = devm_iio_channel_get(dev, \"main_charger_v\");\n\t\tif (IS_ERR(di->adc_main_charger_v)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(di->adc_main_charger_v),\n\t\t\t\t\t    \"failed to get ADC main charger voltage\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdi->adc_main_charger_c = devm_iio_channel_get(dev, \"main_charger_c\");\n\t\tif (IS_ERR(di->adc_main_charger_c)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(di->adc_main_charger_c),\n\t\t\t\t\t    \"failed to get ADC main charger current\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdi->adc_vbus_v = devm_iio_channel_get(dev, \"vbus_v\");\n\tif (IS_ERR(di->adc_vbus_v)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(di->adc_vbus_v),\n\t\t\t\t    \"failed to get ADC USB charger voltage\\n\");\n\t\treturn ret;\n\t}\n\tdi->adc_usb_charger_c = devm_iio_channel_get(dev, \"usb_charger_c\");\n\tif (IS_ERR(di->adc_usb_charger_c)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(di->adc_usb_charger_c),\n\t\t\t\t    \"failed to get ADC USB charger current\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdi->regu = devm_regulator_get(dev, \"vddadc\");\n\tif (IS_ERR(di->regu)) {\n\t\tret = PTR_ERR(di->regu);\n\t\tdev_err(dev, \"failed to get vddadc regulator\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_charger_irq); i++) {\n\t\tirq = platform_get_irq_byname(pdev, ab8500_charger_irq[i].name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(dev,\n\t\t\tirq, NULL, ab8500_charger_irq[i].isr,\n\t\t\tIRQF_SHARED | IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\tab8500_charger_irq[i].name, di);\n\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"failed to request %s IRQ %d: %d\\n\"\n\t\t\t\t, ab8500_charger_irq[i].name, irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev, \"Requested %s IRQ %d: %d\\n\",\n\t\t\tab8500_charger_irq[i].name, irq, ret);\n\t}\n\n\t \n\tspin_lock_init(&di->usb_state.usb_lock);\n\tmutex_init(&di->usb_ipt_crnt_lock);\n\n\tdi->autopower = false;\n\tdi->invalid_charger_detect_state = 0;\n\n\t \n\tac_psy_cfg.of_node = np;\n\tac_psy_cfg.supplied_to = supply_interface;\n\tac_psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\n\tac_psy_cfg.drv_data = &di->ac_chg;\n\tusb_psy_cfg.of_node = np;\n\tusb_psy_cfg.supplied_to = supply_interface;\n\tusb_psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\n\tusb_psy_cfg.drv_data = &di->usb_chg;\n\n\t \n\t \n\tdi->ac_chg.ops.enable = &ab8500_charger_ac_en;\n\tdi->ac_chg.ops.check_enable = &ab8500_charger_ac_check_enable;\n\tdi->ac_chg.ops.kick_wd = &ab8500_charger_watchdog_kick;\n\tdi->ac_chg.ops.update_curr = &ab8500_charger_update_charger_current;\n\tdi->ac_chg.max_out_volt_uv = ab8500_charger_voltage_map[\n\t\tARRAY_SIZE(ab8500_charger_voltage_map) - 1];\n\tdi->ac_chg.max_out_curr_ua =\n\t\tab8500_charge_output_curr_map[ARRAY_SIZE(ab8500_charge_output_curr_map) - 1];\n\tdi->ac_chg.wdt_refresh = CHG_WD_INTERVAL;\n\t \n\tif (!is_ab8505(di->parent))\n\t\tdi->ac_chg.enabled = true;\n\n\t \n\t \n\tdi->usb_chg.ops.enable = &ab8500_charger_usb_en;\n\tdi->usb_chg.ops.check_enable = &ab8500_charger_usb_check_enable;\n\tdi->usb_chg.ops.kick_wd = &ab8500_charger_watchdog_kick;\n\tdi->usb_chg.ops.update_curr = &ab8500_charger_update_charger_current;\n\tdi->usb_chg.max_out_volt_uv = ab8500_charger_voltage_map[\n\t\tARRAY_SIZE(ab8500_charger_voltage_map) - 1];\n\tdi->usb_chg.max_out_curr_ua =\n\t\tab8500_charge_output_curr_map[ARRAY_SIZE(ab8500_charge_output_curr_map) - 1];\n\tdi->usb_chg.wdt_refresh = CHG_WD_INTERVAL;\n\tdi->usb_state.usb_current_ua = -1;\n\n\tmutex_init(&di->charger_attached_mutex);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->check_hw_failure_work,\n\t\tab8500_charger_check_hw_failure_work);\n\tINIT_DEFERRABLE_WORK(&di->check_usbchgnotok_work,\n\t\tab8500_charger_check_usbchargernotok_work);\n\n\tINIT_DELAYED_WORK(&di->ac_charger_attached_work,\n\t\t\t  ab8500_charger_ac_attached_work);\n\tINIT_DELAYED_WORK(&di->usb_charger_attached_work,\n\t\t\t  ab8500_charger_usb_attached_work);\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->kick_wd_work,\n\t\tab8500_charger_kick_watchdog_work);\n\n\tINIT_DEFERRABLE_WORK(&di->check_vbat_work,\n\t\tab8500_charger_check_vbat_work);\n\n\tINIT_DELAYED_WORK(&di->attach_work,\n\t\tab8500_charger_usb_link_attach_work);\n\n\tINIT_DELAYED_WORK(&di->usb_state_changed_work,\n\t\tab8500_charger_usb_state_changed_work);\n\n\tINIT_DELAYED_WORK(&di->vbus_drop_end_work,\n\t\tab8500_charger_vbus_drop_end_work);\n\n\t \n\tINIT_WORK(&di->usb_link_status_work,\n\t\tab8500_charger_usb_link_status_work);\n\tINIT_WORK(&di->ac_work, ab8500_charger_ac_work);\n\tINIT_WORK(&di->detect_usb_type_work,\n\t\tab8500_charger_detect_usb_type_work);\n\n\t \n\tINIT_WORK(&di->check_main_thermal_prot_work,\n\t\tab8500_charger_check_main_thermal_prot_work);\n\tINIT_WORK(&di->check_usb_thermal_prot_work,\n\t\tab8500_charger_check_usb_thermal_prot_work);\n\n\n\t \n\tret = ab8500_charger_init_hw_registers(di);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize ABB registers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (di->ac_chg.enabled) {\n\t\tdi->ac_chg.psy = devm_power_supply_register(dev,\n\t\t\t\t\t\t       &ab8500_ac_chg_desc,\n\t\t\t\t\t\t       &ac_psy_cfg);\n\t\tif (IS_ERR(di->ac_chg.psy)) {\n\t\t\tdev_err(dev, \"failed to register AC charger\\n\");\n\t\t\treturn PTR_ERR(di->ac_chg.psy);\n\t\t}\n\t}\n\n\t \n\tdi->usb_chg.psy = devm_power_supply_register(dev,\n\t\t\t\t\t\t     &ab8500_usb_chg_desc,\n\t\t\t\t\t\t     &usb_psy_cfg);\n\tif (IS_ERR(di->usb_chg.psy)) {\n\t\tdev_err(dev, \"failed to register USB charger\\n\");\n\t\treturn PTR_ERR(di->usb_chg.psy);\n\t}\n\n\t \n\tret = ab8500_bm_of_probe(di->usb_chg.psy, di->bm);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get battery information\\n\");\n\n\t \n\tcharger_status = ab8500_charger_detect_chargers(di, true);\n\tif (charger_status & AC_PW_CONN) {\n\t\tdi->ac.charger_connected = 1;\n\t\tdi->ac_conn = true;\n\t\tab8500_power_supply_changed(di, di->ac_chg.psy);\n\t\tsysfs_notify(&di->ac_chg.psy->dev.kobj, NULL, \"present\");\n\t}\n\n\tplatform_set_drvdata(pdev, di);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_charger_component_drivers); i++) {\n\t\tstruct device_driver *drv = &ab8500_charger_component_drivers[i]->driver;\n\t\tstruct device *p = NULL, *d;\n\n\t\twhile ((d = platform_find_device_by_driver(p, drv))) {\n\t\t\tput_device(p);\n\t\t\tcomponent_match_add(dev, &match, component_compare_dev, d);\n\t\t\tp = d;\n\t\t}\n\t\tput_device(p);\n\t}\n\tif (!match) {\n\t\tdev_err(dev, \"no matching components\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_ab8500_bm;\n\t}\n\tif (IS_ERR(match)) {\n\t\tdev_err(dev, \"could not create component match\\n\");\n\t\tret = PTR_ERR(match);\n\t\tgoto remove_ab8500_bm;\n\t}\n\n\tdi->usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);\n\tif (IS_ERR_OR_NULL(di->usb_phy)) {\n\t\tdev_err(dev, \"failed to get usb transceiver\\n\");\n\t\tret = -EINVAL;\n\t\tgoto remove_ab8500_bm;\n\t}\n\tdi->nb.notifier_call = ab8500_charger_usb_notifier_call;\n\tret = usb_register_notifier(di->usb_phy, &di->nb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register usb notifier\\n\");\n\t\tgoto put_usb_phy;\n\t}\n\n\tret = component_master_add_with_match(&pdev->dev,\n\t\t\t\t\t      &ab8500_charger_comp_ops,\n\t\t\t\t\t      match);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add component master\\n\");\n\t\tgoto free_notifier;\n\t}\n\n\treturn 0;\n\nfree_notifier:\n\tusb_unregister_notifier(di->usb_phy, &di->nb);\nput_usb_phy:\n\tusb_put_phy(di->usb_phy);\nremove_ab8500_bm:\n\tab8500_bm_of_remove(di->usb_chg.psy, di->bm);\n\treturn ret;\n}\n\nstatic int ab8500_charger_remove(struct platform_device *pdev)\n{\n\tstruct ab8500_charger *di = platform_get_drvdata(pdev);\n\n\tcomponent_master_del(&pdev->dev, &ab8500_charger_comp_ops);\n\n\tusb_unregister_notifier(di->usb_phy, &di->nb);\n\tab8500_bm_of_remove(di->usb_chg.psy, di->bm);\n\tusb_put_phy(di->usb_phy);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ab8500_charger_pm_ops, ab8500_charger_suspend, ab8500_charger_resume);\n\nstatic const struct of_device_id ab8500_charger_match[] = {\n\t{ .compatible = \"stericsson,ab8500-charger\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ab8500_charger_match);\n\nstatic struct platform_driver ab8500_charger_driver = {\n\t.probe = ab8500_charger_probe,\n\t.remove = ab8500_charger_remove,\n\t.driver = {\n\t\t.name = \"ab8500-charger\",\n\t\t.of_match_table = ab8500_charger_match,\n\t\t.pm = &ab8500_charger_pm_ops,\n\t},\n};\n\nstatic int __init ab8500_charger_init(void)\n{\n\tint ret;\n\n\tret = platform_register_drivers(ab8500_charger_component_drivers,\n\t\t\tARRAY_SIZE(ab8500_charger_component_drivers));\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&ab8500_charger_driver);\n\tif (ret) {\n\t\tplatform_unregister_drivers(ab8500_charger_component_drivers,\n\t\t\t\tARRAY_SIZE(ab8500_charger_component_drivers));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ab8500_charger_exit(void)\n{\n\tplatform_unregister_drivers(ab8500_charger_component_drivers,\n\t\t\tARRAY_SIZE(ab8500_charger_component_drivers));\n\tplatform_driver_unregister(&ab8500_charger_driver);\n}\n\nmodule_init(ab8500_charger_init);\nmodule_exit(ab8500_charger_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Johan Palsson, Karl Komierowski, Arun R Murthy\");\nMODULE_ALIAS(\"platform:ab8500-charger\");\nMODULE_DESCRIPTION(\"AB8500 charger management driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}