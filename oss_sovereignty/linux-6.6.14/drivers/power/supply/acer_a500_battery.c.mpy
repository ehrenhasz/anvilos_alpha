{
  "module_name": "acer_a500_battery.c",
  "hash_id": "6c6aac2ec6c3c9a0ef4f825cb2d24b90335ca282ec9843653026d473ab3746a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/acer_a500_battery.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\nenum {\n\tREG_CAPACITY,\n\tREG_VOLTAGE,\n\tREG_CURRENT,\n\tREG_DESIGN_CAPACITY,\n\tREG_TEMPERATURE,\n};\n\n#define EC_DATA(_reg, _psp) {\t\t\t\\\n\t.psp = POWER_SUPPLY_PROP_ ## _psp,\t\\\n\t.reg = _reg,\t\t\t\t\\\n}\n\nstatic const struct battery_register {\n\tenum power_supply_property psp;\n\tunsigned int reg;\n} ec_data[] = {\n\t[REG_CAPACITY]\t\t= EC_DATA(0x00, CAPACITY),\n\t[REG_VOLTAGE]\t\t= EC_DATA(0x01, VOLTAGE_NOW),\n\t[REG_CURRENT]\t\t= EC_DATA(0x03, CURRENT_NOW),\n\t[REG_DESIGN_CAPACITY]\t= EC_DATA(0x08, CHARGE_FULL_DESIGN),\n\t[REG_TEMPERATURE]\t= EC_DATA(0x0a, TEMP),\n};\n\nstatic const enum power_supply_property a500_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\nstruct a500_battery {\n\tstruct delayed_work poll_work;\n\tstruct power_supply *psy;\n\tstruct regmap *regmap;\n\tunsigned int capacity;\n};\n\nstatic bool a500_battery_update_capacity(struct a500_battery *bat)\n{\n\tunsigned int capacity;\n\tint err;\n\n\terr = regmap_read(bat->regmap, ec_data[REG_CAPACITY].reg, &capacity);\n\tif (err)\n\t\treturn false;\n\n\t \n\tcapacity = min(capacity, 100u);\n\n\tif (bat->capacity != capacity) {\n\t\tbat->capacity = capacity;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int a500_battery_get_status(struct a500_battery *bat)\n{\n\tif (bat->capacity < 100) {\n\t\tif (power_supply_am_i_supplied(bat->psy))\n\t\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\n\treturn POWER_SUPPLY_STATUS_FULL;\n}\n\nstatic void a500_battery_unit_adjustment(struct device *dev,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tconst unsigned int base_unit_conversion = 1000;\n\tconst unsigned int temp_kelvin_to_celsius = 2731;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval *= base_unit_conversion;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval -= temp_kelvin_to_celsius;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!val->intval;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(dev,\n\t\t\t\"%s: no need for unit conversion %d\\n\", __func__, psp);\n\t}\n}\n\nstatic int a500_battery_get_ec_data_index(struct device *dev,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\tunsigned int i;\n\n\t \n\tif (psp == POWER_SUPPLY_PROP_PRESENT)\n\t\tpsp = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\n\n\tfor (i = 0; i < ARRAY_SIZE(ec_data); i++)\n\t\tif (psp == ec_data[i].psp)\n\t\t\treturn i;\n\n\tdev_dbg(dev, \"%s: invalid property %u\\n\", __func__, psp);\n\n\treturn -EINVAL;\n}\n\nstatic int a500_battery_get_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct a500_battery *bat = power_supply_get_drvdata(psy);\n\tstruct device *dev = psy->dev.parent;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = a500_battery_get_status(bat);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\ta500_battery_update_capacity(bat);\n\t\tval->intval = bat->capacity;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = a500_battery_get_ec_data_index(dev, psp);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = regmap_read(bat->regmap, ec_data[ret].reg, &val->intval);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"%s: invalid property %u\\n\", __func__, psp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\t \n\t\ta500_battery_unit_adjustment(dev, psp, val);\n\t}\n\n\tdev_dbg(dev, \"%s: property = %d, value = %x\\n\",\n\t\t__func__, psp, val->intval);\n\n\t \n\tif (ret)\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nstatic void a500_battery_poll_work(struct work_struct *work)\n{\n\tstruct a500_battery *bat;\n\tbool capacity_changed;\n\n\tbat = container_of(work, struct a500_battery, poll_work.work);\n\tcapacity_changed = a500_battery_update_capacity(bat);\n\n\tif (capacity_changed)\n\t\tpower_supply_changed(bat->psy);\n\n\t \n\tschedule_delayed_work(&bat->poll_work, 30 * HZ);\n}\n\nstatic const struct power_supply_desc a500_battery_desc = {\n\t.name = \"ec-battery\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = a500_battery_properties,\n\t.get_property = a500_battery_get_property,\n\t.num_properties = ARRAY_SIZE(a500_battery_properties),\n\t.external_power_changed = power_supply_changed,\n};\n\nstatic int a500_battery_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct a500_battery *bat;\n\n\tbat = devm_kzalloc(&pdev->dev, sizeof(*bat), GFP_KERNEL);\n\tif (!bat)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, bat);\n\n\tpsy_cfg.of_node = pdev->dev.parent->of_node;\n\tpsy_cfg.drv_data = bat;\n\n\tbat->regmap = dev_get_regmap(pdev->dev.parent, \"KB930\");\n\tif (!bat->regmap)\n\t\treturn -EINVAL;\n\n\tbat->psy = devm_power_supply_register_no_ws(&pdev->dev,\n\t\t\t\t\t\t    &a500_battery_desc,\n\t\t\t\t\t\t    &psy_cfg);\n\tif (IS_ERR(bat->psy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(bat->psy),\n\t\t\t\t     \"failed to register battery\\n\");\n\n\tINIT_DELAYED_WORK(&bat->poll_work, a500_battery_poll_work);\n\tschedule_delayed_work(&bat->poll_work, HZ);\n\n\treturn 0;\n}\n\nstatic int a500_battery_remove(struct platform_device *pdev)\n{\n\tstruct a500_battery *bat = dev_get_drvdata(&pdev->dev);\n\n\tcancel_delayed_work_sync(&bat->poll_work);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused a500_battery_suspend(struct device *dev)\n{\n\tstruct a500_battery *bat = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&bat->poll_work);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused a500_battery_resume(struct device *dev)\n{\n\tstruct a500_battery *bat = dev_get_drvdata(dev);\n\n\tschedule_delayed_work(&bat->poll_work, HZ);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(a500_battery_pm_ops,\n\t\t\t a500_battery_suspend, a500_battery_resume);\n\nstatic struct platform_driver a500_battery_driver = {\n\t.driver = {\n\t\t.name = \"acer-a500-iconia-battery\",\n\t\t.pm = &a500_battery_pm_ops,\n\t},\n\t.probe = a500_battery_probe,\n\t.remove = a500_battery_remove,\n};\nmodule_platform_driver(a500_battery_driver);\n\nMODULE_DESCRIPTION(\"Battery gauge driver for Acer Iconia Tab A500\");\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_ALIAS(\"platform:acer-a500-iconia-battery\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}