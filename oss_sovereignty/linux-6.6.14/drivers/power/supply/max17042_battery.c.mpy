{
  "module_name": "max17042_battery.c",
  "hash_id": "e6afc8b4f6658f1ff31540825276b4dbe6a0fb7555bed95bd118af1343bc7d31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max17042_battery.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/devm-helpers.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/power_supply.h>\n#include <linux/power/max17042_battery.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define STATUS_POR_BIT         (1 << 1)\n#define STATUS_BST_BIT         (1 << 3)\n#define STATUS_VMN_BIT         (1 << 8)\n#define STATUS_TMN_BIT         (1 << 9)\n#define STATUS_SMN_BIT         (1 << 10)\n#define STATUS_BI_BIT          (1 << 11)\n#define STATUS_VMX_BIT         (1 << 12)\n#define STATUS_TMX_BIT         (1 << 13)\n#define STATUS_SMX_BIT         (1 << 14)\n#define STATUS_BR_BIT          (1 << 15)\n\n \n#define CONFIG_ALRT_BIT_ENBL\t(1 << 2)\n\n#define VFSOC0_LOCK\t\t0x0000\n#define VFSOC0_UNLOCK\t\t0x0080\n#define MODEL_UNLOCK1\t0X0059\n#define MODEL_UNLOCK2\t0X00C4\n#define MODEL_LOCK1\t\t0X0000\n#define MODEL_LOCK2\t\t0X0000\n\n#define dQ_ACC_DIV\t0x4\n#define dP_ACC_100\t0x1900\n#define dP_ACC_200\t0x3200\n\n#define MAX17042_VMAX_TOLERANCE\t\t50  \n\nstruct max17042_chip {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct power_supply *battery;\n\tenum max170xx_chip_type chip_type;\n\tstruct max17042_platform_data *pdata;\n\tstruct work_struct work;\n\tint    init_complete;\n};\n\nstatic enum power_supply_property max17042_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_TEMP_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_MAX,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,\n\t\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n};\n\nstatic int max17042_get_temperature(struct max17042_chip *chip, int *temp)\n{\n\tint ret;\n\tu32 data;\n\tstruct regmap *map = chip->regmap;\n\n\tret = regmap_read(map, MAX17042_TEMP, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*temp = sign_extend32(data, 15);\n\t \n\t \n\t*temp = *temp * 10 / 256;\n\treturn 0;\n}\n\nstatic int max17042_get_status(struct max17042_chip *chip, int *status)\n{\n\tint ret, charge_full, charge_now;\n\tint avg_current;\n\tu32 data;\n\n\tret = power_supply_am_i_supplied(chip->battery);\n\tif (ret < 0) {\n\t\t*status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\treturn 0;\n\t}\n\tif (ret == 0) {\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn 0;\n\t}\n\n\t \n\n\tret = regmap_read(chip->regmap, MAX17042_FullCAP, &charge_full);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(chip->regmap, MAX17042_RepCap, &charge_now);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((charge_full - charge_now) <= MAX17042_FULL_THRESHOLD) {\n\t\t*status = POWER_SUPPLY_STATUS_FULL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!chip->pdata->enable_current_sense) {\n\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\t\treturn 0;\n\t}\n\n\tret = regmap_read(chip->regmap, MAX17042_AvgCurrent, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tavg_current = sign_extend32(data, 15);\n\tavg_current *= 1562500 / chip->pdata->r_sns;\n\n\tif (avg_current > 0)\n\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\telse\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\treturn 0;\n}\n\nstatic int max17042_get_battery_health(struct max17042_chip *chip, int *health)\n{\n\tint temp, vavg, vbatt, ret;\n\tu32 val;\n\n\tret = regmap_read(chip->regmap, MAX17042_AvgVCELL, &val);\n\tif (ret < 0)\n\t\tgoto health_error;\n\n\t \n\tvavg = val * 625 / 8;\n\t \n\tvavg /= 1000;\n\n\tret = regmap_read(chip->regmap, MAX17042_VCELL, &val);\n\tif (ret < 0)\n\t\tgoto health_error;\n\n\t \n\tvbatt = val * 625 / 8;\n\t \n\tvbatt /= 1000;\n\n\tif (vavg < chip->pdata->vmin) {\n\t\t*health = POWER_SUPPLY_HEALTH_DEAD;\n\t\tgoto out;\n\t}\n\n\tif (vbatt > chip->pdata->vmax + MAX17042_VMAX_TOLERANCE) {\n\t\t*health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\tgoto out;\n\t}\n\n\tret = max17042_get_temperature(chip, &temp);\n\tif (ret < 0)\n\t\tgoto health_error;\n\n\tif (temp < chip->pdata->temp_min) {\n\t\t*health = POWER_SUPPLY_HEALTH_COLD;\n\t\tgoto out;\n\t}\n\n\tif (temp > chip->pdata->temp_max) {\n\t\t*health = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\tgoto out;\n\t}\n\n\t*health = POWER_SUPPLY_HEALTH_GOOD;\n\nout:\n\treturn 0;\n\nhealth_error:\n\treturn ret;\n}\n\nstatic int max17042_get_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tstruct max17042_chip *chip = power_supply_get_drvdata(psy);\n\tstruct regmap *map = chip->regmap;\n\tint ret;\n\tu32 data;\n\tu64 data64;\n\n\tif (!chip->init_complete)\n\t\treturn -EAGAIN;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = max17042_get_status(chip, &val->intval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tret = regmap_read(map, MAX17042_STATUS, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (data & MAX17042_STATUS_BattAbsent)\n\t\t\tval->intval = 0;\n\t\telse\n\t\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tret = regmap_read(map, MAX17042_Cycles, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tret = regmap_read(map, MAX17042_MinMaxVolt, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data >> 8;\n\t\tval->intval *= 20000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tret = regmap_read(map, MAX17042_MinMaxVolt, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = (data & 0xff) * 20000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tif (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042)\n\t\t\tret = regmap_read(map, MAX17042_V_empty, &data);\n\t\telse\n\t\t\tret = regmap_read(map, MAX17047_V_empty, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data >> 7;\n\t\tval->intval *= 10000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = regmap_read(map, MAX17042_VCELL, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data * 625 / 8;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tret = regmap_read(map, MAX17042_AvgVCELL, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data * 625 / 8;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tret = regmap_read(map, MAX17042_OCVInternal, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data * 625 / 8;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (chip->pdata->enable_current_sense)\n\t\t\tret = regmap_read(map, MAX17042_RepSOC, &data);\n\t\telse\n\t\t\tret = regmap_read(map, MAX17042_VFSOC, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data >> 8;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tret = regmap_read(map, MAX17042_DesignCap, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata64 = data * 5000000ll;\n\t\tdo_div(data64, chip->pdata->r_sns);\n\t\tval->intval = data64;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tret = regmap_read(map, MAX17042_FullCAP, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata64 = data * 5000000ll;\n\t\tdo_div(data64, chip->pdata->r_sns);\n\t\tval->intval = data64;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tret = regmap_read(map, MAX17042_RepCap, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata64 = data * 5000000ll;\n\t\tdo_div(data64, chip->pdata->r_sns);\n\t\tval->intval = data64;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tret = regmap_read(map, MAX17042_QH, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata64 = sign_extend64(data, 15) * 5000000ll;\n\t\tval->intval = div_s64(data64, chip->pdata->r_sns);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = max17042_get_temperature(chip, &val->intval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\tret = regmap_read(map, MAX17042_TALRT_Th, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tval->intval = sign_extend32(data & 0xff, 7) * 10;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = regmap_read(map, MAX17042_TALRT_Th, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tval->intval = sign_extend32(data >> 8, 7) * 10;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_MIN:\n\t\tval->intval = chip->pdata->temp_min;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_MAX:\n\t\tval->intval = chip->pdata->temp_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = max17042_get_battery_health(chip, &val->intval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (chip->pdata->enable_current_sense) {\n\t\t\tret = regmap_read(map, MAX17042_Current, &data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tdata64 = sign_extend64(data, 15) * 1562500ll;\n\t\t\tval->intval = div_s64(data64, chip->pdata->r_sns);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tif (chip->pdata->enable_current_sense) {\n\t\t\tret = regmap_read(map, MAX17042_AvgCurrent, &data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tdata64 = sign_extend64(data, 15) * 1562500ll;\n\t\t\tval->intval = div_s64(data64, chip->pdata->r_sns);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = regmap_read(map, MAX17042_ICHGTerm, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata64 = data * 1562500ll;\n\t\tval->intval = div_s64(data64, chip->pdata->r_sns);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\t\tret = regmap_read(map, MAX17042_TTE, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = data * 5625 / 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int max17042_set_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    const union power_supply_propval *val)\n{\n\tstruct max17042_chip *chip = power_supply_get_drvdata(psy);\n\tstruct regmap *map = chip->regmap;\n\tint ret = 0;\n\tu32 data;\n\tint8_t temp;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\tret = regmap_read(map, MAX17042_TALRT_Th, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\ttemp = val->intval / 10;\n\t\t \n\t\tif (temp >= (int8_t)(data >> 8))\n\t\t\ttemp = (int8_t)(data >> 8) - 1;\n\t\t \n\t\tdata = (data & 0xff00) + temp;\n\t\tret = regmap_write(map, MAX17042_TALRT_Th, data);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = regmap_read(map, MAX17042_TALRT_Th, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\ttemp = val->intval / 10;\n\t\t \n\t\tif (temp <= (int8_t)(data & 0xff))\n\t\t\ttemp = (int8_t)(data & 0xff) + 1;\n\t\t \n\t\tdata = (data & 0xff) + (temp << 8);\n\t\tret = regmap_write(map, MAX17042_TALRT_Th, data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int max17042_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int max17042_write_verify_reg(struct regmap *map, u8 reg, u32 value)\n{\n\tint retries = 8;\n\tint ret;\n\tu32 read_value;\n\n\tdo {\n\t\tret = regmap_write(map, reg, value);\n\t\tregmap_read(map, reg, &read_value);\n\t\tif (read_value != value) {\n\t\t\tret = -EIO;\n\t\t\tretries--;\n\t\t}\n\t} while (retries && read_value != value);\n\n\tif (ret < 0)\n\t\tpr_err(\"%s: err %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic inline void max17042_override_por(struct regmap *map,\n\t\t\t\t\t u8 reg, u16 value)\n{\n\tif (value)\n\t\tregmap_write(map, reg, value);\n}\n\nstatic inline void max17042_unlock_model(struct max17042_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_write(map, MAX17042_MLOCKReg1, MODEL_UNLOCK1);\n\tregmap_write(map, MAX17042_MLOCKReg2, MODEL_UNLOCK2);\n}\n\nstatic inline void max17042_lock_model(struct max17042_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_write(map, MAX17042_MLOCKReg1, MODEL_LOCK1);\n\tregmap_write(map, MAX17042_MLOCKReg2, MODEL_LOCK2);\n}\n\nstatic inline void max17042_write_model_data(struct max17042_chip *chip,\n\t\t\t\t\tu8 addr, int size)\n{\n\tstruct regmap *map = chip->regmap;\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tregmap_write(map, addr + i,\n\t\t\tchip->pdata->config_data->cell_char_tbl[i]);\n}\n\nstatic inline void max17042_read_model_data(struct max17042_chip *chip,\n\t\t\t\t\tu8 addr, u16 *data, int size)\n{\n\tstruct regmap *map = chip->regmap;\n\tint i;\n\tu32 tmp;\n\n\tfor (i = 0; i < size; i++) {\n\t\tregmap_read(map, addr + i, &tmp);\n\t\tdata[i] = (u16)tmp;\n\t}\n}\n\nstatic inline int max17042_model_data_compare(struct max17042_chip *chip,\n\t\t\t\t\tu16 *data1, u16 *data2, int size)\n{\n\tint i;\n\n\tif (memcmp(data1, data2, size)) {\n\t\tdev_err(&chip->client->dev, \"%s compare failed\\n\", __func__);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tdev_info(&chip->client->dev, \"0x%x, 0x%x\",\n\t\t\t\tdata1[i], data2[i]);\n\t\tdev_info(&chip->client->dev, \"\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int max17042_init_model(struct max17042_chip *chip)\n{\n\tint ret;\n\tint table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);\n\tu16 *temp_data;\n\n\ttemp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);\n\tif (!temp_data)\n\t\treturn -ENOMEM;\n\n\tmax17042_unlock_model(chip);\n\tmax17042_write_model_data(chip, MAX17042_MODELChrTbl,\n\t\t\t\ttable_size);\n\tmax17042_read_model_data(chip, MAX17042_MODELChrTbl, temp_data,\n\t\t\t\ttable_size);\n\n\tret = max17042_model_data_compare(\n\t\tchip,\n\t\tchip->pdata->config_data->cell_char_tbl,\n\t\ttemp_data,\n\t\ttable_size);\n\n\tmax17042_lock_model(chip);\n\tkfree(temp_data);\n\n\treturn ret;\n}\n\nstatic int max17042_verify_model_lock(struct max17042_chip *chip)\n{\n\tint i;\n\tint table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);\n\tu16 *temp_data;\n\tint ret = 0;\n\n\ttemp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);\n\tif (!temp_data)\n\t\treturn -ENOMEM;\n\n\tmax17042_read_model_data(chip, MAX17042_MODELChrTbl, temp_data,\n\t\t\t\ttable_size);\n\tfor (i = 0; i < table_size; i++)\n\t\tif (temp_data[i])\n\t\t\tret = -EINVAL;\n\n\tkfree(temp_data);\n\treturn ret;\n}\n\nstatic void max17042_write_config_regs(struct max17042_chip *chip)\n{\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_write(map, MAX17042_CONFIG, config->config);\n\tregmap_write(map, MAX17042_LearnCFG, config->learn_cfg);\n\tregmap_write(map, MAX17042_FilterCFG,\n\t\t\tconfig->filter_cfg);\n\tregmap_write(map, MAX17042_RelaxCFG, config->relax_cfg);\n\tif (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17047 ||\n\t\t\tchip->chip_type == MAXIM_DEVICE_TYPE_MAX17050 ||\n\t\t\tchip->chip_type == MAXIM_DEVICE_TYPE_MAX17055)\n\t\tregmap_write(map, MAX17047_FullSOCThr,\n\t\t\t\t\t\tconfig->full_soc_thresh);\n}\n\nstatic void  max17042_write_custom_regs(struct max17042_chip *chip)\n{\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tmax17042_write_verify_reg(map, MAX17042_RCOMP0, config->rcomp0);\n\tmax17042_write_verify_reg(map, MAX17042_TempCo,\tconfig->tcompc0);\n\tmax17042_write_verify_reg(map, MAX17042_ICHGTerm, config->ichgt_term);\n\tif (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042) {\n\t\tregmap_write(map, MAX17042_EmptyTempCo,\tconfig->empty_tempco);\n\t\tmax17042_write_verify_reg(map, MAX17042_K_empty0,\n\t\t\t\t\tconfig->kempty0);\n\t} else {\n\t\tmax17042_write_verify_reg(map, MAX17047_QRTbl00,\n\t\t\t\t\t\tconfig->qrtbl00);\n\t\tmax17042_write_verify_reg(map, MAX17047_QRTbl10,\n\t\t\t\t\t\tconfig->qrtbl10);\n\t\tmax17042_write_verify_reg(map, MAX17047_QRTbl20,\n\t\t\t\t\t\tconfig->qrtbl20);\n\t\tmax17042_write_verify_reg(map, MAX17047_QRTbl30,\n\t\t\t\t\t\tconfig->qrtbl30);\n\t}\n}\n\nstatic void max17042_update_capacity_regs(struct max17042_chip *chip)\n{\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tmax17042_write_verify_reg(map, MAX17042_FullCAP,\n\t\t\t\tconfig->fullcap);\n\tregmap_write(map, MAX17042_DesignCap, config->design_cap);\n\tmax17042_write_verify_reg(map, MAX17042_FullCAPNom,\n\t\t\t\tconfig->fullcapnom);\n}\n\nstatic void max17042_reset_vfsoc0_reg(struct max17042_chip *chip)\n{\n\tunsigned int vfSoc;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_read(map, MAX17042_VFSOC, &vfSoc);\n\tregmap_write(map, MAX17042_VFSOC0Enable, VFSOC0_UNLOCK);\n\tmax17042_write_verify_reg(map, MAX17042_VFSOC0, vfSoc);\n\tregmap_write(map, MAX17042_VFSOC0Enable, VFSOC0_LOCK);\n}\n\nstatic void max17042_load_new_capacity_params(struct max17042_chip *chip)\n{\n\tu32 full_cap0, rep_cap, dq_acc, vfSoc;\n\tu32 rem_cap;\n\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\tstruct regmap *map = chip->regmap;\n\n\tregmap_read(map, MAX17042_FullCAP0, &full_cap0);\n\tregmap_read(map, MAX17042_VFSOC, &vfSoc);\n\n\t \n\trem_cap = ((vfSoc >> 8) * full_cap0) / 100;\n\tmax17042_write_verify_reg(map, MAX17042_RemCap, rem_cap);\n\n\trep_cap = rem_cap;\n\tmax17042_write_verify_reg(map, MAX17042_RepCap, rep_cap);\n\n\t \n\tdq_acc = config->fullcap / dQ_ACC_DIV;\n\tmax17042_write_verify_reg(map, MAX17042_dQacc, dq_acc);\n\tmax17042_write_verify_reg(map, MAX17042_dPacc, dP_ACC_200);\n\n\tmax17042_write_verify_reg(map, MAX17042_FullCAP,\n\t\t\tconfig->fullcap);\n\tregmap_write(map, MAX17042_DesignCap,\n\t\t\tconfig->design_cap);\n\tmax17042_write_verify_reg(map, MAX17042_FullCAPNom,\n\t\t\tconfig->fullcapnom);\n\t \n\tregmap_write(map, MAX17042_RepSOC, vfSoc);\n}\n\n \nstatic inline void max17042_override_por_values(struct max17042_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\tstruct max17042_config_data *config = chip->pdata->config_data;\n\n\tmax17042_override_por(map, MAX17042_TGAIN, config->tgain);\n\tmax17042_override_por(map, MAX17042_TOFF, config->toff);\n\tmax17042_override_por(map, MAX17042_CGAIN, config->cgain);\n\tmax17042_override_por(map, MAX17042_COFF, config->coff);\n\n\tmax17042_override_por(map, MAX17042_VALRT_Th, config->valrt_thresh);\n\tmax17042_override_por(map, MAX17042_TALRT_Th, config->talrt_thresh);\n\tmax17042_override_por(map, MAX17042_SALRT_Th,\n\t\t\t\t\t\tconfig->soc_alrt_thresh);\n\tmax17042_override_por(map, MAX17042_CONFIG, config->config);\n\tmax17042_override_por(map, MAX17042_SHDNTIMER, config->shdntimer);\n\n\tmax17042_override_por(map, MAX17042_DesignCap, config->design_cap);\n\tmax17042_override_por(map, MAX17042_ICHGTerm, config->ichgt_term);\n\n\tmax17042_override_por(map, MAX17042_AtRate, config->at_rate);\n\tmax17042_override_por(map, MAX17042_LearnCFG, config->learn_cfg);\n\tmax17042_override_por(map, MAX17042_FilterCFG, config->filter_cfg);\n\tmax17042_override_por(map, MAX17042_RelaxCFG, config->relax_cfg);\n\tmax17042_override_por(map, MAX17042_MiscCFG, config->misc_cfg);\n\n\tmax17042_override_por(map, MAX17042_FullCAP, config->fullcap);\n\tmax17042_override_por(map, MAX17042_FullCAPNom, config->fullcapnom);\n\tmax17042_override_por(map, MAX17042_dQacc, config->dqacc);\n\tmax17042_override_por(map, MAX17042_dPacc, config->dpacc);\n\n\tmax17042_override_por(map, MAX17042_RCOMP0, config->rcomp0);\n\tmax17042_override_por(map, MAX17042_TempCo, config->tcompc0);\n\n\tif (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042) {\n\t\tmax17042_override_por(map, MAX17042_MaskSOC, config->masksoc);\n\t\tmax17042_override_por(map, MAX17042_SOC_empty, config->socempty);\n\t\tmax17042_override_por(map, MAX17042_V_empty, config->vempty);\n\t\tmax17042_override_por(map, MAX17042_EmptyTempCo, config->empty_tempco);\n\t\tmax17042_override_por(map, MAX17042_K_empty0, config->kempty0);\n\t}\n\n\tif ((chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042) ||\n\t    (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17047) ||\n\t    (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17050)) {\n\t\tmax17042_override_por(map, MAX17042_IAvg_empty, config->iavg_empty);\n\t\tmax17042_override_por(map, MAX17042_TempNom, config->temp_nom);\n\t\tmax17042_override_por(map, MAX17042_TempLim, config->temp_lim);\n\t\tmax17042_override_por(map, MAX17042_FCTC, config->fctc);\n\t}\n\n\tif ((chip->chip_type == MAXIM_DEVICE_TYPE_MAX17047) ||\n\t    (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17050) ||\n\t    (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17055)) {\n\t\tmax17042_override_por(map, MAX17047_V_empty, config->vempty);\n\t}\n}\n\nstatic int max17042_init_chip(struct max17042_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\tint ret;\n\n\tmax17042_override_por_values(chip);\n\t \n\tmsleep(500);\n\n\t \n\tmax17042_write_config_regs(chip);\n\n\t \n\tret = max17042_init_model(chip);\n\tif (ret) {\n\t\tdev_err(&chip->client->dev, \"%s init failed\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tret = max17042_verify_model_lock(chip);\n\tif (ret) {\n\t\tdev_err(&chip->client->dev, \"%s lock verify failed\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\t \n\tmax17042_write_custom_regs(chip);\n\n\t \n\tmax17042_update_capacity_regs(chip);\n\n\t \n\tmsleep(350);\n\n\t \n\tmax17042_reset_vfsoc0_reg(chip);\n\n\t \n\tmax17042_load_new_capacity_params(chip);\n\n\t \n\tregmap_update_bits(map, MAX17042_STATUS, STATUS_POR_BIT, 0x0);\n\treturn 0;\n}\n\nstatic void max17042_set_soc_threshold(struct max17042_chip *chip, u16 off)\n{\n\tstruct regmap *map = chip->regmap;\n\tu32 soc, soc_tr;\n\n\t \n\tregmap_read(map, MAX17042_RepSOC, &soc);\n\tsoc >>= 8;\n\tsoc_tr = (soc + off) << 8;\n\tif (off < soc)\n\t\tsoc_tr |= soc - off;\n\tregmap_write(map, MAX17042_SALRT_Th, soc_tr);\n}\n\nstatic irqreturn_t max17042_thread_handler(int id, void *dev)\n{\n\tstruct max17042_chip *chip = dev;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, MAX17042_STATUS, &val);\n\tif (ret)\n\t\treturn IRQ_HANDLED;\n\n\tif ((val & STATUS_SMN_BIT) || (val & STATUS_SMX_BIT)) {\n\t\tdev_dbg(&chip->client->dev, \"SOC threshold INTR\\n\");\n\t\tmax17042_set_soc_threshold(chip, 1);\n\t}\n\n\t \n\tregmap_clear_bits(chip->regmap, MAX17042_STATUS,\n\t\t\t  0xFFFF & ~(STATUS_POR_BIT | STATUS_BST_BIT));\n\n\tpower_supply_changed(chip->battery);\n\treturn IRQ_HANDLED;\n}\n\nstatic void max17042_init_worker(struct work_struct *work)\n{\n\tstruct max17042_chip *chip = container_of(work,\n\t\t\t\tstruct max17042_chip, work);\n\tint ret;\n\n\t \n\tif (chip->pdata->enable_por_init && chip->pdata->config_data) {\n\t\tret = max17042_init_chip(chip);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tchip->init_complete = 1;\n}\n\n#ifdef CONFIG_OF\nstatic struct max17042_platform_data *\nmax17042_get_of_pdata(struct max17042_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tstruct device_node *np = dev->of_node;\n\tu32 prop;\n\tstruct max17042_platform_data *pdata;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\t \n\tif (of_property_read_u32(np, \"maxim,rsns-microohm\", &prop) == 0) {\n\t\tpdata->r_sns = prop;\n\t\tpdata->enable_current_sense = true;\n\t}\n\n\tif (of_property_read_s32(np, \"maxim,cold-temp\", &pdata->temp_min))\n\t\tpdata->temp_min = INT_MIN;\n\tif (of_property_read_s32(np, \"maxim,over-heat-temp\", &pdata->temp_max))\n\t\tpdata->temp_max = INT_MAX;\n\tif (of_property_read_s32(np, \"maxim,dead-volt\", &pdata->vmin))\n\t\tpdata->vmin = INT_MIN;\n\tif (of_property_read_s32(np, \"maxim,over-volt\", &pdata->vmax))\n\t\tpdata->vmax = INT_MAX;\n\n\treturn pdata;\n}\n#endif\n\nstatic struct max17042_reg_data max17047_default_pdata_init_regs[] = {\n\t \n\t{ MAX17047_FullSOCThr, MAX17042_BATTERY_FULL << 8 },\n};\n\nstatic struct max17042_platform_data *\nmax17042_get_default_pdata(struct max17042_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\tstruct max17042_platform_data *pdata;\n\tint ret, misc_cfg;\n\n\t \n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn pdata;\n\n\tif ((chip->chip_type == MAXIM_DEVICE_TYPE_MAX17047) ||\n\t    (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17050)) {\n\t\tpdata->init_data = max17047_default_pdata_init_regs;\n\t\tpdata->num_init_data =\n\t\t\tARRAY_SIZE(max17047_default_pdata_init_regs);\n\t}\n\n\tret = regmap_read(chip->regmap, MAX17042_MiscCFG, &misc_cfg);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\t \n\tif ((misc_cfg & 0x3) == 0x3)\n\t\tpdata->enable_current_sense = false;\n\telse\n\t\tpdata->enable_current_sense = true;\n\n\tpdata->vmin = MAX17042_DEFAULT_VMIN;\n\tpdata->vmax = MAX17042_DEFAULT_VMAX;\n\tpdata->temp_min = MAX17042_DEFAULT_TEMP_MIN;\n\tpdata->temp_max = MAX17042_DEFAULT_TEMP_MAX;\n\n\treturn pdata;\n}\n\nstatic struct max17042_platform_data *\nmax17042_get_pdata(struct max17042_chip *chip)\n{\n\tstruct device *dev = &chip->client->dev;\n\n#ifdef CONFIG_OF\n\tif (dev->of_node)\n\t\treturn max17042_get_of_pdata(chip);\n#endif\n\tif (dev->platform_data)\n\t\treturn dev->platform_data;\n\n\treturn max17042_get_default_pdata(chip);\n}\n\nstatic const struct regmap_config max17042_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.val_format_endian = REGMAP_ENDIAN_NATIVE,\n};\n\nstatic const struct power_supply_desc max17042_psy_desc = {\n\t.name\t\t= \"max170xx_battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t= max17042_get_property,\n\t.set_property\t= max17042_set_property,\n\t.property_is_writeable\t= max17042_property_is_writeable,\n\t.external_power_changed\t= power_supply_changed,\n\t.properties\t= max17042_battery_props,\n\t.num_properties\t= ARRAY_SIZE(max17042_battery_props),\n};\n\nstatic const struct power_supply_desc max17042_no_current_sense_psy_desc = {\n\t.name\t\t= \"max170xx_battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t= max17042_get_property,\n\t.set_property\t= max17042_set_property,\n\t.property_is_writeable\t= max17042_property_is_writeable,\n\t.properties\t= max17042_battery_props,\n\t.num_properties\t= ARRAY_SIZE(max17042_battery_props) - 2,\n};\n\nstatic int max17042_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tconst struct power_supply_desc *max17042_desc = &max17042_psy_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tconst struct acpi_device_id *acpi_id = NULL;\n\tstruct device *dev = &client->dev;\n\tstruct max17042_chip *chip;\n\tint ret;\n\tint i;\n\tu32 val;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EIO;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tif (id) {\n\t\tchip->chip_type = id->driver_data;\n\t} else {\n\t\tacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\n\t\tif (!acpi_id)\n\t\t\treturn -ENODEV;\n\n\t\tchip->chip_type = acpi_id->driver_data;\n\t}\n\tchip->regmap = devm_regmap_init_i2c(client, &max17042_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->pdata = max17042_get_pdata(chip);\n\tif (!chip->pdata) {\n\t\tdev_err(&client->dev, \"no platform data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_set_clientdata(client, chip);\n\tpsy_cfg.drv_data = chip;\n\tpsy_cfg.of_node = dev->of_node;\n\n\t \n\tif (!chip->pdata->enable_current_sense)\n\t\tmax17042_desc = &max17042_no_current_sense_psy_desc;\n\n\tif (chip->pdata->r_sns == 0)\n\t\tchip->pdata->r_sns = MAX17042_DEFAULT_SNS_RESISTOR;\n\n\tif (chip->pdata->init_data)\n\t\tfor (i = 0; i < chip->pdata->num_init_data; i++)\n\t\t\tregmap_write(chip->regmap,\n\t\t\t\t\tchip->pdata->init_data[i].addr,\n\t\t\t\t\tchip->pdata->init_data[i].data);\n\n\tif (!chip->pdata->enable_current_sense) {\n\t\tregmap_write(chip->regmap, MAX17042_CGAIN, 0x0000);\n\t\tregmap_write(chip->regmap, MAX17042_MiscCFG, 0x0003);\n\t\tregmap_write(chip->regmap, MAX17042_LearnCFG, 0x0007);\n\t}\n\n\tchip->battery = devm_power_supply_register(&client->dev, max17042_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(chip->battery)) {\n\t\tdev_err(&client->dev, \"failed: power supply register\\n\");\n\t\treturn PTR_ERR(chip->battery);\n\t}\n\n\tif (client->irq) {\n\t\tunsigned int flags = IRQF_ONESHOT;\n\n\t\t \n\t\tif (acpi_id)\n\t\t\tflags |= IRQF_SHARED | IRQF_PROBE_SHARED;\n\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tmax17042_thread_handler, flags,\n\t\t\t\t\t\tchip->battery->desc->name,\n\t\t\t\t\t\tchip);\n\t\tif (!ret) {\n\t\t\tregmap_update_bits(chip->regmap, MAX17042_CONFIG,\n\t\t\t\t\tCONFIG_ALRT_BIT_ENBL,\n\t\t\t\t\tCONFIG_ALRT_BIT_ENBL);\n\t\t\tmax17042_set_soc_threshold(chip, 1);\n\t\t} else {\n\t\t\tclient->irq = 0;\n\t\t\tif (ret != -EBUSY)\n\t\t\t\tdev_err(&client->dev, \"Failed to get IRQ\\n\");\n\t\t}\n\t}\n\t \n\tif (!client->irq)\n\t\tregmap_write(chip->regmap, MAX17042_SALRT_Th, 0xff00);\n\n\tregmap_read(chip->regmap, MAX17042_STATUS, &val);\n\tif (val & STATUS_POR_BIT) {\n\t\tret = devm_work_autocancel(&client->dev, &chip->work,\n\t\t\t\t\t   max17042_init_worker);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tschedule_work(&chip->work);\n\t} else {\n\t\tchip->init_complete = 1;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max17042_suspend(struct device *dev)\n{\n\tstruct max17042_chip *chip = dev_get_drvdata(dev);\n\n\t \n\tif (chip->client->irq) {\n\t\tdisable_irq(chip->client->irq);\n\t\tenable_irq_wake(chip->client->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int max17042_resume(struct device *dev)\n{\n\tstruct max17042_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip->client->irq) {\n\t\tdisable_irq_wake(chip->client->irq);\n\t\tenable_irq(chip->client->irq);\n\t\t \n\t\tmax17042_set_soc_threshold(chip, 1);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(max17042_pm_ops, max17042_suspend,\n\t\t\tmax17042_resume);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max17042_acpi_match[] = {\n\t{ \"MAX17047\", MAXIM_DEVICE_TYPE_MAX17047 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, max17042_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max17042_dt_match[] = {\n\t{ .compatible = \"maxim,max17042\" },\n\t{ .compatible = \"maxim,max17047\" },\n\t{ .compatible = \"maxim,max17050\" },\n\t{ .compatible = \"maxim,max17055\" },\n\t{ .compatible = \"maxim,max77849-battery\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max17042_dt_match);\n#endif\n\nstatic const struct i2c_device_id max17042_id[] = {\n\t{ \"max17042\", MAXIM_DEVICE_TYPE_MAX17042 },\n\t{ \"max17047\", MAXIM_DEVICE_TYPE_MAX17047 },\n\t{ \"max17050\", MAXIM_DEVICE_TYPE_MAX17050 },\n\t{ \"max17055\", MAXIM_DEVICE_TYPE_MAX17055 },\n\t{ \"max77849-battery\", MAXIM_DEVICE_TYPE_MAX17047 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max17042_id);\n\nstatic struct i2c_driver max17042_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"max17042\",\n\t\t.acpi_match_table = ACPI_PTR(max17042_acpi_match),\n\t\t.of_match_table = of_match_ptr(max17042_dt_match),\n\t\t.pm\t= &max17042_pm_ops,\n\t},\n\t.probe\t\t= max17042_probe,\n\t.id_table\t= max17042_id,\n};\nmodule_i2c_driver(max17042_i2c_driver);\n\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_DESCRIPTION(\"MAX17042 Fuel Gauge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}