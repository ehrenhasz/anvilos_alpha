{
  "module_name": "apm_power.c",
  "hash_id": "5283b9368f018f1963e7c5c0ac917212ccf6e15a1dc98673690b52ab04c1459e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/apm_power.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/power_supply.h>\n#include <linux/apm-emulation.h>\n\n\n#define PSY_PROP(psy, prop, val) (power_supply_get_property(psy, \\\n\t\t\t POWER_SUPPLY_PROP_##prop, val))\n\n#define _MPSY_PROP(prop, val) (power_supply_get_property(main_battery, \\\n\t\t\t\t\t\t\t prop, val))\n\n#define MPSY_PROP(prop, val) _MPSY_PROP(POWER_SUPPLY_PROP_##prop, val)\n\nstatic DEFINE_MUTEX(apm_mutex);\nstatic struct power_supply *main_battery;\n\nenum apm_source {\n\tSOURCE_ENERGY,\n\tSOURCE_CHARGE,\n\tSOURCE_VOLTAGE,\n};\n\nstruct find_bat_param {\n\tstruct power_supply *main;\n\tstruct power_supply *bat;\n\tstruct power_supply *max_charge_bat;\n\tstruct power_supply *max_energy_bat;\n\tunion power_supply_propval full;\n\tint max_charge;\n\tint max_energy;\n};\n\nstatic int __find_main_battery(struct device *dev, void *data)\n{\n\tstruct find_bat_param *bp = (struct find_bat_param *)data;\n\n\tbp->bat = dev_get_drvdata(dev);\n\n\tif (bp->bat->desc->use_for_apm) {\n\t\t \n\t\tbp->main = bp->bat;\n\t\treturn 1;\n\t}\n\n\tif (!PSY_PROP(bp->bat, CHARGE_FULL_DESIGN, &bp->full) ||\n\t\t\t!PSY_PROP(bp->bat, CHARGE_FULL, &bp->full)) {\n\t\tif (bp->full.intval > bp->max_charge) {\n\t\t\tbp->max_charge_bat = bp->bat;\n\t\t\tbp->max_charge = bp->full.intval;\n\t\t}\n\t} else if (!PSY_PROP(bp->bat, ENERGY_FULL_DESIGN, &bp->full) ||\n\t\t\t!PSY_PROP(bp->bat, ENERGY_FULL, &bp->full)) {\n\t\tif (bp->full.intval > bp->max_energy) {\n\t\t\tbp->max_energy_bat = bp->bat;\n\t\t\tbp->max_energy = bp->full.intval;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void find_main_battery(void)\n{\n\tstruct find_bat_param bp;\n\tint error;\n\n\tmemset(&bp, 0, sizeof(struct find_bat_param));\n\tmain_battery = NULL;\n\tbp.main = main_battery;\n\n\terror = class_for_each_device(power_supply_class, NULL, &bp,\n\t\t\t\t      __find_main_battery);\n\tif (error) {\n\t\tmain_battery = bp.main;\n\t\treturn;\n\t}\n\n\tif ((bp.max_energy_bat && bp.max_charge_bat) &&\n\t\t\t(bp.max_energy_bat != bp.max_charge_bat)) {\n\t\t \n\t\tif (!PSY_PROP(bp.max_charge_bat, VOLTAGE_MAX_DESIGN,\n\t\t\t      &bp.full)) {\n\t\t\tif (bp.max_energy > bp.max_charge * bp.full.intval)\n\t\t\t\tmain_battery = bp.max_energy_bat;\n\t\t\telse\n\t\t\t\tmain_battery = bp.max_charge_bat;\n\t\t} else if (!PSY_PROP(bp.max_energy_bat, VOLTAGE_MAX_DESIGN,\n\t\t\t\t\t\t\t\t  &bp.full)) {\n\t\t\tif (bp.max_charge > bp.max_energy / bp.full.intval)\n\t\t\t\tmain_battery = bp.max_charge_bat;\n\t\t\telse\n\t\t\t\tmain_battery = bp.max_energy_bat;\n\t\t} else {\n\t\t\t \n\t\t\tmain_battery = bp.max_energy_bat;\n\t\t}\n\t} else if (bp.max_charge_bat) {\n\t\tmain_battery = bp.max_charge_bat;\n\t} else if (bp.max_energy_bat) {\n\t\tmain_battery = bp.max_energy_bat;\n\t} else {\n\t\t \n\t\tmain_battery = bp.bat;\n\t}\n}\n\nstatic int do_calculate_time(int status, enum apm_source source)\n{\n\tunion power_supply_propval full;\n\tunion power_supply_propval empty;\n\tunion power_supply_propval cur;\n\tunion power_supply_propval I;\n\tenum power_supply_property full_prop;\n\tenum power_supply_property full_design_prop;\n\tenum power_supply_property empty_prop;\n\tenum power_supply_property empty_design_prop;\n\tenum power_supply_property cur_avg_prop;\n\tenum power_supply_property cur_now_prop;\n\n\tif (MPSY_PROP(CURRENT_AVG, &I)) {\n\t\t \n\t\tif (MPSY_PROP(CURRENT_NOW, &I))\n\t\t\treturn -1;\n\t}\n\n\tif (!I.intval)\n\t\treturn 0;\n\n\tswitch (source) {\n\tcase SOURCE_CHARGE:\n\t\tfull_prop = POWER_SUPPLY_PROP_CHARGE_FULL;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\n\t\tempty_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\n\t\tcur_avg_prop = POWER_SUPPLY_PROP_CHARGE_AVG;\n\t\tcur_now_prop = POWER_SUPPLY_PROP_CHARGE_NOW;\n\t\tbreak;\n\tcase SOURCE_ENERGY:\n\t\tfull_prop = POWER_SUPPLY_PROP_ENERGY_FULL;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\n\t\tempty_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\n\t\tcur_avg_prop = POWER_SUPPLY_PROP_ENERGY_AVG;\n\t\tcur_now_prop = POWER_SUPPLY_PROP_ENERGY_NOW;\n\t\tbreak;\n\tcase SOURCE_VOLTAGE:\n\t\tfull_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\n\t\tempty_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\n\t\tcur_avg_prop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\n\t\tcur_now_prop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unsupported source: %d\\n\", source);\n\t\treturn -1;\n\t}\n\n\tif (_MPSY_PROP(full_prop, &full)) {\n\t\t \n\t\tif (_MPSY_PROP(full_design_prop, &full))\n\t\t\treturn -1;\n\t}\n\n\tif (_MPSY_PROP(empty_prop, &empty)) {\n\t\t \n\t\tif (_MPSY_PROP(empty_design_prop, &empty))\n\t\t\tempty.intval = 0;\n\t}\n\n\tif (_MPSY_PROP(cur_avg_prop, &cur)) {\n\t\t \n\t\tif (_MPSY_PROP(cur_now_prop, &cur))\n\t\t\treturn -1;\n\t}\n\n\tif (status == POWER_SUPPLY_STATUS_CHARGING)\n\t\treturn ((cur.intval - full.intval) * 60L) / I.intval;\n\telse\n\t\treturn -((cur.intval - empty.intval) * 60L) / I.intval;\n}\n\nstatic int calculate_time(int status)\n{\n\tint time;\n\n\ttime = do_calculate_time(status, SOURCE_ENERGY);\n\tif (time != -1)\n\t\treturn time;\n\n\ttime = do_calculate_time(status, SOURCE_CHARGE);\n\tif (time != -1)\n\t\treturn time;\n\n\ttime = do_calculate_time(status, SOURCE_VOLTAGE);\n\tif (time != -1)\n\t\treturn time;\n\n\treturn -1;\n}\n\nstatic int calculate_capacity(enum apm_source source)\n{\n\tenum power_supply_property full_prop, empty_prop;\n\tenum power_supply_property full_design_prop, empty_design_prop;\n\tenum power_supply_property now_prop, avg_prop;\n\tunion power_supply_propval empty, full, cur;\n\tint ret;\n\n\tswitch (source) {\n\tcase SOURCE_CHARGE:\n\t\tfull_prop = POWER_SUPPLY_PROP_CHARGE_FULL;\n\t\tempty_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN;\n\t\tnow_prop = POWER_SUPPLY_PROP_CHARGE_NOW;\n\t\tavg_prop = POWER_SUPPLY_PROP_CHARGE_AVG;\n\t\tbreak;\n\tcase SOURCE_ENERGY:\n\t\tfull_prop = POWER_SUPPLY_PROP_ENERGY_FULL;\n\t\tempty_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN;\n\t\tnow_prop = POWER_SUPPLY_PROP_ENERGY_NOW;\n\t\tavg_prop = POWER_SUPPLY_PROP_ENERGY_AVG;\n\t\tbreak;\n\tcase SOURCE_VOLTAGE:\n\t\tfull_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\n\t\tempty_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\n\t\tfull_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\n\t\tempty_design_prop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\n\t\tnow_prop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\n\t\tavg_prop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unsupported source: %d\\n\", source);\n\t\treturn -1;\n\t}\n\n\tif (_MPSY_PROP(full_prop, &full)) {\n\t\t \n\t\tif (_MPSY_PROP(full_design_prop, &full))\n\t\t\treturn -1;\n\t}\n\n\tif (_MPSY_PROP(avg_prop, &cur)) {\n\t\t \n\t\tif (_MPSY_PROP(now_prop, &cur))\n\t\t\treturn -1;\n\t}\n\n\tif (_MPSY_PROP(empty_prop, &empty)) {\n\t\t \n\t\tif (_MPSY_PROP(empty_design_prop, &empty))\n\t\t\tempty.intval = 0;\n\t}\n\n\tif (full.intval - empty.intval)\n\t\tret =  ((cur.intval - empty.intval) * 100L) /\n\t\t       (full.intval - empty.intval);\n\telse\n\t\treturn -1;\n\n\tif (ret > 100)\n\t\treturn 100;\n\telse if (ret < 0)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic void apm_battery_apm_get_power_status(struct apm_power_info *info)\n{\n\tunion power_supply_propval status;\n\tunion power_supply_propval capacity, time_to_full, time_to_empty;\n\n\tmutex_lock(&apm_mutex);\n\tfind_main_battery();\n\tif (!main_battery) {\n\t\tmutex_unlock(&apm_mutex);\n\t\treturn;\n\t}\n\n\t \n\n\tif (MPSY_PROP(STATUS, &status))\n\t\tstatus.intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\t \n\n\tif ((status.intval == POWER_SUPPLY_STATUS_CHARGING) ||\n\t    (status.intval == POWER_SUPPLY_STATUS_NOT_CHARGING) ||\n\t    (status.intval == POWER_SUPPLY_STATUS_FULL))\n\t\tinfo->ac_line_status = APM_AC_ONLINE;\n\telse\n\t\tinfo->ac_line_status = APM_AC_OFFLINE;\n\n\t \n\n\tif (MPSY_PROP(CAPACITY, &capacity) == 0) {\n\t\tinfo->battery_life = capacity.intval;\n\t} else {\n\t\t \n\t\tinfo->battery_life = calculate_capacity(SOURCE_ENERGY);\n\t\t \n\t\tif (info->battery_life == -1)\n\t\t\tinfo->battery_life = calculate_capacity(SOURCE_CHARGE);\n\t\tif (info->battery_life == -1)\n\t\t\tinfo->battery_life = calculate_capacity(SOURCE_VOLTAGE);\n\t}\n\n\t \n\n\tif (status.intval == POWER_SUPPLY_STATUS_CHARGING) {\n\t\tinfo->battery_status = APM_BATTERY_STATUS_CHARGING;\n\t} else {\n\t\tif (info->battery_life > 50)\n\t\t\tinfo->battery_status = APM_BATTERY_STATUS_HIGH;\n\t\telse if (info->battery_life > 5)\n\t\t\tinfo->battery_status = APM_BATTERY_STATUS_LOW;\n\t\telse\n\t\t\tinfo->battery_status = APM_BATTERY_STATUS_CRITICAL;\n\t}\n\tinfo->battery_flag = info->battery_status;\n\n\t \n\n\tinfo->units = APM_UNITS_MINS;\n\n\tif (status.intval == POWER_SUPPLY_STATUS_CHARGING) {\n\t\tif (!MPSY_PROP(TIME_TO_FULL_AVG, &time_to_full) ||\n\t\t\t\t!MPSY_PROP(TIME_TO_FULL_NOW, &time_to_full))\n\t\t\tinfo->time = time_to_full.intval / 60;\n\t\telse\n\t\t\tinfo->time = calculate_time(status.intval);\n\t} else {\n\t\tif (!MPSY_PROP(TIME_TO_EMPTY_AVG, &time_to_empty) ||\n\t\t\t      !MPSY_PROP(TIME_TO_EMPTY_NOW, &time_to_empty))\n\t\t\tinfo->time = time_to_empty.intval / 60;\n\t\telse\n\t\t\tinfo->time = calculate_time(status.intval);\n\t}\n\n\tmutex_unlock(&apm_mutex);\n}\n\nstatic int __init apm_battery_init(void)\n{\n\tprintk(KERN_INFO \"APM Battery Driver\\n\");\n\n\tapm_get_power_status = apm_battery_apm_get_power_status;\n\treturn 0;\n}\n\nstatic void __exit apm_battery_exit(void)\n{\n\tapm_get_power_status = NULL;\n}\n\nmodule_init(apm_battery_init);\nmodule_exit(apm_battery_exit);\n\nMODULE_AUTHOR(\"Eugeny Boger <eugenyboger@dgap.mipt.ru>\");\nMODULE_DESCRIPTION(\"APM emulation driver for battery monitoring class\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}