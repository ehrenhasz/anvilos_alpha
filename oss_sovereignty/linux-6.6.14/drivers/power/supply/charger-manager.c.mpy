{
  "module_name": "charger-manager.c",
  "hash_id": "20d111e95231926a1d282d35062141d0fd5abe912b65d2cda591fb42a381ee9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/charger-manager.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/power/charger-manager.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sysfs.h>\n#include <linux/of.h>\n#include <linux/thermal.h>\n\nstatic struct {\n\tconst char *name;\n\tu64 extcon_type;\n} extcon_mapping[] = {\n\t \n\t{ \"USB\", EXTCON_USB },\n\t{ \"USB-HOST\", EXTCON_USB_HOST },\n\t{ \"SDP\", EXTCON_CHG_USB_SDP },\n\t{ \"DCP\", EXTCON_CHG_USB_DCP },\n\t{ \"CDP\", EXTCON_CHG_USB_CDP },\n\t{ \"ACA\", EXTCON_CHG_USB_ACA },\n\t{ \"FAST-CHARGER\", EXTCON_CHG_USB_FAST },\n\t{ \"SLOW-CHARGER\", EXTCON_CHG_USB_SLOW },\n\t{ \"WPT\", EXTCON_CHG_WPT },\n\t{ \"PD\", EXTCON_CHG_USB_PD },\n\t{ \"DOCK\", EXTCON_DOCK },\n\t{ \"JIG\", EXTCON_JIG },\n\t{ \"MECHANICAL\", EXTCON_MECHANICAL },\n\t \n\t{ \"TA\", EXTCON_CHG_USB_SDP },\n\t{ \"CHARGE-DOWNSTREAM\", EXTCON_CHG_USB_CDP },\n};\n\n \n#define CM_DEFAULT_RECHARGE_TEMP_DIFF\t50\n#define CM_DEFAULT_CHARGE_TEMP_MAX\t500\n\n \n#define\tCM_JIFFIES_SMALL\t(2)\n\n \n#define CM_MIN_VALID(x, y)\tx = (((y > 0) && ((x) > (y))) ? (y) : (x))\n\n \n#define CM_RTC_SMALL\t\t(2)\n\nstatic LIST_HEAD(cm_list);\nstatic DEFINE_MUTEX(cm_list_mtx);\n\n \nstatic struct alarm *cm_timer;\n\nstatic bool cm_suspended;\nstatic bool cm_timer_set;\nstatic unsigned long cm_suspend_duration_ms;\n\n \nstatic unsigned long polling_jiffy = ULONG_MAX;  \nstatic unsigned long next_polling;  \nstatic struct workqueue_struct *cm_wq;  \nstatic struct delayed_work cm_monitor_work;  \n\n \nstatic bool is_batt_present(struct charger_manager *cm)\n{\n\tunion power_supply_propval val;\n\tstruct power_supply *psy;\n\tbool present = false;\n\tint i, ret;\n\n\tswitch (cm->desc->battery_present) {\n\tcase CM_BATTERY_PRESENT:\n\t\tpresent = true;\n\t\tbreak;\n\tcase CM_NO_BATTERY:\n\t\tbreak;\n\tcase CM_FUEL_GAUGE:\n\t\tpsy = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!psy)\n\t\t\tbreak;\n\n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_PRESENT,\n\t\t\t\t&val);\n\t\tif (ret == 0 && val.intval)\n\t\t\tpresent = true;\n\t\tpower_supply_put(psy);\n\t\tbreak;\n\tcase CM_CHARGER_STAT:\n\t\tfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\n\t\t\tpsy = power_supply_get_by_name(\n\t\t\t\t\tcm->desc->psy_charger_stat[i]);\n\t\t\tif (!psy) {\n\t\t\t\tdev_err(cm->dev, \"Cannot find power supply \\\"%s\\\"\\n\",\n\t\t\t\t\tcm->desc->psy_charger_stat[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = power_supply_get_property(psy,\n\t\t\t\tPOWER_SUPPLY_PROP_PRESENT, &val);\n\t\t\tpower_supply_put(psy);\n\t\t\tif (ret == 0 && val.intval) {\n\t\t\t\tpresent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn present;\n}\n\n \nstatic bool is_ext_pwr_online(struct charger_manager *cm)\n{\n\tunion power_supply_propval val;\n\tstruct power_supply *psy;\n\tbool online = false;\n\tint i, ret;\n\n\t \n\tfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\n\t\tpsy = power_supply_get_by_name(cm->desc->psy_charger_stat[i]);\n\t\tif (!psy) {\n\t\t\tdev_err(cm->dev, \"Cannot find power supply \\\"%s\\\"\\n\",\n\t\t\t\t\tcm->desc->psy_charger_stat[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t&val);\n\t\tpower_supply_put(psy);\n\t\tif (ret == 0 && val.intval) {\n\t\t\tonline = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn online;\n}\n\n \nstatic int get_batt_uV(struct charger_manager *cm, int *uV)\n{\n\tunion power_supply_propval val;\n\tstruct power_supply *fuel_gauge;\n\tint ret;\n\n\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\tif (!fuel_gauge)\n\t\treturn -ENODEV;\n\n\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_VOLTAGE_NOW, &val);\n\tpower_supply_put(fuel_gauge);\n\tif (ret)\n\t\treturn ret;\n\n\t*uV = val.intval;\n\treturn 0;\n}\n\n \nstatic bool is_charging(struct charger_manager *cm)\n{\n\tint i, ret;\n\tbool charging = false;\n\tstruct power_supply *psy;\n\tunion power_supply_propval val;\n\n\t \n\tif (!is_batt_present(cm))\n\t\treturn false;\n\n\t \n\tfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\n\t\t \n\t\tif (cm->emergency_stop)\n\t\t\tcontinue;\n\t\tif (!cm->charger_enabled)\n\t\t\tcontinue;\n\n\t\tpsy = power_supply_get_by_name(cm->desc->psy_charger_stat[i]);\n\t\tif (!psy) {\n\t\t\tdev_err(cm->dev, \"Cannot find power supply \\\"%s\\\"\\n\",\n\t\t\t\t\tcm->desc->psy_charger_stat[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t&val);\n\t\tif (ret) {\n\t\t\tdev_warn(cm->dev, \"Cannot read ONLINE value from %s\\n\",\n\t\t\t\t cm->desc->psy_charger_stat[i]);\n\t\t\tpower_supply_put(psy);\n\t\t\tcontinue;\n\t\t}\n\t\tif (val.intval == 0) {\n\t\t\tpower_supply_put(psy);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_STATUS,\n\t\t\t\t&val);\n\t\tpower_supply_put(psy);\n\t\tif (ret) {\n\t\t\tdev_warn(cm->dev, \"Cannot read STATUS value from %s\\n\",\n\t\t\t\t cm->desc->psy_charger_stat[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (val.intval == POWER_SUPPLY_STATUS_FULL ||\n\t\t\t\tval.intval == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tval.intval == POWER_SUPPLY_STATUS_NOT_CHARGING)\n\t\t\tcontinue;\n\n\t\t \n\t\tcharging = true;\n\t\tbreak;\n\t}\n\n\treturn charging;\n}\n\n \nstatic bool is_full_charged(struct charger_manager *cm)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tunion power_supply_propval val;\n\tstruct power_supply *fuel_gauge;\n\tbool is_full = false;\n\tint ret = 0;\n\tint uV;\n\n\t \n\tif (!is_batt_present(cm))\n\t\treturn false;\n\n\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\tif (!fuel_gauge)\n\t\treturn false;\n\n\t \n\tif (desc->fullbatt_uV > 0) {\n\t\tret = get_batt_uV(cm, &uV);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (cm->battery_status == POWER_SUPPLY_STATUS_FULL\n\t\t\t\t\t&& desc->fullbatt_vchkdrop_uV)\n\t\t\t\tuV += desc->fullbatt_vchkdrop_uV;\n\t\t\tif (uV >= desc->fullbatt_uV)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (desc->fullbatt_full_capacity > 0) {\n\t\tval.intval = 0;\n\n\t\t \n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_CHARGE_FULL, &val);\n\t\tif (!ret && val.intval > desc->fullbatt_full_capacity) {\n\t\t\tis_full = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (desc->fullbatt_soc > 0) {\n\t\tval.intval = 0;\n\n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_CAPACITY, &val);\n\t\tif (!ret && val.intval >= desc->fullbatt_soc) {\n\t\t\tis_full = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tpower_supply_put(fuel_gauge);\n\treturn is_full;\n}\n\n \nstatic bool is_polling_required(struct charger_manager *cm)\n{\n\tswitch (cm->desc->polling_mode) {\n\tcase CM_POLL_DISABLE:\n\t\treturn false;\n\tcase CM_POLL_ALWAYS:\n\t\treturn true;\n\tcase CM_POLL_EXTERNAL_POWER_ONLY:\n\t\treturn is_ext_pwr_online(cm);\n\tcase CM_POLL_CHARGING_ONLY:\n\t\treturn is_charging(cm);\n\tdefault:\n\t\tdev_warn(cm->dev, \"Incorrect polling_mode (%d)\\n\",\n\t\t\t cm->desc->polling_mode);\n\t}\n\n\treturn false;\n}\n\n \nstatic int try_charger_enable(struct charger_manager *cm, bool enable)\n{\n\tint err = 0, i;\n\tstruct charger_desc *desc = cm->desc;\n\n\t \n\tif (enable == cm->charger_enabled)\n\t\treturn 0;\n\n\tif (enable) {\n\t\tif (cm->emergency_stop)\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tcm->charging_start_time = ktime_to_ms(ktime_get());\n\t\tcm->charging_end_time = 0;\n\n\t\tfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\n\t\t\tif (desc->charger_regulators[i].externally_control)\n\t\t\t\tcontinue;\n\n\t\t\terr = regulator_enable(desc->charger_regulators[i].consumer);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_warn(cm->dev, \"Cannot enable %s regulator\\n\",\n\t\t\t\t\t desc->charger_regulators[i].regulator_name);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tcm->charging_start_time = 0;\n\t\tcm->charging_end_time = ktime_to_ms(ktime_get());\n\n\t\tfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\n\t\t\tif (desc->charger_regulators[i].externally_control)\n\t\t\t\tcontinue;\n\n\t\t\terr = regulator_disable(desc->charger_regulators[i].consumer);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_warn(cm->dev, \"Cannot disable %s regulator\\n\",\n\t\t\t\t\t desc->charger_regulators[i].regulator_name);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < desc->num_charger_regulators; i++) {\n\t\t\tif (regulator_is_enabled(\n\t\t\t\t    desc->charger_regulators[i].consumer)) {\n\t\t\t\tregulator_force_disable(\n\t\t\t\t\tdesc->charger_regulators[i].consumer);\n\t\t\t\tdev_warn(cm->dev, \"Disable regulator(%s) forcibly\\n\",\n\t\t\t\t\t desc->charger_regulators[i].regulator_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err)\n\t\tcm->charger_enabled = enable;\n\n\treturn err;\n}\n\n \nstatic int check_charging_duration(struct charger_manager *cm)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tu64 curr = ktime_to_ms(ktime_get());\n\tu64 duration;\n\tint ret = false;\n\n\tif (!desc->charging_max_duration_ms &&\n\t\t\t!desc->discharging_max_duration_ms)\n\t\treturn ret;\n\n\tif (cm->charger_enabled) {\n\t\tduration = curr - cm->charging_start_time;\n\n\t\tif (duration > desc->charging_max_duration_ms) {\n\t\t\tdev_info(cm->dev, \"Charging duration exceed %ums\\n\",\n\t\t\t\t desc->charging_max_duration_ms);\n\t\t\tret = true;\n\t\t}\n\t} else if (cm->battery_status == POWER_SUPPLY_STATUS_NOT_CHARGING) {\n\t\tduration = curr - cm->charging_end_time;\n\n\t\tif (duration > desc->discharging_max_duration_ms) {\n\t\t\tdev_info(cm->dev, \"Discharging duration exceed %ums\\n\",\n\t\t\t\t desc->discharging_max_duration_ms);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cm_get_battery_temperature_by_psy(struct charger_manager *cm,\n\t\t\t\t\tint *temp)\n{\n\tstruct power_supply *fuel_gauge;\n\tint ret;\n\n\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\tif (!fuel_gauge)\n\t\treturn -ENODEV;\n\n\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_TEMP,\n\t\t\t\t(union power_supply_propval *)temp);\n\tpower_supply_put(fuel_gauge);\n\n\treturn ret;\n}\n\nstatic int cm_get_battery_temperature(struct charger_manager *cm,\n\t\t\t\t\tint *temp)\n{\n\tint ret;\n\n\tif (!cm->desc->measure_battery_temp)\n\t\treturn -ENODEV;\n\n#ifdef CONFIG_THERMAL\n\tif (cm->tzd_batt) {\n\t\tret = thermal_zone_get_temp(cm->tzd_batt, temp);\n\t\tif (!ret)\n\t\t\t \n\t\t\t*temp /= 100;\n\t} else\n#endif\n\t{\n\t\t \n\t\tret = cm_get_battery_temperature_by_psy(cm, temp);\n\t}\n\n\treturn ret;\n}\n\nstatic int cm_check_thermal_status(struct charger_manager *cm)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tint temp, upper_limit, lower_limit;\n\tint ret = 0;\n\n\tret = cm_get_battery_temperature(cm, &temp);\n\tif (ret) {\n\t\t \n\t\tdev_err(cm->dev, \"Failed to get battery temperature\\n\");\n\t\treturn 0;\n\t}\n\n\tupper_limit = desc->temp_max;\n\tlower_limit = desc->temp_min;\n\n\tif (cm->emergency_stop) {\n\t\tupper_limit -= desc->temp_diff;\n\t\tlower_limit += desc->temp_diff;\n\t}\n\n\tif (temp > upper_limit)\n\t\tret = CM_BATT_OVERHEAT;\n\telse if (temp < lower_limit)\n\t\tret = CM_BATT_COLD;\n\telse\n\t\tret = CM_BATT_OK;\n\n\tcm->emergency_stop = ret;\n\n\treturn ret;\n}\n\n \nstatic int cm_get_target_status(struct charger_manager *cm)\n{\n\tif (!is_ext_pwr_online(cm))\n\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\n\tif (cm_check_thermal_status(cm)) {\n\t\t \n\t\tif (check_charging_duration(cm))\n\t\t\tgoto charging_ok;\n\t\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t}\n\n\tswitch (cm->battery_status) {\n\tcase POWER_SUPPLY_STATUS_CHARGING:\n\t\t \n\t\tif (check_charging_duration(cm))\n\t\t\treturn POWER_SUPPLY_STATUS_FULL;\n\t\tfallthrough;\n\tcase POWER_SUPPLY_STATUS_FULL:\n\t\tif (is_full_charged(cm))\n\t\t\treturn POWER_SUPPLY_STATUS_FULL;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\ncharging_ok:\n\t \n\treturn POWER_SUPPLY_STATUS_CHARGING;\n}\n\n \nstatic bool _cm_monitor(struct charger_manager *cm)\n{\n\tint target;\n\n\ttarget = cm_get_target_status(cm);\n\n\ttry_charger_enable(cm, (target == POWER_SUPPLY_STATUS_CHARGING));\n\n\tif (cm->battery_status != target) {\n\t\tcm->battery_status = target;\n\t\tpower_supply_changed(cm->charger_psy);\n\t}\n\n\treturn (cm->battery_status == POWER_SUPPLY_STATUS_NOT_CHARGING);\n}\n\n \nstatic bool cm_monitor(void)\n{\n\tbool stop = false;\n\tstruct charger_manager *cm;\n\n\tmutex_lock(&cm_list_mtx);\n\n\tlist_for_each_entry(cm, &cm_list, entry) {\n\t\tif (_cm_monitor(cm))\n\t\t\tstop = true;\n\t}\n\n\tmutex_unlock(&cm_list_mtx);\n\n\treturn stop;\n}\n\n \nstatic void _setup_polling(struct work_struct *work)\n{\n\tunsigned long min = ULONG_MAX;\n\tstruct charger_manager *cm;\n\tbool keep_polling = false;\n\tunsigned long _next_polling;\n\n\tmutex_lock(&cm_list_mtx);\n\n\tlist_for_each_entry(cm, &cm_list, entry) {\n\t\tif (is_polling_required(cm) && cm->desc->polling_interval_ms) {\n\t\t\tkeep_polling = true;\n\n\t\t\tif (min > cm->desc->polling_interval_ms)\n\t\t\t\tmin = cm->desc->polling_interval_ms;\n\t\t}\n\t}\n\n\tpolling_jiffy = msecs_to_jiffies(min);\n\tif (polling_jiffy <= CM_JIFFIES_SMALL)\n\t\tpolling_jiffy = CM_JIFFIES_SMALL + 1;\n\n\tif (!keep_polling)\n\t\tpolling_jiffy = ULONG_MAX;\n\tif (polling_jiffy == ULONG_MAX)\n\t\tgoto out;\n\n\tWARN(cm_wq == NULL, \"charger-manager: workqueue not initialized\"\n\t\t\t    \". try it later. %s\\n\", __func__);\n\n\t \n\t_next_polling = jiffies + polling_jiffy;\n\n\tif (time_before(_next_polling, next_polling)) {\n\t\tmod_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy);\n\t\tnext_polling = _next_polling;\n\t} else {\n\t\tif (queue_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy))\n\t\t\tnext_polling = _next_polling;\n\t}\nout:\n\tmutex_unlock(&cm_list_mtx);\n}\nstatic DECLARE_WORK(setup_polling, _setup_polling);\n\n \nstatic void cm_monitor_poller(struct work_struct *work)\n{\n\tcm_monitor();\n\tschedule_work(&setup_polling);\n}\n\nstatic int charger_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct charger_manager *cm = power_supply_get_drvdata(psy);\n\tstruct charger_desc *desc = cm->desc;\n\tstruct power_supply *fuel_gauge = NULL;\n\tint ret = 0;\n\tint uV;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = cm->battery_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (cm->emergency_stop == CM_BATT_OVERHEAT)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse if (cm->emergency_stop == CM_BATT_COLD)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_COLD;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tif (is_batt_present(cm))\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = get_batt_uV(cm, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!fuel_gauge) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\tPOWER_SUPPLY_PROP_CURRENT_NOW, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\treturn cm_get_battery_temperature(cm, &val->intval);\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (!is_batt_present(cm)) {\n\t\t\t \n\t\t\tval->intval = 100;\n\t\t\tbreak;\n\t\t}\n\n\t\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!fuel_gauge) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\t\tPOWER_SUPPLY_PROP_CAPACITY, val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (val->intval > 100) {\n\t\t\tval->intval = 100;\n\t\t\tbreak;\n\t\t}\n\t\tif (val->intval < 0)\n\t\t\tval->intval = 0;\n\n\t\t \n\t\tif (is_charging(cm))\n\t\t\tbreak;\n\n\t\t \n\t\tret = get_batt_uV(cm, &uV);\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->fullbatt_uV > 0 && uV >= desc->fullbatt_uV &&\n\t\t    !is_charging(cm)) {\n\t\t\tval->intval = 100;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tif (is_ext_pwr_online(cm))\n\t\t\tval->intval = 1;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\n\t\tif (!fuel_gauge) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tret = power_supply_get_property(fuel_gauge, psp, val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (fuel_gauge)\n\t\tpower_supply_put(fuel_gauge);\n\treturn ret;\n}\n\n#define NUM_CHARGER_PSY_OPTIONAL\t(4)\nstatic enum power_supply_property default_charger_props[] = {\n\t \n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\t \n};\n\nstatic const struct power_supply_desc psy_default = {\n\t.name = \"battery\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = default_charger_props,\n\t.num_properties = ARRAY_SIZE(default_charger_props),\n\t.get_property = charger_get_property,\n\t.no_thermal = true,\n};\n\n \nstatic bool cm_setup_timer(void)\n{\n\tstruct charger_manager *cm;\n\tunsigned int wakeup_ms = UINT_MAX;\n\tint timer_req = 0;\n\n\tif (time_after(next_polling, jiffies))\n\t\tCM_MIN_VALID(wakeup_ms,\n\t\t\tjiffies_to_msecs(next_polling - jiffies));\n\n\tmutex_lock(&cm_list_mtx);\n\tlist_for_each_entry(cm, &cm_list, entry) {\n\t\t \n\t\tif (!is_polling_required(cm) && !cm->emergency_stop)\n\t\t\tcontinue;\n\t\ttimer_req++;\n\t\tif (cm->desc->polling_interval_ms == 0)\n\t\t\tcontinue;\n\t\tCM_MIN_VALID(wakeup_ms, cm->desc->polling_interval_ms);\n\t}\n\tmutex_unlock(&cm_list_mtx);\n\n\tif (timer_req && cm_timer) {\n\t\tktime_t now, add;\n\n\t\t \n\t\tif (wakeup_ms == UINT_MAX ||\n\t\t\twakeup_ms < CM_RTC_SMALL * MSEC_PER_SEC)\n\t\t\twakeup_ms = 2 * CM_RTC_SMALL * MSEC_PER_SEC;\n\n\t\tpr_info(\"Charger Manager wakeup timer: %u ms\\n\", wakeup_ms);\n\n\t\tnow = ktime_get_boottime();\n\t\tadd = ktime_set(wakeup_ms / MSEC_PER_SEC,\n\t\t\t\t(wakeup_ms % MSEC_PER_SEC) * NSEC_PER_MSEC);\n\t\talarm_start(cm_timer, ktime_add(now, add));\n\n\t\tcm_suspend_duration_ms = wakeup_ms;\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void charger_extcon_work(struct work_struct *work)\n{\n\tstruct charger_cable *cable =\n\t\t\tcontainer_of(work, struct charger_cable, wq);\n\tint ret;\n\n\tif (cable->attached && cable->min_uA != 0 && cable->max_uA != 0) {\n\t\tret = regulator_set_current_limit(cable->charger->consumer,\n\t\t\t\t\tcable->min_uA, cable->max_uA);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Cannot set current limit of %s (%s)\\n\",\n\t\t\t       cable->charger->regulator_name, cable->name);\n\t\t\treturn;\n\t\t}\n\n\t\tpr_info(\"Set current limit of %s : %duA ~ %duA\\n\",\n\t\t\tcable->charger->regulator_name,\n\t\t\tcable->min_uA, cable->max_uA);\n\t}\n\n\tcancel_delayed_work(&cm_monitor_work);\n\tqueue_delayed_work(cm_wq, &cm_monitor_work, 0);\n}\n\n \nstatic int charger_extcon_notifier(struct notifier_block *self,\n\t\t\tunsigned long event, void *ptr)\n{\n\tstruct charger_cable *cable =\n\t\tcontainer_of(self, struct charger_cable, nb);\n\n\t \n\tcable->attached = event;\n\n\t \n\tschedule_work(&cable->wq);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int charger_extcon_init(struct charger_manager *cm,\n\t\tstruct charger_cable *cable)\n{\n\tint ret, i;\n\tu64 extcon_type = EXTCON_NONE;\n\n\t \n\tINIT_WORK(&cable->wq, charger_extcon_work);\n\tcable->nb.notifier_call = charger_extcon_notifier;\n\n\tcable->extcon_dev = extcon_get_extcon_dev(cable->extcon_name);\n\tif (IS_ERR(cable->extcon_dev)) {\n\t\tpr_err(\"Cannot find extcon_dev for %s (cable: %s)\\n\",\n\t\t\tcable->extcon_name, cable->name);\n\t\treturn PTR_ERR(cable->extcon_dev);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(extcon_mapping); i++) {\n\t\tif (!strcmp(cable->name, extcon_mapping[i].name)) {\n\t\t\textcon_type = extcon_mapping[i].extcon_type;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (extcon_type == EXTCON_NONE) {\n\t\tpr_err(\"Cannot find cable for type %s\", cable->name);\n\t\treturn -EINVAL;\n\t}\n\n\tcable->extcon_type = extcon_type;\n\n\tret = devm_extcon_register_notifier(cm->dev, cable->extcon_dev,\n\t\tcable->extcon_type, &cable->nb);\n\tif (ret < 0) {\n\t\tpr_err(\"Cannot register extcon_dev for %s (cable: %s)\\n\",\n\t\t\tcable->extcon_name, cable->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int charger_manager_register_extcon(struct charger_manager *cm)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tstruct charger_regulator *charger;\n\tunsigned long event;\n\tint ret;\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < desc->num_charger_regulators; i++) {\n\t\tcharger = &desc->charger_regulators[i];\n\n\t\tcharger->consumer = regulator_get(cm->dev,\n\t\t\t\t\tcharger->regulator_name);\n\t\tif (IS_ERR(charger->consumer)) {\n\t\t\tdev_err(cm->dev, \"Cannot find charger(%s)\\n\",\n\t\t\t\tcharger->regulator_name);\n\t\t\treturn PTR_ERR(charger->consumer);\n\t\t}\n\t\tcharger->cm = cm;\n\n\t\tfor (j = 0; j < charger->num_cables; j++) {\n\t\t\tstruct charger_cable *cable = &charger->cables[j];\n\n\t\t\tret = charger_extcon_init(cm, cable);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(cm->dev, \"Cannot initialize charger(%s)\\n\",\n\t\t\t\t\tcharger->regulator_name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcable->charger = charger;\n\t\t\tcable->cm = cm;\n\n\t\t\tevent = extcon_get_state(cable->extcon_dev,\n\t\t\t\tcable->extcon_type);\n\t\t\tcharger_extcon_notifier(&cable->nb,\n\t\t\t\tevent, NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t charger_name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct charger_regulator *charger\n\t\t= container_of(attr, struct charger_regulator, attr_name);\n\n\treturn sysfs_emit(buf, \"%s\\n\", charger->regulator_name);\n}\n\nstatic ssize_t charger_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct charger_regulator *charger\n\t\t= container_of(attr, struct charger_regulator, attr_state);\n\tint state = 0;\n\n\tif (!charger->externally_control)\n\t\tstate = regulator_is_enabled(charger->consumer);\n\n\treturn sysfs_emit(buf, \"%s\\n\", state ? \"enabled\" : \"disabled\");\n}\n\nstatic ssize_t charger_externally_control_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct charger_regulator *charger = container_of(attr,\n\t\t\tstruct charger_regulator, attr_externally_control);\n\n\treturn sysfs_emit(buf, \"%d\\n\", charger->externally_control);\n}\n\nstatic ssize_t charger_externally_control_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct charger_regulator *charger\n\t\t= container_of(attr, struct charger_regulator,\n\t\t\t\t\tattr_externally_control);\n\tstruct charger_manager *cm = charger->cm;\n\tstruct charger_desc *desc = cm->desc;\n\tint i;\n\tint ret;\n\tint externally_control;\n\tint chargers_externally_control = 1;\n\n\tret = sscanf(buf, \"%d\", &externally_control);\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tif (!externally_control) {\n\t\tcharger->externally_control = 0;\n\t\treturn count;\n\t}\n\n\tfor (i = 0; i < desc->num_charger_regulators; i++) {\n\t\tif (&desc->charger_regulators[i] != charger &&\n\t\t\t!desc->charger_regulators[i].externally_control) {\n\t\t\t \n\t\t\tchargers_externally_control = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!chargers_externally_control) {\n\t\tif (cm->charger_enabled) {\n\t\t\ttry_charger_enable(charger->cm, false);\n\t\t\tcharger->externally_control = externally_control;\n\t\t\ttry_charger_enable(charger->cm, true);\n\t\t} else {\n\t\t\tcharger->externally_control = externally_control;\n\t\t}\n\t} else {\n\t\tdev_warn(cm->dev,\n\t\t\t \"'%s' regulator should be controlled in charger-manager because charger-manager must need at least one charger for charging\\n\",\n\t\t\t charger->regulator_name);\n\t}\n\n\treturn count;\n}\n\n \nstatic int charger_manager_prepare_sysfs(struct charger_manager *cm)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tstruct charger_regulator *charger;\n\tint chargers_externally_control = 1;\n\tchar *name;\n\tint i;\n\n\t \n\tfor (i = 0; i < desc->num_charger_regulators; i++) {\n\t\tcharger = &desc->charger_regulators[i];\n\n\t\tname = devm_kasprintf(cm->dev, GFP_KERNEL, \"charger.%d\", i);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tcharger->attrs[0] = &charger->attr_name.attr;\n\t\tcharger->attrs[1] = &charger->attr_state.attr;\n\t\tcharger->attrs[2] = &charger->attr_externally_control.attr;\n\t\tcharger->attrs[3] = NULL;\n\n\t\tcharger->attr_grp.name = name;\n\t\tcharger->attr_grp.attrs = charger->attrs;\n\t\tdesc->sysfs_groups[i] = &charger->attr_grp;\n\n\t\tsysfs_attr_init(&charger->attr_name.attr);\n\t\tcharger->attr_name.attr.name = \"name\";\n\t\tcharger->attr_name.attr.mode = 0444;\n\t\tcharger->attr_name.show = charger_name_show;\n\n\t\tsysfs_attr_init(&charger->attr_state.attr);\n\t\tcharger->attr_state.attr.name = \"state\";\n\t\tcharger->attr_state.attr.mode = 0444;\n\t\tcharger->attr_state.show = charger_state_show;\n\n\t\tsysfs_attr_init(&charger->attr_externally_control.attr);\n\t\tcharger->attr_externally_control.attr.name\n\t\t\t\t= \"externally_control\";\n\t\tcharger->attr_externally_control.attr.mode = 0644;\n\t\tcharger->attr_externally_control.show\n\t\t\t\t= charger_externally_control_show;\n\t\tcharger->attr_externally_control.store\n\t\t\t\t= charger_externally_control_store;\n\n\t\tif (!desc->charger_regulators[i].externally_control ||\n\t\t\t\t!chargers_externally_control)\n\t\t\tchargers_externally_control = 0;\n\n\t\tdev_info(cm->dev, \"'%s' regulator's externally_control is %d\\n\",\n\t\t\t charger->regulator_name, charger->externally_control);\n\t}\n\n\tif (chargers_externally_control) {\n\t\tdev_err(cm->dev, \"Cannot register regulator because charger-manager must need at least one charger for charging battery\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cm_init_thermal_data(struct charger_manager *cm,\n\t\tstruct power_supply *fuel_gauge,\n\t\tenum power_supply_property *properties,\n\t\tsize_t *num_properties)\n{\n\tstruct charger_desc *desc = cm->desc;\n\tunion power_supply_propval val;\n\tint ret;\n\n\t \n\tret = power_supply_get_property(fuel_gauge,\n\t\t\t\t\tPOWER_SUPPLY_PROP_TEMP, &val);\n\n\tif (!ret) {\n\t\tproperties[*num_properties] = POWER_SUPPLY_PROP_TEMP;\n\t\t(*num_properties)++;\n\t\tcm->desc->measure_battery_temp = true;\n\t}\n#ifdef CONFIG_THERMAL\n\tif (ret && desc->thermal_zone) {\n\t\tcm->tzd_batt =\n\t\t\tthermal_zone_get_zone_by_name(desc->thermal_zone);\n\t\tif (IS_ERR(cm->tzd_batt))\n\t\t\treturn PTR_ERR(cm->tzd_batt);\n\n\t\t \n\t\tproperties[*num_properties] = POWER_SUPPLY_PROP_TEMP;\n\t\t(*num_properties)++;\n\t\tcm->desc->measure_battery_temp = true;\n\t\tret = 0;\n\t}\n#endif\n\tif (cm->desc->measure_battery_temp) {\n\t\t \n\t\tif (!desc->temp_max)\n\t\t\tdesc->temp_max = CM_DEFAULT_CHARGE_TEMP_MAX;\n\t\tif (!desc->temp_diff)\n\t\t\tdesc->temp_diff = CM_DEFAULT_RECHARGE_TEMP_DIFF;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id charger_manager_match[] = {\n\t{\n\t\t.compatible = \"charger-manager\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, charger_manager_match);\n\nstatic struct charger_desc *of_cm_parse_desc(struct device *dev)\n{\n\tstruct charger_desc *desc;\n\tstruct device_node *np = dev->of_node;\n\tu32 poll_mode = CM_POLL_DISABLE;\n\tu32 battery_stat = CM_NO_BATTERY;\n\tint num_chgs = 0;\n\n\tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_property_read_string(np, \"cm-name\", &desc->psy_name);\n\n\tof_property_read_u32(np, \"cm-poll-mode\", &poll_mode);\n\tdesc->polling_mode = poll_mode;\n\n\tof_property_read_u32(np, \"cm-poll-interval\",\n\t\t\t\t&desc->polling_interval_ms);\n\n\tof_property_read_u32(np, \"cm-fullbatt-vchkdrop-volt\",\n\t\t\t\t\t&desc->fullbatt_vchkdrop_uV);\n\tof_property_read_u32(np, \"cm-fullbatt-voltage\", &desc->fullbatt_uV);\n\tof_property_read_u32(np, \"cm-fullbatt-soc\", &desc->fullbatt_soc);\n\tof_property_read_u32(np, \"cm-fullbatt-capacity\",\n\t\t\t\t\t&desc->fullbatt_full_capacity);\n\n\tof_property_read_u32(np, \"cm-battery-stat\", &battery_stat);\n\tdesc->battery_present = battery_stat;\n\n\t \n\tnum_chgs = of_property_count_strings(np, \"cm-chargers\");\n\tif (num_chgs > 0) {\n\t\tint i;\n\n\t\t \n\t\tdesc->psy_charger_stat = devm_kcalloc(dev,\n\t\t\t\t\t\t      num_chgs + 1,\n\t\t\t\t\t\t      sizeof(char *),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!desc->psy_charger_stat)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tfor (i = 0; i < num_chgs; i++)\n\t\t\tof_property_read_string_index(np, \"cm-chargers\",\n\t\t\t\t\t\t      i, &desc->psy_charger_stat[i]);\n\t}\n\n\tof_property_read_string(np, \"cm-fuel-gauge\", &desc->psy_fuel_gauge);\n\n\tof_property_read_string(np, \"cm-thermal-zone\", &desc->thermal_zone);\n\n\tof_property_read_u32(np, \"cm-battery-cold\", &desc->temp_min);\n\tif (of_property_read_bool(np, \"cm-battery-cold-in-minus\"))\n\t\tdesc->temp_min *= -1;\n\tof_property_read_u32(np, \"cm-battery-hot\", &desc->temp_max);\n\tof_property_read_u32(np, \"cm-battery-temp-diff\", &desc->temp_diff);\n\n\tof_property_read_u32(np, \"cm-charging-max\",\n\t\t\t\t&desc->charging_max_duration_ms);\n\tof_property_read_u32(np, \"cm-discharging-max\",\n\t\t\t\t&desc->discharging_max_duration_ms);\n\n\t \n\tdesc->num_charger_regulators = of_get_child_count(np);\n\tif (desc->num_charger_regulators) {\n\t\tstruct charger_regulator *chg_regs;\n\t\tstruct device_node *child;\n\n\t\tchg_regs = devm_kcalloc(dev,\n\t\t\t\t\tdesc->num_charger_regulators,\n\t\t\t\t\tsizeof(*chg_regs),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!chg_regs)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tdesc->charger_regulators = chg_regs;\n\n\t\tdesc->sysfs_groups = devm_kcalloc(dev,\n\t\t\t\t\tdesc->num_charger_regulators + 1,\n\t\t\t\t\tsizeof(*desc->sysfs_groups),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!desc->sysfs_groups)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tfor_each_child_of_node(np, child) {\n\t\t\tstruct charger_cable *cables;\n\t\t\tstruct device_node *_child;\n\n\t\t\tof_property_read_string(child, \"cm-regulator-name\",\n\t\t\t\t\t&chg_regs->regulator_name);\n\n\t\t\t \n\t\t\tchg_regs->num_cables = of_get_child_count(child);\n\t\t\tif (chg_regs->num_cables) {\n\t\t\t\tcables = devm_kcalloc(dev,\n\t\t\t\t\t\t      chg_regs->num_cables,\n\t\t\t\t\t\t      sizeof(*cables),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\t\tif (!cables) {\n\t\t\t\t\tof_node_put(child);\n\t\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t\t}\n\n\t\t\t\tchg_regs->cables = cables;\n\n\t\t\t\tfor_each_child_of_node(child, _child) {\n\t\t\t\t\tof_property_read_string(_child,\n\t\t\t\t\t\"cm-cable-name\", &cables->name);\n\t\t\t\t\tof_property_read_string(_child,\n\t\t\t\t\t\"cm-cable-extcon\",\n\t\t\t\t\t&cables->extcon_name);\n\t\t\t\t\tof_property_read_u32(_child,\n\t\t\t\t\t\"cm-cable-min\",\n\t\t\t\t\t&cables->min_uA);\n\t\t\t\t\tof_property_read_u32(_child,\n\t\t\t\t\t\"cm-cable-max\",\n\t\t\t\t\t&cables->max_uA);\n\t\t\t\t\tcables++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchg_regs++;\n\t\t}\n\t}\n\treturn desc;\n}\n\nstatic inline struct charger_desc *cm_get_drv_data(struct platform_device *pdev)\n{\n\tif (pdev->dev.of_node)\n\t\treturn of_cm_parse_desc(&pdev->dev);\n\treturn dev_get_platdata(&pdev->dev);\n}\n\nstatic enum alarmtimer_restart cm_timer_func(struct alarm *alarm, ktime_t now)\n{\n\tcm_timer_set = false;\n\treturn ALARMTIMER_NORESTART;\n}\n\nstatic int charger_manager_probe(struct platform_device *pdev)\n{\n\tstruct charger_desc *desc = cm_get_drv_data(pdev);\n\tstruct charger_manager *cm;\n\tint ret, i = 0;\n\tunion power_supply_propval val;\n\tstruct power_supply *fuel_gauge;\n\tenum power_supply_property *properties;\n\tsize_t num_properties;\n\tstruct power_supply_config psy_cfg = {};\n\n\tif (IS_ERR(desc)) {\n\t\tdev_err(&pdev->dev, \"No platform data (desc) found\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tcm = devm_kzalloc(&pdev->dev, sizeof(*cm), GFP_KERNEL);\n\tif (!cm)\n\t\treturn -ENOMEM;\n\n\t \n\tcm->dev = &pdev->dev;\n\tcm->desc = desc;\n\tpsy_cfg.drv_data = cm;\n\n\t \n\tif (alarmtimer_get_rtcdev()) {\n\t\tcm_timer = devm_kzalloc(cm->dev, sizeof(*cm_timer), GFP_KERNEL);\n\t\tif (!cm_timer)\n\t\t\treturn -ENOMEM;\n\t\talarm_init(cm_timer, ALARM_BOOTTIME, cm_timer_func);\n\t}\n\n\t \n\tif (desc->fullbatt_uV == 0) {\n\t\tdev_info(&pdev->dev, \"Ignoring full-battery voltage threshold as it is not supplied\\n\");\n\t}\n\tif (!desc->fullbatt_vchkdrop_uV) {\n\t\tdev_info(&pdev->dev, \"Disabling full-battery voltage drop checking mechanism as it is not supplied\\n\");\n\t\tdesc->fullbatt_vchkdrop_uV = 0;\n\t}\n\tif (desc->fullbatt_soc == 0) {\n\t\tdev_info(&pdev->dev, \"Ignoring full-battery soc(state of charge) threshold as it is not supplied\\n\");\n\t}\n\tif (desc->fullbatt_full_capacity == 0) {\n\t\tdev_info(&pdev->dev, \"Ignoring full-battery full capacity threshold as it is not supplied\\n\");\n\t}\n\n\tif (!desc->charger_regulators || desc->num_charger_regulators < 1) {\n\t\tdev_err(&pdev->dev, \"charger_regulators undefined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->psy_charger_stat || !desc->psy_charger_stat[0]) {\n\t\tdev_err(&pdev->dev, \"No power supply defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->psy_fuel_gauge) {\n\t\tdev_err(&pdev->dev, \"No fuel gauge power supply defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; desc->psy_charger_stat[i]; i++) {\n\t\tstruct power_supply *psy;\n\n\t\tpsy = power_supply_get_by_name(desc->psy_charger_stat[i]);\n\t\tif (!psy) {\n\t\t\tdev_err(&pdev->dev, \"Cannot find power supply \\\"%s\\\"\\n\",\n\t\t\t\tdesc->psy_charger_stat[i]);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tpower_supply_put(psy);\n\t}\n\n\tif (cm->desc->polling_mode != CM_POLL_DISABLE &&\n\t    (desc->polling_interval_ms == 0 ||\n\t     msecs_to_jiffies(desc->polling_interval_ms) <= CM_JIFFIES_SMALL)) {\n\t\tdev_err(&pdev->dev, \"polling_interval_ms is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->charging_max_duration_ms ||\n\t\t\t!desc->discharging_max_duration_ms) {\n\t\tdev_info(&pdev->dev, \"Cannot limit charging duration checking mechanism to prevent overcharge/overheat and control discharging duration\\n\");\n\t\tdesc->charging_max_duration_ms = 0;\n\t\tdesc->discharging_max_duration_ms = 0;\n\t}\n\n\tplatform_set_drvdata(pdev, cm);\n\n\tmemcpy(&cm->charger_psy_desc, &psy_default, sizeof(psy_default));\n\n\tif (!desc->psy_name)\n\t\tstrncpy(cm->psy_name_buf, psy_default.name, PSY_NAME_MAX);\n\telse\n\t\tstrncpy(cm->psy_name_buf, desc->psy_name, PSY_NAME_MAX);\n\tcm->charger_psy_desc.name = cm->psy_name_buf;\n\n\t \n\tproperties = devm_kcalloc(&pdev->dev,\n\t\t\t     ARRAY_SIZE(default_charger_props) +\n\t\t\t\tNUM_CHARGER_PSY_OPTIONAL,\n\t\t\t     sizeof(*properties), GFP_KERNEL);\n\tif (!properties)\n\t\treturn -ENOMEM;\n\n\tmemcpy(properties, default_charger_props,\n\t\tsizeof(enum power_supply_property) *\n\t\tARRAY_SIZE(default_charger_props));\n\tnum_properties = ARRAY_SIZE(default_charger_props);\n\n\t \n\tfuel_gauge = power_supply_get_by_name(desc->psy_fuel_gauge);\n\tif (!fuel_gauge) {\n\t\tdev_err(&pdev->dev, \"Cannot find power supply \\\"%s\\\"\\n\",\n\t\t\tdesc->psy_fuel_gauge);\n\t\treturn -ENODEV;\n\t}\n\tif (!power_supply_get_property(fuel_gauge,\n\t\t\t\t\tPOWER_SUPPLY_PROP_CHARGE_FULL, &val)) {\n\t\tproperties[num_properties] =\n\t\t\t\tPOWER_SUPPLY_PROP_CHARGE_FULL;\n\t\tnum_properties++;\n\t}\n\tif (!power_supply_get_property(fuel_gauge,\n\t\t\t\t\t  POWER_SUPPLY_PROP_CHARGE_NOW, &val)) {\n\t\tproperties[num_properties] =\n\t\t\t\tPOWER_SUPPLY_PROP_CHARGE_NOW;\n\t\tnum_properties++;\n\t}\n\tif (!power_supply_get_property(fuel_gauge,\n\t\t\t\t\t  POWER_SUPPLY_PROP_CURRENT_NOW,\n\t\t\t\t\t  &val)) {\n\t\tproperties[num_properties] =\n\t\t\t\tPOWER_SUPPLY_PROP_CURRENT_NOW;\n\t\tnum_properties++;\n\t}\n\n\tret = cm_init_thermal_data(cm, fuel_gauge, properties, &num_properties);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize thermal data\\n\");\n\t\tcm->desc->measure_battery_temp = false;\n\t}\n\tpower_supply_put(fuel_gauge);\n\n\tcm->charger_psy_desc.properties = properties;\n\tcm->charger_psy_desc.num_properties = num_properties;\n\n\t \n\tret = charger_manager_prepare_sysfs(cm);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot prepare sysfs entry of regulators\\n\");\n\t\treturn ret;\n\t}\n\tpsy_cfg.attr_grp = desc->sysfs_groups;\n\n\tcm->charger_psy = power_supply_register(&pdev->dev,\n\t\t\t\t\t\t&cm->charger_psy_desc,\n\t\t\t\t\t\t&psy_cfg);\n\tif (IS_ERR(cm->charger_psy)) {\n\t\tdev_err(&pdev->dev, \"Cannot register charger-manager with name \\\"%s\\\"\\n\",\n\t\t\tcm->charger_psy_desc.name);\n\t\treturn PTR_ERR(cm->charger_psy);\n\t}\n\n\t \n\tret = charger_manager_register_extcon(cm);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Cannot initialize extcon device\\n\");\n\t\tgoto err_reg_extcon;\n\t}\n\n\t \n\tmutex_lock(&cm_list_mtx);\n\tlist_add(&cm->entry, &cm_list);\n\tmutex_unlock(&cm_list_mtx);\n\n\t \n\tdevice_init_wakeup(&pdev->dev, true);\n\tdevice_set_wakeup_capable(&pdev->dev, false);\n\n\t \n\tcm_monitor();\n\n\tschedule_work(&setup_polling);\n\n\treturn 0;\n\nerr_reg_extcon:\n\tfor (i = 0; i < desc->num_charger_regulators; i++)\n\t\tregulator_put(desc->charger_regulators[i].consumer);\n\n\tpower_supply_unregister(cm->charger_psy);\n\n\treturn ret;\n}\n\nstatic int charger_manager_remove(struct platform_device *pdev)\n{\n\tstruct charger_manager *cm = platform_get_drvdata(pdev);\n\tstruct charger_desc *desc = cm->desc;\n\tint i = 0;\n\n\t \n\tmutex_lock(&cm_list_mtx);\n\tlist_del(&cm->entry);\n\tmutex_unlock(&cm_list_mtx);\n\n\tcancel_work_sync(&setup_polling);\n\tcancel_delayed_work_sync(&cm_monitor_work);\n\n\tfor (i = 0 ; i < desc->num_charger_regulators ; i++)\n\t\tregulator_put(desc->charger_regulators[i].consumer);\n\n\tpower_supply_unregister(cm->charger_psy);\n\n\ttry_charger_enable(cm, false);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id charger_manager_id[] = {\n\t{ \"charger-manager\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, charger_manager_id);\n\nstatic int cm_suspend_noirq(struct device *dev)\n{\n\tif (device_may_wakeup(dev)) {\n\t\tdevice_set_wakeup_capable(dev, false);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic bool cm_need_to_awake(void)\n{\n\tstruct charger_manager *cm;\n\n\tif (cm_timer)\n\t\treturn false;\n\n\tmutex_lock(&cm_list_mtx);\n\tlist_for_each_entry(cm, &cm_list, entry) {\n\t\tif (is_charging(cm)) {\n\t\t\tmutex_unlock(&cm_list_mtx);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(&cm_list_mtx);\n\n\treturn false;\n}\n\nstatic int cm_suspend_prepare(struct device *dev)\n{\n\tif (cm_need_to_awake())\n\t\treturn -EBUSY;\n\n\tif (!cm_suspended)\n\t\tcm_suspended = true;\n\n\tcm_timer_set = cm_setup_timer();\n\n\tif (cm_timer_set) {\n\t\tcancel_work_sync(&setup_polling);\n\t\tcancel_delayed_work_sync(&cm_monitor_work);\n\t}\n\n\treturn 0;\n}\n\nstatic void cm_suspend_complete(struct device *dev)\n{\n\tstruct charger_manager *cm = dev_get_drvdata(dev);\n\n\tif (cm_suspended)\n\t\tcm_suspended = false;\n\n\tif (cm_timer_set) {\n\t\tktime_t remain;\n\n\t\talarm_cancel(cm_timer);\n\t\tcm_timer_set = false;\n\t\tremain = alarm_expires_remaining(cm_timer);\n\t\tcm_suspend_duration_ms -= ktime_to_ms(remain);\n\t\tschedule_work(&setup_polling);\n\t}\n\n\t_cm_monitor(cm);\n\n\tdevice_set_wakeup_capable(cm->dev, false);\n}\n\nstatic const struct dev_pm_ops charger_manager_pm = {\n\t.prepare\t= cm_suspend_prepare,\n\t.suspend_noirq\t= cm_suspend_noirq,\n\t.complete\t= cm_suspend_complete,\n};\n\nstatic struct platform_driver charger_manager_driver = {\n\t.driver = {\n\t\t.name = \"charger-manager\",\n\t\t.pm = &charger_manager_pm,\n\t\t.of_match_table = charger_manager_match,\n\t},\n\t.probe = charger_manager_probe,\n\t.remove = charger_manager_remove,\n\t.id_table = charger_manager_id,\n};\n\nstatic int __init charger_manager_init(void)\n{\n\tcm_wq = create_freezable_workqueue(\"charger_manager\");\n\tif (unlikely(!cm_wq))\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&cm_monitor_work, cm_monitor_poller);\n\n\treturn platform_driver_register(&charger_manager_driver);\n}\nlate_initcall(charger_manager_init);\n\nstatic void __exit charger_manager_cleanup(void)\n{\n\tdestroy_workqueue(cm_wq);\n\tcm_wq = NULL;\n\n\tplatform_driver_unregister(&charger_manager_driver);\n}\nmodule_exit(charger_manager_cleanup);\n\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_DESCRIPTION(\"Charger Manager\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}