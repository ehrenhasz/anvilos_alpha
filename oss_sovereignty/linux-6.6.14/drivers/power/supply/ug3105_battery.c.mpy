{
  "module_name": "ug3105_battery.c",
  "hash_id": "bd5f04f04b3763b4b010a01646bbc68882c95731b57581b4b639f0852798ee31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ug3105_battery.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/power_supply.h>\n#include <linux/workqueue.h>\n\n#define UG3105_MOV_AVG_WINDOW\t\t\t\t\t8\n#define UG3105_INIT_POLL_TIME\t\t\t\t\t(5 * HZ)\n#define UG3105_POLL_TIME\t\t\t\t\t(30 * HZ)\n#define UG3105_SETTLE_TIME\t\t\t\t\t(1 * HZ)\n\n#define UG3105_INIT_POLL_COUNT\t\t\t\t\t30\n\n#define UG3105_REG_MODE\t\t\t\t\t\t0x00\n#define UG3105_REG_CTRL1\t\t\t\t\t0x01\n#define UG3105_REG_COULOMB_CNT\t\t\t\t\t0x02\n#define UG3105_REG_BAT_VOLT\t\t\t\t\t0x08\n#define UG3105_REG_BAT_CURR\t\t\t\t\t0x0c\n\n#define UG3105_MODE_STANDBY\t\t\t\t\t0x00\n#define UG3105_MODE_RUN\t\t\t\t\t\t0x10\n\n#define UG3105_CTRL1_RESET_COULOMB_CNT\t\t\t\t0x03\n\n#define UG3105_CURR_HYST_UA\t\t\t\t\t65000\n\n#define UG3105_LOW_BAT_UV\t\t\t\t\t3700000\n#define UG3105_FULL_BAT_HYST_UV\t\t\t\t\t38000\n\nstruct ug3105_chip {\n\tstruct i2c_client *client;\n\tstruct power_supply *psy;\n\tstruct power_supply_battery_info *info;\n\tstruct delayed_work work;\n\tstruct mutex lock;\n\tint ocv[UG3105_MOV_AVG_WINDOW];\t\t \n\tint intern_res[UG3105_MOV_AVG_WINDOW];\t \n\tint poll_count;\n\tint ocv_avg_index;\n\tint ocv_avg;\t\t\t\t \n\tint intern_res_poll_count;\n\tint intern_res_avg_index;\n\tint intern_res_avg;\t\t\t \n\tint volt;\t\t\t\t \n\tint curr;\t\t\t\t \n\tint total_coulomb_count;\n\tint uv_per_unit;\n\tint ua_per_unit;\n\tint status;\n\tint capacity;\n\tbool supplied;\n};\n\nstatic int ug3105_read_word(struct i2c_client *client, u8 reg)\n{\n\tint val;\n\n\tval = i2c_smbus_read_word_data(client, reg);\n\tif (val < 0)\n\t\tdev_err(&client->dev, \"Error reading reg 0x%02x\\n\", reg);\n\n\treturn val;\n}\n\nstatic int ug3105_get_status(struct ug3105_chip *chip)\n{\n\tint full = chip->info->constant_charge_voltage_max_uv - UG3105_FULL_BAT_HYST_UV;\n\n\tif (chip->curr > UG3105_CURR_HYST_UA)\n\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\n\tif (chip->curr < -UG3105_CURR_HYST_UA)\n\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\n\tif (chip->supplied && chip->ocv_avg > full)\n\t\treturn POWER_SUPPLY_STATUS_FULL;\n\n\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n}\n\nstatic int ug3105_get_capacity(struct ug3105_chip *chip)\n{\n\t \n\tstatic const int ocv_capacity_tbl[23] = {\n\t\t3350000,\n\t\t3610000,\n\t\t3690000,\n\t\t3710000,\n\t\t3730000,\n\t\t3750000,\n\t\t3770000,\n\t\t3786667,\n\t\t3803333,\n\t\t3820000,\n\t\t3836667,\n\t\t3853333,\n\t\t3870000,\n\t\t3907500,\n\t\t3945000,\n\t\t3982500,\n\t\t4020000,\n\t\t4075000,\n\t\t4110000,\n\t\t4150000,\n\t\t4200000,\n\t\t4250000,\n\t\t4300000,\n\t};\n\tint i, ocv_diff, ocv_step;\n\n\tif (chip->ocv_avg < ocv_capacity_tbl[0])\n\t\treturn 0;\n\n\tif (chip->status == POWER_SUPPLY_STATUS_FULL)\n\t\treturn 100;\n\n\tfor (i = 1; i < ARRAY_SIZE(ocv_capacity_tbl); i++) {\n\t\tif (chip->ocv_avg > ocv_capacity_tbl[i])\n\t\t\tcontinue;\n\n\t\tocv_diff = ocv_capacity_tbl[i] - chip->ocv_avg;\n\t\tocv_step = ocv_capacity_tbl[i] - ocv_capacity_tbl[i - 1];\n\t\t \n\t\tif (chip->info->constant_charge_voltage_max_uv >= 4300000)\n\t\t\treturn (i * 500 - ocv_diff * 500 / ocv_step) / 110;\n\t\telse\n\t\t\treturn i * 5 - ocv_diff * 5 / ocv_step;\n\t}\n\n\treturn 100;\n}\n\nstatic void ug3105_work(struct work_struct *work)\n{\n\tstruct ug3105_chip *chip = container_of(work, struct ug3105_chip,\n\t\t\t\t\t\twork.work);\n\tint i, val, curr_diff, volt_diff, res, win_size;\n\tbool prev_supplied = chip->supplied;\n\tint prev_status = chip->status;\n\tint prev_volt = chip->volt;\n\tint prev_curr = chip->curr;\n\tstruct power_supply *psy;\n\n\tmutex_lock(&chip->lock);\n\n\tpsy = chip->psy;\n\tif (!psy)\n\t\tgoto out;\n\n\tval = ug3105_read_word(chip->client, UG3105_REG_BAT_VOLT);\n\tif (val < 0)\n\t\tgoto out;\n\tchip->volt = val * chip->uv_per_unit;\n\n\tval = ug3105_read_word(chip->client, UG3105_REG_BAT_CURR);\n\tif (val < 0)\n\t\tgoto out;\n\tchip->curr = (s16)val * chip->ua_per_unit;\n\n\tchip->ocv[chip->ocv_avg_index] =\n\t\tchip->volt - chip->curr * chip->intern_res_avg / 1000;\n\tchip->ocv_avg_index = (chip->ocv_avg_index + 1) % UG3105_MOV_AVG_WINDOW;\n\tchip->poll_count++;\n\n\t \n\n\tchip->ocv_avg = 0;\n\twin_size = min(chip->poll_count, UG3105_MOV_AVG_WINDOW);\n\tfor (i = 0; i < win_size; i++)\n\t\tchip->ocv_avg += chip->ocv[i];\n\tchip->ocv_avg /= win_size;\n\n\tchip->supplied = power_supply_am_i_supplied(psy);\n\tchip->status = ug3105_get_status(chip);\n\tchip->capacity = ug3105_get_capacity(chip);\n\n\t \n\tif (chip->supplied != prev_supplied ||\n\t    chip->volt < UG3105_LOW_BAT_UV ||\n\t    chip->poll_count < 2)\n\t\tgoto out;\n\n\t \n\tcurr_diff = abs(chip->curr - prev_curr);\n\tif (curr_diff < UG3105_CURR_HYST_UA)\n\t\tgoto out;\n\n\tvolt_diff = abs(chip->volt - prev_volt);\n\tres = volt_diff * 1000 / curr_diff;\n\n\tif ((res < (chip->intern_res_avg * 2 / 3)) ||\n\t    (res > (chip->intern_res_avg * 4 / 3))) {\n\t\tdev_dbg(&chip->client->dev, \"Ignoring outlier internal resistance %d mOhm\\n\", res);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&chip->client->dev, \"Internal resistance %d mOhm\\n\", res);\n\n\tchip->intern_res[chip->intern_res_avg_index] = res;\n\tchip->intern_res_avg_index = (chip->intern_res_avg_index + 1) % UG3105_MOV_AVG_WINDOW;\n\tchip->intern_res_poll_count++;\n\n\tchip->intern_res_avg = 0;\n\twin_size = min(chip->intern_res_poll_count, UG3105_MOV_AVG_WINDOW);\n\tfor (i = 0; i < win_size; i++)\n\t\tchip->intern_res_avg += chip->intern_res[i];\n\tchip->intern_res_avg /= win_size;\n\nout:\n\tmutex_unlock(&chip->lock);\n\n\tqueue_delayed_work(system_wq, &chip->work,\n\t\t\t   (chip->poll_count <= UG3105_INIT_POLL_COUNT) ?\n\t\t\t\t\tUG3105_INIT_POLL_TIME : UG3105_POLL_TIME);\n\n\tif (chip->status != prev_status && psy)\n\t\tpower_supply_changed(psy);\n}\n\nstatic enum power_supply_property ug3105_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n};\n\nstatic int ug3105_get_property(struct power_supply *psy,\n\t\t\t       enum power_supply_property psp,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct ug3105_chip *chip = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\n\tif (!chip->psy) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = chip->status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = chip->info->technology;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = ug3105_read_word(chip->client, UG3105_REG_BAT_VOLT);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tval->intval = ret * chip->uv_per_unit;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tval->intval = chip->ocv_avg;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = ug3105_read_word(chip->client, UG3105_REG_BAT_CURR);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tval->intval = (s16)ret * chip->ua_per_unit;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = chip->capacity;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic void ug3105_external_power_changed(struct power_supply *psy)\n{\n\tstruct ug3105_chip *chip = power_supply_get_drvdata(psy);\n\n\tdev_dbg(&chip->client->dev, \"external power changed\\n\");\n\tmod_delayed_work(system_wq, &chip->work, UG3105_SETTLE_TIME);\n}\n\nstatic const struct power_supply_desc ug3105_psy_desc = {\n\t.name\t\t= \"ug3105_battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t= ug3105_get_property,\n\t.external_power_changed\t= ug3105_external_power_changed,\n\t.properties\t= ug3105_battery_props,\n\t.num_properties\t= ARRAY_SIZE(ug3105_battery_props),\n};\n\nstatic void ug3105_init(struct ug3105_chip *chip)\n{\n\tchip->poll_count = 0;\n\tchip->ocv_avg_index = 0;\n\tchip->total_coulomb_count = 0;\n\ti2c_smbus_write_byte_data(chip->client, UG3105_REG_MODE,\n\t\t\t\t  UG3105_MODE_RUN);\n\ti2c_smbus_write_byte_data(chip->client, UG3105_REG_CTRL1,\n\t\t\t\t  UG3105_CTRL1_RESET_COULOMB_CNT);\n\tqueue_delayed_work(system_wq, &chip->work, 0);\n\tflush_delayed_work(&chip->work);\n}\n\nstatic int ug3105_probe(struct i2c_client *client)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct device *dev = &client->dev;\n\tu32 curr_sense_res_uohm = 10000;\n\tstruct power_supply *psy;\n\tstruct ug3105_chip *chip;\n\tint ret;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tmutex_init(&chip->lock);\n\tret = devm_delayed_work_autocancel(dev, &chip->work, ug3105_work);\n\tif (ret)\n\t\treturn ret;\n\n\tpsy_cfg.drv_data = chip;\n\tpsy = devm_power_supply_register(dev, &ug3105_psy_desc, &psy_cfg);\n\tif (IS_ERR(psy))\n\t\treturn PTR_ERR(psy);\n\n\tret = power_supply_get_battery_info(psy, &chip->info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->info->factory_internal_resistance_uohm == -EINVAL ||\n\t    chip->info->constant_charge_voltage_max_uv == -EINVAL) {\n\t\tdev_err(dev, \"error required properties are missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_property_read_u32(dev, \"upisemi,rsns-microohm\", &curr_sense_res_uohm);\n\n\t \n\tchip->uv_per_unit = 45000000/65536;\n\t \n\tchip->ua_per_unit = 8100000 / curr_sense_res_uohm;\n\n\t \n\tchip->intern_res_avg = chip->info->factory_internal_resistance_uohm / 1000;\n\t \n\tchip->intern_res[0] = chip->intern_res_avg;\n\tchip->intern_res_avg_index = 1;\n\tchip->intern_res_poll_count = 1;\n\n\tmutex_lock(&chip->lock);\n\tchip->psy = psy;\n\tmutex_unlock(&chip->lock);\n\n\tug3105_init(chip);\n\n\ti2c_set_clientdata(client, chip);\n\treturn 0;\n}\n\nstatic int __maybe_unused ug3105_suspend(struct device *dev)\n{\n\tstruct ug3105_chip *chip = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&chip->work);\n\ti2c_smbus_write_byte_data(chip->client, UG3105_REG_MODE,\n\t\t\t\t  UG3105_MODE_STANDBY);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ug3105_resume(struct device *dev)\n{\n\tstruct ug3105_chip *chip = dev_get_drvdata(dev);\n\n\tug3105_init(chip);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ug3105_pm_ops, ug3105_suspend,\n\t\t\tug3105_resume);\n\nstatic const struct i2c_device_id ug3105_id[] = {\n\t{ \"ug3105\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ug3105_id);\n\nstatic struct i2c_driver ug3105_i2c_driver = {\n\t.driver\t= {\n\t\t.name = \"ug3105\",\n\t\t.pm = &ug3105_pm_ops,\n\t},\n\t.probe = ug3105_probe,\n\t.id_table = ug3105_id,\n};\nmodule_i2c_driver(ug3105_i2c_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com\");\nMODULE_DESCRIPTION(\"uPI uG3105 battery monitor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}