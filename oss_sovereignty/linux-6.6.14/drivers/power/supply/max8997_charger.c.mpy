{
  "module_name": "max8997_charger.c",
  "hash_id": "12169229dcb0d0e8f849a9b3ed12b0401594282e96eeeae7fd0d2eb623995693",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max8997_charger.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/extcon.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/mfd/max8997.h>\n#include <linux/mfd/max8997-private.h>\n#include <linux/regulator/consumer.h>\n#include <linux/devm-helpers.h>\n\n \n#define DCINOK_SHIFT\t\t1\n#define DCINOK_MASK\t\t(1 << DCINOK_SHIFT)\n#define DETBAT_SHIFT\t\t2\n#define DETBAT_MASK\t\t(1 << DETBAT_SHIFT)\n\n \n#define TFCH_SHIFT\t\t4\n#define TFCH_MASK\t\t(7 << TFCH_SHIFT)\n\n \n#define ITOPOFF_SHIFT\t\t0\n#define ITOPOFF_MASK\t\t(0xF << ITOPOFF_SHIFT)\n\nstruct charger_data {\n\tstruct device *dev;\n\tstruct max8997_dev *iodev;\n\tstruct power_supply *battery;\n\tstruct regulator *reg;\n\tstruct extcon_dev *edev;\n\tstruct notifier_block extcon_nb;\n\tstruct work_struct extcon_work;\n};\n\nstatic enum power_supply_property max8997_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,  \n\tPOWER_SUPPLY_PROP_PRESENT,  \n\tPOWER_SUPPLY_PROP_ONLINE,  \n};\n\n \nstatic int max8997_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct charger_data *charger = power_supply_get_drvdata(psy);\n\tstruct i2c_client *i2c = charger->iodev->i2c;\n\tint ret;\n\tu8 reg;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & (1 << 0)) == 0x1)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse if ((reg & DCINOK_MASK))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((reg & DETBAT_MASK) == 0x0)\n\t\t\tval->intval = 1;\n\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = 0;\n\t\tret = max8997_read_reg(i2c, MAX8997_REG_STATUS4, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (reg & DCINOK_MASK)\n\t\t\tval->intval = 1;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void max8997_battery_extcon_evt_worker(struct work_struct *work)\n{\n\tstruct charger_data *charger =\n\t    container_of(work, struct charger_data, extcon_work);\n\tstruct extcon_dev *edev = charger->edev;\n\tint current_limit;\n\n\tif (extcon_get_state(edev, EXTCON_CHG_USB_SDP) > 0) {\n\t\tdev_dbg(charger->dev, \"USB SDP charger is connected\\n\");\n\t\tcurrent_limit = 450000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_DCP) > 0) {\n\t\tdev_dbg(charger->dev, \"USB DCP charger is connected\\n\");\n\t\tcurrent_limit = 650000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_FAST) > 0) {\n\t\tdev_dbg(charger->dev, \"USB FAST charger is connected\\n\");\n\t\tcurrent_limit = 650000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_SLOW) > 0) {\n\t\tdev_dbg(charger->dev, \"USB SLOW charger is connected\\n\");\n\t\tcurrent_limit = 650000;\n\t} else if (extcon_get_state(edev, EXTCON_CHG_USB_CDP) > 0) {\n\t\tdev_dbg(charger->dev, \"USB CDP charger is connected\\n\");\n\t\tcurrent_limit = 650000;\n\t} else {\n\t\tdev_dbg(charger->dev, \"USB charger is disconnected\\n\");\n\t\tcurrent_limit = -1;\n\t}\n\n\tif (current_limit > 0) {\n\t\tint ret = regulator_set_current_limit(charger->reg, current_limit, current_limit);\n\n\t\tif (ret) {\n\t\t\tdev_err(charger->dev, \"failed to set current limit: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t\tret = regulator_enable(charger->reg);\n\t\tif (ret)\n\t\t\tdev_err(charger->dev, \"failed to enable regulator: %d\\n\", ret);\n\t} else {\n\t\tint ret  = regulator_disable(charger->reg);\n\n\t\tif (ret)\n\t\t\tdev_err(charger->dev, \"failed to disable regulator: %d\\n\", ret);\n\t}\n}\n\nstatic int max8997_battery_extcon_evt(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *param)\n{\n\tstruct charger_data *charger =\n\t\tcontainer_of(nb, struct charger_data, extcon_nb);\n\tschedule_work(&charger->extcon_work);\n\treturn NOTIFY_OK;\n}\n\nstatic const struct power_supply_desc max8997_battery_desc = {\n\t.name\t\t= \"max8997_pmic\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t= max8997_battery_get_property,\n\t.properties\t= max8997_battery_props,\n\t.num_properties\t= ARRAY_SIZE(max8997_battery_props),\n};\n\nstatic int max8997_battery_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct charger_data *charger;\n\tstruct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct i2c_client *i2c = iodev->i2c;\n\tstruct max8997_platform_data *pdata = iodev->pdata;\n\tstruct power_supply_config psy_cfg = {};\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No platform data supplied.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->eoc_mA) {\n\t\tint val = (pdata->eoc_mA - 50) / 10;\n\t\tif (val < 0)\n\t\t\tval = 0;\n\t\tif (val > 0xf)\n\t\t\tval = 0xf;\n\n\t\tret = max8997_update_reg(i2c, MAX8997_REG_MBCCTRL5,\n\t\t\t\tval << ITOPOFF_SHIFT, ITOPOFF_MASK);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Cannot use i2c bus.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tswitch (pdata->timeout) {\n\tcase 5:\n\t\tret = max8997_update_reg(i2c, MAX8997_REG_MBCCTRL1,\n\t\t\t\t0x2 << TFCH_SHIFT, TFCH_MASK);\n\t\tbreak;\n\tcase 6:\n\t\tret = max8997_update_reg(i2c, MAX8997_REG_MBCCTRL1,\n\t\t\t\t0x3 << TFCH_SHIFT, TFCH_MASK);\n\t\tbreak;\n\tcase 7:\n\t\tret = max8997_update_reg(i2c, MAX8997_REG_MBCCTRL1,\n\t\t\t\t0x4 << TFCH_SHIFT, TFCH_MASK);\n\t\tbreak;\n\tcase 0:\n\t\tret = max8997_update_reg(i2c, MAX8997_REG_MBCCTRL1,\n\t\t\t\t0x7 << TFCH_SHIFT, TFCH_MASK);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"incorrect timeout value (%d)\\n\",\n\t\t\t\tpdata->timeout);\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Cannot use i2c bus.\\n\");\n\t\treturn ret;\n\t}\n\n\tcharger = devm_kzalloc(&pdev->dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, charger);\n\n\tcharger->dev = &pdev->dev;\n\tcharger->iodev = iodev;\n\n\tpsy_cfg.drv_data = charger;\n\n\tcharger->battery = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t &max8997_battery_desc,\n\t\t\t\t\t\t &psy_cfg);\n\tif (IS_ERR(charger->battery)) {\n\t\tdev_err(&pdev->dev, \"failed: power supply register\\n\");\n\t\treturn PTR_ERR(charger->battery);\n\t}\n\n\t\n\tpdev->dev.of_node = iodev->dev->of_node;\n\tcharger->reg = devm_regulator_get_optional(&pdev->dev, \"charger\");\n\tpdev->dev.of_node = np;\n\tif (IS_ERR(charger->reg)) {\n\t\tif (PTR_ERR(charger->reg) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(&pdev->dev, \"couldn't get charger regulator\\n\");\n\t}\n\tcharger->edev = extcon_get_extcon_dev(\"max8997-muic\");\n\tif (IS_ERR(charger->edev)) {\n\t\tdev_err_probe(charger->dev, PTR_ERR(charger->edev),\n\t\t\t      \"couldn't get extcon device: max8997-muic\\n\");\n\t\treturn PTR_ERR(charger->edev);\n\t}\n\n\tif (!IS_ERR(charger->reg) && !IS_ERR_OR_NULL(charger->edev)) {\n\t\tret = devm_work_autocancel(&pdev->dev, &charger->extcon_work,\n\t\t\t\t\t   max8997_battery_extcon_evt_worker);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to add extcon evt stop action: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tcharger->extcon_nb.notifier_call = max8997_battery_extcon_evt;\n\t\tret = devm_extcon_register_notifier_all(&pdev->dev, charger->edev,\n\t\t\t\t\t\t\t&charger->extcon_nb);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to register extcon notifier\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max8997_battery_id[] = {\n\t{ \"max8997-battery\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, max8997_battery_id);\n\nstatic struct platform_driver max8997_battery_driver = {\n\t.driver = {\n\t\t.name = \"max8997-battery\",\n\t},\n\t.probe = max8997_battery_probe,\n\t.id_table = max8997_battery_id,\n};\nmodule_platform_driver(max8997_battery_driver);\n\nMODULE_DESCRIPTION(\"MAXIM 8997/8966 battery control driver\");\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}