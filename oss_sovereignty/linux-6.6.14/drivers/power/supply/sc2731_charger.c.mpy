{
  "module_name": "sc2731_charger.c",
  "hash_id": "44af4b9fcc19ed6e6d7f931dc24f097d1217f71f36f20fd6fac6d9d071a7ff69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/sc2731_charger.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/usb/phy.h>\n#include <linux/regmap.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n\n \n#define SC2731_CHARGE_STATUS\t\t0xedc\n#define SC2731_CHARGE_FULL\t\tBIT(4)\n#define SC2731_MODULE_EN1\t\t0xc0c\n#define SC2731_CHARGE_EN\t\tBIT(5)\n\n \n#define SC2731_CHG_CFG0\t\t\t0x0\n#define SC2731_CHG_CFG1\t\t\t0x4\n#define SC2731_CHG_CFG2\t\t\t0x8\n#define SC2731_CHG_CFG3\t\t\t0xc\n#define SC2731_CHG_CFG4\t\t\t0x10\n#define SC2731_CHG_CFG5\t\t\t0x28\n\n \n#define SC2731_PRECHG_RNG_SHIFT\t\t11\n#define SC2731_PRECHG_RNG_MASK\t\tGENMASK(12, 11)\n\n#define SC2731_TERMINATION_VOL_MASK\tGENMASK(2, 1)\n#define SC2731_TERMINATION_VOL_SHIFT\t1\n#define SC2731_TERMINATION_VOL_CAL_MASK\tGENMASK(8, 3)\n#define SC2731_TERMINATION_VOL_CAL_SHIFT\t3\n#define SC2731_TERMINATION_CUR_MASK\tGENMASK(2, 0)\n\n#define SC2731_CC_EN\t\t\tBIT(13)\n#define SC2731_CHARGER_PD\t\tBIT(0)\n\n \n#define SC2731_CUR_MASK\t\t\tGENMASK(5, 0)\n\n \n#define SC2731_CUR_LIMIT_SHIFT\t\t8\n#define SC2731_CUR_LIMIT_MASK\t\tGENMASK(9, 8)\n\n \n#define SC2731_CURRENT_LIMIT_100\t100\n#define SC2731_CURRENT_LIMIT_500\t500\n#define SC2731_CURRENT_LIMIT_900\t900\n#define SC2731_CURRENT_LIMIT_2000\t2000\n#define SC2731_CURRENT_PRECHG\t\t450\n#define SC2731_CURRENT_STEP\t\t50\n\nstruct sc2731_charger_info {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct usb_phy *usb_phy;\n\tstruct notifier_block usb_notify;\n\tstruct power_supply *psy_usb;\n\tstruct work_struct work;\n\tstruct mutex lock;\n\tbool charging;\n\tu32 base;\n\tu32 limit;\n};\n\nstatic void sc2731_charger_stop_charge(struct sc2731_charger_info *info)\n{\n\tregmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t   SC2731_CC_EN, 0);\n\n\tregmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t   SC2731_CHARGER_PD, SC2731_CHARGER_PD);\n}\n\nstatic int sc2731_charger_start_charge(struct sc2731_charger_info *info)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t\t SC2731_CC_EN, SC2731_CC_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t\t  SC2731_CHARGER_PD, 0);\n}\n\nstatic int sc2731_charger_set_current_limit(struct sc2731_charger_info *info,\n\t\t\t\t\t    u32 limit)\n{\n\tu32 val;\n\n\tif (limit <= SC2731_CURRENT_LIMIT_100)\n\t\tval = 0;\n\telse if (limit <= SC2731_CURRENT_LIMIT_500)\n\t\tval = 3;\n\telse if (limit <= SC2731_CURRENT_LIMIT_900)\n\t\tval = 2;\n\telse\n\t\tval = 1;\n\n\treturn regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG5,\n\t\t\t\t  SC2731_CUR_LIMIT_MASK,\n\t\t\t\t  val << SC2731_CUR_LIMIT_SHIFT);\n}\n\nstatic int sc2731_charger_set_current(struct sc2731_charger_info *info, u32 cur)\n{\n\tu32 val;\n\tint ret;\n\n\tif (cur > SC2731_CURRENT_LIMIT_2000)\n\t\tcur = SC2731_CURRENT_LIMIT_2000;\n\telse if (cur < SC2731_CURRENT_PRECHG)\n\t\tcur = SC2731_CURRENT_PRECHG;\n\n\t \n\tval = (cur - SC2731_CURRENT_PRECHG) / SC2731_CURRENT_STEP;\n\n\t \n\tret = regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t\t SC2731_PRECHG_RNG_MASK,\n\t\t\t\t 0x3 << SC2731_PRECHG_RNG_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG1,\n\t\t\t\t  SC2731_CUR_MASK, val);\n}\n\nstatic int sc2731_charger_get_status(struct sc2731_charger_info *info)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(info->regmap, SC2731_CHARGE_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & SC2731_CHARGE_FULL)\n\t\treturn POWER_SUPPLY_STATUS_FULL;\n\n\treturn POWER_SUPPLY_STATUS_CHARGING;\n}\n\nstatic int sc2731_charger_get_current(struct sc2731_charger_info *info,\n\t\t\t\t      u32 *cur)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(info->regmap, info->base + SC2731_CHG_CFG1, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= SC2731_CUR_MASK;\n\t*cur = val * SC2731_CURRENT_STEP + SC2731_CURRENT_PRECHG;\n\n\treturn 0;\n}\n\nstatic int sc2731_charger_get_current_limit(struct sc2731_charger_info *info,\n\t\t\t\t\t    u32 *cur)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(info->regmap, info->base + SC2731_CHG_CFG5, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & SC2731_CUR_LIMIT_MASK) >> SC2731_CUR_LIMIT_SHIFT;\n\n\tswitch (val) {\n\tcase 0:\n\t\t*cur = SC2731_CURRENT_LIMIT_100;\n\t\tbreak;\n\n\tcase 1:\n\t\t*cur = SC2731_CURRENT_LIMIT_2000;\n\t\tbreak;\n\n\tcase 2:\n\t\t*cur = SC2731_CURRENT_LIMIT_900;\n\t\tbreak;\n\n\tcase 3:\n\t\t*cur = SC2731_CURRENT_LIMIT_500;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsc2731_charger_usb_set_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct sc2731_charger_info *info = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\n\tif (!info->charging) {\n\t\tmutex_unlock(&info->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = sc2731_charger_set_current(info, val->intval / 1000);\n\t\tif (ret < 0)\n\t\t\tdev_err(info->dev, \"set charge current failed\\n\");\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = sc2731_charger_set_current_limit(info,\n\t\t\t\t\t\t       val->intval / 1000);\n\t\tif (ret < 0)\n\t\t\tdev_err(info->dev, \"set input current limit failed\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int sc2731_charger_usb_get_property(struct power_supply *psy,\n\t\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct sc2731_charger_info *info = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tu32 cur;\n\n\tmutex_lock(&info->lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (info->charging)\n\t\t\tval->intval = sc2731_charger_get_status(info);\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tif (!info->charging) {\n\t\t\tval->intval = 0;\n\t\t} else {\n\t\t\tret = sc2731_charger_get_current(info, &cur);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tval->intval = cur * 1000;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tif (!info->charging) {\n\t\t\tval->intval = 0;\n\t\t} else {\n\t\t\tret = sc2731_charger_get_current_limit(info, &cur);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tval->intval = cur * 1000;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&info->lock);\n\treturn ret;\n}\n\nstatic int sc2731_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property sc2731_usb_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n};\n\nstatic const struct power_supply_desc sc2731_charger_desc = {\n\t.name\t\t\t= \"sc2731_charger\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= sc2731_usb_props,\n\t.num_properties\t\t= ARRAY_SIZE(sc2731_usb_props),\n\t.get_property\t\t= sc2731_charger_usb_get_property,\n\t.set_property\t\t= sc2731_charger_usb_set_property,\n\t.property_is_writeable\t= sc2731_charger_property_is_writeable,\n};\n\nstatic void sc2731_charger_work(struct work_struct *data)\n{\n\tstruct sc2731_charger_info *info =\n\t\tcontainer_of(data, struct sc2731_charger_info, work);\n\tint ret;\n\n\tmutex_lock(&info->lock);\n\n\tif (info->limit > 0 && !info->charging) {\n\t\t \n\t\tret = sc2731_charger_set_current_limit(info, info->limit);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = sc2731_charger_set_current(info, info->limit);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = sc2731_charger_start_charge(info);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tinfo->charging = true;\n\t} else if (!info->limit && info->charging) {\n\t\t \n\t\tinfo->charging = false;\n\t\tsc2731_charger_stop_charge(info);\n\t}\n\nout:\n\tmutex_unlock(&info->lock);\n}\n\nstatic int sc2731_charger_usb_change(struct notifier_block *nb,\n\t\t\t\t     unsigned long limit, void *data)\n{\n\tstruct sc2731_charger_info *info =\n\t\tcontainer_of(nb, struct sc2731_charger_info, usb_notify);\n\n\tinfo->limit = limit;\n\n\tschedule_work(&info->work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int sc2731_charger_hw_init(struct sc2731_charger_info *info)\n{\n\tstruct power_supply_battery_info *bat_info;\n\tu32 term_currrent, term_voltage, cur_val, vol_val;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(info->regmap, SC2731_MODULE_EN1,\n\t\t\t\t SC2731_CHARGE_EN, SC2731_CHARGE_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = power_supply_get_battery_info(info->psy_usb, &bat_info);\n\tif (ret) {\n\t\tdev_warn(info->dev, \"no battery information is supplied\\n\");\n\n\t\t \n\t\tcur_val = 0x2;\n\t\tvol_val = 0x1;\n\t} else {\n\t\tterm_currrent = bat_info->charge_term_current_ua / 1000;\n\n\t\tif (term_currrent <= 90)\n\t\t\tcur_val = 0;\n\t\telse if (term_currrent >= 265)\n\t\t\tcur_val = 0x7;\n\t\telse\n\t\t\tcur_val = ((term_currrent - 90) / 25) + 1;\n\n\t\tterm_voltage = bat_info->constant_charge_voltage_max_uv / 1000;\n\n\t\tif (term_voltage > 4500)\n\t\t\tterm_voltage = 4500;\n\n\t\tif (term_voltage > 4200)\n\t\t\tvol_val = (term_voltage - 4200) / 100;\n\t\telse\n\t\t\tvol_val = 0;\n\n\t\tpower_supply_put_battery_info(info->psy_usb, bat_info);\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG2,\n\t\t\t\t SC2731_TERMINATION_CUR_MASK, cur_val);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_update_bits(info->regmap, info->base + SC2731_CHG_CFG0,\n\t\t\t\t SC2731_TERMINATION_VOL_MASK |\n\t\t\t\t SC2731_TERMINATION_VOL_CAL_MASK,\n\t\t\t\t (vol_val << SC2731_TERMINATION_VOL_SHIFT) |\n\t\t\t\t (0x6 << SC2731_TERMINATION_VOL_CAL_SHIFT));\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tregmap_update_bits(info->regmap, SC2731_MODULE_EN1, SC2731_CHARGE_EN, 0);\n\treturn ret;\n}\n\nstatic void sc2731_charger_detect_status(struct sc2731_charger_info *info)\n{\n\tunsigned int min, max;\n\n\t \n\tif (info->usb_phy->chg_state != USB_CHARGER_PRESENT)\n\t\treturn;\n\n\tusb_phy_get_charger_current(info->usb_phy, &min, &max);\n\tinfo->limit = min;\n\n\tschedule_work(&info->work);\n}\n\nstatic int sc2731_charger_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sc2731_charger_info *info;\n\tstruct power_supply_config charger_cfg = { };\n\tint ret;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&info->lock);\n\tinfo->dev = &pdev->dev;\n\tINIT_WORK(&info->work, sc2731_charger_work);\n\n\tinfo->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!info->regmap) {\n\t\tdev_err(&pdev->dev, \"failed to get charger regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(np, \"reg\", &info->base);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get register address\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcharger_cfg.drv_data = info;\n\tcharger_cfg.of_node = np;\n\tinfo->psy_usb = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t   &sc2731_charger_desc,\n\t\t\t\t\t\t   &charger_cfg);\n\tif (IS_ERR(info->psy_usb)) {\n\t\tdev_err(&pdev->dev, \"failed to register power supply\\n\");\n\t\treturn PTR_ERR(info->psy_usb);\n\t}\n\n\tret = sc2731_charger_hw_init(info);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->usb_phy = devm_usb_get_phy_by_phandle(&pdev->dev, \"phys\", 0);\n\tif (IS_ERR(info->usb_phy)) {\n\t\tdev_err(&pdev->dev, \"failed to find USB phy\\n\");\n\t\treturn PTR_ERR(info->usb_phy);\n\t}\n\n\tinfo->usb_notify.notifier_call = sc2731_charger_usb_change;\n\tret = usb_register_notifier(info->usb_phy, &info->usb_notify);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register notifier: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsc2731_charger_detect_status(info);\n\n\treturn 0;\n}\n\nstatic int sc2731_charger_remove(struct platform_device *pdev)\n{\n\tstruct sc2731_charger_info *info = platform_get_drvdata(pdev);\n\n\tusb_unregister_notifier(info->usb_phy, &info->usb_notify);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sc2731_charger_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-charger\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sc2731_charger_of_match);\n\nstatic struct platform_driver sc2731_charger_driver = {\n\t.driver = {\n\t\t.name = \"sc2731-charger\",\n\t\t.of_match_table = sc2731_charger_of_match,\n\t},\n\t.probe = sc2731_charger_probe,\n\t.remove = sc2731_charger_remove,\n};\n\nmodule_platform_driver(sc2731_charger_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum SC2731 Charger Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}