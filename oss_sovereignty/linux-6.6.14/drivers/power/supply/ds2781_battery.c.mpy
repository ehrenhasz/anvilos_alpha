{
  "module_name": "ds2781_battery.c",
  "hash_id": "d5b7019742b41d32f2f371b23b246ab61b93f493c388ff75d2203277b44b10b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ds2781_battery.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/param.h>\n#include <linux/pm.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/idr.h>\n\n#include <linux/w1.h>\n#include \"../../w1/slaves/w1_ds2781.h\"\n\n \n#define DS2781_CURRENT_UNITS\t1563\n \n#define DS2781_CHARGE_UNITS\t\t6250\n \n#define DS2781_USER_EEPROM_SIZE\t\t(DS2781_EEPROM_BLOCK0_END - \\\n\t\t\t\t\tDS2781_EEPROM_BLOCK0_START + 1)\n \n#define DS2781_PARAM_EEPROM_SIZE\t(DS2781_EEPROM_BLOCK1_END - \\\n\t\t\t\t\tDS2781_EEPROM_BLOCK1_START + 1)\n\nstruct ds2781_device_info {\n\tstruct device *dev;\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct device *w1_dev;\n};\n\nenum current_types {\n\tCURRENT_NOW,\n\tCURRENT_AVG,\n};\n\nstatic const char model[] = \"DS2781\";\nstatic const char manufacturer[] = \"Maxim/Dallas\";\n\nstatic inline struct ds2781_device_info *\nto_ds2781_device_info(struct power_supply *psy)\n{\n\treturn power_supply_get_drvdata(psy);\n}\n\nstatic inline int ds2781_battery_io(struct ds2781_device_info *dev_info,\n\tchar *buf, int addr, size_t count, int io)\n{\n\treturn w1_ds2781_io(dev_info->w1_dev, buf, addr, count, io);\n}\n\nstatic int w1_ds2781_read(struct ds2781_device_info *dev_info, char *buf,\n\t\tint addr, size_t count)\n{\n\treturn ds2781_battery_io(dev_info, buf, addr, count, 0);\n}\n\nstatic inline int ds2781_read8(struct ds2781_device_info *dev_info, u8 *val,\n\tint addr)\n{\n\treturn ds2781_battery_io(dev_info, val, addr, sizeof(u8), 0);\n}\n\nstatic int ds2781_read16(struct ds2781_device_info *dev_info, s16 *val,\n\tint addr)\n{\n\tint ret;\n\tu8 raw[2];\n\n\tret = ds2781_battery_io(dev_info, raw, addr, sizeof(raw), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = (raw[0] << 8) | raw[1];\n\n\treturn 0;\n}\n\nstatic inline int ds2781_read_block(struct ds2781_device_info *dev_info,\n\tu8 *val, int addr, size_t count)\n{\n\treturn ds2781_battery_io(dev_info, val, addr, count, 0);\n}\n\nstatic inline int ds2781_write(struct ds2781_device_info *dev_info, u8 *val,\n\tint addr, size_t count)\n{\n\treturn ds2781_battery_io(dev_info, val, addr, count, 1);\n}\n\nstatic inline int ds2781_store_eeprom(struct device *dev, int addr)\n{\n\treturn w1_ds2781_eeprom_cmd(dev, addr, W1_DS2781_COPY_DATA);\n}\n\nstatic inline int ds2781_recall_eeprom(struct device *dev, int addr)\n{\n\treturn w1_ds2781_eeprom_cmd(dev, addr, W1_DS2781_RECALL_DATA);\n}\n\nstatic int ds2781_save_eeprom(struct ds2781_device_info *dev_info, int reg)\n{\n\tint ret;\n\n\tret = ds2781_store_eeprom(dev_info->w1_dev, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ds2781_recall_eeprom(dev_info->w1_dev, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int ds2781_set_sense_register(struct ds2781_device_info *dev_info,\n\tu8 conductance)\n{\n\tint ret;\n\n\tret = ds2781_write(dev_info, &conductance,\n\t\t\t\tDS2781_RSNSP, sizeof(u8));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ds2781_save_eeprom(dev_info, DS2781_RSNSP);\n}\n\n \nstatic int ds2781_get_rsgain_register(struct ds2781_device_info *dev_info,\n\tu16 *rsgain)\n{\n\treturn ds2781_read16(dev_info, rsgain, DS2781_RSGAIN_MSB);\n}\n\n \nstatic int ds2781_set_rsgain_register(struct ds2781_device_info *dev_info,\n\tu16 rsgain)\n{\n\tint ret;\n\tu8 raw[] = {rsgain >> 8, rsgain & 0xFF};\n\n\tret = ds2781_write(dev_info, raw,\n\t\t\t\tDS2781_RSGAIN_MSB, sizeof(raw));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ds2781_save_eeprom(dev_info, DS2781_RSGAIN_MSB);\n}\n\nstatic int ds2781_get_voltage(struct ds2781_device_info *dev_info,\n\tint *voltage_uV)\n{\n\tint ret;\n\tchar val[2];\n\tint voltage_raw;\n\n\tret = w1_ds2781_read(dev_info, val, DS2781_VOLT_MSB, 2 * sizeof(u8));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tvoltage_raw = (val[0] << 3) |\n\t\t(val[1] >> 5);\n\n\t \n\t*voltage_uV = voltage_raw * 9760;\n\n\treturn 0;\n}\n\nstatic int ds2781_get_temperature(struct ds2781_device_info *dev_info,\n\tint *temp)\n{\n\tint ret;\n\tchar val[2];\n\tint temp_raw;\n\n\tret = w1_ds2781_read(dev_info, val, DS2781_TEMP_MSB, 2 * sizeof(u8));\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\ttemp_raw = ((val[0]) << 3) |\n\t\t(val[1] >> 5);\n\t*temp = temp_raw + (temp_raw / 4);\n\n\treturn 0;\n}\n\nstatic int ds2781_get_current(struct ds2781_device_info *dev_info,\n\tenum current_types type, int *current_uA)\n{\n\tint ret, sense_res;\n\ts16 current_raw;\n\tu8 sense_res_raw, reg_msb;\n\n\t \n\tret = ds2781_read8(dev_info, &sense_res_raw, DS2781_RSNSP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sense_res_raw == 0) {\n\t\tdev_err(dev_info->dev, \"sense resistor value is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsense_res = 1000 / sense_res_raw;\n\n\tif (type == CURRENT_NOW)\n\t\treg_msb = DS2781_CURRENT_MSB;\n\telse if (type == CURRENT_AVG)\n\t\treg_msb = DS2781_IAVG_MSB;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tret = ds2781_read16(dev_info, &current_raw, reg_msb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*current_uA = current_raw * (DS2781_CURRENT_UNITS / sense_res);\n\treturn 0;\n}\n\nstatic int ds2781_get_accumulated_current(struct ds2781_device_info *dev_info,\n\tint *accumulated_current)\n{\n\tint ret, sense_res;\n\ts16 current_raw;\n\tu8 sense_res_raw;\n\n\t \n\tret = ds2781_read8(dev_info, &sense_res_raw, DS2781_RSNSP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sense_res_raw == 0) {\n\t\tdev_err(dev_info->dev, \"sense resistor value is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsense_res = 1000 / sense_res_raw;\n\n\t \n\tret = ds2781_read16(dev_info, &current_raw, DS2781_ACR_MSB);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*accumulated_current = current_raw * (DS2781_CHARGE_UNITS / sense_res);\n\treturn 0;\n}\n\nstatic int ds2781_get_capacity(struct ds2781_device_info *dev_info,\n\tint *capacity)\n{\n\tint ret;\n\tu8 raw;\n\n\tret = ds2781_read8(dev_info, &raw, DS2781_RARC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*capacity = raw;\n\treturn 0;\n}\n\nstatic int ds2781_get_status(struct ds2781_device_info *dev_info, int *status)\n{\n\tint ret, current_uA, capacity;\n\n\tret = ds2781_get_current(dev_info, CURRENT_NOW, &current_uA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ds2781_get_capacity(dev_info, &capacity);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (power_supply_am_i_supplied(dev_info->bat)) {\n\t\tif (capacity == 100)\n\t\t\t*status = POWER_SUPPLY_STATUS_FULL;\n\t\telse if (current_uA > 50000)\n\t\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\t*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t} else {\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\treturn 0;\n}\n\nstatic int ds2781_get_charge_now(struct ds2781_device_info *dev_info,\n\tint *charge_now)\n{\n\tint ret;\n\tu16 charge_raw;\n\n\t \n\tret = ds2781_read16(dev_info, &charge_raw, DS2781_RAAC_MSB);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*charge_now = charge_raw * 1600;\n\treturn 0;\n}\n\nstatic int ds2781_get_control_register(struct ds2781_device_info *dev_info,\n\tu8 *control_reg)\n{\n\treturn ds2781_read8(dev_info, control_reg, DS2781_CONTROL);\n}\n\nstatic int ds2781_set_control_register(struct ds2781_device_info *dev_info,\n\tu8 control_reg)\n{\n\tint ret;\n\n\tret = ds2781_write(dev_info, &control_reg,\n\t\t\t\tDS2781_CONTROL, sizeof(u8));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ds2781_save_eeprom(dev_info, DS2781_CONTROL);\n}\n\nstatic int ds2781_battery_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tint ret = 0;\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = ds2781_get_voltage(dev_info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = ds2781_get_temperature(dev_info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = model;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = manufacturer;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = ds2781_get_current(dev_info, CURRENT_NOW, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tret = ds2781_get_current(dev_info, CURRENT_AVG, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = ds2781_get_status(dev_info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = ds2781_get_capacity(dev_info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tret = ds2781_get_accumulated_current(dev_info, &val->intval);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tret = ds2781_get_charge_now(dev_info, &val->intval);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property ds2781_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n};\n\nstatic ssize_t ds2781_get_pmod_enabled(struct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tint ret;\n\tu8 control_reg;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\t \n\tret = ds2781_get_control_register(dev_info, &control_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t !!(control_reg & DS2781_CONTROL_PMOD));\n}\n\nstatic ssize_t ds2781_set_pmod_enabled(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count)\n{\n\tint ret;\n\tu8 control_reg, new_setting;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\t \n\tret = ds2781_get_control_register(dev_info, &control_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kstrtou8(buf, 0, &new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((new_setting != 0) && (new_setting != 1)) {\n\t\tdev_err(dev_info->dev, \"Invalid pmod setting (0 or 1)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_setting)\n\t\tcontrol_reg |= DS2781_CONTROL_PMOD;\n\telse\n\t\tcontrol_reg &= ~DS2781_CONTROL_PMOD;\n\n\tret = ds2781_set_control_register(dev_info, control_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t ds2781_get_sense_resistor_value(struct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tint ret;\n\tu8 sense_resistor;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = ds2781_read8(dev_info, &sense_resistor, DS2781_RSNSP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sysfs_emit(buf, \"%d\\n\", sense_resistor);\n\treturn ret;\n}\n\nstatic ssize_t ds2781_set_sense_resistor_value(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count)\n{\n\tint ret;\n\tu8 new_setting;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = kstrtou8(buf, 0, &new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ds2781_set_sense_register(dev_info, new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t ds2781_get_rsgain_setting(struct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tint ret;\n\tu16 rsgain;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = ds2781_get_rsgain_register(dev_info, &rsgain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", rsgain);\n}\n\nstatic ssize_t ds2781_set_rsgain_setting(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count)\n{\n\tint ret;\n\tu16 new_setting;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = kstrtou16(buf, 0, &new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (new_setting > 1999) {\n\t\tdev_err(dev_info->dev, \"Invalid rsgain setting (0 - 1999)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ds2781_set_rsgain_register(dev_info, new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t ds2781_get_pio_pin(struct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tint ret;\n\tu8 sfr;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = ds2781_read8(dev_info, &sfr, DS2781_SFR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sysfs_emit(buf, \"%d\\n\", sfr & DS2781_SFR_PIOSC);\n\treturn ret;\n}\n\nstatic ssize_t ds2781_set_pio_pin(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count)\n{\n\tint ret;\n\tu8 new_setting;\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\tret = kstrtou8(buf, 0, &new_setting);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((new_setting != 0) && (new_setting != 1)) {\n\t\tdev_err(dev_info->dev, \"Invalid pio_pin setting (0 or 1)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ds2781_write(dev_info, &new_setting,\n\t\t\t\tDS2781_SFR, sizeof(u8));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t ds2781_read_param_eeprom_bin(struct file *filp,\n\t\t\t\tstruct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\treturn ds2781_read_block(dev_info, buf,\n\t\t\t\tDS2781_EEPROM_BLOCK1_START + off, count);\n}\n\nstatic ssize_t ds2781_write_param_eeprom_bin(struct file *filp,\n\t\t\t\tstruct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\tint ret;\n\n\tret = ds2781_write(dev_info, buf,\n\t\t\t\tDS2781_EEPROM_BLOCK1_START + off, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ds2781_save_eeprom(dev_info, DS2781_EEPROM_BLOCK1_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic struct bin_attribute ds2781_param_eeprom_bin_attr = {\n\t.attr = {\n\t\t.name = \"param_eeprom\",\n\t\t.mode = S_IRUGO | S_IWUSR,\n\t},\n\t.size = DS2781_PARAM_EEPROM_SIZE,\n\t.read = ds2781_read_param_eeprom_bin,\n\t.write = ds2781_write_param_eeprom_bin,\n};\n\nstatic ssize_t ds2781_read_user_eeprom_bin(struct file *filp,\n\t\t\t\tstruct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\n\treturn ds2781_read_block(dev_info, buf,\n\t\t\t\tDS2781_EEPROM_BLOCK0_START + off, count);\n\n}\n\nstatic ssize_t ds2781_write_user_eeprom_bin(struct file *filp,\n\t\t\t\tstruct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct power_supply *psy = to_power_supply(dev);\n\tstruct ds2781_device_info *dev_info = to_ds2781_device_info(psy);\n\tint ret;\n\n\tret = ds2781_write(dev_info, buf,\n\t\t\t\tDS2781_EEPROM_BLOCK0_START + off, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ds2781_save_eeprom(dev_info, DS2781_EEPROM_BLOCK0_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic struct bin_attribute ds2781_user_eeprom_bin_attr = {\n\t.attr = {\n\t\t.name = \"user_eeprom\",\n\t\t.mode = S_IRUGO | S_IWUSR,\n\t},\n\t.size = DS2781_USER_EEPROM_SIZE,\n\t.read = ds2781_read_user_eeprom_bin,\n\t.write = ds2781_write_user_eeprom_bin,\n};\n\nstatic DEVICE_ATTR(pmod_enabled, S_IRUGO | S_IWUSR, ds2781_get_pmod_enabled,\n\tds2781_set_pmod_enabled);\nstatic DEVICE_ATTR(sense_resistor_value, S_IRUGO | S_IWUSR,\n\tds2781_get_sense_resistor_value, ds2781_set_sense_resistor_value);\nstatic DEVICE_ATTR(rsgain_setting, S_IRUGO | S_IWUSR, ds2781_get_rsgain_setting,\n\tds2781_set_rsgain_setting);\nstatic DEVICE_ATTR(pio_pin, S_IRUGO | S_IWUSR, ds2781_get_pio_pin,\n\tds2781_set_pio_pin);\n\nstatic struct attribute *ds2781_sysfs_attrs[] = {\n\t&dev_attr_pmod_enabled.attr,\n\t&dev_attr_sense_resistor_value.attr,\n\t&dev_attr_rsgain_setting.attr,\n\t&dev_attr_pio_pin.attr,\n\tNULL\n};\n\nstatic struct bin_attribute *ds2781_sysfs_bin_attrs[] = {\n\t&ds2781_param_eeprom_bin_attr,\n\t&ds2781_user_eeprom_bin_attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ds2781_sysfs_group = {\n\t.attrs = ds2781_sysfs_attrs,\n\t.bin_attrs = ds2781_sysfs_bin_attrs,\n\n};\n\nstatic const struct attribute_group *ds2781_sysfs_groups[] = {\n\t&ds2781_sysfs_group,\n\tNULL,\n};\n\nstatic int ds2781_battery_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ds2781_device_info *dev_info;\n\n\tdev_info = devm_kzalloc(&pdev->dev, sizeof(*dev_info), GFP_KERNEL);\n\tif (!dev_info)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev_info);\n\n\tdev_info->dev\t\t\t= &pdev->dev;\n\tdev_info->w1_dev\t\t= pdev->dev.parent;\n\tdev_info->bat_desc.name\t\t= dev_name(&pdev->dev);\n\tdev_info->bat_desc.type\t\t= POWER_SUPPLY_TYPE_BATTERY;\n\tdev_info->bat_desc.properties\t= ds2781_battery_props;\n\tdev_info->bat_desc.num_properties = ARRAY_SIZE(ds2781_battery_props);\n\tdev_info->bat_desc.get_property\t= ds2781_battery_get_property;\n\n\tpsy_cfg.drv_data\t\t= dev_info;\n\tpsy_cfg.attr_grp\t\t= ds2781_sysfs_groups;\n\n\tdev_info->bat = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t   &dev_info->bat_desc,\n\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(dev_info->bat)) {\n\t\tdev_err(dev_info->dev, \"failed to register battery\\n\");\n\t\treturn PTR_ERR(dev_info->bat);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ds2781_battery_driver = {\n\t.driver = {\n\t\t.name = \"ds2781-battery\",\n\t},\n\t.probe\t  = ds2781_battery_probe,\n};\nmodule_platform_driver(ds2781_battery_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Renata Sayakhova <renata@oktetlabs.ru>\");\nMODULE_DESCRIPTION(\"Maxim/Dallas DS2781 Stand-Alone Fuel Gauge IC driver\");\nMODULE_ALIAS(\"platform:ds2781-battery\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}