{
  "module_name": "bq25890_charger.c",
  "hash_id": "97fcf7b173b706437db9ff68b7b256c61293edd12ae3f0be0bc6d16a94f593de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq25890_charger.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/power_supply.h>\n#include <linux/power/bq25890_charger.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/types.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/usb/phy.h>\n\n#include <linux/acpi.h>\n#include <linux/of.h>\n\n#define BQ25890_MANUFACTURER\t\t\"Texas Instruments\"\n#define BQ25890_IRQ_PIN\t\t\t\"bq25890_irq\"\n\n#define BQ25890_ID\t\t\t3\n#define BQ25895_ID\t\t\t7\n#define BQ25896_ID\t\t\t0\n\n#define PUMP_EXPRESS_START_DELAY\t(5 * HZ)\n#define PUMP_EXPRESS_MAX_TRIES\t\t6\n#define PUMP_EXPRESS_VBUS_MARGIN_uV\t1000000\n\nenum bq25890_chip_version {\n\tBQ25890,\n\tBQ25892,\n\tBQ25895,\n\tBQ25896,\n};\n\nstatic const char *const bq25890_chip_name[] = {\n\t\"BQ25890\",\n\t\"BQ25892\",\n\t\"BQ25895\",\n\t\"BQ25896\",\n};\n\nenum bq25890_fields {\n\tF_EN_HIZ, F_EN_ILIM, F_IINLIM,\t\t\t\t      \n\tF_BHOT, F_BCOLD, F_VINDPM_OFS,\t\t\t\t      \n\tF_CONV_START, F_CONV_RATE, F_BOOSTF, F_ICO_EN,\n\tF_HVDCP_EN, F_MAXC_EN, F_FORCE_DPM, F_AUTO_DPDM_EN,\t      \n\tF_BAT_LOAD_EN, F_WD_RST, F_OTG_CFG, F_CHG_CFG, F_SYSVMIN,\n\tF_MIN_VBAT_SEL,\t\t\t\t\t\t      \n\tF_PUMPX_EN, F_ICHG,\t\t\t\t\t      \n\tF_IPRECHG, F_ITERM,\t\t\t\t\t      \n\tF_VREG, F_BATLOWV, F_VRECHG,\t\t\t\t      \n\tF_TERM_EN, F_STAT_DIS, F_WD, F_TMR_EN, F_CHG_TMR,\n\tF_JEITA_ISET,\t\t\t\t\t\t      \n\tF_BATCMP, F_VCLAMP, F_TREG,\t\t\t\t      \n\tF_FORCE_ICO, F_TMR2X_EN, F_BATFET_DIS, F_JEITA_VSET,\n\tF_BATFET_DLY, F_BATFET_RST_EN, F_PUMPX_UP, F_PUMPX_DN,\t      \n\tF_BOOSTV, F_PFM_OTG_DIS, F_BOOSTI,\t\t\t      \n\tF_VBUS_STAT, F_CHG_STAT, F_PG_STAT, F_SDP_STAT, F_0B_RSVD,\n\tF_VSYS_STAT,\t\t\t\t\t\t      \n\tF_WD_FAULT, F_BOOST_FAULT, F_CHG_FAULT, F_BAT_FAULT,\n\tF_NTC_FAULT,\t\t\t\t\t\t      \n\tF_FORCE_VINDPM, F_VINDPM,\t\t\t\t      \n\tF_THERM_STAT, F_BATV,\t\t\t\t\t      \n\tF_SYSV,\t\t\t\t\t\t\t      \n\tF_TSPCT,\t\t\t\t\t\t      \n\tF_VBUS_GD, F_VBUSV,\t\t\t\t\t      \n\tF_ICHGR,\t\t\t\t\t\t      \n\tF_VDPM_STAT, F_IDPM_STAT, F_IDPM_LIM,\t\t\t      \n\tF_REG_RST, F_ICO_OPTIMIZED, F_PN, F_TS_PROFILE, F_DEV_REV,    \n\n\tF_MAX_FIELDS\n};\n\n \nstruct bq25890_init_data {\n\tu8 ichg;\t \n\tu8 vreg;\t \n\tu8 iterm;\t \n\tu8 iprechg;\t \n\tu8 sysvmin;\t \n\tu8 boostv;\t \n\tu8 boosti;\t \n\tu8 boostf;\t \n\tu8 ilim_en;\t \n\tu8 treg;\t \n\tu8 rbatcomp;\t \n\tu8 vclamp;\t \n};\n\nstruct bq25890_state {\n\tu8 online;\n\tu8 hiz;\n\tu8 chrg_status;\n\tu8 chrg_fault;\n\tu8 vsys_status;\n\tu8 boost_fault;\n\tu8 bat_fault;\n\tu8 ntc_fault;\n};\n\nstruct bq25890_device {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct power_supply *charger;\n\tstruct power_supply *secondary_chrg;\n\tstruct power_supply_desc desc;\n\tchar name[28];  \n\tint id;\n\n\tstruct usb_phy *usb_phy;\n\tstruct notifier_block usb_nb;\n\tstruct work_struct usb_work;\n\tstruct delayed_work pump_express_work;\n\tunsigned long usb_event;\n\n\tstruct regmap *rmap;\n\tstruct regmap_field *rmap_fields[F_MAX_FIELDS];\n\n\tbool skip_reset;\n\tbool read_back_init_data;\n\tbool force_hiz;\n\tu32 pump_express_vbus_max;\n\tu32 iinlim_percentage;\n\tenum bq25890_chip_version chip_version;\n\tstruct bq25890_init_data init_data;\n\tstruct bq25890_state state;\n\n\tstruct mutex lock;  \n};\n\nstatic DEFINE_IDR(bq25890_id);\nstatic DEFINE_MUTEX(bq25890_id_mutex);\n\nstatic const struct regmap_range bq25890_readonly_reg_ranges[] = {\n\tregmap_reg_range(0x0b, 0x0c),\n\tregmap_reg_range(0x0e, 0x13),\n};\n\nstatic const struct regmap_access_table bq25890_writeable_regs = {\n\t.no_ranges = bq25890_readonly_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(bq25890_readonly_reg_ranges),\n};\n\nstatic const struct regmap_range bq25890_volatile_reg_ranges[] = {\n\tregmap_reg_range(0x00, 0x00),\n\tregmap_reg_range(0x02, 0x02),\n\tregmap_reg_range(0x09, 0x09),\n\tregmap_reg_range(0x0b, 0x14),\n};\n\nstatic const struct regmap_access_table bq25890_volatile_regs = {\n\t.yes_ranges = bq25890_volatile_reg_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(bq25890_volatile_reg_ranges),\n};\n\nstatic const struct regmap_config bq25890_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0x14,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.wr_table = &bq25890_writeable_regs,\n\t.volatile_table = &bq25890_volatile_regs,\n};\n\nstatic const struct reg_field bq25890_reg_fields[] = {\n\t \n\t[F_EN_HIZ]\t\t= REG_FIELD(0x00, 7, 7),\n\t[F_EN_ILIM]\t\t= REG_FIELD(0x00, 6, 6),\n\t[F_IINLIM]\t\t= REG_FIELD(0x00, 0, 5),\n\t \n\t[F_BHOT]\t\t= REG_FIELD(0x01, 6, 7),\n\t[F_BCOLD]\t\t= REG_FIELD(0x01, 5, 5),\n\t[F_VINDPM_OFS]\t\t= REG_FIELD(0x01, 0, 4),\n\t \n\t[F_CONV_START]\t\t= REG_FIELD(0x02, 7, 7),\n\t[F_CONV_RATE]\t\t= REG_FIELD(0x02, 6, 6),\n\t[F_BOOSTF]\t\t= REG_FIELD(0x02, 5, 5),\n\t[F_ICO_EN]\t\t= REG_FIELD(0x02, 4, 4),\n\t[F_HVDCP_EN]\t\t= REG_FIELD(0x02, 3, 3),  \n\t[F_MAXC_EN]\t\t= REG_FIELD(0x02, 2, 2),  \n\t[F_FORCE_DPM]\t\t= REG_FIELD(0x02, 1, 1),\n\t[F_AUTO_DPDM_EN]\t= REG_FIELD(0x02, 0, 0),\n\t \n\t[F_BAT_LOAD_EN]\t\t= REG_FIELD(0x03, 7, 7),\n\t[F_WD_RST]\t\t= REG_FIELD(0x03, 6, 6),\n\t[F_OTG_CFG]\t\t= REG_FIELD(0x03, 5, 5),\n\t[F_CHG_CFG]\t\t= REG_FIELD(0x03, 4, 4),\n\t[F_SYSVMIN]\t\t= REG_FIELD(0x03, 1, 3),\n\t[F_MIN_VBAT_SEL]\t= REG_FIELD(0x03, 0, 0), \n\t \n\t[F_PUMPX_EN]\t\t= REG_FIELD(0x04, 7, 7),\n\t[F_ICHG]\t\t= REG_FIELD(0x04, 0, 6),\n\t \n\t[F_IPRECHG]\t\t= REG_FIELD(0x05, 4, 7),\n\t[F_ITERM]\t\t= REG_FIELD(0x05, 0, 3),\n\t \n\t[F_VREG]\t\t= REG_FIELD(0x06, 2, 7),\n\t[F_BATLOWV]\t\t= REG_FIELD(0x06, 1, 1),\n\t[F_VRECHG]\t\t= REG_FIELD(0x06, 0, 0),\n\t \n\t[F_TERM_EN]\t\t= REG_FIELD(0x07, 7, 7),\n\t[F_STAT_DIS]\t\t= REG_FIELD(0x07, 6, 6),\n\t[F_WD]\t\t\t= REG_FIELD(0x07, 4, 5),\n\t[F_TMR_EN]\t\t= REG_FIELD(0x07, 3, 3),\n\t[F_CHG_TMR]\t\t= REG_FIELD(0x07, 1, 2),\n\t[F_JEITA_ISET]\t\t= REG_FIELD(0x07, 0, 0), \n\t \n\t[F_BATCMP]\t\t= REG_FIELD(0x08, 5, 7),\n\t[F_VCLAMP]\t\t= REG_FIELD(0x08, 2, 4),\n\t[F_TREG]\t\t= REG_FIELD(0x08, 0, 1),\n\t \n\t[F_FORCE_ICO]\t\t= REG_FIELD(0x09, 7, 7),\n\t[F_TMR2X_EN]\t\t= REG_FIELD(0x09, 6, 6),\n\t[F_BATFET_DIS]\t\t= REG_FIELD(0x09, 5, 5),\n\t[F_JEITA_VSET]\t\t= REG_FIELD(0x09, 4, 4), \n\t[F_BATFET_DLY]\t\t= REG_FIELD(0x09, 3, 3),\n\t[F_BATFET_RST_EN]\t= REG_FIELD(0x09, 2, 2),\n\t[F_PUMPX_UP]\t\t= REG_FIELD(0x09, 1, 1),\n\t[F_PUMPX_DN]\t\t= REG_FIELD(0x09, 0, 0),\n\t \n\t[F_BOOSTV]\t\t= REG_FIELD(0x0A, 4, 7),\n\t[F_BOOSTI]\t\t= REG_FIELD(0x0A, 0, 2), \n\t[F_PFM_OTG_DIS]\t\t= REG_FIELD(0x0A, 3, 3), \n\t \n\t[F_VBUS_STAT]\t\t= REG_FIELD(0x0B, 5, 7),\n\t[F_CHG_STAT]\t\t= REG_FIELD(0x0B, 3, 4),\n\t[F_PG_STAT]\t\t= REG_FIELD(0x0B, 2, 2),\n\t[F_SDP_STAT]\t\t= REG_FIELD(0x0B, 1, 1), \n\t[F_VSYS_STAT]\t\t= REG_FIELD(0x0B, 0, 0),\n\t \n\t[F_WD_FAULT]\t\t= REG_FIELD(0x0C, 7, 7),\n\t[F_BOOST_FAULT]\t\t= REG_FIELD(0x0C, 6, 6),\n\t[F_CHG_FAULT]\t\t= REG_FIELD(0x0C, 4, 5),\n\t[F_BAT_FAULT]\t\t= REG_FIELD(0x0C, 3, 3),\n\t[F_NTC_FAULT]\t\t= REG_FIELD(0x0C, 0, 2),\n\t \n\t[F_FORCE_VINDPM]\t= REG_FIELD(0x0D, 7, 7),\n\t[F_VINDPM]\t\t= REG_FIELD(0x0D, 0, 6),\n\t \n\t[F_THERM_STAT]\t\t= REG_FIELD(0x0E, 7, 7),\n\t[F_BATV]\t\t= REG_FIELD(0x0E, 0, 6),\n\t \n\t[F_SYSV]\t\t= REG_FIELD(0x0F, 0, 6),\n\t \n\t[F_TSPCT]\t\t= REG_FIELD(0x10, 0, 6),\n\t \n\t[F_VBUS_GD]\t\t= REG_FIELD(0x11, 7, 7),\n\t[F_VBUSV]\t\t= REG_FIELD(0x11, 0, 6),\n\t \n\t[F_ICHGR]\t\t= REG_FIELD(0x12, 0, 6),\n\t \n\t[F_VDPM_STAT]\t\t= REG_FIELD(0x13, 7, 7),\n\t[F_IDPM_STAT]\t\t= REG_FIELD(0x13, 6, 6),\n\t[F_IDPM_LIM]\t\t= REG_FIELD(0x13, 0, 5),\n\t \n\t[F_REG_RST]\t\t= REG_FIELD(0x14, 7, 7),\n\t[F_ICO_OPTIMIZED]\t= REG_FIELD(0x14, 6, 6),\n\t[F_PN]\t\t\t= REG_FIELD(0x14, 3, 5),\n\t[F_TS_PROFILE]\t\t= REG_FIELD(0x14, 2, 2),\n\t[F_DEV_REV]\t\t= REG_FIELD(0x14, 0, 1)\n};\n\n \nenum bq25890_table_ids {\n\t \n\tTBL_ICHG,\n\tTBL_ITERM,\n\tTBL_IINLIM,\n\tTBL_VREG,\n\tTBL_BOOSTV,\n\tTBL_SYSVMIN,\n\tTBL_VBUSV,\n\tTBL_VBATCOMP,\n\tTBL_RBATCOMP,\n\n\t \n\tTBL_TREG,\n\tTBL_BOOSTI,\n\tTBL_TSPCT,\n};\n\n \nstatic const u32 bq25890_treg_tbl[] = { 60, 80, 100, 120 };\n\n#define BQ25890_TREG_TBL_SIZE\t\tARRAY_SIZE(bq25890_treg_tbl)\n\n \nstatic const u32 bq25890_boosti_tbl[] = {\n\t500000, 700000, 1100000, 1300000, 1600000, 1800000, 2100000, 2400000\n};\n\n#define BQ25890_BOOSTI_TBL_SIZE\t\tARRAY_SIZE(bq25890_boosti_tbl)\n\n \nstatic const u32 bq25890_tspct_tbl[] = {\n\t850, 840, 830, 820, 810, 800, 790, 780,\n\t770, 760, 750, 740, 730, 720, 710, 700,\n\t690, 685, 680, 675, 670, 660, 650, 645,\n\t640, 630, 620, 615, 610, 600, 590, 585,\n\t580, 570, 565, 560, 550, 540, 535, 530,\n\t520, 515, 510, 500, 495, 490, 480, 475,\n\t470, 460, 455, 450, 440, 435, 430, 425,\n\t420, 410, 405, 400, 390, 385, 380, 370,\n\t365, 360, 355, 350, 340, 335, 330, 320,\n\t310, 305, 300, 290, 285, 280, 275, 270,\n\t260, 250, 245, 240, 230, 225, 220, 210,\n\t205, 200, 190, 180, 175, 170, 160, 150,\n\t145, 140, 130, 120, 115, 110, 100, 90,\n\t80, 70, 60, 50, 40, 30, 20, 10,\n\t0, -10, -20, -30, -40, -60, -70, -80,\n\t-90, -10, -120, -140, -150, -170, -190, -210,\n};\n\n#define BQ25890_TSPCT_TBL_SIZE\t\tARRAY_SIZE(bq25890_tspct_tbl)\n\nstruct bq25890_range {\n\tu32 min;\n\tu32 max;\n\tu32 step;\n};\n\nstruct bq25890_lookup {\n\tconst u32 *tbl;\n\tu32 size;\n};\n\nstatic const union {\n\tstruct bq25890_range  rt;\n\tstruct bq25890_lookup lt;\n} bq25890_tables[] = {\n\t \n\t \n\t[TBL_ICHG] =\t { .rt = {0,        5056000, 64000} },\t  \n\t[TBL_ITERM] =\t { .rt = {64000,    1024000, 64000} },\t  \n\t[TBL_IINLIM] =   { .rt = {100000,   3250000, 50000} },\t  \n\t[TBL_VREG] =\t { .rt = {3840000,  4608000, 16000} },\t  \n\t[TBL_BOOSTV] =\t { .rt = {4550000,  5510000, 64000} },\t  \n\t[TBL_SYSVMIN] =  { .rt = {3000000,  3700000, 100000} },\t  \n\t[TBL_VBUSV] =\t { .rt = {2600000, 15300000, 100000} },\t  \n\t[TBL_VBATCOMP] = { .rt = {0,         224000, 32000} },\t  \n\t[TBL_RBATCOMP] = { .rt = {0,         140000, 20000} },\t  \n\n\t \n\t[TBL_TREG] =\t{ .lt = {bq25890_treg_tbl, BQ25890_TREG_TBL_SIZE} },\n\t[TBL_BOOSTI] =\t{ .lt = {bq25890_boosti_tbl, BQ25890_BOOSTI_TBL_SIZE} },\n\t[TBL_TSPCT] =\t{ .lt = {bq25890_tspct_tbl, BQ25890_TSPCT_TBL_SIZE} }\n};\n\nstatic int bq25890_field_read(struct bq25890_device *bq,\n\t\t\t      enum bq25890_fields field_id)\n{\n\tint ret;\n\tint val;\n\n\tret = regmap_field_read(bq->rmap_fields[field_id], &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int bq25890_field_write(struct bq25890_device *bq,\n\t\t\t       enum bq25890_fields field_id, u8 val)\n{\n\treturn regmap_field_write(bq->rmap_fields[field_id], val);\n}\n\nstatic u8 bq25890_find_idx(u32 value, enum bq25890_table_ids id)\n{\n\tu8 idx;\n\n\tif (id >= TBL_TREG) {\n\t\tconst u32 *tbl = bq25890_tables[id].lt.tbl;\n\t\tu32 tbl_size = bq25890_tables[id].lt.size;\n\n\t\tfor (idx = 1; idx < tbl_size && tbl[idx] <= value; idx++)\n\t\t\t;\n\t} else {\n\t\tconst struct bq25890_range *rtbl = &bq25890_tables[id].rt;\n\t\tu8 rtbl_size;\n\n\t\trtbl_size = (rtbl->max - rtbl->min) / rtbl->step + 1;\n\n\t\tfor (idx = 1;\n\t\t     idx < rtbl_size && (idx * rtbl->step + rtbl->min <= value);\n\t\t     idx++)\n\t\t\t;\n\t}\n\n\treturn idx - 1;\n}\n\nstatic u32 bq25890_find_val(u8 idx, enum bq25890_table_ids id)\n{\n\tconst struct bq25890_range *rtbl;\n\n\t \n\tif (id >= TBL_TREG)\n\t\treturn bq25890_tables[id].lt.tbl[idx];\n\n\t \n\trtbl = &bq25890_tables[id].rt;\n\n\treturn (rtbl->min + idx * rtbl->step);\n}\n\nenum bq25890_status {\n\tSTATUS_NOT_CHARGING,\n\tSTATUS_PRE_CHARGING,\n\tSTATUS_FAST_CHARGING,\n\tSTATUS_TERMINATION_DONE,\n};\n\nenum bq25890_chrg_fault {\n\tCHRG_FAULT_NORMAL,\n\tCHRG_FAULT_INPUT,\n\tCHRG_FAULT_THERMAL_SHUTDOWN,\n\tCHRG_FAULT_TIMER_EXPIRED,\n};\n\nenum bq25890_ntc_fault {\n\tNTC_FAULT_NORMAL = 0,\n\tNTC_FAULT_WARM = 2,\n\tNTC_FAULT_COOL = 3,\n\tNTC_FAULT_COLD = 5,\n\tNTC_FAULT_HOT = 6,\n};\n\nstatic bool bq25890_is_adc_property(enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic irqreturn_t __bq25890_handle_irq(struct bq25890_device *bq);\n\nstatic int bq25890_get_vbus_voltage(struct bq25890_device *bq)\n{\n\tint ret;\n\n\tret = bq25890_field_read(bq, F_VBUSV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bq25890_find_val(ret, TBL_VBUSV);\n}\n\nstatic void bq25890_update_state(struct bq25890_device *bq,\n\t\t\t\t enum power_supply_property psp,\n\t\t\t\t struct bq25890_state *state)\n{\n\tbool do_adc_conv;\n\tint ret;\n\n\tmutex_lock(&bq->lock);\n\t \n\t__bq25890_handle_irq(bq);\n\t*state = bq->state;\n\tdo_adc_conv = (!state->online || state->hiz) && bq25890_is_adc_property(psp);\n\tif (do_adc_conv)\n\t\tbq25890_field_write(bq, F_CONV_START, 1);\n\tmutex_unlock(&bq->lock);\n\n\tif (do_adc_conv)\n\t\tregmap_field_read_poll_timeout(bq->rmap_fields[F_CONV_START],\n\t\t\tret, !ret, 25000, 1000000);\n}\n\nstatic int bq25890_power_supply_get_property(struct power_supply *psy,\n\t\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct bq25890_device *bq = power_supply_get_drvdata(psy);\n\tstruct bq25890_state state;\n\tint ret;\n\n\tbq25890_update_state(bq, psp, &state);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (!state.online || state.hiz)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (state.chrg_status == STATUS_NOT_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse if (state.chrg_status == STATUS_PRE_CHARGING ||\n\t\t\t state.chrg_status == STATUS_FAST_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (state.chrg_status == STATUS_TERMINATION_DONE)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tif (!state.online || state.hiz ||\n\t\t    state.chrg_status == STATUS_NOT_CHARGING ||\n\t\t    state.chrg_status == STATUS_TERMINATION_DONE)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\telse if (state.chrg_status == STATUS_PRE_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\telse if (state.chrg_status == STATUS_FAST_CHARGING)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\telse  \n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BQ25890_MANUFACTURER;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bq25890_chip_name[bq->chip_version];\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = state.online && !state.hiz;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (!state.chrg_fault && !state.bat_fault && !state.boost_fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\telse if (state.bat_fault)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\telse if (state.chrg_fault == CHRG_FAULT_TIMER_EXPIRED)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\t\telse if (state.chrg_fault == CHRG_FAULT_THERMAL_SHUTDOWN)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tval->intval = bq25890_find_val(bq->init_data.iprechg, TBL_ITERM);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tval->intval = bq25890_find_val(bq->init_data.iterm, TBL_ITERM);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq25890_field_read(bq, F_IINLIM);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = bq25890_find_val(ret, TBL_IINLIM);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\t \n\t\t \n\t\tret = bq25890_field_read(bq, F_ICHGR);  \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval = ret * -50000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\t \n\t\t \n\t\tret = bq25890_field_read(bq, F_ICHG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = bq25890_find_val(ret, TBL_ICHG);\n\n\t\t \n\t\tif (bq->state.ntc_fault == NTC_FAULT_COOL) {\n\t\t\tret = bq25890_field_read(bq, F_JEITA_ISET);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (ret)\n\t\t\t\tval->intval /= 5;\n\t\t\telse\n\t\t\t\tval->intval /= 2;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\t \n\t\t \n\t\tval->intval = bq25890_find_val(bq->init_data.ichg, TBL_ICHG);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\t \n\t\t \n\t\tret = bq25890_field_read(bq, F_BATV);  \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval = 2304000 + ret * 20000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\t \n\t\t \n\t\tret = bq25890_field_read(bq, F_VREG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = bq25890_find_val(ret, TBL_VREG);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\t \n\t\t \n\t\tval->intval = bq25890_find_val(bq->init_data.vreg, TBL_VREG);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = bq25890_field_read(bq, F_TSPCT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tval->intval = bq25890_find_val(ret, TBL_TSPCT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq25890_power_supply_set_property(struct power_supply *psy,\n\t\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t\t     const union power_supply_propval *val)\n{\n\tstruct bq25890_device *bq = power_supply_get_drvdata(psy);\n\tstruct bq25890_state state;\n\tint maxval, ret;\n\tu8 lval;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tmaxval = bq25890_find_val(bq->init_data.ichg, TBL_ICHG);\n\t\tlval = bq25890_find_idx(min(val->intval, maxval), TBL_ICHG);\n\t\treturn bq25890_field_write(bq, F_ICHG, lval);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tmaxval = bq25890_find_val(bq->init_data.vreg, TBL_VREG);\n\t\tlval = bq25890_find_idx(min(val->intval, maxval), TBL_VREG);\n\t\treturn bq25890_field_write(bq, F_VREG, lval);\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tlval = bq25890_find_idx(val->intval, TBL_IINLIM);\n\t\treturn bq25890_field_write(bq, F_IINLIM, lval);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq25890_field_write(bq, F_EN_HIZ, !val->intval);\n\t\tif (!ret)\n\t\t\tbq->force_hiz = !val->intval;\n\t\tbq25890_update_state(bq, psp, &state);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int bq25890_power_supply_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\t      enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int bq25890_charger_get_scaled_iinlim_regval(struct bq25890_device *bq,\n\t\t\t\t\t\t    int iinlim_ua)\n{\n\tiinlim_ua = iinlim_ua * bq->iinlim_percentage / 100;\n\treturn bq25890_find_idx(iinlim_ua, TBL_IINLIM);\n}\n\n \nstatic void bq25890_charger_external_power_changed(struct power_supply *psy)\n{\n\tstruct bq25890_device *bq = power_supply_get_drvdata(psy);\n\tunion power_supply_propval val;\n\tint input_current_limit, ret;\n\n\tif (bq->chip_version != BQ25892)\n\t\treturn;\n\n\tret = power_supply_get_property_from_supplier(psy,\n\t\t\t\t\t\t      POWER_SUPPLY_PROP_USB_TYPE,\n\t\t\t\t\t\t      &val);\n\tif (ret)\n\t\treturn;\n\n\tswitch (val.intval) {\n\tcase POWER_SUPPLY_USB_TYPE_DCP:\n\t\tinput_current_limit = bq25890_charger_get_scaled_iinlim_regval(bq, 2000000);\n\t\tif (bq->pump_express_vbus_max) {\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t   &bq->pump_express_work,\n\t\t\t\t\t   PUMP_EXPRESS_START_DELAY);\n\t\t}\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_CDP:\n\tcase POWER_SUPPLY_USB_TYPE_ACA:\n\t\tinput_current_limit = bq25890_charger_get_scaled_iinlim_regval(bq, 1500000);\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_SDP:\n\tdefault:\n\t\tinput_current_limit = bq25890_charger_get_scaled_iinlim_regval(bq, 500000);\n\t}\n\n\tbq25890_field_write(bq, F_IINLIM, input_current_limit);\n\tpower_supply_changed(psy);\n}\n\nstatic int bq25890_get_chip_state(struct bq25890_device *bq,\n\t\t\t\t  struct bq25890_state *state)\n{\n\tint i, ret;\n\n\tstruct {\n\t\tenum bq25890_fields id;\n\t\tu8 *data;\n\t} state_fields[] = {\n\t\t{F_CHG_STAT,\t&state->chrg_status},\n\t\t{F_PG_STAT,\t&state->online},\n\t\t{F_EN_HIZ,\t&state->hiz},\n\t\t{F_VSYS_STAT,\t&state->vsys_status},\n\t\t{F_BOOST_FAULT, &state->boost_fault},\n\t\t{F_BAT_FAULT,\t&state->bat_fault},\n\t\t{F_CHG_FAULT,\t&state->chrg_fault},\n\t\t{F_NTC_FAULT,\t&state->ntc_fault}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(state_fields); i++) {\n\t\tret = bq25890_field_read(bq, state_fields[i].id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*state_fields[i].data = ret;\n\t}\n\n\tdev_dbg(bq->dev, \"S:CHG/PG/HIZ/VSYS=%d/%d/%d/%d, F:CHG/BOOST/BAT/NTC=%d/%d/%d/%d\\n\",\n\t\tstate->chrg_status, state->online,\n\t\tstate->hiz, state->vsys_status,\n\t\tstate->chrg_fault, state->boost_fault,\n\t\tstate->bat_fault, state->ntc_fault);\n\n\treturn 0;\n}\n\nstatic irqreturn_t __bq25890_handle_irq(struct bq25890_device *bq)\n{\n\tbool adc_conv_rate, new_adc_conv_rate;\n\tstruct bq25890_state new_state;\n\tint ret;\n\n\tret = bq25890_get_chip_state(bq, &new_state);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tif (!memcmp(&bq->state, &new_state, sizeof(new_state)))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (new_state.online && !bq->state.online && bq->force_hiz) {\n\t\tret = bq25890_field_write(bq, F_EN_HIZ, bq->force_hiz);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tnew_state.hiz = 1;\n\t}\n\n\t \n\tadc_conv_rate = bq->state.online && !bq->state.hiz;\n\tnew_adc_conv_rate = new_state.online && !new_state.hiz;\n\n\tif (new_adc_conv_rate != adc_conv_rate) {\n\t\tret = bq25890_field_write(bq, F_CONV_RATE, new_adc_conv_rate);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tbq->state = new_state;\n\tpower_supply_changed(bq->charger);\n\n\treturn IRQ_HANDLED;\nerror:\n\tdev_err(bq->dev, \"Error communicating with the chip: %pe\\n\",\n\t\tERR_PTR(ret));\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bq25890_irq_handler_thread(int irq, void *private)\n{\n\tstruct bq25890_device *bq = private;\n\tirqreturn_t ret;\n\n\tmutex_lock(&bq->lock);\n\tret = __bq25890_handle_irq(bq);\n\tmutex_unlock(&bq->lock);\n\n\treturn ret;\n}\n\nstatic int bq25890_chip_reset(struct bq25890_device *bq)\n{\n\tint ret;\n\tint rst_check_counter = 10;\n\n\tret = bq25890_field_write(bq, F_REG_RST, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdo {\n\t\tret = bq25890_field_read(bq, F_REG_RST);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tusleep_range(5, 10);\n\t} while (ret == 1 && --rst_check_counter);\n\n\tif (!rst_check_counter)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int bq25890_rw_init_data(struct bq25890_device *bq)\n{\n\tbool write = !bq->read_back_init_data;\n\tint ret;\n\tint i;\n\n\tconst struct {\n\t\tenum bq25890_fields id;\n\t\tu8 *value;\n\t} init_data[] = {\n\t\t{F_ICHG,\t &bq->init_data.ichg},\n\t\t{F_VREG,\t &bq->init_data.vreg},\n\t\t{F_ITERM,\t &bq->init_data.iterm},\n\t\t{F_IPRECHG,\t &bq->init_data.iprechg},\n\t\t{F_SYSVMIN,\t &bq->init_data.sysvmin},\n\t\t{F_BOOSTV,\t &bq->init_data.boostv},\n\t\t{F_BOOSTI,\t &bq->init_data.boosti},\n\t\t{F_BOOSTF,\t &bq->init_data.boostf},\n\t\t{F_EN_ILIM,\t &bq->init_data.ilim_en},\n\t\t{F_TREG,\t &bq->init_data.treg},\n\t\t{F_BATCMP,\t &bq->init_data.rbatcomp},\n\t\t{F_VCLAMP,\t &bq->init_data.vclamp},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\n\t\tif (write) {\n\t\t\tret = bq25890_field_write(bq, init_data[i].id,\n\t\t\t\t\t\t  *init_data[i].value);\n\t\t} else {\n\t\t\tret = bq25890_field_read(bq, init_data[i].id);\n\t\t\tif (ret >= 0)\n\t\t\t\t*init_data[i].value = ret;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(bq->dev, \"Accessing init data failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bq25890_hw_init(struct bq25890_device *bq)\n{\n\tint ret;\n\n\tif (!bq->skip_reset) {\n\t\tret = bq25890_chip_reset(bq);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(bq->dev, \"Reset failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tret = bq25890_field_write(bq, F_CHG_CFG, 1);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(bq->dev, \"Enabling charging failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = bq25890_field_write(bq, F_WD, 0);\n\tif (ret < 0) {\n\t\tdev_dbg(bq->dev, \"Disabling watchdog failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = bq25890_rw_init_data(bq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bq25890_get_chip_state(bq, &bq->state);\n\tif (ret < 0) {\n\t\tdev_dbg(bq->dev, \"Get state failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = bq25890_field_write(bq, F_CONV_RATE, bq->state.online && !bq->state.hiz);\n\tif (ret < 0) {\n\t\tdev_dbg(bq->dev, \"Config ADC failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_property bq25890_power_supply_props[] = {\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic char *bq25890_charger_supplied_to[] = {\n\t\"main-battery\",\n};\n\nstatic const struct power_supply_desc bq25890_power_supply_desc = {\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = bq25890_power_supply_props,\n\t.num_properties = ARRAY_SIZE(bq25890_power_supply_props),\n\t.get_property = bq25890_power_supply_get_property,\n\t.set_property = bq25890_power_supply_set_property,\n\t.property_is_writeable = bq25890_power_supply_property_is_writeable,\n\t.external_power_changed\t= bq25890_charger_external_power_changed,\n};\n\nstatic int bq25890_power_supply_init(struct bq25890_device *bq)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = bq, };\n\n\t \n\tmutex_lock(&bq25890_id_mutex);\n\tbq->id = idr_alloc(&bq25890_id, bq, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&bq25890_id_mutex);\n\tif (bq->id < 0)\n\t\treturn bq->id;\n\n\tsnprintf(bq->name, sizeof(bq->name), \"bq25890-charger-%d\", bq->id);\n\tbq->desc = bq25890_power_supply_desc;\n\tbq->desc.name = bq->name;\n\n\tpsy_cfg.supplied_to = bq25890_charger_supplied_to;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(bq25890_charger_supplied_to);\n\n\tbq->charger = devm_power_supply_register(bq->dev, &bq->desc, &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(bq->charger);\n}\n\nstatic int bq25890_set_otg_cfg(struct bq25890_device *bq, u8 val)\n{\n\tint ret;\n\n\tret = bq25890_field_write(bq, F_OTG_CFG, val);\n\tif (ret < 0)\n\t\tdev_err(bq->dev, \"Error switching to boost/charger mode: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void bq25890_pump_express_work(struct work_struct *data)\n{\n\tstruct bq25890_device *bq =\n\t\tcontainer_of(data, struct bq25890_device, pump_express_work.work);\n\tunion power_supply_propval value;\n\tint voltage, i, ret;\n\n\tdev_dbg(bq->dev, \"Start to request input voltage increasing\\n\");\n\n\t \n\tif (bq->secondary_chrg) {\n\t\tvalue.intval = 0;\n\t\tpower_supply_set_property(bq->secondary_chrg, POWER_SUPPLY_PROP_ONLINE, &value);\n\t}\n\n\t \n\tret = bq25890_field_write(bq, F_PUMPX_EN, 1);\n\tif (ret < 0)\n\t\tgoto error_print;\n\n\tfor (i = 0; i < PUMP_EXPRESS_MAX_TRIES; i++) {\n\t\tvoltage = bq25890_get_vbus_voltage(bq);\n\t\tif (voltage < 0)\n\t\t\tgoto error_print;\n\t\tdev_dbg(bq->dev, \"input voltage = %d uV\\n\", voltage);\n\n\t\tif ((voltage + PUMP_EXPRESS_VBUS_MARGIN_uV) >\n\t\t\t\t\tbq->pump_express_vbus_max)\n\t\t\tbreak;\n\n\t\tret = bq25890_field_write(bq, F_PUMPX_UP, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error_print;\n\n\t\t \n\t\tret = regmap_field_read_poll_timeout(bq->rmap_fields[F_PUMPX_UP],\n\t\t\t\t\t\t     ret, !ret, 100000, 3000000);\n\t\tif (ret < 0)\n\t\t\tgoto error_print;\n\n\t\t \n\t\tmsleep(1000);\n\t}\n\n\tbq25890_field_write(bq, F_PUMPX_EN, 0);\n\n\tif (bq->secondary_chrg) {\n\t\tvalue.intval = 1;\n\t\tpower_supply_set_property(bq->secondary_chrg, POWER_SUPPLY_PROP_ONLINE, &value);\n\t}\n\n\tdev_info(bq->dev, \"Hi-voltage charging requested, input voltage is %d mV\\n\",\n\t\t voltage);\n\n\tpower_supply_changed(bq->charger);\n\n\treturn;\nerror_print:\n\tbq25890_field_write(bq, F_PUMPX_EN, 0);\n\tdev_err(bq->dev, \"Failed to request hi-voltage charging\\n\");\n}\n\nstatic void bq25890_usb_work(struct work_struct *data)\n{\n\tint ret;\n\tstruct bq25890_device *bq =\n\t\t\tcontainer_of(data, struct bq25890_device, usb_work);\n\n\tswitch (bq->usb_event) {\n\tcase USB_EVENT_ID:\n\t\t \n\t\tbq25890_set_otg_cfg(bq, 1);\n\t\tbreak;\n\n\tcase USB_EVENT_NONE:\n\t\t \n\t\tret = bq25890_set_otg_cfg(bq, 0);\n\t\tif (ret == 0)\n\t\t\tpower_supply_changed(bq->charger);\n\t\tbreak;\n\t}\n}\n\nstatic int bq25890_usb_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\tvoid *priv)\n{\n\tstruct bq25890_device *bq =\n\t\t\tcontainer_of(nb, struct bq25890_device, usb_nb);\n\n\tbq->usb_event = val;\n\tqueue_work(system_power_efficient_wq, &bq->usb_work);\n\n\treturn NOTIFY_OK;\n}\n\n#ifdef CONFIG_REGULATOR\nstatic int bq25890_vbus_enable(struct regulator_dev *rdev)\n{\n\tstruct bq25890_device *bq = rdev_get_drvdata(rdev);\n\tunion power_supply_propval val = {\n\t\t.intval = 0,\n\t};\n\n\t \n\tif (bq->secondary_chrg)\n\t\tpower_supply_set_property(bq->secondary_chrg, POWER_SUPPLY_PROP_ONLINE, &val);\n\n\treturn bq25890_set_otg_cfg(bq, 1);\n}\n\nstatic int bq25890_vbus_disable(struct regulator_dev *rdev)\n{\n\tstruct bq25890_device *bq = rdev_get_drvdata(rdev);\n\tunion power_supply_propval val = {\n\t\t.intval = 1,\n\t};\n\tint ret;\n\n\tret = bq25890_set_otg_cfg(bq, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bq->secondary_chrg)\n\t\tpower_supply_set_property(bq->secondary_chrg, POWER_SUPPLY_PROP_ONLINE, &val);\n\n\treturn 0;\n}\n\nstatic int bq25890_vbus_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct bq25890_device *bq = rdev_get_drvdata(rdev);\n\n\treturn bq25890_field_read(bq, F_OTG_CFG);\n}\n\nstatic int bq25890_vbus_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct bq25890_device *bq = rdev_get_drvdata(rdev);\n\n\treturn bq25890_get_vbus_voltage(bq);\n}\n\nstatic int bq25890_vsys_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct bq25890_device *bq = rdev_get_drvdata(rdev);\n\tint ret;\n\n\t \n\tret = bq25890_field_read(bq, F_SYSV);  \n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn 2304000 + ret * 20000;\n}\n\nstatic const struct regulator_ops bq25890_vbus_ops = {\n\t.enable = bq25890_vbus_enable,\n\t.disable = bq25890_vbus_disable,\n\t.is_enabled = bq25890_vbus_is_enabled,\n\t.get_voltage = bq25890_vbus_get_voltage,\n};\n\nstatic const struct regulator_desc bq25890_vbus_desc = {\n\t.name = \"usb_otg_vbus\",\n\t.of_match = \"usb-otg-vbus\",\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &bq25890_vbus_ops,\n};\n\nstatic const struct regulator_ops bq25890_vsys_ops = {\n\t.get_voltage = bq25890_vsys_get_voltage,\n};\n\nstatic const struct regulator_desc bq25890_vsys_desc = {\n\t.name = \"vsys\",\n\t.of_match = \"vsys\",\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &bq25890_vsys_ops,\n};\n\nstatic int bq25890_register_regulator(struct bq25890_device *bq)\n{\n\tstruct bq25890_platform_data *pdata = dev_get_platdata(bq->dev);\n\tstruct regulator_config cfg = {\n\t\t.dev = bq->dev,\n\t\t.driver_data = bq,\n\t};\n\tstruct regulator_dev *reg;\n\n\tif (pdata)\n\t\tcfg.init_data = pdata->regulator_init_data;\n\n\treg = devm_regulator_register(bq->dev, &bq25890_vbus_desc, &cfg);\n\tif (IS_ERR(reg)) {\n\t\treturn dev_err_probe(bq->dev, PTR_ERR(reg),\n\t\t\t\t     \"registering vbus regulator\");\n\t}\n\n\t \n\tcfg.init_data = NULL;\n\treg = devm_regulator_register(bq->dev, &bq25890_vsys_desc, &cfg);\n\tif (IS_ERR(reg)) {\n\t\treturn dev_err_probe(bq->dev, PTR_ERR(reg),\n\t\t\t\t     \"registering vsys regulator\");\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int\nbq25890_register_regulator(struct bq25890_device *bq)\n{\n\treturn 0;\n}\n#endif\n\nstatic int bq25890_get_chip_version(struct bq25890_device *bq)\n{\n\tint id, rev;\n\n\tid = bq25890_field_read(bq, F_PN);\n\tif (id < 0) {\n\t\tdev_err(bq->dev, \"Cannot read chip ID: %d\\n\", id);\n\t\treturn id;\n\t}\n\n\trev = bq25890_field_read(bq, F_DEV_REV);\n\tif (rev < 0) {\n\t\tdev_err(bq->dev, \"Cannot read chip revision: %d\\n\", rev);\n\t\treturn rev;\n\t}\n\n\tswitch (id) {\n\tcase BQ25890_ID:\n\t\tbq->chip_version = BQ25890;\n\t\tbreak;\n\n\t \n\tcase BQ25896_ID:\n\t\tswitch (rev) {\n\t\tcase 2:\n\t\t\tbq->chip_version = BQ25896;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbq->chip_version = BQ25892;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(bq->dev,\n\t\t\t\t\"Unknown device revision %d, assume BQ25892\\n\",\n\t\t\t\trev);\n\t\t\tbq->chip_version = BQ25892;\n\t\t}\n\t\tbreak;\n\n\tcase BQ25895_ID:\n\t\tbq->chip_version = BQ25895;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(bq->dev, \"Unknown chip ID %d\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq25890_irq_probe(struct bq25890_device *bq)\n{\n\tstruct gpio_desc *irq;\n\n\tirq = devm_gpiod_get(bq->dev, BQ25890_IRQ_PIN, GPIOD_IN);\n\tif (IS_ERR(irq))\n\t\treturn dev_err_probe(bq->dev, PTR_ERR(irq),\n\t\t\t\t     \"Could not probe irq pin.\\n\");\n\n\treturn gpiod_to_irq(irq);\n}\n\nstatic int bq25890_fw_read_u32_props(struct bq25890_device *bq)\n{\n\tint ret;\n\tu32 property;\n\tint i;\n\tstruct bq25890_init_data *init = &bq->init_data;\n\tstruct {\n\t\tchar *name;\n\t\tbool optional;\n\t\tenum bq25890_table_ids tbl_id;\n\t\tu8 *conv_data;  \n\t} props[] = {\n\t\t \n\t\t{\"ti,charge-current\", false, TBL_ICHG, &init->ichg},\n\t\t{\"ti,battery-regulation-voltage\", false, TBL_VREG, &init->vreg},\n\t\t{\"ti,termination-current\", false, TBL_ITERM, &init->iterm},\n\t\t{\"ti,precharge-current\", false, TBL_ITERM, &init->iprechg},\n\t\t{\"ti,minimum-sys-voltage\", false, TBL_SYSVMIN, &init->sysvmin},\n\t\t{\"ti,boost-voltage\", false, TBL_BOOSTV, &init->boostv},\n\t\t{\"ti,boost-max-current\", false, TBL_BOOSTI, &init->boosti},\n\n\t\t \n\t\t{\"ti,thermal-regulation-threshold\", true, TBL_TREG, &init->treg},\n\t\t{\"ti,ibatcomp-micro-ohms\", true, TBL_RBATCOMP, &init->rbatcomp},\n\t\t{\"ti,ibatcomp-clamp-microvolt\", true, TBL_VBATCOMP, &init->vclamp},\n\t};\n\n\t \n\tinit->treg = 3;  \n\tinit->rbatcomp = init->vclamp = 0;  \n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tret = device_property_read_u32(bq->dev, props[i].name,\n\t\t\t\t\t       &property);\n\t\tif (ret < 0) {\n\t\t\tif (props[i].optional)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(bq->dev, \"Unable to read property %d %s\\n\", ret,\n\t\t\t\tprops[i].name);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\t*props[i].conv_data = bq25890_find_idx(property,\n\t\t\t\t\t\t       props[i].tbl_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int bq25890_fw_probe(struct bq25890_device *bq)\n{\n\tint ret;\n\tstruct bq25890_init_data *init = &bq->init_data;\n\tconst char *str;\n\tu32 val;\n\n\tret = device_property_read_string(bq->dev, \"linux,secondary-charger-name\", &str);\n\tif (ret == 0) {\n\t\tbq->secondary_chrg = power_supply_get_by_name(str);\n\t\tif (!bq->secondary_chrg)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tdevice_property_read_u32(bq->dev, \"linux,pump-express-vbus-max\",\n\t\t\t\t &bq->pump_express_vbus_max);\n\n\tret = device_property_read_u32(bq->dev, \"linux,iinlim-percentage\", &val);\n\tif (ret == 0) {\n\t\tif (val > 100) {\n\t\t\tdev_err(bq->dev, \"Error linux,iinlim-percentage %u > 100\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbq->iinlim_percentage = val;\n\t} else {\n\t\tbq->iinlim_percentage = 100;\n\t}\n\n\tbq->skip_reset = device_property_read_bool(bq->dev, \"linux,skip-reset\");\n\tbq->read_back_init_data = device_property_read_bool(bq->dev,\n\t\t\t\t\t\t\"linux,read-back-settings\");\n\tif (bq->read_back_init_data)\n\t\treturn 0;\n\n\tret = bq25890_fw_read_u32_props(bq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinit->ilim_en = device_property_read_bool(bq->dev, \"ti,use-ilim-pin\");\n\tinit->boostf = device_property_read_bool(bq->dev, \"ti,boost-low-freq\");\n\n\treturn 0;\n}\n\nstatic void bq25890_non_devm_cleanup(void *data)\n{\n\tstruct bq25890_device *bq = data;\n\n\tcancel_delayed_work_sync(&bq->pump_express_work);\n\n\tif (bq->id >= 0) {\n\t\tmutex_lock(&bq25890_id_mutex);\n\t\tidr_remove(&bq25890_id, bq->id);\n\t\tmutex_unlock(&bq25890_id_mutex);\n\t}\n}\n\nstatic int bq25890_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct bq25890_device *bq;\n\tint ret;\n\n\tbq = devm_kzalloc(dev, sizeof(*bq), GFP_KERNEL);\n\tif (!bq)\n\t\treturn -ENOMEM;\n\n\tbq->client = client;\n\tbq->dev = dev;\n\tbq->id = -1;\n\n\tmutex_init(&bq->lock);\n\tINIT_DELAYED_WORK(&bq->pump_express_work, bq25890_pump_express_work);\n\n\tbq->rmap = devm_regmap_init_i2c(client, &bq25890_regmap_config);\n\tif (IS_ERR(bq->rmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(bq->rmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\n\tret = devm_regmap_field_bulk_alloc(dev, bq->rmap, bq->rmap_fields,\n\t\t\t\t\t   bq25890_reg_fields, F_MAX_FIELDS);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, bq);\n\n\tret = bq25890_get_chip_version(bq);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot read chip ID or unknown chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = bq25890_fw_probe(bq);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"reading device properties\\n\");\n\n\tret = bq25890_hw_init(bq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot initialize the chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (client->irq <= 0)\n\t\tclient->irq = bq25890_irq_probe(bq);\n\n\tif (client->irq < 0) {\n\t\tdev_err(dev, \"No irq resource found.\\n\");\n\t\treturn client->irq;\n\t}\n\n\t \n\tbq->usb_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\n\n\t \n\tret = devm_add_action_or_reset(dev, bq25890_non_devm_cleanup, bq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bq25890_register_regulator(bq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bq25890_power_supply_init(bq);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"registering power supply\\n\");\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tbq25890_irq_handler_thread,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tBQ25890_IRQ_PIN, bq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR_OR_NULL(bq->usb_phy)) {\n\t\tINIT_WORK(&bq->usb_work, bq25890_usb_work);\n\t\tbq->usb_nb.notifier_call = bq25890_usb_notifier;\n\t\tusb_register_notifier(bq->usb_phy, &bq->usb_nb);\n\t}\n\n\treturn 0;\n}\n\nstatic void bq25890_remove(struct i2c_client *client)\n{\n\tstruct bq25890_device *bq = i2c_get_clientdata(client);\n\n\tif (!IS_ERR_OR_NULL(bq->usb_phy)) {\n\t\tusb_unregister_notifier(bq->usb_phy, &bq->usb_nb);\n\t\tcancel_work_sync(&bq->usb_work);\n\t}\n\n\tif (!bq->skip_reset) {\n\t\t \n\t\tbq25890_chip_reset(bq);\n\t}\n}\n\nstatic void bq25890_shutdown(struct i2c_client *client)\n{\n\tstruct bq25890_device *bq = i2c_get_clientdata(client);\n\n\t \n\tif (!IS_ERR_OR_NULL(bq->usb_phy))\n\t\treturn;\n\n\t \n\tbq25890_set_otg_cfg(bq, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bq25890_suspend(struct device *dev)\n{\n\tstruct bq25890_device *bq = dev_get_drvdata(dev);\n\n\t \n\treturn bq25890_field_write(bq, F_CONV_RATE, 0);\n}\n\nstatic int bq25890_resume(struct device *dev)\n{\n\tint ret;\n\tstruct bq25890_device *bq = dev_get_drvdata(dev);\n\n\tmutex_lock(&bq->lock);\n\n\tret = bq25890_get_chip_state(bq, &bq->state);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tif (bq->state.online) {\n\t\tret = bq25890_field_write(bq, F_CONV_RATE, 1);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tpower_supply_changed(bq->charger);\n\nunlock:\n\tmutex_unlock(&bq->lock);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops bq25890_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bq25890_suspend, bq25890_resume)\n};\n\nstatic const struct i2c_device_id bq25890_i2c_ids[] = {\n\t{ \"bq25890\", 0 },\n\t{ \"bq25892\", 0 },\n\t{ \"bq25895\", 0 },\n\t{ \"bq25896\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, bq25890_i2c_ids);\n\nstatic const struct of_device_id bq25890_of_match[] __maybe_unused = {\n\t{ .compatible = \"ti,bq25890\", },\n\t{ .compatible = \"ti,bq25892\", },\n\t{ .compatible = \"ti,bq25895\", },\n\t{ .compatible = \"ti,bq25896\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bq25890_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id bq25890_acpi_match[] = {\n\t{\"BQ258900\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, bq25890_acpi_match);\n#endif\n\nstatic struct i2c_driver bq25890_driver = {\n\t.driver = {\n\t\t.name = \"bq25890-charger\",\n\t\t.of_match_table = of_match_ptr(bq25890_of_match),\n\t\t.acpi_match_table = ACPI_PTR(bq25890_acpi_match),\n\t\t.pm = &bq25890_pm,\n\t},\n\t.probe = bq25890_probe,\n\t.remove = bq25890_remove,\n\t.shutdown = bq25890_shutdown,\n\t.id_table = bq25890_i2c_ids,\n};\nmodule_i2c_driver(bq25890_driver);\n\nMODULE_AUTHOR(\"Laurentiu Palcu <laurentiu.palcu@intel.com>\");\nMODULE_DESCRIPTION(\"bq25890 charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}