{
  "module_name": "ucs1002_power.c",
  "hash_id": "fbbcce5b06af4923cb515cd6810302b11bda9edb6a87ed4458ec0884866b6770",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ucs1002_power.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/freezer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define UCS1002_REG_CURRENT_MEASUREMENT\t0x00\n\n \n#define UCS1002_REG_TOTAL_ACC_CHARGE\t0x01\n\n \n#define UCS1002_REG_OTHER_STATUS\t0x0f\n#  define F_ADET_PIN\t\t\tBIT(4)\n#  define F_CHG_ACT\t\t\tBIT(3)\n\n \n#define UCS1002_REG_INTERRUPT_STATUS\t0x10\n#  define F_ERR\t\t\t\tBIT(7)\n#  define F_DISCHARGE_ERR\t\tBIT(6)\n#  define F_RESET\t\t\tBIT(5)\n#  define F_MIN_KEEP_OUT\t\tBIT(4)\n#  define F_TSD\t\t\t\tBIT(3)\n#  define F_OVER_VOLT\t\t\tBIT(2)\n#  define F_BACK_VOLT\t\t\tBIT(1)\n#  define F_OVER_ILIM\t\t\tBIT(0)\n\n \n#define UCS1002_REG_PIN_STATUS\t\t0x14\n#  define UCS1002_PWR_STATE_MASK\t0x03\n#  define F_PWR_EN_PIN\t\t\tBIT(6)\n#  define F_M2_PIN\t\t\tBIT(5)\n#  define F_M1_PIN\t\t\tBIT(4)\n#  define F_EM_EN_PIN\t\t\tBIT(3)\n#  define F_SEL_PIN\t\t\tBIT(2)\n#  define F_ACTIVE_MODE_MASK\t\tGENMASK(5, 3)\n#  define F_ACTIVE_MODE_PASSTHROUGH\tF_M2_PIN\n#  define F_ACTIVE_MODE_DEDICATED\tF_EM_EN_PIN\n#  define F_ACTIVE_MODE_BC12_DCP\t(F_M2_PIN | F_EM_EN_PIN)\n#  define F_ACTIVE_MODE_BC12_SDP\tF_M1_PIN\n#  define F_ACTIVE_MODE_BC12_CDP\t(F_M1_PIN | F_M2_PIN | F_EM_EN_PIN)\n\n \n#define UCS1002_REG_GENERAL_CFG\t\t0x15\n#  define F_RATION_EN\t\t\tBIT(3)\n\n \n#define UCS1002_REG_EMU_CFG\t\t0x16\n\n \n#define UCS1002_REG_SWITCH_CFG\t\t0x17\n#  define F_PIN_IGNORE\t\t\tBIT(7)\n#  define F_EM_EN_SET\t\t\tBIT(5)\n#  define F_M2_SET\t\t\tBIT(4)\n#  define F_M1_SET\t\t\tBIT(3)\n#  define F_S0_SET\t\t\tBIT(2)\n#  define F_PWR_EN_SET\t\t\tBIT(1)\n#  define F_LATCH_SET\t\t\tBIT(0)\n#  define V_SET_ACTIVE_MODE_MASK\tGENMASK(5, 3)\n#  define V_SET_ACTIVE_MODE_PASSTHROUGH\tF_M2_SET\n#  define V_SET_ACTIVE_MODE_DEDICATED\tF_EM_EN_SET\n#  define V_SET_ACTIVE_MODE_BC12_DCP\t(F_M2_SET | F_EM_EN_SET)\n#  define V_SET_ACTIVE_MODE_BC12_SDP\tF_M1_SET\n#  define V_SET_ACTIVE_MODE_BC12_CDP\t(F_M1_SET | F_M2_SET | F_EM_EN_SET)\n\n \n#define UCS1002_REG_ILIMIT\t\t0x19\n#  define UCS1002_ILIM_SW_MASK\t\tGENMASK(3, 0)\n\n \n#define UCS1002_REG_PRODUCT_ID\t\t0xfd\n#  define UCS1002_PRODUCT_ID\t\t0x4e\n\n \n#define UCS1002_MANUFACTURER\t\t\"SMSC\"\n\nstruct ucs1002_info {\n\tstruct power_supply *charger;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct regulator_desc *regulator_descriptor;\n\tstruct regulator_dev *rdev;\n\tbool present;\n\tbool output_disable;\n\tstruct delayed_work health_poll;\n\tint health;\n\n};\n\nstatic enum power_supply_property ucs1002_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_PRESENT,  \n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n};\n\nstatic int ucs1002_get_online(struct ucs1002_info *info,\n\t\t\t      union power_supply_propval *val)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_OTHER_STATUS, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = !!(reg & F_CHG_ACT);\n\n\treturn 0;\n}\n\nstatic int ucs1002_get_charge(struct ucs1002_info *info,\n\t\t\t      union power_supply_propval *val)\n{\n\t \n\tstatic const int bit_weights_uAh[BITS_PER_TYPE(u32)] = {\n\t\t \n\t\t0, 0, 0, 0, 0, 0, 3, 5,\n\t\t \n\t\t11, 22, 43, 87, 173, 347, 694, 1388,\n\t\t \n\t\t2776, 5552, 11105, 22210, 44420, 88840, 177700, 355400,\n\t\t \n\t\t710700, 1421000, 2843000, 5685000, 11371000, 22742000,\n\t\t45484000, 90968000,\n\t};\n\tunsigned long total_acc_charger;\n\tunsigned int reg;\n\tint i, ret;\n\n\tret = regmap_bulk_read(info->regmap, UCS1002_REG_TOTAL_ACC_CHARGE,\n\t\t\t       &reg, sizeof(u32));\n\tif (ret)\n\t\treturn ret;\n\n\ttotal_acc_charger = be32_to_cpu(reg);  \n\tval->intval = 0;\n\n\tfor_each_set_bit(i, &total_acc_charger, ARRAY_SIZE(bit_weights_uAh))\n\t\tval->intval += bit_weights_uAh[i];\n\n\treturn 0;\n}\n\nstatic int ucs1002_get_current(struct ucs1002_info *info,\n\t\t\t       union power_supply_propval *val)\n{\n\t \n\tstatic const int bit_weights_uA[BITS_PER_TYPE(u8)] = {\n\t\t9760, 19500, 39000, 78100, 156200, 312300, 624600, 1249300,\n\t};\n\tunsigned long current_measurement;\n\tunsigned int reg;\n\tint i, ret;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_CURRENT_MEASUREMENT, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tcurrent_measurement = reg;\n\tval->intval = 0;\n\n\tfor_each_set_bit(i, &current_measurement, ARRAY_SIZE(bit_weights_uA))\n\t\tval->intval += bit_weights_uA[i];\n\n\treturn 0;\n}\n\n \nstatic const u32 ucs1002_current_limit_uA[] = {\n\t500000, 900000, 1000000, 1200000, 1500000, 1800000, 2000000, 2500000,\n};\n\nstatic int ucs1002_get_max_current(struct ucs1002_info *info,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tif (info->output_disable) {\n\t\tval->intval = 0;\n\t\treturn 0;\n\t}\n\n\tret = regmap_read(info->regmap, UCS1002_REG_ILIMIT, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval->intval = ucs1002_current_limit_uA[reg & UCS1002_ILIM_SW_MASK];\n\n\treturn 0;\n}\n\nstatic int ucs1002_set_max_current(struct ucs1002_info *info, u32 val)\n{\n\tunsigned int reg;\n\tint ret, idx;\n\n\tif (val == 0) {\n\t\tinfo->output_disable = true;\n\t\tregulator_disable_regmap(info->rdev);\n\t\treturn 0;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(ucs1002_current_limit_uA); idx++) {\n\t\tif (val == ucs1002_current_limit_uA[idx])\n\t\t\tbreak;\n\t}\n\n\tif (idx == ARRAY_SIZE(ucs1002_current_limit_uA))\n\t\treturn -EINVAL;\n\n\tret = regmap_write(info->regmap, UCS1002_REG_ILIMIT, idx);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_read(info->regmap, UCS1002_REG_ILIMIT, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg != idx)\n\t\treturn -EINVAL;\n\n\tinfo->output_disable = false;\n\n\tif (info->rdev && info->rdev->use_count &&\n\t    !regulator_is_enabled_regmap(info->rdev))\n\t\tregulator_enable_regmap(info->rdev);\n\n\treturn 0;\n}\n\nstatic enum power_supply_usb_type ucs1002_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n};\n\nstatic int ucs1002_set_usb_type(struct ucs1002_info *info, int val)\n{\n\tunsigned int mode;\n\n\tif (val < 0 || val >= ARRAY_SIZE(ucs1002_usb_types))\n\t\treturn -EINVAL;\n\n\tswitch (ucs1002_usb_types[val]) {\n\tcase POWER_SUPPLY_USB_TYPE_PD:\n\t\tmode = V_SET_ACTIVE_MODE_DEDICATED;\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_SDP:\n\t\tmode = V_SET_ACTIVE_MODE_BC12_SDP;\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_DCP:\n\t\tmode = V_SET_ACTIVE_MODE_BC12_DCP;\n\t\tbreak;\n\tcase POWER_SUPPLY_USB_TYPE_CDP:\n\t\tmode = V_SET_ACTIVE_MODE_BC12_CDP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(info->regmap, UCS1002_REG_SWITCH_CFG,\n\t\t\t\t  V_SET_ACTIVE_MODE_MASK, mode);\n}\n\nstatic int ucs1002_get_usb_type(struct ucs1002_info *info,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tenum power_supply_usb_type type;\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_PIN_STATUS, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reg & F_ACTIVE_MODE_MASK) {\n\tdefault:\n\t\ttype = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tbreak;\n\tcase F_ACTIVE_MODE_DEDICATED:\n\t\ttype = POWER_SUPPLY_USB_TYPE_PD;\n\t\tbreak;\n\tcase F_ACTIVE_MODE_BC12_SDP:\n\t\ttype = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tbreak;\n\tcase F_ACTIVE_MODE_BC12_DCP:\n\t\ttype = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tbreak;\n\tcase F_ACTIVE_MODE_BC12_CDP:\n\t\ttype = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tbreak;\n\t}\n\n\tval->intval = type;\n\n\treturn 0;\n}\n\nstatic int ucs1002_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct ucs1002_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn ucs1002_get_online(info, val);\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\treturn ucs1002_get_charge(info, val);\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn ucs1002_get_current(info, val);\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn ucs1002_get_max_current(info, val);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn ucs1002_get_usb_type(info, val);\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = info->health;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = info->present;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = UCS1002_MANUFACTURER;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ucs1002_set_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct ucs1002_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn ucs1002_set_max_current(info, val->intval);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn ucs1002_set_usb_type(info, val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ucs1002_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct power_supply_desc ucs1002_charger_desc = {\n\t.name\t\t\t= \"ucs1002\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.usb_types\t\t= ucs1002_usb_types,\n\t.num_usb_types\t\t= ARRAY_SIZE(ucs1002_usb_types),\n\t.get_property\t\t= ucs1002_get_property,\n\t.set_property\t\t= ucs1002_set_property,\n\t.property_is_writeable\t= ucs1002_property_is_writeable,\n\t.properties\t\t= ucs1002_props,\n\t.num_properties\t\t= ARRAY_SIZE(ucs1002_props),\n};\n\nstatic void ucs1002_health_poll(struct work_struct *work)\n{\n\tstruct ucs1002_info *info = container_of(work, struct ucs1002_info,\n\t\t\t\t\t\t health_poll.work);\n\tint ret;\n\tu32 reg;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_INTERRUPT_STATUS, &reg);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif ((reg & F_ERR) && info->health != POWER_SUPPLY_HEALTH_GOOD) {\n\t\tschedule_delayed_work(&info->health_poll,\n\t\t\t\t      msecs_to_jiffies(2000));\n\t\treturn;\n\t}\n\n\tif (reg & F_TSD)\n\t\tinfo->health = POWER_SUPPLY_HEALTH_OVERHEAT;\n\telse if (reg & (F_OVER_VOLT | F_BACK_VOLT))\n\t\tinfo->health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\telse if (reg & F_OVER_ILIM)\n\t\tinfo->health = POWER_SUPPLY_HEALTH_OVERCURRENT;\n\telse if (reg & (F_DISCHARGE_ERR | F_MIN_KEEP_OUT))\n\t\tinfo->health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\telse\n\t\tinfo->health = POWER_SUPPLY_HEALTH_GOOD;\n\n\tsysfs_notify(&info->charger->dev.kobj, NULL, \"health\");\n}\n\nstatic irqreturn_t ucs1002_charger_irq(int irq, void *data)\n{\n\tint ret, regval;\n\tbool present;\n\tstruct ucs1002_info *info = data;\n\n\tpresent = info->present;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_OTHER_STATUS, &regval);\n\tif (ret)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tinfo->present = regval & F_ADET_PIN;\n\n\t \n\tif (present != info->present)\n\t\tpower_supply_changed(info->charger);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ucs1002_alert_irq(int irq, void *data)\n{\n\tstruct ucs1002_info *info = data;\n\n\tmod_delayed_work(system_wq, &info->health_poll, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ucs1002_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct ucs1002_info *info = rdev_get_drvdata(rdev);\n\n\t \n\tif (info->output_disable)\n\t\treturn 0;\n\n\treturn regulator_enable_regmap(rdev);\n}\n\nstatic const struct regulator_ops ucs1002_regulator_ops = {\n\t.is_enabled\t= regulator_is_enabled_regmap,\n\t.enable\t\t= ucs1002_regulator_enable,\n\t.disable\t= regulator_disable_regmap,\n};\n\nstatic const struct regulator_desc ucs1002_regulator_descriptor = {\n\t.name\t\t= \"ucs1002-vbus\",\n\t.ops\t\t= &ucs1002_regulator_ops,\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.owner\t\t= THIS_MODULE,\n\t.enable_reg\t= UCS1002_REG_SWITCH_CFG,\n\t.enable_mask\t= F_PWR_EN_SET,\n\t.enable_val\t= F_PWR_EN_SET,\n\t.fixed_uV\t= 5000000,\n\t.n_voltages\t= 1,\n};\n\nstatic int ucs1002_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_config charger_config = {};\n\tconst struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\tstruct regulator_config regulator_config = {};\n\tint irq_a_det, irq_alert, ret;\n\tstruct ucs1002_info *info;\n\tunsigned int regval;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tret = PTR_ERR_OR_ZERO(info->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Regmap initialization failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinfo->client = client;\n\n\tirq_a_det = of_irq_get_byname(dev->of_node, \"a_det\");\n\tirq_alert = of_irq_get_byname(dev->of_node, \"alert\");\n\n\tcharger_config.of_node = dev->of_node;\n\tcharger_config.drv_data = info;\n\n\tret = regmap_read(info->regmap, UCS1002_REG_PRODUCT_ID, &regval);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read product ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (regval != UCS1002_PRODUCT_ID) {\n\t\tdev_err(dev,\n\t\t\t\"Product ID does not match (0x%02x != 0x%02x)\\n\",\n\t\t\tregval, UCS1002_PRODUCT_ID);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap, UCS1002_REG_GENERAL_CFG,\n\t\t\t\t F_RATION_EN, F_RATION_EN);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read general config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(info->regmap, UCS1002_REG_SWITCH_CFG,\n\t\t\t\t V_SET_ACTIVE_MODE_MASK | F_PIN_IGNORE,\n\t\t\t\t V_SET_ACTIVE_MODE_BC12_CDP | F_PIN_IGNORE);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to configure default mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tret = ucs1002_set_max_current(info, 500000);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set max current default: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinfo->charger = devm_power_supply_register(dev, &ucs1002_charger_desc,\n\t\t\t\t\t\t   &charger_config);\n\tret = PTR_ERR_OR_ZERO(info->charger);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register power supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(info->regmap, UCS1002_REG_PIN_STATUS, &regval);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read pin status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinfo->regulator_descriptor =\n\t\tdevm_kmemdup(dev, &ucs1002_regulator_descriptor,\n\t\t\t     sizeof(ucs1002_regulator_descriptor),\n\t\t\t     GFP_KERNEL);\n\tif (!info->regulator_descriptor)\n\t\treturn -ENOMEM;\n\n\tinfo->regulator_descriptor->enable_is_inverted = !(regval & F_SEL_PIN);\n\n\tregulator_config.dev = dev;\n\tregulator_config.of_node = dev->of_node;\n\tregulator_config.regmap = info->regmap;\n\tregulator_config.driver_data = info;\n\n\tinfo->rdev = devm_regulator_register(dev, info->regulator_descriptor,\n\t\t\t\t       &regulator_config);\n\tret = PTR_ERR_OR_ZERO(info->rdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register VBUS regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinfo->health = POWER_SUPPLY_HEALTH_GOOD;\n\tINIT_DELAYED_WORK(&info->health_poll, ucs1002_health_poll);\n\n\tif (irq_a_det > 0) {\n\t\tret = devm_request_threaded_irq(dev, irq_a_det, NULL,\n\t\t\t\t\t\tucs1002_charger_irq,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"ucs1002-a_det\", info);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request A_DET threaded irq: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (irq_alert > 0) {\n\t\tret = devm_request_irq(dev, irq_alert, ucs1002_alert_irq,\n\t\t\t\t       0,\"ucs1002-alert\", info);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request ALERT threaded irq: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ucs1002_of_match[] = {\n\t{ .compatible = \"microchip,ucs1002\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ucs1002_of_match);\n\nstatic struct i2c_driver ucs1002_driver = {\n\t.driver = {\n\t\t   .name = \"ucs1002\",\n\t\t   .of_match_table = ucs1002_of_match,\n\t},\n\t.probe = ucs1002_probe,\n};\nmodule_i2c_driver(ucs1002_driver);\n\nMODULE_DESCRIPTION(\"Microchip UCS1002 Programmable USB Port Power Controller\");\nMODULE_AUTHOR(\"Enric Balletbo Serra <enric.balletbo@collabora.com>\");\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}