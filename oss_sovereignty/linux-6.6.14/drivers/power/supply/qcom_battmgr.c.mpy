{
  "module_name": "qcom_battmgr.c",
  "hash_id": "7ca5fe1e0248856db2a16d815b80cff49f83ae97e369fa61cd6f12ef17137947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/qcom_battmgr.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_device.h>\n#include <linux/power_supply.h>\n#include <linux/soc/qcom/pdr.h>\n#include <linux/soc/qcom/pmic_glink.h>\n#include <linux/math.h>\n#include <linux/units.h>\n\n#define BATTMGR_CHEMISTRY_LEN\t4\n#define BATTMGR_STRING_LEN\t128\n\nenum qcom_battmgr_variant {\n\tQCOM_BATTMGR_SM8350,\n\tQCOM_BATTMGR_SC8280XP,\n};\n\n#define BATTMGR_BAT_STATUS\t\t0x1\n\n#define BATTMGR_REQUEST_NOTIFICATION\t0x4\n\n#define BATTMGR_NOTIFICATION\t\t0x7\n#define NOTIF_BAT_PROPERTY\t\t0x30\n#define NOTIF_USB_PROPERTY\t\t0x32\n#define NOTIF_WLS_PROPERTY\t\t0x34\n#define NOTIF_BAT_INFO\t\t\t0x81\n#define NOTIF_BAT_STATUS\t\t0x80\n\n#define BATTMGR_BAT_INFO\t\t0x9\n\n#define BATTMGR_BAT_DISCHARGE_TIME\t0xc\n\n#define BATTMGR_BAT_CHARGE_TIME\t\t0xd\n\n#define BATTMGR_BAT_PROPERTY_GET\t0x30\n#define BATTMGR_BAT_PROPERTY_SET\t0x31\n#define BATT_STATUS\t\t\t0\n#define BATT_HEALTH\t\t\t1\n#define BATT_PRESENT\t\t\t2\n#define BATT_CHG_TYPE\t\t\t3\n#define BATT_CAPACITY\t\t\t4\n#define BATT_SOH\t\t\t5\n#define BATT_VOLT_OCV\t\t\t6\n#define BATT_VOLT_NOW\t\t\t7\n#define BATT_VOLT_MAX\t\t\t8\n#define BATT_CURR_NOW\t\t\t9\n#define BATT_CHG_CTRL_LIM\t\t10\n#define BATT_CHG_CTRL_LIM_MAX\t\t11\n#define BATT_TEMP\t\t\t12\n#define BATT_TECHNOLOGY\t\t\t13\n#define BATT_CHG_COUNTER\t\t14\n#define BATT_CYCLE_COUNT\t\t15\n#define BATT_CHG_FULL_DESIGN\t\t16\n#define BATT_CHG_FULL\t\t\t17\n#define BATT_MODEL_NAME\t\t\t18\n#define BATT_TTF_AVG\t\t\t19\n#define BATT_TTE_AVG\t\t\t20\n#define BATT_RESISTANCE\t\t\t21\n#define BATT_POWER_NOW\t\t\t22\n#define BATT_POWER_AVG\t\t\t23\n\n#define BATTMGR_USB_PROPERTY_GET\t0x32\n#define BATTMGR_USB_PROPERTY_SET\t0x33\n#define USB_ONLINE\t\t\t0\n#define USB_VOLT_NOW\t\t\t1\n#define USB_VOLT_MAX\t\t\t2\n#define USB_CURR_NOW\t\t\t3\n#define USB_CURR_MAX\t\t\t4\n#define USB_INPUT_CURR_LIMIT\t\t5\n#define USB_TYPE\t\t\t6\n#define USB_ADAP_TYPE\t\t\t7\n#define USB_MOISTURE_DET_EN\t\t8\n#define USB_MOISTURE_DET_STS\t\t9\n\n#define BATTMGR_WLS_PROPERTY_GET\t0x34\n#define BATTMGR_WLS_PROPERTY_SET\t0x35\n#define WLS_ONLINE\t\t\t0\n#define WLS_VOLT_NOW\t\t\t1\n#define WLS_VOLT_MAX\t\t\t2\n#define WLS_CURR_NOW\t\t\t3\n#define WLS_CURR_MAX\t\t\t4\n#define WLS_TYPE\t\t\t5\n#define WLS_BOOST_EN\t\t\t6\n\nstruct qcom_battmgr_enable_request {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 battery_id;\n\t__le32 power_state;\n\t__le32 low_capacity;\n\t__le32 high_capacity;\n};\n\nstruct qcom_battmgr_property_request {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 battery;\n\t__le32 property;\n\t__le32 value;\n};\n\nstruct qcom_battmgr_update_request {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 battery_id;\n};\n\nstruct qcom_battmgr_charge_time_request {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 battery_id;\n\t__le32 percent;\n\t__le32 reserved;\n};\n\nstruct qcom_battmgr_discharge_time_request {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 battery_id;\n\t__le32 rate;  \n\t__le32 reserved;\n};\n\nstruct qcom_battmgr_message {\n\tstruct pmic_glink_hdr hdr;\n\tunion {\n\t\tstruct {\n\t\t\t__le32 property;\n\t\t\t__le32 value;\n\t\t\t__le32 result;\n\t\t} intval;\n\t\tstruct {\n\t\t\t__le32 property;\n\t\t\tchar model[BATTMGR_STRING_LEN];\n\t\t} strval;\n\t\tstruct {\n\t\t\t \n\t\t\t__le32 power_unit;\n\t\t\t__le32 design_capacity;\n\t\t\t__le32 last_full_capacity;\n\t\t\t \n\t\t\t__le32 battery_tech;\n\t\t\t__le32 design_voltage;  \n\t\t\t__le32 capacity_low;\n\t\t\t__le32 capacity_warning;\n\t\t\t__le32 cycle_count;\n\t\t\t \n\t\t\t__le32 accuracy;\n\t\t\t__le32 max_sample_time_ms;\n\t\t\t__le32 min_sample_time_ms;\n\t\t\t__le32 max_average_interval_ms;\n\t\t\t__le32 min_average_interval_ms;\n\t\t\t \n\t\t\t__le32 capacity_granularity1;\n\t\t\t \n\t\t\t__le32 capacity_granularity2;\n\t\t\t \n\t\t\t__le32 swappable;\n\t\t\t__le32 capabilities;\n\t\t\tchar model_number[BATTMGR_STRING_LEN];\n\t\t\tchar serial_number[BATTMGR_STRING_LEN];\n\t\t\tchar battery_type[BATTMGR_STRING_LEN];\n\t\t\tchar oem_info[BATTMGR_STRING_LEN];\n\t\t\tchar battery_chemistry[BATTMGR_CHEMISTRY_LEN];\n\t\t\tchar uid[BATTMGR_STRING_LEN];\n\t\t\t__le32 critical_bias;\n\t\t\tu8 day;\n\t\t\tu8 month;\n\t\t\t__le16 year;\n\t\t\t__le32 battery_id;\n\t\t} info;\n\t\tstruct {\n\t\t\t \n\t\t\t__le32 battery_state;\n\t\t\t \n\t\t\t__le32 capacity;\n\t\t\t__le32 rate;\n\t\t\t \n\t\t\t__le32 battery_voltage;\n\t\t\t \n\t\t\t__le32 power_state;\n\t\t\t \n\t\t\t__le32 charging_source;\n\t\t\t__le32 temperature;\n\t\t} status;\n\t\t__le32 time;\n\t\t__le32 notification;\n\t};\n};\n\n#define BATTMGR_CHARGING_SOURCE_AC\t1\n#define BATTMGR_CHARGING_SOURCE_USB\t2\n#define BATTMGR_CHARGING_SOURCE_WIRELESS 3\n\nenum qcom_battmgr_unit {\n\tQCOM_BATTMGR_UNIT_mWh = 0,\n\tQCOM_BATTMGR_UNIT_mAh = 1\n};\n\nstruct qcom_battmgr_info {\n\tbool valid;\n\n\tbool present;\n\tunsigned int charge_type;\n\tunsigned int design_capacity;\n\tunsigned int last_full_capacity;\n\tunsigned int voltage_max_design;\n\tunsigned int voltage_max;\n\tunsigned int capacity_low;\n\tunsigned int capacity_warning;\n\tunsigned int cycle_count;\n\tunsigned int charge_count;\n\tchar model_number[BATTMGR_STRING_LEN];\n\tchar serial_number[BATTMGR_STRING_LEN];\n\tchar oem_info[BATTMGR_STRING_LEN];\n\tunsigned char technology;\n\tunsigned char day;\n\tunsigned char month;\n\tunsigned short year;\n};\n\nstruct qcom_battmgr_status {\n\tunsigned int status;\n\tunsigned int health;\n\tunsigned int capacity;\n\tunsigned int percent;\n\tint current_now;\n\tint power_now;\n\tunsigned int voltage_now;\n\tunsigned int voltage_ocv;\n\tunsigned int temperature;\n\n\tunsigned int discharge_time;\n\tunsigned int charge_time;\n};\n\nstruct qcom_battmgr_ac {\n\tbool online;\n};\n\nstruct qcom_battmgr_usb {\n\tbool online;\n\tunsigned int voltage_now;\n\tunsigned int voltage_max;\n\tunsigned int current_now;\n\tunsigned int current_max;\n\tunsigned int current_limit;\n\tunsigned int usb_type;\n};\n\nstruct qcom_battmgr_wireless {\n\tbool online;\n\tunsigned int voltage_now;\n\tunsigned int voltage_max;\n\tunsigned int current_now;\n\tunsigned int current_max;\n};\n\nstruct qcom_battmgr {\n\tstruct device *dev;\n\tstruct pmic_glink_client *client;\n\n\tenum qcom_battmgr_variant variant;\n\n\tstruct power_supply *ac_psy;\n\tstruct power_supply *bat_psy;\n\tstruct power_supply *usb_psy;\n\tstruct power_supply *wls_psy;\n\n\tenum qcom_battmgr_unit unit;\n\n\tint error;\n\tstruct completion ack;\n\n\tbool service_up;\n\n\tstruct qcom_battmgr_info info;\n\tstruct qcom_battmgr_status status;\n\tstruct qcom_battmgr_ac ac;\n\tstruct qcom_battmgr_usb usb;\n\tstruct qcom_battmgr_wireless wireless;\n\n\tstruct work_struct enable_work;\n\n\t \n\tstruct mutex lock;\n};\n\nstatic int qcom_battmgr_request(struct qcom_battmgr *battmgr, void *data, size_t len)\n{\n\tunsigned long left;\n\tint ret;\n\n\treinit_completion(&battmgr->ack);\n\n\tbattmgr->error = 0;\n\n\tret = pmic_glink_send(battmgr->client, data, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tleft = wait_for_completion_timeout(&battmgr->ack, HZ);\n\tif (!left)\n\t\treturn -ETIMEDOUT;\n\n\treturn battmgr->error;\n}\n\nstatic int qcom_battmgr_request_property(struct qcom_battmgr *battmgr, int opcode,\n\t\t\t\t\t int property, u32 value)\n{\n\tstruct qcom_battmgr_property_request request = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP),\n\t\t.hdr.opcode = cpu_to_le32(opcode),\n\t\t.battery = cpu_to_le32(0),\n\t\t.property = cpu_to_le32(property),\n\t\t.value = cpu_to_le32(value),\n\t};\n\n\treturn qcom_battmgr_request(battmgr, &request, sizeof(request));\n}\n\nstatic int qcom_battmgr_update_status(struct qcom_battmgr *battmgr)\n{\n\tstruct qcom_battmgr_update_request request = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP),\n\t\t.hdr.opcode = cpu_to_le32(BATTMGR_BAT_STATUS),\n\t\t.battery_id = cpu_to_le32(0),\n\t};\n\n\treturn qcom_battmgr_request(battmgr, &request, sizeof(request));\n}\n\nstatic int qcom_battmgr_update_info(struct qcom_battmgr *battmgr)\n{\n\tstruct qcom_battmgr_update_request request = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP),\n\t\t.hdr.opcode = cpu_to_le32(BATTMGR_BAT_INFO),\n\t\t.battery_id = cpu_to_le32(0),\n\t};\n\n\treturn qcom_battmgr_request(battmgr, &request, sizeof(request));\n}\n\nstatic int qcom_battmgr_update_charge_time(struct qcom_battmgr *battmgr)\n{\n\tstruct qcom_battmgr_charge_time_request request = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP),\n\t\t.hdr.opcode = cpu_to_le32(BATTMGR_BAT_CHARGE_TIME),\n\t\t.battery_id = cpu_to_le32(0),\n\t\t.percent = cpu_to_le32(100),\n\t};\n\n\treturn qcom_battmgr_request(battmgr, &request, sizeof(request));\n}\n\nstatic int qcom_battmgr_update_discharge_time(struct qcom_battmgr *battmgr)\n{\n\tstruct qcom_battmgr_discharge_time_request request = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP),\n\t\t.hdr.opcode = cpu_to_le32(BATTMGR_BAT_DISCHARGE_TIME),\n\t\t.battery_id = cpu_to_le32(0),\n\t\t.rate = cpu_to_le32(0),\n\t};\n\n\treturn qcom_battmgr_request(battmgr, &request, sizeof(request));\n}\n\nstatic const u8 sm8350_bat_prop_map[] = {\n\t[POWER_SUPPLY_PROP_STATUS] = BATT_STATUS,\n\t[POWER_SUPPLY_PROP_HEALTH] = BATT_HEALTH,\n\t[POWER_SUPPLY_PROP_PRESENT] = BATT_PRESENT,\n\t[POWER_SUPPLY_PROP_CHARGE_TYPE] = BATT_CHG_TYPE,\n\t[POWER_SUPPLY_PROP_CAPACITY] = BATT_CAPACITY,\n\t[POWER_SUPPLY_PROP_VOLTAGE_OCV] = BATT_VOLT_OCV,\n\t[POWER_SUPPLY_PROP_VOLTAGE_NOW] = BATT_VOLT_NOW,\n\t[POWER_SUPPLY_PROP_VOLTAGE_MAX] = BATT_VOLT_MAX,\n\t[POWER_SUPPLY_PROP_CURRENT_NOW] = BATT_CURR_NOW,\n\t[POWER_SUPPLY_PROP_TEMP] = BATT_TEMP,\n\t[POWER_SUPPLY_PROP_TECHNOLOGY] = BATT_TECHNOLOGY,\n\t[POWER_SUPPLY_PROP_CHARGE_COUNTER] =  BATT_CHG_COUNTER,\n\t[POWER_SUPPLY_PROP_CYCLE_COUNT] = BATT_CYCLE_COUNT,\n\t[POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN] =  BATT_CHG_FULL_DESIGN,\n\t[POWER_SUPPLY_PROP_CHARGE_FULL] = BATT_CHG_FULL,\n\t[POWER_SUPPLY_PROP_MODEL_NAME] = BATT_MODEL_NAME,\n\t[POWER_SUPPLY_PROP_TIME_TO_FULL_AVG] = BATT_TTF_AVG,\n\t[POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG] = BATT_TTE_AVG,\n\t[POWER_SUPPLY_PROP_POWER_NOW] = BATT_POWER_NOW,\n};\n\nstatic int qcom_battmgr_bat_sm8350_update(struct qcom_battmgr *battmgr,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\tunsigned int prop;\n\tint ret;\n\n\tif (psp >= ARRAY_SIZE(sm8350_bat_prop_map))\n\t\treturn -EINVAL;\n\n\tprop = sm8350_bat_prop_map[psp];\n\n\tmutex_lock(&battmgr->lock);\n\tret = qcom_battmgr_request_property(battmgr, BATTMGR_BAT_PROPERTY_GET, prop, 0);\n\tmutex_unlock(&battmgr->lock);\n\n\treturn ret;\n}\n\nstatic int qcom_battmgr_bat_sc8280xp_update(struct qcom_battmgr *battmgr,\n\t\t\t\t\t    enum power_supply_property psp)\n{\n\tint ret;\n\n\tmutex_lock(&battmgr->lock);\n\n\tif (!battmgr->info.valid) {\n\t\tret = qcom_battmgr_update_info(battmgr);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t\tbattmgr->info.valid = true;\n\t}\n\n\tret = qcom_battmgr_update_status(battmgr);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tif (psp == POWER_SUPPLY_PROP_TIME_TO_FULL_AVG) {\n\t\tret = qcom_battmgr_update_charge_time(battmgr);\n\t\tif (ret < 0) {\n\t\t\tret = -ENODATA;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (psp == POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG) {\n\t\tret = qcom_battmgr_update_discharge_time(battmgr);\n\t\tif (ret < 0) {\n\t\t\tret = -ENODATA;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout_unlock:\n\tmutex_unlock(&battmgr->lock);\n\treturn ret;\n}\n\nstatic int qcom_battmgr_bat_get_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct qcom_battmgr *battmgr = power_supply_get_drvdata(psy);\n\tenum qcom_battmgr_unit unit = battmgr->unit;\n\tint ret;\n\n\tif (!battmgr->service_up)\n\t\treturn -ENODEV;\n\n\tif (battmgr->variant == QCOM_BATTMGR_SC8280XP)\n\t\tret = qcom_battmgr_bat_sc8280xp_update(battmgr, psp);\n\telse\n\t\tret = qcom_battmgr_bat_sm8350_update(battmgr, psp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = battmgr->status.status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = battmgr->info.charge_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = battmgr->status.health;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = battmgr->info.present;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = battmgr->info.technology;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CYCLE_COUNT:\n\t\tval->intval = battmgr->info.cycle_count;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = battmgr->info.voltage_max_design;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tval->intval = battmgr->info.voltage_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = battmgr->status.voltage_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tval->intval = battmgr->status.voltage_ocv;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = battmgr->status.current_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\tval->intval = battmgr->status.power_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mAh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.design_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mAh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.last_full_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_EMPTY:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mAh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.capacity_low;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mAh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->status.capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tval->intval = battmgr->info.charge_count;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mWh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.design_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mWh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.last_full_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_EMPTY:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mWh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->info.capacity_low;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ENERGY_NOW:\n\t\tif (unit != QCOM_BATTMGR_UNIT_mWh)\n\t\t\treturn -ENODATA;\n\t\tval->intval = battmgr->status.capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = battmgr->status.percent;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = battmgr->status.temperature;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\t\tval->intval = battmgr->status.discharge_time;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\n\t\tval->intval = battmgr->status.charge_time;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_YEAR:\n\t\tval->intval = battmgr->info.year;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_MONTH:\n\t\tval->intval = battmgr->info.month;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURE_DAY:\n\t\tval->intval = battmgr->info.day;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = battmgr->info.model_number;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = battmgr->info.oem_info;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tval->strval = battmgr->info.serial_number;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_property sc8280xp_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_EMPTY,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL,\n\tPOWER_SUPPLY_PROP_ENERGY_EMPTY,\n\tPOWER_SUPPLY_PROP_ENERGY_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_YEAR,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_MONTH,\n\tPOWER_SUPPLY_PROP_MANUFACTURE_DAY,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic const struct power_supply_desc sc8280xp_bat_psy_desc = {\n\t.name = \"qcom-battmgr-bat\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = sc8280xp_bat_props,\n\t.num_properties = ARRAY_SIZE(sc8280xp_bat_props),\n\t.get_property = qcom_battmgr_bat_get_property,\n};\n\nstatic const enum power_supply_property sm8350_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_CYCLE_COUNT,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_TIME_TO_FULL_AVG,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n};\n\nstatic const struct power_supply_desc sm8350_bat_psy_desc = {\n\t.name = \"qcom-battmgr-bat\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = sm8350_bat_props,\n\t.num_properties = ARRAY_SIZE(sm8350_bat_props),\n\t.get_property = qcom_battmgr_bat_get_property,\n};\n\nstatic int qcom_battmgr_ac_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct qcom_battmgr *battmgr = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (!battmgr->service_up)\n\t\treturn -ENODEV;\n\n\tret = qcom_battmgr_bat_sc8280xp_update(battmgr, psp);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = battmgr->ac.online;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_property sc8280xp_ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc sc8280xp_ac_psy_desc = {\n\t.name = \"qcom-battmgr-ac\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = sc8280xp_ac_props,\n\t.num_properties = ARRAY_SIZE(sc8280xp_ac_props),\n\t.get_property = qcom_battmgr_ac_get_property,\n};\n\nstatic const u8 sm8350_usb_prop_map[] = {\n\t[POWER_SUPPLY_PROP_ONLINE] = USB_ONLINE,\n\t[POWER_SUPPLY_PROP_VOLTAGE_NOW] = USB_VOLT_NOW,\n\t[POWER_SUPPLY_PROP_VOLTAGE_MAX] = USB_VOLT_MAX,\n\t[POWER_SUPPLY_PROP_CURRENT_NOW] = USB_CURR_NOW,\n\t[POWER_SUPPLY_PROP_CURRENT_MAX] = USB_CURR_MAX,\n\t[POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT] = USB_INPUT_CURR_LIMIT,\n\t[POWER_SUPPLY_PROP_USB_TYPE] = USB_TYPE,\n};\n\nstatic int qcom_battmgr_usb_sm8350_update(struct qcom_battmgr *battmgr,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\tunsigned int prop;\n\tint ret;\n\n\tif (psp >= ARRAY_SIZE(sm8350_usb_prop_map))\n\t\treturn -EINVAL;\n\n\tprop = sm8350_usb_prop_map[psp];\n\n\tmutex_lock(&battmgr->lock);\n\tret = qcom_battmgr_request_property(battmgr, BATTMGR_USB_PROPERTY_GET, prop, 0);\n\tmutex_unlock(&battmgr->lock);\n\n\treturn ret;\n}\n\nstatic int qcom_battmgr_usb_get_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct qcom_battmgr *battmgr = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (!battmgr->service_up)\n\t\treturn -ENODEV;\n\n\tif (battmgr->variant == QCOM_BATTMGR_SC8280XP)\n\t\tret = qcom_battmgr_bat_sc8280xp_update(battmgr, psp);\n\telse\n\t\tret = qcom_battmgr_usb_sm8350_update(battmgr, psp);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = battmgr->usb.online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = battmgr->usb.voltage_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tval->intval = battmgr->usb.voltage_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = battmgr->usb.current_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = battmgr->usb.current_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tval->intval = battmgr->usb.current_limit;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = battmgr->usb.usb_type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_usb_type usb_psy_supported_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_ACA,\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_DRP,\n\tPOWER_SUPPLY_USB_TYPE_PD_PPS,\n\tPOWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID,\n};\n\nstatic const enum power_supply_property sc8280xp_usb_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc sc8280xp_usb_psy_desc = {\n\t.name = \"qcom-battmgr-usb\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = sc8280xp_usb_props,\n\t.num_properties = ARRAY_SIZE(sc8280xp_usb_props),\n\t.get_property = qcom_battmgr_usb_get_property,\n\t.usb_types = usb_psy_supported_types,\n\t.num_usb_types = ARRAY_SIZE(usb_psy_supported_types),\n};\n\nstatic const enum power_supply_property sm8350_usb_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n};\n\nstatic const struct power_supply_desc sm8350_usb_psy_desc = {\n\t.name = \"qcom-battmgr-usb\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = sm8350_usb_props,\n\t.num_properties = ARRAY_SIZE(sm8350_usb_props),\n\t.get_property = qcom_battmgr_usb_get_property,\n\t.usb_types = usb_psy_supported_types,\n\t.num_usb_types = ARRAY_SIZE(usb_psy_supported_types),\n};\n\nstatic const u8 sm8350_wls_prop_map[] = {\n\t[POWER_SUPPLY_PROP_ONLINE] = WLS_ONLINE,\n\t[POWER_SUPPLY_PROP_VOLTAGE_NOW] = WLS_VOLT_NOW,\n\t[POWER_SUPPLY_PROP_VOLTAGE_MAX] = WLS_VOLT_MAX,\n\t[POWER_SUPPLY_PROP_CURRENT_NOW] = WLS_CURR_NOW,\n\t[POWER_SUPPLY_PROP_CURRENT_MAX] = WLS_CURR_MAX,\n};\n\nstatic int qcom_battmgr_wls_sm8350_update(struct qcom_battmgr *battmgr,\n\t\t\t\t\t  enum power_supply_property psp)\n{\n\tunsigned int prop;\n\tint ret;\n\n\tif (psp >= ARRAY_SIZE(sm8350_wls_prop_map))\n\t\treturn -EINVAL;\n\n\tprop = sm8350_wls_prop_map[psp];\n\n\tmutex_lock(&battmgr->lock);\n\tret = qcom_battmgr_request_property(battmgr, BATTMGR_WLS_PROPERTY_GET, prop, 0);\n\tmutex_unlock(&battmgr->lock);\n\n\treturn ret;\n}\n\nstatic int qcom_battmgr_wls_get_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property psp,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct qcom_battmgr *battmgr = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (!battmgr->service_up)\n\t\treturn -ENODEV;\n\n\tif (battmgr->variant == QCOM_BATTMGR_SC8280XP)\n\t\tret = qcom_battmgr_bat_sc8280xp_update(battmgr, psp);\n\telse\n\t\tret = qcom_battmgr_wls_sm8350_update(battmgr, psp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = battmgr->wireless.online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = battmgr->wireless.voltage_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tval->intval = battmgr->wireless.voltage_max;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = battmgr->wireless.current_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = battmgr->wireless.current_max;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_property sc8280xp_wls_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc sc8280xp_wls_psy_desc = {\n\t.name = \"qcom-battmgr-wls\",\n\t.type = POWER_SUPPLY_TYPE_WIRELESS,\n\t.properties = sc8280xp_wls_props,\n\t.num_properties = ARRAY_SIZE(sc8280xp_wls_props),\n\t.get_property = qcom_battmgr_wls_get_property,\n};\n\nstatic const enum power_supply_property sm8350_wls_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n};\n\nstatic const struct power_supply_desc sm8350_wls_psy_desc = {\n\t.name = \"qcom-battmgr-wls\",\n\t.type = POWER_SUPPLY_TYPE_WIRELESS,\n\t.properties = sm8350_wls_props,\n\t.num_properties = ARRAY_SIZE(sm8350_wls_props),\n\t.get_property = qcom_battmgr_wls_get_property,\n};\n\nstatic void qcom_battmgr_notification(struct qcom_battmgr *battmgr,\n\t\t\t\t      const struct qcom_battmgr_message *msg,\n\t\t\t\t      int len)\n{\n\tsize_t payload_len = len - sizeof(struct pmic_glink_hdr);\n\tunsigned int notification;\n\n\tif (payload_len != sizeof(msg->notification)) {\n\t\tdev_warn(battmgr->dev, \"ignoring notification with invalid length\\n\");\n\t\treturn;\n\t}\n\n\tnotification = le32_to_cpu(msg->notification);\n\tswitch (notification) {\n\tcase NOTIF_BAT_INFO:\n\t\tbattmgr->info.valid = false;\n\t\tfallthrough;\n\tcase NOTIF_BAT_STATUS:\n\tcase NOTIF_BAT_PROPERTY:\n\t\tpower_supply_changed(battmgr->bat_psy);\n\t\tbreak;\n\tcase NOTIF_USB_PROPERTY:\n\t\tpower_supply_changed(battmgr->usb_psy);\n\t\tbreak;\n\tcase NOTIF_WLS_PROPERTY:\n\t\tpower_supply_changed(battmgr->wls_psy);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(battmgr->dev, \"unknown notification: %#x\\n\", notification);\n\t\tbreak;\n\t}\n}\n\nstatic void qcom_battmgr_sc8280xp_strcpy(char *dest, const char *src)\n{\n\tsize_t len = src[0];\n\n\t \n\tif (len < BATTMGR_STRING_LEN && len == strnlen(src + 1, BATTMGR_STRING_LEN - 1)) {\n\t\tmemcpy(dest, src + 1, len);\n\t\tdest[len] = '\\0';\n\t} else {\n\t\tmemcpy(dest, src, BATTMGR_STRING_LEN);\n\t}\n}\n\nstatic unsigned int qcom_battmgr_sc8280xp_parse_technology(const char *chemistry)\n{\n\tif (!strncmp(chemistry, \"LIO\", BATTMGR_CHEMISTRY_LEN))\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\n\tpr_err(\"Unknown battery technology '%s'\\n\", chemistry);\n\treturn POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n}\n\nstatic unsigned int qcom_battmgr_sc8280xp_convert_temp(unsigned int temperature)\n{\n\treturn DIV_ROUND_CLOSEST(temperature, 10);\n}\n\nstatic void qcom_battmgr_sc8280xp_callback(struct qcom_battmgr *battmgr,\n\t\t\t\t\t   const struct qcom_battmgr_message *resp,\n\t\t\t\t\t   size_t len)\n{\n\tunsigned int opcode = le32_to_cpu(resp->hdr.opcode);\n\tunsigned int source;\n\tunsigned int state;\n\tsize_t payload_len = len - sizeof(struct pmic_glink_hdr);\n\n\tif (payload_len < sizeof(__le32)) {\n\t\tdev_warn(battmgr->dev, \"invalid payload length for %#x: %zd\\n\",\n\t\t\t opcode, len);\n\t\treturn;\n\t}\n\n\tswitch (opcode) {\n\tcase BATTMGR_REQUEST_NOTIFICATION:\n\t\tbattmgr->error = 0;\n\t\tbreak;\n\tcase BATTMGR_BAT_INFO:\n\t\tif (payload_len != sizeof(resp->info)) {\n\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t \"invalid payload length for battery information request: %zd\\n\",\n\t\t\t\t payload_len);\n\t\t\tbattmgr->error = -ENODATA;\n\t\t\treturn;\n\t\t}\n\n\t\tbattmgr->unit = le32_to_cpu(resp->info.power_unit);\n\n\t\tbattmgr->info.present = true;\n\t\tbattmgr->info.design_capacity = le32_to_cpu(resp->info.design_capacity) * 1000;\n\t\tbattmgr->info.last_full_capacity = le32_to_cpu(resp->info.last_full_capacity) * 1000;\n\t\tbattmgr->info.voltage_max_design = le32_to_cpu(resp->info.design_voltage) * 1000;\n\t\tbattmgr->info.capacity_low = le32_to_cpu(resp->info.capacity_low) * 1000;\n\t\tbattmgr->info.cycle_count = le32_to_cpu(resp->info.cycle_count);\n\t\tqcom_battmgr_sc8280xp_strcpy(battmgr->info.model_number, resp->info.model_number);\n\t\tqcom_battmgr_sc8280xp_strcpy(battmgr->info.serial_number, resp->info.serial_number);\n\t\tbattmgr->info.technology = qcom_battmgr_sc8280xp_parse_technology(resp->info.battery_chemistry);\n\t\tqcom_battmgr_sc8280xp_strcpy(battmgr->info.oem_info, resp->info.oem_info);\n\t\tbattmgr->info.day = resp->info.day;\n\t\tbattmgr->info.month = resp->info.month;\n\t\tbattmgr->info.year = le16_to_cpu(resp->info.year);\n\t\tbreak;\n\tcase BATTMGR_BAT_STATUS:\n\t\tif (payload_len != sizeof(resp->status)) {\n\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t \"invalid payload length for battery status request: %zd\\n\",\n\t\t\t\t payload_len);\n\t\t\tbattmgr->error = -ENODATA;\n\t\t\treturn;\n\t\t}\n\n\t\tstate = le32_to_cpu(resp->status.battery_state);\n\t\tif (state & BIT(0))\n\t\t\tbattmgr->status.status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (state & BIT(1))\n\t\t\tbattmgr->status.status = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tbattmgr->status.status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\t\tbattmgr->status.capacity = le32_to_cpu(resp->status.capacity) * 1000;\n\t\tbattmgr->status.power_now = le32_to_cpu(resp->status.rate) * 1000;\n\t\tbattmgr->status.voltage_now = le32_to_cpu(resp->status.battery_voltage) * 1000;\n\t\tbattmgr->status.temperature = qcom_battmgr_sc8280xp_convert_temp(le32_to_cpu(resp->status.temperature));\n\n\t\tsource = le32_to_cpu(resp->status.charging_source);\n\t\tbattmgr->ac.online = source == BATTMGR_CHARGING_SOURCE_AC;\n\t\tbattmgr->usb.online = source == BATTMGR_CHARGING_SOURCE_USB;\n\t\tbattmgr->wireless.online = source == BATTMGR_CHARGING_SOURCE_WIRELESS;\n\t\tbreak;\n\tcase BATTMGR_BAT_DISCHARGE_TIME:\n\t\tbattmgr->status.discharge_time = le32_to_cpu(resp->time);\n\t\tbreak;\n\tcase BATTMGR_BAT_CHARGE_TIME:\n\t\tbattmgr->status.charge_time = le32_to_cpu(resp->time);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(battmgr->dev, \"unknown message %#x\\n\", opcode);\n\t\tbreak;\n\t}\n\n\tcomplete(&battmgr->ack);\n}\n\nstatic void qcom_battmgr_sm8350_callback(struct qcom_battmgr *battmgr,\n\t\t\t\t\t const struct qcom_battmgr_message *resp,\n\t\t\t\t\t size_t len)\n{\n\tunsigned int property;\n\tunsigned int opcode = le32_to_cpu(resp->hdr.opcode);\n\tsize_t payload_len = len - sizeof(struct pmic_glink_hdr);\n\tunsigned int val;\n\n\tif (payload_len < sizeof(__le32)) {\n\t\tdev_warn(battmgr->dev, \"invalid payload length for %#x: %zd\\n\",\n\t\t\t opcode, len);\n\t\treturn;\n\t}\n\n\tswitch (opcode) {\n\tcase BATTMGR_BAT_PROPERTY_GET:\n\t\tproperty = le32_to_cpu(resp->intval.property);\n\t\tif (property == BATT_MODEL_NAME) {\n\t\t\tif (payload_len != sizeof(resp->strval)) {\n\t\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t\t \"invalid payload length for BATT_MODEL_NAME request: %zd\\n\",\n\t\t\t\t\t payload_len);\n\t\t\t\tbattmgr->error = -ENODATA;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (payload_len != sizeof(resp->intval)) {\n\t\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t\t \"invalid payload length for %#x request: %zd\\n\",\n\t\t\t\t\t property, payload_len);\n\t\t\t\tbattmgr->error = -ENODATA;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbattmgr->error = le32_to_cpu(resp->intval.result);\n\t\t\tif (battmgr->error)\n\t\t\t\tgoto out_complete;\n\t\t}\n\n\t\tswitch (property) {\n\t\tcase BATT_STATUS:\n\t\t\tbattmgr->status.status = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_HEALTH:\n\t\t\tbattmgr->status.health = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_PRESENT:\n\t\t\tbattmgr->info.present = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CHG_TYPE:\n\t\t\tbattmgr->info.charge_type = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CAPACITY:\n\t\t\tbattmgr->status.percent = le32_to_cpu(resp->intval.value) / 100;\n\t\t\tbreak;\n\t\tcase BATT_VOLT_OCV:\n\t\t\tbattmgr->status.voltage_ocv = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_VOLT_NOW:\n\t\t\tbattmgr->status.voltage_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_VOLT_MAX:\n\t\t\tbattmgr->info.voltage_max = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CURR_NOW:\n\t\t\tbattmgr->status.current_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_TEMP:\n\t\t\tval = le32_to_cpu(resp->intval.value);\n\t\t\tbattmgr->status.temperature = DIV_ROUND_CLOSEST(val, 10);\n\t\t\tbreak;\n\t\tcase BATT_TECHNOLOGY:\n\t\t\tbattmgr->info.technology = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CHG_COUNTER:\n\t\t\tbattmgr->info.charge_count = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CYCLE_COUNT:\n\t\t\tbattmgr->info.cycle_count = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CHG_FULL_DESIGN:\n\t\t\tbattmgr->info.design_capacity = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_CHG_FULL:\n\t\t\tbattmgr->info.last_full_capacity = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_MODEL_NAME:\n\t\t\tstrscpy(battmgr->info.model_number, resp->strval.model, BATTMGR_STRING_LEN);\n\t\t\tbreak;\n\t\tcase BATT_TTF_AVG:\n\t\t\tbattmgr->status.charge_time = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_TTE_AVG:\n\t\t\tbattmgr->status.discharge_time = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase BATT_POWER_NOW:\n\t\t\tbattmgr->status.power_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(battmgr->dev, \"unknown property %#x\\n\", property);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BATTMGR_USB_PROPERTY_GET:\n\t\tproperty = le32_to_cpu(resp->intval.property);\n\t\tif (payload_len != sizeof(resp->intval)) {\n\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t \"invalid payload length for %#x request: %zd\\n\",\n\t\t\t\t property, payload_len);\n\t\t\tbattmgr->error = -ENODATA;\n\t\t\treturn;\n\t\t}\n\n\t\tbattmgr->error = le32_to_cpu(resp->intval.result);\n\t\tif (battmgr->error)\n\t\t\tgoto out_complete;\n\n\t\tswitch (property) {\n\t\tcase USB_ONLINE:\n\t\t\tbattmgr->usb.online = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_VOLT_NOW:\n\t\t\tbattmgr->usb.voltage_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_VOLT_MAX:\n\t\t\tbattmgr->usb.voltage_max = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_CURR_NOW:\n\t\t\tbattmgr->usb.current_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_CURR_MAX:\n\t\t\tbattmgr->usb.current_max = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_INPUT_CURR_LIMIT:\n\t\t\tbattmgr->usb.current_limit = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase USB_TYPE:\n\t\t\tbattmgr->usb.usb_type = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(battmgr->dev, \"unknown property %#x\\n\", property);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BATTMGR_WLS_PROPERTY_GET:\n\t\tproperty = le32_to_cpu(resp->intval.property);\n\t\tif (payload_len != sizeof(resp->intval)) {\n\t\t\tdev_warn(battmgr->dev,\n\t\t\t\t \"invalid payload length for %#x request: %zd\\n\",\n\t\t\t\t property, payload_len);\n\t\t\tbattmgr->error = -ENODATA;\n\t\t\treturn;\n\t\t}\n\n\t\tbattmgr->error = le32_to_cpu(resp->intval.result);\n\t\tif (battmgr->error)\n\t\t\tgoto out_complete;\n\n\t\tswitch (property) {\n\t\tcase WLS_ONLINE:\n\t\t\tbattmgr->wireless.online = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase WLS_VOLT_NOW:\n\t\t\tbattmgr->wireless.voltage_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase WLS_VOLT_MAX:\n\t\t\tbattmgr->wireless.voltage_max = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase WLS_CURR_NOW:\n\t\t\tbattmgr->wireless.current_now = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tcase WLS_CURR_MAX:\n\t\t\tbattmgr->wireless.current_max = le32_to_cpu(resp->intval.value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(battmgr->dev, \"unknown property %#x\\n\", property);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BATTMGR_REQUEST_NOTIFICATION:\n\t\tbattmgr->error = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(battmgr->dev, \"unknown message %#x\\n\", opcode);\n\t\tbreak;\n\t}\n\nout_complete:\n\tcomplete(&battmgr->ack);\n}\n\nstatic void qcom_battmgr_callback(const void *data, size_t len, void *priv)\n{\n\tconst struct pmic_glink_hdr *hdr = data;\n\tstruct qcom_battmgr *battmgr = priv;\n\tunsigned int opcode = le32_to_cpu(hdr->opcode);\n\n\tif (opcode == BATTMGR_NOTIFICATION)\n\t\tqcom_battmgr_notification(battmgr, data, len);\n\telse if (battmgr->variant == QCOM_BATTMGR_SC8280XP)\n\t\tqcom_battmgr_sc8280xp_callback(battmgr, data, len);\n\telse\n\t\tqcom_battmgr_sm8350_callback(battmgr, data, len);\n}\n\nstatic void qcom_battmgr_enable_worker(struct work_struct *work)\n{\n\tstruct qcom_battmgr *battmgr = container_of(work, struct qcom_battmgr, enable_work);\n\tstruct qcom_battmgr_enable_request req = {\n\t\t.hdr.owner = cpu_to_le32(PMIC_GLINK_OWNER_BATTMGR),\n\t\t.hdr.type = cpu_to_le32(PMIC_GLINK_NOTIFY),\n\t\t.hdr.opcode = cpu_to_le32(BATTMGR_REQUEST_NOTIFICATION),\n\t};\n\tint ret;\n\n\tret = qcom_battmgr_request(battmgr, &req, sizeof(req));\n\tif (ret)\n\t\tdev_err(battmgr->dev, \"failed to request power notifications\\n\");\n}\n\nstatic void qcom_battmgr_pdr_notify(void *priv, int state)\n{\n\tstruct qcom_battmgr *battmgr = priv;\n\n\tif (state == SERVREG_SERVICE_STATE_UP) {\n\t\tbattmgr->service_up = true;\n\t\tschedule_work(&battmgr->enable_work);\n\t} else {\n\t\tbattmgr->service_up = false;\n\t}\n}\n\nstatic const struct of_device_id qcom_battmgr_of_variants[] = {\n\t{ .compatible = \"qcom,sc8180x-pmic-glink\", .data = (void *)QCOM_BATTMGR_SC8280XP },\n\t{ .compatible = \"qcom,sc8280xp-pmic-glink\", .data = (void *)QCOM_BATTMGR_SC8280XP },\n\t \n\t{}\n};\n\nstatic char *qcom_battmgr_battery[] = { \"battery\" };\n\nstatic int qcom_battmgr_probe(struct auxiliary_device *adev,\n\t\t\t      const struct auxiliary_device_id *id)\n{\n\tstruct power_supply_config psy_cfg_supply = {};\n\tstruct power_supply_config psy_cfg = {};\n\tconst struct of_device_id *match;\n\tstruct qcom_battmgr *battmgr;\n\tstruct device *dev = &adev->dev;\n\n\tbattmgr = devm_kzalloc(dev, sizeof(*battmgr), GFP_KERNEL);\n\tif (!battmgr)\n\t\treturn -ENOMEM;\n\n\tbattmgr->dev = dev;\n\n\tpsy_cfg.drv_data = battmgr;\n\tpsy_cfg.of_node = adev->dev.of_node;\n\n\tpsy_cfg_supply.drv_data = battmgr;\n\tpsy_cfg_supply.of_node = adev->dev.of_node;\n\tpsy_cfg_supply.supplied_to = qcom_battmgr_battery;\n\tpsy_cfg_supply.num_supplicants = 1;\n\n\tINIT_WORK(&battmgr->enable_work, qcom_battmgr_enable_worker);\n\tmutex_init(&battmgr->lock);\n\tinit_completion(&battmgr->ack);\n\n\tmatch = of_match_device(qcom_battmgr_of_variants, dev->parent);\n\tif (match)\n\t\tbattmgr->variant = (unsigned long)match->data;\n\telse\n\t\tbattmgr->variant = QCOM_BATTMGR_SM8350;\n\n\tif (battmgr->variant == QCOM_BATTMGR_SC8280XP) {\n\t\tbattmgr->bat_psy = devm_power_supply_register(dev, &sc8280xp_bat_psy_desc, &psy_cfg);\n\t\tif (IS_ERR(battmgr->bat_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->bat_psy),\n\t\t\t\t\t     \"failed to register battery power supply\\n\");\n\n\t\tbattmgr->ac_psy = devm_power_supply_register(dev, &sc8280xp_ac_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->ac_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->ac_psy),\n\t\t\t\t\t     \"failed to register AC power supply\\n\");\n\n\t\tbattmgr->usb_psy = devm_power_supply_register(dev, &sc8280xp_usb_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->usb_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->usb_psy),\n\t\t\t\t\t     \"failed to register USB power supply\\n\");\n\n\t\tbattmgr->wls_psy = devm_power_supply_register(dev, &sc8280xp_wls_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->wls_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->wls_psy),\n\t\t\t\t\t     \"failed to register wireless charing power supply\\n\");\n\t} else {\n\t\tbattmgr->bat_psy = devm_power_supply_register(dev, &sm8350_bat_psy_desc, &psy_cfg);\n\t\tif (IS_ERR(battmgr->bat_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->bat_psy),\n\t\t\t\t\t     \"failed to register battery power supply\\n\");\n\n\t\tbattmgr->usb_psy = devm_power_supply_register(dev, &sm8350_usb_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->usb_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->usb_psy),\n\t\t\t\t\t     \"failed to register USB power supply\\n\");\n\n\t\tbattmgr->wls_psy = devm_power_supply_register(dev, &sm8350_wls_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->wls_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->wls_psy),\n\t\t\t\t\t     \"failed to register wireless charing power supply\\n\");\n\t}\n\n\tbattmgr->client = devm_pmic_glink_register_client(dev,\n\t\t\t\t\t\t\t  PMIC_GLINK_OWNER_BATTMGR,\n\t\t\t\t\t\t\t  qcom_battmgr_callback,\n\t\t\t\t\t\t\t  qcom_battmgr_pdr_notify,\n\t\t\t\t\t\t\t  battmgr);\n\treturn PTR_ERR_OR_ZERO(battmgr->client);\n}\n\nstatic const struct auxiliary_device_id qcom_battmgr_id_table[] = {\n\t{ .name = \"pmic_glink.power-supply\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, qcom_battmgr_id_table);\n\nstatic struct auxiliary_driver qcom_battmgr_driver = {\n\t.name = \"pmic_glink_power_supply\",\n\t.probe = qcom_battmgr_probe,\n\t.id_table = qcom_battmgr_id_table,\n};\n\nmodule_auxiliary_driver(qcom_battmgr_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC GLINK battery manager driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}