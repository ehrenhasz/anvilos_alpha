{
  "module_name": "sc27xx_fuel_gauge.c",
  "hash_id": "53e8327c98a704b15ee926567c07256649bc5413785c3ac4ba0406d4114b3651",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/sc27xx_fuel_gauge.c",
  "human_readable_source": "\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/iio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define SC27XX_MODULE_EN0\t\t0xc08\n#define SC27XX_CLK_EN0\t\t\t0xc18\n#define SC27XX_FGU_EN\t\t\tBIT(7)\n#define SC27XX_FGU_RTC_EN\t\tBIT(6)\n\n \n#define SC27XX_FGU_START\t\t0x0\n#define SC27XX_FGU_CONFIG\t\t0x4\n#define SC27XX_FGU_ADC_CONFIG\t\t0x8\n#define SC27XX_FGU_STATUS\t\t0xc\n#define SC27XX_FGU_INT_EN\t\t0x10\n#define SC27XX_FGU_INT_CLR\t\t0x14\n#define SC27XX_FGU_INT_STS\t\t0x1c\n#define SC27XX_FGU_VOLTAGE\t\t0x20\n#define SC27XX_FGU_OCV\t\t\t0x24\n#define SC27XX_FGU_POCV\t\t\t0x28\n#define SC27XX_FGU_CURRENT\t\t0x2c\n#define SC27XX_FGU_LOW_OVERLOAD\t\t0x34\n#define SC27XX_FGU_CLBCNT_SETH\t\t0x50\n#define SC27XX_FGU_CLBCNT_SETL\t\t0x54\n#define SC27XX_FGU_CLBCNT_DELTH\t\t0x58\n#define SC27XX_FGU_CLBCNT_DELTL\t\t0x5c\n#define SC27XX_FGU_CLBCNT_VALH\t\t0x68\n#define SC27XX_FGU_CLBCNT_VALL\t\t0x6c\n#define SC27XX_FGU_CLBCNT_QMAXL\t\t0x74\n#define SC27XX_FGU_USER_AREA_SET\t0xa0\n#define SC27XX_FGU_USER_AREA_CLEAR\t0xa4\n#define SC27XX_FGU_USER_AREA_STATUS\t0xa8\n#define SC27XX_FGU_VOLTAGE_BUF\t\t0xd0\n#define SC27XX_FGU_CURRENT_BUF\t\t0xf0\n\n#define SC27XX_WRITE_SELCLB_EN\t\tBIT(0)\n#define SC27XX_FGU_CLBCNT_MASK\t\tGENMASK(15, 0)\n#define SC27XX_FGU_CLBCNT_SHIFT\t\t16\n#define SC27XX_FGU_LOW_OVERLOAD_MASK\tGENMASK(12, 0)\n\n#define SC27XX_FGU_INT_MASK\t\tGENMASK(9, 0)\n#define SC27XX_FGU_LOW_OVERLOAD_INT\tBIT(0)\n#define SC27XX_FGU_CLBCNT_DELTA_INT\tBIT(2)\n\n#define SC27XX_FGU_MODE_AREA_MASK\tGENMASK(15, 12)\n#define SC27XX_FGU_CAP_AREA_MASK\tGENMASK(11, 0)\n#define SC27XX_FGU_MODE_AREA_SHIFT\t12\n\n#define SC27XX_FGU_FIRST_POWERTON\tGENMASK(3, 0)\n#define SC27XX_FGU_DEFAULT_CAP\t\tGENMASK(11, 0)\n#define SC27XX_FGU_NORMAIL_POWERTON\t0x5\n\n#define SC27XX_FGU_CUR_BASIC_ADC\t8192\n#define SC27XX_FGU_SAMPLE_HZ\t\t2\n \n#define SC27XX_FGU_IDEAL_RESISTANCE\t20000\n\n \nstruct sc27xx_fgu_data {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct power_supply *battery;\n\tu32 base;\n\tstruct mutex lock;\n\tstruct gpio_desc *gpiod;\n\tstruct iio_channel *channel;\n\tstruct iio_channel *charge_chan;\n\tbool bat_present;\n\tint internal_resist;\n\tint total_cap;\n\tint init_cap;\n\tint alarm_cap;\n\tint init_clbcnt;\n\tint max_volt;\n\tint min_volt;\n\tint boot_volt;\n\tint table_len;\n\tint resist_table_len;\n\tint cur_1000ma_adc;\n\tint vol_1000mv_adc;\n\tint calib_resist;\n\tstruct power_supply_battery_ocv_table *cap_table;\n\tstruct power_supply_resistance_temp_table *resist_table;\n};\n\nstatic int sc27xx_fgu_cap_to_clbcnt(struct sc27xx_fgu_data *data, int capacity);\nstatic void sc27xx_fgu_capacity_calibration(struct sc27xx_fgu_data *data,\n\t\t\t\t\t    int cap, bool int_mode);\nstatic void sc27xx_fgu_adjust_cap(struct sc27xx_fgu_data *data, int cap);\nstatic int sc27xx_fgu_get_temp(struct sc27xx_fgu_data *data, int *temp);\n\nstatic const char * const sc27xx_charger_supply_name[] = {\n\t\"sc2731_charger\",\n\t\"sc2720_charger\",\n\t\"sc2721_charger\",\n\t\"sc2723_charger\",\n};\n\nstatic int sc27xx_fgu_adc_to_current(struct sc27xx_fgu_data *data, s64 adc)\n{\n\treturn DIV_S64_ROUND_CLOSEST(adc * 1000, data->cur_1000ma_adc);\n}\n\nstatic int sc27xx_fgu_adc_to_voltage(struct sc27xx_fgu_data *data, s64 adc)\n{\n\treturn DIV_S64_ROUND_CLOSEST(adc * 1000, data->vol_1000mv_adc);\n}\n\nstatic int sc27xx_fgu_voltage_to_adc(struct sc27xx_fgu_data *data, int vol)\n{\n\treturn DIV_ROUND_CLOSEST(vol * data->vol_1000mv_adc, 1000);\n}\n\nstatic bool sc27xx_fgu_is_first_poweron(struct sc27xx_fgu_data *data)\n{\n\tint ret, status, cap, mode;\n\n\tret = regmap_read(data->regmap,\n\t\t\t  data->base + SC27XX_FGU_USER_AREA_STATUS, &status);\n\tif (ret)\n\t\treturn false;\n\n\t \n\tmode = (status & SC27XX_FGU_MODE_AREA_MASK) >> SC27XX_FGU_MODE_AREA_SHIFT;\n\tcap = status & SC27XX_FGU_CAP_AREA_MASK;\n\n\t \n\tif (mode == SC27XX_FGU_FIRST_POWERTON || cap == SC27XX_FGU_DEFAULT_CAP)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sc27xx_fgu_save_boot_mode(struct sc27xx_fgu_data *data,\n\t\t\t\t     int boot_mode)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_USER_AREA_CLEAR,\n\t\t\t\t SC27XX_FGU_MODE_AREA_MASK,\n\t\t\t\t SC27XX_FGU_MODE_AREA_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(200);\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_USER_AREA_SET,\n\t\t\t\t SC27XX_FGU_MODE_AREA_MASK,\n\t\t\t\t boot_mode << SC27XX_FGU_MODE_AREA_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(200);\n\n\t \n\treturn regmap_update_bits(data->regmap,\n\t\t\t\t  data->base + SC27XX_FGU_USER_AREA_CLEAR,\n\t\t\t\t  SC27XX_FGU_MODE_AREA_MASK, 0);\n}\n\nstatic int sc27xx_fgu_save_last_cap(struct sc27xx_fgu_data *data, int cap)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_USER_AREA_CLEAR,\n\t\t\t\t SC27XX_FGU_CAP_AREA_MASK,\n\t\t\t\t SC27XX_FGU_CAP_AREA_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(200);\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_USER_AREA_SET,\n\t\t\t\t SC27XX_FGU_CAP_AREA_MASK, cap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(200);\n\n\t \n\treturn regmap_update_bits(data->regmap,\n\t\t\t\t  data->base + SC27XX_FGU_USER_AREA_CLEAR,\n\t\t\t\t  SC27XX_FGU_CAP_AREA_MASK, 0);\n}\n\nstatic int sc27xx_fgu_read_last_cap(struct sc27xx_fgu_data *data, int *cap)\n{\n\tint ret, value;\n\n\tret = regmap_read(data->regmap,\n\t\t\t  data->base + SC27XX_FGU_USER_AREA_STATUS, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t*cap = value & SC27XX_FGU_CAP_AREA_MASK;\n\treturn 0;\n}\n\n \nstatic int sc27xx_fgu_get_boot_capacity(struct sc27xx_fgu_data *data, int *cap)\n{\n\tint volt, cur, oci, ocv, ret;\n\tbool is_first_poweron = sc27xx_fgu_is_first_poweron(data);\n\n\t \n\tif (!is_first_poweron) {\n\t\tret = sc27xx_fgu_read_last_cap(data, cap);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn sc27xx_fgu_save_boot_mode(data, SC27XX_FGU_NORMAIL_POWERTON);\n\t}\n\n\t \n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_CLBCNT_QMAXL,\n\t\t\t  &cur);\n\tif (ret)\n\t\treturn ret;\n\n\tcur <<= 1;\n\toci = sc27xx_fgu_adc_to_current(data, cur - SC27XX_FGU_CUR_BASIC_ADC);\n\n\t \n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_POCV, &volt);\n\tif (ret)\n\t\treturn ret;\n\n\tvolt = sc27xx_fgu_adc_to_voltage(data, volt);\n\tocv = volt * 1000 - oci * data->internal_resist;\n\tdata->boot_volt = ocv;\n\n\t \n\t*cap = power_supply_ocv2cap_simple(data->cap_table, data->table_len,\n\t\t\t\t\t   ocv);\n\n\tret = sc27xx_fgu_save_last_cap(data, *cap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sc27xx_fgu_save_boot_mode(data, SC27XX_FGU_NORMAIL_POWERTON);\n}\n\nstatic int sc27xx_fgu_set_clbcnt(struct sc27xx_fgu_data *data, int clbcnt)\n{\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_CLBCNT_SETL,\n\t\t\t\t SC27XX_FGU_CLBCNT_MASK, clbcnt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(data->regmap,\n\t\t\t\t data->base + SC27XX_FGU_CLBCNT_SETH,\n\t\t\t\t SC27XX_FGU_CLBCNT_MASK,\n\t\t\t\t clbcnt >> SC27XX_FGU_CLBCNT_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(data->regmap, data->base + SC27XX_FGU_START,\n\t\t\t\t SC27XX_WRITE_SELCLB_EN,\n\t\t\t\t SC27XX_WRITE_SELCLB_EN);\n}\n\nstatic int sc27xx_fgu_get_clbcnt(struct sc27xx_fgu_data *data, int *clb_cnt)\n{\n\tint ccl, cch, ret;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_CLBCNT_VALL,\n\t\t\t  &ccl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_CLBCNT_VALH,\n\t\t\t  &cch);\n\tif (ret)\n\t\treturn ret;\n\n\t*clb_cnt = ccl & SC27XX_FGU_CLBCNT_MASK;\n\t*clb_cnt |= (cch & SC27XX_FGU_CLBCNT_MASK) << SC27XX_FGU_CLBCNT_SHIFT;\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_vol_now(struct sc27xx_fgu_data *data, int *val)\n{\n\tint ret;\n\tu32 vol;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_VOLTAGE_BUF,\n\t\t\t  &vol);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = sc27xx_fgu_adc_to_voltage(data, vol);\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_cur_now(struct sc27xx_fgu_data *data, int *val)\n{\n\tint ret;\n\tu32 cur;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_CURRENT_BUF,\n\t\t\t  &cur);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = sc27xx_fgu_adc_to_current(data, cur - SC27XX_FGU_CUR_BASIC_ADC);\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_capacity(struct sc27xx_fgu_data *data, int *cap)\n{\n\tint ret, cur_clbcnt, delta_clbcnt, delta_cap, temp;\n\n\t \n\tret = sc27xx_fgu_get_clbcnt(data, &cur_clbcnt);\n\tif (ret)\n\t\treturn ret;\n\n\tdelta_clbcnt = cur_clbcnt - data->init_clbcnt;\n\n\t \n\ttemp = DIV_ROUND_CLOSEST(delta_clbcnt * 10, 36 * SC27XX_FGU_SAMPLE_HZ);\n\ttemp = sc27xx_fgu_adc_to_current(data, temp / 1000);\n\n\t \n\tdelta_cap = DIV_ROUND_CLOSEST(temp * 100, data->total_cap);\n\t*cap = delta_cap + data->init_cap;\n\n\t \n\tsc27xx_fgu_capacity_calibration(data, *cap, false);\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_vbat_vol(struct sc27xx_fgu_data *data, int *val)\n{\n\tint ret, vol;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_VOLTAGE, &vol);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = sc27xx_fgu_adc_to_voltage(data, vol);\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_current(struct sc27xx_fgu_data *data, int *val)\n{\n\tint ret, cur;\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_CURRENT, &cur);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = sc27xx_fgu_adc_to_current(data, cur - SC27XX_FGU_CUR_BASIC_ADC);\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_vbat_ocv(struct sc27xx_fgu_data *data, int *val)\n{\n\tint vol, cur, ret, temp, resistance;\n\n\tret = sc27xx_fgu_get_vbat_vol(data, &vol);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sc27xx_fgu_get_current(data, &cur);\n\tif (ret)\n\t\treturn ret;\n\n\tresistance = data->internal_resist;\n\tif (data->resist_table_len > 0) {\n\t\tret = sc27xx_fgu_get_temp(data, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tresistance = power_supply_temp2resist_simple(data->resist_table,\n\t\t\t\t\t\tdata->resist_table_len, temp);\n\t\tresistance = data->internal_resist * resistance / 100;\n\t}\n\n\t \n\t*val = vol * 1000 - cur * resistance;\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_charge_vol(struct sc27xx_fgu_data *data, int *val)\n{\n\tint ret, vol;\n\n\tret = iio_read_channel_processed(data->charge_chan, &vol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = vol * 1000;\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_temp(struct sc27xx_fgu_data *data, int *temp)\n{\n\treturn iio_read_channel_processed(data->channel, temp);\n}\n\nstatic int sc27xx_fgu_get_health(struct sc27xx_fgu_data *data, int *health)\n{\n\tint ret, vol;\n\n\tret = sc27xx_fgu_get_vbat_vol(data, &vol);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vol > data->max_volt)\n\t\t*health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\telse\n\t\t*health = POWER_SUPPLY_HEALTH_GOOD;\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_get_status(struct sc27xx_fgu_data *data, int *status)\n{\n\tunion power_supply_propval val;\n\tstruct power_supply *psy;\n\tint i, ret = -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(sc27xx_charger_supply_name); i++) {\n\t\tpsy = power_supply_get_by_name(sc27xx_charger_supply_name[i]);\n\t\tif (!psy)\n\t\t\tcontinue;\n\n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_STATUS,\n\t\t\t\t\t\t&val);\n\t\tpower_supply_put(psy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*status = val.intval;\n\t}\n\n\treturn ret;\n}\n\nstatic int sc27xx_fgu_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct sc27xx_fgu_data *data = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\tint value;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = sc27xx_fgu_get_status(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = sc27xx_fgu_get_health(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = data->bat_present;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = sc27xx_fgu_get_temp(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = sc27xx_fgu_get_capacity(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tret = sc27xx_fgu_get_vbat_vol(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tret = sc27xx_fgu_get_vbat_ocv(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = sc27xx_fgu_get_charge_vol(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tret = sc27xx_fgu_get_current(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tval->intval = data->total_cap * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tret = sc27xx_fgu_get_clbcnt(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tvalue = DIV_ROUND_CLOSEST(value * 10,\n\t\t\t\t\t  36 * SC27XX_FGU_SAMPLE_HZ);\n\t\tval->intval = sc27xx_fgu_adc_to_current(data, value);\n\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = sc27xx_fgu_get_vol_now(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = sc27xx_fgu_get_cur_now(data, &value);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tval->intval = value * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_BOOT:\n\t\tval->intval = data->boot_volt;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerror:\n\tmutex_unlock(&data->lock);\n\treturn ret;\n}\n\nstatic int sc27xx_fgu_set_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tstruct sc27xx_fgu_data *data = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tmutex_lock(&data->lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = sc27xx_fgu_save_last_cap(data, val->intval);\n\t\tif (ret < 0)\n\t\t\tdev_err(data->dev, \"failed to save battery capacity\\n\");\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CALIBRATE:\n\t\tsc27xx_fgu_adjust_cap(data, val->intval);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\n\t\tdata->total_cap = val->intval / 1000;\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\nstatic int sc27xx_fgu_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t    enum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_CAPACITY ||\n\t\tpsp == POWER_SUPPLY_PROP_CALIBRATE ||\n\t\tpsp == POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\n}\n\nstatic enum power_supply_property sc27xx_fgu_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_BOOT,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CALIBRATE,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW\n};\n\nstatic const struct power_supply_desc sc27xx_fgu_desc = {\n\t.name\t\t\t= \"sc27xx-fgu\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= sc27xx_fgu_props,\n\t.num_properties\t\t= ARRAY_SIZE(sc27xx_fgu_props),\n\t.get_property\t\t= sc27xx_fgu_get_property,\n\t.set_property\t\t= sc27xx_fgu_set_property,\n\t.external_power_changed\t= power_supply_changed,\n\t.property_is_writeable\t= sc27xx_fgu_property_is_writeable,\n\t.no_thermal\t\t= true,\n};\n\nstatic void sc27xx_fgu_adjust_cap(struct sc27xx_fgu_data *data, int cap)\n{\n\tint ret;\n\n\tdata->init_cap = cap;\n\tret = sc27xx_fgu_get_clbcnt(data, &data->init_clbcnt);\n\tif (ret)\n\t\tdev_err(data->dev, \"failed to get init coulomb counter\\n\");\n}\n\nstatic void sc27xx_fgu_capacity_calibration(struct sc27xx_fgu_data *data,\n\t\t\t\t\t    int cap, bool int_mode)\n{\n\tint ret, ocv, chg_sts, adc;\n\n\tret = sc27xx_fgu_get_vbat_ocv(data, &ocv);\n\tif (ret) {\n\t\tdev_err(data->dev, \"get battery ocv error.\\n\");\n\t\treturn;\n\t}\n\n\tret = sc27xx_fgu_get_status(data, &chg_sts);\n\tif (ret) {\n\t\tdev_err(data->dev, \"get charger status error.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (chg_sts == POWER_SUPPLY_STATUS_CHARGING)\n\t\treturn;\n\n\tif ((ocv > data->cap_table[0].ocv && cap < 100) || cap > 100) {\n\t\t \n\t\tsc27xx_fgu_adjust_cap(data, 100);\n\t} else if (ocv <= data->cap_table[data->table_len - 1].ocv) {\n\t\t \n\t\tsc27xx_fgu_adjust_cap(data, 0);\n\t} else if ((ocv > data->cap_table[data->table_len - 1].ocv && cap <= 0) ||\n\t\t   (ocv > data->min_volt && cap <= data->alarm_cap)) {\n\t\t \n\t\tint cur_cap = power_supply_ocv2cap_simple(data->cap_table,\n\t\t\t\t\t\t\t  data->table_len, ocv);\n\n\t\tsc27xx_fgu_adjust_cap(data, cur_cap);\n\t} else if (ocv <= data->min_volt) {\n\t\t \n\t\tif (cap > data->alarm_cap) {\n\t\t\tsc27xx_fgu_adjust_cap(data, data->alarm_cap);\n\t\t} else {\n\t\t\tint cur_cap;\n\n\t\t\t \n\t\t\tcur_cap = power_supply_ocv2cap_simple(data->cap_table,\n\t\t\t\t\t\t\t      data->table_len,\n\t\t\t\t\t\t\t      ocv);\n\t\t\tsc27xx_fgu_adjust_cap(data, cur_cap);\n\t\t}\n\n\t\tif (!int_mode)\n\t\t\treturn;\n\n\t\t \n\t\tdata->min_volt = data->cap_table[data->table_len - 1].ocv;\n\t\tdata->alarm_cap = power_supply_ocv2cap_simple(data->cap_table,\n\t\t\t\t\t\t\t      data->table_len,\n\t\t\t\t\t\t\t      data->min_volt);\n\n\t\tadc = sc27xx_fgu_voltage_to_adc(data, data->min_volt / 1000);\n\t\tregmap_update_bits(data->regmap,\n\t\t\t\t   data->base + SC27XX_FGU_LOW_OVERLOAD,\n\t\t\t\t   SC27XX_FGU_LOW_OVERLOAD_MASK, adc);\n\t}\n}\n\nstatic irqreturn_t sc27xx_fgu_interrupt(int irq, void *dev_id)\n{\n\tstruct sc27xx_fgu_data *data = dev_id;\n\tint ret, cap;\n\tu32 status;\n\n\tmutex_lock(&data->lock);\n\n\tret = regmap_read(data->regmap, data->base + SC27XX_FGU_INT_STS,\n\t\t\t  &status);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_INT_CLR,\n\t\t\t\t status, status);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (!(status & SC27XX_FGU_LOW_OVERLOAD_INT))\n\t\tgoto out;\n\n\tret = sc27xx_fgu_get_capacity(data, &cap);\n\tif (ret)\n\t\tgoto out;\n\n\tsc27xx_fgu_capacity_calibration(data, cap, true);\n\nout:\n\tmutex_unlock(&data->lock);\n\n\tpower_supply_changed(data->battery);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sc27xx_fgu_bat_detection(int irq, void *dev_id)\n{\n\tstruct sc27xx_fgu_data *data = dev_id;\n\tint state;\n\n\tmutex_lock(&data->lock);\n\n\tstate = gpiod_get_value_cansleep(data->gpiod);\n\tif (state < 0) {\n\t\tdev_err(data->dev, \"failed to get gpio state\\n\");\n\t\tmutex_unlock(&data->lock);\n\t\treturn IRQ_RETVAL(state);\n\t}\n\n\tdata->bat_present = !!state;\n\n\tmutex_unlock(&data->lock);\n\n\tpower_supply_changed(data->battery);\n\treturn IRQ_HANDLED;\n}\n\nstatic void sc27xx_fgu_disable(void *_data)\n{\n\tstruct sc27xx_fgu_data *data = _data;\n\n\tregmap_update_bits(data->regmap, SC27XX_CLK_EN0, SC27XX_FGU_RTC_EN, 0);\n\tregmap_update_bits(data->regmap, SC27XX_MODULE_EN0, SC27XX_FGU_EN, 0);\n}\n\nstatic int sc27xx_fgu_cap_to_clbcnt(struct sc27xx_fgu_data *data, int capacity)\n{\n\t \n\tint cur_cap = DIV_ROUND_CLOSEST(data->total_cap * capacity, 100);\n\n\t \n\treturn DIV_ROUND_CLOSEST(cur_cap * 36 * data->cur_1000ma_adc * SC27XX_FGU_SAMPLE_HZ, 10);\n}\n\nstatic int sc27xx_fgu_calibration(struct sc27xx_fgu_data *data)\n{\n\tstruct nvmem_cell *cell;\n\tint calib_data, cal_4200mv;\n\tvoid *buf;\n\tsize_t len;\n\n\tcell = nvmem_cell_get(data->dev, \"fgu_calib\");\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmemcpy(&calib_data, buf, min(len, sizeof(u32)));\n\n\t \n\tcal_4200mv = (calib_data & 0x1ff) + 6963 - 4096 - 256;\n\tdata->vol_1000mv_adc = DIV_ROUND_CLOSEST(cal_4200mv * 10, 42);\n\tdata->cur_1000ma_adc =\n\t\tDIV_ROUND_CLOSEST(data->vol_1000mv_adc * 4 * data->calib_resist,\n\t\t\t\t  SC27XX_FGU_IDEAL_RESISTANCE);\n\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_hw_init(struct sc27xx_fgu_data *data)\n{\n\tstruct power_supply_battery_info *info;\n\tstruct power_supply_battery_ocv_table *table;\n\tint ret, delta_clbcnt, alarm_adc;\n\n\tret = power_supply_get_battery_info(data->battery, &info);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to get battery information\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->total_cap = info->charge_full_design_uah / 1000;\n\tdata->max_volt = info->constant_charge_voltage_max_uv / 1000;\n\tdata->internal_resist = info->factory_internal_resistance_uohm / 1000;\n\tdata->min_volt = info->voltage_min_design_uv;\n\n\t \n\ttable = power_supply_find_ocv2cap_table(info, 20, &data->table_len);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tdata->cap_table = devm_kmemdup(data->dev, table,\n\t\t\t\t       data->table_len * sizeof(*table),\n\t\t\t\t       GFP_KERNEL);\n\tif (!data->cap_table) {\n\t\tpower_supply_put_battery_info(data->battery, info);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->alarm_cap = power_supply_ocv2cap_simple(data->cap_table,\n\t\t\t\t\t\t      data->table_len,\n\t\t\t\t\t\t      data->min_volt);\n\tif (!data->alarm_cap)\n\t\tdata->alarm_cap += 1;\n\n\tdata->resist_table_len = info->resist_table_size;\n\tif (data->resist_table_len > 0) {\n\t\tdata->resist_table = devm_kmemdup(data->dev, info->resist_table,\n\t\t\t\t\t\t  data->resist_table_len *\n\t\t\t\t\t\t  sizeof(struct power_supply_resistance_temp_table),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!data->resist_table) {\n\t\t\tpower_supply_put_battery_info(data->battery, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tpower_supply_put_battery_info(data->battery, info);\n\n\tret = sc27xx_fgu_calibration(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(data->regmap, SC27XX_MODULE_EN0,\n\t\t\t\t SC27XX_FGU_EN, SC27XX_FGU_EN);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to enable fgu\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(data->regmap, SC27XX_CLK_EN0,\n\t\t\t\t SC27XX_FGU_RTC_EN, SC27XX_FGU_RTC_EN);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to enable fgu RTC clock\\n\");\n\t\tgoto disable_fgu;\n\t}\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_INT_CLR,\n\t\t\t\t SC27XX_FGU_INT_MASK, SC27XX_FGU_INT_MASK);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to clear interrupt status\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\t \n\talarm_adc = sc27xx_fgu_voltage_to_adc(data, data->min_volt / 1000);\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_LOW_OVERLOAD,\n\t\t\t\t SC27XX_FGU_LOW_OVERLOAD_MASK, alarm_adc);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to set fgu low overload\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tdelta_clbcnt = sc27xx_fgu_cap_to_clbcnt(data, 1);\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_CLBCNT_DELTL,\n\t\t\t\t SC27XX_FGU_CLBCNT_MASK, delta_clbcnt);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to set low delta coulomb counter\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_CLBCNT_DELTH,\n\t\t\t\t SC27XX_FGU_CLBCNT_MASK,\n\t\t\t\t delta_clbcnt >> SC27XX_FGU_CLBCNT_SHIFT);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to set high delta coulomb counter\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tret = sc27xx_fgu_get_boot_capacity(data, &data->init_cap);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to get boot capacity\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tdata->init_clbcnt = sc27xx_fgu_cap_to_clbcnt(data, data->init_cap);\n\tret = sc27xx_fgu_set_clbcnt(data, data->init_clbcnt);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to initialize coulomb counter\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\tregmap_update_bits(data->regmap, SC27XX_CLK_EN0, SC27XX_FGU_RTC_EN, 0);\ndisable_fgu:\n\tregmap_update_bits(data->regmap, SC27XX_MODULE_EN0, SC27XX_FGU_EN, 0);\n\n\treturn ret;\n}\n\nstatic int sc27xx_fgu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct power_supply_config fgu_cfg = { };\n\tstruct sc27xx_fgu_data *data;\n\tint ret, irq;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!data->regmap) {\n\t\tdev_err(dev, \"failed to get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_property_read_u32(dev, \"reg\", &data->base);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get fgu address\\n\");\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(&pdev->dev,\n\t\t\t\t       \"sprd,calib-resistance-micro-ohms\",\n\t\t\t\t       &data->calib_resist);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get fgu calibration resistance\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->channel = devm_iio_channel_get(dev, \"bat-temp\");\n\tif (IS_ERR(data->channel)) {\n\t\tdev_err(dev, \"failed to get IIO channel\\n\");\n\t\treturn PTR_ERR(data->channel);\n\t}\n\n\tdata->charge_chan = devm_iio_channel_get(dev, \"charge-vol\");\n\tif (IS_ERR(data->charge_chan)) {\n\t\tdev_err(dev, \"failed to get charge IIO channel\\n\");\n\t\treturn PTR_ERR(data->charge_chan);\n\t}\n\n\tdata->gpiod = devm_gpiod_get(dev, \"bat-detect\", GPIOD_IN);\n\tif (IS_ERR(data->gpiod)) {\n\t\tdev_err(dev, \"failed to get battery detection GPIO\\n\");\n\t\treturn PTR_ERR(data->gpiod);\n\t}\n\n\tret = gpiod_get_value_cansleep(data->gpiod);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get gpio state\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->bat_present = !!ret;\n\tmutex_init(&data->lock);\n\tdata->dev = dev;\n\tplatform_set_drvdata(pdev, data);\n\n\tfgu_cfg.drv_data = data;\n\tfgu_cfg.of_node = np;\n\tdata->battery = devm_power_supply_register(dev, &sc27xx_fgu_desc,\n\t\t\t\t\t\t   &fgu_cfg);\n\tif (IS_ERR(data->battery)) {\n\t\tdev_err(dev, \"failed to register power supply\\n\");\n\t\treturn PTR_ERR(data->battery);\n\t}\n\n\tret = sc27xx_fgu_hw_init(data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize fgu hardware\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, sc27xx_fgu_disable, data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add fgu disable action\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(data->dev, irq, NULL,\n\t\t\t\t\tsc27xx_fgu_interrupt,\n\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, data);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to request fgu IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = gpiod_to_irq(data->gpiod);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"failed to translate GPIO to IRQ\\n\");\n\t\treturn irq;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\tsc27xx_fgu_bat_detection,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\tpdev->name, data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sc27xx_fgu_resume(struct device *dev)\n{\n\tstruct sc27xx_fgu_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_INT_EN,\n\t\t\t\t SC27XX_FGU_LOW_OVERLOAD_INT |\n\t\t\t\t SC27XX_FGU_CLBCNT_DELTA_INT, 0);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to disable fgu interrupts\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc27xx_fgu_suspend(struct device *dev)\n{\n\tstruct sc27xx_fgu_data *data = dev_get_drvdata(dev);\n\tint ret, status, ocv;\n\n\tret = sc27xx_fgu_get_status(data, &status);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (status != POWER_SUPPLY_STATUS_NOT_CHARGING &&\n\t    status != POWER_SUPPLY_STATUS_DISCHARGING)\n\t\treturn 0;\n\n\tret = regmap_update_bits(data->regmap, data->base + SC27XX_FGU_INT_EN,\n\t\t\t\t SC27XX_FGU_LOW_OVERLOAD_INT,\n\t\t\t\t SC27XX_FGU_LOW_OVERLOAD_INT);\n\tif (ret) {\n\t\tdev_err(data->dev, \"failed to enable low voltage interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sc27xx_fgu_get_vbat_ocv(data, &ocv);\n\tif (ret)\n\t\tgoto disable_int;\n\n\t \n\tif (ocv < data->min_volt) {\n\t\tret = regmap_update_bits(data->regmap,\n\t\t\t\t\t data->base + SC27XX_FGU_INT_EN,\n\t\t\t\t\t SC27XX_FGU_CLBCNT_DELTA_INT,\n\t\t\t\t\t SC27XX_FGU_CLBCNT_DELTA_INT);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"failed to enable coulomb threshold int\\n\");\n\t\t\tgoto disable_int;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_int:\n\tregmap_update_bits(data->regmap, data->base + SC27XX_FGU_INT_EN,\n\t\t\t   SC27XX_FGU_LOW_OVERLOAD_INT, 0);\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sc27xx_fgu_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sc27xx_fgu_suspend, sc27xx_fgu_resume)\n};\n\nstatic const struct of_device_id sc27xx_fgu_of_match[] = {\n\t{ .compatible = \"sprd,sc2731-fgu\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sc27xx_fgu_of_match);\n\nstatic struct platform_driver sc27xx_fgu_driver = {\n\t.probe = sc27xx_fgu_probe,\n\t.driver = {\n\t\t.name = \"sc27xx-fgu\",\n\t\t.of_match_table = sc27xx_fgu_of_match,\n\t\t.pm = &sc27xx_fgu_pm_ops,\n\t}\n};\n\nmodule_platform_driver(sc27xx_fgu_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum SC27XX PMICs Fual Gauge Unit Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}