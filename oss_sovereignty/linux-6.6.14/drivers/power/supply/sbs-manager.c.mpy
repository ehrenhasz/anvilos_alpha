{
  "module_name": "sbs-manager.c",
  "hash_id": "d7655f447e5afac09fcddf5b3b2b575f024452798d70d6abe8d356fcadb238d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/sbs-manager.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n\n#define SBSM_MAX_BATS  4\n#define SBSM_RETRY_CNT 3\n\n \n#define SBSM_CMD_BATSYSSTATE     0x01\n#define SBSM_CMD_BATSYSSTATECONT 0x02\n#define SBSM_CMD_BATSYSINFO      0x04\n#define SBSM_CMD_LTC             0x3c\n\n#define SBSM_MASK_BAT_SUPPORTED  GENMASK(3, 0)\n#define SBSM_MASK_CHARGE_BAT     GENMASK(7, 4)\n#define SBSM_BIT_AC_PRESENT      BIT(0)\n#define SBSM_BIT_TURBO           BIT(7)\n\n#define SBSM_SMB_BAT_OFFSET      11\nstruct sbsm_data {\n\tstruct i2c_client *client;\n\tstruct i2c_mux_core *muxc;\n\n\tstruct power_supply *psy;\n\n\tu8 cur_chan;           \n\tstruct gpio_chip chip;\n\tbool is_ltc1760;       \n\n\tunsigned int supported_bats;\n\tunsigned int last_state;\n\tunsigned int last_state_cont;\n};\n\nstatic enum power_supply_property sbsm_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n};\n\nstatic int sbsm_read_word(struct i2c_client *client, u8 address)\n{\n\tint reg, retries;\n\n\tfor (retries = SBSM_RETRY_CNT; retries > 0; retries--) {\n\t\treg = i2c_smbus_read_word_data(client, address);\n\t\tif (reg >= 0)\n\t\t\tbreak;\n\t}\n\n\tif (reg < 0) {\n\t\tdev_err(&client->dev, \"failed to read register 0x%02x\\n\",\n\t\t\taddress);\n\t}\n\n\treturn reg;\n}\n\nstatic int sbsm_write_word(struct i2c_client *client, u8 address, u16 word)\n{\n\tint ret, retries;\n\n\tfor (retries = SBSM_RETRY_CNT; retries > 0; retries--) {\n\t\tret = i2c_smbus_write_word_data(client, address, word);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to write to register 0x%02x\\n\",\n\t\t\taddress);\n\n\treturn ret;\n}\n\nstatic int sbsm_get_property(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     union power_supply_propval *val)\n{\n\tstruct sbsm_data *data = power_supply_get_drvdata(psy);\n\tint regval = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tregval = sbsm_read_word(data->client, SBSM_CMD_BATSYSSTATECONT);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\t\tval->intval = !!(regval & SBSM_BIT_AC_PRESENT);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tregval = sbsm_read_word(data->client, SBSM_CMD_BATSYSSTATE);\n\t\tif (regval < 0)\n\t\t\treturn regval;\n\n\t\tif ((regval & SBSM_MASK_CHARGE_BAT) == 0) {\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\t\treturn 0;\n\t\t}\n\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\n\t\tif (data->is_ltc1760) {\n\t\t\t \n\t\t\tregval = sbsm_read_word(data->client, SBSM_CMD_LTC);\n\t\t\tif (regval < 0)\n\t\t\t\treturn regval;\n\t\t\telse if (regval & SBSM_BIT_TURBO)\n\t\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbsm_prop_is_writeable(struct power_supply *psy,\n\t\t\t\t  enum power_supply_property psp)\n{\n\tstruct sbsm_data *data = power_supply_get_drvdata(psy);\n\n\treturn (psp == POWER_SUPPLY_PROP_CHARGE_TYPE) && data->is_ltc1760;\n}\n\nstatic int sbsm_set_property(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     const union power_supply_propval *val)\n{\n\tstruct sbsm_data *data = power_supply_get_drvdata(psy);\n\tint ret = -EINVAL;\n\tu16 regval;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\t \n\t\tif (!data->is_ltc1760)\n\t\t\tbreak;\n\t\tregval = val->intval ==\n\t\t\t POWER_SUPPLY_CHARGE_TYPE_FAST ? SBSM_BIT_TURBO : 0;\n\t\tret = sbsm_write_word(data->client, SBSM_CMD_LTC, regval);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sbsm_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct sbsm_data *data = i2c_mux_priv(muxc);\n\tstruct device *dev = &data->client->dev;\n\tint ret = 0;\n\tu16 reg;\n\n\tif (data->cur_chan == chan)\n\t\treturn ret;\n\n\t \n\treg = BIT(SBSM_SMB_BAT_OFFSET + chan);\n\tret = sbsm_write_word(data->client, SBSM_CMD_BATSYSSTATE, reg);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to select channel %i\\n\", chan);\n\telse\n\t\tdata->cur_chan = chan;\n\n\treturn ret;\n}\n\nstatic int sbsm_gpio_get_value(struct gpio_chip *gc, unsigned int off)\n{\n\tstruct sbsm_data *data = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = sbsm_read_word(data->client, SBSM_CMD_BATSYSSTATE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret & BIT(off);\n}\n\n \nstatic int sbsm_gpio_direction_input(struct gpio_chip *gc, unsigned int off)\n{\n\treturn 0;\n}\n\nstatic int sbsm_do_alert(struct device *dev, void *d)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tstruct i2c_driver *driver;\n\n\tif (!client || client->addr != 0x0b)\n\t\treturn 0;\n\n\tdevice_lock(dev);\n\tif (client->dev.driver) {\n\t\tdriver = to_i2c_driver(client->dev.driver);\n\t\tif (driver->alert)\n\t\t\tdriver->alert(client, I2C_PROTOCOL_SMBUS_ALERT, 0);\n\t\telse\n\t\t\tdev_warn(&client->dev, \"no driver alert()!\\n\");\n\t} else {\n\t\tdev_dbg(&client->dev, \"alert with no driver\\n\");\n\t}\n\tdevice_unlock(dev);\n\n\treturn -EBUSY;\n}\n\nstatic void sbsm_alert(struct i2c_client *client, enum i2c_alert_protocol prot,\n\t\t       unsigned int d)\n{\n\tstruct sbsm_data *sbsm = i2c_get_clientdata(client);\n\n\tint ret, i, irq_bat = 0, state = 0;\n\n\tret = sbsm_read_word(sbsm->client, SBSM_CMD_BATSYSSTATE);\n\tif (ret >= 0) {\n\t\tirq_bat = ret ^ sbsm->last_state;\n\t\tsbsm->last_state = ret;\n\t\tstate = ret;\n\t}\n\n\tret = sbsm_read_word(sbsm->client, SBSM_CMD_BATSYSSTATECONT);\n\tif ((ret >= 0) &&\n\t    ((ret ^ sbsm->last_state_cont) & SBSM_BIT_AC_PRESENT)) {\n\t\tirq_bat |= sbsm->supported_bats & state;\n\t\tpower_supply_changed(sbsm->psy);\n\t}\n\tsbsm->last_state_cont = ret;\n\n\tfor (i = 0; i < SBSM_MAX_BATS; i++) {\n\t\tif (irq_bat & BIT(i)) {\n\t\t\tdevice_for_each_child(&sbsm->muxc->adapter[i]->dev,\n\t\t\t\t\t      NULL, sbsm_do_alert);\n\t\t}\n\t}\n}\n\nstatic int sbsm_gpio_setup(struct sbsm_data *data)\n{\n\tstruct gpio_chip *gc = &data->chip;\n\tstruct i2c_client *client = data->client;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tif (!device_property_present(dev, \"gpio-controller\"))\n\t\treturn 0;\n\n\tret  = sbsm_read_word(client, SBSM_CMD_BATSYSSTATE);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->last_state = ret;\n\n\tret  = sbsm_read_word(client, SBSM_CMD_BATSYSSTATECONT);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->last_state_cont = ret;\n\n\tgc->get = sbsm_gpio_get_value;\n\tgc->direction_input  = sbsm_gpio_direction_input;\n\tgc->can_sleep = true;\n\tgc->base = -1;\n\tgc->ngpio = SBSM_MAX_BATS;\n\tgc->label = client->name;\n\tgc->parent = dev;\n\tgc->owner = THIS_MODULE;\n\n\tret = devm_gpiochip_add_data(dev, gc, data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"devm_gpiochip_add_data failed\\n\");\n\n\treturn ret;\n}\n\nstatic const struct power_supply_desc sbsm_default_psy_desc = {\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = sbsm_props,\n\t.num_properties = ARRAY_SIZE(sbsm_props),\n\t.get_property = &sbsm_get_property,\n\t.set_property = &sbsm_set_property,\n\t.property_is_writeable = &sbsm_prop_is_writeable,\n};\n\nstatic void sbsm_del_mux_adapter(void *data)\n{\n\tstruct sbsm_data *sbsm = data;\n\ti2c_mux_del_adapters(sbsm->muxc);\n}\n\nstatic int sbsm_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct sbsm_data *data;\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_desc *psy_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tint ret = 0, i;\n\n\t \n\tif (client->addr != 0x0a)\n\t\treturn -EINVAL;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -EPFNOSUPPORT;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\n\tdata->client = client;\n\tdata->is_ltc1760 = !!strstr(id->name, \"ltc1760\");\n\n\tret  = sbsm_read_word(client, SBSM_CMD_BATSYSINFO);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata->supported_bats = ret & SBSM_MASK_BAT_SUPPORTED;\n\tdata->muxc = i2c_mux_alloc(adapter, dev, SBSM_MAX_BATS, 0,\n\t\t\t\t   I2C_MUX_LOCKED, &sbsm_select, NULL);\n\tif (!data->muxc)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"failed to alloc i2c mux\\n\");\n\tdata->muxc->priv = data;\n\n\tret = devm_add_action_or_reset(dev, sbsm_del_mux_adapter, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < SBSM_MAX_BATS; ++i) {\n\t\tif (data->supported_bats & BIT(i)) {\n\t\t\tret = i2c_mux_add_adapter(data->muxc, 0, i + 1, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to register i2c mux channel %d\\n\", i + 1);\n\n\tpsy_desc = devm_kmemdup(dev, &sbsm_default_psy_desc, sizeof(*psy_desc), GFP_KERNEL);\n\tif (!psy_desc)\n\t\treturn -ENOMEM;\n\n\tpsy_desc->name = devm_kasprintf(dev, GFP_KERNEL, \"sbsm-%s\", dev_name(&client->dev));\n\tif (!psy_desc->name)\n\t\treturn -ENOMEM;\n\n\tret = sbsm_gpio_setup(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpsy_cfg.drv_data = data;\n\tpsy_cfg.of_node = dev->of_node;\n\tdata->psy = devm_power_supply_register(dev, psy_desc, &psy_cfg);\n\tif (IS_ERR(data->psy))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->psy),\n\t\t\t\t     \"failed to register power supply %s\\n\", psy_desc->name);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id sbsm_ids[] = {\n\t{ \"sbs-manager\", 0 },\n\t{ \"ltc1760\",     0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sbsm_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sbsm_dt_ids[] = {\n\t{ .compatible = \"sbs,sbs-manager\" },\n\t{ .compatible = \"lltc,ltc1760\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sbsm_dt_ids);\n#endif\n\nstatic struct i2c_driver sbsm_driver = {\n\t.driver = {\n\t\t.name = \"sbsm\",\n\t\t.of_match_table = of_match_ptr(sbsm_dt_ids),\n\t},\n\t.probe\t\t= sbsm_probe,\n\t.alert\t\t= sbsm_alert,\n\t.id_table\t= sbsm_ids\n};\nmodule_i2c_driver(sbsm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Karl-Heinz Schneider <karl-heinz@schneider-inet.de>\");\nMODULE_DESCRIPTION(\"SBSM Smart Battery System Manager\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}