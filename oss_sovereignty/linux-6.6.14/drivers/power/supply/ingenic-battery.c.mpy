{
  "module_name": "ingenic-battery.c",
  "hash_id": "a49c58d255abf89498fdb3b6ba378238d38fb3b280e922b36cc0668ee99bc52d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ingenic-battery.c",
  "human_readable_source": "\n \n\n#include <linux/iio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n\nstruct ingenic_battery {\n\tstruct device *dev;\n\tstruct iio_channel *channel;\n\tstruct power_supply_desc desc;\n\tstruct power_supply *battery;\n\tstruct power_supply_battery_info *info;\n};\n\nstatic int ingenic_battery_get_property(struct power_supply *psy,\n\t\t\t\t\tenum power_supply_property psp,\n\t\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct ingenic_battery *bat = power_supply_get_drvdata(psy);\n\tstruct power_supply_battery_info *info = bat->info;\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = iio_read_channel_processed(bat->channel, &val->intval);\n\t\tval->intval *= 1000;\n\t\tif (val->intval < info->voltage_min_design_uv)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_DEAD;\n\t\telse if (val->intval > info->voltage_max_design_uv)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\treturn ret;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = iio_read_channel_processed(bat->channel, &val->intval);\n\t\tval->intval *= 1000;\n\t\treturn ret;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tval->intval = info->voltage_min_design_uv;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = info->voltage_max_design_uv;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int ingenic_battery_set_scale(struct ingenic_battery *bat)\n{\n\tconst int *scale_raw;\n\tint scale_len, scale_type, best_idx = -1, best_mV, max_raw, i, ret;\n\tu64 max_mV;\n\n\tret = iio_read_max_channel_raw(bat->channel, &max_raw);\n\tif (ret) {\n\t\tdev_err(bat->dev, \"Unable to read max raw channel value\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iio_read_avail_channel_attribute(bat->channel, &scale_raw,\n\t\t\t\t\t       &scale_type, &scale_len,\n\t\t\t\t\t       IIO_CHAN_INFO_SCALE);\n\tif (ret < 0) {\n\t\tdev_err(bat->dev, \"Unable to read channel avail scale\\n\");\n\t\treturn ret;\n\t}\n\tif (ret != IIO_AVAIL_LIST || scale_type != IIO_VAL_FRACTIONAL_LOG2)\n\t\treturn -EINVAL;\n\n\tmax_mV = bat->info->voltage_max_design_uv / 1000;\n\n\tfor (i = 0; i < scale_len; i += 2) {\n\t\tu64 scale_mV = (max_raw * scale_raw[i]) >> scale_raw[i + 1];\n\n\t\tif (scale_mV < max_mV)\n\t\t\tcontinue;\n\n\t\tif (best_idx >= 0 && scale_mV > best_mV)\n\t\t\tcontinue;\n\n\t\tbest_mV = scale_mV;\n\t\tbest_idx = i;\n\t}\n\n\tif (best_idx < 0) {\n\t\tdev_err(bat->dev, \"Unable to find matching voltage scale\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (scale_len > 2) {\n\t\tret = iio_write_channel_attribute(bat->channel,\n\t\t\t\t\t\t  scale_raw[best_idx],\n\t\t\t\t\t\t  scale_raw[best_idx + 1],\n\t\t\t\t\t\t  IIO_CHAN_INFO_SCALE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property ingenic_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n};\n\nstatic int ingenic_battery_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ingenic_battery *bat;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct power_supply_desc *desc;\n\tint ret;\n\n\tbat = devm_kzalloc(dev, sizeof(*bat), GFP_KERNEL);\n\tif (!bat)\n\t\treturn -ENOMEM;\n\n\tbat->dev = dev;\n\tbat->channel = devm_iio_channel_get(dev, \"battery\");\n\tif (IS_ERR(bat->channel))\n\t\treturn PTR_ERR(bat->channel);\n\n\tdesc = &bat->desc;\n\tdesc->name = \"jz-battery\";\n\tdesc->type = POWER_SUPPLY_TYPE_BATTERY;\n\tdesc->properties = ingenic_battery_properties;\n\tdesc->num_properties = ARRAY_SIZE(ingenic_battery_properties);\n\tdesc->get_property = ingenic_battery_get_property;\n\tpsy_cfg.drv_data = bat;\n\tpsy_cfg.of_node = dev->of_node;\n\n\tbat->battery = devm_power_supply_register(dev, desc, &psy_cfg);\n\tif (IS_ERR(bat->battery))\n\t\treturn dev_err_probe(dev, PTR_ERR(bat->battery),\n\t\t\t\t     \"Unable to register battery\\n\");\n\n\tret = power_supply_get_battery_info(bat->battery, &bat->info);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to get battery info: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (bat->info->voltage_min_design_uv < 0) {\n\t\tdev_err(dev, \"Unable to get voltage min design\\n\");\n\t\treturn bat->info->voltage_min_design_uv;\n\t}\n\tif (bat->info->voltage_max_design_uv < 0) {\n\t\tdev_err(dev, \"Unable to get voltage max design\\n\");\n\t\treturn bat->info->voltage_max_design_uv;\n\t}\n\n\treturn ingenic_battery_set_scale(bat);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ingenic_battery_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-battery\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ingenic_battery_of_match);\n#endif\n\nstatic struct platform_driver ingenic_battery_driver = {\n\t.driver = {\n\t\t.name = \"ingenic-battery\",\n\t\t.of_match_table = of_match_ptr(ingenic_battery_of_match),\n\t},\n\t.probe = ingenic_battery_probe,\n};\nmodule_platform_driver(ingenic_battery_driver);\n\nMODULE_DESCRIPTION(\"Battery driver for Ingenic JZ47xx SoCs\");\nMODULE_AUTHOR(\"Artur Rojek <contact@artur-rojek.eu>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}