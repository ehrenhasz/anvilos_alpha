{
  "module_name": "cw2015_battery.c",
  "hash_id": "29194a50f09d4b17e608054607f2f0c4979c1a2bf8143fe83c2ac8a17b727d40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/cw2015_battery.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/gfp.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/time.h>\n#include <linux/workqueue.h>\n#include <linux/devm-helpers.h>\n\n#define CW2015_SIZE_BATINFO\t\t64\n\n#define CW2015_RESET_TRIES\t\t5\n\n#define CW2015_REG_VERSION\t\t0x00\n#define CW2015_REG_VCELL\t\t0x02\n#define CW2015_REG_SOC\t\t\t0x04\n#define CW2015_REG_RRT_ALERT\t\t0x06\n#define CW2015_REG_CONFIG\t\t0x08\n#define CW2015_REG_MODE\t\t\t0x0A\n#define CW2015_REG_BATINFO\t\t0x10\n\n#define CW2015_MODE_SLEEP_MASK\t\tGENMASK(7, 6)\n#define CW2015_MODE_SLEEP\t\t(0x03 << 6)\n#define CW2015_MODE_NORMAL\t\t(0x00 << 6)\n#define CW2015_MODE_QUICK_START\t\t(0x03 << 4)\n#define CW2015_MODE_RESTART\t\t(0x0f << 0)\n\n#define CW2015_CONFIG_UPDATE_FLG\t(0x01 << 1)\n#define CW2015_ATHD(x)\t\t\t((x) << 3)\n#define CW2015_MASK_ATHD\t\tGENMASK(7, 3)\n#define CW2015_MASK_SOC\t\t\tGENMASK(12, 0)\n\n \n#define CW2015_BAT_SOC_ERROR_MS\t\t(40 * MSEC_PER_SEC)\n \n#define CW2015_BAT_CHARGING_STUCK_MS\t(1800 * MSEC_PER_SEC)\n\n \n#define CW2015_DEFAULT_POLL_INTERVAL_MS\t\t8000\n\n#define CW2015_AVERAGING_SAMPLES\t\t3\n\nstruct cw_battery {\n\tstruct device *dev;\n\tstruct workqueue_struct *battery_workqueue;\n\tstruct delayed_work battery_delay_work;\n\tstruct regmap *regmap;\n\tstruct power_supply *rk_bat;\n\tstruct power_supply_battery_info *battery;\n\tu8 *bat_profile;\n\n\tbool charger_attached;\n\tbool battery_changed;\n\n\tint soc;\n\tint voltage_mv;\n\tint status;\n\tint time_to_empty;\n\tint charge_count;\n\n\tu32 poll_interval_ms;\n\tu8 alert_level;\n\n\tunsigned int read_errors;\n\tunsigned int charge_stuck_cnt;\n};\n\nstatic int cw_read_word(struct cw_battery *cw_bat, u8 reg, u16 *val)\n{\n\t__be16 value;\n\tint ret;\n\n\tret = regmap_bulk_read(cw_bat->regmap, reg, &value, sizeof(value));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = be16_to_cpu(value);\n\treturn 0;\n}\n\nstatic int cw_update_profile(struct cw_battery *cw_bat)\n{\n\tint ret;\n\tunsigned int reg_val;\n\tu8 reset_val;\n\n\t \n\tret = regmap_read(cw_bat->regmap, CW2015_REG_MODE, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treset_val = reg_val;\n\tif ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {\n\t\tdev_err(cw_bat->dev,\n\t\t\t\"Gauge is in sleep mode, can't update battery info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_raw_write(cw_bat->regmap, CW2015_REG_BATINFO,\n\t\t\t       cw_bat->bat_profile,\n\t\t\t       CW2015_SIZE_BATINFO);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg_val |= CW2015_CONFIG_UPDATE_FLG;\n\treg_val &= ~CW2015_MASK_ATHD;\n\treg_val |= CW2015_ATHD(cw_bat->alert_level);\n\tret = regmap_write(cw_bat->regmap, CW2015_REG_CONFIG, reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treset_val &= ~CW2015_MODE_RESTART;\n\treg_val = reset_val | CW2015_MODE_RESTART;\n\tret = regmap_write(cw_bat->regmap, CW2015_REG_MODE, reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\t \n\tret = regmap_write(cw_bat->regmap, CW2015_REG_MODE, reset_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(cw_bat->regmap, CW2015_REG_SOC,\n\t\t\t\t       reg_val, reg_val <= 100,\n\t\t\t\t       10 * USEC_PER_MSEC, 10 * USEC_PER_SEC);\n\tif (ret)\n\t\tdev_err(cw_bat->dev,\n\t\t\t\"Gauge did not become ready after profile upload\\n\");\n\telse\n\t\tdev_dbg(cw_bat->dev, \"Battery profile updated\\n\");\n\n\treturn ret;\n}\n\nstatic int cw_init(struct cw_battery *cw_bat)\n{\n\tint ret;\n\tunsigned int reg_val = CW2015_MODE_SLEEP;\n\n\tif ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {\n\t\treg_val = CW2015_MODE_NORMAL;\n\t\tret = regmap_write(cw_bat->regmap, CW2015_REG_MODE, reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(cw_bat->regmap, CW2015_REG_CONFIG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD(cw_bat->alert_level)) {\n\t\tdev_dbg(cw_bat->dev, \"Setting new alert level\\n\");\n\t\treg_val &= ~CW2015_MASK_ATHD;\n\t\treg_val |= ~CW2015_ATHD(cw_bat->alert_level);\n\t\tret = regmap_write(cw_bat->regmap, CW2015_REG_CONFIG, reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(cw_bat->regmap, CW2015_REG_CONFIG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(reg_val & CW2015_CONFIG_UPDATE_FLG)) {\n\t\tdev_dbg(cw_bat->dev,\n\t\t\t\"Battery profile not present, uploading battery profile\\n\");\n\t\tif (cw_bat->bat_profile) {\n\t\t\tret = cw_update_profile(cw_bat);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(cw_bat->dev,\n\t\t\t\t\t\"Failed to upload battery profile\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(cw_bat->dev,\n\t\t\t\t \"No profile specified, continuing without profile\\n\");\n\t\t}\n\t} else if (cw_bat->bat_profile) {\n\t\tu8 bat_info[CW2015_SIZE_BATINFO];\n\n\t\tret = regmap_raw_read(cw_bat->regmap, CW2015_REG_BATINFO,\n\t\t\t\t      bat_info, CW2015_SIZE_BATINFO);\n\t\tif (ret) {\n\t\t\tdev_err(cw_bat->dev,\n\t\t\t\t\"Failed to read stored battery profile\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (memcmp(bat_info, cw_bat->bat_profile, CW2015_SIZE_BATINFO)) {\n\t\t\tdev_warn(cw_bat->dev, \"Replacing stored battery profile\\n\");\n\t\t\tret = cw_update_profile(cw_bat);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_warn(cw_bat->dev,\n\t\t\t \"Can't check current battery profile, no profile provided\\n\");\n\t}\n\n\tdev_dbg(cw_bat->dev, \"Battery profile configured\\n\");\n\treturn 0;\n}\n\nstatic int cw_power_on_reset(struct cw_battery *cw_bat)\n{\n\tint ret;\n\tunsigned char reset_val;\n\n\treset_val = CW2015_MODE_SLEEP;\n\tret = regmap_write(cw_bat->regmap, CW2015_REG_MODE, reset_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\treset_val = CW2015_MODE_NORMAL;\n\tret = regmap_write(cw_bat->regmap, CW2015_REG_MODE, reset_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cw_init(cw_bat);\n\tif (ret)\n\t\treturn ret;\n\treturn 0;\n}\n\n#define HYSTERESIS(current, previous, up, down) \\\n\t(((current) < (previous) + (up)) && ((current) > (previous) - (down)))\n\nstatic int cw_get_soc(struct cw_battery *cw_bat)\n{\n\tunsigned int soc;\n\tint ret;\n\n\tret = regmap_read(cw_bat->regmap, CW2015_REG_SOC, &soc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (soc > 100) {\n\t\tint max_error_cycles =\n\t\t\tCW2015_BAT_SOC_ERROR_MS / cw_bat->poll_interval_ms;\n\n\t\tdev_err(cw_bat->dev, \"Invalid SoC %d%%\\n\", soc);\n\t\tcw_bat->read_errors++;\n\t\tif (cw_bat->read_errors > max_error_cycles) {\n\t\t\tdev_warn(cw_bat->dev,\n\t\t\t\t \"Too many invalid SoC reports, resetting gauge\\n\");\n\t\t\tcw_power_on_reset(cw_bat);\n\t\t\tcw_bat->read_errors = 0;\n\t\t}\n\t\treturn cw_bat->soc;\n\t}\n\tcw_bat->read_errors = 0;\n\n\t \n\tif (cw_bat->status == POWER_SUPPLY_STATUS_CHARGING && soc == cw_bat->soc) {\n\t\tint max_stuck_cycles =\n\t\t\tCW2015_BAT_CHARGING_STUCK_MS / cw_bat->poll_interval_ms;\n\n\t\tcw_bat->charge_stuck_cnt++;\n\t\tif (cw_bat->charge_stuck_cnt > max_stuck_cycles) {\n\t\t\tdev_warn(cw_bat->dev,\n\t\t\t\t \"SoC stuck @%u%%, resetting gauge\\n\", soc);\n\t\t\tcw_power_on_reset(cw_bat);\n\t\t\tcw_bat->charge_stuck_cnt = 0;\n\t\t}\n\t} else {\n\t\tcw_bat->charge_stuck_cnt = 0;\n\t}\n\n\t \n\tif (cw_bat->charger_attached && HYSTERESIS(soc, cw_bat->soc, 0, 3))\n\t\tsoc = cw_bat->soc;\n\n\t \n\tif (!cw_bat->charger_attached && HYSTERESIS(soc, cw_bat->soc, 3, 0))\n\t\tsoc = cw_bat->soc;\n\n\treturn soc;\n}\n\nstatic int cw_get_voltage(struct cw_battery *cw_bat)\n{\n\tint ret, i, voltage_mv;\n\tu16 reg_val;\n\tu32 avg = 0;\n\n\tfor (i = 0; i < CW2015_AVERAGING_SAMPLES; i++) {\n\t\tret = cw_read_word(cw_bat, CW2015_REG_VCELL, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tavg += reg_val;\n\t}\n\tavg /= CW2015_AVERAGING_SAMPLES;\n\n\t \n\tvoltage_mv = avg * 312 / 1024;\n\n\tdev_dbg(cw_bat->dev, \"Read voltage: %d mV, raw=0x%04x\\n\",\n\t\tvoltage_mv, reg_val);\n\treturn voltage_mv;\n}\n\nstatic int cw_get_time_to_empty(struct cw_battery *cw_bat)\n{\n\tint ret;\n\tu16 value16;\n\n\tret = cw_read_word(cw_bat, CW2015_REG_RRT_ALERT, &value16);\n\tif (ret)\n\t\treturn ret;\n\n\treturn value16 & CW2015_MASK_SOC;\n}\n\nstatic void cw_update_charge_status(struct cw_battery *cw_bat)\n{\n\tint ret;\n\n\tret = power_supply_am_i_supplied(cw_bat->rk_bat);\n\tif (ret < 0) {\n\t\tdev_warn(cw_bat->dev, \"Failed to get supply state: %d\\n\", ret);\n\t} else {\n\t\tbool charger_attached;\n\n\t\tcharger_attached = !!ret;\n\t\tif (cw_bat->charger_attached != charger_attached) {\n\t\t\tcw_bat->battery_changed = true;\n\t\t\tif (charger_attached)\n\t\t\t\tcw_bat->charge_count++;\n\t\t}\n\t\tcw_bat->charger_attached = charger_attached;\n\t}\n}\n\nstatic void cw_update_soc(struct cw_battery *cw_bat)\n{\n\tint soc;\n\n\tsoc = cw_get_soc(cw_bat);\n\tif (soc < 0)\n\t\tdev_err(cw_bat->dev, \"Failed to get SoC from gauge: %d\\n\", soc);\n\telse if (cw_bat->soc != soc) {\n\t\tcw_bat->soc = soc;\n\t\tcw_bat->battery_changed = true;\n\t}\n}\n\nstatic void cw_update_voltage(struct cw_battery *cw_bat)\n{\n\tint voltage_mv;\n\n\tvoltage_mv = cw_get_voltage(cw_bat);\n\tif (voltage_mv < 0)\n\t\tdev_err(cw_bat->dev, \"Failed to get voltage from gauge: %d\\n\",\n\t\t\tvoltage_mv);\n\telse\n\t\tcw_bat->voltage_mv = voltage_mv;\n}\n\nstatic void cw_update_status(struct cw_battery *cw_bat)\n{\n\tint status = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\tif (cw_bat->charger_attached) {\n\t\tif (cw_bat->soc >= 100)\n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t}\n\n\tif (cw_bat->status != status)\n\t\tcw_bat->battery_changed = true;\n\tcw_bat->status = status;\n}\n\nstatic void cw_update_time_to_empty(struct cw_battery *cw_bat)\n{\n\tint time_to_empty;\n\n\ttime_to_empty = cw_get_time_to_empty(cw_bat);\n\tif (time_to_empty < 0)\n\t\tdev_err(cw_bat->dev, \"Failed to get time to empty from gauge: %d\\n\",\n\t\t\ttime_to_empty);\n\telse if (cw_bat->time_to_empty != time_to_empty) {\n\t\tcw_bat->time_to_empty = time_to_empty;\n\t\tcw_bat->battery_changed = true;\n\t}\n}\n\nstatic void cw_bat_work(struct work_struct *work)\n{\n\tstruct delayed_work *delay_work;\n\tstruct cw_battery *cw_bat;\n\tint ret;\n\tunsigned int reg_val;\n\n\tdelay_work = to_delayed_work(work);\n\tcw_bat = container_of(delay_work, struct cw_battery, battery_delay_work);\n\tret = regmap_read(cw_bat->regmap, CW2015_REG_MODE, &reg_val);\n\tif (ret) {\n\t\tdev_err(cw_bat->dev, \"Failed to read mode from gauge: %d\\n\", ret);\n\t} else {\n\t\tif ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < CW2015_RESET_TRIES; i++) {\n\t\t\t\tif (!cw_power_on_reset(cw_bat))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcw_update_soc(cw_bat);\n\t\tcw_update_voltage(cw_bat);\n\t\tcw_update_charge_status(cw_bat);\n\t\tcw_update_status(cw_bat);\n\t\tcw_update_time_to_empty(cw_bat);\n\t}\n\tdev_dbg(cw_bat->dev, \"charger_attached = %d\\n\", cw_bat->charger_attached);\n\tdev_dbg(cw_bat->dev, \"status = %d\\n\", cw_bat->status);\n\tdev_dbg(cw_bat->dev, \"soc = %d%%\\n\", cw_bat->soc);\n\tdev_dbg(cw_bat->dev, \"voltage = %dmV\\n\", cw_bat->voltage_mv);\n\n\tif (cw_bat->battery_changed)\n\t\tpower_supply_changed(cw_bat->rk_bat);\n\tcw_bat->battery_changed = false;\n\n\tqueue_delayed_work(cw_bat->battery_workqueue,\n\t\t\t   &cw_bat->battery_delay_work,\n\t\t\t   msecs_to_jiffies(cw_bat->poll_interval_ms));\n}\n\nstatic bool cw_battery_valid_time_to_empty(struct cw_battery *cw_bat)\n{\n\treturn\tcw_bat->time_to_empty > 0 &&\n\t\tcw_bat->time_to_empty < CW2015_MASK_SOC &&\n\t\tcw_bat->status == POWER_SUPPLY_STATUS_DISCHARGING;\n}\n\nstatic int cw_battery_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct cw_battery *cw_bat;\n\n\tcw_bat = power_supply_get_drvdata(psy);\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = cw_bat->soc;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = cw_bat->status;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!cw_bat->voltage_mv;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = cw_bat->voltage_mv * 1000;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\n\t\tif (cw_battery_valid_time_to_empty(cw_bat))\n\t\t\tval->intval = cw_bat->time_to_empty * 60;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_COUNTER:\n\t\tval->intval = cw_bat->charge_count;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tif (cw_bat->battery->charge_full_design_uah > 0)\n\t\t\tval->intval = cw_bat->battery->charge_full_design_uah;\n\t\telse\n\t\t\tval->intval = 0;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tval->intval = cw_bat->battery->charge_full_design_uah;\n\t\tval->intval = val->intval * cw_bat->soc / 100;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (cw_battery_valid_time_to_empty(cw_bat) &&\n\t\t    cw_bat->battery->charge_full_design_uah > 0) {\n\t\t\t \n\t\t\tval->intval = cw_bat->battery->charge_full_design_uah;\n\t\t\tval->intval = val->intval * cw_bat->soc / 100;\n\n\t\t\t \n\t\t\tval->intval = 60 * val->intval / cw_bat->time_to_empty;\n\t\t} else {\n\t\t\tval->intval = 0;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property cw_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_CHARGE_COUNTER,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic const struct power_supply_desc cw2015_bat_desc = {\n\t.name\t\t= \"cw2015-battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= cw_battery_properties,\n\t.num_properties\t= ARRAY_SIZE(cw_battery_properties),\n\t.get_property\t= cw_battery_get_property,\n};\n\nstatic int cw2015_parse_properties(struct cw_battery *cw_bat)\n{\n\tstruct device *dev = cw_bat->dev;\n\tint length;\n\tint ret;\n\n\tlength = device_property_count_u8(dev, \"cellwise,battery-profile\");\n\tif (length < 0) {\n\t\tdev_warn(cw_bat->dev,\n\t\t\t \"No battery-profile found, using current flash contents\\n\");\n\t} else if (length != CW2015_SIZE_BATINFO) {\n\t\tdev_err(cw_bat->dev, \"battery-profile must be %d bytes\\n\",\n\t\t\tCW2015_SIZE_BATINFO);\n\t\treturn -EINVAL;\n\t} else {\n\t\tcw_bat->bat_profile = devm_kzalloc(dev, length, GFP_KERNEL);\n\t\tif (!cw_bat->bat_profile)\n\t\t\treturn -ENOMEM;\n\n\t\tret = device_property_read_u8_array(dev,\n\t\t\t\t\t\t\"cellwise,battery-profile\",\n\t\t\t\t\t\tcw_bat->bat_profile,\n\t\t\t\t\t\tlength);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"cellwise,monitor-interval-ms\",\n\t\t\t\t       &cw_bat->poll_interval_ms);\n\tif (ret) {\n\t\tdev_dbg(cw_bat->dev, \"Using default poll interval\\n\");\n\t\tcw_bat->poll_interval_ms = CW2015_DEFAULT_POLL_INTERVAL_MS;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_range regmap_ranges_rd_yes[] = {\n\tregmap_reg_range(CW2015_REG_VERSION, CW2015_REG_VERSION),\n\tregmap_reg_range(CW2015_REG_VCELL, CW2015_REG_CONFIG),\n\tregmap_reg_range(CW2015_REG_MODE, CW2015_REG_MODE),\n\tregmap_reg_range(CW2015_REG_BATINFO,\n\t\t\tCW2015_REG_BATINFO + CW2015_SIZE_BATINFO - 1),\n};\n\nstatic const struct regmap_access_table regmap_rd_table = {\n\t.yes_ranges = regmap_ranges_rd_yes,\n\t.n_yes_ranges = 4,\n};\n\nstatic const struct regmap_range regmap_ranges_wr_yes[] = {\n\tregmap_reg_range(CW2015_REG_RRT_ALERT, CW2015_REG_CONFIG),\n\tregmap_reg_range(CW2015_REG_MODE, CW2015_REG_MODE),\n\tregmap_reg_range(CW2015_REG_BATINFO,\n\t\t\tCW2015_REG_BATINFO + CW2015_SIZE_BATINFO - 1),\n};\n\nstatic const struct regmap_access_table regmap_wr_table = {\n\t.yes_ranges = regmap_ranges_wr_yes,\n\t.n_yes_ranges = 3,\n};\n\nstatic const struct regmap_range regmap_ranges_vol_yes[] = {\n\tregmap_reg_range(CW2015_REG_VCELL, CW2015_REG_SOC + 1),\n};\n\nstatic const struct regmap_access_table regmap_vol_table = {\n\t.yes_ranges = regmap_ranges_vol_yes,\n\t.n_yes_ranges = 1,\n};\n\nstatic const struct regmap_config cw2015_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.rd_table = &regmap_rd_table,\n\t.wr_table = &regmap_wr_table,\n\t.volatile_table = &regmap_vol_table,\n\t.max_register = CW2015_REG_BATINFO + CW2015_SIZE_BATINFO - 1,\n};\n\nstatic int cw_bat_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct cw_battery *cw_bat;\n\tstruct power_supply_config psy_cfg = { 0 };\n\n\tcw_bat = devm_kzalloc(&client->dev, sizeof(*cw_bat), GFP_KERNEL);\n\tif (!cw_bat)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, cw_bat);\n\tcw_bat->dev = &client->dev;\n\tcw_bat->soc = 1;\n\n\tret = cw2015_parse_properties(cw_bat);\n\tif (ret) {\n\t\tdev_err(cw_bat->dev, \"Failed to parse cw2015 properties\\n\");\n\t\treturn ret;\n\t}\n\n\tcw_bat->regmap = devm_regmap_init_i2c(client, &cw2015_regmap_config);\n\tif (IS_ERR(cw_bat->regmap)) {\n\t\tdev_err(cw_bat->dev, \"Failed to allocate regmap: %ld\\n\",\n\t\t\tPTR_ERR(cw_bat->regmap));\n\t\treturn PTR_ERR(cw_bat->regmap);\n\t}\n\n\tret = cw_init(cw_bat);\n\tif (ret) {\n\t\tdev_err(cw_bat->dev, \"Init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpsy_cfg.drv_data = cw_bat;\n\tpsy_cfg.fwnode = dev_fwnode(cw_bat->dev);\n\n\tcw_bat->rk_bat = devm_power_supply_register(&client->dev,\n\t\t\t\t\t\t    &cw2015_bat_desc,\n\t\t\t\t\t\t    &psy_cfg);\n\tif (IS_ERR(cw_bat->rk_bat)) {\n\t\t \n\t\tdev_err_probe(&client->dev, PTR_ERR(cw_bat->rk_bat),\n\t\t\t\"Failed to register power supply\\n\");\n\t\treturn PTR_ERR(cw_bat->rk_bat);\n\t}\n\n\tret = power_supply_get_battery_info(cw_bat->rk_bat, &cw_bat->battery);\n\tif (ret) {\n\t\t \n\t\tcw_bat->battery = devm_kzalloc(&client->dev,\n\t\t\t\t\t       sizeof(*cw_bat->battery),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!cw_bat->battery)\n\t\t\treturn -ENOMEM;\n\t\tdev_warn(cw_bat->dev,\n\t\t\t \"No monitored battery, some properties will be missing\\n\");\n\t}\n\n\tcw_bat->battery_workqueue = create_singlethread_workqueue(\"rk_battery\");\n\tif (!cw_bat->battery_workqueue)\n\t\treturn -ENOMEM;\n\n\tdevm_delayed_work_autocancel(&client->dev,\n\t\t\t\t\t\t\t  &cw_bat->battery_delay_work, cw_bat_work);\n\tqueue_delayed_work(cw_bat->battery_workqueue,\n\t\t\t   &cw_bat->battery_delay_work, msecs_to_jiffies(10));\n\treturn 0;\n}\n\nstatic int __maybe_unused cw_bat_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cw_battery *cw_bat = i2c_get_clientdata(client);\n\n\tcancel_delayed_work_sync(&cw_bat->battery_delay_work);\n\treturn 0;\n}\n\nstatic int __maybe_unused cw_bat_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cw_battery *cw_bat = i2c_get_clientdata(client);\n\n\tqueue_delayed_work(cw_bat->battery_workqueue,\n\t\t\t   &cw_bat->battery_delay_work, 0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cw_bat_pm_ops, cw_bat_suspend, cw_bat_resume);\n\nstatic const struct i2c_device_id cw_bat_id_table[] = {\n\t{ \"cw2015\", 0 },\n\t{ }\n};\n\nstatic const struct of_device_id cw2015_of_match[] = {\n\t{ .compatible = \"cellwise,cw2015\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cw2015_of_match);\n\nstatic struct i2c_driver cw_bat_driver = {\n\t.driver = {\n\t\t.name = \"cw2015\",\n\t\t.of_match_table = cw2015_of_match,\n\t\t.pm = &cw_bat_pm_ops,\n\t},\n\t.probe = cw_bat_probe,\n\t.id_table = cw_bat_id_table,\n};\n\nmodule_i2c_driver(cw_bat_driver);\n\nMODULE_AUTHOR(\"xhc<xhc@rock-chips.com>\");\nMODULE_AUTHOR(\"Tobias Schramm <t.schramm@manjaro.org>\");\nMODULE_DESCRIPTION(\"cw2015/cw2013 battery driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}