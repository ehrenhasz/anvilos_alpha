{
  "module_name": "bq2415x_charger.c",
  "hash_id": "480607378ab920a9c208bb1bfa66ff5b9560a2ec9d8b023f872b0c16f6860abe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/bq2415x_charger.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/param.h>\n#include <linux/err.h>\n#include <linux/workqueue.h>\n#include <linux/sysfs.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/idr.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n\n#include <linux/power/bq2415x_charger.h>\n\n \n#define BQ2415X_TIMER_TIMEOUT\t\t10\n\n#define BQ2415X_REG_STATUS\t\t0x00\n#define BQ2415X_REG_CONTROL\t\t0x01\n#define BQ2415X_REG_VOLTAGE\t\t0x02\n#define BQ2415X_REG_VENDER\t\t0x03\n#define BQ2415X_REG_CURRENT\t\t0x04\n\n \n#define BQ2415X_RESET_STATUS\t\tBIT(6)\n#define BQ2415X_RESET_CONTROL\t\t(BIT(4)|BIT(5))\n#define BQ2415X_RESET_VOLTAGE\t\t(BIT(1)|BIT(3))\n#define BQ2415X_RESET_CURRENT\t\t(BIT(0)|BIT(3)|BIT(7))\n\n \n#define BQ2415X_BIT_TMR_RST\t\t7\n#define BQ2415X_BIT_OTG\t\t\t7\n#define BQ2415X_BIT_EN_STAT\t\t6\n#define BQ2415X_MASK_STAT\t\t(BIT(4)|BIT(5))\n#define BQ2415X_SHIFT_STAT\t\t4\n#define BQ2415X_BIT_BOOST\t\t3\n#define BQ2415X_MASK_FAULT\t\t(BIT(0)|BIT(1)|BIT(2))\n#define BQ2415X_SHIFT_FAULT\t\t0\n\n \n#define BQ2415X_MASK_LIMIT\t\t(BIT(6)|BIT(7))\n#define BQ2415X_SHIFT_LIMIT\t\t6\n#define BQ2415X_MASK_VLOWV\t\t(BIT(4)|BIT(5))\n#define BQ2415X_SHIFT_VLOWV\t\t4\n#define BQ2415X_BIT_TE\t\t\t3\n#define BQ2415X_BIT_CE\t\t\t2\n#define BQ2415X_BIT_HZ_MODE\t\t1\n#define BQ2415X_BIT_OPA_MODE\t\t0\n\n \n#define BQ2415X_MASK_VO\t\t(BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7))\n#define BQ2415X_SHIFT_VO\t\t2\n#define BQ2415X_BIT_OTG_PL\t\t1\n#define BQ2415X_BIT_OTG_EN\t\t0\n\n \n#define BQ2415X_MASK_VENDER\t\t(BIT(5)|BIT(6)|BIT(7))\n#define BQ2415X_SHIFT_VENDER\t\t5\n#define BQ2415X_MASK_PN\t\t\t(BIT(3)|BIT(4))\n#define BQ2415X_SHIFT_PN\t\t3\n#define BQ2415X_MASK_REVISION\t\t(BIT(0)|BIT(1)|BIT(2))\n#define BQ2415X_SHIFT_REVISION\t\t0\n\n \n#define BQ2415X_MASK_RESET\t\tBIT(7)\n#define BQ2415X_MASK_VI_CHRG\t\t(BIT(4)|BIT(5)|BIT(6))\n#define BQ2415X_SHIFT_VI_CHRG\t\t4\n \n#define BQ2415X_MASK_VI_TERM\t\t(BIT(0)|BIT(1)|BIT(2))\n#define BQ2415X_SHIFT_VI_TERM\t\t0\n\n\nenum bq2415x_command {\n\tBQ2415X_TIMER_RESET,\n\tBQ2415X_OTG_STATUS,\n\tBQ2415X_STAT_PIN_STATUS,\n\tBQ2415X_STAT_PIN_ENABLE,\n\tBQ2415X_STAT_PIN_DISABLE,\n\tBQ2415X_CHARGE_STATUS,\n\tBQ2415X_BOOST_STATUS,\n\tBQ2415X_FAULT_STATUS,\n\n\tBQ2415X_CHARGE_TERMINATION_STATUS,\n\tBQ2415X_CHARGE_TERMINATION_ENABLE,\n\tBQ2415X_CHARGE_TERMINATION_DISABLE,\n\tBQ2415X_CHARGER_STATUS,\n\tBQ2415X_CHARGER_ENABLE,\n\tBQ2415X_CHARGER_DISABLE,\n\tBQ2415X_HIGH_IMPEDANCE_STATUS,\n\tBQ2415X_HIGH_IMPEDANCE_ENABLE,\n\tBQ2415X_HIGH_IMPEDANCE_DISABLE,\n\tBQ2415X_BOOST_MODE_STATUS,\n\tBQ2415X_BOOST_MODE_ENABLE,\n\tBQ2415X_BOOST_MODE_DISABLE,\n\n\tBQ2415X_OTG_LEVEL,\n\tBQ2415X_OTG_ACTIVATE_HIGH,\n\tBQ2415X_OTG_ACTIVATE_LOW,\n\tBQ2415X_OTG_PIN_STATUS,\n\tBQ2415X_OTG_PIN_ENABLE,\n\tBQ2415X_OTG_PIN_DISABLE,\n\n\tBQ2415X_VENDER_CODE,\n\tBQ2415X_PART_NUMBER,\n\tBQ2415X_REVISION,\n};\n\nenum bq2415x_chip {\n\tBQUNKNOWN,\n\tBQ24150,\n\tBQ24150A,\n\tBQ24151,\n\tBQ24151A,\n\tBQ24152,\n\tBQ24153,\n\tBQ24153A,\n\tBQ24155,\n\tBQ24156,\n\tBQ24156A,\n\tBQ24157S,\n\tBQ24158,\n};\n\nstatic char *bq2415x_chip_name[] = {\n\t\"unknown\",\n\t\"bq24150\",\n\t\"bq24150a\",\n\t\"bq24151\",\n\t\"bq24151a\",\n\t\"bq24152\",\n\t\"bq24153\",\n\t\"bq24153a\",\n\t\"bq24155\",\n\t\"bq24156\",\n\t\"bq24156a\",\n\t\"bq24157s\",\n\t\"bq24158\",\n};\n\nstruct bq2415x_device {\n\tstruct device *dev;\n\tstruct bq2415x_platform_data init_data;\n\tstruct power_supply *charger;\n\tstruct power_supply_desc charger_desc;\n\tstruct delayed_work work;\n\tstruct device_node *notify_node;\n\tstruct notifier_block nb;\n\tenum bq2415x_mode reported_mode; \n\tenum bq2415x_mode mode;\t\t \n\tenum bq2415x_chip chip;\n\tconst char *timer_error;\n\tchar *model;\n\tchar *name;\n\tint autotimer;\t \n\tint automode;\t \n\tint id;\n};\n\n \nstatic DEFINE_IDR(bq2415x_id);\n\nstatic DEFINE_MUTEX(bq2415x_id_mutex);\nstatic DEFINE_MUTEX(bq2415x_timer_mutex);\nstatic DEFINE_MUTEX(bq2415x_i2c_mutex);\n\n \n\n \nstatic int bq2415x_i2c_read(struct bq2415x_device *bq, u8 reg)\n{\n\tstruct i2c_client *client = to_i2c_client(bq->dev);\n\tstruct i2c_msg msg[2];\n\tu8 val;\n\tint ret;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = &reg;\n\tmsg[0].len = sizeof(reg);\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = &val;\n\tmsg[1].len = sizeof(val);\n\n\tmutex_lock(&bq2415x_i2c_mutex);\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tmutex_unlock(&bq2415x_i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\n \nstatic int bq2415x_i2c_read_mask(struct bq2415x_device *bq, u8 reg,\n\t\t\t\t u8 mask, u8 shift)\n{\n\tint ret;\n\n\tif (shift > 8)\n\t\treturn -EINVAL;\n\n\tret = bq2415x_i2c_read(bq, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (ret & mask) >> shift;\n}\n\n \nstatic int bq2415x_i2c_read_bit(struct bq2415x_device *bq, u8 reg, u8 bit)\n{\n\tif (bit > 8)\n\t\treturn -EINVAL;\n\treturn bq2415x_i2c_read_mask(bq, reg, BIT(bit), bit);\n}\n\n \n\n \nstatic int bq2415x_i2c_write(struct bq2415x_device *bq, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = to_i2c_client(bq->dev);\n\tstruct i2c_msg msg[1];\n\tu8 data[2];\n\tint ret;\n\n\tdata[0] = reg;\n\tdata[1] = val;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = data;\n\tmsg[0].len = ARRAY_SIZE(data);\n\n\tmutex_lock(&bq2415x_i2c_mutex);\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tmutex_unlock(&bq2415x_i2c_mutex);\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int bq2415x_i2c_write_mask(struct bq2415x_device *bq, u8 reg, u8 val,\n\t\t\t\t  u8 mask, u8 shift)\n{\n\tint ret;\n\n\tif (shift > 8)\n\t\treturn -EINVAL;\n\n\tret = bq2415x_i2c_read(bq, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~mask;\n\tret |= val << shift;\n\n\treturn bq2415x_i2c_write(bq, reg, ret);\n}\n\n \nstatic int bq2415x_i2c_write_bit(struct bq2415x_device *bq, u8 reg,\n\t\t\t\t bool val, u8 bit)\n{\n\tif (bit > 8)\n\t\treturn -EINVAL;\n\treturn bq2415x_i2c_write_mask(bq, reg, val, BIT(bit), bit);\n}\n\n \n\n \nstatic int bq2415x_exec_command(struct bq2415x_device *bq,\n\t\t\t\tenum bq2415x_command command)\n{\n\tint ret;\n\n\tswitch (command) {\n\tcase BQ2415X_TIMER_RESET:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS,\n\t\t\t\t1, BQ2415X_BIT_TMR_RST);\n\tcase BQ2415X_OTG_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\n\t\t\t\tBQ2415X_BIT_OTG);\n\tcase BQ2415X_STAT_PIN_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\n\t\t\t\tBQ2415X_BIT_EN_STAT);\n\tcase BQ2415X_STAT_PIN_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS, 1,\n\t\t\t\tBQ2415X_BIT_EN_STAT);\n\tcase BQ2415X_STAT_PIN_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS, 0,\n\t\t\t\tBQ2415X_BIT_EN_STAT);\n\tcase BQ2415X_CHARGE_STATUS:\n\t\treturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_STATUS,\n\t\t\t\tBQ2415X_MASK_STAT, BQ2415X_SHIFT_STAT);\n\tcase BQ2415X_BOOST_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\n\t\t\t\tBQ2415X_BIT_BOOST);\n\tcase BQ2415X_FAULT_STATUS:\n\t\treturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_STATUS,\n\t\t\tBQ2415X_MASK_FAULT, BQ2415X_SHIFT_FAULT);\n\n\tcase BQ2415X_CHARGE_TERMINATION_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\tBQ2415X_BIT_TE);\n\tcase BQ2415X_CHARGE_TERMINATION_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t1, BQ2415X_BIT_TE);\n\tcase BQ2415X_CHARGE_TERMINATION_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t0, BQ2415X_BIT_TE);\n\tcase BQ2415X_CHARGER_STATUS:\n\t\tret = bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\tBQ2415X_BIT_CE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn ret > 0 ? 0 : 1;\n\tcase BQ2415X_CHARGER_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t0, BQ2415X_BIT_CE);\n\tcase BQ2415X_CHARGER_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t1, BQ2415X_BIT_CE);\n\tcase BQ2415X_HIGH_IMPEDANCE_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\tBQ2415X_BIT_HZ_MODE);\n\tcase BQ2415X_HIGH_IMPEDANCE_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t1, BQ2415X_BIT_HZ_MODE);\n\tcase BQ2415X_HIGH_IMPEDANCE_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t0, BQ2415X_BIT_HZ_MODE);\n\tcase BQ2415X_BOOST_MODE_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\tBQ2415X_BIT_OPA_MODE);\n\tcase BQ2415X_BOOST_MODE_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t1, BQ2415X_BIT_OPA_MODE);\n\tcase BQ2415X_BOOST_MODE_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\n\t\t\t\t0, BQ2415X_BIT_OPA_MODE);\n\n\tcase BQ2415X_OTG_LEVEL:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\tBQ2415X_BIT_OTG_PL);\n\tcase BQ2415X_OTG_ACTIVATE_HIGH:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\t1, BQ2415X_BIT_OTG_PL);\n\tcase BQ2415X_OTG_ACTIVATE_LOW:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\t0, BQ2415X_BIT_OTG_PL);\n\tcase BQ2415X_OTG_PIN_STATUS:\n\t\treturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\tBQ2415X_BIT_OTG_EN);\n\tcase BQ2415X_OTG_PIN_ENABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\t1, BQ2415X_BIT_OTG_EN);\n\tcase BQ2415X_OTG_PIN_DISABLE:\n\t\treturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\n\t\t\t\t0, BQ2415X_BIT_OTG_EN);\n\n\tcase BQ2415X_VENDER_CODE:\n\t\treturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\n\t\t\tBQ2415X_MASK_VENDER, BQ2415X_SHIFT_VENDER);\n\tcase BQ2415X_PART_NUMBER:\n\t\treturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\n\t\t\t\tBQ2415X_MASK_PN, BQ2415X_SHIFT_PN);\n\tcase BQ2415X_REVISION:\n\t\treturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\n\t\t\tBQ2415X_MASK_REVISION, BQ2415X_SHIFT_REVISION);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic enum bq2415x_chip bq2415x_detect_chip(struct bq2415x_device *bq)\n{\n\tstruct i2c_client *client = to_i2c_client(bq->dev);\n\tint ret = bq2415x_exec_command(bq, BQ2415X_PART_NUMBER);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (client->addr) {\n\tcase 0x6b:\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tif (bq->chip == BQ24151A)\n\t\t\t\treturn bq->chip;\n\t\t\treturn BQ24151;\n\t\tcase 1:\n\t\t\tif (bq->chip == BQ24150A ||\n\t\t\t\tbq->chip == BQ24152 ||\n\t\t\t\tbq->chip == BQ24155)\n\t\t\t\treturn bq->chip;\n\t\t\treturn BQ24150;\n\t\tcase 2:\n\t\t\tif (bq->chip == BQ24153A)\n\t\t\t\treturn bq->chip;\n\t\t\treturn BQ24153;\n\t\tdefault:\n\t\t\treturn BQUNKNOWN;\n\t\t}\n\t\tbreak;\n\n\tcase 0x6a:\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tif (bq->chip == BQ24156A)\n\t\t\t\treturn bq->chip;\n\t\t\treturn BQ24156;\n\t\tcase 2:\n\t\t\tif (bq->chip == BQ24157S)\n\t\t\t\treturn bq->chip;\n\t\t\treturn BQ24158;\n\t\tdefault:\n\t\t\treturn BQUNKNOWN;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn BQUNKNOWN;\n}\n\n \nstatic int bq2415x_detect_revision(struct bq2415x_device *bq)\n{\n\tint ret = bq2415x_exec_command(bq, BQ2415X_REVISION);\n\tint chip = bq2415x_detect_chip(bq);\n\n\tif (ret < 0 || chip < 0)\n\t\treturn -1;\n\n\tswitch (chip) {\n\tcase BQ24150:\n\tcase BQ24150A:\n\tcase BQ24151:\n\tcase BQ24151A:\n\tcase BQ24152:\n\t\tif (ret >= 0 && ret <= 3)\n\t\t\treturn ret;\n\t\treturn -1;\n\tcase BQ24153:\n\tcase BQ24153A:\n\tcase BQ24156:\n\tcase BQ24156A:\n\tcase BQ24157S:\n\tcase BQ24158:\n\t\tif (ret == 3)\n\t\t\treturn 0;\n\t\telse if (ret == 1)\n\t\t\treturn 1;\n\t\treturn -1;\n\tcase BQ24155:\n\t\tif (ret == 3)\n\t\t\treturn 3;\n\t\treturn -1;\n\tcase BQUNKNOWN:\n\t\treturn -1;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int bq2415x_get_vender_code(struct bq2415x_device *bq)\n{\n\tint ret;\n\n\tret = bq2415x_exec_command(bq, BQ2415X_VENDER_CODE);\n\tif (ret < 0)\n\t\treturn 0;\n\n\t \n\treturn (ret & 0x1) +\n\t       ((ret >> 1) & 0x1) * 10 +\n\t       ((ret >> 2) & 0x1) * 100;\n}\n\n \nstatic void bq2415x_reset_chip(struct bq2415x_device *bq)\n{\n\tbq2415x_i2c_write(bq, BQ2415X_REG_CURRENT, BQ2415X_RESET_CURRENT);\n\tbq2415x_i2c_write(bq, BQ2415X_REG_VOLTAGE, BQ2415X_RESET_VOLTAGE);\n\tbq2415x_i2c_write(bq, BQ2415X_REG_CONTROL, BQ2415X_RESET_CONTROL);\n\tbq2415x_i2c_write(bq, BQ2415X_REG_STATUS, BQ2415X_RESET_STATUS);\n\tbq->timer_error = NULL;\n}\n\n \n\n \nstatic int bq2415x_set_current_limit(struct bq2415x_device *bq, int mA)\n{\n\tint val;\n\n\tif (mA <= 100)\n\t\tval = 0;\n\telse if (mA <= 500)\n\t\tval = 1;\n\telse if (mA <= 800)\n\t\tval = 2;\n\telse\n\t\tval = 3;\n\n\treturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CONTROL, val,\n\t\t\tBQ2415X_MASK_LIMIT, BQ2415X_SHIFT_LIMIT);\n}\n\n \nstatic int bq2415x_get_current_limit(struct bq2415x_device *bq)\n{\n\tint ret;\n\n\tret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CONTROL,\n\t\t\tBQ2415X_MASK_LIMIT, BQ2415X_SHIFT_LIMIT);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == 0)\n\t\treturn 100;\n\telse if (ret == 1)\n\t\treturn 500;\n\telse if (ret == 2)\n\t\treturn 800;\n\telse if (ret == 3)\n\t\treturn 1800;\n\treturn -EINVAL;\n}\n\n \nstatic int bq2415x_set_weak_battery_voltage(struct bq2415x_device *bq, int mV)\n{\n\tint val;\n\n\t \n\tif (mV <= 3400 + 50)\n\t\tval = 0;\n\telse if (mV <= 3500 + 50)\n\t\tval = 1;\n\telse if (mV <= 3600 + 50)\n\t\tval = 2;\n\telse\n\t\tval = 3;\n\n\treturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CONTROL, val,\n\t\t\tBQ2415X_MASK_VLOWV, BQ2415X_SHIFT_VLOWV);\n}\n\n \nstatic int bq2415x_get_weak_battery_voltage(struct bq2415x_device *bq)\n{\n\tint ret;\n\n\tret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CONTROL,\n\t\t\tBQ2415X_MASK_VLOWV, BQ2415X_SHIFT_VLOWV);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 100 * (34 + ret);\n}\n\n \nstatic int bq2415x_set_battery_regulation_voltage(struct bq2415x_device *bq,\n\t\t\t\t\t\t  int mV)\n{\n\tint val = (mV/10 - 350) / 2;\n\n\t \n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 47)\n\t\treturn -EINVAL;\n\n\treturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_VOLTAGE, val,\n\t\t\tBQ2415X_MASK_VO, BQ2415X_SHIFT_VO);\n}\n\n \nstatic int bq2415x_get_battery_regulation_voltage(struct bq2415x_device *bq)\n{\n\tint ret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_VOLTAGE,\n\t\t\tBQ2415X_MASK_VO, BQ2415X_SHIFT_VO);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 10 * (350 + 2*ret);\n}\n\n \nstatic int bq2415x_set_charge_current(struct bq2415x_device *bq, int mA)\n{\n\tint val;\n\n\tif (bq->init_data.resistor_sense <= 0)\n\t\treturn -EINVAL;\n\n\tval = (mA * bq->init_data.resistor_sense - 37400) / 6800;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 7)\n\t\tval = 7;\n\n\treturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CURRENT, val,\n\t\t\tBQ2415X_MASK_VI_CHRG | BQ2415X_MASK_RESET,\n\t\t\tBQ2415X_SHIFT_VI_CHRG);\n}\n\n \nstatic int bq2415x_get_charge_current(struct bq2415x_device *bq)\n{\n\tint ret;\n\n\tif (bq->init_data.resistor_sense <= 0)\n\t\treturn -EINVAL;\n\n\tret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CURRENT,\n\t\t\tBQ2415X_MASK_VI_CHRG, BQ2415X_SHIFT_VI_CHRG);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (37400 + 6800*ret) / bq->init_data.resistor_sense;\n}\n\n \nstatic int bq2415x_set_termination_current(struct bq2415x_device *bq, int mA)\n{\n\tint val;\n\n\tif (bq->init_data.resistor_sense <= 0)\n\t\treturn -EINVAL;\n\n\tval = (mA * bq->init_data.resistor_sense - 3400) / 3400;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 7)\n\t\tval = 7;\n\n\treturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CURRENT, val,\n\t\t\tBQ2415X_MASK_VI_TERM | BQ2415X_MASK_RESET,\n\t\t\tBQ2415X_SHIFT_VI_TERM);\n}\n\n \nstatic int bq2415x_get_termination_current(struct bq2415x_device *bq)\n{\n\tint ret;\n\n\tif (bq->init_data.resistor_sense <= 0)\n\t\treturn -EINVAL;\n\n\tret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CURRENT,\n\t\t\tBQ2415X_MASK_VI_TERM, BQ2415X_SHIFT_VI_TERM);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn (3400 + 3400*ret) / bq->init_data.resistor_sense;\n}\n\n \n#define bq2415x_set_default_value(bq, prop) \\\n\tdo { \\\n\t\tint ret = 0; \\\n\t\tif (bq->init_data.prop != -1) \\\n\t\t\tret = bq2415x_set_##prop(bq, bq->init_data.prop); \\\n\t\tif (ret < 0) \\\n\t\t\treturn ret; \\\n\t} while (0)\n\n \nstatic int bq2415x_set_defaults(struct bq2415x_device *bq)\n{\n\tbq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\n\tbq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\n\tbq2415x_exec_command(bq, BQ2415X_CHARGE_TERMINATION_DISABLE);\n\n\tbq2415x_set_default_value(bq, current_limit);\n\tbq2415x_set_default_value(bq, weak_battery_voltage);\n\tbq2415x_set_default_value(bq, battery_regulation_voltage);\n\n\tif (bq->init_data.resistor_sense > 0) {\n\t\tbq2415x_set_default_value(bq, charge_current);\n\t\tbq2415x_set_default_value(bq, termination_current);\n\t\tbq2415x_exec_command(bq, BQ2415X_CHARGE_TERMINATION_ENABLE);\n\t}\n\n\tbq2415x_exec_command(bq, BQ2415X_CHARGER_ENABLE);\n\treturn 0;\n}\n\n \n\n \nstatic int bq2415x_set_mode(struct bq2415x_device *bq, enum bq2415x_mode mode)\n{\n\tint ret = 0;\n\tint charger = 0;\n\tint boost = 0;\n\n\tif (mode == BQ2415X_MODE_BOOST)\n\t\tboost = 1;\n\telse if (mode != BQ2415X_MODE_OFF)\n\t\tcharger = 1;\n\n\tif (!charger)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\n\n\tif (!boost)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (mode) {\n\tcase BQ2415X_MODE_OFF:\n\t\tdev_dbg(bq->dev, \"changing mode to: Offline\\n\");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\tcase BQ2415X_MODE_NONE:\n\t\tdev_dbg(bq->dev, \"changing mode to: N/A\\n\");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\tcase BQ2415X_MODE_HOST_CHARGER:\n\t\tdev_dbg(bq->dev, \"changing mode to: Host/HUB charger\\n\");\n\t\tret = bq2415x_set_current_limit(bq, 500);\n\t\tbreak;\n\tcase BQ2415X_MODE_DEDICATED_CHARGER:\n\t\tdev_dbg(bq->dev, \"changing mode to: Dedicated charger\\n\");\n\t\tret = bq2415x_set_current_limit(bq, 1800);\n\t\tbreak;\n\tcase BQ2415X_MODE_BOOST:  \n\t\tdev_dbg(bq->dev, \"changing mode to: Boost\\n\");\n\t\tret = bq2415x_set_current_limit(bq, 100);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (charger)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGER_ENABLE);\n\telse if (boost)\n\t\tret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_ENABLE);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbq2415x_set_default_value(bq, weak_battery_voltage);\n\tbq2415x_set_default_value(bq, battery_regulation_voltage);\n\n\tbq->mode = mode;\n\tsysfs_notify(&bq->charger->dev.kobj, NULL, \"mode\");\n\n\treturn 0;\n\n}\n\nstatic bool bq2415x_update_reported_mode(struct bq2415x_device *bq, int mA)\n{\n\tenum bq2415x_mode mode;\n\n\tif (mA == 0)\n\t\tmode = BQ2415X_MODE_OFF;\n\telse if (mA < 500)\n\t\tmode = BQ2415X_MODE_NONE;\n\telse if (mA < 1800)\n\t\tmode = BQ2415X_MODE_HOST_CHARGER;\n\telse\n\t\tmode = BQ2415X_MODE_DEDICATED_CHARGER;\n\n\tif (bq->reported_mode == mode)\n\t\treturn false;\n\n\tbq->reported_mode = mode;\n\treturn true;\n}\n\nstatic int bq2415x_notifier_call(struct notifier_block *nb,\n\t\tunsigned long val, void *v)\n{\n\tstruct bq2415x_device *bq =\n\t\tcontainer_of(nb, struct bq2415x_device, nb);\n\tstruct power_supply *psy = v;\n\tunion power_supply_propval prop;\n\tint ret;\n\n\tif (val != PSY_EVENT_PROP_CHANGED)\n\t\treturn NOTIFY_OK;\n\n\t \n\tif (bq->notify_node) {\n\t\tif (!psy->dev.parent ||\n\t\t    psy->dev.parent->of_node != bq->notify_node)\n\t\t\treturn NOTIFY_OK;\n\t} else if (bq->init_data.notify_device) {\n\t\tif (strcmp(psy->desc->name, bq->init_data.notify_device) != 0)\n\t\t\treturn NOTIFY_OK;\n\t}\n\n\tdev_dbg(bq->dev, \"notifier call was called\\n\");\n\n\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_CURRENT_MAX,\n\t\t\t&prop);\n\tif (ret != 0)\n\t\treturn NOTIFY_OK;\n\n\tif (!bq2415x_update_reported_mode(bq, prop.intval))\n\t\treturn NOTIFY_OK;\n\n\t \n\tif (bq->automode < 1)\n\t\treturn NOTIFY_OK;\n\n\tschedule_delayed_work(&bq->work, 0);\n\n\treturn NOTIFY_OK;\n}\n\n \n\n \nstatic void bq2415x_set_autotimer(struct bq2415x_device *bq, int state)\n{\n\tmutex_lock(&bq2415x_timer_mutex);\n\n\tif (bq->autotimer == state) {\n\t\tmutex_unlock(&bq2415x_timer_mutex);\n\t\treturn;\n\t}\n\n\tbq->autotimer = state;\n\n\tif (state) {\n\t\tschedule_delayed_work(&bq->work, BQ2415X_TIMER_TIMEOUT * HZ);\n\t\tbq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\n\t\tbq->timer_error = NULL;\n\t} else {\n\t\tcancel_delayed_work_sync(&bq->work);\n\t}\n\n\tmutex_unlock(&bq2415x_timer_mutex);\n}\n\n \nstatic void bq2415x_timer_error(struct bq2415x_device *bq, const char *msg)\n{\n\tbq->timer_error = msg;\n\tsysfs_notify(&bq->charger->dev.kobj, NULL, \"timer\");\n\tdev_err(bq->dev, \"%s\\n\", msg);\n\tif (bq->automode > 0)\n\t\tbq->automode = 0;\n\tbq2415x_set_mode(bq, BQ2415X_MODE_OFF);\n\tbq2415x_set_autotimer(bq, 0);\n}\n\n \nstatic void bq2415x_timer_work(struct work_struct *work)\n{\n\tstruct bq2415x_device *bq = container_of(work, struct bq2415x_device,\n\t\t\t\t\t\t work.work);\n\tint ret;\n\tint error;\n\tint boost;\n\n\tif (bq->automode > 0 && (bq->reported_mode != bq->mode)) {\n\t\tsysfs_notify(&bq->charger->dev.kobj, NULL, \"reported_mode\");\n\t\tbq2415x_set_mode(bq, bq->reported_mode);\n\t}\n\n\tif (!bq->autotimer)\n\t\treturn;\n\n\tret = bq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\n\tif (ret < 0) {\n\t\tbq2415x_timer_error(bq, \"Resetting timer failed\");\n\t\treturn;\n\t}\n\n\tboost = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_STATUS);\n\tif (boost < 0) {\n\t\tbq2415x_timer_error(bq, \"Unknown error\");\n\t\treturn;\n\t}\n\n\terror = bq2415x_exec_command(bq, BQ2415X_FAULT_STATUS);\n\tif (error < 0) {\n\t\tbq2415x_timer_error(bq, \"Unknown error\");\n\t\treturn;\n\t}\n\n\tif (boost) {\n\t\tswitch (error) {\n\t\t \n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\tdev_err(bq->dev, \"Timer expired\\n\");\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tdev_err(bq->dev, \"Battery voltage to low\\n\");\n\t\t\tbreak;\n\n\t\t \n\t\tcase 1:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\"Overvoltage protection (chip fried)\");\n\t\t\treturn;\n\t\tcase 2:  \n\t\t\tbq2415x_timer_error(bq, \"Overload\");\n\t\t\treturn;\n\t\tcase 4:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\"Battery overvoltage protection\");\n\t\t\treturn;\n\t\tcase 5:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\t\"Thermal shutdown (too hot)\");\n\t\t\treturn;\n\t\tcase 7:  \n\t\t\tbq2415x_timer_error(bq, \"Unknown error\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (error) {\n\t\t \n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tdev_err(bq->dev, \"Sleep mode\\n\");\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tdev_err(bq->dev, \"Poor input source\\n\");\n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\tdev_err(bq->dev, \"Timer expired\\n\");\n\t\t\tbreak;\n\t\tcase 7:  \n\t\t\tdev_err(bq->dev, \"No battery\\n\");\n\t\t\tbreak;\n\n\t\t \n\t\tcase 1:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\"Overvoltage protection (chip fried)\");\n\t\t\treturn;\n\t\tcase 4:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\"Battery overvoltage protection\");\n\t\t\treturn;\n\t\tcase 5:  \n\t\t\tbq2415x_timer_error(bq,\n\t\t\t\t\"Thermal shutdown (too hot)\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tschedule_delayed_work(&bq->work, BQ2415X_TIMER_TIMEOUT * HZ);\n}\n\n \n\nstatic enum power_supply_property bq2415x_power_supply_props[] = {\n\t \n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n};\n\nstatic int bq2415x_power_supply_get_property(struct power_supply *psy,\n\t\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq2415x_exec_command(bq, BQ2415X_CHARGE_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == 0)  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse if (ret == 1)  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (ret == 2)  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bq->model;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void bq2415x_power_supply_exit(struct bq2415x_device *bq)\n{\n\tbq->autotimer = 0;\n\tif (bq->automode > 0)\n\t\tbq->automode = 0;\n\tcancel_delayed_work_sync(&bq->work);\n\tpower_supply_unregister(bq->charger);\n\tkfree(bq->model);\n}\n\n \n\n \nstatic ssize_t bq2415x_sysfs_show_status(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tenum bq2415x_command command;\n\tint ret;\n\n\tif (strcmp(attr->attr.name, \"otg_status\") == 0)\n\t\tcommand = BQ2415X_OTG_STATUS;\n\telse if (strcmp(attr->attr.name, \"charge_status\") == 0)\n\t\tcommand = BQ2415X_CHARGE_STATUS;\n\telse if (strcmp(attr->attr.name, \"boost_status\") == 0)\n\t\tcommand = BQ2415X_BOOST_STATUS;\n\telse if (strcmp(attr->attr.name, \"fault_status\") == 0)\n\t\tcommand = BQ2415X_FAULT_STATUS;\n\telse\n\t\treturn -EINVAL;\n\n\tret = bq2415x_exec_command(bq, command);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\n \nstatic ssize_t bq2415x_sysfs_set_timer(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf,\n\t\t\t\t       size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tif (strncmp(buf, \"auto\", 4) == 0)\n\t\tbq2415x_set_autotimer(bq, 1);\n\telse if (strncmp(buf, \"off\", 3) == 0)\n\t\tbq2415x_set_autotimer(bq, 0);\n\telse\n\t\tret = bq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_timer(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\n\tif (bq->timer_error)\n\t\treturn sysfs_emit(buf, \"%s\\n\", bq->timer_error);\n\n\tif (bq->autotimer)\n\t\treturn sysfs_emit(buf, \"auto\\n\");\n\treturn sysfs_emit(buf, \"off\\n\");\n}\n\n \nstatic ssize_t bq2415x_sysfs_set_mode(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf,\n\t\t\t\t      size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tenum bq2415x_mode mode;\n\tint ret = 0;\n\n\tif (strncmp(buf, \"auto\", 4) == 0) {\n\t\tif (bq->automode < 0)\n\t\t\treturn -EINVAL;\n\t\tbq->automode = 1;\n\t\tmode = bq->reported_mode;\n\t} else if (strncmp(buf, \"off\", 3) == 0) {\n\t\tif (bq->automode > 0)\n\t\t\tbq->automode = 0;\n\t\tmode = BQ2415X_MODE_OFF;\n\t} else if (strncmp(buf, \"none\", 4) == 0) {\n\t\tif (bq->automode > 0)\n\t\t\tbq->automode = 0;\n\t\tmode = BQ2415X_MODE_NONE;\n\t} else if (strncmp(buf, \"host\", 4) == 0) {\n\t\tif (bq->automode > 0)\n\t\t\tbq->automode = 0;\n\t\tmode = BQ2415X_MODE_HOST_CHARGER;\n\t} else if (strncmp(buf, \"dedicated\", 9) == 0) {\n\t\tif (bq->automode > 0)\n\t\t\tbq->automode = 0;\n\t\tmode = BQ2415X_MODE_DEDICATED_CHARGER;\n\t} else if (strncmp(buf, \"boost\", 5) == 0) {\n\t\tif (bq->automode > 0)\n\t\t\tbq->automode = 0;\n\t\tmode = BQ2415X_MODE_BOOST;\n\t} else if (strncmp(buf, \"reset\", 5) == 0) {\n\t\tbq2415x_reset_chip(bq);\n\t\tbq2415x_set_defaults(bq);\n\t\tif (bq->automode <= 0)\n\t\t\treturn count;\n\t\tbq->automode = 1;\n\t\tmode = bq->reported_mode;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = bq2415x_set_mode(bq, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_mode(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tssize_t ret = 0;\n\n\tif (bq->automode > 0)\n\t\tret += sysfs_emit_at(buf, ret, \"auto (\");\n\n\tswitch (bq->mode) {\n\tcase BQ2415X_MODE_OFF:\n\t\tret += sysfs_emit_at(buf, ret, \"off\");\n\t\tbreak;\n\tcase BQ2415X_MODE_NONE:\n\t\tret += sysfs_emit_at(buf, ret, \"none\");\n\t\tbreak;\n\tcase BQ2415X_MODE_HOST_CHARGER:\n\t\tret += sysfs_emit_at(buf, ret, \"host\");\n\t\tbreak;\n\tcase BQ2415X_MODE_DEDICATED_CHARGER:\n\t\tret += sysfs_emit_at(buf, ret, \"dedicated\");\n\t\tbreak;\n\tcase BQ2415X_MODE_BOOST:\n\t\tret += sysfs_emit_at(buf, ret, \"boost\");\n\t\tbreak;\n\t}\n\n\tif (bq->automode > 0)\n\t\tret += sysfs_emit_at(buf, ret, \")\");\n\n\tret += sysfs_emit_at(buf, ret, \"\\n\");\n\treturn ret;\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_reported_mode(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\n\tif (bq->automode < 0)\n\t\treturn -EINVAL;\n\n\tswitch (bq->reported_mode) {\n\tcase BQ2415X_MODE_OFF:\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\tcase BQ2415X_MODE_NONE:\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\tcase BQ2415X_MODE_HOST_CHARGER:\n\t\treturn sysfs_emit(buf, \"host\\n\");\n\tcase BQ2415X_MODE_DEDICATED_CHARGER:\n\t\treturn sysfs_emit(buf, \"dedicated\\n\");\n\tcase BQ2415X_MODE_BOOST:\n\t\treturn sysfs_emit(buf, \"boost\\n\");\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t bq2415x_sysfs_set_registers(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf,\n\t\t\t\t\t   size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tssize_t ret = 0;\n\tunsigned int reg;\n\tunsigned int val;\n\n\tif (sscanf(buf, \"%x %x\", &reg, &val) != 2)\n\t\treturn -EINVAL;\n\n\tif (reg > 4 || val > 255)\n\t\treturn -EINVAL;\n\n\tret = bq2415x_i2c_write(bq, reg, val);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nstatic ssize_t bq2415x_sysfs_print_reg(struct bq2415x_device *bq,\n\t\t\t\t       u8 reg,\n\t\t\t\t       char *buf)\n{\n\tint ret = bq2415x_i2c_read(bq, reg);\n\n\tif (ret < 0)\n\t\treturn sysfs_emit(buf, \"%#.2x=error %d\\n\", reg, ret);\n\treturn sysfs_emit(buf, \"%#.2x=%#.2x\\n\", reg, ret);\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_registers(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tssize_t ret = 0;\n\n\tret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_STATUS, buf+ret);\n\tret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_CONTROL, buf+ret);\n\tret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_VOLTAGE, buf+ret);\n\tret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_VENDER, buf+ret);\n\tret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_CURRENT, buf+ret);\n\treturn ret;\n}\n\n \nstatic ssize_t bq2415x_sysfs_set_limit(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf,\n\t\t\t\t       size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tlong val;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (strcmp(attr->attr.name, \"current_limit\") == 0)\n\t\tret = bq2415x_set_current_limit(bq, val);\n\telse if (strcmp(attr->attr.name, \"weak_battery_voltage\") == 0)\n\t\tret = bq2415x_set_weak_battery_voltage(bq, val);\n\telse if (strcmp(attr->attr.name, \"battery_regulation_voltage\") == 0)\n\t\tret = bq2415x_set_battery_regulation_voltage(bq, val);\n\telse if (strcmp(attr->attr.name, \"charge_current\") == 0)\n\t\tret = bq2415x_set_charge_current(bq, val);\n\telse if (strcmp(attr->attr.name, \"termination_current\") == 0)\n\t\tret = bq2415x_set_termination_current(bq, val);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_limit(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tif (strcmp(attr->attr.name, \"current_limit\") == 0)\n\t\tret = bq2415x_get_current_limit(bq);\n\telse if (strcmp(attr->attr.name, \"weak_battery_voltage\") == 0)\n\t\tret = bq2415x_get_weak_battery_voltage(bq);\n\telse if (strcmp(attr->attr.name, \"battery_regulation_voltage\") == 0)\n\t\tret = bq2415x_get_battery_regulation_voltage(bq);\n\telse if (strcmp(attr->attr.name, \"charge_current\") == 0)\n\t\tret = bq2415x_get_charge_current(bq);\n\telse if (strcmp(attr->attr.name, \"termination_current\") == 0)\n\t\tret = bq2415x_get_termination_current(bq);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\n \nstatic ssize_t bq2415x_sysfs_set_enable(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf,\n\t\t\t\t\tsize_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tenum bq2415x_command command;\n\tlong val;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (strcmp(attr->attr.name, \"charge_termination_enable\") == 0)\n\t\tcommand = val ? BQ2415X_CHARGE_TERMINATION_ENABLE :\n\t\t\tBQ2415X_CHARGE_TERMINATION_DISABLE;\n\telse if (strcmp(attr->attr.name, \"high_impedance_enable\") == 0)\n\t\tcommand = val ? BQ2415X_HIGH_IMPEDANCE_ENABLE :\n\t\t\tBQ2415X_HIGH_IMPEDANCE_DISABLE;\n\telse if (strcmp(attr->attr.name, \"otg_pin_enable\") == 0)\n\t\tcommand = val ? BQ2415X_OTG_PIN_ENABLE :\n\t\t\tBQ2415X_OTG_PIN_DISABLE;\n\telse if (strcmp(attr->attr.name, \"stat_pin_enable\") == 0)\n\t\tcommand = val ? BQ2415X_STAT_PIN_ENABLE :\n\t\t\tBQ2415X_STAT_PIN_DISABLE;\n\telse\n\t\treturn -EINVAL;\n\n\tret = bq2415x_exec_command(bq, command);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nstatic ssize_t bq2415x_sysfs_show_enable(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq2415x_device *bq = power_supply_get_drvdata(psy);\n\tenum bq2415x_command command;\n\tint ret;\n\n\tif (strcmp(attr->attr.name, \"charge_termination_enable\") == 0)\n\t\tcommand = BQ2415X_CHARGE_TERMINATION_STATUS;\n\telse if (strcmp(attr->attr.name, \"high_impedance_enable\") == 0)\n\t\tcommand = BQ2415X_HIGH_IMPEDANCE_STATUS;\n\telse if (strcmp(attr->attr.name, \"otg_pin_enable\") == 0)\n\t\tcommand = BQ2415X_OTG_PIN_STATUS;\n\telse if (strcmp(attr->attr.name, \"stat_pin_enable\") == 0)\n\t\tcommand = BQ2415X_STAT_PIN_STATUS;\n\telse\n\t\treturn -EINVAL;\n\n\tret = bq2415x_exec_command(bq, command);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sysfs_emit(buf, \"%d\\n\", ret);\n}\n\nstatic DEVICE_ATTR(current_limit, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_limit, bq2415x_sysfs_set_limit);\nstatic DEVICE_ATTR(weak_battery_voltage, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_limit, bq2415x_sysfs_set_limit);\nstatic DEVICE_ATTR(battery_regulation_voltage, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_limit, bq2415x_sysfs_set_limit);\nstatic DEVICE_ATTR(charge_current, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_limit, bq2415x_sysfs_set_limit);\nstatic DEVICE_ATTR(termination_current, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_limit, bq2415x_sysfs_set_limit);\n\nstatic DEVICE_ATTR(charge_termination_enable, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_enable, bq2415x_sysfs_set_enable);\nstatic DEVICE_ATTR(high_impedance_enable, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_enable, bq2415x_sysfs_set_enable);\nstatic DEVICE_ATTR(otg_pin_enable, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_enable, bq2415x_sysfs_set_enable);\nstatic DEVICE_ATTR(stat_pin_enable, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_enable, bq2415x_sysfs_set_enable);\n\nstatic DEVICE_ATTR(reported_mode, S_IRUGO,\n\t\tbq2415x_sysfs_show_reported_mode, NULL);\nstatic DEVICE_ATTR(mode, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_mode, bq2415x_sysfs_set_mode);\nstatic DEVICE_ATTR(timer, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_timer, bq2415x_sysfs_set_timer);\n\nstatic DEVICE_ATTR(registers, S_IWUSR | S_IRUGO,\n\t\tbq2415x_sysfs_show_registers, bq2415x_sysfs_set_registers);\n\nstatic DEVICE_ATTR(otg_status, S_IRUGO, bq2415x_sysfs_show_status, NULL);\nstatic DEVICE_ATTR(charge_status, S_IRUGO, bq2415x_sysfs_show_status, NULL);\nstatic DEVICE_ATTR(boost_status, S_IRUGO, bq2415x_sysfs_show_status, NULL);\nstatic DEVICE_ATTR(fault_status, S_IRUGO, bq2415x_sysfs_show_status, NULL);\n\nstatic struct attribute *bq2415x_sysfs_attrs[] = {\n\t \n\t&dev_attr_current_limit.attr,\n\t&dev_attr_weak_battery_voltage.attr,\n\t&dev_attr_battery_regulation_voltage.attr,\n\t&dev_attr_charge_current.attr,\n\t&dev_attr_termination_current.attr,\n\n\t&dev_attr_charge_termination_enable.attr,\n\t&dev_attr_high_impedance_enable.attr,\n\t&dev_attr_otg_pin_enable.attr,\n\t&dev_attr_stat_pin_enable.attr,\n\n\t&dev_attr_reported_mode.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_timer.attr,\n\n\t&dev_attr_registers.attr,\n\n\t&dev_attr_otg_status.attr,\n\t&dev_attr_charge_status.attr,\n\t&dev_attr_boost_status.attr,\n\t&dev_attr_fault_status.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(bq2415x_sysfs);\n\nstatic int bq2415x_power_supply_init(struct bq2415x_device *bq)\n{\n\tint ret;\n\tint chip;\n\tchar revstr[8];\n\tstruct power_supply_config psy_cfg = {\n\t\t.drv_data = bq,\n\t\t.of_node = bq->dev->of_node,\n\t\t.attr_grp = bq2415x_sysfs_groups,\n\t};\n\n\tbq->charger_desc.name = bq->name;\n\tbq->charger_desc.type = POWER_SUPPLY_TYPE_USB;\n\tbq->charger_desc.properties = bq2415x_power_supply_props;\n\tbq->charger_desc.num_properties =\n\t\t\tARRAY_SIZE(bq2415x_power_supply_props);\n\tbq->charger_desc.get_property = bq2415x_power_supply_get_property;\n\n\tret = bq2415x_detect_chip(bq);\n\tif (ret < 0)\n\t\tchip = BQUNKNOWN;\n\telse\n\t\tchip = ret;\n\n\tret = bq2415x_detect_revision(bq);\n\tif (ret < 0)\n\t\tstrcpy(revstr, \"unknown\");\n\telse\n\t\tsprintf(revstr, \"1.%d\", ret);\n\n\tbq->model = kasprintf(GFP_KERNEL,\n\t\t\t\t\"chip %s, revision %s, vender code %.3d\",\n\t\t\t\tbq2415x_chip_name[chip], revstr,\n\t\t\t\tbq2415x_get_vender_code(bq));\n\tif (!bq->model) {\n\t\tdev_err(bq->dev, \"failed to allocate model name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbq->charger = power_supply_register(bq->dev, &bq->charger_desc,\n\t\t\t\t\t    &psy_cfg);\n\tif (IS_ERR(bq->charger)) {\n\t\tkfree(bq->model);\n\t\treturn PTR_ERR(bq->charger);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bq2415x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint ret;\n\tint num;\n\tchar *name = NULL;\n\tstruct bq2415x_device *bq;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct bq2415x_platform_data *pdata = client->dev.platform_data;\n\tconst struct acpi_device_id *acpi_id = NULL;\n\tstruct power_supply *notify_psy = NULL;\n\tunion power_supply_propval prop;\n\n\tif (!np && !pdata && !ACPI_HANDLE(&client->dev)) {\n\t\tdev_err(&client->dev, \"Neither devicetree, nor platform data, nor ACPI support\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmutex_lock(&bq2415x_id_mutex);\n\tnum = idr_alloc(&bq2415x_id, client, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&bq2415x_id_mutex);\n\tif (num < 0)\n\t\treturn num;\n\n\tif (id) {\n\t\tname = kasprintf(GFP_KERNEL, \"%s-%d\", id->name, num);\n\t} else if (ACPI_HANDLE(&client->dev)) {\n\t\tacpi_id =\n\t\t\tacpi_match_device(client->dev.driver->acpi_match_table,\n\t\t\t\t\t  &client->dev);\n\t\tif (!acpi_id) {\n\t\t\tdev_err(&client->dev, \"failed to match device name\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto error_1;\n\t\t}\n\t\tname = kasprintf(GFP_KERNEL, \"%s-%d\", acpi_id->id, num);\n\t}\n\tif (!name) {\n\t\tdev_err(&client->dev, \"failed to allocate device name\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_1;\n\t}\n\n\tbq = devm_kzalloc(&client->dev, sizeof(*bq), GFP_KERNEL);\n\tif (!bq) {\n\t\tret = -ENOMEM;\n\t\tgoto error_2;\n\t}\n\n\ti2c_set_clientdata(client, bq);\n\n\tbq->id = num;\n\tbq->dev = &client->dev;\n\tif (id)\n\t\tbq->chip = id->driver_data;\n\telse if (ACPI_HANDLE(bq->dev))\n\t\tbq->chip = acpi_id->driver_data;\n\tbq->name = name;\n\tbq->mode = BQ2415X_MODE_OFF;\n\tbq->reported_mode = BQ2415X_MODE_OFF;\n\tbq->autotimer = 0;\n\tbq->automode = 0;\n\n\tif (np || ACPI_HANDLE(bq->dev)) {\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\t       \"ti,current-limit\",\n\t\t\t\t\t       &bq->init_data.current_limit);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\t\"ti,weak-battery-voltage\",\n\t\t\t\t\t&bq->init_data.weak_battery_voltage);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\"ti,battery-regulation-voltage\",\n\t\t\t\t&bq->init_data.battery_regulation_voltage);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\t       \"ti,charge-current\",\n\t\t\t\t\t       &bq->init_data.charge_current);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\"ti,termination-current\",\n\t\t\t\t&bq->init_data.termination_current);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tret = device_property_read_u32(bq->dev,\n\t\t\t\t\t       \"ti,resistor-sense\",\n\t\t\t\t\t       &bq->init_data.resistor_sense);\n\t\tif (ret)\n\t\t\tgoto error_2;\n\t\tif (np)\n\t\t\tbq->notify_node = of_parse_phandle(np,\n\t\t\t\t\t\t\"ti,usb-charger-detection\", 0);\n\t} else {\n\t\tmemcpy(&bq->init_data, pdata, sizeof(bq->init_data));\n\t}\n\n\tbq2415x_reset_chip(bq);\n\n\tret = bq2415x_power_supply_init(bq);\n\tif (ret) {\n\t\tdev_err(bq->dev, \"failed to register power supply: %d\\n\", ret);\n\t\tgoto error_2;\n\t}\n\n\tret = bq2415x_set_defaults(bq);\n\tif (ret) {\n\t\tdev_err(bq->dev, \"failed to set default values: %d\\n\", ret);\n\t\tgoto error_3;\n\t}\n\n\tif (bq->notify_node || bq->init_data.notify_device) {\n\t\tbq->nb.notifier_call = bq2415x_notifier_call;\n\t\tret = power_supply_reg_notifier(&bq->nb);\n\t\tif (ret) {\n\t\t\tdev_err(bq->dev, \"failed to reg notifier: %d\\n\", ret);\n\t\t\tgoto error_3;\n\t\t}\n\n\t\tbq->automode = 1;\n\t\tdev_info(bq->dev, \"automode supported, waiting for events\\n\");\n\t} else {\n\t\tbq->automode = -1;\n\t\tdev_info(bq->dev, \"automode not supported\\n\");\n\t}\n\n\t \n\tif (bq->nb.notifier_call) {\n\t\tif (np) {\n\t\t\tnotify_psy = power_supply_get_by_phandle(np,\n\t\t\t\t\t\t\"ti,usb-charger-detection\");\n\t\t\tif (IS_ERR(notify_psy))\n\t\t\t\tnotify_psy = NULL;\n\t\t} else if (bq->init_data.notify_device) {\n\t\t\tnotify_psy = power_supply_get_by_name(\n\t\t\t\t\t\tbq->init_data.notify_device);\n\t\t}\n\t}\n\tif (notify_psy) {\n\t\tret = power_supply_get_property(notify_psy,\n\t\t\t\t\tPOWER_SUPPLY_PROP_CURRENT_MAX, &prop);\n\t\tpower_supply_put(notify_psy);\n\n\t\tif (ret == 0) {\n\t\t\tbq2415x_update_reported_mode(bq, prop.intval);\n\t\t\tbq2415x_set_mode(bq, bq->reported_mode);\n\t\t}\n\t}\n\n\tINIT_DELAYED_WORK(&bq->work, bq2415x_timer_work);\n\tbq2415x_set_autotimer(bq, 1);\n\n\tdev_info(bq->dev, \"driver registered\\n\");\n\treturn 0;\n\nerror_3:\n\tbq2415x_power_supply_exit(bq);\nerror_2:\n\tif (bq)\n\t\tof_node_put(bq->notify_node);\n\tkfree(name);\nerror_1:\n\tmutex_lock(&bq2415x_id_mutex);\n\tidr_remove(&bq2415x_id, num);\n\tmutex_unlock(&bq2415x_id_mutex);\n\n\treturn ret;\n}\n\n \n\nstatic void bq2415x_remove(struct i2c_client *client)\n{\n\tstruct bq2415x_device *bq = i2c_get_clientdata(client);\n\n\tif (bq->nb.notifier_call)\n\t\tpower_supply_unreg_notifier(&bq->nb);\n\n\tof_node_put(bq->notify_node);\n\tbq2415x_power_supply_exit(bq);\n\n\tbq2415x_reset_chip(bq);\n\n\tmutex_lock(&bq2415x_id_mutex);\n\tidr_remove(&bq2415x_id, bq->id);\n\tmutex_unlock(&bq2415x_id_mutex);\n\n\tdev_info(bq->dev, \"driver unregistered\\n\");\n\n\tkfree(bq->name);\n}\n\nstatic const struct i2c_device_id bq2415x_i2c_id_table[] = {\n\t{ \"bq2415x\", BQUNKNOWN },\n\t{ \"bq24150\", BQ24150 },\n\t{ \"bq24150a\", BQ24150A },\n\t{ \"bq24151\", BQ24151 },\n\t{ \"bq24151a\", BQ24151A },\n\t{ \"bq24152\", BQ24152 },\n\t{ \"bq24153\", BQ24153 },\n\t{ \"bq24153a\", BQ24153A },\n\t{ \"bq24155\", BQ24155 },\n\t{ \"bq24156\", BQ24156 },\n\t{ \"bq24156a\", BQ24156A },\n\t{ \"bq24157s\", BQ24157S },\n\t{ \"bq24158\", BQ24158 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, bq2415x_i2c_id_table);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id bq2415x_i2c_acpi_match[] = {\n\t{ \"BQ2415X\", BQUNKNOWN },\n\t{ \"BQ241500\", BQ24150 },\n\t{ \"BQA24150\", BQ24150A },\n\t{ \"BQ241510\", BQ24151 },\n\t{ \"BQA24151\", BQ24151A },\n\t{ \"BQ241520\", BQ24152 },\n\t{ \"BQ241530\", BQ24153 },\n\t{ \"BQA24153\", BQ24153A },\n\t{ \"BQ241550\", BQ24155 },\n\t{ \"BQ241560\", BQ24156 },\n\t{ \"BQA24156\", BQ24156A },\n\t{ \"BQS24157\", BQ24157S },\n\t{ \"BQ241580\", BQ24158 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, bq2415x_i2c_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id bq2415x_of_match_table[] = {\n\t{ .compatible = \"ti,bq24150\" },\n\t{ .compatible = \"ti,bq24150a\" },\n\t{ .compatible = \"ti,bq24151\" },\n\t{ .compatible = \"ti,bq24151a\" },\n\t{ .compatible = \"ti,bq24152\" },\n\t{ .compatible = \"ti,bq24153\" },\n\t{ .compatible = \"ti,bq24153a\" },\n\t{ .compatible = \"ti,bq24155\" },\n\t{ .compatible = \"ti,bq24156\" },\n\t{ .compatible = \"ti,bq24156a\" },\n\t{ .compatible = \"ti,bq24157s\" },\n\t{ .compatible = \"ti,bq24158\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bq2415x_of_match_table);\n#endif\n\nstatic struct i2c_driver bq2415x_driver = {\n\t.driver = {\n\t\t.name = \"bq2415x-charger\",\n\t\t.of_match_table = of_match_ptr(bq2415x_of_match_table),\n\t\t.acpi_match_table = ACPI_PTR(bq2415x_i2c_acpi_match),\n\t},\n\t.probe = bq2415x_probe,\n\t.remove = bq2415x_remove,\n\t.id_table = bq2415x_i2c_id_table,\n};\nmodule_i2c_driver(bq2415x_driver);\n\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_DESCRIPTION(\"bq2415x charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}