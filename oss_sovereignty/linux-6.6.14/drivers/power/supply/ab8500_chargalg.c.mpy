{
  "module_name": "ab8500_chargalg.c",
  "hash_id": "97c9bfd65a7547213e6510319b745a5fdc3eaf2d1e4b2428891a10d49d694813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/ab8500_chargalg.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/component.h>\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/of.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/notifier.h>\n\n#include \"ab8500-bm.h\"\n#include \"ab8500-chargalg.h\"\n\n \n#define CHG_WD_INTERVAL\t\t\t(6 * HZ)\n\n \n#define EOC_COND_CNT\t\t\t10\n\n \n#define ONE_HOUR_IN_SECONDS            3600\n\n \n#define FIVE_MINUTES_IN_SECONDS        300\n\n \n#define AB8500_RECHARGE_CAP\t\t95\n\nenum ab8500_chargers {\n\tNO_CHG,\n\tAC_CHG,\n\tUSB_CHG,\n};\n\nstruct ab8500_chargalg_charger_info {\n\tenum ab8500_chargers conn_chg;\n\tenum ab8500_chargers prev_conn_chg;\n\tenum ab8500_chargers online_chg;\n\tenum ab8500_chargers prev_online_chg;\n\tenum ab8500_chargers charger_type;\n\tbool usb_chg_ok;\n\tbool ac_chg_ok;\n\tint usb_volt_uv;\n\tint usb_curr_ua;\n\tint ac_volt_uv;\n\tint ac_curr_ua;\n\tint usb_vset_uv;\n\tint usb_iset_ua;\n\tint ac_vset_uv;\n\tint ac_iset_ua;\n};\n\nstruct ab8500_chargalg_battery_data {\n\tint temp;\n\tint volt_uv;\n\tint avg_curr_ua;\n\tint inst_curr_ua;\n\tint percent;\n};\n\nenum ab8500_chargalg_states {\n\tSTATE_HANDHELD_INIT,\n\tSTATE_HANDHELD,\n\tSTATE_CHG_NOT_OK_INIT,\n\tSTATE_CHG_NOT_OK,\n\tSTATE_HW_TEMP_PROTECT_INIT,\n\tSTATE_HW_TEMP_PROTECT,\n\tSTATE_NORMAL_INIT,\n\tSTATE_NORMAL,\n\tSTATE_WAIT_FOR_RECHARGE_INIT,\n\tSTATE_WAIT_FOR_RECHARGE,\n\tSTATE_MAINTENANCE_A_INIT,\n\tSTATE_MAINTENANCE_A,\n\tSTATE_MAINTENANCE_B_INIT,\n\tSTATE_MAINTENANCE_B,\n\tSTATE_TEMP_UNDEROVER_INIT,\n\tSTATE_TEMP_UNDEROVER,\n\tSTATE_TEMP_LOWHIGH_INIT,\n\tSTATE_TEMP_LOWHIGH,\n\tSTATE_OVV_PROTECT_INIT,\n\tSTATE_OVV_PROTECT,\n\tSTATE_SAFETY_TIMER_EXPIRED_INIT,\n\tSTATE_SAFETY_TIMER_EXPIRED,\n\tSTATE_BATT_REMOVED_INIT,\n\tSTATE_BATT_REMOVED,\n\tSTATE_WD_EXPIRED_INIT,\n\tSTATE_WD_EXPIRED,\n};\n\nstatic const char * const states[] = {\n\t\"HANDHELD_INIT\",\n\t\"HANDHELD\",\n\t\"CHG_NOT_OK_INIT\",\n\t\"CHG_NOT_OK\",\n\t\"HW_TEMP_PROTECT_INIT\",\n\t\"HW_TEMP_PROTECT\",\n\t\"NORMAL_INIT\",\n\t\"NORMAL\",\n\t\"WAIT_FOR_RECHARGE_INIT\",\n\t\"WAIT_FOR_RECHARGE\",\n\t\"MAINTENANCE_A_INIT\",\n\t\"MAINTENANCE_A\",\n\t\"MAINTENANCE_B_INIT\",\n\t\"MAINTENANCE_B\",\n\t\"TEMP_UNDEROVER_INIT\",\n\t\"TEMP_UNDEROVER\",\n\t\"TEMP_LOWHIGH_INIT\",\n\t\"TEMP_LOWHIGH\",\n\t\"OVV_PROTECT_INIT\",\n\t\"OVV_PROTECT\",\n\t\"SAFETY_TIMER_EXPIRED_INIT\",\n\t\"SAFETY_TIMER_EXPIRED\",\n\t\"BATT_REMOVED_INIT\",\n\t\"BATT_REMOVED\",\n\t\"WD_EXPIRED_INIT\",\n\t\"WD_EXPIRED\",\n};\n\nstruct ab8500_chargalg_events {\n\tbool batt_unknown;\n\tbool mainextchnotok;\n\tbool batt_ovv;\n\tbool batt_rem;\n\tbool btemp_underover;\n\tbool btemp_low;\n\tbool btemp_high;\n\tbool main_thermal_prot;\n\tbool usb_thermal_prot;\n\tbool main_ovv;\n\tbool vbus_ovv;\n\tbool usbchargernotok;\n\tbool safety_timer_expired;\n\tbool maintenance_timer_expired;\n\tbool ac_wd_expired;\n\tbool usb_wd_expired;\n\tbool ac_cv_active;\n\tbool usb_cv_active;\n\tbool vbus_collapsed;\n};\n\n \nstruct ab8500_charge_curr_maximization {\n\tint original_iset_ua;\n\tint current_iset_ua;\n\tint condition_cnt;\n\tint max_current_ua;\n\tint wait_cnt;\n\tu8 level;\n};\n\nenum maxim_ret {\n\tMAXIM_RET_NOACTION,\n\tMAXIM_RET_CHANGE,\n\tMAXIM_RET_IBAT_TOO_HIGH,\n};\n\n \nstruct ab8500_chargalg {\n\tstruct device *dev;\n\tint charge_status;\n\tint eoc_cnt;\n\tbool maintenance_chg;\n\tint t_hyst_norm;\n\tint t_hyst_lowhigh;\n\tenum ab8500_chargalg_states charge_state;\n\tstruct ab8500_charge_curr_maximization ccm;\n\tstruct ab8500_chargalg_charger_info chg_info;\n\tstruct ab8500_chargalg_battery_data batt_data;\n\tstruct ab8500 *parent;\n\tstruct ab8500_bm_data *bm;\n\tstruct power_supply *chargalg_psy;\n\tstruct ux500_charger *ac_chg;\n\tstruct ux500_charger *usb_chg;\n\tstruct ab8500_chargalg_events events;\n\tstruct workqueue_struct *chargalg_wq;\n\tstruct delayed_work chargalg_periodic_work;\n\tstruct delayed_work chargalg_wd_work;\n\tstruct work_struct chargalg_work;\n\tstruct hrtimer safety_timer;\n\tstruct hrtimer maintenance_timer;\n\tstruct kobject chargalg_kobject;\n};\n\n \nstatic enum power_supply_property ab8500_chargalg_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n};\n\n \nstatic enum hrtimer_restart\nab8500_chargalg_safety_timer_expired(struct hrtimer *timer)\n{\n\tstruct ab8500_chargalg *di = container_of(timer, struct ab8500_chargalg,\n\t\t\t\t\t\t  safety_timer);\n\tdev_err(di->dev, \"Safety timer expired\\n\");\n\tdi->events.safety_timer_expired = true;\n\n\t \n\tqueue_work(di->chargalg_wq, &di->chargalg_work);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic enum hrtimer_restart\nab8500_chargalg_maintenance_timer_expired(struct hrtimer *timer)\n{\n\n\tstruct ab8500_chargalg *di = container_of(timer, struct ab8500_chargalg,\n\t\t\t\t\t\t  maintenance_timer);\n\n\tdev_dbg(di->dev, \"Maintenance timer expired\\n\");\n\tdi->events.maintenance_timer_expired = true;\n\n\t \n\tqueue_work(di->chargalg_wq, &di->chargalg_work);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic void ab8500_chargalg_state_to(struct ab8500_chargalg *di,\n\tenum ab8500_chargalg_states state)\n{\n\tdev_dbg(di->dev,\n\t\t\"State changed: %s (From state: [%d] %s =to=> [%d] %s )\\n\",\n\t\tdi->charge_state == state ? \"NO\" : \"YES\",\n\t\tdi->charge_state,\n\t\tstates[di->charge_state],\n\t\tstate,\n\t\tstates[state]);\n\n\tdi->charge_state = state;\n}\n\nstatic int ab8500_chargalg_check_charger_enable(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\n\tswitch (di->charge_state) {\n\tcase STATE_NORMAL:\n\tcase STATE_MAINTENANCE_A:\n\tcase STATE_MAINTENANCE_B:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (di->chg_info.charger_type & USB_CHG) {\n\t\treturn di->usb_chg->ops.check_enable(di->usb_chg,\n\t\t\tbi->constant_charge_voltage_max_uv,\n\t\t\tbi->constant_charge_current_max_ua);\n\t} else if (di->chg_info.charger_type & AC_CHG) {\n\t\treturn di->ac_chg->ops.check_enable(di->ac_chg,\n\t\t\tbi->constant_charge_voltage_max_uv,\n\t\t\tbi->constant_charge_current_max_ua);\n\t}\n\treturn 0;\n}\n\n \nstatic int ab8500_chargalg_check_charger_connection(struct ab8500_chargalg *di)\n{\n\tif (di->chg_info.conn_chg != di->chg_info.prev_conn_chg) {\n\t\t \n\t\tif (di->chg_info.conn_chg & AC_CHG) {\n\t\t\tdev_info(di->dev, \"Charging source is AC\\n\");\n\t\t\tif (di->chg_info.charger_type != AC_CHG) {\n\t\t\t\tdi->chg_info.charger_type = AC_CHG;\n\t\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\t}\n\t\t} else if (di->chg_info.conn_chg & USB_CHG) {\n\t\t\tdev_info(di->dev, \"Charging source is USB\\n\");\n\t\t\tdi->chg_info.charger_type = USB_CHG;\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"Charging source is OFF\\n\");\n\t\t\tdi->chg_info.charger_type = NO_CHG;\n\t\t\tab8500_chargalg_state_to(di, STATE_HANDHELD_INIT);\n\t\t}\n\t\tdi->chg_info.prev_conn_chg = di->chg_info.conn_chg;\n\t}\n\treturn di->chg_info.conn_chg;\n}\n\n \nstatic void ab8500_chargalg_start_safety_timer(struct ab8500_chargalg *di)\n{\n\t \n\tint timer_expiration = 0;\n\n\tswitch (di->chg_info.charger_type) {\n\tcase AC_CHG:\n\t\ttimer_expiration = di->bm->main_safety_tmr_h;\n\t\tbreak;\n\n\tcase USB_CHG:\n\t\ttimer_expiration = di->bm->usb_safety_tmr_h;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(di->dev, \"Unknown charger to charge from\\n\");\n\t\tbreak;\n\t}\n\n\tdi->events.safety_timer_expired = false;\n\thrtimer_set_expires_range(&di->safety_timer,\n\t\tktime_set(timer_expiration * ONE_HOUR_IN_SECONDS, 0),\n\t\tktime_set(FIVE_MINUTES_IN_SECONDS, 0));\n\thrtimer_start_expires(&di->safety_timer, HRTIMER_MODE_REL);\n}\n\n \nstatic void ab8500_chargalg_stop_safety_timer(struct ab8500_chargalg *di)\n{\n\tif (hrtimer_try_to_cancel(&di->safety_timer) >= 0)\n\t\tdi->events.safety_timer_expired = false;\n}\n\n \nstatic void ab8500_chargalg_start_maintenance_timer(struct ab8500_chargalg *di,\n\tint duration)\n{\n\t \n\thrtimer_set_expires_range(&di->maintenance_timer,\n\t\tktime_set(duration * 60, 0),\n\t\tktime_set(30, 0));\n\tdi->events.maintenance_timer_expired = false;\n\thrtimer_start_expires(&di->maintenance_timer, HRTIMER_MODE_REL);\n}\n\n \nstatic void ab8500_chargalg_stop_maintenance_timer(struct ab8500_chargalg *di)\n{\n\tif (hrtimer_try_to_cancel(&di->maintenance_timer) >= 0)\n\t\tdi->events.maintenance_timer_expired = false;\n}\n\n \nstatic int ab8500_chargalg_kick_watchdog(struct ab8500_chargalg *di)\n{\n\t \n\tif (di->ac_chg && di->ac_chg->ops.kick_wd &&\n\t    di->chg_info.online_chg & AC_CHG) {\n\t\treturn di->ac_chg->ops.kick_wd(di->ac_chg);\n\t} else if (di->usb_chg && di->usb_chg->ops.kick_wd &&\n\t\t\tdi->chg_info.online_chg & USB_CHG)\n\t\treturn di->usb_chg->ops.kick_wd(di->usb_chg);\n\n\treturn -ENXIO;\n}\n\n \nstatic int ab8500_chargalg_ac_en(struct ab8500_chargalg *di, int enable,\n\tint vset_uv, int iset_ua)\n{\n\tif (!di->ac_chg || !di->ac_chg->ops.enable)\n\t\treturn -ENXIO;\n\n\t \n\tif (di->ac_chg->max_out_volt_uv)\n\t\tvset_uv = min(vset_uv, di->ac_chg->max_out_volt_uv);\n\tif (di->ac_chg->max_out_curr_ua)\n\t\tiset_ua = min(iset_ua, di->ac_chg->max_out_curr_ua);\n\n\tdi->chg_info.ac_iset_ua = iset_ua;\n\tdi->chg_info.ac_vset_uv = vset_uv;\n\n\treturn di->ac_chg->ops.enable(di->ac_chg, enable, vset_uv, iset_ua);\n}\n\n \nstatic int ab8500_chargalg_usb_en(struct ab8500_chargalg *di, int enable,\n\tint vset_uv, int iset_ua)\n{\n\tif (!di->usb_chg || !di->usb_chg->ops.enable)\n\t\treturn -ENXIO;\n\n\t \n\tif (di->usb_chg->max_out_volt_uv)\n\t\tvset_uv = min(vset_uv, di->usb_chg->max_out_volt_uv);\n\tif (di->usb_chg->max_out_curr_ua)\n\t\tiset_ua = min(iset_ua, di->usb_chg->max_out_curr_ua);\n\n\tdi->chg_info.usb_iset_ua = iset_ua;\n\tdi->chg_info.usb_vset_uv = vset_uv;\n\n\treturn di->usb_chg->ops.enable(di->usb_chg, enable, vset_uv, iset_ua);\n}\n\n \nstatic int ab8500_chargalg_update_chg_curr(struct ab8500_chargalg *di,\n\t\tint iset_ua)\n{\n\t \n\tif (di->ac_chg && di->ac_chg->ops.update_curr &&\n\t\t\tdi->chg_info.charger_type & AC_CHG) {\n\t\t \n\t\tif (di->ac_chg->max_out_curr_ua)\n\t\t\tiset_ua = min(iset_ua, di->ac_chg->max_out_curr_ua);\n\n\t\tdi->chg_info.ac_iset_ua = iset_ua;\n\n\t\treturn di->ac_chg->ops.update_curr(di->ac_chg, iset_ua);\n\t} else if (di->usb_chg && di->usb_chg->ops.update_curr &&\n\t\t\tdi->chg_info.charger_type & USB_CHG) {\n\t\t \n\t\tif (di->usb_chg->max_out_curr_ua)\n\t\t\tiset_ua = min(iset_ua, di->usb_chg->max_out_curr_ua);\n\n\t\tdi->chg_info.usb_iset_ua = iset_ua;\n\n\t\treturn di->usb_chg->ops.update_curr(di->usb_chg, iset_ua);\n\t}\n\n\treturn -ENXIO;\n}\n\n \nstatic void ab8500_chargalg_stop_charging(struct ab8500_chargalg *di)\n{\n\tab8500_chargalg_ac_en(di, false, 0, 0);\n\tab8500_chargalg_usb_en(di, false, 0, 0);\n\tab8500_chargalg_stop_safety_timer(di);\n\tab8500_chargalg_stop_maintenance_timer(di);\n\tdi->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\tdi->maintenance_chg = false;\n\tcancel_delayed_work(&di->chargalg_wd_work);\n\tpower_supply_changed(di->chargalg_psy);\n}\n\n \nstatic void ab8500_chargalg_hold_charging(struct ab8500_chargalg *di)\n{\n\tab8500_chargalg_ac_en(di, false, 0, 0);\n\tab8500_chargalg_usb_en(di, false, 0, 0);\n\tab8500_chargalg_stop_safety_timer(di);\n\tab8500_chargalg_stop_maintenance_timer(di);\n\tdi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\n\tdi->maintenance_chg = false;\n\tcancel_delayed_work(&di->chargalg_wd_work);\n\tpower_supply_changed(di->chargalg_psy);\n}\n\n \nstatic void ab8500_chargalg_start_charging(struct ab8500_chargalg *di,\n\tint vset_uv, int iset_ua)\n{\n\tswitch (di->chg_info.charger_type) {\n\tcase AC_CHG:\n\t\tdev_dbg(di->dev,\n\t\t\t\"AC parameters: Vset %d, Ich %d\\n\", vset_uv, iset_ua);\n\t\tab8500_chargalg_usb_en(di, false, 0, 0);\n\t\tab8500_chargalg_ac_en(di, true, vset_uv, iset_ua);\n\t\tbreak;\n\n\tcase USB_CHG:\n\t\tdev_dbg(di->dev,\n\t\t\t\"USB parameters: Vset %d, Ich %d\\n\", vset_uv, iset_ua);\n\t\tab8500_chargalg_ac_en(di, false, 0, 0);\n\t\tab8500_chargalg_usb_en(di, true, vset_uv, iset_ua);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(di->dev, \"Unknown charger to charge from\\n\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void ab8500_chargalg_check_temp(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\n\tif (di->batt_data.temp > (bi->temp_alert_min + di->t_hyst_norm) &&\n\t\tdi->batt_data.temp < (bi->temp_alert_max - di->t_hyst_norm)) {\n\t\t \n\t\tdi->events.btemp_underover = false;\n\t\tdi->events.btemp_low = false;\n\t\tdi->events.btemp_high = false;\n\t\tdi->t_hyst_norm = 0;\n\t\tdi->t_hyst_lowhigh = 0;\n\t} else {\n\t\tif ((di->batt_data.temp >= bi->temp_alert_max) &&\n\t\t    (di->batt_data.temp < (bi->temp_max - di->t_hyst_lowhigh))) {\n\t\t\t \n\t\t\tdi->events.btemp_underover = false;\n\t\t\tdi->events.btemp_high = true;\n\t\t\tdi->t_hyst_norm = di->bm->temp_hysteresis;\n\t\t\tdi->t_hyst_lowhigh = 0;\n\t\t} else if ((di->batt_data.temp > (bi->temp_min + di->t_hyst_lowhigh)) &&\n\t\t\t   (di->batt_data.temp <= bi->temp_alert_min)) {\n\t\t\t \n\t\t\tdi->events.btemp_underover = false;\n\t\t\tdi->events.btemp_low = true;\n\t\t\tdi->t_hyst_norm = di->bm->temp_hysteresis;\n\t\t\tdi->t_hyst_lowhigh = 0;\n\t\t} else if (di->batt_data.temp <= bi->temp_min ||\n\t\t\tdi->batt_data.temp >= bi->temp_max) {\n\t\t\t \n\t\t\tdi->events.btemp_underover = true;\n\t\t\tdi->events.btemp_low = false;\n\t\t\tdi->events.btemp_high = false;\n\t\t\tdi->t_hyst_norm = 0;\n\t\t\tdi->t_hyst_lowhigh = di->bm->temp_hysteresis;\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(di->dev, \"Within hysteresis limit temp: %d \"\n\t\t\t\t\"hyst_lowhigh %d, hyst normal %d\\n\",\n\t\t\t\tdi->batt_data.temp, di->t_hyst_lowhigh,\n\t\t\t\tdi->t_hyst_norm);\n\t\t}\n\t}\n}\n\n \nstatic void ab8500_chargalg_check_charger_voltage(struct ab8500_chargalg *di)\n{\n\tif (di->chg_info.usb_volt_uv > di->bm->chg_params->usb_volt_max_uv)\n\t\tdi->chg_info.usb_chg_ok = false;\n\telse\n\t\tdi->chg_info.usb_chg_ok = true;\n\n\tif (di->chg_info.ac_volt_uv > di->bm->chg_params->ac_volt_max_uv)\n\t\tdi->chg_info.ac_chg_ok = false;\n\telse\n\t\tdi->chg_info.ac_chg_ok = true;\n\n}\n\n \nstatic void ab8500_chargalg_end_of_charge(struct ab8500_chargalg *di)\n{\n\tif (di->charge_status == POWER_SUPPLY_STATUS_CHARGING &&\n\t\tdi->charge_state == STATE_NORMAL &&\n\t\t!di->maintenance_chg && (di->batt_data.volt_uv >=\n\t\tdi->bm->bi->voltage_max_design_uv ||\n\t\tdi->events.usb_cv_active || di->events.ac_cv_active) &&\n\t\tdi->batt_data.avg_curr_ua <\n\t\tdi->bm->bi->charge_term_current_ua &&\n\t\tdi->batt_data.avg_curr_ua > 0) {\n\t\tif (++di->eoc_cnt >= EOC_COND_CNT) {\n\t\t\tdi->eoc_cnt = 0;\n\t\t\tdi->charge_status = POWER_SUPPLY_STATUS_FULL;\n\t\t\tdi->maintenance_chg = true;\n\t\t\tdev_dbg(di->dev, \"EOC reached!\\n\");\n\t\t\tpower_supply_changed(di->chargalg_psy);\n\t\t} else {\n\t\t\tdev_dbg(di->dev,\n\t\t\t\t\" EOC limit reached for the %d\"\n\t\t\t\t\" time, out of %d before EOC\\n\",\n\t\t\t\tdi->eoc_cnt,\n\t\t\t\tEOC_COND_CNT);\n\t\t}\n\t} else {\n\t\tdi->eoc_cnt = 0;\n\t}\n}\n\nstatic void init_maxim_chg_curr(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\n\tdi->ccm.original_iset_ua = bi->constant_charge_current_max_ua;\n\tdi->ccm.current_iset_ua = bi->constant_charge_current_max_ua;\n\tdi->ccm.max_current_ua = di->bm->maxi->chg_curr_ua;\n\tdi->ccm.condition_cnt = di->bm->maxi->wait_cycles;\n\tdi->ccm.level = 0;\n}\n\n \nstatic enum maxim_ret ab8500_chargalg_chg_curr_maxim(struct ab8500_chargalg *di)\n{\n\n\tif (!di->bm->maxi->ena_maxi)\n\t\treturn MAXIM_RET_NOACTION;\n\n\tif (di->events.vbus_collapsed) {\n\t\tdev_dbg(di->dev, \"Charger voltage has collapsed %d\\n\",\n\t\t\t\tdi->ccm.wait_cnt);\n\t\tif (di->ccm.wait_cnt == 0) {\n\t\t\tdev_dbg(di->dev, \"lowering current\\n\");\n\t\t\tdi->ccm.wait_cnt++;\n\t\t\tdi->ccm.condition_cnt = di->bm->maxi->wait_cycles;\n\t\t\tdi->ccm.max_current_ua = di->ccm.current_iset_ua;\n\t\t\tdi->ccm.current_iset_ua = di->ccm.max_current_ua;\n\t\t\tdi->ccm.level--;\n\t\t\treturn MAXIM_RET_CHANGE;\n\t\t} else {\n\t\t\tdev_dbg(di->dev, \"waiting\\n\");\n\t\t\t \n\t\t\tdi->ccm.wait_cnt = (di->ccm.wait_cnt + 1) % 3;\n\t\t\treturn MAXIM_RET_NOACTION;\n\t\t}\n\t}\n\n\tdi->ccm.wait_cnt = 0;\n\n\tif (di->batt_data.inst_curr_ua > di->ccm.original_iset_ua) {\n\t\tdev_dbg(di->dev, \" Maximization Ibat (%duA) too high\"\n\t\t\t\" (limit %duA) (current iset: %duA)!\\n\",\n\t\t\tdi->batt_data.inst_curr_ua, di->ccm.original_iset_ua,\n\t\t\tdi->ccm.current_iset_ua);\n\n\t\tif (di->ccm.current_iset_ua == di->ccm.original_iset_ua)\n\t\t\treturn MAXIM_RET_NOACTION;\n\n\t\tdi->ccm.condition_cnt = di->bm->maxi->wait_cycles;\n\t\tdi->ccm.current_iset_ua = di->ccm.original_iset_ua;\n\t\tdi->ccm.level = 0;\n\n\t\treturn MAXIM_RET_IBAT_TOO_HIGH;\n\t}\n\n\tdi->ccm.condition_cnt = di->bm->maxi->wait_cycles;\n\treturn MAXIM_RET_NOACTION;\n}\n\nstatic void handle_maxim_chg_curr(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\tenum maxim_ret ret;\n\tint result;\n\n\tret = ab8500_chargalg_chg_curr_maxim(di);\n\tswitch (ret) {\n\tcase MAXIM_RET_CHANGE:\n\t\tresult = ab8500_chargalg_update_chg_curr(di,\n\t\t\tdi->ccm.current_iset_ua);\n\t\tif (result)\n\t\t\tdev_err(di->dev, \"failed to set chg curr\\n\");\n\t\tbreak;\n\tcase MAXIM_RET_IBAT_TOO_HIGH:\n\t\tresult = ab8500_chargalg_update_chg_curr(di,\n\t\t\tbi->constant_charge_current_max_ua);\n\t\tif (result)\n\t\t\tdev_err(di->dev, \"failed to set chg curr\\n\");\n\t\tbreak;\n\n\tcase MAXIM_RET_NOACTION:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int ab8500_chargalg_get_ext_psy_data(struct device *dev, void *data)\n{\n\tstruct power_supply *psy;\n\tstruct power_supply *ext = dev_get_drvdata(dev);\n\tconst char **supplicants = (const char **)ext->supplied_to;\n\tstruct ab8500_chargalg *di;\n\tunion power_supply_propval ret;\n\tint j;\n\tbool capacity_updated = false;\n\n\tpsy = (struct power_supply *)data;\n\tdi = power_supply_get_drvdata(psy);\n\t \n\tj = match_string(supplicants, ext->num_supplicants, psy->desc->name);\n\tif (j < 0)\n\t\treturn 0;\n\n\t \n\tif (!power_supply_get_property(ext, POWER_SUPPLY_PROP_CAPACITY, &ret)) {\n\t\tdi->batt_data.percent = ret.intval;\n\t\tcapacity_updated = true;\n\t}\n\n\t \n\tfor (j = 0; j < ext->desc->num_properties; j++) {\n\t\tenum power_supply_property prop;\n\t\tprop = ext->desc->properties[j];\n\n\t\t \n\t\tif (!di->ac_chg &&\n\t\t\text->desc->type == POWER_SUPPLY_TYPE_MAINS)\n\t\t\tdi->ac_chg = psy_to_ux500_charger(ext);\n\t\telse if (!di->usb_chg &&\n\t\t\text->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\t\tdi->usb_chg = psy_to_ux500_charger(ext);\n\n\t\tif (power_supply_get_property(ext, prop, &ret))\n\t\t\tcontinue;\n\t\tswitch (prop) {\n\t\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\t \n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->events.batt_rem = false;\n\t\t\t\t \n\t\t\t\telse\n\t\t\t\t\tdi->events.batt_rem = true;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\t \n\t\t\t\tif (!ret.intval &&\n\t\t\t\t\t(di->chg_info.conn_chg & AC_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_conn_chg =\n\t\t\t\t\t\tdi->chg_info.conn_chg;\n\t\t\t\t\tdi->chg_info.conn_chg &= ~AC_CHG;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval &&\n\t\t\t\t\t!(di->chg_info.conn_chg & AC_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_conn_chg =\n\t\t\t\t\t\tdi->chg_info.conn_chg;\n\t\t\t\t\tdi->chg_info.conn_chg |= AC_CHG;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\t \n\t\t\t\tif (!ret.intval &&\n\t\t\t\t\t(di->chg_info.conn_chg & USB_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_conn_chg =\n\t\t\t\t\t\tdi->chg_info.conn_chg;\n\t\t\t\t\tdi->chg_info.conn_chg &= ~USB_CHG;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval &&\n\t\t\t\t\t!(di->chg_info.conn_chg & USB_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_conn_chg =\n\t\t\t\t\t\tdi->chg_info.conn_chg;\n\t\t\t\t\tdi->chg_info.conn_chg |= USB_CHG;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\t \n\t\t\t\tif (!ret.intval &&\n\t\t\t\t\t(di->chg_info.online_chg & AC_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_online_chg =\n\t\t\t\t\t\tdi->chg_info.online_chg;\n\t\t\t\t\tdi->chg_info.online_chg &= ~AC_CHG;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval &&\n\t\t\t\t\t!(di->chg_info.online_chg & AC_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_online_chg =\n\t\t\t\t\t\tdi->chg_info.online_chg;\n\t\t\t\t\tdi->chg_info.online_chg |= AC_CHG;\n\t\t\t\t\tqueue_delayed_work(di->chargalg_wq,\n\t\t\t\t\t\t&di->chargalg_wd_work, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\t \n\t\t\t\tif (!ret.intval &&\n\t\t\t\t\t(di->chg_info.online_chg & USB_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_online_chg =\n\t\t\t\t\t\tdi->chg_info.online_chg;\n\t\t\t\t\tdi->chg_info.online_chg &= ~USB_CHG;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ret.intval &&\n\t\t\t\t\t!(di->chg_info.online_chg & USB_CHG)) {\n\t\t\t\t\tdi->chg_info.prev_online_chg =\n\t\t\t\t\t\tdi->chg_info.online_chg;\n\t\t\t\t\tdi->chg_info.online_chg |= USB_CHG;\n\t\t\t\t\tqueue_delayed_work(di->chargalg_wq,\n\t\t\t\t\t\t&di->chargalg_wd_work, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\tswitch (ret.intval) {\n\t\t\t\tcase POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:\n\t\t\t\t\tdi->events.mainextchnotok = true;\n\t\t\t\t\tdi->events.main_thermal_prot = false;\n\t\t\t\t\tdi->events.main_ovv = false;\n\t\t\t\t\tdi->events.ac_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_DEAD:\n\t\t\t\t\tdi->events.ac_wd_expired = true;\n\t\t\t\t\tdi->events.mainextchnotok = false;\n\t\t\t\t\tdi->events.main_ovv = false;\n\t\t\t\t\tdi->events.main_thermal_prot = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_COLD:\n\t\t\t\tcase POWER_SUPPLY_HEALTH_OVERHEAT:\n\t\t\t\t\tdi->events.main_thermal_prot = true;\n\t\t\t\t\tdi->events.mainextchnotok = false;\n\t\t\t\t\tdi->events.main_ovv = false;\n\t\t\t\t\tdi->events.ac_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_OVERVOLTAGE:\n\t\t\t\t\tdi->events.main_ovv = true;\n\t\t\t\t\tdi->events.mainextchnotok = false;\n\t\t\t\t\tdi->events.main_thermal_prot = false;\n\t\t\t\t\tdi->events.ac_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_GOOD:\n\t\t\t\t\tdi->events.main_thermal_prot = false;\n\t\t\t\t\tdi->events.mainextchnotok = false;\n\t\t\t\t\tdi->events.main_ovv = false;\n\t\t\t\t\tdi->events.ac_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\tswitch (ret.intval) {\n\t\t\t\tcase POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:\n\t\t\t\t\tdi->events.usbchargernotok = true;\n\t\t\t\t\tdi->events.usb_thermal_prot = false;\n\t\t\t\t\tdi->events.vbus_ovv = false;\n\t\t\t\t\tdi->events.usb_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_DEAD:\n\t\t\t\t\tdi->events.usb_wd_expired = true;\n\t\t\t\t\tdi->events.usbchargernotok = false;\n\t\t\t\t\tdi->events.usb_thermal_prot = false;\n\t\t\t\t\tdi->events.vbus_ovv = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_COLD:\n\t\t\t\tcase POWER_SUPPLY_HEALTH_OVERHEAT:\n\t\t\t\t\tdi->events.usb_thermal_prot = true;\n\t\t\t\t\tdi->events.usbchargernotok = false;\n\t\t\t\t\tdi->events.vbus_ovv = false;\n\t\t\t\t\tdi->events.usb_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_OVERVOLTAGE:\n\t\t\t\t\tdi->events.vbus_ovv = true;\n\t\t\t\t\tdi->events.usbchargernotok = false;\n\t\t\t\t\tdi->events.usb_thermal_prot = false;\n\t\t\t\t\tdi->events.usb_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_HEALTH_GOOD:\n\t\t\t\t\tdi->events.usbchargernotok = false;\n\t\t\t\t\tdi->events.usb_thermal_prot = false;\n\t\t\t\t\tdi->events.vbus_ovv = false;\n\t\t\t\t\tdi->events.usb_wd_expired = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tdi->batt_data.volt_uv = ret.intval;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\tdi->chg_info.ac_volt_uv = ret.intval;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\tdi->chg_info.usb_volt_uv = ret.intval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\t \n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->events.ac_cv_active = true;\n\t\t\t\telse\n\t\t\t\t\tdi->events.ac_cv_active = false;\n\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\t \n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->events.usb_cv_active = true;\n\t\t\t\telse\n\t\t\t\t\tdi->events.usb_cv_active = false;\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->events.batt_unknown = false;\n\t\t\t\telse\n\t\t\t\t\tdi->events.batt_unknown = true;\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_TEMP:\n\t\t\tdi->batt_data.temp = ret.intval / 10;\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_MAINS:\n\t\t\t\tdi->chg_info.ac_curr_ua = ret.intval;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\tdi->chg_info.usb_curr_ua = ret.intval;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tdi->batt_data.inst_curr_ua = ret.intval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\t\tswitch (ext->desc->type) {\n\t\t\tcase POWER_SUPPLY_TYPE_BATTERY:\n\t\t\t\tdi->batt_data.avg_curr_ua = ret.intval;\n\t\t\t\tbreak;\n\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\tif (ret.intval)\n\t\t\t\t\tdi->events.vbus_collapsed = true;\n\t\t\t\telse\n\t\t\t\t\tdi->events.vbus_collapsed = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\t\tif (!capacity_updated)\n\t\t\t\tdi->batt_data.percent = ret.intval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void ab8500_chargalg_external_power_changed(struct power_supply *psy)\n{\n\tstruct ab8500_chargalg *di = power_supply_get_drvdata(psy);\n\n\t \n\tif (di->chargalg_wq)\n\t\tqueue_work(di->chargalg_wq, &di->chargalg_work);\n}\n\n \nstatic bool ab8500_chargalg_time_to_restart(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\n\t \n\tif (!di->batt_data.volt_uv || !di->batt_data.percent)\n\t\treturn false;\n\n\t \n\tif (bi->charge_restart_voltage_uv > 0) {\n\t\tif (di->batt_data.volt_uv <= bi->charge_restart_voltage_uv)\n\t\t\treturn true;\n\t\t \n\t} else {\n\t\tif (di->batt_data.percent <= AB8500_RECHARGE_CAP)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void ab8500_chargalg_algorithm(struct ab8500_chargalg *di)\n{\n\tstruct power_supply_battery_info *bi = di->bm->bi;\n\tstruct power_supply_maintenance_charge_table *mt;\n\tint charger_status;\n\tint ret;\n\n\t \n\tclass_for_each_device(power_supply_class, NULL,\n\t\tdi->chargalg_psy, ab8500_chargalg_get_ext_psy_data);\n\n\tab8500_chargalg_end_of_charge(di);\n\tab8500_chargalg_check_temp(di);\n\tab8500_chargalg_check_charger_voltage(di);\n\n\tcharger_status = ab8500_chargalg_check_charger_connection(di);\n\n\tif (is_ab8500(di->parent)) {\n\t\tret = ab8500_chargalg_check_charger_enable(di);\n\t\tif (ret < 0)\n\t\t\tdev_err(di->dev, \"Checking charger is enabled error\"\n\t\t\t\t\t\": Returned Value %d\\n\", ret);\n\t}\n\n\t \n\tif (!charger_status ||\n\t\t(di->events.batt_unknown && !di->bm->chg_unknown_bat)) {\n\t\tif (di->charge_state != STATE_HANDHELD) {\n\t\t\tdi->events.safety_timer_expired = false;\n\t\t\tab8500_chargalg_state_to(di, STATE_HANDHELD_INIT);\n\t\t}\n\t}\n\n\t \n\telse if (di->events.safety_timer_expired) {\n\t\tif (di->charge_state != STATE_SAFETY_TIMER_EXPIRED)\n\t\t\tab8500_chargalg_state_to(di,\n\t\t\t\tSTATE_SAFETY_TIMER_EXPIRED_INIT);\n\t}\n\t \n\n\t \n\telse if (di->events.batt_rem) {\n\t\tif (di->charge_state != STATE_BATT_REMOVED)\n\t\t\tab8500_chargalg_state_to(di, STATE_BATT_REMOVED_INIT);\n\t}\n\t \n\telse if (di->events.mainextchnotok || di->events.usbchargernotok) {\n\t\t \n\t\tif (di->charge_state != STATE_CHG_NOT_OK &&\n\t\t\t\t!di->events.vbus_collapsed)\n\t\t\tab8500_chargalg_state_to(di, STATE_CHG_NOT_OK_INIT);\n\t}\n\t \n\telse if (di->events.vbus_ovv ||\n\t\t\tdi->events.main_ovv ||\n\t\t\tdi->events.batt_ovv ||\n\t\t\t!di->chg_info.usb_chg_ok ||\n\t\t\t!di->chg_info.ac_chg_ok) {\n\t\tif (di->charge_state != STATE_OVV_PROTECT)\n\t\t\tab8500_chargalg_state_to(di, STATE_OVV_PROTECT_INIT);\n\t}\n\t \n\telse if (di->events.main_thermal_prot ||\n\t\tdi->events.usb_thermal_prot) {\n\t\tif (di->charge_state != STATE_HW_TEMP_PROTECT)\n\t\t\tab8500_chargalg_state_to(di,\n\t\t\t\tSTATE_HW_TEMP_PROTECT_INIT);\n\t}\n\t \n\telse if (di->events.btemp_underover) {\n\t\tif (di->charge_state != STATE_TEMP_UNDEROVER)\n\t\t\tab8500_chargalg_state_to(di,\n\t\t\t\tSTATE_TEMP_UNDEROVER_INIT);\n\t}\n\t \n\telse if (di->events.ac_wd_expired ||\n\t\tdi->events.usb_wd_expired) {\n\t\tif (di->charge_state != STATE_WD_EXPIRED)\n\t\t\tab8500_chargalg_state_to(di, STATE_WD_EXPIRED_INIT);\n\t}\n\t \n\telse if (di->events.btemp_low || di->events.btemp_high) {\n\t\tif (di->charge_state != STATE_TEMP_LOWHIGH)\n\t\t\tab8500_chargalg_state_to(di, STATE_TEMP_LOWHIGH_INIT);\n\t}\n\n\tdev_dbg(di->dev,\n\t\t\"[CHARGALG] Vb %d Ib_avg %d Ib_inst %d Tb %d Cap %d Maint %d \"\n\t\t\"State %s Active_chg %d Chg_status %d AC %d USB %d \"\n\t\t\"AC_online %d USB_online %d AC_CV %d USB_CV %d AC_I %d \"\n\t\t\"USB_I %d AC_Vset %d AC_Iset %d USB_Vset %d USB_Iset %d\\n\",\n\t\tdi->batt_data.volt_uv,\n\t\tdi->batt_data.avg_curr_ua,\n\t\tdi->batt_data.inst_curr_ua,\n\t\tdi->batt_data.temp,\n\t\tdi->batt_data.percent,\n\t\tdi->maintenance_chg,\n\t\tstates[di->charge_state],\n\t\tdi->chg_info.charger_type,\n\t\tdi->charge_status,\n\t\tdi->chg_info.conn_chg & AC_CHG,\n\t\tdi->chg_info.conn_chg & USB_CHG,\n\t\tdi->chg_info.online_chg & AC_CHG,\n\t\tdi->chg_info.online_chg & USB_CHG,\n\t\tdi->events.ac_cv_active,\n\t\tdi->events.usb_cv_active,\n\t\tdi->chg_info.ac_curr_ua,\n\t\tdi->chg_info.usb_curr_ua,\n\t\tdi->chg_info.ac_vset_uv,\n\t\tdi->chg_info.ac_iset_ua,\n\t\tdi->chg_info.usb_vset_uv,\n\t\tdi->chg_info.usb_iset_ua);\n\n\tswitch (di->charge_state) {\n\tcase STATE_HANDHELD_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tab8500_chargalg_state_to(di, STATE_HANDHELD);\n\t\tfallthrough;\n\n\tcase STATE_HANDHELD:\n\t\tbreak;\n\n\tcase STATE_BATT_REMOVED_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_BATT_REMOVED);\n\t\tfallthrough;\n\n\tcase STATE_BATT_REMOVED:\n\t\tif (!di->events.batt_rem)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_HW_TEMP_PROTECT_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_HW_TEMP_PROTECT);\n\t\tfallthrough;\n\n\tcase STATE_HW_TEMP_PROTECT:\n\t\tif (!di->events.main_thermal_prot &&\n\t\t\t\t!di->events.usb_thermal_prot)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_OVV_PROTECT_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_OVV_PROTECT);\n\t\tfallthrough;\n\n\tcase STATE_OVV_PROTECT:\n\t\tif (!di->events.vbus_ovv &&\n\t\t\t\t!di->events.main_ovv &&\n\t\t\t\t!di->events.batt_ovv &&\n\t\t\t\tdi->chg_info.usb_chg_ok &&\n\t\t\t\tdi->chg_info.ac_chg_ok)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_CHG_NOT_OK_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_CHG_NOT_OK);\n\t\tfallthrough;\n\n\tcase STATE_CHG_NOT_OK:\n\t\tif (!di->events.mainextchnotok &&\n\t\t\t\t!di->events.usbchargernotok)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_SAFETY_TIMER_EXPIRED_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_SAFETY_TIMER_EXPIRED);\n\t\tfallthrough;\n\n\tcase STATE_SAFETY_TIMER_EXPIRED:\n\t\t \n\t\tbreak;\n\n\tcase STATE_NORMAL_INIT:\n\t\tif (bi->constant_charge_current_max_ua == 0)\n\t\t\t \n\t\t\tab8500_chargalg_stop_charging(di);\n\t\telse {\n\t\t\tab8500_chargalg_start_charging(di,\n\t\t\t\tbi->constant_charge_voltage_max_uv,\n\t\t\t\tbi->constant_charge_current_max_ua);\n\t\t}\n\n\t\tab8500_chargalg_state_to(di, STATE_NORMAL);\n\t\tab8500_chargalg_start_safety_timer(di);\n\t\tab8500_chargalg_stop_maintenance_timer(di);\n\t\tinit_maxim_chg_curr(di);\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tdi->eoc_cnt = 0;\n\t\tdi->maintenance_chg = false;\n\t\tpower_supply_changed(di->chargalg_psy);\n\n\t\tbreak;\n\n\tcase STATE_NORMAL:\n\t\thandle_maxim_chg_curr(di);\n\t\tif (di->charge_status == POWER_SUPPLY_STATUS_FULL &&\n\t\t\tdi->maintenance_chg) {\n\t\t\t \n\t\t\tif (!power_supply_supports_maintenance_charging(bi))\n\t\t\t\tab8500_chargalg_state_to(di,\n\t\t\t\t\tSTATE_WAIT_FOR_RECHARGE_INIT);\n\t\t\telse\n\t\t\t\tab8500_chargalg_state_to(di,\n\t\t\t\t\tSTATE_MAINTENANCE_A_INIT);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase STATE_WAIT_FOR_RECHARGE_INIT:\n\t\tab8500_chargalg_hold_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_WAIT_FOR_RECHARGE);\n\t\tfallthrough;\n\n\tcase STATE_WAIT_FOR_RECHARGE:\n\t\tif (ab8500_chargalg_time_to_restart(di))\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_MAINTENANCE_A_INIT:\n\t\tmt = power_supply_get_maintenance_charging_setting(bi, 0);\n\t\tif (!mt) {\n\t\t\t \n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\tpower_supply_changed(di->chargalg_psy);\n\t\t\tbreak;\n\t\t}\n\t\tab8500_chargalg_stop_safety_timer(di);\n\t\tab8500_chargalg_start_maintenance_timer(di,\n\t\t\tmt->charge_safety_timer_minutes);\n\t\tab8500_chargalg_start_charging(di,\n\t\t\tmt->charge_voltage_max_uv,\n\t\t\tmt->charge_current_max_ua);\n\t\tab8500_chargalg_state_to(di, STATE_MAINTENANCE_A);\n\t\tpower_supply_changed(di->chargalg_psy);\n\t\tfallthrough;\n\n\tcase STATE_MAINTENANCE_A:\n\t\tif (di->events.maintenance_timer_expired) {\n\t\t\tab8500_chargalg_stop_maintenance_timer(di);\n\t\t\tab8500_chargalg_state_to(di, STATE_MAINTENANCE_B_INIT);\n\t\t}\n\t\t \n\t\tif (ab8500_chargalg_time_to_restart(di)) {\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\tdev_info(di->dev, \"restarted charging from maintenance state A - battery getting old?\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase STATE_MAINTENANCE_B_INIT:\n\t\tmt = power_supply_get_maintenance_charging_setting(bi, 1);\n\t\tif (!mt) {\n\t\t\t \n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\tpower_supply_changed(di->chargalg_psy);\n\t\t\tbreak;\n\t\t}\n\t\tab8500_chargalg_start_maintenance_timer(di,\n\t\t\tmt->charge_safety_timer_minutes);\n\t\tab8500_chargalg_start_charging(di,\n\t\t\tmt->charge_voltage_max_uv,\n\t\t\tmt->charge_current_max_ua);\n\t\tab8500_chargalg_state_to(di, STATE_MAINTENANCE_B);\n\t\tpower_supply_changed(di->chargalg_psy);\n\t\tfallthrough;\n\n\tcase STATE_MAINTENANCE_B:\n\t\tif (di->events.maintenance_timer_expired) {\n\t\t\tab8500_chargalg_stop_maintenance_timer(di);\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t}\n\t\t \n\t\tif (ab8500_chargalg_time_to_restart(di)) {\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\tdev_info(di->dev, \"restarted charging from maintenance state B - battery getting old?\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase STATE_TEMP_LOWHIGH_INIT:\n\t\tif (di->events.btemp_low) {\n\t\t\tab8500_chargalg_start_charging(di,\n\t\t\t\t       bi->alert_low_temp_charge_voltage_uv,\n\t\t\t\t       bi->alert_low_temp_charge_current_ua);\n\t\t} else if (di->events.btemp_high) {\n\t\t\tab8500_chargalg_start_charging(di,\n\t\t\t\t       bi->alert_high_temp_charge_voltage_uv,\n\t\t\t\t       bi->alert_high_temp_charge_current_ua);\n\t\t} else {\n\t\t\tdev_err(di->dev, \"neither low or high temp event occurred\\n\");\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\t\tbreak;\n\t\t}\n\t\tab8500_chargalg_stop_maintenance_timer(di);\n\t\tdi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tab8500_chargalg_state_to(di, STATE_TEMP_LOWHIGH);\n\t\tpower_supply_changed(di->chargalg_psy);\n\t\tfallthrough;\n\n\tcase STATE_TEMP_LOWHIGH:\n\t\tif (!di->events.btemp_low && !di->events.btemp_high)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_WD_EXPIRED_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_WD_EXPIRED);\n\t\tfallthrough;\n\n\tcase STATE_WD_EXPIRED:\n\t\tif (!di->events.ac_wd_expired &&\n\t\t\t\t!di->events.usb_wd_expired)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\n\tcase STATE_TEMP_UNDEROVER_INIT:\n\t\tab8500_chargalg_stop_charging(di);\n\t\tab8500_chargalg_state_to(di, STATE_TEMP_UNDEROVER);\n\t\tfallthrough;\n\n\tcase STATE_TEMP_UNDEROVER:\n\t\tif (!di->events.btemp_underover)\n\t\t\tab8500_chargalg_state_to(di, STATE_NORMAL_INIT);\n\t\tbreak;\n\t}\n\n\t \n\tif (di->charge_state == STATE_NORMAL_INIT ||\n\t\t\tdi->charge_state == STATE_MAINTENANCE_A_INIT ||\n\t\t\tdi->charge_state == STATE_MAINTENANCE_B_INIT)\n\t\tqueue_work(di->chargalg_wq, &di->chargalg_work);\n}\n\n \nstatic void ab8500_chargalg_periodic_work(struct work_struct *work)\n{\n\tstruct ab8500_chargalg *di = container_of(work,\n\t\tstruct ab8500_chargalg, chargalg_periodic_work.work);\n\n\tab8500_chargalg_algorithm(di);\n\n\t \n\tif (di->chg_info.conn_chg)\n\t\tqueue_delayed_work(di->chargalg_wq,\n\t\t\t&di->chargalg_periodic_work,\n\t\t\tdi->bm->interval_charging * HZ);\n\telse\n\t\tqueue_delayed_work(di->chargalg_wq,\n\t\t\t&di->chargalg_periodic_work,\n\t\t\tdi->bm->interval_not_charging * HZ);\n}\n\n \nstatic void ab8500_chargalg_wd_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct ab8500_chargalg *di = container_of(work,\n\t\tstruct ab8500_chargalg, chargalg_wd_work.work);\n\n\tret = ab8500_chargalg_kick_watchdog(di);\n\tif (ret < 0)\n\t\tdev_err(di->dev, \"failed to kick watchdog\\n\");\n\n\tqueue_delayed_work(di->chargalg_wq,\n\t\t&di->chargalg_wd_work, CHG_WD_INTERVAL);\n}\n\n \nstatic void ab8500_chargalg_work(struct work_struct *work)\n{\n\tstruct ab8500_chargalg *di = container_of(work,\n\t\tstruct ab8500_chargalg, chargalg_work);\n\n\tab8500_chargalg_algorithm(di);\n}\n\n \nstatic int ab8500_chargalg_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct ab8500_chargalg *di = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = di->charge_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (di->events.batt_ovv) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\t} else if (di->events.btemp_underover) {\n\t\t\tif (di->batt_data.temp <= di->bm->bi->temp_min)\n\t\t\t\tval->intval = POWER_SUPPLY_HEALTH_COLD;\n\t\t\telse\n\t\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t} else if (di->charge_state == STATE_SAFETY_TIMER_EXPIRED ||\n\t\t\t   di->charge_state == STATE_SAFETY_TIMER_EXPIRED_INIT) {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\t} else {\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused ab8500_chargalg_resume(struct device *dev)\n{\n\tstruct ab8500_chargalg *di = dev_get_drvdata(dev);\n\n\t \n\tif (di->chg_info.online_chg)\n\t\tqueue_delayed_work(di->chargalg_wq, &di->chargalg_wd_work, 0);\n\n\t \n\tqueue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ab8500_chargalg_suspend(struct device *dev)\n{\n\tstruct ab8500_chargalg *di = dev_get_drvdata(dev);\n\n\tif (di->chg_info.online_chg)\n\t\tcancel_delayed_work_sync(&di->chargalg_wd_work);\n\n\tcancel_delayed_work_sync(&di->chargalg_periodic_work);\n\n\treturn 0;\n}\n\nstatic char *supply_interface[] = {\n\t\"ab8500_fg\",\n};\n\nstatic const struct power_supply_desc ab8500_chargalg_desc = {\n\t.name\t\t\t= \"ab8500_chargalg\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_UNKNOWN,\n\t.properties\t\t= ab8500_chargalg_props,\n\t.num_properties\t\t= ARRAY_SIZE(ab8500_chargalg_props),\n\t.get_property\t\t= ab8500_chargalg_get_property,\n\t.external_power_changed\t= ab8500_chargalg_external_power_changed,\n};\n\nstatic int ab8500_chargalg_bind(struct device *dev, struct device *master,\n\t\t\t\tvoid *data)\n{\n\tstruct ab8500_chargalg *di = dev_get_drvdata(dev);\n\n\t \n\tdi->chargalg_wq = alloc_ordered_workqueue(\"ab8500_chargalg_wq\",\n\t\t\t\t\t\t  WQ_MEM_RECLAIM);\n\tif (di->chargalg_wq == NULL) {\n\t\tdev_err(di->dev, \"failed to create work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tqueue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);\n\n\treturn 0;\n}\n\nstatic void ab8500_chargalg_unbind(struct device *dev, struct device *master,\n\t\t\t\t   void *data)\n{\n\tstruct ab8500_chargalg *di = dev_get_drvdata(dev);\n\n\t \n\thrtimer_cancel(&di->safety_timer);\n\thrtimer_cancel(&di->maintenance_timer);\n\n\tcancel_delayed_work_sync(&di->chargalg_periodic_work);\n\tcancel_delayed_work_sync(&di->chargalg_wd_work);\n\tcancel_work_sync(&di->chargalg_work);\n\n\t \n\tdestroy_workqueue(di->chargalg_wq);\n}\n\nstatic const struct component_ops ab8500_chargalg_component_ops = {\n\t.bind = ab8500_chargalg_bind,\n\t.unbind = ab8500_chargalg_unbind,\n};\n\nstatic int ab8500_chargalg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct ab8500_chargalg *di;\n\n\tdi = devm_kzalloc(dev, sizeof(*di), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->bm = &ab8500_bm_data;\n\n\t \n\tdi->dev = dev;\n\tdi->parent = dev_get_drvdata(pdev->dev.parent);\n\n\tpsy_cfg.supplied_to = supply_interface;\n\tpsy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\n\tpsy_cfg.drv_data = di;\n\n\t \n\thrtimer_init(&di->safety_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tdi->safety_timer.function = ab8500_chargalg_safety_timer_expired;\n\n\t \n\thrtimer_init(&di->maintenance_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tdi->maintenance_timer.function =\n\t\tab8500_chargalg_maintenance_timer_expired;\n\n\t \n\tINIT_DEFERRABLE_WORK(&di->chargalg_periodic_work,\n\t\tab8500_chargalg_periodic_work);\n\tINIT_DEFERRABLE_WORK(&di->chargalg_wd_work,\n\t\tab8500_chargalg_wd_work);\n\n\t \n\tINIT_WORK(&di->chargalg_work, ab8500_chargalg_work);\n\n\t \n\tdi->chg_info.prev_conn_chg = -1;\n\n\t \n\tdi->chargalg_psy = devm_power_supply_register(di->dev,\n\t\t\t\t\t\t &ab8500_chargalg_desc,\n\t\t\t\t\t\t &psy_cfg);\n\tif (IS_ERR(di->chargalg_psy)) {\n\t\tdev_err(di->dev, \"failed to register chargalg psy\\n\");\n\t\treturn PTR_ERR(di->chargalg_psy);\n\t}\n\n\tplatform_set_drvdata(pdev, di);\n\n\tdev_info(di->dev, \"probe success\\n\");\n\treturn component_add(dev, &ab8500_chargalg_component_ops);\n}\n\nstatic int ab8500_chargalg_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &ab8500_chargalg_component_ops);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ab8500_chargalg_pm_ops, ab8500_chargalg_suspend, ab8500_chargalg_resume);\n\nstatic const struct of_device_id ab8500_chargalg_match[] = {\n\t{ .compatible = \"stericsson,ab8500-chargalg\", },\n\t{ },\n};\n\nstruct platform_driver ab8500_chargalg_driver = {\n\t.probe = ab8500_chargalg_probe,\n\t.remove = ab8500_chargalg_remove,\n\t.driver = {\n\t\t.name = \"ab8500_chargalg\",\n\t\t.of_match_table = ab8500_chargalg_match,\n\t\t.pm = &ab8500_chargalg_pm_ops,\n\t},\n};\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Johan Palsson, Karl Komierowski\");\nMODULE_ALIAS(\"platform:ab8500-chargalg\");\nMODULE_DESCRIPTION(\"ab8500 battery charging algorithm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}