{
  "module_name": "power_supply_hwmon.c",
  "hash_id": "116f85a0025400dd04ab039a1e17abbcc7f0d32ff579fd2f9366f28a86570e9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/power_supply_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n\nstruct power_supply_hwmon {\n\tstruct power_supply *psy;\n\tunsigned long *props;\n};\n\nstatic const char *const ps_temp_label[] = {\n\t\"temp\",\n\t\"ambient temp\",\n};\n\nstatic int power_supply_hwmon_in_to_property(u32 attr)\n{\n\tswitch (attr) {\n\tcase hwmon_in_average:\n\t\treturn POWER_SUPPLY_PROP_VOLTAGE_AVG;\n\tcase hwmon_in_min:\n\t\treturn POWER_SUPPLY_PROP_VOLTAGE_MIN;\n\tcase hwmon_in_max:\n\t\treturn POWER_SUPPLY_PROP_VOLTAGE_MAX;\n\tcase hwmon_in_input:\n\t\treturn POWER_SUPPLY_PROP_VOLTAGE_NOW;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int power_supply_hwmon_curr_to_property(u32 attr)\n{\n\tswitch (attr) {\n\tcase hwmon_curr_average:\n\t\treturn POWER_SUPPLY_PROP_CURRENT_AVG;\n\tcase hwmon_curr_max:\n\t\treturn POWER_SUPPLY_PROP_CURRENT_MAX;\n\tcase hwmon_curr_input:\n\t\treturn POWER_SUPPLY_PROP_CURRENT_NOW;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int power_supply_hwmon_temp_to_property(u32 attr, int channel)\n{\n\tif (channel) {\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_AMBIENT;\n\t\tcase hwmon_temp_min_alarm:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN;\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_input:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP;\n\t\tcase hwmon_temp_max:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_MAX;\n\t\tcase hwmon_temp_min:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_MIN;\n\t\tcase hwmon_temp_min_alarm:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_ALERT_MIN;\n\t\tcase hwmon_temp_max_alarm:\n\t\t\treturn POWER_SUPPLY_PROP_TEMP_ALERT_MAX;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\npower_supply_hwmon_to_property(enum hwmon_sensor_types type,\n\t\t\t       u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn power_supply_hwmon_in_to_property(attr);\n\tcase hwmon_curr:\n\t\treturn power_supply_hwmon_curr_to_property(attr);\n\tcase hwmon_temp:\n\t\treturn power_supply_hwmon_temp_to_property(attr, channel);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool power_supply_hwmon_is_a_label(enum hwmon_sensor_types type,\n\t\t\t\t\t   u32 attr)\n{\n\treturn type == hwmon_temp && attr == hwmon_temp_label;\n}\n\nstruct hwmon_type_attr_list {\n\tconst u32 *attrs;\n\tsize_t n_attrs;\n};\n\nstatic const u32 ps_temp_attrs[] = {\n\thwmon_temp_input,\n\thwmon_temp_min, hwmon_temp_max,\n\thwmon_temp_min_alarm, hwmon_temp_max_alarm,\n};\n\nstatic const struct hwmon_type_attr_list ps_type_attrs[hwmon_max] = {\n\t[hwmon_temp] = { ps_temp_attrs, ARRAY_SIZE(ps_temp_attrs) },\n};\n\nstatic bool power_supply_hwmon_has_input(\n\tconst struct power_supply_hwmon *psyhw,\n\tenum hwmon_sensor_types type, int channel)\n{\n\tconst struct hwmon_type_attr_list *attr_list = &ps_type_attrs[type];\n\tsize_t i;\n\n\tfor (i = 0; i < attr_list->n_attrs; ++i) {\n\t\tint prop = power_supply_hwmon_to_property(type,\n\t\t\tattr_list->attrs[i], channel);\n\n\t\tif (prop >= 0 && test_bit(prop, psyhw->props))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool power_supply_hwmon_is_writable(enum hwmon_sensor_types type,\n\t\t\t\t\t   u32 attr)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\treturn attr == hwmon_in_min ||\n\t\t       attr == hwmon_in_max;\n\tcase hwmon_curr:\n\t\treturn attr == hwmon_curr_max;\n\tcase hwmon_temp:\n\t\treturn attr == hwmon_temp_max ||\n\t\t       attr == hwmon_temp_min ||\n\t\t       attr == hwmon_temp_min_alarm ||\n\t\t       attr == hwmon_temp_max_alarm;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic umode_t power_supply_hwmon_is_visible(const void *data,\n\t\t\t\t\t     enum hwmon_sensor_types type,\n\t\t\t\t\t     u32 attr, int channel)\n{\n\tconst struct power_supply_hwmon *psyhw = data;\n\tint prop;\n\n\tif (power_supply_hwmon_is_a_label(type, attr)) {\n\t\tif (power_supply_hwmon_has_input(psyhw, type, channel))\n\t\t\treturn 0444;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tprop = power_supply_hwmon_to_property(type, attr, channel);\n\tif (prop < 0 || !test_bit(prop, psyhw->props))\n\t\treturn 0;\n\n\tif (power_supply_property_is_writeable(psyhw->psy, prop) > 0 &&\n\t    power_supply_hwmon_is_writable(type, attr))\n\t\treturn 0644;\n\n\treturn 0444;\n}\n\nstatic int power_supply_hwmon_read_string(struct device *dev,\n\t\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t\t  u32 attr, int channel,\n\t\t\t\t\t  const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\t*str = ps_temp_label[channel];\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\npower_supply_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct power_supply_hwmon *psyhw = dev_get_drvdata(dev);\n\tstruct power_supply *psy = psyhw->psy;\n\tunion power_supply_propval pspval;\n\tint ret, prop;\n\n\tprop = power_supply_hwmon_to_property(type, attr, channel);\n\tif (prop < 0)\n\t\treturn prop;\n\n\tret  = power_supply_get_property(psy, prop, &pspval);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (type) {\n\t \n\tcase hwmon_curr:\n\tcase hwmon_in:\n\t\tpspval.intval = DIV_ROUND_CLOSEST(pspval.intval, 1000);\n\t\tbreak;\n\t \n\tcase hwmon_temp:\n\t\tif (check_mul_overflow(pspval.intval, 100,\n\t\t\t\t       &pspval.intval))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val = pspval.intval;\n\n\treturn 0;\n}\n\nstatic int\npower_supply_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long val)\n{\n\tstruct power_supply_hwmon *psyhw = dev_get_drvdata(dev);\n\tstruct power_supply *psy = psyhw->psy;\n\tunion power_supply_propval pspval;\n\tint prop;\n\n\tprop = power_supply_hwmon_to_property(type, attr, channel);\n\tif (prop < 0)\n\t\treturn prop;\n\n\tpspval.intval = val;\n\n\tswitch (type) {\n\t \n\tcase hwmon_curr:\n\tcase hwmon_in:\n\t\tif (check_mul_overflow(pspval.intval, 1000,\n\t\t\t\t       &pspval.intval))\n\t\t\treturn -EOVERFLOW;\n\t\tbreak;\n\t \n\tcase hwmon_temp:\n\t\tpspval.intval = DIV_ROUND_CLOSEST(pspval.intval, 100);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn power_supply_set_property(psy, prop, &pspval);\n}\n\nstatic const struct hwmon_ops power_supply_hwmon_ops = {\n\t.is_visible\t= power_supply_hwmon_is_visible,\n\t.read\t\t= power_supply_hwmon_read,\n\t.write\t\t= power_supply_hwmon_write,\n\t.read_string\t= power_supply_hwmon_read_string,\n};\n\nstatic const struct hwmon_channel_info * const power_supply_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_LABEL     |\n\t\t\t   HWMON_T_INPUT     |\n\t\t\t   HWMON_T_MAX       |\n\t\t\t   HWMON_T_MIN       |\n\t\t\t   HWMON_T_MIN_ALARM,\n\n\t\t\t   HWMON_T_LABEL     |\n\t\t\t   HWMON_T_INPUT     |\n\t\t\t   HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_MAX_ALARM),\n\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_AVERAGE |\n\t\t\t   HWMON_C_MAX     |\n\t\t\t   HWMON_C_INPUT),\n\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_AVERAGE |\n\t\t\t   HWMON_I_MIN     |\n\t\t\t   HWMON_I_MAX     |\n\t\t\t   HWMON_I_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info power_supply_hwmon_chip_info = {\n\t.ops = &power_supply_hwmon_ops,\n\t.info = power_supply_hwmon_info,\n};\n\nint power_supply_add_hwmon_sysfs(struct power_supply *psy)\n{\n\tconst struct power_supply_desc *desc = psy->desc;\n\tstruct power_supply_hwmon *psyhw;\n\tstruct device *dev = &psy->dev;\n\tstruct device *hwmon;\n\tint ret, i;\n\tconst char *name;\n\n\tif (!devres_open_group(dev, power_supply_add_hwmon_sysfs,\n\t\t\t       GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tpsyhw = devm_kzalloc(dev, sizeof(*psyhw), GFP_KERNEL);\n\tif (!psyhw) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpsyhw->psy = psy;\n\tpsyhw->props = devm_bitmap_zalloc(dev,\n\t\t\t\t\t  POWER_SUPPLY_PROP_TIME_TO_FULL_AVG + 1,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!psyhw->props) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < desc->num_properties; i++) {\n\t\tconst enum power_supply_property prop = desc->properties[i];\n\n\t\tswitch (prop) {\n\t\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tcase POWER_SUPPLY_PROP_TEMP_MAX:\n\t\tcase POWER_SUPPLY_PROP_TEMP_MIN:\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT:\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:\n\t\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t\tset_bit(prop, psyhw->props);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tname = psy->desc->name;\n\tif (strchr(name, '-')) {\n\t\tchar *new_name;\n\n\t\tnew_name = devm_kstrdup(dev, name, GFP_KERNEL);\n\t\tif (!new_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tstrreplace(new_name, '-', '_');\n\t\tname = new_name;\n\t}\n\thwmon = devm_hwmon_device_register_with_info(dev, name,\n\t\t\t\t\t\tpsyhw,\n\t\t\t\t\t\t&power_supply_hwmon_chip_info,\n\t\t\t\t\t\tNULL);\n\tret = PTR_ERR_OR_ZERO(hwmon);\n\tif (ret)\n\t\tgoto error;\n\n\tdevres_close_group(dev, power_supply_add_hwmon_sysfs);\n\treturn 0;\nerror:\n\tdevres_release_group(dev, NULL);\n\treturn ret;\n}\n\nvoid power_supply_remove_hwmon_sysfs(struct power_supply *psy)\n{\n\tdevres_release_group(&psy->dev, power_supply_add_hwmon_sysfs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}