{
  "module_name": "qcom_smbb.c",
  "hash_id": "992843d2e9da85cef45e1073fff6e05d1af2ebde37626a0c5107b47cc646bd9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/qcom_smbb.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/extcon-provider.h>\n#include <linux/regulator/driver.h>\n\n#define SMBB_CHG_VMAX\t\t0x040\n#define SMBB_CHG_VSAFE\t\t0x041\n#define SMBB_CHG_CFG\t\t0x043\n#define SMBB_CHG_IMAX\t\t0x044\n#define SMBB_CHG_ISAFE\t\t0x045\n#define SMBB_CHG_VIN_MIN\t0x047\n#define SMBB_CHG_CTRL\t\t0x049\n#define CTRL_EN\t\t\tBIT(7)\n#define SMBB_CHG_VBAT_WEAK\t0x052\n#define SMBB_CHG_IBAT_TERM_CHG\t0x05b\n#define IBAT_TERM_CHG_IEOC\tBIT(7)\n#define IBAT_TERM_CHG_IEOC_BMS\tBIT(7)\n#define IBAT_TERM_CHG_IEOC_CHG\t0\n#define SMBB_CHG_VBAT_DET\t0x05d\n#define SMBB_CHG_TCHG_MAX_EN\t0x060\n#define TCHG_MAX_EN\t\tBIT(7)\n#define SMBB_CHG_WDOG_TIME\t0x062\n#define SMBB_CHG_WDOG_EN\t0x065\n#define WDOG_EN\t\t\tBIT(7)\n\n#define SMBB_BUCK_REG_MODE\t0x174\n#define BUCK_REG_MODE\t\tBIT(0)\n#define BUCK_REG_MODE_VBAT\tBIT(0)\n#define BUCK_REG_MODE_VSYS\t0\n\n#define SMBB_BAT_PRES_STATUS\t0x208\n#define PRES_STATUS_BAT_PRES\tBIT(7)\n#define SMBB_BAT_TEMP_STATUS\t0x209\n#define TEMP_STATUS_OK\t\tBIT(7)\n#define TEMP_STATUS_HOT\t\tBIT(6)\n#define SMBB_BAT_BTC_CTRL\t0x249\n#define BTC_CTRL_COMP_EN\tBIT(7)\n#define BTC_CTRL_COLD_EXT\tBIT(1)\n#define BTC_CTRL_HOT_EXT_N\tBIT(0)\n\n#define SMBB_USB_IMAX\t\t0x344\n#define SMBB_USB_OTG_CTL\t0x348\n#define OTG_CTL_EN\t\tBIT(0)\n#define SMBB_USB_ENUM_TIMER_STOP 0x34e\n#define ENUM_TIMER_STOP\t\tBIT(0)\n#define SMBB_USB_SEC_ACCESS\t0x3d0\n#define SEC_ACCESS_MAGIC\t0xa5\n#define SMBB_USB_REV_BST\t0x3ed\n#define REV_BST_CHG_GONE\tBIT(7)\n\n#define SMBB_DC_IMAX\t\t0x444\n\n#define SMBB_MISC_REV2\t\t0x601\n#define SMBB_MISC_BOOT_DONE\t0x642\n#define BOOT_DONE\t\tBIT(7)\n\n#define STATUS_USBIN_VALID\tBIT(0)  \n#define STATUS_DCIN_VALID\tBIT(1)  \n#define STATUS_BAT_HOT\t\tBIT(2)  \n#define STATUS_BAT_OK\t\tBIT(3)  \n#define STATUS_BAT_PRESENT\tBIT(4)  \n#define STATUS_CHG_DONE\t\tBIT(5)  \n#define STATUS_CHG_TRKL\t\tBIT(6)  \n#define STATUS_CHG_FAST\t\tBIT(7)  \n#define STATUS_CHG_GONE\t\tBIT(8)  \n\nenum smbb_attr {\n\tATTR_BAT_ISAFE,\n\tATTR_BAT_IMAX,\n\tATTR_USBIN_IMAX,\n\tATTR_DCIN_IMAX,\n\tATTR_BAT_VSAFE,\n\tATTR_BAT_VMAX,\n\tATTR_BAT_VMIN,\n\tATTR_CHG_VDET,\n\tATTR_VIN_MIN,\n\t_ATTR_CNT,\n};\n\nstruct smbb_charger {\n\tunsigned int revision;\n\tunsigned int addr;\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tbool dc_disabled;\n\tbool jeita_ext_temp;\n\tunsigned long status;\n\tstruct mutex statlock;\n\n\tunsigned int attr[_ATTR_CNT];\n\n\tstruct power_supply *usb_psy;\n\tstruct power_supply *dc_psy;\n\tstruct power_supply *bat_psy;\n\tstruct regmap *regmap;\n\n\tstruct regulator_desc otg_rdesc;\n\tstruct regulator_dev *otg_reg;\n};\n\nstatic const unsigned int smbb_usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_NONE,\n};\n\nstatic int smbb_vbat_weak_fn(unsigned int index)\n{\n\treturn 2100000 + index * 100000;\n}\n\nstatic int smbb_vin_fn(unsigned int index)\n{\n\tif (index > 42)\n\t\treturn 5600000 + (index - 43) * 200000;\n\treturn 3400000 + index * 50000;\n}\n\nstatic int smbb_vmax_fn(unsigned int index)\n{\n\treturn 3240000 + index * 10000;\n}\n\nstatic int smbb_vbat_det_fn(unsigned int index)\n{\n\treturn 3240000 + index * 20000;\n}\n\nstatic int smbb_imax_fn(unsigned int index)\n{\n\tif (index < 2)\n\t\treturn 100000 + index * 50000;\n\treturn index * 100000;\n}\n\nstatic int smbb_bat_imax_fn(unsigned int index)\n{\n\treturn index * 50000;\n}\n\nstatic unsigned int smbb_hw_lookup(unsigned int val, int (*fn)(unsigned int))\n{\n\tunsigned int widx;\n\tunsigned int sel;\n\n\tfor (widx = sel = 0; (*fn)(widx) <= val; ++widx)\n\t\tsel = widx;\n\n\treturn sel;\n}\n\nstatic const struct smbb_charger_attr {\n\tconst char *name;\n\tunsigned int reg;\n\tunsigned int safe_reg;\n\tunsigned int max;\n\tunsigned int min;\n\tunsigned int fail_ok;\n\tint (*hw_fn)(unsigned int);\n} smbb_charger_attrs[] = {\n\t[ATTR_BAT_ISAFE] = {\n\t\t.name = \"qcom,fast-charge-safe-current\",\n\t\t.reg = SMBB_CHG_ISAFE,\n\t\t.max = 3000000,\n\t\t.min = 200000,\n\t\t.hw_fn = smbb_bat_imax_fn,\n\t\t.fail_ok = 1,\n\t},\n\t[ATTR_BAT_IMAX] = {\n\t\t.name = \"qcom,fast-charge-current-limit\",\n\t\t.reg = SMBB_CHG_IMAX,\n\t\t.safe_reg = SMBB_CHG_ISAFE,\n\t\t.max = 3000000,\n\t\t.min = 200000,\n\t\t.hw_fn = smbb_bat_imax_fn,\n\t},\n\t[ATTR_DCIN_IMAX] = {\n\t\t.name = \"qcom,dc-current-limit\",\n\t\t.reg = SMBB_DC_IMAX,\n\t\t.max = 2500000,\n\t\t.min = 100000,\n\t\t.hw_fn = smbb_imax_fn,\n\t},\n\t[ATTR_BAT_VSAFE] = {\n\t\t.name = \"qcom,fast-charge-safe-voltage\",\n\t\t.reg = SMBB_CHG_VSAFE,\n\t\t.max = 5000000,\n\t\t.min = 3240000,\n\t\t.hw_fn = smbb_vmax_fn,\n\t\t.fail_ok = 1,\n\t},\n\t[ATTR_BAT_VMAX] = {\n\t\t.name = \"qcom,fast-charge-high-threshold-voltage\",\n\t\t.reg = SMBB_CHG_VMAX,\n\t\t.safe_reg = SMBB_CHG_VSAFE,\n\t\t.max = 5000000,\n\t\t.min = 3240000,\n\t\t.hw_fn = smbb_vmax_fn,\n\t},\n\t[ATTR_BAT_VMIN] = {\n\t\t.name = \"qcom,fast-charge-low-threshold-voltage\",\n\t\t.reg = SMBB_CHG_VBAT_WEAK,\n\t\t.max = 3600000,\n\t\t.min = 2100000,\n\t\t.hw_fn = smbb_vbat_weak_fn,\n\t},\n\t[ATTR_CHG_VDET] = {\n\t\t.name = \"qcom,auto-recharge-threshold-voltage\",\n\t\t.reg = SMBB_CHG_VBAT_DET,\n\t\t.max = 5000000,\n\t\t.min = 3240000,\n\t\t.hw_fn = smbb_vbat_det_fn,\n\t},\n\t[ATTR_VIN_MIN] = {\n\t\t.name = \"qcom,minimum-input-voltage\",\n\t\t.reg = SMBB_CHG_VIN_MIN,\n\t\t.max = 9600000,\n\t\t.min = 4200000,\n\t\t.hw_fn = smbb_vin_fn,\n\t},\n\t[ATTR_USBIN_IMAX] = {\n\t\t.name = \"usb-charge-current-limit\",\n\t\t.reg = SMBB_USB_IMAX,\n\t\t.max = 2500000,\n\t\t.min = 100000,\n\t\t.hw_fn = smbb_imax_fn,\n\t},\n};\n\nstatic int smbb_charger_attr_write(struct smbb_charger *chg,\n\t\tenum smbb_attr which, unsigned int val)\n{\n\tconst struct smbb_charger_attr *prop;\n\tunsigned int wval;\n\tunsigned int out;\n\tint rc;\n\n\tprop = &smbb_charger_attrs[which];\n\n\tif (val > prop->max || val < prop->min) {\n\t\tdev_err(chg->dev, \"value out of range for %s [%u:%u]\\n\",\n\t\t\tprop->name, prop->min, prop->max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (prop->safe_reg) {\n\t\trc = regmap_read(chg->regmap,\n\t\t\t\tchg->addr + prop->safe_reg, &wval);\n\t\tif (rc) {\n\t\t\tdev_err(chg->dev,\n\t\t\t\t\"unable to read safe value for '%s'\\n\",\n\t\t\t\tprop->name);\n\t\t\treturn rc;\n\t\t}\n\n\t\twval = prop->hw_fn(wval);\n\n\t\tif (val > wval) {\n\t\t\tdev_warn(chg->dev,\n\t\t\t\t\"%s above safe value, clamping at %u\\n\",\n\t\t\t\tprop->name, wval);\n\t\t\tval = wval;\n\t\t}\n\t}\n\n\twval = smbb_hw_lookup(val, prop->hw_fn);\n\n\trc = regmap_write(chg->regmap, chg->addr + prop->reg, wval);\n\tif (rc) {\n\t\tdev_err(chg->dev, \"unable to update %s\", prop->name);\n\t\treturn rc;\n\t}\n\tout = prop->hw_fn(wval);\n\tif (out != val) {\n\t\tdev_warn(chg->dev,\n\t\t\t\"%s inaccurate, rounded to %u\\n\",\n\t\t\tprop->name, out);\n\t}\n\n\tdev_dbg(chg->dev, \"%s <= %d\\n\", prop->name, out);\n\n\tchg->attr[which] = out;\n\n\treturn 0;\n}\n\nstatic int smbb_charger_attr_read(struct smbb_charger *chg,\n\t\tenum smbb_attr which)\n{\n\tconst struct smbb_charger_attr *prop;\n\tunsigned int val;\n\tint rc;\n\n\tprop = &smbb_charger_attrs[which];\n\n\trc = regmap_read(chg->regmap, chg->addr + prop->reg, &val);\n\tif (rc) {\n\t\tdev_err(chg->dev, \"failed to read %s\\n\", prop->name);\n\t\treturn rc;\n\t}\n\tval = prop->hw_fn(val);\n\tdev_dbg(chg->dev, \"%s => %d\\n\", prop->name, val);\n\n\tchg->attr[which] = val;\n\n\treturn 0;\n}\n\nstatic int smbb_charger_attr_parse(struct smbb_charger *chg,\n\t\tenum smbb_attr which)\n{\n\tconst struct smbb_charger_attr *prop;\n\tunsigned int val;\n\tint rc;\n\n\tprop = &smbb_charger_attrs[which];\n\n\trc = of_property_read_u32(chg->dev->of_node, prop->name, &val);\n\tif (rc == 0) {\n\t\trc = smbb_charger_attr_write(chg, which, val);\n\t\tif (!rc || !prop->fail_ok)\n\t\t\treturn rc;\n\t}\n\treturn smbb_charger_attr_read(chg, which);\n}\n\nstatic void smbb_set_line_flag(struct smbb_charger *chg, int irq, int flag)\n{\n\tbool state;\n\tint ret;\n\n\tret = irq_get_irqchip_state(irq, IRQCHIP_STATE_LINE_LEVEL, &state);\n\tif (ret < 0) {\n\t\tdev_err(chg->dev, \"failed to read irq line\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&chg->statlock);\n\tif (state)\n\t\tchg->status |= flag;\n\telse\n\t\tchg->status &= ~flag;\n\tmutex_unlock(&chg->statlock);\n\n\tdev_dbg(chg->dev, \"status = %03lx\\n\", chg->status);\n}\n\nstatic irqreturn_t smbb_usb_valid_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_USBIN_VALID);\n\textcon_set_state_sync(chg->edev, EXTCON_USB,\n\t\t\t\tchg->status & STATUS_USBIN_VALID);\n\tpower_supply_changed(chg->usb_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_dc_valid_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_DCIN_VALID);\n\tif (!chg->dc_disabled)\n\t\tpower_supply_changed(chg->dc_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_bat_temp_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\tunsigned int val;\n\tint rc;\n\n\trc = regmap_read(chg->regmap, chg->addr + SMBB_BAT_TEMP_STATUS, &val);\n\tif (rc)\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&chg->statlock);\n\tif (val & TEMP_STATUS_OK) {\n\t\tchg->status |= STATUS_BAT_OK;\n\t} else {\n\t\tchg->status &= ~STATUS_BAT_OK;\n\t\tif (val & TEMP_STATUS_HOT)\n\t\t\tchg->status |= STATUS_BAT_HOT;\n\t}\n\tmutex_unlock(&chg->statlock);\n\n\tpower_supply_changed(chg->bat_psy);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_bat_present_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_BAT_PRESENT);\n\tpower_supply_changed(chg->bat_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_chg_done_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_CHG_DONE);\n\tpower_supply_changed(chg->bat_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_chg_gone_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_CHG_GONE);\n\tpower_supply_changed(chg->bat_psy);\n\tpower_supply_changed(chg->usb_psy);\n\tif (!chg->dc_disabled)\n\t\tpower_supply_changed(chg->dc_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_chg_fast_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_CHG_FAST);\n\tpower_supply_changed(chg->bat_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t smbb_chg_trkl_handler(int irq, void *_data)\n{\n\tstruct smbb_charger *chg = _data;\n\n\tsmbb_set_line_flag(chg, irq, STATUS_CHG_TRKL);\n\tpower_supply_changed(chg->bat_psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct smbb_irq {\n\tconst char *name;\n\tirqreturn_t (*handler)(int, void *);\n} smbb_charger_irqs[] = {\n\t{ \"chg-done\", smbb_chg_done_handler },\n\t{ \"chg-fast\", smbb_chg_fast_handler },\n\t{ \"chg-trkl\", smbb_chg_trkl_handler },\n\t{ \"bat-temp-ok\", smbb_bat_temp_handler },\n\t{ \"bat-present\", smbb_bat_present_handler },\n\t{ \"chg-gone\", smbb_chg_gone_handler },\n\t{ \"usb-valid\", smbb_usb_valid_handler },\n\t{ \"dc-valid\", smbb_dc_valid_handler },\n};\n\nstatic int smbb_usbin_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tint rc = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tmutex_lock(&chg->statlock);\n\t\tval->intval = !(chg->status & STATUS_CHG_GONE) &&\n\t\t\t\t(chg->status & STATUS_USBIN_VALID);\n\t\tmutex_unlock(&chg->statlock);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\tval->intval = chg->attr[ATTR_USBIN_IMAX];\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\n\t\tval->intval = 2500000;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_usbin_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tint rc;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\trc = smbb_charger_attr_write(chg, ATTR_USBIN_IMAX,\n\t\t\t\tval->intval);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_dcin_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tint rc = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tmutex_lock(&chg->statlock);\n\t\tval->intval = !(chg->status & STATUS_CHG_GONE) &&\n\t\t\t\t(chg->status & STATUS_DCIN_VALID);\n\t\tmutex_unlock(&chg->statlock);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\tval->intval = chg->attr[ATTR_DCIN_IMAX];\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\n\t\tval->intval = 2500000;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_dcin_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tint rc;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\trc = smbb_charger_attr_write(chg, ATTR_DCIN_IMAX,\n\t\t\t\tval->intval);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_charger_writable_property(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT;\n}\n\nstatic int smbb_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tunsigned long status;\n\tint rc = 0;\n\n\tmutex_lock(&chg->statlock);\n\tstatus = chg->status;\n\tmutex_unlock(&chg->statlock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (status & STATUS_CHG_GONE)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (!(status & (STATUS_DCIN_VALID | STATUS_USBIN_VALID)))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (status & STATUS_CHG_DONE)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse if (!(status & STATUS_BAT_OK))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse if (status & (STATUS_CHG_FAST | STATUS_CHG_TRKL))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse  \n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (status & STATUS_BAT_OK)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\t\telse if (status & STATUS_BAT_HOT)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_COLD;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tif (status & STATUS_CHG_FAST)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\telse if (status & STATUS_CHG_TRKL)\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!(status & STATUS_BAT_PRESENT);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = chg->attr[ATTR_BAT_IMAX];\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tval->intval = chg->attr[ATTR_BAT_VMAX];\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t \n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tval->intval = 3000000;  \n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_battery_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct smbb_charger *chg = power_supply_get_drvdata(psy);\n\tint rc;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\trc = smbb_charger_attr_write(chg, ATTR_BAT_IMAX, val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\trc = smbb_charger_attr_write(chg, ATTR_BAT_VMAX, val->intval);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int smbb_battery_writable_property(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum power_supply_property smbb_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,\n};\n\nstatic enum power_supply_property smbb_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n};\n\nstatic const struct reg_off_mask_default {\n\tunsigned int offset;\n\tunsigned int mask;\n\tunsigned int value;\n\tunsigned int rev_mask;\n} smbb_charger_setup[] = {\n\t \n\t{ SMBB_MISC_BOOT_DONE, BOOT_DONE, BOOT_DONE },\n\n\t \n\t{ SMBB_CHG_TCHG_MAX_EN, TCHG_MAX_EN, 0 },\n\n\t \n\t{ SMBB_CHG_WDOG_TIME, 0xff, 160 },\n\t{ SMBB_CHG_WDOG_EN, WDOG_EN, 0 },\n\n\t \n\t{ SMBB_CHG_IBAT_TERM_CHG, IBAT_TERM_CHG_IEOC, IBAT_TERM_CHG_IEOC_CHG },\n\n\t \n\t{ SMBB_CHG_CFG, 0xff, 0x00, BIT(3) },\n\n\t \n\t{ SMBB_BUCK_REG_MODE, BUCK_REG_MODE, BUCK_REG_MODE_VBAT },\n\n\t \n\t{ SMBB_BAT_BTC_CTRL, BTC_CTRL_COMP_EN, BTC_CTRL_COMP_EN },\n\n\t \n\t{ SMBB_USB_ENUM_TIMER_STOP, ENUM_TIMER_STOP, ENUM_TIMER_STOP },\n\n#if 0  \n\t{ SMBB_USB_SEC_ACCESS, SEC_ACCESS_MAGIC },\n\t{ SMBB_USB_REV_BST, 0xff, REV_BST_CHG_GONE },\n#endif\n\n\t \n\t{ SMBB_USB_ENUM_TIMER_STOP, ENUM_TIMER_STOP, ENUM_TIMER_STOP },\n\n\t \n\t{ SMBB_CHG_CTRL, CTRL_EN, CTRL_EN },\n};\n\nstatic char *smbb_bif[] = { \"smbb-bif\" };\n\nstatic const struct power_supply_desc bat_psy_desc = {\n\t.name = \"smbb-bif\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = smbb_battery_properties,\n\t.num_properties = ARRAY_SIZE(smbb_battery_properties),\n\t.get_property = smbb_battery_get_property,\n\t.set_property = smbb_battery_set_property,\n\t.property_is_writeable = smbb_battery_writable_property,\n};\n\nstatic const struct power_supply_desc usb_psy_desc = {\n\t.name = \"smbb-usbin\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.properties = smbb_charger_properties,\n\t.num_properties = ARRAY_SIZE(smbb_charger_properties),\n\t.get_property = smbb_usbin_get_property,\n\t.set_property = smbb_usbin_set_property,\n\t.property_is_writeable = smbb_charger_writable_property,\n};\n\nstatic const struct power_supply_desc dc_psy_desc = {\n\t.name = \"smbb-dcin\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = smbb_charger_properties,\n\t.num_properties = ARRAY_SIZE(smbb_charger_properties),\n\t.get_property = smbb_dcin_get_property,\n\t.set_property = smbb_dcin_set_property,\n\t.property_is_writeable = smbb_charger_writable_property,\n};\n\nstatic int smbb_chg_otg_enable(struct regulator_dev *rdev)\n{\n\tstruct smbb_charger *chg = rdev_get_drvdata(rdev);\n\tint rc;\n\n\trc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,\n\t\t\t\tOTG_CTL_EN, OTG_CTL_EN);\n\tif (rc)\n\t\tdev_err(chg->dev, \"failed to update OTG_CTL\\n\");\n\treturn rc;\n}\n\nstatic int smbb_chg_otg_disable(struct regulator_dev *rdev)\n{\n\tstruct smbb_charger *chg = rdev_get_drvdata(rdev);\n\tint rc;\n\n\trc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,\n\t\t\t\tOTG_CTL_EN, 0);\n\tif (rc)\n\t\tdev_err(chg->dev, \"failed to update OTG_CTL\\n\");\n\treturn rc;\n}\n\nstatic int smbb_chg_otg_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct smbb_charger *chg = rdev_get_drvdata(rdev);\n\tunsigned int value = 0;\n\tint rc;\n\n\trc = regmap_read(chg->regmap, chg->addr + SMBB_USB_OTG_CTL, &value);\n\tif (rc)\n\t\tdev_err(chg->dev, \"failed to read OTG_CTL\\n\");\n\n\treturn !!(value & OTG_CTL_EN);\n}\n\nstatic const struct regulator_ops smbb_chg_otg_ops = {\n\t.enable = smbb_chg_otg_enable,\n\t.disable = smbb_chg_otg_disable,\n\t.is_enabled = smbb_chg_otg_is_enabled,\n};\n\nstatic int smbb_charger_probe(struct platform_device *pdev)\n{\n\tstruct power_supply_config bat_cfg = {};\n\tstruct power_supply_config usb_cfg = {};\n\tstruct power_supply_config dc_cfg = {};\n\tstruct smbb_charger *chg;\n\tstruct regulator_config config = { };\n\tint rc, i;\n\n\tchg = devm_kzalloc(&pdev->dev, sizeof(*chg), GFP_KERNEL);\n\tif (!chg)\n\t\treturn -ENOMEM;\n\n\tchg->dev = &pdev->dev;\n\tmutex_init(&chg->statlock);\n\n\tchg->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chg->regmap) {\n\t\tdev_err(&pdev->dev, \"failed to locate regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = of_property_read_u32(pdev->dev.of_node, \"reg\", &chg->addr);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"missing or invalid 'reg' property\\n\");\n\t\treturn rc;\n\t}\n\n\trc = regmap_read(chg->regmap, chg->addr + SMBB_MISC_REV2, &chg->revision);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"unable to read revision\\n\");\n\t\treturn rc;\n\t}\n\n\tchg->revision += 1;\n\tif (chg->revision != 1 && chg->revision != 2 && chg->revision != 3) {\n\t\tdev_err(&pdev->dev, \"v%d hardware not supported\\n\", chg->revision);\n\t\treturn -ENODEV;\n\t}\n\tdev_info(&pdev->dev, \"Initializing SMBB rev %u\", chg->revision);\n\n\tchg->dc_disabled = of_property_read_bool(pdev->dev.of_node, \"qcom,disable-dc\");\n\n\tfor (i = 0; i < _ATTR_CNT; ++i) {\n\t\trc = smbb_charger_attr_parse(chg, i);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse/apply settings\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tbat_cfg.drv_data = chg;\n\tbat_cfg.of_node = pdev->dev.of_node;\n\tchg->bat_psy = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t  &bat_psy_desc,\n\t\t\t\t\t\t  &bat_cfg);\n\tif (IS_ERR(chg->bat_psy)) {\n\t\tdev_err(&pdev->dev, \"failed to register battery\\n\");\n\t\treturn PTR_ERR(chg->bat_psy);\n\t}\n\n\tusb_cfg.drv_data = chg;\n\tusb_cfg.supplied_to = smbb_bif;\n\tusb_cfg.num_supplicants = ARRAY_SIZE(smbb_bif);\n\tchg->usb_psy = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t  &usb_psy_desc,\n\t\t\t\t\t\t  &usb_cfg);\n\tif (IS_ERR(chg->usb_psy)) {\n\t\tdev_err(&pdev->dev, \"failed to register USB power supply\\n\");\n\t\treturn PTR_ERR(chg->usb_psy);\n\t}\n\n\tchg->edev = devm_extcon_dev_allocate(&pdev->dev, smbb_usb_extcon_cable);\n\tif (IS_ERR(chg->edev)) {\n\t\tdev_err(&pdev->dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = devm_extcon_dev_register(&pdev->dev, chg->edev);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register extcon device\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!chg->dc_disabled) {\n\t\tdc_cfg.drv_data = chg;\n\t\tdc_cfg.supplied_to = smbb_bif;\n\t\tdc_cfg.num_supplicants = ARRAY_SIZE(smbb_bif);\n\t\tchg->dc_psy = devm_power_supply_register(&pdev->dev,\n\t\t\t\t\t\t\t &dc_psy_desc,\n\t\t\t\t\t\t\t &dc_cfg);\n\t\tif (IS_ERR(chg->dc_psy)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register DC power supply\\n\");\n\t\t\treturn PTR_ERR(chg->dc_psy);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(smbb_charger_irqs); ++i) {\n\t\tint irq;\n\n\t\tirq = platform_get_irq_byname(pdev, smbb_charger_irqs[i].name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tsmbb_charger_irqs[i].handler(irq, chg);\n\n\t\trc = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\tsmbb_charger_irqs[i].handler, IRQF_ONESHOT,\n\t\t\t\tsmbb_charger_irqs[i].name, chg);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"failed to request irq '%s'\\n\",\n\t\t\t\tsmbb_charger_irqs[i].name);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\tchg->otg_rdesc.id = -1;\n\tchg->otg_rdesc.name = \"otg-vbus\";\n\tchg->otg_rdesc.ops = &smbb_chg_otg_ops;\n\tchg->otg_rdesc.owner = THIS_MODULE;\n\tchg->otg_rdesc.type = REGULATOR_VOLTAGE;\n\tchg->otg_rdesc.supply_name = \"usb-otg-in\";\n\tchg->otg_rdesc.of_match = \"otg-vbus\";\n\n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = chg;\n\n\tchg->otg_reg = devm_regulator_register(&pdev->dev, &chg->otg_rdesc,\n\t\t\t\t\t       &config);\n\tif (IS_ERR(chg->otg_reg))\n\t\treturn PTR_ERR(chg->otg_reg);\n\n\tchg->jeita_ext_temp = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\"qcom,jeita-extended-temp-range\");\n\n\t \n\trc = regmap_update_bits(chg->regmap, chg->addr + SMBB_BAT_BTC_CTRL,\n\t\t\tBTC_CTRL_COLD_EXT | BTC_CTRL_HOT_EXT_N,\n\t\t\tchg->jeita_ext_temp ?\n\t\t\t\tBTC_CTRL_COLD_EXT :\n\t\t\t\tBTC_CTRL_HOT_EXT_N);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to set %s temperature range\\n\",\n\t\t\tchg->jeita_ext_temp ? \"JEITA extended\" : \"normal\");\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(smbb_charger_setup); ++i) {\n\t\tconst struct reg_off_mask_default *r = &smbb_charger_setup[i];\n\n\t\tif (r->rev_mask & BIT(chg->revision))\n\t\t\tcontinue;\n\n\t\trc = regmap_update_bits(chg->regmap, chg->addr + r->offset,\n\t\t\t\tr->mask, r->value);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to initializing charging, bailing\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, chg);\n\n\treturn 0;\n}\n\nstatic int smbb_charger_remove(struct platform_device *pdev)\n{\n\tstruct smbb_charger *chg;\n\n\tchg = platform_get_drvdata(pdev);\n\n\tregmap_update_bits(chg->regmap, chg->addr + SMBB_CHG_CTRL, CTRL_EN, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id smbb_charger_id_table[] = {\n\t{ .compatible = \"qcom,pm8226-charger\" },\n\t{ .compatible = \"qcom,pm8941-charger\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, smbb_charger_id_table);\n\nstatic struct platform_driver smbb_charger_driver = {\n\t.probe\t  = smbb_charger_probe,\n\t.remove\t = smbb_charger_remove,\n\t.driver\t = {\n\t\t.name   = \"qcom-smbb\",\n\t\t.of_match_table = smbb_charger_id_table,\n\t},\n};\nmodule_platform_driver(smbb_charger_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Switch-Mode Battery Charger and Boost driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}