{
  "module_name": "rt9471.c",
  "hash_id": "b2a141813b67382d122285e662aa73fe4070a34963104eb69afe65a8e51bb835",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/rt9471.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kstrtox.h>\n#include <linux/linear_range.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/sysfs.h>\n\n#define RT9471_REG_OTGCFG\t0x00\n#define RT9471_REG_TOP\t\t0x01\n#define RT9471_REG_FUNC\t\t0x02\n#define RT9471_REG_IBUS\t\t0x03\n#define RT9471_REG_VBUS\t\t0x04\n#define RT9471_REG_PRECHG\t0x05\n#define RT9471_REG_VCHG\t\t0x07\n#define RT9471_REG_ICHG\t\t0x08\n#define RT9471_REG_CHGTMR\t0x09\n#define RT9471_REG_EOC\t\t0x0A\n#define RT9471_REG_INFO\t\t0x0B\n#define RT9471_REG_JEITA\t0x0C\n#define RT9471_REG_PUMP_EXP\t0x0D\n#define\tRT9471_REG_DPDMDET\t0x0E\n#define RT9471_REG_ICSTAT\t0x0F\n#define\tRT9471_REG_STAT0\t0x10\n#define RT9471_REG_STAT1\t0x11\n#define RT9471_REG_STAT2\t0x12\n#define RT9471_REG_IRQ0\t\t0x20\n#define RT9471_REG_MASK0\t0x30\n\n#define RT9471_OTGCV_MASK\tGENMASK(7, 6)\n#define RT9471_OTGCC_MASK\tBIT(0)\n#define RT9471_OTGEN_MASK\tBIT(1)\n#define RT9471_CHGFAULT_MASK\tGENMASK(4, 1)\n\n#define RT9471_NUM_IRQ_REGS\t4\n#define RT9471_OTGCV_MINUV\t4850000\n#define RT9471_OTGCV_STEPUV\t150000\n#define RT9471_NUM_VOTG\t\t4\n#define RT9471_VCHG_MAXUV\t4700000\n#define RT9471_ICHG_MAXUA\t3150000\n\n \n#define RT9470_DEVID\t\t0x09\n#define RT9470D_DEVID\t\t0x0A\n#define RT9471_DEVID\t\t0x0D\n#define RT9471D_DEVID\t\t0x0E\n\n \n#define RT9471_IRQ_BC12_DONE\t0\n#define RT9471_IRQ_DETACH\t1\n#define RT9471_IRQ_RECHG\t2\n#define RT9471_IRQ_CHG_DONE\t3\n#define RT9471_IRQ_BG_CHG\t4\n#define RT9471_IRQ_IE0C\t\t5\n#define RT9471_IRQ_CHG_RDY\t6\n#define RT9471_IRQ_VBUS_GD\t7\n#define RT9471_IRQ_CHG_BATOV\t9\n#define RT9471_IRQ_CHG_SYSOV\t10\n#define RT9471_IRQ_CHG_TOUT\t11\n#define RT9471_IRQ_CHG_BUSUV\t12\n#define RT9471_IRQ_CHG_THREG\t13\n#define RT9471_IRQ_CHG_AICR\t14\n#define RT9471_IRQ_CHG_MIVR\t15\n#define RT9471_IRQ_SYS_SHORT\t16\n#define RT9471_IRQ_SYS_MIN\t17\n#define RT9471_IRQ_AICC_DONE\t18\n#define RT9471_IRQ_PE_DONE\t19\n#define RT9471_IRQ_JEITA_COLD\t20\n#define RT9471_IRQ_JEITA_COOL\t21\n#define RT9471_IRQ_JEITA_WARM\t22\n#define RT9471_IRQ_JEITA_HOT\t23\n#define RT9471_IRQ_OTG_FAULT\t24\n#define RT9471_IRQ_OTG_LBP\t25\n#define RT9471_IRQ_OTG_CC\t26\n#define RT9471_IRQ_WDT\t\t29\n#define RT9471_IRQ_VAC_OV\t30\n#define RT9471_IRQ_OTP\t\t31\n\nenum rt9471_fields {\n\tF_WDT = 0,\n\tF_WDT_RST,\n\tF_CHG_EN,\n\tF_HZ,\n\tF_BATFET_DIS,\n\tF_AICR,\n\tF_AICC_EN,\n\tF_MIVR,\n\tF_IPRE_CHG,\n\tF_VPRE_CHG,\n\tF_VBAT_REG,\n\tF_ICHG_REG,\n\tF_EOC_RST,\n\tF_TE,\n\tF_IEOC_CHG,\n\tF_DEVICE_ID,\n\tF_REG_RST,\n\tF_BC12_EN,\n\tF_IC_STAT,\n\tF_PORT_STAT,\n\tF_ST_CHG_DONE,\n\tF_ST_CHG_RDY,\n\tF_ST_VBUS_GD,\n\tF_MAX_FIELDS\n};\n\nenum rt9471_ranges {\n\tRT9471_RANGE_AICR = 0,\n\tRT9471_RANGE_MIVR,\n\tRT9471_RANGE_IPRE,\n\tRT9471_RANGE_VCHG,\n\tRT9471_RANGE_ICHG,\n\tRT9471_RANGE_IEOC,\n\tRT9471_MAX_RANGES\n};\n\nenum {\n\tRT9471_PORTSTAT_APPLE_10W = 8,\n\tRT9471_PORTSTAT_SAMSUNG_10W,\n\tRT9471_PORTSTAT_APPLE_5W,\n\tRT9471_PORTSTAT_APPLE_12W,\n\tRT9471_PORTSTAT_NSTD,\n\tRT9471_PORTSTAT_SDP,\n\tRT9471_PORTSTAT_CDP,\n\tRT9471_PORTSTAT_DCP,\n};\n\nstruct rt9471_chip {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_field *rm_fields[F_MAX_FIELDS];\n\tstruct regmap_irq_chip_data *irq_chip_data;\n\tstruct regulator_dev *otg_rdev;\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tstruct mutex var_lock;\n\tenum power_supply_usb_type psy_usb_type;\n\tint psy_usb_curr;\n};\n\nstatic const struct reg_field rt9471_reg_fields[F_MAX_FIELDS] = {\n\t[F_WDT]\t\t= REG_FIELD(RT9471_REG_TOP, 0, 0),\n\t[F_WDT_RST]\t= REG_FIELD(RT9471_REG_TOP, 1, 1),\n\t[F_CHG_EN]\t= REG_FIELD(RT9471_REG_FUNC, 0, 0),\n\t[F_HZ]\t\t= REG_FIELD(RT9471_REG_FUNC, 5, 5),\n\t[F_BATFET_DIS]\t= REG_FIELD(RT9471_REG_FUNC, 7, 7),\n\t[F_AICR]\t= REG_FIELD(RT9471_REG_IBUS, 0, 5),\n\t[F_AICC_EN]\t= REG_FIELD(RT9471_REG_IBUS, 7, 7),\n\t[F_MIVR]\t= REG_FIELD(RT9471_REG_VBUS, 0, 3),\n\t[F_IPRE_CHG]\t= REG_FIELD(RT9471_REG_PRECHG, 0, 3),\n\t[F_VPRE_CHG]\t= REG_FIELD(RT9471_REG_PRECHG, 4, 6),\n\t[F_VBAT_REG]\t= REG_FIELD(RT9471_REG_VCHG, 0, 6),\n\t[F_ICHG_REG]\t= REG_FIELD(RT9471_REG_ICHG, 0, 5),\n\t[F_EOC_RST]\t= REG_FIELD(RT9471_REG_EOC, 0, 0),\n\t[F_TE]\t\t= REG_FIELD(RT9471_REG_EOC, 1, 1),\n\t[F_IEOC_CHG]\t= REG_FIELD(RT9471_REG_EOC, 4, 7),\n\t[F_DEVICE_ID]\t= REG_FIELD(RT9471_REG_INFO, 3, 6),\n\t[F_REG_RST]\t= REG_FIELD(RT9471_REG_INFO, 7, 7),\n\t[F_BC12_EN]\t= REG_FIELD(RT9471_REG_DPDMDET, 7, 7),\n\t[F_IC_STAT]\t= REG_FIELD(RT9471_REG_ICSTAT, 0, 3),\n\t[F_PORT_STAT]\t= REG_FIELD(RT9471_REG_ICSTAT, 4, 7),\n\t[F_ST_CHG_DONE]\t= REG_FIELD(RT9471_REG_STAT0, 3, 3),\n\t[F_ST_CHG_RDY]\t= REG_FIELD(RT9471_REG_STAT0, 6, 6),\n\t[F_ST_VBUS_GD]\t= REG_FIELD(RT9471_REG_STAT0, 7, 7),\n};\n\nstatic const struct linear_range rt9471_chg_ranges[RT9471_MAX_RANGES] = {\n\t[RT9471_RANGE_AICR] = { .min = 50000,\t.min_sel = 1, .max_sel = 63, .step = 50000 },\n\t[RT9471_RANGE_MIVR] = { .min = 3900000,\t.min_sel = 0, .max_sel = 15, .step = 100000 },\n\t[RT9471_RANGE_IPRE] = { .min = 50000,\t.min_sel = 0, .max_sel = 15, .step = 50000 },\n\t[RT9471_RANGE_VCHG] = { .min = 3900000,\t.min_sel = 0, .max_sel = 80, .step = 10000 },\n\t[RT9471_RANGE_ICHG] = { .min = 0,\t.min_sel = 0, .max_sel = 63, .step = 50000 },\n\t[RT9471_RANGE_IEOC] = { .min = 50000,\t.min_sel = 0, .max_sel = 15, .step = 50000 },\n};\n\nstatic int rt9471_set_value_by_field_range(struct rt9471_chip *chip,\n\t\t\t\t\t   enum rt9471_fields field,\n\t\t\t\t\t   enum rt9471_ranges range, int val)\n{\n\tunsigned int sel;\n\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tlinear_range_get_selector_within(rt9471_chg_ranges + range, val, &sel);\n\n\treturn regmap_field_write(chip->rm_fields[field], sel);\n}\n\n\nstatic int rt9471_get_value_by_field_range(struct rt9471_chip *chip,\n\t\t\t\t\t   enum rt9471_fields field,\n\t\t\t\t\t   enum rt9471_ranges range, int *val)\n{\n\tunsigned int sel, rvalue;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[field], &sel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = linear_range_get_value(rt9471_chg_ranges + range, sel, &rvalue);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = rvalue;\n\treturn 0;\n}\n\nstatic int rt9471_set_ieoc(struct rt9471_chip *chip, int microamp)\n{\n\tint ret;\n\n\tif (microamp == 0)\n\t\treturn regmap_field_write(chip->rm_fields[F_TE], 0);\n\n\tret = rt9471_set_value_by_field_range(chip, F_IEOC_CHG, RT9471_RANGE_IEOC, microamp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_field_write(chip->rm_fields[F_TE], 1);\n}\n\nstatic int rt9471_get_ieoc(struct rt9471_chip *chip, int *microamp)\n{\n\tunsigned int chg_term_enable;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_TE], &chg_term_enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!chg_term_enable) {\n\t\t*microamp = 0;\n\t\treturn 0;\n\t}\n\n\treturn rt9471_get_value_by_field_range(chip, F_IEOC_CHG, RT9471_RANGE_IEOC, microamp);\n}\n\nstatic int rt9471_get_status(struct rt9471_chip *chip, int *status)\n{\n\tunsigned int chg_ready, chg_done, fault_stat;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_ST_CHG_RDY], &chg_ready);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_ST_CHG_DONE], &chg_done);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(chip->regmap, RT9471_REG_STAT1, &fault_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tfault_stat &= RT9471_CHGFAULT_MASK;\n\n\tif (chg_ready && chg_done)\n\t\t*status = POWER_SUPPLY_STATUS_FULL;\n\telse if (chg_ready && fault_stat)\n\t\t*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\telse if (chg_ready && !fault_stat)\n\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\telse\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\treturn 0;\n}\n\nstatic int rt9471_get_vbus_good(struct rt9471_chip *chip, int *stat)\n{\n\tunsigned int vbus_gd;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_ST_VBUS_GD], &vbus_gd);\n\tif (ret)\n\t\treturn ret;\n\n\t*stat = vbus_gd;\n\treturn 0;\n}\n\nstatic int rt9471_get_usb_type(struct rt9471_chip *chip, int *usb_type)\n{\n\tmutex_lock(&chip->var_lock);\n\t*usb_type = chip->psy_usb_type;\n\tmutex_unlock(&chip->var_lock);\n\n\treturn 0;\n}\n\nstatic int rt9471_get_usb_type_current(struct rt9471_chip *chip,\n\t\t\t\t\t      int *microamp)\n{\n\tmutex_lock(&chip->var_lock);\n\t*microamp = chip->psy_usb_curr;\n\tmutex_unlock(&chip->var_lock);\n\n\treturn 0;\n}\n\nstatic enum power_supply_property rt9471_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic enum power_supply_usb_type rt9471_charger_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID,\n};\n\nstatic int rt9471_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int rt9471_charger_set_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       const union power_supply_propval *val)\n{\n\tstruct rt9471_chip *chip = power_supply_get_drvdata(psy);\n\tint value = val->intval;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn regmap_field_write(chip->rm_fields[F_CHG_EN], !!value);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn regmap_field_write(chip->rm_fields[F_HZ], !value);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn rt9471_set_value_by_field_range(chip, F_ICHG_REG, RT9471_RANGE_ICHG, value);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn rt9471_set_value_by_field_range(chip, F_VBAT_REG, RT9471_RANGE_VCHG, value);\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn rt9471_set_value_by_field_range(chip, F_AICR, RT9471_RANGE_AICR, value);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn rt9471_set_value_by_field_range(chip, F_MIVR, RT9471_RANGE_MIVR, value);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn rt9471_set_value_by_field_range(chip, F_IPRE_CHG, RT9471_RANGE_IPRE, value);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn rt9471_set_ieoc(chip, val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char * const rt9471_manufacturer\t= \"Richtek Technology Corp.\";\nstatic const char * const rt9471_model\t\t= \"RT9471\";\n\nstatic int rt9471_charger_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct rt9471_chip *chip = power_supply_get_drvdata(psy);\n\tint *pvalue = &val->intval;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\treturn rt9471_get_status(chip, pvalue);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn rt9471_get_vbus_good(chip, pvalue);\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn rt9471_get_usb_type_current(chip, pvalue);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\treturn rt9471_get_value_by_field_range(chip, F_ICHG_REG, RT9471_RANGE_ICHG, pvalue);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\t*pvalue = RT9471_ICHG_MAXUA;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\treturn rt9471_get_value_by_field_range(chip, F_VBAT_REG, RT9471_RANGE_VCHG, pvalue);\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = RT9471_VCHG_MAXUV;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn rt9471_get_value_by_field_range(chip, F_AICR, RT9471_RANGE_AICR, pvalue);\n\tcase POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:\n\t\treturn rt9471_get_value_by_field_range(chip, F_MIVR, RT9471_RANGE_MIVR, pvalue);\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn rt9471_get_usb_type(chip, pvalue);\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\treturn rt9471_get_value_by_field_range(chip, F_IPRE_CHG, RT9471_RANGE_IPRE, pvalue);\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\treturn rt9471_get_ieoc(chip, pvalue);\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = rt9471_model;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = rt9471_manufacturer;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic irqreturn_t rt9471_vbus_gd_handler(int irqno, void *devid)\n{\n\tstruct rt9471_chip *chip = devid;\n\n\tpower_supply_changed(chip->psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9471_detach_handler(int irqno, void *devid)\n{\n\tstruct rt9471_chip *chip = devid;\n\tunsigned int vbus_gd;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_ST_VBUS_GD], &vbus_gd);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (vbus_gd)\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&chip->var_lock);\n\tchip->psy_usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\tchip->psy_usb_curr = 0;\n\tmutex_unlock(&chip->var_lock);\n\n\tpower_supply_changed(chip->psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9471_bc12_done_handler(int irqno, void *devid)\n{\n\tstruct rt9471_chip *chip = devid;\n\tenum power_supply_usb_type usb_type;\n\tunsigned int port_stat;\n\tint usb_curr, ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_PORT_STAT], &port_stat);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tswitch (port_stat) {\n\tcase RT9471_PORTSTAT_APPLE_10W:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID;\n\t\tusb_curr = 2000000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_APPLE_5W:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID;\n\t\tusb_curr = 1000000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_APPLE_12W:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID;\n\t\tusb_curr = 2400000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_SAMSUNG_10W:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tusb_curr = 2000000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_DCP:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\tusb_curr = 1500000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_NSTD:\n\tcase RT9471_PORTSTAT_SDP:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\tusb_curr = 500000;\n\t\tbreak;\n\tcase RT9471_PORTSTAT_CDP:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\tusb_curr = 1500000;\n\t\tbreak;\n\tdefault:\n\t\tusb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\t\tusb_curr = 0;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&chip->var_lock);\n\tchip->psy_usb_type = usb_type;\n\tchip->psy_usb_curr = usb_curr;\n\tmutex_unlock(&chip->var_lock);\n\n\tpower_supply_changed(chip->psy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9471_wdt_handler(int irqno, void *devid)\n{\n\tstruct rt9471_chip *chip = devid;\n\tint ret;\n\n\tret = regmap_field_write(chip->rm_fields[F_WDT_RST], 1);\n\n\treturn ret ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic irqreturn_t rt9471_otg_fault_handler(int irqno, void *devid)\n{\n\tstruct rt9471_chip *chip = devid;\n\n\tregulator_notifier_call_chain(chip->otg_rdev, REGULATOR_EVENT_FAIL, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n#define RT9471_IRQ_DESC(_name, _hwirq) \\\n{ \\\n\t.name = #_name, \\\n\t.hwirq = _hwirq, \\\n\t.handler = rt9471_##_name##_handler, \\\n}\n\nstatic int rt9471_register_interrupts(struct rt9471_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstatic const struct {\n\t\tchar *name;\n\t\tint hwirq;\n\t\tirq_handler_t handler;\n\t} chg_irqs[] = {\n\t\tRT9471_IRQ_DESC(vbus_gd, RT9471_IRQ_VBUS_GD),\n\t\tRT9471_IRQ_DESC(detach, RT9471_IRQ_DETACH),\n\t\tRT9471_IRQ_DESC(bc12_done, RT9471_IRQ_BC12_DONE),\n\t\tRT9471_IRQ_DESC(wdt, RT9471_IRQ_WDT),\n\t\tRT9471_IRQ_DESC(otg_fault, RT9471_IRQ_OTG_FAULT),\n\t}, *curr;\n\tint i, virq, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(chg_irqs); i++) {\n\t\tcurr = chg_irqs + i;\n\n\t\tvirq = regmap_irq_get_virq(chip->irq_chip_data, curr->hwirq);\n\t\tif (virq <= 0)\n\t\t\treturn virq;\n\n\t\tret = devm_request_threaded_irq(dev, virq, NULL, curr->handler,\n\t\t\t\t\t\tIRQF_ONESHOT, curr->name, chip);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to register IRQ (%s)\\n\",\n\t\t\t\t\t     curr->name);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops rt9471_otg_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n};\n\nstatic const unsigned int rt9471_otg_microamp[] = { 500000, 1200000, };\n\nstatic const struct regulator_desc rt9471_otg_rdesc = {\n\t.of_match = of_match_ptr(\"usb-otg-vbus-regulator\"),\n\t.name = \"rt9471-otg-vbus\",\n\t.owner = THIS_MODULE,\n\t.type = REGULATOR_VOLTAGE,\n\t.ops = &rt9471_otg_ops,\n\t.min_uV = RT9471_OTGCV_MINUV,\n\t.uV_step = RT9471_OTGCV_STEPUV,\n\t.n_voltages = RT9471_NUM_VOTG,\n\t.curr_table = rt9471_otg_microamp,\n\t.n_current_limits = ARRAY_SIZE(rt9471_otg_microamp),\n\t.enable_mask = RT9471_OTGEN_MASK,\n\t.enable_reg = RT9471_REG_FUNC,\n\t.vsel_reg = RT9471_REG_OTGCFG,\n\t.vsel_mask = RT9471_OTGCV_MASK,\n\t.csel_reg = RT9471_REG_OTGCFG,\n\t.csel_mask = RT9471_OTGCC_MASK,\n};\n\nstatic int rt9471_register_otg_regulator(struct rt9471_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct regulator_config cfg = { .dev = dev, .driver_data = chip };\n\n\tchip->otg_rdev = devm_regulator_register(dev, &rt9471_otg_rdesc, &cfg);\n\n\treturn PTR_ERR_OR_ZERO(chip->otg_rdev);\n}\n\nstatic inline struct rt9471_chip *psy_device_to_chip(struct device *dev)\n{\n\treturn power_supply_get_drvdata(to_power_supply(dev));\n}\n\nstatic ssize_t sysoff_enable_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct rt9471_chip *chip = psy_device_to_chip(dev);\n\tunsigned int sysoff_enable;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_BATFET_DIS], &sysoff_enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", sysoff_enable);\n}\n\nstatic ssize_t sysoff_enable_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct rt9471_chip *chip = psy_device_to_chip(dev);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_write(chip->rm_fields[F_BATFET_DIS], !!tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t port_detect_enable_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct rt9471_chip *chip = psy_device_to_chip(dev);\n\tunsigned int bc12_enable;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_BC12_EN], &bc12_enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", bc12_enable);\n}\n\nstatic ssize_t port_detect_enable_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct rt9471_chip *chip = psy_device_to_chip(dev);\n\tunsigned int tmp;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_write(chip->rm_fields[F_BC12_EN], !!tmp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(sysoff_enable);\nstatic DEVICE_ATTR_RW(port_detect_enable);\n\nstatic struct attribute *rt9471_sysfs_attrs[] = {\n\t&dev_attr_sysoff_enable.attr,\n\t&dev_attr_port_detect_enable.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(rt9471_sysfs);\n\nstatic int rt9471_register_psy(struct rt9471_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct power_supply_desc *desc = &chip->psy_desc;\n\tstruct power_supply_config cfg = {};\n\tchar *psy_name;\n\n\tcfg.drv_data = chip;\n\tcfg.of_node = dev->of_node;\n\tcfg.attr_grp = rt9471_sysfs_groups;\n\n\tpsy_name = devm_kasprintf(dev, GFP_KERNEL, \"rt9471-%s\", dev_name(dev));\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\tdesc->name = psy_name;\n\tdesc->type = POWER_SUPPLY_TYPE_USB;\n\tdesc->usb_types = rt9471_charger_usb_types;\n\tdesc->num_usb_types = ARRAY_SIZE(rt9471_charger_usb_types);\n\tdesc->properties = rt9471_charger_properties;\n\tdesc->num_properties = ARRAY_SIZE(rt9471_charger_properties);\n\tdesc->get_property = rt9471_charger_get_property;\n\tdesc->set_property = rt9471_charger_set_property;\n\tdesc->property_is_writeable = rt9471_charger_property_is_writeable;\n\n\tchip->psy = devm_power_supply_register(dev, desc, &cfg);\n\n\treturn PTR_ERR_OR_ZERO(chip->psy);\n}\n\nstatic const struct regmap_irq rt9471_regmap_irqs[] = {\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_BC12_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_DETACH, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_RECHG, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_BG_CHG, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_IE0C, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_RDY, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_VBUS_GD, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_BATOV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_SYSOV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_TOUT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_BUSUV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_THREG, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_AICR, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_CHG_MIVR, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_SYS_SHORT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_SYS_MIN, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_AICC_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_PE_DONE, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_JEITA_COLD, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_JEITA_COOL, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_JEITA_WARM, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_JEITA_HOT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_OTG_FAULT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_OTG_LBP, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_OTG_CC, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_WDT, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_VAC_OV, 8),\n\tREGMAP_IRQ_REG_LINE(RT9471_IRQ_OTP, 8),\n};\n\nstatic const struct regmap_irq_chip rt9471_irq_chip = {\n\t.name = \"rt9471-irqs\",\n\t.status_base = RT9471_REG_IRQ0,\n\t.mask_base = RT9471_REG_MASK0,\n\t.num_regs = RT9471_NUM_IRQ_REGS,\n\t.irqs = rt9471_regmap_irqs,\n\t.num_irqs = ARRAY_SIZE(rt9471_regmap_irqs),\n};\n\nstatic const struct reg_sequence rt9471_init_regs[] = {\n\tREG_SEQ0(RT9471_REG_INFO, 0x80),  \n\tREG_SEQ0(RT9471_REG_TOP, 0xC0),  \n\tREG_SEQ0(RT9471_REG_FUNC, 0x01),  \n\tREG_SEQ0(RT9471_REG_IBUS, 0x0A),  \n\tREG_SEQ0(RT9471_REG_VBUS, 0xC6),  \n\tREG_SEQ0(RT9471_REG_JEITA, 0x38),  \n\tREG_SEQ0(RT9471_REG_DPDMDET, 0x31),  \n};\n\nstatic int rt9471_check_devinfo(struct rt9471_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tunsigned int dev_id;\n\tint ret;\n\n\tret = regmap_field_read(chip->rm_fields[F_DEVICE_ID], &dev_id);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read device_id\\n\");\n\n\tswitch (dev_id) {\n\tcase RT9470_DEVID:\n\tcase RT9470D_DEVID:\n\tcase RT9471_DEVID:\n\tcase RT9471D_DEVID:\n\t\treturn 0;\n\tdefault:\n\t\treturn dev_err_probe(dev, -ENODEV, \"Incorrect device id\\n\");\n\t}\n}\n\nstatic bool rt9471_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00 ... 0x0F:\n\tcase 0x10 ... 0x13:\n\tcase 0x20 ... 0x33:\n\tcase 0x40 ... 0xA1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt9471_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xA1,\n\t.writeable_reg = rt9471_accessible_reg,\n\t.readable_reg = rt9471_accessible_reg,\n};\n\nstatic int rt9471_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct rt9471_chip *chip;\n\tstruct gpio_desc *ce_gpio;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tmutex_init(&chip->var_lock);\n\ti2c_set_clientdata(i2c, chip);\n\n\t \n\tce_gpio = devm_gpiod_get_optional(dev, \"charge-enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ce_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ce_gpio),\n\t\t\t\t     \"Failed to config charge enable gpio\\n\");\n\n\tregmap = devm_regmap_init_i2c(i2c, &rt9471_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to init regmap\\n\");\n\n\tchip->regmap = regmap;\n\n\tret = devm_regmap_field_bulk_alloc(dev, regmap, chip->rm_fields,\n\t\t\t\t\t   rt9471_reg_fields,\n\t\t\t\t\t   ARRAY_SIZE(rt9471_reg_fields));\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to alloc regmap field\\n\");\n\n\tret = rt9471_check_devinfo(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_register_patch(regmap, rt9471_init_regs,\n\t\t\t\t    ARRAY_SIZE(rt9471_init_regs));\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init registers\\n\");\n\n\tret = devm_regmap_add_irq_chip(dev, regmap, i2c->irq,\n\t\t\t\t       IRQF_TRIGGER_FALLING | IRQF_ONESHOT, 0,\n\t\t\t\t       &rt9471_irq_chip, &chip->irq_chip_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add IRQ chip\\n\");\n\n\tret = rt9471_register_psy(chip);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to register psy\\n\");\n\n\tret = rt9471_register_otg_regulator(chip);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to register otg\\n\");\n\n\tret = rt9471_register_interrupts(chip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_field_write(chip->rm_fields[F_BC12_EN], 1);\n}\n\nstatic void rt9471_shutdown(struct i2c_client *i2c)\n{\n\tstruct rt9471_chip *chip = i2c_get_clientdata(i2c);\n\n\t \n\tregmap_field_write(chip->rm_fields[F_REG_RST], 1);\n}\n\nstatic const struct of_device_id rt9471_of_device_id[] = {\n\t{ .compatible = \"richtek,rt9471\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt9471_of_device_id);\n\nstatic struct i2c_driver rt9471_driver = {\n\t.driver = {\n\t\t.name = \"rt9471\",\n\t\t.of_match_table = rt9471_of_device_id,\n\t},\n\t.probe = rt9471_probe,\n\t.shutdown = rt9471_shutdown,\n};\nmodule_i2c_driver(rt9471_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT9471 charger driver\");\nMODULE_AUTHOR(\"Alina Yu <alina_yu@richtek.com>\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}