{
  "module_name": "gpio-charger.c",
  "hash_id": "134bd26141b0728ea8ea56840f02bb403e0fa8b30fa6c4ba75c122c122032365",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/gpio-charger.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n\n#include <linux/power/gpio-charger.h>\n\nstruct gpio_mapping {\n\tu32 limit_ua;\n\tu32 gpiodata;\n} __packed;\n\nstruct gpio_charger {\n\tstruct device *dev;\n\tunsigned int irq;\n\tunsigned int charge_status_irq;\n\tbool wakeup_enabled;\n\n\tstruct power_supply *charger;\n\tstruct power_supply_desc charger_desc;\n\tstruct gpio_desc *gpiod;\n\tstruct gpio_desc *charge_status;\n\n\tstruct gpio_descs *current_limit_gpios;\n\tstruct gpio_mapping *current_limit_map;\n\tu32 current_limit_map_size;\n\tu32 charge_current_limit;\n};\n\nstatic irqreturn_t gpio_charger_irq(int irq, void *devid)\n{\n\tstruct power_supply *charger = devid;\n\n\tpower_supply_changed(charger);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline struct gpio_charger *psy_to_gpio_charger(struct power_supply *psy)\n{\n\treturn power_supply_get_drvdata(psy);\n}\n\nstatic int set_charge_current_limit(struct gpio_charger *gpio_charger, int val)\n{\n\tstruct gpio_mapping mapping;\n\tint ndescs = gpio_charger->current_limit_gpios->ndescs;\n\tstruct gpio_desc **gpios = gpio_charger->current_limit_gpios->desc;\n\tint i;\n\n\tif (!gpio_charger->current_limit_map_size)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < gpio_charger->current_limit_map_size; i++) {\n\t\tif (gpio_charger->current_limit_map[i].limit_ua <= val)\n\t\t\tbreak;\n\t}\n\tmapping = gpio_charger->current_limit_map[i];\n\n\tfor (i = 0; i < ndescs; i++) {\n\t\tbool val = (mapping.gpiodata >> i) & 1;\n\t\tgpiod_set_value_cansleep(gpios[ndescs-i-1], val);\n\t}\n\n\tgpio_charger->charge_current_limit = mapping.limit_ua;\n\n\tdev_dbg(gpio_charger->dev, \"set charge current limit to %d (requested: %d)\\n\",\n\t\tgpio_charger->charge_current_limit, val);\n\n\treturn 0;\n}\n\nstatic int gpio_charger_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct gpio_charger *gpio_charger = psy_to_gpio_charger(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = gpiod_get_value_cansleep(gpio_charger->gpiod);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (gpiod_get_value_cansleep(gpio_charger->charge_status))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = gpio_charger->charge_current_limit;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_charger_set_property(struct power_supply *psy,\n\tenum power_supply_property psp, const union power_supply_propval *val)\n{\n\tstruct gpio_charger *gpio_charger = psy_to_gpio_charger(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\treturn set_charge_current_limit(gpio_charger, val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_charger_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t      enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_type gpio_charger_get_type(struct device *dev)\n{\n\tconst char *chargetype;\n\n\tif (!device_property_read_string(dev, \"charger-type\", &chargetype)) {\n\t\tif (!strcmp(\"unknown\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_UNKNOWN;\n\t\tif (!strcmp(\"battery\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_BATTERY;\n\t\tif (!strcmp(\"ups\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_UPS;\n\t\tif (!strcmp(\"mains\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_MAINS;\n\t\tif (!strcmp(\"usb-sdp\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_USB;\n\t\tif (!strcmp(\"usb-dcp\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_USB;\n\t\tif (!strcmp(\"usb-cdp\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_USB;\n\t\tif (!strcmp(\"usb-aca\", chargetype))\n\t\t\treturn POWER_SUPPLY_TYPE_USB;\n\t}\n\tdev_warn(dev, \"unknown charger type %s\\n\", chargetype);\n\n\treturn POWER_SUPPLY_TYPE_UNKNOWN;\n}\n\nstatic int gpio_charger_get_irq(struct device *dev, void *dev_id,\n\t\t\t\tstruct gpio_desc *gpio)\n{\n\tint ret, irq = gpiod_to_irq(gpio);\n\n\tif (irq > 0) {\n\t\tret = devm_request_any_context_irq(dev, irq, gpio_charger_irq,\n\t\t\t\t\t\t   IRQF_TRIGGER_RISING |\n\t\t\t\t\t\t   IRQF_TRIGGER_FALLING,\n\t\t\t\t\t\t   dev_name(dev),\n\t\t\t\t\t\t   dev_id);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(dev, \"Failed to request irq: %d\\n\", ret);\n\t\t\tirq = 0;\n\t\t}\n\t}\n\n\treturn irq;\n}\n\nstatic int init_charge_current_limit(struct device *dev,\n\t\t\t\t    struct gpio_charger *gpio_charger)\n{\n\tint i, len;\n\tu32 cur_limit = U32_MAX;\n\n\tgpio_charger->current_limit_gpios = devm_gpiod_get_array_optional(dev,\n\t\t\"charge-current-limit\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio_charger->current_limit_gpios)) {\n\t\tdev_err(dev, \"error getting current-limit GPIOs\\n\");\n\t\treturn PTR_ERR(gpio_charger->current_limit_gpios);\n\t}\n\n\tif (!gpio_charger->current_limit_gpios)\n\t\treturn 0;\n\n\tlen = device_property_read_u32_array(dev, \"charge-current-limit-mapping\",\n\t\tNULL, 0);\n\tif (len < 0)\n\t\treturn len;\n\n\tif (len == 0 || len % 2) {\n\t\tdev_err(dev, \"invalid charge-current-limit-mapping length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_charger->current_limit_map = devm_kmalloc_array(dev,\n\t\tlen / 2, sizeof(*gpio_charger->current_limit_map), GFP_KERNEL);\n\tif (!gpio_charger->current_limit_map)\n\t\treturn -ENOMEM;\n\n\tgpio_charger->current_limit_map_size = len / 2;\n\n\tlen = device_property_read_u32_array(dev, \"charge-current-limit-mapping\",\n\t\t(u32*) gpio_charger->current_limit_map, len);\n\tif (len < 0)\n\t\treturn len;\n\n\tfor (i=0; i < gpio_charger->current_limit_map_size; i++) {\n\t\tif (gpio_charger->current_limit_map[i].limit_ua > cur_limit) {\n\t\t\tdev_err(dev, \"charge-current-limit-mapping not sorted by current in descending order\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcur_limit = gpio_charger->current_limit_map[i].limit_ua;\n\t}\n\n\t \n\tlen = gpio_charger->current_limit_map_size - 1;\n\tset_charge_current_limit(gpio_charger,\n\t\tgpio_charger->current_limit_map[len].limit_ua);\n\n\treturn 0;\n}\n\n \nstatic enum power_supply_property gpio_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n};\n\nstatic int gpio_charger_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct gpio_charger_platform_data *pdata = dev->platform_data;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct gpio_charger *gpio_charger;\n\tstruct power_supply_desc *charger_desc;\n\tstruct gpio_desc *charge_status;\n\tint charge_status_irq;\n\tint ret;\n\tint num_props = 0;\n\n\tif (!pdata && !dev->of_node) {\n\t\tdev_err(dev, \"No platform data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tgpio_charger = devm_kzalloc(dev, sizeof(*gpio_charger), GFP_KERNEL);\n\tif (!gpio_charger)\n\t\treturn -ENOMEM;\n\tgpio_charger->dev = dev;\n\n\t \n\tgpio_charger->gpiod = devm_gpiod_get_optional(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(gpio_charger->gpiod)) {\n\t\t \n\t\treturn dev_err_probe(dev, PTR_ERR(gpio_charger->gpiod),\n\t\t\t\t     \"error getting GPIO descriptor\\n\");\n\t}\n\n\tif (gpio_charger->gpiod) {\n\t\tgpio_charger_properties[num_props] = POWER_SUPPLY_PROP_ONLINE;\n\t\tnum_props++;\n\t}\n\n\tcharge_status = devm_gpiod_get_optional(dev, \"charge-status\", GPIOD_IN);\n\tif (IS_ERR(charge_status))\n\t\treturn PTR_ERR(charge_status);\n\tif (charge_status) {\n\t\tgpio_charger->charge_status = charge_status;\n\t\tgpio_charger_properties[num_props] = POWER_SUPPLY_PROP_STATUS;\n\t\tnum_props++;\n\t}\n\n\tret = init_charge_current_limit(dev, gpio_charger);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (gpio_charger->current_limit_map) {\n\t\tgpio_charger_properties[num_props] =\n\t\t\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;\n\t\tnum_props++;\n\t}\n\n\tcharger_desc = &gpio_charger->charger_desc;\n\tcharger_desc->properties = gpio_charger_properties;\n\tcharger_desc->num_properties = num_props;\n\tcharger_desc->get_property = gpio_charger_get_property;\n\tcharger_desc->set_property = gpio_charger_set_property;\n\tcharger_desc->property_is_writeable =\n\t\t\t\t\tgpio_charger_property_is_writeable;\n\n\tpsy_cfg.of_node = dev->of_node;\n\tpsy_cfg.drv_data = gpio_charger;\n\n\tif (pdata) {\n\t\tcharger_desc->name = pdata->name;\n\t\tcharger_desc->type = pdata->type;\n\t\tpsy_cfg.supplied_to = pdata->supplied_to;\n\t\tpsy_cfg.num_supplicants = pdata->num_supplicants;\n\t} else {\n\t\tcharger_desc->name = dev->of_node->name;\n\t\tcharger_desc->type = gpio_charger_get_type(dev);\n\t}\n\n\tif (!charger_desc->name)\n\t\tcharger_desc->name = pdev->name;\n\n\tgpio_charger->charger = devm_power_supply_register(dev, charger_desc,\n\t\t\t\t\t\t\t   &psy_cfg);\n\tif (IS_ERR(gpio_charger->charger)) {\n\t\tret = PTR_ERR(gpio_charger->charger);\n\t\tdev_err(dev, \"Failed to register power supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpio_charger->irq = gpio_charger_get_irq(dev, gpio_charger->charger,\n\t\t\t\t\t\t gpio_charger->gpiod);\n\n\tcharge_status_irq = gpio_charger_get_irq(dev, gpio_charger->charger,\n\t\t\t\t\t\t gpio_charger->charge_status);\n\tgpio_charger->charge_status_irq = charge_status_irq;\n\n\tplatform_set_drvdata(pdev, gpio_charger);\n\n\tdevice_init_wakeup(dev, 1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpio_charger_suspend(struct device *dev)\n{\n\tstruct gpio_charger *gpio_charger = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tgpio_charger->wakeup_enabled =\n\t\t\t!enable_irq_wake(gpio_charger->irq);\n\n\treturn 0;\n}\n\nstatic int gpio_charger_resume(struct device *dev)\n{\n\tstruct gpio_charger *gpio_charger = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev) && gpio_charger->wakeup_enabled)\n\t\tdisable_irq_wake(gpio_charger->irq);\n\tpower_supply_changed(gpio_charger->charger);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(gpio_charger_pm_ops,\n\t\tgpio_charger_suspend, gpio_charger_resume);\n\nstatic const struct of_device_id gpio_charger_match[] = {\n\t{ .compatible = \"gpio-charger\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gpio_charger_match);\n\nstatic struct platform_driver gpio_charger_driver = {\n\t.probe = gpio_charger_probe,\n\t.driver = {\n\t\t.name = \"gpio-charger\",\n\t\t.pm = &gpio_charger_pm_ops,\n\t\t.of_match_table = gpio_charger_match,\n\t},\n};\n\nmodule_platform_driver(gpio_charger_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Driver for chargers only communicating via GPIO(s)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-charger\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}