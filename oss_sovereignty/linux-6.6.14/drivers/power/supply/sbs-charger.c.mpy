{
  "module_name": "sbs-charger.c",
  "hash_id": "d6fc9e7a7549f13ef16daa9d864a37c7e1e8803d8de78ca00b1b08e94a401cbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/sbs-charger.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/power_supply.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/bitops.h>\n#include <linux/devm-helpers.h>\n\n#define SBS_CHARGER_REG_SPEC_INFO\t\t0x11\n#define SBS_CHARGER_REG_STATUS\t\t\t0x13\n#define SBS_CHARGER_REG_ALARM_WARNING\t\t0x16\n\n#define SBS_CHARGER_STATUS_CHARGE_INHIBITED\tBIT(0)\n#define SBS_CHARGER_STATUS_RES_COLD\t\tBIT(9)\n#define SBS_CHARGER_STATUS_RES_HOT\t\tBIT(10)\n#define SBS_CHARGER_STATUS_BATTERY_PRESENT\tBIT(14)\n#define SBS_CHARGER_STATUS_AC_PRESENT\t\tBIT(15)\n\n#define SBS_CHARGER_POLL_TIME\t\t\t500\n\nstruct sbs_info {\n\tstruct i2c_client\t\t*client;\n\tstruct power_supply\t\t*power_supply;\n\tstruct regmap\t\t\t*regmap;\n\tstruct delayed_work\t\twork;\n\tunsigned int\t\t\tlast_state;\n};\n\nstatic int sbs_get_property(struct power_supply *psy,\n\t\t\t    enum power_supply_property psp,\n\t\t\t    union power_supply_propval *val)\n{\n\tstruct sbs_info *chip = power_supply_get_drvdata(psy);\n\tunsigned int reg;\n\n\treg = chip->last_state;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = !!(reg & SBS_CHARGER_STATUS_BATTERY_PRESENT);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = !!(reg & SBS_CHARGER_STATUS_AC_PRESENT);\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\t\tif (!(reg & SBS_CHARGER_STATUS_BATTERY_PRESENT))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\telse if (reg & SBS_CHARGER_STATUS_AC_PRESENT &&\n\t\t\t !(reg & SBS_CHARGER_STATUS_CHARGE_INHIBITED))\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tif (reg & SBS_CHARGER_STATUS_RES_COLD)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_COLD;\n\t\tif (reg & SBS_CHARGER_STATUS_RES_HOT)\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_HEALTH_GOOD;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbs_check_state(struct sbs_info *chip)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, SBS_CHARGER_REG_STATUS, &reg);\n\tif (!ret && reg != chip->last_state) {\n\t\tchip->last_state = reg;\n\t\tpower_supply_changed(chip->power_supply);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void sbs_delayed_work(struct work_struct *work)\n{\n\tstruct sbs_info *chip = container_of(work, struct sbs_info, work.work);\n\n\tsbs_check_state(chip);\n\n\tschedule_delayed_work(&chip->work,\n\t\t\t      msecs_to_jiffies(SBS_CHARGER_POLL_TIME));\n}\n\nstatic irqreturn_t sbs_irq_thread(int irq, void *data)\n{\n\tstruct sbs_info *chip = data;\n\tint ret;\n\n\tret = sbs_check_state(chip);\n\n\treturn ret ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic enum power_supply_property sbs_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n};\n\nstatic bool sbs_readable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg >= SBS_CHARGER_REG_SPEC_INFO;\n}\n\nstatic bool sbs_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SBS_CHARGER_REG_STATUS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config sbs_regmap = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 16,\n\t.max_register\t= SBS_CHARGER_REG_ALARM_WARNING,\n\t.readable_reg\t= sbs_readable_reg,\n\t.volatile_reg\t= sbs_volatile_reg,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,  \n};\n\nstatic const struct power_supply_desc sbs_desc = {\n\t.name = \"sbs-charger\",\n\t.type = POWER_SUPPLY_TYPE_MAINS,\n\t.properties = sbs_properties,\n\t.num_properties = ARRAY_SIZE(sbs_properties),\n\t.get_property = sbs_get_property,\n};\n\nstatic int sbs_probe(struct i2c_client *client)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct sbs_info *chip;\n\tint ret, val;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(struct sbs_info), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tpsy_cfg.of_node = client->dev.of_node;\n\tpsy_cfg.drv_data = chip;\n\n\ti2c_set_clientdata(client, chip);\n\n\tchip->regmap = devm_regmap_init_i2c(client, &sbs_regmap);\n\tif (IS_ERR(chip->regmap))\n\t\treturn PTR_ERR(chip->regmap);\n\n\t \n\tret = regmap_read(chip->regmap, SBS_CHARGER_REG_STATUS, &val);\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret, \"Failed to get device status\\n\");\n\tchip->last_state = val;\n\n\tchip->power_supply = devm_power_supply_register(&client->dev, &sbs_desc, &psy_cfg);\n\tif (IS_ERR(chip->power_supply))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(chip->power_supply),\n\t\t\t\t     \"Failed to register power supply\\n\");\n\n\t \n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, sbs_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&client->dev), chip);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&client->dev, ret, \"Failed to request irq\\n\");\n\t} else {\n\t\tret = devm_delayed_work_autocancel(&client->dev, &chip->work,\n\t\t\t\t\t\t   sbs_delayed_work);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t\t     \"Failed to init work for polling\\n\");\n\n\t\tschedule_delayed_work(&chip->work,\n\t\t\t\t      msecs_to_jiffies(SBS_CHARGER_POLL_TIME));\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"%s: smart charger device registered\\n\", client->name);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sbs_dt_ids[] = {\n\t{ .compatible = \"sbs,sbs-charger\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sbs_dt_ids);\n#endif\n\nstatic const struct i2c_device_id sbs_id[] = {\n\t{ \"sbs-charger\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sbs_id);\n\nstatic struct i2c_driver sbs_driver = {\n\t.probe\t\t= sbs_probe,\n\t.id_table\t= sbs_id,\n\t.driver = {\n\t\t.name\t= \"sbs-charger\",\n\t\t.of_match_table = of_match_ptr(sbs_dt_ids),\n\t},\n};\nmodule_i2c_driver(sbs_driver);\n\nMODULE_AUTHOR(\"Nicolas Saenz Julienne <nicolassaenzj@gmail.com>\");\nMODULE_DESCRIPTION(\"SBS smart charger driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}