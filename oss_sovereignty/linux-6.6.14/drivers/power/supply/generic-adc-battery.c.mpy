{
  "module_name": "generic-adc-battery.c",
  "hash_id": "68e7d02a4680c1ffc2aafaa8e96aceadf17f7b5e28146695c54a4ba97124fa56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/generic-adc-battery.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/gpio/consumer.h>\n#include <linux/err.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n#include <linux/of.h>\n#include <linux/devm-helpers.h>\n\n#define JITTER_DEFAULT 10  \n\nenum gab_chan_type {\n\tGAB_VOLTAGE = 0,\n\tGAB_CURRENT,\n\tGAB_POWER,\n\tGAB_TEMP,\n\tGAB_MAX_CHAN_TYPE\n};\n\n \nstatic const char *const gab_chan_name[] = {\n\t[GAB_VOLTAGE]\t= \"voltage\",\n\t[GAB_CURRENT]\t= \"current\",\n\t[GAB_POWER]\t= \"power\",\n\t[GAB_TEMP]\t= \"temperature\",\n};\n\nstruct gab {\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tstruct iio_channel *channel[GAB_MAX_CHAN_TYPE];\n\tstruct delayed_work bat_work;\n\tint status;\n\tstruct gpio_desc *charge_finished;\n};\n\nstatic struct gab *to_generic_bat(struct power_supply *psy)\n{\n\treturn power_supply_get_drvdata(psy);\n}\n\nstatic void gab_ext_power_changed(struct power_supply *psy)\n{\n\tstruct gab *adc_bat = to_generic_bat(psy);\n\n\tschedule_delayed_work(&adc_bat->bat_work, msecs_to_jiffies(0));\n}\n\nstatic const enum power_supply_property gab_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n};\n\n \nstatic const enum power_supply_property gab_dyn_props[] = {\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic bool gab_charge_finished(struct gab *adc_bat)\n{\n\tif (!adc_bat->charge_finished)\n\t\treturn false;\n\treturn gpiod_get_value(adc_bat->charge_finished);\n}\n\nstatic int gab_read_channel(struct gab *adc_bat, enum gab_chan_type channel,\n\t\tint *result)\n{\n\tint ret;\n\n\tret = iio_read_channel_processed(adc_bat->channel[channel], result);\n\tif (ret < 0)\n\t\tdev_err(&adc_bat->psy->dev, \"read channel error: %d\\n\", ret);\n\telse\n\t\t*result *= 1000;\n\n\treturn ret;\n}\n\nstatic int gab_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct gab *adc_bat = to_generic_bat(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = adc_bat->status;\n\t\treturn 0;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\treturn gab_read_channel(adc_bat, GAB_VOLTAGE, &val->intval);\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn gab_read_channel(adc_bat, GAB_CURRENT, &val->intval);\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\treturn gab_read_channel(adc_bat, GAB_POWER, &val->intval);\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\treturn gab_read_channel(adc_bat, GAB_TEMP, &val->intval);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void gab_work(struct work_struct *work)\n{\n\tstruct gab *adc_bat;\n\tstruct delayed_work *delayed_work;\n\tint status;\n\n\tdelayed_work = to_delayed_work(work);\n\tadc_bat = container_of(delayed_work, struct gab, bat_work);\n\tstatus = adc_bat->status;\n\n\tif (!power_supply_am_i_supplied(adc_bat->psy))\n\t\tadc_bat->status =  POWER_SUPPLY_STATUS_DISCHARGING;\n\telse if (gab_charge_finished(adc_bat))\n\t\tadc_bat->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\telse\n\t\tadc_bat->status = POWER_SUPPLY_STATUS_CHARGING;\n\n\tif (status != adc_bat->status)\n\t\tpower_supply_changed(adc_bat->psy);\n}\n\nstatic irqreturn_t gab_charged(int irq, void *dev_id)\n{\n\tstruct gab *adc_bat = dev_id;\n\n\tschedule_delayed_work(&adc_bat->bat_work,\n\t\t\t      msecs_to_jiffies(JITTER_DEFAULT));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gab_probe(struct platform_device *pdev)\n{\n\tstruct gab *adc_bat;\n\tstruct power_supply_desc *psy_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tenum power_supply_property *properties;\n\tint ret = 0;\n\tint chan;\n\tint index = ARRAY_SIZE(gab_props);\n\tbool any = false;\n\n\tadc_bat = devm_kzalloc(&pdev->dev, sizeof(*adc_bat), GFP_KERNEL);\n\tif (!adc_bat)\n\t\treturn -ENOMEM;\n\n\tpsy_cfg.of_node = pdev->dev.of_node;\n\tpsy_cfg.drv_data = adc_bat;\n\tpsy_desc = &adc_bat->psy_desc;\n\tpsy_desc->name = dev_name(&pdev->dev);\n\n\t \n\tadc_bat->status = POWER_SUPPLY_STATUS_DISCHARGING;\n\tpsy_desc->type = POWER_SUPPLY_TYPE_BATTERY;\n\tpsy_desc->get_property = gab_get_property;\n\tpsy_desc->external_power_changed = gab_ext_power_changed;\n\n\t \n\tproperties = devm_kcalloc(&pdev->dev,\n\t\t\t\t  ARRAY_SIZE(gab_props) +\n\t\t\t\t  ARRAY_SIZE(gab_chan_name),\n\t\t\t\t  sizeof(*properties),\n\t\t\t\t  GFP_KERNEL);\n\tif (!properties)\n\t\treturn -ENOMEM;\n\n\tmemcpy(properties, gab_props, sizeof(gab_props));\n\n\t \n\tfor (chan = 0; chan < ARRAY_SIZE(gab_chan_name); chan++) {\n\t\tadc_bat->channel[chan] = devm_iio_channel_get(&pdev->dev, gab_chan_name[chan]);\n\t\tif (IS_ERR(adc_bat->channel[chan])) {\n\t\t\tret = PTR_ERR(adc_bat->channel[chan]);\n\t\t\tif (ret != -ENODEV)\n\t\t\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to get ADC channel %s\\n\", gab_chan_name[chan]);\n\t\t\tadc_bat->channel[chan] = NULL;\n\t\t} else if (adc_bat->channel[chan]) {\n\t\t\t \n\t\t\tint index2;\n\n\t\t\tfor (index2 = 0; index2 < index; index2++) {\n\t\t\t\tif (properties[index2] == gab_dyn_props[chan])\n\t\t\t\t\tbreak;\t \n\t\t\t}\n\t\t\tif (index2 == index)\t \n\t\t\t\tproperties[index++] = gab_dyn_props[chan];\n\t\t\tany = true;\n\t\t}\n\t}\n\n\t \n\tif (!any)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV, \"Failed to get any ADC channel\\n\");\n\n\t \n\tpsy_desc->properties = properties;\n\tpsy_desc->num_properties = index;\n\n\tadc_bat->psy = devm_power_supply_register(&pdev->dev, psy_desc, &psy_cfg);\n\tif (IS_ERR(adc_bat->psy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(adc_bat->psy), \"Failed to register power-supply device\\n\");\n\n\tret = devm_delayed_work_autocancel(&pdev->dev, &adc_bat->bat_work, gab_work);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register delayed work\\n\");\n\n\tadc_bat->charge_finished = devm_gpiod_get_optional(&pdev->dev, \"charged\", GPIOD_IN);\n\tif (adc_bat->charge_finished) {\n\t\tint irq;\n\n\t\tirq = gpiod_to_irq(adc_bat->charge_finished);\n\t\tret = devm_request_any_context_irq(&pdev->dev, irq, gab_charged,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\t\"battery charged\", adc_bat);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register irq\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, adc_bat);\n\n\t \n\tschedule_delayed_work(&adc_bat->bat_work,\n\t\t\tmsecs_to_jiffies(0));\n\treturn 0;\n}\n\nstatic int __maybe_unused gab_suspend(struct device *dev)\n{\n\tstruct gab *adc_bat = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&adc_bat->bat_work);\n\tadc_bat->status = POWER_SUPPLY_STATUS_UNKNOWN;\n\treturn 0;\n}\n\nstatic int __maybe_unused gab_resume(struct device *dev)\n{\n\tstruct gab *adc_bat = dev_get_drvdata(dev);\n\n\t \n\tschedule_delayed_work(&adc_bat->bat_work,\n\t\t\t      msecs_to_jiffies(JITTER_DEFAULT));\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(gab_pm_ops, gab_suspend, gab_resume);\n\nstatic const struct of_device_id gab_match[] = {\n\t{ .compatible = \"adc-battery\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gab_match);\n\nstatic struct platform_driver gab_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"generic-adc-battery\",\n\t\t.pm\t= &gab_pm_ops,\n\t\t.of_match_table = gab_match,\n\t},\n\t.probe\t\t= gab_probe,\n};\nmodule_platform_driver(gab_driver);\n\nMODULE_AUTHOR(\"anish kumar <anish198519851985@gmail.com>\");\nMODULE_DESCRIPTION(\"generic battery driver using IIO\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}