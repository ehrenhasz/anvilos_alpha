{
  "module_name": "max1721x_battery.c",
  "hash_id": "3d0c8011e626af1f14e634f38b63bf1658474cd3b567f71054ea6000d8ae308f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/max1721x_battery.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/w1.h>\n#include <linux/regmap.h>\n#include <linux/power_supply.h>\n\n#define W1_MAX1721X_FAMILY_ID\t\t0x26\n#define DEF_DEV_NAME_MAX17211\t\t\"MAX17211\"\n#define DEF_DEV_NAME_MAX17215\t\t\"MAX17215\"\n#define DEF_DEV_NAME_UNKNOWN\t\t\"UNKNOWN\"\n#define DEF_MFG_NAME\t\t\t\"MAXIM\"\n\n#define PSY_MAX_NAME_LEN\t32\n\n \n#define MAX1721X_MAX_REG_NR\t0x1EF\n\n \n#define MAX1721X_REG_NRSENSE\t0x1CF\t \n \n#define MAX1721X_REG_MFG_STR\t0x1CC\n#define MAX1721X_REG_MFG_NUMB\t3\n#define MAX1721X_REG_DEV_STR\t0x1DB\n#define MAX1721X_REG_DEV_NUMB\t5\n \n#define MAX1721X_REG_SER_HEX\t0x1D8\n\n \n#define MAX172XX_REG_STATUS\t0x000\t \n#define MAX172XX_BAT_PRESENT\t(1<<4)\t \n#define MAX172XX_REG_DEVNAME\t0x021\t \n#define MAX172XX_DEV_MASK\t0x000F\t \n#define MAX172X1_DEV\t\t0x0001\n#define MAX172X5_DEV\t\t0x0005\n#define MAX172XX_REG_TEMP\t0x008\t \n#define MAX172XX_REG_BATT\t0x0DA\t \n#define MAX172XX_REG_CURRENT\t0x00A\t \n#define MAX172XX_REG_AVGCURRENT\t0x00B\t \n#define MAX172XX_REG_REPSOC\t0x006\t \n#define MAX172XX_REG_DESIGNCAP\t0x018\t \n#define MAX172XX_REG_REPCAP\t0x005\t \n#define MAX172XX_REG_TTE\t0x011\t \n#define MAX172XX_REG_TTF\t0x020\t \n\nstruct max17211_device_info {\n\tchar name[PSY_MAX_NAME_LEN];\n\tstruct power_supply *bat;\n\tstruct power_supply_desc bat_desc;\n\tstruct device *w1_dev;\n\tstruct regmap *regmap;\n\t \n\tunsigned int rsense;  \n\tchar DeviceName[2 * MAX1721X_REG_DEV_NUMB + 1];\n\tchar ManufacturerName[2 * MAX1721X_REG_MFG_NUMB + 1];\n\tchar SerialNumber[13];  \n};\n\n \n\nstatic inline int max172xx_time_to_ps(unsigned int reg)\n{\n\treturn reg * 5625 / 1000;\t \n}\n\nstatic inline int max172xx_percent_to_ps(unsigned int reg)\n{\n\treturn reg / 256;\t \n}\n\nstatic inline int max172xx_voltage_to_ps(unsigned int reg)\n{\n\treturn reg * 1250;\t \n}\n\nstatic inline int max172xx_capacity_to_ps(unsigned int reg)\n{\n\treturn reg * 500;\t \n}\n\n \n\nstatic inline int max172xx_temperature_to_ps(unsigned int reg)\n{\n\tint val = (int16_t)(reg);\n\n\treturn val * 10 / 256;  \n}\n\n \nstatic inline int max172xx_current_to_voltage(unsigned int reg)\n{\n\tint val = (int16_t)(reg);\n\n\treturn val * 156252;\n}\n\n\nstatic inline struct max17211_device_info *\nto_device_info(struct power_supply *psy)\n{\n\treturn power_supply_get_drvdata(psy);\n}\n\nstatic int max1721x_battery_get_property(struct power_supply *psy,\n\tenum power_supply_property psp,\n\tunion power_supply_propval *val)\n{\n\tstruct max17211_device_info *info = to_device_info(psy);\n\tunsigned int reg = 0;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\t \n\t\tval->intval =\n\t\t\tregmap_read(info->regmap, MAX172XX_REG_STATUS,\n\t\t\t&reg) ? 0 : !(reg & MAX172XX_BAT_PRESENT);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_REPSOC, &reg);\n\t\tval->intval = max172xx_percent_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_BATT, &reg);\n\t\tval->intval = max172xx_voltage_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_DESIGNCAP, &reg);\n\t\tval->intval = max172xx_capacity_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_AVG:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_REPCAP, &reg);\n\t\tval->intval = max172xx_capacity_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_TTE, &reg);\n\t\tval->intval = max172xx_time_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_TTF, &reg);\n\t\tval->intval = max172xx_time_to_ps(reg);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_TEMP, &reg);\n\t\tval->intval = max172xx_temperature_to_ps(reg);\n\t\tbreak;\n\t \n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_CURRENT, &reg);\n\t\tval->intval =\n\t\t\tmax172xx_current_to_voltage(reg) / (int)info->rsense;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tret = regmap_read(info->regmap, MAX172XX_REG_AVGCURRENT, &reg);\n\t\tval->intval =\n\t\t\tmax172xx_current_to_voltage(reg) / (int)info->rsense;\n\t\tbreak;\n\t \n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tret = regmap_read(info->regmap, MAX1721X_REG_DEV_STR, &reg);\n\t\tval->strval = info->DeviceName;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tret = regmap_read(info->regmap, MAX1721X_REG_MFG_STR, &reg);\n\t\tval->strval = info->ManufacturerName;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tret = regmap_read(info->regmap, MAX1721X_REG_SER_HEX, &reg);\n\t\tval->strval = info->SerialNumber;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property max1721x_battery_props[] = {\n\t \n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_AVG,\n\tPOWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,\n\tPOWER_SUPPLY_PROP_TIME_TO_FULL_AVG,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\t \n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic int get_string(struct max17211_device_info *info,\n\t\t\tuint16_t reg, uint8_t nr, char *str)\n{\n\tunsigned int val;\n\n\tif (!str || !(reg == MAX1721X_REG_MFG_STR ||\n\t\t\treg == MAX1721X_REG_DEV_STR))\n\t\treturn -EFAULT;\n\n\twhile (nr--) {\n\t\tif (regmap_read(info->regmap, reg++, &val))\n\t\t\treturn -EFAULT;\n\t\t*str++ = val>>8 & 0x00FF;\n\t\t*str++ = val & 0x00FF;\n\t}\n\treturn 0;\n}\n\n \nstatic int get_sn_string(struct max17211_device_info *info, char *str)\n{\n\tunsigned int val[3];\n\n\tif (!str)\n\t\treturn -EFAULT;\n\n\tif (regmap_read(info->regmap, MAX1721X_REG_SER_HEX, &val[0]))\n\t\treturn -EFAULT;\n\tif (regmap_read(info->regmap, MAX1721X_REG_SER_HEX + 1, &val[1]))\n\t\treturn -EFAULT;\n\tif (regmap_read(info->regmap, MAX1721X_REG_SER_HEX + 2, &val[2]))\n\t\treturn -EFAULT;\n\n\tsnprintf(str, 13, \"%04X%04X%04X\", val[0], val[1], val[2]);\n\treturn 0;\n}\n\n \nstatic const struct regmap_range max1721x_allow_range[] = {\n\tregmap_reg_range(0, 0xDF),\t \n\tregmap_reg_range(0x180, 0x1DF),\t \n\tregmap_reg_range(0x1E0, 0x1EF),\t \n};\n\nstatic const struct regmap_range max1721x_deny_range[] = {\n\t \n\tregmap_reg_range(0x24, 0x26),\n\tregmap_reg_range(0x30, 0x31),\n\tregmap_reg_range(0x33, 0x34),\n\tregmap_reg_range(0x37, 0x37),\n\tregmap_reg_range(0x3B, 0x3C),\n\tregmap_reg_range(0x40, 0x41),\n\tregmap_reg_range(0x43, 0x44),\n\tregmap_reg_range(0x47, 0x49),\n\tregmap_reg_range(0x4B, 0x4C),\n\tregmap_reg_range(0x4E, 0xAF),\n\tregmap_reg_range(0xB1, 0xB3),\n\tregmap_reg_range(0xB5, 0xB7),\n\tregmap_reg_range(0xBF, 0xD0),\n\tregmap_reg_range(0xDB, 0xDB),\n\t \n\tregmap_reg_range(0xE0, 0x17F),\n};\n\nstatic const struct regmap_access_table max1721x_regs = {\n\t.yes_ranges\t= max1721x_allow_range,\n\t.n_yes_ranges\t= ARRAY_SIZE(max1721x_allow_range),\n\t.no_ranges\t= max1721x_deny_range,\n\t.n_no_ranges\t= ARRAY_SIZE(max1721x_deny_range),\n};\n\n \nstatic const struct regmap_range max1721x_volatile_allow[] = {\n\tregmap_reg_range(0, 0xDF),\n};\n\nstatic const struct regmap_access_table max1721x_volatile_regs = {\n\t.yes_ranges\t= max1721x_volatile_allow,\n\t.n_yes_ranges\t= ARRAY_SIZE(max1721x_volatile_allow),\n};\n\n \nstatic const struct regmap_config max1721x_regmap_w1_config = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.rd_table = &max1721x_regs,\n\t.volatile_table = &max1721x_volatile_regs,\n\t.max_register = MAX1721X_MAX_REG_NR,\n};\n\nstatic int devm_w1_max1721x_add_device(struct w1_slave *sl)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct max17211_device_info *info;\n\n\tinfo = devm_kzalloc(&sl->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tsl->family_data = (void *)info;\n\tinfo->w1_dev = &sl->dev;\n\n\t \n\tsnprintf(info->name, sizeof(info->name),\n\t\t\"max1721x-%012X\", (unsigned int)sl->reg_num.id);\n\tinfo->bat_desc.name = info->name;\n\n\t \n\tinfo->bat_desc.no_thermal = true;\n\tinfo->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tinfo->bat_desc.properties = max1721x_battery_props;\n\tinfo->bat_desc.num_properties = ARRAY_SIZE(max1721x_battery_props);\n\tinfo->bat_desc.get_property = max1721x_battery_get_property;\n\tpsy_cfg.drv_data = info;\n\n\t \n\tinfo->regmap = devm_regmap_init_w1(info->w1_dev,\n\t\t\t\t\t&max1721x_regmap_w1_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tint err = PTR_ERR(info->regmap);\n\n\t\tdev_err(info->w1_dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tinfo->rsense = 0;\n\tif (regmap_read(info->regmap, MAX1721X_REG_NRSENSE, &info->rsense)) {\n\t\tdev_err(info->w1_dev, \"Can't read RSense. Hardware error.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!info->rsense) {\n\t\tdev_warn(info->w1_dev, \"RSense not calibrated, set 10 mOhms!\\n\");\n\t\tinfo->rsense = 1000;  \n\t}\n\tdev_info(info->w1_dev, \"RSense: %d mOhms.\\n\", info->rsense / 100);\n\n\tif (get_string(info, MAX1721X_REG_MFG_STR,\n\t\t\tMAX1721X_REG_MFG_NUMB, info->ManufacturerName)) {\n\t\tdev_err(info->w1_dev, \"Can't read manufacturer. Hardware error.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!info->ManufacturerName[0])\n\t\tstrscpy(info->ManufacturerName, DEF_MFG_NAME,\n\t\t\t2 * MAX1721X_REG_MFG_NUMB);\n\n\tif (get_string(info, MAX1721X_REG_DEV_STR,\n\t\t\tMAX1721X_REG_DEV_NUMB, info->DeviceName)) {\n\t\tdev_err(info->w1_dev, \"Can't read device. Hardware error.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!info->DeviceName[0]) {\n\t\tunsigned int dev_name;\n\n\t\tif (regmap_read(info->regmap,\n\t\t\t\tMAX172XX_REG_DEVNAME, &dev_name)) {\n\t\t\tdev_err(info->w1_dev, \"Can't read device name reg.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tswitch (dev_name & MAX172XX_DEV_MASK) {\n\t\tcase MAX172X1_DEV:\n\t\t\tstrscpy(info->DeviceName, DEF_DEV_NAME_MAX17211,\n\t\t\t\t2 * MAX1721X_REG_DEV_NUMB);\n\t\t\tbreak;\n\t\tcase MAX172X5_DEV:\n\t\t\tstrscpy(info->DeviceName, DEF_DEV_NAME_MAX17215,\n\t\t\t\t2 * MAX1721X_REG_DEV_NUMB);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrscpy(info->DeviceName, DEF_DEV_NAME_UNKNOWN,\n\t\t\t\t2 * MAX1721X_REG_DEV_NUMB);\n\t\t}\n\t}\n\n\tif (get_sn_string(info, info->SerialNumber)) {\n\t\tdev_err(info->w1_dev, \"Can't read serial. Hardware error.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->bat = devm_power_supply_register(&sl->dev, &info->bat_desc,\n\t\t\t\t\t\t&psy_cfg);\n\tif (IS_ERR(info->bat)) {\n\t\tdev_err(info->w1_dev, \"failed to register battery\\n\");\n\t\treturn PTR_ERR(info->bat);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct w1_family_ops w1_max1721x_fops = {\n\t.add_slave = devm_w1_max1721x_add_device,\n};\n\nstatic struct w1_family w1_max1721x_family = {\n\t.fid = W1_MAX1721X_FAMILY_ID,\n\t.fops = &w1_max1721x_fops,\n};\n\nmodule_w1_family(w1_max1721x_family);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alex A. Mihaylov <minimumlaw@rambler.ru>\");\nMODULE_DESCRIPTION(\"Maxim MAX17211/MAX17215 Fuel Gauge IC driver\");\nMODULE_ALIAS(\"w1-family-\" __stringify(W1_MAX1721X_FAMILY_ID));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}