{
  "module_name": "rt5033_battery.c",
  "hash_id": "3acb1f3b9ac8414eb2fd353a85ae5dbdba25f3374276584164344c706701cd3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/rt5033_battery.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/mfd/rt5033-private.h>\n\nstruct rt5033_battery {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tstruct power_supply\t*psy;\n};\n\nstatic int rt5033_battery_get_status(struct i2c_client *client)\n{\n\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\tunion power_supply_propval val;\n\tint ret;\n\n\tret = power_supply_get_property_from_supplier(battery->psy,\n\t\t\t\t\t\tPOWER_SUPPLY_PROP_STATUS,\n\t\t\t\t\t\t&val);\n\tif (ret)\n\t\tval.intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\treturn val.intval;\n}\n\nstatic int rt5033_battery_get_capacity(struct i2c_client *client)\n{\n\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\tu32 msb;\n\n\tregmap_read(battery->regmap, RT5033_FUEL_REG_SOC_H, &msb);\n\n\treturn msb;\n}\n\nstatic int rt5033_battery_get_present(struct i2c_client *client)\n{\n\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\tu32 val;\n\n\tregmap_read(battery->regmap, RT5033_FUEL_REG_CONFIG_L, &val);\n\n\treturn (val & RT5033_FUEL_BAT_PRESENT) ? true : false;\n}\n\nstatic int rt5033_battery_get_watt_prop(struct i2c_client *client,\n\t\tenum power_supply_property psp)\n{\n\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\tunsigned int regh, regl;\n\tint ret;\n\tu32 msb, lsb;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tregh = RT5033_FUEL_REG_VBAT_H;\n\t\tregl = RT5033_FUEL_REG_VBAT_L;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tregh = RT5033_FUEL_REG_AVG_VOLT_H;\n\t\tregl = RT5033_FUEL_REG_AVG_VOLT_L;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tregh = RT5033_FUEL_REG_OCV_H;\n\t\tregl = RT5033_FUEL_REG_OCV_L;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(battery->regmap, regh, &msb);\n\tregmap_read(battery->regmap, regl, &lsb);\n\n\tret = ((msb << 4) + (lsb >> 4)) * 1250;\n\n\treturn ret;\n}\n\nstatic int rt5033_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct rt5033_battery *battery = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_OCV:\n\t\tval->intval = rt5033_battery_get_watt_prop(battery->client,\n\t\t\t\t\t\t\t\t\tpsp);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = rt5033_battery_get_present(battery->client);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = rt5033_battery_get_capacity(battery->client);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = rt5033_battery_get_status(battery->client);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum power_supply_property rt5033_battery_props[] = {\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_OCV,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_STATUS,\n};\n\nstatic const struct regmap_config rt5033_battery_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= RT5033_FUEL_REG_END,\n};\n\nstatic const struct power_supply_desc rt5033_battery_desc = {\n\t.name\t\t= \"rt5033-battery\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.get_property\t= rt5033_battery_get_property,\n\t.properties\t= rt5033_battery_props,\n\t.num_properties\t= ARRAY_SIZE(rt5033_battery_props),\n};\n\nstatic int rt5033_battery_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct power_supply_config psy_cfg = {};\n\tstruct rt5033_battery *battery;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -EIO;\n\n\tbattery = devm_kzalloc(&client->dev, sizeof(*battery), GFP_KERNEL);\n\tif (!battery)\n\t\treturn -ENOMEM;\n\n\tbattery->client = client;\n\tbattery->regmap = devm_regmap_init_i2c(client,\n\t\t\t&rt5033_battery_regmap_config);\n\tif (IS_ERR(battery->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_set_clientdata(client, battery);\n\tpsy_cfg.of_node = client->dev.of_node;\n\tpsy_cfg.drv_data = battery;\n\n\tbattery->psy = power_supply_register(&client->dev,\n\t\t\t\t\t     &rt5033_battery_desc, &psy_cfg);\n\tif (IS_ERR(battery->psy))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(battery->psy),\n\t\t\t\t     \"Failed to register power supply\\n\");\n\n\treturn 0;\n}\n\nstatic void rt5033_battery_remove(struct i2c_client *client)\n{\n\tstruct rt5033_battery *battery = i2c_get_clientdata(client);\n\n\tpower_supply_unregister(battery->psy);\n}\n\nstatic const struct i2c_device_id rt5033_battery_id[] = {\n\t{ \"rt5033-battery\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt5033_battery_id);\n\nstatic const struct of_device_id rt5033_battery_of_match[] = {\n\t{ .compatible = \"richtek,rt5033-battery\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rt5033_battery_of_match);\n\nstatic struct i2c_driver rt5033_battery_driver = {\n\t.driver = {\n\t\t.name = \"rt5033-battery\",\n\t\t.of_match_table = rt5033_battery_of_match,\n\t},\n\t.probe = rt5033_battery_probe,\n\t.remove = rt5033_battery_remove,\n\t.id_table = rt5033_battery_id,\n};\nmodule_i2c_driver(rt5033_battery_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT5033 fuel gauge driver\");\nMODULE_AUTHOR(\"Beomho Seo <beomho.seo@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}