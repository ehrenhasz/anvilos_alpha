{
  "module_name": "wm831x_power.c",
  "hash_id": "5357a0b77c897fe9820ef13d8b5bbf48945a0fea380eea67af66d7d657e5be82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/wm831x_power.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n#include <linux/usb/phy.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/auxadc.h>\n#include <linux/mfd/wm831x/pmu.h>\n#include <linux/mfd/wm831x/pdata.h>\n\nstruct wm831x_power {\n\tstruct wm831x *wm831x;\n\tstruct power_supply *wall;\n\tstruct power_supply *usb;\n\tstruct power_supply *battery;\n\tstruct power_supply_desc wall_desc;\n\tstruct power_supply_desc usb_desc;\n\tstruct power_supply_desc battery_desc;\n\tchar wall_name[20];\n\tchar usb_name[20];\n\tchar battery_name[20];\n\tbool have_battery;\n\tstruct usb_phy *usb_phy;\n\tstruct notifier_block usb_notify;\n};\n\nstatic int wm831x_power_check_online(struct wm831x *wm831x, int supply,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & supply)\n\t\tval->intval = 1;\n\telse\n\t\tval->intval = 0;\n\n\treturn 0;\n}\n\nstatic int wm831x_power_read_voltage(struct wm831x *wm831x,\n\t\t\t\t     enum wm831x_auxadc src,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tint ret;\n\n\tret = wm831x_auxadc_read_uv(wm831x, src);\n\tif (ret >= 0)\n\t\tval->intval = ret;\n\n\treturn ret;\n}\n\n \nstatic int wm831x_wall_get_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct wm831x_power *wm831x_power = dev_get_drvdata(psy->dev.parent);\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = wm831x_power_check_online(wm831x, WM831X_PWR_WALL, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = wm831x_power_read_voltage(wm831x, WM831X_AUX_WALL, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property wm831x_wall_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\n \nstatic int wm831x_usb_get_prop(struct power_supply *psy,\n\t\t\t       enum power_supply_property psp,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct wm831x_power *wm831x_power = dev_get_drvdata(psy->dev.parent);\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = wm831x_power_check_online(wm831x, WM831X_PWR_USB, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = wm831x_power_read_voltage(wm831x, WM831X_AUX_USB, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property wm831x_usb_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n};\n\n \nstatic const unsigned int wm831x_usb_limits[] = {\n\t0,\n\t2,\n\t100,\n\t500,\n\t900,\n\t1500,\n\t1800,\n\t550,\n};\n\nstatic int wm831x_usb_limit_change(struct notifier_block *nb,\n\t\t\t\t   unsigned long limit, void *data)\n{\n\tstruct wm831x_power *wm831x_power = container_of(nb,\n\t\t\t\t\t\t\t struct wm831x_power,\n\t\t\t\t\t\t\t usb_notify);\n\tunsigned int i, best;\n\n\t \n\tbest = 0;\n\tfor (i = 0; i < ARRAY_SIZE(wm831x_usb_limits); i++) {\n\t\tif (limit >= wm831x_usb_limits[i] &&\n\t\t    wm831x_usb_limits[best] < wm831x_usb_limits[i])\n\t\t\tbest = i;\n\t}\n\n\tdev_dbg(wm831x_power->wm831x->dev,\n\t\t\"Limiting USB current to %umA\", wm831x_usb_limits[best]);\n\n\twm831x_set_bits(wm831x_power->wm831x, WM831X_POWER_STATE,\n\t\t        WM831X_USB_ILIM_MASK, best);\n\n\treturn 0;\n}\n\n \n\nstruct chg_map {\n\tint val;\n\tint reg_val;\n};\n\nstatic struct chg_map trickle_ilims[] = {\n\t{  50, 0 << WM831X_CHG_TRKL_ILIM_SHIFT },\n\t{ 100, 1 << WM831X_CHG_TRKL_ILIM_SHIFT },\n\t{ 150, 2 << WM831X_CHG_TRKL_ILIM_SHIFT },\n\t{ 200, 3 << WM831X_CHG_TRKL_ILIM_SHIFT },\n};\n\nstatic struct chg_map vsels[] = {\n\t{ 4050, 0 << WM831X_CHG_VSEL_SHIFT },\n\t{ 4100, 1 << WM831X_CHG_VSEL_SHIFT },\n\t{ 4150, 2 << WM831X_CHG_VSEL_SHIFT },\n\t{ 4200, 3 << WM831X_CHG_VSEL_SHIFT },\n};\n\nstatic struct chg_map fast_ilims[] = {\n\t{    0,  0 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{   50,  1 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  100,  2 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  150,  3 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  200,  4 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  250,  5 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  300,  6 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  350,  7 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  400,  8 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  450,  9 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  500, 10 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  600, 11 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  700, 12 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  800, 13 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{  900, 14 << WM831X_CHG_FAST_ILIM_SHIFT },\n\t{ 1000, 15 << WM831X_CHG_FAST_ILIM_SHIFT },\n};\n\nstatic struct chg_map eoc_iterms[] = {\n\t{ 20, 0 << WM831X_CHG_ITERM_SHIFT },\n\t{ 30, 1 << WM831X_CHG_ITERM_SHIFT },\n\t{ 40, 2 << WM831X_CHG_ITERM_SHIFT },\n\t{ 50, 3 << WM831X_CHG_ITERM_SHIFT },\n\t{ 60, 4 << WM831X_CHG_ITERM_SHIFT },\n\t{ 70, 5 << WM831X_CHG_ITERM_SHIFT },\n\t{ 80, 6 << WM831X_CHG_ITERM_SHIFT },\n\t{ 90, 7 << WM831X_CHG_ITERM_SHIFT },\n};\n\nstatic struct chg_map chg_times[] = {\n\t{  60,  0 << WM831X_CHG_TIME_SHIFT },\n\t{  90,  1 << WM831X_CHG_TIME_SHIFT },\n\t{ 120,  2 << WM831X_CHG_TIME_SHIFT },\n\t{ 150,  3 << WM831X_CHG_TIME_SHIFT },\n\t{ 180,  4 << WM831X_CHG_TIME_SHIFT },\n\t{ 210,  5 << WM831X_CHG_TIME_SHIFT },\n\t{ 240,  6 << WM831X_CHG_TIME_SHIFT },\n\t{ 270,  7 << WM831X_CHG_TIME_SHIFT },\n\t{ 300,  8 << WM831X_CHG_TIME_SHIFT },\n\t{ 330,  9 << WM831X_CHG_TIME_SHIFT },\n\t{ 360, 10 << WM831X_CHG_TIME_SHIFT },\n\t{ 390, 11 << WM831X_CHG_TIME_SHIFT },\n\t{ 420, 12 << WM831X_CHG_TIME_SHIFT },\n\t{ 450, 13 << WM831X_CHG_TIME_SHIFT },\n\t{ 480, 14 << WM831X_CHG_TIME_SHIFT },\n\t{ 510, 15 << WM831X_CHG_TIME_SHIFT },\n};\n\nstatic void wm831x_battery_apply_config(struct wm831x *wm831x,\n\t\t\t\t       struct chg_map *map, int count, int val,\n\t\t\t\t       int *reg, const char *name,\n\t\t\t\t       const char *units)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (val == map[i].val)\n\t\t\tbreak;\n\tif (i == count) {\n\t\tdev_err(wm831x->dev, \"Invalid %s %d%s\\n\",\n\t\t\tname, val, units);\n\t} else {\n\t\t*reg |= map[i].reg_val;\n\t\tdev_dbg(wm831x->dev, \"Set %s of %d%s\\n\", name, val, units);\n\t}\n}\n\nstatic void wm831x_config_battery(struct wm831x *wm831x)\n{\n\tstruct wm831x_pdata *wm831x_pdata = wm831x->dev->platform_data;\n\tstruct wm831x_battery_pdata *pdata;\n\tint ret, reg1, reg2;\n\n\tif (!wm831x_pdata || !wm831x_pdata->battery) {\n\t\tdev_warn(wm831x->dev,\n\t\t\t \"No battery charger configuration\\n\");\n\t\treturn;\n\t}\n\n\tpdata = wm831x_pdata->battery;\n\n\treg1 = 0;\n\treg2 = 0;\n\n\tif (!pdata->enable) {\n\t\tdev_info(wm831x->dev, \"Battery charger disabled\\n\");\n\t\treturn;\n\t}\n\n\treg1 |= WM831X_CHG_ENA;\n\tif (pdata->off_mask)\n\t\treg2 |= WM831X_CHG_OFF_MSK;\n\tif (pdata->fast_enable)\n\t\treg1 |= WM831X_CHG_FAST;\n\n\twm831x_battery_apply_config(wm831x, trickle_ilims,\n\t\t\t\t   ARRAY_SIZE(trickle_ilims),\n\t\t\t\t   pdata->trickle_ilim, &reg2,\n\t\t\t\t   \"trickle charge current limit\", \"mA\");\n\n\twm831x_battery_apply_config(wm831x, vsels, ARRAY_SIZE(vsels),\n\t\t\t\t   pdata->vsel, &reg2,\n\t\t\t\t   \"target voltage\", \"mV\");\n\n\twm831x_battery_apply_config(wm831x, fast_ilims, ARRAY_SIZE(fast_ilims),\n\t\t\t\t   pdata->fast_ilim, &reg2,\n\t\t\t\t   \"fast charge current limit\", \"mA\");\n\n\twm831x_battery_apply_config(wm831x, eoc_iterms, ARRAY_SIZE(eoc_iterms),\n\t\t\t\t   pdata->eoc_iterm, &reg1,\n\t\t\t\t   \"end of charge current threshold\", \"mA\");\n\n\twm831x_battery_apply_config(wm831x, chg_times, ARRAY_SIZE(chg_times),\n\t\t\t\t   pdata->timeout, &reg2,\n\t\t\t\t   \"charger timeout\", \"min\");\n\n\tret = wm831x_reg_unlock(wm831x);\n\tif (ret != 0) {\n\t\tdev_err(wm831x->dev, \"Failed to unlock registers: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = wm831x_set_bits(wm831x, WM831X_CHARGER_CONTROL_1,\n\t\t\t      WM831X_CHG_ENA_MASK |\n\t\t\t      WM831X_CHG_FAST_MASK |\n\t\t\t      WM831X_CHG_ITERM_MASK,\n\t\t\t      reg1);\n\tif (ret != 0)\n\t\tdev_err(wm831x->dev, \"Failed to set charger control 1: %d\\n\",\n\t\t\tret);\n\n\tret = wm831x_set_bits(wm831x, WM831X_CHARGER_CONTROL_2,\n\t\t\t      WM831X_CHG_OFF_MSK |\n\t\t\t      WM831X_CHG_TIME_MASK |\n\t\t\t      WM831X_CHG_FAST_ILIM_MASK |\n\t\t\t      WM831X_CHG_TRKL_ILIM_MASK |\n\t\t\t      WM831X_CHG_VSEL_MASK,\n\t\t\t      reg2);\n\tif (ret != 0)\n\t\tdev_err(wm831x->dev, \"Failed to set charger control 2: %d\\n\",\n\t\t\tret);\n\n\twm831x_reg_lock(wm831x);\n}\n\nstatic int wm831x_bat_check_status(struct wm831x *wm831x, int *status)\n{\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & WM831X_PWR_SRC_BATT) {\n\t\t*status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn 0;\n\t}\n\n\tret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & WM831X_CHG_STATE_MASK) {\n\tcase WM831X_CHG_STATE_OFF:\n\t\t*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase WM831X_CHG_STATE_TRICKLE:\n\tcase WM831X_CHG_STATE_FAST:\n\t\t*status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\n\tdefault:\n\t\t*status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_bat_check_type(struct wm831x *wm831x, int *type)\n{\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & WM831X_CHG_STATE_MASK) {\n\tcase WM831X_CHG_STATE_TRICKLE:\n\tcase WM831X_CHG_STATE_TRICKLE_OT:\n\t\t*type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase WM831X_CHG_STATE_FAST:\n\tcase WM831X_CHG_STATE_FAST_OT:\n\t\t*type = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\tbreak;\n\tdefault:\n\t\t*type = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_bat_check_health(struct wm831x *wm831x, int *health)\n{\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & WM831X_BATT_HOT_STS) {\n\t\t*health = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\treturn 0;\n\t}\n\n\tif (ret & WM831X_BATT_COLD_STS) {\n\t\t*health = POWER_SUPPLY_HEALTH_COLD;\n\t\treturn 0;\n\t}\n\n\tif (ret & WM831X_BATT_OV_STS) {\n\t\t*health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t\treturn 0;\n\t}\n\n\tswitch (ret & WM831X_CHG_STATE_MASK) {\n\tcase WM831X_CHG_STATE_TRICKLE_OT:\n\tcase WM831X_CHG_STATE_FAST_OT:\n\t\t*health = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\tbreak;\n\tcase WM831X_CHG_STATE_DEFECTIVE:\n\t\t*health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\tbreak;\n\tdefault:\n\t\t*health = POWER_SUPPLY_HEALTH_GOOD;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_bat_get_prop(struct power_supply *psy,\n\t\t\t       enum power_supply_property psp,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct wm831x_power *wm831x_power = dev_get_drvdata(psy->dev.parent);\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = wm831x_bat_check_status(wm831x, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = wm831x_power_check_online(wm831x, WM831X_PWR_SRC_BATT,\n\t\t\t\t\t\tval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = wm831x_bat_check_health(wm831x, &val->intval);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = wm831x_bat_check_type(wm831x, &val->intval);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property wm831x_bat_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n};\n\nstatic const char *wm831x_bat_irqs[] = {\n\t\"BATT HOT\",\n\t\"BATT COLD\",\n\t\"BATT FAIL\",\n\t\"OV\",\n\t\"END\",\n\t\"TO\",\n\t\"MODE\",\n\t\"START\",\n};\n\nstatic irqreturn_t wm831x_bat_irq(int irq, void *data)\n{\n\tstruct wm831x_power *wm831x_power = data;\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\n\tdev_dbg(wm831x->dev, \"Battery status changed: %d\\n\", irq);\n\n\t \n\tif (wm831x_power->have_battery)\n\t\tpower_supply_changed(wm831x_power->battery);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic irqreturn_t wm831x_syslo_irq(int irq, void *data)\n{\n\tstruct wm831x_power *wm831x_power = data;\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\n\t \n\tdev_crit(wm831x->dev, \"SYSVDD under voltage\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wm831x_pwr_src_irq(int irq, void *data)\n{\n\tstruct wm831x_power *wm831x_power = data;\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\n\tdev_dbg(wm831x->dev, \"Power source changed\\n\");\n\n\t \n\tif (wm831x_power->have_battery)\n\t\tpower_supply_changed(wm831x_power->battery);\n\tpower_supply_changed(wm831x_power->usb);\n\tpower_supply_changed(wm831x_power->wall);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wm831x_power_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *wm831x_pdata = wm831x->dev->platform_data;\n\tstruct wm831x_power *power;\n\tint ret, irq, i;\n\n\tpower = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_power),\n\t\t\t     GFP_KERNEL);\n\tif (power == NULL)\n\t\treturn -ENOMEM;\n\n\tpower->wm831x = wm831x;\n\tplatform_set_drvdata(pdev, power);\n\n\tif (wm831x_pdata && wm831x_pdata->wm831x_num) {\n\t\tsnprintf(power->wall_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-wall.%d\", wm831x_pdata->wm831x_num);\n\t\tsnprintf(power->battery_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-battery.%d\", wm831x_pdata->wm831x_num);\n\t\tsnprintf(power->usb_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-usb.%d\", wm831x_pdata->wm831x_num);\n\t} else {\n\t\tsnprintf(power->wall_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-wall\");\n\t\tsnprintf(power->battery_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-battery\");\n\t\tsnprintf(power->usb_name, sizeof(power->wall_name),\n\t\t\t \"wm831x-usb\");\n\t}\n\n\t \n\twm831x_config_battery(wm831x);\n\n\tpower->wall_desc.name = power->wall_name;\n\tpower->wall_desc.type = POWER_SUPPLY_TYPE_MAINS;\n\tpower->wall_desc.properties = wm831x_wall_props;\n\tpower->wall_desc.num_properties = ARRAY_SIZE(wm831x_wall_props);\n\tpower->wall_desc.get_property = wm831x_wall_get_prop;\n\tpower->wall = power_supply_register(&pdev->dev, &power->wall_desc,\n\t\t\t\t\t    NULL);\n\tif (IS_ERR(power->wall)) {\n\t\tret = PTR_ERR(power->wall);\n\t\tgoto err;\n\t}\n\n\tpower->usb_desc.name = power->usb_name,\n\tpower->usb_desc.type = POWER_SUPPLY_TYPE_USB;\n\tpower->usb_desc.properties = wm831x_usb_props;\n\tpower->usb_desc.num_properties = ARRAY_SIZE(wm831x_usb_props);\n\tpower->usb_desc.get_property = wm831x_usb_get_prop;\n\tpower->usb = power_supply_register(&pdev->dev, &power->usb_desc, NULL);\n\tif (IS_ERR(power->usb)) {\n\t\tret = PTR_ERR(power->usb);\n\t\tgoto err_wall;\n\t}\n\n\tret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_1);\n\tif (ret < 0)\n\t\tgoto err_wall;\n\tpower->have_battery = ret & WM831X_CHG_ENA;\n\n\tif (power->have_battery) {\n\t\tpower->battery_desc.name = power->battery_name;\n\t\tpower->battery_desc.properties = wm831x_bat_props;\n\t\tpower->battery_desc.num_properties = ARRAY_SIZE(wm831x_bat_props);\n\t\tpower->battery_desc.get_property = wm831x_bat_get_prop;\n\t\tpower->battery_desc.use_for_apm = 1;\n\t\tpower->battery = power_supply_register(&pdev->dev,\n\t\t\t\t\t\t       &power->battery_desc,\n\t\t\t\t\t\t       NULL);\n\t\tif (IS_ERR(power->battery)) {\n\t\t\tret = PTR_ERR(power->battery);\n\t\t\tgoto err_usb;\n\t\t}\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"SYSLO\"));\n\tret = request_threaded_irq(irq, NULL, wm831x_syslo_irq,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT, \"System power low\",\n\t\t\t\t   power);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request SYSLO IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err_battery;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"PWR SRC\"));\n\tret = request_threaded_irq(irq, NULL, wm831x_pwr_src_irq,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT, \"Power source\",\n\t\t\t\t   power);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request PWR SRC IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err_syslo;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm831x_bat_irqs); i++) {\n\t\tirq = wm831x_irq(wm831x,\n\t\t\t\t platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t wm831x_bat_irqs[i]));\n\t\tret = request_threaded_irq(irq, NULL, wm831x_bat_irq,\n\t\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t   wm831x_bat_irqs[i],\n\t\t\t\t\t   power);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to request %s IRQ %d: %d\\n\",\n\t\t\t\twm831x_bat_irqs[i], irq, ret);\n\t\t\tgoto err_bat_irq;\n\t\t}\n\t}\n\n\tpower->usb_phy = devm_usb_get_phy_by_phandle(&pdev->dev, \"phys\", 0);\n\tret = PTR_ERR_OR_ZERO(power->usb_phy);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tpower->usb_notify.notifier_call = wm831x_usb_limit_change;\n\t\tret = usb_register_notifier(power->usb_phy, &power->usb_notify);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register notifier: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_bat_irq;\n\t\t}\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ENODEV:\n\t\t \n\t\tpower->usb_phy = NULL;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Failed to find USB phy: %d\\n\", ret);\n\t\tfallthrough;\n\tcase -EPROBE_DEFER:\n\t\tgoto err_bat_irq;\n\t}\n\n\treturn ret;\n\nerr_bat_irq:\n\t--i;\n\tfor (; i >= 0; i--) {\n\t\tirq = platform_get_irq_byname(pdev, wm831x_bat_irqs[i]);\n\t\tfree_irq(irq, power);\n\t}\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"PWR SRC\"));\n\tfree_irq(irq, power);\nerr_syslo:\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"SYSLO\"));\n\tfree_irq(irq, power);\nerr_battery:\n\tif (power->have_battery)\n\t\tpower_supply_unregister(power->battery);\nerr_usb:\n\tpower_supply_unregister(power->usb);\nerr_wall:\n\tpower_supply_unregister(power->wall);\nerr:\n\treturn ret;\n}\n\nstatic int wm831x_power_remove(struct platform_device *pdev)\n{\n\tstruct wm831x_power *wm831x_power = platform_get_drvdata(pdev);\n\tstruct wm831x *wm831x = wm831x_power->wm831x;\n\tint irq, i;\n\n\tif (wm831x_power->usb_phy) {\n\t\tusb_unregister_notifier(wm831x_power->usb_phy,\n\t\t\t\t\t&wm831x_power->usb_notify);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm831x_bat_irqs); i++) {\n\t\tirq = wm831x_irq(wm831x, \n\t\t\t\t platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t wm831x_bat_irqs[i]));\n\t\tfree_irq(irq, wm831x_power);\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"PWR SRC\"));\n\tfree_irq(irq, wm831x_power);\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"SYSLO\"));\n\tfree_irq(irq, wm831x_power);\n\n\tif (wm831x_power->have_battery)\n\t\tpower_supply_unregister(wm831x_power->battery);\n\tpower_supply_unregister(wm831x_power->wall);\n\tpower_supply_unregister(wm831x_power->usb);\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_power_driver = {\n\t.probe = wm831x_power_probe,\n\t.remove = wm831x_power_remove,\n\t.driver = {\n\t\t.name = \"wm831x-power\",\n\t},\n};\n\nmodule_platform_driver(wm831x_power_driver);\n\nMODULE_DESCRIPTION(\"Power supply driver for WM831x PMICs\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-power\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}