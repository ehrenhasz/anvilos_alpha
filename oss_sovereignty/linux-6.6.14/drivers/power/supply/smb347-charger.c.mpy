{
  "module_name": "smb347-charger.c",
  "hash_id": "ff61eb964e4dd8f52bdd2aa54048a65b49a9179f25bef6ba5c9fef28621c70e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/smb347-charger.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\n#include <dt-bindings/power/summit,smb347-charger.h>\n\n \n#define SMB3XX_SOFT_TEMP_COMPENSATE_DEFAULT -1\n\n \n#define SMB3XX_TEMP_USE_DEFAULT\t\t-273\n\n \n#define CFG_CHARGE_CURRENT\t\t\t0x00\n#define CFG_CHARGE_CURRENT_FCC_MASK\t\t0xe0\n#define CFG_CHARGE_CURRENT_FCC_SHIFT\t\t5\n#define CFG_CHARGE_CURRENT_PCC_MASK\t\t0x18\n#define CFG_CHARGE_CURRENT_PCC_SHIFT\t\t3\n#define CFG_CHARGE_CURRENT_TC_MASK\t\t0x07\n#define CFG_CURRENT_LIMIT\t\t\t0x01\n#define CFG_CURRENT_LIMIT_DC_MASK\t\t0xf0\n#define CFG_CURRENT_LIMIT_DC_SHIFT\t\t4\n#define CFG_CURRENT_LIMIT_USB_MASK\t\t0x0f\n#define CFG_FLOAT_VOLTAGE\t\t\t0x03\n#define CFG_FLOAT_VOLTAGE_FLOAT_MASK\t\t0x3f\n#define CFG_FLOAT_VOLTAGE_THRESHOLD_MASK\t0xc0\n#define CFG_FLOAT_VOLTAGE_THRESHOLD_SHIFT\t6\n#define CFG_STAT\t\t\t\t0x05\n#define CFG_STAT_DISABLED\t\t\tBIT(5)\n#define CFG_STAT_ACTIVE_HIGH\t\t\tBIT(7)\n#define CFG_PIN\t\t\t\t\t0x06\n#define CFG_PIN_EN_CTRL_MASK\t\t\t0x60\n#define CFG_PIN_EN_CTRL_ACTIVE_HIGH\t\t0x40\n#define CFG_PIN_EN_CTRL_ACTIVE_LOW\t\t0x60\n#define CFG_PIN_EN_APSD_IRQ\t\t\tBIT(1)\n#define CFG_PIN_EN_CHARGER_ERROR\t\tBIT(2)\n#define CFG_PIN_EN_CTRL\t\t\t\tBIT(4)\n#define CFG_THERM\t\t\t\t0x07\n#define CFG_THERM_SOFT_HOT_COMPENSATION_MASK\t0x03\n#define CFG_THERM_SOFT_HOT_COMPENSATION_SHIFT\t0\n#define CFG_THERM_SOFT_COLD_COMPENSATION_MASK\t0x0c\n#define CFG_THERM_SOFT_COLD_COMPENSATION_SHIFT\t2\n#define CFG_THERM_MONITOR_DISABLED\t\tBIT(4)\n#define CFG_SYSOK\t\t\t\t0x08\n#define CFG_SYSOK_INOK_ACTIVE_HIGH\t\tBIT(0)\n#define CFG_SYSOK_SUSPEND_HARD_LIMIT_DISABLED\tBIT(2)\n#define CFG_OTHER\t\t\t\t0x09\n#define CFG_OTHER_RID_MASK\t\t\t0xc0\n#define CFG_OTHER_RID_ENABLED_AUTO_OTG\t\t0xc0\n#define CFG_OTG\t\t\t\t\t0x0a\n#define CFG_OTG_TEMP_THRESHOLD_MASK\t\t0x30\n#define CFG_OTG_CURRENT_LIMIT_250mA\t\tBIT(2)\n#define CFG_OTG_CURRENT_LIMIT_750mA\t\tBIT(3)\n#define CFG_OTG_TEMP_THRESHOLD_SHIFT\t\t4\n#define CFG_OTG_CC_COMPENSATION_MASK\t\t0xc0\n#define CFG_OTG_CC_COMPENSATION_SHIFT\t\t6\n#define CFG_TEMP_LIMIT\t\t\t\t0x0b\n#define CFG_TEMP_LIMIT_SOFT_HOT_MASK\t\t0x03\n#define CFG_TEMP_LIMIT_SOFT_HOT_SHIFT\t\t0\n#define CFG_TEMP_LIMIT_SOFT_COLD_MASK\t\t0x0c\n#define CFG_TEMP_LIMIT_SOFT_COLD_SHIFT\t\t2\n#define CFG_TEMP_LIMIT_HARD_HOT_MASK\t\t0x30\n#define CFG_TEMP_LIMIT_HARD_HOT_SHIFT\t\t4\n#define CFG_TEMP_LIMIT_HARD_COLD_MASK\t\t0xc0\n#define CFG_TEMP_LIMIT_HARD_COLD_SHIFT\t\t6\n#define CFG_FAULT_IRQ\t\t\t\t0x0c\n#define CFG_FAULT_IRQ_DCIN_UV\t\t\tBIT(2)\n#define CFG_STATUS_IRQ\t\t\t\t0x0d\n#define CFG_STATUS_IRQ_TERMINATION_OR_TAPER\tBIT(4)\n#define CFG_STATUS_IRQ_CHARGE_TIMEOUT\t\tBIT(7)\n#define CFG_ADDRESS\t\t\t\t0x0e\n\n \n#define CMD_A\t\t\t\t\t0x30\n#define CMD_A_CHG_ENABLED\t\t\tBIT(1)\n#define CMD_A_SUSPEND_ENABLED\t\t\tBIT(2)\n#define CMD_A_OTG_ENABLED\t\t\tBIT(4)\n#define CMD_A_ALLOW_WRITE\t\t\tBIT(7)\n#define CMD_B\t\t\t\t\t0x31\n#define CMD_C\t\t\t\t\t0x33\n\n \n#define IRQSTAT_A\t\t\t\t0x35\n#define IRQSTAT_C\t\t\t\t0x37\n#define IRQSTAT_C_TERMINATION_STAT\t\tBIT(0)\n#define IRQSTAT_C_TERMINATION_IRQ\t\tBIT(1)\n#define IRQSTAT_C_TAPER_IRQ\t\t\tBIT(3)\n#define IRQSTAT_D\t\t\t\t0x38\n#define IRQSTAT_D_CHARGE_TIMEOUT_STAT\t\tBIT(2)\n#define IRQSTAT_D_CHARGE_TIMEOUT_IRQ\t\tBIT(3)\n#define IRQSTAT_E\t\t\t\t0x39\n#define IRQSTAT_E_USBIN_UV_STAT\t\t\tBIT(0)\n#define IRQSTAT_E_USBIN_UV_IRQ\t\t\tBIT(1)\n#define IRQSTAT_E_DCIN_UV_STAT\t\t\tBIT(4)\n#define IRQSTAT_E_DCIN_UV_IRQ\t\t\tBIT(5)\n#define IRQSTAT_F\t\t\t\t0x3a\n\n \n#define STAT_A\t\t\t\t\t0x3b\n#define STAT_A_FLOAT_VOLTAGE_MASK\t\t0x3f\n#define STAT_B\t\t\t\t\t0x3c\n#define STAT_C\t\t\t\t\t0x3d\n#define STAT_C_CHG_ENABLED\t\t\tBIT(0)\n#define STAT_C_HOLDOFF_STAT\t\t\tBIT(3)\n#define STAT_C_CHG_MASK\t\t\t\t0x06\n#define STAT_C_CHG_SHIFT\t\t\t1\n#define STAT_C_CHG_TERM\t\t\t\tBIT(5)\n#define STAT_C_CHARGER_ERROR\t\t\tBIT(6)\n#define STAT_E\t\t\t\t\t0x3f\n\n#define SMB347_MAX_REGISTER\t\t\t0x3f\n\n \nstruct smb347_charger {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\tstruct power_supply\t*mains;\n\tstruct power_supply\t*usb;\n\tstruct regulator_dev\t*usb_rdev;\n\tunsigned int\t\tid;\n\tbool\t\t\tmains_online;\n\tbool\t\t\tusb_online;\n\tbool\t\t\tirq_unsupported;\n\tbool\t\t\tusb_vbus_enabled;\n\n\tunsigned int\t\tmax_charge_current;\n\tunsigned int\t\tmax_charge_voltage;\n\tunsigned int\t\tpre_charge_current;\n\tunsigned int\t\ttermination_current;\n\tunsigned int\t\tpre_to_fast_voltage;\n\tunsigned int\t\tmains_current_limit;\n\tunsigned int\t\tusb_hc_current_limit;\n\tunsigned int\t\tchip_temp_threshold;\n\tint\t\t\tsoft_cold_temp_limit;\n\tint\t\t\tsoft_hot_temp_limit;\n\tint\t\t\thard_cold_temp_limit;\n\tint\t\t\thard_hot_temp_limit;\n\tbool\t\t\tsuspend_on_hard_temp_limit;\n\tunsigned int\t\tsoft_temp_limit_compensation;\n\tunsigned int\t\tcharge_current_compensation;\n\tbool\t\t\tuse_mains;\n\tbool\t\t\tuse_usb;\n\tbool\t\t\tuse_usb_otg;\n\tunsigned int\t\tenable_control;\n\tunsigned int\t\tinok_polarity;\n};\n\nenum smb_charger_chipid {\n\tSMB345,\n\tSMB347,\n\tSMB358,\n\tNUM_CHIP_TYPES,\n};\n\n \nstatic const unsigned int fcc_tbl[NUM_CHIP_TYPES][8] = {\n\t[SMB345] = {  200000,  450000,  600000,  900000,\n\t\t     1300000, 1500000, 1800000, 2000000 },\n\t[SMB347] = {  700000,  900000, 1200000, 1500000,\n\t\t     1800000, 2000000, 2200000, 2500000 },\n\t[SMB358] = {  200000,  450000,  600000,  900000,\n\t\t     1300000, 1500000, 1800000, 2000000 },\n};\n \nstatic const unsigned int pcc_tbl[NUM_CHIP_TYPES][4] = {\n\t[SMB345] = { 150000, 250000, 350000, 450000 },\n\t[SMB347] = { 100000, 150000, 200000, 250000 },\n\t[SMB358] = { 150000, 250000, 350000, 450000 },\n};\n\n \nstatic const unsigned int tc_tbl[NUM_CHIP_TYPES][8] = {\n\t[SMB345] = {  30000,  40000,  60000,  80000,\n\t\t     100000, 125000, 150000, 200000 },\n\t[SMB347] = {  37500,  50000, 100000, 150000,\n\t\t     200000, 250000, 500000, 600000 },\n\t[SMB358] = {  30000,  40000,  60000,  80000,\n\t\t     100000, 125000, 150000, 200000 },\n};\n\n \nstatic const unsigned int icl_tbl[NUM_CHIP_TYPES][10] = {\n\t[SMB345] = {  300000,  500000,  700000, 1000000, 1500000,\n\t\t     1800000, 2000000, 2000000, 2000000, 2000000 },\n\t[SMB347] = {  300000,  500000,  700000,  900000, 1200000,\n\t\t     1500000, 1800000, 2000000, 2200000, 2500000 },\n\t[SMB358] = {  300000,  500000,  700000, 1000000, 1500000,\n\t\t     1800000, 2000000, 2000000, 2000000, 2000000 },\n};\n\n \nstatic const unsigned int ccc_tbl[NUM_CHIP_TYPES][4] = {\n\t[SMB345] = {  200000,  450000,  600000,  900000 },\n\t[SMB347] = {  250000,  700000,  900000, 1200000 },\n\t[SMB358] = {  200000,  450000,  600000,  900000 },\n};\n\n \nstatic int hw_to_current(const unsigned int *tbl, size_t size, unsigned int val)\n{\n\tif (val >= size)\n\t\treturn -EINVAL;\n\treturn tbl[val];\n}\n\n \nstatic int current_to_hw(const unsigned int *tbl, size_t size, unsigned int val)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (val < tbl[i])\n\t\t\tbreak;\n\treturn i > 0 ? i - 1 : -EINVAL;\n}\n\n \nstatic int smb347_update_ps_status(struct smb347_charger *smb)\n{\n\tbool usb = false;\n\tbool dc = false;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(smb->regmap, IRQSTAT_E, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (smb->use_mains)\n\t\tdc = !(val & IRQSTAT_E_DCIN_UV_STAT);\n\tif (smb->use_usb)\n\t\tusb = !(val & IRQSTAT_E_USBIN_UV_STAT);\n\n\tret = smb->mains_online != dc || smb->usb_online != usb;\n\tsmb->mains_online = dc;\n\tsmb->usb_online = usb;\n\n\treturn ret;\n}\n\n \nstatic bool smb347_is_ps_online(struct smb347_charger *smb)\n{\n\treturn smb->usb_online || smb->mains_online;\n}\n\n \nstatic int smb347_charging_status(struct smb347_charger *smb)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (!smb347_is_ps_online(smb))\n\t\treturn 0;\n\n\tret = regmap_read(smb->regmap, STAT_C, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn (val & STAT_C_CHG_MASK) >> STAT_C_CHG_SHIFT;\n}\n\nstatic int smb347_charging_set(struct smb347_charger *smb, bool enable)\n{\n\tif (smb->enable_control != SMB3XX_CHG_ENABLE_SW) {\n\t\tdev_dbg(smb->dev, \"charging enable/disable in SW disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tif (enable && smb->usb_vbus_enabled) {\n\t\tdev_dbg(smb->dev, \"charging not enabled because USB is in host mode\\n\");\n\t\treturn 0;\n\t}\n\n\treturn regmap_update_bits(smb->regmap, CMD_A, CMD_A_CHG_ENABLED,\n\t\t\t\t  enable ? CMD_A_CHG_ENABLED : 0);\n}\n\nstatic inline int smb347_charging_enable(struct smb347_charger *smb)\n{\n\treturn smb347_charging_set(smb, true);\n}\n\nstatic inline int smb347_charging_disable(struct smb347_charger *smb)\n{\n\treturn smb347_charging_set(smb, false);\n}\n\nstatic int smb347_start_stop_charging(struct smb347_charger *smb)\n{\n\tint ret;\n\n\t \n\tif (smb347_is_ps_online(smb)) {\n\t\tret = smb347_charging_enable(smb);\n\t\tif (ret < 0)\n\t\t\tdev_err(smb->dev, \"failed to enable charging\\n\");\n\t} else {\n\t\tret = smb347_charging_disable(smb);\n\t\tif (ret < 0)\n\t\t\tdev_err(smb->dev, \"failed to disable charging\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int smb347_set_charge_current(struct smb347_charger *smb)\n{\n\tunsigned int id = smb->id;\n\tint ret;\n\n\tif (smb->max_charge_current) {\n\t\tret = current_to_hw(fcc_tbl[id], ARRAY_SIZE(fcc_tbl[id]),\n\t\t\t\t    smb->max_charge_current);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\n\t\t\t\t\t CFG_CHARGE_CURRENT_FCC_MASK,\n\t\t\t\t\t ret << CFG_CHARGE_CURRENT_FCC_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->pre_charge_current) {\n\t\tret = current_to_hw(pcc_tbl[id], ARRAY_SIZE(pcc_tbl[id]),\n\t\t\t\t    smb->pre_charge_current);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\n\t\t\t\t\t CFG_CHARGE_CURRENT_PCC_MASK,\n\t\t\t\t\t ret << CFG_CHARGE_CURRENT_PCC_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->termination_current) {\n\t\tret = current_to_hw(tc_tbl[id], ARRAY_SIZE(tc_tbl[id]),\n\t\t\t\t    smb->termination_current);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\n\t\t\t\t\t CFG_CHARGE_CURRENT_TC_MASK, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb347_set_current_limits(struct smb347_charger *smb)\n{\n\tunsigned int id = smb->id;\n\tint ret;\n\n\tif (smb->mains_current_limit) {\n\t\tret = current_to_hw(icl_tbl[id], ARRAY_SIZE(icl_tbl[id]),\n\t\t\t\t    smb->mains_current_limit);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_CURRENT_LIMIT,\n\t\t\t\t\t CFG_CURRENT_LIMIT_DC_MASK,\n\t\t\t\t\t ret << CFG_CURRENT_LIMIT_DC_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->usb_hc_current_limit) {\n\t\tret = current_to_hw(icl_tbl[id], ARRAY_SIZE(icl_tbl[id]),\n\t\t\t\t    smb->usb_hc_current_limit);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_CURRENT_LIMIT,\n\t\t\t\t\t CFG_CURRENT_LIMIT_USB_MASK, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb347_set_voltage_limits(struct smb347_charger *smb)\n{\n\tint ret;\n\n\tif (smb->pre_to_fast_voltage) {\n\t\tret = smb->pre_to_fast_voltage;\n\n\t\t \n\t\tret = clamp_val(ret, 2400000, 3000000) - 2400000;\n\t\tret /= 200000;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_FLOAT_VOLTAGE,\n\t\t\t\tCFG_FLOAT_VOLTAGE_THRESHOLD_MASK,\n\t\t\t\tret << CFG_FLOAT_VOLTAGE_THRESHOLD_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->max_charge_voltage) {\n\t\tret = smb->max_charge_voltage;\n\n\t\t \n\t\tret = clamp_val(ret, 3500000, 4500000) - 3500000;\n\t\tret /= 20000;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_FLOAT_VOLTAGE,\n\t\t\t\t\t CFG_FLOAT_VOLTAGE_FLOAT_MASK, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb347_set_temp_limits(struct smb347_charger *smb)\n{\n\tunsigned int id = smb->id;\n\tbool enable_therm_monitor = false;\n\tint ret = 0;\n\tint val;\n\n\tif (smb->chip_temp_threshold) {\n\t\tval = smb->chip_temp_threshold;\n\n\t\t \n\t\tval = clamp_val(val, 100, 130) - 100;\n\t\tval /= 10;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_OTG,\n\t\t\t\t\t CFG_OTG_TEMP_THRESHOLD_MASK,\n\t\t\t\t\t val << CFG_OTG_TEMP_THRESHOLD_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->soft_cold_temp_limit != SMB3XX_TEMP_USE_DEFAULT) {\n\t\tval = smb->soft_cold_temp_limit;\n\n\t\tval = clamp_val(val, 0, 15);\n\t\tval /= 5;\n\t\t \n\t\tval = ~val & 0x3;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\n\t\t\t\t\t CFG_TEMP_LIMIT_SOFT_COLD_MASK,\n\t\t\t\t\t val << CFG_TEMP_LIMIT_SOFT_COLD_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tenable_therm_monitor = true;\n\t}\n\n\tif (smb->soft_hot_temp_limit != SMB3XX_TEMP_USE_DEFAULT) {\n\t\tval = smb->soft_hot_temp_limit;\n\n\t\tval = clamp_val(val, 40, 55) - 40;\n\t\tval /= 5;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\n\t\t\t\t\t CFG_TEMP_LIMIT_SOFT_HOT_MASK,\n\t\t\t\t\t val << CFG_TEMP_LIMIT_SOFT_HOT_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tenable_therm_monitor = true;\n\t}\n\n\tif (smb->hard_cold_temp_limit != SMB3XX_TEMP_USE_DEFAULT) {\n\t\tval = smb->hard_cold_temp_limit;\n\n\t\tval = clamp_val(val, -5, 10) + 5;\n\t\tval /= 5;\n\t\t \n\t\tval = ~val & 0x3;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\n\t\t\t\t\t CFG_TEMP_LIMIT_HARD_COLD_MASK,\n\t\t\t\t\t val << CFG_TEMP_LIMIT_HARD_COLD_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tenable_therm_monitor = true;\n\t}\n\n\tif (smb->hard_hot_temp_limit != SMB3XX_TEMP_USE_DEFAULT) {\n\t\tval = smb->hard_hot_temp_limit;\n\n\t\tval = clamp_val(val, 50, 65) - 50;\n\t\tval /= 5;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\n\t\t\t\t\t CFG_TEMP_LIMIT_HARD_HOT_MASK,\n\t\t\t\t\t val << CFG_TEMP_LIMIT_HARD_HOT_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tenable_therm_monitor = true;\n\t}\n\n\t \n\tif (enable_therm_monitor) {\n\t\tret = regmap_update_bits(smb->regmap, CFG_THERM,\n\t\t\t\t\t CFG_THERM_MONITOR_DISABLED, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->suspend_on_hard_temp_limit) {\n\t\tret = regmap_update_bits(smb->regmap, CFG_SYSOK,\n\t\t\t\t CFG_SYSOK_SUSPEND_HARD_LIMIT_DISABLED, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->soft_temp_limit_compensation !=\n\t    SMB3XX_SOFT_TEMP_COMPENSATE_DEFAULT) {\n\t\tval = smb->soft_temp_limit_compensation & 0x3;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_THERM,\n\t\t\t\t CFG_THERM_SOFT_HOT_COMPENSATION_MASK,\n\t\t\t\t val << CFG_THERM_SOFT_HOT_COMPENSATION_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_THERM,\n\t\t\t\t CFG_THERM_SOFT_COLD_COMPENSATION_MASK,\n\t\t\t\t val << CFG_THERM_SOFT_COLD_COMPENSATION_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (smb->charge_current_compensation) {\n\t\tval = current_to_hw(ccc_tbl[id], ARRAY_SIZE(ccc_tbl[id]),\n\t\t\t\t    smb->charge_current_compensation);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_OTG,\n\t\t\t\tCFG_OTG_CC_COMPENSATION_MASK,\n\t\t\t\t(val & 0x3) << CFG_OTG_CC_COMPENSATION_SHIFT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int smb347_set_writable(struct smb347_charger *smb, bool writable,\n\t\t\t       bool irq_toggle)\n{\n\tstruct i2c_client *client = to_i2c_client(smb->dev);\n\tint ret;\n\n\tif (writable && irq_toggle && !smb->irq_unsupported)\n\t\tdisable_irq(client->irq);\n\n\tret = regmap_update_bits(smb->regmap, CMD_A, CMD_A_ALLOW_WRITE,\n\t\t\t\t writable ? CMD_A_ALLOW_WRITE : 0);\n\n\tif ((!writable || ret) && irq_toggle && !smb->irq_unsupported)\n\t\tenable_irq(client->irq);\n\n\treturn ret;\n}\n\nstatic int smb347_hw_init(struct smb347_charger *smb)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = smb347_set_writable(smb, true, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = smb347_set_charge_current(smb);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = smb347_set_current_limits(smb);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = smb347_set_voltage_limits(smb);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = smb347_set_temp_limits(smb);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tif (!smb->use_usb) {\n\t\tret = regmap_update_bits(smb->regmap, CMD_A,\n\t\t\t\t\t CMD_A_SUSPEND_ENABLED,\n\t\t\t\t\t CMD_A_SUSPEND_ENABLED);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tret = regmap_update_bits(smb->regmap, CFG_OTHER, CFG_OTHER_RID_MASK,\n\t\tsmb->use_usb_otg ? CFG_OTHER_RID_ENABLED_AUTO_OTG : 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tswitch (smb->enable_control) {\n\tcase SMB3XX_CHG_ENABLE_PIN_ACTIVE_LOW:\n\tcase SMB3XX_CHG_ENABLE_PIN_ACTIVE_HIGH:\n\t\tret = regmap_set_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_CTRL);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tswitch (smb->enable_control) {\n\tcase SMB3XX_CHG_ENABLE_PIN_ACTIVE_LOW:\n\t\tval = CFG_PIN_EN_CTRL_ACTIVE_LOW;\n\t\tbreak;\n\tcase SMB3XX_CHG_ENABLE_PIN_ACTIVE_HIGH:\n\t\tval = CFG_PIN_EN_CTRL_ACTIVE_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\tret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_CTRL_MASK,\n\t\t\t\t val);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_APSD_IRQ, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = smb347_update_ps_status(smb);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = smb347_start_stop_charging(smb);\n\nfail:\n\tsmb347_set_writable(smb, false, false);\n\treturn ret;\n}\n\nstatic irqreturn_t smb347_interrupt(int irq, void *data)\n{\n\tstruct smb347_charger *smb = data;\n\tunsigned int stat_c, irqstat_c, irqstat_d, irqstat_e;\n\tbool handled = false;\n\tint ret;\n\n\t \n\tusleep_range(25000, 35000);\n\n\tret = regmap_read(smb->regmap, STAT_C, &stat_c);\n\tif (ret < 0) {\n\t\tdev_warn(smb->dev, \"reading STAT_C failed\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(smb->regmap, IRQSTAT_C, &irqstat_c);\n\tif (ret < 0) {\n\t\tdev_warn(smb->dev, \"reading IRQSTAT_C failed\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(smb->regmap, IRQSTAT_D, &irqstat_d);\n\tif (ret < 0) {\n\t\tdev_warn(smb->dev, \"reading IRQSTAT_D failed\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(smb->regmap, IRQSTAT_E, &irqstat_e);\n\tif (ret < 0) {\n\t\tdev_warn(smb->dev, \"reading IRQSTAT_E failed\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (stat_c & STAT_C_CHARGER_ERROR) {\n\t\tdev_err(smb->dev, \"charging stopped due to charger error\\n\");\n\t\tif (smb->use_mains)\n\t\t\tpower_supply_changed(smb->mains);\n\t\tif (smb->use_usb)\n\t\t\tpower_supply_changed(smb->usb);\n\t\thandled = true;\n\t}\n\n\t \n\tif (irqstat_c & (IRQSTAT_C_TERMINATION_IRQ | IRQSTAT_C_TAPER_IRQ)) {\n\t\tif (irqstat_c & IRQSTAT_C_TERMINATION_STAT) {\n\t\t\tif (smb->use_mains)\n\t\t\t\tpower_supply_changed(smb->mains);\n\t\t\tif (smb->use_usb)\n\t\t\t\tpower_supply_changed(smb->usb);\n\t\t}\n\t\tdev_dbg(smb->dev, \"going to HW maintenance mode\\n\");\n\t\thandled = true;\n\t}\n\n\t \n\tif (irqstat_d & IRQSTAT_D_CHARGE_TIMEOUT_IRQ) {\n\t\tdev_dbg(smb->dev, \"total Charge Timeout INT received\\n\");\n\n\t\tif (irqstat_d & IRQSTAT_D_CHARGE_TIMEOUT_STAT)\n\t\t\tdev_warn(smb->dev, \"charging stopped due to timeout\\n\");\n\t\tif (smb->use_mains)\n\t\t\tpower_supply_changed(smb->mains);\n\t\tif (smb->use_usb)\n\t\t\tpower_supply_changed(smb->usb);\n\t\thandled = true;\n\t}\n\n\t \n\tif (irqstat_e & (IRQSTAT_E_USBIN_UV_IRQ | IRQSTAT_E_DCIN_UV_IRQ)) {\n\t\tif (smb347_update_ps_status(smb) > 0) {\n\t\t\tsmb347_start_stop_charging(smb);\n\t\t\tif (smb->use_mains)\n\t\t\t\tpower_supply_changed(smb->mains);\n\t\t\tif (smb->use_usb)\n\t\t\t\tpower_supply_changed(smb->usb);\n\t\t}\n\t\thandled = true;\n\t}\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int smb347_irq_set(struct smb347_charger *smb, bool enable)\n{\n\tint ret;\n\n\tif (smb->irq_unsupported)\n\t\treturn 0;\n\n\tret = smb347_set_writable(smb, true, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(smb->regmap, CFG_FAULT_IRQ, 0xff,\n\t\t\t\t enable ? CFG_FAULT_IRQ_DCIN_UV : 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = regmap_update_bits(smb->regmap, CFG_STATUS_IRQ, 0xff,\n\t\t\tenable ? (CFG_STATUS_IRQ_TERMINATION_OR_TAPER |\n\t\t\t\t\tCFG_STATUS_IRQ_CHARGE_TIMEOUT) : 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_CHARGER_ERROR,\n\t\t\t\t enable ? CFG_PIN_EN_CHARGER_ERROR : 0);\nfail:\n\tsmb347_set_writable(smb, false, true);\n\treturn ret;\n}\n\nstatic inline int smb347_irq_enable(struct smb347_charger *smb)\n{\n\treturn smb347_irq_set(smb, true);\n}\n\nstatic inline int smb347_irq_disable(struct smb347_charger *smb)\n{\n\treturn smb347_irq_set(smb, false);\n}\n\nstatic int smb347_irq_init(struct smb347_charger *smb,\n\t\t\t   struct i2c_client *client)\n{\n\tint ret;\n\n\tsmb->irq_unsupported = true;\n\n\t \n\tif (!client->irq)\n\t\treturn 0;\n\n\tret = smb347_set_writable(smb, true, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(smb->regmap, CFG_STAT,\n\t\t\t\t CFG_STAT_ACTIVE_HIGH | CFG_STAT_DISABLED,\n\t\t\t\t CFG_STAT_DISABLED);\n\n\tsmb347_set_writable(smb, false, false);\n\n\tif (ret < 0) {\n\t\tdev_warn(smb->dev, \"failed to initialize IRQ: %d\\n\", ret);\n\t\tdev_warn(smb->dev, \"disabling IRQ support\\n\");\n\t\treturn 0;\n\t}\n\n\tret = devm_request_threaded_irq(smb->dev, client->irq, NULL,\n\t\t\t\t\tsmb347_interrupt, IRQF_ONESHOT,\n\t\t\t\t\tclient->name, smb);\n\tif (ret)\n\t\treturn ret;\n\n\tsmb->irq_unsupported = false;\n\n\tret = smb347_irq_enable(smb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int get_const_charge_current(struct smb347_charger *smb)\n{\n\tunsigned int id = smb->id;\n\tint ret, intval;\n\tunsigned int v;\n\n\tif (!smb347_is_ps_online(smb))\n\t\treturn -ENODATA;\n\n\tret = regmap_read(smb->regmap, STAT_B, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (v & 0x20) {\n\t\tintval = hw_to_current(fcc_tbl[id],\n\t\t\t\t       ARRAY_SIZE(fcc_tbl[id]), v & 7);\n\t} else {\n\t\tv >>= 3;\n\t\tintval = hw_to_current(pcc_tbl[id],\n\t\t\t\t       ARRAY_SIZE(pcc_tbl[id]), v & 7);\n\t}\n\n\treturn intval;\n}\n\n \nstatic int get_const_charge_voltage(struct smb347_charger *smb)\n{\n\tint ret, intval;\n\tunsigned int v;\n\n\tif (!smb347_is_ps_online(smb))\n\t\treturn -ENODATA;\n\n\tret = regmap_read(smb->regmap, STAT_A, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv &= STAT_A_FLOAT_VOLTAGE_MASK;\n\tif (v > 0x3d)\n\t\tv = 0x3d;\n\n\tintval = 3500000 + v * 20000;\n\n\treturn intval;\n}\n\nstatic int smb347_get_charging_status(struct smb347_charger *smb,\n\t\t\t\t      struct power_supply *psy)\n{\n\tint ret, status;\n\tunsigned int val;\n\n\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB) {\n\t\tif (!smb->usb_online)\n\t\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\t} else {\n\t\tif (!smb->mains_online)\n\t\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\n\tret = regmap_read(smb->regmap, STAT_C, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & STAT_C_CHARGER_ERROR) ||\n\t\t\t(val & STAT_C_HOLDOFF_STAT)) {\n\t\t \n\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t} else {\n\t\tif ((val & STAT_C_CHG_MASK) >> STAT_C_CHG_SHIFT) {\n\t\t\t \n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t} else if (val & STAT_C_CHG_TERM) {\n\t\t\t \n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t} else {\n\t\t\t \n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int smb347_get_property_locked(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property prop,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct smb347_charger *smb = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = smb347_get_charging_status(smb, psy);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB) {\n\t\t\tif (!smb->usb_online)\n\t\t\t\treturn -ENODATA;\n\t\t} else {\n\t\t\tif (!smb->mains_online)\n\t\t\t\treturn -ENODATA;\n\t\t}\n\n\t\t \n\t\tswitch (smb347_charging_status(smb)) {\n\t\tcase 1:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\n\t\t\tval->intval = smb->usb_online;\n\t\telse\n\t\t\tval->intval = smb->mains_online;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = get_const_charge_voltage(smb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = get_const_charge_current(smb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval->intval = ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb347_get_property(struct power_supply *psy,\n\t\t\t       enum power_supply_property prop,\n\t\t\t       union power_supply_propval *val)\n{\n\tstruct smb347_charger *smb = power_supply_get_drvdata(psy);\n\tstruct i2c_client *client = to_i2c_client(smb->dev);\n\tint ret;\n\n\tif (!smb->irq_unsupported)\n\t\tdisable_irq(client->irq);\n\n\tret = smb347_get_property_locked(psy, prop, val);\n\n\tif (!smb->irq_unsupported)\n\t\tenable_irq(client->irq);\n\n\treturn ret;\n}\n\nstatic enum power_supply_property smb347_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n};\n\nstatic bool smb347_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase IRQSTAT_A:\n\tcase IRQSTAT_C:\n\tcase IRQSTAT_D:\n\tcase IRQSTAT_E:\n\tcase IRQSTAT_F:\n\tcase STAT_A:\n\tcase STAT_B:\n\tcase STAT_C:\n\tcase STAT_E:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool smb347_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CFG_CHARGE_CURRENT:\n\tcase CFG_CURRENT_LIMIT:\n\tcase CFG_FLOAT_VOLTAGE:\n\tcase CFG_STAT:\n\tcase CFG_PIN:\n\tcase CFG_THERM:\n\tcase CFG_SYSOK:\n\tcase CFG_OTHER:\n\tcase CFG_OTG:\n\tcase CFG_TEMP_LIMIT:\n\tcase CFG_FAULT_IRQ:\n\tcase CFG_STATUS_IRQ:\n\tcase CFG_ADDRESS:\n\tcase CMD_A:\n\tcase CMD_B:\n\tcase CMD_C:\n\t\treturn true;\n\t}\n\n\treturn smb347_volatile_reg(dev, reg);\n}\n\nstatic void smb347_dt_parse_dev_info(struct smb347_charger *smb)\n{\n\tstruct device *dev = smb->dev;\n\n\tsmb->soft_temp_limit_compensation =\n\t\t\t\t\tSMB3XX_SOFT_TEMP_COMPENSATE_DEFAULT;\n\t \n\tsmb->soft_cold_temp_limit = SMB3XX_TEMP_USE_DEFAULT;\n\tsmb->hard_cold_temp_limit = SMB3XX_TEMP_USE_DEFAULT;\n\tsmb->soft_hot_temp_limit  = SMB3XX_TEMP_USE_DEFAULT;\n\tsmb->hard_hot_temp_limit  = SMB3XX_TEMP_USE_DEFAULT;\n\n\t \n\tdevice_property_read_u32(dev, \"summit,fast-voltage-threshold-microvolt\",\n\t\t\t\t &smb->pre_to_fast_voltage);\n\tdevice_property_read_u32(dev, \"summit,mains-current-limit-microamp\",\n\t\t\t\t &smb->mains_current_limit);\n\tdevice_property_read_u32(dev, \"summit,usb-current-limit-microamp\",\n\t\t\t\t &smb->usb_hc_current_limit);\n\n\t \n\tdevice_property_read_u32(dev, \"summit,chip-temperature-threshold-celsius\",\n\t\t\t\t &smb->chip_temp_threshold);\n\tdevice_property_read_u32(dev, \"summit,soft-compensation-method\",\n\t\t\t\t &smb->soft_temp_limit_compensation);\n\tdevice_property_read_u32(dev, \"summit,charge-current-compensation-microamp\",\n\t\t\t\t &smb->charge_current_compensation);\n\n\t \n\tsmb->use_mains = device_property_read_bool(dev, \"summit,enable-mains-charging\");\n\tsmb->use_usb = device_property_read_bool(dev, \"summit,enable-usb-charging\");\n\tsmb->use_usb_otg = device_property_read_bool(dev, \"summit,enable-otg-charging\");\n\n\t \n\tdevice_property_read_u32(dev, \"summit,enable-charge-control\",\n\t\t\t\t &smb->enable_control);\n\n\t \n\tdevice_property_read_u32(dev, \"summit,inok-polarity\",\n\t\t\t\t &smb->inok_polarity);\n}\n\nstatic int smb347_get_battery_info(struct smb347_charger *smb)\n{\n\tstruct power_supply_battery_info *info;\n\tstruct power_supply *supply;\n\tint err;\n\n\tif (smb->mains)\n\t\tsupply = smb->mains;\n\telse\n\t\tsupply = smb->usb;\n\n\terr = power_supply_get_battery_info(supply, &info);\n\tif (err == -ENXIO || err == -ENODEV)\n\t\treturn 0;\n\tif (err)\n\t\treturn err;\n\n\tif (info->constant_charge_current_max_ua != -EINVAL)\n\t\tsmb->max_charge_current = info->constant_charge_current_max_ua;\n\n\tif (info->constant_charge_voltage_max_uv != -EINVAL)\n\t\tsmb->max_charge_voltage = info->constant_charge_voltage_max_uv;\n\n\tif (info->precharge_current_ua != -EINVAL)\n\t\tsmb->pre_charge_current = info->precharge_current_ua;\n\n\tif (info->charge_term_current_ua != -EINVAL)\n\t\tsmb->termination_current = info->charge_term_current_ua;\n\n\tif (info->temp_alert_min != INT_MIN)\n\t\tsmb->soft_cold_temp_limit = info->temp_alert_min;\n\n\tif (info->temp_alert_max != INT_MAX)\n\t\tsmb->soft_hot_temp_limit = info->temp_alert_max;\n\n\tif (info->temp_min != INT_MIN)\n\t\tsmb->hard_cold_temp_limit = info->temp_min;\n\n\tif (info->temp_max != INT_MAX)\n\t\tsmb->hard_hot_temp_limit = info->temp_max;\n\n\t \n\tif (smb->hard_cold_temp_limit != SMB3XX_TEMP_USE_DEFAULT ||\n\t    smb->hard_hot_temp_limit != SMB3XX_TEMP_USE_DEFAULT)\n\t\tsmb->suspend_on_hard_temp_limit = true;\n\n\treturn 0;\n}\n\nstatic int smb347_usb_vbus_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct smb347_charger *smb = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(smb->regmap, CFG_OTG, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!(val & CFG_OTG_CURRENT_LIMIT_250mA))\n\t\treturn 0;\n\n\treturn val & CFG_OTG_CURRENT_LIMIT_750mA ? 750000 : 250000;\n}\n\nstatic int smb347_usb_vbus_set_new_current_limit(struct smb347_charger *smb,\n\t\t\t\t\t\t int max_uA)\n{\n\tconst unsigned int mask = CFG_OTG_CURRENT_LIMIT_750mA |\n\t\t\t\t  CFG_OTG_CURRENT_LIMIT_250mA;\n\tunsigned int val = CFG_OTG_CURRENT_LIMIT_250mA;\n\tint ret;\n\n\tif (max_uA >= 750000)\n\t\tval |= CFG_OTG_CURRENT_LIMIT_750mA;\n\n\tret = regmap_update_bits(smb->regmap, CFG_OTG, mask, val);\n\tif (ret < 0)\n\t\tdev_err(smb->dev, \"failed to change USB current limit\\n\");\n\n\treturn ret;\n}\n\nstatic int smb347_usb_vbus_set_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\t     int min_uA, int max_uA)\n{\n\tstruct smb347_charger *smb = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = smb347_set_writable(smb, true, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smb347_usb_vbus_set_new_current_limit(smb, max_uA);\n\tsmb347_set_writable(smb, false, true);\n\n\treturn ret;\n}\n\nstatic int smb347_usb_vbus_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct smb347_charger *smb = rdev_get_drvdata(rdev);\n\tint ret, max_uA;\n\n\tret = smb347_set_writable(smb, true, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsmb347_charging_disable(smb);\n\n\tif (device_property_read_bool(&rdev->dev, \"summit,needs-inok-toggle\")) {\n\t\tunsigned int sysok = 0;\n\n\t\tif (smb->inok_polarity == SMB3XX_SYSOK_INOK_ACTIVE_LOW)\n\t\t\tsysok = CFG_SYSOK_INOK_ACTIVE_HIGH;\n\n\t\t \n\t\tret = regmap_update_bits(smb->regmap, CFG_SYSOK,\n\t\t\t\t\t CFG_SYSOK_INOK_ACTIVE_HIGH, sysok);\n\t\tif (ret < 0) {\n\t\t\tdev_err(smb->dev, \"failed to disable INOK\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = smb347_usb_vbus_get_current_limit(rdev);\n\tif (ret < 0) {\n\t\tdev_err(smb->dev, \"failed to get USB VBUS current limit\\n\");\n\t\tgoto done;\n\t}\n\n\tmax_uA = ret;\n\n\tret = smb347_usb_vbus_set_new_current_limit(smb, 250000);\n\tif (ret < 0) {\n\t\tdev_err(smb->dev, \"failed to preset USB VBUS current limit\\n\");\n\t\tgoto done;\n\t}\n\n\tret = regmap_set_bits(smb->regmap, CMD_A, CMD_A_OTG_ENABLED);\n\tif (ret < 0) {\n\t\tdev_err(smb->dev, \"failed to enable USB VBUS\\n\");\n\t\tgoto done;\n\t}\n\n\tsmb->usb_vbus_enabled = true;\n\n\tret = smb347_usb_vbus_set_new_current_limit(smb, max_uA);\n\tif (ret < 0) {\n\t\tdev_err(smb->dev, \"failed to restore USB VBUS current limit\\n\");\n\t\tgoto done;\n\t}\ndone:\n\tsmb347_set_writable(smb, false, true);\n\n\treturn ret;\n}\n\nstatic int smb347_usb_vbus_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct smb347_charger *smb = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = smb347_set_writable(smb, true, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(smb->regmap, CMD_A, CMD_A_OTG_ENABLED);\n\tif (ret < 0) {\n\t\tdev_err(smb->dev, \"failed to disable USB VBUS\\n\");\n\t\tgoto done;\n\t}\n\n\tsmb->usb_vbus_enabled = false;\n\n\tif (device_property_read_bool(&rdev->dev, \"summit,needs-inok-toggle\")) {\n\t\tunsigned int sysok = 0;\n\n\t\tif (smb->inok_polarity == SMB3XX_SYSOK_INOK_ACTIVE_HIGH)\n\t\t\tsysok = CFG_SYSOK_INOK_ACTIVE_HIGH;\n\n\t\tret = regmap_update_bits(smb->regmap, CFG_SYSOK,\n\t\t\t\t\t CFG_SYSOK_INOK_ACTIVE_HIGH, sysok);\n\t\tif (ret < 0) {\n\t\t\tdev_err(smb->dev, \"failed to enable INOK\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tsmb347_start_stop_charging(smb);\ndone:\n\tsmb347_set_writable(smb, false, true);\n\n\treturn ret;\n}\n\nstatic const struct regmap_config smb347_regmap = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= SMB347_MAX_REGISTER,\n\t.volatile_reg\t= smb347_volatile_reg,\n\t.readable_reg\t= smb347_readable_reg,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic const struct regulator_ops smb347_usb_vbus_regulator_ops = {\n\t.is_enabled\t= regulator_is_enabled_regmap,\n\t.enable\t\t= smb347_usb_vbus_regulator_enable,\n\t.disable\t= smb347_usb_vbus_regulator_disable,\n\t.get_current_limit = smb347_usb_vbus_get_current_limit,\n\t.set_current_limit = smb347_usb_vbus_set_current_limit,\n};\n\nstatic const struct power_supply_desc smb347_mains_desc = {\n\t.name\t\t= \"smb347-mains\",\n\t.type\t\t= POWER_SUPPLY_TYPE_MAINS,\n\t.get_property\t= smb347_get_property,\n\t.properties\t= smb347_properties,\n\t.num_properties\t= ARRAY_SIZE(smb347_properties),\n};\n\nstatic const struct power_supply_desc smb347_usb_desc = {\n\t.name\t\t= \"smb347-usb\",\n\t.type\t\t= POWER_SUPPLY_TYPE_USB,\n\t.get_property\t= smb347_get_property,\n\t.properties\t= smb347_properties,\n\t.num_properties\t= ARRAY_SIZE(smb347_properties),\n};\n\nstatic const struct regulator_desc smb347_usb_vbus_regulator_desc = {\n\t.name\t\t= \"smb347-usb-vbus\",\n\t.of_match\t= of_match_ptr(\"usb-vbus\"),\n\t.ops\t\t= &smb347_usb_vbus_regulator_ops,\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.owner\t\t= THIS_MODULE,\n\t.enable_reg\t= CMD_A,\n\t.enable_mask\t= CMD_A_OTG_ENABLED,\n\t.enable_val\t= CMD_A_OTG_ENABLED,\n\t.fixed_uV\t= 5000000,\n\t.n_voltages\t= 1,\n};\n\nstatic int smb347_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct power_supply_config mains_usb_cfg = {};\n\tstruct regulator_config usb_rdev_cfg = {};\n\tstruct device *dev = &client->dev;\n\tstruct smb347_charger *smb;\n\tint ret;\n\n\tsmb = devm_kzalloc(dev, sizeof(*smb), GFP_KERNEL);\n\tif (!smb)\n\t\treturn -ENOMEM;\n\tsmb->dev = &client->dev;\n\tsmb->id = id->driver_data;\n\ti2c_set_clientdata(client, smb);\n\n\tsmb347_dt_parse_dev_info(smb);\n\tif (!smb->use_mains && !smb->use_usb)\n\t\treturn -EINVAL;\n\n\tsmb->regmap = devm_regmap_init_i2c(client, &smb347_regmap);\n\tif (IS_ERR(smb->regmap))\n\t\treturn PTR_ERR(smb->regmap);\n\n\tmains_usb_cfg.drv_data = smb;\n\tmains_usb_cfg.of_node = dev->of_node;\n\tif (smb->use_mains) {\n\t\tsmb->mains = devm_power_supply_register(dev, &smb347_mains_desc,\n\t\t\t\t\t\t\t&mains_usb_cfg);\n\t\tif (IS_ERR(smb->mains))\n\t\t\treturn PTR_ERR(smb->mains);\n\t}\n\n\tif (smb->use_usb) {\n\t\tsmb->usb = devm_power_supply_register(dev, &smb347_usb_desc,\n\t\t\t\t\t\t      &mains_usb_cfg);\n\t\tif (IS_ERR(smb->usb))\n\t\t\treturn PTR_ERR(smb->usb);\n\t}\n\n\tret = smb347_get_battery_info(smb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smb347_hw_init(smb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smb347_irq_init(smb, client);\n\tif (ret)\n\t\treturn ret;\n\n\tusb_rdev_cfg.dev = dev;\n\tusb_rdev_cfg.driver_data = smb;\n\tusb_rdev_cfg.regmap = smb->regmap;\n\n\tsmb->usb_rdev = devm_regulator_register(dev,\n\t\t\t\t\t\t&smb347_usb_vbus_regulator_desc,\n\t\t\t\t\t\t&usb_rdev_cfg);\n\tif (IS_ERR(smb->usb_rdev)) {\n\t\tsmb347_irq_disable(smb);\n\t\treturn PTR_ERR(smb->usb_rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic void smb347_remove(struct i2c_client *client)\n{\n\tstruct smb347_charger *smb = i2c_get_clientdata(client);\n\n\tsmb347_usb_vbus_regulator_disable(smb->usb_rdev);\n\tsmb347_irq_disable(smb);\n}\n\nstatic void smb347_shutdown(struct i2c_client *client)\n{\n\tsmb347_remove(client);\n}\n\nstatic const struct i2c_device_id smb347_id[] = {\n\t{ \"smb345\", SMB345 },\n\t{ \"smb347\", SMB347 },\n\t{ \"smb358\", SMB358 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, smb347_id);\n\nstatic const struct of_device_id smb3xx_of_match[] = {\n\t{ .compatible = \"summit,smb345\" },\n\t{ .compatible = \"summit,smb347\" },\n\t{ .compatible = \"summit,smb358\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, smb3xx_of_match);\n\nstatic struct i2c_driver smb347_driver = {\n\t.driver = {\n\t\t.name = \"smb347\",\n\t\t.of_match_table = smb3xx_of_match,\n\t},\n\t.probe = smb347_probe,\n\t.remove = smb347_remove,\n\t.shutdown = smb347_shutdown,\n\t.id_table = smb347_id,\n};\nmodule_i2c_driver(smb347_driver);\n\nMODULE_AUTHOR(\"Bruce E. Robertson <bruce.e.robertson@intel.com>\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_DESCRIPTION(\"SMB347 battery charger driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}