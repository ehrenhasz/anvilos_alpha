{
  "module_name": "da9150-fg.c",
  "hash_id": "0052dea702ba47c561cb72c7b09ea8d9ae96b16f254a808b9aaa042e0841782d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/supply/da9150-fg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/power_supply.h>\n#include <linux/list.h>\n#include <asm/div64.h>\n#include <linux/mfd/da9150/core.h>\n#include <linux/mfd/da9150/registers.h>\n#include <linux/devm-helpers.h>\n\n \n#define DA9150_QIF_READ\t\t(0x0 << 7)\n#define DA9150_QIF_WRITE\t(0x1 << 7)\n#define DA9150_QIF_CODE_MASK\t0x7F\n\n#define DA9150_QIF_BYTE_SIZE\t8\n#define DA9150_QIF_BYTE_MASK\t0xFF\n#define DA9150_QIF_SHORT_SIZE\t2\n#define DA9150_QIF_LONG_SIZE\t4\n\n \n#define DA9150_QIF_UAVG\t\t\t6\n#define DA9150_QIF_UAVG_SIZE\t\tDA9150_QIF_LONG_SIZE\n#define DA9150_QIF_IAVG\t\t\t8\n#define DA9150_QIF_IAVG_SIZE\t\tDA9150_QIF_LONG_SIZE\n#define DA9150_QIF_NTCAVG\t\t12\n#define DA9150_QIF_NTCAVG_SIZE\t\tDA9150_QIF_LONG_SIZE\n#define DA9150_QIF_SHUNT_VAL\t\t36\n#define DA9150_QIF_SHUNT_VAL_SIZE\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_SD_GAIN\t\t38\n#define DA9150_QIF_SD_GAIN_SIZE\t\tDA9150_QIF_LONG_SIZE\n#define DA9150_QIF_FCC_MAH\t\t40\n#define DA9150_QIF_FCC_MAH_SIZE\t\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_SOC_PCT\t\t43\n#define DA9150_QIF_SOC_PCT_SIZE\t\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_CHARGE_LIMIT\t\t44\n#define DA9150_QIF_CHARGE_LIMIT_SIZE\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_DISCHARGE_LIMIT\t45\n#define DA9150_QIF_DISCHARGE_LIMIT_SIZE\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_FW_MAIN_VER\t\t118\n#define DA9150_QIF_FW_MAIN_VER_SIZE\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_E_FG_STATUS\t\t126\n#define DA9150_QIF_E_FG_STATUS_SIZE\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_SYNC\t\t\t127\n#define DA9150_QIF_SYNC_SIZE\t\tDA9150_QIF_SHORT_SIZE\n#define DA9150_QIF_MAX_CODES\t\t128\n\n \n#define DA9150_QIF_SYNC_TIMEOUT\t\t1000\n#define DA9150_QIF_SYNC_RETRIES\t\t10\n\n \n#define DA9150_FG_IRQ_LOW_SOC_MASK\t(1 << 0)\n#define DA9150_FG_IRQ_HIGH_SOC_MASK\t(1 << 1)\n#define DA9150_FG_IRQ_SOC_MASK\t\\\n\t(DA9150_FG_IRQ_LOW_SOC_MASK | DA9150_FG_IRQ_HIGH_SOC_MASK)\n\n \nstruct da9150_fg {\n\tstruct da9150 *da9150;\n\tstruct device *dev;\n\n\tstruct mutex io_lock;\n\n\tstruct power_supply *battery;\n\tstruct delayed_work work;\n\tu32 interval;\n\n\tint warn_soc;\n\tint crit_soc;\n\tint soc;\n};\n\n \nstatic u32 da9150_fg_read_attr(struct da9150_fg *fg, u8 code, u8 size)\n\n{\n\tu8 buf[DA9150_QIF_LONG_SIZE];\n\tu8 read_addr;\n\tu32 res = 0;\n\tint i;\n\n\t \n\tread_addr = (code & DA9150_QIF_CODE_MASK) | DA9150_QIF_READ;\n\n\tda9150_read_qif(fg->da9150, read_addr, size, buf);\n\tfor (i = 0; i < size; ++i)\n\t\tres |= (buf[i] << (i * DA9150_QIF_BYTE_SIZE));\n\n\treturn res;\n}\n\nstatic void da9150_fg_write_attr(struct da9150_fg *fg, u8 code, u8 size,\n\t\t\t\t u32 val)\n\n{\n\tu8 buf[DA9150_QIF_LONG_SIZE];\n\tu8 write_addr;\n\tint i;\n\n\t \n\twrite_addr = (code & DA9150_QIF_CODE_MASK) | DA9150_QIF_WRITE;\n\n\tfor (i = 0; i < size; ++i) {\n\t\tbuf[i] = (val >> (i * DA9150_QIF_BYTE_SIZE)) &\n\t\t\t DA9150_QIF_BYTE_MASK;\n\t}\n\tda9150_write_qif(fg->da9150, write_addr, size, buf);\n}\n\n \nstatic void da9150_fg_read_sync_start(struct da9150_fg *fg)\n{\n\tint i = 0;\n\tu32 res = 0;\n\n\tmutex_lock(&fg->io_lock);\n\n\t \n\tres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t  DA9150_QIF_SYNC_SIZE);\n\tif (res > 0)\n\t\tda9150_fg_write_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t     DA9150_QIF_SYNC_SIZE, 0);\n\n\t \n\tres = 0;\n\twhile ((res == 0) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\n\t\tusleep_range(DA9150_QIF_SYNC_TIMEOUT,\n\t\t\t     DA9150_QIF_SYNC_TIMEOUT * 2);\n\t\tres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t\t  DA9150_QIF_SYNC_SIZE);\n\t}\n\n\t \n\tif (res == 0)\n\t\tdev_err(fg->dev, \"Failed to perform QIF read sync!\\n\");\n}\n\n \nstatic inline void da9150_fg_read_sync_end(struct da9150_fg *fg)\n{\n\tmutex_unlock(&fg->io_lock);\n}\n\n \nstatic u32 da9150_fg_read_attr_sync(struct da9150_fg *fg, u8 code, u8 size)\n{\n\tu32 val;\n\n\tda9150_fg_read_sync_start(fg);\n\tval = da9150_fg_read_attr(fg, code, size);\n\tda9150_fg_read_sync_end(fg);\n\n\treturn val;\n}\n\n \nstatic void da9150_fg_write_attr_sync(struct da9150_fg *fg, u8 code, u8 size,\n\t\t\t\t      u32 val)\n{\n\tint i = 0;\n\tu32 res = 0, sync_val;\n\n\tmutex_lock(&fg->io_lock);\n\n\t \n\tres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t  DA9150_QIF_SYNC_SIZE);\n\n\t \n\twhile ((res == 0) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\n\t\tusleep_range(DA9150_QIF_SYNC_TIMEOUT,\n\t\t\t     DA9150_QIF_SYNC_TIMEOUT * 2);\n\t\tres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t\t  DA9150_QIF_SYNC_SIZE);\n\t}\n\n\tif (res == 0) {\n\t\tdev_err(fg->dev, \"Timeout waiting for existing QIF sync!\\n\");\n\t\tmutex_unlock(&fg->io_lock);\n\t\treturn;\n\t}\n\n\t \n\tda9150_fg_write_attr(fg, code, size, val);\n\n\t \n\ti = 0;\n\tsync_val = res;\n\twhile ((res == sync_val) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\n\t\tusleep_range(DA9150_QIF_SYNC_TIMEOUT,\n\t\t\t     DA9150_QIF_SYNC_TIMEOUT * 2);\n\t\tres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\n\t\t\t\t\t  DA9150_QIF_SYNC_SIZE);\n\t}\n\n\tmutex_unlock(&fg->io_lock);\n\n\t \n\tif (res != (sync_val + 1))\n\t\tdev_err(fg->dev, \"Error performing QIF sync write for code %d\\n\",\n\t\t\tcode);\n}\n\n \nstatic int da9150_fg_capacity(struct da9150_fg *fg,\n\t\t\t      union power_supply_propval *val)\n{\n\tval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_SOC_PCT,\n\t\t\t\t\t       DA9150_QIF_SOC_PCT_SIZE);\n\n\tif (val->intval > 100)\n\t\tval->intval = 100;\n\n\treturn 0;\n}\n\nstatic int da9150_fg_current_avg(struct da9150_fg *fg,\n\t\t\t\t union power_supply_propval *val)\n{\n\tu32 iavg, sd_gain, shunt_val;\n\tu64 div, res;\n\n\tda9150_fg_read_sync_start(fg);\n\tiavg = da9150_fg_read_attr(fg, DA9150_QIF_IAVG,\n\t\t\t\t   DA9150_QIF_IAVG_SIZE);\n\tshunt_val = da9150_fg_read_attr(fg, DA9150_QIF_SHUNT_VAL,\n\t\t\t\t\tDA9150_QIF_SHUNT_VAL_SIZE);\n\tsd_gain = da9150_fg_read_attr(fg, DA9150_QIF_SD_GAIN,\n\t\t\t\t      DA9150_QIF_SD_GAIN_SIZE);\n\tda9150_fg_read_sync_end(fg);\n\n\tdiv = (u64) (sd_gain * shunt_val * 65536ULL);\n\tdo_div(div, 1000000);\n\tres = (u64) (iavg * 1000000ULL);\n\tdo_div(res, div);\n\n\tval->intval = (int) res;\n\n\treturn 0;\n}\n\nstatic int da9150_fg_voltage_avg(struct da9150_fg *fg,\n\t\t\t\t union power_supply_propval *val)\n{\n\tu64 res;\n\n\tval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_UAVG,\n\t\t\t\t\t       DA9150_QIF_UAVG_SIZE);\n\n\tres = (u64) (val->intval * 186ULL);\n\tdo_div(res, 10000);\n\tval->intval = (int) res;\n\n\treturn 0;\n}\n\nstatic int da9150_fg_charge_full(struct da9150_fg *fg,\n\t\t\t\t union power_supply_propval *val)\n{\n\tval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_FCC_MAH,\n\t\t\t\t\t       DA9150_QIF_FCC_MAH_SIZE);\n\n\tval->intval = val->intval * 1000;\n\n\treturn 0;\n}\n\n \nstatic int da9150_fg_temp(struct da9150_fg *fg,\n\t\t\t  union power_supply_propval *val)\n{\n\tval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_NTCAVG,\n\t\t\t\t\t       DA9150_QIF_NTCAVG_SIZE);\n\n\tval->intval = (val->intval * 10) / 1048576;\n\n\treturn 0;\n}\n\nstatic enum power_supply_property da9150_fg_props[] = {\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL,\n\tPOWER_SUPPLY_PROP_TEMP,\n};\n\nstatic int da9150_fg_get_prop(struct power_supply *psy,\n\t\t\t      enum power_supply_property psp,\n\t\t\t      union power_supply_propval *val)\n{\n\tstruct da9150_fg *fg = dev_get_drvdata(psy->dev.parent);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tret = da9150_fg_capacity(fg, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tret = da9150_fg_current_avg(fg, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tret = da9150_fg_voltage_avg(fg, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL:\n\t\tret = da9150_fg_charge_full(fg, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tret = da9150_fg_temp(fg, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool da9150_fg_soc_changed(struct da9150_fg *fg)\n{\n\tunion power_supply_propval val;\n\n\tda9150_fg_capacity(fg, &val);\n\tif (val.intval != fg->soc) {\n\t\tfg->soc = val.intval;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void da9150_fg_work(struct work_struct *work)\n{\n\tstruct da9150_fg *fg = container_of(work, struct da9150_fg, work.work);\n\n\t \n\tif (da9150_fg_soc_changed(fg))\n\t\tpower_supply_changed(fg->battery);\n\n\tschedule_delayed_work(&fg->work, msecs_to_jiffies(fg->interval));\n}\n\n \nstatic void da9150_fg_soc_event_config(struct da9150_fg *fg)\n{\n\tint soc;\n\n\tsoc = da9150_fg_read_attr_sync(fg, DA9150_QIF_SOC_PCT,\n\t\t\t\t       DA9150_QIF_SOC_PCT_SIZE);\n\n\tif (soc > fg->warn_soc) {\n\t\t \n\t\tda9150_fg_write_attr_sync(fg, DA9150_QIF_DISCHARGE_LIMIT,\n\t\t\t\t\t  DA9150_QIF_DISCHARGE_LIMIT_SIZE,\n\t\t\t\t\t  fg->warn_soc + 1);\n\t} else if ((soc <= fg->warn_soc) && (soc > fg->crit_soc)) {\n\t\t \n\t\tda9150_fg_write_attr_sync(fg, DA9150_QIF_DISCHARGE_LIMIT,\n\t\t\t\t\t  DA9150_QIF_DISCHARGE_LIMIT_SIZE,\n\t\t\t\t\t  fg->crit_soc + 1);\n\n\t\tda9150_fg_write_attr_sync(fg, DA9150_QIF_CHARGE_LIMIT,\n\t\t\t\t\t  DA9150_QIF_CHARGE_LIMIT_SIZE,\n\t\t\t\t\t  fg->warn_soc);\n\t} else if (soc <= fg->crit_soc) {\n\t\t \n\t\tda9150_fg_write_attr_sync(fg, DA9150_QIF_CHARGE_LIMIT,\n\t\t\t\t\t  DA9150_QIF_CHARGE_LIMIT_SIZE,\n\t\t\t\t\t  fg->crit_soc);\n\t}\n}\n\nstatic irqreturn_t da9150_fg_irq(int irq, void *data)\n{\n\tstruct da9150_fg *fg = data;\n\tu32 e_fg_status;\n\n\t \n\te_fg_status = da9150_fg_read_attr(fg, DA9150_QIF_E_FG_STATUS,\n\t\t\t\t\t  DA9150_QIF_E_FG_STATUS_SIZE);\n\n\t \n\tif (e_fg_status & DA9150_FG_IRQ_SOC_MASK)\n\t\tda9150_fg_soc_event_config(fg);\n\n\t \n\tda9150_fg_write_attr(fg, DA9150_QIF_E_FG_STATUS,\n\t\t\t     DA9150_QIF_E_FG_STATUS_SIZE, e_fg_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct da9150_fg_pdata *da9150_fg_dt_pdata(struct device *dev)\n{\n\tstruct device_node *fg_node = dev->of_node;\n\tstruct da9150_fg_pdata *pdata;\n\n\tpdata = devm_kzalloc(dev, sizeof(struct da9150_fg_pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tof_property_read_u32(fg_node, \"dlg,update-interval\",\n\t\t\t     &pdata->update_interval);\n\tof_property_read_u8(fg_node, \"dlg,warn-soc-level\",\n\t\t\t    &pdata->warn_soc_lvl);\n\tof_property_read_u8(fg_node, \"dlg,crit-soc-level\",\n\t\t\t    &pdata->crit_soc_lvl);\n\n\treturn pdata;\n}\n\nstatic const struct power_supply_desc fg_desc = {\n\t.name\t\t= \"da9150-fg\",\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= da9150_fg_props,\n\t.num_properties\t= ARRAY_SIZE(da9150_fg_props),\n\t.get_property\t= da9150_fg_get_prop,\n};\n\nstatic int da9150_fg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9150 *da9150 = dev_get_drvdata(dev->parent);\n\tstruct da9150_fg_pdata *fg_pdata = dev_get_platdata(dev);\n\tstruct da9150_fg *fg;\n\tint ver, irq, ret = 0;\n\n\tfg = devm_kzalloc(dev, sizeof(*fg), GFP_KERNEL);\n\tif (fg == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, fg);\n\tfg->da9150 = da9150;\n\tfg->dev = dev;\n\n\tmutex_init(&fg->io_lock);\n\n\t \n\tda9150_set_bits(da9150, DA9150_CORE2WIRE_CTRL_A, DA9150_FG_QIF_EN_MASK,\n\t\t\tDA9150_FG_QIF_EN_MASK);\n\n\tfg->battery = devm_power_supply_register(dev, &fg_desc, NULL);\n\tif (IS_ERR(fg->battery)) {\n\t\tret = PTR_ERR(fg->battery);\n\t\treturn ret;\n\t}\n\n\tver = da9150_fg_read_attr(fg, DA9150_QIF_FW_MAIN_VER,\n\t\t\t\t  DA9150_QIF_FW_MAIN_VER_SIZE);\n\tdev_info(dev, \"Version: 0x%x\\n\", ver);\n\n\t \n\tif (dev->of_node) {\n\t\tfg_pdata = da9150_fg_dt_pdata(dev);\n\t\tdev->platform_data = fg_pdata;\n\t}\n\n\t \n\tif (fg_pdata) {\n\t\tfg->interval = fg_pdata->update_interval;\n\n\t\tif (fg_pdata->warn_soc_lvl > 100)\n\t\t\tdev_warn(dev, \"Invalid SOC warning level provided, Ignoring\");\n\t\telse\n\t\t\tfg->warn_soc = fg_pdata->warn_soc_lvl;\n\n\t\tif ((fg_pdata->crit_soc_lvl > 100) ||\n\t\t    (fg_pdata->crit_soc_lvl >= fg_pdata->warn_soc_lvl))\n\t\t\tdev_warn(dev, \"Invalid SOC critical level provided, Ignoring\");\n\t\telse\n\t\t\tfg->crit_soc = fg_pdata->crit_soc_lvl;\n\n\n\t}\n\n\t \n\tda9150_fg_soc_event_config(fg);\n\n\t \n\tif (fg->interval) {\n\t\tret = devm_delayed_work_autocancel(dev, &fg->work,\n\t\t\t\t\t\t   da9150_fg_work);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init work\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tschedule_delayed_work(&fg->work,\n\t\t\t\t      msecs_to_jiffies(fg->interval));\n\t}\n\n\t \n\tirq = platform_get_irq_byname(pdev, \"FG\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, da9150_fg_irq,\n\t\t\t\t\tIRQF_ONESHOT, \"FG\", fg);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int da9150_fg_resume(struct platform_device *pdev)\n{\n\tstruct da9150_fg *fg = platform_get_drvdata(pdev);\n\n\t \n\tif (fg->interval)\n\t\tflush_delayed_work(&fg->work);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9150_fg_driver = {\n\t.driver = {\n\t\t.name = \"da9150-fuel-gauge\",\n\t},\n\t.probe = da9150_fg_probe,\n\t.resume = da9150_fg_resume,\n};\n\nmodule_platform_driver(da9150_fg_driver);\n\nMODULE_DESCRIPTION(\"Fuel-Gauge Driver for DA9150\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}