{
  "module_name": "at91-poweroff.c",
  "hash_id": "110f705a54bc1dcc3228945f755066aeac2fd58b7e9550fea82583bab0c45fc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/at91-poweroff.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n\n#include <soc/at91/at91sam9_ddrsdr.h>\n\n#define AT91_SHDW_CR\t0x00\t\t \n#define AT91_SHDW_SHDW\t\tBIT(0)\t\t\t \n#define AT91_SHDW_KEY\t\t(0xa5 << 24)\t\t \n\n#define AT91_SHDW_MR\t0x04\t\t \n#define AT91_SHDW_WKMODE0\tGENMASK(2, 0)\t\t \n#define AT91_SHDW_CPTWK0_MAX\t0xf\t\t\t \n#define AT91_SHDW_CPTWK0\t(AT91_SHDW_CPTWK0_MAX << 4)  \n#define AT91_SHDW_CPTWK0_(x)\t((x) << 4)\n#define AT91_SHDW_RTTWKEN\tBIT(16)\t\t\t \n#define AT91_SHDW_RTCWKEN\tBIT(17)\t\t\t \n\n#define AT91_SHDW_SR\t0x08\t\t \n#define AT91_SHDW_WAKEUP0\tBIT(0)\t\t\t \n#define AT91_SHDW_RTTWK\t\tBIT(16)\t\t\t \n#define AT91_SHDW_RTCWK\t\tBIT(17)\t\t\t \n\nenum wakeup_type {\n\tAT91_SHDW_WKMODE0_NONE\t\t= 0,\n\tAT91_SHDW_WKMODE0_HIGH\t\t= 1,\n\tAT91_SHDW_WKMODE0_LOW\t\t= 2,\n\tAT91_SHDW_WKMODE0_ANYLEVEL\t= 3,\n};\n\nstatic const char *shdwc_wakeup_modes[] = {\n\t[AT91_SHDW_WKMODE0_NONE]\t= \"none\",\n\t[AT91_SHDW_WKMODE0_HIGH]\t= \"high\",\n\t[AT91_SHDW_WKMODE0_LOW]\t\t= \"low\",\n\t[AT91_SHDW_WKMODE0_ANYLEVEL]\t= \"any\",\n};\n\nstatic struct shdwc {\n\tstruct clk *sclk;\n\tvoid __iomem *shdwc_base;\n\tvoid __iomem *mpddrc_base;\n} at91_shdwc;\n\nstatic void __init at91_wakeup_status(struct platform_device *pdev)\n{\n\tconst char *reason;\n\tu32 reg = readl(at91_shdwc.shdwc_base + AT91_SHDW_SR);\n\n\t \n\tif (!reg)\n\t\treturn;\n\n\tif (reg & AT91_SHDW_RTTWK)\n\t\treason = \"RTT\";\n\telse if (reg & AT91_SHDW_RTCWK)\n\t\treason = \"RTC\";\n\telse\n\t\treason = \"unknown\";\n\n\tdev_info(&pdev->dev, \"Wake-Up source: %s\\n\", reason);\n}\n\nstatic void at91_poweroff(void)\n{\n\tasm volatile(\n\t\t \n\t\t\".balign 32\\n\\t\"\n\n\t\t \n\t\t\"\tldr\tr6, [%2, #\" __stringify(AT91_SHDW_CR) \"]\\n\\t\"\n\n\t\t \n\t\t\"\ttst\t%0, #0\\n\\t\"\n\t\t\"\tbeq\t1f\\n\\t\"\n\t\t\"\tstr\t%1, [%0, #\" __stringify(AT91_DDRSDRC_LPR) \"]\\n\\t\"\n\t\t \n\t\t\"1:\tstr\t%3, [%2, #\" __stringify(AT91_SHDW_CR) \"]\\n\\t\"\n\n\t\t\"\tb\t.\\n\\t\"\n\t\t:\n\t\t: \"r\" (at91_shdwc.mpddrc_base),\n\t\t  \"r\" cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),\n\t\t  \"r\" (at91_shdwc.shdwc_base),\n\t\t  \"r\" cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)\n\t\t: \"r6\");\n}\n\nstatic int at91_poweroff_get_wakeup_mode(struct device_node *np)\n{\n\tconst char *pm;\n\tunsigned int i;\n\tint err;\n\n\terr = of_property_read_string(np, \"atmel,wakeup-mode\", &pm);\n\tif (err < 0)\n\t\treturn AT91_SHDW_WKMODE0_ANYLEVEL;\n\n\tfor (i = 0; i < ARRAY_SIZE(shdwc_wakeup_modes); i++)\n\t\tif (!strcasecmp(pm, shdwc_wakeup_modes[i]))\n\t\t\treturn i;\n\n\treturn -ENODEV;\n}\n\nstatic void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint wakeup_mode;\n\tu32 mode = 0, tmp;\n\n\twakeup_mode = at91_poweroff_get_wakeup_mode(np);\n\tif (wakeup_mode < 0) {\n\t\tdev_warn(&pdev->dev, \"shdwc unknown wakeup mode\\n\");\n\t\treturn;\n\t}\n\n\tif (!of_property_read_u32(np, \"atmel,wakeup-counter\", &tmp)) {\n\t\tif (tmp > AT91_SHDW_CPTWK0_MAX) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"shdwc wakeup counter 0x%x > 0x%x reduce it to 0x%x\\n\",\n\t\t\t\t tmp, AT91_SHDW_CPTWK0_MAX, AT91_SHDW_CPTWK0_MAX);\n\t\t\ttmp = AT91_SHDW_CPTWK0_MAX;\n\t\t}\n\t\tmode |= AT91_SHDW_CPTWK0_(tmp);\n\t}\n\n\tif (of_property_read_bool(np, \"atmel,wakeup-rtc-timer\"))\n\t\t\tmode |= AT91_SHDW_RTCWKEN;\n\n\tif (of_property_read_bool(np, \"atmel,wakeup-rtt-timer\"))\n\t\t\tmode |= AT91_SHDW_RTTWKEN;\n\n\twritel(wakeup_mode | mode, at91_shdwc.shdwc_base + AT91_SHDW_MR);\n}\n\nstatic int __init at91_poweroff_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tu32 ddr_type;\n\tint ret;\n\n\tat91_shdwc.shdwc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(at91_shdwc.shdwc_base))\n\t\treturn PTR_ERR(at91_shdwc.shdwc_base);\n\n\tat91_shdwc.sclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(at91_shdwc.sclk))\n\t\treturn PTR_ERR(at91_shdwc.sclk);\n\n\tret = clk_prepare_enable(at91_shdwc.sclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not enable slow clock\\n\");\n\t\treturn ret;\n\t}\n\n\tat91_wakeup_status(pdev);\n\n\tif (pdev->dev.of_node)\n\t\tat91_poweroff_dt_set_wakeup_mode(pdev);\n\n\tnp = of_find_compatible_node(NULL, NULL, \"atmel,sama5d3-ddramc\");\n\tif (np) {\n\t\tat91_shdwc.mpddrc_base = of_iomap(np, 0);\n\t\tof_node_put(np);\n\n\t\tif (!at91_shdwc.mpddrc_base) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto clk_disable;\n\t\t}\n\n\t\tddr_type = readl(at91_shdwc.mpddrc_base + AT91_DDRSDRC_MDR) &\n\t\t\t\t AT91_DDRSDRC_MD;\n\t\tif (ddr_type != AT91_DDRSDRC_MD_LPDDR2 &&\n\t\t    ddr_type != AT91_DDRSDRC_MD_LPDDR3) {\n\t\t\tiounmap(at91_shdwc.mpddrc_base);\n\t\t\tat91_shdwc.mpddrc_base = NULL;\n\t\t}\n\t}\n\n\tpm_power_off = at91_poweroff;\n\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(at91_shdwc.sclk);\n\treturn ret;\n}\n\nstatic int __exit at91_poweroff_remove(struct platform_device *pdev)\n{\n\tif (pm_power_off == at91_poweroff)\n\t\tpm_power_off = NULL;\n\n\tif (at91_shdwc.mpddrc_base)\n\t\tiounmap(at91_shdwc.mpddrc_base);\n\n\tclk_disable_unprepare(at91_shdwc.sclk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id at91_poweroff_of_match[] = {\n\t{ .compatible = \"atmel,at91sam9260-shdwc\", },\n\t{ .compatible = \"atmel,at91sam9rl-shdwc\", },\n\t{ .compatible = \"atmel,at91sam9x5-shdwc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, at91_poweroff_of_match);\n\nstatic struct platform_driver at91_poweroff_driver = {\n\t.remove = __exit_p(at91_poweroff_remove),\n\t.driver = {\n\t\t.name = \"at91-poweroff\",\n\t\t.of_match_table = at91_poweroff_of_match,\n\t},\n};\nmodule_platform_driver_probe(at91_poweroff_driver, at91_poweroff_probe);\n\nMODULE_AUTHOR(\"Atmel Corporation\");\nMODULE_DESCRIPTION(\"Shutdown driver for Atmel SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}