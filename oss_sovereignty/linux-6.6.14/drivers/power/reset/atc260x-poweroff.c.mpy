{
  "module_name": "atc260x-poweroff.c",
  "hash_id": "dd9a2b75e6f13afc08dba51b46ad292b55b2e5e1790df599ee2f8bd662653abc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/atc260x-poweroff.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/mfd/atc260x/core.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\nstruct atc260x_pwrc {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct notifier_block restart_nb;\n\tint (*do_poweroff)(const struct atc260x_pwrc *pwrc, bool restart);\n};\n\n \nstatic struct atc260x_pwrc *atc260x_pwrc_data;\n\nstatic int atc2603c_do_poweroff(const struct atc260x_pwrc *pwrc, bool restart)\n{\n\tint ret, deep_sleep = 0;\n\tuint reg_mask, reg_val;\n\n\t \n\tif (!restart && !power_supply_is_system_supplied()) {\n\t\tdeep_sleep = 1;\n\t\tdev_info(pwrc->dev, \"Enabling S4-Deep Sleep Mode\");\n\t}\n\n\t \n\treg_val = ATC2603C_PMU_SYS_CTL0_ONOFF_LONG_WK_EN |\n\t\t  (restart ? ATC2603C_PMU_SYS_CTL0_RESET_WK_EN\n\t\t\t   : ATC2603C_PMU_SYS_CTL0_ONOFF_SHORT_WK_EN);\n\n\tret = regmap_update_bits(pwrc->regmap, ATC2603C_PMU_SYS_CTL0,\n\t\t\t\t ATC2603C_PMU_SYS_CTL0_WK_ALL, reg_val);\n\tif (ret)\n\t\tdev_warn(pwrc->dev, \"failed to write SYS_CTL0: %d\\n\", ret);\n\n\t \n\treg_mask = ATC2603C_PMU_SYS_CTL3_EN_S2 | ATC2603C_PMU_SYS_CTL3_EN_S3;\n\n\tret = regmap_update_bits(pwrc->regmap, ATC2603C_PMU_SYS_CTL3, reg_mask,\n\t\t\t\t deep_sleep ? 0 : ATC2603C_PMU_SYS_CTL3_EN_S3);\n\tif (ret) {\n\t\tdev_err(pwrc->dev, \"failed to write SYS_CTL3: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg_mask = restart ? ATC2603C_PMU_SYS_CTL0_RESTART_EN\n\t\t\t   : ATC2603C_PMU_SYS_CTL1_EN_S1;\n\treg_val = restart ? ATC2603C_PMU_SYS_CTL0_RESTART_EN : 0;\n\n\tret = regmap_update_bits(pwrc->regmap,\n\t\t\t\t restart ? ATC2603C_PMU_SYS_CTL0 : ATC2603C_PMU_SYS_CTL1,\n\t\t\t\t reg_mask, reg_val);\n\tif (ret) {\n\t\tdev_err(pwrc->dev, \"failed to write SYS_CTL%d: %d\\n\",\n\t\t\trestart ? 0 : 1, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmdelay(200);\n\n\treturn 0;\n}\n\nstatic int atc2609a_do_poweroff(const struct atc260x_pwrc *pwrc, bool restart)\n{\n\tint ret, deep_sleep = 0;\n\tuint reg_mask, reg_val;\n\n\t \n\tif (!restart && !power_supply_is_system_supplied()) {\n\t\tdeep_sleep = 1;\n\t\tdev_info(pwrc->dev, \"Enabling S4-Deep Sleep Mode\");\n\t}\n\n\t \n\treg_val = ATC2609A_PMU_SYS_CTL0_ONOFF_LONG_WK_EN |\n\t\t  (restart ? ATC2609A_PMU_SYS_CTL0_RESET_WK_EN\n\t\t\t   : ATC2609A_PMU_SYS_CTL0_ONOFF_SHORT_WK_EN);\n\n\tret = regmap_update_bits(pwrc->regmap, ATC2609A_PMU_SYS_CTL0,\n\t\t\t\t ATC2609A_PMU_SYS_CTL0_WK_ALL, reg_val);\n\tif (ret)\n\t\tdev_warn(pwrc->dev, \"failed to write SYS_CTL0: %d\\n\", ret);\n\n\t \n\treg_mask = ATC2609A_PMU_SYS_CTL3_EN_S2 | ATC2609A_PMU_SYS_CTL3_EN_S3;\n\n\tret = regmap_update_bits(pwrc->regmap, ATC2609A_PMU_SYS_CTL3, reg_mask,\n\t\t\t\t deep_sleep ? 0 : ATC2609A_PMU_SYS_CTL3_EN_S3);\n\tif (ret) {\n\t\tdev_err(pwrc->dev, \"failed to write SYS_CTL3: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg_mask = restart ? ATC2609A_PMU_SYS_CTL0_RESTART_EN\n\t\t\t   : ATC2609A_PMU_SYS_CTL1_EN_S1;\n\treg_val = restart ? ATC2609A_PMU_SYS_CTL0_RESTART_EN : 0;\n\n\tret = regmap_update_bits(pwrc->regmap,\n\t\t\t\t restart ? ATC2609A_PMU_SYS_CTL0 : ATC2609A_PMU_SYS_CTL1,\n\t\t\t\t reg_mask, reg_val);\n\tif (ret) {\n\t\tdev_err(pwrc->dev, \"failed to write SYS_CTL%d: %d\\n\",\n\t\t\trestart ? 0 : 1, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmdelay(200);\n\n\treturn 0;\n}\n\nstatic int atc2603c_init(const struct atc260x_pwrc *pwrc)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(pwrc->regmap, ATC2603C_PMU_SYS_CTL3,\n\t\t\t\t ATC2603C_PMU_SYS_CTL3_S2S3TOS1_TIMER_EN,\n\t\t\t\t ATC2603C_PMU_SYS_CTL3_S2S3TOS1_TIMER_EN);\n\tif (ret)\n\t\tdev_warn(pwrc->dev, \"failed to write SYS_CTL3: %d\\n\", ret);\n\n\t \n\tret = regmap_update_bits(pwrc->regmap, ATC2603C_PMU_SYS_CTL0,\n\t\t\t\t ATC2603C_PMU_SYS_CTL0_WK_ALL,\n\t\t\t\t ATC2603C_PMU_SYS_CTL0_HDSW_WK_EN |\n\t\t\t\t ATC2603C_PMU_SYS_CTL0_ONOFF_LONG_WK_EN);\n\tif (ret)\n\t\tdev_warn(pwrc->dev, \"failed to write SYS_CTL0: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int atc2609a_init(const struct atc260x_pwrc *pwrc)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(pwrc->regmap, ATC2609A_PMU_SYS_CTL0,\n\t\t\t\t ATC2609A_PMU_SYS_CTL0_WK_ALL,\n\t\t\t\t ATC2609A_PMU_SYS_CTL0_HDSW_WK_EN |\n\t\t\t\t ATC2609A_PMU_SYS_CTL0_ONOFF_LONG_WK_EN);\n\tif (ret)\n\t\tdev_warn(pwrc->dev, \"failed to write SYS_CTL0: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void atc260x_pwrc_pm_handler(void)\n{\n\tatc260x_pwrc_data->do_poweroff(atc260x_pwrc_data, false);\n\n\tWARN_ONCE(1, \"Unable to power off system\\n\");\n}\n\nstatic int atc260x_pwrc_restart_handler(struct notifier_block *nb,\n\t\t\t\t\tunsigned long mode, void *cmd)\n{\n\tstruct atc260x_pwrc *pwrc = container_of(nb, struct atc260x_pwrc,\n\t\t\t\t\t\t restart_nb);\n\tpwrc->do_poweroff(pwrc, true);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int atc260x_pwrc_probe(struct platform_device *pdev)\n{\n\tstruct atc260x *atc260x = dev_get_drvdata(pdev->dev.parent);\n\tstruct atc260x_pwrc *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->regmap = atc260x->regmap;\n\tpriv->restart_nb.notifier_call = atc260x_pwrc_restart_handler;\n\tpriv->restart_nb.priority = 192;\n\n\tswitch (atc260x->ic_type) {\n\tcase ATC2603C:\n\t\tpriv->do_poweroff = atc2603c_do_poweroff;\n\t\tret = atc2603c_init(priv);\n\t\tbreak;\n\tcase ATC2609A:\n\t\tpriv->do_poweroff = atc2609a_do_poweroff;\n\t\tret = atc2609a_init(priv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev,\n\t\t\t\"Poweroff not supported for ATC260x PMIC type: %u\\n\",\n\t\t\tatc260x->ic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tif (!pm_power_off) {\n\t\tatc260x_pwrc_data = priv;\n\t\tpm_power_off = atc260x_pwrc_pm_handler;\n\t} else {\n\t\tdev_warn(priv->dev, \"Poweroff callback already assigned\\n\");\n\t}\n\n\tret = register_restart_handler(&priv->restart_nb);\n\tif (ret)\n\t\tdev_err(priv->dev, \"failed to register restart handler: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int atc260x_pwrc_remove(struct platform_device *pdev)\n{\n\tstruct atc260x_pwrc *priv = platform_get_drvdata(pdev);\n\n\tif (atc260x_pwrc_data == priv) {\n\t\tpm_power_off = NULL;\n\t\tatc260x_pwrc_data = NULL;\n\t}\n\n\tunregister_restart_handler(&priv->restart_nb);\n\n\treturn 0;\n}\n\nstatic struct platform_driver atc260x_pwrc_driver = {\n\t.probe = atc260x_pwrc_probe,\n\t.remove = atc260x_pwrc_remove,\n\t.driver = {\n\t\t.name = \"atc260x-pwrc\",\n\t},\n};\n\nmodule_platform_driver(atc260x_pwrc_driver);\n\nMODULE_DESCRIPTION(\"Poweroff & reset driver for ATC260x PMICs\");\nMODULE_AUTHOR(\"Cristian Ciocaltea <cristian.ciocaltea@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}