{
  "module_name": "keystone-reset.c",
  "hash_id": "63d204e976599ca2f6b5f3ea3d2723bea3586c95b28af7bb09512d2fe5b75443",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/keystone-reset.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n\n#define RSTYPE_RG\t\t\t0x0\n#define RSCTRL_RG\t\t\t0x4\n#define RSCFG_RG\t\t\t0x8\n#define RSISO_RG\t\t\t0xc\n\n#define RSCTRL_KEY_MASK\t\t\t0x0000ffff\n#define RSCTRL_RESET_MASK\t\tBIT(16)\n#define RSCTRL_KEY\t\t\t0x5a69\n\n#define RSMUX_OMODE_MASK\t\t0xe\n#define RSMUX_OMODE_RESET_ON\t\t0xa\n#define RSMUX_OMODE_RESET_OFF\t\t0x0\n#define RSMUX_LOCK_MASK\t\t\t0x1\n#define RSMUX_LOCK_SET\t\t\t0x1\n\n#define RSCFG_RSTYPE_SOFT\t\t0x300f\n#define RSCFG_RSTYPE_HARD\t\t0x0\n\n#define WDT_MUX_NUMBER\t\t\t0x4\n\nstatic int rspll_offset;\nstatic struct regmap *pllctrl_regs;\n\n \nstatic inline int rsctrl_enable_rspll_write(void)\n{\n\treturn regmap_update_bits(pllctrl_regs, rspll_offset + RSCTRL_RG,\n\t\t\t\t  RSCTRL_KEY_MASK, RSCTRL_KEY);\n}\n\nstatic int rsctrl_restart_handler(struct notifier_block *this,\n\t\t\t\t  unsigned long mode, void *cmd)\n{\n\t \n\trsctrl_enable_rspll_write();\n\n\t \n\tregmap_update_bits(pllctrl_regs, rspll_offset + RSCTRL_RG,\n\t\t\t   RSCTRL_RESET_MASK, 0);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rsctrl_restart_nb = {\n\t.notifier_call = rsctrl_restart_handler,\n\t.priority = 128,\n};\n\nstatic const struct of_device_id rsctrl_of_match[] = {\n\t{.compatible = \"ti,keystone-reset\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rsctrl_of_match);\n\nstatic int rsctrl_probe(struct platform_device *pdev)\n{\n\tint i;\n\tint ret;\n\tu32 val;\n\tunsigned int rg;\n\tu32 rsmux_offset;\n\tstruct regmap *devctrl_regs;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\t \n\tpllctrl_regs = syscon_regmap_lookup_by_phandle(np, \"ti,syscon-pll\");\n\tif (IS_ERR(pllctrl_regs))\n\t\treturn PTR_ERR(pllctrl_regs);\n\n\tdevctrl_regs = syscon_regmap_lookup_by_phandle(np, \"ti,syscon-dev\");\n\tif (IS_ERR(devctrl_regs))\n\t\treturn PTR_ERR(devctrl_regs);\n\n\tret = of_property_read_u32_index(np, \"ti,syscon-pll\", 1, &rspll_offset);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't read the reset pll offset!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_index(np, \"ti,syscon-dev\", 1, &rsmux_offset);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't read the rsmux offset!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = of_property_read_bool(np, \"ti,soft-reset\");\n\tval = val ? RSCFG_RSTYPE_SOFT : RSCFG_RSTYPE_HARD;\n\n\tret = rsctrl_enable_rspll_write();\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(pllctrl_regs, rspll_offset + RSCFG_RG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(pllctrl_regs, rspll_offset + RSISO_RG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < WDT_MUX_NUMBER; i++) {\n\t\tret = of_property_read_u32_index(np, \"ti,wdt-list\", i, &val);\n\t\tif (ret == -EOVERFLOW && !i) {\n\t\t\tdev_err(dev, \"ti,wdt-list property has to contain at\"\n\t\t\t\t\"least one entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (ret) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val >= WDT_MUX_NUMBER) {\n\t\t\tdev_err(dev, \"ti,wdt-list property can contain \"\n\t\t\t\t\"only numbers < 4\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trg = rsmux_offset + val * 4;\n\n\t\tret = regmap_update_bits(devctrl_regs, rg, RSMUX_OMODE_MASK,\n\t\t\t\t\t RSMUX_OMODE_RESET_ON |\n\t\t\t\t\t RSMUX_LOCK_SET);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = register_restart_handler(&rsctrl_restart_nb);\n\tif (ret)\n\t\tdev_err(dev, \"cannot register restart handler (err=%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver rsctrl_driver = {\n\t.probe = rsctrl_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = rsctrl_of_match,\n\t},\n};\nmodule_platform_driver(rsctrl_driver);\n\nMODULE_AUTHOR(\"Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments keystone reset driver\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}