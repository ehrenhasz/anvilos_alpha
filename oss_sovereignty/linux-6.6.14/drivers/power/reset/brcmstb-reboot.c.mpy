{
  "module_name": "brcmstb-reboot.c",
  "hash_id": "219b2b92cc69ec033cce7e29c16035117e3209113dfd94ad7a20dbd14bac7495",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/brcmstb-reboot.c",
  "human_readable_source": "\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/notifier.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/smp.h>\n#include <linux/mfd/syscon.h>\n\n#define RESET_SOURCE_ENABLE_REG 1\n#define SW_MASTER_RESET_REG 2\n\nstatic struct regmap *regmap;\nstatic u32 rst_src_en;\nstatic u32 sw_mstr_rst;\n\nstruct reset_reg_mask {\n\tu32 rst_src_en_mask;\n\tu32 sw_mstr_rst_mask;\n};\n\nstatic const struct reset_reg_mask *reset_masks;\n\nstatic int brcmstb_restart_handler(struct notifier_block *this,\n\t\t\t\t   unsigned long mode, void *cmd)\n{\n\tint rc;\n\tu32 tmp;\n\n\trc = regmap_write(regmap, rst_src_en, reset_masks->rst_src_en_mask);\n\tif (rc) {\n\t\tpr_err(\"failed to write rst_src_en (%d)\\n\", rc);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\trc = regmap_read(regmap, rst_src_en, &tmp);\n\tif (rc) {\n\t\tpr_err(\"failed to read rst_src_en (%d)\\n\", rc);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\trc = regmap_write(regmap, sw_mstr_rst, reset_masks->sw_mstr_rst_mask);\n\tif (rc) {\n\t\tpr_err(\"failed to write sw_mstr_rst (%d)\\n\", rc);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\trc = regmap_read(regmap, sw_mstr_rst, &tmp);\n\tif (rc) {\n\t\tpr_err(\"failed to read sw_mstr_rst (%d)\\n\", rc);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\twhile (1)\n\t\t;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block brcmstb_restart_nb = {\n\t.notifier_call = brcmstb_restart_handler,\n\t.priority = 128,\n};\n\nstatic const struct reset_reg_mask reset_bits_40nm = {\n\t.rst_src_en_mask = BIT(0),\n\t.sw_mstr_rst_mask = BIT(0),\n};\n\nstatic const struct reset_reg_mask reset_bits_65nm = {\n\t.rst_src_en_mask = BIT(3),\n\t.sw_mstr_rst_mask = BIT(31),\n};\n\nstatic const struct of_device_id of_match[] = {\n\t{ .compatible = \"brcm,brcmstb-reboot\", .data = &reset_bits_40nm },\n\t{ .compatible = \"brcm,bcm7038-reboot\", .data = &reset_bits_65nm },\n\t{},\n};\n\nstatic int brcmstb_reboot_probe(struct platform_device *pdev)\n{\n\tint rc;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(of_match, np);\n\tif (!of_id) {\n\t\tpr_err(\"failed to look up compatible string\\n\");\n\t\treturn -EINVAL;\n\t}\n\treset_masks = of_id->data;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"failed to get syscon phandle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = of_property_read_u32_index(np, \"syscon\", RESET_SOURCE_ENABLE_REG,\n\t\t\t\t\t&rst_src_en);\n\tif (rc) {\n\t\tpr_err(\"can't get rst_src_en offset (%d)\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\trc = of_property_read_u32_index(np, \"syscon\", SW_MASTER_RESET_REG,\n\t\t\t\t\t&sw_mstr_rst);\n\tif (rc) {\n\t\tpr_err(\"can't get sw_mstr_rst offset (%d)\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\trc = register_restart_handler(&brcmstb_restart_nb);\n\tif (rc)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"cannot register restart handler (err=%d)\\n\", rc);\n\n\treturn rc;\n}\n\nstatic struct platform_driver brcmstb_reboot_driver = {\n\t.probe = brcmstb_reboot_probe,\n\t.driver = {\n\t\t.name = \"brcmstb-reboot\",\n\t\t.of_match_table = of_match,\n\t},\n};\n\nstatic int __init brcmstb_reboot_init(void)\n{\n\treturn platform_driver_probe(&brcmstb_reboot_driver,\n\t\t\t\t\tbrcmstb_reboot_probe);\n}\nsubsys_initcall(brcmstb_reboot_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}