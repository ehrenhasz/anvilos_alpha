{
  "module_name": "qnap-poweroff.c",
  "hash_id": "b40b350048ec67b3eea8a545f341bf929f4adaf2ae0973344be4e11467c37a0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/qnap-poweroff.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/serial_reg.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n\n#define UART1_REG(x)\t(base + ((UART_##x) << 2))\n\nstruct power_off_cfg {\n\tu32 baud;\n\tchar cmd;\n};\n\nstatic const struct power_off_cfg qnap_power_off_cfg = {\n\t.baud = 19200,\n\t.cmd = 'A',\n};\n\nstatic const struct power_off_cfg synology_power_off_cfg = {\n\t.baud = 9600,\n\t.cmd = '1',\n};\n\nstatic const struct of_device_id qnap_power_off_of_match_table[] = {\n\t{ .compatible = \"qnap,power-off\",\n\t  .data = &qnap_power_off_cfg,\n\t},\n\t{ .compatible = \"synology,power-off\",\n\t  .data = &synology_power_off_cfg,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qnap_power_off_of_match_table);\n\nstatic void __iomem *base;\nstatic unsigned long tclk;\nstatic const struct power_off_cfg *cfg;\n\nstatic void qnap_power_off(void)\n{\n\tconst unsigned divisor = ((tclk + (8 * cfg->baud)) / (16 * cfg->baud));\n\n\tpr_err(\"%s: triggering power-off...\\n\", __func__);\n\n\t \n\twritel(0x83, UART1_REG(LCR));\n\twritel(divisor & 0xff, UART1_REG(DLL));\n\twritel((divisor >> 8) & 0xff, UART1_REG(DLM));\n\twritel(0x03, UART1_REG(LCR));\n\twritel(0x00, UART1_REG(IER));\n\twritel(0x00, UART1_REG(FCR));\n\twritel(0x00, UART1_REG(MCR));\n\n\t \n\twritel(cfg->cmd, UART1_REG(TX));\n}\n\nstatic int qnap_power_off_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct clk *clk;\n\n\tconst struct of_device_id *match =\n\t\tof_match_node(qnap_power_off_of_match_table, np);\n\tcfg = match->data;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Missing resource\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!base) {\n\t\tdev_err(&pdev->dev, \"Unable to map resource\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Clk missing\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\ttclk = clk_get_rate(clk);\n\n\t \n\tif (pm_power_off) {\n\t\tdev_err(&pdev->dev, \"pm_power_off already claimed for %ps\",\n\t\t\tpm_power_off);\n\t\treturn -EBUSY;\n\t}\n\tpm_power_off = qnap_power_off;\n\n\treturn 0;\n}\n\nstatic int qnap_power_off_remove(struct platform_device *pdev)\n{\n\tpm_power_off = NULL;\n\treturn 0;\n}\n\nstatic struct platform_driver qnap_power_off_driver = {\n\t.probe\t= qnap_power_off_probe,\n\t.remove\t= qnap_power_off_remove,\n\t.driver\t= {\n\t\t.name\t= \"qnap_power_off\",\n\t\t.of_match_table = of_match_ptr(qnap_power_off_of_match_table),\n\t},\n};\nmodule_platform_driver(qnap_power_off_driver);\n\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_DESCRIPTION(\"QNAP Power off driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}