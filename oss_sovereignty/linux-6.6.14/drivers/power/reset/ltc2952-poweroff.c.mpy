{
  "module_name": "ltc2952-poweroff.c",
  "hash_id": "2e7be4fe30036ee9695d09e986352134221773e9a1a8368471e5ecb14d78e954",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/ltc2952-poweroff.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/panic_notifier.h>\n#include <linux/mod_devicetable.h>\n#include <linux/gpio/consumer.h>\n#include <linux/reboot.h>\n#include <linux/property.h>\n\nstruct ltc2952_poweroff {\n\tstruct hrtimer timer_trigger;\n\tstruct hrtimer timer_wde;\n\n\tktime_t trigger_delay;\n\tktime_t wde_interval;\n\n\tstruct device *dev;\n\n\tstruct gpio_desc *gpio_trigger;\n\tstruct gpio_desc *gpio_watchdog;\n\tstruct gpio_desc *gpio_kill;\n\n\tbool kernel_panic;\n\tstruct notifier_block panic_notifier;\n};\n\n#define to_ltc2952(p, m) container_of(p, struct ltc2952_poweroff, m)\n\n \nstatic struct ltc2952_poweroff *ltc2952_data;\n\n \nstatic enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)\n{\n\tint state;\n\tstruct ltc2952_poweroff *data = to_ltc2952(timer, timer_wde);\n\n\tif (data->kernel_panic)\n\t\treturn HRTIMER_NORESTART;\n\n\tstate = gpiod_get_value(data->gpio_watchdog);\n\tgpiod_set_value(data->gpio_watchdog, !state);\n\n\thrtimer_forward_now(timer, data->wde_interval);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic void ltc2952_poweroff_start_wde(struct ltc2952_poweroff *data)\n{\n\thrtimer_start(&data->timer_wde, data->wde_interval, HRTIMER_MODE_REL);\n}\n\nstatic enum hrtimer_restart\nltc2952_poweroff_timer_trigger(struct hrtimer *timer)\n{\n\tstruct ltc2952_poweroff *data = to_ltc2952(timer, timer_trigger);\n\n\tltc2952_poweroff_start_wde(data);\n\tdev_info(data->dev, \"executing shutdown\\n\");\n\torderly_poweroff(true);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)\n{\n\tstruct ltc2952_poweroff *data = dev_id;\n\n\tif (data->kernel_panic || hrtimer_active(&data->timer_wde)) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (gpiod_get_value(data->gpio_trigger)) {\n\t\thrtimer_start(&data->timer_trigger, data->trigger_delay,\n\t\t\t      HRTIMER_MODE_REL);\n\t} else {\n\t\thrtimer_cancel(&data->timer_trigger);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void ltc2952_poweroff_kill(void)\n{\n\tgpiod_set_value(ltc2952_data->gpio_kill, 1);\n}\n\nstatic void ltc2952_poweroff_default(struct ltc2952_poweroff *data)\n{\n\tdata->wde_interval = 300L * NSEC_PER_MSEC;\n\tdata->trigger_delay = ktime_set(2, 500L * NSEC_PER_MSEC);\n\n\thrtimer_init(&data->timer_trigger, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tdata->timer_trigger.function = ltc2952_poweroff_timer_trigger;\n\n\thrtimer_init(&data->timer_wde, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tdata->timer_wde.function = ltc2952_poweroff_timer_wde;\n}\n\nstatic int ltc2952_poweroff_init(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 trigger_delay_ms;\n\tstruct ltc2952_poweroff *data = platform_get_drvdata(pdev);\n\n\tltc2952_poweroff_default(data);\n\n\tif (!device_property_read_u32(&pdev->dev, \"trigger-delay-ms\",\n\t\t\t\t      &trigger_delay_ms)) {\n\t\tdata->trigger_delay = ktime_set(trigger_delay_ms / MSEC_PER_SEC,\n\t\t\t(trigger_delay_ms % MSEC_PER_SEC) * NSEC_PER_MSEC);\n\t}\n\n\tdata->gpio_watchdog = devm_gpiod_get(&pdev->dev, \"watchdog\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpio_watchdog)) {\n\t\tret = PTR_ERR(data->gpio_watchdog);\n\t\tdev_err(&pdev->dev, \"unable to claim gpio \\\"watchdog\\\"\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->gpio_kill = devm_gpiod_get(&pdev->dev, \"kill\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpio_kill)) {\n\t\tret = PTR_ERR(data->gpio_kill);\n\t\tdev_err(&pdev->dev, \"unable to claim gpio \\\"kill\\\"\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->gpio_trigger = devm_gpiod_get_optional(&pdev->dev, \"trigger\",\n\t\t\t\t\t\t     GPIOD_IN);\n\tif (IS_ERR(data->gpio_trigger)) {\n\t\t \n\t\tdev_err(&pdev->dev, \"unable to claim gpio \\\"trigger\\\"\\n\");\n\t\tdata->gpio_trigger = NULL;\n\t}\n\n\tif (devm_request_irq(&pdev->dev, gpiod_to_irq(data->gpio_trigger),\n\t\t\t     ltc2952_poweroff_handler,\n\t\t\t     (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),\n\t\t\t     \"ltc2952-poweroff\",\n\t\t\t     data)) {\n\t\t \n\t\tif (data->gpio_trigger) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"unable to configure the trigger interrupt\\n\");\n\t\t\tdevm_gpiod_put(&pdev->dev, data->gpio_trigger);\n\t\t\tdata->gpio_trigger = NULL;\n\t\t}\n\t\tdev_info(&pdev->dev,\n\t\t\t \"power down trigger input will not be used\\n\");\n\t\tltc2952_poweroff_start_wde(data);\n\t}\n\n\treturn 0;\n}\n\nstatic int ltc2952_poweroff_notify_panic(struct notifier_block *nb,\n\t\t\t\t\t unsigned long code, void *unused)\n{\n\tstruct ltc2952_poweroff *data = to_ltc2952(nb, panic_notifier);\n\n\tdata->kernel_panic = true;\n\treturn NOTIFY_DONE;\n}\n\nstatic int ltc2952_poweroff_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct ltc2952_poweroff *data;\n\n\tif (pm_power_off) {\n\t\tdev_err(&pdev->dev, \"pm_power_off already registered\");\n\t\treturn -EBUSY;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, data);\n\n\tret = ltc2952_poweroff_init(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tltc2952_data = data;\n\tpm_power_off = ltc2952_poweroff_kill;\n\n\tdata->panic_notifier.notifier_call = ltc2952_poweroff_notify_panic;\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &data->panic_notifier);\n\tdev_info(&pdev->dev, \"probe successful\\n\");\n\n\treturn 0;\n}\n\nstatic int ltc2952_poweroff_remove(struct platform_device *pdev)\n{\n\tstruct ltc2952_poweroff *data = platform_get_drvdata(pdev);\n\n\tpm_power_off = NULL;\n\thrtimer_cancel(&data->timer_trigger);\n\thrtimer_cancel(&data->timer_wde);\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &data->panic_notifier);\n\treturn 0;\n}\n\nstatic const struct of_device_id of_ltc2952_poweroff_match[] = {\n\t{ .compatible = \"lltc,ltc2952\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_ltc2952_poweroff_match);\n\nstatic struct platform_driver ltc2952_poweroff_driver = {\n\t.probe = ltc2952_poweroff_probe,\n\t.remove = ltc2952_poweroff_remove,\n\t.driver = {\n\t\t.name = \"ltc2952-poweroff\",\n\t\t.of_match_table = of_ltc2952_poweroff_match,\n\t},\n};\n\nmodule_platform_driver(ltc2952_poweroff_driver);\n\nMODULE_AUTHOR(\"Ren\u00e9 Moll <rene.moll@xsens.com>\");\nMODULE_DESCRIPTION(\"LTC PowerPath power-off driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}