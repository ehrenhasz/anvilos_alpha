{
  "module_name": "vexpress-poweroff.c",
  "hash_id": "a3c63f727c59fcce82da1f4313498ab33935e664a2843ae6fe1c21b0b0930549",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/vexpress-poweroff.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/stat.h>\n#include <linux/vexpress.h>\n\nstatic void vexpress_reset_do(struct device *dev, const char *what)\n{\n\tint err = -ENOENT;\n\tstruct regmap *reg = dev_get_drvdata(dev);\n\n\tif (reg) {\n\t\terr = regmap_write(reg, 0, 0);\n\t\tif (!err)\n\t\t\tmdelay(1000);\n\t}\n\n\tdev_emerg(dev, \"Unable to %s (%d)\\n\", what, err);\n}\n\nstatic struct device *vexpress_power_off_device;\nstatic atomic_t vexpress_restart_nb_refcnt = ATOMIC_INIT(0);\n\nstatic void vexpress_power_off(void)\n{\n\tvexpress_reset_do(vexpress_power_off_device, \"power off\");\n}\n\nstatic struct device *vexpress_restart_device;\n\nstatic int vexpress_restart(struct notifier_block *this, unsigned long mode,\n\t\t\t     void *cmd)\n{\n\tvexpress_reset_do(vexpress_restart_device, \"restart\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block vexpress_restart_nb = {\n\t.notifier_call = vexpress_restart,\n\t.priority = 128,\n};\n\nstatic ssize_t vexpress_reset_active_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", vexpress_restart_device == dev);\n}\n\nstatic ssize_t vexpress_reset_active_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tlong value;\n\tint err = kstrtol(buf, 0, &value);\n\n\tif (!err && value)\n\t\tvexpress_restart_device = dev;\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR(active, S_IRUGO | S_IWUSR, vexpress_reset_active_show,\n\t\t   vexpress_reset_active_store);\n\n\nenum vexpress_reset_func { FUNC_RESET, FUNC_SHUTDOWN, FUNC_REBOOT };\n\nstatic const struct of_device_id vexpress_reset_of_match[] = {\n\t{\n\t\t.compatible = \"arm,vexpress-reset\",\n\t\t.data = (void *)FUNC_RESET,\n\t}, {\n\t\t.compatible = \"arm,vexpress-shutdown\",\n\t\t.data = (void *)FUNC_SHUTDOWN\n\t}, {\n\t\t.compatible = \"arm,vexpress-reboot\",\n\t\t.data = (void *)FUNC_REBOOT\n\t},\n\t{}\n};\n\nstatic int _vexpress_register_restart_handler(struct device *dev)\n{\n\tint err;\n\n\tvexpress_restart_device = dev;\n\tif (atomic_inc_return(&vexpress_restart_nb_refcnt) == 1) {\n\t\terr = register_restart_handler(&vexpress_restart_nb);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"cannot register restart handler (err=%d)\\n\", err);\n\t\t\tatomic_dec(&vexpress_restart_nb_refcnt);\n\t\t\treturn err;\n\t\t}\n\t}\n\tdevice_create_file(dev, &dev_attr_active);\n\n\treturn 0;\n}\n\nstatic int vexpress_reset_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match =\n\t\t\tof_match_device(vexpress_reset_of_match, &pdev->dev);\n\tstruct regmap *regmap;\n\tint ret = 0;\n\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tregmap = devm_regmap_init_vexpress_config(&pdev->dev);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\tdev_set_drvdata(&pdev->dev, regmap);\n\n\tswitch ((uintptr_t)match->data) {\n\tcase FUNC_SHUTDOWN:\n\t\tvexpress_power_off_device = &pdev->dev;\n\t\tpm_power_off = vexpress_power_off;\n\t\tbreak;\n\tcase FUNC_RESET:\n\t\tif (!vexpress_restart_device)\n\t\t\tret = _vexpress_register_restart_handler(&pdev->dev);\n\t\tbreak;\n\tcase FUNC_REBOOT:\n\t\tret = _vexpress_register_restart_handler(&pdev->dev);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver vexpress_reset_driver = {\n\t.probe = vexpress_reset_probe,\n\t.driver = {\n\t\t.name = \"vexpress-reset\",\n\t\t.of_match_table = vexpress_reset_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(vexpress_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}