{
  "module_name": "ocelot-reset.c",
  "hash_id": "bf42bdd67d5347447d20f9098876463c8d6ae0538b4372ca443766201d448908",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/ocelot-reset.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/notifier.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\nstruct reset_props {\n\tconst char *syscon;\n\tu32 protect_reg;\n\tu32 vcore_protect;\n\tu32 if_si_owner_bit;\n};\n\nstruct ocelot_reset_context {\n\tvoid __iomem *base;\n\tstruct regmap *cpu_ctrl;\n\tconst struct reset_props *props;\n\tstruct notifier_block restart_handler;\n};\n\n#define BIT_OFF_INVALID\t\t\t\t32\n\n#define SOFT_CHIP_RST BIT(0)\n\n#define ICPU_CFG_CPU_SYSTEM_CTRL_GENERAL_CTRL\t0x24\n#define IF_SI_OWNER_MASK\t\t\tGENMASK(1, 0)\n#define IF_SI_OWNER_SISL\t\t\t0\n#define IF_SI_OWNER_SIBM\t\t\t1\n#define IF_SI_OWNER_SIMC\t\t\t2\n\nstatic int ocelot_restart_handle(struct notifier_block *this,\n\t\t\t\t unsigned long mode, void *cmd)\n{\n\tstruct ocelot_reset_context *ctx = container_of(this, struct\n\t\t\t\t\t\t\tocelot_reset_context,\n\t\t\t\t\t\t\trestart_handler);\n\tu32 if_si_owner_bit = ctx->props->if_si_owner_bit;\n\n\t \n\tregmap_update_bits(ctx->cpu_ctrl, ctx->props->protect_reg,\n\t\t\t   ctx->props->vcore_protect, 0);\n\n\t \n\tif (if_si_owner_bit != BIT_OFF_INVALID)\n\t\tregmap_update_bits(ctx->cpu_ctrl,\n\t\t\t\t   ICPU_CFG_CPU_SYSTEM_CTRL_GENERAL_CTRL,\n\t\t\t\t   IF_SI_OWNER_MASK << if_si_owner_bit,\n\t\t\t\t   IF_SI_OWNER_SIBM << if_si_owner_bit);\n\n\tpr_emerg(\"Resetting SoC\\n\");\n\n\twritel(SOFT_CHIP_RST, ctx->base);\n\n\tpr_emerg(\"Unable to restart system\\n\");\n\treturn NOTIFY_DONE;\n}\n\nstatic int ocelot_reset_probe(struct platform_device *pdev)\n{\n\tstruct ocelot_reset_context *ctx;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->base))\n\t\treturn PTR_ERR(ctx->base);\n\n\tctx->props = device_get_match_data(dev);\n\n\tctx->cpu_ctrl = syscon_regmap_lookup_by_compatible(ctx->props->syscon);\n\tif (IS_ERR(ctx->cpu_ctrl)) {\n\t\tdev_err(dev, \"No syscon map: %s\\n\", ctx->props->syscon);\n\t\treturn PTR_ERR(ctx->cpu_ctrl);\n\t}\n\n\tctx->restart_handler.notifier_call = ocelot_restart_handle;\n\tctx->restart_handler.priority = 192;\n\terr = register_restart_handler(&ctx->restart_handler);\n\tif (err)\n\t\tdev_err(dev, \"can't register restart notifier (err=%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic const struct reset_props reset_props_jaguar2 = {\n\t.syscon\t\t = \"mscc,ocelot-cpu-syscon\",\n\t.protect_reg     = 0x20,\n\t.vcore_protect   = BIT(2),\n\t.if_si_owner_bit = 6,\n};\n\nstatic const struct reset_props reset_props_luton = {\n\t.syscon\t\t = \"mscc,ocelot-cpu-syscon\",\n\t.protect_reg     = 0x20,\n\t.vcore_protect   = BIT(2),\n\t.if_si_owner_bit = BIT_OFF_INVALID,  \n};\n\nstatic const struct reset_props reset_props_ocelot = {\n\t.syscon\t\t = \"mscc,ocelot-cpu-syscon\",\n\t.protect_reg     = 0x20,\n\t.vcore_protect   = BIT(2),\n\t.if_si_owner_bit = 4,\n};\n\nstatic const struct reset_props reset_props_sparx5 = {\n\t.syscon\t\t = \"microchip,sparx5-cpu-syscon\",\n\t.protect_reg     = 0x84,\n\t.vcore_protect   = BIT(10),\n\t.if_si_owner_bit = 6,\n};\n\nstatic const struct of_device_id ocelot_reset_of_match[] = {\n\t{\n\t\t.compatible = \"mscc,jaguar2-chip-reset\",\n\t\t.data = &reset_props_jaguar2\n\t}, {\n\t\t.compatible = \"mscc,luton-chip-reset\",\n\t\t.data = &reset_props_luton\n\t}, {\n\t\t.compatible = \"mscc,ocelot-chip-reset\",\n\t\t.data = &reset_props_ocelot\n\t}, {\n\t\t.compatible = \"microchip,sparx5-chip-reset\",\n\t\t.data = &reset_props_sparx5\n\t},\n\t{   }\n};\n\nstatic struct platform_driver ocelot_reset_driver = {\n\t.probe = ocelot_reset_probe,\n\t.driver = {\n\t\t.name = \"ocelot-chip-reset\",\n\t\t.of_match_table = ocelot_reset_of_match,\n\t},\n};\nbuiltin_platform_driver(ocelot_reset_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}