{
  "module_name": "at91-reset.c",
  "hash_id": "7e936fa0d19977c3ec48c555e406f9ffb2e6c230200e443e8ecd6092a8be082d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/at91-reset.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/reset-controller.h>\n#include <linux/power/power_on_reason.h>\n\n#include <soc/at91/at91sam9_ddrsdr.h>\n#include <soc/at91/at91sam9_sdramc.h>\n\n#include <dt-bindings/reset/sama7g5-reset.h>\n\n#define AT91_RSTC_CR\t0x00\t\t \n#define AT91_RSTC_PROCRST\tBIT(0)\t\t \n#define AT91_RSTC_PERRST\tBIT(2)\t\t \n#define AT91_RSTC_EXTRST\tBIT(3)\t\t \n#define AT91_RSTC_KEY\t\t(0xa5 << 24)\t \n\n#define AT91_RSTC_SR\t0x04\t\t \n#define AT91_RSTC_URSTS\t\tBIT(0)\t\t \n#define AT91_RSTC_RSTTYP\tGENMASK(10, 8)\t \n#define AT91_RSTC_NRSTL\t\tBIT(16)\t\t \n#define AT91_RSTC_SRCMP\t\tBIT(17)\t\t \n\n#define AT91_RSTC_MR\t0x08\t\t \n#define AT91_RSTC_URSTEN\tBIT(0)\t\t \n#define AT91_RSTC_URSTASYNC\tBIT(2)\t\t \n#define AT91_RSTC_URSTIEN\tBIT(4)\t\t \n#define AT91_RSTC_ERSTL\t\tGENMASK(11, 8)\t \n\n \nenum reset_type {\n\tRESET_TYPE_GENERAL\t= 0,\n\tRESET_TYPE_WAKEUP\t= 1,\n\tRESET_TYPE_WATCHDOG\t= 2,\n\tRESET_TYPE_SOFTWARE\t= 3,\n\tRESET_TYPE_USER\t\t= 4,\n\tRESET_TYPE_CPU_FAIL\t= 6,\n\tRESET_TYPE_XTAL_FAIL\t= 7,\n\tRESET_TYPE_ULP2\t\t= 8,\n};\n\n \nstruct at91_reset {\n\tvoid __iomem *rstc_base;\n\tvoid __iomem *ramc_base[2];\n\tvoid __iomem *dev_base;\n\tstruct clk *sclk;\n\tconst struct at91_reset_data *data;\n\tstruct reset_controller_dev rcdev;\n\tspinlock_t lock;\n\tstruct notifier_block nb;\n\tu32 args;\n\tu32 ramc_lpr;\n};\n\n#define to_at91_reset(r)\tcontainer_of(r, struct at91_reset, rcdev)\n\n \nstruct at91_reset_data {\n\tu32 reset_args;\n\tu32 n_device_reset;\n\tu8 device_reset_min_id;\n\tu8 device_reset_max_id;\n};\n\n \nstatic int at91_reset(struct notifier_block *this, unsigned long mode,\n\t\t      void *cmd)\n{\n\tstruct at91_reset *reset = container_of(this, struct at91_reset, nb);\n\n\tasm volatile(\n\t\t \n\t\t\".balign 32\\n\\t\"\n\n\t\t \n\t\t\"\ttst\t%0, #0\\n\\t\"\n\t\t\"\tbeq\t1f\\n\\t\"\n\t\t\"\tstr\t%3, [%0, #\" __stringify(AT91_DDRSDRC_RTR) \"]\\n\\t\"\n\t\t \n\t\t\"\tstr\t%4, [%0, %6]\\n\\t\"\n\t\t \n\t\t\"1:\ttst\t%1, #0\\n\\t\"\n\t\t\"\tbeq\t2f\\n\\t\"\n\t\t\"\tstrne\t%3, [%1, #\" __stringify(AT91_DDRSDRC_RTR) \"]\\n\\t\"\n\t\t \n\t\t\"\tstrne\t%4, [%1, %6]\\n\\t\"\n\t\t \n\t\t\"2:\tstr\t%5, [%2, #\" __stringify(AT91_RSTC_CR) \"]\\n\\t\"\n\n\t\t\"\tb\t.\\n\\t\"\n\t\t:\n\t\t: \"r\" (reset->ramc_base[0]),\n\t\t  \"r\" (reset->ramc_base[1]),\n\t\t  \"r\" (reset->rstc_base),\n\t\t  \"r\" (1),\n\t\t  \"r\" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),\n\t\t  \"r\" (reset->data->reset_args),\n\t\t  \"r\" (reset->ramc_lpr)\n\t\t: \"r4\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const char *at91_reset_reason(struct at91_reset *reset)\n{\n\tu32 reg = readl(reset->rstc_base + AT91_RSTC_SR);\n\tconst char *reason;\n\n\tswitch ((reg & AT91_RSTC_RSTTYP) >> 8) {\n\tcase RESET_TYPE_GENERAL:\n\t\treason = POWER_ON_REASON_REGULAR;\n\t\tbreak;\n\tcase RESET_TYPE_WAKEUP:\n\t\treason = POWER_ON_REASON_RTC;\n\t\tbreak;\n\tcase RESET_TYPE_WATCHDOG:\n\t\treason = POWER_ON_REASON_WATCHDOG;\n\t\tbreak;\n\tcase RESET_TYPE_SOFTWARE:\n\t\treason = POWER_ON_REASON_SOFTWARE;\n\t\tbreak;\n\tcase RESET_TYPE_USER:\n\t\treason = POWER_ON_REASON_RST_BTN;\n\t\tbreak;\n\tcase RESET_TYPE_CPU_FAIL:\n\t\treason = POWER_ON_REASON_CPU_CLK_FAIL;\n\t\tbreak;\n\tcase RESET_TYPE_XTAL_FAIL:\n\t\treason = POWER_ON_REASON_XTAL_FAIL;\n\t\tbreak;\n\tcase RESET_TYPE_ULP2:\n\t\treason = POWER_ON_REASON_BROWN_OUT;\n\t\tbreak;\n\tdefault:\n\t\treason = POWER_ON_REASON_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn reason;\n}\n\nstatic ssize_t power_on_reason_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct at91_reset *reset = platform_get_drvdata(pdev);\n\n\treturn sprintf(buf, \"%s\\n\", at91_reset_reason(reset));\n}\nstatic DEVICE_ATTR_RO(power_on_reason);\n\nstatic const struct of_device_id at91_ramc_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9260-sdramc\",\n\t\t.data = (void *)AT91_SDRAMC_LPR,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-ddramc\",\n\t\t.data = (void *)AT91_DDRSDRC_LPR,\n\t},\n\t{   }\n};\n\nstatic const struct at91_reset_data sam9260 = {\n\t.reset_args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,\n};\n\nstatic const struct at91_reset_data samx7 = {\n\t.reset_args = AT91_RSTC_KEY | AT91_RSTC_PROCRST,\n};\n\nstatic const struct at91_reset_data sama7g5 = {\n\t.reset_args = AT91_RSTC_KEY | AT91_RSTC_PROCRST,\n\t.n_device_reset = 3,\n\t.device_reset_min_id = SAMA7G5_RESET_USB_PHY1,\n\t.device_reset_max_id = SAMA7G5_RESET_USB_PHY3,\n};\n\nstatic const struct of_device_id at91_reset_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9260-rstc\",\n\t\t.data = &sam9260,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-rstc\",\n\t\t.data = &sam9260,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d3-rstc\",\n\t\t.data = &sam9260,\n\t},\n\t{\n\t\t.compatible = \"atmel,samx7-rstc\",\n\t\t.data = &samx7,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-rstc\",\n\t\t.data = &samx7,\n\t},\n\t{\n\t\t.compatible = \"microchip,sama7g5-rstc\",\n\t\t.data = &sama7g5,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, at91_reset_of_match);\n\nstatic int at91_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id, bool assert)\n{\n\tstruct at91_reset *reset = to_at91_reset(rcdev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&reset->lock, flags);\n\tval = readl_relaxed(reset->dev_base);\n\tif (assert)\n\t\tval |= BIT(id);\n\telse\n\t\tval &= ~BIT(id);\n\twritel_relaxed(val, reset->dev_base);\n\tspin_unlock_irqrestore(&reset->lock, flags);\n\n\treturn 0;\n}\n\nstatic int at91_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t     unsigned long id)\n{\n\treturn at91_reset_update(rcdev, id, true);\n}\n\nstatic int at91_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn at91_reset_update(rcdev, id, false);\n}\n\nstatic int at91_reset_dev_status(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\tstruct at91_reset *reset = to_at91_reset(rcdev);\n\tu32 val;\n\n\tval = readl_relaxed(reset->dev_base);\n\n\treturn !!(val & BIT(id));\n}\n\nstatic const struct reset_control_ops at91_reset_ops = {\n\t.assert = at91_reset_assert,\n\t.deassert = at91_reset_deassert,\n\t.status = at91_reset_dev_status,\n};\n\nstatic int at91_reset_of_xlate(struct reset_controller_dev *rcdev,\n\t\t\t       const struct of_phandle_args *reset_spec)\n{\n\tstruct at91_reset *reset = to_at91_reset(rcdev);\n\n\tif (!reset->data->n_device_reset ||\n\t    (reset_spec->args[0] < reset->data->device_reset_min_id ||\n\t     reset_spec->args[0] > reset->data->device_reset_max_id))\n\t\treturn -EINVAL;\n\n\treturn reset_spec->args[0];\n}\n\nstatic int at91_rcdev_init(struct at91_reset *reset,\n\t\t\t   struct platform_device *pdev)\n{\n\tif (!reset->data->n_device_reset)\n\t\treturn 0;\n\n\treset->dev_base = devm_of_iomap(&pdev->dev, pdev->dev.of_node, 1,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(reset->dev_base))\n\t\treturn -ENODEV;\n\n\tspin_lock_init(&reset->lock);\n\treset->rcdev.ops = &at91_reset_ops;\n\treset->rcdev.owner = THIS_MODULE;\n\treset->rcdev.of_node = pdev->dev.of_node;\n\treset->rcdev.nr_resets = reset->data->n_device_reset;\n\treset->rcdev.of_reset_n_cells = 1;\n\treset->rcdev.of_xlate = at91_reset_of_xlate;\n\n\treturn devm_reset_controller_register(&pdev->dev, &reset->rcdev);\n}\n\nstatic int __init at91_reset_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct at91_reset *reset;\n\tstruct device_node *np;\n\tint ret, idx = 0;\n\n\treset = devm_kzalloc(&pdev->dev, sizeof(*reset), GFP_KERNEL);\n\tif (!reset)\n\t\treturn -ENOMEM;\n\n\treset->rstc_base = devm_of_iomap(&pdev->dev, pdev->dev.of_node, 0, NULL);\n\tif (IS_ERR(reset->rstc_base)) {\n\t\tdev_err(&pdev->dev, \"Could not map reset controller address\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_compatible(pdev->dev.of_node, \"atmel,sama5d3-rstc\")) {\n\t\t \n\t\tfor_each_matching_node_and_match(np, at91_ramc_of_match, &match) {\n\t\t\treset->ramc_lpr = (u32)match->data;\n\t\t\treset->ramc_base[idx] = devm_of_iomap(&pdev->dev, np, 0, NULL);\n\t\t\tif (IS_ERR(reset->ramc_base[idx])) {\n\t\t\t\tdev_err(&pdev->dev, \"Could not map ram controller address\\n\");\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treset->data = device_get_match_data(&pdev->dev);\n\tif (!reset->data)\n\t\treturn -ENODEV;\n\n\treset->nb.notifier_call = at91_reset;\n\treset->nb.priority = 192;\n\n\treset->sclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(reset->sclk))\n\t\treturn PTR_ERR(reset->sclk);\n\n\tret = clk_prepare_enable(reset->sclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not enable slow clock\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, reset);\n\n\tret = at91_rcdev_init(reset, pdev);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"microchip,sam9x60-rstc\")) {\n\t\tu32 val = readl(reset->rstc_base + AT91_RSTC_MR);\n\n\t\twritel(AT91_RSTC_KEY | AT91_RSTC_URSTASYNC | val,\n\t\t       reset->rstc_base + AT91_RSTC_MR);\n\t}\n\n\tret = register_restart_handler(&reset->nb);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = device_create_file(&pdev->dev, &dev_attr_power_on_reason);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not create sysfs entry\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"Starting after %s\\n\", at91_reset_reason(reset));\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(reset->sclk);\n\treturn ret;\n}\n\nstatic int __exit at91_reset_remove(struct platform_device *pdev)\n{\n\tstruct at91_reset *reset = platform_get_drvdata(pdev);\n\n\tunregister_restart_handler(&reset->nb);\n\tclk_disable_unprepare(reset->sclk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver at91_reset_driver = {\n\t.remove = __exit_p(at91_reset_remove),\n\t.driver = {\n\t\t.name = \"at91-reset\",\n\t\t.of_match_table = at91_reset_of_match,\n\t},\n};\nmodule_platform_driver_probe(at91_reset_driver, at91_reset_probe);\n\nMODULE_AUTHOR(\"Atmel Corporation\");\nMODULE_DESCRIPTION(\"Reset driver for Atmel SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}