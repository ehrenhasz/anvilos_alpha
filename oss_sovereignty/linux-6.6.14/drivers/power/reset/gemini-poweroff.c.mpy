{
  "module_name": "gemini-poweroff.c",
  "hash_id": "242e346adef01fb103307d159ec894ac753cdf90763ad72157f977830b452c2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/gemini-poweroff.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/reboot.h>\n\n#define GEMINI_PWC_ID\t\t0x00010500\n#define\tGEMINI_PWC_IDREG\t0x00\n#define\tGEMINI_PWC_CTRLREG\t0x04\n#define\tGEMINI_PWC_STATREG\t0x08\n\n#define GEMINI_CTRL_SHUTDOWN\tBIT(0)\n#define GEMINI_CTRL_ENABLE\tBIT(1)\n#define GEMINI_CTRL_IRQ_CLR\tBIT(2)\n\n#define GEMINI_STAT_CIR\t\tBIT(4)\n#define\tGEMINI_STAT_RTC\t\tBIT(5)\n#define\tGEMINI_STAT_POWERBUTTON\tBIT(6)\n\nstruct gemini_powercon {\n        struct device           *dev;\n        void __iomem            *base;\n};\n\nstatic irqreturn_t gemini_powerbutton_interrupt(int irq, void *data)\n{\n\tstruct gemini_powercon *gpw = data;\n\tu32 val;\n\n\t \n\tval = readl(gpw->base + GEMINI_PWC_CTRLREG);\n\tval |= GEMINI_CTRL_IRQ_CLR;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n\n\tval = readl(gpw->base + GEMINI_PWC_STATREG);\n\tval &= 0x70U;\n\tswitch (val) {\n\tcase GEMINI_STAT_CIR:\n\t\t \n\t\tdev_info(gpw->dev, \"infrared poweroff - ignored\\n\");\n\t\tbreak;\n\tcase GEMINI_STAT_RTC:\n\t\tdev_info(gpw->dev, \"RTC poweroff\\n\");\n\t\torderly_poweroff(true);\n\t\tbreak;\n\tcase GEMINI_STAT_POWERBUTTON:\n\t\tdev_info(gpw->dev, \"poweroff button pressed\\n\");\n\t\torderly_poweroff(true);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(gpw->dev, \"other power management IRQ\\n\");\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic struct gemini_powercon *gpw_poweroff;\n\nstatic void gemini_poweroff(void)\n{\n\tstruct gemini_powercon *gpw = gpw_poweroff;\n\tu32 val;\n\n\tdev_crit(gpw->dev, \"Gemini power off\\n\");\n\tval = readl(gpw->base + GEMINI_PWC_CTRLREG);\n\tval |= GEMINI_CTRL_ENABLE | GEMINI_CTRL_IRQ_CLR;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n\n\tval &= ~GEMINI_CTRL_ENABLE;\n\tval |= GEMINI_CTRL_SHUTDOWN;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n}\n\nstatic int gemini_poweroff_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gemini_powercon *gpw;\n\tu32 val;\n\tint irq;\n\tint ret;\n\n\tgpw = devm_kzalloc(dev, sizeof(*gpw), GFP_KERNEL);\n\tif (!gpw)\n\t\treturn -ENOMEM;\n\n\tgpw->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpw->base))\n\t\treturn PTR_ERR(gpw->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tgpw->dev = dev;\n\n\tval = readl(gpw->base + GEMINI_PWC_IDREG);\n\tval &= 0xFFFFFF00U;\n\tif (val != GEMINI_PWC_ID) {\n\t\tdev_err(dev, \"wrong power controller ID: %08x\\n\",\n\t\t\tval);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tval = readl(gpw->base + GEMINI_PWC_CTRLREG);\n\tval |= GEMINI_CTRL_ENABLE;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n\n\t \n\tval = readl(gpw->base + GEMINI_PWC_CTRLREG);\n\tval |= GEMINI_CTRL_IRQ_CLR;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n\n\t \n\tval = readl(gpw->base + GEMINI_PWC_STATREG);\n\twhile (val & 0x70U)\n\t\tval = readl(gpw->base + GEMINI_PWC_STATREG);\n\n\t \n\tval = readl(gpw->base + GEMINI_PWC_CTRLREG);\n\tval |= GEMINI_CTRL_IRQ_CLR;\n\twritel(val, gpw->base + GEMINI_PWC_CTRLREG);\n\n\tret = devm_request_irq(dev, irq, gemini_powerbutton_interrupt, 0,\n\t\t\t       \"poweroff\", gpw);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_power_off = gemini_poweroff;\n\tgpw_poweroff = gpw;\n\n\tdev_info(dev, \"Gemini poweroff driver registered\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gemini_poweroff_of_match[] = {\n\t{\n\t\t.compatible = \"cortina,gemini-power-controller\",\n\t},\n\t{}\n};\n\nstatic struct platform_driver gemini_poweroff_driver = {\n\t.probe = gemini_poweroff_probe,\n\t.driver = {\n\t\t.name = \"gemini-poweroff\",\n\t\t.of_match_table = gemini_poweroff_of_match,\n\t},\n};\nbuiltin_platform_driver(gemini_poweroff_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}