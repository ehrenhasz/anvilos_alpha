{
  "module_name": "reboot-mode.c",
  "hash_id": "100aec20455a34c47c127467e2056c8fa6bfdf65a50f0a896cb4ad5c83a66375",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/reboot-mode.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/reboot.h>\n#include <linux/reboot-mode.h>\n\n#define PREFIX \"mode-\"\n\nstruct mode_info {\n\tconst char *mode;\n\tu32 magic;\n\tstruct list_head list;\n};\n\nstatic unsigned int get_reboot_mode_magic(struct reboot_mode_driver *reboot,\n\t\t\t\t\t  const char *cmd)\n{\n\tconst char *normal = \"normal\";\n\tint magic = 0;\n\tstruct mode_info *info;\n\n\tif (!cmd)\n\t\tcmd = normal;\n\n\tlist_for_each_entry(info, &reboot->head, list) {\n\t\tif (!strcmp(info->mode, cmd)) {\n\t\t\tmagic = info->magic;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn magic;\n}\n\nstatic int reboot_mode_notify(struct notifier_block *this,\n\t\t\t      unsigned long mode, void *cmd)\n{\n\tstruct reboot_mode_driver *reboot;\n\tunsigned int magic;\n\n\treboot = container_of(this, struct reboot_mode_driver, reboot_notifier);\n\tmagic = get_reboot_mode_magic(reboot, cmd);\n\tif (magic)\n\t\treboot->write(reboot, magic);\n\n\treturn NOTIFY_DONE;\n}\n\n \nint reboot_mode_register(struct reboot_mode_driver *reboot)\n{\n\tstruct mode_info *info;\n\tstruct property *prop;\n\tstruct device_node *np = reboot->dev->of_node;\n\tsize_t len = strlen(PREFIX);\n\tint ret;\n\n\tINIT_LIST_HEAD(&reboot->head);\n\n\tfor_each_property_of_node(np, prop) {\n\t\tif (strncmp(prop->name, PREFIX, len))\n\t\t\tcontinue;\n\n\t\tinfo = devm_kzalloc(reboot->dev, sizeof(*info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (of_property_read_u32(np, prop->name, &info->magic)) {\n\t\t\tdev_err(reboot->dev, \"reboot mode %s without magic number\\n\",\n\t\t\t\tinfo->mode);\n\t\t\tdevm_kfree(reboot->dev, info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo->mode = kstrdup_const(prop->name + len, GFP_KERNEL);\n\t\tif (!info->mode) {\n\t\t\tret =  -ENOMEM;\n\t\t\tgoto error;\n\t\t} else if (info->mode[0] == '\\0') {\n\t\t\tkfree_const(info->mode);\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(reboot->dev, \"invalid mode name(%s): too short!\\n\",\n\t\t\t\tprop->name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tlist_add_tail(&info->list, &reboot->head);\n\t}\n\n\treboot->reboot_notifier.notifier_call = reboot_mode_notify;\n\tregister_reboot_notifier(&reboot->reboot_notifier);\n\n\treturn 0;\n\nerror:\n\tlist_for_each_entry(info, &reboot->head, list)\n\t\tkfree_const(info->mode);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(reboot_mode_register);\n\n \nint reboot_mode_unregister(struct reboot_mode_driver *reboot)\n{\n\tstruct mode_info *info;\n\n\tunregister_reboot_notifier(&reboot->reboot_notifier);\n\n\tlist_for_each_entry(info, &reboot->head, list)\n\t\tkfree_const(info->mode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(reboot_mode_unregister);\n\nstatic void devm_reboot_mode_release(struct device *dev, void *res)\n{\n\treboot_mode_unregister(*(struct reboot_mode_driver **)res);\n}\n\n \nint devm_reboot_mode_register(struct device *dev,\n\t\t\t      struct reboot_mode_driver *reboot)\n{\n\tstruct reboot_mode_driver **dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_reboot_mode_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\trc = reboot_mode_register(reboot);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\t*dr = reboot;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_reboot_mode_register);\n\nstatic int devm_reboot_mode_match(struct device *dev, void *res, void *data)\n{\n\tstruct reboot_mode_driver **p = res;\n\n\tif (WARN_ON(!p || !*p))\n\t\treturn 0;\n\n\treturn *p == data;\n}\n\n \nvoid devm_reboot_mode_unregister(struct device *dev,\n\t\t\t\t struct reboot_mode_driver *reboot)\n{\n\tWARN_ON(devres_release(dev,\n\t\t\t       devm_reboot_mode_release,\n\t\t\t       devm_reboot_mode_match, reboot));\n}\nEXPORT_SYMBOL_GPL(devm_reboot_mode_unregister);\n\nMODULE_AUTHOR(\"Andy Yan <andy.yan@rock-chips.com>\");\nMODULE_DESCRIPTION(\"System reboot mode core library\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}