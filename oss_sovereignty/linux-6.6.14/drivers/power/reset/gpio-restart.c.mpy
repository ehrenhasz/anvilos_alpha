{
  "module_name": "gpio-restart.c",
  "hash_id": "87b39893ca42fe97d20595f453cedb48f4340fcbdb8fc3682b6b052703c0ec4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/power/reset/gpio-restart.c",
  "human_readable_source": "\n \n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\nstruct gpio_restart {\n\tstruct gpio_desc *reset_gpio;\n\tstruct notifier_block restart_handler;\n\tu32 active_delay_ms;\n\tu32 inactive_delay_ms;\n\tu32 wait_delay_ms;\n};\n\nstatic int gpio_restart_notify(struct notifier_block *this,\n\t\t\t\tunsigned long mode, void *cmd)\n{\n\tstruct gpio_restart *gpio_restart =\n\t\tcontainer_of(this, struct gpio_restart, restart_handler);\n\n\t \n\tgpiod_direction_output(gpio_restart->reset_gpio, 1);\n\tmdelay(gpio_restart->active_delay_ms);\n\n\t \n\tgpiod_set_value(gpio_restart->reset_gpio, 0);\n\tmdelay(gpio_restart->inactive_delay_ms);\n\n\t \n\tgpiod_set_value(gpio_restart->reset_gpio, 1);\n\n\t \n\tmdelay(gpio_restart->wait_delay_ms);\n\n\tWARN_ON(1);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int gpio_restart_probe(struct platform_device *pdev)\n{\n\tstruct gpio_restart *gpio_restart;\n\tbool open_source = false;\n\tu32 property;\n\tint ret;\n\n\tgpio_restart = devm_kzalloc(&pdev->dev, sizeof(*gpio_restart),\n\t\t\tGFP_KERNEL);\n\tif (!gpio_restart)\n\t\treturn -ENOMEM;\n\n\topen_source = of_property_read_bool(pdev->dev.of_node, \"open-source\");\n\n\tgpio_restart->reset_gpio = devm_gpiod_get(&pdev->dev, NULL,\n\t\t\topen_source ? GPIOD_IN : GPIOD_OUT_LOW);\n\tret = PTR_ERR_OR_ZERO(gpio_restart->reset_gpio);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Could not get reset GPIO\\n\");\n\t\treturn ret;\n\t}\n\n\tgpio_restart->restart_handler.notifier_call = gpio_restart_notify;\n\tgpio_restart->restart_handler.priority = 129;\n\tgpio_restart->active_delay_ms = 100;\n\tgpio_restart->inactive_delay_ms = 100;\n\tgpio_restart->wait_delay_ms = 3000;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"priority\", &property);\n\tif (!ret) {\n\t\tif (property > 255)\n\t\t\tdev_err(&pdev->dev, \"Invalid priority property: %u\\n\",\n\t\t\t\t\tproperty);\n\t\telse\n\t\t\tgpio_restart->restart_handler.priority = property;\n\t}\n\n\tof_property_read_u32(pdev->dev.of_node, \"active-delay\",\n\t\t\t&gpio_restart->active_delay_ms);\n\tof_property_read_u32(pdev->dev.of_node, \"inactive-delay\",\n\t\t\t&gpio_restart->inactive_delay_ms);\n\tof_property_read_u32(pdev->dev.of_node, \"wait-delay\",\n\t\t\t&gpio_restart->wait_delay_ms);\n\n\tplatform_set_drvdata(pdev, gpio_restart);\n\n\tret = register_restart_handler(&gpio_restart->restart_handler);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: cannot register restart handler, %d\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void gpio_restart_remove(struct platform_device *pdev)\n{\n\tstruct gpio_restart *gpio_restart = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = unregister_restart_handler(&gpio_restart->restart_handler);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: cannot unregister restart handler, %d\\n\",\n\t\t\t\t__func__, ret);\n\t}\n}\n\nstatic const struct of_device_id of_gpio_restart_match[] = {\n\t{ .compatible = \"gpio-restart\", },\n\t{},\n};\n\nstatic struct platform_driver gpio_restart_driver = {\n\t.probe = gpio_restart_probe,\n\t.remove_new = gpio_restart_remove,\n\t.driver = {\n\t\t.name = \"restart-gpio\",\n\t\t.of_match_table = of_gpio_restart_match,\n\t},\n};\n\nmodule_platform_driver(gpio_restart_driver);\n\nMODULE_AUTHOR(\"David Riley <davidriley@chromium.org>\");\nMODULE_DESCRIPTION(\"GPIO restart driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}