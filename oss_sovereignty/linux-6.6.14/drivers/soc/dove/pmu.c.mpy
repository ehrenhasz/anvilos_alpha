{
  "module_name": "pmu.c",
  "hash_id": "6d272bee9b02ff00936a2f123bec3d52fbf09b2db6f44097afb734794f6b25c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/dove/pmu.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/reset.h>\n#include <linux/reset-controller.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/soc/dove/pmu.h>\n#include <linux/spinlock.h>\n\n#define NR_PMU_IRQS\t\t7\n\n#define PMC_SW_RST\t\t0x30\n#define PMC_IRQ_CAUSE\t\t0x50\n#define PMC_IRQ_MASK\t\t0x54\n\n#define PMU_PWR\t\t\t0x10\n#define PMU_ISO\t\t\t0x58\n\nstruct pmu_data {\n\tspinlock_t lock;\n\tstruct device_node *of_node;\n\tvoid __iomem *pmc_base;\n\tvoid __iomem *pmu_base;\n\tstruct irq_chip_generic *irq_gc;\n\tstruct irq_domain *irq_domain;\n#ifdef CONFIG_RESET_CONTROLLER\n\tstruct reset_controller_dev reset;\n#endif\n};\n\n \n#ifdef CONFIG_RESET_CONTROLLER\n#define rcdev_to_pmu(rcdev) container_of(rcdev, struct pmu_data, reset)\n\nstatic int pmu_reset_reset(struct reset_controller_dev *rc, unsigned long id)\n{\n\tstruct pmu_data *pmu = rcdev_to_pmu(rc);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\tval = readl_relaxed(pmu->pmc_base + PMC_SW_RST);\n\twritel_relaxed(val & ~BIT(id), pmu->pmc_base + PMC_SW_RST);\n\twritel_relaxed(val | BIT(id), pmu->pmc_base + PMC_SW_RST);\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pmu_reset_assert(struct reset_controller_dev *rc, unsigned long id)\n{\n\tstruct pmu_data *pmu = rcdev_to_pmu(rc);\n\tunsigned long flags;\n\tu32 val = ~BIT(id);\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\tval &= readl_relaxed(pmu->pmc_base + PMC_SW_RST);\n\twritel_relaxed(val, pmu->pmc_base + PMC_SW_RST);\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pmu_reset_deassert(struct reset_controller_dev *rc, unsigned long id)\n{\n\tstruct pmu_data *pmu = rcdev_to_pmu(rc);\n\tunsigned long flags;\n\tu32 val = BIT(id);\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\tval |= readl_relaxed(pmu->pmc_base + PMC_SW_RST);\n\twritel_relaxed(val, pmu->pmc_base + PMC_SW_RST);\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops pmu_reset_ops = {\n\t.reset = pmu_reset_reset,\n\t.assert = pmu_reset_assert,\n\t.deassert = pmu_reset_deassert,\n};\n\nstatic struct reset_controller_dev pmu_reset __initdata = {\n\t.ops = &pmu_reset_ops,\n\t.owner = THIS_MODULE,\n\t.nr_resets = 32,\n};\n\nstatic void __init pmu_reset_init(struct pmu_data *pmu)\n{\n\tint ret;\n\n\tpmu->reset = pmu_reset;\n\tpmu->reset.of_node = pmu->of_node;\n\n\tret = reset_controller_register(&pmu->reset);\n\tif (ret)\n\t\tpr_err(\"pmu: %s failed: %d\\n\", \"reset_controller_register\", ret);\n}\n#else\nstatic void __init pmu_reset_init(struct pmu_data *pmu)\n{\n}\n#endif\n\nstruct pmu_domain {\n\tstruct pmu_data *pmu;\n\tu32 pwr_mask;\n\tu32 rst_mask;\n\tu32 iso_mask;\n\tstruct generic_pm_domain base;\n};\n\n#define to_pmu_domain(dom) container_of(dom, struct pmu_domain, base)\n\n \nstatic int pmu_domain_power_off(struct generic_pm_domain *domain)\n{\n\tstruct pmu_domain *pmu_dom = to_pmu_domain(domain);\n\tstruct pmu_data *pmu = pmu_dom->pmu;\n\tunsigned long flags;\n\tunsigned int val;\n\tvoid __iomem *pmu_base = pmu->pmu_base;\n\tvoid __iomem *pmc_base = pmu->pmc_base;\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\n\t \n\tif (pmu_dom->iso_mask) {\n\t\tval = ~pmu_dom->iso_mask;\n\t\tval &= readl_relaxed(pmu_base + PMU_ISO);\n\t\twritel_relaxed(val, pmu_base + PMU_ISO);\n\t}\n\n\t \n\tif (pmu_dom->rst_mask) {\n\t\tval = ~pmu_dom->rst_mask;\n\t\tval &= readl_relaxed(pmc_base + PMC_SW_RST);\n\t\twritel_relaxed(val, pmc_base + PMC_SW_RST);\n\t}\n\n\t \n\tval = readl_relaxed(pmu_base + PMU_PWR) | pmu_dom->pwr_mask;\n\twritel_relaxed(val, pmu_base + PMU_PWR);\n\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int pmu_domain_power_on(struct generic_pm_domain *domain)\n{\n\tstruct pmu_domain *pmu_dom = to_pmu_domain(domain);\n\tstruct pmu_data *pmu = pmu_dom->pmu;\n\tunsigned long flags;\n\tunsigned int val;\n\tvoid __iomem *pmu_base = pmu->pmu_base;\n\tvoid __iomem *pmc_base = pmu->pmc_base;\n\n\tspin_lock_irqsave(&pmu->lock, flags);\n\n\t \n\tval = ~pmu_dom->pwr_mask & readl_relaxed(pmu_base + PMU_PWR);\n\twritel_relaxed(val, pmu_base + PMU_PWR);\n\n\t \n\tif (pmu_dom->rst_mask) {\n\t\tval = pmu_dom->rst_mask;\n\t\tval |= readl_relaxed(pmc_base + PMC_SW_RST);\n\t\twritel_relaxed(val, pmc_base + PMC_SW_RST);\n\t}\n\n\t \n\tif (pmu_dom->iso_mask) {\n\t\tval = pmu_dom->iso_mask;\n\t\tval |= readl_relaxed(pmu_base + PMU_ISO);\n\t\twritel_relaxed(val, pmu_base + PMU_ISO);\n\t}\n\n\tspin_unlock_irqrestore(&pmu->lock, flags);\n\n\treturn 0;\n}\n\nstatic void __pmu_domain_register(struct pmu_domain *domain,\n\tstruct device_node *np)\n{\n\tunsigned int val = readl_relaxed(domain->pmu->pmu_base + PMU_PWR);\n\n\tdomain->base.power_off = pmu_domain_power_off;\n\tdomain->base.power_on = pmu_domain_power_on;\n\n\tpm_genpd_init(&domain->base, NULL, !(val & domain->pwr_mask));\n\n\tif (np)\n\t\tof_genpd_add_provider_simple(np, &domain->base);\n}\n\n \nstatic void pmu_irq_handler(struct irq_desc *desc)\n{\n\tstruct pmu_data *pmu = irq_desc_get_handler_data(desc);\n\tstruct irq_chip_generic *gc = pmu->irq_gc;\n\tstruct irq_domain *domain = pmu->irq_domain;\n\tvoid __iomem *base = gc->reg_base;\n\tu32 stat = readl_relaxed(base + PMC_IRQ_CAUSE) & gc->mask_cache;\n\tu32 done = ~0;\n\n\tif (stat == 0) {\n\t\thandle_bad_irq(desc);\n\t\treturn;\n\t}\n\n\twhile (stat) {\n\t\tu32 hwirq = fls(stat) - 1;\n\n\t\tstat &= ~(1 << hwirq);\n\t\tdone &= ~(1 << hwirq);\n\n\t\tgeneric_handle_irq(irq_find_mapping(domain, hwirq));\n\t}\n\n\t \n\tirq_gc_lock(gc);\n\tdone &= readl_relaxed(base + PMC_IRQ_CAUSE);\n\twritel_relaxed(done, base + PMC_IRQ_CAUSE);\n\tirq_gc_unlock(gc);\n}\n\nstatic int __init dove_init_pmu_irq(struct pmu_data *pmu, int irq)\n{\n\tconst char *name = \"pmu_irq\";\n\tstruct irq_chip_generic *gc;\n\tstruct irq_domain *domain;\n\tint ret;\n\n\t \n\twritel(0, pmu->pmc_base + PMC_IRQ_MASK);\n\twritel(0, pmu->pmc_base + PMC_IRQ_CAUSE);\n\n\tdomain = irq_domain_add_linear(pmu->of_node, NR_PMU_IRQS,\n\t\t\t\t       &irq_generic_chip_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"%s: unable to add irq domain\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = irq_alloc_domain_generic_chips(domain, NR_PMU_IRQS, 1, name,\n\t\t\t\t\t     handle_level_irq,\n\t\t\t\t\t     IRQ_NOREQUEST | IRQ_NOPROBE, 0,\n\t\t\t\t\t     IRQ_GC_INIT_MASK_CACHE);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to alloc irq domain gc: %d\\n\", name, ret);\n\t\tirq_domain_remove(domain);\n\t\treturn ret;\n\t}\n\n\tgc = irq_get_domain_generic_chip(domain, 0);\n\tgc->reg_base = pmu->pmc_base;\n\tgc->chip_types[0].regs.mask = PMC_IRQ_MASK;\n\tgc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\n\tgc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\n\n\tpmu->irq_domain = domain;\n\tpmu->irq_gc = gc;\n\n\tirq_set_handler_data(irq, pmu);\n\tirq_set_chained_handler(irq, pmu_irq_handler);\n\n\treturn 0;\n}\n\nint __init dove_init_pmu_legacy(const struct dove_pmu_initdata *initdata)\n{\n\tconst struct dove_pmu_domain_initdata *domain_initdata;\n\tstruct pmu_data *pmu;\n\tint ret;\n\n\tpmu = kzalloc(sizeof(*pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&pmu->lock);\n\tpmu->pmc_base = initdata->pmc_base;\n\tpmu->pmu_base = initdata->pmu_base;\n\n\tpmu_reset_init(pmu);\n\tfor (domain_initdata = initdata->domains; domain_initdata->name;\n\t     domain_initdata++) {\n\t\tstruct pmu_domain *domain;\n\n\t\tdomain = kzalloc(sizeof(*domain), GFP_KERNEL);\n\t\tif (domain) {\n\t\t\tdomain->pmu = pmu;\n\t\t\tdomain->pwr_mask = domain_initdata->pwr_mask;\n\t\t\tdomain->rst_mask = domain_initdata->rst_mask;\n\t\t\tdomain->iso_mask = domain_initdata->iso_mask;\n\t\t\tdomain->base.name = domain_initdata->name;\n\n\t\t\t__pmu_domain_register(domain, NULL);\n\t\t}\n\t}\n\n\tret = dove_init_pmu_irq(pmu, initdata->irq);\n\tif (ret)\n\t\tpr_err(\"dove_init_pmu_irq() failed: %d\\n\", ret);\n\n\tif (pmu->irq_domain)\n\t\tirq_domain_associate_many(pmu->irq_domain,\n\t\t\t\t\t  initdata->irq_domain_start,\n\t\t\t\t\t  0, NR_PMU_IRQS);\n\n\treturn 0;\n}\n\n \nint __init dove_init_pmu(void)\n{\n\tstruct device_node *np_pmu, *domains_node, *np;\n\tstruct pmu_data *pmu;\n\tint ret, parent_irq;\n\n\t \n\tnp_pmu = of_find_compatible_node(NULL, NULL, \"marvell,dove-pmu\");\n\tif (!np_pmu)\n\t\treturn 0;\n\n\tdomains_node = of_get_child_by_name(np_pmu, \"domains\");\n\tif (!domains_node) {\n\t\tpr_err(\"%pOFn: failed to find domains sub-node\\n\", np_pmu);\n\t\treturn 0;\n\t}\n\n\tpmu = kzalloc(sizeof(*pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&pmu->lock);\n\tpmu->of_node = np_pmu;\n\tpmu->pmc_base = of_iomap(pmu->of_node, 0);\n\tpmu->pmu_base = of_iomap(pmu->of_node, 1);\n\tif (!pmu->pmc_base || !pmu->pmu_base) {\n\t\tpr_err(\"%pOFn: failed to map PMU\\n\", np_pmu);\n\t\tiounmap(pmu->pmu_base);\n\t\tiounmap(pmu->pmc_base);\n\t\tkfree(pmu);\n\t\treturn -ENOMEM;\n\t}\n\n\tpmu_reset_init(pmu);\n\n\tfor_each_available_child_of_node(domains_node, np) {\n\t\tstruct of_phandle_args args;\n\t\tstruct pmu_domain *domain;\n\n\t\tdomain = kzalloc(sizeof(*domain), GFP_KERNEL);\n\t\tif (!domain)\n\t\t\tbreak;\n\n\t\tdomain->pmu = pmu;\n\t\tdomain->base.name = kasprintf(GFP_KERNEL, \"%pOFn\", np);\n\t\tif (!domain->base.name) {\n\t\t\tkfree(domain);\n\t\t\tbreak;\n\t\t}\n\n\t\tof_property_read_u32(np, \"marvell,pmu_pwr_mask\",\n\t\t\t\t     &domain->pwr_mask);\n\t\tof_property_read_u32(np, \"marvell,pmu_iso_mask\",\n\t\t\t\t     &domain->iso_mask);\n\n\t\t \n\t\tret = of_parse_phandle_with_args(np, \"resets\", \"#reset-cells\",\n\t\t\t\t\t\t 0, &args);\n\t\tif (ret == 0) {\n\t\t\tif (args.np == pmu->of_node)\n\t\t\t\tdomain->rst_mask = BIT(args.args[0]);\n\t\t\tof_node_put(args.np);\n\t\t}\n\n\t\t__pmu_domain_register(domain, np);\n\t}\n\n\t \n\tparent_irq = irq_of_parse_and_map(pmu->of_node, 0);\n\tif (!parent_irq) {\n\t\tpr_err(\"%pOFn: no interrupt specified\\n\", np_pmu);\n\t} else {\n\t\tret = dove_init_pmu_irq(pmu, parent_irq);\n\t\tif (ret)\n\t\t\tpr_err(\"dove_init_pmu_irq() failed: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}