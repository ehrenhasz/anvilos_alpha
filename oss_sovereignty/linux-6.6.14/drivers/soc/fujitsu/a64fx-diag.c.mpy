{
  "module_name": "a64fx-diag.c",
  "hash_id": "e5b390dfbda423730f504dc165936d3816c6d9f2a999e8fac814019ea814d20e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fujitsu/a64fx-diag.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define A64FX_DIAG_IRQ 1\n#define BMC_DIAG_INTERRUPT_ENABLE 0x40\n#define BMC_DIAG_INTERRUPT_STATUS 0x44\n#define BMC_DIAG_INTERRUPT_MASK BIT(31)\n\nstruct a64fx_diag_priv {\n\tvoid __iomem *mmsc_reg_base;\n\tint irq;\n\tbool has_nmi;\n};\n\nstatic irqreturn_t a64fx_diag_handler_nmi(int irq, void *dev_id)\n{\n\tnmi_panic(NULL, \"a64fx_diag: interrupt received\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t a64fx_diag_handler_irq(int irq, void *dev_id)\n{\n\tpanic(\"a64fx_diag: interrupt received\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void a64fx_diag_interrupt_clear(struct a64fx_diag_priv *priv)\n{\n\tvoid __iomem *diag_status_reg_addr;\n\tu32 mmsc;\n\n\tdiag_status_reg_addr = priv->mmsc_reg_base + BMC_DIAG_INTERRUPT_STATUS;\n\tmmsc = readl(diag_status_reg_addr);\n\tif (mmsc & BMC_DIAG_INTERRUPT_MASK)\n\t\twritel(BMC_DIAG_INTERRUPT_MASK, diag_status_reg_addr);\n}\n\nstatic void a64fx_diag_interrupt_enable(struct a64fx_diag_priv *priv)\n{\n\tvoid __iomem *diag_enable_reg_addr;\n\tu32 mmsc;\n\n\tdiag_enable_reg_addr = priv->mmsc_reg_base + BMC_DIAG_INTERRUPT_ENABLE;\n\tmmsc = readl(diag_enable_reg_addr);\n\tif (!(mmsc & BMC_DIAG_INTERRUPT_MASK)) {\n\t\tmmsc |= BMC_DIAG_INTERRUPT_MASK;\n\t\twritel(mmsc, diag_enable_reg_addr);\n\t}\n}\n\nstatic void a64fx_diag_interrupt_disable(struct a64fx_diag_priv *priv)\n{\n\tvoid __iomem *diag_enable_reg_addr;\n\tu32 mmsc;\n\n\tdiag_enable_reg_addr = priv->mmsc_reg_base + BMC_DIAG_INTERRUPT_ENABLE;\n\tmmsc = readl(diag_enable_reg_addr);\n\tif (mmsc & BMC_DIAG_INTERRUPT_MASK) {\n\t\tmmsc &= ~BMC_DIAG_INTERRUPT_MASK;\n\t\twritel(mmsc, diag_enable_reg_addr);\n\t}\n}\n\nstatic int a64fx_diag_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct a64fx_diag_priv *priv;\n\tunsigned long irq_flags;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv->mmsc_reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mmsc_reg_base))\n\t\treturn PTR_ERR(priv->mmsc_reg_base);\n\n\tpriv->irq = platform_get_irq(pdev, A64FX_DIAG_IRQ);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tirq_flags = IRQF_PERCPU | IRQF_NOBALANCING | IRQF_NO_AUTOEN |\n\t\t   IRQF_NO_THREAD;\n\tret = request_nmi(priv->irq, &a64fx_diag_handler_nmi, irq_flags,\n\t\t\t\"a64fx_diag_nmi\", NULL);\n\tif (ret) {\n\t\tret = request_irq(priv->irq, &a64fx_diag_handler_irq,\n\t\t\t\tirq_flags, \"a64fx_diag_irq\", NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"cannot register IRQ %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tenable_irq(priv->irq);\n\t} else {\n\t\tenable_nmi(priv->irq);\n\t\tpriv->has_nmi = true;\n\t}\n\n\ta64fx_diag_interrupt_clear(priv);\n\ta64fx_diag_interrupt_enable(priv);\n\n\treturn 0;\n}\n\nstatic int a64fx_diag_remove(struct platform_device *pdev)\n{\n\tstruct a64fx_diag_priv *priv = platform_get_drvdata(pdev);\n\n\ta64fx_diag_interrupt_disable(priv);\n\ta64fx_diag_interrupt_clear(priv);\n\n\tif (priv->has_nmi)\n\t\tfree_nmi(priv->irq, NULL);\n\telse\n\t\tfree_irq(priv->irq, NULL);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id a64fx_diag_acpi_match[] = {\n\t{ \"FUJI2007\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, a64fx_diag_acpi_match);\n\n\nstatic struct platform_driver a64fx_diag_driver = {\n\t.driver = {\n\t\t.name = \"a64fx_diag_driver\",\n\t\t.acpi_match_table = ACPI_PTR(a64fx_diag_acpi_match),\n\t},\n\t.probe = a64fx_diag_probe,\n\t.remove = a64fx_diag_remove,\n};\n\nmodule_platform_driver(a64fx_diag_driver);\n\nMODULE_AUTHOR(\"Hitomi Hasegawa <hasegawa-hitomi@fujitsu.com>\");\nMODULE_DESCRIPTION(\"A64FX diag driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}