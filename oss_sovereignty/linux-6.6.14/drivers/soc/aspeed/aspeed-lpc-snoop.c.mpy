{
  "module_name": "aspeed-lpc-snoop.c",
  "hash_id": "a2c6d0a4e28c7d609cf2adbd62e402016d3589125706396639ec957a41b4ce3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/aspeed/aspeed-lpc-snoop.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/kfifo.h>\n#include <linux/mfd/syscon.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/regmap.h>\n\n#define DEVICE_NAME\t\"aspeed-lpc-snoop\"\n\n#define NUM_SNOOP_CHANNELS 2\n#define SNOOP_FIFO_SIZE 2048\n\n#define HICR5\t0x80\n#define HICR5_EN_SNP0W\t\tBIT(0)\n#define HICR5_ENINT_SNP0W\tBIT(1)\n#define HICR5_EN_SNP1W\t\tBIT(2)\n#define HICR5_ENINT_SNP1W\tBIT(3)\n#define HICR6\t0x84\n#define HICR6_STR_SNP0W\t\tBIT(0)\n#define HICR6_STR_SNP1W\t\tBIT(1)\n#define SNPWADR\t0x90\n#define SNPWADR_CH0_MASK\tGENMASK(15, 0)\n#define SNPWADR_CH0_SHIFT\t0\n#define SNPWADR_CH1_MASK\tGENMASK(31, 16)\n#define SNPWADR_CH1_SHIFT\t16\n#define SNPWDR\t0x94\n#define SNPWDR_CH0_MASK\t\tGENMASK(7, 0)\n#define SNPWDR_CH0_SHIFT\t0\n#define SNPWDR_CH1_MASK\t\tGENMASK(15, 8)\n#define SNPWDR_CH1_SHIFT\t8\n#define HICRB\t0x100\n#define HICRB_ENSNP0D\t\tBIT(14)\n#define HICRB_ENSNP1D\t\tBIT(15)\n\nstruct aspeed_lpc_snoop_model_data {\n\t \n\tunsigned int has_hicrb_ensnp;\n};\n\nstruct aspeed_lpc_snoop_channel {\n\tstruct kfifo\t\tfifo;\n\twait_queue_head_t\twq;\n\tstruct miscdevice\tmiscdev;\n};\n\nstruct aspeed_lpc_snoop {\n\tstruct regmap\t\t*regmap;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tstruct aspeed_lpc_snoop_channel chan[NUM_SNOOP_CHANNELS];\n};\n\nstatic struct aspeed_lpc_snoop_channel *snoop_file_to_chan(struct file *file)\n{\n\treturn container_of(file->private_data,\n\t\t\t    struct aspeed_lpc_snoop_channel,\n\t\t\t    miscdev);\n}\n\nstatic ssize_t snoop_file_read(struct file *file, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct aspeed_lpc_snoop_channel *chan = snoop_file_to_chan(file);\n\tunsigned int copied;\n\tint ret = 0;\n\n\tif (kfifo_is_empty(&chan->fifo)) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tret = wait_event_interruptible(chan->wq,\n\t\t\t\t!kfifo_is_empty(&chan->fifo));\n\t\tif (ret == -ERESTARTSYS)\n\t\t\treturn -EINTR;\n\t}\n\tret = kfifo_to_user(&chan->fifo, buffer, count, &copied);\n\tif (ret)\n\t\treturn ret;\n\n\treturn copied;\n}\n\nstatic __poll_t snoop_file_poll(struct file *file,\n\t\t\t\t    struct poll_table_struct *pt)\n{\n\tstruct aspeed_lpc_snoop_channel *chan = snoop_file_to_chan(file);\n\n\tpoll_wait(file, &chan->wq, pt);\n\treturn !kfifo_is_empty(&chan->fifo) ? EPOLLIN : 0;\n}\n\nstatic const struct file_operations snoop_fops = {\n\t.owner  = THIS_MODULE,\n\t.read   = snoop_file_read,\n\t.poll   = snoop_file_poll,\n\t.llseek = noop_llseek,\n};\n\n \nstatic void put_fifo_with_discard(struct aspeed_lpc_snoop_channel *chan, u8 val)\n{\n\tif (!kfifo_initialized(&chan->fifo))\n\t\treturn;\n\tif (kfifo_is_full(&chan->fifo))\n\t\tkfifo_skip(&chan->fifo);\n\tkfifo_put(&chan->fifo, val);\n\twake_up_interruptible(&chan->wq);\n}\n\nstatic irqreturn_t aspeed_lpc_snoop_irq(int irq, void *arg)\n{\n\tstruct aspeed_lpc_snoop *lpc_snoop = arg;\n\tu32 reg, data;\n\n\tif (regmap_read(lpc_snoop->regmap, HICR6, &reg))\n\t\treturn IRQ_NONE;\n\n\t \n\treg &= (HICR6_STR_SNP0W | HICR6_STR_SNP1W);\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\t \n\tregmap_write(lpc_snoop->regmap, HICR6, reg);\n\n\t \n\tregmap_read(lpc_snoop->regmap, SNPWDR, &data);\n\n\tif (reg & HICR6_STR_SNP0W) {\n\t\tu8 val = (data & SNPWDR_CH0_MASK) >> SNPWDR_CH0_SHIFT;\n\n\t\tput_fifo_with_discard(&lpc_snoop->chan[0], val);\n\t}\n\tif (reg & HICR6_STR_SNP1W) {\n\t\tu8 val = (data & SNPWDR_CH1_MASK) >> SNPWDR_CH1_SHIFT;\n\n\t\tput_fifo_with_discard(&lpc_snoop->chan[1], val);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int aspeed_lpc_snoop_config_irq(struct aspeed_lpc_snoop *lpc_snoop,\n\t\t\t\t       struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint rc;\n\n\tlpc_snoop->irq = platform_get_irq(pdev, 0);\n\tif (!lpc_snoop->irq)\n\t\treturn -ENODEV;\n\n\trc = devm_request_irq(dev, lpc_snoop->irq,\n\t\t\t      aspeed_lpc_snoop_irq, IRQF_SHARED,\n\t\t\t      DEVICE_NAME, lpc_snoop);\n\tif (rc < 0) {\n\t\tdev_warn(dev, \"Unable to request IRQ %d\\n\", lpc_snoop->irq);\n\t\tlpc_snoop->irq = 0;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int aspeed_lpc_enable_snoop(struct aspeed_lpc_snoop *lpc_snoop,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   int channel, u16 lpc_port)\n{\n\tint rc = 0;\n\tu32 hicr5_en, snpwadr_mask, snpwadr_shift, hicrb_en;\n\tconst struct aspeed_lpc_snoop_model_data *model_data =\n\t\tof_device_get_match_data(dev);\n\n\tinit_waitqueue_head(&lpc_snoop->chan[channel].wq);\n\t \n\trc = kfifo_alloc(&lpc_snoop->chan[channel].fifo,\n\t\t\t SNOOP_FIFO_SIZE, GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tlpc_snoop->chan[channel].miscdev.minor = MISC_DYNAMIC_MINOR;\n\tlpc_snoop->chan[channel].miscdev.name =\n\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%s%d\", DEVICE_NAME, channel);\n\tlpc_snoop->chan[channel].miscdev.fops = &snoop_fops;\n\tlpc_snoop->chan[channel].miscdev.parent = dev;\n\trc = misc_register(&lpc_snoop->chan[channel].miscdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (channel) {\n\tcase 0:\n\t\thicr5_en = HICR5_EN_SNP0W | HICR5_ENINT_SNP0W;\n\t\tsnpwadr_mask = SNPWADR_CH0_MASK;\n\t\tsnpwadr_shift = SNPWADR_CH0_SHIFT;\n\t\thicrb_en = HICRB_ENSNP0D;\n\t\tbreak;\n\tcase 1:\n\t\thicr5_en = HICR5_EN_SNP1W | HICR5_ENINT_SNP1W;\n\t\tsnpwadr_mask = SNPWADR_CH1_MASK;\n\t\tsnpwadr_shift = SNPWADR_CH1_SHIFT;\n\t\thicrb_en = HICRB_ENSNP1D;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(lpc_snoop->regmap, HICR5, hicr5_en, hicr5_en);\n\tregmap_update_bits(lpc_snoop->regmap, SNPWADR, snpwadr_mask,\n\t\t\t   lpc_port << snpwadr_shift);\n\tif (model_data->has_hicrb_ensnp)\n\t\tregmap_update_bits(lpc_snoop->regmap, HICRB,\n\t\t\t\thicrb_en, hicrb_en);\n\n\treturn rc;\n}\n\nstatic void aspeed_lpc_disable_snoop(struct aspeed_lpc_snoop *lpc_snoop,\n\t\t\t\t     int channel)\n{\n\tswitch (channel) {\n\tcase 0:\n\t\tregmap_update_bits(lpc_snoop->regmap, HICR5,\n\t\t\t\t   HICR5_EN_SNP0W | HICR5_ENINT_SNP0W,\n\t\t\t\t   0);\n\t\tbreak;\n\tcase 1:\n\t\tregmap_update_bits(lpc_snoop->regmap, HICR5,\n\t\t\t\t   HICR5_EN_SNP1W | HICR5_ENINT_SNP1W,\n\t\t\t\t   0);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tkfifo_free(&lpc_snoop->chan[channel].fifo);\n\tmisc_deregister(&lpc_snoop->chan[channel].miscdev);\n}\n\nstatic int aspeed_lpc_snoop_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_lpc_snoop *lpc_snoop;\n\tstruct device *dev;\n\tstruct device_node *np;\n\tu32 port;\n\tint rc;\n\n\tdev = &pdev->dev;\n\n\tlpc_snoop = devm_kzalloc(dev, sizeof(*lpc_snoop), GFP_KERNEL);\n\tif (!lpc_snoop)\n\t\treturn -ENOMEM;\n\n\tnp = pdev->dev.parent->of_node;\n\tif (!of_device_is_compatible(np, \"aspeed,ast2400-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2500-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2600-lpc-v2\")) {\n\t\tdev_err(dev, \"unsupported LPC device binding\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlpc_snoop->regmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(lpc_snoop->regmap)) {\n\t\tdev_err(dev, \"Couldn't get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, lpc_snoop);\n\n\trc = of_property_read_u32_index(dev->of_node, \"snoop-ports\", 0, &port);\n\tif (rc) {\n\t\tdev_err(dev, \"no snoop ports configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlpc_snoop->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(lpc_snoop->clk)) {\n\t\trc = PTR_ERR(lpc_snoop->clk);\n\t\tif (rc != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"couldn't get clock\\n\");\n\t\treturn rc;\n\t}\n\trc = clk_prepare_enable(lpc_snoop->clk);\n\tif (rc) {\n\t\tdev_err(dev, \"couldn't enable clock\\n\");\n\t\treturn rc;\n\t}\n\n\trc = aspeed_lpc_snoop_config_irq(lpc_snoop, pdev);\n\tif (rc)\n\t\tgoto err;\n\n\trc = aspeed_lpc_enable_snoop(lpc_snoop, dev, 0, port);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tif (of_property_read_u32_index(dev->of_node, \"snoop-ports\",\n\t\t\t\t       1, &port) == 0) {\n\t\trc = aspeed_lpc_enable_snoop(lpc_snoop, dev, 1, port);\n\t\tif (rc) {\n\t\t\taspeed_lpc_disable_snoop(lpc_snoop, 0);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(lpc_snoop->clk);\n\n\treturn rc;\n}\n\nstatic int aspeed_lpc_snoop_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_lpc_snoop *lpc_snoop = dev_get_drvdata(&pdev->dev);\n\n\t \n\taspeed_lpc_disable_snoop(lpc_snoop, 0);\n\taspeed_lpc_disable_snoop(lpc_snoop, 1);\n\n\tclk_disable_unprepare(lpc_snoop->clk);\n\n\treturn 0;\n}\n\nstatic const struct aspeed_lpc_snoop_model_data ast2400_model_data = {\n\t.has_hicrb_ensnp = 0,\n};\n\nstatic const struct aspeed_lpc_snoop_model_data ast2500_model_data = {\n\t.has_hicrb_ensnp = 1,\n};\n\nstatic const struct of_device_id aspeed_lpc_snoop_match[] = {\n\t{ .compatible = \"aspeed,ast2400-lpc-snoop\",\n\t  .data = &ast2400_model_data },\n\t{ .compatible = \"aspeed,ast2500-lpc-snoop\",\n\t  .data = &ast2500_model_data },\n\t{ .compatible = \"aspeed,ast2600-lpc-snoop\",\n\t  .data = &ast2500_model_data },\n\t{ },\n};\n\nstatic struct platform_driver aspeed_lpc_snoop_driver = {\n\t.driver = {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table = aspeed_lpc_snoop_match,\n\t},\n\t.probe = aspeed_lpc_snoop_probe,\n\t.remove = aspeed_lpc_snoop_remove,\n};\n\nmodule_platform_driver(aspeed_lpc_snoop_driver);\n\nMODULE_DEVICE_TABLE(of, aspeed_lpc_snoop_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Lippert <rlippert@google.com>\");\nMODULE_DESCRIPTION(\"Linux driver to control Aspeed LPC snoop functionality\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}