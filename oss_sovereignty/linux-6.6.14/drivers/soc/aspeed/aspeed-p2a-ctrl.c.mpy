{
  "module_name": "aspeed-p2a-ctrl.c",
  "hash_id": "a3900afed635e38a32381419d24f82778a10f351a548e13f2c805f7403c9c491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/aspeed/aspeed-p2a-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <linux/aspeed-p2a-ctrl.h>\n\n#define DEVICE_NAME\t\"aspeed-p2a-ctrl\"\n\n \n#define SCU2C 0x2c\n \n#define SCU180 0x180\n \n#define SCU180_ENP2A BIT(1)\n\n \n#define P2A_REGION_COUNT 6\n\nstruct region {\n\tu64 min;\n\tu64 max;\n\tu32 bit;\n};\n\nstruct aspeed_p2a_model_data {\n\t \n\tstruct region regions[P2A_REGION_COUNT];\n};\n\nstruct aspeed_p2a_ctrl {\n\tstruct miscdevice miscdev;\n\tstruct regmap *regmap;\n\n\tconst struct aspeed_p2a_model_data *config;\n\n\t \n\tstruct mutex tracking;\n\tu32 readers;\n\tu32 readerwriters[P2A_REGION_COUNT];\n\n\tphys_addr_t mem_base;\n\tresource_size_t mem_size;\n};\n\nstruct aspeed_p2a_user {\n\tstruct file *file;\n\tstruct aspeed_p2a_ctrl *parent;\n\n\t \n\tu32 read;\n\n\t \n\tu32 readwrite[P2A_REGION_COUNT];\n};\n\nstatic void aspeed_p2a_enable_bridge(struct aspeed_p2a_ctrl *p2a_ctrl)\n{\n\tregmap_update_bits(p2a_ctrl->regmap,\n\t\tSCU180, SCU180_ENP2A, SCU180_ENP2A);\n}\n\nstatic void aspeed_p2a_disable_bridge(struct aspeed_p2a_ctrl *p2a_ctrl)\n{\n\tregmap_update_bits(p2a_ctrl->regmap, SCU180, SCU180_ENP2A, 0);\n}\n\nstatic int aspeed_p2a_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long vsize;\n\tpgprot_t prot;\n\tstruct aspeed_p2a_user *priv = file->private_data;\n\tstruct aspeed_p2a_ctrl *ctrl = priv->parent;\n\n\tif (ctrl->mem_base == 0 && ctrl->mem_size == 0)\n\t\treturn -EINVAL;\n\n\tvsize = vma->vm_end - vma->vm_start;\n\tprot = vma->vm_page_prot;\n\n\tif (vma->vm_pgoff + vma_pages(vma) > ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tprot = pgprot_noncached(prot);\n\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic bool aspeed_p2a_region_acquire(struct aspeed_p2a_user *priv,\n\t\tstruct aspeed_p2a_ctrl *ctrl,\n\t\tstruct aspeed_p2a_ctrl_mapping *map)\n{\n\tint i;\n\tu64 base, end;\n\tbool matched = false;\n\n\tbase = map->addr;\n\tend = map->addr + (map->length - 1);\n\n\t \n\tfor (i = 0; i < P2A_REGION_COUNT; i++) {\n\t\tconst struct region *curr = &ctrl->config->regions[i];\n\n\t\t \n\t\tif (curr->max < base)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (curr->min > end)\n\t\t\tbreak;\n\n\t\t \n\t\tmutex_lock(&ctrl->tracking);\n\t\tctrl->readerwriters[i] += 1;\n\t\tmutex_unlock(&ctrl->tracking);\n\n\t\t \n\t\tpriv->readwrite[i] += 1;\n\n\t\t \n\t\tregmap_update_bits(ctrl->regmap, SCU2C, curr->bit, 0);\n\t\tmatched = true;\n\t}\n\n\treturn matched;\n}\n\nstatic long aspeed_p2a_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long data)\n{\n\tstruct aspeed_p2a_user *priv = file->private_data;\n\tstruct aspeed_p2a_ctrl *ctrl = priv->parent;\n\tvoid __user *arg = (void __user *)data;\n\tstruct aspeed_p2a_ctrl_mapping map;\n\n\tif (copy_from_user(&map, arg, sizeof(map)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ASPEED_P2A_CTRL_IOCTL_SET_WINDOW:\n\t\t \n\t\tif (map.flags == ASPEED_P2A_CTRL_READ_ONLY) {\n\t\t\tmutex_lock(&ctrl->tracking);\n\t\t\tctrl->readers += 1;\n\t\t\tmutex_unlock(&ctrl->tracking);\n\n\t\t\t \n\t\t\tpriv->read += 1;\n\t\t} else if (map.flags == ASPEED_P2A_CTRL_READWRITE) {\n\t\t\t \n\t\t\tif (!aspeed_p2a_region_acquire(priv, ctrl, &map)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taspeed_p2a_enable_bridge(ctrl);\n\t\treturn 0;\n\tcase ASPEED_P2A_CTRL_IOCTL_GET_MEMORY_CONFIG:\n\t\t \n\n\t\tmap.flags = 0;\n\t\tmap.addr = ctrl->mem_base;\n\t\tmap.length = ctrl->mem_size;\n\n\t\treturn copy_to_user(arg, &map, sizeof(map)) ? -EFAULT : 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\n \nstatic int aspeed_p2a_open(struct inode *inode, struct file *file)\n{\n\tstruct aspeed_p2a_user *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->file = file;\n\tpriv->read = 0;\n\tmemset(priv->readwrite, 0, sizeof(priv->readwrite));\n\n\t \n\tpriv->parent = file->private_data;\n\n\t \n\tfile->private_data = priv;\n\n\treturn 0;\n}\n\n \nstatic int aspeed_p2a_release(struct inode *inode, struct file *file)\n{\n\tint i;\n\tu32 bits = 0;\n\tbool open_regions = false;\n\tstruct aspeed_p2a_user *priv = file->private_data;\n\n\t \n\tmutex_lock(&priv->parent->tracking);\n\n\tpriv->parent->readers -= priv->read;\n\n\tfor (i = 0; i < P2A_REGION_COUNT; i++) {\n\t\tpriv->parent->readerwriters[i] -= priv->readwrite[i];\n\n\t\tif (priv->parent->readerwriters[i] > 0)\n\t\t\topen_regions = true;\n\t\telse\n\t\t\tbits |= priv->parent->config->regions[i].bit;\n\t}\n\n\t \n\n\t \n\tregmap_update_bits(priv->parent->regmap, SCU2C, bits, bits);\n\n\t \n\tif (!open_regions && priv->parent->readers == 0)\n\t\taspeed_p2a_disable_bridge(priv->parent);\n\n\tmutex_unlock(&priv->parent->tracking);\n\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic const struct file_operations aspeed_p2a_ctrl_fops = {\n\t.owner = THIS_MODULE,\n\t.mmap = aspeed_p2a_mmap,\n\t.unlocked_ioctl = aspeed_p2a_ioctl,\n\t.open = aspeed_p2a_open,\n\t.release = aspeed_p2a_release,\n};\n\n \nstatic void aspeed_p2a_disable_all(struct aspeed_p2a_ctrl *p2a_ctrl)\n{\n\tint i;\n\tu32 value = 0;\n\n\tfor (i = 0; i < P2A_REGION_COUNT; i++)\n\t\tvalue |= p2a_ctrl->config->regions[i].bit;\n\n\tregmap_update_bits(p2a_ctrl->regmap, SCU2C, value, value);\n\n\t \n\taspeed_p2a_disable_bridge(p2a_ctrl);\n}\n\nstatic int aspeed_p2a_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_p2a_ctrl *misc_ctrl;\n\tstruct device *dev;\n\tstruct resource resm;\n\tstruct device_node *node;\n\tint rc = 0;\n\n\tdev = &pdev->dev;\n\n\tmisc_ctrl = devm_kzalloc(dev, sizeof(*misc_ctrl), GFP_KERNEL);\n\tif (!misc_ctrl)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&misc_ctrl->tracking);\n\n\t \n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (node) {\n\t\trc = of_address_to_resource(node, 0, &resm);\n\t\tof_node_put(node);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Couldn't address to resource for reserved memory\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tmisc_ctrl->mem_size = resource_size(&resm);\n\t\tmisc_ctrl->mem_base = resm.start;\n\t}\n\n\tmisc_ctrl->regmap = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(misc_ctrl->regmap)) {\n\t\tdev_err(dev, \"Couldn't get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmisc_ctrl->config = of_device_get_match_data(dev);\n\n\tdev_set_drvdata(&pdev->dev, misc_ctrl);\n\n\taspeed_p2a_disable_all(misc_ctrl);\n\n\tmisc_ctrl->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tmisc_ctrl->miscdev.name = DEVICE_NAME;\n\tmisc_ctrl->miscdev.fops = &aspeed_p2a_ctrl_fops;\n\tmisc_ctrl->miscdev.parent = dev;\n\n\trc = misc_register(&misc_ctrl->miscdev);\n\tif (rc)\n\t\tdev_err(dev, \"Unable to register device\\n\");\n\n\treturn rc;\n}\n\nstatic int aspeed_p2a_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_p2a_ctrl *p2a_ctrl = dev_get_drvdata(&pdev->dev);\n\n\tmisc_deregister(&p2a_ctrl->miscdev);\n\n\treturn 0;\n}\n\n#define SCU2C_DRAM\tBIT(25)\n#define SCU2C_SPI\tBIT(24)\n#define SCU2C_SOC\tBIT(23)\n#define SCU2C_FLASH\tBIT(22)\n\nstatic const struct aspeed_p2a_model_data ast2400_model_data = {\n\t.regions = {\n\t\t{0x00000000, 0x17FFFFFF, SCU2C_FLASH},\n\t\t{0x18000000, 0x1FFFFFFF, SCU2C_SOC},\n\t\t{0x20000000, 0x2FFFFFFF, SCU2C_FLASH},\n\t\t{0x30000000, 0x3FFFFFFF, SCU2C_SPI},\n\t\t{0x40000000, 0x5FFFFFFF, SCU2C_DRAM},\n\t\t{0x60000000, 0xFFFFFFFF, SCU2C_SOC},\n\t}\n};\n\nstatic const struct aspeed_p2a_model_data ast2500_model_data = {\n\t.regions = {\n\t\t{0x00000000, 0x0FFFFFFF, SCU2C_FLASH},\n\t\t{0x10000000, 0x1FFFFFFF, SCU2C_SOC},\n\t\t{0x20000000, 0x3FFFFFFF, SCU2C_FLASH},\n\t\t{0x40000000, 0x5FFFFFFF, SCU2C_SOC},\n\t\t{0x60000000, 0x7FFFFFFF, SCU2C_SPI},\n\t\t{0x80000000, 0xFFFFFFFF, SCU2C_DRAM},\n\t}\n};\n\nstatic const struct of_device_id aspeed_p2a_ctrl_match[] = {\n\t{ .compatible = \"aspeed,ast2400-p2a-ctrl\",\n\t  .data = &ast2400_model_data },\n\t{ .compatible = \"aspeed,ast2500-p2a-ctrl\",\n\t  .data = &ast2500_model_data },\n\t{ },\n};\n\nstatic struct platform_driver aspeed_p2a_ctrl_driver = {\n\t.driver = {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table = aspeed_p2a_ctrl_match,\n\t},\n\t.probe = aspeed_p2a_ctrl_probe,\n\t.remove = aspeed_p2a_ctrl_remove,\n};\n\nmodule_platform_driver(aspeed_p2a_ctrl_driver);\n\nMODULE_DEVICE_TABLE(of, aspeed_p2a_ctrl_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick Venture <venture@google.com>\");\nMODULE_DESCRIPTION(\"Control for aspeed 2400/2500 P2A VGA HOST to BMC mappings\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}