{
  "module_name": "aspeed-lpc-ctrl.c",
  "hash_id": "3040df1463b48142fd8533173ea99a2373ac33142b328785b164ab34ca5747eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/aspeed/aspeed-lpc-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/log2.h>\n#include <linux/mfd/syscon.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/regmap.h>\n\n#include <linux/aspeed-lpc-ctrl.h>\n\n#define DEVICE_NAME\t\"aspeed-lpc-ctrl\"\n\n#define HICR5 0x80\n#define HICR5_ENL2H\tBIT(8)\n#define HICR5_ENFWH\tBIT(10)\n\n#define HICR6 0x84\n#define SW_FWH2AHB\tBIT(17)\n\n#define HICR7 0x88\n#define HICR8 0x8c\n\nstruct aspeed_lpc_ctrl {\n\tstruct miscdevice\tmiscdev;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clk;\n\tphys_addr_t\t\tmem_base;\n\tresource_size_t\t\tmem_size;\n\tu32\t\t\tpnor_size;\n\tu32\t\t\tpnor_base;\n\tbool\t\t\tfwh2ahb;\n\tstruct regmap\t\t*scu;\n};\n\nstatic struct aspeed_lpc_ctrl *file_aspeed_lpc_ctrl(struct file *file)\n{\n\treturn container_of(file->private_data, struct aspeed_lpc_ctrl,\n\t\t\tmiscdev);\n}\n\nstatic int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tprot = pgprot_noncached(prot);\n\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic long aspeed_lpc_ctrl_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long param)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tstruct device *dev = file->private_data;\n\tvoid __user *p = (void __user *)param;\n\tstruct aspeed_lpc_ctrl_mapping map;\n\tu32 addr;\n\tu32 size;\n\tlong rc;\n\n\tif (copy_from_user(&map, p, sizeof(map)))\n\t\treturn -EFAULT;\n\n\tif (map.flags != 0)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase ASPEED_LPC_CTRL_IOCTL_GET_SIZE:\n\t\t \n\t\tif (map.window_type != ASPEED_LPC_CTRL_WINDOW_MEMORY)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (map.window_id != 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!lpc_ctrl->mem_size) {\n\t\t\tdev_dbg(dev, \"Didn't find reserved memory\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tmap.size = lpc_ctrl->mem_size;\n\n\t\treturn copy_to_user(p, &map, sizeof(map)) ? -EFAULT : 0;\n\tcase ASPEED_LPC_CTRL_IOCTL_MAP:\n\n\t\t \n\n\t\t \n\n\t\tif ((map.size & 0x0000ffff) || (map.offset & 0x0000ffff))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (map.offset & (map.size - 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (map.window_type == ASPEED_LPC_CTRL_WINDOW_FLASH) {\n\t\t\tif (!lpc_ctrl->pnor_size) {\n\t\t\t\tdev_dbg(dev, \"Didn't find host pnor flash\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t\taddr = lpc_ctrl->pnor_base;\n\t\t\tsize = lpc_ctrl->pnor_size;\n\t\t} else if (map.window_type == ASPEED_LPC_CTRL_WINDOW_MEMORY) {\n\t\t\t \n\t\t\tif (!lpc_ctrl->mem_size) {\n\t\t\t\tdev_dbg(dev, \"Didn't find reserved memory\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t\taddr = lpc_ctrl->mem_base;\n\t\t\tsize = lpc_ctrl->mem_size;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (map.offset + map.size < map.offset ||\n\t\t\tmap.offset + map.size > size)\n\t\t\treturn -EINVAL;\n\n\t\tif (map.size == 0 || map.size > size)\n\t\t\treturn -EINVAL;\n\n\t\taddr += map.offset;\n\n\t\t \n\n\t\trc = regmap_write(lpc_ctrl->regmap, HICR7,\n\t\t\t\t(addr | (map.addr >> 16)));\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = regmap_write(lpc_ctrl->regmap, HICR8,\n\t\t\t\t(~(map.size - 1)) | ((map.size >> 16) - 1));\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (lpc_ctrl->fwh2ahb) {\n\t\t\t \n\t\t\tregmap_update_bits(lpc_ctrl->scu, 0x0D8, BIT(2), 0);\n\n\t\t\t \n\t\t\tregmap_write(lpc_ctrl->regmap, HICR6, SW_FWH2AHB);\n\t\t}\n\n\t\t \n\t\treturn regmap_update_bits(lpc_ctrl->regmap, HICR5,\n\t\t\t\tHICR5_ENFWH | HICR5_ENL2H,\n\t\t\t\tHICR5_ENFWH | HICR5_ENL2H);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct file_operations aspeed_lpc_ctrl_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.mmap\t\t= aspeed_lpc_ctrl_mmap,\n\t.unlocked_ioctl\t= aspeed_lpc_ctrl_ioctl,\n};\n\nstatic int aspeed_lpc_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl;\n\tstruct device_node *node;\n\tstruct resource resm;\n\tstruct device *dev;\n\tstruct device_node *np;\n\tint rc;\n\n\tdev = &pdev->dev;\n\n\tlpc_ctrl = devm_kzalloc(dev, sizeof(*lpc_ctrl), GFP_KERNEL);\n\tif (!lpc_ctrl)\n\t\treturn -ENOMEM;\n\n\t \n\tnode = of_parse_phandle(dev->of_node, \"flash\", 0);\n\tif (!node) {\n\t\tdev_dbg(dev, \"Didn't find host pnor flash node\\n\");\n\t} else {\n\t\trc = of_address_to_resource(node, 1, &resm);\n\t\tof_node_put(node);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Couldn't address to resource for flash\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tlpc_ctrl->pnor_size = resource_size(&resm);\n\t\tlpc_ctrl->pnor_base = resm.start;\n\t}\n\n\n\tdev_set_drvdata(&pdev->dev, lpc_ctrl);\n\n\t \n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (!node) {\n\t\tdev_dbg(dev, \"Didn't find reserved memory\\n\");\n\t} else {\n\t\trc = of_address_to_resource(node, 0, &resm);\n\t\tof_node_put(node);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Couldn't address to resource for reserved memory\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tlpc_ctrl->mem_size = resource_size(&resm);\n\t\tlpc_ctrl->mem_base = resm.start;\n\n\t\tif (!is_power_of_2(lpc_ctrl->mem_size)) {\n\t\t\tdev_err(dev, \"Reserved memory size must be a power of 2, got %u\\n\",\n\t\t\t       (unsigned int)lpc_ctrl->mem_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!IS_ALIGNED(lpc_ctrl->mem_base, lpc_ctrl->mem_size)) {\n\t\t\tdev_err(dev, \"Reserved memory must be naturally aligned for size %u\\n\",\n\t\t\t       (unsigned int)lpc_ctrl->mem_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnp = pdev->dev.parent->of_node;\n\tif (!of_device_is_compatible(np, \"aspeed,ast2400-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2500-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2600-lpc-v2\")) {\n\t\tdev_err(dev, \"unsupported LPC device binding\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlpc_ctrl->regmap = syscon_node_to_regmap(np);\n\tif (IS_ERR(lpc_ctrl->regmap)) {\n\t\tdev_err(dev, \"Couldn't get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_device_is_compatible(dev->of_node, \"aspeed,ast2600-lpc-ctrl\")) {\n\t\tlpc_ctrl->fwh2ahb = true;\n\n\t\tlpc_ctrl->scu = syscon_regmap_lookup_by_compatible(\"aspeed,ast2600-scu\");\n\t\tif (IS_ERR(lpc_ctrl->scu)) {\n\t\t\tdev_err(dev, \"couldn't find scu\\n\");\n\t\t\treturn PTR_ERR(lpc_ctrl->scu);\n\t\t}\n\t}\n\n\tlpc_ctrl->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(lpc_ctrl->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(lpc_ctrl->clk),\n\t\t\t\t     \"couldn't get clock\\n\");\n\trc = clk_prepare_enable(lpc_ctrl->clk);\n\tif (rc) {\n\t\tdev_err(dev, \"couldn't enable clock\\n\");\n\t\treturn rc;\n\t}\n\n\tlpc_ctrl->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tlpc_ctrl->miscdev.name = DEVICE_NAME;\n\tlpc_ctrl->miscdev.fops = &aspeed_lpc_ctrl_fops;\n\tlpc_ctrl->miscdev.parent = dev;\n\trc = misc_register(&lpc_ctrl->miscdev);\n\tif (rc) {\n\t\tdev_err(dev, \"Unable to register device\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(lpc_ctrl->clk);\n\treturn rc;\n}\n\nstatic int aspeed_lpc_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = dev_get_drvdata(&pdev->dev);\n\n\tmisc_deregister(&lpc_ctrl->miscdev);\n\tclk_disable_unprepare(lpc_ctrl->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id aspeed_lpc_ctrl_match[] = {\n\t{ .compatible = \"aspeed,ast2400-lpc-ctrl\" },\n\t{ .compatible = \"aspeed,ast2500-lpc-ctrl\" },\n\t{ .compatible = \"aspeed,ast2600-lpc-ctrl\" },\n\t{ },\n};\n\nstatic struct platform_driver aspeed_lpc_ctrl_driver = {\n\t.driver = {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table = aspeed_lpc_ctrl_match,\n\t},\n\t.probe = aspeed_lpc_ctrl_probe,\n\t.remove = aspeed_lpc_ctrl_remove,\n};\n\nmodule_platform_driver(aspeed_lpc_ctrl_driver);\n\nMODULE_DEVICE_TABLE(of, aspeed_lpc_ctrl_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cyril Bur <cyrilbur@gmail.com>\");\nMODULE_DESCRIPTION(\"Control for ASPEED LPC HOST to BMC mappings\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}