{
  "module_name": "aspeed-socinfo.c",
  "hash_id": "553a3a1121b613022876ced583008907d8313ff4a4eca21e62337b9c9439b01f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/aspeed/aspeed-socinfo.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\nstatic struct {\n\tconst char *name;\n\tconst u32 id;\n} const rev_table[] = {\n\t \n\t{ \"AST2400\", 0x02000303 },\n\t{ \"AST1400\", 0x02010103 },\n\t{ \"AST1250\", 0x02010303 },\n\t \n\t{ \"AST2500\", 0x04000303 },\n\t{ \"AST2510\", 0x04000103 },\n\t{ \"AST2520\", 0x04000203 },\n\t{ \"AST2530\", 0x04000403 },\n\t \n\t{ \"AST2600\", 0x05000303 },\n\t{ \"AST2620\", 0x05010203 },\n\t{ \"AST2605\", 0x05030103 },\n\t{ \"AST2625\", 0x05030403 },\n};\n\nstatic const char *siliconid_to_name(u32 siliconid)\n{\n\tunsigned int id = siliconid & 0xff00ffff;\n\tunsigned int i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(rev_table) ; ++i) {\n\t\tif (rev_table[i].id == id)\n\t\t\treturn rev_table[i].name;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic const char *siliconid_to_rev(u32 siliconid)\n{\n\tunsigned int rev = (siliconid >> 16) & 0xff;\n\tunsigned int gen = (siliconid >> 24) & 0xff;\n\n\tif (gen < 0x5) {\n\t\t \n\t\tswitch (rev) {\n\t\tcase 0:\n\t\t\treturn \"A0\";\n\t\tcase 1:\n\t\t\treturn \"A1\";\n\t\tcase 3:\n\t\t\treturn \"A2\";\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (rev) {\n\t\tcase 0:\n\t\t\treturn \"A0\";\n\t\tcase 1:\n\t\t\treturn \"A1\";\n\t\tcase 2:\n\t\t\treturn \"A2\";\n\t\tcase 3:\n\t\t\treturn \"A3\";\n\t\t}\n\t}\n\n\treturn \"??\";\n}\n\nstatic int __init aspeed_socinfo_init(void)\n{\n\tstruct soc_device_attribute *attrs;\n\tstruct soc_device *soc_dev;\n\tstruct device_node *np;\n\tvoid __iomem *reg;\n\tbool has_chipid = false;\n\tu32 siliconid;\n\tu32 chipid[2];\n\tconst char *machine = NULL;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"aspeed,silicon-id\");\n\tif (!of_device_is_available(np)) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\n\treg = of_iomap(np, 0);\n\tif (!reg) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\tsiliconid = readl(reg);\n\tiounmap(reg);\n\n\t \n\treg = of_iomap(np, 1);\n\tif (reg) {\n\t\thas_chipid = true;\n\t\tchipid[0] = readl(reg);\n\t\tchipid[1] = readl(reg + 4);\n\t\tiounmap(reg);\n\t}\n\tof_node_put(np);\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENODEV;\n\n\t \n\n\tnp = of_find_node_by_path(\"/\");\n\tof_property_read_string(np, \"model\", &machine);\n\tif (machine)\n\t\tattrs->machine = kstrdup(machine, GFP_KERNEL);\n\tof_node_put(np);\n\n\tattrs->family = siliconid_to_name(siliconid);\n\tattrs->revision = siliconid_to_rev(siliconid);\n\tattrs->soc_id = kasprintf(GFP_KERNEL, \"%08x\", siliconid);\n\n\tif (has_chipid)\n\t\tattrs->serial_number = kasprintf(GFP_KERNEL, \"%08x%08x\",\n\t\t\t\t\t\t chipid[1], chipid[0]);\n\n\tsoc_dev = soc_device_register(attrs);\n\tif (IS_ERR(soc_dev)) {\n\t\tkfree(attrs->machine);\n\t\tkfree(attrs->soc_id);\n\t\tkfree(attrs->serial_number);\n\t\tkfree(attrs);\n\t\treturn PTR_ERR(soc_dev);\n\t}\n\n\tpr_info(\"ASPEED %s rev %s (%s)\\n\",\n\t\t\tattrs->family,\n\t\t\tattrs->revision,\n\t\t\tattrs->soc_id);\n\n\treturn 0;\n}\nearly_initcall(aspeed_socinfo_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}