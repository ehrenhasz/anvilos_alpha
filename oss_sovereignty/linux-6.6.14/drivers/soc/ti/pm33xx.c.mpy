{
  "module_name": "pm33xx.c",
  "hash_id": "e492070b7eef269659ce9c89dd9fb66c6ea54e4a156019507da16e1e338a3ecc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/pm33xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/genalloc.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_data/pm33xx.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rtc.h>\n#include <linux/rtc/rtc-omap.h>\n#include <linux/sizes.h>\n#include <linux/sram.h>\n#include <linux/suspend.h>\n#include <linux/ti-emif-sram.h>\n#include <linux/wkup_m3_ipc.h>\n\n#include <asm/proc-fns.h>\n#include <asm/suspend.h>\n#include <asm/system_misc.h>\n\n#define AMX3_PM_SRAM_SYMBOL_OFFSET(sym) ((unsigned long)(sym) - \\\n\t\t\t\t\t (unsigned long)pm_sram->do_wfi)\n\n#define RTC_SCRATCH_RESUME_REG\t0\n#define RTC_SCRATCH_MAGIC_REG\t1\n#define RTC_REG_BOOT_MAGIC\t0x8cd0  \n#define GIC_INT_SET_PENDING_BASE 0x200\n#define AM43XX_GIC_DIST_BASE\t0x48241000\n\nstatic void __iomem *rtc_base_virt;\nstatic struct clk *rtc_fck;\nstatic u32 rtc_magic_val;\n\nstatic int (*am33xx_do_wfi_sram)(unsigned long unused);\nstatic phys_addr_t am33xx_do_wfi_sram_phys;\n\nstatic struct gen_pool *sram_pool, *sram_pool_data;\nstatic unsigned long ocmcram_location, ocmcram_location_data;\n\nstatic struct rtc_device *omap_rtc;\nstatic void __iomem *gic_dist_base;\n\nstatic struct am33xx_pm_platform_data *pm_ops;\nstatic struct am33xx_pm_sram_addr *pm_sram;\n\nstatic struct device *pm33xx_dev;\nstatic struct wkup_m3_ipc *m3_ipc;\n\n#ifdef CONFIG_SUSPEND\nstatic int rtc_only_idle;\nstatic int retrigger_irq;\nstatic unsigned long suspend_wfi_flags;\n\nstatic struct wkup_m3_wakeup_src wakeup_src = {.irq_nr = 0,\n\t.src = \"Unknown\",\n};\n\nstatic struct wkup_m3_wakeup_src rtc_alarm_wakeup = {\n\t.irq_nr = 108, .src = \"RTC Alarm\",\n};\n\nstatic struct wkup_m3_wakeup_src rtc_ext_wakeup = {\n\t.irq_nr = 0, .src = \"Ext wakeup\",\n};\n#endif\n\nstatic u32 sram_suspend_address(unsigned long addr)\n{\n\treturn ((unsigned long)am33xx_do_wfi_sram +\n\t\tAMX3_PM_SRAM_SYMBOL_OFFSET(addr));\n}\n\nstatic int am33xx_push_sram_idle(void)\n{\n\tstruct am33xx_pm_ro_sram_data ro_sram_data;\n\tint ret;\n\tu32 table_addr, ro_data_addr;\n\tvoid *copy_addr;\n\n\tro_sram_data.amx3_pm_sram_data_virt = ocmcram_location_data;\n\tro_sram_data.amx3_pm_sram_data_phys =\n\t\tgen_pool_virt_to_phys(sram_pool_data, ocmcram_location_data);\n\tro_sram_data.rtc_base_virt = rtc_base_virt;\n\n\t \n\tam33xx_do_wfi_sram_phys = gen_pool_virt_to_phys(sram_pool,\n\t\t\t\t\t\t\tocmcram_location);\n\n\tam33xx_do_wfi_sram = sram_exec_copy(sram_pool, (void *)ocmcram_location,\n\t\t\t\t\t    pm_sram->do_wfi,\n\t\t\t\t\t    *pm_sram->do_wfi_sz);\n\tif (!am33xx_do_wfi_sram) {\n\t\tdev_err(pm33xx_dev,\n\t\t\t\"PM: %s: am33xx_do_wfi copy to sram failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\ttable_addr =\n\t\tsram_suspend_address((unsigned long)pm_sram->emif_sram_table);\n\tret = ti_emif_copy_pm_function_table(sram_pool, (void *)table_addr);\n\tif (ret) {\n\t\tdev_dbg(pm33xx_dev,\n\t\t\t\"PM: %s: EMIF function copy failed\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tro_data_addr =\n\t\tsram_suspend_address((unsigned long)pm_sram->ro_sram_data);\n\tcopy_addr = sram_exec_copy(sram_pool, (void *)ro_data_addr,\n\t\t\t\t   &ro_sram_data,\n\t\t\t\t   sizeof(ro_sram_data));\n\tif (!copy_addr) {\n\t\tdev_err(pm33xx_dev,\n\t\t\t\"PM: %s: ro_sram_data copy to sram failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int am33xx_do_sram_idle(u32 wfi_flags)\n{\n\tif (!m3_ipc || !pm_ops)\n\t\treturn 0;\n\n\tif (wfi_flags & WFI_FLAG_WAKE_M3)\n\t\tm3_ipc->ops->prepare_low_power(m3_ipc, WKUP_M3_IDLE);\n\n\treturn pm_ops->cpu_suspend(am33xx_do_wfi_sram, wfi_flags);\n}\n\nstatic int __init am43xx_map_gic(void)\n{\n\tgic_dist_base = ioremap(AM43XX_GIC_DIST_BASE, SZ_4K);\n\n\tif (!gic_dist_base)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SUSPEND\nstatic struct wkup_m3_wakeup_src rtc_wake_src(void)\n{\n\tu32 i;\n\n\ti = __raw_readl(rtc_base_virt + 0x44) & 0x40;\n\n\tif (i) {\n\t\tretrigger_irq = rtc_alarm_wakeup.irq_nr;\n\t\treturn rtc_alarm_wakeup;\n\t}\n\n\tretrigger_irq = rtc_ext_wakeup.irq_nr;\n\n\treturn rtc_ext_wakeup;\n}\n\nstatic int am33xx_rtc_only_idle(unsigned long wfi_flags)\n{\n\tomap_rtc_power_off_program(&omap_rtc->dev);\n\tam33xx_do_wfi_sram(wfi_flags);\n\treturn 0;\n}\n\n \nstatic int am33xx_pm_suspend(suspend_state_t suspend_state)\n{\n\tint i, ret = 0;\n\n\tif (suspend_state == PM_SUSPEND_MEM &&\n\t    pm_ops->check_off_mode_enable()) {\n\t\tret = clk_prepare_enable(rtc_fck);\n\t\tif (ret) {\n\t\t\tdev_err(pm33xx_dev, \"Failed to enable clock: %i\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpm_ops->save_context();\n\t\tsuspend_wfi_flags |= WFI_FLAG_RTC_ONLY;\n\t\tclk_save_context();\n\t\tret = pm_ops->soc_suspend(suspend_state, am33xx_rtc_only_idle,\n\t\t\t\t\t  suspend_wfi_flags);\n\n\t\tsuspend_wfi_flags &= ~WFI_FLAG_RTC_ONLY;\n\t\tdev_info(pm33xx_dev, \"Entering RTC Only mode with DDR in self-refresh\\n\");\n\n\t\tif (!ret) {\n\t\t\tclk_restore_context();\n\t\t\tpm_ops->restore_context();\n\t\t\tm3_ipc->ops->set_rtc_only(m3_ipc);\n\t\t\tam33xx_push_sram_idle();\n\t\t}\n\t} else {\n\t\tret = pm_ops->soc_suspend(suspend_state, am33xx_do_wfi_sram,\n\t\t\t\t\t  suspend_wfi_flags);\n\t}\n\n\tif (ret) {\n\t\tdev_err(pm33xx_dev, \"PM: Kernel suspend failure\\n\");\n\t} else {\n\t\ti = m3_ipc->ops->request_pm_status(m3_ipc);\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tdev_info(pm33xx_dev,\n\t\t\t\t \"PM: Successfully put all powerdomains to target state\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_err(pm33xx_dev,\n\t\t\t\t\"PM: Could not transition all powerdomains to target state\\n\");\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pm33xx_dev,\n\t\t\t\t\"PM: CM3 returned unknown result = %d\\n\", i);\n\t\t\tret = -1;\n\t\t}\n\n\t\t \n\t\tif (rtc_only_idle) {\n\t\t\twakeup_src = rtc_wake_src();\n\t\t\tpr_info(\"PM: Wakeup source %s\\n\", wakeup_src.src);\n\t\t} else {\n\t\t\tpr_info(\"PM: Wakeup source %s\\n\",\n\t\t\t\tm3_ipc->ops->request_wake_src(m3_ipc));\n\t\t}\n\t}\n\n\tif (suspend_state == PM_SUSPEND_MEM && pm_ops->check_off_mode_enable())\n\t\tclk_disable_unprepare(rtc_fck);\n\n\treturn ret;\n}\n\nstatic int am33xx_pm_enter(suspend_state_t suspend_state)\n{\n\tint ret = 0;\n\n\tswitch (suspend_state) {\n\tcase PM_SUSPEND_MEM:\n\tcase PM_SUSPEND_STANDBY:\n\t\tret = am33xx_pm_suspend(suspend_state);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int am33xx_pm_begin(suspend_state_t state)\n{\n\tint ret = -EINVAL;\n\tstruct nvmem_device *nvmem;\n\n\tif (state == PM_SUSPEND_MEM && pm_ops->check_off_mode_enable()) {\n\t\tnvmem = devm_nvmem_device_get(&omap_rtc->dev,\n\t\t\t\t\t      \"omap_rtc_scratch0\");\n\t\tif (!IS_ERR(nvmem))\n\t\t\tnvmem_device_write(nvmem, RTC_SCRATCH_MAGIC_REG * 4, 4,\n\t\t\t\t\t   (void *)&rtc_magic_val);\n\t\trtc_only_idle = 1;\n\t} else {\n\t\trtc_only_idle = 0;\n\t}\n\n\tpm_ops->begin_suspend();\n\n\tswitch (state) {\n\tcase PM_SUSPEND_MEM:\n\t\tret = m3_ipc->ops->prepare_low_power(m3_ipc, WKUP_M3_DEEPSLEEP);\n\t\tbreak;\n\tcase PM_SUSPEND_STANDBY:\n\t\tret = m3_ipc->ops->prepare_low_power(m3_ipc, WKUP_M3_STANDBY);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void am33xx_pm_end(void)\n{\n\tu32 val = 0;\n\tstruct nvmem_device *nvmem;\n\n\tnvmem = devm_nvmem_device_get(&omap_rtc->dev, \"omap_rtc_scratch0\");\n\tif (IS_ERR(nvmem))\n\t\treturn;\n\n\tm3_ipc->ops->finish_low_power(m3_ipc);\n\tif (rtc_only_idle) {\n\t\tif (retrigger_irq) {\n\t\t\t \n\t\t\twritel_relaxed(1 << (retrigger_irq & 31),\n\t\t\t\t       gic_dist_base + GIC_INT_SET_PENDING_BASE\n\t\t\t\t       + retrigger_irq / 32 * 4);\n\t\t}\n\n\t\tnvmem_device_write(nvmem, RTC_SCRATCH_MAGIC_REG * 4, 4,\n\t\t\t\t   (void *)&val);\n\t}\n\n\trtc_only_idle = 0;\n\n\tpm_ops->finish_suspend();\n}\n\nstatic int am33xx_pm_valid(suspend_state_t state)\n{\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\tcase PM_SUSPEND_MEM:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct platform_suspend_ops am33xx_pm_ops = {\n\t.begin\t\t= am33xx_pm_begin,\n\t.end\t\t= am33xx_pm_end,\n\t.enter\t\t= am33xx_pm_enter,\n\t.valid\t\t= am33xx_pm_valid,\n};\n#endif  \n\nstatic void am33xx_pm_set_ipc_ops(void)\n{\n\tu32 resume_address;\n\tint temp;\n\n\ttemp = ti_emif_get_mem_type();\n\tif (temp < 0) {\n\t\tdev_err(pm33xx_dev, \"PM: Cannot determine memory type, no PM available\\n\");\n\t\treturn;\n\t}\n\tm3_ipc->ops->set_mem_type(m3_ipc, temp);\n\n\t \n\tresume_address = am33xx_do_wfi_sram_phys +\n\t\t\t *pm_sram->resume_offset + 0x4;\n\n\tm3_ipc->ops->set_resume_address(m3_ipc, (void *)resume_address);\n}\n\nstatic void am33xx_pm_free_sram(void)\n{\n\tgen_pool_free(sram_pool, ocmcram_location, *pm_sram->do_wfi_sz);\n\tgen_pool_free(sram_pool_data, ocmcram_location_data,\n\t\t      sizeof(struct am33xx_pm_ro_sram_data));\n}\n\n \nstatic int am33xx_pm_alloc_sram(void)\n{\n\tstruct device_node *np;\n\tint ret = 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"ti,omap3-mpu\");\n\tif (!np) {\n\t\tnp = of_find_compatible_node(NULL, NULL, \"ti,omap4-mpu\");\n\t\tif (!np) {\n\t\t\tdev_err(pm33xx_dev, \"PM: %s: Unable to find device node for mpu\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tsram_pool = of_gen_pool_get(np, \"pm-sram\", 0);\n\tif (!sram_pool) {\n\t\tdev_err(pm33xx_dev, \"PM: %s: Unable to get sram pool for ocmcram\\n\",\n\t\t\t__func__);\n\t\tret = -ENODEV;\n\t\tgoto mpu_put_node;\n\t}\n\n\tsram_pool_data = of_gen_pool_get(np, \"pm-sram\", 1);\n\tif (!sram_pool_data) {\n\t\tdev_err(pm33xx_dev, \"PM: %s: Unable to get sram data pool for ocmcram\\n\",\n\t\t\t__func__);\n\t\tret = -ENODEV;\n\t\tgoto mpu_put_node;\n\t}\n\n\tocmcram_location = gen_pool_alloc(sram_pool, *pm_sram->do_wfi_sz);\n\tif (!ocmcram_location) {\n\t\tdev_err(pm33xx_dev, \"PM: %s: Unable to allocate memory from ocmcram\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEM;\n\t\tgoto mpu_put_node;\n\t}\n\n\tocmcram_location_data = gen_pool_alloc(sram_pool_data,\n\t\t\t\t\t       sizeof(struct emif_regs_amx3));\n\tif (!ocmcram_location_data) {\n\t\tdev_err(pm33xx_dev, \"PM: Unable to allocate memory from ocmcram\\n\");\n\t\tgen_pool_free(sram_pool, ocmcram_location, *pm_sram->do_wfi_sz);\n\t\tret = -ENOMEM;\n\t}\n\nmpu_put_node:\n\tof_node_put(np);\n\treturn ret;\n}\n\nstatic int am33xx_pm_rtc_setup(void)\n{\n\tstruct device_node *np;\n\tunsigned long val = 0;\n\tstruct nvmem_device *nvmem;\n\tint error;\n\n\tnp = of_find_node_by_name(NULL, \"rtc\");\n\n\tif (of_device_is_available(np)) {\n\t\t \n\t\trtc_fck = of_clk_get_by_name(np->parent, \"fck\");\n\t\tif (IS_ERR(rtc_fck))\n\t\t\treturn PTR_ERR(rtc_fck);\n\n\t\trtc_base_virt = of_iomap(np, 0);\n\t\tif (!rtc_base_virt) {\n\t\t\tpr_warn(\"PM: could not iomap rtc\");\n\t\t\terror = -ENODEV;\n\t\t\tgoto err_clk_put;\n\t\t}\n\n\t\tomap_rtc = rtc_class_open(\"rtc0\");\n\t\tif (!omap_rtc) {\n\t\t\tpr_warn(\"PM: rtc0 not available\");\n\t\t\terror = -EPROBE_DEFER;\n\t\t\tgoto err_iounmap;\n\t\t}\n\n\t\tnvmem = devm_nvmem_device_get(&omap_rtc->dev,\n\t\t\t\t\t      \"omap_rtc_scratch0\");\n\t\tif (!IS_ERR(nvmem)) {\n\t\t\tnvmem_device_read(nvmem, RTC_SCRATCH_MAGIC_REG * 4,\n\t\t\t\t\t  4, (void *)&rtc_magic_val);\n\t\t\tif ((rtc_magic_val & 0xffff) != RTC_REG_BOOT_MAGIC)\n\t\t\t\tpr_warn(\"PM: bootloader does not support rtc-only!\\n\");\n\n\t\t\tnvmem_device_write(nvmem, RTC_SCRATCH_MAGIC_REG * 4,\n\t\t\t\t\t   4, (void *)&val);\n\t\t\tval = pm_sram->resume_address;\n\t\t\tnvmem_device_write(nvmem, RTC_SCRATCH_RESUME_REG * 4,\n\t\t\t\t\t   4, (void *)&val);\n\t\t}\n\t} else {\n\t\tpr_warn(\"PM: no-rtc available, rtc-only mode disabled.\\n\");\n\t}\n\n\treturn 0;\n\nerr_iounmap:\n\tiounmap(rtc_base_virt);\nerr_clk_put:\n\tclk_put(rtc_fck);\n\n\treturn error;\n}\n\nstatic int am33xx_pm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (!of_machine_is_compatible(\"ti,am33xx\") &&\n\t    !of_machine_is_compatible(\"ti,am43\"))\n\t\treturn -ENODEV;\n\n\tpm_ops = dev->platform_data;\n\tif (!pm_ops) {\n\t\tdev_err(dev, \"PM: Cannot get core PM ops!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = am43xx_map_gic();\n\tif (ret) {\n\t\tpr_err(\"PM: Could not ioremap GIC base\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_sram = pm_ops->get_sram_addrs();\n\tif (!pm_sram) {\n\t\tdev_err(dev, \"PM: Cannot get PM asm function addresses!!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tm3_ipc = wkup_m3_ipc_get();\n\tif (!m3_ipc) {\n\t\tpr_err(\"PM: Cannot get wkup_m3_ipc handle\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tpm33xx_dev = dev;\n\n\tret = am33xx_pm_alloc_sram();\n\tif (ret)\n\t\tgoto err_wkup_m3_ipc_put;\n\n\tret = am33xx_pm_rtc_setup();\n\tif (ret)\n\t\tgoto err_free_sram;\n\n\tret = am33xx_push_sram_idle();\n\tif (ret)\n\t\tgoto err_unsetup_rtc;\n\n\tam33xx_pm_set_ipc_ops();\n\n#ifdef CONFIG_SUSPEND\n\tsuspend_set_ops(&am33xx_pm_ops);\n\n\t \n\tsuspend_wfi_flags |= WFI_FLAG_FLUSH_CACHE;\n\tsuspend_wfi_flags |= WFI_FLAG_SELF_REFRESH;\n\tsuspend_wfi_flags |= WFI_FLAG_SAVE_EMIF;\n\tsuspend_wfi_flags |= WFI_FLAG_WAKE_M3;\n#endif  \n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto err_pm_runtime_disable;\n\n\tret = pm_ops->init(am33xx_do_sram_idle);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to call core pm init!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_pm_runtime_put;\n\t}\n\n\treturn 0;\n\nerr_pm_runtime_put:\n\tpm_runtime_put_sync(dev);\nerr_pm_runtime_disable:\n\tpm_runtime_disable(dev);\nerr_unsetup_rtc:\n\tiounmap(rtc_base_virt);\n\tclk_put(rtc_fck);\nerr_free_sram:\n\tam33xx_pm_free_sram();\n\tpm33xx_dev = NULL;\nerr_wkup_m3_ipc_put:\n\twkup_m3_ipc_put(m3_ipc);\n\treturn ret;\n}\n\nstatic int am33xx_pm_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tif (pm_ops->deinit)\n\t\tpm_ops->deinit();\n\tsuspend_set_ops(NULL);\n\twkup_m3_ipc_put(m3_ipc);\n\tam33xx_pm_free_sram();\n\tiounmap(rtc_base_virt);\n\tclk_put(rtc_fck);\n\treturn 0;\n}\n\nstatic struct platform_driver am33xx_pm_driver = {\n\t.driver = {\n\t\t.name   = \"pm33xx\",\n\t},\n\t.probe = am33xx_pm_probe,\n\t.remove = am33xx_pm_remove,\n};\nmodule_platform_driver(am33xx_pm_driver);\n\nMODULE_ALIAS(\"platform:pm33xx\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"am33xx power management driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}