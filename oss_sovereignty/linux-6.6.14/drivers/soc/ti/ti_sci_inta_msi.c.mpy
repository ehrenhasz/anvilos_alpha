{
  "module_name": "ti_sci_inta_msi.c",
  "hash_id": "e6708fd110f2673bdfe9384e645da631b43f552a66da6c60af464f122bc988f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/ti_sci_inta_msi.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ti/ti_sci_inta_msi.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n\nstatic void ti_sci_inta_msi_write_msg(struct irq_data *data,\n\t\t\t\t      struct msi_msg *msg)\n{\n\t \n}\n\nstatic void ti_sci_inta_msi_compose_msi_msg(struct irq_data *data,\n\t\t\t\t\t    struct msi_msg *msg)\n{\n\t \n}\n\nstatic void ti_sci_inta_msi_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tif (WARN_ON(!chip))\n\t\treturn;\n\n\tchip->irq_request_resources = irq_chip_request_resources_parent;\n\tchip->irq_release_resources = irq_chip_release_resources_parent;\n\tchip->irq_compose_msi_msg = ti_sci_inta_msi_compose_msi_msg;\n\tchip->irq_write_msi_msg = ti_sci_inta_msi_write_msg;\n\tchip->irq_set_type = irq_chip_set_type_parent;\n\tchip->irq_unmask = irq_chip_unmask_parent;\n\tchip->irq_mask = irq_chip_mask_parent;\n\tchip->irq_ack = irq_chip_ack_parent;\n}\n\nstruct irq_domain *ti_sci_inta_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t     struct msi_domain_info *info,\n\t\t\t\t\t\t     struct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tti_sci_inta_msi_update_chip_ops(info);\n\tinfo->flags |= MSI_FLAG_FREE_MSI_DESCS;\n\n\tdomain = msi_create_irq_domain(fwnode, info, parent);\n\tif (domain)\n\t\tirq_domain_update_bus_token(domain, DOMAIN_BUS_TI_SCI_INTA_MSI);\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(ti_sci_inta_msi_create_irq_domain);\n\nstatic int ti_sci_inta_msi_alloc_descs(struct device *dev,\n\t\t\t\t       struct ti_sci_resource *res)\n{\n\tstruct msi_desc msi_desc;\n\tint set, i, count = 0;\n\n\tmemset(&msi_desc, 0, sizeof(msi_desc));\n\tmsi_desc.nvec_used = 1;\n\n\tfor (set = 0; set < res->sets; set++) {\n\t\tfor (i = 0; i < res->desc[set].num; i++, count++) {\n\t\t\tmsi_desc.msi_index = res->desc[set].start + i;\n\t\t\tif (msi_insert_msi_desc(dev, &msi_desc))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (i = 0; i < res->desc[set].num_sec; i++, count++) {\n\t\t\tmsi_desc.msi_index = res->desc[set].start_sec + i;\n\t\t\tif (msi_insert_msi_desc(dev, &msi_desc))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn count;\nfail:\n\tmsi_free_msi_descs(dev);\n\treturn -ENOMEM;\n}\n\nint ti_sci_inta_msi_domain_alloc_irqs(struct device *dev,\n\t\t\t\t      struct ti_sci_resource *res)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret, nvec;\n\n\tif (pdev->id < 0)\n\t\treturn -ENODEV;\n\n\tret = msi_setup_device_data(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmsi_lock_descs(dev);\n\tnvec = ti_sci_inta_msi_alloc_descs(dev, res);\n\tif (nvec <= 0) {\n\t\tret = nvec;\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = msi_domain_alloc_irqs_all_locked(dev, MSI_DEFAULT_DOMAIN, nvec);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to allocate IRQs %d\\n\", ret);\nunlock:\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ti_sci_inta_msi_domain_alloc_irqs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}