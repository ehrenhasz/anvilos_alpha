{
  "module_name": "wkup_m3_ipc.c",
  "hash_id": "337f009e5254825e9d2b2ac15a31c30f50d0c36939d33508f5ba0c1c4c666e00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/wkup_m3_ipc.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/omap-mailbox.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/suspend.h>\n#include <linux/wkup_m3_ipc.h>\n\n#define AM33XX_CTRL_IPC_REG_COUNT\t0x8\n#define AM33XX_CTRL_IPC_REG_OFFSET(m)\t(0x4 + 4 * (m))\n\n \n#define AM33XX_CONTROL_M3_TXEV_EOI\t0x00\n\n#define AM33XX_M3_TXEV_ACK\t\t(0x1 << 0)\n#define AM33XX_M3_TXEV_ENABLE\t\t(0x0 << 0)\n\n#define IPC_CMD_DS0\t\t\t0x4\n#define IPC_CMD_STANDBY\t\t\t0xc\n#define IPC_CMD_IDLE\t\t\t0x10\n#define IPC_CMD_RESET\t\t\t0xe\n#define DS_IPC_DEFAULT\t\t\t0xffffffff\n#define M3_VERSION_UNKNOWN\t\t0x0000ffff\n#define M3_BASELINE_VERSION\t\t0x191\n#define M3_STATUS_RESP_MASK\t\t(0xffff << 16)\n#define M3_FW_VERSION_MASK\t\t0xffff\n#define M3_WAKE_SRC_MASK\t\t0xff\n\n#define IPC_MEM_TYPE_SHIFT\t\t(0x0)\n#define IPC_MEM_TYPE_MASK\t\t(0x7 << 0)\n#define IPC_VTT_STAT_SHIFT\t\t(0x3)\n#define IPC_VTT_STAT_MASK\t\t(0x1 << 3)\n#define IPC_VTT_GPIO_PIN_SHIFT\t\t(0x4)\n#define IPC_VTT_GPIO_PIN_MASK\t\t(0x3f << 4)\n#define IPC_IO_ISOLATION_STAT_SHIFT\t(10)\n#define IPC_IO_ISOLATION_STAT_MASK\t(0x1 << 10)\n\n#define IPC_DBG_HALT_SHIFT\t\t(11)\n#define IPC_DBG_HALT_MASK\t\t(0x1 << 11)\n\n#define M3_STATE_UNKNOWN\t\t0\n#define M3_STATE_RESET\t\t\t1\n#define M3_STATE_INITED\t\t\t2\n#define M3_STATE_MSG_FOR_LP\t\t3\n#define M3_STATE_MSG_FOR_RESET\t\t4\n\n#define WKUP_M3_SD_FW_MAGIC\t\t0x570C\n\n#define WKUP_M3_DMEM_START\t\t0x80000\n#define WKUP_M3_AUXDATA_OFFSET\t\t0x1000\n#define WKUP_M3_AUXDATA_SIZE\t\t0xFF\n\nstatic struct wkup_m3_ipc *m3_ipc_state;\n\nstatic const struct wkup_m3_wakeup_src wakeups[] = {\n\t{.irq_nr = 16,\t.src = \"PRCM\"},\n\t{.irq_nr = 35,\t.src = \"USB0_PHY\"},\n\t{.irq_nr = 36,\t.src = \"USB1_PHY\"},\n\t{.irq_nr = 40,\t.src = \"I2C0\"},\n\t{.irq_nr = 41,\t.src = \"RTC Timer\"},\n\t{.irq_nr = 42,\t.src = \"RTC Alarm\"},\n\t{.irq_nr = 43,\t.src = \"Timer0\"},\n\t{.irq_nr = 44,\t.src = \"Timer1\"},\n\t{.irq_nr = 45,\t.src = \"UART\"},\n\t{.irq_nr = 46,\t.src = \"GPIO0\"},\n\t{.irq_nr = 48,\t.src = \"MPU_WAKE\"},\n\t{.irq_nr = 49,\t.src = \"WDT0\"},\n\t{.irq_nr = 50,\t.src = \"WDT1\"},\n\t{.irq_nr = 51,\t.src = \"ADC_TSC\"},\n\t{.irq_nr = 0,\t.src = \"Unknown\"},\n};\n\n \nstatic unsigned long wkup_m3_copy_aux_data(struct wkup_m3_ipc *m3_ipc,\n\t\t\t\t\t   const void *data, int sz)\n{\n\tunsigned long aux_data_dev_addr;\n\tvoid *aux_data_addr;\n\n\taux_data_dev_addr = WKUP_M3_DMEM_START + WKUP_M3_AUXDATA_OFFSET;\n\taux_data_addr = rproc_da_to_va(m3_ipc->rproc,\n\t\t\t\t       aux_data_dev_addr,\n\t\t\t\t       WKUP_M3_AUXDATA_SIZE,\n\t\t\t\t       NULL);\n\tmemcpy(aux_data_addr, data, sz);\n\n\treturn WKUP_M3_AUXDATA_OFFSET;\n}\n\nstatic void wkup_m3_scale_data_fw_cb(const struct firmware *fw, void *context)\n{\n\tunsigned long val, aux_base;\n\tstruct wkup_m3_scale_data_header hdr;\n\tstruct wkup_m3_ipc *m3_ipc = context;\n\tstruct device *dev = m3_ipc->dev;\n\n\tif (!fw) {\n\t\tdev_err(dev, \"Voltage scale fw name given but file missing.\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(&hdr, fw->data, sizeof(hdr));\n\n\tif (hdr.magic != WKUP_M3_SD_FW_MAGIC) {\n\t\tdev_err(dev, \"PM: Voltage Scale Data binary does not appear valid.\\n\");\n\t\tgoto release_sd_fw;\n\t}\n\n\taux_base = wkup_m3_copy_aux_data(m3_ipc, fw->data + sizeof(hdr),\n\t\t\t\t\t fw->size - sizeof(hdr));\n\n\tval = (aux_base + hdr.sleep_offset);\n\tval |= ((aux_base + hdr.wake_offset) << 16);\n\n\tm3_ipc->volt_scale_offsets = val;\n\nrelease_sd_fw:\n\trelease_firmware(fw);\n};\n\nstatic int wkup_m3_init_scale_data(struct wkup_m3_ipc *m3_ipc,\n\t\t\t\t   struct device *dev)\n{\n\tint ret = 0;\n\n\t \n\n\tif (!m3_ipc->sd_fw_name)\n\t\treturn ret;\n\n\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t      m3_ipc->sd_fw_name, dev, GFP_ATOMIC,\n\t\t\t\t      m3_ipc, wkup_m3_scale_data_fw_cb);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void wkup_m3_set_halt_late(bool enabled)\n{\n\tif (enabled)\n\t\tm3_ipc_state->halt = (1 << IPC_DBG_HALT_SHIFT);\n\telse\n\t\tm3_ipc_state->halt = 0;\n}\n\nstatic int option_get(void *data, u64 *val)\n{\n\tu32 *option = data;\n\n\t*val = *option;\n\n\treturn 0;\n}\n\nstatic int option_set(void *data, u64 val)\n{\n\tu32 *option = data;\n\n\t*option = val;\n\n\tif (option == &m3_ipc_state->halt) {\n\t\tif (val)\n\t\t\twkup_m3_set_halt_late(true);\n\t\telse\n\t\t\twkup_m3_set_halt_late(false);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(wkup_m3_ipc_option_fops, option_get, option_set,\n\t\t\t\"%llu\\n\");\n\nstatic int wkup_m3_ipc_dbg_init(struct wkup_m3_ipc *m3_ipc)\n{\n\tm3_ipc->dbg_path = debugfs_create_dir(\"wkup_m3_ipc\", NULL);\n\n\tif (IS_ERR(m3_ipc->dbg_path))\n\t\treturn -EINVAL;\n\n\t(void)debugfs_create_file(\"enable_late_halt\", 0644,\n\t\t\t\t  m3_ipc->dbg_path,\n\t\t\t\t  &m3_ipc->halt,\n\t\t\t\t  &wkup_m3_ipc_option_fops);\n\n\treturn 0;\n}\n\nstatic inline void wkup_m3_ipc_dbg_destroy(struct wkup_m3_ipc *m3_ipc)\n{\n\tdebugfs_remove_recursive(m3_ipc->dbg_path);\n}\n#else\nstatic inline int wkup_m3_ipc_dbg_init(struct wkup_m3_ipc *m3_ipc)\n{\n\treturn 0;\n}\n\nstatic inline void wkup_m3_ipc_dbg_destroy(struct wkup_m3_ipc *m3_ipc)\n{\n}\n#endif  \n\nstatic void am33xx_txev_eoi(struct wkup_m3_ipc *m3_ipc)\n{\n\twritel(AM33XX_M3_TXEV_ACK,\n\t       m3_ipc->ipc_mem_base + AM33XX_CONTROL_M3_TXEV_EOI);\n}\n\nstatic void am33xx_txev_enable(struct wkup_m3_ipc *m3_ipc)\n{\n\twritel(AM33XX_M3_TXEV_ENABLE,\n\t       m3_ipc->ipc_mem_base + AM33XX_CONTROL_M3_TXEV_EOI);\n}\n\nstatic void wkup_m3_ctrl_ipc_write(struct wkup_m3_ipc *m3_ipc,\n\t\t\t\t   u32 val, int ipc_reg_num)\n{\n\tif (WARN(ipc_reg_num < 0 || ipc_reg_num > AM33XX_CTRL_IPC_REG_COUNT,\n\t\t \"ipc register operation out of range\"))\n\t\treturn;\n\n\twritel(val, m3_ipc->ipc_mem_base +\n\t       AM33XX_CTRL_IPC_REG_OFFSET(ipc_reg_num));\n}\n\nstatic unsigned int wkup_m3_ctrl_ipc_read(struct wkup_m3_ipc *m3_ipc,\n\t\t\t\t\t  int ipc_reg_num)\n{\n\tif (WARN(ipc_reg_num < 0 || ipc_reg_num > AM33XX_CTRL_IPC_REG_COUNT,\n\t\t \"ipc register operation out of range\"))\n\t\treturn 0;\n\n\treturn readl(m3_ipc->ipc_mem_base +\n\t\t     AM33XX_CTRL_IPC_REG_OFFSET(ipc_reg_num));\n}\n\nstatic int wkup_m3_fw_version_read(struct wkup_m3_ipc *m3_ipc)\n{\n\tint val;\n\n\tval = wkup_m3_ctrl_ipc_read(m3_ipc, 2);\n\n\treturn val & M3_FW_VERSION_MASK;\n}\n\nstatic irqreturn_t wkup_m3_txev_handler(int irq, void *ipc_data)\n{\n\tstruct wkup_m3_ipc *m3_ipc = ipc_data;\n\tstruct device *dev = m3_ipc->dev;\n\tint ver = 0;\n\n\tam33xx_txev_eoi(m3_ipc);\n\n\tswitch (m3_ipc->state) {\n\tcase M3_STATE_RESET:\n\t\tver = wkup_m3_fw_version_read(m3_ipc);\n\n\t\tif (ver == M3_VERSION_UNKNOWN ||\n\t\t    ver < M3_BASELINE_VERSION) {\n\t\t\tdev_warn(dev, \"CM3 Firmware Version %x not supported\\n\",\n\t\t\t\t ver);\n\t\t} else {\n\t\t\tdev_info(dev, \"CM3 Firmware Version = 0x%x\\n\", ver);\n\t\t}\n\n\t\tm3_ipc->state = M3_STATE_INITED;\n\t\twkup_m3_init_scale_data(m3_ipc, dev);\n\t\tcomplete(&m3_ipc->sync_complete);\n\t\tbreak;\n\tcase M3_STATE_MSG_FOR_RESET:\n\t\tm3_ipc->state = M3_STATE_INITED;\n\t\tcomplete(&m3_ipc->sync_complete);\n\t\tbreak;\n\tcase M3_STATE_MSG_FOR_LP:\n\t\tcomplete(&m3_ipc->sync_complete);\n\t\tbreak;\n\tcase M3_STATE_UNKNOWN:\n\t\tdev_warn(dev, \"Unknown CM3 State\\n\");\n\t}\n\n\tam33xx_txev_enable(m3_ipc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wkup_m3_ping(struct wkup_m3_ipc *m3_ipc)\n{\n\tstruct device *dev = m3_ipc->dev;\n\tmbox_msg_t dummy_msg = 0;\n\tint ret;\n\n\tif (!m3_ipc->mbox) {\n\t\tdev_err(dev,\n\t\t\t\"No IPC channel to communicate with wkup_m3!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = mbox_send_message(m3_ipc->mbox, &dummy_msg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: mbox_send_message() failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&m3_ipc->sync_complete,\n\t\t\t\t\t  msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(dev, \"MPU<->CM3 sync failure\\n\");\n\t\tm3_ipc->state = M3_STATE_UNKNOWN;\n\t\treturn -EIO;\n\t}\n\n\tmbox_client_txdone(m3_ipc->mbox, 0);\n\treturn 0;\n}\n\nstatic int wkup_m3_ping_noirq(struct wkup_m3_ipc *m3_ipc)\n{\n\tstruct device *dev = m3_ipc->dev;\n\tmbox_msg_t dummy_msg = 0;\n\tint ret;\n\n\tif (!m3_ipc->mbox) {\n\t\tdev_err(dev,\n\t\t\t\"No IPC channel to communicate with wkup_m3!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = mbox_send_message(m3_ipc->mbox, &dummy_msg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: mbox_send_message() failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tmbox_client_txdone(m3_ipc->mbox, 0);\n\treturn 0;\n}\n\nstatic int wkup_m3_is_available(struct wkup_m3_ipc *m3_ipc)\n{\n\treturn ((m3_ipc->state != M3_STATE_RESET) &&\n\t\t(m3_ipc->state != M3_STATE_UNKNOWN));\n}\n\nstatic void wkup_m3_set_vtt_gpio(struct wkup_m3_ipc *m3_ipc, int gpio)\n{\n\tm3_ipc->vtt_conf = (1 << IPC_VTT_STAT_SHIFT) |\n\t\t\t    (gpio << IPC_VTT_GPIO_PIN_SHIFT);\n}\n\nstatic void wkup_m3_set_io_isolation(struct wkup_m3_ipc *m3_ipc)\n{\n\tm3_ipc->isolation_conf = (1 << IPC_IO_ISOLATION_STAT_SHIFT);\n}\n\n \n \nstatic void wkup_m3_set_mem_type(struct wkup_m3_ipc *m3_ipc, int mem_type)\n{\n\tm3_ipc->mem_type = mem_type;\n}\n\n \nstatic void wkup_m3_set_resume_address(struct wkup_m3_ipc *m3_ipc, void *addr)\n{\n\tm3_ipc->resume_addr = (unsigned long)addr;\n}\n\n \nstatic int wkup_m3_request_pm_status(struct wkup_m3_ipc *m3_ipc)\n{\n\tunsigned int i;\n\tint val;\n\n\tval = wkup_m3_ctrl_ipc_read(m3_ipc, 1);\n\n\ti = M3_STATUS_RESP_MASK & val;\n\ti >>= __ffs(M3_STATUS_RESP_MASK);\n\n\treturn i;\n}\n\n \nstatic int wkup_m3_prepare_low_power(struct wkup_m3_ipc *m3_ipc, int state)\n{\n\tstruct device *dev = m3_ipc->dev;\n\tint m3_power_state;\n\tint ret = 0;\n\n\tif (!wkup_m3_is_available(m3_ipc))\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase WKUP_M3_DEEPSLEEP:\n\t\tm3_power_state = IPC_CMD_DS0;\n\t\twkup_m3_ctrl_ipc_write(m3_ipc, m3_ipc->volt_scale_offsets, 5);\n\t\tbreak;\n\tcase WKUP_M3_STANDBY:\n\t\tm3_power_state = IPC_CMD_STANDBY;\n\t\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 5);\n\t\tbreak;\n\tcase WKUP_M3_IDLE:\n\t\tm3_power_state = IPC_CMD_IDLE;\n\t\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 5);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\t \n\twkup_m3_ctrl_ipc_write(m3_ipc, m3_ipc->resume_addr, 0);\n\twkup_m3_ctrl_ipc_write(m3_ipc, m3_power_state, 1);\n\twkup_m3_ctrl_ipc_write(m3_ipc, m3_ipc->mem_type |\n\t\t\t       m3_ipc->vtt_conf |\n\t\t\t       m3_ipc->isolation_conf |\n\t\t\t       m3_ipc->halt, 4);\n\n\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 2);\n\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 3);\n\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 6);\n\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 7);\n\n\tm3_ipc->state = M3_STATE_MSG_FOR_LP;\n\n\tif (state == WKUP_M3_IDLE)\n\t\tret = wkup_m3_ping_noirq(m3_ipc);\n\telse\n\t\tret = wkup_m3_ping(m3_ipc);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to ping CM3\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wkup_m3_finish_low_power(struct wkup_m3_ipc *m3_ipc)\n{\n\tstruct device *dev = m3_ipc->dev;\n\tint ret = 0;\n\n\tif (!wkup_m3_is_available(m3_ipc))\n\t\treturn -ENODEV;\n\n\twkup_m3_ctrl_ipc_write(m3_ipc, IPC_CMD_RESET, 1);\n\twkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 2);\n\n\tm3_ipc->state = M3_STATE_MSG_FOR_RESET;\n\n\tret = wkup_m3_ping(m3_ipc);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to ping CM3\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const char *wkup_m3_request_wake_src(struct wkup_m3_ipc *m3_ipc)\n{\n\tunsigned int wakeup_src_idx;\n\tint j, val;\n\n\tval = wkup_m3_ctrl_ipc_read(m3_ipc, 6);\n\n\twakeup_src_idx = val & M3_WAKE_SRC_MASK;\n\n\tfor (j = 0; j < ARRAY_SIZE(wakeups) - 1; j++) {\n\t\tif (wakeups[j].irq_nr == wakeup_src_idx)\n\t\t\treturn wakeups[j].src;\n\t}\n\treturn wakeups[j].src;\n}\n\n \nstatic void wkup_m3_set_rtc_only(struct wkup_m3_ipc *m3_ipc)\n{\n\tif (m3_ipc_state)\n\t\tm3_ipc_state->is_rtc_only = true;\n}\n\nstatic struct wkup_m3_ipc_ops ipc_ops = {\n\t.set_mem_type = wkup_m3_set_mem_type,\n\t.set_resume_address = wkup_m3_set_resume_address,\n\t.prepare_low_power = wkup_m3_prepare_low_power,\n\t.finish_low_power = wkup_m3_finish_low_power,\n\t.request_pm_status = wkup_m3_request_pm_status,\n\t.request_wake_src = wkup_m3_request_wake_src,\n\t.set_rtc_only = wkup_m3_set_rtc_only,\n};\n\n \nstruct wkup_m3_ipc *wkup_m3_ipc_get(void)\n{\n\tif (m3_ipc_state)\n\t\tget_device(m3_ipc_state->dev);\n\telse\n\t\treturn NULL;\n\n\treturn m3_ipc_state;\n}\nEXPORT_SYMBOL_GPL(wkup_m3_ipc_get);\n\n \nvoid wkup_m3_ipc_put(struct wkup_m3_ipc *m3_ipc)\n{\n\tif (m3_ipc_state)\n\t\tput_device(m3_ipc_state->dev);\n}\nEXPORT_SYMBOL_GPL(wkup_m3_ipc_put);\n\nstatic int wkup_m3_rproc_boot_thread(void *arg)\n{\n\tstruct wkup_m3_ipc *m3_ipc = arg;\n\tstruct device *dev = m3_ipc->dev;\n\tint ret;\n\n\tinit_completion(&m3_ipc->sync_complete);\n\n\tret = rproc_boot(m3_ipc->rproc);\n\tif (ret)\n\t\tdev_err(dev, \"rproc_boot failed\\n\");\n\telse\n\t\tm3_ipc_state = m3_ipc;\n\n\treturn 0;\n}\n\nstatic int wkup_m3_ipc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint irq, ret, temp;\n\tphandle rproc_phandle;\n\tstruct rproc *m3_rproc;\n\tstruct task_struct *task;\n\tstruct wkup_m3_ipc *m3_ipc;\n\tstruct device_node *np = dev->of_node;\n\n\tm3_ipc = devm_kzalloc(dev, sizeof(*m3_ipc), GFP_KERNEL);\n\tif (!m3_ipc)\n\t\treturn -ENOMEM;\n\n\tm3_ipc->ipc_mem_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(m3_ipc->ipc_mem_base))\n\t\treturn PTR_ERR(m3_ipc->ipc_mem_base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, wkup_m3_txev_handler,\n\t\t\t       0, \"wkup_m3_txev\", m3_ipc);\n\tif (ret) {\n\t\tdev_err(dev, \"request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\tm3_ipc->mbox_client.dev = dev;\n\tm3_ipc->mbox_client.tx_done = NULL;\n\tm3_ipc->mbox_client.tx_prepare = NULL;\n\tm3_ipc->mbox_client.rx_callback = NULL;\n\tm3_ipc->mbox_client.tx_block = false;\n\tm3_ipc->mbox_client.knows_txdone = false;\n\n\tm3_ipc->mbox = mbox_request_channel(&m3_ipc->mbox_client, 0);\n\n\tif (IS_ERR(m3_ipc->mbox)) {\n\t\tdev_err(dev, \"IPC Request for A8->M3 Channel failed! %ld\\n\",\n\t\t\tPTR_ERR(m3_ipc->mbox));\n\t\treturn PTR_ERR(m3_ipc->mbox);\n\t}\n\n\tif (of_property_read_u32(dev->of_node, \"ti,rproc\", &rproc_phandle)) {\n\t\tdev_err(&pdev->dev, \"could not get rproc phandle\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free_mbox;\n\t}\n\n\tm3_rproc = rproc_get_by_phandle(rproc_phandle);\n\tif (!m3_rproc) {\n\t\tdev_err(&pdev->dev, \"could not get rproc handle\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_free_mbox;\n\t}\n\n\tm3_ipc->rproc = m3_rproc;\n\tm3_ipc->dev = dev;\n\tm3_ipc->state = M3_STATE_RESET;\n\n\tm3_ipc->ops = &ipc_ops;\n\n\tif (!of_property_read_u32(np, \"ti,vtt-gpio-pin\", &temp)) {\n\t\tif (temp >= 0 && temp <= 31)\n\t\t\twkup_m3_set_vtt_gpio(m3_ipc, temp);\n\t\telse\n\t\t\tdev_warn(dev, \"Invalid VTT GPIO(%d) pin\\n\", temp);\n\t}\n\n\tif (of_property_read_bool(np, \"ti,set-io-isolation\"))\n\t\twkup_m3_set_io_isolation(m3_ipc);\n\n\tret = of_property_read_string(np, \"firmware-name\",\n\t\t\t\t      &m3_ipc->sd_fw_name);\n\tif (ret) {\n\t\tdev_dbg(dev, \"Voltage scaling data blob not provided from DT.\\n\");\n\t}\n\n\t \n\ttask = kthread_run(wkup_m3_rproc_boot_thread, m3_ipc,\n\t\t\t   \"wkup_m3_rproc_loader\");\n\n\tif (IS_ERR(task)) {\n\t\tdev_err(dev, \"can't create rproc_boot thread\\n\");\n\t\tret = PTR_ERR(task);\n\t\tgoto err_put_rproc;\n\t}\n\n\twkup_m3_ipc_dbg_init(m3_ipc);\n\n\treturn 0;\n\nerr_put_rproc:\n\trproc_put(m3_rproc);\nerr_free_mbox:\n\tmbox_free_channel(m3_ipc->mbox);\n\treturn ret;\n}\n\nstatic int wkup_m3_ipc_remove(struct platform_device *pdev)\n{\n\twkup_m3_ipc_dbg_destroy(m3_ipc_state);\n\n\tmbox_free_channel(m3_ipc_state->mbox);\n\n\trproc_shutdown(m3_ipc_state->rproc);\n\trproc_put(m3_ipc_state->rproc);\n\n\tm3_ipc_state = NULL;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused wkup_m3_ipc_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int __maybe_unused wkup_m3_ipc_resume(struct device *dev)\n{\n\tif (m3_ipc_state->is_rtc_only) {\n\t\trproc_shutdown(m3_ipc_state->rproc);\n\t\trproc_boot(m3_ipc_state->rproc);\n\t}\n\n\tm3_ipc_state->is_rtc_only = false;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wkup_m3_ipc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(wkup_m3_ipc_suspend, wkup_m3_ipc_resume)\n};\n\nstatic const struct of_device_id wkup_m3_ipc_of_match[] = {\n\t{ .compatible = \"ti,am3352-wkup-m3-ipc\", },\n\t{ .compatible = \"ti,am4372-wkup-m3-ipc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, wkup_m3_ipc_of_match);\n\nstatic struct platform_driver wkup_m3_ipc_driver = {\n\t.probe = wkup_m3_ipc_probe,\n\t.remove = wkup_m3_ipc_remove,\n\t.driver = {\n\t\t.name = \"wkup_m3_ipc\",\n\t\t.of_match_table = wkup_m3_ipc_of_match,\n\t\t.pm = &wkup_m3_ipc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(wkup_m3_ipc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"wkup m3 remote processor ipc driver\");\nMODULE_AUTHOR(\"Dave Gerlach <d-gerlach@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}