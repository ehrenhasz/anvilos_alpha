{
  "module_name": "k3-socinfo.c",
  "hash_id": "fd2927683d2ce3291c44e495601e051865f73bef0262860096ce49fa8a93d473",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/k3-socinfo.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sys_soc.h>\n\n#define CTRLMMR_WKUP_JTAGID_REG\t\t0\n \n#define CTRLMMR_WKUP_JTAGID_VARIANT_SHIFT\t(28)\n#define CTRLMMR_WKUP_JTAGID_VARIANT_MASK\tGENMASK(31, 28)\n\n#define CTRLMMR_WKUP_JTAGID_PARTNO_SHIFT\t(12)\n#define CTRLMMR_WKUP_JTAGID_PARTNO_MASK\t\tGENMASK(27, 12)\n\n#define CTRLMMR_WKUP_JTAGID_MFG_SHIFT\t\t(1)\n#define CTRLMMR_WKUP_JTAGID_MFG_MASK\t\tGENMASK(11, 1)\n\n#define CTRLMMR_WKUP_JTAGID_MFG_TI\t\t0x17\n\nstatic const struct k3_soc_id {\n\tunsigned int id;\n\tconst char *family_name;\n} k3_soc_ids[] = {\n\t{ 0xBB5A, \"AM65X\" },\n\t{ 0xBB64, \"J721E\" },\n\t{ 0xBB6D, \"J7200\" },\n\t{ 0xBB38, \"AM64X\" },\n\t{ 0xBB75, \"J721S2\"},\n\t{ 0xBB7E, \"AM62X\" },\n\t{ 0xBB80, \"J784S4\" },\n\t{ 0xBB8D, \"AM62AX\" },\n\t{ 0xBB9D, \"AM62PX\" },\n};\n\nstatic int\nk3_chipinfo_partno_to_names(unsigned int partno,\n\t\t\t    struct soc_device_attribute *soc_dev_attr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(k3_soc_ids); i++)\n\t\tif (partno == k3_soc_ids[i].id) {\n\t\t\tsoc_dev_attr->family = k3_soc_ids[i].family_name;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int k3_chipinfo_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct device *dev = &pdev->dev;\n\tstruct soc_device *soc_dev;\n\tstruct regmap *regmap;\n\tu32 partno_id;\n\tu32 variant;\n\tu32 jtag_id;\n\tu32 mfg;\n\tint ret;\n\n\tregmap = device_node_to_regmap(node);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = regmap_read(regmap, CTRLMMR_WKUP_JTAGID_REG, &jtag_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmfg = (jtag_id & CTRLMMR_WKUP_JTAGID_MFG_MASK) >>\n\t       CTRLMMR_WKUP_JTAGID_MFG_SHIFT;\n\n\tif (mfg != CTRLMMR_WKUP_JTAGID_MFG_TI) {\n\t\tdev_err(dev, \"Invalid MFG SoC\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tvariant = (jtag_id & CTRLMMR_WKUP_JTAGID_VARIANT_MASK) >>\n\t\t  CTRLMMR_WKUP_JTAGID_VARIANT_SHIFT;\n\tvariant++;\n\n\tpartno_id = (jtag_id & CTRLMMR_WKUP_JTAGID_PARTNO_MASK) >>\n\t\t CTRLMMR_WKUP_JTAGID_PARTNO_SHIFT;\n\n\tsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENOMEM;\n\n\tsoc_dev_attr->revision = kasprintf(GFP_KERNEL, \"SR%x.0\", variant);\n\tif (!soc_dev_attr->revision) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = k3_chipinfo_partno_to_names(partno_id, soc_dev_attr);\n\tif (ret) {\n\t\tdev_err(dev, \"Unknown SoC JTAGID[0x%08X]\\n\", jtag_id);\n\t\tret = -ENODEV;\n\t\tgoto err_free_rev;\n\t}\n\n\tnode = of_find_node_by_path(\"/\");\n\tof_property_read_string(node, \"model\", &soc_dev_attr->machine);\n\tof_node_put(node);\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev)) {\n\t\tret = PTR_ERR(soc_dev);\n\t\tgoto err_free_rev;\n\t}\n\n\tdev_info(dev, \"Family:%s rev:%s JTAGID[0x%08x] Detected\\n\",\n\t\t soc_dev_attr->family,\n\t\t soc_dev_attr->revision, jtag_id);\n\n\treturn 0;\n\nerr_free_rev:\n\tkfree(soc_dev_attr->revision);\nerr:\n\tkfree(soc_dev_attr);\n\treturn ret;\n}\n\nstatic const struct of_device_id k3_chipinfo_of_match[] = {\n\t{ .compatible = \"ti,am654-chipid\", },\n\t{   },\n};\n\nstatic struct platform_driver k3_chipinfo_driver = {\n\t.driver = {\n\t\t.name = \"k3-chipinfo\",\n\t\t.of_match_table = k3_chipinfo_of_match,\n\t},\n\t.probe = k3_chipinfo_probe,\n};\n\nstatic int __init k3_chipinfo_init(void)\n{\n\treturn platform_driver_register(&k3_chipinfo_driver);\n}\nsubsys_initcall(k3_chipinfo_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}