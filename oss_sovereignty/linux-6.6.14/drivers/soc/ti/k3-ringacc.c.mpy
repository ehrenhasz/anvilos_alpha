{
  "module_name": "k3-ringacc.c",
  "hash_id": "5a5848d97304f309ff6a03914accd6f250ed82353da152b18a7eca468e97e05b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/k3-ringacc.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sys_soc.h>\n#include <linux/dma/ti-cppi5.h>\n#include <linux/soc/ti/k3-ringacc.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n#include <linux/soc/ti/ti_sci_inta_msi.h>\n#include <linux/of_irq.h>\n#include <linux/irqdomain.h>\n\nstatic LIST_HEAD(k3_ringacc_list);\nstatic DEFINE_MUTEX(k3_ringacc_list_lock);\n\n#define K3_RINGACC_CFG_RING_SIZE_ELCNT_MASK\t\tGENMASK(19, 0)\n#define K3_DMARING_CFG_RING_SIZE_ELCNT_MASK\t\tGENMASK(15, 0)\n\n \nstruct k3_ring_rt_regs {\n\tu32\tresv_16[4];\n\tu32\tdb;\n\tu32\tresv_4[1];\n\tu32\tocc;\n\tu32\tindx;\n\tu32\thwocc;\n\tu32\thwindx;\n};\n\n#define K3_RINGACC_RT_REGS_STEP\t\t\t0x1000\n#define K3_DMARING_RT_REGS_STEP\t\t\t0x2000\n#define K3_DMARING_RT_REGS_REVERSE_OFS\t\t0x1000\n#define K3_RINGACC_RT_OCC_MASK\t\t\tGENMASK(20, 0)\n#define K3_DMARING_RT_OCC_TDOWN_COMPLETE\tBIT(31)\n#define K3_DMARING_RT_DB_ENTRY_MASK\t\tGENMASK(7, 0)\n#define K3_DMARING_RT_DB_TDOWN_ACK\t\tBIT(31)\n\n \nstruct k3_ring_fifo_regs {\n\tu32\thead_data[128];\n\tu32\ttail_data[128];\n\tu32\tpeek_head_data[128];\n\tu32\tpeek_tail_data[128];\n};\n\n \nstruct k3_ringacc_proxy_gcfg_regs {\n\tu32\trevision;\n\tu32\tconfig;\n};\n\n#define K3_RINGACC_PROXY_CFG_THREADS_MASK\t\tGENMASK(15, 0)\n\n \nstruct k3_ringacc_proxy_target_regs {\n\tu32\tcontrol;\n\tu32\tstatus;\n\tu8\tresv_512[504];\n\tu32\tdata[128];\n};\n\n#define K3_RINGACC_PROXY_TARGET_STEP\t0x1000\n#define K3_RINGACC_PROXY_NOT_USED\t(-1)\n\nenum k3_ringacc_proxy_access_mode {\n\tPROXY_ACCESS_MODE_HEAD = 0,\n\tPROXY_ACCESS_MODE_TAIL = 1,\n\tPROXY_ACCESS_MODE_PEEK_HEAD = 2,\n\tPROXY_ACCESS_MODE_PEEK_TAIL = 3,\n};\n\n#define K3_RINGACC_FIFO_WINDOW_SIZE_BYTES  (512U)\n#define K3_RINGACC_FIFO_REGS_STEP\t0x1000\n#define K3_RINGACC_MAX_DB_RING_CNT    (127U)\n\nstruct k3_ring_ops {\n\tint (*push_tail)(struct k3_ring *ring, void *elm);\n\tint (*push_head)(struct k3_ring *ring, void *elm);\n\tint (*pop_tail)(struct k3_ring *ring, void *elm);\n\tint (*pop_head)(struct k3_ring *ring, void *elm);\n};\n\n \nstruct k3_ring_state {\n\tu32 free;\n\tu32 occ;\n\tu32 windex;\n\tu32 rindex;\n\tu32 tdown_complete:1;\n};\n\n \nstruct k3_ring {\n\tstruct k3_ring_rt_regs __iomem *rt;\n\tstruct k3_ring_fifo_regs __iomem *fifos;\n\tstruct k3_ringacc_proxy_target_regs  __iomem *proxy;\n\tdma_addr_t\tring_mem_dma;\n\tvoid\t\t*ring_mem_virt;\n\tstruct k3_ring_ops *ops;\n\tu32\t\tsize;\n\tenum k3_ring_size elm_size;\n\tenum k3_ring_mode mode;\n\tu32\t\tflags;\n#define K3_RING_FLAG_BUSY\tBIT(1)\n#define K3_RING_FLAG_SHARED\tBIT(2)\n#define K3_RING_FLAG_REVERSE\tBIT(3)\n\tstruct k3_ring_state state;\n\tu32\t\tring_id;\n\tstruct k3_ringacc\t*parent;\n\tu32\t\tuse_count;\n\tint\t\tproxy_id;\n\tstruct device\t*dma_dev;\n\tu32\t\tasel;\n#define K3_ADDRESS_ASEL_SHIFT\t48\n};\n\nstruct k3_ringacc_ops {\n\tint (*init)(struct platform_device *pdev, struct k3_ringacc *ringacc);\n};\n\n \nstruct k3_ringacc {\n\tstruct device *dev;\n\tstruct k3_ringacc_proxy_gcfg_regs __iomem *proxy_gcfg;\n\tvoid __iomem *proxy_target_base;\n\tu32 num_rings;  \n\tunsigned long *rings_inuse;\n\tstruct ti_sci_resource *rm_gp_range;\n\n\tbool dma_ring_reset_quirk;\n\tu32 num_proxies;\n\tunsigned long *proxy_inuse;\n\n\tstruct k3_ring *rings;\n\tstruct list_head list;\n\tstruct mutex req_lock;  \n\n\tconst struct ti_sci_handle *tisci;\n\tconst struct ti_sci_rm_ringacc_ops *tisci_ring_ops;\n\tu32 tisci_dev_id;\n\n\tconst struct k3_ringacc_ops *ops;\n\tbool dma_rings;\n};\n\n \nstruct k3_ringacc_soc_data {\n\tunsigned dma_ring_reset_quirk:1;\n};\n\nstatic int k3_ringacc_ring_read_occ(struct k3_ring *ring)\n{\n\treturn readl(&ring->rt->occ) & K3_RINGACC_RT_OCC_MASK;\n}\n\nstatic void k3_ringacc_ring_update_occ(struct k3_ring *ring)\n{\n\tu32 val;\n\n\tval = readl(&ring->rt->occ);\n\n\tring->state.occ = val & K3_RINGACC_RT_OCC_MASK;\n\tring->state.tdown_complete = !!(val & K3_DMARING_RT_OCC_TDOWN_COMPLETE);\n}\n\nstatic long k3_ringacc_ring_get_fifo_pos(struct k3_ring *ring)\n{\n\treturn K3_RINGACC_FIFO_WINDOW_SIZE_BYTES -\n\t       (4 << ring->elm_size);\n}\n\nstatic void *k3_ringacc_get_elm_addr(struct k3_ring *ring, u32 idx)\n{\n\treturn (ring->ring_mem_virt + idx * (4 << ring->elm_size));\n}\n\nstatic int k3_ringacc_ring_push_mem(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_pop_mem(struct k3_ring *ring, void *elem);\nstatic int k3_dmaring_fwd_pop(struct k3_ring *ring, void *elem);\nstatic int k3_dmaring_reverse_pop(struct k3_ring *ring, void *elem);\n\nstatic struct k3_ring_ops k3_ring_mode_ring_ops = {\n\t\t.push_tail = k3_ringacc_ring_push_mem,\n\t\t.pop_head = k3_ringacc_ring_pop_mem,\n};\n\nstatic struct k3_ring_ops k3_dmaring_fwd_ops = {\n\t\t.push_tail = k3_ringacc_ring_push_mem,\n\t\t.pop_head = k3_dmaring_fwd_pop,\n};\n\nstatic struct k3_ring_ops k3_dmaring_reverse_ops = {\n\t\t \n\t\t.pop_head = k3_dmaring_reverse_pop,\n};\n\nstatic int k3_ringacc_ring_push_io(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_pop_io(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_push_head_io(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_pop_tail_io(struct k3_ring *ring, void *elem);\n\nstatic struct k3_ring_ops k3_ring_mode_msg_ops = {\n\t\t.push_tail = k3_ringacc_ring_push_io,\n\t\t.push_head = k3_ringacc_ring_push_head_io,\n\t\t.pop_tail = k3_ringacc_ring_pop_tail_io,\n\t\t.pop_head = k3_ringacc_ring_pop_io,\n};\n\nstatic int k3_ringacc_ring_push_head_proxy(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_push_tail_proxy(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_pop_head_proxy(struct k3_ring *ring, void *elem);\nstatic int k3_ringacc_ring_pop_tail_proxy(struct k3_ring *ring, void *elem);\n\nstatic struct k3_ring_ops k3_ring_mode_proxy_ops = {\n\t\t.push_tail = k3_ringacc_ring_push_tail_proxy,\n\t\t.push_head = k3_ringacc_ring_push_head_proxy,\n\t\t.pop_tail = k3_ringacc_ring_pop_tail_proxy,\n\t\t.pop_head = k3_ringacc_ring_pop_head_proxy,\n};\n\nstatic void k3_ringacc_ring_dump(struct k3_ring *ring)\n{\n\tstruct device *dev = ring->parent->dev;\n\n\tdev_dbg(dev, \"dump ring: %d\\n\", ring->ring_id);\n\tdev_dbg(dev, \"dump mem virt %p, dma %pad\\n\", ring->ring_mem_virt,\n\t\t&ring->ring_mem_dma);\n\tdev_dbg(dev, \"dump elmsize %d, size %d, mode %d, proxy_id %d\\n\",\n\t\tring->elm_size, ring->size, ring->mode, ring->proxy_id);\n\tdev_dbg(dev, \"dump flags %08X\\n\", ring->flags);\n\n\tdev_dbg(dev, \"dump ring_rt_regs: db%08x\\n\", readl(&ring->rt->db));\n\tdev_dbg(dev, \"dump occ%08x\\n\", readl(&ring->rt->occ));\n\tdev_dbg(dev, \"dump indx%08x\\n\", readl(&ring->rt->indx));\n\tdev_dbg(dev, \"dump hwocc%08x\\n\", readl(&ring->rt->hwocc));\n\tdev_dbg(dev, \"dump hwindx%08x\\n\", readl(&ring->rt->hwindx));\n\n\tif (ring->ring_mem_virt)\n\t\tprint_hex_dump_debug(\"dump ring_mem_virt \", DUMP_PREFIX_NONE,\n\t\t\t\t     16, 1, ring->ring_mem_virt, 16 * 8, false);\n}\n\nstruct k3_ring *k3_ringacc_request_ring(struct k3_ringacc *ringacc,\n\t\t\t\t\tint id, u32 flags)\n{\n\tint proxy_id = K3_RINGACC_PROXY_NOT_USED;\n\n\tmutex_lock(&ringacc->req_lock);\n\n\tif (!try_module_get(ringacc->dev->driver->owner))\n\t\tgoto err_module_get;\n\n\tif (id == K3_RINGACC_RING_ID_ANY) {\n\t\t \n\t\tstruct ti_sci_resource_desc *gp_rings =\n\t\t\t\t\t\t&ringacc->rm_gp_range->desc[0];\n\t\tunsigned long size;\n\n\t\tsize = gp_rings->start + gp_rings->num;\n\t\tid = find_next_zero_bit(ringacc->rings_inuse, size,\n\t\t\t\t\tgp_rings->start);\n\t\tif (id == size)\n\t\t\tgoto error;\n\t} else if (id < 0) {\n\t\tgoto error;\n\t}\n\n\tif (test_bit(id, ringacc->rings_inuse) &&\n\t    !(ringacc->rings[id].flags & K3_RING_FLAG_SHARED))\n\t\tgoto error;\n\telse if (ringacc->rings[id].flags & K3_RING_FLAG_SHARED)\n\t\tgoto out;\n\n\tif (flags & K3_RINGACC_RING_USE_PROXY) {\n\t\tproxy_id = find_first_zero_bit(ringacc->proxy_inuse,\n\t\t\t\t\t      ringacc->num_proxies);\n\t\tif (proxy_id == ringacc->num_proxies)\n\t\t\tgoto error;\n\t}\n\n\tif (proxy_id != K3_RINGACC_PROXY_NOT_USED) {\n\t\tset_bit(proxy_id, ringacc->proxy_inuse);\n\t\tringacc->rings[id].proxy_id = proxy_id;\n\t\tdev_dbg(ringacc->dev, \"Giving ring#%d proxy#%d\\n\", id,\n\t\t\tproxy_id);\n\t} else {\n\t\tdev_dbg(ringacc->dev, \"Giving ring#%d\\n\", id);\n\t}\n\n\tset_bit(id, ringacc->rings_inuse);\nout:\n\tringacc->rings[id].use_count++;\n\tmutex_unlock(&ringacc->req_lock);\n\treturn &ringacc->rings[id];\n\nerror:\n\tmodule_put(ringacc->dev->driver->owner);\n\nerr_module_get:\n\tmutex_unlock(&ringacc->req_lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_request_ring);\n\nstatic int k3_dmaring_request_dual_ring(struct k3_ringacc *ringacc, int fwd_id,\n\t\t\t\t\tstruct k3_ring **fwd_ring,\n\t\t\t\t\tstruct k3_ring **compl_ring)\n{\n\tint ret = 0;\n\n\t \n\tif (fwd_id < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ringacc->req_lock);\n\n\tif (!try_module_get(ringacc->dev->driver->owner)) {\n\t\tret = -EINVAL;\n\t\tgoto err_module_get;\n\t}\n\n\tif (test_bit(fwd_id, ringacc->rings_inuse)) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t*fwd_ring = &ringacc->rings[fwd_id];\n\t*compl_ring = &ringacc->rings[fwd_id + ringacc->num_rings];\n\tset_bit(fwd_id, ringacc->rings_inuse);\n\tringacc->rings[fwd_id].use_count++;\n\tdev_dbg(ringacc->dev, \"Giving ring#%d\\n\", fwd_id);\n\n\tmutex_unlock(&ringacc->req_lock);\n\treturn 0;\n\nerror:\n\tmodule_put(ringacc->dev->driver->owner);\nerr_module_get:\n\tmutex_unlock(&ringacc->req_lock);\n\treturn ret;\n}\n\nint k3_ringacc_request_rings_pair(struct k3_ringacc *ringacc,\n\t\t\t\t  int fwd_id, int compl_id,\n\t\t\t\t  struct k3_ring **fwd_ring,\n\t\t\t\t  struct k3_ring **compl_ring)\n{\n\tint ret = 0;\n\n\tif (!fwd_ring || !compl_ring)\n\t\treturn -EINVAL;\n\n\tif (ringacc->dma_rings)\n\t\treturn k3_dmaring_request_dual_ring(ringacc, fwd_id,\n\t\t\t\t\t\t    fwd_ring, compl_ring);\n\n\t*fwd_ring = k3_ringacc_request_ring(ringacc, fwd_id, 0);\n\tif (!(*fwd_ring))\n\t\treturn -ENODEV;\n\n\t*compl_ring = k3_ringacc_request_ring(ringacc, compl_id, 0);\n\tif (!(*compl_ring)) {\n\t\tk3_ringacc_ring_free(*fwd_ring);\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_request_rings_pair);\n\nstatic void k3_ringacc_ring_reset_sci(struct k3_ring *ring)\n{\n\tstruct ti_sci_msg_rm_ring_cfg ring_cfg = { 0 };\n\tstruct k3_ringacc *ringacc = ring->parent;\n\tint ret;\n\n\tring_cfg.nav_id = ringacc->tisci_dev_id;\n\tring_cfg.index = ring->ring_id;\n\tring_cfg.valid_params = TI_SCI_MSG_VALUE_RM_RING_COUNT_VALID;\n\tring_cfg.count = ring->size;\n\n\tret = ringacc->tisci_ring_ops->set_cfg(ringacc->tisci, &ring_cfg);\n\tif (ret)\n\t\tdev_err(ringacc->dev, \"TISCI reset ring fail (%d) ring_idx %d\\n\",\n\t\t\tret, ring->ring_id);\n}\n\nvoid k3_ringacc_ring_reset(struct k3_ring *ring)\n{\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn;\n\n\tmemset(&ring->state, 0, sizeof(ring->state));\n\n\tk3_ringacc_ring_reset_sci(ring);\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_reset);\n\nstatic void k3_ringacc_ring_reconfig_qmode_sci(struct k3_ring *ring,\n\t\t\t\t\t       enum k3_ring_mode mode)\n{\n\tstruct ti_sci_msg_rm_ring_cfg ring_cfg = { 0 };\n\tstruct k3_ringacc *ringacc = ring->parent;\n\tint ret;\n\n\tring_cfg.nav_id = ringacc->tisci_dev_id;\n\tring_cfg.index = ring->ring_id;\n\tring_cfg.valid_params = TI_SCI_MSG_VALUE_RM_RING_MODE_VALID;\n\tring_cfg.mode = mode;\n\n\tret = ringacc->tisci_ring_ops->set_cfg(ringacc->tisci, &ring_cfg);\n\tif (ret)\n\t\tdev_err(ringacc->dev, \"TISCI reconf qmode fail (%d) ring_idx %d\\n\",\n\t\t\tret, ring->ring_id);\n}\n\nvoid k3_ringacc_ring_reset_dma(struct k3_ring *ring, u32 occ)\n{\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn;\n\n\tif (!ring->parent->dma_ring_reset_quirk)\n\t\tgoto reset;\n\n\tif (!occ)\n\t\tocc = k3_ringacc_ring_read_occ(ring);\n\n\tif (occ) {\n\t\tu32 db_ring_cnt, db_ring_cnt_cur;\n\n\t\tdev_dbg(ring->parent->dev, \"%s %u occ: %u\\n\", __func__,\n\t\t\tring->ring_id, occ);\n\t\t \n\t\tk3_ringacc_ring_reset_sci(ring);\n\n\t\t \n\t\tif (ring->mode != K3_RINGACC_RING_MODE_RING)\n\t\t\tk3_ringacc_ring_reconfig_qmode_sci(\n\t\t\t\t\tring, K3_RINGACC_RING_MODE_RING);\n\t\t \n\t\tdb_ring_cnt = (1U << 22) - occ;\n\n\t\twhile (db_ring_cnt != 0) {\n\t\t\t \n\t\t\tif (db_ring_cnt > K3_RINGACC_MAX_DB_RING_CNT)\n\t\t\t\tdb_ring_cnt_cur = K3_RINGACC_MAX_DB_RING_CNT;\n\t\t\telse\n\t\t\t\tdb_ring_cnt_cur = db_ring_cnt;\n\n\t\t\twritel(db_ring_cnt_cur, &ring->rt->db);\n\t\t\tdb_ring_cnt -= db_ring_cnt_cur;\n\t\t}\n\n\t\t \n\t\tif (ring->mode != K3_RINGACC_RING_MODE_RING)\n\t\t\tk3_ringacc_ring_reconfig_qmode_sci(ring, ring->mode);\n\t}\n\nreset:\n\t \n\tk3_ringacc_ring_reset(ring);\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_reset_dma);\n\nstatic void k3_ringacc_ring_free_sci(struct k3_ring *ring)\n{\n\tstruct ti_sci_msg_rm_ring_cfg ring_cfg = { 0 };\n\tstruct k3_ringacc *ringacc = ring->parent;\n\tint ret;\n\n\tring_cfg.nav_id = ringacc->tisci_dev_id;\n\tring_cfg.index = ring->ring_id;\n\tring_cfg.valid_params = TI_SCI_MSG_VALUE_RM_ALL_NO_ORDER;\n\n\tret = ringacc->tisci_ring_ops->set_cfg(ringacc->tisci, &ring_cfg);\n\tif (ret)\n\t\tdev_err(ringacc->dev, \"TISCI ring free fail (%d) ring_idx %d\\n\",\n\t\t\tret, ring->ring_id);\n}\n\nint k3_ringacc_ring_free(struct k3_ring *ring)\n{\n\tstruct k3_ringacc *ringacc;\n\n\tif (!ring)\n\t\treturn -EINVAL;\n\n\tringacc = ring->parent;\n\n\t \n\tif (ringacc->dma_rings && (ring->flags & K3_RING_FLAG_REVERSE))\n\t\treturn 0;\n\n\tdev_dbg(ring->parent->dev, \"flags: 0x%08x\\n\", ring->flags);\n\n\tif (!test_bit(ring->ring_id, ringacc->rings_inuse))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ringacc->req_lock);\n\n\tif (--ring->use_count)\n\t\tgoto out;\n\n\tif (!(ring->flags & K3_RING_FLAG_BUSY))\n\t\tgoto no_init;\n\n\tk3_ringacc_ring_free_sci(ring);\n\n\tdma_free_coherent(ring->dma_dev,\n\t\t\t  ring->size * (4 << ring->elm_size),\n\t\t\t  ring->ring_mem_virt, ring->ring_mem_dma);\n\tring->flags = 0;\n\tring->ops = NULL;\n\tring->dma_dev = NULL;\n\tring->asel = 0;\n\n\tif (ring->proxy_id != K3_RINGACC_PROXY_NOT_USED) {\n\t\tclear_bit(ring->proxy_id, ringacc->proxy_inuse);\n\t\tring->proxy = NULL;\n\t\tring->proxy_id = K3_RINGACC_PROXY_NOT_USED;\n\t}\n\nno_init:\n\tclear_bit(ring->ring_id, ringacc->rings_inuse);\n\n\tmodule_put(ringacc->dev->driver->owner);\n\nout:\n\tmutex_unlock(&ringacc->req_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_free);\n\nu32 k3_ringacc_get_ring_id(struct k3_ring *ring)\n{\n\tif (!ring)\n\t\treturn -EINVAL;\n\n\treturn ring->ring_id;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_get_ring_id);\n\nu32 k3_ringacc_get_tisci_dev_id(struct k3_ring *ring)\n{\n\tif (!ring)\n\t\treturn -EINVAL;\n\n\treturn ring->parent->tisci_dev_id;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_get_tisci_dev_id);\n\nint k3_ringacc_get_ring_irq_num(struct k3_ring *ring)\n{\n\tint irq_num;\n\n\tif (!ring)\n\t\treturn -EINVAL;\n\n\tirq_num = msi_get_virq(ring->parent->dev, ring->ring_id);\n\tif (irq_num <= 0)\n\t\tirq_num = -EINVAL;\n\treturn irq_num;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_get_ring_irq_num);\n\nstatic int k3_ringacc_ring_cfg_sci(struct k3_ring *ring)\n{\n\tstruct ti_sci_msg_rm_ring_cfg ring_cfg = { 0 };\n\tstruct k3_ringacc *ringacc = ring->parent;\n\tint ret;\n\n\tif (!ringacc->tisci)\n\t\treturn -EINVAL;\n\n\tring_cfg.nav_id = ringacc->tisci_dev_id;\n\tring_cfg.index = ring->ring_id;\n\tring_cfg.valid_params = TI_SCI_MSG_VALUE_RM_ALL_NO_ORDER;\n\tring_cfg.addr_lo = lower_32_bits(ring->ring_mem_dma);\n\tring_cfg.addr_hi = upper_32_bits(ring->ring_mem_dma);\n\tring_cfg.count = ring->size;\n\tring_cfg.mode = ring->mode;\n\tring_cfg.size = ring->elm_size;\n\tring_cfg.asel = ring->asel;\n\n\tret = ringacc->tisci_ring_ops->set_cfg(ringacc->tisci, &ring_cfg);\n\tif (ret)\n\t\tdev_err(ringacc->dev, \"TISCI config ring fail (%d) ring_idx %d\\n\",\n\t\t\tret, ring->ring_id);\n\n\treturn ret;\n}\n\nstatic int k3_dmaring_cfg(struct k3_ring *ring, struct k3_ring_cfg *cfg)\n{\n\tstruct k3_ringacc *ringacc;\n\tstruct k3_ring *reverse_ring;\n\tint ret = 0;\n\n\tif (cfg->elm_size != K3_RINGACC_RING_ELSIZE_8 ||\n\t    cfg->mode != K3_RINGACC_RING_MODE_RING ||\n\t    cfg->size & ~K3_DMARING_CFG_RING_SIZE_ELCNT_MASK)\n\t\treturn -EINVAL;\n\n\tringacc = ring->parent;\n\n\t \n\tif (ringacc->dma_rings && (ring->flags & K3_RING_FLAG_REVERSE))\n\t\treturn 0;\n\n\tif (!test_bit(ring->ring_id, ringacc->rings_inuse))\n\t\treturn -EINVAL;\n\n\tring->size = cfg->size;\n\tring->elm_size = cfg->elm_size;\n\tring->mode = cfg->mode;\n\tring->asel = cfg->asel;\n\tring->dma_dev = cfg->dma_dev;\n\tif (!ring->dma_dev) {\n\t\tdev_warn(ringacc->dev, \"dma_dev is not provided for ring%d\\n\",\n\t\t\t ring->ring_id);\n\t\tring->dma_dev = ringacc->dev;\n\t}\n\n\tmemset(&ring->state, 0, sizeof(ring->state));\n\n\tring->ops = &k3_dmaring_fwd_ops;\n\n\tring->ring_mem_virt = dma_alloc_coherent(ring->dma_dev,\n\t\t\t\t\t\t ring->size * (4 << ring->elm_size),\n\t\t\t\t\t\t &ring->ring_mem_dma, GFP_KERNEL);\n\tif (!ring->ring_mem_virt) {\n\t\tdev_err(ringacc->dev, \"Failed to alloc ring mem\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ops;\n\t}\n\n\tret = k3_ringacc_ring_cfg_sci(ring);\n\tif (ret)\n\t\tgoto err_free_mem;\n\n\tring->flags |= K3_RING_FLAG_BUSY;\n\n\tk3_ringacc_ring_dump(ring);\n\n\t \n\treverse_ring = &ringacc->rings[ring->ring_id + ringacc->num_rings];\n\treverse_ring->size = cfg->size;\n\treverse_ring->elm_size = cfg->elm_size;\n\treverse_ring->mode = cfg->mode;\n\treverse_ring->asel = cfg->asel;\n\tmemset(&reverse_ring->state, 0, sizeof(reverse_ring->state));\n\treverse_ring->ops = &k3_dmaring_reverse_ops;\n\n\treverse_ring->ring_mem_virt = ring->ring_mem_virt;\n\treverse_ring->ring_mem_dma = ring->ring_mem_dma;\n\treverse_ring->flags |= K3_RING_FLAG_BUSY;\n\tk3_ringacc_ring_dump(reverse_ring);\n\n\treturn 0;\n\nerr_free_mem:\n\tdma_free_coherent(ring->dma_dev,\n\t\t\t  ring->size * (4 << ring->elm_size),\n\t\t\t  ring->ring_mem_virt,\n\t\t\t  ring->ring_mem_dma);\nerr_free_ops:\n\tring->ops = NULL;\n\tring->proxy = NULL;\n\tring->dma_dev = NULL;\n\tring->asel = 0;\n\treturn ret;\n}\n\nint k3_ringacc_ring_cfg(struct k3_ring *ring, struct k3_ring_cfg *cfg)\n{\n\tstruct k3_ringacc *ringacc;\n\tint ret = 0;\n\n\tif (!ring || !cfg)\n\t\treturn -EINVAL;\n\n\tringacc = ring->parent;\n\n\tif (ringacc->dma_rings)\n\t\treturn k3_dmaring_cfg(ring, cfg);\n\n\tif (cfg->elm_size > K3_RINGACC_RING_ELSIZE_256 ||\n\t    cfg->mode >= K3_RINGACC_RING_MODE_INVALID ||\n\t    cfg->size & ~K3_RINGACC_CFG_RING_SIZE_ELCNT_MASK ||\n\t    !test_bit(ring->ring_id, ringacc->rings_inuse))\n\t\treturn -EINVAL;\n\n\tif (cfg->mode == K3_RINGACC_RING_MODE_MESSAGE &&\n\t    ring->proxy_id == K3_RINGACC_PROXY_NOT_USED &&\n\t    cfg->elm_size > K3_RINGACC_RING_ELSIZE_8) {\n\t\tdev_err(ringacc->dev,\n\t\t\t\"Message mode must use proxy for %u element size\\n\",\n\t\t\t4 << ring->elm_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ring->use_count != 1)\n\t\treturn 0;\n\n\tring->size = cfg->size;\n\tring->elm_size = cfg->elm_size;\n\tring->mode = cfg->mode;\n\tmemset(&ring->state, 0, sizeof(ring->state));\n\n\tif (ring->proxy_id != K3_RINGACC_PROXY_NOT_USED)\n\t\tring->proxy = ringacc->proxy_target_base +\n\t\t\t      ring->proxy_id * K3_RINGACC_PROXY_TARGET_STEP;\n\n\tswitch (ring->mode) {\n\tcase K3_RINGACC_RING_MODE_RING:\n\t\tring->ops = &k3_ring_mode_ring_ops;\n\t\tring->dma_dev = cfg->dma_dev;\n\t\tif (!ring->dma_dev)\n\t\t\tring->dma_dev = ringacc->dev;\n\t\tbreak;\n\tcase K3_RINGACC_RING_MODE_MESSAGE:\n\t\tring->dma_dev = ringacc->dev;\n\t\tif (ring->proxy)\n\t\t\tring->ops = &k3_ring_mode_proxy_ops;\n\t\telse\n\t\t\tring->ops = &k3_ring_mode_msg_ops;\n\t\tbreak;\n\tdefault:\n\t\tring->ops = NULL;\n\t\tret = -EINVAL;\n\t\tgoto err_free_proxy;\n\t}\n\n\tring->ring_mem_virt = dma_alloc_coherent(ring->dma_dev,\n\t\t\t\t\t\t ring->size * (4 << ring->elm_size),\n\t\t\t\t\t\t &ring->ring_mem_dma, GFP_KERNEL);\n\tif (!ring->ring_mem_virt) {\n\t\tdev_err(ringacc->dev, \"Failed to alloc ring mem\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ops;\n\t}\n\n\tret = k3_ringacc_ring_cfg_sci(ring);\n\n\tif (ret)\n\t\tgoto err_free_mem;\n\n\tring->flags |= K3_RING_FLAG_BUSY;\n\tring->flags |= (cfg->flags & K3_RINGACC_RING_SHARED) ?\n\t\t\tK3_RING_FLAG_SHARED : 0;\n\n\tk3_ringacc_ring_dump(ring);\n\n\treturn 0;\n\nerr_free_mem:\n\tdma_free_coherent(ring->dma_dev,\n\t\t\t  ring->size * (4 << ring->elm_size),\n\t\t\t  ring->ring_mem_virt,\n\t\t\t  ring->ring_mem_dma);\nerr_free_ops:\n\tring->ops = NULL;\n\tring->dma_dev = NULL;\nerr_free_proxy:\n\tring->proxy = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_cfg);\n\nu32 k3_ringacc_ring_get_size(struct k3_ring *ring)\n{\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\treturn ring->size;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_get_size);\n\nu32 k3_ringacc_ring_get_free(struct k3_ring *ring)\n{\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\tif (!ring->state.free)\n\t\tring->state.free = ring->size - k3_ringacc_ring_read_occ(ring);\n\n\treturn ring->state.free;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_get_free);\n\nu32 k3_ringacc_ring_get_occ(struct k3_ring *ring)\n{\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\treturn k3_ringacc_ring_read_occ(ring);\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_get_occ);\n\nu32 k3_ringacc_ring_is_full(struct k3_ring *ring)\n{\n\treturn !k3_ringacc_ring_get_free(ring);\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_is_full);\n\nenum k3_ringacc_access_mode {\n\tK3_RINGACC_ACCESS_MODE_PUSH_HEAD,\n\tK3_RINGACC_ACCESS_MODE_POP_HEAD,\n\tK3_RINGACC_ACCESS_MODE_PUSH_TAIL,\n\tK3_RINGACC_ACCESS_MODE_POP_TAIL,\n\tK3_RINGACC_ACCESS_MODE_PEEK_HEAD,\n\tK3_RINGACC_ACCESS_MODE_PEEK_TAIL,\n};\n\n#define K3_RINGACC_PROXY_MODE(x)\t(((x) & 0x3) << 16)\n#define K3_RINGACC_PROXY_ELSIZE(x)\t(((x) & 0x7) << 24)\nstatic int k3_ringacc_ring_cfg_proxy(struct k3_ring *ring,\n\t\t\t\t     enum k3_ringacc_proxy_access_mode mode)\n{\n\tu32 val;\n\n\tval = ring->ring_id;\n\tval |= K3_RINGACC_PROXY_MODE(mode);\n\tval |= K3_RINGACC_PROXY_ELSIZE(ring->elm_size);\n\twritel(val, &ring->proxy->control);\n\treturn 0;\n}\n\nstatic int k3_ringacc_ring_access_proxy(struct k3_ring *ring, void *elem,\n\t\t\t\t\tenum k3_ringacc_access_mode access_mode)\n{\n\tvoid __iomem *ptr;\n\n\tptr = (void __iomem *)&ring->proxy->data;\n\n\tswitch (access_mode) {\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_HEAD:\n\tcase K3_RINGACC_ACCESS_MODE_POP_HEAD:\n\t\tk3_ringacc_ring_cfg_proxy(ring, PROXY_ACCESS_MODE_HEAD);\n\t\tbreak;\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_TAIL:\n\tcase K3_RINGACC_ACCESS_MODE_POP_TAIL:\n\t\tk3_ringacc_ring_cfg_proxy(ring, PROXY_ACCESS_MODE_TAIL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tptr += k3_ringacc_ring_get_fifo_pos(ring);\n\n\tswitch (access_mode) {\n\tcase K3_RINGACC_ACCESS_MODE_POP_HEAD:\n\tcase K3_RINGACC_ACCESS_MODE_POP_TAIL:\n\t\tdev_dbg(ring->parent->dev,\n\t\t\t\"proxy:memcpy_fromio(x): --> ptr(%p), mode:%d\\n\", ptr,\n\t\t\taccess_mode);\n\t\tmemcpy_fromio(elem, ptr, (4 << ring->elm_size));\n\t\tring->state.occ--;\n\t\tbreak;\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_TAIL:\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_HEAD:\n\t\tdev_dbg(ring->parent->dev,\n\t\t\t\"proxy:memcpy_toio(x): --> ptr(%p), mode:%d\\n\", ptr,\n\t\t\taccess_mode);\n\t\tmemcpy_toio(ptr, elem, (4 << ring->elm_size));\n\t\tring->state.free--;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ring->parent->dev, \"proxy: free%d occ%d\\n\", ring->state.free,\n\t\tring->state.occ);\n\treturn 0;\n}\n\nstatic int k3_ringacc_ring_push_head_proxy(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_proxy(ring, elem,\n\t\t\t\t\t    K3_RINGACC_ACCESS_MODE_PUSH_HEAD);\n}\n\nstatic int k3_ringacc_ring_push_tail_proxy(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_proxy(ring, elem,\n\t\t\t\t\t    K3_RINGACC_ACCESS_MODE_PUSH_TAIL);\n}\n\nstatic int k3_ringacc_ring_pop_head_proxy(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_proxy(ring, elem,\n\t\t\t\t\t    K3_RINGACC_ACCESS_MODE_POP_HEAD);\n}\n\nstatic int k3_ringacc_ring_pop_tail_proxy(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_proxy(ring, elem,\n\t\t\t\t\t    K3_RINGACC_ACCESS_MODE_POP_HEAD);\n}\n\nstatic int k3_ringacc_ring_access_io(struct k3_ring *ring, void *elem,\n\t\t\t\t     enum k3_ringacc_access_mode access_mode)\n{\n\tvoid __iomem *ptr;\n\n\tswitch (access_mode) {\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_HEAD:\n\tcase K3_RINGACC_ACCESS_MODE_POP_HEAD:\n\t\tptr = (void __iomem *)&ring->fifos->head_data;\n\t\tbreak;\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_TAIL:\n\tcase K3_RINGACC_ACCESS_MODE_POP_TAIL:\n\t\tptr = (void __iomem *)&ring->fifos->tail_data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tptr += k3_ringacc_ring_get_fifo_pos(ring);\n\n\tswitch (access_mode) {\n\tcase K3_RINGACC_ACCESS_MODE_POP_HEAD:\n\tcase K3_RINGACC_ACCESS_MODE_POP_TAIL:\n\t\tdev_dbg(ring->parent->dev,\n\t\t\t\"memcpy_fromio(x): --> ptr(%p), mode:%d\\n\", ptr,\n\t\t\taccess_mode);\n\t\tmemcpy_fromio(elem, ptr, (4 << ring->elm_size));\n\t\tring->state.occ--;\n\t\tbreak;\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_TAIL:\n\tcase K3_RINGACC_ACCESS_MODE_PUSH_HEAD:\n\t\tdev_dbg(ring->parent->dev,\n\t\t\t\"memcpy_toio(x): --> ptr(%p), mode:%d\\n\", ptr,\n\t\t\taccess_mode);\n\t\tmemcpy_toio(ptr, elem, (4 << ring->elm_size));\n\t\tring->state.free--;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ring->parent->dev, \"free%d index%d occ%d index%d\\n\",\n\t\tring->state.free, ring->state.windex, ring->state.occ,\n\t\tring->state.rindex);\n\treturn 0;\n}\n\nstatic int k3_ringacc_ring_push_head_io(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_io(ring, elem,\n\t\t\t\t\t K3_RINGACC_ACCESS_MODE_PUSH_HEAD);\n}\n\nstatic int k3_ringacc_ring_push_io(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_io(ring, elem,\n\t\t\t\t\t K3_RINGACC_ACCESS_MODE_PUSH_TAIL);\n}\n\nstatic int k3_ringacc_ring_pop_io(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_io(ring, elem,\n\t\t\t\t\t K3_RINGACC_ACCESS_MODE_POP_HEAD);\n}\n\nstatic int k3_ringacc_ring_pop_tail_io(struct k3_ring *ring, void *elem)\n{\n\treturn k3_ringacc_ring_access_io(ring, elem,\n\t\t\t\t\t K3_RINGACC_ACCESS_MODE_POP_HEAD);\n}\n\n \nstatic void k3_dmaring_remove_asel_from_elem(u64 *elem)\n{\n\t*elem &= GENMASK_ULL(K3_ADDRESS_ASEL_SHIFT - 1, 0);\n}\n\nstatic int k3_dmaring_fwd_pop(struct k3_ring *ring, void *elem)\n{\n\tvoid *elem_ptr;\n\tu32 elem_idx;\n\n\t \n\tring->state.occ = k3_ringacc_ring_read_occ(ring);\n\tif (ring->state.windex >= ring->state.occ)\n\t\telem_idx = ring->state.windex - ring->state.occ;\n\telse\n\t\telem_idx = ring->size - (ring->state.occ - ring->state.windex);\n\n\telem_ptr = k3_ringacc_get_elm_addr(ring, elem_idx);\n\tmemcpy(elem, elem_ptr, (4 << ring->elm_size));\n\tk3_dmaring_remove_asel_from_elem(elem);\n\n\tring->state.occ--;\n\twritel(-1, &ring->rt->db);\n\n\tdev_dbg(ring->parent->dev, \"%s: occ%d Windex%d Rindex%d pos_ptr%px\\n\",\n\t\t__func__, ring->state.occ, ring->state.windex, elem_idx,\n\t\telem_ptr);\n\treturn 0;\n}\n\nstatic int k3_dmaring_reverse_pop(struct k3_ring *ring, void *elem)\n{\n\tvoid *elem_ptr;\n\n\telem_ptr = k3_ringacc_get_elm_addr(ring, ring->state.rindex);\n\n\tif (ring->state.occ) {\n\t\tmemcpy(elem, elem_ptr, (4 << ring->elm_size));\n\t\tk3_dmaring_remove_asel_from_elem(elem);\n\n\t\tring->state.rindex = (ring->state.rindex + 1) % ring->size;\n\t\tring->state.occ--;\n\t\twritel(-1 & K3_DMARING_RT_DB_ENTRY_MASK, &ring->rt->db);\n\t} else if (ring->state.tdown_complete) {\n\t\tdma_addr_t *value = elem;\n\n\t\t*value = CPPI5_TDCM_MARKER;\n\t\twritel(K3_DMARING_RT_DB_TDOWN_ACK, &ring->rt->db);\n\t\tring->state.tdown_complete = false;\n\t}\n\n\tdev_dbg(ring->parent->dev, \"%s: occ%d index%d pos_ptr%px\\n\",\n\t\t__func__, ring->state.occ, ring->state.rindex, elem_ptr);\n\treturn 0;\n}\n\nstatic int k3_ringacc_ring_push_mem(struct k3_ring *ring, void *elem)\n{\n\tvoid *elem_ptr;\n\n\telem_ptr = k3_ringacc_get_elm_addr(ring, ring->state.windex);\n\n\tmemcpy(elem_ptr, elem, (4 << ring->elm_size));\n\tif (ring->parent->dma_rings) {\n\t\tu64 *addr = elem_ptr;\n\n\t\t*addr |= ((u64)ring->asel << K3_ADDRESS_ASEL_SHIFT);\n\t}\n\n\tring->state.windex = (ring->state.windex + 1) % ring->size;\n\tring->state.free--;\n\twritel(1, &ring->rt->db);\n\n\tdev_dbg(ring->parent->dev, \"ring_push_mem: free%d index%d\\n\",\n\t\tring->state.free, ring->state.windex);\n\n\treturn 0;\n}\n\nstatic int k3_ringacc_ring_pop_mem(struct k3_ring *ring, void *elem)\n{\n\tvoid *elem_ptr;\n\n\telem_ptr = k3_ringacc_get_elm_addr(ring, ring->state.rindex);\n\n\tmemcpy(elem, elem_ptr, (4 << ring->elm_size));\n\n\tring->state.rindex = (ring->state.rindex + 1) % ring->size;\n\tring->state.occ--;\n\twritel(-1, &ring->rt->db);\n\n\tdev_dbg(ring->parent->dev, \"ring_pop_mem: occ%d index%d pos_ptr%p\\n\",\n\t\tring->state.occ, ring->state.rindex, elem_ptr);\n\treturn 0;\n}\n\nint k3_ringacc_ring_push(struct k3_ring *ring, void *elem)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\tdev_dbg(ring->parent->dev, \"ring_push: free%d index%d\\n\",\n\t\tring->state.free, ring->state.windex);\n\n\tif (k3_ringacc_ring_is_full(ring))\n\t\treturn -ENOMEM;\n\n\tif (ring->ops && ring->ops->push_tail)\n\t\tret = ring->ops->push_tail(ring, elem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_push);\n\nint k3_ringacc_ring_push_head(struct k3_ring *ring, void *elem)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\tdev_dbg(ring->parent->dev, \"ring_push_head: free%d index%d\\n\",\n\t\tring->state.free, ring->state.windex);\n\n\tif (k3_ringacc_ring_is_full(ring))\n\t\treturn -ENOMEM;\n\n\tif (ring->ops && ring->ops->push_head)\n\t\tret = ring->ops->push_head(ring, elem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_push_head);\n\nint k3_ringacc_ring_pop(struct k3_ring *ring, void *elem)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\tif (!ring->state.occ)\n\t\tk3_ringacc_ring_update_occ(ring);\n\n\tdev_dbg(ring->parent->dev, \"ring_pop: occ%d index%d\\n\", ring->state.occ,\n\t\tring->state.rindex);\n\n\tif (!ring->state.occ && !ring->state.tdown_complete)\n\t\treturn -ENODATA;\n\n\tif (ring->ops && ring->ops->pop_head)\n\t\tret = ring->ops->pop_head(ring, elem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_pop);\n\nint k3_ringacc_ring_pop_tail(struct k3_ring *ring, void *elem)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (!ring || !(ring->flags & K3_RING_FLAG_BUSY))\n\t\treturn -EINVAL;\n\n\tif (!ring->state.occ)\n\t\tk3_ringacc_ring_update_occ(ring);\n\n\tdev_dbg(ring->parent->dev, \"ring_pop_tail: occ%d index%d\\n\",\n\t\tring->state.occ, ring->state.rindex);\n\n\tif (!ring->state.occ)\n\t\treturn -ENODATA;\n\n\tif (ring->ops && ring->ops->pop_tail)\n\t\tret = ring->ops->pop_tail(ring, elem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_ring_pop_tail);\n\nstruct k3_ringacc *of_k3_ringacc_get_by_phandle(struct device_node *np,\n\t\t\t\t\t\tconst char *property)\n{\n\tstruct device_node *ringacc_np;\n\tstruct k3_ringacc *ringacc = ERR_PTR(-EPROBE_DEFER);\n\tstruct k3_ringacc *entry;\n\n\tringacc_np = of_parse_phandle(np, property, 0);\n\tif (!ringacc_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&k3_ringacc_list_lock);\n\tlist_for_each_entry(entry, &k3_ringacc_list, list)\n\t\tif (entry->dev->of_node == ringacc_np) {\n\t\t\tringacc = entry;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&k3_ringacc_list_lock);\n\tof_node_put(ringacc_np);\n\n\treturn ringacc;\n}\nEXPORT_SYMBOL_GPL(of_k3_ringacc_get_by_phandle);\n\nstatic int k3_ringacc_probe_dt(struct k3_ringacc *ringacc)\n{\n\tstruct device_node *node = ringacc->dev->of_node;\n\tstruct device *dev = ringacc->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tif (!node) {\n\t\tdev_err(dev, \"device tree info unavailable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(node, \"ti,num-rings\", &ringacc->num_rings);\n\tif (ret) {\n\t\tdev_err(dev, \"ti,num-rings read failure %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tringacc->tisci = ti_sci_get_by_phandle(node, \"ti,sci\");\n\tif (IS_ERR(ringacc->tisci)) {\n\t\tret = PTR_ERR(ringacc->tisci);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"ti,sci read fail %d\\n\", ret);\n\t\tringacc->tisci = NULL;\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(node, \"ti,sci-dev-id\",\n\t\t\t\t   &ringacc->tisci_dev_id);\n\tif (ret) {\n\t\tdev_err(dev, \"ti,sci-dev-id read fail %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpdev->id = ringacc->tisci_dev_id;\n\n\tringacc->rm_gp_range = devm_ti_sci_get_of_resource(ringacc->tisci, dev,\n\t\t\t\t\t\tringacc->tisci_dev_id,\n\t\t\t\t\t\t\"ti,sci-rm-range-gp-rings\");\n\tif (IS_ERR(ringacc->rm_gp_range)) {\n\t\tdev_err(dev, \"Failed to allocate MSI interrupts\\n\");\n\t\treturn PTR_ERR(ringacc->rm_gp_range);\n\t}\n\n\treturn ti_sci_inta_msi_domain_alloc_irqs(ringacc->dev,\n\t\t\t\t\t\t ringacc->rm_gp_range);\n}\n\nstatic const struct k3_ringacc_soc_data k3_ringacc_soc_data_sr1 = {\n\t.dma_ring_reset_quirk = 1,\n};\n\nstatic const struct soc_device_attribute k3_ringacc_socinfo[] = {\n\t{ .family = \"AM65X\",\n\t  .revision = \"SR1.0\",\n\t  .data = &k3_ringacc_soc_data_sr1\n\t},\n\t{ }\n};\n\nstatic int k3_ringacc_init(struct platform_device *pdev,\n\t\t\t   struct k3_ringacc *ringacc)\n{\n\tconst struct soc_device_attribute *soc;\n\tvoid __iomem *base_fifo, *base_rt;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i;\n\n\tdev->msi.domain = of_msi_get_domain(dev, dev->of_node,\n\t\t\t\t\t    DOMAIN_BUS_TI_SCI_INTA_MSI);\n\tif (!dev->msi.domain)\n\t\treturn -EPROBE_DEFER;\n\n\tret = k3_ringacc_probe_dt(ringacc);\n\tif (ret)\n\t\treturn ret;\n\n\tsoc = soc_device_match(k3_ringacc_socinfo);\n\tif (soc && soc->data) {\n\t\tconst struct k3_ringacc_soc_data *soc_data = soc->data;\n\n\t\tringacc->dma_ring_reset_quirk = soc_data->dma_ring_reset_quirk;\n\t}\n\n\tbase_rt = devm_platform_ioremap_resource_byname(pdev, \"rt\");\n\tif (IS_ERR(base_rt))\n\t\treturn PTR_ERR(base_rt);\n\n\tbase_fifo = devm_platform_ioremap_resource_byname(pdev, \"fifos\");\n\tif (IS_ERR(base_fifo))\n\t\treturn PTR_ERR(base_fifo);\n\n\tringacc->proxy_gcfg = devm_platform_ioremap_resource_byname(pdev, \"proxy_gcfg\");\n\tif (IS_ERR(ringacc->proxy_gcfg))\n\t\treturn PTR_ERR(ringacc->proxy_gcfg);\n\n\tringacc->proxy_target_base = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\t\t\t\t   \"proxy_target\");\n\tif (IS_ERR(ringacc->proxy_target_base))\n\t\treturn PTR_ERR(ringacc->proxy_target_base);\n\n\tringacc->num_proxies = readl(&ringacc->proxy_gcfg->config) &\n\t\t\t\t     K3_RINGACC_PROXY_CFG_THREADS_MASK;\n\n\tringacc->rings = devm_kzalloc(dev,\n\t\t\t\t      sizeof(*ringacc->rings) *\n\t\t\t\t      ringacc->num_rings,\n\t\t\t\t      GFP_KERNEL);\n\tringacc->rings_inuse = devm_bitmap_zalloc(dev, ringacc->num_rings,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tringacc->proxy_inuse = devm_bitmap_zalloc(dev, ringacc->num_proxies,\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!ringacc->rings || !ringacc->rings_inuse || !ringacc->proxy_inuse)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ringacc->num_rings; i++) {\n\t\tringacc->rings[i].rt = base_rt +\n\t\t\t\t       K3_RINGACC_RT_REGS_STEP * i;\n\t\tringacc->rings[i].fifos = base_fifo +\n\t\t\t\t\t  K3_RINGACC_FIFO_REGS_STEP * i;\n\t\tringacc->rings[i].parent = ringacc;\n\t\tringacc->rings[i].ring_id = i;\n\t\tringacc->rings[i].proxy_id = K3_RINGACC_PROXY_NOT_USED;\n\t}\n\n\tringacc->tisci_ring_ops = &ringacc->tisci->ops.rm_ring_ops;\n\n\tdev_info(dev, \"Ring Accelerator probed rings:%u, gp-rings[%u,%u] sci-dev-id:%u\\n\",\n\t\t ringacc->num_rings,\n\t\t ringacc->rm_gp_range->desc[0].start,\n\t\t ringacc->rm_gp_range->desc[0].num,\n\t\t ringacc->tisci_dev_id);\n\tdev_info(dev, \"dma-ring-reset-quirk: %s\\n\",\n\t\t ringacc->dma_ring_reset_quirk ? \"enabled\" : \"disabled\");\n\tdev_info(dev, \"RA Proxy rev. %08x, num_proxies:%u\\n\",\n\t\t readl(&ringacc->proxy_gcfg->revision), ringacc->num_proxies);\n\n\treturn 0;\n}\n\nstruct ringacc_match_data {\n\tstruct k3_ringacc_ops ops;\n};\n\nstatic struct ringacc_match_data k3_ringacc_data = {\n\t.ops = {\n\t\t.init = k3_ringacc_init,\n\t},\n};\n\n \nstatic const struct of_device_id k3_ringacc_of_match[] = {\n\t{ .compatible = \"ti,am654-navss-ringacc\", .data = &k3_ringacc_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, k3_ringacc_of_match);\n\nstruct k3_ringacc *k3_ringacc_dmarings_init(struct platform_device *pdev,\n\t\t\t\t\t    struct k3_ringacc_init_data *data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct k3_ringacc *ringacc;\n\tvoid __iomem *base_rt;\n\tint i;\n\n\tringacc = devm_kzalloc(dev, sizeof(*ringacc), GFP_KERNEL);\n\tif (!ringacc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tringacc->dev = dev;\n\tringacc->dma_rings = true;\n\tringacc->num_rings = data->num_rings;\n\tringacc->tisci = data->tisci;\n\tringacc->tisci_dev_id = data->tisci_dev_id;\n\n\tmutex_init(&ringacc->req_lock);\n\n\tbase_rt = devm_platform_ioremap_resource_byname(pdev, \"ringrt\");\n\tif (IS_ERR(base_rt))\n\t\treturn ERR_CAST(base_rt);\n\n\tringacc->rings = devm_kzalloc(dev,\n\t\t\t\t      sizeof(*ringacc->rings) *\n\t\t\t\t      ringacc->num_rings * 2,\n\t\t\t\t      GFP_KERNEL);\n\tringacc->rings_inuse = devm_bitmap_zalloc(dev, ringacc->num_rings,\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!ringacc->rings || !ringacc->rings_inuse)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < ringacc->num_rings; i++) {\n\t\tstruct k3_ring *ring = &ringacc->rings[i];\n\n\t\tring->rt = base_rt + K3_DMARING_RT_REGS_STEP * i;\n\t\tring->parent = ringacc;\n\t\tring->ring_id = i;\n\t\tring->proxy_id = K3_RINGACC_PROXY_NOT_USED;\n\n\t\tring = &ringacc->rings[ringacc->num_rings + i];\n\t\tring->rt = base_rt + K3_DMARING_RT_REGS_STEP * i +\n\t\t\t   K3_DMARING_RT_REGS_REVERSE_OFS;\n\t\tring->parent = ringacc;\n\t\tring->ring_id = i;\n\t\tring->proxy_id = K3_RINGACC_PROXY_NOT_USED;\n\t\tring->flags = K3_RING_FLAG_REVERSE;\n\t}\n\n\tringacc->tisci_ring_ops = &ringacc->tisci->ops.rm_ring_ops;\n\n\tdev_info(dev, \"Number of rings: %u\\n\", ringacc->num_rings);\n\n\treturn ringacc;\n}\nEXPORT_SYMBOL_GPL(k3_ringacc_dmarings_init);\n\nstatic int k3_ringacc_probe(struct platform_device *pdev)\n{\n\tconst struct ringacc_match_data *match_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct k3_ringacc *ringacc;\n\tint ret;\n\n\tmatch_data = of_device_get_match_data(&pdev->dev);\n\tif (!match_data)\n\t\treturn -ENODEV;\n\n\tringacc = devm_kzalloc(dev, sizeof(*ringacc), GFP_KERNEL);\n\tif (!ringacc)\n\t\treturn -ENOMEM;\n\n\tringacc->dev = dev;\n\tmutex_init(&ringacc->req_lock);\n\tringacc->ops = &match_data->ops;\n\n\tret = ringacc->ops->init(pdev, ringacc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, ringacc);\n\n\tmutex_lock(&k3_ringacc_list_lock);\n\tlist_add_tail(&ringacc->list, &k3_ringacc_list);\n\tmutex_unlock(&k3_ringacc_list_lock);\n\n\treturn 0;\n}\n\nstatic int k3_ringacc_remove(struct platform_device *pdev)\n{\n\tstruct k3_ringacc *ringacc = dev_get_drvdata(&pdev->dev);\n\n\tmutex_lock(&k3_ringacc_list_lock);\n\tlist_del(&ringacc->list);\n\tmutex_unlock(&k3_ringacc_list_lock);\n\treturn 0;\n}\n\nstatic struct platform_driver k3_ringacc_driver = {\n\t.probe\t\t= k3_ringacc_probe,\n\t.remove\t\t= k3_ringacc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"k3-ringacc\",\n\t\t.of_match_table = k3_ringacc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(k3_ringacc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TI Ringacc driver for K3 SOCs\");\nMODULE_AUTHOR(\"Grygorii Strashko <grygorii.strashko@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}