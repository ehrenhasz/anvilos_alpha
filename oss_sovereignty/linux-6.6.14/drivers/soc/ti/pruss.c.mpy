{
  "module_name": "pruss.c",
  "hash_id": "4ccb9f46edc2acffc1cea889fb1626cb25927c27b630021ef3186f93b5295005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/pruss.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pruss_driver.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/slab.h>\n#include \"pruss.h\"\n\n \nstruct pruss_private_data {\n\tbool has_no_sharedram;\n\tbool has_core_mux_clock;\n};\n\n \nstruct pruss *pruss_get(struct rproc *rproc)\n{\n\tstruct pruss *pruss;\n\tstruct device *dev;\n\tstruct platform_device *ppdev;\n\n\tif (IS_ERR_OR_NULL(rproc))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = &rproc->dev;\n\n\t \n\tif (!dev->parent || !is_pru_rproc(dev->parent))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tppdev = to_platform_device(dev->parent->parent);\n\tpruss = platform_get_drvdata(ppdev);\n\tif (!pruss)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tget_device(pruss->dev);\n\n\treturn pruss;\n}\nEXPORT_SYMBOL_GPL(pruss_get);\n\n \nvoid pruss_put(struct pruss *pruss)\n{\n\tif (IS_ERR_OR_NULL(pruss))\n\t\treturn;\n\n\tput_device(pruss->dev);\n}\nEXPORT_SYMBOL_GPL(pruss_put);\n\n \nint pruss_request_mem_region(struct pruss *pruss, enum pruss_mem mem_id,\n\t\t\t     struct pruss_mem_region *region)\n{\n\tif (!pruss || !region || mem_id >= PRUSS_MEM_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pruss->lock);\n\n\tif (pruss->mem_in_use[mem_id]) {\n\t\tmutex_unlock(&pruss->lock);\n\t\treturn -EBUSY;\n\t}\n\n\t*region = pruss->mem_regions[mem_id];\n\tpruss->mem_in_use[mem_id] = region;\n\n\tmutex_unlock(&pruss->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pruss_request_mem_region);\n\n \nint pruss_release_mem_region(struct pruss *pruss,\n\t\t\t     struct pruss_mem_region *region)\n{\n\tint id;\n\n\tif (!pruss || !region)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pruss->lock);\n\n\t \n\tfor (id = 0; id < PRUSS_MEM_MAX; id++) {\n\t\tif (pruss->mem_in_use[id] == region)\n\t\t\tbreak;\n\t}\n\n\tif (id == PRUSS_MEM_MAX) {\n\t\tmutex_unlock(&pruss->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tpruss->mem_in_use[id] = NULL;\n\n\tmutex_unlock(&pruss->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pruss_release_mem_region);\n\n \nint pruss_cfg_get_gpmux(struct pruss *pruss, enum pruss_pru_id pru_id, u8 *mux)\n{\n\tint ret;\n\tu32 val;\n\n\tif (pru_id >= PRUSS_NUM_PRUS || !mux)\n\t\treturn -EINVAL;\n\n\tret = pruss_cfg_read(pruss, PRUSS_CFG_GPCFG(pru_id), &val);\n\tif (!ret)\n\t\t*mux = (u8)((val & PRUSS_GPCFG_PRU_MUX_SEL_MASK) >>\n\t\t\t    PRUSS_GPCFG_PRU_MUX_SEL_SHIFT);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pruss_cfg_get_gpmux);\n\n \nint pruss_cfg_set_gpmux(struct pruss *pruss, enum pruss_pru_id pru_id, u8 mux)\n{\n\tif (mux >= PRUSS_GP_MUX_SEL_MAX ||\n\t    pru_id >= PRUSS_NUM_PRUS)\n\t\treturn -EINVAL;\n\n\treturn pruss_cfg_update(pruss, PRUSS_CFG_GPCFG(pru_id),\n\t\t\t\tPRUSS_GPCFG_PRU_MUX_SEL_MASK,\n\t\t\t\t(u32)mux << PRUSS_GPCFG_PRU_MUX_SEL_SHIFT);\n}\nEXPORT_SYMBOL_GPL(pruss_cfg_set_gpmux);\n\n \nint pruss_cfg_gpimode(struct pruss *pruss, enum pruss_pru_id pru_id,\n\t\t      enum pruss_gpi_mode mode)\n{\n\tif (pru_id >= PRUSS_NUM_PRUS || mode >= PRUSS_GPI_MODE_MAX)\n\t\treturn -EINVAL;\n\n\treturn pruss_cfg_update(pruss, PRUSS_CFG_GPCFG(pru_id),\n\t\t\t\tPRUSS_GPCFG_PRU_GPI_MODE_MASK,\n\t\t\t\tmode << PRUSS_GPCFG_PRU_GPI_MODE_SHIFT);\n}\nEXPORT_SYMBOL_GPL(pruss_cfg_gpimode);\n\n \nint pruss_cfg_miirt_enable(struct pruss *pruss, bool enable)\n{\n\tu32 set = enable ? PRUSS_MII_RT_EVENT_EN : 0;\n\n\treturn pruss_cfg_update(pruss, PRUSS_CFG_MII_RT,\n\t\t\t\tPRUSS_MII_RT_EVENT_EN, set);\n}\nEXPORT_SYMBOL_GPL(pruss_cfg_miirt_enable);\n\n \nint pruss_cfg_xfr_enable(struct pruss *pruss, enum pru_type pru_type,\n\t\t\t bool enable)\n{\n\tu32 mask, set;\n\n\tswitch (pru_type) {\n\tcase PRU_TYPE_PRU:\n\t\tmask = PRUSS_SPP_XFER_SHIFT_EN;\n\t\tbreak;\n\tcase PRU_TYPE_RTU:\n\t\tmask = PRUSS_SPP_RTU_XFR_SHIFT_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tset = enable ? mask : 0;\n\n\treturn pruss_cfg_update(pruss, PRUSS_CFG_SPP, mask, set);\n}\nEXPORT_SYMBOL_GPL(pruss_cfg_xfr_enable);\n\nstatic void pruss_of_free_clk_provider(void *data)\n{\n\tstruct device_node *clk_mux_np = data;\n\n\tof_clk_del_provider(clk_mux_np);\n\tof_node_put(clk_mux_np);\n}\n\nstatic void pruss_clk_unregister_mux(void *data)\n{\n\tclk_unregister_mux(data);\n}\n\nstatic int pruss_clk_mux_setup(struct pruss *pruss, struct clk *clk_mux,\n\t\t\t       char *mux_name, struct device_node *clks_np)\n{\n\tstruct device_node *clk_mux_np;\n\tstruct device *dev = pruss->dev;\n\tchar *clk_mux_name;\n\tunsigned int num_parents;\n\tconst char **parent_names;\n\tvoid __iomem *reg;\n\tu32 reg_offset;\n\tint ret;\n\n\tclk_mux_np = of_get_child_by_name(clks_np, mux_name);\n\tif (!clk_mux_np) {\n\t\tdev_err(dev, \"%pOF is missing its '%s' node\\n\", clks_np,\n\t\t\tmux_name);\n\t\treturn -ENODEV;\n\t}\n\n\tnum_parents = of_clk_get_parent_count(clk_mux_np);\n\tif (num_parents < 1) {\n\t\tdev_err(dev, \"mux-clock %pOF must have parents\\n\", clk_mux_np);\n\t\tret = -EINVAL;\n\t\tgoto put_clk_mux_np;\n\t}\n\n\tparent_names = devm_kcalloc(dev, sizeof(*parent_names), num_parents,\n\t\t\t\t    GFP_KERNEL);\n\tif (!parent_names) {\n\t\tret = -ENOMEM;\n\t\tgoto put_clk_mux_np;\n\t}\n\n\tof_clk_parent_fill(clk_mux_np, parent_names, num_parents);\n\n\tclk_mux_name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%pOFn\",\n\t\t\t\t      dev_name(dev), clk_mux_np);\n\tif (!clk_mux_name) {\n\t\tret = -ENOMEM;\n\t\tgoto put_clk_mux_np;\n\t}\n\n\tret = of_property_read_u32(clk_mux_np, \"reg\", &reg_offset);\n\tif (ret)\n\t\tgoto put_clk_mux_np;\n\n\treg = pruss->cfg_base + reg_offset;\n\n\tclk_mux = clk_register_mux(NULL, clk_mux_name, parent_names,\n\t\t\t\t   num_parents, 0, reg, 0, 1, 0, NULL);\n\tif (IS_ERR(clk_mux)) {\n\t\tret = PTR_ERR(clk_mux);\n\t\tgoto put_clk_mux_np;\n\t}\n\n\tret = devm_add_action_or_reset(dev, pruss_clk_unregister_mux, clk_mux);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add clkmux unregister action %d\", ret);\n\t\tgoto put_clk_mux_np;\n\t}\n\n\tret = of_clk_add_provider(clk_mux_np, of_clk_src_simple_get, clk_mux);\n\tif (ret)\n\t\tgoto put_clk_mux_np;\n\n\tret = devm_add_action_or_reset(dev, pruss_of_free_clk_provider,\n\t\t\t\t       clk_mux_np);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add clkmux free action %d\", ret);\n\t\tgoto put_clk_mux_np;\n\t}\n\n\treturn 0;\n\nput_clk_mux_np:\n\tof_node_put(clk_mux_np);\n\treturn ret;\n}\n\nstatic int pruss_clk_init(struct pruss *pruss, struct device_node *cfg_node)\n{\n\tconst struct pruss_private_data *data;\n\tstruct device_node *clks_np;\n\tstruct device *dev = pruss->dev;\n\tint ret = 0;\n\n\tdata = of_device_get_match_data(dev);\n\n\tclks_np = of_get_child_by_name(cfg_node, \"clocks\");\n\tif (!clks_np) {\n\t\tdev_err(dev, \"%pOF is missing its 'clocks' node\\n\", cfg_node);\n\t\treturn -ENODEV;\n\t}\n\n\tif (data && data->has_core_mux_clock) {\n\t\tret = pruss_clk_mux_setup(pruss, pruss->core_clk_mux,\n\t\t\t\t\t  \"coreclk-mux\", clks_np);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to setup coreclk-mux\\n\");\n\t\t\tgoto put_clks_node;\n\t\t}\n\t}\n\n\tret = pruss_clk_mux_setup(pruss, pruss->iep_clk_mux, \"iepclk-mux\",\n\t\t\t\t  clks_np);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup iepclk-mux\\n\");\n\t\tgoto put_clks_node;\n\t}\n\nput_clks_node:\n\tof_node_put(clks_np);\n\n\treturn ret;\n}\n\nstatic struct regmap_config regmap_conf = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int pruss_cfg_of_init(struct device *dev, struct pruss *pruss)\n{\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device_node *child;\n\tstruct resource res;\n\tint ret;\n\n\tchild = of_get_child_by_name(np, \"cfg\");\n\tif (!child) {\n\t\tdev_err(dev, \"%pOF is missing its 'cfg' node\\n\", child);\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_address_to_resource(child, 0, &res)) {\n\t\tret = -ENOMEM;\n\t\tgoto node_put;\n\t}\n\n\tpruss->cfg_base = devm_ioremap(dev, res.start, resource_size(&res));\n\tif (!pruss->cfg_base) {\n\t\tret = -ENOMEM;\n\t\tgoto node_put;\n\t}\n\n\tregmap_conf.name = kasprintf(GFP_KERNEL, \"%pOFn@%llx\", child,\n\t\t\t\t     (u64)res.start);\n\tregmap_conf.max_register = resource_size(&res) - 4;\n\n\tpruss->cfg_regmap = devm_regmap_init_mmio(dev, pruss->cfg_base,\n\t\t\t\t\t\t  &regmap_conf);\n\tkfree(regmap_conf.name);\n\tif (IS_ERR(pruss->cfg_regmap)) {\n\t\tdev_err(dev, \"regmap_init_mmio failed for cfg, ret = %ld\\n\",\n\t\t\tPTR_ERR(pruss->cfg_regmap));\n\t\tret = PTR_ERR(pruss->cfg_regmap);\n\t\tgoto node_put;\n\t}\n\n\tret = pruss_clk_init(pruss, child);\n\tif (ret)\n\t\tdev_err(dev, \"pruss_clk_init failed, ret = %d\\n\", ret);\n\nnode_put:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic int pruss_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct device_node *child;\n\tstruct pruss *pruss;\n\tstruct resource res;\n\tint ret, i, index;\n\tconst struct pruss_private_data *data;\n\tconst char *mem_names[PRUSS_MEM_MAX] = { \"dram0\", \"dram1\", \"shrdram2\" };\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\tret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set the DMA coherent mask\");\n\t\treturn ret;\n\t}\n\n\tpruss = devm_kzalloc(dev, sizeof(*pruss), GFP_KERNEL);\n\tif (!pruss)\n\t\treturn -ENOMEM;\n\n\tpruss->dev = dev;\n\tmutex_init(&pruss->lock);\n\n\tchild = of_get_child_by_name(np, \"memories\");\n\tif (!child) {\n\t\tdev_err(dev, \"%pOF is missing its 'memories' node\\n\", child);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < PRUSS_MEM_MAX; i++) {\n\t\t \n\t\tif (data && data->has_no_sharedram && i == PRUSS_MEM_SHRD_RAM2)\n\t\t\tcontinue;\n\n\t\tindex = of_property_match_string(child, \"reg-names\",\n\t\t\t\t\t\t mem_names[i]);\n\t\tif (index < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn index;\n\t\t}\n\n\t\tif (of_address_to_resource(child, index, &res)) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpruss->mem_regions[i].va = devm_ioremap(dev, res.start,\n\t\t\t\t\t\t\tresource_size(&res));\n\t\tif (!pruss->mem_regions[i].va) {\n\t\t\tdev_err(dev, \"failed to parse and map memory resource %d %s\\n\",\n\t\t\t\ti, mem_names[i]);\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpruss->mem_regions[i].pa = res.start;\n\t\tpruss->mem_regions[i].size = resource_size(&res);\n\n\t\tdev_dbg(dev, \"memory %8s: pa %pa size 0x%zx va %pK\\n\",\n\t\t\tmem_names[i], &pruss->mem_regions[i].pa,\n\t\t\tpruss->mem_regions[i].size, pruss->mem_regions[i].va);\n\t}\n\tof_node_put(child);\n\n\tplatform_set_drvdata(pdev, pruss);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"couldn't enable module\\n\");\n\t\tgoto rpm_disable;\n\t}\n\n\tret = pruss_cfg_of_init(dev, pruss);\n\tif (ret < 0)\n\t\tgoto rpm_put;\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register child devices\\n\");\n\t\tgoto rpm_put;\n\t}\n\n\treturn 0;\n\nrpm_put:\n\tpm_runtime_put_sync(dev);\nrpm_disable:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int pruss_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tdevm_of_platform_depopulate(dev);\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\n \nstatic const struct pruss_private_data am437x_pruss1_data = {\n\t.has_no_sharedram = false,\n};\n\nstatic const struct pruss_private_data am437x_pruss0_data = {\n\t.has_no_sharedram = true,\n};\n\nstatic const struct pruss_private_data am65x_j721e_pruss_data = {\n\t.has_core_mux_clock = true,\n};\n\nstatic const struct of_device_id pruss_of_match[] = {\n\t{ .compatible = \"ti,am3356-pruss\" },\n\t{ .compatible = \"ti,am4376-pruss0\", .data = &am437x_pruss0_data, },\n\t{ .compatible = \"ti,am4376-pruss1\", .data = &am437x_pruss1_data, },\n\t{ .compatible = \"ti,am5728-pruss\" },\n\t{ .compatible = \"ti,k2g-pruss\" },\n\t{ .compatible = \"ti,am654-icssg\", .data = &am65x_j721e_pruss_data, },\n\t{ .compatible = \"ti,j721e-icssg\", .data = &am65x_j721e_pruss_data, },\n\t{ .compatible = \"ti,am642-icssg\", .data = &am65x_j721e_pruss_data, },\n\t{ .compatible = \"ti,am625-pruss\", .data = &am65x_j721e_pruss_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pruss_of_match);\n\nstatic struct platform_driver pruss_driver = {\n\t.driver = {\n\t\t.name = \"pruss\",\n\t\t.of_match_table = pruss_of_match,\n\t},\n\t.probe  = pruss_probe,\n\t.remove = pruss_remove,\n};\nmodule_platform_driver(pruss_driver);\n\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_DESCRIPTION(\"PRU-ICSS Subsystem Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}