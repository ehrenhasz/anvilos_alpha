{
  "module_name": "smartreflex.c",
  "hash_id": "958bf79c28aad5ae934e93198aebcac40791a03e5efd95b97c80240091976860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/smartreflex.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/power/smartreflex.h>\n\n#define DRIVER_NAME\t\"smartreflex\"\n#define SMARTREFLEX_NAME_LEN\t32\n#define NVALUE_NAME_LEN\t\t40\n#define SR_DISABLE_TIMEOUT\t200\n\n \nstatic LIST_HEAD(sr_list);\n\nstatic struct omap_sr_class_data *sr_class;\nstatic struct dentry\t\t*sr_dbg_dir;\n\nstatic inline void sr_write_reg(struct omap_sr *sr, unsigned offset, u32 value)\n{\n\t__raw_writel(value, (sr->base + offset));\n}\n\nstatic inline void sr_modify_reg(struct omap_sr *sr, unsigned offset, u32 mask,\n\t\t\t\t\tu32 value)\n{\n\tu32 reg_val;\n\n\t \n\tif (sr->ip_type == SR_TYPE_V1 && offset == ERRCONFIG_V1)\n\t\tmask |= ERRCONFIG_STATUS_V1_MASK;\n\telse if (sr->ip_type == SR_TYPE_V2 && offset == ERRCONFIG_V2)\n\t\tmask |= ERRCONFIG_VPBOUNDINTST_V2;\n\n\treg_val = __raw_readl(sr->base + offset);\n\treg_val &= ~mask;\n\n\tvalue &= mask;\n\n\treg_val |= value;\n\n\t__raw_writel(reg_val, (sr->base + offset));\n}\n\nstatic inline u32 sr_read_reg(struct omap_sr *sr, unsigned offset)\n{\n\treturn __raw_readl(sr->base + offset);\n}\n\nstatic struct omap_sr *_sr_lookup(struct voltagedomain *voltdm)\n{\n\tstruct omap_sr *sr_info;\n\n\tif (!voltdm) {\n\t\tpr_err(\"%s: Null voltage domain passed!\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlist_for_each_entry(sr_info, &sr_list, node) {\n\t\tif (voltdm == sr_info->voltdm)\n\t\t\treturn sr_info;\n\t}\n\n\treturn ERR_PTR(-ENODATA);\n}\n\nstatic irqreturn_t sr_interrupt(int irq, void *data)\n{\n\tstruct omap_sr *sr_info = data;\n\tu32 status = 0;\n\n\tswitch (sr_info->ip_type) {\n\tcase SR_TYPE_V1:\n\t\t \n\t\tstatus = sr_read_reg(sr_info, ERRCONFIG_V1);\n\n\t\t \n\t\tsr_write_reg(sr_info, ERRCONFIG_V1, status);\n\t\tbreak;\n\tcase SR_TYPE_V2:\n\t\t \n\t\tstatus = sr_read_reg(sr_info, IRQSTATUS);\n\n\t\t \n\t\tsr_write_reg(sr_info, IRQSTATUS, status);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr_info->pdev->dev, \"UNKNOWN IP type %d\\n\",\n\t\t\tsr_info->ip_type);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (sr_class->notify)\n\t\tsr_class->notify(sr_info, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sr_set_clk_length(struct omap_sr *sr)\n{\n\tu32 fclk_speed;\n\n\t \n\tif (IS_ERR(sr->fck))\n\t\treturn;\n\n\tfclk_speed = clk_get_rate(sr->fck);\n\n\tswitch (fclk_speed) {\n\tcase 12000000:\n\t\tsr->clk_length = SRCLKLENGTH_12MHZ_SYSCLK;\n\t\tbreak;\n\tcase 13000000:\n\t\tsr->clk_length = SRCLKLENGTH_13MHZ_SYSCLK;\n\t\tbreak;\n\tcase 19200000:\n\t\tsr->clk_length = SRCLKLENGTH_19MHZ_SYSCLK;\n\t\tbreak;\n\tcase 26000000:\n\t\tsr->clk_length = SRCLKLENGTH_26MHZ_SYSCLK;\n\t\tbreak;\n\tcase 38400000:\n\t\tsr->clk_length = SRCLKLENGTH_38MHZ_SYSCLK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr->pdev->dev, \"%s: Invalid fclk rate: %d\\n\",\n\t\t\t__func__, fclk_speed);\n\t\tbreak;\n\t}\n}\n\nstatic void sr_start_vddautocomp(struct omap_sr *sr)\n{\n\tif (!sr_class || !(sr_class->enable) || !(sr_class->configure)) {\n\t\tdev_warn(&sr->pdev->dev,\n\t\t\t \"%s: smartreflex class driver not registered\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tif (!sr_class->enable(sr))\n\t\tsr->autocomp_active = true;\n}\n\nstatic void sr_stop_vddautocomp(struct omap_sr *sr)\n{\n\tif (!sr_class || !(sr_class->disable)) {\n\t\tdev_warn(&sr->pdev->dev,\n\t\t\t \"%s: smartreflex class driver not registered\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tif (sr->autocomp_active) {\n\t\tsr_class->disable(sr, 1);\n\t\tsr->autocomp_active = false;\n\t}\n}\n\n \nstatic int sr_late_init(struct omap_sr *sr_info)\n{\n\tint ret = 0;\n\n\tif (sr_class->notify && sr_class->notify_flags && sr_info->irq) {\n\t\tret = devm_request_irq(&sr_info->pdev->dev, sr_info->irq,\n\t\t\t\t       sr_interrupt, 0, sr_info->name, sr_info);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tdisable_irq(sr_info->irq);\n\t}\n\n\treturn ret;\n\nerror:\n\tlist_del(&sr_info->node);\n\tdev_err(&sr_info->pdev->dev, \"%s: ERROR in registering interrupt handler. Smartreflex will not function as desired\\n\",\n\t\t__func__);\n\n\treturn ret;\n}\n\nstatic void sr_v1_disable(struct omap_sr *sr)\n{\n\tint timeout = 0;\n\tint errconf_val = ERRCONFIG_MCUACCUMINTST | ERRCONFIG_MCUVALIDINTST |\n\t\t\tERRCONFIG_MCUBOUNDINTST;\n\n\t \n\tsr_modify_reg(sr, ERRCONFIG_V1,\n\t\t\tERRCONFIG_MCUDISACKINTEN, ERRCONFIG_MCUDISACKINTEN);\n\n\t \n\tsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, 0x0);\n\n\t \n\tif (sr_read_reg(sr, ERRCONFIG_V1) & ERRCONFIG_VPBOUNDINTST_V1)\n\t\terrconf_val |= ERRCONFIG_VPBOUNDINTST_V1;\n\tsr_modify_reg(sr, ERRCONFIG_V1,\n\t\t\t(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUVALIDINTEN |\n\t\t\tERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_VPBOUNDINTEN_V1),\n\t\t\terrconf_val);\n\n\t \n\tsr_test_cond_timeout((sr_read_reg(sr, ERRCONFIG_V1) &\n\t\t\t     ERRCONFIG_MCUDISACKINTST), SR_DISABLE_TIMEOUT,\n\t\t\t     timeout);\n\n\tif (timeout >= SR_DISABLE_TIMEOUT)\n\t\tdev_warn(&sr->pdev->dev, \"%s: Smartreflex disable timedout\\n\",\n\t\t\t __func__);\n\n\t \n\tsr_modify_reg(sr, ERRCONFIG_V1, ERRCONFIG_MCUDISACKINTEN,\n\t\t\tERRCONFIG_MCUDISACKINTST);\n}\n\nstatic void sr_v2_disable(struct omap_sr *sr)\n{\n\tint timeout = 0;\n\n\t \n\tsr_write_reg(sr, IRQENABLE_SET, IRQENABLE_MCUDISABLEACKINT);\n\n\t \n\tsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, 0x0);\n\n\t \n\tif (sr_read_reg(sr, ERRCONFIG_V2) & ERRCONFIG_VPBOUNDINTST_V2)\n\t\tsr_modify_reg(sr, ERRCONFIG_V2, ERRCONFIG_VPBOUNDINTEN_V2,\n\t\t\tERRCONFIG_VPBOUNDINTST_V2);\n\telse\n\t\tsr_modify_reg(sr, ERRCONFIG_V2, ERRCONFIG_VPBOUNDINTEN_V2,\n\t\t\t\t0x0);\n\tsr_write_reg(sr, IRQENABLE_CLR, (IRQENABLE_MCUACCUMINT |\n\t\t\tIRQENABLE_MCUVALIDINT |\n\t\t\tIRQENABLE_MCUBOUNDSINT));\n\tsr_write_reg(sr, IRQSTATUS, (IRQSTATUS_MCUACCUMINT |\n\t\t\tIRQSTATUS_MCVALIDINT |\n\t\t\tIRQSTATUS_MCBOUNDSINT));\n\n\t \n\tsr_test_cond_timeout((sr_read_reg(sr, IRQSTATUS) &\n\t\t\t     IRQSTATUS_MCUDISABLEACKINT), SR_DISABLE_TIMEOUT,\n\t\t\t     timeout);\n\n\tif (timeout >= SR_DISABLE_TIMEOUT)\n\t\tdev_warn(&sr->pdev->dev, \"%s: Smartreflex disable timedout\\n\",\n\t\t\t __func__);\n\n\t \n\tsr_write_reg(sr, IRQENABLE_CLR, IRQENABLE_MCUDISABLEACKINT);\n\tsr_write_reg(sr, IRQSTATUS, IRQSTATUS_MCUDISABLEACKINT);\n}\n\nstatic struct omap_sr_nvalue_table *sr_retrieve_nvalue_row(\n\t\t\t\tstruct omap_sr *sr, u32 efuse_offs)\n{\n\tint i;\n\n\tif (!sr->nvalue_table) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: Missing ntarget value table\\n\",\n\t\t\t __func__);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < sr->nvalue_count; i++) {\n\t\tif (sr->nvalue_table[i].efuse_offs == efuse_offs)\n\t\t\treturn &sr->nvalue_table[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\n \nint sr_configure_errgen(struct omap_sr *sr)\n{\n\tu32 sr_config, sr_errconfig, errconfig_offs;\n\tu32 vpboundint_en, vpboundint_st;\n\tu32 senp_en = 0, senn_en = 0;\n\tu8 senp_shift, senn_shift;\n\n\tif (!sr) {\n\t\tpr_warn(\"%s: NULL omap_sr from %pS\\n\",\n\t\t\t__func__, (void *)_RET_IP_);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sr->clk_length)\n\t\tsr_set_clk_length(sr);\n\n\tsenp_en = sr->senp_mod;\n\tsenn_en = sr->senn_mod;\n\n\tsr_config = (sr->clk_length << SRCONFIG_SRCLKLENGTH_SHIFT) |\n\t\tSRCONFIG_SENENABLE | SRCONFIG_ERRGEN_EN;\n\n\tswitch (sr->ip_type) {\n\tcase SR_TYPE_V1:\n\t\tsr_config |= SRCONFIG_DELAYCTRL;\n\t\tsenn_shift = SRCONFIG_SENNENABLE_V1_SHIFT;\n\t\tsenp_shift = SRCONFIG_SENPENABLE_V1_SHIFT;\n\t\terrconfig_offs = ERRCONFIG_V1;\n\t\tvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V1;\n\t\tvpboundint_st = ERRCONFIG_VPBOUNDINTST_V1;\n\t\tbreak;\n\tcase SR_TYPE_V2:\n\t\tsenn_shift = SRCONFIG_SENNENABLE_V2_SHIFT;\n\t\tsenp_shift = SRCONFIG_SENPENABLE_V2_SHIFT;\n\t\terrconfig_offs = ERRCONFIG_V2;\n\t\tvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V2;\n\t\tvpboundint_st = ERRCONFIG_VPBOUNDINTST_V2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr->pdev->dev, \"%s: Trying to Configure smartreflex module without specifying the ip\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsr_config |= ((senn_en << senn_shift) | (senp_en << senp_shift));\n\tsr_write_reg(sr, SRCONFIG, sr_config);\n\tsr_errconfig = (sr->err_weight << ERRCONFIG_ERRWEIGHT_SHIFT) |\n\t\t(sr->err_maxlimit << ERRCONFIG_ERRMAXLIMIT_SHIFT) |\n\t\t(sr->err_minlimit <<  ERRCONFIG_ERRMINLIMIT_SHIFT);\n\tsr_modify_reg(sr, errconfig_offs, (SR_ERRWEIGHT_MASK |\n\t\tSR_ERRMAXLIMIT_MASK | SR_ERRMINLIMIT_MASK),\n\t\tsr_errconfig);\n\n\t \n\tsr_modify_reg(sr, errconfig_offs, (vpboundint_en | vpboundint_st),\n\t\t      vpboundint_en);\n\n\treturn 0;\n}\n\n \nint sr_disable_errgen(struct omap_sr *sr)\n{\n\tu32 errconfig_offs;\n\tu32 vpboundint_en, vpboundint_st;\n\n\tif (!sr) {\n\t\tpr_warn(\"%s: NULL omap_sr from %pS\\n\",\n\t\t\t__func__, (void *)_RET_IP_);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sr->ip_type) {\n\tcase SR_TYPE_V1:\n\t\terrconfig_offs = ERRCONFIG_V1;\n\t\tvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V1;\n\t\tvpboundint_st = ERRCONFIG_VPBOUNDINTST_V1;\n\t\tbreak;\n\tcase SR_TYPE_V2:\n\t\terrconfig_offs = ERRCONFIG_V2;\n\t\tvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V2;\n\t\tvpboundint_st = ERRCONFIG_VPBOUNDINTST_V2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr->pdev->dev, \"%s: Trying to Configure smartreflex module without specifying the ip\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsr_modify_reg(sr, SRCONFIG, SRCONFIG_SENENABLE | SRCONFIG_ERRGEN_EN, 0);\n\n\t \n\tsr_modify_reg(sr, errconfig_offs, vpboundint_en | vpboundint_st, 0);\n\n\treturn 0;\n}\n\n \nint sr_configure_minmax(struct omap_sr *sr)\n{\n\tu32 sr_config, sr_avgwt;\n\tu32 senp_en = 0, senn_en = 0;\n\tu8 senp_shift, senn_shift;\n\n\tif (!sr) {\n\t\tpr_warn(\"%s: NULL omap_sr from %pS\\n\",\n\t\t\t__func__, (void *)_RET_IP_);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sr->clk_length)\n\t\tsr_set_clk_length(sr);\n\n\tsenp_en = sr->senp_mod;\n\tsenn_en = sr->senn_mod;\n\n\tsr_config = (sr->clk_length << SRCONFIG_SRCLKLENGTH_SHIFT) |\n\t\tSRCONFIG_SENENABLE |\n\t\t(sr->accum_data << SRCONFIG_ACCUMDATA_SHIFT);\n\n\tswitch (sr->ip_type) {\n\tcase SR_TYPE_V1:\n\t\tsr_config |= SRCONFIG_DELAYCTRL;\n\t\tsenn_shift = SRCONFIG_SENNENABLE_V1_SHIFT;\n\t\tsenp_shift = SRCONFIG_SENPENABLE_V1_SHIFT;\n\t\tbreak;\n\tcase SR_TYPE_V2:\n\t\tsenn_shift = SRCONFIG_SENNENABLE_V2_SHIFT;\n\t\tsenp_shift = SRCONFIG_SENPENABLE_V2_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr->pdev->dev, \"%s: Trying to Configure smartreflex module without specifying the ip\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsr_config |= ((senn_en << senn_shift) | (senp_en << senp_shift));\n\tsr_write_reg(sr, SRCONFIG, sr_config);\n\tsr_avgwt = (sr->senp_avgweight << AVGWEIGHT_SENPAVGWEIGHT_SHIFT) |\n\t\t(sr->senn_avgweight << AVGWEIGHT_SENNAVGWEIGHT_SHIFT);\n\tsr_write_reg(sr, AVGWEIGHT, sr_avgwt);\n\n\t \n\tswitch (sr->ip_type) {\n\tcase SR_TYPE_V1:\n\t\tsr_modify_reg(sr, ERRCONFIG_V1,\n\t\t\t(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUVALIDINTEN |\n\t\t\tERRCONFIG_MCUBOUNDINTEN),\n\t\t\t(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUACCUMINTST |\n\t\t\t ERRCONFIG_MCUVALIDINTEN | ERRCONFIG_MCUVALIDINTST |\n\t\t\t ERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_MCUBOUNDINTST));\n\t\tbreak;\n\tcase SR_TYPE_V2:\n\t\tsr_write_reg(sr, IRQSTATUS,\n\t\t\tIRQSTATUS_MCUACCUMINT | IRQSTATUS_MCVALIDINT |\n\t\t\tIRQSTATUS_MCBOUNDSINT | IRQSTATUS_MCUDISABLEACKINT);\n\t\tsr_write_reg(sr, IRQENABLE_SET,\n\t\t\tIRQENABLE_MCUACCUMINT | IRQENABLE_MCUVALIDINT |\n\t\t\tIRQENABLE_MCUBOUNDSINT | IRQENABLE_MCUDISABLEACKINT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sr->pdev->dev, \"%s: Trying to Configure smartreflex module without specifying the ip\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint sr_enable(struct omap_sr *sr, unsigned long volt)\n{\n\tstruct omap_volt_data *volt_data;\n\tstruct omap_sr_nvalue_table *nvalue_row;\n\tint ret;\n\n\tif (!sr) {\n\t\tpr_warn(\"%s: NULL omap_sr from %pS\\n\",\n\t\t\t__func__, (void *)_RET_IP_);\n\t\treturn -EINVAL;\n\t}\n\n\tvolt_data = omap_voltage_get_voltdata(sr->voltdm, volt);\n\n\tif (IS_ERR(volt_data)) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: Unable to get voltage table for nominal voltage %ld\\n\",\n\t\t\t __func__, volt);\n\t\treturn PTR_ERR(volt_data);\n\t}\n\n\tnvalue_row = sr_retrieve_nvalue_row(sr, volt_data->sr_efuse_offs);\n\n\tif (!nvalue_row) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: failure getting SR data for this voltage %ld\\n\",\n\t\t\t __func__, volt);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tsr->err_minlimit = nvalue_row->errminlimit;\n\n\tclk_enable(sr->fck);\n\n\t \n\tif (sr_read_reg(sr, SRCONFIG) & SRCONFIG_SRENABLE)\n\t\tgoto out_enabled;\n\n\t \n\tret = sr_class->configure(sr);\n\tif (ret)\n\t\tgoto out_enabled;\n\n\tsr_write_reg(sr, NVALUERECIPROCAL, nvalue_row->nvalue);\n\n\t \n\tsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, SRCONFIG_SRENABLE);\n\nout_enabled:\n\tsr->enabled = 1;\n\n\treturn 0;\n}\n\n \nvoid sr_disable(struct omap_sr *sr)\n{\n\tif (!sr) {\n\t\tpr_warn(\"%s: NULL omap_sr from %pS\\n\",\n\t\t\t__func__, (void *)_RET_IP_);\n\t\treturn;\n\t}\n\n\t \n\tif (!sr->enabled)\n\t\treturn;\n\n\t \n\tif (sr_read_reg(sr, SRCONFIG) & SRCONFIG_SRENABLE) {\n\t\tswitch (sr->ip_type) {\n\t\tcase SR_TYPE_V1:\n\t\t\tsr_v1_disable(sr);\n\t\t\tbreak;\n\t\tcase SR_TYPE_V2:\n\t\t\tsr_v2_disable(sr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&sr->pdev->dev, \"UNKNOWN IP type %d\\n\",\n\t\t\t\tsr->ip_type);\n\t\t}\n\t}\n\n\tclk_disable(sr->fck);\n\tsr->enabled = 0;\n}\n\n \nint sr_register_class(struct omap_sr_class_data *class_data)\n{\n\tstruct omap_sr *sr_info;\n\n\tif (!class_data) {\n\t\tpr_warn(\"%s:, Smartreflex class data passed is NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sr_class) {\n\t\tpr_warn(\"%s: Smartreflex class driver already registered\\n\",\n\t\t\t__func__);\n\t\treturn -EBUSY;\n\t}\n\n\tsr_class = class_data;\n\n\t \n\tlist_for_each_entry(sr_info, &sr_list, node)\n\t\tsr_late_init(sr_info);\n\n\treturn 0;\n}\n\n \nvoid omap_sr_enable(struct voltagedomain *voltdm)\n{\n\tstruct omap_sr *sr = _sr_lookup(voltdm);\n\n\tif (IS_ERR(sr)) {\n\t\tpr_warn(\"%s: omap_sr struct for voltdm not found\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!sr->autocomp_active)\n\t\treturn;\n\n\tif (!sr_class || !(sr_class->enable) || !(sr_class->configure)) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: smartreflex class driver not registered\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tsr_class->enable(sr);\n}\n\n \nvoid omap_sr_disable(struct voltagedomain *voltdm)\n{\n\tstruct omap_sr *sr = _sr_lookup(voltdm);\n\n\tif (IS_ERR(sr)) {\n\t\tpr_warn(\"%s: omap_sr struct for voltdm not found\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!sr->autocomp_active)\n\t\treturn;\n\n\tif (!sr_class || !(sr_class->disable)) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: smartreflex class driver not registered\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tsr_class->disable(sr, 0);\n}\n\n \nvoid omap_sr_disable_reset_volt(struct voltagedomain *voltdm)\n{\n\tstruct omap_sr *sr = _sr_lookup(voltdm);\n\n\tif (IS_ERR(sr)) {\n\t\tpr_warn(\"%s: omap_sr struct for voltdm not found\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!sr->autocomp_active)\n\t\treturn;\n\n\tif (!sr_class || !(sr_class->disable)) {\n\t\tdev_warn(&sr->pdev->dev, \"%s: smartreflex class driver not registered\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\n\tsr_class->disable(sr, 1);\n}\n\n \nstatic int omap_sr_autocomp_show(void *data, u64 *val)\n{\n\tstruct omap_sr *sr_info = data;\n\n\tif (!sr_info) {\n\t\tpr_warn(\"%s: omap_sr struct not found\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*val = sr_info->autocomp_active;\n\n\treturn 0;\n}\n\nstatic int omap_sr_autocomp_store(void *data, u64 val)\n{\n\tstruct omap_sr *sr_info = data;\n\n\tif (!sr_info) {\n\t\tpr_warn(\"%s: omap_sr struct not found\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (val > 1) {\n\t\tpr_warn(\"%s: Invalid argument %lld\\n\", __func__, val);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sr_info->autocomp_active != val) {\n\t\tif (!val)\n\t\t\tsr_stop_vddautocomp(sr_info);\n\t\telse\n\t\t\tsr_start_vddautocomp(sr_info);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(pm_sr_fops, omap_sr_autocomp_show,\n\t\t\tomap_sr_autocomp_store, \"%llu\\n\");\n\nstatic int omap_sr_probe(struct platform_device *pdev)\n{\n\tstruct omap_sr *sr_info;\n\tstruct omap_sr_data *pdata = pdev->dev.platform_data;\n\tstruct dentry *nvalue_dir;\n\tint i, ret = 0;\n\n\tsr_info = devm_kzalloc(&pdev->dev, sizeof(struct omap_sr), GFP_KERNEL);\n\tif (!sr_info)\n\t\treturn -ENOMEM;\n\n\tsr_info->name = devm_kzalloc(&pdev->dev,\n\t\t\t\t     SMARTREFLEX_NAME_LEN, GFP_KERNEL);\n\tif (!sr_info->name)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, sr_info);\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"%s: platform data missing\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsr_info->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sr_info->base))\n\t\treturn PTR_ERR(sr_info->base);\n\n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret < 0 && ret != -ENXIO)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to get IRQ resource\\n\");\n\tif (ret > 0)\n\t\tsr_info->irq = ret;\n\n\tsr_info->fck = devm_clk_get(pdev->dev.parent, \"fck\");\n\tif (IS_ERR(sr_info->fck))\n\t\treturn PTR_ERR(sr_info->fck);\n\tclk_prepare(sr_info->fck);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tsnprintf(sr_info->name, SMARTREFLEX_NAME_LEN, \"%s\", pdata->name);\n\n\tsr_info->pdev = pdev;\n\tsr_info->srid = pdev->id;\n\tsr_info->voltdm = pdata->voltdm;\n\tsr_info->nvalue_table = pdata->nvalue_table;\n\tsr_info->nvalue_count = pdata->nvalue_count;\n\tsr_info->senn_mod = pdata->senn_mod;\n\tsr_info->senp_mod = pdata->senp_mod;\n\tsr_info->err_weight = pdata->err_weight;\n\tsr_info->err_maxlimit = pdata->err_maxlimit;\n\tsr_info->accum_data = pdata->accum_data;\n\tsr_info->senn_avgweight = pdata->senn_avgweight;\n\tsr_info->senp_avgweight = pdata->senp_avgweight;\n\tsr_info->autocomp_active = false;\n\tsr_info->ip_type = pdata->ip_type;\n\n\tsr_set_clk_length(sr_info);\n\n\tlist_add(&sr_info->node, &sr_list);\n\n\t \n\tif (sr_class) {\n\t\tret = sr_late_init(sr_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Error in SR late init\\n\", __func__);\n\t\t\tgoto err_list_del;\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev, \"%s: SmartReflex driver initialized\\n\", __func__);\n\tif (!sr_dbg_dir)\n\t\tsr_dbg_dir = debugfs_create_dir(\"smartreflex\", NULL);\n\n\tsr_info->dbg_dir = debugfs_create_dir(sr_info->name, sr_dbg_dir);\n\n\tdebugfs_create_file(\"autocomp\", S_IRUGO | S_IWUSR, sr_info->dbg_dir,\n\t\t\t    sr_info, &pm_sr_fops);\n\tdebugfs_create_x32(\"errweight\", S_IRUGO, sr_info->dbg_dir,\n\t\t\t   &sr_info->err_weight);\n\tdebugfs_create_x32(\"errmaxlimit\", S_IRUGO, sr_info->dbg_dir,\n\t\t\t   &sr_info->err_maxlimit);\n\n\tnvalue_dir = debugfs_create_dir(\"nvalue\", sr_info->dbg_dir);\n\n\tif (sr_info->nvalue_count == 0 || !sr_info->nvalue_table) {\n\t\tdev_warn(&pdev->dev, \"%s: %s: No Voltage table for the corresponding vdd. Cannot create debugfs entries for n-values\\n\",\n\t\t\t __func__, sr_info->name);\n\n\t\tret = -ENODATA;\n\t\tgoto err_debugfs;\n\t}\n\n\tfor (i = 0; i < sr_info->nvalue_count; i++) {\n\t\tchar name[NVALUE_NAME_LEN + 1];\n\n\t\tsnprintf(name, sizeof(name), \"volt_%lu\",\n\t\t\t\tsr_info->nvalue_table[i].volt_nominal);\n\t\tdebugfs_create_x32(name, S_IRUGO | S_IWUSR, nvalue_dir,\n\t\t\t\t   &(sr_info->nvalue_table[i].nvalue));\n\t\tsnprintf(name, sizeof(name), \"errminlimit_%lu\",\n\t\t\t sr_info->nvalue_table[i].volt_nominal);\n\t\tdebugfs_create_x32(name, S_IRUGO | S_IWUSR, nvalue_dir,\n\t\t\t\t   &(sr_info->nvalue_table[i].errminlimit));\n\n\t}\n\n\treturn 0;\n\nerr_debugfs:\n\tdebugfs_remove_recursive(sr_info->dbg_dir);\nerr_list_del:\n\tpm_runtime_disable(&pdev->dev);\n\tlist_del(&sr_info->node);\n\tclk_unprepare(sr_info->fck);\n\n\treturn ret;\n}\n\nstatic int omap_sr_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct omap_sr *sr_info = platform_get_drvdata(pdev);\n\n\tif (sr_info->autocomp_active)\n\t\tsr_stop_vddautocomp(sr_info);\n\tdebugfs_remove_recursive(sr_info->dbg_dir);\n\n\tpm_runtime_disable(dev);\n\tclk_unprepare(sr_info->fck);\n\tlist_del(&sr_info->node);\n\treturn 0;\n}\n\nstatic void omap_sr_shutdown(struct platform_device *pdev)\n{\n\tstruct omap_sr *sr_info = platform_get_drvdata(pdev);\n\n\tif (sr_info->autocomp_active)\n\t\tsr_stop_vddautocomp(sr_info);\n\n\treturn;\n}\n\nstatic const struct of_device_id omap_sr_match[] = {\n\t{ .compatible = \"ti,omap3-smartreflex-core\", },\n\t{ .compatible = \"ti,omap3-smartreflex-mpu-iva\", },\n\t{ .compatible = \"ti,omap4-smartreflex-core\", },\n\t{ .compatible = \"ti,omap4-smartreflex-mpu\", },\n\t{ .compatible = \"ti,omap4-smartreflex-iva\", },\n\t{  },\n};\nMODULE_DEVICE_TABLE(of, omap_sr_match);\n\nstatic struct platform_driver smartreflex_driver = {\n\t.probe\t\t= omap_sr_probe,\n\t.remove         = omap_sr_remove,\n\t.shutdown\t= omap_sr_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table\t= omap_sr_match,\n\t},\n};\n\nstatic int __init sr_init(void)\n{\n\tint ret = 0;\n\n\tret = platform_driver_register(&smartreflex_driver);\n\tif (ret) {\n\t\tpr_err(\"%s: platform driver register failed for SR\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nlate_initcall(sr_init);\n\nstatic void __exit sr_exit(void)\n{\n\tplatform_driver_unregister(&smartreflex_driver);\n}\nmodule_exit(sr_exit);\n\nMODULE_DESCRIPTION(\"OMAP Smartreflex Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Texas Instruments Inc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}