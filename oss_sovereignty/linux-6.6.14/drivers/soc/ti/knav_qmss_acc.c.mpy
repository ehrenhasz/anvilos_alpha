{
  "module_name": "knav_qmss_acc.c",
  "hash_id": "30a81df9f767e893a7ef579d2dba98c138ea41c8bd1e69eda4233d388e0a6da7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ti/knav_qmss_acc.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/soc/ti/knav_qmss.h>\n\n#include \"knav_qmss.h\"\n\n#define knav_range_offset_to_inst(kdev, range, q)\t\\\n\t(range->queue_base_inst + (q << kdev->inst_shift))\n\nstatic void __knav_acc_notify(struct knav_range_info *range,\n\t\t\t\tstruct knav_acc_channel *acc)\n{\n\tstruct knav_device *kdev = range->kdev;\n\tstruct knav_queue_inst *inst;\n\tint range_base, queue;\n\n\trange_base = kdev->base_id + range->queue_base;\n\n\tif (range->flags & RANGE_MULTI_QUEUE) {\n\t\tfor (queue = 0; queue < range->num_queues; queue++) {\n\t\t\tinst = knav_range_offset_to_inst(kdev, range,\n\t\t\t\t\t\t\t\tqueue);\n\t\t\tif (inst->notify_needed) {\n\t\t\t\tinst->notify_needed = 0;\n\t\t\t\tdev_dbg(kdev->dev, \"acc-irq: notifying %d\\n\",\n\t\t\t\t\trange_base + queue);\n\t\t\t\tknav_queue_notify(inst);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tqueue = acc->channel - range->acc_info.start_channel;\n\t\tinst = knav_range_offset_to_inst(kdev, range, queue);\n\t\tdev_dbg(kdev->dev, \"acc-irq: notifying %d\\n\",\n\t\t\trange_base + queue);\n\t\tknav_queue_notify(inst);\n\t}\n}\n\nstatic int knav_acc_set_notify(struct knav_range_info *range,\n\t\t\t\tstruct knav_queue_inst *kq,\n\t\t\t\tbool enabled)\n{\n\tstruct knav_pdsp_info *pdsp = range->acc_info.pdsp;\n\tstruct knav_device *kdev = range->kdev;\n\tu32 mask, offset;\n\n\t \n\tif (!enabled || atomic_read(&kq->desc_count) <= 0)\n\t\treturn 0;\n\n\tkq->notify_needed = 1;\n\tatomic_inc(&kq->acc->retrigger_count);\n\tmask = BIT(kq->acc->channel % 32);\n\toffset = ACC_INTD_OFFSET_STATUS(kq->acc->channel);\n\tdev_dbg(kdev->dev, \"setup-notify: re-triggering irq for %s\\n\",\n\t\tkq->acc->name);\n\twritel_relaxed(mask, pdsp->intd + offset);\n\treturn 0;\n}\n\nstatic irqreturn_t knav_acc_int_handler(int irq, void *_instdata)\n{\n\tstruct knav_acc_channel *acc;\n\tstruct knav_queue_inst *kq = NULL;\n\tstruct knav_range_info *range;\n\tstruct knav_pdsp_info *pdsp;\n\tstruct knav_acc_info *info;\n\tstruct knav_device *kdev;\n\n\tu32 *list, *list_cpu, val, idx, notifies;\n\tint range_base, channel, queue = 0;\n\tdma_addr_t list_dma;\n\n\trange = _instdata;\n\tinfo  = &range->acc_info;\n\tkdev  = range->kdev;\n\tpdsp  = range->acc_info.pdsp;\n\tacc   = range->acc;\n\n\trange_base = kdev->base_id + range->queue_base;\n\tif ((range->flags & RANGE_MULTI_QUEUE) == 0) {\n\t\tfor (queue = 0; queue < range->num_irqs; queue++)\n\t\t\tif (range->irqs[queue].irq == irq)\n\t\t\t\tbreak;\n\t\tkq = knav_range_offset_to_inst(kdev, range, queue);\n\t\tacc += queue;\n\t}\n\n\tchannel = acc->channel;\n\tlist_dma = acc->list_dma[acc->list_index];\n\tlist_cpu = acc->list_cpu[acc->list_index];\n\tdev_dbg(kdev->dev, \"acc-irq: channel %d, list %d, virt %p, dma %pad\\n\",\n\t\tchannel, acc->list_index, list_cpu, &list_dma);\n\tif (atomic_read(&acc->retrigger_count)) {\n\t\tatomic_dec(&acc->retrigger_count);\n\t\t__knav_acc_notify(range, acc);\n\t\twritel_relaxed(1, pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\n\t\t \n\t\twritel_relaxed(ACC_CHANNEL_INT_BASE + channel,\n\t\t\t       pdsp->intd + ACC_INTD_OFFSET_EOI);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tnotifies = readl_relaxed(pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\n\tWARN_ON(!notifies);\n\tdma_sync_single_for_cpu(kdev->dev, list_dma, info->list_size,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tfor (list = list_cpu; list < list_cpu + (info->list_size / sizeof(u32));\n\t     list += ACC_LIST_ENTRY_WORDS) {\n\t\tif (ACC_LIST_ENTRY_WORDS == 1) {\n\t\t\tdev_dbg(kdev->dev,\n\t\t\t\t\"acc-irq: list %d, entry @%p, %08x\\n\",\n\t\t\t\tacc->list_index, list, list[0]);\n\t\t} else if (ACC_LIST_ENTRY_WORDS == 2) {\n\t\t\tdev_dbg(kdev->dev,\n\t\t\t\t\"acc-irq: list %d, entry @%p, %08x %08x\\n\",\n\t\t\t\tacc->list_index, list, list[0], list[1]);\n\t\t} else if (ACC_LIST_ENTRY_WORDS == 4) {\n\t\t\tdev_dbg(kdev->dev,\n\t\t\t\t\"acc-irq: list %d, entry @%p, %08x %08x %08x %08x\\n\",\n\t\t\t\tacc->list_index, list, list[0], list[1],\n\t\t\t\tlist[2], list[3]);\n\t\t}\n\n\t\tval = list[ACC_LIST_ENTRY_DESC_IDX];\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tif (range->flags & RANGE_MULTI_QUEUE) {\n\t\t\tqueue = list[ACC_LIST_ENTRY_QUEUE_IDX] >> 16;\n\t\t\tif (queue < range_base ||\n\t\t\t    queue >= range_base + range->num_queues) {\n\t\t\t\tdev_err(kdev->dev,\n\t\t\t\t\t\"bad queue %d, expecting %d-%d\\n\",\n\t\t\t\t\tqueue, range_base,\n\t\t\t\t\trange_base + range->num_queues);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue -= range_base;\n\t\t\tkq = knav_range_offset_to_inst(kdev, range,\n\t\t\t\t\t\t\t\tqueue);\n\t\t}\n\n\t\tif (atomic_inc_return(&kq->desc_count) >= ACC_DESCS_MAX) {\n\t\t\tatomic_dec(&kq->desc_count);\n\t\t\tdev_err(kdev->dev,\n\t\t\t\t\"acc-irq: queue %d full, entry dropped\\n\",\n\t\t\t\tqueue + range_base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tidx = atomic_inc_return(&kq->desc_tail) & ACC_DESCS_MASK;\n\t\tkq->descs[idx] = val;\n\t\tkq->notify_needed = 1;\n\t\tdev_dbg(kdev->dev, \"acc-irq: enqueue %08x at %d, queue %d\\n\",\n\t\t\tval, idx, queue + range_base);\n\t}\n\n\t__knav_acc_notify(range, acc);\n\tmemset(list_cpu, 0, info->list_size);\n\tdma_sync_single_for_device(kdev->dev, list_dma, info->list_size,\n\t\t\t\t   DMA_TO_DEVICE);\n\n\t \n\tacc->list_index ^= 1;\n\n\t \n\twritel_relaxed(1, pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\n\n\t \n\twritel_relaxed(ACC_CHANNEL_INT_BASE + channel,\n\t\t       pdsp->intd + ACC_INTD_OFFSET_EOI);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int knav_range_setup_acc_irq(struct knav_range_info *range,\n\t\t\t\tint queue, bool enabled)\n{\n\tstruct knav_device *kdev = range->kdev;\n\tstruct knav_acc_channel *acc;\n\tstruct cpumask *cpu_mask;\n\tint ret = 0, irq;\n\tu32 old, new;\n\n\tif (range->flags & RANGE_MULTI_QUEUE) {\n\t\tacc = range->acc;\n\t\tirq = range->irqs[0].irq;\n\t\tcpu_mask = range->irqs[0].cpu_mask;\n\t} else {\n\t\tacc = range->acc + queue;\n\t\tirq = range->irqs[queue].irq;\n\t\tcpu_mask = range->irqs[queue].cpu_mask;\n\t}\n\n\told = acc->open_mask;\n\tif (enabled)\n\t\tnew = old | BIT(queue);\n\telse\n\t\tnew = old & ~BIT(queue);\n\tacc->open_mask = new;\n\n\tdev_dbg(kdev->dev,\n\t\t\"setup-acc-irq: open mask old %08x, new %08x, channel %s\\n\",\n\t\told, new, acc->name);\n\n\tif (likely(new == old))\n\t\treturn 0;\n\n\tif (new && !old) {\n\t\tdev_dbg(kdev->dev,\n\t\t\t\"setup-acc-irq: requesting %s for channel %s\\n\",\n\t\t\tacc->name, acc->name);\n\t\tret = request_irq(irq, knav_acc_int_handler, 0, acc->name,\n\t\t\t\t  range);\n\t\tif (!ret && cpu_mask) {\n\t\t\tret = irq_set_affinity_hint(irq, cpu_mask);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(range->kdev->dev,\n\t\t\t\t\t \"Failed to set IRQ affinity\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (old && !new) {\n\t\tdev_dbg(kdev->dev, \"setup-acc-irq: freeing %s for channel %s\\n\",\n\t\t\tacc->name, acc->name);\n\t\tret = irq_set_affinity_hint(irq, NULL);\n\t\tif (ret)\n\t\t\tdev_warn(range->kdev->dev,\n\t\t\t\t \"Failed to set IRQ affinity\\n\");\n\t\tfree_irq(irq, range);\n\t}\n\n\treturn ret;\n}\n\nstatic const char *knav_acc_result_str(enum knav_acc_result result)\n{\n\tstatic const char * const result_str[] = {\n\t\t[ACC_RET_IDLE]\t\t\t= \"idle\",\n\t\t[ACC_RET_SUCCESS]\t\t= \"success\",\n\t\t[ACC_RET_INVALID_COMMAND]\t= \"invalid command\",\n\t\t[ACC_RET_INVALID_CHANNEL]\t= \"invalid channel\",\n\t\t[ACC_RET_INACTIVE_CHANNEL]\t= \"inactive channel\",\n\t\t[ACC_RET_ACTIVE_CHANNEL]\t= \"active channel\",\n\t\t[ACC_RET_INVALID_QUEUE]\t\t= \"invalid queue\",\n\t\t[ACC_RET_INVALID_RET]\t\t= \"invalid return code\",\n\t};\n\n\tif (result >= ARRAY_SIZE(result_str))\n\t\treturn result_str[ACC_RET_INVALID_RET];\n\telse\n\t\treturn result_str[result];\n}\n\nstatic enum knav_acc_result\nknav_acc_write(struct knav_device *kdev, struct knav_pdsp_info *pdsp,\n\t\tstruct knav_reg_acc_command *cmd)\n{\n\tu32 result;\n\n\tdev_dbg(kdev->dev, \"acc command %08x %08x %08x %08x %08x\\n\",\n\t\tcmd->command, cmd->queue_mask, cmd->list_dma,\n\t\tcmd->queue_num, cmd->timer_config);\n\n\twritel_relaxed(cmd->timer_config, &pdsp->acc_command->timer_config);\n\twritel_relaxed(cmd->queue_num, &pdsp->acc_command->queue_num);\n\twritel_relaxed(cmd->list_dma, &pdsp->acc_command->list_dma);\n\twritel_relaxed(cmd->queue_mask, &pdsp->acc_command->queue_mask);\n\twritel_relaxed(cmd->command, &pdsp->acc_command->command);\n\n\t \n\tdo {\n\t\tresult = readl_relaxed(&pdsp->acc_command->command);\n\t} while ((result >> 8) & 0xff);\n\n\treturn (result >> 24) & 0xff;\n}\n\nstatic void knav_acc_setup_cmd(struct knav_device *kdev,\n\t\t\t\tstruct knav_range_info *range,\n\t\t\t\tstruct knav_reg_acc_command *cmd,\n\t\t\t\tint queue)\n{\n\tstruct knav_acc_info *info = &range->acc_info;\n\tstruct knav_acc_channel *acc;\n\tint queue_base;\n\tu32 queue_mask;\n\n\tif (range->flags & RANGE_MULTI_QUEUE) {\n\t\tacc = range->acc;\n\t\tqueue_base = range->queue_base;\n\t\tqueue_mask = BIT(range->num_queues) - 1;\n\t} else {\n\t\tacc = range->acc + queue;\n\t\tqueue_base = range->queue_base + queue;\n\t\tqueue_mask = 0;\n\t}\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->command    = acc->channel;\n\tcmd->queue_mask = queue_mask;\n\tcmd->list_dma   = (u32)acc->list_dma[0];\n\tcmd->queue_num  = info->list_entries << 16;\n\tcmd->queue_num |= queue_base;\n\n\tcmd->timer_config = ACC_LIST_ENTRY_TYPE << 18;\n\tif (range->flags & RANGE_MULTI_QUEUE)\n\t\tcmd->timer_config |= ACC_CFG_MULTI_QUEUE;\n\tcmd->timer_config |= info->pacing_mode << 16;\n\tcmd->timer_config |= info->timer_count;\n}\n\nstatic void knav_acc_stop(struct knav_device *kdev,\n\t\t\t\tstruct knav_range_info *range,\n\t\t\t\tint queue)\n{\n\tstruct knav_reg_acc_command cmd;\n\tstruct knav_acc_channel *acc;\n\tenum knav_acc_result result;\n\n\tacc = range->acc + queue;\n\n\tknav_acc_setup_cmd(kdev, range, &cmd, queue);\n\tcmd.command |= ACC_CMD_DISABLE_CHANNEL << 8;\n\tresult = knav_acc_write(kdev, range->acc_info.pdsp, &cmd);\n\n\tdev_dbg(kdev->dev, \"stopped acc channel %s, result %s\\n\",\n\t\tacc->name, knav_acc_result_str(result));\n}\n\nstatic enum knav_acc_result knav_acc_start(struct knav_device *kdev,\n\t\t\t\t\t\tstruct knav_range_info *range,\n\t\t\t\t\t\tint queue)\n{\n\tstruct knav_reg_acc_command cmd;\n\tstruct knav_acc_channel *acc;\n\tenum knav_acc_result result;\n\n\tacc = range->acc + queue;\n\n\tknav_acc_setup_cmd(kdev, range, &cmd, queue);\n\tcmd.command |= ACC_CMD_ENABLE_CHANNEL << 8;\n\tresult = knav_acc_write(kdev, range->acc_info.pdsp, &cmd);\n\n\tdev_dbg(kdev->dev, \"started acc channel %s, result %s\\n\",\n\t\tacc->name, knav_acc_result_str(result));\n\n\treturn result;\n}\n\nstatic int knav_acc_init_range(struct knav_range_info *range)\n{\n\tstruct knav_device *kdev = range->kdev;\n\tstruct knav_acc_channel *acc;\n\tenum knav_acc_result result;\n\tint queue;\n\n\tfor (queue = 0; queue < range->num_queues; queue++) {\n\t\tacc = range->acc + queue;\n\n\t\tknav_acc_stop(kdev, range, queue);\n\t\tacc->list_index = 0;\n\t\tresult = knav_acc_start(kdev, range, queue);\n\n\t\tif (result != ACC_RET_SUCCESS)\n\t\t\treturn -EIO;\n\n\t\tif (range->flags & RANGE_MULTI_QUEUE)\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int knav_acc_init_queue(struct knav_range_info *range,\n\t\t\t\tstruct knav_queue_inst *kq)\n{\n\tunsigned id = kq->id - range->queue_base;\n\n\tkq->descs = devm_kcalloc(range->kdev->dev,\n\t\t\t\t ACC_DESCS_MAX, sizeof(u32), GFP_KERNEL);\n\tif (!kq->descs)\n\t\treturn -ENOMEM;\n\n\tkq->acc = range->acc;\n\tif ((range->flags & RANGE_MULTI_QUEUE) == 0)\n\t\tkq->acc += id;\n\treturn 0;\n}\n\nstatic int knav_acc_open_queue(struct knav_range_info *range,\n\t\t\t\tstruct knav_queue_inst *inst, unsigned flags)\n{\n\tunsigned id = inst->id - range->queue_base;\n\n\treturn knav_range_setup_acc_irq(range, id, true);\n}\n\nstatic int knav_acc_close_queue(struct knav_range_info *range,\n\t\t\t\t\tstruct knav_queue_inst *inst)\n{\n\tunsigned id = inst->id - range->queue_base;\n\n\treturn knav_range_setup_acc_irq(range, id, false);\n}\n\nstatic int knav_acc_free_range(struct knav_range_info *range)\n{\n\tstruct knav_device *kdev = range->kdev;\n\tstruct knav_acc_channel *acc;\n\tstruct knav_acc_info *info;\n\tint channel, channels;\n\n\tinfo = &range->acc_info;\n\n\tif (range->flags & RANGE_MULTI_QUEUE)\n\t\tchannels = 1;\n\telse\n\t\tchannels = range->num_queues;\n\n\tfor (channel = 0; channel < channels; channel++) {\n\t\tacc = range->acc + channel;\n\t\tif (!acc->list_cpu[0])\n\t\t\tcontinue;\n\t\tdma_unmap_single(kdev->dev, acc->list_dma[0],\n\t\t\t\t info->mem_size, DMA_BIDIRECTIONAL);\n\t\tfree_pages_exact(acc->list_cpu[0], info->mem_size);\n\t}\n\tdevm_kfree(range->kdev->dev, range->acc);\n\treturn 0;\n}\n\nstatic struct knav_range_ops knav_acc_range_ops = {\n\t.set_notify\t= knav_acc_set_notify,\n\t.init_queue\t= knav_acc_init_queue,\n\t.open_queue\t= knav_acc_open_queue,\n\t.close_queue\t= knav_acc_close_queue,\n\t.init_range\t= knav_acc_init_range,\n\t.free_range\t= knav_acc_free_range,\n};\n\n \nint knav_init_acc_range(struct knav_device *kdev,\n\t\t\tstruct device_node *node,\n\t\t\tstruct knav_range_info *range)\n{\n\tstruct knav_acc_channel *acc;\n\tstruct knav_pdsp_info *pdsp;\n\tstruct knav_acc_info *info;\n\tint ret, channel, channels;\n\tint list_size, mem_size;\n\tdma_addr_t list_dma;\n\tvoid *list_mem;\n\tu32 config[5];\n\n\trange->flags |= RANGE_HAS_ACCUMULATOR;\n\tinfo = &range->acc_info;\n\n\tret = of_property_read_u32_array(node, \"accumulator\", config, 5);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->pdsp_id\t\t= config[0];\n\tinfo->start_channel\t= config[1];\n\tinfo->list_entries\t= config[2];\n\tinfo->pacing_mode\t= config[3];\n\tinfo->timer_count\t= config[4] / ACC_DEFAULT_PERIOD;\n\n\tif (info->start_channel > ACC_MAX_CHANNEL) {\n\t\tdev_err(kdev->dev, \"channel %d invalid for range %s\\n\",\n\t\t\tinfo->start_channel, range->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->pacing_mode > 3) {\n\t\tdev_err(kdev->dev, \"pacing mode %d invalid for range %s\\n\",\n\t\t\tinfo->pacing_mode, range->name);\n\t\treturn -EINVAL;\n\t}\n\n\tpdsp = knav_find_pdsp(kdev, info->pdsp_id);\n\tif (!pdsp) {\n\t\tdev_err(kdev->dev, \"pdsp id %d not found for range %s\\n\",\n\t\t\tinfo->pdsp_id, range->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdsp->started) {\n\t\tdev_err(kdev->dev, \"pdsp id %d not started for range %s\\n\",\n\t\t\tinfo->pdsp_id, range->name);\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->pdsp = pdsp;\n\tchannels = range->num_queues;\n\tif (of_property_read_bool(node, \"multi-queue\")) {\n\t\trange->flags |= RANGE_MULTI_QUEUE;\n\t\tchannels = 1;\n\t\tif (range->queue_base & (32 - 1)) {\n\t\t\tdev_err(kdev->dev,\n\t\t\t\t\"misaligned multi-queue accumulator range %s\\n\",\n\t\t\t\trange->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (range->num_queues > 32) {\n\t\t\tdev_err(kdev->dev,\n\t\t\t\t\"too many queues in accumulator range %s\\n\",\n\t\t\t\trange->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tlist_size  = info->list_entries;\n\tlist_size *= ACC_LIST_ENTRY_WORDS * sizeof(u32);\n\tinfo->list_size = list_size;\n\tmem_size   = PAGE_ALIGN(list_size * 2);\n\tinfo->mem_size  = mem_size;\n\trange->acc = devm_kcalloc(kdev->dev, channels, sizeof(*range->acc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!range->acc)\n\t\treturn -ENOMEM;\n\n\tfor (channel = 0; channel < channels; channel++) {\n\t\tacc = range->acc + channel;\n\t\tacc->channel = info->start_channel + channel;\n\n\t\t \n\t\tlist_mem = alloc_pages_exact(mem_size, GFP_KERNEL | GFP_DMA);\n\t\tif (!list_mem)\n\t\t\treturn -ENOMEM;\n\n\t\tlist_dma = dma_map_single(kdev->dev, list_mem, mem_size,\n\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(kdev->dev, list_dma)) {\n\t\t\tfree_pages_exact(list_mem, mem_size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemset(list_mem, 0, mem_size);\n\t\tdma_sync_single_for_device(kdev->dev, list_dma, mem_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tscnprintf(acc->name, sizeof(acc->name), \"hwqueue-acc-%d\",\n\t\t\t  acc->channel);\n\t\tacc->list_cpu[0] = list_mem;\n\t\tacc->list_cpu[1] = list_mem + list_size;\n\t\tacc->list_dma[0] = list_dma;\n\t\tacc->list_dma[1] = list_dma + list_size;\n\t\tdev_dbg(kdev->dev, \"%s: channel %d, dma %pad, virt %8p\\n\",\n\t\t\tacc->name, acc->channel, &list_dma, list_mem);\n\t}\n\n\trange->ops = &knav_acc_range_ops;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(knav_init_acc_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}