{
  "module_name": "mfp.c",
  "hash_id": "f3d658c66492279bc9f07d45562568a2bc4864a045b86bc91e5979f4df58b1a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/pxa/mfp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n\n#include <linux/soc/pxa/mfp.h>\n\n#define MFPR_SIZE\t(PAGE_SIZE)\n\n \n#define MFPR_PULL_SEL\t\t(0x1 << 15)\n#define MFPR_PULLUP_EN\t\t(0x1 << 14)\n#define MFPR_PULLDOWN_EN\t(0x1 << 13)\n#define MFPR_SLEEP_SEL\t\t(0x1 << 9)\n#define MFPR_SLEEP_OE_N\t\t(0x1 << 7)\n#define MFPR_EDGE_CLEAR\t\t(0x1 << 6)\n#define MFPR_EDGE_FALL_EN\t(0x1 << 5)\n#define MFPR_EDGE_RISE_EN\t(0x1 << 4)\n\n#define MFPR_SLEEP_DATA(x)\t((x) << 8)\n#define MFPR_DRIVE(x)\t\t(((x) & 0x7) << 10)\n#define MFPR_AF_SEL(x)\t\t(((x) & 0x7) << 0)\n\n#define MFPR_EDGE_NONE\t\t(0)\n#define MFPR_EDGE_RISE\t\t(MFPR_EDGE_RISE_EN)\n#define MFPR_EDGE_FALL\t\t(MFPR_EDGE_FALL_EN)\n#define MFPR_EDGE_BOTH\t\t(MFPR_EDGE_RISE | MFPR_EDGE_FALL)\n\n \n#define MFPR_LPM_INPUT\t\t(0)\n#define MFPR_LPM_DRIVE_LOW\t(MFPR_SLEEP_DATA(0) | MFPR_PULLDOWN_EN)\n#define MFPR_LPM_DRIVE_HIGH    \t(MFPR_SLEEP_DATA(1) | MFPR_PULLUP_EN)\n#define MFPR_LPM_PULL_LOW      \t(MFPR_LPM_DRIVE_LOW  | MFPR_SLEEP_OE_N)\n#define MFPR_LPM_PULL_HIGH     \t(MFPR_LPM_DRIVE_HIGH | MFPR_SLEEP_OE_N)\n#define MFPR_LPM_FLOAT         \t(MFPR_SLEEP_OE_N)\n#define MFPR_LPM_MASK\t\t(0xe080)\n\n \n#define MFPR_PULL_NONE\t\t(0)\n#define MFPR_PULL_LOW\t\t(MFPR_PULL_SEL | MFPR_PULLDOWN_EN)\n#define MFPR_PULL_BOTH\t\t(MFPR_PULL_LOW | MFPR_PULLUP_EN)\n#define MFPR_PULL_HIGH\t\t(MFPR_PULL_SEL | MFPR_PULLUP_EN)\n#define MFPR_PULL_FLOAT\t\t(MFPR_PULL_SEL)\n\n \nstatic DEFINE_SPINLOCK(mfp_spin_lock);\n\nstatic void __iomem *mfpr_mmio_base;\n\nstruct mfp_pin {\n\tunsigned long\tconfig;\t\t \n\tunsigned long\tmfpr_off;\t \n\tunsigned long\tmfpr_run;\t \n\tunsigned long\tmfpr_lpm;\t \n};\n\nstatic struct mfp_pin mfp_table[MFP_PIN_MAX];\n\n \nstatic const unsigned long mfpr_lpm[] = {\n\tMFPR_LPM_INPUT,\n\tMFPR_LPM_DRIVE_LOW,\n\tMFPR_LPM_DRIVE_HIGH,\n\tMFPR_LPM_PULL_LOW,\n\tMFPR_LPM_PULL_HIGH,\n\tMFPR_LPM_FLOAT,\n\tMFPR_LPM_INPUT,\n};\n\n \nstatic const unsigned long mfpr_pull[] = {\n\tMFPR_PULL_NONE,\n\tMFPR_PULL_LOW,\n\tMFPR_PULL_HIGH,\n\tMFPR_PULL_BOTH,\n\tMFPR_PULL_FLOAT,\n};\n\n \nstatic const unsigned long mfpr_edge[] = {\n\tMFPR_EDGE_NONE,\n\tMFPR_EDGE_RISE,\n\tMFPR_EDGE_FALL,\n\tMFPR_EDGE_BOTH,\n};\n\n#define mfpr_readl(off)\t\t\t\\\n\t__raw_readl(mfpr_mmio_base + (off))\n\n#define mfpr_writel(off, val)\t\t\\\n\t__raw_writel(val, mfpr_mmio_base + (off))\n\n#define mfp_configured(p)\t((p)->config != -1)\n\n \nstatic unsigned long mfpr_off_readback;\n#define mfpr_sync()\t(void)__raw_readl(mfpr_mmio_base + mfpr_off_readback)\n\nstatic inline void __mfp_config_run(struct mfp_pin *p)\n{\n\tif (mfp_configured(p))\n\t\tmfpr_writel(p->mfpr_off, p->mfpr_run);\n}\n\nstatic inline void __mfp_config_lpm(struct mfp_pin *p)\n{\n\tif (mfp_configured(p)) {\n\t\tunsigned long mfpr_clr = (p->mfpr_run & ~MFPR_EDGE_BOTH) | MFPR_EDGE_CLEAR;\n\t\tif (mfpr_clr != p->mfpr_run)\n\t\t\tmfpr_writel(p->mfpr_off, mfpr_clr);\n\t\tif (p->mfpr_lpm != mfpr_clr)\n\t\t\tmfpr_writel(p->mfpr_off, p->mfpr_lpm);\n\t}\n}\n\nvoid mfp_config(unsigned long *mfp_cfgs, int num)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mfp_spin_lock, flags);\n\n\tfor (i = 0; i < num; i++, mfp_cfgs++) {\n\t\tunsigned long tmp, c = *mfp_cfgs;\n\t\tstruct mfp_pin *p;\n\t\tint pin, af, drv, lpm, edge, pull;\n\n\t\tpin = MFP_PIN(c);\n\t\tBUG_ON(pin >= MFP_PIN_MAX);\n\t\tp = &mfp_table[pin];\n\n\t\taf  = MFP_AF(c);\n\t\tdrv = MFP_DS(c);\n\t\tlpm = MFP_LPM_STATE(c);\n\t\tedge = MFP_LPM_EDGE(c);\n\t\tpull = MFP_PULL(c);\n\n\t\t \n\t\ttmp = MFPR_AF_SEL(af) | MFPR_DRIVE(drv);\n\n\t\tif (likely(pull == MFP_PULL_NONE)) {\n\t\t\tp->mfpr_run = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];\n\t\t\tp->mfpr_lpm = p->mfpr_run;\n\t\t} else {\n\t\t\tp->mfpr_lpm = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];\n\t\t\tp->mfpr_run = tmp | mfpr_pull[pull];\n\t\t}\n\n\t\tp->config = c; __mfp_config_run(p);\n\t}\n\n\tmfpr_sync();\n\tspin_unlock_irqrestore(&mfp_spin_lock, flags);\n}\n\nunsigned long mfp_read(int mfp)\n{\n\tunsigned long val, flags;\n\n\tBUG_ON(mfp < 0 || mfp >= MFP_PIN_MAX);\n\n\tspin_lock_irqsave(&mfp_spin_lock, flags);\n\tval = mfpr_readl(mfp_table[mfp].mfpr_off);\n\tspin_unlock_irqrestore(&mfp_spin_lock, flags);\n\n\treturn val;\n}\n\nvoid mfp_write(int mfp, unsigned long val)\n{\n\tunsigned long flags;\n\n\tBUG_ON(mfp < 0 || mfp >= MFP_PIN_MAX);\n\n\tspin_lock_irqsave(&mfp_spin_lock, flags);\n\tmfpr_writel(mfp_table[mfp].mfpr_off, val);\n\tmfpr_sync();\n\tspin_unlock_irqrestore(&mfp_spin_lock, flags);\n}\n\nvoid __init mfp_init_base(void __iomem *mfpr_base)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mfp_table); i++)\n\t\tmfp_table[i].config = -1;\n\n\tmfpr_mmio_base = mfpr_base;\n}\n\nvoid __init mfp_init_addr(struct mfp_addr_map *map)\n{\n\tstruct mfp_addr_map *p;\n\tunsigned long offset, flags;\n\tint i;\n\n\tspin_lock_irqsave(&mfp_spin_lock, flags);\n\n\t \n\tmfpr_off_readback = map[0].offset;\n\n\tfor (p = map; p->start != MFP_PIN_INVALID; p++) {\n\t\toffset = p->offset;\n\t\ti = p->start;\n\n\t\tdo {\n\t\t\tmfp_table[i].mfpr_off = offset;\n\t\t\tmfp_table[i].mfpr_run = 0;\n\t\t\tmfp_table[i].mfpr_lpm = 0;\n\t\t\toffset += 4; i++;\n\t\t} while ((i <= p->end) && (p->end != -1));\n\t}\n\n\tspin_unlock_irqrestore(&mfp_spin_lock, flags);\n}\n\nvoid mfp_config_lpm(void)\n{\n\tstruct mfp_pin *p = &mfp_table[0];\n\tint pin;\n\n\tfor (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)\n\t\t__mfp_config_lpm(p);\n}\n\nvoid mfp_config_run(void)\n{\n\tstruct mfp_pin *p = &mfp_table[0];\n\tint pin;\n\n\tfor (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)\n\t\t__mfp_config_run(p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}