{
  "module_name": "ssp.c",
  "hash_id": "93f902ca89db7f71d52bdb4423985da71b523f6b314f39f10dd2cdbc72e6837b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/pxa/ssp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/spi/pxa2xx_spi.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <asm/irq.h>\n\nstatic DEFINE_MUTEX(ssp_lock);\nstatic LIST_HEAD(ssp_list);\n\nstruct ssp_device *pxa_ssp_request(int port, const char *label)\n{\n\tstruct ssp_device *ssp = NULL;\n\n\tmutex_lock(&ssp_lock);\n\n\tlist_for_each_entry(ssp, &ssp_list, node) {\n\t\tif (ssp->port_id == port && ssp->use_count == 0) {\n\t\t\tssp->use_count++;\n\t\t\tssp->label = label;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ssp_lock);\n\n\tif (&ssp->node == &ssp_list)\n\t\treturn NULL;\n\n\treturn ssp;\n}\nEXPORT_SYMBOL(pxa_ssp_request);\n\nstruct ssp_device *pxa_ssp_request_of(const struct device_node *of_node,\n\t\t\t\t      const char *label)\n{\n\tstruct ssp_device *ssp = NULL;\n\n\tmutex_lock(&ssp_lock);\n\n\tlist_for_each_entry(ssp, &ssp_list, node) {\n\t\tif (ssp->of_node == of_node && ssp->use_count == 0) {\n\t\t\tssp->use_count++;\n\t\t\tssp->label = label;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ssp_lock);\n\n\tif (&ssp->node == &ssp_list)\n\t\treturn NULL;\n\n\treturn ssp;\n}\nEXPORT_SYMBOL(pxa_ssp_request_of);\n\nvoid pxa_ssp_free(struct ssp_device *ssp)\n{\n\tmutex_lock(&ssp_lock);\n\tif (ssp->use_count) {\n\t\tssp->use_count--;\n\t\tssp->label = NULL;\n\t} else\n\t\tdev_err(ssp->dev, \"device already free\\n\");\n\tmutex_unlock(&ssp_lock);\n}\nEXPORT_SYMBOL(pxa_ssp_free);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_ssp_of_ids[] = {\n\t{ .compatible = \"mrvl,pxa25x-ssp\",\t.data = (void *) PXA25x_SSP },\n\t{ .compatible = \"mvrl,pxa25x-nssp\",\t.data = (void *) PXA25x_NSSP },\n\t{ .compatible = \"mrvl,pxa27x-ssp\",\t.data = (void *) PXA27x_SSP },\n\t{ .compatible = \"mrvl,pxa3xx-ssp\",\t.data = (void *) PXA3xx_SSP },\n\t{ .compatible = \"mvrl,pxa168-ssp\",\t.data = (void *) PXA168_SSP },\n\t{ .compatible = \"mrvl,pxa910-ssp\",\t.data = (void *) PXA910_SSP },\n\t{ .compatible = \"mrvl,ce4100-ssp\",\t.data = (void *) CE4100_SSP },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pxa_ssp_of_ids);\n#endif\n\nstatic int pxa_ssp_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct ssp_device *ssp;\n\tstruct device *dev = &pdev->dev;\n\n\tssp = devm_kzalloc(dev, sizeof(struct ssp_device), GFP_KERNEL);\n\tif (ssp == NULL)\n\t\treturn -ENOMEM;\n\n\tssp->dev = dev;\n\n\tssp->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ssp->clk))\n\t\treturn PTR_ERR(ssp->clk);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = devm_request_mem_region(dev, res->start, resource_size(res),\n\t\t\t\t      pdev->name);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"failed to request memory resource\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tssp->phys_base = res->start;\n\n\tssp->mmio_base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (ssp->mmio_base == NULL) {\n\t\tdev_err(dev, \"failed to ioremap() registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tssp->irq = platform_get_irq(pdev, 0);\n\tif (ssp->irq < 0)\n\t\treturn -ENODEV;\n\n\tif (dev->of_node) {\n\t\tconst struct of_device_id *id =\n\t\t\tof_match_device(of_match_ptr(pxa_ssp_of_ids), dev);\n\t\tssp->type = (int) id->data;\n\t} else {\n\t\tconst struct platform_device_id *id =\n\t\t\tplatform_get_device_id(pdev);\n\t\tssp->type = (int) id->driver_data;\n\n\t\t \n\t\tssp->port_id = pdev->id + 1;\n\t}\n\n\tssp->use_count = 0;\n\tssp->of_node = dev->of_node;\n\n\tmutex_lock(&ssp_lock);\n\tlist_add(&ssp->node, &ssp_list);\n\tmutex_unlock(&ssp_lock);\n\n\tplatform_set_drvdata(pdev, ssp);\n\n\treturn 0;\n}\n\nstatic int pxa_ssp_remove(struct platform_device *pdev)\n{\n\tstruct ssp_device *ssp = platform_get_drvdata(pdev);\n\n\tmutex_lock(&ssp_lock);\n\tlist_del(&ssp->node);\n\tmutex_unlock(&ssp_lock);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id ssp_id_table[] = {\n\t{ \"pxa25x-ssp\",\t\tPXA25x_SSP },\n\t{ \"pxa25x-nssp\",\tPXA25x_NSSP },\n\t{ \"pxa27x-ssp\",\t\tPXA27x_SSP },\n\t{ \"pxa3xx-ssp\",\t\tPXA3xx_SSP },\n\t{ \"pxa168-ssp\",\t\tPXA168_SSP },\n\t{ \"pxa910-ssp\",\t\tPXA910_SSP },\n\t{ },\n};\n\nstatic struct platform_driver pxa_ssp_driver = {\n\t.probe\t\t= pxa_ssp_probe,\n\t.remove\t\t= pxa_ssp_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"pxa2xx-ssp\",\n\t\t.of_match_table\t= of_match_ptr(pxa_ssp_of_ids),\n\t},\n\t.id_table\t= ssp_id_table,\n};\n\nstatic int __init pxa_ssp_init(void)\n{\n\treturn platform_driver_register(&pxa_ssp_driver);\n}\n\nstatic void __exit pxa_ssp_exit(void)\n{\n\tplatform_driver_unregister(&pxa_ssp_driver);\n}\n\narch_initcall(pxa_ssp_init);\nmodule_exit(pxa_ssp_exit);\n\nMODULE_DESCRIPTION(\"PXA SSP driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}