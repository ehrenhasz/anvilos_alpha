{
  "module_name": "zynqmp_power.c",
  "hash_id": "3901a3c4aa952a2648d4be2007aa409a9b46b4893e6f88929962e5060213d8ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/xilinx/zynqmp_power.c",
  "human_readable_source": "\n \n\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/firmware/xlnx-event-manager.h>\n#include <linux/mailbox/zynqmp-ipi-message.h>\n\n \nstruct zynqmp_pm_work_struct {\n\tstruct work_struct callback_work;\n\tu32 args[CB_ARG_CNT];\n};\n\nstatic struct zynqmp_pm_work_struct *zynqmp_pm_init_suspend_work;\nstatic struct mbox_chan *rx_chan;\nstatic bool event_registered;\n\nenum pm_suspend_mode {\n\tPM_SUSPEND_MODE_FIRST = 0,\n\tPM_SUSPEND_MODE_STD = PM_SUSPEND_MODE_FIRST,\n\tPM_SUSPEND_MODE_POWER_OFF,\n};\n\n#define PM_SUSPEND_MODE_FIRST\tPM_SUSPEND_MODE_STD\n\nstatic const char *const suspend_modes[] = {\n\t[PM_SUSPEND_MODE_STD] = \"standard\",\n\t[PM_SUSPEND_MODE_POWER_OFF] = \"power-off\",\n};\n\nstatic enum pm_suspend_mode suspend_mode = PM_SUSPEND_MODE_STD;\n\nstatic void zynqmp_pm_get_callback_data(u32 *buf)\n{\n\tzynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, buf);\n}\n\nstatic void suspend_event_callback(const u32 *payload, void *data)\n{\n\t \n\tif (work_pending(&zynqmp_pm_init_suspend_work->callback_work))\n\t\treturn;\n\n\t \n\tmemcpy(zynqmp_pm_init_suspend_work->args, &payload[1],\n\t       sizeof(zynqmp_pm_init_suspend_work->args));\n\n\tqueue_work(system_unbound_wq, &zynqmp_pm_init_suspend_work->callback_work);\n}\n\nstatic irqreturn_t zynqmp_pm_isr(int irq, void *data)\n{\n\tu32 payload[CB_PAYLOAD_SIZE];\n\n\tzynqmp_pm_get_callback_data(payload);\n\n\t \n\tif (payload[0] == PM_INIT_SUSPEND_CB) {\n\t\tswitch (payload[1]) {\n\t\tcase SUSPEND_SYSTEM_SHUTDOWN:\n\t\t\torderly_poweroff(true);\n\t\t\tbreak;\n\t\tcase SUSPEND_POWER_REQUEST:\n\t\t\tpm_suspend(PM_SUSPEND_MEM);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s Unsupported InitSuspendCb reason \"\n\t\t\t\t\"code %d\\n\", __func__, payload[1]);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ipi_receive_callback(struct mbox_client *cl, void *data)\n{\n\tstruct zynqmp_ipi_message *msg = (struct zynqmp_ipi_message *)data;\n\tu32 payload[CB_PAYLOAD_SIZE];\n\tint ret;\n\n\tmemcpy(payload, msg->data, sizeof(msg->len));\n\t \n\tif (payload[0] == PM_INIT_SUSPEND_CB) {\n\t\tif (work_pending(&zynqmp_pm_init_suspend_work->callback_work))\n\t\t\treturn;\n\n\t\t \n\t\tmemcpy(zynqmp_pm_init_suspend_work->args, &payload[1],\n\t\t       sizeof(zynqmp_pm_init_suspend_work->args));\n\n\t\tqueue_work(system_unbound_wq,\n\t\t\t   &zynqmp_pm_init_suspend_work->callback_work);\n\n\t\t \n\t\tret = mbox_send_message(rx_chan, NULL);\n\t\tif (ret)\n\t\t\tpr_err(\"IPI ack failed. Error %d\\n\", ret);\n\t}\n}\n\n \nstatic void zynqmp_pm_init_suspend_work_fn(struct work_struct *work)\n{\n\tstruct zynqmp_pm_work_struct *pm_work =\n\t\tcontainer_of(work, struct zynqmp_pm_work_struct, callback_work);\n\n\tif (pm_work->args[0] == SUSPEND_SYSTEM_SHUTDOWN) {\n\t\torderly_poweroff(true);\n\t} else if (pm_work->args[0] == SUSPEND_POWER_REQUEST) {\n\t\tpm_suspend(PM_SUSPEND_MEM);\n\t} else {\n\t\tpr_err(\"%s Unsupported InitSuspendCb reason code %d.\\n\",\n\t\t       __func__, pm_work->args[0]);\n\t}\n}\n\nstatic ssize_t suspend_mode_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tchar *s = buf;\n\tint md;\n\n\tfor (md = PM_SUSPEND_MODE_FIRST; md < ARRAY_SIZE(suspend_modes); md++)\n\t\tif (suspend_modes[md]) {\n\t\t\tif (md == suspend_mode)\n\t\t\t\ts += sprintf(s, \"[%s] \", suspend_modes[md]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", suspend_modes[md]);\n\t\t}\n\n\t \n\tif (s != buf)\n\t\t*(s - 1) = '\\n';\n\treturn (s - buf);\n}\n\nstatic ssize_t suspend_mode_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint md, ret = -EINVAL;\n\n\tfor (md = PM_SUSPEND_MODE_FIRST; md < ARRAY_SIZE(suspend_modes); md++)\n\t\tif (suspend_modes[md] &&\n\t\t    sysfs_streq(suspend_modes[md], buf)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\tif (!ret && md != suspend_mode) {\n\t\tret = zynqmp_pm_set_suspend_mode(md);\n\t\tif (likely(!ret))\n\t\t\tsuspend_mode = md;\n\t}\n\n\treturn ret ? ret : count;\n}\n\nstatic DEVICE_ATTR_RW(suspend_mode);\n\nstatic int zynqmp_pm_probe(struct platform_device *pdev)\n{\n\tint ret, irq;\n\tu32 pm_api_version;\n\tstruct mbox_client *client;\n\n\tzynqmp_pm_get_api_version(&pm_api_version);\n\n\t \n\tif (pm_api_version < ZYNQMP_PM_VERSION)\n\t\treturn -ENODEV;\n\n\t \n\tret = xlnx_register_event(PM_INIT_SUSPEND_CB, 0, 0, false,\n\t\t\t\t  suspend_event_callback, NULL);\n\tif (!ret) {\n\t\tzynqmp_pm_init_suspend_work = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\t   sizeof(struct zynqmp_pm_work_struct),\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!zynqmp_pm_init_suspend_work) {\n\t\t\txlnx_unregister_event(PM_INIT_SUSPEND_CB, 0, 0,\n\t\t\t\t\t      suspend_event_callback, NULL);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tevent_registered = true;\n\n\t\tINIT_WORK(&zynqmp_pm_init_suspend_work->callback_work,\n\t\t\t  zynqmp_pm_init_suspend_work_fn);\n\t} else if (ret != -EACCES && ret != -ENODEV) {\n\t\tdev_err(&pdev->dev, \"Failed to Register with Xilinx Event manager %d\\n\", ret);\n\t\treturn ret;\n\t} else if (of_property_present(pdev->dev.of_node, \"mboxes\")) {\n\t\tzynqmp_pm_init_suspend_work =\n\t\t\tdevm_kzalloc(&pdev->dev,\n\t\t\t\t     sizeof(struct zynqmp_pm_work_struct),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!zynqmp_pm_init_suspend_work)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_WORK(&zynqmp_pm_init_suspend_work->callback_work,\n\t\t\t  zynqmp_pm_init_suspend_work_fn);\n\t\tclient = devm_kzalloc(&pdev->dev, sizeof(*client), GFP_KERNEL);\n\t\tif (!client)\n\t\t\treturn -ENOMEM;\n\n\t\tclient->dev = &pdev->dev;\n\t\tclient->rx_callback = ipi_receive_callback;\n\n\t\trx_chan = mbox_request_channel_byname(client, \"rx\");\n\t\tif (IS_ERR(rx_chan)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to request rx channel\\n\");\n\t\t\treturn PTR_ERR(rx_chan);\n\t\t}\n\t} else if (of_property_present(pdev->dev.of_node, \"interrupts\")) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tzynqmp_pm_isr,\n\t\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\t\t&pdev->dev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"devm_request_threaded_irq '%d' \"\n\t\t\t\t\t    \"failed with %d\\n\", irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_err(&pdev->dev, \"Required property not found in DT node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_suspend_mode.attr);\n\tif (ret) {\n\t\tif (event_registered) {\n\t\t\txlnx_unregister_event(PM_INIT_SUSPEND_CB, 0, 0, suspend_event_callback,\n\t\t\t\t\t      NULL);\n\t\t\tevent_registered = false;\n\t\t}\n\t\tdev_err(&pdev->dev, \"unable to create sysfs interface\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int zynqmp_pm_remove(struct platform_device *pdev)\n{\n\tsysfs_remove_file(&pdev->dev.kobj, &dev_attr_suspend_mode.attr);\n\tif (event_registered)\n\t\txlnx_unregister_event(PM_INIT_SUSPEND_CB, 0, 0, suspend_event_callback, NULL);\n\n\tif (!rx_chan)\n\t\tmbox_free_channel(rx_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pm_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-power\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, pm_of_match);\n\nstatic struct platform_driver zynqmp_pm_platform_driver = {\n\t.probe = zynqmp_pm_probe,\n\t.remove = zynqmp_pm_remove,\n\t.driver = {\n\t\t.name = \"zynqmp_power\",\n\t\t.of_match_table = pm_of_match,\n\t},\n};\nmodule_platform_driver(zynqmp_pm_platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}