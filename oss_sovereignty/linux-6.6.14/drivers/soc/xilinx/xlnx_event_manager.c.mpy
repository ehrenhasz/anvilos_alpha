{
  "module_name": "xlnx_event_manager.c",
  "hash_id": "6fa4891814d6f108a89962274fa38de0aa5079ab54bc65d505c8186004ff3467",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/xilinx/xlnx_event_manager.c",
  "human_readable_source": "\n \n\n#include <linux/cpuhotplug.h>\n#include <linux/firmware/xlnx-event-manager.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/hashtable.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nstatic DEFINE_PER_CPU_READ_MOSTLY(int, cpu_number1);\n\nstatic int virq_sgi;\nstatic int event_manager_availability = -EACCES;\n\n \n#define XLNX_EVENT_SGI_NUM\t(15)\n\n \n#define MAX_DRIVER_PER_EVENT\t(10U)\n\n \n#define REGISTERED_DRIVER_MAX_ORDER\t(7)\n\n#define MAX_BITS\t(32U)  \n\n#define FIRMWARE_VERSION_MASK\t\t\t(0xFFFFU)\n#define REGISTER_NOTIFIER_FIRMWARE_VERSION\t(2U)\n\nstatic DEFINE_HASHTABLE(reg_driver_map, REGISTERED_DRIVER_MAX_ORDER);\nstatic int sgi_num = XLNX_EVENT_SGI_NUM;\n\nstatic bool is_need_to_unregister;\n\n \nstruct agent_cb {\n\tvoid *agent_data;\n\tevent_cb_func_t eve_cb;\n\tstruct list_head list;\n};\n\n \nstruct registered_event_data {\n\tu64 key;\n\tenum pm_api_cb_id cb_type;\n\tbool wake;\n\tstruct list_head cb_list_head;\n\tstruct hlist_node hentry;\n};\n\nstatic bool xlnx_is_error_event(const u32 node_id)\n{\n\tif (node_id == EVENT_ERROR_PMC_ERR1 ||\n\t    node_id == EVENT_ERROR_PMC_ERR2 ||\n\t    node_id == EVENT_ERROR_PSM_ERR1 ||\n\t    node_id == EVENT_ERROR_PSM_ERR2)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int xlnx_add_cb_for_notify_event(const u32 node_id, const u32 event, const bool wake,\n\t\t\t\t\tevent_cb_func_t cb_fun,\tvoid *data)\n{\n\tu64 key = 0;\n\tbool present_in_hash = false;\n\tstruct registered_event_data *eve_data;\n\tstruct agent_cb *cb_data;\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\n\tkey = ((u64)node_id << 32U) | (u64)event;\n\t \n\thash_for_each_possible(reg_driver_map, eve_data, hentry, key) {\n\t\tif (eve_data->key == key) {\n\t\t\tpresent_in_hash = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!present_in_hash) {\n\t\t \n\t\teve_data = kmalloc(sizeof(*eve_data), GFP_KERNEL);\n\t\tif (!eve_data)\n\t\t\treturn -ENOMEM;\n\t\teve_data->key = key;\n\t\teve_data->cb_type = PM_NOTIFY_CB;\n\t\teve_data->wake = wake;\n\t\tINIT_LIST_HEAD(&eve_data->cb_list_head);\n\n\t\tcb_data = kmalloc(sizeof(*cb_data), GFP_KERNEL);\n\t\tif (!cb_data) {\n\t\t\tkfree(eve_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcb_data->eve_cb = cb_fun;\n\t\tcb_data->agent_data = data;\n\n\t\t \n\t\tlist_add(&cb_data->list, &eve_data->cb_list_head);\n\n\t\t \n\t\thash_add(reg_driver_map, &eve_data->hentry, key);\n\t} else {\n\t\t \n\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\tif (cb_pos->eve_cb == cb_fun &&\n\t\t\t    cb_pos->agent_data == data) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcb_data = kmalloc(sizeof(*cb_data), GFP_KERNEL);\n\t\tif (!cb_data)\n\t\t\treturn -ENOMEM;\n\t\tcb_data->eve_cb = cb_fun;\n\t\tcb_data->agent_data = data;\n\n\t\tlist_add(&cb_data->list, &eve_data->cb_list_head);\n\t}\n\n\treturn 0;\n}\n\nstatic int xlnx_add_cb_for_suspend(event_cb_func_t cb_fun, void *data)\n{\n\tstruct registered_event_data *eve_data;\n\tstruct agent_cb *cb_data;\n\n\t \n\thash_for_each_possible(reg_driver_map, eve_data, hentry, PM_INIT_SUSPEND_CB) {\n\t\tif (eve_data->cb_type == PM_INIT_SUSPEND_CB) {\n\t\t\tpr_err(\"Found as already registered\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\teve_data = kmalloc(sizeof(*eve_data), GFP_KERNEL);\n\tif (!eve_data)\n\t\treturn -ENOMEM;\n\n\teve_data->key = 0;\n\teve_data->cb_type = PM_INIT_SUSPEND_CB;\n\tINIT_LIST_HEAD(&eve_data->cb_list_head);\n\n\tcb_data = kmalloc(sizeof(*cb_data), GFP_KERNEL);\n\tif (!cb_data)\n\t\treturn -ENOMEM;\n\tcb_data->eve_cb = cb_fun;\n\tcb_data->agent_data = data;\n\n\t \n\tlist_add(&cb_data->list, &eve_data->cb_list_head);\n\n\thash_add(reg_driver_map, &eve_data->hentry, PM_INIT_SUSPEND_CB);\n\n\treturn 0;\n}\n\nstatic int xlnx_remove_cb_for_suspend(event_cb_func_t cb_fun)\n{\n\tbool is_callback_found = false;\n\tstruct registered_event_data *eve_data;\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\tstruct hlist_node *tmp;\n\n\tis_need_to_unregister = false;\n\n\t \n\thash_for_each_possible_safe(reg_driver_map, eve_data, tmp, hentry, PM_INIT_SUSPEND_CB) {\n\t\tif (eve_data->cb_type == PM_INIT_SUSPEND_CB) {\n\t\t\t \n\t\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\t\tif (cb_pos->eve_cb == cb_fun) {\n\t\t\t\t\tis_callback_found = true;\n\t\t\t\t\tlist_del_init(&cb_pos->list);\n\t\t\t\t\tkfree(cb_pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\thash_del(&eve_data->hentry);\n\t\t\tkfree(eve_data);\n\t\t\tis_need_to_unregister = true;\n\t\t}\n\t}\n\tif (!is_callback_found) {\n\t\tpr_warn(\"Didn't find any registered callback for suspend event\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int xlnx_remove_cb_for_notify_event(const u32 node_id, const u32 event,\n\t\t\t\t\t   event_cb_func_t cb_fun, void *data)\n{\n\tbool is_callback_found = false;\n\tstruct registered_event_data *eve_data;\n\tu64 key = ((u64)node_id << 32U) | (u64)event;\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\tstruct hlist_node *tmp;\n\n\tis_need_to_unregister = false;\n\n\t \n\thash_for_each_possible_safe(reg_driver_map, eve_data, tmp, hentry, key) {\n\t\tif (eve_data->key == key) {\n\t\t\t \n\t\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\t\tif (cb_pos->eve_cb == cb_fun &&\n\t\t\t\t    cb_pos->agent_data == data) {\n\t\t\t\t\tis_callback_found = true;\n\t\t\t\t\tlist_del_init(&cb_pos->list);\n\t\t\t\t\tkfree(cb_pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (list_empty(&eve_data->cb_list_head)) {\n\t\t\t\t \n\t\t\t\thash_del(&eve_data->hentry);\n\t\t\t\tkfree(eve_data);\n\t\t\t\tis_need_to_unregister = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_callback_found) {\n\t\tpr_warn(\"Didn't find any registered callback for 0x%x 0x%x\\n\",\n\t\t\tnode_id, event);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint xlnx_register_event(const enum pm_api_cb_id cb_type, const u32 node_id, const u32 event,\n\t\t\tconst bool wake, event_cb_func_t cb_fun, void *data)\n{\n\tint ret = 0;\n\tu32 eve;\n\tint pos;\n\n\tif (event_manager_availability)\n\t\treturn event_manager_availability;\n\n\tif (cb_type != PM_NOTIFY_CB && cb_type != PM_INIT_SUSPEND_CB) {\n\t\tpr_err(\"%s() Unsupported Callback 0x%x\\n\", __func__, cb_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cb_fun)\n\t\treturn -EFAULT;\n\n\tif (cb_type == PM_INIT_SUSPEND_CB) {\n\t\tret = xlnx_add_cb_for_suspend(cb_fun, data);\n\t} else {\n\t\tif (!xlnx_is_error_event(node_id)) {\n\t\t\t \n\t\t\tret = xlnx_add_cb_for_notify_event(node_id, event, wake, cb_fun, data);\n\t\t} else {\n\t\t\t \n\t\t\tfor (pos = 0; pos < MAX_BITS; pos++) {\n\t\t\t\teve = event & (1 << pos);\n\t\t\t\tif (!eve)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tret = xlnx_add_cb_for_notify_event(node_id, eve, wake, cb_fun,\n\t\t\t\t\t\t\t\t   data);\n\t\t\t\t \n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tpos--;\n\t\t\t\t \n\t\t\t\tfor ( ; pos >= 0; pos--) {\n\t\t\t\t\teve = event & (1 << pos);\n\t\t\t\t\tif (!eve)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txlnx_remove_cb_for_notify_event(node_id, eve, cb_fun, data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tpr_err(\"%s() failed for 0x%x and 0x%x: %d\\r\\n\", __func__, node_id,\n\t\t\t       event, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = zynqmp_pm_register_notifier(node_id, event, wake, true);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s() failed for 0x%x and 0x%x: %d\\r\\n\", __func__, node_id,\n\t\t\t       event, ret);\n\t\t\t \n\t\t\tif (xlnx_is_error_event(node_id)) {\n\t\t\t\tfor (pos = 0; pos < MAX_BITS; pos++) {\n\t\t\t\t\teve = event & (1 << pos);\n\t\t\t\t\tif (!eve)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txlnx_remove_cb_for_notify_event(node_id, eve, cb_fun, data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txlnx_remove_cb_for_notify_event(node_id, event, cb_fun, data);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xlnx_register_event);\n\n \nint xlnx_unregister_event(const enum pm_api_cb_id cb_type, const u32 node_id, const u32 event,\n\t\t\t  event_cb_func_t cb_fun, void *data)\n{\n\tint ret = 0;\n\tu32 eve, pos;\n\n\tis_need_to_unregister = false;\n\n\tif (event_manager_availability)\n\t\treturn event_manager_availability;\n\n\tif (cb_type != PM_NOTIFY_CB && cb_type != PM_INIT_SUSPEND_CB) {\n\t\tpr_err(\"%s() Unsupported Callback 0x%x\\n\", __func__, cb_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cb_fun)\n\t\treturn -EFAULT;\n\n\tif (cb_type == PM_INIT_SUSPEND_CB) {\n\t\tret = xlnx_remove_cb_for_suspend(cb_fun);\n\t} else {\n\t\t \n\t\tif (!xlnx_is_error_event(node_id)) {\n\t\t\txlnx_remove_cb_for_notify_event(node_id, event, cb_fun, data);\n\t\t} else {\n\t\t\tfor (pos = 0; pos < MAX_BITS; pos++) {\n\t\t\t\teve = event & (1 << pos);\n\t\t\t\tif (!eve)\n\t\t\t\t\tcontinue;\n\n\t\t\t\txlnx_remove_cb_for_notify_event(node_id, eve, cb_fun, data);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_need_to_unregister) {\n\t\t\t \n\t\t\tret = zynqmp_pm_register_notifier(node_id, event, false, false);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"%s() failed for 0x%x and 0x%x: %d\\n\",\n\t\t\t\t       __func__, node_id, event, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xlnx_unregister_event);\n\nstatic void xlnx_call_suspend_cb_handler(const u32 *payload)\n{\n\tbool is_callback_found = false;\n\tstruct registered_event_data *eve_data;\n\tu32 cb_type = payload[0];\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\n\t \n\thash_for_each_possible(reg_driver_map, eve_data, hentry, cb_type) {\n\t\tif (eve_data->cb_type == cb_type) {\n\t\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\t\tcb_pos->eve_cb(&payload[0], cb_pos->agent_data);\n\t\t\t\tis_callback_found = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_callback_found)\n\t\tpr_warn(\"Didn't find any registered callback for suspend event\\n\");\n}\n\nstatic void xlnx_call_notify_cb_handler(const u32 *payload)\n{\n\tbool is_callback_found = false;\n\tstruct registered_event_data *eve_data;\n\tu64 key = ((u64)payload[1] << 32U) | (u64)payload[2];\n\tint ret;\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\n\t \n\thash_for_each_possible(reg_driver_map, eve_data, hentry, key) {\n\t\tif (eve_data->key == key) {\n\t\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\t\tcb_pos->eve_cb(&payload[0], cb_pos->agent_data);\n\t\t\t\tis_callback_found = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = zynqmp_pm_register_notifier(payload[1], payload[2],\n\t\t\t\t\t\t\t  eve_data->wake, true);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"%s() failed for 0x%x and 0x%x: %d\\r\\n\", __func__,\n\t\t\t\t       payload[1], payload[2], ret);\n\t\t\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head,\n\t\t\t\t\t\t\t list) {\n\t\t\t\t\t \n\t\t\t\t\txlnx_remove_cb_for_notify_event(payload[1], payload[2],\n\t\t\t\t\t\t\t\t\tcb_pos->eve_cb,\n\t\t\t\t\t\t\t\t\tcb_pos->agent_data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_callback_found)\n\t\tpr_warn(\"Didn't find any registered callback for 0x%x 0x%x\\n\",\n\t\t\tpayload[1], payload[2]);\n}\n\nstatic void xlnx_get_event_callback_data(u32 *buf)\n{\n\tzynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, buf);\n}\n\nstatic irqreturn_t xlnx_event_handler(int irq, void *dev_id)\n{\n\tu32 cb_type, node_id, event, pos;\n\tu32 payload[CB_MAX_PAYLOAD_SIZE] = {0};\n\tu32 event_data[CB_MAX_PAYLOAD_SIZE] = {0};\n\n\t \n\txlnx_get_event_callback_data(payload);\n\n\t \n\tcb_type = payload[0];\n\n\tif (cb_type == PM_NOTIFY_CB) {\n\t\tnode_id = payload[1];\n\t\tevent = payload[2];\n\t\tif (!xlnx_is_error_event(node_id)) {\n\t\t\txlnx_call_notify_cb_handler(payload);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(event_data, payload, (4 * CB_MAX_PAYLOAD_SIZE));\n\t\t\t \n\t\t\tfor (pos = 0; pos < MAX_BITS; pos++) {\n\t\t\t\tif ((0 == (event & (1 << pos))))\n\t\t\t\t\tcontinue;\n\t\t\t\tevent_data[2] = (event & (1 << pos));\n\t\t\t\txlnx_call_notify_cb_handler(event_data);\n\t\t\t}\n\t\t}\n\t} else if (cb_type == PM_INIT_SUSPEND_CB) {\n\t\txlnx_call_suspend_cb_handler(payload);\n\t} else {\n\t\tpr_err(\"%s() Unsupported Callback %d\\n\", __func__, cb_type);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xlnx_event_cpuhp_start(unsigned int cpu)\n{\n\tenable_percpu_irq(virq_sgi, IRQ_TYPE_NONE);\n\n\treturn 0;\n}\n\nstatic int xlnx_event_cpuhp_down(unsigned int cpu)\n{\n\tdisable_percpu_irq(virq_sgi);\n\n\treturn 0;\n}\n\nstatic void xlnx_disable_percpu_irq(void *data)\n{\n\tdisable_percpu_irq(virq_sgi);\n}\n\nstatic int xlnx_event_init_sgi(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint cpu = smp_processor_id();\n\t \n\tstruct irq_domain *domain;\n\tstruct irq_fwspec sgi_fwspec;\n\tstruct device_node *interrupt_parent = NULL;\n\tstruct device *parent = pdev->dev.parent;\n\n\t \n\tinterrupt_parent = of_irq_find_parent(parent->of_node);\n\tif (!interrupt_parent) {\n\t\tdev_err(&pdev->dev, \"Failed to find property for Interrupt parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdomain = irq_find_host(interrupt_parent);\n\tof_node_put(interrupt_parent);\n\n\t \n\tsgi_fwspec.fwnode = domain->fwnode;\n\n\t \n\tsgi_fwspec.param_count = 1;\n\n\t \n\tsgi_fwspec.param[0] = sgi_num;\n\tvirq_sgi = irq_create_fwspec_mapping(&sgi_fwspec);\n\n\tper_cpu(cpu_number1, cpu) = cpu;\n\tret = request_percpu_irq(virq_sgi, xlnx_event_handler, \"xlnx_event_mgmt\",\n\t\t\t\t &cpu_number1);\n\tWARN_ON(ret);\n\tif (ret) {\n\t\tirq_dispose_mapping(virq_sgi);\n\t\treturn ret;\n\t}\n\n\tirq_to_desc(virq_sgi);\n\tirq_set_status_flags(virq_sgi, IRQ_PER_CPU);\n\n\treturn ret;\n}\n\nstatic void xlnx_event_cleanup_sgi(struct platform_device *pdev)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_number1, cpu) = cpu;\n\n\tcpuhp_remove_state(CPUHP_AP_ONLINE_DYN);\n\n\ton_each_cpu(xlnx_disable_percpu_irq, NULL, 1);\n\n\tirq_clear_status_flags(virq_sgi, IRQ_PER_CPU);\n\tfree_percpu_irq(virq_sgi, &cpu_number1);\n\tirq_dispose_mapping(virq_sgi);\n}\n\nstatic int xlnx_event_manager_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = zynqmp_pm_feature(PM_REGISTER_NOTIFIER);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Feature check failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif ((ret & FIRMWARE_VERSION_MASK) <\n\t    REGISTER_NOTIFIER_FIRMWARE_VERSION) {\n\t\tdev_err(&pdev->dev, \"Register notifier version error. Expected Firmware: v%d - Found: v%d\\n\",\n\t\t\tREGISTER_NOTIFIER_FIRMWARE_VERSION,\n\t\t\tret & FIRMWARE_VERSION_MASK);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tret = xlnx_event_init_sgi(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"SGI Init has been failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"soc/event:starting\",\n\t\t\t  xlnx_event_cpuhp_start, xlnx_event_cpuhp_down);\n\n\tret = zynqmp_pm_register_sgi(sgi_num, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"SGI %d Registration over TF-A failed with %d\\n\", sgi_num, ret);\n\t\txlnx_event_cleanup_sgi(pdev);\n\t\treturn ret;\n\t}\n\n\tevent_manager_availability = 0;\n\n\tdev_info(&pdev->dev, \"SGI %d Registered over TF-A\\n\", sgi_num);\n\tdev_info(&pdev->dev, \"Xilinx Event Management driver probed\\n\");\n\n\treturn ret;\n}\n\nstatic void xlnx_event_manager_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct registered_event_data *eve_data;\n\tstruct hlist_node *tmp;\n\tint ret;\n\tstruct agent_cb *cb_pos;\n\tstruct agent_cb *cb_next;\n\n\thash_for_each_safe(reg_driver_map, i, tmp, eve_data, hentry) {\n\t\tlist_for_each_entry_safe(cb_pos, cb_next, &eve_data->cb_list_head, list) {\n\t\t\tlist_del_init(&cb_pos->list);\n\t\t\tkfree(cb_pos);\n\t\t}\n\t\thash_del(&eve_data->hentry);\n\t\tkfree(eve_data);\n\t}\n\n\tret = zynqmp_pm_register_sgi(0, 1);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"SGI unregistration over TF-A failed with %d\\n\", ret);\n\n\txlnx_event_cleanup_sgi(pdev);\n\n\tevent_manager_availability = -EACCES;\n}\n\nstatic struct platform_driver xlnx_event_manager_driver = {\n\t.probe = xlnx_event_manager_probe,\n\t.remove_new = xlnx_event_manager_remove,\n\t.driver = {\n\t\t.name = \"xlnx_event_manager\",\n\t},\n};\nmodule_param(sgi_num, uint, 0);\nmodule_platform_driver(xlnx_event_manager_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}