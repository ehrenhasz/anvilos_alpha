{
  "module_name": "soc-imx8m.c",
  "hash_id": "5fa8c56af21130d5fad4b4feb4cba225548953ac8468e3450181d90a6c8e11db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/imx/soc-imx8m.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n#include <linux/platform_device.h>\n#include <linux/arm-smccc.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n\n#define REV_B1\t\t\t\t0x21\n\n#define IMX8MQ_SW_INFO_B1\t\t0x40\n#define IMX8MQ_SW_MAGIC_B1\t\t0xff0055aa\n\n#define IMX_SIP_GET_SOC_INFO\t\t0xc2000006\n\n#define OCOTP_UID_LOW\t\t\t0x410\n#define OCOTP_UID_HIGH\t\t\t0x420\n\n#define IMX8MP_OCOTP_UID_OFFSET\t\t0x10\n\n \n#define ANADIG_DIGPROG_IMX8MM\t0x800\n\nstruct imx8_soc_data {\n\tchar *name;\n\tu32 (*soc_revision)(void);\n};\n\nstatic u64 soc_uid;\n\n#ifdef CONFIG_HAVE_ARM_SMCCC\nstatic u32 imx8mq_soc_revision_from_atf(void)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(IMX_SIP_GET_SOC_INFO, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tif (res.a0 == SMCCC_RET_NOT_SUPPORTED)\n\t\treturn 0;\n\telse\n\t\treturn res.a0 & 0xff;\n}\n#else\nstatic inline u32 imx8mq_soc_revision_from_atf(void) { return 0; };\n#endif\n\nstatic u32 __init imx8mq_soc_revision(void)\n{\n\tstruct device_node *np;\n\tvoid __iomem *ocotp_base;\n\tu32 magic;\n\tu32 rev;\n\tstruct clk *clk;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,imx8mq-ocotp\");\n\tif (!np)\n\t\treturn 0;\n\n\tocotp_base = of_iomap(np, 0);\n\tWARN_ON(!ocotp_base);\n\tclk = of_clk_get_by_name(np, NULL);\n\tif (IS_ERR(clk)) {\n\t\tWARN_ON(IS_ERR(clk));\n\t\treturn 0;\n\t}\n\n\tclk_prepare_enable(clk);\n\n\t \n\trev = imx8mq_soc_revision_from_atf();\n\tif (!rev) {\n\t\tmagic = readl_relaxed(ocotp_base + IMX8MQ_SW_INFO_B1);\n\t\tif (magic == IMX8MQ_SW_MAGIC_B1)\n\t\t\trev = REV_B1;\n\t}\n\n\tsoc_uid = readl_relaxed(ocotp_base + OCOTP_UID_HIGH);\n\tsoc_uid <<= 32;\n\tsoc_uid |= readl_relaxed(ocotp_base + OCOTP_UID_LOW);\n\n\tclk_disable_unprepare(clk);\n\tclk_put(clk);\n\tiounmap(ocotp_base);\n\tof_node_put(np);\n\n\treturn rev;\n}\n\nstatic void __init imx8mm_soc_uid(void)\n{\n\tvoid __iomem *ocotp_base;\n\tstruct device_node *np;\n\tstruct clk *clk;\n\tu32 offset = of_machine_is_compatible(\"fsl,imx8mp\") ?\n\t\t     IMX8MP_OCOTP_UID_OFFSET : 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,imx8mm-ocotp\");\n\tif (!np)\n\t\treturn;\n\n\tocotp_base = of_iomap(np, 0);\n\tWARN_ON(!ocotp_base);\n\tclk = of_clk_get_by_name(np, NULL);\n\tif (IS_ERR(clk)) {\n\t\tWARN_ON(IS_ERR(clk));\n\t\treturn;\n\t}\n\n\tclk_prepare_enable(clk);\n\n\tsoc_uid = readl_relaxed(ocotp_base + OCOTP_UID_HIGH + offset);\n\tsoc_uid <<= 32;\n\tsoc_uid |= readl_relaxed(ocotp_base + OCOTP_UID_LOW + offset);\n\n\tclk_disable_unprepare(clk);\n\tclk_put(clk);\n\tiounmap(ocotp_base);\n\tof_node_put(np);\n}\n\nstatic u32 __init imx8mm_soc_revision(void)\n{\n\tstruct device_node *np;\n\tvoid __iomem *anatop_base;\n\tu32 rev;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,imx8mm-anatop\");\n\tif (!np)\n\t\treturn 0;\n\n\tanatop_base = of_iomap(np, 0);\n\tWARN_ON(!anatop_base);\n\n\trev = readl_relaxed(anatop_base + ANADIG_DIGPROG_IMX8MM);\n\n\tiounmap(anatop_base);\n\tof_node_put(np);\n\n\timx8mm_soc_uid();\n\n\treturn rev;\n}\n\nstatic const struct imx8_soc_data imx8mq_soc_data = {\n\t.name = \"i.MX8MQ\",\n\t.soc_revision = imx8mq_soc_revision,\n};\n\nstatic const struct imx8_soc_data imx8mm_soc_data = {\n\t.name = \"i.MX8MM\",\n\t.soc_revision = imx8mm_soc_revision,\n};\n\nstatic const struct imx8_soc_data imx8mn_soc_data = {\n\t.name = \"i.MX8MN\",\n\t.soc_revision = imx8mm_soc_revision,\n};\n\nstatic const struct imx8_soc_data imx8mp_soc_data = {\n\t.name = \"i.MX8MP\",\n\t.soc_revision = imx8mm_soc_revision,\n};\n\nstatic __maybe_unused const struct of_device_id imx8_soc_match[] = {\n\t{ .compatible = \"fsl,imx8mq\", .data = &imx8mq_soc_data, },\n\t{ .compatible = \"fsl,imx8mm\", .data = &imx8mm_soc_data, },\n\t{ .compatible = \"fsl,imx8mn\", .data = &imx8mn_soc_data, },\n\t{ .compatible = \"fsl,imx8mp\", .data = &imx8mp_soc_data, },\n\t{ }\n};\n\n#define imx8_revision(soc_rev) \\\n\tsoc_rev ? \\\n\tkasprintf(GFP_KERNEL, \"%d.%d\", (soc_rev >> 4) & 0xf,  soc_rev & 0xf) : \\\n\t\"unknown\"\n\nstatic int __init imx8_soc_init(void)\n{\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct soc_device *soc_dev;\n\tconst struct of_device_id *id;\n\tu32 soc_rev = 0;\n\tconst struct imx8_soc_data *data;\n\tint ret;\n\n\tsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENOMEM;\n\n\tsoc_dev_attr->family = \"Freescale i.MX\";\n\n\tret = of_property_read_string(of_root, \"model\", &soc_dev_attr->machine);\n\tif (ret)\n\t\tgoto free_soc;\n\n\tid = of_match_node(imx8_soc_match, of_root);\n\tif (!id) {\n\t\tret = -ENODEV;\n\t\tgoto free_soc;\n\t}\n\n\tdata = id->data;\n\tif (data) {\n\t\tsoc_dev_attr->soc_id = data->name;\n\t\tif (data->soc_revision)\n\t\t\tsoc_rev = data->soc_revision();\n\t}\n\n\tsoc_dev_attr->revision = imx8_revision(soc_rev);\n\tif (!soc_dev_attr->revision) {\n\t\tret = -ENOMEM;\n\t\tgoto free_soc;\n\t}\n\n\tsoc_dev_attr->serial_number = kasprintf(GFP_KERNEL, \"%016llX\", soc_uid);\n\tif (!soc_dev_attr->serial_number) {\n\t\tret = -ENOMEM;\n\t\tgoto free_rev;\n\t}\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev)) {\n\t\tret = PTR_ERR(soc_dev);\n\t\tgoto free_serial_number;\n\t}\n\n\tpr_info(\"SoC: %s revision %s\\n\", soc_dev_attr->soc_id,\n\t\tsoc_dev_attr->revision);\n\n\tif (IS_ENABLED(CONFIG_ARM_IMX_CPUFREQ_DT))\n\t\tplatform_device_register_simple(\"imx-cpufreq-dt\", -1, NULL, 0);\n\n\treturn 0;\n\nfree_serial_number:\n\tkfree(soc_dev_attr->serial_number);\nfree_rev:\n\tif (strcmp(soc_dev_attr->revision, \"unknown\"))\n\t\tkfree(soc_dev_attr->revision);\nfree_soc:\n\tkfree(soc_dev_attr);\n\treturn ret;\n}\ndevice_initcall(imx8_soc_init);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}