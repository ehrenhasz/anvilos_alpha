{
  "module_name": "exynos-usi.c",
  "hash_id": "86c2006d163bb2e0c463505756a7e32d78867eca82c6a970495dd58f8635515d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/samsung/exynos-usi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/soc/samsung,exynos-usi.h>\n\n \n#define USI_V2_SW_CONF_NONE\t0x0\n#define USI_V2_SW_CONF_UART\tBIT(0)\n#define USI_V2_SW_CONF_SPI\tBIT(1)\n#define USI_V2_SW_CONF_I2C\tBIT(2)\n#define USI_V2_SW_CONF_MASK\t(USI_V2_SW_CONF_UART | USI_V2_SW_CONF_SPI | \\\n\t\t\t\t USI_V2_SW_CONF_I2C)\n\n \n#define USI_CON\t\t\t0x04\n#define USI_OPTION\t\t0x08\n\n \n#define USI_CON_RESET\t\tBIT(0)\n#define USI_OPTION_CLKREQ_ON\tBIT(1)\n#define USI_OPTION_CLKSTOP_ON\tBIT(2)\n\nenum exynos_usi_ver {\n\tUSI_VER2 = 2,\n};\n\nstruct exynos_usi_variant {\n\tenum exynos_usi_ver ver;\t \n\tunsigned int sw_conf_mask;\t \n\tsize_t min_mode;\t\t \n\tsize_t max_mode;\t\t \n\tsize_t num_clks;\t\t \n\tconst char * const *clk_names;\t \n};\n\nstruct exynos_usi {\n\tstruct device *dev;\n\tvoid __iomem *regs;\t\t \n\tstruct clk_bulk_data *clks;\t \n\n\tsize_t mode;\t\t\t \n\tbool clkreq_on;\t\t\t \n\n\t \n\tstruct regmap *sysreg;\t\t \n\tunsigned int sw_conf;\t\t \n\n\tconst struct exynos_usi_variant *data;\n};\n\nstruct exynos_usi_mode {\n\tconst char *name;\t\t \n\tunsigned int val;\t\t \n};\n\nstatic const struct exynos_usi_mode exynos_usi_modes[] = {\n\t[USI_V2_NONE] =\t{ .name = \"none\", .val = USI_V2_SW_CONF_NONE },\n\t[USI_V2_UART] =\t{ .name = \"uart\", .val = USI_V2_SW_CONF_UART },\n\t[USI_V2_SPI] =\t{ .name = \"spi\",  .val = USI_V2_SW_CONF_SPI },\n\t[USI_V2_I2C] =\t{ .name = \"i2c\",  .val = USI_V2_SW_CONF_I2C },\n};\n\nstatic const char * const exynos850_usi_clk_names[] = { \"pclk\", \"ipclk\" };\nstatic const struct exynos_usi_variant exynos850_usi_data = {\n\t.ver\t\t= USI_VER2,\n\t.sw_conf_mask\t= USI_V2_SW_CONF_MASK,\n\t.min_mode\t= USI_V2_NONE,\n\t.max_mode\t= USI_V2_I2C,\n\t.num_clks\t= ARRAY_SIZE(exynos850_usi_clk_names),\n\t.clk_names\t= exynos850_usi_clk_names,\n};\n\nstatic const struct of_device_id exynos_usi_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos850-usi\",\n\t\t.data = &exynos850_usi_data,\n\t},\n\t{ }  \n};\nMODULE_DEVICE_TABLE(of, exynos_usi_dt_match);\n\n \nstatic int exynos_usi_set_sw_conf(struct exynos_usi *usi, size_t mode)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (mode < usi->data->min_mode || mode > usi->data->max_mode)\n\t\treturn -EINVAL;\n\n\tval = exynos_usi_modes[mode].val;\n\tret = regmap_update_bits(usi->sysreg, usi->sw_conf,\n\t\t\t\t usi->data->sw_conf_mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\tusi->mode = mode;\n\tdev_dbg(usi->dev, \"protocol: %s\\n\", exynos_usi_modes[usi->mode].name);\n\n\treturn 0;\n}\n\n \nstatic int exynos_usi_enable(const struct exynos_usi *usi)\n{\n\tu32 val;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(usi->data->num_clks, usi->clks);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = readl(usi->regs + USI_CON);\n\tval &= ~USI_CON_RESET;\n\twritel(val, usi->regs + USI_CON);\n\tudelay(1);\n\n\t \n\tif (usi->clkreq_on) {\n\t\tval = readl(usi->regs + USI_OPTION);\n\t\tval &= ~USI_OPTION_CLKSTOP_ON;\n\t\tval |= USI_OPTION_CLKREQ_ON;\n\t\twritel(val, usi->regs + USI_OPTION);\n\t}\n\n\tclk_bulk_disable_unprepare(usi->data->num_clks, usi->clks);\n\n\treturn ret;\n}\n\nstatic int exynos_usi_configure(struct exynos_usi *usi)\n{\n\tint ret;\n\n\tret = exynos_usi_set_sw_conf(usi, usi->mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (usi->data->ver == USI_VER2)\n\t\treturn exynos_usi_enable(usi);\n\n\treturn 0;\n}\n\nstatic int exynos_usi_parse_dt(struct device_node *np, struct exynos_usi *usi)\n{\n\tint ret;\n\tu32 mode;\n\n\tret = of_property_read_u32(np, \"samsung,mode\", &mode);\n\tif (ret)\n\t\treturn ret;\n\tif (mode < usi->data->min_mode || mode > usi->data->max_mode)\n\t\treturn -EINVAL;\n\tusi->mode = mode;\n\n\tusi->sysreg = syscon_regmap_lookup_by_phandle(np, \"samsung,sysreg\");\n\tif (IS_ERR(usi->sysreg))\n\t\treturn PTR_ERR(usi->sysreg);\n\n\tret = of_property_read_u32_index(np, \"samsung,sysreg\", 1,\n\t\t\t\t\t &usi->sw_conf);\n\tif (ret)\n\t\treturn ret;\n\n\tusi->clkreq_on = of_property_read_bool(np, \"samsung,clkreq-on\");\n\n\treturn 0;\n}\n\nstatic int exynos_usi_get_clocks(struct exynos_usi *usi)\n{\n\tconst size_t num = usi->data->num_clks;\n\tstruct device *dev = usi->dev;\n\tsize_t i;\n\n\tif (num == 0)\n\t\treturn 0;\n\n\tusi->clks = devm_kcalloc(dev, num, sizeof(*usi->clks), GFP_KERNEL);\n\tif (!usi->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; ++i)\n\t\tusi->clks[i].id = usi->data->clk_names[i];\n\n\treturn devm_clk_bulk_get(dev, num, usi->clks);\n}\n\nstatic int exynos_usi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct exynos_usi *usi;\n\tint ret;\n\n\tusi = devm_kzalloc(dev, sizeof(*usi), GFP_KERNEL);\n\tif (!usi)\n\t\treturn -ENOMEM;\n\n\tusi->dev = dev;\n\tplatform_set_drvdata(pdev, usi);\n\n\tusi->data = of_device_get_match_data(dev);\n\tif (!usi->data)\n\t\treturn -EINVAL;\n\n\tret = exynos_usi_parse_dt(np, usi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_usi_get_clocks(usi);\n\tif (ret)\n\t\treturn ret;\n\n\tif (usi->data->ver == USI_VER2) {\n\t\tusi->regs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(usi->regs))\n\t\t\treturn PTR_ERR(usi->regs);\n\t}\n\n\tret = exynos_usi_configure(usi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn of_platform_populate(np, NULL, NULL, dev);\n}\n\nstatic int __maybe_unused exynos_usi_resume_noirq(struct device *dev)\n{\n\tstruct exynos_usi *usi = dev_get_drvdata(dev);\n\n\treturn exynos_usi_configure(usi);\n}\n\nstatic const struct dev_pm_ops exynos_usi_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, exynos_usi_resume_noirq)\n};\n\nstatic struct platform_driver exynos_usi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"exynos-usi\",\n\t\t.pm\t\t= &exynos_usi_pm,\n\t\t.of_match_table\t= exynos_usi_dt_match,\n\t},\n\t.probe = exynos_usi_probe,\n};\nmodule_platform_driver(exynos_usi_driver);\n\nMODULE_DESCRIPTION(\"Samsung USI driver\");\nMODULE_AUTHOR(\"Sam Protsenko <semen.protsenko@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}