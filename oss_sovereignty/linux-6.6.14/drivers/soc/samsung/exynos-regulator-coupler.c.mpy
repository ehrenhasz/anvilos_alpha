{
  "module_name": "exynos-regulator-coupler.c",
  "hash_id": "8a24fa25e5725d5b8dfa5254f8dfdadcb4dc5d40b930b3368dc9d3c159cb3d38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/samsung/exynos-regulator-coupler.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/regulator/coupler.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\nstatic int regulator_get_optimal_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t int *current_uV,\n\t\t\t\t\t int *min_uV, int *max_uV,\n\t\t\t\t\t suspend_state_t state)\n{\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tstruct regulator_dev **c_rdevs = c_desc->coupled_rdevs;\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\tint desired_min_uV = 0, desired_max_uV = INT_MAX;\n\tint max_current_uV = 0, min_current_uV = INT_MAX;\n\tint highest_min_uV = 0, target_uV, possible_uV;\n\tint i, ret, max_spread, n_coupled = c_desc->n_coupled;\n\tbool done;\n\n\t*current_uV = -1;\n\n\t \n\tfor (i = 0; i < n_coupled; i++) {\n\t\tint tmp_min = 0;\n\t\tint tmp_max = INT_MAX;\n\n\t\tlockdep_assert_held_once(&c_rdevs[i]->mutex.base);\n\n\t\tret = regulator_check_consumers(c_rdevs[i],\n\t\t\t\t\t\t&tmp_min,\n\t\t\t\t\t\t&tmp_max, state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (tmp_min == 0) {\n\t\t\tret = regulator_get_voltage_rdev(c_rdevs[i]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\ttmp_min = ret;\n\t\t}\n\n\t\t \n\t\tret = regulator_check_voltage(c_rdevs[i], &tmp_min, &tmp_max);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\thighest_min_uV = max(highest_min_uV, tmp_min);\n\n\t\tif (i == 0) {\n\t\t\tdesired_min_uV = tmp_min;\n\t\t\tdesired_max_uV = tmp_max;\n\t\t}\n\t}\n\n\tmax_spread = constraints->max_spread[0];\n\n\t \n\ttarget_uV = max(desired_min_uV, highest_min_uV - max_spread);\n\n\t \n\tfor (i = 1; i < n_coupled; i++) {\n\t\tint tmp_act;\n\n\t\ttmp_act = regulator_get_voltage_rdev(c_rdevs[i]);\n\t\tif (tmp_act < 0)\n\t\t\treturn tmp_act;\n\n\t\tmin_current_uV = min(tmp_act, min_current_uV);\n\t\tmax_current_uV = max(tmp_act, max_current_uV);\n\t}\n\n\t \n\tpossible_uV = max(target_uV, max_current_uV - max_spread);\n\tpossible_uV = min(possible_uV, min_current_uV + max_spread);\n\n\tif (possible_uV > desired_max_uV)\n\t\treturn -EINVAL;\n\n\tdone = (possible_uV == target_uV);\n\tdesired_min_uV = possible_uV;\n\n\t \n\tif (*current_uV == -1) {\n\t\tret = regulator_get_voltage_rdev(rdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*current_uV = ret;\n\t}\n\n\t*min_uV = desired_min_uV;\n\t*max_uV = desired_max_uV;\n\n\treturn done;\n}\n\nstatic int exynos_coupler_balance_voltage(struct regulator_coupler *coupler,\n\t\t\t\t\t  struct regulator_dev *rdev,\n\t\t\t\t\t  suspend_state_t state)\n{\n\tstruct regulator_dev **c_rdevs;\n\tstruct regulator_dev *best_rdev;\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tint i, ret, n_coupled, best_min_uV, best_max_uV, best_c_rdev;\n\tunsigned int delta, best_delta;\n\tunsigned long c_rdev_done = 0;\n\tbool best_c_rdev_done;\n\n\tc_rdevs = c_desc->coupled_rdevs;\n\tn_coupled = c_desc->n_coupled;\n\n\t \n\tdo {\n\t\tbest_c_rdev_done = false;\n\t\tbest_delta = 0;\n\t\tbest_min_uV = 0;\n\t\tbest_max_uV = 0;\n\t\tbest_c_rdev = 0;\n\t\tbest_rdev = NULL;\n\n\t\t \n\t\tfor (i = 0; i < n_coupled; i++) {\n\t\t\t \n\t\t\tint optimal_uV = 0, optimal_max_uV = 0, current_uV = 0;\n\n\t\t\tif (test_bit(i, &c_rdev_done))\n\t\t\t\tcontinue;\n\n\t\t\tret = regulator_get_optimal_voltage(c_rdevs[i],\n\t\t\t\t\t\t\t    &current_uV,\n\t\t\t\t\t\t\t    &optimal_uV,\n\t\t\t\t\t\t\t    &optimal_max_uV,\n\t\t\t\t\t\t\t    state);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tdelta = abs(optimal_uV - current_uV);\n\n\t\t\tif (delta && best_delta <= delta) {\n\t\t\t\tbest_c_rdev_done = ret;\n\t\t\t\tbest_delta = delta;\n\t\t\t\tbest_rdev = c_rdevs[i];\n\t\t\t\tbest_min_uV = optimal_uV;\n\t\t\t\tbest_max_uV = optimal_max_uV;\n\t\t\t\tbest_c_rdev = i;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!best_rdev) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regulator_set_voltage_rdev(best_rdev, best_min_uV,\n\t\t\t\t\t\t best_max_uV, state);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (best_c_rdev_done)\n\t\t\tset_bit(best_c_rdev, &c_rdev_done);\n\n\t} while (n_coupled > 1);\n\nout:\n\treturn ret;\n}\n\nstatic int exynos_coupler_attach(struct regulator_coupler *coupler,\n\t\t\t\t struct regulator_dev *rdev)\n{\n\treturn 0;\n}\n\nstatic struct regulator_coupler exynos_coupler = {\n\t.attach_regulator = exynos_coupler_attach,\n\t.balance_voltage  = exynos_coupler_balance_voltage,\n};\n\nstatic int __init exynos_coupler_init(void)\n{\n\tif (!of_machine_is_compatible(\"samsung,exynos5800\"))\n\t\treturn 0;\n\n\treturn regulator_coupler_register(&exynos_coupler);\n}\narch_initcall(exynos_coupler_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}