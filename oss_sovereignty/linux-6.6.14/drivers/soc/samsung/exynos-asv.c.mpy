{
  "module_name": "exynos-asv.c",
  "hash_id": "eeff677610f2229e846f4542d2960c0a9ed5621d0233d48f3d618e0d9d323025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/samsung/exynos-asv.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/soc/samsung/exynos-chipid.h>\n\n#include \"exynos-asv.h\"\n#include \"exynos5422-asv.h\"\n\n#define MHZ 1000000U\n\nstatic int exynos_asv_update_cpu_opps(struct exynos_asv *asv,\n\t\t\t\t      struct device *cpu)\n{\n\tstruct exynos_asv_subsys *subsys = NULL;\n\tstruct dev_pm_opp *opp;\n\tunsigned int opp_freq;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(asv->subsys); i++) {\n\t\tif (of_device_is_compatible(cpu->of_node,\n\t\t\t\t\t    asv->subsys[i].cpu_dt_compat)) {\n\t\t\tsubsys = &asv->subsys[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!subsys)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < subsys->table.num_rows; i++) {\n\t\tunsigned int new_volt, volt;\n\t\tint ret;\n\n\t\topp_freq = exynos_asv_opp_get_frequency(subsys, i);\n\n\t\topp = dev_pm_opp_find_freq_exact(cpu, opp_freq * MHZ, true);\n\t\tif (IS_ERR(opp)) {\n\t\t\tdev_info(asv->dev, \"cpu%d opp%d, freq: %u missing\\n\",\n\t\t\t\t cpu->id, i, opp_freq);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvolt = dev_pm_opp_get_voltage(opp);\n\t\tnew_volt = asv->opp_get_voltage(subsys, i, volt);\n\t\tdev_pm_opp_put(opp);\n\n\t\tif (new_volt == volt)\n\t\t\tcontinue;\n\n\t\tret = dev_pm_opp_adjust_voltage(cpu, opp_freq * MHZ,\n\t\t\t\t\t\tnew_volt, new_volt, new_volt);\n\t\tif (ret < 0)\n\t\t\tdev_err(asv->dev,\n\t\t\t\t\"Failed to adjust OPP %u Hz/%u uV for cpu%d\\n\",\n\t\t\t\topp_freq, new_volt, cpu->id);\n\t\telse\n\t\t\tdev_dbg(asv->dev,\n\t\t\t\t\"Adjusted OPP %u Hz/%u -> %u uV, cpu%d\\n\",\n\t\t\t\topp_freq, volt, new_volt, cpu->id);\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_asv_update_opps(struct exynos_asv *asv)\n{\n\tstruct opp_table *last_opp_table = NULL;\n\tstruct device *cpu;\n\tint ret, cpuid;\n\n\tfor_each_possible_cpu(cpuid) {\n\t\tstruct opp_table *opp_table;\n\n\t\tcpu = get_cpu_device(cpuid);\n\t\tif (!cpu)\n\t\t\tcontinue;\n\n\t\topp_table = dev_pm_opp_get_opp_table(cpu);\n\t\tif (IS_ERR(opp_table))\n\t\t\tcontinue;\n\n\t\tif (!last_opp_table || opp_table != last_opp_table) {\n\t\t\tlast_opp_table = opp_table;\n\n\t\t\tret = exynos_asv_update_cpu_opps(asv, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(asv->dev, \"Couldn't udate OPPs for cpu%d\\n\",\n\t\t\t\t\tcpuid);\n\t\t}\n\n\t\tdev_pm_opp_put_opp_table(opp_table);\n\t}\n\n\treturn\t0;\n}\n\nint exynos_asv_init(struct device *dev, struct regmap *regmap)\n{\n\tint (*probe_func)(struct exynos_asv *asv);\n\tstruct exynos_asv *asv;\n\tstruct device *cpu_dev;\n\tu32 product_id = 0;\n\tint ret, i;\n\n\tasv = devm_kzalloc(dev, sizeof(*asv), GFP_KERNEL);\n\tif (!asv)\n\t\treturn -ENOMEM;\n\n\tasv->chipid_regmap = regmap;\n\tasv->dev = dev;\n\tret = regmap_read(asv->chipid_regmap, EXYNOS_CHIPID_REG_PRO_ID,\n\t\t\t  &product_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot read revision from ChipID: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (product_id & EXYNOS_MASK) {\n\tcase 0xE5422000:\n\t\tprobe_func = exynos5422_asv_init;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"No ASV support for this SoC\\n\");\n\t\tdevm_kfree(dev, asv);\n\t\treturn 0;\n\t}\n\n\tcpu_dev = get_cpu_device(0);\n\tret = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (ret < 0)\n\t\treturn -EPROBE_DEFER;\n\n\tret = of_property_read_u32(dev->of_node, \"samsung,asv-bin\",\n\t\t\t\t   &asv->of_bin);\n\tif (ret < 0)\n\t\tasv->of_bin = -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(asv->subsys); i++)\n\t\tasv->subsys[i].asv = asv;\n\n\tret = probe_func(asv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn exynos_asv_update_opps(asv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}