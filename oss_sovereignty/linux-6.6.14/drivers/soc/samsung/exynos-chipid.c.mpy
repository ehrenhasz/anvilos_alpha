{
  "module_name": "exynos-chipid.c",
  "hash_id": "dab977400b870f40210ba38ba14c337f985fa8fa6b81b4bdc514b14360352dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/samsung/exynos-chipid.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/soc/samsung/exynos-chipid.h>\n#include <linux/sys_soc.h>\n\n#include \"exynos-asv.h\"\n\nstruct exynos_chipid_variant {\n\tunsigned int rev_reg;\t\t \n\tunsigned int main_rev_shift;\t \n\tunsigned int sub_rev_shift;\t \n};\n\nstruct exynos_chipid_info {\n\tu32 product_id;\n\tu32 revision;\n};\n\nstatic const struct exynos_soc_id {\n\tconst char *name;\n\tunsigned int id;\n} soc_ids[] = {\n\t \n\t \n\t{ \"EXYNOS3250\", 0xE3472000 },\n\t{ \"EXYNOS4210\", 0x43200000 },\t \n\t{ \"EXYNOS4210\", 0x43210000 },\n\t{ \"EXYNOS4212\", 0x43220000 },\n\t{ \"EXYNOS4412\", 0xE4412000 },\n\t{ \"EXYNOS5250\", 0x43520000 },\n\t{ \"EXYNOS5260\", 0xE5260000 },\n\t{ \"EXYNOS5410\", 0xE5410000 },\n\t{ \"EXYNOS5420\", 0xE5420000 },\n\t{ \"EXYNOS5433\", 0xE5433000 },\n\t{ \"EXYNOS5440\", 0xE5440000 },\n\t{ \"EXYNOS5800\", 0xE5422000 },\n\t{ \"EXYNOS7420\", 0xE7420000 },\n\t \n\t{ \"EXYNOS7885\", 0xE7885000 },\n\t{ \"EXYNOS850\", 0xE3830000 },\n\t{ \"EXYNOSAUTOV9\", 0xAAA80000 },\n};\n\nstatic const char *product_id_to_soc_id(unsigned int product_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(soc_ids); i++)\n\t\tif (product_id == soc_ids[i].id)\n\t\t\treturn soc_ids[i].name;\n\treturn NULL;\n}\n\nstatic int exynos_chipid_get_chipid_info(struct regmap *regmap,\n\t\tconst struct exynos_chipid_variant *data,\n\t\tstruct exynos_chipid_info *soc_info)\n{\n\tint ret;\n\tunsigned int val, main_rev, sub_rev;\n\n\tret = regmap_read(regmap, EXYNOS_CHIPID_REG_PRO_ID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tsoc_info->product_id = val & EXYNOS_MASK;\n\n\tif (data->rev_reg != EXYNOS_CHIPID_REG_PRO_ID) {\n\t\tret = regmap_read(regmap, data->rev_reg, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tmain_rev = (val >> data->main_rev_shift) & EXYNOS_REV_PART_MASK;\n\tsub_rev = (val >> data->sub_rev_shift) & EXYNOS_REV_PART_MASK;\n\tsoc_info->revision = (main_rev << EXYNOS_REV_PART_SHIFT) | sub_rev;\n\n\treturn 0;\n}\n\nstatic int exynos_chipid_probe(struct platform_device *pdev)\n{\n\tconst struct exynos_chipid_variant *drv_data;\n\tstruct exynos_chipid_info soc_info;\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct soc_device *soc_dev;\n\tstruct device_node *root;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdrv_data = of_device_get_match_data(&pdev->dev);\n\tif (!drv_data)\n\t\treturn -EINVAL;\n\n\tregmap = device_node_to_regmap(pdev->dev.of_node);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = exynos_chipid_get_chipid_info(regmap, drv_data, &soc_info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsoc_dev_attr = devm_kzalloc(&pdev->dev, sizeof(*soc_dev_attr),\n\t\t\t\t    GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENOMEM;\n\n\tsoc_dev_attr->family = \"Samsung Exynos\";\n\n\troot = of_find_node_by_path(\"/\");\n\tof_property_read_string(root, \"model\", &soc_dev_attr->machine);\n\tof_node_put(root);\n\n\tsoc_dev_attr->revision = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"%x\", soc_info.revision);\n\tsoc_dev_attr->soc_id = product_id_to_soc_id(soc_info.product_id);\n\tif (!soc_dev_attr->soc_id) {\n\t\tpr_err(\"Unknown SoC\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev))\n\t\treturn PTR_ERR(soc_dev);\n\n\tret = exynos_asv_init(&pdev->dev, regmap);\n\tif (ret)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, soc_dev);\n\n\tdev_info(&pdev->dev, \"Exynos: CPU[%s] PRO_ID[0x%x] REV[0x%x] Detected\\n\",\n\t\t soc_dev_attr->soc_id, soc_info.product_id, soc_info.revision);\n\n\treturn 0;\n\nerr:\n\tsoc_device_unregister(soc_dev);\n\n\treturn ret;\n}\n\nstatic int exynos_chipid_remove(struct platform_device *pdev)\n{\n\tstruct soc_device *soc_dev = platform_get_drvdata(pdev);\n\n\tsoc_device_unregister(soc_dev);\n\n\treturn 0;\n}\n\nstatic const struct exynos_chipid_variant exynos4210_chipid_drv_data = {\n\t.rev_reg\t= 0x0,\n\t.main_rev_shift\t= 4,\n\t.sub_rev_shift\t= 0,\n};\n\nstatic const struct exynos_chipid_variant exynos850_chipid_drv_data = {\n\t.rev_reg\t= 0x10,\n\t.main_rev_shift\t= 20,\n\t.sub_rev_shift\t= 16,\n};\n\nstatic const struct of_device_id exynos_chipid_of_device_ids[] = {\n\t{\n\t\t.compatible\t= \"samsung,exynos4210-chipid\",\n\t\t.data\t\t= &exynos4210_chipid_drv_data,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos850-chipid\",\n\t\t.data\t\t= &exynos850_chipid_drv_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, exynos_chipid_of_device_ids);\n\nstatic struct platform_driver exynos_chipid_driver = {\n\t.driver = {\n\t\t.name = \"exynos-chipid\",\n\t\t.of_match_table = exynos_chipid_of_device_ids,\n\t},\n\t.probe\t= exynos_chipid_probe,\n\t.remove\t= exynos_chipid_remove,\n};\nmodule_platform_driver(exynos_chipid_driver);\n\nMODULE_DESCRIPTION(\"Samsung Exynos ChipID controller and ASV driver\");\nMODULE_AUTHOR(\"Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>\");\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_AUTHOR(\"Pankaj Dubey <pankaj.dubey@samsung.com>\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}