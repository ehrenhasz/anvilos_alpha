{
  "module_name": "exynos-pmu.c",
  "hash_id": "4566f232553e942c6c1f6b5ce8351610f781aefc6e6aee8f1d6ae75f6fe4d5d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/samsung/exynos-pmu.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n\n#include <linux/soc/samsung/exynos-regs-pmu.h>\n#include <linux/soc/samsung/exynos-pmu.h>\n\n#include \"exynos-pmu.h\"\n\nstruct exynos_pmu_context {\n\tstruct device *dev;\n\tconst struct exynos_pmu_data *pmu_data;\n};\n\nvoid __iomem *pmu_base_addr;\nstatic struct exynos_pmu_context *pmu_context;\n\nvoid pmu_raw_writel(u32 val, u32 offset)\n{\n\twritel_relaxed(val, pmu_base_addr + offset);\n}\n\nu32 pmu_raw_readl(u32 offset)\n{\n\treturn readl_relaxed(pmu_base_addr + offset);\n}\n\nvoid exynos_sys_powerdown_conf(enum sys_powerdown mode)\n{\n\tunsigned int i;\n\tconst struct exynos_pmu_data *pmu_data;\n\n\tif (!pmu_context || !pmu_context->pmu_data)\n\t\treturn;\n\n\tpmu_data = pmu_context->pmu_data;\n\n\tif (pmu_data->powerdown_conf)\n\t\tpmu_data->powerdown_conf(mode);\n\n\tif (pmu_data->pmu_config) {\n\t\tfor (i = 0; (pmu_data->pmu_config[i].offset != PMU_TABLE_END); i++)\n\t\t\tpmu_raw_writel(pmu_data->pmu_config[i].val[mode],\n\t\t\t\t\tpmu_data->pmu_config[i].offset);\n\t}\n\n\tif (pmu_data->powerdown_conf_extra)\n\t\tpmu_data->powerdown_conf_extra(mode);\n\n\tif (pmu_data->pmu_config_extra) {\n\t\tfor (i = 0; pmu_data->pmu_config_extra[i].offset != PMU_TABLE_END; i++)\n\t\t\tpmu_raw_writel(pmu_data->pmu_config_extra[i].val[mode],\n\t\t\t\t       pmu_data->pmu_config_extra[i].offset);\n\t}\n}\n\n \n#ifdef CONFIG_EXYNOS_PMU_ARM_DRIVERS\n#define exynos_pmu_data_arm_ptr(data)\t(&data)\n#else\n#define exynos_pmu_data_arm_ptr(data)\tNULL\n#endif\n\n \nstatic const struct of_device_id exynos_pmu_of_device_ids[] = {\n\t{\n\t\t.compatible = \"samsung,exynos3250-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos3250_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos4210_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos4212_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos4412-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos4412_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos5250_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos5410-pmu\",\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-pmu\",\n\t\t.data = exynos_pmu_data_arm_ptr(exynos5420_pmu_data),\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-pmu\",\n\t}, {\n\t\t.compatible = \"samsung,exynos7-pmu\",\n\t}, {\n\t\t.compatible = \"samsung,exynos850-pmu\",\n\t},\n\t{   },\n};\n\nstatic const struct mfd_cell exynos_pmu_devs[] = {\n\t{ .name = \"exynos-clkout\", },\n};\n\nstruct regmap *exynos_get_pmu_regmap(void)\n{\n\tstruct device_node *np = of_find_matching_node(NULL,\n\t\t\t\t\t\t      exynos_pmu_of_device_ids);\n\tif (np)\n\t\treturn syscon_node_to_regmap(np);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL_GPL(exynos_get_pmu_regmap);\n\nstatic int exynos_pmu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpmu_base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pmu_base_addr))\n\t\treturn PTR_ERR(pmu_base_addr);\n\n\tpmu_context = devm_kzalloc(&pdev->dev,\n\t\t\tsizeof(struct exynos_pmu_context),\n\t\t\tGFP_KERNEL);\n\tif (!pmu_context)\n\t\treturn -ENOMEM;\n\tpmu_context->dev = dev;\n\tpmu_context->pmu_data = of_device_get_match_data(dev);\n\n\tif (pmu_context->pmu_data && pmu_context->pmu_data->pmu_init)\n\t\tpmu_context->pmu_data->pmu_init();\n\n\tplatform_set_drvdata(pdev, pmu_context);\n\n\tret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE, exynos_pmu_devs,\n\t\t\t\t   ARRAY_SIZE(exynos_pmu_devs), NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (devm_of_platform_populate(dev))\n\t\tdev_err(dev, \"Error populating children, reboot and poweroff might not work properly\\n\");\n\n\tdev_dbg(dev, \"Exynos PMU Driver probe done\\n\");\n\treturn 0;\n}\n\nstatic struct platform_driver exynos_pmu_driver = {\n\t.driver  = {\n\t\t.name   = \"exynos-pmu\",\n\t\t.of_match_table = exynos_pmu_of_device_ids,\n\t},\n\t.probe = exynos_pmu_probe,\n};\n\nstatic int __init exynos_pmu_init(void)\n{\n\treturn platform_driver_register(&exynos_pmu_driver);\n\n}\npostcore_initcall(exynos_pmu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}