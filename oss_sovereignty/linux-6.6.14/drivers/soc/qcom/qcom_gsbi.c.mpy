{
  "module_name": "qcom_gsbi.c",
  "hash_id": "da20010e05676cd2d14855fcea23baa3ba3789eb7b46a1ab931dd0d0270ad73f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qcom_gsbi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <dt-bindings/soc/qcom,gsbi.h>\n\n#define GSBI_CTRL_REG\t\t0x0000\n#define GSBI_PROTOCOL_SHIFT\t4\n#define MAX_GSBI\t\t12\n\n#define TCSR_ADM_CRCI_BASE\t0x70\n\nstruct crci_config {\n\tu32 num_rows;\n\tconst u32 (*array)[MAX_GSBI];\n};\n\nstatic const u32 crci_ipq8064[][MAX_GSBI] = {\n\t{\n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n\t{\n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n};\n\nstatic const struct crci_config config_ipq8064 = {\n\t.num_rows = ARRAY_SIZE(crci_ipq8064),\n\t.array = crci_ipq8064,\n};\n\nstatic const unsigned int crci_apq8064[][MAX_GSBI] = {\n\t{\n\t\t0x001800, 0x006000, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000400, 0x000000, 0x000000,\n\t\t0x000000, 0x000000, 0x000000, 0x000000\n\t},\n\t{\n\t\t0x000000, 0x000000, 0x000000, 0x000000,\n\t\t0x000000, 0x000020, 0x0000c0, 0x000000,\n\t\t0x000000, 0x000000, 0x000000, 0x000000\n\t},\n};\n\nstatic const struct crci_config config_apq8064 = {\n\t.num_rows = ARRAY_SIZE(crci_apq8064),\n\t.array = crci_apq8064,\n};\n\nstatic const unsigned int crci_msm8960[][MAX_GSBI] = {\n\t{\n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000400, 0x000000, 0x000000,\n\t\t0x000000, 0x000000, 0x000000, 0x000000\n\t},\n\t{\n\t\t0x000000, 0x000000, 0x000000, 0x000000,\n\t\t0x000000, 0x000020, 0x0000c0, 0x000300,\n\t\t0x001800, 0x006000, 0x000000, 0x000000\n\t},\n};\n\nstatic const struct crci_config config_msm8960 = {\n\t.num_rows = ARRAY_SIZE(crci_msm8960),\n\t.array = crci_msm8960,\n};\n\nstatic const unsigned int crci_msm8660[][MAX_GSBI] = {\n\t{\t \n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n\t{\t \n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n\t{\t \n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n\t{\t \n\t\t0x000003, 0x00000c, 0x000030, 0x0000c0,\n\t\t0x000300, 0x000c00, 0x003000, 0x00c000,\n\t\t0x030000, 0x0c0000, 0x300000, 0xc00000\n\t},\n};\n\nstatic const struct crci_config config_msm8660 = {\n\t.num_rows = ARRAY_SIZE(crci_msm8660),\n\t.array = crci_msm8660,\n};\n\nstruct gsbi_info {\n\tstruct clk *hclk;\n\tu32 mode;\n\tu32 crci;\n\tstruct regmap *tcsr;\n};\n\nstatic const struct of_device_id tcsr_dt_match[] __maybe_unused = {\n\t{ .compatible = \"qcom,tcsr-ipq8064\", .data = &config_ipq8064},\n\t{ .compatible = \"qcom,tcsr-apq8064\", .data = &config_apq8064},\n\t{ .compatible = \"qcom,tcsr-msm8960\", .data = &config_msm8960},\n\t{ .compatible = \"qcom,tcsr-msm8660\", .data = &config_msm8660},\n\t{ },\n};\n\nstatic int gsbi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *tcsr_node;\n\tconst struct of_device_id *match;\n\tvoid __iomem *base;\n\tstruct gsbi_info *gsbi;\n\tint i;\n\tu32 mask, gsbi_num;\n\tconst struct crci_config *config = NULL;\n\n\tgsbi = devm_kzalloc(&pdev->dev, sizeof(*gsbi), GFP_KERNEL);\n\n\tif (!gsbi)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tgsbi->tcsr = syscon_regmap_lookup_by_phandle(node, \"syscon-tcsr\");\n\n\tif (!IS_ERR(gsbi->tcsr)) {\n\t\ttcsr_node = of_parse_phandle(node, \"syscon-tcsr\", 0);\n\t\tif (tcsr_node) {\n\t\t\tmatch = of_match_node(tcsr_dt_match, tcsr_node);\n\t\t\tif (match)\n\t\t\t\tconfig = match->data;\n\t\t\telse\n\t\t\t\tdev_warn(&pdev->dev, \"no matching TCSR\\n\");\n\n\t\t\tof_node_put(tcsr_node);\n\t\t}\n\t}\n\n\tif (of_property_read_u32(node, \"cell-index\", &gsbi_num)) {\n\t\tdev_err(&pdev->dev, \"missing cell-index\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gsbi_num < 1 || gsbi_num > MAX_GSBI) {\n\t\tdev_err(&pdev->dev, \"invalid cell-index\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(node, \"qcom,mode\", &gsbi->mode)) {\n\t\tdev_err(&pdev->dev, \"missing mode configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tof_property_read_u32(node, \"qcom,crci\", &gsbi->crci);\n\n\tdev_info(&pdev->dev, \"GSBI port protocol: %d crci: %d\\n\",\n\t\t gsbi->mode, gsbi->crci);\n\tgsbi->hclk = devm_clk_get_enabled(&pdev->dev, \"iface\");\n\tif (IS_ERR(gsbi->hclk))\n\t\treturn PTR_ERR(gsbi->hclk);\n\n\twritel_relaxed((gsbi->mode << GSBI_PROTOCOL_SHIFT) | gsbi->crci,\n\t\t\t\tbase + GSBI_CTRL_REG);\n\n\t \n\tif (config) {\n\t\tfor (i = 0; i < config->num_rows; i++) {\n\t\t\tmask = config->array[i][gsbi_num - 1];\n\n\t\t\tif (gsbi->mode == GSBI_PROT_SPI)\n\t\t\t\tregmap_update_bits(gsbi->tcsr,\n\t\t\t\t\tTCSR_ADM_CRCI_BASE + 4 * i, mask, 0);\n\t\t\telse\n\t\t\t\tregmap_update_bits(gsbi->tcsr,\n\t\t\t\t\tTCSR_ADM_CRCI_BASE + 4 * i, mask, mask);\n\n\t\t}\n\t}\n\n\t \n\twmb();\n\n\tplatform_set_drvdata(pdev, gsbi);\n\n\treturn of_platform_populate(node, NULL, NULL, &pdev->dev);\n}\n\nstatic int gsbi_remove(struct platform_device *pdev)\n{\n\tstruct gsbi_info *gsbi = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(gsbi->hclk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id gsbi_dt_match[] = {\n\t{ .compatible = \"qcom,gsbi-v1.0.0\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, gsbi_dt_match);\n\nstatic struct platform_driver gsbi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"gsbi\",\n\t\t.of_match_table\t= gsbi_dt_match,\n\t},\n\t.probe = gsbi_probe,\n\t.remove\t= gsbi_remove,\n};\n\nmodule_platform_driver(gsbi_driver);\n\nMODULE_AUTHOR(\"Andy Gross <agross@codeaurora.org>\");\nMODULE_DESCRIPTION(\"QCOM GSBI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}