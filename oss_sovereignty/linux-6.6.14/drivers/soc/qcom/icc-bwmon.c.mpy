{
  "module_name": "icc-bwmon.c",
  "hash_id": "f81228326fd7bd905769a780bec725ed9afb9a5a3a0ccf67daa5b641de7b6044",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/icc-bwmon.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interconnect.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n\n \n\n \n#define HW_TIMER_HZ\t\t\t\t19200000\n\n#define BWMON_V4_GLOBAL_IRQ_CLEAR\t\t0x108\n#define BWMON_V4_GLOBAL_IRQ_ENABLE\t\t0x10c\n \n#define BWMON_V4_GLOBAL_IRQ_ENABLE_ENABLE\tBIT(0)\n\n \n#define BWMON_V4_845_OFFSET\t\t\t0x100\n#define BWMON_V4_GLOBAL_IRQ_CLEAR_845\t\t(BWMON_V4_GLOBAL_IRQ_CLEAR - BWMON_V4_845_OFFSET)\n#define BWMON_V4_GLOBAL_IRQ_ENABLE_845\t\t(BWMON_V4_GLOBAL_IRQ_ENABLE - BWMON_V4_845_OFFSET)\n\n#define BWMON_V4_IRQ_STATUS\t\t\t0x100\n#define BWMON_V4_IRQ_CLEAR\t\t\t0x108\n\n#define BWMON_V4_IRQ_ENABLE\t\t\t0x10c\n#define BWMON_IRQ_ENABLE_MASK\t\t\t(BIT(1) | BIT(3))\n#define BWMON_V5_IRQ_STATUS\t\t\t0x000\n#define BWMON_V5_IRQ_CLEAR\t\t\t0x008\n#define BWMON_V5_IRQ_ENABLE\t\t\t0x00c\n\n#define BWMON_V4_ENABLE\t\t\t\t0x2a0\n#define BWMON_V5_ENABLE\t\t\t\t0x010\n#define BWMON_ENABLE_ENABLE\t\t\tBIT(0)\n\n#define BWMON_V4_CLEAR\t\t\t\t0x2a4\n#define BWMON_V5_CLEAR\t\t\t\t0x014\n#define BWMON_CLEAR_CLEAR\t\t\tBIT(0)\n#define BWMON_CLEAR_CLEAR_ALL\t\t\tBIT(1)\n\n#define BWMON_V4_SAMPLE_WINDOW\t\t\t0x2a8\n#define BWMON_V5_SAMPLE_WINDOW\t\t\t0x020\n\n#define BWMON_V4_THRESHOLD_HIGH\t\t\t0x2ac\n#define BWMON_V4_THRESHOLD_MED\t\t\t0x2b0\n#define BWMON_V4_THRESHOLD_LOW\t\t\t0x2b4\n#define BWMON_V5_THRESHOLD_HIGH\t\t\t0x024\n#define BWMON_V5_THRESHOLD_MED\t\t\t0x028\n#define BWMON_V5_THRESHOLD_LOW\t\t\t0x02c\n\n#define BWMON_V4_ZONE_ACTIONS\t\t\t0x2b8\n#define BWMON_V5_ZONE_ACTIONS\t\t\t0x030\n \n#define BWMON_ZONE_ACTIONS_INCREMENT(z)\t\t(0x2 << ((z) * 2))\n \n#define BWMON_ZONE_ACTIONS_CLEAR(z)\t\t(0x1 << ((z) * 2))\n\n \n#define BWMON_ZONE_ACTIONS_ZONE0\t\t(BWMON_ZONE_ACTIONS_CLEAR(0))\n\n \n#define BWMON_ZONE_ACTIONS_ZONE1\t\t(BWMON_ZONE_ACTIONS_INCREMENT(1) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(0))\n\n \n#define BWMON_ZONE_ACTIONS_ZONE2\t\t(BWMON_ZONE_ACTIONS_INCREMENT(2) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(1) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(0))\n\n \n#define BWMON_ZONE_ACTIONS_ZONE3\t\t(BWMON_ZONE_ACTIONS_INCREMENT(3) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(2) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(1) | \\\n\t\t\t\t\t\t BWMON_ZONE_ACTIONS_CLEAR(0))\n\n \n#define BWMON_V4_THRESHOLD_COUNT\t\t0x2bc\n#define BWMON_V5_THRESHOLD_COUNT\t\t0x034\n#define BWMON_THRESHOLD_COUNT_ZONE0_DEFAULT\t0xff\n#define BWMON_THRESHOLD_COUNT_ZONE2_DEFAULT\t0xff\n\n#define BWMON_V4_ZONE_MAX(zone)\t\t\t(0x2e0 + 4 * (zone))\n#define BWMON_V5_ZONE_MAX(zone)\t\t\t(0x044 + 4 * (zone))\n\n \n#define BWMON_HAS_GLOBAL_IRQ\t\t\tBIT(0)\n#define BWMON_NEEDS_FORCE_CLEAR\t\t\tBIT(1)\n\nenum bwmon_fields {\n\t \n\tF_GLOBAL_IRQ_CLEAR,\n\tF_GLOBAL_IRQ_ENABLE,\n\tF_NUM_GLOBAL_FIELDS,\n\n\t \n\tF_IRQ_STATUS = F_NUM_GLOBAL_FIELDS,\n\tF_IRQ_CLEAR,\n\tF_IRQ_ENABLE,\n\tF_ENABLE,\n\tF_CLEAR,\n\tF_SAMPLE_WINDOW,\n\tF_THRESHOLD_HIGH,\n\tF_THRESHOLD_MED,\n\tF_THRESHOLD_LOW,\n\tF_ZONE_ACTIONS_ZONE0,\n\tF_ZONE_ACTIONS_ZONE1,\n\tF_ZONE_ACTIONS_ZONE2,\n\tF_ZONE_ACTIONS_ZONE3,\n\tF_THRESHOLD_COUNT_ZONE0,\n\tF_THRESHOLD_COUNT_ZONE1,\n\tF_THRESHOLD_COUNT_ZONE2,\n\tF_THRESHOLD_COUNT_ZONE3,\n\tF_ZONE0_MAX,\n\tF_ZONE1_MAX,\n\tF_ZONE2_MAX,\n\tF_ZONE3_MAX,\n\n\tF_NUM_FIELDS\n};\n\nstruct icc_bwmon_data {\n\tunsigned int sample_ms;\n\tunsigned int count_unit_kb;  \n\tu8 zone1_thres_count;\n\tu8 zone3_thres_count;\n\tunsigned int quirks;\n\n\tconst struct regmap_config *regmap_cfg;\n\tconst struct reg_field *regmap_fields;\n\n\tconst struct regmap_config *global_regmap_cfg;\n\tconst struct reg_field *global_regmap_fields;\n};\n\nstruct icc_bwmon {\n\tstruct device *dev;\n\tconst struct icc_bwmon_data *data;\n\tint irq;\n\n\tstruct regmap_field *regs[F_NUM_FIELDS];\n\tstruct regmap_field *global_regs[F_NUM_GLOBAL_FIELDS];\n\n\tunsigned int max_bw_kbps;\n\tunsigned int min_bw_kbps;\n\tunsigned int target_kbps;\n\tunsigned int current_kbps;\n};\n\n \nstatic const struct reg_field msm8998_bwmon_reg_fields[] = {\n\t[F_GLOBAL_IRQ_CLEAR]\t= {},\n\t[F_GLOBAL_IRQ_ENABLE]\t= {},\n\t[F_IRQ_STATUS]\t\t= REG_FIELD(BWMON_V4_IRQ_STATUS, 4, 7),\n\t[F_IRQ_CLEAR]\t\t= REG_FIELD(BWMON_V4_IRQ_CLEAR, 4, 7),\n\t[F_IRQ_ENABLE]\t\t= REG_FIELD(BWMON_V4_IRQ_ENABLE, 4, 7),\n\t \n\t[F_ENABLE]\t\t= REG_FIELD(BWMON_V4_ENABLE, 0, 31),\n\t[F_CLEAR]\t\t= REG_FIELD(BWMON_V4_CLEAR, 0, 1),\n\t[F_SAMPLE_WINDOW]\t= REG_FIELD(BWMON_V4_SAMPLE_WINDOW, 0, 23),\n\t[F_THRESHOLD_HIGH]\t= REG_FIELD(BWMON_V4_THRESHOLD_HIGH, 0, 11),\n\t[F_THRESHOLD_MED]\t= REG_FIELD(BWMON_V4_THRESHOLD_MED, 0, 11),\n\t[F_THRESHOLD_LOW]\t= REG_FIELD(BWMON_V4_THRESHOLD_LOW, 0, 11),\n\t[F_ZONE_ACTIONS_ZONE0]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 0, 7),\n\t[F_ZONE_ACTIONS_ZONE1]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 8, 15),\n\t[F_ZONE_ACTIONS_ZONE2]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 16, 23),\n\t[F_ZONE_ACTIONS_ZONE3]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 24, 31),\n\t[F_THRESHOLD_COUNT_ZONE0]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 0, 7),\n\t[F_THRESHOLD_COUNT_ZONE1]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 8, 15),\n\t[F_THRESHOLD_COUNT_ZONE2]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 16, 23),\n\t[F_THRESHOLD_COUNT_ZONE3]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 24, 31),\n\t[F_ZONE0_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(0), 0, 11),\n\t[F_ZONE1_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(1), 0, 11),\n\t[F_ZONE2_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(2), 0, 11),\n\t[F_ZONE3_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(3), 0, 11),\n};\n\nstatic const struct regmap_range msm8998_bwmon_reg_noread_ranges[] = {\n\tregmap_reg_range(BWMON_V4_IRQ_CLEAR, BWMON_V4_IRQ_CLEAR),\n\tregmap_reg_range(BWMON_V4_CLEAR, BWMON_V4_CLEAR),\n};\n\nstatic const struct regmap_access_table msm8998_bwmon_reg_read_table = {\n\t.no_ranges\t= msm8998_bwmon_reg_noread_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(msm8998_bwmon_reg_noread_ranges),\n};\n\nstatic const struct regmap_range msm8998_bwmon_reg_volatile_ranges[] = {\n\tregmap_reg_range(BWMON_V4_IRQ_STATUS, BWMON_V4_IRQ_STATUS),\n\tregmap_reg_range(BWMON_V4_ZONE_MAX(0), BWMON_V4_ZONE_MAX(3)),\n};\n\nstatic const struct regmap_access_table msm8998_bwmon_reg_volatile_table = {\n\t.yes_ranges\t= msm8998_bwmon_reg_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(msm8998_bwmon_reg_volatile_ranges),\n};\n\nstatic const struct reg_field msm8998_bwmon_global_reg_fields[] = {\n\t[F_GLOBAL_IRQ_CLEAR]\t= REG_FIELD(BWMON_V4_GLOBAL_IRQ_CLEAR, 0, 0),\n\t[F_GLOBAL_IRQ_ENABLE]\t= REG_FIELD(BWMON_V4_GLOBAL_IRQ_ENABLE, 0, 0),\n};\n\nstatic const struct regmap_range msm8998_bwmon_global_reg_noread_ranges[] = {\n\tregmap_reg_range(BWMON_V4_GLOBAL_IRQ_CLEAR, BWMON_V4_GLOBAL_IRQ_CLEAR),\n};\n\nstatic const struct regmap_access_table msm8998_bwmon_global_reg_read_table = {\n\t.no_ranges\t= msm8998_bwmon_global_reg_noread_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(msm8998_bwmon_global_reg_noread_ranges),\n};\n\n \nstatic const struct reg_default msm8998_bwmon_reg_defaults[] = {\n\t{ BWMON_V4_IRQ_CLEAR, 0x0 },\n\t{ BWMON_V4_CLEAR, 0x0 },\n};\n\nstatic const struct reg_default msm8998_bwmon_global_reg_defaults[] = {\n\t{ BWMON_V4_GLOBAL_IRQ_CLEAR, 0x0 },\n};\n\nstatic const struct regmap_config msm8998_bwmon_regmap_cfg = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t \n\t.disable_locking\t= true,\n\t.rd_table\t\t= &msm8998_bwmon_reg_read_table,\n\t.volatile_table\t\t= &msm8998_bwmon_reg_volatile_table,\n\t.reg_defaults\t\t= msm8998_bwmon_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(msm8998_bwmon_reg_defaults),\n\t \n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_config msm8998_bwmon_global_regmap_cfg = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t \n\t.disable_locking\t= true,\n\t.rd_table\t\t= &msm8998_bwmon_global_reg_read_table,\n\t.reg_defaults\t\t= msm8998_bwmon_global_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(msm8998_bwmon_global_reg_defaults),\n\t \n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct reg_field sdm845_cpu_bwmon_reg_fields[] = {\n\t[F_GLOBAL_IRQ_CLEAR]\t= REG_FIELD(BWMON_V4_GLOBAL_IRQ_CLEAR_845, 0, 0),\n\t[F_GLOBAL_IRQ_ENABLE]\t= REG_FIELD(BWMON_V4_GLOBAL_IRQ_ENABLE_845, 0, 0),\n\t[F_IRQ_STATUS]\t\t= REG_FIELD(BWMON_V4_IRQ_STATUS, 4, 7),\n\t[F_IRQ_CLEAR]\t\t= REG_FIELD(BWMON_V4_IRQ_CLEAR, 4, 7),\n\t[F_IRQ_ENABLE]\t\t= REG_FIELD(BWMON_V4_IRQ_ENABLE, 4, 7),\n\t \n\t[F_ENABLE]\t\t= REG_FIELD(BWMON_V4_ENABLE, 0, 31),\n\t[F_CLEAR]\t\t= REG_FIELD(BWMON_V4_CLEAR, 0, 1),\n\t[F_SAMPLE_WINDOW]\t= REG_FIELD(BWMON_V4_SAMPLE_WINDOW, 0, 23),\n\t[F_THRESHOLD_HIGH]\t= REG_FIELD(BWMON_V4_THRESHOLD_HIGH, 0, 11),\n\t[F_THRESHOLD_MED]\t= REG_FIELD(BWMON_V4_THRESHOLD_MED, 0, 11),\n\t[F_THRESHOLD_LOW]\t= REG_FIELD(BWMON_V4_THRESHOLD_LOW, 0, 11),\n\t[F_ZONE_ACTIONS_ZONE0]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 0, 7),\n\t[F_ZONE_ACTIONS_ZONE1]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 8, 15),\n\t[F_ZONE_ACTIONS_ZONE2]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 16, 23),\n\t[F_ZONE_ACTIONS_ZONE3]\t= REG_FIELD(BWMON_V4_ZONE_ACTIONS, 24, 31),\n\t[F_THRESHOLD_COUNT_ZONE0]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 0, 7),\n\t[F_THRESHOLD_COUNT_ZONE1]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 8, 15),\n\t[F_THRESHOLD_COUNT_ZONE2]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 16, 23),\n\t[F_THRESHOLD_COUNT_ZONE3]\t= REG_FIELD(BWMON_V4_THRESHOLD_COUNT, 24, 31),\n\t[F_ZONE0_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(0), 0, 11),\n\t[F_ZONE1_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(1), 0, 11),\n\t[F_ZONE2_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(2), 0, 11),\n\t[F_ZONE3_MAX]\t\t= REG_FIELD(BWMON_V4_ZONE_MAX(3), 0, 11),\n};\n\nstatic const struct regmap_range sdm845_cpu_bwmon_reg_noread_ranges[] = {\n\tregmap_reg_range(BWMON_V4_GLOBAL_IRQ_CLEAR_845, BWMON_V4_GLOBAL_IRQ_CLEAR_845),\n\tregmap_reg_range(BWMON_V4_IRQ_CLEAR, BWMON_V4_IRQ_CLEAR),\n\tregmap_reg_range(BWMON_V4_CLEAR, BWMON_V4_CLEAR),\n};\n\nstatic const struct regmap_access_table sdm845_cpu_bwmon_reg_read_table = {\n\t.no_ranges\t= sdm845_cpu_bwmon_reg_noread_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(sdm845_cpu_bwmon_reg_noread_ranges),\n};\n\n \nstatic const struct reg_default sdm845_cpu_bwmon_reg_defaults[] = {\n\t{ BWMON_V4_GLOBAL_IRQ_CLEAR_845, 0x0 },\n\t{ BWMON_V4_IRQ_CLEAR, 0x0 },\n\t{ BWMON_V4_CLEAR, 0x0 },\n};\n\nstatic const struct regmap_config sdm845_cpu_bwmon_regmap_cfg = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t \n\t.disable_locking\t= true,\n\t.rd_table\t\t= &sdm845_cpu_bwmon_reg_read_table,\n\t.volatile_table\t\t= &msm8998_bwmon_reg_volatile_table,\n\t.reg_defaults\t\t= sdm845_cpu_bwmon_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(sdm845_cpu_bwmon_reg_defaults),\n\t \n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\n \nstatic const struct reg_field sdm845_llcc_bwmon_reg_fields[] = {\n\t[F_GLOBAL_IRQ_CLEAR]\t= {},\n\t[F_GLOBAL_IRQ_ENABLE]\t= {},\n\t[F_IRQ_STATUS]\t\t= REG_FIELD(BWMON_V5_IRQ_STATUS, 0, 3),\n\t[F_IRQ_CLEAR]\t\t= REG_FIELD(BWMON_V5_IRQ_CLEAR, 0, 3),\n\t[F_IRQ_ENABLE]\t\t= REG_FIELD(BWMON_V5_IRQ_ENABLE, 0, 3),\n\t \n\t[F_ENABLE]\t\t= REG_FIELD(BWMON_V5_ENABLE, 0, 31),\n\t[F_CLEAR]\t\t= REG_FIELD(BWMON_V5_CLEAR, 0, 1),\n\t[F_SAMPLE_WINDOW]\t= REG_FIELD(BWMON_V5_SAMPLE_WINDOW, 0, 19),\n\t[F_THRESHOLD_HIGH]\t= REG_FIELD(BWMON_V5_THRESHOLD_HIGH, 0, 11),\n\t[F_THRESHOLD_MED]\t= REG_FIELD(BWMON_V5_THRESHOLD_MED, 0, 11),\n\t[F_THRESHOLD_LOW]\t= REG_FIELD(BWMON_V5_THRESHOLD_LOW, 0, 11),\n\t[F_ZONE_ACTIONS_ZONE0]\t= REG_FIELD(BWMON_V5_ZONE_ACTIONS, 0, 7),\n\t[F_ZONE_ACTIONS_ZONE1]\t= REG_FIELD(BWMON_V5_ZONE_ACTIONS, 8, 15),\n\t[F_ZONE_ACTIONS_ZONE2]\t= REG_FIELD(BWMON_V5_ZONE_ACTIONS, 16, 23),\n\t[F_ZONE_ACTIONS_ZONE3]\t= REG_FIELD(BWMON_V5_ZONE_ACTIONS, 24, 31),\n\t[F_THRESHOLD_COUNT_ZONE0]\t= REG_FIELD(BWMON_V5_THRESHOLD_COUNT, 0, 7),\n\t[F_THRESHOLD_COUNT_ZONE1]\t= REG_FIELD(BWMON_V5_THRESHOLD_COUNT, 8, 15),\n\t[F_THRESHOLD_COUNT_ZONE2]\t= REG_FIELD(BWMON_V5_THRESHOLD_COUNT, 16, 23),\n\t[F_THRESHOLD_COUNT_ZONE3]\t= REG_FIELD(BWMON_V5_THRESHOLD_COUNT, 24, 31),\n\t[F_ZONE0_MAX]\t\t= REG_FIELD(BWMON_V5_ZONE_MAX(0), 0, 11),\n\t[F_ZONE1_MAX]\t\t= REG_FIELD(BWMON_V5_ZONE_MAX(1), 0, 11),\n\t[F_ZONE2_MAX]\t\t= REG_FIELD(BWMON_V5_ZONE_MAX(2), 0, 11),\n\t[F_ZONE3_MAX]\t\t= REG_FIELD(BWMON_V5_ZONE_MAX(3), 0, 11),\n};\n\nstatic const struct regmap_range sdm845_llcc_bwmon_reg_noread_ranges[] = {\n\tregmap_reg_range(BWMON_V5_IRQ_CLEAR, BWMON_V5_IRQ_CLEAR),\n\tregmap_reg_range(BWMON_V5_CLEAR, BWMON_V5_CLEAR),\n};\n\nstatic const struct regmap_access_table sdm845_llcc_bwmon_reg_read_table = {\n\t.no_ranges\t= sdm845_llcc_bwmon_reg_noread_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(sdm845_llcc_bwmon_reg_noread_ranges),\n};\n\nstatic const struct regmap_range sdm845_llcc_bwmon_reg_volatile_ranges[] = {\n\tregmap_reg_range(BWMON_V5_IRQ_STATUS, BWMON_V5_IRQ_STATUS),\n\tregmap_reg_range(BWMON_V5_ZONE_MAX(0), BWMON_V5_ZONE_MAX(3)),\n};\n\nstatic const struct regmap_access_table sdm845_llcc_bwmon_reg_volatile_table = {\n\t.yes_ranges\t= sdm845_llcc_bwmon_reg_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(sdm845_llcc_bwmon_reg_volatile_ranges),\n};\n\n \nstatic const struct reg_default sdm845_llcc_bwmon_reg_defaults[] = {\n\t{ BWMON_V5_IRQ_CLEAR, 0x0 },\n\t{ BWMON_V5_CLEAR, 0x0 },\n};\n\nstatic const struct regmap_config sdm845_llcc_bwmon_regmap_cfg = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t \n\t.disable_locking\t= true,\n\t.rd_table\t\t= &sdm845_llcc_bwmon_reg_read_table,\n\t.volatile_table\t\t= &sdm845_llcc_bwmon_reg_volatile_table,\n\t.reg_defaults\t\t= sdm845_llcc_bwmon_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(sdm845_llcc_bwmon_reg_defaults),\n\t \n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic void bwmon_clear_counters(struct icc_bwmon *bwmon, bool clear_all)\n{\n\tunsigned int val = BWMON_CLEAR_CLEAR;\n\n\tif (clear_all)\n\t\tval |= BWMON_CLEAR_CLEAR_ALL;\n\t \n\tregmap_field_force_write(bwmon->regs[F_CLEAR], val);\n\tif (bwmon->data->quirks & BWMON_NEEDS_FORCE_CLEAR)\n\t\tregmap_field_force_write(bwmon->regs[F_CLEAR], 0);\n}\n\nstatic void bwmon_clear_irq(struct icc_bwmon *bwmon)\n{\n\tstruct regmap_field *global_irq_clr;\n\n\tif (bwmon->data->global_regmap_fields)\n\t\tglobal_irq_clr = bwmon->global_regs[F_GLOBAL_IRQ_CLEAR];\n\telse\n\t\tglobal_irq_clr = bwmon->regs[F_GLOBAL_IRQ_CLEAR];\n\n\t \n\tregmap_field_force_write(bwmon->regs[F_IRQ_CLEAR], BWMON_IRQ_ENABLE_MASK);\n\tif (bwmon->data->quirks & BWMON_NEEDS_FORCE_CLEAR)\n\t\tregmap_field_force_write(bwmon->regs[F_IRQ_CLEAR], 0);\n\tif (bwmon->data->quirks & BWMON_HAS_GLOBAL_IRQ)\n\t\tregmap_field_force_write(global_irq_clr,\n\t\t\t\t\t BWMON_V4_GLOBAL_IRQ_ENABLE_ENABLE);\n}\n\nstatic void bwmon_disable(struct icc_bwmon *bwmon)\n{\n\tstruct regmap_field *global_irq_en;\n\n\tif (bwmon->data->global_regmap_fields)\n\t\tglobal_irq_en = bwmon->global_regs[F_GLOBAL_IRQ_ENABLE];\n\telse\n\t\tglobal_irq_en = bwmon->regs[F_GLOBAL_IRQ_ENABLE];\n\n\t \n\tif (bwmon->data->quirks & BWMON_HAS_GLOBAL_IRQ)\n\t\tregmap_field_write(global_irq_en, 0x0);\n\tregmap_field_write(bwmon->regs[F_IRQ_ENABLE], 0x0);\n\n\t \n\tregmap_field_write(bwmon->regs[F_ENABLE], 0x0);\n}\n\nstatic void bwmon_enable(struct icc_bwmon *bwmon, unsigned int irq_enable)\n{\n\tstruct regmap_field *global_irq_en;\n\n\tif (bwmon->data->global_regmap_fields)\n\t\tglobal_irq_en = bwmon->global_regs[F_GLOBAL_IRQ_ENABLE];\n\telse\n\t\tglobal_irq_en = bwmon->regs[F_GLOBAL_IRQ_ENABLE];\n\n\t \n\tif (bwmon->data->quirks & BWMON_HAS_GLOBAL_IRQ)\n\t\tregmap_field_write(global_irq_en,\n\t\t\t\t   BWMON_V4_GLOBAL_IRQ_ENABLE_ENABLE);\n\n\tregmap_field_write(bwmon->regs[F_IRQ_ENABLE], irq_enable);\n\n\t \n\tregmap_field_write(bwmon->regs[F_ENABLE], BWMON_ENABLE_ENABLE);\n}\n\nstatic unsigned int bwmon_kbps_to_count(struct icc_bwmon *bwmon,\n\t\t\t\t\tunsigned int kbps)\n{\n\treturn kbps / bwmon->data->count_unit_kb;\n}\n\nstatic void bwmon_set_threshold(struct icc_bwmon *bwmon,\n\t\t\t\tstruct regmap_field *reg, unsigned int kbps)\n{\n\tunsigned int thres;\n\n\tthres = mult_frac(bwmon_kbps_to_count(bwmon, kbps),\n\t\t\t  bwmon->data->sample_ms, MSEC_PER_SEC);\n\tregmap_field_write(reg, thres);\n}\n\nstatic void bwmon_start(struct icc_bwmon *bwmon)\n{\n\tconst struct icc_bwmon_data *data = bwmon->data;\n\tu32 bw_low = 0;\n\tint window;\n\n\t \n\tdev_pm_opp_find_bw_ceil(bwmon->dev, &bw_low, 0);\n\n\tbwmon_clear_counters(bwmon, true);\n\n\twindow = mult_frac(bwmon->data->sample_ms, HW_TIMER_HZ, MSEC_PER_SEC);\n\t \n\tregmap_field_write(bwmon->regs[F_SAMPLE_WINDOW], window);\n\n\tbwmon_set_threshold(bwmon, bwmon->regs[F_THRESHOLD_HIGH], bw_low);\n\tbwmon_set_threshold(bwmon, bwmon->regs[F_THRESHOLD_MED], bw_low);\n\tbwmon_set_threshold(bwmon, bwmon->regs[F_THRESHOLD_LOW], 0);\n\n\tregmap_field_write(bwmon->regs[F_THRESHOLD_COUNT_ZONE0],\n\t\t\t   BWMON_THRESHOLD_COUNT_ZONE0_DEFAULT);\n\tregmap_field_write(bwmon->regs[F_THRESHOLD_COUNT_ZONE1],\n\t\t\t   data->zone1_thres_count);\n\tregmap_field_write(bwmon->regs[F_THRESHOLD_COUNT_ZONE2],\n\t\t\t   BWMON_THRESHOLD_COUNT_ZONE2_DEFAULT);\n\tregmap_field_write(bwmon->regs[F_THRESHOLD_COUNT_ZONE3],\n\t\t\t   data->zone3_thres_count);\n\n\tregmap_field_write(bwmon->regs[F_ZONE_ACTIONS_ZONE0],\n\t\t\t   BWMON_ZONE_ACTIONS_ZONE0);\n\tregmap_field_write(bwmon->regs[F_ZONE_ACTIONS_ZONE1],\n\t\t\t   BWMON_ZONE_ACTIONS_ZONE1);\n\tregmap_field_write(bwmon->regs[F_ZONE_ACTIONS_ZONE2],\n\t\t\t   BWMON_ZONE_ACTIONS_ZONE2);\n\tregmap_field_write(bwmon->regs[F_ZONE_ACTIONS_ZONE3],\n\t\t\t   BWMON_ZONE_ACTIONS_ZONE3);\n\n\tbwmon_clear_irq(bwmon);\n\tbwmon_enable(bwmon, BWMON_IRQ_ENABLE_MASK);\n}\n\nstatic irqreturn_t bwmon_intr(int irq, void *dev_id)\n{\n\tstruct icc_bwmon *bwmon = dev_id;\n\tunsigned int status, max;\n\tint zone;\n\n\tif (regmap_field_read(bwmon->regs[F_IRQ_STATUS], &status))\n\t\treturn IRQ_NONE;\n\n\tstatus &= BWMON_IRQ_ENABLE_MASK;\n\tif (!status) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tbwmon_disable(bwmon);\n\n\tzone = get_bitmask_order(status) - 1;\n\t \n\tif (regmap_field_read(bwmon->regs[F_ZONE0_MAX + zone], &max))\n\t\treturn IRQ_NONE;\n\n\tmax += 1;\n\tmax *= bwmon->data->count_unit_kb;\n\tbwmon->target_kbps = mult_frac(max, MSEC_PER_SEC, bwmon->data->sample_ms);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t bwmon_intr_thread(int irq, void *dev_id)\n{\n\tstruct icc_bwmon *bwmon = dev_id;\n\tunsigned int irq_enable = 0;\n\tstruct dev_pm_opp *opp, *target_opp;\n\tunsigned int bw_kbps, up_kbps, down_kbps;\n\n\tbw_kbps = bwmon->target_kbps;\n\n\ttarget_opp = dev_pm_opp_find_bw_ceil(bwmon->dev, &bw_kbps, 0);\n\tif (IS_ERR(target_opp) && PTR_ERR(target_opp) == -ERANGE)\n\t\ttarget_opp = dev_pm_opp_find_bw_floor(bwmon->dev, &bw_kbps, 0);\n\n\tbwmon->target_kbps = bw_kbps;\n\n\tbw_kbps--;\n\topp = dev_pm_opp_find_bw_floor(bwmon->dev, &bw_kbps, 0);\n\tif (IS_ERR(opp) && PTR_ERR(opp) == -ERANGE)\n\t\tdown_kbps = bwmon->target_kbps;\n\telse\n\t\tdown_kbps = bw_kbps;\n\n\tup_kbps = bwmon->target_kbps + 1;\n\n\tif (bwmon->target_kbps >= bwmon->max_bw_kbps)\n\t\tirq_enable = BIT(1);\n\telse if (bwmon->target_kbps <= bwmon->min_bw_kbps)\n\t\tirq_enable = BIT(3);\n\telse\n\t\tirq_enable = BWMON_IRQ_ENABLE_MASK;\n\n\tbwmon_set_threshold(bwmon, bwmon->regs[F_THRESHOLD_HIGH],\n\t\t\t    up_kbps);\n\tbwmon_set_threshold(bwmon, bwmon->regs[F_THRESHOLD_MED],\n\t\t\t    down_kbps);\n\tbwmon_clear_counters(bwmon, false);\n\tbwmon_clear_irq(bwmon);\n\tbwmon_enable(bwmon, irq_enable);\n\n\tif (bwmon->target_kbps == bwmon->current_kbps)\n\t\tgoto out;\n\n\tdev_pm_opp_set_opp(bwmon->dev, target_opp);\n\tbwmon->current_kbps = bwmon->target_kbps;\n\nout:\n\tdev_pm_opp_put(target_opp);\n\tif (!IS_ERR(opp))\n\t\tdev_pm_opp_put(opp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bwmon_init_regmap(struct platform_device *pdev,\n\t\t\t     struct icc_bwmon *bwmon)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tstruct regmap *map;\n\tint ret;\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn dev_err_probe(dev, PTR_ERR(base),\n\t\t\t\t     \"failed to map bwmon registers\\n\");\n\n\tmap = devm_regmap_init_mmio(dev, base, bwmon->data->regmap_cfg);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t     \"failed to initialize regmap\\n\");\n\n\tBUILD_BUG_ON(ARRAY_SIZE(msm8998_bwmon_global_reg_fields) != F_NUM_GLOBAL_FIELDS);\n\tBUILD_BUG_ON(ARRAY_SIZE(msm8998_bwmon_reg_fields) != F_NUM_FIELDS);\n\tBUILD_BUG_ON(ARRAY_SIZE(sdm845_cpu_bwmon_reg_fields) != F_NUM_FIELDS);\n\tBUILD_BUG_ON(ARRAY_SIZE(sdm845_llcc_bwmon_reg_fields) != F_NUM_FIELDS);\n\n\tret = devm_regmap_field_bulk_alloc(dev, map, bwmon->regs,\n\t\t\t\t\t   bwmon->data->regmap_fields,\n\t\t\t\t\t   F_NUM_FIELDS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bwmon->data->global_regmap_cfg) {\n\t\t \n\t\tbase = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(base))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(base),\n\t\t\t\t\t     \"failed to map bwmon global registers\\n\");\n\n\t\tmap = devm_regmap_init_mmio(dev, base, bwmon->data->global_regmap_cfg);\n\t\tif (IS_ERR(map))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(map),\n\t\t\t\t\t     \"failed to initialize global regmap\\n\");\n\n\t\tret = devm_regmap_field_bulk_alloc(dev, map, bwmon->global_regs,\n\t\t\t\t\t\t   bwmon->data->global_regmap_fields,\n\t\t\t\t\t\t   F_NUM_GLOBAL_FIELDS);\n\t}\n\n\treturn ret;\n}\n\nstatic int bwmon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dev_pm_opp *opp;\n\tstruct icc_bwmon *bwmon;\n\tint ret;\n\n\tbwmon = devm_kzalloc(dev, sizeof(*bwmon), GFP_KERNEL);\n\tif (!bwmon)\n\t\treturn -ENOMEM;\n\n\tbwmon->data = of_device_get_match_data(dev);\n\n\tret = bwmon_init_regmap(pdev, bwmon);\n\tif (ret)\n\t\treturn ret;\n\n\tbwmon->irq = platform_get_irq(pdev, 0);\n\tif (bwmon->irq < 0)\n\t\treturn bwmon->irq;\n\n\tret = devm_pm_opp_of_add_table(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add OPP table\\n\");\n\n\tbwmon->max_bw_kbps = UINT_MAX;\n\topp = dev_pm_opp_find_bw_floor(dev, &bwmon->max_bw_kbps, 0);\n\tif (IS_ERR(opp))\n\t\treturn dev_err_probe(dev, PTR_ERR(opp), \"failed to find max peak bandwidth\\n\");\n\n\tbwmon->min_bw_kbps = 0;\n\topp = dev_pm_opp_find_bw_ceil(dev, &bwmon->min_bw_kbps, 0);\n\tif (IS_ERR(opp))\n\t\treturn dev_err_probe(dev, PTR_ERR(opp), \"failed to find min peak bandwidth\\n\");\n\n\tbwmon->dev = dev;\n\n\tbwmon_disable(bwmon);\n\tret = devm_request_threaded_irq(dev, bwmon->irq, bwmon_intr,\n\t\t\t\t\tbwmon_intr_thread,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), bwmon);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request IRQ\\n\");\n\n\tplatform_set_drvdata(pdev, bwmon);\n\tbwmon_start(bwmon);\n\n\treturn 0;\n}\n\nstatic int bwmon_remove(struct platform_device *pdev)\n{\n\tstruct icc_bwmon *bwmon = platform_get_drvdata(pdev);\n\n\tbwmon_disable(bwmon);\n\n\treturn 0;\n}\n\nstatic const struct icc_bwmon_data msm8998_bwmon_data = {\n\t.sample_ms = 4,\n\t.count_unit_kb = 1024,\n\t.zone1_thres_count = 16,\n\t.zone3_thres_count = 1,\n\t.quirks = BWMON_HAS_GLOBAL_IRQ,\n\t.regmap_fields = msm8998_bwmon_reg_fields,\n\t.regmap_cfg = &msm8998_bwmon_regmap_cfg,\n\t.global_regmap_fields = msm8998_bwmon_global_reg_fields,\n\t.global_regmap_cfg = &msm8998_bwmon_global_regmap_cfg,\n};\n\nstatic const struct icc_bwmon_data sdm845_cpu_bwmon_data = {\n\t.sample_ms = 4,\n\t.count_unit_kb = 64,\n\t.zone1_thres_count = 16,\n\t.zone3_thres_count = 1,\n\t.quirks = BWMON_HAS_GLOBAL_IRQ,\n\t.regmap_fields = sdm845_cpu_bwmon_reg_fields,\n\t.regmap_cfg = &sdm845_cpu_bwmon_regmap_cfg,\n};\n\nstatic const struct icc_bwmon_data sdm845_llcc_bwmon_data = {\n\t.sample_ms = 4,\n\t.count_unit_kb = 1024,\n\t.zone1_thres_count = 16,\n\t.zone3_thres_count = 1,\n\t.regmap_fields = sdm845_llcc_bwmon_reg_fields,\n\t.regmap_cfg = &sdm845_llcc_bwmon_regmap_cfg,\n};\n\nstatic const struct icc_bwmon_data sc7280_llcc_bwmon_data = {\n\t.sample_ms = 4,\n\t.count_unit_kb = 64,\n\t.zone1_thres_count = 16,\n\t.zone3_thres_count = 1,\n\t.quirks = BWMON_NEEDS_FORCE_CLEAR,\n\t.regmap_fields = sdm845_llcc_bwmon_reg_fields,\n\t.regmap_cfg = &sdm845_llcc_bwmon_regmap_cfg,\n};\n\nstatic const struct of_device_id bwmon_of_match[] = {\n\t \n\t{ .compatible = \"qcom,msm8998-bwmon\", .data = &msm8998_bwmon_data },\n\t \n\t{ .compatible = \"qcom,sdm845-bwmon\", .data = &sdm845_cpu_bwmon_data },\n\t \n\t{ .compatible = \"qcom,sdm845-llcc-bwmon\", .data = &sdm845_llcc_bwmon_data },\n\t{ .compatible = \"qcom,sc7280-llcc-bwmon\", .data = &sc7280_llcc_bwmon_data },\n\n\t \n\t{ .compatible = \"qcom,sc7280-cpu-bwmon\", .data = &sdm845_cpu_bwmon_data },\n\t{ .compatible = \"qcom,sc8280xp-cpu-bwmon\", .data = &sdm845_cpu_bwmon_data },\n\t{ .compatible = \"qcom,sm8550-cpu-bwmon\", .data = &sdm845_cpu_bwmon_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bwmon_of_match);\n\nstatic struct platform_driver bwmon_driver = {\n\t.probe = bwmon_probe,\n\t.remove = bwmon_remove,\n\t.driver = {\n\t\t.name = \"qcom-bwmon\",\n\t\t.of_match_table = bwmon_of_match,\n\t},\n};\nmodule_platform_driver(bwmon_driver);\n\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>\");\nMODULE_DESCRIPTION(\"QCOM BWMON driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}