{
  "module_name": "smsm.c",
  "hash_id": "fdebcb12f7af09526a698598a7c7cebc46aff331161679490657234f7dd738cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/smsm.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\n \n\n \n#define SMEM_SMSM_SHARED_STATE\t\t85\n#define SMEM_SMSM_CPU_INTR_MASK\t\t333\n#define SMEM_SMSM_SIZE_INFO\t\t419\n\n \n#define SMSM_DEFAULT_NUM_ENTRIES\t8\n#define SMSM_DEFAULT_NUM_HOSTS\t\t3\n\nstruct smsm_entry;\nstruct smsm_host;\n\n \nstruct qcom_smsm {\n\tstruct device *dev;\n\n\tu32 local_host;\n\n\tu32 num_hosts;\n\tu32 num_entries;\n\n\tu32 *local_state;\n\tu32 *subscription;\n\tstruct qcom_smem_state *state;\n\n\tspinlock_t lock;\n\n\tstruct smsm_entry *entries;\n\tstruct smsm_host *hosts;\n};\n\n \nstruct smsm_entry {\n\tstruct qcom_smsm *smsm;\n\n\tstruct irq_domain *domain;\n\tDECLARE_BITMAP(irq_enabled, 32);\n\tDECLARE_BITMAP(irq_rising, 32);\n\tDECLARE_BITMAP(irq_falling, 32);\n\tunsigned long last_value;\n\n\tu32 *remote_state;\n\tu32 *subscription;\n};\n\n \nstruct smsm_host {\n\tstruct regmap *ipc_regmap;\n\tint ipc_offset;\n\tint ipc_bit;\n};\n\n \nstatic int smsm_update_bits(void *data, u32 mask, u32 value)\n{\n\tstruct qcom_smsm *smsm = data;\n\tstruct smsm_host *hostp;\n\tunsigned long flags;\n\tu32 changes;\n\tu32 host;\n\tu32 orig;\n\tu32 val;\n\n\tspin_lock_irqsave(&smsm->lock, flags);\n\n\t \n\tval = orig = readl(smsm->local_state);\n\tval &= ~mask;\n\tval |= value;\n\n\t \n\tchanges = val ^ orig;\n\tif (!changes) {\n\t\tspin_unlock_irqrestore(&smsm->lock, flags);\n\t\tgoto done;\n\t}\n\n\t \n\twritel(val, smsm->local_state);\n\tspin_unlock_irqrestore(&smsm->lock, flags);\n\n\t \n\twmb();\n\n\t \n\tfor (host = 0; host < smsm->num_hosts; host++) {\n\t\thostp = &smsm->hosts[host];\n\n\t\tval = readl(smsm->subscription + host);\n\t\tif (val & changes && hostp->ipc_regmap) {\n\t\t\tregmap_write(hostp->ipc_regmap,\n\t\t\t\t     hostp->ipc_offset,\n\t\t\t\t     BIT(hostp->ipc_bit));\n\t\t}\n\t}\n\ndone:\n\treturn 0;\n}\n\nstatic const struct qcom_smem_state_ops smsm_state_ops = {\n\t.update_bits = smsm_update_bits,\n};\n\n \nstatic irqreturn_t smsm_intr(int irq, void *data)\n{\n\tstruct smsm_entry *entry = data;\n\tunsigned i;\n\tint irq_pin;\n\tu32 changed;\n\tu32 val;\n\n\tval = readl(entry->remote_state);\n\tchanged = val ^ xchg(&entry->last_value, val);\n\n\tfor_each_set_bit(i, entry->irq_enabled, 32) {\n\t\tif (!(changed & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (val & BIT(i)) {\n\t\t\tif (test_bit(i, entry->irq_rising)) {\n\t\t\t\tirq_pin = irq_find_mapping(entry->domain, i);\n\t\t\t\thandle_nested_irq(irq_pin);\n\t\t\t}\n\t\t} else {\n\t\t\tif (test_bit(i, entry->irq_falling)) {\n\t\t\t\tirq_pin = irq_find_mapping(entry->domain, i);\n\t\t\t\thandle_nested_irq(irq_pin);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void smsm_mask_irq(struct irq_data *irqd)\n{\n\tstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\tstruct qcom_smsm *smsm = entry->smsm;\n\tu32 val;\n\n\tif (entry->subscription) {\n\t\tval = readl(entry->subscription + smsm->local_host);\n\t\tval &= ~BIT(irq);\n\t\twritel(val, entry->subscription + smsm->local_host);\n\t}\n\n\tclear_bit(irq, entry->irq_enabled);\n}\n\n \nstatic void smsm_unmask_irq(struct irq_data *irqd)\n{\n\tstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\tstruct qcom_smsm *smsm = entry->smsm;\n\tu32 val;\n\n\t \n\tif (readl(entry->remote_state) & BIT(irq))\n\t\tset_bit(irq, &entry->last_value);\n\telse\n\t\tclear_bit(irq, &entry->last_value);\n\n\tset_bit(irq, entry->irq_enabled);\n\n\tif (entry->subscription) {\n\t\tval = readl(entry->subscription + smsm->local_host);\n\t\tval |= BIT(irq);\n\t\twritel(val, entry->subscription + smsm->local_host);\n\t}\n}\n\n \nstatic int smsm_set_irq_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\n\tif (!(type & IRQ_TYPE_EDGE_BOTH))\n\t\treturn -EINVAL;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tset_bit(irq, entry->irq_rising);\n\telse\n\t\tclear_bit(irq, entry->irq_rising);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tset_bit(irq, entry->irq_falling);\n\telse\n\t\tclear_bit(irq, entry->irq_falling);\n\n\treturn 0;\n}\n\nstatic int smsm_get_irqchip_state(struct irq_data *irqd,\n\t\t\t\t  enum irqchip_irq_state which, bool *state)\n{\n\tstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\tu32 val;\n\n\tif (which != IRQCHIP_STATE_LINE_LEVEL)\n\t\treturn -EINVAL;\n\n\tval = readl(entry->remote_state);\n\t*state = !!(val & BIT(irq));\n\n\treturn 0;\n}\n\nstatic struct irq_chip smsm_irq_chip = {\n\t.name           = \"smsm\",\n\t.irq_mask       = smsm_mask_irq,\n\t.irq_unmask     = smsm_unmask_irq,\n\t.irq_set_type\t= smsm_set_irq_type,\n\t.irq_get_irqchip_state = smsm_get_irqchip_state,\n};\n\n \nstatic int smsm_irq_map(struct irq_domain *d,\n\t\t\tunsigned int irq,\n\t\t\tirq_hw_number_t hw)\n{\n\tstruct smsm_entry *entry = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &smsm_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, entry);\n\tirq_set_nested_thread(irq, 1);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops smsm_irq_ops = {\n\t.map = smsm_irq_map,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\n \nstatic int smsm_parse_ipc(struct qcom_smsm *smsm, unsigned host_id)\n{\n\tstruct device_node *syscon;\n\tstruct device_node *node = smsm->dev->of_node;\n\tstruct smsm_host *host = &smsm->hosts[host_id];\n\tchar key[16];\n\tint ret;\n\n\tsnprintf(key, sizeof(key), \"qcom,ipc-%d\", host_id);\n\tsyscon = of_parse_phandle(node, key, 0);\n\tif (!syscon)\n\t\treturn 0;\n\n\thost->ipc_regmap = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(host->ipc_regmap))\n\t\treturn PTR_ERR(host->ipc_regmap);\n\n\tret = of_property_read_u32_index(node, key, 1, &host->ipc_offset);\n\tif (ret < 0) {\n\t\tdev_err(smsm->dev, \"no offset in %s\\n\", key);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_index(node, key, 2, &host->ipc_bit);\n\tif (ret < 0) {\n\t\tdev_err(smsm->dev, \"no bit in %s\\n\", key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smsm_inbound_entry(struct qcom_smsm *smsm,\n\t\t\t      struct smsm_entry *entry,\n\t\t\t      struct device_node *node)\n{\n\tint ret;\n\tint irq;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tdev_err(smsm->dev, \"failed to parse smsm interrupt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_threaded_irq(smsm->dev, irq,\n\t\t\t\t\tNULL, smsm_intr,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"smsm\", (void *)entry);\n\tif (ret) {\n\t\tdev_err(smsm->dev, \"failed to request interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\tentry->domain = irq_domain_add_linear(node, 32, &smsm_irq_ops, entry);\n\tif (!entry->domain) {\n\t\tdev_err(smsm->dev, \"failed to add irq_domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smsm_get_size_info(struct qcom_smsm *smsm)\n{\n\tsize_t size;\n\tstruct {\n\t\tu32 num_hosts;\n\t\tu32 num_entries;\n\t\tu32 reserved0;\n\t\tu32 reserved1;\n\t} *info;\n\n\tinfo = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SIZE_INFO, &size);\n\tif (IS_ERR(info) && PTR_ERR(info) != -ENOENT)\n\t\treturn dev_err_probe(smsm->dev, PTR_ERR(info),\n\t\t\t\t     \"unable to retrieve smsm size info\\n\");\n\telse if (IS_ERR(info) || size != sizeof(*info)) {\n\t\tdev_warn(smsm->dev, \"no smsm size info, using defaults\\n\");\n\t\tsmsm->num_entries = SMSM_DEFAULT_NUM_ENTRIES;\n\t\tsmsm->num_hosts = SMSM_DEFAULT_NUM_HOSTS;\n\t\treturn 0;\n\t}\n\n\tsmsm->num_entries = info->num_entries;\n\tsmsm->num_hosts = info->num_hosts;\n\n\tdev_dbg(smsm->dev,\n\t\t\"found custom size of smsm: %d entries %d hosts\\n\",\n\t\tsmsm->num_entries, smsm->num_hosts);\n\n\treturn 0;\n}\n\nstatic int qcom_smsm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *local_node;\n\tstruct device_node *node;\n\tstruct smsm_entry *entry;\n\tstruct qcom_smsm *smsm;\n\tu32 *intr_mask;\n\tsize_t size;\n\tu32 *states;\n\tu32 id;\n\tint ret;\n\n\tsmsm = devm_kzalloc(&pdev->dev, sizeof(*smsm), GFP_KERNEL);\n\tif (!smsm)\n\t\treturn -ENOMEM;\n\tsmsm->dev = &pdev->dev;\n\tspin_lock_init(&smsm->lock);\n\n\tret = smsm_get_size_info(smsm);\n\tif (ret)\n\t\treturn ret;\n\n\tsmsm->entries = devm_kcalloc(&pdev->dev,\n\t\t\t\t     smsm->num_entries,\n\t\t\t\t     sizeof(struct smsm_entry),\n\t\t\t\t     GFP_KERNEL);\n\tif (!smsm->entries)\n\t\treturn -ENOMEM;\n\n\tsmsm->hosts = devm_kcalloc(&pdev->dev,\n\t\t\t\t   smsm->num_hosts,\n\t\t\t\t   sizeof(struct smsm_host),\n\t\t\t\t   GFP_KERNEL);\n\tif (!smsm->hosts)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(pdev->dev.of_node, local_node) {\n\t\tif (of_property_present(local_node, \"#qcom,smem-state-cells\"))\n\t\t\tbreak;\n\t}\n\tif (!local_node) {\n\t\tdev_err(&pdev->dev, \"no state entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32(pdev->dev.of_node,\n\t\t\t     \"qcom,local-host\",\n\t\t\t     &smsm->local_host);\n\n\t \n\tfor (id = 0; id < smsm->num_hosts; id++) {\n\t\tret = smsm_parse_ipc(smsm, id);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t}\n\n\t \n\tret = qcom_smem_alloc(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SHARED_STATE,\n\t\t\t      smsm->num_entries * sizeof(u32));\n\tif (ret < 0 && ret != -EEXIST) {\n\t\tdev_err(&pdev->dev, \"unable to allocate shared state entry\\n\");\n\t\tgoto out_put;\n\t}\n\n\tstates = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SHARED_STATE, NULL);\n\tif (IS_ERR(states)) {\n\t\tdev_err(&pdev->dev, \"Unable to acquire shared state entry\\n\");\n\t\tret = PTR_ERR(states);\n\t\tgoto out_put;\n\t}\n\n\t \n\tsize = smsm->num_entries * smsm->num_hosts * sizeof(u32);\n\tret = qcom_smem_alloc(QCOM_SMEM_HOST_ANY, SMEM_SMSM_CPU_INTR_MASK, size);\n\tif (ret < 0 && ret != -EEXIST) {\n\t\tdev_err(&pdev->dev, \"unable to allocate smsm interrupt mask\\n\");\n\t\tgoto out_put;\n\t}\n\n\tintr_mask = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_CPU_INTR_MASK, NULL);\n\tif (IS_ERR(intr_mask)) {\n\t\tdev_err(&pdev->dev, \"unable to acquire shared memory interrupt mask\\n\");\n\t\tret = PTR_ERR(intr_mask);\n\t\tgoto out_put;\n\t}\n\n\t \n\tsmsm->local_state = states + smsm->local_host;\n\tsmsm->subscription = intr_mask + smsm->local_host * smsm->num_hosts;\n\n\t \n\tsmsm->state = qcom_smem_state_register(local_node, &smsm_state_ops, smsm);\n\tif (IS_ERR(smsm->state)) {\n\t\tdev_err(smsm->dev, \"failed to register qcom_smem_state\\n\");\n\t\tret = PTR_ERR(smsm->state);\n\t\tgoto out_put;\n\t}\n\n\t \n\tfor_each_available_child_of_node(pdev->dev.of_node, node) {\n\t\tif (!of_property_read_bool(node, \"interrupt-controller\"))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(node, \"reg\", &id);\n\t\tif (ret || id >= smsm->num_entries) {\n\t\t\tdev_err(&pdev->dev, \"invalid reg of entry\\n\");\n\t\t\tif (!ret)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto unwind_interfaces;\n\t\t}\n\t\tentry = &smsm->entries[id];\n\n\t\tentry->smsm = smsm;\n\t\tentry->remote_state = states + id;\n\n\t\t \n\t\tentry->subscription = intr_mask + id * smsm->num_hosts;\n\t\twritel(0, entry->subscription + smsm->local_host);\n\n\t\tret = smsm_inbound_entry(smsm, entry, node);\n\t\tif (ret < 0)\n\t\t\tgoto unwind_interfaces;\n\t}\n\n\tplatform_set_drvdata(pdev, smsm);\n\tof_node_put(local_node);\n\n\treturn 0;\n\nunwind_interfaces:\n\tof_node_put(node);\n\tfor (id = 0; id < smsm->num_entries; id++)\n\t\tif (smsm->entries[id].domain)\n\t\t\tirq_domain_remove(smsm->entries[id].domain);\n\n\tqcom_smem_state_unregister(smsm->state);\nout_put:\n\tof_node_put(local_node);\n\treturn ret;\n}\n\nstatic int qcom_smsm_remove(struct platform_device *pdev)\n{\n\tstruct qcom_smsm *smsm = platform_get_drvdata(pdev);\n\tunsigned id;\n\n\tfor (id = 0; id < smsm->num_entries; id++)\n\t\tif (smsm->entries[id].domain)\n\t\t\tirq_domain_remove(smsm->entries[id].domain);\n\n\tqcom_smem_state_unregister(smsm->state);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_smsm_of_match[] = {\n\t{ .compatible = \"qcom,smsm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_smsm_of_match);\n\nstatic struct platform_driver qcom_smsm_driver = {\n\t.probe = qcom_smsm_probe,\n\t.remove = qcom_smsm_remove,\n\t.driver  = {\n\t\t.name  = \"qcom-smsm\",\n\t\t.of_match_table = qcom_smsm_of_match,\n\t},\n};\nmodule_platform_driver(qcom_smsm_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Shared Memory State Machine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}