{
  "module_name": "qmi_interface.c",
  "hash_id": "c7939887a1e030fbe386d573504723428ebcc71c7c2ac04c7f47571c5f87f326",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qmi_interface.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/qrtr.h>\n#include <linux/net.h>\n#include <linux/completion.h>\n#include <linux/idr.h>\n#include <linux/string.h>\n#include <net/sock.h>\n#include <linux/workqueue.h>\n#include <trace/events/sock.h>\n#include <linux/soc/qcom/qmi.h>\n\nstatic struct socket *qmi_sock_create(struct qmi_handle *qmi,\n\t\t\t\t      struct sockaddr_qrtr *sq);\n\n \nstatic void qmi_recv_new_server(struct qmi_handle *qmi,\n\t\t\t\tunsigned int service, unsigned int instance,\n\t\t\t\tunsigned int node, unsigned int port)\n{\n\tstruct qmi_ops *ops = &qmi->ops;\n\tstruct qmi_service *svc;\n\tint ret;\n\n\tif (!ops->new_server)\n\t\treturn;\n\n\t \n\tif (!node && !port)\n\t\treturn;\n\n\tsvc = kzalloc(sizeof(*svc), GFP_KERNEL);\n\tif (!svc)\n\t\treturn;\n\n\tsvc->service = service;\n\tsvc->version = instance & 0xff;\n\tsvc->instance = instance >> 8;\n\tsvc->node = node;\n\tsvc->port = port;\n\n\tret = ops->new_server(qmi, svc);\n\tif (ret < 0)\n\t\tkfree(svc);\n\telse\n\t\tlist_add(&svc->list_node, &qmi->lookup_results);\n}\n\n \nstatic void qmi_recv_del_server(struct qmi_handle *qmi,\n\t\t\t\tunsigned int node, unsigned int port)\n{\n\tstruct qmi_ops *ops = &qmi->ops;\n\tstruct qmi_service *svc;\n\tstruct qmi_service *tmp;\n\n\tlist_for_each_entry_safe(svc, tmp, &qmi->lookup_results, list_node) {\n\t\tif (node != -1 && svc->node != node)\n\t\t\tcontinue;\n\t\tif (port != -1 && svc->port != port)\n\t\t\tcontinue;\n\n\t\tif (ops->del_server)\n\t\t\tops->del_server(qmi, svc);\n\n\t\tlist_del(&svc->list_node);\n\t\tkfree(svc);\n\t}\n}\n\n \nstatic void qmi_recv_bye(struct qmi_handle *qmi,\n\t\t\t unsigned int node)\n{\n\tstruct qmi_ops *ops = &qmi->ops;\n\n\tqmi_recv_del_server(qmi, node, -1);\n\n\tif (ops->bye)\n\t\tops->bye(qmi, node);\n}\n\n \nstatic void qmi_recv_del_client(struct qmi_handle *qmi,\n\t\t\t\tunsigned int node, unsigned int port)\n{\n\tstruct qmi_ops *ops = &qmi->ops;\n\n\tif (ops->del_client)\n\t\tops->del_client(qmi, node, port);\n}\n\nstatic void qmi_recv_ctrl_pkt(struct qmi_handle *qmi,\n\t\t\t      const void *buf, size_t len)\n{\n\tconst struct qrtr_ctrl_pkt *pkt = buf;\n\n\tif (len < sizeof(struct qrtr_ctrl_pkt)) {\n\t\tpr_debug(\"ignoring short control packet\\n\");\n\t\treturn;\n\t}\n\n\tswitch (le32_to_cpu(pkt->cmd)) {\n\tcase QRTR_TYPE_BYE:\n\t\tqmi_recv_bye(qmi, le32_to_cpu(pkt->client.node));\n\t\tbreak;\n\tcase QRTR_TYPE_NEW_SERVER:\n\t\tqmi_recv_new_server(qmi,\n\t\t\t\t    le32_to_cpu(pkt->server.service),\n\t\t\t\t    le32_to_cpu(pkt->server.instance),\n\t\t\t\t    le32_to_cpu(pkt->server.node),\n\t\t\t\t    le32_to_cpu(pkt->server.port));\n\t\tbreak;\n\tcase QRTR_TYPE_DEL_SERVER:\n\t\tqmi_recv_del_server(qmi,\n\t\t\t\t    le32_to_cpu(pkt->server.node),\n\t\t\t\t    le32_to_cpu(pkt->server.port));\n\t\tbreak;\n\tcase QRTR_TYPE_DEL_CLIENT:\n\t\tqmi_recv_del_client(qmi,\n\t\t\t\t    le32_to_cpu(pkt->client.node),\n\t\t\t\t    le32_to_cpu(pkt->client.port));\n\t\tbreak;\n\t}\n}\n\nstatic void qmi_send_new_lookup(struct qmi_handle *qmi, struct qmi_service *svc)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct sockaddr_qrtr sq;\n\tstruct msghdr msg = { };\n\tstruct kvec iv = { &pkt, sizeof(pkt) };\n\tint ret;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_NEW_LOOKUP);\n\tpkt.server.service = cpu_to_le32(svc->service);\n\tpkt.server.instance = cpu_to_le32(svc->version | svc->instance << 8);\n\n\tsq.sq_family = qmi->sq.sq_family;\n\tsq.sq_node = qmi->sq.sq_node;\n\tsq.sq_port = QRTR_PORT_CTRL;\n\n\tmsg.msg_name = &sq;\n\tmsg.msg_namelen = sizeof(sq);\n\n\tmutex_lock(&qmi->sock_lock);\n\tif (qmi->sock) {\n\t\tret = kernel_sendmsg(qmi->sock, &msg, &iv, 1, sizeof(pkt));\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to send lookup registration: %d\\n\", ret);\n\t}\n\tmutex_unlock(&qmi->sock_lock);\n}\n\n \nint qmi_add_lookup(struct qmi_handle *qmi, unsigned int service,\n\t\t   unsigned int version, unsigned int instance)\n{\n\tstruct qmi_service *svc;\n\n\tsvc = kzalloc(sizeof(*svc), GFP_KERNEL);\n\tif (!svc)\n\t\treturn -ENOMEM;\n\n\tsvc->service = service;\n\tsvc->version = version;\n\tsvc->instance = instance;\n\n\tlist_add(&svc->list_node, &qmi->lookups);\n\n\tqmi_send_new_lookup(qmi, svc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmi_add_lookup);\n\nstatic void qmi_send_new_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct sockaddr_qrtr sq;\n\tstruct msghdr msg = { };\n\tstruct kvec iv = { &pkt, sizeof(pkt) };\n\tint ret;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_NEW_SERVER);\n\tpkt.server.service = cpu_to_le32(svc->service);\n\tpkt.server.instance = cpu_to_le32(svc->version | svc->instance << 8);\n\tpkt.server.node = cpu_to_le32(qmi->sq.sq_node);\n\tpkt.server.port = cpu_to_le32(qmi->sq.sq_port);\n\n\tsq.sq_family = qmi->sq.sq_family;\n\tsq.sq_node = qmi->sq.sq_node;\n\tsq.sq_port = QRTR_PORT_CTRL;\n\n\tmsg.msg_name = &sq;\n\tmsg.msg_namelen = sizeof(sq);\n\n\tmutex_lock(&qmi->sock_lock);\n\tif (qmi->sock) {\n\t\tret = kernel_sendmsg(qmi->sock, &msg, &iv, 1, sizeof(pkt));\n\t\tif (ret < 0)\n\t\t\tpr_err(\"send service registration failed: %d\\n\", ret);\n\t}\n\tmutex_unlock(&qmi->sock_lock);\n}\n\n \nint qmi_add_server(struct qmi_handle *qmi, unsigned int service,\n\t\t   unsigned int version, unsigned int instance)\n{\n\tstruct qmi_service *svc;\n\n\tsvc = kzalloc(sizeof(*svc), GFP_KERNEL);\n\tif (!svc)\n\t\treturn -ENOMEM;\n\n\tsvc->service = service;\n\tsvc->version = version;\n\tsvc->instance = instance;\n\n\tlist_add(&svc->list_node, &qmi->services);\n\n\tqmi_send_new_server(qmi, svc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmi_add_server);\n\n \nint qmi_txn_init(struct qmi_handle *qmi, struct qmi_txn *txn,\n\t\t const struct qmi_elem_info *ei, void *c_struct)\n{\n\tint ret;\n\n\tmemset(txn, 0, sizeof(*txn));\n\n\tmutex_init(&txn->lock);\n\tinit_completion(&txn->completion);\n\ttxn->qmi = qmi;\n\ttxn->ei = ei;\n\ttxn->dest = c_struct;\n\n\tmutex_lock(&qmi->txn_lock);\n\tret = idr_alloc_cyclic(&qmi->txns, txn, 0, U16_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tpr_err(\"failed to allocate transaction id\\n\");\n\n\ttxn->id = ret;\n\tmutex_unlock(&qmi->txn_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qmi_txn_init);\n\n \nint qmi_txn_wait(struct qmi_txn *txn, unsigned long timeout)\n{\n\tstruct qmi_handle *qmi = txn->qmi;\n\tint ret;\n\n\tret = wait_for_completion_timeout(&txn->completion, timeout);\n\n\tmutex_lock(&qmi->txn_lock);\n\tmutex_lock(&txn->lock);\n\tidr_remove(&qmi->txns, txn->id);\n\tmutex_unlock(&txn->lock);\n\tmutex_unlock(&qmi->txn_lock);\n\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn txn->result;\n}\nEXPORT_SYMBOL(qmi_txn_wait);\n\n \nvoid qmi_txn_cancel(struct qmi_txn *txn)\n{\n\tstruct qmi_handle *qmi = txn->qmi;\n\n\tmutex_lock(&qmi->txn_lock);\n\tmutex_lock(&txn->lock);\n\tidr_remove(&qmi->txns, txn->id);\n\tmutex_unlock(&txn->lock);\n\tmutex_unlock(&qmi->txn_lock);\n}\nEXPORT_SYMBOL(qmi_txn_cancel);\n\n \nstatic void qmi_invoke_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t       struct qmi_txn *txn, const void *buf, size_t len)\n{\n\tconst struct qmi_msg_handler *handler;\n\tconst struct qmi_header *hdr = buf;\n\tvoid *dest;\n\tint ret;\n\n\tif (!qmi->handlers)\n\t\treturn;\n\n\tfor (handler = qmi->handlers; handler->fn; handler++) {\n\t\tif (handler->type == hdr->type &&\n\t\t    handler->msg_id == hdr->msg_id)\n\t\t\tbreak;\n\t}\n\n\tif (!handler->fn)\n\t\treturn;\n\n\tdest = kzalloc(handler->decoded_size, GFP_KERNEL);\n\tif (!dest)\n\t\treturn;\n\n\tret = qmi_decode_message(buf, len, handler->ei, dest);\n\tif (ret < 0)\n\t\tpr_err(\"failed to decode incoming message\\n\");\n\telse\n\t\thandler->fn(qmi, sq, txn, dest);\n\n\tkfree(dest);\n}\n\n \nstatic void qmi_handle_net_reset(struct qmi_handle *qmi)\n{\n\tstruct sockaddr_qrtr sq;\n\tstruct qmi_service *svc;\n\tstruct socket *sock;\n\n\tsock = qmi_sock_create(qmi, &sq);\n\tif (IS_ERR(sock))\n\t\treturn;\n\n\tmutex_lock(&qmi->sock_lock);\n\tsock_release(qmi->sock);\n\tqmi->sock = NULL;\n\tmutex_unlock(&qmi->sock_lock);\n\n\tqmi_recv_del_server(qmi, -1, -1);\n\n\tif (qmi->ops.net_reset)\n\t\tqmi->ops.net_reset(qmi);\n\n\tmutex_lock(&qmi->sock_lock);\n\tqmi->sock = sock;\n\tqmi->sq = sq;\n\tmutex_unlock(&qmi->sock_lock);\n\n\tlist_for_each_entry(svc, &qmi->lookups, list_node)\n\t\tqmi_send_new_lookup(qmi, svc);\n\n\tlist_for_each_entry(svc, &qmi->services, list_node)\n\t\tqmi_send_new_server(qmi, svc);\n}\n\nstatic void qmi_handle_message(struct qmi_handle *qmi,\n\t\t\t       struct sockaddr_qrtr *sq,\n\t\t\t       const void *buf, size_t len)\n{\n\tconst struct qmi_header *hdr;\n\tstruct qmi_txn tmp_txn;\n\tstruct qmi_txn *txn = NULL;\n\tint ret;\n\n\tif (len < sizeof(*hdr)) {\n\t\tpr_err(\"ignoring short QMI packet\\n\");\n\t\treturn;\n\t}\n\n\thdr = buf;\n\n\t \n\tif (hdr->type == QMI_RESPONSE) {\n\t\tmutex_lock(&qmi->txn_lock);\n\t\ttxn = idr_find(&qmi->txns, hdr->txn_id);\n\n\t\t \n\t\tif (!txn) {\n\t\t\tmutex_unlock(&qmi->txn_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tmutex_lock(&txn->lock);\n\t\tmutex_unlock(&qmi->txn_lock);\n\n\t\tif (txn->dest && txn->ei) {\n\t\t\tret = qmi_decode_message(buf, len, txn->ei, txn->dest);\n\t\t\tif (ret < 0)\n\t\t\t\tpr_err(\"failed to decode incoming message\\n\");\n\n\t\t\ttxn->result = ret;\n\t\t\tcomplete(&txn->completion);\n\t\t} else  {\n\t\t\tqmi_invoke_handler(qmi, sq, txn, buf, len);\n\t\t}\n\n\t\tmutex_unlock(&txn->lock);\n\t} else {\n\t\t \n\t\tmemset(&tmp_txn, 0, sizeof(tmp_txn));\n\t\ttmp_txn.id = hdr->txn_id;\n\n\t\tqmi_invoke_handler(qmi, sq, &tmp_txn, buf, len);\n\t}\n}\n\nstatic void qmi_data_ready_work(struct work_struct *work)\n{\n\tstruct qmi_handle *qmi = container_of(work, struct qmi_handle, work);\n\tstruct qmi_ops *ops = &qmi->ops;\n\tstruct sockaddr_qrtr sq;\n\tstruct msghdr msg = { .msg_name = &sq, .msg_namelen = sizeof(sq) };\n\tstruct kvec iv;\n\tssize_t msglen;\n\n\tfor (;;) {\n\t\tiv.iov_base = qmi->recv_buf;\n\t\tiv.iov_len = qmi->recv_buf_size;\n\n\t\tmutex_lock(&qmi->sock_lock);\n\t\tif (qmi->sock)\n\t\t\tmsglen = kernel_recvmsg(qmi->sock, &msg, &iv, 1,\n\t\t\t\t\t\tiv.iov_len, MSG_DONTWAIT);\n\t\telse\n\t\t\tmsglen = -EPIPE;\n\t\tmutex_unlock(&qmi->sock_lock);\n\t\tif (msglen == -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (msglen == -ENETRESET) {\n\t\t\tqmi_handle_net_reset(qmi);\n\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (msglen < 0) {\n\t\t\tpr_err(\"qmi recvmsg failed: %zd\\n\", msglen);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sq.sq_node == qmi->sq.sq_node &&\n\t\t    sq.sq_port == QRTR_PORT_CTRL) {\n\t\t\tqmi_recv_ctrl_pkt(qmi, qmi->recv_buf, msglen);\n\t\t} else if (ops->msg_handler) {\n\t\t\tops->msg_handler(qmi, &sq, qmi->recv_buf, msglen);\n\t\t} else {\n\t\t\tqmi_handle_message(qmi, &sq, qmi->recv_buf, msglen);\n\t\t}\n\t}\n}\n\nstatic void qmi_data_ready(struct sock *sk)\n{\n\tstruct qmi_handle *qmi = sk->sk_user_data;\n\n\ttrace_sk_data_ready(sk);\n\n\t \n\tif (!qmi)\n\t\treturn;\n\n\tqueue_work(qmi->wq, &qmi->work);\n}\n\nstatic struct socket *qmi_sock_create(struct qmi_handle *qmi,\n\t\t\t\t      struct sockaddr_qrtr *sq)\n{\n\tstruct socket *sock;\n\tint ret;\n\n\tret = sock_create_kern(&init_net, AF_QIPCRTR, SOCK_DGRAM,\n\t\t\t       PF_QIPCRTR, &sock);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tret = kernel_getsockname(sock, (struct sockaddr *)sq);\n\tif (ret < 0) {\n\t\tsock_release(sock);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tsock->sk->sk_user_data = qmi;\n\tsock->sk->sk_data_ready = qmi_data_ready;\n\tsock->sk->sk_error_report = qmi_data_ready;\n\n\treturn sock;\n}\n\n \nint qmi_handle_init(struct qmi_handle *qmi, size_t recv_buf_size,\n\t\t    const struct qmi_ops *ops,\n\t\t    const struct qmi_msg_handler *handlers)\n{\n\tint ret;\n\n\tmutex_init(&qmi->txn_lock);\n\tmutex_init(&qmi->sock_lock);\n\n\tidr_init(&qmi->txns);\n\n\tINIT_LIST_HEAD(&qmi->lookups);\n\tINIT_LIST_HEAD(&qmi->lookup_results);\n\tINIT_LIST_HEAD(&qmi->services);\n\n\tINIT_WORK(&qmi->work, qmi_data_ready_work);\n\n\tqmi->handlers = handlers;\n\tif (ops)\n\t\tqmi->ops = *ops;\n\n\t \n\trecv_buf_size += sizeof(struct qmi_header);\n\t \n\tif (recv_buf_size < sizeof(struct qrtr_ctrl_pkt))\n\t\trecv_buf_size = sizeof(struct qrtr_ctrl_pkt);\n\n\tqmi->recv_buf_size = recv_buf_size;\n\tqmi->recv_buf = kzalloc(recv_buf_size, GFP_KERNEL);\n\tif (!qmi->recv_buf)\n\t\treturn -ENOMEM;\n\n\tqmi->wq = alloc_ordered_workqueue(\"qmi_msg_handler\", 0);\n\tif (!qmi->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_recv_buf;\n\t}\n\n\tqmi->sock = qmi_sock_create(qmi, &qmi->sq);\n\tif (IS_ERR(qmi->sock)) {\n\t\tif (PTR_ERR(qmi->sock) == -EAFNOSUPPORT) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t} else {\n\t\t\tpr_err(\"failed to create QMI socket\\n\");\n\t\t\tret = PTR_ERR(qmi->sock);\n\t\t}\n\t\tgoto err_destroy_wq;\n\t}\n\n\treturn 0;\n\nerr_destroy_wq:\n\tdestroy_workqueue(qmi->wq);\nerr_free_recv_buf:\n\tkfree(qmi->recv_buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qmi_handle_init);\n\n \nvoid qmi_handle_release(struct qmi_handle *qmi)\n{\n\tstruct socket *sock = qmi->sock;\n\tstruct qmi_service *svc, *tmp;\n\n\tsock->sk->sk_user_data = NULL;\n\tcancel_work_sync(&qmi->work);\n\n\tqmi_recv_del_server(qmi, -1, -1);\n\n\tmutex_lock(&qmi->sock_lock);\n\tsock_release(sock);\n\tqmi->sock = NULL;\n\tmutex_unlock(&qmi->sock_lock);\n\n\tdestroy_workqueue(qmi->wq);\n\n\tidr_destroy(&qmi->txns);\n\n\tkfree(qmi->recv_buf);\n\n\t \n\tlist_for_each_entry_safe(svc, tmp, &qmi->lookups, list_node) {\n\t\tlist_del(&svc->list_node);\n\t\tkfree(svc);\n\t}\n\n\t \n\tlist_for_each_entry_safe(svc, tmp, &qmi->services, list_node) {\n\t\tlist_del(&svc->list_node);\n\t\tkfree(svc);\n\t}\n}\nEXPORT_SYMBOL(qmi_handle_release);\n\n \nstatic ssize_t qmi_send_message(struct qmi_handle *qmi,\n\t\t\t\tstruct sockaddr_qrtr *sq, struct qmi_txn *txn,\n\t\t\t\tint type, int msg_id, size_t len,\n\t\t\t\tconst struct qmi_elem_info *ei,\n\t\t\t\tconst void *c_struct)\n{\n\tstruct msghdr msghdr = {};\n\tstruct kvec iv;\n\tvoid *msg;\n\tint ret;\n\n\tmsg = qmi_encode_message(type,\n\t\t\t\t msg_id, &len,\n\t\t\t\t txn->id, ei,\n\t\t\t\t c_struct);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tiv.iov_base = msg;\n\tiv.iov_len = len;\n\n\tif (sq) {\n\t\tmsghdr.msg_name = sq;\n\t\tmsghdr.msg_namelen = sizeof(*sq);\n\t}\n\n\tmutex_lock(&qmi->sock_lock);\n\tif (qmi->sock) {\n\t\tret = kernel_sendmsg(qmi->sock, &msghdr, &iv, 1, len);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to send QMI message\\n\");\n\t} else {\n\t\tret = -EPIPE;\n\t}\n\tmutex_unlock(&qmi->sock_lock);\n\n\tkfree(msg);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n \nssize_t qmi_send_request(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t struct qmi_txn *txn, int msg_id, size_t len,\n\t\t\t const struct qmi_elem_info *ei, const void *c_struct)\n{\n\treturn qmi_send_message(qmi, sq, txn, QMI_REQUEST, msg_id, len, ei,\n\t\t\t\tc_struct);\n}\nEXPORT_SYMBOL(qmi_send_request);\n\n \nssize_t qmi_send_response(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t  struct qmi_txn *txn, int msg_id, size_t len,\n\t\t\t  const struct qmi_elem_info *ei, const void *c_struct)\n{\n\treturn qmi_send_message(qmi, sq, txn, QMI_RESPONSE, msg_id, len, ei,\n\t\t\t\tc_struct);\n}\nEXPORT_SYMBOL(qmi_send_response);\n\n \nssize_t qmi_send_indication(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t    int msg_id, size_t len,\n\t\t\t    const struct qmi_elem_info *ei,\n\t\t\t    const void *c_struct)\n{\n\tstruct qmi_txn txn;\n\tssize_t rval;\n\tint ret;\n\n\tret = qmi_txn_init(qmi, &txn, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trval = qmi_send_message(qmi, sq, &txn, QMI_INDICATION, msg_id, len, ei,\n\t\t\t\tc_struct);\n\n\t \n\tqmi_txn_cancel(&txn);\n\n\treturn rval;\n}\nEXPORT_SYMBOL(qmi_send_indication);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}