{
  "module_name": "pdr_interface.c",
  "hash_id": "1f591b013efe7982895565dba4d7064ecd75a22ed564f18909796885ca02b647",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/pdr_interface.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n\n#include \"pdr_internal.h\"\n\nstruct pdr_service {\n\tchar service_name[SERVREG_NAME_LENGTH + 1];\n\tchar service_path[SERVREG_NAME_LENGTH + 1];\n\n\tstruct sockaddr_qrtr addr;\n\n\tunsigned int instance;\n\tunsigned int service;\n\tu8 service_data_valid;\n\tu32 service_data;\n\tint state;\n\n\tbool need_notifier_register;\n\tbool need_notifier_remove;\n\tbool need_locator_lookup;\n\tbool service_connected;\n\n\tstruct list_head node;\n};\n\nstruct pdr_handle {\n\tstruct qmi_handle locator_hdl;\n\tstruct qmi_handle notifier_hdl;\n\n\tstruct sockaddr_qrtr locator_addr;\n\n\tstruct list_head lookups;\n\tstruct list_head indack_list;\n\n\t \n\tstruct mutex list_lock;\n\n\t \n\tstruct mutex status_lock;\n\n\t \n\tstruct mutex lock;\n\n\tbool locator_init_complete;\n\n\tstruct work_struct locator_work;\n\tstruct work_struct notifier_work;\n\tstruct work_struct indack_work;\n\n\tstruct workqueue_struct *notifier_wq;\n\tstruct workqueue_struct *indack_wq;\n\n\tvoid (*status)(int state, char *service_path, void *priv);\n\tvoid *priv;\n};\n\nstruct pdr_list_node {\n\tenum servreg_service_state curr_state;\n\tu16 transaction_id;\n\tstruct pdr_service *pds;\n\tstruct list_head node;\n};\n\nstatic int pdr_locator_new_server(struct qmi_handle *qmi,\n\t\t\t\t  struct qmi_service *svc)\n{\n\tstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\n\t\t\t\t\t      locator_hdl);\n\tstruct pdr_service *pds;\n\n\t \n\tpdr->locator_addr.sq_family = AF_QIPCRTR;\n\tpdr->locator_addr.sq_node = svc->node;\n\tpdr->locator_addr.sq_port = svc->port;\n\n\tmutex_lock(&pdr->lock);\n\tpdr->locator_init_complete = true;\n\tmutex_unlock(&pdr->lock);\n\n\t \n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(pds, &pdr->lookups, node) {\n\t\tif (pds->need_locator_lookup)\n\t\t\tschedule_work(&pdr->locator_work);\n\t}\n\tmutex_unlock(&pdr->list_lock);\n\n\treturn 0;\n}\n\nstatic void pdr_locator_del_server(struct qmi_handle *qmi,\n\t\t\t\t   struct qmi_service *svc)\n{\n\tstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\n\t\t\t\t\t      locator_hdl);\n\n\tmutex_lock(&pdr->lock);\n\tpdr->locator_init_complete = false;\n\tmutex_unlock(&pdr->lock);\n\n\tpdr->locator_addr.sq_node = 0;\n\tpdr->locator_addr.sq_port = 0;\n}\n\nstatic const struct qmi_ops pdr_locator_ops = {\n\t.new_server = pdr_locator_new_server,\n\t.del_server = pdr_locator_del_server,\n};\n\nstatic int pdr_register_listener(struct pdr_handle *pdr,\n\t\t\t\t struct pdr_service *pds,\n\t\t\t\t bool enable)\n{\n\tstruct servreg_register_listener_resp resp;\n\tstruct servreg_register_listener_req req;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tret = qmi_txn_init(&pdr->notifier_hdl, &txn,\n\t\t\t   servreg_register_listener_resp_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.enable = enable;\n\tstrscpy(req.service_path, pds->service_path, sizeof(req.service_path));\n\n\tret = qmi_send_request(&pdr->notifier_hdl, &pds->addr,\n\t\t\t       &txn, SERVREG_REGISTER_LISTENER_REQ,\n\t\t\t       SERVREG_REGISTER_LISTENER_REQ_LEN,\n\t\t\t       servreg_register_listener_req_ei,\n\t\t\t       &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\treturn ret;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0) {\n\t\tpr_err(\"PDR: %s register listener txn wait failed: %d\\n\",\n\t\t       pds->service_path, ret);\n\t\treturn ret;\n\t}\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tpr_err(\"PDR: %s register listener failed: 0x%x\\n\",\n\t\t       pds->service_path, resp.resp.error);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tpds->state = resp.curr_state;\n\n\treturn 0;\n}\n\nstatic void pdr_notifier_work(struct work_struct *work)\n{\n\tstruct pdr_handle *pdr = container_of(work, struct pdr_handle,\n\t\t\t\t\t      notifier_work);\n\tstruct pdr_service *pds;\n\tint ret;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(pds, &pdr->lookups, node) {\n\t\tif (pds->service_connected) {\n\t\t\tif (!pds->need_notifier_register)\n\t\t\t\tcontinue;\n\n\t\t\tpds->need_notifier_register = false;\n\t\t\tret = pdr_register_listener(pdr, pds, true);\n\t\t\tif (ret < 0)\n\t\t\t\tpds->state = SERVREG_SERVICE_STATE_DOWN;\n\t\t} else {\n\t\t\tif (!pds->need_notifier_remove)\n\t\t\t\tcontinue;\n\n\t\t\tpds->need_notifier_remove = false;\n\t\t\tpds->state = SERVREG_SERVICE_STATE_DOWN;\n\t\t}\n\n\t\tmutex_lock(&pdr->status_lock);\n\t\tpdr->status(pds->state, pds->service_path, pdr->priv);\n\t\tmutex_unlock(&pdr->status_lock);\n\t}\n\tmutex_unlock(&pdr->list_lock);\n}\n\nstatic int pdr_notifier_new_server(struct qmi_handle *qmi,\n\t\t\t\t   struct qmi_service *svc)\n{\n\tstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\n\t\t\t\t\t      notifier_hdl);\n\tstruct pdr_service *pds;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(pds, &pdr->lookups, node) {\n\t\tif (pds->service == svc->service &&\n\t\t    pds->instance == svc->instance) {\n\t\t\tpds->service_connected = true;\n\t\t\tpds->need_notifier_register = true;\n\t\t\tpds->addr.sq_family = AF_QIPCRTR;\n\t\t\tpds->addr.sq_node = svc->node;\n\t\t\tpds->addr.sq_port = svc->port;\n\t\t\tqueue_work(pdr->notifier_wq, &pdr->notifier_work);\n\t\t}\n\t}\n\tmutex_unlock(&pdr->list_lock);\n\n\treturn 0;\n}\n\nstatic void pdr_notifier_del_server(struct qmi_handle *qmi,\n\t\t\t\t    struct qmi_service *svc)\n{\n\tstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\n\t\t\t\t\t      notifier_hdl);\n\tstruct pdr_service *pds;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(pds, &pdr->lookups, node) {\n\t\tif (pds->service == svc->service &&\n\t\t    pds->instance == svc->instance) {\n\t\t\tpds->service_connected = false;\n\t\t\tpds->need_notifier_remove = true;\n\t\t\tpds->addr.sq_node = 0;\n\t\t\tpds->addr.sq_port = 0;\n\t\t\tqueue_work(pdr->notifier_wq, &pdr->notifier_work);\n\t\t}\n\t}\n\tmutex_unlock(&pdr->list_lock);\n}\n\nstatic const struct qmi_ops pdr_notifier_ops = {\n\t.new_server = pdr_notifier_new_server,\n\t.del_server = pdr_notifier_del_server,\n};\n\nstatic int pdr_send_indack_msg(struct pdr_handle *pdr, struct pdr_service *pds,\n\t\t\t       u16 tid)\n{\n\tstruct servreg_set_ack_resp resp;\n\tstruct servreg_set_ack_req req;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tret = qmi_txn_init(&pdr->notifier_hdl, &txn, servreg_set_ack_resp_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq.transaction_id = tid;\n\tstrscpy(req.service_path, pds->service_path, sizeof(req.service_path));\n\n\tret = qmi_send_request(&pdr->notifier_hdl, &pds->addr,\n\t\t\t       &txn, SERVREG_SET_ACK_REQ,\n\t\t\t       SERVREG_SET_ACK_REQ_LEN,\n\t\t\t       servreg_set_ack_req_ei,\n\t\t\t       &req);\n\n\t \n\tqmi_txn_cancel(&txn);\n\treturn ret;\n}\n\nstatic void pdr_indack_work(struct work_struct *work)\n{\n\tstruct pdr_handle *pdr = container_of(work, struct pdr_handle,\n\t\t\t\t\t      indack_work);\n\tstruct pdr_list_node *ind, *tmp;\n\tstruct pdr_service *pds;\n\n\tlist_for_each_entry_safe(ind, tmp, &pdr->indack_list, node) {\n\t\tpds = ind->pds;\n\n\t\tmutex_lock(&pdr->status_lock);\n\t\tpds->state = ind->curr_state;\n\t\tpdr->status(pds->state, pds->service_path, pdr->priv);\n\t\tmutex_unlock(&pdr->status_lock);\n\n\t\t \n\t\tpdr_send_indack_msg(pdr, pds, ind->transaction_id);\n\n\t\tmutex_lock(&pdr->list_lock);\n\t\tlist_del(&ind->node);\n\t\tmutex_unlock(&pdr->list_lock);\n\n\t\tkfree(ind);\n\t}\n}\n\nstatic void pdr_indication_cb(struct qmi_handle *qmi,\n\t\t\t      struct sockaddr_qrtr *sq,\n\t\t\t      struct qmi_txn *txn, const void *data)\n{\n\tstruct pdr_handle *pdr = container_of(qmi, struct pdr_handle,\n\t\t\t\t\t      notifier_hdl);\n\tconst struct servreg_state_updated_ind *ind_msg = data;\n\tstruct pdr_list_node *ind;\n\tstruct pdr_service *pds = NULL, *iter;\n\n\tif (!ind_msg || !ind_msg->service_path[0] ||\n\t    strlen(ind_msg->service_path) > SERVREG_NAME_LENGTH)\n\t\treturn;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(iter, &pdr->lookups, node) {\n\t\tif (strcmp(iter->service_path, ind_msg->service_path))\n\t\t\tcontinue;\n\n\t\tpds = iter;\n\t\tbreak;\n\t}\n\tmutex_unlock(&pdr->list_lock);\n\n\tif (!pds)\n\t\treturn;\n\n\tpr_info(\"PDR: Indication received from %s, state: 0x%x, trans-id: %d\\n\",\n\t\tind_msg->service_path, ind_msg->curr_state,\n\t\tind_msg->transaction_id);\n\n\tind = kzalloc(sizeof(*ind), GFP_KERNEL);\n\tif (!ind)\n\t\treturn;\n\n\tind->transaction_id = ind_msg->transaction_id;\n\tind->curr_state = ind_msg->curr_state;\n\tind->pds = pds;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_add_tail(&ind->node, &pdr->indack_list);\n\tmutex_unlock(&pdr->list_lock);\n\n\tqueue_work(pdr->indack_wq, &pdr->indack_work);\n}\n\nstatic const struct qmi_msg_handler qmi_indication_handler[] = {\n\t{\n\t\t.type = QMI_INDICATION,\n\t\t.msg_id = SERVREG_STATE_UPDATED_IND_ID,\n\t\t.ei = servreg_state_updated_ind_ei,\n\t\t.decoded_size = sizeof(struct servreg_state_updated_ind),\n\t\t.fn = pdr_indication_cb,\n\t},\n\t{}\n};\n\nstatic int pdr_get_domain_list(struct servreg_get_domain_list_req *req,\n\t\t\t       struct servreg_get_domain_list_resp *resp,\n\t\t\t       struct pdr_handle *pdr)\n{\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tret = qmi_txn_init(&pdr->locator_hdl, &txn,\n\t\t\t   servreg_get_domain_list_resp_ei, resp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = qmi_send_request(&pdr->locator_hdl,\n\t\t\t       &pdr->locator_addr,\n\t\t\t       &txn, SERVREG_GET_DOMAIN_LIST_REQ,\n\t\t\t       SERVREG_GET_DOMAIN_LIST_REQ_MAX_LEN,\n\t\t\t       servreg_get_domain_list_req_ei,\n\t\t\t       req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\treturn ret;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0) {\n\t\tpr_err(\"PDR: %s get domain list txn wait failed: %d\\n\",\n\t\t       req->service_name, ret);\n\t\treturn ret;\n\t}\n\n\tif (resp->resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tpr_err(\"PDR: %s get domain list failed: 0x%x\\n\",\n\t\t       req->service_name, resp->resp.error);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int pdr_locate_service(struct pdr_handle *pdr, struct pdr_service *pds)\n{\n\tstruct servreg_get_domain_list_resp *resp;\n\tstruct servreg_get_domain_list_req req;\n\tstruct servreg_location_entry *entry;\n\tint domains_read = 0;\n\tint ret, i;\n\n\tresp = kzalloc(sizeof(*resp), GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\t \n\tstrscpy(req.service_name, pds->service_name, sizeof(req.service_name));\n\treq.domain_offset_valid = true;\n\treq.domain_offset = 0;\n\n\tdo {\n\t\treq.domain_offset = domains_read;\n\t\tret = pdr_get_domain_list(&req, resp, pdr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tfor (i = domains_read; i < resp->domain_list_len; i++) {\n\t\t\tentry = &resp->domain_list[i];\n\n\t\t\tif (strnlen(entry->name, sizeof(entry->name)) == sizeof(entry->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (!strcmp(entry->name, pds->service_path)) {\n\t\t\t\tpds->service_data_valid = entry->service_data_valid;\n\t\t\t\tpds->service_data = entry->service_data;\n\t\t\t\tpds->instance = entry->instance;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = -ENXIO;\n\n\t\t \n\t\tif (resp->domain_list_len > resp->total_domains)\n\t\t\tresp->domain_list_len = resp->total_domains;\n\n\t\tdomains_read += resp->domain_list_len;\n\t} while (domains_read < resp->total_domains);\nout:\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic void pdr_notify_lookup_failure(struct pdr_handle *pdr,\n\t\t\t\t      struct pdr_service *pds,\n\t\t\t\t      int err)\n{\n\tpr_err(\"PDR: service lookup for %s failed: %d\\n\",\n\t       pds->service_name, err);\n\n\tif (err == -ENXIO)\n\t\treturn;\n\n\tlist_del(&pds->node);\n\tpds->state = SERVREG_LOCATOR_ERR;\n\tmutex_lock(&pdr->status_lock);\n\tpdr->status(pds->state, pds->service_path, pdr->priv);\n\tmutex_unlock(&pdr->status_lock);\n\tkfree(pds);\n}\n\nstatic void pdr_locator_work(struct work_struct *work)\n{\n\tstruct pdr_handle *pdr = container_of(work, struct pdr_handle,\n\t\t\t\t\t      locator_work);\n\tstruct pdr_service *pds, *tmp;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&pdr->lock);\n\tif (!pdr->locator_init_complete) {\n\t\tmutex_unlock(&pdr->lock);\n\t\tpr_debug(\"PDR: SERVICE LOCATOR service not available\\n\");\n\t\treturn;\n\t}\n\tmutex_unlock(&pdr->lock);\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry_safe(pds, tmp, &pdr->lookups, node) {\n\t\tif (!pds->need_locator_lookup)\n\t\t\tcontinue;\n\n\t\tret = pdr_locate_service(pdr, pds);\n\t\tif (ret < 0) {\n\t\t\tpdr_notify_lookup_failure(pdr, pds, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = qmi_add_lookup(&pdr->notifier_hdl, pds->service, 1,\n\t\t\t\t     pds->instance);\n\t\tif (ret < 0) {\n\t\t\tpdr_notify_lookup_failure(pdr, pds, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpds->need_locator_lookup = false;\n\t}\n\tmutex_unlock(&pdr->list_lock);\n}\n\n \nstruct pdr_service *pdr_add_lookup(struct pdr_handle *pdr,\n\t\t\t\t   const char *service_name,\n\t\t\t\t   const char *service_path)\n{\n\tstruct pdr_service *pds, *tmp;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(pdr))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!service_name || strlen(service_name) > SERVREG_NAME_LENGTH ||\n\t    !service_path || strlen(service_path) > SERVREG_NAME_LENGTH)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpds = kzalloc(sizeof(*pds), GFP_KERNEL);\n\tif (!pds)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpds->service = SERVREG_NOTIFIER_SERVICE;\n\tstrscpy(pds->service_name, service_name, sizeof(pds->service_name));\n\tstrscpy(pds->service_path, service_path, sizeof(pds->service_path));\n\tpds->need_locator_lookup = true;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(tmp, &pdr->lookups, node) {\n\t\tif (strcmp(tmp->service_path, service_path))\n\t\t\tcontinue;\n\n\t\tmutex_unlock(&pdr->list_lock);\n\t\tret = -EALREADY;\n\t\tgoto err;\n\t}\n\n\tlist_add(&pds->node, &pdr->lookups);\n\tmutex_unlock(&pdr->list_lock);\n\n\tschedule_work(&pdr->locator_work);\n\n\treturn pds;\nerr:\n\tkfree(pds);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(pdr_add_lookup);\n\n \nint pdr_restart_pd(struct pdr_handle *pdr, struct pdr_service *pds)\n{\n\tstruct servreg_restart_pd_resp resp;\n\tstruct servreg_restart_pd_req req = { 0 };\n\tstruct sockaddr_qrtr addr;\n\tstruct pdr_service *tmp;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(pdr) || IS_ERR_OR_NULL(pds))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry(tmp, &pdr->lookups, node) {\n\t\tif (tmp != pds)\n\t\t\tcontinue;\n\n\t\tif (!pds->service_connected)\n\t\t\tbreak;\n\n\t\t \n\t\tstrscpy(req.service_path, pds->service_path, sizeof(req.service_path));\n\t\taddr = pds->addr;\n\t\tbreak;\n\t}\n\tmutex_unlock(&pdr->list_lock);\n\n\tif (!req.service_path[0])\n\t\treturn -EINVAL;\n\n\tret = qmi_txn_init(&pdr->notifier_hdl, &txn,\n\t\t\t   servreg_restart_pd_resp_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = qmi_send_request(&pdr->notifier_hdl, &addr,\n\t\t\t       &txn, SERVREG_RESTART_PD_REQ,\n\t\t\t       SERVREG_RESTART_PD_REQ_MAX_LEN,\n\t\t\t       servreg_restart_pd_req_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\treturn ret;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0) {\n\t\tpr_err(\"PDR: %s PD restart txn wait failed: %d\\n\",\n\t\t       req.service_path, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (resp.resp.result == QMI_RESULT_FAILURE_V01 &&\n\t    resp.resp.error == QMI_ERR_DISABLED_V01) {\n\t\tpr_err(\"PDR: %s PD restart is disabled: 0x%x\\n\",\n\t\t       req.service_path, resp.resp.error);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tpr_err(\"PDR: %s request for PD restart failed: 0x%x\\n\",\n\t\t       req.service_path, resp.resp.error);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pdr_restart_pd);\n\n \nstruct pdr_handle *pdr_handle_alloc(void (*status)(int state,\n\t\t\t\t\t\t   char *service_path,\n\t\t\t\t\t\t   void *priv), void *priv)\n{\n\tstruct pdr_handle *pdr;\n\tint ret;\n\n\tif (!status)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpdr = kzalloc(sizeof(*pdr), GFP_KERNEL);\n\tif (!pdr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdr->status = status;\n\tpdr->priv = priv;\n\n\tmutex_init(&pdr->status_lock);\n\tmutex_init(&pdr->list_lock);\n\tmutex_init(&pdr->lock);\n\n\tINIT_LIST_HEAD(&pdr->lookups);\n\tINIT_LIST_HEAD(&pdr->indack_list);\n\n\tINIT_WORK(&pdr->locator_work, pdr_locator_work);\n\tINIT_WORK(&pdr->notifier_work, pdr_notifier_work);\n\tINIT_WORK(&pdr->indack_work, pdr_indack_work);\n\n\tpdr->notifier_wq = create_singlethread_workqueue(\"pdr_notifier_wq\");\n\tif (!pdr->notifier_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pdr_handle;\n\t}\n\n\tpdr->indack_wq = alloc_ordered_workqueue(\"pdr_indack_wq\", WQ_HIGHPRI);\n\tif (!pdr->indack_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto destroy_notifier;\n\t}\n\n\tret = qmi_handle_init(&pdr->locator_hdl,\n\t\t\t      SERVREG_GET_DOMAIN_LIST_RESP_MAX_LEN,\n\t\t\t      &pdr_locator_ops, NULL);\n\tif (ret < 0)\n\t\tgoto destroy_indack;\n\n\tret = qmi_add_lookup(&pdr->locator_hdl, SERVREG_LOCATOR_SERVICE, 1, 1);\n\tif (ret < 0)\n\t\tgoto release_qmi_handle;\n\n\tret = qmi_handle_init(&pdr->notifier_hdl,\n\t\t\t      SERVREG_STATE_UPDATED_IND_MAX_LEN,\n\t\t\t      &pdr_notifier_ops,\n\t\t\t      qmi_indication_handler);\n\tif (ret < 0)\n\t\tgoto release_qmi_handle;\n\n\treturn pdr;\n\nrelease_qmi_handle:\n\tqmi_handle_release(&pdr->locator_hdl);\ndestroy_indack:\n\tdestroy_workqueue(pdr->indack_wq);\ndestroy_notifier:\n\tdestroy_workqueue(pdr->notifier_wq);\nfree_pdr_handle:\n\tkfree(pdr);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(pdr_handle_alloc);\n\n \nvoid pdr_handle_release(struct pdr_handle *pdr)\n{\n\tstruct pdr_service *pds, *tmp;\n\n\tif (IS_ERR_OR_NULL(pdr))\n\t\treturn;\n\n\tmutex_lock(&pdr->list_lock);\n\tlist_for_each_entry_safe(pds, tmp, &pdr->lookups, node) {\n\t\tlist_del(&pds->node);\n\t\tkfree(pds);\n\t}\n\tmutex_unlock(&pdr->list_lock);\n\n\tcancel_work_sync(&pdr->locator_work);\n\tcancel_work_sync(&pdr->notifier_work);\n\tcancel_work_sync(&pdr->indack_work);\n\n\tdestroy_workqueue(pdr->notifier_wq);\n\tdestroy_workqueue(pdr->indack_wq);\n\n\tqmi_handle_release(&pdr->locator_hdl);\n\tqmi_handle_release(&pdr->notifier_hdl);\n\n\tkfree(pdr);\n}\nEXPORT_SYMBOL(pdr_handle_release);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm Protection Domain Restart helpers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}