{
  "module_name": "spm.c",
  "hash_id": "7e884b97601926946b1628dadeb6e4b933895e4455949ed860554cd586b90680",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/spm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <soc/qcom/spm.h>\n\n#define SPM_CTL_INDEX\t\t0x7f\n#define SPM_CTL_INDEX_SHIFT\t4\n#define SPM_CTL_EN\t\tBIT(0)\n\nenum spm_reg {\n\tSPM_REG_CFG,\n\tSPM_REG_SPM_CTL,\n\tSPM_REG_DLY,\n\tSPM_REG_PMIC_DLY,\n\tSPM_REG_PMIC_DATA_0,\n\tSPM_REG_PMIC_DATA_1,\n\tSPM_REG_VCTL,\n\tSPM_REG_SEQ_ENTRY,\n\tSPM_REG_SPM_STS,\n\tSPM_REG_PMIC_STS,\n\tSPM_REG_AVS_CTL,\n\tSPM_REG_AVS_LIMIT,\n\tSPM_REG_NR,\n};\n\nstatic const u16 spm_reg_offset_v4_1[SPM_REG_NR] = {\n\t[SPM_REG_AVS_CTL]\t= 0x904,\n\t[SPM_REG_AVS_LIMIT]\t= 0x908,\n};\n\nstatic const struct spm_reg_data spm_reg_660_gold_l2  = {\n\t.reg_offset = spm_reg_offset_v4_1,\n\t.avs_ctl = 0x1010031,\n\t.avs_limit = 0x4580458,\n};\n\nstatic const struct spm_reg_data spm_reg_660_silver_l2  = {\n\t.reg_offset = spm_reg_offset_v4_1,\n\t.avs_ctl = 0x101c031,\n\t.avs_limit = 0x4580458,\n};\n\nstatic const struct spm_reg_data spm_reg_8998_gold_l2  = {\n\t.reg_offset = spm_reg_offset_v4_1,\n\t.avs_ctl = 0x1010031,\n\t.avs_limit = 0x4700470,\n};\n\nstatic const struct spm_reg_data spm_reg_8998_silver_l2  = {\n\t.reg_offset = spm_reg_offset_v4_1,\n\t.avs_ctl = 0x1010031,\n\t.avs_limit = 0x4200420,\n};\n\nstatic const u16 spm_reg_offset_v3_0[SPM_REG_NR] = {\n\t[SPM_REG_CFG]\t\t= 0x08,\n\t[SPM_REG_SPM_CTL]\t= 0x30,\n\t[SPM_REG_DLY]\t\t= 0x34,\n\t[SPM_REG_SEQ_ENTRY]\t= 0x400,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8909_cpu = {\n\t.reg_offset = spm_reg_offset_v3_0,\n\t.spm_cfg = 0x1,\n\t.spm_dly = 0x3C102800,\n\t.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,\n\t\t0x5B, 0x60, 0x03, 0x60, 0x76, 0x76, 0x0B, 0x94, 0x5B, 0x80,\n\t\t0x10, 0x26, 0x30, 0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 5,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8916_cpu = {\n\t.reg_offset = spm_reg_offset_v3_0,\n\t.spm_cfg = 0x1,\n\t.spm_dly = 0x3C102800,\n\t.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,\n\t\t0x5B, 0x60, 0x03, 0x60, 0x3B, 0x76, 0x76, 0x0B, 0x94, 0x5B,\n\t\t0x80, 0x10, 0x26, 0x30, 0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 5,\n};\n\nstatic const struct spm_reg_data spm_reg_8939_cpu = {\n\t.reg_offset = spm_reg_offset_v3_0,\n\t.spm_cfg = 0x1,\n\t.spm_dly = 0x3C102800,\n\t.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x50, 0x1B, 0x10, 0x80,\n\t\t0x30, 0x90, 0x5B, 0x60, 0x50, 0x03, 0x60, 0x76, 0x76, 0x0B,\n\t\t0x50, 0x1B, 0x94, 0x5B, 0x80, 0x10, 0x26, 0x30, 0x50, 0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 5,\n};\n\nstatic const u16 spm_reg_offset_v2_3[SPM_REG_NR] = {\n\t[SPM_REG_CFG]\t\t= 0x08,\n\t[SPM_REG_SPM_CTL]\t= 0x30,\n\t[SPM_REG_DLY]\t\t= 0x34,\n\t[SPM_REG_PMIC_DATA_0]\t= 0x40,\n\t[SPM_REG_PMIC_DATA_1]\t= 0x44,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8976_gold_l2 = {\n\t.reg_offset = spm_reg_offset_v2_3,\n\t.spm_cfg = 0x14,\n\t.spm_dly = 0x3c11840a,\n\t.pmic_data[0] = 0x03030080,\n\t.pmic_data[1] = 0x00030000,\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 3,\n};\n\nstatic const struct spm_reg_data spm_reg_8976_silver_l2 = {\n\t.reg_offset = spm_reg_offset_v2_3,\n\t.spm_cfg = 0x14,\n\t.spm_dly = 0x3c102800,\n\t.pmic_data[0] = 0x03030080,\n\t.pmic_data[1] = 0x00030000,\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 2,\n};\n\nstatic const u16 spm_reg_offset_v2_1[SPM_REG_NR] = {\n\t[SPM_REG_CFG]\t\t= 0x08,\n\t[SPM_REG_SPM_CTL]\t= 0x30,\n\t[SPM_REG_DLY]\t\t= 0x34,\n\t[SPM_REG_SEQ_ENTRY]\t= 0x80,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8974_8084_cpu  = {\n\t.reg_offset = spm_reg_offset_v2_1,\n\t.spm_cfg = 0x1,\n\t.spm_dly = 0x3C102800,\n\t.seq = { 0x03, 0x0B, 0x0F, 0x00, 0x20, 0x80, 0x10, 0xE8, 0x5B, 0x03,\n\t\t0x3B, 0xE8, 0x5B, 0x82, 0x10, 0x0B, 0x30, 0x06, 0x26, 0x30,\n\t\t0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 3,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8226_cpu  = {\n\t.reg_offset = spm_reg_offset_v2_1,\n\t.spm_cfg = 0x0,\n\t.spm_dly = 0x3C102800,\n\t.seq = { 0x60, 0x03, 0x60, 0x0B, 0x0F, 0x20, 0x10, 0x80, 0x30, 0x90,\n\t\t0x5B, 0x60, 0x03, 0x60, 0x3B, 0x76, 0x76, 0x0B, 0x94, 0x5B,\n\t\t0x80, 0x10, 0x26, 0x30, 0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 5,\n};\n\nstatic const u16 spm_reg_offset_v1_1[SPM_REG_NR] = {\n\t[SPM_REG_CFG]\t\t= 0x08,\n\t[SPM_REG_SPM_CTL]\t= 0x20,\n\t[SPM_REG_PMIC_DLY]\t= 0x24,\n\t[SPM_REG_PMIC_DATA_0]\t= 0x28,\n\t[SPM_REG_PMIC_DATA_1]\t= 0x2C,\n\t[SPM_REG_SEQ_ENTRY]\t= 0x80,\n};\n\n \nstatic const struct spm_reg_data spm_reg_8064_cpu = {\n\t.reg_offset = spm_reg_offset_v1_1,\n\t.spm_cfg = 0x1F,\n\t.pmic_dly = 0x02020004,\n\t.pmic_data[0] = 0x0084009C,\n\t.pmic_data[1] = 0x00A4001C,\n\t.seq = { 0x03, 0x0F, 0x00, 0x24, 0x54, 0x10, 0x09, 0x03, 0x01,\n\t\t0x10, 0x54, 0x30, 0x0C, 0x24, 0x30, 0x0F },\n\t.start_index[PM_SLEEP_MODE_STBY] = 0,\n\t.start_index[PM_SLEEP_MODE_SPC] = 2,\n};\n\nstatic inline void spm_register_write(struct spm_driver_data *drv,\n\t\t\t\t\tenum spm_reg reg, u32 val)\n{\n\tif (drv->reg_data->reg_offset[reg])\n\t\twritel_relaxed(val, drv->reg_base +\n\t\t\t\tdrv->reg_data->reg_offset[reg]);\n}\n\n \nstatic inline void spm_register_write_sync(struct spm_driver_data *drv,\n\t\t\t\t\tenum spm_reg reg, u32 val)\n{\n\tu32 ret;\n\n\tif (!drv->reg_data->reg_offset[reg])\n\t\treturn;\n\n\tdo {\n\t\twritel_relaxed(val, drv->reg_base +\n\t\t\t\tdrv->reg_data->reg_offset[reg]);\n\t\tret = readl_relaxed(drv->reg_base +\n\t\t\t\tdrv->reg_data->reg_offset[reg]);\n\t\tif (ret == val)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t} while (1);\n}\n\nstatic inline u32 spm_register_read(struct spm_driver_data *drv,\n\t\t\t\t    enum spm_reg reg)\n{\n\treturn readl_relaxed(drv->reg_base + drv->reg_data->reg_offset[reg]);\n}\n\nvoid spm_set_low_power_mode(struct spm_driver_data *drv,\n\t\t\t    enum pm_sleep_mode mode)\n{\n\tu32 start_index;\n\tu32 ctl_val;\n\n\tstart_index = drv->reg_data->start_index[mode];\n\n\tctl_val = spm_register_read(drv, SPM_REG_SPM_CTL);\n\tctl_val &= ~(SPM_CTL_INDEX << SPM_CTL_INDEX_SHIFT);\n\tctl_val |= start_index << SPM_CTL_INDEX_SHIFT;\n\tctl_val |= SPM_CTL_EN;\n\tspm_register_write_sync(drv, SPM_REG_SPM_CTL, ctl_val);\n}\n\nstatic const struct of_device_id spm_match_table[] = {\n\t{ .compatible = \"qcom,sdm660-gold-saw2-v4.1-l2\",\n\t  .data = &spm_reg_660_gold_l2 },\n\t{ .compatible = \"qcom,sdm660-silver-saw2-v4.1-l2\",\n\t  .data = &spm_reg_660_silver_l2 },\n\t{ .compatible = \"qcom,msm8226-saw2-v2.1-cpu\",\n\t  .data = &spm_reg_8226_cpu },\n\t{ .compatible = \"qcom,msm8909-saw2-v3.0-cpu\",\n\t  .data = &spm_reg_8909_cpu },\n\t{ .compatible = \"qcom,msm8916-saw2-v3.0-cpu\",\n\t  .data = &spm_reg_8916_cpu },\n\t{ .compatible = \"qcom,msm8939-saw2-v3.0-cpu\",\n\t  .data = &spm_reg_8939_cpu },\n\t{ .compatible = \"qcom,msm8974-saw2-v2.1-cpu\",\n\t  .data = &spm_reg_8974_8084_cpu },\n\t{ .compatible = \"qcom,msm8976-gold-saw2-v2.3-l2\",\n\t  .data = &spm_reg_8976_gold_l2 },\n\t{ .compatible = \"qcom,msm8976-silver-saw2-v2.3-l2\",\n\t  .data = &spm_reg_8976_silver_l2 },\n\t{ .compatible = \"qcom,msm8998-gold-saw2-v4.1-l2\",\n\t  .data = &spm_reg_8998_gold_l2 },\n\t{ .compatible = \"qcom,msm8998-silver-saw2-v4.1-l2\",\n\t  .data = &spm_reg_8998_silver_l2 },\n\t{ .compatible = \"qcom,apq8084-saw2-v2.1-cpu\",\n\t  .data = &spm_reg_8974_8084_cpu },\n\t{ .compatible = \"qcom,apq8064-saw2-v1.1-cpu\",\n\t  .data = &spm_reg_8064_cpu },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, spm_match_table);\n\nstatic int spm_dev_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match_id;\n\tstruct spm_driver_data *drv;\n\tvoid __iomem *addr;\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tdrv->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drv->reg_base))\n\t\treturn PTR_ERR(drv->reg_base);\n\n\tmatch_id = of_match_node(spm_match_table, pdev->dev.of_node);\n\tif (!match_id)\n\t\treturn -ENODEV;\n\n\tdrv->reg_data = match_id->data;\n\tplatform_set_drvdata(pdev, drv);\n\n\t \n\taddr = drv->reg_base + drv->reg_data->reg_offset[SPM_REG_SEQ_ENTRY];\n\t__iowrite32_copy(addr, drv->reg_data->seq,\n\t\t\tARRAY_SIZE(drv->reg_data->seq) / 4);\n\n\t \n\tspm_register_write(drv, SPM_REG_AVS_CTL, drv->reg_data->avs_ctl);\n\tspm_register_write(drv, SPM_REG_AVS_LIMIT, drv->reg_data->avs_limit);\n\tspm_register_write(drv, SPM_REG_CFG, drv->reg_data->spm_cfg);\n\tspm_register_write(drv, SPM_REG_DLY, drv->reg_data->spm_dly);\n\tspm_register_write(drv, SPM_REG_PMIC_DLY, drv->reg_data->pmic_dly);\n\tspm_register_write(drv, SPM_REG_PMIC_DATA_0,\n\t\t\t\tdrv->reg_data->pmic_data[0]);\n\tspm_register_write(drv, SPM_REG_PMIC_DATA_1,\n\t\t\t\tdrv->reg_data->pmic_data[1]);\n\n\t \n\tif (drv->reg_data->reg_offset[SPM_REG_SPM_CTL])\n\t\tspm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);\n\n\treturn 0;\n}\n\nstatic struct platform_driver spm_driver = {\n\t.probe = spm_dev_probe,\n\t.driver = {\n\t\t.name = \"qcom_spm\",\n\t\t.of_match_table = spm_match_table,\n\t},\n};\n\nstatic int __init qcom_spm_init(void)\n{\n\treturn platform_driver_register(&spm_driver);\n}\narch_initcall(qcom_spm_init);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}