{
  "module_name": "pdr_internal.h",
  "hash_id": "b1cf73f34a49cbf13f658d1b4f3503f2a65b0b2ec5bd1aef24a8d37fc77685dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/pdr_internal.h",
  "human_readable_source": " \n#ifndef __QCOM_PDR_HELPER_INTERNAL__\n#define __QCOM_PDR_HELPER_INTERNAL__\n\n#include <linux/soc/qcom/pdr.h>\n\n#define SERVREG_LOCATOR_SERVICE\t\t\t\t0x40\n#define SERVREG_NOTIFIER_SERVICE\t\t\t0x42\n\n#define SERVREG_REGISTER_LISTENER_REQ\t\t\t0x20\n#define SERVREG_GET_DOMAIN_LIST_REQ\t\t\t0x21\n#define SERVREG_STATE_UPDATED_IND_ID\t\t\t0x22\n#define SERVREG_SET_ACK_REQ\t\t\t\t0x23\n#define SERVREG_RESTART_PD_REQ\t\t\t\t0x24\n\n#define SERVREG_DOMAIN_LIST_LENGTH\t\t\t32\n#define SERVREG_RESTART_PD_REQ_MAX_LEN\t\t\t67\n#define SERVREG_REGISTER_LISTENER_REQ_LEN\t\t71\n#define SERVREG_SET_ACK_REQ_LEN\t\t\t\t72\n#define SERVREG_GET_DOMAIN_LIST_REQ_MAX_LEN\t\t74\n#define SERVREG_STATE_UPDATED_IND_MAX_LEN\t\t79\n#define SERVREG_GET_DOMAIN_LIST_RESP_MAX_LEN\t\t2389\n\nstruct servreg_location_entry {\n\tchar name[SERVREG_NAME_LENGTH + 1];\n\tu8 service_data_valid;\n\tu32 service_data;\n\tu32 instance;\n};\n\nstatic const struct qmi_elem_info servreg_location_entry_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0,\n\t\t.offset         = offsetof(struct servreg_location_entry,\n\t\t\t\t\t   name),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0,\n\t\t.offset         = offsetof(struct servreg_location_entry,\n\t\t\t\t\t   instance),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0,\n\t\t.offset         = offsetof(struct servreg_location_entry,\n\t\t\t\t\t   service_data_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0,\n\t\t.offset         = offsetof(struct servreg_location_entry,\n\t\t\t\t\t   service_data),\n\t},\n\t{}\n};\n\nstruct servreg_get_domain_list_req {\n\tchar service_name[SERVREG_NAME_LENGTH + 1];\n\tu8 domain_offset_valid;\n\tu32 domain_offset;\n};\n\nstatic const struct qmi_elem_info servreg_get_domain_list_req_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x01,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_req,\n\t\t\t\t\t   service_name),\n\t},\n\t{\n\t\t.data_type      = QMI_OPT_FLAG,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_req,\n\t\t\t\t\t   domain_offset_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_req,\n\t\t\t\t\t   domain_offset),\n\t},\n\t{}\n};\n\nstruct servreg_get_domain_list_resp {\n\tstruct qmi_response_type_v01 resp;\n\tu8 total_domains_valid;\n\tu16 total_domains;\n\tu8 db_rev_count_valid;\n\tu16 db_rev_count;\n\tu8 domain_list_valid;\n\tu32 domain_list_len;\n\tstruct servreg_location_entry domain_list[SERVREG_DOMAIN_LIST_LENGTH];\n};\n\nstatic const struct qmi_elem_info servreg_get_domain_list_resp_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRUCT,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   resp),\n\t\t.ei_array      = qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type      = QMI_OPT_FLAG,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   total_domains_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_2_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   total_domains),\n\t},\n\t{\n\t\t.data_type      = QMI_OPT_FLAG,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x11,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   db_rev_count_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_2_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x11,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   db_rev_count),\n\t},\n\t{\n\t\t.data_type      = QMI_OPT_FLAG,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x12,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   domain_list_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_DATA_LEN,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x12,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   domain_list_len),\n\t},\n\t{\n\t\t.data_type      = QMI_STRUCT,\n\t\t.elem_len       = SERVREG_DOMAIN_LIST_LENGTH,\n\t\t.elem_size      = sizeof(struct servreg_location_entry),\n\t\t.array_type\t= VAR_LEN_ARRAY,\n\t\t.tlv_type       = 0x12,\n\t\t.offset         = offsetof(struct servreg_get_domain_list_resp,\n\t\t\t\t\t   domain_list),\n\t\t.ei_array      = servreg_location_entry_ei,\n\t},\n\t{}\n};\n\nstruct servreg_register_listener_req {\n\tu8 enable;\n\tchar service_path[SERVREG_NAME_LENGTH + 1];\n};\n\nstatic const struct qmi_elem_info servreg_register_listener_req_ei[] = {\n\t{\n\t\t.data_type      = QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x01,\n\t\t.offset         = offsetof(struct servreg_register_listener_req,\n\t\t\t\t\t   enable),\n\t},\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_register_listener_req,\n\t\t\t\t\t   service_path),\n\t},\n\t{}\n};\n\nstruct servreg_register_listener_resp {\n\tstruct qmi_response_type_v01 resp;\n\tu8 curr_state_valid;\n\tenum servreg_service_state curr_state;\n};\n\nstatic const struct qmi_elem_info servreg_register_listener_resp_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRUCT,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_register_listener_resp,\n\t\t\t\t\t   resp),\n\t\t.ei_array      = qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type      = QMI_OPT_FLAG,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_register_listener_resp,\n\t\t\t\t\t   curr_state_valid),\n\t},\n\t{\n\t\t.data_type      = QMI_SIGNED_4_BYTE_ENUM,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(enum servreg_service_state),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x10,\n\t\t.offset         = offsetof(struct servreg_register_listener_resp,\n\t\t\t\t\t   curr_state),\n\t},\n\t{}\n};\n\nstruct servreg_restart_pd_req {\n\tchar service_path[SERVREG_NAME_LENGTH + 1];\n};\n\nstatic const struct qmi_elem_info servreg_restart_pd_req_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x01,\n\t\t.offset         = offsetof(struct servreg_restart_pd_req,\n\t\t\t\t\t   service_path),\n\t},\n\t{}\n};\n\nstruct servreg_restart_pd_resp {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstatic const struct qmi_elem_info servreg_restart_pd_resp_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRUCT,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_restart_pd_resp,\n\t\t\t\t\t   resp),\n\t\t.ei_array      = qmi_response_type_v01_ei,\n\t},\n\t{}\n};\n\nstruct servreg_state_updated_ind {\n\tenum servreg_service_state curr_state;\n\tchar service_path[SERVREG_NAME_LENGTH + 1];\n\tu16 transaction_id;\n};\n\nstatic const struct qmi_elem_info servreg_state_updated_ind_ei[] = {\n\t{\n\t\t.data_type      = QMI_SIGNED_4_BYTE_ENUM,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x01,\n\t\t.offset         = offsetof(struct servreg_state_updated_ind,\n\t\t\t\t\t   curr_state),\n\t},\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_state_updated_ind,\n\t\t\t\t\t   service_path),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_2_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x03,\n\t\t.offset         = offsetof(struct servreg_state_updated_ind,\n\t\t\t\t\t   transaction_id),\n\t},\n\t{}\n};\n\nstruct servreg_set_ack_req {\n\tchar service_path[SERVREG_NAME_LENGTH + 1];\n\tu16 transaction_id;\n};\n\nstatic const struct qmi_elem_info servreg_set_ack_req_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRING,\n\t\t.elem_len       = SERVREG_NAME_LENGTH + 1,\n\t\t.elem_size      = sizeof(char),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x01,\n\t\t.offset         = offsetof(struct servreg_set_ack_req,\n\t\t\t\t\t   service_path),\n\t},\n\t{\n\t\t.data_type      = QMI_UNSIGNED_2_BYTE,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_set_ack_req,\n\t\t\t\t\t   transaction_id),\n\t},\n\t{}\n};\n\nstruct servreg_set_ack_resp {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstatic const struct qmi_elem_info servreg_set_ack_resp_ei[] = {\n\t{\n\t\t.data_type      = QMI_STRUCT,\n\t\t.elem_len       = 1,\n\t\t.elem_size      = sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type       = 0x02,\n\t\t.offset         = offsetof(struct servreg_set_ack_resp,\n\t\t\t\t\t   resp),\n\t\t.ei_array       = qmi_response_type_v01_ei,\n\t},\n\t{}\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}