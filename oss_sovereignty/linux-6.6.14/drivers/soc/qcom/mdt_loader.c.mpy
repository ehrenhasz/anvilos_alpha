{
  "module_name": "mdt_loader.c",
  "hash_id": "0dd1426fe5dad57e4bf299574862293a7e7e6595b1de81d89cb0802876b2f771",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/mdt_loader.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/elf.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/mdt_loader.h>\n\nstatic bool mdt_phdr_valid(const struct elf32_phdr *phdr)\n{\n\tif (phdr->p_type != PT_LOAD)\n\t\treturn false;\n\n\tif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\n\t\treturn false;\n\n\tif (!phdr->p_memsz)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic ssize_t mdt_load_split_segment(void *ptr, const struct elf32_phdr *phdrs,\n\t\t\t\t      unsigned int segment, const char *fw_name,\n\t\t\t\t      struct device *dev)\n{\n\tconst struct elf32_phdr *phdr = &phdrs[segment];\n\tconst struct firmware *seg_fw;\n\tchar *seg_name;\n\tssize_t ret;\n\n\tif (strlen(fw_name) < 4)\n\t\treturn -EINVAL;\n\n\tseg_name = kstrdup(fw_name, GFP_KERNEL);\n\tif (!seg_name)\n\t\treturn -ENOMEM;\n\n\tsprintf(seg_name + strlen(fw_name) - 3, \"b%02d\", segment);\n\tret = request_firmware_into_buf(&seg_fw, seg_name, dev,\n\t\t\t\t\tptr, phdr->p_filesz);\n\tif (ret) {\n\t\tdev_err(dev, \"error %zd loading %s\\n\", ret, seg_name);\n\t\tkfree(seg_name);\n\t\treturn ret;\n\t}\n\n\tif (seg_fw->size != phdr->p_filesz) {\n\t\tdev_err(dev,\n\t\t\t\"failed to load segment %d from truncated file %s\\n\",\n\t\t\tsegment, seg_name);\n\t\tret = -EINVAL;\n\t}\n\n\trelease_firmware(seg_fw);\n\tkfree(seg_name);\n\n\treturn ret;\n}\n\n \nssize_t qcom_mdt_get_size(const struct firmware *fw)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct elf32_hdr *ehdr;\n\tphys_addr_t min_addr = PHYS_ADDR_MAX;\n\tphys_addr_t max_addr = 0;\n\tint i;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!mdt_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\tif (phdr->p_paddr < min_addr)\n\t\t\tmin_addr = phdr->p_paddr;\n\n\t\tif (phdr->p_paddr + phdr->p_memsz > max_addr)\n\t\t\tmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\n\t}\n\n\treturn min_addr < max_addr ? max_addr - min_addr : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(qcom_mdt_get_size);\n\n \nvoid *qcom_mdt_read_metadata(const struct firmware *fw, size_t *data_len,\n\t\t\t     const char *fw_name, struct device *dev)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_hdr *ehdr;\n\tunsigned int hash_segment = 0;\n\tsize_t hash_offset;\n\tsize_t hash_size;\n\tsize_t ehdr_size;\n\tunsigned int i;\n\tssize_t ret;\n\tvoid *data;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tif (ehdr->e_phnum < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (phdrs[0].p_type == PT_LOAD)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 1; i < ehdr->e_phnum; i++) {\n\t\tif ((phdrs[i].p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH) {\n\t\t\thash_segment = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!hash_segment) {\n\t\tdev_err(dev, \"no hash segment found in %s\\n\", fw_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tehdr_size = phdrs[0].p_filesz;\n\thash_size = phdrs[hash_segment].p_filesz;\n\n\tdata = kmalloc(ehdr_size + hash_size, GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmemcpy(data, fw->data, ehdr_size);\n\n\tif (ehdr_size + hash_size == fw->size) {\n\t\t \n\t\thash_offset = phdrs[0].p_filesz;\n\t\tmemcpy(data + ehdr_size, fw->data + hash_offset, hash_size);\n\t} else if (phdrs[hash_segment].p_offset + hash_size <= fw->size) {\n\t\t \n\t\thash_offset = phdrs[hash_segment].p_offset;\n\t\tmemcpy(data + ehdr_size, fw->data + hash_offset, hash_size);\n\t} else {\n\t\t \n\t\tret = mdt_load_split_segment(data + ehdr_size, phdrs, hash_segment, fw_name, dev);\n\t\tif (ret) {\n\t\t\tkfree(data);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\t*data_len = ehdr_size + hash_size;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(qcom_mdt_read_metadata);\n\n \nint qcom_mdt_pas_init(struct device *dev, const struct firmware *fw,\n\t\t      const char *fw_name, int pas_id, phys_addr_t mem_phys,\n\t\t      struct qcom_scm_pas_metadata *ctx)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct elf32_hdr *ehdr;\n\tphys_addr_t min_addr = PHYS_ADDR_MAX;\n\tphys_addr_t max_addr = 0;\n\tbool relocate = false;\n\tsize_t metadata_len;\n\tvoid *metadata;\n\tint ret;\n\tint i;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!mdt_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\n\t\t\trelocate = true;\n\n\t\tif (phdr->p_paddr < min_addr)\n\t\t\tmin_addr = phdr->p_paddr;\n\n\t\tif (phdr->p_paddr + phdr->p_memsz > max_addr)\n\t\t\tmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\n\t}\n\n\tmetadata = qcom_mdt_read_metadata(fw, &metadata_len, fw_name, dev);\n\tif (IS_ERR(metadata)) {\n\t\tret = PTR_ERR(metadata);\n\t\tdev_err(dev, \"error %d reading firmware %s metadata\\n\", ret, fw_name);\n\t\tgoto out;\n\t}\n\n\tret = qcom_scm_pas_init_image(pas_id, metadata, metadata_len, ctx);\n\tkfree(metadata);\n\tif (ret) {\n\t\t \n\t\tdev_err(dev, \"error %d initializing firmware %s\\n\", ret, fw_name);\n\t\tgoto out;\n\t}\n\n\tif (relocate) {\n\t\tret = qcom_scm_pas_mem_setup(pas_id, mem_phys, max_addr - min_addr);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(dev, \"error %d setting up firmware %s\\n\", ret, fw_name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_mdt_pas_init);\n\nstatic bool qcom_mdt_bins_are_split(const struct firmware *fw, const char *fw_name)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_hdr *ehdr;\n\tuint64_t seg_start, seg_end;\n\tint i;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t \n\t\tif (!phdrs[i].p_filesz)\n\t\t\tcontinue;\n\n\t\tseg_start = phdrs[i].p_offset;\n\t\tseg_end = phdrs[i].p_offset + phdrs[i].p_filesz;\n\t\tif (seg_start > fw->size || seg_end > fw->size)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __qcom_mdt_load(struct device *dev, const struct firmware *fw,\n\t\t\t   const char *fw_name, int pas_id, void *mem_region,\n\t\t\t   phys_addr_t mem_phys, size_t mem_size,\n\t\t\t   phys_addr_t *reloc_base, bool pas_init)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct elf32_hdr *ehdr;\n\tphys_addr_t mem_reloc;\n\tphys_addr_t min_addr = PHYS_ADDR_MAX;\n\tssize_t offset;\n\tbool relocate = false;\n\tbool is_split;\n\tvoid *ptr;\n\tint ret = 0;\n\tint i;\n\n\tif (!fw || !mem_region || !mem_phys || !mem_size)\n\t\treturn -EINVAL;\n\n\tis_split = qcom_mdt_bins_are_split(fw, fw_name);\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!mdt_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\n\t\t\trelocate = true;\n\n\t\tif (phdr->p_paddr < min_addr)\n\t\t\tmin_addr = phdr->p_paddr;\n\t}\n\n\tif (relocate) {\n\t\t \n\t\tmem_reloc = min_addr;\n\t} else {\n\t\t \n\t\tmem_reloc = mem_phys;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!mdt_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\toffset = phdr->p_paddr - mem_reloc;\n\t\tif (offset < 0 || offset + phdr->p_memsz > mem_size) {\n\t\t\tdev_err(dev, \"segment outside memory range\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (phdr->p_filesz > phdr->p_memsz) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"refusing to load segment %d with p_filesz > p_memsz\\n\",\n\t\t\t\ti);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tptr = mem_region + offset;\n\n\t\tif (phdr->p_filesz && !is_split) {\n\t\t\t \n\t\t\tif (phdr->p_offset + phdr->p_filesz > fw->size) {\n\t\t\t\tdev_err(dev, \"file %s segment %d would be truncated\\n\",\n\t\t\t\t\tfw_name, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(ptr, fw->data + phdr->p_offset, phdr->p_filesz);\n\t\t} else if (phdr->p_filesz) {\n\t\t\t \n\t\t\tret = mdt_load_split_segment(ptr, phdrs, i, fw_name, dev);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (phdr->p_memsz > phdr->p_filesz)\n\t\t\tmemset(ptr + phdr->p_filesz, 0, phdr->p_memsz - phdr->p_filesz);\n\t}\n\n\tif (reloc_base)\n\t\t*reloc_base = mem_reloc;\n\n\treturn ret;\n}\n\n \nint qcom_mdt_load(struct device *dev, const struct firmware *fw,\n\t\t  const char *firmware, int pas_id, void *mem_region,\n\t\t  phys_addr_t mem_phys, size_t mem_size,\n\t\t  phys_addr_t *reloc_base)\n{\n\tint ret;\n\n\tret = qcom_mdt_pas_init(dev, fw, firmware, pas_id, mem_phys, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __qcom_mdt_load(dev, fw, firmware, pas_id, mem_region, mem_phys,\n\t\t\t       mem_size, reloc_base, true);\n}\nEXPORT_SYMBOL_GPL(qcom_mdt_load);\n\n \nint qcom_mdt_load_no_init(struct device *dev, const struct firmware *fw,\n\t\t\t  const char *firmware, int pas_id,\n\t\t\t  void *mem_region, phys_addr_t mem_phys,\n\t\t\t  size_t mem_size, phys_addr_t *reloc_base)\n{\n\treturn __qcom_mdt_load(dev, fw, firmware, pas_id, mem_region, mem_phys,\n\t\t\t       mem_size, reloc_base, false);\n}\nEXPORT_SYMBOL_GPL(qcom_mdt_load_no_init);\n\nMODULE_DESCRIPTION(\"Firmware parser for Qualcomm MDT format\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}