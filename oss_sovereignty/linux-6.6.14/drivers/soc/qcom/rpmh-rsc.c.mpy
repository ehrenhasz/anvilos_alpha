{
  "module_name": "rpmh-rsc.c",
  "hash_id": "442380caeaf214b5766e98cee769ee6c3f9197bdd91a47eba70a7383f655ae4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/rpmh-rsc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s \" fmt, KBUILD_MODNAME\n\n#include <linux/atomic.h>\n#include <linux/cpu_pm.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n\n#include <clocksource/arm_arch_timer.h>\n#include <soc/qcom/cmd-db.h>\n#include <soc/qcom/tcs.h>\n#include <dt-bindings/soc/qcom,rpmh-rsc.h>\n\n#include \"rpmh-internal.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace-rpmh.h\"\n\n\n#define RSC_DRV_ID\t\t\t0\n\n#define MAJOR_VER_MASK\t\t\t0xFF\n#define MAJOR_VER_SHIFT\t\t\t16\n#define MINOR_VER_MASK\t\t\t0xFF\n#define MINOR_VER_SHIFT\t\t\t8\n\nenum {\n\tRSC_DRV_TCS_OFFSET,\n\tRSC_DRV_CMD_OFFSET,\n\tDRV_SOLVER_CONFIG,\n\tDRV_PRNT_CHLD_CONFIG,\n\tRSC_DRV_IRQ_ENABLE,\n\tRSC_DRV_IRQ_STATUS,\n\tRSC_DRV_IRQ_CLEAR,\n\tRSC_DRV_CMD_WAIT_FOR_CMPL,\n\tRSC_DRV_CONTROL,\n\tRSC_DRV_STATUS,\n\tRSC_DRV_CMD_ENABLE,\n\tRSC_DRV_CMD_MSGID,\n\tRSC_DRV_CMD_ADDR,\n\tRSC_DRV_CMD_DATA,\n\tRSC_DRV_CMD_STATUS,\n\tRSC_DRV_CMD_RESP_DATA,\n};\n\n \n#define DRV_HW_SOLVER_MASK\t\t1\n#define DRV_HW_SOLVER_SHIFT\t\t24\n\n \n#define DRV_NUM_TCS_MASK\t\t0x3F\n#define DRV_NUM_TCS_SHIFT\t\t6\n#define DRV_NCPT_MASK\t\t\t0x1F\n#define DRV_NCPT_SHIFT\t\t\t27\n\n \n#define RSC_DRV_CTL_TCS_DATA_HI\t\t0x38\n#define RSC_DRV_CTL_TCS_DATA_HI_MASK\t0xFFFFFF\n#define RSC_DRV_CTL_TCS_DATA_HI_VALID\tBIT(31)\n#define RSC_DRV_CTL_TCS_DATA_LO\t\t0x40\n#define RSC_DRV_CTL_TCS_DATA_LO_MASK\t0xFFFFFFFF\n#define RSC_DRV_CTL_TCS_DATA_SIZE\t32\n\n#define TCS_AMC_MODE_ENABLE\t\tBIT(16)\n#define TCS_AMC_MODE_TRIGGER\t\tBIT(24)\n\n \n#define CMD_MSGID_LEN\t\t\t8\n#define CMD_MSGID_RESP_REQ\t\tBIT(8)\n#define CMD_MSGID_WRITE\t\t\tBIT(16)\n#define CMD_STATUS_ISSUED\t\tBIT(8)\n#define CMD_STATUS_COMPL\t\tBIT(16)\n\n \n\n#define USECS_TO_CYCLES(time_usecs)\t\t\t\\\n\txloops_to_cycles((time_usecs) * 0x10C7UL)\n\nstatic inline unsigned long xloops_to_cycles(u64 xloops)\n{\n\treturn (xloops * loops_per_jiffy * HZ) >> 32;\n}\n\nstatic u32 rpmh_rsc_reg_offset_ver_2_7[] = {\n\t[RSC_DRV_TCS_OFFSET]\t\t= 672,\n\t[RSC_DRV_CMD_OFFSET]\t\t= 20,\n\t[DRV_SOLVER_CONFIG]\t\t= 0x04,\n\t[DRV_PRNT_CHLD_CONFIG]\t\t= 0x0C,\n\t[RSC_DRV_IRQ_ENABLE]\t\t= 0x00,\n\t[RSC_DRV_IRQ_STATUS]\t\t= 0x04,\n\t[RSC_DRV_IRQ_CLEAR]\t\t= 0x08,\n\t[RSC_DRV_CMD_WAIT_FOR_CMPL]\t= 0x10,\n\t[RSC_DRV_CONTROL]\t\t= 0x14,\n\t[RSC_DRV_STATUS]\t\t= 0x18,\n\t[RSC_DRV_CMD_ENABLE]\t\t= 0x1C,\n\t[RSC_DRV_CMD_MSGID]\t\t= 0x30,\n\t[RSC_DRV_CMD_ADDR]\t\t= 0x34,\n\t[RSC_DRV_CMD_DATA]\t\t= 0x38,\n\t[RSC_DRV_CMD_STATUS]\t\t= 0x3C,\n\t[RSC_DRV_CMD_RESP_DATA]\t\t= 0x40,\n};\n\nstatic u32 rpmh_rsc_reg_offset_ver_3_0[] = {\n\t[RSC_DRV_TCS_OFFSET]\t\t= 672,\n\t[RSC_DRV_CMD_OFFSET]\t\t= 24,\n\t[DRV_SOLVER_CONFIG]\t\t= 0x04,\n\t[DRV_PRNT_CHLD_CONFIG]\t\t= 0x0C,\n\t[RSC_DRV_IRQ_ENABLE]\t\t= 0x00,\n\t[RSC_DRV_IRQ_STATUS]\t\t= 0x04,\n\t[RSC_DRV_IRQ_CLEAR]\t\t= 0x08,\n\t[RSC_DRV_CMD_WAIT_FOR_CMPL]\t= 0x20,\n\t[RSC_DRV_CONTROL]\t\t= 0x24,\n\t[RSC_DRV_STATUS]\t\t= 0x28,\n\t[RSC_DRV_CMD_ENABLE]\t\t= 0x2C,\n\t[RSC_DRV_CMD_MSGID]\t\t= 0x34,\n\t[RSC_DRV_CMD_ADDR]\t\t= 0x38,\n\t[RSC_DRV_CMD_DATA]\t\t= 0x3C,\n\t[RSC_DRV_CMD_STATUS]\t\t= 0x40,\n\t[RSC_DRV_CMD_RESP_DATA]\t\t= 0x44,\n};\n\nstatic inline void __iomem *\ntcs_reg_addr(const struct rsc_drv *drv, int reg, int tcs_id)\n{\n\treturn drv->tcs_base + drv->regs[RSC_DRV_TCS_OFFSET] * tcs_id + reg;\n}\n\nstatic inline void __iomem *\ntcs_cmd_addr(const struct rsc_drv *drv, int reg, int tcs_id, int cmd_id)\n{\n\treturn tcs_reg_addr(drv, reg, tcs_id) + drv->regs[RSC_DRV_CMD_OFFSET] * cmd_id;\n}\n\nstatic u32 read_tcs_cmd(const struct rsc_drv *drv, int reg, int tcs_id,\n\t\t\tint cmd_id)\n{\n\treturn readl_relaxed(tcs_cmd_addr(drv, reg, tcs_id, cmd_id));\n}\n\nstatic u32 read_tcs_reg(const struct rsc_drv *drv, int reg, int tcs_id)\n{\n\treturn readl_relaxed(tcs_reg_addr(drv, reg, tcs_id));\n}\n\nstatic void write_tcs_cmd(const struct rsc_drv *drv, int reg, int tcs_id,\n\t\t\t  int cmd_id, u32 data)\n{\n\twritel_relaxed(data, tcs_cmd_addr(drv, reg, tcs_id, cmd_id));\n}\n\nstatic void write_tcs_reg(const struct rsc_drv *drv, int reg, int tcs_id,\n\t\t\t  u32 data)\n{\n\twritel_relaxed(data, tcs_reg_addr(drv, reg, tcs_id));\n}\n\nstatic void write_tcs_reg_sync(const struct rsc_drv *drv, int reg, int tcs_id,\n\t\t\t       u32 data)\n{\n\tint i;\n\n\twritel(data, tcs_reg_addr(drv, reg, tcs_id));\n\n\t \n\tfor (i = 0; i < USEC_PER_SEC; i++) {\n\t\tif (readl(tcs_reg_addr(drv, reg, tcs_id)) == data)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\tpr_err(\"%s: error writing %#x to %d:%#x\\n\", drv->name,\n\t       data, tcs_id, reg);\n}\n\n \nstatic void tcs_invalidate(struct rsc_drv *drv, int type)\n{\n\tint m;\n\tstruct tcs_group *tcs = &drv->tcs[type];\n\n\t \n\tif (bitmap_empty(tcs->slots, MAX_TCS_SLOTS))\n\t\treturn;\n\n\tfor (m = tcs->offset; m < tcs->offset + tcs->num_tcs; m++)\n\t\twrite_tcs_reg_sync(drv, drv->regs[RSC_DRV_CMD_ENABLE], m, 0);\n\n\tbitmap_zero(tcs->slots, MAX_TCS_SLOTS);\n}\n\n \nvoid rpmh_rsc_invalidate(struct rsc_drv *drv)\n{\n\ttcs_invalidate(drv, SLEEP_TCS);\n\ttcs_invalidate(drv, WAKE_TCS);\n}\n\n \nstatic struct tcs_group *get_tcs_for_msg(struct rsc_drv *drv,\n\t\t\t\t\t const struct tcs_request *msg)\n{\n\tint type;\n\tstruct tcs_group *tcs;\n\n\tswitch (msg->state) {\n\tcase RPMH_ACTIVE_ONLY_STATE:\n\t\ttype = ACTIVE_TCS;\n\t\tbreak;\n\tcase RPMH_WAKE_ONLY_STATE:\n\t\ttype = WAKE_TCS;\n\t\tbreak;\n\tcase RPMH_SLEEP_STATE:\n\t\ttype = SLEEP_TCS;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\ttcs = &drv->tcs[type];\n\tif (msg->state == RPMH_ACTIVE_ONLY_STATE && !tcs->num_tcs)\n\t\ttcs = &drv->tcs[WAKE_TCS];\n\n\treturn tcs;\n}\n\n \nstatic const struct tcs_request *get_req_from_tcs(struct rsc_drv *drv,\n\t\t\t\t\t\t  int tcs_id)\n{\n\tstruct tcs_group *tcs;\n\tint i;\n\n\tfor (i = 0; i < TCS_TYPE_NR; i++) {\n\t\ttcs = &drv->tcs[i];\n\t\tif (tcs->mask & BIT(tcs_id))\n\t\t\treturn tcs->req[tcs_id - tcs->offset];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void __tcs_set_trigger(struct rsc_drv *drv, int tcs_id, bool trigger)\n{\n\tu32 enable;\n\tu32 reg = drv->regs[RSC_DRV_CONTROL];\n\n\t \n\tenable = read_tcs_reg(drv, reg, tcs_id);\n\tenable &= ~TCS_AMC_MODE_TRIGGER;\n\twrite_tcs_reg_sync(drv, reg, tcs_id, enable);\n\tenable &= ~TCS_AMC_MODE_ENABLE;\n\twrite_tcs_reg_sync(drv, reg, tcs_id, enable);\n\n\tif (trigger) {\n\t\t \n\t\tenable = TCS_AMC_MODE_ENABLE;\n\t\twrite_tcs_reg_sync(drv, reg, tcs_id, enable);\n\t\tenable |= TCS_AMC_MODE_TRIGGER;\n\t\twrite_tcs_reg(drv, reg, tcs_id, enable);\n\t}\n}\n\n \nstatic void enable_tcs_irq(struct rsc_drv *drv, int tcs_id, bool enable)\n{\n\tu32 data;\n\tu32 reg = drv->regs[RSC_DRV_IRQ_ENABLE];\n\n\tdata = readl_relaxed(drv->tcs_base + reg);\n\tif (enable)\n\t\tdata |= BIT(tcs_id);\n\telse\n\t\tdata &= ~BIT(tcs_id);\n\twritel_relaxed(data, drv->tcs_base + reg);\n}\n\n \nstatic irqreturn_t tcs_tx_done(int irq, void *p)\n{\n\tstruct rsc_drv *drv = p;\n\tint i;\n\tunsigned long irq_status;\n\tconst struct tcs_request *req;\n\n\tirq_status = readl_relaxed(drv->tcs_base + drv->regs[RSC_DRV_IRQ_STATUS]);\n\n\tfor_each_set_bit(i, &irq_status, BITS_PER_TYPE(u32)) {\n\t\treq = get_req_from_tcs(drv, i);\n\t\tif (WARN_ON(!req))\n\t\t\tgoto skip;\n\n\t\ttrace_rpmh_tx_done(drv, i, req);\n\n\t\t \n\t\tif (!drv->tcs[ACTIVE_TCS].num_tcs)\n\t\t\t__tcs_set_trigger(drv, i, false);\nskip:\n\t\t \n\t\twrite_tcs_reg(drv, drv->regs[RSC_DRV_CMD_ENABLE], i, 0);\n\t\twritel_relaxed(BIT(i), drv->tcs_base + drv->regs[RSC_DRV_IRQ_CLEAR]);\n\t\tspin_lock(&drv->lock);\n\t\tclear_bit(i, drv->tcs_in_use);\n\t\t \n\t\tif (!drv->tcs[ACTIVE_TCS].num_tcs)\n\t\t\tenable_tcs_irq(drv, i, false);\n\t\tspin_unlock(&drv->lock);\n\t\twake_up(&drv->tcs_wait);\n\t\tif (req)\n\t\t\trpmh_tx_done(req);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void __tcs_buffer_write(struct rsc_drv *drv, int tcs_id, int cmd_id,\n\t\t\t       const struct tcs_request *msg)\n{\n\tu32 msgid;\n\tu32 cmd_msgid = CMD_MSGID_LEN | CMD_MSGID_WRITE;\n\tu32 cmd_enable = 0;\n\tstruct tcs_cmd *cmd;\n\tint i, j;\n\n\t \n\tcmd_msgid |= msg->wait_for_compl ? CMD_MSGID_RESP_REQ : 0;\n\n\tfor (i = 0, j = cmd_id; i < msg->num_cmds; i++, j++) {\n\t\tcmd = &msg->cmds[i];\n\t\tcmd_enable |= BIT(j);\n\t\tmsgid = cmd_msgid;\n\t\t \n\t\tmsgid |= cmd->wait ? CMD_MSGID_RESP_REQ : 0;\n\n\t\twrite_tcs_cmd(drv, drv->regs[RSC_DRV_CMD_MSGID], tcs_id, j, msgid);\n\t\twrite_tcs_cmd(drv, drv->regs[RSC_DRV_CMD_ADDR], tcs_id, j, cmd->addr);\n\t\twrite_tcs_cmd(drv, drv->regs[RSC_DRV_CMD_DATA], tcs_id, j, cmd->data);\n\t\ttrace_rpmh_send_msg(drv, tcs_id, msg->state, j, msgid, cmd);\n\t}\n\n\tcmd_enable |= read_tcs_reg(drv, drv->regs[RSC_DRV_CMD_ENABLE], tcs_id);\n\twrite_tcs_reg(drv, drv->regs[RSC_DRV_CMD_ENABLE], tcs_id, cmd_enable);\n}\n\n \nstatic int check_for_req_inflight(struct rsc_drv *drv, struct tcs_group *tcs,\n\t\t\t\t  const struct tcs_request *msg)\n{\n\tunsigned long curr_enabled;\n\tu32 addr;\n\tint j, k;\n\tint i = tcs->offset;\n\n\tfor_each_set_bit_from(i, drv->tcs_in_use, tcs->offset + tcs->num_tcs) {\n\t\tcurr_enabled = read_tcs_reg(drv, drv->regs[RSC_DRV_CMD_ENABLE], i);\n\n\t\tfor_each_set_bit(j, &curr_enabled, MAX_CMDS_PER_TCS) {\n\t\t\taddr = read_tcs_cmd(drv, drv->regs[RSC_DRV_CMD_ADDR], i, j);\n\t\t\tfor (k = 0; k < msg->num_cmds; k++) {\n\t\t\t\tif (addr == msg->cmds[k].addr)\n\t\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int find_free_tcs(struct tcs_group *tcs)\n{\n\tconst struct rsc_drv *drv = tcs->drv;\n\tunsigned long i;\n\tunsigned long max = tcs->offset + tcs->num_tcs;\n\n\ti = find_next_zero_bit(drv->tcs_in_use, max, tcs->offset);\n\tif (i >= max)\n\t\treturn -EBUSY;\n\n\treturn i;\n}\n\n \nstatic int claim_tcs_for_req(struct rsc_drv *drv, struct tcs_group *tcs,\n\t\t\t     const struct tcs_request *msg)\n{\n\tint ret;\n\n\t \n\tret = check_for_req_inflight(drv, tcs, msg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn find_free_tcs(tcs);\n}\n\n \nint rpmh_rsc_send_data(struct rsc_drv *drv, const struct tcs_request *msg)\n{\n\tstruct tcs_group *tcs;\n\tint tcs_id;\n\tunsigned long flags;\n\n\ttcs = get_tcs_for_msg(drv, msg);\n\tif (IS_ERR(tcs))\n\t\treturn PTR_ERR(tcs);\n\n\tspin_lock_irqsave(&drv->lock, flags);\n\n\t \n\twait_event_lock_irq(drv->tcs_wait,\n\t\t\t    (tcs_id = claim_tcs_for_req(drv, tcs, msg)) >= 0,\n\t\t\t    drv->lock);\n\n\ttcs->req[tcs_id - tcs->offset] = msg;\n\tset_bit(tcs_id, drv->tcs_in_use);\n\tif (msg->state == RPMH_ACTIVE_ONLY_STATE && tcs->type != ACTIVE_TCS) {\n\t\t \n\t\twrite_tcs_reg_sync(drv, drv->regs[RSC_DRV_CMD_ENABLE], tcs_id, 0);\n\t\tenable_tcs_irq(drv, tcs_id, true);\n\t}\n\tspin_unlock_irqrestore(&drv->lock, flags);\n\n\t \n\t__tcs_buffer_write(drv, tcs_id, 0, msg);\n\t__tcs_set_trigger(drv, tcs_id, true);\n\n\treturn 0;\n}\n\n \nstatic int find_slots(struct tcs_group *tcs, const struct tcs_request *msg,\n\t\t      int *tcs_id, int *cmd_id)\n{\n\tint slot, offset;\n\tint i = 0;\n\n\t \n\tdo {\n\t\tslot = bitmap_find_next_zero_area(tcs->slots, MAX_TCS_SLOTS,\n\t\t\t\t\t\t  i, msg->num_cmds, 0);\n\t\tif (slot >= tcs->num_tcs * tcs->ncpt)\n\t\t\treturn -ENOMEM;\n\t\ti += tcs->ncpt;\n\t} while (slot + msg->num_cmds - 1 >= i);\n\n\tbitmap_set(tcs->slots, slot, msg->num_cmds);\n\n\toffset = slot / tcs->ncpt;\n\t*tcs_id = offset + tcs->offset;\n\t*cmd_id = slot % tcs->ncpt;\n\n\treturn 0;\n}\n\n \nint rpmh_rsc_write_ctrl_data(struct rsc_drv *drv, const struct tcs_request *msg)\n{\n\tstruct tcs_group *tcs;\n\tint tcs_id = 0, cmd_id = 0;\n\tint ret;\n\n\ttcs = get_tcs_for_msg(drv, msg);\n\tif (IS_ERR(tcs))\n\t\treturn PTR_ERR(tcs);\n\n\t \n\tret = find_slots(tcs, msg, &tcs_id, &cmd_id);\n\tif (!ret)\n\t\t__tcs_buffer_write(drv, tcs_id, cmd_id, msg);\n\n\treturn ret;\n}\n\n \nstatic bool rpmh_rsc_ctrlr_is_busy(struct rsc_drv *drv)\n{\n\tunsigned long set;\n\tconst struct tcs_group *tcs = &drv->tcs[ACTIVE_TCS];\n\tunsigned long max;\n\n\t \n\tif (!tcs->num_tcs)\n\t\ttcs = &drv->tcs[WAKE_TCS];\n\n\tmax = tcs->offset + tcs->num_tcs;\n\tset = find_next_bit(drv->tcs_in_use, max, tcs->offset);\n\n\treturn set < max;\n}\n\n \nvoid rpmh_rsc_write_next_wakeup(struct rsc_drv *drv)\n{\n\tktime_t now, wakeup;\n\tu64 wakeup_us, wakeup_cycles = ~0;\n\tu32 lo, hi;\n\n\tif (!drv->tcs[CONTROL_TCS].num_tcs || !drv->genpd_nb.notifier_call)\n\t\treturn;\n\n\t \n\tif (system_state == SYSTEM_SUSPEND)\n\t\tgoto exit;\n\n\t \n\twakeup = dev_pm_genpd_get_next_hrtimer(drv->dev);\n\n\t \n\tnow = ktime_get();\n\twakeup = ktime_sub(wakeup, now);\n\twakeup_us = ktime_to_us(wakeup);\n\n\t \n\twakeup_cycles = USECS_TO_CYCLES(wakeup_us);\n\twakeup_cycles += arch_timer_read_counter();\n\nexit:\n\tlo = wakeup_cycles & RSC_DRV_CTL_TCS_DATA_LO_MASK;\n\thi = wakeup_cycles >> RSC_DRV_CTL_TCS_DATA_SIZE;\n\thi &= RSC_DRV_CTL_TCS_DATA_HI_MASK;\n\thi |= RSC_DRV_CTL_TCS_DATA_HI_VALID;\n\n\twritel_relaxed(lo, drv->base + RSC_DRV_CTL_TCS_DATA_LO);\n\twritel_relaxed(hi, drv->base + RSC_DRV_CTL_TCS_DATA_HI);\n}\n\n \nstatic int rpmh_rsc_cpu_pm_callback(struct notifier_block *nfb,\n\t\t\t\t    unsigned long action, void *v)\n{\n\tstruct rsc_drv *drv = container_of(nfb, struct rsc_drv, rsc_pm);\n\tint ret = NOTIFY_OK;\n\tint cpus_in_pm;\n\n\tswitch (action) {\n\tcase CPU_PM_ENTER:\n\t\tcpus_in_pm = atomic_inc_return(&drv->cpus_in_pm);\n\t\t \n\t\tif (cpus_in_pm < num_online_cpus())\n\t\t\treturn NOTIFY_OK;\n\t\tbreak;\n\tcase CPU_PM_ENTER_FAILED:\n\tcase CPU_PM_EXIT:\n\t\tatomic_dec(&drv->cpus_in_pm);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\t \n\tif (spin_trylock(&drv->lock)) {\n\t\tif (rpmh_rsc_ctrlr_is_busy(drv) || rpmh_flush(&drv->client))\n\t\t\tret = NOTIFY_BAD;\n\t\tspin_unlock(&drv->lock);\n\t} else {\n\t\t \n\t\treturn NOTIFY_OK;\n\t}\n\n\tif (ret == NOTIFY_BAD) {\n\t\t \n\t\tif (cpus_in_pm < num_online_cpus())\n\t\t\tret = NOTIFY_OK;\n\t\telse\n\t\t\t \n\t\t\tatomic_dec(&drv->cpus_in_pm);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int rpmh_rsc_pd_callback(struct notifier_block *nfb,\n\t\t\t\tunsigned long action, void *v)\n{\n\tstruct rsc_drv *drv = container_of(nfb, struct rsc_drv, genpd_nb);\n\n\t \n\tif ((action == GENPD_NOTIFY_PRE_OFF) &&\n\t    (rpmh_rsc_ctrlr_is_busy(drv) || rpmh_flush(&drv->client)))\n\t\treturn NOTIFY_BAD;\n\n\treturn NOTIFY_OK;\n}\n\nstatic int rpmh_rsc_pd_attach(struct rsc_drv *drv, struct device *dev)\n{\n\tint ret;\n\n\tpm_runtime_enable(dev);\n\tdrv->genpd_nb.notifier_call = rpmh_rsc_pd_callback;\n\tret = dev_pm_genpd_add_notifier(dev, &drv->genpd_nb);\n\tif (ret)\n\t\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int rpmh_probe_tcs_config(struct platform_device *pdev, struct rsc_drv *drv)\n{\n\tstruct tcs_type_config {\n\t\tu32 type;\n\t\tu32 n;\n\t} tcs_cfg[TCS_TYPE_NR] = { { 0 } };\n\tstruct device_node *dn = pdev->dev.of_node;\n\tu32 config, max_tcs, ncpt, offset;\n\tint i, ret, n, st = 0;\n\tstruct tcs_group *tcs;\n\n\tret = of_property_read_u32(dn, \"qcom,tcs-offset\", &offset);\n\tif (ret)\n\t\treturn ret;\n\tdrv->tcs_base = drv->base + offset;\n\n\tconfig = readl_relaxed(drv->base + drv->regs[DRV_PRNT_CHLD_CONFIG]);\n\n\tmax_tcs = config;\n\tmax_tcs &= DRV_NUM_TCS_MASK << (DRV_NUM_TCS_SHIFT * drv->id);\n\tmax_tcs = max_tcs >> (DRV_NUM_TCS_SHIFT * drv->id);\n\n\tncpt = config & (DRV_NCPT_MASK << DRV_NCPT_SHIFT);\n\tncpt = ncpt >> DRV_NCPT_SHIFT;\n\n\tn = of_property_count_u32_elems(dn, \"qcom,tcs-config\");\n\tif (n != 2 * TCS_TYPE_NR)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < TCS_TYPE_NR; i++) {\n\t\tret = of_property_read_u32_index(dn, \"qcom,tcs-config\",\n\t\t\t\t\t\t i * 2, &tcs_cfg[i].type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tcs_cfg[i].type >= TCS_TYPE_NR)\n\t\t\treturn -EINVAL;\n\n\t\tret = of_property_read_u32_index(dn, \"qcom,tcs-config\",\n\t\t\t\t\t\t i * 2 + 1, &tcs_cfg[i].n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (tcs_cfg[i].n > MAX_TCS_PER_TYPE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < TCS_TYPE_NR; i++) {\n\t\ttcs = &drv->tcs[tcs_cfg[i].type];\n\t\tif (tcs->drv)\n\t\t\treturn -EINVAL;\n\t\ttcs->drv = drv;\n\t\ttcs->type = tcs_cfg[i].type;\n\t\ttcs->num_tcs = tcs_cfg[i].n;\n\t\ttcs->ncpt = ncpt;\n\n\t\tif (!tcs->num_tcs || tcs->type == CONTROL_TCS)\n\t\t\tcontinue;\n\n\t\tif (st + tcs->num_tcs > max_tcs ||\n\t\t    st + tcs->num_tcs >= BITS_PER_BYTE * sizeof(tcs->mask))\n\t\t\treturn -EINVAL;\n\n\t\ttcs->mask = ((1 << tcs->num_tcs) - 1) << st;\n\t\ttcs->offset = st;\n\t\tst += tcs->num_tcs;\n\t}\n\n\tdrv->num_tcs = st;\n\n\treturn 0;\n}\n\nstatic int rpmh_rsc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct rsc_drv *drv;\n\tchar drv_id[10] = {0};\n\tint ret, irq;\n\tu32 solver_config;\n\tu32 rsc_id;\n\n\t \n\tret = cmd_db_ready();\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Command DB not available (%d)\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(dn, \"qcom,drv-id\", &drv->id);\n\tif (ret)\n\t\treturn ret;\n\n\tdrv->name = of_get_property(dn, \"label\", NULL);\n\tif (!drv->name)\n\t\tdrv->name = dev_name(&pdev->dev);\n\n\tsnprintf(drv_id, ARRAY_SIZE(drv_id), \"drv-%d\", drv->id);\n\tdrv->base = devm_platform_ioremap_resource_byname(pdev, drv_id);\n\tif (IS_ERR(drv->base))\n\t\treturn PTR_ERR(drv->base);\n\n\trsc_id = readl_relaxed(drv->base + RSC_DRV_ID);\n\tdrv->ver.major = rsc_id & (MAJOR_VER_MASK << MAJOR_VER_SHIFT);\n\tdrv->ver.major >>= MAJOR_VER_SHIFT;\n\tdrv->ver.minor = rsc_id & (MINOR_VER_MASK << MINOR_VER_SHIFT);\n\tdrv->ver.minor >>= MINOR_VER_SHIFT;\n\n\tif (drv->ver.major == 3)\n\t\tdrv->regs = rpmh_rsc_reg_offset_ver_3_0;\n\telse\n\t\tdrv->regs = rpmh_rsc_reg_offset_ver_2_7;\n\n\tret = rpmh_probe_tcs_config(pdev, drv);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&drv->lock);\n\tinit_waitqueue_head(&drv->tcs_wait);\n\tbitmap_zero(drv->tcs_in_use, MAX_TCS_NR);\n\n\tirq = platform_get_irq(pdev, drv->id);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, tcs_tx_done,\n\t\t\t       IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND,\n\t\t\t       drv->name, drv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsolver_config = readl_relaxed(drv->base + drv->regs[DRV_SOLVER_CONFIG]);\n\tsolver_config &= DRV_HW_SOLVER_MASK << DRV_HW_SOLVER_SHIFT;\n\tsolver_config = solver_config >> DRV_HW_SOLVER_SHIFT;\n\tif (!solver_config) {\n\t\tif (pdev->dev.pm_domain) {\n\t\t\tret = rpmh_rsc_pd_attach(drv, &pdev->dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tdrv->rsc_pm.notifier_call = rpmh_rsc_cpu_pm_callback;\n\t\t\tcpu_pm_register_notifier(&drv->rsc_pm);\n\t\t}\n\t}\n\n\t \n\twritel_relaxed(drv->tcs[ACTIVE_TCS].mask,\n\t\t       drv->tcs_base + drv->regs[RSC_DRV_IRQ_ENABLE]);\n\n\tspin_lock_init(&drv->client.cache_lock);\n\tINIT_LIST_HEAD(&drv->client.cache);\n\tINIT_LIST_HEAD(&drv->client.batch_cache);\n\n\tdev_set_drvdata(&pdev->dev, drv);\n\tdrv->dev = &pdev->dev;\n\n\tret = devm_of_platform_populate(&pdev->dev);\n\tif (ret && pdev->dev.pm_domain) {\n\t\tdev_pm_genpd_remove_notifier(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id rpmh_drv_match[] = {\n\t{ .compatible = \"qcom,rpmh-rsc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rpmh_drv_match);\n\nstatic struct platform_driver rpmh_driver = {\n\t.probe = rpmh_rsc_probe,\n\t.driver = {\n\t\t  .name = \"rpmh\",\n\t\t  .of_match_table = rpmh_drv_match,\n\t\t  .suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init rpmh_driver_init(void)\n{\n\treturn platform_driver_register(&rpmh_driver);\n}\narch_initcall(rpmh_driver_init);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. RPMh Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}