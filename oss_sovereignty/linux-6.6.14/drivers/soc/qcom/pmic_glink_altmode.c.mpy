{
  "module_name": "pmic_glink_altmode.c",
  "hash_id": "2bcfca1a3563bfd4b2ea64ac25afdadb4ebf0d390ccf513d8413fd25bac432eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/pmic_glink_altmode.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/soc/qcom/pdr.h>\n#include <drm/drm_bridge.h>\n\n#include <linux/usb/typec_altmode.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/usb/typec_retimer.h>\n\n#include <linux/soc/qcom/pmic_glink.h>\n\n#define PMIC_GLINK_MAX_PORTS\t2\n\n#define USBC_SC8180X_NOTIFY_IND\t0x13\n#define USBC_CMD_WRITE_REQ      0x15\n#define USBC_NOTIFY_IND\t\t0x16\n\n#define ALTMODE_PAN_EN\t\t0x10\n#define ALTMODE_PAN_ACK\t\t0x11\n\nstruct usbc_write_req {\n\tstruct pmic_glink_hdr   hdr;\n\t__le32 cmd;\n\t__le32 arg;\n\t__le32 reserved;\n};\n\n#define NOTIFY_PAYLOAD_SIZE 16\nstruct usbc_notify {\n\tstruct pmic_glink_hdr hdr;\n\tchar payload[NOTIFY_PAYLOAD_SIZE];\n\tu32 reserved;\n};\n\nstruct usbc_sc8180x_notify {\n\tstruct pmic_glink_hdr hdr;\n\t__le32 notification;\n\t__le32 reserved[2];\n};\n\nenum pmic_glink_altmode_pin_assignment {\n\tDPAM_HPD_OUT,\n\tDPAM_HPD_A,\n\tDPAM_HPD_B,\n\tDPAM_HPD_C,\n\tDPAM_HPD_D,\n\tDPAM_HPD_E,\n\tDPAM_HPD_F,\n};\n\nstruct pmic_glink_altmode;\n\n#define work_to_altmode_port(w) container_of((w), struct pmic_glink_altmode_port, work)\n\nstruct pmic_glink_altmode_port {\n\tstruct pmic_glink_altmode *altmode;\n\tunsigned int index;\n\n\tstruct typec_switch *typec_switch;\n\tstruct typec_mux *typec_mux;\n\tstruct typec_mux_state state;\n\tstruct typec_retimer *typec_retimer;\n\tstruct typec_retimer_state retimer_state;\n\tstruct typec_altmode dp_alt;\n\n\tstruct work_struct work;\n\n\tstruct drm_bridge bridge;\n\n\tenum typec_orientation orientation;\n\tu16 svid;\n\tu8 dp_data;\n\tu8 mode;\n\tu8 hpd_state;\n\tu8 hpd_irq;\n};\n\n#define work_to_altmode(w) container_of((w), struct pmic_glink_altmode, enable_work)\n\nstruct pmic_glink_altmode {\n\tstruct device *dev;\n\n\tunsigned int owner_id;\n\n\t \n\tstruct mutex lock;\n\n\tstruct completion pan_ack;\n\tstruct pmic_glink_client *client;\n\n\tstruct work_struct enable_work;\n\n\tstruct pmic_glink_altmode_port ports[PMIC_GLINK_MAX_PORTS];\n};\n\nstatic int pmic_glink_altmode_request(struct pmic_glink_altmode *altmode, u32 cmd, u32 arg)\n{\n\tstruct usbc_write_req req = {};\n\tunsigned long left;\n\tint ret;\n\n\t \n\tmutex_lock(&altmode->lock);\n\n\treq.hdr.owner = cpu_to_le32(altmode->owner_id);\n\treq.hdr.type = cpu_to_le32(PMIC_GLINK_REQ_RESP);\n\treq.hdr.opcode = cpu_to_le32(USBC_CMD_WRITE_REQ);\n\treq.cmd = cpu_to_le32(cmd);\n\treq.arg = cpu_to_le32(arg);\n\n\tret = pmic_glink_send(altmode->client, &req, sizeof(req));\n\tif (ret) {\n\t\tdev_err(altmode->dev, \"failed to send altmode request: %#x (%d)\\n\", cmd, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tleft = wait_for_completion_timeout(&altmode->pan_ack, 5 * HZ);\n\tif (!left) {\n\t\tdev_err(altmode->dev, \"timeout waiting for altmode request ack for: %#x\\n\", cmd);\n\t\tret = -ETIMEDOUT;\n\t}\n\nout_unlock:\n\tmutex_unlock(&altmode->lock);\n\treturn ret;\n}\n\nstatic void pmic_glink_altmode_enable_dp(struct pmic_glink_altmode *altmode,\n\t\t\t\t\t struct pmic_glink_altmode_port *port,\n\t\t\t\t\t u8 mode, bool hpd_state,\n\t\t\t\t\t bool hpd_irq)\n{\n\tstruct typec_displayport_data dp_data = {};\n\tint ret;\n\n\tdp_data.status = DP_STATUS_ENABLED;\n\tif (hpd_state)\n\t\tdp_data.status |= DP_STATUS_HPD_STATE;\n\tif (hpd_irq)\n\t\tdp_data.status |= DP_STATUS_IRQ_HPD;\n\tdp_data.conf = DP_CONF_SET_PIN_ASSIGN(mode);\n\n\tport->state.alt = &port->dp_alt;\n\tport->state.data = &dp_data;\n\tport->state.mode = TYPEC_MODAL_STATE(mode);\n\n\tret = typec_mux_set(port->typec_mux, &port->state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to switch mux to DP\\n\");\n\n\tport->retimer_state.alt = &port->dp_alt;\n\tport->retimer_state.data = &dp_data;\n\tport->retimer_state.mode = TYPEC_MODAL_STATE(mode);\n\n\tret = typec_retimer_set(port->typec_retimer, &port->retimer_state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to setup retimer to DP\\n\");\n}\n\nstatic void pmic_glink_altmode_enable_usb(struct pmic_glink_altmode *altmode,\n\t\t\t\t\t  struct pmic_glink_altmode_port *port)\n{\n\tint ret;\n\n\tport->state.alt = NULL;\n\tport->state.data = NULL;\n\tport->state.mode = TYPEC_STATE_USB;\n\n\tret = typec_mux_set(port->typec_mux, &port->state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to switch mux to USB\\n\");\n\n\tport->retimer_state.alt = NULL;\n\tport->retimer_state.data = NULL;\n\tport->retimer_state.mode = TYPEC_STATE_USB;\n\n\tret = typec_retimer_set(port->typec_retimer, &port->retimer_state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to setup retimer to USB\\n\");\n}\n\nstatic void pmic_glink_altmode_safe(struct pmic_glink_altmode *altmode,\n\t\t\t\t    struct pmic_glink_altmode_port *port)\n{\n\tint ret;\n\n\tport->state.alt = NULL;\n\tport->state.data = NULL;\n\tport->state.mode = TYPEC_STATE_SAFE;\n\n\tret = typec_mux_set(port->typec_mux, &port->state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to switch mux to safe mode\\n\");\n\n\tport->retimer_state.alt = NULL;\n\tport->retimer_state.data = NULL;\n\tport->retimer_state.mode = TYPEC_STATE_SAFE;\n\n\tret = typec_retimer_set(port->typec_retimer, &port->retimer_state);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to setup retimer to USB\\n\");\n}\n\nstatic void pmic_glink_altmode_worker(struct work_struct *work)\n{\n\tstruct pmic_glink_altmode_port *alt_port = work_to_altmode_port(work);\n\tstruct pmic_glink_altmode *altmode = alt_port->altmode;\n\n\ttypec_switch_set(alt_port->typec_switch, alt_port->orientation);\n\n\tif (alt_port->svid == USB_TYPEC_DP_SID && alt_port->mode == 0xff)\n\t\tpmic_glink_altmode_safe(altmode, alt_port);\n\telse if (alt_port->svid == USB_TYPEC_DP_SID)\n\t\tpmic_glink_altmode_enable_dp(altmode, alt_port, alt_port->mode,\n\t\t\t\t\t     alt_port->hpd_state, alt_port->hpd_irq);\n\telse\n\t\tpmic_glink_altmode_enable_usb(altmode, alt_port);\n\n\tif (alt_port->hpd_state)\n\t\tdrm_bridge_hpd_notify(&alt_port->bridge, connector_status_connected);\n\telse\n\t\tdrm_bridge_hpd_notify(&alt_port->bridge, connector_status_disconnected);\n\n\tpmic_glink_altmode_request(altmode, ALTMODE_PAN_ACK, alt_port->index);\n};\n\nstatic enum typec_orientation pmic_glink_altmode_orientation(unsigned int orientation)\n{\n\tif (orientation == 0)\n\t\treturn TYPEC_ORIENTATION_NORMAL;\n\telse if (orientation == 1)\n\t\treturn TYPEC_ORIENTATION_REVERSE;\n\telse\n\t\treturn TYPEC_ORIENTATION_NONE;\n}\n\n#define SC8180X_PORT_MASK\t\t0x000000ff\n#define SC8180X_ORIENTATION_MASK\t0x0000ff00\n#define SC8180X_MUX_MASK\t\t0x00ff0000\n#define SC8180X_MODE_MASK\t\t0x3f000000\n#define SC8180X_HPD_STATE_MASK\t\t0x40000000\n#define SC8180X_HPD_IRQ_MASK\t\t0x80000000\n\nstatic void pmic_glink_altmode_sc8180xp_notify(struct pmic_glink_altmode *altmode,\n\t\t\t\t\t       const void *data, size_t len)\n{\n\tstruct pmic_glink_altmode_port *alt_port;\n\tconst struct usbc_sc8180x_notify *msg;\n\tu32 notification;\n\tu8 orientation;\n\tu8 hpd_state;\n\tu8 hpd_irq;\n\tu16 svid;\n\tu8 port;\n\tu8 mode;\n\tu8 mux;\n\n\tif (len != sizeof(*msg)) {\n\t\tdev_warn(altmode->dev, \"invalid length of USBC_NOTIFY indication: %zd\\n\", len);\n\t\treturn;\n\t}\n\n\tmsg = data;\n\tnotification = le32_to_cpu(msg->notification);\n\tport = FIELD_GET(SC8180X_PORT_MASK, notification);\n\torientation = FIELD_GET(SC8180X_ORIENTATION_MASK, notification);\n\tmux = FIELD_GET(SC8180X_MUX_MASK, notification);\n\tmode = FIELD_GET(SC8180X_MODE_MASK, notification);\n\thpd_state = FIELD_GET(SC8180X_HPD_STATE_MASK, notification);\n\thpd_irq = FIELD_GET(SC8180X_HPD_IRQ_MASK, notification);\n\n\tsvid = mux == 2 ? USB_TYPEC_DP_SID : 0;\n\n\tif (!altmode->ports[port].altmode) {\n\t\tdev_dbg(altmode->dev, \"notification on undefined port %d\\n\", port);\n\t\treturn;\n\t}\n\n\talt_port = &altmode->ports[port];\n\talt_port->orientation = pmic_glink_altmode_orientation(orientation);\n\talt_port->svid = svid;\n\talt_port->mode = mode;\n\talt_port->hpd_state = hpd_state;\n\talt_port->hpd_irq = hpd_irq;\n\tschedule_work(&alt_port->work);\n}\n\n#define SC8280XP_DPAM_MASK\t0x3f\n#define SC8280XP_HPD_STATE_MASK BIT(6)\n#define SC8280XP_HPD_IRQ_MASK\tBIT(7)\n\nstatic void pmic_glink_altmode_sc8280xp_notify(struct pmic_glink_altmode *altmode,\n\t\t\t\t\t       u16 svid, const void *data, size_t len)\n{\n\tstruct pmic_glink_altmode_port *alt_port;\n\tconst struct usbc_notify *notify;\n\tu8 orientation;\n\tu8 hpd_state;\n\tu8 hpd_irq;\n\tu8 mode;\n\tu8 port;\n\n\tif (len != sizeof(*notify)) {\n\t\tdev_warn(altmode->dev, \"invalid length USBC_NOTIFY_IND: %zd\\n\",\n\t\t\t len);\n\t\treturn;\n\t}\n\n\tnotify = data;\n\n\tport = notify->payload[0];\n\torientation = notify->payload[1];\n\tmode = FIELD_GET(SC8280XP_DPAM_MASK, notify->payload[8]) - DPAM_HPD_A;\n\thpd_state = FIELD_GET(SC8280XP_HPD_STATE_MASK, notify->payload[8]);\n\thpd_irq = FIELD_GET(SC8280XP_HPD_IRQ_MASK, notify->payload[8]);\n\n\tif (!altmode->ports[port].altmode) {\n\t\tdev_dbg(altmode->dev, \"notification on undefined port %d\\n\", port);\n\t\treturn;\n\t}\n\n\talt_port = &altmode->ports[port];\n\talt_port->orientation = pmic_glink_altmode_orientation(orientation);\n\talt_port->svid = svid;\n\talt_port->mode = mode;\n\talt_port->hpd_state = hpd_state;\n\talt_port->hpd_irq = hpd_irq;\n\tschedule_work(&alt_port->work);\n}\n\nstatic void pmic_glink_altmode_callback(const void *data, size_t len, void *priv)\n{\n\tstruct pmic_glink_altmode *altmode = priv;\n\tconst struct pmic_glink_hdr *hdr = data;\n\tu16 opcode;\n\tu16 svid;\n\n\topcode = le32_to_cpu(hdr->opcode) & 0xff;\n\tsvid = le32_to_cpu(hdr->opcode) >> 16;\n\n\tswitch (opcode) {\n\tcase USBC_CMD_WRITE_REQ:\n\t\tcomplete(&altmode->pan_ack);\n\t\tbreak;\n\tcase USBC_NOTIFY_IND:\n\t\tpmic_glink_altmode_sc8280xp_notify(altmode, svid, data, len);\n\t\tbreak;\n\tcase USBC_SC8180X_NOTIFY_IND:\n\t\tpmic_glink_altmode_sc8180xp_notify(altmode, data, len);\n\t\tbreak;\n\t}\n}\n\nstatic int pmic_glink_altmode_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\treturn flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR ? 0 : -EINVAL;\n}\n\nstatic const struct drm_bridge_funcs pmic_glink_altmode_bridge_funcs = {\n\t.attach = pmic_glink_altmode_attach,\n};\n\nstatic void pmic_glink_altmode_put_retimer(void *data)\n{\n\ttypec_retimer_put(data);\n}\n\nstatic void pmic_glink_altmode_put_mux(void *data)\n{\n\ttypec_mux_put(data);\n}\n\nstatic void pmic_glink_altmode_put_switch(void *data)\n{\n\ttypec_switch_put(data);\n}\n\nstatic void pmic_glink_altmode_enable_worker(struct work_struct *work)\n{\n\tstruct pmic_glink_altmode *altmode = work_to_altmode(work);\n\tint ret;\n\n\tret = pmic_glink_altmode_request(altmode, ALTMODE_PAN_EN, 0);\n\tif (ret)\n\t\tdev_err(altmode->dev, \"failed to request altmode notifications\\n\");\n}\n\nstatic void pmic_glink_altmode_pdr_notify(void *priv, int state)\n{\n\tstruct pmic_glink_altmode *altmode = priv;\n\n\tif (state == SERVREG_SERVICE_STATE_UP)\n\t\tschedule_work(&altmode->enable_work);\n}\n\nstatic const struct of_device_id pmic_glink_altmode_of_quirks[] = {\n\t{ .compatible = \"qcom,sc8180x-pmic-glink\", .data = (void *)PMIC_GLINK_OWNER_USBC },\n\t{}\n};\n\nstatic int pmic_glink_altmode_probe(struct auxiliary_device *adev,\n\t\t\t\t    const struct auxiliary_device_id *id)\n{\n\tstruct pmic_glink_altmode_port *alt_port;\n\tstruct pmic_glink_altmode *altmode;\n\tconst struct of_device_id *match;\n\tstruct fwnode_handle *fwnode;\n\tstruct device *dev = &adev->dev;\n\tu32 port;\n\tint ret;\n\n\taltmode = devm_kzalloc(dev, sizeof(*altmode), GFP_KERNEL);\n\tif (!altmode)\n\t\treturn -ENOMEM;\n\n\taltmode->dev = dev;\n\n\tmatch = of_match_device(pmic_glink_altmode_of_quirks, dev->parent);\n\tif (match)\n\t\taltmode->owner_id = (unsigned long)match->data;\n\telse\n\t\taltmode->owner_id = PMIC_GLINK_OWNER_USBC_PAN;\n\n\tINIT_WORK(&altmode->enable_work, pmic_glink_altmode_enable_worker);\n\tinit_completion(&altmode->pan_ack);\n\tmutex_init(&altmode->lock);\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tret = fwnode_property_read_u32(fwnode, \"reg\", &port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", fwnode);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port >= ARRAY_SIZE(altmode->ports)) {\n\t\t\tdev_warn(dev, \"invalid connector number, ignoring\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (altmode->ports[port].altmode) {\n\t\t\tdev_err(dev, \"multiple connector definition for port %u\\n\", port);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\talt_port = &altmode->ports[port];\n\t\talt_port->altmode = altmode;\n\t\talt_port->index = port;\n\t\tINIT_WORK(&alt_port->work, pmic_glink_altmode_worker);\n\n\t\talt_port->bridge.funcs = &pmic_glink_altmode_bridge_funcs;\n\t\talt_port->bridge.of_node = to_of_node(fwnode);\n\t\talt_port->bridge.ops = DRM_BRIDGE_OP_HPD;\n\t\talt_port->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\t\tret = devm_drm_bridge_add(dev, &alt_port->bridge);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\talt_port->dp_alt.svid = USB_TYPEC_DP_SID;\n\t\talt_port->dp_alt.mode = USB_TYPEC_DP_MODE;\n\t\talt_port->dp_alt.active = 1;\n\n\t\talt_port->typec_mux = fwnode_typec_mux_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_mux)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_mux),\n\t\t\t\t\t     \"failed to acquire mode-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_mux,\n\t\t\t\t\t       alt_port->typec_mux);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\talt_port->typec_retimer = fwnode_typec_retimer_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_retimer)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_retimer),\n\t\t\t\t\t     \"failed to acquire retimer-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_retimer,\n\t\t\t\t\t       alt_port->typec_retimer);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\talt_port->typec_switch = fwnode_typec_switch_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_switch)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_switch),\n\t\t\t\t\t     \"failed to acquire orientation-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_switch,\n\t\t\t\t\t       alt_port->typec_switch);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\taltmode->client = devm_pmic_glink_register_client(dev,\n\t\t\t\t\t\t\t  altmode->owner_id,\n\t\t\t\t\t\t\t  pmic_glink_altmode_callback,\n\t\t\t\t\t\t\t  pmic_glink_altmode_pdr_notify,\n\t\t\t\t\t\t\t  altmode);\n\treturn PTR_ERR_OR_ZERO(altmode->client);\n}\n\nstatic const struct auxiliary_device_id pmic_glink_altmode_id_table[] = {\n\t{ .name = \"pmic_glink.altmode\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, pmic_glink_altmode_id_table);\n\nstatic struct auxiliary_driver pmic_glink_altmode_driver = {\n\t.name = \"pmic_glink_altmode\",\n\t.probe = pmic_glink_altmode_probe,\n\t.id_table = pmic_glink_altmode_id_table,\n};\n\nmodule_auxiliary_driver(pmic_glink_altmode_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC GLINK Altmode driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}