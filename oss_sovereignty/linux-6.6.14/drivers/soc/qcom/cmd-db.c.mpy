{
  "module_name": "cmd-db.c",
  "hash_id": "de3247bd937fec93c6720d3a217944a1485f9d76f1793657616e38f3328ee543",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/cmd-db.c",
  "human_readable_source": " \n \n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n\n#include <soc/qcom/cmd-db.h>\n\n#define NUM_PRIORITY\t\t2\n#define MAX_SLV_ID\t\t8\n#define SLAVE_ID_MASK\t\t0x7\n#define SLAVE_ID_SHIFT\t\t16\n\n \nstruct entry_header {\n\tu8 id[8];\n\t__le32 priority[NUM_PRIORITY];\n\t__le32 addr;\n\t__le16 len;\n\t__le16 offset;\n};\n\n \nstruct rsc_hdr {\n\t__le16 slv_id;\n\t__le16 header_offset;\n\t__le16 data_offset;\n\t__le16 cnt;\n\t__le16 version;\n\t__le16 reserved[3];\n};\n\n \nstruct cmd_db_header {\n\t__le32 version;\n\tu8 magic[4];\n\tstruct rsc_hdr header[MAX_SLV_ID];\n\t__le32 checksum;\n\t__le32 reserved;\n\tu8 data[];\n};\n\n \n\nstatic const u8 CMD_DB_MAGIC[] = { 0xdb, 0x30, 0x03, 0x0c };\n\nstatic bool cmd_db_magic_matches(const struct cmd_db_header *header)\n{\n\tconst u8 *magic = header->magic;\n\n\treturn memcmp(magic, CMD_DB_MAGIC, ARRAY_SIZE(CMD_DB_MAGIC)) == 0;\n}\n\nstatic struct cmd_db_header *cmd_db_header;\n\nstatic inline const void *rsc_to_entry_header(const struct rsc_hdr *hdr)\n{\n\tu16 offset = le16_to_cpu(hdr->header_offset);\n\n\treturn cmd_db_header->data + offset;\n}\n\nstatic inline void *\nrsc_offset(const struct rsc_hdr *hdr, const struct entry_header *ent)\n{\n\tu16 offset = le16_to_cpu(hdr->data_offset);\n\tu16 loffset = le16_to_cpu(ent->offset);\n\n\treturn cmd_db_header->data + offset + loffset;\n}\n\n \nint cmd_db_ready(void)\n{\n\tif (cmd_db_header == NULL)\n\t\treturn -EPROBE_DEFER;\n\telse if (!cmd_db_magic_matches(cmd_db_header))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cmd_db_ready);\n\nstatic int cmd_db_get_header(const char *id, const struct entry_header **eh,\n\t\t\t     const struct rsc_hdr **rh)\n{\n\tconst struct rsc_hdr *rsc_hdr;\n\tconst struct entry_header *ent;\n\tint ret, i, j;\n\tu8 query[sizeof(ent->id)] __nonstring;\n\n\tret = cmd_db_ready();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstrncpy(query, id, sizeof(query));\n\n\tfor (i = 0; i < MAX_SLV_ID; i++) {\n\t\trsc_hdr = &cmd_db_header->header[i];\n\t\tif (!rsc_hdr->slv_id)\n\t\t\tbreak;\n\n\t\tent = rsc_to_entry_header(rsc_hdr);\n\t\tfor (j = 0; j < le16_to_cpu(rsc_hdr->cnt); j++, ent++) {\n\t\t\tif (memcmp(ent->id, query, sizeof(ent->id)) == 0) {\n\t\t\t\tif (eh)\n\t\t\t\t\t*eh = ent;\n\t\t\t\tif (rh)\n\t\t\t\t\t*rh = rsc_hdr;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nu32 cmd_db_read_addr(const char *id)\n{\n\tint ret;\n\tconst struct entry_header *ent;\n\n\tret = cmd_db_get_header(id, &ent, NULL);\n\n\treturn ret < 0 ? 0 : le32_to_cpu(ent->addr);\n}\nEXPORT_SYMBOL(cmd_db_read_addr);\n\n \nconst void *cmd_db_read_aux_data(const char *id, size_t *len)\n{\n\tint ret;\n\tconst struct entry_header *ent;\n\tconst struct rsc_hdr *rsc_hdr;\n\n\tret = cmd_db_get_header(id, &ent, &rsc_hdr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (len)\n\t\t*len = le16_to_cpu(ent->len);\n\n\treturn rsc_offset(rsc_hdr, ent);\n}\nEXPORT_SYMBOL(cmd_db_read_aux_data);\n\n \nenum cmd_db_hw_type cmd_db_read_slave_id(const char *id)\n{\n\tint ret;\n\tconst struct entry_header *ent;\n\tu32 addr;\n\n\tret = cmd_db_get_header(id, &ent, NULL);\n\tif (ret < 0)\n\t\treturn CMD_DB_HW_INVALID;\n\n\taddr = le32_to_cpu(ent->addr);\n\treturn (addr >> SLAVE_ID_SHIFT) & SLAVE_ID_MASK;\n}\nEXPORT_SYMBOL(cmd_db_read_slave_id);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int cmd_db_debugfs_dump(struct seq_file *seq, void *p)\n{\n\tint i, j;\n\tconst struct rsc_hdr *rsc;\n\tconst struct entry_header *ent;\n\tconst char *name;\n\tu16 len, version;\n\tu8 major, minor;\n\n\tseq_puts(seq, \"Command DB DUMP\\n\");\n\n\tfor (i = 0; i < MAX_SLV_ID; i++) {\n\t\trsc = &cmd_db_header->header[i];\n\t\tif (!rsc->slv_id)\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(rsc->slv_id)) {\n\t\tcase CMD_DB_HW_ARC:\n\t\t\tname = \"ARC\";\n\t\t\tbreak;\n\t\tcase CMD_DB_HW_VRM:\n\t\t\tname = \"VRM\";\n\t\t\tbreak;\n\t\tcase CMD_DB_HW_BCM:\n\t\t\tname = \"BCM\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tname = \"Unknown\";\n\t\t\tbreak;\n\t\t}\n\n\t\tversion = le16_to_cpu(rsc->version);\n\t\tmajor = version >> 8;\n\t\tminor = version;\n\n\t\tseq_printf(seq, \"Slave %s (v%u.%u)\\n\", name, major, minor);\n\t\tseq_puts(seq, \"-------------------------\\n\");\n\n\t\tent = rsc_to_entry_header(rsc);\n\t\tfor (j = 0; j < le16_to_cpu(rsc->cnt); j++, ent++) {\n\t\t\tseq_printf(seq, \"0x%05x: %*pEp\", le32_to_cpu(ent->addr),\n\t\t\t\t   (int)strnlen(ent->id, sizeof(ent->id)), ent->id);\n\n\t\t\tlen = le16_to_cpu(ent->len);\n\t\t\tif (len) {\n\t\t\t\tseq_printf(seq, \" [%*ph]\",\n\t\t\t\t\t   len, rsc_offset(rsc, ent));\n\t\t\t}\n\t\t\tseq_putc(seq, '\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int open_cmd_db_debugfs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, cmd_db_debugfs_dump, inode->i_private);\n}\n#endif\n\nstatic const struct file_operations cmd_db_debugfs_ops = {\n#ifdef CONFIG_DEBUG_FS\n\t.open = open_cmd_db_debugfs,\n#endif\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int cmd_db_dev_probe(struct platform_device *pdev)\n{\n\tstruct reserved_mem *rmem;\n\tint ret = 0;\n\n\trmem = of_reserved_mem_lookup(pdev->dev.of_node);\n\tif (!rmem) {\n\t\tdev_err(&pdev->dev, \"failed to acquire memory region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_db_header = memremap(rmem->base, rmem->size, MEMREMAP_WB);\n\tif (!cmd_db_header) {\n\t\tret = -ENOMEM;\n\t\tcmd_db_header = NULL;\n\t\treturn ret;\n\t}\n\n\tif (!cmd_db_magic_matches(cmd_db_header)) {\n\t\tdev_err(&pdev->dev, \"Invalid Command DB Magic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebugfs_create_file(\"cmd-db\", 0400, NULL, NULL, &cmd_db_debugfs_ops);\n\n\tdevice_set_pm_not_required(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cmd_db_match_table[] = {\n\t{ .compatible = \"qcom,cmd-db\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cmd_db_match_table);\n\nstatic struct platform_driver cmd_db_dev_driver = {\n\t.probe  = cmd_db_dev_probe,\n\t.driver = {\n\t\t   .name = \"cmd-db\",\n\t\t   .of_match_table = cmd_db_match_table,\n\t\t   .suppress_bind_attrs = true,\n\t},\n};\n\nstatic int __init cmd_db_device_init(void)\n{\n\treturn platform_driver_register(&cmd_db_dev_driver);\n}\narch_initcall(cmd_db_device_init);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. Command DB Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}