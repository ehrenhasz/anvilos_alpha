{
  "module_name": "qcom-geni-se.c",
  "hash_id": "b3f3dfdd8da9457e8a26117dcfbbbab96397934ec8508d73629f58df5fb83c65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qcom-geni-se.c",
  "human_readable_source": "\n\n\n \n#define __DISABLE_TRACE_MMIO__\n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/soc/qcom/geni-se.h>\n\n \n\n \n\n \n\n#define MAX_CLK_PERF_LEVEL 32\n#define MAX_CLKS 2\n\n \nstruct geni_wrapper {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk_bulk_data clks[MAX_CLKS];\n\tunsigned int num_clks;\n};\n\n \nstruct geni_se_desc {\n\tunsigned int num_clks;\n\tconst char * const *clks;\n};\n\nstatic const char * const icc_path_names[] = {\"qup-core\", \"qup-config\",\n\t\t\t\t\t\t\"qup-memory\"};\n\n#define QUP_HW_VER_REG\t\t\t0x4\n\n \n#define GENI_INIT_CFG_REVISION\t\t0x0\n#define GENI_S_INIT_CFG_REVISION\t0x4\n#define GENI_OUTPUT_CTRL\t\t0x24\n#define GENI_CGC_CTRL\t\t\t0x28\n#define GENI_CLK_CTRL_RO\t\t0x60\n#define GENI_FW_S_REVISION_RO\t\t0x6c\n#define SE_GENI_BYTE_GRAN\t\t0x254\n#define SE_GENI_TX_PACKING_CFG0\t\t0x260\n#define SE_GENI_TX_PACKING_CFG1\t\t0x264\n#define SE_GENI_RX_PACKING_CFG0\t\t0x284\n#define SE_GENI_RX_PACKING_CFG1\t\t0x288\n#define SE_GENI_M_GP_LENGTH\t\t0x910\n#define SE_GENI_S_GP_LENGTH\t\t0x914\n#define SE_DMA_TX_PTR_L\t\t\t0xc30\n#define SE_DMA_TX_PTR_H\t\t\t0xc34\n#define SE_DMA_TX_ATTR\t\t\t0xc38\n#define SE_DMA_TX_LEN\t\t\t0xc3c\n#define SE_DMA_TX_IRQ_EN\t\t0xc48\n#define SE_DMA_TX_IRQ_EN_SET\t\t0xc4c\n#define SE_DMA_TX_IRQ_EN_CLR\t\t0xc50\n#define SE_DMA_TX_LEN_IN\t\t0xc54\n#define SE_DMA_TX_MAX_BURST\t\t0xc5c\n#define SE_DMA_RX_PTR_L\t\t\t0xd30\n#define SE_DMA_RX_PTR_H\t\t\t0xd34\n#define SE_DMA_RX_ATTR\t\t\t0xd38\n#define SE_DMA_RX_LEN\t\t\t0xd3c\n#define SE_DMA_RX_IRQ_EN\t\t0xd48\n#define SE_DMA_RX_IRQ_EN_SET\t\t0xd4c\n#define SE_DMA_RX_IRQ_EN_CLR\t\t0xd50\n#define SE_DMA_RX_LEN_IN\t\t0xd54\n#define SE_DMA_RX_MAX_BURST\t\t0xd5c\n#define SE_DMA_RX_FLUSH\t\t\t0xd60\n#define SE_GSI_EVENT_EN\t\t\t0xe18\n#define SE_IRQ_EN\t\t\t0xe1c\n#define SE_DMA_GENERAL_CFG\t\t0xe30\n\n \n#define DEFAULT_IO_OUTPUT_CTRL_MSK\tGENMASK(6, 0)\n\n \n#define CFG_AHB_CLK_CGC_ON\t\tBIT(0)\n#define CFG_AHB_WR_ACLK_CGC_ON\t\tBIT(1)\n#define DATA_AHB_CLK_CGC_ON\t\tBIT(2)\n#define SCLK_CGC_ON\t\t\tBIT(3)\n#define TX_CLK_CGC_ON\t\t\tBIT(4)\n#define RX_CLK_CGC_ON\t\t\tBIT(5)\n#define EXT_CLK_CGC_ON\t\t\tBIT(6)\n#define PROG_RAM_HCLK_OFF\t\tBIT(8)\n#define PROG_RAM_SCLK_OFF\t\tBIT(9)\n#define DEFAULT_CGC_EN\t\t\tGENMASK(6, 0)\n\n \n#define DMA_RX_EVENT_EN\t\t\tBIT(0)\n#define DMA_TX_EVENT_EN\t\t\tBIT(1)\n#define GENI_M_EVENT_EN\t\t\tBIT(2)\n#define GENI_S_EVENT_EN\t\t\tBIT(3)\n\n \n#define DMA_RX_IRQ_EN\t\t\tBIT(0)\n#define DMA_TX_IRQ_EN\t\t\tBIT(1)\n#define GENI_M_IRQ_EN\t\t\tBIT(2)\n#define GENI_S_IRQ_EN\t\t\tBIT(3)\n\n \n#define DMA_RX_CLK_CGC_ON\t\tBIT(0)\n#define DMA_TX_CLK_CGC_ON\t\tBIT(1)\n#define DMA_AHB_SLV_CFG_ON\t\tBIT(2)\n#define AHB_SEC_SLV_CLK_CGC_ON\t\tBIT(3)\n#define DUMMY_RX_NON_BUFFERABLE\t\tBIT(4)\n#define RX_DMA_ZERO_PADDING_EN\t\tBIT(5)\n#define RX_DMA_IRQ_DELAY_MSK\t\tGENMASK(8, 6)\n#define RX_DMA_IRQ_DELAY_SHFT\t\t6\n\n \nu32 geni_se_get_qup_hw_version(struct geni_se *se)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\treturn readl_relaxed(wrapper->base + QUP_HW_VER_REG);\n}\nEXPORT_SYMBOL(geni_se_get_qup_hw_version);\n\nstatic void geni_se_io_set_mode(void __iomem *base)\n{\n\tu32 val;\n\n\tval = readl_relaxed(base + SE_IRQ_EN);\n\tval |= GENI_M_IRQ_EN | GENI_S_IRQ_EN;\n\tval |= DMA_TX_IRQ_EN | DMA_RX_IRQ_EN;\n\twritel_relaxed(val, base + SE_IRQ_EN);\n\n\tval = readl_relaxed(base + SE_GENI_DMA_MODE_EN);\n\tval &= ~GENI_DMA_MODE_EN;\n\twritel_relaxed(val, base + SE_GENI_DMA_MODE_EN);\n\n\twritel_relaxed(0, base + SE_GSI_EVENT_EN);\n}\n\nstatic void geni_se_io_init(void __iomem *base)\n{\n\tu32 val;\n\n\tval = readl_relaxed(base + GENI_CGC_CTRL);\n\tval |= DEFAULT_CGC_EN;\n\twritel_relaxed(val, base + GENI_CGC_CTRL);\n\n\tval = readl_relaxed(base + SE_DMA_GENERAL_CFG);\n\tval |= AHB_SEC_SLV_CLK_CGC_ON | DMA_AHB_SLV_CFG_ON;\n\tval |= DMA_TX_CLK_CGC_ON | DMA_RX_CLK_CGC_ON;\n\twritel_relaxed(val, base + SE_DMA_GENERAL_CFG);\n\n\twritel_relaxed(DEFAULT_IO_OUTPUT_CTRL_MSK, base + GENI_OUTPUT_CTRL);\n\twritel_relaxed(FORCE_DEFAULT, base + GENI_FORCE_DEFAULT_REG);\n}\n\nstatic void geni_se_irq_clear(struct geni_se *se)\n{\n\twritel_relaxed(0, se->base + SE_GSI_EVENT_EN);\n\twritel_relaxed(0xffffffff, se->base + SE_GENI_M_IRQ_CLEAR);\n\twritel_relaxed(0xffffffff, se->base + SE_GENI_S_IRQ_CLEAR);\n\twritel_relaxed(0xffffffff, se->base + SE_DMA_TX_IRQ_CLR);\n\twritel_relaxed(0xffffffff, se->base + SE_DMA_RX_IRQ_CLR);\n\twritel_relaxed(0xffffffff, se->base + SE_IRQ_EN);\n}\n\n \nvoid geni_se_init(struct geni_se *se, u32 rx_wm, u32 rx_rfr)\n{\n\tu32 val;\n\n\tgeni_se_irq_clear(se);\n\tgeni_se_io_init(se->base);\n\tgeni_se_io_set_mode(se->base);\n\n\twritel_relaxed(rx_wm, se->base + SE_GENI_RX_WATERMARK_REG);\n\twritel_relaxed(rx_rfr, se->base + SE_GENI_RX_RFR_WATERMARK_REG);\n\n\tval = readl_relaxed(se->base + SE_GENI_M_IRQ_EN);\n\tval |= M_COMMON_GENI_M_IRQ_EN;\n\twritel_relaxed(val, se->base + SE_GENI_M_IRQ_EN);\n\n\tval = readl_relaxed(se->base + SE_GENI_S_IRQ_EN);\n\tval |= S_COMMON_GENI_S_IRQ_EN;\n\twritel_relaxed(val, se->base + SE_GENI_S_IRQ_EN);\n}\nEXPORT_SYMBOL(geni_se_init);\n\nstatic void geni_se_select_fifo_mode(struct geni_se *se)\n{\n\tu32 proto = geni_se_read_proto(se);\n\tu32 val, val_old;\n\n\tgeni_se_irq_clear(se);\n\n\t \n\tif (proto != GENI_SE_UART) {\n\t\t \n\t\tval_old = val = readl_relaxed(se->base + SE_GENI_M_IRQ_EN);\n\t\tval |= M_CMD_DONE_EN | M_TX_FIFO_WATERMARK_EN;\n\t\tval |= M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN;\n\t\tif (val != val_old)\n\t\t\twritel_relaxed(val, se->base + SE_GENI_M_IRQ_EN);\n\t}\n\n\tval_old = val = readl_relaxed(se->base + SE_GENI_DMA_MODE_EN);\n\tval &= ~GENI_DMA_MODE_EN;\n\tif (val != val_old)\n\t\twritel_relaxed(val, se->base + SE_GENI_DMA_MODE_EN);\n}\n\nstatic void geni_se_select_dma_mode(struct geni_se *se)\n{\n\tu32 proto = geni_se_read_proto(se);\n\tu32 val, val_old;\n\n\tgeni_se_irq_clear(se);\n\n\t \n\tif (proto != GENI_SE_UART) {\n\t\t \n\t\tval_old = val = readl_relaxed(se->base + SE_GENI_M_IRQ_EN);\n\t\tval &= ~(M_CMD_DONE_EN | M_TX_FIFO_WATERMARK_EN);\n\t\tval &= ~(M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN);\n\t\tif (val != val_old)\n\t\t\twritel_relaxed(val, se->base + SE_GENI_M_IRQ_EN);\n\t}\n\n\tval_old = val = readl_relaxed(se->base + SE_GENI_DMA_MODE_EN);\n\tval |= GENI_DMA_MODE_EN;\n\tif (val != val_old)\n\t\twritel_relaxed(val, se->base + SE_GENI_DMA_MODE_EN);\n}\n\nstatic void geni_se_select_gpi_mode(struct geni_se *se)\n{\n\tu32 val;\n\n\tgeni_se_irq_clear(se);\n\n\twritel(0, se->base + SE_IRQ_EN);\n\n\tval = readl(se->base + SE_GENI_M_IRQ_EN);\n\tval &= ~(M_CMD_DONE_EN | M_TX_FIFO_WATERMARK_EN |\n\t\t M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN);\n\twritel(val, se->base + SE_GENI_M_IRQ_EN);\n\n\twritel(GENI_DMA_MODE_EN, se->base + SE_GENI_DMA_MODE_EN);\n\n\tval = readl(se->base + SE_GSI_EVENT_EN);\n\tval |= (DMA_RX_EVENT_EN | DMA_TX_EVENT_EN | GENI_M_EVENT_EN | GENI_S_EVENT_EN);\n\twritel(val, se->base + SE_GSI_EVENT_EN);\n}\n\n \nvoid geni_se_select_mode(struct geni_se *se, enum geni_se_xfer_mode mode)\n{\n\tWARN_ON(mode != GENI_SE_FIFO && mode != GENI_SE_DMA && mode != GENI_GPI_DMA);\n\n\tswitch (mode) {\n\tcase GENI_SE_FIFO:\n\t\tgeni_se_select_fifo_mode(se);\n\t\tbreak;\n\tcase GENI_SE_DMA:\n\t\tgeni_se_select_dma_mode(se);\n\t\tbreak;\n\tcase GENI_GPI_DMA:\n\t\tgeni_se_select_gpi_mode(se);\n\t\tbreak;\n\tcase GENI_SE_INVALID:\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(geni_se_select_mode);\n\n \n\n#define NUM_PACKING_VECTORS 4\n#define PACKING_START_SHIFT 5\n#define PACKING_DIR_SHIFT 4\n#define PACKING_LEN_SHIFT 1\n#define PACKING_STOP_BIT BIT(0)\n#define PACKING_VECTOR_SHIFT 10\n \nvoid geni_se_config_packing(struct geni_se *se, int bpw, int pack_words,\n\t\t\t    bool msb_to_lsb, bool tx_cfg, bool rx_cfg)\n{\n\tu32 cfg0, cfg1, cfg[NUM_PACKING_VECTORS] = {0};\n\tint len;\n\tint temp_bpw = bpw;\n\tint idx_start = msb_to_lsb ? bpw - 1 : 0;\n\tint idx = idx_start;\n\tint idx_delta = msb_to_lsb ? -BITS_PER_BYTE : BITS_PER_BYTE;\n\tint ceil_bpw = ALIGN(bpw, BITS_PER_BYTE);\n\tint iter = (ceil_bpw * pack_words) / BITS_PER_BYTE;\n\tint i;\n\n\tif (iter <= 0 || iter > NUM_PACKING_VECTORS)\n\t\treturn;\n\n\tfor (i = 0; i < iter; i++) {\n\t\tlen = min_t(int, temp_bpw, BITS_PER_BYTE) - 1;\n\t\tcfg[i] = idx << PACKING_START_SHIFT;\n\t\tcfg[i] |= msb_to_lsb << PACKING_DIR_SHIFT;\n\t\tcfg[i] |= len << PACKING_LEN_SHIFT;\n\n\t\tif (temp_bpw <= BITS_PER_BYTE) {\n\t\t\tidx = ((i + 1) * BITS_PER_BYTE) + idx_start;\n\t\t\ttemp_bpw = bpw;\n\t\t} else {\n\t\t\tidx = idx + idx_delta;\n\t\t\ttemp_bpw = temp_bpw - BITS_PER_BYTE;\n\t\t}\n\t}\n\tcfg[iter - 1] |= PACKING_STOP_BIT;\n\tcfg0 = cfg[0] | (cfg[1] << PACKING_VECTOR_SHIFT);\n\tcfg1 = cfg[2] | (cfg[3] << PACKING_VECTOR_SHIFT);\n\n\tif (tx_cfg) {\n\t\twritel_relaxed(cfg0, se->base + SE_GENI_TX_PACKING_CFG0);\n\t\twritel_relaxed(cfg1, se->base + SE_GENI_TX_PACKING_CFG1);\n\t}\n\tif (rx_cfg) {\n\t\twritel_relaxed(cfg0, se->base + SE_GENI_RX_PACKING_CFG0);\n\t\twritel_relaxed(cfg1, se->base + SE_GENI_RX_PACKING_CFG1);\n\t}\n\n\t \n\tif (pack_words || bpw == 32)\n\t\twritel_relaxed(bpw / 16, se->base + SE_GENI_BYTE_GRAN);\n}\nEXPORT_SYMBOL(geni_se_config_packing);\n\nstatic void geni_se_clks_off(struct geni_se *se)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tclk_disable_unprepare(se->clk);\n\tclk_bulk_disable_unprepare(wrapper->num_clks, wrapper->clks);\n}\n\n \nint geni_se_resources_off(struct geni_se *se)\n{\n\tint ret;\n\n\tif (has_acpi_companion(se->dev))\n\t\treturn 0;\n\n\tret = pinctrl_pm_select_sleep_state(se->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tgeni_se_clks_off(se);\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_se_resources_off);\n\nstatic int geni_se_clks_on(struct geni_se *se)\n{\n\tint ret;\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tret = clk_bulk_prepare_enable(wrapper->num_clks, wrapper->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(se->clk);\n\tif (ret)\n\t\tclk_bulk_disable_unprepare(wrapper->num_clks, wrapper->clks);\n\treturn ret;\n}\n\n \nint geni_se_resources_on(struct geni_se *se)\n{\n\tint ret;\n\n\tif (has_acpi_companion(se->dev))\n\t\treturn 0;\n\n\tret = geni_se_clks_on(se);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pinctrl_pm_select_default_state(se->dev);\n\tif (ret)\n\t\tgeni_se_clks_off(se);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(geni_se_resources_on);\n\n \nint geni_se_clk_tbl_get(struct geni_se *se, unsigned long **tbl)\n{\n\tlong freq = 0;\n\tint i;\n\n\tif (se->clk_perf_tbl) {\n\t\t*tbl = se->clk_perf_tbl;\n\t\treturn se->num_clk_levels;\n\t}\n\n\tse->clk_perf_tbl = devm_kcalloc(se->dev, MAX_CLK_PERF_LEVEL,\n\t\t\t\t\tsizeof(*se->clk_perf_tbl),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!se->clk_perf_tbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAX_CLK_PERF_LEVEL; i++) {\n\t\tfreq = clk_round_rate(se->clk, freq + 1);\n\t\tif (freq <= 0 || freq == se->clk_perf_tbl[i - 1])\n\t\t\tbreak;\n\t\tse->clk_perf_tbl[i] = freq;\n\t}\n\tse->num_clk_levels = i;\n\t*tbl = se->clk_perf_tbl;\n\treturn se->num_clk_levels;\n}\nEXPORT_SYMBOL(geni_se_clk_tbl_get);\n\n \nint geni_se_clk_freq_match(struct geni_se *se, unsigned long req_freq,\n\t\t\t   unsigned int *index, unsigned long *res_freq,\n\t\t\t   bool exact)\n{\n\tunsigned long *tbl;\n\tint num_clk_levels;\n\tint i;\n\tunsigned long best_delta;\n\tunsigned long new_delta;\n\tunsigned int divider;\n\n\tnum_clk_levels = geni_se_clk_tbl_get(se, &tbl);\n\tif (num_clk_levels < 0)\n\t\treturn num_clk_levels;\n\n\tif (num_clk_levels == 0)\n\t\treturn -EINVAL;\n\n\tbest_delta = ULONG_MAX;\n\tfor (i = 0; i < num_clk_levels; i++) {\n\t\tdivider = DIV_ROUND_UP(tbl[i], req_freq);\n\t\tnew_delta = req_freq - tbl[i] / divider;\n\t\tif (new_delta < best_delta) {\n\t\t\t \n\t\t\t*index = i;\n\t\t\t*res_freq = tbl[i];\n\n\t\t\t \n\t\t\tif (new_delta == 0)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tbest_delta = new_delta;\n\t\t}\n\t}\n\n\tif (exact)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_se_clk_freq_match);\n\n#define GENI_SE_DMA_DONE_EN BIT(0)\n#define GENI_SE_DMA_EOT_EN BIT(1)\n#define GENI_SE_DMA_AHB_ERR_EN BIT(2)\n#define GENI_SE_DMA_EOT_BUF BIT(0)\n\n \nvoid geni_se_tx_init_dma(struct geni_se *se, dma_addr_t iova, size_t len)\n{\n\tu32 val;\n\n\tval = GENI_SE_DMA_DONE_EN;\n\tval |= GENI_SE_DMA_EOT_EN;\n\tval |= GENI_SE_DMA_AHB_ERR_EN;\n\twritel_relaxed(val, se->base + SE_DMA_TX_IRQ_EN_SET);\n\twritel_relaxed(lower_32_bits(iova), se->base + SE_DMA_TX_PTR_L);\n\twritel_relaxed(upper_32_bits(iova), se->base + SE_DMA_TX_PTR_H);\n\twritel_relaxed(GENI_SE_DMA_EOT_BUF, se->base + SE_DMA_TX_ATTR);\n\twritel(len, se->base + SE_DMA_TX_LEN);\n}\nEXPORT_SYMBOL(geni_se_tx_init_dma);\n\n \nint geni_se_tx_dma_prep(struct geni_se *se, void *buf, size_t len,\n\t\t\tdma_addr_t *iova)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tif (!wrapper)\n\t\treturn -EINVAL;\n\n\t*iova = dma_map_single(wrapper->dev, buf, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(wrapper->dev, *iova))\n\t\treturn -EIO;\n\n\tgeni_se_tx_init_dma(se, *iova, len);\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_se_tx_dma_prep);\n\n \nvoid geni_se_rx_init_dma(struct geni_se *se, dma_addr_t iova, size_t len)\n{\n\tu32 val;\n\n\tval = GENI_SE_DMA_DONE_EN;\n\tval |= GENI_SE_DMA_EOT_EN;\n\tval |= GENI_SE_DMA_AHB_ERR_EN;\n\twritel_relaxed(val, se->base + SE_DMA_RX_IRQ_EN_SET);\n\twritel_relaxed(lower_32_bits(iova), se->base + SE_DMA_RX_PTR_L);\n\twritel_relaxed(upper_32_bits(iova), se->base + SE_DMA_RX_PTR_H);\n\t \n\twritel_relaxed(0, se->base + SE_DMA_RX_ATTR);\n\twritel(len, se->base + SE_DMA_RX_LEN);\n}\nEXPORT_SYMBOL(geni_se_rx_init_dma);\n\n \nint geni_se_rx_dma_prep(struct geni_se *se, void *buf, size_t len,\n\t\t\tdma_addr_t *iova)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tif (!wrapper)\n\t\treturn -EINVAL;\n\n\t*iova = dma_map_single(wrapper->dev, buf, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(wrapper->dev, *iova))\n\t\treturn -EIO;\n\n\tgeni_se_rx_init_dma(se, *iova, len);\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_se_rx_dma_prep);\n\n \nvoid geni_se_tx_dma_unprep(struct geni_se *se, dma_addr_t iova, size_t len)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tif (!dma_mapping_error(wrapper->dev, iova))\n\t\tdma_unmap_single(wrapper->dev, iova, len, DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL(geni_se_tx_dma_unprep);\n\n \nvoid geni_se_rx_dma_unprep(struct geni_se *se, dma_addr_t iova, size_t len)\n{\n\tstruct geni_wrapper *wrapper = se->wrapper;\n\n\tif (!dma_mapping_error(wrapper->dev, iova))\n\t\tdma_unmap_single(wrapper->dev, iova, len, DMA_FROM_DEVICE);\n}\nEXPORT_SYMBOL(geni_se_rx_dma_unprep);\n\nint geni_icc_get(struct geni_se *se, const char *icc_ddr)\n{\n\tint i, err;\n\tconst char *icc_names[] = {\"qup-core\", \"qup-config\", icc_ddr};\n\n\tif (has_acpi_companion(se->dev))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(se->icc_paths); i++) {\n\t\tif (!icc_names[i])\n\t\t\tcontinue;\n\n\t\tse->icc_paths[i].path = devm_of_icc_get(se->dev, icc_names[i]);\n\t\tif (IS_ERR(se->icc_paths[i].path))\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(se->icc_paths[i].path);\n\tif (err != -EPROBE_DEFER)\n\t\tdev_err_ratelimited(se->dev, \"Failed to get ICC path '%s': %d\\n\",\n\t\t\t\t\ticc_names[i], err);\n\treturn err;\n\n}\nEXPORT_SYMBOL(geni_icc_get);\n\nint geni_icc_set_bw(struct geni_se *se)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(se->icc_paths); i++) {\n\t\tret = icc_set_bw(se->icc_paths[i].path,\n\t\t\tse->icc_paths[i].avg_bw, se->icc_paths[i].avg_bw);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(se->dev, \"ICC BW voting failed on path '%s': %d\\n\",\n\t\t\t\t\ticc_path_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_icc_set_bw);\n\nvoid geni_icc_set_tag(struct geni_se *se, u32 tag)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(se->icc_paths); i++)\n\t\ticc_set_tag(se->icc_paths[i].path, tag);\n}\nEXPORT_SYMBOL(geni_icc_set_tag);\n\n \nint geni_icc_enable(struct geni_se *se)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(se->icc_paths); i++) {\n\t\tret = icc_enable(se->icc_paths[i].path);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(se->dev, \"ICC enable failed on path '%s': %d\\n\",\n\t\t\t\t\ticc_path_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_icc_enable);\n\nint geni_icc_disable(struct geni_se *se)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(se->icc_paths); i++) {\n\t\tret = icc_disable(se->icc_paths[i].path);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(se->dev, \"ICC disable failed on path '%s': %d\\n\",\n\t\t\t\t\ticc_path_names[i], ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(geni_icc_disable);\n\nstatic int geni_se_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct geni_wrapper *wrapper;\n\tint ret;\n\n\twrapper = devm_kzalloc(dev, sizeof(*wrapper), GFP_KERNEL);\n\tif (!wrapper)\n\t\treturn -ENOMEM;\n\n\twrapper->dev = dev;\n\twrapper->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wrapper->base))\n\t\treturn PTR_ERR(wrapper->base);\n\n\tif (!has_acpi_companion(&pdev->dev)) {\n\t\tconst struct geni_se_desc *desc;\n\t\tint i;\n\n\t\tdesc = device_get_match_data(&pdev->dev);\n\t\tif (!desc)\n\t\t\treturn -EINVAL;\n\n\t\twrapper->num_clks = min_t(unsigned int, desc->num_clks, MAX_CLKS);\n\n\t\tfor (i = 0; i < wrapper->num_clks; ++i)\n\t\t\twrapper->clks[i].id = desc->clks[i];\n\n\t\tret = of_count_phandle_with_args(dev->of_node, \"clocks\", \"#clock-cells\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"invalid clocks property at %pOF\\n\", dev->of_node);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret < wrapper->num_clks) {\n\t\t\tdev_err(dev, \"invalid clocks count at %pOF, expected %d entries\\n\",\n\t\t\t\tdev->of_node, wrapper->num_clks);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = devm_clk_bulk_get(dev, wrapper->num_clks, wrapper->clks);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Err getting clks %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, wrapper);\n\tdev_dbg(dev, \"GENI SE Driver probed\\n\");\n\treturn devm_of_platform_populate(dev);\n}\n\nstatic const char * const qup_clks[] = {\n\t\"m-ahb\",\n\t\"s-ahb\",\n};\n\nstatic const struct geni_se_desc qup_desc = {\n\t.clks = qup_clks,\n\t.num_clks = ARRAY_SIZE(qup_clks),\n};\n\nstatic const char * const i2c_master_hub_clks[] = {\n\t\"s-ahb\",\n};\n\nstatic const struct geni_se_desc i2c_master_hub_desc = {\n\t.clks = i2c_master_hub_clks,\n\t.num_clks = ARRAY_SIZE(i2c_master_hub_clks),\n};\n\nstatic const struct of_device_id geni_se_dt_match[] = {\n\t{ .compatible = \"qcom,geni-se-qup\", .data = &qup_desc },\n\t{ .compatible = \"qcom,geni-se-i2c-master-hub\", .data = &i2c_master_hub_desc },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, geni_se_dt_match);\n\nstatic struct platform_driver geni_se_driver = {\n\t.driver = {\n\t\t.name = \"geni_se_qup\",\n\t\t.of_match_table = geni_se_dt_match,\n\t},\n\t.probe = geni_se_probe,\n};\nmodule_platform_driver(geni_se_driver);\n\nMODULE_DESCRIPTION(\"GENI Serial Engine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}