{
  "module_name": "rpm_master_stats.c",
  "hash_id": "cfba453f0c215ea72b0cce0f9b8fcb7c245c0fba966276c8d5417ecf5a0fc449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/rpm_master_stats.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\nstruct master_stats_data {\n\tvoid __iomem *base;\n\tconst char *label;\n};\n\nstruct rpm_master_stats {\n\tu32 active_cores;\n\tu32 num_shutdowns;\n\tu64 shutdown_req;\n\tu64 wakeup_idx;\n\tu64 bringup_req;\n\tu64 bringup_ack;\n\tu32 wakeup_reason;  \n\tu32 last_sleep_trans_dur;\n\tu32 last_wake_trans_dur;\n\n\t \n\tu32 xo_count;\n\tu64 xo_last_enter;\n\tu64 last_exit;\n\tu64 xo_total_dur;\n} __packed;\n\nstatic int master_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct master_stats_data *data = s->private;\n\tstruct rpm_master_stats stat;\n\n\tmemcpy_fromio(&stat, data->base, sizeof(stat));\n\n\tseq_printf(s, \"%s:\\n\", data->label);\n\n\tseq_printf(s, \"\\tLast shutdown @ %llu\\n\", stat.shutdown_req);\n\tseq_printf(s, \"\\tLast bringup req @ %llu\\n\", stat.bringup_req);\n\tseq_printf(s, \"\\tLast bringup ack @ %llu\\n\", stat.bringup_ack);\n\tseq_printf(s, \"\\tLast wakeup idx: %llu\\n\", stat.wakeup_idx);\n\tseq_printf(s, \"\\tLast XO shutdown enter @ %llu\\n\", stat.xo_last_enter);\n\tseq_printf(s, \"\\tLast XO shutdown exit @ %llu\\n\", stat.last_exit);\n\tseq_printf(s, \"\\tXO total duration: %llu\\n\", stat.xo_total_dur);\n\tseq_printf(s, \"\\tLast sleep transition duration: %u\\n\", stat.last_sleep_trans_dur);\n\tseq_printf(s, \"\\tLast wake transition duration: %u\\n\", stat.last_wake_trans_dur);\n\tseq_printf(s, \"\\tXO shutdown count: %u\\n\", stat.xo_count);\n\tseq_printf(s, \"\\tWakeup reason: 0x%x\\n\", stat.wakeup_reason);\n\tseq_printf(s, \"\\tShutdown count: %u\\n\", stat.num_shutdowns);\n\tseq_printf(s, \"\\tActive cores bitmask: 0x%x\\n\", stat.active_cores);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(master_stats);\n\nstatic int master_stats_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct master_stats_data *data;\n\tstruct device_node *msgram_np;\n\tstruct dentry *dent, *root;\n\tstruct resource res;\n\tint count, i, ret;\n\n\tcount = of_property_count_strings(dev->of_node, \"qcom,master-names\");\n\tif (count < 0)\n\t\treturn count;\n\n\tdata = devm_kzalloc(dev, count * sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\troot = debugfs_create_dir(\"qcom_rpm_master_stats\", NULL);\n\tplatform_set_drvdata(pdev, root);\n\n\tfor (i = 0; i < count; i++) {\n\t\tmsgram_np = of_parse_phandle(dev->of_node, \"qcom,rpm-msg-ram\", i);\n\t\tif (!msgram_np) {\n\t\t\tdebugfs_remove_recursive(root);\n\t\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t\t     \"Couldn't parse MSG RAM phandle idx %d\", i);\n\t\t}\n\n\t\t \n\t\tret = of_address_to_resource(msgram_np, 0, &res);\n\t\tof_node_put(msgram_np);\n\t\tif (ret < 0) {\n\t\t\tdebugfs_remove_recursive(root);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata[i].base = devm_ioremap(dev, res.start, resource_size(&res));\n\t\tif (!data[i].base) {\n\t\t\tdebugfs_remove_recursive(root);\n\t\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t\t     \"Could not map the MSG RAM slice idx %d!\\n\", i);\n\t\t}\n\n\t\tret = of_property_read_string_index(dev->of_node, \"qcom,master-names\", i,\n\t\t\t\t\t\t    &data[i].label);\n\t\tif (ret < 0) {\n\t\t\tdebugfs_remove_recursive(root);\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"Could not read name idx %d!\\n\", i);\n\t\t}\n\n\t\t \n\t\tdent = debugfs_create_file(data[i].label, 0444, root,\n\t\t\t\t\t   &data[i], &master_stats_fops);\n\t\tif (IS_ERR(dent)) {\n\t\t\tdebugfs_remove_recursive(root);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(dent),\n\t\t\t\t\t     \"Failed to create debugfs file %s!\\n\", data[i].label);\n\t\t}\n\t}\n\n\tdevice_set_pm_not_required(dev);\n\n\treturn 0;\n}\n\nstatic void master_stats_remove(struct platform_device *pdev)\n{\n\tstruct dentry *root = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(root);\n}\n\nstatic const struct of_device_id rpm_master_table[] = {\n\t{ .compatible = \"qcom,rpm-master-stats\" },\n\t{ },\n};\n\nstatic struct platform_driver master_stats_driver = {\n\t.probe = master_stats_probe,\n\t.remove_new = master_stats_remove,\n\t.driver = {\n\t\t.name = \"qcom_rpm_master_stats\",\n\t\t.of_match_table = rpm_master_table,\n\t},\n};\nmodule_platform_driver(master_stats_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm RPM Master Statistics driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}