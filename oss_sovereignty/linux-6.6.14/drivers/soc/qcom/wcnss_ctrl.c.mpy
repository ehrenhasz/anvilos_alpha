{
  "module_name": "wcnss_ctrl.c",
  "hash_id": "7c7a4e3137fb2598a06b9272c0deb324737aa24ede7e87eb6a710202e8102fde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/wcnss_ctrl.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/rpmsg.h>\n#include <linux/soc/qcom/wcnss_ctrl.h>\n\n#define WCNSS_REQUEST_TIMEOUT\t(5 * HZ)\n#define WCNSS_CBC_TIMEOUT\t(10 * HZ)\n\n#define WCNSS_ACK_DONE_BOOTING\t1\n#define WCNSS_ACK_COLD_BOOTING\t2\n\n#define NV_FRAGMENT_SIZE\t3072\n#define NVBIN_FILE\t\t\"wlan/prima/WCNSS_qcom_wlan_nv.bin\"\n\n \nstruct wcnss_ctrl {\n\tstruct device *dev;\n\tstruct rpmsg_endpoint *channel;\n\n\tstruct completion ack;\n\tstruct completion cbc;\n\tint ack_status;\n\n\tstruct work_struct probe_work;\n};\n\n \nenum {\n\tWCNSS_VERSION_REQ = 0x01000000,\n\tWCNSS_VERSION_RESP,\n\tWCNSS_DOWNLOAD_NV_REQ,\n\tWCNSS_DOWNLOAD_NV_RESP,\n\tWCNSS_UPLOAD_CAL_REQ,\n\tWCNSS_UPLOAD_CAL_RESP,\n\tWCNSS_DOWNLOAD_CAL_REQ,\n\tWCNSS_DOWNLOAD_CAL_RESP,\n\tWCNSS_VBAT_LEVEL_IND,\n\tWCNSS_BUILD_VERSION_REQ,\n\tWCNSS_BUILD_VERSION_RESP,\n\tWCNSS_PM_CONFIG_REQ,\n\tWCNSS_CBC_COMPLETE_IND,\n};\n\n \nstruct wcnss_msg_hdr {\n\tu32 type;\n\tu32 len;\n} __packed;\n\n \nstruct wcnss_version_resp {\n\tstruct wcnss_msg_hdr hdr;\n\tu8 major;\n\tu8 minor;\n\tu8 version;\n\tu8 revision;\n} __packed;\n\n \nstruct wcnss_download_nv_req {\n\tstruct wcnss_msg_hdr hdr;\n\tu16 seq;\n\tu16 last;\n\tu32 frag_size;\n\tu8 fragment[];\n} __packed;\n\n \nstruct wcnss_download_nv_resp {\n\tstruct wcnss_msg_hdr hdr;\n\tu8 status;\n} __packed;\n\n \nstatic int wcnss_ctrl_smd_callback(struct rpmsg_device *rpdev,\n\t\t\t\t   void *data,\n\t\t\t\t   int count,\n\t\t\t\t   void *priv,\n\t\t\t\t   u32 addr)\n{\n\tstruct wcnss_ctrl *wcnss = dev_get_drvdata(&rpdev->dev);\n\tconst struct wcnss_download_nv_resp *nvresp;\n\tconst struct wcnss_version_resp *version;\n\tconst struct wcnss_msg_hdr *hdr = data;\n\n\tswitch (hdr->type) {\n\tcase WCNSS_VERSION_RESP:\n\t\tif (count != sizeof(*version)) {\n\t\t\tdev_err(wcnss->dev,\n\t\t\t\t\"invalid size of version response\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tversion = data;\n\t\tdev_info(wcnss->dev, \"WCNSS Version %d.%d %d.%d\\n\",\n\t\t\t version->major, version->minor,\n\t\t\t version->version, version->revision);\n\n\t\tcomplete(&wcnss->ack);\n\t\tbreak;\n\tcase WCNSS_DOWNLOAD_NV_RESP:\n\t\tif (count != sizeof(*nvresp)) {\n\t\t\tdev_err(wcnss->dev,\n\t\t\t\t\"invalid size of download response\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tnvresp = data;\n\t\twcnss->ack_status = nvresp->status;\n\t\tcomplete(&wcnss->ack);\n\t\tbreak;\n\tcase WCNSS_CBC_COMPLETE_IND:\n\t\tdev_dbg(wcnss->dev, \"cold boot complete\\n\");\n\t\tcomplete(&wcnss->cbc);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(wcnss->dev, \"unknown message type %d\\n\", hdr->type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wcnss_request_version(struct wcnss_ctrl *wcnss)\n{\n\tstruct wcnss_msg_hdr msg;\n\tint ret;\n\n\tmsg.type = WCNSS_VERSION_REQ;\n\tmsg.len = sizeof(msg);\n\tret = rpmsg_send(wcnss->channel, &msg, sizeof(msg));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&wcnss->ack, WCNSS_CBC_TIMEOUT);\n\tif (!ret) {\n\t\tdev_err(wcnss->dev, \"timeout waiting for version response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wcnss_download_nv(struct wcnss_ctrl *wcnss, bool *expect_cbc)\n{\n\tstruct wcnss_download_nv_req *req;\n\tconst struct firmware *fw;\n\tstruct device *dev = wcnss->dev;\n\tconst char *nvbin = NVBIN_FILE;\n\tconst void *data;\n\tssize_t left;\n\tint ret;\n\n\treq = kzalloc(sizeof(*req) + NV_FRAGMENT_SIZE, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_string(dev->of_node, \"firmware-name\", &nvbin);\n\tif (ret < 0 && ret != -EINVAL)\n\t\tgoto free_req;\n\n\tret = request_firmware(&fw, nvbin, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to load nv file %s: %d\\n\", nvbin, ret);\n\t\tgoto free_req;\n\t}\n\n\tdata = fw->data;\n\tleft = fw->size;\n\n\treq->hdr.type = WCNSS_DOWNLOAD_NV_REQ;\n\treq->hdr.len = sizeof(*req) + NV_FRAGMENT_SIZE;\n\n\treq->last = 0;\n\treq->frag_size = NV_FRAGMENT_SIZE;\n\n\treq->seq = 0;\n\tdo {\n\t\tif (left <= NV_FRAGMENT_SIZE) {\n\t\t\treq->last = 1;\n\t\t\treq->frag_size = left;\n\t\t\treq->hdr.len = sizeof(*req) + left;\n\t\t}\n\n\t\tmemcpy(req->fragment, data, req->frag_size);\n\n\t\tret = rpmsg_send(wcnss->channel, req, req->hdr.len);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to send smd packet\\n\");\n\t\t\tgoto release_fw;\n\t\t}\n\n\t\t \n\t\treq->seq++;\n\n\t\tdata += NV_FRAGMENT_SIZE;\n\t\tleft -= NV_FRAGMENT_SIZE;\n\t} while (left > 0);\n\n\tret = wait_for_completion_timeout(&wcnss->ack, WCNSS_REQUEST_TIMEOUT);\n\tif (!ret) {\n\t\tdev_err(dev, \"timeout waiting for nv upload ack\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t*expect_cbc = wcnss->ack_status == WCNSS_ACK_COLD_BOOTING;\n\t\tret = 0;\n\t}\n\nrelease_fw:\n\trelease_firmware(fw);\nfree_req:\n\tkfree(req);\n\n\treturn ret;\n}\n\n \nstruct rpmsg_endpoint *qcom_wcnss_open_channel(void *wcnss, const char *name, rpmsg_rx_cb_t cb, void *priv)\n{\n\tstruct rpmsg_channel_info chinfo;\n\tstruct wcnss_ctrl *_wcnss = wcnss;\n\n\tstrscpy(chinfo.name, name, sizeof(chinfo.name));\n\tchinfo.src = RPMSG_ADDR_ANY;\n\tchinfo.dst = RPMSG_ADDR_ANY;\n\n\treturn rpmsg_create_ept(_wcnss->channel->rpdev, cb, priv, chinfo);\n}\nEXPORT_SYMBOL(qcom_wcnss_open_channel);\n\nstatic void wcnss_async_probe(struct work_struct *work)\n{\n\tstruct wcnss_ctrl *wcnss = container_of(work, struct wcnss_ctrl, probe_work);\n\tbool expect_cbc;\n\tint ret;\n\n\tret = wcnss_request_version(wcnss);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = wcnss_download_nv(wcnss, &expect_cbc);\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tif (expect_cbc) {\n\t\tret = wait_for_completion_timeout(&wcnss->cbc, WCNSS_REQUEST_TIMEOUT);\n\t\tif (!ret)\n\t\t\tdev_err(wcnss->dev, \"expected cold boot completion\\n\");\n\t}\n\n\tof_platform_populate(wcnss->dev->of_node, NULL, NULL, wcnss->dev);\n}\n\nstatic int wcnss_ctrl_probe(struct rpmsg_device *rpdev)\n{\n\tstruct wcnss_ctrl *wcnss;\n\n\twcnss = devm_kzalloc(&rpdev->dev, sizeof(*wcnss), GFP_KERNEL);\n\tif (!wcnss)\n\t\treturn -ENOMEM;\n\n\twcnss->dev = &rpdev->dev;\n\twcnss->channel = rpdev->ept;\n\n\tinit_completion(&wcnss->ack);\n\tinit_completion(&wcnss->cbc);\n\tINIT_WORK(&wcnss->probe_work, wcnss_async_probe);\n\n\tdev_set_drvdata(&rpdev->dev, wcnss);\n\n\tschedule_work(&wcnss->probe_work);\n\n\treturn 0;\n}\n\nstatic void wcnss_ctrl_remove(struct rpmsg_device *rpdev)\n{\n\tstruct wcnss_ctrl *wcnss = dev_get_drvdata(&rpdev->dev);\n\n\tcancel_work_sync(&wcnss->probe_work);\n\tof_platform_depopulate(&rpdev->dev);\n}\n\nstatic const struct of_device_id wcnss_ctrl_of_match[] = {\n\t{ .compatible = \"qcom,wcnss\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wcnss_ctrl_of_match);\n\nstatic struct rpmsg_driver wcnss_ctrl_driver = {\n\t.probe = wcnss_ctrl_probe,\n\t.remove = wcnss_ctrl_remove,\n\t.callback = wcnss_ctrl_smd_callback,\n\t.drv  = {\n\t\t.name  = \"qcom_wcnss_ctrl\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = wcnss_ctrl_of_match,\n\t},\n};\n\nmodule_rpmsg_driver(wcnss_ctrl_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm WCNSS control driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}