{
  "module_name": "llcc-qcom.c",
  "hash_id": "4e43e2e390dbd9e8758f9a3cf6af44c9d6f2294ca6eea76f410cc6f5d5498b07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/llcc-qcom.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/llcc-qcom.h>\n\n#define ACTIVATE                      BIT(0)\n#define DEACTIVATE                    BIT(1)\n#define ACT_CLEAR                     BIT(0)\n#define ACT_COMPLETE                  BIT(4)\n#define ACT_CTRL_OPCODE_ACTIVATE      BIT(0)\n#define ACT_CTRL_OPCODE_DEACTIVATE    BIT(1)\n#define ACT_CTRL_ACT_TRIG             BIT(0)\n#define ACT_CTRL_OPCODE_SHIFT         0x01\n#define ATTR1_PROBE_TARGET_WAYS_SHIFT 0x02\n#define ATTR1_FIXED_SIZE_SHIFT        0x03\n#define ATTR1_PRIORITY_SHIFT          0x04\n#define ATTR1_MAX_CAP_SHIFT           0x10\n#define ATTR0_RES_WAYS_MASK           GENMASK(15, 0)\n#define ATTR0_BONUS_WAYS_MASK         GENMASK(31, 16)\n#define ATTR0_BONUS_WAYS_SHIFT        0x10\n#define LLCC_STATUS_READ_DELAY        100\n\n#define CACHE_LINE_SIZE_SHIFT         6\n\n#define LLCC_LB_CNT_MASK              GENMASK(31, 28)\n#define LLCC_LB_CNT_SHIFT             28\n\n#define MAX_CAP_TO_BYTES(n)           (n * SZ_1K)\n#define LLCC_TRP_ACT_CTRLn(n)         (n * SZ_4K)\n#define LLCC_TRP_ACT_CLEARn(n)        (8 + n * SZ_4K)\n#define LLCC_TRP_STATUSn(n)           (4 + n * SZ_4K)\n#define LLCC_TRP_ATTR0_CFGn(n)        (0x21000 + SZ_8 * n)\n#define LLCC_TRP_ATTR1_CFGn(n)        (0x21004 + SZ_8 * n)\n#define LLCC_TRP_ATTR2_CFGn(n)        (0x21100 + SZ_4 * n)\n\n#define LLCC_TRP_SCID_DIS_CAP_ALLOC   0x21f00\n#define LLCC_TRP_PCB_ACT              0x21f04\n#define LLCC_TRP_ALGO_CFG1\t      0x21f0c\n#define LLCC_TRP_ALGO_CFG2\t      0x21f10\n#define LLCC_TRP_ALGO_CFG3\t      0x21f14\n#define LLCC_TRP_ALGO_CFG4\t      0x21f18\n#define LLCC_TRP_ALGO_CFG5\t      0x21f1c\n#define LLCC_TRP_WRSC_EN              0x21f20\n#define LLCC_TRP_ALGO_CFG6\t      0x21f24\n#define LLCC_TRP_ALGO_CFG7\t      0x21f28\n#define LLCC_TRP_WRSC_CACHEABLE_EN    0x21f2c\n#define LLCC_TRP_ALGO_CFG8\t      0x21f30\n\n#define LLCC_VERSION_2_0_0_0          0x02000000\n#define LLCC_VERSION_2_1_0_0          0x02010000\n#define LLCC_VERSION_4_1_0_0          0x04010000\n\n \nstruct llcc_slice_config {\n\tu32 usecase_id;\n\tu32 slice_id;\n\tu32 max_cap;\n\tu32 priority;\n\tbool fixed_size;\n\tu32 bonus_ways;\n\tu32 res_ways;\n\tu32 cache_mode;\n\tu32 probe_target_ways;\n\tbool dis_cap_alloc;\n\tbool retain_on_pc;\n\tbool activate_on_init;\n\tbool write_scid_en;\n\tbool write_scid_cacheable_en;\n\tbool stale_en;\n\tbool stale_cap_en;\n\tbool mru_uncap_en;\n\tbool mru_rollover;\n\tbool alloc_oneway_en;\n\tbool ovcap_en;\n\tbool ovcap_prio;\n\tbool vict_prio;\n};\n\nstruct qcom_llcc_config {\n\tconst struct llcc_slice_config *sct_data;\n\tconst u32 *reg_offset;\n\tconst struct llcc_edac_reg_offset *edac_reg_offset;\n\tint size;\n\tbool need_llcc_cfg;\n\tbool no_edac;\n};\n\nenum llcc_reg_offset {\n\tLLCC_COMMON_HW_INFO,\n\tLLCC_COMMON_STATUS0,\n};\n\nstatic const struct llcc_slice_config sc7180_data[] =  {\n\t{ LLCC_CPUSS,    1,  256, 1, 0, 0xf, 0x0, 0, 0, 0, 1, 1 },\n\t{ LLCC_MDM,      8,  128, 1, 0, 0xf, 0x0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 128, 1, 0, 0xf, 0x0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPU,      12, 128, 1, 0, 0xf, 0x0, 0, 0, 0, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sc7280_data[] =  {\n\t{ LLCC_CPUSS,    1,  768, 1, 0, 0x3f, 0x0, 0, 0, 0, 1, 1, 0},\n\t{ LLCC_MDMHPGRW, 7,  512, 2, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_CMPT,     10, 768, 1, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_GPUHTW,   11, 256, 1, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_GPU,      12, 512, 1, 0, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_MMUHWT,   13, 256, 1, 1, 0x3f, 0x0, 0, 0, 0, 0, 1, 0},\n\t{ LLCC_MDMPNG,   21, 768, 0, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_WLHW,     24, 256, 1, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n\t{ LLCC_MODPE,    29, 64,  1, 1, 0x3f, 0x0, 0, 0, 0, 1, 0, 0},\n};\n\nstatic const struct llcc_slice_config sc8180x_data[] = {\n\t{ LLCC_CPUSS,    1, 6144,  1, 1, 0xfff, 0x0,   0, 0, 0, 1, 1 },\n\t{ LLCC_VIDSC0,   2, 512,   2, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_VIDSC1,   3, 512,   2, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_AUDIO,    6, 1024,  1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MDMHPGRW, 7, 3072,  1, 1, 0x3ff, 0xc00, 0, 0, 0, 1, 0 },\n\t{ LLCC_MDM,      8, 3072,  1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MODHW,    9, 1024,  1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_CMPT,     10, 6144, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 1024, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_GPU,      12, 5120, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MMUHWT,   13, 1024, 1, 1, 0xfff, 0x0,   0, 0, 0, 0, 1 },\n\t{ LLCC_CMPTDMA,  15, 6144, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_DISP,     16, 6144, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_VIDFW,    17, 1024, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MDMHPFX,  20, 1024, 2, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MDMPNG,   21, 1024, 0, 1, 0xc,   0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_AUDHW,    22, 1024, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_NPU,      23, 6144, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_WLHW,     24, 6144, 1, 1, 0xfff, 0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_MODPE,    29, 512,  1, 1, 0xc,   0x0,   0, 0, 0, 1, 0 },\n\t{ LLCC_APTCM,    30, 512,  3, 1, 0x0,   0x1,   1, 0, 0, 1, 0 },\n\t{ LLCC_WRCACHE,  31, 128,  1, 1, 0xfff, 0x0,   0, 0, 0, 0, 0 },\n};\n\nstatic const struct llcc_slice_config sc8280xp_data[] = {\n\t{ LLCC_CPUSS,    1,  6144, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 1, 0 },\n\t{ LLCC_VIDSC0,   2,  512,  3, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_AUDIO,    6,  1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 0 },\n\t{ LLCC_CMPT,     10, 6144, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 0 },\n\t{ LLCC_GPUHTW,   11, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_GPU,      12, 4096, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 1 },\n\t{ LLCC_MMUHWT,   13, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_DISP,     16, 6144, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_AUDHW,    22, 2048, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_DRE,      26, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_CVP,      28, 512,  3, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_APTCM,    30, 1024, 3, 1, 0x0,   0x1, 1, 0, 0, 1, 0, 0 },\n\t{ LLCC_WRCACHE,  31, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CVPFW,    17, 512,  1, 0, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_CPUSS1,   3, 2048, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_CPUHWT,   5, 512,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sdm845_data[] =  {\n\t{ LLCC_CPUSS,    1,  2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 1 },\n\t{ LLCC_VIDSC0,   2,  512,  2, 1, 0x0,   0x0f0, 0, 0, 1, 1, 0 },\n\t{ LLCC_VIDSC1,   3,  512,  2, 1, 0x0,   0x0f0, 0, 0, 1, 1, 0 },\n\t{ LLCC_ROTATOR,  4,  563,  2, 1, 0x0,   0x00e, 2, 0, 1, 1, 0 },\n\t{ LLCC_VOICE,    5,  2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_AUDIO,    6,  2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_MDMHPGRW, 7,  1024, 2, 0, 0xfc,  0xf00, 0, 0, 1, 1, 0 },\n\t{ LLCC_MDM,      8,  2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_CMPT,     10, 2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 512,  1, 1, 0xc,   0x0,   0, 0, 1, 1, 0 },\n\t{ LLCC_GPU,      12, 2304, 1, 0, 0xff0, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_MMUHWT,   13, 256,  2, 0, 0x0,   0x1,   0, 0, 1, 0, 1 },\n\t{ LLCC_CMPTDMA,  15, 2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_DISP,     16, 2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_VIDFW,    17, 2816, 1, 0, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n\t{ LLCC_MDMHPFX,  20, 1024, 2, 1, 0x0,   0xf00, 0, 0, 1, 1, 0 },\n\t{ LLCC_MDMPNG,   21, 1024, 0, 1, 0x1e,  0x0,   0, 0, 1, 1, 0 },\n\t{ LLCC_AUDHW,    22, 1024, 1, 1, 0xffc, 0x2,   0, 0, 1, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sm6350_data[] =  {\n\t{ LLCC_CPUSS,    1,  768, 1, 0, 0xFFF, 0x0, 0, 0, 0, 0, 1, 1 },\n\t{ LLCC_MDM,      8,  512, 2, 0, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 256, 1, 0, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPU,      12, 512, 1, 0, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_MDMPNG,   21, 768, 0, 1, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_NPU,      23, 768, 1, 0, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_MODPE,    29,  64, 1, 1, 0xFFF, 0x0, 0, 0, 0, 0, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sm7150_data[] =  {\n\t{ LLCC_CPUSS,    1,  512, 1, 0, 0xF, 0x0, 0, 0, 0, 1, 1 },\n\t{ LLCC_MDM,      8,  128, 2, 0, 0xF, 0x0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 256, 1, 1, 0xF, 0x0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPU,      12, 256, 1, 1, 0xF, 0x0, 0, 0, 0, 1, 0 },\n\t{ LLCC_NPU,      23, 512, 1, 0, 0xF, 0x0, 0, 0, 0, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sm8150_data[] =  {\n\t{  LLCC_CPUSS,    1, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 1 },\n\t{  LLCC_VIDSC0,   2, 512,  2, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_VIDSC1,   3, 512,  2, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_AUDIO,    6, 1024, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MDMHPGRW, 7, 3072, 1, 0, 0xFF,  0xF00, 0, 0, 0, 1, 0 },\n\t{  LLCC_MDM,      8, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MODHW,    9, 1024, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_CMPT,    10, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_GPUHTW , 11, 512,  1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_GPU,     12, 2560, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MMUHWT,  13, 1024, 1, 1, 0xFFF, 0x0,   0, 0, 0, 0, 1 },\n\t{  LLCC_CMPTDMA, 15, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_DISP,    16, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MDMHPFX, 20, 1024, 2, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MDMHPFX, 21, 1024, 0, 1, 0xF,   0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_AUDHW,   22, 1024, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_NPU,     23, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_WLHW,    24, 3072, 1, 1, 0xFFF, 0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_MODPE,   29, 256,  1, 1, 0xF,   0x0,   0, 0, 0, 1, 0 },\n\t{  LLCC_APTCM,   30, 256,  3, 1, 0x0,   0x1,   1, 0, 0, 1, 0 },\n\t{  LLCC_WRCACHE, 31, 128,  1, 1, 0xFFF, 0x0,   0, 0, 0, 0, 0 },\n};\n\nstatic const struct llcc_slice_config sm8250_data[] =  {\n\t{ LLCC_CPUSS,    1, 3072, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 1, 0 },\n\t{ LLCC_VIDSC0,   2, 512,  3, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_AUDIO,    6, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 0, 0, 0 },\n\t{ LLCC_CMPT,    10, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 0, 0, 0 },\n\t{ LLCC_GPUHTW,  11, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_GPU,     12, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 1, 0, 1 },\n\t{ LLCC_MMUHWT,  13, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CMPTDMA, 15, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_DISP,    16, 3072, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_VIDFW,   17, 512,  1, 0, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_AUDHW,   22, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_NPU,     23, 3072, 1, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_WLHW,    24, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_CVP,     28, 256,  3, 1, 0xfff, 0x0, 0, 0, 0, 1, 0, 0 },\n\t{ LLCC_APTCM,   30, 128,  3, 0, 0x0,   0x3, 1, 0, 0, 1, 0, 0 },\n\t{ LLCC_WRCACHE, 31, 256,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n};\n\nstatic const struct llcc_slice_config sm8350_data[] =  {\n\t{ LLCC_CPUSS,    1, 3072,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 1 },\n\t{ LLCC_VIDSC0,   2, 512,   3, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_AUDIO,    6, 1024,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 0 },\n\t{ LLCC_MDMHPGRW, 7, 1024,  3, 0, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_MODHW,    9, 1024,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CMPT,     10, 3072, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPUHTW,   11, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_GPU,      12, 1024, 1, 0, 0xfff, 0x0, 0, 0, 0, 1, 1, 0 },\n\t{ LLCC_MMUHWT,   13, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 1 },\n\t{ LLCC_DISP,     16, 3072, 2, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_MDMPNG,   21, 1024, 0, 1, 0xf,   0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_AUDHW,    22, 1024, 1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CVP,      28, 512,  3, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_MODPE,    29, 256,  1, 1, 0xf,   0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_APTCM,    30, 1024, 3, 1, 0x0,   0x1, 1, 0, 0, 0, 1, 0 },\n\t{ LLCC_WRCACHE,  31, 512,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 1 },\n\t{ LLCC_CVPFW,    17, 512,  1, 0, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CPUSS1,   3, 1024,  1, 1, 0xfff, 0x0, 0, 0, 0, 0, 1, 0 },\n\t{ LLCC_CPUHWT,   5, 512,   1, 1, 0xfff, 0x0, 0, 0, 0, 0, 0, 1 },\n};\n\nstatic const struct llcc_slice_config sm8450_data[] =  {\n\t{LLCC_CPUSS,     1, 3072, 1, 0, 0xFFFF, 0x0,   0, 0, 0, 1, 1, 0, 0 },\n\t{LLCC_VIDSC0,    2,  512, 3, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_AUDIO,     6, 1024, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0 },\n\t{LLCC_MDMHPGRW,  7, 1024, 3, 0, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_MODHW,     9, 1024, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_CMPT,     10, 4096, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_GPUHTW,   11,  512, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_GPU,      12, 2048, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 1, 0 },\n\t{LLCC_MMUHWT,   13,  768, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0 },\n\t{LLCC_DISP,     16, 4096, 2, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_MDMPNG,   21, 1024, 1, 1, 0xF000, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_AUDHW,    22, 1024, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0 },\n\t{LLCC_CVP,      28,  256, 3, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_MODPE,    29,   64, 1, 1, 0xF000, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_APTCM,    30, 1024, 3, 1, 0x0,    0xF0,  1, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_WRCACHE,  31,  512, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0 },\n\t{LLCC_CVPFW,    17,  512, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_CPUSS1,    3, 1024, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_CAMEXP0,   4,  256, 3, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_CPUMTE,   23,  256, 1, 1, 0x0FFF, 0x0,   0, 0, 0, 0, 1, 0, 0 },\n\t{LLCC_CPUHWT,    5,  512, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 1, 0, 0 },\n\t{LLCC_CAMEXP1,  27,  256, 3, 1, 0xFFFF, 0x0,   0, 0, 0, 1, 0, 0, 0 },\n\t{LLCC_AENPU,     8, 2048, 1, 1, 0xFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0 },\n};\n\nstatic const struct llcc_slice_config sm8550_data[] =  {\n\t{LLCC_CPUSS,     1, 5120, 1, 0, 0xFFFFFF, 0x0,   0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_VIDSC0,    2,  512, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_AUDIO,     6, 1024, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_MDMHPGRW, 25, 1024, 4, 0, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_MODHW,    26, 1024, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CMPT,     10, 4096, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_GPUHTW,   11,  512, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_GPU,       9, 3096, 1, 0, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_MMUHWT,   18,  768, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_DISP,     16, 6144, 1, 1, 0xFFFFFF, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_MDMPNG,   27, 1024, 0, 1, 0xF00000, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_AUDHW,    22, 1024, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CVP,       8,  256, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_MODPE,    29,   64, 1, 1, 0xF00000, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, },\n\t{LLCC_WRCACHE,  31,  512, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CAMEXP0,   4,  256, 4, 1,      0xF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CPUHWT,    5,  512, 1, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CAMEXP1,   7, 3200, 3, 1, 0xFFFFF0, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CMPTHCP,  17,  256, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_LCPDARE,  30,  128, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, },\n\t{LLCC_AENPU,     3, 3072, 1, 1, 0xFE01FF, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_ISLAND1,  12, 1792, 7, 1,   0xFE00, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_ISLAND4,  15,  256, 7, 1,  0x10000, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CAMEXP2,  19, 3200, 3, 1, 0xFFFFF0, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CAMEXP3,  20, 3200, 2, 1, 0xFFFFF0, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_CAMEXP4,  21, 3200, 2, 1, 0xFFFFF0, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_DISP_WB,  23, 1024, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_DISP_1,   24, 6144, 1, 1, 0xFFFFFF, 0x0,   2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t{LLCC_VIDVSP,   28,  256, 4, 1, 0xFFFFFF, 0x0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n};\n\nstatic const struct llcc_edac_reg_offset llcc_v1_edac_reg_offset = {\n\t.trp_ecc_error_status0 = 0x20344,\n\t.trp_ecc_error_status1 = 0x20348,\n\t.trp_ecc_sb_err_syn0 = 0x2304c,\n\t.trp_ecc_db_err_syn0 = 0x20370,\n\t.trp_ecc_error_cntr_clear = 0x20440,\n\t.trp_interrupt_0_status = 0x20480,\n\t.trp_interrupt_0_clear = 0x20484,\n\t.trp_interrupt_0_enable = 0x20488,\n\n\t \n\t.cmn_status0 = 0x3000c,\n\t.cmn_interrupt_0_enable = 0x3001c,\n\t.cmn_interrupt_2_enable = 0x3003c,\n\n\t \n\t.drp_ecc_error_cfg = 0x40000,\n\t.drp_ecc_error_cntr_clear = 0x40004,\n\t.drp_interrupt_status = 0x41000,\n\t.drp_interrupt_clear = 0x41008,\n\t.drp_interrupt_enable = 0x4100c,\n\t.drp_ecc_error_status0 = 0x42044,\n\t.drp_ecc_error_status1 = 0x42048,\n\t.drp_ecc_sb_err_syn0 = 0x4204c,\n\t.drp_ecc_db_err_syn0 = 0x42070,\n};\n\nstatic const struct llcc_edac_reg_offset llcc_v2_1_edac_reg_offset = {\n\t.trp_ecc_error_status0 = 0x20344,\n\t.trp_ecc_error_status1 = 0x20348,\n\t.trp_ecc_sb_err_syn0 = 0x2034c,\n\t.trp_ecc_db_err_syn0 = 0x20370,\n\t.trp_ecc_error_cntr_clear = 0x20440,\n\t.trp_interrupt_0_status = 0x20480,\n\t.trp_interrupt_0_clear = 0x20484,\n\t.trp_interrupt_0_enable = 0x20488,\n\n\t \n\t.cmn_status0 = 0x3400c,\n\t.cmn_interrupt_0_enable = 0x3401c,\n\t.cmn_interrupt_2_enable = 0x3403c,\n\n\t \n\t.drp_ecc_error_cfg = 0x50000,\n\t.drp_ecc_error_cntr_clear = 0x50004,\n\t.drp_interrupt_status = 0x50020,\n\t.drp_interrupt_clear = 0x50028,\n\t.drp_interrupt_enable = 0x5002c,\n\t.drp_ecc_error_status0 = 0x520f4,\n\t.drp_ecc_error_status1 = 0x520f8,\n\t.drp_ecc_sb_err_syn0 = 0x520fc,\n\t.drp_ecc_db_err_syn0 = 0x52120,\n};\n\n \nstatic const u32 llcc_v1_reg_offset[] = {\n\t[LLCC_COMMON_HW_INFO]\t= 0x00030000,\n\t[LLCC_COMMON_STATUS0]\t= 0x0003000c,\n};\n\n \nstatic const u32 llcc_v2_1_reg_offset[] = {\n\t[LLCC_COMMON_HW_INFO]\t= 0x00034000,\n\t[LLCC_COMMON_STATUS0]\t= 0x0003400c,\n};\n\nstatic const struct qcom_llcc_config sc7180_cfg = {\n\t.sct_data\t= sc7180_data,\n\t.size\t\t= ARRAY_SIZE(sc7180_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sc7280_cfg = {\n\t.sct_data\t= sc7280_data,\n\t.size\t\t= ARRAY_SIZE(sc7280_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sc8180x_cfg = {\n\t.sct_data\t= sc8180x_data,\n\t.size\t\t= ARRAY_SIZE(sc8180x_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sc8280xp_cfg = {\n\t.sct_data\t= sc8280xp_data,\n\t.size\t\t= ARRAY_SIZE(sc8280xp_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sdm845_cfg = {\n\t.sct_data\t= sdm845_data,\n\t.size\t\t= ARRAY_SIZE(sdm845_data),\n\t.need_llcc_cfg\t= false,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n\t.no_edac\t= true,\n};\n\nstatic const struct qcom_llcc_config sm6350_cfg = {\n\t.sct_data\t= sm6350_data,\n\t.size\t\t= ARRAY_SIZE(sm6350_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm7150_cfg = {\n\t.sct_data       = sm7150_data,\n\t.size           = ARRAY_SIZE(sm7150_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm8150_cfg = {\n\t.sct_data       = sm8150_data,\n\t.size           = ARRAY_SIZE(sm8150_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm8250_cfg = {\n\t.sct_data       = sm8250_data,\n\t.size           = ARRAY_SIZE(sm8250_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm8350_cfg = {\n\t.sct_data       = sm8350_data,\n\t.size           = ARRAY_SIZE(sm8350_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v1_reg_offset,\n\t.edac_reg_offset = &llcc_v1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm8450_cfg = {\n\t.sct_data       = sm8450_data,\n\t.size           = ARRAY_SIZE(sm8450_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v2_1_reg_offset,\n\t.edac_reg_offset = &llcc_v2_1_edac_reg_offset,\n};\n\nstatic const struct qcom_llcc_config sm8550_cfg = {\n\t.sct_data       = sm8550_data,\n\t.size           = ARRAY_SIZE(sm8550_data),\n\t.need_llcc_cfg\t= true,\n\t.reg_offset\t= llcc_v2_1_reg_offset,\n\t.edac_reg_offset = &llcc_v2_1_edac_reg_offset,\n};\n\nstatic struct llcc_drv_data *drv_data = (void *) -EPROBE_DEFER;\n\n \nstruct llcc_slice_desc *llcc_slice_getd(u32 uid)\n{\n\tconst struct llcc_slice_config *cfg;\n\tstruct llcc_slice_desc *desc;\n\tu32 sz, count;\n\n\tif (IS_ERR(drv_data))\n\t\treturn ERR_CAST(drv_data);\n\n\tcfg = drv_data->cfg;\n\tsz = drv_data->cfg_size;\n\n\tfor (count = 0; cfg && count < sz; count++, cfg++)\n\t\tif (cfg->usecase_id == uid)\n\t\t\tbreak;\n\n\tif (count == sz || !cfg)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->slice_id = cfg->slice_id;\n\tdesc->slice_size = cfg->max_cap;\n\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(llcc_slice_getd);\n\n \nvoid llcc_slice_putd(struct llcc_slice_desc *desc)\n{\n\tif (!IS_ERR_OR_NULL(desc))\n\t\tkfree(desc);\n}\nEXPORT_SYMBOL_GPL(llcc_slice_putd);\n\nstatic int llcc_update_act_ctrl(u32 sid,\n\t\t\t\tu32 act_ctrl_reg_val, u32 status)\n{\n\tu32 act_ctrl_reg;\n\tu32 act_clear_reg;\n\tu32 status_reg;\n\tu32 slice_status;\n\tint ret;\n\n\tif (IS_ERR(drv_data))\n\t\treturn PTR_ERR(drv_data);\n\n\tact_ctrl_reg = LLCC_TRP_ACT_CTRLn(sid);\n\tact_clear_reg = LLCC_TRP_ACT_CLEARn(sid);\n\tstatus_reg = LLCC_TRP_STATUSn(sid);\n\n\t \n\tact_ctrl_reg_val |= ACT_CTRL_ACT_TRIG;\n\tret = regmap_write(drv_data->bcast_regmap, act_ctrl_reg,\n\t\t\t\tact_ctrl_reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tact_ctrl_reg_val &= ~ACT_CTRL_ACT_TRIG;\n\tret = regmap_write(drv_data->bcast_regmap, act_ctrl_reg,\n\t\t\t\tact_ctrl_reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (drv_data->version >= LLCC_VERSION_4_1_0_0) {\n\t\tret = regmap_read_poll_timeout(drv_data->bcast_regmap, status_reg,\n\t\t\t\t      slice_status, (slice_status & ACT_COMPLETE),\n\t\t\t\t      0, LLCC_STATUS_READ_DELAY);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read_poll_timeout(drv_data->bcast_regmap, status_reg,\n\t\t\t\t      slice_status, !(slice_status & status),\n\t\t\t\t      0, LLCC_STATUS_READ_DELAY);\n\n\tif (drv_data->version >= LLCC_VERSION_4_1_0_0)\n\t\tret = regmap_write(drv_data->bcast_regmap, act_clear_reg,\n\t\t\t\t\tACT_CLEAR);\n\n\treturn ret;\n}\n\n \nint llcc_slice_activate(struct llcc_slice_desc *desc)\n{\n\tint ret;\n\tu32 act_ctrl_val;\n\n\tif (IS_ERR(drv_data))\n\t\treturn PTR_ERR(drv_data);\n\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&drv_data->lock);\n\tif (test_bit(desc->slice_id, drv_data->bitmap)) {\n\t\tmutex_unlock(&drv_data->lock);\n\t\treturn 0;\n\t}\n\n\tact_ctrl_val = ACT_CTRL_OPCODE_ACTIVATE << ACT_CTRL_OPCODE_SHIFT;\n\n\tret = llcc_update_act_ctrl(desc->slice_id, act_ctrl_val,\n\t\t\t\t  DEACTIVATE);\n\tif (ret) {\n\t\tmutex_unlock(&drv_data->lock);\n\t\treturn ret;\n\t}\n\n\t__set_bit(desc->slice_id, drv_data->bitmap);\n\tmutex_unlock(&drv_data->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(llcc_slice_activate);\n\n \nint llcc_slice_deactivate(struct llcc_slice_desc *desc)\n{\n\tu32 act_ctrl_val;\n\tint ret;\n\n\tif (IS_ERR(drv_data))\n\t\treturn PTR_ERR(drv_data);\n\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&drv_data->lock);\n\tif (!test_bit(desc->slice_id, drv_data->bitmap)) {\n\t\tmutex_unlock(&drv_data->lock);\n\t\treturn 0;\n\t}\n\tact_ctrl_val = ACT_CTRL_OPCODE_DEACTIVATE << ACT_CTRL_OPCODE_SHIFT;\n\n\tret = llcc_update_act_ctrl(desc->slice_id, act_ctrl_val,\n\t\t\t\t  ACTIVATE);\n\tif (ret) {\n\t\tmutex_unlock(&drv_data->lock);\n\t\treturn ret;\n\t}\n\n\t__clear_bit(desc->slice_id, drv_data->bitmap);\n\tmutex_unlock(&drv_data->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(llcc_slice_deactivate);\n\n \nint llcc_get_slice_id(struct llcc_slice_desc *desc)\n{\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn -EINVAL;\n\n\treturn desc->slice_id;\n}\nEXPORT_SYMBOL_GPL(llcc_get_slice_id);\n\n \nsize_t llcc_get_slice_size(struct llcc_slice_desc *desc)\n{\n\tif (IS_ERR_OR_NULL(desc))\n\t\treturn 0;\n\n\treturn desc->slice_size;\n}\nEXPORT_SYMBOL_GPL(llcc_get_slice_size);\n\nstatic int _qcom_llcc_cfg_program(const struct llcc_slice_config *config,\n\t\t\t\t  const struct qcom_llcc_config *cfg)\n{\n\tint ret;\n\tu32 attr2_cfg;\n\tu32 attr1_cfg;\n\tu32 attr0_cfg;\n\tu32 attr2_val;\n\tu32 attr1_val;\n\tu32 attr0_val;\n\tu32 max_cap_cacheline;\n\tstruct llcc_slice_desc desc;\n\n\tattr1_val = config->cache_mode;\n\tattr1_val |= config->probe_target_ways << ATTR1_PROBE_TARGET_WAYS_SHIFT;\n\tattr1_val |= config->fixed_size << ATTR1_FIXED_SIZE_SHIFT;\n\tattr1_val |= config->priority << ATTR1_PRIORITY_SHIFT;\n\n\tmax_cap_cacheline = MAX_CAP_TO_BYTES(config->max_cap);\n\n\t \n\tmax_cap_cacheline = max_cap_cacheline / drv_data->num_banks;\n\tmax_cap_cacheline >>= CACHE_LINE_SIZE_SHIFT;\n\tattr1_val |= max_cap_cacheline << ATTR1_MAX_CAP_SHIFT;\n\n\tattr1_cfg = LLCC_TRP_ATTR1_CFGn(config->slice_id);\n\n\tret = regmap_write(drv_data->bcast_regmap, attr1_cfg, attr1_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (drv_data->version >= LLCC_VERSION_4_1_0_0) {\n\t\tattr2_cfg = LLCC_TRP_ATTR2_CFGn(config->slice_id);\n\t\tattr0_val = config->res_ways;\n\t\tattr2_val = config->bonus_ways;\n\t} else {\n\t\tattr0_val = config->res_ways & ATTR0_RES_WAYS_MASK;\n\t\tattr0_val |= config->bonus_ways << ATTR0_BONUS_WAYS_SHIFT;\n\t}\n\n\tattr0_cfg = LLCC_TRP_ATTR0_CFGn(config->slice_id);\n\n\tret = regmap_write(drv_data->bcast_regmap, attr0_cfg, attr0_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (drv_data->version >= LLCC_VERSION_4_1_0_0) {\n\t\tret = regmap_write(drv_data->bcast_regmap, attr2_cfg, attr2_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cfg->need_llcc_cfg) {\n\t\tu32 disable_cap_alloc, retain_pc;\n\n\t\tdisable_cap_alloc = config->dis_cap_alloc << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_SCID_DIS_CAP_ALLOC,\n\t\t\t\t\t BIT(config->slice_id), disable_cap_alloc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (drv_data->version < LLCC_VERSION_4_1_0_0) {\n\t\t\tretain_pc = config->retain_on_pc << config->slice_id;\n\t\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_PCB_ACT,\n\t\t\t\t\t\t BIT(config->slice_id), retain_pc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (drv_data->version >= LLCC_VERSION_2_0_0_0) {\n\t\tu32 wren;\n\n\t\twren = config->write_scid_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_WRSC_EN,\n\t\t\t\t\t BIT(config->slice_id), wren);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (drv_data->version >= LLCC_VERSION_2_1_0_0) {\n\t\tu32 wr_cache_en;\n\n\t\twr_cache_en = config->write_scid_cacheable_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_WRSC_CACHEABLE_EN,\n\t\t\t\t\t BIT(config->slice_id), wr_cache_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (drv_data->version >= LLCC_VERSION_4_1_0_0) {\n\t\tu32 stale_en;\n\t\tu32 stale_cap_en;\n\t\tu32 mru_uncap_en;\n\t\tu32 mru_rollover;\n\t\tu32 alloc_oneway_en;\n\t\tu32 ovcap_en;\n\t\tu32 ovcap_prio;\n\t\tu32 vict_prio;\n\n\t\tstale_en = config->stale_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG1,\n\t\t\t\t\t BIT(config->slice_id), stale_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstale_cap_en = config->stale_cap_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG2,\n\t\t\t\t\t BIT(config->slice_id), stale_cap_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmru_uncap_en = config->mru_uncap_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG3,\n\t\t\t\t\t BIT(config->slice_id), mru_uncap_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmru_rollover = config->mru_rollover << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG4,\n\t\t\t\t\t BIT(config->slice_id), mru_rollover);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\talloc_oneway_en = config->alloc_oneway_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG5,\n\t\t\t\t\t BIT(config->slice_id), alloc_oneway_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tovcap_en = config->ovcap_en << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG6,\n\t\t\t\t\t BIT(config->slice_id), ovcap_en);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tovcap_prio = config->ovcap_prio << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG7,\n\t\t\t\t\t BIT(config->slice_id), ovcap_prio);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvict_prio = config->vict_prio << config->slice_id;\n\t\tret = regmap_update_bits(drv_data->bcast_regmap, LLCC_TRP_ALGO_CFG8,\n\t\t\t\t\t BIT(config->slice_id), vict_prio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (config->activate_on_init) {\n\t\tdesc.slice_id = config->slice_id;\n\t\tret = llcc_slice_activate(&desc);\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_llcc_cfg_program(struct platform_device *pdev,\n\t\t\t\t const struct qcom_llcc_config *cfg)\n{\n\tint i;\n\tu32 sz;\n\tint ret = 0;\n\tconst struct llcc_slice_config *llcc_table;\n\n\tsz = drv_data->cfg_size;\n\tllcc_table = drv_data->cfg;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tret = _qcom_llcc_cfg_program(&llcc_table[i], cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_llcc_remove(struct platform_device *pdev)\n{\n\t \n\tdrv_data = ERR_PTR(-ENODEV);\n\treturn 0;\n}\n\nstatic struct regmap *qcom_llcc_init_mmio(struct platform_device *pdev, u8 index,\n\t\t\t\t\t  const char *name)\n{\n\tvoid __iomem *base;\n\tstruct regmap_config llcc_regmap_config = {\n\t\t.reg_bits = 32,\n\t\t.reg_stride = 4,\n\t\t.val_bits = 32,\n\t\t.fast_io = true,\n\t};\n\n\tbase = devm_platform_ioremap_resource(pdev, index);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\n\tllcc_regmap_config.name = name;\n\treturn devm_regmap_init_mmio(&pdev->dev, base, &llcc_regmap_config);\n}\n\nstatic int qcom_llcc_probe(struct platform_device *pdev)\n{\n\tu32 num_banks;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i;\n\tstruct platform_device *llcc_edac;\n\tconst struct qcom_llcc_config *cfg;\n\tconst struct llcc_slice_config *llcc_cfg;\n\tu32 sz;\n\tu32 version;\n\tstruct regmap *regmap;\n\n\tif (!IS_ERR(drv_data))\n\t\treturn -EBUSY;\n\n\tdrv_data = devm_kzalloc(dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tregmap = qcom_llcc_init_mmio(pdev, 0, \"llcc0_base\");\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err;\n\t}\n\n\tcfg = of_device_get_match_data(&pdev->dev);\n\n\tret = regmap_read(regmap, cfg->reg_offset[LLCC_COMMON_STATUS0], &num_banks);\n\tif (ret)\n\t\tgoto err;\n\n\tnum_banks &= LLCC_LB_CNT_MASK;\n\tnum_banks >>= LLCC_LB_CNT_SHIFT;\n\tdrv_data->num_banks = num_banks;\n\n\tdrv_data->regmaps = devm_kcalloc(dev, num_banks, sizeof(*drv_data->regmaps), GFP_KERNEL);\n\tif (!drv_data->regmaps) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdrv_data->regmaps[0] = regmap;\n\n\t \n\tfor (i = 1; i < num_banks; i++) {\n\t\tchar *base = kasprintf(GFP_KERNEL, \"llcc%d_base\", i);\n\n\t\tdrv_data->regmaps[i] = qcom_llcc_init_mmio(pdev, i, base);\n\t\tif (IS_ERR(drv_data->regmaps[i])) {\n\t\t\tret = PTR_ERR(drv_data->regmaps[i]);\n\t\t\tkfree(base);\n\t\t\tgoto err;\n\t\t}\n\n\t\tkfree(base);\n\t}\n\n\tdrv_data->bcast_regmap = qcom_llcc_init_mmio(pdev, i, \"llcc_broadcast_base\");\n\tif (IS_ERR(drv_data->bcast_regmap)) {\n\t\tret = PTR_ERR(drv_data->bcast_regmap);\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_read(drv_data->bcast_regmap, cfg->reg_offset[LLCC_COMMON_HW_INFO],\n\t\t\t  &version);\n\tif (ret)\n\t\tgoto err;\n\n\tdrv_data->version = version;\n\n\tllcc_cfg = cfg->sct_data;\n\tsz = cfg->size;\n\n\tfor (i = 0; i < sz; i++)\n\t\tif (llcc_cfg[i].slice_id > drv_data->max_slices)\n\t\t\tdrv_data->max_slices = llcc_cfg[i].slice_id;\n\n\tdrv_data->bitmap = devm_bitmap_zalloc(dev, drv_data->max_slices,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!drv_data->bitmap) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdrv_data->cfg = llcc_cfg;\n\tdrv_data->cfg_size = sz;\n\tdrv_data->edac_reg_offset = cfg->edac_reg_offset;\n\tmutex_init(&drv_data->lock);\n\tplatform_set_drvdata(pdev, drv_data);\n\n\tret = qcom_llcc_cfg_program(pdev, cfg);\n\tif (ret)\n\t\tgoto err;\n\n\tdrv_data->ecc_irq = platform_get_irq_optional(pdev, 0);\n\n\t \n\tif (!cfg->no_edac) {\n\t\tllcc_edac = platform_device_register_data(&pdev->dev,\n\t\t\t\t\t\t\"qcom_llcc_edac\", -1, drv_data,\n\t\t\t\t\t\tsizeof(*drv_data));\n\t\tif (IS_ERR(llcc_edac))\n\t\t\tdev_err(dev, \"Failed to register llcc edac driver\\n\");\n\t}\n\n\treturn 0;\nerr:\n\tdrv_data = ERR_PTR(-ENODEV);\n\treturn ret;\n}\n\nstatic const struct of_device_id qcom_llcc_of_match[] = {\n\t{ .compatible = \"qcom,sc7180-llcc\", .data = &sc7180_cfg },\n\t{ .compatible = \"qcom,sc7280-llcc\", .data = &sc7280_cfg },\n\t{ .compatible = \"qcom,sc8180x-llcc\", .data = &sc8180x_cfg },\n\t{ .compatible = \"qcom,sc8280xp-llcc\", .data = &sc8280xp_cfg },\n\t{ .compatible = \"qcom,sdm845-llcc\", .data = &sdm845_cfg },\n\t{ .compatible = \"qcom,sm6350-llcc\", .data = &sm6350_cfg },\n\t{ .compatible = \"qcom,sm7150-llcc\", .data = &sm7150_cfg },\n\t{ .compatible = \"qcom,sm8150-llcc\", .data = &sm8150_cfg },\n\t{ .compatible = \"qcom,sm8250-llcc\", .data = &sm8250_cfg },\n\t{ .compatible = \"qcom,sm8350-llcc\", .data = &sm8350_cfg },\n\t{ .compatible = \"qcom,sm8450-llcc\", .data = &sm8450_cfg },\n\t{ .compatible = \"qcom,sm8550-llcc\", .data = &sm8550_cfg },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_llcc_of_match);\n\nstatic struct platform_driver qcom_llcc_driver = {\n\t.driver = {\n\t\t.name = \"qcom-llcc\",\n\t\t.of_match_table = qcom_llcc_of_match,\n\t},\n\t.probe = qcom_llcc_probe,\n\t.remove = qcom_llcc_remove,\n};\nmodule_platform_driver(qcom_llcc_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Last Level Cache Controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}