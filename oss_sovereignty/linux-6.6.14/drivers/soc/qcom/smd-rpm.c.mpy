{
  "module_name": "smd-rpm.c",
  "hash_id": "4330c24e2fa2bcd3cfae59fbcf534ed22b716b3a4ee3d559237081b26b8f774b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/smd-rpm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_platform.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#include <linux/rpmsg.h>\n#include <linux/soc/qcom/smd-rpm.h>\n\n#define RPM_REQUEST_TIMEOUT     (5 * HZ)\n\n \nstruct qcom_smd_rpm {\n\tstruct rpmsg_endpoint *rpm_channel;\n\tstruct device *dev;\n\n\tstruct completion ack;\n\tstruct mutex lock;\n\tint ack_status;\n};\n\n \nstruct qcom_rpm_header {\n\t__le32 service_type;\n\t__le32 length;\n};\n\n \nstruct qcom_rpm_request {\n\t__le32 msg_id;\n\t__le32 flags;\n\t__le32 type;\n\t__le32 id;\n\t__le32 data_len;\n};\n\n \nstruct qcom_rpm_message {\n\t__le32 msg_type;\n\t__le32 length;\n\tunion {\n\t\t__le32 msg_id;\n\t\tDECLARE_FLEX_ARRAY(u8, message);\n\t};\n};\n\n#define RPM_SERVICE_TYPE_REQUEST\t0x00716572  \n\n#define RPM_MSG_TYPE_ERR\t\t0x00727265  \n#define RPM_MSG_TYPE_MSG_ID\t\t0x2367736d  \n\n \nint qcom_rpm_smd_write(struct qcom_smd_rpm *rpm,\n\t\t       int state,\n\t\t       u32 type, u32 id,\n\t\t       void *buf,\n\t\t       size_t count)\n{\n\tstatic unsigned msg_id = 1;\n\tint left;\n\tint ret;\n\tstruct {\n\t\tstruct qcom_rpm_header hdr;\n\t\tstruct qcom_rpm_request req;\n\t\tu8 payload[];\n\t} *pkt;\n\tsize_t size = sizeof(*pkt) + count;\n\n\t \n\tif (WARN_ON(size >= 256))\n\t\treturn -EINVAL;\n\n\tpkt = kmalloc(size, GFP_ATOMIC);\n\tif (!pkt)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&rpm->lock);\n\n\tpkt->hdr.service_type = cpu_to_le32(RPM_SERVICE_TYPE_REQUEST);\n\tpkt->hdr.length = cpu_to_le32(sizeof(struct qcom_rpm_request) + count);\n\n\tpkt->req.msg_id = cpu_to_le32(msg_id++);\n\tpkt->req.flags = cpu_to_le32(state);\n\tpkt->req.type = cpu_to_le32(type);\n\tpkt->req.id = cpu_to_le32(id);\n\tpkt->req.data_len = cpu_to_le32(count);\n\tmemcpy(pkt->payload, buf, count);\n\n\tret = rpmsg_send(rpm->rpm_channel, pkt, size);\n\tif (ret)\n\t\tgoto out;\n\n\tleft = wait_for_completion_timeout(&rpm->ack, RPM_REQUEST_TIMEOUT);\n\tif (!left)\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = rpm->ack_status;\n\nout:\n\tkfree(pkt);\n\tmutex_unlock(&rpm->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(qcom_rpm_smd_write);\n\nstatic int qcom_smd_rpm_callback(struct rpmsg_device *rpdev,\n\t\t\t\t void *data,\n\t\t\t\t int count,\n\t\t\t\t void *priv,\n\t\t\t\t u32 addr)\n{\n\tconst struct qcom_rpm_header *hdr = data;\n\tsize_t hdr_length = le32_to_cpu(hdr->length);\n\tconst struct qcom_rpm_message *msg;\n\tstruct qcom_smd_rpm *rpm = dev_get_drvdata(&rpdev->dev);\n\tconst u8 *buf = data + sizeof(struct qcom_rpm_header);\n\tconst u8 *end = buf + hdr_length;\n\tchar msgbuf[32];\n\tint status = 0;\n\tu32 len, msg_length;\n\n\tif (le32_to_cpu(hdr->service_type) != RPM_SERVICE_TYPE_REQUEST ||\n\t    hdr_length < sizeof(struct qcom_rpm_message)) {\n\t\tdev_err(rpm->dev, \"invalid request\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (buf < end) {\n\t\tmsg = (struct qcom_rpm_message *)buf;\n\t\tmsg_length = le32_to_cpu(msg->length);\n\t\tswitch (le32_to_cpu(msg->msg_type)) {\n\t\tcase RPM_MSG_TYPE_MSG_ID:\n\t\t\tbreak;\n\t\tcase RPM_MSG_TYPE_ERR:\n\t\t\tlen = min_t(u32, ALIGN(msg_length, 4), sizeof(msgbuf));\n\t\t\tmemcpy_fromio(msgbuf, msg->message, len);\n\t\t\tmsgbuf[len - 1] = 0;\n\n\t\t\tif (!strcmp(msgbuf, \"resource does not exist\"))\n\t\t\t\tstatus = -ENXIO;\n\t\t\telse\n\t\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = PTR_ALIGN(buf + 2 * sizeof(u32) + msg_length, 4);\n\t}\n\n\trpm->ack_status = status;\n\tcomplete(&rpm->ack);\n\treturn 0;\n}\n\nstatic int qcom_smd_rpm_probe(struct rpmsg_device *rpdev)\n{\n\tstruct qcom_smd_rpm *rpm;\n\n\tif (!rpdev->dev.of_node)\n\t\treturn -EINVAL;\n\n\trpm = devm_kzalloc(&rpdev->dev, sizeof(*rpm), GFP_KERNEL);\n\tif (!rpm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&rpm->lock);\n\tinit_completion(&rpm->ack);\n\n\trpm->dev = &rpdev->dev;\n\trpm->rpm_channel = rpdev->ept;\n\tdev_set_drvdata(&rpdev->dev, rpm);\n\n\treturn of_platform_populate(rpdev->dev.of_node, NULL, NULL, &rpdev->dev);\n}\n\nstatic void qcom_smd_rpm_remove(struct rpmsg_device *rpdev)\n{\n\tof_platform_depopulate(&rpdev->dev);\n}\n\nstatic const struct rpmsg_device_id qcom_smd_rpm_id_table[] = {\n\t{ .name = \"rpm_requests\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(rpmsg, qcom_smd_rpm_id_table);\n\nstatic struct rpmsg_driver qcom_smd_rpm_driver = {\n\t.probe = qcom_smd_rpm_probe,\n\t.remove = qcom_smd_rpm_remove,\n\t.callback = qcom_smd_rpm_callback,\n\t.id_table = qcom_smd_rpm_id_table,\n\t.drv.name = \"qcom_smd_rpm\",\n};\n\nstatic int __init qcom_smd_rpm_init(void)\n{\n\treturn register_rpmsg_driver(&qcom_smd_rpm_driver);\n}\narch_initcall(qcom_smd_rpm_init);\n\nstatic void __exit qcom_smd_rpm_exit(void)\n{\n\tunregister_rpmsg_driver(&qcom_smd_rpm_driver);\n}\nmodule_exit(qcom_smd_rpm_exit);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@sonymobile.com>\");\nMODULE_DESCRIPTION(\"Qualcomm SMD backed RPM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}