{
  "module_name": "pmic_glink.c",
  "hash_id": "5c798177b3d3dcb39374116be437fc00d714e852cbc4fc22e273de6b18ffa35f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/pmic_glink.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rpmsg.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/pdr.h>\n#include <linux/soc/qcom/pmic_glink.h>\n\nenum {\n\tPMIC_GLINK_CLIENT_BATT = 0,\n\tPMIC_GLINK_CLIENT_ALTMODE,\n\tPMIC_GLINK_CLIENT_UCSI,\n};\n\n#define PMIC_GLINK_CLIENT_DEFAULT\t(BIT(PMIC_GLINK_CLIENT_BATT) |\t\\\n\t\t\t\t\t BIT(PMIC_GLINK_CLIENT_ALTMODE))\n\nstruct pmic_glink {\n\tstruct device *dev;\n\tstruct pdr_handle *pdr;\n\n\tstruct rpmsg_endpoint *ept;\n\n\tunsigned long client_mask;\n\n\tstruct auxiliary_device altmode_aux;\n\tstruct auxiliary_device ps_aux;\n\tstruct auxiliary_device ucsi_aux;\n\n\t \n\tstruct mutex state_lock;\n\tunsigned int client_state;\n\tunsigned int pdr_state;\n\n\t \n\tstruct mutex client_lock;\n\tstruct list_head clients;\n};\n\nstatic struct pmic_glink *__pmic_glink;\nstatic DEFINE_MUTEX(__pmic_glink_lock);\n\nstruct pmic_glink_client {\n\tstruct list_head node;\n\n\tstruct pmic_glink *pg;\n\tunsigned int id;\n\n\tvoid (*cb)(const void *data, size_t len, void *priv);\n\tvoid (*pdr_notify)(void *priv, int state);\n\tvoid *priv;\n};\n\nstatic void _devm_pmic_glink_release_client(struct device *dev, void *res)\n{\n\tstruct pmic_glink_client *client = (struct pmic_glink_client *)res;\n\tstruct pmic_glink *pg = client->pg;\n\n\tmutex_lock(&pg->client_lock);\n\tlist_del(&client->node);\n\tmutex_unlock(&pg->client_lock);\n}\n\nstruct pmic_glink_client *devm_pmic_glink_register_client(struct device *dev,\n\t\t\t\t\t\t\t  unsigned int id,\n\t\t\t\t\t\t\t  void (*cb)(const void *, size_t, void *),\n\t\t\t\t\t\t\t  void (*pdr)(void *, int),\n\t\t\t\t\t\t\t  void *priv)\n{\n\tstruct pmic_glink_client *client;\n\tstruct pmic_glink *pg = dev_get_drvdata(dev->parent);\n\n\tclient = devres_alloc(_devm_pmic_glink_release_client, sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient->pg = pg;\n\tclient->id = id;\n\tclient->cb = cb;\n\tclient->pdr_notify = pdr;\n\tclient->priv = priv;\n\n\tmutex_lock(&pg->client_lock);\n\tlist_add(&client->node, &pg->clients);\n\tmutex_unlock(&pg->client_lock);\n\n\tdevres_add(dev, client);\n\n\treturn client;\n}\nEXPORT_SYMBOL_GPL(devm_pmic_glink_register_client);\n\nint pmic_glink_send(struct pmic_glink_client *client, void *data, size_t len)\n{\n\tstruct pmic_glink *pg = client->pg;\n\n\treturn rpmsg_send(pg->ept, data, len);\n}\nEXPORT_SYMBOL_GPL(pmic_glink_send);\n\nstatic int pmic_glink_rpmsg_callback(struct rpmsg_device *rpdev, void *data,\n\t\t\t\t     int len, void *priv, u32 addr)\n{\n\tstruct pmic_glink_client *client;\n\tstruct pmic_glink_hdr *hdr;\n\tstruct pmic_glink *pg = dev_get_drvdata(&rpdev->dev);\n\n\tif (len < sizeof(*hdr)) {\n\t\tdev_warn(pg->dev, \"ignoring truncated message\\n\");\n\t\treturn 0;\n\t}\n\n\thdr = data;\n\n\tlist_for_each_entry(client, &pg->clients, node) {\n\t\tif (client->id == le32_to_cpu(hdr->owner))\n\t\t\tclient->cb(data, len, client->priv);\n\t}\n\n\treturn 0;\n}\n\nstatic void pmic_glink_aux_release(struct device *dev) {}\n\nstatic int pmic_glink_add_aux_device(struct pmic_glink *pg,\n\t\t\t\t     struct auxiliary_device *aux,\n\t\t\t\t     const char *name)\n{\n\tstruct device *parent = pg->dev;\n\tint ret;\n\n\taux->name = name;\n\taux->dev.parent = parent;\n\taux->dev.release = pmic_glink_aux_release;\n\tdevice_set_of_node_from_dev(&aux->dev, parent);\n\tret = auxiliary_device_init(aux);\n\tif (ret)\n\t\treturn ret;\n\n\tret = auxiliary_device_add(aux);\n\tif (ret)\n\t\tauxiliary_device_uninit(aux);\n\n\treturn ret;\n}\n\nstatic void pmic_glink_del_aux_device(struct pmic_glink *pg,\n\t\t\t\t      struct auxiliary_device *aux)\n{\n\tauxiliary_device_delete(aux);\n\tauxiliary_device_uninit(aux);\n}\n\nstatic void pmic_glink_state_notify_clients(struct pmic_glink *pg)\n{\n\tstruct pmic_glink_client *client;\n\tunsigned int new_state = pg->client_state;\n\n\tif (pg->client_state != SERVREG_SERVICE_STATE_UP) {\n\t\tif (pg->pdr_state == SERVREG_SERVICE_STATE_UP && pg->ept)\n\t\t\tnew_state = SERVREG_SERVICE_STATE_UP;\n\t} else {\n\t\tif (pg->pdr_state == SERVREG_SERVICE_STATE_UP && pg->ept)\n\t\t\tnew_state = SERVREG_SERVICE_STATE_DOWN;\n\t}\n\n\tif (new_state != pg->client_state) {\n\t\tlist_for_each_entry(client, &pg->clients, node)\n\t\t\tclient->pdr_notify(client->priv, new_state);\n\t\tpg->client_state = new_state;\n\t}\n}\n\nstatic void pmic_glink_pdr_callback(int state, char *svc_path, void *priv)\n{\n\tstruct pmic_glink *pg = priv;\n\n\tmutex_lock(&pg->state_lock);\n\tpg->pdr_state = state;\n\n\tpmic_glink_state_notify_clients(pg);\n\tmutex_unlock(&pg->state_lock);\n}\n\nstatic int pmic_glink_rpmsg_probe(struct rpmsg_device *rpdev)\n{\n\tstruct pmic_glink *pg = __pmic_glink;\n\tint ret = 0;\n\n\tmutex_lock(&__pmic_glink_lock);\n\tif (!pg) {\n\t\tret = dev_err_probe(&rpdev->dev, -ENODEV, \"no pmic_glink device to attach to\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tdev_set_drvdata(&rpdev->dev, pg);\n\n\tmutex_lock(&pg->state_lock);\n\tpg->ept = rpdev->ept;\n\tpmic_glink_state_notify_clients(pg);\n\tmutex_unlock(&pg->state_lock);\n\nout_unlock:\n\tmutex_unlock(&__pmic_glink_lock);\n\treturn ret;\n}\n\nstatic void pmic_glink_rpmsg_remove(struct rpmsg_device *rpdev)\n{\n\tstruct pmic_glink *pg;\n\n\tmutex_lock(&__pmic_glink_lock);\n\tpg = __pmic_glink;\n\tif (!pg)\n\t\tgoto out_unlock;\n\n\tmutex_lock(&pg->state_lock);\n\tpg->ept = NULL;\n\tpmic_glink_state_notify_clients(pg);\n\tmutex_unlock(&pg->state_lock);\nout_unlock:\n\tmutex_unlock(&__pmic_glink_lock);\n}\n\nstatic const struct rpmsg_device_id pmic_glink_rpmsg_id_match[] = {\n\t{ \"PMIC_RTR_ADSP_APPS\" },\n\t{}\n};\n\nstatic struct rpmsg_driver pmic_glink_rpmsg_driver = {\n\t.probe = pmic_glink_rpmsg_probe,\n\t.remove = pmic_glink_rpmsg_remove,\n\t.callback = pmic_glink_rpmsg_callback,\n\t.id_table = pmic_glink_rpmsg_id_match,\n\t.drv  = {\n\t\t.name  = \"qcom_pmic_glink_rpmsg\",\n\t},\n};\n\nstatic int pmic_glink_probe(struct platform_device *pdev)\n{\n\tconst unsigned long *match_data;\n\tstruct pdr_service *service;\n\tstruct pmic_glink *pg;\n\tint ret;\n\n\tpg = devm_kzalloc(&pdev->dev, sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, pg);\n\n\tpg->dev = &pdev->dev;\n\n\tINIT_LIST_HEAD(&pg->clients);\n\tmutex_init(&pg->client_lock);\n\tmutex_init(&pg->state_lock);\n\n\tmatch_data = (unsigned long *)of_device_get_match_data(&pdev->dev);\n\tif (match_data)\n\t\tpg->client_mask = *match_data;\n\telse\n\t\tpg->client_mask = PMIC_GLINK_CLIENT_DEFAULT;\n\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_UCSI)) {\n\t\tret = pmic_glink_add_aux_device(pg, &pg->ucsi_aux, \"ucsi\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_ALTMODE)) {\n\t\tret = pmic_glink_add_aux_device(pg, &pg->altmode_aux, \"altmode\");\n\t\tif (ret)\n\t\t\tgoto out_release_ucsi_aux;\n\t}\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_BATT)) {\n\t\tret = pmic_glink_add_aux_device(pg, &pg->ps_aux, \"power-supply\");\n\t\tif (ret)\n\t\t\tgoto out_release_altmode_aux;\n\t}\n\n\tpg->pdr = pdr_handle_alloc(pmic_glink_pdr_callback, pg);\n\tif (IS_ERR(pg->pdr)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(pg->pdr), \"failed to initialize pdr\\n\");\n\t\tgoto out_release_aux_devices;\n\t}\n\n\tservice = pdr_add_lookup(pg->pdr, \"tms/servreg\", \"msm/adsp/charger_pd\");\n\tif (IS_ERR(service)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(service),\n\t\t\t\t    \"failed adding pdr lookup for charger_pd\\n\");\n\t\tgoto out_release_pdr_handle;\n\t}\n\n\tmutex_lock(&__pmic_glink_lock);\n\t__pmic_glink = pg;\n\tmutex_unlock(&__pmic_glink_lock);\n\n\treturn 0;\n\nout_release_pdr_handle:\n\tpdr_handle_release(pg->pdr);\nout_release_aux_devices:\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_BATT))\n\t\tpmic_glink_del_aux_device(pg, &pg->ps_aux);\nout_release_altmode_aux:\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_ALTMODE))\n\t\tpmic_glink_del_aux_device(pg, &pg->altmode_aux);\nout_release_ucsi_aux:\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_UCSI))\n\t\tpmic_glink_del_aux_device(pg, &pg->ucsi_aux);\n\n\treturn ret;\n}\n\nstatic int pmic_glink_remove(struct platform_device *pdev)\n{\n\tstruct pmic_glink *pg = dev_get_drvdata(&pdev->dev);\n\n\tpdr_handle_release(pg->pdr);\n\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_BATT))\n\t\tpmic_glink_del_aux_device(pg, &pg->ps_aux);\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_ALTMODE))\n\t\tpmic_glink_del_aux_device(pg, &pg->altmode_aux);\n\tif (pg->client_mask & BIT(PMIC_GLINK_CLIENT_UCSI))\n\t\tpmic_glink_del_aux_device(pg, &pg->ucsi_aux);\n\n\tmutex_lock(&__pmic_glink_lock);\n\t__pmic_glink = NULL;\n\tmutex_unlock(&__pmic_glink_lock);\n\n\treturn 0;\n}\n\nstatic const unsigned long pmic_glink_sm8450_client_mask = BIT(PMIC_GLINK_CLIENT_BATT) |\n\t\t\t\t\t\t\t   BIT(PMIC_GLINK_CLIENT_ALTMODE) |\n\t\t\t\t\t\t\t   BIT(PMIC_GLINK_CLIENT_UCSI);\n\nstatic const struct of_device_id pmic_glink_of_match[] = {\n\t{ .compatible = \"qcom,sm8450-pmic-glink\", .data = &pmic_glink_sm8450_client_mask },\n\t{ .compatible = \"qcom,sm8550-pmic-glink\", .data = &pmic_glink_sm8450_client_mask },\n\t{ .compatible = \"qcom,pmic-glink\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pmic_glink_of_match);\n\nstatic struct platform_driver pmic_glink_driver = {\n\t.probe = pmic_glink_probe,\n\t.remove = pmic_glink_remove,\n\t.driver = {\n\t\t.name = \"qcom_pmic_glink\",\n\t\t.of_match_table = pmic_glink_of_match,\n\t},\n};\n\nstatic int pmic_glink_init(void)\n{\n\tplatform_driver_register(&pmic_glink_driver);\n\tregister_rpmsg_driver(&pmic_glink_rpmsg_driver);\n\n\treturn 0;\n};\nmodule_init(pmic_glink_init);\n\nstatic void pmic_glink_exit(void)\n{\n\tunregister_rpmsg_driver(&pmic_glink_rpmsg_driver);\n\tplatform_driver_unregister(&pmic_glink_driver);\n};\nmodule_exit(pmic_glink_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC GLINK driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}