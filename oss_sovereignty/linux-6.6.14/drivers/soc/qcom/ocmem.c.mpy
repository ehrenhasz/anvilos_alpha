{
  "module_name": "ocmem.c",
  "hash_id": "0a38aace8bb1cff127e70872239b69251bfd2a194c4c72d7fc247a835d74af8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/ocmem.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <soc/qcom/ocmem.h>\n\nenum region_mode {\n\tWIDE_MODE = 0x0,\n\tTHIN_MODE,\n\tMODE_DEFAULT = WIDE_MODE,\n};\n\nenum ocmem_macro_state {\n\tPASSTHROUGH = 0,\n\tPERI_ON = 1,\n\tCORE_ON = 2,\n\tCLK_OFF = 4,\n};\n\nstruct ocmem_region {\n\tbool interleaved;\n\tenum region_mode mode;\n\tunsigned int num_macros;\n\tenum ocmem_macro_state macro_state[4];\n\tunsigned long macro_size;\n\tunsigned long region_size;\n};\n\nstruct ocmem_config {\n\tuint8_t num_regions;\n\tunsigned long macro_size;\n};\n\nstruct ocmem {\n\tstruct device *dev;\n\tconst struct ocmem_config *config;\n\tstruct resource *memory;\n\tvoid __iomem *mmio;\n\tstruct clk *core_clk;\n\tstruct clk *iface_clk;\n\tunsigned int num_ports;\n\tunsigned int num_macros;\n\tbool interleaved;\n\tstruct ocmem_region *regions;\n\tunsigned long active_allocations;\n};\n\n#define OCMEM_MIN_ALIGN\t\t\t\tSZ_64K\n#define OCMEM_MIN_ALLOC\t\t\t\tSZ_64K\n\n#define OCMEM_REG_HW_VERSION\t\t\t0x00000000\n#define OCMEM_REG_HW_PROFILE\t\t\t0x00000004\n\n#define OCMEM_REG_REGION_MODE_CTL\t\t0x00001000\n#define OCMEM_REGION_MODE_CTL_REG0_THIN\t\t0x00000001\n#define OCMEM_REGION_MODE_CTL_REG1_THIN\t\t0x00000002\n#define OCMEM_REGION_MODE_CTL_REG2_THIN\t\t0x00000004\n#define OCMEM_REGION_MODE_CTL_REG3_THIN\t\t0x00000008\n\n#define OCMEM_REG_GFX_MPU_START\t\t\t0x00001004\n#define OCMEM_REG_GFX_MPU_END\t\t\t0x00001008\n\n#define OCMEM_HW_VERSION_MAJOR(val)\t\tFIELD_GET(GENMASK(31, 28), val)\n#define OCMEM_HW_VERSION_MINOR(val)\t\tFIELD_GET(GENMASK(27, 16), val)\n#define OCMEM_HW_VERSION_STEP(val)\t\tFIELD_GET(GENMASK(15, 0), val)\n\n#define OCMEM_HW_PROFILE_NUM_PORTS(val)\t\tFIELD_GET(0x0000000f, (val))\n#define OCMEM_HW_PROFILE_NUM_MACROS(val)\tFIELD_GET(0x00003f00, (val))\n\n#define OCMEM_HW_PROFILE_LAST_REGN_HALFSIZE\t0x00010000\n#define OCMEM_HW_PROFILE_INTERLEAVING\t\t0x00020000\n#define OCMEM_REG_GEN_STATUS\t\t\t0x0000000c\n\n#define OCMEM_REG_PSGSC_STATUS\t\t\t0x00000038\n#define OCMEM_REG_PSGSC_CTL(i0)\t\t\t(0x0000003c + 0x1*(i0))\n\n#define OCMEM_PSGSC_CTL_MACRO0_MODE(val)\tFIELD_PREP(0x00000007, (val))\n#define OCMEM_PSGSC_CTL_MACRO1_MODE(val)\tFIELD_PREP(0x00000070, (val))\n#define OCMEM_PSGSC_CTL_MACRO2_MODE(val)\tFIELD_PREP(0x00000700, (val))\n#define OCMEM_PSGSC_CTL_MACRO3_MODE(val)\tFIELD_PREP(0x00007000, (val))\n\nstatic inline void ocmem_write(struct ocmem *ocmem, u32 reg, u32 data)\n{\n\twritel(data, ocmem->mmio + reg);\n}\n\nstatic inline u32 ocmem_read(struct ocmem *ocmem, u32 reg)\n{\n\treturn readl(ocmem->mmio + reg);\n}\n\nstatic void update_ocmem(struct ocmem *ocmem)\n{\n\tuint32_t region_mode_ctrl = 0x0;\n\tint i;\n\n\tif (!qcom_scm_ocmem_lock_available()) {\n\t\tfor (i = 0; i < ocmem->config->num_regions; i++) {\n\t\t\tstruct ocmem_region *region = &ocmem->regions[i];\n\n\t\t\tif (region->mode == THIN_MODE)\n\t\t\t\tregion_mode_ctrl |= BIT(i);\n\t\t}\n\n\t\tdev_dbg(ocmem->dev, \"ocmem_region_mode_control %x\\n\",\n\t\t\tregion_mode_ctrl);\n\t\tocmem_write(ocmem, OCMEM_REG_REGION_MODE_CTL, region_mode_ctrl);\n\t}\n\n\tfor (i = 0; i < ocmem->config->num_regions; i++) {\n\t\tstruct ocmem_region *region = &ocmem->regions[i];\n\t\tu32 data;\n\n\t\tdata = OCMEM_PSGSC_CTL_MACRO0_MODE(region->macro_state[0]) |\n\t\t\tOCMEM_PSGSC_CTL_MACRO1_MODE(region->macro_state[1]) |\n\t\t\tOCMEM_PSGSC_CTL_MACRO2_MODE(region->macro_state[2]) |\n\t\t\tOCMEM_PSGSC_CTL_MACRO3_MODE(region->macro_state[3]);\n\n\t\tocmem_write(ocmem, OCMEM_REG_PSGSC_CTL(i), data);\n\t}\n}\n\nstatic unsigned long phys_to_offset(struct ocmem *ocmem,\n\t\t\t\t    unsigned long addr)\n{\n\tif (addr < ocmem->memory->start || addr >= ocmem->memory->end)\n\t\treturn 0;\n\n\treturn addr - ocmem->memory->start;\n}\n\nstatic unsigned long device_address(struct ocmem *ocmem,\n\t\t\t\t    enum ocmem_client client,\n\t\t\t\t    unsigned long addr)\n{\n\tWARN_ON(client != OCMEM_GRAPHICS);\n\n\t \n\treturn phys_to_offset(ocmem, addr);\n}\n\nstatic void update_range(struct ocmem *ocmem, struct ocmem_buf *buf,\n\t\t\t enum ocmem_macro_state mstate, enum region_mode rmode)\n{\n\tunsigned long offset = 0;\n\tint i, j;\n\n\tfor (i = 0; i < ocmem->config->num_regions; i++) {\n\t\tstruct ocmem_region *region = &ocmem->regions[i];\n\n\t\tif (buf->offset <= offset && offset < buf->offset + buf->len)\n\t\t\tregion->mode = rmode;\n\n\t\tfor (j = 0; j < region->num_macros; j++) {\n\t\t\tif (buf->offset <= offset &&\n\t\t\t    offset < buf->offset + buf->len)\n\t\t\t\tregion->macro_state[j] = mstate;\n\n\t\t\toffset += region->macro_size;\n\t\t}\n\t}\n\n\tupdate_ocmem(ocmem);\n}\n\nstruct ocmem *of_get_ocmem(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *devnode;\n\tstruct ocmem *ocmem;\n\n\tdevnode = of_parse_phandle(dev->of_node, \"sram\", 0);\n\tif (!devnode || !devnode->parent) {\n\t\tdev_err(dev, \"Cannot look up sram phandle\\n\");\n\t\tof_node_put(devnode);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpdev = of_find_device_by_node(devnode->parent);\n\tif (!pdev) {\n\t\tdev_err(dev, \"Cannot find device node %s\\n\", devnode->name);\n\t\tof_node_put(devnode);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\tof_node_put(devnode);\n\n\tocmem = platform_get_drvdata(pdev);\n\tif (!ocmem) {\n\t\tdev_err(dev, \"Cannot get ocmem\\n\");\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\treturn ocmem;\n}\nEXPORT_SYMBOL(of_get_ocmem);\n\nstruct ocmem_buf *ocmem_allocate(struct ocmem *ocmem, enum ocmem_client client,\n\t\t\t\t unsigned long size)\n{\n\tstruct ocmem_buf *buf;\n\tint ret;\n\n\t \n\tif (WARN_ON(client != OCMEM_GRAPHICS))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (size < OCMEM_MIN_ALLOC || !IS_ALIGNED(size, OCMEM_MIN_ALIGN))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (test_and_set_bit_lock(BIT(client), &ocmem->active_allocations))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf->offset = 0;\n\tbuf->addr = device_address(ocmem, client, buf->offset);\n\tbuf->len = size;\n\n\tupdate_range(ocmem, buf, CORE_ON, WIDE_MODE);\n\n\tif (qcom_scm_ocmem_lock_available()) {\n\t\tret = qcom_scm_ocmem_lock(QCOM_SCM_OCMEM_GRAPHICS_ID,\n\t\t\t\t\t  buf->offset, buf->len, WIDE_MODE);\n\t\tif (ret) {\n\t\t\tdev_err(ocmem->dev, \"could not lock: %d\\n\", ret);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_kfree;\n\t\t}\n\t} else {\n\t\tocmem_write(ocmem, OCMEM_REG_GFX_MPU_START, buf->offset);\n\t\tocmem_write(ocmem, OCMEM_REG_GFX_MPU_END,\n\t\t\t    buf->offset + buf->len);\n\t}\n\n\tdev_dbg(ocmem->dev, \"using %ldK of OCMEM at 0x%08lx for client %d\\n\",\n\t\tsize / 1024, buf->addr, client);\n\n\treturn buf;\n\nerr_kfree:\n\tkfree(buf);\nerr_unlock:\n\tclear_bit_unlock(BIT(client), &ocmem->active_allocations);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(ocmem_allocate);\n\nvoid ocmem_free(struct ocmem *ocmem, enum ocmem_client client,\n\t\tstruct ocmem_buf *buf)\n{\n\t \n\tif (WARN_ON(client != OCMEM_GRAPHICS))\n\t\treturn;\n\n\tupdate_range(ocmem, buf, CLK_OFF, MODE_DEFAULT);\n\n\tif (qcom_scm_ocmem_lock_available()) {\n\t\tint ret;\n\n\t\tret = qcom_scm_ocmem_unlock(QCOM_SCM_OCMEM_GRAPHICS_ID,\n\t\t\t\t\t    buf->offset, buf->len);\n\t\tif (ret)\n\t\t\tdev_err(ocmem->dev, \"could not unlock: %d\\n\", ret);\n\t} else {\n\t\tocmem_write(ocmem, OCMEM_REG_GFX_MPU_START, 0x0);\n\t\tocmem_write(ocmem, OCMEM_REG_GFX_MPU_END, 0x0);\n\t}\n\n\tkfree(buf);\n\n\tclear_bit_unlock(BIT(client), &ocmem->active_allocations);\n}\nEXPORT_SYMBOL(ocmem_free);\n\nstatic int ocmem_dev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tunsigned long reg, region_size;\n\tint i, j, ret, num_banks;\n\tstruct ocmem *ocmem;\n\n\tif (!qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tocmem = devm_kzalloc(dev, sizeof(*ocmem), GFP_KERNEL);\n\tif (!ocmem)\n\t\treturn -ENOMEM;\n\n\tocmem->dev = dev;\n\tocmem->config = device_get_match_data(dev);\n\n\tocmem->core_clk = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(ocmem->core_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ocmem->core_clk),\n\t\t\t\t     \"Unable to get core clock\\n\");\n\n\tocmem->iface_clk = devm_clk_get_optional(dev, \"iface\");\n\tif (IS_ERR(ocmem->iface_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ocmem->iface_clk),\n\t\t\t\t     \"Unable to get iface clock\\n\");\n\n\tocmem->mmio = devm_platform_ioremap_resource_byname(pdev, \"ctrl\");\n\tif (IS_ERR(ocmem->mmio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ocmem->mmio),\n\t\t\t\t     \"Failed to ioremap ocmem_ctrl resource\\n\");\n\n\tocmem->memory = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t     \"mem\");\n\tif (!ocmem->memory) {\n\t\tdev_err(dev, \"Could not get mem region\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tWARN_ON(clk_set_rate(ocmem->core_clk, 1000) < 0);\n\n\tret = clk_prepare_enable(ocmem->core_clk);\n\tif (ret)\n\t\treturn dev_err_probe(ocmem->dev, ret, \"Failed to enable core clock\\n\");\n\n\tret = clk_prepare_enable(ocmem->iface_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(ocmem->core_clk);\n\t\treturn dev_err_probe(ocmem->dev, ret, \"Failed to enable iface clock\\n\");\n\t}\n\n\tif (qcom_scm_restore_sec_cfg_available()) {\n\t\tdev_dbg(dev, \"configuring scm\\n\");\n\t\tret = qcom_scm_restore_sec_cfg(QCOM_SCM_OCMEM_DEV_ID, 0);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"Could not enable secure configuration\\n\");\n\t\t\tgoto err_clk_disable;\n\t\t}\n\t}\n\n\treg = ocmem_read(ocmem, OCMEM_REG_HW_VERSION);\n\tdev_dbg(dev, \"OCMEM hardware version: %lu.%lu.%lu\\n\",\n\t\tOCMEM_HW_VERSION_MAJOR(reg),\n\t\tOCMEM_HW_VERSION_MINOR(reg),\n\t\tOCMEM_HW_VERSION_STEP(reg));\n\n\treg = ocmem_read(ocmem, OCMEM_REG_HW_PROFILE);\n\tocmem->num_ports = OCMEM_HW_PROFILE_NUM_PORTS(reg);\n\tocmem->num_macros = OCMEM_HW_PROFILE_NUM_MACROS(reg);\n\tocmem->interleaved = !!(reg & OCMEM_HW_PROFILE_INTERLEAVING);\n\n\tnum_banks = ocmem->num_ports / 2;\n\tregion_size = ocmem->config->macro_size * num_banks;\n\n\tdev_info(dev, \"%u ports, %u regions, %u macros, %sinterleaved\\n\",\n\t\t ocmem->num_ports, ocmem->config->num_regions,\n\t\t ocmem->num_macros, ocmem->interleaved ? \"\" : \"not \");\n\n\tocmem->regions = devm_kcalloc(dev, ocmem->config->num_regions,\n\t\t\t\t      sizeof(struct ocmem_region), GFP_KERNEL);\n\tif (!ocmem->regions) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable;\n\t}\n\n\tfor (i = 0; i < ocmem->config->num_regions; i++) {\n\t\tstruct ocmem_region *region = &ocmem->regions[i];\n\n\t\tif (WARN_ON(num_banks > ARRAY_SIZE(region->macro_state))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_clk_disable;\n\t\t}\n\n\t\tregion->mode = MODE_DEFAULT;\n\t\tregion->num_macros = num_banks;\n\n\t\tif (i == (ocmem->config->num_regions - 1) &&\n\t\t    reg & OCMEM_HW_PROFILE_LAST_REGN_HALFSIZE) {\n\t\t\tregion->macro_size = ocmem->config->macro_size / 2;\n\t\t\tregion->region_size = region_size / 2;\n\t\t} else {\n\t\t\tregion->macro_size = ocmem->config->macro_size;\n\t\t\tregion->region_size = region_size;\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(region->macro_state); j++)\n\t\t\tregion->macro_state[j] = CLK_OFF;\n\t}\n\n\tplatform_set_drvdata(pdev, ocmem);\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(ocmem->core_clk);\n\tclk_disable_unprepare(ocmem->iface_clk);\n\treturn ret;\n}\n\nstatic int ocmem_dev_remove(struct platform_device *pdev)\n{\n\tstruct ocmem *ocmem = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(ocmem->core_clk);\n\tclk_disable_unprepare(ocmem->iface_clk);\n\n\treturn 0;\n}\n\nstatic const struct ocmem_config ocmem_8226_config = {\n\t.num_regions = 1,\n\t.macro_size = SZ_128K,\n};\n\nstatic const struct ocmem_config ocmem_8974_config = {\n\t.num_regions = 3,\n\t.macro_size = SZ_128K,\n};\n\nstatic const struct of_device_id ocmem_of_match[] = {\n\t{ .compatible = \"qcom,msm8226-ocmem\", .data = &ocmem_8226_config },\n\t{ .compatible = \"qcom,msm8974-ocmem\", .data = &ocmem_8974_config },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, ocmem_of_match);\n\nstatic struct platform_driver ocmem_driver = {\n\t.probe = ocmem_dev_probe,\n\t.remove = ocmem_dev_remove,\n\t.driver = {\n\t\t.name = \"ocmem\",\n\t\t.of_match_table = ocmem_of_match,\n\t},\n};\n\nmodule_platform_driver(ocmem_driver);\n\nMODULE_DESCRIPTION(\"On Chip Memory (OCMEM) allocator for some Snapdragon SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}