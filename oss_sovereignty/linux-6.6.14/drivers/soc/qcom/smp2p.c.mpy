{
  "module_name": "smp2p.c",
  "hash_id": "2093e37e252859ab4d2b2e4267505eec713d2e245ae82541431f6384447fd16f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/smp2p.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n#include <linux/spinlock.h>\n\n \n\n#define SMP2P_MAX_ENTRY 16\n#define SMP2P_MAX_ENTRY_NAME 16\n\n#define SMP2P_FEATURE_SSR_ACK 0x1\n#define SMP2P_FLAGS_RESTART_DONE_BIT 0\n#define SMP2P_FLAGS_RESTART_ACK_BIT 1\n\n#define SMP2P_MAGIC 0x504d5324\n#define SMP2P_ALL_FEATURES\tSMP2P_FEATURE_SSR_ACK\n\n \nstruct smp2p_smem_item {\n\tu32 magic;\n\tu8 version;\n\tunsigned features:24;\n\tu16 local_pid;\n\tu16 remote_pid;\n\tu16 total_entries;\n\tu16 valid_entries;\n\tu32 flags;\n\n\tstruct {\n\t\tu8 name[SMP2P_MAX_ENTRY_NAME];\n\t\tu32 value;\n\t} entries[SMP2P_MAX_ENTRY];\n} __packed;\n\n \nstruct smp2p_entry {\n\tstruct list_head node;\n\tstruct qcom_smp2p *smp2p;\n\n\tconst char *name;\n\tu32 *value;\n\tu32 last_value;\n\n\tstruct irq_domain *domain;\n\tDECLARE_BITMAP(irq_enabled, 32);\n\tDECLARE_BITMAP(irq_rising, 32);\n\tDECLARE_BITMAP(irq_falling, 32);\n\n\tstruct qcom_smem_state *state;\n\n\tspinlock_t lock;\n};\n\n#define SMP2P_INBOUND\t0\n#define SMP2P_OUTBOUND\t1\n\n \nstruct qcom_smp2p {\n\tstruct device *dev;\n\n\tstruct smp2p_smem_item *in;\n\tstruct smp2p_smem_item *out;\n\n\tunsigned smem_items[SMP2P_OUTBOUND + 1];\n\n\tunsigned valid_entries;\n\n\tbool ssr_ack_enabled;\n\tbool ssr_ack;\n\tbool negotiation_done;\n\n\tunsigned local_pid;\n\tunsigned remote_pid;\n\n\tstruct regmap *ipc_regmap;\n\tint ipc_offset;\n\tint ipc_bit;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tstruct list_head inbound;\n\tstruct list_head outbound;\n};\n\nstatic void qcom_smp2p_kick(struct qcom_smp2p *smp2p)\n{\n\t \n\twmb();\n\n\tif (smp2p->mbox_chan) {\n\t\tmbox_send_message(smp2p->mbox_chan, NULL);\n\t\tmbox_client_txdone(smp2p->mbox_chan, 0);\n\t} else {\n\t\tregmap_write(smp2p->ipc_regmap, smp2p->ipc_offset, BIT(smp2p->ipc_bit));\n\t}\n}\n\nstatic bool qcom_smp2p_check_ssr(struct qcom_smp2p *smp2p)\n{\n\tstruct smp2p_smem_item *in = smp2p->in;\n\tbool restart;\n\n\tif (!smp2p->ssr_ack_enabled)\n\t\treturn false;\n\n\trestart = in->flags & BIT(SMP2P_FLAGS_RESTART_DONE_BIT);\n\n\treturn restart != smp2p->ssr_ack;\n}\n\nstatic void qcom_smp2p_do_ssr_ack(struct qcom_smp2p *smp2p)\n{\n\tstruct smp2p_smem_item *out = smp2p->out;\n\tu32 val;\n\n\tsmp2p->ssr_ack = !smp2p->ssr_ack;\n\n\tval = out->flags & ~BIT(SMP2P_FLAGS_RESTART_ACK_BIT);\n\tif (smp2p->ssr_ack)\n\t\tval |= BIT(SMP2P_FLAGS_RESTART_ACK_BIT);\n\tout->flags = val;\n\n\tqcom_smp2p_kick(smp2p);\n}\n\nstatic void qcom_smp2p_negotiate(struct qcom_smp2p *smp2p)\n{\n\tstruct smp2p_smem_item *out = smp2p->out;\n\tstruct smp2p_smem_item *in = smp2p->in;\n\n\tif (in->version == out->version) {\n\t\tout->features &= in->features;\n\n\t\tif (out->features & SMP2P_FEATURE_SSR_ACK)\n\t\t\tsmp2p->ssr_ack_enabled = true;\n\n\t\tsmp2p->negotiation_done = true;\n\t}\n}\n\nstatic void qcom_smp2p_notify_in(struct qcom_smp2p *smp2p)\n{\n\tstruct smp2p_smem_item *in;\n\tstruct smp2p_entry *entry;\n\tint irq_pin;\n\tu32 status;\n\tchar buf[SMP2P_MAX_ENTRY_NAME];\n\tu32 val;\n\tint i;\n\n\tin = smp2p->in;\n\n\t \n\tfor (i = smp2p->valid_entries; i < in->valid_entries; i++) {\n\t\tlist_for_each_entry(entry, &smp2p->inbound, node) {\n\t\t\tmemcpy(buf, in->entries[i].name, sizeof(buf));\n\t\t\tif (!strcmp(buf, entry->name)) {\n\t\t\t\tentry->value = &in->entries[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsmp2p->valid_entries = i;\n\n\t \n\tlist_for_each_entry(entry, &smp2p->inbound, node) {\n\t\t \n\t\tif (!entry->value)\n\t\t\tcontinue;\n\n\t\tval = readl(entry->value);\n\n\t\tstatus = val ^ entry->last_value;\n\t\tentry->last_value = val;\n\n\t\t \n\t\tif (!status)\n\t\t\tcontinue;\n\n\t\tfor_each_set_bit(i, entry->irq_enabled, 32) {\n\t\t\tif (!(status & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tif ((val & BIT(i) && test_bit(i, entry->irq_rising)) ||\n\t\t\t    (!(val & BIT(i)) && test_bit(i, entry->irq_falling))) {\n\t\t\t\tirq_pin = irq_find_mapping(entry->domain, i);\n\t\t\t\thandle_nested_irq(irq_pin);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t qcom_smp2p_intr(int irq, void *data)\n{\n\tstruct smp2p_smem_item *in;\n\tstruct qcom_smp2p *smp2p = data;\n\tunsigned int smem_id = smp2p->smem_items[SMP2P_INBOUND];\n\tunsigned int pid = smp2p->remote_pid;\n\tbool ack_restart;\n\tsize_t size;\n\n\tin = smp2p->in;\n\n\t \n\tif (!in) {\n\t\tin = qcom_smem_get(pid, smem_id, &size);\n\t\tif (IS_ERR(in)) {\n\t\t\tdev_err(smp2p->dev,\n\t\t\t\t\"Unable to acquire remote smp2p item\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsmp2p->in = in;\n\t}\n\n\tif (!smp2p->negotiation_done)\n\t\tqcom_smp2p_negotiate(smp2p);\n\n\tif (smp2p->negotiation_done) {\n\t\tack_restart = qcom_smp2p_check_ssr(smp2p);\n\t\tqcom_smp2p_notify_in(smp2p);\n\n\t\tif (ack_restart)\n\t\t\tqcom_smp2p_do_ssr_ack(smp2p);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void smp2p_mask_irq(struct irq_data *irqd)\n{\n\tstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\n\tclear_bit(irq, entry->irq_enabled);\n}\n\nstatic void smp2p_unmask_irq(struct irq_data *irqd)\n{\n\tstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\n\tset_bit(irq, entry->irq_enabled);\n}\n\nstatic int smp2p_set_irq_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\n\tirq_hw_number_t irq = irqd_to_hwirq(irqd);\n\n\tif (!(type & IRQ_TYPE_EDGE_BOTH))\n\t\treturn -EINVAL;\n\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tset_bit(irq, entry->irq_rising);\n\telse\n\t\tclear_bit(irq, entry->irq_rising);\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tset_bit(irq, entry->irq_falling);\n\telse\n\t\tclear_bit(irq, entry->irq_falling);\n\n\treturn 0;\n}\n\nstatic struct irq_chip smp2p_irq_chip = {\n\t.name           = \"smp2p\",\n\t.irq_mask       = smp2p_mask_irq,\n\t.irq_unmask     = smp2p_unmask_irq,\n\t.irq_set_type\t= smp2p_set_irq_type,\n};\n\nstatic int smp2p_irq_map(struct irq_domain *d,\n\t\t\t unsigned int irq,\n\t\t\t irq_hw_number_t hw)\n{\n\tstruct smp2p_entry *entry = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &smp2p_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, entry);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops smp2p_irq_ops = {\n\t.map = smp2p_irq_map,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\nstatic int qcom_smp2p_inbound_entry(struct qcom_smp2p *smp2p,\n\t\t\t\t    struct smp2p_entry *entry,\n\t\t\t\t    struct device_node *node)\n{\n\tentry->domain = irq_domain_add_linear(node, 32, &smp2p_irq_ops, entry);\n\tif (!entry->domain) {\n\t\tdev_err(smp2p->dev, \"failed to add irq_domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int smp2p_update_bits(void *data, u32 mask, u32 value)\n{\n\tstruct smp2p_entry *entry = data;\n\tunsigned long flags;\n\tu32 orig;\n\tu32 val;\n\n\tspin_lock_irqsave(&entry->lock, flags);\n\tval = orig = readl(entry->value);\n\tval &= ~mask;\n\tval |= value;\n\twritel(val, entry->value);\n\tspin_unlock_irqrestore(&entry->lock, flags);\n\n\tif (val != orig)\n\t\tqcom_smp2p_kick(entry->smp2p);\n\n\treturn 0;\n}\n\nstatic const struct qcom_smem_state_ops smp2p_state_ops = {\n\t.update_bits = smp2p_update_bits,\n};\n\nstatic int qcom_smp2p_outbound_entry(struct qcom_smp2p *smp2p,\n\t\t\t\t     struct smp2p_entry *entry,\n\t\t\t\t     struct device_node *node)\n{\n\tstruct smp2p_smem_item *out = smp2p->out;\n\tchar buf[SMP2P_MAX_ENTRY_NAME] = {};\n\n\t \n\tstrscpy(buf, entry->name, SMP2P_MAX_ENTRY_NAME);\n\tmemcpy(out->entries[out->valid_entries].name, buf, SMP2P_MAX_ENTRY_NAME);\n\n\t \n\tentry->value = &out->entries[out->valid_entries].value;\n\n\tout->valid_entries++;\n\n\tentry->state = qcom_smem_state_register(node, &smp2p_state_ops, entry);\n\tif (IS_ERR(entry->state)) {\n\t\tdev_err(smp2p->dev, \"failed to register qcom_smem_state\\n\");\n\t\treturn PTR_ERR(entry->state);\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_smp2p_alloc_outbound_item(struct qcom_smp2p *smp2p)\n{\n\tstruct smp2p_smem_item *out;\n\tunsigned smem_id = smp2p->smem_items[SMP2P_OUTBOUND];\n\tunsigned pid = smp2p->remote_pid;\n\tint ret;\n\n\tret = qcom_smem_alloc(pid, smem_id, sizeof(*out));\n\tif (ret < 0 && ret != -EEXIST) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(smp2p->dev,\n\t\t\t\t\"unable to allocate local smp2p item\\n\");\n\t\treturn ret;\n\t}\n\n\tout = qcom_smem_get(pid, smem_id, NULL);\n\tif (IS_ERR(out)) {\n\t\tdev_err(smp2p->dev, \"Unable to acquire local smp2p item\\n\");\n\t\treturn PTR_ERR(out);\n\t}\n\n\tmemset(out, 0, sizeof(*out));\n\tout->magic = SMP2P_MAGIC;\n\tout->local_pid = smp2p->local_pid;\n\tout->remote_pid = smp2p->remote_pid;\n\tout->total_entries = SMP2P_MAX_ENTRY;\n\tout->valid_entries = 0;\n\tout->features = SMP2P_ALL_FEATURES;\n\n\t \n\twmb();\n\tout->version = 1;\n\n\tqcom_smp2p_kick(smp2p);\n\n\tsmp2p->out = out;\n\n\treturn 0;\n}\n\nstatic int smp2p_parse_ipc(struct qcom_smp2p *smp2p)\n{\n\tstruct device_node *syscon;\n\tstruct device *dev = smp2p->dev;\n\tconst char *key;\n\tint ret;\n\n\tsyscon = of_parse_phandle(dev->of_node, \"qcom,ipc\", 0);\n\tif (!syscon) {\n\t\tdev_err(dev, \"no qcom,ipc node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsmp2p->ipc_regmap = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(smp2p->ipc_regmap))\n\t\treturn PTR_ERR(smp2p->ipc_regmap);\n\n\tkey = \"qcom,ipc\";\n\tret = of_property_read_u32_index(dev->of_node, key, 1, &smp2p->ipc_offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"no offset in %s\\n\", key);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_index(dev->of_node, key, 2, &smp2p->ipc_bit);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"no bit in %s\\n\", key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_smp2p_probe(struct platform_device *pdev)\n{\n\tstruct smp2p_entry *entry;\n\tstruct device_node *node;\n\tstruct qcom_smp2p *smp2p;\n\tconst char *key;\n\tint irq;\n\tint ret;\n\n\tsmp2p = devm_kzalloc(&pdev->dev, sizeof(*smp2p), GFP_KERNEL);\n\tif (!smp2p)\n\t\treturn -ENOMEM;\n\n\tsmp2p->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&smp2p->inbound);\n\tINIT_LIST_HEAD(&smp2p->outbound);\n\n\tplatform_set_drvdata(pdev, smp2p);\n\n\tkey = \"qcom,smem\";\n\tret = of_property_read_u32_array(pdev->dev.of_node, key,\n\t\t\t\t\t smp2p->smem_items, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tkey = \"qcom,local-pid\";\n\tret = of_property_read_u32(pdev->dev.of_node, key, &smp2p->local_pid);\n\tif (ret)\n\t\tgoto report_read_failure;\n\n\tkey = \"qcom,remote-pid\";\n\tret = of_property_read_u32(pdev->dev.of_node, key, &smp2p->remote_pid);\n\tif (ret)\n\t\tgoto report_read_failure;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tsmp2p->mbox_client.dev = &pdev->dev;\n\tsmp2p->mbox_client.knows_txdone = true;\n\tsmp2p->mbox_chan = mbox_request_channel(&smp2p->mbox_client, 0);\n\tif (IS_ERR(smp2p->mbox_chan)) {\n\t\tif (PTR_ERR(smp2p->mbox_chan) != -ENODEV)\n\t\t\treturn PTR_ERR(smp2p->mbox_chan);\n\n\t\tsmp2p->mbox_chan = NULL;\n\n\t\tret = smp2p_parse_ipc(smp2p);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = qcom_smp2p_alloc_outbound_item(smp2p);\n\tif (ret < 0)\n\t\tgoto release_mbox;\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, node) {\n\t\tentry = devm_kzalloc(&pdev->dev, sizeof(*entry), GFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tret = -ENOMEM;\n\t\t\tof_node_put(node);\n\t\t\tgoto unwind_interfaces;\n\t\t}\n\n\t\tentry->smp2p = smp2p;\n\t\tspin_lock_init(&entry->lock);\n\n\t\tret = of_property_read_string(node, \"qcom,entry-name\", &entry->name);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(node);\n\t\t\tgoto unwind_interfaces;\n\t\t}\n\n\t\tif (of_property_read_bool(node, \"interrupt-controller\")) {\n\t\t\tret = qcom_smp2p_inbound_entry(smp2p, entry, node);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(node);\n\t\t\t\tgoto unwind_interfaces;\n\t\t\t}\n\n\t\t\tlist_add(&entry->node, &smp2p->inbound);\n\t\t} else  {\n\t\t\tret = qcom_smp2p_outbound_entry(smp2p, entry, node);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(node);\n\t\t\t\tgoto unwind_interfaces;\n\t\t\t}\n\n\t\t\tlist_add(&entry->node, &smp2p->outbound);\n\t\t}\n\t}\n\n\t \n\tqcom_smp2p_kick(smp2p);\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tNULL, qcom_smp2p_intr,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"smp2p\", (void *)smp2p);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request interrupt\\n\");\n\t\tgoto unwind_interfaces;\n\t}\n\n\t \n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\tret = dev_pm_set_wake_irq(&pdev->dev, irq);\n\tif (ret)\n\t\tgoto set_wake_irq_fail;\n\n\treturn 0;\n\nset_wake_irq_fail:\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\nunwind_interfaces:\n\tlist_for_each_entry(entry, &smp2p->inbound, node)\n\t\tirq_domain_remove(entry->domain);\n\n\tlist_for_each_entry(entry, &smp2p->outbound, node)\n\t\tqcom_smem_state_unregister(entry->state);\n\n\tsmp2p->out->valid_entries = 0;\n\nrelease_mbox:\n\tmbox_free_channel(smp2p->mbox_chan);\n\n\treturn ret;\n\nreport_read_failure:\n\tdev_err(&pdev->dev, \"failed to read %s\\n\", key);\n\treturn -EINVAL;\n}\n\nstatic int qcom_smp2p_remove(struct platform_device *pdev)\n{\n\tstruct qcom_smp2p *smp2p = platform_get_drvdata(pdev);\n\tstruct smp2p_entry *entry;\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\n\tlist_for_each_entry(entry, &smp2p->inbound, node)\n\t\tirq_domain_remove(entry->domain);\n\n\tlist_for_each_entry(entry, &smp2p->outbound, node)\n\t\tqcom_smem_state_unregister(entry->state);\n\n\tmbox_free_channel(smp2p->mbox_chan);\n\n\tsmp2p->out->valid_entries = 0;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_smp2p_of_match[] = {\n\t{ .compatible = \"qcom,smp2p\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_smp2p_of_match);\n\nstatic struct platform_driver qcom_smp2p_driver = {\n\t.probe = qcom_smp2p_probe,\n\t.remove = qcom_smp2p_remove,\n\t.driver  = {\n\t\t.name  = \"qcom_smp2p\",\n\t\t.of_match_table = qcom_smp2p_of_match,\n\t},\n};\nmodule_platform_driver(qcom_smp2p_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Shared Memory Point to Point driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}