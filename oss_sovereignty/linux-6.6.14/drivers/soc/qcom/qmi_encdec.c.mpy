{
  "module_name": "qmi_encdec.c",
  "hash_id": "ec4d0f505607cc6ae3293935587ec6f569e11239376aa0a73ec2ad2dce9124bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qmi_encdec.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/soc/qcom/qmi.h>\n\n#define QMI_ENCDEC_ENCODE_TLV(type, length, p_dst) do { \\\n\t*p_dst++ = type; \\\n\t*p_dst++ = ((u8)((length) & 0xFF)); \\\n\t*p_dst++ = ((u8)(((length) >> 8) & 0xFF)); \\\n} while (0)\n\n#define QMI_ENCDEC_DECODE_TLV(p_type, p_length, p_src) do { \\\n\t*p_type = (u8)*p_src++; \\\n\t*p_length = (u8)*p_src++; \\\n\t*p_length |= ((u8)*p_src) << 8; \\\n} while (0)\n\n#define QMI_ENCDEC_ENCODE_N_BYTES(p_dst, p_src, size) \\\ndo { \\\n\tmemcpy(p_dst, p_src, size); \\\n\tp_dst = (u8 *)p_dst + size; \\\n\tp_src = (u8 *)p_src + size; \\\n} while (0)\n\n#define QMI_ENCDEC_DECODE_N_BYTES(p_dst, p_src, size) \\\ndo { \\\n\tmemcpy(p_dst, p_src, size); \\\n\tp_dst = (u8 *)p_dst + size; \\\n\tp_src = (u8 *)p_src + size; \\\n} while (0)\n\n#define UPDATE_ENCODE_VARIABLES(temp_si, buf_dst, \\\n\t\t\t\tencoded_bytes, tlv_len, encode_tlv, rc) \\\ndo { \\\n\tbuf_dst = (u8 *)buf_dst + rc; \\\n\tencoded_bytes += rc; \\\n\ttlv_len += rc; \\\n\ttemp_si = temp_si + 1; \\\n\tencode_tlv = 1; \\\n} while (0)\n\n#define UPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc) \\\ndo { \\\n\tbuf_src = (u8 *)buf_src + rc; \\\n\tdecoded_bytes += rc; \\\n} while (0)\n\n#define TLV_LEN_SIZE sizeof(u16)\n#define TLV_TYPE_SIZE sizeof(u8)\n#define OPTIONAL_TLV_TYPE_START 0x10\n\nstatic int qmi_encode(const struct qmi_elem_info *ei_array, void *out_buf,\n\t\t      const void *in_c_struct, u32 out_buf_len,\n\t\t      int enc_level);\n\nstatic int qmi_decode(const struct qmi_elem_info *ei_array, void *out_c_struct,\n\t\t      const void *in_buf, u32 in_buf_len, int dec_level);\n\n \nstatic const struct qmi_elem_info *\nskip_to_next_elem(const struct qmi_elem_info *ei_array, int level)\n{\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\tu8 tlv_type;\n\n\tif (level > 1) {\n\t\ttemp_ei = temp_ei + 1;\n\t} else {\n\t\tdo {\n\t\t\ttlv_type = temp_ei->tlv_type;\n\t\t\ttemp_ei = temp_ei + 1;\n\t\t} while (tlv_type == temp_ei->tlv_type);\n\t}\n\n\treturn temp_ei;\n}\n\n \nstatic int qmi_calc_min_msg_len(const struct qmi_elem_info *ei_array,\n\t\t\t\tint level)\n{\n\tint min_msg_len = 0;\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\n\tif (!ei_array)\n\t\treturn min_msg_len;\n\n\twhile (temp_ei->data_type != QMI_EOTI) {\n\t\t \n\t\tif (temp_ei->data_type == QMI_OPT_FLAG) {\n\t\t\ttemp_ei = skip_to_next_elem(temp_ei, level);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (temp_ei->data_type == QMI_DATA_LEN) {\n\t\t\tmin_msg_len += (temp_ei->elem_size == sizeof(u8) ?\n\t\t\t\t\tsizeof(u8) : sizeof(u16));\n\t\t\ttemp_ei++;\n\t\t\tcontinue;\n\t\t} else if (temp_ei->data_type == QMI_STRUCT) {\n\t\t\tmin_msg_len += qmi_calc_min_msg_len(temp_ei->ei_array,\n\t\t\t\t\t\t\t    (level + 1));\n\t\t\ttemp_ei++;\n\t\t} else if (temp_ei->data_type == QMI_STRING) {\n\t\t\tif (level > 1)\n\t\t\t\tmin_msg_len += temp_ei->elem_len <= U8_MAX ?\n\t\t\t\t\tsizeof(u8) : sizeof(u16);\n\t\t\tmin_msg_len += temp_ei->elem_len * temp_ei->elem_size;\n\t\t\ttemp_ei++;\n\t\t} else {\n\t\t\tmin_msg_len += (temp_ei->elem_len * temp_ei->elem_size);\n\t\t\ttemp_ei++;\n\t\t}\n\n\t\t \n\t\tif (level == 1)\n\t\t\tmin_msg_len += (TLV_TYPE_SIZE + TLV_LEN_SIZE);\n\t}\n\n\treturn min_msg_len;\n}\n\n \nstatic int qmi_encode_basic_elem(void *buf_dst, const void *buf_src,\n\t\t\t\t u32 elem_len, u32 elem_size)\n{\n\tu32 i, rc = 0;\n\n\tfor (i = 0; i < elem_len; i++) {\n\t\tQMI_ENCDEC_ENCODE_N_BYTES(buf_dst, buf_src, elem_size);\n\t\trc += elem_size;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int qmi_encode_struct_elem(const struct qmi_elem_info *ei_array,\n\t\t\t\t  void *buf_dst, const void *buf_src,\n\t\t\t\t  u32 elem_len, u32 out_buf_len,\n\t\t\t\t  int enc_level)\n{\n\tint i, rc, encoded_bytes = 0;\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\n\tfor (i = 0; i < elem_len; i++) {\n\t\trc = qmi_encode(temp_ei->ei_array, buf_dst, buf_src,\n\t\t\t\tout_buf_len - encoded_bytes, enc_level);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"%s: STRUCT Encode failure\\n\", __func__);\n\t\t\treturn rc;\n\t\t}\n\t\tbuf_dst = buf_dst + rc;\n\t\tbuf_src = buf_src + temp_ei->elem_size;\n\t\tencoded_bytes += rc;\n\t}\n\n\treturn encoded_bytes;\n}\n\n \nstatic int qmi_encode_string_elem(const struct qmi_elem_info *ei_array,\n\t\t\t\t  void *buf_dst, const void *buf_src,\n\t\t\t\t  u32 out_buf_len, int enc_level)\n{\n\tint rc;\n\tint encoded_bytes = 0;\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\tu32 string_len = 0;\n\tu32 string_len_sz = 0;\n\n\tstring_len = strlen(buf_src);\n\tstring_len_sz = temp_ei->elem_len <= U8_MAX ?\n\t\t\tsizeof(u8) : sizeof(u16);\n\tif (string_len > temp_ei->elem_len) {\n\t\tpr_err(\"%s: String to be encoded is longer - %d > %d\\n\",\n\t\t       __func__, string_len, temp_ei->elem_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (enc_level == 1) {\n\t\tif (string_len + TLV_LEN_SIZE + TLV_TYPE_SIZE >\n\t\t    out_buf_len) {\n\t\t\tpr_err(\"%s: Output len %d > Out Buf len %d\\n\",\n\t\t\t       __func__, string_len, out_buf_len);\n\t\t\treturn -ETOOSMALL;\n\t\t}\n\t} else {\n\t\tif (string_len + string_len_sz > out_buf_len) {\n\t\t\tpr_err(\"%s: Output len %d > Out Buf len %d\\n\",\n\t\t\t       __func__, string_len, out_buf_len);\n\t\t\treturn -ETOOSMALL;\n\t\t}\n\t\trc = qmi_encode_basic_elem(buf_dst, &string_len,\n\t\t\t\t\t   1, string_len_sz);\n\t\tencoded_bytes += rc;\n\t}\n\n\trc = qmi_encode_basic_elem(buf_dst + encoded_bytes, buf_src,\n\t\t\t\t   string_len, temp_ei->elem_size);\n\tencoded_bytes += rc;\n\n\treturn encoded_bytes;\n}\n\n \nstatic int qmi_encode(const struct qmi_elem_info *ei_array, void *out_buf,\n\t\t      const void *in_c_struct, u32 out_buf_len,\n\t\t      int enc_level)\n{\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\tu8 opt_flag_value = 0;\n\tu32 data_len_value = 0, data_len_sz;\n\tu8 *buf_dst = (u8 *)out_buf;\n\tu8 *tlv_pointer;\n\tu32 tlv_len;\n\tu8 tlv_type;\n\tu32 encoded_bytes = 0;\n\tconst void *buf_src;\n\tint encode_tlv = 0;\n\tint rc;\n\n\tif (!ei_array)\n\t\treturn 0;\n\n\ttlv_pointer = buf_dst;\n\ttlv_len = 0;\n\tif (enc_level == 1)\n\t\tbuf_dst = buf_dst + (TLV_LEN_SIZE + TLV_TYPE_SIZE);\n\n\twhile (temp_ei->data_type != QMI_EOTI) {\n\t\tbuf_src = in_c_struct + temp_ei->offset;\n\t\ttlv_type = temp_ei->tlv_type;\n\n\t\tif (temp_ei->array_type == NO_ARRAY) {\n\t\t\tdata_len_value = 1;\n\t\t} else if (temp_ei->array_type == STATIC_ARRAY) {\n\t\t\tdata_len_value = temp_ei->elem_len;\n\t\t} else if (data_len_value <= 0 ||\n\t\t\t    temp_ei->elem_len < data_len_value) {\n\t\t\tpr_err(\"%s: Invalid data length\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (temp_ei->data_type) {\n\t\tcase QMI_OPT_FLAG:\n\t\t\trc = qmi_encode_basic_elem(&opt_flag_value, buf_src,\n\t\t\t\t\t\t   1, sizeof(u8));\n\t\t\tif (opt_flag_value)\n\t\t\t\ttemp_ei = temp_ei + 1;\n\t\t\telse\n\t\t\t\ttemp_ei = skip_to_next_elem(temp_ei, enc_level);\n\t\t\tbreak;\n\n\t\tcase QMI_DATA_LEN:\n\t\t\tmemcpy(&data_len_value, buf_src, temp_ei->elem_size);\n\t\t\tdata_len_sz = temp_ei->elem_size == sizeof(u8) ?\n\t\t\t\t\tsizeof(u8) : sizeof(u16);\n\t\t\t \n\t\t\tif ((data_len_sz + encoded_bytes + TLV_LEN_SIZE +\n\t\t\t    TLV_TYPE_SIZE) > out_buf_len) {\n\t\t\t\tpr_err(\"%s: Too Small Buffer @DATA_LEN\\n\",\n\t\t\t\t       __func__);\n\t\t\t\treturn -ETOOSMALL;\n\t\t\t}\n\t\t\trc = qmi_encode_basic_elem(buf_dst, &data_len_value,\n\t\t\t\t\t\t   1, data_len_sz);\n\t\t\tUPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,\n\t\t\t\t\t\tencoded_bytes, tlv_len,\n\t\t\t\t\t\tencode_tlv, rc);\n\t\t\tif (!data_len_value)\n\t\t\t\ttemp_ei = skip_to_next_elem(temp_ei, enc_level);\n\t\t\telse\n\t\t\t\tencode_tlv = 0;\n\t\t\tbreak;\n\n\t\tcase QMI_UNSIGNED_1_BYTE:\n\t\tcase QMI_UNSIGNED_2_BYTE:\n\t\tcase QMI_UNSIGNED_4_BYTE:\n\t\tcase QMI_UNSIGNED_8_BYTE:\n\t\tcase QMI_SIGNED_2_BYTE_ENUM:\n\t\tcase QMI_SIGNED_4_BYTE_ENUM:\n\t\t\t \n\t\t\tif (((data_len_value * temp_ei->elem_size) +\n\t\t\t    encoded_bytes + TLV_LEN_SIZE + TLV_TYPE_SIZE) >\n\t\t\t    out_buf_len) {\n\t\t\t\tpr_err(\"%s: Too Small Buffer @data_type:%d\\n\",\n\t\t\t\t       __func__, temp_ei->data_type);\n\t\t\t\treturn -ETOOSMALL;\n\t\t\t}\n\t\t\trc = qmi_encode_basic_elem(buf_dst, buf_src,\n\t\t\t\t\t\t   data_len_value,\n\t\t\t\t\t\t   temp_ei->elem_size);\n\t\t\tUPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,\n\t\t\t\t\t\tencoded_bytes, tlv_len,\n\t\t\t\t\t\tencode_tlv, rc);\n\t\t\tbreak;\n\n\t\tcase QMI_STRUCT:\n\t\t\trc = qmi_encode_struct_elem(temp_ei, buf_dst, buf_src,\n\t\t\t\t\t\t    data_len_value,\n\t\t\t\t\t\t    out_buf_len - encoded_bytes,\n\t\t\t\t\t\t    enc_level + 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tUPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,\n\t\t\t\t\t\tencoded_bytes, tlv_len,\n\t\t\t\t\t\tencode_tlv, rc);\n\t\t\tbreak;\n\n\t\tcase QMI_STRING:\n\t\t\trc = qmi_encode_string_elem(temp_ei, buf_dst, buf_src,\n\t\t\t\t\t\t    out_buf_len - encoded_bytes,\n\t\t\t\t\t\t    enc_level);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tUPDATE_ENCODE_VARIABLES(temp_ei, buf_dst,\n\t\t\t\t\t\tencoded_bytes, tlv_len,\n\t\t\t\t\t\tencode_tlv, rc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unrecognized data type\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (encode_tlv && enc_level == 1) {\n\t\t\tQMI_ENCDEC_ENCODE_TLV(tlv_type, tlv_len, tlv_pointer);\n\t\t\tencoded_bytes += (TLV_TYPE_SIZE + TLV_LEN_SIZE);\n\t\t\ttlv_pointer = buf_dst;\n\t\t\ttlv_len = 0;\n\t\t\tbuf_dst = buf_dst + TLV_LEN_SIZE + TLV_TYPE_SIZE;\n\t\t\tencode_tlv = 0;\n\t\t}\n\t}\n\n\treturn encoded_bytes;\n}\n\n \nstatic int qmi_decode_basic_elem(void *buf_dst, const void *buf_src,\n\t\t\t\t u32 elem_len, u32 elem_size)\n{\n\tu32 i, rc = 0;\n\n\tfor (i = 0; i < elem_len; i++) {\n\t\tQMI_ENCDEC_DECODE_N_BYTES(buf_dst, buf_src, elem_size);\n\t\trc += elem_size;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int qmi_decode_struct_elem(const struct qmi_elem_info *ei_array,\n\t\t\t\t  void *buf_dst, const void *buf_src,\n\t\t\t\t  u32 elem_len, u32 tlv_len,\n\t\t\t\t  int dec_level)\n{\n\tint i, rc, decoded_bytes = 0;\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\n\tfor (i = 0; i < elem_len && decoded_bytes < tlv_len; i++) {\n\t\trc = qmi_decode(temp_ei->ei_array, buf_dst, buf_src,\n\t\t\t\ttlv_len - decoded_bytes, dec_level);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tbuf_src = buf_src + rc;\n\t\tbuf_dst = buf_dst + temp_ei->elem_size;\n\t\tdecoded_bytes += rc;\n\t}\n\n\tif ((dec_level <= 2 && decoded_bytes != tlv_len) ||\n\t    (dec_level > 2 && (i < elem_len || decoded_bytes > tlv_len))) {\n\t\tpr_err(\"%s: Fault in decoding: dl(%d), db(%d), tl(%d), i(%d), el(%d)\\n\",\n\t\t       __func__, dec_level, decoded_bytes, tlv_len,\n\t\t       i, elem_len);\n\t\treturn -EFAULT;\n\t}\n\n\treturn decoded_bytes;\n}\n\n \nstatic int qmi_decode_string_elem(const struct qmi_elem_info *ei_array,\n\t\t\t\t  void *buf_dst, const void *buf_src,\n\t\t\t\t  u32 tlv_len, int dec_level)\n{\n\tint rc;\n\tint decoded_bytes = 0;\n\tu32 string_len = 0;\n\tu32 string_len_sz = 0;\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\n\tif (dec_level == 1) {\n\t\tstring_len = tlv_len;\n\t} else {\n\t\tstring_len_sz = temp_ei->elem_len <= U8_MAX ?\n\t\t\t\tsizeof(u8) : sizeof(u16);\n\t\trc = qmi_decode_basic_elem(&string_len, buf_src,\n\t\t\t\t\t   1, string_len_sz);\n\t\tdecoded_bytes += rc;\n\t}\n\n\tif (string_len >= temp_ei->elem_len) {\n\t\tpr_err(\"%s: String len %d >= Max Len %d\\n\",\n\t\t       __func__, string_len, temp_ei->elem_len);\n\t\treturn -ETOOSMALL;\n\t} else if (string_len > tlv_len) {\n\t\tpr_err(\"%s: String len %d > Input Buffer Len %d\\n\",\n\t\t       __func__, string_len, tlv_len);\n\t\treturn -EFAULT;\n\t}\n\n\trc = qmi_decode_basic_elem(buf_dst, buf_src + decoded_bytes,\n\t\t\t\t   string_len, temp_ei->elem_size);\n\t*((char *)buf_dst + string_len) = '\\0';\n\tdecoded_bytes += rc;\n\n\treturn decoded_bytes;\n}\n\n \nstatic const struct qmi_elem_info *find_ei(const struct qmi_elem_info *ei_array,\n\t\t\t\t\t   u32 type)\n{\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\n\twhile (temp_ei->data_type != QMI_EOTI) {\n\t\tif (temp_ei->tlv_type == (u8)type)\n\t\t\treturn temp_ei;\n\t\ttemp_ei = temp_ei + 1;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int qmi_decode(const struct qmi_elem_info *ei_array, void *out_c_struct,\n\t\t      const void *in_buf, u32 in_buf_len,\n\t\t      int dec_level)\n{\n\tconst struct qmi_elem_info *temp_ei = ei_array;\n\tu8 opt_flag_value = 1;\n\tu32 data_len_value = 0, data_len_sz = 0;\n\tu8 *buf_dst = out_c_struct;\n\tconst u8 *tlv_pointer;\n\tu32 tlv_len = 0;\n\tu32 tlv_type;\n\tu32 decoded_bytes = 0;\n\tconst void *buf_src = in_buf;\n\tint rc;\n\n\twhile (decoded_bytes < in_buf_len) {\n\t\tif (dec_level >= 2 && temp_ei->data_type == QMI_EOTI)\n\t\t\treturn decoded_bytes;\n\n\t\tif (dec_level == 1) {\n\t\t\ttlv_pointer = buf_src;\n\t\t\tQMI_ENCDEC_DECODE_TLV(&tlv_type,\n\t\t\t\t\t      &tlv_len, tlv_pointer);\n\t\t\tbuf_src += (TLV_TYPE_SIZE + TLV_LEN_SIZE);\n\t\t\tdecoded_bytes += (TLV_TYPE_SIZE + TLV_LEN_SIZE);\n\t\t\ttemp_ei = find_ei(ei_array, tlv_type);\n\t\t\tif (!temp_ei && tlv_type < OPTIONAL_TLV_TYPE_START) {\n\t\t\t\tpr_err(\"%s: Inval element info\\n\", __func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (!temp_ei) {\n\t\t\t\tUPDATE_DECODE_VARIABLES(buf_src,\n\t\t\t\t\t\t\tdecoded_bytes, tlv_len);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttlv_len = in_buf_len - decoded_bytes;\n\t\t}\n\n\t\tbuf_dst = out_c_struct + temp_ei->offset;\n\t\tif (temp_ei->data_type == QMI_OPT_FLAG) {\n\t\t\tmemcpy(buf_dst, &opt_flag_value, sizeof(u8));\n\t\t\ttemp_ei = temp_ei + 1;\n\t\t\tbuf_dst = out_c_struct + temp_ei->offset;\n\t\t}\n\n\t\tif (temp_ei->data_type == QMI_DATA_LEN) {\n\t\t\tdata_len_sz = temp_ei->elem_size == sizeof(u8) ?\n\t\t\t\t\tsizeof(u8) : sizeof(u16);\n\t\t\trc = qmi_decode_basic_elem(&data_len_value, buf_src,\n\t\t\t\t\t\t   1, data_len_sz);\n\t\t\tmemcpy(buf_dst, &data_len_value, sizeof(u32));\n\t\t\ttemp_ei = temp_ei + 1;\n\t\t\tbuf_dst = out_c_struct + temp_ei->offset;\n\t\t\ttlv_len -= data_len_sz;\n\t\t\tUPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);\n\t\t}\n\n\t\tif (temp_ei->array_type == NO_ARRAY) {\n\t\t\tdata_len_value = 1;\n\t\t} else if (temp_ei->array_type == STATIC_ARRAY) {\n\t\t\tdata_len_value = temp_ei->elem_len;\n\t\t} else if (data_len_value > temp_ei->elem_len) {\n\t\t\tpr_err(\"%s: Data len %d > max spec %d\\n\",\n\t\t\t       __func__, data_len_value, temp_ei->elem_len);\n\t\t\treturn -ETOOSMALL;\n\t\t}\n\n\t\tswitch (temp_ei->data_type) {\n\t\tcase QMI_UNSIGNED_1_BYTE:\n\t\tcase QMI_UNSIGNED_2_BYTE:\n\t\tcase QMI_UNSIGNED_4_BYTE:\n\t\tcase QMI_UNSIGNED_8_BYTE:\n\t\tcase QMI_SIGNED_2_BYTE_ENUM:\n\t\tcase QMI_SIGNED_4_BYTE_ENUM:\n\t\t\trc = qmi_decode_basic_elem(buf_dst, buf_src,\n\t\t\t\t\t\t   data_len_value,\n\t\t\t\t\t\t   temp_ei->elem_size);\n\t\t\tUPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);\n\t\t\tbreak;\n\n\t\tcase QMI_STRUCT:\n\t\t\trc = qmi_decode_struct_elem(temp_ei, buf_dst, buf_src,\n\t\t\t\t\t\t    data_len_value, tlv_len,\n\t\t\t\t\t\t    dec_level + 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tUPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);\n\t\t\tbreak;\n\n\t\tcase QMI_STRING:\n\t\t\trc = qmi_decode_string_elem(temp_ei, buf_dst, buf_src,\n\t\t\t\t\t\t    tlv_len, dec_level);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tUPDATE_DECODE_VARIABLES(buf_src, decoded_bytes, rc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unrecognized data type\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttemp_ei = temp_ei + 1;\n\t}\n\n\treturn decoded_bytes;\n}\n\n \nvoid *qmi_encode_message(int type, unsigned int msg_id, size_t *len,\n\t\t\t unsigned int txn_id, const struct qmi_elem_info *ei,\n\t\t\t const void *c_struct)\n{\n\tstruct qmi_header *hdr;\n\tssize_t msglen = 0;\n\tvoid *msg;\n\tint ret;\n\n\t \n\tif (!c_struct) {\n\t\tret = qmi_calc_min_msg_len(ei, 1);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: Calc. len %d != 0, but NULL c_struct\\n\",\n\t\t\t       __func__, ret);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tmsg = kzalloc(sizeof(*hdr) + *len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (c_struct) {\n\t\tmsglen = qmi_encode(ei, msg + sizeof(*hdr), c_struct, *len, 1);\n\t\tif (msglen < 0) {\n\t\t\tkfree(msg);\n\t\t\treturn ERR_PTR(msglen);\n\t\t}\n\t}\n\n\thdr = msg;\n\thdr->type = type;\n\thdr->txn_id = txn_id;\n\thdr->msg_id = msg_id;\n\thdr->msg_len = msglen;\n\n\t*len = sizeof(*hdr) + msglen;\n\n\treturn msg;\n}\nEXPORT_SYMBOL(qmi_encode_message);\n\n \nint qmi_decode_message(const void *buf, size_t len,\n\t\t       const struct qmi_elem_info *ei, void *c_struct)\n{\n\tif (!ei)\n\t\treturn -EINVAL;\n\n\tif (!c_struct || !buf || !len)\n\t\treturn -EINVAL;\n\n\treturn qmi_decode(ei, c_struct, buf + sizeof(struct qmi_header),\n\t\t\t  len - sizeof(struct qmi_header), 1);\n}\nEXPORT_SYMBOL(qmi_decode_message);\n\n \nconst struct qmi_elem_info qmi_response_type_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_SIGNED_2_BYTE_ENUM,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= QMI_COMMON_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct qmi_response_type_v01, result),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_SIGNED_2_BYTE_ENUM,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u16),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= QMI_COMMON_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct qmi_response_type_v01, error),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_EOTI,\n\t\t.elem_len\t= 0,\n\t\t.elem_size\t= 0,\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= QMI_COMMON_TLV_TYPE,\n\t\t.offset\t\t= 0,\n\t\t.ei_array\t= NULL,\n\t},\n};\nEXPORT_SYMBOL(qmi_response_type_v01_ei);\n\nMODULE_DESCRIPTION(\"QMI encoder/decoder helper\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}