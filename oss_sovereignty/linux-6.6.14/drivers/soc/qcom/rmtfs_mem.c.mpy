{
  "module_name": "rmtfs_mem.c",
  "hash_id": "0e0505608fef8e4557fe87c9a3eadf0e61e783f509a9d870e3c625ebae457c48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/rmtfs_mem.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/cdev.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n\n#define QCOM_RMTFS_MEM_DEV_MAX\t(MINORMASK + 1)\n#define NUM_MAX_VMIDS\t\t2\n\nstatic dev_t qcom_rmtfs_mem_major;\n\nstruct qcom_rmtfs_mem {\n\tstruct device dev;\n\tstruct cdev cdev;\n\n\tvoid *base;\n\tphys_addr_t addr;\n\tphys_addr_t size;\n\n\tunsigned int client_id;\n\n\tu64 perms;\n};\n\nstatic ssize_t qcom_rmtfs_mem_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf);\n\nstatic DEVICE_ATTR(phys_addr, 0444, qcom_rmtfs_mem_show, NULL);\nstatic DEVICE_ATTR(size, 0444, qcom_rmtfs_mem_show, NULL);\nstatic DEVICE_ATTR(client_id, 0444, qcom_rmtfs_mem_show, NULL);\n\nstatic ssize_t qcom_rmtfs_mem_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = container_of(dev,\n\t\t\t\t\t\t\tstruct qcom_rmtfs_mem,\n\t\t\t\t\t\t\tdev);\n\n\tif (attr == &dev_attr_phys_addr)\n\t\treturn sprintf(buf, \"%pa\\n\", &rmtfs_mem->addr);\n\tif (attr == &dev_attr_size)\n\t\treturn sprintf(buf, \"%pa\\n\", &rmtfs_mem->size);\n\tif (attr == &dev_attr_client_id)\n\t\treturn sprintf(buf, \"%d\\n\", rmtfs_mem->client_id);\n\n\treturn -EINVAL;\n}\n\nstatic struct attribute *qcom_rmtfs_mem_attrs[] = {\n\t&dev_attr_phys_addr.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_client_id.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(qcom_rmtfs_mem);\n\nstatic int qcom_rmtfs_mem_open(struct inode *inode, struct file *filp)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = container_of(inode->i_cdev,\n\t\t\t\t\t\t\tstruct qcom_rmtfs_mem,\n\t\t\t\t\t\t\tcdev);\n\n\tget_device(&rmtfs_mem->dev);\n\tfilp->private_data = rmtfs_mem;\n\n\treturn 0;\n}\nstatic ssize_t qcom_rmtfs_mem_read(struct file *filp,\n\t\t\t      char __user *buf, size_t count, loff_t *f_pos)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = filp->private_data;\n\n\tif (*f_pos >= rmtfs_mem->size)\n\t\treturn 0;\n\n\tif (*f_pos + count >= rmtfs_mem->size)\n\t\tcount = rmtfs_mem->size - *f_pos;\n\n\tif (copy_to_user(buf, rmtfs_mem->base + *f_pos, count))\n\t\treturn -EFAULT;\n\n\t*f_pos += count;\n\treturn count;\n}\n\nstatic ssize_t qcom_rmtfs_mem_write(struct file *filp,\n\t\t\t       const char __user *buf, size_t count,\n\t\t\t       loff_t *f_pos)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = filp->private_data;\n\n\tif (*f_pos >= rmtfs_mem->size)\n\t\treturn 0;\n\n\tif (*f_pos + count >= rmtfs_mem->size)\n\t\tcount = rmtfs_mem->size - *f_pos;\n\n\tif (copy_from_user(rmtfs_mem->base + *f_pos, buf, count))\n\t\treturn -EFAULT;\n\n\t*f_pos += count;\n\treturn count;\n}\n\nstatic int qcom_rmtfs_mem_release(struct inode *inode, struct file *filp)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = filp->private_data;\n\n\tput_device(&rmtfs_mem->dev);\n\n\treturn 0;\n}\n\nstatic struct class rmtfs_class = {\n\t.name           = \"rmtfs\",\n};\n\nstatic int qcom_rmtfs_mem_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = filep->private_data;\n\n\tif (vma->vm_end - vma->vm_start > rmtfs_mem->size) {\n\t\tdev_dbg(&rmtfs_mem->dev,\n\t\t\t\"vm_end[%lu] - vm_start[%lu] [%lu] > mem->size[%pa]\\n\",\n\t\t\tvma->vm_end, vma->vm_start,\n\t\t\t(vma->vm_end - vma->vm_start), &rmtfs_mem->size);\n\t\treturn -EINVAL;\n\t}\n\n\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       rmtfs_mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}\n\nstatic const struct file_operations qcom_rmtfs_mem_fops = {\n\t.owner = THIS_MODULE,\n\t.open = qcom_rmtfs_mem_open,\n\t.read = qcom_rmtfs_mem_read,\n\t.write = qcom_rmtfs_mem_write,\n\t.release = qcom_rmtfs_mem_release,\n\t.llseek = default_llseek,\n\t.mmap = qcom_rmtfs_mem_mmap,\n};\n\nstatic void qcom_rmtfs_mem_release_device(struct device *dev)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = container_of(dev,\n\t\t\t\t\t\t\tstruct qcom_rmtfs_mem,\n\t\t\t\t\t\t\tdev);\n\n\tkfree(rmtfs_mem);\n}\n\nstatic int qcom_rmtfs_mem_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct qcom_scm_vmperm perms[NUM_MAX_VMIDS + 1];\n\tstruct reserved_mem *rmem;\n\tstruct qcom_rmtfs_mem *rmtfs_mem;\n\tu32 client_id;\n\tu32 vmid[NUM_MAX_VMIDS];\n\tint num_vmids;\n\tint ret, i;\n\n\trmem = of_reserved_mem_lookup(node);\n\tif (!rmem) {\n\t\tdev_err(&pdev->dev, \"failed to acquire memory region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(node, \"qcom,client-id\", &client_id);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to parse \\\"qcom,client-id\\\"\\n\");\n\t\treturn ret;\n\n\t}\n\n\trmtfs_mem = kzalloc(sizeof(*rmtfs_mem), GFP_KERNEL);\n\tif (!rmtfs_mem)\n\t\treturn -ENOMEM;\n\n\trmtfs_mem->addr = rmem->base;\n\trmtfs_mem->client_id = client_id;\n\trmtfs_mem->size = rmem->size;\n\n\tdevice_initialize(&rmtfs_mem->dev);\n\trmtfs_mem->dev.parent = &pdev->dev;\n\trmtfs_mem->dev.groups = qcom_rmtfs_mem_groups;\n\trmtfs_mem->dev.release = qcom_rmtfs_mem_release_device;\n\n\trmtfs_mem->base = devm_memremap(&rmtfs_mem->dev, rmtfs_mem->addr,\n\t\t\t\t\trmtfs_mem->size, MEMREMAP_WC);\n\tif (IS_ERR(rmtfs_mem->base)) {\n\t\tdev_err(&pdev->dev, \"failed to remap rmtfs_mem region\\n\");\n\t\tret = PTR_ERR(rmtfs_mem->base);\n\t\tgoto put_device;\n\t}\n\n\tcdev_init(&rmtfs_mem->cdev, &qcom_rmtfs_mem_fops);\n\trmtfs_mem->cdev.owner = THIS_MODULE;\n\n\tdev_set_name(&rmtfs_mem->dev, \"qcom_rmtfs_mem%d\", client_id);\n\trmtfs_mem->dev.id = client_id;\n\trmtfs_mem->dev.class = &rmtfs_class;\n\trmtfs_mem->dev.devt = MKDEV(MAJOR(qcom_rmtfs_mem_major), client_id);\n\n\tret = cdev_device_add(&rmtfs_mem->cdev, &rmtfs_mem->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add cdev: %d\\n\", ret);\n\t\tgoto put_device;\n\t}\n\n\tnum_vmids = of_property_count_u32_elems(node, \"qcom,vmid\");\n\tif (num_vmids == -EINVAL) {\n\t\t \n\t\tnum_vmids = 0;\n\t} else if (num_vmids < 0) {\n\t\tdev_err(&pdev->dev, \"failed to count qcom,vmid elements: %d\\n\", num_vmids);\n\t\tret = num_vmids;\n\t\tgoto remove_cdev;\n\t} else if (num_vmids > NUM_MAX_VMIDS) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"too many VMIDs (%d) specified! Only mapping first %d entries\\n\",\n\t\t\t num_vmids, NUM_MAX_VMIDS);\n\t\tnum_vmids = NUM_MAX_VMIDS;\n\t}\n\n\tret = of_property_read_u32_array(node, \"qcom,vmid\", vmid, num_vmids);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(&pdev->dev, \"failed to parse qcom,vmid\\n\");\n\t\tgoto remove_cdev;\n\t} else if (!ret) {\n\t\tif (!qcom_scm_is_available()) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto remove_cdev;\n\t\t}\n\n\t\tperms[0].vmid = QCOM_SCM_VMID_HLOS;\n\t\tperms[0].perm = QCOM_SCM_PERM_RW;\n\n\t\tfor (i = 0; i < num_vmids; i++) {\n\t\t\tperms[i + 1].vmid = vmid[i];\n\t\t\tperms[i + 1].perm = QCOM_SCM_PERM_RW;\n\t\t}\n\n\t\trmtfs_mem->perms = BIT(QCOM_SCM_VMID_HLOS);\n\t\tret = qcom_scm_assign_mem(rmtfs_mem->addr, rmtfs_mem->size,\n\t\t\t\t\t  &rmtfs_mem->perms, perms, num_vmids + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"assign memory failed\\n\");\n\t\t\tgoto remove_cdev;\n\t\t}\n\t}\n\n\tdev_set_drvdata(&pdev->dev, rmtfs_mem);\n\n\treturn 0;\n\nremove_cdev:\n\tcdev_device_del(&rmtfs_mem->cdev, &rmtfs_mem->dev);\nput_device:\n\tput_device(&rmtfs_mem->dev);\n\n\treturn ret;\n}\n\nstatic int qcom_rmtfs_mem_remove(struct platform_device *pdev)\n{\n\tstruct qcom_rmtfs_mem *rmtfs_mem = dev_get_drvdata(&pdev->dev);\n\tstruct qcom_scm_vmperm perm;\n\n\tif (rmtfs_mem->perms) {\n\t\tperm.vmid = QCOM_SCM_VMID_HLOS;\n\t\tperm.perm = QCOM_SCM_PERM_RW;\n\n\t\tqcom_scm_assign_mem(rmtfs_mem->addr, rmtfs_mem->size,\n\t\t\t\t    &rmtfs_mem->perms, &perm, 1);\n\t}\n\n\tcdev_device_del(&rmtfs_mem->cdev, &rmtfs_mem->dev);\n\tput_device(&rmtfs_mem->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_rmtfs_mem_of_match[] = {\n\t{ .compatible = \"qcom,rmtfs-mem\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_rmtfs_mem_of_match);\n\nstatic struct platform_driver qcom_rmtfs_mem_driver = {\n\t.probe = qcom_rmtfs_mem_probe,\n\t.remove = qcom_rmtfs_mem_remove,\n\t.driver  = {\n\t\t.name  = \"qcom_rmtfs_mem\",\n\t\t.of_match_table = qcom_rmtfs_mem_of_match,\n\t},\n};\n\nstatic int __init qcom_rmtfs_mem_init(void)\n{\n\tint ret;\n\n\tret = class_register(&rmtfs_class);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_chrdev_region(&qcom_rmtfs_mem_major, 0,\n\t\t\t\t  QCOM_RMTFS_MEM_DEV_MAX, \"qcom_rmtfs_mem\");\n\tif (ret < 0) {\n\t\tpr_err(\"qcom_rmtfs_mem: failed to allocate char dev region\\n\");\n\t\tgoto unregister_class;\n\t}\n\n\tret = platform_driver_register(&qcom_rmtfs_mem_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"qcom_rmtfs_mem: failed to register rmtfs_mem driver\\n\");\n\t\tgoto unregister_chrdev;\n\t}\n\n\treturn 0;\n\nunregister_chrdev:\n\tunregister_chrdev_region(qcom_rmtfs_mem_major, QCOM_RMTFS_MEM_DEV_MAX);\nunregister_class:\n\tclass_unregister(&rmtfs_class);\n\treturn ret;\n}\nmodule_init(qcom_rmtfs_mem_init);\n\nstatic void __exit qcom_rmtfs_mem_exit(void)\n{\n\tplatform_driver_unregister(&qcom_rmtfs_mem_driver);\n\tunregister_chrdev_region(qcom_rmtfs_mem_major, QCOM_RMTFS_MEM_DEV_MAX);\n\tclass_unregister(&rmtfs_class);\n}\nmodule_exit(qcom_rmtfs_mem_exit);\n\nMODULE_AUTHOR(\"Linaro Ltd\");\nMODULE_DESCRIPTION(\"Qualcomm Remote Filesystem memory driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}