{
  "module_name": "apr.c",
  "hash_id": "3852a9e15c0017077ddebf3e79e2a794840143b79700098589d4281240aacecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/apr.c",
  "human_readable_source": "\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/of_device.h>\n#include <linux/soc/qcom/apr.h>\n#include <linux/soc/qcom/pdr.h>\n#include <linux/rpmsg.h>\n#include <linux/of.h>\n\nenum {\n\tPR_TYPE_APR = 0,\n\tPR_TYPE_GPR,\n};\n\n \n#define GPR_DYNAMIC_PORT_START\t0x10000000\n#define GPR_DYNAMIC_PORT_END\t0x20000000\n\nstruct packet_router {\n\tstruct rpmsg_endpoint *ch;\n\tstruct device *dev;\n\tspinlock_t svcs_lock;\n\tspinlock_t rx_lock;\n\tstruct idr svcs_idr;\n\tint dest_domain_id;\n\tint type;\n\tstruct pdr_handle *pdr;\n\tstruct workqueue_struct *rxwq;\n\tstruct work_struct rx_work;\n\tstruct list_head rx_list;\n};\n\nstruct apr_rx_buf {\n\tstruct list_head node;\n\tint len;\n\tuint8_t buf[];\n};\n\n \nint apr_send_pkt(struct apr_device *adev, struct apr_pkt *pkt)\n{\n\tstruct packet_router *apr = dev_get_drvdata(adev->dev.parent);\n\tstruct apr_hdr *hdr;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&adev->svc.lock, flags);\n\n\thdr = &pkt->hdr;\n\thdr->src_domain = APR_DOMAIN_APPS;\n\thdr->src_svc = adev->svc.id;\n\thdr->dest_domain = adev->domain_id;\n\thdr->dest_svc = adev->svc.id;\n\n\tret = rpmsg_trysend(apr->ch, pkt, hdr->pkt_size);\n\tspin_unlock_irqrestore(&adev->svc.lock, flags);\n\n\treturn ret ? ret : hdr->pkt_size;\n}\nEXPORT_SYMBOL_GPL(apr_send_pkt);\n\nvoid gpr_free_port(gpr_port_t *port)\n{\n\tstruct packet_router *gpr = port->pr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gpr->svcs_lock, flags);\n\tidr_remove(&gpr->svcs_idr, port->id);\n\tspin_unlock_irqrestore(&gpr->svcs_lock, flags);\n\n\tkfree(port);\n}\nEXPORT_SYMBOL_GPL(gpr_free_port);\n\ngpr_port_t *gpr_alloc_port(struct apr_device *gdev, struct device *dev,\n\t\t\t\tgpr_port_cb cb,\tvoid *priv)\n{\n\tstruct packet_router *pr = dev_get_drvdata(gdev->dev.parent);\n\tgpr_port_t *port;\n\tstruct pkt_router_svc *svc;\n\tint id;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsvc = port;\n\tsvc->callback = cb;\n\tsvc->pr = pr;\n\tsvc->priv = priv;\n\tsvc->dev = dev;\n\tspin_lock_init(&svc->lock);\n\n\tspin_lock(&pr->svcs_lock);\n\tid = idr_alloc_cyclic(&pr->svcs_idr, svc, GPR_DYNAMIC_PORT_START,\n\t\t\t      GPR_DYNAMIC_PORT_END, GFP_ATOMIC);\n\tif (id < 0) {\n\t\tdev_err(dev, \"Unable to allocate dynamic GPR src port\\n\");\n\t\tkfree(port);\n\t\tspin_unlock(&pr->svcs_lock);\n\t\treturn ERR_PTR(id);\n\t}\n\n\tsvc->id = id;\n\tspin_unlock(&pr->svcs_lock);\n\n\treturn port;\n}\nEXPORT_SYMBOL_GPL(gpr_alloc_port);\n\nstatic int pkt_router_send_svc_pkt(struct pkt_router_svc *svc, struct gpr_pkt *pkt)\n{\n\tstruct packet_router *pr = svc->pr;\n\tstruct gpr_hdr *hdr;\n\tunsigned long flags;\n\tint ret;\n\n\thdr = &pkt->hdr;\n\n\tspin_lock_irqsave(&svc->lock, flags);\n\tret = rpmsg_trysend(pr->ch, pkt, hdr->pkt_size);\n\tspin_unlock_irqrestore(&svc->lock, flags);\n\n\treturn ret ? ret : hdr->pkt_size;\n}\n\nint gpr_send_pkt(struct apr_device *gdev, struct gpr_pkt *pkt)\n{\n\treturn pkt_router_send_svc_pkt(&gdev->svc, pkt);\n}\nEXPORT_SYMBOL_GPL(gpr_send_pkt);\n\nint gpr_send_port_pkt(gpr_port_t *port, struct gpr_pkt *pkt)\n{\n\treturn pkt_router_send_svc_pkt(port, pkt);\n}\nEXPORT_SYMBOL_GPL(gpr_send_port_pkt);\n\nstatic void apr_dev_release(struct device *dev)\n{\n\tstruct apr_device *adev = to_apr_device(dev);\n\n\tkfree(adev);\n}\n\nstatic int apr_callback(struct rpmsg_device *rpdev, void *buf,\n\t\t\t\t  int len, void *priv, u32 addr)\n{\n\tstruct packet_router *apr = dev_get_drvdata(&rpdev->dev);\n\tstruct apr_rx_buf *abuf;\n\tunsigned long flags;\n\n\tif (len <= APR_HDR_SIZE) {\n\t\tdev_err(apr->dev, \"APR: Improper apr pkt received:%p %d\\n\",\n\t\t\tbuf, len);\n\t\treturn -EINVAL;\n\t}\n\n\tabuf = kzalloc(sizeof(*abuf) + len, GFP_ATOMIC);\n\tif (!abuf)\n\t\treturn -ENOMEM;\n\n\tabuf->len = len;\n\tmemcpy(abuf->buf, buf, len);\n\n\tspin_lock_irqsave(&apr->rx_lock, flags);\n\tlist_add_tail(&abuf->node, &apr->rx_list);\n\tspin_unlock_irqrestore(&apr->rx_lock, flags);\n\n\tqueue_work(apr->rxwq, &apr->rx_work);\n\n\treturn 0;\n}\n\nstatic int apr_do_rx_callback(struct packet_router *apr, struct apr_rx_buf *abuf)\n{\n\tuint16_t hdr_size, msg_type, ver, svc_id;\n\tstruct pkt_router_svc *svc;\n\tstruct apr_device *adev;\n\tstruct apr_driver *adrv = NULL;\n\tstruct apr_resp_pkt resp;\n\tstruct apr_hdr *hdr;\n\tunsigned long flags;\n\tvoid *buf = abuf->buf;\n\tint len = abuf->len;\n\n\thdr = buf;\n\tver = APR_HDR_FIELD_VER(hdr->hdr_field);\n\tif (ver > APR_PKT_VER + 1)\n\t\treturn -EINVAL;\n\n\thdr_size = APR_HDR_FIELD_SIZE_BYTES(hdr->hdr_field);\n\tif (hdr_size < APR_HDR_SIZE) {\n\t\tdev_err(apr->dev, \"APR: Wrong hdr size:%d\\n\", hdr_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->pkt_size < APR_HDR_SIZE || hdr->pkt_size != len) {\n\t\tdev_err(apr->dev, \"APR: Wrong packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_type = APR_HDR_FIELD_MT(hdr->hdr_field);\n\tif (msg_type >= APR_MSG_TYPE_MAX) {\n\t\tdev_err(apr->dev, \"APR: Wrong message type: %d\\n\", msg_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->src_domain >= APR_DOMAIN_MAX ||\n\t\t\thdr->dest_domain >= APR_DOMAIN_MAX ||\n\t\t\thdr->src_svc >= APR_SVC_MAX ||\n\t\t\thdr->dest_svc >= APR_SVC_MAX) {\n\t\tdev_err(apr->dev, \"APR: Wrong APR header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsvc_id = hdr->dest_svc;\n\tspin_lock_irqsave(&apr->svcs_lock, flags);\n\tsvc = idr_find(&apr->svcs_idr, svc_id);\n\tif (svc && svc->dev->driver) {\n\t\tadev = svc_to_apr_device(svc);\n\t\tadrv = to_apr_driver(adev->dev.driver);\n\t}\n\tspin_unlock_irqrestore(&apr->svcs_lock, flags);\n\n\tif (!adrv || !adev) {\n\t\tdev_err(apr->dev, \"APR: service is not registered (%d)\\n\",\n\t\t\tsvc_id);\n\t\treturn -EINVAL;\n\t}\n\n\tresp.hdr = *hdr;\n\tresp.payload_size = hdr->pkt_size - hdr_size;\n\n\t \n\tif (resp.payload_size > 0)\n\t\tresp.payload = buf + hdr_size;\n\n\tadrv->callback(adev, &resp);\n\n\treturn 0;\n}\n\nstatic int gpr_do_rx_callback(struct packet_router *gpr, struct apr_rx_buf *abuf)\n{\n\tuint16_t hdr_size, ver;\n\tstruct pkt_router_svc *svc = NULL;\n\tstruct gpr_resp_pkt resp;\n\tstruct gpr_hdr *hdr;\n\tunsigned long flags;\n\tvoid *buf = abuf->buf;\n\tint len = abuf->len;\n\n\thdr = buf;\n\tver = hdr->version;\n\tif (ver > GPR_PKT_VER + 1)\n\t\treturn -EINVAL;\n\n\thdr_size = hdr->hdr_size;\n\tif (hdr_size < GPR_PKT_HEADER_WORD_SIZE) {\n\t\tdev_err(gpr->dev, \"GPR: Wrong hdr size:%d\\n\", hdr_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->pkt_size < GPR_PKT_HEADER_BYTE_SIZE || hdr->pkt_size != len) {\n\t\tdev_err(gpr->dev, \"GPR: Wrong packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tresp.hdr = *hdr;\n\tresp.payload_size = hdr->pkt_size - (hdr_size * 4);\n\n\t \n\tif (resp.payload_size > 0)\n\t\tresp.payload = buf + (hdr_size *  4);\n\n\n\tspin_lock_irqsave(&gpr->svcs_lock, flags);\n\tsvc = idr_find(&gpr->svcs_idr, hdr->dest_port);\n\tspin_unlock_irqrestore(&gpr->svcs_lock, flags);\n\n\tif (!svc) {\n\t\tdev_err(gpr->dev, \"GPR: Port(%x) is not registered\\n\",\n\t\t\thdr->dest_port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (svc->callback)\n\t\tsvc->callback(&resp, svc->priv, 0);\n\n\treturn 0;\n}\n\nstatic void apr_rxwq(struct work_struct *work)\n{\n\tstruct packet_router *apr = container_of(work, struct packet_router, rx_work);\n\tstruct apr_rx_buf *abuf, *b;\n\tunsigned long flags;\n\n\tif (!list_empty(&apr->rx_list)) {\n\t\tlist_for_each_entry_safe(abuf, b, &apr->rx_list, node) {\n\t\t\tswitch (apr->type) {\n\t\t\tcase PR_TYPE_APR:\n\t\t\t\tapr_do_rx_callback(apr, abuf);\n\t\t\t\tbreak;\n\t\t\tcase PR_TYPE_GPR:\n\t\t\t\tgpr_do_rx_callback(apr, abuf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&apr->rx_lock, flags);\n\t\t\tlist_del(&abuf->node);\n\t\t\tspin_unlock_irqrestore(&apr->rx_lock, flags);\n\t\t\tkfree(abuf);\n\t\t}\n\t}\n}\n\nstatic int apr_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct apr_device *adev = to_apr_device(dev);\n\tstruct apr_driver *adrv = to_apr_driver(drv);\n\tconst struct apr_device_id *id = adrv->id_table;\n\n\t \n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (!id)\n\t\treturn 0;\n\n\twhile (id->domain_id != 0 || id->svc_id != 0) {\n\t\tif (id->domain_id == adev->domain_id &&\n\t\t    id->svc_id == adev->svc.id)\n\t\t\treturn 1;\n\t\tid++;\n\t}\n\n\treturn 0;\n}\n\nstatic int apr_device_probe(struct device *dev)\n{\n\tstruct apr_device *adev = to_apr_device(dev);\n\tstruct apr_driver *adrv = to_apr_driver(dev->driver);\n\tint ret;\n\n\tret = adrv->probe(adev);\n\tif (!ret)\n\t\tadev->svc.callback = adrv->gpr_callback;\n\n\treturn ret;\n}\n\nstatic void apr_device_remove(struct device *dev)\n{\n\tstruct apr_device *adev = to_apr_device(dev);\n\tstruct apr_driver *adrv = to_apr_driver(dev->driver);\n\tstruct packet_router *apr = dev_get_drvdata(adev->dev.parent);\n\n\tif (adrv->remove)\n\t\tadrv->remove(adev);\n\tspin_lock(&apr->svcs_lock);\n\tidr_remove(&apr->svcs_idr, adev->svc.id);\n\tspin_unlock(&apr->svcs_lock);\n}\n\nstatic int apr_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct apr_device *adev = to_apr_device(dev);\n\tint ret;\n\n\tret = of_device_uevent_modalias(dev, env);\n\tif (ret != -ENODEV)\n\t\treturn ret;\n\n\treturn add_uevent_var(env, \"MODALIAS=apr:%s\", adev->name);\n}\n\nstruct bus_type aprbus = {\n\t.name\t\t= \"aprbus\",\n\t.match\t\t= apr_device_match,\n\t.probe\t\t= apr_device_probe,\n\t.uevent\t\t= apr_uevent,\n\t.remove\t\t= apr_device_remove,\n};\nEXPORT_SYMBOL_GPL(aprbus);\n\nstatic int apr_add_device(struct device *dev, struct device_node *np,\n\t\t\t  u32 svc_id, u32 domain_id)\n{\n\tstruct packet_router *apr = dev_get_drvdata(dev);\n\tstruct apr_device *adev = NULL;\n\tstruct pkt_router_svc *svc;\n\tint ret;\n\n\tadev = kzalloc(sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\treturn -ENOMEM;\n\n\tadev->svc_id = svc_id;\n\tsvc = &adev->svc;\n\n\tsvc->id = svc_id;\n\tsvc->pr = apr;\n\tsvc->priv = adev;\n\tsvc->dev = dev;\n\tspin_lock_init(&svc->lock);\n\n\tadev->domain_id = domain_id;\n\n\tif (np)\n\t\tsnprintf(adev->name, APR_NAME_SIZE, \"%pOFn\", np);\n\n\tswitch (apr->type) {\n\tcase PR_TYPE_APR:\n\t\tdev_set_name(&adev->dev, \"aprsvc:%s:%x:%x\", adev->name,\n\t\t\t     domain_id, svc_id);\n\t\tbreak;\n\tcase PR_TYPE_GPR:\n\t\tdev_set_name(&adev->dev, \"gprsvc:%s:%x:%x\", adev->name,\n\t\t\t     domain_id, svc_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tadev->dev.bus = &aprbus;\n\tadev->dev.parent = dev;\n\tadev->dev.of_node = np;\n\tadev->dev.release = apr_dev_release;\n\tadev->dev.driver = NULL;\n\n\tspin_lock(&apr->svcs_lock);\n\tret = idr_alloc(&apr->svcs_idr, svc, svc_id, svc_id + 1, GFP_ATOMIC);\n\tspin_unlock(&apr->svcs_lock);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"idr_alloc failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = of_property_read_string_index(np, \"qcom,protection-domain\",\n\t\t\t\t\t    1, &adev->service_path);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(dev, \"Failed to read second value of qcom,protection-domain\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_info(dev, \"Adding APR/GPR dev: %s\\n\", dev_name(&adev->dev));\n\n\tret = device_register(&adev->dev);\n\tif (ret) {\n\t\tdev_err(dev, \"device_register failed: %d\\n\", ret);\n\t\tput_device(&adev->dev);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int of_apr_add_pd_lookups(struct device *dev)\n{\n\tconst char *service_name, *service_path;\n\tstruct packet_router *apr = dev_get_drvdata(dev);\n\tstruct device_node *node;\n\tstruct pdr_service *pds;\n\tint ret;\n\n\tfor_each_child_of_node(dev->of_node, node) {\n\t\tret = of_property_read_string_index(node, \"qcom,protection-domain\",\n\t\t\t\t\t\t    0, &service_name);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = of_property_read_string_index(node, \"qcom,protection-domain\",\n\t\t\t\t\t\t    1, &service_path);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"pdr service path missing: %d\\n\", ret);\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpds = pdr_add_lookup(apr->pdr, service_name, service_path);\n\t\tif (IS_ERR(pds) && PTR_ERR(pds) != -EALREADY) {\n\t\t\tdev_err(dev, \"pdr add lookup failed: %ld\\n\", PTR_ERR(pds));\n\t\t\tof_node_put(node);\n\t\t\treturn PTR_ERR(pds);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void of_register_apr_devices(struct device *dev, const char *svc_path)\n{\n\tstruct packet_router *apr = dev_get_drvdata(dev);\n\tstruct device_node *node;\n\tconst char *service_path;\n\tint ret;\n\n\tfor_each_child_of_node(dev->of_node, node) {\n\t\tu32 svc_id;\n\t\tu32 domain_id;\n\n\t\t \n\n\t\tret = of_property_read_string_index(node, \"qcom,protection-domain\",\n\t\t\t\t\t\t    1, &service_path);\n\t\tif (svc_path) {\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (strcmp(service_path, svc_path))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_property_read_u32(node, \"reg\", &svc_id))\n\t\t\tcontinue;\n\n\t\tdomain_id = apr->dest_domain_id;\n\n\t\tif (apr_add_device(dev, node, svc_id, domain_id))\n\t\t\tdev_err(dev, \"Failed to add apr %d svc\\n\", svc_id);\n\t}\n}\n\nstatic int apr_remove_device(struct device *dev, void *svc_path)\n{\n\tstruct apr_device *adev = to_apr_device(dev);\n\n\tif (svc_path && adev->service_path) {\n\t\tif (!strcmp(adev->service_path, (char *)svc_path))\n\t\t\tdevice_unregister(&adev->dev);\n\t} else {\n\t\tdevice_unregister(&adev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void apr_pd_status(int state, char *svc_path, void *priv)\n{\n\tstruct packet_router *apr = (struct packet_router *)priv;\n\n\tswitch (state) {\n\tcase SERVREG_SERVICE_STATE_UP:\n\t\tof_register_apr_devices(apr->dev, svc_path);\n\t\tbreak;\n\tcase SERVREG_SERVICE_STATE_DOWN:\n\t\tdevice_for_each_child(apr->dev, svc_path, apr_remove_device);\n\t\tbreak;\n\t}\n}\n\nstatic int apr_probe(struct rpmsg_device *rpdev)\n{\n\tstruct device *dev = &rpdev->dev;\n\tstruct packet_router *apr;\n\tint ret;\n\n\tapr = devm_kzalloc(dev, sizeof(*apr), GFP_KERNEL);\n\tif (!apr)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(dev->of_node, \"qcom,domain\", &apr->dest_domain_id);\n\n\tif (of_device_is_compatible(dev->of_node, \"qcom,gpr\")) {\n\t\tapr->type = PR_TYPE_GPR;\n\t} else {\n\t\tif (ret)  \n\t\t\tret = of_property_read_u32(dev->of_node, \"qcom,apr-domain\",\n\t\t\t\t\t\t   &apr->dest_domain_id);\n\t\tapr->type = PR_TYPE_APR;\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"Domain ID not specified in DT\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, apr);\n\tapr->ch = rpdev->ept;\n\tapr->dev = dev;\n\tapr->rxwq = create_singlethread_workqueue(\"qcom_apr_rx\");\n\tif (!apr->rxwq) {\n\t\tdev_err(apr->dev, \"Failed to start Rx WQ\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_WORK(&apr->rx_work, apr_rxwq);\n\n\tapr->pdr = pdr_handle_alloc(apr_pd_status, apr);\n\tif (IS_ERR(apr->pdr)) {\n\t\tdev_err(dev, \"Failed to init PDR handle\\n\");\n\t\tret = PTR_ERR(apr->pdr);\n\t\tgoto destroy_wq;\n\t}\n\n\tINIT_LIST_HEAD(&apr->rx_list);\n\tspin_lock_init(&apr->rx_lock);\n\tspin_lock_init(&apr->svcs_lock);\n\tidr_init(&apr->svcs_idr);\n\n\tret = of_apr_add_pd_lookups(dev);\n\tif (ret)\n\t\tgoto handle_release;\n\n\tof_register_apr_devices(dev, NULL);\n\n\treturn 0;\n\nhandle_release:\n\tpdr_handle_release(apr->pdr);\ndestroy_wq:\n\tdestroy_workqueue(apr->rxwq);\n\treturn ret;\n}\n\nstatic void apr_remove(struct rpmsg_device *rpdev)\n{\n\tstruct packet_router *apr = dev_get_drvdata(&rpdev->dev);\n\n\tpdr_handle_release(apr->pdr);\n\tdevice_for_each_child(&rpdev->dev, NULL, apr_remove_device);\n\tdestroy_workqueue(apr->rxwq);\n}\n\n \nint __apr_driver_register(struct apr_driver *drv, struct module *owner)\n{\n\tdrv->driver.bus = &aprbus;\n\tdrv->driver.owner = owner;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__apr_driver_register);\n\n \nvoid apr_driver_unregister(struct apr_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(apr_driver_unregister);\n\nstatic const struct of_device_id pkt_router_of_match[] = {\n\t{ .compatible = \"qcom,apr\"},\n\t{ .compatible = \"qcom,apr-v2\"},\n\t{ .compatible = \"qcom,gpr\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pkt_router_of_match);\n\nstatic struct rpmsg_driver packet_router_driver = {\n\t.probe = apr_probe,\n\t.remove = apr_remove,\n\t.callback = apr_callback,\n\t.drv = {\n\t\t.name = \"qcom,apr\",\n\t\t.of_match_table = pkt_router_of_match,\n\t},\n};\n\nstatic int __init apr_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&aprbus);\n\tif (!ret)\n\t\tret = register_rpmsg_driver(&packet_router_driver);\n\telse\n\t\tbus_unregister(&aprbus);\n\n\treturn ret;\n}\n\nstatic void __exit apr_exit(void)\n{\n\tbus_unregister(&aprbus);\n\tunregister_rpmsg_driver(&packet_router_driver);\n}\n\nsubsys_initcall(apr_init);\nmodule_exit(apr_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm APR Bus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}