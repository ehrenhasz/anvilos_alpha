{
  "module_name": "smem_state.c",
  "hash_id": "dfcc1744a9b0dd39903ab1978705dbc17af3edc7596962442c99d4093417a67f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/smem_state.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/smem_state.h>\n\nstatic LIST_HEAD(smem_states);\nstatic DEFINE_MUTEX(list_lock);\n\n \nstruct qcom_smem_state {\n\tstruct kref refcount;\n\tbool orphan;\n\n\tstruct list_head list;\n\tstruct device_node *of_node;\n\n\tvoid *priv;\n\n\tstruct qcom_smem_state_ops ops;\n};\n\n \nint qcom_smem_state_update_bits(struct qcom_smem_state *state,\n\t\t\t\tu32 mask,\n\t\t\t\tu32 value)\n{\n\tif (state->orphan)\n\t\treturn -ENXIO;\n\n\tif (!state->ops.update_bits)\n\t\treturn -ENOTSUPP;\n\n\treturn state->ops.update_bits(state->priv, mask, value);\n}\nEXPORT_SYMBOL_GPL(qcom_smem_state_update_bits);\n\nstatic struct qcom_smem_state *of_node_to_state(struct device_node *np)\n{\n\tstruct qcom_smem_state *state;\n\n\tmutex_lock(&list_lock);\n\n\tlist_for_each_entry(state, &smem_states, list) {\n\t\tif (state->of_node == np) {\n\t\t\tkref_get(&state->refcount);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tstate = ERR_PTR(-EPROBE_DEFER);\n\nunlock:\n\tmutex_unlock(&list_lock);\n\n\treturn state;\n}\n\n \nstruct qcom_smem_state *qcom_smem_state_get(struct device *dev,\n\t\t\t\t\t    const char *con_id,\n\t\t\t\t\t    unsigned *bit)\n{\n\tstruct qcom_smem_state *state;\n\tstruct of_phandle_args args;\n\tint index = 0;\n\tint ret;\n\n\tif (con_id) {\n\t\tindex = of_property_match_string(dev->of_node,\n\t\t\t\t\t\t \"qcom,smem-state-names\",\n\t\t\t\t\t\t con_id);\n\t\tif (index < 0) {\n\t\t\tdev_err(dev, \"missing qcom,smem-state-names\\n\");\n\t\t\treturn ERR_PTR(index);\n\t\t}\n\t}\n\n\tret = of_parse_phandle_with_args(dev->of_node,\n\t\t\t\t\t \"qcom,smem-states\",\n\t\t\t\t\t \"#qcom,smem-state-cells\",\n\t\t\t\t\t index,\n\t\t\t\t\t &args);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse qcom,smem-states property\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (args.args_count != 1) {\n\t\tdev_err(dev, \"invalid #qcom,smem-state-cells\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tstate = of_node_to_state(args.np);\n\tif (IS_ERR(state))\n\t\tgoto put;\n\n\t*bit = args.args[0];\n\nput:\n\tof_node_put(args.np);\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(qcom_smem_state_get);\n\nstatic void qcom_smem_state_release(struct kref *ref)\n{\n\tstruct qcom_smem_state *state = container_of(ref, struct qcom_smem_state, refcount);\n\n\tlist_del(&state->list);\n\tof_node_put(state->of_node);\n\tkfree(state);\n}\n\n \nvoid qcom_smem_state_put(struct qcom_smem_state *state)\n{\n\tmutex_lock(&list_lock);\n\tkref_put(&state->refcount, qcom_smem_state_release);\n\tmutex_unlock(&list_lock);\n}\nEXPORT_SYMBOL_GPL(qcom_smem_state_put);\n\nstatic void devm_qcom_smem_state_release(struct device *dev, void *res)\n{\n\tqcom_smem_state_put(*(struct qcom_smem_state **)res);\n}\n\n \nstruct qcom_smem_state *devm_qcom_smem_state_get(struct device *dev,\n\t\t\t\t\t\t const char *con_id,\n\t\t\t\t\t\t unsigned *bit)\n{\n\tstruct qcom_smem_state **ptr, *state;\n\n\tptr = devres_alloc(devm_qcom_smem_state_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate = qcom_smem_state_get(dev, con_id, bit);\n\tif (!IS_ERR(state)) {\n\t\t*ptr = state;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(devm_qcom_smem_state_get);\n\n \nstruct qcom_smem_state *qcom_smem_state_register(struct device_node *of_node,\n\t\t\t\t\t\t const struct qcom_smem_state_ops *ops,\n\t\t\t\t\t\t void *priv)\n{\n\tstruct qcom_smem_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&state->refcount);\n\n\tstate->of_node = of_node_get(of_node);\n\tstate->ops = *ops;\n\tstate->priv = priv;\n\n\tmutex_lock(&list_lock);\n\tlist_add(&state->list, &smem_states);\n\tmutex_unlock(&list_lock);\n\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(qcom_smem_state_register);\n\n \nvoid qcom_smem_state_unregister(struct qcom_smem_state *state)\n{\n\tstate->orphan = true;\n\tqcom_smem_state_put(state);\n}\nEXPORT_SYMBOL_GPL(qcom_smem_state_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}