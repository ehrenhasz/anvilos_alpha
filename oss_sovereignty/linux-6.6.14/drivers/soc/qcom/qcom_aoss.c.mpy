{
  "module_name": "qcom_aoss.c",
  "hash_id": "4849fe2ca63c31725ed08b40d34fa1e57888166544cabb359c512db6488de5ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qcom_aoss.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/qcom_aoss.h>\n\n#define QMP_DESC_MAGIC\t\t\t0x0\n#define QMP_DESC_VERSION\t\t0x4\n#define QMP_DESC_FEATURES\t\t0x8\n\n \n#define QMP_DESC_UCORE_LINK_STATE\t0xc\n#define QMP_DESC_UCORE_LINK_STATE_ACK\t0x10\n#define QMP_DESC_UCORE_CH_STATE\t\t0x14\n#define QMP_DESC_UCORE_CH_STATE_ACK\t0x18\n#define QMP_DESC_UCORE_MBOX_SIZE\t0x1c\n#define QMP_DESC_UCORE_MBOX_OFFSET\t0x20\n\n \n#define QMP_DESC_MCORE_LINK_STATE\t0x24\n#define QMP_DESC_MCORE_LINK_STATE_ACK\t0x28\n#define QMP_DESC_MCORE_CH_STATE\t\t0x2c\n#define QMP_DESC_MCORE_CH_STATE_ACK\t0x30\n#define QMP_DESC_MCORE_MBOX_SIZE\t0x34\n#define QMP_DESC_MCORE_MBOX_OFFSET\t0x38\n\n#define QMP_STATE_UP\t\t\tGENMASK(15, 0)\n#define QMP_STATE_DOWN\t\t\tGENMASK(31, 16)\n\n#define QMP_MAGIC\t\t\t0x4d41494c  \n#define QMP_VERSION\t\t\t1\n\n \n#define QMP_MSG_LEN\t\t\t64\n\n#define QMP_NUM_COOLING_RESOURCES\t2\n\nstatic bool qmp_cdev_max_state = 1;\n\nstruct qmp_cooling_device {\n\tstruct thermal_cooling_device *cdev;\n\tstruct qmp *qmp;\n\tchar *name;\n\tbool state;\n};\n\n \nstruct qmp {\n\tvoid __iomem *msgram;\n\tstruct device *dev;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tsize_t offset;\n\tsize_t size;\n\n\twait_queue_head_t event;\n\n\tstruct mutex tx_lock;\n\n\tstruct clk_hw qdss_clk;\n\tstruct qmp_cooling_device *cooling_devs;\n};\n\nstatic void qmp_kick(struct qmp *qmp)\n{\n\tmbox_send_message(qmp->mbox_chan, NULL);\n\tmbox_client_txdone(qmp->mbox_chan, 0);\n}\n\nstatic bool qmp_magic_valid(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MAGIC) == QMP_MAGIC;\n}\n\nstatic bool qmp_link_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_LINK_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_mcore_channel_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_CH_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_ucore_channel_up(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_UCORE_CH_STATE) == QMP_STATE_UP;\n}\n\nstatic int qmp_open(struct qmp *qmp)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!qmp_magic_valid(qmp)) {\n\t\tdev_err(qmp->dev, \"QMP magic doesn't match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(qmp->msgram + QMP_DESC_VERSION);\n\tif (val != QMP_VERSION) {\n\t\tdev_err(qmp->dev, \"unsupported QMP version %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tqmp->offset = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_OFFSET);\n\tqmp->size = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_SIZE);\n\tif (!qmp->size) {\n\t\tdev_err(qmp->dev, \"invalid mailbox size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = readl(qmp->msgram + QMP_DESC_UCORE_LINK_STATE);\n\twritel(val, qmp->msgram + QMP_DESC_UCORE_LINK_STATE_ACK);\n\n\t \n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_link_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack link\\n\");\n\t\tgoto timeout_close_link;\n\t}\n\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_ucore_channel_up(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't open channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\t \n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_UCORE_CH_STATE_ACK);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_mcore_channel_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\treturn 0;\n\ntimeout_close_channel:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\ntimeout_close_link:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void qmp_close(struct qmp *qmp)\n{\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n}\n\nstatic irqreturn_t qmp_intr(int irq, void *data)\n{\n\tstruct qmp *qmp = data;\n\n\twake_up_all(&qmp->event);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool qmp_message_empty(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + qmp->offset) == 0;\n}\n\n \nint qmp_send(struct qmp *qmp, const char *fmt, ...)\n{\n\tchar buf[QMP_MSG_LEN];\n\tlong time_left;\n\tva_list args;\n\tint len;\n\tint ret;\n\n\tif (WARN_ON(IS_ERR_OR_NULL(qmp) || !fmt))\n\t\treturn -EINVAL;\n\n\tmemset(buf, 0, sizeof(buf));\n\tva_start(args, fmt);\n\tlen = vsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (WARN_ON(len >= sizeof(buf)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&qmp->tx_lock);\n\n\t \n\t__iowrite32_copy(qmp->msgram + qmp->offset + sizeof(u32),\n\t\t\t buf, sizeof(buf) / sizeof(u32));\n\twritel(sizeof(buf), qmp->msgram + qmp->offset);\n\n\t \n\treadl(qmp->msgram + qmp->offset);\n\tqmp_kick(qmp);\n\n\ttime_left = wait_event_interruptible_timeout(qmp->event,\n\t\t\t\t\t\t     qmp_message_empty(qmp), HZ);\n\tif (!time_left) {\n\t\tdev_err(qmp->dev, \"ucore did not ack channel\\n\");\n\t\tret = -ETIMEDOUT;\n\n\t\t \n\t\twritel(0, qmp->msgram + qmp->offset);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&qmp->tx_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qmp_send);\n\nstatic int qmp_qdss_clk_prepare(struct clk_hw *hw)\n{\n\tstatic const char *buf = \"{class: clock, res: qdss, val: 1}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\treturn qmp_send(qmp, buf);\n}\n\nstatic void qmp_qdss_clk_unprepare(struct clk_hw *hw)\n{\n\tstatic const char *buf = \"{class: clock, res: qdss, val: 0}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\tqmp_send(qmp, buf);\n}\n\nstatic const struct clk_ops qmp_qdss_clk_ops = {\n\t.prepare = qmp_qdss_clk_prepare,\n\t.unprepare = qmp_qdss_clk_unprepare,\n};\n\nstatic int qmp_qdss_clk_add(struct qmp *qmp)\n{\n\tstatic const struct clk_init_data qdss_init = {\n\t\t.ops = &qmp_qdss_clk_ops,\n\t\t.name = \"qdss\",\n\t};\n\tint ret;\n\n\tqmp->qdss_clk.init = &qdss_init;\n\tret = clk_hw_register(qmp->dev, &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"failed to register qdss clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_clk_add_hw_provider(qmp->dev->of_node, of_clk_hw_simple_get,\n\t\t\t\t     &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"unable to register of clk hw provider\\n\");\n\t\tclk_hw_unregister(&qmp->qdss_clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void qmp_qdss_clk_remove(struct qmp *qmp)\n{\n\tof_clk_del_provider(qmp->dev->of_node);\n\tclk_hw_unregister(&qmp->qdss_clk);\n}\n\nstatic int qmp_cdev_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\t*state = qmp_cdev_max_state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\n\t*state = qmp_cdev->state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\tbool cdev_state;\n\tint ret;\n\n\t \n\tcdev_state = !!state;\n\n\tif (qmp_cdev->state == state)\n\t\treturn 0;\n\n\tret = qmp_send(qmp_cdev->qmp, \"{class: volt_flr, event:zero_temp, res:%s, value:%s}\",\n\t\t       qmp_cdev->name, cdev_state ? \"on\" : \"off\");\n\tif (!ret)\n\t\tqmp_cdev->state = cdev_state;\n\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops qmp_cooling_device_ops = {\n\t.get_max_state = qmp_cdev_get_max_state,\n\t.get_cur_state = qmp_cdev_get_cur_state,\n\t.set_cur_state = qmp_cdev_set_cur_state,\n};\n\nstatic int qmp_cooling_device_add(struct qmp *qmp,\n\t\t\t\t  struct qmp_cooling_device *qmp_cdev,\n\t\t\t\t  struct device_node *node)\n{\n\tchar *cdev_name = (char *)node->name;\n\n\tqmp_cdev->qmp = qmp;\n\tqmp_cdev->state = !qmp_cdev_max_state;\n\tqmp_cdev->name = cdev_name;\n\tqmp_cdev->cdev = devm_thermal_of_cooling_device_register\n\t\t\t\t(qmp->dev, node,\n\t\t\t\tcdev_name,\n\t\t\t\tqmp_cdev, &qmp_cooling_device_ops);\n\n\tif (IS_ERR(qmp_cdev->cdev))\n\t\tdev_err(qmp->dev, \"unable to register %s cooling device\\n\",\n\t\t\tcdev_name);\n\n\treturn PTR_ERR_OR_ZERO(qmp_cdev->cdev);\n}\n\nstatic int qmp_cooling_devices_register(struct qmp *qmp)\n{\n\tstruct device_node *np, *child;\n\tint count = 0;\n\tint ret;\n\n\tnp = qmp->dev->of_node;\n\n\tqmp->cooling_devs = devm_kcalloc(qmp->dev, QMP_NUM_COOLING_RESOURCES,\n\t\t\t\t\t sizeof(*qmp->cooling_devs),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!qmp->cooling_devs)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (!of_property_present(child, \"#cooling-cells\"))\n\t\t\tcontinue;\n\t\tret = qmp_cooling_device_add(qmp, &qmp->cooling_devs[count++],\n\t\t\t\t\t     child);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tgoto unroll;\n\t\t}\n\t}\n\n\tif (!count)\n\t\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn 0;\n\nunroll:\n\twhile (--count >= 0)\n\t\tthermal_cooling_device_unregister\n\t\t\t(qmp->cooling_devs[count].cdev);\n\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn ret;\n}\n\nstatic void qmp_cooling_devices_remove(struct qmp *qmp)\n{\n\tint i;\n\n\tfor (i = 0; i < QMP_NUM_COOLING_RESOURCES; i++)\n\t\tthermal_cooling_device_unregister(qmp->cooling_devs[i].cdev);\n}\n\n \nstruct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}\nEXPORT_SYMBOL(qmp_get);\n\n \nvoid qmp_put(struct qmp *qmp)\n{\n\t \n\tif (!IS_ERR_OR_NULL(qmp))\n\t\tput_device(qmp->dev);\n}\nEXPORT_SYMBOL(qmp_put);\n\nstatic int qmp_probe(struct platform_device *pdev)\n{\n\tstruct qmp *qmp;\n\tint irq;\n\tint ret;\n\n\tqmp = devm_kzalloc(&pdev->dev, sizeof(*qmp), GFP_KERNEL);\n\tif (!qmp)\n\t\treturn -ENOMEM;\n\n\tqmp->dev = &pdev->dev;\n\tinit_waitqueue_head(&qmp->event);\n\tmutex_init(&qmp->tx_lock);\n\n\tqmp->msgram = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qmp->msgram))\n\t\treturn PTR_ERR(qmp->msgram);\n\n\tqmp->mbox_client.dev = &pdev->dev;\n\tqmp->mbox_client.knows_txdone = true;\n\tqmp->mbox_chan = mbox_request_channel(&qmp->mbox_client, 0);\n\tif (IS_ERR(qmp->mbox_chan)) {\n\t\tdev_err(&pdev->dev, \"failed to acquire ipc mailbox\\n\");\n\t\treturn PTR_ERR(qmp->mbox_chan);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, qmp_intr, 0,\n\t\t\t       \"aoss-qmp\", qmp);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request interrupt\\n\");\n\t\tgoto err_free_mbox;\n\t}\n\n\tret = qmp_open(qmp);\n\tif (ret < 0)\n\t\tgoto err_free_mbox;\n\n\tret = qmp_qdss_clk_add(qmp);\n\tif (ret)\n\t\tgoto err_close_qmp;\n\n\tret = qmp_cooling_devices_register(qmp);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to register aoss cooling devices\\n\");\n\n\tplatform_set_drvdata(pdev, qmp);\n\n\treturn 0;\n\nerr_close_qmp:\n\tqmp_close(qmp);\nerr_free_mbox:\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn ret;\n}\n\nstatic int qmp_remove(struct platform_device *pdev)\n{\n\tstruct qmp *qmp = platform_get_drvdata(pdev);\n\n\tqmp_qdss_clk_remove(qmp);\n\tqmp_cooling_devices_remove(qmp);\n\n\tqmp_close(qmp);\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmp_dt_match[] = {\n\t{ .compatible = \"qcom,sc7180-aoss-qmp\", },\n\t{ .compatible = \"qcom,sc7280-aoss-qmp\", },\n\t{ .compatible = \"qcom,sdm845-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8150-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8250-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8350-aoss-qmp\", },\n\t{ .compatible = \"qcom,aoss-qmp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qmp_dt_match);\n\nstatic struct platform_driver qmp_driver = {\n\t.driver = {\n\t\t.name\t\t= \"qcom_aoss_qmp\",\n\t\t.of_match_table\t= qmp_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = qmp_probe,\n\t.remove\t= qmp_remove,\n};\nmodule_platform_driver(qmp_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm AOSS QMP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}