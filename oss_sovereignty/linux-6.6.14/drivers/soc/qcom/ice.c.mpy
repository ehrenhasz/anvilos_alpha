{
  "module_name": "ice.c",
  "hash_id": "05958c8e9986445a3eb18678521a786336a0fd505e19d4ea22e82e70a3ab3009",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/ice.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <linux/firmware/qcom/qcom_scm.h>\n\n#include <soc/qcom/ice.h>\n\n#define AES_256_XTS_KEY_SIZE\t\t\t64\n\n \n#define QCOM_ICE_REG_VERSION\t\t\t0x0008\n#define QCOM_ICE_REG_FUSE_SETTING\t\t0x0010\n#define QCOM_ICE_REG_BIST_STATUS\t\t0x0070\n#define QCOM_ICE_REG_ADVANCED_CONTROL\t\t0x1000\n\n \n#define QCOM_ICE_BIST_STATUS_MASK\t\tGENMASK(31, 28)\n\n#define QCOM_ICE_FUSE_SETTING_MASK\t\t0x1\n#define QCOM_ICE_FORCE_HW_KEY0_SETTING_MASK\t0x2\n#define QCOM_ICE_FORCE_HW_KEY1_SETTING_MASK\t0x4\n\n#define qcom_ice_writel(engine, val, reg)\t\\\n\twritel((val), (engine)->base + (reg))\n\n#define qcom_ice_readl(engine, reg)\t\\\n\treadl((engine)->base + (reg))\n\nstruct qcom_ice {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct device_link *link;\n\n\tstruct clk *core_clk;\n};\n\nstatic bool qcom_ice_check_supported(struct qcom_ice *ice)\n{\n\tu32 regval = qcom_ice_readl(ice, QCOM_ICE_REG_VERSION);\n\tstruct device *dev = ice->dev;\n\tint major = FIELD_GET(GENMASK(31, 24), regval);\n\tint minor = FIELD_GET(GENMASK(23, 16), regval);\n\tint step = FIELD_GET(GENMASK(15, 0), regval);\n\n\t \n\tif (major != 3 && major != 4) {\n\t\tdev_warn(dev, \"Unsupported ICE version: v%d.%d.%d\\n\",\n\t\t\t major, minor, step);\n\t\treturn false;\n\t}\n\n\tdev_info(dev, \"Found QC Inline Crypto Engine (ICE) v%d.%d.%d\\n\",\n\t\t major, minor, step);\n\n\t \n\tregval = qcom_ice_readl(ice, QCOM_ICE_REG_FUSE_SETTING);\n\tif (regval & (QCOM_ICE_FUSE_SETTING_MASK |\n\t\t      QCOM_ICE_FORCE_HW_KEY0_SETTING_MASK |\n\t\t      QCOM_ICE_FORCE_HW_KEY1_SETTING_MASK)) {\n\t\tdev_warn(dev, \"Fuses are blown; ICE is unusable!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void qcom_ice_low_power_mode_enable(struct qcom_ice *ice)\n{\n\tu32 regval;\n\n\tregval = qcom_ice_readl(ice, QCOM_ICE_REG_ADVANCED_CONTROL);\n\n\t \n\tregval |= 0x7000;\n\tqcom_ice_writel(ice, regval, QCOM_ICE_REG_ADVANCED_CONTROL);\n}\n\nstatic void qcom_ice_optimization_enable(struct qcom_ice *ice)\n{\n\tu32 regval;\n\n\t \n\tregval = qcom_ice_readl(ice, QCOM_ICE_REG_ADVANCED_CONTROL);\n\tregval |= 0xd807100;\n\t \n\tudelay(5);\n\tqcom_ice_writel(ice, regval, QCOM_ICE_REG_ADVANCED_CONTROL);\n\tudelay(5);\n}\n\n \nstatic int qcom_ice_wait_bist_status(struct qcom_ice *ice)\n{\n\tu32 regval;\n\tint err;\n\n\terr = readl_poll_timeout(ice->base + QCOM_ICE_REG_BIST_STATUS,\n\t\t\t\t regval, !(regval & QCOM_ICE_BIST_STATUS_MASK),\n\t\t\t\t 50, 5000);\n\tif (err)\n\t\tdev_err(ice->dev, \"Timed out waiting for ICE self-test to complete\\n\");\n\n\treturn err;\n}\n\nint qcom_ice_enable(struct qcom_ice *ice)\n{\n\tqcom_ice_low_power_mode_enable(ice);\n\tqcom_ice_optimization_enable(ice);\n\n\treturn qcom_ice_wait_bist_status(ice);\n}\nEXPORT_SYMBOL_GPL(qcom_ice_enable);\n\nint qcom_ice_resume(struct qcom_ice *ice)\n{\n\tstruct device *dev = ice->dev;\n\tint err;\n\n\terr = clk_prepare_enable(ice->core_clk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable core clock (%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn qcom_ice_wait_bist_status(ice);\n}\nEXPORT_SYMBOL_GPL(qcom_ice_resume);\n\nint qcom_ice_suspend(struct qcom_ice *ice)\n{\n\tclk_disable_unprepare(ice->core_clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_ice_suspend);\n\nint qcom_ice_program_key(struct qcom_ice *ice,\n\t\t\t u8 algorithm_id, u8 key_size,\n\t\t\t const u8 crypto_key[], u8 data_unit_size,\n\t\t\t int slot)\n{\n\tstruct device *dev = ice->dev;\n\tunion {\n\t\tu8 bytes[AES_256_XTS_KEY_SIZE];\n\t\tu32 words[AES_256_XTS_KEY_SIZE / sizeof(u32)];\n\t} key;\n\tint i;\n\tint err;\n\n\t \n\tif (algorithm_id != QCOM_ICE_CRYPTO_ALG_AES_XTS ||\n\t    key_size != QCOM_ICE_CRYPTO_KEY_SIZE_256) {\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"Unhandled crypto capability; algorithm_id=%d, key_size=%d\\n\",\n\t\t\t\t    algorithm_id, key_size);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(key.bytes, crypto_key, AES_256_XTS_KEY_SIZE);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(key.words); i++)\n\t\t__cpu_to_be32s(&key.words[i]);\n\n\terr = qcom_scm_ice_set_key(slot, key.bytes, AES_256_XTS_KEY_SIZE,\n\t\t\t\t   QCOM_SCM_ICE_CIPHER_AES_256_XTS,\n\t\t\t\t   data_unit_size);\n\n\tmemzero_explicit(&key, sizeof(key));\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(qcom_ice_program_key);\n\nint qcom_ice_evict_key(struct qcom_ice *ice, int slot)\n{\n\treturn qcom_scm_ice_invalidate_key(slot);\n}\nEXPORT_SYMBOL_GPL(qcom_ice_evict_key);\n\nstatic struct qcom_ice *qcom_ice_create(struct device *dev,\n\t\t\t\t\tvoid __iomem *base)\n{\n\tstruct qcom_ice *engine;\n\n\tif (!qcom_scm_is_available())\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tif (!qcom_scm_ice_available()) {\n\t\tdev_warn(dev, \"ICE SCM interface not found\\n\");\n\t\treturn NULL;\n\t}\n\n\tengine = devm_kzalloc(dev, sizeof(*engine), GFP_KERNEL);\n\tif (!engine)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tengine->dev = dev;\n\tengine->base = base;\n\n\t \n\tengine->core_clk = devm_clk_get_optional_enabled(dev, \"ice_core_clk\");\n\tif (!engine->core_clk)\n\t\tengine->core_clk = devm_clk_get_optional_enabled(dev, \"ice\");\n\tif (!engine->core_clk)\n\t\tengine->core_clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(engine->core_clk))\n\t\treturn ERR_CAST(engine->core_clk);\n\n\tif (!qcom_ice_check_supported(engine))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tdev_dbg(dev, \"Registered Qualcomm Inline Crypto Engine\\n\");\n\n\treturn engine;\n}\n\n \nstruct qcom_ice *of_qcom_ice_get(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct qcom_ice *ice;\n\tstruct device_node *node;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ice\");\n\tif (res) {\n\t\tbase = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(base))\n\t\t\treturn ERR_CAST(base);\n\n\t\t \n\t\treturn qcom_ice_create(&pdev->dev, base);\n\t}\n\n\t \n\tnode = of_parse_phandle(dev->of_node, \"qcom,ice\", 0);\n\tif (!node)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(node);\n\tif (!pdev) {\n\t\tdev_err(dev, \"Cannot find device node %s\\n\", node->name);\n\t\tice = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\n\n\tice = platform_get_drvdata(pdev);\n\tif (!ice) {\n\t\tdev_err(dev, \"Cannot get ice instance from %s\\n\",\n\t\t\tdev_name(&pdev->dev));\n\t\tplatform_device_put(pdev);\n\t\tice = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\n\n\tice->link = device_link_add(dev, &pdev->dev, DL_FLAG_AUTOREMOVE_SUPPLIER);\n\tif (!ice->link) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to create device link to consumer %s\\n\",\n\t\t\tdev_name(dev));\n\t\tplatform_device_put(pdev);\n\t\tice = ERR_PTR(-EINVAL);\n\t}\n\nout:\n\tof_node_put(node);\n\n\treturn ice;\n}\nEXPORT_SYMBOL_GPL(of_qcom_ice_get);\n\nstatic int qcom_ice_probe(struct platform_device *pdev)\n{\n\tstruct qcom_ice *engine;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_warn(&pdev->dev, \"ICE registers not found\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tengine = qcom_ice_create(&pdev->dev, base);\n\tif (IS_ERR(engine))\n\t\treturn PTR_ERR(engine);\n\n\tplatform_set_drvdata(pdev, engine);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_ice_of_match_table[] = {\n\t{ .compatible = \"qcom,inline-crypto-engine\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_ice_of_match_table);\n\nstatic struct platform_driver qcom_ice_driver = {\n\t.probe\t= qcom_ice_probe,\n\t.driver = {\n\t\t.name = \"qcom-ice\",\n\t\t.of_match_table = qcom_ice_of_match_table,\n\t},\n};\n\nmodule_platform_driver(qcom_ice_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Inline Crypto Engine driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}