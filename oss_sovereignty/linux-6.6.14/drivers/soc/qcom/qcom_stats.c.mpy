{
  "module_name": "qcom_stats.c",
  "hash_id": "3afe496a4adab126d2e17cf6fdb0ea292c7d7622811c013ee3f1f3a2b2c21f77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/qcom_stats.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <linux/soc/qcom/smem.h>\n#include <clocksource/arm_arch_timer.h>\n\n#define RPM_DYNAMIC_ADDR\t0x14\n#define RPM_DYNAMIC_ADDR_MASK\t0xFFFF\n\n#define STAT_TYPE_OFFSET\t0x0\n#define COUNT_OFFSET\t\t0x4\n#define LAST_ENTERED_AT_OFFSET\t0x8\n#define LAST_EXITED_AT_OFFSET\t0x10\n#define ACCUMULATED_OFFSET\t0x18\n#define CLIENT_VOTES_OFFSET\t0x20\n\nstruct subsystem_data {\n\tconst char *name;\n\tu32 smem_item;\n\tu32 pid;\n};\n\nstatic const struct subsystem_data subsystems[] = {\n\t{ \"modem\", 605, 1 },\n\t{ \"wpss\", 605, 13 },\n\t{ \"adsp\", 606, 2 },\n\t{ \"cdsp\", 607, 5 },\n\t{ \"slpi\", 608, 3 },\n\t{ \"gpu\", 609, 0 },\n\t{ \"display\", 610, 0 },\n\t{ \"adsp_island\", 613, 2 },\n\t{ \"slpi_island\", 613, 3 },\n};\n\nstruct stats_config {\n\tsize_t stats_offset;\n\tsize_t num_records;\n\tbool appended_stats_avail;\n\tbool dynamic_offset;\n\tbool subsystem_stats_in_smem;\n};\n\nstruct stats_data {\n\tbool appended_stats_avail;\n\tvoid __iomem *base;\n};\n\nstruct sleep_stats {\n\tu32 stat_type;\n\tu32 count;\n\tu64 last_entered_at;\n\tu64 last_exited_at;\n\tu64 accumulated;\n};\n\nstruct appended_stats {\n\tu32 client_votes;\n\tu32 reserved[3];\n};\n\nstatic void qcom_print_stats(struct seq_file *s, const struct sleep_stats *stat)\n{\n\tu64 accumulated = stat->accumulated;\n\t \n\tif (stat->last_entered_at > stat->last_exited_at)\n\t\taccumulated += arch_timer_read_counter() - stat->last_entered_at;\n\n\tseq_printf(s, \"Count: %u\\n\", stat->count);\n\tseq_printf(s, \"Last Entered At: %llu\\n\", stat->last_entered_at);\n\tseq_printf(s, \"Last Exited At: %llu\\n\", stat->last_exited_at);\n\tseq_printf(s, \"Accumulated Duration: %llu\\n\", accumulated);\n}\n\nstatic int qcom_subsystem_sleep_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct subsystem_data *subsystem = s->private;\n\tstruct sleep_stats *stat;\n\n\t \n\tstat = qcom_smem_get(subsystem->pid, subsystem->smem_item, NULL);\n\tif (IS_ERR(stat))\n\t\treturn 0;\n\n\tqcom_print_stats(s, stat);\n\n\treturn 0;\n}\n\nstatic int qcom_soc_sleep_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct stats_data *d = s->private;\n\tvoid __iomem *reg = d->base;\n\tstruct sleep_stats stat;\n\n\tmemcpy_fromio(&stat, reg, sizeof(stat));\n\tqcom_print_stats(s, &stat);\n\n\tif (d->appended_stats_avail) {\n\t\tstruct appended_stats votes;\n\n\t\tmemcpy_fromio(&votes, reg + CLIENT_VOTES_OFFSET, sizeof(votes));\n\t\tseq_printf(s, \"Client Votes: %#x\\n\", votes.client_votes);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qcom_soc_sleep_stats);\nDEFINE_SHOW_ATTRIBUTE(qcom_subsystem_sleep_stats);\n\nstatic void qcom_create_soc_sleep_stat_files(struct dentry *root, void __iomem *reg,\n\t\t\t\t\t     struct stats_data *d,\n\t\t\t\t\t     const struct stats_config *config)\n{\n\tchar stat_type[sizeof(u32) + 1] = {0};\n\tsize_t stats_offset = config->stats_offset;\n\tu32 offset = 0, type;\n\tint i, j;\n\n\t \n\tif (config->dynamic_offset) {\n\t\tstats_offset = readl(reg + RPM_DYNAMIC_ADDR);\n\t\tstats_offset &= RPM_DYNAMIC_ADDR_MASK;\n\t}\n\n\tfor (i = 0; i < config->num_records; i++) {\n\t\td[i].base = reg + offset + stats_offset;\n\n\t\t \n\t\ttype = readl(d[i].base);\n\t\tfor (j = 0; j < sizeof(u32); j++) {\n\t\t\tstat_type[j] = type & 0xff;\n\t\t\ttype = type >> 8;\n\t\t}\n\t\tstrim(stat_type);\n\t\tdebugfs_create_file(stat_type, 0400, root, &d[i],\n\t\t\t\t    &qcom_soc_sleep_stats_fops);\n\n\t\toffset += sizeof(struct sleep_stats);\n\t\tif (d[i].appended_stats_avail)\n\t\t\toffset += sizeof(struct appended_stats);\n\t}\n}\n\nstatic void qcom_create_subsystem_stat_files(struct dentry *root,\n\t\t\t\t\t     const struct stats_config *config)\n{\n\tint i;\n\n\tif (!config->subsystem_stats_in_smem)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(subsystems); i++)\n\t\tdebugfs_create_file(subsystems[i].name, 0400, root, (void *)&subsystems[i],\n\t\t\t\t    &qcom_subsystem_sleep_stats_fops);\n}\n\nstatic int qcom_stats_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *reg;\n\tstruct dentry *root;\n\tconst struct stats_config *config;\n\tstruct stats_data *d;\n\tint i;\n\n\tconfig = device_get_match_data(&pdev->dev);\n\tif (!config)\n\t\treturn -ENODEV;\n\n\treg = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(reg))\n\t\treturn -ENOMEM;\n\n\td = devm_kcalloc(&pdev->dev, config->num_records,\n\t\t\t sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < config->num_records; i++)\n\t\td[i].appended_stats_avail = config->appended_stats_avail;\n\n\troot = debugfs_create_dir(\"qcom_stats\", NULL);\n\n\tqcom_create_subsystem_stat_files(root, config);\n\tqcom_create_soc_sleep_stat_files(root, reg, d, config);\n\n\tplatform_set_drvdata(pdev, root);\n\n\tdevice_set_pm_not_required(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int qcom_stats_remove(struct platform_device *pdev)\n{\n\tstruct dentry *root = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(root);\n\n\treturn 0;\n}\n\nstatic const struct stats_config rpm_data = {\n\t.stats_offset = 0,\n\t.num_records = 2,\n\t.appended_stats_avail = true,\n\t.dynamic_offset = true,\n\t.subsystem_stats_in_smem = false,\n};\n\n \nstatic const struct stats_config rpm_data_dba0 = {\n\t.stats_offset = 0xdba0,\n\t.num_records = 2,\n\t.appended_stats_avail = true,\n\t.dynamic_offset = false,\n\t.subsystem_stats_in_smem = false,\n};\n\nstatic const struct stats_config rpmh_data_sdm845 = {\n\t.stats_offset = 0x48,\n\t.num_records = 2,\n\t.appended_stats_avail = false,\n\t.dynamic_offset = false,\n\t.subsystem_stats_in_smem = true,\n};\n\nstatic const struct stats_config rpmh_data = {\n\t.stats_offset = 0x48,\n\t.num_records = 3,\n\t.appended_stats_avail = false,\n\t.dynamic_offset = false,\n\t.subsystem_stats_in_smem = true,\n};\n\nstatic const struct of_device_id qcom_stats_table[] = {\n\t{ .compatible = \"qcom,apq8084-rpm-stats\", .data = &rpm_data_dba0 },\n\t{ .compatible = \"qcom,msm8226-rpm-stats\", .data = &rpm_data_dba0 },\n\t{ .compatible = \"qcom,msm8916-rpm-stats\", .data = &rpm_data_dba0 },\n\t{ .compatible = \"qcom,msm8974-rpm-stats\", .data = &rpm_data_dba0 },\n\t{ .compatible = \"qcom,rpm-stats\", .data = &rpm_data },\n\t{ .compatible = \"qcom,rpmh-stats\", .data = &rpmh_data },\n\t{ .compatible = \"qcom,sdm845-rpmh-stats\", .data = &rpmh_data_sdm845 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_stats_table);\n\nstatic struct platform_driver qcom_stats = {\n\t.probe = qcom_stats_probe,\n\t.remove = qcom_stats_remove,\n\t.driver = {\n\t\t.name = \"qcom_stats\",\n\t\t.of_match_table = qcom_stats_table,\n\t},\n};\n\nstatic int __init qcom_stats_init(void)\n{\n\treturn platform_driver_register(&qcom_stats);\n}\nlate_initcall(qcom_stats_init);\n\nstatic void __exit qcom_stats_exit(void)\n{\n\tplatform_driver_unregister(&qcom_stats);\n}\nmodule_exit(qcom_stats_exit)\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. (QTI) Stats driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}