{
  "module_name": "ramp_controller.c",
  "hash_id": "d7059237faa5ecf260963002ca6003b02b57e1ab017839377719ec06a74810aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/qcom/ramp_controller.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#define RC_UPDATE_EN\t\tBIT(0)\n#define RC_ROOT_EN\t\tBIT(1)\n\n#define RC_REG_CFG_UPDATE\t0x60\n#define RC_CFG_UPDATE_EN\tBIT(8)\n#define RC_CFG_ACK\t\tGENMASK(31, 16)\n\n#define RC_DCVS_CFG_SID\t\t2\n#define RC_LINK_SID\t\t3\n#define RC_LMH_SID\t\t6\n#define RC_DFS_SID\t\t14\n\n#define RC_UPDATE_TIMEOUT_US\t500\n\n \nstruct qcom_ramp_controller_desc {\n\tconst struct reg_sequence *cfg_dfs_sid;\n\tconst struct reg_sequence *cfg_link_sid;\n\tconst struct reg_sequence *cfg_lmh_sid;\n\tconst struct reg_sequence *cfg_ramp_en;\n\tconst struct reg_sequence *cfg_ramp_dis;\n\tu8 cmd_reg;\n\tu8 num_dfs_sids;\n\tu8 num_link_sids;\n\tu8 num_lmh_sids;\n\tu8 num_ramp_en;\n\tu8 num_ramp_dis;\n};\n\n \nstruct qcom_ramp_controller {\n\tstruct regmap *regmap;\n\tconst struct qcom_ramp_controller_desc *desc;\n};\n\n \nstatic int rc_wait_for_update(struct qcom_ramp_controller *qrc)\n{\n\tconst struct qcom_ramp_controller_desc *d = qrc->desc;\n\tstruct regmap *r = qrc->regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_set_bits(r, d->cmd_reg, RC_ROOT_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read_poll_timeout(r, d->cmd_reg, val, !(val & RC_UPDATE_EN),\n\t\t\t\t\t1, RC_UPDATE_TIMEOUT_US);\n}\n\n \nstatic int rc_set_cfg_update(struct qcom_ramp_controller *qrc, u8 ce)\n{\n\tconst struct qcom_ramp_controller_desc *d = qrc->desc;\n\tstruct regmap *r = qrc->regmap;\n\tu32 ack, val;\n\tint ret;\n\n\t \n\tack = FIELD_PREP(RC_CFG_ACK, BIT(ce));\n\n\t \n\tret = regmap_set_bits(r, d->cmd_reg + RC_REG_CFG_UPDATE, ce);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_set_bits(r, d->cmd_reg + RC_REG_CFG_UPDATE, RC_CFG_UPDATE_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(r, d->cmd_reg + RC_REG_CFG_UPDATE, val,\n\t\t\t\t       val & ack, 1, RC_UPDATE_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(r, d->cmd_reg + RC_REG_CFG_UPDATE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_read_poll_timeout(r, d->cmd_reg + RC_REG_CFG_UPDATE,\n\t\t\t\t\tval, !(val & RC_CFG_ACK), 1,\n\t\t\t\t\tRC_UPDATE_TIMEOUT_US);\n}\n\n \nstatic int rc_write_cfg(struct qcom_ramp_controller *qrc,\n\t\t\tconst struct reg_sequence *seq,\n\t\t\tu16 ce, u8 nsids)\n{\n\tint ret;\n\tu8 i;\n\n\t \n\tret = rc_wait_for_update(qrc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_multi_reg_write(qrc->regmap, seq, nsids);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < nsids; i++) {\n\t\tret = rc_set_cfg_update(qrc, (u8)ce - i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rc_ramp_ctrl_enable(struct qcom_ramp_controller *qrc)\n{\n\tconst struct qcom_ramp_controller_desc *d = qrc->desc;\n\tint i, ret;\n\n\tfor (i = 0; i < d->num_ramp_en; i++) {\n\t\tret = rc_write_cfg(qrc, &d->cfg_ramp_en[i], RC_DCVS_CFG_SID, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qcom_ramp_controller_start(struct qcom_ramp_controller *qrc)\n{\n\tconst struct qcom_ramp_controller_desc *d = qrc->desc;\n\tint ret;\n\n\t \n\tret = rc_write_cfg(qrc, d->cfg_lmh_sid, RC_LMH_SID, d->num_lmh_sids);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rc_write_cfg(qrc, d->cfg_dfs_sid, RC_DFS_SID, d->num_dfs_sids);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rc_write_cfg(qrc, d->cfg_link_sid, RC_LINK_SID, d->num_link_sids);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn rc_ramp_ctrl_enable(qrc);\n}\n\nstatic const struct regmap_config qrc_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register =\t0x68,\n\t.fast_io = true,\n};\n\nstatic const struct reg_sequence msm8976_cfg_dfs_sid[] = {\n\t{ 0x10, 0xfefebff7 },\n\t{ 0x14, 0xfdff7fef },\n\t{ 0x18, 0xfbffdefb },\n\t{ 0x1c, 0xb69b5555 },\n\t{ 0x20, 0x24929249 },\n\t{ 0x24, 0x49241112 },\n\t{ 0x28, 0x11112111 },\n\t{ 0x2c, 0x8102 }\n};\n\nstatic const struct reg_sequence msm8976_cfg_link_sid[] = {\n\t{ 0x40, 0xfc987 }\n};\n\nstatic const struct reg_sequence msm8976_cfg_lmh_sid[] = {\n\t{ 0x30, 0x77706db },\n\t{ 0x34, 0x5550249 },\n\t{ 0x38, 0x111 }\n};\n\nstatic const struct reg_sequence msm8976_cfg_ramp_en[] = {\n\t{ 0x50, 0x800 },  \n\t{ 0x50, 0xc00 },  \n\t{ 0x50, 0x400 }   \n};\n\nstatic const struct reg_sequence msm8976_cfg_ramp_dis[] = {\n\t{ 0x50, 0x0 }\n};\n\nstatic const struct qcom_ramp_controller_desc msm8976_rc_cfg = {\n\t.cfg_dfs_sid = msm8976_cfg_dfs_sid,\n\t.num_dfs_sids = ARRAY_SIZE(msm8976_cfg_dfs_sid),\n\n\t.cfg_link_sid = msm8976_cfg_link_sid,\n\t.num_link_sids = ARRAY_SIZE(msm8976_cfg_link_sid),\n\n\t.cfg_lmh_sid = msm8976_cfg_lmh_sid,\n\t.num_lmh_sids = ARRAY_SIZE(msm8976_cfg_lmh_sid),\n\n\t.cfg_ramp_en = msm8976_cfg_ramp_en,\n\t.num_ramp_en = ARRAY_SIZE(msm8976_cfg_ramp_en),\n\n\t.cfg_ramp_dis = msm8976_cfg_ramp_dis,\n\t.num_ramp_dis = ARRAY_SIZE(msm8976_cfg_ramp_dis),\n\n\t.cmd_reg = 0x0,\n};\n\nstatic int qcom_ramp_controller_probe(struct platform_device *pdev)\n{\n\tstruct qcom_ramp_controller *qrc;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tqrc = devm_kmalloc(&pdev->dev, sizeof(*qrc), GFP_KERNEL);\n\tif (!qrc)\n\t\treturn -ENOMEM;\n\n\tqrc->desc = device_get_match_data(&pdev->dev);\n\tif (!qrc->desc)\n\t\treturn -EINVAL;\n\n\tqrc->regmap = devm_regmap_init_mmio(&pdev->dev, base, &qrc_regmap_config);\n\tif (IS_ERR(qrc->regmap))\n\t\treturn PTR_ERR(qrc->regmap);\n\n\tplatform_set_drvdata(pdev, qrc);\n\n\treturn qcom_ramp_controller_start(qrc);\n}\n\nstatic void qcom_ramp_controller_remove(struct platform_device *pdev)\n{\n\tstruct qcom_ramp_controller *qrc = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = rc_write_cfg(qrc, qrc->desc->cfg_ramp_dis,\n\t\t\t   RC_DCVS_CFG_SID, qrc->desc->num_ramp_dis);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to send disable sequence\\n\");\n}\n\nstatic const struct of_device_id qcom_ramp_controller_match_table[] = {\n\t{ .compatible = \"qcom,msm8976-ramp-controller\", .data = &msm8976_rc_cfg },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, qcom_ramp_controller_match_table);\n\nstatic struct platform_driver qcom_ramp_controller_driver = {\n\t.driver = {\n\t\t.name = \"qcom-ramp-controller\",\n\t\t.of_match_table = qcom_ramp_controller_match_table,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = qcom_ramp_controller_probe,\n\t.remove_new = qcom_ramp_controller_remove,\n};\n\nstatic int __init qcom_ramp_controller_init(void)\n{\n\treturn platform_driver_register(&qcom_ramp_controller_driver);\n}\narch_initcall(qcom_ramp_controller_init);\n\nMODULE_AUTHOR(\"AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>\");\nMODULE_DESCRIPTION(\"Qualcomm Ramp Controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}