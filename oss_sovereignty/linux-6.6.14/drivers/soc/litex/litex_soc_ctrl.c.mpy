{
  "module_name": "litex_soc_ctrl.c",
  "hash_id": "25262b4a089306a4422b7f70edc210e51abcdbe9bc16b0f84c263b1816b33efd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/litex/litex_soc_ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/litex.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/reboot.h>\n\n \n#define RESET_REG_OFF           0x00\n#define RESET_REG_VALUE         0x00000001\n\n#define SCRATCH_REG_OFF         0x04\n#define SCRATCH_REG_VALUE       0x12345678\n#define SCRATCH_TEST_VALUE      0xdeadbeef\n\n \nstatic int litex_check_csr_access(void __iomem *reg_addr)\n{\n\tunsigned long reg;\n\n\treg = litex_read32(reg_addr + SCRATCH_REG_OFF);\n\n\tif (reg != SCRATCH_REG_VALUE) {\n\t\tpanic(\"Scratch register read error - the system is probably broken! Expected: 0x%x but got: 0x%lx\",\n\t\t\tSCRATCH_REG_VALUE, reg);\n\t\treturn -EINVAL;\n\t}\n\n\tlitex_write32(reg_addr + SCRATCH_REG_OFF, SCRATCH_TEST_VALUE);\n\treg = litex_read32(reg_addr + SCRATCH_REG_OFF);\n\n\tif (reg != SCRATCH_TEST_VALUE) {\n\t\tpanic(\"Scratch register write error - the system is probably broken! Expected: 0x%x but got: 0x%lx\",\n\t\t\tSCRATCH_TEST_VALUE, reg);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlitex_write32(reg_addr + SCRATCH_REG_OFF, SCRATCH_REG_VALUE);\n\n\tpr_info(\"LiteX SoC Controller driver initialized\");\n\n\treturn 0;\n}\n\nstruct litex_soc_ctrl_device {\n\tvoid __iomem *base;\n\tstruct notifier_block reset_nb;\n};\n\nstatic int litex_reset_handler(struct notifier_block *this, unsigned long mode,\n\t\t\t       void *cmd)\n{\n\tstruct litex_soc_ctrl_device *soc_ctrl_dev =\n\t\tcontainer_of(this, struct litex_soc_ctrl_device, reset_nb);\n\n\tlitex_write32(soc_ctrl_dev->base + RESET_REG_OFF, RESET_REG_VALUE);\n\treturn NOTIFY_DONE;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id litex_soc_ctrl_of_match[] = {\n\t{.compatible = \"litex,soc-controller\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, litex_soc_ctrl_of_match);\n#endif  \n\nstatic int litex_soc_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct litex_soc_ctrl_device *soc_ctrl_dev;\n\tint error;\n\n\tsoc_ctrl_dev = devm_kzalloc(&pdev->dev, sizeof(*soc_ctrl_dev), GFP_KERNEL);\n\tif (!soc_ctrl_dev)\n\t\treturn -ENOMEM;\n\n\tsoc_ctrl_dev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(soc_ctrl_dev->base))\n\t\treturn PTR_ERR(soc_ctrl_dev->base);\n\n\terror = litex_check_csr_access(soc_ctrl_dev->base);\n\tif (error)\n\t\treturn error;\n\n\tplatform_set_drvdata(pdev, soc_ctrl_dev);\n\n\tsoc_ctrl_dev->reset_nb.notifier_call = litex_reset_handler;\n\tsoc_ctrl_dev->reset_nb.priority = 128;\n\terror = register_restart_handler(&soc_ctrl_dev->reset_nb);\n\tif (error) {\n\t\tdev_warn(&pdev->dev, \"cannot register restart handler: %d\\n\",\n\t\t\t error);\n\t}\n\n\treturn 0;\n}\n\nstatic int litex_soc_ctrl_remove(struct platform_device *pdev)\n{\n\tstruct litex_soc_ctrl_device *soc_ctrl_dev = platform_get_drvdata(pdev);\n\n\tunregister_restart_handler(&soc_ctrl_dev->reset_nb);\n\treturn 0;\n}\n\nstatic struct platform_driver litex_soc_ctrl_driver = {\n\t.driver = {\n\t\t.name = \"litex-soc-controller\",\n\t\t.of_match_table = of_match_ptr(litex_soc_ctrl_of_match)\n\t},\n\t.probe = litex_soc_ctrl_probe,\n\t.remove = litex_soc_ctrl_remove,\n};\n\nmodule_platform_driver(litex_soc_ctrl_driver);\nMODULE_DESCRIPTION(\"LiteX SoC Controller driver\");\nMODULE_AUTHOR(\"Antmicro <www.antmicro.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}