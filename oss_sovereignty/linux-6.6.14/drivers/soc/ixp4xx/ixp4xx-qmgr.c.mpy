{
  "module_name": "ixp4xx-qmgr.c",
  "hash_id": "8d665e80d0dc2fabb5b04355dabb32f047bc35c2316b85e29726552e1430cfb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ixp4xx/ixp4xx-qmgr.c",
  "human_readable_source": "\n \n\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ixp4xx/qmgr.h>\n#include <linux/soc/ixp4xx/cpu.h>\n\nstatic struct qmgr_regs __iomem *qmgr_regs;\nstatic int qmgr_irq_1;\nstatic int qmgr_irq_2;\nstatic spinlock_t qmgr_lock;\nstatic u32 used_sram_bitmap[4];  \nstatic void (*irq_handlers[QUEUES])(void *pdev);\nstatic void *irq_pdevs[QUEUES];\n\n#if DEBUG_QMGR\nchar qmgr_queue_descs[QUEUES][32];\n#endif\n\nvoid qmgr_put_entry(unsigned int queue, u32 val)\n{\n#if DEBUG_QMGR\n\tBUG_ON(!qmgr_queue_descs[queue]);  \n\n\tprintk(KERN_DEBUG \"Queue %s(%i) put %X\\n\",\n\t       qmgr_queue_descs[queue], queue, val);\n#endif\n\t__raw_writel(val, &qmgr_regs->acc[queue][0]);\n}\n\nu32 qmgr_get_entry(unsigned int queue)\n{\n\tu32 val;\n\tval = __raw_readl(&qmgr_regs->acc[queue][0]);\n#if DEBUG_QMGR\n\tBUG_ON(!qmgr_queue_descs[queue]);  \n\n\tprintk(KERN_DEBUG \"Queue %s(%i) get %X\\n\",\n\t       qmgr_queue_descs[queue], queue, val);\n#endif\n\treturn val;\n}\n\nstatic int __qmgr_get_stat1(unsigned int queue)\n{\n\treturn (__raw_readl(&qmgr_regs->stat1[queue >> 3])\n\t\t>> ((queue & 7) << 2)) & 0xF;\n}\n\nstatic int __qmgr_get_stat2(unsigned int queue)\n{\n\tBUG_ON(queue >= HALF_QUEUES);\n\treturn (__raw_readl(&qmgr_regs->stat2[queue >> 4])\n\t\t>> ((queue & 0xF) << 1)) & 0x3;\n}\n\n \nint qmgr_stat_empty(unsigned int queue)\n{\n\tBUG_ON(queue >= HALF_QUEUES);\n\treturn __qmgr_get_stat1(queue) & QUEUE_STAT1_EMPTY;\n}\n\n \nint qmgr_stat_below_low_watermark(unsigned int queue)\n{\n\tif (queue >= HALF_QUEUES)\n\t\treturn (__raw_readl(&qmgr_regs->statne_h) >>\n\t\t\t(queue - HALF_QUEUES)) & 0x01;\n\treturn __qmgr_get_stat1(queue) & QUEUE_STAT1_NEARLY_EMPTY;\n}\n\n \nint qmgr_stat_full(unsigned int queue)\n{\n\tif (queue >= HALF_QUEUES)\n\t\treturn (__raw_readl(&qmgr_regs->statf_h) >>\n\t\t\t(queue - HALF_QUEUES)) & 0x01;\n\treturn __qmgr_get_stat1(queue) & QUEUE_STAT1_FULL;\n}\n\n \nint qmgr_stat_overflow(unsigned int queue)\n{\n\treturn __qmgr_get_stat2(queue) & QUEUE_STAT2_OVERFLOW;\n}\n\nvoid qmgr_set_irq(unsigned int queue, int src,\n\t\t  void (*handler)(void *pdev), void *pdev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qmgr_lock, flags);\n\tif (queue < HALF_QUEUES) {\n\t\tu32 __iomem *reg;\n\t\tint bit;\n\t\tBUG_ON(src > QUEUE_IRQ_SRC_NOT_FULL);\n\t\treg = &qmgr_regs->irqsrc[queue >> 3];  \n\t\tbit = (queue % 8) * 4;  \n\t\t__raw_writel((__raw_readl(reg) & ~(7 << bit)) | (src << bit),\n\t\t\t     reg);\n\t} else\n\t\t \n\t\tBUG_ON(src != QUEUE_IRQ_SRC_NOT_NEARLY_EMPTY);\n\n\tirq_handlers[queue] = handler;\n\tirq_pdevs[queue] = pdev;\n\tspin_unlock_irqrestore(&qmgr_lock, flags);\n}\n\n\nstatic irqreturn_t qmgr_irq1_a0(int irq, void *pdev)\n{\n\tint i, ret = 0;\n\tu32 en_bitmap, src, stat;\n\n\t \n\t__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[0]);\n\n\ten_bitmap = __raw_readl(&qmgr_regs->irqen[0]);\n\twhile (en_bitmap) {\n\t\ti = __fls(en_bitmap);  \n\t\ten_bitmap &= ~BIT(i);\n\t\tsrc = __raw_readl(&qmgr_regs->irqsrc[i >> 3]);\n\t\tstat = __raw_readl(&qmgr_regs->stat1[i >> 3]);\n\t\tif (src & 4)  \n\t\t\tstat = ~stat;\n\t\tif (stat & BIT(src & 3)) {\n\t\t\tirq_handlers[i](irq_pdevs[i]);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstatic irqreturn_t qmgr_irq2_a0(int irq, void *pdev)\n{\n\tint i, ret = 0;\n\tu32 req_bitmap;\n\n\t \n\t__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[1]);\n\n\treq_bitmap = __raw_readl(&qmgr_regs->irqen[1]) &\n\t\t     __raw_readl(&qmgr_regs->statne_h);\n\twhile (req_bitmap) {\n\t\ti = __fls(req_bitmap);  \n\t\treq_bitmap &= ~BIT(i);\n\t\tirq_handlers[HALF_QUEUES + i](irq_pdevs[HALF_QUEUES + i]);\n\t\tret = IRQ_HANDLED;\n\t}\n\treturn ret;\n}\n\n\nstatic irqreturn_t qmgr_irq(int irq, void *pdev)\n{\n\tint i, half = (irq == qmgr_irq_1 ? 0 : 1);\n\tu32 req_bitmap = __raw_readl(&qmgr_regs->irqstat[half]);\n\n\tif (!req_bitmap)\n\t\treturn 0;\n\t__raw_writel(req_bitmap, &qmgr_regs->irqstat[half]);  \n\n\twhile (req_bitmap) {\n\t\ti = __fls(req_bitmap);  \n\t\treq_bitmap &= ~BIT(i);\n\t\ti += half * HALF_QUEUES;\n\t\tirq_handlers[i](irq_pdevs[i]);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\nvoid qmgr_enable_irq(unsigned int queue)\n{\n\tunsigned long flags;\n\tint half = queue / 32;\n\tu32 mask = 1 << (queue & (HALF_QUEUES - 1));\n\n\tspin_lock_irqsave(&qmgr_lock, flags);\n\t__raw_writel(__raw_readl(&qmgr_regs->irqen[half]) | mask,\n\t\t     &qmgr_regs->irqen[half]);\n\tspin_unlock_irqrestore(&qmgr_lock, flags);\n}\n\nvoid qmgr_disable_irq(unsigned int queue)\n{\n\tunsigned long flags;\n\tint half = queue / 32;\n\tu32 mask = 1 << (queue & (HALF_QUEUES - 1));\n\n\tspin_lock_irqsave(&qmgr_lock, flags);\n\t__raw_writel(__raw_readl(&qmgr_regs->irqen[half]) & ~mask,\n\t\t     &qmgr_regs->irqen[half]);\n\t__raw_writel(mask, &qmgr_regs->irqstat[half]);  \n\tspin_unlock_irqrestore(&qmgr_lock, flags);\n}\n\nstatic inline void shift_mask(u32 *mask)\n{\n\tmask[3] = mask[3] << 1 | mask[2] >> 31;\n\tmask[2] = mask[2] << 1 | mask[1] >> 31;\n\tmask[1] = mask[1] << 1 | mask[0] >> 31;\n\tmask[0] <<= 1;\n}\n\n#if DEBUG_QMGR\nint qmgr_request_queue(unsigned int queue, unsigned int len  ,\n\t\t       unsigned int nearly_empty_watermark,\n\t\t       unsigned int nearly_full_watermark,\n\t\t       const char *desc_format, const char* name)\n#else\nint __qmgr_request_queue(unsigned int queue, unsigned int len  ,\n\t\t\t unsigned int nearly_empty_watermark,\n\t\t\t unsigned int nearly_full_watermark)\n#endif\n{\n\tu32 cfg, addr = 0, mask[4];  \n\tint err;\n\n\tBUG_ON(queue >= QUEUES);\n\n\tif ((nearly_empty_watermark | nearly_full_watermark) & ~7)\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase  16:\n\t\tcfg = 0 << 24;\n\t\tmask[0] = 0x1;\n\t\tbreak;\n\tcase  32:\n\t\tcfg = 1 << 24;\n\t\tmask[0] = 0x3;\n\t\tbreak;\n\tcase  64:\n\t\tcfg = 2 << 24;\n\t\tmask[0] = 0xF;\n\t\tbreak;\n\tcase 128:\n\t\tcfg = 3 << 24;\n\t\tmask[0] = 0xFF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcfg |= nearly_empty_watermark << 26;\n\tcfg |= nearly_full_watermark << 29;\n\tlen /= 16;\t\t \n\tmask[1] = mask[2] = mask[3] = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&qmgr_lock);\n\tif (__raw_readl(&qmgr_regs->sram[queue])) {\n\t\terr = -EBUSY;\n\t\tgoto err;\n\t}\n\n\twhile (1) {\n\t\tif (!(used_sram_bitmap[0] & mask[0]) &&\n\t\t    !(used_sram_bitmap[1] & mask[1]) &&\n\t\t    !(used_sram_bitmap[2] & mask[2]) &&\n\t\t    !(used_sram_bitmap[3] & mask[3]))\n\t\t\tbreak;  \n\n\t\taddr++;\n\t\tshift_mask(mask);\n\t\tif (addr + len > ARRAY_SIZE(qmgr_regs->sram)) {\n\t\t\tprintk(KERN_ERR \"qmgr: no free SRAM space for\"\n\t\t\t       \" queue %i\\n\", queue);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tused_sram_bitmap[0] |= mask[0];\n\tused_sram_bitmap[1] |= mask[1];\n\tused_sram_bitmap[2] |= mask[2];\n\tused_sram_bitmap[3] |= mask[3];\n\t__raw_writel(cfg | (addr << 14), &qmgr_regs->sram[queue]);\n#if DEBUG_QMGR\n\tsnprintf(qmgr_queue_descs[queue], sizeof(qmgr_queue_descs[0]),\n\t\t desc_format, name);\n\tprintk(KERN_DEBUG \"qmgr: requested queue %s(%i) addr = 0x%02X\\n\",\n\t       qmgr_queue_descs[queue], queue, addr);\n#endif\n\tspin_unlock_irq(&qmgr_lock);\n\treturn 0;\n\nerr:\n\tspin_unlock_irq(&qmgr_lock);\n\tmodule_put(THIS_MODULE);\n\treturn err;\n}\n\nvoid qmgr_release_queue(unsigned int queue)\n{\n\tu32 cfg, addr, mask[4];\n\n\tBUG_ON(queue >= QUEUES);  \n\n\tspin_lock_irq(&qmgr_lock);\n\tcfg = __raw_readl(&qmgr_regs->sram[queue]);\n\taddr = (cfg >> 14) & 0xFF;\n\n\tBUG_ON(!addr);\t\t \n\n\tswitch ((cfg >> 24) & 3) {\n\tcase 0: mask[0] = 0x1; break;\n\tcase 1: mask[0] = 0x3; break;\n\tcase 2: mask[0] = 0xF; break;\n\tcase 3: mask[0] = 0xFF; break;\n\t}\n\n\tmask[1] = mask[2] = mask[3] = 0;\n\n\twhile (addr--)\n\t\tshift_mask(mask);\n\n#if DEBUG_QMGR\n\tprintk(KERN_DEBUG \"qmgr: releasing queue %s(%i)\\n\",\n\t       qmgr_queue_descs[queue], queue);\n\tqmgr_queue_descs[queue][0] = '\\x0';\n#endif\n\n\twhile ((addr = qmgr_get_entry(queue)))\n\t\tprintk(KERN_ERR \"qmgr: released queue %i not empty: 0x%08X\\n\",\n\t\t       queue, addr);\n\n\t__raw_writel(0, &qmgr_regs->sram[queue]);\n\n\tused_sram_bitmap[0] &= ~mask[0];\n\tused_sram_bitmap[1] &= ~mask[1];\n\tused_sram_bitmap[2] &= ~mask[2];\n\tused_sram_bitmap[3] &= ~mask[3];\n\tirq_handlers[queue] = NULL;  \n\tspin_unlock_irq(&qmgr_lock);\n\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int ixp4xx_qmgr_probe(struct platform_device *pdev)\n{\n\tint i, err;\n\tirq_handler_t handler1, handler2;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint irq1, irq2;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\tqmgr_regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(qmgr_regs))\n\t\treturn PTR_ERR(qmgr_regs);\n\n\tirq1 = platform_get_irq(pdev, 0);\n\tif (irq1 <= 0)\n\t\treturn irq1 ? irq1 : -EINVAL;\n\tqmgr_irq_1 = irq1;\n\tirq2 = platform_get_irq(pdev, 1);\n\tif (irq2 <= 0)\n\t\treturn irq2 ? irq2 : -EINVAL;\n\tqmgr_irq_2 = irq2;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\t__raw_writel(0x33333333, &qmgr_regs->stat1[i]);\n\t\t__raw_writel(0, &qmgr_regs->irqsrc[i]);\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\t__raw_writel(0, &qmgr_regs->stat2[i]);\n\t\t__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[i]);  \n\t\t__raw_writel(0, &qmgr_regs->irqen[i]);\n\t}\n\n\t__raw_writel(0xFFFFFFFF, &qmgr_regs->statne_h);\n\t__raw_writel(0, &qmgr_regs->statf_h);\n\n\tfor (i = 0; i < QUEUES; i++)\n\t\t__raw_writel(0, &qmgr_regs->sram[i]);\n\n\tif (cpu_is_ixp42x_rev_a0()) {\n\t\thandler1 = qmgr_irq1_a0;\n\t\thandler2 = qmgr_irq2_a0;\n\t} else\n\t\thandler1 = handler2 = qmgr_irq;\n\n\terr = devm_request_irq(dev, irq1, handler1, 0, \"IXP4xx Queue Manager\",\n\t\t\t       NULL);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request IRQ%i (%i)\\n\",\n\t\t\tirq1, err);\n\t\treturn err;\n\t}\n\n\terr = devm_request_irq(dev, irq2, handler2, 0, \"IXP4xx Queue Manager\",\n\t\t\t       NULL);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request IRQ%i (%i)\\n\",\n\t\t\tirq2, err);\n\t\treturn err;\n\t}\n\n\tused_sram_bitmap[0] = 0xF;  \n\tspin_lock_init(&qmgr_lock);\n\n\tdev_info(dev, \"IXP4xx Queue Manager initialized.\\n\");\n\treturn 0;\n}\n\nstatic int ixp4xx_qmgr_remove(struct platform_device *pdev)\n{\n\tsynchronize_irq(qmgr_irq_1);\n\tsynchronize_irq(qmgr_irq_2);\n\treturn 0;\n}\n\nstatic const struct of_device_id ixp4xx_qmgr_of_match[] = {\n\t{\n\t\t.compatible = \"intel,ixp4xx-ahb-queue-manager\",\n        },\n\t{},\n};\n\nstatic struct platform_driver ixp4xx_qmgr_driver = {\n\t.driver = {\n\t\t.name           = \"ixp4xx-qmgr\",\n\t\t.of_match_table = ixp4xx_qmgr_of_match,\n\t},\n\t.probe = ixp4xx_qmgr_probe,\n\t.remove = ixp4xx_qmgr_remove,\n};\nmodule_platform_driver(ixp4xx_qmgr_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Krzysztof Halasa\");\n\nEXPORT_SYMBOL(qmgr_put_entry);\nEXPORT_SYMBOL(qmgr_get_entry);\nEXPORT_SYMBOL(qmgr_stat_empty);\nEXPORT_SYMBOL(qmgr_stat_below_low_watermark);\nEXPORT_SYMBOL(qmgr_stat_full);\nEXPORT_SYMBOL(qmgr_stat_overflow);\nEXPORT_SYMBOL(qmgr_set_irq);\nEXPORT_SYMBOL(qmgr_enable_irq);\nEXPORT_SYMBOL(qmgr_disable_irq);\n#if DEBUG_QMGR\nEXPORT_SYMBOL(qmgr_queue_descs);\nEXPORT_SYMBOL(qmgr_request_queue);\n#else\nEXPORT_SYMBOL(__qmgr_request_queue);\n#endif\nEXPORT_SYMBOL(qmgr_release_queue);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}