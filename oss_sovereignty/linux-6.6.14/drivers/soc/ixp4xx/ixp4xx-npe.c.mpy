{
  "module_name": "ixp4xx-npe.c",
  "hash_id": "99eb34d47e59533fa9cfda72000fa6b50807ae89e1ce305a0a8cf612897d9405",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ixp4xx/ixp4xx-npe.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ixp4xx/npe.h>\n#include <linux/soc/ixp4xx/cpu.h>\n\n#define DEBUG_MSG\t\t\t0\n#define DEBUG_FW\t\t\t0\n\n#define NPE_COUNT\t\t\t3\n#define MAX_RETRIES\t\t\t1000\t \n#define NPE_42X_DATA_SIZE\t\t0x800\t \n#define NPE_46X_DATA_SIZE\t\t0x1000\n#define NPE_A_42X_INSTR_SIZE\t\t0x1000\n#define NPE_B_AND_C_42X_INSTR_SIZE\t0x800\n#define NPE_46X_INSTR_SIZE\t\t0x1000\n#define REGS_SIZE\t\t\t0x1000\n\n#define NPE_PHYS_REG\t\t\t32\n\n#define FW_MAGIC\t\t\t0xFEEDF00D\n#define FW_BLOCK_TYPE_INSTR\t\t0x0\n#define FW_BLOCK_TYPE_DATA\t\t0x1\n#define FW_BLOCK_TYPE_EOF\t\t0xF\n\n \n#define CMD_NPE_STEP\t\t\t0x01\n#define CMD_NPE_START\t\t\t0x02\n#define CMD_NPE_STOP\t\t\t0x03\n#define CMD_NPE_CLR_PIPE\t\t0x04\n#define CMD_CLR_PROFILE_CNT\t\t0x0C\n#define CMD_RD_INS_MEM\t\t\t0x10  \n#define CMD_WR_INS_MEM\t\t\t0x11\n#define CMD_RD_DATA_MEM\t\t\t0x12  \n#define CMD_WR_DATA_MEM\t\t\t0x13\n#define CMD_RD_ECS_REG\t\t\t0x14  \n#define CMD_WR_ECS_REG\t\t\t0x15\n\n#define STAT_RUN\t\t\t0x80000000\n#define STAT_STOP\t\t\t0x40000000\n#define STAT_CLEAR\t\t\t0x20000000\n#define STAT_ECS_K\t\t\t0x00800000  \n\n#define NPE_STEVT\t\t\t0x1B\n#define NPE_STARTPC\t\t\t0x1C\n#define NPE_REGMAP\t\t\t0x1E\n#define NPE_CINDEX\t\t\t0x1F\n\n#define INSTR_WR_REG_SHORT\t\t0x0000C000\n#define INSTR_WR_REG_BYTE\t\t0x00004000\n#define INSTR_RD_FIFO\t\t\t0x0F888220\n#define INSTR_RESET_MBOX\t\t0x0FAC8210\n\n#define ECS_BG_CTXT_REG_0\t\t0x00  \n#define ECS_BG_CTXT_REG_1\t\t0x01  \n#define ECS_BG_CTXT_REG_2\t\t0x02\n#define ECS_PRI_1_CTXT_REG_0\t\t0x04  \n#define ECS_PRI_1_CTXT_REG_1\t\t0x05  \n#define ECS_PRI_1_CTXT_REG_2\t\t0x06\n#define ECS_PRI_2_CTXT_REG_0\t\t0x08  \n#define ECS_PRI_2_CTXT_REG_1\t\t0x09  \n#define ECS_PRI_2_CTXT_REG_2\t\t0x0A\n#define ECS_DBG_CTXT_REG_0\t\t0x0C  \n#define ECS_DBG_CTXT_REG_1\t\t0x0D  \n#define ECS_DBG_CTXT_REG_2\t\t0x0E\n#define ECS_INSTRUCT_REG\t\t0x11  \n\n#define ECS_REG_0_ACTIVE\t\t0x80000000  \n#define ECS_REG_0_NEXTPC_MASK\t\t0x1FFF0000  \n#define ECS_REG_0_LDUR_BITS\t\t8\n#define ECS_REG_0_LDUR_MASK\t\t0x00000700  \n#define ECS_REG_1_CCTXT_BITS\t\t16\n#define ECS_REG_1_CCTXT_MASK\t\t0x000F0000  \n#define ECS_REG_1_SELCTXT_BITS\t\t0\n#define ECS_REG_1_SELCTXT_MASK\t\t0x0000000F  \n#define ECS_DBG_REG_2_IF\t\t0x00100000  \n#define ECS_DBG_REG_2_IE\t\t0x00080000  \n\n \n#define WFIFO_VALID\t\t\t0x80000000\n\n \n#define MSGSTAT_OFNE\t0x00010000  \n#define MSGSTAT_IFNF\t0x00020000  \n#define MSGSTAT_OFNF\t0x00040000  \n#define MSGSTAT_IFNE\t0x00080000  \n#define MSGSTAT_MBINT\t0x00100000  \n#define MSGSTAT_IFINT\t0x00200000  \n#define MSGSTAT_OFINT\t0x00400000  \n#define MSGSTAT_WFINT\t0x00800000  \n\n \n#define MSGCTL_OUT_FIFO\t\t\t0x00010000  \n#define MSGCTL_IN_FIFO\t\t\t0x00020000  \n#define MSGCTL_OUT_FIFO_WRITE\t\t0x01000000  \n#define MSGCTL_IN_FIFO_WRITE\t\t0x02000000\n\n \n#define RESET_MBOX_STAT\t\t\t0x0000F0F0\n\n#define NPE_A_FIRMWARE \"NPE-A\"\n#define NPE_B_FIRMWARE \"NPE-B\"\n#define NPE_C_FIRMWARE \"NPE-C\"\n\nconst char *npe_names[] = { NPE_A_FIRMWARE, NPE_B_FIRMWARE, NPE_C_FIRMWARE };\n\n#define print_npe(pri, npe, fmt, ...)\t\t\t\t\t\\\n\tprintk(pri \"%s: \" fmt, npe_name(npe), ## __VA_ARGS__)\n\n#if DEBUG_MSG\n#define debug_msg(npe, fmt, ...)\t\t\t\t\t\\\n\tprint_npe(KERN_DEBUG, npe, fmt, ## __VA_ARGS__)\n#else\n#define debug_msg(npe, fmt, ...)\n#endif\n\nstatic struct {\n\tu32 reg, val;\n} ecs_reset[] = {\n\t{ ECS_BG_CTXT_REG_0,\t0xA0000000 },\n\t{ ECS_BG_CTXT_REG_1,\t0x01000000 },\n\t{ ECS_BG_CTXT_REG_2,\t0x00008000 },\n\t{ ECS_PRI_1_CTXT_REG_0,\t0x20000080 },\n\t{ ECS_PRI_1_CTXT_REG_1,\t0x01000000 },\n\t{ ECS_PRI_1_CTXT_REG_2,\t0x00008000 },\n\t{ ECS_PRI_2_CTXT_REG_0,\t0x20000080 },\n\t{ ECS_PRI_2_CTXT_REG_1,\t0x01000000 },\n\t{ ECS_PRI_2_CTXT_REG_2,\t0x00008000 },\n\t{ ECS_DBG_CTXT_REG_0,\t0x20000000 },\n\t{ ECS_DBG_CTXT_REG_1,\t0x00000000 },\n\t{ ECS_DBG_CTXT_REG_2,\t0x001E0000 },\n\t{ ECS_INSTRUCT_REG,\t0x1003C00F },\n};\n\nstatic struct npe npe_tab[NPE_COUNT] = {\n\t{\n\t\t.id\t= 0,\n\t}, {\n\t\t.id\t= 1,\n\t}, {\n\t\t.id\t= 2,\n\t}\n};\n\nint npe_running(struct npe *npe)\n{\n\treturn (__raw_readl(&npe->regs->exec_status_cmd) & STAT_RUN) != 0;\n}\n\nstatic void npe_cmd_write(struct npe *npe, u32 addr, int cmd, u32 data)\n{\n\t__raw_writel(data, &npe->regs->exec_data);\n\t__raw_writel(addr, &npe->regs->exec_addr);\n\t__raw_writel(cmd, &npe->regs->exec_status_cmd);\n}\n\nstatic u32 npe_cmd_read(struct npe *npe, u32 addr, int cmd)\n{\n\t__raw_writel(addr, &npe->regs->exec_addr);\n\t__raw_writel(cmd, &npe->regs->exec_status_cmd);\n\t \n\t__raw_readl(&npe->regs->exec_data);\n\t__raw_readl(&npe->regs->exec_data);\n\treturn __raw_readl(&npe->regs->exec_data);\n}\n\nstatic void npe_clear_active(struct npe *npe, u32 reg)\n{\n\tu32 val = npe_cmd_read(npe, reg, CMD_RD_ECS_REG);\n\tnpe_cmd_write(npe, reg, CMD_WR_ECS_REG, val & ~ECS_REG_0_ACTIVE);\n}\n\nstatic void npe_start(struct npe *npe)\n{\n\t \n\tnpe_clear_active(npe, ECS_PRI_1_CTXT_REG_0);\n\tnpe_clear_active(npe, ECS_PRI_2_CTXT_REG_0);\n\tnpe_clear_active(npe, ECS_DBG_CTXT_REG_0);\n\n\t__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\n\t__raw_writel(CMD_NPE_START, &npe->regs->exec_status_cmd);\n}\n\nstatic void npe_stop(struct npe *npe)\n{\n\t__raw_writel(CMD_NPE_STOP, &npe->regs->exec_status_cmd);\n\t__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);  \n}\n\nstatic int __must_check npe_debug_instr(struct npe *npe, u32 instr, u32 ctx,\n\t\t\t\t\tu32 ldur)\n{\n\tu32 wc;\n\tint i;\n\n\t \n\tnpe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG,\n\t\t      ECS_REG_0_ACTIVE | (ldur << ECS_REG_0_LDUR_BITS));\n\n\t \n\tnpe_cmd_write(npe, ECS_DBG_CTXT_REG_1, CMD_WR_ECS_REG,\n\t\t      (ctx << ECS_REG_1_CCTXT_BITS) |\n\t\t      (ctx << ECS_REG_1_SELCTXT_BITS));\n\n\t \n\t__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\n\n\t \n\tnpe_cmd_write(npe, ECS_INSTRUCT_REG, CMD_WR_ECS_REG, instr);\n\n\t \n\twc = __raw_readl(&npe->regs->watch_count);\n\n\t \n\t__raw_writel(CMD_NPE_STEP, &npe->regs->exec_status_cmd);\n\n\t \n\tfor (i = 0; i < MAX_RETRIES; i++) {\n\t\tif (wc != __raw_readl(&npe->regs->watch_count))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tprint_npe(KERN_ERR, npe, \"reset: npe_debug_instr(): timeout\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int __must_check npe_logical_reg_write8(struct npe *npe, u32 addr,\n\t\t\t\t\t       u8 val, u32 ctx)\n{\n\t \n\tu32 instr = INSTR_WR_REG_BYTE |\t \n\t\taddr << 9 |\t\t \n\t\t(val & 0x1F) << 4 |\t \n\t\t(val & ~0x1F) << (18 - 5); \n\treturn npe_debug_instr(npe, instr, ctx, 1);  \n}\n\nstatic int __must_check npe_logical_reg_write16(struct npe *npe, u32 addr,\n\t\t\t\t\t\tu16 val, u32 ctx)\n{\n\t \n\tu32 instr = INSTR_WR_REG_SHORT |  \n\t\taddr << 9 |\t\t \n\t\t(val & 0x1F) << 4 |\t \n\t\t(val & ~0x1F) << (18 - 5); \n\treturn npe_debug_instr(npe, instr, ctx, 1);  \n}\n\nstatic int __must_check npe_logical_reg_write32(struct npe *npe, u32 addr,\n\t\t\t\t\t\tu32 val, u32 ctx)\n{\n\t \n\tif (npe_logical_reg_write16(npe, addr, val >> 16, ctx))\n\t\treturn -ETIMEDOUT;\n\treturn npe_logical_reg_write16(npe, addr + 2, val & 0xFFFF, ctx);\n}\n\nstatic int npe_reset(struct npe *npe)\n{\n\tu32 reset_bit = (IXP4XX_FEATURE_RESET_NPEA << npe->id);\n\tu32 val, ctl, exec_count, ctx_reg2;\n\tint i;\n\n\tctl = (__raw_readl(&npe->regs->messaging_control) | 0x3F000000) &\n\t\t0x3F3FFFFF;\n\n\t \n\t__raw_writel(ctl & 0x3F00FFFF, &npe->regs->messaging_control);\n\n\t \n\t \n\texec_count = __raw_readl(&npe->regs->exec_count);\n\t__raw_writel(0, &npe->regs->exec_count);\n\t \n\tctx_reg2 = npe_cmd_read(npe, ECS_DBG_CTXT_REG_2, CMD_RD_ECS_REG);\n\tnpe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2 |\n\t\t      ECS_DBG_REG_2_IF | ECS_DBG_REG_2_IE);\n\n\t \n\twhile (__raw_readl(&npe->regs->watchpoint_fifo) & WFIFO_VALID)\n\t\t;\n\twhile (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE)\n\t\t \n\t\tprint_npe(KERN_DEBUG, npe, \"npe_reset: read FIFO = 0x%X\\n\",\n\t\t\t  __raw_readl(&npe->regs->in_out_fifo));\n\n\twhile (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)\n\t\t \n\t\tif (npe_debug_instr(npe, INSTR_RD_FIFO, 0, 0))\n\t\t\treturn -ETIMEDOUT;\n\n\t \n\t__raw_writel(RESET_MBOX_STAT, &npe->regs->mailbox_status);\n\t \n\tif (npe_debug_instr(npe, INSTR_RESET_MBOX, 0, 0))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tfor (val = 0; val < NPE_PHYS_REG; val++) {\n\t\tif (npe_logical_reg_write16(npe, NPE_REGMAP, val >> 1, 0))\n\t\t\treturn -ETIMEDOUT;\n\t\t \n\t\tif (npe_logical_reg_write32(npe, (val & 1) * 4, 0, 0))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\n\t \n\tval = npe_cmd_read(npe, ECS_BG_CTXT_REG_0, CMD_RD_ECS_REG);\n\tval &= ~ECS_REG_0_NEXTPC_MASK;\n\tval |= (0   << 16) & ECS_REG_0_NEXTPC_MASK;\n\tnpe_cmd_write(npe, ECS_BG_CTXT_REG_0, CMD_WR_ECS_REG, val);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (i) {\t \n\t\t\t \n\t\t\tif (npe_logical_reg_write8(npe, NPE_STEVT, 0x80, i))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tif (npe_logical_reg_write16(npe, NPE_STARTPC, 0, i))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\t \n\t\tif (npe_logical_reg_write16(npe, NPE_REGMAP, 0x820, i))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (npe_logical_reg_write8(npe, NPE_CINDEX, 0, i))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\t \n\tnpe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG, 0);\n\t \n\t__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\n\t \n\t__raw_writel(exec_count, &npe->regs->exec_count);\n\tnpe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2);\n\n\t \n\tfor (val = 0; val < ARRAY_SIZE(ecs_reset); val++)\n\t\tnpe_cmd_write(npe, ecs_reset[val].reg, CMD_WR_ECS_REG,\n\t\t\t      ecs_reset[val].val);\n\n\t \n\t__raw_writel(CMD_CLR_PROFILE_CNT, &npe->regs->exec_status_cmd);\n\n\t__raw_writel(0, &npe->regs->exec_count);\n\t__raw_writel(0, &npe->regs->action_points[0]);\n\t__raw_writel(0, &npe->regs->action_points[1]);\n\t__raw_writel(0, &npe->regs->action_points[2]);\n\t__raw_writel(0, &npe->regs->action_points[3]);\n\t__raw_writel(0, &npe->regs->watch_count);\n\n\t \n\tval = cpu_ixp4xx_features(npe->rmap);\n\t \n\tregmap_write(npe->rmap, IXP4XX_EXP_CNFG2, val & ~reset_bit);\n\t \n\tregmap_write(npe->rmap, IXP4XX_EXP_CNFG2, val | reset_bit);\n\n\tfor (i = 0; i < MAX_RETRIES; i++) {\n\t\tval = cpu_ixp4xx_features(npe->rmap);\n\t\tif (val & reset_bit)\n\t\t\tbreak;\t \n\t\tudelay(1);\n\t}\n\tif (i == MAX_RETRIES)\n\t\treturn -ETIMEDOUT;\n\n\tnpe_stop(npe);\n\n\t \n\t__raw_writel(ctl, &npe->regs->messaging_control);\n\treturn 0;\n}\n\n\nint npe_send_message(struct npe *npe, const void *msg, const char *what)\n{\n\tconst u32 *send = msg;\n\tint cycles = 0;\n\n\tdebug_msg(npe, \"Trying to send message %s [%08X:%08X]\\n\",\n\t\t  what, send[0], send[1]);\n\n\tif (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE) {\n\t\tdebug_msg(npe, \"NPE input FIFO not empty\\n\");\n\t\treturn -EIO;\n\t}\n\n\t__raw_writel(send[0], &npe->regs->in_out_fifo);\n\n\tif (!(__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNF)) {\n\t\tdebug_msg(npe, \"NPE input FIFO full\\n\");\n\t\treturn -EIO;\n\t}\n\n\t__raw_writel(send[1], &npe->regs->in_out_fifo);\n\n\twhile ((cycles < MAX_RETRIES) &&\n\t       (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)) {\n\t\tudelay(1);\n\t\tcycles++;\n\t}\n\n\tif (cycles == MAX_RETRIES) {\n\t\tdebug_msg(npe, \"Timeout sending message\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n#if DEBUG_MSG > 1\n\tdebug_msg(npe, \"Sending a message took %i cycles\\n\", cycles);\n#endif\n\treturn 0;\n}\n\nint npe_recv_message(struct npe *npe, void *msg, const char *what)\n{\n\tu32 *recv = msg;\n\tint cycles = 0, cnt = 0;\n\n\tdebug_msg(npe, \"Trying to receive message %s\\n\", what);\n\n\twhile (cycles < MAX_RETRIES) {\n\t\tif (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE) {\n\t\t\trecv[cnt++] = __raw_readl(&npe->regs->in_out_fifo);\n\t\t\tif (cnt == 2)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tudelay(1);\n\t\t\tcycles++;\n\t\t}\n\t}\n\n\tswitch(cnt) {\n\tcase 1:\n\t\tdebug_msg(npe, \"Received [%08X]\\n\", recv[0]);\n\t\tbreak;\n\tcase 2:\n\t\tdebug_msg(npe, \"Received [%08X:%08X]\\n\", recv[0], recv[1]);\n\t\tbreak;\n\t}\n\n\tif (cycles == MAX_RETRIES) {\n\t\tdebug_msg(npe, \"Timeout waiting for message\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n#if DEBUG_MSG > 1\n\tdebug_msg(npe, \"Receiving a message took %i cycles\\n\", cycles);\n#endif\n\treturn 0;\n}\n\nint npe_send_recv_message(struct npe *npe, void *msg, const char *what)\n{\n\tint result;\n\tu32 *send = msg, recv[2];\n\n\tif ((result = npe_send_message(npe, msg, what)) != 0)\n\t\treturn result;\n\tif ((result = npe_recv_message(npe, recv, what)) != 0)\n\t\treturn result;\n\n\tif ((recv[0] != send[0]) || (recv[1] != send[1])) {\n\t\tdebug_msg(npe, \"Message %s: unexpected message received\\n\",\n\t\t\t  what);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\nint npe_load_firmware(struct npe *npe, const char *name, struct device *dev)\n{\n\tconst struct firmware *fw_entry;\n\n\tstruct dl_block {\n\t\tu32 type;\n\t\tu32 offset;\n\t} *blk;\n\n\tstruct dl_image {\n\t\tu32 magic;\n\t\tu32 id;\n\t\tu32 size;\n\t\tunion {\n\t\t\tDECLARE_FLEX_ARRAY(u32, data);\n\t\t\tDECLARE_FLEX_ARRAY(struct dl_block, blocks);\n\t\t};\n\t} *image;\n\n\tstruct dl_codeblock {\n\t\tu32 npe_addr;\n\t\tu32 size;\n\t\tu32 data[];\n\t} *cb;\n\n\tint i, j, err, data_size, instr_size, blocks, table_end;\n\tu32 cmd;\n\n\tif ((err = request_firmware(&fw_entry, name, dev)) != 0)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (fw_entry->size < sizeof(struct dl_image)) {\n\t\tprint_npe(KERN_ERR, npe, \"incomplete firmware file\\n\");\n\t\tgoto err;\n\t}\n\timage = (struct dl_image*)fw_entry->data;\n\n#if DEBUG_FW\n\tprint_npe(KERN_DEBUG, npe, \"firmware: %08X %08X %08X (0x%X bytes)\\n\",\n\t\t  image->magic, image->id, image->size, image->size * 4);\n#endif\n\n\tif (image->magic == swab32(FW_MAGIC)) {  \n\t\timage->id = swab32(image->id);\n\t\timage->size = swab32(image->size);\n\t} else if (image->magic != FW_MAGIC) {\n\t\tprint_npe(KERN_ERR, npe, \"bad firmware file magic: 0x%X\\n\",\n\t\t\t  image->magic);\n\t\tgoto err;\n\t}\n\tif ((image->size * 4 + sizeof(struct dl_image)) != fw_entry->size) {\n\t\tprint_npe(KERN_ERR, npe,\n\t\t\t  \"inconsistent size of firmware file\\n\");\n\t\tgoto err;\n\t}\n\tif (((image->id >> 24) & 0xF  ) != npe->id) {\n\t\tprint_npe(KERN_ERR, npe, \"firmware file NPE ID mismatch\\n\");\n\t\tgoto err;\n\t}\n\tif (image->magic == swab32(FW_MAGIC))\n\t\tfor (i = 0; i < image->size; i++)\n\t\t\timage->data[i] = swab32(image->data[i]);\n\n\tif (cpu_is_ixp42x() && ((image->id >> 28) & 0xF  )) {\n\t\tprint_npe(KERN_INFO, npe, \"IXP43x/IXP46x firmware ignored on \"\n\t\t\t  \"IXP42x\\n\");\n\t\tgoto err;\n\t}\n\n\tif (npe_running(npe)) {\n\t\tprint_npe(KERN_INFO, npe, \"unable to load firmware, NPE is \"\n\t\t\t  \"already running\\n\");\n\t\terr = -EBUSY;\n\t\tgoto err;\n\t}\n#if 0\n\tnpe_stop(npe);\n\tnpe_reset(npe);\n#endif\n\n\tprint_npe(KERN_INFO, npe, \"firmware functionality 0x%X, \"\n\t\t  \"revision 0x%X:%X\\n\", (image->id >> 16) & 0xFF,\n\t\t  (image->id >> 8) & 0xFF, image->id & 0xFF);\n\n\tif (cpu_is_ixp42x()) {\n\t\tif (!npe->id)\n\t\t\tinstr_size = NPE_A_42X_INSTR_SIZE;\n\t\telse\n\t\t\tinstr_size = NPE_B_AND_C_42X_INSTR_SIZE;\n\t\tdata_size = NPE_42X_DATA_SIZE;\n\t} else {\n\t\tinstr_size = NPE_46X_INSTR_SIZE;\n\t\tdata_size = NPE_46X_DATA_SIZE;\n\t}\n\n\tfor (blocks = 0; blocks * sizeof(struct dl_block) / 4 < image->size;\n\t     blocks++)\n\t\tif (image->blocks[blocks].type == FW_BLOCK_TYPE_EOF)\n\t\t\tbreak;\n\tif (blocks * sizeof(struct dl_block) / 4 >= image->size) {\n\t\tprint_npe(KERN_INFO, npe, \"firmware EOF block marker not \"\n\t\t\t  \"found\\n\");\n\t\tgoto err;\n\t}\n\n#if DEBUG_FW\n\tprint_npe(KERN_DEBUG, npe, \"%i firmware blocks found\\n\", blocks);\n#endif\n\n\ttable_end = blocks * sizeof(struct dl_block) / 4 + 1  ;\n\tfor (i = 0, blk = image->blocks; i < blocks; i++, blk++) {\n\t\tif (blk->offset > image->size - sizeof(struct dl_codeblock) / 4\n\t\t    || blk->offset < table_end) {\n\t\t\tprint_npe(KERN_INFO, npe, \"invalid offset 0x%X of \"\n\t\t\t\t  \"firmware block #%i\\n\", blk->offset, i);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcb = (struct dl_codeblock*)&image->data[blk->offset];\n\t\tif (blk->type == FW_BLOCK_TYPE_INSTR) {\n\t\t\tif (cb->npe_addr + cb->size > instr_size)\n\t\t\t\tgoto too_big;\n\t\t\tcmd = CMD_WR_INS_MEM;\n\t\t} else if (blk->type == FW_BLOCK_TYPE_DATA) {\n\t\t\tif (cb->npe_addr + cb->size > data_size)\n\t\t\t\tgoto too_big;\n\t\t\tcmd = CMD_WR_DATA_MEM;\n\t\t} else {\n\t\t\tprint_npe(KERN_INFO, npe, \"invalid firmware block #%i \"\n\t\t\t\t  \"type 0x%X\\n\", i, blk->type);\n\t\t\tgoto err;\n\t\t}\n\t\tif (blk->offset + sizeof(*cb) / 4 + cb->size > image->size) {\n\t\t\tprint_npe(KERN_INFO, npe, \"firmware block #%i doesn't \"\n\t\t\t\t  \"fit in firmware image: type %c, start 0x%X,\"\n\t\t\t\t  \" length 0x%X\\n\", i,\n\t\t\t\t  blk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',\n\t\t\t\t  cb->npe_addr, cb->size);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfor (j = 0; j < cb->size; j++)\n\t\t\tnpe_cmd_write(npe, cb->npe_addr + j, cmd, cb->data[j]);\n\t}\n\n\tnpe_start(npe);\n\tif (!npe_running(npe))\n\t\tprint_npe(KERN_ERR, npe, \"unable to start\\n\");\n\trelease_firmware(fw_entry);\n\treturn 0;\n\ntoo_big:\n\tprint_npe(KERN_INFO, npe, \"firmware block #%i doesn't fit in NPE \"\n\t\t  \"memory: type %c, start 0x%X, length 0x%X\\n\", i,\n\t\t  blk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',\n\t\t  cb->npe_addr, cb->size);\nerr:\n\trelease_firmware(fw_entry);\n\treturn err;\n}\n\n\nstruct npe *npe_request(unsigned id)\n{\n\tif (id < NPE_COUNT)\n\t\tif (npe_tab[id].valid)\n\t\t\tif (try_module_get(THIS_MODULE))\n\t\t\t\treturn &npe_tab[id];\n\treturn NULL;\n}\n\nvoid npe_release(struct npe *npe)\n{\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int ixp4xx_npe_probe(struct platform_device *pdev)\n{\n\tint i, found = 0;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *res;\n\tstruct regmap *rmap;\n\tu32 val;\n\n\t \n\trmap = syscon_regmap_lookup_by_compatible(\"syscon\");\n\tif (IS_ERR(rmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(rmap),\n\t\t\t\t     \"failed to look up syscon\\n\");\n\n\tfor (i = 0; i < NPE_COUNT; i++) {\n\t\tstruct npe *npe = &npe_tab[i];\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\treturn -ENODEV;\n\n\t\tval = cpu_ixp4xx_features(rmap);\n\n\t\tif (!(val & (IXP4XX_FEATURE_RESET_NPEA << i))) {\n\t\t\tdev_info(dev, \"NPE%d at %pR not available\\n\",\n\t\t\t\t i, res);\n\t\t\tcontinue;  \n\t\t}\n\t\tnpe->regs = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(npe->regs))\n\t\t\treturn PTR_ERR(npe->regs);\n\t\tnpe->rmap = rmap;\n\n\t\tif (npe_reset(npe)) {\n\t\t\tdev_info(dev, \"NPE%d at %pR does not reset\\n\",\n\t\t\t\t i, res);\n\t\t\tcontinue;\n\t\t}\n\t\tnpe->valid = 1;\n\t\tdev_info(dev, \"NPE%d at %pR registered\\n\", i, res);\n\t\tfound++;\n\t}\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\t \n\tif (IS_ENABLED(CONFIG_OF) && np)\n\t\tdevm_of_platform_populate(dev);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_npe_remove(struct platform_device *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < NPE_COUNT; i++)\n\t\tif (npe_tab[i].regs) {\n\t\t\tnpe_reset(&npe_tab[i]);\n\t\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ixp4xx_npe_of_match[] = {\n\t{\n\t\t.compatible = \"intel,ixp4xx-network-processing-engine\",\n        },\n\t{},\n};\n\nstatic struct platform_driver ixp4xx_npe_driver = {\n\t.driver = {\n\t\t.name           = \"ixp4xx-npe\",\n\t\t.of_match_table = ixp4xx_npe_of_match,\n\t},\n\t.probe = ixp4xx_npe_probe,\n\t.remove = ixp4xx_npe_remove,\n};\nmodule_platform_driver(ixp4xx_npe_driver);\n\nMODULE_AUTHOR(\"Krzysztof Halasa\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(NPE_A_FIRMWARE);\nMODULE_FIRMWARE(NPE_B_FIRMWARE);\nMODULE_FIRMWARE(NPE_C_FIRMWARE);\n\nEXPORT_SYMBOL(npe_names);\nEXPORT_SYMBOL(npe_running);\nEXPORT_SYMBOL(npe_request);\nEXPORT_SYMBOL(npe_release);\nEXPORT_SYMBOL(npe_load_firmware);\nEXPORT_SYMBOL(npe_send_message);\nEXPORT_SYMBOL(npe_recv_message);\nEXPORT_SYMBOL(npe_send_recv_message);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}