{
  "module_name": "sunxi_sram.c",
  "hash_id": "c0fe41204b7f39fb6318e2e6bba5e6411a7a3bb41e7da3e1b24aa5371f85f6e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/sunxi/sunxi_sram.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/soc/sunxi/sunxi_sram.h>\n\nstruct sunxi_sram_func {\n\tchar\t*func;\n\tu8\tval;\n\tu32\treg_val;\n};\n\nstruct sunxi_sram_data {\n\tchar\t\t\t*name;\n\tu8\t\t\treg;\n\tu8\t\t\toffset;\n\tu8\t\t\twidth;\n\tstruct sunxi_sram_func\t*func;\n\tstruct list_head\tlist;\n};\n\nstruct sunxi_sram_desc {\n\tstruct sunxi_sram_data\tdata;\n\tbool\t\t\tclaimed;\n};\n\n#define SUNXI_SRAM_MAP(_reg_val, _val, _func)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.func = _func,\t\t\t\t\t\\\n\t\t.val = _val,\t\t\t\t\t\\\n\t\t.reg_val = _reg_val,\t\t\t\t\\\n\t}\n\n#define SUNXI_SRAM_DATA(_name, _reg, _off, _width, ...)\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\t\\\n\t\t.offset = _off,\t\t\t\t\t\\\n\t\t.width = _width,\t\t\t\t\\\n\t\t.func = (struct sunxi_sram_func[]){\t\t\\\n\t\t\t__VA_ARGS__, { } },\t\t\t\\\n\t}\n\nstatic struct sunxi_sram_desc sun4i_a10_sram_a3_a4 = {\n\t.data\t= SUNXI_SRAM_DATA(\"A3-A4\", 0x4, 0x4, 2,\n\t\t\t\t  SUNXI_SRAM_MAP(0, 0, \"cpu\"),\n\t\t\t\t  SUNXI_SRAM_MAP(1, 1, \"emac\")),\n};\n\nstatic struct sunxi_sram_desc sun4i_a10_sram_c1 = {\n\t.data\t= SUNXI_SRAM_DATA(\"C1\", 0x0, 0x0, 31,\n\t\t\t\t  SUNXI_SRAM_MAP(0, 0, \"cpu\"),\n\t\t\t\t  SUNXI_SRAM_MAP(0x7fffffff, 1, \"ve\")),\n};\n\nstatic struct sunxi_sram_desc sun4i_a10_sram_d = {\n\t.data\t= SUNXI_SRAM_DATA(\"D\", 0x4, 0x0, 1,\n\t\t\t\t  SUNXI_SRAM_MAP(0, 0, \"cpu\"),\n\t\t\t\t  SUNXI_SRAM_MAP(1, 1, \"usb-otg\")),\n};\n\nstatic struct sunxi_sram_desc sun50i_a64_sram_c = {\n\t.data\t= SUNXI_SRAM_DATA(\"C\", 0x4, 24, 1,\n\t\t\t\t  SUNXI_SRAM_MAP(1, 0, \"cpu\"),\n\t\t\t\t  SUNXI_SRAM_MAP(0, 1, \"de2\")),\n};\n\nstatic const struct of_device_id sunxi_sram_dt_ids[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun4i-a10-sram-a3-a4\",\n\t\t.data\t\t= &sun4i_a10_sram_a3_a4.data,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun4i-a10-sram-c1\",\n\t\t.data\t\t= &sun4i_a10_sram_c1.data,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun4i-a10-sram-d\",\n\t\t.data\t\t= &sun4i_a10_sram_d.data,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-a64-sram-c\",\n\t\t.data\t\t= &sun50i_a64_sram_c.data,\n\t},\n\t{}\n};\n\nstatic struct device *sram_dev;\nstatic LIST_HEAD(claimed_sram);\nstatic DEFINE_SPINLOCK(sram_lock);\nstatic void __iomem *base;\n\nstatic int sunxi_sram_show(struct seq_file *s, void *data)\n{\n\tstruct device_node *sram_node, *section_node;\n\tconst struct sunxi_sram_data *sram_data;\n\tconst struct of_device_id *match;\n\tstruct sunxi_sram_func *func;\n\tconst __be32 *sram_addr_p, *section_addr_p;\n\tu32 val;\n\n\tseq_puts(s, \"Allwinner sunXi SRAM\\n\");\n\tseq_puts(s, \"--------------------\\n\\n\");\n\n\tfor_each_child_of_node(sram_dev->of_node, sram_node) {\n\t\tif (!of_device_is_compatible(sram_node, \"mmio-sram\"))\n\t\t\tcontinue;\n\n\t\tsram_addr_p = of_get_address(sram_node, 0, NULL, NULL);\n\n\t\tseq_printf(s, \"sram@%08x\\n\",\n\t\t\t   be32_to_cpu(*sram_addr_p));\n\n\t\tfor_each_child_of_node(sram_node, section_node) {\n\t\t\tmatch = of_match_node(sunxi_sram_dt_ids, section_node);\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t\tsram_data = match->data;\n\n\t\t\tsection_addr_p = of_get_address(section_node, 0,\n\t\t\t\t\t\t\tNULL, NULL);\n\n\t\t\tseq_printf(s, \"\\tsection@%04x\\t(%s)\\n\",\n\t\t\t\t   be32_to_cpu(*section_addr_p),\n\t\t\t\t   sram_data->name);\n\n\t\t\tval = readl(base + sram_data->reg);\n\t\t\tval >>= sram_data->offset;\n\t\t\tval &= GENMASK(sram_data->width - 1, 0);\n\n\t\t\tfor (func = sram_data->func; func->func; func++) {\n\t\t\t\tseq_printf(s, \"\\t\\t%s%c\\n\", func->func,\n\t\t\t\t\t   func->reg_val == val ?\n\t\t\t\t\t   '*' : ' ');\n\t\t\t}\n\t\t}\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sunxi_sram);\n\nstatic inline struct sunxi_sram_desc *to_sram_desc(const struct sunxi_sram_data *data)\n{\n\treturn container_of(data, struct sunxi_sram_desc, data);\n}\n\nstatic const struct sunxi_sram_data *sunxi_sram_of_parse(struct device_node *node,\n\t\t\t\t\t\t\t unsigned int *reg_value)\n{\n\tconst struct of_device_id *match;\n\tconst struct sunxi_sram_data *data;\n\tstruct sunxi_sram_func *func;\n\tstruct of_phandle_args args;\n\tu8 val;\n\tint ret;\n\n\tret = of_parse_phandle_with_fixed_args(node, \"allwinner,sram\", 1, 0,\n\t\t\t\t\t       &args);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!of_device_is_available(args.np)) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tval = args.args[0];\n\n\tmatch = of_match_node(sunxi_sram_dt_ids, args.np);\n\tif (!match) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata = match->data;\n\tif (!data) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (func = data->func; func->func; func++) {\n\t\tif (val == func->val) {\n\t\t\tif (reg_value)\n\t\t\t\t*reg_value = func->reg_val;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!func->func) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tof_node_put(args.np);\n\treturn match->data;\n\nerr:\n\tof_node_put(args.np);\n\treturn ERR_PTR(ret);\n}\n\nint sunxi_sram_claim(struct device *dev)\n{\n\tconst struct sunxi_sram_data *sram_data;\n\tstruct sunxi_sram_desc *sram_desc;\n\tunsigned int device;\n\tu32 val, mask;\n\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (!base)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!dev || !dev->of_node)\n\t\treturn -EINVAL;\n\n\tsram_data = sunxi_sram_of_parse(dev->of_node, &device);\n\tif (IS_ERR(sram_data))\n\t\treturn PTR_ERR(sram_data);\n\n\tsram_desc = to_sram_desc(sram_data);\n\n\tspin_lock(&sram_lock);\n\n\tif (sram_desc->claimed) {\n\t\tspin_unlock(&sram_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tmask = GENMASK(sram_data->offset + sram_data->width - 1,\n\t\t       sram_data->offset);\n\tval = readl(base + sram_data->reg);\n\tval &= ~mask;\n\twritel(val | ((device << sram_data->offset) & mask),\n\t       base + sram_data->reg);\n\n\tsram_desc->claimed = true;\n\tspin_unlock(&sram_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sunxi_sram_claim);\n\nvoid sunxi_sram_release(struct device *dev)\n{\n\tconst struct sunxi_sram_data *sram_data;\n\tstruct sunxi_sram_desc *sram_desc;\n\n\tif (!dev || !dev->of_node)\n\t\treturn;\n\n\tsram_data = sunxi_sram_of_parse(dev->of_node, NULL);\n\tif (IS_ERR(sram_data))\n\t\treturn;\n\n\tsram_desc = to_sram_desc(sram_data);\n\n\tspin_lock(&sram_lock);\n\tsram_desc->claimed = false;\n\tspin_unlock(&sram_lock);\n}\nEXPORT_SYMBOL(sunxi_sram_release);\n\nstruct sunxi_sramc_variant {\n\tint num_emac_clocks;\n\tbool has_ldo_ctrl;\n};\n\nstatic const struct sunxi_sramc_variant sun4i_a10_sramc_variant = {\n\t \n};\n\nstatic const struct sunxi_sramc_variant sun8i_h3_sramc_variant = {\n\t.num_emac_clocks = 1,\n};\n\nstatic const struct sunxi_sramc_variant sun20i_d1_sramc_variant = {\n\t.num_emac_clocks = 1,\n\t.has_ldo_ctrl = true,\n};\n\nstatic const struct sunxi_sramc_variant sun50i_a64_sramc_variant = {\n\t.num_emac_clocks = 1,\n};\n\nstatic const struct sunxi_sramc_variant sun50i_h616_sramc_variant = {\n\t.num_emac_clocks = 2,\n};\n\n#define SUNXI_SRAM_EMAC_CLOCK_REG\t0x30\n#define SUNXI_SYS_LDO_CTRL_REG\t\t0x150\n\nstatic bool sunxi_sram_regmap_accessible_reg(struct device *dev,\n\t\t\t\t\t     unsigned int reg)\n{\n\tconst struct sunxi_sramc_variant *variant = dev_get_drvdata(dev);\n\n\tif (reg >= SUNXI_SRAM_EMAC_CLOCK_REG &&\n\t    reg <  SUNXI_SRAM_EMAC_CLOCK_REG + variant->num_emac_clocks * 4)\n\t\treturn true;\n\tif (reg == SUNXI_SYS_LDO_CTRL_REG && variant->has_ldo_ctrl)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct regmap_config sunxi_sram_regmap_config = {\n\t.reg_bits       = 32,\n\t.val_bits       = 32,\n\t.reg_stride     = 4,\n\t \n\t.max_register   = SUNXI_SYS_LDO_CTRL_REG,\n\t \n\t.readable_reg\t= sunxi_sram_regmap_accessible_reg,\n\t.writeable_reg\t= sunxi_sram_regmap_accessible_reg,\n};\n\nstatic int __init sunxi_sram_probe(struct platform_device *pdev)\n{\n\tconst struct sunxi_sramc_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\n\tsram_dev = &pdev->dev;\n\n\tvariant = of_device_get_match_data(&pdev->dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\tdev_set_drvdata(dev, (struct sunxi_sramc_variant *)variant);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (variant->num_emac_clocks || variant->has_ldo_ctrl) {\n\t\tregmap = devm_regmap_init_mmio(dev, base, &sunxi_sram_regmap_config);\n\t\tif (IS_ERR(regmap))\n\t\t\treturn PTR_ERR(regmap);\n\t}\n\n\tof_platform_populate(dev->of_node, NULL, NULL, dev);\n\n\tdebugfs_create_file(\"sram\", 0444, NULL, NULL, &sunxi_sram_fops);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sunxi_sram_dt_match[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-sram-controller\",\n\t\t.data = &sun4i_a10_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-system-control\",\n\t\t.data = &sun4i_a10_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun5i-a13-system-control\",\n\t\t.data = &sun4i_a10_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a23-system-control\",\n\t\t.data = &sun4i_a10_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-h3-system-control\",\n\t\t.data = &sun8i_h3_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun20i-d1-system-control\",\n\t\t.data = &sun20i_d1_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-a64-sram-controller\",\n\t\t.data = &sun50i_a64_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-a64-system-control\",\n\t\t.data = &sun50i_a64_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h5-system-control\",\n\t\t.data = &sun50i_a64_sramc_variant,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun50i-h616-system-control\",\n\t\t.data = &sun50i_h616_sramc_variant,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sunxi_sram_dt_match);\n\nstatic struct platform_driver sunxi_sram_driver = {\n\t.driver = {\n\t\t.name\t\t= \"sunxi-sram\",\n\t\t.of_match_table\t= sunxi_sram_dt_match,\n\t},\n};\nbuiltin_platform_driver_probe(sunxi_sram_driver, sunxi_sram_probe);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner sunXi SRAM Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}