{
  "module_name": "sifive_ccache.c",
  "hash_id": "ee879fa1ad00ad9ea1c15f101d9a744fad28eb2e5c7f3ef10c9e1cb846e3c8cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/sifive/sifive_ccache.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CCACHE: \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/interrupt.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/device.h>\n#include <linux/bitfield.h>\n#include <asm/cacheinfo.h>\n#include <soc/sifive/sifive_ccache.h>\n\n#define SIFIVE_CCACHE_DIRECCFIX_LOW 0x100\n#define SIFIVE_CCACHE_DIRECCFIX_HIGH 0x104\n#define SIFIVE_CCACHE_DIRECCFIX_COUNT 0x108\n\n#define SIFIVE_CCACHE_DIRECCFAIL_LOW 0x120\n#define SIFIVE_CCACHE_DIRECCFAIL_HIGH 0x124\n#define SIFIVE_CCACHE_DIRECCFAIL_COUNT 0x128\n\n#define SIFIVE_CCACHE_DATECCFIX_LOW 0x140\n#define SIFIVE_CCACHE_DATECCFIX_HIGH 0x144\n#define SIFIVE_CCACHE_DATECCFIX_COUNT 0x148\n\n#define SIFIVE_CCACHE_DATECCFAIL_LOW 0x160\n#define SIFIVE_CCACHE_DATECCFAIL_HIGH 0x164\n#define SIFIVE_CCACHE_DATECCFAIL_COUNT 0x168\n\n#define SIFIVE_CCACHE_CONFIG 0x00\n#define SIFIVE_CCACHE_CONFIG_BANK_MASK GENMASK_ULL(7, 0)\n#define SIFIVE_CCACHE_CONFIG_WAYS_MASK GENMASK_ULL(15, 8)\n#define SIFIVE_CCACHE_CONFIG_SETS_MASK GENMASK_ULL(23, 16)\n#define SIFIVE_CCACHE_CONFIG_BLKS_MASK GENMASK_ULL(31, 24)\n\n#define SIFIVE_CCACHE_WAYENABLE 0x08\n#define SIFIVE_CCACHE_ECCINJECTERR 0x40\n\n#define SIFIVE_CCACHE_MAX_ECCINTR 4\n\nstatic void __iomem *ccache_base;\nstatic int g_irq[SIFIVE_CCACHE_MAX_ECCINTR];\nstatic struct riscv_cacheinfo_ops ccache_cache_ops;\nstatic int level;\n\nenum {\n\tDIR_CORR = 0,\n\tDATA_CORR,\n\tDATA_UNCORR,\n\tDIR_UNCORR,\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic struct dentry *sifive_test;\n\nstatic ssize_t ccache_write(struct file *file, const char __user *data,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned int val;\n\n\tif (kstrtouint_from_user(data, count, 0, &val))\n\t\treturn -EINVAL;\n\tif ((val < 0xFF) || (val >= 0x10000 && val < 0x100FF))\n\t\twritel(val, ccache_base + SIFIVE_CCACHE_ECCINJECTERR);\n\telse\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic const struct file_operations ccache_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.write = ccache_write\n};\n\nstatic void setup_sifive_debug(void)\n{\n\tsifive_test = debugfs_create_dir(\"sifive_ccache_cache\", NULL);\n\n\tdebugfs_create_file(\"sifive_debug_inject_error\", 0200,\n\t\t\t    sifive_test, NULL, &ccache_fops);\n}\n#endif\n\nstatic void ccache_config_read(void)\n{\n\tu32 cfg;\n\n\tcfg = readl(ccache_base + SIFIVE_CCACHE_CONFIG);\n\tpr_info(\"%llu banks, %llu ways, sets/bank=%llu, bytes/block=%llu\\n\",\n\t\tFIELD_GET(SIFIVE_CCACHE_CONFIG_BANK_MASK, cfg),\n\t\tFIELD_GET(SIFIVE_CCACHE_CONFIG_WAYS_MASK, cfg),\n\t\tBIT_ULL(FIELD_GET(SIFIVE_CCACHE_CONFIG_SETS_MASK, cfg)),\n\t\tBIT_ULL(FIELD_GET(SIFIVE_CCACHE_CONFIG_BLKS_MASK, cfg)));\n\n\tcfg = readl(ccache_base + SIFIVE_CCACHE_WAYENABLE);\n\tpr_info(\"Index of the largest way enabled: %u\\n\", cfg);\n}\n\nstatic const struct of_device_id sifive_ccache_ids[] = {\n\t{ .compatible = \"sifive,fu540-c000-ccache\" },\n\t{ .compatible = \"sifive,fu740-c000-ccache\" },\n\t{ .compatible = \"sifive,ccache0\" },\n\t{   }\n};\n\nstatic ATOMIC_NOTIFIER_HEAD(ccache_err_chain);\n\nint register_sifive_ccache_error_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&ccache_err_chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_sifive_ccache_error_notifier);\n\nint unregister_sifive_ccache_error_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&ccache_err_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_sifive_ccache_error_notifier);\n\nstatic int ccache_largest_wayenabled(void)\n{\n\treturn readl(ccache_base + SIFIVE_CCACHE_WAYENABLE) & 0xFF;\n}\n\nstatic ssize_t number_of_ways_enabled_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ccache_largest_wayenabled());\n}\n\nstatic DEVICE_ATTR_RO(number_of_ways_enabled);\n\nstatic struct attribute *priv_attrs[] = {\n\t&dev_attr_number_of_ways_enabled.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group priv_attr_group = {\n\t.attrs = priv_attrs,\n};\n\nstatic const struct attribute_group *ccache_get_priv_group(struct cacheinfo\n\t\t\t\t\t\t\t   *this_leaf)\n{\n\t \n\tif (this_leaf->level == level)\n\t\treturn &priv_attr_group;\n\telse\n\t\treturn NULL;\n}\n\nstatic irqreturn_t ccache_int_handler(int irq, void *device)\n{\n\tunsigned int add_h, add_l;\n\n\tif (irq == g_irq[DIR_CORR]) {\n\t\tadd_h = readl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_HIGH);\n\t\tadd_l = readl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_LOW);\n\t\tpr_err(\"DirError @ 0x%08X.%08X\\n\", add_h, add_l);\n\t\t \n\t\treadl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_COUNT);\n\t\tatomic_notifier_call_chain(&ccache_err_chain,\n\t\t\t\t\t   SIFIVE_CCACHE_ERR_TYPE_CE,\n\t\t\t\t\t   \"DirECCFix\");\n\t}\n\tif (irq == g_irq[DIR_UNCORR]) {\n\t\tadd_h = readl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_HIGH);\n\t\tadd_l = readl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_LOW);\n\t\t \n\t\treadl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_COUNT);\n\t\tatomic_notifier_call_chain(&ccache_err_chain,\n\t\t\t\t\t   SIFIVE_CCACHE_ERR_TYPE_UE,\n\t\t\t\t\t   \"DirECCFail\");\n\t\tpanic(\"CCACHE: DirFail @ 0x%08X.%08X\\n\", add_h, add_l);\n\t}\n\tif (irq == g_irq[DATA_CORR]) {\n\t\tadd_h = readl(ccache_base + SIFIVE_CCACHE_DATECCFIX_HIGH);\n\t\tadd_l = readl(ccache_base + SIFIVE_CCACHE_DATECCFIX_LOW);\n\t\tpr_err(\"DataError @ 0x%08X.%08X\\n\", add_h, add_l);\n\t\t \n\t\treadl(ccache_base + SIFIVE_CCACHE_DATECCFIX_COUNT);\n\t\tatomic_notifier_call_chain(&ccache_err_chain,\n\t\t\t\t\t   SIFIVE_CCACHE_ERR_TYPE_CE,\n\t\t\t\t\t   \"DatECCFix\");\n\t}\n\tif (irq == g_irq[DATA_UNCORR]) {\n\t\tadd_h = readl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_HIGH);\n\t\tadd_l = readl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_LOW);\n\t\tpr_err(\"DataFail @ 0x%08X.%08X\\n\", add_h, add_l);\n\t\t \n\t\treadl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_COUNT);\n\t\tatomic_notifier_call_chain(&ccache_err_chain,\n\t\t\t\t\t   SIFIVE_CCACHE_ERR_TYPE_UE,\n\t\t\t\t\t   \"DatECCFail\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init sifive_ccache_init(void)\n{\n\tstruct device_node *np;\n\tstruct resource res;\n\tint i, rc, intr_num;\n\n\tnp = of_find_matching_node(NULL, sifive_ccache_ids);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (of_address_to_resource(np, 0, &res)) {\n\t\trc = -ENODEV;\n\t\tgoto err_node_put;\n\t}\n\n\tccache_base = ioremap(res.start, resource_size(&res));\n\tif (!ccache_base) {\n\t\trc = -ENOMEM;\n\t\tgoto err_node_put;\n\t}\n\n\tif (of_property_read_u32(np, \"cache-level\", &level)) {\n\t\trc = -ENOENT;\n\t\tgoto err_unmap;\n\t}\n\n\tintr_num = of_property_count_u32_elems(np, \"interrupts\");\n\tif (!intr_num) {\n\t\tpr_err(\"No interrupts property\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_unmap;\n\t}\n\n\tfor (i = 0; i < intr_num; i++) {\n\t\tg_irq[i] = irq_of_parse_and_map(np, i);\n\t\trc = request_irq(g_irq[i], ccache_int_handler, 0, \"ccache_ecc\",\n\t\t\t\t NULL);\n\t\tif (rc) {\n\t\t\tpr_err(\"Could not request IRQ %d\\n\", g_irq[i]);\n\t\t\tgoto err_free_irq;\n\t\t}\n\t}\n\tof_node_put(np);\n\n\tccache_config_read();\n\n\tccache_cache_ops.get_priv_group = ccache_get_priv_group;\n\triscv_set_cacheinfo_ops(&ccache_cache_ops);\n\n#ifdef CONFIG_DEBUG_FS\n\tsetup_sifive_debug();\n#endif\n\treturn 0;\n\nerr_free_irq:\n\twhile (--i >= 0)\n\t\tfree_irq(g_irq[i], NULL);\nerr_unmap:\n\tiounmap(ccache_base);\nerr_node_put:\n\tof_node_put(np);\n\treturn rc;\n}\n\ndevice_initcall(sifive_ccache_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}