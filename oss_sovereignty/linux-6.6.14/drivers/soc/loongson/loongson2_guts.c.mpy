{
  "module_name": "loongson2_guts.c",
  "hash_id": "f1c2facdf496168ad4b24aed2c380a97c2ca4b561373375621b7e0e4631679ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/loongson/loongson2_guts.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of_fdt.h>\n#include <linux/sys_soc.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\nstatic struct soc_device_attribute soc_dev_attr;\nstatic struct soc_device *soc_dev;\n\n \nstruct scfg_guts {\n\tu32     svr;             \n\tu8      res0[4];\n\tu16     feature;         \n\tu32     vendor;          \n\tu8      res1[6];\n\tu32     id;\n\tu8      res2[0x3ff8 - 0x18];\n\tu32     chip;\n};\n\nstatic struct guts {\n\tstruct scfg_guts __iomem *regs;\n\tbool little_endian;\n} *guts;\n\nstruct loongson2_soc_die_attr {\n\tchar\t*die;\n\tu32\tsvr;\n\tu32\tmask;\n};\n\n \nstatic const struct loongson2_soc_die_attr loongson2_soc_die[] = {\n\n\t \n\n\t \n\t{ .die\t\t= \"2K1000\",\n\t  .svr\t\t= 0x00000013,\n\t  .mask\t\t= 0x000000ff,\n\t},\n\t{ },\n};\n\nstatic const struct loongson2_soc_die_attr *loongson2_soc_die_match(\n\tu32 svr, const struct loongson2_soc_die_attr *matches)\n{\n\twhile (matches->svr) {\n\t\tif (matches->svr == (svr & matches->mask))\n\t\t\treturn matches;\n\t\tmatches++;\n\t}\n\n\treturn NULL;\n}\n\nstatic u32 loongson2_guts_get_svr(void)\n{\n\tu32 svr = 0;\n\n\tif (!guts || !guts->regs)\n\t\treturn svr;\n\n\tif (guts->little_endian)\n\t\tsvr = ioread32(&guts->regs->svr);\n\telse\n\t\tsvr = ioread32be(&guts->regs->svr);\n\n\treturn svr;\n}\n\nstatic int loongson2_guts_probe(struct platform_device *pdev)\n{\n\tstruct device_node *root, *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tconst struct loongson2_soc_die_attr *soc_die;\n\tconst char *machine;\n\tu32 svr;\n\n\t \n\tguts = devm_kzalloc(dev, sizeof(*guts), GFP_KERNEL);\n\tif (!guts)\n\t\treturn -ENOMEM;\n\n\tguts->little_endian = of_property_read_bool(np, \"little-endian\");\n\n\tguts->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(guts->regs))\n\t\treturn PTR_ERR(guts->regs);\n\n\t \n\troot = of_find_node_by_path(\"/\");\n\tif (of_property_read_string(root, \"model\", &machine))\n\t\tof_property_read_string_index(root, \"compatible\", 0, &machine);\n\tof_node_put(root);\n\tif (machine)\n\t\tsoc_dev_attr.machine = devm_kstrdup(dev, machine, GFP_KERNEL);\n\n\tsvr = loongson2_guts_get_svr();\n\tsoc_die = loongson2_soc_die_match(svr, loongson2_soc_die);\n\tif (soc_die) {\n\t\tsoc_dev_attr.family = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t     \"Loongson %s\", soc_die->die);\n\t} else {\n\t\tsoc_dev_attr.family = devm_kasprintf(dev, GFP_KERNEL, \"Loongson\");\n\t}\n\tif (!soc_dev_attr.family)\n\t\treturn -ENOMEM;\n\tsoc_dev_attr.soc_id = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t     \"svr:0x%08x\", svr);\n\tif (!soc_dev_attr.soc_id)\n\t\treturn -ENOMEM;\n\tsoc_dev_attr.revision = devm_kasprintf(dev, GFP_KERNEL, \"%d.%d\",\n\t\t\t\t\t       (svr >>  4) & 0xf, svr & 0xf);\n\tif (!soc_dev_attr.revision)\n\t\treturn -ENOMEM;\n\n\tsoc_dev = soc_device_register(&soc_dev_attr);\n\tif (IS_ERR(soc_dev))\n\t\treturn PTR_ERR(soc_dev);\n\n\tpr_info(\"Machine: %s\\n\", soc_dev_attr.machine);\n\tpr_info(\"SoC family: %s\\n\", soc_dev_attr.family);\n\tpr_info(\"SoC ID: %s, Revision: %s\\n\",\n\t\tsoc_dev_attr.soc_id, soc_dev_attr.revision);\n\n\treturn 0;\n}\n\nstatic int loongson2_guts_remove(struct platform_device *dev)\n{\n\tsoc_device_unregister(soc_dev);\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id loongson2_guts_of_match[] = {\n\t{ .compatible = \"loongson,ls2k-chipid\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, loongson2_guts_of_match);\n\nstatic struct platform_driver loongson2_guts_driver = {\n\t.driver = {\n\t\t.name = \"loongson2-guts\",\n\t\t.of_match_table = loongson2_guts_of_match,\n\t},\n\t.probe = loongson2_guts_probe,\n\t.remove = loongson2_guts_remove,\n};\n\nstatic int __init loongson2_guts_init(void)\n{\n\treturn platform_driver_register(&loongson2_guts_driver);\n}\ncore_initcall(loongson2_guts_init);\n\nstatic void __exit loongson2_guts_exit(void)\n{\n\tplatform_driver_unregister(&loongson2_guts_driver);\n}\nmodule_exit(loongson2_guts_exit);\n\nMODULE_DESCRIPTION(\"Loongson2 GUTS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}