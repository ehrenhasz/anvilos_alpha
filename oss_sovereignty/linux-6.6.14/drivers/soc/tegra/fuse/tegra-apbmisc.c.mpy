{
  "module_name": "tegra-apbmisc.c",
  "hash_id": "83c3996ad197c8e8b14a08304e3ee66b7a058134ff80eb06d779ff2229f90c5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/fuse/tegra-apbmisc.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n\n#include \"fuse.h\"\n\n#define FUSE_SKU_INFO\t0x10\n\n#define ERD_ERR_CONFIG 0x120c\n#define ERD_MASK_INBAND_ERR 0x1\n\n#define PMC_STRAPPING_OPT_A_RAM_CODE_SHIFT\t4\n#define PMC_STRAPPING_OPT_A_RAM_CODE_MASK_LONG\t\\\n\t(0xf << PMC_STRAPPING_OPT_A_RAM_CODE_SHIFT)\n#define PMC_STRAPPING_OPT_A_RAM_CODE_MASK_SHORT\t\\\n\t(0x3 << PMC_STRAPPING_OPT_A_RAM_CODE_SHIFT)\n\nstatic void __iomem *apbmisc_base;\nstatic bool long_ram_code;\nstatic u32 strapping;\nstatic u32 chipid;\n\nu32 tegra_read_chipid(void)\n{\n\tWARN(!chipid, \"Tegra APB MISC not yet available\\n\");\n\n\treturn chipid;\n}\n\nu8 tegra_get_chip_id(void)\n{\n\treturn (tegra_read_chipid() >> 8) & 0xff;\n}\n\nu8 tegra_get_major_rev(void)\n{\n\treturn (tegra_read_chipid() >> 4) & 0xf;\n}\n\nu8 tegra_get_minor_rev(void)\n{\n\treturn (tegra_read_chipid() >> 16) & 0xf;\n}\n\nu8 tegra_get_platform(void)\n{\n\treturn (tegra_read_chipid() >> 20) & 0xf;\n}\n\nbool tegra_is_silicon(void)\n{\n\tswitch (tegra_get_chip_id()) {\n\tcase TEGRA194:\n\tcase TEGRA234:\n\tcase TEGRA264:\n\t\tif (tegra_get_platform() == 0)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nu32 tegra_read_straps(void)\n{\n\tWARN(!chipid, \"Tegra ABP MISC not yet available\\n\");\n\n\treturn strapping;\n}\n\nu32 tegra_read_ram_code(void)\n{\n\tu32 straps = tegra_read_straps();\n\n\tif (long_ram_code)\n\t\tstraps &= PMC_STRAPPING_OPT_A_RAM_CODE_MASK_LONG;\n\telse\n\t\tstraps &= PMC_STRAPPING_OPT_A_RAM_CODE_MASK_SHORT;\n\n\treturn straps >> PMC_STRAPPING_OPT_A_RAM_CODE_SHIFT;\n}\nEXPORT_SYMBOL_GPL(tegra_read_ram_code);\n\n \nint tegra194_miscreg_mask_serror(void)\n{\n\tif (!apbmisc_base)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!of_machine_is_compatible(\"nvidia,tegra194\")) {\n\t\tWARN(1, \"Only supported for Tegra194 devices!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twritel_relaxed(ERD_MASK_INBAND_ERR,\n\t\t       apbmisc_base + ERD_ERR_CONFIG);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra194_miscreg_mask_serror);\n\nstatic const struct of_device_id apbmisc_match[] __initconst = {\n\t{ .compatible = \"nvidia,tegra20-apbmisc\", },\n\t{ .compatible = \"nvidia,tegra186-misc\", },\n\t{ .compatible = \"nvidia,tegra194-misc\", },\n\t{ .compatible = \"nvidia,tegra234-misc\", },\n\t{},\n};\n\nvoid __init tegra_init_revision(void)\n{\n\tu8 chip_id, minor_rev;\n\n\tchip_id = tegra_get_chip_id();\n\tminor_rev = tegra_get_minor_rev();\n\n\tswitch (minor_rev) {\n\tcase 1:\n\t\ttegra_sku_info.revision = TEGRA_REVISION_A01;\n\t\tbreak;\n\tcase 2:\n\t\ttegra_sku_info.revision = TEGRA_REVISION_A02;\n\t\tbreak;\n\tcase 3:\n\t\tif (chip_id == TEGRA20 && (tegra_fuse_read_spare(18) ||\n\t\t\t\t\t   tegra_fuse_read_spare(19)))\n\t\t\ttegra_sku_info.revision = TEGRA_REVISION_A03p;\n\t\telse\n\t\t\ttegra_sku_info.revision = TEGRA_REVISION_A03;\n\t\tbreak;\n\tcase 4:\n\t\ttegra_sku_info.revision = TEGRA_REVISION_A04;\n\t\tbreak;\n\tdefault:\n\t\ttegra_sku_info.revision = TEGRA_REVISION_UNKNOWN;\n\t}\n\n\ttegra_sku_info.sku_id = tegra_fuse_read_early(FUSE_SKU_INFO);\n\ttegra_sku_info.platform = tegra_get_platform();\n}\n\nvoid __init tegra_init_apbmisc(void)\n{\n\tvoid __iomem *strapping_base;\n\tstruct resource apbmisc, straps;\n\tstruct device_node *np;\n\n\tnp = of_find_matching_node(NULL, apbmisc_match);\n\tif (!np) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ARM) && soc_is_tegra()) {\n\t\t\t \n\t\t\tapbmisc.start = 0x70000800;\n\t\t\tapbmisc.end = 0x70000863;\n\t\t\tapbmisc.flags = IORESOURCE_MEM;\n\n\t\t\t \n\t\t\tif (of_machine_is_compatible(\"nvidia,tegra124\")) {\n\t\t\t\tstraps.start = 0x7000e864;\n\t\t\t\tstraps.end = 0x7000e867;\n\t\t\t} else {\n\t\t\t\tstraps.start = 0x70000008;\n\t\t\t\tstraps.end = 0x7000000b;\n\t\t\t}\n\n\t\t\tstraps.flags = IORESOURCE_MEM;\n\n\t\t\tpr_warn(\"Using APBMISC region %pR\\n\", &apbmisc);\n\t\t\tpr_warn(\"Using strapping options registers %pR\\n\",\n\t\t\t\t&straps);\n\t\t} else {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tif (of_address_to_resource(np, 0, &apbmisc) < 0) {\n\t\t\tpr_err(\"failed to get APBMISC registers\\n\");\n\t\t\tgoto put;\n\t\t}\n\n\t\tif (of_address_to_resource(np, 1, &straps) < 0) {\n\t\t\tpr_err(\"failed to get strapping options registers\\n\");\n\t\t\tgoto put;\n\t\t}\n\t}\n\n\tapbmisc_base = ioremap(apbmisc.start, resource_size(&apbmisc));\n\tif (!apbmisc_base) {\n\t\tpr_err(\"failed to map APBMISC registers\\n\");\n\t} else {\n\t\tchipid = readl_relaxed(apbmisc_base + 4);\n\t}\n\n\tstrapping_base = ioremap(straps.start, resource_size(&straps));\n\tif (!strapping_base) {\n\t\tpr_err(\"failed to map strapping options registers\\n\");\n\t} else {\n\t\tstrapping = readl_relaxed(strapping_base);\n\t\tiounmap(strapping_base);\n\t}\n\n\tlong_ram_code = of_property_read_bool(np, \"nvidia,long-ram-code\");\n\nput:\n\tof_node_put(np);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}