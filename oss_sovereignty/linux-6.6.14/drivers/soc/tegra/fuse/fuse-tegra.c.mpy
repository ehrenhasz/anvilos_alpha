{
  "module_name": "fuse-tegra.c",
  "hash_id": "60a6206404380ff55a28317e92a756bbb6799b7b350c8297b0c2bf4947d92b8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/fuse/fuse-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/nvmem-provider.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n\n#include \"fuse.h\"\n\nstruct tegra_sku_info tegra_sku_info;\nEXPORT_SYMBOL(tegra_sku_info);\n\nstatic const char *tegra_revision_name[TEGRA_REVISION_MAX] = {\n\t[TEGRA_REVISION_UNKNOWN] = \"unknown\",\n\t[TEGRA_REVISION_A01]     = \"A01\",\n\t[TEGRA_REVISION_A02]     = \"A02\",\n\t[TEGRA_REVISION_A03]     = \"A03\",\n\t[TEGRA_REVISION_A03p]    = \"A03 prime\",\n\t[TEGRA_REVISION_A04]     = \"A04\",\n};\n\nstatic const char *tegra_platform_name[TEGRA_PLATFORM_MAX] = {\n\t[TEGRA_PLATFORM_SILICON]\t\t\t= \"Silicon\",\n\t[TEGRA_PLATFORM_QT]\t\t\t\t= \"QT\",\n\t[TEGRA_PLATFORM_SYSTEM_FPGA]\t\t\t= \"System FPGA\",\n\t[TEGRA_PLATFORM_UNIT_FPGA]\t\t\t= \"Unit FPGA\",\n\t[TEGRA_PLATFORM_ASIM_QT]\t\t\t= \"Asim QT\",\n\t[TEGRA_PLATFORM_ASIM_LINSIM]\t\t\t= \"Asim Linsim\",\n\t[TEGRA_PLATFORM_DSIM_ASIM_LINSIM]\t\t= \"Dsim Asim Linsim\",\n\t[TEGRA_PLATFORM_VERIFICATION_SIMULATION]\t= \"Verification Simulation\",\n\t[TEGRA_PLATFORM_VDK]\t\t\t\t= \"VDK\",\n\t[TEGRA_PLATFORM_VSP]\t\t\t\t= \"VSP\",\n};\n\nstatic const struct of_device_id car_match[] __initconst = {\n\t{ .compatible = \"nvidia,tegra20-car\", },\n\t{ .compatible = \"nvidia,tegra30-car\", },\n\t{ .compatible = \"nvidia,tegra114-car\", },\n\t{ .compatible = \"nvidia,tegra124-car\", },\n\t{ .compatible = \"nvidia,tegra132-car\", },\n\t{ .compatible = \"nvidia,tegra210-car\", },\n\t{},\n};\n\nstatic struct tegra_fuse *fuse = &(struct tegra_fuse) {\n\t.base = NULL,\n\t.soc = NULL,\n};\n\nstatic const struct of_device_id tegra_fuse_match[] = {\n#ifdef CONFIG_ARCH_TEGRA_234_SOC\n\t{ .compatible = \"nvidia,tegra234-efuse\", .data = &tegra234_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_194_SOC\n\t{ .compatible = \"nvidia,tegra194-efuse\", .data = &tegra194_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_186_SOC\n\t{ .compatible = \"nvidia,tegra186-efuse\", .data = &tegra186_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_210_SOC\n\t{ .compatible = \"nvidia,tegra210-efuse\", .data = &tegra210_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_132_SOC\n\t{ .compatible = \"nvidia,tegra132-efuse\", .data = &tegra124_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_124_SOC\n\t{ .compatible = \"nvidia,tegra124-efuse\", .data = &tegra124_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_114_SOC\n\t{ .compatible = \"nvidia,tegra114-efuse\", .data = &tegra114_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_3x_SOC\n\t{ .compatible = \"nvidia,tegra30-efuse\", .data = &tegra30_fuse_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_2x_SOC\n\t{ .compatible = \"nvidia,tegra20-efuse\", .data = &tegra20_fuse_soc },\n#endif\n\t{   }\n};\n\nstatic int tegra_fuse_read(void *priv, unsigned int offset, void *value,\n\t\t\t   size_t bytes)\n{\n\tunsigned int count = bytes / 4, i;\n\tstruct tegra_fuse *fuse = priv;\n\tu32 *buffer = value;\n\n\tfor (i = 0; i < count; i++)\n\t\tbuffer[i] = fuse->read(fuse, offset + i * 4);\n\n\treturn 0;\n}\n\nstatic void tegra_fuse_restore(void *base)\n{\n\tfuse->base = (void __iomem *)base;\n\tfuse->clk = NULL;\n}\n\nstatic int tegra_fuse_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base = fuse->base;\n\tstruct nvmem_config nvmem;\n\tstruct resource *res;\n\tint err;\n\n\terr = devm_add_action(&pdev->dev, tegra_fuse_restore, (void __force *)base);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfuse->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(fuse->base))\n\t\treturn PTR_ERR(fuse->base);\n\tfuse->phys = res->start;\n\n\tfuse->clk = devm_clk_get(&pdev->dev, \"fuse\");\n\tif (IS_ERR(fuse->clk)) {\n\t\tif (PTR_ERR(fuse->clk) != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"failed to get FUSE clock: %ld\",\n\t\t\t\tPTR_ERR(fuse->clk));\n\n\t\treturn PTR_ERR(fuse->clk);\n\t}\n\n\tplatform_set_drvdata(pdev, fuse);\n\tfuse->dev = &pdev->dev;\n\n\terr = devm_pm_runtime_enable(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tif (fuse->soc->probe) {\n\t\terr = fuse->soc->probe(fuse);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmemset(&nvmem, 0, sizeof(nvmem));\n\tnvmem.dev = &pdev->dev;\n\tnvmem.name = \"fuse\";\n\tnvmem.id = -1;\n\tnvmem.owner = THIS_MODULE;\n\tnvmem.cells = fuse->soc->cells;\n\tnvmem.ncells = fuse->soc->num_cells;\n\tnvmem.keepout = fuse->soc->keepouts;\n\tnvmem.nkeepout = fuse->soc->num_keepouts;\n\tnvmem.type = NVMEM_TYPE_OTP;\n\tnvmem.read_only = true;\n\tnvmem.root_only = false;\n\tnvmem.reg_read = tegra_fuse_read;\n\tnvmem.size = fuse->soc->info->size;\n\tnvmem.word_size = 4;\n\tnvmem.stride = 4;\n\tnvmem.priv = fuse;\n\n\tfuse->nvmem = devm_nvmem_register(&pdev->dev, &nvmem);\n\tif (IS_ERR(fuse->nvmem)) {\n\t\terr = PTR_ERR(fuse->nvmem);\n\t\tdev_err(&pdev->dev, \"failed to register NVMEM device: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tfuse->rst = devm_reset_control_get_optional(&pdev->dev, \"fuse\");\n\tif (IS_ERR(fuse->rst)) {\n\t\terr = PTR_ERR(fuse->rst);\n\t\tdev_err(&pdev->dev, \"failed to get FUSE reset: %pe\\n\",\n\t\t\tfuse->rst);\n\t\treturn err;\n\t}\n\n\t \n\terr = pm_runtime_resume_and_get(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = reset_control_reset(fuse->rst);\n\tpm_runtime_put(&pdev->dev);\n\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to reset FUSE: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tiounmap(base);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_fuse_runtime_resume(struct device *dev)\n{\n\tint err;\n\n\terr = clk_prepare_enable(fuse->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable FUSE clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_fuse_runtime_suspend(struct device *dev)\n{\n\tclk_disable_unprepare(fuse->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_fuse_suspend(struct device *dev)\n{\n\tint ret;\n\n\t \n\tif (fuse->soc->clk_suspend_on)\n\t\tret = pm_runtime_resume_and_get(dev);\n\telse\n\t\tret = pm_runtime_force_suspend(dev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused tegra_fuse_resume(struct device *dev)\n{\n\tint ret = 0;\n\n\tif (fuse->soc->clk_suspend_on)\n\t\tpm_runtime_put(dev);\n\telse\n\t\tret = pm_runtime_force_resume(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops tegra_fuse_pm = {\n\tSET_RUNTIME_PM_OPS(tegra_fuse_runtime_suspend, tegra_fuse_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_fuse_suspend, tegra_fuse_resume)\n};\n\nstatic struct platform_driver tegra_fuse_driver = {\n\t.driver = {\n\t\t.name = \"tegra-fuse\",\n\t\t.of_match_table = tegra_fuse_match,\n\t\t.pm = &tegra_fuse_pm,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = tegra_fuse_probe,\n};\nbuiltin_platform_driver(tegra_fuse_driver);\n\nu32 __init tegra_fuse_read_spare(unsigned int spare)\n{\n\tunsigned int offset = fuse->soc->info->spare + spare * 4;\n\n\treturn fuse->read_early(fuse, offset) & 1;\n}\n\nu32 __init tegra_fuse_read_early(unsigned int offset)\n{\n\treturn fuse->read_early(fuse, offset);\n}\n\nint tegra_fuse_readl(unsigned long offset, u32 *value)\n{\n\tif (!fuse->read || !fuse->clk)\n\t\treturn -EPROBE_DEFER;\n\n\tif (IS_ERR(fuse->clk))\n\t\treturn PTR_ERR(fuse->clk);\n\n\t*value = fuse->read(fuse, offset);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_fuse_readl);\n\nstatic void tegra_enable_fuse_clk(void __iomem *base)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(base + 0x48);\n\treg |= 1 << 28;\n\twritel(reg, base + 0x48);\n\n\t \n\treg = readl(base + 0x14);\n\treg |= 1 << 7;\n\twritel(reg, base + 0x14);\n}\n\nstatic ssize_t major_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", tegra_get_major_rev());\n}\n\nstatic DEVICE_ATTR_RO(major);\n\nstatic ssize_t minor_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", tegra_get_minor_rev());\n}\n\nstatic DEVICE_ATTR_RO(minor);\n\nstatic struct attribute *tegra_soc_attr[] = {\n\t&dev_attr_major.attr,\n\t&dev_attr_minor.attr,\n\tNULL,\n};\n\nconst struct attribute_group tegra_soc_attr_group = {\n\t.attrs = tegra_soc_attr,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \\\n    IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)\nstatic ssize_t platform_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\t \n\treturn sprintf(buf, \"%d\\n\", tegra_get_platform());\n}\n\nstatic DEVICE_ATTR_RO(platform);\n\nstatic struct attribute *tegra194_soc_attr[] = {\n\t&dev_attr_major.attr,\n\t&dev_attr_minor.attr,\n\t&dev_attr_platform.attr,\n\tNULL,\n};\n\nconst struct attribute_group tegra194_soc_attr_group = {\n\t.attrs = tegra194_soc_attr,\n};\n#endif\n\nstruct device * __init tegra_soc_device_register(void)\n{\n\tstruct soc_device_attribute *attr;\n\tstruct soc_device *dev;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn NULL;\n\n\tattr->family = kasprintf(GFP_KERNEL, \"Tegra\");\n\tif (tegra_is_silicon())\n\t\tattr->revision = kasprintf(GFP_KERNEL, \"%s %s\",\n\t\t\t\t\t   tegra_platform_name[tegra_sku_info.platform],\n\t\t\t\t\t   tegra_revision_name[tegra_sku_info.revision]);\n\telse\n\t\tattr->revision = kasprintf(GFP_KERNEL, \"%s\",\n\t\t\t\t\t   tegra_platform_name[tegra_sku_info.platform]);\n\tattr->soc_id = kasprintf(GFP_KERNEL, \"%u\", tegra_get_chip_id());\n\tattr->custom_attr_group = fuse->soc->soc_attr_group;\n\n\tdev = soc_device_register(attr);\n\tif (IS_ERR(dev)) {\n\t\tkfree(attr->soc_id);\n\t\tkfree(attr->revision);\n\t\tkfree(attr->family);\n\t\tkfree(attr);\n\t\treturn ERR_CAST(dev);\n\t}\n\n\treturn soc_device_to_device(dev);\n}\n\nstatic int __init tegra_init_fuse(void)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *np;\n\tstruct resource regs;\n\n\ttegra_init_apbmisc();\n\n\tnp = of_find_matching_node_and_match(NULL, tegra_fuse_match, &match);\n\tif (!np) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ARM) && soc_is_tegra()) {\n\t\t\tu8 chip = tegra_get_chip_id();\n\n\t\t\tregs.start = 0x7000f800;\n\t\t\tregs.end = 0x7000fbff;\n\t\t\tregs.flags = IORESOURCE_MEM;\n\n\t\t\tswitch (chip) {\n#ifdef CONFIG_ARCH_TEGRA_2x_SOC\n\t\t\tcase TEGRA20:\n\t\t\t\tfuse->soc = &tegra20_fuse_soc;\n\t\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_ARCH_TEGRA_3x_SOC\n\t\t\tcase TEGRA30:\n\t\t\t\tfuse->soc = &tegra30_fuse_soc;\n\t\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_ARCH_TEGRA_114_SOC\n\t\t\tcase TEGRA114:\n\t\t\t\tfuse->soc = &tegra114_fuse_soc;\n\t\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_ARCH_TEGRA_124_SOC\n\t\t\tcase TEGRA124:\n\t\t\t\tfuse->soc = &tegra124_fuse_soc;\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"Unsupported SoC: %02x\\n\", chip);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (of_address_to_resource(np, 0, &regs) < 0) {\n\t\t\tpr_err(\"failed to get FUSE register\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tfuse->soc = match->data;\n\t}\n\n\tnp = of_find_matching_node(NULL, car_match);\n\tif (np) {\n\t\tvoid __iomem *base = of_iomap(np, 0);\n\t\tof_node_put(np);\n\t\tif (base) {\n\t\t\ttegra_enable_fuse_clk(base);\n\t\t\tiounmap(base);\n\t\t} else {\n\t\t\tpr_err(\"failed to map clock registers\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tfuse->base = ioremap(regs.start, resource_size(&regs));\n\tif (!fuse->base) {\n\t\tpr_err(\"failed to map FUSE registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tfuse->soc->init(fuse);\n\n\tpr_info(\"Tegra Revision: %s SKU: %d CPU Process: %d SoC Process: %d\\n\",\n\t\ttegra_revision_name[tegra_sku_info.revision],\n\t\ttegra_sku_info.sku_id, tegra_sku_info.cpu_process_id,\n\t\ttegra_sku_info.soc_process_id);\n\tpr_debug(\"Tegra CPU Speedo ID %d, SoC Speedo ID %d\\n\",\n\t\t tegra_sku_info.cpu_speedo_id, tegra_sku_info.soc_speedo_id);\n\n\tif (fuse->soc->lookups) {\n\t\tsize_t size = sizeof(*fuse->lookups) * fuse->soc->num_lookups;\n\n\t\tfuse->lookups = kmemdup(fuse->soc->lookups, size, GFP_KERNEL);\n\t\tif (fuse->lookups)\n\t\t\tnvmem_add_cell_lookups(fuse->lookups, fuse->soc->num_lookups);\n\t}\n\n\treturn 0;\n}\nearly_initcall(tegra_init_fuse);\n\n#ifdef CONFIG_ARM64\nstatic int __init tegra_init_soc(void)\n{\n\tstruct device_node *np;\n\tstruct device *soc;\n\n\t \n\tnp = of_find_matching_node(NULL, tegra_fuse_match);\n\tif (!np)\n\t\treturn 0;\n\n\tof_node_put(np);\n\n\tsoc = tegra_soc_device_register();\n\tif (IS_ERR(soc)) {\n\t\tpr_err(\"failed to register SoC device: %ld\\n\", PTR_ERR(soc));\n\t\treturn PTR_ERR(soc);\n\t}\n\n\treturn 0;\n}\ndevice_initcall(tegra_init_soc);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}