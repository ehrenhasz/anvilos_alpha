{
  "module_name": "fuse-tegra20.c",
  "hash_id": "d2929aa4f36b5fdb821862112bac8376e765344bd7418f083077e493e8b695ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/fuse/fuse-tegra20.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"fuse.h\"\n\n#define FUSE_BEGIN\t0x100\n#define FUSE_UID_LOW\t0x08\n#define FUSE_UID_HIGH\t0x0c\n\nstatic u32 tegra20_fuse_read_early(struct tegra_fuse *fuse, unsigned int offset)\n{\n\treturn readl_relaxed(fuse->base + FUSE_BEGIN + offset);\n}\n\nstatic void apb_dma_complete(void *args)\n{\n\tstruct tegra_fuse *fuse = args;\n\n\tcomplete(&fuse->apbdma.wait);\n}\n\nstatic u32 tegra20_fuse_read(struct tegra_fuse *fuse, unsigned int offset)\n{\n\tunsigned long flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\n\tstruct dma_async_tx_descriptor *dma_desc;\n\tunsigned long time_left;\n\tu32 value = 0;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(fuse->dev);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&fuse->apbdma.lock);\n\n\tfuse->apbdma.config.src_addr = fuse->phys + FUSE_BEGIN + offset;\n\n\terr = dmaengine_slave_config(fuse->apbdma.chan, &fuse->apbdma.config);\n\tif (err)\n\t\tgoto out;\n\n\tdma_desc = dmaengine_prep_slave_single(fuse->apbdma.chan,\n\t\t\t\t\t       fuse->apbdma.phys,\n\t\t\t\t\t       sizeof(u32), DMA_DEV_TO_MEM,\n\t\t\t\t\t       flags);\n\tif (!dma_desc)\n\t\tgoto out;\n\n\tdma_desc->callback = apb_dma_complete;\n\tdma_desc->callback_param = fuse;\n\n\treinit_completion(&fuse->apbdma.wait);\n\n\tdmaengine_submit(dma_desc);\n\tdma_async_issue_pending(fuse->apbdma.chan);\n\ttime_left = wait_for_completion_timeout(&fuse->apbdma.wait,\n\t\t\t\t\t\tmsecs_to_jiffies(50));\n\n\tif (WARN(time_left == 0, \"apb read dma timed out\"))\n\t\tdmaengine_terminate_all(fuse->apbdma.chan);\n\telse\n\t\tvalue = *fuse->apbdma.virt;\n\nout:\n\tmutex_unlock(&fuse->apbdma.lock);\n\tpm_runtime_put(fuse->dev);\n\treturn value;\n}\n\nstatic bool dma_filter(struct dma_chan *chan, void *filter_param)\n{\n\tstruct device_node *np = chan->device->dev->of_node;\n\n\treturn of_device_is_compatible(np, \"nvidia,tegra20-apbdma\");\n}\n\nstatic void tegra20_fuse_release_channel(void *data)\n{\n\tstruct tegra_fuse *fuse = data;\n\n\tdma_release_channel(fuse->apbdma.chan);\n\tfuse->apbdma.chan = NULL;\n}\n\nstatic void tegra20_fuse_free_coherent(void *data)\n{\n\tstruct tegra_fuse *fuse = data;\n\n\tdma_free_coherent(fuse->dev, sizeof(u32), fuse->apbdma.virt,\n\t\t\t  fuse->apbdma.phys);\n\tfuse->apbdma.virt = NULL;\n\tfuse->apbdma.phys = 0x0;\n}\n\nstatic int tegra20_fuse_probe(struct tegra_fuse *fuse)\n{\n\tdma_cap_mask_t mask;\n\tint err;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tfuse->apbdma.chan = dma_request_channel(mask, dma_filter, NULL);\n\tif (!fuse->apbdma.chan)\n\t\treturn -EPROBE_DEFER;\n\n\terr = devm_add_action_or_reset(fuse->dev, tegra20_fuse_release_channel,\n\t\t\t\t       fuse);\n\tif (err)\n\t\treturn err;\n\n\tfuse->apbdma.virt = dma_alloc_coherent(fuse->dev, sizeof(u32),\n\t\t\t\t\t       &fuse->apbdma.phys,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!fuse->apbdma.virt)\n\t\treturn -ENOMEM;\n\n\terr = devm_add_action_or_reset(fuse->dev, tegra20_fuse_free_coherent,\n\t\t\t\t       fuse);\n\tif (err)\n\t\treturn err;\n\n\tfuse->apbdma.config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tfuse->apbdma.config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tfuse->apbdma.config.src_maxburst = 1;\n\tfuse->apbdma.config.dst_maxburst = 1;\n\tfuse->apbdma.config.direction = DMA_DEV_TO_MEM;\n\tfuse->apbdma.config.device_fc = false;\n\n\tinit_completion(&fuse->apbdma.wait);\n\tmutex_init(&fuse->apbdma.lock);\n\tfuse->read = tegra20_fuse_read;\n\n\treturn 0;\n}\n\nstatic const struct tegra_fuse_info tegra20_fuse_info = {\n\t.read = tegra20_fuse_read,\n\t.size = 0x1f8,\n\t.spare = 0x100,\n};\n\n \n\nstatic void __init tegra20_fuse_add_randomness(void)\n{\n\tu32 randomness[7];\n\n\trandomness[0] = tegra_sku_info.sku_id;\n\trandomness[1] = tegra_read_straps();\n\trandomness[2] = tegra_read_chipid();\n\trandomness[3] = tegra_sku_info.cpu_process_id << 16;\n\trandomness[3] |= tegra_sku_info.soc_process_id;\n\trandomness[4] = tegra_sku_info.cpu_speedo_id << 16;\n\trandomness[4] |= tegra_sku_info.soc_speedo_id;\n\trandomness[5] = tegra_fuse_read_early(FUSE_UID_LOW);\n\trandomness[6] = tegra_fuse_read_early(FUSE_UID_HIGH);\n\n\tadd_device_randomness(randomness, sizeof(randomness));\n}\n\nstatic void __init tegra20_fuse_init(struct tegra_fuse *fuse)\n{\n\tfuse->read_early = tegra20_fuse_read_early;\n\n\ttegra_init_revision();\n\tfuse->soc->speedo_init(&tegra_sku_info);\n\ttegra20_fuse_add_randomness();\n}\n\nconst struct tegra_fuse_soc tegra20_fuse_soc = {\n\t.init = tegra20_fuse_init,\n\t.speedo_init = tegra20_init_speedo_data,\n\t.probe = tegra20_fuse_probe,\n\t.info = &tegra20_fuse_info,\n\t.soc_attr_group = &tegra_soc_attr_group,\n\t.clk_suspend_on = false,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}