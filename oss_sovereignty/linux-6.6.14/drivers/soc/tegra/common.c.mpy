{
  "module_name": "common.c",
  "hash_id": "c6a2fe63b8f3efbdba8f1124d5bdc532a31b1563066aa997ab19d373f0fdd1e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/common.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt)\t\"tegra-soc: \" fmt\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n\nstatic const struct of_device_id tegra_machine_match[] = {\n\t{ .compatible = \"nvidia,tegra20\", },\n\t{ .compatible = \"nvidia,tegra30\", },\n\t{ .compatible = \"nvidia,tegra114\", },\n\t{ .compatible = \"nvidia,tegra124\", },\n\t{ .compatible = \"nvidia,tegra132\", },\n\t{ .compatible = \"nvidia,tegra210\", },\n\t{ }\n};\n\nbool soc_is_tegra(void)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *root;\n\n\troot = of_find_node_by_path(\"/\");\n\tif (!root)\n\t\treturn false;\n\n\tmatch = of_match_node(tegra_machine_match, root);\n\tof_node_put(root);\n\n\treturn match != NULL;\n}\n\nstatic int tegra_core_dev_init_opp_state(struct device *dev)\n{\n\tunsigned long rate;\n\tstruct clk *clk;\n\tbool rpm_enabled;\n\tint err;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to get clk: %pe\\n\", clk);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\trate = clk_get_rate(clk);\n\tif (!rate) {\n\t\tdev_err(dev, \"failed to get clk rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trpm_enabled = pm_runtime_enabled(dev);\n\tif (!rpm_enabled)\n\t\tpm_runtime_enable(dev);\n\n\t \n\tif (!pm_runtime_enabled(dev)) {\n\t\tdev_WARN(dev, \"failed to enable runtime PM\\n\");\n\t\tpm_runtime_disable(dev);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = dev_pm_opp_set_rate(dev, rate);\n\n\tif (!rpm_enabled)\n\t\tpm_runtime_disable(dev);\n\n\tif (err) {\n\t\tdev_err(dev, \"failed to initialize OPP clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nint devm_tegra_core_dev_init_opp_table(struct device *dev,\n\t\t\t\t       struct tegra_core_opp_params *params)\n{\n\tu32 hw_version;\n\tint err;\n\t \n\tconst char *clk_names[] = { NULL, NULL };\n\tstruct dev_pm_opp_config config = {\n\t\t \n\t\t.clk_names = clk_names,\n\t};\n\n\tif (of_machine_is_compatible(\"nvidia,tegra20\")) {\n\t\thw_version = BIT(tegra_sku_info.soc_process_id);\n\t\tconfig.supported_hw = &hw_version;\n\t\tconfig.supported_hw_count = 1;\n\t} else if (of_machine_is_compatible(\"nvidia,tegra30\")) {\n\t\thw_version = BIT(tegra_sku_info.soc_speedo_id);\n\t\tconfig.supported_hw = &hw_version;\n\t\tconfig.supported_hw_count = 1;\n\t}\n\n\terr = devm_pm_opp_set_config(dev, &config);\n\tif (err) {\n\t\tdev_err(dev, \"failed to set OPP config: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (!config.supported_hw)\n\t\treturn -ENODEV;\n\n\t \n\terr = devm_pm_opp_of_add_table(dev);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_err(dev, \"failed to add OPP table: %d\\n\", err);\n\n\t\treturn err;\n\t}\n\n\tif (params->init_state) {\n\t\terr = tegra_core_dev_init_opp_state(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_tegra_core_dev_init_opp_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}