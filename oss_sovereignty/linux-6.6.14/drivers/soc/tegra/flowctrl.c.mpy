{
  "module_name": "flowctrl.c",
  "hash_id": "9640514145b94a6cac49d23bb918de6d7e8fd25ba414bb072fb4e9c3851e8dd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/flowctrl.c",
  "human_readable_source": "\n \n\n#include <linux/cpumask.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/flowctrl.h>\n#include <soc/tegra/fuse.h>\n\nstatic u8 flowctrl_offset_halt_cpu[] = {\n\tFLOW_CTRL_HALT_CPU0_EVENTS,\n\tFLOW_CTRL_HALT_CPU1_EVENTS,\n\tFLOW_CTRL_HALT_CPU1_EVENTS + 8,\n\tFLOW_CTRL_HALT_CPU1_EVENTS + 16,\n};\n\nstatic u8 flowctrl_offset_cpu_csr[] = {\n\tFLOW_CTRL_CPU0_CSR,\n\tFLOW_CTRL_CPU1_CSR,\n\tFLOW_CTRL_CPU1_CSR + 8,\n\tFLOW_CTRL_CPU1_CSR + 16,\n};\n\nstatic void __iomem *tegra_flowctrl_base;\n\nstatic void flowctrl_update(u8 offset, u32 value)\n{\n\tif (WARN_ONCE(IS_ERR_OR_NULL(tegra_flowctrl_base),\n\t\t      \"Tegra flowctrl not initialised!\\n\"))\n\t\treturn;\n\n\twritel(value, tegra_flowctrl_base + offset);\n\n\t \n\twmb();\n\treadl_relaxed(tegra_flowctrl_base + offset);\n}\n\nu32 flowctrl_read_cpu_csr(unsigned int cpuid)\n{\n\tu8 offset = flowctrl_offset_cpu_csr[cpuid];\n\n\tif (WARN_ONCE(IS_ERR_OR_NULL(tegra_flowctrl_base),\n\t\t      \"Tegra flowctrl not initialised!\\n\"))\n\t\treturn 0;\n\n\treturn readl(tegra_flowctrl_base + offset);\n}\n\nvoid flowctrl_write_cpu_csr(unsigned int cpuid, u32 value)\n{\n\treturn flowctrl_update(flowctrl_offset_cpu_csr[cpuid], value);\n}\n\nvoid flowctrl_write_cpu_halt(unsigned int cpuid, u32 value)\n{\n\treturn flowctrl_update(flowctrl_offset_halt_cpu[cpuid], value);\n}\n\nvoid flowctrl_cpu_suspend_enter(unsigned int cpuid)\n{\n\tunsigned int reg;\n\tint i;\n\n\treg = flowctrl_read_cpu_csr(cpuid);\n\tswitch (tegra_get_chip_id()) {\n\tcase TEGRA20:\n\t\t \n\t\treg &= ~TEGRA20_FLOW_CTRL_CSR_WFE_BITMAP;\n\t\t \n\t\treg &= ~TEGRA20_FLOW_CTRL_CSR_WFI_BITMAP;\n\t\t \n\t\treg |= TEGRA20_FLOW_CTRL_CSR_WFE_CPU0 << cpuid;\n\t\tbreak;\n\tcase TEGRA30:\n\tcase TEGRA114:\n\tcase TEGRA124:\n\t\t \n\t\treg &= ~TEGRA30_FLOW_CTRL_CSR_WFE_BITMAP;\n\t\t \n\t\treg &= ~TEGRA30_FLOW_CTRL_CSR_WFI_BITMAP;\n\n\t\tif (tegra_get_chip_id() == TEGRA30) {\n\t\t\t \n\t\t\treg |= TEGRA20_FLOW_CTRL_CSR_WFE_CPU0 << cpuid;\n\t\t} else {\n\t\t\t \n\t\t\treg |= TEGRA30_FLOW_CTRL_CSR_WFI_CPU0 << cpuid;\n\t\t}\n\t\tbreak;\n\t}\n\treg |= FLOW_CTRL_CSR_INTR_FLAG;\t\t\t \n\treg |= FLOW_CTRL_CSR_EVENT_FLAG;\t\t \n\treg |= FLOW_CTRL_CSR_ENABLE;\t\t\t \n\tflowctrl_write_cpu_csr(cpuid, reg);\n\n\tfor (i = 0; i < num_possible_cpus(); i++) {\n\t\tif (i == cpuid)\n\t\t\tcontinue;\n\t\treg = flowctrl_read_cpu_csr(i);\n\t\treg |= FLOW_CTRL_CSR_EVENT_FLAG;\n\t\treg |= FLOW_CTRL_CSR_INTR_FLAG;\n\t\tflowctrl_write_cpu_csr(i, reg);\n\t}\n}\n\nvoid flowctrl_cpu_suspend_exit(unsigned int cpuid)\n{\n\tunsigned int reg;\n\n\t \n\treg = flowctrl_read_cpu_csr(cpuid);\n\tswitch (tegra_get_chip_id()) {\n\tcase TEGRA20:\n\t\t \n\t\treg &= ~TEGRA20_FLOW_CTRL_CSR_WFE_BITMAP;\n\t\t \n\t\treg &= ~TEGRA20_FLOW_CTRL_CSR_WFI_BITMAP;\n\t\tbreak;\n\tcase TEGRA30:\n\tcase TEGRA114:\n\tcase TEGRA124:\n\t\t \n\t\treg &= ~TEGRA30_FLOW_CTRL_CSR_WFE_BITMAP;\n\t\t \n\t\treg &= ~TEGRA30_FLOW_CTRL_CSR_WFI_BITMAP;\n\t\tbreak;\n\t}\n\treg &= ~FLOW_CTRL_CSR_ENABLE;\t\t\t \n\treg |= FLOW_CTRL_CSR_INTR_FLAG;\t\t\t \n\treg |= FLOW_CTRL_CSR_EVENT_FLAG;\t\t \n\tflowctrl_write_cpu_csr(cpuid, reg);\n}\n\nstatic int tegra_flowctrl_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base = tegra_flowctrl_base;\n\n\ttegra_flowctrl_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(tegra_flowctrl_base))\n\t\treturn PTR_ERR(tegra_flowctrl_base);\n\n\tiounmap(base);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_flowctrl_match[] = {\n\t{ .compatible = \"nvidia,tegra210-flowctrl\" },\n\t{ .compatible = \"nvidia,tegra124-flowctrl\" },\n\t{ .compatible = \"nvidia,tegra114-flowctrl\" },\n\t{ .compatible = \"nvidia,tegra30-flowctrl\" },\n\t{ .compatible = \"nvidia,tegra20-flowctrl\" },\n\t{ }\n};\n\nstatic struct platform_driver tegra_flowctrl_driver = {\n\t.driver = {\n\t\t.name = \"tegra-flowctrl\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = tegra_flowctrl_match,\n\t},\n\t.probe = tegra_flowctrl_probe,\n};\nbuiltin_platform_driver(tegra_flowctrl_driver);\n\nstatic int __init tegra_flowctrl_init(void)\n{\n\tstruct resource res;\n\tstruct device_node *np;\n\n\tif (!soc_is_tegra())\n\t\treturn 0;\n\n\tnp = of_find_matching_node(NULL, tegra_flowctrl_match);\n\tif (np) {\n\t\tif (of_address_to_resource(np, 0, &res) < 0) {\n\t\t\tpr_err(\"failed to get flowctrl register\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tof_node_put(np);\n\t} else if (IS_ENABLED(CONFIG_ARM)) {\n\t\t \n\t\tres.start = 0x60007000;\n\t\tres.end = 0x60007fff;\n\t\tres.flags = IORESOURCE_MEM;\n\t} else {\n\t\t \n\t\treturn 0;\n\t}\n\n\ttegra_flowctrl_base = ioremap(res.start, resource_size(&res));\n\tif (!tegra_flowctrl_base)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\nearly_initcall(tegra_flowctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}