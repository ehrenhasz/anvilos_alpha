{
  "module_name": "tegra234-cbb.c",
  "hash_id": "5b7335c8e695407fcb2cbd760d13054a4dd4066ae01068df3e2ee5b1c7762a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/cbb/tegra234-cbb.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/cpufeature.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/tegra-cbb.h>\n\n#define FABRIC_EN_CFG_INTERRUPT_ENABLE_0_0\t0x0\n#define FABRIC_EN_CFG_STATUS_0_0\t\t0x40\n#define FABRIC_EN_CFG_ADDR_INDEX_0_0\t\t0x60\n#define FABRIC_EN_CFG_ADDR_LOW_0\t\t0x80\n#define FABRIC_EN_CFG_ADDR_HI_0\t\t\t0x84\n\n#define FABRIC_MN_MASTER_ERR_EN_0\t\t0x200\n#define FABRIC_MN_MASTER_ERR_FORCE_0\t\t0x204\n#define FABRIC_MN_MASTER_ERR_STATUS_0\t\t0x208\n#define FABRIC_MN_MASTER_ERR_OVERFLOW_STATUS_0\t0x20c\n\n#define FABRIC_MN_MASTER_LOG_ERR_STATUS_0\t0x300\n#define FABRIC_MN_MASTER_LOG_ADDR_LOW_0\t\t0x304\n#define FABRIC_MN_MASTER_LOG_ADDR_HIGH_0\t0x308\n#define FABRIC_MN_MASTER_LOG_ATTRIBUTES0_0\t0x30c\n#define FABRIC_MN_MASTER_LOG_ATTRIBUTES1_0\t0x310\n#define FABRIC_MN_MASTER_LOG_ATTRIBUTES2_0\t0x314\n#define FABRIC_MN_MASTER_LOG_USER_BITS0_0\t0x318\n\n#define AXI_SLV_TIMEOUT_STATUS_0_0\t\t0x8\n#define APB_BLOCK_TMO_STATUS_0\t\t\t0xc00\n#define APB_BLOCK_NUM_TMO_OFFSET\t\t0x20\n\n#define FAB_EM_EL_MSTRID\t\tGENMASK(29, 24)\n#define FAB_EM_EL_VQC\t\t\tGENMASK(17, 16)\n#define FAB_EM_EL_GRPSEC\t\tGENMASK(14, 8)\n#define FAB_EM_EL_FALCONSEC\t\tGENMASK(1, 0)\n\n#define FAB_EM_EL_FABID\t\t\tGENMASK(20, 16)\n#define FAB_EM_EL_SLAVEID\t\tGENMASK(7, 0)\n\n#define FAB_EM_EL_ACCESSID\t\tGENMASK(7, 0)\n\n#define FAB_EM_EL_AXCACHE\t\tGENMASK(27, 24)\n#define FAB_EM_EL_AXPROT\t\tGENMASK(22, 20)\n#define FAB_EM_EL_BURSTLENGTH\t\tGENMASK(19, 12)\n#define FAB_EM_EL_BURSTTYPE\t\tGENMASK(9, 8)\n#define FAB_EM_EL_BEATSIZE\t\tGENMASK(6, 4)\n#define FAB_EM_EL_ACCESSTYPE\t\tGENMASK(0, 0)\n\n#define USRBITS_MSTR_ID\t\t\tGENMASK(29, 24)\n\n#define REQ_SOCKET_ID\t\t\tGENMASK(27, 24)\n\n#define CCPLEX_MSTRID\t\t\t0x1\n#define FIREWALL_APERTURE_SZ\t\t0x10000\n \n#define WEN\t\t\t\t0x20000\n\nenum tegra234_cbb_fabric_ids {\n\tCBB_FAB_ID,\n\tSCE_FAB_ID,\n\tRCE_FAB_ID,\n\tDCE_FAB_ID,\n\tAON_FAB_ID,\n\tPSC_FAB_ID,\n\tBPMP_FAB_ID,\n\tFSI_FAB_ID,\n\tMAX_FAB_ID,\n};\n\nstruct tegra234_slave_lookup {\n\tconst char *name;\n\tunsigned int offset;\n};\n\nstruct tegra234_cbb_fabric {\n\tconst char *name;\n\tphys_addr_t off_mask_erd;\n\tphys_addr_t firewall_base;\n\tunsigned int firewall_ctl;\n\tunsigned int firewall_wr_ctl;\n\tconst char * const *master_id;\n\tunsigned int notifier_offset;\n\tconst struct tegra_cbb_error *errors;\n\tconst int max_errors;\n\tconst struct tegra234_slave_lookup *slave_map;\n\tconst int max_slaves;\n};\n\nstruct tegra234_cbb {\n\tstruct tegra_cbb base;\n\n\tconst struct tegra234_cbb_fabric *fabric;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\n\tint num_intr;\n\tint sec_irq;\n\n\t \n\tvoid __iomem *mon;\n\tunsigned int type;\n\tu32 mask;\n\tu64 access;\n\tu32 mn_attr0;\n\tu32 mn_attr1;\n\tu32 mn_attr2;\n\tu32 mn_user_bits;\n};\n\nstatic inline struct tegra234_cbb *to_tegra234_cbb(struct tegra_cbb *cbb)\n{\n\treturn container_of(cbb, struct tegra234_cbb, base);\n}\n\nstatic LIST_HEAD(cbb_list);\nstatic DEFINE_SPINLOCK(cbb_lock);\n\nstatic bool\ntegra234_cbb_write_access_allowed(struct platform_device *pdev, struct tegra234_cbb *cbb)\n{\n\tu32 val;\n\n\tif (!cbb->fabric->firewall_base ||\n\t    !cbb->fabric->firewall_ctl ||\n\t    !cbb->fabric->firewall_wr_ctl) {\n\t\tdev_info(&pdev->dev, \"SoC data missing for firewall\\n\");\n\t\treturn false;\n\t}\n\n\tif ((cbb->fabric->firewall_ctl > FIREWALL_APERTURE_SZ) ||\n\t    (cbb->fabric->firewall_wr_ctl > FIREWALL_APERTURE_SZ)) {\n\t\tdev_err(&pdev->dev, \"wrong firewall offset value\\n\");\n\t\treturn false;\n\t}\n\n\tval = readl(cbb->regs + cbb->fabric->firewall_base + cbb->fabric->firewall_ctl);\n\t \n\tif (!(val & WEN))\n\t\treturn true;\n\n\t \n\tval = readl(cbb->regs + cbb->fabric->firewall_base + cbb->fabric->firewall_wr_ctl);\n\tif (val & (BIT(CCPLEX_MSTRID)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void tegra234_cbb_fault_enable(struct tegra_cbb *cbb)\n{\n\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\tvoid __iomem *addr;\n\n\taddr = priv->regs + priv->fabric->notifier_offset;\n\twritel(0x1ff, addr + FABRIC_EN_CFG_INTERRUPT_ENABLE_0_0);\n\tdsb(sy);\n}\n\nstatic void tegra234_cbb_error_clear(struct tegra_cbb *cbb)\n{\n\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\n\twritel(0x3f, priv->mon + FABRIC_MN_MASTER_ERR_STATUS_0);\n\tdsb(sy);\n}\n\nstatic u32 tegra234_cbb_get_status(struct tegra_cbb *cbb)\n{\n\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\tvoid __iomem *addr;\n\tu32 value;\n\n\taddr = priv->regs + priv->fabric->notifier_offset;\n\tvalue = readl(addr + FABRIC_EN_CFG_STATUS_0_0);\n\tdsb(sy);\n\n\treturn value;\n}\n\nstatic void tegra234_cbb_mask_serror(struct tegra234_cbb *cbb)\n{\n\twritel(0x1, cbb->regs + cbb->fabric->off_mask_erd);\n\tdsb(sy);\n}\n\nstatic u32 tegra234_cbb_get_tmo_slv(void __iomem *addr)\n{\n\tu32 timeout;\n\n\ttimeout = readl(addr);\n\treturn timeout;\n}\n\nstatic void tegra234_cbb_tmo_slv(struct seq_file *file, const char *slave, void __iomem *addr,\n\t\t\t\t u32 status)\n{\n\ttegra_cbb_print_err(file, \"\\t  %s : %#x\\n\", slave, status);\n}\n\nstatic void tegra234_cbb_lookup_apbslv(struct seq_file *file, const char *slave,\n\t\t\t\t       void __iomem *base)\n{\n\tunsigned int block = 0;\n\tvoid __iomem *addr;\n\tchar name[64];\n\tu32 status;\n\n\tstatus = tegra234_cbb_get_tmo_slv(base);\n\tif (status)\n\t\ttegra_cbb_print_err(file, \"\\t  %s_BLOCK_TMO_STATUS : %#x\\n\", slave, status);\n\n\twhile (status) {\n\t\tif (status & BIT(0)) {\n\t\t\tu32 timeout, clients, client = 0;\n\n\t\t\taddr = base + APB_BLOCK_NUM_TMO_OFFSET + (block * 4);\n\t\t\ttimeout = tegra234_cbb_get_tmo_slv(addr);\n\t\t\tclients = timeout;\n\n\t\t\twhile (timeout) {\n\t\t\t\tif (timeout & BIT(0)) {\n\t\t\t\t\tif (clients != 0xffffffff)\n\t\t\t\t\t\tclients &= BIT(client);\n\n\t\t\t\t\tsprintf(name, \"%s_BLOCK%d_TMO\", slave, block);\n\n\t\t\t\t\ttegra234_cbb_tmo_slv(file, name, addr, clients);\n\t\t\t\t}\n\n\t\t\t\ttimeout >>= 1;\n\t\t\t\tclient++;\n\t\t\t}\n\t\t}\n\n\t\tstatus >>= 1;\n\t\tblock++;\n\t}\n}\n\nstatic void tegra234_lookup_slave_timeout(struct seq_file *file, struct tegra234_cbb *cbb,\n\t\t\t\t\t  u8 slave_id, u8 fab_id)\n{\n\tconst struct tegra234_slave_lookup *map = cbb->fabric->slave_map;\n\tvoid __iomem *addr;\n\n\t \n\n\taddr = cbb->regs + map[slave_id].offset;\n\n\tif (strstr(map[slave_id].name, \"AXI2APB\")) {\n\t\taddr += APB_BLOCK_TMO_STATUS_0;\n\n\t\ttegra234_cbb_lookup_apbslv(file, map[slave_id].name, addr);\n\t} else {\n\t\tchar name[64];\n\t\tu32 status;\n\n\t\taddr += AXI_SLV_TIMEOUT_STATUS_0_0;\n\n\t\tstatus = tegra234_cbb_get_tmo_slv(addr);\n\t\tif (status) {\n\t\t\tsprintf(name, \"%s_SLV_TIMEOUT_STATUS\", map[slave_id].name);\n\t\t\ttegra234_cbb_tmo_slv(file, name, addr, status);\n\t\t}\n\t}\n}\n\nstatic void tegra234_cbb_print_error(struct seq_file *file, struct tegra234_cbb *cbb, u32 status,\n\t\t\t\t     u32 overflow)\n{\n\tunsigned int type = 0;\n\n\tif (status & (status - 1))\n\t\ttegra_cbb_print_err(file, \"\\t  Multiple type of errors reported\\n\");\n\n\twhile (status) {\n\t\tif (type >= cbb->fabric->max_errors) {\n\t\t\ttegra_cbb_print_err(file, \"\\t  Wrong type index:%u, status:%u\\n\",\n\t\t\t\t\t    type, status);\n\t\t\treturn;\n\t\t}\n\n\t\tif (status & 0x1)\n\t\t\ttegra_cbb_print_err(file, \"\\t  Error Code\\t\\t: %s\\n\",\n\t\t\t\t\t    cbb->fabric->errors[type].code);\n\n\t\tstatus >>= 1;\n\t\ttype++;\n\t}\n\n\ttype = 0;\n\n\twhile (overflow) {\n\t\tif (type >= cbb->fabric->max_errors) {\n\t\t\ttegra_cbb_print_err(file, \"\\t  Wrong type index:%u, overflow:%u\\n\",\n\t\t\t\t\t    type, overflow);\n\t\t\treturn;\n\t\t}\n\n\t\tif (overflow & 0x1)\n\t\t\ttegra_cbb_print_err(file, \"\\t  Overflow\\t\\t: Multiple %s\\n\",\n\t\t\t\t\t    cbb->fabric->errors[type].code);\n\n\t\toverflow >>= 1;\n\t\ttype++;\n\t}\n}\n\nstatic void print_errlog_err(struct seq_file *file, struct tegra234_cbb *cbb)\n{\n\tu8 cache_type, prot_type, burst_length, mstr_id, grpsec, vqc, falconsec, beat_size;\n\tu8 access_type, access_id, requester_socket_id, local_socket_id, slave_id, fab_id;\n\tchar fabric_name[20];\n\tbool is_numa = false;\n\tu8 burst_type;\n\n\tif (num_possible_nodes() > 1)\n\t\tis_numa = true;\n\n\tmstr_id = FIELD_GET(FAB_EM_EL_MSTRID, cbb->mn_user_bits);\n\tvqc = FIELD_GET(FAB_EM_EL_VQC, cbb->mn_user_bits);\n\tgrpsec = FIELD_GET(FAB_EM_EL_GRPSEC, cbb->mn_user_bits);\n\tfalconsec = FIELD_GET(FAB_EM_EL_FALCONSEC, cbb->mn_user_bits);\n\n\t \n\tif (is_numa) {\n\t\tlocal_socket_id = numa_node_id();\n\t\trequester_socket_id = FIELD_GET(REQ_SOCKET_ID, cbb->mn_attr2);\n\n\t\tif (requester_socket_id != local_socket_id) {\n\t\t\tif ((mstr_id != 0x1) && (mstr_id != 0x2) && (mstr_id != 0xB))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tfab_id = FIELD_GET(FAB_EM_EL_FABID, cbb->mn_attr2);\n\tslave_id = FIELD_GET(FAB_EM_EL_SLAVEID, cbb->mn_attr2);\n\n\taccess_id = FIELD_GET(FAB_EM_EL_ACCESSID, cbb->mn_attr1);\n\n\tcache_type = FIELD_GET(FAB_EM_EL_AXCACHE, cbb->mn_attr0);\n\tprot_type = FIELD_GET(FAB_EM_EL_AXPROT, cbb->mn_attr0);\n\tburst_length = FIELD_GET(FAB_EM_EL_BURSTLENGTH, cbb->mn_attr0);\n\tburst_type = FIELD_GET(FAB_EM_EL_BURSTTYPE, cbb->mn_attr0);\n\tbeat_size = FIELD_GET(FAB_EM_EL_BEATSIZE, cbb->mn_attr0);\n\taccess_type = FIELD_GET(FAB_EM_EL_ACCESSTYPE, cbb->mn_attr0);\n\n\ttegra_cbb_print_err(file, \"\\n\");\n\tif (cbb->type < cbb->fabric->max_errors)\n\t\ttegra_cbb_print_err(file, \"\\t  Error Code\\t\\t: %s\\n\",\n\t\t\t\t    cbb->fabric->errors[cbb->type].code);\n\telse\n\t\ttegra_cbb_print_err(file, \"\\t  Wrong type index:%u\\n\", cbb->type);\n\n\ttegra_cbb_print_err(file, \"\\t  MASTER_ID\\t\\t: %s\\n\", cbb->fabric->master_id[mstr_id]);\n\ttegra_cbb_print_err(file, \"\\t  Address\\t\\t: %#llx\\n\", cbb->access);\n\n\ttegra_cbb_print_cache(file, cache_type);\n\ttegra_cbb_print_prot(file, prot_type);\n\n\ttegra_cbb_print_err(file, \"\\t  Access_Type\\t\\t: %s\", (access_type) ? \"Write\\n\" : \"Read\\n\");\n\ttegra_cbb_print_err(file, \"\\t  Access_ID\\t\\t: %#x\", access_id);\n\n\tif (fab_id == PSC_FAB_ID)\n\t\tstrcpy(fabric_name, \"psc-fabric\");\n\telse if (fab_id == FSI_FAB_ID)\n\t\tstrcpy(fabric_name, \"fsi-fabric\");\n\telse\n\t\tstrcpy(fabric_name, cbb->fabric->name);\n\n\tif (is_numa) {\n\t\ttegra_cbb_print_err(file, \"\\t  Requester_Socket_Id\\t: %#x\\n\",\n\t\t\t\t    requester_socket_id);\n\t\ttegra_cbb_print_err(file, \"\\t  Local_Socket_Id\\t: %#x\\n\",\n\t\t\t\t    local_socket_id);\n\t\ttegra_cbb_print_err(file, \"\\t  No. of NUMA_NODES\\t: %#x\\n\",\n\t\t\t\t    num_possible_nodes());\n\t}\n\n\ttegra_cbb_print_err(file, \"\\t  Fabric\\t\\t: %s\\n\", fabric_name);\n\ttegra_cbb_print_err(file, \"\\t  Slave_Id\\t\\t: %#x\\n\", slave_id);\n\ttegra_cbb_print_err(file, \"\\t  Burst_length\\t\\t: %#x\\n\", burst_length);\n\ttegra_cbb_print_err(file, \"\\t  Burst_type\\t\\t: %#x\\n\", burst_type);\n\ttegra_cbb_print_err(file, \"\\t  Beat_size\\t\\t: %#x\\n\", beat_size);\n\ttegra_cbb_print_err(file, \"\\t  VQC\\t\\t\\t: %#x\\n\", vqc);\n\ttegra_cbb_print_err(file, \"\\t  GRPSEC\\t\\t: %#x\\n\", grpsec);\n\ttegra_cbb_print_err(file, \"\\t  FALCONSEC\\t\\t: %#x\\n\", falconsec);\n\n\tif ((fab_id == PSC_FAB_ID) || (fab_id == FSI_FAB_ID))\n\t\treturn;\n\n\tif (slave_id >= cbb->fabric->max_slaves) {\n\t\ttegra_cbb_print_err(file, \"\\t  Invalid slave_id:%d\\n\", slave_id);\n\t\treturn;\n\t}\n\n\tif (!strcmp(cbb->fabric->errors[cbb->type].code, \"TIMEOUT_ERR\")) {\n\t\ttegra234_lookup_slave_timeout(file, cbb, slave_id, fab_id);\n\t\treturn;\n\t}\n\n\ttegra_cbb_print_err(file, \"\\t  Slave\\t\\t\\t: %s\\n\", cbb->fabric->slave_map[slave_id].name);\n}\n\nstatic int print_errmonX_info(struct seq_file *file, struct tegra234_cbb *cbb)\n{\n\tu32 overflow, status, error;\n\n\tstatus = readl(cbb->mon + FABRIC_MN_MASTER_ERR_STATUS_0);\n\tif (!status) {\n\t\tpr_err(\"Error Notifier received a spurious notification\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (status == 0xffffffff) {\n\t\tpr_err(\"CBB registers returning all 1's which is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toverflow = readl(cbb->mon + FABRIC_MN_MASTER_ERR_OVERFLOW_STATUS_0);\n\n\ttegra234_cbb_print_error(file, cbb, status, overflow);\n\n\terror = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ERR_STATUS_0);\n\tif (!error) {\n\t\tpr_info(\"Error Monitor doesn't have Error Logger\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcbb->type = 0;\n\n\twhile (error) {\n\t\tif (error & BIT(0)) {\n\t\t\tu32 hi, lo;\n\n\t\t\thi = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ADDR_HIGH_0);\n\t\t\tlo = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ADDR_LOW_0);\n\n\t\t\tcbb->access = (u64)hi << 32 | lo;\n\n\t\t\tcbb->mn_attr0 = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ATTRIBUTES0_0);\n\t\t\tcbb->mn_attr1 = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ATTRIBUTES1_0);\n\t\t\tcbb->mn_attr2 = readl(cbb->mon + FABRIC_MN_MASTER_LOG_ATTRIBUTES2_0);\n\t\t\tcbb->mn_user_bits = readl(cbb->mon + FABRIC_MN_MASTER_LOG_USER_BITS0_0);\n\n\t\t\tprint_errlog_err(file, cbb);\n\t\t}\n\n\t\tcbb->type++;\n\t\terror >>= 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int print_err_notifier(struct seq_file *file, struct tegra234_cbb *cbb, u32 status)\n{\n\tunsigned int index = 0;\n\tint err;\n\n\tpr_crit(\"**************************************\\n\");\n\tpr_crit(\"CPU:%d, Error:%s, Errmon:%d\\n\", smp_processor_id(),\n\t\tcbb->fabric->name, status);\n\n\twhile (status) {\n\t\tif (status & BIT(0)) {\n\t\t\tunsigned int notifier = cbb->fabric->notifier_offset;\n\t\t\tu32 hi, lo, mask = BIT(index);\n\t\t\tphys_addr_t addr;\n\t\t\tu64 offset;\n\n\t\t\twritel(mask, cbb->regs + notifier + FABRIC_EN_CFG_ADDR_INDEX_0_0);\n\t\t\thi = readl(cbb->regs + notifier + FABRIC_EN_CFG_ADDR_HI_0);\n\t\t\tlo = readl(cbb->regs + notifier + FABRIC_EN_CFG_ADDR_LOW_0);\n\n\t\t\taddr = (u64)hi << 32 | lo;\n\n\t\t\toffset = addr - cbb->res->start;\n\t\t\tcbb->mon = cbb->regs + offset;\n\t\t\tcbb->mask = BIT(index);\n\n\t\t\terr = print_errmonX_info(file, cbb);\n\t\t\ttegra234_cbb_error_clear(&cbb->base);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tstatus >>= 1;\n\t\tindex++;\n\t}\n\n\ttegra_cbb_print_err(file, \"\\t**************************************\\n\");\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic DEFINE_MUTEX(cbb_debugfs_mutex);\n\nstatic int tegra234_cbb_debugfs_show(struct tegra_cbb *cbb, struct seq_file *file, void *data)\n{\n\tint err = 0;\n\n\tmutex_lock(&cbb_debugfs_mutex);\n\n\tlist_for_each_entry(cbb, &cbb_list, node) {\n\t\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\t\tu32 status;\n\n\t\tstatus = tegra_cbb_get_status(&priv->base);\n\t\tif (status) {\n\t\t\terr = print_err_notifier(file, priv, status);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&cbb_debugfs_mutex);\n\treturn err;\n}\n#endif\n\n \nstatic irqreturn_t tegra234_cbb_isr(int irq, void *data)\n{\n\tbool is_inband_err = false;\n\tstruct tegra_cbb *cbb;\n\tunsigned long flags;\n\tu8 mstr_id;\n\tint err;\n\n\tspin_lock_irqsave(&cbb_lock, flags);\n\n\tlist_for_each_entry(cbb, &cbb_list, node) {\n\t\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\t\tu32 status = tegra_cbb_get_status(cbb);\n\n\t\tif (status && (irq == priv->sec_irq)) {\n\t\t\ttegra_cbb_print_err(NULL, \"CPU:%d, Error: %s@0x%llx, irq=%d\\n\",\n\t\t\t\t\t    smp_processor_id(), priv->fabric->name,\n\t\t\t\t\t    priv->res->start, irq);\n\n\t\t\terr = print_err_notifier(NULL, priv, status);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\t \n\t\t\tif (priv->fabric->off_mask_erd) {\n\t\t\t\tmstr_id =  FIELD_GET(USRBITS_MSTR_ID, priv->mn_user_bits);\n\t\t\t\tif (mstr_id == CCPLEX_MSTRID)\n\t\t\t\t\tis_inband_err = 1;\n\t\t\t}\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&cbb_lock, flags);\n\tWARN_ON(is_inband_err);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int tegra234_cbb_interrupt_enable(struct tegra_cbb *cbb)\n{\n\tstruct tegra234_cbb *priv = to_tegra234_cbb(cbb);\n\n\tif (priv->sec_irq) {\n\t\tint err = devm_request_irq(cbb->dev, priv->sec_irq, tegra234_cbb_isr, 0,\n\t\t\t\t\t   dev_name(cbb->dev), priv);\n\t\tif (err) {\n\t\t\tdev_err(cbb->dev, \"failed to register interrupt %u: %d\\n\", priv->sec_irq,\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra234_cbb_error_enable(struct tegra_cbb *cbb)\n{\n\ttegra_cbb_fault_enable(cbb);\n}\n\nstatic const struct tegra_cbb_ops tegra234_cbb_ops = {\n\t.get_status = tegra234_cbb_get_status,\n\t.error_clear = tegra234_cbb_error_clear,\n\t.fault_enable = tegra234_cbb_fault_enable,\n\t.error_enable = tegra234_cbb_error_enable,\n\t.interrupt_enable = tegra234_cbb_interrupt_enable,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_show = tegra234_cbb_debugfs_show,\n#endif\n};\n\nstatic const char * const tegra234_master_id[] = {\n\t[0x00] = \"TZ\",\n\t[0x01] = \"CCPLEX\",\n\t[0x02] = \"CCPMU\",\n\t[0x03] = \"BPMP_FW\",\n\t[0x04] = \"AON\",\n\t[0x05] = \"SCE\",\n\t[0x06] = \"GPCDMA_P\",\n\t[0x07] = \"TSECA_NONSECURE\",\n\t[0x08] = \"TSECA_LIGHTSECURE\",\n\t[0x09] = \"TSECA_HEAVYSECURE\",\n\t[0x0a] = \"CORESIGHT\",\n\t[0x0b] = \"APE\",\n\t[0x0c] = \"PEATRANS\",\n\t[0x0d] = \"JTAGM_DFT\",\n\t[0x0e] = \"RCE\",\n\t[0x0f] = \"DCE\",\n\t[0x10] = \"PSC_FW_USER\",\n\t[0x11] = \"PSC_FW_SUPERVISOR\",\n\t[0x12] = \"PSC_FW_MACHINE\",\n\t[0x13] = \"PSC_BOOT\",\n\t[0x14] = \"BPMP_BOOT\",\n\t[0x15] = \"NVDEC_NONSECURE\",\n\t[0x16] = \"NVDEC_LIGHTSECURE\",\n\t[0x17] = \"NVDEC_HEAVYSECURE\",\n\t[0x18] = \"CBB_INTERNAL\",\n\t[0x19] = \"RSVD\"\n};\n\nstatic const struct tegra_cbb_error tegra234_cbb_errors[] = {\n\t{\n\t\t.code = \"SLAVE_ERR\",\n\t\t.desc = \"Slave being accessed responded with an error\"\n\t}, {\n\t\t.code = \"DECODE_ERR\",\n\t\t.desc = \"Attempt to access an address hole\"\n\t}, {\n\t\t.code = \"FIREWALL_ERR\",\n\t\t.desc = \"Attempt to access a region which is firewall protected\"\n\t}, {\n\t\t.code = \"TIMEOUT_ERR\",\n\t\t.desc = \"No response returned by slave\"\n\t}, {\n\t\t.code = \"PWRDOWN_ERR\",\n\t\t.desc = \"Attempt to access a portion of fabric that is powered down\"\n\t}, {\n\t\t.code = \"UNSUPPORTED_ERR\",\n\t\t.desc = \"Attempt to access a slave through an unsupported access\"\n\t}\n};\n\nstatic const struct tegra234_slave_lookup tegra234_aon_slave_map[] = {\n\t{ \"AXI2APB\", 0x00000 },\n\t{ \"AST\",     0x14000 },\n\t{ \"CBB\",     0x15000 },\n\t{ \"CPU\",     0x16000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_aon_fabric = {\n\t.name = \"aon-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_aon_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_aon_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x17000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x8d0,\n\t.firewall_wr_ctl = 0x8c8,\n};\n\nstatic const struct tegra234_slave_lookup tegra234_bpmp_slave_map[] = {\n\t{ \"AXI2APB\", 0x00000 },\n\t{ \"AST0\",    0x15000 },\n\t{ \"AST1\",    0x16000 },\n\t{ \"CBB\",     0x17000 },\n\t{ \"CPU\",     0x18000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_bpmp_fabric = {\n\t.name = \"bpmp-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_bpmp_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_bpmp_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x19000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x8f0,\n\t.firewall_wr_ctl = 0x8e8,\n};\n\nstatic const struct tegra234_slave_lookup tegra234_cbb_slave_map[] = {\n\t{ \"AON\",        0x40000 },\n\t{ \"BPMP\",       0x41000 },\n\t{ \"CBB\",        0x42000 },\n\t{ \"HOST1X\",     0x43000 },\n\t{ \"STM\",        0x44000 },\n\t{ \"FSI\",        0x45000 },\n\t{ \"PSC\",        0x46000 },\n\t{ \"PCIE_C1\",    0x47000 },\n\t{ \"PCIE_C2\",    0x48000 },\n\t{ \"PCIE_C3\",    0x49000 },\n\t{ \"PCIE_C0\",    0x4a000 },\n\t{ \"PCIE_C4\",    0x4b000 },\n\t{ \"GPU\",        0x4c000 },\n\t{ \"SMMU0\",      0x4d000 },\n\t{ \"SMMU1\",      0x4e000 },\n\t{ \"SMMU2\",      0x4f000 },\n\t{ \"SMMU3\",      0x50000 },\n\t{ \"SMMU4\",      0x51000 },\n\t{ \"PCIE_C10\",   0x52000 },\n\t{ \"PCIE_C7\",    0x53000 },\n\t{ \"PCIE_C8\",    0x54000 },\n\t{ \"PCIE_C9\",    0x55000 },\n\t{ \"PCIE_C5\",    0x56000 },\n\t{ \"PCIE_C6\",    0x57000 },\n\t{ \"DCE\",        0x58000 },\n\t{ \"RCE\",        0x59000 },\n\t{ \"SCE\",        0x5a000 },\n\t{ \"AXI2APB_1\",  0x70000 },\n\t{ \"AXI2APB_10\", 0x71000 },\n\t{ \"AXI2APB_11\", 0x72000 },\n\t{ \"AXI2APB_12\", 0x73000 },\n\t{ \"AXI2APB_13\", 0x74000 },\n\t{ \"AXI2APB_14\", 0x75000 },\n\t{ \"AXI2APB_15\", 0x76000 },\n\t{ \"AXI2APB_16\", 0x77000 },\n\t{ \"AXI2APB_17\", 0x78000 },\n\t{ \"AXI2APB_18\", 0x79000 },\n\t{ \"AXI2APB_19\", 0x7a000 },\n\t{ \"AXI2APB_2\",  0x7b000 },\n\t{ \"AXI2APB_20\", 0x7c000 },\n\t{ \"AXI2APB_21\", 0x7d000 },\n\t{ \"AXI2APB_22\", 0x7e000 },\n\t{ \"AXI2APB_23\", 0x7f000 },\n\t{ \"AXI2APB_25\", 0x80000 },\n\t{ \"AXI2APB_26\", 0x81000 },\n\t{ \"AXI2APB_27\", 0x82000 },\n\t{ \"AXI2APB_28\", 0x83000 },\n\t{ \"AXI2APB_29\", 0x84000 },\n\t{ \"AXI2APB_30\", 0x85000 },\n\t{ \"AXI2APB_31\", 0x86000 },\n\t{ \"AXI2APB_32\", 0x87000 },\n\t{ \"AXI2APB_33\", 0x88000 },\n\t{ \"AXI2APB_34\", 0x89000 },\n\t{ \"AXI2APB_35\", 0x92000 },\n\t{ \"AXI2APB_4\",  0x8b000 },\n\t{ \"AXI2APB_5\",  0x8c000 },\n\t{ \"AXI2APB_6\",  0x8d000 },\n\t{ \"AXI2APB_7\",  0x8e000 },\n\t{ \"AXI2APB_8\",  0x8f000 },\n\t{ \"AXI2APB_9\",  0x90000 },\n\t{ \"AXI2APB_3\",  0x91000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_cbb_fabric = {\n\t.name = \"cbb-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_cbb_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_cbb_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x60000,\n\t.off_mask_erd = 0x3a004,\n\t.firewall_base = 0x10000,\n\t.firewall_ctl = 0x23f0,\n\t.firewall_wr_ctl = 0x23e8,\n};\n\nstatic const struct tegra234_slave_lookup tegra234_common_slave_map[] = {\n\t{ \"AXI2APB\", 0x00000 },\n\t{ \"AST0\",    0x15000 },\n\t{ \"AST1\",    0x16000 },\n\t{ \"CBB\",     0x17000 },\n\t{ \"RSVD\",    0x00000 },\n\t{ \"CPU\",     0x18000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_dce_fabric = {\n\t.name = \"dce-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_common_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_common_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x19000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x290,\n\t.firewall_wr_ctl = 0x288,\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_rce_fabric = {\n\t.name = \"rce-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_common_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_common_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x19000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x290,\n\t.firewall_wr_ctl = 0x288,\n};\n\nstatic const struct tegra234_cbb_fabric tegra234_sce_fabric = {\n\t.name = \"sce-fabric\",\n\t.master_id = tegra234_master_id,\n\t.slave_map = tegra234_common_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra234_common_slave_map),\n\t.errors = tegra234_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra234_cbb_errors),\n\t.notifier_offset = 0x19000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x290,\n\t.firewall_wr_ctl = 0x288,\n};\n\nstatic const char * const tegra241_master_id[] = {\n\t[0x0] = \"TZ\",\n\t[0x1] = \"CCPLEX\",\n\t[0x2] = \"CCPMU\",\n\t[0x3] = \"BPMP_FW\",\n\t[0x4] = \"PSC_FW_USER\",\n\t[0x5] = \"PSC_FW_SUPERVISOR\",\n\t[0x6] = \"PSC_FW_MACHINE\",\n\t[0x7] = \"PSC_BOOT\",\n\t[0x8] = \"BPMP_BOOT\",\n\t[0x9] = \"JTAGM_DFT\",\n\t[0xa] = \"CORESIGHT\",\n\t[0xb] = \"GPU\",\n\t[0xc] = \"PEATRANS\",\n\t[0xd ... 0x3f] = \"RSVD\"\n};\n\n \nstatic const struct tegra_cbb_error tegra241_cbb_errors[] = {\n\t{\n\t\t.code = \"SLAVE_ERR\",\n\t\t.desc = \"Slave being accessed responded with an error.\"\n\t}, {\n\t\t.code = \"DECODE_ERR\",\n\t\t.desc = \"Attempt to access an address hole or Reserved region of memory.\"\n\t}, {\n\t\t.code = \"FIREWALL_ERR\",\n\t\t.desc = \"Attempt to access a region which is firewalled.\"\n\t}, {\n\t\t.code = \"TIMEOUT_ERR\",\n\t\t.desc = \"No response returned by slave.\"\n\t}, {\n\t\t.code = \"PWRDOWN_ERR\",\n\t\t.desc = \"Attempt to access a portion of the fabric that is powered down.\"\n\t}, {\n\t\t.code = \"UNSUPPORTED_ERR\",\n\t\t.desc = \"Attempt to access a slave through an unsupported access.\"\n\t}, {\n\t\t.code = \"POISON_ERR\",\n\t\t.desc = \"Slave responds with poison error to indicate error in data.\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"RSVD\"\n\t}, {\n\t\t.code = \"NO_SUCH_ADDRESS_ERR\",\n\t\t.desc = \"The address belongs to the pri_target range but there is no register \"\n\t\t\t\"implemented at the address.\"\n\t}, {\n\t\t.code = \"TASK_ERR\",\n\t\t.desc = \"Attempt to update a PRI task when the current task has still not \"\n\t\t\t\"completed.\"\n\t}, {\n\t\t.code = \"EXTERNAL_ERR\",\n\t\t.desc = \"Indicates that an external PRI register access met with an error due to \"\n\t\t\t\"any issue in the unit.\"\n\t}, {\n\t\t.code = \"INDEX_ERR\",\n\t\t.desc = \"Applicable to PRI index aperture pair, when the programmed index is \"\n\t\t\t\"outside the range defined in the manual.\"\n\t}, {\n\t\t.code = \"RESET_ERR\",\n\t\t.desc = \"Target in Reset Error: Attempt to access a SubPri or external PRI \"\n\t\t\t\"register but they are in reset.\"\n\t}, {\n\t\t.code = \"REGISTER_RST_ERR\",\n\t\t.desc = \"Attempt to access a PRI register but the register is partial or \"\n\t\t\t\"completely in reset.\"\n\t}, {\n\t\t.code = \"POWER_GATED_ERR\",\n\t\t.desc = \"Returned by external PRI client when the external access goes to a power \"\n\t\t\t\"gated domain.\"\n\t}, {\n\t\t.code = \"SUBPRI_FS_ERR\",\n\t\t.desc = \"Subpri is floorswept: Attempt to access a subpri through the main pri \"\n\t\t\t\"target but subPri logic is floorswept.\"\n\t}, {\n\t\t.code = \"SUBPRI_CLK_OFF_ERR\",\n\t\t.desc = \"Subpri clock is off: Attempt to access a subpri through the main pri \"\n\t\t\t\"target but subPris clock is gated/off.\"\n\t},\n};\n\nstatic const struct tegra234_slave_lookup tegra241_cbb_slave_map[] = {\n\t{ \"RSVD\",       0x00000 },\n\t{ \"PCIE_C8\",    0x51000 },\n\t{ \"PCIE_C9\",    0x52000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"AON\",        0x5b000 },\n\t{ \"BPMP\",       0x5c000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"RSVD\",       0x00000 },\n\t{ \"PSC\",        0x5d000 },\n\t{ \"STM\",        0x5e000 },\n\t{ \"AXI2APB_1\",  0x70000 },\n\t{ \"AXI2APB_10\", 0x71000 },\n\t{ \"AXI2APB_11\", 0x72000 },\n\t{ \"AXI2APB_12\", 0x73000 },\n\t{ \"AXI2APB_13\", 0x74000 },\n\t{ \"AXI2APB_14\", 0x75000 },\n\t{ \"AXI2APB_15\", 0x76000 },\n\t{ \"AXI2APB_16\", 0x77000 },\n\t{ \"AXI2APB_17\", 0x78000 },\n\t{ \"AXI2APB_18\", 0x79000 },\n\t{ \"AXI2APB_19\", 0x7a000 },\n\t{ \"AXI2APB_2\",  0x7b000 },\n\t{ \"AXI2APB_20\", 0x7c000 },\n\t{ \"AXI2APB_4\",  0x87000 },\n\t{ \"AXI2APB_5\",  0x88000 },\n\t{ \"AXI2APB_6\",  0x89000 },\n\t{ \"AXI2APB_7\",  0x8a000 },\n\t{ \"AXI2APB_8\",  0x8b000 },\n\t{ \"AXI2APB_9\",  0x8c000 },\n\t{ \"AXI2APB_3\",  0x8d000 },\n\t{ \"AXI2APB_21\", 0x7d000 },\n\t{ \"AXI2APB_22\", 0x7e000 },\n\t{ \"AXI2APB_23\", 0x7f000 },\n\t{ \"AXI2APB_24\", 0x80000 },\n\t{ \"AXI2APB_25\", 0x81000 },\n\t{ \"AXI2APB_26\", 0x82000 },\n\t{ \"AXI2APB_27\", 0x83000 },\n\t{ \"AXI2APB_28\", 0x84000 },\n\t{ \"PCIE_C4\",    0x53000 },\n\t{ \"PCIE_C5\",    0x54000 },\n\t{ \"PCIE_C6\",    0x55000 },\n\t{ \"PCIE_C7\",    0x56000 },\n\t{ \"PCIE_C2\",    0x57000 },\n\t{ \"PCIE_C3\",    0x58000 },\n\t{ \"PCIE_C0\",    0x59000 },\n\t{ \"PCIE_C1\",    0x5a000 },\n\t{ \"CCPLEX\",     0x50000 },\n\t{ \"AXI2APB_29\", 0x85000 },\n\t{ \"AXI2APB_30\", 0x86000 },\n\t{ \"CBB_CENTRAL\", 0x00000 },\n\t{ \"AXI2APB_31\", 0x8E000 },\n\t{ \"AXI2APB_32\", 0x8F000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra241_cbb_fabric = {\n\t.name = \"cbb-fabric\",\n\t.master_id = tegra241_master_id,\n\t.slave_map = tegra241_cbb_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra241_cbb_slave_map),\n\t.errors = tegra241_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra241_cbb_errors),\n\t.notifier_offset = 0x60000,\n\t.off_mask_erd = 0x40004,\n\t.firewall_base = 0x20000,\n\t.firewall_ctl = 0x2370,\n\t.firewall_wr_ctl = 0x2368,\n};\n\nstatic const struct tegra234_slave_lookup tegra241_bpmp_slave_map[] = {\n\t{ \"RSVD\",    0x00000 },\n\t{ \"RSVD\",    0x00000 },\n\t{ \"RSVD\",    0x00000 },\n\t{ \"CBB\",     0x15000 },\n\t{ \"CPU\",     0x16000 },\n\t{ \"AXI2APB\", 0x00000 },\n\t{ \"DBB0\",    0x17000 },\n\t{ \"DBB1\",    0x18000 },\n};\n\nstatic const struct tegra234_cbb_fabric tegra241_bpmp_fabric = {\n\t.name = \"bpmp-fabric\",\n\t.master_id = tegra241_master_id,\n\t.slave_map = tegra241_bpmp_slave_map,\n\t.max_slaves = ARRAY_SIZE(tegra241_bpmp_slave_map),\n\t.errors = tegra241_cbb_errors,\n\t.max_errors = ARRAY_SIZE(tegra241_cbb_errors),\n\t.notifier_offset = 0x19000,\n\t.firewall_base = 0x30000,\n\t.firewall_ctl = 0x8f0,\n\t.firewall_wr_ctl = 0x8e8,\n};\n\nstatic const struct of_device_id tegra234_cbb_dt_ids[] = {\n\t{ .compatible = \"nvidia,tegra234-cbb-fabric\", .data = &tegra234_cbb_fabric },\n\t{ .compatible = \"nvidia,tegra234-aon-fabric\", .data = &tegra234_aon_fabric },\n\t{ .compatible = \"nvidia,tegra234-bpmp-fabric\", .data = &tegra234_bpmp_fabric },\n\t{ .compatible = \"nvidia,tegra234-dce-fabric\", .data = &tegra234_dce_fabric },\n\t{ .compatible = \"nvidia,tegra234-rce-fabric\", .data = &tegra234_rce_fabric },\n\t{ .compatible = \"nvidia,tegra234-sce-fabric\", .data = &tegra234_sce_fabric },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, tegra234_cbb_dt_ids);\n\nstruct tegra234_cbb_acpi_uid {\n\tconst char *hid;\n\tconst char *uid;\n\tconst struct tegra234_cbb_fabric *fabric;\n};\n\nstatic const struct tegra234_cbb_acpi_uid tegra234_cbb_acpi_uids[] = {\n\t{ \"NVDA1070\", \"1\", &tegra241_cbb_fabric },\n\t{ \"NVDA1070\", \"2\", &tegra241_bpmp_fabric },\n\t{ },\n};\n\nstatic const struct\ntegra234_cbb_fabric *tegra234_cbb_acpi_get_fabric(struct acpi_device *adev)\n{\n\tconst struct tegra234_cbb_acpi_uid *entry;\n\n\tfor (entry = tegra234_cbb_acpi_uids; entry->hid; entry++) {\n\t\tif (acpi_dev_hid_uid_match(adev, entry->hid, entry->uid))\n\t\t\treturn entry->fabric;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct acpi_device_id tegra241_cbb_acpi_ids[] = {\n\t{ \"NVDA1070\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, tegra241_cbb_acpi_ids);\n\nstatic int tegra234_cbb_probe(struct platform_device *pdev)\n{\n\tconst struct tegra234_cbb_fabric *fabric;\n\tstruct tegra234_cbb *cbb;\n\tunsigned long flags = 0;\n\tint err;\n\n\tif (pdev->dev.of_node) {\n\t\tfabric = of_device_get_match_data(&pdev->dev);\n\t} else {\n\t\tstruct acpi_device *device = ACPI_COMPANION(&pdev->dev);\n\t\tif (!device)\n\t\t\treturn -ENODEV;\n\n\t\tfabric = tegra234_cbb_acpi_get_fabric(device);\n\t\tif (!fabric) {\n\t\t\tdev_err(&pdev->dev, \"no device match found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tcbb = devm_kzalloc(&pdev->dev, sizeof(*cbb), GFP_KERNEL);\n\tif (!cbb)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cbb->base.node);\n\tcbb->base.ops = &tegra234_cbb_ops;\n\tcbb->base.dev = &pdev->dev;\n\tcbb->fabric = fabric;\n\n\tcbb->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &cbb->res);\n\tif (IS_ERR(cbb->regs))\n\t\treturn PTR_ERR(cbb->regs);\n\n\terr = tegra_cbb_get_irq(pdev, NULL, &cbb->sec_irq);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, cbb);\n\n\t \n\tif (!tegra234_cbb_write_access_allowed(pdev, cbb)) {\n\t\tdev_info(&pdev->dev, \"error reporting not enabled due to firewall\\n\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&cbb_lock, flags);\n\tlist_add(&cbb->base.node, &cbb_list);\n\tspin_unlock_irqrestore(&cbb_lock, flags);\n\n\t \n\tif (cbb->fabric->off_mask_erd)\n\t\ttegra234_cbb_mask_serror(cbb);\n\n\treturn tegra_cbb_register(&cbb->base);\n}\n\nstatic int __maybe_unused tegra234_cbb_resume_noirq(struct device *dev)\n{\n\tstruct tegra234_cbb *cbb = dev_get_drvdata(dev);\n\n\ttegra234_cbb_error_enable(&cbb->base);\n\n\tdev_dbg(dev, \"%s resumed\\n\", cbb->fabric->name);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra234_cbb_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, tegra234_cbb_resume_noirq)\n};\n\nstatic struct platform_driver tegra234_cbb_driver = {\n\t.probe = tegra234_cbb_probe,\n\t.driver = {\n\t\t.name = \"tegra234-cbb\",\n\t\t.of_match_table = tegra234_cbb_dt_ids,\n\t\t.acpi_match_table = tegra241_cbb_acpi_ids,\n\t\t.pm = &tegra234_cbb_pm,\n\t},\n};\n\nstatic int __init tegra234_cbb_init(void)\n{\n\treturn platform_driver_register(&tegra234_cbb_driver);\n}\npure_initcall(tegra234_cbb_init);\n\nstatic void __exit tegra234_cbb_exit(void)\n{\n\tplatform_driver_unregister(&tegra234_cbb_driver);\n}\nmodule_exit(tegra234_cbb_exit);\n\nMODULE_DESCRIPTION(\"Control Backbone 2.0 error handling driver for Tegra234\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}