{
  "module_name": "tegra-cbb.c",
  "hash_id": "490937938bcc3130df9ba6bb54b9d4a1618a056cb8012de9dec3f299db57d95d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/cbb/tegra-cbb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpufeature.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/tegra-cbb.h>\n\nvoid tegra_cbb_print_err(struct seq_file *file, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (file) {\n\t\tseq_vprintf(file, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tpr_crit(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}\n\nvoid tegra_cbb_print_cache(struct seq_file *file, u32 cache)\n{\n\tconst char *buff_str, *mod_str, *rd_str, *wr_str;\n\n\tbuff_str = (cache & BIT(0)) ? \"Bufferable \" : \"\";\n\tmod_str = (cache & BIT(1)) ? \"Modifiable \" : \"\";\n\trd_str = (cache & BIT(2)) ? \"Read-Allocate \" : \"\";\n\twr_str = (cache & BIT(3)) ? \"Write-Allocate\" : \"\";\n\n\tif (cache == 0x0)\n\t\tbuff_str = \"Device Non-Bufferable\";\n\n\ttegra_cbb_print_err(file, \"\\t  Cache\\t\\t\\t: 0x%x -- %s%s%s%s\\n\",\n\t\t\t    cache, buff_str, mod_str, rd_str, wr_str);\n}\n\nvoid tegra_cbb_print_prot(struct seq_file *file, u32 prot)\n{\n\tconst char *data_str, *secure_str, *priv_str;\n\n\tdata_str = (prot & 0x4) ? \"Instruction\" : \"Data\";\n\tsecure_str = (prot & 0x2) ? \"Non-Secure\" : \"Secure\";\n\tpriv_str = (prot & 0x1) ? \"Privileged\" : \"Unprivileged\";\n\n\ttegra_cbb_print_err(file, \"\\t  Protection\\t\\t: 0x%x -- %s, %s, %s Access\\n\",\n\t\t\t    prot, priv_str, secure_str, data_str);\n}\n\nstatic int tegra_cbb_err_show(struct seq_file *file, void *data)\n{\n\tstruct tegra_cbb *cbb = file->private;\n\n\treturn cbb->ops->debugfs_show(cbb, file, data);\n}\nDEFINE_SHOW_ATTRIBUTE(tegra_cbb_err);\n\nstatic int tegra_cbb_err_debugfs_init(struct tegra_cbb *cbb)\n{\n\tstatic struct dentry *root;\n\n\tif (!root) {\n\t\troot = debugfs_create_file(\"tegra_cbb_err\", 0444, NULL, cbb, &tegra_cbb_err_fops);\n\t\tif (IS_ERR_OR_NULL(root)) {\n\t\t\tpr_err(\"%s(): could not create debugfs node\\n\", __func__);\n\t\t\treturn PTR_ERR(root);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid tegra_cbb_stall_enable(struct tegra_cbb *cbb)\n{\n\tif (cbb->ops->stall_enable)\n\t\tcbb->ops->stall_enable(cbb);\n}\n\nvoid tegra_cbb_fault_enable(struct tegra_cbb *cbb)\n{\n\tif (cbb->ops->fault_enable)\n\t\tcbb->ops->fault_enable(cbb);\n}\n\nvoid tegra_cbb_error_clear(struct tegra_cbb *cbb)\n{\n\tif (cbb->ops->error_clear)\n\t\tcbb->ops->error_clear(cbb);\n}\n\nu32 tegra_cbb_get_status(struct tegra_cbb *cbb)\n{\n\tif (cbb->ops->get_status)\n\t\treturn cbb->ops->get_status(cbb);\n\n\treturn 0;\n}\n\nint tegra_cbb_get_irq(struct platform_device *pdev, unsigned int *nonsec_irq,\n\t\t      unsigned int *sec_irq)\n{\n\tunsigned int index = 0;\n\tint num_intr = 0, irq;\n\n\tnum_intr = platform_irq_count(pdev);\n\tif (!num_intr)\n\t\treturn -EINVAL;\n\n\tif (num_intr == 2) {\n\t\tirq = platform_get_irq(pdev, index);\n\t\tif (irq <= 0)\n\t\t\treturn -ENOENT;\n\n\t\t*nonsec_irq = irq;\n\t\tindex++;\n\t}\n\n\tirq = platform_get_irq(pdev, index);\n\tif (irq <= 0)\n\t\treturn -ENOENT;\n\n\t*sec_irq = irq;\n\n\tif (num_intr == 1)\n\t\tdev_dbg(&pdev->dev, \"secure IRQ: %u\\n\", *sec_irq);\n\n\tif (num_intr == 2)\n\t\tdev_dbg(&pdev->dev, \"secure IRQ: %u, non-secure IRQ: %u\\n\", *sec_irq, *nonsec_irq);\n\n\treturn 0;\n}\n\nint tegra_cbb_register(struct tegra_cbb *cbb)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS)) {\n\t\tret = tegra_cbb_err_debugfs_init(cbb);\n\t\tif (ret) {\n\t\t\tdev_err(cbb->dev, \"failed to create debugfs\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = cbb->ops->interrupt_enable(cbb);\n\tif (ret < 0) {\n\t\tdev_err(cbb->dev, \"Failed to register CBB Interrupt ISR\");\n\t\treturn ret;\n\t}\n\n\tcbb->ops->error_enable(cbb);\n\tdsb(sy);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}