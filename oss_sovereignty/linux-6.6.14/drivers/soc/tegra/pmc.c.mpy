{
  "module_name": "pmc.c",
  "hash_id": "92d0b8851df686311fb0b24ee49bbfb11b27df286fd6d67f28ab102856fbcf3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/tegra/pmc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"tegra-pmc: \" fmt\n\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/clk/tegra.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/of_clk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/power_supply.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/syscore_ops.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/pmc.h>\n\n#include <dt-bindings/interrupt-controller/arm-gic.h>\n#include <dt-bindings/pinctrl/pinctrl-tegra-io-pad.h>\n#include <dt-bindings/gpio/tegra186-gpio.h>\n#include <dt-bindings/gpio/tegra194-gpio.h>\n#include <dt-bindings/gpio/tegra234-gpio.h>\n#include <dt-bindings/soc/tegra-pmc.h>\n\n#define PMC_CNTRL\t\t\t0x0\n#define  PMC_CNTRL_INTR_POLARITY\tBIT(17)  \n#define  PMC_CNTRL_CPU_PWRREQ_OE\tBIT(16)  \n#define  PMC_CNTRL_CPU_PWRREQ_POLARITY\tBIT(15)  \n#define  PMC_CNTRL_SIDE_EFFECT_LP0\tBIT(14)  \n#define  PMC_CNTRL_SYSCLK_OE\t\tBIT(11)  \n#define  PMC_CNTRL_SYSCLK_POLARITY\tBIT(10)  \n#define  PMC_CNTRL_PWRREQ_POLARITY\tBIT(8)\n#define  PMC_CNTRL_BLINK_EN\t\t7\n#define  PMC_CNTRL_MAIN_RST\t\tBIT(4)\n\n#define PMC_WAKE_MASK\t\t\t0x0c\n#define PMC_WAKE_LEVEL\t\t\t0x10\n#define PMC_WAKE_STATUS\t\t\t0x14\n#define PMC_SW_WAKE_STATUS\t\t0x18\n#define PMC_DPD_PADS_ORIDE\t\t0x1c\n#define  PMC_DPD_PADS_ORIDE_BLINK\t20\n\n#define DPD_SAMPLE\t\t\t0x020\n#define  DPD_SAMPLE_ENABLE\t\tBIT(0)\n#define  DPD_SAMPLE_DISABLE\t\t(0 << 0)\n\n#define PWRGATE_TOGGLE\t\t\t0x30\n#define  PWRGATE_TOGGLE_START\t\tBIT(8)\n\n#define REMOVE_CLAMPING\t\t\t0x34\n\n#define PWRGATE_STATUS\t\t\t0x38\n\n#define PMC_BLINK_TIMER\t\t\t0x40\n#define PMC_IMPL_E_33V_PWR\t\t0x40\n\n#define PMC_PWR_DET\t\t\t0x48\n\n#define PMC_SCRATCH0_MODE_RECOVERY\tBIT(31)\n#define PMC_SCRATCH0_MODE_BOOTLOADER\tBIT(30)\n#define PMC_SCRATCH0_MODE_RCM\t\tBIT(1)\n#define PMC_SCRATCH0_MODE_MASK\t\t(PMC_SCRATCH0_MODE_RECOVERY | \\\n\t\t\t\t\t PMC_SCRATCH0_MODE_BOOTLOADER | \\\n\t\t\t\t\t PMC_SCRATCH0_MODE_RCM)\n\n#define PMC_CPUPWRGOOD_TIMER\t\t0xc8\n#define PMC_CPUPWROFF_TIMER\t\t0xcc\n#define PMC_COREPWRGOOD_TIMER\t\t0x3c\n#define PMC_COREPWROFF_TIMER\t\t0xe0\n\n#define PMC_PWR_DET_VALUE\t\t0xe4\n\n#define PMC_USB_DEBOUNCE_DEL\t\t0xec\n#define PMC_USB_AO\t\t\t0xf0\n\n#define PMC_SCRATCH37\t\t\t0x130\n#define PMC_SCRATCH41\t\t\t0x140\n\n#define PMC_WAKE2_MASK\t\t\t0x160\n#define PMC_WAKE2_LEVEL\t\t\t0x164\n#define PMC_WAKE2_STATUS\t\t0x168\n#define PMC_SW_WAKE2_STATUS\t\t0x16c\n\n#define PMC_CLK_OUT_CNTRL\t\t0x1a8\n#define  PMC_CLK_OUT_MUX_MASK\t\tGENMASK(1, 0)\n#define PMC_SENSOR_CTRL\t\t\t0x1b0\n#define  PMC_SENSOR_CTRL_SCRATCH_WRITE\tBIT(2)\n#define  PMC_SENSOR_CTRL_ENABLE_RST\tBIT(1)\n\n#define  PMC_RST_STATUS_POR\t\t0\n#define  PMC_RST_STATUS_WATCHDOG\t1\n#define  PMC_RST_STATUS_SENSOR\t\t2\n#define  PMC_RST_STATUS_SW_MAIN\t\t3\n#define  PMC_RST_STATUS_LP0\t\t4\n#define  PMC_RST_STATUS_AOTAG\t\t5\n\n#define IO_DPD_REQ\t\t\t0x1b8\n#define  IO_DPD_REQ_CODE_IDLE\t\t(0U << 30)\n#define  IO_DPD_REQ_CODE_OFF\t\t(1U << 30)\n#define  IO_DPD_REQ_CODE_ON\t\t(2U << 30)\n#define  IO_DPD_REQ_CODE_MASK\t\t(3U << 30)\n\n#define IO_DPD_STATUS\t\t\t0x1bc\n#define IO_DPD2_REQ\t\t\t0x1c0\n#define IO_DPD2_STATUS\t\t\t0x1c4\n#define SEL_DPD_TIM\t\t\t0x1c8\n\n#define PMC_UTMIP_UHSIC_TRIGGERS\t0x1ec\n#define PMC_UTMIP_UHSIC_SAVED_STATE\t0x1f0\n\n#define PMC_UTMIP_TERM_PAD_CFG\t\t0x1f8\n#define PMC_UTMIP_UHSIC_SLEEP_CFG\t0x1fc\n#define PMC_UTMIP_UHSIC_FAKE\t\t0x218\n\n#define PMC_SCRATCH54\t\t\t0x258\n#define  PMC_SCRATCH54_DATA_SHIFT\t8\n#define  PMC_SCRATCH54_ADDR_SHIFT\t0\n\n#define PMC_SCRATCH55\t\t\t0x25c\n#define  PMC_SCRATCH55_RESET_TEGRA\tBIT(31)\n#define  PMC_SCRATCH55_CNTRL_ID_SHIFT\t27\n#define  PMC_SCRATCH55_PINMUX_SHIFT\t24\n#define  PMC_SCRATCH55_16BITOP\t\tBIT(15)\n#define  PMC_SCRATCH55_CHECKSUM_SHIFT\t16\n#define  PMC_SCRATCH55_I2CSLV1_SHIFT\t0\n\n#define  PMC_UTMIP_UHSIC_LINE_WAKEUP\t0x26c\n\n#define PMC_UTMIP_BIAS_MASTER_CNTRL\t0x270\n#define PMC_UTMIP_MASTER_CONFIG\t\t0x274\n#define PMC_UTMIP_UHSIC2_TRIGGERS\t0x27c\n#define PMC_UTMIP_MASTER2_CONFIG\t0x29c\n\n#define GPU_RG_CNTRL\t\t\t0x2d4\n\n#define PMC_UTMIP_PAD_CFG0\t\t0x4c0\n#define PMC_UTMIP_UHSIC_SLEEP_CFG1\t0x4d0\n#define PMC_UTMIP_SLEEPWALK_P3\t\t0x4e0\n \n#define WAKE_AOWAKE_CNTRL(x) (0x000 + ((x) << 2))\n#define WAKE_AOWAKE_CNTRL_LEVEL (1 << 3)\n#define WAKE_AOWAKE_CNTRL_SR_CAPTURE_EN (1 << 1)\n#define WAKE_AOWAKE_MASK_W(x) (0x180 + ((x) << 2))\n#define WAKE_AOWAKE_MASK_R(x) (0x300 + ((x) << 2))\n#define WAKE_AOWAKE_STATUS_W(x) (0x30c + ((x) << 2))\n#define WAKE_AOWAKE_STATUS_R(x) (0x48c + ((x) << 2))\n#define WAKE_AOWAKE_TIER0_ROUTING(x) (0x4b4 + ((x) << 2))\n#define WAKE_AOWAKE_TIER1_ROUTING(x) (0x4c0 + ((x) << 2))\n#define WAKE_AOWAKE_TIER2_ROUTING(x) (0x4cc + ((x) << 2))\n#define WAKE_AOWAKE_SW_STATUS_W_0\t0x49c\n#define WAKE_AOWAKE_SW_STATUS(x)\t(0x4a0 + ((x) << 2))\n#define WAKE_LATCH_SW\t\t\t0x498\n\n#define WAKE_AOWAKE_CTRL 0x4f4\n#define  WAKE_AOWAKE_CTRL_INTR_POLARITY BIT(0)\n\n#define SW_WAKE_ID\t\t83  \n\n \n#define TEGRA_SMC_PMC\t\t0xc2fffe00\n#define  TEGRA_SMC_PMC_READ\t0xaa\n#define  TEGRA_SMC_PMC_WRITE\t0xbb\n\nstruct pmc_clk {\n\tstruct clk_hw\thw;\n\tunsigned long\toffs;\n\tu32\t\tmux_shift;\n\tu32\t\tforce_en_shift;\n};\n\n#define to_pmc_clk(_hw) container_of(_hw, struct pmc_clk, hw)\n\nstruct pmc_clk_gate {\n\tstruct clk_hw\thw;\n\tunsigned long\toffs;\n\tu32\t\tshift;\n};\n\n#define to_pmc_clk_gate(_hw) container_of(_hw, struct pmc_clk_gate, hw)\n\nstruct pmc_clk_init_data {\n\tchar *name;\n\tconst char *const *parents;\n\tint num_parents;\n\tint clk_id;\n\tu8 mux_shift;\n\tu8 force_en_shift;\n};\n\nstatic const char * const clk_out1_parents[] = { \"osc\", \"osc_div2\",\n\t\"osc_div4\", \"extern1\",\n};\n\nstatic const char * const clk_out2_parents[] = { \"osc\", \"osc_div2\",\n\t\"osc_div4\", \"extern2\",\n};\n\nstatic const char * const clk_out3_parents[] = { \"osc\", \"osc_div2\",\n\t\"osc_div4\", \"extern3\",\n};\n\nstatic const struct pmc_clk_init_data tegra_pmc_clks_data[] = {\n\t{\n\t\t.name = \"pmc_clk_out_1\",\n\t\t.parents = clk_out1_parents,\n\t\t.num_parents = ARRAY_SIZE(clk_out1_parents),\n\t\t.clk_id = TEGRA_PMC_CLK_OUT_1,\n\t\t.mux_shift = 6,\n\t\t.force_en_shift = 2,\n\t},\n\t{\n\t\t.name = \"pmc_clk_out_2\",\n\t\t.parents = clk_out2_parents,\n\t\t.num_parents = ARRAY_SIZE(clk_out2_parents),\n\t\t.clk_id = TEGRA_PMC_CLK_OUT_2,\n\t\t.mux_shift = 14,\n\t\t.force_en_shift = 10,\n\t},\n\t{\n\t\t.name = \"pmc_clk_out_3\",\n\t\t.parents = clk_out3_parents,\n\t\t.num_parents = ARRAY_SIZE(clk_out3_parents),\n\t\t.clk_id = TEGRA_PMC_CLK_OUT_3,\n\t\t.mux_shift = 22,\n\t\t.force_en_shift = 18,\n\t},\n};\n\nstruct tegra_powergate {\n\tstruct generic_pm_domain genpd;\n\tstruct tegra_pmc *pmc;\n\tunsigned int id;\n\tstruct clk **clks;\n\tunsigned int num_clks;\n\tunsigned long *clk_rates;\n\tstruct reset_control *reset;\n};\n\nstruct tegra_io_pad_soc {\n\tenum tegra_io_pad id;\n\tunsigned int dpd;\n\tunsigned int request;\n\tunsigned int status;\n\tunsigned int voltage;\n\tconst char *name;\n};\n\nstruct tegra_pmc_regs {\n\tunsigned int scratch0;\n\tunsigned int rst_status;\n\tunsigned int rst_source_shift;\n\tunsigned int rst_source_mask;\n\tunsigned int rst_level_shift;\n\tunsigned int rst_level_mask;\n};\n\nstruct tegra_wake_event {\n\tconst char *name;\n\tunsigned int id;\n\tunsigned int irq;\n\tstruct {\n\t\tunsigned int instance;\n\t\tunsigned int pin;\n\t} gpio;\n};\n\n#define TEGRA_WAKE_SIMPLE(_name, _id)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\\\n\t\t.irq = 0,\t\t\t\t\\\n\t\t.gpio = {\t\t\t\t\\\n\t\t\t.instance = UINT_MAX,\t\t\\\n\t\t\t.pin = UINT_MAX,\t\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\n#define TEGRA_WAKE_IRQ(_name, _id, _irq)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\\\n\t\t.irq = _irq,\t\t\t\t\\\n\t\t.gpio = {\t\t\t\t\\\n\t\t\t.instance = UINT_MAX,\t\t\\\n\t\t\t.pin = UINT_MAX,\t\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\n#define TEGRA_WAKE_GPIO(_name, _id, _instance, _pin)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\\\n\t\t.irq = 0,\t\t\t\t\\\n\t\t.gpio = {\t\t\t\t\\\n\t\t\t.instance = _instance,\t\t\\\n\t\t\t.pin = _pin,\t\t\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\nstruct tegra_pmc_soc {\n\tunsigned int num_powergates;\n\tconst char *const *powergates;\n\tunsigned int num_cpu_powergates;\n\tconst u8 *cpu_powergates;\n\n\tbool has_tsense_reset;\n\tbool has_gpu_clamps;\n\tbool needs_mbist_war;\n\tbool has_impl_33v_pwr;\n\tbool maybe_tz_only;\n\n\tconst struct tegra_io_pad_soc *io_pads;\n\tunsigned int num_io_pads;\n\n\tconst struct pinctrl_pin_desc *pin_descs;\n\tunsigned int num_pin_descs;\n\n\tconst struct tegra_pmc_regs *regs;\n\tvoid (*init)(struct tegra_pmc *pmc);\n\tvoid (*setup_irq_polarity)(struct tegra_pmc *pmc,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   bool invert);\n\tvoid (*set_wake_filters)(struct tegra_pmc *pmc);\n\tint (*irq_set_wake)(struct irq_data *data, unsigned int on);\n\tint (*irq_set_type)(struct irq_data *data, unsigned int type);\n\tint (*powergate_set)(struct tegra_pmc *pmc, unsigned int id,\n\t\t\t     bool new_state);\n\n\tconst char * const *reset_sources;\n\tunsigned int num_reset_sources;\n\tconst char * const *reset_levels;\n\tunsigned int num_reset_levels;\n\n\t \n\tconst struct tegra_wake_event *wake_events;\n\tunsigned int num_wake_events;\n\tunsigned int max_wake_events;\n\tunsigned int max_wake_vectors;\n\n\tconst struct pmc_clk_init_data *pmc_clks_data;\n\tunsigned int num_pmc_clks;\n\tbool has_blink_output;\n\tbool has_usb_sleepwalk;\n\tbool supports_core_domain;\n};\n\n \nstruct tegra_pmc {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *wake;\n\tvoid __iomem *aotag;\n\tvoid __iomem *scratch;\n\tstruct clk *clk;\n\n\tconst struct tegra_pmc_soc *soc;\n\tbool tz_only;\n\n\tunsigned long rate;\n\n\tenum tegra_suspend_mode suspend_mode;\n\tu32 cpu_good_time;\n\tu32 cpu_off_time;\n\tu32 core_osc_time;\n\tu32 core_pmu_time;\n\tu32 core_off_time;\n\tbool corereq_high;\n\tbool sysclkreq_high;\n\tbool combined_req;\n\tbool cpu_pwr_good_en;\n\tu32 lp0_vec_phys;\n\tu32 lp0_vec_size;\n\tDECLARE_BITMAP(powergates_available, TEGRA_POWERGATE_MAX);\n\n\tstruct mutex powergates_lock;\n\n\tstruct pinctrl_dev *pctl_dev;\n\n\tstruct irq_domain *domain;\n\tstruct irq_chip irq;\n\n\tstruct notifier_block clk_nb;\n\n\tbool core_domain_state_synced;\n\tbool core_domain_registered;\n\n\tunsigned long *wake_type_level_map;\n\tunsigned long *wake_type_dual_edge_map;\n\tunsigned long *wake_sw_status_map;\n\tunsigned long *wake_cntrl_level_map;\n\tstruct syscore_ops syscore;\n};\n\nstatic struct tegra_pmc *pmc = &(struct tegra_pmc) {\n\t.base = NULL,\n\t.suspend_mode = TEGRA_SUSPEND_NOT_READY,\n};\n\nstatic inline struct tegra_powergate *\nto_powergate(struct generic_pm_domain *domain)\n{\n\treturn container_of(domain, struct tegra_powergate, genpd);\n}\n\nstatic u32 tegra_pmc_readl(struct tegra_pmc *pmc, unsigned long offset)\n{\n\tstruct arm_smccc_res res;\n\n\tif (pmc->tz_only) {\n\t\tarm_smccc_smc(TEGRA_SMC_PMC, TEGRA_SMC_PMC_READ, offset, 0, 0,\n\t\t\t      0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tif (pmc->dev)\n\t\t\t\tdev_warn(pmc->dev, \"%s(): SMC failed: %lu\\n\",\n\t\t\t\t\t __func__, res.a0);\n\t\t\telse\n\t\t\t\tpr_warn(\"%s(): SMC failed: %lu\\n\", __func__,\n\t\t\t\t\tres.a0);\n\t\t}\n\n\t\treturn res.a1;\n\t}\n\n\treturn readl(pmc->base + offset);\n}\n\nstatic void tegra_pmc_writel(struct tegra_pmc *pmc, u32 value,\n\t\t\t     unsigned long offset)\n{\n\tstruct arm_smccc_res res;\n\n\tif (pmc->tz_only) {\n\t\tarm_smccc_smc(TEGRA_SMC_PMC, TEGRA_SMC_PMC_WRITE, offset,\n\t\t\t      value, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tif (pmc->dev)\n\t\t\t\tdev_warn(pmc->dev, \"%s(): SMC failed: %lu\\n\",\n\t\t\t\t\t __func__, res.a0);\n\t\t\telse\n\t\t\t\tpr_warn(\"%s(): SMC failed: %lu\\n\", __func__,\n\t\t\t\t\tres.a0);\n\t\t}\n\t} else {\n\t\twritel(value, pmc->base + offset);\n\t}\n}\n\nstatic u32 tegra_pmc_scratch_readl(struct tegra_pmc *pmc, unsigned long offset)\n{\n\tif (pmc->tz_only)\n\t\treturn tegra_pmc_readl(pmc, offset);\n\n\treturn readl(pmc->scratch + offset);\n}\n\nstatic void tegra_pmc_scratch_writel(struct tegra_pmc *pmc, u32 value,\n\t\t\t\t     unsigned long offset)\n{\n\tif (pmc->tz_only)\n\t\ttegra_pmc_writel(pmc, value, offset);\n\telse\n\t\twritel(value, pmc->scratch + offset);\n}\n\n \nstatic inline bool tegra_powergate_state(int id)\n{\n\tif (id == TEGRA_POWERGATE_3D && pmc->soc->has_gpu_clamps)\n\t\treturn (tegra_pmc_readl(pmc, GPU_RG_CNTRL) & 0x1) == 0;\n\telse\n\t\treturn (tegra_pmc_readl(pmc, PWRGATE_STATUS) & BIT(id)) != 0;\n}\n\nstatic inline bool tegra_powergate_is_valid(struct tegra_pmc *pmc, int id)\n{\n\treturn (pmc->soc && pmc->soc->powergates[id]);\n}\n\nstatic inline bool tegra_powergate_is_available(struct tegra_pmc *pmc, int id)\n{\n\treturn test_bit(id, pmc->powergates_available);\n}\n\nstatic int tegra_powergate_lookup(struct tegra_pmc *pmc, const char *name)\n{\n\tunsigned int i;\n\n\tif (!pmc || !pmc->soc || !name)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < pmc->soc->num_powergates; i++) {\n\t\tif (!tegra_powergate_is_valid(pmc, i))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(name, pmc->soc->powergates[i]))\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int tegra20_powergate_set(struct tegra_pmc *pmc, unsigned int id,\n\t\t\t\t bool new_state)\n{\n\tunsigned int retries = 100;\n\tbool status;\n\tint ret;\n\n\t \n\tdo {\n\t\ttegra_pmc_writel(pmc, PWRGATE_TOGGLE_START | id, PWRGATE_TOGGLE);\n\n\t\t \n\t\tret = readx_poll_timeout(tegra_powergate_state, id, status,\n\t\t\t\t\t status == new_state, 1, 10);\n\t} while (ret == -ETIMEDOUT && retries--);\n\n\treturn ret;\n}\n\nstatic inline bool tegra_powergate_toggle_ready(struct tegra_pmc *pmc)\n{\n\treturn !(tegra_pmc_readl(pmc, PWRGATE_TOGGLE) & PWRGATE_TOGGLE_START);\n}\n\nstatic int tegra114_powergate_set(struct tegra_pmc *pmc, unsigned int id,\n\t\t\t\t  bool new_state)\n{\n\tbool status;\n\tint err;\n\n\t \n\terr = readx_poll_timeout(tegra_powergate_toggle_ready, pmc, status,\n\t\t\t\t status == true, 1, 100);\n\tif (err)\n\t\treturn err;\n\n\ttegra_pmc_writel(pmc, PWRGATE_TOGGLE_START | id, PWRGATE_TOGGLE);\n\n\t \n\terr = readx_poll_timeout(tegra_powergate_toggle_ready, pmc, status,\n\t\t\t\t status == true, 1, 100);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = readx_poll_timeout(tegra_powergate_state, id, status,\n\t\t\t\t status == new_state, 10, 100000);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int tegra_powergate_set(struct tegra_pmc *pmc, unsigned int id,\n\t\t\t       bool new_state)\n{\n\tint err;\n\n\tif (id == TEGRA_POWERGATE_3D && pmc->soc->has_gpu_clamps)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pmc->powergates_lock);\n\n\tif (tegra_powergate_state(id) == new_state) {\n\t\tmutex_unlock(&pmc->powergates_lock);\n\t\treturn 0;\n\t}\n\n\terr = pmc->soc->powergate_set(pmc, id, new_state);\n\n\tmutex_unlock(&pmc->powergates_lock);\n\n\treturn err;\n}\n\nstatic int __tegra_powergate_remove_clamping(struct tegra_pmc *pmc,\n\t\t\t\t\t     unsigned int id)\n{\n\tu32 mask;\n\n\tmutex_lock(&pmc->powergates_lock);\n\n\t \n\tif (id == TEGRA_POWERGATE_3D) {\n\t\tif (pmc->soc->has_gpu_clamps) {\n\t\t\ttegra_pmc_writel(pmc, 0, GPU_RG_CNTRL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (id == TEGRA_POWERGATE_VDEC)\n\t\tmask = (1 << TEGRA_POWERGATE_PCIE);\n\telse if (id == TEGRA_POWERGATE_PCIE)\n\t\tmask = (1 << TEGRA_POWERGATE_VDEC);\n\telse\n\t\tmask = (1 << id);\n\n\ttegra_pmc_writel(pmc, mask, REMOVE_CLAMPING);\n\nout:\n\tmutex_unlock(&pmc->powergates_lock);\n\n\treturn 0;\n}\n\nstatic int tegra_powergate_prepare_clocks(struct tegra_powergate *pg)\n{\n\tunsigned long safe_rate = 100 * 1000 * 1000;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < pg->num_clks; i++) {\n\t\tpg->clk_rates[i] = clk_get_rate(pg->clks[i]);\n\n\t\tif (!pg->clk_rates[i]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pg->clk_rates[i] <= safe_rate)\n\t\t\tcontinue;\n\n\t\t \n\t\terr = clk_set_rate(pg->clks[i], safe_rate);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\twhile (i--)\n\t\tclk_set_rate(pg->clks[i], pg->clk_rates[i]);\n\n\treturn err;\n}\n\nstatic int tegra_powergate_unprepare_clocks(struct tegra_powergate *pg)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < pg->num_clks; i++) {\n\t\terr = clk_set_rate(pg->clks[i], pg->clk_rates[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_powergate_disable_clocks(struct tegra_powergate *pg)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pg->num_clks; i++)\n\t\tclk_disable_unprepare(pg->clks[i]);\n}\n\nstatic int tegra_powergate_enable_clocks(struct tegra_powergate *pg)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < pg->num_clks; i++) {\n\t\terr = clk_prepare_enable(pg->clks[i]);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\twhile (i--)\n\t\tclk_disable_unprepare(pg->clks[i]);\n\n\treturn err;\n}\n\nstatic int tegra_powergate_power_up(struct tegra_powergate *pg,\n\t\t\t\t    bool disable_clocks)\n{\n\tint err;\n\n\terr = reset_control_assert(pg->reset);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\terr = tegra_powergate_set(pg->pmc, pg->id, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\terr = tegra_powergate_prepare_clocks(pg);\n\tif (err)\n\t\tgoto powergate_off;\n\n\terr = tegra_powergate_enable_clocks(pg);\n\tif (err)\n\t\tgoto unprepare_clks;\n\n\tusleep_range(10, 20);\n\n\terr = __tegra_powergate_remove_clamping(pg->pmc, pg->id);\n\tif (err)\n\t\tgoto disable_clks;\n\n\tusleep_range(10, 20);\n\n\terr = reset_control_deassert(pg->reset);\n\tif (err)\n\t\tgoto disable_clks;\n\n\tusleep_range(10, 20);\n\n\tif (pg->pmc->soc->needs_mbist_war)\n\t\terr = tegra210_clk_handle_mbist_war(pg->id);\n\tif (err)\n\t\tgoto disable_clks;\n\n\tif (disable_clocks)\n\t\ttegra_powergate_disable_clocks(pg);\n\n\terr = tegra_powergate_unprepare_clocks(pg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n\ndisable_clks:\n\ttegra_powergate_disable_clocks(pg);\n\tusleep_range(10, 20);\n\nunprepare_clks:\n\ttegra_powergate_unprepare_clocks(pg);\n\npowergate_off:\n\ttegra_powergate_set(pg->pmc, pg->id, false);\n\n\treturn err;\n}\n\nstatic int tegra_powergate_power_down(struct tegra_powergate *pg)\n{\n\tint err;\n\n\terr = tegra_powergate_prepare_clocks(pg);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_powergate_enable_clocks(pg);\n\tif (err)\n\t\tgoto unprepare_clks;\n\n\tusleep_range(10, 20);\n\n\terr = reset_control_assert(pg->reset);\n\tif (err)\n\t\tgoto disable_clks;\n\n\tusleep_range(10, 20);\n\n\ttegra_powergate_disable_clocks(pg);\n\n\tusleep_range(10, 20);\n\n\terr = tegra_powergate_set(pg->pmc, pg->id, false);\n\tif (err)\n\t\tgoto assert_resets;\n\n\terr = tegra_powergate_unprepare_clocks(pg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n\nassert_resets:\n\ttegra_powergate_enable_clocks(pg);\n\tusleep_range(10, 20);\n\treset_control_deassert(pg->reset);\n\tusleep_range(10, 20);\n\ndisable_clks:\n\ttegra_powergate_disable_clocks(pg);\n\nunprepare_clks:\n\ttegra_powergate_unprepare_clocks(pg);\n\n\treturn err;\n}\n\nstatic int tegra_genpd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct tegra_powergate *pg = to_powergate(domain);\n\tstruct device *dev = pg->pmc->dev;\n\tint err;\n\n\terr = tegra_powergate_power_up(pg, true);\n\tif (err) {\n\t\tdev_err(dev, \"failed to turn on PM domain %s: %d\\n\",\n\t\t\tpg->genpd.name, err);\n\t\tgoto out;\n\t}\n\n\treset_control_release(pg->reset);\n\nout:\n\treturn err;\n}\n\nstatic int tegra_genpd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct tegra_powergate *pg = to_powergate(domain);\n\tstruct device *dev = pg->pmc->dev;\n\tint err;\n\n\terr = reset_control_acquire(pg->reset);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to acquire resets for PM domain %s: %d\\n\",\n\t\t\tpg->genpd.name, err);\n\t\treturn err;\n\t}\n\n\terr = tegra_powergate_power_down(pg);\n\tif (err) {\n\t\tdev_err(dev, \"failed to turn off PM domain %s: %d\\n\",\n\t\t\tpg->genpd.name, err);\n\t\treset_control_release(pg->reset);\n\t}\n\n\treturn err;\n}\n\n \nint tegra_powergate_power_on(unsigned int id)\n{\n\tif (!tegra_powergate_is_available(pmc, id))\n\t\treturn -EINVAL;\n\n\treturn tegra_powergate_set(pmc, id, true);\n}\nEXPORT_SYMBOL(tegra_powergate_power_on);\n\n \nint tegra_powergate_power_off(unsigned int id)\n{\n\tif (!tegra_powergate_is_available(pmc, id))\n\t\treturn -EINVAL;\n\n\treturn tegra_powergate_set(pmc, id, false);\n}\nEXPORT_SYMBOL(tegra_powergate_power_off);\n\n \nstatic int tegra_powergate_is_powered(struct tegra_pmc *pmc, unsigned int id)\n{\n\tif (!tegra_powergate_is_valid(pmc, id))\n\t\treturn -EINVAL;\n\n\treturn tegra_powergate_state(id);\n}\n\n \nint tegra_powergate_remove_clamping(unsigned int id)\n{\n\tif (!tegra_powergate_is_available(pmc, id))\n\t\treturn -EINVAL;\n\n\treturn __tegra_powergate_remove_clamping(pmc, id);\n}\nEXPORT_SYMBOL(tegra_powergate_remove_clamping);\n\n \nint tegra_powergate_sequence_power_up(unsigned int id, struct clk *clk,\n\t\t\t\t      struct reset_control *rst)\n{\n\tstruct tegra_powergate *pg;\n\tint err;\n\n\tif (!tegra_powergate_is_available(pmc, id))\n\t\treturn -EINVAL;\n\n\tpg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn -ENOMEM;\n\n\tpg->clk_rates = kzalloc(sizeof(*pg->clk_rates), GFP_KERNEL);\n\tif (!pg->clk_rates) {\n\t\tkfree(pg->clks);\n\t\treturn -ENOMEM;\n\t}\n\n\tpg->id = id;\n\tpg->clks = &clk;\n\tpg->num_clks = 1;\n\tpg->reset = rst;\n\tpg->pmc = pmc;\n\n\terr = tegra_powergate_power_up(pg, false);\n\tif (err)\n\t\tdev_err(pmc->dev, \"failed to turn on partition %d: %d\\n\", id,\n\t\t\terr);\n\n\tkfree(pg->clk_rates);\n\tkfree(pg);\n\n\treturn err;\n}\nEXPORT_SYMBOL(tegra_powergate_sequence_power_up);\n\n \nstatic int tegra_get_cpu_powergate_id(struct tegra_pmc *pmc,\n\t\t\t\t      unsigned int cpuid)\n{\n\tif (pmc->soc && cpuid < pmc->soc->num_cpu_powergates)\n\t\treturn pmc->soc->cpu_powergates[cpuid];\n\n\treturn -EINVAL;\n}\n\n \nbool tegra_pmc_cpu_is_powered(unsigned int cpuid)\n{\n\tint id;\n\n\tid = tegra_get_cpu_powergate_id(pmc, cpuid);\n\tif (id < 0)\n\t\treturn false;\n\n\treturn tegra_powergate_is_powered(pmc, id);\n}\n\n \nint tegra_pmc_cpu_power_on(unsigned int cpuid)\n{\n\tint id;\n\n\tid = tegra_get_cpu_powergate_id(pmc, cpuid);\n\tif (id < 0)\n\t\treturn id;\n\n\treturn tegra_powergate_set(pmc, id, true);\n}\n\n \nint tegra_pmc_cpu_remove_clamping(unsigned int cpuid)\n{\n\tint id;\n\n\tid = tegra_get_cpu_powergate_id(pmc, cpuid);\n\tif (id < 0)\n\t\treturn id;\n\n\treturn tegra_powergate_remove_clamping(id);\n}\n\nstatic void tegra_pmc_program_reboot_reason(const char *cmd)\n{\n\tu32 value;\n\n\tvalue = tegra_pmc_scratch_readl(pmc, pmc->soc->regs->scratch0);\n\tvalue &= ~PMC_SCRATCH0_MODE_MASK;\n\n\tif (cmd) {\n\t\tif (strcmp(cmd, \"recovery\") == 0)\n\t\t\tvalue |= PMC_SCRATCH0_MODE_RECOVERY;\n\n\t\tif (strcmp(cmd, \"bootloader\") == 0)\n\t\t\tvalue |= PMC_SCRATCH0_MODE_BOOTLOADER;\n\n\t\tif (strcmp(cmd, \"forced-recovery\") == 0)\n\t\t\tvalue |= PMC_SCRATCH0_MODE_RCM;\n\t}\n\n\ttegra_pmc_scratch_writel(pmc, value, pmc->soc->regs->scratch0);\n}\n\nstatic int tegra_pmc_reboot_notify(struct notifier_block *this,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tif (action == SYS_RESTART)\n\t\ttegra_pmc_program_reboot_reason(data);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block tegra_pmc_reboot_notifier = {\n\t.notifier_call = tegra_pmc_reboot_notify,\n};\n\nstatic void tegra_pmc_restart(void)\n{\n\tu32 value;\n\n\t \n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\tvalue |= PMC_CNTRL_MAIN_RST;\n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n}\n\nstatic int tegra_pmc_restart_handler(struct sys_off_data *data)\n{\n\ttegra_pmc_restart();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int tegra_pmc_power_off_handler(struct sys_off_data *data)\n{\n\t \n\tif (of_machine_is_compatible(\"asus,grouper\") &&\n\t    power_supply_is_system_supplied()) {\n\t\tconst u32 go_to_charger_mode = 0xa5a55a5a;\n\n\t\ttegra_pmc_writel(pmc, go_to_charger_mode, PMC_SCRATCH37);\n\t\ttegra_pmc_restart();\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int powergate_show(struct seq_file *s, void *data)\n{\n\tunsigned int i;\n\tint status;\n\n\tseq_printf(s, \" powergate powered\\n\");\n\tseq_printf(s, \"------------------\\n\");\n\n\tfor (i = 0; i < pmc->soc->num_powergates; i++) {\n\t\tstatus = tegra_powergate_is_powered(pmc, i);\n\t\tif (status < 0)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \" %9s %7s\\n\", pmc->soc->powergates[i],\n\t\t\t   status ? \"yes\" : \"no\");\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(powergate);\n\nstatic int tegra_powergate_of_get_clks(struct tegra_powergate *pg,\n\t\t\t\t       struct device_node *np)\n{\n\tstruct clk *clk;\n\tunsigned int i, count;\n\tint err;\n\n\tcount = of_clk_get_parent_count(np);\n\tif (count == 0)\n\t\treturn -ENODEV;\n\n\tpg->clks = kcalloc(count, sizeof(clk), GFP_KERNEL);\n\tif (!pg->clks)\n\t\treturn -ENOMEM;\n\n\tpg->clk_rates = kcalloc(count, sizeof(*pg->clk_rates), GFP_KERNEL);\n\tif (!pg->clk_rates) {\n\t\tkfree(pg->clks);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tpg->clks[i] = of_clk_get(np, i);\n\t\tif (IS_ERR(pg->clks[i])) {\n\t\t\terr = PTR_ERR(pg->clks[i]);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tpg->num_clks = count;\n\n\treturn 0;\n\nerr:\n\twhile (i--)\n\t\tclk_put(pg->clks[i]);\n\n\tkfree(pg->clk_rates);\n\tkfree(pg->clks);\n\n\treturn err;\n}\n\nstatic int tegra_powergate_of_get_resets(struct tegra_powergate *pg,\n\t\t\t\t\t struct device_node *np, bool off)\n{\n\tstruct device *dev = pg->pmc->dev;\n\tint err;\n\n\tpg->reset = of_reset_control_array_get_exclusive_released(np);\n\tif (IS_ERR(pg->reset)) {\n\t\terr = PTR_ERR(pg->reset);\n\t\tdev_err(dev, \"failed to get device resets: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = reset_control_acquire(pg->reset);\n\tif (err < 0) {\n\t\tpr_err(\"failed to acquire resets: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (off) {\n\t\terr = reset_control_assert(pg->reset);\n\t} else {\n\t\terr = reset_control_deassert(pg->reset);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\treset_control_release(pg->reset);\n\t}\n\nout:\n\tif (err) {\n\t\treset_control_release(pg->reset);\n\t\treset_control_put(pg->reset);\n\t}\n\n\treturn err;\n}\n\nstatic int tegra_powergate_add(struct tegra_pmc *pmc, struct device_node *np)\n{\n\tstruct device *dev = pmc->dev;\n\tstruct tegra_powergate *pg;\n\tint id, err = 0;\n\tbool off;\n\n\tpg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn -ENOMEM;\n\n\tid = tegra_powergate_lookup(pmc, np->name);\n\tif (id < 0) {\n\t\tdev_err(dev, \"powergate lookup failed for %pOFn: %d\\n\", np, id);\n\t\terr = -ENODEV;\n\t\tgoto free_mem;\n\t}\n\n\t \n\tclear_bit(id, pmc->powergates_available);\n\n\tpg->id = id;\n\tpg->genpd.name = np->name;\n\tpg->genpd.power_off = tegra_genpd_power_off;\n\tpg->genpd.power_on = tegra_genpd_power_on;\n\tpg->pmc = pmc;\n\n\toff = !tegra_powergate_is_powered(pmc, pg->id);\n\n\terr = tegra_powergate_of_get_clks(pg, np);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get clocks for %pOFn: %d\\n\", np, err);\n\t\tgoto set_available;\n\t}\n\n\terr = tegra_powergate_of_get_resets(pg, np, off);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to get resets for %pOFn: %d\\n\", np, err);\n\t\tgoto remove_clks;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\n\t\tif (off)\n\t\t\tWARN_ON(tegra_powergate_power_up(pg, true));\n\n\t\tgoto remove_resets;\n\t}\n\n\terr = pm_genpd_init(&pg->genpd, NULL, off);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to initialise PM domain %pOFn: %d\\n\", np,\n\t\t       err);\n\t\tgoto remove_resets;\n\t}\n\n\terr = of_genpd_add_provider_simple(np, &pg->genpd);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to add PM domain provider for %pOFn: %d\\n\",\n\t\t\tnp, err);\n\t\tgoto remove_genpd;\n\t}\n\n\tdev_dbg(dev, \"added PM domain %s\\n\", pg->genpd.name);\n\n\treturn 0;\n\nremove_genpd:\n\tpm_genpd_remove(&pg->genpd);\n\nremove_resets:\n\treset_control_put(pg->reset);\n\nremove_clks:\n\twhile (pg->num_clks--)\n\t\tclk_put(pg->clks[pg->num_clks]);\n\n\tkfree(pg->clks);\n\nset_available:\n\tset_bit(id, pmc->powergates_available);\n\nfree_mem:\n\tkfree(pg);\n\n\treturn err;\n}\n\nbool tegra_pmc_core_domain_state_synced(void)\n{\n\treturn pmc->core_domain_state_synced;\n}\n\nstatic int\ntegra_pmc_core_pd_set_performance_state(struct generic_pm_domain *genpd,\n\t\t\t\t\tunsigned int level)\n{\n\tstruct dev_pm_opp *opp;\n\tint err;\n\n\topp = dev_pm_opp_find_level_ceil(&genpd->dev, &level);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(&genpd->dev, \"failed to find OPP for level %u: %pe\\n\",\n\t\t\tlevel, opp);\n\t\treturn PTR_ERR(opp);\n\t}\n\n\tmutex_lock(&pmc->powergates_lock);\n\terr = dev_pm_opp_set_opp(pmc->dev, opp);\n\tmutex_unlock(&pmc->powergates_lock);\n\n\tdev_pm_opp_put(opp);\n\n\tif (err) {\n\t\tdev_err(&genpd->dev, \"failed to set voltage to %duV: %d\\n\",\n\t\t\tlevel, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int\ntegra_pmc_core_pd_opp_to_performance_state(struct generic_pm_domain *genpd,\n\t\t\t\t\t   struct dev_pm_opp *opp)\n{\n\treturn dev_pm_opp_get_level(opp);\n}\n\nstatic int tegra_pmc_core_pd_add(struct tegra_pmc *pmc, struct device_node *np)\n{\n\tstruct generic_pm_domain *genpd;\n\tconst char *rname[] = { \"core\", NULL};\n\tint err;\n\n\tgenpd = devm_kzalloc(pmc->dev, sizeof(*genpd), GFP_KERNEL);\n\tif (!genpd)\n\t\treturn -ENOMEM;\n\n\tgenpd->name = \"core\";\n\tgenpd->set_performance_state = tegra_pmc_core_pd_set_performance_state;\n\tgenpd->opp_to_performance_state = tegra_pmc_core_pd_opp_to_performance_state;\n\n\terr = devm_pm_opp_set_regulators(pmc->dev, rname);\n\tif (err)\n\t\treturn dev_err_probe(pmc->dev, err,\n\t\t\t\t     \"failed to set core OPP regulator\\n\");\n\n\terr = pm_genpd_init(genpd, NULL, false);\n\tif (err) {\n\t\tdev_err(pmc->dev, \"failed to init core genpd: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = of_genpd_add_provider_simple(np, genpd);\n\tif (err) {\n\t\tdev_err(pmc->dev, \"failed to add core genpd: %d\\n\", err);\n\t\tgoto remove_genpd;\n\t}\n\n\tpmc->core_domain_registered = true;\n\n\treturn 0;\n\nremove_genpd:\n\tpm_genpd_remove(genpd);\n\n\treturn err;\n}\n\nstatic int tegra_powergate_init(struct tegra_pmc *pmc,\n\t\t\t\tstruct device_node *parent)\n{\n\tstruct of_phandle_args child_args, parent_args;\n\tstruct device_node *np, *child;\n\tint err = 0;\n\n\t \n\tnp = of_get_child_by_name(parent, \"core-domain\");\n\tif (np) {\n\t\terr = tegra_pmc_core_pd_add(pmc, np);\n\t\tof_node_put(np);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnp = of_get_child_by_name(parent, \"powergates\");\n\tif (!np)\n\t\treturn 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\terr = tegra_powergate_add(pmc, child);\n\t\tif (err < 0) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (of_parse_phandle_with_args(child, \"power-domains\",\n\t\t\t\t\t       \"#power-domain-cells\",\n\t\t\t\t\t       0, &parent_args))\n\t\t\tcontinue;\n\n\t\tchild_args.np = child;\n\t\tchild_args.args_count = 0;\n\n\t\terr = of_genpd_add_subdomain(&parent_args, &child_args);\n\t\tof_node_put(parent_args.np);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\treturn err;\n}\n\nstatic void tegra_powergate_remove(struct generic_pm_domain *genpd)\n{\n\tstruct tegra_powergate *pg = to_powergate(genpd);\n\n\treset_control_put(pg->reset);\n\n\twhile (pg->num_clks--)\n\t\tclk_put(pg->clks[pg->num_clks]);\n\n\tkfree(pg->clks);\n\n\tset_bit(pg->id, pmc->powergates_available);\n\n\tkfree(pg);\n}\n\nstatic void tegra_powergate_remove_all(struct device_node *parent)\n{\n\tstruct generic_pm_domain *genpd;\n\tstruct device_node *np, *child;\n\n\tnp = of_get_child_by_name(parent, \"powergates\");\n\tif (!np)\n\t\treturn;\n\n\tfor_each_child_of_node(np, child) {\n\t\tof_genpd_del_provider(child);\n\n\t\tgenpd = of_genpd_remove_last(child);\n\t\tif (IS_ERR(genpd))\n\t\t\tcontinue;\n\n\t\ttegra_powergate_remove(genpd);\n\t}\n\n\tof_node_put(np);\n\n\tnp = of_get_child_by_name(parent, \"core-domain\");\n\tif (np) {\n\t\tof_genpd_del_provider(np);\n\t\tof_genpd_remove_last(np);\n\t}\n}\n\nstatic const struct tegra_io_pad_soc *\ntegra_io_pad_find(struct tegra_pmc *pmc, enum tegra_io_pad id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pmc->soc->num_io_pads; i++)\n\t\tif (pmc->soc->io_pads[i].id == id)\n\t\t\treturn &pmc->soc->io_pads[i];\n\n\treturn NULL;\n}\n\nstatic int tegra_io_pad_prepare(struct tegra_pmc *pmc,\n\t\t\t\tconst struct tegra_io_pad_soc *pad,\n\t\t\t\tunsigned long *request,\n\t\t\t\tunsigned long *status,\n\t\t\t\tu32 *mask)\n{\n\tunsigned long rate, value;\n\n\tif (pad->dpd == UINT_MAX)\n\t\treturn -EINVAL;\n\n\t*request = pad->request;\n\t*status = pad->status;\n\t*mask = BIT(pad->dpd);\n\n\tif (pmc->clk) {\n\t\trate = pmc->rate;\n\t\tif (!rate) {\n\t\t\tdev_err(pmc->dev, \"failed to get clock rate\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\ttegra_pmc_writel(pmc, DPD_SAMPLE_ENABLE, DPD_SAMPLE);\n\n\t\t \n\t\tvalue = DIV_ROUND_UP(1000000000, rate);\n\t\tvalue = DIV_ROUND_UP(200, value);\n\t\ttegra_pmc_writel(pmc, value, SEL_DPD_TIM);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_io_pad_poll(struct tegra_pmc *pmc, unsigned long offset,\n\t\t\t     u32 mask, u32 val, unsigned long timeout)\n{\n\tu32 value;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (time_after(timeout, jiffies)) {\n\t\tvalue = tegra_pmc_readl(pmc, offset);\n\t\tif ((value & mask) == val)\n\t\t\treturn 0;\n\n\t\tusleep_range(250, 1000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void tegra_io_pad_unprepare(struct tegra_pmc *pmc)\n{\n\tif (pmc->clk)\n\t\ttegra_pmc_writel(pmc, DPD_SAMPLE_DISABLE, DPD_SAMPLE);\n}\n\n \nint tegra_io_pad_power_enable(enum tegra_io_pad id)\n{\n\tconst struct tegra_io_pad_soc *pad;\n\tunsigned long request, status;\n\tu32 mask;\n\tint err;\n\n\tpad = tegra_io_pad_find(pmc, id);\n\tif (!pad) {\n\t\tdev_err(pmc->dev, \"invalid I/O pad ID %u\\n\", id);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&pmc->powergates_lock);\n\n\terr = tegra_io_pad_prepare(pmc, pad, &request, &status, &mask);\n\tif (err < 0) {\n\t\tdev_err(pmc->dev, \"failed to prepare I/O pad: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\ttegra_pmc_writel(pmc, IO_DPD_REQ_CODE_OFF | mask, request);\n\n\terr = tegra_io_pad_poll(pmc, status, mask, 0, 250);\n\tif (err < 0) {\n\t\tdev_err(pmc->dev, \"failed to enable I/O pad: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\ttegra_io_pad_unprepare(pmc);\n\nunlock:\n\tmutex_unlock(&pmc->powergates_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(tegra_io_pad_power_enable);\n\n \nint tegra_io_pad_power_disable(enum tegra_io_pad id)\n{\n\tconst struct tegra_io_pad_soc *pad;\n\tunsigned long request, status;\n\tu32 mask;\n\tint err;\n\n\tpad = tegra_io_pad_find(pmc, id);\n\tif (!pad) {\n\t\tdev_err(pmc->dev, \"invalid I/O pad ID %u\\n\", id);\n\t\treturn -ENOENT;\n\t}\n\n\tmutex_lock(&pmc->powergates_lock);\n\n\terr = tegra_io_pad_prepare(pmc, pad, &request, &status, &mask);\n\tif (err < 0) {\n\t\tdev_err(pmc->dev, \"failed to prepare I/O pad: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\ttegra_pmc_writel(pmc, IO_DPD_REQ_CODE_ON | mask, request);\n\n\terr = tegra_io_pad_poll(pmc, status, mask, mask, 250);\n\tif (err < 0) {\n\t\tdev_err(pmc->dev, \"failed to disable I/O pad: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\ttegra_io_pad_unprepare(pmc);\n\nunlock:\n\tmutex_unlock(&pmc->powergates_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(tegra_io_pad_power_disable);\n\nstatic int tegra_io_pad_is_powered(struct tegra_pmc *pmc, enum tegra_io_pad id)\n{\n\tconst struct tegra_io_pad_soc *pad;\n\tunsigned long status;\n\tu32 mask, value;\n\n\tpad = tegra_io_pad_find(pmc, id);\n\tif (!pad) {\n\t\tdev_err(pmc->dev, \"invalid I/O pad ID %u\\n\", id);\n\t\treturn -ENOENT;\n\t}\n\n\tif (pad->dpd == UINT_MAX)\n\t\treturn -EINVAL;\n\n\tstatus = pad->status;\n\tmask = BIT(pad->dpd);\n\n\tvalue = tegra_pmc_readl(pmc, status);\n\n\treturn !(value & mask);\n}\n\nstatic int tegra_io_pad_set_voltage(struct tegra_pmc *pmc, enum tegra_io_pad id,\n\t\t\t\t    int voltage)\n{\n\tconst struct tegra_io_pad_soc *pad;\n\tu32 value;\n\n\tpad = tegra_io_pad_find(pmc, id);\n\tif (!pad)\n\t\treturn -ENOENT;\n\n\tif (pad->voltage == UINT_MAX)\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&pmc->powergates_lock);\n\n\tif (pmc->soc->has_impl_33v_pwr) {\n\t\tvalue = tegra_pmc_readl(pmc, PMC_IMPL_E_33V_PWR);\n\n\t\tif (voltage == TEGRA_IO_PAD_VOLTAGE_1V8)\n\t\t\tvalue &= ~BIT(pad->voltage);\n\t\telse\n\t\t\tvalue |= BIT(pad->voltage);\n\n\t\ttegra_pmc_writel(pmc, value, PMC_IMPL_E_33V_PWR);\n\t} else {\n\t\t \n\t\tvalue = tegra_pmc_readl(pmc, PMC_PWR_DET);\n\t\tvalue |= BIT(pad->voltage);\n\t\ttegra_pmc_writel(pmc, value, PMC_PWR_DET);\n\n\t\t \n\t\tvalue = tegra_pmc_readl(pmc, PMC_PWR_DET_VALUE);\n\n\t\tif (voltage == TEGRA_IO_PAD_VOLTAGE_1V8)\n\t\t\tvalue &= ~BIT(pad->voltage);\n\t\telse\n\t\t\tvalue |= BIT(pad->voltage);\n\n\t\ttegra_pmc_writel(pmc, value, PMC_PWR_DET_VALUE);\n\t}\n\n\tmutex_unlock(&pmc->powergates_lock);\n\n\tusleep_range(100, 250);\n\n\treturn 0;\n}\n\nstatic int tegra_io_pad_get_voltage(struct tegra_pmc *pmc, enum tegra_io_pad id)\n{\n\tconst struct tegra_io_pad_soc *pad;\n\tu32 value;\n\n\tpad = tegra_io_pad_find(pmc, id);\n\tif (!pad)\n\t\treturn -ENOENT;\n\n\tif (pad->voltage == UINT_MAX)\n\t\treturn -ENOTSUPP;\n\n\tif (pmc->soc->has_impl_33v_pwr)\n\t\tvalue = tegra_pmc_readl(pmc, PMC_IMPL_E_33V_PWR);\n\telse\n\t\tvalue = tegra_pmc_readl(pmc, PMC_PWR_DET_VALUE);\n\n\tif ((value & BIT(pad->voltage)) == 0)\n\t\treturn TEGRA_IO_PAD_VOLTAGE_1V8;\n\n\treturn TEGRA_IO_PAD_VOLTAGE_3V3;\n}\n\n \nint tegra_io_rail_power_on(unsigned int id)\n{\n\treturn tegra_io_pad_power_enable(id);\n}\nEXPORT_SYMBOL(tegra_io_rail_power_on);\n\n \nint tegra_io_rail_power_off(unsigned int id)\n{\n\treturn tegra_io_pad_power_disable(id);\n}\nEXPORT_SYMBOL(tegra_io_rail_power_off);\n\n#ifdef CONFIG_PM_SLEEP\nenum tegra_suspend_mode tegra_pmc_get_suspend_mode(void)\n{\n\treturn pmc->suspend_mode;\n}\n\nvoid tegra_pmc_set_suspend_mode(enum tegra_suspend_mode mode)\n{\n\tif (mode < TEGRA_SUSPEND_NONE || mode >= TEGRA_MAX_SUSPEND_MODE)\n\t\treturn;\n\n\tpmc->suspend_mode = mode;\n}\n\nvoid tegra_pmc_enter_suspend_mode(enum tegra_suspend_mode mode)\n{\n\tunsigned long long rate = 0;\n\tu64 ticks;\n\tu32 value;\n\n\tswitch (mode) {\n\tcase TEGRA_SUSPEND_LP1:\n\t\trate = 32768;\n\t\tbreak;\n\n\tcase TEGRA_SUSPEND_LP2:\n\t\trate = pmc->rate;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (WARN_ON_ONCE(rate == 0))\n\t\trate = 100000000;\n\n\tticks = pmc->cpu_good_time * rate + USEC_PER_SEC - 1;\n\tdo_div(ticks, USEC_PER_SEC);\n\ttegra_pmc_writel(pmc, ticks, PMC_CPUPWRGOOD_TIMER);\n\n\tticks = pmc->cpu_off_time * rate + USEC_PER_SEC - 1;\n\tdo_div(ticks, USEC_PER_SEC);\n\ttegra_pmc_writel(pmc, ticks, PMC_CPUPWROFF_TIMER);\n\n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\tvalue &= ~PMC_CNTRL_SIDE_EFFECT_LP0;\n\tvalue |= PMC_CNTRL_CPU_PWRREQ_OE;\n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n}\n#endif\n\nstatic int tegra_pmc_parse_dt(struct tegra_pmc *pmc, struct device_node *np)\n{\n\tu32 value, values[2];\n\n\tif (of_property_read_u32(np, \"nvidia,suspend-mode\", &value)) {\n\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\t} else {\n\t\tswitch (value) {\n\t\tcase 0:\n\t\t\tpmc->suspend_mode = TEGRA_SUSPEND_LP0;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tpmc->suspend_mode = TEGRA_SUSPEND_LP1;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tpmc->suspend_mode = TEGRA_SUSPEND_LP2;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpmc->suspend_mode = tegra_pm_validate_suspend_mode(pmc->suspend_mode);\n\n\tif (of_property_read_u32(np, \"nvidia,cpu-pwr-good-time\", &value))\n\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\n\tpmc->cpu_good_time = value;\n\n\tif (of_property_read_u32(np, \"nvidia,cpu-pwr-off-time\", &value))\n\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\n\tpmc->cpu_off_time = value;\n\n\tif (of_property_read_u32_array(np, \"nvidia,core-pwr-good-time\",\n\t\t\t\t       values, ARRAY_SIZE(values)))\n\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\n\tpmc->core_osc_time = values[0];\n\tpmc->core_pmu_time = values[1];\n\n\tif (of_property_read_u32(np, \"nvidia,core-pwr-off-time\", &value))\n\t\tpmc->suspend_mode = TEGRA_SUSPEND_NONE;\n\n\tpmc->core_off_time = value;\n\n\tpmc->corereq_high = of_property_read_bool(np,\n\t\t\t\t\"nvidia,core-power-req-active-high\");\n\n\tpmc->sysclkreq_high = of_property_read_bool(np,\n\t\t\t\t\"nvidia,sys-clock-req-active-high\");\n\n\tpmc->combined_req = of_property_read_bool(np,\n\t\t\t\t\"nvidia,combined-power-req\");\n\n\tpmc->cpu_pwr_good_en = of_property_read_bool(np,\n\t\t\t\t\"nvidia,cpu-pwr-good-en\");\n\n\tif (of_property_read_u32_array(np, \"nvidia,lp0-vec\", values,\n\t\t\t\t       ARRAY_SIZE(values)))\n\t\tif (pmc->suspend_mode == TEGRA_SUSPEND_LP0)\n\t\t\tpmc->suspend_mode = TEGRA_SUSPEND_LP1;\n\n\tpmc->lp0_vec_phys = values[0];\n\tpmc->lp0_vec_size = values[1];\n\n\treturn 0;\n}\n\nstatic int tegra_pmc_init(struct tegra_pmc *pmc)\n{\n\tif (pmc->soc->max_wake_events > 0) {\n\t\tpmc->wake_type_level_map = bitmap_zalloc(pmc->soc->max_wake_events, GFP_KERNEL);\n\t\tif (!pmc->wake_type_level_map)\n\t\t\treturn -ENOMEM;\n\n\t\tpmc->wake_type_dual_edge_map = bitmap_zalloc(pmc->soc->max_wake_events, GFP_KERNEL);\n\t\tif (!pmc->wake_type_dual_edge_map)\n\t\t\treturn -ENOMEM;\n\n\t\tpmc->wake_sw_status_map = bitmap_zalloc(pmc->soc->max_wake_events, GFP_KERNEL);\n\t\tif (!pmc->wake_sw_status_map)\n\t\t\treturn -ENOMEM;\n\n\t\tpmc->wake_cntrl_level_map = bitmap_zalloc(pmc->soc->max_wake_events, GFP_KERNEL);\n\t\tif (!pmc->wake_cntrl_level_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (pmc->soc->init)\n\t\tpmc->soc->init(pmc);\n\n\treturn 0;\n}\n\nstatic void tegra_pmc_init_tsense_reset(struct tegra_pmc *pmc)\n{\n\tstatic const char disabled[] = \"emergency thermal reset disabled\";\n\tu32 pmu_addr, ctrl_id, reg_addr, reg_data, pinmux;\n\tstruct device *dev = pmc->dev;\n\tstruct device_node *np;\n\tu32 value, checksum;\n\n\tif (!pmc->soc->has_tsense_reset)\n\t\treturn;\n\n\tnp = of_get_child_by_name(pmc->dev->of_node, \"i2c-thermtrip\");\n\tif (!np) {\n\t\tdev_warn(dev, \"i2c-thermtrip node not found, %s.\\n\", disabled);\n\t\treturn;\n\t}\n\n\tif (of_property_read_u32(np, \"nvidia,i2c-controller-id\", &ctrl_id)) {\n\t\tdev_err(dev, \"I2C controller ID missing, %s.\\n\", disabled);\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"nvidia,bus-addr\", &pmu_addr)) {\n\t\tdev_err(dev, \"nvidia,bus-addr missing, %s.\\n\", disabled);\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"nvidia,reg-addr\", &reg_addr)) {\n\t\tdev_err(dev, \"nvidia,reg-addr missing, %s.\\n\", disabled);\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"nvidia,reg-data\", &reg_data)) {\n\t\tdev_err(dev, \"nvidia,reg-data missing, %s.\\n\", disabled);\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"nvidia,pinmux-id\", &pinmux))\n\t\tpinmux = 0;\n\n\tvalue = tegra_pmc_readl(pmc, PMC_SENSOR_CTRL);\n\tvalue |= PMC_SENSOR_CTRL_SCRATCH_WRITE;\n\ttegra_pmc_writel(pmc, value, PMC_SENSOR_CTRL);\n\n\tvalue = (reg_data << PMC_SCRATCH54_DATA_SHIFT) |\n\t\t(reg_addr << PMC_SCRATCH54_ADDR_SHIFT);\n\ttegra_pmc_writel(pmc, value, PMC_SCRATCH54);\n\n\tvalue = PMC_SCRATCH55_RESET_TEGRA;\n\tvalue |= ctrl_id << PMC_SCRATCH55_CNTRL_ID_SHIFT;\n\tvalue |= pinmux << PMC_SCRATCH55_PINMUX_SHIFT;\n\tvalue |= pmu_addr << PMC_SCRATCH55_I2CSLV1_SHIFT;\n\n\t \n\tchecksum = reg_addr + reg_data + (value & 0xff) + ((value >> 8) & 0xff)\n\t\t+ ((value >> 24) & 0xff);\n\tchecksum &= 0xff;\n\tchecksum = 0x100 - checksum;\n\n\tvalue |= checksum << PMC_SCRATCH55_CHECKSUM_SHIFT;\n\n\ttegra_pmc_writel(pmc, value, PMC_SCRATCH55);\n\n\tvalue = tegra_pmc_readl(pmc, PMC_SENSOR_CTRL);\n\tvalue |= PMC_SENSOR_CTRL_ENABLE_RST;\n\ttegra_pmc_writel(pmc, value, PMC_SENSOR_CTRL);\n\n\tdev_info(pmc->dev, \"emergency thermal reset enabled\\n\");\n\nout:\n\tof_node_put(np);\n}\n\nstatic int tegra_io_pad_pinctrl_get_groups_count(struct pinctrl_dev *pctl_dev)\n{\n\tstruct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);\n\n\treturn pmc->soc->num_io_pads;\n}\n\nstatic const char *tegra_io_pad_pinctrl_get_group_name(struct pinctrl_dev *pctl,\n\t\t\t\t\t\t       unsigned int group)\n{\n\tstruct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl);\n\n\treturn pmc->soc->io_pads[group].name;\n}\n\nstatic int tegra_io_pad_pinctrl_get_group_pins(struct pinctrl_dev *pctl_dev,\n\t\t\t\t\t       unsigned int group,\n\t\t\t\t\t       const unsigned int **pins,\n\t\t\t\t\t       unsigned int *num_pins)\n{\n\tstruct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);\n\n\t*pins = &pmc->soc->io_pads[group].id;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops tegra_io_pad_pinctrl_ops = {\n\t.get_groups_count = tegra_io_pad_pinctrl_get_groups_count,\n\t.get_group_name = tegra_io_pad_pinctrl_get_group_name,\n\t.get_group_pins = tegra_io_pad_pinctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\nstatic int tegra_io_pad_pinconf_get(struct pinctrl_dev *pctl_dev,\n\t\t\t\t    unsigned int pin, unsigned long *config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tstruct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);\n\tconst struct tegra_io_pad_soc *pad;\n\tint ret;\n\tu32 arg;\n\n\tpad = tegra_io_pad_find(pmc, pin);\n\tif (!pad)\n\t\treturn -EINVAL;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\tret = tegra_io_pad_get_voltage(pmc, pad->id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = ret;\n\t\tbreak;\n\n\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\tret = tegra_io_pad_is_powered(pmc, pad->id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = !ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int tegra_io_pad_pinconf_set(struct pinctrl_dev *pctl_dev,\n\t\t\t\t    unsigned int pin, unsigned long *configs,\n\t\t\t\t    unsigned int num_configs)\n{\n\tstruct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);\n\tconst struct tegra_io_pad_soc *pad;\n\tenum pin_config_param param;\n\tunsigned int i;\n\tint err;\n\tu32 arg;\n\n\tpad = tegra_io_pad_find(pmc, pin);\n\tif (!pad)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_configs; ++i) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\t\tif (arg)\n\t\t\t\terr = tegra_io_pad_power_disable(pad->id);\n\t\t\telse\n\t\t\t\terr = tegra_io_pad_power_enable(pad->id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tif (arg != TEGRA_IO_PAD_VOLTAGE_1V8 &&\n\t\t\t    arg != TEGRA_IO_PAD_VOLTAGE_3V3)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = tegra_io_pad_set_voltage(pmc, pad->id, arg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops tegra_io_pad_pinconf_ops = {\n\t.pin_config_get = tegra_io_pad_pinconf_get,\n\t.pin_config_set = tegra_io_pad_pinconf_set,\n\t.is_generic = true,\n};\n\nstatic struct pinctrl_desc tegra_pmc_pctl_desc = {\n\t.pctlops = &tegra_io_pad_pinctrl_ops,\n\t.confops = &tegra_io_pad_pinconf_ops,\n};\n\nstatic int tegra_pmc_pinctrl_init(struct tegra_pmc *pmc)\n{\n\tint err;\n\n\tif (!pmc->soc->num_pin_descs)\n\t\treturn 0;\n\n\ttegra_pmc_pctl_desc.name = dev_name(pmc->dev);\n\ttegra_pmc_pctl_desc.pins = pmc->soc->pin_descs;\n\ttegra_pmc_pctl_desc.npins = pmc->soc->num_pin_descs;\n\n\tpmc->pctl_dev = devm_pinctrl_register(pmc->dev, &tegra_pmc_pctl_desc,\n\t\t\t\t\t      pmc);\n\tif (IS_ERR(pmc->pctl_dev)) {\n\t\terr = PTR_ERR(pmc->pctl_dev);\n\t\tdev_err(pmc->dev, \"failed to register pin controller: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t reset_reason_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 value;\n\n\tvalue = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);\n\tvalue &= pmc->soc->regs->rst_source_mask;\n\tvalue >>= pmc->soc->regs->rst_source_shift;\n\n\tif (WARN_ON(value >= pmc->soc->num_reset_sources))\n\t\treturn sprintf(buf, \"%s\\n\", \"UNKNOWN\");\n\n\treturn sprintf(buf, \"%s\\n\", pmc->soc->reset_sources[value]);\n}\n\nstatic DEVICE_ATTR_RO(reset_reason);\n\nstatic ssize_t reset_level_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu32 value;\n\n\tvalue = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);\n\tvalue &= pmc->soc->regs->rst_level_mask;\n\tvalue >>= pmc->soc->regs->rst_level_shift;\n\n\tif (WARN_ON(value >= pmc->soc->num_reset_levels))\n\t\treturn sprintf(buf, \"%s\\n\", \"UNKNOWN\");\n\n\treturn sprintf(buf, \"%s\\n\", pmc->soc->reset_levels[value]);\n}\n\nstatic DEVICE_ATTR_RO(reset_level);\n\nstatic void tegra_pmc_reset_sysfs_init(struct tegra_pmc *pmc)\n{\n\tstruct device *dev = pmc->dev;\n\tint err = 0;\n\n\tif (pmc->soc->reset_sources) {\n\t\terr = device_create_file(dev, &dev_attr_reset_reason);\n\t\tif (err < 0)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to create attr \\\"reset_reason\\\": %d\\n\",\n\t\t\t\t err);\n\t}\n\n\tif (pmc->soc->reset_levels) {\n\t\terr = device_create_file(dev, &dev_attr_reset_level);\n\t\tif (err < 0)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to create attr \\\"reset_level\\\": %d\\n\",\n\t\t\t\t err);\n\t}\n}\n\nstatic int tegra_pmc_irq_translate(struct irq_domain *domain,\n\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t   unsigned long *hwirq,\n\t\t\t\t   unsigned int *type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic int tegra_pmc_irq_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t       unsigned int num_irqs, void *data)\n{\n\tstruct tegra_pmc *pmc = domain->host_data;\n\tconst struct tegra_pmc_soc *soc = pmc->soc;\n\tstruct irq_fwspec *fwspec = data;\n\tunsigned int i;\n\tint err = 0;\n\n\tif (WARN_ON(num_irqs > 1))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < soc->num_wake_events; i++) {\n\t\tconst struct tegra_wake_event *event = &soc->wake_events[i];\n\n\t\t \n\t\tif (fwspec->param_count == 2) {\n\t\t\tstruct irq_fwspec spec;\n\n\t\t\tif (event->id != fwspec->param[0])\n\t\t\t\tcontinue;\n\n\t\t\terr = irq_domain_set_hwirq_and_chip(domain, virq,\n\t\t\t\t\t\t\t    event->id,\n\t\t\t\t\t\t\t    &pmc->irq, pmc);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (event->irq == 0) {\n\t\t\t\terr = irq_domain_disconnect_hierarchy(domain->parent, virq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspec.fwnode = &pmc->dev->of_node->fwnode;\n\t\t\tspec.param_count = 3;\n\t\t\tspec.param[0] = GIC_SPI;\n\t\t\tspec.param[1] = event->irq;\n\t\t\tspec.param[2] = fwspec->param[1];\n\n\t\t\terr = irq_domain_alloc_irqs_parent(domain, virq,\n\t\t\t\t\t\t\t   num_irqs, &spec);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (fwspec->param_count == 3) {\n\t\t\tif (event->gpio.instance != fwspec->param[0] ||\n\t\t\t    event->gpio.pin != fwspec->param[1])\n\t\t\t\tcontinue;\n\n\t\t\terr = irq_domain_set_hwirq_and_chip(domain, virq,\n\t\t\t\t\t\t\t    event->id,\n\t\t\t\t\t\t\t    &pmc->irq, pmc);\n\n\t\t\t \n\t\t\tif (!err && domain->parent)\n\t\t\t\terr = irq_domain_disconnect_hierarchy(domain->parent,\n\t\t\t\t\t\t\t\t      virq);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == soc->num_wake_events)\n\t\terr = irq_domain_disconnect_hierarchy(domain, virq);\n\n\treturn err;\n}\n\nstatic const struct irq_domain_ops tegra_pmc_irq_domain_ops = {\n\t.translate = tegra_pmc_irq_translate,\n\t.alloc = tegra_pmc_irq_alloc,\n};\n\nstatic int tegra210_pmc_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);\n\tunsigned int offset, bit;\n\tu32 value;\n\n\toffset = data->hwirq / 32;\n\tbit = data->hwirq % 32;\n\n\t \n\ttegra_pmc_writel(pmc, 0, PMC_SW_WAKE_STATUS);\n\ttegra_pmc_writel(pmc, 0, PMC_SW_WAKE2_STATUS);\n\n\ttegra_pmc_writel(pmc, 0, PMC_WAKE_STATUS);\n\ttegra_pmc_writel(pmc, 0, PMC_WAKE2_STATUS);\n\n\t \n\tif (data->hwirq >= 32)\n\t\toffset = PMC_WAKE2_MASK;\n\telse\n\t\toffset = PMC_WAKE_MASK;\n\n\tvalue = tegra_pmc_readl(pmc, offset);\n\n\tif (on)\n\t\tvalue |= BIT(bit);\n\telse\n\t\tvalue &= ~BIT(bit);\n\n\ttegra_pmc_writel(pmc, value, offset);\n\n\treturn 0;\n}\n\nstatic int tegra210_pmc_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);\n\tunsigned int offset, bit;\n\tu32 value;\n\n\toffset = data->hwirq / 32;\n\tbit = data->hwirq % 32;\n\n\tif (data->hwirq >= 32)\n\t\toffset = PMC_WAKE2_LEVEL;\n\telse\n\t\toffset = PMC_WAKE_LEVEL;\n\n\tvalue = tegra_pmc_readl(pmc, offset);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tvalue |= BIT(bit);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tvalue &= ~BIT(bit);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:\n\t\tvalue ^= BIT(bit);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttegra_pmc_writel(pmc, value, offset);\n\n\treturn 0;\n}\n\nstatic void tegra186_pmc_set_wake_filters(struct tegra_pmc *pmc)\n{\n\tu32 value;\n\n\t \n\tvalue = readl(pmc->wake + WAKE_AOWAKE_CNTRL(SW_WAKE_ID));\n\tvalue |= WAKE_AOWAKE_CNTRL_SR_CAPTURE_EN;\n\twritel(value, pmc->wake + WAKE_AOWAKE_CNTRL(SW_WAKE_ID));\n\tdev_dbg(pmc->dev, \"WAKE_AOWAKE_CNTRL_83 = 0x%x\\n\", value);\n}\n\nstatic int tegra186_pmc_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);\n\tunsigned int offset, bit;\n\tu32 value;\n\n\toffset = data->hwirq / 32;\n\tbit = data->hwirq % 32;\n\n\t \n\twritel(0x1, pmc->wake + WAKE_AOWAKE_STATUS_W(data->hwirq));\n\n\t \n\tvalue = readl(pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));\n\n\tif (!on)\n\t\tvalue &= ~(1 << bit);\n\telse\n\t\tvalue |= 1 << bit;\n\n\twritel(value, pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));\n\n\t \n\twritel(!!on, pmc->wake + WAKE_AOWAKE_MASK_W(data->hwirq));\n\n\treturn 0;\n}\n\nstatic int tegra186_pmc_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);\n\tu32 value;\n\n\tvalue = readl(pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tvalue |= WAKE_AOWAKE_CNTRL_LEVEL;\n\t\tset_bit(data->hwirq, pmc->wake_type_level_map);\n\t\tclear_bit(data->hwirq, pmc->wake_type_dual_edge_map);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tvalue &= ~WAKE_AOWAKE_CNTRL_LEVEL;\n\t\tclear_bit(data->hwirq, pmc->wake_type_level_map);\n\t\tclear_bit(data->hwirq, pmc->wake_type_dual_edge_map);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:\n\t\tvalue ^= WAKE_AOWAKE_CNTRL_LEVEL;\n\t\tclear_bit(data->hwirq, pmc->wake_type_level_map);\n\t\tset_bit(data->hwirq, pmc->wake_type_dual_edge_map);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twritel(value, pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));\n\n\treturn 0;\n}\n\nstatic void tegra_irq_mask_parent(struct irq_data *data)\n{\n\tif (data->parent_data)\n\t\tirq_chip_mask_parent(data);\n}\n\nstatic void tegra_irq_unmask_parent(struct irq_data *data)\n{\n\tif (data->parent_data)\n\t\tirq_chip_unmask_parent(data);\n}\n\nstatic void tegra_irq_eoi_parent(struct irq_data *data)\n{\n\tif (data->parent_data)\n\t\tirq_chip_eoi_parent(data);\n}\n\nstatic int tegra_irq_set_affinity_parent(struct irq_data *data,\n\t\t\t\t\t const struct cpumask *dest,\n\t\t\t\t\t bool force)\n{\n\tif (data->parent_data)\n\t\treturn irq_chip_set_affinity_parent(data, dest, force);\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_pmc_irq_init(struct tegra_pmc *pmc)\n{\n\tstruct irq_domain *parent = NULL;\n\tstruct device_node *np;\n\n\tnp = of_irq_find_parent(pmc->dev->of_node);\n\tif (np) {\n\t\tparent = irq_find_host(np);\n\t\tof_node_put(np);\n\t}\n\n\tif (!parent)\n\t\treturn 0;\n\n\tpmc->irq.name = dev_name(pmc->dev);\n\tpmc->irq.irq_mask = tegra_irq_mask_parent;\n\tpmc->irq.irq_unmask = tegra_irq_unmask_parent;\n\tpmc->irq.irq_eoi = tegra_irq_eoi_parent;\n\tpmc->irq.irq_set_affinity = tegra_irq_set_affinity_parent;\n\tpmc->irq.irq_set_type = pmc->soc->irq_set_type;\n\tpmc->irq.irq_set_wake = pmc->soc->irq_set_wake;\n\n\tpmc->domain = irq_domain_add_hierarchy(parent, 0, 96, pmc->dev->of_node,\n\t\t\t\t\t       &tegra_pmc_irq_domain_ops, pmc);\n\tif (!pmc->domain) {\n\t\tdev_err(pmc->dev, \"failed to allocate domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pmc_clk_notify_cb(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *ptr)\n{\n\tstruct tegra_pmc *pmc = container_of(nb, struct tegra_pmc, clk_nb);\n\tstruct clk_notifier_data *data = ptr;\n\n\tswitch (action) {\n\tcase PRE_RATE_CHANGE:\n\t\tmutex_lock(&pmc->powergates_lock);\n\t\tbreak;\n\n\tcase POST_RATE_CHANGE:\n\t\tpmc->rate = data->new_rate;\n\t\tfallthrough;\n\n\tcase ABORT_RATE_CHANGE:\n\t\tmutex_unlock(&pmc->powergates_lock);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn notifier_from_errno(-EINVAL);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic void pmc_clk_fence_udelay(u32 offset)\n{\n\ttegra_pmc_readl(pmc, offset);\n\t \n\tudelay(2);\n}\n\nstatic u8 pmc_clk_mux_get_parent(struct clk_hw *hw)\n{\n\tstruct pmc_clk *clk = to_pmc_clk(hw);\n\tu32 val;\n\n\tval = tegra_pmc_readl(pmc, clk->offs) >> clk->mux_shift;\n\tval &= PMC_CLK_OUT_MUX_MASK;\n\n\treturn val;\n}\n\nstatic int pmc_clk_mux_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct pmc_clk *clk = to_pmc_clk(hw);\n\tu32 val;\n\n\tval = tegra_pmc_readl(pmc, clk->offs);\n\tval &= ~(PMC_CLK_OUT_MUX_MASK << clk->mux_shift);\n\tval |= index << clk->mux_shift;\n\ttegra_pmc_writel(pmc, val, clk->offs);\n\tpmc_clk_fence_udelay(clk->offs);\n\n\treturn 0;\n}\n\nstatic int pmc_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct pmc_clk *clk = to_pmc_clk(hw);\n\tu32 val;\n\n\tval = tegra_pmc_readl(pmc, clk->offs) & BIT(clk->force_en_shift);\n\n\treturn val ? 1 : 0;\n}\n\nstatic void pmc_clk_set_state(unsigned long offs, u32 shift, int state)\n{\n\tu32 val;\n\n\tval = tegra_pmc_readl(pmc, offs);\n\tval = state ? (val | BIT(shift)) : (val & ~BIT(shift));\n\ttegra_pmc_writel(pmc, val, offs);\n\tpmc_clk_fence_udelay(offs);\n}\n\nstatic int pmc_clk_enable(struct clk_hw *hw)\n{\n\tstruct pmc_clk *clk = to_pmc_clk(hw);\n\n\tpmc_clk_set_state(clk->offs, clk->force_en_shift, 1);\n\n\treturn 0;\n}\n\nstatic void pmc_clk_disable(struct clk_hw *hw)\n{\n\tstruct pmc_clk *clk = to_pmc_clk(hw);\n\n\tpmc_clk_set_state(clk->offs, clk->force_en_shift, 0);\n}\n\nstatic const struct clk_ops pmc_clk_ops = {\n\t.get_parent = pmc_clk_mux_get_parent,\n\t.set_parent = pmc_clk_mux_set_parent,\n\t.determine_rate = __clk_mux_determine_rate,\n\t.is_enabled = pmc_clk_is_enabled,\n\t.enable = pmc_clk_enable,\n\t.disable = pmc_clk_disable,\n};\n\nstatic struct clk *\ntegra_pmc_clk_out_register(struct tegra_pmc *pmc,\n\t\t\t   const struct pmc_clk_init_data *data,\n\t\t\t   unsigned long offset)\n{\n\tstruct clk_init_data init;\n\tstruct pmc_clk *pmc_clk;\n\n\tpmc_clk = devm_kzalloc(pmc->dev, sizeof(*pmc_clk), GFP_KERNEL);\n\tif (!pmc_clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = data->name;\n\tinit.ops = &pmc_clk_ops;\n\tinit.parent_names = data->parents;\n\tinit.num_parents = data->num_parents;\n\tinit.flags = CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT |\n\t\t     CLK_SET_PARENT_GATE;\n\n\tpmc_clk->hw.init = &init;\n\tpmc_clk->offs = offset;\n\tpmc_clk->mux_shift = data->mux_shift;\n\tpmc_clk->force_en_shift = data->force_en_shift;\n\n\treturn clk_register(NULL, &pmc_clk->hw);\n}\n\nstatic int pmc_clk_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct pmc_clk_gate *gate = to_pmc_clk_gate(hw);\n\n\treturn tegra_pmc_readl(pmc, gate->offs) & BIT(gate->shift) ? 1 : 0;\n}\n\nstatic int pmc_clk_gate_enable(struct clk_hw *hw)\n{\n\tstruct pmc_clk_gate *gate = to_pmc_clk_gate(hw);\n\n\tpmc_clk_set_state(gate->offs, gate->shift, 1);\n\n\treturn 0;\n}\n\nstatic void pmc_clk_gate_disable(struct clk_hw *hw)\n{\n\tstruct pmc_clk_gate *gate = to_pmc_clk_gate(hw);\n\n\tpmc_clk_set_state(gate->offs, gate->shift, 0);\n}\n\nstatic const struct clk_ops pmc_clk_gate_ops = {\n\t.is_enabled = pmc_clk_gate_is_enabled,\n\t.enable = pmc_clk_gate_enable,\n\t.disable = pmc_clk_gate_disable,\n};\n\nstatic struct clk *\ntegra_pmc_clk_gate_register(struct tegra_pmc *pmc, const char *name,\n\t\t\t    const char *parent_name, unsigned long offset,\n\t\t\t    u32 shift)\n{\n\tstruct clk_init_data init;\n\tstruct pmc_clk_gate *gate;\n\n\tgate = devm_kzalloc(pmc->dev, sizeof(*gate), GFP_KERNEL);\n\tif (!gate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit.name = name;\n\tinit.ops = &pmc_clk_gate_ops;\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tgate->hw.init = &init;\n\tgate->offs = offset;\n\tgate->shift = shift;\n\n\treturn clk_register(NULL, &gate->hw);\n}\n\nstatic void tegra_pmc_clock_register(struct tegra_pmc *pmc,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct clk *clk;\n\tstruct clk_onecell_data *clk_data;\n\tunsigned int num_clks;\n\tint i, err;\n\n\tnum_clks = pmc->soc->num_pmc_clks;\n\tif (pmc->soc->has_blink_output)\n\t\tnum_clks += 1;\n\n\tif (!num_clks)\n\t\treturn;\n\n\tclk_data = devm_kmalloc(pmc->dev, sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn;\n\n\tclk_data->clks = devm_kcalloc(pmc->dev, TEGRA_PMC_CLK_MAX,\n\t\t\t\t      sizeof(*clk_data->clks), GFP_KERNEL);\n\tif (!clk_data->clks)\n\t\treturn;\n\n\tclk_data->clk_num = TEGRA_PMC_CLK_MAX;\n\n\tfor (i = 0; i < TEGRA_PMC_CLK_MAX; i++)\n\t\tclk_data->clks[i] = ERR_PTR(-ENOENT);\n\n\tfor (i = 0; i < pmc->soc->num_pmc_clks; i++) {\n\t\tconst struct pmc_clk_init_data *data;\n\n\t\tdata = pmc->soc->pmc_clks_data + i;\n\n\t\tclk = tegra_pmc_clk_out_register(pmc, data, PMC_CLK_OUT_CNTRL);\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_warn(pmc->dev, \"unable to register clock %s: %d\\n\",\n\t\t\t\t data->name, PTR_ERR_OR_ZERO(clk));\n\t\t\treturn;\n\t\t}\n\n\t\terr = clk_register_clkdev(clk, data->name, NULL);\n\t\tif (err) {\n\t\t\tdev_warn(pmc->dev,\n\t\t\t\t \"unable to register %s clock lookup: %d\\n\",\n\t\t\t\t data->name, err);\n\t\t\treturn;\n\t\t}\n\n\t\tclk_data->clks[data->clk_id] = clk;\n\t}\n\n\tif (pmc->soc->has_blink_output) {\n\t\ttegra_pmc_writel(pmc, 0x0, PMC_BLINK_TIMER);\n\t\tclk = tegra_pmc_clk_gate_register(pmc,\n\t\t\t\t\t\t  \"pmc_blink_override\",\n\t\t\t\t\t\t  \"clk_32k\",\n\t\t\t\t\t\t  PMC_DPD_PADS_ORIDE,\n\t\t\t\t\t\t  PMC_DPD_PADS_ORIDE_BLINK);\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_warn(pmc->dev,\n\t\t\t\t \"unable to register pmc_blink_override: %d\\n\",\n\t\t\t\t PTR_ERR_OR_ZERO(clk));\n\t\t\treturn;\n\t\t}\n\n\t\tclk = tegra_pmc_clk_gate_register(pmc, \"pmc_blink\",\n\t\t\t\t\t\t  \"pmc_blink_override\",\n\t\t\t\t\t\t  PMC_CNTRL,\n\t\t\t\t\t\t  PMC_CNTRL_BLINK_EN);\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_warn(pmc->dev,\n\t\t\t\t \"unable to register pmc_blink: %d\\n\",\n\t\t\t\t PTR_ERR_OR_ZERO(clk));\n\t\t\treturn;\n\t\t}\n\n\t\terr = clk_register_clkdev(clk, \"pmc_blink\", NULL);\n\t\tif (err) {\n\t\t\tdev_warn(pmc->dev,\n\t\t\t\t \"unable to register pmc_blink lookup: %d\\n\",\n\t\t\t\t err);\n\t\t\treturn;\n\t\t}\n\n\t\tclk_data->clks[TEGRA_PMC_CLK_BLINK] = clk;\n\t}\n\n\terr = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\n\tif (err)\n\t\tdev_warn(pmc->dev, \"failed to add pmc clock provider: %d\\n\",\n\t\t\t err);\n}\n\nstatic const struct regmap_range pmc_usb_sleepwalk_ranges[] = {\n\tregmap_reg_range(PMC_USB_DEBOUNCE_DEL, PMC_USB_AO),\n\tregmap_reg_range(PMC_UTMIP_UHSIC_TRIGGERS, PMC_UTMIP_UHSIC_SAVED_STATE),\n\tregmap_reg_range(PMC_UTMIP_TERM_PAD_CFG, PMC_UTMIP_UHSIC_FAKE),\n\tregmap_reg_range(PMC_UTMIP_UHSIC_LINE_WAKEUP, PMC_UTMIP_UHSIC_LINE_WAKEUP),\n\tregmap_reg_range(PMC_UTMIP_BIAS_MASTER_CNTRL, PMC_UTMIP_MASTER_CONFIG),\n\tregmap_reg_range(PMC_UTMIP_UHSIC2_TRIGGERS, PMC_UTMIP_MASTER2_CONFIG),\n\tregmap_reg_range(PMC_UTMIP_PAD_CFG0, PMC_UTMIP_UHSIC_SLEEP_CFG1),\n\tregmap_reg_range(PMC_UTMIP_SLEEPWALK_P3, PMC_UTMIP_SLEEPWALK_P3),\n};\n\nstatic const struct regmap_access_table pmc_usb_sleepwalk_table = {\n\t.yes_ranges = pmc_usb_sleepwalk_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(pmc_usb_sleepwalk_ranges),\n};\n\nstatic int tegra_pmc_regmap_readl(void *context, unsigned int offset, unsigned int *value)\n{\n\tstruct tegra_pmc *pmc = context;\n\n\t*value = tegra_pmc_readl(pmc, offset);\n\treturn 0;\n}\n\nstatic int tegra_pmc_regmap_writel(void *context, unsigned int offset, unsigned int value)\n{\n\tstruct tegra_pmc *pmc = context;\n\n\ttegra_pmc_writel(pmc, value, offset);\n\treturn 0;\n}\n\nstatic const struct regmap_config usb_sleepwalk_regmap_config = {\n\t.name = \"usb_sleepwalk\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n\t.rd_table = &pmc_usb_sleepwalk_table,\n\t.wr_table = &pmc_usb_sleepwalk_table,\n\t.reg_read = tegra_pmc_regmap_readl,\n\t.reg_write = tegra_pmc_regmap_writel,\n};\n\nstatic int tegra_pmc_regmap_init(struct tegra_pmc *pmc)\n{\n\tstruct regmap *regmap;\n\tint err;\n\n\tif (pmc->soc->has_usb_sleepwalk) {\n\t\tregmap = devm_regmap_init(pmc->dev, NULL, pmc, &usb_sleepwalk_regmap_config);\n\t\tif (IS_ERR(regmap)) {\n\t\t\terr = PTR_ERR(regmap);\n\t\t\tdev_err(pmc->dev, \"failed to allocate register map (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_pmc_reset_suspend_mode(void *data)\n{\n\tpmc->suspend_mode = TEGRA_SUSPEND_NOT_READY;\n}\n\nstatic int tegra_pmc_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\tstruct resource *res;\n\tint err;\n\n\t \n\tif (WARN_ON(!pmc->base || !pmc->soc))\n\t\treturn -ENODEV;\n\n\terr = tegra_pmc_parse_dt(pmc, pdev->dev.of_node);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&pdev->dev, tegra_pmc_reset_suspend_mode,\n\t\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"wake\");\n\tif (res) {\n\t\tpmc->wake = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(pmc->wake))\n\t\t\treturn PTR_ERR(pmc->wake);\n\t} else {\n\t\tpmc->wake = base;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"aotag\");\n\tif (res) {\n\t\tpmc->aotag = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(pmc->aotag))\n\t\t\treturn PTR_ERR(pmc->aotag);\n\t} else {\n\t\tpmc->aotag = base;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"scratch\");\n\tif (res) {\n\t\tpmc->scratch = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(pmc->scratch))\n\t\t\treturn PTR_ERR(pmc->scratch);\n\t} else {\n\t\tpmc->scratch = base;\n\t}\n\n\tpmc->clk = devm_clk_get_optional(&pdev->dev, \"pclk\");\n\tif (IS_ERR(pmc->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pmc->clk),\n\t\t\t\t     \"failed to get pclk\\n\");\n\n\t \n\terr = devm_register_reboot_notifier(&pdev->dev,\n\t\t\t\t\t    &tegra_pmc_reboot_notifier);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to register reboot notifier, %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = devm_register_sys_off_handler(&pdev->dev,\n\t\t\t\t\t    SYS_OFF_MODE_RESTART,\n\t\t\t\t\t    SYS_OFF_PRIO_LOW,\n\t\t\t\t\t    tegra_pmc_restart_handler, NULL);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register sys-off handler: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\terr = devm_register_sys_off_handler(&pdev->dev,\n\t\t\t\t\t    SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t    SYS_OFF_PRIO_FIRMWARE,\n\t\t\t\t\t    tegra_pmc_power_off_handler, NULL);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register sys-off handler: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tif (pmc->clk) {\n\t\tpmc->clk_nb.notifier_call = tegra_pmc_clk_notify_cb;\n\t\terr = devm_clk_notifier_register(&pdev->dev, pmc->clk,\n\t\t\t\t\t\t &pmc->clk_nb);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to register clk notifier\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tpmc->rate = clk_get_rate(pmc->clk);\n\t}\n\n\tpmc->dev = &pdev->dev;\n\n\terr = tegra_pmc_init(pmc);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize PMC: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_pmc_init_tsense_reset(pmc);\n\n\ttegra_pmc_reset_sysfs_init(pmc);\n\n\terr = tegra_pmc_pinctrl_init(pmc);\n\tif (err)\n\t\tgoto cleanup_sysfs;\n\n\terr = tegra_pmc_regmap_init(pmc);\n\tif (err < 0)\n\t\tgoto cleanup_sysfs;\n\n\terr = tegra_powergate_init(pmc, pdev->dev.of_node);\n\tif (err < 0)\n\t\tgoto cleanup_powergates;\n\n\terr = tegra_pmc_irq_init(pmc);\n\tif (err < 0)\n\t\tgoto cleanup_powergates;\n\n\tmutex_lock(&pmc->powergates_lock);\n\tiounmap(pmc->base);\n\tpmc->base = base;\n\tmutex_unlock(&pmc->powergates_lock);\n\n\ttegra_pmc_clock_register(pmc, pdev->dev.of_node);\n\tplatform_set_drvdata(pdev, pmc);\n\ttegra_pm_init_suspend();\n\n\t \n\tif (pmc->soc->set_wake_filters)\n\t\tpmc->soc->set_wake_filters(pmc);\n\n\tdebugfs_create_file(\"powergate\", 0444, NULL, NULL, &powergate_fops);\n\n\treturn 0;\n\ncleanup_powergates:\n\ttegra_powergate_remove_all(pdev->dev.of_node);\ncleanup_sysfs:\n\tdevice_remove_file(&pdev->dev, &dev_attr_reset_reason);\n\tdevice_remove_file(&pdev->dev, &dev_attr_reset_level);\n\n\treturn err;\n}\n\n \nstatic void wke_32kwritel(struct tegra_pmc *pmc, u32 value, unsigned int offset)\n{\n\twritel(value, pmc->wake + offset);\n\tudelay(130);\n}\n\nstatic void wke_write_wake_level(struct tegra_pmc *pmc, int wake, int level)\n{\n\tunsigned int offset = WAKE_AOWAKE_CNTRL(wake);\n\tu32 value;\n\n\tvalue = readl(pmc->wake + offset);\n\tif (level)\n\t\tvalue |= WAKE_AOWAKE_CNTRL_LEVEL;\n\telse\n\t\tvalue &= ~WAKE_AOWAKE_CNTRL_LEVEL;\n\n\twritel(value, pmc->wake + offset);\n}\n\nstatic void wke_write_wake_levels(struct tegra_pmc *pmc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pmc->soc->max_wake_events; i++)\n\t\twke_write_wake_level(pmc, i, test_bit(i, pmc->wake_cntrl_level_map));\n}\n\nstatic void wke_clear_sw_wake_status(struct tegra_pmc *pmc)\n{\n\twke_32kwritel(pmc, 1, WAKE_AOWAKE_SW_STATUS_W_0);\n}\n\nstatic void wke_read_sw_wake_status(struct tegra_pmc *pmc)\n{\n\tunsigned long status;\n\tunsigned int wake, i;\n\n\tfor (i = 0; i < pmc->soc->max_wake_events; i++)\n\t\twke_write_wake_level(pmc, i, 0);\n\n\twke_clear_sw_wake_status(pmc);\n\n\twke_32kwritel(pmc, 1, WAKE_LATCH_SW);\n\n\t \n\tfor (i = 0; i < pmc->soc->max_wake_events; i++)\n\t\twke_write_wake_level(pmc, i, 1);\n\n\t \n\tudelay(300);\n\n\twke_32kwritel(pmc, 0, WAKE_LATCH_SW);\n\n\tbitmap_zero(pmc->wake_sw_status_map, pmc->soc->max_wake_events);\n\n\tfor (i = 0; i < pmc->soc->max_wake_vectors; i++) {\n\t\tstatus = readl(pmc->wake + WAKE_AOWAKE_SW_STATUS(i));\n\n\t\tfor_each_set_bit(wake, &status, 32)\n\t\t\tset_bit(wake + (i * 32), pmc->wake_sw_status_map);\n\t}\n}\n\nstatic void wke_clear_wake_status(struct tegra_pmc *pmc)\n{\n\tunsigned long status;\n\tunsigned int i, wake;\n\tu32 mask;\n\n\tfor (i = 0; i < pmc->soc->max_wake_vectors; i++) {\n\t\tmask = readl(pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(i));\n\t\tstatus = readl(pmc->wake + WAKE_AOWAKE_STATUS_R(i)) & mask;\n\n\t\tfor_each_set_bit(wake, &status, 32)\n\t\t\twke_32kwritel(pmc, 0x1, WAKE_AOWAKE_STATUS_W((i * 32) + wake));\n\t}\n}\n\n \nstatic void tegra186_pmc_process_wake_events(struct tegra_pmc *pmc, unsigned int index,\n\t\t\t\t\t     unsigned long status)\n{\n\tunsigned int wake;\n\n\tdev_dbg(pmc->dev, \"Wake[%d:%d]  status=%#lx\\n\", (index * 32) + 31, index * 32, status);\n\n\tfor_each_set_bit(wake, &status, 32) {\n\t\tirq_hw_number_t hwirq = wake + 32 * index;\n\t\tstruct irq_desc *desc;\n\t\tunsigned int irq;\n\n\t\tirq = irq_find_mapping(pmc->domain, hwirq);\n\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc || !desc->action || !desc->action->name) {\n\t\t\tdev_dbg(pmc->dev, \"Resume caused by WAKE%ld, IRQ %d\\n\", hwirq, irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(pmc->dev, \"Resume caused by WAKE%ld, %s\\n\", hwirq, desc->action->name);\n\t\tgeneric_handle_irq(irq);\n\t}\n}\n\nstatic void tegra186_pmc_wake_syscore_resume(void)\n{\n\tu32 status, mask;\n\tunsigned int i;\n\n\tfor (i = 0; i < pmc->soc->max_wake_vectors; i++) {\n\t\tmask = readl(pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(i));\n\t\tstatus = readl(pmc->wake + WAKE_AOWAKE_STATUS_R(i)) & mask;\n\n\t\ttegra186_pmc_process_wake_events(pmc, i, status);\n\t}\n}\n\nstatic int tegra186_pmc_wake_syscore_suspend(void)\n{\n\twke_read_sw_wake_status(pmc);\n\n\t \n\tbitmap_andnot(pmc->wake_cntrl_level_map, pmc->wake_type_dual_edge_map,\n\t\t      pmc->wake_sw_status_map, pmc->soc->max_wake_events);\n\tbitmap_or(pmc->wake_cntrl_level_map, pmc->wake_cntrl_level_map,\n\t\t  pmc->wake_type_level_map, pmc->soc->max_wake_events);\n\n\t \n\twke_clear_wake_status(pmc);\n\twke_write_wake_levels(pmc);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_ARM)\nstatic int tegra_pmc_suspend(struct device *dev)\n{\n\tstruct tegra_pmc *pmc = dev_get_drvdata(dev);\n\n\ttegra_pmc_writel(pmc, virt_to_phys(tegra_resume), PMC_SCRATCH41);\n\n\treturn 0;\n}\n\nstatic int tegra_pmc_resume(struct device *dev)\n{\n\tstruct tegra_pmc *pmc = dev_get_drvdata(dev);\n\n\ttegra_pmc_writel(pmc, 0x0, PMC_SCRATCH41);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tegra_pmc_pm_ops, tegra_pmc_suspend, tegra_pmc_resume);\n\n#endif\n\nstatic const char * const tegra20_powergates[] = {\n\t[TEGRA_POWERGATE_CPU] = \"cpu\",\n\t[TEGRA_POWERGATE_3D] = \"td\",\n\t[TEGRA_POWERGATE_VENC] = \"venc\",\n\t[TEGRA_POWERGATE_VDEC] = \"vdec\",\n\t[TEGRA_POWERGATE_PCIE] = \"pcie\",\n\t[TEGRA_POWERGATE_L2] = \"l2\",\n\t[TEGRA_POWERGATE_MPE] = \"mpe\",\n};\n\nstatic const struct tegra_pmc_regs tegra20_pmc_regs = {\n\t.scratch0 = 0x50,\n\t.rst_status = 0x1b4,\n\t.rst_source_shift = 0x0,\n\t.rst_source_mask = 0x7,\n\t.rst_level_shift = 0x0,\n\t.rst_level_mask = 0x0,\n};\n\nstatic void tegra20_pmc_init(struct tegra_pmc *pmc)\n{\n\tu32 value, osc, pmu, off;\n\n\t \n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\tvalue |= PMC_CNTRL_CPU_PWRREQ_OE;\n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n\n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\n\tif (pmc->sysclkreq_high)\n\t\tvalue &= ~PMC_CNTRL_SYSCLK_POLARITY;\n\telse\n\t\tvalue |= PMC_CNTRL_SYSCLK_POLARITY;\n\n\tif (pmc->corereq_high)\n\t\tvalue &= ~PMC_CNTRL_PWRREQ_POLARITY;\n\telse\n\t\tvalue |= PMC_CNTRL_PWRREQ_POLARITY;\n\n\t \n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n\n\t \n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\tvalue |= PMC_CNTRL_SYSCLK_OE;\n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n\n\t \n\tif (pmc->suspend_mode != TEGRA_SUSPEND_NONE) {\n\t\tosc = DIV_ROUND_UP(pmc->core_osc_time * 8192, 1000000);\n\t\tpmu = DIV_ROUND_UP(pmc->core_pmu_time * 32768, 1000000);\n\t\toff = DIV_ROUND_UP(pmc->core_off_time * 32768, 1000000);\n\t\ttegra_pmc_writel(pmc, ((osc << 8) & 0xff00) | (pmu & 0xff),\n\t\t\t\t PMC_COREPWRGOOD_TIMER);\n\t\ttegra_pmc_writel(pmc, off, PMC_COREPWROFF_TIMER);\n\t}\n}\n\nstatic void tegra20_pmc_setup_irq_polarity(struct tegra_pmc *pmc,\n\t\t\t\t\t   struct device_node *np,\n\t\t\t\t\t   bool invert)\n{\n\tu32 value;\n\n\tvalue = tegra_pmc_readl(pmc, PMC_CNTRL);\n\n\tif (invert)\n\t\tvalue |= PMC_CNTRL_INTR_POLARITY;\n\telse\n\t\tvalue &= ~PMC_CNTRL_INTR_POLARITY;\n\n\ttegra_pmc_writel(pmc, value, PMC_CNTRL);\n}\n\nstatic const struct tegra_pmc_soc tegra20_pmc_soc = {\n\t.supports_core_domain = true,\n\t.num_powergates = ARRAY_SIZE(tegra20_powergates),\n\t.powergates = tegra20_powergates,\n\t.num_cpu_powergates = 0,\n\t.cpu_powergates = NULL,\n\t.has_tsense_reset = false,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = false,\n\t.maybe_tz_only = false,\n\t.num_io_pads = 0,\n\t.io_pads = NULL,\n\t.num_pin_descs = 0,\n\t.pin_descs = NULL,\n\t.regs = &tegra20_pmc_regs,\n\t.init = tegra20_pmc_init,\n\t.setup_irq_polarity = tegra20_pmc_setup_irq_polarity,\n\t.powergate_set = tegra20_powergate_set,\n\t.reset_sources = NULL,\n\t.num_reset_sources = 0,\n\t.reset_levels = NULL,\n\t.num_reset_levels = 0,\n\t.pmc_clks_data = NULL,\n\t.num_pmc_clks = 0,\n\t.has_blink_output = true,\n\t.has_usb_sleepwalk = true,\n};\n\nstatic const char * const tegra30_powergates[] = {\n\t[TEGRA_POWERGATE_CPU] = \"cpu0\",\n\t[TEGRA_POWERGATE_3D] = \"td\",\n\t[TEGRA_POWERGATE_VENC] = \"venc\",\n\t[TEGRA_POWERGATE_VDEC] = \"vdec\",\n\t[TEGRA_POWERGATE_PCIE] = \"pcie\",\n\t[TEGRA_POWERGATE_L2] = \"l2\",\n\t[TEGRA_POWERGATE_MPE] = \"mpe\",\n\t[TEGRA_POWERGATE_HEG] = \"heg\",\n\t[TEGRA_POWERGATE_SATA] = \"sata\",\n\t[TEGRA_POWERGATE_CPU1] = \"cpu1\",\n\t[TEGRA_POWERGATE_CPU2] = \"cpu2\",\n\t[TEGRA_POWERGATE_CPU3] = \"cpu3\",\n\t[TEGRA_POWERGATE_CELP] = \"celp\",\n\t[TEGRA_POWERGATE_3D1] = \"td2\",\n};\n\nstatic const u8 tegra30_cpu_powergates[] = {\n\tTEGRA_POWERGATE_CPU,\n\tTEGRA_POWERGATE_CPU1,\n\tTEGRA_POWERGATE_CPU2,\n\tTEGRA_POWERGATE_CPU3,\n};\n\nstatic const char * const tegra30_reset_sources[] = {\n\t\"POWER_ON_RESET\",\n\t\"WATCHDOG\",\n\t\"SENSOR\",\n\t\"SW_MAIN\",\n\t\"LP0\"\n};\n\nstatic const struct tegra_pmc_soc tegra30_pmc_soc = {\n\t.supports_core_domain = true,\n\t.num_powergates = ARRAY_SIZE(tegra30_powergates),\n\t.powergates = tegra30_powergates,\n\t.num_cpu_powergates = ARRAY_SIZE(tegra30_cpu_powergates),\n\t.cpu_powergates = tegra30_cpu_powergates,\n\t.has_tsense_reset = true,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = false,\n\t.maybe_tz_only = false,\n\t.num_io_pads = 0,\n\t.io_pads = NULL,\n\t.num_pin_descs = 0,\n\t.pin_descs = NULL,\n\t.regs = &tegra20_pmc_regs,\n\t.init = tegra20_pmc_init,\n\t.setup_irq_polarity = tegra20_pmc_setup_irq_polarity,\n\t.powergate_set = tegra20_powergate_set,\n\t.reset_sources = tegra30_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra30_reset_sources),\n\t.reset_levels = NULL,\n\t.num_reset_levels = 0,\n\t.pmc_clks_data = tegra_pmc_clks_data,\n\t.num_pmc_clks = ARRAY_SIZE(tegra_pmc_clks_data),\n\t.has_blink_output = true,\n\t.has_usb_sleepwalk = true,\n};\n\nstatic const char * const tegra114_powergates[] = {\n\t[TEGRA_POWERGATE_CPU] = \"crail\",\n\t[TEGRA_POWERGATE_3D] = \"td\",\n\t[TEGRA_POWERGATE_VENC] = \"venc\",\n\t[TEGRA_POWERGATE_VDEC] = \"vdec\",\n\t[TEGRA_POWERGATE_MPE] = \"mpe\",\n\t[TEGRA_POWERGATE_HEG] = \"heg\",\n\t[TEGRA_POWERGATE_CPU1] = \"cpu1\",\n\t[TEGRA_POWERGATE_CPU2] = \"cpu2\",\n\t[TEGRA_POWERGATE_CPU3] = \"cpu3\",\n\t[TEGRA_POWERGATE_CELP] = \"celp\",\n\t[TEGRA_POWERGATE_CPU0] = \"cpu0\",\n\t[TEGRA_POWERGATE_C0NC] = \"c0nc\",\n\t[TEGRA_POWERGATE_C1NC] = \"c1nc\",\n\t[TEGRA_POWERGATE_DIS] = \"dis\",\n\t[TEGRA_POWERGATE_DISB] = \"disb\",\n\t[TEGRA_POWERGATE_XUSBA] = \"xusba\",\n\t[TEGRA_POWERGATE_XUSBB] = \"xusbb\",\n\t[TEGRA_POWERGATE_XUSBC] = \"xusbc\",\n};\n\nstatic const u8 tegra114_cpu_powergates[] = {\n\tTEGRA_POWERGATE_CPU0,\n\tTEGRA_POWERGATE_CPU1,\n\tTEGRA_POWERGATE_CPU2,\n\tTEGRA_POWERGATE_CPU3,\n};\n\nstatic const struct tegra_pmc_soc tegra114_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = ARRAY_SIZE(tegra114_powergates),\n\t.powergates = tegra114_powergates,\n\t.num_cpu_powergates = ARRAY_SIZE(tegra114_cpu_powergates),\n\t.cpu_powergates = tegra114_cpu_powergates,\n\t.has_tsense_reset = true,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = false,\n\t.maybe_tz_only = false,\n\t.num_io_pads = 0,\n\t.io_pads = NULL,\n\t.num_pin_descs = 0,\n\t.pin_descs = NULL,\n\t.regs = &tegra20_pmc_regs,\n\t.init = tegra20_pmc_init,\n\t.setup_irq_polarity = tegra20_pmc_setup_irq_polarity,\n\t.powergate_set = tegra114_powergate_set,\n\t.reset_sources = tegra30_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra30_reset_sources),\n\t.reset_levels = NULL,\n\t.num_reset_levels = 0,\n\t.pmc_clks_data = tegra_pmc_clks_data,\n\t.num_pmc_clks = ARRAY_SIZE(tegra_pmc_clks_data),\n\t.has_blink_output = true,\n\t.has_usb_sleepwalk = true,\n};\n\nstatic const char * const tegra124_powergates[] = {\n\t[TEGRA_POWERGATE_CPU] = \"crail\",\n\t[TEGRA_POWERGATE_3D] = \"3d\",\n\t[TEGRA_POWERGATE_VENC] = \"venc\",\n\t[TEGRA_POWERGATE_PCIE] = \"pcie\",\n\t[TEGRA_POWERGATE_VDEC] = \"vdec\",\n\t[TEGRA_POWERGATE_MPE] = \"mpe\",\n\t[TEGRA_POWERGATE_HEG] = \"heg\",\n\t[TEGRA_POWERGATE_SATA] = \"sata\",\n\t[TEGRA_POWERGATE_CPU1] = \"cpu1\",\n\t[TEGRA_POWERGATE_CPU2] = \"cpu2\",\n\t[TEGRA_POWERGATE_CPU3] = \"cpu3\",\n\t[TEGRA_POWERGATE_CELP] = \"celp\",\n\t[TEGRA_POWERGATE_CPU0] = \"cpu0\",\n\t[TEGRA_POWERGATE_C0NC] = \"c0nc\",\n\t[TEGRA_POWERGATE_C1NC] = \"c1nc\",\n\t[TEGRA_POWERGATE_SOR] = \"sor\",\n\t[TEGRA_POWERGATE_DIS] = \"dis\",\n\t[TEGRA_POWERGATE_DISB] = \"disb\",\n\t[TEGRA_POWERGATE_XUSBA] = \"xusba\",\n\t[TEGRA_POWERGATE_XUSBB] = \"xusbb\",\n\t[TEGRA_POWERGATE_XUSBC] = \"xusbc\",\n\t[TEGRA_POWERGATE_VIC] = \"vic\",\n\t[TEGRA_POWERGATE_IRAM] = \"iram\",\n};\n\nstatic const u8 tegra124_cpu_powergates[] = {\n\tTEGRA_POWERGATE_CPU0,\n\tTEGRA_POWERGATE_CPU1,\n\tTEGRA_POWERGATE_CPU2,\n\tTEGRA_POWERGATE_CPU3,\n};\n\n#define TEGRA_IO_PAD(_id, _dpd, _request, _status, _voltage, _name)\t\\\n\t((struct tegra_io_pad_soc) {\t\t\t\t\t\\\n\t\t.id\t\t= (_id),\t\t\t\t\\\n\t\t.dpd\t\t= (_dpd),\t\t\t\t\\\n\t\t.request\t= (_request),\t\t\t\t\\\n\t\t.status\t\t= (_status),\t\t\t\t\\\n\t\t.voltage\t= (_voltage),\t\t\t\t\\\n\t\t.name\t\t= (_name),\t\t\t\t\\\n\t})\n\n#define TEGRA_IO_PIN_DESC(_id, _name)\t\\\n\t((struct pinctrl_pin_desc) {\t\\\n\t\t.number\t= (_id),\t\\\n\t\t.name\t= (_name),\t\\\n\t})\n\nstatic const struct tegra_io_pad_soc tegra124_io_pads[] = {\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO, 17, 0x1b8, 0x1bc, UINT_MAX, \"audio\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_BB, 15, 0x1b8, 0x1bc, UINT_MAX, \"bb\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CAM, 4, 0x1c0, 0x1c4, UINT_MAX, \"cam\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_COMP, 22, 0x1b8, 0x1bc, UINT_MAX, \"comp\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIA, 0, 0x1b8, 0x1bc, UINT_MAX, \"csia\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIB, 1, 0x1b8, 0x1bc, UINT_MAX, \"csib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIE, 12, 0x1c0, 0x1c4, UINT_MAX, \"csie\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSI, 2, 0x1b8, 0x1bc, UINT_MAX, \"dsi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIB, 7, 0x1c0, 0x1c4, UINT_MAX, \"dsib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIC, 8, 0x1c0, 0x1c4, UINT_MAX, \"dsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSID, 9, 0x1c0, 0x1c4, UINT_MAX, \"dsid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI, 28, 0x1b8, 0x1bc, UINT_MAX, \"hdmi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HSIC, 19, 0x1b8, 0x1bc, UINT_MAX, \"hsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HV, 6, 0x1c0, 0x1c4, UINT_MAX, \"hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_LVDS, 25, 0x1c0, 0x1c4, UINT_MAX, \"lvds\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_MIPI_BIAS, 3, 0x1b8, 0x1bc, UINT_MAX, \"mipi-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_NAND, 13, 0x1b8, 0x1bc, UINT_MAX, \"nand\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_BIAS, 4, 0x1b8, 0x1bc, UINT_MAX, \"pex-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK1, 5, 0x1b8, 0x1bc, UINT_MAX, \"pex-clk1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK2, 6, 0x1b8, 0x1bc, UINT_MAX, \"pex-clk2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CNTRL, 0, 0x1c0, 0x1c4, UINT_MAX, \"pex-cntrl\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC1, 1, 0x1c0, 0x1c4, UINT_MAX, \"sdmmc1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC3, 2, 0x1c0, 0x1c4, UINT_MAX, \"sdmmc3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC4, 3, 0x1c0, 0x1c4, UINT_MAX, \"sdmmc4\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SYS_DDC, 26, 0x1c0, 0x1c4, UINT_MAX, \"sys_ddc\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART, 14, 0x1b8, 0x1bc, UINT_MAX, \"uart\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB0, 9, 0x1b8, 0x1bc, UINT_MAX, \"usb0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB1, 10, 0x1b8, 0x1bc, UINT_MAX, \"usb1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB2, 11, 0x1b8, 0x1bc, UINT_MAX, \"usb2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB_BIAS, 12, 0x1b8, 0x1bc, UINT_MAX, \"usb_bias\"),\n};\n\nstatic const struct pinctrl_pin_desc tegra124_pin_descs[] = {\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO, \"audio\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_BB, \"bb\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CAM, \"cam\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_COMP, \"comp\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIA, \"csia\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIB, \"csib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIE, \"csie\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSI, \"dsi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIB, \"dsib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIC, \"dsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSID, \"dsid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI, \"hdmi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HSIC, \"hsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HV, \"hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_LVDS, \"lvds\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_MIPI_BIAS, \"mipi-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_NAND, \"nand\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_BIAS, \"pex-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK1, \"pex-clk1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK2, \"pex-clk2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CNTRL, \"pex-cntrl\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC1, \"sdmmc1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC3, \"sdmmc3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC4, \"sdmmc4\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SYS_DDC, \"sys_ddc\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART, \"uart\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB0, \"usb0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB1, \"usb1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB2, \"usb2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB_BIAS, \"usb_bias\"),\n};\n\nstatic const struct tegra_pmc_soc tegra124_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = ARRAY_SIZE(tegra124_powergates),\n\t.powergates = tegra124_powergates,\n\t.num_cpu_powergates = ARRAY_SIZE(tegra124_cpu_powergates),\n\t.cpu_powergates = tegra124_cpu_powergates,\n\t.has_tsense_reset = true,\n\t.has_gpu_clamps = true,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = false,\n\t.maybe_tz_only = false,\n\t.num_io_pads = ARRAY_SIZE(tegra124_io_pads),\n\t.io_pads = tegra124_io_pads,\n\t.num_pin_descs = ARRAY_SIZE(tegra124_pin_descs),\n\t.pin_descs = tegra124_pin_descs,\n\t.regs = &tegra20_pmc_regs,\n\t.init = tegra20_pmc_init,\n\t.setup_irq_polarity = tegra20_pmc_setup_irq_polarity,\n\t.powergate_set = tegra114_powergate_set,\n\t.reset_sources = tegra30_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra30_reset_sources),\n\t.reset_levels = NULL,\n\t.num_reset_levels = 0,\n\t.pmc_clks_data = tegra_pmc_clks_data,\n\t.num_pmc_clks = ARRAY_SIZE(tegra_pmc_clks_data),\n\t.has_blink_output = true,\n\t.has_usb_sleepwalk = true,\n};\n\nstatic const char * const tegra210_powergates[] = {\n\t[TEGRA_POWERGATE_CPU] = \"crail\",\n\t[TEGRA_POWERGATE_3D] = \"3d\",\n\t[TEGRA_POWERGATE_VENC] = \"venc\",\n\t[TEGRA_POWERGATE_PCIE] = \"pcie\",\n\t[TEGRA_POWERGATE_MPE] = \"mpe\",\n\t[TEGRA_POWERGATE_SATA] = \"sata\",\n\t[TEGRA_POWERGATE_CPU1] = \"cpu1\",\n\t[TEGRA_POWERGATE_CPU2] = \"cpu2\",\n\t[TEGRA_POWERGATE_CPU3] = \"cpu3\",\n\t[TEGRA_POWERGATE_CPU0] = \"cpu0\",\n\t[TEGRA_POWERGATE_C0NC] = \"c0nc\",\n\t[TEGRA_POWERGATE_SOR] = \"sor\",\n\t[TEGRA_POWERGATE_DIS] = \"dis\",\n\t[TEGRA_POWERGATE_DISB] = \"disb\",\n\t[TEGRA_POWERGATE_XUSBA] = \"xusba\",\n\t[TEGRA_POWERGATE_XUSBB] = \"xusbb\",\n\t[TEGRA_POWERGATE_XUSBC] = \"xusbc\",\n\t[TEGRA_POWERGATE_VIC] = \"vic\",\n\t[TEGRA_POWERGATE_IRAM] = \"iram\",\n\t[TEGRA_POWERGATE_NVDEC] = \"nvdec\",\n\t[TEGRA_POWERGATE_NVJPG] = \"nvjpg\",\n\t[TEGRA_POWERGATE_AUD] = \"aud\",\n\t[TEGRA_POWERGATE_DFD] = \"dfd\",\n\t[TEGRA_POWERGATE_VE2] = \"ve2\",\n};\n\nstatic const u8 tegra210_cpu_powergates[] = {\n\tTEGRA_POWERGATE_CPU0,\n\tTEGRA_POWERGATE_CPU1,\n\tTEGRA_POWERGATE_CPU2,\n\tTEGRA_POWERGATE_CPU3,\n};\n\nstatic const struct tegra_io_pad_soc tegra210_io_pads[] = {\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO, 17, 0x1b8, 0x1bc, 5, \"audio\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO_HV, 29, 0x1c0, 0x1c4, 18, \"audio-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CAM, 4, 0x1c0, 0x1c4, 10, \"cam\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIA, 0, 0x1b8, 0x1bc, UINT_MAX, \"csia\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIB, 1, 0x1b8, 0x1bc, UINT_MAX, \"csib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIC, 10, 0x1c0, 0x1c4, UINT_MAX, \"csic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSID, 11, 0x1c0, 0x1c4, UINT_MAX, \"csid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIE, 12, 0x1c0, 0x1c4, UINT_MAX, \"csie\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIF, 13, 0x1c0, 0x1c4, UINT_MAX, \"csif\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DBG, 25, 0x1b8, 0x1bc, 19, \"dbg\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DEBUG_NONAO, 26, 0x1b8, 0x1bc, UINT_MAX, \"debug-nonao\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DMIC, 18, 0x1c0, 0x1c4, 20, \"dmic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DP, 19, 0x1c0, 0x1c4, UINT_MAX, \"dp\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSI, 2, 0x1b8, 0x1bc, UINT_MAX, \"dsi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIB, 7, 0x1c0, 0x1c4, UINT_MAX, \"dsib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIC, 8, 0x1c0, 0x1c4, UINT_MAX, \"dsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSID, 9, 0x1c0, 0x1c4, UINT_MAX, \"dsid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EMMC, 3, 0x1c0, 0x1c4, UINT_MAX, \"emmc\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EMMC2, 5, 0x1c0, 0x1c4, UINT_MAX, \"emmc2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_GPIO, 27, 0x1b8, 0x1bc, 21, \"gpio\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI, 28, 0x1b8, 0x1bc, UINT_MAX, \"hdmi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HSIC, 19, 0x1b8, 0x1bc, UINT_MAX, \"hsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_LVDS, 25, 0x1c0, 0x1c4, UINT_MAX, \"lvds\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_MIPI_BIAS, 3, 0x1b8, 0x1bc, UINT_MAX, \"mipi-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_BIAS, 4, 0x1b8, 0x1bc, UINT_MAX, \"pex-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK1, 5, 0x1b8, 0x1bc, UINT_MAX, \"pex-clk1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK2, 6, 0x1b8, 0x1bc, UINT_MAX, \"pex-clk2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CNTRL, UINT_MAX, UINT_MAX, UINT_MAX, 11, \"pex-cntrl\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC1, 1, 0x1c0, 0x1c4, 12, \"sdmmc1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC3, 2, 0x1c0, 0x1c4, 13, \"sdmmc3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SPI, 14, 0x1c0, 0x1c4, 22, \"spi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SPI_HV, 15, 0x1c0, 0x1c4, 23, \"spi-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART, 14, 0x1b8, 0x1bc, 2, \"uart\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB0, 9, 0x1b8, 0x1bc, UINT_MAX, \"usb0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB1, 10, 0x1b8, 0x1bc, UINT_MAX, \"usb1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB2, 11, 0x1b8, 0x1bc, UINT_MAX, \"usb2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB3, 18, 0x1b8, 0x1bc, UINT_MAX, \"usb3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB_BIAS, 12, 0x1b8, 0x1bc, UINT_MAX, \"usb-bias\"),\n};\n\nstatic const struct pinctrl_pin_desc tegra210_pin_descs[] = {\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO, \"audio\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO_HV, \"audio-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CAM, \"cam\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIA, \"csia\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIB, \"csib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIC, \"csic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSID, \"csid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIE, \"csie\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIF, \"csif\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DBG, \"dbg\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DEBUG_NONAO, \"debug-nonao\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DMIC, \"dmic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DP, \"dp\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSI, \"dsi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIB, \"dsib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIC, \"dsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSID, \"dsid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EMMC, \"emmc\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EMMC2, \"emmc2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_GPIO, \"gpio\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI, \"hdmi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HSIC, \"hsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_LVDS, \"lvds\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_MIPI_BIAS, \"mipi-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_BIAS, \"pex-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK1, \"pex-clk1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK2, \"pex-clk2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CNTRL, \"pex-cntrl\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC1, \"sdmmc1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC3, \"sdmmc3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SPI, \"spi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SPI_HV, \"spi-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART, \"uart\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB0, \"usb0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB1, \"usb1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB2, \"usb2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB3, \"usb3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB_BIAS, \"usb-bias\"),\n};\n\nstatic const char * const tegra210_reset_sources[] = {\n\t\"POWER_ON_RESET\",\n\t\"WATCHDOG\",\n\t\"SENSOR\",\n\t\"SW_MAIN\",\n\t\"LP0\",\n\t\"AOTAG\"\n};\n\nstatic const struct tegra_wake_event tegra210_wake_events[] = {\n\tTEGRA_WAKE_IRQ(\"rtc\", 16, 2),\n\tTEGRA_WAKE_IRQ(\"pmu\", 51, 86),\n};\n\nstatic const struct tegra_pmc_soc tegra210_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = ARRAY_SIZE(tegra210_powergates),\n\t.powergates = tegra210_powergates,\n\t.num_cpu_powergates = ARRAY_SIZE(tegra210_cpu_powergates),\n\t.cpu_powergates = tegra210_cpu_powergates,\n\t.has_tsense_reset = true,\n\t.has_gpu_clamps = true,\n\t.needs_mbist_war = true,\n\t.has_impl_33v_pwr = false,\n\t.maybe_tz_only = true,\n\t.num_io_pads = ARRAY_SIZE(tegra210_io_pads),\n\t.io_pads = tegra210_io_pads,\n\t.num_pin_descs = ARRAY_SIZE(tegra210_pin_descs),\n\t.pin_descs = tegra210_pin_descs,\n\t.regs = &tegra20_pmc_regs,\n\t.init = tegra20_pmc_init,\n\t.setup_irq_polarity = tegra20_pmc_setup_irq_polarity,\n\t.powergate_set = tegra114_powergate_set,\n\t.irq_set_wake = tegra210_pmc_irq_set_wake,\n\t.irq_set_type = tegra210_pmc_irq_set_type,\n\t.reset_sources = tegra210_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra210_reset_sources),\n\t.reset_levels = NULL,\n\t.num_reset_levels = 0,\n\t.num_wake_events = ARRAY_SIZE(tegra210_wake_events),\n\t.wake_events = tegra210_wake_events,\n\t.pmc_clks_data = tegra_pmc_clks_data,\n\t.num_pmc_clks = ARRAY_SIZE(tegra_pmc_clks_data),\n\t.has_blink_output = true,\n\t.has_usb_sleepwalk = true,\n};\n\nstatic const struct tegra_io_pad_soc tegra186_io_pads[] = {\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIA, 0, 0x74, 0x78, UINT_MAX, \"csia\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIB, 1, 0x74, 0x78, UINT_MAX, \"csib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSI, 2, 0x74, 0x78, UINT_MAX, \"dsi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_MIPI_BIAS, 3, 0x74, 0x78, UINT_MAX, \"mipi-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK_BIAS, 4, 0x74, 0x78, UINT_MAX, \"pex-clk-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK3, 5, 0x74, 0x78, UINT_MAX, \"pex-clk3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK2, 6, 0x74, 0x78, UINT_MAX, \"pex-clk2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK1, 7, 0x74, 0x78, UINT_MAX, \"pex-clk1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB0, 9, 0x74, 0x78, UINT_MAX, \"usb0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB1, 10, 0x74, 0x78, UINT_MAX, \"usb1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB2, 11, 0x74, 0x78, UINT_MAX, \"usb2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_USB_BIAS, 12, 0x74, 0x78, UINT_MAX, \"usb-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART, 14, 0x74, 0x78, UINT_MAX, \"uart\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO, 17, 0x74, 0x78, UINT_MAX, \"audio\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HSIC, 19, 0x74, 0x78, UINT_MAX, \"hsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DBG, 25, 0x74, 0x78, UINT_MAX, \"dbg\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP0, 28, 0x74, 0x78, UINT_MAX, \"hdmi-dp0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP1, 29, 0x74, 0x78, UINT_MAX, \"hdmi-dp1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CNTRL, 0, 0x7c, 0x80, UINT_MAX, \"pex-cntrl\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC2_HV, 2, 0x7c, 0x80, 5, \"sdmmc2-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC4, 4, 0x7c, 0x80, UINT_MAX, \"sdmmc4\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CAM, 6, 0x7c, 0x80, UINT_MAX, \"cam\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIB, 8, 0x7c, 0x80, UINT_MAX, \"dsib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSIC, 9, 0x7c, 0x80, UINT_MAX, \"dsic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DSID, 10, 0x7c, 0x80, UINT_MAX, \"dsid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIC, 11, 0x7c, 0x80, UINT_MAX, \"csic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSID, 12, 0x7c, 0x80, UINT_MAX, \"csid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIE, 13, 0x7c, 0x80, UINT_MAX, \"csie\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIF, 14, 0x7c, 0x80, UINT_MAX, \"csif\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SPI, 15, 0x7c, 0x80, UINT_MAX, \"spi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UFS, 17, 0x7c, 0x80, UINT_MAX, \"ufs\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DMIC_HV, 20, 0x7c, 0x80, 2, \"dmic-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EDP, 21, 0x7c, 0x80, UINT_MAX, \"edp\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC1_HV, 23, 0x7c, 0x80, 4, \"sdmmc1-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC3_HV, 24, 0x7c, 0x80, 6, \"sdmmc3-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CONN, 28, 0x7c, 0x80, UINT_MAX, \"conn\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO_HV, 29, 0x7c, 0x80, 1, \"audio-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AO_HV, UINT_MAX, UINT_MAX, UINT_MAX, 0, \"ao-hv\"),\n};\n\nstatic const struct pinctrl_pin_desc tegra186_pin_descs[] = {\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIA, \"csia\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIB, \"csib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSI, \"dsi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_MIPI_BIAS, \"mipi-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK_BIAS, \"pex-clk-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK3, \"pex-clk3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK2, \"pex-clk2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK1, \"pex-clk1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB0, \"usb0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB1, \"usb1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB2, \"usb2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_USB_BIAS, \"usb-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART, \"uart\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO, \"audio\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HSIC, \"hsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DBG, \"dbg\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP0, \"hdmi-dp0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP1, \"hdmi-dp1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CNTRL, \"pex-cntrl\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC2_HV, \"sdmmc2-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC4, \"sdmmc4\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CAM, \"cam\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIB, \"dsib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSIC, \"dsic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DSID, \"dsid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIC, \"csic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSID, \"csid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIE, \"csie\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIF, \"csif\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SPI, \"spi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UFS, \"ufs\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DMIC_HV, \"dmic-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EDP, \"edp\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC1_HV, \"sdmmc1-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC3_HV, \"sdmmc3-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CONN, \"conn\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO_HV, \"audio-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AO_HV, \"ao-hv\"),\n};\n\nstatic const struct tegra_pmc_regs tegra186_pmc_regs = {\n\t.scratch0 = 0x2000,\n\t.rst_status = 0x70,\n\t.rst_source_shift = 0x2,\n\t.rst_source_mask = 0x3c,\n\t.rst_level_shift = 0x0,\n\t.rst_level_mask = 0x3,\n};\n\nstatic void tegra186_pmc_init(struct tegra_pmc *pmc)\n{\n\tpmc->syscore.suspend = tegra186_pmc_wake_syscore_suspend;\n\tpmc->syscore.resume = tegra186_pmc_wake_syscore_resume;\n\n\tregister_syscore_ops(&pmc->syscore);\n}\n\nstatic void tegra186_pmc_setup_irq_polarity(struct tegra_pmc *pmc,\n\t\t\t\t\t    struct device_node *np,\n\t\t\t\t\t    bool invert)\n{\n\tstruct resource regs;\n\tvoid __iomem *wake;\n\tu32 value;\n\tint index;\n\n\tindex = of_property_match_string(np, \"reg-names\", \"wake\");\n\tif (index < 0) {\n\t\tdev_err(pmc->dev, \"failed to find PMC wake registers\\n\");\n\t\treturn;\n\t}\n\n\tof_address_to_resource(np, index, &regs);\n\n\twake = ioremap(regs.start, resource_size(&regs));\n\tif (!wake) {\n\t\tdev_err(pmc->dev, \"failed to map PMC wake registers\\n\");\n\t\treturn;\n\t}\n\n\tvalue = readl(wake + WAKE_AOWAKE_CTRL);\n\n\tif (invert)\n\t\tvalue |= WAKE_AOWAKE_CTRL_INTR_POLARITY;\n\telse\n\t\tvalue &= ~WAKE_AOWAKE_CTRL_INTR_POLARITY;\n\n\twritel(value, wake + WAKE_AOWAKE_CTRL);\n\n\tiounmap(wake);\n}\n\nstatic const char * const tegra186_reset_sources[] = {\n\t\"SYS_RESET\",\n\t\"AOWDT\",\n\t\"MCCPLEXWDT\",\n\t\"BPMPWDT\",\n\t\"SCEWDT\",\n\t\"SPEWDT\",\n\t\"APEWDT\",\n\t\"BCCPLEXWDT\",\n\t\"SENSOR\",\n\t\"AOTAG\",\n\t\"VFSENSOR\",\n\t\"SWREST\",\n\t\"SC7\",\n\t\"HSM\",\n\t\"CORESIGHT\"\n};\n\nstatic const char * const tegra186_reset_levels[] = {\n\t\"L0\", \"L1\", \"L2\", \"WARM\"\n};\n\nstatic const struct tegra_wake_event tegra186_wake_events[] = {\n\tTEGRA_WAKE_IRQ(\"pmu\", 24, 209),\n\tTEGRA_WAKE_GPIO(\"power\", 29, 1, TEGRA186_AON_GPIO(FF, 0)),\n\tTEGRA_WAKE_IRQ(\"rtc\", 73, 10),\n};\n\nstatic const struct tegra_pmc_soc tegra186_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = 0,\n\t.powergates = NULL,\n\t.num_cpu_powergates = 0,\n\t.cpu_powergates = NULL,\n\t.has_tsense_reset = false,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = true,\n\t.maybe_tz_only = false,\n\t.num_io_pads = ARRAY_SIZE(tegra186_io_pads),\n\t.io_pads = tegra186_io_pads,\n\t.num_pin_descs = ARRAY_SIZE(tegra186_pin_descs),\n\t.pin_descs = tegra186_pin_descs,\n\t.regs = &tegra186_pmc_regs,\n\t.init = tegra186_pmc_init,\n\t.setup_irq_polarity = tegra186_pmc_setup_irq_polarity,\n\t.set_wake_filters = tegra186_pmc_set_wake_filters,\n\t.irq_set_wake = tegra186_pmc_irq_set_wake,\n\t.irq_set_type = tegra186_pmc_irq_set_type,\n\t.reset_sources = tegra186_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra186_reset_sources),\n\t.reset_levels = tegra186_reset_levels,\n\t.num_reset_levels = ARRAY_SIZE(tegra186_reset_levels),\n\t.num_wake_events = ARRAY_SIZE(tegra186_wake_events),\n\t.wake_events = tegra186_wake_events,\n\t.max_wake_events = 96,\n\t.max_wake_vectors = 3,\n\t.pmc_clks_data = NULL,\n\t.num_pmc_clks = 0,\n\t.has_blink_output = false,\n\t.has_usb_sleepwalk = false,\n};\n\nstatic const struct tegra_io_pad_soc tegra194_io_pads[] = {\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIA, 0, 0x74, 0x78, UINT_MAX, \"csia\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIB, 1, 0x74, 0x78, UINT_MAX, \"csib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_MIPI_BIAS, 3, 0x74, 0x78, UINT_MAX, \"mipi-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK_BIAS, 4, 0x74, 0x78, UINT_MAX, \"pex-clk-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK3, 5, 0x74, 0x78, UINT_MAX, \"pex-clk3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK2, 6, 0x74, 0x78, UINT_MAX, \"pex-clk2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK1, 7, 0x74, 0x78, UINT_MAX, \"pex-clk1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EQOS, 8, 0x74, 0x78, UINT_MAX, \"eqos\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK_2_BIAS, 9, 0x74, 0x78, UINT_MAX, \"pex-clk-2-bias\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CLK_2, 10, 0x74, 0x78, UINT_MAX, \"pex-clk-2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DAP3, 11, 0x74, 0x78, UINT_MAX, \"dap3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DAP5, 12, 0x74, 0x78, UINT_MAX, \"dap5\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART, 14, 0x74, 0x78, UINT_MAX, \"uart\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PWR_CTL, 15, 0x74, 0x78, UINT_MAX, \"pwr-ctl\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SOC_GPIO53, 16, 0x74, 0x78, UINT_MAX, \"soc-gpio53\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO, 17, 0x74, 0x78, UINT_MAX, \"audio\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_GP_PWM2, 18, 0x74, 0x78, UINT_MAX, \"gp-pwm2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_GP_PWM3, 19, 0x74, 0x78, UINT_MAX, \"gp-pwm3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SOC_GPIO12, 20, 0x74, 0x78, UINT_MAX, \"soc-gpio12\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SOC_GPIO13, 21, 0x74, 0x78, UINT_MAX, \"soc-gpio13\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SOC_GPIO10, 22, 0x74, 0x78, UINT_MAX, \"soc-gpio10\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART4, 23, 0x74, 0x78, UINT_MAX, \"uart4\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UART5, 24, 0x74, 0x78, UINT_MAX, \"uart5\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_DBG, 25, 0x74, 0x78, UINT_MAX, \"dbg\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP3, 26, 0x74, 0x78, UINT_MAX, \"hdmi-dp3\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP2, 27, 0x74, 0x78, UINT_MAX, \"hdmi-dp2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP0, 28, 0x74, 0x78, UINT_MAX, \"hdmi-dp0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP1, 29, 0x74, 0x78, UINT_MAX, \"hdmi-dp1\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CNTRL, 0, 0x7c, 0x80, UINT_MAX, \"pex-cntrl\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_CTL2, 1, 0x7c, 0x80, UINT_MAX, \"pex-ctl2\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_L0_RST, 2, 0x7c, 0x80, UINT_MAX, \"pex-l0-rst\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_L1_RST, 3, 0x7c, 0x80, UINT_MAX, \"pex-l1-rst\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC4, 4, 0x7c, 0x80, UINT_MAX, \"sdmmc4\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_PEX_L5_RST, 5, 0x7c, 0x80, UINT_MAX, \"pex-l5-rst\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CAM, 6, 0x7c, 0x80, UINT_MAX, \"cam\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIC, 11, 0x7c, 0x80, UINT_MAX, \"csic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSID, 12, 0x7c, 0x80, UINT_MAX, \"csid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIE, 13, 0x7c, 0x80, UINT_MAX, \"csie\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIF, 14, 0x7c, 0x80, UINT_MAX, \"csif\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SPI, 15, 0x7c, 0x80, UINT_MAX, \"spi\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UFS, 17, 0x7c, 0x80, UINT_MAX, \"ufs\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIG, 18, 0x7c, 0x80, UINT_MAX, \"csig\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIH, 19, 0x7c, 0x80, UINT_MAX, \"csih\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EDP, 21, 0x7c, 0x80, UINT_MAX, \"edp\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC1_HV, 23, 0x7c, 0x80, 4, \"sdmmc1-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC3_HV, 24, 0x7c, 0x80, 6, \"sdmmc3-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CONN, 28, 0x7c, 0x80, UINT_MAX, \"conn\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO_HV, 29, 0x7c, 0x80, 1, \"audio-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AO_HV, UINT_MAX, UINT_MAX, UINT_MAX, 0, \"ao-hv\"),\n};\n\nstatic const struct pinctrl_pin_desc tegra194_pin_descs[] = {\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIA, \"csia\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIB, \"csib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_MIPI_BIAS, \"mipi-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK_BIAS, \"pex-clk-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK3, \"pex-clk3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK2, \"pex-clk2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK1, \"pex-clk1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EQOS, \"eqos\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK_2_BIAS, \"pex-clk-2-bias\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CLK_2, \"pex-clk-2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DAP3, \"dap3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DAP5, \"dap5\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART, \"uart\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PWR_CTL, \"pwr-ctl\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SOC_GPIO53, \"soc-gpio53\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO, \"audio\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_GP_PWM2, \"gp-pwm2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_GP_PWM3, \"gp-pwm3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SOC_GPIO12, \"soc-gpio12\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SOC_GPIO13, \"soc-gpio13\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SOC_GPIO10, \"soc-gpio10\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART4, \"uart4\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UART5, \"uart5\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_DBG, \"dbg\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP3, \"hdmi-dp3\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP2, \"hdmi-dp2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP0, \"hdmi-dp0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP1, \"hdmi-dp1\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CNTRL, \"pex-cntrl\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_CTL2, \"pex-ctl2\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_L0_RST, \"pex-l0-rst\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_L1_RST, \"pex-l1-rst\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC4, \"sdmmc4\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_PEX_L5_RST, \"pex-l5-rst\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CAM, \"cam\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIC, \"csic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSID, \"csid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIE, \"csie\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIF, \"csif\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SPI, \"spi\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UFS, \"ufs\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIG, \"csig\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIH, \"csih\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EDP, \"edp\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC1_HV, \"sdmmc1-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC3_HV, \"sdmmc3-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CONN, \"conn\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO_HV, \"audio-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AO_HV, \"ao-hv\"),\n};\n\nstatic const struct tegra_pmc_regs tegra194_pmc_regs = {\n\t.scratch0 = 0x2000,\n\t.rst_status = 0x70,\n\t.rst_source_shift = 0x2,\n\t.rst_source_mask = 0x7c,\n\t.rst_level_shift = 0x0,\n\t.rst_level_mask = 0x3,\n};\n\nstatic const char * const tegra194_reset_sources[] = {\n\t\"SYS_RESET_N\",\n\t\"AOWDT\",\n\t\"BCCPLEXWDT\",\n\t\"BPMPWDT\",\n\t\"SCEWDT\",\n\t\"SPEWDT\",\n\t\"APEWDT\",\n\t\"LCCPLEXWDT\",\n\t\"SENSOR\",\n\t\"AOTAG\",\n\t\"VFSENSOR\",\n\t\"MAINSWRST\",\n\t\"SC7\",\n\t\"HSM\",\n\t\"CSITE\",\n\t\"RCEWDT\",\n\t\"PVA0WDT\",\n\t\"PVA1WDT\",\n\t\"L1A_ASYNC\",\n\t\"BPMPBOOT\",\n\t\"FUSECRC\",\n};\n\nstatic const struct tegra_wake_event tegra194_wake_events[] = {\n\tTEGRA_WAKE_IRQ(\"pmu\", 24, 209),\n\tTEGRA_WAKE_GPIO(\"power\", 29, 1, TEGRA194_AON_GPIO(EE, 4)),\n\tTEGRA_WAKE_IRQ(\"rtc\", 73, 10),\n\tTEGRA_WAKE_SIMPLE(\"usb3-port-0\", 76),\n\tTEGRA_WAKE_SIMPLE(\"usb3-port-1\", 77),\n\tTEGRA_WAKE_SIMPLE(\"usb3-port-2-3\", 78),\n\tTEGRA_WAKE_SIMPLE(\"usb2-port-0\", 79),\n\tTEGRA_WAKE_SIMPLE(\"usb2-port-1\", 80),\n\tTEGRA_WAKE_SIMPLE(\"usb2-port-2\", 81),\n\tTEGRA_WAKE_SIMPLE(\"usb2-port-3\", 82),\n};\n\nstatic const struct tegra_pmc_soc tegra194_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = 0,\n\t.powergates = NULL,\n\t.num_cpu_powergates = 0,\n\t.cpu_powergates = NULL,\n\t.has_tsense_reset = false,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = true,\n\t.maybe_tz_only = false,\n\t.num_io_pads = ARRAY_SIZE(tegra194_io_pads),\n\t.io_pads = tegra194_io_pads,\n\t.num_pin_descs = ARRAY_SIZE(tegra194_pin_descs),\n\t.pin_descs = tegra194_pin_descs,\n\t.regs = &tegra194_pmc_regs,\n\t.init = tegra186_pmc_init,\n\t.setup_irq_polarity = tegra186_pmc_setup_irq_polarity,\n\t.set_wake_filters = tegra186_pmc_set_wake_filters,\n\t.irq_set_wake = tegra186_pmc_irq_set_wake,\n\t.irq_set_type = tegra186_pmc_irq_set_type,\n\t.reset_sources = tegra194_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra194_reset_sources),\n\t.reset_levels = tegra186_reset_levels,\n\t.num_reset_levels = ARRAY_SIZE(tegra186_reset_levels),\n\t.num_wake_events = ARRAY_SIZE(tegra194_wake_events),\n\t.wake_events = tegra194_wake_events,\n\t.max_wake_events = 96,\n\t.max_wake_vectors = 3,\n\t.pmc_clks_data = NULL,\n\t.num_pmc_clks = 0,\n\t.has_blink_output = false,\n\t.has_usb_sleepwalk = false,\n};\n\nstatic const struct tegra_io_pad_soc tegra234_io_pads[] = {\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIA, 0, 0xe0c0, 0xe0c4, UINT_MAX, \"csia\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIB, 1, 0xe0c0, 0xe0c4, UINT_MAX, \"csib\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_HDMI_DP0, 0, 0xe0d0, 0xe0d4, UINT_MAX, \"hdmi-dp0\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIC, 2, 0xe0c0, 0xe0c4, UINT_MAX, \"csic\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSID, 3, 0xe0c0, 0xe0c4, UINT_MAX, \"csid\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIE, 4, 0xe0c0, 0xe0c4, UINT_MAX, \"csie\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIF, 5, 0xe0c0, 0xe0c4, UINT_MAX, \"csif\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_UFS, 0, 0xe064, 0xe068, UINT_MAX, \"ufs\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_EDP, 1, 0xe05c, 0xe060, UINT_MAX, \"edp\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC1_HV, 0, 0xe054, 0xe058, 4, \"sdmmc1-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_SDMMC3_HV, UINT_MAX, UINT_MAX, UINT_MAX, 6, \"sdmmc3-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AUDIO_HV, UINT_MAX, UINT_MAX, UINT_MAX, 1, \"audio-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_AO_HV, UINT_MAX, UINT_MAX, UINT_MAX, 0, \"ao-hv\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIG, 6, 0xe0c0, 0xe0c4, UINT_MAX, \"csig\"),\n\tTEGRA_IO_PAD(TEGRA_IO_PAD_CSIH, 7, 0xe0c0, 0xe0c4, UINT_MAX, \"csih\"),\n};\n\nstatic const struct pinctrl_pin_desc tegra234_pin_descs[] = {\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIA, \"csia\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIB, \"csib\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_HDMI_DP0, \"hdmi-dp0\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIC, \"csic\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSID, \"csid\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIE, \"csie\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIF, \"csif\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_UFS, \"ufs\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_EDP, \"edp\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC1_HV, \"sdmmc1-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_SDMMC3_HV, \"sdmmc3-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AUDIO_HV, \"audio-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_AO_HV, \"ao-hv\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIG, \"csig\"),\n\tTEGRA_IO_PIN_DESC(TEGRA_IO_PAD_CSIH, \"csih\"),\n};\n\nstatic const struct tegra_pmc_regs tegra234_pmc_regs = {\n\t.scratch0 = 0x2000,\n\t.rst_status = 0x70,\n\t.rst_source_shift = 0x2,\n\t.rst_source_mask = 0xfc,\n\t.rst_level_shift = 0x0,\n\t.rst_level_mask = 0x3,\n};\n\nstatic const char * const tegra234_reset_sources[] = {\n\t\"SYS_RESET_N\",\t \n\t\"AOWDT\",\n\t\"BCCPLEXWDT\",\n\t\"BPMPWDT\",\n\t\"SCEWDT\",\n\t\"SPEWDT\",\n\t\"APEWDT\",\n\t\"LCCPLEXWDT\",\n\t\"SENSOR\",\t \n\tNULL,\n\tNULL,\n\t\"MAINSWRST\",\n\t\"SC7\",\n\t\"HSM\",\n\tNULL,\n\t\"RCEWDT\",\n\tNULL,\t\t \n\tNULL,\n\tNULL,\n\t\"BPMPBOOT\",\n\t\"FUSECRC\",\n\t\"DCEWDT\",\n\t\"PSCWDT\",\n\t\"PSC\",\n\t\"CSITE_SW\",\t \n\t\"POD\",\n\t\"SCPM\",\n\t\"VREFRO_POWERBAD\",\n\t\"VMON\",\n\t\"FMON\",\n\t\"FSI_R5WDT\",\n\t\"FSI_THERM\",\n\t\"FSI_R52C0WDT\",\t \n\t\"FSI_R52C1WDT\",\n\t\"FSI_R52C2WDT\",\n\t\"FSI_R52C3WDT\",\n\t\"FSI_FMON\",\n\t\"FSI_VMON\",\t \n};\n\nstatic const struct tegra_wake_event tegra234_wake_events[] = {\n\tTEGRA_WAKE_IRQ(\"pmu\", 24, 209),\n\tTEGRA_WAKE_GPIO(\"power\", 29, 1, TEGRA234_AON_GPIO(EE, 4)),\n\tTEGRA_WAKE_GPIO(\"mgbe\", 56, 0, TEGRA234_MAIN_GPIO(Y, 3)),\n\tTEGRA_WAKE_IRQ(\"rtc\", 73, 10),\n\tTEGRA_WAKE_IRQ(\"sw-wake\", SW_WAKE_ID, 179),\n};\n\nstatic const struct tegra_pmc_soc tegra234_pmc_soc = {\n\t.supports_core_domain = false,\n\t.num_powergates = 0,\n\t.powergates = NULL,\n\t.num_cpu_powergates = 0,\n\t.cpu_powergates = NULL,\n\t.has_tsense_reset = false,\n\t.has_gpu_clamps = false,\n\t.needs_mbist_war = false,\n\t.has_impl_33v_pwr = true,\n\t.maybe_tz_only = false,\n\t.num_io_pads = ARRAY_SIZE(tegra234_io_pads),\n\t.io_pads = tegra234_io_pads,\n\t.num_pin_descs = ARRAY_SIZE(tegra234_pin_descs),\n\t.pin_descs = tegra234_pin_descs,\n\t.regs = &tegra234_pmc_regs,\n\t.init = tegra186_pmc_init,\n\t.setup_irq_polarity = tegra186_pmc_setup_irq_polarity,\n\t.set_wake_filters = tegra186_pmc_set_wake_filters,\n\t.irq_set_wake = tegra186_pmc_irq_set_wake,\n\t.irq_set_type = tegra186_pmc_irq_set_type,\n\t.reset_sources = tegra234_reset_sources,\n\t.num_reset_sources = ARRAY_SIZE(tegra234_reset_sources),\n\t.reset_levels = tegra186_reset_levels,\n\t.num_reset_levels = ARRAY_SIZE(tegra186_reset_levels),\n\t.num_wake_events = ARRAY_SIZE(tegra234_wake_events),\n\t.wake_events = tegra234_wake_events,\n\t.max_wake_events = 96,\n\t.max_wake_vectors = 3,\n\t.pmc_clks_data = NULL,\n\t.num_pmc_clks = 0,\n\t.has_blink_output = false,\n};\n\nstatic const struct of_device_id tegra_pmc_match[] = {\n\t{ .compatible = \"nvidia,tegra234-pmc\", .data = &tegra234_pmc_soc },\n\t{ .compatible = \"nvidia,tegra194-pmc\", .data = &tegra194_pmc_soc },\n\t{ .compatible = \"nvidia,tegra186-pmc\", .data = &tegra186_pmc_soc },\n\t{ .compatible = \"nvidia,tegra210-pmc\", .data = &tegra210_pmc_soc },\n\t{ .compatible = \"nvidia,tegra132-pmc\", .data = &tegra124_pmc_soc },\n\t{ .compatible = \"nvidia,tegra124-pmc\", .data = &tegra124_pmc_soc },\n\t{ .compatible = \"nvidia,tegra114-pmc\", .data = &tegra114_pmc_soc },\n\t{ .compatible = \"nvidia,tegra30-pmc\", .data = &tegra30_pmc_soc },\n\t{ .compatible = \"nvidia,tegra20-pmc\", .data = &tegra20_pmc_soc },\n\t{ }\n};\n\nstatic void tegra_pmc_sync_state(struct device *dev)\n{\n\tint err;\n\n\t \n\tif (!pmc->soc->supports_core_domain)\n\t\treturn;\n\n\t \n\tif (!pmc->core_domain_registered)\n\t\treturn;\n\n\tpmc->core_domain_state_synced = true;\n\n\t \n\tmutex_lock(&pmc->powergates_lock);\n\terr = dev_pm_opp_sync_regulators(dev);\n\tmutex_unlock(&pmc->powergates_lock);\n\n\tif (err)\n\t\tdev_err(dev, \"failed to sync regulators: %d\\n\", err);\n}\n\nstatic struct platform_driver tegra_pmc_driver = {\n\t.driver = {\n\t\t.name = \"tegra-pmc\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = tegra_pmc_match,\n#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_ARM)\n\t\t.pm = &tegra_pmc_pm_ops,\n#endif\n\t\t.sync_state = tegra_pmc_sync_state,\n\t},\n\t.probe = tegra_pmc_probe,\n};\nbuiltin_platform_driver(tegra_pmc_driver);\n\nstatic bool __init tegra_pmc_detect_tz_only(struct tegra_pmc *pmc)\n{\n\tu32 value, saved;\n\n\tsaved = readl(pmc->base + pmc->soc->regs->scratch0);\n\tvalue = saved ^ 0xffffffff;\n\n\tif (value == 0xffffffff)\n\t\tvalue = 0xdeadbeef;\n\n\t \n\twritel(value, pmc->base + pmc->soc->regs->scratch0);\n\tvalue = readl(pmc->base + pmc->soc->regs->scratch0);\n\n\t \n\tif (value == 0) {\n\t\tpr_info(\"access to PMC is restricted to TZ\\n\");\n\t\treturn true;\n\t}\n\n\t \n\twritel(saved, pmc->base + pmc->soc->regs->scratch0);\n\n\treturn false;\n}\n\n \nstatic int __init tegra_pmc_early_init(void)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *np;\n\tstruct resource regs;\n\tunsigned int i;\n\tbool invert;\n\n\tmutex_init(&pmc->powergates_lock);\n\n\tnp = of_find_matching_node_and_match(NULL, tegra_pmc_match, &match);\n\tif (!np) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_ARM) && soc_is_tegra()) {\n\t\t\tpr_warn(\"DT node not found, powergating disabled\\n\");\n\n\t\t\tregs.start = 0x7000e400;\n\t\t\tregs.end = 0x7000e7ff;\n\t\t\tregs.flags = IORESOURCE_MEM;\n\n\t\t\tpr_warn(\"Using memory region %pR\\n\", &regs);\n\t\t} else {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (of_address_to_resource(np, 0, &regs) < 0) {\n\t\t\tpr_err(\"failed to get PMC registers\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tpmc->base = ioremap(regs.start, resource_size(&regs));\n\tif (!pmc->base) {\n\t\tpr_err(\"failed to map PMC registers\\n\");\n\t\tof_node_put(np);\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_device_is_available(np)) {\n\t\tpmc->soc = match->data;\n\n\t\tif (pmc->soc->maybe_tz_only)\n\t\t\tpmc->tz_only = tegra_pmc_detect_tz_only(pmc);\n\n\t\t \n\t\tfor (i = 0; i < pmc->soc->num_powergates; i++)\n\t\t\tif (pmc->soc->powergates[i])\n\t\t\t\tset_bit(i, pmc->powergates_available);\n\n\t\t \n\t\tinvert = of_property_read_bool(np, \"nvidia,invert-interrupt\");\n\n\t\tpmc->soc->setup_irq_polarity(pmc, np, invert);\n\n\t\tof_node_put(np);\n\t}\n\n\treturn 0;\n}\nearly_initcall(tegra_pmc_early_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}