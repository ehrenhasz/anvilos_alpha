{
  "module_name": "meson-canvas.c",
  "hash_id": "9d753be1a08c8b600008bf2cd9670f786ae008e04a25341e523da353f964d878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/amlogic/meson-canvas.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/soc/amlogic/meson-canvas.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/io.h>\n\n#define NUM_CANVAS 256\n\n \n#define DMC_CAV_LUT_DATAL\t0x00\n\t#define CANVAS_WIDTH_LBIT\t29\n\t#define CANVAS_WIDTH_LWID\t3\n#define DMC_CAV_LUT_DATAH\t0x04\n\t#define CANVAS_WIDTH_HBIT\t0\n\t#define CANVAS_HEIGHT_BIT\t9\n\t#define CANVAS_WRAP_BIT\t\t22\n\t#define CANVAS_BLKMODE_BIT\t24\n\t#define CANVAS_ENDIAN_BIT\t26\n#define DMC_CAV_LUT_ADDR\t0x08\n\t#define CANVAS_LUT_WR_EN\tBIT(9)\n\t#define CANVAS_LUT_RD_EN\tBIT(8)\n\nstruct meson_canvas {\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tspinlock_t lock;  \n\tu8 used[NUM_CANVAS];\n\tbool supports_endianness;\n};\n\nstatic void canvas_write(struct meson_canvas *canvas, u32 reg, u32 val)\n{\n\twritel_relaxed(val, canvas->reg_base + reg);\n}\n\nstatic u32 canvas_read(struct meson_canvas *canvas, u32 reg)\n{\n\treturn readl_relaxed(canvas->reg_base + reg);\n}\n\nstruct meson_canvas *meson_canvas_get(struct device *dev)\n{\n\tstruct device_node *canvas_node;\n\tstruct platform_device *canvas_pdev;\n\tstruct meson_canvas *canvas;\n\n\tcanvas_node = of_parse_phandle(dev->of_node, \"amlogic,canvas\", 0);\n\tif (!canvas_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcanvas_pdev = of_find_device_by_node(canvas_node);\n\tif (!canvas_pdev) {\n\t\tof_node_put(canvas_node);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tof_node_put(canvas_node);\n\n\t \n\tcanvas = dev_get_drvdata(&canvas_pdev->dev);\n\tif (!canvas) {\n\t\tput_device(&canvas_pdev->dev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn canvas;\n}\nEXPORT_SYMBOL_GPL(meson_canvas_get);\n\nint meson_canvas_config(struct meson_canvas *canvas, u8 canvas_index,\n\t\t\tu32 addr, u32 stride, u32 height,\n\t\t\tunsigned int wrap,\n\t\t\tunsigned int blkmode,\n\t\t\tunsigned int endian)\n{\n\tunsigned long flags;\n\n\tif (endian && !canvas->supports_endianness) {\n\t\tdev_err(canvas->dev,\n\t\t\t\"Endianness is not supported on this SoC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&canvas->lock, flags);\n\tif (!canvas->used[canvas_index]) {\n\t\tdev_err(canvas->dev,\n\t\t\t\"Trying to setup non allocated canvas %u\\n\",\n\t\t\tcanvas_index);\n\t\tspin_unlock_irqrestore(&canvas->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tcanvas_write(canvas, DMC_CAV_LUT_DATAL,\n\t\t     ((addr + 7) >> 3) |\n\t\t     (((stride + 7) >> 3) << CANVAS_WIDTH_LBIT));\n\n\tcanvas_write(canvas, DMC_CAV_LUT_DATAH,\n\t\t     ((((stride + 7) >> 3) >> CANVAS_WIDTH_LWID) <<\n\t\t\t\t\t\tCANVAS_WIDTH_HBIT) |\n\t\t     (height << CANVAS_HEIGHT_BIT) |\n\t\t     (wrap << CANVAS_WRAP_BIT) |\n\t\t     (blkmode << CANVAS_BLKMODE_BIT) |\n\t\t     (endian << CANVAS_ENDIAN_BIT));\n\n\tcanvas_write(canvas, DMC_CAV_LUT_ADDR,\n\t\t     CANVAS_LUT_WR_EN | canvas_index);\n\n\t \n\tcanvas_read(canvas, DMC_CAV_LUT_DATAH);\n\tspin_unlock_irqrestore(&canvas->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_canvas_config);\n\nint meson_canvas_alloc(struct meson_canvas *canvas, u8 *canvas_index)\n{\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&canvas->lock, flags);\n\tfor (i = 0; i < NUM_CANVAS; ++i) {\n\t\tif (!canvas->used[i]) {\n\t\t\tcanvas->used[i] = 1;\n\t\t\tspin_unlock_irqrestore(&canvas->lock, flags);\n\t\t\t*canvas_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&canvas->lock, flags);\n\n\tdev_err(canvas->dev, \"No more canvas available\\n\");\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(meson_canvas_alloc);\n\nint meson_canvas_free(struct meson_canvas *canvas, u8 canvas_index)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&canvas->lock, flags);\n\tif (!canvas->used[canvas_index]) {\n\t\tdev_err(canvas->dev,\n\t\t\t\"Trying to free unused canvas %u\\n\", canvas_index);\n\t\tspin_unlock_irqrestore(&canvas->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tcanvas->used[canvas_index] = 0;\n\tspin_unlock_irqrestore(&canvas->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_canvas_free);\n\nstatic int meson_canvas_probe(struct platform_device *pdev)\n{\n\tstruct meson_canvas *canvas;\n\tstruct device *dev = &pdev->dev;\n\n\tcanvas = devm_kzalloc(dev, sizeof(*canvas), GFP_KERNEL);\n\tif (!canvas)\n\t\treturn -ENOMEM;\n\n\tcanvas->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(canvas->reg_base))\n\t\treturn PTR_ERR(canvas->reg_base);\n\n\tcanvas->supports_endianness = of_device_get_match_data(dev);\n\n\tcanvas->dev = dev;\n\tspin_lock_init(&canvas->lock);\n\tdev_set_drvdata(dev, canvas);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id canvas_dt_match[] = {\n\t{ .compatible = \"amlogic,meson8-canvas\", .data = (void *)false, },\n\t{ .compatible = \"amlogic,meson8b-canvas\", .data = (void *)false, },\n\t{ .compatible = \"amlogic,meson8m2-canvas\", .data = (void *)false, },\n\t{ .compatible = \"amlogic,canvas\", .data = (void *)true, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, canvas_dt_match);\n\nstatic struct platform_driver meson_canvas_driver = {\n\t.probe = meson_canvas_probe,\n\t.driver = {\n\t\t.name = \"amlogic-canvas\",\n\t\t.of_match_table = canvas_dt_match,\n\t},\n};\nmodule_platform_driver(meson_canvas_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Canvas driver\");\nMODULE_AUTHOR(\"Maxime Jourdan <mjourdan@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}