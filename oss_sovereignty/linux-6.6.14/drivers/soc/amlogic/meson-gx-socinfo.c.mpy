{
  "module_name": "meson-gx-socinfo.c",
  "hash_id": "9c1212b5044bb105ca2befb9354f0d9221795a7da1baa854050389f7fad89708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/amlogic/meson-gx-socinfo.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#define AO_SEC_SD_CFG8\t\t0xe0\n#define AO_SEC_SOCINFO_OFFSET\tAO_SEC_SD_CFG8\n\n#define SOCINFO_MAJOR\tGENMASK(31, 24)\n#define SOCINFO_PACK\tGENMASK(23, 16)\n#define SOCINFO_MINOR\tGENMASK(15, 8)\n#define SOCINFO_MISC\tGENMASK(7, 0)\n\nstatic const struct meson_gx_soc_id {\n\tconst char *name;\n\tunsigned int id;\n} soc_ids[] = {\n\t{ \"GXBB\", 0x1f },\n\t{ \"GXTVBB\", 0x20 },\n\t{ \"GXL\", 0x21 },\n\t{ \"GXM\", 0x22 },\n\t{ \"TXL\", 0x23 },\n\t{ \"TXLX\", 0x24 },\n\t{ \"AXG\", 0x25 },\n\t{ \"GXLX\", 0x26 },\n\t{ \"TXHD\", 0x27 },\n\t{ \"G12A\", 0x28 },\n\t{ \"G12B\", 0x29 },\n\t{ \"SM1\", 0x2b },\n\t{ \"A1\", 0x2c },\n};\n\nstatic const struct meson_gx_package_id {\n\tconst char *name;\n\tunsigned int major_id;\n\tunsigned int pack_id;\n\tunsigned int pack_mask;\n} soc_packages[] = {\n\t{ \"S905\", 0x1f, 0, 0x20 },  \n\t{ \"S905H\", 0x1f, 0x3, 0xf },  \n\t{ \"S905M\", 0x1f, 0x20, 0xf0 },  \n\t{ \"S905D\", 0x21, 0, 0xf0 },\n\t{ \"S905X\", 0x21, 0x80, 0xf0 },\n\t{ \"S905W\", 0x21, 0xa0, 0xf0 },\n\t{ \"S905L\", 0x21, 0xc0, 0xf0 },\n\t{ \"S905M2\", 0x21, 0xe0, 0xf0 },\n\t{ \"S805X\", 0x21, 0x30, 0xf0 },\n\t{ \"S805Y\", 0x21, 0xb0, 0xf0 },\n\t{ \"S912\", 0x22, 0, 0x0 },  \n\t{ \"962X\", 0x24, 0x10, 0xf0 },\n\t{ \"962E\", 0x24, 0x20, 0xf0 },\n\t{ \"A113X\", 0x25, 0x37, 0xff },\n\t{ \"A113D\", 0x25, 0x22, 0xff },\n\t{ \"S905D2\", 0x28, 0x10, 0xf0 },\n\t{ \"S905Y2\", 0x28, 0x30, 0xf0 },\n\t{ \"S905X2\", 0x28, 0x40, 0xf0 },\n\t{ \"A311D\", 0x29, 0x10, 0xf0 },\n\t{ \"S922X\", 0x29, 0x40, 0xf0 },\n\t{ \"S905D3\", 0x2b, 0x4, 0xf5 },\n\t{ \"S905X3\", 0x2b, 0x5, 0xf5 },\n\t{ \"S905X3\", 0x2b, 0x10, 0x3f },\n\t{ \"S905D3\", 0x2b, 0x30, 0x3f },\n\t{ \"A113L\", 0x2c, 0x0, 0xf8 },\n};\n\nstatic inline unsigned int socinfo_to_major(u32 socinfo)\n{\n\treturn FIELD_GET(SOCINFO_MAJOR, socinfo);\n}\n\nstatic inline unsigned int socinfo_to_minor(u32 socinfo)\n{\n\treturn FIELD_GET(SOCINFO_MINOR, socinfo);\n}\n\nstatic inline unsigned int socinfo_to_pack(u32 socinfo)\n{\n\treturn FIELD_GET(SOCINFO_PACK, socinfo);\n}\n\nstatic inline unsigned int socinfo_to_misc(u32 socinfo)\n{\n\treturn FIELD_GET(SOCINFO_MISC, socinfo);\n}\n\nstatic const char *socinfo_to_package_id(u32 socinfo)\n{\n\tunsigned int pack = socinfo_to_pack(socinfo);\n\tunsigned int major = socinfo_to_major(socinfo);\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(soc_packages) ; ++i) {\n\t\tif (soc_packages[i].major_id == major &&\n\t\t    soc_packages[i].pack_id ==\n\t\t\t\t(pack & soc_packages[i].pack_mask))\n\t\t\treturn soc_packages[i].name;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic const char *socinfo_to_soc_id(u32 socinfo)\n{\n\tunsigned int id = socinfo_to_major(socinfo);\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(soc_ids) ; ++i) {\n\t\tif (soc_ids[i].id == id)\n\t\t\treturn soc_ids[i].name;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic int __init meson_gx_socinfo_init(void)\n{\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct soc_device *soc_dev;\n\tstruct device_node *np;\n\tstruct regmap *regmap;\n\tunsigned int socinfo;\n\tstruct device *dev;\n\tint ret;\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"amlogic,meson-gx-ao-secure\");\n\tif (!np)\n\t\treturn -ENODEV;\n\n\t \n\tif (!of_device_is_available(np)) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!of_property_read_bool(np, \"amlogic,has-chip-id\")) {\n\t\tof_node_put(np);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tregmap = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"%s: failed to get regmap\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(regmap, AO_SEC_SOCINFO_OFFSET, &socinfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!socinfo) {\n\t\tpr_err(\"%s: invalid chipid value\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENODEV;\n\n\tsoc_dev_attr->family = \"Amlogic Meson\";\n\tsoc_dev_attr->revision = kasprintf(GFP_KERNEL, \"%x:%x - %x:%x\",\n\t\t\t\t\t   socinfo_to_major(socinfo),\n\t\t\t\t\t   socinfo_to_minor(socinfo),\n\t\t\t\t\t   socinfo_to_pack(socinfo),\n\t\t\t\t\t   socinfo_to_misc(socinfo));\n\tsoc_dev_attr->soc_id = kasprintf(GFP_KERNEL, \"%s (%s)\",\n\t\t\t\t\t socinfo_to_soc_id(socinfo),\n\t\t\t\t\t socinfo_to_package_id(socinfo));\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev)) {\n\t\tkfree(soc_dev_attr->revision);\n\t\tkfree_const(soc_dev_attr->soc_id);\n\t\tkfree(soc_dev_attr);\n\t\treturn PTR_ERR(soc_dev);\n\t}\n\tdev = soc_device_to_device(soc_dev);\n\n\tdev_info(dev, \"Amlogic Meson %s Revision %x:%x (%x:%x) Detected\\n\",\n\t\t\tsoc_dev_attr->soc_id,\n\t\t\tsocinfo_to_major(socinfo),\n\t\t\tsocinfo_to_minor(socinfo),\n\t\t\tsocinfo_to_pack(socinfo),\n\t\t\tsocinfo_to_misc(socinfo));\n\n\treturn 0;\n}\ndevice_initcall(meson_gx_socinfo_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}