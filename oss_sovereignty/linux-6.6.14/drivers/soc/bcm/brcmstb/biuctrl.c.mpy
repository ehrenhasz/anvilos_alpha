{
  "module_name": "biuctrl.c",
  "hash_id": "c1bf3a158095bca8f1002dcd0c8d262b9499bde9b1b2a4923266316312550cda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/bcm/brcmstb/biuctrl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"brcmstb: \" KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/syscore_ops.h>\n#include <linux/soc/brcmstb/brcmstb.h>\n\n#define RACENPREF_MASK\t\t\t0x3\n#define RACPREFINST_SHIFT\t\t0\n#define RACENINST_SHIFT\t\t\t2\n#define RACPREFDATA_SHIFT\t\t4\n#define RACENDATA_SHIFT\t\t\t6\n#define RAC_CPU_SHIFT\t\t\t8\n#define RACCFG_MASK\t\t\t0xff\n#define DPREF_LINE_2_SHIFT\t\t24\n#define DPREF_LINE_2_MASK\t\t0xff\n\n \n#define RAC_DATA_INST_EN_MASK\t\t(1 << RACPREFINST_SHIFT | \\\n\t\t\t\t\t RACENPREF_MASK << RACENINST_SHIFT | \\\n\t\t\t\t\t 1 << RACPREFDATA_SHIFT | \\\n\t\t\t\t\t RACENPREF_MASK << RACENDATA_SHIFT)\n\n#define  CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK\t0x70000000\n#define CPU_CREDIT_REG_MCPx_READ_CRED_MASK\t0xf\n#define CPU_CREDIT_REG_MCPx_WRITE_CRED_MASK\t0xf\n#define CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(x)\t((x) * 8)\n#define CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(x)\t(((x) * 8) + 4)\n\n#define CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_SHIFT(x)\t((x) * 8)\n#define CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_MASK\t\t0xff\n\n#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_THRESHOLD_MASK\t0xf\n#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_MASK\t\t0xf\n#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT\t4\n#define CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_ENABLE\t\tBIT(8)\n\nstatic void __iomem *cpubiuctrl_base;\nstatic bool mcp_wr_pairing_en;\nstatic const int *cpubiuctrl_regs;\n\nenum cpubiuctrl_regs {\n\tCPU_CREDIT_REG = 0,\n\tCPU_MCP_FLOW_REG,\n\tCPU_WRITEBACK_CTRL_REG,\n\tRAC_CONFIG0_REG,\n\tRAC_CONFIG1_REG,\n\tNUM_CPU_BIUCTRL_REGS,\n};\n\nstatic inline u32 cbc_readl(int reg)\n{\n\tint offset = cpubiuctrl_regs[reg];\n\n\tif (offset == -1 ||\n\t    (IS_ENABLED(CONFIG_CACHE_B15_RAC) && reg >= RAC_CONFIG0_REG))\n\t\treturn (u32)-1;\n\n\treturn readl_relaxed(cpubiuctrl_base + offset);\n}\n\nstatic inline void cbc_writel(u32 val, int reg)\n{\n\tint offset = cpubiuctrl_regs[reg];\n\n\tif (offset == -1 ||\n\t    (IS_ENABLED(CONFIG_CACHE_B15_RAC) && reg >= RAC_CONFIG0_REG))\n\t\treturn;\n\n\twritel(val, cpubiuctrl_base + offset);\n}\n\nstatic const int b15_cpubiuctrl_regs[] = {\n\t[CPU_CREDIT_REG] = 0x184,\n\t[CPU_MCP_FLOW_REG] = -1,\n\t[CPU_WRITEBACK_CTRL_REG] = -1,\n\t[RAC_CONFIG0_REG] = -1,\n\t[RAC_CONFIG1_REG] = -1,\n};\n\n \nstatic const int b53_cpubiuctrl_no_wb_regs[] = {\n\t[CPU_CREDIT_REG] = 0x0b0,\n\t[CPU_MCP_FLOW_REG] = 0x0b4,\n\t[CPU_WRITEBACK_CTRL_REG] = -1,\n\t[RAC_CONFIG0_REG] = 0x78,\n\t[RAC_CONFIG1_REG] = 0x7c,\n};\n\nstatic const int b53_cpubiuctrl_regs[] = {\n\t[CPU_CREDIT_REG] = 0x0b0,\n\t[CPU_MCP_FLOW_REG] = 0x0b4,\n\t[CPU_WRITEBACK_CTRL_REG] = 0x22c,\n\t[RAC_CONFIG0_REG] = 0x78,\n\t[RAC_CONFIG1_REG] = 0x7c,\n};\n\nstatic const int a72_cpubiuctrl_regs[] = {\n\t[CPU_CREDIT_REG] = 0x18,\n\t[CPU_MCP_FLOW_REG] = 0x1c,\n\t[CPU_WRITEBACK_CTRL_REG] = 0x20,\n\t[RAC_CONFIG0_REG] = 0x08,\n\t[RAC_CONFIG1_REG] = 0x0c,\n};\n\nstatic int __init mcp_write_pairing_set(void)\n{\n\tu32 creds = 0;\n\n\tif (!cpubiuctrl_base)\n\t\treturn -1;\n\n\tcreds = cbc_readl(CPU_CREDIT_REG);\n\tif (mcp_wr_pairing_en) {\n\t\tpr_info(\"MCP: Enabling write pairing\\n\");\n\t\tcbc_writel(creds | CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,\n\t\t\t   CPU_CREDIT_REG);\n\t} else if (creds & CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK) {\n\t\tpr_info(\"MCP: Disabling write pairing\\n\");\n\t\tcbc_writel(creds & ~CPU_CREDIT_REG_MCPx_WR_PAIRING_EN_MASK,\n\t\t\t   CPU_CREDIT_REG);\n\t} else {\n\t\tpr_info(\"MCP: Write pairing already disabled\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const u32 a72_b53_mach_compat[] = {\n\t0x7211,\n\t0x72113,\n\t0x72116,\n\t0x7216,\n\t0x72164,\n\t0x72165,\n\t0x7255,\n\t0x7260,\n\t0x7268,\n\t0x7271,\n\t0x7278,\n};\n\n \nstatic void __init a72_b53_rac_enable_all(struct device_node *np)\n{\n\tunsigned int cpu;\n\tu32 enable = 0, pref_dist, shift;\n\n\tif (IS_ENABLED(CONFIG_CACHE_B15_RAC))\n\t\treturn;\n\n\tif (WARN(num_possible_cpus() > 4, \"RAC only supports 4 CPUs\\n\"))\n\t\treturn;\n\n\tpref_dist = cbc_readl(RAC_CONFIG1_REG);\n\tfor_each_possible_cpu(cpu) {\n\t\tshift = cpu * RAC_CPU_SHIFT + RACPREFDATA_SHIFT;\n\t\tenable |= RAC_DATA_INST_EN_MASK << (cpu * RAC_CPU_SHIFT);\n\t\tif (cpubiuctrl_regs == a72_cpubiuctrl_regs) {\n\t\t\tenable &= ~(RACENPREF_MASK << shift);\n\t\t\tenable |= 3 << shift;\n\t\t\tpref_dist |= 1 << (cpu + DPREF_LINE_2_SHIFT);\n\t\t}\n\t}\n\n\tcbc_writel(enable, RAC_CONFIG0_REG);\n\tcbc_writel(pref_dist, RAC_CONFIG1_REG);\n\n\tpr_info(\"%pOF: Broadcom %s read-ahead cache\\n\",\n\t\tnp, cpubiuctrl_regs == a72_cpubiuctrl_regs ?\n\t\t\"Cortex-A72\" : \"Brahma-B53\");\n}\n\nstatic void __init mcp_a72_b53_set(void)\n{\n\tunsigned int i;\n\tu32 reg;\n\n\treg = brcmstb_get_family_id();\n\n\tfor (i = 0; i < ARRAY_SIZE(a72_b53_mach_compat); i++) {\n\t\tif (BRCM_ID(reg) == a72_b53_mach_compat[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(a72_b53_mach_compat))\n\t\treturn;\n\n\t \n\treg = cbc_readl(CPU_CREDIT_REG);\n\tfor (i = 0; i < 3; i++) {\n\t\treg &= ~(CPU_CREDIT_REG_MCPx_WRITE_CRED_MASK <<\n\t\t\t CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(i));\n\t\treg &= ~(CPU_CREDIT_REG_MCPx_READ_CRED_MASK <<\n\t\t\t CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(i));\n\t\treg |= 8 << CPU_CREDIT_REG_MCPx_WRITE_CRED_SHIFT(i);\n\t\treg |= 8 << CPU_CREDIT_REG_MCPx_READ_CRED_SHIFT(i);\n\t}\n\tcbc_writel(reg, CPU_CREDIT_REG);\n\n\t \n\treg = cbc_readl(CPU_MCP_FLOW_REG);\n\tfor (i = 0; i < 3; i++)\n\t\treg |= CPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_MASK <<\n\t\t\tCPU_MCP_FLOW_REG_MCPx_RDBUFF_CRED_SHIFT(i);\n\tcbc_writel(reg, CPU_MCP_FLOW_REG);\n\n\t \n\treg = cbc_readl(CPU_WRITEBACK_CTRL_REG);\n\treg |= CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_ENABLE;\n\treg &= ~CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_THRESHOLD_MASK;\n\treg &= ~(CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_MASK <<\n\t\t CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT);\n\treg |= 8;\n\treg |= 7 << CPU_WRITEBACK_CTRL_REG_WB_THROTTLE_TIMEOUT_SHIFT;\n\tcbc_writel(reg, CPU_WRITEBACK_CTRL_REG);\n}\n\nstatic int __init setup_hifcpubiuctrl_regs(struct device_node *np)\n{\n\tstruct device_node *cpu_dn;\n\tu32 family_id;\n\tint ret = 0;\n\n\tcpubiuctrl_base = of_iomap(np, 0);\n\tif (!cpubiuctrl_base) {\n\t\tpr_err(\"failed to remap BIU control base\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmcp_wr_pairing_en = of_property_read_bool(np, \"brcm,write-pairing\");\n\n\tcpu_dn = of_get_cpu_node(0, NULL);\n\tif (!cpu_dn) {\n\t\tpr_err(\"failed to obtain CPU device node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (of_device_is_compatible(cpu_dn, \"brcm,brahma-b15\"))\n\t\tcpubiuctrl_regs = b15_cpubiuctrl_regs;\n\telse if (of_device_is_compatible(cpu_dn, \"brcm,brahma-b53\"))\n\t\tcpubiuctrl_regs = b53_cpubiuctrl_regs;\n\telse if (of_device_is_compatible(cpu_dn, \"arm,cortex-a72\"))\n\t\tcpubiuctrl_regs = a72_cpubiuctrl_regs;\n\telse {\n\t\tpr_err(\"unsupported CPU\\n\");\n\t\tret = -EINVAL;\n\t}\n\tof_node_put(cpu_dn);\n\n\tfamily_id = brcmstb_get_family_id();\n\tif (BRCM_ID(family_id) == 0x7260 && BRCM_REV(family_id) == 0)\n\t\tcpubiuctrl_regs = b53_cpubiuctrl_no_wb_regs;\nout:\n\tif (ret && cpubiuctrl_base) {\n\t\tiounmap(cpubiuctrl_base);\n\t\tcpubiuctrl_base = NULL;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic u32 cpubiuctrl_reg_save[NUM_CPU_BIUCTRL_REGS];\n\nstatic int brcmstb_cpu_credit_reg_suspend(void)\n{\n\tunsigned int i;\n\n\tif (!cpubiuctrl_base)\n\t\treturn 0;\n\n\tfor (i = 0; i < NUM_CPU_BIUCTRL_REGS; i++)\n\t\tcpubiuctrl_reg_save[i] = cbc_readl(i);\n\n\treturn 0;\n}\n\nstatic void brcmstb_cpu_credit_reg_resume(void)\n{\n\tunsigned int i;\n\n\tif (!cpubiuctrl_base)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_CPU_BIUCTRL_REGS; i++)\n\t\tcbc_writel(cpubiuctrl_reg_save[i], i);\n}\n\nstatic struct syscore_ops brcmstb_cpu_credit_syscore_ops = {\n\t.suspend = brcmstb_cpu_credit_reg_suspend,\n\t.resume = brcmstb_cpu_credit_reg_resume,\n};\n#endif\n\n\nstatic int __init brcmstb_biuctrl_init(void)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"brcm,brcmstb-cpu-biu-ctrl\");\n\tif (!np)\n\t\treturn 0;\n\n\tret = setup_hifcpubiuctrl_regs(np);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = mcp_write_pairing_set();\n\tif (ret) {\n\t\tpr_err(\"MCP: Unable to disable write pairing!\\n\");\n\t\tgoto out_put;\n\t}\n\n\ta72_b53_rac_enable_all(np);\n\tmcp_a72_b53_set();\n#ifdef CONFIG_PM_SLEEP\n\tregister_syscore_ops(&brcmstb_cpu_credit_syscore_ops);\n#endif\n\tret = 0;\nout_put:\n\tof_node_put(np);\n\treturn ret;\n}\nearly_initcall(brcmstb_biuctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}