{
  "module_name": "pm-mips.c",
  "hash_id": "ce4bbb19e361dbb1e29b41d7c4c8a12477bac37dd3c1dd779cfc71a74acee4b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/bcm/brcmstb/pm/pm-mips.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <asm/bmips.h>\n#include <asm/tlbflush.h>\n\n#include \"pm.h\"\n\n#define S2_NUM_PARAMS\t\t6\n#define MAX_NUM_MEMC\t\t3\n\n \n#define MAX_GP_REGS\t\t16\n#define MAX_CP0_REGS\t\t32\n#define NUM_MEMC_CLIENTS\t128\n#define AON_CTRL_RAM_SIZE\t128\n#define BRCMSTB_S3_MAGIC\t0x5AFEB007\n\n#define CLEAR_RESET_MASK\t0x01\n\n \n#define CONTEXT\t\t0\n#define USER_LOCAL\t1\n#define PGMK\t\t2\n#define HWRENA\t\t3\n#define COMPARE\t\t4\n#define STATUS\t\t5\n#define CONFIG\t\t6\n#define MODE\t\t7\n#define EDSP\t\t8\n#define BOOT_VEC\t9\n#define EBASE\t\t10\n\nstruct brcmstb_memc {\n\tvoid __iomem *ddr_phy_base;\n\tvoid __iomem *arb_base;\n};\n\nstruct brcmstb_pm_control {\n\tvoid __iomem *aon_ctrl_base;\n\tvoid __iomem *aon_sram_base;\n\tvoid __iomem *timers_base;\n\tstruct brcmstb_memc memcs[MAX_NUM_MEMC];\n\tint num_memc;\n};\n\nstruct brcm_pm_s3_context {\n\tu32\t\t\tcp0_regs[MAX_CP0_REGS];\n\tu32\t\t\tmemc0_rts[NUM_MEMC_CLIENTS];\n\tu32\t\t\tsc_boot_vec;\n};\n\nstruct brcmstb_mem_transfer;\n\nstruct brcmstb_mem_transfer {\n\tstruct brcmstb_mem_transfer\t*next;\n\tvoid\t\t\t\t*src;\n\tvoid\t\t\t\t*dst;\n\tdma_addr_t\t\t\tpa_src;\n\tdma_addr_t\t\t\tpa_dst;\n\tu32\t\t\t\tlen;\n\tu8\t\t\t\tkey;\n\tu8\t\t\t\tmode;\n\tu8\t\t\t\tsrc_remapped;\n\tu8\t\t\t\tdst_remapped;\n\tu8\t\t\t\tsrc_dst_remapped;\n};\n\n#define AON_SAVE_SRAM(base, idx, val) \\\n\t__raw_writel(val, base + (idx << 2))\n\n \nu32 gp_regs[MAX_GP_REGS];\n\n#define\tBSP_CLOCK_STOP\t\t0x00\n#define PM_INITIATE\t\t0x01\n\nstatic struct brcmstb_pm_control ctrl;\n\nstatic void brcm_pm_save_cp0_context(struct brcm_pm_s3_context *ctx)\n{\n\t \n\tctx->cp0_regs[CONTEXT] = read_c0_context();\n\tctx->cp0_regs[USER_LOCAL] = read_c0_userlocal();\n\tctx->cp0_regs[PGMK] = read_c0_pagemask();\n\tctx->cp0_regs[HWRENA] = read_c0_cache();\n\tctx->cp0_regs[COMPARE] = read_c0_compare();\n\tctx->cp0_regs[STATUS] = read_c0_status();\n\n\t \n\tctx->cp0_regs[CONFIG] = read_c0_brcm_config();\n\tctx->cp0_regs[MODE] = read_c0_brcm_mode();\n\tctx->cp0_regs[EDSP] = read_c0_brcm_edsp();\n\tctx->cp0_regs[BOOT_VEC] = read_c0_brcm_bootvec();\n\tctx->cp0_regs[EBASE] = read_c0_ebase();\n\n\tctx->sc_boot_vec = bmips_read_zscm_reg(0xa0);\n}\n\nstatic void brcm_pm_restore_cp0_context(struct brcm_pm_s3_context *ctx)\n{\n\t \n\tbmips_write_zscm_reg(0xa0, ctx->sc_boot_vec);\n\n\t \n\twrite_c0_context(ctx->cp0_regs[CONTEXT]);\n\twrite_c0_userlocal(ctx->cp0_regs[USER_LOCAL]);\n\twrite_c0_pagemask(ctx->cp0_regs[PGMK]);\n\twrite_c0_cache(ctx->cp0_regs[HWRENA]);\n\twrite_c0_compare(ctx->cp0_regs[COMPARE]);\n\twrite_c0_status(ctx->cp0_regs[STATUS]);\n\n\t \n\twrite_c0_brcm_config(ctx->cp0_regs[CONFIG]);\n\twrite_c0_brcm_mode(ctx->cp0_regs[MODE]);\n\twrite_c0_brcm_edsp(ctx->cp0_regs[EDSP]);\n\twrite_c0_brcm_bootvec(ctx->cp0_regs[BOOT_VEC]);\n\twrite_c0_ebase(ctx->cp0_regs[EBASE]);\n}\n\nstatic void  brcmstb_pm_handshake(void)\n{\n\tvoid __iomem *base = ctrl.aon_ctrl_base;\n\tu32 tmp;\n\n\t \n\ttmp = __raw_readl(base + AON_CTRL_HOST_MISC_CMDS);\n\ttmp &= ~1UL;\n\t__raw_writel(tmp, base + AON_CTRL_HOST_MISC_CMDS);\n\t(void)__raw_readl(base + AON_CTRL_HOST_MISC_CMDS);\n\n\t__raw_writel(0, base + AON_CTRL_PM_INITIATE);\n\t(void)__raw_readl(base + AON_CTRL_PM_INITIATE);\n\t__raw_writel(BSP_CLOCK_STOP | PM_INITIATE,\n\t\t     base + AON_CTRL_PM_INITIATE);\n\t \n\tmdelay(3);\n}\n\nstatic void brcmstb_pm_s5(void)\n{\n\tvoid __iomem *base = ctrl.aon_ctrl_base;\n\n\tbrcmstb_pm_handshake();\n\n\t \n\tAON_SAVE_SRAM(ctrl.aon_sram_base, 0, 0);\n\n\t \n\t__raw_writel(0x10, base + AON_CTRL_PM_CPU_WAIT_COUNT);\n\t(void)__raw_readl(base + AON_CTRL_PM_CPU_WAIT_COUNT);\n\n\t \n\t__raw_writel(PM_COLD_CONFIG, base + AON_CTRL_PM_CTRL);\n\t(void)__raw_readl(base + AON_CTRL_PM_CTRL);\n\n\t__raw_writel((PM_COLD_CONFIG | PM_PWR_DOWN), base +\n\t\t      AON_CTRL_PM_CTRL);\n\t(void)__raw_readl(base + AON_CTRL_PM_CTRL);\n\n\t__asm__ __volatile__(\n\t\"\twait\\n\"\n\t: : : \"memory\");\n}\n\nstatic int brcmstb_pm_s3(void)\n{\n\tstruct brcm_pm_s3_context s3_context;\n\tvoid __iomem *memc_arb_base;\n\tunsigned long flags;\n\tu32 tmp;\n\tint i;\n\n\t \n\tAON_SAVE_SRAM(ctrl.aon_sram_base, 0, BRCMSTB_S3_MAGIC);\n\tAON_SAVE_SRAM(ctrl.aon_sram_base, 1, (u32)&s3_reentry);\n\tAON_SAVE_SRAM(ctrl.aon_sram_base, 2, 0);\n\n\t \n\ttmp = __raw_readl(ctrl.aon_ctrl_base + AON_CTRL_RESET_CTRL);\n\ttmp &= ~CLEAR_RESET_MASK;\n\t__raw_writel(tmp, ctrl.aon_ctrl_base + AON_CTRL_RESET_CTRL);\n\n\tlocal_irq_save(flags);\n\n\t \n\tfor (i = 0; i < ctrl.num_memc; i++) {\n\t\ttmp = __raw_readl(ctrl.memcs[i].ddr_phy_base +\n\t\t\tDDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);\n\n\t\ttmp &= ~0x0f;\n\t\t__raw_writel(tmp, ctrl.memcs[i].ddr_phy_base +\n\t\t\tDDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);\n\t\ttmp |= (0x05 | BIT(5));\n\t\t__raw_writel(tmp, ctrl.memcs[i].ddr_phy_base +\n\t\t\tDDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);\n\t}\n\n\t \n\tbrcm_pm_save_cp0_context(&s3_context);\n\n\t \n\tmemc_arb_base = ctrl.memcs[0].arb_base + 4;\n\tfor (i = 0; i < NUM_MEMC_CLIENTS; i++) {\n\t\ts3_context.memc0_rts[i] = __raw_readl(memc_arb_base);\n\t\tmemc_arb_base += 4;\n\t}\n\n\t \n\tlocal_flush_tlb_all();\n\t_dma_cache_wback_inv(0, ~0);\n\n\tbrcm_pm_do_s3(ctrl.aon_ctrl_base, current_cpu_data.dcache.linesz);\n\n\t \n\tlocal_flush_tlb_all();\n\tbmips_cpu_setup();\n\tcpumask_clear(&bmips_booted_mask);\n\n\t \n\tmemc_arb_base = ctrl.memcs[0].arb_base + 4;\n\tfor (i = 0; i < NUM_MEMC_CLIENTS; i++) {\n\t\t__raw_writel(s3_context.memc0_rts[i], memc_arb_base);\n\t\tmemc_arb_base += 4;\n\t}\n\n\t \n\tbrcm_pm_restore_cp0_context(&s3_context);\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic int brcmstb_pm_s2(void)\n{\n\t \n\tu32 s2_params[6];\n\n\t \n\ts2_params[0] = (u32)ctrl.aon_ctrl_base;\n\ts2_params[1] = (u32)ctrl.memcs[0].ddr_phy_base;\n\ts2_params[2] = (u32)ctrl.timers_base;\n\ts2_params[3] = (u32)current_cpu_data.icache.linesz;\n\ts2_params[4] = (u32)BMIPS_WARM_RESTART_VEC;\n\ts2_params[5] = (u32)(bmips_smp_int_vec_end -\n\t\tbmips_smp_int_vec);\n\n\t \n\tbrcm_pm_do_s2(s2_params);\n\n\treturn 0;\n}\n\nstatic int brcmstb_pm_standby(bool deep_standby)\n{\n\tbrcmstb_pm_handshake();\n\n\t \n\tclear_c0_cause(CAUSEF_IV);\n\tirq_disable_hazard();\n\tset_c0_status(ST0_BEV);\n\tirq_disable_hazard();\n\n\tif (deep_standby)\n\t\tbrcmstb_pm_s3();\n\telse\n\t\tbrcmstb_pm_s2();\n\n\t \n\tclear_c0_status(ST0_BEV);\n\tirq_disable_hazard();\n\tset_c0_cause(CAUSEF_IV);\n\tirq_disable_hazard();\n\n\treturn 0;\n}\n\nstatic int brcmstb_pm_enter(suspend_state_t state)\n{\n\tint ret = -EINVAL;\n\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\tret = brcmstb_pm_standby(false);\n\t\tbreak;\n\tcase PM_SUSPEND_MEM:\n\t\tret = brcmstb_pm_standby(true);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int brcmstb_pm_valid(suspend_state_t state)\n{\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn true;\n\tcase PM_SUSPEND_MEM:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct platform_suspend_ops brcmstb_pm_ops = {\n\t.enter\t\t= brcmstb_pm_enter,\n\t.valid\t\t= brcmstb_pm_valid,\n};\n\nstatic const struct of_device_id aon_ctrl_dt_ids[] = {\n\t{ .compatible = \"brcm,brcmstb-aon-ctrl\" },\n\t{   }\n};\n\nstatic const struct of_device_id ddr_phy_dt_ids[] = {\n\t{ .compatible = \"brcm,brcmstb-ddr-phy\" },\n\t{   }\n};\n\nstatic const struct of_device_id arb_dt_ids[] = {\n\t{ .compatible = \"brcm,brcmstb-memc-arb\" },\n\t{   }\n};\n\nstatic const struct of_device_id timers_ids[] = {\n\t{ .compatible = \"brcm,brcmstb-timers\" },\n\t{   }\n};\n\nstatic inline void __iomem *brcmstb_ioremap_node(struct device_node *dn,\n\t\t\t\t\t\t int index)\n{\n\treturn of_io_request_and_map(dn, index, dn->full_name);\n}\n\nstatic void __iomem *brcmstb_ioremap_match(const struct of_device_id *matches,\n\t\t\t\t\t   int index, const void **ofdata)\n{\n\tstruct device_node *dn;\n\tconst struct of_device_id *match;\n\n\tdn = of_find_matching_node_and_match(NULL, matches, &match);\n\tif (!dn)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ofdata)\n\t\t*ofdata = match->data;\n\n\treturn brcmstb_ioremap_node(dn, index);\n}\n\nstatic int brcmstb_pm_init(void)\n{\n\tstruct device_node *dn;\n\tvoid __iomem *base;\n\tint i;\n\n\t \n\tbase = brcmstb_ioremap_match(aon_ctrl_dt_ids, 0, NULL);\n\tif (IS_ERR(base)) {\n\t\tpr_err(\"error mapping AON_CTRL\\n\");\n\t\tgoto aon_err;\n\t}\n\tctrl.aon_ctrl_base = base;\n\n\t \n\tbase = brcmstb_ioremap_match(aon_ctrl_dt_ids, 1, NULL);\n\tif (IS_ERR(base)) {\n\t\tpr_err(\"error mapping AON_SRAM\\n\");\n\t\tgoto sram_err;\n\t}\n\tctrl.aon_sram_base = base;\n\n\tctrl.num_memc = 0;\n\t \n\tfor_each_matching_node(dn, ddr_phy_dt_ids) {\n\t\ti = ctrl.num_memc;\n\t\tif (i >= MAX_NUM_MEMC) {\n\t\t\tpr_warn(\"Too many MEMCs (max %d)\\n\", MAX_NUM_MEMC);\n\t\t\tof_node_put(dn);\n\t\t\tbreak;\n\t\t}\n\t\tbase = brcmstb_ioremap_node(dn, 0);\n\t\tif (IS_ERR(base)) {\n\t\t\tof_node_put(dn);\n\t\t\tgoto ddr_err;\n\t\t}\n\n\t\tctrl.memcs[i].ddr_phy_base = base;\n\t\tctrl.num_memc++;\n\t}\n\n\t \n\tbase = brcmstb_ioremap_match(arb_dt_ids, 0, NULL);\n\tif (IS_ERR(base)) {\n\t\tpr_err(\"error mapping MEMC ARB\\n\");\n\t\tgoto ddr_err;\n\t}\n\tctrl.memcs[0].arb_base = base;\n\n\t \n\tbase = brcmstb_ioremap_match(timers_ids, 0, NULL);\n\tif (IS_ERR(base)) {\n\t\tpr_err(\"error mapping timers\\n\");\n\t\tgoto tmr_err;\n\t}\n\tctrl.timers_base = base;\n\n\t \n\tpm_power_off = brcmstb_pm_s5;\n\n\tsuspend_set_ops(&brcmstb_pm_ops);\n\n\treturn 0;\n\ntmr_err:\n\tiounmap(ctrl.memcs[0].arb_base);\nddr_err:\n\tfor (i = 0; i < ctrl.num_memc; i++)\n\t\tiounmap(ctrl.memcs[i].ddr_phy_base);\n\n\tiounmap(ctrl.aon_sram_base);\nsram_err:\n\tiounmap(ctrl.aon_ctrl_base);\naon_err:\n\treturn PTR_ERR(base);\n}\narch_initcall(brcmstb_pm_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}