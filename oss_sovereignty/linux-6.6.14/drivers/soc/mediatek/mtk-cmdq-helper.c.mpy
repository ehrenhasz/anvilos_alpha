{
  "module_name": "mtk-cmdq-helper.c",
  "hash_id": "fd57d19bdbd05d74c7b39745e45a47246340b07904fcd68d66fb15e7429f4f3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/mediatek/mtk-cmdq-helper.c",
  "human_readable_source": "\n\n\n\n#include <linux/completion.h>\n#include <linux/errno.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/mailbox_controller.h>\n#include <linux/of.h>\n#include <linux/soc/mediatek/mtk-cmdq.h>\n\n#define CMDQ_WRITE_ENABLE_MASK\tBIT(0)\n#define CMDQ_POLL_ENABLE_MASK\tBIT(0)\n#define CMDQ_EOC_IRQ_EN\t\tBIT(0)\n#define CMDQ_REG_TYPE\t\t1\n#define CMDQ_JUMP_RELATIVE\t1\n\nstruct cmdq_instruction {\n\tunion {\n\t\tu32 value;\n\t\tu32 mask;\n\t\tstruct {\n\t\t\tu16 arg_c;\n\t\t\tu16 src_reg;\n\t\t};\n\t};\n\tunion {\n\t\tu16 offset;\n\t\tu16 event;\n\t\tu16 reg_dst;\n\t};\n\tunion {\n\t\tu8 subsys;\n\t\tstruct {\n\t\t\tu8 sop:5;\n\t\t\tu8 arg_c_t:1;\n\t\t\tu8 src_t:1;\n\t\t\tu8 dst_t:1;\n\t\t};\n\t};\n\tu8 op;\n};\n\nint cmdq_dev_get_client_reg(struct device *dev,\n\t\t\t    struct cmdq_client_reg *client_reg, int idx)\n{\n\tstruct of_phandle_args spec;\n\tint err;\n\n\tif (!client_reg)\n\t\treturn -ENOENT;\n\n\terr = of_parse_phandle_with_fixed_args(dev->of_node,\n\t\t\t\t\t       \"mediatek,gce-client-reg\",\n\t\t\t\t\t       3, idx, &spec);\n\tif (err < 0) {\n\t\tdev_err(dev,\n\t\t\t\"error %d can't parse gce-client-reg property (%d)\",\n\t\t\terr, idx);\n\n\t\treturn err;\n\t}\n\n\tclient_reg->subsys = (u8)spec.args[0];\n\tclient_reg->offset = (u16)spec.args[1];\n\tclient_reg->size = (u16)spec.args[2];\n\tof_node_put(spec.np);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cmdq_dev_get_client_reg);\n\nstruct cmdq_client *cmdq_mbox_create(struct device *dev, int index)\n{\n\tstruct cmdq_client *client;\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn (struct cmdq_client *)-ENOMEM;\n\n\tclient->client.dev = dev;\n\tclient->client.tx_block = false;\n\tclient->client.knows_txdone = true;\n\tclient->chan = mbox_request_channel(&client->client, index);\n\n\tif (IS_ERR(client->chan)) {\n\t\tlong err;\n\n\t\tdev_err(dev, \"failed to request channel\\n\");\n\t\terr = PTR_ERR(client->chan);\n\t\tkfree(client);\n\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn client;\n}\nEXPORT_SYMBOL(cmdq_mbox_create);\n\nvoid cmdq_mbox_destroy(struct cmdq_client *client)\n{\n\tmbox_free_channel(client->chan);\n\tkfree(client);\n}\nEXPORT_SYMBOL(cmdq_mbox_destroy);\n\nstruct cmdq_pkt *cmdq_pkt_create(struct cmdq_client *client, size_t size)\n{\n\tstruct cmdq_pkt *pkt;\n\tstruct device *dev;\n\tdma_addr_t dma_addr;\n\n\tpkt = kzalloc(sizeof(*pkt), GFP_KERNEL);\n\tif (!pkt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpkt->va_base = kzalloc(size, GFP_KERNEL);\n\tif (!pkt->va_base) {\n\t\tkfree(pkt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpkt->buf_size = size;\n\tpkt->cl = (void *)client;\n\n\tdev = client->chan->mbox->dev;\n\tdma_addr = dma_map_single(dev, pkt->va_base, pkt->buf_size,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_addr)) {\n\t\tdev_err(dev, \"dma map failed, size=%u\\n\", (u32)(u64)size);\n\t\tkfree(pkt->va_base);\n\t\tkfree(pkt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tpkt->pa_base = dma_addr;\n\n\treturn pkt;\n}\nEXPORT_SYMBOL(cmdq_pkt_create);\n\nvoid cmdq_pkt_destroy(struct cmdq_pkt *pkt)\n{\n\tstruct cmdq_client *client = (struct cmdq_client *)pkt->cl;\n\n\tdma_unmap_single(client->chan->mbox->dev, pkt->pa_base, pkt->buf_size,\n\t\t\t DMA_TO_DEVICE);\n\tkfree(pkt->va_base);\n\tkfree(pkt);\n}\nEXPORT_SYMBOL(cmdq_pkt_destroy);\n\nstatic int cmdq_pkt_append_command(struct cmdq_pkt *pkt,\n\t\t\t\t   struct cmdq_instruction inst)\n{\n\tstruct cmdq_instruction *cmd_ptr;\n\n\tif (unlikely(pkt->cmd_buf_size + CMDQ_INST_SIZE > pkt->buf_size)) {\n\t\t \n\t\tpkt->cmd_buf_size += CMDQ_INST_SIZE;\n\t\tWARN_ONCE(1, \"%s: buffer size %u is too small !\\n\",\n\t\t\t__func__, (u32)pkt->buf_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd_ptr = pkt->va_base + pkt->cmd_buf_size;\n\t*cmd_ptr = inst;\n\tpkt->cmd_buf_size += CMDQ_INST_SIZE;\n\n\treturn 0;\n}\n\nint cmdq_pkt_write(struct cmdq_pkt *pkt, u8 subsys, u16 offset, u32 value)\n{\n\tstruct cmdq_instruction inst;\n\n\tinst.op = CMDQ_CODE_WRITE;\n\tinst.value = value;\n\tinst.offset = offset;\n\tinst.subsys = subsys;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_write);\n\nint cmdq_pkt_write_mask(struct cmdq_pkt *pkt, u8 subsys,\n\t\t\tu16 offset, u32 value, u32 mask)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\tu16 offset_mask = offset;\n\tint err;\n\n\tif (mask != 0xffffffff) {\n\t\tinst.op = CMDQ_CODE_MASK;\n\t\tinst.mask = ~mask;\n\t\terr = cmdq_pkt_append_command(pkt, inst);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\toffset_mask |= CMDQ_WRITE_ENABLE_MASK;\n\t}\n\terr = cmdq_pkt_write(pkt, subsys, offset_mask, value);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmdq_pkt_write_mask);\n\nint cmdq_pkt_read_s(struct cmdq_pkt *pkt, u16 high_addr_reg_idx, u16 addr_low,\n\t\t    u16 reg_idx)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tinst.op = CMDQ_CODE_READ_S;\n\tinst.dst_t = CMDQ_REG_TYPE;\n\tinst.sop = high_addr_reg_idx;\n\tinst.reg_dst = reg_idx;\n\tinst.src_reg = addr_low;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_read_s);\n\nint cmdq_pkt_write_s(struct cmdq_pkt *pkt, u16 high_addr_reg_idx,\n\t\t     u16 addr_low, u16 src_reg_idx)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tinst.op = CMDQ_CODE_WRITE_S;\n\tinst.src_t = CMDQ_REG_TYPE;\n\tinst.sop = high_addr_reg_idx;\n\tinst.offset = addr_low;\n\tinst.src_reg = src_reg_idx;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_write_s);\n\nint cmdq_pkt_write_s_mask(struct cmdq_pkt *pkt, u16 high_addr_reg_idx,\n\t\t\t  u16 addr_low, u16 src_reg_idx, u32 mask)\n{\n\tstruct cmdq_instruction inst = {};\n\tint err;\n\n\tinst.op = CMDQ_CODE_MASK;\n\tinst.mask = ~mask;\n\terr = cmdq_pkt_append_command(pkt, inst);\n\tif (err < 0)\n\t\treturn err;\n\n\tinst.mask = 0;\n\tinst.op = CMDQ_CODE_WRITE_S_MASK;\n\tinst.src_t = CMDQ_REG_TYPE;\n\tinst.sop = high_addr_reg_idx;\n\tinst.offset = addr_low;\n\tinst.src_reg = src_reg_idx;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_write_s_mask);\n\nint cmdq_pkt_write_s_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,\n\t\t\t   u16 addr_low, u32 value)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tinst.op = CMDQ_CODE_WRITE_S;\n\tinst.sop = high_addr_reg_idx;\n\tinst.offset = addr_low;\n\tinst.value = value;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_write_s_value);\n\nint cmdq_pkt_write_s_mask_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,\n\t\t\t\tu16 addr_low, u32 value, u32 mask)\n{\n\tstruct cmdq_instruction inst = {};\n\tint err;\n\n\tinst.op = CMDQ_CODE_MASK;\n\tinst.mask = ~mask;\n\terr = cmdq_pkt_append_command(pkt, inst);\n\tif (err < 0)\n\t\treturn err;\n\n\tinst.op = CMDQ_CODE_WRITE_S_MASK;\n\tinst.sop = high_addr_reg_idx;\n\tinst.offset = addr_low;\n\tinst.value = value;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_write_s_mask_value);\n\nint cmdq_pkt_wfe(struct cmdq_pkt *pkt, u16 event, bool clear)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\tu32 clear_option = clear ? CMDQ_WFE_UPDATE : 0;\n\n\tif (event >= CMDQ_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tinst.op = CMDQ_CODE_WFE;\n\tinst.value = CMDQ_WFE_OPTION | clear_option;\n\tinst.event = event;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_wfe);\n\nint cmdq_pkt_clear_event(struct cmdq_pkt *pkt, u16 event)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\n\tif (event >= CMDQ_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tinst.op = CMDQ_CODE_WFE;\n\tinst.value = CMDQ_WFE_UPDATE;\n\tinst.event = event;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_clear_event);\n\nint cmdq_pkt_set_event(struct cmdq_pkt *pkt, u16 event)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tif (event >= CMDQ_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tinst.op = CMDQ_CODE_WFE;\n\tinst.value = CMDQ_WFE_UPDATE | CMDQ_WFE_UPDATE_VALUE;\n\tinst.event = event;\n\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_set_event);\n\nint cmdq_pkt_poll(struct cmdq_pkt *pkt, u8 subsys,\n\t\t  u16 offset, u32 value)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\tint err;\n\n\tinst.op = CMDQ_CODE_POLL;\n\tinst.value = value;\n\tinst.offset = offset;\n\tinst.subsys = subsys;\n\terr = cmdq_pkt_append_command(pkt, inst);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmdq_pkt_poll);\n\nint cmdq_pkt_poll_mask(struct cmdq_pkt *pkt, u8 subsys,\n\t\t       u16 offset, u32 value, u32 mask)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\tint err;\n\n\tinst.op = CMDQ_CODE_MASK;\n\tinst.mask = ~mask;\n\terr = cmdq_pkt_append_command(pkt, inst);\n\tif (err < 0)\n\t\treturn err;\n\n\toffset = offset | CMDQ_POLL_ENABLE_MASK;\n\terr = cmdq_pkt_poll(pkt, subsys, offset, value);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmdq_pkt_poll_mask);\n\nint cmdq_pkt_assign(struct cmdq_pkt *pkt, u16 reg_idx, u32 value)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tinst.op = CMDQ_CODE_LOGIC;\n\tinst.dst_t = CMDQ_REG_TYPE;\n\tinst.reg_dst = reg_idx;\n\tinst.value = value;\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_assign);\n\nint cmdq_pkt_jump(struct cmdq_pkt *pkt, dma_addr_t addr)\n{\n\tstruct cmdq_instruction inst = {};\n\n\tinst.op = CMDQ_CODE_JUMP;\n\tinst.offset = CMDQ_JUMP_RELATIVE;\n\tinst.value = addr >>\n\t\tcmdq_get_shift_pa(((struct cmdq_client *)pkt->cl)->chan);\n\treturn cmdq_pkt_append_command(pkt, inst);\n}\nEXPORT_SYMBOL(cmdq_pkt_jump);\n\nint cmdq_pkt_finalize(struct cmdq_pkt *pkt)\n{\n\tstruct cmdq_instruction inst = { {0} };\n\tint err;\n\n\t \n\tinst.op = CMDQ_CODE_EOC;\n\tinst.value = CMDQ_EOC_IRQ_EN;\n\terr = cmdq_pkt_append_command(pkt, inst);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tinst.op = CMDQ_CODE_JUMP;\n\tinst.value = CMDQ_JUMP_PASS >>\n\t\tcmdq_get_shift_pa(((struct cmdq_client *)pkt->cl)->chan);\n\terr = cmdq_pkt_append_command(pkt, inst);\n\n\treturn err;\n}\nEXPORT_SYMBOL(cmdq_pkt_finalize);\n\nint cmdq_pkt_flush_async(struct cmdq_pkt *pkt)\n{\n\tint err;\n\tstruct cmdq_client *client = (struct cmdq_client *)pkt->cl;\n\n\terr = mbox_send_message(client->chan, pkt);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tmbox_client_txdone(client->chan, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cmdq_pkt_flush_async);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}