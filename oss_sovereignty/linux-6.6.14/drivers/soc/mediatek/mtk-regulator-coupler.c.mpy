{
  "module_name": "mtk-regulator-coupler.c",
  "hash_id": "a60f18a6b407a17a795eb5728a8d701806b7e824e040207b055608ebf5fcc2db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/mediatek/mtk-regulator-coupler.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/regulator/coupler.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/suspend.h>\n\n#define to_mediatek_coupler(x)\tcontainer_of(x, struct mediatek_regulator_coupler, coupler)\n\nstruct mediatek_regulator_coupler {\n\tstruct regulator_coupler coupler;\n\tstruct regulator_dev *vsram_rdev;\n};\n\n \nstatic int mediatek_regulator_balance_voltage(struct regulator_coupler *coupler,\n\t\t\t\t\t      struct regulator_dev *rdev,\n\t\t\t\t\t      suspend_state_t state)\n{\n\tstruct mediatek_regulator_coupler *mrc = to_mediatek_coupler(coupler);\n\tint max_spread = rdev->constraints->max_spread[0];\n\tint vsram_min_uV = mrc->vsram_rdev->constraints->min_uV;\n\tint vsram_max_uV = mrc->vsram_rdev->constraints->max_uV;\n\tint vsram_target_min_uV, vsram_target_max_uV;\n\tint min_uV = 0;\n\tint max_uV = INT_MAX;\n\tint ret;\n\n\t \n\tif (rdev == mrc->vsram_rdev) {\n\t\tif (rdev->use_count == 0)\n\t\t\treturn regulator_do_balance_voltage(rdev, state, true);\n\n\t\treturn -EPERM;\n\t}\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (min_uV == 0) {\n\t\tret = regulator_get_voltage_rdev(rdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmin_uV = ret;\n\t}\n\n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tvsram_target_min_uV = max(vsram_min_uV, min_uV + max_spread);\n\tvsram_target_max_uV = min(vsram_max_uV, vsram_target_min_uV + max_spread);\n\n\t \n\tvsram_target_min_uV = min(vsram_target_min_uV, vsram_max_uV);\n\n\tpr_debug(\"Setting voltage %d-%duV on %s (minuV %d)\\n\",\n\t\t vsram_target_min_uV, vsram_target_max_uV,\n\t\t rdev_get_name(mrc->vsram_rdev), min_uV);\n\n\tret = regulator_set_voltage_rdev(mrc->vsram_rdev, vsram_target_min_uV,\n\t\t\t\t\t vsram_target_max_uV, state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regulator_do_balance_voltage(rdev, state, true);\n}\n\nstatic int mediatek_regulator_attach(struct regulator_coupler *coupler,\n\t\t\t\t     struct regulator_dev *rdev)\n{\n\tstruct mediatek_regulator_coupler *mrc = to_mediatek_coupler(coupler);\n\tconst char *rdev_name = rdev_get_name(rdev);\n\n\t \n\tif (rdev->coupling_desc.n_coupled > 2)\n\t\treturn 1;\n\n\tif (strstr(rdev_name, \"sram\")) {\n\t\tif (mrc->vsram_rdev)\n\t\t\treturn -EINVAL;\n\t\tmrc->vsram_rdev = rdev;\n\t} else if (!strstr(rdev_name, \"vgpu\") && !strstr(rdev_name, \"Vgpu\")) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mediatek_regulator_detach(struct regulator_coupler *coupler,\n\t\t\t\t     struct regulator_dev *rdev)\n{\n\tstruct mediatek_regulator_coupler *mrc = to_mediatek_coupler(coupler);\n\n\tif (rdev == mrc->vsram_rdev)\n\t\tmrc->vsram_rdev = NULL;\n\n\treturn 0;\n}\n\nstatic struct mediatek_regulator_coupler mediatek_coupler = {\n\t.coupler = {\n\t\t.attach_regulator = mediatek_regulator_attach,\n\t\t.detach_regulator = mediatek_regulator_detach,\n\t\t.balance_voltage = mediatek_regulator_balance_voltage,\n\t},\n};\n\nstatic int mediatek_regulator_coupler_init(void)\n{\n\tif (!of_machine_is_compatible(\"mediatek,mt8183\") &&\n\t    !of_machine_is_compatible(\"mediatek,mt8186\") &&\n\t    !of_machine_is_compatible(\"mediatek,mt8192\"))\n\t\treturn 0;\n\n\treturn regulator_coupler_register(&mediatek_coupler.coupler);\n}\narch_initcall(mediatek_regulator_coupler_init);\n\nMODULE_AUTHOR(\"AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>\");\nMODULE_DESCRIPTION(\"MediaTek Regulator Coupler driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}