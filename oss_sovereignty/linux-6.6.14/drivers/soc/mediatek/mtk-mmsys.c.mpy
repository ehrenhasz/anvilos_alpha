{
  "module_name": "mtk-mmsys.c",
  "hash_id": "c6fe40d9029743208720acf77676a23b23ee6d8be8ba1bae120f598db290fbc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/mediatek/mtk-mmsys.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/soc/mediatek/mtk-mmsys.h>\n\n#include \"mtk-mmsys.h\"\n#include \"mt8167-mmsys.h\"\n#include \"mt8173-mmsys.h\"\n#include \"mt8183-mmsys.h\"\n#include \"mt8186-mmsys.h\"\n#include \"mt8188-mmsys.h\"\n#include \"mt8192-mmsys.h\"\n#include \"mt8195-mmsys.h\"\n#include \"mt8365-mmsys.h\"\n\n#define MMSYS_SW_RESET_PER_REG 32\n\nstatic const struct mtk_mmsys_driver_data mt2701_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt2701-mm\",\n\t.routes = mmsys_default_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_default_routing_table),\n};\n\nstatic const struct mtk_mmsys_driver_data mt2712_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt2712-mm\",\n\t.routes = mmsys_default_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_default_routing_table),\n};\n\nstatic const struct mtk_mmsys_driver_data mt6779_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt6779-mm\",\n};\n\nstatic const struct mtk_mmsys_driver_data mt6795_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt6795-mm\",\n\t.routes = mt8173_mmsys_routing_table,\n\t.num_routes = ARRAY_SIZE(mt8173_mmsys_routing_table),\n\t.sw0_rst_offset = MT8183_MMSYS_SW0_RST_B,\n\t.num_resets = 64,\n};\n\nstatic const struct mtk_mmsys_driver_data mt6797_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt6797-mm\",\n};\n\nstatic const struct mtk_mmsys_driver_data mt8167_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8167-mm\",\n\t.routes = mt8167_mmsys_routing_table,\n\t.num_routes = ARRAY_SIZE(mt8167_mmsys_routing_table),\n};\n\nstatic const struct mtk_mmsys_driver_data mt8173_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8173-mm\",\n\t.routes = mt8173_mmsys_routing_table,\n\t.num_routes = ARRAY_SIZE(mt8173_mmsys_routing_table),\n\t.sw0_rst_offset = MT8183_MMSYS_SW0_RST_B,\n\t.num_resets = 64,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8183_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8183-mm\",\n\t.routes = mmsys_mt8183_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8183_routing_table),\n\t.sw0_rst_offset = MT8183_MMSYS_SW0_RST_B,\n\t.num_resets = 32,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8186_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8186-mm\",\n\t.routes = mmsys_mt8186_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8186_routing_table),\n\t.sw0_rst_offset = MT8186_MMSYS_SW0_RST_B,\n\t.num_resets = 32,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8188_vdosys0_driver_data = {\n\t.clk_driver = \"clk-mt8188-vdo0\",\n\t.routes = mmsys_mt8188_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8188_routing_table),\n};\n\nstatic const struct mtk_mmsys_driver_data mt8192_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8192-mm\",\n\t.routes = mmsys_mt8192_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8192_routing_table),\n\t.sw0_rst_offset = MT8186_MMSYS_SW0_RST_B,\n\t.num_resets = 32,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vdosys0_driver_data = {\n\t.clk_driver = \"clk-mt8195-vdo0\",\n\t.routes = mmsys_mt8195_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8195_routing_table),\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vdosys1_driver_data = {\n\t.clk_driver = \"clk-mt8195-vdo1\",\n\t.routes = mmsys_mt8195_vdo1_routing_table,\n\t.num_routes = ARRAY_SIZE(mmsys_mt8195_vdo1_routing_table),\n\t.sw0_rst_offset = MT8195_VDO1_SW0_RST_B,\n\t.num_resets = 64,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vppsys0_driver_data = {\n\t.clk_driver = \"clk-mt8195-vpp0\",\n\t.is_vppsys = true,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8195_vppsys1_driver_data = {\n\t.clk_driver = \"clk-mt8195-vpp1\",\n\t.is_vppsys = true,\n};\n\nstatic const struct mtk_mmsys_driver_data mt8365_mmsys_driver_data = {\n\t.clk_driver = \"clk-mt8365-mm\",\n\t.routes = mt8365_mmsys_routing_table,\n\t.num_routes = ARRAY_SIZE(mt8365_mmsys_routing_table),\n};\n\nstruct mtk_mmsys {\n\tvoid __iomem *regs;\n\tconst struct mtk_mmsys_driver_data *data;\n\tstruct platform_device *clks_pdev;\n\tstruct platform_device *drm_pdev;\n\tspinlock_t lock;  \n\tstruct reset_controller_dev rcdev;\n\tstruct cmdq_client_reg cmdq_base;\n};\n\nstatic void mtk_mmsys_update_bits(struct mtk_mmsys *mmsys, u32 offset, u32 mask, u32 val,\n\t\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tint ret;\n\tu32 tmp;\n\n\tif (mmsys->cmdq_base.size && cmdq_pkt) {\n\t\tret = cmdq_pkt_write_mask(cmdq_pkt, mmsys->cmdq_base.subsys,\n\t\t\t\t\t  mmsys->cmdq_base.offset + offset, val,\n\t\t\t\t\t  mask);\n\t\tif (ret)\n\t\t\tpr_debug(\"CMDQ unavailable: using CPU write\\n\");\n\t\telse\n\t\t\treturn;\n\t}\n\ttmp = readl_relaxed(mmsys->regs + offset);\n\ttmp = (tmp & ~mask) | (val & mask);\n\twritel_relaxed(tmp, mmsys->regs + offset);\n}\n\nvoid mtk_mmsys_ddp_connect(struct device *dev,\n\t\t\t   enum mtk_ddp_comp_id cur,\n\t\t\t   enum mtk_ddp_comp_id next)\n{\n\tstruct mtk_mmsys *mmsys = dev_get_drvdata(dev);\n\tconst struct mtk_mmsys_routes *routes = mmsys->data->routes;\n\tint i;\n\n\tfor (i = 0; i < mmsys->data->num_routes; i++)\n\t\tif (cur == routes[i].from_comp && next == routes[i].to_comp)\n\t\t\tmtk_mmsys_update_bits(mmsys, routes[i].addr, routes[i].mask,\n\t\t\t\t\t      routes[i].val, NULL);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_ddp_connect);\n\nvoid mtk_mmsys_ddp_disconnect(struct device *dev,\n\t\t\t      enum mtk_ddp_comp_id cur,\n\t\t\t      enum mtk_ddp_comp_id next)\n{\n\tstruct mtk_mmsys *mmsys = dev_get_drvdata(dev);\n\tconst struct mtk_mmsys_routes *routes = mmsys->data->routes;\n\tint i;\n\n\tfor (i = 0; i < mmsys->data->num_routes; i++)\n\t\tif (cur == routes[i].from_comp && next == routes[i].to_comp)\n\t\t\tmtk_mmsys_update_bits(mmsys, routes[i].addr, routes[i].mask, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_ddp_disconnect);\n\nvoid mtk_mmsys_merge_async_config(struct device *dev, int idx, int width, int height,\n\t\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev), MT8195_VDO1_MERGE0_ASYNC_CFG_WD + 0x10 * idx,\n\t\t\t      ~0, height << 16 | width, cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_merge_async_config);\n\nvoid mtk_mmsys_hdr_config(struct device *dev, int be_width, int be_height,\n\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev), MT8195_VDO1_HDRBE_ASYNC_CFG_WD, ~0,\n\t\t\t      be_height << 16 | be_width, cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_hdr_config);\n\nvoid mtk_mmsys_mixer_in_config(struct device *dev, int idx, bool alpha_sel, u16 alpha,\n\t\t\t       u8 mode, u32 biwidth, struct cmdq_pkt *cmdq_pkt)\n{\n\tstruct mtk_mmsys *mmsys = dev_get_drvdata(dev);\n\n\tmtk_mmsys_update_bits(mmsys, MT8195_VDO1_MIXER_IN1_ALPHA + (idx - 1) * 4, ~0,\n\t\t\t      alpha << 16 | alpha, cmdq_pkt);\n\tmtk_mmsys_update_bits(mmsys, MT8195_VDO1_HDR_TOP_CFG, BIT(19 + idx),\n\t\t\t      alpha_sel << (19 + idx), cmdq_pkt);\n\tmtk_mmsys_update_bits(mmsys, MT8195_VDO1_MIXER_IN1_PAD + (idx - 1) * 4,\n\t\t\t      GENMASK(31, 16) | GENMASK(1, 0), biwidth << 16 | mode, cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_mixer_in_config);\n\nvoid mtk_mmsys_mixer_in_channel_swap(struct device *dev, int idx, bool channel_swap,\n\t\t\t\t     struct cmdq_pkt *cmdq_pkt)\n{\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev), MT8195_VDO1_MIXER_IN1_PAD + (idx - 1) * 4,\n\t\t\t      BIT(4), channel_swap << 4, cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_mixer_in_channel_swap);\n\nvoid mtk_mmsys_ddp_dpi_fmt_config(struct device *dev, u32 val)\n{\n\tstruct mtk_mmsys *mmsys = dev_get_drvdata(dev);\n\n\tswitch (val) {\n\tcase MTK_DPI_RGB888_SDR_CON:\n\t\tmtk_mmsys_update_bits(mmsys, MT8186_MMSYS_DPI_OUTPUT_FORMAT,\n\t\t\t\t      MT8186_DPI_FORMAT_MASK, MT8186_DPI_RGB888_SDR_CON, NULL);\n\t\tbreak;\n\tcase MTK_DPI_RGB565_SDR_CON:\n\t\tmtk_mmsys_update_bits(mmsys, MT8186_MMSYS_DPI_OUTPUT_FORMAT,\n\t\t\t\t      MT8186_DPI_FORMAT_MASK, MT8186_DPI_RGB565_SDR_CON, NULL);\n\t\tbreak;\n\tcase MTK_DPI_RGB565_DDR_CON:\n\t\tmtk_mmsys_update_bits(mmsys, MT8186_MMSYS_DPI_OUTPUT_FORMAT,\n\t\t\t\t      MT8186_DPI_FORMAT_MASK, MT8186_DPI_RGB565_DDR_CON, NULL);\n\t\tbreak;\n\tcase MTK_DPI_RGB888_DDR_CON:\n\tdefault:\n\t\tmtk_mmsys_update_bits(mmsys, MT8186_MMSYS_DPI_OUTPUT_FORMAT,\n\t\t\t\t      MT8186_DPI_FORMAT_MASK, MT8186_DPI_RGB888_DDR_CON, NULL);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_ddp_dpi_fmt_config);\n\nvoid mtk_mmsys_vpp_rsz_merge_config(struct device *dev, u32 id, bool enable,\n\t\t\t\t    struct cmdq_pkt *cmdq_pkt)\n{\n\tu32 reg;\n\n\tswitch (id) {\n\tcase 2:\n\t\treg = MT8195_SVPP2_BUF_BF_RSZ_SWITCH;\n\t\tbreak;\n\tcase 3:\n\t\treg = MT8195_SVPP3_BUF_BF_RSZ_SWITCH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid id %d\\n\", id);\n\t\treturn;\n\t}\n\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev), reg, ~0, enable, cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_vpp_rsz_merge_config);\n\nvoid mtk_mmsys_vpp_rsz_dcm_config(struct device *dev, bool enable,\n\t\t\t\t  struct cmdq_pkt *cmdq_pkt)\n{\n\tu32 client;\n\n\tclient = MT8195_SVPP1_MDP_RSZ;\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev),\n\t\t\t      MT8195_VPP1_HW_DCM_1ST_DIS0, client,\n\t\t\t      ((enable) ? client : 0), cmdq_pkt);\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev),\n\t\t\t      MT8195_VPP1_HW_DCM_2ND_DIS0, client,\n\t\t\t      ((enable) ? client : 0), cmdq_pkt);\n\n\tclient = MT8195_SVPP2_MDP_RSZ | MT8195_SVPP3_MDP_RSZ;\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev),\n\t\t\t      MT8195_VPP1_HW_DCM_1ST_DIS1, client,\n\t\t\t      ((enable) ? client : 0), cmdq_pkt);\n\tmtk_mmsys_update_bits(dev_get_drvdata(dev),\n\t\t\t      MT8195_VPP1_HW_DCM_2ND_DIS1, client,\n\t\t\t      ((enable) ? client : 0), cmdq_pkt);\n}\nEXPORT_SYMBOL_GPL(mtk_mmsys_vpp_rsz_dcm_config);\n\nstatic int mtk_mmsys_reset_update(struct reset_controller_dev *rcdev, unsigned long id,\n\t\t\t\t  bool assert)\n{\n\tstruct mtk_mmsys *mmsys = container_of(rcdev, struct mtk_mmsys, rcdev);\n\tunsigned long flags;\n\tu32 offset;\n\tu32 reg;\n\n\toffset = (id / MMSYS_SW_RESET_PER_REG) * sizeof(u32);\n\tid = id % MMSYS_SW_RESET_PER_REG;\n\treg = mmsys->data->sw0_rst_offset + offset;\n\n\tspin_lock_irqsave(&mmsys->lock, flags);\n\n\tif (assert)\n\t\tmtk_mmsys_update_bits(mmsys, reg, BIT(id), 0, NULL);\n\telse\n\t\tmtk_mmsys_update_bits(mmsys, reg, BIT(id), BIT(id), NULL);\n\n\tspin_unlock_irqrestore(&mmsys->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtk_mmsys_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\treturn mtk_mmsys_reset_update(rcdev, id, true);\n}\n\nstatic int mtk_mmsys_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\treturn mtk_mmsys_reset_update(rcdev, id, false);\n}\n\nstatic int mtk_mmsys_reset(struct reset_controller_dev *rcdev, unsigned long id)\n{\n\tint ret;\n\n\tret = mtk_mmsys_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(1000, 1100);\n\n\treturn mtk_mmsys_reset_deassert(rcdev, id);\n}\n\nstatic const struct reset_control_ops mtk_mmsys_reset_ops = {\n\t.assert = mtk_mmsys_reset_assert,\n\t.deassert = mtk_mmsys_reset_deassert,\n\t.reset = mtk_mmsys_reset,\n};\n\nstatic int mtk_mmsys_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct platform_device *clks;\n\tstruct platform_device *drm;\n\tstruct mtk_mmsys *mmsys;\n\tint ret;\n\n\tmmsys = devm_kzalloc(dev, sizeof(*mmsys), GFP_KERNEL);\n\tif (!mmsys)\n\t\treturn -ENOMEM;\n\n\tmmsys->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmsys->regs)) {\n\t\tret = PTR_ERR(mmsys->regs);\n\t\tdev_err(dev, \"Failed to ioremap mmsys registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmmsys->data = of_device_get_match_data(&pdev->dev);\n\n\tif (mmsys->data->num_resets > 0) {\n\t\tspin_lock_init(&mmsys->lock);\n\n\t\tmmsys->rcdev.owner = THIS_MODULE;\n\t\tmmsys->rcdev.nr_resets = mmsys->data->num_resets;\n\t\tmmsys->rcdev.ops = &mtk_mmsys_reset_ops;\n\t\tmmsys->rcdev.of_node = pdev->dev.of_node;\n\t\tret = devm_reset_controller_register(&pdev->dev, &mmsys->rcdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't register mmsys reset controller: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = cmdq_dev_get_client_reg(dev, &mmsys->cmdq_base, 0);\n\tif (ret)\n\t\tdev_dbg(dev, \"No mediatek,gce-client-reg!\\n\");\n\n\tplatform_set_drvdata(pdev, mmsys);\n\n\tclks = platform_device_register_data(&pdev->dev, mmsys->data->clk_driver,\n\t\t\t\t\t     PLATFORM_DEVID_AUTO, NULL, 0);\n\tif (IS_ERR(clks))\n\t\treturn PTR_ERR(clks);\n\tmmsys->clks_pdev = clks;\n\n\tif (mmsys->data->is_vppsys)\n\t\tgoto out_probe_done;\n\n\tdrm = platform_device_register_data(&pdev->dev, \"mediatek-drm\",\n\t\t\t\t\t    PLATFORM_DEVID_AUTO, NULL, 0);\n\tif (IS_ERR(drm)) {\n\t\tplatform_device_unregister(clks);\n\t\treturn PTR_ERR(drm);\n\t}\n\tmmsys->drm_pdev = drm;\n\nout_probe_done:\n\treturn 0;\n}\n\nstatic int mtk_mmsys_remove(struct platform_device *pdev)\n{\n\tstruct mtk_mmsys *mmsys = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(mmsys->drm_pdev);\n\tplatform_device_unregister(mmsys->clks_pdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_match_mtk_mmsys[] = {\n\t{ .compatible = \"mediatek,mt2701-mmsys\", .data = &mt2701_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt2712-mmsys\", .data = &mt2712_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt6779-mmsys\", .data = &mt6779_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt6795-mmsys\", .data = &mt6795_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt6797-mmsys\", .data = &mt6797_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt8167-mmsys\", .data = &mt8167_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt8173-mmsys\", .data = &mt8173_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt8183-mmsys\", .data = &mt8183_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt8186-mmsys\", .data = &mt8186_mmsys_driver_data },\n\t{ .compatible = \"mediatek,mt8188-vdosys0\", .data = &mt8188_vdosys0_driver_data },\n\t{ .compatible = \"mediatek,mt8192-mmsys\", .data = &mt8192_mmsys_driver_data },\n\t \n\t{ .compatible = \"mediatek,mt8195-mmsys\", .data = &mt8195_vdosys0_driver_data },\n\t{ .compatible = \"mediatek,mt8195-vdosys0\", .data = &mt8195_vdosys0_driver_data },\n\t{ .compatible = \"mediatek,mt8195-vdosys1\", .data = &mt8195_vdosys1_driver_data },\n\t{ .compatible = \"mediatek,mt8195-vppsys0\", .data = &mt8195_vppsys0_driver_data },\n\t{ .compatible = \"mediatek,mt8195-vppsys1\", .data = &mt8195_vppsys1_driver_data },\n\t{ .compatible = \"mediatek,mt8365-mmsys\", .data = &mt8365_mmsys_driver_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_match_mtk_mmsys);\n\nstatic struct platform_driver mtk_mmsys_drv = {\n\t.driver = {\n\t\t.name = \"mtk-mmsys\",\n\t\t.of_match_table = of_match_mtk_mmsys,\n\t},\n\t.probe = mtk_mmsys_probe,\n\t.remove = mtk_mmsys_remove,\n};\nmodule_platform_driver(mtk_mmsys_drv);\n\nMODULE_AUTHOR(\"Yongqiang Niu <yongqiang.niu@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek SoC MMSYS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}