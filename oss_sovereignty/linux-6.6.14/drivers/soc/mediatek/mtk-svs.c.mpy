{
  "module_name": "mtk-svs.c",
  "hash_id": "06cf1cb7e5041cb05d1abac35a93893719e5c6467437640cef3fa5f66f023676",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/mediatek/mtk-svs.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/thermal.h>\n\n \n#define SVSB_CPU_LITTLE\t\t\tBIT(0)\n#define SVSB_CPU_BIG\t\t\tBIT(1)\n#define SVSB_CCI\t\t\tBIT(2)\n#define SVSB_GPU\t\t\tBIT(3)\n\n \n#define SVSB_LOW\t\t\tBIT(8)\n#define SVSB_HIGH\t\t\tBIT(9)\n\n \n#define SVSB_MODE_ALL_DISABLE\t\t0\n#define SVSB_MODE_INIT01\t\tBIT(1)\n#define SVSB_MODE_INIT02\t\tBIT(2)\n#define SVSB_MODE_MON\t\t\tBIT(3)\n\n \n#define SVSB_INIT01_PD_REQ\t\tBIT(0)\n#define SVSB_INIT01_VOLT_IGNORE\t\tBIT(1)\n#define SVSB_INIT01_VOLT_INC_ONLY\tBIT(2)\n#define SVSB_MON_VOLT_IGNORE\t\tBIT(16)\n#define SVSB_REMOVE_DVTFIXED_VOLT\tBIT(24)\n\n \n#define SVSB_PTPCONFIG_DETMAX\t\tGENMASK(15, 0)\n#define SVSB_DET_MAX\t\t\tFIELD_PREP(SVSB_PTPCONFIG_DETMAX, 0xffff)\n#define SVSB_DET_WINDOW\t\t\t0xa28\n\n \n#define SVSB_DESCHAR_FLD_MDES\t\tGENMASK(7, 0)\n#define SVSB_DESCHAR_FLD_BDES\t\tGENMASK(15, 8)\n\n \n#define SVSB_TEMPCHAR_FLD_DVT_FIXED\tGENMASK(7, 0)\n#define SVSB_TEMPCHAR_FLD_MTDES\t\tGENMASK(15, 8)\n#define SVSB_TEMPCHAR_FLD_VCO\t\tGENMASK(23, 16)\n\n \n#define SVSB_DETCHAR_FLD_DCMDET\t\tGENMASK(7, 0)\n#define SVSB_DETCHAR_FLD_DCBDET\t\tGENMASK(15, 8)\n\n \n#define SVSB_PTPEN_INIT01\t\tBIT(0)\n#define SVSB_PTPEN_MON\t\t\tBIT(1)\n#define SVSB_PTPEN_INIT02\t\t(SVSB_PTPEN_INIT01 | BIT(2))\n#define SVSB_PTPEN_OFF\t\t\t0x0\n\n \n#define SVSB_FREQPCTS_FLD_PCT0_4\tGENMASK(7, 0)\n#define SVSB_FREQPCTS_FLD_PCT1_5\tGENMASK(15, 8)\n#define SVSB_FREQPCTS_FLD_PCT2_6\tGENMASK(23, 16)\n#define SVSB_FREQPCTS_FLD_PCT3_7\tGENMASK(31, 24)\n\n \n#define SVSB_INTSTS_VAL_CLEAN\t\t0x00ffffff\n#define SVSB_INTSTS_F0_COMPLETE\t\tBIT(0)\n#define SVSB_INTSTS_FLD_MONVOP\t\tGENMASK(23, 16)\n#define SVSB_RUNCONFIG_DEFAULT\t\t0x80000000\n\n \n#define SVSB_LIMITVALS_FLD_DTLO\t\tGENMASK(7, 0)\n#define SVSB_LIMITVALS_FLD_DTHI\t\tGENMASK(15, 8)\n#define SVSB_LIMITVALS_FLD_VMIN\t\tGENMASK(23, 16)\n#define SVSB_LIMITVALS_FLD_VMAX\t\tGENMASK(31, 24)\n#define SVSB_VAL_DTHI\t\t\t0x1\n#define SVSB_VAL_DTLO\t\t\t0xfe\n\n \n#define SVSB_INTEN_F0EN\t\t\tBIT(0)\n#define SVSB_INTEN_DACK0UPEN\t\tBIT(8)\n#define SVSB_INTEN_DC0EN\t\tBIT(9)\n#define SVSB_INTEN_DC1EN\t\tBIT(10)\n#define SVSB_INTEN_DACK0LOEN\t\tBIT(11)\n#define SVSB_INTEN_INITPROD_OVF_EN\tBIT(12)\n#define SVSB_INTEN_INITSUM_OVF_EN\tBIT(14)\n#define SVSB_INTEN_MONVOPEN\t\tGENMASK(23, 16)\n#define SVSB_INTEN_INIT0x\t\t(SVSB_INTEN_F0EN | SVSB_INTEN_DACK0UPEN |\t\\\n\t\t\t\t\t SVSB_INTEN_DC0EN | SVSB_INTEN_DC1EN |\t\t\\\n\t\t\t\t\t SVSB_INTEN_DACK0LOEN |\t\t\t\t\\\n\t\t\t\t\t SVSB_INTEN_INITPROD_OVF_EN |\t\t\t\\\n\t\t\t\t\t SVSB_INTEN_INITSUM_OVF_EN)\n\n \n#define SVSB_TSCALCS_FLD_MTS\t\tGENMASK(11, 0)\n#define SVSB_TSCALCS_FLD_BTS\t\tGENMASK(23, 12)\n\n \n#define SVSB_INIT2VALS_FLD_DCVOFFSETIN\tGENMASK(15, 0)\n#define SVSB_INIT2VALS_FLD_AGEVOFFSETIN\tGENMASK(31, 16)\n\n \n#define SVSB_VOPS_FLD_VOP0_4\t\tGENMASK(7, 0)\n#define SVSB_VOPS_FLD_VOP1_5\t\tGENMASK(15, 8)\n#define SVSB_VOPS_FLD_VOP2_6\t\tGENMASK(23, 16)\n#define SVSB_VOPS_FLD_VOP3_7\t\tGENMASK(31, 24)\n\n \n#define BITS8\t\t\t\t8\n#define MAX_OPP_ENTRIES\t\t\t16\n#define REG_BYTES\t\t\t4\n#define SVSB_DC_SIGNED_BIT\t\tBIT(15)\n#define SVSB_DET_CLK_EN\t\t\tBIT(31)\n#define SVSB_TEMP_LOWER_BOUND\t\t0xb2\n#define SVSB_TEMP_UPPER_BOUND\t\t0x64\n\nstatic DEFINE_SPINLOCK(svs_lock);\n\n#ifdef CONFIG_DEBUG_FS\n#define debug_fops_ro(name)\t\t\t\t\t\t\\\n\tstatic int svs_##name##_debug_open(struct inode *inode,\t\t\\\n\t\t\t\t\t   struct file *filp)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn single_open(filp, svs_##name##_debug_show,\t\\\n\t\t\t\t   inode->i_private);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic const struct file_operations svs_##name##_debug_fops = {\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t\\\n\t\t.open = svs_##name##_debug_open,\t\t\t\\\n\t\t.read = seq_read,\t\t\t\t\t\\\n\t\t.llseek = seq_lseek,\t\t\t\t\t\\\n\t\t.release = single_release,\t\t\t\t\\\n\t}\n\n#define debug_fops_rw(name)\t\t\t\t\t\t\\\n\tstatic int svs_##name##_debug_open(struct inode *inode,\t\t\\\n\t\t\t\t\t   struct file *filp)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn single_open(filp, svs_##name##_debug_show,\t\\\n\t\t\t\t   inode->i_private);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic const struct file_operations svs_##name##_debug_fops = {\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t\\\n\t\t.open = svs_##name##_debug_open,\t\t\t\\\n\t\t.read = seq_read,\t\t\t\t\t\\\n\t\t.write = svs_##name##_debug_write,\t\t\t\\\n\t\t.llseek = seq_lseek,\t\t\t\t\t\\\n\t\t.release = single_release,\t\t\t\t\\\n\t}\n\n#define svs_dentry_data(name)\t{__stringify(name), &svs_##name##_debug_fops}\n#endif\n\n \nenum svsb_phase {\n\tSVSB_PHASE_ERROR = 0,\n\tSVSB_PHASE_INIT01,\n\tSVSB_PHASE_INIT02,\n\tSVSB_PHASE_MON,\n\tSVSB_PHASE_MAX,\n};\n\nenum svs_reg_index {\n\tDESCHAR = 0,\n\tTEMPCHAR,\n\tDETCHAR,\n\tAGECHAR,\n\tDCCONFIG,\n\tAGECONFIG,\n\tFREQPCT30,\n\tFREQPCT74,\n\tLIMITVALS,\n\tVBOOT,\n\tDETWINDOW,\n\tCONFIG,\n\tTSCALCS,\n\tRUNCONFIG,\n\tSVSEN,\n\tINIT2VALS,\n\tDCVALUES,\n\tAGEVALUES,\n\tVOP30,\n\tVOP74,\n\tTEMP,\n\tINTSTS,\n\tINTSTSRAW,\n\tINTEN,\n\tCHKINT,\n\tCHKSHIFT,\n\tSTATUS,\n\tVDESIGN30,\n\tVDESIGN74,\n\tDVT30,\n\tDVT74,\n\tAGECOUNT,\n\tSMSTATE0,\n\tSMSTATE1,\n\tCTL0,\n\tDESDETSEC,\n\tTEMPAGESEC,\n\tCTRLSPARE0,\n\tCTRLSPARE1,\n\tCTRLSPARE2,\n\tCTRLSPARE3,\n\tCORESEL,\n\tTHERMINTST,\n\tINTST,\n\tTHSTAGE0ST,\n\tTHSTAGE1ST,\n\tTHSTAGE2ST,\n\tTHAHBST0,\n\tTHAHBST1,\n\tSPARE0,\n\tSPARE1,\n\tSPARE2,\n\tSPARE3,\n\tTHSLPEVEB,\n\tSVS_REG_MAX,\n};\n\nstatic const u32 svs_regs_v2[] = {\n\t[DESCHAR]\t\t= 0xc00,\n\t[TEMPCHAR]\t\t= 0xc04,\n\t[DETCHAR]\t\t= 0xc08,\n\t[AGECHAR]\t\t= 0xc0c,\n\t[DCCONFIG]\t\t= 0xc10,\n\t[AGECONFIG]\t\t= 0xc14,\n\t[FREQPCT30]\t\t= 0xc18,\n\t[FREQPCT74]\t\t= 0xc1c,\n\t[LIMITVALS]\t\t= 0xc20,\n\t[VBOOT]\t\t\t= 0xc24,\n\t[DETWINDOW]\t\t= 0xc28,\n\t[CONFIG]\t\t= 0xc2c,\n\t[TSCALCS]\t\t= 0xc30,\n\t[RUNCONFIG]\t\t= 0xc34,\n\t[SVSEN]\t\t\t= 0xc38,\n\t[INIT2VALS]\t\t= 0xc3c,\n\t[DCVALUES]\t\t= 0xc40,\n\t[AGEVALUES]\t\t= 0xc44,\n\t[VOP30]\t\t\t= 0xc48,\n\t[VOP74]\t\t\t= 0xc4c,\n\t[TEMP]\t\t\t= 0xc50,\n\t[INTSTS]\t\t= 0xc54,\n\t[INTSTSRAW]\t\t= 0xc58,\n\t[INTEN]\t\t\t= 0xc5c,\n\t[CHKINT]\t\t= 0xc60,\n\t[CHKSHIFT]\t\t= 0xc64,\n\t[STATUS]\t\t= 0xc68,\n\t[VDESIGN30]\t\t= 0xc6c,\n\t[VDESIGN74]\t\t= 0xc70,\n\t[DVT30]\t\t\t= 0xc74,\n\t[DVT74]\t\t\t= 0xc78,\n\t[AGECOUNT]\t\t= 0xc7c,\n\t[SMSTATE0]\t\t= 0xc80,\n\t[SMSTATE1]\t\t= 0xc84,\n\t[CTL0]\t\t\t= 0xc88,\n\t[DESDETSEC]\t\t= 0xce0,\n\t[TEMPAGESEC]\t\t= 0xce4,\n\t[CTRLSPARE0]\t\t= 0xcf0,\n\t[CTRLSPARE1]\t\t= 0xcf4,\n\t[CTRLSPARE2]\t\t= 0xcf8,\n\t[CTRLSPARE3]\t\t= 0xcfc,\n\t[CORESEL]\t\t= 0xf00,\n\t[THERMINTST]\t\t= 0xf04,\n\t[INTST]\t\t\t= 0xf08,\n\t[THSTAGE0ST]\t\t= 0xf0c,\n\t[THSTAGE1ST]\t\t= 0xf10,\n\t[THSTAGE2ST]\t\t= 0xf14,\n\t[THAHBST0]\t\t= 0xf18,\n\t[THAHBST1]\t\t= 0xf1c,\n\t[SPARE0]\t\t= 0xf20,\n\t[SPARE1]\t\t= 0xf24,\n\t[SPARE2]\t\t= 0xf28,\n\t[SPARE3]\t\t= 0xf2c,\n\t[THSLPEVEB]\t\t= 0xf30,\n};\n\n \nstruct svs_platform {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct clk *main_clk;\n\tstruct svs_bank *pbank;\n\tstruct svs_bank *banks;\n\tstruct reset_control *rst;\n\tsize_t efuse_max;\n\tsize_t tefuse_max;\n\tconst u32 *regs;\n\tu32 bank_max;\n\tu32 *efuse;\n\tu32 *tefuse;\n};\n\nstruct svs_platform_data {\n\tchar *name;\n\tstruct svs_bank *banks;\n\tbool (*efuse_parsing)(struct svs_platform *svsp);\n\tint (*probe)(struct svs_platform *svsp);\n\tconst u32 *regs;\n\tu32 bank_max;\n};\n\n \nstruct svs_bank {\n\tstruct device *dev;\n\tstruct device *opp_dev;\n\tstruct completion init_completion;\n\tstruct regulator *buck;\n\tstruct thermal_zone_device *tzd;\n\tstruct mutex lock;\t \n\tvoid (*set_freq_pct)(struct svs_platform *svsp);\n\tvoid (*get_volts)(struct svs_platform *svsp);\n\tchar *name;\n\tchar *buck_name;\n\tchar *tzone_name;\n\tenum svsb_phase phase;\n\ts32 volt_od;\n\tu32 reg_data[SVSB_PHASE_MAX][SVS_REG_MAX];\n\tu32 pm_runtime_enabled_count;\n\tu32 mode_support;\n\tu32 freq_base;\n\tu32 turn_freq_base;\n\tu32 vboot;\n\tu32 opp_dfreq[MAX_OPP_ENTRIES];\n\tu32 opp_dvolt[MAX_OPP_ENTRIES];\n\tu32 freq_pct[MAX_OPP_ENTRIES];\n\tu32 volt[MAX_OPP_ENTRIES];\n\tu32 volt_step;\n\tu32 volt_base;\n\tu32 volt_flags;\n\tu32 vmax;\n\tu32 vmin;\n\tu32 age_config;\n\tu32 age_voffset_in;\n\tu32 dc_config;\n\tu32 dc_voffset_in;\n\tu32 dvt_fixed;\n\tu32 vco;\n\tu32 chk_shift;\n\tu32 core_sel;\n\tu32 opp_count;\n\tu32 int_st;\n\tu32 sw_id;\n\tu32 cpu_id;\n\tu32 ctl0;\n\tu32 temp;\n\tu32 tzone_htemp;\n\tu32 tzone_htemp_voffset;\n\tu32 tzone_ltemp;\n\tu32 tzone_ltemp_voffset;\n\tu32 bts;\n\tu32 mts;\n\tu32 bdes;\n\tu32 mdes;\n\tu32 mtdes;\n\tu32 dcbdet;\n\tu32 dcmdet;\n\tu32 turn_pt;\n\tu32 type;\n};\n\nstatic u32 percent(u32 numerator, u32 denominator)\n{\n\t \n\tnumerator /= 1000;\n\tdenominator /= 1000;\n\n\treturn DIV_ROUND_UP(numerator * 100, denominator);\n}\n\nstatic u32 svs_readl_relaxed(struct svs_platform *svsp, enum svs_reg_index rg_i)\n{\n\treturn readl_relaxed(svsp->base + svsp->regs[rg_i]);\n}\n\nstatic void svs_writel_relaxed(struct svs_platform *svsp, u32 val,\n\t\t\t       enum svs_reg_index rg_i)\n{\n\twritel_relaxed(val, svsp->base + svsp->regs[rg_i]);\n}\n\nstatic void svs_switch_bank(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\n\tsvs_writel_relaxed(svsp, svsb->core_sel, CORESEL);\n}\n\nstatic u32 svs_bank_volt_to_opp_volt(u32 svsb_volt, u32 svsb_volt_step,\n\t\t\t\t     u32 svsb_volt_base)\n{\n\treturn (svsb_volt * svsb_volt_step) + svsb_volt_base;\n}\n\nstatic u32 svs_opp_volt_to_bank_volt(u32 opp_u_volt, u32 svsb_volt_step,\n\t\t\t\t     u32 svsb_volt_base)\n{\n\treturn (opp_u_volt - svsb_volt_base) / svsb_volt_step;\n}\n\nstatic int svs_sync_bank_volts_from_opp(struct svs_bank *svsb)\n{\n\tstruct dev_pm_opp *opp;\n\tu32 i, opp_u_volt;\n\n\tfor (i = 0; i < svsb->opp_count; i++) {\n\t\topp = dev_pm_opp_find_freq_exact(svsb->opp_dev,\n\t\t\t\t\t\t svsb->opp_dfreq[i],\n\t\t\t\t\t\t true);\n\t\tif (IS_ERR(opp)) {\n\t\t\tdev_err(svsb->dev, \"cannot find freq = %u (%ld)\\n\",\n\t\t\t\tsvsb->opp_dfreq[i], PTR_ERR(opp));\n\t\t\treturn PTR_ERR(opp);\n\t\t}\n\n\t\topp_u_volt = dev_pm_opp_get_voltage(opp);\n\t\tsvsb->volt[i] = svs_opp_volt_to_bank_volt(opp_u_volt,\n\t\t\t\t\t\t\t  svsb->volt_step,\n\t\t\t\t\t\t\t  svsb->volt_base);\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\treturn 0;\n}\n\nstatic int svs_adjust_pm_opp_volts(struct svs_bank *svsb)\n{\n\tint ret = -EPERM, tzone_temp = 0;\n\tu32 i, svsb_volt, opp_volt, temp_voffset = 0, opp_start, opp_stop;\n\n\tmutex_lock(&svsb->lock);\n\n\t \n\tif (svsb->type == SVSB_HIGH) {\n\t\topp_start = 0;\n\t\topp_stop = svsb->turn_pt;\n\t} else if (svsb->type == SVSB_LOW) {\n\t\topp_start = svsb->turn_pt;\n\t\topp_stop = svsb->opp_count;\n\t} else {\n\t\topp_start = 0;\n\t\topp_stop = svsb->opp_count;\n\t}\n\n\t \n\tif (!IS_ERR_OR_NULL(svsb->tzd)) {\n\t\tret = thermal_zone_get_temp(svsb->tzd, &tzone_temp);\n\t\tif (ret || (svsb->temp > SVSB_TEMP_UPPER_BOUND &&\n\t\t\t    svsb->temp < SVSB_TEMP_LOWER_BOUND)) {\n\t\t\tdev_err(svsb->dev, \"%s: %d (0x%x), run default volts\\n\",\n\t\t\t\tsvsb->tzone_name, ret, svsb->temp);\n\t\t\tsvsb->phase = SVSB_PHASE_ERROR;\n\t\t}\n\n\t\tif (tzone_temp >= svsb->tzone_htemp)\n\t\t\ttemp_voffset += svsb->tzone_htemp_voffset;\n\t\telse if (tzone_temp <= svsb->tzone_ltemp)\n\t\t\ttemp_voffset += svsb->tzone_ltemp_voffset;\n\n\t\t \n\t\tif (svsb->phase == SVSB_PHASE_MON && (svsb->type == SVSB_HIGH ||\n\t\t\t\t\t\t      svsb->type == SVSB_LOW)) {\n\t\t\topp_start = 0;\n\t\t\topp_stop = svsb->opp_count;\n\t\t}\n\t}\n\n\t \n\tfor (i = opp_start; i < opp_stop; i++) {\n\t\tswitch (svsb->phase) {\n\t\tcase SVSB_PHASE_ERROR:\n\t\t\topp_volt = svsb->opp_dvolt[i];\n\t\t\tbreak;\n\t\tcase SVSB_PHASE_INIT01:\n\t\t\t \n\t\t\tgoto unlock_mutex;\n\t\tcase SVSB_PHASE_INIT02:\n\t\tcase SVSB_PHASE_MON:\n\t\t\tsvsb_volt = max(svsb->volt[i] + temp_voffset, svsb->vmin);\n\t\t\topp_volt = svs_bank_volt_to_opp_volt(svsb_volt,\n\t\t\t\t\t\t\t     svsb->volt_step,\n\t\t\t\t\t\t\t     svsb->volt_base);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(svsb->dev, \"unknown phase: %u\\n\", svsb->phase);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_mutex;\n\t\t}\n\n\t\topp_volt = min(opp_volt, svsb->opp_dvolt[i]);\n\t\tret = dev_pm_opp_adjust_voltage(svsb->opp_dev,\n\t\t\t\t\t\tsvsb->opp_dfreq[i],\n\t\t\t\t\t\topp_volt, opp_volt,\n\t\t\t\t\t\tsvsb->opp_dvolt[i]);\n\t\tif (ret) {\n\t\t\tdev_err(svsb->dev, \"set %uuV fail: %d\\n\",\n\t\t\t\topp_volt, ret);\n\t\t\tgoto unlock_mutex;\n\t\t}\n\t}\n\nunlock_mutex:\n\tmutex_unlock(&svsb->lock);\n\n\treturn ret;\n}\n\nstatic void svs_bank_disable_and_restore_default_volts(struct svs_platform *svsp,\n\t\t\t\t\t\t       struct svs_bank *svsb)\n{\n\tunsigned long flags;\n\n\tif (svsb->mode_support == SVSB_MODE_ALL_DISABLE)\n\t\treturn;\n\n\tspin_lock_irqsave(&svs_lock, flags);\n\tsvsp->pbank = svsb;\n\tsvs_switch_bank(svsp);\n\tsvs_writel_relaxed(svsp, SVSB_PTPEN_OFF, SVSEN);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_VAL_CLEAN, INTSTS);\n\tspin_unlock_irqrestore(&svs_lock, flags);\n\n\tsvsb->phase = SVSB_PHASE_ERROR;\n\tsvs_adjust_pm_opp_volts(svsb);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int svs_dump_debug_show(struct seq_file *m, void *p)\n{\n\tstruct svs_platform *svsp = (struct svs_platform *)m->private;\n\tstruct svs_bank *svsb;\n\tunsigned long svs_reg_addr;\n\tu32 idx, i, j, bank_id;\n\n\tfor (i = 0; i < svsp->efuse_max; i++)\n\t\tif (svsp->efuse && svsp->efuse[i])\n\t\t\tseq_printf(m, \"M_HW_RES%d = 0x%08x\\n\",\n\t\t\t\t   i, svsp->efuse[i]);\n\n\tfor (i = 0; i < svsp->tefuse_max; i++)\n\t\tif (svsp->tefuse)\n\t\t\tseq_printf(m, \"THERMAL_EFUSE%d = 0x%08x\\n\",\n\t\t\t\t   i, svsp->tefuse[i]);\n\n\tfor (bank_id = 0, idx = 0; idx < svsp->bank_max; idx++, bank_id++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tfor (i = SVSB_PHASE_INIT01; i <= SVSB_PHASE_MON; i++) {\n\t\t\tseq_printf(m, \"Bank_number = %u\\n\", bank_id);\n\n\t\t\tif (i == SVSB_PHASE_INIT01 || i == SVSB_PHASE_INIT02)\n\t\t\t\tseq_printf(m, \"mode = init%d\\n\", i);\n\t\t\telse if (i == SVSB_PHASE_MON)\n\t\t\t\tseq_puts(m, \"mode = mon\\n\");\n\t\t\telse\n\t\t\t\tseq_puts(m, \"mode = error\\n\");\n\n\t\t\tfor (j = DESCHAR; j < SVS_REG_MAX; j++) {\n\t\t\t\tsvs_reg_addr = (unsigned long)(svsp->base +\n\t\t\t\t\t\t\t       svsp->regs[j]);\n\t\t\t\tseq_printf(m, \"0x%08lx = 0x%08x\\n\",\n\t\t\t\t\t   svs_reg_addr, svsb->reg_data[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\ndebug_fops_ro(dump);\n\nstatic int svs_enable_debug_show(struct seq_file *m, void *v)\n{\n\tstruct svs_bank *svsb = (struct svs_bank *)m->private;\n\n\tswitch (svsb->phase) {\n\tcase SVSB_PHASE_ERROR:\n\t\tseq_puts(m, \"disabled\\n\");\n\t\tbreak;\n\tcase SVSB_PHASE_INIT01:\n\t\tseq_puts(m, \"init1\\n\");\n\t\tbreak;\n\tcase SVSB_PHASE_INIT02:\n\t\tseq_puts(m, \"init2\\n\");\n\t\tbreak;\n\tcase SVSB_PHASE_MON:\n\t\tseq_puts(m, \"mon mode\\n\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"unknown\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t svs_enable_debug_write(struct file *filp,\n\t\t\t\t      const char __user *buffer,\n\t\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct svs_bank *svsb = file_inode(filp)->i_private;\n\tstruct svs_platform *svsp = dev_get_drvdata(svsb->dev);\n\tint enabled, ret;\n\tchar *buf = NULL;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = (char *)memdup_user_nul(buffer, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = kstrtoint(buf, 10, &enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enabled) {\n\t\tsvs_bank_disable_and_restore_default_volts(svsp, svsb);\n\t\tsvsb->mode_support = SVSB_MODE_ALL_DISABLE;\n\t}\n\n\tkfree(buf);\n\n\treturn count;\n}\n\ndebug_fops_rw(enable);\n\nstatic int svs_status_debug_show(struct seq_file *m, void *v)\n{\n\tstruct svs_bank *svsb = (struct svs_bank *)m->private;\n\tstruct dev_pm_opp *opp;\n\tint tzone_temp = 0, ret;\n\tu32 i;\n\n\tret = thermal_zone_get_temp(svsb->tzd, &tzone_temp);\n\tif (ret)\n\t\tseq_printf(m, \"%s: temperature ignore, turn_pt = %u\\n\",\n\t\t\t   svsb->name, svsb->turn_pt);\n\telse\n\t\tseq_printf(m, \"%s: temperature = %d, turn_pt = %u\\n\",\n\t\t\t   svsb->name, tzone_temp, svsb->turn_pt);\n\n\tfor (i = 0; i < svsb->opp_count; i++) {\n\t\topp = dev_pm_opp_find_freq_exact(svsb->opp_dev,\n\t\t\t\t\t\t svsb->opp_dfreq[i], true);\n\t\tif (IS_ERR(opp)) {\n\t\t\tseq_printf(m, \"%s: cannot find freq = %u (%ld)\\n\",\n\t\t\t\t   svsb->name, svsb->opp_dfreq[i],\n\t\t\t\t   PTR_ERR(opp));\n\t\t\treturn PTR_ERR(opp);\n\t\t}\n\n\t\tseq_printf(m, \"opp_freq[%02u]: %u, opp_volt[%02u]: %lu, \",\n\t\t\t   i, svsb->opp_dfreq[i], i,\n\t\t\t   dev_pm_opp_get_voltage(opp));\n\t\tseq_printf(m, \"svsb_volt[%02u]: 0x%x, freq_pct[%02u]: %u\\n\",\n\t\t\t   i, svsb->volt[i], i, svsb->freq_pct[i]);\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\treturn 0;\n}\n\ndebug_fops_ro(status);\n\nstatic int svs_create_debug_cmds(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tstruct dentry *svs_dir, *svsb_dir, *file_entry;\n\tconst char *d = \"/sys/kernel/debug/svs\";\n\tu32 i, idx;\n\n\tstruct svs_dentry {\n\t\tconst char *name;\n\t\tconst struct file_operations *fops;\n\t};\n\n\tstruct svs_dentry svs_entries[] = {\n\t\tsvs_dentry_data(dump),\n\t};\n\n\tstruct svs_dentry svsb_entries[] = {\n\t\tsvs_dentry_data(enable),\n\t\tsvs_dentry_data(status),\n\t};\n\n\tsvs_dir = debugfs_create_dir(\"svs\", NULL);\n\tif (IS_ERR(svs_dir)) {\n\t\tdev_err(svsp->dev, \"cannot create %s: %ld\\n\",\n\t\t\td, PTR_ERR(svs_dir));\n\t\treturn PTR_ERR(svs_dir);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(svs_entries); i++) {\n\t\tfile_entry = debugfs_create_file(svs_entries[i].name, 0664,\n\t\t\t\t\t\t svs_dir, svsp,\n\t\t\t\t\t\t svs_entries[i].fops);\n\t\tif (IS_ERR(file_entry)) {\n\t\t\tdev_err(svsp->dev, \"cannot create %s/%s: %ld\\n\",\n\t\t\t\td, svs_entries[i].name, PTR_ERR(file_entry));\n\t\t\treturn PTR_ERR(file_entry);\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (svsb->mode_support == SVSB_MODE_ALL_DISABLE)\n\t\t\tcontinue;\n\n\t\tsvsb_dir = debugfs_create_dir(svsb->name, svs_dir);\n\t\tif (IS_ERR(svsb_dir)) {\n\t\t\tdev_err(svsp->dev, \"cannot create %s/%s: %ld\\n\",\n\t\t\t\td, svsb->name, PTR_ERR(svsb_dir));\n\t\t\treturn PTR_ERR(svsb_dir);\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(svsb_entries); i++) {\n\t\t\tfile_entry = debugfs_create_file(svsb_entries[i].name,\n\t\t\t\t\t\t\t 0664, svsb_dir, svsb,\n\t\t\t\t\t\t\t svsb_entries[i].fops);\n\t\t\tif (IS_ERR(file_entry)) {\n\t\t\t\tdev_err(svsp->dev, \"no %s/%s/%s?: %ld\\n\",\n\t\t\t\t\td, svsb->name, svsb_entries[i].name,\n\t\t\t\t\tPTR_ERR(file_entry));\n\t\t\t\treturn PTR_ERR(file_entry);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif  \n\nstatic u32 interpolate(u32 f0, u32 f1, u32 v0, u32 v1, u32 fx)\n{\n\tu32 vx;\n\n\tif (v0 == v1 || f0 == f1)\n\t\treturn v0;\n\n\t \n\tvx = (v0 * 100) - ((((v0 - v1) * 100) / (f0 - f1)) * (f0 - fx));\n\n\treturn DIV_ROUND_UP(vx, 100);\n}\n\nstatic void svs_get_bank_volts_v3(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tu32 i, j, *vop, vop74, vop30, turn_pt = svsb->turn_pt;\n\tu32 b_sft, shift_byte = 0, opp_start = 0, opp_stop = 0;\n\tu32 middle_index = (svsb->opp_count / 2);\n\n\tif (svsb->phase == SVSB_PHASE_MON &&\n\t    svsb->volt_flags & SVSB_MON_VOLT_IGNORE)\n\t\treturn;\n\n\tvop74 = svs_readl_relaxed(svsp, VOP74);\n\tvop30 = svs_readl_relaxed(svsp, VOP30);\n\n\t \n\tif (turn_pt < middle_index) {\n\t\tif (svsb->type == SVSB_HIGH) {\n\t\t\t \n\t\t\tfor (i = 0; i < turn_pt; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tvop = (shift_byte < REG_BYTES) ? &vop30 :\n\t\t\t\t\t\t\t\t &vop74;\n\t\t\t\tsvsb->volt[i] = (*vop >> b_sft) & GENMASK(7, 0);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t} else if (svsb->type == SVSB_LOW) {\n\t\t\t \n\t\t\tj = svsb->opp_count - 7;\n\t\t\tsvsb->volt[turn_pt] = FIELD_GET(SVSB_VOPS_FLD_VOP0_4, vop30);\n\t\t\tshift_byte++;\n\t\t\tfor (i = j; i < svsb->opp_count; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tvop = (shift_byte < REG_BYTES) ? &vop30 :\n\t\t\t\t\t\t\t\t &vop74;\n\t\t\t\tsvsb->volt[i] = (*vop >> b_sft) & GENMASK(7, 0);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = turn_pt + 1; i < j; i++)\n\t\t\t\tsvsb->volt[i] = interpolate(svsb->freq_pct[turn_pt],\n\t\t\t\t\t\t\t    svsb->freq_pct[j],\n\t\t\t\t\t\t\t    svsb->volt[turn_pt],\n\t\t\t\t\t\t\t    svsb->volt[j],\n\t\t\t\t\t\t\t    svsb->freq_pct[i]);\n\t\t}\n\t} else {\n\t\tif (svsb->type == SVSB_HIGH) {\n\t\t\t \n\t\t\tj = turn_pt - 7;\n\t\t\tsvsb->volt[0] = FIELD_GET(SVSB_VOPS_FLD_VOP0_4, vop30);\n\t\t\tshift_byte++;\n\t\t\tfor (i = j; i < turn_pt; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tvop = (shift_byte < REG_BYTES) ? &vop30 :\n\t\t\t\t\t\t\t\t &vop74;\n\t\t\t\tsvsb->volt[i] = (*vop >> b_sft) & GENMASK(7, 0);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 1; i < j; i++)\n\t\t\t\tsvsb->volt[i] = interpolate(svsb->freq_pct[0],\n\t\t\t\t\t\t\t    svsb->freq_pct[j],\n\t\t\t\t\t\t\t    svsb->volt[0],\n\t\t\t\t\t\t\t    svsb->volt[j],\n\t\t\t\t\t\t\t    svsb->freq_pct[i]);\n\t\t} else if (svsb->type == SVSB_LOW) {\n\t\t\t \n\t\t\tfor (i = turn_pt; i < svsb->opp_count; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tvop = (shift_byte < REG_BYTES) ? &vop30 :\n\t\t\t\t\t\t\t\t &vop74;\n\t\t\t\tsvsb->volt[i] = (*vop >> b_sft) & GENMASK(7, 0);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (svsb->type == SVSB_HIGH) {\n\t\topp_start = 0;\n\t\topp_stop = svsb->turn_pt;\n\t} else if (svsb->type == SVSB_LOW) {\n\t\topp_start = svsb->turn_pt;\n\t\topp_stop = svsb->opp_count;\n\t}\n\n\tfor (i = opp_start; i < opp_stop; i++)\n\t\tif (svsb->volt_flags & SVSB_REMOVE_DVTFIXED_VOLT)\n\t\t\tsvsb->volt[i] -= svsb->dvt_fixed;\n}\n\nstatic void svs_set_bank_freq_pct_v3(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tu32 i, j, *freq_pct, freq_pct74 = 0, freq_pct30 = 0;\n\tu32 b_sft, shift_byte = 0, turn_pt;\n\tu32 middle_index = (svsb->opp_count / 2);\n\n\tfor (i = 0; i < svsb->opp_count; i++) {\n\t\tif (svsb->opp_dfreq[i] <= svsb->turn_freq_base) {\n\t\t\tsvsb->turn_pt = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tturn_pt = svsb->turn_pt;\n\n\t \n\tif (turn_pt < middle_index) {\n\t\tif (svsb->type == SVSB_HIGH) {\n\t\t\t \n\t\t\tif (turn_pt == 0)\n\t\t\t\tfreq_pct30 = svsb->freq_pct[0];\n\n\t\t\t \n\t\t\tfor (i = 0; i < turn_pt; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tfreq_pct = (shift_byte < REG_BYTES) ?\n\t\t\t\t\t   &freq_pct30 : &freq_pct74;\n\t\t\t\t*freq_pct |= (svsb->freq_pct[i] << b_sft);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t} else if (svsb->type == SVSB_LOW) {\n\t\t\t \n\t\t\tfreq_pct30 = svsb->freq_pct[turn_pt];\n\t\t\tshift_byte++;\n\t\t\tj = svsb->opp_count - 7;\n\t\t\tfor (i = j; i < svsb->opp_count; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tfreq_pct = (shift_byte < REG_BYTES) ?\n\t\t\t\t\t   &freq_pct30 : &freq_pct74;\n\t\t\t\t*freq_pct |= (svsb->freq_pct[i] << b_sft);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (svsb->type == SVSB_HIGH) {\n\t\t\t \n\t\t\tfreq_pct30 = svsb->freq_pct[0];\n\t\t\tshift_byte++;\n\t\t\tj = turn_pt - 7;\n\t\t\tfor (i = j; i < turn_pt; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tfreq_pct = (shift_byte < REG_BYTES) ?\n\t\t\t\t\t   &freq_pct30 : &freq_pct74;\n\t\t\t\t*freq_pct |= (svsb->freq_pct[i] << b_sft);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t} else if (svsb->type == SVSB_LOW) {\n\t\t\t \n\t\t\tfor (i = turn_pt; i < svsb->opp_count; i++) {\n\t\t\t\tb_sft = BITS8 * (shift_byte % REG_BYTES);\n\t\t\t\tfreq_pct = (shift_byte < REG_BYTES) ?\n\t\t\t\t\t   &freq_pct30 : &freq_pct74;\n\t\t\t\t*freq_pct |= (svsb->freq_pct[i] << b_sft);\n\t\t\t\tshift_byte++;\n\t\t\t}\n\t\t}\n\t}\n\n\tsvs_writel_relaxed(svsp, freq_pct74, FREQPCT74);\n\tsvs_writel_relaxed(svsp, freq_pct30, FREQPCT30);\n}\n\nstatic void svs_get_bank_volts_v2(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tu32 temp, i;\n\n\ttemp = svs_readl_relaxed(svsp, VOP74);\n\tsvsb->volt[14] = FIELD_GET(SVSB_VOPS_FLD_VOP3_7, temp);\n\tsvsb->volt[12] = FIELD_GET(SVSB_VOPS_FLD_VOP2_6, temp);\n\tsvsb->volt[10] = FIELD_GET(SVSB_VOPS_FLD_VOP1_5, temp);\n\tsvsb->volt[8] = FIELD_GET(SVSB_VOPS_FLD_VOP0_4, temp);\n\n\ttemp = svs_readl_relaxed(svsp, VOP30);\n\tsvsb->volt[6] = FIELD_GET(SVSB_VOPS_FLD_VOP3_7, temp);\n\tsvsb->volt[4] = FIELD_GET(SVSB_VOPS_FLD_VOP2_6, temp);\n\tsvsb->volt[2] = FIELD_GET(SVSB_VOPS_FLD_VOP1_5, temp);\n\tsvsb->volt[0] = FIELD_GET(SVSB_VOPS_FLD_VOP0_4, temp);\n\n\tfor (i = 0; i <= 12; i += 2)\n\t\tsvsb->volt[i + 1] = interpolate(svsb->freq_pct[i],\n\t\t\t\t\t\tsvsb->freq_pct[i + 2],\n\t\t\t\t\t\tsvsb->volt[i],\n\t\t\t\t\t\tsvsb->volt[i + 2],\n\t\t\t\t\t\tsvsb->freq_pct[i + 1]);\n\n\tsvsb->volt[15] = interpolate(svsb->freq_pct[12],\n\t\t\t\t     svsb->freq_pct[14],\n\t\t\t\t     svsb->volt[12],\n\t\t\t\t     svsb->volt[14],\n\t\t\t\t     svsb->freq_pct[15]);\n\n\tfor (i = 0; i < svsb->opp_count; i++)\n\t\tsvsb->volt[i] += svsb->volt_od;\n}\n\nstatic void svs_set_bank_freq_pct_v2(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tu32 freqpct74_val, freqpct30_val;\n\n\tfreqpct74_val = FIELD_PREP(SVSB_FREQPCTS_FLD_PCT0_4, svsb->freq_pct[8]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT1_5, svsb->freq_pct[10]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT2_6, svsb->freq_pct[12]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT3_7, svsb->freq_pct[14]);\n\n\tfreqpct30_val = FIELD_PREP(SVSB_FREQPCTS_FLD_PCT0_4, svsb->freq_pct[0]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT1_5, svsb->freq_pct[2]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT2_6, svsb->freq_pct[4]) |\n\t\t\tFIELD_PREP(SVSB_FREQPCTS_FLD_PCT3_7, svsb->freq_pct[6]);\n\n\tsvs_writel_relaxed(svsp, freqpct74_val, FREQPCT74);\n\tsvs_writel_relaxed(svsp, freqpct30_val, FREQPCT30);\n}\n\nstatic void svs_set_bank_phase(struct svs_platform *svsp,\n\t\t\t       enum svsb_phase target_phase)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tu32 des_char, temp_char, det_char, limit_vals, init2vals, ts_calcs;\n\n\tsvs_switch_bank(svsp);\n\n\tdes_char = FIELD_PREP(SVSB_DESCHAR_FLD_BDES, svsb->bdes) |\n\t\t   FIELD_PREP(SVSB_DESCHAR_FLD_MDES, svsb->mdes);\n\tsvs_writel_relaxed(svsp, des_char, DESCHAR);\n\n\ttemp_char = FIELD_PREP(SVSB_TEMPCHAR_FLD_VCO, svsb->vco) |\n\t\t    FIELD_PREP(SVSB_TEMPCHAR_FLD_MTDES, svsb->mtdes) |\n\t\t    FIELD_PREP(SVSB_TEMPCHAR_FLD_DVT_FIXED, svsb->dvt_fixed);\n\tsvs_writel_relaxed(svsp, temp_char, TEMPCHAR);\n\n\tdet_char = FIELD_PREP(SVSB_DETCHAR_FLD_DCBDET, svsb->dcbdet) |\n\t\t   FIELD_PREP(SVSB_DETCHAR_FLD_DCMDET, svsb->dcmdet);\n\tsvs_writel_relaxed(svsp, det_char, DETCHAR);\n\n\tsvs_writel_relaxed(svsp, svsb->dc_config, DCCONFIG);\n\tsvs_writel_relaxed(svsp, svsb->age_config, AGECONFIG);\n\tsvs_writel_relaxed(svsp, SVSB_RUNCONFIG_DEFAULT, RUNCONFIG);\n\n\tsvsb->set_freq_pct(svsp);\n\n\tlimit_vals = FIELD_PREP(SVSB_LIMITVALS_FLD_DTLO, SVSB_VAL_DTLO) |\n\t\t     FIELD_PREP(SVSB_LIMITVALS_FLD_DTHI, SVSB_VAL_DTHI) |\n\t\t     FIELD_PREP(SVSB_LIMITVALS_FLD_VMIN, svsb->vmin) |\n\t\t     FIELD_PREP(SVSB_LIMITVALS_FLD_VMAX, svsb->vmax);\n\tsvs_writel_relaxed(svsp, limit_vals, LIMITVALS);\n\n\tsvs_writel_relaxed(svsp, SVSB_DET_WINDOW, DETWINDOW);\n\tsvs_writel_relaxed(svsp, SVSB_DET_MAX, CONFIG);\n\tsvs_writel_relaxed(svsp, svsb->chk_shift, CHKSHIFT);\n\tsvs_writel_relaxed(svsp, svsb->ctl0, CTL0);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_VAL_CLEAN, INTSTS);\n\n\tswitch (target_phase) {\n\tcase SVSB_PHASE_INIT01:\n\t\tsvs_writel_relaxed(svsp, svsb->vboot, VBOOT);\n\t\tsvs_writel_relaxed(svsp, SVSB_INTEN_INIT0x, INTEN);\n\t\tsvs_writel_relaxed(svsp, SVSB_PTPEN_INIT01, SVSEN);\n\t\tbreak;\n\tcase SVSB_PHASE_INIT02:\n\t\tinit2vals = FIELD_PREP(SVSB_INIT2VALS_FLD_AGEVOFFSETIN, svsb->age_voffset_in) |\n\t\t\t    FIELD_PREP(SVSB_INIT2VALS_FLD_DCVOFFSETIN, svsb->dc_voffset_in);\n\t\tsvs_writel_relaxed(svsp, SVSB_INTEN_INIT0x, INTEN);\n\t\tsvs_writel_relaxed(svsp, init2vals, INIT2VALS);\n\t\tsvs_writel_relaxed(svsp, SVSB_PTPEN_INIT02, SVSEN);\n\t\tbreak;\n\tcase SVSB_PHASE_MON:\n\t\tts_calcs = FIELD_PREP(SVSB_TSCALCS_FLD_BTS, svsb->bts) |\n\t\t\t   FIELD_PREP(SVSB_TSCALCS_FLD_MTS, svsb->mts);\n\t\tsvs_writel_relaxed(svsp, ts_calcs, TSCALCS);\n\t\tsvs_writel_relaxed(svsp, SVSB_INTEN_MONVOPEN, INTEN);\n\t\tsvs_writel_relaxed(svsp, SVSB_PTPEN_MON, SVSEN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(svsb->dev, \"requested unknown target phase: %u\\n\",\n\t\t\ttarget_phase);\n\t\tbreak;\n\t}\n}\n\nstatic inline void svs_save_bank_register_data(struct svs_platform *svsp,\n\t\t\t\t\t       enum svsb_phase phase)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\tenum svs_reg_index rg_i;\n\n\tfor (rg_i = DESCHAR; rg_i < SVS_REG_MAX; rg_i++)\n\t\tsvsb->reg_data[phase][rg_i] = svs_readl_relaxed(svsp, rg_i);\n}\n\nstatic inline void svs_error_isr_handler(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\n\tdev_err(svsb->dev, \"%s: CORESEL = 0x%08x\\n\",\n\t\t__func__, svs_readl_relaxed(svsp, CORESEL));\n\tdev_err(svsb->dev, \"SVSEN = 0x%08x, INTSTS = 0x%08x\\n\",\n\t\tsvs_readl_relaxed(svsp, SVSEN),\n\t\tsvs_readl_relaxed(svsp, INTSTS));\n\tdev_err(svsb->dev, \"SMSTATE0 = 0x%08x, SMSTATE1 = 0x%08x\\n\",\n\t\tsvs_readl_relaxed(svsp, SMSTATE0),\n\t\tsvs_readl_relaxed(svsp, SMSTATE1));\n\tdev_err(svsb->dev, \"TEMP = 0x%08x\\n\", svs_readl_relaxed(svsp, TEMP));\n\n\tsvs_save_bank_register_data(svsp, SVSB_PHASE_ERROR);\n\n\tsvsb->phase = SVSB_PHASE_ERROR;\n\tsvs_writel_relaxed(svsp, SVSB_PTPEN_OFF, SVSEN);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_VAL_CLEAN, INTSTS);\n}\n\nstatic inline void svs_init01_isr_handler(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\n\tdev_info(svsb->dev, \"%s: VDN74~30:0x%08x~0x%08x, DC:0x%08x\\n\",\n\t\t __func__, svs_readl_relaxed(svsp, VDESIGN74),\n\t\t svs_readl_relaxed(svsp, VDESIGN30),\n\t\t svs_readl_relaxed(svsp, DCVALUES));\n\n\tsvs_save_bank_register_data(svsp, SVSB_PHASE_INIT01);\n\n\tsvsb->phase = SVSB_PHASE_INIT01;\n\tsvsb->dc_voffset_in = ~(svs_readl_relaxed(svsp, DCVALUES) &\n\t\t\t\tGENMASK(15, 0)) + 1;\n\tif (svsb->volt_flags & SVSB_INIT01_VOLT_IGNORE ||\n\t    (svsb->dc_voffset_in & SVSB_DC_SIGNED_BIT &&\n\t     svsb->volt_flags & SVSB_INIT01_VOLT_INC_ONLY))\n\t\tsvsb->dc_voffset_in = 0;\n\n\tsvsb->age_voffset_in = svs_readl_relaxed(svsp, AGEVALUES) &\n\t\t\t       GENMASK(15, 0);\n\n\tsvs_writel_relaxed(svsp, SVSB_PTPEN_OFF, SVSEN);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_F0_COMPLETE, INTSTS);\n\tsvsb->core_sel &= ~SVSB_DET_CLK_EN;\n}\n\nstatic inline void svs_init02_isr_handler(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\n\tdev_info(svsb->dev, \"%s: VOP74~30:0x%08x~0x%08x, DC:0x%08x\\n\",\n\t\t __func__, svs_readl_relaxed(svsp, VOP74),\n\t\t svs_readl_relaxed(svsp, VOP30),\n\t\t svs_readl_relaxed(svsp, DCVALUES));\n\n\tsvs_save_bank_register_data(svsp, SVSB_PHASE_INIT02);\n\n\tsvsb->phase = SVSB_PHASE_INIT02;\n\tsvsb->get_volts(svsp);\n\n\tsvs_writel_relaxed(svsp, SVSB_PTPEN_OFF, SVSEN);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_F0_COMPLETE, INTSTS);\n}\n\nstatic inline void svs_mon_mode_isr_handler(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb = svsp->pbank;\n\n\tsvs_save_bank_register_data(svsp, SVSB_PHASE_MON);\n\n\tsvsb->phase = SVSB_PHASE_MON;\n\tsvsb->get_volts(svsp);\n\n\tsvsb->temp = svs_readl_relaxed(svsp, TEMP) & GENMASK(7, 0);\n\tsvs_writel_relaxed(svsp, SVSB_INTSTS_FLD_MONVOP, INTSTS);\n}\n\nstatic irqreturn_t svs_isr(int irq, void *data)\n{\n\tstruct svs_platform *svsp = data;\n\tstruct svs_bank *svsb = NULL;\n\tunsigned long flags;\n\tu32 idx, int_sts, svs_en;\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tWARN(!svsb, \"%s: svsb(%s) is null\", __func__, svsb->name);\n\n\t\tspin_lock_irqsave(&svs_lock, flags);\n\t\tsvsp->pbank = svsb;\n\n\t\t \n\t\tif (svsb->int_st & svs_readl_relaxed(svsp, INTST)) {\n\t\t\tspin_unlock_irqrestore(&svs_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsvs_switch_bank(svsp);\n\t\tint_sts = svs_readl_relaxed(svsp, INTSTS);\n\t\tsvs_en = svs_readl_relaxed(svsp, SVSEN);\n\n\t\tif (int_sts == SVSB_INTSTS_F0_COMPLETE &&\n\t\t    svs_en == SVSB_PTPEN_INIT01)\n\t\t\tsvs_init01_isr_handler(svsp);\n\t\telse if (int_sts == SVSB_INTSTS_F0_COMPLETE &&\n\t\t\t svs_en == SVSB_PTPEN_INIT02)\n\t\t\tsvs_init02_isr_handler(svsp);\n\t\telse if (int_sts & SVSB_INTSTS_FLD_MONVOP)\n\t\t\tsvs_mon_mode_isr_handler(svsp);\n\t\telse\n\t\t\tsvs_error_isr_handler(svsp);\n\n\t\tspin_unlock_irqrestore(&svs_lock, flags);\n\t\tbreak;\n\t}\n\n\tsvs_adjust_pm_opp_volts(svsb);\n\n\tif (svsb->phase == SVSB_PHASE_INIT01 ||\n\t    svsb->phase == SVSB_PHASE_INIT02)\n\t\tcomplete(&svsb->init_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int svs_init01(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tunsigned long flags, time_left;\n\tbool search_done;\n\tint ret = 0, r;\n\tu32 opp_freq, opp_vboot, buck_volt, idx, i;\n\n\t \n\tcpuidle_pause_and_lock();\n\n\t  \n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT01))\n\t\t\tcontinue;\n\n\t\tret = regulator_enable(svsb->buck);\n\t\tif (ret) {\n\t\t\tdev_err(svsb->dev, \"%s enable fail: %d\\n\",\n\t\t\t\tsvsb->buck_name, ret);\n\t\t\tgoto svs_init01_resume_cpuidle;\n\t\t}\n\n\t\t \n\t\tret = regulator_set_mode(svsb->buck, REGULATOR_MODE_FAST);\n\t\tif (ret)\n\t\t\tdev_notice(svsb->dev, \"set fast mode fail: %d\\n\", ret);\n\n\t\tif (svsb->volt_flags & SVSB_INIT01_PD_REQ) {\n\t\t\tif (!pm_runtime_enabled(svsb->opp_dev)) {\n\t\t\t\tpm_runtime_enable(svsb->opp_dev);\n\t\t\t\tsvsb->pm_runtime_enabled_count++;\n\t\t\t}\n\n\t\t\tret = pm_runtime_resume_and_get(svsb->opp_dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(svsb->dev, \"mtcmos on fail: %d\\n\", ret);\n\t\t\t\tgoto svs_init01_resume_cpuidle;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT01))\n\t\t\tcontinue;\n\n\t\t \n\t\tsearch_done = false;\n\t\topp_vboot = svs_bank_volt_to_opp_volt(svsb->vboot,\n\t\t\t\t\t\t      svsb->volt_step,\n\t\t\t\t\t\t      svsb->volt_base);\n\n\t\tfor (i = 0; i < svsb->opp_count; i++) {\n\t\t\topp_freq = svsb->opp_dfreq[i];\n\t\t\tif (!search_done && svsb->opp_dvolt[i] <= opp_vboot) {\n\t\t\t\tret = dev_pm_opp_adjust_voltage(svsb->opp_dev,\n\t\t\t\t\t\t\t\topp_freq,\n\t\t\t\t\t\t\t\topp_vboot,\n\t\t\t\t\t\t\t\topp_vboot,\n\t\t\t\t\t\t\t\topp_vboot);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(svsb->dev,\n\t\t\t\t\t\t\"set opp %uuV vboot fail: %d\\n\",\n\t\t\t\t\t\topp_vboot, ret);\n\t\t\t\t\tgoto svs_init01_finish;\n\t\t\t\t}\n\n\t\t\t\tsearch_done = true;\n\t\t\t} else {\n\t\t\t\tret = dev_pm_opp_disable(svsb->opp_dev,\n\t\t\t\t\t\t\t svsb->opp_dfreq[i]);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(svsb->dev,\n\t\t\t\t\t\t\"opp %uHz disable fail: %d\\n\",\n\t\t\t\t\t\tsvsb->opp_dfreq[i], ret);\n\t\t\t\t\tgoto svs_init01_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT01))\n\t\t\tcontinue;\n\n\t\topp_vboot = svs_bank_volt_to_opp_volt(svsb->vboot,\n\t\t\t\t\t\t      svsb->volt_step,\n\t\t\t\t\t\t      svsb->volt_base);\n\n\t\tbuck_volt = regulator_get_voltage(svsb->buck);\n\t\tif (buck_volt != opp_vboot) {\n\t\t\tdev_err(svsb->dev,\n\t\t\t\t\"buck voltage: %uuV, expected vboot: %uuV\\n\",\n\t\t\t\tbuck_volt, opp_vboot);\n\t\t\tret = -EPERM;\n\t\t\tgoto svs_init01_finish;\n\t\t}\n\n\t\tspin_lock_irqsave(&svs_lock, flags);\n\t\tsvsp->pbank = svsb;\n\t\tsvs_set_bank_phase(svsp, SVSB_PHASE_INIT01);\n\t\tspin_unlock_irqrestore(&svs_lock, flags);\n\n\t\ttime_left = wait_for_completion_timeout(&svsb->init_completion,\n\t\t\t\t\t\t\tmsecs_to_jiffies(5000));\n\t\tif (!time_left) {\n\t\t\tdev_err(svsb->dev, \"init01 completion timeout\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto svs_init01_finish;\n\t\t}\n\t}\n\nsvs_init01_finish:\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT01))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < svsb->opp_count; i++) {\n\t\t\tr = dev_pm_opp_enable(svsb->opp_dev,\n\t\t\t\t\t      svsb->opp_dfreq[i]);\n\t\t\tif (r)\n\t\t\t\tdev_err(svsb->dev, \"opp %uHz enable fail: %d\\n\",\n\t\t\t\t\tsvsb->opp_dfreq[i], r);\n\t\t}\n\n\t\tif (svsb->volt_flags & SVSB_INIT01_PD_REQ) {\n\t\t\tr = pm_runtime_put_sync(svsb->opp_dev);\n\t\t\tif (r)\n\t\t\t\tdev_err(svsb->dev, \"mtcmos off fail: %d\\n\", r);\n\n\t\t\tif (svsb->pm_runtime_enabled_count > 0) {\n\t\t\t\tpm_runtime_disable(svsb->opp_dev);\n\t\t\t\tsvsb->pm_runtime_enabled_count--;\n\t\t\t}\n\t\t}\n\n\t\tr = regulator_set_mode(svsb->buck, REGULATOR_MODE_NORMAL);\n\t\tif (r)\n\t\t\tdev_notice(svsb->dev, \"set normal mode fail: %d\\n\", r);\n\n\t\tr = regulator_disable(svsb->buck);\n\t\tif (r)\n\t\t\tdev_err(svsb->dev, \"%s disable fail: %d\\n\",\n\t\t\t\tsvsb->buck_name, r);\n\t}\n\nsvs_init01_resume_cpuidle:\n\tcpuidle_resume_and_unlock();\n\n\treturn ret;\n}\n\nstatic int svs_init02(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tunsigned long flags, time_left;\n\tint ret;\n\tu32 idx;\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT02))\n\t\t\tcontinue;\n\n\t\treinit_completion(&svsb->init_completion);\n\t\tspin_lock_irqsave(&svs_lock, flags);\n\t\tsvsp->pbank = svsb;\n\t\tsvs_set_bank_phase(svsp, SVSB_PHASE_INIT02);\n\t\tspin_unlock_irqrestore(&svs_lock, flags);\n\n\t\ttime_left = wait_for_completion_timeout(&svsb->init_completion,\n\t\t\t\t\t\t\tmsecs_to_jiffies(5000));\n\t\tif (!time_left) {\n\t\t\tdev_err(svsb->dev, \"init02 completion timeout\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_of_init02;\n\t\t}\n\t}\n\n\t \n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_INIT02))\n\t\t\tcontinue;\n\n\t\tif (svsb->type == SVSB_HIGH || svsb->type == SVSB_LOW) {\n\t\t\tif (svs_sync_bank_volts_from_opp(svsb)) {\n\t\t\t\tdev_err(svsb->dev, \"sync volt fail\\n\");\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out_of_init02;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nout_of_init02:\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tsvs_bank_disable_and_restore_default_volts(svsp, svsb);\n\t}\n\n\treturn ret;\n}\n\nstatic void svs_mon_mode(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tunsigned long flags;\n\tu32 idx;\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (!(svsb->mode_support & SVSB_MODE_MON))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&svs_lock, flags);\n\t\tsvsp->pbank = svsb;\n\t\tsvs_set_bank_phase(svsp, SVSB_PHASE_MON);\n\t\tspin_unlock_irqrestore(&svs_lock, flags);\n\t}\n}\n\nstatic int svs_start(struct svs_platform *svsp)\n{\n\tint ret;\n\n\tret = svs_init01(svsp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = svs_init02(svsp);\n\tif (ret)\n\t\treturn ret;\n\n\tsvs_mon_mode(svsp);\n\n\treturn 0;\n}\n\nstatic int svs_suspend(struct device *dev)\n{\n\tstruct svs_platform *svsp = dev_get_drvdata(dev);\n\tstruct svs_bank *svsb;\n\tint ret;\n\tu32 idx;\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tsvs_bank_disable_and_restore_default_volts(svsp, svsb);\n\t}\n\n\tret = reset_control_assert(svsp->rst);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"cannot assert reset %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(svsp->main_clk);\n\n\treturn 0;\n}\n\nstatic int svs_resume(struct device *dev)\n{\n\tstruct svs_platform *svsp = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(svsp->main_clk);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"cannot enable main_clk, disable svs\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(svsp->rst);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"cannot deassert reset %d\\n\", ret);\n\t\tgoto out_of_resume;\n\t}\n\n\tret = svs_init02(svsp);\n\tif (ret)\n\t\tgoto svs_resume_reset_assert;\n\n\tsvs_mon_mode(svsp);\n\n\treturn 0;\n\nsvs_resume_reset_assert:\n\tdev_err(svsp->dev, \"assert reset: %d\\n\",\n\t\treset_control_assert(svsp->rst));\n\nout_of_resume:\n\tclk_disable_unprepare(svsp->main_clk);\n\treturn ret;\n}\n\nstatic int svs_bank_resource_setup(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tstruct dev_pm_opp *opp;\n\tunsigned long freq;\n\tint count, ret;\n\tu32 idx, i;\n\n\tdev_set_drvdata(svsp->dev, svsp);\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tswitch (svsb->sw_id) {\n\t\tcase SVSB_CPU_LITTLE:\n\t\t\tsvsb->name = \"SVSB_CPU_LITTLE\";\n\t\t\tbreak;\n\t\tcase SVSB_CPU_BIG:\n\t\t\tsvsb->name = \"SVSB_CPU_BIG\";\n\t\t\tbreak;\n\t\tcase SVSB_CCI:\n\t\t\tsvsb->name = \"SVSB_CCI\";\n\t\t\tbreak;\n\t\tcase SVSB_GPU:\n\t\t\tif (svsb->type == SVSB_HIGH)\n\t\t\t\tsvsb->name = \"SVSB_GPU_HIGH\";\n\t\t\telse if (svsb->type == SVSB_LOW)\n\t\t\t\tsvsb->name = \"SVSB_GPU_LOW\";\n\t\t\telse\n\t\t\t\tsvsb->name = \"SVSB_GPU\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(svsb->dev, \"unknown sw_id: %u\\n\", svsb->sw_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsvsb->dev = devm_kzalloc(svsp->dev, sizeof(*svsb->dev),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!svsb->dev)\n\t\t\treturn -ENOMEM;\n\n\t\tret = dev_set_name(svsb->dev, \"%s\", svsb->name);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_set_drvdata(svsb->dev, svsp);\n\n\t\tret = devm_pm_opp_of_add_table(svsb->opp_dev);\n\t\tif (ret) {\n\t\t\tdev_err(svsb->dev, \"add opp table fail: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_init(&svsb->lock);\n\t\tinit_completion(&svsb->init_completion);\n\n\t\tif (svsb->mode_support & SVSB_MODE_INIT01) {\n\t\t\tsvsb->buck = devm_regulator_get_optional(svsb->opp_dev,\n\t\t\t\t\t\t\t\t svsb->buck_name);\n\t\t\tif (IS_ERR(svsb->buck)) {\n\t\t\t\tdev_err(svsb->dev, \"cannot get \\\"%s-supply\\\"\\n\",\n\t\t\t\t\tsvsb->buck_name);\n\t\t\t\treturn PTR_ERR(svsb->buck);\n\t\t\t}\n\t\t}\n\n\t\tif (!IS_ERR_OR_NULL(svsb->tzone_name)) {\n\t\t\tsvsb->tzd = thermal_zone_get_zone_by_name(svsb->tzone_name);\n\t\t\tif (IS_ERR(svsb->tzd)) {\n\t\t\t\tdev_err(svsb->dev, \"cannot get \\\"%s\\\" thermal zone\\n\",\n\t\t\t\t\tsvsb->tzone_name);\n\t\t\t\treturn PTR_ERR(svsb->tzd);\n\t\t\t}\n\t\t}\n\n\t\tcount = dev_pm_opp_get_opp_count(svsb->opp_dev);\n\t\tif (svsb->opp_count != count) {\n\t\t\tdev_err(svsb->dev,\n\t\t\t\t\"opp_count not \\\"%u\\\" but get \\\"%d\\\"?\\n\",\n\t\t\t\tsvsb->opp_count, count);\n\t\t\treturn count;\n\t\t}\n\n\t\tfor (i = 0, freq = U32_MAX; i < svsb->opp_count; i++, freq--) {\n\t\t\topp = dev_pm_opp_find_freq_floor(svsb->opp_dev, &freq);\n\t\t\tif (IS_ERR(opp)) {\n\t\t\t\tdev_err(svsb->dev, \"cannot find freq = %ld\\n\",\n\t\t\t\t\tPTR_ERR(opp));\n\t\t\t\treturn PTR_ERR(opp);\n\t\t\t}\n\n\t\t\tsvsb->opp_dfreq[i] = freq;\n\t\t\tsvsb->opp_dvolt[i] = dev_pm_opp_get_voltage(opp);\n\t\t\tsvsb->freq_pct[i] = percent(svsb->opp_dfreq[i],\n\t\t\t\t\t\t    svsb->freq_base);\n\t\t\tdev_pm_opp_put(opp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int svs_get_efuse_data(struct svs_platform *svsp,\n\t\t\t      const char *nvmem_cell_name,\n\t\t\t      u32 **svsp_efuse, size_t *svsp_efuse_max)\n{\n\tstruct nvmem_cell *cell;\n\n\tcell = nvmem_cell_get(svsp->dev, nvmem_cell_name);\n\tif (IS_ERR(cell)) {\n\t\tdev_err(svsp->dev, \"no \\\"%s\\\"? %ld\\n\",\n\t\t\tnvmem_cell_name, PTR_ERR(cell));\n\t\treturn PTR_ERR(cell);\n\t}\n\n\t*svsp_efuse = nvmem_cell_read(cell, svsp_efuse_max);\n\tif (IS_ERR(*svsp_efuse)) {\n\t\tdev_err(svsp->dev, \"cannot read \\\"%s\\\" efuse: %ld\\n\",\n\t\t\tnvmem_cell_name, PTR_ERR(*svsp_efuse));\n\t\tnvmem_cell_put(cell);\n\t\treturn PTR_ERR(*svsp_efuse);\n\t}\n\n\t*svsp_efuse_max /= sizeof(u32);\n\tnvmem_cell_put(cell);\n\n\treturn 0;\n}\n\nstatic bool svs_mt8192_efuse_parsing(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tu32 idx, i, vmin, golden_temp;\n\tint ret;\n\n\tfor (i = 0; i < svsp->efuse_max; i++)\n\t\tif (svsp->efuse[i])\n\t\t\tdev_info(svsp->dev, \"M_HW_RES%d: 0x%08x\\n\",\n\t\t\t\t i, svsp->efuse[i]);\n\n\tif (!svsp->efuse[9]) {\n\t\tdev_notice(svsp->dev, \"svs_efuse[9] = 0x0?\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tvmin = (svsp->efuse[19] >> 4) & GENMASK(1, 0);\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (vmin == 0x1)\n\t\t\tsvsb->vmin = 0x1e;\n\n\t\tif (svsb->type == SVSB_LOW) {\n\t\t\tsvsb->mtdes = svsp->efuse[10] & GENMASK(7, 0);\n\t\t\tsvsb->bdes = (svsp->efuse[10] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[10] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[17]) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[17] >> 8) & GENMASK(7, 0);\n\t\t} else if (svsb->type == SVSB_HIGH) {\n\t\t\tsvsb->mtdes = svsp->efuse[9] & GENMASK(7, 0);\n\t\t\tsvsb->bdes = (svsp->efuse[9] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[9] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[17] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[17] >> 24) & GENMASK(7, 0);\n\t\t}\n\n\t\tsvsb->vmax += svsb->dvt_fixed;\n\t}\n\n\tret = svs_get_efuse_data(svsp, \"t-calibration-data\",\n\t\t\t\t &svsp->tefuse, &svsp->tefuse_max);\n\tif (ret)\n\t\treturn false;\n\n\tfor (i = 0; i < svsp->tefuse_max; i++)\n\t\tif (svsp->tefuse[i] != 0)\n\t\t\tbreak;\n\n\tif (i == svsp->tefuse_max)\n\t\tgolden_temp = 50;  \n\telse\n\t\tgolden_temp = (svsp->tefuse[0] >> 24) & GENMASK(7, 0);\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tsvsb->mts = 500;\n\t\tsvsb->bts = (((500 * golden_temp + 250460) / 1000) - 25) * 4;\n\t}\n\n\treturn true;\n}\n\nstatic bool svs_mt8183_efuse_parsing(struct svs_platform *svsp)\n{\n\tstruct svs_bank *svsb;\n\tint format[6], x_roomt[6], o_vtsmcu[5], o_vtsabb, tb_roomt = 0;\n\tint adc_ge_t, adc_oe_t, ge, oe, gain, degc_cali, adc_cali_en_t;\n\tint o_slope, o_slope_sign, ts_id;\n\tu32 idx, i, ft_pgm, mts, temp0, temp1, temp2;\n\tint ret;\n\n\tfor (i = 0; i < svsp->efuse_max; i++)\n\t\tif (svsp->efuse[i])\n\t\t\tdev_info(svsp->dev, \"M_HW_RES%d: 0x%08x\\n\",\n\t\t\t\t i, svsp->efuse[i]);\n\n\tif (!svsp->efuse[2]) {\n\t\tdev_notice(svsp->dev, \"svs_efuse[2] = 0x0?\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tft_pgm = (svsp->efuse[0] >> 4) & GENMASK(3, 0);\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (ft_pgm <= 1)\n\t\t\tsvsb->volt_flags |= SVSB_INIT01_VOLT_IGNORE;\n\n\t\tswitch (svsb->sw_id) {\n\t\tcase SVSB_CPU_LITTLE:\n\t\t\tsvsb->bdes = svsp->efuse[16] & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[16] >> 8) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[16] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[16] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->mtdes  = (svsp->efuse[17] >> 16) & GENMASK(7, 0);\n\n\t\t\tif (ft_pgm <= 3)\n\t\t\t\tsvsb->volt_od += 10;\n\t\t\telse\n\t\t\t\tsvsb->volt_od += 2;\n\t\t\tbreak;\n\t\tcase SVSB_CPU_BIG:\n\t\t\tsvsb->bdes = svsp->efuse[18] & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[18] >> 8) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[18] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[18] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->mtdes  = svsp->efuse[17] & GENMASK(7, 0);\n\n\t\t\tif (ft_pgm <= 3)\n\t\t\t\tsvsb->volt_od += 15;\n\t\t\telse\n\t\t\t\tsvsb->volt_od += 12;\n\t\t\tbreak;\n\t\tcase SVSB_CCI:\n\t\t\tsvsb->bdes = svsp->efuse[4] & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[4] >> 8) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[4] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[4] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->mtdes  = (svsp->efuse[5] >> 16) & GENMASK(7, 0);\n\n\t\t\tif (ft_pgm <= 3)\n\t\t\t\tsvsb->volt_od += 10;\n\t\t\telse\n\t\t\t\tsvsb->volt_od += 2;\n\t\t\tbreak;\n\t\tcase SVSB_GPU:\n\t\t\tsvsb->bdes = svsp->efuse[6] & GENMASK(7, 0);\n\t\t\tsvsb->mdes = (svsp->efuse[6] >> 8) & GENMASK(7, 0);\n\t\t\tsvsb->dcbdet = (svsp->efuse[6] >> 16) & GENMASK(7, 0);\n\t\t\tsvsb->dcmdet = (svsp->efuse[6] >> 24) & GENMASK(7, 0);\n\t\t\tsvsb->mtdes  = svsp->efuse[5] & GENMASK(7, 0);\n\n\t\t\tif (ft_pgm >= 2) {\n\t\t\t\tsvsb->freq_base = 800000000;  \n\t\t\t\tsvsb->dvt_fixed = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(svsb->dev, \"unknown sw_id: %u\\n\", svsb->sw_id);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tret = svs_get_efuse_data(svsp, \"t-calibration-data\",\n\t\t\t\t &svsp->tefuse, &svsp->tefuse_max);\n\tif (ret)\n\t\treturn false;\n\n\t \n\tadc_ge_t = (svsp->tefuse[1] >> 22) & GENMASK(9, 0);\n\tadc_oe_t = (svsp->tefuse[1] >> 12) & GENMASK(9, 0);\n\n\to_vtsmcu[0] = (svsp->tefuse[0] >> 17) & GENMASK(8, 0);\n\to_vtsmcu[1] = (svsp->tefuse[0] >> 8) & GENMASK(8, 0);\n\to_vtsmcu[2] = svsp->tefuse[1] & GENMASK(8, 0);\n\to_vtsmcu[3] = (svsp->tefuse[2] >> 23) & GENMASK(8, 0);\n\to_vtsmcu[4] = (svsp->tefuse[2] >> 5) & GENMASK(8, 0);\n\to_vtsabb = (svsp->tefuse[2] >> 14) & GENMASK(8, 0);\n\n\tdegc_cali = (svsp->tefuse[0] >> 1) & GENMASK(5, 0);\n\tadc_cali_en_t = svsp->tefuse[0] & BIT(0);\n\to_slope_sign = (svsp->tefuse[0] >> 7) & BIT(0);\n\n\tts_id = (svsp->tefuse[1] >> 9) & BIT(0);\n\tif (!ts_id) {\n\t\to_slope = 1534;\n\t} else {\n\t\to_slope = (svsp->tefuse[0] >> 26) & GENMASK(5, 0);\n\t\tif (!o_slope_sign)\n\t\t\to_slope = 1534 + o_slope * 10;\n\t\telse\n\t\t\to_slope = 1534 - o_slope * 10;\n\t}\n\n\tif (adc_cali_en_t == 0 ||\n\t    adc_ge_t < 265 || adc_ge_t > 758 ||\n\t    adc_oe_t < 265 || adc_oe_t > 758 ||\n\t    o_vtsmcu[0] < -8 || o_vtsmcu[0] > 484 ||\n\t    o_vtsmcu[1] < -8 || o_vtsmcu[1] > 484 ||\n\t    o_vtsmcu[2] < -8 || o_vtsmcu[2] > 484 ||\n\t    o_vtsmcu[3] < -8 || o_vtsmcu[3] > 484 ||\n\t    o_vtsmcu[4] < -8 || o_vtsmcu[4] > 484 ||\n\t    o_vtsabb < -8 || o_vtsabb > 484 ||\n\t    degc_cali < 1 || degc_cali > 63) {\n\t\tdev_err(svsp->dev, \"bad thermal efuse, no mon mode\\n\");\n\t\tgoto remove_mt8183_svsb_mon_mode;\n\t}\n\n\tge = ((adc_ge_t - 512) * 10000) / 4096;\n\toe = (adc_oe_t - 512);\n\tgain = (10000 + ge);\n\n\tformat[0] = (o_vtsmcu[0] + 3350 - oe);\n\tformat[1] = (o_vtsmcu[1] + 3350 - oe);\n\tformat[2] = (o_vtsmcu[2] + 3350 - oe);\n\tformat[3] = (o_vtsmcu[3] + 3350 - oe);\n\tformat[4] = (o_vtsmcu[4] + 3350 - oe);\n\tformat[5] = (o_vtsabb + 3350 - oe);\n\n\tfor (i = 0; i < 6; i++)\n\t\tx_roomt[i] = (((format[i] * 10000) / 4096) * 10000) / gain;\n\n\ttemp0 = (10000 * 100000 / gain) * 15 / 18;\n\tmts = (temp0 * 10) / o_slope;\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tsvsb->mts = mts;\n\n\t\tswitch (svsb->sw_id) {\n\t\tcase SVSB_CPU_LITTLE:\n\t\t\ttb_roomt = x_roomt[3];\n\t\t\tbreak;\n\t\tcase SVSB_CPU_BIG:\n\t\t\ttb_roomt = x_roomt[4];\n\t\t\tbreak;\n\t\tcase SVSB_CCI:\n\t\t\ttb_roomt = x_roomt[3];\n\t\t\tbreak;\n\t\tcase SVSB_GPU:\n\t\t\ttb_roomt = x_roomt[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(svsb->dev, \"unknown sw_id: %u\\n\", svsb->sw_id);\n\t\t\tgoto remove_mt8183_svsb_mon_mode;\n\t\t}\n\n\t\ttemp0 = (degc_cali * 10 / 2);\n\t\ttemp1 = ((10000 * 100000 / 4096 / gain) *\n\t\t\t oe + tb_roomt * 10) * 15 / 18;\n\t\ttemp2 = temp1 * 100 / o_slope;\n\n\t\tsvsb->bts = (temp0 + temp2 - 250) * 4 / 10;\n\t}\n\n\treturn true;\n\nremove_mt8183_svsb_mon_mode:\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\t\tsvsb->mode_support &= ~SVSB_MODE_MON;\n\t}\n\n\treturn true;\n}\n\nstatic struct device *svs_get_subsys_device(struct svs_platform *svsp,\n\t\t\t\t\t    const char *node_name)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\n\tnp = of_find_node_by_name(NULL, node_name);\n\tif (!np) {\n\t\tdev_err(svsp->dev, \"cannot find %s node\\n\", node_name);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tof_node_put(np);\n\t\tdev_err(svsp->dev, \"cannot find pdev by %s\\n\", node_name);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tof_node_put(np);\n\n\treturn &pdev->dev;\n}\n\nstatic struct device *svs_add_device_link(struct svs_platform *svsp,\n\t\t\t\t\t  const char *node_name)\n{\n\tstruct device *dev;\n\tstruct device_link *sup_link;\n\n\tdev = svs_get_subsys_device(svsp, node_name);\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tsup_link = device_link_add(svsp->dev, dev,\n\t\t\t\t   DL_FLAG_AUTOREMOVE_CONSUMER);\n\tif (!sup_link) {\n\t\tdev_err(svsp->dev, \"sup_link is NULL\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (sup_link->supplier->links.status != DL_DEV_DRIVER_BOUND)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn dev;\n}\n\nstatic int svs_mt8192_platform_probe(struct svs_platform *svsp)\n{\n\tstruct device *dev;\n\tstruct svs_bank *svsb;\n\tu32 idx;\n\n\tsvsp->rst = devm_reset_control_get_optional(svsp->dev, \"svs_rst\");\n\tif (IS_ERR(svsp->rst))\n\t\treturn dev_err_probe(svsp->dev, PTR_ERR(svsp->rst),\n\t\t\t\t     \"cannot get svs reset control\\n\");\n\n\tdev = svs_add_device_link(svsp, \"lvts\");\n\tif (IS_ERR(dev))\n\t\treturn dev_err_probe(svsp->dev, PTR_ERR(dev),\n\t\t\t\t     \"failed to get lvts device\\n\");\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tif (svsb->type == SVSB_HIGH)\n\t\t\tsvsb->opp_dev = svs_add_device_link(svsp, \"gpu\");\n\t\telse if (svsb->type == SVSB_LOW)\n\t\t\tsvsb->opp_dev = svs_get_subsys_device(svsp, \"gpu\");\n\n\t\tif (IS_ERR(svsb->opp_dev))\n\t\t\treturn dev_err_probe(svsp->dev, PTR_ERR(svsb->opp_dev),\n\t\t\t\t\t     \"failed to get OPP device for bank %d\\n\",\n\t\t\t\t\t     idx);\n\t}\n\n\treturn 0;\n}\n\nstatic int svs_mt8183_platform_probe(struct svs_platform *svsp)\n{\n\tstruct device *dev;\n\tstruct svs_bank *svsb;\n\tu32 idx;\n\n\tdev = svs_add_device_link(svsp, \"thermal\");\n\tif (IS_ERR(dev))\n\t\treturn dev_err_probe(svsp->dev, PTR_ERR(dev),\n\t\t\t\t     \"failed to get thermal device\\n\");\n\n\tfor (idx = 0; idx < svsp->bank_max; idx++) {\n\t\tsvsb = &svsp->banks[idx];\n\n\t\tswitch (svsb->sw_id) {\n\t\tcase SVSB_CPU_LITTLE:\n\t\tcase SVSB_CPU_BIG:\n\t\t\tsvsb->opp_dev = get_cpu_device(svsb->cpu_id);\n\t\t\tbreak;\n\t\tcase SVSB_CCI:\n\t\t\tsvsb->opp_dev = svs_add_device_link(svsp, \"cci\");\n\t\t\tbreak;\n\t\tcase SVSB_GPU:\n\t\t\tsvsb->opp_dev = svs_add_device_link(svsp, \"gpu\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(svsb->dev, \"unknown sw_id: %u\\n\", svsb->sw_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(svsb->opp_dev))\n\t\t\treturn dev_err_probe(svsp->dev, PTR_ERR(svsb->opp_dev),\n\t\t\t\t\t     \"failed to get OPP device for bank %d\\n\",\n\t\t\t\t\t     idx);\n\t}\n\n\treturn 0;\n}\n\nstatic struct svs_bank svs_mt8192_banks[] = {\n\t{\n\t\t.sw_id\t\t\t= SVSB_GPU,\n\t\t.type\t\t\t= SVSB_LOW,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v3,\n\t\t.get_volts\t\t= svs_get_bank_volts_v3,\n\t\t.tzone_name\t\t= \"gpu1\",\n\t\t.volt_flags\t\t= SVSB_REMOVE_DVTFIXED_VOLT,\n\t\t.mode_support\t\t= SVSB_MODE_INIT02,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 688000000,\n\t\t.turn_freq_base\t\t= 688000000,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 400000,\n\t\t.vmax\t\t\t= 0x60,\n\t\t.vmin\t\t\t= 0x1a,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x1,\n\t\t.dvt_fixed\t\t= 0x1,\n\t\t.vco\t\t\t= 0x18,\n\t\t.chk_shift\t\t= 0x87,\n\t\t.core_sel\t\t= 0x0fff0100,\n\t\t.int_st\t\t\t= BIT(0),\n\t\t.ctl0\t\t\t= 0x00540003,\n\t\t.tzone_htemp\t\t= 85000,\n\t\t.tzone_htemp_voffset\t= 0,\n\t\t.tzone_ltemp\t\t= 25000,\n\t\t.tzone_ltemp_voffset\t= 7,\n\t},\n\t{\n\t\t.sw_id\t\t\t= SVSB_GPU,\n\t\t.type\t\t\t= SVSB_HIGH,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v3,\n\t\t.get_volts\t\t= svs_get_bank_volts_v3,\n\t\t.tzone_name\t\t= \"gpu1\",\n\t\t.volt_flags\t\t= SVSB_REMOVE_DVTFIXED_VOLT |\n\t\t\t\t\t  SVSB_MON_VOLT_IGNORE,\n\t\t.mode_support\t\t= SVSB_MODE_INIT02 | SVSB_MODE_MON,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 902000000,\n\t\t.turn_freq_base\t\t= 688000000,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 400000,\n\t\t.vmax\t\t\t= 0x60,\n\t\t.vmin\t\t\t= 0x1a,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x1,\n\t\t.dvt_fixed\t\t= 0x6,\n\t\t.vco\t\t\t= 0x18,\n\t\t.chk_shift\t\t= 0x87,\n\t\t.core_sel\t\t= 0x0fff0101,\n\t\t.int_st\t\t\t= BIT(1),\n\t\t.ctl0\t\t\t= 0x00540003,\n\t\t.tzone_htemp\t\t= 85000,\n\t\t.tzone_htemp_voffset\t= 0,\n\t\t.tzone_ltemp\t\t= 25000,\n\t\t.tzone_ltemp_voffset\t= 7,\n\t},\n};\n\nstatic struct svs_bank svs_mt8183_banks[] = {\n\t{\n\t\t.sw_id\t\t\t= SVSB_CPU_LITTLE,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v2,\n\t\t.get_volts\t\t= svs_get_bank_volts_v2,\n\t\t.cpu_id\t\t\t= 0,\n\t\t.buck_name\t\t= \"proc\",\n\t\t.volt_flags\t\t= SVSB_INIT01_VOLT_INC_ONLY,\n\t\t.mode_support\t\t= SVSB_MODE_INIT01 | SVSB_MODE_INIT02,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 1989000000,\n\t\t.vboot\t\t\t= 0x30,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 500000,\n\t\t.vmax\t\t\t= 0x64,\n\t\t.vmin\t\t\t= 0x18,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x555555,\n\t\t.dvt_fixed\t\t= 0x7,\n\t\t.vco\t\t\t= 0x10,\n\t\t.chk_shift\t\t= 0x77,\n\t\t.core_sel\t\t= 0x8fff0000,\n\t\t.int_st\t\t\t= BIT(0),\n\t\t.ctl0\t\t\t= 0x00010001,\n\t},\n\t{\n\t\t.sw_id\t\t\t= SVSB_CPU_BIG,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v2,\n\t\t.get_volts\t\t= svs_get_bank_volts_v2,\n\t\t.cpu_id\t\t\t= 4,\n\t\t.buck_name\t\t= \"proc\",\n\t\t.volt_flags\t\t= SVSB_INIT01_VOLT_INC_ONLY,\n\t\t.mode_support\t\t= SVSB_MODE_INIT01 | SVSB_MODE_INIT02,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 1989000000,\n\t\t.vboot\t\t\t= 0x30,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 500000,\n\t\t.vmax\t\t\t= 0x58,\n\t\t.vmin\t\t\t= 0x10,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x555555,\n\t\t.dvt_fixed\t\t= 0x7,\n\t\t.vco\t\t\t= 0x10,\n\t\t.chk_shift\t\t= 0x77,\n\t\t.core_sel\t\t= 0x8fff0001,\n\t\t.int_st\t\t\t= BIT(1),\n\t\t.ctl0\t\t\t= 0x00000001,\n\t},\n\t{\n\t\t.sw_id\t\t\t= SVSB_CCI,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v2,\n\t\t.get_volts\t\t= svs_get_bank_volts_v2,\n\t\t.buck_name\t\t= \"proc\",\n\t\t.volt_flags\t\t= SVSB_INIT01_VOLT_INC_ONLY,\n\t\t.mode_support\t\t= SVSB_MODE_INIT01 | SVSB_MODE_INIT02,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 1196000000,\n\t\t.vboot\t\t\t= 0x30,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 500000,\n\t\t.vmax\t\t\t= 0x64,\n\t\t.vmin\t\t\t= 0x18,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x555555,\n\t\t.dvt_fixed\t\t= 0x7,\n\t\t.vco\t\t\t= 0x10,\n\t\t.chk_shift\t\t= 0x77,\n\t\t.core_sel\t\t= 0x8fff0002,\n\t\t.int_st\t\t\t= BIT(2),\n\t\t.ctl0\t\t\t= 0x00100003,\n\t},\n\t{\n\t\t.sw_id\t\t\t= SVSB_GPU,\n\t\t.set_freq_pct\t\t= svs_set_bank_freq_pct_v2,\n\t\t.get_volts\t\t= svs_get_bank_volts_v2,\n\t\t.buck_name\t\t= \"mali\",\n\t\t.tzone_name\t\t= \"tzts2\",\n\t\t.volt_flags\t\t= SVSB_INIT01_PD_REQ |\n\t\t\t\t\t  SVSB_INIT01_VOLT_INC_ONLY,\n\t\t.mode_support\t\t= SVSB_MODE_INIT01 | SVSB_MODE_INIT02 |\n\t\t\t\t\t  SVSB_MODE_MON,\n\t\t.opp_count\t\t= MAX_OPP_ENTRIES,\n\t\t.freq_base\t\t= 900000000,\n\t\t.vboot\t\t\t= 0x30,\n\t\t.volt_step\t\t= 6250,\n\t\t.volt_base\t\t= 500000,\n\t\t.vmax\t\t\t= 0x40,\n\t\t.vmin\t\t\t= 0x14,\n\t\t.age_config\t\t= 0x555555,\n\t\t.dc_config\t\t= 0x555555,\n\t\t.dvt_fixed\t\t= 0x3,\n\t\t.vco\t\t\t= 0x10,\n\t\t.chk_shift\t\t= 0x77,\n\t\t.core_sel\t\t= 0x8fff0003,\n\t\t.int_st\t\t\t= BIT(3),\n\t\t.ctl0\t\t\t= 0x00050001,\n\t\t.tzone_htemp\t\t= 85000,\n\t\t.tzone_htemp_voffset\t= 0,\n\t\t.tzone_ltemp\t\t= 25000,\n\t\t.tzone_ltemp_voffset\t= 3,\n\t},\n};\n\nstatic const struct svs_platform_data svs_mt8192_platform_data = {\n\t.name = \"mt8192-svs\",\n\t.banks = svs_mt8192_banks,\n\t.efuse_parsing = svs_mt8192_efuse_parsing,\n\t.probe = svs_mt8192_platform_probe,\n\t.regs = svs_regs_v2,\n\t.bank_max = ARRAY_SIZE(svs_mt8192_banks),\n};\n\nstatic const struct svs_platform_data svs_mt8183_platform_data = {\n\t.name = \"mt8183-svs\",\n\t.banks = svs_mt8183_banks,\n\t.efuse_parsing = svs_mt8183_efuse_parsing,\n\t.probe = svs_mt8183_platform_probe,\n\t.regs = svs_regs_v2,\n\t.bank_max = ARRAY_SIZE(svs_mt8183_banks),\n};\n\nstatic const struct of_device_id svs_of_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8192-svs\",\n\t\t.data = &svs_mt8192_platform_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt8183-svs\",\n\t\t.data = &svs_mt8183_platform_data,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, svs_of_match);\n\nstatic int svs_probe(struct platform_device *pdev)\n{\n\tstruct svs_platform *svsp;\n\tconst struct svs_platform_data *svsp_data;\n\tint ret, svsp_irq;\n\n\tsvsp_data = of_device_get_match_data(&pdev->dev);\n\n\tsvsp = devm_kzalloc(&pdev->dev, sizeof(*svsp), GFP_KERNEL);\n\tif (!svsp)\n\t\treturn -ENOMEM;\n\n\tsvsp->dev = &pdev->dev;\n\tsvsp->banks = svsp_data->banks;\n\tsvsp->regs = svsp_data->regs;\n\tsvsp->bank_max = svsp_data->bank_max;\n\n\tret = svsp_data->probe(svsp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = svs_get_efuse_data(svsp, \"svs-calibration-data\",\n\t\t\t\t &svsp->efuse, &svsp->efuse_max);\n\tif (ret) {\n\t\tret = -EPERM;\n\t\tgoto svs_probe_free_efuse;\n\t}\n\n\tif (!svsp_data->efuse_parsing(svsp)) {\n\t\tdev_err(svsp->dev, \"efuse data parsing failed\\n\");\n\t\tret = -EPERM;\n\t\tgoto svs_probe_free_tefuse;\n\t}\n\n\tret = svs_bank_resource_setup(svsp);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"svs bank resource setup fail: %d\\n\", ret);\n\t\tgoto svs_probe_free_tefuse;\n\t}\n\n\tsvsp_irq = platform_get_irq(pdev, 0);\n\tif (svsp_irq < 0) {\n\t\tret = svsp_irq;\n\t\tgoto svs_probe_free_tefuse;\n\t}\n\n\tsvsp->main_clk = devm_clk_get(svsp->dev, \"main\");\n\tif (IS_ERR(svsp->main_clk)) {\n\t\tdev_err(svsp->dev, \"failed to get clock: %ld\\n\",\n\t\t\tPTR_ERR(svsp->main_clk));\n\t\tret = PTR_ERR(svsp->main_clk);\n\t\tgoto svs_probe_free_tefuse;\n\t}\n\n\tret = clk_prepare_enable(svsp->main_clk);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"cannot enable main clk: %d\\n\", ret);\n\t\tgoto svs_probe_free_tefuse;\n\t}\n\n\tsvsp->base = of_iomap(svsp->dev->of_node, 0);\n\tif (IS_ERR_OR_NULL(svsp->base)) {\n\t\tdev_err(svsp->dev, \"cannot find svs register base\\n\");\n\t\tret = -EINVAL;\n\t\tgoto svs_probe_clk_disable;\n\t}\n\n\tret = devm_request_threaded_irq(svsp->dev, svsp_irq, NULL, svs_isr,\n\t\t\t\t\tIRQF_ONESHOT, svsp_data->name, svsp);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"register irq(%d) failed: %d\\n\",\n\t\t\tsvsp_irq, ret);\n\t\tgoto svs_probe_iounmap;\n\t}\n\n\tret = svs_start(svsp);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"svs start fail: %d\\n\", ret);\n\t\tgoto svs_probe_iounmap;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tret = svs_create_debug_cmds(svsp);\n\tif (ret) {\n\t\tdev_err(svsp->dev, \"svs create debug cmds fail: %d\\n\", ret);\n\t\tgoto svs_probe_iounmap;\n\t}\n#endif\n\n\treturn 0;\n\nsvs_probe_iounmap:\n\tiounmap(svsp->base);\n\nsvs_probe_clk_disable:\n\tclk_disable_unprepare(svsp->main_clk);\n\nsvs_probe_free_tefuse:\n\tif (!IS_ERR_OR_NULL(svsp->tefuse))\n\t\tkfree(svsp->tefuse);\n\nsvs_probe_free_efuse:\n\tif (!IS_ERR_OR_NULL(svsp->efuse))\n\t\tkfree(svsp->efuse);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(svs_pm_ops, svs_suspend, svs_resume);\n\nstatic struct platform_driver svs_driver = {\n\t.probe\t= svs_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"mtk-svs\",\n\t\t.pm\t\t= &svs_pm_ops,\n\t\t.of_match_table\t= svs_of_match,\n\t},\n};\n\nmodule_platform_driver(svs_driver);\n\nMODULE_AUTHOR(\"Roger Lu <roger.lu@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek SVS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}