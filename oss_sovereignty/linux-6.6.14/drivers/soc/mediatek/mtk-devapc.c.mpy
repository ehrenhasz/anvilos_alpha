{
  "module_name": "mtk-devapc.c",
  "hash_id": "984f1bc1122811ff091b413fdf18b972d67965853e696c7b57fb2296be1b9264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/mediatek/mtk-devapc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n\n#define VIO_MOD_TO_REG_IND(m)\t((m) / 32)\n#define VIO_MOD_TO_REG_OFF(m)\t((m) % 32)\n\nstruct mtk_devapc_vio_dbgs {\n\tunion {\n\t\tu32 vio_dbg0;\n\t\tstruct {\n\t\t\tu32 mstid:16;\n\t\t\tu32 dmnid:6;\n\t\t\tu32 vio_w:1;\n\t\t\tu32 vio_r:1;\n\t\t\tu32 addr_h:4;\n\t\t\tu32 resv:4;\n\t\t} dbg0_bits;\n\t};\n\n\tu32 vio_dbg1;\n};\n\nstruct mtk_devapc_regs_ofs {\n\t \n\tu32 vio_mask_offset;\n\tu32 vio_sta_offset;\n\tu32 vio_dbg0_offset;\n\tu32 vio_dbg1_offset;\n\tu32 apc_con_offset;\n\tu32 vio_shift_sta_offset;\n\tu32 vio_shift_sel_offset;\n\tu32 vio_shift_con_offset;\n};\n\nstruct mtk_devapc_data {\n\t \n\tu32 vio_idx_num;\n\tconst struct mtk_devapc_regs_ofs *regs_ofs;\n};\n\nstruct mtk_devapc_context {\n\tstruct device *dev;\n\tvoid __iomem *infra_base;\n\tstruct clk *infra_clk;\n\tconst struct mtk_devapc_data *data;\n};\n\nstatic void clear_vio_status(struct mtk_devapc_context *ctx)\n{\n\tvoid __iomem *reg;\n\tint i;\n\n\treg = ctx->infra_base + ctx->data->regs_ofs->vio_sta_offset;\n\n\tfor (i = 0; i < VIO_MOD_TO_REG_IND(ctx->data->vio_idx_num) - 1; i++)\n\t\twritel(GENMASK(31, 0), reg + 4 * i);\n\n\twritel(GENMASK(VIO_MOD_TO_REG_OFF(ctx->data->vio_idx_num) - 1, 0),\n\t       reg + 4 * i);\n}\n\nstatic void mask_module_irq(struct mtk_devapc_context *ctx, bool mask)\n{\n\tvoid __iomem *reg;\n\tu32 val;\n\tint i;\n\n\treg = ctx->infra_base + ctx->data->regs_ofs->vio_mask_offset;\n\n\tif (mask)\n\t\tval = GENMASK(31, 0);\n\telse\n\t\tval = 0;\n\n\tfor (i = 0; i < VIO_MOD_TO_REG_IND(ctx->data->vio_idx_num) - 1; i++)\n\t\twritel(val, reg + 4 * i);\n\n\tval = readl(reg + 4 * i);\n\tif (mask)\n\t\tval |= GENMASK(VIO_MOD_TO_REG_OFF(ctx->data->vio_idx_num) - 1,\n\t\t\t       0);\n\telse\n\t\tval &= ~GENMASK(VIO_MOD_TO_REG_OFF(ctx->data->vio_idx_num) - 1,\n\t\t\t\t0);\n\n\twritel(val, reg + 4 * i);\n}\n\n#define PHY_DEVAPC_TIMEOUT\t0x10000\n\n \nstatic int devapc_sync_vio_dbg(struct mtk_devapc_context *ctx)\n{\n\tvoid __iomem *pd_vio_shift_sta_reg;\n\tvoid __iomem *pd_vio_shift_sel_reg;\n\tvoid __iomem *pd_vio_shift_con_reg;\n\tint min_shift_group;\n\tint ret;\n\tu32 val;\n\n\tpd_vio_shift_sta_reg = ctx->infra_base +\n\t\t\t       ctx->data->regs_ofs->vio_shift_sta_offset;\n\tpd_vio_shift_sel_reg = ctx->infra_base +\n\t\t\t       ctx->data->regs_ofs->vio_shift_sel_offset;\n\tpd_vio_shift_con_reg = ctx->infra_base +\n\t\t\t       ctx->data->regs_ofs->vio_shift_con_offset;\n\n\t \n\tval = readl(pd_vio_shift_sta_reg);\n\tif (!val)\n\t\treturn false;\n\n\tmin_shift_group = __ffs(val);\n\n\t \n\twritel(0x1 << min_shift_group, pd_vio_shift_sel_reg);\n\n\t \n\twritel(0x1, pd_vio_shift_con_reg);\n\n\tret = readl_poll_timeout(pd_vio_shift_con_reg, val, val == 0x3, 0,\n\t\t\t\t PHY_DEVAPC_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"%s: Shift violation info failed\\n\", __func__);\n\t\treturn false;\n\t}\n\n\t \n\twritel(0x0, pd_vio_shift_con_reg);\n\n\t \n\twritel(0x1 << min_shift_group, pd_vio_shift_sta_reg);\n\n\treturn true;\n}\n\n \nstatic void devapc_extract_vio_dbg(struct mtk_devapc_context *ctx)\n{\n\tstruct mtk_devapc_vio_dbgs vio_dbgs;\n\tvoid __iomem *vio_dbg0_reg;\n\tvoid __iomem *vio_dbg1_reg;\n\n\tvio_dbg0_reg = ctx->infra_base + ctx->data->regs_ofs->vio_dbg0_offset;\n\tvio_dbg1_reg = ctx->infra_base + ctx->data->regs_ofs->vio_dbg1_offset;\n\n\tvio_dbgs.vio_dbg0 = readl(vio_dbg0_reg);\n\tvio_dbgs.vio_dbg1 = readl(vio_dbg1_reg);\n\n\t \n\tif (vio_dbgs.dbg0_bits.vio_w)\n\t\tdev_info(ctx->dev, \"Write Violation\\n\");\n\telse if (vio_dbgs.dbg0_bits.vio_r)\n\t\tdev_info(ctx->dev, \"Read Violation\\n\");\n\n\tdev_info(ctx->dev, \"Bus ID:0x%x, Dom ID:0x%x, Vio Addr:0x%x\\n\",\n\t\t vio_dbgs.dbg0_bits.mstid, vio_dbgs.dbg0_bits.dmnid,\n\t\t vio_dbgs.vio_dbg1);\n}\n\n \nstatic irqreturn_t devapc_violation_irq(int irq_number, void *data)\n{\n\tstruct mtk_devapc_context *ctx = data;\n\n\twhile (devapc_sync_vio_dbg(ctx))\n\t\tdevapc_extract_vio_dbg(ctx);\n\n\tclear_vio_status(ctx);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void start_devapc(struct mtk_devapc_context *ctx)\n{\n\twritel(BIT(31), ctx->infra_base + ctx->data->regs_ofs->apc_con_offset);\n\n\tmask_module_irq(ctx, false);\n}\n\n \nstatic void stop_devapc(struct mtk_devapc_context *ctx)\n{\n\tmask_module_irq(ctx, true);\n\n\twritel(BIT(2), ctx->infra_base + ctx->data->regs_ofs->apc_con_offset);\n}\n\nstatic const struct mtk_devapc_regs_ofs devapc_regs_ofs_mt6779 = {\n\t.vio_mask_offset = 0x0,\n\t.vio_sta_offset = 0x400,\n\t.vio_dbg0_offset = 0x900,\n\t.vio_dbg1_offset = 0x904,\n\t.apc_con_offset = 0xF00,\n\t.vio_shift_sta_offset = 0xF10,\n\t.vio_shift_sel_offset = 0xF14,\n\t.vio_shift_con_offset = 0xF20,\n};\n\nstatic const struct mtk_devapc_data devapc_mt6779 = {\n\t.vio_idx_num = 511,\n\t.regs_ofs = &devapc_regs_ofs_mt6779,\n};\n\nstatic const struct mtk_devapc_data devapc_mt8186 = {\n\t.vio_idx_num = 519,\n\t.regs_ofs = &devapc_regs_ofs_mt6779,\n};\n\nstatic const struct of_device_id mtk_devapc_dt_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt6779-devapc\",\n\t\t.data = &devapc_mt6779,\n\t}, {\n\t\t.compatible = \"mediatek,mt8186-devapc\",\n\t\t.data = &devapc_mt8186,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, mtk_devapc_dt_match);\n\nstatic int mtk_devapc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct mtk_devapc_context *ctx;\n\tu32 devapc_irq;\n\tint ret;\n\n\tif (IS_ERR(node))\n\t\treturn -ENODEV;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->data = of_device_get_match_data(&pdev->dev);\n\tctx->dev = &pdev->dev;\n\n\tctx->infra_base = of_iomap(node, 0);\n\tif (!ctx->infra_base)\n\t\treturn -EINVAL;\n\n\tdevapc_irq = irq_of_parse_and_map(node, 0);\n\tif (!devapc_irq)\n\t\treturn -EINVAL;\n\n\tctx->infra_clk = devm_clk_get_enabled(&pdev->dev, \"devapc-infra-clock\");\n\tif (IS_ERR(ctx->infra_clk))\n\t\treturn -EINVAL;\n\n\tret = devm_request_irq(&pdev->dev, devapc_irq, devapc_violation_irq,\n\t\t\t       IRQF_TRIGGER_NONE, \"devapc\", ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tstart_devapc(ctx);\n\n\treturn 0;\n}\n\nstatic int mtk_devapc_remove(struct platform_device *pdev)\n{\n\tstruct mtk_devapc_context *ctx = platform_get_drvdata(pdev);\n\n\tstop_devapc(ctx);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_devapc_driver = {\n\t.probe = mtk_devapc_probe,\n\t.remove = mtk_devapc_remove,\n\t.driver = {\n\t\t.name = \"mtk-devapc\",\n\t\t.of_match_table = mtk_devapc_dt_match,\n\t},\n};\n\nmodule_platform_driver(mtk_devapc_driver);\n\nMODULE_DESCRIPTION(\"Mediatek Device APC Driver\");\nMODULE_AUTHOR(\"Neal Liu <neal.liu@mediatek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}