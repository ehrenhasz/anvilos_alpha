{
  "module_name": "sart.c",
  "hash_id": "e17320024ba1ad17cbb0a0ec02d21a9d3c92a3958ebbcdf4571632e82e27387c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/apple/sart.c",
  "human_readable_source": "\n \n\n#include <linux/soc/apple/sart.h>\n#include <linux/atomic.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#define APPLE_SART_MAX_ENTRIES 16\n\n \n#define APPLE_SART_FLAGS_ALLOW 0xff\n\n \n#define APPLE_SART2_CONFIG(idx)\t      (0x00 + 4 * (idx))\n#define APPLE_SART2_CONFIG_FLAGS      GENMASK(31, 24)\n#define APPLE_SART2_CONFIG_SIZE\t      GENMASK(23, 0)\n#define APPLE_SART2_CONFIG_SIZE_SHIFT 12\n#define APPLE_SART2_CONFIG_SIZE_MAX   GENMASK(23, 0)\n\n#define APPLE_SART2_PADDR(idx)\t(0x40 + 4 * (idx))\n#define APPLE_SART2_PADDR_SHIFT 12\n\n \n#define APPLE_SART3_CONFIG(idx) (0x00 + 4 * (idx))\n\n#define APPLE_SART3_PADDR(idx)\t(0x40 + 4 * (idx))\n#define APPLE_SART3_PADDR_SHIFT 12\n\n#define APPLE_SART3_SIZE(idx)  (0x80 + 4 * (idx))\n#define APPLE_SART3_SIZE_SHIFT 12\n#define APPLE_SART3_SIZE_MAX   GENMASK(29, 0)\n\nstruct apple_sart_ops {\n\tvoid (*get_entry)(struct apple_sart *sart, int index, u8 *flags,\n\t\t\t  phys_addr_t *paddr, size_t *size);\n\tvoid (*set_entry)(struct apple_sart *sart, int index, u8 flags,\n\t\t\t  phys_addr_t paddr_shifted, size_t size_shifted);\n\tunsigned int size_shift;\n\tunsigned int paddr_shift;\n\tsize_t size_max;\n};\n\nstruct apple_sart {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\n\tconst struct apple_sart_ops *ops;\n\n\tunsigned long protected_entries;\n\tunsigned long used_entries;\n};\n\nstatic void sart2_get_entry(struct apple_sart *sart, int index, u8 *flags,\n\t\t\t    phys_addr_t *paddr, size_t *size)\n{\n\tu32 cfg = readl(sart->regs + APPLE_SART2_CONFIG(index));\n\tphys_addr_t paddr_ = readl(sart->regs + APPLE_SART2_PADDR(index));\n\tsize_t size_ = FIELD_GET(APPLE_SART2_CONFIG_SIZE, cfg);\n\n\t*flags = FIELD_GET(APPLE_SART2_CONFIG_FLAGS, cfg);\n\t*size = size_ << APPLE_SART2_CONFIG_SIZE_SHIFT;\n\t*paddr = paddr_ << APPLE_SART2_PADDR_SHIFT;\n}\n\nstatic void sart2_set_entry(struct apple_sart *sart, int index, u8 flags,\n\t\t\t    phys_addr_t paddr_shifted, size_t size_shifted)\n{\n\tu32 cfg;\n\n\tcfg = FIELD_PREP(APPLE_SART2_CONFIG_FLAGS, flags);\n\tcfg |= FIELD_PREP(APPLE_SART2_CONFIG_SIZE, size_shifted);\n\n\twritel(paddr_shifted, sart->regs + APPLE_SART2_PADDR(index));\n\twritel(cfg, sart->regs + APPLE_SART2_CONFIG(index));\n}\n\nstatic struct apple_sart_ops sart_ops_v2 = {\n\t.get_entry = sart2_get_entry,\n\t.set_entry = sart2_set_entry,\n\t.size_shift = APPLE_SART2_CONFIG_SIZE_SHIFT,\n\t.paddr_shift = APPLE_SART2_PADDR_SHIFT,\n\t.size_max = APPLE_SART2_CONFIG_SIZE_MAX,\n};\n\nstatic void sart3_get_entry(struct apple_sart *sart, int index, u8 *flags,\n\t\t\t    phys_addr_t *paddr, size_t *size)\n{\n\tphys_addr_t paddr_ = readl(sart->regs + APPLE_SART3_PADDR(index));\n\tsize_t size_ = readl(sart->regs + APPLE_SART3_SIZE(index));\n\n\t*flags = readl(sart->regs + APPLE_SART3_CONFIG(index));\n\t*size = size_ << APPLE_SART3_SIZE_SHIFT;\n\t*paddr = paddr_ << APPLE_SART3_PADDR_SHIFT;\n}\n\nstatic void sart3_set_entry(struct apple_sart *sart, int index, u8 flags,\n\t\t\t    phys_addr_t paddr_shifted, size_t size_shifted)\n{\n\twritel(paddr_shifted, sart->regs + APPLE_SART3_PADDR(index));\n\twritel(size_shifted, sart->regs + APPLE_SART3_SIZE(index));\n\twritel(flags, sart->regs + APPLE_SART3_CONFIG(index));\n}\n\nstatic struct apple_sart_ops sart_ops_v3 = {\n\t.get_entry = sart3_get_entry,\n\t.set_entry = sart3_set_entry,\n\t.size_shift = APPLE_SART3_SIZE_SHIFT,\n\t.paddr_shift = APPLE_SART3_PADDR_SHIFT,\n\t.size_max = APPLE_SART3_SIZE_MAX,\n};\n\nstatic int apple_sart_probe(struct platform_device *pdev)\n{\n\tint i;\n\tstruct apple_sart *sart;\n\tstruct device *dev = &pdev->dev;\n\n\tsart = devm_kzalloc(dev, sizeof(*sart), GFP_KERNEL);\n\tif (!sart)\n\t\treturn -ENOMEM;\n\n\tsart->dev = dev;\n\tsart->ops = of_device_get_match_data(dev);\n\n\tsart->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sart->regs))\n\t\treturn PTR_ERR(sart->regs);\n\n\tfor (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {\n\t\tu8 flags;\n\t\tsize_t size;\n\t\tphys_addr_t paddr;\n\n\t\tsart->ops->get_entry(sart, i, &flags, &paddr, &size);\n\n\t\tif (!flags)\n\t\t\tcontinue;\n\n\t\tdev_dbg(sart->dev,\n\t\t\t\"SART bootloader entry: index %02d; flags: 0x%02x; paddr: %pa; size: 0x%zx\\n\",\n\t\t\ti, flags, &paddr, size);\n\t\tset_bit(i, &sart->protected_entries);\n\t}\n\n\tplatform_set_drvdata(pdev, sart);\n\treturn 0;\n}\n\nstatic void apple_sart_put_device(void *dev)\n{\n\tput_device(dev);\n}\n\nstruct apple_sart *devm_apple_sart_get(struct device *dev)\n{\n\tstruct device_node *sart_node;\n\tstruct platform_device *sart_pdev;\n\tstruct apple_sart *sart;\n\tint ret;\n\n\tsart_node = of_parse_phandle(dev->of_node, \"apple,sart\", 0);\n\tif (!sart_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsart_pdev = of_find_device_by_node(sart_node);\n\tof_node_put(sart_node);\n\n\tif (!sart_pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsart = dev_get_drvdata(&sart_pdev->dev);\n\tif (!sart) {\n\t\tput_device(&sart_pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tret = devm_add_action_or_reset(dev, apple_sart_put_device,\n\t\t\t\t       &sart_pdev->dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdevice_link_add(dev, &sart_pdev->dev,\n\t\t\tDL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_SUPPLIER);\n\n\treturn sart;\n}\nEXPORT_SYMBOL_GPL(devm_apple_sart_get);\n\nstatic int sart_set_entry(struct apple_sart *sart, int index, u8 flags,\n\t\t\t  phys_addr_t paddr, size_t size)\n{\n\tif (size & ((1 << sart->ops->size_shift) - 1))\n\t\treturn -EINVAL;\n\tif (paddr & ((1 << sart->ops->paddr_shift) - 1))\n\t\treturn -EINVAL;\n\n\tpaddr >>= sart->ops->size_shift;\n\tsize >>= sart->ops->paddr_shift;\n\n\tif (size > sart->ops->size_max)\n\t\treturn -EINVAL;\n\n\tsart->ops->set_entry(sart, index, flags, paddr, size);\n\treturn 0;\n}\n\nint apple_sart_add_allowed_region(struct apple_sart *sart, phys_addr_t paddr,\n\t\t\t\t  size_t size)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {\n\t\tif (test_bit(i, &sart->protected_entries))\n\t\t\tcontinue;\n\t\tif (test_and_set_bit(i, &sart->used_entries))\n\t\t\tcontinue;\n\n\t\tret = sart_set_entry(sart, i, APPLE_SART_FLAGS_ALLOW, paddr,\n\t\t\t\t     size);\n\t\tif (ret) {\n\t\t\tdev_dbg(sart->dev,\n\t\t\t\t\"unable to set entry %d to [%pa, 0x%zx]\\n\",\n\t\t\t\ti, &paddr, size);\n\t\t\tclear_bit(i, &sart->used_entries);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(sart->dev, \"wrote [%pa, 0x%zx] to %d\\n\", &paddr, size,\n\t\t\ti);\n\t\treturn 0;\n\t}\n\n\tdev_warn(sart->dev,\n\t\t \"no free entries left to add [paddr: 0x%pa, size: 0x%zx]\\n\",\n\t\t &paddr, size);\n\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(apple_sart_add_allowed_region);\n\nint apple_sart_remove_allowed_region(struct apple_sart *sart, phys_addr_t paddr,\n\t\t\t\t     size_t size)\n{\n\tint i;\n\n\tdev_dbg(sart->dev,\n\t\t\"will remove [paddr: %pa, size: 0x%zx] from allowed regions\\n\",\n\t\t&paddr, size);\n\n\tfor (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {\n\t\tu8 eflags;\n\t\tsize_t esize;\n\t\tphys_addr_t epaddr;\n\n\t\tif (test_bit(i, &sart->protected_entries))\n\t\t\tcontinue;\n\n\t\tsart->ops->get_entry(sart, i, &eflags, &epaddr, &esize);\n\n\t\tif (epaddr != paddr || esize != size)\n\t\t\tcontinue;\n\n\t\tsart->ops->set_entry(sart, i, 0, 0, 0);\n\n\t\tclear_bit(i, &sart->used_entries);\n\t\tdev_dbg(sart->dev, \"cleared entry %d\\n\", i);\n\t\treturn 0;\n\t}\n\n\tdev_warn(sart->dev, \"entry [paddr: 0x%pa, size: 0x%zx] not found\\n\",\n\t\t &paddr, size);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(apple_sart_remove_allowed_region);\n\nstatic void apple_sart_shutdown(struct platform_device *pdev)\n{\n\tstruct apple_sart *sart = dev_get_drvdata(&pdev->dev);\n\tint i;\n\n\tfor (i = 0; i < APPLE_SART_MAX_ENTRIES; ++i) {\n\t\tif (test_bit(i, &sart->protected_entries))\n\t\t\tcontinue;\n\n\t\tsart->ops->set_entry(sart, i, 0, 0, 0);\n\t}\n}\n\nstatic const struct of_device_id apple_sart_of_match[] = {\n\t{\n\t\t.compatible = \"apple,t6000-sart\",\n\t\t.data = &sart_ops_v3,\n\t},\n\t{\n\t\t.compatible = \"apple,t8103-sart\",\n\t\t.data = &sart_ops_v2,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, apple_sart_of_match);\n\nstatic struct platform_driver apple_sart_driver = {\n\t.driver = {\n\t\t.name = \"apple-sart\",\n\t\t.of_match_table = apple_sart_of_match,\n\t},\n\t.probe = apple_sart_probe,\n\t.shutdown = apple_sart_shutdown,\n};\nmodule_platform_driver(apple_sart_driver);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_DESCRIPTION(\"Apple SART driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}