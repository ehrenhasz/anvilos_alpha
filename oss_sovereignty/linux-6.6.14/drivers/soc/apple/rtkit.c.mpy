{
  "module_name": "rtkit.c",
  "hash_id": "ae01cad64fb725faf9f885c959d8fff1afca67d35918dbbf8d69d205864d0d4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/apple/rtkit.c",
  "human_readable_source": "\n \n\n#include \"rtkit-internal.h\"\n\nenum {\n\tAPPLE_RTKIT_PWR_STATE_OFF = 0x00,  \n\tAPPLE_RTKIT_PWR_STATE_SLEEP = 0x01,  \n\tAPPLE_RTKIT_PWR_STATE_IDLE = 0x201,  \n\tAPPLE_RTKIT_PWR_STATE_QUIESCED = 0x10,  \n\tAPPLE_RTKIT_PWR_STATE_ON = 0x20,  \n};\n\nenum {\n\tAPPLE_RTKIT_EP_MGMT = 0,\n\tAPPLE_RTKIT_EP_CRASHLOG = 1,\n\tAPPLE_RTKIT_EP_SYSLOG = 2,\n\tAPPLE_RTKIT_EP_DEBUG = 3,\n\tAPPLE_RTKIT_EP_IOREPORT = 4,\n\tAPPLE_RTKIT_EP_OSLOG = 8,\n};\n\n#define APPLE_RTKIT_MGMT_TYPE GENMASK_ULL(59, 52)\n\nenum {\n\tAPPLE_RTKIT_MGMT_HELLO = 1,\n\tAPPLE_RTKIT_MGMT_HELLO_REPLY = 2,\n\tAPPLE_RTKIT_MGMT_STARTEP = 5,\n\tAPPLE_RTKIT_MGMT_SET_IOP_PWR_STATE = 6,\n\tAPPLE_RTKIT_MGMT_SET_IOP_PWR_STATE_ACK = 7,\n\tAPPLE_RTKIT_MGMT_EPMAP = 8,\n\tAPPLE_RTKIT_MGMT_EPMAP_REPLY = 8,\n\tAPPLE_RTKIT_MGMT_SET_AP_PWR_STATE = 0xb,\n\tAPPLE_RTKIT_MGMT_SET_AP_PWR_STATE_ACK = 0xb,\n};\n\n#define APPLE_RTKIT_MGMT_HELLO_MINVER GENMASK_ULL(15, 0)\n#define APPLE_RTKIT_MGMT_HELLO_MAXVER GENMASK_ULL(31, 16)\n\n#define APPLE_RTKIT_MGMT_EPMAP_LAST   BIT_ULL(51)\n#define APPLE_RTKIT_MGMT_EPMAP_BASE   GENMASK_ULL(34, 32)\n#define APPLE_RTKIT_MGMT_EPMAP_BITMAP GENMASK_ULL(31, 0)\n\n#define APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE BIT_ULL(0)\n\n#define APPLE_RTKIT_MGMT_STARTEP_EP   GENMASK_ULL(39, 32)\n#define APPLE_RTKIT_MGMT_STARTEP_FLAG BIT_ULL(1)\n\n#define APPLE_RTKIT_MGMT_PWR_STATE GENMASK_ULL(15, 0)\n\n#define APPLE_RTKIT_CRASHLOG_CRASH 1\n\n#define APPLE_RTKIT_BUFFER_REQUEST\t1\n#define APPLE_RTKIT_BUFFER_REQUEST_SIZE GENMASK_ULL(51, 44)\n#define APPLE_RTKIT_BUFFER_REQUEST_IOVA GENMASK_ULL(43, 0)\n\n#define APPLE_RTKIT_SYSLOG_TYPE GENMASK_ULL(59, 52)\n\n#define APPLE_RTKIT_SYSLOG_LOG 5\n\n#define APPLE_RTKIT_SYSLOG_INIT\t     8\n#define APPLE_RTKIT_SYSLOG_N_ENTRIES GENMASK_ULL(7, 0)\n#define APPLE_RTKIT_SYSLOG_MSG_SIZE  GENMASK_ULL(31, 24)\n\n#define APPLE_RTKIT_OSLOG_TYPE GENMASK_ULL(63, 56)\n#define APPLE_RTKIT_OSLOG_INIT\t1\n#define APPLE_RTKIT_OSLOG_ACK\t3\n\n#define APPLE_RTKIT_MIN_SUPPORTED_VERSION 11\n#define APPLE_RTKIT_MAX_SUPPORTED_VERSION 12\n\nstruct apple_rtkit_msg {\n\tstruct completion *completion;\n\tstruct apple_mbox_msg mbox_msg;\n};\n\nstruct apple_rtkit_rx_work {\n\tstruct apple_rtkit *rtk;\n\tu8 ep;\n\tu64 msg;\n\tstruct work_struct work;\n};\n\nbool apple_rtkit_is_running(struct apple_rtkit *rtk)\n{\n\tif (rtk->crashed)\n\t\treturn false;\n\tif ((rtk->iop_power_state & 0xff) != APPLE_RTKIT_PWR_STATE_ON)\n\t\treturn false;\n\tif ((rtk->ap_power_state & 0xff) != APPLE_RTKIT_PWR_STATE_ON)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_is_running);\n\nbool apple_rtkit_is_crashed(struct apple_rtkit *rtk)\n{\n\treturn rtk->crashed;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_is_crashed);\n\nstatic void apple_rtkit_management_send(struct apple_rtkit *rtk, u8 type,\n\t\t\t\t\tu64 msg)\n{\n\tmsg &= ~APPLE_RTKIT_MGMT_TYPE;\n\tmsg |= FIELD_PREP(APPLE_RTKIT_MGMT_TYPE, type);\n\tapple_rtkit_send_message(rtk, APPLE_RTKIT_EP_MGMT, msg, NULL, false);\n}\n\nstatic void apple_rtkit_management_rx_hello(struct apple_rtkit *rtk, u64 msg)\n{\n\tu64 reply;\n\n\tint min_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MINVER, msg);\n\tint max_ver = FIELD_GET(APPLE_RTKIT_MGMT_HELLO_MAXVER, msg);\n\tint want_ver = min(APPLE_RTKIT_MAX_SUPPORTED_VERSION, max_ver);\n\n\tdev_dbg(rtk->dev, \"RTKit: Min ver %d, max ver %d\\n\", min_ver, max_ver);\n\n\tif (min_ver > APPLE_RTKIT_MAX_SUPPORTED_VERSION) {\n\t\tdev_err(rtk->dev, \"RTKit: Firmware min version %d is too new\\n\",\n\t\t\tmin_ver);\n\t\tgoto abort_boot;\n\t}\n\n\tif (max_ver < APPLE_RTKIT_MIN_SUPPORTED_VERSION) {\n\t\tdev_err(rtk->dev, \"RTKit: Firmware max version %d is too old\\n\",\n\t\t\tmax_ver);\n\t\tgoto abort_boot;\n\t}\n\n\tdev_info(rtk->dev, \"RTKit: Initializing (protocol version %d)\\n\",\n\t\t want_ver);\n\trtk->version = want_ver;\n\n\treply = FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MINVER, want_ver);\n\treply |= FIELD_PREP(APPLE_RTKIT_MGMT_HELLO_MAXVER, want_ver);\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_HELLO_REPLY, reply);\n\n\treturn;\n\nabort_boot:\n\trtk->boot_result = -EINVAL;\n\tcomplete_all(&rtk->epmap_completion);\n}\n\nstatic void apple_rtkit_management_rx_epmap(struct apple_rtkit *rtk, u64 msg)\n{\n\tint i, ep;\n\tu64 reply;\n\tunsigned long bitmap = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BITMAP, msg);\n\tu32 base = FIELD_GET(APPLE_RTKIT_MGMT_EPMAP_BASE, msg);\n\n\tdev_dbg(rtk->dev,\n\t\t\"RTKit: received endpoint bitmap 0x%lx with base 0x%x\\n\",\n\t\tbitmap, base);\n\n\tfor_each_set_bit(i, &bitmap, 32) {\n\t\tep = 32 * base + i;\n\t\tdev_dbg(rtk->dev, \"RTKit: Discovered endpoint 0x%02x\\n\", ep);\n\t\tset_bit(ep, rtk->endpoints);\n\t}\n\n\treply = FIELD_PREP(APPLE_RTKIT_MGMT_EPMAP_BASE, base);\n\tif (msg & APPLE_RTKIT_MGMT_EPMAP_LAST)\n\t\treply |= APPLE_RTKIT_MGMT_EPMAP_LAST;\n\telse\n\t\treply |= APPLE_RTKIT_MGMT_EPMAP_REPLY_MORE;\n\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_EPMAP_REPLY, reply);\n\n\tif (!(msg & APPLE_RTKIT_MGMT_EPMAP_LAST))\n\t\treturn;\n\n\tfor_each_set_bit(ep, rtk->endpoints, APPLE_RTKIT_APP_ENDPOINT_START) {\n\t\tswitch (ep) {\n\t\t \n\t\tcase APPLE_RTKIT_EP_MGMT:\n\t\t\tbreak;\n\n\t\t \n\t\tcase APPLE_RTKIT_EP_SYSLOG:\n\t\tcase APPLE_RTKIT_EP_CRASHLOG:\n\t\tcase APPLE_RTKIT_EP_DEBUG:\n\t\tcase APPLE_RTKIT_EP_IOREPORT:\n\t\tcase APPLE_RTKIT_EP_OSLOG:\n\t\t\tdev_dbg(rtk->dev,\n\t\t\t\t\"RTKit: Starting system endpoint 0x%02x\\n\", ep);\n\t\t\tapple_rtkit_start_ep(rtk, ep);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(rtk->dev,\n\t\t\t\t \"RTKit: Unknown system endpoint: 0x%02x\\n\",\n\t\t\t\t ep);\n\t\t}\n\t}\n\n\trtk->boot_result = 0;\n\tcomplete_all(&rtk->epmap_completion);\n}\n\nstatic void apple_rtkit_management_rx_iop_pwr_ack(struct apple_rtkit *rtk,\n\t\t\t\t\t\t  u64 msg)\n{\n\tunsigned int new_state = FIELD_GET(APPLE_RTKIT_MGMT_PWR_STATE, msg);\n\n\tdev_dbg(rtk->dev, \"RTKit: IOP power state transition: 0x%x -> 0x%x\\n\",\n\t\trtk->iop_power_state, new_state);\n\trtk->iop_power_state = new_state;\n\n\tcomplete_all(&rtk->iop_pwr_ack_completion);\n}\n\nstatic void apple_rtkit_management_rx_ap_pwr_ack(struct apple_rtkit *rtk,\n\t\t\t\t\t\t u64 msg)\n{\n\tunsigned int new_state = FIELD_GET(APPLE_RTKIT_MGMT_PWR_STATE, msg);\n\n\tdev_dbg(rtk->dev, \"RTKit: AP power state transition: 0x%x -> 0x%x\\n\",\n\t\trtk->ap_power_state, new_state);\n\trtk->ap_power_state = new_state;\n\n\tcomplete_all(&rtk->ap_pwr_ack_completion);\n}\n\nstatic void apple_rtkit_management_rx(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 type = FIELD_GET(APPLE_RTKIT_MGMT_TYPE, msg);\n\n\tswitch (type) {\n\tcase APPLE_RTKIT_MGMT_HELLO:\n\t\tapple_rtkit_management_rx_hello(rtk, msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_MGMT_EPMAP:\n\t\tapple_rtkit_management_rx_epmap(rtk, msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_MGMT_SET_IOP_PWR_STATE_ACK:\n\t\tapple_rtkit_management_rx_iop_pwr_ack(rtk, msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_MGMT_SET_AP_PWR_STATE_ACK:\n\t\tapple_rtkit_management_rx_ap_pwr_ack(rtk, msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(\n\t\t\trtk->dev,\n\t\t\t\"RTKit: unknown management message: 0x%llx (type: 0x%02x)\\n\",\n\t\t\tmsg, type);\n\t}\n}\n\nstatic int apple_rtkit_common_rx_get_buffer(struct apple_rtkit *rtk,\n\t\t\t\t\t    struct apple_rtkit_shmem *buffer,\n\t\t\t\t\t    u8 ep, u64 msg)\n{\n\tsize_t n_4kpages = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_SIZE, msg);\n\tu64 reply;\n\tint err;\n\n\tbuffer->buffer = NULL;\n\tbuffer->iomem = NULL;\n\tbuffer->is_mapped = false;\n\tbuffer->iova = FIELD_GET(APPLE_RTKIT_BUFFER_REQUEST_IOVA, msg);\n\tbuffer->size = n_4kpages << 12;\n\n\tdev_dbg(rtk->dev, \"RTKit: buffer request for 0x%zx bytes at %pad\\n\",\n\t\tbuffer->size, &buffer->iova);\n\n\tif (buffer->iova &&\n\t    (!rtk->ops->shmem_setup || !rtk->ops->shmem_destroy)) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (rtk->ops->shmem_setup) {\n\t\terr = rtk->ops->shmem_setup(rtk->cookie, buffer);\n\t\tif (err)\n\t\t\tgoto error;\n\t} else {\n\t\tbuffer->buffer = dma_alloc_coherent(rtk->dev, buffer->size,\n\t\t\t\t\t\t    &buffer->iova, GFP_KERNEL);\n\t\tif (!buffer->buffer) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (!buffer->is_mapped) {\n\t\treply = FIELD_PREP(APPLE_RTKIT_SYSLOG_TYPE,\n\t\t\t\t   APPLE_RTKIT_BUFFER_REQUEST);\n\t\treply |= FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_SIZE, n_4kpages);\n\t\treply |= FIELD_PREP(APPLE_RTKIT_BUFFER_REQUEST_IOVA,\n\t\t\t\t    buffer->iova);\n\t\tapple_rtkit_send_message(rtk, ep, reply, NULL, false);\n\t}\n\n\treturn 0;\n\nerror:\n\tbuffer->buffer = NULL;\n\tbuffer->iomem = NULL;\n\tbuffer->iova = 0;\n\tbuffer->size = 0;\n\tbuffer->is_mapped = false;\n\treturn err;\n}\n\nstatic void apple_rtkit_free_buffer(struct apple_rtkit *rtk,\n\t\t\t\t    struct apple_rtkit_shmem *bfr)\n{\n\tif (bfr->size == 0)\n\t\treturn;\n\n\tif (rtk->ops->shmem_destroy)\n\t\trtk->ops->shmem_destroy(rtk->cookie, bfr);\n\telse if (bfr->buffer)\n\t\tdma_free_coherent(rtk->dev, bfr->size, bfr->buffer, bfr->iova);\n\n\tbfr->buffer = NULL;\n\tbfr->iomem = NULL;\n\tbfr->iova = 0;\n\tbfr->size = 0;\n\tbfr->is_mapped = false;\n}\n\nstatic void apple_rtkit_memcpy(struct apple_rtkit *rtk, void *dst,\n\t\t\t       struct apple_rtkit_shmem *bfr, size_t offset,\n\t\t\t       size_t len)\n{\n\tif (bfr->iomem)\n\t\tmemcpy_fromio(dst, bfr->iomem + offset, len);\n\telse\n\t\tmemcpy(dst, bfr->buffer + offset, len);\n}\n\nstatic void apple_rtkit_crashlog_rx(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);\n\tu8 *bfr;\n\n\tif (type != APPLE_RTKIT_CRASHLOG_CRASH) {\n\t\tdev_warn(rtk->dev, \"RTKit: Unknown crashlog message: %llx\\n\",\n\t\t\t msg);\n\t\treturn;\n\t}\n\n\tif (!rtk->crashlog_buffer.size) {\n\t\tapple_rtkit_common_rx_get_buffer(rtk, &rtk->crashlog_buffer,\n\t\t\t\t\t\t APPLE_RTKIT_EP_CRASHLOG, msg);\n\t\treturn;\n\t}\n\n\tdev_err(rtk->dev, \"RTKit: co-processor has crashed\\n\");\n\n\t \n\tbfr = kzalloc(rtk->crashlog_buffer.size, GFP_KERNEL);\n\tif (bfr) {\n\t\tapple_rtkit_memcpy(rtk, bfr, &rtk->crashlog_buffer, 0,\n\t\t\t\t   rtk->crashlog_buffer.size);\n\t\tapple_rtkit_crashlog_dump(rtk, bfr, rtk->crashlog_buffer.size);\n\t\tkfree(bfr);\n\t} else {\n\t\tdev_err(rtk->dev,\n\t\t\t\"RTKit: Couldn't allocate crashlog shadow buffer\\n\");\n\t}\n\n\trtk->crashed = true;\n\tif (rtk->ops->crashed)\n\t\trtk->ops->crashed(rtk->cookie);\n}\n\nstatic void apple_rtkit_ioreport_rx(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);\n\n\tswitch (type) {\n\tcase APPLE_RTKIT_BUFFER_REQUEST:\n\t\tapple_rtkit_common_rx_get_buffer(rtk, &rtk->ioreport_buffer,\n\t\t\t\t\t\t APPLE_RTKIT_EP_IOREPORT, msg);\n\t\tbreak;\n\t \n\tcase 0x8:\n\tcase 0xc:\n\t\tapple_rtkit_send_message(rtk, APPLE_RTKIT_EP_IOREPORT, msg,\n\t\t\t\t\t NULL, false);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(rtk->dev, \"RTKit: Unknown ioreport message: %llx\\n\",\n\t\t\t msg);\n\t}\n}\n\nstatic void apple_rtkit_syslog_rx_init(struct apple_rtkit *rtk, u64 msg)\n{\n\trtk->syslog_n_entries = FIELD_GET(APPLE_RTKIT_SYSLOG_N_ENTRIES, msg);\n\trtk->syslog_msg_size = FIELD_GET(APPLE_RTKIT_SYSLOG_MSG_SIZE, msg);\n\n\trtk->syslog_msg_buffer = kzalloc(rtk->syslog_msg_size, GFP_KERNEL);\n\n\tdev_dbg(rtk->dev,\n\t\t\"RTKit: syslog initialized: entries: %zd, msg_size: %zd\\n\",\n\t\trtk->syslog_n_entries, rtk->syslog_msg_size);\n}\n\nstatic bool should_crop_syslog_char(char c)\n{\n\treturn c == '\\n' || c == '\\r' || c == ' ' || c == '\\0';\n}\n\nstatic void apple_rtkit_syslog_rx_log(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 idx = msg & 0xff;\n\tchar log_context[24];\n\tsize_t entry_size = 0x20 + rtk->syslog_msg_size;\n\tint msglen;\n\n\tif (!rtk->syslog_msg_buffer) {\n\t\tdev_warn(\n\t\t\trtk->dev,\n\t\t\t\"RTKit: received syslog message but no syslog_msg_buffer\\n\");\n\t\tgoto done;\n\t}\n\tif (!rtk->syslog_buffer.size) {\n\t\tdev_warn(\n\t\t\trtk->dev,\n\t\t\t\"RTKit: received syslog message but syslog_buffer.size is zero\\n\");\n\t\tgoto done;\n\t}\n\tif (!rtk->syslog_buffer.buffer && !rtk->syslog_buffer.iomem) {\n\t\tdev_warn(\n\t\t\trtk->dev,\n\t\t\t\"RTKit: received syslog message but no syslog_buffer.buffer or syslog_buffer.iomem\\n\");\n\t\tgoto done;\n\t}\n\tif (idx > rtk->syslog_n_entries) {\n\t\tdev_warn(rtk->dev, \"RTKit: syslog index %d out of range\\n\",\n\t\t\t idx);\n\t\tgoto done;\n\t}\n\n\tapple_rtkit_memcpy(rtk, log_context, &rtk->syslog_buffer,\n\t\t\t   idx * entry_size + 8, sizeof(log_context));\n\tapple_rtkit_memcpy(rtk, rtk->syslog_msg_buffer, &rtk->syslog_buffer,\n\t\t\t   idx * entry_size + 8 + sizeof(log_context),\n\t\t\t   rtk->syslog_msg_size);\n\n\tlog_context[sizeof(log_context) - 1] = 0;\n\n\tmsglen = rtk->syslog_msg_size - 1;\n\twhile (msglen > 0 &&\n\t\t   should_crop_syslog_char(rtk->syslog_msg_buffer[msglen - 1]))\n\t\tmsglen--;\n\n\trtk->syslog_msg_buffer[msglen] = 0;\n\tdev_info(rtk->dev, \"RTKit: syslog message: %s: %s\\n\", log_context,\n\t\t rtk->syslog_msg_buffer);\n\ndone:\n\tapple_rtkit_send_message(rtk, APPLE_RTKIT_EP_SYSLOG, msg, NULL, false);\n}\n\nstatic void apple_rtkit_syslog_rx(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 type = FIELD_GET(APPLE_RTKIT_SYSLOG_TYPE, msg);\n\n\tswitch (type) {\n\tcase APPLE_RTKIT_BUFFER_REQUEST:\n\t\tapple_rtkit_common_rx_get_buffer(rtk, &rtk->syslog_buffer,\n\t\t\t\t\t\t APPLE_RTKIT_EP_SYSLOG, msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_SYSLOG_INIT:\n\t\tapple_rtkit_syslog_rx_init(rtk, msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_SYSLOG_LOG:\n\t\tapple_rtkit_syslog_rx_log(rtk, msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(rtk->dev, \"RTKit: Unknown syslog message: %llx\\n\",\n\t\t\t msg);\n\t}\n}\n\nstatic void apple_rtkit_oslog_rx_init(struct apple_rtkit *rtk, u64 msg)\n{\n\tu64 ack;\n\n\tdev_dbg(rtk->dev, \"RTKit: oslog init: msg: 0x%llx\\n\", msg);\n\tack = FIELD_PREP(APPLE_RTKIT_OSLOG_TYPE, APPLE_RTKIT_OSLOG_ACK);\n\tapple_rtkit_send_message(rtk, APPLE_RTKIT_EP_OSLOG, ack, NULL, false);\n}\n\nstatic void apple_rtkit_oslog_rx(struct apple_rtkit *rtk, u64 msg)\n{\n\tu8 type = FIELD_GET(APPLE_RTKIT_OSLOG_TYPE, msg);\n\n\tswitch (type) {\n\tcase APPLE_RTKIT_OSLOG_INIT:\n\t\tapple_rtkit_oslog_rx_init(rtk, msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(rtk->dev, \"RTKit: Unknown oslog message: %llx\\n\", msg);\n\t}\n}\n\nstatic void apple_rtkit_rx_work(struct work_struct *work)\n{\n\tstruct apple_rtkit_rx_work *rtk_work =\n\t\tcontainer_of(work, struct apple_rtkit_rx_work, work);\n\tstruct apple_rtkit *rtk = rtk_work->rtk;\n\n\tswitch (rtk_work->ep) {\n\tcase APPLE_RTKIT_EP_MGMT:\n\t\tapple_rtkit_management_rx(rtk, rtk_work->msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_EP_CRASHLOG:\n\t\tapple_rtkit_crashlog_rx(rtk, rtk_work->msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_EP_SYSLOG:\n\t\tapple_rtkit_syslog_rx(rtk, rtk_work->msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_EP_IOREPORT:\n\t\tapple_rtkit_ioreport_rx(rtk, rtk_work->msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_EP_OSLOG:\n\t\tapple_rtkit_oslog_rx(rtk, rtk_work->msg);\n\t\tbreak;\n\tcase APPLE_RTKIT_APP_ENDPOINT_START ... 0xff:\n\t\tif (rtk->ops->recv_message)\n\t\t\trtk->ops->recv_message(rtk->cookie, rtk_work->ep,\n\t\t\t\t\t       rtk_work->msg);\n\t\telse\n\t\t\tdev_warn(\n\t\t\t\trtk->dev,\n\t\t\t\t\"Received unexpected message to EP%02d: %llx\\n\",\n\t\t\t\trtk_work->ep, rtk_work->msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(rtk->dev,\n\t\t\t \"RTKit: message to unknown endpoint %02x: %llx\\n\",\n\t\t\t rtk_work->ep, rtk_work->msg);\n\t}\n\n\tkfree(rtk_work);\n}\n\nstatic void apple_rtkit_rx(struct mbox_client *cl, void *mssg)\n{\n\tstruct apple_rtkit *rtk = container_of(cl, struct apple_rtkit, mbox_cl);\n\tstruct apple_mbox_msg *msg = mssg;\n\tstruct apple_rtkit_rx_work *work;\n\tu8 ep = msg->msg1;\n\n\t \n\tdma_rmb();\n\n\tif (!test_bit(ep, rtk->endpoints))\n\t\tdev_warn(rtk->dev,\n\t\t\t \"RTKit: Message to undiscovered endpoint 0x%02x\\n\",\n\t\t\t ep);\n\n\tif (ep >= APPLE_RTKIT_APP_ENDPOINT_START &&\n\t    rtk->ops->recv_message_early &&\n\t    rtk->ops->recv_message_early(rtk->cookie, ep, msg->msg0))\n\t\treturn;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn;\n\n\twork->rtk = rtk;\n\twork->ep = ep;\n\twork->msg = msg->msg0;\n\tINIT_WORK(&work->work, apple_rtkit_rx_work);\n\tqueue_work(rtk->wq, &work->work);\n}\n\nstatic void apple_rtkit_tx_done(struct mbox_client *cl, void *mssg, int r)\n{\n\tstruct apple_rtkit_msg *msg =\n\t\tcontainer_of(mssg, struct apple_rtkit_msg, mbox_msg);\n\n\tif (r == -ETIME)\n\t\treturn;\n\n\tif (msg->completion)\n\t\tcomplete(msg->completion);\n\tkfree(msg);\n}\n\nint apple_rtkit_send_message(struct apple_rtkit *rtk, u8 ep, u64 message,\n\t\t\t     struct completion *completion, bool atomic)\n{\n\tstruct apple_rtkit_msg *msg;\n\tint ret;\n\tgfp_t flags;\n\n\tif (rtk->crashed)\n\t\treturn -EINVAL;\n\tif (ep >= APPLE_RTKIT_APP_ENDPOINT_START &&\n\t    !apple_rtkit_is_running(rtk))\n\t\treturn -EINVAL;\n\n\tif (atomic)\n\t\tflags = GFP_ATOMIC;\n\telse\n\t\tflags = GFP_KERNEL;\n\n\tmsg = kzalloc(sizeof(*msg), flags);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->mbox_msg.msg0 = message;\n\tmsg->mbox_msg.msg1 = ep;\n\tmsg->completion = completion;\n\n\t \n\tdma_wmb();\n\n\tret = mbox_send_message(rtk->mbox_chan, &msg->mbox_msg);\n\tif (ret < 0) {\n\t\tkfree(msg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_send_message);\n\nint apple_rtkit_send_message_wait(struct apple_rtkit *rtk, u8 ep, u64 message,\n\t\t\t\t  unsigned long timeout, bool atomic)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint ret;\n\tlong t;\n\n\tret = apple_rtkit_send_message(rtk, ep, message, &completion, atomic);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (atomic) {\n\t\tret = mbox_flush(rtk->mbox_chan, timeout);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (try_wait_for_completion(&completion))\n\t\t\treturn 0;\n\n\t\treturn -ETIME;\n\t} else {\n\t\tt = wait_for_completion_interruptible_timeout(\n\t\t\t&completion, msecs_to_jiffies(timeout));\n\t\tif (t < 0)\n\t\t\treturn t;\n\t\telse if (t == 0)\n\t\t\treturn -ETIME;\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_send_message_wait);\n\nint apple_rtkit_poll(struct apple_rtkit *rtk)\n{\n\treturn mbox_client_peek_data(rtk->mbox_chan);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_poll);\n\nint apple_rtkit_start_ep(struct apple_rtkit *rtk, u8 endpoint)\n{\n\tu64 msg;\n\n\tif (!test_bit(endpoint, rtk->endpoints))\n\t\treturn -EINVAL;\n\tif (endpoint >= APPLE_RTKIT_APP_ENDPOINT_START &&\n\t    !apple_rtkit_is_running(rtk))\n\t\treturn -EINVAL;\n\n\tmsg = FIELD_PREP(APPLE_RTKIT_MGMT_STARTEP_EP, endpoint);\n\tmsg |= APPLE_RTKIT_MGMT_STARTEP_FLAG;\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_STARTEP, msg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_start_ep);\n\nstatic int apple_rtkit_request_mbox_chan(struct apple_rtkit *rtk)\n{\n\tif (rtk->mbox_name)\n\t\trtk->mbox_chan = mbox_request_channel_byname(&rtk->mbox_cl,\n\t\t\t\t\t\t\t     rtk->mbox_name);\n\telse\n\t\trtk->mbox_chan =\n\t\t\tmbox_request_channel(&rtk->mbox_cl, rtk->mbox_idx);\n\n\tif (IS_ERR(rtk->mbox_chan))\n\t\treturn PTR_ERR(rtk->mbox_chan);\n\treturn 0;\n}\n\nstruct apple_rtkit *apple_rtkit_init(struct device *dev, void *cookie,\n\t\t\t\t\t    const char *mbox_name, int mbox_idx,\n\t\t\t\t\t    const struct apple_rtkit_ops *ops)\n{\n\tstruct apple_rtkit *rtk;\n\tint ret;\n\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trtk = kzalloc(sizeof(*rtk), GFP_KERNEL);\n\tif (!rtk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trtk->dev = dev;\n\trtk->cookie = cookie;\n\trtk->ops = ops;\n\n\tinit_completion(&rtk->epmap_completion);\n\tinit_completion(&rtk->iop_pwr_ack_completion);\n\tinit_completion(&rtk->ap_pwr_ack_completion);\n\n\tbitmap_zero(rtk->endpoints, APPLE_RTKIT_MAX_ENDPOINTS);\n\tset_bit(APPLE_RTKIT_EP_MGMT, rtk->endpoints);\n\n\trtk->mbox_name = mbox_name;\n\trtk->mbox_idx = mbox_idx;\n\trtk->mbox_cl.dev = dev;\n\trtk->mbox_cl.tx_block = false;\n\trtk->mbox_cl.knows_txdone = false;\n\trtk->mbox_cl.rx_callback = &apple_rtkit_rx;\n\trtk->mbox_cl.tx_done = &apple_rtkit_tx_done;\n\n\trtk->wq = alloc_ordered_workqueue(\"rtkit-%s\", WQ_MEM_RECLAIM,\n\t\t\t\t\t  dev_name(rtk->dev));\n\tif (!rtk->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto free_rtk;\n\t}\n\n\tret = apple_rtkit_request_mbox_chan(rtk);\n\tif (ret)\n\t\tgoto destroy_wq;\n\n\treturn rtk;\n\ndestroy_wq:\n\tdestroy_workqueue(rtk->wq);\nfree_rtk:\n\tkfree(rtk);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_init);\n\nstatic int apple_rtkit_wait_for_completion(struct completion *c)\n{\n\tlong t;\n\n\tt = wait_for_completion_interruptible_timeout(c,\n\t\t\t\t\t\t      msecs_to_jiffies(1000));\n\tif (t < 0)\n\t\treturn t;\n\telse if (t == 0)\n\t\treturn -ETIME;\n\telse\n\t\treturn 0;\n}\n\nint apple_rtkit_reinit(struct apple_rtkit *rtk)\n{\n\t \n\tmbox_free_channel(rtk->mbox_chan);\n\tflush_workqueue(rtk->wq);\n\n\tapple_rtkit_free_buffer(rtk, &rtk->ioreport_buffer);\n\tapple_rtkit_free_buffer(rtk, &rtk->crashlog_buffer);\n\tapple_rtkit_free_buffer(rtk, &rtk->syslog_buffer);\n\n\tkfree(rtk->syslog_msg_buffer);\n\n\trtk->syslog_msg_buffer = NULL;\n\trtk->syslog_n_entries = 0;\n\trtk->syslog_msg_size = 0;\n\n\tbitmap_zero(rtk->endpoints, APPLE_RTKIT_MAX_ENDPOINTS);\n\tset_bit(APPLE_RTKIT_EP_MGMT, rtk->endpoints);\n\n\treinit_completion(&rtk->epmap_completion);\n\treinit_completion(&rtk->iop_pwr_ack_completion);\n\treinit_completion(&rtk->ap_pwr_ack_completion);\n\n\trtk->crashed = false;\n\trtk->iop_power_state = APPLE_RTKIT_PWR_STATE_OFF;\n\trtk->ap_power_state = APPLE_RTKIT_PWR_STATE_OFF;\n\n\treturn apple_rtkit_request_mbox_chan(rtk);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_reinit);\n\nstatic int apple_rtkit_set_ap_power_state(struct apple_rtkit *rtk,\n\t\t\t\t\t  unsigned int state)\n{\n\tu64 msg;\n\tint ret;\n\n\treinit_completion(&rtk->ap_pwr_ack_completion);\n\n\tmsg = FIELD_PREP(APPLE_RTKIT_MGMT_PWR_STATE, state);\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_SET_AP_PWR_STATE,\n\t\t\t\t    msg);\n\n\tret = apple_rtkit_wait_for_completion(&rtk->ap_pwr_ack_completion);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rtk->ap_power_state != state)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int apple_rtkit_set_iop_power_state(struct apple_rtkit *rtk,\n\t\t\t\t\t   unsigned int state)\n{\n\tu64 msg;\n\tint ret;\n\n\treinit_completion(&rtk->iop_pwr_ack_completion);\n\n\tmsg = FIELD_PREP(APPLE_RTKIT_MGMT_PWR_STATE, state);\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_SET_IOP_PWR_STATE,\n\t\t\t\t    msg);\n\n\tret = apple_rtkit_wait_for_completion(&rtk->iop_pwr_ack_completion);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rtk->iop_power_state != state)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint apple_rtkit_boot(struct apple_rtkit *rtk)\n{\n\tint ret;\n\n\tif (apple_rtkit_is_running(rtk))\n\t\treturn 0;\n\tif (rtk->crashed)\n\t\treturn -EINVAL;\n\n\tdev_dbg(rtk->dev, \"RTKit: waiting for boot to finish\\n\");\n\tret = apple_rtkit_wait_for_completion(&rtk->epmap_completion);\n\tif (ret)\n\t\treturn ret;\n\tif (rtk->boot_result)\n\t\treturn rtk->boot_result;\n\n\tdev_dbg(rtk->dev, \"RTKit: waiting for IOP power state ACK\\n\");\n\tret = apple_rtkit_wait_for_completion(&rtk->iop_pwr_ack_completion);\n\tif (ret)\n\t\treturn ret;\n\n\treturn apple_rtkit_set_ap_power_state(rtk, APPLE_RTKIT_PWR_STATE_ON);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_boot);\n\nint apple_rtkit_shutdown(struct apple_rtkit *rtk)\n{\n\tint ret;\n\n\t \n\tret = apple_rtkit_set_ap_power_state(rtk,\n\t\t\t\t\t     APPLE_RTKIT_PWR_STATE_QUIESCED);\n\tif (ret)\n\t\treturn ret;\n\n\tret = apple_rtkit_set_iop_power_state(rtk, APPLE_RTKIT_PWR_STATE_SLEEP);\n\tif (ret)\n\t\treturn ret;\n\n\treturn apple_rtkit_reinit(rtk);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_shutdown);\n\nint apple_rtkit_idle(struct apple_rtkit *rtk)\n{\n\tint ret;\n\n\t \n\tret = apple_rtkit_set_ap_power_state(rtk,\n\t\t\t\t\t     APPLE_RTKIT_PWR_STATE_IDLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = apple_rtkit_set_iop_power_state(rtk, APPLE_RTKIT_PWR_STATE_IDLE);\n\tif (ret)\n\t\treturn ret;\n\n\trtk->iop_power_state = APPLE_RTKIT_PWR_STATE_IDLE;\n\trtk->ap_power_state = APPLE_RTKIT_PWR_STATE_IDLE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_idle);\n\nint apple_rtkit_quiesce(struct apple_rtkit *rtk)\n{\n\tint ret;\n\n\tret = apple_rtkit_set_ap_power_state(rtk,\n\t\t\t\t\t     APPLE_RTKIT_PWR_STATE_QUIESCED);\n\tif (ret)\n\t\treturn ret;\n\n\tret = apple_rtkit_set_iop_power_state(rtk,\n\t\t\t\t\t      APPLE_RTKIT_PWR_STATE_QUIESCED);\n\tif (ret)\n\t\treturn ret;\n\n\tret = apple_rtkit_reinit(rtk);\n\tif (ret)\n\t\treturn ret;\n\n\trtk->iop_power_state = APPLE_RTKIT_PWR_STATE_QUIESCED;\n\trtk->ap_power_state = APPLE_RTKIT_PWR_STATE_QUIESCED;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_quiesce);\n\nint apple_rtkit_wake(struct apple_rtkit *rtk)\n{\n\tu64 msg;\n\n\tif (apple_rtkit_is_running(rtk))\n\t\treturn -EINVAL;\n\n\treinit_completion(&rtk->iop_pwr_ack_completion);\n\n\t \n\tmsg = FIELD_PREP(APPLE_RTKIT_MGMT_PWR_STATE, APPLE_RTKIT_PWR_STATE_ON);\n\tapple_rtkit_management_send(rtk, APPLE_RTKIT_MGMT_SET_IOP_PWR_STATE,\n\t\t\t\t    msg);\n\n\treturn apple_rtkit_boot(rtk);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_wake);\n\nvoid apple_rtkit_free(struct apple_rtkit *rtk)\n{\n\tmbox_free_channel(rtk->mbox_chan);\n\tdestroy_workqueue(rtk->wq);\n\n\tapple_rtkit_free_buffer(rtk, &rtk->ioreport_buffer);\n\tapple_rtkit_free_buffer(rtk, &rtk->crashlog_buffer);\n\tapple_rtkit_free_buffer(rtk, &rtk->syslog_buffer);\n\n\tkfree(rtk->syslog_msg_buffer);\n\tkfree(rtk);\n}\nEXPORT_SYMBOL_GPL(apple_rtkit_free);\n\nstatic void apple_rtkit_free_wrapper(void *data)\n{\n\tapple_rtkit_free(data);\n}\n\nstruct apple_rtkit *devm_apple_rtkit_init(struct device *dev, void *cookie,\n\t\t\t\t\t  const char *mbox_name, int mbox_idx,\n\t\t\t\t\t  const struct apple_rtkit_ops *ops)\n{\n\tstruct apple_rtkit *rtk;\n\tint ret;\n\n\trtk = apple_rtkit_init(dev, cookie, mbox_name, mbox_idx, ops);\n\tif (IS_ERR(rtk))\n\t\treturn rtk;\n\n\tret = devm_add_action_or_reset(dev, apple_rtkit_free_wrapper, rtk);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn rtk;\n}\nEXPORT_SYMBOL_GPL(devm_apple_rtkit_init);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_DESCRIPTION(\"Apple RTKit driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}