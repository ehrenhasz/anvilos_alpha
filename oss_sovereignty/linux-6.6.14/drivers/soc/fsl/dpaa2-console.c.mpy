{
  "module_name": "dpaa2-console.c",
  "hash_id": "017249abc0d94ec053dede07d4ea29ad4e0a9a0705d9542936c76dae42def72c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/dpaa2-console.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dpaa2-console: \" fmt\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/miscdevice.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n\n \n#define MCFBALR_OFFSET 0\n#define MCFBAHR_OFFSET 1\n\n \n#define MC_FW_ADDR_MASK_HIGH 0x1FFFF\n#define MC_FW_ADDR_MASK_LOW  0xE0000000\n\n#define MC_BUFFER_OFFSET 0x01000000\n#define MC_BUFFER_SIZE   (1024 * 1024 * 16)\n#define MC_OFFSET_DELTA  MC_BUFFER_OFFSET\n\n#define AIOP_BUFFER_OFFSET 0x06000000\n#define AIOP_BUFFER_SIZE   (1024 * 1024 * 16)\n#define AIOP_OFFSET_DELTA  0\n\n#define LOG_HEADER_FLAG_BUFFER_WRAPAROUND 0x80000000\n#define LAST_BYTE(a) ((a) & ~(LOG_HEADER_FLAG_BUFFER_WRAPAROUND))\n\n \n#define MAGIC_MC   0x4d430100\n#define MAGIC_AIOP 0x41494F50\n\nstruct log_header {\n\t__le32 magic_word;\n\tchar reserved[4];\n\t__le32 buf_start;\n\t__le32 buf_length;\n\t__le32 last_byte;\n};\n\nstruct console_data {\n\tvoid __iomem *map_addr;\n\tstruct log_header __iomem *hdr;\n\tvoid __iomem *start_addr;\n\tvoid __iomem *end_addr;\n\tvoid __iomem *end_of_data;\n\tvoid __iomem *cur_ptr;\n};\n\nstatic struct resource mc_base_addr;\n\nstatic inline void adjust_end(struct console_data *cd)\n{\n\tu32 last_byte = readl(&cd->hdr->last_byte);\n\n\tcd->end_of_data = cd->start_addr + LAST_BYTE(last_byte);\n}\n\nstatic u64 get_mc_fw_base_address(void)\n{\n\tu64 mcfwbase = 0ULL;\n\tu32 __iomem *mcfbaregs;\n\n\tmcfbaregs = ioremap(mc_base_addr.start, resource_size(&mc_base_addr));\n\tif (!mcfbaregs) {\n\t\tpr_err(\"could not map MC Firmware Base registers\\n\");\n\t\treturn 0;\n\t}\n\n\tmcfwbase  = readl(mcfbaregs + MCFBAHR_OFFSET) &\n\t\t\t  MC_FW_ADDR_MASK_HIGH;\n\tmcfwbase <<= 32;\n\tmcfwbase |= readl(mcfbaregs + MCFBALR_OFFSET) & MC_FW_ADDR_MASK_LOW;\n\tiounmap(mcfbaregs);\n\n\tpr_debug(\"MC base address at 0x%016llx\\n\", mcfwbase);\n\treturn mcfwbase;\n}\n\nstatic ssize_t dpaa2_console_size(struct console_data *cd)\n{\n\tssize_t size;\n\n\tif (cd->cur_ptr <= cd->end_of_data)\n\t\tsize = cd->end_of_data - cd->cur_ptr;\n\telse\n\t\tsize = (cd->end_addr - cd->cur_ptr) +\n\t\t\t(cd->end_of_data - cd->start_addr);\n\n\treturn size;\n}\n\nstatic int dpaa2_generic_console_open(struct inode *node, struct file *fp,\n\t\t\t\t      u64 offset, u64 size,\n\t\t\t\t      u32 expected_magic,\n\t\t\t\t      u32 offset_delta)\n{\n\tu32 read_magic, wrapped, last_byte, buf_start, buf_length;\n\tstruct console_data *cd;\n\tu64 base_addr;\n\tint err;\n\n\tcd = kmalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd)\n\t\treturn -ENOMEM;\n\n\tbase_addr = get_mc_fw_base_address();\n\tif (!base_addr) {\n\t\terr = -EIO;\n\t\tgoto err_fwba;\n\t}\n\n\tcd->map_addr = ioremap(base_addr + offset, size);\n\tif (!cd->map_addr) {\n\t\tpr_err(\"cannot map console log memory\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tcd->hdr = (struct log_header __iomem *)cd->map_addr;\n\tread_magic = readl(&cd->hdr->magic_word);\n\tlast_byte =  readl(&cd->hdr->last_byte);\n\tbuf_start =  readl(&cd->hdr->buf_start);\n\tbuf_length = readl(&cd->hdr->buf_length);\n\n\tif (read_magic != expected_magic) {\n\t\tpr_warn(\"expected = %08x, read = %08x\\n\",\n\t\t\texpected_magic, read_magic);\n\t\terr = -EIO;\n\t\tgoto err_magic;\n\t}\n\n\tcd->start_addr = cd->map_addr + buf_start - offset_delta;\n\tcd->end_addr = cd->start_addr + buf_length;\n\n\twrapped = last_byte & LOG_HEADER_FLAG_BUFFER_WRAPAROUND;\n\n\tadjust_end(cd);\n\tif (wrapped && cd->end_of_data != cd->end_addr)\n\t\tcd->cur_ptr = cd->end_of_data + 1;\n\telse\n\t\tcd->cur_ptr = cd->start_addr;\n\n\tfp->private_data = cd;\n\n\treturn 0;\n\nerr_magic:\n\tiounmap(cd->map_addr);\n\nerr_ioremap:\nerr_fwba:\n\tkfree(cd);\n\n\treturn err;\n}\n\nstatic int dpaa2_mc_console_open(struct inode *node, struct file *fp)\n{\n\treturn dpaa2_generic_console_open(node, fp,\n\t\t\t\t\t  MC_BUFFER_OFFSET, MC_BUFFER_SIZE,\n\t\t\t\t\t  MAGIC_MC, MC_OFFSET_DELTA);\n}\n\nstatic int dpaa2_aiop_console_open(struct inode *node, struct file *fp)\n{\n\treturn dpaa2_generic_console_open(node, fp,\n\t\t\t\t\t  AIOP_BUFFER_OFFSET, AIOP_BUFFER_SIZE,\n\t\t\t\t\t  MAGIC_AIOP, AIOP_OFFSET_DELTA);\n}\n\nstatic int dpaa2_console_close(struct inode *node, struct file *fp)\n{\n\tstruct console_data *cd = fp->private_data;\n\n\tiounmap(cd->map_addr);\n\tkfree(cd);\n\treturn 0;\n}\n\nstatic ssize_t dpaa2_console_read(struct file *fp, char __user *buf,\n\t\t\t\t  size_t count, loff_t *f_pos)\n{\n\tstruct console_data *cd = fp->private_data;\n\tsize_t bytes = dpaa2_console_size(cd);\n\tsize_t bytes_end = cd->end_addr - cd->cur_ptr;\n\tsize_t written = 0;\n\tvoid *kbuf;\n\tint err;\n\n\t \n\tadjust_end(cd);\n\n\tif (cd->end_of_data == cd->cur_ptr)\n\t\treturn 0;\n\n\tif (count < bytes)\n\t\tbytes = count;\n\n\tkbuf = kmalloc(bytes, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (bytes > bytes_end) {\n\t\tmemcpy_fromio(kbuf, cd->cur_ptr, bytes_end);\n\t\tif (copy_to_user(buf, kbuf, bytes_end)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto err_free_buf;\n\t\t}\n\t\tbuf += bytes_end;\n\t\tcd->cur_ptr = cd->start_addr;\n\t\tbytes -= bytes_end;\n\t\twritten += bytes_end;\n\t}\n\n\tmemcpy_fromio(kbuf, cd->cur_ptr, bytes);\n\tif (copy_to_user(buf, kbuf, bytes)) {\n\t\terr = -EFAULT;\n\t\tgoto err_free_buf;\n\t}\n\tcd->cur_ptr += bytes;\n\twritten += bytes;\n\n\tkfree(kbuf);\n\treturn written;\n\nerr_free_buf:\n\tkfree(kbuf);\n\n\treturn err;\n}\n\nstatic const struct file_operations dpaa2_mc_console_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = dpaa2_mc_console_open,\n\t.release        = dpaa2_console_close,\n\t.read           = dpaa2_console_read,\n};\n\nstatic struct miscdevice dpaa2_mc_console_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"dpaa2_mc_console\",\n\t.fops = &dpaa2_mc_console_fops\n};\n\nstatic const struct file_operations dpaa2_aiop_console_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = dpaa2_aiop_console_open,\n\t.release        = dpaa2_console_close,\n\t.read           = dpaa2_console_read,\n};\n\nstatic struct miscdevice dpaa2_aiop_console_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"dpaa2_aiop_console\",\n\t.fops = &dpaa2_aiop_console_fops\n};\n\nstatic int dpaa2_console_probe(struct platform_device *pdev)\n{\n\tint error;\n\n\terror = of_address_to_resource(pdev->dev.of_node, 0, &mc_base_addr);\n\tif (error < 0) {\n\t\tpr_err(\"of_address_to_resource() failed for %pOF with %d\\n\",\n\t\t       pdev->dev.of_node, error);\n\t\treturn error;\n\t}\n\n\terror = misc_register(&dpaa2_mc_console_dev);\n\tif (error) {\n\t\tpr_err(\"cannot register device %s\\n\",\n\t\t       dpaa2_mc_console_dev.name);\n\t\tgoto err_register_mc;\n\t}\n\n\terror = misc_register(&dpaa2_aiop_console_dev);\n\tif (error) {\n\t\tpr_err(\"cannot register device %s\\n\",\n\t\t       dpaa2_aiop_console_dev.name);\n\t\tgoto err_register_aiop;\n\t}\n\n\treturn 0;\n\nerr_register_aiop:\n\tmisc_deregister(&dpaa2_mc_console_dev);\nerr_register_mc:\n\treturn error;\n}\n\nstatic int dpaa2_console_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&dpaa2_mc_console_dev);\n\tmisc_deregister(&dpaa2_aiop_console_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dpaa2_console_match_table[] = {\n\t{ .compatible = \"fsl,dpaa2-console\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dpaa2_console_match_table);\n\nstatic struct platform_driver dpaa2_console_driver = {\n\t.driver = {\n\t\t   .name = \"dpaa2-console\",\n\t\t   .pm = NULL,\n\t\t   .of_match_table = dpaa2_console_match_table,\n\t\t   },\n\t.probe = dpaa2_console_probe,\n\t.remove = dpaa2_console_remove,\n};\nmodule_platform_driver(dpaa2_console_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Roy Pledge <roy.pledge@nxp.com>\");\nMODULE_DESCRIPTION(\"DPAA2 console driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}