{
  "module_name": "rcpm.c",
  "hash_id": "196119cb14c4afd56f224b27e8e3c6c3e9d3cd4ecf0d57bbff398a09f1d6fa55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/rcpm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n\n#define RCPM_WAKEUP_CELL_MAX_SIZE\t7\n\nstruct rcpm {\n\tunsigned int\twakeup_cells;\n\tvoid __iomem\t*ippdexpcr_base;\n\tbool\t\tlittle_endian;\n};\n\n#define  SCFG_SPARECR8\t0x051c\n\nstatic void copy_ippdexpcr1_setting(u32 val)\n{\n\tstruct device_node *np;\n\tvoid __iomem *regs;\n\tu32 reg_val;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,ls1021a-scfg\");\n\tif (!np)\n\t\treturn;\n\n\tregs = of_iomap(np, 0);\n\tif (!regs)\n\t\treturn;\n\n\treg_val = ioread32be(regs + SCFG_SPARECR8);\n\tiowrite32be(val | reg_val, regs + SCFG_SPARECR8);\n\n\tiounmap(regs);\n}\n\n \nstatic int rcpm_pm_prepare(struct device *dev)\n{\n\tint i, ret, idx;\n\tvoid __iomem *base;\n\tstruct wakeup_source\t*ws;\n\tstruct rcpm\t\t*rcpm;\n\tstruct device_node\t*np = dev->of_node;\n\tu32 value[RCPM_WAKEUP_CELL_MAX_SIZE + 1];\n\tu32 setting[RCPM_WAKEUP_CELL_MAX_SIZE] = {0};\n\n\trcpm = dev_get_drvdata(dev);\n\tif (!rcpm)\n\t\treturn -EINVAL;\n\n\tbase = rcpm->ippdexpcr_base;\n\tidx = wakeup_sources_read_lock();\n\n\t \n\tfor_each_wakeup_source(ws) {\n\n\t\t \n\t\tif (!ws->dev || !ws->dev->parent)\n\t\t\tcontinue;\n\n\t\tret = device_property_read_u32_array(ws->dev->parent,\n\t\t\t\t\"fsl,rcpm-wakeup\", value,\n\t\t\t\trcpm->wakeup_cells + 1);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (is_of_node(dev->fwnode))\n\t\t\tif (np->phandle != value[0])\n\t\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < rcpm->wakeup_cells; i++)\n\t\t\tsetting[i] |= value[i + 1];\n\t}\n\n\twakeup_sources_read_unlock(idx);\n\n\t \n\tfor (i = 0; i < rcpm->wakeup_cells; i++) {\n\t\tu32 tmp = setting[i];\n\t\tvoid __iomem *address = base + i * 4;\n\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (rcpm->little_endian) {\n\t\t\ttmp |= ioread32(address);\n\t\t\tiowrite32(tmp, address);\n\t\t} else {\n\t\t\ttmp |= ioread32be(address);\n\t\t\tiowrite32be(tmp, address);\n\t\t}\n\t\t \n\t\tif (dev_of_node(dev) && (i == 1))\n\t\t\tif (of_device_is_compatible(np, \"fsl,ls1021a-rcpm\"))\n\t\t\t\tcopy_ippdexpcr1_setting(tmp);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rcpm_pm_ops = {\n\t.prepare =  rcpm_pm_prepare,\n};\n\nstatic int rcpm_probe(struct platform_device *pdev)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tstruct rcpm\t*rcpm;\n\tint ret;\n\n\trcpm = devm_kzalloc(dev, sizeof(*rcpm), GFP_KERNEL);\n\tif (!rcpm)\n\t\treturn -ENOMEM;\n\n\trcpm->ippdexpcr_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rcpm->ippdexpcr_base)) {\n\t\tret =  PTR_ERR(rcpm->ippdexpcr_base);\n\t\treturn ret;\n\t}\n\n\trcpm->little_endian = device_property_read_bool(\n\t\t\t&pdev->dev, \"little-endian\");\n\n\tret = device_property_read_u32(&pdev->dev,\n\t\t\t\"#fsl,rcpm-wakeup-cells\", &rcpm->wakeup_cells);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(&pdev->dev, rcpm);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rcpm_of_match[] = {\n\t{ .compatible = \"fsl,qoriq-rcpm-2.1+\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rcpm_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rcpm_acpi_ids[] = {\n\t{\"NXP0015\",},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rcpm_acpi_ids);\n#endif\n\nstatic struct platform_driver rcpm_driver = {\n\t.driver = {\n\t\t.name = \"rcpm\",\n\t\t.of_match_table = rcpm_of_match,\n\t\t.acpi_match_table = ACPI_PTR(rcpm_acpi_ids),\n\t\t.pm\t= &rcpm_pm_ops,\n\t},\n\t.probe = rcpm_probe,\n};\n\nmodule_platform_driver(rcpm_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}