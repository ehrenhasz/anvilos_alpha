{
  "module_name": "dpio-driver.c",
  "hash_id": "bfdcb6f702c74619eadfb1bd4f6d06f7916058e6d55790b9cd17b5049994dbbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/dpio/dpio-driver.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/sys_soc.h>\n\n#include <linux/fsl/mc.h>\n#include <soc/fsl/dpaa2-io.h>\n\n#include \"qbman-portal.h\"\n#include \"dpio.h\"\n#include \"dpio-cmd.h\"\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc\");\nMODULE_DESCRIPTION(\"DPIO Driver\");\n\nstruct dpio_priv {\n\tstruct dpaa2_io *io;\n};\n\nstatic cpumask_var_t cpus_unused_mask;\n\nstatic const struct soc_device_attribute ls1088a_soc[] = {\n\t{.family = \"QorIQ LS1088A\"},\n\t{   }\n};\n\nstatic const struct soc_device_attribute ls2080a_soc[] = {\n\t{.family = \"QorIQ LS2080A\"},\n\t{   }\n};\n\nstatic const struct soc_device_attribute ls2088a_soc[] = {\n\t{.family = \"QorIQ LS2088A\"},\n\t{   }\n};\n\nstatic const struct soc_device_attribute lx2160a_soc[] = {\n\t{.family = \"QorIQ LX2160A\"},\n\t{   }\n};\n\nstatic int dpaa2_dpio_get_cluster_sdest(struct fsl_mc_device *dpio_dev, int cpu)\n{\n\tint cluster_base, cluster_size;\n\n\tif (soc_device_match(ls1088a_soc)) {\n\t\tcluster_base = 2;\n\t\tcluster_size = 4;\n\t} else if (soc_device_match(ls2080a_soc) ||\n\t\t   soc_device_match(ls2088a_soc) ||\n\t\t   soc_device_match(lx2160a_soc)) {\n\t\tcluster_base = 0;\n\t\tcluster_size = 2;\n\t} else {\n\t\tdev_err(&dpio_dev->dev, \"unknown SoC version\\n\");\n\t\treturn -1;\n\t}\n\n\treturn cluster_base + cpu / cluster_size;\n}\n\nstatic irqreturn_t dpio_irq_handler(int irq_num, void *arg)\n{\n\tstruct device *dev = (struct device *)arg;\n\tstruct dpio_priv *priv = dev_get_drvdata(dev);\n\n\treturn dpaa2_io_irq(priv->io);\n}\n\nstatic void unregister_dpio_irq_handlers(struct fsl_mc_device *dpio_dev)\n{\n\tstruct fsl_mc_device_irq *irq;\n\n\tirq = dpio_dev->irqs[0];\n\n\t \n\tirq_set_affinity_hint(irq->virq, NULL);\n}\n\nstatic int register_dpio_irq_handlers(struct fsl_mc_device *dpio_dev, int cpu)\n{\n\tint error;\n\tstruct fsl_mc_device_irq *irq;\n\n\tirq = dpio_dev->irqs[0];\n\terror = devm_request_irq(&dpio_dev->dev,\n\t\t\t\t irq->virq,\n\t\t\t\t dpio_irq_handler,\n\t\t\t\t 0,\n\t\t\t\t dev_name(&dpio_dev->dev),\n\t\t\t\t &dpio_dev->dev);\n\tif (error < 0) {\n\t\tdev_err(&dpio_dev->dev,\n\t\t\t\"devm_request_irq() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (irq_set_affinity_hint(irq->virq, cpumask_of(cpu)))\n\t\tdev_err(&dpio_dev->dev,\n\t\t\t\"irq_set_affinity failed irq %d cpu %d\\n\",\n\t\t\tirq->virq, cpu);\n\n\treturn 0;\n}\n\nstatic int dpaa2_dpio_probe(struct fsl_mc_device *dpio_dev)\n{\n\tstruct dpio_attr dpio_attrs;\n\tstruct dpaa2_io_desc desc;\n\tstruct dpio_priv *priv;\n\tint err = -ENOMEM;\n\tstruct device *dev = &dpio_dev->dev;\n\tint possible_next_cpu;\n\tint sdest;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto err_priv_alloc;\n\n\tdev_set_drvdata(dev, priv);\n\n\terr = fsl_mc_portal_allocate(dpio_dev, 0, &dpio_dev->mc_io);\n\tif (err) {\n\t\tdev_dbg(dev, \"MC portal allocation failed\\n\");\n\t\terr = -EPROBE_DEFER;\n\t\tgoto err_priv_alloc;\n\t}\n\n\terr = dpio_open(dpio_dev->mc_io, 0, dpio_dev->obj_desc.id,\n\t\t\t&dpio_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpio_open() failed\\n\");\n\t\tgoto err_open;\n\t}\n\n\terr = dpio_reset(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpio_reset() failed\\n\");\n\t\tgoto err_reset;\n\t}\n\n\terr = dpio_get_attributes(dpio_dev->mc_io, 0, dpio_dev->mc_handle,\n\t\t\t\t  &dpio_attrs);\n\tif (err) {\n\t\tdev_err(dev, \"dpio_get_attributes() failed %d\\n\", err);\n\t\tgoto err_get_attr;\n\t}\n\tdesc.qman_version = dpio_attrs.qbman_version;\n\tdesc.qman_clk = dpio_attrs.clk;\n\n\terr = dpio_enable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpio_enable() failed %d\\n\", err);\n\t\tgoto err_get_attr;\n\t}\n\n\t \n\tdesc.receives_notifications = dpio_attrs.num_priorities ? 1 : 0;\n\tdesc.has_8prio = dpio_attrs.num_priorities == 8 ? 1 : 0;\n\tdesc.dpio_id = dpio_dev->obj_desc.id;\n\n\t \n\tpossible_next_cpu = cpumask_first(cpus_unused_mask);\n\tif (possible_next_cpu >= nr_cpu_ids) {\n\t\tdev_err(dev, \"probe failed. Number of DPIOs exceeds NR_CPUS.\\n\");\n\t\terr = -ERANGE;\n\t\tgoto err_allocate_irqs;\n\t}\n\tdesc.cpu = possible_next_cpu;\n\tcpumask_clear_cpu(possible_next_cpu, cpus_unused_mask);\n\n\tsdest = dpaa2_dpio_get_cluster_sdest(dpio_dev, desc.cpu);\n\tif (sdest >= 0) {\n\t\terr = dpio_set_stashing_destination(dpio_dev->mc_io, 0,\n\t\t\t\t\t\t    dpio_dev->mc_handle,\n\t\t\t\t\t\t    sdest);\n\t\tif (err)\n\t\t\tdev_err(dev, \"dpio_set_stashing_destination failed for cpu%d\\n\",\n\t\t\t\tdesc.cpu);\n\t}\n\n\tif (dpio_dev->obj_desc.region_count < 3) {\n\t\t \n\t\t \n\t\tdesc.regs_cena = devm_memremap(dev, dpio_dev->regions[1].start,\n\t\t\t\t\tresource_size(&dpio_dev->regions[1]),\n\t\t\t\t\tMEMREMAP_WC);\n\t} else {\n\t\tdesc.regs_cena = devm_memremap(dev, dpio_dev->regions[2].start,\n\t\t\t\t\tresource_size(&dpio_dev->regions[2]),\n\t\t\t\t\tMEMREMAP_WB);\n\t}\n\n\tif (IS_ERR(desc.regs_cena)) {\n\t\tdev_err(dev, \"devm_memremap failed\\n\");\n\t\terr = PTR_ERR(desc.regs_cena);\n\t\tgoto err_allocate_irqs;\n\t}\n\n\tdesc.regs_cinh = devm_ioremap(dev, dpio_dev->regions[1].start,\n\t\t\t\t      resource_size(&dpio_dev->regions[1]));\n\tif (!desc.regs_cinh) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dev, \"devm_ioremap failed\\n\");\n\t\tgoto err_allocate_irqs;\n\t}\n\n\terr = fsl_mc_allocate_irqs(dpio_dev);\n\tif (err) {\n\t\tdev_err(dev, \"fsl_mc_allocate_irqs failed. err=%d\\n\", err);\n\t\tgoto err_allocate_irqs;\n\t}\n\n\tpriv->io = dpaa2_io_create(&desc, dev);\n\tif (!priv->io) {\n\t\tdev_err(dev, \"dpaa2_io_create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_dpaa2_io_create;\n\t}\n\n\terr = register_dpio_irq_handlers(dpio_dev, desc.cpu);\n\tif (err)\n\t\tgoto err_register_dpio_irq;\n\n\tdev_info(dev, \"probed\\n\");\n\tdev_dbg(dev, \"   receives_notifications = %d\\n\",\n\t\tdesc.receives_notifications);\n\tdpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\n\n\treturn 0;\n\nerr_dpaa2_io_create:\n\tunregister_dpio_irq_handlers(dpio_dev);\nerr_register_dpio_irq:\n\tfsl_mc_free_irqs(dpio_dev);\nerr_allocate_irqs:\n\tdpio_disable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\nerr_get_attr:\nerr_reset:\n\tdpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\nerr_open:\n\tfsl_mc_portal_free(dpio_dev->mc_io);\nerr_priv_alloc:\n\treturn err;\n}\n\n \nstatic void dpio_teardown_irqs(struct fsl_mc_device *dpio_dev)\n{\n\tunregister_dpio_irq_handlers(dpio_dev);\n\tfsl_mc_free_irqs(dpio_dev);\n}\n\nstatic void dpaa2_dpio_remove(struct fsl_mc_device *dpio_dev)\n{\n\tstruct device *dev;\n\tstruct dpio_priv *priv;\n\tint err = 0, cpu;\n\n\tdev = &dpio_dev->dev;\n\tpriv = dev_get_drvdata(dev);\n\tcpu = dpaa2_io_get_cpu(priv->io);\n\n\tdpaa2_io_down(priv->io);\n\n\tdpio_teardown_irqs(dpio_dev);\n\n\tcpumask_set_cpu(cpu, cpus_unused_mask);\n\n\terr = dpio_open(dpio_dev->mc_io, 0, dpio_dev->obj_desc.id,\n\t\t\t&dpio_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpio_open() failed\\n\");\n\t\tgoto err_open;\n\t}\n\n\tdpio_disable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\n\n\tdpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\n\nerr_open:\n\tfsl_mc_portal_free(dpio_dev->mc_io);\n}\n\nstatic const struct fsl_mc_device_id dpaa2_dpio_match_id_table[] = {\n\t{\n\t\t.vendor = FSL_MC_VENDOR_FREESCALE,\n\t\t.obj_type = \"dpio\",\n\t},\n\t{ .vendor = 0x0 }\n};\n\nstatic struct fsl_mc_driver dpaa2_dpio_driver = {\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n\t.probe\t\t= dpaa2_dpio_probe,\n\t.remove\t\t= dpaa2_dpio_remove,\n\t.match_id_table = dpaa2_dpio_match_id_table\n};\n\nstatic int dpio_driver_init(void)\n{\n\tif (!zalloc_cpumask_var(&cpus_unused_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tcpumask_copy(cpus_unused_mask, cpu_online_mask);\n\n\treturn fsl_mc_driver_register(&dpaa2_dpio_driver);\n}\n\nstatic void dpio_driver_exit(void)\n{\n\tfree_cpumask_var(cpus_unused_mask);\n\tfsl_mc_driver_unregister(&dpaa2_dpio_driver);\n}\nmodule_init(dpio_driver_init);\nmodule_exit(dpio_driver_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}