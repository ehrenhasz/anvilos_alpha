{
  "module_name": "qbman-portal.c",
  "hash_id": "d6c283887ea9f6d64225d4442e502002304f14264a4a27f5980761653fb0ac53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/dpio/qbman-portal.c",
  "human_readable_source": "\n \n\n#include <asm/cacheflush.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <soc/fsl/dpaa2-global.h>\n\n#include \"qbman-portal.h\"\n\n \n#define QB_VALID_BIT ((u32)0x80)\n\n \n#define QBMAN_MC_ACQUIRE       0x30\n#define QBMAN_WQCHAN_CONFIGURE 0x46\n\n \n#define QBMAN_CINH_SWP_EQCR_PI      0x800\n#define QBMAN_CINH_SWP_EQCR_CI\t    0x840\n#define QBMAN_CINH_SWP_EQAR    0x8c0\n#define QBMAN_CINH_SWP_CR_RT        0x900\n#define QBMAN_CINH_SWP_VDQCR_RT     0x940\n#define QBMAN_CINH_SWP_EQCR_AM_RT   0x980\n#define QBMAN_CINH_SWP_RCR_AM_RT    0x9c0\n#define QBMAN_CINH_SWP_DQPI    0xa00\n#define QBMAN_CINH_SWP_DQRR_ITR     0xa80\n#define QBMAN_CINH_SWP_DCAP    0xac0\n#define QBMAN_CINH_SWP_SDQCR   0xb00\n#define QBMAN_CINH_SWP_EQCR_AM_RT2  0xb40\n#define QBMAN_CINH_SWP_RCR_PI       0xc00\n#define QBMAN_CINH_SWP_RAR     0xcc0\n#define QBMAN_CINH_SWP_ISR     0xe00\n#define QBMAN_CINH_SWP_IER     0xe40\n#define QBMAN_CINH_SWP_ISDR    0xe80\n#define QBMAN_CINH_SWP_IIR     0xec0\n#define QBMAN_CINH_SWP_ITPR    0xf40\n\n \n#define QBMAN_CENA_SWP_EQCR(n) (0x000 + ((u32)(n) << 6))\n#define QBMAN_CENA_SWP_DQRR(n) (0x200 + ((u32)(n) << 6))\n#define QBMAN_CENA_SWP_RCR(n)  (0x400 + ((u32)(n) << 6))\n#define QBMAN_CENA_SWP_CR      0x600\n#define QBMAN_CENA_SWP_RR(vb)  (0x700 + ((u32)(vb) >> 1))\n#define QBMAN_CENA_SWP_VDQCR   0x780\n#define QBMAN_CENA_SWP_EQCR_CI 0x840\n#define QBMAN_CENA_SWP_EQCR_CI_MEMBACK 0x1840\n\n \n#define QBMAN_CENA_SWP_DQRR_MEM(n)  (0x800 + ((u32)(n) << 6))\n#define QBMAN_CENA_SWP_RCR_MEM(n)   (0x1400 + ((u32)(n) << 6))\n#define QBMAN_CENA_SWP_CR_MEM       0x1600\n#define QBMAN_CENA_SWP_RR_MEM       0x1680\n#define QBMAN_CENA_SWP_VDQCR_MEM    0x1780\n\n \n#define QBMAN_IDX_FROM_DQRR(p) (((unsigned long)(p) & 0x1ff) >> 6)\n\n \n#define QMAN_DQ_TOKEN_VALID 1\n\n \n#define QB_SDQCR_FC_SHIFT   29\n#define QB_SDQCR_FC_MASK    0x1\n#define QB_SDQCR_DCT_SHIFT  24\n#define QB_SDQCR_DCT_MASK   0x3\n#define QB_SDQCR_TOK_SHIFT  16\n#define QB_SDQCR_TOK_MASK   0xff\n#define QB_SDQCR_SRC_SHIFT  0\n#define QB_SDQCR_SRC_MASK   0xffff\n\n \n#define QMAN_SDQCR_TOKEN    0xbb\n\n#define QBMAN_EQCR_DCA_IDXMASK          0x0f\n#define QBMAN_ENQUEUE_FLAG_DCA          (1ULL << 31)\n\n#define EQ_DESC_SIZE_WITHOUT_FD 29\n#define EQ_DESC_SIZE_FD_START 32\n\nenum qbman_sdqcr_dct {\n\tqbman_sdqcr_dct_null = 0,\n\tqbman_sdqcr_dct_prio_ics,\n\tqbman_sdqcr_dct_active_ics,\n\tqbman_sdqcr_dct_active\n};\n\nenum qbman_sdqcr_fc {\n\tqbman_sdqcr_fc_one = 0,\n\tqbman_sdqcr_fc_up_to_3 = 1\n};\n\n \nstatic int qbman_swp_enqueue_direct(struct qbman_swp *s,\n\t\t\t\t    const struct qbman_eq_desc *d,\n\t\t\t\t    const struct dpaa2_fd *fd);\nstatic int qbman_swp_enqueue_mem_back(struct qbman_swp *s,\n\t\t\t\t      const struct qbman_eq_desc *d,\n\t\t\t\t      const struct dpaa2_fd *fd);\nstatic int qbman_swp_enqueue_multiple_direct(struct qbman_swp *s,\n\t\t\t\t\t     const struct qbman_eq_desc *d,\n\t\t\t\t\t     const struct dpaa2_fd *fd,\n\t\t\t\t\t     uint32_t *flags,\n\t\t\t\t\t     int num_frames);\nstatic int qbman_swp_enqueue_multiple_mem_back(struct qbman_swp *s,\n\t\t\t\t\t       const struct qbman_eq_desc *d,\n\t\t\t\t\t       const struct dpaa2_fd *fd,\n\t\t\t\t\t       uint32_t *flags,\n\t\t\t\t\t       int num_frames);\nstatic int\nqbman_swp_enqueue_multiple_desc_direct(struct qbman_swp *s,\n\t\t\t\t       const struct qbman_eq_desc *d,\n\t\t\t\t       const struct dpaa2_fd *fd,\n\t\t\t\t       int num_frames);\nstatic\nint qbman_swp_enqueue_multiple_desc_mem_back(struct qbman_swp *s,\n\t\t\t\t\t     const struct qbman_eq_desc *d,\n\t\t\t\t\t     const struct dpaa2_fd *fd,\n\t\t\t\t\t     int num_frames);\nstatic int qbman_swp_pull_direct(struct qbman_swp *s,\n\t\t\t\t struct qbman_pull_desc *d);\nstatic int qbman_swp_pull_mem_back(struct qbman_swp *s,\n\t\t\t\t   struct qbman_pull_desc *d);\n\nconst struct dpaa2_dq *qbman_swp_dqrr_next_direct(struct qbman_swp *s);\nconst struct dpaa2_dq *qbman_swp_dqrr_next_mem_back(struct qbman_swp *s);\n\nstatic int qbman_swp_release_direct(struct qbman_swp *s,\n\t\t\t\t    const struct qbman_release_desc *d,\n\t\t\t\t    const u64 *buffers,\n\t\t\t\t    unsigned int num_buffers);\nstatic int qbman_swp_release_mem_back(struct qbman_swp *s,\n\t\t\t\t      const struct qbman_release_desc *d,\n\t\t\t\t      const u64 *buffers,\n\t\t\t\t      unsigned int num_buffers);\n\n \nint (*qbman_swp_enqueue_ptr)(struct qbman_swp *s,\n\t\t\t     const struct qbman_eq_desc *d,\n\t\t\t     const struct dpaa2_fd *fd)\n\t= qbman_swp_enqueue_direct;\n\nint (*qbman_swp_enqueue_multiple_ptr)(struct qbman_swp *s,\n\t\t\t\t      const struct qbman_eq_desc *d,\n\t\t\t\t      const struct dpaa2_fd *fd,\n\t\t\t\t      uint32_t *flags,\n\t\t\t\t\t     int num_frames)\n\t= qbman_swp_enqueue_multiple_direct;\n\nint\n(*qbman_swp_enqueue_multiple_desc_ptr)(struct qbman_swp *s,\n\t\t\t\t       const struct qbman_eq_desc *d,\n\t\t\t\t       const struct dpaa2_fd *fd,\n\t\t\t\t       int num_frames)\n\t= qbman_swp_enqueue_multiple_desc_direct;\n\nint (*qbman_swp_pull_ptr)(struct qbman_swp *s, struct qbman_pull_desc *d)\n\t\t\t= qbman_swp_pull_direct;\n\nconst struct dpaa2_dq *(*qbman_swp_dqrr_next_ptr)(struct qbman_swp *s)\n\t\t\t= qbman_swp_dqrr_next_direct;\n\nint (*qbman_swp_release_ptr)(struct qbman_swp *s,\n\t\t\t     const struct qbman_release_desc *d,\n\t\t\t     const u64 *buffers,\n\t\t\t     unsigned int num_buffers)\n\t\t\t= qbman_swp_release_direct;\n\n \n\nstatic inline u32 qbman_read_register(struct qbman_swp *p, u32 offset)\n{\n\treturn readl_relaxed(p->addr_cinh + offset);\n}\n\nstatic inline void qbman_write_register(struct qbman_swp *p, u32 offset,\n\t\t\t\t\tu32 value)\n{\n\twritel_relaxed(value, p->addr_cinh + offset);\n}\n\nstatic inline void *qbman_get_cmd(struct qbman_swp *p, u32 offset)\n{\n\treturn p->addr_cena + offset;\n}\n\n#define QBMAN_CINH_SWP_CFG   0xd00\n\n#define SWP_CFG_DQRR_MF_SHIFT 20\n#define SWP_CFG_EST_SHIFT     16\n#define SWP_CFG_CPBS_SHIFT    15\n#define SWP_CFG_WN_SHIFT      14\n#define SWP_CFG_RPM_SHIFT     12\n#define SWP_CFG_DCM_SHIFT     10\n#define SWP_CFG_EPM_SHIFT     8\n#define SWP_CFG_VPM_SHIFT     7\n#define SWP_CFG_CPM_SHIFT     6\n#define SWP_CFG_SD_SHIFT      5\n#define SWP_CFG_SP_SHIFT      4\n#define SWP_CFG_SE_SHIFT      3\n#define SWP_CFG_DP_SHIFT      2\n#define SWP_CFG_DE_SHIFT      1\n#define SWP_CFG_EP_SHIFT      0\n\nstatic inline u32 qbman_set_swp_cfg(u8 max_fill, u8 wn,\tu8 est, u8 rpm, u8 dcm,\n\t\t\t\t    u8 epm, int sd, int sp, int se,\n\t\t\t\t    int dp, int de, int ep)\n{\n\treturn (max_fill << SWP_CFG_DQRR_MF_SHIFT |\n\t\test << SWP_CFG_EST_SHIFT |\n\t\twn << SWP_CFG_WN_SHIFT |\n\t\trpm << SWP_CFG_RPM_SHIFT |\n\t\tdcm << SWP_CFG_DCM_SHIFT |\n\t\tepm << SWP_CFG_EPM_SHIFT |\n\t\tsd << SWP_CFG_SD_SHIFT |\n\t\tsp << SWP_CFG_SP_SHIFT |\n\t\tse << SWP_CFG_SE_SHIFT |\n\t\tdp << SWP_CFG_DP_SHIFT |\n\t\tde << SWP_CFG_DE_SHIFT |\n\t\tep << SWP_CFG_EP_SHIFT);\n}\n\n#define QMAN_RT_MODE\t   0x00000100\n\nstatic inline u8 qm_cyc_diff(u8 ringsize, u8 first, u8 last)\n{\n\t \n\tif (first <= last)\n\t\treturn last - first;\n\telse\n\t\treturn (2 * ringsize) - (first - last);\n}\n\n \nstruct qbman_swp *qbman_swp_init(const struct qbman_swp_desc *d)\n{\n\tstruct qbman_swp *p = kzalloc(sizeof(*p), GFP_KERNEL);\n\tu32 reg;\n\tu32 mask_size;\n\tu32 eqcr_pi;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock_init(&p->access_spinlock);\n\n\tp->desc = d;\n\tp->mc.valid_bit = QB_VALID_BIT;\n\tp->sdq = 0;\n\tp->sdq |= qbman_sdqcr_dct_prio_ics << QB_SDQCR_DCT_SHIFT;\n\tp->sdq |= qbman_sdqcr_fc_up_to_3 << QB_SDQCR_FC_SHIFT;\n\tp->sdq |= QMAN_SDQCR_TOKEN << QB_SDQCR_TOK_SHIFT;\n\tif ((p->desc->qman_version & QMAN_REV_MASK) >= QMAN_REV_5000)\n\t\tp->mr.valid_bit = QB_VALID_BIT;\n\n\tatomic_set(&p->vdq.available, 1);\n\tp->vdq.valid_bit = QB_VALID_BIT;\n\tp->dqrr.next_idx = 0;\n\tp->dqrr.valid_bit = QB_VALID_BIT;\n\n\tif ((p->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_4100) {\n\t\tp->dqrr.dqrr_size = 4;\n\t\tp->dqrr.reset_bug = 1;\n\t} else {\n\t\tp->dqrr.dqrr_size = 8;\n\t\tp->dqrr.reset_bug = 0;\n\t}\n\n\tp->addr_cena = d->cena_bar;\n\tp->addr_cinh = d->cinh_bar;\n\n\tif ((p->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000) {\n\n\t\treg = qbman_set_swp_cfg(p->dqrr.dqrr_size,\n\t\t\t1,  \n\t\t\t0,  \n\t\t\t3,  \n\t\t\t2,  \n\t\t\t2,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t0,  \n\t\t\t0);  \n\t} else {\n\t\tmemset(p->addr_cena, 0, 64 * 1024);\n\t\treg = qbman_set_swp_cfg(p->dqrr.dqrr_size,\n\t\t\t1,  \n\t\t\t1,  \n\t\t\t3,  \n\t\t\t2,  \n\t\t\t0,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t1,  \n\t\t\t0,  \n\t\t\t0);  \n\t\treg |= 1 << SWP_CFG_CPBS_SHIFT |  \n\t\t       1 << SWP_CFG_VPM_SHIFT |   \n\t\t       1 << SWP_CFG_CPM_SHIFT;    \n\t}\n\n\tqbman_write_register(p, QBMAN_CINH_SWP_CFG, reg);\n\treg = qbman_read_register(p, QBMAN_CINH_SWP_CFG);\n\tif (!reg) {\n\t\tpr_err(\"qbman: the portal is not enabled!\\n\");\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\tif ((p->desc->qman_version & QMAN_REV_MASK) >= QMAN_REV_5000) {\n\t\tqbman_write_register(p, QBMAN_CINH_SWP_EQCR_PI, QMAN_RT_MODE);\n\t\tqbman_write_register(p, QBMAN_CINH_SWP_RCR_PI, QMAN_RT_MODE);\n\t}\n\t \n\tqbman_write_register(p, QBMAN_CINH_SWP_SDQCR, 0);\n\n\tp->eqcr.pi_ring_size = 8;\n\tif ((p->desc->qman_version & QMAN_REV_MASK) >= QMAN_REV_5000) {\n\t\tp->eqcr.pi_ring_size = 32;\n\t\tqbman_swp_enqueue_ptr =\n\t\t\tqbman_swp_enqueue_mem_back;\n\t\tqbman_swp_enqueue_multiple_ptr =\n\t\t\tqbman_swp_enqueue_multiple_mem_back;\n\t\tqbman_swp_enqueue_multiple_desc_ptr =\n\t\t\tqbman_swp_enqueue_multiple_desc_mem_back;\n\t\tqbman_swp_pull_ptr = qbman_swp_pull_mem_back;\n\t\tqbman_swp_dqrr_next_ptr = qbman_swp_dqrr_next_mem_back;\n\t\tqbman_swp_release_ptr = qbman_swp_release_mem_back;\n\t}\n\n\tfor (mask_size = p->eqcr.pi_ring_size; mask_size > 0; mask_size >>= 1)\n\t\tp->eqcr.pi_ci_mask = (p->eqcr.pi_ci_mask << 1) + 1;\n\teqcr_pi = qbman_read_register(p, QBMAN_CINH_SWP_EQCR_PI);\n\tp->eqcr.pi = eqcr_pi & p->eqcr.pi_ci_mask;\n\tp->eqcr.pi_vb = eqcr_pi & QB_VALID_BIT;\n\tp->eqcr.ci = qbman_read_register(p, QBMAN_CINH_SWP_EQCR_CI)\n\t\t\t& p->eqcr.pi_ci_mask;\n\tp->eqcr.available = p->eqcr.pi_ring_size;\n\n\t \n\tqbman_swp_set_irq_coalescing(p, p->dqrr.dqrr_size - 1, 0);\n\n\treturn p;\n}\n\n \nvoid qbman_swp_finish(struct qbman_swp *p)\n{\n\tkfree(p);\n}\n\n \nu32 qbman_swp_interrupt_read_status(struct qbman_swp *p)\n{\n\treturn qbman_read_register(p, QBMAN_CINH_SWP_ISR);\n}\n\n \nvoid qbman_swp_interrupt_clear_status(struct qbman_swp *p, u32 mask)\n{\n\tqbman_write_register(p, QBMAN_CINH_SWP_ISR, mask);\n}\n\n \nu32 qbman_swp_interrupt_get_trigger(struct qbman_swp *p)\n{\n\treturn qbman_read_register(p, QBMAN_CINH_SWP_IER);\n}\n\n \nvoid qbman_swp_interrupt_set_trigger(struct qbman_swp *p, u32 mask)\n{\n\tqbman_write_register(p, QBMAN_CINH_SWP_IER, mask);\n}\n\n \nint qbman_swp_interrupt_get_inhibit(struct qbman_swp *p)\n{\n\treturn qbman_read_register(p, QBMAN_CINH_SWP_IIR);\n}\n\n \nvoid qbman_swp_interrupt_set_inhibit(struct qbman_swp *p, int inhibit)\n{\n\tqbman_write_register(p, QBMAN_CINH_SWP_IIR, inhibit ? 0xffffffff : 0);\n}\n\n \n\n \nvoid *qbman_swp_mc_start(struct qbman_swp *p)\n{\n\tif ((p->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000)\n\t\treturn qbman_get_cmd(p, QBMAN_CENA_SWP_CR);\n\telse\n\t\treturn qbman_get_cmd(p, QBMAN_CENA_SWP_CR_MEM);\n}\n\n \nvoid qbman_swp_mc_submit(struct qbman_swp *p, void *cmd, u8 cmd_verb)\n{\n\tu8 *v = cmd;\n\n\tif ((p->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000) {\n\t\tdma_wmb();\n\t\t*v = cmd_verb | p->mc.valid_bit;\n\t} else {\n\t\t*v = cmd_verb | p->mc.valid_bit;\n\t\tdma_wmb();\n\t\tqbman_write_register(p, QBMAN_CINH_SWP_CR_RT, QMAN_RT_MODE);\n\t}\n}\n\n \nvoid *qbman_swp_mc_result(struct qbman_swp *p)\n{\n\tu32 *ret, verb;\n\n\tif ((p->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000) {\n\t\tret = qbman_get_cmd(p, QBMAN_CENA_SWP_RR(p->mc.valid_bit));\n\t\t \n\t\tverb = ret[0] & ~QB_VALID_BIT;\n\t\tif (!verb)\n\t\t\treturn NULL;\n\t\tp->mc.valid_bit ^= QB_VALID_BIT;\n\t} else {\n\t\tret = qbman_get_cmd(p, QBMAN_CENA_SWP_RR_MEM);\n\t\t \n\t\tif (p->mr.valid_bit != (ret[0] & QB_VALID_BIT))\n\t\t\treturn NULL;\n\t\t \n\t\tverb = ret[0] & ~QB_VALID_BIT;\n\t\tif (!verb)\n\t\t\treturn NULL;\n\t\tp->mr.valid_bit ^= QB_VALID_BIT;\n\t}\n\n\treturn ret;\n}\n\n#define QB_ENQUEUE_CMD_OPTIONS_SHIFT    0\nenum qb_enqueue_commands {\n\tenqueue_empty = 0,\n\tenqueue_response_always = 1,\n\tenqueue_rejects_to_fq = 2\n};\n\n#define QB_ENQUEUE_CMD_ORP_ENABLE_SHIFT      2\n#define QB_ENQUEUE_CMD_IRQ_ON_DISPATCH_SHIFT 3\n#define QB_ENQUEUE_CMD_TARGET_TYPE_SHIFT     4\n#define QB_ENQUEUE_CMD_DCA_EN_SHIFT          7\n\n \nvoid qbman_eq_desc_clear(struct qbman_eq_desc *d)\n{\n\tmemset(d, 0, sizeof(*d));\n}\n\n \nvoid qbman_eq_desc_set_no_orp(struct qbman_eq_desc *d, int respond_success)\n{\n\td->verb &= ~(1 << QB_ENQUEUE_CMD_ORP_ENABLE_SHIFT);\n\tif (respond_success)\n\t\td->verb |= enqueue_response_always;\n\telse\n\t\td->verb |= enqueue_rejects_to_fq;\n}\n\n \n\n \nvoid qbman_eq_desc_set_fq(struct qbman_eq_desc *d, u32 fqid)\n{\n\td->verb &= ~(1 << QB_ENQUEUE_CMD_TARGET_TYPE_SHIFT);\n\td->tgtid = cpu_to_le32(fqid);\n}\n\n \nvoid qbman_eq_desc_set_qd(struct qbman_eq_desc *d, u32 qdid,\n\t\t\t  u32 qd_bin, u32 qd_prio)\n{\n\td->verb |= 1 << QB_ENQUEUE_CMD_TARGET_TYPE_SHIFT;\n\td->tgtid = cpu_to_le32(qdid);\n\td->qdbin = cpu_to_le16(qd_bin);\n\td->qpri = qd_prio;\n}\n\n#define EQAR_IDX(eqar)     ((eqar) & 0x7)\n#define EQAR_VB(eqar)      ((eqar) & 0x80)\n#define EQAR_SUCCESS(eqar) ((eqar) & 0x100)\n\n#define QB_RT_BIT ((u32)0x100)\n \nstatic\nint qbman_swp_enqueue_direct(struct qbman_swp *s,\n\t\t\t     const struct qbman_eq_desc *d,\n\t\t\t     const struct dpaa2_fd *fd)\n{\n\tint flags = 0;\n\tint ret = qbman_swp_enqueue_multiple_direct(s, d, fd, &flags, 1);\n\n\tif (ret >= 0)\n\t\tret = 0;\n\telse\n\t\tret = -EBUSY;\n\treturn  ret;\n}\n\n \nstatic\nint qbman_swp_enqueue_mem_back(struct qbman_swp *s,\n\t\t\t       const struct qbman_eq_desc *d,\n\t\t\t       const struct dpaa2_fd *fd)\n{\n\tint flags = 0;\n\tint ret = qbman_swp_enqueue_multiple_mem_back(s, d, fd, &flags, 1);\n\n\tif (ret >= 0)\n\t\tret = 0;\n\telse\n\t\tret = -EBUSY;\n\treturn  ret;\n}\n\n \nstatic\nint qbman_swp_enqueue_multiple_direct(struct qbman_swp *s,\n\t\t\t\t      const struct qbman_eq_desc *d,\n\t\t\t\t      const struct dpaa2_fd *fd,\n\t\t\t\t      uint32_t *flags,\n\t\t\t\t      int num_frames)\n{\n\tuint32_t *p = NULL;\n\tconst uint32_t *cl = (uint32_t *)d;\n\tuint32_t eqcr_ci, eqcr_pi, half_mask, full_mask;\n\tint i, num_enqueued = 0;\n\n\tspin_lock(&s->access_spinlock);\n\thalf_mask = (s->eqcr.pi_ci_mask>>1);\n\tfull_mask = s->eqcr.pi_ci_mask;\n\n\tif (!s->eqcr.available) {\n\t\teqcr_ci = s->eqcr.ci;\n\t\tp = s->addr_cena + QBMAN_CENA_SWP_EQCR_CI;\n\t\ts->eqcr.ci = qbman_read_register(s, QBMAN_CINH_SWP_EQCR_CI);\n\t\ts->eqcr.ci &= full_mask;\n\n\t\ts->eqcr.available = qm_cyc_diff(s->eqcr.pi_ring_size,\n\t\t\t\t\teqcr_ci, s->eqcr.ci);\n\t\tif (!s->eqcr.available) {\n\t\t\tspin_unlock(&s->access_spinlock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\teqcr_pi = s->eqcr.pi;\n\tnum_enqueued = (s->eqcr.available < num_frames) ?\n\t\t\ts->eqcr.available : num_frames;\n\ts->eqcr.available -= num_enqueued;\n\t \n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\t \n\t\tmemcpy(&p[1], &cl[1], EQ_DESC_SIZE_WITHOUT_FD - 1);\n\t\tmemcpy(&p[EQ_DESC_SIZE_FD_START/sizeof(uint32_t)],\n\t\t       &fd[i], sizeof(*fd));\n\t\teqcr_pi++;\n\t}\n\n\tdma_wmb();\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tp[0] = cl[0] | s->eqcr.pi_vb;\n\t\tif (flags && (flags[i] & QBMAN_ENQUEUE_FLAG_DCA)) {\n\t\t\tstruct qbman_eq_desc *eq_desc = (struct qbman_eq_desc *)p;\n\n\t\t\teq_desc->dca = (1 << QB_ENQUEUE_CMD_DCA_EN_SHIFT) |\n\t\t\t\t((flags[i]) & QBMAN_EQCR_DCA_IDXMASK);\n\t\t}\n\t\teqcr_pi++;\n\t\tif (!(eqcr_pi & half_mask))\n\t\t\ts->eqcr.pi_vb ^= QB_VALID_BIT;\n\t}\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++)\n\t\teqcr_pi++;\n\ts->eqcr.pi = eqcr_pi & full_mask;\n\tspin_unlock(&s->access_spinlock);\n\n\treturn num_enqueued;\n}\n\n \nstatic\nint qbman_swp_enqueue_multiple_mem_back(struct qbman_swp *s,\n\t\t\t\t\tconst struct qbman_eq_desc *d,\n\t\t\t\t\tconst struct dpaa2_fd *fd,\n\t\t\t\t\tuint32_t *flags,\n\t\t\t\t\tint num_frames)\n{\n\tuint32_t *p = NULL;\n\tconst uint32_t *cl = (uint32_t *)(d);\n\tuint32_t eqcr_ci, eqcr_pi, half_mask, full_mask;\n\tint i, num_enqueued = 0;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&s->access_spinlock, irq_flags);\n\n\thalf_mask = (s->eqcr.pi_ci_mask>>1);\n\tfull_mask = s->eqcr.pi_ci_mask;\n\tif (!s->eqcr.available) {\n\t\teqcr_ci = s->eqcr.ci;\n\t\ts->eqcr.ci = qbman_read_register(s, QBMAN_CINH_SWP_EQCR_CI);\n\t\ts->eqcr.ci &= full_mask;\n\t\ts->eqcr.available = qm_cyc_diff(s->eqcr.pi_ring_size,\n\t\t\t\t\teqcr_ci, s->eqcr.ci);\n\t\tif (!s->eqcr.available) {\n\t\t\tspin_unlock_irqrestore(&s->access_spinlock, irq_flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\teqcr_pi = s->eqcr.pi;\n\tnum_enqueued = (s->eqcr.available < num_frames) ?\n\t\t\ts->eqcr.available : num_frames;\n\ts->eqcr.available -= num_enqueued;\n\t \n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\t \n\t\tmemcpy(&p[1], &cl[1], EQ_DESC_SIZE_WITHOUT_FD - 1);\n\t\tmemcpy(&p[EQ_DESC_SIZE_FD_START/sizeof(uint32_t)],\n\t\t       &fd[i], sizeof(*fd));\n\t\teqcr_pi++;\n\t}\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tp[0] = cl[0] | s->eqcr.pi_vb;\n\t\tif (flags && (flags[i] & QBMAN_ENQUEUE_FLAG_DCA)) {\n\t\t\tstruct qbman_eq_desc *eq_desc = (struct qbman_eq_desc *)p;\n\n\t\t\teq_desc->dca = (1 << QB_ENQUEUE_CMD_DCA_EN_SHIFT) |\n\t\t\t\t((flags[i]) & QBMAN_EQCR_DCA_IDXMASK);\n\t\t}\n\t\teqcr_pi++;\n\t\tif (!(eqcr_pi & half_mask))\n\t\t\ts->eqcr.pi_vb ^= QB_VALID_BIT;\n\t}\n\ts->eqcr.pi = eqcr_pi & full_mask;\n\n\tdma_wmb();\n\tqbman_write_register(s, QBMAN_CINH_SWP_EQCR_PI,\n\t\t\t\t(QB_RT_BIT)|(s->eqcr.pi)|s->eqcr.pi_vb);\n\tspin_unlock_irqrestore(&s->access_spinlock, irq_flags);\n\n\treturn num_enqueued;\n}\n\n \nstatic\nint qbman_swp_enqueue_multiple_desc_direct(struct qbman_swp *s,\n\t\t\t\t\t   const struct qbman_eq_desc *d,\n\t\t\t\t\t   const struct dpaa2_fd *fd,\n\t\t\t\t\t   int num_frames)\n{\n\tuint32_t *p;\n\tconst uint32_t *cl;\n\tuint32_t eqcr_ci, eqcr_pi, half_mask, full_mask;\n\tint i, num_enqueued = 0;\n\n\thalf_mask = (s->eqcr.pi_ci_mask>>1);\n\tfull_mask = s->eqcr.pi_ci_mask;\n\tif (!s->eqcr.available) {\n\t\teqcr_ci = s->eqcr.ci;\n\t\tp = s->addr_cena + QBMAN_CENA_SWP_EQCR_CI;\n\t\ts->eqcr.ci = qbman_read_register(s, QBMAN_CINH_SWP_EQCR_CI);\n\t\ts->eqcr.available = qm_cyc_diff(s->eqcr.pi_ring_size,\n\t\t\t\t\teqcr_ci, s->eqcr.ci);\n\t\tif (!s->eqcr.available)\n\t\t\treturn 0;\n\t}\n\n\teqcr_pi = s->eqcr.pi;\n\tnum_enqueued = (s->eqcr.available < num_frames) ?\n\t\t\ts->eqcr.available : num_frames;\n\ts->eqcr.available -= num_enqueued;\n\t \n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tcl = (uint32_t *)(&d[i]);\n\t\t \n\t\tmemcpy(&p[1], &cl[1], EQ_DESC_SIZE_WITHOUT_FD - 1);\n\t\tmemcpy(&p[EQ_DESC_SIZE_FD_START/sizeof(uint32_t)],\n\t\t       &fd[i], sizeof(*fd));\n\t\teqcr_pi++;\n\t}\n\n\tdma_wmb();\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tcl = (uint32_t *)(&d[i]);\n\t\tp[0] = cl[0] | s->eqcr.pi_vb;\n\t\teqcr_pi++;\n\t\tif (!(eqcr_pi & half_mask))\n\t\t\ts->eqcr.pi_vb ^= QB_VALID_BIT;\n\t}\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++)\n\t\teqcr_pi++;\n\ts->eqcr.pi = eqcr_pi & full_mask;\n\n\treturn num_enqueued;\n}\n\n \nstatic\nint qbman_swp_enqueue_multiple_desc_mem_back(struct qbman_swp *s,\n\t\t\t\t\t   const struct qbman_eq_desc *d,\n\t\t\t\t\t   const struct dpaa2_fd *fd,\n\t\t\t\t\t   int num_frames)\n{\n\tuint32_t *p;\n\tconst uint32_t *cl;\n\tuint32_t eqcr_ci, eqcr_pi, half_mask, full_mask;\n\tint i, num_enqueued = 0;\n\n\thalf_mask = (s->eqcr.pi_ci_mask>>1);\n\tfull_mask = s->eqcr.pi_ci_mask;\n\tif (!s->eqcr.available) {\n\t\teqcr_ci = s->eqcr.ci;\n\t\ts->eqcr.ci = qbman_read_register(s, QBMAN_CINH_SWP_EQCR_CI);\n\t\ts->eqcr.ci &= full_mask;\n\t\ts->eqcr.available = qm_cyc_diff(s->eqcr.pi_ring_size,\n\t\t\t\t\teqcr_ci, s->eqcr.ci);\n\t\tif (!s->eqcr.available)\n\t\t\treturn 0;\n\t}\n\n\teqcr_pi = s->eqcr.pi;\n\tnum_enqueued = (s->eqcr.available < num_frames) ?\n\t\t\ts->eqcr.available : num_frames;\n\ts->eqcr.available -= num_enqueued;\n\t \n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tcl = (uint32_t *)(&d[i]);\n\t\t \n\t\tmemcpy(&p[1], &cl[1], EQ_DESC_SIZE_WITHOUT_FD - 1);\n\t\tmemcpy(&p[EQ_DESC_SIZE_FD_START/sizeof(uint32_t)],\n\t\t       &fd[i], sizeof(*fd));\n\t\teqcr_pi++;\n\t}\n\n\t \n\teqcr_pi = s->eqcr.pi;\n\tfor (i = 0; i < num_enqueued; i++) {\n\t\tp = (s->addr_cena + QBMAN_CENA_SWP_EQCR(eqcr_pi & half_mask));\n\t\tcl = (uint32_t *)(&d[i]);\n\t\tp[0] = cl[0] | s->eqcr.pi_vb;\n\t\teqcr_pi++;\n\t\tif (!(eqcr_pi & half_mask))\n\t\t\ts->eqcr.pi_vb ^= QB_VALID_BIT;\n\t}\n\n\ts->eqcr.pi = eqcr_pi & full_mask;\n\n\tdma_wmb();\n\tqbman_write_register(s, QBMAN_CINH_SWP_EQCR_PI,\n\t\t\t\t(QB_RT_BIT)|(s->eqcr.pi)|s->eqcr.pi_vb);\n\n\treturn num_enqueued;\n}\n\n \n\n \nvoid qbman_swp_push_get(struct qbman_swp *s, u8 channel_idx, int *enabled)\n{\n\tu16 src = (s->sdq >> QB_SDQCR_SRC_SHIFT) & QB_SDQCR_SRC_MASK;\n\n\tWARN_ON(channel_idx > 15);\n\t*enabled = src | (1 << channel_idx);\n}\n\n \nvoid qbman_swp_push_set(struct qbman_swp *s, u8 channel_idx, int enable)\n{\n\tu16 dqsrc;\n\n\tWARN_ON(channel_idx > 15);\n\tif (enable)\n\t\ts->sdq |= 1 << channel_idx;\n\telse\n\t\ts->sdq &= ~(1 << channel_idx);\n\n\t \n\tdqsrc = (s->sdq >> QB_SDQCR_SRC_SHIFT) & QB_SDQCR_SRC_MASK;\n\tif (dqsrc != 0)\n\t\tqbman_write_register(s, QBMAN_CINH_SWP_SDQCR, s->sdq);\n\telse\n\t\tqbman_write_register(s, QBMAN_CINH_SWP_SDQCR, 0);\n}\n\n#define QB_VDQCR_VERB_DCT_SHIFT    0\n#define QB_VDQCR_VERB_DT_SHIFT     2\n#define QB_VDQCR_VERB_RLS_SHIFT    4\n#define QB_VDQCR_VERB_WAE_SHIFT    5\n\nenum qb_pull_dt_e {\n\tqb_pull_dt_channel,\n\tqb_pull_dt_workqueue,\n\tqb_pull_dt_framequeue\n};\n\n \nvoid qbman_pull_desc_clear(struct qbman_pull_desc *d)\n{\n\tmemset(d, 0, sizeof(*d));\n}\n\n \nvoid qbman_pull_desc_set_storage(struct qbman_pull_desc *d,\n\t\t\t\t struct dpaa2_dq *storage,\n\t\t\t\t dma_addr_t storage_phys,\n\t\t\t\t int stash)\n{\n\t \n\td->rsp_addr_virt = (u64)(uintptr_t)storage;\n\n\tif (!storage) {\n\t\td->verb &= ~(1 << QB_VDQCR_VERB_RLS_SHIFT);\n\t\treturn;\n\t}\n\td->verb |= 1 << QB_VDQCR_VERB_RLS_SHIFT;\n\tif (stash)\n\t\td->verb |= 1 << QB_VDQCR_VERB_WAE_SHIFT;\n\telse\n\t\td->verb &= ~(1 << QB_VDQCR_VERB_WAE_SHIFT);\n\n\td->rsp_addr = cpu_to_le64(storage_phys);\n}\n\n \nvoid qbman_pull_desc_set_numframes(struct qbman_pull_desc *d, u8 numframes)\n{\n\td->numf = numframes - 1;\n}\n\n \n\n \nvoid qbman_pull_desc_set_fq(struct qbman_pull_desc *d, u32 fqid)\n{\n\td->verb |= 1 << QB_VDQCR_VERB_DCT_SHIFT;\n\td->verb |= qb_pull_dt_framequeue << QB_VDQCR_VERB_DT_SHIFT;\n\td->dq_src = cpu_to_le32(fqid);\n}\n\n \nvoid qbman_pull_desc_set_wq(struct qbman_pull_desc *d, u32 wqid,\n\t\t\t    enum qbman_pull_type_e dct)\n{\n\td->verb |= dct << QB_VDQCR_VERB_DCT_SHIFT;\n\td->verb |= qb_pull_dt_workqueue << QB_VDQCR_VERB_DT_SHIFT;\n\td->dq_src = cpu_to_le32(wqid);\n}\n\n \nvoid qbman_pull_desc_set_channel(struct qbman_pull_desc *d, u32 chid,\n\t\t\t\t enum qbman_pull_type_e dct)\n{\n\td->verb |= dct << QB_VDQCR_VERB_DCT_SHIFT;\n\td->verb |= qb_pull_dt_channel << QB_VDQCR_VERB_DT_SHIFT;\n\td->dq_src = cpu_to_le32(chid);\n}\n\n \nstatic\nint qbman_swp_pull_direct(struct qbman_swp *s, struct qbman_pull_desc *d)\n{\n\tstruct qbman_pull_desc *p;\n\n\tif (!atomic_dec_and_test(&s->vdq.available)) {\n\t\tatomic_inc(&s->vdq.available);\n\t\treturn -EBUSY;\n\t}\n\ts->vdq.storage = (void *)(uintptr_t)d->rsp_addr_virt;\n\tif ((s->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000)\n\t\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_VDQCR);\n\telse\n\t\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_VDQCR_MEM);\n\tp->numf = d->numf;\n\tp->tok = QMAN_DQ_TOKEN_VALID;\n\tp->dq_src = d->dq_src;\n\tp->rsp_addr = d->rsp_addr;\n\tp->rsp_addr_virt = d->rsp_addr_virt;\n\tdma_wmb();\n\t \n\tp->verb = d->verb | s->vdq.valid_bit;\n\ts->vdq.valid_bit ^= QB_VALID_BIT;\n\n\treturn 0;\n}\n\n \nstatic\nint qbman_swp_pull_mem_back(struct qbman_swp *s, struct qbman_pull_desc *d)\n{\n\tstruct qbman_pull_desc *p;\n\n\tif (!atomic_dec_and_test(&s->vdq.available)) {\n\t\tatomic_inc(&s->vdq.available);\n\t\treturn -EBUSY;\n\t}\n\ts->vdq.storage = (void *)(uintptr_t)d->rsp_addr_virt;\n\tif ((s->desc->qman_version & QMAN_REV_MASK) < QMAN_REV_5000)\n\t\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_VDQCR);\n\telse\n\t\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_VDQCR_MEM);\n\tp->numf = d->numf;\n\tp->tok = QMAN_DQ_TOKEN_VALID;\n\tp->dq_src = d->dq_src;\n\tp->rsp_addr = d->rsp_addr;\n\tp->rsp_addr_virt = d->rsp_addr_virt;\n\n\t \n\tp->verb = d->verb | s->vdq.valid_bit;\n\ts->vdq.valid_bit ^= QB_VALID_BIT;\n\tdma_wmb();\n\tqbman_write_register(s, QBMAN_CINH_SWP_VDQCR_RT, QMAN_RT_MODE);\n\n\treturn 0;\n}\n\n#define QMAN_DQRR_PI_MASK   0xf\n\n \nconst struct dpaa2_dq *qbman_swp_dqrr_next_direct(struct qbman_swp *s)\n{\n\tu32 verb;\n\tu32 response_verb;\n\tu32 flags;\n\tstruct dpaa2_dq *p;\n\n\t \n\tif (unlikely(s->dqrr.reset_bug)) {\n\t\t \n\t\tu8 pi = qbman_read_register(s, QBMAN_CINH_SWP_DQPI) &\n\t\t\tQMAN_DQRR_PI_MASK;\n\n\t\t \n\t\tif (pi == s->dqrr.next_idx)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (s->dqrr.next_idx == (s->dqrr.dqrr_size - 1)) {\n\t\t\tpr_debug(\"next_idx=%d, pi=%d, clear reset bug\\n\",\n\t\t\t\t s->dqrr.next_idx, pi);\n\t\t\ts->dqrr.reset_bug = 0;\n\t\t}\n\t\tprefetch(qbman_get_cmd(s,\n\t\t\t\t       QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\t}\n\n\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx));\n\tverb = p->dq.verb;\n\n\t \n\tif ((verb & QB_VALID_BIT) != s->dqrr.valid_bit) {\n\t\tprefetch(qbman_get_cmd(s,\n\t\t\t\t       QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\t\treturn NULL;\n\t}\n\t \n\ts->dqrr.next_idx++;\n\ts->dqrr.next_idx &= s->dqrr.dqrr_size - 1;  \n\tif (!s->dqrr.next_idx)\n\t\ts->dqrr.valid_bit ^= QB_VALID_BIT;\n\n\t \n\tflags = p->dq.stat;\n\tresponse_verb = verb & QBMAN_RESULT_MASK;\n\tif ((response_verb == QBMAN_RESULT_DQ) &&\n\t    (flags & DPAA2_DQ_STAT_VOLATILE) &&\n\t    (flags & DPAA2_DQ_STAT_EXPIRED))\n\t\tatomic_inc(&s->vdq.available);\n\n\tprefetch(qbman_get_cmd(s, QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\n\treturn p;\n}\n\n \nconst struct dpaa2_dq *qbman_swp_dqrr_next_mem_back(struct qbman_swp *s)\n{\n\tu32 verb;\n\tu32 response_verb;\n\tu32 flags;\n\tstruct dpaa2_dq *p;\n\n\t \n\tif (unlikely(s->dqrr.reset_bug)) {\n\t\t \n\t\tu8 pi = qbman_read_register(s, QBMAN_CINH_SWP_DQPI) &\n\t\t\tQMAN_DQRR_PI_MASK;\n\n\t\t \n\t\tif (pi == s->dqrr.next_idx)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (s->dqrr.next_idx == (s->dqrr.dqrr_size - 1)) {\n\t\t\tpr_debug(\"next_idx=%d, pi=%d, clear reset bug\\n\",\n\t\t\t\t s->dqrr.next_idx, pi);\n\t\t\ts->dqrr.reset_bug = 0;\n\t\t}\n\t\tprefetch(qbman_get_cmd(s,\n\t\t\t\t       QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\t}\n\n\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_DQRR_MEM(s->dqrr.next_idx));\n\tverb = p->dq.verb;\n\n\t \n\tif ((verb & QB_VALID_BIT) != s->dqrr.valid_bit) {\n\t\tprefetch(qbman_get_cmd(s,\n\t\t\t\t       QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\t\treturn NULL;\n\t}\n\t \n\ts->dqrr.next_idx++;\n\ts->dqrr.next_idx &= s->dqrr.dqrr_size - 1;  \n\tif (!s->dqrr.next_idx)\n\t\ts->dqrr.valid_bit ^= QB_VALID_BIT;\n\n\t \n\tflags = p->dq.stat;\n\tresponse_verb = verb & QBMAN_RESULT_MASK;\n\tif ((response_verb == QBMAN_RESULT_DQ) &&\n\t    (flags & DPAA2_DQ_STAT_VOLATILE) &&\n\t    (flags & DPAA2_DQ_STAT_EXPIRED))\n\t\tatomic_inc(&s->vdq.available);\n\n\tprefetch(qbman_get_cmd(s, QBMAN_CENA_SWP_DQRR(s->dqrr.next_idx)));\n\n\treturn p;\n}\n\n \nvoid qbman_swp_dqrr_consume(struct qbman_swp *s, const struct dpaa2_dq *dq)\n{\n\tqbman_write_register(s, QBMAN_CINH_SWP_DCAP, QBMAN_IDX_FROM_DQRR(dq));\n}\n\n \nint qbman_result_has_new_result(struct qbman_swp *s, const struct dpaa2_dq *dq)\n{\n\tif (dq->dq.tok != QMAN_DQ_TOKEN_VALID)\n\t\treturn 0;\n\n\t \n\t((struct dpaa2_dq *)dq)->dq.tok = 0;\n\n\t \n\tif (s->vdq.storage == dq) {\n\t\ts->vdq.storage = NULL;\n\t\tatomic_inc(&s->vdq.available);\n\t}\n\n\treturn 1;\n}\n\n \nvoid qbman_release_desc_clear(struct qbman_release_desc *d)\n{\n\tmemset(d, 0, sizeof(*d));\n\td->verb = 1 << 5;  \n}\n\n \nvoid qbman_release_desc_set_bpid(struct qbman_release_desc *d, u16 bpid)\n{\n\td->bpid = cpu_to_le16(bpid);\n}\n\n \nvoid qbman_release_desc_set_rcdi(struct qbman_release_desc *d, int enable)\n{\n\tif (enable)\n\t\td->verb |= 1 << 6;\n\telse\n\t\td->verb &= ~(1 << 6);\n}\n\n#define RAR_IDX(rar)     ((rar) & 0x7)\n#define RAR_VB(rar)      ((rar) & 0x80)\n#define RAR_SUCCESS(rar) ((rar) & 0x100)\n\n \nint qbman_swp_release_direct(struct qbman_swp *s,\n\t\t\t     const struct qbman_release_desc *d,\n\t\t\t     const u64 *buffers, unsigned int num_buffers)\n{\n\tint i;\n\tstruct qbman_release_desc *p;\n\tu32 rar;\n\n\tif (!num_buffers || (num_buffers > 7))\n\t\treturn -EINVAL;\n\n\trar = qbman_read_register(s, QBMAN_CINH_SWP_RAR);\n\tif (!RAR_SUCCESS(rar))\n\t\treturn -EBUSY;\n\n\t \n\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_RCR(RAR_IDX(rar)));\n\n\t \n\tfor (i = 0; i < num_buffers; i++)\n\t\tp->buf[i] = cpu_to_le64(buffers[i]);\n\tp->bpid = d->bpid;\n\n\t \n\tdma_wmb();\n\tp->verb = d->verb | RAR_VB(rar) | num_buffers;\n\n\treturn 0;\n}\n\n \nint qbman_swp_release_mem_back(struct qbman_swp *s,\n\t\t\t       const struct qbman_release_desc *d,\n\t\t\t       const u64 *buffers, unsigned int num_buffers)\n{\n\tint i;\n\tstruct qbman_release_desc *p;\n\tu32 rar;\n\n\tif (!num_buffers || (num_buffers > 7))\n\t\treturn -EINVAL;\n\n\trar = qbman_read_register(s, QBMAN_CINH_SWP_RAR);\n\tif (!RAR_SUCCESS(rar))\n\t\treturn -EBUSY;\n\n\t \n\tp = qbman_get_cmd(s, QBMAN_CENA_SWP_RCR_MEM(RAR_IDX(rar)));\n\n\t \n\tfor (i = 0; i < num_buffers; i++)\n\t\tp->buf[i] = cpu_to_le64(buffers[i]);\n\tp->bpid = d->bpid;\n\n\tp->verb = d->verb | RAR_VB(rar) | num_buffers;\n\tdma_wmb();\n\tqbman_write_register(s, QBMAN_CINH_SWP_RCR_AM_RT +\n\t\t\t     RAR_IDX(rar)  * 4, QMAN_RT_MODE);\n\n\treturn 0;\n}\n\nstruct qbman_acquire_desc {\n\tu8 verb;\n\tu8 reserved;\n\t__le16 bpid;\n\tu8 num;\n\tu8 reserved2[59];\n};\n\nstruct qbman_acquire_rslt {\n\tu8 verb;\n\tu8 rslt;\n\t__le16 reserved;\n\tu8 num;\n\tu8 reserved2[3];\n\t__le64 buf[7];\n};\n\n \nint qbman_swp_acquire(struct qbman_swp *s, u16 bpid, u64 *buffers,\n\t\t      unsigned int num_buffers)\n{\n\tstruct qbman_acquire_desc *p;\n\tstruct qbman_acquire_rslt *r;\n\tint i;\n\n\tif (!num_buffers || (num_buffers > 7))\n\t\treturn -EINVAL;\n\n\t \n\tp = qbman_swp_mc_start(s);\n\n\tif (!p)\n\t\treturn -EBUSY;\n\n\t \n\tp->bpid = cpu_to_le16(bpid);\n\tp->num = num_buffers;\n\n\t \n\tr = qbman_swp_mc_complete(s, p, QBMAN_MC_ACQUIRE);\n\tif (unlikely(!r)) {\n\t\tpr_err(\"qbman: acquire from BPID %d failed, no response\\n\",\n\t\t       bpid);\n\t\treturn -EIO;\n\t}\n\n\t \n\tWARN_ON((r->verb & 0x7f) != QBMAN_MC_ACQUIRE);\n\n\t \n\tif (unlikely(r->rslt != QBMAN_MC_RSLT_OK)) {\n\t\tpr_err(\"qbman: acquire from BPID 0x%x failed, code=0x%02x\\n\",\n\t\t       bpid, r->rslt);\n\t\treturn -EIO;\n\t}\n\n\tWARN_ON(r->num > num_buffers);\n\n\t \n\tfor (i = 0; i < r->num; i++)\n\t\tbuffers[i] = le64_to_cpu(r->buf[i]);\n\n\treturn (int)r->num;\n}\n\nstruct qbman_alt_fq_state_desc {\n\tu8 verb;\n\tu8 reserved[3];\n\t__le32 fqid;\n\tu8 reserved2[56];\n};\n\nstruct qbman_alt_fq_state_rslt {\n\tu8 verb;\n\tu8 rslt;\n\tu8 reserved[62];\n};\n\n#define ALT_FQ_FQID_MASK 0x00FFFFFF\n\nint qbman_swp_alt_fq_state(struct qbman_swp *s, u32 fqid,\n\t\t\t   u8 alt_fq_verb)\n{\n\tstruct qbman_alt_fq_state_desc *p;\n\tstruct qbman_alt_fq_state_rslt *r;\n\n\t \n\tp = qbman_swp_mc_start(s);\n\tif (!p)\n\t\treturn -EBUSY;\n\n\tp->fqid = cpu_to_le32(fqid & ALT_FQ_FQID_MASK);\n\n\t \n\tr = qbman_swp_mc_complete(s, p, alt_fq_verb);\n\tif (unlikely(!r)) {\n\t\tpr_err(\"qbman: mgmt cmd failed, no response (verb=0x%x)\\n\",\n\t\t       alt_fq_verb);\n\t\treturn -EIO;\n\t}\n\n\t \n\tWARN_ON((r->verb & QBMAN_RESULT_MASK) != alt_fq_verb);\n\n\t \n\tif (unlikely(r->rslt != QBMAN_MC_RSLT_OK)) {\n\t\tpr_err(\"qbman: ALT FQID %d failed: verb = 0x%08x code = 0x%02x\\n\",\n\t\t       fqid, r->verb, r->rslt);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstruct qbman_cdan_ctrl_desc {\n\tu8 verb;\n\tu8 reserved;\n\t__le16 ch;\n\tu8 we;\n\tu8 ctrl;\n\t__le16 reserved2;\n\t__le64 cdan_ctx;\n\tu8 reserved3[48];\n\n};\n\nstruct qbman_cdan_ctrl_rslt {\n\tu8 verb;\n\tu8 rslt;\n\t__le16 ch;\n\tu8 reserved[60];\n};\n\nint qbman_swp_CDAN_set(struct qbman_swp *s, u16 channelid,\n\t\t       u8 we_mask, u8 cdan_en,\n\t\t       u64 ctx)\n{\n\tstruct qbman_cdan_ctrl_desc *p = NULL;\n\tstruct qbman_cdan_ctrl_rslt *r = NULL;\n\n\t \n\tp = qbman_swp_mc_start(s);\n\tif (!p)\n\t\treturn -EBUSY;\n\n\t \n\tp->ch = cpu_to_le16(channelid);\n\tp->we = we_mask;\n\tif (cdan_en)\n\t\tp->ctrl = 1;\n\telse\n\t\tp->ctrl = 0;\n\tp->cdan_ctx = cpu_to_le64(ctx);\n\n\t \n\tr = qbman_swp_mc_complete(s, p, QBMAN_WQCHAN_CONFIGURE);\n\tif (unlikely(!r)) {\n\t\tpr_err(\"qbman: wqchan config failed, no response\\n\");\n\t\treturn -EIO;\n\t}\n\n\tWARN_ON((r->verb & 0x7f) != QBMAN_WQCHAN_CONFIGURE);\n\n\t \n\tif (unlikely(r->rslt != QBMAN_MC_RSLT_OK)) {\n\t\tpr_err(\"qbman: CDAN cQID %d failed: code = 0x%02x\\n\",\n\t\t       channelid, r->rslt);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n#define QBMAN_RESPONSE_VERB_MASK\t0x7f\n#define QBMAN_FQ_QUERY_NP\t\t0x45\n#define QBMAN_BP_QUERY\t\t\t0x32\n\nstruct qbman_fq_query_desc {\n\tu8 verb;\n\tu8 reserved[3];\n\t__le32 fqid;\n\tu8 reserved2[56];\n};\n\nint qbman_fq_query_state(struct qbman_swp *s, u32 fqid,\n\t\t\t struct qbman_fq_query_np_rslt *r)\n{\n\tstruct qbman_fq_query_desc *p;\n\tvoid *resp;\n\n\tp = (struct qbman_fq_query_desc *)qbman_swp_mc_start(s);\n\tif (!p)\n\t\treturn -EBUSY;\n\n\t \n\tp->fqid = cpu_to_le32(fqid & 0x00FFFFFF);\n\tresp = qbman_swp_mc_complete(s, p, QBMAN_FQ_QUERY_NP);\n\tif (!resp) {\n\t\tpr_err(\"qbman: Query FQID %d NP fields failed, no response\\n\",\n\t\t       fqid);\n\t\treturn -EIO;\n\t}\n\t*r = *(struct qbman_fq_query_np_rslt *)resp;\n\t \n\tWARN_ON((r->verb & QBMAN_RESPONSE_VERB_MASK) != QBMAN_FQ_QUERY_NP);\n\n\t \n\tif (r->rslt != QBMAN_MC_RSLT_OK) {\n\t\tpr_err(\"Query NP fields of FQID 0x%x failed, code=0x%02x\\n\",\n\t\t       p->fqid, r->rslt);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nu32 qbman_fq_state_frame_count(const struct qbman_fq_query_np_rslt *r)\n{\n\treturn (le32_to_cpu(r->frm_cnt) & 0x00FFFFFF);\n}\n\nu32 qbman_fq_state_byte_count(const struct qbman_fq_query_np_rslt *r)\n{\n\treturn le32_to_cpu(r->byte_cnt);\n}\n\nstruct qbman_bp_query_desc {\n\tu8 verb;\n\tu8 reserved;\n\t__le16 bpid;\n\tu8 reserved2[60];\n};\n\nint qbman_bp_query(struct qbman_swp *s, u16 bpid,\n\t\t   struct qbman_bp_query_rslt *r)\n{\n\tstruct qbman_bp_query_desc *p;\n\tvoid *resp;\n\n\tp = (struct qbman_bp_query_desc *)qbman_swp_mc_start(s);\n\tif (!p)\n\t\treturn -EBUSY;\n\n\tp->bpid = cpu_to_le16(bpid);\n\tresp = qbman_swp_mc_complete(s, p, QBMAN_BP_QUERY);\n\tif (!resp) {\n\t\tpr_err(\"qbman: Query BPID %d fields failed, no response\\n\",\n\t\t       bpid);\n\t\treturn -EIO;\n\t}\n\t*r = *(struct qbman_bp_query_rslt *)resp;\n\t \n\tWARN_ON((r->verb & QBMAN_RESPONSE_VERB_MASK) != QBMAN_BP_QUERY);\n\n\t \n\tif (r->rslt != QBMAN_MC_RSLT_OK) {\n\t\tpr_err(\"Query fields of BPID 0x%x failed, code=0x%02x\\n\",\n\t\t       bpid, r->rslt);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nu32 qbman_bp_info_num_free_bufs(struct qbman_bp_query_rslt *a)\n{\n\treturn le32_to_cpu(a->fill);\n}\n\n \nint qbman_swp_set_irq_coalescing(struct qbman_swp *p, u32 irq_threshold,\n\t\t\t\t u32 irq_holdoff)\n{\n\tu32 itp, max_holdoff;\n\n\t \n\titp = (irq_holdoff * 1000) / p->desc->qman_256_cycles_per_ns;\n\tif (itp > 4096) {\n\t\tmax_holdoff = (p->desc->qman_256_cycles_per_ns * 4096) / 1000;\n\t\tpr_err(\"irq_holdoff must be <= %uus\\n\", max_holdoff);\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_threshold >= p->dqrr.dqrr_size) {\n\t\tpr_err(\"irq_threshold must be < %u\\n\", p->dqrr.dqrr_size - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tp->irq_threshold = irq_threshold;\n\tp->irq_holdoff = irq_holdoff;\n\n\tqbman_write_register(p, QBMAN_CINH_SWP_DQRR_ITR, irq_threshold);\n\tqbman_write_register(p, QBMAN_CINH_SWP_ITPR, itp);\n\n\treturn 0;\n}\n\n \nvoid qbman_swp_get_irq_coalescing(struct qbman_swp *p, u32 *irq_threshold,\n\t\t\t\t  u32 *irq_holdoff)\n{\n\tif (irq_threshold)\n\t\t*irq_threshold = p->irq_threshold;\n\tif (irq_holdoff)\n\t\t*irq_holdoff = p->irq_holdoff;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}