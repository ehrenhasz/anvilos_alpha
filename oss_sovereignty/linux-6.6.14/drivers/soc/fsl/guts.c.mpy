{
  "module_name": "guts.c",
  "hash_id": "37b65acd13fd73917505339f37aaa5cb9b32d9f35e7db8f56ccc60947ec8a427",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/guts.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of_fdt.h>\n#include <linux/sys_soc.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/fsl/guts.h>\n\nstruct fsl_soc_die_attr {\n\tchar\t*die;\n\tu32\tsvr;\n\tu32\tmask;\n};\n\nstruct fsl_soc_data {\n\tconst char *sfp_compat;\n\tu32 uid_offset;\n};\n\n \nstatic const struct fsl_soc_die_attr fsl_soc_die[] = {\n\t \n\n\t \n\t{ .die\t\t= \"T4240\",\n\t  .svr\t\t= 0x82400000,\n\t  .mask\t\t= 0xfff00000,\n\t},\n\t \n\t{ .die\t\t= \"T1040\",\n\t  .svr\t\t= 0x85200000,\n\t  .mask\t\t= 0xfff00000,\n\t},\n\t \n\t{ .die\t\t= \"T2080\",\n\t  .svr\t\t= 0x85300000,\n\t  .mask\t\t= 0xfff00000,\n\t},\n\t \n\t{ .die\t\t= \"T1024\",\n\t  .svr\t\t= 0x85400000,\n\t  .mask\t\t= 0xfff00000,\n\t},\n\n\t \n\n\t \n\t{ .die\t\t= \"LS1043A\",\n\t  .svr\t\t= 0x87920000,\n\t  .mask\t\t= 0xffff0000,\n\t},\n\t \n\t{ .die\t\t= \"LS2080A\",\n\t  .svr\t\t= 0x87010000,\n\t  .mask\t\t= 0xff3f0000,\n\t},\n\t \n\t{ .die\t\t= \"LS1088A\",\n\t  .svr\t\t= 0x87030000,\n\t  .mask\t\t= 0xff3f0000,\n\t},\n\t \n\t{ .die\t\t= \"LS1012A\",\n\t  .svr\t\t= 0x87040000,\n\t  .mask\t\t= 0xffff0000,\n\t},\n\t \n\t{ .die\t\t= \"LS1046A\",\n\t  .svr\t\t= 0x87070000,\n\t  .mask\t\t= 0xffff0000,\n\t},\n\t \n\t{ .die\t\t= \"LS2088A\",\n\t  .svr\t\t= 0x87090000,\n\t  .mask\t\t= 0xff3f0000,\n\t},\n\t \n\t{ .die\t\t= \"LS1021A\",\n\t  .svr\t\t= 0x87000000,\n\t  .mask\t\t= 0xfff70000,\n\t},\n\t \n\t{ .die          = \"LX2160A\",\n\t  .svr          = 0x87360000,\n\t  .mask         = 0xff3f0000,\n\t},\n\t \n\t{ .die          = \"LS1028A\",\n\t  .svr          = 0x870b0000,\n\t  .mask         = 0xff3f0000,\n\t},\n\t{ },\n};\n\nstatic const struct fsl_soc_die_attr *fsl_soc_die_match(\n\tu32 svr, const struct fsl_soc_die_attr *matches)\n{\n\twhile (matches->svr) {\n\t\tif (matches->svr == (svr & matches->mask))\n\t\t\treturn matches;\n\t\tmatches++;\n\t}\n\treturn NULL;\n}\n\nstatic u64 fsl_guts_get_soc_uid(const char *compat, unsigned int offset)\n{\n\tstruct device_node *np;\n\tvoid __iomem *sfp_base;\n\tu64 uid;\n\n\tnp = of_find_compatible_node(NULL, NULL, compat);\n\tif (!np)\n\t\treturn 0;\n\n\tsfp_base = of_iomap(np, 0);\n\tif (!sfp_base) {\n\t\tof_node_put(np);\n\t\treturn 0;\n\t}\n\n\tuid = ioread32(sfp_base + offset);\n\tuid <<= 32;\n\tuid |= ioread32(sfp_base + offset + 4);\n\n\tiounmap(sfp_base);\n\tof_node_put(np);\n\n\treturn uid;\n}\n\nstatic const struct fsl_soc_data ls1028a_data = {\n\t.sfp_compat = \"fsl,ls1028a-sfp\",\n\t.uid_offset = 0x21c,\n};\n\n \nstatic const struct of_device_id fsl_guts_of_match[] = {\n\t{ .compatible = \"fsl,qoriq-device-config-1.0\", },\n\t{ .compatible = \"fsl,qoriq-device-config-2.0\", },\n\t{ .compatible = \"fsl,p1010-guts\", },\n\t{ .compatible = \"fsl,p1020-guts\", },\n\t{ .compatible = \"fsl,p1021-guts\", },\n\t{ .compatible = \"fsl,p1022-guts\", },\n\t{ .compatible = \"fsl,p1023-guts\", },\n\t{ .compatible = \"fsl,p2020-guts\", },\n\t{ .compatible = \"fsl,bsc9131-guts\", },\n\t{ .compatible = \"fsl,bsc9132-guts\", },\n\t{ .compatible = \"fsl,mpc8536-guts\", },\n\t{ .compatible = \"fsl,mpc8544-guts\", },\n\t{ .compatible = \"fsl,mpc8548-guts\", },\n\t{ .compatible = \"fsl,mpc8568-guts\", },\n\t{ .compatible = \"fsl,mpc8569-guts\", },\n\t{ .compatible = \"fsl,mpc8572-guts\", },\n\t{ .compatible = \"fsl,ls1021a-dcfg\", },\n\t{ .compatible = \"fsl,ls1043a-dcfg\", },\n\t{ .compatible = \"fsl,ls2080a-dcfg\", },\n\t{ .compatible = \"fsl,ls1088a-dcfg\", },\n\t{ .compatible = \"fsl,ls1012a-dcfg\", },\n\t{ .compatible = \"fsl,ls1046a-dcfg\", },\n\t{ .compatible = \"fsl,lx2160a-dcfg\", },\n\t{ .compatible = \"fsl,ls1028a-dcfg\", .data = &ls1028a_data},\n\t{}\n};\n\nstatic int __init fsl_guts_init(void)\n{\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstatic struct soc_device *soc_dev;\n\tconst struct fsl_soc_die_attr *soc_die;\n\tconst struct fsl_soc_data *soc_data;\n\tconst struct of_device_id *match;\n\tstruct ccsr_guts __iomem *regs;\n\tconst char *machine = NULL;\n\tstruct device_node *np;\n\tbool little_endian;\n\tu64 soc_uid = 0;\n\tu32 svr;\n\tint ret;\n\n\tnp = of_find_matching_node_and_match(NULL, fsl_guts_of_match, &match);\n\tif (!np)\n\t\treturn 0;\n\tsoc_data = match->data;\n\n\tregs = of_iomap(np, 0);\n\tif (!regs) {\n\t\tof_node_put(np);\n\t\treturn -ENOMEM;\n\t}\n\n\tlittle_endian = of_property_read_bool(np, \"little-endian\");\n\tif (little_endian)\n\t\tsvr = ioread32(&regs->svr);\n\telse\n\t\tsvr = ioread32be(&regs->svr);\n\tiounmap(regs);\n\tof_node_put(np);\n\n\t \n\tsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_string(of_root, \"model\", &machine))\n\t\tof_property_read_string_index(of_root, \"compatible\", 0, &machine);\n\tif (machine) {\n\t\tsoc_dev_attr->machine = kstrdup(machine, GFP_KERNEL);\n\t\tif (!soc_dev_attr->machine)\n\t\t\tgoto err_nomem;\n\t}\n\n\tsoc_die = fsl_soc_die_match(svr, fsl_soc_die);\n\tif (soc_die) {\n\t\tsoc_dev_attr->family = kasprintf(GFP_KERNEL, \"QorIQ %s\",\n\t\t\t\t\t\t soc_die->die);\n\t} else {\n\t\tsoc_dev_attr->family = kasprintf(GFP_KERNEL, \"QorIQ\");\n\t}\n\tif (!soc_dev_attr->family)\n\t\tgoto err_nomem;\n\n\tsoc_dev_attr->soc_id = kasprintf(GFP_KERNEL, \"svr:0x%08x\", svr);\n\tif (!soc_dev_attr->soc_id)\n\t\tgoto err_nomem;\n\n\tsoc_dev_attr->revision = kasprintf(GFP_KERNEL, \"%d.%d\",\n\t\t\t\t\t   (svr >>  4) & 0xf, svr & 0xf);\n\tif (!soc_dev_attr->revision)\n\t\tgoto err_nomem;\n\n\tif (soc_data)\n\t\tsoc_uid = fsl_guts_get_soc_uid(soc_data->sfp_compat,\n\t\t\t\t\t       soc_data->uid_offset);\n\tif (soc_uid)\n\t\tsoc_dev_attr->serial_number = kasprintf(GFP_KERNEL, \"%016llX\",\n\t\t\t\t\t\t\tsoc_uid);\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev)) {\n\t\tret = PTR_ERR(soc_dev);\n\t\tgoto err;\n\t}\n\n\tpr_info(\"Machine: %s\\n\", soc_dev_attr->machine);\n\tpr_info(\"SoC family: %s\\n\", soc_dev_attr->family);\n\tpr_info(\"SoC ID: %s, Revision: %s\\n\",\n\t\tsoc_dev_attr->soc_id, soc_dev_attr->revision);\n\n\treturn 0;\n\nerr_nomem:\n\tret = -ENOMEM;\nerr:\n\tkfree(soc_dev_attr->machine);\n\tkfree(soc_dev_attr->family);\n\tkfree(soc_dev_attr->soc_id);\n\tkfree(soc_dev_attr->revision);\n\tkfree(soc_dev_attr->serial_number);\n\tkfree(soc_dev_attr);\n\n\treturn ret;\n}\ncore_initcall(fsl_guts_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}