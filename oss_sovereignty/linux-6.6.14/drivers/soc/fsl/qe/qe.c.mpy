{
  "module_name": "qe.c",
  "hash_id": "a158c14bd10082f0ab37f47703c828dc51d52f37666e308294c92e827c49944b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qe.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/param.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/iopoll.h>\n#include <linux/crc32.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <soc/fsl/qe/immap_qe.h>\n#include <soc/fsl/qe/qe.h>\n\nstatic void qe_snums_init(void);\nstatic int qe_sdma_init(void);\n\nstatic DEFINE_SPINLOCK(qe_lock);\nDEFINE_SPINLOCK(cmxgcr_lock);\nEXPORT_SYMBOL(cmxgcr_lock);\n\n \nstruct qe_immap __iomem *qe_immr;\nEXPORT_SYMBOL(qe_immr);\n\nstatic u8 snums[QE_NUM_OF_SNUM];\t \nstatic DECLARE_BITMAP(snum_state, QE_NUM_OF_SNUM);\nstatic unsigned int qe_num_of_snum;\n\nstatic phys_addr_t qebase = -1;\n\nstatic struct device_node *qe_get_device_node(void)\n{\n\tstruct device_node *qe;\n\n\t \n\tqe = of_find_compatible_node(NULL, NULL, \"fsl,qe\");\n\tif (qe)\n\t\treturn qe;\n\treturn of_find_node_by_type(NULL, \"qe\");\n}\n\nstatic phys_addr_t get_qe_base(void)\n{\n\tstruct device_node *qe;\n\tint ret;\n\tstruct resource res;\n\n\tif (qebase != -1)\n\t\treturn qebase;\n\n\tqe = qe_get_device_node();\n\tif (!qe)\n\t\treturn qebase;\n\n\tret = of_address_to_resource(qe, 0, &res);\n\tif (!ret)\n\t\tqebase = res.start;\n\tof_node_put(qe);\n\n\treturn qebase;\n}\n\nvoid qe_reset(void)\n{\n\tif (qe_immr == NULL)\n\t\tqe_immr = ioremap(get_qe_base(), QE_IMMAP_SIZE);\n\n\tqe_snums_init();\n\n\tqe_issue_cmd(QE_RESET, QE_CR_SUBBLOCK_INVALID,\n\t\t     QE_CR_PROTOCOL_UNSPECIFIED, 0);\n\n\t \n\tqe_muram_init();\n\n\tif (qe_sdma_init())\n\t\tpanic(\"sdma init failed!\");\n}\n\nint qe_issue_cmd(u32 cmd, u32 device, u8 mcn_protocol, u32 cmd_input)\n{\n\tunsigned long flags;\n\tu8 mcn_shift = 0, dev_shift = 0;\n\tu32 val;\n\tint ret;\n\n\tspin_lock_irqsave(&qe_lock, flags);\n\tif (cmd == QE_RESET) {\n\t\tiowrite32be((u32)(cmd | QE_CR_FLG), &qe_immr->cp.cecr);\n\t} else {\n\t\tif (cmd == QE_ASSIGN_PAGE) {\n\t\t\t \n\t\t\tdev_shift = QE_CR_SNUM_SHIFT;\n\t\t} else if (cmd == QE_ASSIGN_RISC) {\n\t\t\t \n\t\t\tdev_shift = QE_CR_SNUM_SHIFT;\n\t\t\tmcn_shift = QE_CR_MCN_RISC_ASSIGN_SHIFT;\n\t\t} else {\n\t\t\tif (device == QE_CR_SUBBLOCK_USB)\n\t\t\t\tmcn_shift = QE_CR_MCN_USB_SHIFT;\n\t\t\telse\n\t\t\t\tmcn_shift = QE_CR_MCN_NORMAL_SHIFT;\n\t\t}\n\n\t\tiowrite32be(cmd_input, &qe_immr->cp.cecdr);\n\t\tiowrite32be((cmd | QE_CR_FLG | ((u32)device << dev_shift) | (u32)mcn_protocol << mcn_shift),\n\t\t\t       &qe_immr->cp.cecr);\n\t}\n\n\t \n\tret = readx_poll_timeout_atomic(ioread32be, &qe_immr->cp.cecr, val,\n\t\t\t\t\t(val & QE_CR_FLG) == 0, 0, 100);\n\t \n\tspin_unlock_irqrestore(&qe_lock, flags);\n\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(qe_issue_cmd);\n\n \nstatic unsigned int brg_clk = 0;\n\n#define CLK_GRAN\t(1000)\n#define CLK_GRAN_LIMIT\t(5)\n\nunsigned int qe_get_brg_clk(void)\n{\n\tstruct device_node *qe;\n\tu32 brg;\n\tunsigned int mod;\n\n\tif (brg_clk)\n\t\treturn brg_clk;\n\n\tqe = qe_get_device_node();\n\tif (!qe)\n\t\treturn brg_clk;\n\n\tif (!of_property_read_u32(qe, \"brg-frequency\", &brg))\n\t\tbrg_clk = brg;\n\n\tof_node_put(qe);\n\n\t \n\tmod = brg_clk % CLK_GRAN;\n\tif (mod) {\n\t\tif (mod < CLK_GRAN_LIMIT)\n\t\t\tbrg_clk -= mod;\n\t\telse if (mod > (CLK_GRAN - CLK_GRAN_LIMIT))\n\t\t\tbrg_clk += CLK_GRAN - mod;\n\t}\n\n\treturn brg_clk;\n}\nEXPORT_SYMBOL(qe_get_brg_clk);\n\n#define PVR_VER_836x\t0x8083\n#define PVR_VER_832x\t0x8084\n\nstatic bool qe_general4_errata(void)\n{\n#ifdef CONFIG_PPC32\n\treturn pvr_version_is(PVR_VER_836x) || pvr_version_is(PVR_VER_832x);\n#endif\n\treturn false;\n}\n\n \nint qe_setbrg(enum qe_clock brg, unsigned int rate, unsigned int multiplier)\n{\n\tu32 divisor, tempval;\n\tu32 div16 = 0;\n\n\tif ((brg < QE_BRG1) || (brg > QE_BRG16))\n\t\treturn -EINVAL;\n\n\tdivisor = qe_get_brg_clk() / (rate * multiplier);\n\n\tif (divisor > QE_BRGC_DIVISOR_MAX + 1) {\n\t\tdiv16 = QE_BRGC_DIV16;\n\t\tdivisor /= 16;\n\t}\n\n\t \n\tif (qe_general4_errata())\n\t\tif (!div16 && (divisor & 1) && (divisor > 3))\n\t\t\tdivisor++;\n\n\ttempval = ((divisor - 1) << QE_BRGC_DIVISOR_SHIFT) |\n\t\tQE_BRGC_ENABLE | div16;\n\n\tiowrite32be(tempval, &qe_immr->brg.brgc[brg - QE_BRG1]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qe_setbrg);\n\n \nenum qe_clock qe_clock_source(const char *source)\n{\n\tunsigned int i;\n\n\tif (strcasecmp(source, \"none\") == 0)\n\t\treturn QE_CLK_NONE;\n\n\tif (strcmp(source, \"tsync_pin\") == 0)\n\t\treturn QE_TSYNC_PIN;\n\n\tif (strcmp(source, \"rsync_pin\") == 0)\n\t\treturn QE_RSYNC_PIN;\n\n\tif (strncasecmp(source, \"brg\", 3) == 0) {\n\t\ti = simple_strtoul(source + 3, NULL, 10);\n\t\tif ((i >= 1) && (i <= 16))\n\t\t\treturn (QE_BRG1 - 1) + i;\n\t\telse\n\t\t\treturn QE_CLK_DUMMY;\n\t}\n\n\tif (strncasecmp(source, \"clk\", 3) == 0) {\n\t\ti = simple_strtoul(source + 3, NULL, 10);\n\t\tif ((i >= 1) && (i <= 24))\n\t\t\treturn (QE_CLK1 - 1) + i;\n\t\telse\n\t\t\treturn QE_CLK_DUMMY;\n\t}\n\n\treturn QE_CLK_DUMMY;\n}\nEXPORT_SYMBOL(qe_clock_source);\n\n \nstatic void qe_snums_init(void)\n{\n\tstatic const u8 snum_init_76[] = {\n\t\t0x04, 0x05, 0x0C, 0x0D, 0x14, 0x15, 0x1C, 0x1D,\n\t\t0x24, 0x25, 0x2C, 0x2D, 0x34, 0x35, 0x88, 0x89,\n\t\t0x98, 0x99, 0xA8, 0xA9, 0xB8, 0xB9, 0xC8, 0xC9,\n\t\t0xD8, 0xD9, 0xE8, 0xE9, 0x44, 0x45, 0x4C, 0x4D,\n\t\t0x54, 0x55, 0x5C, 0x5D, 0x64, 0x65, 0x6C, 0x6D,\n\t\t0x74, 0x75, 0x7C, 0x7D, 0x84, 0x85, 0x8C, 0x8D,\n\t\t0x94, 0x95, 0x9C, 0x9D, 0xA4, 0xA5, 0xAC, 0xAD,\n\t\t0xB4, 0xB5, 0xBC, 0xBD, 0xC4, 0xC5, 0xCC, 0xCD,\n\t\t0xD4, 0xD5, 0xDC, 0xDD, 0xE4, 0xE5, 0xEC, 0xED,\n\t\t0xF4, 0xF5, 0xFC, 0xFD,\n\t};\n\tstatic const u8 snum_init_46[] = {\n\t\t0x04, 0x05, 0x0C, 0x0D, 0x14, 0x15, 0x1C, 0x1D,\n\t\t0x24, 0x25, 0x2C, 0x2D, 0x34, 0x35, 0x88, 0x89,\n\t\t0x98, 0x99, 0xA8, 0xA9, 0xB8, 0xB9, 0xC8, 0xC9,\n\t\t0xD8, 0xD9, 0xE8, 0xE9, 0x08, 0x09, 0x18, 0x19,\n\t\t0x28, 0x29, 0x38, 0x39, 0x48, 0x49, 0x58, 0x59,\n\t\t0x68, 0x69, 0x78, 0x79, 0x80, 0x81,\n\t};\n\tstruct device_node *qe;\n\tconst u8 *snum_init;\n\tint i;\n\n\tbitmap_zero(snum_state, QE_NUM_OF_SNUM);\n\tqe_num_of_snum = 28;  \n\tqe = qe_get_device_node();\n\tif (qe) {\n\t\ti = of_property_read_variable_u8_array(qe, \"fsl,qe-snums\",\n\t\t\t\t\t\t       snums, 1, QE_NUM_OF_SNUM);\n\t\tif (i > 0) {\n\t\t\tof_node_put(qe);\n\t\t\tqe_num_of_snum = i;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tof_property_read_u32(qe, \"fsl,qe-num-snums\", &qe_num_of_snum);\n\t\tof_node_put(qe);\n\t}\n\n\tif (qe_num_of_snum == 76) {\n\t\tsnum_init = snum_init_76;\n\t} else if (qe_num_of_snum == 28 || qe_num_of_snum == 46) {\n\t\tsnum_init = snum_init_46;\n\t} else {\n\t\tpr_err(\"QE: unsupported value of fsl,qe-num-snums: %u\\n\", qe_num_of_snum);\n\t\treturn;\n\t}\n\tmemcpy(snums, snum_init, qe_num_of_snum);\n}\n\nint qe_get_snum(void)\n{\n\tunsigned long flags;\n\tint snum = -EBUSY;\n\tint i;\n\n\tspin_lock_irqsave(&qe_lock, flags);\n\ti = find_first_zero_bit(snum_state, qe_num_of_snum);\n\tif (i < qe_num_of_snum) {\n\t\tset_bit(i, snum_state);\n\t\tsnum = snums[i];\n\t}\n\tspin_unlock_irqrestore(&qe_lock, flags);\n\n\treturn snum;\n}\nEXPORT_SYMBOL(qe_get_snum);\n\nvoid qe_put_snum(u8 snum)\n{\n\tconst u8 *p = memchr(snums, snum, qe_num_of_snum);\n\n\tif (p)\n\t\tclear_bit(p - snums, snum_state);\n}\nEXPORT_SYMBOL(qe_put_snum);\n\nstatic int qe_sdma_init(void)\n{\n\tstruct sdma __iomem *sdma = &qe_immr->sdma;\n\tstatic s32 sdma_buf_offset = -ENOMEM;\n\n\t \n\tif (sdma_buf_offset < 0) {\n\t\tsdma_buf_offset = qe_muram_alloc(512 * 2, 4096);\n\t\tif (sdma_buf_offset < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tiowrite32be((u32)sdma_buf_offset & QE_SDEBCR_BA_MASK,\n\t\t       &sdma->sdebcr);\n\tiowrite32be((QE_SDMR_GLB_1_MSK | (0x1 << QE_SDMR_CEN_SHIFT)),\n\t\t       &sdma->sdmr);\n\n\treturn 0;\n}\n\n \n#define MAX_QE_RISC     4\n\n \nstatic struct qe_firmware_info qe_firmware_info;\n\n \nstatic int qe_firmware_uploaded;\n\n \nstatic void qe_upload_microcode(const void *base,\n\tconst struct qe_microcode *ucode)\n{\n\tconst __be32 *code = base + be32_to_cpu(ucode->code_offset);\n\tunsigned int i;\n\n\tif (ucode->major || ucode->minor || ucode->revision)\n\t\tprintk(KERN_INFO \"qe-firmware: \"\n\t\t\t\"uploading microcode '%s' version %u.%u.%u\\n\",\n\t\t\tucode->id, ucode->major, ucode->minor, ucode->revision);\n\telse\n\t\tprintk(KERN_INFO \"qe-firmware: \"\n\t\t\t\"uploading microcode '%s'\\n\", ucode->id);\n\n\t \n\tiowrite32be(be32_to_cpu(ucode->iram_offset) | QE_IRAM_IADD_AIE | QE_IRAM_IADD_BADDR,\n\t\t       &qe_immr->iram.iadd);\n\n\tfor (i = 0; i < be32_to_cpu(ucode->count); i++)\n\t\tiowrite32be(be32_to_cpu(code[i]), &qe_immr->iram.idata);\n\n\t \n\tiowrite32be(QE_IRAM_READY, &qe_immr->iram.iready);\n}\n\n \nint qe_upload_firmware(const struct qe_firmware *firmware)\n{\n\tunsigned int i;\n\tunsigned int j;\n\tu32 crc;\n\tsize_t calc_size;\n\tsize_t length;\n\tconst struct qe_header *hdr;\n\n\tif (!firmware) {\n\t\tprintk(KERN_ERR \"qe-firmware: invalid pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = &firmware->header;\n\tlength = be32_to_cpu(hdr->length);\n\n\t \n\tif ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||\n\t    (hdr->magic[2] != 'F')) {\n\t\tprintk(KERN_ERR \"qe-firmware: not a microcode\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (hdr->version != 1) {\n\t\tprintk(KERN_ERR \"qe-firmware: unsupported version\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif ((firmware->count < 1) || (firmware->count > MAX_QE_RISC)) {\n\t\tprintk(KERN_ERR \"qe-firmware: invalid data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcalc_size = struct_size(firmware, microcode, firmware->count);\n\n\tfor (i = 0; i < firmware->count; i++)\n\t\t \n\t\tcalc_size += sizeof(__be32) *\n\t\t\tbe32_to_cpu(firmware->microcode[i].count);\n\n\t \n\tif (length != calc_size + sizeof(__be32)) {\n\t\tprintk(KERN_ERR \"qe-firmware: invalid length\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tcrc = be32_to_cpu(*(__be32 *)((void *)firmware + calc_size));\n\tif (crc != crc32(0, firmware, calc_size)) {\n\t\tprintk(KERN_ERR \"qe-firmware: firmware CRC is invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!firmware->split)\n\t\tqe_setbits_be16(&qe_immr->cp.cercr, QE_CP_CERCR_CIR);\n\n\tif (firmware->soc.model)\n\t\tprintk(KERN_INFO\n\t\t\t\"qe-firmware: firmware '%s' for %u V%u.%u\\n\",\n\t\t\tfirmware->id, be16_to_cpu(firmware->soc.model),\n\t\t\tfirmware->soc.major, firmware->soc.minor);\n\telse\n\t\tprintk(KERN_INFO \"qe-firmware: firmware '%s'\\n\",\n\t\t\tfirmware->id);\n\n\t \n\tmemset(&qe_firmware_info, 0, sizeof(qe_firmware_info));\n\tstrscpy(qe_firmware_info.id, firmware->id, sizeof(qe_firmware_info.id));\n\tqe_firmware_info.extended_modes = be64_to_cpu(firmware->extended_modes);\n\tmemcpy(qe_firmware_info.vtraps, firmware->vtraps,\n\t\tsizeof(firmware->vtraps));\n\n\t \n\tfor (i = 0; i < firmware->count; i++) {\n\t\tconst struct qe_microcode *ucode = &firmware->microcode[i];\n\n\t\t \n\t\tif (ucode->code_offset)\n\t\t\tqe_upload_microcode(firmware, ucode);\n\n\t\t \n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tu32 trap = be32_to_cpu(ucode->traps[j]);\n\n\t\t\tif (trap)\n\t\t\t\tiowrite32be(trap,\n\t\t\t\t\t       &qe_immr->rsp[i].tibcr[j]);\n\t\t}\n\n\t\t \n\t\tiowrite32be(be32_to_cpu(ucode->eccr),\n\t\t\t       &qe_immr->rsp[i].eccr);\n\t}\n\n\tqe_firmware_uploaded = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qe_upload_firmware);\n\n \nstruct qe_firmware_info *qe_get_firmware_info(void)\n{\n\tstatic int initialized;\n\tstruct device_node *qe;\n\tstruct device_node *fw = NULL;\n\tconst char *sprop;\n\n\t \n\tif (qe_firmware_uploaded)\n\t\treturn &qe_firmware_info;\n\n\tif (initialized)\n\t\treturn NULL;\n\n\tinitialized = 1;\n\n\tqe = qe_get_device_node();\n\tif (!qe)\n\t\treturn NULL;\n\n\t \n\tfw = of_get_child_by_name(qe, \"firmware\");\n\tof_node_put(qe);\n\n\t \n\tif (!fw)\n\t\treturn NULL;\n\n\tqe_firmware_uploaded = 1;\n\n\t \n\tsprop = of_get_property(fw, \"id\", NULL);\n\tif (sprop)\n\t\tstrscpy(qe_firmware_info.id, sprop,\n\t\t\tsizeof(qe_firmware_info.id));\n\n\tof_property_read_u64(fw, \"extended-modes\",\n\t\t\t     &qe_firmware_info.extended_modes);\n\n\tof_property_read_u32_array(fw, \"virtual-traps\", qe_firmware_info.vtraps,\n\t\t\t\t   ARRAY_SIZE(qe_firmware_info.vtraps));\n\n\tof_node_put(fw);\n\n\treturn &qe_firmware_info;\n}\nEXPORT_SYMBOL(qe_get_firmware_info);\n\nunsigned int qe_get_num_of_risc(void)\n{\n\tstruct device_node *qe;\n\tunsigned int num_of_risc = 0;\n\n\tqe = qe_get_device_node();\n\tif (!qe)\n\t\treturn num_of_risc;\n\n\tof_property_read_u32(qe, \"fsl,qe-num-riscs\", &num_of_risc);\n\n\tof_node_put(qe);\n\n\treturn num_of_risc;\n}\nEXPORT_SYMBOL(qe_get_num_of_risc);\n\nunsigned int qe_get_num_of_snums(void)\n{\n\treturn qe_num_of_snum;\n}\nEXPORT_SYMBOL(qe_get_num_of_snums);\n\nstatic int __init qe_init(void)\n{\n\tstruct device_node *np;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,qe\");\n\tif (!np)\n\t\treturn -ENODEV;\n\tqe_reset();\n\tof_node_put(np);\n\treturn 0;\n}\nsubsys_initcall(qe_init);\n\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC_85xx)\nstatic int qe_resume(struct platform_device *ofdev)\n{\n\tif (!qe_alive_during_sleep())\n\t\tqe_reset();\n\treturn 0;\n}\n\nstatic int qe_probe(struct platform_device *ofdev)\n{\n\treturn 0;\n}\n\nstatic const struct of_device_id qe_ids[] = {\n\t{ .compatible = \"fsl,qe\", },\n\t{ },\n};\n\nstatic struct platform_driver qe_driver = {\n\t.driver = {\n\t\t.name = \"fsl-qe\",\n\t\t.of_match_table = qe_ids,\n\t},\n\t.probe = qe_probe,\n\t.resume = qe_resume,\n};\n\nbuiltin_platform_driver(qe_driver);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}