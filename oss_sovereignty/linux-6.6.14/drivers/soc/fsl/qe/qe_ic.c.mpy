{
  "module_name": "qe_ic.c",
  "hash_id": "f2f559f26b33da9c761c85e8e28b5d6b79f7233337939a90e8c5fdcf0811424b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qe_ic.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/irq.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <soc/fsl/qe/qe.h>\n\n#define NR_QE_IC_INTS\t\t64\n\n \n#define QEIC_CICR\t\t0x00\n#define QEIC_CIVEC\t\t0x04\n#define QEIC_CIPXCC\t\t0x10\n#define QEIC_CIPYCC\t\t0x14\n#define QEIC_CIPWCC\t\t0x18\n#define QEIC_CIPZCC\t\t0x1c\n#define QEIC_CIMR\t\t0x20\n#define QEIC_CRIMR\t\t0x24\n#define QEIC_CIPRTA\t\t0x30\n#define QEIC_CIPRTB\t\t0x34\n#define QEIC_CHIVEC\t\t0x60\n\nstruct qe_ic {\n\t \n\t__be32 __iomem *regs;\n\n\t \n\tstruct irq_domain *irqhost;\n\n\t \n\tstruct irq_chip hc_irq;\n\n\t \n\tint virq_high;\n\tint virq_low;\n};\n\n \nstruct qe_ic_info {\n\t \n\tu32\tmask;\n\n\t \n\tu32\tmask_reg;\n\n\t \n\tu8\tpri_code;\n\n\t \n\tu32\tpri_reg;\n};\n\nstatic DEFINE_RAW_SPINLOCK(qe_ic_lock);\n\nstatic struct qe_ic_info qe_ic_info[] = {\n\t[1] = {\n\t       .mask = 0x00008000,\n\t       .mask_reg = QEIC_CIMR,\n\t       .pri_code = 0,\n\t       .pri_reg = QEIC_CIPWCC,\n\t       },\n\t[2] = {\n\t       .mask = 0x00004000,\n\t       .mask_reg = QEIC_CIMR,\n\t       .pri_code = 1,\n\t       .pri_reg = QEIC_CIPWCC,\n\t       },\n\t[3] = {\n\t       .mask = 0x00002000,\n\t       .mask_reg = QEIC_CIMR,\n\t       .pri_code = 2,\n\t       .pri_reg = QEIC_CIPWCC,\n\t       },\n\t[10] = {\n\t\t.mask = 0x00000040,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 1,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[11] = {\n\t\t.mask = 0x00000020,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 2,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[12] = {\n\t\t.mask = 0x00000010,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 3,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[13] = {\n\t\t.mask = 0x00000008,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 4,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[14] = {\n\t\t.mask = 0x00000004,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 5,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[15] = {\n\t\t.mask = 0x00000002,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 6,\n\t\t.pri_reg = QEIC_CIPZCC,\n\t\t},\n\t[20] = {\n\t\t.mask = 0x10000000,\n\t\t.mask_reg = QEIC_CRIMR,\n\t\t.pri_code = 3,\n\t\t.pri_reg = QEIC_CIPRTA,\n\t\t},\n\t[25] = {\n\t\t.mask = 0x00800000,\n\t\t.mask_reg = QEIC_CRIMR,\n\t\t.pri_code = 0,\n\t\t.pri_reg = QEIC_CIPRTB,\n\t\t},\n\t[26] = {\n\t\t.mask = 0x00400000,\n\t\t.mask_reg = QEIC_CRIMR,\n\t\t.pri_code = 1,\n\t\t.pri_reg = QEIC_CIPRTB,\n\t\t},\n\t[27] = {\n\t\t.mask = 0x00200000,\n\t\t.mask_reg = QEIC_CRIMR,\n\t\t.pri_code = 2,\n\t\t.pri_reg = QEIC_CIPRTB,\n\t\t},\n\t[28] = {\n\t\t.mask = 0x00100000,\n\t\t.mask_reg = QEIC_CRIMR,\n\t\t.pri_code = 3,\n\t\t.pri_reg = QEIC_CIPRTB,\n\t\t},\n\t[32] = {\n\t\t.mask = 0x80000000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 0,\n\t\t.pri_reg = QEIC_CIPXCC,\n\t\t},\n\t[33] = {\n\t\t.mask = 0x40000000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 1,\n\t\t.pri_reg = QEIC_CIPXCC,\n\t\t},\n\t[34] = {\n\t\t.mask = 0x20000000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 2,\n\t\t.pri_reg = QEIC_CIPXCC,\n\t\t},\n\t[35] = {\n\t\t.mask = 0x10000000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 3,\n\t\t.pri_reg = QEIC_CIPXCC,\n\t\t},\n\t[36] = {\n\t\t.mask = 0x08000000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 4,\n\t\t.pri_reg = QEIC_CIPXCC,\n\t\t},\n\t[40] = {\n\t\t.mask = 0x00800000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 0,\n\t\t.pri_reg = QEIC_CIPYCC,\n\t\t},\n\t[41] = {\n\t\t.mask = 0x00400000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 1,\n\t\t.pri_reg = QEIC_CIPYCC,\n\t\t},\n\t[42] = {\n\t\t.mask = 0x00200000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 2,\n\t\t.pri_reg = QEIC_CIPYCC,\n\t\t},\n\t[43] = {\n\t\t.mask = 0x00100000,\n\t\t.mask_reg = QEIC_CIMR,\n\t\t.pri_code = 3,\n\t\t.pri_reg = QEIC_CIPYCC,\n\t\t},\n};\n\nstatic inline u32 qe_ic_read(__be32  __iomem *base, unsigned int reg)\n{\n\treturn ioread32be(base + (reg >> 2));\n}\n\nstatic inline void qe_ic_write(__be32  __iomem *base, unsigned int reg,\n\t\t\t       u32 value)\n{\n\tiowrite32be(value, base + (reg >> 2));\n}\n\nstatic inline struct qe_ic *qe_ic_from_irq(unsigned int virq)\n{\n\treturn irq_get_chip_data(virq);\n}\n\nstatic inline struct qe_ic *qe_ic_from_irq_data(struct irq_data *d)\n{\n\treturn irq_data_get_irq_chip_data(d);\n}\n\nstatic void qe_ic_unmask_irq(struct irq_data *d)\n{\n\tstruct qe_ic *qe_ic = qe_ic_from_irq_data(d);\n\tunsigned int src = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 temp;\n\n\traw_spin_lock_irqsave(&qe_ic_lock, flags);\n\n\ttemp = qe_ic_read(qe_ic->regs, qe_ic_info[src].mask_reg);\n\tqe_ic_write(qe_ic->regs, qe_ic_info[src].mask_reg,\n\t\t    temp | qe_ic_info[src].mask);\n\n\traw_spin_unlock_irqrestore(&qe_ic_lock, flags);\n}\n\nstatic void qe_ic_mask_irq(struct irq_data *d)\n{\n\tstruct qe_ic *qe_ic = qe_ic_from_irq_data(d);\n\tunsigned int src = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 temp;\n\n\traw_spin_lock_irqsave(&qe_ic_lock, flags);\n\n\ttemp = qe_ic_read(qe_ic->regs, qe_ic_info[src].mask_reg);\n\tqe_ic_write(qe_ic->regs, qe_ic_info[src].mask_reg,\n\t\t    temp & ~qe_ic_info[src].mask);\n\n\t \n\tmb();\n\n\traw_spin_unlock_irqrestore(&qe_ic_lock, flags);\n}\n\nstatic struct irq_chip qe_ic_irq_chip = {\n\t.name = \"QEIC\",\n\t.irq_unmask = qe_ic_unmask_irq,\n\t.irq_mask = qe_ic_mask_irq,\n\t.irq_mask_ack = qe_ic_mask_irq,\n};\n\nstatic int qe_ic_host_match(struct irq_domain *h, struct device_node *node,\n\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\t \n\tstruct device_node *of_node = irq_domain_get_of_node(h);\n\treturn of_node == NULL || of_node == node;\n}\n\nstatic int qe_ic_host_map(struct irq_domain *h, unsigned int virq,\n\t\t\t  irq_hw_number_t hw)\n{\n\tstruct qe_ic *qe_ic = h->host_data;\n\tstruct irq_chip *chip;\n\n\tif (hw >= ARRAY_SIZE(qe_ic_info)) {\n\t\tpr_err(\"%s: Invalid hw irq number for QEIC\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (qe_ic_info[hw].mask == 0) {\n\t\tprintk(KERN_ERR \"Can't map reserved IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tchip = &qe_ic->hc_irq;\n\n\tirq_set_chip_data(virq, qe_ic);\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\n\tirq_set_chip_and_handler(virq, chip, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops qe_ic_host_ops = {\n\t.match = qe_ic_host_match,\n\t.map = qe_ic_host_map,\n\t.xlate = irq_domain_xlate_onetwocell,\n};\n\n \nstatic unsigned int qe_ic_get_low_irq(struct qe_ic *qe_ic)\n{\n\tint irq;\n\n\tBUG_ON(qe_ic == NULL);\n\n\t \n\tirq = qe_ic_read(qe_ic->regs, QEIC_CIVEC) >> 26;\n\n\tif (irq == 0)\n\t\treturn 0;\n\n\treturn irq_linear_revmap(qe_ic->irqhost, irq);\n}\n\n \nstatic unsigned int qe_ic_get_high_irq(struct qe_ic *qe_ic)\n{\n\tint irq;\n\n\tBUG_ON(qe_ic == NULL);\n\n\t \n\tirq = qe_ic_read(qe_ic->regs, QEIC_CHIVEC) >> 26;\n\n\tif (irq == 0)\n\t\treturn 0;\n\n\treturn irq_linear_revmap(qe_ic->irqhost, irq);\n}\n\nstatic void qe_ic_cascade_low(struct irq_desc *desc)\n{\n\tstruct qe_ic *qe_ic = irq_desc_get_handler_data(desc);\n\tunsigned int cascade_irq = qe_ic_get_low_irq(qe_ic);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tif (cascade_irq != 0)\n\t\tgeneric_handle_irq(cascade_irq);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\n\nstatic void qe_ic_cascade_high(struct irq_desc *desc)\n{\n\tstruct qe_ic *qe_ic = irq_desc_get_handler_data(desc);\n\tunsigned int cascade_irq = qe_ic_get_high_irq(qe_ic);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tif (cascade_irq != 0)\n\t\tgeneric_handle_irq(cascade_irq);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\n\nstatic void qe_ic_cascade_muxed_mpic(struct irq_desc *desc)\n{\n\tstruct qe_ic *qe_ic = irq_desc_get_handler_data(desc);\n\tunsigned int cascade_irq;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tcascade_irq = qe_ic_get_high_irq(qe_ic);\n\tif (cascade_irq == 0)\n\t\tcascade_irq = qe_ic_get_low_irq(qe_ic);\n\n\tif (cascade_irq != 0)\n\t\tgeneric_handle_irq(cascade_irq);\n\n\tchip->irq_eoi(&desc->irq_data);\n}\n\nstatic int qe_ic_init(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid (*low_handler)(struct irq_desc *desc);\n\tvoid (*high_handler)(struct irq_desc *desc);\n\tstruct qe_ic *qe_ic;\n\tstruct resource *res;\n\tstruct device_node *node = pdev->dev.of_node;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqe_ic = devm_kzalloc(dev, sizeof(*qe_ic), GFP_KERNEL);\n\tif (qe_ic == NULL)\n\t\treturn -ENOMEM;\n\n\tqe_ic->regs = devm_ioremap(dev, res->start, resource_size(res));\n\tif (qe_ic->regs == NULL) {\n\t\tdev_err(dev, \"failed to ioremap() registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqe_ic->hc_irq = qe_ic_irq_chip;\n\n\tqe_ic->virq_high = platform_get_irq(pdev, 0);\n\tqe_ic->virq_low = platform_get_irq(pdev, 1);\n\n\tif (qe_ic->virq_low <= 0)\n\t\treturn -ENODEV;\n\n\tif (qe_ic->virq_high > 0 && qe_ic->virq_high != qe_ic->virq_low) {\n\t\tlow_handler = qe_ic_cascade_low;\n\t\thigh_handler = qe_ic_cascade_high;\n\t} else {\n\t\tlow_handler = qe_ic_cascade_muxed_mpic;\n\t\thigh_handler = NULL;\n\t}\n\n\tqe_ic->irqhost = irq_domain_add_linear(node, NR_QE_IC_INTS,\n\t\t\t\t\t       &qe_ic_host_ops, qe_ic);\n\tif (qe_ic->irqhost == NULL) {\n\t\tdev_err(dev, \"failed to add irq domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqe_ic_write(qe_ic->regs, QEIC_CICR, 0);\n\n\tirq_set_handler_data(qe_ic->virq_low, qe_ic);\n\tirq_set_chained_handler(qe_ic->virq_low, low_handler);\n\n\tif (high_handler) {\n\t\tirq_set_handler_data(qe_ic->virq_high, qe_ic);\n\t\tirq_set_chained_handler(qe_ic->virq_high, high_handler);\n\t}\n\treturn 0;\n}\nstatic const struct of_device_id qe_ic_ids[] = {\n\t{ .compatible = \"fsl,qe-ic\"},\n\t{ .type = \"qeic\"},\n\t{},\n};\n\nstatic struct platform_driver qe_ic_driver =\n{\n\t.driver\t= {\n\t\t.name\t\t= \"qe-ic\",\n\t\t.of_match_table\t= qe_ic_ids,\n\t},\n\t.probe\t= qe_ic_init,\n};\n\nstatic int __init qe_ic_of_init(void)\n{\n\tplatform_driver_register(&qe_ic_driver);\n\treturn 0;\n}\nsubsys_initcall(qe_ic_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}