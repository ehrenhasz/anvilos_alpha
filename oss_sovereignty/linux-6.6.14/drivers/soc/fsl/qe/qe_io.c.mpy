{
  "module_name": "qe_io.c",
  "hash_id": "32afd7deff13b93bca05bea29ec3936af3d12e82a4538c464ef710fa3928da2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qe_io.c",
  "human_readable_source": "\n \n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n\n#include <asm/io.h>\n#include <soc/fsl/qe/qe.h>\n\n#undef DEBUG\n\nstatic struct qe_pio_regs __iomem *par_io;\nstatic int num_par_io_ports = 0;\n\nint par_io_init(struct device_node *np)\n{\n\tstruct resource res;\n\tint ret;\n\tu32 num_ports;\n\n\t \n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret)\n\t\treturn ret;\n\tpar_io = ioremap(res.start, resource_size(&res));\n\tif (!par_io)\n\t\treturn -ENOMEM;\n\n\tif (!of_property_read_u32(np, \"num-ports\", &num_ports))\n\t\tnum_par_io_ports = num_ports;\n\n\treturn 0;\n}\n\nvoid __par_io_config_pin(struct qe_pio_regs __iomem *par_io, u8 pin, int dir,\n\t\t\t int open_drain, int assignment, int has_irq)\n{\n\tu32 pin_mask1bit;\n\tu32 pin_mask2bits;\n\tu32 new_mask2bits;\n\tu32 tmp_val;\n\n\t \n\tpin_mask1bit = (u32) (1 << (QE_PIO_PINS - (pin + 1)));\n\n\t \n\ttmp_val = ioread32be(&par_io->cpodr);\n\tif (open_drain)\n\t\tiowrite32be(pin_mask1bit | tmp_val, &par_io->cpodr);\n\telse\n\t\tiowrite32be(~pin_mask1bit & tmp_val, &par_io->cpodr);\n\n\t \n\ttmp_val = (pin > (QE_PIO_PINS / 2) - 1) ?\n\t\tioread32be(&par_io->cpdir2) :\n\t\tioread32be(&par_io->cpdir1);\n\n\t \n\tpin_mask2bits = (u32) (0x3 << (QE_PIO_PINS -\n\t\t\t\t(pin % (QE_PIO_PINS / 2) + 1) * 2));\n\n\t \n\tnew_mask2bits = (u32) (dir << (QE_PIO_PINS -\n\t\t\t\t(pin % (QE_PIO_PINS / 2) + 1) * 2));\n\n\t \n\tif (pin > (QE_PIO_PINS / 2) - 1) {\n\t\tiowrite32be(~pin_mask2bits & tmp_val, &par_io->cpdir2);\n\t\ttmp_val &= ~pin_mask2bits;\n\t\tiowrite32be(new_mask2bits | tmp_val, &par_io->cpdir2);\n\t} else {\n\t\tiowrite32be(~pin_mask2bits & tmp_val, &par_io->cpdir1);\n\t\ttmp_val &= ~pin_mask2bits;\n\t\tiowrite32be(new_mask2bits | tmp_val, &par_io->cpdir1);\n\t}\n\t \n\ttmp_val = (pin > (QE_PIO_PINS / 2) - 1) ?\n\t\tioread32be(&par_io->cppar2) :\n\t\tioread32be(&par_io->cppar1);\n\n\tnew_mask2bits = (u32) (assignment << (QE_PIO_PINS -\n\t\t\t(pin % (QE_PIO_PINS / 2) + 1) * 2));\n\t \n\tif (pin > (QE_PIO_PINS / 2) - 1) {\n\t\tiowrite32be(~pin_mask2bits & tmp_val, &par_io->cppar2);\n\t\ttmp_val &= ~pin_mask2bits;\n\t\tiowrite32be(new_mask2bits | tmp_val, &par_io->cppar2);\n\t} else {\n\t\tiowrite32be(~pin_mask2bits & tmp_val, &par_io->cppar1);\n\t\ttmp_val &= ~pin_mask2bits;\n\t\tiowrite32be(new_mask2bits | tmp_val, &par_io->cppar1);\n\t}\n}\nEXPORT_SYMBOL(__par_io_config_pin);\n\nint par_io_config_pin(u8 port, u8 pin, int dir, int open_drain,\n\t\t      int assignment, int has_irq)\n{\n\tif (!par_io || port >= num_par_io_ports)\n\t\treturn -EINVAL;\n\n\t__par_io_config_pin(&par_io[port], pin, dir, open_drain, assignment,\n\t\t\t    has_irq);\n\treturn 0;\n}\nEXPORT_SYMBOL(par_io_config_pin);\n\nint par_io_data_set(u8 port, u8 pin, u8 val)\n{\n\tu32 pin_mask, tmp_val;\n\n\tif (port >= num_par_io_ports)\n\t\treturn -EINVAL;\n\tif (pin >= QE_PIO_PINS)\n\t\treturn -EINVAL;\n\t \n\tpin_mask = (u32) (1 << (QE_PIO_PINS - 1 - pin));\n\n\ttmp_val = ioread32be(&par_io[port].cpdata);\n\n\tif (val == 0)\t\t \n\t\tiowrite32be(~pin_mask & tmp_val, &par_io[port].cpdata);\n\telse\t\t\t \n\t\tiowrite32be(pin_mask | tmp_val, &par_io[port].cpdata);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(par_io_data_set);\n\nint par_io_of_config(struct device_node *np)\n{\n\tstruct device_node *pio;\n\tint pio_map_len;\n\tconst __be32 *pio_map;\n\n\tif (par_io == NULL) {\n\t\tprintk(KERN_ERR \"par_io not initialized\\n\");\n\t\treturn -1;\n\t}\n\n\tpio = of_parse_phandle(np, \"pio-handle\", 0);\n\tif (pio == NULL) {\n\t\tprintk(KERN_ERR \"pio-handle not available\\n\");\n\t\treturn -1;\n\t}\n\n\tpio_map = of_get_property(pio, \"pio-map\", &pio_map_len);\n\tif (pio_map == NULL) {\n\t\tprintk(KERN_ERR \"pio-map is not set!\\n\");\n\t\treturn -1;\n\t}\n\tpio_map_len /= sizeof(unsigned int);\n\tif ((pio_map_len % 6) != 0) {\n\t\tprintk(KERN_ERR \"pio-map format wrong!\\n\");\n\t\treturn -1;\n\t}\n\n\twhile (pio_map_len > 0) {\n\t\tu8 port        = be32_to_cpu(pio_map[0]);\n\t\tu8 pin         = be32_to_cpu(pio_map[1]);\n\t\tint dir        = be32_to_cpu(pio_map[2]);\n\t\tint open_drain = be32_to_cpu(pio_map[3]);\n\t\tint assignment = be32_to_cpu(pio_map[4]);\n\t\tint has_irq    = be32_to_cpu(pio_map[5]);\n\n\t\tpar_io_config_pin(port, pin, dir, open_drain,\n\t\t\t\t  assignment, has_irq);\n\t\tpio_map += 6;\n\t\tpio_map_len -= 6;\n\t}\n\tof_node_put(pio);\n\treturn 0;\n}\nEXPORT_SYMBOL(par_io_of_config);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}