{
  "module_name": "qe_tdm.c",
  "hash_id": "73f9f7fc449e78e044c0ca696126bc7107039ec694ecabe22ad1374b9c432ebc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qe_tdm.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <soc/fsl/qe/qe_tdm.h>\n\nstatic int set_tdm_framer(const char *tdm_framer_type)\n{\n\tif (strcmp(tdm_framer_type, \"e1\") == 0)\n\t\treturn TDM_FRAMER_E1;\n\telse if (strcmp(tdm_framer_type, \"t1\") == 0)\n\t\treturn TDM_FRAMER_T1;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void set_si_param(struct ucc_tdm *utdm, struct ucc_tdm_info *ut_info)\n{\n\tstruct si_mode_info *si_info = &ut_info->si_info;\n\n\tif (utdm->tdm_mode == TDM_INTERNAL_LOOPBACK) {\n\t\tsi_info->simr_crt = 1;\n\t\tsi_info->simr_rfsd = 0;\n\t}\n}\n\nint ucc_of_parse_tdm(struct device_node *np, struct ucc_tdm *utdm,\n\t\t     struct ucc_tdm_info *ut_info)\n{\n\tconst char *sprop;\n\tint ret = 0;\n\tu32 val;\n\n\tsprop = of_get_property(np, \"fsl,rx-sync-clock\", NULL);\n\tif (sprop) {\n\t\tut_info->uf_info.rx_sync = qe_clock_source(sprop);\n\t\tif ((ut_info->uf_info.rx_sync < QE_CLK_NONE) ||\n\t\t    (ut_info->uf_info.rx_sync > QE_RSYNC_PIN)) {\n\t\t\tpr_err(\"QE-TDM: Invalid rx-sync-clock property\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"QE-TDM: Invalid rx-sync-clock property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsprop = of_get_property(np, \"fsl,tx-sync-clock\", NULL);\n\tif (sprop) {\n\t\tut_info->uf_info.tx_sync = qe_clock_source(sprop);\n\t\tif ((ut_info->uf_info.tx_sync < QE_CLK_NONE) ||\n\t\t    (ut_info->uf_info.tx_sync > QE_TSYNC_PIN)) {\n\t\t\tpr_err(\"QE-TDM: Invalid tx-sync-clock property\\n\");\n\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"QE-TDM: Invalid tx-sync-clock property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_index(np, \"fsl,tx-timeslot-mask\", 0, &val);\n\tif (ret) {\n\t\tpr_err(\"QE-TDM: Invalid tx-timeslot-mask property\\n\");\n\t\treturn -EINVAL;\n\t}\n\tutdm->tx_ts_mask = val;\n\n\tret = of_property_read_u32_index(np, \"fsl,rx-timeslot-mask\", 0, &val);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"QE-TDM: Invalid rx-timeslot-mask property\\n\");\n\t\treturn ret;\n\t}\n\tutdm->rx_ts_mask = val;\n\n\tret = of_property_read_u32_index(np, \"fsl,tdm-id\", 0, &val);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"QE-TDM: No fsl,tdm-id property for this UCC\\n\");\n\t\treturn ret;\n\t}\n\tutdm->tdm_port = val;\n\tut_info->uf_info.tdm_num = utdm->tdm_port;\n\n\tif (of_property_read_bool(np, \"fsl,tdm-internal-loopback\"))\n\t\tutdm->tdm_mode = TDM_INTERNAL_LOOPBACK;\n\telse\n\t\tutdm->tdm_mode = TDM_NORMAL;\n\n\tsprop = of_get_property(np, \"fsl,tdm-framer-type\", NULL);\n\tif (!sprop) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"QE-TDM: No tdm-framer-type property for UCC\\n\");\n\t\treturn ret;\n\t}\n\tret = set_tdm_framer(sprop);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tutdm->tdm_framer_type = ret;\n\n\tret = of_property_read_u32_index(np, \"fsl,siram-entry-id\", 0, &val);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"QE-TDM: No siram entry id for UCC\\n\");\n\t\treturn ret;\n\t}\n\tutdm->siram_entry_id = val;\n\n\tset_si_param(utdm, ut_info);\n\treturn ret;\n}\nEXPORT_SYMBOL(ucc_of_parse_tdm);\n\nvoid ucc_tdm_init(struct ucc_tdm *utdm, struct ucc_tdm_info *ut_info)\n{\n\tstruct si1 __iomem *si_regs;\n\tu16 __iomem *siram;\n\tu16 siram_entry_valid;\n\tu16 siram_entry_closed;\n\tu16 ucc_num;\n\tu8 csel;\n\tu16 sixmr;\n\tu16 tdm_port;\n\tu32 siram_entry_id;\n\tu32 mask;\n\tint i;\n\n\tsi_regs = utdm->si_regs;\n\tsiram = utdm->siram;\n\tucc_num = ut_info->uf_info.ucc_num;\n\ttdm_port = utdm->tdm_port;\n\tsiram_entry_id = utdm->siram_entry_id;\n\n\tif (utdm->tdm_framer_type == TDM_FRAMER_T1)\n\t\tutdm->num_of_ts = 24;\n\tif (utdm->tdm_framer_type == TDM_FRAMER_E1)\n\t\tutdm->num_of_ts = 32;\n\n\t \n\tcsel = (ucc_num < 4) ? ucc_num + 9 : ucc_num - 3;\n\n\tsiram_entry_valid = SIR_CSEL(csel) | SIR_BYTE | SIR_CNT(0);\n\tsiram_entry_closed = SIR_IDLE | SIR_BYTE | SIR_CNT(0);\n\n\tfor (i = 0; i < utdm->num_of_ts; i++) {\n\t\tmask = 0x01 << i;\n\n\t\tif (utdm->tx_ts_mask & mask)\n\t\t\tiowrite16be(siram_entry_valid,\n\t\t\t\t    &siram[siram_entry_id * 32 + i]);\n\t\telse\n\t\t\tiowrite16be(siram_entry_closed,\n\t\t\t\t    &siram[siram_entry_id * 32 + i]);\n\n\t\tif (utdm->rx_ts_mask & mask)\n\t\t\tiowrite16be(siram_entry_valid,\n\t\t\t\t    &siram[siram_entry_id * 32 + 0x200 +  i]);\n\t\telse\n\t\t\tiowrite16be(siram_entry_closed,\n\t\t\t\t    &siram[siram_entry_id * 32 + 0x200 +  i]);\n\t}\n\n\tqe_setbits_be16(&siram[(siram_entry_id * 32) + (utdm->num_of_ts - 1)],\n\t\t\tSIR_LAST);\n\tqe_setbits_be16(&siram[(siram_entry_id * 32) + 0x200 + (utdm->num_of_ts - 1)],\n\t\t\tSIR_LAST);\n\n\t \n\tsixmr = SIMR_SAD(siram_entry_id);\n\n\tsixmr &= ~SIMR_SDM_MASK;\n\n\tif (utdm->tdm_mode == TDM_INTERNAL_LOOPBACK)\n\t\tsixmr |= SIMR_SDM_INTERNAL_LOOPBACK;\n\telse\n\t\tsixmr |= SIMR_SDM_NORMAL;\n\n\tsixmr |= SIMR_RFSD(ut_info->si_info.simr_rfsd) |\n\t\t\tSIMR_TFSD(ut_info->si_info.simr_tfsd);\n\n\tif (ut_info->si_info.simr_crt)\n\t\tsixmr |= SIMR_CRT;\n\tif (ut_info->si_info.simr_sl)\n\t\tsixmr |= SIMR_SL;\n\tif (ut_info->si_info.simr_ce)\n\t\tsixmr |= SIMR_CE;\n\tif (ut_info->si_info.simr_fe)\n\t\tsixmr |= SIMR_FE;\n\tif (ut_info->si_info.simr_gm)\n\t\tsixmr |= SIMR_GM;\n\n\tswitch (tdm_port) {\n\tcase 0:\n\t\tiowrite16be(sixmr, &si_regs->sixmr1[0]);\n\t\tbreak;\n\tcase 1:\n\t\tiowrite16be(sixmr, &si_regs->sixmr1[1]);\n\t\tbreak;\n\tcase 2:\n\t\tiowrite16be(sixmr, &si_regs->sixmr1[2]);\n\t\tbreak;\n\tcase 3:\n\t\tiowrite16be(sixmr, &si_regs->sixmr1[3]);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"QE-TDM: can not find tdm sixmr reg\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(ucc_tdm_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}