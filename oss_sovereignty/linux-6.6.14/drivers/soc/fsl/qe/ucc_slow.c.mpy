{
  "module_name": "ucc_slow.c",
  "hash_id": "86528216afb9a38e8f025477d3aac0455c15a257898d396df74ffb199b817715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/ucc_slow.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/export.h>\n\n#include <asm/io.h>\n#include <soc/fsl/qe/immap_qe.h>\n#include <soc/fsl/qe/qe.h>\n\n#include <soc/fsl/qe/ucc.h>\n#include <soc/fsl/qe/ucc_slow.h>\n\nu32 ucc_slow_get_qe_cr_subblock(int uccs_num)\n{\n\tswitch (uccs_num) {\n\tcase 0: return QE_CR_SUBBLOCK_UCCSLOW1;\n\tcase 1: return QE_CR_SUBBLOCK_UCCSLOW2;\n\tcase 2: return QE_CR_SUBBLOCK_UCCSLOW3;\n\tcase 3: return QE_CR_SUBBLOCK_UCCSLOW4;\n\tcase 4: return QE_CR_SUBBLOCK_UCCSLOW5;\n\tcase 5: return QE_CR_SUBBLOCK_UCCSLOW6;\n\tcase 6: return QE_CR_SUBBLOCK_UCCSLOW7;\n\tcase 7: return QE_CR_SUBBLOCK_UCCSLOW8;\n\tdefault: return QE_CR_SUBBLOCK_INVALID;\n\t}\n}\nEXPORT_SYMBOL(ucc_slow_get_qe_cr_subblock);\n\nvoid ucc_slow_graceful_stop_tx(struct ucc_slow_private * uccs)\n{\n\tstruct ucc_slow_info *us_info = uccs->us_info;\n\tu32 id;\n\n\tid = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);\n\tqe_issue_cmd(QE_GRACEFUL_STOP_TX, id,\n\t\t\t QE_CR_PROTOCOL_UNSPECIFIED, 0);\n}\nEXPORT_SYMBOL(ucc_slow_graceful_stop_tx);\n\nvoid ucc_slow_stop_tx(struct ucc_slow_private * uccs)\n{\n\tstruct ucc_slow_info *us_info = uccs->us_info;\n\tu32 id;\n\n\tid = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);\n\tqe_issue_cmd(QE_STOP_TX, id, QE_CR_PROTOCOL_UNSPECIFIED, 0);\n}\nEXPORT_SYMBOL(ucc_slow_stop_tx);\n\nvoid ucc_slow_restart_tx(struct ucc_slow_private * uccs)\n{\n\tstruct ucc_slow_info *us_info = uccs->us_info;\n\tu32 id;\n\n\tid = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);\n\tqe_issue_cmd(QE_RESTART_TX, id, QE_CR_PROTOCOL_UNSPECIFIED, 0);\n}\nEXPORT_SYMBOL(ucc_slow_restart_tx);\n\nvoid ucc_slow_enable(struct ucc_slow_private * uccs, enum comm_dir mode)\n{\n\tstruct ucc_slow __iomem *us_regs;\n\tu32 gumr_l;\n\n\tus_regs = uccs->us_regs;\n\n\t \n\tgumr_l = ioread32be(&us_regs->gumr_l);\n\tif (mode & COMM_DIR_TX) {\n\t\tgumr_l |= UCC_SLOW_GUMR_L_ENT;\n\t\tuccs->enabled_tx = 1;\n\t}\n\tif (mode & COMM_DIR_RX) {\n\t\tgumr_l |= UCC_SLOW_GUMR_L_ENR;\n\t\tuccs->enabled_rx = 1;\n\t}\n\tiowrite32be(gumr_l, &us_regs->gumr_l);\n}\nEXPORT_SYMBOL(ucc_slow_enable);\n\nvoid ucc_slow_disable(struct ucc_slow_private * uccs, enum comm_dir mode)\n{\n\tstruct ucc_slow __iomem *us_regs;\n\tu32 gumr_l;\n\n\tus_regs = uccs->us_regs;\n\n\t \n\tgumr_l = ioread32be(&us_regs->gumr_l);\n\tif (mode & COMM_DIR_TX) {\n\t\tgumr_l &= ~UCC_SLOW_GUMR_L_ENT;\n\t\tuccs->enabled_tx = 0;\n\t}\n\tif (mode & COMM_DIR_RX) {\n\t\tgumr_l &= ~UCC_SLOW_GUMR_L_ENR;\n\t\tuccs->enabled_rx = 0;\n\t}\n\tiowrite32be(gumr_l, &us_regs->gumr_l);\n}\nEXPORT_SYMBOL(ucc_slow_disable);\n\n \nint ucc_slow_init(struct ucc_slow_info * us_info, struct ucc_slow_private ** uccs_ret)\n{\n\tstruct ucc_slow_private *uccs;\n\tu32 i;\n\tstruct ucc_slow __iomem *us_regs;\n\tu32 gumr;\n\tstruct qe_bd __iomem *bd;\n\tu32 id;\n\tu32 command;\n\tint ret = 0;\n\n\tif (!us_info)\n\t\treturn -EINVAL;\n\n\t \n\tif ((us_info->ucc_num < 0) || (us_info->ucc_num > UCC_MAX_NUM - 1)) {\n\t\tprintk(KERN_ERR \"%s: illegal UCC number\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((!us_info->rfw) &&\n\t\t(us_info->max_rx_buf_length & (UCC_SLOW_MRBLR_ALIGNMENT - 1))) {\n\t\tprintk(KERN_ERR \"max_rx_buf_length not aligned.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tuccs = kzalloc(sizeof(struct ucc_slow_private), GFP_KERNEL);\n\tif (!uccs) {\n\t\tprintk(KERN_ERR \"%s: Cannot allocate private data\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tuccs->rx_base_offset = -1;\n\tuccs->tx_base_offset = -1;\n\tuccs->us_pram_offset = -1;\n\n\t \n\tuccs->us_info = us_info;\n\t \n\tuccs->us_regs = ioremap(us_info->regs, sizeof(struct ucc_slow));\n\tif (uccs->us_regs == NULL) {\n\t\tprintk(KERN_ERR \"%s: Cannot map UCC registers\\n\", __func__);\n\t\tkfree(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\tus_regs = uccs->us_regs;\n\tuccs->p_ucce = &us_regs->ucce;\n\tuccs->p_uccm = &us_regs->uccm;\n\n\t \n\tuccs->us_pram_offset =\n\t\tqe_muram_alloc(UCC_SLOW_PRAM_SIZE, ALIGNMENT_OF_UCC_SLOW_PRAM);\n\tif (uccs->us_pram_offset < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate MURAM for PRAM\", __func__);\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\tid = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);\n\tqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, id, us_info->protocol,\n\t\t     uccs->us_pram_offset);\n\n\tuccs->us_pram = qe_muram_addr(uccs->us_pram_offset);\n\n\t \n\tret = ucc_set_type(us_info->ucc_num, UCC_SPEED_TYPE_SLOW);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: cannot set UCC type\", __func__);\n\t\tucc_slow_free(uccs);\n\t\treturn ret;\n\t}\n\n\tiowrite16be(us_info->max_rx_buf_length, &uccs->us_pram->mrblr);\n\n\tINIT_LIST_HEAD(&uccs->confQ);\n\n\t \n\tuccs->rx_base_offset =\n\t\tqe_muram_alloc(us_info->rx_bd_ring_len * sizeof(struct qe_bd),\n\t\t\t\tQE_ALIGNMENT_OF_BD);\n\tif (uccs->rx_base_offset < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate %u RX BDs\\n\", __func__,\n\t\t\tus_info->rx_bd_ring_len);\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\tuccs->tx_base_offset =\n\t\tqe_muram_alloc(us_info->tx_bd_ring_len * sizeof(struct qe_bd),\n\t\t\tQE_ALIGNMENT_OF_BD);\n\tif (uccs->tx_base_offset < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate TX BDs\", __func__);\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbd = uccs->confBd = uccs->tx_bd = qe_muram_addr(uccs->tx_base_offset);\n\tfor (i = 0; i < us_info->tx_bd_ring_len - 1; i++) {\n\t\t \n\t\tiowrite32be(0, &bd->buf);\n\t\t \n\t\tiowrite32be(0, (u32 __iomem *)bd);\n\t\tbd++;\n\t}\n\t \n\tiowrite32be(0, &bd->buf);\n\tiowrite32be(T_W, (u32 __iomem *)bd);\n\n\t \n\tbd = uccs->rx_bd = qe_muram_addr(uccs->rx_base_offset);\n\tfor (i = 0; i < us_info->rx_bd_ring_len - 1; i++) {\n\t\t \n\t\tiowrite32be(0, (u32 __iomem *)bd);\n\t\t \n\t\tiowrite32be(0, &bd->buf);\n\t\tbd++;\n\t}\n\t \n\tiowrite32be(R_W, (u32 __iomem *)bd);\n\tiowrite32be(0, &bd->buf);\n\n\t \n\t \n\tgumr = us_info->tcrc;\n\tif (us_info->cdp)\n\t\tgumr |= UCC_SLOW_GUMR_H_CDP;\n\tif (us_info->ctsp)\n\t\tgumr |= UCC_SLOW_GUMR_H_CTSP;\n\tif (us_info->cds)\n\t\tgumr |= UCC_SLOW_GUMR_H_CDS;\n\tif (us_info->ctss)\n\t\tgumr |= UCC_SLOW_GUMR_H_CTSS;\n\tif (us_info->tfl)\n\t\tgumr |= UCC_SLOW_GUMR_H_TFL;\n\tif (us_info->rfw)\n\t\tgumr |= UCC_SLOW_GUMR_H_RFW;\n\tif (us_info->txsy)\n\t\tgumr |= UCC_SLOW_GUMR_H_TXSY;\n\tif (us_info->rtsm)\n\t\tgumr |= UCC_SLOW_GUMR_H_RTSM;\n\tiowrite32be(gumr, &us_regs->gumr_h);\n\n\t \n\tgumr = (u32)us_info->tdcr | (u32)us_info->rdcr | (u32)us_info->tenc |\n\t       (u32)us_info->renc | (u32)us_info->diag | (u32)us_info->mode;\n\tif (us_info->tci)\n\t\tgumr |= UCC_SLOW_GUMR_L_TCI;\n\tif (us_info->rinv)\n\t\tgumr |= UCC_SLOW_GUMR_L_RINV;\n\tif (us_info->tinv)\n\t\tgumr |= UCC_SLOW_GUMR_L_TINV;\n\tif (us_info->tend)\n\t\tgumr |= UCC_SLOW_GUMR_L_TEND;\n\tiowrite32be(gumr, &us_regs->gumr_l);\n\n\t \n\n\t \n\t \n\tiowrite8(UCC_BMR_BO_BE, &uccs->us_pram->tbmr);\n\tiowrite8(UCC_BMR_BO_BE, &uccs->us_pram->rbmr);\n\n\t \n\tiowrite16be(uccs->rx_base_offset, &uccs->us_pram->rbase);\n\tiowrite16be(uccs->tx_base_offset, &uccs->us_pram->tbase);\n\n\t \n\t \n\tucc_set_qe_mux_grant(us_info->ucc_num, us_info->grant_support);\n\t \n\tucc_set_qe_mux_bkpt(us_info->ucc_num, us_info->brkpt_support);\n\t \n\tucc_set_qe_mux_tsa(us_info->ucc_num, us_info->tsa);\n\t \n\tif (!us_info->tsa) {\n\t\t \n\t\tif (ucc_set_qe_mux_rxtx(us_info->ucc_num, us_info->rx_clock,\n\t\t\t\t\tCOMM_DIR_RX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for RX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_slow_free(uccs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (ucc_set_qe_mux_rxtx(us_info->ucc_num, us_info->tx_clock,\n\t\t\t\t\tCOMM_DIR_TX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for TX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_slow_free(uccs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tiowrite16be(us_info->uccm_mask, &us_regs->uccm);\n\n\t \n\n\t \n\tiowrite16be(0xffff, &us_regs->ucce);\n\n\t \n\tif (us_info->init_tx && us_info->init_rx)\n\t\tcommand = QE_INIT_TX_RX;\n\telse if (us_info->init_tx)\n\t\tcommand = QE_INIT_TX;\n\telse\n\t\tcommand = QE_INIT_RX;\t \n\n\tqe_issue_cmd(command, id, us_info->protocol, 0);\n\n\t*uccs_ret = uccs;\n\treturn 0;\n}\nEXPORT_SYMBOL(ucc_slow_init);\n\nvoid ucc_slow_free(struct ucc_slow_private * uccs)\n{\n\tif (!uccs)\n\t\treturn;\n\n\tqe_muram_free(uccs->rx_base_offset);\n\tqe_muram_free(uccs->tx_base_offset);\n\tqe_muram_free(uccs->us_pram_offset);\n\n\tif (uccs->us_regs)\n\t\tiounmap(uccs->us_regs);\n\n\tkfree(uccs);\n}\nEXPORT_SYMBOL(ucc_slow_free);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}