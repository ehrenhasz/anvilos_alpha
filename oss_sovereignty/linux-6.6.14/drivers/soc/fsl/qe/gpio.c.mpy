{
  "module_name": "gpio.c",
  "hash_id": "af6661386e49b522e20fad6363c48718de262ecf5542db1c0b52f841e23b6849",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/gpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/gpio/legacy-of-mm-gpiochip.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/property.h>\n\n#include <soc/fsl/qe/qe.h>\n\nstruct qe_gpio_chip {\n\tstruct of_mm_gpio_chip mm_gc;\n\tspinlock_t lock;\n\n\t \n\tu32 cpdata;\n\n\t \n\tstruct qe_pio_regs saved_regs;\n};\n\nstatic void qe_gpio_save_regs(struct of_mm_gpio_chip *mm_gc)\n{\n\tstruct qe_gpio_chip *qe_gc =\n\t\tcontainer_of(mm_gc, struct qe_gpio_chip, mm_gc);\n\tstruct qe_pio_regs __iomem *regs = mm_gc->regs;\n\n\tqe_gc->cpdata = ioread32be(&regs->cpdata);\n\tqe_gc->saved_regs.cpdata = qe_gc->cpdata;\n\tqe_gc->saved_regs.cpdir1 = ioread32be(&regs->cpdir1);\n\tqe_gc->saved_regs.cpdir2 = ioread32be(&regs->cpdir2);\n\tqe_gc->saved_regs.cppar1 = ioread32be(&regs->cppar1);\n\tqe_gc->saved_regs.cppar2 = ioread32be(&regs->cppar2);\n\tqe_gc->saved_regs.cpodr = ioread32be(&regs->cpodr);\n}\n\nstatic int qe_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\n\tstruct qe_pio_regs __iomem *regs = mm_gc->regs;\n\tu32 pin_mask = 1 << (QE_PIO_PINS - 1 - gpio);\n\n\treturn !!(ioread32be(&regs->cpdata) & pin_mask);\n}\n\nstatic void qe_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\n\tstruct qe_gpio_chip *qe_gc = gpiochip_get_data(gc);\n\tstruct qe_pio_regs __iomem *regs = mm_gc->regs;\n\tunsigned long flags;\n\tu32 pin_mask = 1 << (QE_PIO_PINS - 1 - gpio);\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\tif (val)\n\t\tqe_gc->cpdata |= pin_mask;\n\telse\n\t\tqe_gc->cpdata &= ~pin_mask;\n\n\tiowrite32be(qe_gc->cpdata, &regs->cpdata);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n}\n\nstatic void qe_gpio_set_multiple(struct gpio_chip *gc,\n\t\t\t\t unsigned long *mask, unsigned long *bits)\n{\n\tstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\n\tstruct qe_gpio_chip *qe_gc = gpiochip_get_data(gc);\n\tstruct qe_pio_regs __iomem *regs = mm_gc->regs;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tif (*mask == 0)\n\t\t\tbreak;\n\t\tif (__test_and_clear_bit(i, mask)) {\n\t\t\tif (test_bit(i, bits))\n\t\t\t\tqe_gc->cpdata |= (1U << (QE_PIO_PINS - 1 - i));\n\t\t\telse\n\t\t\t\tqe_gc->cpdata &= ~(1U << (QE_PIO_PINS - 1 - i));\n\t\t}\n\t}\n\n\tiowrite32be(qe_gc->cpdata, &regs->cpdata);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n}\n\nstatic int qe_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\n\tstruct qe_gpio_chip *qe_gc = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\t__par_io_config_pin(mm_gc->regs, gpio, QE_PIO_DIR_IN, 0, 0, 0);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int qe_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\n{\n\tstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\n\tstruct qe_gpio_chip *qe_gc = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tqe_gpio_set(gc, gpio, val);\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\t__par_io_config_pin(mm_gc->regs, gpio, QE_PIO_DIR_OUT, 0, 0, 0);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n\n\treturn 0;\n}\n\nstruct qe_pin {\n\t \n\tstruct qe_gpio_chip *controller;\n\tint num;\n};\n\n \nstruct qe_pin *qe_pin_request(struct device *dev, int index)\n{\n\tstruct qe_pin *qe_pin;\n\tstruct gpio_chip *gc;\n\tstruct gpio_desc *gpiod;\n\tint gpio_num;\n\tint err;\n\n\tqe_pin = kzalloc(sizeof(*qe_pin), GFP_KERNEL);\n\tif (!qe_pin) {\n\t\tdev_dbg(dev, \"%s: can't allocate memory\\n\", __func__);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tgpiod = gpiod_get_index(dev, NULL, index,\n\t\t\t        GPIOD_ASIS | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\terr = PTR_ERR_OR_ZERO(gpiod);\n\tif (err)\n\t\tgoto err0;\n\n\tgc = gpiod_to_chip(gpiod);\n\tgpio_num = desc_to_gpio(gpiod);\n\t \n\tgpiod_put(gpiod);\n\n\tif (WARN_ON(!gc)) {\n\t\terr = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tqe_pin->controller = gpiochip_get_data(gc);\n\t \n\tqe_pin->num = gpio_num - gc->base;\n\n\tif (!fwnode_device_is_compatible(gc->fwnode, \"fsl,mpc8323-qe-pario-bank\")) {\n\t\tdev_dbg(dev, \"%s: tried to get a non-qe pin\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto err0;\n\t}\n\treturn qe_pin;\nerr0:\n\tkfree(qe_pin);\n\tdev_dbg(dev, \"%s failed with status %d\\n\", __func__, err);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(qe_pin_request);\n\n \nvoid qe_pin_free(struct qe_pin *qe_pin)\n{\n\tkfree(qe_pin);\n}\nEXPORT_SYMBOL(qe_pin_free);\n\n \nvoid qe_pin_set_dedicated(struct qe_pin *qe_pin)\n{\n\tstruct qe_gpio_chip *qe_gc = qe_pin->controller;\n\tstruct qe_pio_regs __iomem *regs = qe_gc->mm_gc.regs;\n\tstruct qe_pio_regs *sregs = &qe_gc->saved_regs;\n\tint pin = qe_pin->num;\n\tu32 mask1 = 1 << (QE_PIO_PINS - (pin + 1));\n\tu32 mask2 = 0x3 << (QE_PIO_PINS - (pin % (QE_PIO_PINS / 2) + 1) * 2);\n\tbool second_reg = pin > (QE_PIO_PINS / 2) - 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\tif (second_reg) {\n\t\tqe_clrsetbits_be32(&regs->cpdir2, mask2,\n\t\t\t\t   sregs->cpdir2 & mask2);\n\t\tqe_clrsetbits_be32(&regs->cppar2, mask2,\n\t\t\t\t   sregs->cppar2 & mask2);\n\t} else {\n\t\tqe_clrsetbits_be32(&regs->cpdir1, mask2,\n\t\t\t\t   sregs->cpdir1 & mask2);\n\t\tqe_clrsetbits_be32(&regs->cppar1, mask2,\n\t\t\t\t   sregs->cppar1 & mask2);\n\t}\n\n\tif (sregs->cpdata & mask1)\n\t\tqe_gc->cpdata |= mask1;\n\telse\n\t\tqe_gc->cpdata &= ~mask1;\n\n\tiowrite32be(qe_gc->cpdata, &regs->cpdata);\n\tqe_clrsetbits_be32(&regs->cpodr, mask1, sregs->cpodr & mask1);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n}\nEXPORT_SYMBOL(qe_pin_set_dedicated);\n\n \nvoid qe_pin_set_gpio(struct qe_pin *qe_pin)\n{\n\tstruct qe_gpio_chip *qe_gc = qe_pin->controller;\n\tstruct qe_pio_regs __iomem *regs = qe_gc->mm_gc.regs;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qe_gc->lock, flags);\n\n\t \n\t__par_io_config_pin(regs, qe_pin->num, QE_PIO_DIR_IN, 0, 0, 0);\n\n\tspin_unlock_irqrestore(&qe_gc->lock, flags);\n}\nEXPORT_SYMBOL(qe_pin_set_gpio);\n\nstatic int __init qe_add_gpiochips(void)\n{\n\tstruct device_node *np;\n\n\tfor_each_compatible_node(np, NULL, \"fsl,mpc8323-qe-pario-bank\") {\n\t\tint ret;\n\t\tstruct qe_gpio_chip *qe_gc;\n\t\tstruct of_mm_gpio_chip *mm_gc;\n\t\tstruct gpio_chip *gc;\n\n\t\tqe_gc = kzalloc(sizeof(*qe_gc), GFP_KERNEL);\n\t\tif (!qe_gc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_init(&qe_gc->lock);\n\n\t\tmm_gc = &qe_gc->mm_gc;\n\t\tgc = &mm_gc->gc;\n\n\t\tmm_gc->save_regs = qe_gpio_save_regs;\n\t\tgc->ngpio = QE_PIO_PINS;\n\t\tgc->direction_input = qe_gpio_dir_in;\n\t\tgc->direction_output = qe_gpio_dir_out;\n\t\tgc->get = qe_gpio_get;\n\t\tgc->set = qe_gpio_set;\n\t\tgc->set_multiple = qe_gpio_set_multiple;\n\n\t\tret = of_mm_gpiochip_add_data(np, mm_gc, qe_gc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tcontinue;\nerr:\n\t\tpr_err(\"%pOF: registration failed with status %d\\n\",\n\t\t       np, ret);\n\t\tkfree(qe_gc);\n\t\t \n\t}\n\treturn 0;\n}\narch_initcall(qe_add_gpiochips);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}