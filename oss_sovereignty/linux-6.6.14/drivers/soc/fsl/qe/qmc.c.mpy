{
  "module_name": "qmc.c",
  "hash_id": "9909366eba674ef454a975edc4e41d586313987412726c3639c49c8d5cc97af5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qmc.c",
  "human_readable_source": "\n \n\n#include <soc/fsl/qe/qmc.h>\n#include <linux/dma-mapping.h>\n#include <linux/hdlc.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <soc/fsl/cpm.h>\n#include <sysdev/fsl_soc.h>\n#include \"tsa.h\"\n\n \n#define SCC_GSMRL\t0x00\n#define SCC_GSMRL_ENR\t\t(1 << 5)\n#define SCC_GSMRL_ENT\t\t(1 << 4)\n#define SCC_GSMRL_MODE_QMC\t(0x0A << 0)\n\n \n#define SCC_GSMRH\t0x04\n#define   SCC_GSMRH_CTSS\t(1 << 7)\n#define   SCC_GSMRH_CDS\t\t(1 << 8)\n#define   SCC_GSMRH_CTSP\t(1 << 9)\n#define   SCC_GSMRH_CDP\t\t(1 << 10)\n\n \n#define SCC_SCCE\t0x10\n#define   SCC_SCCE_IQOV\t\t(1 << 3)\n#define   SCC_SCCE_GINT\t\t(1 << 2)\n#define   SCC_SCCE_GUN\t\t(1 << 1)\n#define   SCC_SCCE_GOV\t\t(1 << 0)\n\n \n#define SCC_SCCM\t0x14\n \n#define QMC_GBL_MCBASE\t\t0x00\n \n#define QMC_GBL_QMCSTATE\t0x04\n \n#define QMC_GBL_MRBLR\t\t0x06\n \n#define QMC_GBL_TX_S_PTR\t0x08\n \n#define QMC_GBL_RXPTR\t\t0x0A\n \n#define QMC_GBL_GRFTHR\t\t0x0C\n \n#define QMC_GBL_GRFCNT\t\t0x0E\n \n#define QMC_GBL_INTBASE\t\t0x10\n \n#define QMC_GBL_INTPTR\t\t0x14\n \n#define QMC_GBL_RX_S_PTR\t0x18\n \n#define QMC_GBL_TXPTR\t\t0x1A\n \n#define QMC_GBL_C_MASK32\t0x1C\n \n#define QMC_GBL_TSATRX\t\t0x20\n \n#define QMC_GBL_TSATTX\t\t0x60\n \n#define QMC_GBL_C_MASK16\t0xA0\n\n \n#define QMC_TSA_VALID\t\t(1 << 15)\n#define QMC_TSA_WRAP\t\t(1 << 14)\n#define QMC_TSA_MASK\t\t(0x303F)\n#define QMC_TSA_CHANNEL(x)\t((x) << 6)\n\n \n#define QMC_SPE_TBASE\t0x00\n\n \n#define QMC_SPE_CHAMR\t0x02\n#define   QMC_SPE_CHAMR_MODE_HDLC\t(1 << 15)\n#define   QMC_SPE_CHAMR_MODE_TRANSP\t((0 << 15) | (1 << 13))\n#define   QMC_SPE_CHAMR_ENT\t\t(1 << 12)\n#define   QMC_SPE_CHAMR_POL\t\t(1 << 8)\n#define   QMC_SPE_CHAMR_HDLC_IDLM\t(1 << 13)\n#define   QMC_SPE_CHAMR_HDLC_CRC\t(1 << 7)\n#define   QMC_SPE_CHAMR_HDLC_NOF\t(0x0f << 0)\n#define   QMC_SPE_CHAMR_TRANSP_RD\t(1 << 14)\n#define   QMC_SPE_CHAMR_TRANSP_SYNC\t(1 << 10)\n\n \n#define QMC_SPE_TSTATE\t0x04\n \n#define QMC_SPE_TBPTR\t0x0C\n \n#define QMC_SPE_ZISTATE\t0x14\n \n#define QMC_SPE_INTMSK\t0x1C\n \n#define QMC_SPE_RBASE\t0x20\n \n#define QMC_SPE_MFLR\t0x22\n \n#define QMC_SPE_TMRBLR\t0x22\n \n#define QMC_SPE_RSTATE\t0x24\n \n#define QMC_SPE_RBPTR\t0x2C\n \n#define QMC_SPE_RPACK\t0x30\n \n#define QMC_SPE_ZDSTATE\t0x34\n\n \n#define QMC_SPE_TRNSYNC 0x3C\n#define   QMC_SPE_TRNSYNC_RX(x)\t((x) << 8)\n#define   QMC_SPE_TRNSYNC_TX(x)\t((x) << 0)\n\n \n#define QMC_INT_V\t\t(1 << 15)\n#define QMC_INT_W\t\t(1 << 14)\n#define QMC_INT_NID\t\t(1 << 13)\n#define QMC_INT_IDL\t\t(1 << 12)\n#define QMC_INT_GET_CHANNEL(x)\t(((x) & 0x0FC0) >> 6)\n#define QMC_INT_MRF\t\t(1 << 5)\n#define QMC_INT_UN\t\t(1 << 4)\n#define QMC_INT_RXF\t\t(1 << 3)\n#define QMC_INT_BSY\t\t(1 << 2)\n#define QMC_INT_TXB\t\t(1 << 1)\n#define QMC_INT_RXB\t\t(1 << 0)\n\n \n#define QMC_BD_RX_E\t(1 << 15)\n#define QMC_BD_RX_W\t(1 << 13)\n#define QMC_BD_RX_I\t(1 << 12)\n#define QMC_BD_RX_L\t(1 << 11)\n#define QMC_BD_RX_F\t(1 << 10)\n#define QMC_BD_RX_CM\t(1 << 9)\n#define QMC_BD_RX_UB\t(1 << 7)\n#define QMC_BD_RX_LG\t(1 << 5)\n#define QMC_BD_RX_NO\t(1 << 4)\n#define QMC_BD_RX_AB\t(1 << 3)\n#define QMC_BD_RX_CR\t(1 << 2)\n\n#define QMC_BD_TX_R\t(1 << 15)\n#define QMC_BD_TX_W\t(1 << 13)\n#define QMC_BD_TX_I\t(1 << 12)\n#define QMC_BD_TX_L\t(1 << 11)\n#define QMC_BD_TX_TC\t(1 << 10)\n#define QMC_BD_TX_CM\t(1 << 9)\n#define QMC_BD_TX_UB\t(1 << 7)\n#define QMC_BD_TX_PAD\t(0x0f << 0)\n\n \n#define QMC_NB_TXBDS\t8\n#define QMC_NB_RXBDS\t8\n#define QMC_NB_INTS\t128\n\nstruct qmc_xfer_desc {\n\tunion {\n\t\tvoid (*tx_complete)(void *context);\n\t\tvoid (*rx_complete)(void *context, size_t length);\n\t};\n\tvoid *context;\n};\n\nstruct qmc_chan {\n\tstruct list_head list;\n\tunsigned int id;\n\tstruct qmc *qmc;\n\tvoid *__iomem s_param;\n\tenum qmc_mode mode;\n\tu64\ttx_ts_mask;\n\tu64\trx_ts_mask;\n\tbool is_reverse_data;\n\n\tspinlock_t\ttx_lock;\n\tcbd_t __iomem *txbds;\n\tcbd_t __iomem *txbd_free;\n\tcbd_t __iomem *txbd_done;\n\tstruct qmc_xfer_desc tx_desc[QMC_NB_TXBDS];\n\tu64\tnb_tx_underrun;\n\tbool\tis_tx_stopped;\n\n\tspinlock_t\trx_lock;\n\tcbd_t __iomem *rxbds;\n\tcbd_t __iomem *rxbd_free;\n\tcbd_t __iomem *rxbd_done;\n\tstruct qmc_xfer_desc rx_desc[QMC_NB_RXBDS];\n\tu64\tnb_rx_busy;\n\tint\trx_pending;\n\tbool\tis_rx_halted;\n\tbool\tis_rx_stopped;\n};\n\nstruct qmc {\n\tstruct device *dev;\n\tstruct tsa_serial *tsa_serial;\n\tvoid *__iomem scc_regs;\n\tvoid *__iomem scc_pram;\n\tvoid *__iomem dpram;\n\tu16 scc_pram_offset;\n\tcbd_t __iomem *bd_table;\n\tdma_addr_t bd_dma_addr;\n\tsize_t bd_size;\n\tu16 __iomem *int_table;\n\tu16 __iomem *int_curr;\n\tdma_addr_t int_dma_addr;\n\tsize_t int_size;\n\tstruct list_head chan_head;\n\tstruct qmc_chan *chans[64];\n};\n\nstatic inline void qmc_write16(void *__iomem addr, u16 val)\n{\n\tiowrite16be(val, addr);\n}\n\nstatic inline u16 qmc_read16(void *__iomem addr)\n{\n\treturn ioread16be(addr);\n}\n\nstatic inline void qmc_setbits16(void *__iomem addr, u16 set)\n{\n\tqmc_write16(addr, qmc_read16(addr) | set);\n}\n\nstatic inline void qmc_clrbits16(void *__iomem addr, u16 clr)\n{\n\tqmc_write16(addr, qmc_read16(addr) & ~clr);\n}\n\nstatic inline void qmc_write32(void *__iomem addr, u32 val)\n{\n\tiowrite32be(val, addr);\n}\n\nstatic inline u32 qmc_read32(void *__iomem addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic inline void qmc_setbits32(void *__iomem addr, u32 set)\n{\n\tqmc_write32(addr, qmc_read32(addr) | set);\n}\n\n\nint qmc_chan_get_info(struct qmc_chan *chan, struct qmc_chan_info *info)\n{\n\tstruct tsa_serial_info tsa_info;\n\tint ret;\n\n\t \n\tret = tsa_serial_get_info(chan->qmc->tsa_serial, &tsa_info);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->mode = chan->mode;\n\tinfo->rx_fs_rate = tsa_info.rx_fs_rate;\n\tinfo->rx_bit_rate = tsa_info.rx_bit_rate;\n\tinfo->nb_tx_ts = hweight64(chan->tx_ts_mask);\n\tinfo->tx_fs_rate = tsa_info.tx_fs_rate;\n\tinfo->tx_bit_rate = tsa_info.tx_bit_rate;\n\tinfo->nb_rx_ts = hweight64(chan->rx_ts_mask);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmc_chan_get_info);\n\nint qmc_chan_set_param(struct qmc_chan *chan, const struct qmc_chan_param *param)\n{\n\tif (param->mode != chan->mode)\n\t\treturn -EINVAL;\n\n\tswitch (param->mode) {\n\tcase QMC_HDLC:\n\t\tif ((param->hdlc.max_rx_buf_size % 4) ||\n\t\t    (param->hdlc.max_rx_buf_size < 8))\n\t\t\treturn -EINVAL;\n\n\t\tqmc_write16(chan->qmc->scc_pram + QMC_GBL_MRBLR,\n\t\t\t    param->hdlc.max_rx_buf_size - 8);\n\t\tqmc_write16(chan->s_param + QMC_SPE_MFLR,\n\t\t\t    param->hdlc.max_rx_frame_size);\n\t\tif (param->hdlc.is_crc32) {\n\t\t\tqmc_setbits16(chan->s_param + QMC_SPE_CHAMR,\n\t\t\t\t      QMC_SPE_CHAMR_HDLC_CRC);\n\t\t} else {\n\t\t\tqmc_clrbits16(chan->s_param + QMC_SPE_CHAMR,\n\t\t\t\t      QMC_SPE_CHAMR_HDLC_CRC);\n\t\t}\n\t\tbreak;\n\n\tcase QMC_TRANSPARENT:\n\t\tqmc_write16(chan->s_param + QMC_SPE_TMRBLR,\n\t\t\t    param->transp.max_rx_buf_size);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmc_chan_set_param);\n\nint qmc_chan_write_submit(struct qmc_chan *chan, dma_addr_t addr, size_t length,\n\t\t\t  void (*complete)(void *context), void *context)\n{\n\tstruct qmc_xfer_desc *xfer_desc;\n\tunsigned long flags;\n\tcbd_t *__iomem bd;\n\tu16 ctrl;\n\tint ret;\n\n\t \n\n\tspin_lock_irqsave(&chan->tx_lock, flags);\n\tbd = chan->txbd_free;\n\n\tctrl = qmc_read16(&bd->cbd_sc);\n\tif (ctrl & (QMC_BD_TX_R | QMC_BD_TX_UB)) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tqmc_write16(&bd->cbd_datlen, length);\n\tqmc_write32(&bd->cbd_bufaddr, addr);\n\n\txfer_desc = &chan->tx_desc[bd - chan->txbds];\n\txfer_desc->tx_complete = complete;\n\txfer_desc->context = context;\n\n\t \n\tctrl |= (QMC_BD_TX_R | QMC_BD_TX_UB);\n\twmb();  \n\tqmc_write16(&bd->cbd_sc, ctrl);\n\n\tif (!chan->is_tx_stopped)\n\t\tqmc_setbits16(chan->s_param + QMC_SPE_CHAMR, QMC_SPE_CHAMR_POL);\n\n\tif (ctrl & QMC_BD_TX_W)\n\t\tchan->txbd_free = chan->txbds;\n\telse\n\t\tchan->txbd_free++;\n\n\tret = 0;\n\nend:\n\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(qmc_chan_write_submit);\n\nstatic void qmc_chan_write_done(struct qmc_chan *chan)\n{\n\tstruct qmc_xfer_desc *xfer_desc;\n\tvoid (*complete)(void *context);\n\tunsigned long flags;\n\tvoid *context;\n\tcbd_t *__iomem bd;\n\tu16 ctrl;\n\n\t \n\n\tspin_lock_irqsave(&chan->tx_lock, flags);\n\tbd = chan->txbd_done;\n\n\tctrl = qmc_read16(&bd->cbd_sc);\n\twhile (!(ctrl & QMC_BD_TX_R)) {\n\t\tif (!(ctrl & QMC_BD_TX_UB))\n\t\t\tgoto end;\n\n\t\txfer_desc = &chan->tx_desc[bd - chan->txbds];\n\t\tcomplete = xfer_desc->tx_complete;\n\t\tcontext = xfer_desc->context;\n\t\txfer_desc->tx_complete = NULL;\n\t\txfer_desc->context = NULL;\n\n\t\tqmc_write16(&bd->cbd_sc, ctrl & ~QMC_BD_TX_UB);\n\n\t\tif (ctrl & QMC_BD_TX_W)\n\t\t\tchan->txbd_done = chan->txbds;\n\t\telse\n\t\t\tchan->txbd_done++;\n\n\t\tif (complete) {\n\t\t\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n\t\t\tcomplete(context);\n\t\t\tspin_lock_irqsave(&chan->tx_lock, flags);\n\t\t}\n\n\t\tbd = chan->txbd_done;\n\t\tctrl = qmc_read16(&bd->cbd_sc);\n\t}\n\nend:\n\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n}\n\nint qmc_chan_read_submit(struct qmc_chan *chan, dma_addr_t addr, size_t length,\n\t\t\t void (*complete)(void *context, size_t length), void *context)\n{\n\tstruct qmc_xfer_desc *xfer_desc;\n\tunsigned long flags;\n\tcbd_t *__iomem bd;\n\tu16 ctrl;\n\tint ret;\n\n\t \n\n\tspin_lock_irqsave(&chan->rx_lock, flags);\n\tbd = chan->rxbd_free;\n\n\tctrl = qmc_read16(&bd->cbd_sc);\n\tif (ctrl & (QMC_BD_RX_E | QMC_BD_RX_UB)) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tqmc_write16(&bd->cbd_datlen, 0);  \n\tqmc_write32(&bd->cbd_bufaddr, addr);\n\n\txfer_desc = &chan->rx_desc[bd - chan->rxbds];\n\txfer_desc->rx_complete = complete;\n\txfer_desc->context = context;\n\n\t \n\tctrl |= (QMC_BD_RX_E | QMC_BD_RX_UB);\n\twmb();  \n\tqmc_write16(&bd->cbd_sc, ctrl);\n\n\t \n\tif (chan->is_rx_halted && !chan->is_rx_stopped) {\n\t\t \n\t\tif (chan->mode == QMC_TRANSPARENT)\n\t\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x18000080);\n\t\telse\n\t\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x00000080);\n\t\tqmc_write32(chan->s_param + QMC_SPE_RSTATE, 0x31000000);\n\t\tchan->is_rx_halted = false;\n\t}\n\tchan->rx_pending++;\n\n\tif (ctrl & QMC_BD_RX_W)\n\t\tchan->rxbd_free = chan->rxbds;\n\telse\n\t\tchan->rxbd_free++;\n\n\tret = 0;\nend:\n\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(qmc_chan_read_submit);\n\nstatic void qmc_chan_read_done(struct qmc_chan *chan)\n{\n\tvoid (*complete)(void *context, size_t size);\n\tstruct qmc_xfer_desc *xfer_desc;\n\tunsigned long flags;\n\tcbd_t *__iomem bd;\n\tvoid *context;\n\tu16 datalen;\n\tu16 ctrl;\n\n\t \n\n\tspin_lock_irqsave(&chan->rx_lock, flags);\n\tbd = chan->rxbd_done;\n\n\tctrl = qmc_read16(&bd->cbd_sc);\n\twhile (!(ctrl & QMC_BD_RX_E)) {\n\t\tif (!(ctrl & QMC_BD_RX_UB))\n\t\t\tgoto end;\n\n\t\txfer_desc = &chan->rx_desc[bd - chan->rxbds];\n\t\tcomplete = xfer_desc->rx_complete;\n\t\tcontext = xfer_desc->context;\n\t\txfer_desc->rx_complete = NULL;\n\t\txfer_desc->context = NULL;\n\n\t\tdatalen = qmc_read16(&bd->cbd_datlen);\n\t\tqmc_write16(&bd->cbd_sc, ctrl & ~QMC_BD_RX_UB);\n\n\t\tif (ctrl & QMC_BD_RX_W)\n\t\t\tchan->rxbd_done = chan->rxbds;\n\t\telse\n\t\t\tchan->rxbd_done++;\n\n\t\tchan->rx_pending--;\n\n\t\tif (complete) {\n\t\t\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n\t\t\tcomplete(context, datalen);\n\t\t\tspin_lock_irqsave(&chan->rx_lock, flags);\n\t\t}\n\n\t\tbd = chan->rxbd_done;\n\t\tctrl = qmc_read16(&bd->cbd_sc);\n\t}\n\nend:\n\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n}\n\nstatic int qmc_chan_command(struct qmc_chan *chan, u8 qmc_opcode)\n{\n\treturn cpm_command(chan->id << 2, (qmc_opcode << 4) | 0x0E);\n}\n\nstatic int qmc_chan_stop_rx(struct qmc_chan *chan)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&chan->rx_lock, flags);\n\n\t \n\tret = qmc_chan_command(chan, 0x0);\n\tif (ret) {\n\t\tdev_err(chan->qmc->dev, \"chan %u: Send STOP RECEIVE failed (%d)\\n\",\n\t\t\tchan->id, ret);\n\t\tgoto end;\n\t}\n\n\tchan->is_rx_stopped = true;\n\nend:\n\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n\treturn ret;\n}\n\nstatic int qmc_chan_stop_tx(struct qmc_chan *chan)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&chan->tx_lock, flags);\n\n\t \n\tret = qmc_chan_command(chan, 0x1);\n\tif (ret) {\n\t\tdev_err(chan->qmc->dev, \"chan %u: Send STOP TRANSMIT failed (%d)\\n\",\n\t\t\tchan->id, ret);\n\t\tgoto end;\n\t}\n\n\tchan->is_tx_stopped = true;\n\nend:\n\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n\treturn ret;\n}\n\nint qmc_chan_stop(struct qmc_chan *chan, int direction)\n{\n\tint ret;\n\n\tif (direction & QMC_CHAN_READ) {\n\t\tret = qmc_chan_stop_rx(chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (direction & QMC_CHAN_WRITE) {\n\t\tret = qmc_chan_stop_tx(chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmc_chan_stop);\n\nstatic void qmc_chan_start_rx(struct qmc_chan *chan)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->rx_lock, flags);\n\n\t \n\tif (chan->mode == QMC_TRANSPARENT)\n\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x18000080);\n\telse\n\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x00000080);\n\tqmc_write32(chan->s_param + QMC_SPE_RSTATE, 0x31000000);\n\tchan->is_rx_halted = false;\n\n\tchan->is_rx_stopped = false;\n\n\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n}\n\nstatic void qmc_chan_start_tx(struct qmc_chan *chan)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chan->tx_lock, flags);\n\n\t \n\tqmc_setbits16(chan->s_param + QMC_SPE_CHAMR, QMC_SPE_CHAMR_ENT);\n\n\t \n\tqmc_setbits16(chan->s_param + QMC_SPE_CHAMR, QMC_SPE_CHAMR_POL);\n\n\tchan->is_tx_stopped = false;\n\n\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n}\n\nint qmc_chan_start(struct qmc_chan *chan, int direction)\n{\n\tif (direction & QMC_CHAN_READ)\n\t\tqmc_chan_start_rx(chan);\n\n\tif (direction & QMC_CHAN_WRITE)\n\t\tqmc_chan_start_tx(chan);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmc_chan_start);\n\nstatic void qmc_chan_reset_rx(struct qmc_chan *chan)\n{\n\tstruct qmc_xfer_desc *xfer_desc;\n\tunsigned long flags;\n\tcbd_t *__iomem bd;\n\tu16 ctrl;\n\n\tspin_lock_irqsave(&chan->rx_lock, flags);\n\tbd = chan->rxbds;\n\tdo {\n\t\tctrl = qmc_read16(&bd->cbd_sc);\n\t\tqmc_write16(&bd->cbd_sc, ctrl & ~(QMC_BD_RX_UB | QMC_BD_RX_E));\n\n\t\txfer_desc = &chan->rx_desc[bd - chan->rxbds];\n\t\txfer_desc->rx_complete = NULL;\n\t\txfer_desc->context = NULL;\n\n\t\tbd++;\n\t} while (!(ctrl & QMC_BD_RX_W));\n\n\tchan->rxbd_free = chan->rxbds;\n\tchan->rxbd_done = chan->rxbds;\n\tqmc_write16(chan->s_param + QMC_SPE_RBPTR,\n\t\t    qmc_read16(chan->s_param + QMC_SPE_RBASE));\n\n\tchan->rx_pending = 0;\n\tchan->is_rx_stopped = false;\n\n\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n}\n\nstatic void qmc_chan_reset_tx(struct qmc_chan *chan)\n{\n\tstruct qmc_xfer_desc *xfer_desc;\n\tunsigned long flags;\n\tcbd_t *__iomem bd;\n\tu16 ctrl;\n\n\tspin_lock_irqsave(&chan->tx_lock, flags);\n\n\t \n\tqmc_clrbits16(chan->s_param + QMC_SPE_CHAMR, QMC_SPE_CHAMR_ENT);\n\n\tbd = chan->txbds;\n\tdo {\n\t\tctrl = qmc_read16(&bd->cbd_sc);\n\t\tqmc_write16(&bd->cbd_sc, ctrl & ~(QMC_BD_TX_UB | QMC_BD_TX_R));\n\n\t\txfer_desc = &chan->tx_desc[bd - chan->txbds];\n\t\txfer_desc->tx_complete = NULL;\n\t\txfer_desc->context = NULL;\n\n\t\tbd++;\n\t} while (!(ctrl & QMC_BD_TX_W));\n\n\tchan->txbd_free = chan->txbds;\n\tchan->txbd_done = chan->txbds;\n\tqmc_write16(chan->s_param + QMC_SPE_TBPTR,\n\t\t    qmc_read16(chan->s_param + QMC_SPE_TBASE));\n\n\t \n\tqmc_write32(chan->s_param + QMC_SPE_TSTATE, 0x30000000);\n\tqmc_write32(chan->s_param + QMC_SPE_ZISTATE, 0x00000100);\n\n\tspin_unlock_irqrestore(&chan->tx_lock, flags);\n}\n\nint qmc_chan_reset(struct qmc_chan *chan, int direction)\n{\n\tif (direction & QMC_CHAN_READ)\n\t\tqmc_chan_reset_rx(chan);\n\n\tif (direction & QMC_CHAN_WRITE)\n\t\tqmc_chan_reset_tx(chan);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qmc_chan_reset);\n\nstatic int qmc_check_chans(struct qmc *qmc)\n{\n\tstruct tsa_serial_info info;\n\tbool is_one_table = false;\n\tstruct qmc_chan *chan;\n\tu64 tx_ts_mask = 0;\n\tu64 rx_ts_mask = 0;\n\tu64 tx_ts_assigned_mask;\n\tu64 rx_ts_assigned_mask;\n\tint ret;\n\n\t \n\tret = tsa_serial_get_info(qmc->tsa_serial, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((info.nb_tx_ts > 64) || (info.nb_rx_ts > 64)) {\n\t\tdev_err(qmc->dev, \"Number of TSA Tx/Rx TS assigned not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((info.nb_tx_ts > 32) || (info.nb_rx_ts > 32)) {\n\t\tif (info.nb_tx_ts != info.nb_rx_ts) {\n\t\t\tdev_err(qmc->dev, \"Number of TSA Tx/Rx TS assigned are not equal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tis_one_table = true;\n\t}\n\n\ttx_ts_assigned_mask = info.nb_tx_ts == 64 ? U64_MAX : (((u64)1) << info.nb_tx_ts) - 1;\n\trx_ts_assigned_mask = info.nb_rx_ts == 64 ? U64_MAX : (((u64)1) << info.nb_rx_ts) - 1;\n\n\tlist_for_each_entry(chan, &qmc->chan_head, list) {\n\t\tif (chan->tx_ts_mask > tx_ts_assigned_mask) {\n\t\t\tdev_err(qmc->dev, \"chan %u uses TSA unassigned Tx TS\\n\", chan->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tx_ts_mask & chan->tx_ts_mask) {\n\t\t\tdev_err(qmc->dev, \"chan %u uses an already used Tx TS\\n\", chan->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (chan->rx_ts_mask > rx_ts_assigned_mask) {\n\t\t\tdev_err(qmc->dev, \"chan %u uses TSA unassigned Rx TS\\n\", chan->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rx_ts_mask & chan->rx_ts_mask) {\n\t\t\tdev_err(qmc->dev, \"chan %u uses an already used Rx TS\\n\", chan->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_one_table && (chan->tx_ts_mask != chan->rx_ts_mask)) {\n\t\t\tdev_err(qmc->dev, \"chan %u uses different Rx and Tx TS\\n\", chan->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttx_ts_mask |= chan->tx_ts_mask;\n\t\trx_ts_mask |= chan->rx_ts_mask;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int qmc_nb_chans(struct qmc *qmc)\n{\n\tunsigned int count = 0;\n\tstruct qmc_chan *chan;\n\n\tlist_for_each_entry(chan, &qmc->chan_head, list)\n\t\tcount++;\n\n\treturn count;\n}\n\nstatic int qmc_of_parse_chans(struct qmc *qmc, struct device_node *np)\n{\n\tstruct device_node *chan_np;\n\tstruct qmc_chan *chan;\n\tconst char *mode;\n\tu32 chan_id;\n\tu64 ts_mask;\n\tint ret;\n\n\tfor_each_available_child_of_node(np, chan_np) {\n\t\tret = of_property_read_u32(chan_np, \"reg\", &chan_id);\n\t\tif (ret) {\n\t\t\tdev_err(qmc->dev, \"%pOF: failed to read reg\\n\", chan_np);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn ret;\n\t\t}\n\t\tif (chan_id > 63) {\n\t\t\tdev_err(qmc->dev, \"%pOF: Invalid chan_id\\n\", chan_np);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchan = devm_kzalloc(qmc->dev, sizeof(*chan), GFP_KERNEL);\n\t\tif (!chan) {\n\t\t\tof_node_put(chan_np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tchan->id = chan_id;\n\t\tspin_lock_init(&chan->rx_lock);\n\t\tspin_lock_init(&chan->tx_lock);\n\n\t\tret = of_property_read_u64(chan_np, \"fsl,tx-ts-mask\", &ts_mask);\n\t\tif (ret) {\n\t\t\tdev_err(qmc->dev, \"%pOF: failed to read fsl,tx-ts-mask\\n\",\n\t\t\t\tchan_np);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn ret;\n\t\t}\n\t\tchan->tx_ts_mask = ts_mask;\n\n\t\tret = of_property_read_u64(chan_np, \"fsl,rx-ts-mask\", &ts_mask);\n\t\tif (ret) {\n\t\t\tdev_err(qmc->dev, \"%pOF: failed to read fsl,rx-ts-mask\\n\",\n\t\t\t\tchan_np);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn ret;\n\t\t}\n\t\tchan->rx_ts_mask = ts_mask;\n\n\t\tmode = \"transparent\";\n\t\tret = of_property_read_string(chan_np, \"fsl,operational-mode\", &mode);\n\t\tif (ret && ret != -EINVAL) {\n\t\t\tdev_err(qmc->dev, \"%pOF: failed to read fsl,operational-mode\\n\",\n\t\t\t\tchan_np);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!strcmp(mode, \"transparent\")) {\n\t\t\tchan->mode = QMC_TRANSPARENT;\n\t\t} else if (!strcmp(mode, \"hdlc\")) {\n\t\t\tchan->mode = QMC_HDLC;\n\t\t} else {\n\t\t\tdev_err(qmc->dev, \"%pOF: Invalid fsl,operational-mode (%s)\\n\",\n\t\t\t\tchan_np, mode);\n\t\t\tof_node_put(chan_np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchan->is_reverse_data = of_property_read_bool(chan_np,\n\t\t\t\t\t\t\t      \"fsl,reverse-data\");\n\n\t\tlist_add_tail(&chan->list, &qmc->chan_head);\n\t\tqmc->chans[chan->id] = chan;\n\t}\n\n\treturn qmc_check_chans(qmc);\n}\n\nstatic int qmc_setup_tsa_64rxtx(struct qmc *qmc, const struct tsa_serial_info *info)\n{\n\tstruct qmc_chan *chan;\n\tunsigned int i;\n\tu16 val;\n\n\t \n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATRX + (i * 2), 0x0000);\n\n\t \n\tlist_for_each_entry(chan, &qmc->chan_head, list) {\n\t\tfor (i = 0; i < info->nb_rx_ts; i++) {\n\t\t\tif (!(chan->rx_ts_mask & (((u64)1) << i)))\n\t\t\t\tcontinue;\n\n\t\t\tval = QMC_TSA_VALID | QMC_TSA_MASK |\n\t\t\t      QMC_TSA_CHANNEL(chan->id);\n\t\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATRX + (i * 2), val);\n\t\t}\n\t}\n\n\t \n\tqmc_setbits16(qmc->scc_pram + QMC_GBL_TSATRX + ((info->nb_rx_ts - 1) * 2),\n\t\t      QMC_TSA_WRAP);\n\n\t \n\tval = qmc->scc_pram_offset + QMC_GBL_TSATRX;\n\tqmc_write16(qmc->scc_pram + QMC_GBL_RX_S_PTR, val);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_RXPTR, val);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_TX_S_PTR, val);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_TXPTR, val);\n\n\treturn 0;\n}\n\nstatic int qmc_setup_tsa_32rx_32tx(struct qmc *qmc, const struct tsa_serial_info *info)\n{\n\tstruct qmc_chan *chan;\n\tunsigned int i;\n\tu16 val;\n\n\t \n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATRX + (i * 2), 0x0000);\n\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATTX + (i * 2), 0x0000);\n\t}\n\n\t \n\tlist_for_each_entry(chan, &qmc->chan_head, list) {\n\t\t \n\t\tfor (i = 0; i < info->nb_rx_ts; i++) {\n\t\t\tif (!(chan->rx_ts_mask & (((u64)1) << i)))\n\t\t\t\tcontinue;\n\n\t\t\tval = QMC_TSA_VALID | QMC_TSA_MASK |\n\t\t\t      QMC_TSA_CHANNEL(chan->id);\n\t\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATRX + (i * 2), val);\n\t\t}\n\t\t \n\t\tfor (i = 0; i < info->nb_tx_ts; i++) {\n\t\t\tif (!(chan->tx_ts_mask & (((u64)1) << i)))\n\t\t\t\tcontinue;\n\n\t\t\tval = QMC_TSA_VALID | QMC_TSA_MASK |\n\t\t\t      QMC_TSA_CHANNEL(chan->id);\n\t\t\tqmc_write16(qmc->scc_pram + QMC_GBL_TSATTX + (i * 2), val);\n\t\t}\n\t}\n\n\t \n\tqmc_setbits16(qmc->scc_pram + QMC_GBL_TSATRX + ((info->nb_rx_ts - 1) * 2),\n\t\t      QMC_TSA_WRAP);\n\tqmc_setbits16(qmc->scc_pram + QMC_GBL_TSATTX + ((info->nb_tx_ts - 1) * 2),\n\t\t      QMC_TSA_WRAP);\n\n\t \n\tval = qmc->scc_pram_offset + QMC_GBL_TSATRX;\n\tqmc_write16(qmc->scc_pram + QMC_GBL_RX_S_PTR, val);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_RXPTR, val);\n\n\t \n\tval = qmc->scc_pram_offset + QMC_GBL_TSATTX;\n\tqmc_write16(qmc->scc_pram + QMC_GBL_TX_S_PTR, val);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_TXPTR, val);\n\n\treturn 0;\n}\n\nstatic int qmc_setup_tsa(struct qmc *qmc)\n{\n\tstruct tsa_serial_info info;\n\tint ret;\n\n\t \n\tret = tsa_serial_get_info(qmc->tsa_serial, &info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ((info.nb_tx_ts > 32) || (info.nb_rx_ts > 32)) ?\n\t\tqmc_setup_tsa_64rxtx(qmc, &info) :\n\t\tqmc_setup_tsa_32rx_32tx(qmc, &info);\n}\n\nstatic int qmc_setup_chan_trnsync(struct qmc *qmc, struct qmc_chan *chan)\n{\n\tstruct tsa_serial_info info;\n\tu16 first_rx, last_tx;\n\tu16 trnsync;\n\tint ret;\n\n\t \n\tret = tsa_serial_get_info(chan->qmc->tsa_serial, &info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfirst_rx = chan->rx_ts_mask ? __ffs64(chan->rx_ts_mask) + 1 : 0;\n\n\t \n\tlast_tx = fls64(chan->tx_ts_mask);\n\n\ttrnsync = 0;\n\tif (info.nb_rx_ts)\n\t\ttrnsync |= QMC_SPE_TRNSYNC_RX((first_rx % info.nb_rx_ts) * 2);\n\tif (info.nb_tx_ts)\n\t\ttrnsync |= QMC_SPE_TRNSYNC_TX((last_tx % info.nb_tx_ts) * 2);\n\n\tqmc_write16(chan->s_param + QMC_SPE_TRNSYNC, trnsync);\n\n\tdev_dbg(qmc->dev, \"chan %u: trnsync=0x%04x, rx %u/%u 0x%llx, tx %u/%u 0x%llx\\n\",\n\t\tchan->id, trnsync,\n\t\tfirst_rx, info.nb_rx_ts, chan->rx_ts_mask,\n\t\tlast_tx, info.nb_tx_ts, chan->tx_ts_mask);\n\n\treturn 0;\n}\n\nstatic int qmc_setup_chan(struct qmc *qmc, struct qmc_chan *chan)\n{\n\tunsigned int i;\n\tcbd_t __iomem *bd;\n\tint ret;\n\tu16 val;\n\n\tchan->qmc = qmc;\n\n\t \n\tchan->s_param = qmc->dpram + (chan->id * 64);\n\t \n\tchan->txbds = qmc->bd_table + (chan->id * (QMC_NB_TXBDS + QMC_NB_RXBDS));\n\tchan->rxbds = qmc->bd_table + (chan->id * (QMC_NB_TXBDS + QMC_NB_RXBDS)) + QMC_NB_TXBDS;\n\n\tchan->txbd_free = chan->txbds;\n\tchan->txbd_done = chan->txbds;\n\tchan->rxbd_free = chan->rxbds;\n\tchan->rxbd_done = chan->rxbds;\n\n\t \n\tval = chan->id * (QMC_NB_TXBDS + QMC_NB_RXBDS) * sizeof(cbd_t);\n\tqmc_write16(chan->s_param + QMC_SPE_TBASE, val);\n\tqmc_write16(chan->s_param + QMC_SPE_TBPTR, val);\n\n\t \n\tval = ((chan->id * (QMC_NB_TXBDS + QMC_NB_RXBDS)) + QMC_NB_TXBDS) * sizeof(cbd_t);\n\tqmc_write16(chan->s_param + QMC_SPE_RBASE, val);\n\tqmc_write16(chan->s_param + QMC_SPE_RBPTR, val);\n\tqmc_write32(chan->s_param + QMC_SPE_TSTATE, 0x30000000);\n\tqmc_write32(chan->s_param + QMC_SPE_RSTATE, 0x31000000);\n\tqmc_write32(chan->s_param + QMC_SPE_ZISTATE, 0x00000100);\n\tif (chan->mode == QMC_TRANSPARENT) {\n\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x18000080);\n\t\tqmc_write16(chan->s_param + QMC_SPE_TMRBLR, 60);\n\t\tval = QMC_SPE_CHAMR_MODE_TRANSP | QMC_SPE_CHAMR_TRANSP_SYNC;\n\t\tif (chan->is_reverse_data)\n\t\t\tval |= QMC_SPE_CHAMR_TRANSP_RD;\n\t\tqmc_write16(chan->s_param + QMC_SPE_CHAMR, val);\n\t\tret = qmc_setup_chan_trnsync(qmc, chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x00000080);\n\t\tqmc_write16(chan->s_param + QMC_SPE_MFLR, 60);\n\t\tqmc_write16(chan->s_param + QMC_SPE_CHAMR,\n\t\t\tQMC_SPE_CHAMR_MODE_HDLC | QMC_SPE_CHAMR_HDLC_IDLM);\n\t}\n\n\t \n\tqmc_write16(chan->s_param + QMC_SPE_INTMSK, 0x0000);\n\n\t \n\tBUILD_BUG_ON(QMC_NB_RXBDS == 0);\n\tval = QMC_BD_RX_I;\n\tfor (i = 0; i < QMC_NB_RXBDS; i++) {\n\t\tbd = chan->rxbds + i;\n\t\tqmc_write16(&bd->cbd_sc, val);\n\t}\n\tbd = chan->rxbds + QMC_NB_RXBDS - 1;\n\tqmc_write16(&bd->cbd_sc, val | QMC_BD_RX_W);\n\n\t \n\tBUILD_BUG_ON(QMC_NB_TXBDS == 0);\n\tval = QMC_BD_TX_I;\n\tif (chan->mode == QMC_HDLC)\n\t\tval |= QMC_BD_TX_L | QMC_BD_TX_TC;\n\tfor (i = 0; i < QMC_NB_TXBDS; i++) {\n\t\tbd = chan->txbds + i;\n\t\tqmc_write16(&bd->cbd_sc, val);\n\t}\n\tbd = chan->txbds + QMC_NB_TXBDS - 1;\n\tqmc_write16(&bd->cbd_sc, val | QMC_BD_TX_W);\n\n\treturn 0;\n}\n\nstatic int qmc_setup_chans(struct qmc *qmc)\n{\n\tstruct qmc_chan *chan;\n\tint ret;\n\n\tlist_for_each_entry(chan, &qmc->chan_head, list) {\n\t\tret = qmc_setup_chan(qmc, chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qmc_finalize_chans(struct qmc *qmc)\n{\n\tstruct qmc_chan *chan;\n\tint ret;\n\n\tlist_for_each_entry(chan, &qmc->chan_head, list) {\n\t\t \n\t\tif (chan->mode == QMC_HDLC) {\n\t\t\tqmc_write16(chan->s_param + QMC_SPE_INTMSK,\n\t\t\t\t    QMC_INT_NID | QMC_INT_IDL | QMC_INT_MRF |\n\t\t\t\t    QMC_INT_UN | QMC_INT_RXF | QMC_INT_BSY |\n\t\t\t\t    QMC_INT_TXB | QMC_INT_RXB);\n\t\t} else {\n\t\t\tqmc_write16(chan->s_param + QMC_SPE_INTMSK,\n\t\t\t\t    QMC_INT_UN | QMC_INT_BSY |\n\t\t\t\t    QMC_INT_TXB | QMC_INT_RXB);\n\t\t}\n\n\t\t \n\t\tret = qmc_chan_stop(chan, QMC_CHAN_ALL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qmc_setup_ints(struct qmc *qmc)\n{\n\tunsigned int i;\n\tu16 __iomem *last;\n\n\t \n\tfor (i = 0; i < (qmc->int_size / sizeof(u16)); i++)\n\t\tqmc_write16(qmc->int_table + i, 0x0000);\n\n\t \n\tif (qmc->int_size >= sizeof(u16)) {\n\t\tlast = qmc->int_table + (qmc->int_size / sizeof(u16)) - 1;\n\t\tqmc_write16(last, QMC_INT_W);\n\t}\n\n\treturn 0;\n}\n\nstatic void qmc_irq_gint(struct qmc *qmc)\n{\n\tstruct qmc_chan *chan;\n\tunsigned int chan_id;\n\tunsigned long flags;\n\tu16 int_entry;\n\n\tint_entry = qmc_read16(qmc->int_curr);\n\twhile (int_entry & QMC_INT_V) {\n\t\t \n\t\tqmc_write16(qmc->int_curr, int_entry & QMC_INT_W);\n\n\t\tchan_id = QMC_INT_GET_CHANNEL(int_entry);\n\t\tchan = qmc->chans[chan_id];\n\t\tif (!chan) {\n\t\t\tdev_err(qmc->dev, \"interrupt on invalid chan %u\\n\", chan_id);\n\t\t\tgoto int_next;\n\t\t}\n\n\t\tif (int_entry & QMC_INT_TXB)\n\t\t\tqmc_chan_write_done(chan);\n\n\t\tif (int_entry & QMC_INT_UN) {\n\t\t\tdev_info(qmc->dev, \"intr chan %u, 0x%04x (UN)\\n\", chan_id,\n\t\t\t\t int_entry);\n\t\t\tchan->nb_tx_underrun++;\n\t\t}\n\n\t\tif (int_entry & QMC_INT_BSY) {\n\t\t\tdev_info(qmc->dev, \"intr chan %u, 0x%04x (BSY)\\n\", chan_id,\n\t\t\t\t int_entry);\n\t\t\tchan->nb_rx_busy++;\n\t\t\t \n\t\t\tspin_lock_irqsave(&chan->rx_lock, flags);\n\t\t\tif (chan->rx_pending && !chan->is_rx_stopped) {\n\t\t\t\tif (chan->mode == QMC_TRANSPARENT)\n\t\t\t\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x18000080);\n\t\t\t\telse\n\t\t\t\t\tqmc_write32(chan->s_param + QMC_SPE_ZDSTATE, 0x00000080);\n\t\t\t\tqmc_write32(chan->s_param + QMC_SPE_RSTATE, 0x31000000);\n\t\t\t\tchan->is_rx_halted = false;\n\t\t\t} else {\n\t\t\t\tchan->is_rx_halted = true;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&chan->rx_lock, flags);\n\t\t}\n\n\t\tif (int_entry & QMC_INT_RXB)\n\t\t\tqmc_chan_read_done(chan);\n\nint_next:\n\t\tif (int_entry & QMC_INT_W)\n\t\t\tqmc->int_curr = qmc->int_table;\n\t\telse\n\t\t\tqmc->int_curr++;\n\t\tint_entry = qmc_read16(qmc->int_curr);\n\t}\n}\n\nstatic irqreturn_t qmc_irq_handler(int irq, void *priv)\n{\n\tstruct qmc *qmc = (struct qmc *)priv;\n\tu16 scce;\n\n\tscce = qmc_read16(qmc->scc_regs + SCC_SCCE);\n\tqmc_write16(qmc->scc_regs + SCC_SCCE, scce);\n\n\tif (unlikely(scce & SCC_SCCE_IQOV))\n\t\tdev_info(qmc->dev, \"IRQ queue overflow\\n\");\n\n\tif (unlikely(scce & SCC_SCCE_GUN))\n\t\tdev_err(qmc->dev, \"Global transmitter underrun\\n\");\n\n\tif (unlikely(scce & SCC_SCCE_GOV))\n\t\tdev_err(qmc->dev, \"Global receiver overrun\\n\");\n\n\t \n\tif (likely(scce & SCC_SCCE_GINT))\n\t\tqmc_irq_gint(qmc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qmc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tunsigned int nb_chans;\n\tstruct resource *res;\n\tstruct qmc *qmc;\n\tint irq;\n\tint ret;\n\n\tqmc = devm_kzalloc(&pdev->dev, sizeof(*qmc), GFP_KERNEL);\n\tif (!qmc)\n\t\treturn -ENOMEM;\n\n\tqmc->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&qmc->chan_head);\n\n\tqmc->scc_regs = devm_platform_ioremap_resource_byname(pdev, \"scc_regs\");\n\tif (IS_ERR(qmc->scc_regs))\n\t\treturn PTR_ERR(qmc->scc_regs);\n\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"scc_pram\");\n\tif (!res)\n\t\treturn -EINVAL;\n\tqmc->scc_pram_offset = res->start - get_immrbase();\n\tqmc->scc_pram = devm_ioremap_resource(qmc->dev, res);\n\tif (IS_ERR(qmc->scc_pram))\n\t\treturn PTR_ERR(qmc->scc_pram);\n\n\tqmc->dpram  = devm_platform_ioremap_resource_byname(pdev, \"dpram\");\n\tif (IS_ERR(qmc->dpram))\n\t\treturn PTR_ERR(qmc->dpram);\n\n\tqmc->tsa_serial = devm_tsa_serial_get_byphandle(qmc->dev, np, \"fsl,tsa-serial\");\n\tif (IS_ERR(qmc->tsa_serial)) {\n\t\treturn dev_err_probe(qmc->dev, PTR_ERR(qmc->tsa_serial),\n\t\t\t\t     \"Failed to get TSA serial\\n\");\n\t}\n\n\t \n\tret = tsa_serial_connect(qmc->tsa_serial);\n\tif (ret) {\n\t\tdev_err(qmc->dev, \"Failed to connect TSA serial\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = qmc_of_parse_chans(qmc, np);\n\tif (ret)\n\t\tgoto err_tsa_serial_disconnect;\n\n\tnb_chans = qmc_nb_chans(qmc);\n\n\t \n\tqmc_write32(qmc->scc_regs + SCC_GSMRH,\n\t\t    SCC_GSMRH_CDS | SCC_GSMRH_CTSS | SCC_GSMRH_CDP | SCC_GSMRH_CTSP);\n\n\t \n\tqmc_write32(qmc->scc_regs + SCC_GSMRL, SCC_GSMRL_MODE_QMC);\n\n\t \n\tqmc->bd_size = (nb_chans * (QMC_NB_TXBDS + QMC_NB_RXBDS)) * sizeof(cbd_t);\n\tqmc->bd_table = dmam_alloc_coherent(qmc->dev, qmc->bd_size,\n\t\t&qmc->bd_dma_addr, GFP_KERNEL);\n\tif (!qmc->bd_table) {\n\t\tdev_err(qmc->dev, \"Failed to allocate bd table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_tsa_serial_disconnect;\n\t}\n\tmemset(qmc->bd_table, 0, qmc->bd_size);\n\n\tqmc_write32(qmc->scc_pram + QMC_GBL_MCBASE, qmc->bd_dma_addr);\n\n\t \n\tqmc->int_size = QMC_NB_INTS * sizeof(u16);\n\tqmc->int_table = dmam_alloc_coherent(qmc->dev, qmc->int_size,\n\t\t&qmc->int_dma_addr, GFP_KERNEL);\n\tif (!qmc->int_table) {\n\t\tdev_err(qmc->dev, \"Failed to allocate interrupt table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_tsa_serial_disconnect;\n\t}\n\tmemset(qmc->int_table, 0, qmc->int_size);\n\n\tqmc->int_curr = qmc->int_table;\n\tqmc_write32(qmc->scc_pram + QMC_GBL_INTBASE, qmc->int_dma_addr);\n\tqmc_write32(qmc->scc_pram + QMC_GBL_INTPTR, qmc->int_dma_addr);\n\n\t \n\tqmc_write16(qmc->scc_pram + QMC_GBL_MRBLR, HDLC_MAX_MRU + 4);\n\n\tqmc_write16(qmc->scc_pram + QMC_GBL_GRFTHR, 1);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_GRFCNT, 1);\n\n\tqmc_write32(qmc->scc_pram + QMC_GBL_C_MASK32, 0xDEBB20E3);\n\tqmc_write16(qmc->scc_pram + QMC_GBL_C_MASK16, 0xF0B8);\n\n\tret = qmc_setup_tsa(qmc);\n\tif (ret)\n\t\tgoto err_tsa_serial_disconnect;\n\n\tqmc_write16(qmc->scc_pram + QMC_GBL_QMCSTATE, 0x8000);\n\n\tret = qmc_setup_chans(qmc);\n\tif (ret)\n\t\tgoto err_tsa_serial_disconnect;\n\n\t \n\tret = qmc_setup_ints(qmc);\n\tif (ret)\n\t\tgoto err_tsa_serial_disconnect;\n\n\t \n\tqmc_write16(qmc->scc_regs + SCC_SCCM, 0x0000);\n\tqmc_write16(qmc->scc_regs + SCC_SCCE, 0x000F);\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\tgoto err_tsa_serial_disconnect;\n\tret = devm_request_irq(qmc->dev, irq, qmc_irq_handler, 0, \"qmc\", qmc);\n\tif (ret < 0)\n\t\tgoto err_tsa_serial_disconnect;\n\n\t \n\tqmc_write16(qmc->scc_regs + SCC_SCCM,\n\t\tSCC_SCCE_IQOV | SCC_SCCE_GINT | SCC_SCCE_GUN | SCC_SCCE_GOV);\n\n\tret = qmc_finalize_chans(qmc);\n\tif (ret < 0)\n\t\tgoto err_disable_intr;\n\n\t \n\tqmc_setbits32(qmc->scc_regs + SCC_GSMRL, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\n\tplatform_set_drvdata(pdev, qmc);\n\n\treturn 0;\n\nerr_disable_intr:\n\tqmc_write16(qmc->scc_regs + SCC_SCCM, 0);\n\nerr_tsa_serial_disconnect:\n\ttsa_serial_disconnect(qmc->tsa_serial);\n\treturn ret;\n}\n\nstatic int qmc_remove(struct platform_device *pdev)\n{\n\tstruct qmc *qmc = platform_get_drvdata(pdev);\n\n\t \n\tqmc_setbits32(qmc->scc_regs + SCC_GSMRL, 0);\n\n\t \n\tqmc_write16(qmc->scc_regs + SCC_SCCM, 0);\n\n\t \n\ttsa_serial_disconnect(qmc->tsa_serial);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmc_id_table[] = {\n\t{ .compatible = \"fsl,cpm1-scc-qmc\" },\n\t{}  \n};\nMODULE_DEVICE_TABLE(of, qmc_id_table);\n\nstatic struct platform_driver qmc_driver = {\n\t.driver = {\n\t\t.name = \"fsl-qmc\",\n\t\t.of_match_table = of_match_ptr(qmc_id_table),\n\t},\n\t.probe = qmc_probe,\n\t.remove = qmc_remove,\n};\nmodule_platform_driver(qmc_driver);\n\nstruct qmc_chan *qmc_chan_get_byphandle(struct device_node *np, const char *phandle_name)\n{\n\tstruct of_phandle_args out_args;\n\tstruct platform_device *pdev;\n\tstruct qmc_chan *qmc_chan;\n\tstruct qmc *qmc;\n\tint ret;\n\n\tret = of_parse_phandle_with_fixed_args(np, phandle_name, 1, 0,\n\t\t\t\t\t       &out_args);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!of_match_node(qmc_driver.driver.of_match_table, out_args.np)) {\n\t\tof_node_put(out_args.np);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdev = of_find_device_by_node(out_args.np);\n\tof_node_put(out_args.np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tqmc = platform_get_drvdata(pdev);\n\tif (!qmc) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (out_args.args_count != 1) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (out_args.args[0] >= ARRAY_SIZE(qmc->chans)) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tqmc_chan = qmc->chans[out_args.args[0]];\n\tif (!qmc_chan) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn qmc_chan;\n}\nEXPORT_SYMBOL(qmc_chan_get_byphandle);\n\nvoid qmc_chan_put(struct qmc_chan *chan)\n{\n\tput_device(chan->qmc->dev);\n}\nEXPORT_SYMBOL(qmc_chan_put);\n\nstatic void devm_qmc_chan_release(struct device *dev, void *res)\n{\n\tstruct qmc_chan **qmc_chan = res;\n\n\tqmc_chan_put(*qmc_chan);\n}\n\nstruct qmc_chan *devm_qmc_chan_get_byphandle(struct device *dev,\n\t\t\t\t\t     struct device_node *np,\n\t\t\t\t\t     const char *phandle_name)\n{\n\tstruct qmc_chan *qmc_chan;\n\tstruct qmc_chan **dr;\n\n\tdr = devres_alloc(devm_qmc_chan_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqmc_chan = qmc_chan_get_byphandle(np, phandle_name);\n\tif (!IS_ERR(qmc_chan)) {\n\t\t*dr = qmc_chan;\n\t\tdevres_add(dev, dr);\n\t} else {\n\t\tdevres_free(dr);\n\t}\n\n\treturn qmc_chan;\n}\nEXPORT_SYMBOL(devm_qmc_chan_get_byphandle);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"CPM QMC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}