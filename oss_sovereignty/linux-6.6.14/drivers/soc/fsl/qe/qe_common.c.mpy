{
  "module_name": "qe_common.c",
  "hash_id": "9699b0ecc5234f72c8b80e4c998e19a91789a1b96200167d6ed5c59b975285ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/qe_common.c",
  "human_readable_source": "\n \n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <soc/fsl/qe/qe.h>\n\nstatic struct gen_pool *muram_pool;\nstatic DEFINE_SPINLOCK(cpm_muram_lock);\nstatic void __iomem *muram_vbase;\nstatic phys_addr_t muram_pbase;\n\nstruct muram_block {\n\tstruct list_head head;\n\ts32 start;\n\tint size;\n};\n\nstatic LIST_HEAD(muram_block_list);\n\n \n#define OF_MAX_ADDR_CELLS\t4\n#define GENPOOL_OFFSET\t\t(4096 * 8)\n\nint cpm_muram_init(void)\n{\n\tstruct device_node *np;\n\tstruct resource r;\n\t__be32 zero[OF_MAX_ADDR_CELLS] = {};\n\tresource_size_t max = 0;\n\tint i = 0;\n\tint ret = 0;\n\n\tif (muram_pbase)\n\t\treturn 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,cpm-muram-data\");\n\tif (!np) {\n\t\t \n\t\tnp = of_find_node_by_name(NULL, \"data-only\");\n\t\tif (!np) {\n\t\t\tpr_err(\"Cannot find CPM muram data node\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_muram;\n\t\t}\n\t}\n\n\tmuram_pool = gen_pool_create(0, -1);\n\tif (!muram_pool) {\n\t\tpr_err(\"Cannot allocate memory pool for CPM/QE muram\");\n\t\tret = -ENOMEM;\n\t\tgoto out_muram;\n\t}\n\tmuram_pbase = of_translate_address(np, zero);\n\tif (muram_pbase == (phys_addr_t)OF_BAD_ADDR) {\n\t\tpr_err(\"Cannot translate zero through CPM muram node\");\n\t\tret = -ENODEV;\n\t\tgoto out_pool;\n\t}\n\n\twhile (of_address_to_resource(np, i++, &r) == 0) {\n\t\tif (r.end > max)\n\t\t\tmax = r.end;\n\t\tret = gen_pool_add(muram_pool, r.start - muram_pbase +\n\t\t\t\t   GENPOOL_OFFSET, resource_size(&r), -1);\n\t\tif (ret) {\n\t\t\tpr_err(\"QE: couldn't add muram to pool!\\n\");\n\t\t\tgoto out_pool;\n\t\t}\n\t}\n\n\tmuram_vbase = ioremap(muram_pbase, max - muram_pbase + 1);\n\tif (!muram_vbase) {\n\t\tpr_err(\"Cannot map QE muram\");\n\t\tret = -ENOMEM;\n\t\tgoto out_pool;\n\t}\n\tgoto out_muram;\nout_pool:\n\tgen_pool_destroy(muram_pool);\nout_muram:\n\tof_node_put(np);\n\treturn ret;\n}\n\n \nstatic s32 cpm_muram_alloc_common(unsigned long size,\n\t\t\t\t  genpool_algo_t algo, void *data)\n{\n\tstruct muram_block *entry;\n\ts32 start;\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tstart = gen_pool_alloc_algo(muram_pool, size, algo, data);\n\tif (!start) {\n\t\tkfree(entry);\n\t\treturn -ENOMEM;\n\t}\n\tstart = start - GENPOOL_OFFSET;\n\tmemset_io(cpm_muram_addr(start), 0, size);\n\tentry->start = start;\n\tentry->size = size;\n\tlist_add(&entry->head, &muram_block_list);\n\n\treturn start;\n}\n\n \ns32 cpm_muram_alloc(unsigned long size, unsigned long align)\n{\n\ts32 start;\n\tunsigned long flags;\n\tstruct genpool_data_align muram_pool_data;\n\n\tspin_lock_irqsave(&cpm_muram_lock, flags);\n\tmuram_pool_data.align = align;\n\tstart = cpm_muram_alloc_common(size, gen_pool_first_fit_align,\n\t\t\t\t       &muram_pool_data);\n\tspin_unlock_irqrestore(&cpm_muram_lock, flags);\n\treturn start;\n}\nEXPORT_SYMBOL(cpm_muram_alloc);\n\n \nvoid cpm_muram_free(s32 offset)\n{\n\tunsigned long flags;\n\tint size;\n\tstruct muram_block *tmp;\n\n\tif (offset < 0)\n\t\treturn;\n\n\tsize = 0;\n\tspin_lock_irqsave(&cpm_muram_lock, flags);\n\tlist_for_each_entry(tmp, &muram_block_list, head) {\n\t\tif (tmp->start == offset) {\n\t\t\tsize = tmp->size;\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgen_pool_free(muram_pool, offset + GENPOOL_OFFSET, size);\n\tspin_unlock_irqrestore(&cpm_muram_lock, flags);\n}\nEXPORT_SYMBOL(cpm_muram_free);\n\n \ns32 cpm_muram_alloc_fixed(unsigned long offset, unsigned long size)\n{\n\ts32 start;\n\tunsigned long flags;\n\tstruct genpool_data_fixed muram_pool_data_fixed;\n\n\tspin_lock_irqsave(&cpm_muram_lock, flags);\n\tmuram_pool_data_fixed.offset = offset + GENPOOL_OFFSET;\n\tstart = cpm_muram_alloc_common(size, gen_pool_fixed_alloc,\n\t\t\t\t       &muram_pool_data_fixed);\n\tspin_unlock_irqrestore(&cpm_muram_lock, flags);\n\treturn start;\n}\nEXPORT_SYMBOL(cpm_muram_alloc_fixed);\n\n \nvoid __iomem *cpm_muram_addr(unsigned long offset)\n{\n\treturn muram_vbase + offset;\n}\nEXPORT_SYMBOL(cpm_muram_addr);\n\nunsigned long cpm_muram_offset(const void __iomem *addr)\n{\n\treturn addr - muram_vbase;\n}\nEXPORT_SYMBOL(cpm_muram_offset);\n\n \ndma_addr_t cpm_muram_dma(void __iomem *addr)\n{\n\treturn muram_pbase + (addr - muram_vbase);\n}\nEXPORT_SYMBOL(cpm_muram_dma);\n\n \nvoid cpm_muram_free_addr(const void __iomem *addr)\n{\n\tif (!addr)\n\t\treturn;\n\tcpm_muram_free(cpm_muram_offset(addr));\n}\nEXPORT_SYMBOL(cpm_muram_free_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}