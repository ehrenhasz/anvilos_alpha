{
  "module_name": "tsa.c",
  "hash_id": "0ff57d484a8eb15f3828617c36a478f84fb1a3e7515327d9886b9c328c68abd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/tsa.c",
  "human_readable_source": "\n \n\n#include \"tsa.h\"\n#include <dt-bindings/soc/cpm1-fsl,tsa.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n\n \n#define TSA_SIRAM_ENTRY_LAST\t\t(1 << 16)\n#define TSA_SIRAM_ENTRY_BYTE\t\t(1 << 17)\n#define TSA_SIRAM_ENTRY_CNT(x)\t\t(((x) & 0x0f) << 18)\n#define TSA_SIRAM_ENTRY_CSEL_MASK\t(0x7 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_NU\t\t(0x0 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_SCC2\t(0x2 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_SCC3\t(0x3 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_SCC4\t(0x4 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_SMC1\t(0x5 << 22)\n#define TSA_SIRAM_ENTRY_CSEL_SMC2\t(0x6 << 22)\n\n \n#define TSA_SIMODE\t0x00\n#define   TSA_SIMODE_SMC2\t\t\t0x80000000\n#define   TSA_SIMODE_SMC1\t\t\t0x00008000\n#define   TSA_SIMODE_TDMA(x)\t\t\t((x) << 0)\n#define   TSA_SIMODE_TDMB(x)\t\t\t((x) << 16)\n#define     TSA_SIMODE_TDM_MASK\t\t\t0x0fff\n#define     TSA_SIMODE_TDM_SDM_MASK\t\t0x0c00\n#define       TSA_SIMODE_TDM_SDM_NORM\t\t0x0000\n#define       TSA_SIMODE_TDM_SDM_ECHO\t\t0x0400\n#define       TSA_SIMODE_TDM_SDM_INTL_LOOP\t0x0800\n#define       TSA_SIMODE_TDM_SDM_LOOP_CTRL\t0x0c00\n#define     TSA_SIMODE_TDM_RFSD(x)\t\t((x) << 8)\n#define     TSA_SIMODE_TDM_DSC\t\t\t0x0080\n#define     TSA_SIMODE_TDM_CRT\t\t\t0x0040\n#define     TSA_SIMODE_TDM_STZ\t\t\t0x0020\n#define     TSA_SIMODE_TDM_CE\t\t\t0x0010\n#define     TSA_SIMODE_TDM_FE\t\t\t0x0008\n#define     TSA_SIMODE_TDM_GM\t\t\t0x0004\n#define     TSA_SIMODE_TDM_TFSD(x)\t\t((x) << 0)\n\n \n#define TSA_SIGMR\t0x04\n#define TSA_SIGMR_ENB\t\t\t(1<<3)\n#define TSA_SIGMR_ENA\t\t\t(1<<2)\n#define TSA_SIGMR_RDM_MASK\t\t0x03\n#define   TSA_SIGMR_RDM_STATIC_TDMA\t0x00\n#define   TSA_SIGMR_RDM_DYN_TDMA\t0x01\n#define   TSA_SIGMR_RDM_STATIC_TDMAB\t0x02\n#define   TSA_SIGMR_RDM_DYN_TDMAB\t0x03\n\n \n#define TSA_SISTR\t0x06\n\n \n#define TSA_SICMR\t0x07\n\n \n#define TSA_SICR\t0x0C\n#define   TSA_SICR_SCC2(x)\t\t((x) << 8)\n#define   TSA_SICR_SCC3(x)\t\t((x) << 16)\n#define   TSA_SICR_SCC4(x)\t\t((x) << 24)\n#define     TSA_SICR_SCC_MASK\t\t0x0ff\n#define     TSA_SICR_SCC_GRX\t\t(1 << 7)\n#define     TSA_SICR_SCC_SCX_TSA\t(1 << 6)\n#define     TSA_SICR_SCC_RXCS_MASK\t(0x7 << 3)\n#define       TSA_SICR_SCC_RXCS_BRG1\t(0x0 << 3)\n#define       TSA_SICR_SCC_RXCS_BRG2\t(0x1 << 3)\n#define       TSA_SICR_SCC_RXCS_BRG3\t(0x2 << 3)\n#define       TSA_SICR_SCC_RXCS_BRG4\t(0x3 << 3)\n#define       TSA_SICR_SCC_RXCS_CLK15\t(0x4 << 3)\n#define       TSA_SICR_SCC_RXCS_CLK26\t(0x5 << 3)\n#define       TSA_SICR_SCC_RXCS_CLK37\t(0x6 << 3)\n#define       TSA_SICR_SCC_RXCS_CLK48\t(0x7 << 3)\n#define     TSA_SICR_SCC_TXCS_MASK\t(0x7 << 0)\n#define       TSA_SICR_SCC_TXCS_BRG1\t(0x0 << 0)\n#define       TSA_SICR_SCC_TXCS_BRG2\t(0x1 << 0)\n#define       TSA_SICR_SCC_TXCS_BRG3\t(0x2 << 0)\n#define       TSA_SICR_SCC_TXCS_BRG4\t(0x3 << 0)\n#define       TSA_SICR_SCC_TXCS_CLK15\t(0x4 << 0)\n#define       TSA_SICR_SCC_TXCS_CLK26\t(0x5 << 0)\n#define       TSA_SICR_SCC_TXCS_CLK37\t(0x6 << 0)\n#define       TSA_SICR_SCC_TXCS_CLK48\t(0x7 << 0)\n\n \n#define TSA_SIRP\t0x10\n\nstruct tsa_entries_area {\n\tvoid *__iomem entries_start;\n\tvoid *__iomem entries_next;\n\tvoid *__iomem last_entry;\n};\n\nstruct tsa_tdm {\n\tbool is_enable;\n\tstruct clk *l1rclk_clk;\n\tstruct clk *l1rsync_clk;\n\tstruct clk *l1tclk_clk;\n\tstruct clk *l1tsync_clk;\n\tu32 simode_tdm;\n};\n\n#define TSA_TDMA\t0\n#define TSA_TDMB\t1\n\nstruct tsa {\n\tstruct device *dev;\n\tvoid *__iomem si_regs;\n\tvoid *__iomem si_ram;\n\tresource_size_t si_ram_sz;\n\tspinlock_t\tlock;\n\tint tdms;  \n\tstruct tsa_tdm tdm[2];  \n\tstruct tsa_serial {\n\t\tunsigned int id;\n\t\tstruct tsa_serial_info info;\n\t} serials[6];\n};\n\nstatic inline struct tsa *tsa_serial_get_tsa(struct tsa_serial *tsa_serial)\n{\n\t \n\treturn container_of(tsa_serial, struct tsa, serials[tsa_serial->id]);\n}\n\nstatic inline void tsa_write32(void *__iomem addr, u32 val)\n{\n\tiowrite32be(val, addr);\n}\n\nstatic inline void tsa_write8(void *__iomem addr, u32 val)\n{\n\tiowrite8(val, addr);\n}\n\nstatic inline u32 tsa_read32(void *__iomem addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic inline void tsa_clrbits32(void *__iomem addr, u32 clr)\n{\n\ttsa_write32(addr, tsa_read32(addr) & ~clr);\n}\n\nstatic inline void tsa_clrsetbits32(void *__iomem addr, u32 clr, u32 set)\n{\n\ttsa_write32(addr, (tsa_read32(addr) & ~clr) | set);\n}\n\nint tsa_serial_connect(struct tsa_serial *tsa_serial)\n{\n\tstruct tsa *tsa = tsa_serial_get_tsa(tsa_serial);\n\tunsigned long flags;\n\tu32 clear;\n\tu32 set;\n\n\tswitch (tsa_serial->id) {\n\tcase FSL_CPM_TSA_SCC2:\n\t\tclear = TSA_SICR_SCC2(TSA_SICR_SCC_MASK);\n\t\tset = TSA_SICR_SCC2(TSA_SICR_SCC_SCX_TSA);\n\t\tbreak;\n\tcase FSL_CPM_TSA_SCC3:\n\t\tclear = TSA_SICR_SCC3(TSA_SICR_SCC_MASK);\n\t\tset = TSA_SICR_SCC3(TSA_SICR_SCC_SCX_TSA);\n\t\tbreak;\n\tcase FSL_CPM_TSA_SCC4:\n\t\tclear = TSA_SICR_SCC4(TSA_SICR_SCC_MASK);\n\t\tset = TSA_SICR_SCC4(TSA_SICR_SCC_SCX_TSA);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tsa->dev, \"Unsupported serial id %u\\n\", tsa_serial->id);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&tsa->lock, flags);\n\ttsa_clrsetbits32(tsa->si_regs + TSA_SICR, clear, set);\n\tspin_unlock_irqrestore(&tsa->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tsa_serial_connect);\n\nint tsa_serial_disconnect(struct tsa_serial *tsa_serial)\n{\n\tstruct tsa *tsa = tsa_serial_get_tsa(tsa_serial);\n\tunsigned long flags;\n\tu32 clear;\n\n\tswitch (tsa_serial->id) {\n\tcase FSL_CPM_TSA_SCC2:\n\t\tclear = TSA_SICR_SCC2(TSA_SICR_SCC_MASK);\n\t\tbreak;\n\tcase FSL_CPM_TSA_SCC3:\n\t\tclear = TSA_SICR_SCC3(TSA_SICR_SCC_MASK);\n\t\tbreak;\n\tcase FSL_CPM_TSA_SCC4:\n\t\tclear = TSA_SICR_SCC4(TSA_SICR_SCC_MASK);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tsa->dev, \"Unsupported serial id %u\\n\", tsa_serial->id);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&tsa->lock, flags);\n\ttsa_clrsetbits32(tsa->si_regs + TSA_SICR, clear, 0);\n\tspin_unlock_irqrestore(&tsa->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tsa_serial_disconnect);\n\nint tsa_serial_get_info(struct tsa_serial *tsa_serial, struct tsa_serial_info *info)\n{\n\tmemcpy(info, &tsa_serial->info, sizeof(*info));\n\treturn 0;\n}\nEXPORT_SYMBOL(tsa_serial_get_info);\n\nstatic void tsa_init_entries_area(struct tsa *tsa, struct tsa_entries_area *area,\n\t\t\t\t  u32 tdms, u32 tdm_id, bool is_rx)\n{\n\tresource_size_t quarter;\n\tresource_size_t half;\n\n\tquarter = tsa->si_ram_sz/4;\n\thalf = tsa->si_ram_sz/2;\n\n\tif (tdms == BIT(TSA_TDMA)) {\n\t\t \n\t\tif (is_rx) {\n\t\t\t \n\t\t\tarea->entries_start = tsa->si_ram;\n\t\t\tarea->entries_next = area->entries_start + half;\n\t\t\tarea->last_entry = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tarea->entries_start = tsa->si_ram + half;\n\t\t\tarea->entries_next = area->entries_start + half;\n\t\t\tarea->last_entry = NULL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (tdm_id == TSA_TDMA) {\n\t\t\tif (is_rx) {\n\t\t\t\t \n\t\t\t\tarea->entries_start = tsa->si_ram;\n\t\t\t\tarea->entries_next = area->entries_start + quarter;\n\t\t\t\tarea->last_entry = NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tarea->entries_start = tsa->si_ram + (2 * quarter);\n\t\t\t\tarea->entries_next = area->entries_start + quarter;\n\t\t\t\tarea->last_entry = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_rx) {\n\t\t\t\t \n\t\t\t\tarea->entries_start = tsa->si_ram + quarter;\n\t\t\t\tarea->entries_next = area->entries_start + quarter;\n\t\t\t\tarea->last_entry = NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tarea->entries_start = tsa->si_ram + (3 * quarter);\n\t\t\t\tarea->entries_next = area->entries_start + quarter;\n\t\t\t\tarea->last_entry = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char *tsa_serial_id2name(struct tsa *tsa, u32 serial_id)\n{\n\tswitch (serial_id) {\n\tcase FSL_CPM_TSA_NU:\treturn \"Not used\";\n\tcase FSL_CPM_TSA_SCC2:\treturn \"SCC2\";\n\tcase FSL_CPM_TSA_SCC3:\treturn \"SCC3\";\n\tcase FSL_CPM_TSA_SCC4:\treturn \"SCC4\";\n\tcase FSL_CPM_TSA_SMC1:\treturn \"SMC1\";\n\tcase FSL_CPM_TSA_SMC2:\treturn \"SMC2\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic u32 tsa_serial_id2csel(struct tsa *tsa, u32 serial_id)\n{\n\tswitch (serial_id) {\n\tcase FSL_CPM_TSA_SCC2:\treturn TSA_SIRAM_ENTRY_CSEL_SCC2;\n\tcase FSL_CPM_TSA_SCC3:\treturn TSA_SIRAM_ENTRY_CSEL_SCC3;\n\tcase FSL_CPM_TSA_SCC4:\treturn TSA_SIRAM_ENTRY_CSEL_SCC4;\n\tcase FSL_CPM_TSA_SMC1:\treturn TSA_SIRAM_ENTRY_CSEL_SMC1;\n\tcase FSL_CPM_TSA_SMC2:\treturn TSA_SIRAM_ENTRY_CSEL_SMC2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn TSA_SIRAM_ENTRY_CSEL_NU;\n}\n\nstatic int tsa_add_entry(struct tsa *tsa, struct tsa_entries_area *area,\n\t\t\t u32 count, u32 serial_id)\n{\n\tvoid *__iomem addr;\n\tu32 left;\n\tu32 val;\n\tu32 cnt;\n\tu32 nb;\n\n\taddr = area->last_entry ? area->last_entry + 4 : area->entries_start;\n\n\tnb = DIV_ROUND_UP(count, 8);\n\tif ((addr + (nb * 4)) > area->entries_next) {\n\t\tdev_err(tsa->dev, \"si ram area full\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (area->last_entry) {\n\t\t \n\t\ttsa_clrbits32(area->last_entry, TSA_SIRAM_ENTRY_LAST);\n\t}\n\n\tleft = count;\n\twhile (left) {\n\t\tval = TSA_SIRAM_ENTRY_BYTE | tsa_serial_id2csel(tsa, serial_id);\n\n\t\tif (left > 16) {\n\t\t\tcnt = 16;\n\t\t} else {\n\t\t\tcnt = left;\n\t\t\tval |= TSA_SIRAM_ENTRY_LAST;\n\t\t\tarea->last_entry = addr;\n\t\t}\n\t\tval |= TSA_SIRAM_ENTRY_CNT(cnt - 1);\n\n\t\ttsa_write32(addr, val);\n\t\taddr += 4;\n\t\tleft -= cnt;\n\t}\n\n\treturn 0;\n}\n\nstatic int tsa_of_parse_tdm_route(struct tsa *tsa, struct device_node *tdm_np,\n\t\t\t\t  u32 tdms, u32 tdm_id, bool is_rx)\n{\n\tstruct tsa_entries_area area;\n\tconst char *route_name;\n\tu32 serial_id;\n\tint len, i;\n\tu32 count;\n\tconst char *serial_name;\n\tstruct tsa_serial_info *serial_info;\n\tstruct tsa_tdm *tdm;\n\tint ret;\n\tu32 ts;\n\n\troute_name = is_rx ? \"fsl,rx-ts-routes\" : \"fsl,tx-ts-routes\";\n\n\tlen = of_property_count_u32_elems(tdm_np,  route_name);\n\tif (len < 0) {\n\t\tdev_err(tsa->dev, \"%pOF: failed to read %s\\n\", tdm_np, route_name);\n\t\treturn len;\n\t}\n\tif (len % 2 != 0) {\n\t\tdev_err(tsa->dev, \"%pOF: wrong %s format\\n\", tdm_np, route_name);\n\t\treturn -EINVAL;\n\t}\n\n\ttsa_init_entries_area(tsa, &area, tdms, tdm_id, is_rx);\n\tts = 0;\n\tfor (i = 0; i < len; i += 2) {\n\t\tof_property_read_u32_index(tdm_np, route_name, i, &count);\n\t\tof_property_read_u32_index(tdm_np, route_name, i + 1, &serial_id);\n\n\t\tif (serial_id >= ARRAY_SIZE(tsa->serials)) {\n\t\t\tdev_err(tsa->dev, \"%pOF: invalid serial id (%u)\\n\",\n\t\t\t\ttdm_np, serial_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tserial_name = tsa_serial_id2name(tsa, serial_id);\n\t\tif (!serial_name) {\n\t\t\tdev_err(tsa->dev, \"%pOF: unsupported serial id (%u)\\n\",\n\t\t\t\ttdm_np, serial_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(tsa->dev, \"tdm_id=%u, %s ts %u..%u -> %s\\n\",\n\t\t\ttdm_id, route_name, ts, ts+count-1, serial_name);\n\t\tts += count;\n\n\t\tret = tsa_add_entry(tsa, &area, count, serial_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tserial_info = &tsa->serials[serial_id].info;\n\t\ttdm = &tsa->tdm[tdm_id];\n\t\tif (is_rx) {\n\t\t\tserial_info->rx_fs_rate = clk_get_rate(tdm->l1rsync_clk);\n\t\t\tserial_info->rx_bit_rate = clk_get_rate(tdm->l1rclk_clk);\n\t\t\tserial_info->nb_rx_ts += count;\n\t\t} else {\n\t\t\tserial_info->tx_fs_rate = tdm->l1tsync_clk ?\n\t\t\t\tclk_get_rate(tdm->l1tsync_clk) :\n\t\t\t\tclk_get_rate(tdm->l1rsync_clk);\n\t\t\tserial_info->tx_bit_rate = tdm->l1tclk_clk ?\n\t\t\t\tclk_get_rate(tdm->l1tclk_clk) :\n\t\t\t\tclk_get_rate(tdm->l1rclk_clk);\n\t\t\tserial_info->nb_tx_ts += count;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline int tsa_of_parse_tdm_rx_route(struct tsa *tsa,\n\t\t\t\t\t    struct device_node *tdm_np,\n\t\t\t\t\t    u32 tdms, u32 tdm_id)\n{\n\treturn tsa_of_parse_tdm_route(tsa, tdm_np, tdms, tdm_id, true);\n}\n\nstatic inline int tsa_of_parse_tdm_tx_route(struct tsa *tsa,\n\t\t\t\t\t    struct device_node *tdm_np,\n\t\t\t\t\t    u32 tdms, u32 tdm_id)\n{\n\treturn tsa_of_parse_tdm_route(tsa, tdm_np, tdms, tdm_id, false);\n}\n\nstatic int tsa_of_parse_tdms(struct tsa *tsa, struct device_node *np)\n{\n\tstruct device_node *tdm_np;\n\tstruct tsa_tdm *tdm;\n\tstruct clk *clk;\n\tu32 tdm_id, val;\n\tint ret;\n\tint i;\n\n\ttsa->tdms = 0;\n\ttsa->tdm[0].is_enable = false;\n\ttsa->tdm[1].is_enable = false;\n\n\tfor_each_available_child_of_node(np, tdm_np) {\n\t\tret = of_property_read_u32(tdm_np, \"reg\", &tdm_id);\n\t\tif (ret) {\n\t\t\tdev_err(tsa->dev, \"%pOF: failed to read reg\\n\", tdm_np);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn ret;\n\t\t}\n\t\tswitch (tdm_id) {\n\t\tcase 0:\n\t\t\ttsa->tdms |= BIT(TSA_TDMA);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttsa->tdms |= BIT(TSA_TDMB);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(tsa->dev, \"%pOF: Invalid tdm_id (%u)\\n\", tdm_np,\n\t\t\t\ttdm_id);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor_each_available_child_of_node(np, tdm_np) {\n\t\tret = of_property_read_u32(tdm_np, \"reg\", &tdm_id);\n\t\tif (ret) {\n\t\t\tdev_err(tsa->dev, \"%pOF: failed to read reg\\n\", tdm_np);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttdm = &tsa->tdm[tdm_id];\n\t\ttdm->simode_tdm = TSA_SIMODE_TDM_SDM_NORM;\n\n\t\tval = 0;\n\t\tret = of_property_read_u32(tdm_np, \"fsl,rx-frame-sync-delay-bits\",\n\t\t\t\t\t   &val);\n\t\tif (ret && ret != -EINVAL) {\n\t\t\tdev_err(tsa->dev,\n\t\t\t\t\"%pOF: failed to read fsl,rx-frame-sync-delay-bits\\n\",\n\t\t\t\ttdm_np);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn ret;\n\t\t}\n\t\tif (val > 3) {\n\t\t\tdev_err(tsa->dev,\n\t\t\t\t\"%pOF: Invalid fsl,rx-frame-sync-delay-bits (%u)\\n\",\n\t\t\t\ttdm_np, val);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_RFSD(val);\n\n\t\tval = 0;\n\t\tret = of_property_read_u32(tdm_np, \"fsl,tx-frame-sync-delay-bits\",\n\t\t\t\t\t   &val);\n\t\tif (ret && ret != -EINVAL) {\n\t\t\tdev_err(tsa->dev,\n\t\t\t\t\"%pOF: failed to read fsl,tx-frame-sync-delay-bits\\n\",\n\t\t\t\ttdm_np);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn ret;\n\t\t}\n\t\tif (val > 3) {\n\t\t\tdev_err(tsa->dev,\n\t\t\t\t\"%pOF: Invalid fsl,tx-frame-sync-delay-bits (%u)\\n\",\n\t\t\t\ttdm_np, val);\n\t\t\tof_node_put(tdm_np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_TFSD(val);\n\n\t\tif (of_property_read_bool(tdm_np, \"fsl,common-rxtx-pins\"))\n\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_CRT;\n\n\t\tif (of_property_read_bool(tdm_np, \"fsl,clock-falling-edge\"))\n\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_CE;\n\n\t\tif (of_property_read_bool(tdm_np, \"fsl,fsync-rising-edge\"))\n\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_FE;\n\n\t\tif (of_property_read_bool(tdm_np, \"fsl,double-speed-clock\"))\n\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_DSC;\n\n\t\tclk = of_clk_get_by_name(tdm_np, \"l1rsync\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tclk_put(clk);\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\t\ttdm->l1rsync_clk = clk;\n\n\t\tclk = of_clk_get_by_name(tdm_np, \"l1rclk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tclk_put(clk);\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\t\ttdm->l1rclk_clk = clk;\n\n\t\tif (!(tdm->simode_tdm & TSA_SIMODE_TDM_CRT)) {\n\t\t\tclk = of_clk_get_by_name(tdm_np, \"l1tsync\");\n\t\t\tif (IS_ERR(clk)) {\n\t\t\t\tret = PTR_ERR(clk);\n\t\t\t\tof_node_put(tdm_np);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tret = clk_prepare_enable(clk);\n\t\t\tif (ret) {\n\t\t\t\tclk_put(clk);\n\t\t\t\tof_node_put(tdm_np);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\ttdm->l1tsync_clk = clk;\n\n\t\t\tclk = of_clk_get_by_name(tdm_np, \"l1tclk\");\n\t\t\tif (IS_ERR(clk)) {\n\t\t\t\tret = PTR_ERR(clk);\n\t\t\t\tof_node_put(tdm_np);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tret = clk_prepare_enable(clk);\n\t\t\tif (ret) {\n\t\t\t\tclk_put(clk);\n\t\t\t\tof_node_put(tdm_np);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\ttdm->l1tclk_clk = clk;\n\t\t}\n\n\t\tret = tsa_of_parse_tdm_rx_route(tsa, tdm_np, tsa->tdms, tdm_id);\n\t\tif (ret) {\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = tsa_of_parse_tdm_tx_route(tsa, tdm_np, tsa->tdms, tdm_id);\n\t\tif (ret) {\n\t\t\tof_node_put(tdm_np);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttdm->is_enable = true;\n\t}\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < 2; i++) {\n\t\tif (tsa->tdm[i].l1rsync_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rsync_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rsync_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1rclk_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rclk_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rclk_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1tsync_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rsync_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rsync_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1tclk_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rclk_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rclk_clk);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void tsa_init_si_ram(struct tsa *tsa)\n{\n\tresource_size_t i;\n\n\t \n\tfor (i = 0; i < tsa->si_ram_sz; i += 4)\n\t\ttsa_write32(tsa->si_ram + i, TSA_SIRAM_ENTRY_LAST);\n}\n\nstatic int tsa_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct tsa *tsa;\n\tunsigned int i;\n\tu32 val;\n\tint ret;\n\n\ttsa = devm_kzalloc(&pdev->dev, sizeof(*tsa), GFP_KERNEL);\n\tif (!tsa)\n\t\treturn -ENOMEM;\n\n\ttsa->dev = &pdev->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(tsa->serials); i++)\n\t\ttsa->serials[i].id = i;\n\n\tspin_lock_init(&tsa->lock);\n\n\ttsa->si_regs = devm_platform_ioremap_resource_byname(pdev, \"si_regs\");\n\tif (IS_ERR(tsa->si_regs))\n\t\treturn PTR_ERR(tsa->si_regs);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"si_ram\");\n\tif (!res) {\n\t\tdev_err(tsa->dev, \"si_ram resource missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttsa->si_ram_sz = resource_size(res);\n\ttsa->si_ram = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(tsa->si_ram))\n\t\treturn PTR_ERR(tsa->si_ram);\n\n\ttsa_init_si_ram(tsa);\n\n\tret = tsa_of_parse_tdms(tsa, np);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = 0;\n\tif (tsa->tdm[0].is_enable)\n\t\tval |= TSA_SIMODE_TDMA(tsa->tdm[0].simode_tdm);\n\tif (tsa->tdm[1].is_enable)\n\t\tval |= TSA_SIMODE_TDMB(tsa->tdm[1].simode_tdm);\n\n\ttsa_clrsetbits32(tsa->si_regs + TSA_SIMODE,\n\t\t\t TSA_SIMODE_TDMA(TSA_SIMODE_TDM_MASK) |\n\t\t\t TSA_SIMODE_TDMB(TSA_SIMODE_TDM_MASK),\n\t\t\t val);\n\n\t \n\tval = (tsa->tdms == BIT(TSA_TDMA)) ?\n\t\tTSA_SIGMR_RDM_STATIC_TDMA : TSA_SIGMR_RDM_STATIC_TDMAB;\n\tif (tsa->tdms & BIT(TSA_TDMA))\n\t\tval |= TSA_SIGMR_ENA;\n\tif (tsa->tdms & BIT(TSA_TDMB))\n\t\tval |= TSA_SIGMR_ENB;\n\ttsa_write8(tsa->si_regs + TSA_SIGMR, val);\n\n\tplatform_set_drvdata(pdev, tsa);\n\n\treturn 0;\n}\n\nstatic int tsa_remove(struct platform_device *pdev)\n{\n\tstruct tsa *tsa = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (tsa->tdm[i].l1rsync_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rsync_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rsync_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1rclk_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rclk_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rclk_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1tsync_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rsync_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rsync_clk);\n\t\t}\n\t\tif (tsa->tdm[i].l1tclk_clk) {\n\t\t\tclk_disable_unprepare(tsa->tdm[i].l1rclk_clk);\n\t\t\tclk_put(tsa->tdm[i].l1rclk_clk);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct of_device_id tsa_id_table[] = {\n\t{ .compatible = \"fsl,cpm1-tsa\" },\n\t{}  \n};\nMODULE_DEVICE_TABLE(of, tsa_id_table);\n\nstatic struct platform_driver tsa_driver = {\n\t.driver = {\n\t\t.name = \"fsl-tsa\",\n\t\t.of_match_table = of_match_ptr(tsa_id_table),\n\t},\n\t.probe = tsa_probe,\n\t.remove = tsa_remove,\n};\nmodule_platform_driver(tsa_driver);\n\nstruct tsa_serial *tsa_serial_get_byphandle(struct device_node *np,\n\t\t\t\t\t    const char *phandle_name)\n{\n\tstruct of_phandle_args out_args;\n\tstruct platform_device *pdev;\n\tstruct tsa_serial *tsa_serial;\n\tstruct tsa *tsa;\n\tint ret;\n\n\tret = of_parse_phandle_with_fixed_args(np, phandle_name, 1, 0, &out_args);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!of_match_node(tsa_driver.driver.of_match_table, out_args.np)) {\n\t\tof_node_put(out_args.np);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdev = of_find_device_by_node(out_args.np);\n\tof_node_put(out_args.np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttsa = platform_get_drvdata(pdev);\n\tif (!tsa) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (out_args.args_count != 1) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (out_args.args[0] >= ARRAY_SIZE(tsa->serials)) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttsa_serial = &tsa->serials[out_args.args[0]];\n\n\t \n\tif (WARN_ON(tsa_serial->id != out_args.args[0])) {\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn tsa_serial;\n}\nEXPORT_SYMBOL(tsa_serial_get_byphandle);\n\nvoid tsa_serial_put(struct tsa_serial *tsa_serial)\n{\n\tstruct tsa *tsa = tsa_serial_get_tsa(tsa_serial);\n\n\tput_device(tsa->dev);\n}\nEXPORT_SYMBOL(tsa_serial_put);\n\nstatic void devm_tsa_serial_release(struct device *dev, void *res)\n{\n\tstruct tsa_serial **tsa_serial = res;\n\n\ttsa_serial_put(*tsa_serial);\n}\n\nstruct tsa_serial *devm_tsa_serial_get_byphandle(struct device *dev,\n\t\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t\t const char *phandle_name)\n{\n\tstruct tsa_serial *tsa_serial;\n\tstruct tsa_serial **dr;\n\n\tdr = devres_alloc(devm_tsa_serial_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttsa_serial = tsa_serial_get_byphandle(np, phandle_name);\n\tif (!IS_ERR(tsa_serial)) {\n\t\t*dr = tsa_serial;\n\t\tdevres_add(dev, dr);\n\t} else {\n\t\tdevres_free(dr);\n\t}\n\n\treturn tsa_serial;\n}\nEXPORT_SYMBOL(devm_tsa_serial_get_byphandle);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"CPM TSA driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}