{
  "module_name": "ucc_fast.c",
  "hash_id": "809cd410ed79e70c7bd13a41d1ac1dcae997658074aab054e1174bdb5689a06d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qe/ucc_fast.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/export.h>\n\n#include <asm/io.h>\n#include <soc/fsl/qe/immap_qe.h>\n#include <soc/fsl/qe/qe.h>\n\n#include <soc/fsl/qe/ucc.h>\n#include <soc/fsl/qe/ucc_fast.h>\n\nvoid ucc_fast_dump_regs(struct ucc_fast_private * uccf)\n{\n\tprintk(KERN_INFO \"UCC%u Fast registers:\\n\", uccf->uf_info->ucc_num);\n\tprintk(KERN_INFO \"Base address: 0x%p\\n\", uccf->uf_regs);\n\n\tprintk(KERN_INFO \"gumr  : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->gumr, ioread32be(&uccf->uf_regs->gumr));\n\tprintk(KERN_INFO \"upsmr : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->upsmr, ioread32be(&uccf->uf_regs->upsmr));\n\tprintk(KERN_INFO \"utodr : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->utodr, ioread16be(&uccf->uf_regs->utodr));\n\tprintk(KERN_INFO \"udsr  : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->udsr, ioread16be(&uccf->uf_regs->udsr));\n\tprintk(KERN_INFO \"ucce  : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->ucce, ioread32be(&uccf->uf_regs->ucce));\n\tprintk(KERN_INFO \"uccm  : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->uccm, ioread32be(&uccf->uf_regs->uccm));\n\tprintk(KERN_INFO \"uccs  : addr=0x%p, val=0x%02x\\n\",\n\t\t  &uccf->uf_regs->uccs, ioread8(&uccf->uf_regs->uccs));\n\tprintk(KERN_INFO \"urfb  : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->urfb, ioread32be(&uccf->uf_regs->urfb));\n\tprintk(KERN_INFO \"urfs  : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->urfs, ioread16be(&uccf->uf_regs->urfs));\n\tprintk(KERN_INFO \"urfet : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->urfet, ioread16be(&uccf->uf_regs->urfet));\n\tprintk(KERN_INFO \"urfset: addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->urfset,\n\t\t  ioread16be(&uccf->uf_regs->urfset));\n\tprintk(KERN_INFO \"utfb  : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->utfb, ioread32be(&uccf->uf_regs->utfb));\n\tprintk(KERN_INFO \"utfs  : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->utfs, ioread16be(&uccf->uf_regs->utfs));\n\tprintk(KERN_INFO \"utfet : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->utfet, ioread16be(&uccf->uf_regs->utfet));\n\tprintk(KERN_INFO \"utftt : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->utftt, ioread16be(&uccf->uf_regs->utftt));\n\tprintk(KERN_INFO \"utpt  : addr=0x%p, val=0x%04x\\n\",\n\t\t  &uccf->uf_regs->utpt, ioread16be(&uccf->uf_regs->utpt));\n\tprintk(KERN_INFO \"urtry : addr=0x%p, val=0x%08x\\n\",\n\t\t  &uccf->uf_regs->urtry, ioread32be(&uccf->uf_regs->urtry));\n\tprintk(KERN_INFO \"guemr : addr=0x%p, val=0x%02x\\n\",\n\t\t  &uccf->uf_regs->guemr, ioread8(&uccf->uf_regs->guemr));\n}\nEXPORT_SYMBOL(ucc_fast_dump_regs);\n\nu32 ucc_fast_get_qe_cr_subblock(int uccf_num)\n{\n\tswitch (uccf_num) {\n\tcase 0: return QE_CR_SUBBLOCK_UCCFAST1;\n\tcase 1: return QE_CR_SUBBLOCK_UCCFAST2;\n\tcase 2: return QE_CR_SUBBLOCK_UCCFAST3;\n\tcase 3: return QE_CR_SUBBLOCK_UCCFAST4;\n\tcase 4: return QE_CR_SUBBLOCK_UCCFAST5;\n\tcase 5: return QE_CR_SUBBLOCK_UCCFAST6;\n\tcase 6: return QE_CR_SUBBLOCK_UCCFAST7;\n\tcase 7: return QE_CR_SUBBLOCK_UCCFAST8;\n\tdefault: return QE_CR_SUBBLOCK_INVALID;\n\t}\n}\nEXPORT_SYMBOL(ucc_fast_get_qe_cr_subblock);\n\nvoid ucc_fast_transmit_on_demand(struct ucc_fast_private * uccf)\n{\n\tiowrite16be(UCC_FAST_TOD, &uccf->uf_regs->utodr);\n}\nEXPORT_SYMBOL(ucc_fast_transmit_on_demand);\n\nvoid ucc_fast_enable(struct ucc_fast_private * uccf, enum comm_dir mode)\n{\n\tstruct ucc_fast __iomem *uf_regs;\n\tu32 gumr;\n\n\tuf_regs = uccf->uf_regs;\n\n\t \n\tgumr = ioread32be(&uf_regs->gumr);\n\tif (mode & COMM_DIR_TX) {\n\t\tgumr |= UCC_FAST_GUMR_ENT;\n\t\tuccf->enabled_tx = 1;\n\t}\n\tif (mode & COMM_DIR_RX) {\n\t\tgumr |= UCC_FAST_GUMR_ENR;\n\t\tuccf->enabled_rx = 1;\n\t}\n\tiowrite32be(gumr, &uf_regs->gumr);\n}\nEXPORT_SYMBOL(ucc_fast_enable);\n\nvoid ucc_fast_disable(struct ucc_fast_private * uccf, enum comm_dir mode)\n{\n\tstruct ucc_fast __iomem *uf_regs;\n\tu32 gumr;\n\n\tuf_regs = uccf->uf_regs;\n\n\t \n\tgumr = ioread32be(&uf_regs->gumr);\n\tif (mode & COMM_DIR_TX) {\n\t\tgumr &= ~UCC_FAST_GUMR_ENT;\n\t\tuccf->enabled_tx = 0;\n\t}\n\tif (mode & COMM_DIR_RX) {\n\t\tgumr &= ~UCC_FAST_GUMR_ENR;\n\t\tuccf->enabled_rx = 0;\n\t}\n\tiowrite32be(gumr, &uf_regs->gumr);\n}\nEXPORT_SYMBOL(ucc_fast_disable);\n\nint ucc_fast_init(struct ucc_fast_info * uf_info, struct ucc_fast_private ** uccf_ret)\n{\n\tstruct ucc_fast_private *uccf;\n\tstruct ucc_fast __iomem *uf_regs;\n\tu32 gumr;\n\tint ret;\n\n\tif (!uf_info)\n\t\treturn -EINVAL;\n\n\t \n\tif ((uf_info->ucc_num < 0) || (uf_info->ucc_num > UCC_MAX_NUM - 1)) {\n\t\tprintk(KERN_ERR \"%s: illegal UCC number\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (uf_info->max_rx_buf_length & (UCC_FAST_MRBLR_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: max_rx_buf_length not aligned\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (uf_info->urfs < UCC_FAST_URFS_MIN_VAL) {\n\t\tprintk(KERN_ERR \"%s: urfs is too small\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->urfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: urfs is not aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->urfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: urfet is not aligned.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->urfset & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: urfset is not aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->utfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: utfs is not aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->utfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: utfet is not aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uf_info->utftt & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\n\t\tprintk(KERN_ERR \"%s: utftt is not aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tuccf = kzalloc(sizeof(struct ucc_fast_private), GFP_KERNEL);\n\tif (!uccf) {\n\t\tprintk(KERN_ERR \"%s: Cannot allocate private data\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tuccf->ucc_fast_tx_virtual_fifo_base_offset = -1;\n\tuccf->ucc_fast_rx_virtual_fifo_base_offset = -1;\n\n\t \n\tuccf->uf_info = uf_info;\n\t \n\tuccf->uf_regs = ioremap(uf_info->regs, sizeof(struct ucc_fast));\n\tif (uccf->uf_regs == NULL) {\n\t\tprintk(KERN_ERR \"%s: Cannot map UCC registers\\n\", __func__);\n\t\tkfree(uccf);\n\t\treturn -ENOMEM;\n\t}\n\n\tuccf->enabled_tx = 0;\n\tuccf->enabled_rx = 0;\n\tuccf->stopped_tx = 0;\n\tuccf->stopped_rx = 0;\n\tuf_regs = uccf->uf_regs;\n\tuccf->p_ucce = &uf_regs->ucce;\n\tuccf->p_uccm = &uf_regs->uccm;\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\n\tuccf->p_utodr = &uf_regs->utodr;\n#endif\n#ifdef STATISTICS\n\tuccf->tx_frames = 0;\n\tuccf->rx_frames = 0;\n\tuccf->rx_discarded = 0;\n#endif\t\t\t\t \n\n\t \n\tret = ucc_set_type(uf_info->ucc_num, UCC_SPEED_TYPE_FAST);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: cannot set UCC type\\n\", __func__);\n\t\tucc_fast_free(uccf);\n\t\treturn ret;\n\t}\n\n\tuccf->mrblr = uf_info->max_rx_buf_length;\n\n\t \n\t \n\tgumr = uf_info->ttx_trx;\n\tif (uf_info->tci)\n\t\tgumr |= UCC_FAST_GUMR_TCI;\n\tif (uf_info->cdp)\n\t\tgumr |= UCC_FAST_GUMR_CDP;\n\tif (uf_info->ctsp)\n\t\tgumr |= UCC_FAST_GUMR_CTSP;\n\tif (uf_info->cds)\n\t\tgumr |= UCC_FAST_GUMR_CDS;\n\tif (uf_info->ctss)\n\t\tgumr |= UCC_FAST_GUMR_CTSS;\n\tif (uf_info->txsy)\n\t\tgumr |= UCC_FAST_GUMR_TXSY;\n\tif (uf_info->rsyn)\n\t\tgumr |= UCC_FAST_GUMR_RSYN;\n\tgumr |= uf_info->synl;\n\tif (uf_info->rtsm)\n\t\tgumr |= UCC_FAST_GUMR_RTSM;\n\tgumr |= uf_info->renc;\n\tif (uf_info->revd)\n\t\tgumr |= UCC_FAST_GUMR_REVD;\n\tgumr |= uf_info->tenc;\n\tgumr |= uf_info->tcrc;\n\tgumr |= uf_info->mode;\n\tiowrite32be(gumr, &uf_regs->gumr);\n\n\t \n\tuccf->ucc_fast_tx_virtual_fifo_base_offset =\n\t    qe_muram_alloc(uf_info->utfs, UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);\n\tif (uccf->ucc_fast_tx_virtual_fifo_base_offset < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate MURAM for TX FIFO\\n\",\n\t\t\t__func__);\n\t\tucc_fast_free(uccf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tuccf->ucc_fast_rx_virtual_fifo_base_offset =\n\t\tqe_muram_alloc(uf_info->urfs +\n\t\t\t   UCC_FAST_RECEIVE_VIRTUAL_FIFO_SIZE_FUDGE_FACTOR,\n\t\t\t   UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);\n\tif (uccf->ucc_fast_rx_virtual_fifo_base_offset < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate MURAM for RX FIFO\\n\",\n\t\t\t__func__);\n\t\tucc_fast_free(uccf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tiowrite16be(uf_info->urfs, &uf_regs->urfs);\n\tiowrite16be(uf_info->urfet, &uf_regs->urfet);\n\tiowrite16be(uf_info->urfset, &uf_regs->urfset);\n\tiowrite16be(uf_info->utfs, &uf_regs->utfs);\n\tiowrite16be(uf_info->utfet, &uf_regs->utfet);\n\tiowrite16be(uf_info->utftt, &uf_regs->utftt);\n\t \n\tiowrite32be(uccf->ucc_fast_tx_virtual_fifo_base_offset,\n\t\t       &uf_regs->utfb);\n\tiowrite32be(uccf->ucc_fast_rx_virtual_fifo_base_offset,\n\t\t       &uf_regs->urfb);\n\n\t \n\t \n\tucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);\n\t \n\tucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);\n\t \n\tucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);\n\t \n\tif (!uf_info->tsa) {\n\t\t \n\t\tif ((uf_info->rx_clock != QE_CLK_NONE) &&\n\t\t    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->rx_clock,\n\t\t\t\t\tCOMM_DIR_RX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for RX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif ((uf_info->tx_clock != QE_CLK_NONE) &&\n\t\t    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->tx_clock,\n\t\t\t\t\tCOMM_DIR_TX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for TX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((uf_info->rx_clock != QE_CLK_NONE) &&\n\t\t    ucc_set_tdm_rxtx_clk(uf_info->tdm_num, uf_info->rx_clock,\n\t\t\t\t\t COMM_DIR_RX)) {\n\t\t\tpr_err(\"%s: illegal value for RX clock\", __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((uf_info->tx_clock != QE_CLK_NONE) &&\n\t\t    ucc_set_tdm_rxtx_clk(uf_info->tdm_num, uf_info->tx_clock,\n\t\t\t\t\t COMM_DIR_TX)) {\n\t\t\tpr_err(\"%s: illegal value for TX clock\", __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((uf_info->rx_sync != QE_CLK_NONE) &&\n\t\t    ucc_set_tdm_rxtx_sync(uf_info->tdm_num, uf_info->rx_sync,\n\t\t\t\t\t  COMM_DIR_RX)) {\n\t\t\tpr_err(\"%s: illegal value for RX clock\", __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif ((uf_info->tx_sync != QE_CLK_NONE) &&\n\t\t    ucc_set_tdm_rxtx_sync(uf_info->tdm_num, uf_info->tx_sync,\n\t\t\t\t\t  COMM_DIR_TX)) {\n\t\t\tpr_err(\"%s: illegal value for TX clock\", __func__);\n\t\t\tucc_fast_free(uccf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tiowrite32be(uf_info->uccm_mask, &uf_regs->uccm);\n\n\t \n\n\t \n\tiowrite32be(0xffffffff, &uf_regs->ucce);\n\n\t*uccf_ret = uccf;\n\treturn 0;\n}\nEXPORT_SYMBOL(ucc_fast_init);\n\nvoid ucc_fast_free(struct ucc_fast_private * uccf)\n{\n\tif (!uccf)\n\t\treturn;\n\n\tqe_muram_free(uccf->ucc_fast_tx_virtual_fifo_base_offset);\n\tqe_muram_free(uccf->ucc_fast_rx_virtual_fifo_base_offset);\n\n\tif (uccf->uf_regs)\n\t\tiounmap(uccf->uf_regs);\n\n\tkfree(uccf);\n}\nEXPORT_SYMBOL(ucc_fast_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}