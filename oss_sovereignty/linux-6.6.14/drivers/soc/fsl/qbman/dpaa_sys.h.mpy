{
  "module_name": "dpaa_sys.h",
  "hash_id": "d4e5c6a6fde48dc994eba42f4df68fbe89899538bb369e0238b680b43271cc7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/dpaa_sys.h",
  "human_readable_source": " \n\n#ifndef __DPAA_SYS_H\n#define __DPAA_SYS_H\n\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/sched/signal.h>\n#include <linux/vmalloc.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/prefetch.h>\n#include <linux/genalloc.h>\n#include <asm/cacheflush.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n\n \n#define DPAA_PORTAL_CE 0\n#define DPAA_PORTAL_CI 1\n\nstatic inline void dpaa_flush(void *p)\n{\n\t \n#ifdef CONFIG_PPC\n\tflush_dcache_range((unsigned long)p, (unsigned long)p+64);\n#endif\n}\n\n#define dpaa_invalidate(p) dpaa_flush(p)\n\n#define dpaa_zero(p) memset(p, 0, 64)\n\nstatic inline void dpaa_touch_ro(void *p)\n{\n#if (L1_CACHE_BYTES == 32)\n\tprefetch(p+32);\n#endif\n\tprefetch(p);\n}\n\n \nstatic inline void dpaa_invalidate_touch_ro(void *p)\n{\n\tdpaa_invalidate(p);\n\tdpaa_touch_ro(p);\n}\n\n\n#ifdef CONFIG_FSL_DPAA_CHECKING\n#define DPAA_ASSERT(x) WARN_ON(!(x))\n#else\n#define DPAA_ASSERT(x)\n#endif\n\n \nstatic inline u8 dpaa_cyc_diff(u8 ringsize, u8 first, u8 last)\n{\n\t \n\tif (first <= last)\n\t\treturn last - first;\n\treturn ringsize + last - first;\n}\n\n \n#define DPAA_GENALLOC_OFF\t0x80000000\n\n \nint qbman_init_private_mem(struct device *dev, int idx, dma_addr_t *addr,\n\t\t\t\tsize_t *size);\n\n \n#ifdef CONFIG_PPC\n#define QBMAN_MEMREMAP_ATTR\tMEMREMAP_WB\n#else\n#define QBMAN_MEMREMAP_ATTR\tMEMREMAP_WC\n#endif\n\nstatic inline int dpaa_set_portal_irq_affinity(struct device *dev,\n\t\t\t\t\t       int irq, int cpu)\n{\n\tint ret = 0;\n\n\tif (!irq_can_set_affinity(irq)) {\n\t\tdev_err(dev, \"unable to set IRQ affinity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cpu == -1 || !cpu_online(cpu))\n\t\tcpu = cpumask_any(cpu_online_mask);\n\n\tret = irq_set_affinity(irq, cpumask_of(cpu));\n\tif (ret)\n\t\tdev_err(dev, \"irq_set_affinity() on CPU %d failed\\n\", cpu);\n\n\treturn ret;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}