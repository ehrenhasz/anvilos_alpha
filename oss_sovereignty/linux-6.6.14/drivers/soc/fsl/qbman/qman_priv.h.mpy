{
  "module_name": "qman_priv.h",
  "hash_id": "4d28282403d32f8a99cd8453ee4c8c60346da166931c63074ff0c9936dfb148c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/qman_priv.h",
  "human_readable_source": " \n\n#include \"dpaa_sys.h\"\n\n#include <soc/fsl/qman.h>\n#include <linux/dma-mapping.h>\n#include <linux/iommu.h>\n\n#if defined(CONFIG_FSL_PAMU)\n#include <asm/fsl_pamu_stash.h>\n#endif\n\nstruct qm_mcr_querywq {\n\tu8 verb;\n\tu8 result;\n\tu16 channel_wq;  \n\tu8 __reserved[28];\n\tu32 wq_len[8];\n} __packed;\n\nstatic inline u16 qm_mcr_querywq_get_chan(const struct qm_mcr_querywq *wq)\n{\n\treturn wq->channel_wq >> 3;\n}\n\nstruct __qm_mcr_querycongestion {\n\tu32 state[8];\n};\n\n \nstruct qm_mcr_querycongestion {\n\tu8 verb;\n\tu8 result;\n\tu8 __reserved[30];\n\t \n\tstruct __qm_mcr_querycongestion state;\n} __packed;\n\n \nstruct qm_mcr_querycgr {\n\tu8 verb;\n\tu8 result;\n\tu16 __reserved1;\n\tstruct __qm_mc_cgr cgr;  \n\tu8 __reserved2[6];\n\tu8 i_bcnt_hi;\t \n\t__be32 i_bcnt_lo;\t \n\tu8 __reserved3[3];\n\tu8 a_bcnt_hi;\t \n\t__be32 a_bcnt_lo;\t \n\t__be32 cscn_targ_swp[4];\n} __packed;\n\nstatic inline u64 qm_mcr_querycgr_i_get64(const struct qm_mcr_querycgr *q)\n{\n\treturn ((u64)q->i_bcnt_hi << 32) | be32_to_cpu(q->i_bcnt_lo);\n}\nstatic inline u64 qm_mcr_querycgr_a_get64(const struct qm_mcr_querycgr *q)\n{\n\treturn ((u64)q->a_bcnt_hi << 32) | be32_to_cpu(q->a_bcnt_lo);\n}\n\n \n\n \n#define CGR_BITS_PER_WORD 5\n#define CGR_WORD(x)\t((x) >> CGR_BITS_PER_WORD)\n#define CGR_BIT(x)\t(BIT(31) >> ((x) & 0x1f))\n#define CGR_NUM\t(sizeof(struct __qm_mcr_querycongestion) << 3)\n\nstruct qman_cgrs {\n\tstruct __qm_mcr_querycongestion q;\n};\n\nstatic inline void qman_cgrs_init(struct qman_cgrs *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}\n\nstatic inline void qman_cgrs_fill(struct qman_cgrs *c)\n{\n\tmemset(c, 0xff, sizeof(*c));\n}\n\nstatic inline int qman_cgrs_get(struct qman_cgrs *c, u8 cgr)\n{\n\treturn c->q.state[CGR_WORD(cgr)] & CGR_BIT(cgr);\n}\n\nstatic inline void qman_cgrs_cp(struct qman_cgrs *dest,\n\t\t\t\tconst struct qman_cgrs *src)\n{\n\t*dest = *src;\n}\n\nstatic inline void qman_cgrs_and(struct qman_cgrs *dest,\n\t\t\tconst struct qman_cgrs *a, const struct qman_cgrs *b)\n{\n\tint ret;\n\tu32 *_d = dest->q.state;\n\tconst u32 *_a = a->q.state;\n\tconst u32 *_b = b->q.state;\n\n\tfor (ret = 0; ret < 8; ret++)\n\t\t*_d++ = *_a++ & *_b++;\n}\n\nstatic inline void qman_cgrs_xor(struct qman_cgrs *dest,\n\t\t\tconst struct qman_cgrs *a, const struct qman_cgrs *b)\n{\n\tint ret;\n\tu32 *_d = dest->q.state;\n\tconst u32 *_a = a->q.state;\n\tconst u32 *_b = b->q.state;\n\n\tfor (ret = 0; ret < 8; ret++)\n\t\t*_d++ = *_a++ ^ *_b++;\n}\n\nvoid qman_init_cgr_all(void);\n\nstruct qm_portal_config {\n\t \n\tvoid *addr_virt_ce;\n\tvoid __iomem *addr_virt_ci;\n\tstruct device *dev;\n\tstruct iommu_domain *iommu_domain;\n\t \n\tstruct list_head list;\n\t \n\t \n\tint cpu;\n\t \n\tint irq;\n\t \n\tu16 channel;\n\t \n\tu32 pools;\n};\n\n \n#define QMAN_REV11 0x0101\n#define QMAN_REV12 0x0102\n#define QMAN_REV20 0x0200\n#define QMAN_REV30 0x0300\n#define QMAN_REV31 0x0301\n#define QMAN_REV32 0x0302\nextern u16 qman_ip_rev;  \n\n#define QM_FQID_RANGE_START 1  \nextern struct gen_pool *qm_fqalloc;  \nextern struct gen_pool *qm_qpalloc;  \nextern struct gen_pool *qm_cgralloc;  \nu32 qm_get_pools_sdqcr(void);\n\nint qman_wq_alloc(void);\n#ifdef CONFIG_FSL_PAMU\n#define qman_liodn_fixup __qman_liodn_fixup\n#else\nstatic inline void qman_liodn_fixup(u16 channel)\n{\n}\n#endif\nvoid __qman_liodn_fixup(u16 channel);\nvoid qman_set_sdest(u16 channel, unsigned int cpu_idx);\n\nstruct qman_portal *qman_create_affine_portal(\n\t\t\tconst struct qm_portal_config *config,\n\t\t\tconst struct qman_cgrs *cgrs);\nconst struct qm_portal_config *qman_destroy_affine_portal(void);\n\n \nint qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd);\n\nint qman_alloc_fq_table(u32 num_fqids);\n\n \n\n \n#define QM_SDQCR_SOURCE_CHANNELS\t0x0\n#define QM_SDQCR_SOURCE_SPECIFICWQ\t0x40000000\n#define QM_SDQCR_COUNT_EXACT1\t\t0x0\n#define QM_SDQCR_COUNT_UPTO3\t\t0x20000000\n#define QM_SDQCR_DEDICATED_PRECEDENCE\t0x10000000\n#define QM_SDQCR_TYPE_MASK\t\t0x03000000\n#define QM_SDQCR_TYPE_NULL\t\t0x0\n#define QM_SDQCR_TYPE_PRIO_QOS\t\t0x01000000\n#define QM_SDQCR_TYPE_ACTIVE_QOS\t0x02000000\n#define QM_SDQCR_TYPE_ACTIVE\t\t0x03000000\n#define QM_SDQCR_TOKEN_MASK\t\t0x00ff0000\n#define QM_SDQCR_TOKEN_SET(v)\t\t(((v) & 0xff) << 16)\n#define QM_SDQCR_TOKEN_GET(v)\t\t(((v) >> 16) & 0xff)\n#define QM_SDQCR_CHANNELS_DEDICATED\t0x00008000\n#define QM_SDQCR_SPECIFICWQ_MASK\t0x000000f7\n#define QM_SDQCR_SPECIFICWQ_DEDICATED\t0x00000000\n#define QM_SDQCR_SPECIFICWQ_POOL(n)\t((n) << 4)\n#define QM_SDQCR_SPECIFICWQ_WQ(n)\t(n)\n\n \n#define QM_VDQCR_FQID_MASK\t\t0x00ffffff\n#define QM_VDQCR_FQID(n)\t\t((n) & QM_VDQCR_FQID_MASK)\n\n \n#define QM_PIRQ_DQAVAIL\t0x0000ffff\n\n \n#define QM_DQAVAIL_PORTAL\t0x8000\t\t \n#define QM_DQAVAIL_POOL(n)\t(0x8000 >> (n))\t \n#define QM_DQAVAIL_MASK\t\t0xffff\n \n#define QM_PIRQ_VISIBLE\t(QM_PIRQ_SLOW | QM_PIRQ_DQRI)\n\nextern struct qman_portal *affine_portals[NR_CPUS];\nextern struct qman_portal *qman_dma_portal;\nconst struct qm_portal_config *qman_get_qm_portal_config(\n\t\t\t\t\t\tstruct qman_portal *portal);\n\nunsigned int qm_get_fqid_maxcnt(void);\n\nint qman_shutdown_fq(u32 fqid);\n\nint qman_requires_cleanup(void);\nvoid qman_done_cleanup(void);\nvoid qman_enable_irqs(void);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}