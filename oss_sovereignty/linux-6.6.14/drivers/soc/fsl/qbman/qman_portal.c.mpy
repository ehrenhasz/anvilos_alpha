{
  "module_name": "qman_portal.c",
  "hash_id": "965b823dbc864b2364b460ab53d5847c3d9af69468b25f7515fa1eb7f8036778",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/qman_portal.c",
  "human_readable_source": " \n\n#include \"qman_priv.h\"\n\nstruct qman_portal *qman_dma_portal;\nEXPORT_SYMBOL(qman_dma_portal);\n\n \n#define CONFIG_FSL_DPA_PIRQ_SLOW  1\n#define CONFIG_FSL_DPA_PIRQ_FAST  1\n\nstatic struct cpumask portal_cpus;\nstatic int __qman_portals_probed;\n \nstatic DEFINE_SPINLOCK(qman_lock);\n\nstatic void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)\n{\n#ifdef CONFIG_FSL_PAMU\n\tstruct device *dev = pcfg->dev;\n\tint ret;\n\n\tpcfg->iommu_domain = iommu_domain_alloc(&platform_bus_type);\n\tif (!pcfg->iommu_domain) {\n\t\tdev_err(dev, \"%s(): iommu_domain_alloc() failed\", __func__);\n\t\tgoto no_iommu;\n\t}\n\tret = fsl_pamu_configure_l1_stash(pcfg->iommu_domain, cpu);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): fsl_pamu_configure_l1_stash() = %d\",\n\t\t\t__func__, ret);\n\t\tgoto out_domain_free;\n\t}\n\tret = iommu_attach_device(pcfg->iommu_domain, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s(): iommu_device_attach() = %d\", __func__,\n\t\t\tret);\n\t\tgoto out_domain_free;\n\t}\n\nno_iommu:\n#endif\n\tqman_set_sdest(pcfg->channel, cpu);\n\n\treturn;\n\n#ifdef CONFIG_FSL_PAMU\nout_domain_free:\n\tiommu_domain_free(pcfg->iommu_domain);\n\tpcfg->iommu_domain = NULL;\n#endif\n}\n\nstatic struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)\n{\n\tstruct qman_portal *p;\n\tu32 irq_sources = 0;\n\n\t \n\tqman_liodn_fixup(pcfg->channel);\n\n\tpcfg->iommu_domain = NULL;\n\tportal_set_cpu(pcfg, pcfg->cpu);\n\n\tp = qman_create_affine_portal(pcfg, NULL);\n\tif (!p) {\n\t\tdev_crit(pcfg->dev, \"%s: Portal failure on cpu %d\\n\",\n\t\t\t __func__, pcfg->cpu);\n\t\treturn NULL;\n\t}\n\n\t \n#ifdef CONFIG_FSL_DPA_PIRQ_SLOW\n\tirq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI | QM_PIRQ_MRI |\n\t\t       QM_PIRQ_CSCI;\n#endif\n#ifdef CONFIG_FSL_DPA_PIRQ_FAST\n\tirq_sources |= QM_PIRQ_DQRI;\n#endif\n\tqman_p_irqsource_add(p, irq_sources);\n\n\tspin_lock(&qman_lock);\n\tif (cpumask_equal(&portal_cpus, cpu_possible_mask)) {\n\t\t \n\t\tqman_init_cgr_all();\n\t}\n\n\tif (!qman_dma_portal)\n\t\tqman_dma_portal = p;\n\n\tspin_unlock(&qman_lock);\n\n\tdev_info(pcfg->dev, \"Portal initialised, cpu %d\\n\", pcfg->cpu);\n\n\treturn p;\n}\n\nstatic void qman_portal_update_sdest(const struct qm_portal_config *pcfg,\n\t\t\t\t\t\t\tunsigned int cpu)\n{\n#ifdef CONFIG_FSL_PAMU  \n\tif (pcfg->iommu_domain) {\n\t\tif (fsl_pamu_configure_l1_stash(pcfg->iommu_domain, cpu) < 0) {\n\t\t\tdev_err(pcfg->dev,\n\t\t\t\t\"Failed to update pamu stash setting\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tqman_set_sdest(pcfg->channel, cpu);\n}\n\nstatic int qman_offline_cpu(unsigned int cpu)\n{\n\tstruct qman_portal *p;\n\tconst struct qm_portal_config *pcfg;\n\n\tp = affine_portals[cpu];\n\tif (p) {\n\t\tpcfg = qman_get_qm_portal_config(p);\n\t\tif (pcfg) {\n\t\t\t \n\t\t\tcpu = cpumask_any_but(cpu_online_mask, cpu);\n\t\t\tirq_set_affinity(pcfg->irq, cpumask_of(cpu));\n\t\t\tqman_portal_update_sdest(pcfg, cpu);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qman_online_cpu(unsigned int cpu)\n{\n\tstruct qman_portal *p;\n\tconst struct qm_portal_config *pcfg;\n\n\tp = affine_portals[cpu];\n\tif (p) {\n\t\tpcfg = qman_get_qm_portal_config(p);\n\t\tif (pcfg) {\n\t\t\tirq_set_affinity(pcfg->irq, cpumask_of(cpu));\n\t\t\tqman_portal_update_sdest(pcfg, cpu);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint qman_portals_probed(void)\n{\n\treturn __qman_portals_probed;\n}\nEXPORT_SYMBOL_GPL(qman_portals_probed);\n\nstatic int qman_portal_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct qm_portal_config *pcfg;\n\tstruct resource *addr_phys[2];\n\tint irq, cpu, err, i;\n\tu32 val;\n\n\terr = qman_is_probed();\n\tif (!err)\n\t\treturn -EPROBE_DEFER;\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failing probe due to qman probe error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcfg = devm_kmalloc(dev, sizeof(*pcfg), GFP_KERNEL);\n\tif (!pcfg) {\n\t\t__qman_portals_probed = -1;\n\t\treturn -ENOMEM;\n\t}\n\n\tpcfg->dev = dev;\n\n\taddr_phys[0] = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\t     DPAA_PORTAL_CE);\n\tif (!addr_phys[0]) {\n\t\tdev_err(dev, \"Can't get %pOF property 'reg::CE'\\n\", node);\n\t\tgoto err_ioremap1;\n\t}\n\n\taddr_phys[1] = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\t     DPAA_PORTAL_CI);\n\tif (!addr_phys[1]) {\n\t\tdev_err(dev, \"Can't get %pOF property 'reg::CI'\\n\", node);\n\t\tgoto err_ioremap1;\n\t}\n\n\terr = of_property_read_u32(node, \"cell-index\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"Can't get %pOF property 'cell-index'\\n\", node);\n\t\t__qman_portals_probed = -1;\n\t\treturn err;\n\t}\n\tpcfg->channel = val;\n\tpcfg->cpu = -1;\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\tgoto err_ioremap1;\n\tpcfg->irq = irq;\n\n\tpcfg->addr_virt_ce = memremap(addr_phys[0]->start,\n\t\t\t\t\tresource_size(addr_phys[0]),\n\t\t\t\t\tQBMAN_MEMREMAP_ATTR);\n\tif (!pcfg->addr_virt_ce) {\n\t\tdev_err(dev, \"memremap::CE failed\\n\");\n\t\tgoto err_ioremap1;\n\t}\n\n\tpcfg->addr_virt_ci = ioremap(addr_phys[1]->start,\n\t\t\t\tresource_size(addr_phys[1]));\n\tif (!pcfg->addr_virt_ci) {\n\t\tdev_err(dev, \"ioremap::CI failed\\n\");\n\t\tgoto err_ioremap2;\n\t}\n\n\tpcfg->pools = qm_get_pools_sdqcr();\n\n\tspin_lock(&qman_lock);\n\tcpu = cpumask_first_zero(&portal_cpus);\n\tif (cpu >= nr_cpu_ids) {\n\t\t__qman_portals_probed = 1;\n\t\t \n\t\tspin_unlock(&qman_lock);\n\t\tgoto check_cleanup;\n\t}\n\n\tcpumask_set_cpu(cpu, &portal_cpus);\n\tspin_unlock(&qman_lock);\n\tpcfg->cpu = cpu;\n\n\tif (dma_set_mask(dev, DMA_BIT_MASK(40))) {\n\t\tdev_err(dev, \"dma_set_mask() failed\\n\");\n\t\tgoto err_portal_init;\n\t}\n\n\tif (!init_pcfg(pcfg)) {\n\t\tdev_err(dev, \"portal init failed\\n\");\n\t\tgoto err_portal_init;\n\t}\n\n\t \n\tif (!cpu_online(cpu))\n\t\tqman_offline_cpu(cpu);\n\ncheck_cleanup:\n\tif (__qman_portals_probed == 1 && qman_requires_cleanup()) {\n\t\t \n\t\tfor (i = 0; i < qm_get_fqid_maxcnt(); i++) {\n\t\t\terr =  qman_shutdown_fq(i);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev, \"Failed to shutdown frame queue %d\\n\",\n\t\t\t\t\ti);\n\t\t\t\tgoto err_portal_init;\n\t\t\t}\n\t\t}\n\t\tqman_done_cleanup();\n\t}\n\n\treturn 0;\n\nerr_portal_init:\n\tiounmap(pcfg->addr_virt_ci);\nerr_ioremap2:\n\tmemunmap(pcfg->addr_virt_ce);\nerr_ioremap1:\n\t__qman_portals_probed = -1;\n\n\treturn -ENXIO;\n}\n\nstatic const struct of_device_id qman_portal_ids[] = {\n\t{\n\t\t.compatible = \"fsl,qman-portal\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qman_portal_ids);\n\nstatic struct platform_driver qman_portal_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = qman_portal_ids,\n\t},\n\t.probe = qman_portal_probe,\n};\n\nstatic int __init qman_portal_driver_register(struct platform_driver *drv)\n{\n\tint ret;\n\n\tret = platform_driver_register(drv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"soc/qman_portal:online\",\n\t\t\t\t\tqman_online_cpu, qman_offline_cpu);\n\tif (ret < 0) {\n\t\tpr_err(\"qman: failed to register hotplug callbacks.\\n\");\n\t\tplatform_driver_unregister(drv);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nmodule_driver(qman_portal_driver,\n\t      qman_portal_driver_register, platform_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}