{
  "module_name": "bman_ccsr.c",
  "hash_id": "2ee229def7b3188163e07bd2361723ef2f5e1f12d0dfe0fef9b7b3646350634f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/bman_ccsr.c",
  "human_readable_source": " \n\n#include \"bman_priv.h\"\n\nu16 bman_ip_rev;\nEXPORT_SYMBOL(bman_ip_rev);\n\n \n#define REG_FBPR_FPC\t\t0x0800\n#define REG_ECSR\t\t0x0a00\n#define REG_ECIR\t\t0x0a04\n#define REG_EADR\t\t0x0a08\n#define REG_EDATA(n)\t\t(0x0a10 + ((n) * 0x04))\n#define REG_SBEC(n)\t\t(0x0a80 + ((n) * 0x04))\n#define REG_IP_REV_1\t\t0x0bf8\n#define REG_IP_REV_2\t\t0x0bfc\n#define REG_FBPR_BARE\t\t0x0c00\n#define REG_FBPR_BAR\t\t0x0c04\n#define REG_FBPR_AR\t\t0x0c10\n#define REG_SRCIDR\t\t0x0d04\n#define REG_LIODNR\t\t0x0d08\n#define REG_ERR_ISR\t\t0x0e00\n#define REG_ERR_IER\t\t0x0e04\n#define REG_ERR_ISDR\t\t0x0e08\n\n \n#define BM_EIRQ_IVCI\t0x00000010\t \n#define BM_EIRQ_FLWI\t0x00000008\t \n#define BM_EIRQ_MBEI\t0x00000004\t \n#define BM_EIRQ_SBEI\t0x00000002\t \n#define BM_EIRQ_BSCN\t0x00000001\t \n\nstruct bman_hwerr_txt {\n\tu32 mask;\n\tconst char *txt;\n};\n\nstatic const struct bman_hwerr_txt bman_hwerr_txts[] = {\n\t{ BM_EIRQ_IVCI, \"Invalid Command Verb\" },\n\t{ BM_EIRQ_FLWI, \"FBPR Low Watermark\" },\n\t{ BM_EIRQ_MBEI, \"Multi-bit ECC Error\" },\n\t{ BM_EIRQ_SBEI, \"Single-bit ECC Error\" },\n\t{ BM_EIRQ_BSCN, \"Pool State Change Notification\" },\n};\n\n \n#define BMAN_ERRS_TO_DISABLE BM_EIRQ_FLWI\n\n \nstatic u32 __iomem *bm_ccsr_start;\n\nstatic inline u32 bm_ccsr_in(u32 offset)\n{\n\treturn ioread32be(bm_ccsr_start + offset/4);\n}\nstatic inline void bm_ccsr_out(u32 offset, u32 val)\n{\n\tiowrite32be(val, bm_ccsr_start + offset/4);\n}\n\nstatic void bm_get_version(u16 *id, u8 *major, u8 *minor)\n{\n\tu32 v = bm_ccsr_in(REG_IP_REV_1);\n\t*id = (v >> 16);\n\t*major = (v >> 8) & 0xff;\n\t*minor = v & 0xff;\n}\n\n \n#define FBPR_AR_RPRIO_HI BIT(30)\n\n \nstatic int __bman_probed;\nstatic int __bman_requires_cleanup;\n\n\nstatic int bm_set_memory(u64 ba, u32 size)\n{\n\tu32 bar, bare;\n\tu32 exp = ilog2(size);\n\t \n\tDPAA_ASSERT(size >= 4096 && size <= 1024*1024*1024 &&\n\t\t   is_power_of_2(size));\n\t \n\tDPAA_ASSERT(!(ba & (size - 1)));\n\n\t \n\tbar = bm_ccsr_in(REG_FBPR_BAR);\n\tif (bar) {\n\t\t \n\t\tbare = bm_ccsr_in(REG_FBPR_BARE);\n\t\tif (bare != upper_32_bits(ba) || bar != lower_32_bits(ba)) {\n\t\t\tpr_err(\"Attempted to reinitialize BMan with different BAR, got 0x%llx read BARE=0x%x BAR=0x%x\\n\",\n\t\t\t       ba, bare, bar);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpr_info(\"BMan BAR already configured\\n\");\n\t\t__bman_requires_cleanup = 1;\n\t\treturn 1;\n\t}\n\n\tbm_ccsr_out(REG_FBPR_BARE, upper_32_bits(ba));\n\tbm_ccsr_out(REG_FBPR_BAR, lower_32_bits(ba));\n\tbm_ccsr_out(REG_FBPR_AR, exp - 1);\n\treturn 0;\n}\n\n \nstatic dma_addr_t fbpr_a;\nstatic size_t fbpr_sz;\n\nstatic int bman_fbpr(struct reserved_mem *rmem)\n{\n\tfbpr_a = rmem->base;\n\tfbpr_sz = rmem->size;\n\n\tWARN_ON(!(fbpr_a && fbpr_sz));\n\n\treturn 0;\n}\nRESERVEDMEM_OF_DECLARE(bman_fbpr, \"fsl,bman-fbpr\", bman_fbpr);\n\nstatic irqreturn_t bman_isr(int irq, void *ptr)\n{\n\tu32 isr_val, ier_val, ecsr_val, isr_mask, i;\n\tstruct device *dev = ptr;\n\n\tier_val = bm_ccsr_in(REG_ERR_IER);\n\tisr_val = bm_ccsr_in(REG_ERR_ISR);\n\tecsr_val = bm_ccsr_in(REG_ECSR);\n\tisr_mask = isr_val & ier_val;\n\n\tif (!isr_mask)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < ARRAY_SIZE(bman_hwerr_txts); i++) {\n\t\tif (bman_hwerr_txts[i].mask & isr_mask) {\n\t\t\tdev_err_ratelimited(dev, \"ErrInt: %s\\n\",\n\t\t\t\t\t    bman_hwerr_txts[i].txt);\n\t\t\tif (bman_hwerr_txts[i].mask & ecsr_val) {\n\t\t\t\t \n\t\t\t\tbm_ccsr_out(REG_ECSR, ecsr_val);\n\t\t\t}\n\t\t\tif (bman_hwerr_txts[i].mask & BMAN_ERRS_TO_DISABLE) {\n\t\t\t\tdev_dbg(dev, \"Disabling error 0x%x\\n\",\n\t\t\t\t\tbman_hwerr_txts[i].mask);\n\t\t\t\tier_val &= ~bman_hwerr_txts[i].mask;\n\t\t\t\tbm_ccsr_out(REG_ERR_IER, ier_val);\n\t\t\t}\n\t\t}\n\t}\n\tbm_ccsr_out(REG_ERR_ISR, isr_val);\n\n\treturn IRQ_HANDLED;\n}\n\nint bman_is_probed(void)\n{\n\treturn __bman_probed;\n}\nEXPORT_SYMBOL_GPL(bman_is_probed);\n\nint bman_requires_cleanup(void)\n{\n\treturn __bman_requires_cleanup;\n}\n\nvoid bman_done_cleanup(void)\n{\n\t__bman_requires_cleanup = 0;\n}\n\nstatic int fsl_bman_probe(struct platform_device *pdev)\n{\n\tint ret, err_irq;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct resource *res;\n\tu16 id, bm_pool_cnt;\n\tu8 major, minor;\n\n\t__bman_probed = -1;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"Can't get %pOF property 'IORESOURCE_MEM'\\n\",\n\t\t\tnode);\n\t\treturn -ENXIO;\n\t}\n\tbm_ccsr_start = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!bm_ccsr_start)\n\t\treturn -ENXIO;\n\n\tbm_get_version(&id, &major, &minor);\n\tif (major == 1 && minor == 0) {\n\t\tbman_ip_rev = BMAN_REV10;\n\t\tbm_pool_cnt = BM_POOL_MAX;\n\t} else if (major == 2 && minor == 0) {\n\t\tbman_ip_rev = BMAN_REV20;\n\t\tbm_pool_cnt = 8;\n\t} else if (major == 2 && minor == 1) {\n\t\tbman_ip_rev = BMAN_REV21;\n\t\tbm_pool_cnt = BM_POOL_MAX;\n\t} else {\n\t\tdev_err(dev, \"Unknown Bman version:%04x,%02x,%02x\\n\",\n\t\t\tid, major, minor);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!fbpr_a) {\n\t\tret = qbman_init_private_mem(dev, 0, &fbpr_a, &fbpr_sz);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"qbman_init_private_mem() failed 0x%x\\n\",\n\t\t\t\tret);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"Allocated FBPR 0x%llx 0x%zx\\n\", fbpr_a, fbpr_sz);\n\n\tbm_set_memory(fbpr_a, fbpr_sz);\n\n\terr_irq = platform_get_irq(pdev, 0);\n\tif (err_irq <= 0) {\n\t\tdev_info(dev, \"Can't get %pOF IRQ\\n\", node);\n\t\treturn -ENODEV;\n\t}\n\tret = devm_request_irq(dev, err_irq, bman_isr, IRQF_SHARED, \"bman-err\",\n\t\t\t       dev);\n\tif (ret)  {\n\t\tdev_err(dev, \"devm_request_irq() failed %d for '%pOF'\\n\",\n\t\t\tret, node);\n\t\treturn ret;\n\t}\n\t \n\tbm_ccsr_out(REG_ERR_ISDR, BM_EIRQ_BSCN);\n\t \n\tbm_ccsr_out(REG_ERR_ISR, 0xffffffff);\n\t \n\tbm_ccsr_out(REG_ERR_IER, 0xffffffff);\n\n\tbm_bpalloc = devm_gen_pool_create(dev, 0, -1, \"bman-bpalloc\");\n\tif (IS_ERR(bm_bpalloc)) {\n\t\tret = PTR_ERR(bm_bpalloc);\n\t\tdev_err(dev, \"bman-bpalloc pool init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = gen_pool_add(bm_bpalloc, DPAA_GENALLOC_OFF, bm_pool_cnt, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to seed BPID range [%d..%d] (%d)\\n\",\n\t\t\t0, bm_pool_cnt - 1, ret);\n\t\treturn ret;\n\t}\n\n\t__bman_probed = 1;\n\n\treturn 0;\n};\n\nstatic const struct of_device_id fsl_bman_ids[] = {\n\t{\n\t\t.compatible = \"fsl,bman\",\n\t},\n\t{}\n};\n\nstatic struct platform_driver fsl_bman_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = fsl_bman_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = fsl_bman_probe,\n};\n\nbuiltin_platform_driver(fsl_bman_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}