{
  "module_name": "bman.c",
  "hash_id": "c2700e4880dddd7bf5ec29bfed132fd4299163e068399e1608004f6080d35109",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/bman.c",
  "human_readable_source": " \n\n#include \"bman_priv.h\"\n\n#define IRQNAME\t\t\"BMan portal %d\"\n#define MAX_IRQNAME\t16\t \n\n \n\n#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)\n \n#define BM_REG_RCR_PI_CINH\t0x3000\n#define BM_REG_RCR_CI_CINH\t0x3100\n#define BM_REG_RCR_ITR\t\t0x3200\n#define BM_REG_CFG\t\t0x3300\n#define BM_REG_SCN(n)\t\t(0x3400 + ((n) << 6))\n#define BM_REG_ISR\t\t0x3e00\n#define BM_REG_IER\t\t0x3e40\n#define BM_REG_ISDR\t\t0x3e80\n#define BM_REG_IIR\t\t0x3ec0\n\n \n#define BM_CL_CR\t\t0x0000\n#define BM_CL_RR0\t\t0x0100\n#define BM_CL_RR1\t\t0x0140\n#define BM_CL_RCR\t\t0x1000\n#define BM_CL_RCR_PI_CENA\t0x3000\n#define BM_CL_RCR_CI_CENA\t0x3100\n\n#else\n \n#define BM_REG_RCR_PI_CINH\t0x0000\n#define BM_REG_RCR_CI_CINH\t0x0004\n#define BM_REG_RCR_ITR\t\t0x0008\n#define BM_REG_CFG\t\t0x0100\n#define BM_REG_SCN(n)\t\t(0x0200 + ((n) << 2))\n#define BM_REG_ISR\t\t0x0e00\n#define BM_REG_IER\t\t0x0e04\n#define BM_REG_ISDR\t\t0x0e08\n#define BM_REG_IIR\t\t0x0e0c\n\n \n#define BM_CL_CR\t\t0x0000\n#define BM_CL_RR0\t\t0x0100\n#define BM_CL_RR1\t\t0x0140\n#define BM_CL_RCR\t\t0x1000\n#define BM_CL_RCR_PI_CENA\t0x3000\n#define BM_CL_RCR_CI_CENA\t0x3100\n#endif\n\n \nenum bm_rcr_pmode {\t\t \n\tbm_rcr_pci = 0,\t\t \n\tbm_rcr_pce = 1,\t\t \n\tbm_rcr_pvb = 2\t\t \n};\nenum bm_rcr_cmode {\t\t \n\tbm_rcr_cci,\t\t \n\tbm_rcr_cce\t\t \n};\n\n\n \n\n#define BM_RCR_SIZE\t\t8\n\n \nstruct bm_rcr_entry {\n\tunion {\n\t\tstruct {\n\t\t\tu8 _ncw_verb;  \n\t\t\tu8 bpid;  \n\t\t\tu8 __reserved1[62];\n\t\t};\n\t\tstruct bm_buffer bufs[8];\n\t};\n};\n#define BM_RCR_VERB_VBIT\t\t0x80\n#define BM_RCR_VERB_CMD_MASK\t\t0x70\t \n#define BM_RCR_VERB_CMD_BPID_SINGLE\t0x20\n#define BM_RCR_VERB_CMD_BPID_MULTI\t0x30\n#define BM_RCR_VERB_BUFCOUNT_MASK\t0x0f\t \n\nstruct bm_rcr {\n\tstruct bm_rcr_entry *ring, *cursor;\n\tu8 ci, available, ithresh, vbit;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tu32 busy;\n\tenum bm_rcr_pmode pmode;\n\tenum bm_rcr_cmode cmode;\n#endif\n};\n\n \nstruct bm_mc_command {\n\tu8 _ncw_verb;  \n\tu8 bpid;  \n\tu8 __reserved[62];\n};\n#define BM_MCC_VERB_VBIT\t\t0x80\n#define BM_MCC_VERB_CMD_MASK\t\t0x70\t \n#define BM_MCC_VERB_CMD_ACQUIRE\t\t0x10\n#define BM_MCC_VERB_CMD_QUERY\t\t0x40\n#define BM_MCC_VERB_ACQUIRE_BUFCOUNT\t0x0f\t \n\n \nunion bm_mc_result {\n\tstruct {\n\t\tu8 verb;\n\t\tu8 bpid;\n\t\tu8 __reserved[62];\n\t};\n\tstruct bm_buffer bufs[8];\n};\n#define BM_MCR_VERB_VBIT\t\t0x80\n#define BM_MCR_VERB_CMD_MASK\t\tBM_MCC_VERB_CMD_MASK\n#define BM_MCR_VERB_CMD_ACQUIRE\t\tBM_MCC_VERB_CMD_ACQUIRE\n#define BM_MCR_VERB_CMD_QUERY\t\tBM_MCC_VERB_CMD_QUERY\n#define BM_MCR_VERB_CMD_ERR_INVALID\t0x60\n#define BM_MCR_VERB_CMD_ERR_ECC\t\t0x70\n#define BM_MCR_VERB_ACQUIRE_BUFCOUNT\tBM_MCC_VERB_ACQUIRE_BUFCOUNT  \n#define BM_MCR_TIMEOUT\t\t\t10000  \n\nstruct bm_mc {\n\tstruct bm_mc_command *cr;\n\tunion bm_mc_result *rr;\n\tu8 rridx, vbit;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tenum {\n\t\t \n\t\tmc_idle,\n\t\t \n\t\tmc_user,\n\t\t \n\t\tmc_hw\n\t} state;\n#endif\n};\n\nstruct bm_addr {\n\tvoid *ce;\t\t \n\t__be32 *ce_be;\t\t \n\tvoid __iomem *ci;\t \n};\n\nstruct bm_portal {\n\tstruct bm_addr addr;\n\tstruct bm_rcr rcr;\n\tstruct bm_mc mc;\n} ____cacheline_aligned;\n\n \nstatic inline u32 bm_in(struct bm_portal *p, u32 offset)\n{\n\treturn ioread32be(p->addr.ci + offset);\n}\n\nstatic inline void bm_out(struct bm_portal *p, u32 offset, u32 val)\n{\n\tiowrite32be(val, p->addr.ci + offset);\n}\n\n \nstatic inline void bm_cl_invalidate(struct bm_portal *p, u32 offset)\n{\n\tdpaa_invalidate(p->addr.ce + offset);\n}\n\nstatic inline void bm_cl_touch_ro(struct bm_portal *p, u32 offset)\n{\n\tdpaa_touch_ro(p->addr.ce + offset);\n}\n\nstatic inline u32 bm_ce_in(struct bm_portal *p, u32 offset)\n{\n\treturn be32_to_cpu(*(p->addr.ce_be + (offset/4)));\n}\n\nstruct bman_portal {\n\tstruct bm_portal p;\n\t \n\tunsigned long irq_sources;\n\t \n\tconst struct bm_portal_config *config;\n\tchar irqname[MAX_IRQNAME];\n};\n\nstatic cpumask_t affine_mask;\nstatic DEFINE_SPINLOCK(affine_mask_lock);\nstatic DEFINE_PER_CPU(struct bman_portal, bman_affine_portal);\n\nstatic inline struct bman_portal *get_affine_portal(void)\n{\n\treturn &get_cpu_var(bman_affine_portal);\n}\n\nstatic inline void put_affine_portal(void)\n{\n\tput_cpu_var(bman_affine_portal);\n}\n\n \nstruct bman_pool {\n\t \n\tu32 bpid;\n\t \n\tstruct bman_portal *portal;\n\tstruct bman_pool *next;\n};\n\nstatic u32 poll_portal_slow(struct bman_portal *p, u32 is);\n\nstatic irqreturn_t portal_isr(int irq, void *ptr)\n{\n\tstruct bman_portal *p = ptr;\n\tstruct bm_portal *portal = &p->p;\n\tu32 clear = p->irq_sources;\n\tu32 is = bm_in(portal, BM_REG_ISR) & p->irq_sources;\n\n\tif (unlikely(!is))\n\t\treturn IRQ_NONE;\n\n\tclear |= poll_portal_slow(p, is);\n\tbm_out(portal, BM_REG_ISR, clear);\n\treturn IRQ_HANDLED;\n}\n\n \n\n#define RCR_SHIFT\tilog2(sizeof(struct bm_rcr_entry))\n#define RCR_CARRY\t(uintptr_t)(BM_RCR_SIZE << RCR_SHIFT)\n\n \nstatic struct bm_rcr_entry *rcr_carryclear(struct bm_rcr_entry *p)\n{\n\tuintptr_t addr = (uintptr_t)p;\n\n\taddr &= ~RCR_CARRY;\n\n\treturn (struct bm_rcr_entry *)addr;\n}\n\n#ifdef CONFIG_FSL_DPAA_CHECKING\n \nstatic int rcr_ptr2idx(struct bm_rcr_entry *e)\n{\n\treturn ((uintptr_t)e >> RCR_SHIFT) & (BM_RCR_SIZE - 1);\n}\n#endif\n\n \nstatic inline void rcr_inc(struct bm_rcr *rcr)\n{\n\t \n\tstruct bm_rcr_entry *partial = rcr->cursor + 1;\n\n\trcr->cursor = rcr_carryclear(partial);\n\tif (partial != rcr->cursor)\n\t\trcr->vbit ^= BM_RCR_VERB_VBIT;\n}\n\nstatic int bm_rcr_get_avail(struct bm_portal *portal)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\n\treturn rcr->available;\n}\n\nstatic int bm_rcr_get_fill(struct bm_portal *portal)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\n\treturn BM_RCR_SIZE - 1 - rcr->available;\n}\n\nstatic void bm_rcr_set_ithresh(struct bm_portal *portal, u8 ithresh)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\n\trcr->ithresh = ithresh;\n\tbm_out(portal, BM_REG_RCR_ITR, ithresh);\n}\n\nstatic void bm_rcr_cce_prefetch(struct bm_portal *portal)\n{\n\t__maybe_unused struct bm_rcr *rcr = &portal->rcr;\n\n\tDPAA_ASSERT(rcr->cmode == bm_rcr_cce);\n\tbm_cl_touch_ro(portal, BM_CL_RCR_CI_CENA);\n}\n\nstatic u8 bm_rcr_cce_update(struct bm_portal *portal)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\tu8 diff, old_ci = rcr->ci;\n\n\tDPAA_ASSERT(rcr->cmode == bm_rcr_cce);\n\trcr->ci = bm_ce_in(portal, BM_CL_RCR_CI_CENA) & (BM_RCR_SIZE - 1);\n\tbm_cl_invalidate(portal, BM_CL_RCR_CI_CENA);\n\tdiff = dpaa_cyc_diff(BM_RCR_SIZE, old_ci, rcr->ci);\n\trcr->available += diff;\n\treturn diff;\n}\n\nstatic inline struct bm_rcr_entry *bm_rcr_start(struct bm_portal *portal)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\n\tDPAA_ASSERT(!rcr->busy);\n\tif (!rcr->available)\n\t\treturn NULL;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\trcr->busy = 1;\n#endif\n\tdpaa_zero(rcr->cursor);\n\treturn rcr->cursor;\n}\n\nstatic inline void bm_rcr_pvb_commit(struct bm_portal *portal, u8 myverb)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\tstruct bm_rcr_entry *rcursor;\n\n\tDPAA_ASSERT(rcr->busy);\n\tDPAA_ASSERT(rcr->pmode == bm_rcr_pvb);\n\tDPAA_ASSERT(rcr->available >= 1);\n\tdma_wmb();\n\trcursor = rcr->cursor;\n\trcursor->_ncw_verb = myverb | rcr->vbit;\n\tdpaa_flush(rcursor);\n\trcr_inc(rcr);\n\trcr->available--;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\trcr->busy = 0;\n#endif\n}\n\nstatic int bm_rcr_init(struct bm_portal *portal, enum bm_rcr_pmode pmode,\n\t\t       enum bm_rcr_cmode cmode)\n{\n\tstruct bm_rcr *rcr = &portal->rcr;\n\tu32 cfg;\n\tu8 pi;\n\n\trcr->ring = portal->addr.ce + BM_CL_RCR;\n\trcr->ci = bm_in(portal, BM_REG_RCR_CI_CINH) & (BM_RCR_SIZE - 1);\n\tpi = bm_in(portal, BM_REG_RCR_PI_CINH) & (BM_RCR_SIZE - 1);\n\trcr->cursor = rcr->ring + pi;\n\trcr->vbit = (bm_in(portal, BM_REG_RCR_PI_CINH) & BM_RCR_SIZE) ?\n\t\tBM_RCR_VERB_VBIT : 0;\n\trcr->available = BM_RCR_SIZE - 1\n\t\t- dpaa_cyc_diff(BM_RCR_SIZE, rcr->ci, pi);\n\trcr->ithresh = bm_in(portal, BM_REG_RCR_ITR);\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\trcr->busy = 0;\n\trcr->pmode = pmode;\n\trcr->cmode = cmode;\n#endif\n\tcfg = (bm_in(portal, BM_REG_CFG) & 0xffffffe0)\n\t\t| (pmode & 0x3);  \n\tbm_out(portal, BM_REG_CFG, cfg);\n\treturn 0;\n}\n\nstatic void bm_rcr_finish(struct bm_portal *portal)\n{\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tstruct bm_rcr *rcr = &portal->rcr;\n\tint i;\n\n\tDPAA_ASSERT(!rcr->busy);\n\n\ti = bm_in(portal, BM_REG_RCR_PI_CINH) & (BM_RCR_SIZE - 1);\n\tif (i != rcr_ptr2idx(rcr->cursor))\n\t\tpr_crit(\"losing uncommitted RCR entries\\n\");\n\n\ti = bm_in(portal, BM_REG_RCR_CI_CINH) & (BM_RCR_SIZE - 1);\n\tif (i != rcr->ci)\n\t\tpr_crit(\"missing existing RCR completions\\n\");\n\tif (rcr->ci != rcr_ptr2idx(rcr->cursor))\n\t\tpr_crit(\"RCR destroyed unquiesced\\n\");\n#endif\n}\n\n \nstatic int bm_mc_init(struct bm_portal *portal)\n{\n\tstruct bm_mc *mc = &portal->mc;\n\n\tmc->cr = portal->addr.ce + BM_CL_CR;\n\tmc->rr = portal->addr.ce + BM_CL_RR0;\n\tmc->rridx = (mc->cr->_ncw_verb & BM_MCC_VERB_VBIT) ?\n\t\t    0 : 1;\n\tmc->vbit = mc->rridx ? BM_MCC_VERB_VBIT : 0;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tmc->state = mc_idle;\n#endif\n\treturn 0;\n}\n\nstatic void bm_mc_finish(struct bm_portal *portal)\n{\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tstruct bm_mc *mc = &portal->mc;\n\n\tDPAA_ASSERT(mc->state == mc_idle);\n\tif (mc->state != mc_idle)\n\t\tpr_crit(\"Losing incomplete MC command\\n\");\n#endif\n}\n\nstatic inline struct bm_mc_command *bm_mc_start(struct bm_portal *portal)\n{\n\tstruct bm_mc *mc = &portal->mc;\n\n\tDPAA_ASSERT(mc->state == mc_idle);\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tmc->state = mc_user;\n#endif\n\tdpaa_zero(mc->cr);\n\treturn mc->cr;\n}\n\nstatic inline void bm_mc_commit(struct bm_portal *portal, u8 myverb)\n{\n\tstruct bm_mc *mc = &portal->mc;\n\tunion bm_mc_result *rr = mc->rr + mc->rridx;\n\n\tDPAA_ASSERT(mc->state == mc_user);\n\tdma_wmb();\n\tmc->cr->_ncw_verb = myverb | mc->vbit;\n\tdpaa_flush(mc->cr);\n\tdpaa_invalidate_touch_ro(rr);\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tmc->state = mc_hw;\n#endif\n}\n\nstatic inline union bm_mc_result *bm_mc_result(struct bm_portal *portal)\n{\n\tstruct bm_mc *mc = &portal->mc;\n\tunion bm_mc_result *rr = mc->rr + mc->rridx;\n\n\tDPAA_ASSERT(mc->state == mc_hw);\n\t \n\tif (!rr->verb) {\n\t\tdpaa_invalidate_touch_ro(rr);\n\t\treturn NULL;\n\t}\n\tmc->rridx ^= 1;\n\tmc->vbit ^= BM_MCC_VERB_VBIT;\n#ifdef CONFIG_FSL_DPAA_CHECKING\n\tmc->state = mc_idle;\n#endif\n\treturn rr;\n}\n\nstatic inline int bm_mc_result_timeout(struct bm_portal *portal,\n\t\t\t\t       union bm_mc_result **mcr)\n{\n\tint timeout = BM_MCR_TIMEOUT;\n\n\tdo {\n\t\t*mcr = bm_mc_result(portal);\n\t\tif (*mcr)\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--timeout);\n\n\treturn timeout;\n}\n\n \nstatic void bm_isr_bscn_disable(struct bm_portal *portal)\n{\n\tbm_out(portal, BM_REG_SCN(0), 0);\n\tbm_out(portal, BM_REG_SCN(1), 0);\n}\n\nstatic int bman_create_portal(struct bman_portal *portal,\n\t\t\t      const struct bm_portal_config *c)\n{\n\tstruct bm_portal *p;\n\tint ret;\n\n\tp = &portal->p;\n\t \n\tp->addr.ce = c->addr_virt_ce;\n\tp->addr.ce_be = c->addr_virt_ce;\n\tp->addr.ci = c->addr_virt_ci;\n\tif (bm_rcr_init(p, bm_rcr_pvb, bm_rcr_cce)) {\n\t\tdev_err(c->dev, \"RCR initialisation failed\\n\");\n\t\tgoto fail_rcr;\n\t}\n\tif (bm_mc_init(p)) {\n\t\tdev_err(c->dev, \"MC initialisation failed\\n\");\n\t\tgoto fail_mc;\n\t}\n\t \n\tbm_isr_bscn_disable(p);\n\n\t \n\tbm_out(p, BM_REG_ISDR, 0xffffffff);\n\tportal->irq_sources = 0;\n\tbm_out(p, BM_REG_IER, 0);\n\tbm_out(p, BM_REG_ISR, 0xffffffff);\n\tsnprintf(portal->irqname, MAX_IRQNAME, IRQNAME, c->cpu);\n\tif (request_irq(c->irq, portal_isr, 0, portal->irqname,\tportal)) {\n\t\tdev_err(c->dev, \"request_irq() failed\\n\");\n\t\tgoto fail_irq;\n\t}\n\n\tif (dpaa_set_portal_irq_affinity(c->dev, c->irq, c->cpu))\n\t\tgoto fail_affinity;\n\n\t \n\tret = bm_rcr_get_fill(p);\n\tif (ret) {\n\t\tdev_err(c->dev, \"RCR unclean\\n\");\n\t\tgoto fail_rcr_empty;\n\t}\n\t \n\tportal->config = c;\n\n\tbm_out(p, BM_REG_ISDR, 0);\n\tbm_out(p, BM_REG_IIR, 0);\n\n\treturn 0;\n\nfail_rcr_empty:\nfail_affinity:\n\tfree_irq(c->irq, portal);\nfail_irq:\n\tbm_mc_finish(p);\nfail_mc:\n\tbm_rcr_finish(p);\nfail_rcr:\n\treturn -EIO;\n}\n\nstruct bman_portal *bman_create_affine_portal(const struct bm_portal_config *c)\n{\n\tstruct bman_portal *portal;\n\tint err;\n\n\tportal = &per_cpu(bman_affine_portal, c->cpu);\n\terr = bman_create_portal(portal, c);\n\tif (err)\n\t\treturn NULL;\n\n\tspin_lock(&affine_mask_lock);\n\tcpumask_set_cpu(c->cpu, &affine_mask);\n\tspin_unlock(&affine_mask_lock);\n\n\treturn portal;\n}\n\nstatic u32 poll_portal_slow(struct bman_portal *p, u32 is)\n{\n\tu32 ret = is;\n\n\tif (is & BM_PIRQ_RCRI) {\n\t\tbm_rcr_cce_update(&p->p);\n\t\tbm_rcr_set_ithresh(&p->p, 0);\n\t\tbm_out(&p->p, BM_REG_ISR, BM_PIRQ_RCRI);\n\t\tis &= ~BM_PIRQ_RCRI;\n\t}\n\n\t \n\tDPAA_ASSERT(!is);\n\treturn ret;\n}\n\nint bman_p_irqsource_add(struct bman_portal *p, u32 bits)\n{\n\tunsigned long irqflags;\n\n\tlocal_irq_save(irqflags);\n\tp->irq_sources |= bits & BM_PIRQ_VISIBLE;\n\tbm_out(&p->p, BM_REG_IER, p->irq_sources);\n\tlocal_irq_restore(irqflags);\n\treturn 0;\n}\n\nint bm_shutdown_pool(u32 bpid)\n{\n\tint err = 0;\n\tstruct bm_mc_command *bm_cmd;\n\tunion bm_mc_result *bm_res;\n\n\n\tstruct bman_portal *p = get_affine_portal();\n\twhile (1) {\n\t\t \n\t\tbm_cmd = bm_mc_start(&p->p);\n\t\tbm_cmd->bpid = bpid;\n\t\tbm_mc_commit(&p->p, BM_MCC_VERB_CMD_ACQUIRE | 1);\n\t\tif (!bm_mc_result_timeout(&p->p, &bm_res)) {\n\t\t\tpr_crit(\"BMan Acquire Command timedout\\n\");\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto done;\n\t\t}\n\t\tif (!(bm_res->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT)) {\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tput_affine_portal();\n\treturn err;\n}\n\nstruct gen_pool *bm_bpalloc;\n\nstatic int bm_alloc_bpid_range(u32 *result, u32 count)\n{\n\tunsigned long addr;\n\n\taddr = gen_pool_alloc(bm_bpalloc, count);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\t*result = addr & ~DPAA_GENALLOC_OFF;\n\n\treturn 0;\n}\n\nstatic int bm_release_bpid(u32 bpid)\n{\n\tint ret;\n\n\tret = bm_shutdown_pool(bpid);\n\tif (ret) {\n\t\tpr_debug(\"BPID %d leaked\\n\", bpid);\n\t\treturn ret;\n\t}\n\n\tgen_pool_free(bm_bpalloc, bpid | DPAA_GENALLOC_OFF, 1);\n\treturn 0;\n}\n\nstruct bman_pool *bman_new_pool(void)\n{\n\tstruct bman_pool *pool = NULL;\n\tu32 bpid;\n\n\tif (bm_alloc_bpid_range(&bpid, 1))\n\t\treturn NULL;\n\n\tpool = kmalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\tgoto err;\n\n\tpool->bpid = bpid;\n\n\treturn pool;\nerr:\n\tbm_release_bpid(bpid);\n\treturn NULL;\n}\nEXPORT_SYMBOL(bman_new_pool);\n\nvoid bman_free_pool(struct bman_pool *pool)\n{\n\tbm_release_bpid(pool->bpid);\n\n\tkfree(pool);\n}\nEXPORT_SYMBOL(bman_free_pool);\n\nint bman_get_bpid(const struct bman_pool *pool)\n{\n\treturn pool->bpid;\n}\nEXPORT_SYMBOL(bman_get_bpid);\n\nstatic void update_rcr_ci(struct bman_portal *p, int avail)\n{\n\tif (avail)\n\t\tbm_rcr_cce_prefetch(&p->p);\n\telse\n\t\tbm_rcr_cce_update(&p->p);\n}\n\nint bman_release(struct bman_pool *pool, const struct bm_buffer *bufs, u8 num)\n{\n\tstruct bman_portal *p;\n\tstruct bm_rcr_entry *r;\n\tunsigned long irqflags;\n\tint avail, timeout = 1000;  \n\tint i = num - 1;\n\n\tDPAA_ASSERT(num > 0 && num <= 8);\n\n\tdo {\n\t\tp = get_affine_portal();\n\t\tlocal_irq_save(irqflags);\n\t\tavail = bm_rcr_get_avail(&p->p);\n\t\tif (avail < 2)\n\t\t\tupdate_rcr_ci(p, avail);\n\t\tr = bm_rcr_start(&p->p);\n\t\tlocal_irq_restore(irqflags);\n\t\tput_affine_portal();\n\t\tif (likely(r))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t} while (--timeout);\n\n\tif (unlikely(!timeout))\n\t\treturn -ETIMEDOUT;\n\n\tp = get_affine_portal();\n\tlocal_irq_save(irqflags);\n\t \n\tbm_buffer_set64(r->bufs, bm_buffer_get64(bufs));\n\tbm_buffer_set_bpid(r->bufs, pool->bpid);\n\tif (i)\n\t\tmemcpy(&r->bufs[1], &bufs[1], i * sizeof(bufs[0]));\n\n\tbm_rcr_pvb_commit(&p->p, BM_RCR_VERB_CMD_BPID_SINGLE |\n\t\t\t  (num & BM_RCR_VERB_BUFCOUNT_MASK));\n\n\tlocal_irq_restore(irqflags);\n\tput_affine_portal();\n\treturn 0;\n}\nEXPORT_SYMBOL(bman_release);\n\nint bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num)\n{\n\tstruct bman_portal *p = get_affine_portal();\n\tstruct bm_mc_command *mcc;\n\tunion bm_mc_result *mcr;\n\tint ret;\n\n\tDPAA_ASSERT(num > 0 && num <= 8);\n\n\tmcc = bm_mc_start(&p->p);\n\tmcc->bpid = pool->bpid;\n\tbm_mc_commit(&p->p, BM_MCC_VERB_CMD_ACQUIRE |\n\t\t     (num & BM_MCC_VERB_ACQUIRE_BUFCOUNT));\n\tif (!bm_mc_result_timeout(&p->p, &mcr)) {\n\t\tput_affine_portal();\n\t\tpr_crit(\"BMan Acquire Timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tret = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;\n\tif (bufs)\n\t\tmemcpy(&bufs[0], &mcr->bufs[0], num * sizeof(bufs[0]));\n\n\tput_affine_portal();\n\tif (ret != num)\n\t\tret = -ENOMEM;\n\treturn ret;\n}\nEXPORT_SYMBOL(bman_acquire);\n\nconst struct bm_portal_config *\nbman_get_bm_portal_config(const struct bman_portal *portal)\n{\n\treturn portal->config;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}