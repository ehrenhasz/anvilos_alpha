{
  "module_name": "qman_ccsr.c",
  "hash_id": "95cb38f526d679f3dd5ddc55fe7793b5ba8319210fa3024df64ae20edb580353",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/qman_ccsr.c",
  "human_readable_source": " \n\n#include \"qman_priv.h\"\n\nu16 qman_ip_rev;\nEXPORT_SYMBOL(qman_ip_rev);\nu16 qm_channel_pool1 = QMAN_CHANNEL_POOL1;\nEXPORT_SYMBOL(qm_channel_pool1);\nu16 qm_channel_caam = QMAN_CHANNEL_CAAM;\nEXPORT_SYMBOL(qm_channel_caam);\n\n \n#define REG_QCSP_LIO_CFG(n)\t(0x0000 + ((n) * 0x10))\n#define REG_QCSP_IO_CFG(n)\t(0x0004 + ((n) * 0x10))\n#define REG_QCSP_DD_CFG(n)\t(0x000c + ((n) * 0x10))\n#define REG_DD_CFG\t\t0x0200\n#define REG_DCP_CFG(n)\t\t(0x0300 + ((n) * 0x10))\n#define REG_DCP_DD_CFG(n)\t(0x0304 + ((n) * 0x10))\n#define REG_DCP_DLM_AVG(n)\t(0x030c + ((n) * 0x10))\n#define REG_PFDR_FPC\t\t0x0400\n#define REG_PFDR_FP_HEAD\t0x0404\n#define REG_PFDR_FP_TAIL\t0x0408\n#define REG_PFDR_FP_LWIT\t0x0410\n#define REG_PFDR_CFG\t\t0x0414\n#define REG_SFDR_CFG\t\t0x0500\n#define REG_SFDR_IN_USE\t\t0x0504\n#define REG_WQ_CS_CFG(n)\t(0x0600 + ((n) * 0x04))\n#define REG_WQ_DEF_ENC_WQID\t0x0630\n#define REG_WQ_SC_DD_CFG(n)\t(0x640 + ((n) * 0x04))\n#define REG_WQ_PC_DD_CFG(n)\t(0x680 + ((n) * 0x04))\n#define REG_WQ_DC0_DD_CFG(n)\t(0x6c0 + ((n) * 0x04))\n#define REG_WQ_DC1_DD_CFG(n)\t(0x700 + ((n) * 0x04))\n#define REG_WQ_DCn_DD_CFG(n)\t(0x6c0 + ((n) * 0x40))  \n#define REG_CM_CFG\t\t0x0800\n#define REG_ECSR\t\t0x0a00\n#define REG_ECIR\t\t0x0a04\n#define REG_EADR\t\t0x0a08\n#define REG_ECIR2\t\t0x0a0c\n#define REG_EDATA(n)\t\t(0x0a10 + ((n) * 0x04))\n#define REG_SBEC(n)\t\t(0x0a80 + ((n) * 0x04))\n#define REG_MCR\t\t\t0x0b00\n#define REG_MCP(n)\t\t(0x0b04 + ((n) * 0x04))\n#define REG_MISC_CFG\t\t0x0be0\n#define REG_HID_CFG\t\t0x0bf0\n#define REG_IDLE_STAT\t\t0x0bf4\n#define REG_IP_REV_1\t\t0x0bf8\n#define REG_IP_REV_2\t\t0x0bfc\n#define REG_FQD_BARE\t\t0x0c00\n#define REG_PFDR_BARE\t\t0x0c20\n#define REG_offset_BAR\t\t0x0004\t \n#define REG_offset_AR\t\t0x0010\t \n#define REG_QCSP_BARE\t\t0x0c80\n#define REG_QCSP_BAR\t\t0x0c84\n#define REG_CI_SCHED_CFG\t0x0d00\n#define REG_SRCIDR\t\t0x0d04\n#define REG_LIODNR\t\t0x0d08\n#define REG_CI_RLM_AVG\t\t0x0d14\n#define REG_ERR_ISR\t\t0x0e00\n#define REG_ERR_IER\t\t0x0e04\n#define REG_REV3_QCSP_LIO_CFG(n)\t(0x1000 + ((n) * 0x10))\n#define REG_REV3_QCSP_IO_CFG(n)\t(0x1004 + ((n) * 0x10))\n#define REG_REV3_QCSP_DD_CFG(n)\t(0x100c + ((n) * 0x10))\n\n \n#define MCR_INIT_PFDR\t\t0x01000000\n#define MCR_get_rslt(v)\t\t(u8)((v) >> 24)\n#define MCR_rslt_idle(r)\t(!(r) || ((r) >= 0xf0))\n#define MCR_rslt_ok(r)\t\t((r) == 0xf0)\n#define MCR_rslt_eaccess(r)\t((r) == 0xf8)\n#define MCR_rslt_inval(r)\t((r) == 0xff)\n\n \n#define QM_CI_SCHED_CFG_SRCCIV\t\t4\n#define QM_CI_SCHED_CFG_SRQ_W\t\t3\n#define QM_CI_SCHED_CFG_RW_W\t\t2\n#define QM_CI_SCHED_CFG_BMAN_W\t\t2\n \n#define QM_CI_SCHED_CFG_SRCCIV_EN\tBIT(31)\n\n \nenum qm_wq_class {\n\tqm_wq_portal = 0,\n\tqm_wq_pool = 1,\n\tqm_wq_fman0 = 2,\n\tqm_wq_fman1 = 3,\n\tqm_wq_caam = 4,\n\tqm_wq_pme = 5,\n\tqm_wq_first = qm_wq_portal,\n\tqm_wq_last = qm_wq_pme\n};\n\n \nenum qm_memory {\n\tqm_memory_fqd,\n\tqm_memory_pfdr\n};\n\n \n#define QM_EIRQ_CIDE\t0x20000000\t \n#define QM_EIRQ_CTDE\t0x10000000\t \n#define QM_EIRQ_CITT\t0x08000000\t \n#define QM_EIRQ_PLWI\t0x04000000\t \n#define QM_EIRQ_MBEI\t0x02000000\t \n#define QM_EIRQ_SBEI\t0x01000000\t \n#define QM_EIRQ_PEBI\t0x00800000\t \n#define QM_EIRQ_IFSI\t0x00020000\t \n#define QM_EIRQ_ICVI\t0x00010000\t \n#define QM_EIRQ_IDDI\t0x00000800\t \n#define QM_EIRQ_IDFI\t0x00000400\t \n#define QM_EIRQ_IDSI\t0x00000200\t \n#define QM_EIRQ_IDQI\t0x00000100\t \n#define QM_EIRQ_IECE\t0x00000010\t \n#define QM_EIRQ_IEOI\t0x00000008\t \n#define QM_EIRQ_IESI\t0x00000004\t \n#define QM_EIRQ_IECI\t0x00000002\t \n#define QM_EIRQ_IEQI\t0x00000001\t \n\n \n#define PORTAL_ECSR_ERR\t(QM_EIRQ_IEQI | QM_EIRQ_IESI | QM_EIRQ_IEOI | \\\n\t\t\t QM_EIRQ_IDQI | QM_EIRQ_IDSI | QM_EIRQ_IDFI | \\\n\t\t\t QM_EIRQ_IDDI | QM_EIRQ_ICVI | QM_EIRQ_IFSI)\n#define FQID_ECSR_ERR\t(QM_EIRQ_IEQI | QM_EIRQ_IECI | QM_EIRQ_IESI | \\\n\t\t\t QM_EIRQ_IEOI | QM_EIRQ_IDQI | QM_EIRQ_IDFI | \\\n\t\t\t QM_EIRQ_IFSI)\n\nstruct qm_ecir {\n\tu32 info;  \n};\n\nstatic bool qm_ecir_is_dcp(const struct qm_ecir *p)\n{\n\treturn p->info & BIT(29);\n}\n\nstatic int qm_ecir_get_pnum(const struct qm_ecir *p)\n{\n\treturn (p->info >> 24) & 0x1f;\n}\n\nstatic int qm_ecir_get_fqid(const struct qm_ecir *p)\n{\n\treturn p->info & (BIT(24) - 1);\n}\n\nstruct qm_ecir2 {\n\tu32 info;  \n};\n\nstatic bool qm_ecir2_is_dcp(const struct qm_ecir2 *p)\n{\n\treturn p->info & BIT(31);\n}\n\nstatic int qm_ecir2_get_pnum(const struct qm_ecir2 *p)\n{\n\treturn p->info & (BIT(10) - 1);\n}\n\nstruct qm_eadr {\n\tu32 info;  \n\t\t   \n};\n\nstatic int qm_eadr_get_memid(const struct qm_eadr *p)\n{\n\treturn (p->info >> 24) & 0xf;\n}\n\nstatic int qm_eadr_get_eadr(const struct qm_eadr *p)\n{\n\treturn p->info & (BIT(12) - 1);\n}\n\nstatic int qm_eadr_v3_get_memid(const struct qm_eadr *p)\n{\n\treturn (p->info >> 24) & 0x1f;\n}\n\nstatic int qm_eadr_v3_get_eadr(const struct qm_eadr *p)\n{\n\treturn p->info & (BIT(16) - 1);\n}\n\nstruct qman_hwerr_txt {\n\tu32 mask;\n\tconst char *txt;\n};\n\n\nstatic const struct qman_hwerr_txt qman_hwerr_txts[] = {\n\t{ QM_EIRQ_CIDE, \"Corenet Initiator Data Error\" },\n\t{ QM_EIRQ_CTDE, \"Corenet Target Data Error\" },\n\t{ QM_EIRQ_CITT, \"Corenet Invalid Target Transaction\" },\n\t{ QM_EIRQ_PLWI, \"PFDR Low Watermark\" },\n\t{ QM_EIRQ_MBEI, \"Multi-bit ECC Error\" },\n\t{ QM_EIRQ_SBEI, \"Single-bit ECC Error\" },\n\t{ QM_EIRQ_PEBI, \"PFDR Enqueues Blocked Interrupt\" },\n\t{ QM_EIRQ_ICVI, \"Invalid Command Verb\" },\n\t{ QM_EIRQ_IFSI, \"Invalid Flow Control State\" },\n\t{ QM_EIRQ_IDDI, \"Invalid Dequeue (Direct-connect)\" },\n\t{ QM_EIRQ_IDFI, \"Invalid Dequeue FQ\" },\n\t{ QM_EIRQ_IDSI, \"Invalid Dequeue Source\" },\n\t{ QM_EIRQ_IDQI, \"Invalid Dequeue Queue\" },\n\t{ QM_EIRQ_IECE, \"Invalid Enqueue Configuration\" },\n\t{ QM_EIRQ_IEOI, \"Invalid Enqueue Overflow\" },\n\t{ QM_EIRQ_IESI, \"Invalid Enqueue State\" },\n\t{ QM_EIRQ_IECI, \"Invalid Enqueue Channel\" },\n\t{ QM_EIRQ_IEQI, \"Invalid Enqueue Queue\" },\n};\n\nstruct qman_error_info_mdata {\n\tu16 addr_mask;\n\tu16 bits;\n\tconst char *txt;\n};\n\nstatic const struct qman_error_info_mdata error_mdata[] = {\n\t{ 0x01FF, 24, \"FQD cache tag memory 0\" },\n\t{ 0x01FF, 24, \"FQD cache tag memory 1\" },\n\t{ 0x01FF, 24, \"FQD cache tag memory 2\" },\n\t{ 0x01FF, 24, \"FQD cache tag memory 3\" },\n\t{ 0x0FFF, 512, \"FQD cache memory\" },\n\t{ 0x07FF, 128, \"SFDR memory\" },\n\t{ 0x01FF, 72, \"WQ context memory\" },\n\t{ 0x00FF, 240, \"CGR memory\" },\n\t{ 0x00FF, 302, \"Internal Order Restoration List memory\" },\n\t{ 0x01FF, 256, \"SW portal ring memory\" },\n};\n\n#define QMAN_ERRS_TO_DISABLE (QM_EIRQ_PLWI | QM_EIRQ_PEBI)\n\n \n\n \nstatic u32 __iomem *qm_ccsr_start;\n \nstatic u32 qm_pools_sdqcr;\nstatic int __qman_probed;\nstatic int  __qman_requires_cleanup;\n\nstatic inline u32 qm_ccsr_in(u32 offset)\n{\n\treturn ioread32be(qm_ccsr_start + offset/4);\n}\n\nstatic inline void qm_ccsr_out(u32 offset, u32 val)\n{\n\tiowrite32be(val, qm_ccsr_start + offset/4);\n}\n\nu32 qm_get_pools_sdqcr(void)\n{\n\treturn qm_pools_sdqcr;\n}\n\nenum qm_dc_portal {\n\tqm_dc_portal_fman0 = 0,\n\tqm_dc_portal_fman1 = 1\n};\n\nstatic void qm_set_dc(enum qm_dc_portal portal, int ed, u8 sernd)\n{\n\tDPAA_ASSERT(!ed || portal == qm_dc_portal_fman0 ||\n\t\t    portal == qm_dc_portal_fman1);\n\tif ((qman_ip_rev & 0xFF00) >= QMAN_REV30)\n\t\tqm_ccsr_out(REG_DCP_CFG(portal),\n\t\t\t    (ed ? 0x1000 : 0) | (sernd & 0x3ff));\n\telse\n\t\tqm_ccsr_out(REG_DCP_CFG(portal),\n\t\t\t    (ed ? 0x100 : 0) | (sernd & 0x1f));\n}\n\nstatic void qm_set_wq_scheduling(enum qm_wq_class wq_class,\n\t\t\t\t u8 cs_elev, u8 csw2, u8 csw3, u8 csw4,\n\t\t\t\t u8 csw5, u8 csw6, u8 csw7)\n{\n\tqm_ccsr_out(REG_WQ_CS_CFG(wq_class), ((cs_elev & 0xff) << 24) |\n\t\t    ((csw2 & 0x7) << 20) | ((csw3 & 0x7) << 16) |\n\t\t    ((csw4 & 0x7) << 12) | ((csw5 & 0x7) << 8) |\n\t\t    ((csw6 & 0x7) << 4) | (csw7 & 0x7));\n}\n\nstatic void qm_set_hid(void)\n{\n\tqm_ccsr_out(REG_HID_CFG, 0);\n}\n\nstatic void qm_set_corenet_initiator(void)\n{\n\tqm_ccsr_out(REG_CI_SCHED_CFG, QM_CI_SCHED_CFG_SRCCIV_EN |\n\t\t    (QM_CI_SCHED_CFG_SRCCIV << 24) |\n\t\t    (QM_CI_SCHED_CFG_SRQ_W << 8) |\n\t\t    (QM_CI_SCHED_CFG_RW_W << 4) |\n\t\t    QM_CI_SCHED_CFG_BMAN_W);\n}\n\nstatic void qm_get_version(u16 *id, u8 *major, u8 *minor)\n{\n\tu32 v = qm_ccsr_in(REG_IP_REV_1);\n\t*id = (v >> 16);\n\t*major = (v >> 8) & 0xff;\n\t*minor = v & 0xff;\n}\n\n#define PFDR_AR_EN\t\tBIT(31)\nstatic int qm_set_memory(enum qm_memory memory, u64 ba, u32 size)\n{\n\tvoid *ptr;\n\tu32 offset = (memory == qm_memory_fqd) ? REG_FQD_BARE : REG_PFDR_BARE;\n\tu32 exp = ilog2(size);\n\tu32 bar, bare;\n\n\t \n\tDPAA_ASSERT((size >= 4096) && (size <= 1024*1024*1024) &&\n\t\t    is_power_of_2(size));\n\t \n\tDPAA_ASSERT(!(ba & (size - 1)));\n\n\t \n\tbar = qm_ccsr_in(offset + REG_offset_BAR);\n\tif (bar) {\n\t\t \n\t\tbare = qm_ccsr_in(offset);\n\t\tif (bare != upper_32_bits(ba) || bar != lower_32_bits(ba)) {\n\t\t\tpr_err(\"Attempted to reinitialize QMan with different BAR, got 0x%llx read BARE=0x%x BAR=0x%x\\n\",\n\t\t\t       ba, bare, bar);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t__qman_requires_cleanup = 1;\n\t\t \n\t\treturn 1;\n\t}\n\t \n\tptr = memremap(ba, size, MEMREMAP_WB);\n\tif (!ptr) {\n\t\tpr_crit(\"memremap() of QMan private memory failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ptr, 0, size);\n\n#ifdef CONFIG_PPC\n\t \n\tflush_dcache_range((unsigned long) ptr, (unsigned long) ptr+size);\n#endif\n\tmemunmap(ptr);\n\n\tqm_ccsr_out(offset, upper_32_bits(ba));\n\tqm_ccsr_out(offset + REG_offset_BAR, lower_32_bits(ba));\n\tqm_ccsr_out(offset + REG_offset_AR, PFDR_AR_EN | (exp - 1));\n\treturn 0;\n}\n\nstatic void qm_set_pfdr_threshold(u32 th, u8 k)\n{\n\tqm_ccsr_out(REG_PFDR_FP_LWIT, th & 0xffffff);\n\tqm_ccsr_out(REG_PFDR_CFG, k);\n}\n\nstatic void qm_set_sfdr_threshold(u16 th)\n{\n\tqm_ccsr_out(REG_SFDR_CFG, th & 0x3ff);\n}\n\nstatic int qm_init_pfdr(struct device *dev, u32 pfdr_start, u32 num)\n{\n\tu8 rslt = MCR_get_rslt(qm_ccsr_in(REG_MCR));\n\n\tDPAA_ASSERT(pfdr_start && !(pfdr_start & 7) && !(num & 7) && num);\n\t \n\tif (!MCR_rslt_idle(rslt)) {\n\t\tdev_crit(dev, \"QMAN_MCR isn't idle\");\n\t\tWARN_ON(1);\n\t}\n\n\t \n\tqm_ccsr_out(REG_MCP(0), pfdr_start);\n\t \n\tqm_ccsr_out(REG_MCP(1), pfdr_start + num - 16);\n\tdma_wmb();\n\tqm_ccsr_out(REG_MCR, MCR_INIT_PFDR);\n\t \n\tdo {\n\t\trslt = MCR_get_rslt(qm_ccsr_in(REG_MCR));\n\t} while (!MCR_rslt_idle(rslt));\n\tif (MCR_rslt_ok(rslt))\n\t\treturn 0;\n\tif (MCR_rslt_eaccess(rslt))\n\t\treturn -EACCES;\n\tif (MCR_rslt_inval(rslt))\n\t\treturn -EINVAL;\n\tdev_crit(dev, \"Unexpected result from MCR_INIT_PFDR: %02x\\n\", rslt);\n\treturn -ENODEV;\n}\n\n \nstatic dma_addr_t fqd_a, pfdr_a;\nstatic size_t fqd_sz, pfdr_sz;\n\n#ifdef CONFIG_PPC\n \nstatic int zero_priv_mem(phys_addr_t addr, size_t sz)\n{\n\t \n\tvoid __iomem *tmpp = ioremap_cache(addr, sz);\n\n\tif (!tmpp)\n\t\treturn -ENOMEM;\n\n\tmemset_io(tmpp, 0, sz);\n\tflush_dcache_range((unsigned long)tmpp,\n\t\t\t   (unsigned long)tmpp + sz);\n\tiounmap(tmpp);\n\n\treturn 0;\n}\n\nstatic int qman_fqd(struct reserved_mem *rmem)\n{\n\tfqd_a = rmem->base;\n\tfqd_sz = rmem->size;\n\n\tWARN_ON(!(fqd_a && fqd_sz));\n\treturn 0;\n}\nRESERVEDMEM_OF_DECLARE(qman_fqd, \"fsl,qman-fqd\", qman_fqd);\n\nstatic int qman_pfdr(struct reserved_mem *rmem)\n{\n\tpfdr_a = rmem->base;\n\tpfdr_sz = rmem->size;\n\n\tWARN_ON(!(pfdr_a && pfdr_sz));\n\n\treturn 0;\n}\nRESERVEDMEM_OF_DECLARE(qman_pfdr, \"fsl,qman-pfdr\", qman_pfdr);\n\n#endif\n\nunsigned int qm_get_fqid_maxcnt(void)\n{\n\treturn fqd_sz / 64;\n}\n\nstatic void log_edata_bits(struct device *dev, u32 bit_count)\n{\n\tu32 i, j, mask = 0xffffffff;\n\n\tdev_warn(dev, \"ErrInt, EDATA:\\n\");\n\ti = bit_count / 32;\n\tif (bit_count % 32) {\n\t\ti++;\n\t\tmask = ~(mask << bit_count % 32);\n\t}\n\tj = 16 - i;\n\tdev_warn(dev, \"  0x%08x\\n\", qm_ccsr_in(REG_EDATA(j)) & mask);\n\tj++;\n\tfor (; j < 16; j++)\n\t\tdev_warn(dev, \"  0x%08x\\n\", qm_ccsr_in(REG_EDATA(j)));\n}\n\nstatic void log_additional_error_info(struct device *dev, u32 isr_val,\n\t\t\t\t      u32 ecsr_val)\n{\n\tstruct qm_ecir ecir_val;\n\tstruct qm_eadr eadr_val;\n\tint memid;\n\n\tecir_val.info = qm_ccsr_in(REG_ECIR);\n\t \n\tif ((qman_ip_rev & 0xFF00) >= QMAN_REV30) {\n\t\tstruct qm_ecir2 ecir2_val;\n\n\t\tecir2_val.info = qm_ccsr_in(REG_ECIR2);\n\t\tif (ecsr_val & PORTAL_ECSR_ERR) {\n\t\t\tdev_warn(dev, \"ErrInt: %s id %d\\n\",\n\t\t\t\t qm_ecir2_is_dcp(&ecir2_val) ? \"DCP\" : \"SWP\",\n\t\t\t\t qm_ecir2_get_pnum(&ecir2_val));\n\t\t}\n\t\tif (ecsr_val & (FQID_ECSR_ERR | QM_EIRQ_IECE))\n\t\t\tdev_warn(dev, \"ErrInt: ecir.fqid 0x%x\\n\",\n\t\t\t\t qm_ecir_get_fqid(&ecir_val));\n\n\t\tif (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {\n\t\t\teadr_val.info = qm_ccsr_in(REG_EADR);\n\t\t\tmemid = qm_eadr_v3_get_memid(&eadr_val);\n\t\t\tdev_warn(dev, \"ErrInt: EADR Memory: %s, 0x%x\\n\",\n\t\t\t\t error_mdata[memid].txt,\n\t\t\t\t error_mdata[memid].addr_mask\n\t\t\t\t\t& qm_eadr_v3_get_eadr(&eadr_val));\n\t\t\tlog_edata_bits(dev, error_mdata[memid].bits);\n\t\t}\n\t} else {\n\t\tif (ecsr_val & PORTAL_ECSR_ERR) {\n\t\t\tdev_warn(dev, \"ErrInt: %s id %d\\n\",\n\t\t\t\t qm_ecir_is_dcp(&ecir_val) ? \"DCP\" : \"SWP\",\n\t\t\t\t qm_ecir_get_pnum(&ecir_val));\n\t\t}\n\t\tif (ecsr_val & FQID_ECSR_ERR)\n\t\t\tdev_warn(dev, \"ErrInt: ecir.fqid 0x%x\\n\",\n\t\t\t\t qm_ecir_get_fqid(&ecir_val));\n\n\t\tif (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {\n\t\t\teadr_val.info = qm_ccsr_in(REG_EADR);\n\t\t\tmemid = qm_eadr_get_memid(&eadr_val);\n\t\t\tdev_warn(dev, \"ErrInt: EADR Memory: %s, 0x%x\\n\",\n\t\t\t\t error_mdata[memid].txt,\n\t\t\t\t error_mdata[memid].addr_mask\n\t\t\t\t\t& qm_eadr_get_eadr(&eadr_val));\n\t\t\tlog_edata_bits(dev, error_mdata[memid].bits);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t qman_isr(int irq, void *ptr)\n{\n\tu32 isr_val, ier_val, ecsr_val, isr_mask, i;\n\tstruct device *dev = ptr;\n\n\tier_val = qm_ccsr_in(REG_ERR_IER);\n\tisr_val = qm_ccsr_in(REG_ERR_ISR);\n\tecsr_val = qm_ccsr_in(REG_ECSR);\n\tisr_mask = isr_val & ier_val;\n\n\tif (!isr_mask)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < ARRAY_SIZE(qman_hwerr_txts); i++) {\n\t\tif (qman_hwerr_txts[i].mask & isr_mask) {\n\t\t\tdev_err_ratelimited(dev, \"ErrInt: %s\\n\",\n\t\t\t\t\t    qman_hwerr_txts[i].txt);\n\t\t\tif (qman_hwerr_txts[i].mask & ecsr_val) {\n\t\t\t\tlog_additional_error_info(dev, isr_mask,\n\t\t\t\t\t\t\t  ecsr_val);\n\t\t\t\t \n\t\t\t\tqm_ccsr_out(REG_ECSR, ecsr_val);\n\t\t\t}\n\t\t\tif (qman_hwerr_txts[i].mask & QMAN_ERRS_TO_DISABLE) {\n\t\t\t\tdev_dbg(dev, \"Disabling error 0x%x\\n\",\n\t\t\t\t\tqman_hwerr_txts[i].mask);\n\t\t\t\tier_val &= ~qman_hwerr_txts[i].mask;\n\t\t\t\tqm_ccsr_out(REG_ERR_IER, ier_val);\n\t\t\t}\n\t\t}\n\t}\n\tqm_ccsr_out(REG_ERR_ISR, isr_val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qman_init_ccsr(struct device *dev)\n{\n\tint i, err;\n\n\t \n\terr = qm_set_memory(qm_memory_fqd, fqd_a, fqd_sz);\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = qm_set_memory(qm_memory_pfdr, pfdr_a, pfdr_sz);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (err == 0) {\n\t\terr = qm_init_pfdr(dev, 8, pfdr_sz / 64 - 8);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tqm_set_pfdr_threshold(512, 64);\n\tqm_set_sfdr_threshold(128);\n\t \n\tqm_ccsr_out(REG_ERR_ISR, QM_EIRQ_PEBI);\n\t \n\tqm_set_corenet_initiator();\n\t \n\tqm_set_hid();\n\t \n\tfor (i = qm_wq_first; i <= qm_wq_last; i++)\n\t\tqm_set_wq_scheduling(i, 0, 0, 0, 0, 0, 0, 0);\n\t \n\tqm_set_dc(qm_dc_portal_fman0, 1, 0);\n\tqm_set_dc(qm_dc_portal_fman1, 1, 0);\n\treturn 0;\n}\n\n#define LIO_CFG_LIODN_MASK 0x0fff0000\nvoid __qman_liodn_fixup(u16 channel)\n{\n\tstatic int done;\n\tstatic u32 liodn_offset;\n\tu32 before, after;\n\tint idx = channel - QM_CHANNEL_SWPORTAL0;\n\n\tif ((qman_ip_rev & 0xFF00) >= QMAN_REV30)\n\t\tbefore = qm_ccsr_in(REG_REV3_QCSP_LIO_CFG(idx));\n\telse\n\t\tbefore = qm_ccsr_in(REG_QCSP_LIO_CFG(idx));\n\tif (!done) {\n\t\tliodn_offset = before & LIO_CFG_LIODN_MASK;\n\t\tdone = 1;\n\t\treturn;\n\t}\n\tafter = (before & (~LIO_CFG_LIODN_MASK)) | liodn_offset;\n\tif ((qman_ip_rev & 0xFF00) >= QMAN_REV30)\n\t\tqm_ccsr_out(REG_REV3_QCSP_LIO_CFG(idx), after);\n\telse\n\t\tqm_ccsr_out(REG_QCSP_LIO_CFG(idx), after);\n}\n\n#define IO_CFG_SDEST_MASK 0x00ff0000\nvoid qman_set_sdest(u16 channel, unsigned int cpu_idx)\n{\n\tint idx = channel - QM_CHANNEL_SWPORTAL0;\n\tu32 before, after;\n\n\tif ((qman_ip_rev & 0xFF00) >= QMAN_REV30) {\n\t\tbefore = qm_ccsr_in(REG_REV3_QCSP_IO_CFG(idx));\n\t\t \n\t\tcpu_idx /= 2;\n\t\tafter = (before & (~IO_CFG_SDEST_MASK)) | (cpu_idx << 16);\n\t\tqm_ccsr_out(REG_REV3_QCSP_IO_CFG(idx), after);\n\t} else {\n\t\tbefore = qm_ccsr_in(REG_QCSP_IO_CFG(idx));\n\t\tafter = (before & (~IO_CFG_SDEST_MASK)) | (cpu_idx << 16);\n\t\tqm_ccsr_out(REG_QCSP_IO_CFG(idx), after);\n\t}\n}\n\nstatic int qman_resource_init(struct device *dev)\n{\n\tint pool_chan_num, cgrid_num;\n\tint ret, i;\n\n\tswitch (qman_ip_rev >> 8) {\n\tcase 1:\n\t\tpool_chan_num = 15;\n\t\tcgrid_num = 256;\n\t\tbreak;\n\tcase 2:\n\t\tpool_chan_num = 3;\n\t\tcgrid_num = 64;\n\t\tbreak;\n\tcase 3:\n\t\tpool_chan_num = 15;\n\t\tcgrid_num = 256;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tret = gen_pool_add(qm_qpalloc, qm_channel_pool1 | DPAA_GENALLOC_OFF,\n\t\t\t   pool_chan_num, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to seed pool channels (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gen_pool_add(qm_cgralloc, DPAA_GENALLOC_OFF, cgrid_num, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to seed CGRID range (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < cgrid_num; i++)\n\t\tqm_pools_sdqcr |= QM_SDQCR_CHANNELS_POOL_CONV(i);\n\n\tret = gen_pool_add(qm_fqalloc, QM_FQID_RANGE_START | DPAA_GENALLOC_OFF,\n\t\t\t   qm_get_fqid_maxcnt() - QM_FQID_RANGE_START, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to seed FQID range (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint qman_is_probed(void)\n{\n\treturn __qman_probed;\n}\nEXPORT_SYMBOL_GPL(qman_is_probed);\n\nint qman_requires_cleanup(void)\n{\n\treturn __qman_requires_cleanup;\n}\n\nvoid qman_done_cleanup(void)\n{\n\tqman_enable_irqs();\n\t__qman_requires_cleanup = 0;\n}\n\n\nstatic int fsl_qman_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct resource *res;\n\tint ret, err_irq;\n\tu16 id;\n\tu8 major, minor;\n\n\t__qman_probed = -1;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"Can't get %pOF property 'IORESOURCE_MEM'\\n\",\n\t\t\tnode);\n\t\treturn -ENXIO;\n\t}\n\tqm_ccsr_start = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!qm_ccsr_start)\n\t\treturn -ENXIO;\n\n\tqm_get_version(&id, &major, &minor);\n\tif (major == 1 && minor == 0) {\n\t\tdev_err(dev, \"Rev1.0 on P4080 rev1 is not supported!\\n\");\n\t\t\treturn -ENODEV;\n\t} else if (major == 1 && minor == 1)\n\t\tqman_ip_rev = QMAN_REV11;\n\telse if\t(major == 1 && minor == 2)\n\t\tqman_ip_rev = QMAN_REV12;\n\telse if (major == 2 && minor == 0)\n\t\tqman_ip_rev = QMAN_REV20;\n\telse if (major == 3 && minor == 0)\n\t\tqman_ip_rev = QMAN_REV30;\n\telse if (major == 3 && minor == 1)\n\t\tqman_ip_rev = QMAN_REV31;\n\telse if (major == 3 && minor == 2)\n\t\tqman_ip_rev = QMAN_REV32;\n\telse {\n\t\tdev_err(dev, \"Unknown QMan version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((qman_ip_rev & 0xff00) >= QMAN_REV30) {\n\t\tqm_channel_pool1 = QMAN_CHANNEL_POOL1_REV3;\n\t\tqm_channel_caam = QMAN_CHANNEL_CAAM_REV3;\n\t}\n\n\tif (fqd_a) {\n#ifdef CONFIG_PPC\n\t\t \n\t\tzero_priv_mem(fqd_a, fqd_sz);\n#else\n\t\tWARN(1, \"Unexpected architecture using non shared-dma-mem reservations\");\n#endif\n\t} else {\n\t\t \n\t\tret = qbman_init_private_mem(dev, 0, &fqd_a, &fqd_sz);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"qbman_init_private_mem() for FQD failed 0x%x\\n\",\n\t\t\t\tret);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tdev_dbg(dev, \"Allocated FQD 0x%llx 0x%zx\\n\", fqd_a, fqd_sz);\n\n\tif (!pfdr_a) {\n\t\t \n\t\tret = qbman_init_private_mem(dev, 1, &pfdr_a, &pfdr_sz);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"qbman_init_private_mem() for PFDR failed 0x%x\\n\",\n\t\t\t\tret);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tdev_dbg(dev, \"Allocated PFDR 0x%llx 0x%zx\\n\", pfdr_a, pfdr_sz);\n\n\tret = qman_init_ccsr(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"CCSR setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\terr_irq = platform_get_irq(pdev, 0);\n\tif (err_irq <= 0) {\n\t\tdev_info(dev, \"Can't get %pOF property 'interrupts'\\n\",\n\t\t\t node);\n\t\treturn -ENODEV;\n\t}\n\tret = devm_request_irq(dev, err_irq, qman_isr, IRQF_SHARED, \"qman-err\",\n\t\t\t       dev);\n\tif (ret)  {\n\t\tdev_err(dev, \"devm_request_irq() failed %d for '%pOF'\\n\",\n\t\t\tret, node);\n\t\treturn ret;\n\t}\n\n\t \n\tqm_ccsr_out(REG_ERR_ISR, 0xffffffff);\n\t \n\tqm_ccsr_out(REG_ERR_IER, 0xffffffff);\n\n\tqm_fqalloc = devm_gen_pool_create(dev, 0, -1, \"qman-fqalloc\");\n\tif (IS_ERR(qm_fqalloc)) {\n\t\tret = PTR_ERR(qm_fqalloc);\n\t\tdev_err(dev, \"qman-fqalloc pool init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqm_qpalloc = devm_gen_pool_create(dev, 0, -1, \"qman-qpalloc\");\n\tif (IS_ERR(qm_qpalloc)) {\n\t\tret = PTR_ERR(qm_qpalloc);\n\t\tdev_err(dev, \"qman-qpalloc pool init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqm_cgralloc = devm_gen_pool_create(dev, 0, -1, \"qman-cgralloc\");\n\tif (IS_ERR(qm_cgralloc)) {\n\t\tret = PTR_ERR(qm_cgralloc);\n\t\tdev_err(dev, \"qman-cgralloc pool init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qman_resource_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qman_alloc_fq_table(qm_get_fqid_maxcnt());\n\tif (ret)\n\t\treturn ret;\n\n\tret = qman_wq_alloc();\n\tif (ret)\n\t\treturn ret;\n\n\t__qman_probed = 1;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fsl_qman_ids[] = {\n\t{\n\t\t.compatible = \"fsl,qman\",\n\t},\n\t{}\n};\n\nstatic struct platform_driver fsl_qman_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = fsl_qman_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = fsl_qman_probe,\n};\n\nbuiltin_platform_driver(fsl_qman_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}