{
  "module_name": "qman_test_api.c",
  "hash_id": "9920db4088c0a0bd07de9a8909b50ab8b56a514f08af3e4b7116190ced18b866",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/fsl/qbman/qman_test_api.c",
  "human_readable_source": " \n\n#include \"qman_test.h\"\n\n#define CGR_ID\t\t27\n#define POOL_ID\t\t2\n#define FQ_FLAGS\tQMAN_FQ_FLAG_DYNAMIC_FQID\n#define NUM_ENQUEUES\t10\n#define NUM_PARTIAL\t4\n#define PORTAL_SDQCR\t(QM_SDQCR_SOURCE_CHANNELS | \\\n\t\t\tQM_SDQCR_TYPE_PRIO_QOS | \\\n\t\t\tQM_SDQCR_TOKEN_SET(0x98) | \\\n\t\t\tQM_SDQCR_CHANNELS_DEDICATED | \\\n\t\t\tQM_SDQCR_CHANNELS_POOL(POOL_ID))\n#define PORTAL_OPAQUE\t((void *)0xf00dbeef)\n#define VDQCR_FLAGS\t(QMAN_VOLATILE_FLAG_WAIT | QMAN_VOLATILE_FLAG_FINISH)\n\nstatic enum qman_cb_dqrr_result cb_dqrr(struct qman_portal *,\n\t\t\t\t\tstruct qman_fq *,\n\t\t\t\t\tconst struct qm_dqrr_entry *,\n\t\t\t\t\tbool sched_napi);\nstatic void cb_ern(struct qman_portal *, struct qman_fq *,\n\t\t   const union qm_mr_entry *);\nstatic void cb_fqs(struct qman_portal *, struct qman_fq *,\n\t\t   const union qm_mr_entry *);\n\nstatic struct qm_fd fd, fd_dq;\nstatic struct qman_fq fq_base = {\n\t.cb.dqrr = cb_dqrr,\n\t.cb.ern = cb_ern,\n\t.cb.fqs = cb_fqs\n};\nstatic DECLARE_WAIT_QUEUE_HEAD(waitqueue);\nstatic int retire_complete, sdqcr_complete;\n\n \nstatic void fd_init(struct qm_fd *fd)\n{\n\tqm_fd_addr_set64(fd, 0xabdeadbeefLLU);\n\tqm_fd_set_contig_big(fd, 0x0000ffff);\n\tfd->cmd = cpu_to_be32(0xfeedf00d);\n}\n\nstatic void fd_inc(struct qm_fd *fd)\n{\n\tu64 t = qm_fd_addr_get64(fd);\n\tint z = t >> 40;\n\tunsigned int len, off;\n\tenum qm_fd_format fmt;\n\n\tt <<= 1;\n\tif (z)\n\t\tt |= 1;\n\tqm_fd_addr_set64(fd, t);\n\n\tfmt = qm_fd_get_format(fd);\n\toff = qm_fd_get_offset(fd);\n\tlen = qm_fd_get_length(fd);\n\tlen--;\n\tqm_fd_set_param(fd, fmt, off, len);\n\n\tbe32_add_cpu(&fd->cmd, 1);\n}\n\n \nstatic bool fd_neq(const struct qm_fd *a, const struct qm_fd *b)\n{\n\tbool neq = qm_fd_addr_get64(a) != qm_fd_addr_get64(b);\n\n\tneq |= qm_fd_get_format(a) != qm_fd_get_format(b);\n\tneq |= a->cfg != b->cfg;\n\tneq |= a->cmd != b->cmd;\n\n\treturn neq;\n}\n\n \nstatic int do_enqueues(struct qman_fq *fq)\n{\n\tunsigned int loop;\n\tint err = 0;\n\n\tfor (loop = 0; loop < NUM_ENQUEUES; loop++) {\n\t\tif (qman_enqueue(fq, &fd)) {\n\t\t\tpr_crit(\"qman_enqueue() failed\\n\");\n\t\t\terr = -EIO;\n\t\t}\n\t\tfd_inc(&fd);\n\t}\n\n\treturn err;\n}\n\nint qman_test_api(void)\n{\n\tunsigned int flags, frmcnt;\n\tint err;\n\tstruct qman_fq *fq = &fq_base;\n\n\tpr_info(\"%s(): Starting\\n\", __func__);\n\tfd_init(&fd);\n\tfd_init(&fd_dq);\n\n\t \n\terr = qman_create_fq(0, FQ_FLAGS, fq);\n\tif (err) {\n\t\tpr_crit(\"qman_create_fq() failed\\n\");\n\t\tgoto failed;\n\t}\n\terr = qman_init_fq(fq, QMAN_INITFQ_FLAG_LOCAL, NULL);\n\tif (err) {\n\t\tpr_crit(\"qman_init_fq() failed\\n\");\n\t\tgoto failed;\n\t}\n\t \n\terr = do_enqueues(fq);\n\tif (err)\n\t\tgoto failed;\n\tpr_info(\"VDQCR (till-empty);\\n\");\n\tfrmcnt = QM_VDQCR_NUMFRAMES_TILLEMPTY;\n\terr = qman_volatile_dequeue(fq, VDQCR_FLAGS, frmcnt);\n\tif (err) {\n\t\tpr_crit(\"qman_volatile_dequeue() failed\\n\");\n\t\tgoto failed;\n\t}\n\terr = do_enqueues(fq);\n\tif (err)\n\t\tgoto failed;\n\tpr_info(\"VDQCR (%d of %d);\\n\", NUM_PARTIAL, NUM_ENQUEUES);\n\tfrmcnt = QM_VDQCR_NUMFRAMES_SET(NUM_PARTIAL);\n\terr = qman_volatile_dequeue(fq, VDQCR_FLAGS, frmcnt);\n\tif (err) {\n\t\tpr_crit(\"qman_volatile_dequeue() failed\\n\");\n\t\tgoto failed;\n\t}\n\tpr_info(\"VDQCR (%d of %d);\\n\", NUM_ENQUEUES - NUM_PARTIAL,\n\t\tNUM_ENQUEUES);\n\tfrmcnt = QM_VDQCR_NUMFRAMES_SET(NUM_ENQUEUES - NUM_PARTIAL);\n\terr = qman_volatile_dequeue(fq, VDQCR_FLAGS, frmcnt);\n\tif (err) {\n\t\tpr_err(\"qman_volatile_dequeue() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\terr = do_enqueues(fq);\n\tif (err)\n\t\tgoto failed;\n\tpr_info(\"scheduled dequeue (till-empty)\\n\");\n\terr = qman_schedule_fq(fq);\n\tif (err) {\n\t\tpr_crit(\"qman_schedule_fq() failed\\n\");\n\t\tgoto failed;\n\t}\n\twait_event(waitqueue, sdqcr_complete);\n\n\t \n\terr = qman_retire_fq(fq, &flags);\n\tif (err < 0) {\n\t\tpr_crit(\"qman_retire_fq() failed\\n\");\n\t\tgoto failed;\n\t}\n\twait_event(waitqueue, retire_complete);\n\tif (flags & QMAN_FQ_STATE_BLOCKOOS) {\n\t\terr = -EIO;\n\t\tpr_crit(\"leaking frames\\n\");\n\t\tgoto failed;\n\t}\n\terr = qman_oos_fq(fq);\n\tif (err) {\n\t\tpr_crit(\"qman_oos_fq() failed\\n\");\n\t\tgoto failed;\n\t}\n\tqman_destroy_fq(fq);\n\tpr_info(\"%s(): Finished\\n\", __func__);\n\treturn 0;\n\nfailed:\n\tWARN_ON(1);\n\treturn err;\n}\n\nstatic enum qman_cb_dqrr_result cb_dqrr(struct qman_portal *p,\n\t\t\t\t\tstruct qman_fq *fq,\n\t\t\t\t\tconst struct qm_dqrr_entry *dq,\n\t\t\t\t\tbool sched_napi)\n{\n\tif (WARN_ON(fd_neq(&fd_dq, &dq->fd))) {\n\t\tpr_err(\"BADNESS: dequeued frame doesn't match;\\n\");\n\t\treturn qman_cb_dqrr_consume;\n\t}\n\tfd_inc(&fd_dq);\n\tif (!(dq->stat & QM_DQRR_STAT_UNSCHEDULED) && !fd_neq(&fd_dq, &fd)) {\n\t\tsdqcr_complete = 1;\n\t\twake_up(&waitqueue);\n\t}\n\treturn qman_cb_dqrr_consume;\n}\n\nstatic void cb_ern(struct qman_portal *p, struct qman_fq *fq,\n\t\t   const union qm_mr_entry *msg)\n{\n\tpr_crit(\"cb_ern() unimplemented\");\n\tWARN_ON(1);\n}\n\nstatic void cb_fqs(struct qman_portal *p, struct qman_fq *fq,\n\t\t   const union qm_mr_entry *msg)\n{\n\tu8 verb = (msg->verb & QM_MR_VERB_TYPE_MASK);\n\n\tif ((verb != QM_MR_VERB_FQRN) && (verb != QM_MR_VERB_FQRNI)) {\n\t\tpr_crit(\"unexpected FQS message\");\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tpr_info(\"Retirement message received\\n\");\n\tretire_complete = 1;\n\twake_up(&waitqueue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}