{
  "module_name": "kunpeng_hccs.c",
  "hash_id": "19de3881e0d87836d440c262be209ea93d3d7a9feb07b4a6b744dee2fef70db2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/hisilicon/kunpeng_hccs.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/iopoll.h>\n#include <linux/platform_device.h>\n#include <linux/sysfs.h>\n\n#include <acpi/pcc.h>\n\n#include \"kunpeng_hccs.h\"\n\n \n#define HCCS_PCC_SIGNATURE_MASK\t\t0x50434300\n#define HCCS_PCC_STATUS_CMD_COMPLETE\tBIT(0)\n\n \n#define HCCS_PCC_CMD_WAIT_RETRIES_NUM\t\t500ULL\n#define HCCS_POLL_STATUS_TIME_INTERVAL_US\t3\n\nstatic struct hccs_port_info *kobj_to_port_info(struct kobject *k)\n{\n\treturn container_of(k, struct hccs_port_info, kobj);\n}\n\nstatic struct hccs_die_info *kobj_to_die_info(struct kobject *k)\n{\n\treturn container_of(k, struct hccs_die_info, kobj);\n}\n\nstatic struct hccs_chip_info *kobj_to_chip_info(struct kobject *k)\n{\n\treturn container_of(k, struct hccs_chip_info, kobj);\n}\n\nstruct hccs_register_ctx {\n\tstruct device *dev;\n\tu8 chan_id;\n\tint err;\n};\n\nstatic acpi_status hccs_get_register_cb(struct acpi_resource *ares,\n\t\t\t\t\tvoid *context)\n{\n\tstruct acpi_resource_generic_register *reg;\n\tstruct hccs_register_ctx *ctx = context;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_GENERIC_REGISTER)\n\t\treturn AE_OK;\n\n\treg = &ares->data.generic_reg;\n\tif (reg->space_id != ACPI_ADR_SPACE_PLATFORM_COMM) {\n\t\tdev_err(ctx->dev, \"Bad register resource.\\n\");\n\t\tctx->err = -EINVAL;\n\t\treturn AE_ERROR;\n\t}\n\tctx->chan_id = reg->access_size;\n\n\treturn AE_OK;\n}\n\nstatic int hccs_get_pcc_chan_id(struct hccs_dev *hdev)\n{\n\tacpi_handle handle = ACPI_HANDLE(hdev->dev);\n\tstruct hccs_register_ctx ctx = {0};\n\tacpi_status status;\n\n\tif (!acpi_has_method(handle, METHOD_NAME__CRS))\n\t\treturn -ENODEV;\n\n\tctx.dev = hdev->dev;\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     hccs_get_register_cb, &ctx);\n\tif (ACPI_FAILURE(status))\n\t\treturn ctx.err;\n\thdev->chan_id = ctx.chan_id;\n\n\treturn 0;\n}\n\nstatic void hccs_chan_tx_done(struct mbox_client *cl, void *msg, int ret)\n{\n\tif (ret < 0)\n\t\tpr_debug(\"TX did not complete: CMD sent:0x%x, ret:%d\\n\",\n\t\t\t *(u8 *)msg, ret);\n\telse\n\t\tpr_debug(\"TX completed. CMD sent:0x%x, ret:%d\\n\",\n\t\t\t *(u8 *)msg, ret);\n}\n\nstatic void hccs_unregister_pcc_channel(struct hccs_dev *hdev)\n{\n\tstruct hccs_mbox_client_info *cl_info = &hdev->cl_info;\n\n\tif (cl_info->pcc_comm_addr)\n\t\tiounmap(cl_info->pcc_comm_addr);\n\tpcc_mbox_free_channel(hdev->cl_info.pcc_chan);\n}\n\nstatic int hccs_register_pcc_channel(struct hccs_dev *hdev)\n{\n\tstruct hccs_mbox_client_info *cl_info = &hdev->cl_info;\n\tstruct mbox_client *cl = &cl_info->client;\n\tstruct pcc_mbox_chan *pcc_chan;\n\tstruct device *dev = hdev->dev;\n\tint rc;\n\n\tcl->dev = dev;\n\tcl->tx_block = false;\n\tcl->knows_txdone = true;\n\tcl->tx_done = hccs_chan_tx_done;\n\tpcc_chan = pcc_mbox_request_channel(cl, hdev->chan_id);\n\tif (IS_ERR(pcc_chan)) {\n\t\tdev_err(dev, \"PPC channel request failed.\\n\");\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\tcl_info->pcc_chan = pcc_chan;\n\tcl_info->mbox_chan = pcc_chan->mchan;\n\n\t \n\tcl_info->deadline_us =\n\t\t\tHCCS_PCC_CMD_WAIT_RETRIES_NUM * pcc_chan->latency;\n\tif (cl_info->mbox_chan->mbox->txdone_irq) {\n\t\tdev_err(dev, \"PCC IRQ in PCCT is enabled.\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_mbx_channel_free;\n\t}\n\n\tif (pcc_chan->shmem_base_addr) {\n\t\tcl_info->pcc_comm_addr = ioremap(pcc_chan->shmem_base_addr,\n\t\t\t\t\t\t pcc_chan->shmem_size);\n\t\tif (!cl_info->pcc_comm_addr) {\n\t\t\tdev_err(dev, \"Failed to ioremap PCC communication region for channel-%d.\\n\",\n\t\t\t\thdev->chan_id);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_mbx_channel_free;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_mbx_channel_free:\n\tpcc_mbox_free_channel(cl_info->pcc_chan);\nout:\n\treturn rc;\n}\n\nstatic int hccs_check_chan_cmd_complete(struct hccs_dev *hdev)\n{\n\tstruct hccs_mbox_client_info *cl_info = &hdev->cl_info;\n\tstruct acpi_pcct_shared_memory __iomem *comm_base =\n\t\t\t\t\t\t\tcl_info->pcc_comm_addr;\n\tu16 status;\n\tint ret;\n\n\t \n\tret = readw_poll_timeout(&comm_base->status, status,\n\t\t\t\t status & HCCS_PCC_STATUS_CMD_COMPLETE,\n\t\t\t\t HCCS_POLL_STATUS_TIME_INTERVAL_US,\n\t\t\t\t cl_info->deadline_us);\n\tif (unlikely(ret))\n\t\tdev_err(hdev->dev, \"poll PCC status failed, ret = %d.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hccs_pcc_cmd_send(struct hccs_dev *hdev, u8 cmd,\n\t\t\t     struct hccs_desc *desc)\n{\n\tstruct hccs_mbox_client_info *cl_info = &hdev->cl_info;\n\tvoid __iomem *comm_space = cl_info->pcc_comm_addr +\n\t\t\t\t\tsizeof(struct acpi_pcct_shared_memory);\n\tstruct hccs_fw_inner_head *fw_inner_head;\n\tstruct acpi_pcct_shared_memory tmp = {0};\n\tu16 comm_space_size;\n\tint ret;\n\n\t \n\ttmp.signature = HCCS_PCC_SIGNATURE_MASK | hdev->chan_id;\n\t \n\ttmp.command = cmd;\n\t \n\ttmp.status = 0;\n\tmemcpy_toio(cl_info->pcc_comm_addr, (void *)&tmp,\n\t\t\tsizeof(struct acpi_pcct_shared_memory));\n\n\t \n\tcomm_space_size = HCCS_PCC_SHARE_MEM_BYTES -\n\t\t\t\tsizeof(struct acpi_pcct_shared_memory);\n\tmemcpy_toio(comm_space, (void *)desc, comm_space_size);\n\n\t \n\tret = mbox_send_message(cl_info->mbox_chan, &cmd);\n\tif (ret < 0) {\n\t\tdev_err(hdev->dev, \"Send PCC mbox message failed, ret = %d.\\n\",\n\t\t\tret);\n\t\tgoto end;\n\t}\n\n\t \n\tret = hccs_check_chan_cmd_complete(hdev);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\tmemcpy_fromio((void *)desc, comm_space, comm_space_size);\n\tfw_inner_head = &desc->rsp.fw_inner_head;\n\tif (fw_inner_head->retStatus) {\n\t\tdev_err(hdev->dev, \"Execute PCC command failed, error code = %u.\\n\",\n\t\t\tfw_inner_head->retStatus);\n\t\tret = -EIO;\n\t}\n\nend:\n\tmbox_client_txdone(cl_info->mbox_chan, ret);\n\treturn ret;\n}\n\nstatic void hccs_init_req_desc(struct hccs_desc *desc)\n{\n\tstruct hccs_req_desc *req = &desc->req;\n\n\tmemset(desc, 0, sizeof(*desc));\n\treq->req_head.module_code = HCCS_SERDES_MODULE_CODE;\n}\n\nstatic int hccs_get_dev_caps(struct hccs_dev *hdev)\n{\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DEV_CAP, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"Get device capabilities failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tmemcpy(&hdev->caps, desc.rsp.data, sizeof(hdev->caps));\n\n\treturn 0;\n}\n\nstatic int hccs_query_chip_num_on_platform(struct hccs_dev *hdev)\n{\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_CHIP_NUM, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"query system chip number failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thdev->chip_num = *((u8 *)&desc.rsp.data);\n\tif (!hdev->chip_num) {\n\t\tdev_err(hdev->dev, \"chip num obtained from firmware is zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_get_chip_info(struct hccs_dev *hdev,\n\t\t\t      struct hccs_chip_info *chip)\n{\n\tstruct hccs_die_num_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_die_num_req_param *)desc.req.data;\n\treq_param->chip_id = chip->chip_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DIE_NUM, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->die_num = *((u8 *)&desc.rsp.data);\n\n\treturn 0;\n}\n\nstatic int hccs_query_chip_info_on_platform(struct hccs_dev *hdev)\n{\n\tstruct hccs_chip_info *chip;\n\tint ret;\n\tu8 idx;\n\n\tret = hccs_query_chip_num_on_platform(hdev);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"query chip number on platform failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thdev->chips = devm_kzalloc(hdev->dev,\n\t\t\t\thdev->chip_num * sizeof(struct hccs_chip_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!hdev->chips) {\n\t\tdev_err(hdev->dev, \"allocate all chips memory failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (idx = 0; idx < hdev->chip_num; idx++) {\n\t\tchip = &hdev->chips[idx];\n\t\tchip->chip_id = idx;\n\t\tret = hccs_get_chip_info(hdev, chip);\n\t\tif (ret) {\n\t\t\tdev_err(hdev->dev, \"get chip%u info failed, ret = %d.\\n\",\n\t\t\t\tidx, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tchip->hdev = hdev;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_query_die_info_on_chip(struct hccs_dev *hdev, u8 chip_id,\n\t\t\t\t       u8 die_idx, struct hccs_die_info *die)\n{\n\tstruct hccs_die_info_req_param *req_param;\n\tstruct hccs_die_info_rsp_data *rsp_data;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_die_info_req_param *)desc.req.data;\n\treq_param->chip_id = chip_id;\n\treq_param->die_idx = die_idx;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DIE_INFO, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\trsp_data = (struct hccs_die_info_rsp_data *)desc.rsp.data;\n\tdie->die_id = rsp_data->die_id;\n\tdie->port_num = rsp_data->port_num;\n\tdie->min_port_id = rsp_data->min_port_id;\n\tdie->max_port_id = rsp_data->max_port_id;\n\tif (die->min_port_id > die->max_port_id) {\n\t\tdev_err(hdev->dev, \"min port id(%u) > max port id(%u) on die_idx(%u).\\n\",\n\t\t\tdie->min_port_id, die->max_port_id, die_idx);\n\t\treturn -EINVAL;\n\t}\n\tif (die->max_port_id > HCCS_DIE_MAX_PORT_ID) {\n\t\tdev_err(hdev->dev, \"max port id(%u) on die_idx(%u) is too big.\\n\",\n\t\t\tdie->max_port_id, die_idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_query_all_die_info_on_platform(struct hccs_dev *hdev)\n{\n\tstruct device *dev = hdev->dev;\n\tstruct hccs_chip_info *chip;\n\tstruct hccs_die_info *die;\n\tu8 i, j;\n\tint ret;\n\n\tfor (i = 0; i < hdev->chip_num; i++) {\n\t\tchip = &hdev->chips[i];\n\t\tif (!chip->die_num)\n\t\t\tcontinue;\n\n\t\tchip->dies = devm_kzalloc(hdev->dev,\n\t\t\t\tchip->die_num * sizeof(struct hccs_die_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!chip->dies) {\n\t\t\tdev_err(dev, \"allocate all dies memory on chip%u failed.\\n\",\n\t\t\t\ti);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (j = 0; j < chip->die_num; j++) {\n\t\t\tdie = &chip->dies[j];\n\t\t\tret = hccs_query_die_info_on_chip(hdev, i, j, die);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"get die idx (%u) info on chip%u failed, ret = %d.\\n\",\n\t\t\t\t\tj, i, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdie->chip = chip;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_get_bd_info(struct hccs_dev *hdev, u8 opcode,\n\t\t\t    struct hccs_desc *desc,\n\t\t\t    void *buf, size_t buf_len,\n\t\t\t    struct hccs_rsp_head *rsp_head)\n{\n\tstruct hccs_rsp_head *head;\n\tstruct hccs_rsp_desc *rsp;\n\tint ret;\n\n\tret = hccs_pcc_cmd_send(hdev, opcode, desc);\n\tif (ret)\n\t\treturn ret;\n\n\trsp = &desc->rsp;\n\thead = &rsp->rsp_head;\n\tif (head->data_len > buf_len) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"buffer overflow (buf_len = %zu, data_len = %u)!\\n\",\n\t\t\tbuf_len, head->data_len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(buf, rsp->data, head->data_len);\n\t*rsp_head = *head;\n\n\treturn 0;\n}\n\nstatic int hccs_get_all_port_attr(struct hccs_dev *hdev,\n\t\t\t\t  struct hccs_die_info *die,\n\t\t\t\t  struct hccs_port_attr *attrs, u16 size)\n{\n\tstruct hccs_die_comm_req_param *req_param;\n\tstruct hccs_req_head *req_head;\n\tstruct hccs_rsp_head rsp_head;\n\tstruct hccs_desc desc;\n\tsize_t left_buf_len;\n\tu32 data_len = 0;\n\tu8 start_id;\n\tu8 *buf;\n\tint ret;\n\n\tbuf = (u8 *)attrs;\n\tleft_buf_len = sizeof(struct hccs_port_attr) * size;\n\tstart_id = die->min_port_id;\n\twhile (start_id <= die->max_port_id) {\n\t\thccs_init_req_desc(&desc);\n\t\treq_head = &desc.req.req_head;\n\t\treq_head->start_id = start_id;\n\t\treq_param = (struct hccs_die_comm_req_param *)desc.req.data;\n\t\treq_param->chip_id = die->chip->chip_id;\n\t\treq_param->die_id = die->die_id;\n\n\t\tret = hccs_get_bd_info(hdev, HCCS_GET_DIE_PORT_INFO, &desc,\n\t\t\t\t       buf + data_len, left_buf_len, &rsp_head);\n\t\tif (ret) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"get the information of port%u on die%u failed, ret = %d.\\n\",\n\t\t\t\tstart_id, die->die_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata_len += rsp_head.data_len;\n\t\tleft_buf_len -= rsp_head.data_len;\n\t\tif (unlikely(rsp_head.next_id <= start_id)) {\n\t\t\tdev_err(hdev->dev,\n\t\t\t\t\"next port id (%u) is not greater than last start id (%u) on die%u.\\n\",\n\t\t\t\trsp_head.next_id, start_id, die->die_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart_id = rsp_head.next_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_get_all_port_info_on_die(struct hccs_dev *hdev,\n\t\t\t\t\t struct hccs_die_info *die)\n{\n\tstruct hccs_port_attr *attrs;\n\tstruct hccs_port_info *port;\n\tint ret;\n\tu8 i;\n\n\tattrs = kcalloc(die->port_num, sizeof(struct hccs_port_attr),\n\t\t\tGFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tret = hccs_get_all_port_attr(hdev, die, attrs, die->port_num);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < die->port_num; i++) {\n\t\tport = &die->ports[i];\n\t\tport->port_id = attrs[i].port_id;\n\t\tport->port_type = attrs[i].port_type;\n\t\tport->lane_mode = attrs[i].lane_mode;\n\t\tport->enable = attrs[i].enable;\n\t\tport->die = die;\n\t}\n\nout:\n\tkfree(attrs);\n\treturn ret;\n}\n\nstatic int hccs_query_all_port_info_on_platform(struct hccs_dev *hdev)\n{\n\n\tstruct device *dev = hdev->dev;\n\tstruct hccs_chip_info *chip;\n\tstruct hccs_die_info *die;\n\tu8 i, j;\n\tint ret;\n\n\tfor (i = 0; i < hdev->chip_num; i++) {\n\t\tchip = &hdev->chips[i];\n\t\tfor (j = 0; j < chip->die_num; j++) {\n\t\t\tdie = &chip->dies[j];\n\t\t\tif (!die->port_num)\n\t\t\t\tcontinue;\n\n\t\t\tdie->ports = devm_kzalloc(dev,\n\t\t\t\tdie->port_num * sizeof(struct hccs_port_info),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!die->ports) {\n\t\t\t\tdev_err(dev, \"allocate ports memory on chip%u/die%u failed.\\n\",\n\t\t\t\t\ti, die->die_id);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tret = hccs_get_all_port_info_on_die(hdev, die);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"get all port info on chip%u/die%u failed, ret = %d.\\n\",\n\t\t\t\t\ti, die->die_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_get_hw_info(struct hccs_dev *hdev)\n{\n\tint ret;\n\n\tret = hccs_query_chip_info_on_platform(hdev);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"query chip info on platform failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = hccs_query_all_die_info_on_platform(hdev);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"query all die info on platform failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = hccs_query_all_port_info_on_platform(hdev);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"query all port info on platform failed, ret = %d.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_query_port_link_status(struct hccs_dev *hdev,\n\t\t\t\t       const struct hccs_port_info *port,\n\t\t\t\t       struct hccs_link_status *link_status)\n{\n\tconst struct hccs_die_info *die = port->die;\n\tconst struct hccs_chip_info *chip = die->chip;\n\tstruct hccs_port_comm_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_port_comm_req_param *)desc.req.data;\n\treq_param->chip_id = chip->chip_id;\n\treq_param->die_id = die->die_id;\n\treq_param->port_id = port->port_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_PORT_LINK_STATUS, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"get port link status info failed, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*link_status = *((struct hccs_link_status *)desc.rsp.data);\n\n\treturn 0;\n}\n\nstatic int hccs_query_port_crc_err_cnt(struct hccs_dev *hdev,\n\t\t\t\t       const struct hccs_port_info *port,\n\t\t\t\t       u64 *crc_err_cnt)\n{\n\tconst struct hccs_die_info *die = port->die;\n\tconst struct hccs_chip_info *chip = die->chip;\n\tstruct hccs_port_comm_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_port_comm_req_param *)desc.req.data;\n\treq_param->chip_id = chip->chip_id;\n\treq_param->die_id = die->die_id;\n\treq_param->port_id = port->port_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_PORT_CRC_ERR_CNT, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"get port crc error count failed, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(crc_err_cnt, &desc.rsp.data, sizeof(u64));\n\n\treturn 0;\n}\n\nstatic int hccs_get_die_all_link_status(struct hccs_dev *hdev,\n\t\t\t\t\tconst struct hccs_die_info *die,\n\t\t\t\t\tu8 *all_linked)\n{\n\tstruct hccs_die_comm_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\tif (die->port_num == 0) {\n\t\t*all_linked = 1;\n\t\treturn 0;\n\t}\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_die_comm_req_param *)desc.req.data;\n\treq_param->chip_id = die->chip->chip_id;\n\treq_param->die_id = die->die_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DIE_PORTS_LINK_STA, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev,\n\t\t\t\"get link status of all ports failed on die%u, ret = %d.\\n\",\n\t\t\tdie->die_id, ret);\n\t\treturn ret;\n\t}\n\n\t*all_linked = *((u8 *)&desc.rsp.data);\n\n\treturn 0;\n}\n\nstatic int hccs_get_die_all_port_lane_status(struct hccs_dev *hdev,\n\t\t\t\t\t     const struct hccs_die_info *die,\n\t\t\t\t\t     u8 *full_lane)\n{\n\tstruct hccs_die_comm_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\tif (die->port_num == 0) {\n\t\t*full_lane = 1;\n\t\treturn 0;\n\t}\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_die_comm_req_param *)desc.req.data;\n\treq_param->chip_id = die->chip->chip_id;\n\treq_param->die_id = die->die_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DIE_PORTS_LANE_STA, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"get lane status of all ports failed on die%u, ret = %d.\\n\",\n\t\t\tdie->die_id, ret);\n\t\treturn ret;\n\t}\n\n\t*full_lane = *((u8 *)&desc.rsp.data);\n\n\treturn 0;\n}\n\nstatic int hccs_get_die_total_crc_err_cnt(struct hccs_dev *hdev,\n\t\t\t\t\t  const struct hccs_die_info *die,\n\t\t\t\t\t  u64 *total_crc_err_cnt)\n{\n\tstruct hccs_die_comm_req_param *req_param;\n\tstruct hccs_desc desc;\n\tint ret;\n\n\tif (die->port_num == 0) {\n\t\t*total_crc_err_cnt = 0;\n\t\treturn 0;\n\t}\n\n\thccs_init_req_desc(&desc);\n\treq_param = (struct hccs_die_comm_req_param *)desc.req.data;\n\treq_param->chip_id = die->chip->chip_id;\n\treq_param->die_id = die->die_id;\n\tret = hccs_pcc_cmd_send(hdev, HCCS_GET_DIE_PORTS_CRC_ERR_CNT, &desc);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"get crc error count sum failed on die%u, ret = %d.\\n\",\n\t\t\tdie->die_id, ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(total_crc_err_cnt, &desc.rsp.data, sizeof(u64));\n\n\treturn 0;\n}\n\nstatic ssize_t hccs_show(struct kobject *k, struct attribute *attr, char *buf)\n{\n\tstruct kobj_attribute *kobj_attr;\n\n\tkobj_attr = container_of(attr, struct kobj_attribute, attr);\n\n\treturn kobj_attr->show(k, kobj_attr, buf);\n}\n\nstatic const struct sysfs_ops hccs_comm_ops = {\n\t.show = hccs_show,\n};\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\n\treturn sysfs_emit(buf, \"HCCS-v%u\\n\", port->port_type);\n}\nstatic struct kobj_attribute hccs_type_attr = __ATTR_RO(type);\n\nstatic ssize_t lane_mode_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\n\treturn sysfs_emit(buf, \"x%u\\n\", port->lane_mode);\n}\nstatic struct kobj_attribute lane_mode_attr = __ATTR_RO(lane_mode);\n\nstatic ssize_t enable_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\n\treturn sysfs_emit(buf, \"%u\\n\", port->enable);\n}\nstatic struct kobj_attribute port_enable_attr = __ATTR_RO(enable);\n\nstatic ssize_t cur_lane_num_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\tstruct hccs_dev *hdev = port->die->chip->hdev;\n\tstruct hccs_link_status link_status = {0};\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_query_port_link_status(hdev, port, &link_status);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", link_status.lane_num);\n}\nstatic struct kobj_attribute cur_lane_num_attr = __ATTR_RO(cur_lane_num);\n\nstatic ssize_t link_fsm_show(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\tstruct hccs_dev *hdev = port->die->chip->hdev;\n\tstruct hccs_link_status link_status = {0};\n\tconst struct {\n\t\tu8 link_fsm;\n\t\tchar *str;\n\t} link_fsm_map[] = {\n\t\t{HCCS_PORT_RESET, \"reset\"},\n\t\t{HCCS_PORT_SETUP, \"setup\"},\n\t\t{HCCS_PORT_CONFIG, \"config\"},\n\t\t{HCCS_PORT_READY, \"link-up\"},\n\t};\n\tconst char *link_fsm_str = \"unknown\";\n\tsize_t i;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_query_port_link_status(hdev, port, &link_status);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(link_fsm_map); i++) {\n\t\tif (link_fsm_map[i].link_fsm == link_status.link_fsm) {\n\t\t\tlink_fsm_str = link_fsm_map[i].str;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", link_fsm_str);\n}\nstatic struct kobj_attribute link_fsm_attr = __ATTR_RO(link_fsm);\n\nstatic ssize_t lane_mask_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\tstruct hccs_dev *hdev = port->die->chip->hdev;\n\tstruct hccs_link_status link_status = {0};\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_query_port_link_status(hdev, port, &link_status);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", link_status.lane_mask);\n}\nstatic struct kobj_attribute lane_mask_attr = __ATTR_RO(lane_mask);\n\nstatic ssize_t crc_err_cnt_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_port_info *port = kobj_to_port_info(kobj);\n\tstruct hccs_dev *hdev = port->die->chip->hdev;\n\tu64 crc_err_cnt;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_query_port_crc_err_cnt(hdev, port, &crc_err_cnt);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", crc_err_cnt);\n}\nstatic struct kobj_attribute crc_err_cnt_attr = __ATTR_RO(crc_err_cnt);\n\nstatic struct attribute *hccs_port_default_attrs[] = {\n\t&hccs_type_attr.attr,\n\t&lane_mode_attr.attr,\n\t&port_enable_attr.attr,\n\t&cur_lane_num_attr.attr,\n\t&link_fsm_attr.attr,\n\t&lane_mask_attr.attr,\n\t&crc_err_cnt_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hccs_port_default);\n\nstatic const struct kobj_type hccs_port_type = {\n\t.sysfs_ops = &hccs_comm_ops,\n\t.default_groups = hccs_port_default_groups,\n};\n\nstatic ssize_t all_linked_on_die_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_die_info *die = kobj_to_die_info(kobj);\n\tstruct hccs_dev *hdev = die->chip->hdev;\n\tu8 all_linked;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_get_die_all_link_status(hdev, die, &all_linked);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", all_linked);\n}\nstatic struct kobj_attribute all_linked_on_die_attr =\n\t\t__ATTR(all_linked, 0444, all_linked_on_die_show, NULL);\n\nstatic ssize_t linked_full_lane_on_die_show(struct kobject *kobj,\n\t\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tconst struct hccs_die_info *die = kobj_to_die_info(kobj);\n\tstruct hccs_dev *hdev = die->chip->hdev;\n\tu8 full_lane;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_get_die_all_port_lane_status(hdev, die, &full_lane);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", full_lane);\n}\nstatic struct kobj_attribute linked_full_lane_on_die_attr =\n\t__ATTR(linked_full_lane, 0444, linked_full_lane_on_die_show, NULL);\n\nstatic ssize_t crc_err_cnt_sum_on_die_show(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tconst struct hccs_die_info *die = kobj_to_die_info(kobj);\n\tstruct hccs_dev *hdev = die->chip->hdev;\n\tu64 total_crc_err_cnt;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = hccs_get_die_total_crc_err_cnt(hdev, die, &total_crc_err_cnt);\n\tmutex_unlock(&hdev->lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", total_crc_err_cnt);\n}\nstatic struct kobj_attribute crc_err_cnt_sum_on_die_attr =\n\t__ATTR(crc_err_cnt, 0444, crc_err_cnt_sum_on_die_show, NULL);\n\nstatic struct attribute *hccs_die_default_attrs[] = {\n\t&all_linked_on_die_attr.attr,\n\t&linked_full_lane_on_die_attr.attr,\n\t&crc_err_cnt_sum_on_die_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hccs_die_default);\n\nstatic const struct kobj_type hccs_die_type = {\n\t.sysfs_ops = &hccs_comm_ops,\n\t.default_groups = hccs_die_default_groups,\n};\n\nstatic ssize_t all_linked_on_chip_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tconst struct hccs_chip_info *chip = kobj_to_chip_info(kobj);\n\tstruct hccs_dev *hdev = chip->hdev;\n\tconst struct hccs_die_info *die;\n\tu8 all_linked = 1;\n\tu8 i, tmp;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tfor (i = 0; i < chip->die_num; i++) {\n\t\tdie = &chip->dies[i];\n\t\tret = hccs_get_die_all_link_status(hdev, die, &tmp);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&hdev->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tif (tmp != all_linked) {\n\t\t\tall_linked = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&hdev->lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", all_linked);\n}\nstatic struct kobj_attribute all_linked_on_chip_attr =\n\t\t__ATTR(all_linked, 0444, all_linked_on_chip_show, NULL);\n\nstatic ssize_t linked_full_lane_on_chip_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tconst struct hccs_chip_info *chip = kobj_to_chip_info(kobj);\n\tstruct hccs_dev *hdev = chip->hdev;\n\tconst struct hccs_die_info *die;\n\tu8 full_lane = 1;\n\tu8 i, tmp;\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tfor (i = 0; i < chip->die_num; i++) {\n\t\tdie = &chip->dies[i];\n\t\tret = hccs_get_die_all_port_lane_status(hdev, die, &tmp);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&hdev->lock);\n\t\t\treturn ret;\n\t\t}\n\t\tif (tmp != full_lane) {\n\t\t\tfull_lane = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&hdev->lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", full_lane);\n}\nstatic struct kobj_attribute linked_full_lane_on_chip_attr =\n\t__ATTR(linked_full_lane, 0444, linked_full_lane_on_chip_show, NULL);\n\nstatic ssize_t crc_err_cnt_sum_on_chip_show(struct kobject *kobj,\n\t\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tconst struct hccs_chip_info *chip = kobj_to_chip_info(kobj);\n\tu64 crc_err_cnt, total_crc_err_cnt = 0;\n\tstruct hccs_dev *hdev = chip->hdev;\n\tconst struct hccs_die_info *die;\n\tint ret;\n\tu16 i;\n\n\tmutex_lock(&hdev->lock);\n\tfor (i = 0; i < chip->die_num; i++) {\n\t\tdie = &chip->dies[i];\n\t\tret = hccs_get_die_total_crc_err_cnt(hdev, die, &crc_err_cnt);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&hdev->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttotal_crc_err_cnt += crc_err_cnt;\n\t}\n\tmutex_unlock(&hdev->lock);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", total_crc_err_cnt);\n}\nstatic struct kobj_attribute crc_err_cnt_sum_on_chip_attr =\n\t\t__ATTR(crc_err_cnt, 0444, crc_err_cnt_sum_on_chip_show, NULL);\n\nstatic struct attribute *hccs_chip_default_attrs[] = {\n\t&all_linked_on_chip_attr.attr,\n\t&linked_full_lane_on_chip_attr.attr,\n\t&crc_err_cnt_sum_on_chip_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hccs_chip_default);\n\nstatic const struct kobj_type hccs_chip_type = {\n\t.sysfs_ops = &hccs_comm_ops,\n\t.default_groups = hccs_chip_default_groups,\n};\n\nstatic void hccs_remove_die_dir(struct hccs_die_info *die)\n{\n\tstruct hccs_port_info *port;\n\tu8 i;\n\n\tfor (i = 0; i < die->port_num; i++) {\n\t\tport = &die->ports[i];\n\t\tif (port->dir_created)\n\t\t\tkobject_put(&port->kobj);\n\t}\n\n\tkobject_put(&die->kobj);\n}\n\nstatic void hccs_remove_chip_dir(struct hccs_chip_info *chip)\n{\n\tstruct hccs_die_info *die;\n\tu8 i;\n\n\tfor (i = 0; i < chip->die_num; i++) {\n\t\tdie = &chip->dies[i];\n\t\tif (die->dir_created)\n\t\t\thccs_remove_die_dir(die);\n\t}\n\n\tkobject_put(&chip->kobj);\n}\n\nstatic void hccs_remove_topo_dirs(struct hccs_dev *hdev)\n{\n\tu8 i;\n\n\tfor (i = 0; i < hdev->chip_num; i++)\n\t\thccs_remove_chip_dir(&hdev->chips[i]);\n}\n\nstatic int hccs_create_hccs_dir(struct hccs_dev *hdev,\n\t\t\t\tstruct hccs_die_info *die,\n\t\t\t\tstruct hccs_port_info *port)\n{\n\tint ret;\n\n\tret = kobject_init_and_add(&port->kobj, &hccs_port_type,\n\t\t\t\t   &die->kobj, \"hccs%d\", port->port_id);\n\tif (ret) {\n\t\tkobject_put(&port->kobj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hccs_create_die_dir(struct hccs_dev *hdev,\n\t\t\t       struct hccs_chip_info *chip,\n\t\t\t       struct hccs_die_info *die)\n{\n\tstruct hccs_port_info *port;\n\tint ret;\n\tu16 i;\n\n\tret = kobject_init_and_add(&die->kobj, &hccs_die_type,\n\t\t\t\t   &chip->kobj, \"die%d\", die->die_id);\n\tif (ret) {\n\t\tkobject_put(&die->kobj);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < die->port_num; i++) {\n\t\tport = &die->ports[i];\n\t\tret = hccs_create_hccs_dir(hdev, die, port);\n\t\tif (ret) {\n\t\t\tdev_err(hdev->dev, \"create hccs%d dir failed.\\n\",\n\t\t\t\tport->port_id);\n\t\t\tgoto err;\n\t\t}\n\t\tport->dir_created = true;\n\t}\n\n\treturn 0;\nerr:\n\thccs_remove_die_dir(die);\n\n\treturn ret;\n}\n\nstatic int hccs_create_chip_dir(struct hccs_dev *hdev,\n\t\t\t\tstruct hccs_chip_info *chip)\n{\n\tstruct hccs_die_info *die;\n\tint ret;\n\tu16 id;\n\n\tret = kobject_init_and_add(&chip->kobj, &hccs_chip_type,\n\t\t\t\t   &hdev->dev->kobj, \"chip%d\", chip->chip_id);\n\tif (ret) {\n\t\tkobject_put(&chip->kobj);\n\t\treturn ret;\n\t}\n\n\tfor (id = 0; id < chip->die_num; id++) {\n\t\tdie = &chip->dies[id];\n\t\tret = hccs_create_die_dir(hdev, chip, die);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tdie->dir_created = true;\n\t}\n\n\treturn 0;\nerr:\n\thccs_remove_chip_dir(chip);\n\n\treturn ret;\n}\n\nstatic int hccs_create_topo_dirs(struct hccs_dev *hdev)\n{\n\tstruct hccs_chip_info *chip;\n\tu8 id, k;\n\tint ret;\n\n\tfor (id = 0; id < hdev->chip_num; id++) {\n\t\tchip = &hdev->chips[id];\n\t\tret = hccs_create_chip_dir(hdev, chip);\n\t\tif (ret) {\n\t\t\tdev_err(hdev->dev, \"init chip%d dir failed!\\n\", id);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tfor (k = 0; k < id; k++)\n\t\thccs_remove_chip_dir(&hdev->chips[k]);\n\n\treturn ret;\n}\n\nstatic int hccs_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *acpi_dev;\n\tstruct hccs_dev *hdev;\n\tint rc;\n\n\tif (acpi_disabled) {\n\t\tdev_err(&pdev->dev, \"acpi is disabled.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tacpi_dev = ACPI_COMPANION(&pdev->dev);\n\tif (!acpi_dev)\n\t\treturn -ENODEV;\n\n\thdev = devm_kzalloc(&pdev->dev, sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\thdev->acpi_dev = acpi_dev;\n\thdev->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, hdev);\n\n\tmutex_init(&hdev->lock);\n\trc = hccs_get_pcc_chan_id(hdev);\n\tif (rc)\n\t\treturn rc;\n\trc = hccs_register_pcc_channel(hdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hccs_get_dev_caps(hdev);\n\tif (rc)\n\t\tgoto unregister_pcc_chan;\n\n\trc = hccs_get_hw_info(hdev);\n\tif (rc)\n\t\tgoto unregister_pcc_chan;\n\n\trc = hccs_create_topo_dirs(hdev);\n\tif (rc)\n\t\tgoto unregister_pcc_chan;\n\n\treturn 0;\n\nunregister_pcc_chan:\n\thccs_unregister_pcc_channel(hdev);\n\n\treturn rc;\n}\n\nstatic int hccs_remove(struct platform_device *pdev)\n{\n\tstruct hccs_dev *hdev = platform_get_drvdata(pdev);\n\n\thccs_remove_topo_dirs(hdev);\n\thccs_unregister_pcc_channel(hdev);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id hccs_acpi_match[] = {\n\t{ \"HISI04B1\"},\n\t{ \"\"},\n};\nMODULE_DEVICE_TABLE(acpi, hccs_acpi_match);\n\nstatic struct platform_driver hccs_driver = {\n\t.probe = hccs_probe,\n\t.remove = hccs_remove,\n\t.driver = {\n\t\t.name = \"kunpeng_hccs\",\n\t\t.acpi_match_table = hccs_acpi_match,\n\t},\n};\n\nmodule_platform_driver(hccs_driver);\n\nMODULE_DESCRIPTION(\"Kunpeng SoC HCCS driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Huisong Li <lihuisong@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}