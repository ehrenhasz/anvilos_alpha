{
  "module_name": "ux500-soc-id.c",
  "hash_id": "d7942ee1384a5273b853f65a7c9d5d35144aaeff17a984cc906b672c9bed3e1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/ux500/ux500-soc-id.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/sys_soc.h>\n\n#include <asm/cputype.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mach/map.h>\n\n \nstruct dbx500_asic_id {\n\tu16\tpartnumber;\n\tu8\trevision;\n\tu8\tprocess;\n};\n\nstatic struct dbx500_asic_id dbx500_id;\n\nstatic unsigned int __init ux500_read_asicid(phys_addr_t addr)\n{\n\tvoid __iomem *virt = ioremap(addr, 4);\n\tunsigned int asicid;\n\n\tif (!virt)\n\t\treturn 0;\n\n\tasicid = readl(virt);\n\tiounmap(virt);\n\n\treturn asicid;\n}\n\nstatic void ux500_print_soc_info(unsigned int asicid)\n{\n\tunsigned int rev = dbx500_id.revision;\n\n\tpr_info(\"DB%4x \", dbx500_id.partnumber);\n\n\tif (rev == 0x01)\n\t\tpr_cont(\"Early Drop\");\n\telse if (rev >= 0xA0)\n\t\tpr_cont(\"v%d.%d\" , (rev >> 4) - 0xA + 1, rev & 0xf);\n\telse\n\t\tpr_cont(\"Unknown\");\n\n\tpr_cont(\" [%#010x]\\n\", asicid);\n}\n\nstatic unsigned int partnumber(unsigned int asicid)\n{\n\treturn (asicid >> 8) & 0xffff;\n}\n\n \n\nstatic void __init ux500_setup_id(void)\n{\n\tunsigned int cpuid = read_cpuid_id();\n\tunsigned int asicid = 0;\n\tphys_addr_t addr = 0;\n\n\tswitch (cpuid) {\n\tcase 0x410fc090:  \n\tcase 0x411fc091:  \n\t\taddr = 0x9001FFF4;\n\t\tbreak;\n\n\tcase 0x412fc091:  \n\t\tasicid = ux500_read_asicid(0x9001DBF4);\n\t\tif (partnumber(asicid) == 0x8500 ||\n\t\t    partnumber(asicid) == 0x8520)\n\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\taddr = 0x9001FFF4;\n\t\tbreak;\n\n\tcase 0x413fc090:  \n\t\taddr = 0xFFFFDBF4;\n\t\tbreak;\n\t}\n\n\tif (addr)\n\t\tasicid = ux500_read_asicid(addr);\n\n\tif (!asicid) {\n\t\tpr_err(\"Unable to identify SoC\\n\");\n\t\tBUG();\n\t}\n\n\tdbx500_id.process = asicid >> 24;\n\tdbx500_id.partnumber = partnumber(asicid);\n\tdbx500_id.revision = asicid & 0xff;\n\n\tux500_print_soc_info(asicid);\n}\n\nstatic const char * __init ux500_get_machine(void)\n{\n\treturn kasprintf(GFP_KERNEL, \"DB%4x\", dbx500_id.partnumber);\n}\n\nstatic const char * __init ux500_get_family(void)\n{\n\treturn kasprintf(GFP_KERNEL, \"ux500\");\n}\n\nstatic const char * __init ux500_get_revision(void)\n{\n\tunsigned int rev = dbx500_id.revision;\n\n\tif (rev == 0x01)\n\t\treturn kasprintf(GFP_KERNEL, \"%s\", \"ED\");\n\telse if (rev >= 0xA0)\n\t\treturn kasprintf(GFP_KERNEL, \"%d.%d\",\n\t\t\t\t (rev >> 4) - 0xA + 1, rev & 0xf);\n\n\treturn kasprintf(GFP_KERNEL, \"%s\", \"Unknown\");\n}\n\nstatic ssize_t\nprocess_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tif (dbx500_id.process == 0x00)\n\t\treturn sprintf(buf, \"Standard\\n\");\n\n\treturn sprintf(buf, \"%02xnm\\n\", dbx500_id.process);\n}\n\nstatic DEVICE_ATTR_RO(process);\n\nstatic struct attribute *ux500_soc_attrs[] = {\n\t&dev_attr_process.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ux500_soc);\n\nstatic const char *db8500_read_soc_id(struct device_node *backupram)\n{\n\tvoid __iomem *base;\n\tconst char *retstr;\n\tu32 uid[5];\n\n\tbase = of_iomap(backupram, 0);\n\tif (!base)\n\t\treturn NULL;\n\tmemcpy_fromio(uid, base + 0x1fc0, sizeof(uid));\n\n\t \n\tadd_device_randomness(uid, sizeof(uid));\n\tretstr = kasprintf(GFP_KERNEL, \"%08x%08x%08x%08x%08x\",\n\t\t\t   uid[0], uid[1], uid[2], uid[3], uid[4]);\n\tiounmap(base);\n\treturn retstr;\n}\n\nstatic void __init soc_info_populate(struct soc_device_attribute *soc_dev_attr,\n\t\t\t\t     struct device_node *backupram)\n{\n\tsoc_dev_attr->soc_id   = db8500_read_soc_id(backupram);\n\tsoc_dev_attr->machine  = ux500_get_machine();\n\tsoc_dev_attr->family   = ux500_get_family();\n\tsoc_dev_attr->revision = ux500_get_revision();\n\tsoc_dev_attr->custom_attr_group = ux500_soc_groups[0];\n}\n\nstatic int __init ux500_soc_device_init(void)\n{\n\tstruct soc_device *soc_dev;\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct device_node *backupram;\n\n\tbackupram = of_find_compatible_node(NULL, NULL, \"ste,dbx500-backupram\");\n\tif (!backupram)\n\t\treturn 0;\n\n\tux500_setup_id();\n\n\tsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\n\tif (!soc_dev_attr) {\n\t\tof_node_put(backupram);\n\t\treturn -ENOMEM;\n\t}\n\n\tsoc_info_populate(soc_dev_attr, backupram);\n\tof_node_put(backupram);\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev)) {\n\t        kfree(soc_dev_attr);\n\t\treturn PTR_ERR(soc_dev);\n\t}\n\n\treturn 0;\n}\nsubsys_initcall(ux500_soc_device_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}