{
  "module_name": "mpfs-sys-controller.c",
  "hash_id": "fb9ffaa95eef6e23705a143cb0261be044713f57888556e38211f8da3bc4ab04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/microchip/mpfs-sys-controller.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/mailbox_client.h>\n#include <linux/platform_device.h>\n#include <soc/microchip/mpfs.h>\n\n \n#define MPFS_SYS_CTRL_TIMEOUT_MS 30000\n\nstatic DEFINE_MUTEX(transaction_lock);\n\nstruct mpfs_sys_controller {\n\tstruct mbox_client client;\n\tstruct mbox_chan *chan;\n\tstruct completion c;\n\tstruct kref consumers;\n};\n\nint mpfs_blocking_transaction(struct mpfs_sys_controller *sys_controller, struct mpfs_mss_msg *msg)\n{\n\tunsigned long timeout = msecs_to_jiffies(MPFS_SYS_CTRL_TIMEOUT_MS);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&transaction_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&sys_controller->c);\n\n\tret = mbox_send_message(sys_controller->chan, msg);\n\tif (ret < 0) {\n\t\tdev_warn(sys_controller->client.dev, \"MPFS sys controller service timeout\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&sys_controller->c, timeout)) {\n\t\tret = -EBADMSG;\n\t\tdev_warn(sys_controller->client.dev, \"MPFS sys controller service failed\\n\");\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\tmutex_unlock(&transaction_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mpfs_blocking_transaction);\n\nstatic void mpfs_sys_controller_rx_callback(struct mbox_client *client, void *msg)\n{\n\tstruct mpfs_sys_controller *sys_controller =\n\t\tcontainer_of(client, struct mpfs_sys_controller, client);\n\n\tcomplete(&sys_controller->c);\n}\n\nstatic void mpfs_sys_controller_delete(struct kref *kref)\n{\n\tstruct mpfs_sys_controller *sys_controller =\n\t\tcontainer_of(kref, struct mpfs_sys_controller, consumers);\n\n\tmbox_free_channel(sys_controller->chan);\n\tkfree(sys_controller);\n}\n\nstatic void mpfs_sys_controller_put(void *data)\n{\n\tstruct mpfs_sys_controller *sys_controller = data;\n\n\tkref_put(&sys_controller->consumers, mpfs_sys_controller_delete);\n}\n\nstatic struct platform_device subdevs[] = {\n\t{\n\t\t.name\t\t= \"mpfs-rng\",\n\t\t.id\t\t= -1,\n\t},\n\t{\n\t\t.name\t\t= \"mpfs-generic-service\",\n\t\t.id\t\t= -1,\n\t}\n};\n\nstatic int mpfs_sys_controller_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mpfs_sys_controller *sys_controller;\n\tint i, ret;\n\n\tsys_controller = kzalloc(sizeof(*sys_controller), GFP_KERNEL);\n\tif (!sys_controller)\n\t\treturn -ENOMEM;\n\n\tsys_controller->client.dev = dev;\n\tsys_controller->client.rx_callback = mpfs_sys_controller_rx_callback;\n\tsys_controller->client.tx_block = 1U;\n\tsys_controller->client.tx_tout = msecs_to_jiffies(MPFS_SYS_CTRL_TIMEOUT_MS);\n\n\tsys_controller->chan = mbox_request_channel(&sys_controller->client, 0);\n\tif (IS_ERR(sys_controller->chan)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(sys_controller->chan),\n\t\t\t\t    \"Failed to get mbox channel\\n\");\n\t\tkfree(sys_controller);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&sys_controller->c);\n\tkref_init(&sys_controller->consumers);\n\n\tplatform_set_drvdata(pdev, sys_controller);\n\n\tdev_info(&pdev->dev, \"Registered MPFS system controller\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(subdevs); i++) {\n\t\tsubdevs[i].dev.parent = dev;\n\t\tif (platform_device_register(&subdevs[i]))\n\t\t\tdev_warn(dev, \"Error registering sub device %s\\n\", subdevs[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int mpfs_sys_controller_remove(struct platform_device *pdev)\n{\n\tstruct mpfs_sys_controller *sys_controller = platform_get_drvdata(pdev);\n\n\tmpfs_sys_controller_put(sys_controller);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mpfs_sys_controller_of_match[] = {\n\t{.compatible = \"microchip,mpfs-sys-controller\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpfs_sys_controller_of_match);\n\nstruct mpfs_sys_controller *mpfs_sys_controller_get(struct device *dev)\n{\n\tconst struct of_device_id *match;\n\tstruct mpfs_sys_controller *sys_controller;\n\tint ret;\n\n\tif (!dev->parent)\n\t\tgoto err_no_device;\n\n\tmatch = of_match_node(mpfs_sys_controller_of_match,  dev->parent->of_node);\n\tof_node_put(dev->parent->of_node);\n\tif (!match)\n\t\tgoto err_no_device;\n\n\tsys_controller = dev_get_drvdata(dev->parent);\n\tif (!sys_controller)\n\t\tgoto err_bad_device;\n\n\tif (!kref_get_unless_zero(&sys_controller->consumers))\n\t\tgoto err_bad_device;\n\n\tret = devm_add_action_or_reset(dev, mpfs_sys_controller_put, sys_controller);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn sys_controller;\n\nerr_no_device:\n\tdev_dbg(dev, \"Parent device was not an MPFS system controller\\n\");\n\treturn ERR_PTR(-ENODEV);\n\nerr_bad_device:\n\tdev_dbg(dev, \"MPFS system controller found but could not register as a sub device\\n\");\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL(mpfs_sys_controller_get);\n\nstatic struct platform_driver mpfs_sys_controller_driver = {\n\t.driver = {\n\t\t.name = \"mpfs-sys-controller\",\n\t\t.of_match_table = mpfs_sys_controller_of_match,\n\t},\n\t.probe = mpfs_sys_controller_probe,\n\t.remove = mpfs_sys_controller_remove,\n};\nmodule_platform_driver(mpfs_sys_controller_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_DESCRIPTION(\"MPFS system controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}