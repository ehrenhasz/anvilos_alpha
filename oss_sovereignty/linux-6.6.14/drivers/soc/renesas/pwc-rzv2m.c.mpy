{
  "module_name": "pwc-rzv2m.c",
  "hash_id": "756c50f9176021de2e6a2000614c90339c3e2c89380597faa7af0739e19252ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soc/renesas/pwc-rzv2m.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n\n#define PWC_PWCRST\t\t\t0x00\n#define PWC_PWCCKEN\t\t\t0x04\n#define PWC_PWCCTL\t\t\t0x50\n#define PWC_GPIO\t\t\t0x80\n\n#define PWC_PWCRST_RSTSOFTAX\t\t0x1\n#define PWC_PWCCKEN_ENGCKMAIN\t\t0x1\n#define PWC_PWCCTL_PWOFF\t\t0x1\n\nstruct rzv2m_pwc_priv {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct gpio_chip gp;\n\tDECLARE_BITMAP(ch_en_bits, 2);\n};\n\nstatic void rzv2m_pwc_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t       int value)\n{\n\tstruct rzv2m_pwc_priv *priv = gpiochip_get_data(chip);\n\tu32 reg;\n\n\t \n\treg = BIT(offset + 16);\n\tif (value)\n\t\treg |= BIT(offset);\n\n\twritel(reg, priv->base + PWC_GPIO);\n\n\tassign_bit(offset, priv->ch_en_bits, value);\n}\n\nstatic int rzv2m_pwc_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzv2m_pwc_priv *priv = gpiochip_get_data(chip);\n\n\treturn test_bit(offset, priv->ch_en_bits);\n}\n\nstatic int rzv2m_pwc_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t   unsigned int nr, int value)\n{\n\tif (nr > 1)\n\t\treturn -EINVAL;\n\n\trzv2m_pwc_gpio_set(gc, nr, value);\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip rzv2m_pwc_gc = {\n\t.label = \"gpio_rzv2m_pwc\",\n\t.owner = THIS_MODULE,\n\t.get = rzv2m_pwc_gpio_get,\n\t.set = rzv2m_pwc_gpio_set,\n\t.direction_output = rzv2m_pwc_gpio_direction_output,\n\t.can_sleep = false,\n\t.ngpio = 2,\n\t.base = -1,\n};\n\nstatic int rzv2m_pwc_poweroff(struct sys_off_data *data)\n{\n\tstruct rzv2m_pwc_priv *priv = data->cb_data;\n\n\twritel(PWC_PWCRST_RSTSOFTAX, priv->base + PWC_PWCRST);\n\twritel(PWC_PWCCKEN_ENGCKMAIN, priv->base + PWC_PWCCKEN);\n\twritel(PWC_PWCCTL_PWOFF, priv->base + PWC_PWCCTL);\n\n\tmdelay(150);\n\n\tdev_err(priv->dev, \"Failed to power off the system\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int rzv2m_pwc_probe(struct platform_device *pdev)\n{\n\tstruct rzv2m_pwc_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\t \n\twritel(BIT(17) | BIT(16), priv->base + PWC_GPIO);\n\tbitmap_zero(priv->ch_en_bits, 2);\n\n\tpriv->gp = rzv2m_pwc_gc;\n\tpriv->gp.parent = pdev->dev.parent;\n\tpriv->gp.fwnode = dev_fwnode(&pdev->dev);\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &priv->gp, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(&pdev->dev, \"renesas,rzv2m-pwc-power\"))\n\t\tret = devm_register_power_off_handler(&pdev->dev,\n\t\t\t\t\t\t      rzv2m_pwc_poweroff, priv);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id rzv2m_pwc_of_match[] = {\n\t{ .compatible = \"renesas,rzv2m-pwc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzv2m_pwc_of_match);\n\nstatic struct platform_driver rzv2m_pwc_driver = {\n\t.probe = rzv2m_pwc_probe,\n\t.driver = {\n\t\t.name = \"rzv2m_pwc\",\n\t\t.of_match_table = rzv2m_pwc_of_match,\n\t},\n};\nmodule_platform_driver(rzv2m_pwc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fabrizio Castro <castro.fabrizio.jz@renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/V2M PWC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}