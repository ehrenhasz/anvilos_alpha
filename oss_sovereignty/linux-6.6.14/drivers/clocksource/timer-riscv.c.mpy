{
  "module_name": "timer-riscv.c",
  "hash_id": "4e6d6271b5c9b6094afc27a8db816f4572fac31fb973e67fb5c67c703404050d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-riscv.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"riscv-timer: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/sched_clock.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/interrupt.h>\n#include <linux/of_irq.h>\n#include <clocksource/timer-riscv.h>\n#include <asm/smp.h>\n#include <asm/hwcap.h>\n#include <asm/sbi.h>\n#include <asm/timex.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(riscv_sstc_available);\nstatic bool riscv_timer_cannot_wake_cpu;\n\nstatic int riscv_clock_next_event(unsigned long delta,\n\t\tstruct clock_event_device *ce)\n{\n\tu64 next_tval = get_cycles64() + delta;\n\n\tcsr_set(CSR_IE, IE_TIE);\n\tif (static_branch_likely(&riscv_sstc_available)) {\n#if defined(CONFIG_32BIT)\n\t\tcsr_write(CSR_STIMECMP, next_tval & 0xFFFFFFFF);\n\t\tcsr_write(CSR_STIMECMPH, next_tval >> 32);\n#else\n\t\tcsr_write(CSR_STIMECMP, next_tval);\n#endif\n\t} else\n\t\tsbi_set_timer(next_tval);\n\n\treturn 0;\n}\n\nstatic unsigned int riscv_clock_event_irq;\nstatic DEFINE_PER_CPU(struct clock_event_device, riscv_clock_event) = {\n\t.name\t\t\t= \"riscv_timer_clockevent\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 100,\n\t.set_next_event\t\t= riscv_clock_next_event,\n};\n\n \nstatic unsigned long long riscv_clocksource_rdtime(struct clocksource *cs)\n{\n\treturn get_cycles64();\n}\n\nstatic u64 notrace riscv_sched_clock(void)\n{\n\treturn get_cycles64();\n}\n\nstatic struct clocksource riscv_clocksource = {\n\t.name\t\t= \"riscv_clocksource\",\n\t.rating\t\t= 400,\n\t.mask\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.read\t\t= riscv_clocksource_rdtime,\n#if IS_ENABLED(CONFIG_GENERIC_GETTIMEOFDAY)\n\t.vdso_clock_mode = VDSO_CLOCKMODE_ARCHTIMER,\n#else\n\t.vdso_clock_mode = VDSO_CLOCKMODE_NONE,\n#endif\n};\n\nstatic int riscv_timer_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *ce = per_cpu_ptr(&riscv_clock_event, cpu);\n\n\tce->cpumask = cpumask_of(cpu);\n\tce->irq = riscv_clock_event_irq;\n\tif (riscv_timer_cannot_wake_cpu)\n\t\tce->features |= CLOCK_EVT_FEAT_C3STOP;\n\tclockevents_config_and_register(ce, riscv_timebase, 100, 0x7fffffff);\n\n\tenable_percpu_irq(riscv_clock_event_irq,\n\t\t\t  irq_get_trigger_type(riscv_clock_event_irq));\n\treturn 0;\n}\n\nstatic int riscv_timer_dying_cpu(unsigned int cpu)\n{\n\tdisable_percpu_irq(riscv_clock_event_irq);\n\treturn 0;\n}\n\nvoid riscv_cs_get_mult_shift(u32 *mult, u32 *shift)\n{\n\t*mult = riscv_clocksource.mult;\n\t*shift = riscv_clocksource.shift;\n}\nEXPORT_SYMBOL_GPL(riscv_cs_get_mult_shift);\n\n \nstatic irqreturn_t riscv_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evdev = this_cpu_ptr(&riscv_clock_event);\n\n\tcsr_clear(CSR_IE, IE_TIE);\n\tevdev->event_handler(evdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init riscv_timer_init_common(void)\n{\n\tint error;\n\tstruct irq_domain *domain;\n\tstruct fwnode_handle *intc_fwnode = riscv_get_intc_hwnode();\n\n\tdomain = irq_find_matching_fwnode(intc_fwnode, DOMAIN_BUS_ANY);\n\tif (!domain) {\n\t\tpr_err(\"Failed to find irq_domain for INTC node [%pfwP]\\n\",\n\t\t       intc_fwnode);\n\t\treturn -ENODEV;\n\t}\n\n\triscv_clock_event_irq = irq_create_mapping(domain, RV_IRQ_TIMER);\n\tif (!riscv_clock_event_irq) {\n\t\tpr_err(\"Failed to map timer interrupt for node [%pfwP]\\n\", intc_fwnode);\n\t\treturn -ENODEV;\n\t}\n\n\terror = clocksource_register_hz(&riscv_clocksource, riscv_timebase);\n\tif (error) {\n\t\tpr_err(\"RISCV timer registration failed [%d]\\n\", error);\n\t\treturn error;\n\t}\n\n\tsched_clock_register(riscv_sched_clock, 64, riscv_timebase);\n\n\terror = request_percpu_irq(riscv_clock_event_irq,\n\t\t\t\t    riscv_timer_interrupt,\n\t\t\t\t    \"riscv-timer\", &riscv_clock_event);\n\tif (error) {\n\t\tpr_err(\"registering percpu irq failed [%d]\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (riscv_isa_extension_available(NULL, SSTC)) {\n\t\tpr_info(\"Timer interrupt in S-mode is available via sstc extension\\n\");\n\t\tstatic_branch_enable(&riscv_sstc_available);\n\t}\n\n\terror = cpuhp_setup_state(CPUHP_AP_RISCV_TIMER_STARTING,\n\t\t\t \"clockevents/riscv/timer:starting\",\n\t\t\t riscv_timer_starting_cpu, riscv_timer_dying_cpu);\n\tif (error)\n\t\tpr_err(\"cpu hp setup state failed for RISCV timer [%d]\\n\",\n\t\t       error);\n\n\treturn error;\n}\n\nstatic int __init riscv_timer_init_dt(struct device_node *n)\n{\n\tint cpuid, error;\n\tunsigned long hartid;\n\tstruct device_node *child;\n\n\terror = riscv_of_processor_hartid(n, &hartid);\n\tif (error < 0) {\n\t\tpr_warn(\"Invalid hartid for node [%pOF] error = [%lu]\\n\",\n\t\t\tn, hartid);\n\t\treturn error;\n\t}\n\n\tcpuid = riscv_hartid_to_cpuid(hartid);\n\tif (cpuid < 0) {\n\t\tpr_warn(\"Invalid cpuid for hartid [%lu]\\n\", hartid);\n\t\treturn cpuid;\n\t}\n\n\tif (cpuid != smp_processor_id())\n\t\treturn 0;\n\n\tchild = of_find_compatible_node(NULL, NULL, \"riscv,timer\");\n\tif (child) {\n\t\triscv_timer_cannot_wake_cpu = of_property_read_bool(child,\n\t\t\t\t\t\"riscv,timer-cannot-wake-cpu\");\n\t\tof_node_put(child);\n\t}\n\n\treturn riscv_timer_init_common();\n}\n\nTIMER_OF_DECLARE(riscv_timer, \"riscv\", riscv_timer_init_dt);\n\n#ifdef CONFIG_ACPI\nstatic int __init riscv_timer_acpi_init(struct acpi_table_header *table)\n{\n\treturn riscv_timer_init_common();\n}\n\nTIMER_ACPI_DECLARE(aclint_mtimer, ACPI_SIG_RHCT, riscv_timer_acpi_init);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}