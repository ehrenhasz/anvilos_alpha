{
  "module_name": "timer-cadence-ttc.c",
  "hash_id": "e3f961c985e5dd32554a958471bea75d8d37b1535de0824632cd01f4e85468e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-cadence-ttc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sched_clock.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n\n \n\n \n#define TTC_CLK_CNTRL_OFFSET\t\t0x00  \n#define TTC_CNT_CNTRL_OFFSET\t\t0x0C  \n#define TTC_COUNT_VAL_OFFSET\t\t0x18  \n#define TTC_INTR_VAL_OFFSET\t\t0x24  \n#define TTC_ISR_OFFSET\t\t0x54  \n#define TTC_IER_OFFSET\t\t0x60  \n\n#define TTC_CNT_CNTRL_DISABLE_MASK\t0x1\n\n#define TTC_CLK_CNTRL_CSRC_MASK\t\t(1 << 5)\t \n#define TTC_CLK_CNTRL_PSV_MASK\t\t0x1e\n#define TTC_CLK_CNTRL_PSV_SHIFT\t\t1\n\n \n#define PRESCALE_EXPONENT\t11\t \n#define PRESCALE\t\t2048\t \n#define CLK_CNTRL_PRESCALE\t((PRESCALE_EXPONENT - 1) << 1)\n#define CLK_CNTRL_PRESCALE_EN\t1\n#define CNT_CNTRL_RESET\t\t(1 << 4)\n\n#define MAX_F_ERR 50\n\n \nstruct ttc_timer {\n\tvoid __iomem *base_addr;\n\tunsigned long freq;\n\tstruct clk *clk;\n\tstruct notifier_block clk_rate_change_nb;\n};\n\n#define to_ttc_timer(x) \\\n\t\tcontainer_of(x, struct ttc_timer, clk_rate_change_nb)\n\nstruct ttc_timer_clocksource {\n\tu32\t\t\tscale_clk_ctrl_reg_old;\n\tu32\t\t\tscale_clk_ctrl_reg_new;\n\tstruct ttc_timer\tttc;\n\tstruct clocksource\tcs;\n};\n\n#define to_ttc_timer_clksrc(x) \\\n\t\tcontainer_of(x, struct ttc_timer_clocksource, cs)\n\nstruct ttc_timer_clockevent {\n\tstruct ttc_timer\t\tttc;\n\tstruct clock_event_device\tce;\n};\n\n#define to_ttc_timer_clkevent(x) \\\n\t\tcontainer_of(x, struct ttc_timer_clockevent, ce)\n\nstatic void __iomem *ttc_sched_clock_val_reg;\n\n \nstatic void ttc_set_interval(struct ttc_timer *timer,\n\t\t\t\t\tunsigned long cycles)\n{\n\tu32 ctrl_reg;\n\n\t \n\tctrl_reg = readl_relaxed(timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\tctrl_reg |= TTC_CNT_CNTRL_DISABLE_MASK;\n\twritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\n\twritel_relaxed(cycles, timer->base_addr + TTC_INTR_VAL_OFFSET);\n\n\t \n\tctrl_reg |= CNT_CNTRL_RESET;\n\tctrl_reg &= ~TTC_CNT_CNTRL_DISABLE_MASK;\n\twritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n}\n\n \nstatic irqreturn_t ttc_clock_event_interrupt(int irq, void *dev_id)\n{\n\tstruct ttc_timer_clockevent *ttce = dev_id;\n\tstruct ttc_timer *timer = &ttce->ttc;\n\n\t \n\treadl_relaxed(timer->base_addr + TTC_ISR_OFFSET);\n\n\tttce->ce.event_handler(&ttce->ce);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic u64 __ttc_clocksource_read(struct clocksource *cs)\n{\n\tstruct ttc_timer *timer = &to_ttc_timer_clksrc(cs)->ttc;\n\n\treturn (u64)readl_relaxed(timer->base_addr +\n\t\t\t\tTTC_COUNT_VAL_OFFSET);\n}\n\nstatic u64 notrace ttc_sched_clock_read(void)\n{\n\treturn readl_relaxed(ttc_sched_clock_val_reg);\n}\n\n \nstatic int ttc_set_next_event(unsigned long cycles,\n\t\t\t\t\tstruct clock_event_device *evt)\n{\n\tstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\n\tstruct ttc_timer *timer = &ttce->ttc;\n\n\tttc_set_interval(timer, cycles);\n\treturn 0;\n}\n\n \nstatic int ttc_shutdown(struct clock_event_device *evt)\n{\n\tstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\n\tstruct ttc_timer *timer = &ttce->ttc;\n\tu32 ctrl_reg;\n\n\tctrl_reg = readl_relaxed(timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\tctrl_reg |= TTC_CNT_CNTRL_DISABLE_MASK;\n\twritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\treturn 0;\n}\n\nstatic int ttc_set_periodic(struct clock_event_device *evt)\n{\n\tstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\n\tstruct ttc_timer *timer = &ttce->ttc;\n\n\tttc_set_interval(timer,\n\t\t\t DIV_ROUND_CLOSEST(ttce->ttc.freq, PRESCALE * HZ));\n\treturn 0;\n}\n\nstatic int ttc_resume(struct clock_event_device *evt)\n{\n\tstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\n\tstruct ttc_timer *timer = &ttce->ttc;\n\tu32 ctrl_reg;\n\n\tctrl_reg = readl_relaxed(timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\tctrl_reg &= ~TTC_CNT_CNTRL_DISABLE_MASK;\n\twritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\n\treturn 0;\n}\n\nstatic int ttc_rate_change_clocksource_cb(struct notifier_block *nb,\n\t\tunsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct ttc_timer *ttc = to_ttc_timer(nb);\n\tstruct ttc_timer_clocksource *ttccs = container_of(ttc,\n\t\t\tstruct ttc_timer_clocksource, ttc);\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t{\n\t\tu32 psv;\n\t\tunsigned long factor, rate_low, rate_high;\n\n\t\tif (ndata->new_rate > ndata->old_rate) {\n\t\t\tfactor = DIV_ROUND_CLOSEST(ndata->new_rate,\n\t\t\t\t\tndata->old_rate);\n\t\t\trate_low = ndata->old_rate;\n\t\t\trate_high = ndata->new_rate;\n\t\t} else {\n\t\t\tfactor = DIV_ROUND_CLOSEST(ndata->old_rate,\n\t\t\t\t\tndata->new_rate);\n\t\t\trate_low = ndata->new_rate;\n\t\t\trate_high = ndata->old_rate;\n\t\t}\n\n\t\tif (!is_power_of_2(factor))\n\t\t\t\treturn NOTIFY_BAD;\n\n\t\tif (abs(rate_high - (factor * rate_low)) > MAX_F_ERR)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tfactor = __ilog2_u32(factor);\n\n\t\t \n\t\tttccs->scale_clk_ctrl_reg_old =\n\t\t\treadl_relaxed(ttccs->ttc.base_addr +\n\t\t\tTTC_CLK_CNTRL_OFFSET);\n\n\t\tpsv = (ttccs->scale_clk_ctrl_reg_old &\n\t\t\t\tTTC_CLK_CNTRL_PSV_MASK) >>\n\t\t\t\tTTC_CLK_CNTRL_PSV_SHIFT;\n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\tpsv -= factor;\n\t\telse\n\t\t\tpsv += factor;\n\n\t\t \n\t\tif (psv & ~(TTC_CLK_CNTRL_PSV_MASK >> TTC_CLK_CNTRL_PSV_SHIFT))\n\t\t\treturn NOTIFY_BAD;\n\n\t\tttccs->scale_clk_ctrl_reg_new = ttccs->scale_clk_ctrl_reg_old &\n\t\t\t~TTC_CLK_CNTRL_PSV_MASK;\n\t\tttccs->scale_clk_ctrl_reg_new |= psv << TTC_CLK_CNTRL_PSV_SHIFT;\n\n\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\treturn NOTIFY_DONE;\n\n\t\t \n\t\twritel_relaxed(ttccs->scale_clk_ctrl_reg_new,\n\t\t\t       ttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\n\t\tbreak;\n\t}\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\twritel_relaxed(ttccs->scale_clk_ctrl_reg_new,\n\t\t\t       ttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\n\t\tbreak;\n\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\twritel_relaxed(ttccs->scale_clk_ctrl_reg_old,\n\t\t\t       ttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\n\t\tfallthrough;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init ttc_setup_clocksource(struct clk *clk, void __iomem *base,\n\t\t\t\t\t u32 timer_width)\n{\n\tstruct ttc_timer_clocksource *ttccs;\n\tint err;\n\n\tttccs = kzalloc(sizeof(*ttccs), GFP_KERNEL);\n\tif (!ttccs)\n\t\treturn -ENOMEM;\n\n\tttccs->ttc.clk = clk;\n\n\terr = clk_prepare_enable(ttccs->ttc.clk);\n\tif (err) {\n\t\tkfree(ttccs);\n\t\treturn err;\n\t}\n\n\tttccs->ttc.freq = clk_get_rate(ttccs->ttc.clk);\n\n\tttccs->ttc.clk_rate_change_nb.notifier_call =\n\t\tttc_rate_change_clocksource_cb;\n\tttccs->ttc.clk_rate_change_nb.next = NULL;\n\n\terr = clk_notifier_register(ttccs->ttc.clk,\n\t\t\t\t    &ttccs->ttc.clk_rate_change_nb);\n\tif (err)\n\t\tpr_warn(\"Unable to register clock notifier.\\n\");\n\n\tttccs->ttc.base_addr = base;\n\tttccs->cs.name = \"ttc_clocksource\";\n\tttccs->cs.rating = 200;\n\tttccs->cs.read = __ttc_clocksource_read;\n\tttccs->cs.mask = CLOCKSOURCE_MASK(timer_width);\n\tttccs->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\t \n\twritel_relaxed(0x0,  ttccs->ttc.base_addr + TTC_IER_OFFSET);\n\twritel_relaxed(CLK_CNTRL_PRESCALE | CLK_CNTRL_PRESCALE_EN,\n\t\t     ttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\n\twritel_relaxed(CNT_CNTRL_RESET,\n\t\t     ttccs->ttc.base_addr + TTC_CNT_CNTRL_OFFSET);\n\n\terr = clocksource_register_hz(&ttccs->cs, ttccs->ttc.freq / PRESCALE);\n\tif (err) {\n\t\tkfree(ttccs);\n\t\treturn err;\n\t}\n\n\tttc_sched_clock_val_reg = base + TTC_COUNT_VAL_OFFSET;\n\tsched_clock_register(ttc_sched_clock_read, timer_width,\n\t\t\t     ttccs->ttc.freq / PRESCALE);\n\n\treturn 0;\n}\n\nstatic int ttc_rate_change_clockevent_cb(struct notifier_block *nb,\n\t\tunsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct ttc_timer *ttc = to_ttc_timer(nb);\n\tstruct ttc_timer_clockevent *ttcce = container_of(ttc,\n\t\t\tstruct ttc_timer_clockevent, ttc);\n\n\tswitch (event) {\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tttc->freq = ndata->new_rate;\n\n\t\tclockevents_update_freq(&ttcce->ce, ndata->new_rate / PRESCALE);\n\n\t\tfallthrough;\n\tcase PRE_RATE_CHANGE:\n\tcase ABORT_RATE_CHANGE:\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic int __init ttc_setup_clockevent(struct clk *clk,\n\t\t\t\t       void __iomem *base, u32 irq)\n{\n\tstruct ttc_timer_clockevent *ttcce;\n\tint err;\n\n\tttcce = kzalloc(sizeof(*ttcce), GFP_KERNEL);\n\tif (!ttcce)\n\t\treturn -ENOMEM;\n\n\tttcce->ttc.clk = clk;\n\n\terr = clk_prepare_enable(ttcce->ttc.clk);\n\tif (err)\n\t\tgoto out_kfree;\n\n\tttcce->ttc.clk_rate_change_nb.notifier_call =\n\t\tttc_rate_change_clockevent_cb;\n\tttcce->ttc.clk_rate_change_nb.next = NULL;\n\n\terr = clk_notifier_register(ttcce->ttc.clk,\n\t\t\t\t    &ttcce->ttc.clk_rate_change_nb);\n\tif (err) {\n\t\tpr_warn(\"Unable to register clock notifier.\\n\");\n\t\tgoto out_kfree;\n\t}\n\n\tttcce->ttc.freq = clk_get_rate(ttcce->ttc.clk);\n\n\tttcce->ttc.base_addr = base;\n\tttcce->ce.name = \"ttc_clockevent\";\n\tttcce->ce.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tttcce->ce.set_next_event = ttc_set_next_event;\n\tttcce->ce.set_state_shutdown = ttc_shutdown;\n\tttcce->ce.set_state_periodic = ttc_set_periodic;\n\tttcce->ce.set_state_oneshot = ttc_shutdown;\n\tttcce->ce.tick_resume = ttc_resume;\n\tttcce->ce.rating = 200;\n\tttcce->ce.irq = irq;\n\tttcce->ce.cpumask = cpu_possible_mask;\n\n\t \n\twritel_relaxed(0x23, ttcce->ttc.base_addr + TTC_CNT_CNTRL_OFFSET);\n\twritel_relaxed(CLK_CNTRL_PRESCALE | CLK_CNTRL_PRESCALE_EN,\n\t\t     ttcce->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\n\twritel_relaxed(0x1,  ttcce->ttc.base_addr + TTC_IER_OFFSET);\n\n\terr = request_irq(irq, ttc_clock_event_interrupt,\n\t\t\t  IRQF_TIMER, ttcce->ce.name, ttcce);\n\tif (err)\n\t\tgoto out_kfree;\n\n\tclockevents_config_and_register(&ttcce->ce,\n\t\t\tttcce->ttc.freq / PRESCALE, 1, 0xfffe);\n\n\treturn 0;\n\nout_kfree:\n\tkfree(ttcce);\n\treturn err;\n}\n\nstatic int __init ttc_timer_probe(struct platform_device *pdev)\n{\n\tunsigned int irq;\n\tvoid __iomem *timer_baseaddr;\n\tstruct clk *clk_cs, *clk_ce;\n\tstatic int initialized;\n\tint clksel, ret;\n\tu32 timer_width = 16;\n\tstruct device_node *timer = pdev->dev.of_node;\n\n\tif (initialized)\n\t\treturn 0;\n\n\tinitialized = 1;\n\n\t \n\ttimer_baseaddr = devm_of_iomap(&pdev->dev, timer, 0, NULL);\n\tif (IS_ERR(timer_baseaddr)) {\n\t\tpr_err(\"ERROR: invalid timer base address\\n\");\n\t\treturn PTR_ERR(timer_baseaddr);\n\t}\n\n\tirq = irq_of_parse_and_map(timer, 1);\n\tif (irq <= 0) {\n\t\tpr_err(\"ERROR: invalid interrupt number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32(timer, \"timer-width\", &timer_width);\n\n\tclksel = readl_relaxed(timer_baseaddr + TTC_CLK_CNTRL_OFFSET);\n\tclksel = !!(clksel & TTC_CLK_CNTRL_CSRC_MASK);\n\tclk_cs = of_clk_get(timer, clksel);\n\tif (IS_ERR(clk_cs)) {\n\t\tpr_err(\"ERROR: timer input clock not found\\n\");\n\t\treturn PTR_ERR(clk_cs);\n\t}\n\n\tclksel = readl_relaxed(timer_baseaddr + 4 + TTC_CLK_CNTRL_OFFSET);\n\tclksel = !!(clksel & TTC_CLK_CNTRL_CSRC_MASK);\n\tclk_ce = of_clk_get(timer, clksel);\n\tif (IS_ERR(clk_ce)) {\n\t\tpr_err(\"ERROR: timer input clock not found\\n\");\n\t\tret = PTR_ERR(clk_ce);\n\t\tgoto put_clk_cs;\n\t}\n\n\tret = ttc_setup_clocksource(clk_cs, timer_baseaddr, timer_width);\n\tif (ret)\n\t\tgoto put_clk_ce;\n\n\tret = ttc_setup_clockevent(clk_ce, timer_baseaddr + 4, irq);\n\tif (ret)\n\t\tgoto put_clk_ce;\n\n\tpr_info(\"%pOFn #0 at %p, irq=%d\\n\", timer, timer_baseaddr, irq);\n\n\treturn 0;\n\nput_clk_ce:\n\tclk_put(clk_ce);\nput_clk_cs:\n\tclk_put(clk_cs);\n\treturn ret;\n}\n\nstatic const struct of_device_id ttc_timer_of_match[] = {\n\t{.compatible = \"cdns,ttc\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, ttc_timer_of_match);\n\nstatic struct platform_driver ttc_timer_driver = {\n\t.driver = {\n\t\t.name\t= \"cdns_ttc_timer\",\n\t\t.of_match_table = ttc_timer_of_match,\n\t},\n};\nbuiltin_platform_driver_probe(ttc_timer_driver, ttc_timer_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}