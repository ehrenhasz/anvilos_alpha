{
  "module_name": "timer-keystone.c",
  "hash_id": "1c81812107b7f404e76a7b5baa575b53c165572e7fadad9183eef1662828940e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-keystone.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define TIMER_NAME\t\t\t\"timer-keystone\"\n\n \n#define TIM12\t\t\t\t0x10\n#define TIM34\t\t\t\t0x14\n#define PRD12\t\t\t\t0x18\n#define PRD34\t\t\t\t0x1c\n#define TCR\t\t\t\t0x20\n#define TGCR\t\t\t\t0x24\n#define INTCTLSTAT\t\t\t0x44\n\n \n#define TCR_ENAMODE_MASK\t\t0xC0\n#define TCR_ENAMODE_ONESHOT_MASK\t0x40\n#define TCR_ENAMODE_PERIODIC_MASK\t0x80\n\n#define TGCR_TIM_UNRESET_MASK\t\t0x03\n#define INTCTLSTAT_ENINT_MASK\t\t0x01\n\n \nstatic struct keystone_timer {\n\tvoid __iomem *base;\n\tunsigned long hz_period;\n\tstruct clock_event_device event_dev;\n} timer;\n\nstatic inline u32 keystone_timer_readl(unsigned long rg)\n{\n\treturn readl_relaxed(timer.base + rg);\n}\n\nstatic inline void keystone_timer_writel(u32 val, unsigned long rg)\n{\n\twritel_relaxed(val, timer.base + rg);\n}\n\n \nstatic inline void keystone_timer_barrier(void)\n{\n\t__iowmb();\n}\n\n \nstatic int keystone_timer_config(u64 period, int mask)\n{\n\tu32 tcr;\n\tu32 off;\n\n\ttcr = keystone_timer_readl(TCR);\n\toff = tcr & ~(TCR_ENAMODE_MASK);\n\n\t \n\ttcr |= mask;\n\n\t \n\tkeystone_timer_writel(off, TCR);\n\t \n\tkeystone_timer_barrier();\n\n\t \n\tkeystone_timer_writel(0, TIM12);\n\tkeystone_timer_writel(0, TIM34);\n\tkeystone_timer_writel(period & 0xffffffff, PRD12);\n\tkeystone_timer_writel(period >> 32, PRD34);\n\n\t \n\tkeystone_timer_barrier();\n\tkeystone_timer_writel(tcr, TCR);\n\treturn 0;\n}\n\nstatic void keystone_timer_disable(void)\n{\n\tu32 tcr;\n\n\ttcr = keystone_timer_readl(TCR);\n\n\t \n\ttcr &= ~(TCR_ENAMODE_MASK);\n\tkeystone_timer_writel(tcr, TCR);\n}\n\nstatic irqreturn_t keystone_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic int keystone_set_next_event(unsigned long cycles,\n\t\t\t\t  struct clock_event_device *evt)\n{\n\treturn keystone_timer_config(cycles, TCR_ENAMODE_ONESHOT_MASK);\n}\n\nstatic int keystone_shutdown(struct clock_event_device *evt)\n{\n\tkeystone_timer_disable();\n\treturn 0;\n}\n\nstatic int keystone_set_periodic(struct clock_event_device *evt)\n{\n\tkeystone_timer_config(timer.hz_period, TCR_ENAMODE_PERIODIC_MASK);\n\treturn 0;\n}\n\nstatic int __init keystone_timer_init(struct device_node *np)\n{\n\tstruct clock_event_device *event_dev = &timer.event_dev;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint irq, error;\n\n\tirq  = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tpr_err(\"%s: failed to map interrupts\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttimer.base = of_iomap(np, 0);\n\tif (!timer.base) {\n\t\tpr_err(\"%s: failed to map registers\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s: failed to get clock\\n\", __func__);\n\t\tiounmap(timer.base);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\terror = clk_prepare_enable(clk);\n\tif (error) {\n\t\tpr_err(\"%s: failed to enable clock\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\trate = clk_get_rate(clk);\n\n\t \n\tkeystone_timer_writel(0, TCR);\n\t \n\tkeystone_timer_barrier();\n\n\t \n\tkeystone_timer_writel(0, TGCR);\n\n\t \n\tkeystone_timer_writel(TGCR_TIM_UNRESET_MASK, TGCR);\n\n\t \n\tkeystone_timer_writel(0, TIM12);\n\tkeystone_timer_writel(0, TIM34);\n\n\ttimer.hz_period = DIV_ROUND_UP(rate, HZ);\n\n\t \n\tkeystone_timer_writel(INTCTLSTAT_ENINT_MASK, INTCTLSTAT);\n\n\terror = request_irq(irq, keystone_timer_interrupt, IRQF_TIMER,\n\t\t\t    TIMER_NAME, event_dev);\n\tif (error) {\n\t\tpr_err(\"%s: failed to setup irq\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\t \n\tevent_dev->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tevent_dev->set_next_event = keystone_set_next_event;\n\tevent_dev->set_state_shutdown = keystone_shutdown;\n\tevent_dev->set_state_periodic = keystone_set_periodic;\n\tevent_dev->set_state_oneshot = keystone_shutdown;\n\tevent_dev->cpumask = cpu_possible_mask;\n\tevent_dev->owner = THIS_MODULE;\n\tevent_dev->name = TIMER_NAME;\n\tevent_dev->irq = irq;\n\n\tclockevents_config_and_register(event_dev, rate, 1, ULONG_MAX);\n\n\tpr_info(\"keystone timer clock @%lu Hz\\n\", rate);\n\treturn 0;\nerr:\n\tclk_put(clk);\n\tiounmap(timer.base);\n\treturn error;\n}\n\nTIMER_OF_DECLARE(keystone_timer, \"ti,keystone-timer\",\n\t\t\t   keystone_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}