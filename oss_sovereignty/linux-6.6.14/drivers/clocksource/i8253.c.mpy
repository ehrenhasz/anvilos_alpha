{
  "module_name": "i8253.c",
  "hash_id": "622716aef6e47490b34ad9407e1b7622ff5bec399cce95409a71da47be99d34d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/i8253.c",
  "human_readable_source": "\n \n#include <linux/clockchips.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/timex.h>\n#include <linux/module.h>\n#include <linux/i8253.h>\n#include <linux/smp.h>\n\n \nDEFINE_RAW_SPINLOCK(i8253_lock);\nEXPORT_SYMBOL(i8253_lock);\n\n \nbool i8253_clear_counter_on_shutdown __ro_after_init = true;\n\n#ifdef CONFIG_CLKSRC_I8253\n \nstatic u64 i8253_read(struct clocksource *cs)\n{\n\tstatic int old_count;\n\tstatic u32 old_jifs;\n\tunsigned long flags;\n\tint count;\n\tu32 jifs;\n\n\traw_spin_lock_irqsave(&i8253_lock, flags);\n\t \n\tjifs = jiffies;\n\toutb_p(0x00, PIT_MODE);\t \n\tcount = inb_p(PIT_CH0);\t \n\tcount |= inb_p(PIT_CH0) << 8;\n\n\t \n\tif (count > PIT_LATCH) {\n\t\toutb_p(0x34, PIT_MODE);\n\t\toutb_p(PIT_LATCH & 0xff, PIT_CH0);\n\t\toutb_p(PIT_LATCH >> 8, PIT_CH0);\n\t\tcount = PIT_LATCH - 1;\n\t}\n\n\t \n\tif (count > old_count && jifs == old_jifs)\n\t\tcount = old_count;\n\n\told_count = count;\n\told_jifs = jifs;\n\n\traw_spin_unlock_irqrestore(&i8253_lock, flags);\n\n\tcount = (PIT_LATCH - 1) - count;\n\n\treturn (u64)(jifs * PIT_LATCH) + count;\n}\n\nstatic struct clocksource i8253_cs = {\n\t.name\t\t= \"pit\",\n\t.rating\t\t= 110,\n\t.read\t\t= i8253_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n};\n\nint __init clocksource_i8253_init(void)\n{\n\treturn clocksource_register_hz(&i8253_cs, PIT_TICK_RATE);\n}\n#endif\n\n#ifdef CONFIG_CLKEVT_I8253\nstatic int pit_shutdown(struct clock_event_device *evt)\n{\n\tif (!clockevent_state_oneshot(evt) && !clockevent_state_periodic(evt))\n\t\treturn 0;\n\n\traw_spin_lock(&i8253_lock);\n\n\toutb_p(0x30, PIT_MODE);\n\n\tif (i8253_clear_counter_on_shutdown) {\n\t\toutb_p(0, PIT_CH0);\n\t\toutb_p(0, PIT_CH0);\n\t}\n\n\traw_spin_unlock(&i8253_lock);\n\treturn 0;\n}\n\nstatic int pit_set_oneshot(struct clock_event_device *evt)\n{\n\traw_spin_lock(&i8253_lock);\n\toutb_p(0x38, PIT_MODE);\n\traw_spin_unlock(&i8253_lock);\n\treturn 0;\n}\n\nstatic int pit_set_periodic(struct clock_event_device *evt)\n{\n\traw_spin_lock(&i8253_lock);\n\n\t \n\toutb_p(0x34, PIT_MODE);\n\toutb_p(PIT_LATCH & 0xff, PIT_CH0);\t \n\toutb_p(PIT_LATCH >> 8, PIT_CH0);\t \n\n\traw_spin_unlock(&i8253_lock);\n\treturn 0;\n}\n\n \nstatic int pit_next_event(unsigned long delta, struct clock_event_device *evt)\n{\n\traw_spin_lock(&i8253_lock);\n\toutb_p(delta & 0xff , PIT_CH0);\t \n\toutb_p(delta >> 8 , PIT_CH0);\t\t \n\traw_spin_unlock(&i8253_lock);\n\n\treturn 0;\n}\n\n \nstruct clock_event_device i8253_clockevent = {\n\t.name\t\t\t= \"pit\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC,\n\t.set_state_shutdown\t= pit_shutdown,\n\t.set_state_periodic\t= pit_set_periodic,\n\t.set_next_event\t\t= pit_next_event,\n};\n\n \nvoid __init clockevent_i8253_init(bool oneshot)\n{\n\tif (oneshot) {\n\t\ti8253_clockevent.features |= CLOCK_EVT_FEAT_ONESHOT;\n\t\ti8253_clockevent.set_state_oneshot = pit_set_oneshot;\n\t}\n\t \n\ti8253_clockevent.cpumask = cpumask_of(smp_processor_id());\n\n\tclockevents_config_and_register(&i8253_clockevent, PIT_TICK_RATE,\n\t\t\t\t\t0xF, 0x7FFF);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}