{
  "module_name": "timer-sprd.c",
  "hash_id": "111ef53e5a4880400b6a2da9b16f4306d5e979e95490aa896c8f969adc24370c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n\n#include \"timer-of.h\"\n\n#define TIMER_NAME\t\t\"sprd_timer\"\n\n#define TIMER_LOAD_LO\t\t0x0\n#define TIMER_LOAD_HI\t\t0x4\n#define TIMER_VALUE_LO\t\t0x8\n#define TIMER_VALUE_HI\t\t0xc\n\n#define TIMER_CTL\t\t0x10\n#define TIMER_CTL_PERIOD_MODE\tBIT(0)\n#define TIMER_CTL_ENABLE\tBIT(1)\n#define TIMER_CTL_64BIT_WIDTH\tBIT(16)\n\n#define TIMER_INT\t\t0x14\n#define TIMER_INT_EN\t\tBIT(0)\n#define TIMER_INT_RAW_STS\tBIT(1)\n#define TIMER_INT_MASK_STS\tBIT(2)\n#define TIMER_INT_CLR\t\tBIT(3)\n\n#define TIMER_VALUE_SHDW_LO\t0x18\n#define TIMER_VALUE_SHDW_HI\t0x1c\n\n#define TIMER_VALUE_LO_MASK\tGENMASK(31, 0)\n\nstatic void sprd_timer_enable(void __iomem *base, u32 flag)\n{\n\tu32 val = readl_relaxed(base + TIMER_CTL);\n\n\tval |= TIMER_CTL_ENABLE;\n\tif (flag & TIMER_CTL_64BIT_WIDTH)\n\t\tval |= TIMER_CTL_64BIT_WIDTH;\n\telse\n\t\tval &= ~TIMER_CTL_64BIT_WIDTH;\n\n\tif (flag & TIMER_CTL_PERIOD_MODE)\n\t\tval |= TIMER_CTL_PERIOD_MODE;\n\telse\n\t\tval &= ~TIMER_CTL_PERIOD_MODE;\n\n\twritel_relaxed(val, base + TIMER_CTL);\n}\n\nstatic void sprd_timer_disable(void __iomem *base)\n{\n\tu32 val = readl_relaxed(base + TIMER_CTL);\n\n\tval &= ~TIMER_CTL_ENABLE;\n\twritel_relaxed(val, base + TIMER_CTL);\n}\n\nstatic void sprd_timer_update_counter(void __iomem *base, unsigned long cycles)\n{\n\twritel_relaxed(cycles & TIMER_VALUE_LO_MASK, base + TIMER_LOAD_LO);\n\twritel_relaxed(0, base + TIMER_LOAD_HI);\n}\n\nstatic void sprd_timer_enable_interrupt(void __iomem *base)\n{\n\twritel_relaxed(TIMER_INT_EN, base + TIMER_INT);\n}\n\nstatic void sprd_timer_clear_interrupt(void __iomem *base)\n{\n\tu32 val = readl_relaxed(base + TIMER_INT);\n\n\tval |= TIMER_INT_CLR;\n\twritel_relaxed(val, base + TIMER_INT);\n}\n\nstatic int sprd_timer_set_next_event(unsigned long cycles,\n\t\t\t\t     struct clock_event_device *ce)\n{\n\tstruct timer_of *to = to_timer_of(ce);\n\n\tsprd_timer_disable(timer_of_base(to));\n\tsprd_timer_update_counter(timer_of_base(to), cycles);\n\tsprd_timer_enable(timer_of_base(to), 0);\n\n\treturn 0;\n}\n\nstatic int sprd_timer_set_periodic(struct clock_event_device *ce)\n{\n\tstruct timer_of *to = to_timer_of(ce);\n\n\tsprd_timer_disable(timer_of_base(to));\n\tsprd_timer_update_counter(timer_of_base(to), timer_of_period(to));\n\tsprd_timer_enable(timer_of_base(to), TIMER_CTL_PERIOD_MODE);\n\n\treturn 0;\n}\n\nstatic int sprd_timer_shutdown(struct clock_event_device *ce)\n{\n\tstruct timer_of *to = to_timer_of(ce);\n\n\tsprd_timer_disable(timer_of_base(to));\n\treturn 0;\n}\n\nstatic irqreturn_t sprd_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *ce = (struct clock_event_device *)dev_id;\n\tstruct timer_of *to = to_timer_of(ce);\n\n\tsprd_timer_clear_interrupt(timer_of_base(to));\n\n\tif (clockevent_state_oneshot(ce))\n\t\tsprd_timer_disable(timer_of_base(to));\n\n\tce->event_handler(ce);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct timer_of to = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK,\n\n\t.clkevt = {\n\t\t.name = TIMER_NAME,\n\t\t.rating = 300,\n\t\t.features = CLOCK_EVT_FEAT_DYNIRQ | CLOCK_EVT_FEAT_PERIODIC |\n\t\t\tCLOCK_EVT_FEAT_ONESHOT,\n\t\t.set_state_shutdown = sprd_timer_shutdown,\n\t\t.set_state_periodic = sprd_timer_set_periodic,\n\t\t.set_next_event = sprd_timer_set_next_event,\n\t\t.cpumask = cpu_possible_mask,\n\t},\n\n\t.of_irq = {\n\t\t.handler = sprd_timer_interrupt,\n\t\t.flags = IRQF_TIMER | IRQF_IRQPOLL,\n\t},\n};\n\nstatic int __init sprd_timer_init(struct device_node *np)\n{\n\tint ret;\n\n\tret = timer_of_init(np, &to);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_timer_enable_interrupt(timer_of_base(&to));\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to),\n\t\t\t\t\t1, UINT_MAX);\n\n\treturn 0;\n}\n\nstatic struct timer_of suspend_to = {\n\t.flags = TIMER_OF_BASE | TIMER_OF_CLOCK,\n};\n\nstatic u64 sprd_suspend_timer_read(struct clocksource *cs)\n{\n\treturn ~(u64)readl_relaxed(timer_of_base(&suspend_to) +\n\t\t\t\t   TIMER_VALUE_SHDW_LO) & cs->mask;\n}\n\nstatic int sprd_suspend_timer_enable(struct clocksource *cs)\n{\n\tsprd_timer_update_counter(timer_of_base(&suspend_to),\n\t\t\t\t  TIMER_VALUE_LO_MASK);\n\tsprd_timer_enable(timer_of_base(&suspend_to), TIMER_CTL_PERIOD_MODE);\n\n\treturn 0;\n}\n\nstatic void sprd_suspend_timer_disable(struct clocksource *cs)\n{\n\tsprd_timer_disable(timer_of_base(&suspend_to));\n}\n\nstatic struct clocksource suspend_clocksource = {\n\t.name\t= \"sprd_suspend_timer\",\n\t.rating\t= 200,\n\t.read\t= sprd_suspend_timer_read,\n\t.enable = sprd_suspend_timer_enable,\n\t.disable = sprd_suspend_timer_disable,\n\t.mask\t= CLOCKSOURCE_MASK(32),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_SUSPEND_NONSTOP,\n};\n\nstatic int __init sprd_suspend_timer_init(struct device_node *np)\n{\n\tint ret;\n\n\tret = timer_of_init(np, &suspend_to);\n\tif (ret)\n\t\treturn ret;\n\n\tclocksource_register_hz(&suspend_clocksource,\n\t\t\t\ttimer_of_rate(&suspend_to));\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(sc9860_timer, \"sprd,sc9860-timer\", sprd_timer_init);\nTIMER_OF_DECLARE(sc9860_persistent_timer, \"sprd,sc9860-suspend-timer\",\n\t\t sprd_suspend_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}