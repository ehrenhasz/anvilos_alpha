{
  "module_name": "ingenic-timer.c",
  "hash_id": "8ec432eb016aa870c31e6350aff0883c56a9639c3cb3025930a8942222a5d77a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/ingenic-timer.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sched_clock.h>\n\n#include <dt-bindings/clock/ingenic,tcu.h>\n\nstatic DEFINE_PER_CPU(call_single_data_t, ingenic_cevt_csd);\n\nstruct ingenic_soc_info {\n\tunsigned int num_channels;\n};\n\nstruct ingenic_tcu_timer {\n\tunsigned int cpu;\n\tunsigned int channel;\n\tstruct clock_event_device cevt;\n\tstruct clk *clk;\n\tchar name[8];\n};\n\nstruct ingenic_tcu {\n\tstruct regmap *map;\n\tstruct device_node *np;\n\tstruct clk *cs_clk;\n\tunsigned int cs_channel;\n\tstruct clocksource cs;\n\tunsigned long pwm_channels_mask;\n\tstruct ingenic_tcu_timer timers[];\n};\n\nstatic struct ingenic_tcu *ingenic_tcu;\n\nstatic u64 notrace ingenic_tcu_timer_read(void)\n{\n\tstruct ingenic_tcu *tcu = ingenic_tcu;\n\tunsigned int count;\n\n\tregmap_read(tcu->map, TCU_REG_TCNTc(tcu->cs_channel), &count);\n\n\treturn count;\n}\n\nstatic u64 notrace ingenic_tcu_timer_cs_read(struct clocksource *cs)\n{\n\treturn ingenic_tcu_timer_read();\n}\n\nstatic inline struct ingenic_tcu *\nto_ingenic_tcu(struct ingenic_tcu_timer *timer)\n{\n\treturn container_of(timer, struct ingenic_tcu, timers[timer->cpu]);\n}\n\nstatic inline struct ingenic_tcu_timer *\nto_ingenic_tcu_timer(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct ingenic_tcu_timer, cevt);\n}\n\nstatic int ingenic_tcu_cevt_set_state_shutdown(struct clock_event_device *evt)\n{\n\tstruct ingenic_tcu_timer *timer = to_ingenic_tcu_timer(evt);\n\tstruct ingenic_tcu *tcu = to_ingenic_tcu(timer);\n\n\tregmap_write(tcu->map, TCU_REG_TECR, BIT(timer->channel));\n\n\treturn 0;\n}\n\nstatic int ingenic_tcu_cevt_set_next(unsigned long next,\n\t\t\t\t     struct clock_event_device *evt)\n{\n\tstruct ingenic_tcu_timer *timer = to_ingenic_tcu_timer(evt);\n\tstruct ingenic_tcu *tcu = to_ingenic_tcu(timer);\n\n\tif (next > 0xffff)\n\t\treturn -EINVAL;\n\n\tregmap_write(tcu->map, TCU_REG_TDFRc(timer->channel), next);\n\tregmap_write(tcu->map, TCU_REG_TCNTc(timer->channel), 0);\n\tregmap_write(tcu->map, TCU_REG_TESR, BIT(timer->channel));\n\n\treturn 0;\n}\n\nstatic void ingenic_per_cpu_event_handler(void *info)\n{\n\tstruct clock_event_device *cevt = (struct clock_event_device *) info;\n\n\tcevt->event_handler(cevt);\n}\n\nstatic irqreturn_t ingenic_tcu_cevt_cb(int irq, void *dev_id)\n{\n\tstruct ingenic_tcu_timer *timer = dev_id;\n\tstruct ingenic_tcu *tcu = to_ingenic_tcu(timer);\n\tcall_single_data_t *csd;\n\n\tregmap_write(tcu->map, TCU_REG_TECR, BIT(timer->channel));\n\n\tif (timer->cevt.event_handler) {\n\t\tcsd = &per_cpu(ingenic_cevt_csd, timer->cpu);\n\t\tcsd->info = (void *) &timer->cevt;\n\t\tcsd->func = ingenic_per_cpu_event_handler;\n\t\tsmp_call_function_single_async(timer->cpu, csd);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct clk *ingenic_tcu_get_clock(struct device_node *np, int id)\n{\n\tstruct of_phandle_args args;\n\n\targs.np = np;\n\targs.args_count = 1;\n\targs.args[0] = id;\n\n\treturn of_clk_get_from_provider(&args);\n}\n\nstatic int ingenic_tcu_setup_cevt(unsigned int cpu)\n{\n\tstruct ingenic_tcu *tcu = ingenic_tcu;\n\tstruct ingenic_tcu_timer *timer = &tcu->timers[cpu];\n\tunsigned int timer_virq;\n\tstruct irq_domain *domain;\n\tunsigned long rate;\n\tint err;\n\n\ttimer->clk = ingenic_tcu_get_clock(tcu->np, timer->channel);\n\tif (IS_ERR(timer->clk))\n\t\treturn PTR_ERR(timer->clk);\n\n\terr = clk_prepare_enable(timer->clk);\n\tif (err)\n\t\tgoto err_clk_put;\n\n\trate = clk_get_rate(timer->clk);\n\tif (!rate) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tdomain = irq_find_host(tcu->np);\n\tif (!domain) {\n\t\terr = -ENODEV;\n\t\tgoto err_clk_disable;\n\t}\n\n\ttimer_virq = irq_create_mapping(domain, timer->channel);\n\tif (!timer_virq) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tsnprintf(timer->name, sizeof(timer->name), \"TCU%u\", timer->channel);\n\n\terr = request_irq(timer_virq, ingenic_tcu_cevt_cb, IRQF_TIMER,\n\t\t\t  timer->name, timer);\n\tif (err)\n\t\tgoto err_irq_dispose_mapping;\n\n\ttimer->cpu = smp_processor_id();\n\ttimer->cevt.cpumask = cpumask_of(smp_processor_id());\n\ttimer->cevt.features = CLOCK_EVT_FEAT_ONESHOT;\n\ttimer->cevt.name = timer->name;\n\ttimer->cevt.rating = 200;\n\ttimer->cevt.set_state_shutdown = ingenic_tcu_cevt_set_state_shutdown;\n\ttimer->cevt.set_next_event = ingenic_tcu_cevt_set_next;\n\n\tclockevents_config_and_register(&timer->cevt, rate, 10, 0xffff);\n\n\treturn 0;\n\nerr_irq_dispose_mapping:\n\tirq_dispose_mapping(timer_virq);\nerr_clk_disable:\n\tclk_disable_unprepare(timer->clk);\nerr_clk_put:\n\tclk_put(timer->clk);\n\treturn err;\n}\n\nstatic int __init ingenic_tcu_clocksource_init(struct device_node *np,\n\t\t\t\t\t       struct ingenic_tcu *tcu)\n{\n\tunsigned int channel = tcu->cs_channel;\n\tstruct clocksource *cs = &tcu->cs;\n\tunsigned long rate;\n\tint err;\n\n\ttcu->cs_clk = ingenic_tcu_get_clock(np, channel);\n\tif (IS_ERR(tcu->cs_clk))\n\t\treturn PTR_ERR(tcu->cs_clk);\n\n\terr = clk_prepare_enable(tcu->cs_clk);\n\tif (err)\n\t\tgoto err_clk_put;\n\n\trate = clk_get_rate(tcu->cs_clk);\n\tif (!rate) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\tregmap_update_bits(tcu->map, TCU_REG_TCSRc(channel),\n\t\t\t   0xffff & ~TCU_TCSR_RESERVED_BITS, 0);\n\n\t \n\tregmap_write(tcu->map, TCU_REG_TDFRc(channel), 0xffff);\n\tregmap_write(tcu->map, TCU_REG_TCNTc(channel), 0);\n\n\t \n\tregmap_write(tcu->map, TCU_REG_TESR, BIT(channel));\n\n\tcs->name = \"ingenic-timer\";\n\tcs->rating = 200;\n\tcs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\tcs->mask = CLOCKSOURCE_MASK(16);\n\tcs->read = ingenic_tcu_timer_cs_read;\n\n\terr = clocksource_register_hz(cs, rate);\n\tif (err)\n\t\tgoto err_clk_disable;\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(tcu->cs_clk);\nerr_clk_put:\n\tclk_put(tcu->cs_clk);\n\treturn err;\n}\n\nstatic const struct ingenic_soc_info jz4740_soc_info = {\n\t.num_channels = 8,\n};\n\nstatic const struct ingenic_soc_info jz4725b_soc_info = {\n\t.num_channels = 6,\n};\n\nstatic const struct of_device_id ingenic_tcu_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-tcu\", .data = &jz4740_soc_info, },\n\t{ .compatible = \"ingenic,jz4725b-tcu\", .data = &jz4725b_soc_info, },\n\t{ .compatible = \"ingenic,jz4760-tcu\", .data = &jz4740_soc_info, },\n\t{ .compatible = \"ingenic,jz4770-tcu\", .data = &jz4740_soc_info, },\n\t{ .compatible = \"ingenic,x1000-tcu\", .data = &jz4740_soc_info, },\n\t{   }\n};\n\nstatic int __init ingenic_tcu_init(struct device_node *np)\n{\n\tconst struct of_device_id *id = of_match_node(ingenic_tcu_of_match, np);\n\tconst struct ingenic_soc_info *soc_info = id->data;\n\tstruct ingenic_tcu_timer *timer;\n\tstruct ingenic_tcu *tcu;\n\tstruct regmap *map;\n\tunsigned int cpu;\n\tint ret, last_bit = -1;\n\tlong rate;\n\n\tof_node_clear_flag(np, OF_POPULATED);\n\n\tmap = device_node_to_regmap(np);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\ttcu = kzalloc(struct_size(tcu, timers, num_possible_cpus()),\n\t\t      GFP_KERNEL);\n\tif (!tcu)\n\t\treturn -ENOMEM;\n\n\t \n\ttcu->pwm_channels_mask = GENMASK(soc_info->num_channels - 1,\n\t\t\t\t\t num_possible_cpus() + 1);\n\tof_property_read_u32(np, \"ingenic,pwm-channels-mask\",\n\t\t\t     (u32 *)&tcu->pwm_channels_mask);\n\n\t \n\tif (hweight8(tcu->pwm_channels_mask) >\n\t\t\tsoc_info->num_channels - num_possible_cpus() + 1) {\n\t\tpr_crit(\"%s: Invalid PWM channel mask: 0x%02lx\\n\", __func__,\n\t\t\ttcu->pwm_channels_mask);\n\t\tret = -EINVAL;\n\t\tgoto err_free_ingenic_tcu;\n\t}\n\n\ttcu->map = map;\n\ttcu->np = np;\n\tingenic_tcu = tcu;\n\n\tfor (cpu = 0; cpu < num_possible_cpus(); cpu++) {\n\t\ttimer = &tcu->timers[cpu];\n\n\t\ttimer->cpu = cpu;\n\t\ttimer->channel = find_next_zero_bit(&tcu->pwm_channels_mask,\n\t\t\t\t\t\t  soc_info->num_channels,\n\t\t\t\t\t\t  last_bit + 1);\n\t\tlast_bit = timer->channel;\n\t}\n\n\ttcu->cs_channel = find_next_zero_bit(&tcu->pwm_channels_mask,\n\t\t\t\t\t     soc_info->num_channels,\n\t\t\t\t\t     last_bit + 1);\n\n\tret = ingenic_tcu_clocksource_init(np, tcu);\n\tif (ret) {\n\t\tpr_crit(\"%s: Unable to init clocksource: %d\\n\", __func__, ret);\n\t\tgoto err_free_ingenic_tcu;\n\t}\n\n\t \n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"Ingenic XBurst: online\",\n\t\t\t\tingenic_tcu_setup_cevt, NULL);\n\tif (ret < 0) {\n\t\tpr_crit(\"%s: Unable to start CPU timers: %d\\n\", __func__, ret);\n\t\tgoto err_tcu_clocksource_cleanup;\n\t}\n\n\t \n\trate = clk_get_rate(tcu->cs_clk);\n\tsched_clock_register(ingenic_tcu_timer_read, 16, rate);\n\n\treturn 0;\n\nerr_tcu_clocksource_cleanup:\n\tclocksource_unregister(&tcu->cs);\n\tclk_disable_unprepare(tcu->cs_clk);\n\tclk_put(tcu->cs_clk);\nerr_free_ingenic_tcu:\n\tkfree(tcu);\n\treturn ret;\n}\n\nTIMER_OF_DECLARE(jz4740_tcu_intc,  \"ingenic,jz4740-tcu\",  ingenic_tcu_init);\nTIMER_OF_DECLARE(jz4725b_tcu_intc, \"ingenic,jz4725b-tcu\", ingenic_tcu_init);\nTIMER_OF_DECLARE(jz4760_tcu_intc,  \"ingenic,jz4760-tcu\",  ingenic_tcu_init);\nTIMER_OF_DECLARE(jz4770_tcu_intc,  \"ingenic,jz4770-tcu\",  ingenic_tcu_init);\nTIMER_OF_DECLARE(x1000_tcu_intc,  \"ingenic,x1000-tcu\",  ingenic_tcu_init);\n\nstatic int __init ingenic_tcu_probe(struct platform_device *pdev)\n{\n\tplatform_set_drvdata(pdev, ingenic_tcu);\n\n\treturn 0;\n}\n\nstatic int ingenic_tcu_suspend(struct device *dev)\n{\n\tstruct ingenic_tcu *tcu = dev_get_drvdata(dev);\n\tunsigned int cpu;\n\n\tclk_disable(tcu->cs_clk);\n\n\tfor (cpu = 0; cpu < num_online_cpus(); cpu++)\n\t\tclk_disable(tcu->timers[cpu].clk);\n\n\treturn 0;\n}\n\nstatic int ingenic_tcu_resume(struct device *dev)\n{\n\tstruct ingenic_tcu *tcu = dev_get_drvdata(dev);\n\tunsigned int cpu;\n\tint ret;\n\n\tfor (cpu = 0; cpu < num_online_cpus(); cpu++) {\n\t\tret = clk_enable(tcu->timers[cpu].clk);\n\t\tif (ret)\n\t\t\tgoto err_timer_clk_disable;\n\t}\n\n\tret = clk_enable(tcu->cs_clk);\n\tif (ret)\n\t\tgoto err_timer_clk_disable;\n\n\treturn 0;\n\nerr_timer_clk_disable:\n\tfor (; cpu > 0; cpu--)\n\t\tclk_disable(tcu->timers[cpu - 1].clk);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops ingenic_tcu_pm_ops = {\n\t \n\t.suspend_noirq = ingenic_tcu_suspend,\n\t.resume_noirq  = ingenic_tcu_resume,\n};\n\nstatic struct platform_driver ingenic_tcu_driver = {\n\t.driver = {\n\t\t.name\t= \"ingenic-tcu-timer\",\n\t\t.pm\t= pm_sleep_ptr(&ingenic_tcu_pm_ops),\n\t\t.of_match_table = ingenic_tcu_of_match,\n\t},\n};\nbuiltin_platform_driver_probe(ingenic_tcu_driver, ingenic_tcu_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}