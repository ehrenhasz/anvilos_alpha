{
  "module_name": "asm9260_timer.c",
  "hash_id": "7911f1856bb1868b05016efcf1196d6c564b72825d1a117518e303d660c43cf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/asm9260_timer.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/bitops.h>\n\n#define DRIVER_NAME\t\"asm9260-timer\"\n\n \n#define SET_REG 4\n#define CLR_REG 8\n\n#define HW_IR           0x0000  \n#define BM_IR_CR0\tBIT(4)\n#define BM_IR_MR3\tBIT(3)\n#define BM_IR_MR2\tBIT(2)\n#define BM_IR_MR1\tBIT(1)\n#define BM_IR_MR0\tBIT(0)\n\n#define HW_TCR\t\t0x0010  \n \n#define BM_C3_RST\tBIT(7)\n#define BM_C2_RST\tBIT(6)\n#define BM_C1_RST\tBIT(5)\n#define BM_C0_RST\tBIT(4)\n \n#define BM_C3_EN\tBIT(3)\n#define BM_C2_EN\tBIT(2)\n#define BM_C1_EN\tBIT(1)\n#define BM_C0_EN\tBIT(0)\n\n#define HW_DIR\t\t0x0020  \n \n#define BM_DIR_COUNT_UP\t\t0\n#define BM_DIR_COUNT_DOWN\t1\n#define BM_DIR0_SHIFT\t0\n#define BM_DIR1_SHIFT\t4\n#define BM_DIR2_SHIFT\t8\n#define BM_DIR3_SHIFT\t12\n#define BM_DIR_DEFAULT\t\t(BM_DIR_COUNT_UP << BM_DIR0_SHIFT | \\\n\t\t\t\t BM_DIR_COUNT_UP << BM_DIR1_SHIFT | \\\n\t\t\t\t BM_DIR_COUNT_UP << BM_DIR2_SHIFT | \\\n\t\t\t\t BM_DIR_COUNT_UP << BM_DIR3_SHIFT)\n\n#define HW_TC0\t\t0x0030  \n \n#define HW_TC1          0x0040\n#define HW_TC2\t\t0x0050\n#define HW_TC3\t\t0x0060\n\n#define HW_PR\t\t0x0070  \n#define BM_PR_DISABLE\t0\n#define HW_PC\t\t0x0080  \n#define HW_MCR\t\t0x0090  \n \n#define BM_MCR_INT_EN(n)\t(1 << (n * 3 + 0))\n \n#define BM_MCR_RES_EN(n)\t(1 << (n * 3 + 1))\n \n#define BM_MCR_STOP_EN(n)\t(1 << (n * 3 + 2))\n\n#define HW_MR0\t\t0x00a0  \n#define HW_MR1\t\t0x00b0\n#define HW_MR2\t\t0x00C0\n#define HW_MR3\t\t0x00D0\n\n#define HW_CTCR\t\t0x0180  \n#define BM_CTCR0_SHIFT\t0\n#define BM_CTCR1_SHIFT\t2\n#define BM_CTCR2_SHIFT\t4\n#define BM_CTCR3_SHIFT\t6\n#define BM_CTCR_TM\t0\t \n#define BM_CTCR_DEFAULT\t(BM_CTCR_TM << BM_CTCR0_SHIFT | \\\n\t\t\t BM_CTCR_TM << BM_CTCR1_SHIFT | \\\n\t\t\t BM_CTCR_TM << BM_CTCR2_SHIFT | \\\n\t\t\t BM_CTCR_TM << BM_CTCR3_SHIFT)\n\nstatic struct asm9260_timer_priv {\n\tvoid __iomem *base;\n\tunsigned long ticks_per_jiffy;\n} priv;\n\nstatic int asm9260_timer_set_next_event(unsigned long delta,\n\t\t\t\t\t struct clock_event_device *evt)\n{\n\t \n\twritel_relaxed(delta, priv.base + HW_MR0);\n\t \n\twritel_relaxed(BM_C0_EN, priv.base + HW_TCR + SET_REG);\n\treturn 0;\n}\n\nstatic inline void __asm9260_timer_shutdown(struct clock_event_device *evt)\n{\n\t \n\twritel_relaxed(BM_C0_EN, priv.base + HW_TCR + CLR_REG);\n}\n\nstatic int asm9260_timer_shutdown(struct clock_event_device *evt)\n{\n\t__asm9260_timer_shutdown(evt);\n\treturn 0;\n}\n\nstatic int asm9260_timer_set_oneshot(struct clock_event_device *evt)\n{\n\t__asm9260_timer_shutdown(evt);\n\n\t \n\twritel_relaxed(BM_MCR_RES_EN(0) | BM_MCR_STOP_EN(0),\n\t\t       priv.base + HW_MCR + SET_REG);\n\treturn 0;\n}\n\nstatic int asm9260_timer_set_periodic(struct clock_event_device *evt)\n{\n\t__asm9260_timer_shutdown(evt);\n\n\t \n\twritel_relaxed(BM_MCR_RES_EN(0) | BM_MCR_STOP_EN(0),\n\t\t       priv.base + HW_MCR + CLR_REG);\n\t \n\twritel_relaxed(priv.ticks_per_jiffy, priv.base + HW_MR0);\n\t \n\twritel_relaxed(BM_C0_EN, priv.base + HW_TCR + SET_REG);\n\treturn 0;\n}\n\nstatic struct clock_event_device event_dev = {\n\t.name\t\t\t= DRIVER_NAME,\n\t.rating\t\t\t= 200,\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.set_next_event\t\t= asm9260_timer_set_next_event,\n\t.set_state_shutdown\t= asm9260_timer_shutdown,\n\t.set_state_periodic\t= asm9260_timer_set_periodic,\n\t.set_state_oneshot\t= asm9260_timer_set_oneshot,\n\t.tick_resume\t\t= asm9260_timer_shutdown,\n};\n\nstatic irqreturn_t asm9260_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tevt->event_handler(evt);\n\n\twritel_relaxed(BM_IR_MR0, priv.base + HW_IR);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int __init asm9260_timer_init(struct device_node *np)\n{\n\tint irq;\n\tstruct clk *clk;\n\tint ret;\n\tunsigned long rate;\n\n\tpriv.base = of_io_request_and_map(np, 0, np->name);\n\tif (IS_ERR(priv.base)) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", np);\n\t\treturn PTR_ERR(priv.base);\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Failed to get clk!\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"Failed to enable clk!\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tret = request_irq(irq, asm9260_timer_interrupt, IRQF_TIMER,\n\t\t\tDRIVER_NAME, &event_dev);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup irq!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel_relaxed(BM_DIR_DEFAULT, priv.base + HW_DIR);\n\t \n\twritel_relaxed(BM_PR_DISABLE, priv.base + HW_PR);\n\t \n\twritel_relaxed(BM_CTCR_DEFAULT, priv.base + HW_CTCR);\n\t \n\twritel_relaxed(BM_MCR_INT_EN(0) , priv.base + HW_MCR);\n\n\trate = clk_get_rate(clk);\n\tclocksource_mmio_init(priv.base + HW_TC1, DRIVER_NAME, rate,\n\t\t\t200, 32, clocksource_mmio_readl_up);\n\n\t \n\twritel_relaxed(0xffffffff, priv.base + HW_MR1);\n\t \n\twritel_relaxed(BM_C1_EN, priv.base + HW_TCR + SET_REG);\n\n\tpriv.ticks_per_jiffy = DIV_ROUND_CLOSEST(rate, HZ);\n\tevent_dev.cpumask = cpumask_of(0);\n\tclockevents_config_and_register(&event_dev, rate, 0x2c00, 0xfffffffe);\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(asm9260_timer, \"alphascale,asm9260-timer\",\n\t\tasm9260_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}