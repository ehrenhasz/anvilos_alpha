{
  "module_name": "timer-stm32.c",
  "hash_id": "679d04bea528ea24df4a0ad06137f5cdb5322966c54f76eb42d907bc322d35d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-stm32.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n\n#include \"timer-of.h\"\n\n#define TIM_CR1\t\t0x00\n#define TIM_DIER\t0x0c\n#define TIM_SR\t\t0x10\n#define TIM_EGR\t\t0x14\n#define TIM_CNT\t\t0x24\n#define TIM_PSC\t\t0x28\n#define TIM_ARR\t\t0x2c\n#define TIM_CCR1\t0x34\n\n#define TIM_CR1_CEN\tBIT(0)\n#define TIM_CR1_UDIS\tBIT(1)\n#define TIM_CR1_OPM\tBIT(3)\n#define TIM_CR1_ARPE\tBIT(7)\n\n#define TIM_DIER_UIE\tBIT(0)\n#define TIM_DIER_CC1IE\tBIT(1)\n\n#define TIM_SR_UIF\tBIT(0)\n\n#define TIM_EGR_UG\tBIT(0)\n\n#define TIM_PSC_MAX\tUSHRT_MAX\n#define TIM_PSC_CLKRATE\t10000\n\nstruct stm32_timer_private {\n\tint bits;\n};\n\n \nstatic void stm32_timer_of_bits_set(struct timer_of *to, int bits)\n{\n\tstruct stm32_timer_private *pd = to->private_data;\n\n\tpd->bits = bits;\n}\n\n \nstatic int stm32_timer_of_bits_get(struct timer_of *to)\n{\n\tstruct stm32_timer_private *pd = to->private_data;\n\n\treturn pd->bits;\n}\n\nstatic void __iomem *stm32_timer_cnt __read_mostly;\n\nstatic u64 notrace stm32_read_sched_clock(void)\n{\n\treturn readl_relaxed(stm32_timer_cnt);\n}\n\nstatic struct delay_timer stm32_timer_delay;\n\nstatic unsigned long stm32_read_delay(void)\n{\n\treturn readl_relaxed(stm32_timer_cnt);\n}\n\nstatic void stm32_clock_event_disable(struct timer_of *to)\n{\n\twritel_relaxed(0, timer_of_base(to) + TIM_DIER);\n}\n\n \nstatic void stm32_timer_start(struct timer_of *to)\n{\n\twritel_relaxed(TIM_CR1_UDIS | TIM_CR1_CEN, timer_of_base(to) + TIM_CR1);\n}\n\nstatic int stm32_clock_event_shutdown(struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tstm32_clock_event_disable(to);\n\n\treturn 0;\n}\n\nstatic int stm32_clock_event_set_next_event(unsigned long evt,\n\t\t\t\t\t    struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\tunsigned long now, next;\n\n\tnext = readl_relaxed(timer_of_base(to) + TIM_CNT) + evt;\n\twritel_relaxed(next, timer_of_base(to) + TIM_CCR1);\n\tnow = readl_relaxed(timer_of_base(to) + TIM_CNT);\n\n\tif ((next - now) > evt)\n\t\treturn -ETIME;\n\n\twritel_relaxed(TIM_DIER_CC1IE, timer_of_base(to) + TIM_DIER);\n\n\treturn 0;\n}\n\nstatic int stm32_clock_event_set_periodic(struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tstm32_timer_start(to);\n\n\treturn stm32_clock_event_set_next_event(timer_of_period(to), clkevt);\n}\n\nstatic int stm32_clock_event_set_oneshot(struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tstm32_timer_start(to);\n\n\treturn 0;\n}\n\nstatic irqreturn_t stm32_clock_event_handler(int irq, void *dev_id)\n{\n\tstruct clock_event_device *clkevt = (struct clock_event_device *)dev_id;\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\twritel_relaxed(0, timer_of_base(to) + TIM_SR);\n\n\tif (clockevent_state_periodic(clkevt))\n\t\tstm32_clock_event_set_periodic(clkevt);\n\telse\n\t\tstm32_clock_event_shutdown(clkevt);\n\n\tclkevt->event_handler(clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void __init stm32_timer_set_width(struct timer_of *to)\n{\n\tu32 width;\n\n\twritel_relaxed(UINT_MAX, timer_of_base(to) + TIM_ARR);\n\n\twidth = readl_relaxed(timer_of_base(to) + TIM_ARR);\n\n\tstm32_timer_of_bits_set(to, width == UINT_MAX ? 32 : 16);\n}\n\n \nstatic void __init stm32_timer_set_prescaler(struct timer_of *to)\n{\n\tint prescaler = 1;\n\n\tif (stm32_timer_of_bits_get(to) != 32) {\n\t\tprescaler = DIV_ROUND_CLOSEST(timer_of_rate(to),\n\t\t\t\t\t      TIM_PSC_CLKRATE);\n\t\t \n\t\tprescaler = prescaler < TIM_PSC_MAX ? prescaler : TIM_PSC_MAX;\n\t}\n\n\twritel_relaxed(prescaler - 1, timer_of_base(to) + TIM_PSC);\n\twritel_relaxed(TIM_EGR_UG, timer_of_base(to) + TIM_EGR);\n\twritel_relaxed(0, timer_of_base(to) + TIM_SR);\n\n\t \n\tto->of_clk.rate = DIV_ROUND_CLOSEST(to->of_clk.rate, prescaler);\n\tto->of_clk.period = DIV_ROUND_UP(to->of_clk.rate, HZ);\n}\n\nstatic int __init stm32_clocksource_init(struct timer_of *to)\n{\n        u32 bits = stm32_timer_of_bits_get(to);\n\tconst char *name = to->np->full_name;\n\n\t \n\tif (bits == 32 && !stm32_timer_cnt) {\n\n\t\t \n\t\tstm32_timer_start(to);\n\n\t\tstm32_timer_cnt = timer_of_base(to) + TIM_CNT;\n\t\tsched_clock_register(stm32_read_sched_clock, bits, timer_of_rate(to));\n\t\tpr_info(\"%s: STM32 sched_clock registered\\n\", name);\n\n\t\tstm32_timer_delay.read_current_timer = stm32_read_delay;\n\t\tstm32_timer_delay.freq = timer_of_rate(to);\n\t\tregister_current_timer_delay(&stm32_timer_delay);\n\t\tpr_info(\"%s: STM32 delay timer registered\\n\", name);\n\t}\n\n\treturn clocksource_mmio_init(timer_of_base(to) + TIM_CNT, name,\n\t\t\t\t     timer_of_rate(to), bits == 32 ? 250 : 100,\n\t\t\t\t     bits, clocksource_mmio_readl_up);\n}\n\nstatic void __init stm32_clockevent_init(struct timer_of *to)\n{\n\tu32 bits = stm32_timer_of_bits_get(to);\n\n\tto->clkevt.name = to->np->full_name;\n\tto->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tto->clkevt.set_state_shutdown = stm32_clock_event_shutdown;\n\tto->clkevt.set_state_periodic = stm32_clock_event_set_periodic;\n\tto->clkevt.set_state_oneshot = stm32_clock_event_set_oneshot;\n\tto->clkevt.tick_resume = stm32_clock_event_shutdown;\n\tto->clkevt.set_next_event = stm32_clock_event_set_next_event;\n\tto->clkevt.rating = bits == 32 ? 250 : 100;\n\n\tclockevents_config_and_register(&to->clkevt, timer_of_rate(to), 0x1,\n\t\t\t\t\t(1 <<  bits) - 1);\n\n\tpr_info(\"%pOF: STM32 clockevent driver initialized (%d bits)\\n\",\n\t\tto->np, bits);\n}\n\nstatic int __init stm32_timer_init(struct device_node *node)\n{\n\tstruct reset_control *rstc;\n\tstruct timer_of *to;\n\tint ret;\n\n\tto = kzalloc(sizeof(*to), GFP_KERNEL);\n\tif (!to)\n\t\treturn -ENOMEM;\n\n\tto->flags = TIMER_OF_IRQ | TIMER_OF_CLOCK | TIMER_OF_BASE;\n\tto->of_irq.handler = stm32_clock_event_handler;\n\n\tret = timer_of_init(node, to);\n\tif (ret)\n\t\tgoto err;\n\n\tto->private_data = kzalloc(sizeof(struct stm32_timer_private),\n\t\t\t\t   GFP_KERNEL);\n\tif (!to->private_data) {\n\t\tret = -ENOMEM;\n\t\tgoto deinit;\n\t}\n\n\trstc = of_reset_control_get(node, NULL);\n\tif (!IS_ERR(rstc)) {\n\t\treset_control_assert(rstc);\n\t\treset_control_deassert(rstc);\n\t}\n\n\tstm32_timer_set_width(to);\n\n\tstm32_timer_set_prescaler(to);\n\n\tret = stm32_clocksource_init(to);\n\tif (ret)\n\t\tgoto deinit;\n\n\tstm32_clockevent_init(to);\n\treturn 0;\n\ndeinit:\n\ttimer_of_cleanup(to);\nerr:\n\tkfree(to);\n\treturn ret;\n}\n\nTIMER_OF_DECLARE(stm32, \"st,stm32-timer\", stm32_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}