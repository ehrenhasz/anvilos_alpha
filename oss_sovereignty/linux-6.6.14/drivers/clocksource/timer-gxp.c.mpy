{
  "module_name": "timer-gxp.c",
  "hash_id": "ea4d188f7ac3b368c8951e3910d9a10f1acfb29e3a19af3cf520414714b5c441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-gxp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched_clock.h>\n\n#define TIMER0_FREQ\t1000000\n#define GXP_TIMER_CNT_OFS 0x00\n#define GXP_TIMESTAMP_OFS 0x08\n#define GXP_TIMER_CTRL_OFS 0x14\n\n \n \n#define MASK_TCS_ENABLE\t0x01\n#define MASK_TCS_PERIOD\t0x02\n#define MASK_TCS_RELOAD\t0x04\n#define MASK_TCS_TC\t0x80\n\nstruct gxp_timer {\n\tvoid __iomem *counter;\n\tvoid __iomem *control;\n\tstruct clock_event_device evt;\n};\n\nstatic struct gxp_timer *gxp_timer;\n\nstatic void __iomem *system_clock __ro_after_init;\n\nstatic inline struct gxp_timer *to_gxp_timer(struct clock_event_device *evt_dev)\n{\n\treturn container_of(evt_dev, struct gxp_timer, evt);\n}\n\nstatic u64 notrace gxp_sched_read(void)\n{\n\treturn readl_relaxed(system_clock);\n}\n\nstatic int gxp_time_set_next_event(unsigned long event, struct clock_event_device *evt_dev)\n{\n\tstruct gxp_timer *timer = to_gxp_timer(evt_dev);\n\n\t \n\twriteb_relaxed(MASK_TCS_TC, timer->control);\n\twritel_relaxed(event, timer->counter);\n\twriteb_relaxed(MASK_TCS_TC | MASK_TCS_ENABLE, timer->control);\n\n\treturn 0;\n}\n\nstatic irqreturn_t gxp_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct gxp_timer *timer = (struct gxp_timer *)dev_id;\n\n\tif (!(readb_relaxed(timer->control) & MASK_TCS_TC))\n\t\treturn IRQ_NONE;\n\n\twriteb_relaxed(MASK_TCS_TC, timer->control);\n\n\ttimer->evt.event_handler(&timer->evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init gxp_timer_init(struct device_node *node)\n{\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tu32 freq;\n\tint ret, irq;\n\n\tgxp_timer = kzalloc(sizeof(*gxp_timer), GFP_KERNEL);\n\tif (!gxp_timer) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"Can't allocate gxp_timer\");\n\t\treturn ret;\n\t}\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tret = (int)PTR_ERR(clk);\n\t\tpr_err(\"%pOFn clock not found: %d\\n\", node, ret);\n\t\tgoto err_free;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"%pOFn clock enable failed: %d\\n\", node, ret);\n\t\tgoto err_clk_enable;\n\t}\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tret = -ENXIO;\n\t\tpr_err(\"Can't map timer base registers\");\n\t\tgoto err_iomap;\n\t}\n\n\t \n\tgxp_timer->counter = base + GXP_TIMER_CNT_OFS;\n\tgxp_timer->control = base + GXP_TIMER_CTRL_OFS;\n\tsystem_clock = base + GXP_TIMESTAMP_OFS;\n\n\tgxp_timer->evt.name = node->name;\n\tgxp_timer->evt.rating = 300;\n\tgxp_timer->evt.features = CLOCK_EVT_FEAT_ONESHOT;\n\tgxp_timer->evt.set_next_event = gxp_time_set_next_event;\n\tgxp_timer->evt.cpumask = cpumask_of(0);\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"GXP Timer Can't parse IRQ %d\", irq);\n\t\tgoto err_exit;\n\t}\n\n\tfreq = clk_get_rate(clk);\n\n\tret = clocksource_mmio_init(system_clock, node->name, freq,\n\t\t\t\t    300, 32, clocksource_mmio_readl_up);\n\tif (ret) {\n\t\tpr_err(\"%pOFn init clocksource failed: %d\", node, ret);\n\t\tgoto err_exit;\n\t}\n\n\tsched_clock_register(gxp_sched_read, 32, freq);\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"%pOFn Can't parse IRQ %d\", node, irq);\n\t\tgoto err_exit;\n\t}\n\n\tclockevents_config_and_register(&gxp_timer->evt, TIMER0_FREQ,\n\t\t\t\t\t0xf, 0xffffffff);\n\n\tret = request_irq(irq, gxp_timer_interrupt, IRQF_TIMER | IRQF_SHARED,\n\t\t\t  node->name, gxp_timer);\n\tif (ret) {\n\t\tpr_err(\"%pOFn request_irq() failed: %d\", node, ret);\n\t\tgoto err_exit;\n\t}\n\n\tpr_debug(\"gxp: system timer (irq = %d)\\n\", irq);\n\treturn 0;\n\nerr_exit:\n\tiounmap(base);\nerr_iomap:\n\tclk_disable_unprepare(clk);\nerr_clk_enable:\n\tclk_put(clk);\nerr_free:\n\tkfree(gxp_timer);\n\treturn ret;\n}\n\n \n\nstatic int gxp_timer_probe(struct platform_device *pdev)\n{\n\tstruct platform_device *gxp_watchdog_device;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (!gxp_timer) {\n\t\tpr_err(\"Gxp Timer not initialized, cannot create watchdog\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgxp_watchdog_device = platform_device_alloc(\"gxp-wdt\", -1);\n\tif (!gxp_watchdog_device) {\n\t\tpr_err(\"Timer failed to allocate gxp-wdt\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tgxp_watchdog_device->dev.platform_data = gxp_timer->counter;\n\tgxp_watchdog_device->dev.parent = dev;\n\n\tret = platform_device_add(gxp_watchdog_device);\n\tif (ret)\n\t\tplatform_device_put(gxp_watchdog_device);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id gxp_timer_of_match[] = {\n\t{ .compatible = \"hpe,gxp-timer\", },\n\t{},\n};\n\nstatic struct platform_driver gxp_timer_driver = {\n\t.probe  = gxp_timer_probe,\n\t.driver = {\n\t\t.name = \"gxp-timer\",\n\t\t.of_match_table = gxp_timer_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nbuiltin_platform_driver(gxp_timer_driver);\n\nTIMER_OF_DECLARE(gxp, \"hpe,gxp-timer\", gxp_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}