{
  "module_name": "renesas-ostm.c",
  "hash_id": "7ec7fde83a487204059ddfe3802391734067035db98088a9a2ee2f3d05929078",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/renesas-ostm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n\n#include \"timer-of.h\"\n\n \n\nstatic void __iomem *system_clock;\t \n\n \n#define\tOSTM_CMP\t\t0x000\t \n#define\tOSTM_CNT\t\t0x004\t \n#define\tOSTM_TE\t\t\t0x010\t \n#define\tOSTM_TS\t\t\t0x014\t \n#define\tOSTM_TT\t\t\t0x018\t \n#define\tOSTM_CTL\t\t0x020\t \n\n#define\tTE\t\t\t0x01\n#define\tTS\t\t\t0x01\n#define\tTT\t\t\t0x01\n#define\tCTL_PERIODIC\t\t0x00\n#define\tCTL_ONESHOT\t\t0x02\n#define\tCTL_FREERUN\t\t0x02\n\nstatic void ostm_timer_stop(struct timer_of *to)\n{\n\tif (readb(timer_of_base(to) + OSTM_TE) & TE) {\n\t\twriteb(TT, timer_of_base(to) + OSTM_TT);\n\n\t\t \n\t\twhile (readb(timer_of_base(to) + OSTM_TE) & TE)\n\t\t\t;\n\t}\n}\n\nstatic int __init ostm_init_clksrc(struct timer_of *to)\n{\n\tostm_timer_stop(to);\n\n\twritel(0, timer_of_base(to) + OSTM_CMP);\n\twriteb(CTL_FREERUN, timer_of_base(to) + OSTM_CTL);\n\twriteb(TS, timer_of_base(to) + OSTM_TS);\n\n\treturn clocksource_mmio_init(timer_of_base(to) + OSTM_CNT,\n\t\t\t\t     to->np->full_name, timer_of_rate(to), 300,\n\t\t\t\t     32, clocksource_mmio_readl_up);\n}\n\nstatic u64 notrace ostm_read_sched_clock(void)\n{\n\treturn readl(system_clock);\n}\n\nstatic void __init ostm_init_sched_clock(struct timer_of *to)\n{\n\tsystem_clock = timer_of_base(to) + OSTM_CNT;\n\tsched_clock_register(ostm_read_sched_clock, 32, timer_of_rate(to));\n}\n\nstatic int ostm_clock_event_next(unsigned long delta,\n\t\t\t\t struct clock_event_device *ced)\n{\n\tstruct timer_of *to = to_timer_of(ced);\n\n\tostm_timer_stop(to);\n\n\twritel(delta, timer_of_base(to) + OSTM_CMP);\n\twriteb(CTL_ONESHOT, timer_of_base(to) + OSTM_CTL);\n\twriteb(TS, timer_of_base(to) + OSTM_TS);\n\n\treturn 0;\n}\n\nstatic int ostm_shutdown(struct clock_event_device *ced)\n{\n\tstruct timer_of *to = to_timer_of(ced);\n\n\tostm_timer_stop(to);\n\n\treturn 0;\n}\nstatic int ostm_set_periodic(struct clock_event_device *ced)\n{\n\tstruct timer_of *to = to_timer_of(ced);\n\n\tif (clockevent_state_oneshot(ced) || clockevent_state_periodic(ced))\n\t\tostm_timer_stop(to);\n\n\twritel(timer_of_period(to) - 1, timer_of_base(to) + OSTM_CMP);\n\twriteb(CTL_PERIODIC, timer_of_base(to) + OSTM_CTL);\n\twriteb(TS, timer_of_base(to) + OSTM_TS);\n\n\treturn 0;\n}\n\nstatic int ostm_set_oneshot(struct clock_event_device *ced)\n{\n\tstruct timer_of *to = to_timer_of(ced);\n\n\tostm_timer_stop(to);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ostm_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *ced = dev_id;\n\n\tif (clockevent_state_oneshot(ced))\n\t\tostm_timer_stop(to_timer_of(ced));\n\n\t \n\tif (ced->event_handler)\n\t\tced->event_handler(ced);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init ostm_init_clkevt(struct timer_of *to)\n{\n\tstruct clock_event_device *ced = &to->clkevt;\n\n\tced->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC;\n\tced->set_state_shutdown = ostm_shutdown;\n\tced->set_state_periodic = ostm_set_periodic;\n\tced->set_state_oneshot = ostm_set_oneshot;\n\tced->set_next_event = ostm_clock_event_next;\n\tced->shift = 32;\n\tced->rating = 300;\n\tced->cpumask = cpumask_of(0);\n\tclockevents_config_and_register(ced, timer_of_rate(to), 0xf,\n\t\t\t\t\t0xffffffff);\n\n\treturn 0;\n}\n\nstatic int __init ostm_init(struct device_node *np)\n{\n\tstruct reset_control *rstc;\n\tstruct timer_of *to;\n\tint ret;\n\n\tto = kzalloc(sizeof(*to), GFP_KERNEL);\n\tif (!to)\n\t\treturn -ENOMEM;\n\n\trstc = of_reset_control_get_optional_exclusive(np, NULL);\n\tif (IS_ERR(rstc)) {\n\t\tret = PTR_ERR(rstc);\n\t\tgoto err_free;\n\t}\n\n\treset_control_deassert(rstc);\n\n\tto->flags = TIMER_OF_BASE | TIMER_OF_CLOCK;\n\tif (system_clock) {\n\t\t \n\t\tto->flags |= TIMER_OF_IRQ;\n\t\tto->of_irq.flags = IRQF_TIMER | IRQF_IRQPOLL;\n\t\tto->of_irq.handler = ostm_timer_interrupt;\n\t}\n\n\tret = timer_of_init(np, to);\n\tif (ret)\n\t\tgoto err_reset;\n\n\t \n\tif (!system_clock) {\n\t\tret = ostm_init_clksrc(to);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tostm_init_sched_clock(to);\n\t\tpr_info(\"%pOF: used for clocksource\\n\", np);\n\t} else {\n\t\tret = ostm_init_clkevt(to);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tpr_info(\"%pOF: used for clock events\\n\", np);\n\t}\n\n\treturn 0;\n\nerr_cleanup:\n\ttimer_of_cleanup(to);\nerr_reset:\n\treset_control_assert(rstc);\n\treset_control_put(rstc);\nerr_free:\n\tkfree(to);\n\treturn ret;\n}\n\nTIMER_OF_DECLARE(ostm, \"renesas,ostm\", ostm_init);\n\n#ifdef CONFIG_ARCH_RZG2L\nstatic int __init ostm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\treturn ostm_init(dev->of_node);\n}\n\nstatic const struct of_device_id ostm_of_table[] = {\n\t{ .compatible = \"renesas,ostm\", },\n\t{   }\n};\n\nstatic struct platform_driver ostm_device_driver = {\n\t.driver = {\n\t\t.name = \"renesas_ostm\",\n\t\t.of_match_table = of_match_ptr(ostm_of_table),\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver_probe(ostm_device_driver, ostm_probe);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}