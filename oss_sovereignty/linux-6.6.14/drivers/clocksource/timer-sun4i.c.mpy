{
  "module_name": "timer-sun4i.c",
  "hash_id": "efff6631909f0aa2351990efb841ef745172d6a38dd1e3561cd5d65a3623f61a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-sun4i.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqreturn.h>\n#include <linux/sched_clock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include \"timer-of.h\"\n\n#define TIMER_IRQ_EN_REG\t0x00\n#define TIMER_IRQ_EN(val)\t\tBIT(val)\n#define TIMER_IRQ_ST_REG\t0x04\n#define TIMER_IRQ_CLEAR(val)\t\tBIT(val)\n#define TIMER_CTL_REG(val)\t(0x10 * val + 0x10)\n#define TIMER_CTL_ENABLE\t\tBIT(0)\n#define TIMER_CTL_RELOAD\t\tBIT(1)\n#define TIMER_CTL_CLK_SRC(val)\t\t(((val) & 0x3) << 2)\n#define TIMER_CTL_CLK_SRC_OSC24M\t\t(1)\n#define TIMER_CTL_CLK_PRES(val)\t\t(((val) & 0x7) << 4)\n#define TIMER_CTL_ONESHOT\t\tBIT(7)\n#define TIMER_INTVAL_REG(val)\t(0x10 * (val) + 0x14)\n#define TIMER_CNTVAL_REG(val)\t(0x10 * (val) + 0x18)\n\n#define TIMER_SYNC_TICKS\t3\n\n \nstatic void sun4i_clkevt_sync(void __iomem *base)\n{\n\tu32 old = readl(base + TIMER_CNTVAL_REG(1));\n\n\twhile ((old - readl(base + TIMER_CNTVAL_REG(1))) < TIMER_SYNC_TICKS)\n\t\tcpu_relax();\n}\n\nstatic void sun4i_clkevt_time_stop(void __iomem *base, u8 timer)\n{\n\tu32 val = readl(base + TIMER_CTL_REG(timer));\n\twritel(val & ~TIMER_CTL_ENABLE, base + TIMER_CTL_REG(timer));\n\tsun4i_clkevt_sync(base);\n}\n\nstatic void sun4i_clkevt_time_setup(void __iomem *base, u8 timer,\n\t\t\t\t    unsigned long delay)\n{\n\twritel(delay, base + TIMER_INTVAL_REG(timer));\n}\n\nstatic void sun4i_clkevt_time_start(void __iomem *base, u8 timer,\n\t\t\t\t    bool periodic)\n{\n\tu32 val = readl(base + TIMER_CTL_REG(timer));\n\n\tif (periodic)\n\t\tval &= ~TIMER_CTL_ONESHOT;\n\telse\n\t\tval |= TIMER_CTL_ONESHOT;\n\n\twritel(val | TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\n\t       base + TIMER_CTL_REG(timer));\n}\n\nstatic int sun4i_clkevt_shutdown(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\n\tsun4i_clkevt_time_stop(timer_of_base(to), 0);\n\n\treturn 0;\n}\n\nstatic int sun4i_clkevt_set_oneshot(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\n\tsun4i_clkevt_time_stop(timer_of_base(to), 0);\n\tsun4i_clkevt_time_start(timer_of_base(to), 0, false);\n\n\treturn 0;\n}\n\nstatic int sun4i_clkevt_set_periodic(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\n\tsun4i_clkevt_time_stop(timer_of_base(to), 0);\n\tsun4i_clkevt_time_setup(timer_of_base(to), 0, timer_of_period(to));\n\tsun4i_clkevt_time_start(timer_of_base(to), 0, true);\n\n\treturn 0;\n}\n\nstatic int sun4i_clkevt_next_event(unsigned long evt,\n\t\t\t\t   struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tsun4i_clkevt_time_stop(timer_of_base(to), 0);\n\tsun4i_clkevt_time_setup(timer_of_base(to), 0, evt - TIMER_SYNC_TICKS);\n\tsun4i_clkevt_time_start(timer_of_base(to), 0, false);\n\n\treturn 0;\n}\n\nstatic void sun4i_timer_clear_interrupt(void __iomem *base)\n{\n\twritel(TIMER_IRQ_CLEAR(0), base + TIMER_IRQ_ST_REG);\n}\n\nstatic irqreturn_t sun4i_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\tstruct timer_of *to = to_timer_of(evt);\n\n\tsun4i_timer_clear_interrupt(timer_of_base(to));\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct timer_of to = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_CLOCK | TIMER_OF_BASE,\n\n\t.clkevt = {\n\t\t.name = \"sun4i_tick\",\n\t\t.rating = 350,\n\t\t.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\tCLOCK_EVT_FEAT_DYNIRQ,\n\t\t.set_state_shutdown = sun4i_clkevt_shutdown,\n\t\t.set_state_periodic = sun4i_clkevt_set_periodic,\n\t\t.set_state_oneshot = sun4i_clkevt_set_oneshot,\n\t\t.tick_resume = sun4i_clkevt_shutdown,\n\t\t.set_next_event = sun4i_clkevt_next_event,\n\t\t.cpumask = cpu_possible_mask,\n\t},\n\n\t.of_irq = {\n\t\t.handler = sun4i_timer_interrupt,\n\t\t.flags = IRQF_TIMER | IRQF_IRQPOLL,\n\t},\n};\n\nstatic u64 notrace sun4i_timer_sched_read(void)\n{\n\treturn ~readl(timer_of_base(&to) + TIMER_CNTVAL_REG(1));\n}\n\nstatic int __init sun4i_timer_init(struct device_node *node)\n{\n\tint ret;\n\tu32 val;\n\n\tret = timer_of_init(node, &to);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(~0, timer_of_base(&to) + TIMER_INTVAL_REG(1));\n\twritel(TIMER_CTL_ENABLE | TIMER_CTL_RELOAD |\n\t       TIMER_CTL_CLK_SRC(TIMER_CTL_CLK_SRC_OSC24M),\n\t       timer_of_base(&to) + TIMER_CTL_REG(1));\n\n\t \n\tif (of_machine_is_compatible(\"allwinner,sun4i-a10\") ||\n\t    of_machine_is_compatible(\"allwinner,sun5i-a13\") ||\n\t    of_machine_is_compatible(\"allwinner,sun5i-a10s\") ||\n\t    of_machine_is_compatible(\"allwinner,suniv-f1c100s\"))\n\t\tsched_clock_register(sun4i_timer_sched_read, 32,\n\t\t\t\t     timer_of_rate(&to));\n\n\tret = clocksource_mmio_init(timer_of_base(&to) + TIMER_CNTVAL_REG(1),\n\t\t\t\t    node->name, timer_of_rate(&to), 350, 32,\n\t\t\t\t    clocksource_mmio_readl_down);\n\tif (ret) {\n\t\tpr_err(\"Failed to register clocksource\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(TIMER_CTL_CLK_SRC(TIMER_CTL_CLK_SRC_OSC24M),\n\t       timer_of_base(&to) + TIMER_CTL_REG(0));\n\n\t \n\tsun4i_clkevt_time_stop(timer_of_base(&to), 0);\n\n\t \n\tsun4i_timer_clear_interrupt(timer_of_base(&to));\n\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to),\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\n\t \n\tval = readl(timer_of_base(&to) + TIMER_IRQ_EN_REG);\n\twritel(val | TIMER_IRQ_EN(0), timer_of_base(&to) + TIMER_IRQ_EN_REG);\n\n\treturn ret;\n}\nTIMER_OF_DECLARE(sun4i, \"allwinner,sun4i-a10-timer\",\n\t\t       sun4i_timer_init);\nTIMER_OF_DECLARE(sun8i_a23, \"allwinner,sun8i-a23-timer\",\n\t\t sun4i_timer_init);\nTIMER_OF_DECLARE(sun8i_v3s, \"allwinner,sun8i-v3s-timer\",\n\t\t sun4i_timer_init);\nTIMER_OF_DECLARE(suniv, \"allwinner,suniv-f1c100s-timer\",\n\t\t       sun4i_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}