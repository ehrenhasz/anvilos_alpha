{
  "module_name": "timer-digicolor.c",
  "hash_id": "417cfbb35e0c0c1e0374402589d857571a5fd2fb32b3ed70052758e07c4bdc8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-digicolor.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqreturn.h>\n#include <linux/sched/clock.h>\n#include <linux/sched_clock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\nenum {\n\tTIMER_A,\n\tTIMER_B,\n\tTIMER_C,\n\tTIMER_D,\n\tTIMER_E,\n\tTIMER_F,\n\tTIMER_G,\n\tTIMER_H,\n};\n\n#define CONTROL(t)\t((t)*8)\n#define COUNT(t)\t((t)*8 + 4)\n\n#define CONTROL_DISABLE\t\t0\n#define CONTROL_ENABLE\t\tBIT(0)\n#define CONTROL_MODE(m)\t\t((m) << 4)\n#define CONTROL_MODE_ONESHOT\tCONTROL_MODE(1)\n#define CONTROL_MODE_PERIODIC\tCONTROL_MODE(2)\n\nstruct digicolor_timer {\n\tstruct clock_event_device ce;\n\tvoid __iomem *base;\n\tu32 ticks_per_jiffy;\n\tint timer_id;  \n};\n\nstatic struct digicolor_timer *dc_timer(struct clock_event_device *ce)\n{\n\treturn container_of(ce, struct digicolor_timer, ce);\n}\n\nstatic inline void dc_timer_disable(struct clock_event_device *ce)\n{\n\tstruct digicolor_timer *dt = dc_timer(ce);\n\twriteb(CONTROL_DISABLE, dt->base + CONTROL(dt->timer_id));\n}\n\nstatic inline void dc_timer_enable(struct clock_event_device *ce, u32 mode)\n{\n\tstruct digicolor_timer *dt = dc_timer(ce);\n\twriteb(CONTROL_ENABLE | mode, dt->base + CONTROL(dt->timer_id));\n}\n\nstatic inline void dc_timer_set_count(struct clock_event_device *ce,\n\t\t\t\t      unsigned long count)\n{\n\tstruct digicolor_timer *dt = dc_timer(ce);\n\twritel(count, dt->base + COUNT(dt->timer_id));\n}\n\nstatic int digicolor_clkevt_shutdown(struct clock_event_device *ce)\n{\n\tdc_timer_disable(ce);\n\treturn 0;\n}\n\nstatic int digicolor_clkevt_set_oneshot(struct clock_event_device *ce)\n{\n\tdc_timer_disable(ce);\n\tdc_timer_enable(ce, CONTROL_MODE_ONESHOT);\n\treturn 0;\n}\n\nstatic int digicolor_clkevt_set_periodic(struct clock_event_device *ce)\n{\n\tstruct digicolor_timer *dt = dc_timer(ce);\n\n\tdc_timer_disable(ce);\n\tdc_timer_set_count(ce, dt->ticks_per_jiffy);\n\tdc_timer_enable(ce, CONTROL_MODE_PERIODIC);\n\treturn 0;\n}\n\nstatic int digicolor_clkevt_next_event(unsigned long evt,\n\t\t\t\t       struct clock_event_device *ce)\n{\n\tdc_timer_disable(ce);\n\tdc_timer_set_count(ce, evt);\n\tdc_timer_enable(ce, CONTROL_MODE_ONESHOT);\n\n\treturn 0;\n}\n\nstatic struct digicolor_timer dc_timer_dev = {\n\t.ce = {\n\t\t.name = \"digicolor_tick\",\n\t\t.rating = 340,\n\t\t.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,\n\t\t.set_state_shutdown = digicolor_clkevt_shutdown,\n\t\t.set_state_periodic = digicolor_clkevt_set_periodic,\n\t\t.set_state_oneshot = digicolor_clkevt_set_oneshot,\n\t\t.tick_resume = digicolor_clkevt_shutdown,\n\t\t.set_next_event = digicolor_clkevt_next_event,\n\t},\n\t.timer_id = TIMER_C,\n};\n\nstatic irqreturn_t digicolor_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 notrace digicolor_timer_sched_read(void)\n{\n\treturn ~readl(dc_timer_dev.base + COUNT(TIMER_B));\n}\n\nstatic int __init digicolor_timer_init(struct device_node *node)\n{\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret, irq;\n\n\t \n\tdc_timer_dev.base = of_iomap(node, 0);\n\tif (!dc_timer_dev.base) {\n\t\tpr_err(\"Can't map registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tirq = irq_of_parse_and_map(node, dc_timer_dev.timer_id);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't parse IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Can't get timer clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\tclk_prepare_enable(clk);\n\trate = clk_get_rate(clk);\n\tdc_timer_dev.ticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\n\n\twriteb(CONTROL_DISABLE, dc_timer_dev.base + CONTROL(TIMER_B));\n\twritel(UINT_MAX, dc_timer_dev.base + COUNT(TIMER_B));\n\twriteb(CONTROL_ENABLE, dc_timer_dev.base + CONTROL(TIMER_B));\n\n\tsched_clock_register(digicolor_timer_sched_read, 32, rate);\n\tclocksource_mmio_init(dc_timer_dev.base + COUNT(TIMER_B), node->name,\n\t\t\t      rate, 340, 32, clocksource_mmio_readl_down);\n\n\tret = request_irq(irq, digicolor_timer_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL, \"digicolor_timerC\",\n\t\t\t  &dc_timer_dev.ce);\n\tif (ret) {\n\t\tpr_warn(\"request of timer irq %d failed (%d)\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tdc_timer_dev.ce.cpumask = cpu_possible_mask;\n\tdc_timer_dev.ce.irq = irq;\n\n\tclockevents_config_and_register(&dc_timer_dev.ce, rate, 0, 0xffffffff);\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(conexant_digicolor, \"cnxt,cx92755-timer\",\n\t\t       digicolor_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}