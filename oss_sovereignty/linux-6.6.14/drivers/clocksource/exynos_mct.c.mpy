{
  "module_name": "exynos_mct.c",
  "hash_id": "89e556f500630156423149df30cd88aba5ac18cc3aa7cea10780bd9f2724fbe7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/exynos_mct.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/percpu.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/clocksource.h>\n#include <linux/sched_clock.h>\n\n#define EXYNOS4_MCTREG(x)\t\t(x)\n#define EXYNOS4_MCT_G_CNT_L\t\tEXYNOS4_MCTREG(0x100)\n#define EXYNOS4_MCT_G_CNT_U\t\tEXYNOS4_MCTREG(0x104)\n#define EXYNOS4_MCT_G_CNT_WSTAT\t\tEXYNOS4_MCTREG(0x110)\n#define EXYNOS4_MCT_G_COMP0_L\t\tEXYNOS4_MCTREG(0x200)\n#define EXYNOS4_MCT_G_COMP0_U\t\tEXYNOS4_MCTREG(0x204)\n#define EXYNOS4_MCT_G_COMP0_ADD_INCR\tEXYNOS4_MCTREG(0x208)\n#define EXYNOS4_MCT_G_TCON\t\tEXYNOS4_MCTREG(0x240)\n#define EXYNOS4_MCT_G_INT_CSTAT\t\tEXYNOS4_MCTREG(0x244)\n#define EXYNOS4_MCT_G_INT_ENB\t\tEXYNOS4_MCTREG(0x248)\n#define EXYNOS4_MCT_G_WSTAT\t\tEXYNOS4_MCTREG(0x24C)\n#define _EXYNOS4_MCT_L_BASE\t\tEXYNOS4_MCTREG(0x300)\n#define EXYNOS4_MCT_L_BASE(x)\t\t(_EXYNOS4_MCT_L_BASE + (0x100 * (x)))\n#define EXYNOS4_MCT_L_MASK\t\t(0xffffff00)\n\n#define MCT_L_TCNTB_OFFSET\t\t(0x00)\n#define MCT_L_ICNTB_OFFSET\t\t(0x08)\n#define MCT_L_TCON_OFFSET\t\t(0x20)\n#define MCT_L_INT_CSTAT_OFFSET\t\t(0x30)\n#define MCT_L_INT_ENB_OFFSET\t\t(0x34)\n#define MCT_L_WSTAT_OFFSET\t\t(0x40)\n#define MCT_G_TCON_START\t\t(1 << 8)\n#define MCT_G_TCON_COMP0_AUTO_INC\t(1 << 1)\n#define MCT_G_TCON_COMP0_ENABLE\t\t(1 << 0)\n#define MCT_L_TCON_INTERVAL_MODE\t(1 << 2)\n#define MCT_L_TCON_INT_START\t\t(1 << 1)\n#define MCT_L_TCON_TIMER_START\t\t(1 << 0)\n\n#define TICK_BASE_CNT\t1\n\n#ifdef CONFIG_ARM\n \n#define MCT_CLKSOURCE_RATING\t\t450\n#define MCT_CLKEVENTS_RATING\t\t500\n#else\n#define MCT_CLKSOURCE_RATING\t\t350\n#define MCT_CLKEVENTS_RATING\t\t350\n#endif\n\n \n#define MCT_G0_IRQ\t0\n \n#define MCT_L0_IRQ\t4\n \n#define MCT_NR_IRQS\t20\n \n#define MCT_NR_LOCAL\t(MCT_NR_IRQS - MCT_L0_IRQ)\n\nenum {\n\tMCT_INT_SPI,\n\tMCT_INT_PPI\n};\n\nstatic void __iomem *reg_base;\nstatic unsigned long clk_rate;\nstatic unsigned int mct_int_type;\nstatic int mct_irqs[MCT_NR_IRQS];\n\nstruct mct_clock_event_device {\n\tstruct clock_event_device evt;\n\tunsigned long base;\n\t \n\tchar name[11];\n};\n\nstatic void exynos4_mct_write(unsigned int value, unsigned long offset)\n{\n\tunsigned long stat_addr;\n\tu32 mask;\n\tu32 i;\n\n\twritel_relaxed(value, reg_base + offset);\n\n\tif (likely(offset >= EXYNOS4_MCT_L_BASE(0))) {\n\t\tstat_addr = (offset & EXYNOS4_MCT_L_MASK) + MCT_L_WSTAT_OFFSET;\n\t\tswitch (offset & ~EXYNOS4_MCT_L_MASK) {\n\t\tcase MCT_L_TCON_OFFSET:\n\t\t\tmask = 1 << 3;\t\t \n\t\t\tbreak;\n\t\tcase MCT_L_ICNTB_OFFSET:\n\t\t\tmask = 1 << 1;\t\t \n\t\t\tbreak;\n\t\tcase MCT_L_TCNTB_OFFSET:\n\t\t\tmask = 1 << 0;\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (offset) {\n\t\tcase EXYNOS4_MCT_G_TCON:\n\t\t\tstat_addr = EXYNOS4_MCT_G_WSTAT;\n\t\t\tmask = 1 << 16;\t\t \n\t\t\tbreak;\n\t\tcase EXYNOS4_MCT_G_COMP0_L:\n\t\t\tstat_addr = EXYNOS4_MCT_G_WSTAT;\n\t\t\tmask = 1 << 0;\t\t \n\t\t\tbreak;\n\t\tcase EXYNOS4_MCT_G_COMP0_U:\n\t\t\tstat_addr = EXYNOS4_MCT_G_WSTAT;\n\t\t\tmask = 1 << 1;\t\t \n\t\t\tbreak;\n\t\tcase EXYNOS4_MCT_G_COMP0_ADD_INCR:\n\t\t\tstat_addr = EXYNOS4_MCT_G_WSTAT;\n\t\t\tmask = 1 << 2;\t\t \n\t\t\tbreak;\n\t\tcase EXYNOS4_MCT_G_CNT_L:\n\t\t\tstat_addr = EXYNOS4_MCT_G_CNT_WSTAT;\n\t\t\tmask = 1 << 0;\t\t \n\t\t\tbreak;\n\t\tcase EXYNOS4_MCT_G_CNT_U:\n\t\t\tstat_addr = EXYNOS4_MCT_G_CNT_WSTAT;\n\t\t\tmask = 1 << 1;\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < loops_per_jiffy / 1000 * HZ; i++)\n\t\tif (readl_relaxed(reg_base + stat_addr) & mask) {\n\t\t\twritel_relaxed(mask, reg_base + stat_addr);\n\t\t\treturn;\n\t\t}\n\n\tpanic(\"MCT hangs after writing %d (offset:0x%lx)\\n\", value, offset);\n}\n\n \nstatic void exynos4_mct_frc_start(void)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(reg_base + EXYNOS4_MCT_G_TCON);\n\treg |= MCT_G_TCON_START;\n\texynos4_mct_write(reg, EXYNOS4_MCT_G_TCON);\n}\n\n \nstatic u64 exynos4_read_count_64(void)\n{\n\tunsigned int lo, hi;\n\tu32 hi2 = readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_U);\n\n\tdo {\n\t\thi = hi2;\n\t\tlo = readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_L);\n\t\thi2 = readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_U);\n\t} while (hi != hi2);\n\n\treturn ((u64)hi << 32) | lo;\n}\n\n \nstatic u32 notrace exynos4_read_count_32(void)\n{\n\treturn readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_L);\n}\n\nstatic u64 exynos4_frc_read(struct clocksource *cs)\n{\n\treturn exynos4_read_count_32();\n}\n\nstatic void exynos4_frc_resume(struct clocksource *cs)\n{\n\texynos4_mct_frc_start();\n}\n\nstatic struct clocksource mct_frc = {\n\t.name\t\t= \"mct-frc\",\n\t.rating\t\t= MCT_CLKSOURCE_RATING,\n\t.read\t\t= exynos4_frc_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.resume\t\t= exynos4_frc_resume,\n};\n\nstatic u64 notrace exynos4_read_sched_clock(void)\n{\n\treturn exynos4_read_count_32();\n}\n\n#if defined(CONFIG_ARM)\nstatic struct delay_timer exynos4_delay_timer;\n\nstatic cycles_t exynos4_read_current_timer(void)\n{\n\tBUILD_BUG_ON_MSG(sizeof(cycles_t) != sizeof(u32),\n\t\t\t \"cycles_t needs to move to 32-bit for ARM64 usage\");\n\treturn exynos4_read_count_32();\n}\n#endif\n\nstatic int __init exynos4_clocksource_init(bool frc_shared)\n{\n\t \n\tif (frc_shared)\n\t\tmct_frc.resume = NULL;\n\telse\n\t\texynos4_mct_frc_start();\n\n#if defined(CONFIG_ARM)\n\texynos4_delay_timer.read_current_timer = &exynos4_read_current_timer;\n\texynos4_delay_timer.freq = clk_rate;\n\tregister_current_timer_delay(&exynos4_delay_timer);\n#endif\n\n\tif (clocksource_register_hz(&mct_frc, clk_rate))\n\t\tpanic(\"%s: can't register clocksource\\n\", mct_frc.name);\n\n\tsched_clock_register(exynos4_read_sched_clock, 32, clk_rate);\n\n\treturn 0;\n}\n\nstatic void exynos4_mct_comp0_stop(void)\n{\n\tunsigned int tcon;\n\n\ttcon = readl_relaxed(reg_base + EXYNOS4_MCT_G_TCON);\n\ttcon &= ~(MCT_G_TCON_COMP0_ENABLE | MCT_G_TCON_COMP0_AUTO_INC);\n\n\texynos4_mct_write(tcon, EXYNOS4_MCT_G_TCON);\n\texynos4_mct_write(0, EXYNOS4_MCT_G_INT_ENB);\n}\n\nstatic void exynos4_mct_comp0_start(bool periodic, unsigned long cycles)\n{\n\tunsigned int tcon;\n\tu64 comp_cycle;\n\n\ttcon = readl_relaxed(reg_base + EXYNOS4_MCT_G_TCON);\n\n\tif (periodic) {\n\t\ttcon |= MCT_G_TCON_COMP0_AUTO_INC;\n\t\texynos4_mct_write(cycles, EXYNOS4_MCT_G_COMP0_ADD_INCR);\n\t}\n\n\tcomp_cycle = exynos4_read_count_64() + cycles;\n\texynos4_mct_write((u32)comp_cycle, EXYNOS4_MCT_G_COMP0_L);\n\texynos4_mct_write((u32)(comp_cycle >> 32), EXYNOS4_MCT_G_COMP0_U);\n\n\texynos4_mct_write(0x1, EXYNOS4_MCT_G_INT_ENB);\n\n\ttcon |= MCT_G_TCON_COMP0_ENABLE;\n\texynos4_mct_write(tcon , EXYNOS4_MCT_G_TCON);\n}\n\nstatic int exynos4_comp_set_next_event(unsigned long cycles,\n\t\t\t\t       struct clock_event_device *evt)\n{\n\texynos4_mct_comp0_start(false, cycles);\n\n\treturn 0;\n}\n\nstatic int mct_set_state_shutdown(struct clock_event_device *evt)\n{\n\texynos4_mct_comp0_stop();\n\treturn 0;\n}\n\nstatic int mct_set_state_periodic(struct clock_event_device *evt)\n{\n\tunsigned long cycles_per_jiffy;\n\n\tcycles_per_jiffy = (((unsigned long long)NSEC_PER_SEC / HZ * evt->mult)\n\t\t\t    >> evt->shift);\n\texynos4_mct_comp0_stop();\n\texynos4_mct_comp0_start(true, cycles_per_jiffy);\n\treturn 0;\n}\n\nstatic struct clock_event_device mct_comp_device = {\n\t.name\t\t\t= \"mct-comp\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 250,\n\t.set_next_event\t\t= exynos4_comp_set_next_event,\n\t.set_state_periodic\t= mct_set_state_periodic,\n\t.set_state_shutdown\t= mct_set_state_shutdown,\n\t.set_state_oneshot\t= mct_set_state_shutdown,\n\t.set_state_oneshot_stopped = mct_set_state_shutdown,\n\t.tick_resume\t\t= mct_set_state_shutdown,\n};\n\nstatic irqreturn_t exynos4_mct_comp_isr(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\texynos4_mct_write(0x1, EXYNOS4_MCT_G_INT_CSTAT);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int exynos4_clockevent_init(void)\n{\n\tmct_comp_device.cpumask = cpumask_of(0);\n\tclockevents_config_and_register(&mct_comp_device, clk_rate,\n\t\t\t\t\t0xf, 0xffffffff);\n\tif (request_irq(mct_irqs[MCT_G0_IRQ], exynos4_mct_comp_isr,\n\t\t\tIRQF_TIMER | IRQF_IRQPOLL, \"mct_comp_irq\",\n\t\t\t&mct_comp_device))\n\t\tpr_err(\"%s: request_irq() failed\\n\", \"mct_comp_irq\");\n\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(struct mct_clock_event_device, percpu_mct_tick);\n\n \nstatic void exynos4_mct_tick_stop(struct mct_clock_event_device *mevt)\n{\n\tunsigned long tmp;\n\tunsigned long mask = MCT_L_TCON_INT_START | MCT_L_TCON_TIMER_START;\n\tunsigned long offset = mevt->base + MCT_L_TCON_OFFSET;\n\n\ttmp = readl_relaxed(reg_base + offset);\n\tif (tmp & mask) {\n\t\ttmp &= ~mask;\n\t\texynos4_mct_write(tmp, offset);\n\t}\n}\n\nstatic void exynos4_mct_tick_start(unsigned long cycles,\n\t\t\t\t   struct mct_clock_event_device *mevt)\n{\n\tunsigned long tmp;\n\n\texynos4_mct_tick_stop(mevt);\n\n\ttmp = (1 << 31) | cycles;\t \n\n\t \n\texynos4_mct_write(tmp, mevt->base + MCT_L_ICNTB_OFFSET);\n\n\t \n\texynos4_mct_write(0x1, mevt->base + MCT_L_INT_ENB_OFFSET);\n\n\ttmp = readl_relaxed(reg_base + mevt->base + MCT_L_TCON_OFFSET);\n\ttmp |= MCT_L_TCON_INT_START | MCT_L_TCON_TIMER_START |\n\t       MCT_L_TCON_INTERVAL_MODE;\n\texynos4_mct_write(tmp, mevt->base + MCT_L_TCON_OFFSET);\n}\n\nstatic void exynos4_mct_tick_clear(struct mct_clock_event_device *mevt)\n{\n\t \n\tif (readl_relaxed(reg_base + mevt->base + MCT_L_INT_CSTAT_OFFSET) & 1)\n\t\texynos4_mct_write(0x1, mevt->base + MCT_L_INT_CSTAT_OFFSET);\n}\n\nstatic int exynos4_tick_set_next_event(unsigned long cycles,\n\t\t\t\t       struct clock_event_device *evt)\n{\n\tstruct mct_clock_event_device *mevt;\n\n\tmevt = container_of(evt, struct mct_clock_event_device, evt);\n\texynos4_mct_tick_start(cycles, mevt);\n\treturn 0;\n}\n\nstatic int set_state_shutdown(struct clock_event_device *evt)\n{\n\tstruct mct_clock_event_device *mevt;\n\n\tmevt = container_of(evt, struct mct_clock_event_device, evt);\n\texynos4_mct_tick_stop(mevt);\n\texynos4_mct_tick_clear(mevt);\n\treturn 0;\n}\n\nstatic int set_state_periodic(struct clock_event_device *evt)\n{\n\tstruct mct_clock_event_device *mevt;\n\tunsigned long cycles_per_jiffy;\n\n\tmevt = container_of(evt, struct mct_clock_event_device, evt);\n\tcycles_per_jiffy = (((unsigned long long)NSEC_PER_SEC / HZ * evt->mult)\n\t\t\t    >> evt->shift);\n\texynos4_mct_tick_stop(mevt);\n\texynos4_mct_tick_start(cycles_per_jiffy, mevt);\n\treturn 0;\n}\n\nstatic irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)\n{\n\tstruct mct_clock_event_device *mevt = dev_id;\n\tstruct clock_event_device *evt = &mevt->evt;\n\n\t \n\tif (!clockevent_state_periodic(&mevt->evt))\n\t\texynos4_mct_tick_stop(mevt);\n\n\texynos4_mct_tick_clear(mevt);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int exynos4_mct_starting_cpu(unsigned int cpu)\n{\n\tstruct mct_clock_event_device *mevt =\n\t\tper_cpu_ptr(&percpu_mct_tick, cpu);\n\tstruct clock_event_device *evt = &mevt->evt;\n\n\tsnprintf(mevt->name, sizeof(mevt->name), \"mct_tick%d\", cpu);\n\n\tevt->name = mevt->name;\n\tevt->cpumask = cpumask_of(cpu);\n\tevt->set_next_event = exynos4_tick_set_next_event;\n\tevt->set_state_periodic = set_state_periodic;\n\tevt->set_state_shutdown = set_state_shutdown;\n\tevt->set_state_oneshot = set_state_shutdown;\n\tevt->set_state_oneshot_stopped = set_state_shutdown;\n\tevt->tick_resume = set_state_shutdown;\n\tevt->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\n\t\t\tCLOCK_EVT_FEAT_PERCPU;\n\tevt->rating = MCT_CLKEVENTS_RATING;\n\n\texynos4_mct_write(TICK_BASE_CNT, mevt->base + MCT_L_TCNTB_OFFSET);\n\n\tif (mct_int_type == MCT_INT_SPI) {\n\n\t\tif (evt->irq == -1)\n\t\t\treturn -EIO;\n\n\t\tirq_force_affinity(evt->irq, cpumask_of(cpu));\n\t\tenable_irq(evt->irq);\n\t} else {\n\t\tenable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);\n\t}\n\tclockevents_config_and_register(evt, clk_rate / (TICK_BASE_CNT + 1),\n\t\t\t\t\t0xf, 0x7fffffff);\n\n\treturn 0;\n}\n\nstatic int exynos4_mct_dying_cpu(unsigned int cpu)\n{\n\tstruct mct_clock_event_device *mevt =\n\t\tper_cpu_ptr(&percpu_mct_tick, cpu);\n\tstruct clock_event_device *evt = &mevt->evt;\n\n\tevt->set_state_shutdown(evt);\n\tif (mct_int_type == MCT_INT_SPI) {\n\t\tif (evt->irq != -1)\n\t\t\tdisable_irq_nosync(evt->irq);\n\t\texynos4_mct_write(0x1, mevt->base + MCT_L_INT_CSTAT_OFFSET);\n\t} else {\n\t\tdisable_percpu_irq(mct_irqs[MCT_L0_IRQ]);\n\t}\n\treturn 0;\n}\n\nstatic int __init exynos4_timer_resources(struct device_node *np)\n{\n\tstruct clk *mct_clk, *tick_clk;\n\n\treg_base = of_iomap(np, 0);\n\tif (!reg_base)\n\t\tpanic(\"%s: unable to ioremap mct address space\\n\", __func__);\n\n\ttick_clk = of_clk_get_by_name(np, \"fin_pll\");\n\tif (IS_ERR(tick_clk))\n\t\tpanic(\"%s: unable to determine tick clock rate\\n\", __func__);\n\tclk_rate = clk_get_rate(tick_clk);\n\n\tmct_clk = of_clk_get_by_name(np, \"mct\");\n\tif (IS_ERR(mct_clk))\n\t\tpanic(\"%s: unable to retrieve mct clock instance\\n\", __func__);\n\tclk_prepare_enable(mct_clk);\n\n\treturn 0;\n}\n\n \nstatic int __init exynos4_timer_interrupts(struct device_node *np,\n\t\t\t\t\t   unsigned int int_type,\n\t\t\t\t\t   const u32 *local_idx,\n\t\t\t\t\t   size_t nr_local)\n{\n\tint nr_irqs, i, err, cpu;\n\n\tmct_int_type = int_type;\n\n\t \n\tmct_irqs[MCT_G0_IRQ] = irq_of_parse_and_map(np, MCT_G0_IRQ);\n\n\t \n\tnr_irqs = of_irq_count(np);\n\tif (nr_irqs > ARRAY_SIZE(mct_irqs)) {\n\t\tpr_err(\"exynos-mct: too many (%d) interrupts configured in DT\\n\",\n\t\t\tnr_irqs);\n\t\tnr_irqs = ARRAY_SIZE(mct_irqs);\n\t}\n\tfor (i = MCT_L0_IRQ; i < nr_irqs; i++)\n\t\tmct_irqs[i] = irq_of_parse_and_map(np, i);\n\n\tif (mct_int_type == MCT_INT_PPI) {\n\n\t\terr = request_percpu_irq(mct_irqs[MCT_L0_IRQ],\n\t\t\t\t\t exynos4_mct_tick_isr, \"MCT\",\n\t\t\t\t\t &percpu_mct_tick);\n\t\tWARN(err, \"MCT: can't request IRQ %d (%d)\\n\",\n\t\t     mct_irqs[MCT_L0_IRQ], err);\n\t} else {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tint mct_irq;\n\t\t\tunsigned int irq_idx;\n\t\t\tstruct mct_clock_event_device *pcpu_mevt =\n\t\t\t\tper_cpu_ptr(&percpu_mct_tick, cpu);\n\n\t\t\tif (cpu >= nr_local) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_irq;\n\t\t\t}\n\n\t\t\tirq_idx = MCT_L0_IRQ + local_idx[cpu];\n\n\t\t\tpcpu_mevt->evt.irq = -1;\n\t\t\tif (irq_idx >= ARRAY_SIZE(mct_irqs))\n\t\t\t\tbreak;\n\t\t\tmct_irq = mct_irqs[irq_idx];\n\n\t\t\tirq_set_status_flags(mct_irq, IRQ_NOAUTOEN);\n\t\t\tif (request_irq(mct_irq,\n\t\t\t\t\texynos4_mct_tick_isr,\n\t\t\t\t\tIRQF_TIMER | IRQF_NOBALANCING,\n\t\t\t\t\tpcpu_mevt->name, pcpu_mevt)) {\n\t\t\t\tpr_err(\"exynos-mct: cannot register IRQ (cpu%d)\\n\",\n\t\t\t\t\t\t\t\t\tcpu);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpcpu_mevt->evt.irq = mct_irq;\n\t\t}\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct mct_clock_event_device *mevt = per_cpu_ptr(&percpu_mct_tick, cpu);\n\n\t\tif (cpu >= nr_local) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_irq;\n\t\t}\n\n\t\tmevt->base = EXYNOS4_MCT_L_BASE(local_idx[cpu]);\n\t}\n\n\t \n\terr = cpuhp_setup_state(CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING,\n\t\t\t\t\"clockevents/exynos4/mct_timer:starting\",\n\t\t\t\texynos4_mct_starting_cpu,\n\t\t\t\texynos4_mct_dying_cpu);\n\tif (err)\n\t\tgoto out_irq;\n\n\treturn 0;\n\nout_irq:\n\tif (mct_int_type == MCT_INT_PPI) {\n\t\tfree_percpu_irq(mct_irqs[MCT_L0_IRQ], &percpu_mct_tick);\n\t} else {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct mct_clock_event_device *pcpu_mevt =\n\t\t\t\tper_cpu_ptr(&percpu_mct_tick, cpu);\n\n\t\t\tif (pcpu_mevt->evt.irq != -1) {\n\t\t\t\tfree_irq(pcpu_mevt->evt.irq, pcpu_mevt);\n\t\t\t\tpcpu_mevt->evt.irq = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int __init mct_init_dt(struct device_node *np, unsigned int int_type)\n{\n\tbool frc_shared = of_property_read_bool(np, \"samsung,frc-shared\");\n\tu32 local_idx[MCT_NR_LOCAL] = {0};\n\tint nr_local;\n\tint ret;\n\n\tnr_local = of_property_count_u32_elems(np, \"samsung,local-timers\");\n\tif (nr_local == 0)\n\t\treturn -EINVAL;\n\tif (nr_local > 0) {\n\t\tif (nr_local > ARRAY_SIZE(local_idx))\n\t\t\treturn -EINVAL;\n\n\t\tret = of_property_read_u32_array(np, \"samsung,local-timers\",\n\t\t\t\t\t\t local_idx, nr_local);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tint i;\n\n\t\tnr_local = ARRAY_SIZE(local_idx);\n\t\tfor (i = 0; i < nr_local; i++)\n\t\t\tlocal_idx[i] = i;\n\t}\n\n\tret = exynos4_timer_resources(np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos4_timer_interrupts(np, int_type, local_idx, nr_local);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos4_clocksource_init(frc_shared);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (frc_shared)\n\t\treturn 0;\n\n\treturn exynos4_clockevent_init();\n}\n\n\nstatic int __init mct_init_spi(struct device_node *np)\n{\n\treturn mct_init_dt(np, MCT_INT_SPI);\n}\n\nstatic int __init mct_init_ppi(struct device_node *np)\n{\n\treturn mct_init_dt(np, MCT_INT_PPI);\n}\nTIMER_OF_DECLARE(exynos4210, \"samsung,exynos4210-mct\", mct_init_spi);\nTIMER_OF_DECLARE(exynos4412, \"samsung,exynos4412-mct\", mct_init_ppi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}