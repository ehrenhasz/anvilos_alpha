{
  "module_name": "timer-gx6605s.c",
  "hash_id": "627059ca9131c4c31320ee76faf140330076760bd559336a04c80ac6763288c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-gx6605s.c",
  "human_readable_source": "\n\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/sched_clock.h>\n\n#include \"timer-of.h\"\n\n#define CLKSRC_OFFSET\t0x40\n\n#define TIMER_STATUS\t0x00\n#define TIMER_VALUE\t0x04\n#define TIMER_CONTRL\t0x10\n#define TIMER_CONFIG\t0x20\n#define TIMER_DIV\t0x24\n#define TIMER_INI\t0x28\n\n#define GX6605S_STATUS_CLR\tBIT(0)\n#define GX6605S_CONTRL_RST\tBIT(0)\n#define GX6605S_CONTRL_START\tBIT(1)\n#define GX6605S_CONFIG_EN\tBIT(0)\n#define GX6605S_CONFIG_IRQ_EN\tBIT(1)\n\nstatic irqreturn_t gx6605s_timer_interrupt(int irq, void *dev)\n{\n\tstruct clock_event_device *ce = dev;\n\tvoid __iomem *base = timer_of_base(to_timer_of(ce));\n\n\twritel_relaxed(GX6605S_STATUS_CLR, base + TIMER_STATUS);\n\twritel_relaxed(0, base + TIMER_INI);\n\n\tce->event_handler(ce);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gx6605s_timer_set_oneshot(struct clock_event_device *ce)\n{\n\tvoid __iomem *base = timer_of_base(to_timer_of(ce));\n\n\t \n\twritel_relaxed(GX6605S_CONTRL_RST, base + TIMER_CONTRL);\n\n\t \n\twritel_relaxed(GX6605S_CONFIG_EN | GX6605S_CONFIG_IRQ_EN,\n\t\t       base + TIMER_CONFIG);\n\n\treturn 0;\n}\n\nstatic int gx6605s_timer_set_next_event(unsigned long delta,\n\t\t\t\t\tstruct clock_event_device *ce)\n{\n\tvoid __iomem *base = timer_of_base(to_timer_of(ce));\n\n\t \n\twritel_relaxed(GX6605S_CONTRL_RST, base + TIMER_CONTRL);\n\n\t \n\twritel_relaxed(ULONG_MAX - delta, base + TIMER_INI);\n\twritel_relaxed(GX6605S_CONTRL_START, base + TIMER_CONTRL);\n\n\treturn 0;\n}\n\nstatic int gx6605s_timer_shutdown(struct clock_event_device *ce)\n{\n\tvoid __iomem *base = timer_of_base(to_timer_of(ce));\n\n\twritel_relaxed(0, base + TIMER_CONTRL);\n\twritel_relaxed(0, base + TIMER_CONFIG);\n\n\treturn 0;\n}\n\nstatic struct timer_of to = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK,\n\t.clkevt = {\n\t\t.rating\t\t\t= 300,\n\t\t.features\t\t= CLOCK_EVT_FEAT_DYNIRQ |\n\t\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t\t.set_state_shutdown\t= gx6605s_timer_shutdown,\n\t\t.set_state_oneshot\t= gx6605s_timer_set_oneshot,\n\t\t.set_next_event\t\t= gx6605s_timer_set_next_event,\n\t\t.cpumask\t\t= cpu_possible_mask,\n\t},\n\t.of_irq = {\n\t\t.handler\t\t= gx6605s_timer_interrupt,\n\t\t.flags\t\t\t= IRQF_TIMER | IRQF_IRQPOLL,\n\t},\n};\n\nstatic u64 notrace gx6605s_sched_clock_read(void)\n{\n\tvoid __iomem *base;\n\n\tbase = timer_of_base(&to) + CLKSRC_OFFSET;\n\n\treturn (u64)readl_relaxed(base + TIMER_VALUE);\n}\n\nstatic void gx6605s_clkevt_init(void __iomem *base)\n{\n\twritel_relaxed(0, base + TIMER_DIV);\n\twritel_relaxed(0, base + TIMER_CONFIG);\n\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to), 2,\n\t\t\t\t\tULONG_MAX);\n}\n\nstatic int gx6605s_clksrc_init(void __iomem *base)\n{\n\twritel_relaxed(0, base + TIMER_DIV);\n\twritel_relaxed(0, base + TIMER_INI);\n\n\twritel_relaxed(GX6605S_CONTRL_RST, base + TIMER_CONTRL);\n\n\twritel_relaxed(GX6605S_CONFIG_EN, base + TIMER_CONFIG);\n\n\twritel_relaxed(GX6605S_CONTRL_START, base + TIMER_CONTRL);\n\n\tsched_clock_register(gx6605s_sched_clock_read, 32, timer_of_rate(&to));\n\n\treturn clocksource_mmio_init(base + TIMER_VALUE, \"gx6605s\",\n\t\t\ttimer_of_rate(&to), 200, 32, clocksource_mmio_readl_up);\n}\n\nstatic int __init gx6605s_timer_init(struct device_node *np)\n{\n\tint ret;\n\n\t \n\tret = timer_of_init(np, &to);\n\tif (ret)\n\t\treturn ret;\n\n\tgx6605s_clkevt_init(timer_of_base(&to));\n\n\treturn gx6605s_clksrc_init(timer_of_base(&to) + CLKSRC_OFFSET);\n}\nTIMER_OF_DECLARE(csky_gx6605s_timer, \"csky,gx6605s-timer\", gx6605s_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}