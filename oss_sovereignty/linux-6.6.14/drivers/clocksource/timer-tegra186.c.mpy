{
  "module_name": "timer-tegra186.c",
  "hash_id": "491d9370f249db4082550db7d75a965f4c6de45be38d1e9acd59012f53180680",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-tegra186.c",
  "human_readable_source": "\n \n\n#include <linux/clocksource.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/watchdog.h>\n\n \n#define TKETSC0 0x000\n#define TKETSC1 0x004\n#define TKEUSEC 0x008\n#define TKEOSC  0x00c\n\n#define TKEIE(x) (0x100 + ((x) * 4))\n#define  TKEIE_WDT_MASK(x, y) ((y) << (16 + 4 * (x)))\n\n \n#define TMRCR 0x000\n#define  TMRCR_ENABLE BIT(31)\n#define  TMRCR_PERIODIC BIT(30)\n#define  TMRCR_PTV(x) ((x) & 0x0fffffff)\n\n#define TMRSR 0x004\n#define  TMRSR_INTR_CLR BIT(30)\n\n#define TMRCSSR 0x008\n#define  TMRCSSR_SRC_USEC (0 << 0)\n\n \n#define WDTCR 0x000\n#define  WDTCR_SYSTEM_POR_RESET_ENABLE BIT(16)\n#define  WDTCR_SYSTEM_DEBUG_RESET_ENABLE BIT(15)\n#define  WDTCR_REMOTE_INT_ENABLE BIT(14)\n#define  WDTCR_LOCAL_FIQ_ENABLE BIT(13)\n#define  WDTCR_LOCAL_INT_ENABLE BIT(12)\n#define  WDTCR_PERIOD_MASK (0xff << 4)\n#define  WDTCR_PERIOD(x) (((x) & 0xff) << 4)\n#define  WDTCR_TIMER_SOURCE_MASK 0xf\n#define  WDTCR_TIMER_SOURCE(x) ((x) & 0xf)\n\n#define WDTCMDR 0x008\n#define  WDTCMDR_DISABLE_COUNTER BIT(1)\n#define  WDTCMDR_START_COUNTER BIT(0)\n\n#define WDTUR 0x00c\n#define  WDTUR_UNLOCK_PATTERN 0x0000c45a\n\nstruct tegra186_timer_soc {\n\tunsigned int num_timers;\n\tunsigned int num_wdts;\n};\n\nstruct tegra186_tmr {\n\tstruct tegra186_timer *parent;\n\tvoid __iomem *regs;\n\tunsigned int index;\n\tunsigned int hwirq;\n};\n\nstruct tegra186_wdt {\n\tstruct watchdog_device base;\n\n\tvoid __iomem *regs;\n\tunsigned int index;\n\tbool locked;\n\n\tstruct tegra186_tmr *tmr;\n};\n\nstatic inline struct tegra186_wdt *to_tegra186_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct tegra186_wdt, base);\n}\n\nstruct tegra186_timer {\n\tconst struct tegra186_timer_soc *soc;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\n\tstruct tegra186_wdt *wdt;\n\tstruct clocksource usec;\n\tstruct clocksource tsc;\n\tstruct clocksource osc;\n};\n\nstatic void tmr_writel(struct tegra186_tmr *tmr, u32 value, unsigned int offset)\n{\n\twritel_relaxed(value, tmr->regs + offset);\n}\n\nstatic void wdt_writel(struct tegra186_wdt *wdt, u32 value, unsigned int offset)\n{\n\twritel_relaxed(value, wdt->regs + offset);\n}\n\nstatic u32 wdt_readl(struct tegra186_wdt *wdt, unsigned int offset)\n{\n\treturn readl_relaxed(wdt->regs + offset);\n}\n\nstatic struct tegra186_tmr *tegra186_tmr_create(struct tegra186_timer *tegra,\n\t\t\t\t\t\tunsigned int index)\n{\n\tunsigned int offset = 0x10000 + index * 0x10000;\n\tstruct tegra186_tmr *tmr;\n\n\ttmr = devm_kzalloc(tegra->dev, sizeof(*tmr), GFP_KERNEL);\n\tif (!tmr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttmr->parent = tegra;\n\ttmr->regs = tegra->regs + offset;\n\ttmr->index = index;\n\ttmr->hwirq = 0;\n\n\treturn tmr;\n}\n\nstatic const struct watchdog_info tegra186_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"NVIDIA Tegra186 WDT\",\n};\n\nstatic void tegra186_wdt_disable(struct tegra186_wdt *wdt)\n{\n\t \n\twdt_writel(wdt, WDTUR_UNLOCK_PATTERN, WDTUR);\n\twdt_writel(wdt, WDTCMDR_DISABLE_COUNTER, WDTCMDR);\n\n\t \n\ttmr_writel(wdt->tmr, 0, TMRCR);\n}\n\nstatic void tegra186_wdt_enable(struct tegra186_wdt *wdt)\n{\n\tstruct tegra186_timer *tegra = wdt->tmr->parent;\n\tu32 value;\n\n\t \n\tvalue = TKEIE_WDT_MASK(wdt->index, 1);\n\twritel(value, tegra->regs + TKEIE(wdt->tmr->hwirq));\n\n\t \n\ttmr_writel(wdt->tmr, TMRSR_INTR_CLR, TMRSR);\n\n\t \n\ttmr_writel(wdt->tmr, TMRCSSR_SRC_USEC, TMRCSSR);\n\n\t \n\tvalue = TMRCR_PTV(wdt->base.timeout * USEC_PER_SEC / 5) |\n\t\tTMRCR_PERIODIC | TMRCR_ENABLE;\n\ttmr_writel(wdt->tmr, value, TMRCR);\n\n\tif (!wdt->locked) {\n\t\tvalue = wdt_readl(wdt, WDTCR);\n\n\t\t \n\t\tvalue &= ~WDTCR_TIMER_SOURCE_MASK;\n\t\tvalue |= WDTCR_TIMER_SOURCE(wdt->tmr->index);\n\n\t\t \n\t\tvalue &= ~WDTCR_PERIOD_MASK;\n\t\tvalue |= WDTCR_PERIOD(1);\n\n\t\t \n\t\tvalue |= WDTCR_LOCAL_INT_ENABLE;\n\n\t\t \n\t\tif (0)\n\t\t\tvalue |= WDTCR_REMOTE_INT_ENABLE |\n\t\t\t\t WDTCR_LOCAL_FIQ_ENABLE;\n\n\t\t \n\t\tif (0)\n\t\t\tvalue |= WDTCR_SYSTEM_DEBUG_RESET_ENABLE;\n\n\t\t \n\t\tvalue |= WDTCR_SYSTEM_POR_RESET_ENABLE;\n\n\t\twdt_writel(wdt, value, WDTCR);\n\t}\n\n\twdt_writel(wdt, WDTCMDR_START_COUNTER, WDTCMDR);\n}\n\nstatic int tegra186_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct tegra186_wdt *wdt = to_tegra186_wdt(wdd);\n\n\ttegra186_wdt_enable(wdt);\n\n\treturn 0;\n}\n\nstatic int tegra186_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct tegra186_wdt *wdt = to_tegra186_wdt(wdd);\n\n\ttegra186_wdt_disable(wdt);\n\n\treturn 0;\n}\n\nstatic int tegra186_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct tegra186_wdt *wdt = to_tegra186_wdt(wdd);\n\n\ttegra186_wdt_disable(wdt);\n\ttegra186_wdt_enable(wdt);\n\n\treturn 0;\n}\n\nstatic int tegra186_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t    unsigned int timeout)\n{\n\tstruct tegra186_wdt *wdt = to_tegra186_wdt(wdd);\n\n\tif (watchdog_active(&wdt->base))\n\t\ttegra186_wdt_disable(wdt);\n\n\twdt->base.timeout = timeout;\n\n\tif (watchdog_active(&wdt->base))\n\t\ttegra186_wdt_enable(wdt);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops tegra186_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = tegra186_wdt_start,\n\t.stop = tegra186_wdt_stop,\n\t.ping = tegra186_wdt_ping,\n\t.set_timeout = tegra186_wdt_set_timeout,\n};\n\nstatic struct tegra186_wdt *tegra186_wdt_create(struct tegra186_timer *tegra,\n\t\t\t\t\t\tunsigned int index)\n{\n\tunsigned int offset = 0x10000, source;\n\tstruct tegra186_wdt *wdt;\n\tu32 value;\n\tint err;\n\n\toffset += tegra->soc->num_timers * 0x10000 + index * 0x10000;\n\n\twdt = devm_kzalloc(tegra->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twdt->regs = tegra->regs + offset;\n\twdt->index = index;\n\n\t \n\tvalue = wdt_readl(wdt, WDTCR);\n\n\tif (value & WDTCR_LOCAL_INT_ENABLE)\n\t\twdt->locked = true;\n\n\tsource = value & WDTCR_TIMER_SOURCE_MASK;\n\n\twdt->tmr = tegra186_tmr_create(tegra, source);\n\tif (IS_ERR(wdt->tmr))\n\t\treturn ERR_CAST(wdt->tmr);\n\n\twdt->base.info = &tegra186_wdt_info;\n\twdt->base.ops = &tegra186_wdt_ops;\n\twdt->base.min_timeout = 1;\n\twdt->base.max_timeout = 255;\n\twdt->base.parent = tegra->dev;\n\n\terr = watchdog_init_timeout(&wdt->base, 5, tegra->dev);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to initialize timeout: %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = devm_watchdog_register_device(tegra->dev, &wdt->base);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to register WDT: %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn wdt;\n}\n\nstatic u64 tegra186_timer_tsc_read(struct clocksource *cs)\n{\n\tstruct tegra186_timer *tegra = container_of(cs, struct tegra186_timer,\n\t\t\t\t\t\t    tsc);\n\tu32 hi, lo, ss;\n\n\thi = readl_relaxed(tegra->regs + TKETSC1);\n\n\t \n\tdo {\n\t\t \n\t\tss = hi;\n\n\t\tlo = readl_relaxed(tegra->regs + TKETSC0);\n\t\thi = readl_relaxed(tegra->regs + TKETSC1);\n\t} while (hi != ss);\n\n\treturn (u64)hi << 32 | lo;\n}\n\nstatic int tegra186_timer_tsc_init(struct tegra186_timer *tegra)\n{\n\ttegra->tsc.name = \"tsc\";\n\ttegra->tsc.rating = 300;\n\ttegra->tsc.read = tegra186_timer_tsc_read;\n\ttegra->tsc.mask = CLOCKSOURCE_MASK(56);\n\ttegra->tsc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\treturn clocksource_register_hz(&tegra->tsc, 31250000);\n}\n\nstatic u64 tegra186_timer_osc_read(struct clocksource *cs)\n{\n\tstruct tegra186_timer *tegra = container_of(cs, struct tegra186_timer,\n\t\t\t\t\t\t    osc);\n\n\treturn readl_relaxed(tegra->regs + TKEOSC);\n}\n\nstatic int tegra186_timer_osc_init(struct tegra186_timer *tegra)\n{\n\ttegra->osc.name = \"osc\";\n\ttegra->osc.rating = 300;\n\ttegra->osc.read = tegra186_timer_osc_read;\n\ttegra->osc.mask = CLOCKSOURCE_MASK(32);\n\ttegra->osc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\treturn clocksource_register_hz(&tegra->osc, 38400000);\n}\n\nstatic u64 tegra186_timer_usec_read(struct clocksource *cs)\n{\n\tstruct tegra186_timer *tegra = container_of(cs, struct tegra186_timer,\n\t\t\t\t\t\t    usec);\n\n\treturn readl_relaxed(tegra->regs + TKEUSEC);\n}\n\nstatic int tegra186_timer_usec_init(struct tegra186_timer *tegra)\n{\n\ttegra->usec.name = \"usec\";\n\ttegra->usec.rating = 300;\n\ttegra->usec.read = tegra186_timer_usec_read;\n\ttegra->usec.mask = CLOCKSOURCE_MASK(32);\n\ttegra->usec.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\treturn clocksource_register_hz(&tegra->usec, USEC_PER_SEC);\n}\n\nstatic irqreturn_t tegra186_timer_irq(int irq, void *data)\n{\n\tstruct tegra186_timer *tegra = data;\n\n\tif (watchdog_active(&tegra->wdt->base)) {\n\t\ttegra186_wdt_disable(tegra->wdt);\n\t\ttegra186_wdt_enable(tegra->wdt);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra186_timer_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra186_timer *tegra;\n\tunsigned int irq;\n\tint err;\n\n\ttegra = devm_kzalloc(dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\ttegra->soc = of_device_get_match_data(dev);\n\tdev_set_drvdata(dev, tegra);\n\ttegra->dev = dev;\n\n\ttegra->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tegra->regs))\n\t\treturn PTR_ERR(tegra->regs);\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tirq = err;\n\n\t \n\ttegra->wdt = tegra186_wdt_create(tegra, 0);\n\tif (IS_ERR(tegra->wdt)) {\n\t\terr = PTR_ERR(tegra->wdt);\n\t\tdev_err(dev, \"failed to create WDT: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra186_timer_tsc_init(tegra);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register TSC counter: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra186_timer_osc_init(tegra);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register OSC counter: %d\\n\", err);\n\t\tgoto unregister_tsc;\n\t}\n\n\terr = tegra186_timer_usec_init(tegra);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to register USEC counter: %d\\n\", err);\n\t\tgoto unregister_osc;\n\t}\n\n\terr = devm_request_irq(dev, irq, tegra186_timer_irq, 0,\n\t\t\t       \"tegra186-timer\", tegra);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to request IRQ#%u: %d\\n\", irq, err);\n\t\tgoto unregister_usec;\n\t}\n\n\treturn 0;\n\nunregister_usec:\n\tclocksource_unregister(&tegra->usec);\nunregister_osc:\n\tclocksource_unregister(&tegra->osc);\nunregister_tsc:\n\tclocksource_unregister(&tegra->tsc);\n\treturn err;\n}\n\nstatic void tegra186_timer_remove(struct platform_device *pdev)\n{\n\tstruct tegra186_timer *tegra = platform_get_drvdata(pdev);\n\n\tclocksource_unregister(&tegra->usec);\n\tclocksource_unregister(&tegra->osc);\n\tclocksource_unregister(&tegra->tsc);\n}\n\nstatic int __maybe_unused tegra186_timer_suspend(struct device *dev)\n{\n\tstruct tegra186_timer *tegra = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&tegra->wdt->base))\n\t\ttegra186_wdt_disable(tegra->wdt);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra186_timer_resume(struct device *dev)\n{\n\tstruct tegra186_timer *tegra = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&tegra->wdt->base))\n\t\ttegra186_wdt_enable(tegra->wdt);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tegra186_timer_pm_ops, tegra186_timer_suspend,\n\t\t\t tegra186_timer_resume);\n\nstatic const struct tegra186_timer_soc tegra186_timer = {\n\t.num_timers = 10,\n\t.num_wdts = 3,\n};\n\nstatic const struct tegra186_timer_soc tegra234_timer = {\n\t.num_timers = 16,\n\t.num_wdts = 3,\n};\n\nstatic const struct of_device_id tegra186_timer_of_match[] = {\n\t{ .compatible = \"nvidia,tegra186-timer\", .data = &tegra186_timer },\n\t{ .compatible = \"nvidia,tegra234-timer\", .data = &tegra234_timer },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra186_timer_of_match);\n\nstatic struct platform_driver tegra186_wdt_driver = {\n\t.driver = {\n\t\t.name = \"tegra186-timer\",\n\t\t.pm = &tegra186_timer_pm_ops,\n\t\t.of_match_table = tegra186_timer_of_match,\n\t},\n\t.probe = tegra186_timer_probe,\n\t.remove_new = tegra186_timer_remove,\n};\nmodule_platform_driver(tegra186_wdt_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra186 timers driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}