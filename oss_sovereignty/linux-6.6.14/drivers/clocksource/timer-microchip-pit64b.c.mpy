{
  "module_name": "timer-microchip-pit64b.c",
  "hash_id": "dea388f637b0a75a621cade2c31bc3cffdcf6891a9684787b6fe36485825d319",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-microchip-pit64b.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n\n#define MCHP_PIT64B_CR\t\t\t0x00\t \n#define MCHP_PIT64B_CR_START\t\tBIT(0)\n#define MCHP_PIT64B_CR_SWRST\t\tBIT(8)\n\n#define MCHP_PIT64B_MR\t\t\t0x04\t \n#define MCHP_PIT64B_MR_CONT\t\tBIT(0)\n#define MCHP_PIT64B_MR_ONE_SHOT\t\t(0)\n#define MCHP_PIT64B_MR_SGCLK\t\tBIT(3)\n#define MCHP_PIT64B_MR_PRES\t\tGENMASK(11, 8)\n\n#define MCHP_PIT64B_LSB_PR\t\t0x08\t \n\n#define MCHP_PIT64B_MSB_PR\t\t0x0C\t \n\n#define MCHP_PIT64B_IER\t\t\t0x10\t \n#define MCHP_PIT64B_IER_PERIOD\t\tBIT(0)\n\n#define MCHP_PIT64B_ISR\t\t\t0x1C\t \n\n#define MCHP_PIT64B_TLSBR\t\t0x20\t \n\n#define MCHP_PIT64B_TMSBR\t\t0x24\t \n\n#define MCHP_PIT64B_PRES_MAX\t\t0x10\n#define MCHP_PIT64B_LSBMASK\t\tGENMASK_ULL(31, 0)\n#define MCHP_PIT64B_PRES_TO_MODE(p)\t(MCHP_PIT64B_MR_PRES & ((p) << 8))\n#define MCHP_PIT64B_MODE_TO_PRES(m)\t((MCHP_PIT64B_MR_PRES & (m)) >> 8)\n#define MCHP_PIT64B_DEF_FREQ\t\t5000000UL\t \n\n#define MCHP_PIT64B_NAME\t\t\"pit64b\"\n\n \nstruct mchp_pit64b_timer {\n\tvoid __iomem\t*base;\n\tstruct clk\t*pclk;\n\tstruct clk\t*gclk;\n\tu32\t\tmode;\n};\n\n \nstruct mchp_pit64b_clkevt {\n\tstruct mchp_pit64b_timer\ttimer;\n\tstruct clock_event_device\tclkevt;\n};\n\n#define clkevt_to_mchp_pit64b_timer(x) \\\n\t((struct mchp_pit64b_timer *)container_of(x,\\\n\t\tstruct mchp_pit64b_clkevt, clkevt))\n\n \nstruct mchp_pit64b_clksrc {\n\tstruct mchp_pit64b_timer\ttimer;\n\tstruct clocksource\t\tclksrc;\n};\n\n#define clksrc_to_mchp_pit64b_timer(x) \\\n\t((struct mchp_pit64b_timer *)container_of(x,\\\n\t\tstruct mchp_pit64b_clksrc, clksrc))\n\n \nstatic void __iomem *mchp_pit64b_cs_base;\n \nstatic u64 mchp_pit64b_ce_cycles;\n \nstatic struct delay_timer mchp_pit64b_dt;\n\nstatic inline u64 mchp_pit64b_cnt_read(void __iomem *base)\n{\n\tunsigned long\tflags;\n\tu32\t\tlow, high;\n\n\traw_local_irq_save(flags);\n\n\t \n\tlow = readl_relaxed(base + MCHP_PIT64B_TLSBR);\n\thigh = readl_relaxed(base + MCHP_PIT64B_TMSBR);\n\n\traw_local_irq_restore(flags);\n\n\treturn (((u64)high << 32) | low);\n}\n\nstatic inline void mchp_pit64b_reset(struct mchp_pit64b_timer *timer,\n\t\t\t\t     u64 cycles, u32 mode, u32 irqs)\n{\n\tu32 low, high;\n\n\tlow = cycles & MCHP_PIT64B_LSBMASK;\n\thigh = cycles >> 32;\n\n\twritel_relaxed(MCHP_PIT64B_CR_SWRST, timer->base + MCHP_PIT64B_CR);\n\twritel_relaxed(mode | timer->mode, timer->base + MCHP_PIT64B_MR);\n\twritel_relaxed(high, timer->base + MCHP_PIT64B_MSB_PR);\n\twritel_relaxed(low, timer->base + MCHP_PIT64B_LSB_PR);\n\twritel_relaxed(irqs, timer->base + MCHP_PIT64B_IER);\n\twritel_relaxed(MCHP_PIT64B_CR_START, timer->base + MCHP_PIT64B_CR);\n}\n\nstatic void mchp_pit64b_suspend(struct mchp_pit64b_timer *timer)\n{\n\twritel_relaxed(MCHP_PIT64B_CR_SWRST, timer->base + MCHP_PIT64B_CR);\n\tif (timer->mode & MCHP_PIT64B_MR_SGCLK)\n\t\tclk_disable_unprepare(timer->gclk);\n\tclk_disable_unprepare(timer->pclk);\n}\n\nstatic void mchp_pit64b_resume(struct mchp_pit64b_timer *timer)\n{\n\tclk_prepare_enable(timer->pclk);\n\tif (timer->mode & MCHP_PIT64B_MR_SGCLK)\n\t\tclk_prepare_enable(timer->gclk);\n}\n\nstatic void mchp_pit64b_clksrc_suspend(struct clocksource *cs)\n{\n\tstruct mchp_pit64b_timer *timer = clksrc_to_mchp_pit64b_timer(cs);\n\n\tmchp_pit64b_suspend(timer);\n}\n\nstatic void mchp_pit64b_clksrc_resume(struct clocksource *cs)\n{\n\tstruct mchp_pit64b_timer *timer = clksrc_to_mchp_pit64b_timer(cs);\n\n\tmchp_pit64b_resume(timer);\n\tmchp_pit64b_reset(timer, ULLONG_MAX, MCHP_PIT64B_MR_CONT, 0);\n}\n\nstatic u64 mchp_pit64b_clksrc_read(struct clocksource *cs)\n{\n\treturn mchp_pit64b_cnt_read(mchp_pit64b_cs_base);\n}\n\nstatic u64 notrace mchp_pit64b_sched_read_clk(void)\n{\n\treturn mchp_pit64b_cnt_read(mchp_pit64b_cs_base);\n}\n\nstatic unsigned long notrace mchp_pit64b_dt_read(void)\n{\n\treturn mchp_pit64b_cnt_read(mchp_pit64b_cs_base);\n}\n\nstatic int mchp_pit64b_clkevt_shutdown(struct clock_event_device *cedev)\n{\n\tstruct mchp_pit64b_timer *timer = clkevt_to_mchp_pit64b_timer(cedev);\n\n\tif (!clockevent_state_detached(cedev))\n\t\tmchp_pit64b_suspend(timer);\n\n\treturn 0;\n}\n\nstatic int mchp_pit64b_clkevt_set_periodic(struct clock_event_device *cedev)\n{\n\tstruct mchp_pit64b_timer *timer = clkevt_to_mchp_pit64b_timer(cedev);\n\n\tif (clockevent_state_shutdown(cedev))\n\t\tmchp_pit64b_resume(timer);\n\n\tmchp_pit64b_reset(timer, mchp_pit64b_ce_cycles, MCHP_PIT64B_MR_CONT,\n\t\t\t  MCHP_PIT64B_IER_PERIOD);\n\n\treturn 0;\n}\n\nstatic int mchp_pit64b_clkevt_set_oneshot(struct clock_event_device *cedev)\n{\n\tstruct mchp_pit64b_timer *timer = clkevt_to_mchp_pit64b_timer(cedev);\n\n\tif (clockevent_state_shutdown(cedev))\n\t\tmchp_pit64b_resume(timer);\n\n\tmchp_pit64b_reset(timer, mchp_pit64b_ce_cycles, MCHP_PIT64B_MR_ONE_SHOT,\n\t\t\t  MCHP_PIT64B_IER_PERIOD);\n\n\treturn 0;\n}\n\nstatic int mchp_pit64b_clkevt_set_next_event(unsigned long evt,\n\t\t\t\t\t     struct clock_event_device *cedev)\n{\n\tstruct mchp_pit64b_timer *timer = clkevt_to_mchp_pit64b_timer(cedev);\n\n\tmchp_pit64b_reset(timer, evt, MCHP_PIT64B_MR_ONE_SHOT,\n\t\t\t  MCHP_PIT64B_IER_PERIOD);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mchp_pit64b_interrupt(int irq, void *dev_id)\n{\n\tstruct mchp_pit64b_clkevt *irq_data = dev_id;\n\n\t \n\treadl_relaxed(irq_data->timer.base + MCHP_PIT64B_ISR);\n\n\tirq_data->clkevt.event_handler(&irq_data->clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void __init mchp_pit64b_pres_compute(u32 *pres, u32 clk_rate,\n\t\t\t\t\t    u32 max_rate)\n{\n\tu32 tmp;\n\n\tfor (*pres = 0; *pres < MCHP_PIT64B_PRES_MAX; (*pres)++) {\n\t\ttmp = clk_rate / (*pres + 1);\n\t\tif (tmp <= max_rate)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (*pres == MCHP_PIT64B_PRES_MAX)\n\t\t*pres = MCHP_PIT64B_PRES_MAX - 1;\n}\n\n \nstatic int __init mchp_pit64b_init_mode(struct mchp_pit64b_timer *timer,\n\t\t\t\t\tunsigned long max_rate)\n{\n\tunsigned long pclk_rate, diff = 0, best_diff = ULONG_MAX;\n\tlong gclk_round = 0;\n\tu32 pres, best_pres = 0;\n\n\tpclk_rate = clk_get_rate(timer->pclk);\n\tif (!pclk_rate)\n\t\treturn -EINVAL;\n\n\ttimer->mode = 0;\n\n\t \n\tgclk_round = clk_round_rate(timer->gclk, max_rate);\n\tif (gclk_round < 0)\n\t\tgoto pclk;\n\n\tif (pclk_rate / gclk_round < 3)\n\t\tgoto pclk;\n\n\tmchp_pit64b_pres_compute(&pres, gclk_round, max_rate);\n\tbest_diff = abs(gclk_round / (pres + 1) - max_rate);\n\tbest_pres = pres;\n\n\tif (!best_diff) {\n\t\ttimer->mode |= MCHP_PIT64B_MR_SGCLK;\n\t\tclk_set_rate(timer->gclk, gclk_round);\n\t\tgoto done;\n\t}\n\npclk:\n\t \n\tmchp_pit64b_pres_compute(&pres, pclk_rate, max_rate);\n\tdiff = abs(pclk_rate / (pres + 1) - max_rate);\n\n\tif (best_diff > diff) {\n\t\t \n\t\tbest_pres = pres;\n\t} else {\n\t\t \n\t\ttimer->mode |= MCHP_PIT64B_MR_SGCLK;\n\t\tclk_set_rate(timer->gclk, gclk_round);\n\t}\n\ndone:\n\ttimer->mode |= MCHP_PIT64B_PRES_TO_MODE(best_pres);\n\n\tpr_info(\"PIT64B: using clk=%s with prescaler %u, freq=%lu [Hz]\\n\",\n\t\ttimer->mode & MCHP_PIT64B_MR_SGCLK ? \"gclk\" : \"pclk\", best_pres,\n\t\ttimer->mode & MCHP_PIT64B_MR_SGCLK ?\n\t\tgclk_round / (best_pres + 1) : pclk_rate / (best_pres + 1));\n\n\treturn 0;\n}\n\nstatic int __init mchp_pit64b_init_clksrc(struct mchp_pit64b_timer *timer,\n\t\t\t\t\t  u32 clk_rate)\n{\n\tstruct mchp_pit64b_clksrc *cs;\n\tint ret;\n\n\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn -ENOMEM;\n\n\tmchp_pit64b_resume(timer);\n\tmchp_pit64b_reset(timer, ULLONG_MAX, MCHP_PIT64B_MR_CONT, 0);\n\n\tmchp_pit64b_cs_base = timer->base;\n\n\tcs->timer.base = timer->base;\n\tcs->timer.pclk = timer->pclk;\n\tcs->timer.gclk = timer->gclk;\n\tcs->timer.mode = timer->mode;\n\tcs->clksrc.name = MCHP_PIT64B_NAME;\n\tcs->clksrc.mask = CLOCKSOURCE_MASK(64);\n\tcs->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\tcs->clksrc.rating = 210;\n\tcs->clksrc.read = mchp_pit64b_clksrc_read;\n\tcs->clksrc.suspend = mchp_pit64b_clksrc_suspend;\n\tcs->clksrc.resume = mchp_pit64b_clksrc_resume;\n\n\tret = clocksource_register_hz(&cs->clksrc, clk_rate);\n\tif (ret) {\n\t\tpr_debug(\"clksrc: Failed to register PIT64B clocksource!\\n\");\n\n\t\t \n\t\tmchp_pit64b_suspend(timer);\n\t\tkfree(cs);\n\n\t\treturn ret;\n\t}\n\n\tsched_clock_register(mchp_pit64b_sched_read_clk, 64, clk_rate);\n\n\tmchp_pit64b_dt.read_current_timer = mchp_pit64b_dt_read;\n\tmchp_pit64b_dt.freq = clk_rate;\n\tregister_current_timer_delay(&mchp_pit64b_dt);\n\n\treturn 0;\n}\n\nstatic int __init mchp_pit64b_init_clkevt(struct mchp_pit64b_timer *timer,\n\t\t\t\t\t  u32 clk_rate, u32 irq)\n{\n\tstruct mchp_pit64b_clkevt *ce;\n\tint ret;\n\n\tce = kzalloc(sizeof(*ce), GFP_KERNEL);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\n\tmchp_pit64b_ce_cycles = DIV_ROUND_CLOSEST(clk_rate, HZ);\n\n\tce->timer.base = timer->base;\n\tce->timer.pclk = timer->pclk;\n\tce->timer.gclk = timer->gclk;\n\tce->timer.mode = timer->mode;\n\tce->clkevt.name = MCHP_PIT64B_NAME;\n\tce->clkevt.features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC;\n\tce->clkevt.rating = 150;\n\tce->clkevt.set_state_shutdown = mchp_pit64b_clkevt_shutdown;\n\tce->clkevt.set_state_periodic = mchp_pit64b_clkevt_set_periodic;\n\tce->clkevt.set_state_oneshot = mchp_pit64b_clkevt_set_oneshot;\n\tce->clkevt.set_next_event = mchp_pit64b_clkevt_set_next_event;\n\tce->clkevt.cpumask = cpumask_of(0);\n\tce->clkevt.irq = irq;\n\n\tret = request_irq(irq, mchp_pit64b_interrupt, IRQF_TIMER,\n\t\t\t  \"pit64b_tick\", ce);\n\tif (ret) {\n\t\tpr_debug(\"clkevt: Failed to setup PIT64B IRQ\\n\");\n\t\tkfree(ce);\n\t\treturn ret;\n\t}\n\n\tclockevents_config_and_register(&ce->clkevt, clk_rate, 1, ULONG_MAX);\n\n\treturn 0;\n}\n\nstatic int __init mchp_pit64b_dt_init_timer(struct device_node *node,\n\t\t\t\t\t    bool clkevt)\n{\n\tstruct mchp_pit64b_timer timer;\n\tunsigned long clk_rate;\n\tu32 irq = 0;\n\tint ret;\n\n\t \n\ttimer.pclk = of_clk_get_by_name(node, \"pclk\");\n\tif (IS_ERR(timer.pclk))\n\t\treturn PTR_ERR(timer.pclk);\n\n\ttimer.gclk = of_clk_get_by_name(node, \"gclk\");\n\tif (IS_ERR(timer.gclk))\n\t\treturn PTR_ERR(timer.gclk);\n\n\ttimer.base = of_iomap(node, 0);\n\tif (!timer.base)\n\t\treturn -ENXIO;\n\n\tif (clkevt) {\n\t\tirq = irq_of_parse_and_map(node, 0);\n\t\tif (!irq) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto io_unmap;\n\t\t}\n\t}\n\n\t \n\tret = mchp_pit64b_init_mode(&timer, MCHP_PIT64B_DEF_FREQ);\n\tif (ret)\n\t\tgoto irq_unmap;\n\n\tif (timer.mode & MCHP_PIT64B_MR_SGCLK)\n\t\tclk_rate = clk_get_rate(timer.gclk);\n\telse\n\t\tclk_rate = clk_get_rate(timer.pclk);\n\tclk_rate = clk_rate / (MCHP_PIT64B_MODE_TO_PRES(timer.mode) + 1);\n\n\tif (clkevt)\n\t\tret = mchp_pit64b_init_clkevt(&timer, clk_rate, irq);\n\telse\n\t\tret = mchp_pit64b_init_clksrc(&timer, clk_rate);\n\n\tif (ret)\n\t\tgoto irq_unmap;\n\n\treturn 0;\n\nirq_unmap:\n\tirq_dispose_mapping(irq);\nio_unmap:\n\tiounmap(timer.base);\n\n\treturn ret;\n}\n\nstatic int __init mchp_pit64b_dt_init(struct device_node *node)\n{\n\tstatic int inits;\n\n\tswitch (inits++) {\n\tcase 0:\n\t\t \n\t\treturn mchp_pit64b_dt_init_timer(node, true);\n\tcase 1:\n\t\t \n\t\treturn mchp_pit64b_dt_init_timer(node, false);\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nTIMER_OF_DECLARE(mchp_pit64b, \"microchip,sam9x60-pit64b\", mchp_pit64b_dt_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}