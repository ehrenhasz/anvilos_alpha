{
  "module_name": "sh_mtu2.c",
  "hash_id": "9ee59d0882aa5642a8d78be56eb12a130bd7ea8605062ed2416c02cf9940390a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/sh_mtu2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/sh_timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#ifdef CONFIG_SUPERH\n#include <asm/platform_early.h>\n#endif\n\nstruct sh_mtu2_device;\n\nstruct sh_mtu2_channel {\n\tstruct sh_mtu2_device *mtu;\n\tunsigned int index;\n\n\tvoid __iomem *base;\n\n\tstruct clock_event_device ced;\n};\n\nstruct sh_mtu2_device {\n\tstruct platform_device *pdev;\n\n\tvoid __iomem *mapbase;\n\tstruct clk *clk;\n\n\traw_spinlock_t lock;  \n\n\tstruct sh_mtu2_channel *channels;\n\tunsigned int num_channels;\n\n\tbool has_clockevent;\n};\n\n#define TSTR -1  \n#define TCR  0  \n#define TMDR 1  \n#define TIOR 2  \n#define TIER 3  \n#define TSR  4  \n#define TCNT 5  \n#define TGR  6  \n\n#define TCR_CCLR_NONE\t\t(0 << 5)\n#define TCR_CCLR_TGRA\t\t(1 << 5)\n#define TCR_CCLR_TGRB\t\t(2 << 5)\n#define TCR_CCLR_SYNC\t\t(3 << 5)\n#define TCR_CCLR_TGRC\t\t(5 << 5)\n#define TCR_CCLR_TGRD\t\t(6 << 5)\n#define TCR_CCLR_MASK\t\t(7 << 5)\n#define TCR_CKEG_RISING\t\t(0 << 3)\n#define TCR_CKEG_FALLING\t(1 << 3)\n#define TCR_CKEG_BOTH\t\t(2 << 3)\n#define TCR_CKEG_MASK\t\t(3 << 3)\n \n#define TCR_TPSC_P1\t\t(0 << 0)\n#define TCR_TPSC_P4\t\t(1 << 0)\n#define TCR_TPSC_P16\t\t(2 << 0)\n#define TCR_TPSC_P64\t\t(3 << 0)\n#define TCR_TPSC_CH0_TCLKA\t(4 << 0)\n#define TCR_TPSC_CH0_TCLKB\t(5 << 0)\n#define TCR_TPSC_CH0_TCLKC\t(6 << 0)\n#define TCR_TPSC_CH0_TCLKD\t(7 << 0)\n#define TCR_TPSC_CH1_TCLKA\t(4 << 0)\n#define TCR_TPSC_CH1_TCLKB\t(5 << 0)\n#define TCR_TPSC_CH1_P256\t(6 << 0)\n#define TCR_TPSC_CH1_TCNT2\t(7 << 0)\n#define TCR_TPSC_CH2_TCLKA\t(4 << 0)\n#define TCR_TPSC_CH2_TCLKB\t(5 << 0)\n#define TCR_TPSC_CH2_TCLKC\t(6 << 0)\n#define TCR_TPSC_CH2_P1024\t(7 << 0)\n#define TCR_TPSC_CH34_P256\t(4 << 0)\n#define TCR_TPSC_CH34_P1024\t(5 << 0)\n#define TCR_TPSC_CH34_TCLKA\t(6 << 0)\n#define TCR_TPSC_CH34_TCLKB\t(7 << 0)\n#define TCR_TPSC_MASK\t\t(7 << 0)\n\n#define TMDR_BFE\t\t(1 << 6)\n#define TMDR_BFB\t\t(1 << 5)\n#define TMDR_BFA\t\t(1 << 4)\n#define TMDR_MD_NORMAL\t\t(0 << 0)\n#define TMDR_MD_PWM_1\t\t(2 << 0)\n#define TMDR_MD_PWM_2\t\t(3 << 0)\n#define TMDR_MD_PHASE_1\t\t(4 << 0)\n#define TMDR_MD_PHASE_2\t\t(5 << 0)\n#define TMDR_MD_PHASE_3\t\t(6 << 0)\n#define TMDR_MD_PHASE_4\t\t(7 << 0)\n#define TMDR_MD_PWM_SYNC\t(8 << 0)\n#define TMDR_MD_PWM_COMP_CREST\t(13 << 0)\n#define TMDR_MD_PWM_COMP_TROUGH\t(14 << 0)\n#define TMDR_MD_PWM_COMP_BOTH\t(15 << 0)\n#define TMDR_MD_MASK\t\t(15 << 0)\n\n#define TIOC_IOCH(n)\t\t((n) << 4)\n#define TIOC_IOCL(n)\t\t((n) << 0)\n#define TIOR_OC_RETAIN\t\t(0 << 0)\n#define TIOR_OC_0_CLEAR\t\t(1 << 0)\n#define TIOR_OC_0_SET\t\t(2 << 0)\n#define TIOR_OC_0_TOGGLE\t(3 << 0)\n#define TIOR_OC_1_CLEAR\t\t(5 << 0)\n#define TIOR_OC_1_SET\t\t(6 << 0)\n#define TIOR_OC_1_TOGGLE\t(7 << 0)\n#define TIOR_IC_RISING\t\t(8 << 0)\n#define TIOR_IC_FALLING\t\t(9 << 0)\n#define TIOR_IC_BOTH\t\t(10 << 0)\n#define TIOR_IC_TCNT\t\t(12 << 0)\n#define TIOR_MASK\t\t(15 << 0)\n\n#define TIER_TTGE\t\t(1 << 7)\n#define TIER_TTGE2\t\t(1 << 6)\n#define TIER_TCIEU\t\t(1 << 5)\n#define TIER_TCIEV\t\t(1 << 4)\n#define TIER_TGIED\t\t(1 << 3)\n#define TIER_TGIEC\t\t(1 << 2)\n#define TIER_TGIEB\t\t(1 << 1)\n#define TIER_TGIEA\t\t(1 << 0)\n\n#define TSR_TCFD\t\t(1 << 7)\n#define TSR_TCFU\t\t(1 << 5)\n#define TSR_TCFV\t\t(1 << 4)\n#define TSR_TGFD\t\t(1 << 3)\n#define TSR_TGFC\t\t(1 << 2)\n#define TSR_TGFB\t\t(1 << 1)\n#define TSR_TGFA\t\t(1 << 0)\n\nstatic unsigned long mtu2_reg_offs[] = {\n\t[TCR] = 0,\n\t[TMDR] = 1,\n\t[TIOR] = 2,\n\t[TIER] = 4,\n\t[TSR] = 5,\n\t[TCNT] = 6,\n\t[TGR] = 8,\n};\n\nstatic inline unsigned long sh_mtu2_read(struct sh_mtu2_channel *ch, int reg_nr)\n{\n\tunsigned long offs;\n\n\tif (reg_nr == TSTR)\n\t\treturn ioread8(ch->mtu->mapbase + 0x280);\n\n\toffs = mtu2_reg_offs[reg_nr];\n\n\tif ((reg_nr == TCNT) || (reg_nr == TGR))\n\t\treturn ioread16(ch->base + offs);\n\telse\n\t\treturn ioread8(ch->base + offs);\n}\n\nstatic inline void sh_mtu2_write(struct sh_mtu2_channel *ch, int reg_nr,\n\t\t\t\tunsigned long value)\n{\n\tunsigned long offs;\n\n\tif (reg_nr == TSTR)\n\t\treturn iowrite8(value, ch->mtu->mapbase + 0x280);\n\n\toffs = mtu2_reg_offs[reg_nr];\n\n\tif ((reg_nr == TCNT) || (reg_nr == TGR))\n\t\tiowrite16(value, ch->base + offs);\n\telse\n\t\tiowrite8(value, ch->base + offs);\n}\n\nstatic void sh_mtu2_start_stop_ch(struct sh_mtu2_channel *ch, int start)\n{\n\tunsigned long flags, value;\n\n\t \n\traw_spin_lock_irqsave(&ch->mtu->lock, flags);\n\tvalue = sh_mtu2_read(ch, TSTR);\n\n\tif (start)\n\t\tvalue |= 1 << ch->index;\n\telse\n\t\tvalue &= ~(1 << ch->index);\n\n\tsh_mtu2_write(ch, TSTR, value);\n\traw_spin_unlock_irqrestore(&ch->mtu->lock, flags);\n}\n\nstatic int sh_mtu2_enable(struct sh_mtu2_channel *ch)\n{\n\tunsigned long periodic;\n\tunsigned long rate;\n\tint ret;\n\n\tpm_runtime_get_sync(&ch->mtu->pdev->dev);\n\tdev_pm_syscore_device(&ch->mtu->pdev->dev, true);\n\n\t \n\tret = clk_enable(ch->mtu->clk);\n\tif (ret) {\n\t\tdev_err(&ch->mtu->pdev->dev, \"ch%u: cannot enable clock\\n\",\n\t\t\tch->index);\n\t\treturn ret;\n\t}\n\n\t \n\tsh_mtu2_start_stop_ch(ch, 0);\n\n\trate = clk_get_rate(ch->mtu->clk) / 64;\n\tperiodic = (rate + HZ/2) / HZ;\n\n\t \n\tsh_mtu2_write(ch, TCR, TCR_CCLR_TGRA | TCR_TPSC_P64);\n\tsh_mtu2_write(ch, TIOR, TIOC_IOCH(TIOR_OC_0_CLEAR) |\n\t\t      TIOC_IOCL(TIOR_OC_0_CLEAR));\n\tsh_mtu2_write(ch, TGR, periodic);\n\tsh_mtu2_write(ch, TCNT, 0);\n\tsh_mtu2_write(ch, TMDR, TMDR_MD_NORMAL);\n\tsh_mtu2_write(ch, TIER, TIER_TGIEA);\n\n\t \n\tsh_mtu2_start_stop_ch(ch, 1);\n\n\treturn 0;\n}\n\nstatic void sh_mtu2_disable(struct sh_mtu2_channel *ch)\n{\n\t \n\tsh_mtu2_start_stop_ch(ch, 0);\n\n\t \n\tclk_disable(ch->mtu->clk);\n\n\tdev_pm_syscore_device(&ch->mtu->pdev->dev, false);\n\tpm_runtime_put(&ch->mtu->pdev->dev);\n}\n\nstatic irqreturn_t sh_mtu2_interrupt(int irq, void *dev_id)\n{\n\tstruct sh_mtu2_channel *ch = dev_id;\n\n\t \n\tsh_mtu2_read(ch, TSR);\n\tsh_mtu2_write(ch, TSR, ~TSR_TGFA);\n\n\t \n\tch->ced.event_handler(&ch->ced);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sh_mtu2_channel *ced_to_sh_mtu2(struct clock_event_device *ced)\n{\n\treturn container_of(ced, struct sh_mtu2_channel, ced);\n}\n\nstatic int sh_mtu2_clock_event_shutdown(struct clock_event_device *ced)\n{\n\tstruct sh_mtu2_channel *ch = ced_to_sh_mtu2(ced);\n\n\tif (clockevent_state_periodic(ced))\n\t\tsh_mtu2_disable(ch);\n\n\treturn 0;\n}\n\nstatic int sh_mtu2_clock_event_set_periodic(struct clock_event_device *ced)\n{\n\tstruct sh_mtu2_channel *ch = ced_to_sh_mtu2(ced);\n\n\tif (clockevent_state_periodic(ced))\n\t\tsh_mtu2_disable(ch);\n\n\tdev_info(&ch->mtu->pdev->dev, \"ch%u: used for periodic clock events\\n\",\n\t\t ch->index);\n\tsh_mtu2_enable(ch);\n\treturn 0;\n}\n\nstatic void sh_mtu2_clock_event_suspend(struct clock_event_device *ced)\n{\n\tdev_pm_genpd_suspend(&ced_to_sh_mtu2(ced)->mtu->pdev->dev);\n}\n\nstatic void sh_mtu2_clock_event_resume(struct clock_event_device *ced)\n{\n\tdev_pm_genpd_resume(&ced_to_sh_mtu2(ced)->mtu->pdev->dev);\n}\n\nstatic void sh_mtu2_register_clockevent(struct sh_mtu2_channel *ch,\n\t\t\t\t\tconst char *name)\n{\n\tstruct clock_event_device *ced = &ch->ced;\n\n\tced->name = name;\n\tced->features = CLOCK_EVT_FEAT_PERIODIC;\n\tced->rating = 200;\n\tced->cpumask = cpu_possible_mask;\n\tced->set_state_shutdown = sh_mtu2_clock_event_shutdown;\n\tced->set_state_periodic = sh_mtu2_clock_event_set_periodic;\n\tced->suspend = sh_mtu2_clock_event_suspend;\n\tced->resume = sh_mtu2_clock_event_resume;\n\n\tdev_info(&ch->mtu->pdev->dev, \"ch%u: used for clock events\\n\",\n\t\t ch->index);\n\tclockevents_register_device(ced);\n}\n\nstatic int sh_mtu2_register(struct sh_mtu2_channel *ch, const char *name)\n{\n\tch->mtu->has_clockevent = true;\n\tsh_mtu2_register_clockevent(ch, name);\n\n\treturn 0;\n}\n\nstatic const unsigned int sh_mtu2_channel_offsets[] = {\n\t0x300, 0x380, 0x000,\n};\n\nstatic int sh_mtu2_setup_channel(struct sh_mtu2_channel *ch, unsigned int index,\n\t\t\t\t struct sh_mtu2_device *mtu)\n{\n\tchar name[6];\n\tint irq;\n\tint ret;\n\n\tch->mtu = mtu;\n\n\tsprintf(name, \"tgi%ua\", index);\n\tirq = platform_get_irq_byname(mtu->pdev, name);\n\tif (irq < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tret = request_irq(irq, sh_mtu2_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\n\t\t\t  dev_name(&ch->mtu->pdev->dev), ch);\n\tif (ret) {\n\t\tdev_err(&ch->mtu->pdev->dev, \"ch%u: failed to request irq %d\\n\",\n\t\t\tindex, irq);\n\t\treturn ret;\n\t}\n\n\tch->base = mtu->mapbase + sh_mtu2_channel_offsets[index];\n\tch->index = index;\n\n\treturn sh_mtu2_register(ch, dev_name(&mtu->pdev->dev));\n}\n\nstatic int sh_mtu2_map_memory(struct sh_mtu2_device *mtu)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource(mtu->pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&mtu->pdev->dev, \"failed to get I/O memory\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmtu->mapbase = ioremap(res->start, resource_size(res));\n\tif (mtu->mapbase == NULL)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int sh_mtu2_setup(struct sh_mtu2_device *mtu,\n\t\t\t struct platform_device *pdev)\n{\n\tunsigned int i;\n\tint ret;\n\n\tmtu->pdev = pdev;\n\n\traw_spin_lock_init(&mtu->lock);\n\n\t \n\tmtu->clk = clk_get(&mtu->pdev->dev, \"fck\");\n\tif (IS_ERR(mtu->clk)) {\n\t\tdev_err(&mtu->pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(mtu->clk);\n\t}\n\n\tret = clk_prepare(mtu->clk);\n\tif (ret < 0)\n\t\tgoto err_clk_put;\n\n\t \n\tret = sh_mtu2_map_memory(mtu);\n\tif (ret < 0) {\n\t\tdev_err(&mtu->pdev->dev, \"failed to remap I/O memory\\n\");\n\t\tgoto err_clk_unprepare;\n\t}\n\n\t \n\tret = platform_irq_count(pdev);\n\tif (ret < 0)\n\t\tgoto err_unmap;\n\n\tmtu->num_channels = min_t(unsigned int, ret,\n\t\t\t\t  ARRAY_SIZE(sh_mtu2_channel_offsets));\n\n\tmtu->channels = kcalloc(mtu->num_channels, sizeof(*mtu->channels),\n\t\t\t\tGFP_KERNEL);\n\tif (mtu->channels == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\tfor (i = 0; i < mtu->num_channels; ++i) {\n\t\tret = sh_mtu2_setup_channel(&mtu->channels[i], i, mtu);\n\t\tif (ret < 0)\n\t\t\tgoto err_unmap;\n\t}\n\n\tplatform_set_drvdata(pdev, mtu);\n\n\treturn 0;\n\nerr_unmap:\n\tkfree(mtu->channels);\n\tiounmap(mtu->mapbase);\nerr_clk_unprepare:\n\tclk_unprepare(mtu->clk);\nerr_clk_put:\n\tclk_put(mtu->clk);\n\treturn ret;\n}\n\nstatic int sh_mtu2_probe(struct platform_device *pdev)\n{\n\tstruct sh_mtu2_device *mtu = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (!is_sh_early_platform_device(pdev)) {\n\t\tpm_runtime_set_active(&pdev->dev);\n\t\tpm_runtime_enable(&pdev->dev);\n\t}\n\n\tif (mtu) {\n\t\tdev_info(&pdev->dev, \"kept as earlytimer\\n\");\n\t\tgoto out;\n\t}\n\n\tmtu = kzalloc(sizeof(*mtu), GFP_KERNEL);\n\tif (mtu == NULL)\n\t\treturn -ENOMEM;\n\n\tret = sh_mtu2_setup(mtu, pdev);\n\tif (ret) {\n\t\tkfree(mtu);\n\t\tpm_runtime_idle(&pdev->dev);\n\t\treturn ret;\n\t}\n\tif (is_sh_early_platform_device(pdev))\n\t\treturn 0;\n\n out:\n\tif (mtu->has_clockevent)\n\t\tpm_runtime_irq_safe(&pdev->dev);\n\telse\n\t\tpm_runtime_idle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sh_mtu2_id_table[] = {\n\t{ \"sh-mtu2\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, sh_mtu2_id_table);\n\nstatic const struct of_device_id sh_mtu2_of_table[] __maybe_unused = {\n\t{ .compatible = \"renesas,mtu2\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sh_mtu2_of_table);\n\nstatic struct platform_driver sh_mtu2_device_driver = {\n\t.probe\t\t= sh_mtu2_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sh_mtu2\",\n\t\t.of_match_table = of_match_ptr(sh_mtu2_of_table),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.id_table\t= sh_mtu2_id_table,\n};\n\nstatic int __init sh_mtu2_init(void)\n{\n\treturn platform_driver_register(&sh_mtu2_device_driver);\n}\n\nstatic void __exit sh_mtu2_exit(void)\n{\n\tplatform_driver_unregister(&sh_mtu2_device_driver);\n}\n\n#ifdef CONFIG_SUPERH\nsh_early_platform_init(\"earlytimer\", &sh_mtu2_device_driver);\n#endif\n\nsubsys_initcall(sh_mtu2_init);\nmodule_exit(sh_mtu2_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"SuperH MTU2 Timer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}