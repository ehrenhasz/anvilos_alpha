{
  "module_name": "sh_tmu.c",
  "hash_id": "dd00e5ccc75a3b0e325d1ff4a9906c10d3b839758713461a21abf9cb8663185a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/sh_tmu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/sh_timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#ifdef CONFIG_SUPERH\n#include <asm/platform_early.h>\n#endif\n\nenum sh_tmu_model {\n\tSH_TMU,\n\tSH_TMU_SH3,\n};\n\nstruct sh_tmu_device;\n\nstruct sh_tmu_channel {\n\tstruct sh_tmu_device *tmu;\n\tunsigned int index;\n\n\tvoid __iomem *base;\n\tint irq;\n\n\tunsigned long periodic;\n\tstruct clock_event_device ced;\n\tstruct clocksource cs;\n\tbool cs_enabled;\n\tunsigned int enable_count;\n};\n\nstruct sh_tmu_device {\n\tstruct platform_device *pdev;\n\n\tvoid __iomem *mapbase;\n\tstruct clk *clk;\n\tunsigned long rate;\n\n\tenum sh_tmu_model model;\n\n\traw_spinlock_t lock;  \n\n\tstruct sh_tmu_channel *channels;\n\tunsigned int num_channels;\n\n\tbool has_clockevent;\n\tbool has_clocksource;\n};\n\n#define TSTR -1  \n#define TCOR  0  \n#define TCNT 1  \n#define TCR 2  \n\n#define TCR_UNF\t\t\t(1 << 8)\n#define TCR_UNIE\t\t(1 << 5)\n#define TCR_TPSC_CLK4\t\t(0 << 0)\n#define TCR_TPSC_CLK16\t\t(1 << 0)\n#define TCR_TPSC_CLK64\t\t(2 << 0)\n#define TCR_TPSC_CLK256\t\t(3 << 0)\n#define TCR_TPSC_CLK1024\t(4 << 0)\n#define TCR_TPSC_MASK\t\t(7 << 0)\n\nstatic inline unsigned long sh_tmu_read(struct sh_tmu_channel *ch, int reg_nr)\n{\n\tunsigned long offs;\n\n\tif (reg_nr == TSTR) {\n\t\tswitch (ch->tmu->model) {\n\t\tcase SH_TMU_SH3:\n\t\t\treturn ioread8(ch->tmu->mapbase + 2);\n\t\tcase SH_TMU:\n\t\t\treturn ioread8(ch->tmu->mapbase + 4);\n\t\t}\n\t}\n\n\toffs = reg_nr << 2;\n\n\tif (reg_nr == TCR)\n\t\treturn ioread16(ch->base + offs);\n\telse\n\t\treturn ioread32(ch->base + offs);\n}\n\nstatic inline void sh_tmu_write(struct sh_tmu_channel *ch, int reg_nr,\n\t\t\t\tunsigned long value)\n{\n\tunsigned long offs;\n\n\tif (reg_nr == TSTR) {\n\t\tswitch (ch->tmu->model) {\n\t\tcase SH_TMU_SH3:\n\t\t\treturn iowrite8(value, ch->tmu->mapbase + 2);\n\t\tcase SH_TMU:\n\t\t\treturn iowrite8(value, ch->tmu->mapbase + 4);\n\t\t}\n\t}\n\n\toffs = reg_nr << 2;\n\n\tif (reg_nr == TCR)\n\t\tiowrite16(value, ch->base + offs);\n\telse\n\t\tiowrite32(value, ch->base + offs);\n}\n\nstatic void sh_tmu_start_stop_ch(struct sh_tmu_channel *ch, int start)\n{\n\tunsigned long flags, value;\n\n\t \n\traw_spin_lock_irqsave(&ch->tmu->lock, flags);\n\tvalue = sh_tmu_read(ch, TSTR);\n\n\tif (start)\n\t\tvalue |= 1 << ch->index;\n\telse\n\t\tvalue &= ~(1 << ch->index);\n\n\tsh_tmu_write(ch, TSTR, value);\n\traw_spin_unlock_irqrestore(&ch->tmu->lock, flags);\n}\n\nstatic int __sh_tmu_enable(struct sh_tmu_channel *ch)\n{\n\tint ret;\n\n\t \n\tret = clk_enable(ch->tmu->clk);\n\tif (ret) {\n\t\tdev_err(&ch->tmu->pdev->dev, \"ch%u: cannot enable clock\\n\",\n\t\t\tch->index);\n\t\treturn ret;\n\t}\n\n\t \n\tsh_tmu_start_stop_ch(ch, 0);\n\n\t \n\tsh_tmu_write(ch, TCOR, 0xffffffff);\n\tsh_tmu_write(ch, TCNT, 0xffffffff);\n\n\t \n\tsh_tmu_write(ch, TCR, TCR_TPSC_CLK4);\n\n\t \n\tsh_tmu_start_stop_ch(ch, 1);\n\n\treturn 0;\n}\n\nstatic int sh_tmu_enable(struct sh_tmu_channel *ch)\n{\n\tif (ch->enable_count++ > 0)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(&ch->tmu->pdev->dev);\n\tdev_pm_syscore_device(&ch->tmu->pdev->dev, true);\n\n\treturn __sh_tmu_enable(ch);\n}\n\nstatic void __sh_tmu_disable(struct sh_tmu_channel *ch)\n{\n\t \n\tsh_tmu_start_stop_ch(ch, 0);\n\n\t \n\tsh_tmu_write(ch, TCR, TCR_TPSC_CLK4);\n\n\t \n\tclk_disable(ch->tmu->clk);\n}\n\nstatic void sh_tmu_disable(struct sh_tmu_channel *ch)\n{\n\tif (WARN_ON(ch->enable_count == 0))\n\t\treturn;\n\n\tif (--ch->enable_count > 0)\n\t\treturn;\n\n\t__sh_tmu_disable(ch);\n\n\tdev_pm_syscore_device(&ch->tmu->pdev->dev, false);\n\tpm_runtime_put(&ch->tmu->pdev->dev);\n}\n\nstatic void sh_tmu_set_next(struct sh_tmu_channel *ch, unsigned long delta,\n\t\t\t    int periodic)\n{\n\t \n\tsh_tmu_start_stop_ch(ch, 0);\n\n\t \n\tsh_tmu_read(ch, TCR);\n\n\t \n\tsh_tmu_write(ch, TCR, TCR_UNIE | TCR_TPSC_CLK4);\n\n\t \n\tif (periodic)\n\t\tsh_tmu_write(ch, TCOR, delta);\n\telse\n\t\tsh_tmu_write(ch, TCOR, 0xffffffff);\n\n\tsh_tmu_write(ch, TCNT, delta);\n\n\t \n\tsh_tmu_start_stop_ch(ch, 1);\n}\n\nstatic irqreturn_t sh_tmu_interrupt(int irq, void *dev_id)\n{\n\tstruct sh_tmu_channel *ch = dev_id;\n\n\t \n\tif (clockevent_state_oneshot(&ch->ced))\n\t\tsh_tmu_write(ch, TCR, TCR_TPSC_CLK4);\n\telse\n\t\tsh_tmu_write(ch, TCR, TCR_UNIE | TCR_TPSC_CLK4);\n\n\t \n\tch->ced.event_handler(&ch->ced);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sh_tmu_channel *cs_to_sh_tmu(struct clocksource *cs)\n{\n\treturn container_of(cs, struct sh_tmu_channel, cs);\n}\n\nstatic u64 sh_tmu_clocksource_read(struct clocksource *cs)\n{\n\tstruct sh_tmu_channel *ch = cs_to_sh_tmu(cs);\n\n\treturn sh_tmu_read(ch, TCNT) ^ 0xffffffff;\n}\n\nstatic int sh_tmu_clocksource_enable(struct clocksource *cs)\n{\n\tstruct sh_tmu_channel *ch = cs_to_sh_tmu(cs);\n\tint ret;\n\n\tif (WARN_ON(ch->cs_enabled))\n\t\treturn 0;\n\n\tret = sh_tmu_enable(ch);\n\tif (!ret)\n\t\tch->cs_enabled = true;\n\n\treturn ret;\n}\n\nstatic void sh_tmu_clocksource_disable(struct clocksource *cs)\n{\n\tstruct sh_tmu_channel *ch = cs_to_sh_tmu(cs);\n\n\tif (WARN_ON(!ch->cs_enabled))\n\t\treturn;\n\n\tsh_tmu_disable(ch);\n\tch->cs_enabled = false;\n}\n\nstatic void sh_tmu_clocksource_suspend(struct clocksource *cs)\n{\n\tstruct sh_tmu_channel *ch = cs_to_sh_tmu(cs);\n\n\tif (!ch->cs_enabled)\n\t\treturn;\n\n\tif (--ch->enable_count == 0) {\n\t\t__sh_tmu_disable(ch);\n\t\tdev_pm_genpd_suspend(&ch->tmu->pdev->dev);\n\t}\n}\n\nstatic void sh_tmu_clocksource_resume(struct clocksource *cs)\n{\n\tstruct sh_tmu_channel *ch = cs_to_sh_tmu(cs);\n\n\tif (!ch->cs_enabled)\n\t\treturn;\n\n\tif (ch->enable_count++ == 0) {\n\t\tdev_pm_genpd_resume(&ch->tmu->pdev->dev);\n\t\t__sh_tmu_enable(ch);\n\t}\n}\n\nstatic int sh_tmu_register_clocksource(struct sh_tmu_channel *ch,\n\t\t\t\t       const char *name)\n{\n\tstruct clocksource *cs = &ch->cs;\n\n\tcs->name = name;\n\tcs->rating = 200;\n\tcs->read = sh_tmu_clocksource_read;\n\tcs->enable = sh_tmu_clocksource_enable;\n\tcs->disable = sh_tmu_clocksource_disable;\n\tcs->suspend = sh_tmu_clocksource_suspend;\n\tcs->resume = sh_tmu_clocksource_resume;\n\tcs->mask = CLOCKSOURCE_MASK(32);\n\tcs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\tdev_info(&ch->tmu->pdev->dev, \"ch%u: used as clock source\\n\",\n\t\t ch->index);\n\n\tclocksource_register_hz(cs, ch->tmu->rate);\n\treturn 0;\n}\n\nstatic struct sh_tmu_channel *ced_to_sh_tmu(struct clock_event_device *ced)\n{\n\treturn container_of(ced, struct sh_tmu_channel, ced);\n}\n\nstatic void sh_tmu_clock_event_start(struct sh_tmu_channel *ch, int periodic)\n{\n\tsh_tmu_enable(ch);\n\n\tif (periodic) {\n\t\tch->periodic = (ch->tmu->rate + HZ/2) / HZ;\n\t\tsh_tmu_set_next(ch, ch->periodic, 1);\n\t}\n}\n\nstatic int sh_tmu_clock_event_shutdown(struct clock_event_device *ced)\n{\n\tstruct sh_tmu_channel *ch = ced_to_sh_tmu(ced);\n\n\tif (clockevent_state_oneshot(ced) || clockevent_state_periodic(ced))\n\t\tsh_tmu_disable(ch);\n\treturn 0;\n}\n\nstatic int sh_tmu_clock_event_set_state(struct clock_event_device *ced,\n\t\t\t\t\tint periodic)\n{\n\tstruct sh_tmu_channel *ch = ced_to_sh_tmu(ced);\n\n\t \n\tif (clockevent_state_oneshot(ced) || clockevent_state_periodic(ced))\n\t\tsh_tmu_disable(ch);\n\n\tdev_info(&ch->tmu->pdev->dev, \"ch%u: used for %s clock events\\n\",\n\t\t ch->index, periodic ? \"periodic\" : \"oneshot\");\n\tsh_tmu_clock_event_start(ch, periodic);\n\treturn 0;\n}\n\nstatic int sh_tmu_clock_event_set_oneshot(struct clock_event_device *ced)\n{\n\treturn sh_tmu_clock_event_set_state(ced, 0);\n}\n\nstatic int sh_tmu_clock_event_set_periodic(struct clock_event_device *ced)\n{\n\treturn sh_tmu_clock_event_set_state(ced, 1);\n}\n\nstatic int sh_tmu_clock_event_next(unsigned long delta,\n\t\t\t\t   struct clock_event_device *ced)\n{\n\tstruct sh_tmu_channel *ch = ced_to_sh_tmu(ced);\n\n\tBUG_ON(!clockevent_state_oneshot(ced));\n\n\t \n\tsh_tmu_set_next(ch, delta, 0);\n\treturn 0;\n}\n\nstatic void sh_tmu_clock_event_suspend(struct clock_event_device *ced)\n{\n\tdev_pm_genpd_suspend(&ced_to_sh_tmu(ced)->tmu->pdev->dev);\n}\n\nstatic void sh_tmu_clock_event_resume(struct clock_event_device *ced)\n{\n\tdev_pm_genpd_resume(&ced_to_sh_tmu(ced)->tmu->pdev->dev);\n}\n\nstatic void sh_tmu_register_clockevent(struct sh_tmu_channel *ch,\n\t\t\t\t       const char *name)\n{\n\tstruct clock_event_device *ced = &ch->ced;\n\tint ret;\n\n\tced->name = name;\n\tced->features = CLOCK_EVT_FEAT_PERIODIC;\n\tced->features |= CLOCK_EVT_FEAT_ONESHOT;\n\tced->rating = 200;\n\tced->cpumask = cpu_possible_mask;\n\tced->set_next_event = sh_tmu_clock_event_next;\n\tced->set_state_shutdown = sh_tmu_clock_event_shutdown;\n\tced->set_state_periodic = sh_tmu_clock_event_set_periodic;\n\tced->set_state_oneshot = sh_tmu_clock_event_set_oneshot;\n\tced->suspend = sh_tmu_clock_event_suspend;\n\tced->resume = sh_tmu_clock_event_resume;\n\n\tdev_info(&ch->tmu->pdev->dev, \"ch%u: used for clock events\\n\",\n\t\t ch->index);\n\n\tclockevents_config_and_register(ced, ch->tmu->rate, 0x300, 0xffffffff);\n\n\tret = request_irq(ch->irq, sh_tmu_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\n\t\t\t  dev_name(&ch->tmu->pdev->dev), ch);\n\tif (ret) {\n\t\tdev_err(&ch->tmu->pdev->dev, \"ch%u: failed to request irq %d\\n\",\n\t\t\tch->index, ch->irq);\n\t\treturn;\n\t}\n}\n\nstatic int sh_tmu_register(struct sh_tmu_channel *ch, const char *name,\n\t\t\t   bool clockevent, bool clocksource)\n{\n\tif (clockevent) {\n\t\tch->tmu->has_clockevent = true;\n\t\tsh_tmu_register_clockevent(ch, name);\n\t} else if (clocksource) {\n\t\tch->tmu->has_clocksource = true;\n\t\tsh_tmu_register_clocksource(ch, name);\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_tmu_channel_setup(struct sh_tmu_channel *ch, unsigned int index,\n\t\t\t\tbool clockevent, bool clocksource,\n\t\t\t\tstruct sh_tmu_device *tmu)\n{\n\t \n\tif (!clockevent && !clocksource)\n\t\treturn 0;\n\n\tch->tmu = tmu;\n\tch->index = index;\n\n\tif (tmu->model == SH_TMU_SH3)\n\t\tch->base = tmu->mapbase + 4 + ch->index * 12;\n\telse\n\t\tch->base = tmu->mapbase + 8 + ch->index * 12;\n\n\tch->irq = platform_get_irq(tmu->pdev, index);\n\tif (ch->irq < 0)\n\t\treturn ch->irq;\n\n\tch->cs_enabled = false;\n\tch->enable_count = 0;\n\n\treturn sh_tmu_register(ch, dev_name(&tmu->pdev->dev),\n\t\t\t       clockevent, clocksource);\n}\n\nstatic int sh_tmu_map_memory(struct sh_tmu_device *tmu)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource(tmu->pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&tmu->pdev->dev, \"failed to get I/O memory\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\ttmu->mapbase = ioremap(res->start, resource_size(res));\n\tif (tmu->mapbase == NULL)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int sh_tmu_parse_dt(struct sh_tmu_device *tmu)\n{\n\tstruct device_node *np = tmu->pdev->dev.of_node;\n\n\ttmu->model = SH_TMU;\n\ttmu->num_channels = 3;\n\n\tof_property_read_u32(np, \"#renesas,channels\", &tmu->num_channels);\n\n\tif (tmu->num_channels != 2 && tmu->num_channels != 3) {\n\t\tdev_err(&tmu->pdev->dev, \"invalid number of channels %u\\n\",\n\t\t\ttmu->num_channels);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_tmu_setup(struct sh_tmu_device *tmu, struct platform_device *pdev)\n{\n\tunsigned int i;\n\tint ret;\n\n\ttmu->pdev = pdev;\n\n\traw_spin_lock_init(&tmu->lock);\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tret = sh_tmu_parse_dt(tmu);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (pdev->dev.platform_data) {\n\t\tconst struct platform_device_id *id = pdev->id_entry;\n\t\tstruct sh_timer_config *cfg = pdev->dev.platform_data;\n\n\t\ttmu->model = id->driver_data;\n\t\ttmu->num_channels = hweight8(cfg->channels_mask);\n\t} else {\n\t\tdev_err(&tmu->pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\ttmu->clk = clk_get(&tmu->pdev->dev, \"fck\");\n\tif (IS_ERR(tmu->clk)) {\n\t\tdev_err(&tmu->pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(tmu->clk);\n\t}\n\n\tret = clk_prepare(tmu->clk);\n\tif (ret < 0)\n\t\tgoto err_clk_put;\n\n\t \n\tret = clk_enable(tmu->clk);\n\tif (ret < 0)\n\t\tgoto err_clk_unprepare;\n\n\ttmu->rate = clk_get_rate(tmu->clk) / 4;\n\tclk_disable(tmu->clk);\n\n\t \n\tret = sh_tmu_map_memory(tmu);\n\tif (ret < 0) {\n\t\tdev_err(&tmu->pdev->dev, \"failed to remap I/O memory\\n\");\n\t\tgoto err_clk_unprepare;\n\t}\n\n\t \n\ttmu->channels = kcalloc(tmu->num_channels, sizeof(*tmu->channels),\n\t\t\t\tGFP_KERNEL);\n\tif (tmu->channels == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\tfor (i = 0; i < tmu->num_channels; ++i) {\n\t\tret = sh_tmu_channel_setup(&tmu->channels[i], i,\n\t\t\t\t\t   i == 0, i == 1, tmu);\n\t\tif (ret < 0)\n\t\t\tgoto err_unmap;\n\t}\n\n\tplatform_set_drvdata(pdev, tmu);\n\n\treturn 0;\n\nerr_unmap:\n\tkfree(tmu->channels);\n\tiounmap(tmu->mapbase);\nerr_clk_unprepare:\n\tclk_unprepare(tmu->clk);\nerr_clk_put:\n\tclk_put(tmu->clk);\n\treturn ret;\n}\n\nstatic int sh_tmu_probe(struct platform_device *pdev)\n{\n\tstruct sh_tmu_device *tmu = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (!is_sh_early_platform_device(pdev)) {\n\t\tpm_runtime_set_active(&pdev->dev);\n\t\tpm_runtime_enable(&pdev->dev);\n\t}\n\n\tif (tmu) {\n\t\tdev_info(&pdev->dev, \"kept as earlytimer\\n\");\n\t\tgoto out;\n\t}\n\n\ttmu = kzalloc(sizeof(*tmu), GFP_KERNEL);\n\tif (tmu == NULL)\n\t\treturn -ENOMEM;\n\n\tret = sh_tmu_setup(tmu, pdev);\n\tif (ret) {\n\t\tkfree(tmu);\n\t\tpm_runtime_idle(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tif (is_sh_early_platform_device(pdev))\n\t\treturn 0;\n\n out:\n\tif (tmu->has_clockevent || tmu->has_clocksource)\n\t\tpm_runtime_irq_safe(&pdev->dev);\n\telse\n\t\tpm_runtime_idle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sh_tmu_id_table[] = {\n\t{ \"sh-tmu\", SH_TMU },\n\t{ \"sh-tmu-sh3\", SH_TMU_SH3 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sh_tmu_id_table);\n\nstatic const struct of_device_id sh_tmu_of_table[] __maybe_unused = {\n\t{ .compatible = \"renesas,tmu\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sh_tmu_of_table);\n\nstatic struct platform_driver sh_tmu_device_driver = {\n\t.probe\t\t= sh_tmu_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sh_tmu\",\n\t\t.of_match_table = of_match_ptr(sh_tmu_of_table),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.id_table\t= sh_tmu_id_table,\n};\n\nstatic int __init sh_tmu_init(void)\n{\n\treturn platform_driver_register(&sh_tmu_device_driver);\n}\n\nstatic void __exit sh_tmu_exit(void)\n{\n\tplatform_driver_unregister(&sh_tmu_device_driver);\n}\n\n#ifdef CONFIG_SUPERH\nsh_early_platform_init(\"earlytimer\", &sh_tmu_device_driver);\n#endif\n\nsubsys_initcall(sh_tmu_init);\nmodule_exit(sh_tmu_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"SuperH TMU Timer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}