{
  "module_name": "timer-mediatek.c",
  "hash_id": "efcccea0c5ba2693fec31a23e5f405103d6c44226f9eae2f4657d978889982b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-mediatek.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include \"timer-of.h\"\n\n#define TIMER_CLK_EVT           (1)\n#define TIMER_CLK_SRC           (2)\n\n#define TIMER_SYNC_TICKS        (3)\n\n \n#define GPT_IRQ_EN_REG          0x00\n#define GPT_IRQ_ENABLE(val)     BIT((val) - 1)\n#define GPT_IRQ_ACK_REG\t        0x08\n#define GPT_IRQ_ACK(val)        BIT((val) - 1)\n\n#define GPT_CTRL_REG(val)       (0x10 * (val))\n#define GPT_CTRL_OP(val)        (((val) & 0x3) << 4)\n#define GPT_CTRL_OP_ONESHOT     (0)\n#define GPT_CTRL_OP_REPEAT      (1)\n#define GPT_CTRL_OP_FREERUN     (3)\n#define GPT_CTRL_CLEAR          (2)\n#define GPT_CTRL_ENABLE         (1)\n#define GPT_CTRL_DISABLE        (0)\n\n#define GPT_CLK_REG(val)        (0x04 + (0x10 * (val)))\n#define GPT_CLK_SRC(val)        (((val) & 0x1) << 4)\n#define GPT_CLK_SRC_SYS13M      (0)\n#define GPT_CLK_SRC_RTC32K      (1)\n#define GPT_CLK_DIV1            (0x0)\n#define GPT_CLK_DIV2            (0x1)\n\n#define GPT_CNT_REG(val)        (0x08 + (0x10 * (val)))\n#define GPT_CMP_REG(val)        (0x0C + (0x10 * (val)))\n\n \n#define SYST_BASE               (0x40)\n\n#define SYST_CON                (SYST_BASE + 0x0)\n#define SYST_VAL                (SYST_BASE + 0x4)\n\n#define SYST_CON_REG(to)        (timer_of_base(to) + SYST_CON)\n#define SYST_VAL_REG(to)        (timer_of_base(to) + SYST_VAL)\n\n \n#define SYST_CON_EN              BIT(0)\n#define SYST_CON_IRQ_EN          BIT(1)\n#define SYST_CON_IRQ_CLR         BIT(4)\n\nstatic void __iomem *gpt_sched_reg __read_mostly;\n\nstatic void mtk_syst_ack_irq(struct timer_of *to)\n{\n\t \n\twritel(SYST_CON_EN, SYST_CON_REG(to));\n\twritel(SYST_CON_IRQ_CLR | SYST_CON_EN, SYST_CON_REG(to));\n}\n\nstatic irqreturn_t mtk_syst_handler(int irq, void *dev_id)\n{\n\tstruct clock_event_device *clkevt = dev_id;\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tmtk_syst_ack_irq(to);\n\tclkevt->event_handler(clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_syst_clkevt_next_event(unsigned long ticks,\n\t\t\t\t      struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\t \n\twritel(SYST_CON_EN, SYST_CON_REG(to));\n\n\t \n\twritel(ticks, SYST_VAL_REG(to));\n\n\t \n\twritel(SYST_CON_EN | SYST_CON_IRQ_EN, SYST_CON_REG(to));\n\n\treturn 0;\n}\n\nstatic int mtk_syst_clkevt_shutdown(struct clock_event_device *clkevt)\n{\n\t \n\tmtk_syst_ack_irq(to_timer_of(clkevt));\n\n\t \n\twritel(0, SYST_CON_REG(to_timer_of(clkevt)));\n\n\treturn 0;\n}\n\nstatic int mtk_syst_clkevt_resume(struct clock_event_device *clkevt)\n{\n\treturn mtk_syst_clkevt_shutdown(clkevt);\n}\n\nstatic int mtk_syst_clkevt_oneshot(struct clock_event_device *clkevt)\n{\n\treturn 0;\n}\n\nstatic u64 notrace mtk_gpt_read_sched_clock(void)\n{\n\treturn readl_relaxed(gpt_sched_reg);\n}\n\nstatic void mtk_gpt_clkevt_time_stop(struct timer_of *to, u8 timer)\n{\n\tu32 val;\n\n\tval = readl(timer_of_base(to) + GPT_CTRL_REG(timer));\n\twritel(val & ~GPT_CTRL_ENABLE, timer_of_base(to) +\n\t       GPT_CTRL_REG(timer));\n}\n\nstatic void mtk_gpt_clkevt_time_setup(struct timer_of *to,\n\t\t\t\t      unsigned long delay, u8 timer)\n{\n\twritel(delay, timer_of_base(to) + GPT_CMP_REG(timer));\n}\n\nstatic void mtk_gpt_clkevt_time_start(struct timer_of *to,\n\t\t\t\t      bool periodic, u8 timer)\n{\n\tu32 val;\n\n\t \n\twritel(GPT_IRQ_ACK(timer), timer_of_base(to) + GPT_IRQ_ACK_REG);\n\n\tval = readl(timer_of_base(to) + GPT_CTRL_REG(timer));\n\n\t \n\tval &= ~GPT_CTRL_OP(0x3);\n\n\tif (periodic)\n\t\tval |= GPT_CTRL_OP(GPT_CTRL_OP_REPEAT);\n\telse\n\t\tval |= GPT_CTRL_OP(GPT_CTRL_OP_ONESHOT);\n\n\twritel(val | GPT_CTRL_ENABLE | GPT_CTRL_CLEAR,\n\t       timer_of_base(to) + GPT_CTRL_REG(timer));\n}\n\nstatic int mtk_gpt_clkevt_shutdown(struct clock_event_device *clk)\n{\n\tmtk_gpt_clkevt_time_stop(to_timer_of(clk), TIMER_CLK_EVT);\n\n\treturn 0;\n}\n\nstatic int mtk_gpt_clkevt_set_periodic(struct clock_event_device *clk)\n{\n\tstruct timer_of *to = to_timer_of(clk);\n\n\tmtk_gpt_clkevt_time_stop(to, TIMER_CLK_EVT);\n\tmtk_gpt_clkevt_time_setup(to, to->of_clk.period, TIMER_CLK_EVT);\n\tmtk_gpt_clkevt_time_start(to, true, TIMER_CLK_EVT);\n\n\treturn 0;\n}\n\nstatic int mtk_gpt_clkevt_next_event(unsigned long event,\n\t\t\t\t     struct clock_event_device *clk)\n{\n\tstruct timer_of *to = to_timer_of(clk);\n\n\tmtk_gpt_clkevt_time_stop(to, TIMER_CLK_EVT);\n\tmtk_gpt_clkevt_time_setup(to, event, TIMER_CLK_EVT);\n\tmtk_gpt_clkevt_time_start(to, false, TIMER_CLK_EVT);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mtk_gpt_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *clkevt = (struct clock_event_device *)dev_id;\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\t \n\twritel(GPT_IRQ_ACK(TIMER_CLK_EVT), timer_of_base(to) + GPT_IRQ_ACK_REG);\n\tclkevt->event_handler(clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\n__init mtk_gpt_setup(struct timer_of *to, u8 timer, u8 option)\n{\n\twritel(GPT_CTRL_CLEAR | GPT_CTRL_DISABLE,\n\t       timer_of_base(to) + GPT_CTRL_REG(timer));\n\n\twritel(GPT_CLK_SRC(GPT_CLK_SRC_SYS13M) | GPT_CLK_DIV1,\n\t       timer_of_base(to) + GPT_CLK_REG(timer));\n\n\twritel(0x0, timer_of_base(to) + GPT_CMP_REG(timer));\n\n\twritel(GPT_CTRL_OP(option) | GPT_CTRL_ENABLE,\n\t       timer_of_base(to) + GPT_CTRL_REG(timer));\n}\n\nstatic void mtk_gpt_enable_irq(struct timer_of *to, u8 timer)\n{\n\tu32 val;\n\n\t \n\twritel(0x0, timer_of_base(to) + GPT_IRQ_EN_REG);\n\n\t \n\twritel(0x3f, timer_of_base(to) + GPT_IRQ_ACK_REG);\n\n\tval = readl(timer_of_base(to) + GPT_IRQ_EN_REG);\n\twritel(val | GPT_IRQ_ENABLE(timer),\n\t       timer_of_base(to) + GPT_IRQ_EN_REG);\n}\n\nstatic void mtk_gpt_resume(struct clock_event_device *clk)\n{\n\tstruct timer_of *to = to_timer_of(clk);\n\n\tmtk_gpt_enable_irq(to, TIMER_CLK_EVT);\n}\n\nstatic void mtk_gpt_suspend(struct clock_event_device *clk)\n{\n\tstruct timer_of *to = to_timer_of(clk);\n\n\t \n\twritel(0x0, timer_of_base(to) + GPT_IRQ_EN_REG);\n\n\t \n\twritel(0x3f, timer_of_base(to) + GPT_IRQ_ACK_REG);\n}\n\nstatic struct timer_of to = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK,\n\n\t.clkevt = {\n\t\t.name = \"mtk-clkevt\",\n\t\t.rating = 300,\n\t\t.cpumask = cpu_possible_mask,\n\t},\n\n\t.of_irq = {\n\t\t.flags = IRQF_TIMER | IRQF_IRQPOLL,\n\t},\n};\n\nstatic int __init mtk_syst_init(struct device_node *node)\n{\n\tint ret;\n\n\tto.clkevt.features = CLOCK_EVT_FEAT_DYNIRQ | CLOCK_EVT_FEAT_ONESHOT;\n\tto.clkevt.set_state_shutdown = mtk_syst_clkevt_shutdown;\n\tto.clkevt.set_state_oneshot = mtk_syst_clkevt_oneshot;\n\tto.clkevt.tick_resume = mtk_syst_clkevt_resume;\n\tto.clkevt.set_next_event = mtk_syst_clkevt_next_event;\n\tto.of_irq.handler = mtk_syst_handler;\n\n\tret = timer_of_init(node, &to);\n\tif (ret)\n\t\treturn ret;\n\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to),\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\n\treturn 0;\n}\n\nstatic int __init mtk_gpt_init(struct device_node *node)\n{\n\tint ret;\n\n\tto.clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tto.clkevt.set_state_shutdown = mtk_gpt_clkevt_shutdown;\n\tto.clkevt.set_state_periodic = mtk_gpt_clkevt_set_periodic;\n\tto.clkevt.set_state_oneshot = mtk_gpt_clkevt_shutdown;\n\tto.clkevt.tick_resume = mtk_gpt_clkevt_shutdown;\n\tto.clkevt.set_next_event = mtk_gpt_clkevt_next_event;\n\tto.clkevt.suspend = mtk_gpt_suspend;\n\tto.clkevt.resume = mtk_gpt_resume;\n\tto.of_irq.handler = mtk_gpt_interrupt;\n\n\tret = timer_of_init(node, &to);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmtk_gpt_setup(&to, TIMER_CLK_SRC, GPT_CTRL_OP_FREERUN);\n\tclocksource_mmio_init(timer_of_base(&to) + GPT_CNT_REG(TIMER_CLK_SRC),\n\t\t\t      node->name, timer_of_rate(&to), 300, 32,\n\t\t\t      clocksource_mmio_readl_up);\n\tgpt_sched_reg = timer_of_base(&to) + GPT_CNT_REG(TIMER_CLK_SRC);\n\tsched_clock_register(mtk_gpt_read_sched_clock, 32, timer_of_rate(&to));\n\n\t \n\tmtk_gpt_setup(&to, TIMER_CLK_EVT, GPT_CTRL_OP_REPEAT);\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to),\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\n\tmtk_gpt_enable_irq(&to, TIMER_CLK_EVT);\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(mtk_mt6577, \"mediatek,mt6577-timer\", mtk_gpt_init);\nTIMER_OF_DECLARE(mtk_mt6765, \"mediatek,mt6765-timer\", mtk_syst_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}