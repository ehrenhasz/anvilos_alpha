{
  "module_name": "jcore-pit.c",
  "hash_id": "9e809751037812a3806064ee4c7930c3580b4e08af44379d1a58f995a07582c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/jcore-pit.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/sched_clock.h>\n#include <linux/cpu.h>\n#include <linux/cpuhotplug.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define PIT_IRQ_SHIFT\t\t12\n#define PIT_PRIO_SHIFT\t\t20\n#define PIT_ENABLE_SHIFT\t26\n#define PIT_PRIO_MASK\t\t0xf\n\n#define REG_PITEN\t\t0x00\n#define REG_THROT\t\t0x10\n#define REG_COUNT\t\t0x14\n#define REG_BUSPD\t\t0x18\n#define REG_SECHI\t\t0x20\n#define REG_SECLO\t\t0x24\n#define REG_NSEC\t\t0x28\n\nstruct jcore_pit {\n\tstruct clock_event_device\tced;\n\tvoid __iomem\t\t\t*base;\n\tunsigned long\t\t\tperiodic_delta;\n\tu32\t\t\t\tenable_val;\n};\n\nstatic void __iomem *jcore_pit_base;\nstatic struct jcore_pit __percpu *jcore_pit_percpu;\n\nstatic notrace u64 jcore_sched_clock_read(void)\n{\n\tu32 seclo, nsec, seclo0;\n\t__iomem void *base = jcore_pit_base;\n\n\tseclo = readl(base + REG_SECLO);\n\tdo {\n\t\tseclo0 = seclo;\n\t\tnsec  = readl(base + REG_NSEC);\n\t\tseclo = readl(base + REG_SECLO);\n\t} while (seclo0 != seclo);\n\n\treturn seclo * NSEC_PER_SEC + nsec;\n}\n\nstatic u64 jcore_clocksource_read(struct clocksource *cs)\n{\n\treturn jcore_sched_clock_read();\n}\n\nstatic int jcore_pit_disable(struct jcore_pit *pit)\n{\n\twritel(0, pit->base + REG_PITEN);\n\treturn 0;\n}\n\nstatic int jcore_pit_set(unsigned long delta, struct jcore_pit *pit)\n{\n\tjcore_pit_disable(pit);\n\twritel(delta, pit->base + REG_THROT);\n\twritel(pit->enable_val, pit->base + REG_PITEN);\n\treturn 0;\n}\n\nstatic int jcore_pit_set_state_shutdown(struct clock_event_device *ced)\n{\n\tstruct jcore_pit *pit = container_of(ced, struct jcore_pit, ced);\n\n\treturn jcore_pit_disable(pit);\n}\n\nstatic int jcore_pit_set_state_oneshot(struct clock_event_device *ced)\n{\n\tstruct jcore_pit *pit = container_of(ced, struct jcore_pit, ced);\n\n\treturn jcore_pit_disable(pit);\n}\n\nstatic int jcore_pit_set_state_periodic(struct clock_event_device *ced)\n{\n\tstruct jcore_pit *pit = container_of(ced, struct jcore_pit, ced);\n\n\treturn jcore_pit_set(pit->periodic_delta, pit);\n}\n\nstatic int jcore_pit_set_next_event(unsigned long delta,\n\t\t\t\t    struct clock_event_device *ced)\n{\n\tstruct jcore_pit *pit = container_of(ced, struct jcore_pit, ced);\n\n\treturn jcore_pit_set(delta, pit);\n}\n\nstatic int jcore_pit_local_init(unsigned cpu)\n{\n\tstruct jcore_pit *pit = this_cpu_ptr(jcore_pit_percpu);\n\tunsigned buspd, freq;\n\n\tpr_info(\"Local J-Core PIT init on cpu %u\\n\", cpu);\n\n\tbuspd = readl(pit->base + REG_BUSPD);\n\tfreq = DIV_ROUND_CLOSEST(NSEC_PER_SEC, buspd);\n\tpit->periodic_delta = DIV_ROUND_CLOSEST(NSEC_PER_SEC, HZ * buspd);\n\n\tclockevents_config_and_register(&pit->ced, freq, 1, ULONG_MAX);\n\n\treturn 0;\n}\n\nstatic irqreturn_t jcore_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct jcore_pit *pit = this_cpu_ptr(dev_id);\n\n\tif (clockevent_state_oneshot(&pit->ced))\n\t\tjcore_pit_disable(pit);\n\n\tpit->ced.event_handler(&pit->ced);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init jcore_pit_init(struct device_node *node)\n{\n\tint err;\n\tunsigned pit_irq, cpu;\n\tunsigned long hwirq;\n\tu32 irqprio, enable_val;\n\n\tjcore_pit_base = of_iomap(node, 0);\n\tif (!jcore_pit_base) {\n\t\tpr_err(\"Error: Cannot map base address for J-Core PIT\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpit_irq = irq_of_parse_and_map(node, 0);\n\tif (!pit_irq) {\n\t\tpr_err(\"Error: J-Core PIT has no IRQ\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpr_info(\"Initializing J-Core PIT at %p IRQ %d\\n\",\n\t\tjcore_pit_base, pit_irq);\n\n\terr = clocksource_mmio_init(jcore_pit_base, \"jcore_pit_cs\",\n\t\t\t\t    NSEC_PER_SEC, 400, 32,\n\t\t\t\t    jcore_clocksource_read);\n\tif (err) {\n\t\tpr_err(\"Error registering clocksource device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tsched_clock_register(jcore_sched_clock_read, 32, NSEC_PER_SEC);\n\n\tjcore_pit_percpu = alloc_percpu(struct jcore_pit);\n\tif (!jcore_pit_percpu) {\n\t\tpr_err(\"Failed to allocate memory for clock event device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = request_irq(pit_irq, jcore_timer_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_PERCPU,\n\t\t\t  \"jcore_pit\", jcore_pit_percpu);\n\tif (err) {\n\t\tpr_err(\"pit irq request failed: %d\\n\", err);\n\t\tfree_percpu(jcore_pit_percpu);\n\t\treturn err;\n\t}\n\n\t \n\thwirq = irq_get_irq_data(pit_irq)->hwirq;\n\tirqprio = (hwirq >> 2) & PIT_PRIO_MASK;\n\tenable_val = (1U << PIT_ENABLE_SHIFT)\n\t\t   | (hwirq << PIT_IRQ_SHIFT)\n\t\t   | (irqprio << PIT_PRIO_SHIFT);\n\n\tfor_each_present_cpu(cpu) {\n\t\tstruct jcore_pit *pit = per_cpu_ptr(jcore_pit_percpu, cpu);\n\n\t\tpit->base = of_iomap(node, cpu);\n\t\tif (!pit->base) {\n\t\t\tpr_err(\"Unable to map PIT for cpu %u\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpit->ced.name = \"jcore_pit\";\n\t\tpit->ced.features = CLOCK_EVT_FEAT_PERIODIC\n\t\t\t\t  | CLOCK_EVT_FEAT_ONESHOT\n\t\t\t\t  | CLOCK_EVT_FEAT_PERCPU;\n\t\tpit->ced.cpumask = cpumask_of(cpu);\n\t\tpit->ced.rating = 400;\n\t\tpit->ced.irq = pit_irq;\n\t\tpit->ced.set_state_shutdown = jcore_pit_set_state_shutdown;\n\t\tpit->ced.set_state_periodic = jcore_pit_set_state_periodic;\n\t\tpit->ced.set_state_oneshot = jcore_pit_set_state_oneshot;\n\t\tpit->ced.set_next_event = jcore_pit_set_next_event;\n\n\t\tpit->enable_val = enable_val;\n\t}\n\n\tcpuhp_setup_state(CPUHP_AP_JCORE_TIMER_STARTING,\n\t\t\t  \"clockevents/jcore:starting\",\n\t\t\t  jcore_pit_local_init, NULL);\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(jcore_pit, \"jcore,pit\", jcore_pit_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}