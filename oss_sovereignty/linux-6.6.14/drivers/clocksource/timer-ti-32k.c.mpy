{
  "module_name": "timer-ti-32k.c",
  "hash_id": "54687a0fdbd12671c86f1d7edd62e3866cd565f6d313fd0cb04e87e998d1a03e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-ti-32k.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/sched_clock.h>\n#include <linux/clocksource.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n \n\n#define OMAP2_32KSYNCNT_REV_OFF\t\t0x0\n#define OMAP2_32KSYNCNT_REV_SCHEME\t(0x3 << 30)\n#define OMAP2_32KSYNCNT_CR_OFF_LOW\t0x10\n#define OMAP2_32KSYNCNT_CR_OFF_HIGH\t0x30\n\nstruct ti_32k {\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*counter;\n\tstruct clocksource\tcs;\n};\n\nstatic inline struct ti_32k *to_ti_32k(struct clocksource *cs)\n{\n\treturn container_of(cs, struct ti_32k, cs);\n}\n\nstatic u64 notrace ti_32k_read_cycles(struct clocksource *cs)\n{\n\tstruct ti_32k *ti = to_ti_32k(cs);\n\n\treturn (u64)readl_relaxed(ti->counter);\n}\n\nstatic struct ti_32k ti_32k_timer = {\n\t.cs = {\n\t\t.name\t\t= \"32k_counter\",\n\t\t.rating\t\t= 250,\n\t\t.read\t\t= ti_32k_read_cycles,\n\t\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t},\n};\n\nstatic u64 notrace omap_32k_read_sched_clock(void)\n{\n\treturn ti_32k_read_cycles(&ti_32k_timer.cs);\n}\n\nstatic void __init ti_32k_timer_enable_clock(struct device_node *np,\n\t\t\t\t\t     const char *name)\n{\n\tstruct clk *clock;\n\tint error;\n\n\tclock = of_clk_get_by_name(np->parent, name);\n\tif (IS_ERR(clock)) {\n\t\t \n\t\tif (PTR_ERR(clock) == -EINVAL && !strncmp(\"ick\", name, 3))\n\t\t\treturn;\n\n\t\tpr_warn(\"%s: could not get clock %s %li\\n\",\n\t\t\t__func__, name, PTR_ERR(clock));\n\t\treturn;\n\t}\n\n\terror = clk_prepare_enable(clock);\n\tif (error) {\n\t\tpr_warn(\"%s: could not enable %s: %i\\n\",\n\t\t\t__func__, name, error);\n\t\treturn;\n\t}\n}\n\nstatic void __init ti_32k_timer_module_init(struct device_node *np,\n\t\t\t\t\t    void __iomem *base)\n{\n\tvoid __iomem *sysc = base + 4;\n\n\tif (!of_device_is_compatible(np->parent, \"ti,sysc\"))\n\t\treturn;\n\n\tti_32k_timer_enable_clock(np, \"fck\");\n\tti_32k_timer_enable_clock(np, \"ick\");\n\n\t \n\twritel_relaxed(0, sysc);\n}\n\nstatic int __init ti_32k_timer_init(struct device_node *np)\n{\n\tint ret;\n\n\tti_32k_timer.base = of_iomap(np, 0);\n\tif (!ti_32k_timer.base) {\n\t\tpr_err(\"Can't ioremap 32k timer base\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!of_machine_is_compatible(\"ti,am43\"))\n\t\tti_32k_timer.cs.flags |= CLOCK_SOURCE_SUSPEND_NONSTOP;\n\n\tti_32k_timer.counter = ti_32k_timer.base;\n\tti_32k_timer_module_init(np, ti_32k_timer.base);\n\n\t \n\tif (readl_relaxed(ti_32k_timer.base + OMAP2_32KSYNCNT_REV_OFF) &\n\t\t\tOMAP2_32KSYNCNT_REV_SCHEME)\n\t\tti_32k_timer.counter += OMAP2_32KSYNCNT_CR_OFF_HIGH;\n\telse\n\t\tti_32k_timer.counter += OMAP2_32KSYNCNT_CR_OFF_LOW;\n\n\tpr_info(\"OMAP clocksource: 32k_counter at 32768 Hz\\n\");\n\n\tret = clocksource_register_hz(&ti_32k_timer.cs, 32768);\n\tif (ret) {\n\t\tpr_err(\"32k_counter: can't register clocksource\\n\");\n\t\treturn ret;\n\t}\n\n\tsched_clock_register(omap_32k_read_sched_clock, 32, 32768);\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(ti_32k_timer, \"ti,omap-counter32k\",\n\t\tti_32k_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}