{
  "module_name": "timer-ti-dm-systimer.c",
  "hash_id": "aae09e283c516ab50e1a1b42a34adbbef2ed3f9116440e180870221fdd04a056",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-ti-dm-systimer.c",
  "human_readable_source": "\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#include <linux/clk/clk-conf.h>\n\n#include <clocksource/timer-ti-dm.h>\n#include <dt-bindings/bus/ti-sysc.h>\n\n \n#define DMTIMER_TYPE1_ENABLE\t((1 << 9) | (SYSC_IDLE_SMART << 3) | \\\n\t\t\t\t SYSC_OMAP2_ENAWAKEUP | SYSC_OMAP2_AUTOIDLE)\n#define DMTIMER_TYPE1_DISABLE\t(SYSC_OMAP2_SOFTRESET | SYSC_OMAP2_AUTOIDLE)\n#define DMTIMER_TYPE2_ENABLE\t(SYSC_IDLE_SMART_WKUP << 2)\n#define DMTIMER_RESET_WAIT\t100000\n\n#define DMTIMER_INST_DONT_CARE\t~0U\n\nstatic int counter_32k;\nstatic u32 clocksource;\nstatic u32 clockevent;\n\n \nstruct dmtimer_systimer {\n\tvoid __iomem *base;\n\tu8 sysc;\n\tu8 irq_stat;\n\tu8 irq_ena;\n\tu8 pend;\n\tu8 load;\n\tu8 counter;\n\tu8 ctrl;\n\tu8 wakeup;\n\tu8 ifctrl;\n\tstruct clk *fck;\n\tstruct clk *ick;\n\tunsigned long rate;\n};\n\nstruct dmtimer_clockevent {\n\tstruct clock_event_device dev;\n\tstruct dmtimer_systimer t;\n\tu32 period;\n};\n\nstruct dmtimer_clocksource {\n\tstruct clocksource dev;\n\tstruct dmtimer_systimer t;\n\tunsigned int loadval;\n};\n\n \nstatic bool dmtimer_systimer_revision1(struct dmtimer_systimer *t)\n{\n\tu32 tidr = readl_relaxed(t->base);\n\n\treturn !(tidr >> 16);\n}\n\nstatic void dmtimer_systimer_enable(struct dmtimer_systimer *t)\n{\n\tu32 val;\n\n\tif (dmtimer_systimer_revision1(t))\n\t\tval = DMTIMER_TYPE1_ENABLE;\n\telse\n\t\tval = DMTIMER_TYPE2_ENABLE;\n\n\twritel_relaxed(val, t->base + t->sysc);\n}\n\nstatic void dmtimer_systimer_disable(struct dmtimer_systimer *t)\n{\n\tif (!dmtimer_systimer_revision1(t))\n\t\treturn;\n\n\twritel_relaxed(DMTIMER_TYPE1_DISABLE, t->base + t->sysc);\n}\n\nstatic int __init dmtimer_systimer_type1_reset(struct dmtimer_systimer *t)\n{\n\tvoid __iomem *syss = t->base + OMAP_TIMER_V1_SYS_STAT_OFFSET;\n\tint ret;\n\tu32 l;\n\n\tdmtimer_systimer_enable(t);\n\twritel_relaxed(BIT(1) | BIT(2), t->base + t->ifctrl);\n\tret = readl_poll_timeout_atomic(syss, l, l & BIT(0), 100,\n\t\t\t\t\tDMTIMER_RESET_WAIT);\n\n\treturn ret;\n}\n\n \nstatic int __init dmtimer_systimer_type2_reset(struct dmtimer_systimer *t)\n{\n\tvoid __iomem *sysc = t->base + t->sysc;\n\tu32 l;\n\n\tdmtimer_systimer_enable(t);\n\tl = readl_relaxed(sysc);\n\tl |= BIT(0);\n\twritel_relaxed(l, sysc);\n\n\treturn readl_poll_timeout_atomic(sysc, l, !(l & BIT(0)), 100,\n\t\t\t\t\t DMTIMER_RESET_WAIT);\n}\n\nstatic int __init dmtimer_systimer_reset(struct dmtimer_systimer *t)\n{\n\tint ret;\n\n\tif (dmtimer_systimer_revision1(t))\n\t\tret = dmtimer_systimer_type1_reset(t);\n\telse\n\t\tret = dmtimer_systimer_type2_reset(t);\n\tif (ret < 0) {\n\t\tpr_err(\"%s failed with %i\\n\", __func__, ret);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id counter_match_table[] = {\n\t{ .compatible = \"ti,omap-counter32k\" },\n\t{   },\n};\n\n \nstatic void __init dmtimer_systimer_check_counter32k(void)\n{\n\tstruct device_node *np;\n\n\tif (counter_32k)\n\t\treturn;\n\n\tnp = of_find_matching_node(NULL, counter_match_table);\n\tif (!np) {\n\t\tcounter_32k = -ENODEV;\n\n\t\treturn;\n\t}\n\n\tif (of_device_is_available(np))\n\t\tcounter_32k = 1;\n\telse\n\t\tcounter_32k = -ENODEV;\n\n\tof_node_put(np);\n}\n\nstatic const struct of_device_id dmtimer_match_table[] = {\n\t{ .compatible = \"ti,omap2420-timer\", },\n\t{ .compatible = \"ti,omap3430-timer\", },\n\t{ .compatible = \"ti,omap4430-timer\", },\n\t{ .compatible = \"ti,omap5430-timer\", },\n\t{ .compatible = \"ti,am335x-timer\", },\n\t{ .compatible = \"ti,am335x-timer-1ms\", },\n\t{ .compatible = \"ti,dm814-timer\", },\n\t{ .compatible = \"ti,dm816-timer\", },\n\t{   },\n};\n\n \nstatic bool __init dmtimer_is_preferred(struct device_node *np)\n{\n\tif (!of_device_is_available(np))\n\t\treturn false;\n\n\tif (!of_property_read_bool(np->parent,\n\t\t\t\t   \"ti,no-reset-on-init\"))\n\t\treturn false;\n\n\tif (!of_property_read_bool(np->parent, \"ti,no-idle\"))\n\t\treturn false;\n\n\t \n\tif (!of_property_read_bool(np, \"ti,timer-secure\")) {\n\t\tif (!of_property_read_bool(np, \"assigned-clocks\"))\n\t\t\treturn false;\n\n\t\tif (!of_property_read_bool(np, \"assigned-clock-parents\"))\n\t\t\treturn false;\n\t}\n\n\tif (of_property_read_bool(np, \"ti,timer-dsp\"))\n\t\treturn false;\n\n\tif (of_property_read_bool(np, \"ti,timer-pwm\"))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void __init dmtimer_systimer_assign_alwon(void)\n{\n\tstruct device_node *np;\n\tu32 pa = 0;\n\tbool quirk_unreliable_oscillator = false;\n\n\t \n\tif (of_machine_is_compatible(\"ti,omap3-beagle-ab4\")) {\n\t\tquirk_unreliable_oscillator = true;\n\t\tcounter_32k = -ENODEV;\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"ti,am43\"))\n\t\tcounter_32k = -ENODEV;\n\n\tfor_each_matching_node(np, dmtimer_match_table) {\n\t\tstruct resource res;\n\t\tif (!dmtimer_is_preferred(np))\n\t\t\tcontinue;\n\n\t\tif (!of_property_read_bool(np, \"ti,timer-alwon\"))\n\t\t\tcontinue;\n\n\t\tif (of_address_to_resource(np, 0, &res))\n\t\t\tcontinue;\n\n\t\tpa = res.start;\n\n\t\t \n\t\tif (quirk_unreliable_oscillator && pa == 0x48318000)\n\t\t\tcontinue;\n\n\t\tof_node_put(np);\n\t\tbreak;\n\t}\n\n\t \n\tif (counter_32k >= 0) {\n\t\tclockevent = pa;\n\t\tclocksource = 0;\n\t} else {\n\t\tclocksource = pa;\n\t\tclockevent = DMTIMER_INST_DONT_CARE;\n\t}\n}\n\n \nstatic u32 __init dmtimer_systimer_find_first_available(void)\n{\n\tstruct device_node *np;\n\tu32 pa = 0;\n\n\tfor_each_matching_node(np, dmtimer_match_table) {\n\t\tstruct resource res;\n\t\tif (!dmtimer_is_preferred(np))\n\t\t\tcontinue;\n\n\t\tif (of_address_to_resource(np, 0, &res))\n\t\t\tcontinue;\n\n\t\tif (res.start == clocksource || res.start == clockevent)\n\t\t\tcontinue;\n\n\t\tpa = res.start;\n\t\tof_node_put(np);\n\t\tbreak;\n\t}\n\n\treturn pa;\n}\n\n \nstatic void __init dmtimer_systimer_select_best(void)\n{\n\tdmtimer_systimer_check_counter32k();\n\tdmtimer_systimer_assign_alwon();\n\n\tif (clockevent == DMTIMER_INST_DONT_CARE)\n\t\tclockevent = dmtimer_systimer_find_first_available();\n\n\tpr_debug(\"%s: counter_32k: %i clocksource: %08x clockevent: %08x\\n\",\n\t\t __func__, counter_32k, clocksource, clockevent);\n}\n\n \nstatic int __init dmtimer_systimer_init_clock(struct dmtimer_systimer *t,\n\t\t\t\t\t      struct device_node *np,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      unsigned long *rate)\n{\n\tstruct clk *clock;\n\tunsigned long r;\n\tbool is_ick = false;\n\tint error;\n\n\tis_ick = !strncmp(name, \"ick\", 3);\n\n\tclock = of_clk_get_by_name(np, name);\n\tif ((PTR_ERR(clock) == -EINVAL) && is_ick)\n\t\treturn 0;\n\telse if (IS_ERR(clock))\n\t\treturn PTR_ERR(clock);\n\n\terror = clk_prepare_enable(clock);\n\tif (error)\n\t\treturn error;\n\n\tr = clk_get_rate(clock);\n\tif (!r) {\n\t\tclk_disable_unprepare(clock);\n\t\treturn -ENODEV;\n\t}\n\n\tif (is_ick)\n\t\tt->ick = clock;\n\telse\n\t\tt->fck = clock;\n\n\t*rate = r;\n\n\treturn 0;\n}\n\nstatic int __init dmtimer_systimer_setup(struct device_node *np,\n\t\t\t\t\t struct dmtimer_systimer *t)\n{\n\tunsigned long rate;\n\tu8 regbase;\n\tint error;\n\n\tif (!of_device_is_compatible(np->parent, \"ti,sysc\"))\n\t\treturn -EINVAL;\n\n\tt->base = of_iomap(np, 0);\n\tif (!t->base)\n\t\treturn -ENXIO;\n\n\t \n\terror = of_clk_set_defaults(np, false);\n\tif (error < 0)\n\t\tpr_err(\"%s: clock source init failed: %i\\n\", __func__, error);\n\n\t \n\terror = dmtimer_systimer_init_clock(t, np->parent, \"fck\", &rate);\n\tif (error)\n\t\tgoto err_unmap;\n\n\tt->rate = rate;\n\n\terror = dmtimer_systimer_init_clock(t, np->parent, \"ick\", &rate);\n\tif (error)\n\t\tgoto err_unmap;\n\n\tif (dmtimer_systimer_revision1(t)) {\n\t\tt->irq_stat = OMAP_TIMER_V1_STAT_OFFSET;\n\t\tt->irq_ena = OMAP_TIMER_V1_INT_EN_OFFSET;\n\t\tt->pend = _OMAP_TIMER_WRITE_PEND_OFFSET;\n\t\tregbase = 0;\n\t} else {\n\t\tt->irq_stat = OMAP_TIMER_V2_IRQSTATUS;\n\t\tt->irq_ena = OMAP_TIMER_V2_IRQENABLE_SET;\n\t\tregbase = OMAP_TIMER_V2_FUNC_OFFSET;\n\t\tt->pend = regbase + _OMAP_TIMER_WRITE_PEND_OFFSET;\n\t}\n\n\tt->sysc = OMAP_TIMER_OCP_CFG_OFFSET;\n\tt->load = regbase + _OMAP_TIMER_LOAD_OFFSET;\n\tt->counter = regbase + _OMAP_TIMER_COUNTER_OFFSET;\n\tt->ctrl = regbase + _OMAP_TIMER_CTRL_OFFSET;\n\tt->wakeup = regbase + _OMAP_TIMER_WAKEUP_EN_OFFSET;\n\tt->ifctrl = regbase + _OMAP_TIMER_IF_CTRL_OFFSET;\n\n\tdmtimer_systimer_reset(t);\n\tdmtimer_systimer_enable(t);\n\tpr_debug(\"dmtimer rev %08x sysc %08x\\n\", readl_relaxed(t->base),\n\t\t readl_relaxed(t->base + t->sysc));\n\n\treturn 0;\n\nerr_unmap:\n\tiounmap(t->base);\n\n\treturn error;\n}\n\n \nstatic struct dmtimer_clockevent *\nto_dmtimer_clockevent(struct clock_event_device *clockevent)\n{\n\treturn container_of(clockevent, struct dmtimer_clockevent, dev);\n}\n\nstatic irqreturn_t dmtimer_clockevent_interrupt(int irq, void *data)\n{\n\tstruct dmtimer_clockevent *clkevt = data;\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->irq_stat);\n\tclkevt->dev.event_handler(&clkevt->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dmtimer_set_next_event(unsigned long cycles,\n\t\t\t\t  struct clock_event_device *evt)\n{\n\tstruct dmtimer_clockevent *clkevt = to_dmtimer_clockevent(evt);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\tvoid __iomem *pend = t->base + t->pend;\n\n\twhile (readl_relaxed(pend) & WP_TCRR)\n\t\tcpu_relax();\n\twritel_relaxed(0xffffffff - cycles, t->base + t->counter);\n\n\twhile (readl_relaxed(pend) & WP_TCLR)\n\t\tcpu_relax();\n\twritel_relaxed(OMAP_TIMER_CTRL_ST, t->base + t->ctrl);\n\n\treturn 0;\n}\n\nstatic int dmtimer_clockevent_shutdown(struct clock_event_device *evt)\n{\n\tstruct dmtimer_clockevent *clkevt = to_dmtimer_clockevent(evt);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\tvoid __iomem *ctrl = t->base + t->ctrl;\n\tu32 l;\n\n\tl = readl_relaxed(ctrl);\n\tif (l & OMAP_TIMER_CTRL_ST) {\n\t\tl &= ~BIT(0);\n\t\twritel_relaxed(l, ctrl);\n\t\t \n\t\tl = readl_relaxed(ctrl);\n\t\t \n\t\tudelay(3500000 / t->rate + 1);\n\t}\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->irq_stat);\n\n\treturn 0;\n}\n\nstatic int dmtimer_set_periodic(struct clock_event_device *evt)\n{\n\tstruct dmtimer_clockevent *clkevt = to_dmtimer_clockevent(evt);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\tvoid __iomem *pend = t->base + t->pend;\n\n\tdmtimer_clockevent_shutdown(evt);\n\n\t \n\twhile (readl_relaxed(pend) & WP_TLDR)\n\t\tcpu_relax();\n\twritel_relaxed(clkevt->period, t->base + t->load);\n\n\twhile (readl_relaxed(pend) & WP_TCRR)\n\t\tcpu_relax();\n\twritel_relaxed(clkevt->period, t->base + t->counter);\n\n\twhile (readl_relaxed(pend) & WP_TCLR)\n\t\tcpu_relax();\n\twritel_relaxed(OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,\n\t\t       t->base + t->ctrl);\n\n\treturn 0;\n}\n\nstatic void omap_clockevent_idle(struct clock_event_device *evt)\n{\n\tstruct dmtimer_clockevent *clkevt = to_dmtimer_clockevent(evt);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\n\tdmtimer_systimer_disable(t);\n\tclk_disable(t->fck);\n}\n\nstatic void omap_clockevent_unidle(struct clock_event_device *evt)\n{\n\tstruct dmtimer_clockevent *clkevt = to_dmtimer_clockevent(evt);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\tint error;\n\n\terror = clk_enable(t->fck);\n\tif (error)\n\t\tpr_err(\"could not enable timer fck on resume: %i\\n\", error);\n\n\tdmtimer_systimer_enable(t);\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->irq_ena);\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->wakeup);\n}\n\nstatic int __init dmtimer_clkevt_init_common(struct dmtimer_clockevent *clkevt,\n\t\t\t\t\t     struct device_node *np,\n\t\t\t\t\t     unsigned int features,\n\t\t\t\t\t     const struct cpumask *cpumask,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     int rating)\n{\n\tstruct clock_event_device *dev;\n\tstruct dmtimer_systimer *t;\n\tint error;\n\n\tt = &clkevt->t;\n\tdev = &clkevt->dev;\n\n\t \n\tdev->features = features;\n\tdev->rating = rating;\n\tdev->set_next_event = dmtimer_set_next_event;\n\tdev->set_state_shutdown = dmtimer_clockevent_shutdown;\n\tdev->set_state_periodic = dmtimer_set_periodic;\n\tdev->set_state_oneshot = dmtimer_clockevent_shutdown;\n\tdev->set_state_oneshot_stopped = dmtimer_clockevent_shutdown;\n\tdev->tick_resume = dmtimer_clockevent_shutdown;\n\tdev->cpumask = cpumask;\n\n\tdev->irq = irq_of_parse_and_map(np, 0);\n\tif (!dev->irq)\n\t\treturn -ENXIO;\n\n\terror = dmtimer_systimer_setup(np, &clkevt->t);\n\tif (error)\n\t\treturn error;\n\n\tclkevt->period = 0xffffffff - DIV_ROUND_CLOSEST(t->rate, HZ);\n\n\t \n\twritel_relaxed(OMAP_TIMER_CTRL_POSTED, t->base + t->ifctrl);\n\n\terror = request_irq(dev->irq, dmtimer_clockevent_interrupt,\n\t\t\t    IRQF_TIMER, name, clkevt);\n\tif (error)\n\t\tgoto err_out_unmap;\n\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->irq_ena);\n\twritel_relaxed(OMAP_TIMER_INT_OVERFLOW, t->base + t->wakeup);\n\n\tpr_info(\"TI gptimer %s: %s%lu Hz at %pOF\\n\",\n\t\tname, of_property_read_bool(np, \"ti,timer-alwon\") ?\n\t\t\"always-on \" : \"\", t->rate, np->parent);\n\n\treturn 0;\n\nerr_out_unmap:\n\tiounmap(t->base);\n\n\treturn error;\n}\n\nstatic int __init dmtimer_clockevent_init(struct device_node *np)\n{\n\tstruct dmtimer_clockevent *clkevt;\n\tint error;\n\n\tclkevt = kzalloc(sizeof(*clkevt), GFP_KERNEL);\n\tif (!clkevt)\n\t\treturn -ENOMEM;\n\n\terror = dmtimer_clkevt_init_common(clkevt, np,\n\t\t\t\t\t   CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t\t   CLOCK_EVT_FEAT_ONESHOT,\n\t\t\t\t\t   cpu_possible_mask, \"clockevent\",\n\t\t\t\t\t   300);\n\tif (error)\n\t\tgoto err_out_free;\n\n\tclockevents_config_and_register(&clkevt->dev, clkevt->t.rate,\n\t\t\t\t\t3,  \n\t\t\t\t\t0xffffffff);\n\n\tif (of_machine_is_compatible(\"ti,am33xx\") ||\n\t    of_machine_is_compatible(\"ti,am43\")) {\n\t\tclkevt->dev.suspend = omap_clockevent_idle;\n\t\tclkevt->dev.resume = omap_clockevent_unidle;\n\t}\n\n\treturn 0;\n\nerr_out_free:\n\tkfree(clkevt);\n\n\treturn error;\n}\n\n \nstatic DEFINE_PER_CPU(struct dmtimer_clockevent, dmtimer_percpu_timer);\n\nstatic int __init dmtimer_percpu_timer_init(struct device_node *np, int cpu)\n{\n\tstruct dmtimer_clockevent *clkevt;\n\tint error;\n\n\tif (!cpu_possible(cpu))\n\t\treturn -EINVAL;\n\n\tif (!of_property_read_bool(np->parent, \"ti,no-reset-on-init\") ||\n\t    !of_property_read_bool(np->parent, \"ti,no-idle\"))\n\t\tpr_warn(\"Incomplete dtb for percpu dmtimer %pOF\\n\", np->parent);\n\n\tclkevt = per_cpu_ptr(&dmtimer_percpu_timer, cpu);\n\n\terror = dmtimer_clkevt_init_common(clkevt, np, CLOCK_EVT_FEAT_ONESHOT,\n\t\t\t\t\t   cpumask_of(cpu), \"percpu-dmtimer\",\n\t\t\t\t\t   500);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n \nstatic int omap_dmtimer_starting_cpu(unsigned int cpu)\n{\n\tstruct dmtimer_clockevent *clkevt = per_cpu_ptr(&dmtimer_percpu_timer, cpu);\n\tstruct clock_event_device *dev = &clkevt->dev;\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\n\tclockevents_config_and_register(dev, t->rate, 3, ULONG_MAX);\n\tirq_force_affinity(dev->irq, cpumask_of(cpu));\n\n\treturn 0;\n}\n\nstatic int __init dmtimer_percpu_timer_startup(void)\n{\n\tstruct dmtimer_clockevent *clkevt = per_cpu_ptr(&dmtimer_percpu_timer, 0);\n\tstruct dmtimer_systimer *t = &clkevt->t;\n\n\tif (t->sysc) {\n\t\tcpuhp_setup_state(CPUHP_AP_TI_GP_TIMER_STARTING,\n\t\t\t\t  \"clockevents/omap/gptimer:starting\",\n\t\t\t\t  omap_dmtimer_starting_cpu, NULL);\n\t}\n\n\treturn 0;\n}\nsubsys_initcall(dmtimer_percpu_timer_startup);\n\nstatic int __init dmtimer_percpu_quirk_init(struct device_node *np, u32 pa)\n{\n\tstruct device_node *arm_timer;\n\n\tarm_timer = of_find_compatible_node(NULL, NULL, \"arm,armv7-timer\");\n\tif (of_device_is_available(arm_timer)) {\n\t\tpr_warn_once(\"ARM architected timer wrap issue i940 detected\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pa == 0x4882c000)            \n\t\treturn dmtimer_percpu_timer_init(np, 0);\n\telse if (pa == 0x4882e000)       \n\t\treturn dmtimer_percpu_timer_init(np, 1);\n\n\treturn 0;\n}\n\n \nstatic struct dmtimer_clocksource *\nto_dmtimer_clocksource(struct clocksource *cs)\n{\n\treturn container_of(cs, struct dmtimer_clocksource, dev);\n}\n\nstatic u64 dmtimer_clocksource_read_cycles(struct clocksource *cs)\n{\n\tstruct dmtimer_clocksource *clksrc = to_dmtimer_clocksource(cs);\n\tstruct dmtimer_systimer *t = &clksrc->t;\n\n\treturn (u64)readl_relaxed(t->base + t->counter);\n}\n\nstatic void __iomem *dmtimer_sched_clock_counter;\n\nstatic u64 notrace dmtimer_read_sched_clock(void)\n{\n\treturn readl_relaxed(dmtimer_sched_clock_counter);\n}\n\nstatic void dmtimer_clocksource_suspend(struct clocksource *cs)\n{\n\tstruct dmtimer_clocksource *clksrc = to_dmtimer_clocksource(cs);\n\tstruct dmtimer_systimer *t = &clksrc->t;\n\n\tclksrc->loadval = readl_relaxed(t->base + t->counter);\n\tdmtimer_systimer_disable(t);\n\tclk_disable(t->fck);\n}\n\nstatic void dmtimer_clocksource_resume(struct clocksource *cs)\n{\n\tstruct dmtimer_clocksource *clksrc = to_dmtimer_clocksource(cs);\n\tstruct dmtimer_systimer *t = &clksrc->t;\n\tint error;\n\n\terror = clk_enable(t->fck);\n\tif (error)\n\t\tpr_err(\"could not enable timer fck on resume: %i\\n\", error);\n\n\tdmtimer_systimer_enable(t);\n\twritel_relaxed(clksrc->loadval, t->base + t->counter);\n\twritel_relaxed(OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR,\n\t\t       t->base + t->ctrl);\n}\n\nstatic int __init dmtimer_clocksource_init(struct device_node *np)\n{\n\tstruct dmtimer_clocksource *clksrc;\n\tstruct dmtimer_systimer *t;\n\tstruct clocksource *dev;\n\tint error;\n\n\tclksrc = kzalloc(sizeof(*clksrc), GFP_KERNEL);\n\tif (!clksrc)\n\t\treturn -ENOMEM;\n\n\tdev = &clksrc->dev;\n\tt = &clksrc->t;\n\n\terror = dmtimer_systimer_setup(np, t);\n\tif (error)\n\t\tgoto err_out_free;\n\n\tdev->name = \"dmtimer\";\n\tdev->rating = 300;\n\tdev->read = dmtimer_clocksource_read_cycles;\n\tdev->mask = CLOCKSOURCE_MASK(32);\n\tdev->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\t \n\tif (of_machine_is_compatible(\"ti,am43\")) {\n\t\tdev->suspend = dmtimer_clocksource_suspend;\n\t\tdev->resume = dmtimer_clocksource_resume;\n\t}\n\n\twritel_relaxed(0, t->base + t->counter);\n\twritel_relaxed(OMAP_TIMER_CTRL_ST | OMAP_TIMER_CTRL_AR,\n\t\t       t->base + t->ctrl);\n\n\tpr_info(\"TI gptimer clocksource: %s%pOF\\n\",\n\t\tof_property_read_bool(np, \"ti,timer-alwon\") ?\n\t\t\"always-on \" : \"\", np->parent);\n\n\tif (!dmtimer_sched_clock_counter) {\n\t\tdmtimer_sched_clock_counter = t->base + t->counter;\n\t\tsched_clock_register(dmtimer_read_sched_clock, 32, t->rate);\n\t}\n\n\tif (clocksource_register_hz(dev, t->rate))\n\t\tpr_err(\"Could not register clocksource %pOF\\n\", np);\n\n\treturn 0;\n\nerr_out_free:\n\tkfree(clksrc);\n\n\treturn -ENODEV;\n}\n\n \nstatic int __init dmtimer_systimer_init(struct device_node *np)\n{\n\tstruct resource res;\n\tu32 pa;\n\n\t \n\tif (!clocksource && !clockevent)\n\t\tdmtimer_systimer_select_best();\n\n\tif (!clocksource && !clockevent) {\n\t\tpr_err(\"%s: unable to detect system timers, update dtb?\\n\",\n\t\t       __func__);\n\n\t\treturn -EINVAL;\n\t}\n\n\n\tof_address_to_resource(np, 0, &res);\n\tpa = (u32)res.start;\n\tif (!pa)\n\t\treturn -EINVAL;\n\n\tif (counter_32k <= 0 && clocksource == pa)\n\t\treturn dmtimer_clocksource_init(np);\n\n\tif (clockevent == pa)\n\t\treturn dmtimer_clockevent_init(np);\n\n\tif (of_machine_is_compatible(\"ti,dra7\"))\n\t\treturn dmtimer_percpu_quirk_init(np, pa);\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(systimer_omap2, \"ti,omap2420-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_omap3, \"ti,omap3430-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_omap4, \"ti,omap4430-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_omap5, \"ti,omap5430-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_am33x, \"ti,am335x-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_am3ms, \"ti,am335x-timer-1ms\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_dm814, \"ti,dm814-timer\", dmtimer_systimer_init);\nTIMER_OF_DECLARE(systimer_dm816, \"ti,dm816-timer\", dmtimer_systimer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}