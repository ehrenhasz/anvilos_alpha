{
  "module_name": "timer-stm32-lp.c",
  "hash_id": "f7b2964c0de710a9a5908f60fb6a73b02656089ed5bb7c0f0fd010297227de59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-stm32-lp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/stm32-lptimer.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n\n#define CFGR_PSC_OFFSET\t\t9\n#define STM32_LP_RATING\t\t1000\n#define STM32_TARGET_CLKRATE\t(32000 * HZ)\n#define STM32_LP_MAX_PSC\t7\n\nstruct stm32_lp_private {\n\tstruct regmap *reg;\n\tstruct clock_event_device clkevt;\n\tunsigned long period;\n\tstruct device *dev;\n};\n\nstatic struct stm32_lp_private*\nto_priv(struct clock_event_device *clkevt)\n{\n\treturn container_of(clkevt, struct stm32_lp_private, clkevt);\n}\n\nstatic int stm32_clkevent_lp_shutdown(struct clock_event_device *clkevt)\n{\n\tstruct stm32_lp_private *priv = to_priv(clkevt);\n\n\tregmap_write(priv->reg, STM32_LPTIM_CR, 0);\n\tregmap_write(priv->reg, STM32_LPTIM_IER, 0);\n\t \n\tregmap_write(priv->reg, STM32_LPTIM_ICR, STM32_LPTIM_ARRMCF);\n\n\treturn 0;\n}\n\nstatic int stm32_clkevent_lp_set_timer(unsigned long evt,\n\t\t\t\t       struct clock_event_device *clkevt,\n\t\t\t\t       int is_periodic)\n{\n\tstruct stm32_lp_private *priv = to_priv(clkevt);\n\n\t \n\tregmap_write(priv->reg, STM32_LPTIM_CR, 0);\n\t \n\tregmap_write(priv->reg, STM32_LPTIM_IER, STM32_LPTIM_ARRMIE);\n\t \n\tregmap_write(priv->reg, STM32_LPTIM_CR, STM32_LPTIM_ENABLE);\n\t \n\tregmap_write(priv->reg, STM32_LPTIM_ARR, evt);\n\n\t \n\tif (is_periodic)\n\t\tregmap_write(priv->reg, STM32_LPTIM_CR,\n\t\t\t     STM32_LPTIM_CNTSTRT | STM32_LPTIM_ENABLE);\n\telse\n\t\tregmap_write(priv->reg, STM32_LPTIM_CR,\n\t\t\t     STM32_LPTIM_SNGSTRT | STM32_LPTIM_ENABLE);\n\n\treturn 0;\n}\n\nstatic int stm32_clkevent_lp_set_next_event(unsigned long evt,\n\t\t\t\t\t    struct clock_event_device *clkevt)\n{\n\treturn stm32_clkevent_lp_set_timer(evt, clkevt,\n\t\t\t\t\t   clockevent_state_periodic(clkevt));\n}\n\nstatic int stm32_clkevent_lp_set_periodic(struct clock_event_device *clkevt)\n{\n\tstruct stm32_lp_private *priv = to_priv(clkevt);\n\n\treturn stm32_clkevent_lp_set_timer(priv->period, clkevt, true);\n}\n\nstatic int stm32_clkevent_lp_set_oneshot(struct clock_event_device *clkevt)\n{\n\tstruct stm32_lp_private *priv = to_priv(clkevt);\n\n\treturn stm32_clkevent_lp_set_timer(priv->period, clkevt, false);\n}\n\nstatic irqreturn_t stm32_clkevent_lp_irq_handler(int irq, void *dev_id)\n{\n\tstruct clock_event_device *clkevt = (struct clock_event_device *)dev_id;\n\tstruct stm32_lp_private *priv = to_priv(clkevt);\n\n\tregmap_write(priv->reg, STM32_LPTIM_ICR, STM32_LPTIM_ARRMCF);\n\n\tif (clkevt->event_handler)\n\t\tclkevt->event_handler(clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stm32_clkevent_lp_set_prescaler(struct stm32_lp_private *priv,\n\t\t\t\t\t    unsigned long *rate)\n{\n\tint i;\n\n\tfor (i = 0; i <= STM32_LP_MAX_PSC; i++) {\n\t\tif (DIV_ROUND_CLOSEST(*rate, 1 << i) < STM32_TARGET_CLKRATE)\n\t\t\tbreak;\n\t}\n\n\tregmap_write(priv->reg, STM32_LPTIM_CFGR, i << CFGR_PSC_OFFSET);\n\n\t \n\t*rate = DIV_ROUND_CLOSEST(*rate, (1 << i));\n\tpriv->period = DIV_ROUND_UP(*rate, HZ);\n}\n\nstatic void stm32_clkevent_lp_init(struct stm32_lp_private *priv,\n\t\t\t\t  struct device_node *np, unsigned long rate)\n{\n\tpriv->clkevt.name = np->full_name;\n\tpriv->clkevt.cpumask = cpu_possible_mask;\n\tpriv->clkevt.features = CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\tCLOCK_EVT_FEAT_ONESHOT;\n\tpriv->clkevt.set_state_shutdown = stm32_clkevent_lp_shutdown;\n\tpriv->clkevt.set_state_periodic = stm32_clkevent_lp_set_periodic;\n\tpriv->clkevt.set_state_oneshot = stm32_clkevent_lp_set_oneshot;\n\tpriv->clkevt.set_next_event = stm32_clkevent_lp_set_next_event;\n\tpriv->clkevt.rating = STM32_LP_RATING;\n\n\tclockevents_config_and_register(&priv->clkevt, rate, 0x1,\n\t\t\t\t\tSTM32_LPTIM_MAX_ARR);\n}\n\nstatic int stm32_clkevent_lp_probe(struct platform_device *pdev)\n{\n\tstruct stm32_lptimer *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct stm32_lp_private *priv;\n\tunsigned long rate;\n\tint ret, irq;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg = ddata->regmap;\n\tret = clk_prepare_enable(ddata->clk);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\trate = clk_get_rate(ddata->clk);\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto out_clk_disable;\n\t}\n\n\tirq = platform_get_irq(to_platform_device(pdev->dev.parent), 0);\n\tif (irq <= 0) {\n\t\tret = irq;\n\t\tgoto out_clk_disable;\n\t}\n\n\tif (of_property_read_bool(pdev->dev.parent->of_node, \"wakeup-source\")) {\n\t\tret = device_init_wakeup(&pdev->dev, true);\n\t\tif (ret)\n\t\t\tgoto out_clk_disable;\n\n\t\tret = dev_pm_set_wake_irq(&pdev->dev, irq);\n\t\tif (ret)\n\t\t\tgoto out_clk_disable;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, stm32_clkevent_lp_irq_handler,\n\t\t\t       IRQF_TIMER, pdev->name, &priv->clkevt);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tstm32_clkevent_lp_set_prescaler(priv, &rate);\n\n\tstm32_clkevent_lp_init(priv, pdev->dev.parent->of_node, rate);\n\n\tpriv->dev = &pdev->dev;\n\n\treturn 0;\n\nout_clk_disable:\n\tclk_disable_unprepare(ddata->clk);\n\treturn ret;\n}\n\nstatic const struct of_device_id stm32_clkevent_lp_of_match[] = {\n\t{ .compatible = \"st,stm32-lptimer-timer\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_clkevent_lp_of_match);\n\nstatic struct platform_driver stm32_clkevent_lp_driver = {\n\t.probe  = stm32_clkevent_lp_probe,\n\t.driver\t= {\n\t\t.name = \"stm32-lptimer-timer\",\n\t\t.of_match_table = stm32_clkevent_lp_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(stm32_clkevent_lp_driver);\n\nMODULE_ALIAS(\"platform:stm32-lptimer-timer\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 clockevent low power driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}