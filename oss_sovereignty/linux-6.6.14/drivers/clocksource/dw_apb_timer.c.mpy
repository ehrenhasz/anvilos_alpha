{
  "module_name": "dw_apb_timer.c",
  "hash_id": "eb70725108396fa3a0f155095627f0ed981a1f6dafed05d9636e667fad9ce84c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/dw_apb_timer.c",
  "human_readable_source": "\n \n#include <linux/dw_apb_timer.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#define APBT_MIN_PERIOD\t\t\t4\n#define APBT_MIN_DELTA_USEC\t\t200\n\n#define APBTMR_N_LOAD_COUNT\t\t0x00\n#define APBTMR_N_CURRENT_VALUE\t\t0x04\n#define APBTMR_N_CONTROL\t\t0x08\n#define APBTMR_N_EOI\t\t\t0x0c\n#define APBTMR_N_INT_STATUS\t\t0x10\n\n#define APBTMRS_INT_STATUS\t\t0xa0\n#define APBTMRS_EOI\t\t\t0xa4\n#define APBTMRS_RAW_INT_STATUS\t\t0xa8\n#define APBTMRS_COMP_VERSION\t\t0xac\n\n#define APBTMR_CONTROL_ENABLE\t\t(1 << 0)\n \n#define APBTMR_CONTROL_MODE_PERIODIC\t(1 << 1)\n#define APBTMR_CONTROL_INT\t\t(1 << 2)\n\nstatic inline struct dw_apb_clock_event_device *\nced_to_dw_apb_ced(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct dw_apb_clock_event_device, ced);\n}\n\nstatic inline struct dw_apb_clocksource *\nclocksource_to_dw_apb_clocksource(struct clocksource *cs)\n{\n\treturn container_of(cs, struct dw_apb_clocksource, cs);\n}\n\nstatic inline u32 apbt_readl(struct dw_apb_timer *timer, unsigned long offs)\n{\n\treturn readl(timer->base + offs);\n}\n\nstatic inline void apbt_writel(struct dw_apb_timer *timer, u32 val,\n\t\t\tunsigned long offs)\n{\n\twritel(val, timer->base + offs);\n}\n\nstatic inline u32 apbt_readl_relaxed(struct dw_apb_timer *timer, unsigned long offs)\n{\n\treturn readl_relaxed(timer->base + offs);\n}\n\nstatic inline void apbt_writel_relaxed(struct dw_apb_timer *timer, u32 val,\n\t\t\tunsigned long offs)\n{\n\twritel_relaxed(val, timer->base + offs);\n}\n\nstatic void apbt_disable_int(struct dw_apb_timer *timer)\n{\n\tu32 ctrl = apbt_readl(timer, APBTMR_N_CONTROL);\n\n\tctrl |= APBTMR_CONTROL_INT;\n\tapbt_writel(timer, ctrl, APBTMR_N_CONTROL);\n}\n\n \nvoid dw_apb_clockevent_pause(struct dw_apb_clock_event_device *dw_ced)\n{\n\tdisable_irq(dw_ced->timer.irq);\n\tapbt_disable_int(&dw_ced->timer);\n}\n\nstatic void apbt_eoi(struct dw_apb_timer *timer)\n{\n\tapbt_readl_relaxed(timer, APBTMR_N_EOI);\n}\n\nstatic irqreturn_t dw_apb_clockevent_irq(int irq, void *data)\n{\n\tstruct clock_event_device *evt = data;\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\n\tif (!evt->event_handler) {\n\t\tpr_info(\"Spurious APBT timer interrupt %d\\n\", irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (dw_ced->eoi)\n\t\tdw_ced->eoi(&dw_ced->timer);\n\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic void apbt_enable_int(struct dw_apb_timer *timer)\n{\n\tu32 ctrl = apbt_readl(timer, APBTMR_N_CONTROL);\n\t \n\tapbt_readl(timer, APBTMR_N_EOI);\n\tctrl &= ~APBTMR_CONTROL_INT;\n\tapbt_writel(timer, ctrl, APBTMR_N_CONTROL);\n}\n\nstatic int apbt_shutdown(struct clock_event_device *evt)\n{\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\tu32 ctrl;\n\n\tpr_debug(\"%s CPU %d state=shutdown\\n\", __func__,\n\t\t cpumask_first(evt->cpumask));\n\n\tctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\n\tctrl &= ~APBTMR_CONTROL_ENABLE;\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\treturn 0;\n}\n\nstatic int apbt_set_oneshot(struct clock_event_device *evt)\n{\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\tu32 ctrl;\n\n\tpr_debug(\"%s CPU %d state=oneshot\\n\", __func__,\n\t\t cpumask_first(evt->cpumask));\n\n\tctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\n\t \n\tctrl &= ~APBTMR_CONTROL_ENABLE;\n\tctrl &= ~APBTMR_CONTROL_MODE_PERIODIC;\n\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\t \n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\n\t \n\tapbt_writel(&dw_ced->timer, ~0, APBTMR_N_LOAD_COUNT);\n\tctrl &= ~APBTMR_CONTROL_INT;\n\tctrl |= APBTMR_CONTROL_ENABLE;\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\treturn 0;\n}\n\nstatic int apbt_set_periodic(struct clock_event_device *evt)\n{\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\tunsigned long period = DIV_ROUND_UP(dw_ced->timer.freq, HZ);\n\tu32 ctrl;\n\n\tpr_debug(\"%s CPU %d state=periodic\\n\", __func__,\n\t\t cpumask_first(evt->cpumask));\n\n\tctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\n\tctrl |= APBTMR_CONTROL_MODE_PERIODIC;\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\t \n\tctrl &= ~APBTMR_CONTROL_ENABLE;\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\tudelay(1);\n\tpr_debug(\"Setting clock period %lu for HZ %d\\n\", period, HZ);\n\tapbt_writel(&dw_ced->timer, period, APBTMR_N_LOAD_COUNT);\n\tctrl |= APBTMR_CONTROL_ENABLE;\n\tapbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\treturn 0;\n}\n\nstatic int apbt_resume(struct clock_event_device *evt)\n{\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\n\tpr_debug(\"%s CPU %d state=resume\\n\", __func__,\n\t\t cpumask_first(evt->cpumask));\n\n\tapbt_enable_int(&dw_ced->timer);\n\treturn 0;\n}\n\nstatic int apbt_next_event(unsigned long delta,\n\t\t\t   struct clock_event_device *evt)\n{\n\tu32 ctrl;\n\tstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\n\n\t \n\tctrl = apbt_readl_relaxed(&dw_ced->timer, APBTMR_N_CONTROL);\n\tctrl &= ~APBTMR_CONTROL_ENABLE;\n\tapbt_writel_relaxed(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\t \n\tapbt_writel_relaxed(&dw_ced->timer, delta, APBTMR_N_LOAD_COUNT);\n\tctrl |= APBTMR_CONTROL_ENABLE;\n\tapbt_writel_relaxed(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\n\n\treturn 0;\n}\n\n \nstruct dw_apb_clock_event_device *\ndw_apb_clockevent_init(int cpu, const char *name, unsigned rating,\n\t\t       void __iomem *base, int irq, unsigned long freq)\n{\n\tstruct dw_apb_clock_event_device *dw_ced =\n\t\tkzalloc(sizeof(*dw_ced), GFP_KERNEL);\n\tint err;\n\n\tif (!dw_ced)\n\t\treturn NULL;\n\n\tdw_ced->timer.base = base;\n\tdw_ced->timer.irq = irq;\n\tdw_ced->timer.freq = freq;\n\n\tclockevents_calc_mult_shift(&dw_ced->ced, freq, APBT_MIN_PERIOD);\n\tdw_ced->ced.max_delta_ns = clockevent_delta2ns(0x7fffffff,\n\t\t\t\t\t\t       &dw_ced->ced);\n\tdw_ced->ced.max_delta_ticks = 0x7fffffff;\n\tdw_ced->ced.min_delta_ns = clockevent_delta2ns(5000, &dw_ced->ced);\n\tdw_ced->ced.min_delta_ticks = 5000;\n\tdw_ced->ced.cpumask = cpu < 0 ? cpu_possible_mask : cpumask_of(cpu);\n\tdw_ced->ced.features = CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\tCLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_DYNIRQ;\n\tdw_ced->ced.set_state_shutdown = apbt_shutdown;\n\tdw_ced->ced.set_state_periodic = apbt_set_periodic;\n\tdw_ced->ced.set_state_oneshot = apbt_set_oneshot;\n\tdw_ced->ced.set_state_oneshot_stopped = apbt_shutdown;\n\tdw_ced->ced.tick_resume = apbt_resume;\n\tdw_ced->ced.set_next_event = apbt_next_event;\n\tdw_ced->ced.irq = dw_ced->timer.irq;\n\tdw_ced->ced.rating = rating;\n\tdw_ced->ced.name = name;\n\n\tdw_ced->eoi = apbt_eoi;\n\terr = request_irq(irq, dw_apb_clockevent_irq,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\n\t\t\t  dw_ced->ced.name, &dw_ced->ced);\n\tif (err) {\n\t\tpr_err(\"failed to request timer irq\\n\");\n\t\tkfree(dw_ced);\n\t\tdw_ced = NULL;\n\t}\n\n\treturn dw_ced;\n}\n\n \nvoid dw_apb_clockevent_resume(struct dw_apb_clock_event_device *dw_ced)\n{\n\tenable_irq(dw_ced->timer.irq);\n}\n\n \nvoid dw_apb_clockevent_stop(struct dw_apb_clock_event_device *dw_ced)\n{\n\tfree_irq(dw_ced->timer.irq, &dw_ced->ced);\n}\n\n \nvoid dw_apb_clockevent_register(struct dw_apb_clock_event_device *dw_ced)\n{\n\tapbt_writel(&dw_ced->timer, 0, APBTMR_N_CONTROL);\n\tclockevents_register_device(&dw_ced->ced);\n\tapbt_enable_int(&dw_ced->timer);\n}\n\n \nvoid dw_apb_clocksource_start(struct dw_apb_clocksource *dw_cs)\n{\n\t \n\tu32 ctrl = apbt_readl(&dw_cs->timer, APBTMR_N_CONTROL);\n\n\tctrl &= ~APBTMR_CONTROL_ENABLE;\n\tapbt_writel(&dw_cs->timer, ctrl, APBTMR_N_CONTROL);\n\tapbt_writel(&dw_cs->timer, ~0, APBTMR_N_LOAD_COUNT);\n\t \n\tctrl &= ~APBTMR_CONTROL_MODE_PERIODIC;\n\tctrl |= (APBTMR_CONTROL_ENABLE | APBTMR_CONTROL_INT);\n\tapbt_writel(&dw_cs->timer, ctrl, APBTMR_N_CONTROL);\n\t \n\tdw_apb_clocksource_read(dw_cs);\n}\n\nstatic u64 __apbt_read_clocksource(struct clocksource *cs)\n{\n\tu32 current_count;\n\tstruct dw_apb_clocksource *dw_cs =\n\t\tclocksource_to_dw_apb_clocksource(cs);\n\n\tcurrent_count = apbt_readl_relaxed(&dw_cs->timer,\n\t\t\t\t\tAPBTMR_N_CURRENT_VALUE);\n\n\treturn (u64)~current_count;\n}\n\nstatic void apbt_restart_clocksource(struct clocksource *cs)\n{\n\tstruct dw_apb_clocksource *dw_cs =\n\t\tclocksource_to_dw_apb_clocksource(cs);\n\n\tdw_apb_clocksource_start(dw_cs);\n}\n\n \nstruct dw_apb_clocksource *\ndw_apb_clocksource_init(unsigned rating, const char *name, void __iomem *base,\n\t\t\tunsigned long freq)\n{\n\tstruct dw_apb_clocksource *dw_cs = kzalloc(sizeof(*dw_cs), GFP_KERNEL);\n\n\tif (!dw_cs)\n\t\treturn NULL;\n\n\tdw_cs->timer.base = base;\n\tdw_cs->timer.freq = freq;\n\tdw_cs->cs.name = name;\n\tdw_cs->cs.rating = rating;\n\tdw_cs->cs.read = __apbt_read_clocksource;\n\tdw_cs->cs.mask = CLOCKSOURCE_MASK(32);\n\tdw_cs->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\tdw_cs->cs.resume = apbt_restart_clocksource;\n\n\treturn dw_cs;\n}\n\n \nvoid dw_apb_clocksource_register(struct dw_apb_clocksource *dw_cs)\n{\n\tclocksource_register_hz(&dw_cs->cs, dw_cs->timer.freq);\n}\n\n \nu64 dw_apb_clocksource_read(struct dw_apb_clocksource *dw_cs)\n{\n\treturn (u64)~apbt_readl(&dw_cs->timer, APBTMR_N_CURRENT_VALUE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}