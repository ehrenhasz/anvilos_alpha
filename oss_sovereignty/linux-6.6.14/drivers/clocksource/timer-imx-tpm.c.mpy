{
  "module_name": "timer-imx-tpm.c",
  "hash_id": "8a1edb5bc898b61b1c07c8e52c38cbcd6d126c570e90a1446166df2d61ad1aec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-imx-tpm.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/sched_clock.h>\n\n#include \"timer-of.h\"\n\n#define TPM_PARAM\t\t\t0x4\n#define TPM_PARAM_WIDTH_SHIFT\t\t16\n#define TPM_PARAM_WIDTH_MASK\t\t(0xff << 16)\n#define TPM_SC\t\t\t\t0x10\n#define TPM_SC_CMOD_INC_PER_CNT\t\t(0x1 << 3)\n#define TPM_SC_CMOD_DIV_DEFAULT\t\t0x3\n#define TPM_SC_CMOD_DIV_MAX\t\t0x7\n#define TPM_SC_TOF_MASK\t\t\t(0x1 << 7)\n#define TPM_CNT\t\t\t\t0x14\n#define TPM_MOD\t\t\t\t0x18\n#define TPM_STATUS\t\t\t0x1c\n#define TPM_STATUS_CH0F\t\t\tBIT(0)\n#define TPM_C0SC\t\t\t0x20\n#define TPM_C0SC_CHIE\t\t\tBIT(6)\n#define TPM_C0SC_MODE_SHIFT\t\t2\n#define TPM_C0SC_MODE_MASK\t\t0x3c\n#define TPM_C0SC_MODE_SW_COMPARE\t0x4\n#define TPM_C0SC_CHF_MASK\t\t(0x1 << 7)\n#define TPM_C0V\t\t\t\t0x24\n\nstatic int counter_width __ro_after_init;\nstatic void __iomem *timer_base __ro_after_init;\n\nstatic inline void tpm_timer_disable(void)\n{\n\tunsigned int val;\n\n\t \n\tval = readl(timer_base + TPM_C0SC);\n\tval &= ~(TPM_C0SC_MODE_MASK | TPM_C0SC_CHIE);\n\twritel(val, timer_base + TPM_C0SC);\n}\n\nstatic inline void tpm_timer_enable(void)\n{\n\tunsigned int val;\n\n\t \n\tval = readl(timer_base + TPM_C0SC);\n\tval |= (TPM_C0SC_MODE_SW_COMPARE << TPM_C0SC_MODE_SHIFT) |\n\t       TPM_C0SC_CHIE;\n\twritel(val, timer_base + TPM_C0SC);\n}\n\nstatic inline void tpm_irq_acknowledge(void)\n{\n\twritel(TPM_STATUS_CH0F, timer_base + TPM_STATUS);\n}\n\nstatic inline unsigned long tpm_read_counter(void)\n{\n\treturn readl(timer_base + TPM_CNT);\n}\n\n#if defined(CONFIG_ARM)\nstatic struct delay_timer tpm_delay_timer;\n\nstatic unsigned long tpm_read_current_timer(void)\n{\n\treturn tpm_read_counter();\n}\n\nstatic u64 notrace tpm_read_sched_clock(void)\n{\n\treturn tpm_read_counter();\n}\n#endif\n\nstatic int tpm_set_next_event(unsigned long delta,\n\t\t\t\tstruct clock_event_device *evt)\n{\n\tunsigned long next, now;\n\n\tnext = tpm_read_counter();\n\tnext += delta;\n\twritel(next, timer_base + TPM_C0V);\n\tnow = tpm_read_counter();\n\n\t \n\treturn (int)(next - now) <= 0 ? -ETIME : 0;\n}\n\nstatic int tpm_set_state_oneshot(struct clock_event_device *evt)\n{\n\ttpm_timer_enable();\n\n\treturn 0;\n}\n\nstatic int tpm_set_state_shutdown(struct clock_event_device *evt)\n{\n\ttpm_timer_disable();\n\n\treturn 0;\n}\n\nstatic irqreturn_t tpm_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\ttpm_irq_acknowledge();\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct timer_of to_tpm = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK,\n\t.clkevt = {\n\t\t.name\t\t\t= \"i.MX TPM Timer\",\n\t\t.rating\t\t\t= 200,\n\t\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_DYNIRQ,\n\t\t.set_state_shutdown\t= tpm_set_state_shutdown,\n\t\t.set_state_oneshot\t= tpm_set_state_oneshot,\n\t\t.set_next_event\t\t= tpm_set_next_event,\n\t\t.cpumask\t\t= cpu_possible_mask,\n\t},\n\t.of_irq = {\n\t\t.handler\t\t= tpm_timer_interrupt,\n\t\t.flags\t\t\t= IRQF_TIMER,\n\t},\n\t.of_clk = {\n\t\t.name = \"per\",\n\t},\n};\n\nstatic int __init tpm_clocksource_init(void)\n{\n#if defined(CONFIG_ARM)\n\ttpm_delay_timer.read_current_timer = &tpm_read_current_timer;\n\ttpm_delay_timer.freq = timer_of_rate(&to_tpm) >> 3;\n\tregister_current_timer_delay(&tpm_delay_timer);\n\n\tsched_clock_register(tpm_read_sched_clock, counter_width,\n\t\t\t     timer_of_rate(&to_tpm) >> 3);\n#endif\n\n\treturn clocksource_mmio_init(timer_base + TPM_CNT,\n\t\t\t\t     \"imx-tpm\",\n\t\t\t\t     timer_of_rate(&to_tpm) >> 3,\n\t\t\t\t     to_tpm.clkevt.rating,\n\t\t\t\t     counter_width,\n\t\t\t\t     clocksource_mmio_readl_up);\n}\n\nstatic void __init tpm_clockevent_init(void)\n{\n\tclockevents_config_and_register(&to_tpm.clkevt,\n\t\t\t\t\ttimer_of_rate(&to_tpm) >> 3,\n\t\t\t\t\t300,\n\t\t\t\t\tGENMASK(counter_width - 1,\n\t\t\t\t\t1));\n}\n\nstatic int __init tpm_timer_init(struct device_node *np)\n{\n\tstruct clk *ipg;\n\tint ret;\n\n\tipg = of_clk_get_by_name(np, \"ipg\");\n\tif (IS_ERR(ipg)) {\n\t\tpr_err(\"tpm: failed to get ipg clk\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tret = clk_prepare_enable(ipg);\n\tif (ret) {\n\t\tpr_err(\"tpm: ipg clock enable failed (%d)\\n\", ret);\n\t\tclk_put(ipg);\n\t\treturn ret;\n\t}\n\n\tret = timer_of_init(np, &to_tpm);\n\tif (ret)\n\t\treturn ret;\n\n\ttimer_base = timer_of_base(&to_tpm);\n\n\tcounter_width = (readl(timer_base + TPM_PARAM)\n\t\t& TPM_PARAM_WIDTH_MASK) >> TPM_PARAM_WIDTH_SHIFT;\n\t \n\tto_tpm.clkevt.rating = counter_width == 0x20 ? 200 : 150;\n\n\t \n\t \n\twritel(0, timer_base + TPM_SC);\n\t \n\twritel(TPM_SC_TOF_MASK, timer_base + TPM_SC);\n\twritel(0, timer_base + TPM_CNT);\n\t \n\twritel(TPM_C0SC_CHF_MASK, timer_base + TPM_C0SC);\n\n\t \n\twritel(TPM_SC_CMOD_INC_PER_CNT |\n\t\t(counter_width == 0x20 ?\n\t\tTPM_SC_CMOD_DIV_DEFAULT : TPM_SC_CMOD_DIV_MAX),\n\t\ttimer_base + TPM_SC);\n\n\t \n\twritel(GENMASK(counter_width - 1, 0), timer_base + TPM_MOD);\n\n\ttpm_clockevent_init();\n\n\treturn tpm_clocksource_init();\n}\nTIMER_OF_DECLARE(imx7ulp, \"fsl,imx7ulp-tpm\", tpm_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}