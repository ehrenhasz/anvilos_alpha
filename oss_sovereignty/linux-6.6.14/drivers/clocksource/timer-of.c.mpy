{
  "module_name": "timer-of.c",
  "hash_id": "4ce64877dad60e2ba078765cbe56cfb7e5a0852b3b380a8b6df37a23f0d3570e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-of.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n\n#include \"timer-of.h\"\n\n \nstatic __init void timer_of_irq_exit(struct of_timer_irq *of_irq)\n{\n\tstruct timer_of *to = container_of(of_irq, struct timer_of, of_irq);\n\n\tstruct clock_event_device *clkevt = &to->clkevt;\n\n\tif (of_irq->percpu)\n\t\tfree_percpu_irq(of_irq->irq, clkevt);\n\telse\n\t\tfree_irq(of_irq->irq, clkevt);\n}\n\n \nstatic __init int timer_of_irq_init(struct device_node *np,\n\t\t\t\t    struct of_timer_irq *of_irq)\n{\n\tint ret;\n\tstruct timer_of *to = container_of(of_irq, struct timer_of, of_irq);\n\tstruct clock_event_device *clkevt = &to->clkevt;\n\n\tif (of_irq->name) {\n\t\tof_irq->irq = ret = of_irq_get_byname(np, of_irq->name);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to get interrupt %s for %pOF\\n\",\n\t\t\t       of_irq->name, np);\n\t\t\treturn ret;\n\t\t}\n\t} else\t{\n\t\tof_irq->irq = irq_of_parse_and_map(np, of_irq->index);\n\t}\n\tif (!of_irq->irq) {\n\t\tpr_err(\"Failed to map interrupt for %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_irq->percpu ?\n\t\trequest_percpu_irq(of_irq->irq, of_irq->handler,\n\t\t\t\t   np->full_name, clkevt) :\n\t\trequest_irq(of_irq->irq, of_irq->handler,\n\t\t\t    of_irq->flags ? of_irq->flags : IRQF_TIMER,\n\t\t\t    np->full_name, clkevt);\n\tif (ret) {\n\t\tpr_err(\"Failed to request irq %d for %pOF\\n\", of_irq->irq, np);\n\t\treturn ret;\n\t}\n\n\tclkevt->irq = of_irq->irq;\n\n\treturn 0;\n}\n\n \nstatic __init void timer_of_clk_exit(struct of_timer_clk *of_clk)\n{\n\tof_clk->rate = 0;\n\tclk_disable_unprepare(of_clk->clk);\n\tclk_put(of_clk->clk);\n}\n\n \nstatic __init int timer_of_clk_init(struct device_node *np,\n\t\t\t\t    struct of_timer_clk *of_clk)\n{\n\tint ret;\n\n\tof_clk->clk = of_clk->name ? of_clk_get_by_name(np, of_clk->name) :\n\t\tof_clk_get(np, of_clk->index);\n\tif (IS_ERR(of_clk->clk)) {\n\t\tret = PTR_ERR(of_clk->clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tpr_err(\"Failed to get clock for %pOF\\n\", np);\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(of_clk->clk);\n\tif (ret) {\n\t\tpr_err(\"Failed for enable clock for %pOF\\n\", np);\n\t\tgoto out_clk_put;\n\t}\n\n\tof_clk->rate = clk_get_rate(of_clk->clk);\n\tif (!of_clk->rate) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"Failed to get clock rate for %pOF\\n\", np);\n\t\tgoto out_clk_disable;\n\t}\n\n\tof_clk->period = DIV_ROUND_UP(of_clk->rate, HZ);\nout:\n\treturn ret;\n\nout_clk_disable:\n\tclk_disable_unprepare(of_clk->clk);\nout_clk_put:\n\tclk_put(of_clk->clk);\n\n\tgoto out;\n}\n\nstatic __init void timer_of_base_exit(struct of_timer_base *of_base)\n{\n\tiounmap(of_base->base);\n}\n\nstatic __init int timer_of_base_init(struct device_node *np,\n\t\t\t\t     struct of_timer_base *of_base)\n{\n\tof_base->base = of_base->name ?\n\t\tof_io_request_and_map(np, of_base->index, of_base->name) :\n\t\tof_iomap(np, of_base->index);\n\tif (IS_ERR_OR_NULL(of_base->base)) {\n\t\tpr_err(\"Failed to iomap (%s:%s)\\n\", np->name, of_base->name);\n\t\treturn of_base->base ? PTR_ERR(of_base->base) : -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint __init timer_of_init(struct device_node *np, struct timer_of *to)\n{\n\tint ret = -EINVAL;\n\tint flags = 0;\n\n\tif (to->flags & TIMER_OF_BASE) {\n\t\tret = timer_of_base_init(np, &to->of_base);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\tflags |= TIMER_OF_BASE;\n\t}\n\n\tif (to->flags & TIMER_OF_CLOCK) {\n\t\tret = timer_of_clk_init(np, &to->of_clk);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\tflags |= TIMER_OF_CLOCK;\n\t}\n\n\tif (to->flags & TIMER_OF_IRQ) {\n\t\tret = timer_of_irq_init(np, &to->of_irq);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\tflags |= TIMER_OF_IRQ;\n\t}\n\n\tif (!to->clkevt.name)\n\t\tto->clkevt.name = np->full_name;\n\n\tto->np = np;\n\n\treturn ret;\n\nout_fail:\n\tif (flags & TIMER_OF_IRQ)\n\t\ttimer_of_irq_exit(&to->of_irq);\n\n\tif (flags & TIMER_OF_CLOCK)\n\t\ttimer_of_clk_exit(&to->of_clk);\n\n\tif (flags & TIMER_OF_BASE)\n\t\ttimer_of_base_exit(&to->of_base);\n\treturn ret;\n}\n\n \nvoid __init timer_of_cleanup(struct timer_of *to)\n{\n\tif (to->flags & TIMER_OF_IRQ)\n\t\ttimer_of_irq_exit(&to->of_irq);\n\n\tif (to->flags & TIMER_OF_CLOCK)\n\t\ttimer_of_clk_exit(&to->of_clk);\n\n\tif (to->flags & TIMER_OF_BASE)\n\t\ttimer_of_base_exit(&to->of_base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}