{
  "module_name": "timer-atmel-pit.c",
  "hash_id": "26911bf58aeca552fe5f1635bf148fcc3e78ad212224e334daa332bd94f583a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-atmel-pit.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"AT91: PIT: \" fmt\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n\n#define AT91_PIT_MR\t\t0x00\t\t\t \n#define AT91_PIT_PITIEN\t\t\tBIT(25)\t\t\t \n#define AT91_PIT_PITEN\t\t\tBIT(24)\t\t\t \n#define AT91_PIT_PIV\t\t\tGENMASK(19, 0)\t\t \n\n#define AT91_PIT_SR\t\t0x04\t\t\t \n#define AT91_PIT_PITS\t\t\tBIT(0)\t\t\t \n\n#define AT91_PIT_PIVR\t\t0x08\t\t\t \n#define AT91_PIT_PIIR\t\t0x0c\t\t\t \n#define AT91_PIT_PICNT\t\t\tGENMASK(31, 20)\t\t \n#define AT91_PIT_CPIV\t\t\tGENMASK(19, 0)\t\t \n\n#define PIT_CPIV(x)\t((x) & AT91_PIT_CPIV)\n#define PIT_PICNT(x)\t(((x) & AT91_PIT_PICNT) >> 20)\n\nstruct pit_data {\n\tstruct clock_event_device\tclkevt;\n\tstruct clocksource\t\tclksrc;\n\n\tvoid __iomem\t*base;\n\tu32\t\tcycle;\n\tu32\t\tcnt;\n\tunsigned int\tirq;\n\tstruct clk\t*mck;\n};\n\nstatic inline struct pit_data *clksrc_to_pit_data(struct clocksource *clksrc)\n{\n\treturn container_of(clksrc, struct pit_data, clksrc);\n}\n\nstatic inline struct pit_data *clkevt_to_pit_data(struct clock_event_device *clkevt)\n{\n\treturn container_of(clkevt, struct pit_data, clkevt);\n}\n\nstatic inline unsigned int pit_read(void __iomem *base, unsigned int reg_offset)\n{\n\treturn readl_relaxed(base + reg_offset);\n}\n\nstatic inline void pit_write(void __iomem *base, unsigned int reg_offset, unsigned long value)\n{\n\twritel_relaxed(value, base + reg_offset);\n}\n\n \nstatic u64 read_pit_clk(struct clocksource *cs)\n{\n\tstruct pit_data *data = clksrc_to_pit_data(cs);\n\tunsigned long flags;\n\tu32 elapsed;\n\tu32 t;\n\n\traw_local_irq_save(flags);\n\telapsed = data->cnt;\n\tt = pit_read(data->base, AT91_PIT_PIIR);\n\traw_local_irq_restore(flags);\n\n\telapsed += PIT_PICNT(t) * data->cycle;\n\telapsed += PIT_CPIV(t);\n\treturn elapsed;\n}\n\nstatic int pit_clkevt_shutdown(struct clock_event_device *dev)\n{\n\tstruct pit_data *data = clkevt_to_pit_data(dev);\n\n\t \n\tpit_write(data->base, AT91_PIT_MR, (data->cycle - 1) | AT91_PIT_PITEN);\n\treturn 0;\n}\n\n \nstatic int pit_clkevt_set_periodic(struct clock_event_device *dev)\n{\n\tstruct pit_data *data = clkevt_to_pit_data(dev);\n\n\t \n\tdata->cnt += data->cycle * PIT_PICNT(pit_read(data->base, AT91_PIT_PIVR));\n\tpit_write(data->base, AT91_PIT_MR,\n\t\t  (data->cycle - 1) | AT91_PIT_PITEN | AT91_PIT_PITIEN);\n\treturn 0;\n}\n\nstatic void at91sam926x_pit_suspend(struct clock_event_device *cedev)\n{\n\tstruct pit_data *data = clkevt_to_pit_data(cedev);\n\n\t \n\tpit_write(data->base, AT91_PIT_MR, 0);\n}\n\nstatic void at91sam926x_pit_reset(struct pit_data *data)\n{\n\t \n\tpit_write(data->base, AT91_PIT_MR, 0);\n\n\t \n\twhile (PIT_CPIV(pit_read(data->base, AT91_PIT_PIVR)) != 0)\n\t\tcpu_relax();\n\n\t \n\tpit_write(data->base, AT91_PIT_MR,\n\t\t  (data->cycle - 1) | AT91_PIT_PITEN);\n}\n\nstatic void at91sam926x_pit_resume(struct clock_event_device *cedev)\n{\n\tstruct pit_data *data = clkevt_to_pit_data(cedev);\n\n\tat91sam926x_pit_reset(data);\n}\n\n \nstatic irqreturn_t at91sam926x_pit_interrupt(int irq, void *dev_id)\n{\n\tstruct pit_data *data = dev_id;\n\n\t \n\tif (clockevent_state_periodic(&data->clkevt) &&\n\t    (pit_read(data->base, AT91_PIT_SR) & AT91_PIT_PITS)) {\n\t\t \n\t\tdata->cnt += data->cycle * PIT_PICNT(pit_read(data->base,\n\t\t\t\t\t\t\t      AT91_PIT_PIVR));\n\t\tdata->clkevt.event_handler(&data->clkevt);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int __init at91sam926x_pit_dt_init(struct device_node *node)\n{\n\tunsigned long   pit_rate;\n\tunsigned        bits;\n\tint             ret;\n\tstruct pit_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->base = of_iomap(node, 0);\n\tif (!data->base) {\n\t\tpr_err(\"Could not map PIT address\\n\");\n\t\tret = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\tdata->mck = of_clk_get(node, 0);\n\tif (IS_ERR(data->mck)) {\n\t\tpr_err(\"Unable to get mck clk\\n\");\n\t\tret = PTR_ERR(data->mck);\n\t\tgoto exit;\n\t}\n\n\tret = clk_prepare_enable(data->mck);\n\tif (ret) {\n\t\tpr_err(\"Unable to enable mck\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tdata->irq = irq_of_parse_and_map(node, 0);\n\tif (!data->irq) {\n\t\tpr_err(\"Unable to get IRQ from DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tpit_rate = clk_get_rate(data->mck) / 16;\n\tdata->cycle = DIV_ROUND_CLOSEST(pit_rate, HZ);\n\tWARN_ON(((data->cycle - 1) & ~AT91_PIT_PIV) != 0);\n\n\t \n\tat91sam926x_pit_reset(data);\n\n\t \n\tbits = 12   + ilog2(data->cycle)  ;\n\tdata->clksrc.mask = CLOCKSOURCE_MASK(bits);\n\tdata->clksrc.name = \"pit\";\n\tdata->clksrc.rating = 175;\n\tdata->clksrc.read = read_pit_clk;\n\tdata->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\t\n\tret = clocksource_register_hz(&data->clksrc, pit_rate);\n\tif (ret) {\n\t\tpr_err(\"Failed to register clocksource\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tret = request_irq(data->irq, at91sam926x_pit_interrupt,\n\t\t\t  IRQF_SHARED | IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t  \"at91_tick\", data);\n\tif (ret) {\n\t\tpr_err(\"Unable to setup IRQ\\n\");\n\t\tclocksource_unregister(&data->clksrc);\n\t\tgoto exit;\n\t}\n\n\t \n\tdata->clkevt.name = \"pit\";\n\tdata->clkevt.features = CLOCK_EVT_FEAT_PERIODIC;\n\tdata->clkevt.shift = 32;\n\tdata->clkevt.mult = div_sc(pit_rate, NSEC_PER_SEC, data->clkevt.shift);\n\tdata->clkevt.rating = 100;\n\tdata->clkevt.cpumask = cpumask_of(0);\n\n\tdata->clkevt.set_state_shutdown = pit_clkevt_shutdown;\n\tdata->clkevt.set_state_periodic = pit_clkevt_set_periodic;\n\tdata->clkevt.resume = at91sam926x_pit_resume;\n\tdata->clkevt.suspend = at91sam926x_pit_suspend;\n\tclockevents_register_device(&data->clkevt);\n\n\treturn 0;\n\nexit:\n\tkfree(data);\n\treturn ret;\n}\nTIMER_OF_DECLARE(at91sam926x_pit, \"atmel,at91sam9260-pit\",\n\t\t       at91sam926x_pit_dt_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}