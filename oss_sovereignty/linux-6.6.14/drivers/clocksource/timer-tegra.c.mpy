{
  "module_name": "timer-tegra.c",
  "hash_id": "44a07c3bc37ccc5110a5269f0184b9f65da2f0dc9b841c2a7bbb94f9b16d57c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-tegra.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"tegra-timer: \" fmt\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/percpu.h>\n#include <linux/sched_clock.h>\n#include <linux/time.h>\n\n#include \"timer-of.h\"\n\n#define RTC_SECONDS\t\t0x08\n#define RTC_SHADOW_SECONDS\t0x0c\n#define RTC_MILLISECONDS\t0x10\n\n#define TIMERUS_CNTR_1US\t0x10\n#define TIMERUS_USEC_CFG\t0x14\n#define TIMERUS_CNTR_FREEZE\t0x4c\n\n#define TIMER_PTV\t\t0x0\n#define TIMER_PTV_EN\t\tBIT(31)\n#define TIMER_PTV_PER\t\tBIT(30)\n#define TIMER_PCR\t\t0x4\n#define TIMER_PCR_INTR_CLR\tBIT(30)\n\n#define TIMER1_BASE\t\t0x00\n#define TIMER2_BASE\t\t0x08\n#define TIMER3_BASE\t\t0x50\n#define TIMER4_BASE\t\t0x58\n#define TIMER10_BASE\t\t0x90\n\n#define TIMER1_IRQ_IDX\t\t0\n#define TIMER10_IRQ_IDX\t\t10\n\n#define TIMER_1MHz\t\t1000000\n\nstatic u32 usec_config;\nstatic void __iomem *timer_reg_base;\n\nstatic int tegra_timer_set_next_event(unsigned long cycles,\n\t\t\t\t      struct clock_event_device *evt)\n{\n\tvoid __iomem *reg_base = timer_of_base(to_timer_of(evt));\n\n\t \n\twritel_relaxed(TIMER_PTV_EN | (cycles - 1), reg_base + TIMER_PTV);\n\n\treturn 0;\n}\n\nstatic int tegra_timer_shutdown(struct clock_event_device *evt)\n{\n\tvoid __iomem *reg_base = timer_of_base(to_timer_of(evt));\n\n\twritel_relaxed(0, reg_base + TIMER_PTV);\n\n\treturn 0;\n}\n\nstatic int tegra_timer_set_periodic(struct clock_event_device *evt)\n{\n\tvoid __iomem *reg_base = timer_of_base(to_timer_of(evt));\n\tunsigned long period = timer_of_period(to_timer_of(evt));\n\n\twritel_relaxed(TIMER_PTV_EN | TIMER_PTV_PER | (period - 1),\n\t\t       reg_base + TIMER_PTV);\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_timer_isr(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\tvoid __iomem *reg_base = timer_of_base(to_timer_of(evt));\n\n\twritel_relaxed(TIMER_PCR_INTR_CLR, reg_base + TIMER_PCR);\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_timer_suspend(struct clock_event_device *evt)\n{\n\tvoid __iomem *reg_base = timer_of_base(to_timer_of(evt));\n\n\twritel_relaxed(TIMER_PCR_INTR_CLR, reg_base + TIMER_PCR);\n}\n\nstatic void tegra_timer_resume(struct clock_event_device *evt)\n{\n\twritel_relaxed(usec_config, timer_reg_base + TIMERUS_USEC_CFG);\n}\n\nstatic DEFINE_PER_CPU(struct timer_of, tegra_to) = {\n\t.flags = TIMER_OF_CLOCK | TIMER_OF_BASE,\n\n\t.clkevt = {\n\t\t.name = \"tegra_timer\",\n\t\t.features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,\n\t\t.set_next_event = tegra_timer_set_next_event,\n\t\t.set_state_shutdown = tegra_timer_shutdown,\n\t\t.set_state_periodic = tegra_timer_set_periodic,\n\t\t.set_state_oneshot = tegra_timer_shutdown,\n\t\t.tick_resume = tegra_timer_shutdown,\n\t\t.suspend = tegra_timer_suspend,\n\t\t.resume = tegra_timer_resume,\n\t},\n};\n\nstatic int tegra_timer_setup(unsigned int cpu)\n{\n\tstruct timer_of *to = per_cpu_ptr(&tegra_to, cpu);\n\n\twritel_relaxed(0, timer_of_base(to) + TIMER_PTV);\n\twritel_relaxed(TIMER_PCR_INTR_CLR, timer_of_base(to) + TIMER_PCR);\n\n\tirq_force_affinity(to->clkevt.irq, cpumask_of(cpu));\n\tenable_irq(to->clkevt.irq);\n\n\t \n\tclockevents_config_and_register(&to->clkevt, timer_of_rate(to),\n\t\t\t\t\t1,  \n\t\t\t\t\t0x1fffffff + 1);  \n\n\treturn 0;\n}\n\nstatic int tegra_timer_stop(unsigned int cpu)\n{\n\tstruct timer_of *to = per_cpu_ptr(&tegra_to, cpu);\n\n\tto->clkevt.set_state_shutdown(&to->clkevt);\n\tdisable_irq_nosync(to->clkevt.irq);\n\n\treturn 0;\n}\n\nstatic u64 notrace tegra_read_sched_clock(void)\n{\n\treturn readl_relaxed(timer_reg_base + TIMERUS_CNTR_1US);\n}\n\n#ifdef CONFIG_ARM\nstatic unsigned long tegra_delay_timer_read_counter_long(void)\n{\n\treturn readl_relaxed(timer_reg_base + TIMERUS_CNTR_1US);\n}\n\nstatic struct delay_timer tegra_delay_timer = {\n\t.read_current_timer = tegra_delay_timer_read_counter_long,\n\t.freq = TIMER_1MHz,\n};\n#endif\n\nstatic struct timer_of suspend_rtc_to = {\n\t.flags = TIMER_OF_BASE | TIMER_OF_CLOCK,\n};\n\n \nstatic u64 tegra_rtc_read_ms(struct clocksource *cs)\n{\n\tvoid __iomem *reg_base = timer_of_base(&suspend_rtc_to);\n\n\tu32 ms = readl_relaxed(reg_base + RTC_MILLISECONDS);\n\tu32 s = readl_relaxed(reg_base + RTC_SHADOW_SECONDS);\n\n\treturn (u64)s * MSEC_PER_SEC + ms;\n}\n\nstatic struct clocksource suspend_rtc_clocksource = {\n\t.name\t= \"tegra_suspend_timer\",\n\t.rating\t= 200,\n\t.read\t= tegra_rtc_read_ms,\n\t.mask\t= CLOCKSOURCE_MASK(32),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_SUSPEND_NONSTOP,\n};\n\nstatic inline unsigned int tegra_base_for_cpu(int cpu, bool tegra20)\n{\n\tif (tegra20) {\n\t\tswitch (cpu) {\n\t\tcase 0:\n\t\t\treturn TIMER1_BASE;\n\t\tcase 1:\n\t\t\treturn TIMER2_BASE;\n\t\tcase 2:\n\t\t\treturn TIMER3_BASE;\n\t\tdefault:\n\t\t\treturn TIMER4_BASE;\n\t\t}\n\t}\n\n\treturn TIMER10_BASE + cpu * 8;\n}\n\nstatic inline unsigned int tegra_irq_idx_for_cpu(int cpu, bool tegra20)\n{\n\tif (tegra20)\n\t\treturn TIMER1_IRQ_IDX + cpu;\n\n\treturn TIMER10_IRQ_IDX + cpu;\n}\n\nstatic inline unsigned long tegra_rate_for_timer(struct timer_of *to,\n\t\t\t\t\t\t bool tegra20)\n{\n\t \n\tif (tegra20)\n\t\treturn TIMER_1MHz;\n\n\treturn timer_of_rate(to);\n}\n\nstatic int __init tegra_init_timer(struct device_node *np, bool tegra20,\n\t\t\t\t   int rating)\n{\n\tstruct timer_of *to;\n\tint cpu, ret;\n\n\tto = this_cpu_ptr(&tegra_to);\n\tret = timer_of_init(np, to);\n\tif (ret)\n\t\tgoto out;\n\n\ttimer_reg_base = timer_of_base(to);\n\n\t \n\tswitch (timer_of_rate(to)) {\n\tcase 12000000:\n\t\tusec_config = 0x000b;  \n\t\tbreak;\n\tcase 12800000:\n\t\tusec_config = 0x043f;  \n\t\tbreak;\n\tcase 13000000:\n\t\tusec_config = 0x000c;  \n\t\tbreak;\n\tcase 16800000:\n\t\tusec_config = 0x0453;  \n\t\tbreak;\n\tcase 19200000:\n\t\tusec_config = 0x045f;  \n\t\tbreak;\n\tcase 26000000:\n\t\tusec_config = 0x0019;  \n\t\tbreak;\n\tcase 38400000:\n\t\tusec_config = 0x04bf;  \n\t\tbreak;\n\tcase 48000000:\n\t\tusec_config = 0x002f;  \n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twritel_relaxed(usec_config, timer_reg_base + TIMERUS_USEC_CFG);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct timer_of *cpu_to = per_cpu_ptr(&tegra_to, cpu);\n\t\tunsigned long flags = IRQF_TIMER | IRQF_NOBALANCING;\n\t\tunsigned long rate = tegra_rate_for_timer(to, tegra20);\n\t\tunsigned int base = tegra_base_for_cpu(cpu, tegra20);\n\t\tunsigned int idx = tegra_irq_idx_for_cpu(cpu, tegra20);\n\t\tunsigned int irq = irq_of_parse_and_map(np, idx);\n\n\t\tif (!irq) {\n\t\t\tpr_err(\"failed to map irq for cpu%d\\n\", cpu);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_irq;\n\t\t}\n\n\t\tcpu_to->clkevt.irq = irq;\n\t\tcpu_to->clkevt.rating = rating;\n\t\tcpu_to->clkevt.cpumask = cpumask_of(cpu);\n\t\tcpu_to->of_base.base = timer_reg_base + base;\n\t\tcpu_to->of_clk.period = rate / HZ;\n\t\tcpu_to->of_clk.rate = rate;\n\n\t\tirq_set_status_flags(cpu_to->clkevt.irq, IRQ_NOAUTOEN);\n\n\t\tret = request_irq(cpu_to->clkevt.irq, tegra_timer_isr, flags,\n\t\t\t\t  cpu_to->clkevt.name, &cpu_to->clkevt);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set up irq for cpu%d: %d\\n\",\n\t\t\t       cpu, ret);\n\t\t\tirq_dispose_mapping(cpu_to->clkevt.irq);\n\t\t\tcpu_to->clkevt.irq = 0;\n\t\t\tgoto out_irq;\n\t\t}\n\t}\n\n\tsched_clock_register(tegra_read_sched_clock, 32, TIMER_1MHz);\n\n\tret = clocksource_mmio_init(timer_reg_base + TIMERUS_CNTR_1US,\n\t\t\t\t    \"timer_us\", TIMER_1MHz, 300, 32,\n\t\t\t\t    clocksource_mmio_readl_up);\n\tif (ret)\n\t\tpr_err(\"failed to register clocksource: %d\\n\", ret);\n\n#ifdef CONFIG_ARM\n\tregister_current_timer_delay(&tegra_delay_timer);\n#endif\n\n\tret = cpuhp_setup_state(CPUHP_AP_TEGRA_TIMER_STARTING,\n\t\t\t\t\"AP_TEGRA_TIMER_STARTING\", tegra_timer_setup,\n\t\t\t\ttegra_timer_stop);\n\tif (ret)\n\t\tpr_err(\"failed to set up cpu hp state: %d\\n\", ret);\n\n\treturn ret;\n\nout_irq:\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct timer_of *cpu_to;\n\n\t\tcpu_to = per_cpu_ptr(&tegra_to, cpu);\n\t\tif (cpu_to->clkevt.irq) {\n\t\t\tfree_irq(cpu_to->clkevt.irq, &cpu_to->clkevt);\n\t\t\tirq_dispose_mapping(cpu_to->clkevt.irq);\n\t\t}\n\t}\n\n\tto->of_base.base = timer_reg_base;\nout:\n\ttimer_of_cleanup(to);\n\n\treturn ret;\n}\n\nstatic int __init tegra210_init_timer(struct device_node *np)\n{\n\t \n\treturn tegra_init_timer(np, false, 460);\n}\nTIMER_OF_DECLARE(tegra210_timer, \"nvidia,tegra210-timer\", tegra210_init_timer);\n\nstatic int __init tegra20_init_timer(struct device_node *np)\n{\n\tint rating;\n\n\t \n\tif (of_machine_is_compatible(\"nvidia,tegra20\") ||\n\t    of_machine_is_compatible(\"nvidia,tegra30\"))\n\t\trating = 460;\n\telse\n\t\trating = 330;\n\n\treturn tegra_init_timer(np, true, rating);\n}\nTIMER_OF_DECLARE(tegra20_timer, \"nvidia,tegra20-timer\", tegra20_init_timer);\n\nstatic int __init tegra20_init_rtc(struct device_node *np)\n{\n\tint ret;\n\n\tret = timer_of_init(np, &suspend_rtc_to);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clocksource_register_hz(&suspend_rtc_clocksource, 1000);\n}\nTIMER_OF_DECLARE(tegra20_rtc, \"nvidia,tegra20-rtc\", tegra20_init_rtc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}