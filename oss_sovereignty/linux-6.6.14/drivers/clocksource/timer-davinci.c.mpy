{
  "module_name": "timer-davinci.c",
  "hash_id": "a73bdd1c0e950877463faeb3711ceead559346a8dcdc39e3cf562b649f4ec59b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-davinci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#include <clocksource/timer-davinci.h>\n\n#define DAVINCI_TIMER_REG_TIM12\t\t\t0x10\n#define DAVINCI_TIMER_REG_TIM34\t\t\t0x14\n#define DAVINCI_TIMER_REG_PRD12\t\t\t0x18\n#define DAVINCI_TIMER_REG_PRD34\t\t\t0x1c\n#define DAVINCI_TIMER_REG_TCR\t\t\t0x20\n#define DAVINCI_TIMER_REG_TGCR\t\t\t0x24\n\n#define DAVINCI_TIMER_TIMMODE_MASK\t\tGENMASK(3, 2)\n#define DAVINCI_TIMER_RESET_MASK\t\tGENMASK(1, 0)\n#define DAVINCI_TIMER_TIMMODE_32BIT_UNCHAINED\tBIT(2)\n#define DAVINCI_TIMER_UNRESET\t\t\tGENMASK(1, 0)\n\n#define DAVINCI_TIMER_ENAMODE_MASK\t\tGENMASK(1, 0)\n#define DAVINCI_TIMER_ENAMODE_DISABLED\t\t0x00\n#define DAVINCI_TIMER_ENAMODE_ONESHOT\t\tBIT(0)\n#define DAVINCI_TIMER_ENAMODE_PERIODIC\t\tBIT(1)\n\n#define DAVINCI_TIMER_ENAMODE_SHIFT_TIM12\t6\n#define DAVINCI_TIMER_ENAMODE_SHIFT_TIM34\t22\n\n#define DAVINCI_TIMER_MIN_DELTA\t\t\t0x01\n#define DAVINCI_TIMER_MAX_DELTA\t\t\t0xfffffffe\n\n#define DAVINCI_TIMER_CLKSRC_BITS\t\t32\n\n#define DAVINCI_TIMER_TGCR_DEFAULT \\\n\t\t(DAVINCI_TIMER_TIMMODE_32BIT_UNCHAINED | DAVINCI_TIMER_UNRESET)\n\nstruct davinci_clockevent {\n\tstruct clock_event_device dev;\n\tvoid __iomem *base;\n\tunsigned int cmp_off;\n};\n\n \nstatic struct {\n\tstruct clocksource dev;\n\tvoid __iomem *base;\n\tunsigned int tim_off;\n} davinci_clocksource;\n\nstatic struct davinci_clockevent *\nto_davinci_clockevent(struct clock_event_device *clockevent)\n{\n\treturn container_of(clockevent, struct davinci_clockevent, dev);\n}\n\nstatic unsigned int\ndavinci_clockevent_read(struct davinci_clockevent *clockevent,\n\t\t\tunsigned int reg)\n{\n\treturn readl_relaxed(clockevent->base + reg);\n}\n\nstatic void davinci_clockevent_write(struct davinci_clockevent *clockevent,\n\t\t\t\t     unsigned int reg, unsigned int val)\n{\n\twritel_relaxed(val, clockevent->base + reg);\n}\n\nstatic void davinci_tim12_shutdown(void __iomem *base)\n{\n\tunsigned int tcr;\n\n\ttcr = DAVINCI_TIMER_ENAMODE_DISABLED <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM12;\n\t \n\ttcr |= DAVINCI_TIMER_ENAMODE_PERIODIC <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM34;\n\n\twritel_relaxed(tcr, base + DAVINCI_TIMER_REG_TCR);\n}\n\nstatic void davinci_tim12_set_oneshot(void __iomem *base)\n{\n\tunsigned int tcr;\n\n\ttcr = DAVINCI_TIMER_ENAMODE_ONESHOT <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM12;\n\t \n\ttcr |= DAVINCI_TIMER_ENAMODE_PERIODIC <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM34;\n\n\twritel_relaxed(tcr, base + DAVINCI_TIMER_REG_TCR);\n}\n\nstatic int davinci_clockevent_shutdown(struct clock_event_device *dev)\n{\n\tstruct davinci_clockevent *clockevent;\n\n\tclockevent = to_davinci_clockevent(dev);\n\n\tdavinci_tim12_shutdown(clockevent->base);\n\n\treturn 0;\n}\n\nstatic int davinci_clockevent_set_oneshot(struct clock_event_device *dev)\n{\n\tstruct davinci_clockevent *clockevent = to_davinci_clockevent(dev);\n\n\tdavinci_clockevent_write(clockevent, DAVINCI_TIMER_REG_TIM12, 0x0);\n\n\tdavinci_tim12_set_oneshot(clockevent->base);\n\n\treturn 0;\n}\n\nstatic int\ndavinci_clockevent_set_next_event_std(unsigned long cycles,\n\t\t\t\t      struct clock_event_device *dev)\n{\n\tstruct davinci_clockevent *clockevent = to_davinci_clockevent(dev);\n\n\tdavinci_clockevent_shutdown(dev);\n\n\tdavinci_clockevent_write(clockevent, DAVINCI_TIMER_REG_TIM12, 0x0);\n\tdavinci_clockevent_write(clockevent, DAVINCI_TIMER_REG_PRD12, cycles);\n\n\tdavinci_clockevent_set_oneshot(dev);\n\n\treturn 0;\n}\n\nstatic int\ndavinci_clockevent_set_next_event_cmp(unsigned long cycles,\n\t\t\t\t      struct clock_event_device *dev)\n{\n\tstruct davinci_clockevent *clockevent = to_davinci_clockevent(dev);\n\tunsigned int curr_time;\n\n\tcurr_time = davinci_clockevent_read(clockevent,\n\t\t\t\t\t    DAVINCI_TIMER_REG_TIM12);\n\tdavinci_clockevent_write(clockevent,\n\t\t\t\t clockevent->cmp_off, curr_time + cycles);\n\n\treturn 0;\n}\n\nstatic irqreturn_t davinci_timer_irq_timer(int irq, void *data)\n{\n\tstruct davinci_clockevent *clockevent = data;\n\n\tif (!clockevent_state_oneshot(&clockevent->dev))\n\t\tdavinci_tim12_shutdown(clockevent->base);\n\n\tclockevent->dev.event_handler(&clockevent->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 notrace davinci_timer_read_sched_clock(void)\n{\n\treturn readl_relaxed(davinci_clocksource.base +\n\t\t\t     davinci_clocksource.tim_off);\n}\n\nstatic u64 davinci_clocksource_read(struct clocksource *dev)\n{\n\treturn davinci_timer_read_sched_clock();\n}\n\n \nstatic void davinci_clocksource_init_tim34(void __iomem *base)\n{\n\tint tcr;\n\n\ttcr = DAVINCI_TIMER_ENAMODE_PERIODIC <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM34;\n\ttcr |= DAVINCI_TIMER_ENAMODE_ONESHOT <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM12;\n\n\twritel_relaxed(0x0, base + DAVINCI_TIMER_REG_TIM34);\n\twritel_relaxed(UINT_MAX, base + DAVINCI_TIMER_REG_PRD34);\n\twritel_relaxed(tcr, base + DAVINCI_TIMER_REG_TCR);\n}\n\n \nstatic void davinci_clocksource_init_tim12(void __iomem *base)\n{\n\tunsigned int tcr;\n\n\ttcr = DAVINCI_TIMER_ENAMODE_PERIODIC <<\n\t\tDAVINCI_TIMER_ENAMODE_SHIFT_TIM12;\n\n\twritel_relaxed(0x0, base + DAVINCI_TIMER_REG_TIM12);\n\twritel_relaxed(UINT_MAX, base + DAVINCI_TIMER_REG_PRD12);\n\twritel_relaxed(tcr, base + DAVINCI_TIMER_REG_TCR);\n}\n\nstatic void davinci_timer_init(void __iomem *base)\n{\n\t \n\twritel_relaxed(0x0, base + DAVINCI_TIMER_REG_TCR);\n\t \n\twritel_relaxed(DAVINCI_TIMER_TGCR_DEFAULT,\n\t\t       base + DAVINCI_TIMER_REG_TGCR);\n\t \n\twritel_relaxed(0x0, base + DAVINCI_TIMER_REG_TIM12);\n\twritel_relaxed(0x0, base + DAVINCI_TIMER_REG_TIM34);\n}\n\nint __init davinci_timer_register(struct clk *clk,\n\t\t\t\t  const struct davinci_timer_cfg *timer_cfg)\n{\n\tstruct davinci_clockevent *clockevent;\n\tunsigned int tick_rate;\n\tvoid __iomem *base;\n\tint rv;\n\n\trv = clk_prepare_enable(clk);\n\tif (rv) {\n\t\tpr_err(\"Unable to prepare and enable the timer clock\\n\");\n\t\treturn rv;\n\t}\n\n\tif (!request_mem_region(timer_cfg->reg.start,\n\t\t\t\tresource_size(&timer_cfg->reg),\n\t\t\t\t\"davinci-timer\")) {\n\t\tpr_err(\"Unable to request memory region\\n\");\n\t\trv = -EBUSY;\n\t\tgoto exit_clk_disable;\n\t}\n\n\tbase = ioremap(timer_cfg->reg.start, resource_size(&timer_cfg->reg));\n\tif (!base) {\n\t\tpr_err(\"Unable to map the register range\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto exit_mem_region;\n\t}\n\n\tdavinci_timer_init(base);\n\ttick_rate = clk_get_rate(clk);\n\n\tclockevent = kzalloc(sizeof(*clockevent), GFP_KERNEL);\n\tif (!clockevent) {\n\t\trv = -ENOMEM;\n\t\tgoto exit_iounmap_base;\n\t}\n\n\tclockevent->dev.name = \"tim12\";\n\tclockevent->dev.features = CLOCK_EVT_FEAT_ONESHOT;\n\tclockevent->dev.cpumask = cpumask_of(0);\n\tclockevent->base = base;\n\n\tif (timer_cfg->cmp_off) {\n\t\tclockevent->cmp_off = timer_cfg->cmp_off;\n\t\tclockevent->dev.set_next_event =\n\t\t\t\tdavinci_clockevent_set_next_event_cmp;\n\t} else {\n\t\tclockevent->dev.set_next_event =\n\t\t\t\tdavinci_clockevent_set_next_event_std;\n\t\tclockevent->dev.set_state_oneshot =\n\t\t\t\tdavinci_clockevent_set_oneshot;\n\t\tclockevent->dev.set_state_shutdown =\n\t\t\t\tdavinci_clockevent_shutdown;\n\t}\n\n\trv = request_irq(timer_cfg->irq[DAVINCI_TIMER_CLOCKEVENT_IRQ].start,\n\t\t\t davinci_timer_irq_timer, IRQF_TIMER,\n\t\t\t \"clockevent/tim12\", clockevent);\n\tif (rv) {\n\t\tpr_err(\"Unable to request the clockevent interrupt\\n\");\n\t\tgoto exit_free_clockevent;\n\t}\n\n\tdavinci_clocksource.dev.rating = 300;\n\tdavinci_clocksource.dev.read = davinci_clocksource_read;\n\tdavinci_clocksource.dev.mask =\n\t\t\tCLOCKSOURCE_MASK(DAVINCI_TIMER_CLKSRC_BITS);\n\tdavinci_clocksource.dev.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\tdavinci_clocksource.base = base;\n\n\tif (timer_cfg->cmp_off) {\n\t\tdavinci_clocksource.dev.name = \"tim12\";\n\t\tdavinci_clocksource.tim_off = DAVINCI_TIMER_REG_TIM12;\n\t\tdavinci_clocksource_init_tim12(base);\n\t} else {\n\t\tdavinci_clocksource.dev.name = \"tim34\";\n\t\tdavinci_clocksource.tim_off = DAVINCI_TIMER_REG_TIM34;\n\t\tdavinci_clocksource_init_tim34(base);\n\t}\n\n\tclockevents_config_and_register(&clockevent->dev, tick_rate,\n\t\t\t\t\tDAVINCI_TIMER_MIN_DELTA,\n\t\t\t\t\tDAVINCI_TIMER_MAX_DELTA);\n\n\trv = clocksource_register_hz(&davinci_clocksource.dev, tick_rate);\n\tif (rv) {\n\t\tpr_err(\"Unable to register clocksource\\n\");\n\t\tgoto exit_free_irq;\n\t}\n\n\tsched_clock_register(davinci_timer_read_sched_clock,\n\t\t\t     DAVINCI_TIMER_CLKSRC_BITS, tick_rate);\n\n\treturn 0;\n\nexit_free_irq:\n\tfree_irq(timer_cfg->irq[DAVINCI_TIMER_CLOCKEVENT_IRQ].start,\n\t\t\tclockevent);\nexit_free_clockevent:\n\tkfree(clockevent);\nexit_iounmap_base:\n\tiounmap(base);\nexit_mem_region:\n\trelease_mem_region(timer_cfg->reg.start,\n\t\t\t   resource_size(&timer_cfg->reg));\nexit_clk_disable:\n\tclk_disable_unprepare(clk);\n\treturn rv;\n}\n\nstatic int __init of_davinci_timer_register(struct device_node *np)\n{\n\tstruct davinci_timer_cfg timer_cfg = { };\n\tstruct clk *clk;\n\tint rv;\n\n\trv = of_address_to_resource(np, 0, &timer_cfg.reg);\n\tif (rv) {\n\t\tpr_err(\"Unable to get the register range for timer\\n\");\n\t\treturn rv;\n\t}\n\n\trv = of_irq_to_resource_table(np, timer_cfg.irq,\n\t\t\t\t      DAVINCI_TIMER_NUM_IRQS);\n\tif (rv != DAVINCI_TIMER_NUM_IRQS) {\n\t\tpr_err(\"Unable to get the interrupts for timer\\n\");\n\t\treturn rv;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Unable to get the timer clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\trv = davinci_timer_register(clk, &timer_cfg);\n\tif (rv)\n\t\tclk_put(clk);\n\n\treturn rv;\n}\nTIMER_OF_DECLARE(davinci_timer, \"ti,da830-timer\", of_davinci_timer_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}