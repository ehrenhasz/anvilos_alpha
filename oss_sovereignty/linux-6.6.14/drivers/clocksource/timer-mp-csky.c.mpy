{
  "module_name": "timer-mp-csky.c",
  "hash_id": "44f147438c8d32f07ccb833c3072f206104b439f9632fdf0ae44eb87e6e3d4d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-mp-csky.c",
  "human_readable_source": "\n\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/sched_clock.h>\n#include <linux/cpu.h>\n#include <linux/of_irq.h>\n#include <asm/reg_ops.h>\n\n#include \"timer-of.h\"\n\n#define PTIM_CCVR\t\"cr<3, 14>\"\n#define PTIM_CTLR\t\"cr<0, 14>\"\n#define PTIM_LVR\t\"cr<6, 14>\"\n#define PTIM_TSR\t\"cr<1, 14>\"\n\nstatic int csky_mptimer_irq;\n\nstatic int csky_mptimer_set_next_event(unsigned long delta,\n\t\t\t\t       struct clock_event_device *ce)\n{\n\tmtcr(PTIM_LVR, delta);\n\n\treturn 0;\n}\n\nstatic int csky_mptimer_shutdown(struct clock_event_device *ce)\n{\n\tmtcr(PTIM_CTLR, 0);\n\n\treturn 0;\n}\n\nstatic int csky_mptimer_oneshot(struct clock_event_device *ce)\n{\n\tmtcr(PTIM_CTLR, 1);\n\n\treturn 0;\n}\n\nstatic int csky_mptimer_oneshot_stopped(struct clock_event_device *ce)\n{\n\tmtcr(PTIM_CTLR, 0);\n\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(struct timer_of, csky_to) = {\n\t.flags\t\t\t\t\t= TIMER_OF_CLOCK,\n\t.clkevt = {\n\t\t.rating\t\t\t\t= 300,\n\t\t.features\t\t\t= CLOCK_EVT_FEAT_PERCPU |\n\t\t\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t\t.set_state_shutdown\t\t= csky_mptimer_shutdown,\n\t\t.set_state_oneshot\t\t= csky_mptimer_oneshot,\n\t\t.set_state_oneshot_stopped\t= csky_mptimer_oneshot_stopped,\n\t\t.set_next_event\t\t\t= csky_mptimer_set_next_event,\n\t},\n};\n\nstatic irqreturn_t csky_timer_interrupt(int irq, void *dev)\n{\n\tstruct timer_of *to = this_cpu_ptr(&csky_to);\n\n\tmtcr(PTIM_TSR, 0);\n\n\tto->clkevt.event_handler(&to->clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int csky_mptimer_starting_cpu(unsigned int cpu)\n{\n\tstruct timer_of *to = per_cpu_ptr(&csky_to, cpu);\n\n\tto->clkevt.cpumask = cpumask_of(cpu);\n\n\tenable_percpu_irq(csky_mptimer_irq, 0);\n\n\tclockevents_config_and_register(&to->clkevt, timer_of_rate(to),\n\t\t\t\t\t2, ULONG_MAX);\n\n\treturn 0;\n}\n\nstatic int csky_mptimer_dying_cpu(unsigned int cpu)\n{\n\tdisable_percpu_irq(csky_mptimer_irq);\n\n\treturn 0;\n}\n\n \nstatic u64 notrace sched_clock_read(void)\n{\n\treturn (u64)mfcr(PTIM_CCVR);\n}\n\nstatic u64 clksrc_read(struct clocksource *c)\n{\n\treturn (u64)mfcr(PTIM_CCVR);\n}\n\nstruct clocksource csky_clocksource = {\n\t.name\t= \"csky\",\n\t.rating\t= 400,\n\t.mask\t= CLOCKSOURCE_MASK(32),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.read\t= clksrc_read,\n};\n\nstatic int __init csky_mptimer_init(struct device_node *np)\n{\n\tint ret, cpu, cpu_rollback;\n\tstruct timer_of *to = NULL;\n\n\t \n\tcsky_mptimer_irq = irq_of_parse_and_map(np, 0);\n\tif (csky_mptimer_irq <= 0)\n\t\treturn -EINVAL;\n\n\tret = request_percpu_irq(csky_mptimer_irq, csky_timer_interrupt,\n\t\t\t\t \"csky_mp_timer\", &csky_to);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tto = per_cpu_ptr(&csky_to, cpu);\n\t\tret = timer_of_init(np, to);\n\t\tif (ret)\n\t\t\tgoto rollback;\n\t}\n\n\tclocksource_register_hz(&csky_clocksource, timer_of_rate(to));\n\tsched_clock_register(sched_clock_read, 32, timer_of_rate(to));\n\n\tret = cpuhp_setup_state(CPUHP_AP_CSKY_TIMER_STARTING,\n\t\t\t\t\"clockevents/csky/timer:starting\",\n\t\t\t\tcsky_mptimer_starting_cpu,\n\t\t\t\tcsky_mptimer_dying_cpu);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n\nrollback:\n\tfor_each_possible_cpu(cpu_rollback) {\n\t\tif (cpu_rollback == cpu)\n\t\t\tbreak;\n\n\t\tto = per_cpu_ptr(&csky_to, cpu_rollback);\n\t\ttimer_of_cleanup(to);\n\t}\n\treturn -EINVAL;\n}\nTIMER_OF_DECLARE(csky_mptimer, \"csky,mptimer\", csky_mptimer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}