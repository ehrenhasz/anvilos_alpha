{
  "module_name": "timer-loongson1-pwm.c",
  "hash_id": "7e39967a9f32ccf37c3a4cf8b9ca848bd714bf2d4bf760b2154b514589cf6b95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-loongson1-pwm.c",
  "human_readable_source": "\n \n\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/sizes.h>\n#include \"timer-of.h\"\n\n \n#define PWM_CNTR\t\t0x0\n#define PWM_HRC\t\t\t0x4\n#define PWM_LRC\t\t\t0x8\n#define PWM_CTRL\t\t0xc\n\n \n#define INT_LRC_EN\t\tBIT(11)\n#define INT_HRC_EN\t\tBIT(10)\n#define CNTR_RST\t\tBIT(7)\n#define INT_SR\t\t\tBIT(6)\n#define INT_EN\t\t\tBIT(5)\n#define PWM_SINGLE\t\tBIT(4)\n#define PWM_OE\t\t\tBIT(3)\n#define CNT_EN\t\t\tBIT(0)\n\n#define CNTR_WIDTH\t\t24\n\nstatic DEFINE_RAW_SPINLOCK(ls1x_timer_lock);\n\nstruct ls1x_clocksource {\n\tvoid __iomem *reg_base;\n\tunsigned long ticks_per_jiffy;\n\tstruct clocksource clksrc;\n};\n\nstatic inline struct ls1x_clocksource *to_ls1x_clksrc(struct clocksource *c)\n{\n\treturn container_of(c, struct ls1x_clocksource, clksrc);\n}\n\nstatic inline void ls1x_pwmtimer_set_period(unsigned int period,\n\t\t\t\t\t    struct timer_of *to)\n{\n\twritel(period, timer_of_base(to) + PWM_LRC);\n\twritel(period, timer_of_base(to) + PWM_HRC);\n}\n\nstatic inline void ls1x_pwmtimer_clear(struct timer_of *to)\n{\n\twritel(0, timer_of_base(to) + PWM_CNTR);\n}\n\nstatic inline void ls1x_pwmtimer_start(struct timer_of *to)\n{\n\twritel((INT_EN | PWM_OE | CNT_EN), timer_of_base(to) + PWM_CTRL);\n}\n\nstatic inline void ls1x_pwmtimer_stop(struct timer_of *to)\n{\n\twritel(0, timer_of_base(to) + PWM_CTRL);\n}\n\nstatic inline void ls1x_pwmtimer_irq_ack(struct timer_of *to)\n{\n\tint val;\n\n\tval = readl(timer_of_base(to) + PWM_CTRL);\n\tval |= INT_SR;\n\twritel(val, timer_of_base(to) + PWM_CTRL);\n}\n\nstatic irqreturn_t ls1x_clockevent_isr(int irq, void *dev_id)\n{\n\tstruct clock_event_device *clkevt = dev_id;\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\tls1x_pwmtimer_irq_ack(to);\n\tls1x_pwmtimer_clear(to);\n\tls1x_pwmtimer_start(to);\n\n\tclkevt->event_handler(clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ls1x_clockevent_set_state_periodic(struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\traw_spin_lock(&ls1x_timer_lock);\n\tls1x_pwmtimer_set_period(timer_of_period(to), to);\n\tls1x_pwmtimer_clear(to);\n\tls1x_pwmtimer_start(to);\n\traw_spin_unlock(&ls1x_timer_lock);\n\n\treturn 0;\n}\n\nstatic int ls1x_clockevent_tick_resume(struct clock_event_device *clkevt)\n{\n\traw_spin_lock(&ls1x_timer_lock);\n\tls1x_pwmtimer_start(to_timer_of(clkevt));\n\traw_spin_unlock(&ls1x_timer_lock);\n\n\treturn 0;\n}\n\nstatic int ls1x_clockevent_set_state_shutdown(struct clock_event_device *clkevt)\n{\n\traw_spin_lock(&ls1x_timer_lock);\n\tls1x_pwmtimer_stop(to_timer_of(clkevt));\n\traw_spin_unlock(&ls1x_timer_lock);\n\n\treturn 0;\n}\n\nstatic int ls1x_clockevent_set_next(unsigned long evt,\n\t\t\t\t    struct clock_event_device *clkevt)\n{\n\tstruct timer_of *to = to_timer_of(clkevt);\n\n\traw_spin_lock(&ls1x_timer_lock);\n\tls1x_pwmtimer_set_period(evt, to);\n\tls1x_pwmtimer_clear(to);\n\tls1x_pwmtimer_start(to);\n\traw_spin_unlock(&ls1x_timer_lock);\n\n\treturn 0;\n}\n\nstatic struct timer_of ls1x_to = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE | TIMER_OF_CLOCK,\n\t.clkevt = {\n\t\t.name\t\t\t= \"ls1x-pwmtimer\",\n\t\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t\t.rating\t\t\t= 300,\n\t\t.set_next_event\t\t= ls1x_clockevent_set_next,\n\t\t.set_state_periodic\t= ls1x_clockevent_set_state_periodic,\n\t\t.set_state_oneshot\t= ls1x_clockevent_set_state_shutdown,\n\t\t.set_state_shutdown\t= ls1x_clockevent_set_state_shutdown,\n\t\t.tick_resume\t\t= ls1x_clockevent_tick_resume,\n\t},\n\t.of_irq = {\n\t\t.handler\t\t= ls1x_clockevent_isr,\n\t\t.flags\t\t\t= IRQF_TIMER,\n\t},\n};\n\n \nstatic u64 ls1x_clocksource_read(struct clocksource *cs)\n{\n\tstruct ls1x_clocksource *ls1x_cs = to_ls1x_clksrc(cs);\n\tunsigned long flags;\n\tint count;\n\tu32 jifs;\n\tstatic int old_count;\n\tstatic u32 old_jifs;\n\n\traw_spin_lock_irqsave(&ls1x_timer_lock, flags);\n\t \n\tjifs = jiffies;\n\t \n\tcount = readl(ls1x_cs->reg_base + PWM_CNTR);\n\n\t \n\tif (count < old_count && jifs == old_jifs)\n\t\tcount = old_count;\n\n\told_count = count;\n\told_jifs = jifs;\n\n\traw_spin_unlock_irqrestore(&ls1x_timer_lock, flags);\n\n\treturn (u64)(jifs * ls1x_cs->ticks_per_jiffy) + count;\n}\n\nstatic struct ls1x_clocksource ls1x_clocksource = {\n\t.clksrc = {\n\t\t.name           = \"ls1x-pwmtimer\",\n\t\t.rating\t\t= 300,\n\t\t.read           = ls1x_clocksource_read,\n\t\t.mask           = CLOCKSOURCE_MASK(CNTR_WIDTH),\n\t\t.flags          = CLOCK_SOURCE_IS_CONTINUOUS,\n\t},\n};\n\nstatic int __init ls1x_pwm_clocksource_init(struct device_node *np)\n{\n\tstruct timer_of *to = &ls1x_to;\n\tint ret;\n\n\tret = timer_of_init(np, to);\n\tif (ret)\n\t\treturn ret;\n\n\tclockevents_config_and_register(&to->clkevt, timer_of_rate(to),\n\t\t\t\t\t0x1, GENMASK(CNTR_WIDTH - 1, 0));\n\n\tls1x_clocksource.reg_base = timer_of_base(to);\n\tls1x_clocksource.ticks_per_jiffy = timer_of_period(to);\n\n\treturn clocksource_register_hz(&ls1x_clocksource.clksrc,\n\t\t\t\t       timer_of_rate(to));\n}\n\nTIMER_OF_DECLARE(ls1x_pwm_clocksource, \"loongson,ls1b-pwmtimer\",\n\t\t ls1x_pwm_clocksource_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}