{
  "module_name": "mxs_timer.c",
  "hash_id": "7d1bcb3a0c6e3a65fc0b77604a6d31028e1a1d26b66353306d90ad4aec13e505",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/mxs_timer.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/clockchips.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/stmp_device.h>\n#include <linux/sched_clock.h>\n\n \n\n#define MX23_TIMROT_VERSION_OFFSET\t0x0a0\n#define MX28_TIMROT_VERSION_OFFSET\t0x120\n#define BP_TIMROT_MAJOR_VERSION\t\t24\n#define BV_TIMROT_VERSION_1\t\t0x01\n#define BV_TIMROT_VERSION_2\t\t0x02\n#define timrot_is_v1()\t(timrot_major_version == BV_TIMROT_VERSION_1)\n\n \n \n#define HW_TIMROT_ROTCTRL\t\t0x00\n#define HW_TIMROT_TIMCTRLn(n)\t\t(0x20 + (n) * 0x40)\n \n#define HW_TIMROT_TIMCOUNTn(n)\t\t(0x30 + (n) * 0x40)\n \n#define HW_TIMROT_RUNNING_COUNTn(n)\t(0x30 + (n) * 0x40)\n#define HW_TIMROT_FIXED_COUNTn(n)\t(0x40 + (n) * 0x40)\n\n#define BM_TIMROT_TIMCTRLn_RELOAD\t(1 << 6)\n#define BM_TIMROT_TIMCTRLn_UPDATE\t(1 << 7)\n#define BM_TIMROT_TIMCTRLn_IRQ_EN\t(1 << 14)\n#define BM_TIMROT_TIMCTRLn_IRQ\t\t(1 << 15)\n#define BP_TIMROT_TIMCTRLn_SELECT\t0\n#define BV_TIMROTv1_TIMCTRLn_SELECT__32KHZ_XTAL\t\t0x8\n#define BV_TIMROTv2_TIMCTRLn_SELECT__32KHZ_XTAL\t\t0xb\n#define BV_TIMROTv2_TIMCTRLn_SELECT__TICK_ALWAYS\t0xf\n\nstatic struct clock_event_device mxs_clockevent_device;\n\nstatic void __iomem *mxs_timrot_base;\nstatic u32 timrot_major_version;\n\nstatic inline void timrot_irq_disable(void)\n{\n\t__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN, mxs_timrot_base +\n\t\t     HW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_CLR);\n}\n\nstatic inline void timrot_irq_enable(void)\n{\n\t__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN, mxs_timrot_base +\n\t\t     HW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_SET);\n}\n\nstatic void timrot_irq_acknowledge(void)\n{\n\t__raw_writel(BM_TIMROT_TIMCTRLn_IRQ, mxs_timrot_base +\n\t\t     HW_TIMROT_TIMCTRLn(0) + STMP_OFFSET_REG_CLR);\n}\n\nstatic u64 timrotv1_get_cycles(struct clocksource *cs)\n{\n\treturn ~((__raw_readl(mxs_timrot_base + HW_TIMROT_TIMCOUNTn(1))\n\t\t\t& 0xffff0000) >> 16);\n}\n\nstatic int timrotv1_set_next_event(unsigned long evt,\n\t\t\t\t\tstruct clock_event_device *dev)\n{\n\t \n\t__raw_writel(evt, mxs_timrot_base + HW_TIMROT_TIMCOUNTn(0));\n\n\treturn 0;\n}\n\nstatic int timrotv2_set_next_event(unsigned long evt,\n\t\t\t\t\tstruct clock_event_device *dev)\n{\n\t \n\t__raw_writel(evt, mxs_timrot_base + HW_TIMROT_FIXED_COUNTn(0));\n\n\treturn 0;\n}\n\nstatic irqreturn_t mxs_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\ttimrot_irq_acknowledge();\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxs_irq_clear(char *state)\n{\n\t \n\ttimrot_irq_disable();\n\n\t \n\tif (timrot_is_v1())\n\t\t__raw_writel(0xffff, mxs_timrot_base + HW_TIMROT_TIMCOUNTn(1));\n\telse\n\t\t__raw_writel(0xffffffff,\n\t\t\t     mxs_timrot_base + HW_TIMROT_FIXED_COUNTn(1));\n\n\t \n\ttimrot_irq_acknowledge();\n\tpr_debug(\"%s: changing mode to %s\\n\", __func__, state);\n}\n\nstatic int mxs_shutdown(struct clock_event_device *evt)\n{\n\tmxs_irq_clear(\"shutdown\");\n\n\treturn 0;\n}\n\nstatic int mxs_set_oneshot(struct clock_event_device *evt)\n{\n\tif (clockevent_state_oneshot(evt))\n\t\tmxs_irq_clear(\"oneshot\");\n\ttimrot_irq_enable();\n\treturn 0;\n}\n\nstatic struct clock_event_device mxs_clockevent_device = {\n\t.name\t\t\t= \"mxs_timrot\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_shutdown\t= mxs_shutdown,\n\t.set_state_oneshot\t= mxs_set_oneshot,\n\t.tick_resume\t\t= mxs_shutdown,\n\t.set_next_event\t\t= timrotv2_set_next_event,\n\t.rating\t\t\t= 200,\n};\n\nstatic int __init mxs_clockevent_init(struct clk *timer_clk)\n{\n\tif (timrot_is_v1())\n\t\tmxs_clockevent_device.set_next_event = timrotv1_set_next_event;\n\tmxs_clockevent_device.cpumask = cpumask_of(0);\n\tclockevents_config_and_register(&mxs_clockevent_device,\n\t\t\t\t\tclk_get_rate(timer_clk),\n\t\t\t\t\ttimrot_is_v1() ? 0xf : 0x2,\n\t\t\t\t\ttimrot_is_v1() ? 0xfffe : 0xfffffffe);\n\n\treturn 0;\n}\n\nstatic struct clocksource clocksource_mxs = {\n\t.name\t\t= \"mxs_timer\",\n\t.rating\t\t= 200,\n\t.read\t\t= timrotv1_get_cycles,\n\t.mask\t\t= CLOCKSOURCE_MASK(16),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic u64 notrace mxs_read_sched_clock_v2(void)\n{\n\treturn ~readl_relaxed(mxs_timrot_base + HW_TIMROT_RUNNING_COUNTn(1));\n}\n\nstatic int __init mxs_clocksource_init(struct clk *timer_clk)\n{\n\tunsigned int c = clk_get_rate(timer_clk);\n\n\tif (timrot_is_v1())\n\t\tclocksource_register_hz(&clocksource_mxs, c);\n\telse {\n\t\tclocksource_mmio_init(mxs_timrot_base + HW_TIMROT_RUNNING_COUNTn(1),\n\t\t\t\"mxs_timer\", c, 200, 32, clocksource_mmio_readl_down);\n\t\tsched_clock_register(mxs_read_sched_clock_v2, 32, c);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init mxs_timer_init(struct device_node *np)\n{\n\tstruct clk *timer_clk;\n\tint irq, ret;\n\n\tmxs_timrot_base = of_iomap(np, 0);\n\tWARN_ON(!mxs_timrot_base);\n\n\ttimer_clk = of_clk_get(np, 0);\n\tif (IS_ERR(timer_clk)) {\n\t\tpr_err(\"%s: failed to get clk\\n\", __func__);\n\t\treturn PTR_ERR(timer_clk);\n\t}\n\n\tret = clk_prepare_enable(timer_clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstmp_reset_block(mxs_timrot_base + HW_TIMROT_ROTCTRL);\n\n\t \n\ttimrot_major_version = __raw_readl(mxs_timrot_base +\n\t\t\t(of_device_is_compatible(np, \"fsl,imx23-timrot\") ?\n\t\t\t\t\t\tMX23_TIMROT_VERSION_OFFSET :\n\t\t\t\t\t\tMX28_TIMROT_VERSION_OFFSET));\n\ttimrot_major_version >>= BP_TIMROT_MAJOR_VERSION;\n\n\t \n\t__raw_writel((timrot_is_v1() ?\n\t\t\tBV_TIMROTv1_TIMCTRLn_SELECT__32KHZ_XTAL :\n\t\t\tBV_TIMROTv2_TIMCTRLn_SELECT__TICK_ALWAYS) |\n\t\t\tBM_TIMROT_TIMCTRLn_UPDATE |\n\t\t\tBM_TIMROT_TIMCTRLn_IRQ_EN,\n\t\t\tmxs_timrot_base + HW_TIMROT_TIMCTRLn(0));\n\n\t \n\t__raw_writel((timrot_is_v1() ?\n\t\t\tBV_TIMROTv1_TIMCTRLn_SELECT__32KHZ_XTAL :\n\t\t\tBV_TIMROTv2_TIMCTRLn_SELECT__TICK_ALWAYS) |\n\t\t\tBM_TIMROT_TIMCTRLn_RELOAD,\n\t\t\tmxs_timrot_base + HW_TIMROT_TIMCTRLn(1));\n\n\t \n\tif (timrot_is_v1())\n\t\t__raw_writel(0xffff,\n\t\t\tmxs_timrot_base + HW_TIMROT_TIMCOUNTn(1));\n\telse\n\t\t__raw_writel(0xffffffff,\n\t\t\tmxs_timrot_base + HW_TIMROT_FIXED_COUNTn(1));\n\n\t \n\tret = mxs_clocksource_init(timer_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mxs_clockevent_init(timer_clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0)\n\t\treturn -EINVAL;\n\n\treturn request_irq(irq, mxs_timer_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t   \"MXS Timer Tick\", &mxs_clockevent_device);\n}\nTIMER_OF_DECLARE(mxs, \"fsl,timrot\", mxs_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}