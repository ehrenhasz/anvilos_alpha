{
  "module_name": "em_sti.c",
  "hash_id": "cb84ed8f7f83ee5f5364c040b3b5d54e93e12a1461920c5ace05303ec662f835",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/em_sti.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nenum { USER_CLOCKSOURCE, USER_CLOCKEVENT, USER_NR };\n\nstruct em_sti_priv {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct platform_device *pdev;\n\tunsigned int active[USER_NR];\n\tunsigned long rate;\n\traw_spinlock_t lock;\n\tstruct clock_event_device ced;\n\tstruct clocksource cs;\n};\n\n#define STI_CONTROL 0x00\n#define STI_COMPA_H 0x10\n#define STI_COMPA_L 0x14\n#define STI_COMPB_H 0x18\n#define STI_COMPB_L 0x1c\n#define STI_COUNT_H 0x20\n#define STI_COUNT_L 0x24\n#define STI_COUNT_RAW_H 0x28\n#define STI_COUNT_RAW_L 0x2c\n#define STI_SET_H 0x30\n#define STI_SET_L 0x34\n#define STI_INTSTATUS 0x40\n#define STI_INTRAWSTATUS 0x44\n#define STI_INTENSET 0x48\n#define STI_INTENCLR 0x4c\n#define STI_INTFFCLR 0x50\n\nstatic inline unsigned long em_sti_read(struct em_sti_priv *p, int offs)\n{\n\treturn ioread32(p->base + offs);\n}\n\nstatic inline void em_sti_write(struct em_sti_priv *p, int offs,\n\t\t\t\tunsigned long value)\n{\n\tiowrite32(value, p->base + offs);\n}\n\nstatic int em_sti_enable(struct em_sti_priv *p)\n{\n\tint ret;\n\n\t \n\tret = clk_enable(p->clk);\n\tif (ret) {\n\t\tdev_err(&p->pdev->dev, \"cannot enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tem_sti_write(p, STI_SET_H, 0x40000000);\n\tem_sti_write(p, STI_SET_L, 0x00000000);\n\n\t \n\tem_sti_write(p, STI_INTENCLR, 3);\n\tem_sti_write(p, STI_INTFFCLR, 3);\n\n\t \n\tem_sti_write(p, STI_CONTROL, 1);\n\n\treturn 0;\n}\n\nstatic void em_sti_disable(struct em_sti_priv *p)\n{\n\t \n\tem_sti_write(p, STI_INTENCLR, 3);\n\n\t \n\tclk_disable(p->clk);\n}\n\nstatic u64 em_sti_count(struct em_sti_priv *p)\n{\n\tu64 ticks;\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&p->lock, flags);\n\tticks = (u64)(em_sti_read(p, STI_COUNT_H) & 0xffff) << 32;\n\tticks |= em_sti_read(p, STI_COUNT_L);\n\traw_spin_unlock_irqrestore(&p->lock, flags);\n\n\treturn ticks;\n}\n\nstatic u64 em_sti_set_next(struct em_sti_priv *p, u64 next)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&p->lock, flags);\n\n\t \n\tem_sti_write(p, STI_INTENCLR, 1);\n\n\t \n\tem_sti_write(p, STI_COMPA_H, next >> 32);\n\tem_sti_write(p, STI_COMPA_L, next & 0xffffffff);\n\n\t \n\tem_sti_write(p, STI_INTFFCLR, 1);\n\n\t \n\tem_sti_write(p, STI_INTENSET, 1);\n\n\traw_spin_unlock_irqrestore(&p->lock, flags);\n\n\treturn next;\n}\n\nstatic irqreturn_t em_sti_interrupt(int irq, void *dev_id)\n{\n\tstruct em_sti_priv *p = dev_id;\n\n\tp->ced.event_handler(&p->ced);\n\treturn IRQ_HANDLED;\n}\n\nstatic int em_sti_start(struct em_sti_priv *p, unsigned int user)\n{\n\tunsigned long flags;\n\tint used_before;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&p->lock, flags);\n\tused_before = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\n\tif (!used_before)\n\t\tret = em_sti_enable(p);\n\n\tif (!ret)\n\t\tp->active[user] = 1;\n\traw_spin_unlock_irqrestore(&p->lock, flags);\n\n\treturn ret;\n}\n\nstatic void em_sti_stop(struct em_sti_priv *p, unsigned int user)\n{\n\tunsigned long flags;\n\tint used_before, used_after;\n\n\traw_spin_lock_irqsave(&p->lock, flags);\n\tused_before = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\n\tp->active[user] = 0;\n\tused_after = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\n\n\tif (used_before && !used_after)\n\t\tem_sti_disable(p);\n\traw_spin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic struct em_sti_priv *cs_to_em_sti(struct clocksource *cs)\n{\n\treturn container_of(cs, struct em_sti_priv, cs);\n}\n\nstatic u64 em_sti_clocksource_read(struct clocksource *cs)\n{\n\treturn em_sti_count(cs_to_em_sti(cs));\n}\n\nstatic int em_sti_clocksource_enable(struct clocksource *cs)\n{\n\tstruct em_sti_priv *p = cs_to_em_sti(cs);\n\n\treturn em_sti_start(p, USER_CLOCKSOURCE);\n}\n\nstatic void em_sti_clocksource_disable(struct clocksource *cs)\n{\n\tem_sti_stop(cs_to_em_sti(cs), USER_CLOCKSOURCE);\n}\n\nstatic void em_sti_clocksource_resume(struct clocksource *cs)\n{\n\tem_sti_clocksource_enable(cs);\n}\n\nstatic int em_sti_register_clocksource(struct em_sti_priv *p)\n{\n\tstruct clocksource *cs = &p->cs;\n\n\tcs->name = dev_name(&p->pdev->dev);\n\tcs->rating = 200;\n\tcs->read = em_sti_clocksource_read;\n\tcs->enable = em_sti_clocksource_enable;\n\tcs->disable = em_sti_clocksource_disable;\n\tcs->suspend = em_sti_clocksource_disable;\n\tcs->resume = em_sti_clocksource_resume;\n\tcs->mask = CLOCKSOURCE_MASK(48);\n\tcs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\tdev_info(&p->pdev->dev, \"used as clock source\\n\");\n\n\tclocksource_register_hz(cs, p->rate);\n\treturn 0;\n}\n\nstatic struct em_sti_priv *ced_to_em_sti(struct clock_event_device *ced)\n{\n\treturn container_of(ced, struct em_sti_priv, ced);\n}\n\nstatic int em_sti_clock_event_shutdown(struct clock_event_device *ced)\n{\n\tstruct em_sti_priv *p = ced_to_em_sti(ced);\n\tem_sti_stop(p, USER_CLOCKEVENT);\n\treturn 0;\n}\n\nstatic int em_sti_clock_event_set_oneshot(struct clock_event_device *ced)\n{\n\tstruct em_sti_priv *p = ced_to_em_sti(ced);\n\n\tdev_info(&p->pdev->dev, \"used for oneshot clock events\\n\");\n\tem_sti_start(p, USER_CLOCKEVENT);\n\treturn 0;\n}\n\nstatic int em_sti_clock_event_next(unsigned long delta,\n\t\t\t\t   struct clock_event_device *ced)\n{\n\tstruct em_sti_priv *p = ced_to_em_sti(ced);\n\tu64 next;\n\tint safe;\n\n\tnext = em_sti_set_next(p, em_sti_count(p) + delta);\n\tsafe = em_sti_count(p) < (next - 1);\n\n\treturn !safe;\n}\n\nstatic void em_sti_register_clockevent(struct em_sti_priv *p)\n{\n\tstruct clock_event_device *ced = &p->ced;\n\n\tced->name = dev_name(&p->pdev->dev);\n\tced->features = CLOCK_EVT_FEAT_ONESHOT;\n\tced->rating = 200;\n\tced->cpumask = cpu_possible_mask;\n\tced->set_next_event = em_sti_clock_event_next;\n\tced->set_state_shutdown = em_sti_clock_event_shutdown;\n\tced->set_state_oneshot = em_sti_clock_event_set_oneshot;\n\n\tdev_info(&p->pdev->dev, \"used for clock events\\n\");\n\n\tclockevents_config_and_register(ced, p->rate, 2, 0xffffffff);\n}\n\nstatic int em_sti_probe(struct platform_device *pdev)\n{\n\tstruct em_sti_priv *p;\n\tint irq, ret;\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tp->pdev = pdev;\n\tplatform_set_drvdata(pdev, p);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base))\n\t\treturn PTR_ERR(p->base);\n\n\tret = devm_request_irq(&pdev->dev, irq, em_sti_interrupt,\n\t\t\t       IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\n\t\t\t       dev_name(&pdev->dev), p);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request low IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tp->clk = devm_clk_get(&pdev->dev, \"sclk\");\n\tif (IS_ERR(p->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(p->clk);\n\t}\n\n\tret = clk_prepare(p->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(p->clk);\n\tif (ret < 0) {\n\t\tdev_err(&p->pdev->dev, \"cannot enable clock\\n\");\n\t\tclk_unprepare(p->clk);\n\t\treturn ret;\n\t}\n\tp->rate = clk_get_rate(p->clk);\n\tclk_disable(p->clk);\n\n\traw_spin_lock_init(&p->lock);\n\tem_sti_register_clockevent(p);\n\tem_sti_register_clocksource(p);\n\treturn 0;\n}\n\nstatic const struct of_device_id em_sti_dt_ids[] = {\n\t{ .compatible = \"renesas,em-sti\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, em_sti_dt_ids);\n\nstatic struct platform_driver em_sti_device_driver = {\n\t.probe\t\t= em_sti_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"em_sti\",\n\t\t.of_match_table = em_sti_dt_ids,\n\t\t.suppress_bind_attrs = true,\n\t}\n};\n\nstatic int __init em_sti_init(void)\n{\n\treturn platform_driver_register(&em_sti_device_driver);\n}\n\nstatic void __exit em_sti_exit(void)\n{\n\tplatform_driver_unregister(&em_sti_device_driver);\n}\n\nsubsys_initcall(em_sti_init);\nmodule_exit(em_sti_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"Renesas Emma Mobile STI Timer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}