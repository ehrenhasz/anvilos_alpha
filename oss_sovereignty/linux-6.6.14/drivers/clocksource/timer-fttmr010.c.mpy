{
  "module_name": "timer-fttmr010.c",
  "hash_id": "c0334a7251dcf2d42953b99ec67f63d741413d8a926860ac1e0a86b3ee909590",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-fttmr010.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/sched_clock.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n\n \n#define TIMER1_COUNT\t\t(0x00)\n#define TIMER1_LOAD\t\t(0x04)\n#define TIMER1_MATCH1\t\t(0x08)\n#define TIMER1_MATCH2\t\t(0x0c)\n#define TIMER2_COUNT\t\t(0x10)\n#define TIMER2_LOAD\t\t(0x14)\n#define TIMER2_MATCH1\t\t(0x18)\n#define TIMER2_MATCH2\t\t(0x1c)\n#define TIMER3_COUNT\t\t(0x20)\n#define TIMER3_LOAD\t\t(0x24)\n#define TIMER3_MATCH1\t\t(0x28)\n#define TIMER3_MATCH2\t\t(0x2c)\n#define TIMER_CR\t\t(0x30)\n\n \n#define AST2600_TIMER_CR_CLR\t(0x3c)\n\n \n#define TIMER_1_CR_ENABLE\tBIT(0)\n#define TIMER_1_CR_CLOCK\tBIT(1)\n#define TIMER_1_CR_INT\t\tBIT(2)\n#define TIMER_2_CR_ENABLE\tBIT(3)\n#define TIMER_2_CR_CLOCK\tBIT(4)\n#define TIMER_2_CR_INT\t\tBIT(5)\n#define TIMER_3_CR_ENABLE\tBIT(6)\n#define TIMER_3_CR_CLOCK\tBIT(7)\n#define TIMER_3_CR_INT\t\tBIT(8)\n#define TIMER_1_CR_UPDOWN\tBIT(9)\n#define TIMER_2_CR_UPDOWN\tBIT(10)\n#define TIMER_3_CR_UPDOWN\tBIT(11)\n\n \n#define TIMER_1_CR_ASPEED_ENABLE\tBIT(0)\n#define TIMER_1_CR_ASPEED_CLOCK\t\tBIT(1)\n#define TIMER_1_CR_ASPEED_INT\t\tBIT(2)\n#define TIMER_2_CR_ASPEED_ENABLE\tBIT(4)\n#define TIMER_2_CR_ASPEED_CLOCK\t\tBIT(5)\n#define TIMER_2_CR_ASPEED_INT\t\tBIT(6)\n#define TIMER_3_CR_ASPEED_ENABLE\tBIT(8)\n#define TIMER_3_CR_ASPEED_CLOCK\t\tBIT(9)\n#define TIMER_3_CR_ASPEED_INT\t\tBIT(10)\n\n \n#define TIMER_INTR_STATE\t(0x34)\n#define TIMER_INTR_MASK\t\t(0x38)\n#define TIMER_1_INT_MATCH1\tBIT(0)\n#define TIMER_1_INT_MATCH2\tBIT(1)\n#define TIMER_1_INT_OVERFLOW\tBIT(2)\n#define TIMER_2_INT_MATCH1\tBIT(3)\n#define TIMER_2_INT_MATCH2\tBIT(4)\n#define TIMER_2_INT_OVERFLOW\tBIT(5)\n#define TIMER_3_INT_MATCH1\tBIT(6)\n#define TIMER_3_INT_MATCH2\tBIT(7)\n#define TIMER_3_INT_OVERFLOW\tBIT(8)\n#define TIMER_INT_ALL_MASK\t0x1ff\n\nstruct fttmr010 {\n\tvoid __iomem *base;\n\tunsigned int tick_rate;\n\tbool is_aspeed;\n\tu32 t1_enable_val;\n\tstruct clock_event_device clkevt;\n\tint (*timer_shutdown)(struct clock_event_device *evt);\n#ifdef CONFIG_ARM\n\tstruct delay_timer delay_timer;\n#endif\n};\n\n \nstatic struct fttmr010 *local_fttmr;\n\nstatic inline struct fttmr010 *to_fttmr010(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct fttmr010, clkevt);\n}\n\nstatic unsigned long fttmr010_read_current_timer_up(void)\n{\n\treturn readl(local_fttmr->base + TIMER2_COUNT);\n}\n\nstatic unsigned long fttmr010_read_current_timer_down(void)\n{\n\treturn ~readl(local_fttmr->base + TIMER2_COUNT);\n}\n\nstatic u64 notrace fttmr010_read_sched_clock_up(void)\n{\n\treturn fttmr010_read_current_timer_up();\n}\n\nstatic u64 notrace fttmr010_read_sched_clock_down(void)\n{\n\treturn fttmr010_read_current_timer_down();\n}\n\nstatic int fttmr010_timer_set_next_event(unsigned long cycles,\n\t\t\t\t       struct clock_event_device *evt)\n{\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\tu32 cr;\n\n\t \n\tfttmr010->timer_shutdown(evt);\n\n\tif (fttmr010->is_aspeed) {\n\t\t \n\t\twritel(cycles, fttmr010->base + TIMER1_LOAD);\n\t} else {\n\t\t \n\t\tcr = readl(fttmr010->base + TIMER1_COUNT);\n\t\twritel(cr + cycles, fttmr010->base + TIMER1_MATCH1);\n\t}\n\n\t \n\tcr = readl(fttmr010->base + TIMER_CR);\n\tcr |= fttmr010->t1_enable_val;\n\twritel(cr, fttmr010->base + TIMER_CR);\n\n\treturn 0;\n}\n\nstatic int ast2600_timer_shutdown(struct clock_event_device *evt)\n{\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\n\t \n\twritel(fttmr010->t1_enable_val, fttmr010->base + AST2600_TIMER_CR_CLR);\n\n\treturn 0;\n}\n\nstatic int fttmr010_timer_shutdown(struct clock_event_device *evt)\n{\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\tu32 cr;\n\n\t \n\tcr = readl(fttmr010->base + TIMER_CR);\n\tcr &= ~fttmr010->t1_enable_val;\n\twritel(cr, fttmr010->base + TIMER_CR);\n\n\treturn 0;\n}\n\nstatic int fttmr010_timer_set_oneshot(struct clock_event_device *evt)\n{\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\tu32 cr;\n\n\t \n\tfttmr010->timer_shutdown(evt);\n\n\t \n\twritel(0, fttmr010->base + TIMER1_COUNT);\n\tif (fttmr010->is_aspeed) {\n\t\twritel(~0, fttmr010->base + TIMER1_LOAD);\n\t} else {\n\t\twritel(0, fttmr010->base + TIMER1_LOAD);\n\n\t\t \n\t\tcr = readl(fttmr010->base + TIMER_INTR_MASK);\n\t\tcr &= ~(TIMER_1_INT_OVERFLOW | TIMER_1_INT_MATCH2);\n\t\tcr |= TIMER_1_INT_MATCH1;\n\t\twritel(cr, fttmr010->base + TIMER_INTR_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int fttmr010_timer_set_periodic(struct clock_event_device *evt)\n{\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\tu32 period = DIV_ROUND_CLOSEST(fttmr010->tick_rate, HZ);\n\tu32 cr;\n\n\t \n\tfttmr010->timer_shutdown(evt);\n\n\t \n\tif (fttmr010->is_aspeed) {\n\t\twritel(period, fttmr010->base + TIMER1_LOAD);\n\t} else {\n\t\tcr = 0xffffffff - (period - 1);\n\t\twritel(cr, fttmr010->base + TIMER1_COUNT);\n\t\twritel(cr, fttmr010->base + TIMER1_LOAD);\n\n\t\t \n\t\tcr = readl(fttmr010->base + TIMER_INTR_MASK);\n\t\tcr &= ~(TIMER_1_INT_MATCH1 | TIMER_1_INT_MATCH2);\n\t\tcr |= TIMER_1_INT_OVERFLOW;\n\t\twritel(cr, fttmr010->base + TIMER_INTR_MASK);\n\t}\n\n\t \n\tcr = readl(fttmr010->base + TIMER_CR);\n\tcr |= fttmr010->t1_enable_val;\n\twritel(cr, fttmr010->base + TIMER_CR);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t fttmr010_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ast2600_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\tstruct fttmr010 *fttmr010 = to_fttmr010(evt);\n\n\twritel(0x1, fttmr010->base + TIMER_INTR_STATE);\n\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init fttmr010_common_init(struct device_node *np,\n\t\t\t\t       bool is_aspeed, bool is_ast2600)\n{\n\tstruct fttmr010 *fttmr010;\n\tint irq;\n\tstruct clk *clk;\n\tint ret;\n\tu32 val;\n\n\t \n\tclk = of_clk_get_by_name(np, \"PCLK\");\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"could not get PCLK\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"failed to enable PCLK\\n\");\n\t\treturn ret;\n\t}\n\n\tfttmr010 = kzalloc(sizeof(*fttmr010), GFP_KERNEL);\n\tif (!fttmr010) {\n\t\tret = -ENOMEM;\n\t\tgoto out_disable_clock;\n\t}\n\tfttmr010->tick_rate = clk_get_rate(clk);\n\n\tfttmr010->base = of_iomap(np, 0);\n\tif (!fttmr010->base) {\n\t\tpr_err(\"Can't remap registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out_free;\n\t}\n\t \n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't parse IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\t \n\tif (is_aspeed) {\n\t\tfttmr010->t1_enable_val = TIMER_1_CR_ASPEED_ENABLE |\n\t\t\tTIMER_1_CR_ASPEED_INT;\n\t\tfttmr010->is_aspeed = true;\n\t} else {\n\t\tfttmr010->t1_enable_val = TIMER_1_CR_ENABLE | TIMER_1_CR_INT;\n\n\t\t \n\t\twritel(TIMER_INT_ALL_MASK, fttmr010->base + TIMER_INTR_MASK);\n\t\twritel(0, fttmr010->base + TIMER_INTR_STATE);\n\t}\n\n\t \n\tif (is_aspeed)\n\t\tval = TIMER_2_CR_ASPEED_ENABLE;\n\telse {\n\t\tval = TIMER_2_CR_ENABLE | TIMER_1_CR_UPDOWN |\n\t\t\tTIMER_2_CR_UPDOWN;\n\t}\n\twritel(val, fttmr010->base + TIMER_CR);\n\n\t \n\tlocal_fttmr = fttmr010;\n\twritel(0, fttmr010->base + TIMER2_COUNT);\n\twritel(0, fttmr010->base + TIMER2_MATCH1);\n\twritel(0, fttmr010->base + TIMER2_MATCH2);\n\n\tif (fttmr010->is_aspeed) {\n\t\twritel(~0, fttmr010->base + TIMER2_LOAD);\n\t\tclocksource_mmio_init(fttmr010->base + TIMER2_COUNT,\n\t\t\t\t      \"FTTMR010-TIMER2\",\n\t\t\t\t      fttmr010->tick_rate,\n\t\t\t\t      300, 32, clocksource_mmio_readl_down);\n\t\tsched_clock_register(fttmr010_read_sched_clock_down, 32,\n\t\t\t\t     fttmr010->tick_rate);\n\t} else {\n\t\twritel(0, fttmr010->base + TIMER2_LOAD);\n\t\tclocksource_mmio_init(fttmr010->base + TIMER2_COUNT,\n\t\t\t\t      \"FTTMR010-TIMER2\",\n\t\t\t\t      fttmr010->tick_rate,\n\t\t\t\t      300, 32, clocksource_mmio_readl_up);\n\t\tsched_clock_register(fttmr010_read_sched_clock_up, 32,\n\t\t\t\t     fttmr010->tick_rate);\n\t}\n\n\t \n\twritel(0, fttmr010->base + TIMER1_COUNT);\n\twritel(0, fttmr010->base + TIMER1_LOAD);\n\twritel(0, fttmr010->base + TIMER1_MATCH1);\n\twritel(0, fttmr010->base + TIMER1_MATCH2);\n\n\tif (is_ast2600) {\n\t\tfttmr010->timer_shutdown = ast2600_timer_shutdown;\n\t\tret = request_irq(irq, ast2600_timer_interrupt,\n\t\t\t\t  IRQF_TIMER, \"FTTMR010-TIMER1\",\n\t\t\t\t  &fttmr010->clkevt);\n\t} else {\n\t\tfttmr010->timer_shutdown = fttmr010_timer_shutdown;\n\t\tret = request_irq(irq, fttmr010_timer_interrupt,\n\t\t\t\t  IRQF_TIMER, \"FTTMR010-TIMER1\",\n\t\t\t\t  &fttmr010->clkevt);\n\t}\n\tif (ret) {\n\t\tpr_err(\"FTTMR010-TIMER1 no IRQ\\n\");\n\t\tgoto out_unmap;\n\t}\n\n\tfttmr010->clkevt.name = \"FTTMR010-TIMER1\";\n\t \n\tfttmr010->clkevt.rating = 300;\n\tfttmr010->clkevt.features = CLOCK_EVT_FEAT_PERIODIC |\n\t\tCLOCK_EVT_FEAT_ONESHOT;\n\tfttmr010->clkevt.set_next_event = fttmr010_timer_set_next_event;\n\tfttmr010->clkevt.set_state_shutdown = fttmr010->timer_shutdown;\n\tfttmr010->clkevt.set_state_periodic = fttmr010_timer_set_periodic;\n\tfttmr010->clkevt.set_state_oneshot = fttmr010_timer_set_oneshot;\n\tfttmr010->clkevt.tick_resume = fttmr010->timer_shutdown;\n\tfttmr010->clkevt.cpumask = cpumask_of(0);\n\tfttmr010->clkevt.irq = irq;\n\tclockevents_config_and_register(&fttmr010->clkevt,\n\t\t\t\t\tfttmr010->tick_rate,\n\t\t\t\t\t1, 0xffffffff);\n\n#ifdef CONFIG_ARM\n\t \n\tif (fttmr010->is_aspeed)\n\t\tfttmr010->delay_timer.read_current_timer =\n\t\t\tfttmr010_read_current_timer_down;\n\telse\n\t\tfttmr010->delay_timer.read_current_timer =\n\t\t\tfttmr010_read_current_timer_up;\n\tfttmr010->delay_timer.freq = fttmr010->tick_rate;\n\tregister_current_timer_delay(&fttmr010->delay_timer);\n#endif\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(fttmr010->base);\nout_free:\n\tkfree(fttmr010);\nout_disable_clock:\n\tclk_disable_unprepare(clk);\n\n\treturn ret;\n}\n\nstatic __init int ast2600_timer_init(struct device_node *np)\n{\n\treturn fttmr010_common_init(np, true, true);\n}\n\nstatic __init int aspeed_timer_init(struct device_node *np)\n{\n\treturn fttmr010_common_init(np, true, false);\n}\n\nstatic __init int fttmr010_timer_init(struct device_node *np)\n{\n\treturn fttmr010_common_init(np, false, false);\n}\n\nTIMER_OF_DECLARE(fttmr010, \"faraday,fttmr010\", fttmr010_timer_init);\nTIMER_OF_DECLARE(gemini, \"cortina,gemini-timer\", fttmr010_timer_init);\nTIMER_OF_DECLARE(moxart, \"moxa,moxart-timer\", fttmr010_timer_init);\nTIMER_OF_DECLARE(ast2400, \"aspeed,ast2400-timer\", aspeed_timer_init);\nTIMER_OF_DECLARE(ast2500, \"aspeed,ast2500-timer\", aspeed_timer_init);\nTIMER_OF_DECLARE(ast2600, \"aspeed,ast2600-timer\", ast2600_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}