{
  "module_name": "timer-orion.c",
  "hash_id": "75880b5ec40f479c6af86cdb2881aaca15f82267bb70c8e01a5fc8e09936a894",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-orion.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n#include <linux/sched_clock.h>\n\n#define TIMER_CTRL\t\t0x00\n#define  TIMER0_EN\t\tBIT(0)\n#define  TIMER0_RELOAD_EN\tBIT(1)\n#define  TIMER1_EN\t\tBIT(2)\n#define  TIMER1_RELOAD_EN\tBIT(3)\n#define TIMER0_RELOAD\t\t0x10\n#define TIMER0_VAL\t\t0x14\n#define TIMER1_RELOAD\t\t0x18\n#define TIMER1_VAL\t\t0x1c\n\n#define ORION_ONESHOT_MIN\t1\n#define ORION_ONESHOT_MAX\t0xfffffffe\n\nstatic void __iomem *timer_base;\n\nstatic unsigned long notrace orion_read_timer(void)\n{\n\treturn ~readl(timer_base + TIMER0_VAL);\n}\n\nstatic struct delay_timer orion_delay_timer = {\n\t.read_current_timer = orion_read_timer,\n};\n\nstatic void orion_delay_timer_init(unsigned long rate)\n{\n\torion_delay_timer.freq = rate;\n\tregister_current_timer_delay(&orion_delay_timer);\n}\n\n \nstatic u64 notrace orion_read_sched_clock(void)\n{\n\treturn ~readl(timer_base + TIMER0_VAL);\n}\n\n \nstatic u32 ticks_per_jiffy;\n\nstatic int orion_clkevt_next_event(unsigned long delta,\n\t\t\t\t   struct clock_event_device *dev)\n{\n\t \n\twritel(delta, timer_base + TIMER1_VAL);\n\tatomic_io_modify(timer_base + TIMER_CTRL,\n\t\tTIMER1_RELOAD_EN | TIMER1_EN, TIMER1_EN);\n\n\treturn 0;\n}\n\nstatic int orion_clkevt_shutdown(struct clock_event_device *dev)\n{\n\t \n\tatomic_io_modify(timer_base + TIMER_CTRL,\n\t\t\t TIMER1_RELOAD_EN | TIMER1_EN, 0);\n\treturn 0;\n}\n\nstatic int orion_clkevt_set_periodic(struct clock_event_device *dev)\n{\n\t \n\twritel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD);\n\twritel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL);\n\tatomic_io_modify(timer_base + TIMER_CTRL,\n\t\t\t TIMER1_RELOAD_EN | TIMER1_EN,\n\t\t\t TIMER1_RELOAD_EN | TIMER1_EN);\n\treturn 0;\n}\n\nstatic struct clock_event_device orion_clkevt = {\n\t.name\t\t\t= \"orion_event\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_PERIODIC,\n\t.shift\t\t\t= 32,\n\t.rating\t\t\t= 300,\n\t.set_next_event\t\t= orion_clkevt_next_event,\n\t.set_state_shutdown\t= orion_clkevt_shutdown,\n\t.set_state_periodic\t= orion_clkevt_set_periodic,\n\t.set_state_oneshot\t= orion_clkevt_shutdown,\n\t.tick_resume\t\t= orion_clkevt_shutdown,\n};\n\nstatic irqreturn_t orion_clkevt_irq_handler(int irq, void *dev_id)\n{\n\torion_clkevt.event_handler(&orion_clkevt);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init orion_timer_init(struct device_node *np)\n{\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint irq, ret;\n\n\t \n\ttimer_base = of_iomap(np, 0);\n\tif (!timer_base) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", np);\n\t\treturn -ENXIO;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%pOFn: unable to get clk\\n\", np);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"Failed to prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tirq = irq_of_parse_and_map(np, 1);\n\tif (irq <= 0) {\n\t\tpr_err(\"%pOFn: unable to parse timer1 irq\\n\", np);\n\t\tret = -EINVAL;\n\t\tgoto out_unprep_clk;\n\t}\n\n\trate = clk_get_rate(clk);\n\n\t \n\twritel(~0, timer_base + TIMER0_VAL);\n\twritel(~0, timer_base + TIMER0_RELOAD);\n\tatomic_io_modify(timer_base + TIMER_CTRL,\n\t\tTIMER0_RELOAD_EN | TIMER0_EN,\n\t\tTIMER0_RELOAD_EN | TIMER0_EN);\n\n\tret = clocksource_mmio_init(timer_base + TIMER0_VAL,\n\t\t\t\t    \"orion_clocksource\", rate, 300, 32,\n\t\t\t\t    clocksource_mmio_readl_down);\n\tif (ret) {\n\t\tpr_err(\"Failed to initialize mmio timer\\n\");\n\t\tgoto out_unprep_clk;\n\t}\n\n\tsched_clock_register(orion_read_sched_clock, 32, rate);\n\n\t \n\tret = request_irq(irq, orion_clkevt_irq_handler, IRQF_TIMER,\n\t\t\t  \"orion_event\", NULL);\n\tif (ret) {\n\t\tpr_err(\"%pOFn: unable to setup irq\\n\", np);\n\t\tgoto out_unprep_clk;\n\t}\n\n\tticks_per_jiffy = (clk_get_rate(clk) + HZ/2) / HZ;\n\torion_clkevt.cpumask = cpumask_of(0);\n\torion_clkevt.irq = irq;\n\tclockevents_config_and_register(&orion_clkevt, rate,\n\t\t\t\t\tORION_ONESHOT_MIN, ORION_ONESHOT_MAX);\n\n\n\torion_delay_timer_init(rate);\n\n\treturn 0;\n\nout_unprep_clk:\n\tclk_disable_unprepare(clk);\n\treturn ret;\n}\nTIMER_OF_DECLARE(orion_timer, \"marvell,orion-timer\", orion_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}