{
  "module_name": "ingenic-sysost.c",
  "hash_id": "fa7ded748f27ae2665a7f3a51d7a1368a9822e6986ac8065562a45637b9f68b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/ingenic-sysost.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include <linux/syscore_ops.h>\n\n#include <dt-bindings/clock/ingenic,sysost.h>\n\n \n#define OST_REG_OSTCCR\t\t\t0x00\n#define OST_REG_OSTCR\t\t\t0x08\n#define OST_REG_OSTFR\t\t\t0x0c\n#define OST_REG_OSTMR\t\t\t0x10\n#define OST_REG_OST1DFR\t\t\t0x14\n#define OST_REG_OST1CNT\t\t\t0x18\n#define OST_REG_OST2CNTL\t\t0x20\n#define OST_REG_OSTCNT2HBUF\t\t0x24\n#define OST_REG_OSTESR\t\t\t0x34\n#define OST_REG_OSTECR\t\t\t0x38\n\n \n#define OSTCCR_PRESCALE1_MASK\t0x3\n#define OSTCCR_PRESCALE2_MASK\t0xc\n\n \n#define OSTCR_OST1CLR\t\t\tBIT(0)\n#define OSTCR_OST2CLR\t\t\tBIT(1)\n\n \n#define OSTFR_FFLAG\t\t\t\tBIT(0)\n\n \n#define OSTMR_FMASK\t\t\t\tBIT(0)\n\n \n#define OSTESR_OST1ENS\t\t\tBIT(0)\n#define OSTESR_OST2ENS\t\t\tBIT(1)\n\n \n#define OSTECR_OST1ENC\t\t\tBIT(0)\n#define OSTECR_OST2ENC\t\t\tBIT(1)\n\nstruct ingenic_soc_info {\n\tunsigned int num_channels;\n};\n\nstruct ingenic_ost_clk_info {\n\tstruct clk_init_data init_data;\n\tu8 ostccr_reg;\n};\n\nstruct ingenic_ost_clk {\n\tstruct clk_hw hw;\n\tunsigned int idx;\n\tstruct ingenic_ost *ost;\n\tconst struct ingenic_ost_clk_info *info;\n};\n\nstruct ingenic_ost {\n\tvoid __iomem *base;\n\tconst struct ingenic_soc_info *soc_info;\n\tstruct clk *clk, *percpu_timer_clk, *global_timer_clk;\n\tstruct clock_event_device cevt;\n\tstruct clocksource cs;\n\tchar name[20];\n\n\tstruct clk_hw_onecell_data *clocks;\n};\n\nstatic struct ingenic_ost *ingenic_ost;\n\nstatic inline struct ingenic_ost_clk *to_ost_clk(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct ingenic_ost_clk, hw);\n}\n\nstatic unsigned long ingenic_ost_percpu_timer_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_ost_clk *ost_clk = to_ost_clk(hw);\n\tconst struct ingenic_ost_clk_info *info = ost_clk->info;\n\tunsigned int prescale;\n\n\tprescale = readl(ost_clk->ost->base + info->ostccr_reg);\n\n\tprescale = FIELD_GET(OSTCCR_PRESCALE1_MASK, prescale);\n\n\treturn parent_rate >> (prescale * 2);\n}\n\nstatic unsigned long ingenic_ost_global_timer_recalc_rate(struct clk_hw *hw,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_ost_clk *ost_clk = to_ost_clk(hw);\n\tconst struct ingenic_ost_clk_info *info = ost_clk->info;\n\tunsigned int prescale;\n\n\tprescale = readl(ost_clk->ost->base + info->ostccr_reg);\n\n\tprescale = FIELD_GET(OSTCCR_PRESCALE2_MASK, prescale);\n\n\treturn parent_rate >> (prescale * 2);\n}\n\nstatic u8 ingenic_ost_get_prescale(unsigned long rate, unsigned long req_rate)\n{\n\tu8 prescale;\n\n\tfor (prescale = 0; prescale < 2; prescale++)\n\t\tif ((rate >> (prescale * 2)) <= req_rate)\n\t\t\treturn prescale;\n\n\treturn 2;  \n}\n\nstatic long ingenic_ost_round_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\tunsigned long *parent_rate)\n{\n\tunsigned long rate = *parent_rate;\n\tu8 prescale;\n\n\tif (req_rate > rate)\n\t\treturn rate;\n\n\tprescale = ingenic_ost_get_prescale(rate, req_rate);\n\n\treturn rate >> (prescale * 2);\n}\n\nstatic int ingenic_ost_percpu_timer_set_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_ost_clk *ost_clk = to_ost_clk(hw);\n\tconst struct ingenic_ost_clk_info *info = ost_clk->info;\n\tu8 prescale = ingenic_ost_get_prescale(parent_rate, req_rate);\n\tint val;\n\n\tval = readl(ost_clk->ost->base + info->ostccr_reg);\n\tval &= ~OSTCCR_PRESCALE1_MASK;\n\tval |= FIELD_PREP(OSTCCR_PRESCALE1_MASK, prescale);\n\twritel(val, ost_clk->ost->base + info->ostccr_reg);\n\n\treturn 0;\n}\n\nstatic int ingenic_ost_global_timer_set_rate(struct clk_hw *hw, unsigned long req_rate,\n\t\tunsigned long parent_rate)\n{\n\tstruct ingenic_ost_clk *ost_clk = to_ost_clk(hw);\n\tconst struct ingenic_ost_clk_info *info = ost_clk->info;\n\tu8 prescale = ingenic_ost_get_prescale(parent_rate, req_rate);\n\tint val;\n\n\tval = readl(ost_clk->ost->base + info->ostccr_reg);\n\tval &= ~OSTCCR_PRESCALE2_MASK;\n\tval |= FIELD_PREP(OSTCCR_PRESCALE2_MASK, prescale);\n\twritel(val, ost_clk->ost->base + info->ostccr_reg);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ingenic_ost_percpu_timer_ops = {\n\t.recalc_rate\t= ingenic_ost_percpu_timer_recalc_rate,\n\t.round_rate\t\t= ingenic_ost_round_rate,\n\t.set_rate\t\t= ingenic_ost_percpu_timer_set_rate,\n};\n\nstatic const struct clk_ops ingenic_ost_global_timer_ops = {\n\t.recalc_rate\t= ingenic_ost_global_timer_recalc_rate,\n\t.round_rate\t\t= ingenic_ost_round_rate,\n\t.set_rate\t\t= ingenic_ost_global_timer_set_rate,\n};\n\nstatic const char * const ingenic_ost_clk_parents[] = { \"ext\" };\n\nstatic const struct ingenic_ost_clk_info x1000_ost_clk_info[] = {\n\t[OST_CLK_PERCPU_TIMER] = {\n\t\t.init_data = {\n\t\t\t.name = \"percpu timer\",\n\t\t\t.parent_names = ingenic_ost_clk_parents,\n\t\t\t.num_parents = ARRAY_SIZE(ingenic_ost_clk_parents),\n\t\t\t.ops = &ingenic_ost_percpu_timer_ops,\n\t\t\t.flags = CLK_SET_RATE_UNGATE,\n\t\t},\n\t\t.ostccr_reg = OST_REG_OSTCCR,\n\t},\n\n\t[OST_CLK_GLOBAL_TIMER] = {\n\t\t.init_data = {\n\t\t\t.name = \"global timer\",\n\t\t\t.parent_names = ingenic_ost_clk_parents,\n\t\t\t.num_parents = ARRAY_SIZE(ingenic_ost_clk_parents),\n\t\t\t.ops = &ingenic_ost_global_timer_ops,\n\t\t\t.flags = CLK_SET_RATE_UNGATE,\n\t\t},\n\t\t.ostccr_reg = OST_REG_OSTCCR,\n\t},\n};\n\nstatic u64 notrace ingenic_ost_global_timer_read_cntl(void)\n{\n\tstruct ingenic_ost *ost = ingenic_ost;\n\tunsigned int count;\n\n\tcount = readl(ost->base + OST_REG_OST2CNTL);\n\n\treturn count;\n}\n\nstatic u64 notrace ingenic_ost_clocksource_read(struct clocksource *cs)\n{\n\treturn ingenic_ost_global_timer_read_cntl();\n}\n\nstatic inline struct ingenic_ost *to_ingenic_ost(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct ingenic_ost, cevt);\n}\n\nstatic int ingenic_ost_cevt_set_state_shutdown(struct clock_event_device *evt)\n{\n\tstruct ingenic_ost *ost = to_ingenic_ost(evt);\n\n\twritel(OSTECR_OST1ENC, ost->base + OST_REG_OSTECR);\n\n\treturn 0;\n}\n\nstatic int ingenic_ost_cevt_set_next(unsigned long next,\n\t\t\t\t     struct clock_event_device *evt)\n{\n\tstruct ingenic_ost *ost = to_ingenic_ost(evt);\n\n\twritel((u32)~OSTFR_FFLAG, ost->base + OST_REG_OSTFR);\n\twritel(next, ost->base + OST_REG_OST1DFR);\n\twritel(OSTCR_OST1CLR, ost->base + OST_REG_OSTCR);\n\twritel(OSTESR_OST1ENS, ost->base + OST_REG_OSTESR);\n\twritel((u32)~OSTMR_FMASK, ost->base + OST_REG_OSTMR);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ingenic_ost_cevt_cb(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\tstruct ingenic_ost *ost = to_ingenic_ost(evt);\n\n\twritel(OSTECR_OST1ENC, ost->base + OST_REG_OSTECR);\n\n\tif (evt->event_handler)\n\t\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init ingenic_ost_register_clock(struct ingenic_ost *ost,\n\t\t\tunsigned int idx, const struct ingenic_ost_clk_info *info,\n\t\t\tstruct clk_hw_onecell_data *clocks)\n{\n\tstruct ingenic_ost_clk *ost_clk;\n\tint val, err;\n\n\tost_clk = kzalloc(sizeof(*ost_clk), GFP_KERNEL);\n\tif (!ost_clk)\n\t\treturn -ENOMEM;\n\n\tost_clk->hw.init = &info->init_data;\n\tost_clk->idx = idx;\n\tost_clk->info = info;\n\tost_clk->ost = ost;\n\n\t \n\tval = readl(ost->base + info->ostccr_reg);\n\tval &= ~(OSTCCR_PRESCALE1_MASK | OSTCCR_PRESCALE2_MASK);\n\twritel(val, ost->base + info->ostccr_reg);\n\n\terr = clk_hw_register(NULL, &ost_clk->hw);\n\tif (err) {\n\t\tkfree(ost_clk);\n\t\treturn err;\n\t}\n\n\tclocks->hws[idx] = &ost_clk->hw;\n\n\treturn 0;\n}\n\nstatic struct clk * __init ingenic_ost_get_clock(struct device_node *np, int id)\n{\n\tstruct of_phandle_args args;\n\n\targs.np = np;\n\targs.args_count = 1;\n\targs.args[0] = id;\n\n\treturn of_clk_get_from_provider(&args);\n}\n\nstatic int __init ingenic_ost_percpu_timer_init(struct device_node *np,\n\t\t\t\t\t struct ingenic_ost *ost)\n{\n\tunsigned int timer_virq, channel = OST_CLK_PERCPU_TIMER;\n\tunsigned long rate;\n\tint err;\n\n\tost->percpu_timer_clk = ingenic_ost_get_clock(np, channel);\n\tif (IS_ERR(ost->percpu_timer_clk))\n\t\treturn PTR_ERR(ost->percpu_timer_clk);\n\n\terr = clk_prepare_enable(ost->percpu_timer_clk);\n\tif (err)\n\t\tgoto err_clk_put;\n\n\trate = clk_get_rate(ost->percpu_timer_clk);\n\tif (!rate) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\ttimer_virq = of_irq_get(np, 0);\n\tif (!timer_virq) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tsnprintf(ost->name, sizeof(ost->name), \"OST percpu timer\");\n\n\terr = request_irq(timer_virq, ingenic_ost_cevt_cb, IRQF_TIMER,\n\t\t\t  ost->name, &ost->cevt);\n\tif (err)\n\t\tgoto err_irq_dispose_mapping;\n\n\tost->cevt.cpumask = cpumask_of(smp_processor_id());\n\tost->cevt.features = CLOCK_EVT_FEAT_ONESHOT;\n\tost->cevt.name = ost->name;\n\tost->cevt.rating = 400;\n\tost->cevt.set_state_shutdown = ingenic_ost_cevt_set_state_shutdown;\n\tost->cevt.set_next_event = ingenic_ost_cevt_set_next;\n\n\tclockevents_config_and_register(&ost->cevt, rate, 4, 0xffffffff);\n\n\treturn 0;\n\nerr_irq_dispose_mapping:\n\tirq_dispose_mapping(timer_virq);\nerr_clk_disable:\n\tclk_disable_unprepare(ost->percpu_timer_clk);\nerr_clk_put:\n\tclk_put(ost->percpu_timer_clk);\n\treturn err;\n}\n\nstatic int __init ingenic_ost_global_timer_init(struct device_node *np,\n\t\t\t\t\t       struct ingenic_ost *ost)\n{\n\tunsigned int channel = OST_CLK_GLOBAL_TIMER;\n\tstruct clocksource *cs = &ost->cs;\n\tunsigned long rate;\n\tint err;\n\n\tost->global_timer_clk = ingenic_ost_get_clock(np, channel);\n\tif (IS_ERR(ost->global_timer_clk))\n\t\treturn PTR_ERR(ost->global_timer_clk);\n\n\terr = clk_prepare_enable(ost->global_timer_clk);\n\tif (err)\n\t\tgoto err_clk_put;\n\n\trate = clk_get_rate(ost->global_timer_clk);\n\tif (!rate) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\twritel(OSTCR_OST2CLR, ost->base + OST_REG_OSTCR);\n\n\t \n\twritel(OSTESR_OST2ENS, ost->base + OST_REG_OSTESR);\n\n\tcs->name = \"ingenic-ost\";\n\tcs->rating = 400;\n\tcs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\tcs->mask = CLOCKSOURCE_MASK(32);\n\tcs->read = ingenic_ost_clocksource_read;\n\n\terr = clocksource_register_hz(cs, rate);\n\tif (err)\n\t\tgoto err_clk_disable;\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(ost->global_timer_clk);\nerr_clk_put:\n\tclk_put(ost->global_timer_clk);\n\treturn err;\n}\n\nstatic const struct ingenic_soc_info x1000_soc_info = {\n\t.num_channels = 2,\n};\n\nstatic const struct of_device_id __maybe_unused ingenic_ost_of_matches[] __initconst = {\n\t{ .compatible = \"ingenic,x1000-ost\", .data = &x1000_soc_info },\n\t{   }\n};\n\nstatic int __init ingenic_ost_probe(struct device_node *np)\n{\n\tconst struct of_device_id *id = of_match_node(ingenic_ost_of_matches, np);\n\tstruct ingenic_ost *ost;\n\tunsigned int i;\n\tint ret;\n\n\tost = kzalloc(sizeof(*ost), GFP_KERNEL);\n\tif (!ost)\n\t\treturn -ENOMEM;\n\n\tost->base = of_io_request_and_map(np, 0, of_node_full_name(np));\n\tif (IS_ERR(ost->base)) {\n\t\tpr_err(\"%s: Failed to map OST registers\\n\", __func__);\n\t\tret = PTR_ERR(ost->base);\n\t\tgoto err_free_ost;\n\t}\n\n\tost->clk = of_clk_get_by_name(np, \"ost\");\n\tif (IS_ERR(ost->clk)) {\n\t\tret = PTR_ERR(ost->clk);\n\t\tpr_crit(\"%s: Cannot get OST clock\\n\", __func__);\n\t\tgoto err_free_ost;\n\t}\n\n\tret = clk_prepare_enable(ost->clk);\n\tif (ret) {\n\t\tpr_crit(\"%s: Unable to enable OST clock\\n\", __func__);\n\t\tgoto err_put_clk;\n\t}\n\n\tost->soc_info = id->data;\n\n\tost->clocks = kzalloc(struct_size(ost->clocks, hws, ost->soc_info->num_channels),\n\t\t\t      GFP_KERNEL);\n\tif (!ost->clocks) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable;\n\t}\n\n\tost->clocks->num = ost->soc_info->num_channels;\n\n\tfor (i = 0; i < ost->clocks->num; i++) {\n\t\tret = ingenic_ost_register_clock(ost, i, &x1000_ost_clk_info[i], ost->clocks);\n\t\tif (ret) {\n\t\t\tpr_crit(\"%s: Cannot register clock %d\\n\", __func__, i);\n\t\t\tgoto err_unregister_ost_clocks;\n\t\t}\n\t}\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, ost->clocks);\n\tif (ret) {\n\t\tpr_crit(\"%s: Cannot add OF clock provider\\n\", __func__);\n\t\tgoto err_unregister_ost_clocks;\n\t}\n\n\tingenic_ost = ost;\n\n\treturn 0;\n\nerr_unregister_ost_clocks:\n\tfor (i = 0; i < ost->clocks->num; i++)\n\t\tif (ost->clocks->hws[i])\n\t\t\tclk_hw_unregister(ost->clocks->hws[i]);\n\tkfree(ost->clocks);\nerr_clk_disable:\n\tclk_disable_unprepare(ost->clk);\nerr_put_clk:\n\tclk_put(ost->clk);\nerr_free_ost:\n\tkfree(ost);\n\treturn ret;\n}\n\nstatic int __init ingenic_ost_init(struct device_node *np)\n{\n\tstruct ingenic_ost *ost;\n\tunsigned long rate;\n\tint ret;\n\n\tret = ingenic_ost_probe(np);\n\tif (ret) {\n\t\tpr_crit(\"%s: Failed to initialize OST clocks: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tof_node_clear_flag(np, OF_POPULATED);\n\n\tost = ingenic_ost;\n\tif (IS_ERR(ost))\n\t\treturn PTR_ERR(ost);\n\n\tret = ingenic_ost_global_timer_init(np, ost);\n\tif (ret) {\n\t\tpr_crit(\"%s: Unable to init global timer: %x\\n\", __func__, ret);\n\t\tgoto err_free_ingenic_ost;\n\t}\n\n\tret = ingenic_ost_percpu_timer_init(np, ost);\n\tif (ret)\n\t\tgoto err_ost_global_timer_cleanup;\n\n\t \n\trate = clk_get_rate(ost->global_timer_clk);\n\tsched_clock_register(ingenic_ost_global_timer_read_cntl, 32, rate);\n\n\treturn 0;\n\nerr_ost_global_timer_cleanup:\n\tclocksource_unregister(&ost->cs);\n\tclk_disable_unprepare(ost->global_timer_clk);\n\tclk_put(ost->global_timer_clk);\nerr_free_ingenic_ost:\n\tkfree(ost);\n\treturn ret;\n}\n\nTIMER_OF_DECLARE(x1000_ost,  \"ingenic,x1000-ost\",  ingenic_ost_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}