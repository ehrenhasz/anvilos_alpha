{
  "module_name": "timer-pistachio.c",
  "hash_id": "401982d345f48745f1b22c83bf7359c877dba7a7e1fec3adf2e9ada380708eef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-pistachio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sched_clock.h>\n#include <linux/time.h>\n\n \n#define CR_TIMER_CTRL_CFG\t\t0x00\n#define TIMER_ME_GLOBAL\t\t\tBIT(0)\n#define CR_TIMER_REV\t\t\t0x10\n\n \n#define TIMER_CFG\t\t\t0x20\n#define TIMER_ME_LOCAL\t\t\tBIT(0)\n#define TIMER_RELOAD_VALUE\t\t0x24\n#define TIMER_CURRENT_VALUE\t\t0x28\n#define TIMER_CURRENT_OVERFLOW_VALUE\t0x2C\n#define TIMER_IRQ_STATUS\t\t0x30\n#define TIMER_IRQ_CLEAR\t\t\t0x34\n#define TIMER_IRQ_MASK\t\t\t0x38\n\n#define PERIP_TIMER_CONTROL\t\t0x90\n\n \n#define RELOAD_VALUE\t\t\t0xffffffff\n\nstruct pistachio_clocksource {\n\tvoid __iomem *base;\n\traw_spinlock_t lock;\n\tstruct clocksource cs;\n};\n\nstatic struct pistachio_clocksource pcs_gpt;\n\n#define to_pistachio_clocksource(cs)\t\\\n\tcontainer_of(cs, struct pistachio_clocksource, cs)\n\nstatic inline u32 gpt_readl(void __iomem *base, u32 offset, u32 gpt_id)\n{\n\treturn readl(base + 0x20 * gpt_id + offset);\n}\n\nstatic inline void gpt_writel(void __iomem *base, u32 value, u32 offset,\n\t\tu32 gpt_id)\n{\n\twritel(value, base + 0x20 * gpt_id + offset);\n}\n\nstatic u64 notrace\npistachio_clocksource_read_cycles(struct clocksource *cs)\n{\n\tstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\n\t__maybe_unused u32 overflow;\n\tu32 counter;\n\tunsigned long flags;\n\n\t \n\n\traw_spin_lock_irqsave(&pcs->lock, flags);\n\toverflow = gpt_readl(pcs->base, TIMER_CURRENT_OVERFLOW_VALUE, 0);\n\tcounter = gpt_readl(pcs->base, TIMER_CURRENT_VALUE, 0);\n\traw_spin_unlock_irqrestore(&pcs->lock, flags);\n\n\treturn (u64)~counter;\n}\n\nstatic u64 notrace pistachio_read_sched_clock(void)\n{\n\treturn pistachio_clocksource_read_cycles(&pcs_gpt.cs);\n}\n\nstatic void pistachio_clksrc_set_mode(struct clocksource *cs, int timeridx,\n\t\t\tint enable)\n{\n\tstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\n\tu32 val;\n\n\tval = gpt_readl(pcs->base, TIMER_CFG, timeridx);\n\tif (enable)\n\t\tval |= TIMER_ME_LOCAL;\n\telse\n\t\tval &= ~TIMER_ME_LOCAL;\n\n\tgpt_writel(pcs->base, val, TIMER_CFG, timeridx);\n}\n\nstatic void pistachio_clksrc_enable(struct clocksource *cs, int timeridx)\n{\n\tstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\n\n\t \n\tpistachio_clksrc_set_mode(cs, timeridx, false);\n\tgpt_writel(pcs->base, RELOAD_VALUE, TIMER_RELOAD_VALUE, timeridx);\n\tpistachio_clksrc_set_mode(cs, timeridx, true);\n}\n\nstatic void pistachio_clksrc_disable(struct clocksource *cs, int timeridx)\n{\n\t \n\tpistachio_clksrc_set_mode(cs, timeridx, false);\n}\n\nstatic int pistachio_clocksource_enable(struct clocksource *cs)\n{\n\tpistachio_clksrc_enable(cs, 0);\n\treturn 0;\n}\n\nstatic void pistachio_clocksource_disable(struct clocksource *cs)\n{\n\tpistachio_clksrc_disable(cs, 0);\n}\n\n \nstatic struct pistachio_clocksource pcs_gpt = {\n\t.cs =\t{\n\t\t.name\t\t= \"gptimer\",\n\t\t.rating\t\t= 300,\n\t\t.enable\t\t= pistachio_clocksource_enable,\n\t\t.disable\t= pistachio_clocksource_disable,\n\t\t.read\t\t= pistachio_clocksource_read_cycles,\n\t\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS |\n\t\t\t\t  CLOCK_SOURCE_SUSPEND_NONSTOP,\n\t\t},\n};\n\nstatic int __init pistachio_clksrc_of_init(struct device_node *node)\n{\n\tstruct clk *sys_clk, *fast_clk;\n\tstruct regmap *periph_regs;\n\tunsigned long rate;\n\tint ret;\n\n\tpcs_gpt.base = of_iomap(node, 0);\n\tif (!pcs_gpt.base) {\n\t\tpr_err(\"cannot iomap\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tperiph_regs = syscon_regmap_lookup_by_phandle(node, \"img,cr-periph\");\n\tif (IS_ERR(periph_regs)) {\n\t\tpr_err(\"cannot get peripheral regmap (%ld)\\n\",\n\t\t       PTR_ERR(periph_regs));\n\t\treturn PTR_ERR(periph_regs);\n\t}\n\n\t \n\tret = regmap_update_bits(periph_regs, PERIP_TIMER_CONTROL,\n\t\t\t\t 0xf, 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\tsys_clk = of_clk_get_by_name(node, \"sys\");\n\tif (IS_ERR(sys_clk)) {\n\t\tpr_err(\"clock get failed (%ld)\\n\", PTR_ERR(sys_clk));\n\t\treturn PTR_ERR(sys_clk);\n\t}\n\n\tfast_clk = of_clk_get_by_name(node, \"fast\");\n\tif (IS_ERR(fast_clk)) {\n\t\tpr_err(\"clock get failed (%lu)\\n\", PTR_ERR(fast_clk));\n\t\treturn PTR_ERR(fast_clk);\n\t}\n\n\tret = clk_prepare_enable(sys_clk);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to enable clock (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(fast_clk);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to enable clock (%d)\\n\", ret);\n\t\tclk_disable_unprepare(sys_clk);\n\t\treturn ret;\n\t}\n\n\trate = clk_get_rate(fast_clk);\n\n\t \n\tgpt_writel(pcs_gpt.base, 0, TIMER_IRQ_MASK, 0);\n\tgpt_writel(pcs_gpt.base, 0, TIMER_IRQ_MASK, 1);\n\tgpt_writel(pcs_gpt.base, 0, TIMER_IRQ_MASK, 2);\n\tgpt_writel(pcs_gpt.base, 0, TIMER_IRQ_MASK, 3);\n\n\t \n\twritel(TIMER_ME_GLOBAL, pcs_gpt.base);\n\n\traw_spin_lock_init(&pcs_gpt.lock);\n\tsched_clock_register(pistachio_read_sched_clock, 32, rate);\n\treturn clocksource_register_hz(&pcs_gpt.cs, rate);\n}\nTIMER_OF_DECLARE(pistachio_gptimer, \"img,pistachio-gptimer\",\n\t\t       pistachio_clksrc_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}