{
  "module_name": "timer-sp804.c",
  "hash_id": "aeace4d69c199f6df65a81c3993439bf20639b86ee0f7bd8875d271de26e2705",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-sp804.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_clk.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#include \"timer-sp.h\"\n\n \n#define HISI_TIMER_1_BASE\t0x00\n#define HISI_TIMER_2_BASE\t0x40\n#define HISI_TIMER_LOAD\t\t0x00\n#define HISI_TIMER_LOAD_H\t0x04\n#define HISI_TIMER_VALUE\t0x08\n#define HISI_TIMER_VALUE_H\t0x0c\n#define HISI_TIMER_CTRL\t\t0x10\n#define HISI_TIMER_INTCLR\t0x14\n#define HISI_TIMER_RIS\t\t0x18\n#define HISI_TIMER_MIS\t\t0x1c\n#define HISI_TIMER_BGLOAD\t0x20\n#define HISI_TIMER_BGLOAD_H\t0x24\n\nstatic struct sp804_timer arm_sp804_timer __initdata = {\n\t.load\t\t= TIMER_LOAD,\n\t.value\t\t= TIMER_VALUE,\n\t.ctrl\t\t= TIMER_CTRL,\n\t.intclr\t\t= TIMER_INTCLR,\n\t.timer_base\t= {TIMER_1_BASE, TIMER_2_BASE},\n\t.width\t\t= 32,\n};\n\nstatic struct sp804_timer hisi_sp804_timer __initdata = {\n\t.load\t\t= HISI_TIMER_LOAD,\n\t.load_h\t\t= HISI_TIMER_LOAD_H,\n\t.value\t\t= HISI_TIMER_VALUE,\n\t.value_h\t= HISI_TIMER_VALUE_H,\n\t.ctrl\t\t= HISI_TIMER_CTRL,\n\t.intclr\t\t= HISI_TIMER_INTCLR,\n\t.timer_base\t= {HISI_TIMER_1_BASE, HISI_TIMER_2_BASE},\n\t.width\t\t= 64,\n};\n\nstatic struct sp804_clkevt sp804_clkevt[NR_TIMERS];\n\nstatic long __init sp804_get_clock_rate(struct clk *clk, const char *name)\n{\n\tint err;\n\n\tif (!clk)\n\t\tclk = clk_get_sys(\"sp804\", name);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"%s clock not found: %ld\\n\", name, PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tpr_err(\"clock failed to enable: %d\\n\", err);\n\t\tclk_put(clk);\n\t\treturn err;\n\t}\n\n\treturn clk_get_rate(clk);\n}\n\nstatic struct sp804_clkevt * __init sp804_clkevt_get(void __iomem *base)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_TIMERS; i++) {\n\t\tif (sp804_clkevt[i].base == base)\n\t\t\treturn &sp804_clkevt[i];\n\t}\n\n\t \n\tWARN_ON(1);\n\n\treturn NULL;\n}\n\nstatic struct sp804_clkevt *sched_clkevt;\n\nstatic u64 notrace sp804_read(void)\n{\n\treturn ~readl_relaxed(sched_clkevt->value);\n}\n\nstatic int __init sp804_clocksource_and_sched_clock_init(void __iomem *base,\n\t\t\t\t\t\t\t const char *name,\n\t\t\t\t\t\t\t struct clk *clk,\n\t\t\t\t\t\t\t int use_sched_clock)\n{\n\tlong rate;\n\tstruct sp804_clkevt *clkevt;\n\n\trate = sp804_get_clock_rate(clk, name);\n\tif (rate < 0)\n\t\treturn -EINVAL;\n\n\tclkevt = sp804_clkevt_get(base);\n\n\twritel(0, clkevt->ctrl);\n\twritel(0xffffffff, clkevt->load);\n\twritel(0xffffffff, clkevt->value);\n\tif (clkevt->width == 64) {\n\t\twritel(0xffffffff, clkevt->load_h);\n\t\twritel(0xffffffff, clkevt->value_h);\n\t}\n\twritel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,\n\t\tclkevt->ctrl);\n\n\tclocksource_mmio_init(clkevt->value, name,\n\t\trate, 200, 32, clocksource_mmio_readl_down);\n\n\tif (use_sched_clock) {\n\t\tsched_clkevt = clkevt;\n\t\tsched_clock_register(sp804_read, 32, rate);\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct sp804_clkevt *common_clkevt;\n\n \nstatic irqreturn_t sp804_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\t \n\twritel(1, common_clkevt->intclr);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void evt_timer_shutdown(struct clock_event_device *evt)\n{\n\twritel(0, common_clkevt->ctrl);\n}\n\nstatic int sp804_shutdown(struct clock_event_device *evt)\n{\n\tevt_timer_shutdown(evt);\n\treturn 0;\n}\n\nstatic int sp804_set_periodic(struct clock_event_device *evt)\n{\n\tunsigned long ctrl = TIMER_CTRL_32BIT | TIMER_CTRL_IE |\n\t\t\t     TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\n\n\tevt_timer_shutdown(evt);\n\twritel(common_clkevt->reload, common_clkevt->load);\n\twritel(ctrl, common_clkevt->ctrl);\n\treturn 0;\n}\n\nstatic int sp804_set_next_event(unsigned long next,\n\tstruct clock_event_device *evt)\n{\n\tunsigned long ctrl = TIMER_CTRL_32BIT | TIMER_CTRL_IE |\n\t\t\t     TIMER_CTRL_ONESHOT | TIMER_CTRL_ENABLE;\n\n\twritel(next, common_clkevt->load);\n\twritel(ctrl, common_clkevt->ctrl);\n\n\treturn 0;\n}\n\nstatic struct clock_event_device sp804_clockevent = {\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_DYNIRQ,\n\t.set_state_shutdown\t= sp804_shutdown,\n\t.set_state_periodic\t= sp804_set_periodic,\n\t.set_state_oneshot\t= sp804_shutdown,\n\t.tick_resume\t\t= sp804_shutdown,\n\t.set_next_event\t\t= sp804_set_next_event,\n\t.rating\t\t\t= 300,\n};\n\nstatic int __init sp804_clockevents_init(void __iomem *base, unsigned int irq,\n\t\t\t\t\t struct clk *clk, const char *name)\n{\n\tstruct clock_event_device *evt = &sp804_clockevent;\n\tlong rate;\n\n\trate = sp804_get_clock_rate(clk, name);\n\tif (rate < 0)\n\t\treturn -EINVAL;\n\n\tcommon_clkevt = sp804_clkevt_get(base);\n\tcommon_clkevt->reload = DIV_ROUND_CLOSEST(rate, HZ);\n\tevt->name = name;\n\tevt->irq = irq;\n\tevt->cpumask = cpu_possible_mask;\n\n\twritel(0, common_clkevt->ctrl);\n\n\tif (request_irq(irq, sp804_timer_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t\"timer\", &sp804_clockevent))\n\t\tpr_err(\"request_irq() failed\\n\");\n\tclockevents_config_and_register(evt, rate, 0xf, 0xffffffff);\n\n\treturn 0;\n}\n\nstatic void __init sp804_clkevt_init(struct sp804_timer *timer, void __iomem *base)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_TIMERS; i++) {\n\t\tvoid __iomem *timer_base;\n\t\tstruct sp804_clkevt *clkevt;\n\n\t\ttimer_base = base + timer->timer_base[i];\n\t\tclkevt = &sp804_clkevt[i];\n\t\tclkevt->base\t= timer_base;\n\t\tclkevt->load\t= timer_base + timer->load;\n\t\tclkevt->load_h\t= timer_base + timer->load_h;\n\t\tclkevt->value\t= timer_base + timer->value;\n\t\tclkevt->value_h\t= timer_base + timer->value_h;\n\t\tclkevt->ctrl\t= timer_base + timer->ctrl;\n\t\tclkevt->intclr\t= timer_base + timer->intclr;\n\t\tclkevt->width\t= timer->width;\n\t}\n}\n\nstatic int __init sp804_of_init(struct device_node *np, struct sp804_timer *timer)\n{\n\tstatic bool initialized = false;\n\tvoid __iomem *base;\n\tvoid __iomem *timer1_base;\n\tvoid __iomem *timer2_base;\n\tint irq, ret = -EINVAL;\n\tu32 irq_num = 0;\n\tstruct clk *clk1, *clk2;\n\tconst char *name = of_get_property(np, \"compatible\", NULL);\n\n\tif (initialized) {\n\t\tpr_debug(\"%pOF: skipping further SP804 timer device\\n\", np);\n\t\treturn 0;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base)\n\t\treturn -ENXIO;\n\n\ttimer1_base = base + timer->timer_base[0];\n\ttimer2_base = base + timer->timer_base[1];\n\n\t \n\twritel(0, timer1_base + timer->ctrl);\n\twritel(0, timer2_base + timer->ctrl);\n\n\tclk1 = of_clk_get(np, 0);\n\tif (IS_ERR(clk1))\n\t\tclk1 = NULL;\n\n\t \n\tif (of_clk_get_parent_count(np) == 3) {\n\t\tclk2 = of_clk_get(np, 1);\n\t\tif (IS_ERR(clk2)) {\n\t\t\tpr_err(\"%pOFn clock not found: %d\\n\", np,\n\t\t\t\t(int)PTR_ERR(clk2));\n\t\t\tclk2 = NULL;\n\t\t}\n\t} else\n\t\tclk2 = clk1;\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0)\n\t\tgoto err;\n\n\tsp804_clkevt_init(timer, base);\n\n\tof_property_read_u32(np, \"arm,sp804-has-irq\", &irq_num);\n\tif (irq_num == 2) {\n\n\t\tret = sp804_clockevents_init(timer2_base, irq, clk2, name);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = sp804_clocksource_and_sched_clock_init(timer1_base,\n\t\t\t\t\t\t\t     name, clk1, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\n\t\tret = sp804_clockevents_init(timer1_base, irq, clk1, name);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = sp804_clocksource_and_sched_clock_init(timer2_base,\n\t\t\t\t\t\t\t     name, clk2, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\tinitialized = true;\n\n\treturn 0;\nerr:\n\tiounmap(base);\n\treturn ret;\n}\n\nstatic int __init arm_sp804_of_init(struct device_node *np)\n{\n\treturn sp804_of_init(np, &arm_sp804_timer);\n}\nTIMER_OF_DECLARE(sp804, \"arm,sp804\", arm_sp804_of_init);\n\nstatic int __init hisi_sp804_of_init(struct device_node *np)\n{\n\treturn sp804_of_init(np, &hisi_sp804_timer);\n}\nTIMER_OF_DECLARE(hisi_sp804, \"hisilicon,sp804\", hisi_sp804_of_init);\n\nstatic int __init integrator_cp_of_init(struct device_node *np)\n{\n\tstatic int init_count = 0;\n\tvoid __iomem *base;\n\tint irq, ret = -EINVAL;\n\tconst char *name = of_get_property(np, \"compatible\", NULL);\n\tstruct clk *clk;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"Failed to iomap\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\twritel(0, base + arm_sp804_timer.ctrl);\n\n\tif (init_count == 2 || !of_device_is_available(np))\n\t\tgoto err;\n\n\tsp804_clkevt_init(&arm_sp804_timer, base);\n\n\tif (!init_count) {\n\t\tret = sp804_clocksource_and_sched_clock_init(base,\n\t\t\t\t\t\t\t     name, clk, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tirq = irq_of_parse_and_map(np, 0);\n\t\tif (irq <= 0)\n\t\t\tgoto err;\n\n\t\tret = sp804_clockevents_init(base, irq, clk, name);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tinit_count++;\n\treturn 0;\nerr:\n\tiounmap(base);\n\treturn ret;\n}\nTIMER_OF_DECLARE(intcp, \"arm,integrator-cp-timer\", integrator_cp_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}