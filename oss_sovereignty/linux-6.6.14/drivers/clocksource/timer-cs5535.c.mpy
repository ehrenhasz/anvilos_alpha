{
  "module_name": "timer-cs5535.c",
  "hash_id": "7d677f3d8623ec4cd95830b44c536a33dc1d1ad8797223144058a0659e511565",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-cs5535.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/cs5535.h>\n#include <linux/clockchips.h>\n\n#define DRV_NAME \"cs5535-clockevt\"\n\nstatic int timer_irq;\nmodule_param_hw_named(irq, timer_irq, int, irq, 0644);\nMODULE_PARM_DESC(irq, \"Which IRQ to use for the clock source MFGPT ticks.\");\n\n \n\nstatic struct cs5535_mfgpt_timer *cs5535_event_clock;\n\n \n\n#define MFGPT_DIVISOR 16\n#define MFGPT_SCALE  4      \n#define MFGPT_HZ  (32768 / MFGPT_DIVISOR)\n#define MFGPT_PERIODIC (MFGPT_HZ / HZ)\n\n \n\nstatic void disable_timer(struct cs5535_mfgpt_timer *timer)\n{\n\t \n\tcs5535_mfgpt_write(timer, MFGPT_REG_SETUP,\n\t\t\t(uint16_t) ~MFGPT_SETUP_CNTEN | MFGPT_SETUP_CMP1 |\n\t\t\t\tMFGPT_SETUP_CMP2);\n}\n\nstatic void start_timer(struct cs5535_mfgpt_timer *timer, uint16_t delta)\n{\n\tcs5535_mfgpt_write(timer, MFGPT_REG_CMP2, delta);\n\tcs5535_mfgpt_write(timer, MFGPT_REG_COUNTER, 0);\n\n\tcs5535_mfgpt_write(timer, MFGPT_REG_SETUP,\n\t\t\tMFGPT_SETUP_CNTEN | MFGPT_SETUP_CMP2);\n}\n\nstatic int mfgpt_shutdown(struct clock_event_device *evt)\n{\n\tdisable_timer(cs5535_event_clock);\n\treturn 0;\n}\n\nstatic int mfgpt_set_periodic(struct clock_event_device *evt)\n{\n\tdisable_timer(cs5535_event_clock);\n\tstart_timer(cs5535_event_clock, MFGPT_PERIODIC);\n\treturn 0;\n}\n\nstatic int mfgpt_next_event(unsigned long delta, struct clock_event_device *evt)\n{\n\tstart_timer(cs5535_event_clock, delta);\n\treturn 0;\n}\n\nstatic struct clock_event_device cs5535_clockevent = {\n\t.name = DRV_NAME,\n\t.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_shutdown = mfgpt_shutdown,\n\t.set_state_periodic = mfgpt_set_periodic,\n\t.set_state_oneshot = mfgpt_shutdown,\n\t.tick_resume = mfgpt_shutdown,\n\t.set_next_event = mfgpt_next_event,\n\t.rating = 250,\n};\n\nstatic irqreturn_t mfgpt_tick(int irq, void *dev_id)\n{\n\tuint16_t val = cs5535_mfgpt_read(cs5535_event_clock, MFGPT_REG_SETUP);\n\n\t \n\tif (!(val & (MFGPT_SETUP_SETUP | MFGPT_SETUP_CMP2 | MFGPT_SETUP_CMP1)))\n\t\treturn IRQ_NONE;\n\n\t \n\tdisable_timer(cs5535_event_clock);\n\n\tif (clockevent_state_detached(&cs5535_clockevent) ||\n\t    clockevent_state_shutdown(&cs5535_clockevent))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tcs5535_mfgpt_write(cs5535_event_clock, MFGPT_REG_COUNTER, 0);\n\n\t \n\n\tif (clockevent_state_periodic(&cs5535_clockevent))\n\t\tcs5535_mfgpt_write(cs5535_event_clock, MFGPT_REG_SETUP,\n\t\t\t\tMFGPT_SETUP_CNTEN | MFGPT_SETUP_CMP2);\n\n\tcs5535_clockevent.event_handler(&cs5535_clockevent);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init cs5535_mfgpt_init(void)\n{\n\tunsigned long flags = IRQF_NOBALANCING | IRQF_TIMER | IRQF_SHARED;\n\tstruct cs5535_mfgpt_timer *timer;\n\tint ret;\n\tuint16_t val;\n\n\ttimer = cs5535_mfgpt_alloc_timer(MFGPT_TIMER_ANY, MFGPT_DOMAIN_WORKING);\n\tif (!timer) {\n\t\tprintk(KERN_ERR DRV_NAME \": Could not allocate MFGPT timer\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcs5535_event_clock = timer;\n\n\t \n\tif (cs5535_mfgpt_setup_irq(timer, MFGPT_CMP2, &timer_irq)) {\n\t\tprintk(KERN_ERR DRV_NAME \": Could not set up IRQ %d\\n\",\n\t\t\t\ttimer_irq);\n\t\tgoto err_timer;\n\t}\n\n\t \n\tret = request_irq(timer_irq, mfgpt_tick, flags, DRV_NAME, timer);\n\tif (ret) {\n\t\tprintk(KERN_ERR DRV_NAME \": Unable to set up the interrupt.\\n\");\n\t\tgoto err_irq;\n\t}\n\n\t \n\tval = MFGPT_SCALE | (3 << 8);\n\n\tcs5535_mfgpt_write(cs5535_event_clock, MFGPT_REG_SETUP, val);\n\n\t \n\tprintk(KERN_INFO DRV_NAME\n\t\t\": Registering MFGPT timer as a clock event, using IRQ %d\\n\",\n\t\ttimer_irq);\n\tclockevents_config_and_register(&cs5535_clockevent, MFGPT_HZ,\n\t\t\t\t\t0xF, 0xFFFE);\n\n\treturn 0;\n\nerr_irq:\n\tcs5535_mfgpt_release_irq(cs5535_event_clock, MFGPT_CMP2, &timer_irq);\nerr_timer:\n\tcs5535_mfgpt_free_timer(cs5535_event_clock);\n\tprintk(KERN_ERR DRV_NAME \": Unable to set up the MFGPT clock source\\n\");\n\treturn -EIO;\n}\n\nmodule_init(cs5535_mfgpt_init);\n\nMODULE_AUTHOR(\"Andres Salomon <dilinger@queued.net>\");\nMODULE_DESCRIPTION(\"CS5535/CS5536 MFGPT clock event driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}