{
  "module_name": "mips-gic-timer.c",
  "hash_id": "c79d79b90f025f92cff3e7424611d08cb6f4dddebfa9d6e89bc44e5a469f9cdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/mips-gic-timer.c",
  "human_readable_source": "\n\n\n#define pr_fmt(fmt) \"mips-gic-timer: \" fmt\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/of_irq.h>\n#include <linux/percpu.h>\n#include <linux/sched_clock.h>\n#include <linux/smp.h>\n#include <linux/time.h>\n#include <asm/mips-cps.h>\n\nstatic DEFINE_PER_CPU(struct clock_event_device, gic_clockevent_device);\nstatic int gic_timer_irq;\nstatic unsigned int gic_frequency;\nstatic bool __read_mostly gic_clock_unstable;\n\nstatic void gic_clocksource_unstable(char *reason);\n\nstatic u64 notrace gic_read_count_2x32(void)\n{\n\tunsigned int hi, hi2, lo;\n\n\tdo {\n\t\thi = read_gic_counter_32h();\n\t\tlo = read_gic_counter_32l();\n\t\thi2 = read_gic_counter_32h();\n\t} while (hi2 != hi);\n\n\treturn (((u64) hi) << 32) + lo;\n}\n\nstatic u64 notrace gic_read_count_64(void)\n{\n\treturn read_gic_counter();\n}\n\nstatic u64 notrace gic_read_count(void)\n{\n\tif (mips_cm_is64)\n\t\treturn gic_read_count_64();\n\n\treturn gic_read_count_2x32();\n}\n\nstatic int gic_next_event(unsigned long delta, struct clock_event_device *evt)\n{\n\tint cpu = cpumask_first(evt->cpumask);\n\tu64 cnt;\n\tint res;\n\n\tcnt = gic_read_count();\n\tcnt += (u64)delta;\n\tif (cpu == raw_smp_processor_id()) {\n\t\twrite_gic_vl_compare(cnt);\n\t} else {\n\t\twrite_gic_vl_other(mips_cm_vp_id(cpu));\n\t\twrite_gic_vo_compare(cnt);\n\t}\n\tres = ((int)(gic_read_count() - cnt) >= 0) ? -ETIME : 0;\n\treturn res;\n}\n\nstatic irqreturn_t gic_compare_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *cd = dev_id;\n\n\twrite_gic_vl_compare(read_gic_vl_compare());\n\tcd->event_handler(cd);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct irqaction gic_compare_irqaction = {\n\t.handler = gic_compare_interrupt,\n\t.percpu_dev_id = &gic_clockevent_device,\n\t.flags = IRQF_PERCPU | IRQF_TIMER,\n\t.name = \"timer\",\n};\n\nstatic void gic_clockevent_cpu_init(unsigned int cpu,\n\t\t\t\t    struct clock_event_device *cd)\n{\n\tcd->name\t\t= \"MIPS GIC\";\n\tcd->features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_C3STOP;\n\n\tcd->rating\t\t= 350;\n\tcd->irq\t\t\t= gic_timer_irq;\n\tcd->cpumask\t\t= cpumask_of(cpu);\n\tcd->set_next_event\t= gic_next_event;\n\n\tclockevents_config_and_register(cd, gic_frequency, 0x300, 0x7fffffff);\n\n\tenable_percpu_irq(gic_timer_irq, IRQ_TYPE_NONE);\n}\n\nstatic void gic_clockevent_cpu_exit(struct clock_event_device *cd)\n{\n\tdisable_percpu_irq(gic_timer_irq);\n}\n\nstatic void gic_update_frequency(void *data)\n{\n\tunsigned long rate = (unsigned long)data;\n\n\tclockevents_update_freq(this_cpu_ptr(&gic_clockevent_device), rate);\n}\n\nstatic int gic_starting_cpu(unsigned int cpu)\n{\n\tgic_clockevent_cpu_init(cpu, this_cpu_ptr(&gic_clockevent_device));\n\treturn 0;\n}\n\nstatic int gic_clk_notifier(struct notifier_block *nb, unsigned long action,\n\t\t\t    void *data)\n{\n\tstruct clk_notifier_data *cnd = data;\n\n\tif (action == POST_RATE_CHANGE) {\n\t\tgic_clocksource_unstable(\"ref clock rate change\");\n\t\ton_each_cpu(gic_update_frequency, (void *)cnd->new_rate, 1);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int gic_dying_cpu(unsigned int cpu)\n{\n\tgic_clockevent_cpu_exit(this_cpu_ptr(&gic_clockevent_device));\n\treturn 0;\n}\n\nstatic struct notifier_block gic_clk_nb = {\n\t.notifier_call = gic_clk_notifier,\n};\n\nstatic int gic_clockevent_init(void)\n{\n\tint ret;\n\n\tif (!gic_frequency)\n\t\treturn -ENXIO;\n\n\tret = setup_percpu_irq(gic_timer_irq, &gic_compare_irqaction);\n\tif (ret < 0) {\n\t\tpr_err(\"IRQ %d setup failed (%d)\\n\", gic_timer_irq, ret);\n\t\treturn ret;\n\t}\n\n\tcpuhp_setup_state(CPUHP_AP_MIPS_GIC_TIMER_STARTING,\n\t\t\t  \"clockevents/mips/gic/timer:starting\",\n\t\t\t  gic_starting_cpu, gic_dying_cpu);\n\treturn 0;\n}\n\nstatic u64 gic_hpt_read(struct clocksource *cs)\n{\n\treturn gic_read_count();\n}\n\nstatic struct clocksource gic_clocksource = {\n\t.name\t\t\t= \"GIC\",\n\t.read\t\t\t= gic_hpt_read,\n\t.flags\t\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.vdso_clock_mode\t= VDSO_CLOCKMODE_GIC,\n};\n\nstatic void gic_clocksource_unstable(char *reason)\n{\n\tif (gic_clock_unstable)\n\t\treturn;\n\n\tgic_clock_unstable = true;\n\n\tpr_info(\"GIC timer is unstable due to %s\\n\", reason);\n\n\tclocksource_mark_unstable(&gic_clocksource);\n}\n\nstatic int __init __gic_clocksource_init(void)\n{\n\tunsigned int count_width;\n\tint ret;\n\n\t \n\tcount_width = read_gic_config() & GIC_CONFIG_COUNTBITS;\n\tcount_width >>= __ffs(GIC_CONFIG_COUNTBITS);\n\tcount_width *= 4;\n\tcount_width += 32;\n\tgic_clocksource.mask = CLOCKSOURCE_MASK(count_width);\n\n\t \n\tgic_clocksource.rating = 200 + gic_frequency / 10000000;\n\n\tret = clocksource_register_hz(&gic_clocksource, gic_frequency);\n\tif (ret < 0)\n\t\tpr_warn(\"Unable to register clocksource\\n\");\n\n\treturn ret;\n}\n\nstatic int __init gic_clocksource_of_init(struct device_node *node)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tif (!mips_gic_present() || !node->parent ||\n\t    !of_device_is_compatible(node->parent, \"mti,gic\")) {\n\t\tpr_warn(\"No DT definition\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tclk = of_clk_get(node, 0);\n\tif (!IS_ERR(clk)) {\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Failed to enable clock\\n\");\n\t\t\tclk_put(clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgic_frequency = clk_get_rate(clk);\n\t} else if (of_property_read_u32(node, \"clock-frequency\",\n\t\t\t\t\t&gic_frequency)) {\n\t\tpr_err(\"Frequency not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgic_timer_irq = irq_of_parse_and_map(node, 0);\n\tif (!gic_timer_irq) {\n\t\tpr_err(\"IRQ not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = __gic_clocksource_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = gic_clockevent_init();\n\tif (!ret && !IS_ERR(clk)) {\n\t\tif (clk_notifier_register(clk, &gic_clk_nb) < 0)\n\t\t\tpr_warn(\"Unable to register clock notifier\\n\");\n\t}\n\n\t \n\tclear_gic_config(GIC_CONFIG_COUNTSTOP);\n\n\t \n\tif (mips_cm_revision() >= CM_REV_CM3 || !IS_ENABLED(CONFIG_CPU_FREQ)) {\n\t\tsched_clock_register(mips_cm_is64 ?\n\t\t\t\t     gic_read_count_64 : gic_read_count_2x32,\n\t\t\t\t     64, gic_frequency);\n\t}\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(mips_gic_timer, \"mti,gic-timer\",\n\t\t       gic_clocksource_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}