{
  "module_name": "timer-pxa.c",
  "hash_id": "b7f2c9663135b008482059972c92d8fc0064aee95033d07d95b1d07e3a7180b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-pxa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched/clock.h>\n#include <linux/sched_clock.h>\n\n#include <clocksource/pxa.h>\n\n#include <asm/div64.h>\n\n#define OSMR0\t\t0x00\t \n#define OSMR1\t\t0x04\t \n#define OSMR2\t\t0x08\t \n#define OSMR3\t\t0x0C\t \n\n#define OSCR\t\t0x10\t \n#define OSSR\t\t0x14\t \n#define OWER\t\t0x18\t \n#define OIER\t\t0x1C\t \n\n#define OSSR_M3\t\t(1 << 3)\t \n#define OSSR_M2\t\t(1 << 2)\t \n#define OSSR_M1\t\t(1 << 1)\t \n#define OSSR_M0\t\t(1 << 0)\t \n\n#define OIER_E0\t\t(1 << 0)\t \n\n \n\n#define timer_readl(reg) readl_relaxed(timer_base + (reg))\n#define timer_writel(val, reg) writel_relaxed((val), timer_base + (reg))\n\nstatic void __iomem *timer_base;\n\nstatic u64 notrace pxa_read_sched_clock(void)\n{\n\treturn timer_readl(OSCR);\n}\n\n\n#define MIN_OSCR_DELTA 16\n\nstatic irqreturn_t\npxa_ost0_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *c = dev_id;\n\n\t \n\ttimer_writel(timer_readl(OIER) & ~OIER_E0, OIER);\n\ttimer_writel(OSSR_M0, OSSR);\n\tc->event_handler(c);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\npxa_osmr0_set_next_event(unsigned long delta, struct clock_event_device *dev)\n{\n\tunsigned long next, oscr;\n\n\ttimer_writel(timer_readl(OIER) | OIER_E0, OIER);\n\tnext = timer_readl(OSCR) + delta;\n\ttimer_writel(next, OSMR0);\n\toscr = timer_readl(OSCR);\n\n\treturn (signed)(next - oscr) <= MIN_OSCR_DELTA ? -ETIME : 0;\n}\n\nstatic int pxa_osmr0_shutdown(struct clock_event_device *evt)\n{\n\t \n\ttimer_writel(timer_readl(OIER) & ~OIER_E0, OIER);\n\ttimer_writel(OSSR_M0, OSSR);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic unsigned long osmr[4], oier, oscr;\n\nstatic void pxa_timer_suspend(struct clock_event_device *cedev)\n{\n\tosmr[0] = timer_readl(OSMR0);\n\tosmr[1] = timer_readl(OSMR1);\n\tosmr[2] = timer_readl(OSMR2);\n\tosmr[3] = timer_readl(OSMR3);\n\toier = timer_readl(OIER);\n\toscr = timer_readl(OSCR);\n}\n\nstatic void pxa_timer_resume(struct clock_event_device *cedev)\n{\n\t \n\tif (osmr[0] - oscr < MIN_OSCR_DELTA)\n\t\tosmr[0] += MIN_OSCR_DELTA;\n\n\ttimer_writel(osmr[0], OSMR0);\n\ttimer_writel(osmr[1], OSMR1);\n\ttimer_writel(osmr[2], OSMR2);\n\ttimer_writel(osmr[3], OSMR3);\n\ttimer_writel(oier, OIER);\n\ttimer_writel(oscr, OSCR);\n}\n#else\n#define pxa_timer_suspend NULL\n#define pxa_timer_resume NULL\n#endif\n\nstatic struct clock_event_device ckevt_pxa_osmr0 = {\n\t.name\t\t\t= \"osmr0\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 200,\n\t.set_next_event\t\t= pxa_osmr0_set_next_event,\n\t.set_state_shutdown\t= pxa_osmr0_shutdown,\n\t.set_state_oneshot\t= pxa_osmr0_shutdown,\n\t.suspend\t\t= pxa_timer_suspend,\n\t.resume\t\t\t= pxa_timer_resume,\n};\n\nstatic int __init pxa_timer_common_init(int irq, unsigned long clock_tick_rate)\n{\n\tint ret;\n\n\ttimer_writel(0, OIER);\n\ttimer_writel(OSSR_M0 | OSSR_M1 | OSSR_M2 | OSSR_M3, OSSR);\n\n\tsched_clock_register(pxa_read_sched_clock, 32, clock_tick_rate);\n\n\tckevt_pxa_osmr0.cpumask = cpumask_of(0);\n\n\tret = request_irq(irq, pxa_ost0_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t  \"ost0\", &ckevt_pxa_osmr0);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup irq\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clocksource_mmio_init(timer_base + OSCR, \"oscr0\", clock_tick_rate, 200,\n\t\t\t\t    32, clocksource_mmio_readl_up);\n\tif (ret) {\n\t\tpr_err(\"Failed to init clocksource\\n\");\n\t\treturn ret;\n\t}\n\n\tclockevents_config_and_register(&ckevt_pxa_osmr0, clock_tick_rate,\n\t\t\t\t\tMIN_OSCR_DELTA * 2, 0x7fffffff);\n\n\treturn 0;\n}\n\nstatic int __init pxa_timer_dt_init(struct device_node *np)\n{\n\tstruct clk *clk;\n\tint irq, ret;\n\n\t \n\ttimer_base = of_iomap(np, 0);\n\tif (!timer_base) {\n\t\tpr_err(\"%pOFn: unable to map resource\\n\", np);\n\t\treturn -ENXIO;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_crit(\"%pOFn: unable to get clk\\n\", np);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_crit(\"Failed to prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0) {\n\t\tpr_crit(\"%pOFn: unable to parse OS-timer0 irq\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\treturn pxa_timer_common_init(irq, clk_get_rate(clk));\n}\nTIMER_OF_DECLARE(pxa_timer, \"marvell,pxa-timer\", pxa_timer_dt_init);\n\n \nvoid __init pxa_timer_nodt_init(int irq, void __iomem *base)\n{\n\tstruct clk *clk;\n\n\ttimer_base = base;\n\tclk = clk_get(NULL, \"OSTIMER0\");\n\tif (clk && !IS_ERR(clk)) {\n\t\tclk_prepare_enable(clk);\n\t\tpxa_timer_common_init(irq, clk_get_rate(clk));\n\t} else {\n\t\tpr_crit(\"%s: unable to get clk\\n\", __func__);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}