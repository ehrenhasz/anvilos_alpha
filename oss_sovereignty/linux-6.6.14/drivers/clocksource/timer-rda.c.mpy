{
  "module_name": "timer-rda.c",
  "hash_id": "be7a13efc9dc55a65d467871dab2ab73350cea88530fa4a9507f9d9be5bf819d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-rda.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n\n#include \"timer-of.h\"\n\n#define RDA_OSTIMER_LOADVAL_L\t0x000\n#define RDA_OSTIMER_CTRL\t0x004\n#define RDA_HWTIMER_LOCKVAL_L\t0x024\n#define RDA_HWTIMER_LOCKVAL_H\t0x028\n#define RDA_TIMER_IRQ_MASK_SET\t0x02c\n#define RDA_TIMER_IRQ_MASK_CLR\t0x030\n#define RDA_TIMER_IRQ_CLR\t0x034\n\n#define RDA_OSTIMER_CTRL_ENABLE\t\tBIT(24)\n#define RDA_OSTIMER_CTRL_REPEAT\t\tBIT(28)\n#define RDA_OSTIMER_CTRL_LOAD\t\tBIT(30)\n\n#define RDA_TIMER_IRQ_MASK_OSTIMER\tBIT(0)\n\n#define RDA_TIMER_IRQ_CLR_OSTIMER\tBIT(0)\n\nstatic int rda_ostimer_start(void __iomem *base, bool periodic, u64 cycles)\n{\n\tu32 ctrl, load_l;\n\n\tload_l = (u32)cycles;\n\tctrl = ((cycles >> 32) & 0xffffff);\n\tctrl |= RDA_OSTIMER_CTRL_LOAD | RDA_OSTIMER_CTRL_ENABLE;\n\tif (periodic)\n\t\tctrl |= RDA_OSTIMER_CTRL_REPEAT;\n\n\t \n\twritel_relaxed(RDA_TIMER_IRQ_MASK_OSTIMER,\n\t\t       base + RDA_TIMER_IRQ_MASK_SET);\n\n\t \n\twritel_relaxed(load_l, base + RDA_OSTIMER_LOADVAL_L);\n\twritel_relaxed(ctrl, base + RDA_OSTIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic int rda_ostimer_stop(void __iomem *base)\n{\n\t \n\twritel_relaxed(RDA_TIMER_IRQ_MASK_OSTIMER,\n\t\t       base + RDA_TIMER_IRQ_MASK_CLR);\n\n\twritel_relaxed(0, base + RDA_OSTIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic int rda_ostimer_set_state_shutdown(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\n\trda_ostimer_stop(timer_of_base(to));\n\n\treturn 0;\n}\n\nstatic int rda_ostimer_set_state_oneshot(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\n\trda_ostimer_stop(timer_of_base(to));\n\n\treturn 0;\n}\n\nstatic int rda_ostimer_set_state_periodic(struct clock_event_device *evt)\n{\n\tstruct timer_of *to = to_timer_of(evt);\n\tunsigned long cycles_per_jiffy;\n\n\trda_ostimer_stop(timer_of_base(to));\n\n\tcycles_per_jiffy = ((unsigned long long)NSEC_PER_SEC / HZ *\n\t\t\t     evt->mult) >> evt->shift;\n\trda_ostimer_start(timer_of_base(to), true, cycles_per_jiffy);\n\n\treturn 0;\n}\n\nstatic int rda_ostimer_tick_resume(struct clock_event_device *evt)\n{\n\treturn 0;\n}\n\nstatic int rda_ostimer_set_next_event(unsigned long evt,\n\t\t\t\t      struct clock_event_device *ev)\n{\n\tstruct timer_of *to = to_timer_of(ev);\n\n\trda_ostimer_start(timer_of_base(to), false, evt);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rda_ostimer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\tstruct timer_of *to = to_timer_of(evt);\n\n\t \n\twritel_relaxed(RDA_TIMER_IRQ_CLR_OSTIMER,\n\t\t       timer_of_base(to) + RDA_TIMER_IRQ_CLR);\n\n\tif (evt->event_handler)\n\t\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct timer_of rda_ostimer_of = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_BASE,\n\n\t.clkevt = {\n\t\t.name = \"rda-ostimer\",\n\t\t.rating = 250,\n\t\t.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t    CLOCK_EVT_FEAT_DYNIRQ,\n\t\t.set_state_shutdown = rda_ostimer_set_state_shutdown,\n\t\t.set_state_oneshot = rda_ostimer_set_state_oneshot,\n\t\t.set_state_periodic = rda_ostimer_set_state_periodic,\n\t\t.tick_resume = rda_ostimer_tick_resume,\n\t\t.set_next_event\t= rda_ostimer_set_next_event,\n\t},\n\n\t.of_base = {\n\t\t.name = \"rda-timer\",\n\t\t.index = 0,\n\t},\n\n\t.of_irq = {\n\t\t.name = \"ostimer\",\n\t\t.handler = rda_ostimer_interrupt,\n\t\t.flags = IRQF_TIMER,\n\t},\n};\n\nstatic u64 rda_hwtimer_read(struct clocksource *cs)\n{\n\tvoid __iomem *base = timer_of_base(&rda_ostimer_of);\n\tu32 lo, hi;\n\n\t \n\tdo {\n\t\tlo = readl_relaxed(base + RDA_HWTIMER_LOCKVAL_L);\n\t\thi = readl_relaxed(base + RDA_HWTIMER_LOCKVAL_H);\n\t} while (hi != readl_relaxed(base + RDA_HWTIMER_LOCKVAL_H));\n\n\treturn ((u64)hi << 32) | lo;\n}\n\nstatic struct clocksource rda_hwtimer_clocksource = {\n\t.name           = \"rda-timer\",\n\t.rating         = 400,\n\t.read           = rda_hwtimer_read,\n\t.mask           = CLOCKSOURCE_MASK(64),\n\t.flags          = CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int __init rda_timer_init(struct device_node *np)\n{\n\tunsigned long rate = 2000000;\n\tint ret;\n\n\tret = timer_of_init(np, &rda_ostimer_of);\n\tif (ret)\n\t\treturn ret;\n\n\tclocksource_register_hz(&rda_hwtimer_clocksource, rate);\n\n\tclockevents_config_and_register(&rda_ostimer_of.clkevt, rate,\n\t\t\t\t\t0x2, UINT_MAX);\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(rda8810pl, \"rda,8810pl-timer\", rda_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}