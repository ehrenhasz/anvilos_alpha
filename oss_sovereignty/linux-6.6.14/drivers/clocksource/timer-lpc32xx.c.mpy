{
  "module_name": "timer-lpc32xx.c",
  "hash_id": "c4676841a85975120380f19f5c2338d9c36873e7d74c288605736b3e5fe0b999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-lpc32xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#define LPC32XX_TIMER_IR\t\t0x000\n#define  LPC32XX_TIMER_IR_MR0INT\tBIT(0)\n#define LPC32XX_TIMER_TCR\t\t0x004\n#define  LPC32XX_TIMER_TCR_CEN\t\tBIT(0)\n#define  LPC32XX_TIMER_TCR_CRST\t\tBIT(1)\n#define LPC32XX_TIMER_TC\t\t0x008\n#define LPC32XX_TIMER_PR\t\t0x00c\n#define LPC32XX_TIMER_MCR\t\t0x014\n#define  LPC32XX_TIMER_MCR_MR0I\t\tBIT(0)\n#define  LPC32XX_TIMER_MCR_MR0R\t\tBIT(1)\n#define  LPC32XX_TIMER_MCR_MR0S\t\tBIT(2)\n#define LPC32XX_TIMER_MR0\t\t0x018\n#define LPC32XX_TIMER_CTCR\t\t0x070\n\nstruct lpc32xx_clock_event_ddata {\n\tstruct clock_event_device evtdev;\n\tvoid __iomem *base;\n\tu32 ticks_per_jiffy;\n};\n\n \nstatic void __iomem *clocksource_timer_counter;\n\nstatic u64 notrace lpc32xx_read_sched_clock(void)\n{\n\treturn readl(clocksource_timer_counter);\n}\n\nstatic unsigned long lpc32xx_delay_timer_read(void)\n{\n\treturn readl(clocksource_timer_counter);\n}\n\nstatic struct delay_timer lpc32xx_delay_timer = {\n\t.read_current_timer = lpc32xx_delay_timer_read,\n};\n\nstatic int lpc32xx_clkevt_next_event(unsigned long delta,\n\t\t\t\t     struct clock_event_device *evtdev)\n{\n\tstruct lpc32xx_clock_event_ddata *ddata =\n\t\tcontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_TCR_CRST, ddata->base + LPC32XX_TIMER_TCR);\n\twritel_relaxed(delta, ddata->base + LPC32XX_TIMER_MR0);\n\twritel_relaxed(LPC32XX_TIMER_TCR_CEN, ddata->base + LPC32XX_TIMER_TCR);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_clkevt_shutdown(struct clock_event_device *evtdev)\n{\n\tstruct lpc32xx_clock_event_ddata *ddata =\n\t\tcontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\n\n\t \n\twritel_relaxed(0, ddata->base + LPC32XX_TIMER_TCR);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_clkevt_oneshot(struct clock_event_device *evtdev)\n{\n\tstruct lpc32xx_clock_event_ddata *ddata =\n\t\tcontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\n\n\t \n\twritel_relaxed(0, ddata->base + LPC32XX_TIMER_TCR);\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_MCR_MR0I | LPC32XX_TIMER_MCR_MR0R |\n\t\t       LPC32XX_TIMER_MCR_MR0S, ddata->base + LPC32XX_TIMER_MCR);\n\treturn 0;\n}\n\nstatic int lpc32xx_clkevt_periodic(struct clock_event_device *evtdev)\n{\n\tstruct lpc32xx_clock_event_ddata *ddata =\n\t\tcontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_MCR_MR0I | LPC32XX_TIMER_MCR_MR0R,\n\t\t       ddata->base + LPC32XX_TIMER_MCR);\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_TCR_CRST, ddata->base + LPC32XX_TIMER_TCR);\n\twritel_relaxed(ddata->ticks_per_jiffy, ddata->base + LPC32XX_TIMER_MR0);\n\twritel_relaxed(LPC32XX_TIMER_TCR_CEN, ddata->base + LPC32XX_TIMER_TCR);\n\n\treturn 0;\n}\n\nstatic irqreturn_t lpc32xx_clock_event_handler(int irq, void *dev_id)\n{\n\tstruct lpc32xx_clock_event_ddata *ddata = dev_id;\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_IR_MR0INT, ddata->base + LPC32XX_TIMER_IR);\n\n\tddata->evtdev.event_handler(&ddata->evtdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct lpc32xx_clock_event_ddata lpc32xx_clk_event_ddata = {\n\t.evtdev = {\n\t\t.name\t\t\t= \"lpc3220 clockevent\",\n\t\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t\t  CLOCK_EVT_FEAT_PERIODIC,\n\t\t.rating\t\t\t= 300,\n\t\t.set_next_event\t\t= lpc32xx_clkevt_next_event,\n\t\t.set_state_shutdown\t= lpc32xx_clkevt_shutdown,\n\t\t.set_state_oneshot\t= lpc32xx_clkevt_oneshot,\n\t\t.set_state_periodic\t= lpc32xx_clkevt_periodic,\n\t},\n};\n\nstatic int __init lpc32xx_clocksource_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = of_clk_get_by_name(np, \"timerclk\");\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"clock get failed (%ld)\\n\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"clock enable failed (%d)\\n\", ret);\n\t\tgoto err_clk_enable;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"unable to map registers\\n\");\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto err_iomap;\n\t}\n\n\t \n\twritel_relaxed(LPC32XX_TIMER_TCR_CRST, base + LPC32XX_TIMER_TCR);\n\twritel_relaxed(0, base + LPC32XX_TIMER_PR);\n\twritel_relaxed(0, base + LPC32XX_TIMER_MCR);\n\twritel_relaxed(0, base + LPC32XX_TIMER_CTCR);\n\twritel_relaxed(LPC32XX_TIMER_TCR_CEN, base + LPC32XX_TIMER_TCR);\n\n\trate = clk_get_rate(clk);\n\tret = clocksource_mmio_init(base + LPC32XX_TIMER_TC, \"lpc3220 timer\",\n\t\t\t\t    rate, 300, 32, clocksource_mmio_readl_up);\n\tif (ret) {\n\t\tpr_err(\"failed to init clocksource (%d)\\n\", ret);\n\t\tgoto err_clocksource_init;\n\t}\n\n\tclocksource_timer_counter = base + LPC32XX_TIMER_TC;\n\tlpc32xx_delay_timer.freq = rate;\n\tregister_current_timer_delay(&lpc32xx_delay_timer);\n\tsched_clock_register(lpc32xx_read_sched_clock, 32, rate);\n\n\treturn 0;\n\nerr_clocksource_init:\n\tiounmap(base);\nerr_iomap:\n\tclk_disable_unprepare(clk);\nerr_clk_enable:\n\tclk_put(clk);\n\treturn ret;\n}\n\nstatic int __init lpc32xx_clockevent_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret, irq;\n\n\tclk = of_clk_get_by_name(np, \"timerclk\");\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"clock get failed (%ld)\\n\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"clock enable failed (%d)\\n\", ret);\n\t\tgoto err_clk_enable;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"unable to map registers\\n\");\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto err_iomap;\n\t}\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tpr_err(\"get irq failed\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_irq;\n\t}\n\n\t \n\twritel_relaxed(0, base + LPC32XX_TIMER_TCR);\n\twritel_relaxed(0, base + LPC32XX_TIMER_PR);\n\twritel_relaxed(0, base + LPC32XX_TIMER_CTCR);\n\twritel_relaxed(LPC32XX_TIMER_IR_MR0INT, base + LPC32XX_TIMER_IR);\n\n\trate = clk_get_rate(clk);\n\tlpc32xx_clk_event_ddata.base = base;\n\tlpc32xx_clk_event_ddata.ticks_per_jiffy = DIV_ROUND_CLOSEST(rate, HZ);\n\tclockevents_config_and_register(&lpc32xx_clk_event_ddata.evtdev,\n\t\t\t\t\trate, 1, -1);\n\n\tret = request_irq(irq, lpc32xx_clock_event_handler,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL, \"lpc3220 clockevent\",\n\t\t\t  &lpc32xx_clk_event_ddata);\n\tif (ret) {\n\t\tpr_err(\"request irq failed\\n\");\n\t\tgoto err_irq;\n\t}\n\n\treturn 0;\n\nerr_irq:\n\tiounmap(base);\nerr_iomap:\n\tclk_disable_unprepare(clk);\nerr_clk_enable:\n\tclk_put(clk);\n\treturn ret;\n}\n\n \nstatic int __init lpc32xx_timer_init(struct device_node *np)\n{\n\tstatic int has_clocksource, has_clockevent;\n\tint ret = 0;\n\n\tif (!has_clocksource) {\n\t\tret = lpc32xx_clocksource_init(np);\n\t\tif (!ret) {\n\t\t\thas_clocksource = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!has_clockevent) {\n\t\tret = lpc32xx_clockevent_init(np);\n\t\tif (!ret) {\n\t\t\thas_clockevent = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\nTIMER_OF_DECLARE(lpc32xx_timer, \"nxp,lpc3220-timer\", lpc32xx_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}