{
  "module_name": "timer-mediatek-cpux.c",
  "hash_id": "c7249eed2ee3c53b5f3c4a5ff640f9088d4d1350239e6304dc8080edc6927fe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-mediatek-cpux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include \"timer-of.h\"\n\n#define TIMER_SYNC_TICKS        3\n\n \n#define CPUX_CON_REG\t\t0x0\n#define CPUX_IDX_REG\t\t0x4\n\n \n#define CPUX_IDX_GLOBAL_CTRL\t0x0\n #define CPUX_ENABLE\t\tBIT(0)\n #define CPUX_CLK_DIV_MASK\tGENMASK(10, 8)\n #define CPUX_CLK_DIV1\t\tBIT(8)\n #define CPUX_CLK_DIV2\t\tBIT(9)\n #define CPUX_CLK_DIV4\t\tBIT(10)\n#define CPUX_IDX_GLOBAL_IRQ\t0x30\n\nstatic u32 mtk_cpux_readl(u32 reg_idx, struct timer_of *to)\n{\n\twritel(reg_idx, timer_of_base(to) + CPUX_IDX_REG);\n\treturn readl(timer_of_base(to) + CPUX_CON_REG);\n}\n\nstatic void mtk_cpux_writel(u32 val, u32 reg_idx, struct timer_of *to)\n{\n\twritel(reg_idx, timer_of_base(to) + CPUX_IDX_REG);\n\twritel(val, timer_of_base(to) + CPUX_CON_REG);\n}\n\nstatic void mtk_cpux_set_irq(struct timer_of *to, bool enable)\n{\n\tconst unsigned long *irq_mask = cpumask_bits(cpu_possible_mask);\n\tu32 val;\n\n\tval = mtk_cpux_readl(CPUX_IDX_GLOBAL_IRQ, to);\n\n\tif (enable)\n\t\tval |= *irq_mask;\n\telse\n\t\tval &= ~(*irq_mask);\n\n\tmtk_cpux_writel(val, CPUX_IDX_GLOBAL_IRQ, to);\n}\n\nstatic int mtk_cpux_clkevt_shutdown(struct clock_event_device *clkevt)\n{\n\t \n\tmtk_cpux_set_irq(to_timer_of(clkevt), false);\n\n\t \n\treturn 0;\n}\n\nstatic int mtk_cpux_clkevt_resume(struct clock_event_device *clkevt)\n{\n\tmtk_cpux_set_irq(to_timer_of(clkevt), true);\n\treturn 0;\n}\n\nstatic struct timer_of to = {\n\t \n\t.flags = TIMER_OF_BASE | TIMER_OF_CLOCK,\n\n\t.clkevt = {\n\t\t.name = \"mtk-cpuxgpt\",\n\t\t.cpumask = cpu_possible_mask,\n\t\t.rating = 10,\n\t\t.set_state_shutdown = mtk_cpux_clkevt_shutdown,\n\t\t.tick_resume = mtk_cpux_clkevt_resume,\n\t},\n};\n\nstatic int __init mtk_cpux_init(struct device_node *node)\n{\n\tu32 freq, val;\n\tint ret;\n\n\t \n\tret = timer_of_init(node, &to);\n\tif (ret) {\n\t\tWARN(1, \"Cannot start CPUX timers.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfreq = timer_of_rate(&to);\n\tif (freq > 13000000)\n\t\tWARN(1, \"Requested unsupported timer frequency %u\\n\", freq);\n\n\t \n\tval = mtk_cpux_readl(CPUX_IDX_GLOBAL_CTRL, &to);\n\tval &= ~CPUX_CLK_DIV_MASK;\n\tval |= CPUX_CLK_DIV2;\n\tmtk_cpux_writel(val, CPUX_IDX_GLOBAL_CTRL, &to);\n\n\t \n\tval = mtk_cpux_readl(CPUX_IDX_GLOBAL_CTRL, &to);\n\tmtk_cpux_writel(val | CPUX_ENABLE, CPUX_IDX_GLOBAL_CTRL, &to);\n\n\tclockevents_config_and_register(&to.clkevt, timer_of_rate(&to),\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(mtk_mt6795, \"mediatek,mt6795-systimer\", mtk_cpux_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}