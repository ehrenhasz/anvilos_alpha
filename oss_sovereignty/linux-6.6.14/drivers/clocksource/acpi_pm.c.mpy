{
  "module_name": "acpi_pm.c",
  "hash_id": "c32fb547e046e5ea58a7696bd69f38f419ad23aed6e43e0e2bdd5150fd7f28cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/acpi_pm.c",
  "human_readable_source": "\n \n\n#include <linux/acpi_pmtmr.h>\n#include <linux/clocksource.h>\n#include <linux/timex.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n#include <asm/time.h>\n\n \nu32 pmtmr_ioport __read_mostly;\n\nstatic inline u32 read_pmtmr(void)\n{\n\t \n\treturn inl(pmtmr_ioport) & ACPI_PM_MASK;\n}\n\nu32 acpi_pm_read_verified(void)\n{\n\tu32 v1 = 0, v2 = 0, v3 = 0;\n\n\t \n\tdo {\n\t\tv1 = read_pmtmr();\n\t\tv2 = read_pmtmr();\n\t\tv3 = read_pmtmr();\n\t} while (unlikely((v1 > v2 && v1 < v3) || (v2 > v3 && v2 < v1)\n\t\t\t  || (v3 > v1 && v3 < v2)));\n\n\treturn v2;\n}\n\nstatic u64 acpi_pm_read(struct clocksource *cs)\n{\n\treturn (u64)read_pmtmr();\n}\n\nstatic struct clocksource clocksource_acpi_pm = {\n\t.name\t\t= \"acpi_pm\",\n\t.rating\t\t= 200,\n\t.read\t\t= acpi_pm_read,\n\t.mask\t\t= (u64)ACPI_PM_MASK,\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\n\n#ifdef CONFIG_PCI\nstatic int acpi_pm_good;\nstatic int __init acpi_pm_good_setup(char *__str)\n{\n\tacpi_pm_good = 1;\n\treturn 1;\n}\n__setup(\"acpi_pm_good\", acpi_pm_good_setup);\n\nstatic u64 acpi_pm_read_slow(struct clocksource *cs)\n{\n\treturn (u64)acpi_pm_read_verified();\n}\n\nstatic inline void acpi_pm_need_workaround(void)\n{\n\tclocksource_acpi_pm.read = acpi_pm_read_slow;\n\tclocksource_acpi_pm.rating = 120;\n}\n\n \nstatic void acpi_pm_check_blacklist(struct pci_dev *dev)\n{\n\tif (acpi_pm_good)\n\t\treturn;\n\n\t \n\tif (dev->revision < 3) {\n\t\tpr_warn(\"* Found PM-Timer Bug on the chipset. Due to workarounds for a bug,\\n\"\n\t\t\t\"* this clock source is slow. Consider trying other clock sources\\n\");\n\n\t\tacpi_pm_need_workaround();\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3,\n\t\t\tacpi_pm_check_blacklist);\n\nstatic void acpi_pm_check_graylist(struct pci_dev *dev)\n{\n\tif (acpi_pm_good)\n\t\treturn;\n\n\tpr_warn(\"* The chipset may have PM-Timer Bug. Due to workarounds for a bug,\\n\"\n\t\t\"* this clock source is slow. If you are sure your timer does not have\\n\"\n\t\t\"* this bug, please use \\\"acpi_pm_good\\\" to disable the workaround\\n\");\n\n\tacpi_pm_need_workaround();\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_0,\n\t\t\tacpi_pm_check_graylist);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_LE,\n\t\t\tacpi_pm_check_graylist);\n#endif\n\n#ifndef CONFIG_X86_64\n#include <asm/mach_timer.h>\n#define PMTMR_EXPECTED_RATE \\\n  ((CALIBRATE_LATCH * (PMTMR_TICKS_PER_SEC >> 10)) / (PIT_TICK_RATE>>10))\n \nstatic int verify_pmtmr_rate(void)\n{\n\tu64 value1, value2;\n\tunsigned long count, delta;\n\n\tmach_prepare_counter();\n\tvalue1 = clocksource_acpi_pm.read(&clocksource_acpi_pm);\n\tmach_countup(&count);\n\tvalue2 = clocksource_acpi_pm.read(&clocksource_acpi_pm);\n\tdelta = (value2 - value1) & ACPI_PM_MASK;\n\n\t \n\tif (delta < (PMTMR_EXPECTED_RATE * 19) / 20 ||\n\t    delta > (PMTMR_EXPECTED_RATE * 21) / 20) {\n\t\tpr_info(\"PM-Timer running at invalid rate: %lu%% of normal - aborting.\\n\",\n\t\t\t100UL * delta / PMTMR_EXPECTED_RATE);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n#else\n#define verify_pmtmr_rate() (0)\n#endif\n\n \n#define ACPI_PM_MONOTONICITY_CHECKS 10\n \n#define ACPI_PM_READ_CHECKS 10000\n\nstatic int __init init_acpi_pm_clocksource(void)\n{\n\tu64 value1, value2;\n\tunsigned int i, j = 0;\n\n\tif (!pmtmr_ioport)\n\t\treturn -ENODEV;\n\n\t \n\tfor (j = 0; j < ACPI_PM_MONOTONICITY_CHECKS; j++) {\n\t\tudelay(100 * j);\n\t\tvalue1 = clocksource_acpi_pm.read(&clocksource_acpi_pm);\n\t\tfor (i = 0; i < ACPI_PM_READ_CHECKS; i++) {\n\t\t\tvalue2 = clocksource_acpi_pm.read(&clocksource_acpi_pm);\n\t\t\tif (value2 == value1)\n\t\t\t\tcontinue;\n\t\t\tif (value2 > value1)\n\t\t\t\tbreak;\n\t\t\tif ((value2 < value1) && ((value2) < 0xFFF))\n\t\t\t\tbreak;\n\t\t\tpr_info(\"PM-Timer had inconsistent results: %#llx, %#llx - aborting.\\n\",\n\t\t\t\tvalue1, value2);\n\t\t\tpmtmr_ioport = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (i == ACPI_PM_READ_CHECKS) {\n\t\t\tpr_info(\"PM-Timer failed consistency check  (%#llx) - aborting.\\n\",\n\t\t\t\tvalue1);\n\t\t\tpmtmr_ioport = 0;\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (verify_pmtmr_rate() != 0){\n\t\tpmtmr_ioport = 0;\n\t\treturn -ENODEV;\n\t}\n\n\tif (tsc_clocksource_watchdog_disabled())\n\t\tclocksource_acpi_pm.flags |= CLOCK_SOURCE_MUST_VERIFY;\n\treturn clocksource_register_hz(&clocksource_acpi_pm, PMTMR_TICKS_PER_SEC);\n}\n\n \nfs_initcall(init_acpi_pm_clocksource);\n\n \nstatic int __init parse_pmtmr(char *arg)\n{\n\tunsigned int base;\n\tint ret;\n\n\tret = kstrtouint(arg, 16, &base);\n\tif (ret) {\n\t\tpr_warn(\"PMTMR: invalid 'pmtmr=' value: '%s'\\n\", arg);\n\t\treturn 1;\n\t}\n\n\tpr_info(\"PMTMR IOPort override: 0x%04x -> 0x%04x\\n\", pmtmr_ioport,\n\t\tbase);\n\tpmtmr_ioport = base;\n\n\treturn 1;\n}\n__setup(\"pmtmr=\", parse_pmtmr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}