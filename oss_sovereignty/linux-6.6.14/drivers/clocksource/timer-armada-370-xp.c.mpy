{
  "module_name": "timer-armada-370-xp.c",
  "hash_id": "d9f0a3ab7246a1518190d6e79ed9d75bc28cbe94418baf137d73b39aad02b04d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-armada-370-xp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/timer.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/sched_clock.h>\n#include <linux/percpu.h>\n#include <linux/syscore_ops.h>\n\n#include <asm/delay.h>\n\n \n#define TIMER_CTRL_OFF\t\t0x0000\n#define  TIMER0_EN\t\t BIT(0)\n#define  TIMER0_RELOAD_EN\t BIT(1)\n#define  TIMER0_25MHZ            BIT(11)\n#define  TIMER0_DIV(div)         ((div) << 19)\n#define  TIMER1_EN\t\t BIT(2)\n#define  TIMER1_RELOAD_EN\t BIT(3)\n#define  TIMER1_25MHZ            BIT(12)\n#define  TIMER1_DIV(div)         ((div) << 22)\n#define TIMER_EVENTS_STATUS\t0x0004\n#define  TIMER0_CLR_MASK         (~0x1)\n#define  TIMER1_CLR_MASK         (~0x100)\n#define TIMER0_RELOAD_OFF\t0x0010\n#define TIMER0_VAL_OFF\t\t0x0014\n#define TIMER1_RELOAD_OFF\t0x0018\n#define TIMER1_VAL_OFF\t\t0x001c\n\n#define LCL_TIMER_EVENTS_STATUS\t0x0028\n \n#define TIMER_DIVIDER_SHIFT     5\n#define TIMER_DIVIDER           (1 << TIMER_DIVIDER_SHIFT)\n\n \nstatic void __iomem *timer_base, *local_base;\nstatic unsigned int timer_clk;\nstatic bool timer25Mhz = true;\nstatic u32 enable_mask;\n\n \nstatic u32 ticks_per_jiffy;\n\nstatic struct clock_event_device __percpu *armada_370_xp_evt;\n\nstatic void local_timer_ctrl_clrset(u32 clr, u32 set)\n{\n\twritel((readl(local_base + TIMER_CTRL_OFF) & ~clr) | set,\n\t\tlocal_base + TIMER_CTRL_OFF);\n}\n\nstatic u64 notrace armada_370_xp_read_sched_clock(void)\n{\n\treturn ~readl(timer_base + TIMER0_VAL_OFF);\n}\n\n \nstatic int\narmada_370_xp_clkevt_next_event(unsigned long delta,\n\t\t\t\tstruct clock_event_device *dev)\n{\n\t \n\twritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\n\n\t \n\twritel(delta, local_base + TIMER0_VAL_OFF);\n\n\t \n\tlocal_timer_ctrl_clrset(TIMER0_RELOAD_EN, enable_mask);\n\treturn 0;\n}\n\nstatic int armada_370_xp_clkevt_shutdown(struct clock_event_device *evt)\n{\n\t \n\tlocal_timer_ctrl_clrset(TIMER0_EN, 0);\n\n\t \n\twritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\n\treturn 0;\n}\n\nstatic int armada_370_xp_clkevt_set_periodic(struct clock_event_device *evt)\n{\n\t \n\twritel(ticks_per_jiffy - 1, local_base + TIMER0_RELOAD_OFF);\n\twritel(ticks_per_jiffy - 1, local_base + TIMER0_VAL_OFF);\n\n\t \n\tlocal_timer_ctrl_clrset(0, TIMER0_RELOAD_EN | enable_mask);\n\treturn 0;\n}\n\nstatic int armada_370_xp_clkevt_irq;\n\nstatic irqreturn_t armada_370_xp_timer_interrupt(int irq, void *dev_id)\n{\n\t \n\tstruct clock_event_device *evt = dev_id;\n\n\twritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int armada_370_xp_timer_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *evt = per_cpu_ptr(armada_370_xp_evt, cpu);\n\tu32 clr = 0, set = 0;\n\n\tif (timer25Mhz)\n\t\tset = TIMER0_25MHZ;\n\telse\n\t\tclr = TIMER0_25MHZ;\n\tlocal_timer_ctrl_clrset(clr, set);\n\n\tevt->name\t\t= \"armada_370_xp_per_cpu_tick\";\n\tevt->features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_PERIODIC;\n\tevt->shift\t\t= 32;\n\tevt->rating\t\t= 300;\n\tevt->set_next_event\t= armada_370_xp_clkevt_next_event;\n\tevt->set_state_shutdown\t= armada_370_xp_clkevt_shutdown;\n\tevt->set_state_periodic\t= armada_370_xp_clkevt_set_periodic;\n\tevt->set_state_oneshot\t= armada_370_xp_clkevt_shutdown;\n\tevt->tick_resume\t= armada_370_xp_clkevt_shutdown;\n\tevt->irq\t\t= armada_370_xp_clkevt_irq;\n\tevt->cpumask\t\t= cpumask_of(cpu);\n\n\tclockevents_config_and_register(evt, timer_clk, 1, 0xfffffffe);\n\tenable_percpu_irq(evt->irq, 0);\n\n\treturn 0;\n}\n\nstatic int armada_370_xp_timer_dying_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *evt = per_cpu_ptr(armada_370_xp_evt, cpu);\n\n\tevt->set_state_shutdown(evt);\n\tdisable_percpu_irq(evt->irq);\n\treturn 0;\n}\n\nstatic u32 timer0_ctrl_reg, timer0_local_ctrl_reg;\n\nstatic int armada_370_xp_timer_suspend(void)\n{\n\ttimer0_ctrl_reg = readl(timer_base + TIMER_CTRL_OFF);\n\ttimer0_local_ctrl_reg = readl(local_base + TIMER_CTRL_OFF);\n\treturn 0;\n}\n\nstatic void armada_370_xp_timer_resume(void)\n{\n\twritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\n\twritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\n\twritel(timer0_ctrl_reg, timer_base + TIMER_CTRL_OFF);\n\twritel(timer0_local_ctrl_reg, local_base + TIMER_CTRL_OFF);\n}\n\nstatic struct syscore_ops armada_370_xp_timer_syscore_ops = {\n\t.suspend\t= armada_370_xp_timer_suspend,\n\t.resume\t\t= armada_370_xp_timer_resume,\n};\n\nstatic unsigned long armada_370_delay_timer_read(void)\n{\n\treturn ~readl(timer_base + TIMER0_VAL_OFF);\n}\n\nstatic struct delay_timer armada_370_delay_timer = {\n\t.read_current_timer = armada_370_delay_timer_read,\n};\n\nstatic int __init armada_370_xp_timer_common_init(struct device_node *np)\n{\n\tu32 clr = 0, set = 0;\n\tint res;\n\n\ttimer_base = of_iomap(np, 0);\n\tif (!timer_base) {\n\t\tpr_err(\"Failed to iomap\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tlocal_base = of_iomap(np, 1);\n\tif (!local_base) {\n\t\tpr_err(\"Failed to iomap\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (timer25Mhz) {\n\t\tset = TIMER0_25MHZ;\t\t\n\t\tenable_mask = TIMER0_EN;\n\t} else {\n\t\tclr = TIMER0_25MHZ;\n\t\tenable_mask = TIMER0_EN | TIMER0_DIV(TIMER_DIVIDER_SHIFT);\n\t}\n\tatomic_io_modify(timer_base + TIMER_CTRL_OFF, clr | set, set);\n\tlocal_timer_ctrl_clrset(clr, set);\n\n\t \n\tarmada_370_xp_clkevt_irq = irq_of_parse_and_map(np, 4);\n\n\tticks_per_jiffy = (timer_clk + HZ / 2) / HZ;\n\n\t \n\twritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\n\twritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\n\n\tatomic_io_modify(timer_base + TIMER_CTRL_OFF,\n\t\tTIMER0_RELOAD_EN | enable_mask,\n\t\tTIMER0_RELOAD_EN | enable_mask);\n\n\tarmada_370_delay_timer.freq = timer_clk;\n\tregister_current_timer_delay(&armada_370_delay_timer);\n\n\t \n\tsched_clock_register(armada_370_xp_read_sched_clock, 32, timer_clk);\n\n\tres = clocksource_mmio_init(timer_base + TIMER0_VAL_OFF,\n\t\t\t\t    \"armada_370_xp_clocksource\",\n\t\t\t\t    timer_clk, 300, 32, clocksource_mmio_readl_down);\n\tif (res) {\n\t\tpr_err(\"Failed to initialize clocksource mmio\\n\");\n\t\treturn res;\n\t}\n\n\tarmada_370_xp_evt = alloc_percpu(struct clock_event_device);\n\tif (!armada_370_xp_evt)\n\t\treturn -ENOMEM;\n\n\t \n\tres = request_percpu_irq(armada_370_xp_clkevt_irq,\n\t\t\t\tarmada_370_xp_timer_interrupt,\n\t\t\t\t\"armada_370_xp_per_cpu_tick\",\n\t\t\t\tarmada_370_xp_evt);\n\t \n\tif (res) {\n\t\tpr_err(\"Failed to request percpu irq\\n\");\n\t\treturn res;\n\t}\n\n\tres = cpuhp_setup_state(CPUHP_AP_ARMADA_TIMER_STARTING,\n\t\t\t\t\"clockevents/armada:starting\",\n\t\t\t\tarmada_370_xp_timer_starting_cpu,\n\t\t\t\tarmada_370_xp_timer_dying_cpu);\n\tif (res) {\n\t\tpr_err(\"Failed to setup hotplug state and timer\\n\");\n\t\treturn res;\n\t}\n\n\tregister_syscore_ops(&armada_370_xp_timer_syscore_ops);\n\t\n\treturn 0;\n}\n\nstatic int __init armada_xp_timer_init(struct device_node *np)\n{\n\tstruct clk *clk = of_clk_get_by_name(np, \"fixed\");\n\tint ret;\n\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\ttimer_clk = clk_get_rate(clk);\n\n\treturn armada_370_xp_timer_common_init(np);\n}\nTIMER_OF_DECLARE(armada_xp, \"marvell,armada-xp-timer\",\n\t\t       armada_xp_timer_init);\n\nstatic int __init armada_375_timer_init(struct device_node *np)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = of_clk_get_by_name(np, \"fixed\");\n\tif (!IS_ERR(clk)) {\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttimer_clk = clk_get_rate(clk);\n\t} else {\n\n\t\t \n\t\tclk = of_clk_get(np, 0);\n\n\t\t \n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"Failed to get clock\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttimer_clk = clk_get_rate(clk) / TIMER_DIVIDER;\n\t\ttimer25Mhz = false;\n\t}\n\n\treturn armada_370_xp_timer_common_init(np);\n}\nTIMER_OF_DECLARE(armada_375, \"marvell,armada-375-timer\",\n\t\t       armada_375_timer_init);\n\nstatic int __init armada_370_timer_init(struct device_node *np)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"Failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\ttimer_clk = clk_get_rate(clk) / TIMER_DIVIDER;\n\ttimer25Mhz = false;\n\n\treturn armada_370_xp_timer_common_init(np);\n}\nTIMER_OF_DECLARE(armada_370, \"marvell,armada-370-timer\",\n\t\t       armada_370_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}