{
  "module_name": "ingenic-ost.c",
  "hash_id": "8975e983bca94b33be147f2e4a47b8f920b26e79119694e6eb2d676b254d2476",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/ingenic-ost.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/sched_clock.h>\n\n#define TCU_OST_TCSR_MASK\t0xffc0\n#define TCU_OST_TCSR_CNT_MD\tBIT(15)\n\n#define TCU_OST_CHANNEL\t\t15\n\n \n#define OST_REG_CNTL\t\t0x4\n#define OST_REG_CNTH\t\t0x8\n\nstruct ingenic_ost_soc_info {\n\tbool is64bit;\n};\n\nstruct ingenic_ost {\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\n\tstruct clocksource cs;\n};\n\nstatic struct ingenic_ost *ingenic_ost;\n\nstatic u64 notrace ingenic_ost_read_cntl(void)\n{\n\t \n\treturn readl(ingenic_ost->regs + OST_REG_CNTL);\n}\n\nstatic u64 notrace ingenic_ost_read_cnth(void)\n{\n\t \n\treturn readl(ingenic_ost->regs + OST_REG_CNTH);\n}\n\nstatic u64 notrace ingenic_ost_clocksource_readl(struct clocksource *cs)\n{\n\treturn ingenic_ost_read_cntl();\n}\n\nstatic u64 notrace ingenic_ost_clocksource_readh(struct clocksource *cs)\n{\n\treturn ingenic_ost_read_cnth();\n}\n\nstatic int __init ingenic_ost_probe(struct platform_device *pdev)\n{\n\tconst struct ingenic_ost_soc_info *soc_info;\n\tstruct device *dev = &pdev->dev;\n\tstruct ingenic_ost *ost;\n\tstruct clocksource *cs;\n\tstruct regmap *map;\n\tunsigned long rate;\n\tint err;\n\n\tsoc_info = device_get_match_data(dev);\n\tif (!soc_info)\n\t\treturn -EINVAL;\n\n\tost = devm_kzalloc(dev, sizeof(*ost), GFP_KERNEL);\n\tif (!ost)\n\t\treturn -ENOMEM;\n\n\tingenic_ost = ost;\n\n\tost->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ost->regs))\n\t\treturn PTR_ERR(ost->regs);\n\n\tmap = device_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"regmap not found\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tost->clk = devm_clk_get(dev, \"ost\");\n\tif (IS_ERR(ost->clk))\n\t\treturn PTR_ERR(ost->clk);\n\n\terr = clk_prepare_enable(ost->clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (soc_info->is64bit)\n\t\tregmap_write(map, TCU_REG_OST_CNTL, 0);\n\tregmap_write(map, TCU_REG_OST_CNTH, 0);\n\n\t \n\tregmap_update_bits(map, TCU_REG_OST_TCSR,\n\t\t\t   TCU_OST_TCSR_MASK, TCU_OST_TCSR_CNT_MD);\n\n\trate = clk_get_rate(ost->clk);\n\n\t \n\tregmap_write(map, TCU_REG_TESR, BIT(TCU_OST_CHANNEL));\n\n\tcs = &ost->cs;\n\tcs->name\t= \"ingenic-ost\";\n\tcs->rating\t= 320;\n\tcs->flags\t= CLOCK_SOURCE_IS_CONTINUOUS;\n\tcs->mask\t= CLOCKSOURCE_MASK(32);\n\n\tif (soc_info->is64bit)\n\t\tcs->read = ingenic_ost_clocksource_readl;\n\telse\n\t\tcs->read = ingenic_ost_clocksource_readh;\n\n\terr = clocksource_register_hz(cs, rate);\n\tif (err) {\n\t\tdev_err(dev, \"clocksource registration failed\");\n\t\tclk_disable_unprepare(ost->clk);\n\t\treturn err;\n\t}\n\n\tif (soc_info->is64bit)\n\t\tsched_clock_register(ingenic_ost_read_cntl, 32, rate);\n\telse\n\t\tsched_clock_register(ingenic_ost_read_cnth, 32, rate);\n\n\treturn 0;\n}\n\nstatic int ingenic_ost_suspend(struct device *dev)\n{\n\tstruct ingenic_ost *ost = dev_get_drvdata(dev);\n\n\tclk_disable(ost->clk);\n\n\treturn 0;\n}\n\nstatic int ingenic_ost_resume(struct device *dev)\n{\n\tstruct ingenic_ost *ost = dev_get_drvdata(dev);\n\n\treturn clk_enable(ost->clk);\n}\n\nstatic const struct dev_pm_ops ingenic_ost_pm_ops = {\n\t \n\t.suspend_noirq = ingenic_ost_suspend,\n\t.resume_noirq  = ingenic_ost_resume,\n};\n\nstatic const struct ingenic_ost_soc_info jz4725b_ost_soc_info = {\n\t.is64bit = false,\n};\n\nstatic const struct ingenic_ost_soc_info jz4760b_ost_soc_info = {\n\t.is64bit = true,\n};\n\nstatic const struct of_device_id ingenic_ost_of_match[] = {\n\t{ .compatible = \"ingenic,jz4725b-ost\", .data = &jz4725b_ost_soc_info, },\n\t{ .compatible = \"ingenic,jz4760b-ost\", .data = &jz4760b_ost_soc_info, },\n\t{ .compatible = \"ingenic,jz4770-ost\", .data = &jz4760b_ost_soc_info, },\n\t{ }\n};\n\nstatic struct platform_driver ingenic_ost_driver = {\n\t.driver = {\n\t\t.name = \"ingenic-ost\",\n\t\t.pm = pm_sleep_ptr(&ingenic_ost_pm_ops),\n\t\t.of_match_table = ingenic_ost_of_match,\n\t},\n};\nbuiltin_platform_driver_probe(ingenic_ost_driver, ingenic_ost_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}