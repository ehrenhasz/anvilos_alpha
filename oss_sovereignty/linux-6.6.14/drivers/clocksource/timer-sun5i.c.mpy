{
  "module_name": "timer-sun5i.c",
  "hash_id": "36f76777c546c37d53ad27378e3007a3306e12070c36080c6e8cd989434b771a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-sun5i.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqreturn.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n\n#define TIMER_IRQ_EN_REG\t\t0x00\n#define TIMER_IRQ_EN(val)\t\t\tBIT(val)\n#define TIMER_IRQ_ST_REG\t\t0x04\n#define TIMER_CTL_REG(val)\t\t(0x20 * (val) + 0x10)\n#define TIMER_CTL_ENABLE\t\t\tBIT(0)\n#define TIMER_CTL_RELOAD\t\t\tBIT(1)\n#define TIMER_CTL_CLK_PRES(val)\t\t\t(((val) & 0x7) << 4)\n#define TIMER_CTL_ONESHOT\t\t\tBIT(7)\n#define TIMER_INTVAL_LO_REG(val)\t(0x20 * (val) + 0x14)\n#define TIMER_INTVAL_HI_REG(val)\t(0x20 * (val) + 0x18)\n#define TIMER_CNTVAL_LO_REG(val)\t(0x20 * (val) + 0x1c)\n#define TIMER_CNTVAL_HI_REG(val)\t(0x20 * (val) + 0x20)\n\n#define TIMER_SYNC_TICKS\t3\n\nstruct sun5i_timer {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct notifier_block\tclk_rate_cb;\n\tu32\t\t\tticks_per_jiffy;\n\tstruct clocksource\tclksrc;\n\tstruct clock_event_device\tclkevt;\n};\n\n#define nb_to_sun5i_timer(x) \\\n\tcontainer_of(x, struct sun5i_timer, clk_rate_cb)\n#define clksrc_to_sun5i_timer(x) \\\n\tcontainer_of(x, struct sun5i_timer, clksrc)\n#define clkevt_to_sun5i_timer(x) \\\n\tcontainer_of(x, struct sun5i_timer, clkevt)\n\n \nstatic void sun5i_clkevt_sync(struct sun5i_timer *ce)\n{\n\tu32 old = readl(ce->base + TIMER_CNTVAL_LO_REG(1));\n\n\twhile ((old - readl(ce->base + TIMER_CNTVAL_LO_REG(1))) < TIMER_SYNC_TICKS)\n\t\tcpu_relax();\n}\n\nstatic void sun5i_clkevt_time_stop(struct sun5i_timer *ce, u8 timer)\n{\n\tu32 val = readl(ce->base + TIMER_CTL_REG(timer));\n\twritel(val & ~TIMER_CTL_ENABLE, ce->base + TIMER_CTL_REG(timer));\n\n\tsun5i_clkevt_sync(ce);\n}\n\nstatic void sun5i_clkevt_time_setup(struct sun5i_timer *ce, u8 timer, u32 delay)\n{\n\twritel(delay, ce->base + TIMER_INTVAL_LO_REG(timer));\n}\n\nstatic void sun5i_clkevt_time_start(struct sun5i_timer *ce, u8 timer, bool periodic)\n{\n\tu32 val = readl(ce->base + TIMER_CTL_REG(timer));\n\n\tif (periodic)\n\t\tval &= ~TIMER_CTL_ONESHOT;\n\telse\n\t\tval |= TIMER_CTL_ONESHOT;\n\n\twritel(val | TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\n\t       ce->base + TIMER_CTL_REG(timer));\n}\n\nstatic int sun5i_clkevt_shutdown(struct clock_event_device *clkevt)\n{\n\tstruct sun5i_timer *ce = clkevt_to_sun5i_timer(clkevt);\n\n\tsun5i_clkevt_time_stop(ce, 0);\n\treturn 0;\n}\n\nstatic int sun5i_clkevt_set_oneshot(struct clock_event_device *clkevt)\n{\n\tstruct sun5i_timer *ce = clkevt_to_sun5i_timer(clkevt);\n\n\tsun5i_clkevt_time_stop(ce, 0);\n\tsun5i_clkevt_time_start(ce, 0, false);\n\treturn 0;\n}\n\nstatic int sun5i_clkevt_set_periodic(struct clock_event_device *clkevt)\n{\n\tstruct sun5i_timer *ce = clkevt_to_sun5i_timer(clkevt);\n\n\tsun5i_clkevt_time_stop(ce, 0);\n\tsun5i_clkevt_time_setup(ce, 0, ce->ticks_per_jiffy);\n\tsun5i_clkevt_time_start(ce, 0, true);\n\treturn 0;\n}\n\nstatic int sun5i_clkevt_next_event(unsigned long evt,\n\t\t\t\t   struct clock_event_device *clkevt)\n{\n\tstruct sun5i_timer *ce = clkevt_to_sun5i_timer(clkevt);\n\n\tsun5i_clkevt_time_stop(ce, 0);\n\tsun5i_clkevt_time_setup(ce, 0, evt - TIMER_SYNC_TICKS);\n\tsun5i_clkevt_time_start(ce, 0, false);\n\n\treturn 0;\n}\n\nstatic irqreturn_t sun5i_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct sun5i_timer *ce = dev_id;\n\n\twritel(0x1, ce->base + TIMER_IRQ_ST_REG);\n\tce->clkevt.event_handler(&ce->clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 sun5i_clksrc_read(struct clocksource *clksrc)\n{\n\tstruct sun5i_timer *cs = clksrc_to_sun5i_timer(clksrc);\n\n\treturn ~readl(cs->base + TIMER_CNTVAL_LO_REG(1));\n}\n\nstatic int sun5i_rate_cb(struct notifier_block *nb,\n\t\t\t unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct sun5i_timer *cs = nb_to_sun5i_timer(nb);\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\tclocksource_unregister(&cs->clksrc);\n\t\tbreak;\n\n\tcase POST_RATE_CHANGE:\n\t\tclocksource_register_hz(&cs->clksrc, ndata->new_rate);\n\t\tclockevents_update_freq(&cs->clkevt, ndata->new_rate);\n\t\tcs->ticks_per_jiffy = DIV_ROUND_UP(ndata->new_rate, HZ);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int sun5i_setup_clocksource(struct platform_device *pdev,\n\t\t\t\t   unsigned long rate)\n{\n\tstruct sun5i_timer *cs = platform_get_drvdata(pdev);\n\tvoid __iomem *base = cs->base;\n\tint ret;\n\n\twritel(~0, base + TIMER_INTVAL_LO_REG(1));\n\twritel(TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\n\t       base + TIMER_CTL_REG(1));\n\n\tcs->clksrc.name = pdev->dev.of_node->name;\n\tcs->clksrc.rating = 340;\n\tcs->clksrc.read = sun5i_clksrc_read;\n\tcs->clksrc.mask = CLOCKSOURCE_MASK(32);\n\tcs->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\tret = clocksource_register_hz(&cs->clksrc, rate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't register clock source.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun5i_setup_clockevent(struct platform_device *pdev,\n\t\t\t\t  unsigned long rate, int irq)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sun5i_timer *ce = platform_get_drvdata(pdev);\n\tvoid __iomem *base = ce->base;\n\tint ret;\n\tu32 val;\n\n\tce->clkevt.name = dev->of_node->name;\n\tce->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tce->clkevt.set_next_event = sun5i_clkevt_next_event;\n\tce->clkevt.set_state_shutdown = sun5i_clkevt_shutdown;\n\tce->clkevt.set_state_periodic = sun5i_clkevt_set_periodic;\n\tce->clkevt.set_state_oneshot = sun5i_clkevt_set_oneshot;\n\tce->clkevt.tick_resume = sun5i_clkevt_shutdown;\n\tce->clkevt.rating = 340;\n\tce->clkevt.irq = irq;\n\tce->clkevt.cpumask = cpu_possible_mask;\n\n\t \n\tval = readl(base + TIMER_IRQ_EN_REG);\n\twritel(val | TIMER_IRQ_EN(0), base + TIMER_IRQ_EN_REG);\n\n\tclockevents_config_and_register(&ce->clkevt, rate,\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\n\tret = devm_request_irq(dev, irq, sun5i_timer_interrupt,\n\t\t\t       IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t       \"sun5i_timer0\", ce);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun5i_timer_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sun5i_timer *st;\n\tstruct reset_control *rstc;\n\tvoid __iomem *timer_base;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tint irq, ret;\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, st);\n\n\ttimer_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(timer_base)) {\n\t\tdev_err(dev, \"Can't map registers\\n\");\n\t\treturn PTR_ERR(timer_base);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"Can't get IRQ\\n\");\n\t\treturn irq;\n\t}\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"Can't get timer clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\trate = clk_get_rate(clk);\n\tif (!rate) {\n\t\tdev_err(dev, \"Couldn't get parent clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tst->base = timer_base;\n\tst->ticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\n\tst->clk = clk;\n\tst->clk_rate_cb.notifier_call = sun5i_rate_cb;\n\tst->clk_rate_cb.next = NULL;\n\n\tret = devm_clk_notifier_register(dev, clk, &st->clk_rate_cb);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register clock notifier.\\n\");\n\t\treturn ret;\n\t}\n\n\trstc = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (rstc)\n\t\treset_control_deassert(rstc);\n\n\tret = sun5i_setup_clocksource(pdev, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun5i_setup_clockevent(pdev, rate, irq);\n\tif (ret)\n\t\tgoto err_unreg_clocksource;\n\n\treturn 0;\n\nerr_unreg_clocksource:\n\tclocksource_unregister(&st->clksrc);\n\treturn ret;\n}\n\nstatic void sun5i_timer_remove(struct platform_device *pdev)\n{\n\tstruct sun5i_timer *st = platform_get_drvdata(pdev);\n\n\tclocksource_unregister(&st->clksrc);\n}\n\nstatic const struct of_device_id sun5i_timer_of_match[] = {\n\t{ .compatible = \"allwinner,sun5i-a13-hstimer\" },\n\t{ .compatible = \"allwinner,sun7i-a20-hstimer\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sun5i_timer_of_match);\n\nstatic struct platform_driver sun5i_timer_driver = {\n\t.probe\t\t= sun5i_timer_probe,\n\t.remove_new\t= sun5i_timer_remove,\n\t.driver\t= {\n\t\t.name\t= \"sun5i-timer\",\n\t\t.of_match_table = sun5i_timer_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(sun5i_timer_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}