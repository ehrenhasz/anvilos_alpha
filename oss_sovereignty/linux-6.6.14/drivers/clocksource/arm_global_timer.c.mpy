{
  "module_name": "arm_global_timer.c",
  "hash_id": "7631547397ef68a0a83e5bf56913fc80ecf270178de7ef4d18a55085169c8c8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/arm_global_timer.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/sched_clock.h>\n\n#include <asm/cputype.h>\n\n#define GT_COUNTER0\t0x00\n#define GT_COUNTER1\t0x04\n\n#define GT_CONTROL\t0x08\n#define GT_CONTROL_TIMER_ENABLE\t\tBIT(0)   \n#define GT_CONTROL_COMP_ENABLE\t\tBIT(1)\t \n#define GT_CONTROL_IRQ_ENABLE\t\tBIT(2)\t \n#define GT_CONTROL_AUTO_INC\t\tBIT(3)\t \n#define GT_CONTROL_PRESCALER_SHIFT      8\n#define GT_CONTROL_PRESCALER_MAX        0xF\n#define GT_CONTROL_PRESCALER_MASK       (GT_CONTROL_PRESCALER_MAX << \\\n\t\t\t\t\t GT_CONTROL_PRESCALER_SHIFT)\n\n#define GT_INT_STATUS\t0x0c\n#define GT_INT_STATUS_EVENT_FLAG\tBIT(0)\n\n#define GT_COMP0\t0x10\n#define GT_COMP1\t0x14\n#define GT_AUTO_INC\t0x18\n\n#define MAX_F_ERR 50\n \nstatic void __iomem *gt_base;\nstatic struct notifier_block gt_clk_rate_change_nb;\nstatic u32 gt_psv_new, gt_psv_bck, gt_target_rate;\nstatic int gt_ppi;\nstatic struct clock_event_device __percpu *gt_evt;\n\n \nstatic u64 notrace _gt_counter_read(void)\n{\n\tu64 counter;\n\tu32 lower;\n\tu32 upper, old_upper;\n\n\tupper = readl_relaxed(gt_base + GT_COUNTER1);\n\tdo {\n\t\told_upper = upper;\n\t\tlower = readl_relaxed(gt_base + GT_COUNTER0);\n\t\tupper = readl_relaxed(gt_base + GT_COUNTER1);\n\t} while (upper != old_upper);\n\n\tcounter = upper;\n\tcounter <<= 32;\n\tcounter |= lower;\n\treturn counter;\n}\n\nstatic u64 gt_counter_read(void)\n{\n\treturn _gt_counter_read();\n}\n\n \nstatic void gt_compare_set(unsigned long delta, int periodic)\n{\n\tu64 counter = gt_counter_read();\n\tunsigned long ctrl;\n\n\tcounter += delta;\n\tctrl = readl(gt_base + GT_CONTROL);\n\tctrl &= ~(GT_CONTROL_COMP_ENABLE | GT_CONTROL_IRQ_ENABLE |\n\t\t  GT_CONTROL_AUTO_INC);\n\tctrl |= GT_CONTROL_TIMER_ENABLE;\n\twritel_relaxed(ctrl, gt_base + GT_CONTROL);\n\twritel_relaxed(lower_32_bits(counter), gt_base + GT_COMP0);\n\twritel_relaxed(upper_32_bits(counter), gt_base + GT_COMP1);\n\n\tif (periodic) {\n\t\twritel_relaxed(delta, gt_base + GT_AUTO_INC);\n\t\tctrl |= GT_CONTROL_AUTO_INC;\n\t}\n\n\tctrl |= GT_CONTROL_COMP_ENABLE | GT_CONTROL_IRQ_ENABLE;\n\twritel_relaxed(ctrl, gt_base + GT_CONTROL);\n}\n\nstatic int gt_clockevent_shutdown(struct clock_event_device *evt)\n{\n\tunsigned long ctrl;\n\n\tctrl = readl(gt_base + GT_CONTROL);\n\tctrl &= ~(GT_CONTROL_COMP_ENABLE | GT_CONTROL_IRQ_ENABLE |\n\t\t  GT_CONTROL_AUTO_INC);\n\twritel(ctrl, gt_base + GT_CONTROL);\n\treturn 0;\n}\n\nstatic int gt_clockevent_set_periodic(struct clock_event_device *evt)\n{\n\tgt_compare_set(DIV_ROUND_CLOSEST(gt_target_rate, HZ), 1);\n\treturn 0;\n}\n\nstatic int gt_clockevent_set_next_event(unsigned long evt,\n\t\t\t\t\tstruct clock_event_device *unused)\n{\n\tgt_compare_set(evt, 0);\n\treturn 0;\n}\n\nstatic irqreturn_t gt_clockevent_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tif (!(readl_relaxed(gt_base + GT_INT_STATUS) &\n\t\t\t\tGT_INT_STATUS_EVENT_FLAG))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (clockevent_state_oneshot(evt))\n\t\tgt_compare_set(ULONG_MAX, 0);\n\n\twritel_relaxed(GT_INT_STATUS_EVENT_FLAG, gt_base + GT_INT_STATUS);\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gt_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *clk = this_cpu_ptr(gt_evt);\n\n\tclk->name = \"arm_global_timer\";\n\tclk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\n\t\tCLOCK_EVT_FEAT_PERCPU;\n\tclk->set_state_shutdown = gt_clockevent_shutdown;\n\tclk->set_state_periodic = gt_clockevent_set_periodic;\n\tclk->set_state_oneshot = gt_clockevent_shutdown;\n\tclk->set_state_oneshot_stopped = gt_clockevent_shutdown;\n\tclk->set_next_event = gt_clockevent_set_next_event;\n\tclk->cpumask = cpumask_of(cpu);\n\tclk->rating = 300;\n\tclk->irq = gt_ppi;\n\tclockevents_config_and_register(clk, gt_target_rate,\n\t\t\t\t\t1, 0xffffffff);\n\tenable_percpu_irq(clk->irq, IRQ_TYPE_NONE);\n\treturn 0;\n}\n\nstatic int gt_dying_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *clk = this_cpu_ptr(gt_evt);\n\n\tgt_clockevent_shutdown(clk);\n\tdisable_percpu_irq(clk->irq);\n\treturn 0;\n}\n\nstatic u64 gt_clocksource_read(struct clocksource *cs)\n{\n\treturn gt_counter_read();\n}\n\nstatic void gt_resume(struct clocksource *cs)\n{\n\tunsigned long ctrl;\n\n\tctrl = readl(gt_base + GT_CONTROL);\n\tif (!(ctrl & GT_CONTROL_TIMER_ENABLE))\n\t\t \n\t\twritel(GT_CONTROL_TIMER_ENABLE, gt_base + GT_CONTROL);\n}\n\nstatic struct clocksource gt_clocksource = {\n\t.name\t= \"arm_global_timer\",\n\t.rating\t= 300,\n\t.read\t= gt_clocksource_read,\n\t.mask\t= CLOCKSOURCE_MASK(64),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.resume = gt_resume,\n};\n\n#ifdef CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK\nstatic u64 notrace gt_sched_clock_read(void)\n{\n\treturn _gt_counter_read();\n}\n#endif\n\nstatic unsigned long gt_read_long(void)\n{\n\treturn readl_relaxed(gt_base + GT_COUNTER0);\n}\n\nstatic struct delay_timer gt_delay_timer = {\n\t.read_current_timer = gt_read_long,\n};\n\nstatic void gt_write_presc(u32 psv)\n{\n\tu32 reg;\n\n\treg = readl(gt_base + GT_CONTROL);\n\treg &= ~GT_CONTROL_PRESCALER_MASK;\n\treg |= psv << GT_CONTROL_PRESCALER_SHIFT;\n\twritel(reg, gt_base + GT_CONTROL);\n}\n\nstatic u32 gt_read_presc(void)\n{\n\tu32 reg;\n\n\treg = readl(gt_base + GT_CONTROL);\n\treg &= GT_CONTROL_PRESCALER_MASK;\n\treturn reg >> GT_CONTROL_PRESCALER_SHIFT;\n}\n\nstatic void __init gt_delay_timer_init(void)\n{\n\tgt_delay_timer.freq = gt_target_rate;\n\tregister_current_timer_delay(&gt_delay_timer);\n}\n\nstatic int __init gt_clocksource_init(void)\n{\n\twritel(0, gt_base + GT_CONTROL);\n\twritel(0, gt_base + GT_COUNTER0);\n\twritel(0, gt_base + GT_COUNTER1);\n\t \n\twritel(((CONFIG_ARM_GT_INITIAL_PRESCALER_VAL - 1) <<\n\t\tGT_CONTROL_PRESCALER_SHIFT)\n\t       | GT_CONTROL_TIMER_ENABLE, gt_base + GT_CONTROL);\n\n#ifdef CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK\n\tsched_clock_register(gt_sched_clock_read, 64, gt_target_rate);\n#endif\n\treturn clocksource_register_hz(&gt_clocksource, gt_target_rate);\n}\n\nstatic int gt_clk_rate_change_cb(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t{\n\t\tint psv;\n\n\t\tpsv = DIV_ROUND_CLOSEST(ndata->new_rate,\n\t\t\t\t\tgt_target_rate);\n\n\t\tif (abs(gt_target_rate - (ndata->new_rate / psv)) > MAX_F_ERR)\n\t\t\treturn NOTIFY_BAD;\n\n\t\tpsv--;\n\n\t\t \n\t\tif (psv < 0 || psv > GT_CONTROL_PRESCALER_MAX)\n\t\t\treturn NOTIFY_BAD;\n\n\t\t \n\t\tgt_psv_bck = gt_read_presc();\n\t\tgt_psv_new = psv;\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\treturn NOTIFY_DONE;\n\n\t\t \n\t\tgt_write_presc(psv);\n\t\tbreak;\n\t}\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\tgt_write_presc(gt_psv_new);\n\t\tbreak;\n\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\tgt_write_presc(gt_psv_bck);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init global_timer_of_register(struct device_node *np)\n{\n\tstruct clk *gt_clk;\n\tstatic unsigned long gt_clk_rate;\n\tint err = 0;\n\n\t \n\tif (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9\n\t    && (read_cpuid_id() & 0xf0000f) < 0x200000) {\n\t\tpr_warn(\"global-timer: non support for this cpu version.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tgt_ppi = irq_of_parse_and_map(np, 0);\n\tif (!gt_ppi) {\n\t\tpr_warn(\"global-timer: unable to parse irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgt_base = of_iomap(np, 0);\n\tif (!gt_base) {\n\t\tpr_warn(\"global-timer: invalid base address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tgt_clk = of_clk_get(np, 0);\n\tif (!IS_ERR(gt_clk)) {\n\t\terr = clk_prepare_enable(gt_clk);\n\t\tif (err)\n\t\t\tgoto out_unmap;\n\t} else {\n\t\tpr_warn(\"global-timer: clk not found\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\tgt_clk_rate = clk_get_rate(gt_clk);\n\tgt_target_rate = gt_clk_rate / CONFIG_ARM_GT_INITIAL_PRESCALER_VAL;\n\tgt_clk_rate_change_nb.notifier_call =\n\t\tgt_clk_rate_change_cb;\n\terr = clk_notifier_register(gt_clk, &gt_clk_rate_change_nb);\n\tif (err) {\n\t\tpr_warn(\"Unable to register clock notifier\\n\");\n\t\tgoto out_clk;\n\t}\n\n\tgt_evt = alloc_percpu(struct clock_event_device);\n\tif (!gt_evt) {\n\t\tpr_warn(\"global-timer: can't allocate memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_clk_nb;\n\t}\n\n\terr = request_percpu_irq(gt_ppi, gt_clockevent_interrupt,\n\t\t\t\t \"gt\", gt_evt);\n\tif (err) {\n\t\tpr_warn(\"global-timer: can't register interrupt %d (%d)\\n\",\n\t\t\tgt_ppi, err);\n\t\tgoto out_free;\n\t}\n\n\t \n\terr = gt_clocksource_init();\n\tif (err)\n\t\tgoto out_irq;\n\t\n\terr = cpuhp_setup_state(CPUHP_AP_ARM_GLOBAL_TIMER_STARTING,\n\t\t\t\t\"clockevents/arm/global_timer:starting\",\n\t\t\t\tgt_starting_cpu, gt_dying_cpu);\n\tif (err)\n\t\tgoto out_irq;\n\n\tgt_delay_timer_init();\n\n\treturn 0;\n\nout_irq:\n\tfree_percpu_irq(gt_ppi, gt_evt);\nout_free:\n\tfree_percpu(gt_evt);\nout_clk_nb:\n\tclk_notifier_unregister(gt_clk, &gt_clk_rate_change_nb);\nout_clk:\n\tclk_disable_unprepare(gt_clk);\nout_unmap:\n\tiounmap(gt_base);\n\tWARN(err, \"ARM Global timer register failed (%d)\\n\", err);\n\n\treturn err;\n}\n\n \nTIMER_OF_DECLARE(arm_gt, \"arm,cortex-a9-global-timer\",\n\t\t\tglobal_timer_of_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}