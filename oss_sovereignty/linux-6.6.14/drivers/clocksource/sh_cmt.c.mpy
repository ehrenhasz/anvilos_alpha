{
  "module_name": "sh_cmt.c",
  "hash_id": "9c6e37719caa42229a244ce5dac839b44d48da8fecee02006b5460a1b7016cbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/sh_cmt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/sh_timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#ifdef CONFIG_SUPERH\n#include <asm/platform_early.h>\n#endif\n\nstruct sh_cmt_device;\n\n \n\nenum sh_cmt_model {\n\tSH_CMT_16BIT,\n\tSH_CMT_32BIT,\n\tSH_CMT_48BIT,\n\tSH_CMT0_RCAR_GEN2,\n\tSH_CMT1_RCAR_GEN2,\n};\n\nstruct sh_cmt_info {\n\tenum sh_cmt_model model;\n\n\tunsigned int channels_mask;\n\n\tunsigned long width;  \n\tu32 overflow_bit;\n\tu32 clear_bits;\n\n\t \n\tu32 (*read_control)(void __iomem *base, unsigned long offs);\n\tvoid (*write_control)(void __iomem *base, unsigned long offs,\n\t\t\t      u32 value);\n\n\t \n\tu32 (*read_count)(void __iomem *base, unsigned long offs);\n\tvoid (*write_count)(void __iomem *base, unsigned long offs, u32 value);\n};\n\nstruct sh_cmt_channel {\n\tstruct sh_cmt_device *cmt;\n\n\tunsigned int index;\t \n\tunsigned int hwidx;\t \n\n\tvoid __iomem *iostart;\n\tvoid __iomem *ioctrl;\n\n\tunsigned int timer_bit;\n\tunsigned long flags;\n\tu32 match_value;\n\tu32 next_match_value;\n\tu32 max_match_value;\n\traw_spinlock_t lock;\n\tstruct clock_event_device ced;\n\tstruct clocksource cs;\n\tu64 total_cycles;\n\tbool cs_enabled;\n};\n\nstruct sh_cmt_device {\n\tstruct platform_device *pdev;\n\n\tconst struct sh_cmt_info *info;\n\n\tvoid __iomem *mapbase;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tunsigned int reg_delay;\n\n\traw_spinlock_t lock;  \n\n\tstruct sh_cmt_channel *channels;\n\tunsigned int num_channels;\n\tunsigned int hw_channels;\n\n\tbool has_clockevent;\n\tbool has_clocksource;\n};\n\n#define SH_CMT16_CMCSR_CMF\t\t(1 << 7)\n#define SH_CMT16_CMCSR_CMIE\t\t(1 << 6)\n#define SH_CMT16_CMCSR_CKS8\t\t(0 << 0)\n#define SH_CMT16_CMCSR_CKS32\t\t(1 << 0)\n#define SH_CMT16_CMCSR_CKS128\t\t(2 << 0)\n#define SH_CMT16_CMCSR_CKS512\t\t(3 << 0)\n#define SH_CMT16_CMCSR_CKS_MASK\t\t(3 << 0)\n\n#define SH_CMT32_CMCSR_CMF\t\t(1 << 15)\n#define SH_CMT32_CMCSR_OVF\t\t(1 << 14)\n#define SH_CMT32_CMCSR_WRFLG\t\t(1 << 13)\n#define SH_CMT32_CMCSR_STTF\t\t(1 << 12)\n#define SH_CMT32_CMCSR_STPF\t\t(1 << 11)\n#define SH_CMT32_CMCSR_SSIE\t\t(1 << 10)\n#define SH_CMT32_CMCSR_CMS\t\t(1 << 9)\n#define SH_CMT32_CMCSR_CMM\t\t(1 << 8)\n#define SH_CMT32_CMCSR_CMTOUT_IE\t(1 << 7)\n#define SH_CMT32_CMCSR_CMR_NONE\t\t(0 << 4)\n#define SH_CMT32_CMCSR_CMR_DMA\t\t(1 << 4)\n#define SH_CMT32_CMCSR_CMR_IRQ\t\t(2 << 4)\n#define SH_CMT32_CMCSR_CMR_MASK\t\t(3 << 4)\n#define SH_CMT32_CMCSR_DBGIVD\t\t(1 << 3)\n#define SH_CMT32_CMCSR_CKS_RCLK8\t(4 << 0)\n#define SH_CMT32_CMCSR_CKS_RCLK32\t(5 << 0)\n#define SH_CMT32_CMCSR_CKS_RCLK128\t(6 << 0)\n#define SH_CMT32_CMCSR_CKS_RCLK1\t(7 << 0)\n#define SH_CMT32_CMCSR_CKS_MASK\t\t(7 << 0)\n\nstatic u32 sh_cmt_read16(void __iomem *base, unsigned long offs)\n{\n\treturn ioread16(base + (offs << 1));\n}\n\nstatic u32 sh_cmt_read32(void __iomem *base, unsigned long offs)\n{\n\treturn ioread32(base + (offs << 2));\n}\n\nstatic void sh_cmt_write16(void __iomem *base, unsigned long offs, u32 value)\n{\n\tiowrite16(value, base + (offs << 1));\n}\n\nstatic void sh_cmt_write32(void __iomem *base, unsigned long offs, u32 value)\n{\n\tiowrite32(value, base + (offs << 2));\n}\n\nstatic const struct sh_cmt_info sh_cmt_info[] = {\n\t[SH_CMT_16BIT] = {\n\t\t.model = SH_CMT_16BIT,\n\t\t.width = 16,\n\t\t.overflow_bit = SH_CMT16_CMCSR_CMF,\n\t\t.clear_bits = ~SH_CMT16_CMCSR_CMF,\n\t\t.read_control = sh_cmt_read16,\n\t\t.write_control = sh_cmt_write16,\n\t\t.read_count = sh_cmt_read16,\n\t\t.write_count = sh_cmt_write16,\n\t},\n\t[SH_CMT_32BIT] = {\n\t\t.model = SH_CMT_32BIT,\n\t\t.width = 32,\n\t\t.overflow_bit = SH_CMT32_CMCSR_CMF,\n\t\t.clear_bits = ~(SH_CMT32_CMCSR_CMF | SH_CMT32_CMCSR_OVF),\n\t\t.read_control = sh_cmt_read16,\n\t\t.write_control = sh_cmt_write16,\n\t\t.read_count = sh_cmt_read32,\n\t\t.write_count = sh_cmt_write32,\n\t},\n\t[SH_CMT_48BIT] = {\n\t\t.model = SH_CMT_48BIT,\n\t\t.channels_mask = 0x3f,\n\t\t.width = 32,\n\t\t.overflow_bit = SH_CMT32_CMCSR_CMF,\n\t\t.clear_bits = ~(SH_CMT32_CMCSR_CMF | SH_CMT32_CMCSR_OVF),\n\t\t.read_control = sh_cmt_read32,\n\t\t.write_control = sh_cmt_write32,\n\t\t.read_count = sh_cmt_read32,\n\t\t.write_count = sh_cmt_write32,\n\t},\n\t[SH_CMT0_RCAR_GEN2] = {\n\t\t.model = SH_CMT0_RCAR_GEN2,\n\t\t.channels_mask = 0x60,\n\t\t.width = 32,\n\t\t.overflow_bit = SH_CMT32_CMCSR_CMF,\n\t\t.clear_bits = ~(SH_CMT32_CMCSR_CMF | SH_CMT32_CMCSR_OVF),\n\t\t.read_control = sh_cmt_read32,\n\t\t.write_control = sh_cmt_write32,\n\t\t.read_count = sh_cmt_read32,\n\t\t.write_count = sh_cmt_write32,\n\t},\n\t[SH_CMT1_RCAR_GEN2] = {\n\t\t.model = SH_CMT1_RCAR_GEN2,\n\t\t.channels_mask = 0xff,\n\t\t.width = 32,\n\t\t.overflow_bit = SH_CMT32_CMCSR_CMF,\n\t\t.clear_bits = ~(SH_CMT32_CMCSR_CMF | SH_CMT32_CMCSR_OVF),\n\t\t.read_control = sh_cmt_read32,\n\t\t.write_control = sh_cmt_write32,\n\t\t.read_count = sh_cmt_read32,\n\t\t.write_count = sh_cmt_write32,\n\t},\n};\n\n#define CMCSR 0  \n#define CMCNT 1  \n#define CMCOR 2  \n\n#define CMCLKE\t0x1000\t \n\nstatic inline u32 sh_cmt_read_cmstr(struct sh_cmt_channel *ch)\n{\n\tif (ch->iostart)\n\t\treturn ch->cmt->info->read_control(ch->iostart, 0);\n\telse\n\t\treturn ch->cmt->info->read_control(ch->cmt->mapbase, 0);\n}\n\nstatic inline void sh_cmt_write_cmstr(struct sh_cmt_channel *ch, u32 value)\n{\n\tu32 old_value = sh_cmt_read_cmstr(ch);\n\n\tif (value != old_value) {\n\t\tif (ch->iostart) {\n\t\t\tch->cmt->info->write_control(ch->iostart, 0, value);\n\t\t\tudelay(ch->cmt->reg_delay);\n\t\t} else {\n\t\t\tch->cmt->info->write_control(ch->cmt->mapbase, 0, value);\n\t\t\tudelay(ch->cmt->reg_delay);\n\t\t}\n\t}\n}\n\nstatic inline u32 sh_cmt_read_cmcsr(struct sh_cmt_channel *ch)\n{\n\treturn ch->cmt->info->read_control(ch->ioctrl, CMCSR);\n}\n\nstatic inline void sh_cmt_write_cmcsr(struct sh_cmt_channel *ch, u32 value)\n{\n\tu32 old_value = sh_cmt_read_cmcsr(ch);\n\n\tif (value != old_value) {\n\t\tch->cmt->info->write_control(ch->ioctrl, CMCSR, value);\n\t\tudelay(ch->cmt->reg_delay);\n\t}\n}\n\nstatic inline u32 sh_cmt_read_cmcnt(struct sh_cmt_channel *ch)\n{\n\treturn ch->cmt->info->read_count(ch->ioctrl, CMCNT);\n}\n\nstatic inline int sh_cmt_write_cmcnt(struct sh_cmt_channel *ch, u32 value)\n{\n\t \n\tunsigned int cmcnt_delay = DIV_ROUND_UP(3 * ch->cmt->reg_delay, 2);\n\tu32 reg;\n\n\tif (ch->cmt->info->model > SH_CMT_16BIT) {\n\t\tint ret = read_poll_timeout_atomic(sh_cmt_read_cmcsr, reg,\n\t\t\t\t\t\t   !(reg & SH_CMT32_CMCSR_WRFLG),\n\t\t\t\t\t\t   1, cmcnt_delay, false, ch);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tch->cmt->info->write_count(ch->ioctrl, CMCNT, value);\n\tudelay(cmcnt_delay);\n\treturn 0;\n}\n\nstatic inline void sh_cmt_write_cmcor(struct sh_cmt_channel *ch, u32 value)\n{\n\tu32 old_value = ch->cmt->info->read_count(ch->ioctrl, CMCOR);\n\n\tif (value != old_value) {\n\t\tch->cmt->info->write_count(ch->ioctrl, CMCOR, value);\n\t\tudelay(ch->cmt->reg_delay);\n\t}\n}\n\nstatic u32 sh_cmt_get_counter(struct sh_cmt_channel *ch, u32 *has_wrapped)\n{\n\tu32 v1, v2, v3;\n\tu32 o1, o2;\n\n\to1 = sh_cmt_read_cmcsr(ch) & ch->cmt->info->overflow_bit;\n\n\t \n\tdo {\n\t\to2 = o1;\n\t\tv1 = sh_cmt_read_cmcnt(ch);\n\t\tv2 = sh_cmt_read_cmcnt(ch);\n\t\tv3 = sh_cmt_read_cmcnt(ch);\n\t\to1 = sh_cmt_read_cmcsr(ch) & ch->cmt->info->overflow_bit;\n\t} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\n\t\t\t  || (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\n\n\t*has_wrapped = o1;\n\treturn v2;\n}\n\nstatic void sh_cmt_start_stop_ch(struct sh_cmt_channel *ch, int start)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\t \n\traw_spin_lock_irqsave(&ch->cmt->lock, flags);\n\tvalue = sh_cmt_read_cmstr(ch);\n\n\tif (start)\n\t\tvalue |= 1 << ch->timer_bit;\n\telse\n\t\tvalue &= ~(1 << ch->timer_bit);\n\n\tsh_cmt_write_cmstr(ch, value);\n\traw_spin_unlock_irqrestore(&ch->cmt->lock, flags);\n}\n\nstatic int sh_cmt_enable(struct sh_cmt_channel *ch)\n{\n\tint ret;\n\n\tdev_pm_syscore_device(&ch->cmt->pdev->dev, true);\n\n\t \n\tret = clk_enable(ch->cmt->clk);\n\tif (ret) {\n\t\tdev_err(&ch->cmt->pdev->dev, \"ch%u: cannot enable clock\\n\",\n\t\t\tch->index);\n\t\tgoto err0;\n\t}\n\n\t \n\tsh_cmt_start_stop_ch(ch, 0);\n\n\t \n\tif (ch->cmt->info->width == 16) {\n\t\tsh_cmt_write_cmcsr(ch, SH_CMT16_CMCSR_CMIE |\n\t\t\t\t   SH_CMT16_CMCSR_CKS512);\n\t} else {\n\t\tu32 cmtout = ch->cmt->info->model <= SH_CMT_48BIT ?\n\t\t\t      SH_CMT32_CMCSR_CMTOUT_IE : 0;\n\t\tsh_cmt_write_cmcsr(ch, cmtout | SH_CMT32_CMCSR_CMM |\n\t\t\t\t   SH_CMT32_CMCSR_CMR_IRQ |\n\t\t\t\t   SH_CMT32_CMCSR_CKS_RCLK8);\n\t}\n\n\tsh_cmt_write_cmcor(ch, 0xffffffff);\n\tret = sh_cmt_write_cmcnt(ch, 0);\n\n\tif (ret || sh_cmt_read_cmcnt(ch)) {\n\t\tdev_err(&ch->cmt->pdev->dev, \"ch%u: cannot clear CMCNT\\n\",\n\t\t\tch->index);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err1;\n\t}\n\n\t \n\tsh_cmt_start_stop_ch(ch, 1);\n\treturn 0;\n err1:\n\t \n\tclk_disable(ch->cmt->clk);\n\n err0:\n\treturn ret;\n}\n\nstatic void sh_cmt_disable(struct sh_cmt_channel *ch)\n{\n\t \n\tsh_cmt_start_stop_ch(ch, 0);\n\n\t \n\tsh_cmt_write_cmcsr(ch, 0);\n\n\t \n\tclk_disable(ch->cmt->clk);\n\n\tdev_pm_syscore_device(&ch->cmt->pdev->dev, false);\n}\n\n \n#define FLAG_CLOCKEVENT (1 << 0)\n#define FLAG_CLOCKSOURCE (1 << 1)\n#define FLAG_REPROGRAM (1 << 2)\n#define FLAG_SKIPEVENT (1 << 3)\n#define FLAG_IRQCONTEXT (1 << 4)\n\nstatic void sh_cmt_clock_event_program_verify(struct sh_cmt_channel *ch,\n\t\t\t\t\t      int absolute)\n{\n\tu32 value = ch->next_match_value;\n\tu32 new_match;\n\tu32 delay = 0;\n\tu32 now = 0;\n\tu32 has_wrapped;\n\n\tnow = sh_cmt_get_counter(ch, &has_wrapped);\n\tch->flags |= FLAG_REPROGRAM;  \n\n\tif (has_wrapped) {\n\t\t \n\t\tch->flags |= FLAG_SKIPEVENT;\n\t\treturn;\n\t}\n\n\tif (absolute)\n\t\tnow = 0;\n\n\tdo {\n\t\t \n\t\tnew_match = now + value + delay;\n\t\tif (new_match > ch->max_match_value)\n\t\t\tnew_match = ch->max_match_value;\n\n\t\tsh_cmt_write_cmcor(ch, new_match);\n\n\t\tnow = sh_cmt_get_counter(ch, &has_wrapped);\n\t\tif (has_wrapped && (new_match > ch->match_value)) {\n\t\t\t \n\t\t\tch->flags |= FLAG_SKIPEVENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (has_wrapped) {\n\t\t\t \n\t\t\tch->match_value = new_match;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (now < new_match) {\n\t\t\t \n\t\t\tch->match_value = new_match;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (delay)\n\t\t\tdelay <<= 1;\n\t\telse\n\t\t\tdelay = 1;\n\n\t\tif (!delay)\n\t\t\tdev_warn(&ch->cmt->pdev->dev, \"ch%u: too long delay\\n\",\n\t\t\t\t ch->index);\n\n\t} while (delay);\n}\n\nstatic void __sh_cmt_set_next(struct sh_cmt_channel *ch, unsigned long delta)\n{\n\tif (delta > ch->max_match_value)\n\t\tdev_warn(&ch->cmt->pdev->dev, \"ch%u: delta out of range\\n\",\n\t\t\t ch->index);\n\n\tch->next_match_value = delta;\n\tsh_cmt_clock_event_program_verify(ch, 0);\n}\n\nstatic void sh_cmt_set_next(struct sh_cmt_channel *ch, unsigned long delta)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ch->lock, flags);\n\t__sh_cmt_set_next(ch, delta);\n\traw_spin_unlock_irqrestore(&ch->lock, flags);\n}\n\nstatic irqreturn_t sh_cmt_interrupt(int irq, void *dev_id)\n{\n\tstruct sh_cmt_channel *ch = dev_id;\n\n\t \n\tsh_cmt_write_cmcsr(ch, sh_cmt_read_cmcsr(ch) &\n\t\t\t   ch->cmt->info->clear_bits);\n\n\t \n\tif (ch->flags & FLAG_CLOCKSOURCE)\n\t\tch->total_cycles += ch->match_value + 1;\n\n\tif (!(ch->flags & FLAG_REPROGRAM))\n\t\tch->next_match_value = ch->max_match_value;\n\n\tch->flags |= FLAG_IRQCONTEXT;\n\n\tif (ch->flags & FLAG_CLOCKEVENT) {\n\t\tif (!(ch->flags & FLAG_SKIPEVENT)) {\n\t\t\tif (clockevent_state_oneshot(&ch->ced)) {\n\t\t\t\tch->next_match_value = ch->max_match_value;\n\t\t\t\tch->flags |= FLAG_REPROGRAM;\n\t\t\t}\n\n\t\t\tch->ced.event_handler(&ch->ced);\n\t\t}\n\t}\n\n\tch->flags &= ~FLAG_SKIPEVENT;\n\n\tif (ch->flags & FLAG_REPROGRAM) {\n\t\tch->flags &= ~FLAG_REPROGRAM;\n\t\tsh_cmt_clock_event_program_verify(ch, 1);\n\n\t\tif (ch->flags & FLAG_CLOCKEVENT)\n\t\t\tif ((clockevent_state_shutdown(&ch->ced))\n\t\t\t    || (ch->match_value == ch->next_match_value))\n\t\t\t\tch->flags &= ~FLAG_REPROGRAM;\n\t}\n\n\tch->flags &= ~FLAG_IRQCONTEXT;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sh_cmt_start(struct sh_cmt_channel *ch, unsigned long flag)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tif (flag & FLAG_CLOCKSOURCE)\n\t\tpm_runtime_get_sync(&ch->cmt->pdev->dev);\n\n\traw_spin_lock_irqsave(&ch->lock, flags);\n\n\tif (!(ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE))) {\n\t\tif (flag & FLAG_CLOCKEVENT)\n\t\t\tpm_runtime_get_sync(&ch->cmt->pdev->dev);\n\t\tret = sh_cmt_enable(ch);\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\tch->flags |= flag;\n\n\t \n\tif (ch->cmt->num_channels == 1 &&\n\t    flag == FLAG_CLOCKSOURCE && (!(ch->flags & FLAG_CLOCKEVENT)))\n\t\t__sh_cmt_set_next(ch, ch->max_match_value);\n out:\n\traw_spin_unlock_irqrestore(&ch->lock, flags);\n\n\treturn ret;\n}\n\nstatic void sh_cmt_stop(struct sh_cmt_channel *ch, unsigned long flag)\n{\n\tunsigned long flags;\n\tunsigned long f;\n\n\traw_spin_lock_irqsave(&ch->lock, flags);\n\n\tf = ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE);\n\tch->flags &= ~flag;\n\n\tif (f && !(ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE))) {\n\t\tsh_cmt_disable(ch);\n\t\tif (flag & FLAG_CLOCKEVENT)\n\t\t\tpm_runtime_put(&ch->cmt->pdev->dev);\n\t}\n\n\t \n\tif ((flag == FLAG_CLOCKEVENT) && (ch->flags & FLAG_CLOCKSOURCE))\n\t\t__sh_cmt_set_next(ch, ch->max_match_value);\n\n\traw_spin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (flag & FLAG_CLOCKSOURCE)\n\t\tpm_runtime_put(&ch->cmt->pdev->dev);\n}\n\nstatic struct sh_cmt_channel *cs_to_sh_cmt(struct clocksource *cs)\n{\n\treturn container_of(cs, struct sh_cmt_channel, cs);\n}\n\nstatic u64 sh_cmt_clocksource_read(struct clocksource *cs)\n{\n\tstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\n\tu32 has_wrapped;\n\n\tif (ch->cmt->num_channels == 1) {\n\t\tunsigned long flags;\n\t\tu64 value;\n\t\tu32 raw;\n\n\t\traw_spin_lock_irqsave(&ch->lock, flags);\n\t\tvalue = ch->total_cycles;\n\t\traw = sh_cmt_get_counter(ch, &has_wrapped);\n\n\t\tif (unlikely(has_wrapped))\n\t\t\traw += ch->match_value + 1;\n\t\traw_spin_unlock_irqrestore(&ch->lock, flags);\n\n\t\treturn value + raw;\n\t}\n\n\treturn sh_cmt_get_counter(ch, &has_wrapped);\n}\n\nstatic int sh_cmt_clocksource_enable(struct clocksource *cs)\n{\n\tint ret;\n\tstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\n\n\tWARN_ON(ch->cs_enabled);\n\n\tch->total_cycles = 0;\n\n\tret = sh_cmt_start(ch, FLAG_CLOCKSOURCE);\n\tif (!ret)\n\t\tch->cs_enabled = true;\n\n\treturn ret;\n}\n\nstatic void sh_cmt_clocksource_disable(struct clocksource *cs)\n{\n\tstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\n\n\tWARN_ON(!ch->cs_enabled);\n\n\tsh_cmt_stop(ch, FLAG_CLOCKSOURCE);\n\tch->cs_enabled = false;\n}\n\nstatic void sh_cmt_clocksource_suspend(struct clocksource *cs)\n{\n\tstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\n\n\tif (!ch->cs_enabled)\n\t\treturn;\n\n\tsh_cmt_stop(ch, FLAG_CLOCKSOURCE);\n\tdev_pm_genpd_suspend(&ch->cmt->pdev->dev);\n}\n\nstatic void sh_cmt_clocksource_resume(struct clocksource *cs)\n{\n\tstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\n\n\tif (!ch->cs_enabled)\n\t\treturn;\n\n\tdev_pm_genpd_resume(&ch->cmt->pdev->dev);\n\tsh_cmt_start(ch, FLAG_CLOCKSOURCE);\n}\n\nstatic int sh_cmt_register_clocksource(struct sh_cmt_channel *ch,\n\t\t\t\t       const char *name)\n{\n\tstruct clocksource *cs = &ch->cs;\n\n\tcs->name = name;\n\tcs->rating = 125;\n\tcs->read = sh_cmt_clocksource_read;\n\tcs->enable = sh_cmt_clocksource_enable;\n\tcs->disable = sh_cmt_clocksource_disable;\n\tcs->suspend = sh_cmt_clocksource_suspend;\n\tcs->resume = sh_cmt_clocksource_resume;\n\tcs->mask = CLOCKSOURCE_MASK(ch->cmt->info->width);\n\tcs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\n\n\tdev_info(&ch->cmt->pdev->dev, \"ch%u: used as clock source\\n\",\n\t\t ch->index);\n\n\tclocksource_register_hz(cs, ch->cmt->rate);\n\treturn 0;\n}\n\nstatic struct sh_cmt_channel *ced_to_sh_cmt(struct clock_event_device *ced)\n{\n\treturn container_of(ced, struct sh_cmt_channel, ced);\n}\n\nstatic void sh_cmt_clock_event_start(struct sh_cmt_channel *ch, int periodic)\n{\n\tsh_cmt_start(ch, FLAG_CLOCKEVENT);\n\n\tif (periodic)\n\t\tsh_cmt_set_next(ch, ((ch->cmt->rate + HZ/2) / HZ) - 1);\n\telse\n\t\tsh_cmt_set_next(ch, ch->max_match_value);\n}\n\nstatic int sh_cmt_clock_event_shutdown(struct clock_event_device *ced)\n{\n\tstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\n\n\tsh_cmt_stop(ch, FLAG_CLOCKEVENT);\n\treturn 0;\n}\n\nstatic int sh_cmt_clock_event_set_state(struct clock_event_device *ced,\n\t\t\t\t\tint periodic)\n{\n\tstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\n\n\t \n\tif (clockevent_state_oneshot(ced) || clockevent_state_periodic(ced))\n\t\tsh_cmt_stop(ch, FLAG_CLOCKEVENT);\n\n\tdev_info(&ch->cmt->pdev->dev, \"ch%u: used for %s clock events\\n\",\n\t\t ch->index, periodic ? \"periodic\" : \"oneshot\");\n\tsh_cmt_clock_event_start(ch, periodic);\n\treturn 0;\n}\n\nstatic int sh_cmt_clock_event_set_oneshot(struct clock_event_device *ced)\n{\n\treturn sh_cmt_clock_event_set_state(ced, 0);\n}\n\nstatic int sh_cmt_clock_event_set_periodic(struct clock_event_device *ced)\n{\n\treturn sh_cmt_clock_event_set_state(ced, 1);\n}\n\nstatic int sh_cmt_clock_event_next(unsigned long delta,\n\t\t\t\t   struct clock_event_device *ced)\n{\n\tstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\n\n\tBUG_ON(!clockevent_state_oneshot(ced));\n\tif (likely(ch->flags & FLAG_IRQCONTEXT))\n\t\tch->next_match_value = delta - 1;\n\telse\n\t\tsh_cmt_set_next(ch, delta - 1);\n\n\treturn 0;\n}\n\nstatic void sh_cmt_clock_event_suspend(struct clock_event_device *ced)\n{\n\tstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\n\n\tdev_pm_genpd_suspend(&ch->cmt->pdev->dev);\n\tclk_unprepare(ch->cmt->clk);\n}\n\nstatic void sh_cmt_clock_event_resume(struct clock_event_device *ced)\n{\n\tstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\n\n\tclk_prepare(ch->cmt->clk);\n\tdev_pm_genpd_resume(&ch->cmt->pdev->dev);\n}\n\nstatic int sh_cmt_register_clockevent(struct sh_cmt_channel *ch,\n\t\t\t\t      const char *name)\n{\n\tstruct clock_event_device *ced = &ch->ced;\n\tint irq;\n\tint ret;\n\n\tirq = platform_get_irq(ch->cmt->pdev, ch->index);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = request_irq(irq, sh_cmt_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\n\t\t\t  dev_name(&ch->cmt->pdev->dev), ch);\n\tif (ret) {\n\t\tdev_err(&ch->cmt->pdev->dev, \"ch%u: failed to request irq %d\\n\",\n\t\t\tch->index, irq);\n\t\treturn ret;\n\t}\n\n\tced->name = name;\n\tced->features = CLOCK_EVT_FEAT_PERIODIC;\n\tced->features |= CLOCK_EVT_FEAT_ONESHOT;\n\tced->rating = 125;\n\tced->cpumask = cpu_possible_mask;\n\tced->set_next_event = sh_cmt_clock_event_next;\n\tced->set_state_shutdown = sh_cmt_clock_event_shutdown;\n\tced->set_state_periodic = sh_cmt_clock_event_set_periodic;\n\tced->set_state_oneshot = sh_cmt_clock_event_set_oneshot;\n\tced->suspend = sh_cmt_clock_event_suspend;\n\tced->resume = sh_cmt_clock_event_resume;\n\n\t \n\tced->shift = 32;\n\tced->mult = div_sc(ch->cmt->rate, NSEC_PER_SEC, ced->shift);\n\tced->max_delta_ns = clockevent_delta2ns(ch->max_match_value, ced);\n\tced->max_delta_ticks = ch->max_match_value;\n\tced->min_delta_ns = clockevent_delta2ns(0x1f, ced);\n\tced->min_delta_ticks = 0x1f;\n\n\tdev_info(&ch->cmt->pdev->dev, \"ch%u: used for clock events\\n\",\n\t\t ch->index);\n\tclockevents_register_device(ced);\n\n\treturn 0;\n}\n\nstatic int sh_cmt_register(struct sh_cmt_channel *ch, const char *name,\n\t\t\t   bool clockevent, bool clocksource)\n{\n\tint ret;\n\n\tif (clockevent) {\n\t\tch->cmt->has_clockevent = true;\n\t\tret = sh_cmt_register_clockevent(ch, name);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (clocksource) {\n\t\tch->cmt->has_clocksource = true;\n\t\tsh_cmt_register_clocksource(ch, name);\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_cmt_setup_channel(struct sh_cmt_channel *ch, unsigned int index,\n\t\t\t\tunsigned int hwidx, bool clockevent,\n\t\t\t\tbool clocksource, struct sh_cmt_device *cmt)\n{\n\tu32 value;\n\tint ret;\n\n\t \n\tif (!clockevent && !clocksource)\n\t\treturn 0;\n\n\tch->cmt = cmt;\n\tch->index = index;\n\tch->hwidx = hwidx;\n\tch->timer_bit = hwidx;\n\n\t \n\tswitch (cmt->info->model) {\n\tcase SH_CMT_16BIT:\n\t\tch->ioctrl = cmt->mapbase + 2 + ch->hwidx * 6;\n\t\tbreak;\n\tcase SH_CMT_32BIT:\n\tcase SH_CMT_48BIT:\n\t\tch->ioctrl = cmt->mapbase + 0x10 + ch->hwidx * 0x10;\n\t\tbreak;\n\tcase SH_CMT0_RCAR_GEN2:\n\tcase SH_CMT1_RCAR_GEN2:\n\t\tch->iostart = cmt->mapbase + ch->hwidx * 0x100;\n\t\tch->ioctrl = ch->iostart + 0x10;\n\t\tch->timer_bit = 0;\n\n\t\t \n\t\tvalue = ioread32(cmt->mapbase + CMCLKE);\n\t\tvalue |= BIT(hwidx);\n\t\tiowrite32(value, cmt->mapbase + CMCLKE);\n\t\tbreak;\n\t}\n\n\tif (cmt->info->width == (sizeof(ch->max_match_value) * 8))\n\t\tch->max_match_value = ~0;\n\telse\n\t\tch->max_match_value = (1 << cmt->info->width) - 1;\n\n\tch->match_value = ch->max_match_value;\n\traw_spin_lock_init(&ch->lock);\n\n\tret = sh_cmt_register(ch, dev_name(&cmt->pdev->dev),\n\t\t\t      clockevent, clocksource);\n\tif (ret) {\n\t\tdev_err(&cmt->pdev->dev, \"ch%u: registration failed\\n\",\n\t\t\tch->index);\n\t\treturn ret;\n\t}\n\tch->cs_enabled = false;\n\n\treturn 0;\n}\n\nstatic int sh_cmt_map_memory(struct sh_cmt_device *cmt)\n{\n\tstruct resource *mem;\n\n\tmem = platform_get_resource(cmt->pdev, IORESOURCE_MEM, 0);\n\tif (!mem) {\n\t\tdev_err(&cmt->pdev->dev, \"failed to get I/O memory\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tcmt->mapbase = ioremap(mem->start, resource_size(mem));\n\tif (cmt->mapbase == NULL) {\n\t\tdev_err(&cmt->pdev->dev, \"failed to remap I/O memory\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sh_cmt_id_table[] = {\n\t{ \"sh-cmt-16\", (kernel_ulong_t)&sh_cmt_info[SH_CMT_16BIT] },\n\t{ \"sh-cmt-32\", (kernel_ulong_t)&sh_cmt_info[SH_CMT_32BIT] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sh_cmt_id_table);\n\nstatic const struct of_device_id sh_cmt_of_table[] __maybe_unused = {\n\t{\n\t\t \n\t\t.compatible = \"renesas,cmt-48\",\n\t\t.data = &sh_cmt_info[SH_CMT_48BIT]\n\t},\n\t{\n\t\t \n\t\t.compatible = \"renesas,cmt-48-gen2\",\n\t\t.data = &sh_cmt_info[SH_CMT0_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a7740-cmt1\",\n\t\t.data = &sh_cmt_info[SH_CMT_48BIT]\n\t},\n\t{\n\t\t.compatible = \"renesas,sh73a0-cmt1\",\n\t\t.data = &sh_cmt_info[SH_CMT_48BIT]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-cmt0\",\n\t\t.data = &sh_cmt_info[SH_CMT0_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-cmt1\",\n\t\t.data = &sh_cmt_info[SH_CMT1_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-cmt0\",\n\t\t.data = &sh_cmt_info[SH_CMT0_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-cmt1\",\n\t\t.data = &sh_cmt_info[SH_CMT1_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen4-cmt0\",\n\t\t.data = &sh_cmt_info[SH_CMT0_RCAR_GEN2]\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen4-cmt1\",\n\t\t.data = &sh_cmt_info[SH_CMT1_RCAR_GEN2]\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sh_cmt_of_table);\n\nstatic int sh_cmt_setup(struct sh_cmt_device *cmt, struct platform_device *pdev)\n{\n\tunsigned int mask, i;\n\tunsigned long rate;\n\tint ret;\n\n\tcmt->pdev = pdev;\n\traw_spin_lock_init(&cmt->lock);\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tcmt->info = of_device_get_match_data(&pdev->dev);\n\t\tcmt->hw_channels = cmt->info->channels_mask;\n\t} else if (pdev->dev.platform_data) {\n\t\tstruct sh_timer_config *cfg = pdev->dev.platform_data;\n\t\tconst struct platform_device_id *id = pdev->id_entry;\n\n\t\tcmt->info = (const struct sh_cmt_info *)id->driver_data;\n\t\tcmt->hw_channels = cfg->channels_mask;\n\t} else {\n\t\tdev_err(&cmt->pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tcmt->clk = clk_get(&cmt->pdev->dev, \"fck\");\n\tif (IS_ERR(cmt->clk)) {\n\t\tdev_err(&cmt->pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(cmt->clk);\n\t}\n\n\tret = clk_prepare(cmt->clk);\n\tif (ret < 0)\n\t\tgoto err_clk_put;\n\n\t \n\tret = clk_enable(cmt->clk);\n\tif (ret < 0)\n\t\tgoto err_clk_unprepare;\n\n\trate = clk_get_rate(cmt->clk);\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\tif (cmt->info->model >= SH_CMT_48BIT)\n\t\tcmt->reg_delay = DIV_ROUND_UP(2UL * USEC_PER_SEC, rate);\n\tcmt->rate = rate / (cmt->info->width == 16 ? 512 : 8);\n\n\t \n\tret = sh_cmt_map_memory(cmt);\n\tif (ret < 0)\n\t\tgoto err_clk_disable;\n\n\t \n\tcmt->num_channels = hweight8(cmt->hw_channels);\n\tcmt->channels = kcalloc(cmt->num_channels, sizeof(*cmt->channels),\n\t\t\t\tGFP_KERNEL);\n\tif (cmt->channels == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\tfor (i = 0, mask = cmt->hw_channels; i < cmt->num_channels; ++i) {\n\t\tunsigned int hwidx = ffs(mask) - 1;\n\t\tbool clocksource = i == 1 || cmt->num_channels == 1;\n\t\tbool clockevent = i == 0;\n\n\t\tret = sh_cmt_setup_channel(&cmt->channels[i], i, hwidx,\n\t\t\t\t\t   clockevent, clocksource, cmt);\n\t\tif (ret < 0)\n\t\t\tgoto err_unmap;\n\n\t\tmask &= ~(1 << hwidx);\n\t}\n\n\tclk_disable(cmt->clk);\n\n\tplatform_set_drvdata(pdev, cmt);\n\n\treturn 0;\n\nerr_unmap:\n\tkfree(cmt->channels);\n\tiounmap(cmt->mapbase);\nerr_clk_disable:\n\tclk_disable(cmt->clk);\nerr_clk_unprepare:\n\tclk_unprepare(cmt->clk);\nerr_clk_put:\n\tclk_put(cmt->clk);\n\treturn ret;\n}\n\nstatic int sh_cmt_probe(struct platform_device *pdev)\n{\n\tstruct sh_cmt_device *cmt = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (!is_sh_early_platform_device(pdev)) {\n\t\tpm_runtime_set_active(&pdev->dev);\n\t\tpm_runtime_enable(&pdev->dev);\n\t}\n\n\tif (cmt) {\n\t\tdev_info(&pdev->dev, \"kept as earlytimer\\n\");\n\t\tgoto out;\n\t}\n\n\tcmt = kzalloc(sizeof(*cmt), GFP_KERNEL);\n\tif (cmt == NULL)\n\t\treturn -ENOMEM;\n\n\tret = sh_cmt_setup(cmt, pdev);\n\tif (ret) {\n\t\tkfree(cmt);\n\t\tpm_runtime_idle(&pdev->dev);\n\t\treturn ret;\n\t}\n\tif (is_sh_early_platform_device(pdev))\n\t\treturn 0;\n\n out:\n\tif (cmt->has_clockevent || cmt->has_clocksource)\n\t\tpm_runtime_irq_safe(&pdev->dev);\n\telse\n\t\tpm_runtime_idle(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sh_cmt_device_driver = {\n\t.probe\t\t= sh_cmt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sh_cmt\",\n\t\t.of_match_table = of_match_ptr(sh_cmt_of_table),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.id_table\t= sh_cmt_id_table,\n};\n\nstatic int __init sh_cmt_init(void)\n{\n\treturn platform_driver_register(&sh_cmt_device_driver);\n}\n\nstatic void __exit sh_cmt_exit(void)\n{\n\tplatform_driver_unregister(&sh_cmt_device_driver);\n}\n\n#ifdef CONFIG_SUPERH\nsh_early_platform_init(\"earlytimer\", &sh_cmt_device_driver);\n#endif\n\nsubsys_initcall(sh_cmt_init);\nmodule_exit(sh_cmt_exit);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"SuperH CMT Timer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}