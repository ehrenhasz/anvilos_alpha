{
  "module_name": "nomadik-mtu.c",
  "hash_id": "299d9b2ea58a1ca4c846dbef543347377e9a70ff2252ba36bc7d9b9075a3e8cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/nomadik-mtu.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/sched_clock.h>\n#include <asm/mach/time.h>\n\n \n\n#define MTU_IMSC\t0x00\t \n#define MTU_RIS\t\t0x04\t \n#define MTU_MIS\t\t0x08\t \n#define MTU_ICR\t\t0x0C\t \n\n \n#define MTU_LR(x)\t(0x10 + 0x10 * (x) + 0x00)\t \n#define MTU_VAL(x)\t(0x10 + 0x10 * (x) + 0x04)\t \n#define MTU_CR(x)\t(0x10 + 0x10 * (x) + 0x08)\t \n#define MTU_BGLR(x)\t(0x10 + 0x10 * (x) + 0x0c)\t \n\n \n#define MTU_CRn_ENA\t\t0x80\n#define MTU_CRn_PERIODIC\t0x40\t \n#define MTU_CRn_PRESCALE_MASK\t0x0c\n#define MTU_CRn_PRESCALE_1\t\t0x00\n#define MTU_CRn_PRESCALE_16\t\t0x04\n#define MTU_CRn_PRESCALE_256\t\t0x08\n#define MTU_CRn_32BITS\t\t0x02\n#define MTU_CRn_ONESHOT\t\t0x01\t \n\n \n#define MTU_ITCR\t0xff0\n#define MTU_ITOP\t0xff4\n\n#define MTU_PERIPH_ID0\t0xfe0\n#define MTU_PERIPH_ID1\t0xfe4\n#define MTU_PERIPH_ID2\t0xfe8\n#define MTU_PERIPH_ID3\t0xfeC\n\n#define MTU_PCELL0\t0xff0\n#define MTU_PCELL1\t0xff4\n#define MTU_PCELL2\t0xff8\n#define MTU_PCELL3\t0xffC\n\nstatic void __iomem *mtu_base;\nstatic bool clkevt_periodic;\nstatic u32 clk_prescale;\nstatic u32 nmdk_cycle;\t\t \nstatic struct delay_timer mtu_delay_timer;\n\n \nstatic u64 notrace nomadik_read_sched_clock(void)\n{\n\tif (unlikely(!mtu_base))\n\t\treturn 0;\n\n\treturn -readl(mtu_base + MTU_VAL(0));\n}\n\nstatic unsigned long nmdk_timer_read_current_timer(void)\n{\n\treturn ~readl_relaxed(mtu_base + MTU_VAL(0));\n}\n\n \nstatic int nmdk_clkevt_next(unsigned long evt, struct clock_event_device *ev)\n{\n\twritel(1 << 1, mtu_base + MTU_IMSC);\n\twritel(evt, mtu_base + MTU_LR(1));\n\t \n\twritel(MTU_CRn_ONESHOT | clk_prescale |\n\t       MTU_CRn_32BITS | MTU_CRn_ENA,\n\t       mtu_base + MTU_CR(1));\n\n\treturn 0;\n}\n\nstatic void nmdk_clkevt_reset(void)\n{\n\tif (clkevt_periodic) {\n\t\t \n\t\twritel(nmdk_cycle, mtu_base + MTU_LR(1));\n\t\twritel(nmdk_cycle, mtu_base + MTU_BGLR(1));\n\n\t\twritel(MTU_CRn_PERIODIC | clk_prescale |\n\t\t       MTU_CRn_32BITS | MTU_CRn_ENA,\n\t\t       mtu_base + MTU_CR(1));\n\t\twritel(1 << 1, mtu_base + MTU_IMSC);\n\t} else {\n\t\t \n\t\t(void) nmdk_clkevt_next(nmdk_cycle, NULL);\n\t}\n}\n\nstatic int nmdk_clkevt_shutdown(struct clock_event_device *evt)\n{\n\twritel(0, mtu_base + MTU_IMSC);\n\t \n\twritel(0, mtu_base + MTU_CR(1));\n\t \n\twritel(0xffffffff, mtu_base + MTU_LR(1));\n\treturn 0;\n}\n\nstatic int nmdk_clkevt_set_oneshot(struct clock_event_device *evt)\n{\n\tclkevt_periodic = false;\n\treturn 0;\n}\n\nstatic int nmdk_clkevt_set_periodic(struct clock_event_device *evt)\n{\n\tclkevt_periodic = true;\n\tnmdk_clkevt_reset();\n\treturn 0;\n}\n\nstatic void nmdk_clksrc_reset(void)\n{\n\t \n\twritel(0, mtu_base + MTU_CR(0));\n\n\t \n\twritel(nmdk_cycle, mtu_base + MTU_LR(0));\n\twritel(nmdk_cycle, mtu_base + MTU_BGLR(0));\n\n\twritel(clk_prescale | MTU_CRn_32BITS | MTU_CRn_ENA,\n\t       mtu_base + MTU_CR(0));\n}\n\nstatic void nmdk_clkevt_resume(struct clock_event_device *cedev)\n{\n\tnmdk_clkevt_reset();\n\tnmdk_clksrc_reset();\n}\n\nstatic struct clock_event_device nmdk_clkevt = {\n\t.name\t\t\t= \"mtu_1\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_DYNIRQ,\n\t.rating\t\t\t= 200,\n\t.set_state_shutdown\t= nmdk_clkevt_shutdown,\n\t.set_state_periodic\t= nmdk_clkevt_set_periodic,\n\t.set_state_oneshot\t= nmdk_clkevt_set_oneshot,\n\t.set_next_event\t\t= nmdk_clkevt_next,\n\t.resume\t\t\t= nmdk_clkevt_resume,\n};\n\n \nstatic irqreturn_t nmdk_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evdev = dev_id;\n\n\twritel(1 << 1, mtu_base + MTU_ICR);  \n\tevdev->event_handler(evdev);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init nmdk_timer_init(void __iomem *base, int irq,\n\t\t\t\t   struct clk *pclk, struct clk *clk)\n{\n\tunsigned long rate;\n\tint ret;\n\tint min_ticks;\n\n\tmtu_base = base;\n\n\tBUG_ON(clk_prepare_enable(pclk));\n\tBUG_ON(clk_prepare_enable(clk));\n\n\t \n\trate = clk_get_rate(clk);\n\tif (rate > 32000000) {\n\t\trate /= 16;\n\t\tclk_prescale = MTU_CRn_PRESCALE_16;\n\t} else {\n\t\tclk_prescale = MTU_CRn_PRESCALE_1;\n\t}\n\n\t \n\tnmdk_cycle = DIV_ROUND_CLOSEST(rate, HZ);\n\n\n\t \n\tnmdk_clksrc_reset();\n\n\tret = clocksource_mmio_init(mtu_base + MTU_VAL(0), \"mtu_0\",\n\t\t\t\t    rate, 200, 32, clocksource_mmio_readl_down);\n\tif (ret) {\n\t\tpr_err(\"timer: failed to initialize clock source %s\\n\", \"mtu_0\");\n\t\treturn ret;\n\t}\n\n\tsched_clock_register(nomadik_read_sched_clock, 32, rate);\n\n\t \n\tif (request_irq(irq, nmdk_timer_interrupt, IRQF_TIMER,\n\t\t\t\"Nomadik Timer Tick\", &nmdk_clkevt))\n\t\tpr_err(\"%s: request_irq() failed\\n\", \"Nomadik Timer Tick\");\n\tnmdk_clkevt.cpumask = cpumask_of(0);\n\tnmdk_clkevt.irq = irq;\n\tif (rate < 100000)\n\t\tmin_ticks = 5;\n\telse\n\t\tmin_ticks = 2;\n\tclockevents_config_and_register(&nmdk_clkevt, rate, min_ticks,\n\t\t\t\t\t0xffffffffU);\n\n\tmtu_delay_timer.read_current_timer = &nmdk_timer_read_current_timer;\n\tmtu_delay_timer.freq = rate;\n\tregister_current_timer_delay(&mtu_delay_timer);\n\n\treturn 0;\n}\n\nstatic int __init nmdk_timer_of_init(struct device_node *node)\n{\n\tstruct clk *pclk;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint irq;\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"Can't remap registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpclk = of_clk_get_by_name(node, \"apb_pclk\");\n\tif (IS_ERR(pclk)) {\n\t\tpr_err(\"could not get apb_pclk\\n\");\n\t\treturn PTR_ERR(pclk);\n\t}\n\n\tclk = of_clk_get_by_name(node, \"timclk\");\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"could not get timclk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't parse IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nmdk_timer_init(base, irq, pclk, clk);\n}\nTIMER_OF_DECLARE(nomadik_mtu, \"st,nomadik-mtu\",\n\t\t       nmdk_timer_of_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}