{
  "module_name": "timer-ti-dm.c",
  "hash_id": "f2c5b3a82c96dfc38f10e07c00b8ee5c68c1ca1ab2d56cf7757b08e97fd5b32b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-ti-dm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/cpu_pm.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/dmtimer-omap.h>\n\n#include <clocksource/timer-ti-dm.h>\n\n \n#define OMAP_TIMER_ERRATA_I103_I767\t\t\t0x80000000\n\n \n#define OMAP_TIMER_NONPOSTED\t\t\t0x00\n#define OMAP_TIMER_POSTED\t\t\t0x01\n\n \n#define\tWPSHIFT\t\t\t\t\t16\n\n#define OMAP_TIMER_WAKEUP_EN_REG\t\t(_OMAP_TIMER_WAKEUP_EN_OFFSET \\\n\t\t\t\t\t\t\t| (WP_NONE << WPSHIFT))\n\n#define OMAP_TIMER_CTRL_REG\t\t\t(_OMAP_TIMER_CTRL_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TCLR << WPSHIFT))\n\n#define OMAP_TIMER_COUNTER_REG\t\t\t(_OMAP_TIMER_COUNTER_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TCRR << WPSHIFT))\n\n#define OMAP_TIMER_LOAD_REG\t\t\t(_OMAP_TIMER_LOAD_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TLDR << WPSHIFT))\n\n#define OMAP_TIMER_TRIGGER_REG\t\t\t(_OMAP_TIMER_TRIGGER_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TTGR << WPSHIFT))\n\n#define OMAP_TIMER_WRITE_PEND_REG\t\t(_OMAP_TIMER_WRITE_PEND_OFFSET \\\n\t\t\t\t\t\t\t| (WP_NONE << WPSHIFT))\n\n#define OMAP_TIMER_MATCH_REG\t\t\t(_OMAP_TIMER_MATCH_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TMAR << WPSHIFT))\n\n#define OMAP_TIMER_CAPTURE_REG\t\t\t(_OMAP_TIMER_CAPTURE_OFFSET \\\n\t\t\t\t\t\t\t| (WP_NONE << WPSHIFT))\n\n#define OMAP_TIMER_IF_CTRL_REG\t\t\t(_OMAP_TIMER_IF_CTRL_OFFSET \\\n\t\t\t\t\t\t\t| (WP_NONE << WPSHIFT))\n\n#define OMAP_TIMER_CAPTURE2_REG\t\t\t(_OMAP_TIMER_CAPTURE2_OFFSET \\\n\t\t\t\t\t\t\t| (WP_NONE << WPSHIFT))\n\n#define OMAP_TIMER_TICK_POS_REG\t\t\t(_OMAP_TIMER_TICK_POS_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TPIR << WPSHIFT))\n\n#define OMAP_TIMER_TICK_NEG_REG\t\t\t(_OMAP_TIMER_TICK_NEG_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TNIR << WPSHIFT))\n\n#define OMAP_TIMER_TICK_COUNT_REG\t\t(_OMAP_TIMER_TICK_COUNT_OFFSET \\\n\t\t\t\t\t\t\t| (WP_TCVR << WPSHIFT))\n\n#define OMAP_TIMER_TICK_INT_MASK_SET_REG\t\t\t\t\\\n\t\t(_OMAP_TIMER_TICK_INT_MASK_SET_OFFSET | (WP_TOCR << WPSHIFT))\n\n#define OMAP_TIMER_TICK_INT_MASK_COUNT_REG\t\t\t\t\\\n\t\t(_OMAP_TIMER_TICK_INT_MASK_COUNT_OFFSET | (WP_TOWR << WPSHIFT))\n\nstruct timer_regs {\n\tu32 ocp_cfg;\n\tu32 tidr;\n\tu32 tier;\n\tu32 twer;\n\tu32 tclr;\n\tu32 tcrr;\n\tu32 tldr;\n\tu32 ttrg;\n\tu32 twps;\n\tu32 tmar;\n\tu32 tcar1;\n\tu32 tsicr;\n\tu32 tcar2;\n\tu32 tpir;\n\tu32 tnir;\n\tu32 tcvr;\n\tu32 tocr;\n\tu32 towr;\n};\n\nstruct dmtimer {\n\tstruct omap_dm_timer cookie;\n\tint id;\n\tint irq;\n\tstruct clk *fclk;\n\n\tvoid __iomem\t*io_base;\n\tint\t\tirq_stat;\t \n\tint\t\tirq_ena;\t \n\tint\t\tirq_dis;\t \n\tvoid __iomem\t*pend;\t\t \n\tvoid __iomem\t*func_base;\t \n\n\tatomic_t enabled;\n\tunsigned long rate;\n\tunsigned reserved:1;\n\tunsigned posted:1;\n\tunsigned omap1:1;\n\tstruct timer_regs context;\n\tint revision;\n\tu32 capability;\n\tu32 errata;\n\tstruct platform_device *pdev;\n\tstruct list_head node;\n\tstruct notifier_block nb;\n\tstruct notifier_block fclk_nb;\n\tunsigned long fclk_rate;\n};\n\nstatic u32 omap_reserved_systimers;\nstatic LIST_HEAD(omap_timer_list);\nstatic DEFINE_SPINLOCK(dm_timer_lock);\n\nenum {\n\tREQUEST_ANY = 0,\n\tREQUEST_BY_ID,\n\tREQUEST_BY_CAP,\n\tREQUEST_BY_NODE,\n};\n\n \nstatic inline u32 dmtimer_read(struct dmtimer *timer, u32 reg)\n{\n\tu16 wp, offset;\n\n\twp = reg >> WPSHIFT;\n\toffset = reg & 0xff;\n\n\t \n\tif (wp && timer->posted)\n\t\twhile (readl_relaxed(timer->pend) & wp)\n\t\t\tcpu_relax();\n\n\treturn readl_relaxed(timer->func_base + offset);\n}\n\n \nstatic inline void dmtimer_write(struct dmtimer *timer, u32 reg, u32 val)\n{\n\tu16 wp, offset;\n\n\twp = reg >> WPSHIFT;\n\toffset = reg & 0xff;\n\n\t \n\tif (wp && timer->posted)\n\t\twhile (readl_relaxed(timer->pend) & wp)\n\t\t\tcpu_relax();\n\n\twritel_relaxed(val, timer->func_base + offset);\n}\n\nstatic inline void __omap_dm_timer_init_regs(struct dmtimer *timer)\n{\n\tu32 tidr;\n\n\t \n\ttidr = readl_relaxed(timer->io_base);\n\tif (!(tidr >> 16)) {\n\t\ttimer->revision = 1;\n\t\ttimer->irq_stat = OMAP_TIMER_V1_STAT_OFFSET;\n\t\ttimer->irq_ena = OMAP_TIMER_V1_INT_EN_OFFSET;\n\t\ttimer->irq_dis = OMAP_TIMER_V1_INT_EN_OFFSET;\n\t\ttimer->pend = timer->io_base + _OMAP_TIMER_WRITE_PEND_OFFSET;\n\t\ttimer->func_base = timer->io_base;\n\t} else {\n\t\ttimer->revision = 2;\n\t\ttimer->irq_stat = OMAP_TIMER_V2_IRQSTATUS - OMAP_TIMER_V2_FUNC_OFFSET;\n\t\ttimer->irq_ena = OMAP_TIMER_V2_IRQENABLE_SET - OMAP_TIMER_V2_FUNC_OFFSET;\n\t\ttimer->irq_dis = OMAP_TIMER_V2_IRQENABLE_CLR - OMAP_TIMER_V2_FUNC_OFFSET;\n\t\ttimer->pend = timer->io_base +\n\t\t\t_OMAP_TIMER_WRITE_PEND_OFFSET +\n\t\t\t\tOMAP_TIMER_V2_FUNC_OFFSET;\n\t\ttimer->func_base = timer->io_base + OMAP_TIMER_V2_FUNC_OFFSET;\n\t}\n}\n\n \nstatic inline void __omap_dm_timer_enable_posted(struct dmtimer *timer)\n{\n\tif (timer->posted)\n\t\treturn;\n\n\tif (timer->errata & OMAP_TIMER_ERRATA_I103_I767) {\n\t\ttimer->posted = OMAP_TIMER_NONPOSTED;\n\t\tdmtimer_write(timer, OMAP_TIMER_IF_CTRL_REG, 0);\n\t\treturn;\n\t}\n\n\tdmtimer_write(timer, OMAP_TIMER_IF_CTRL_REG, OMAP_TIMER_CTRL_POSTED);\n\ttimer->context.tsicr = OMAP_TIMER_CTRL_POSTED;\n\ttimer->posted = OMAP_TIMER_POSTED;\n}\n\nstatic inline void __omap_dm_timer_stop(struct dmtimer *timer)\n{\n\tu32 l;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\tif (l & OMAP_TIMER_CTRL_ST) {\n\t\tl &= ~0x1;\n\t\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, l);\n#ifdef CONFIG_ARCH_OMAP2PLUS\n\t\t \n\t\tdmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\t\t \n\t\tudelay(3500000 / timer->fclk_rate + 1);\n#endif\n\t}\n\n\t \n\tdmtimer_write(timer, timer->irq_stat, OMAP_TIMER_INT_OVERFLOW);\n}\n\nstatic inline void __omap_dm_timer_int_enable(struct dmtimer *timer,\n\t\t\t\t\t      unsigned int value)\n{\n\tdmtimer_write(timer, timer->irq_ena, value);\n\tdmtimer_write(timer, OMAP_TIMER_WAKEUP_EN_REG, value);\n}\n\nstatic inline unsigned int\n__omap_dm_timer_read_counter(struct dmtimer *timer)\n{\n\treturn dmtimer_read(timer, OMAP_TIMER_COUNTER_REG);\n}\n\nstatic inline void __omap_dm_timer_write_status(struct dmtimer *timer,\n\t\t\t\t\t\tunsigned int value)\n{\n\tdmtimer_write(timer, timer->irq_stat, value);\n}\n\nstatic void omap_timer_restore_context(struct dmtimer *timer)\n{\n\tdmtimer_write(timer, OMAP_TIMER_OCP_CFG_OFFSET, timer->context.ocp_cfg);\n\n\tdmtimer_write(timer, OMAP_TIMER_WAKEUP_EN_REG, timer->context.twer);\n\tdmtimer_write(timer, OMAP_TIMER_COUNTER_REG, timer->context.tcrr);\n\tdmtimer_write(timer, OMAP_TIMER_LOAD_REG, timer->context.tldr);\n\tdmtimer_write(timer, OMAP_TIMER_MATCH_REG, timer->context.tmar);\n\tdmtimer_write(timer, OMAP_TIMER_IF_CTRL_REG, timer->context.tsicr);\n\tdmtimer_write(timer, timer->irq_ena, timer->context.tier);\n\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, timer->context.tclr);\n}\n\nstatic void omap_timer_save_context(struct dmtimer *timer)\n{\n\ttimer->context.ocp_cfg = dmtimer_read(timer, OMAP_TIMER_OCP_CFG_OFFSET);\n\n\ttimer->context.tclr = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\ttimer->context.twer = dmtimer_read(timer, OMAP_TIMER_WAKEUP_EN_REG);\n\ttimer->context.tldr = dmtimer_read(timer, OMAP_TIMER_LOAD_REG);\n\ttimer->context.tmar = dmtimer_read(timer, OMAP_TIMER_MATCH_REG);\n\ttimer->context.tier = dmtimer_read(timer, timer->irq_ena);\n\ttimer->context.tsicr = dmtimer_read(timer, OMAP_TIMER_IF_CTRL_REG);\n}\n\nstatic int omap_timer_context_notifier(struct notifier_block *nb,\n\t\t\t\t       unsigned long cmd, void *v)\n{\n\tstruct dmtimer *timer;\n\n\ttimer = container_of(nb, struct dmtimer, nb);\n\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tif ((timer->capability & OMAP_TIMER_ALWON) ||\n\t\t    !atomic_read(&timer->enabled))\n\t\t\tbreak;\n\t\tomap_timer_save_context(timer);\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\t \n\t\tbreak;\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tif ((timer->capability & OMAP_TIMER_ALWON) ||\n\t\t    !atomic_read(&timer->enabled))\n\t\t\tbreak;\n\t\tomap_timer_restore_context(timer);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int omap_timer_fclk_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *clk_data = data;\n\tstruct dmtimer *timer = container_of(nb, struct dmtimer, fclk_nb);\n\n\tswitch (event) {\n\tcase POST_RATE_CHANGE:\n\t\ttimer->fclk_rate = clk_data->new_rate;\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic int omap_dm_timer_reset(struct dmtimer *timer)\n{\n\tu32 l, timeout = 100000;\n\n\tif (timer->revision != 1)\n\t\treturn -EINVAL;\n\n\tdmtimer_write(timer, OMAP_TIMER_IF_CTRL_REG, 0x06);\n\n\tdo {\n\t\tl = dmtimer_read(timer, OMAP_TIMER_V1_SYS_STAT_OFFSET);\n\t} while (!l && timeout--);\n\n\tif (!timeout) {\n\t\tdev_err(&timer->pdev->dev, \"Timer failed to reset\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tl = dmtimer_read(timer, OMAP_TIMER_OCP_CFG_OFFSET);\n\tl |= 0x2 << 0x3;\n\tdmtimer_write(timer, OMAP_TIMER_OCP_CFG_OFFSET, l);\n\n\ttimer->posted = 0;\n\n\treturn 0;\n}\n\n \nstatic struct dmtimer *to_dmtimer(struct omap_dm_timer *cookie)\n{\n\tif (!cookie)\n\t\treturn NULL;\n\n\treturn container_of(cookie, struct dmtimer, cookie);\n}\n\nstatic int omap_dm_timer_set_source(struct omap_dm_timer *cookie, int source)\n{\n\tint ret;\n\tconst char *parent_name;\n\tstruct clk *parent;\n\tstruct dmtimer_platform_data *pdata;\n\tstruct dmtimer *timer;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer) || IS_ERR(timer->fclk))\n\t\treturn -EINVAL;\n\n\tswitch (source) {\n\tcase OMAP_TIMER_SRC_SYS_CLK:\n\t\tparent_name = \"timer_sys_ck\";\n\t\tbreak;\n\tcase OMAP_TIMER_SRC_32_KHZ:\n\t\tparent_name = \"timer_32k_ck\";\n\t\tbreak;\n\tcase OMAP_TIMER_SRC_EXT_CLK:\n\t\tparent_name = \"timer_ext_ck\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpdata = timer->pdev->dev.platform_data;\n\n\t \n\tif (timer->omap1 && pdata && pdata->set_timer_src)\n\t\treturn pdata->set_timer_src(timer->pdev, source);\n\n#if defined(CONFIG_COMMON_CLK)\n\t \n\tif (clk_hw_get_num_parents(__clk_get_hw(timer->fclk)) < 2)\n\t\treturn 0;\n#endif\n\n\tparent = clk_get(&timer->pdev->dev, parent_name);\n\tif (IS_ERR(parent)) {\n\t\tpr_err(\"%s: %s not found\\n\", __func__, parent_name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_parent(timer->fclk, parent);\n\tif (ret < 0)\n\t\tpr_err(\"%s: failed to set %s as parent\\n\", __func__,\n\t\t\tparent_name);\n\n\tclk_put(parent);\n\n\treturn ret;\n}\n\nstatic void omap_dm_timer_enable(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer = to_dmtimer(cookie);\n\tstruct device *dev = &timer->pdev->dev;\n\tint rc;\n\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\tdev_err(dev, \"could not enable timer\\n\");\n}\n\nstatic void omap_dm_timer_disable(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer = to_dmtimer(cookie);\n\tstruct device *dev = &timer->pdev->dev;\n\n\tpm_runtime_put_sync(dev);\n}\n\nstatic int omap_dm_timer_prepare(struct dmtimer *timer)\n{\n\tstruct device *dev = &timer->pdev->dev;\n\tint rc;\n\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (timer->capability & OMAP_TIMER_NEEDS_RESET) {\n\t\trc = omap_dm_timer_reset(timer);\n\t\tif (rc) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t__omap_dm_timer_enable_posted(timer);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic inline u32 omap_dm_timer_reserved_systimer(int id)\n{\n\treturn (omap_reserved_systimers & (1 << (id - 1))) ? 1 : 0;\n}\n\nstatic struct dmtimer *_omap_dm_timer_request(int req_type, void *data)\n{\n\tstruct dmtimer *timer = NULL, *t;\n\tstruct device_node *np = NULL;\n\tunsigned long flags;\n\tu32 cap = 0;\n\tint id = 0;\n\n\tswitch (req_type) {\n\tcase REQUEST_BY_ID:\n\t\tid = *(int *)data;\n\t\tbreak;\n\tcase REQUEST_BY_CAP:\n\t\tcap = *(u32 *)data;\n\t\tbreak;\n\tcase REQUEST_BY_NODE:\n\t\tnp = (struct device_node *)data;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&dm_timer_lock, flags);\n\tlist_for_each_entry(t, &omap_timer_list, node) {\n\t\tif (t->reserved)\n\t\t\tcontinue;\n\n\t\tswitch (req_type) {\n\t\tcase REQUEST_BY_ID:\n\t\t\tif (id == t->pdev->id) {\n\t\t\t\ttimer = t;\n\t\t\t\ttimer->reserved = 1;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase REQUEST_BY_CAP:\n\t\t\tif (cap == (t->capability & cap)) {\n\t\t\t\t \n\t\t\t\tif (timer)\n\t\t\t\t\ttimer->reserved = 0;\n\t\t\t\ttimer = t;\n\t\t\t\ttimer->reserved = 1;\n\n\t\t\t\t \n\t\t\t\tif (t->capability == cap)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase REQUEST_BY_NODE:\n\t\t\tif (np == t->pdev->dev.of_node) {\n\t\t\t\ttimer = t;\n\t\t\t\ttimer->reserved = 1;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\ttimer = t;\n\t\t\ttimer->reserved = 1;\n\t\t\tgoto found;\n\t\t}\n\t}\nfound:\n\tspin_unlock_irqrestore(&dm_timer_lock, flags);\n\n\tif (timer && omap_dm_timer_prepare(timer)) {\n\t\ttimer->reserved = 0;\n\t\ttimer = NULL;\n\t}\n\n\tif (!timer)\n\t\tpr_debug(\"%s: timer request failed!\\n\", __func__);\n\n\treturn timer;\n}\n\nstatic struct omap_dm_timer *omap_dm_timer_request(void)\n{\n\tstruct dmtimer *timer;\n\n\ttimer = _omap_dm_timer_request(REQUEST_ANY, NULL);\n\tif (!timer)\n\t\treturn NULL;\n\n\treturn &timer->cookie;\n}\n\nstatic struct omap_dm_timer *omap_dm_timer_request_specific(int id)\n{\n\tstruct dmtimer *timer;\n\n\t \n\tif (of_have_populated_dt()) {\n\t\tpr_warn(\"%s: Please use omap_dm_timer_request_by_node()\\n\",\n\t\t\t__func__);\n\t\treturn NULL;\n\t}\n\n\ttimer = _omap_dm_timer_request(REQUEST_BY_ID, &id);\n\tif (!timer)\n\t\treturn NULL;\n\n\treturn &timer->cookie;\n}\n\n \nstatic struct omap_dm_timer *omap_dm_timer_request_by_node(struct device_node *np)\n{\n\tstruct dmtimer *timer;\n\n\tif (!np)\n\t\treturn NULL;\n\n\ttimer = _omap_dm_timer_request(REQUEST_BY_NODE, np);\n\tif (!timer)\n\t\treturn NULL;\n\n\treturn &timer->cookie;\n}\n\nstatic int omap_dm_timer_free(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tWARN_ON(!timer->reserved);\n\ttimer->reserved = 0;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, 0);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_get_irq(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer = to_dmtimer(cookie);\n\tif (timer)\n\t\treturn timer->irq;\n\treturn -EINVAL;\n}\n\n#if defined(CONFIG_ARCH_OMAP1)\n#include <linux/soc/ti/omap1-io.h>\n\nstatic struct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *cookie)\n{\n\treturn NULL;\n}\n\n \n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\n{\n\tint i = 0;\n\tstruct dmtimer *timer = NULL;\n\tunsigned long flags;\n\n\t \n\tif (!(inputmask & (1 << 1)))\n\t\treturn inputmask;\n\n\t \n\tspin_lock_irqsave(&dm_timer_lock, flags);\n\tlist_for_each_entry(timer, &omap_timer_list, node) {\n\t\tu32 l;\n\n\t\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\t\tif (l & OMAP_TIMER_CTRL_ST) {\n\t\t\tif (((omap_readl(MOD_CONF_CTRL_1) >> (i * 2)) & 0x03) == 0)\n\t\t\t\tinputmask &= ~(1 << 1);\n\t\t\telse\n\t\t\t\tinputmask &= ~(1 << 2);\n\t\t}\n\t\ti++;\n\t}\n\tspin_unlock_irqrestore(&dm_timer_lock, flags);\n\n\treturn inputmask;\n}\n\n#else\n\nstatic struct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer = to_dmtimer(cookie);\n\n\tif (timer && !IS_ERR(timer->fclk))\n\t\treturn timer->fclk;\n\treturn NULL;\n}\n\n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\n{\n\tBUG();\n\n\treturn 0;\n}\n\n#endif\n\nstatic int omap_dm_timer_start(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\tu32 l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\tif (!(l & OMAP_TIMER_CTRL_ST)) {\n\t\tl |= OMAP_TIMER_CTRL_ST;\n\t\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, l);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_stop(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\n\t__omap_dm_timer_stop(timer);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_set_load(struct omap_dm_timer *cookie,\n\t\t\t\t  unsigned int load)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tdmtimer_write(timer, OMAP_TIMER_LOAD_REG, load);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_set_match(struct omap_dm_timer *cookie, int enable,\n\t\t\t\t   unsigned int match)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\tu32 l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\tif (enable)\n\t\tl |= OMAP_TIMER_CTRL_CE;\n\telse\n\t\tl &= ~OMAP_TIMER_CTRL_CE;\n\tdmtimer_write(timer, OMAP_TIMER_MATCH_REG, match);\n\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, l);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_set_pwm(struct omap_dm_timer *cookie, int def_on,\n\t\t\t\t int toggle, int trigger, int autoreload)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\tu32 l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\tl &= ~(OMAP_TIMER_CTRL_GPOCFG | OMAP_TIMER_CTRL_SCPWM |\n\t       OMAP_TIMER_CTRL_PT | (0x03 << 10) | OMAP_TIMER_CTRL_AR);\n\tif (def_on)\n\t\tl |= OMAP_TIMER_CTRL_SCPWM;\n\tif (toggle)\n\t\tl |= OMAP_TIMER_CTRL_PT;\n\tl |= trigger << 10;\n\tif (autoreload)\n\t\tl |= OMAP_TIMER_CTRL_AR;\n\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, l);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_get_pwm_status(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\tu32 l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn l;\n}\n\nstatic int omap_dm_timer_set_prescaler(struct omap_dm_timer *cookie,\n\t\t\t\t       int prescaler)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\tu32 l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer) || prescaler < -1 || prescaler > 7)\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tl = dmtimer_read(timer, OMAP_TIMER_CTRL_REG);\n\tl &= ~(OMAP_TIMER_CTRL_PRE | (0x07 << 2));\n\tif (prescaler >= 0) {\n\t\tl |= OMAP_TIMER_CTRL_PRE;\n\t\tl |= prescaler << 2;\n\t}\n\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, l);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int omap_dm_timer_set_int_enable(struct omap_dm_timer *cookie,\n\t\t\t\t\tunsigned int value)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tint rc;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t__omap_dm_timer_int_enable(timer, value);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\n \nstatic int omap_dm_timer_set_int_disable(struct omap_dm_timer *cookie, u32 mask)\n{\n\tstruct dmtimer *timer;\n\tstruct device *dev;\n\tu32 l = mask;\n\tint rc;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer))\n\t\treturn -EINVAL;\n\n\tdev = &timer->pdev->dev;\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (timer->revision == 1)\n\t\tl = dmtimer_read(timer, timer->irq_ena) & ~mask;\n\n\tdmtimer_write(timer, timer->irq_dis, l);\n\tl = dmtimer_read(timer, OMAP_TIMER_WAKEUP_EN_REG) & ~mask;\n\tdmtimer_write(timer, OMAP_TIMER_WAKEUP_EN_REG, l);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic unsigned int omap_dm_timer_read_status(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\tunsigned int l;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer || !atomic_read(&timer->enabled))) {\n\t\tpr_err(\"%s: timer not available or enabled.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tl = dmtimer_read(timer, timer->irq_stat);\n\n\treturn l;\n}\n\nstatic int omap_dm_timer_write_status(struct omap_dm_timer *cookie, unsigned int value)\n{\n\tstruct dmtimer *timer;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer || !atomic_read(&timer->enabled)))\n\t\treturn -EINVAL;\n\n\t__omap_dm_timer_write_status(timer, value);\n\n\treturn 0;\n}\n\nstatic unsigned int omap_dm_timer_read_counter(struct omap_dm_timer *cookie)\n{\n\tstruct dmtimer *timer;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer || !atomic_read(&timer->enabled))) {\n\t\tpr_err(\"%s: timer not iavailable or enabled.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn __omap_dm_timer_read_counter(timer);\n}\n\nstatic int omap_dm_timer_write_counter(struct omap_dm_timer *cookie, unsigned int value)\n{\n\tstruct dmtimer *timer;\n\n\ttimer = to_dmtimer(cookie);\n\tif (unlikely(!timer || !atomic_read(&timer->enabled))) {\n\t\tpr_err(\"%s: timer not available or enabled.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdmtimer_write(timer, OMAP_TIMER_COUNTER_REG, value);\n\n\t \n\ttimer->context.tcrr = value;\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_dm_timer_runtime_suspend(struct device *dev)\n{\n\tstruct dmtimer *timer = dev_get_drvdata(dev);\n\n\tatomic_set(&timer->enabled, 0);\n\n\tif (timer->capability & OMAP_TIMER_ALWON || !timer->func_base)\n\t\treturn 0;\n\n\tomap_timer_save_context(timer);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_dm_timer_runtime_resume(struct device *dev)\n{\n\tstruct dmtimer *timer = dev_get_drvdata(dev);\n\n\tif (!(timer->capability & OMAP_TIMER_ALWON) && timer->func_base)\n\t\tomap_timer_restore_context(timer);\n\n\tatomic_set(&timer->enabled, 1);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_dm_timer_pm_ops = {\n\tSET_RUNTIME_PM_OPS(omap_dm_timer_runtime_suspend,\n\t\t\t   omap_dm_timer_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id omap_timer_match[];\n\n \nstatic int omap_dm_timer_probe(struct platform_device *pdev)\n{\n\tunsigned long flags;\n\tstruct dmtimer *timer;\n\tstruct device *dev = &pdev->dev;\n\tconst struct dmtimer_platform_data *pdata;\n\tint ret;\n\n\tpdata = of_device_get_match_data(dev);\n\tif (!pdata)\n\t\tpdata = dev_get_platdata(dev);\n\telse\n\t\tdev->platform_data = (void *)pdata;\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"%s: no platform data.\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\ttimer = devm_kzalloc(dev, sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn  -ENOMEM;\n\n\ttimer->irq = platform_get_irq(pdev, 0);\n\tif (timer->irq < 0)\n\t\treturn timer->irq;\n\n\ttimer->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(timer->io_base))\n\t\treturn PTR_ERR(timer->io_base);\n\n\tplatform_set_drvdata(pdev, timer);\n\n\tif (dev->of_node) {\n\t\tif (of_property_read_bool(dev->of_node, \"ti,timer-alwon\"))\n\t\t\ttimer->capability |= OMAP_TIMER_ALWON;\n\t\tif (of_property_read_bool(dev->of_node, \"ti,timer-dsp\"))\n\t\t\ttimer->capability |= OMAP_TIMER_HAS_DSP_IRQ;\n\t\tif (of_property_read_bool(dev->of_node, \"ti,timer-pwm\"))\n\t\t\ttimer->capability |= OMAP_TIMER_HAS_PWM;\n\t\tif (of_property_read_bool(dev->of_node, \"ti,timer-secure\"))\n\t\t\ttimer->capability |= OMAP_TIMER_SECURE;\n\t} else {\n\t\ttimer->id = pdev->id;\n\t\ttimer->capability = pdata->timer_capability;\n\t\ttimer->reserved = omap_dm_timer_reserved_systimer(timer->id);\n\t}\n\n\ttimer->omap1 = timer->capability & OMAP_TIMER_NEEDS_RESET;\n\n\t \n\tif (!timer->omap1) {\n\t\ttimer->fclk = devm_clk_get(dev, \"fck\");\n\t\tif (IS_ERR(timer->fclk))\n\t\t\treturn PTR_ERR(timer->fclk);\n\n\t\ttimer->fclk_nb.notifier_call = omap_timer_fclk_notifier;\n\t\tret = devm_clk_notifier_register(dev, timer->fclk,\n\t\t\t\t\t\t &timer->fclk_nb);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttimer->fclk_rate = clk_get_rate(timer->fclk);\n\t} else {\n\t\ttimer->fclk = ERR_PTR(-ENODEV);\n\t}\n\n\tif (!(timer->capability & OMAP_TIMER_ALWON)) {\n\t\ttimer->nb.notifier_call = omap_timer_context_notifier;\n\t\tcpu_pm_register_notifier(&timer->nb);\n\t}\n\n\ttimer->errata = pdata->timer_errata;\n\n\ttimer->pdev = pdev;\n\n\tpm_runtime_enable(dev);\n\n\tif (!timer->reserved) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: pm_runtime_get_sync failed!\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto err_disable;\n\t\t}\n\t\t__omap_dm_timer_init_regs(timer);\n\n\t\t \n\t\tdmtimer_write(timer, OMAP_TIMER_CTRL_REG, 0);\n\n\t\tpm_runtime_put(dev);\n\t}\n\n\t \n\tspin_lock_irqsave(&dm_timer_lock, flags);\n\tlist_add_tail(&timer->node, &omap_timer_list);\n\tspin_unlock_irqrestore(&dm_timer_lock, flags);\n\n\tdev_dbg(dev, \"Device Probed.\\n\");\n\n\treturn 0;\n\nerr_disable:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\n \nstatic void omap_dm_timer_remove(struct platform_device *pdev)\n{\n\tstruct dmtimer *timer;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&dm_timer_lock, flags);\n\tlist_for_each_entry(timer, &omap_timer_list, node)\n\t\tif (!strcmp(dev_name(&timer->pdev->dev),\n\t\t\t    dev_name(&pdev->dev))) {\n\t\t\tif (!(timer->capability & OMAP_TIMER_ALWON))\n\t\t\t\tcpu_pm_unregister_notifier(&timer->nb);\n\t\t\tlist_del(&timer->node);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_irqrestore(&dm_timer_lock, flags);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Unable to determine timer entry in list of drivers on remove\\n\");\n}\n\nstatic const struct omap_dm_timer_ops dmtimer_ops = {\n\t.request_by_node = omap_dm_timer_request_by_node,\n\t.request_specific = omap_dm_timer_request_specific,\n\t.request = omap_dm_timer_request,\n\t.set_source = omap_dm_timer_set_source,\n\t.get_irq = omap_dm_timer_get_irq,\n\t.set_int_enable = omap_dm_timer_set_int_enable,\n\t.set_int_disable = omap_dm_timer_set_int_disable,\n\t.free = omap_dm_timer_free,\n\t.enable = omap_dm_timer_enable,\n\t.disable = omap_dm_timer_disable,\n\t.get_fclk = omap_dm_timer_get_fclk,\n\t.start = omap_dm_timer_start,\n\t.stop = omap_dm_timer_stop,\n\t.set_load = omap_dm_timer_set_load,\n\t.set_match = omap_dm_timer_set_match,\n\t.set_pwm = omap_dm_timer_set_pwm,\n\t.get_pwm_status = omap_dm_timer_get_pwm_status,\n\t.set_prescaler = omap_dm_timer_set_prescaler,\n\t.read_counter = omap_dm_timer_read_counter,\n\t.write_counter = omap_dm_timer_write_counter,\n\t.read_status = omap_dm_timer_read_status,\n\t.write_status = omap_dm_timer_write_status,\n};\n\nstatic const struct dmtimer_platform_data omap3plus_pdata = {\n\t.timer_errata = OMAP_TIMER_ERRATA_I103_I767,\n\t.timer_ops = &dmtimer_ops,\n};\n\nstatic const struct dmtimer_platform_data am6_pdata = {\n\t.timer_ops = &dmtimer_ops,\n};\n\nstatic const struct of_device_id omap_timer_match[] = {\n\t{\n\t\t.compatible = \"ti,omap2420-timer\",\n\t},\n\t{\n\t\t.compatible = \"ti,omap3430-timer\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4430-timer\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap5430-timer\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am335x-timer\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am335x-timer-1ms\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,dm816-timer\",\n\t\t.data = &omap3plus_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am654-timer\",\n\t\t.data = &am6_pdata,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_timer_match);\n\nstatic struct platform_driver omap_dm_timer_driver = {\n\t.probe  = omap_dm_timer_probe,\n\t.remove_new = omap_dm_timer_remove,\n\t.driver = {\n\t\t.name   = \"omap_timer\",\n\t\t.of_match_table = omap_timer_match,\n\t\t.pm = &omap_dm_timer_pm_ops,\n\t},\n};\n\nmodule_platform_driver(omap_dm_timer_driver);\n\nMODULE_DESCRIPTION(\"OMAP Dual-Mode Timer Driver\");\nMODULE_AUTHOR(\"Texas Instruments Inc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}