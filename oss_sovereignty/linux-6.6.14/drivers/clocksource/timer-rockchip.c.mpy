{
  "module_name": "timer-rockchip.c",
  "hash_id": "93a0fd0d302d2af9033cac145d96df5c7a30415ae8ad1112dc6c43cfe2ed032b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-rockchip.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define TIMER_NAME \"rk_timer\"\n\n#define TIMER_LOAD_COUNT0\t0x00\n#define TIMER_LOAD_COUNT1\t0x04\n#define TIMER_CURRENT_VALUE0\t0x08\n#define TIMER_CURRENT_VALUE1\t0x0C\n#define TIMER_CONTROL_REG3288\t0x10\n#define TIMER_CONTROL_REG3399\t0x1c\n#define TIMER_INT_STATUS\t0x18\n\n#define TIMER_DISABLE\t\t0x0\n#define TIMER_ENABLE\t\t0x1\n#define TIMER_MODE_FREE_RUNNING\t\t\t(0 << 1)\n#define TIMER_MODE_USER_DEFINED_COUNT\t\t(1 << 1)\n#define TIMER_INT_UNMASK\t\t\t(1 << 2)\n\nstruct rk_timer {\n\tvoid __iomem *base;\n\tvoid __iomem *ctrl;\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\tu32 freq;\n\tint irq;\n};\n\nstruct rk_clkevt {\n\tstruct clock_event_device ce;\n\tstruct rk_timer timer;\n};\n\nstatic struct rk_clkevt *rk_clkevt;\nstatic struct rk_timer *rk_clksrc;\n\nstatic inline struct rk_timer *rk_timer(struct clock_event_device *ce)\n{\n\treturn &container_of(ce, struct rk_clkevt, ce)->timer;\n}\n\nstatic inline void rk_timer_disable(struct rk_timer *timer)\n{\n\twritel_relaxed(TIMER_DISABLE, timer->ctrl);\n}\n\nstatic inline void rk_timer_enable(struct rk_timer *timer, u32 flags)\n{\n\twritel_relaxed(TIMER_ENABLE | flags, timer->ctrl);\n}\n\nstatic void rk_timer_update_counter(unsigned long cycles,\n\t\t\t\t    struct rk_timer *timer)\n{\n\twritel_relaxed(cycles, timer->base + TIMER_LOAD_COUNT0);\n\twritel_relaxed(0, timer->base + TIMER_LOAD_COUNT1);\n}\n\nstatic void rk_timer_interrupt_clear(struct rk_timer *timer)\n{\n\twritel_relaxed(1, timer->base + TIMER_INT_STATUS);\n}\n\nstatic inline int rk_timer_set_next_event(unsigned long cycles,\n\t\t\t\t\t  struct clock_event_device *ce)\n{\n\tstruct rk_timer *timer = rk_timer(ce);\n\n\trk_timer_disable(timer);\n\trk_timer_update_counter(cycles, timer);\n\trk_timer_enable(timer, TIMER_MODE_USER_DEFINED_COUNT |\n\t\t\t       TIMER_INT_UNMASK);\n\treturn 0;\n}\n\nstatic int rk_timer_shutdown(struct clock_event_device *ce)\n{\n\tstruct rk_timer *timer = rk_timer(ce);\n\n\trk_timer_disable(timer);\n\treturn 0;\n}\n\nstatic int rk_timer_set_periodic(struct clock_event_device *ce)\n{\n\tstruct rk_timer *timer = rk_timer(ce);\n\n\trk_timer_disable(timer);\n\trk_timer_update_counter(timer->freq / HZ - 1, timer);\n\trk_timer_enable(timer, TIMER_MODE_FREE_RUNNING | TIMER_INT_UNMASK);\n\treturn 0;\n}\n\nstatic irqreturn_t rk_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *ce = dev_id;\n\tstruct rk_timer *timer = rk_timer(ce);\n\n\trk_timer_interrupt_clear(timer);\n\n\tif (clockevent_state_oneshot(ce))\n\t\trk_timer_disable(timer);\n\n\tce->event_handler(ce);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 notrace rk_timer_sched_read(void)\n{\n\treturn ~readl_relaxed(rk_clksrc->base + TIMER_CURRENT_VALUE0);\n}\n\nstatic int __init\nrk_timer_probe(struct rk_timer *timer, struct device_node *np)\n{\n\tstruct clk *timer_clk;\n\tstruct clk *pclk;\n\tint ret = -EINVAL, irq;\n\tu32 ctrl_reg = TIMER_CONTROL_REG3288;\n\n\ttimer->base = of_iomap(np, 0);\n\tif (!timer->base) {\n\t\tpr_err(\"Failed to get base address for '%s'\\n\", TIMER_NAME);\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_device_is_compatible(np, \"rockchip,rk3399-timer\"))\n\t\tctrl_reg = TIMER_CONTROL_REG3399;\n\n\ttimer->ctrl = timer->base + ctrl_reg;\n\n\tpclk = of_clk_get_by_name(np, \"pclk\");\n\tif (IS_ERR(pclk)) {\n\t\tret = PTR_ERR(pclk);\n\t\tpr_err(\"Failed to get pclk for '%s'\\n\", TIMER_NAME);\n\t\tgoto out_unmap;\n\t}\n\n\tret = clk_prepare_enable(pclk);\n\tif (ret) {\n\t\tpr_err(\"Failed to enable pclk for '%s'\\n\", TIMER_NAME);\n\t\tgoto out_unmap;\n\t}\n\ttimer->pclk = pclk;\n\n\ttimer_clk = of_clk_get_by_name(np, \"timer\");\n\tif (IS_ERR(timer_clk)) {\n\t\tret = PTR_ERR(timer_clk);\n\t\tpr_err(\"Failed to get timer clock for '%s'\\n\", TIMER_NAME);\n\t\tgoto out_timer_clk;\n\t}\n\n\tret = clk_prepare_enable(timer_clk);\n\tif (ret) {\n\t\tpr_err(\"Failed to enable timer clock\\n\");\n\t\tgoto out_timer_clk;\n\t}\n\ttimer->clk = timer_clk;\n\n\ttimer->freq = clk_get_rate(timer_clk);\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"Failed to map interrupts for '%s'\\n\", TIMER_NAME);\n\t\tgoto out_irq;\n\t}\n\ttimer->irq = irq;\n\n\trk_timer_interrupt_clear(timer);\n\trk_timer_disable(timer);\n\treturn 0;\n\nout_irq:\n\tclk_disable_unprepare(timer_clk);\nout_timer_clk:\n\tclk_disable_unprepare(pclk);\nout_unmap:\n\tiounmap(timer->base);\n\n\treturn ret;\n}\n\nstatic void __init rk_timer_cleanup(struct rk_timer *timer)\n{\n\tclk_disable_unprepare(timer->clk);\n\tclk_disable_unprepare(timer->pclk);\n\tiounmap(timer->base);\n}\n\nstatic int __init rk_clkevt_init(struct device_node *np)\n{\n\tstruct clock_event_device *ce;\n\tint ret = -EINVAL;\n\n\trk_clkevt = kzalloc(sizeof(struct rk_clkevt), GFP_KERNEL);\n\tif (!rk_clkevt) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = rk_timer_probe(&rk_clkevt->timer, np);\n\tif (ret)\n\t\tgoto out_probe;\n\n\tce = &rk_clkevt->ce;\n\tce->name = TIMER_NAME;\n\tce->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\n\t\t       CLOCK_EVT_FEAT_DYNIRQ;\n\tce->set_next_event = rk_timer_set_next_event;\n\tce->set_state_shutdown = rk_timer_shutdown;\n\tce->set_state_periodic = rk_timer_set_periodic;\n\tce->irq = rk_clkevt->timer.irq;\n\tce->cpumask = cpu_possible_mask;\n\tce->rating = 250;\n\n\tret = request_irq(rk_clkevt->timer.irq, rk_timer_interrupt, IRQF_TIMER,\n\t\t\t  TIMER_NAME, ce);\n\tif (ret) {\n\t\tpr_err(\"Failed to initialize '%s': %d\\n\",\n\t\t\tTIMER_NAME, ret);\n\t\tgoto out_irq;\n\t}\n\n\tclockevents_config_and_register(&rk_clkevt->ce,\n\t\t\t\t\trk_clkevt->timer.freq, 1, UINT_MAX);\n\treturn 0;\n\nout_irq:\n\trk_timer_cleanup(&rk_clkevt->timer);\nout_probe:\n\tkfree(rk_clkevt);\nout:\n\t \n\trk_clkevt = ERR_PTR(ret);\n\treturn ret;\n}\n\nstatic int __init rk_clksrc_init(struct device_node *np)\n{\n\tint ret = -EINVAL;\n\n\trk_clksrc = kzalloc(sizeof(struct rk_timer), GFP_KERNEL);\n\tif (!rk_clksrc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = rk_timer_probe(rk_clksrc, np);\n\tif (ret)\n\t\tgoto out_probe;\n\n\trk_timer_update_counter(UINT_MAX, rk_clksrc);\n\trk_timer_enable(rk_clksrc, 0);\n\n\tret = clocksource_mmio_init(rk_clksrc->base + TIMER_CURRENT_VALUE0,\n\t\tTIMER_NAME, rk_clksrc->freq, 250, 32,\n\t\tclocksource_mmio_readl_down);\n\tif (ret) {\n\t\tpr_err(\"Failed to register clocksource\\n\");\n\t\tgoto out_clocksource;\n\t}\n\n\tsched_clock_register(rk_timer_sched_read, 32, rk_clksrc->freq);\n\treturn 0;\n\nout_clocksource:\n\trk_timer_cleanup(rk_clksrc);\nout_probe:\n\tkfree(rk_clksrc);\nout:\n\t \n\trk_clksrc = ERR_PTR(ret);\n\treturn ret;\n}\n\nstatic int __init rk_timer_init(struct device_node *np)\n{\n\tif (!rk_clkevt)\n\t\treturn rk_clkevt_init(np);\n\n\tif (!rk_clksrc)\n\t\treturn rk_clksrc_init(np);\n\n\tpr_err(\"Too many timer definitions for '%s'\\n\", TIMER_NAME);\n\treturn -EINVAL;\n}\n\nTIMER_OF_DECLARE(rk3288_timer, \"rockchip,rk3288-timer\", rk_timer_init);\nTIMER_OF_DECLARE(rk3399_timer, \"rockchip,rk3399-timer\", rk_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}