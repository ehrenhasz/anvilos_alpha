{
  "module_name": "timer-imx-sysctr.c",
  "hash_id": "bb2f00ab8286d23f0b11cbf779f5d86621842674742d24d47c9a669069f0cb9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-imx-sysctr.c",
  "human_readable_source": "\n\n\n\n#include <linux/interrupt.h>\n#include <linux/clockchips.h>\n\n#include \"timer-of.h\"\n\n#define CMP_OFFSET\t0x10000\n\n#define CNTCV_LO\t0x8\n#define CNTCV_HI\t0xc\n#define CMPCV_LO\t(CMP_OFFSET + 0x20)\n#define CMPCV_HI\t(CMP_OFFSET + 0x24)\n#define CMPCR\t\t(CMP_OFFSET + 0x2c)\n\n#define SYS_CTR_EN\t\t0x1\n#define SYS_CTR_IRQ_MASK\t0x2\n\n#define SYS_CTR_CLK_DIV\t\t0x3\n\nstatic void __iomem *sys_ctr_base __ro_after_init;\nstatic u32 cmpcr __ro_after_init;\n\nstatic void sysctr_timer_enable(bool enable)\n{\n\twritel(enable ? cmpcr | SYS_CTR_EN : cmpcr, sys_ctr_base + CMPCR);\n}\n\nstatic void sysctr_irq_acknowledge(void)\n{\n\t \n\tsysctr_timer_enable(false);\n}\n\nstatic inline u64 sysctr_read_counter(void)\n{\n\tu32 cnt_hi, tmp_hi, cnt_lo;\n\n\tdo {\n\t\tcnt_hi = readl_relaxed(sys_ctr_base + CNTCV_HI);\n\t\tcnt_lo = readl_relaxed(sys_ctr_base + CNTCV_LO);\n\t\ttmp_hi = readl_relaxed(sys_ctr_base + CNTCV_HI);\n\t} while (tmp_hi != cnt_hi);\n\n\treturn  ((u64) cnt_hi << 32) | cnt_lo;\n}\n\nstatic int sysctr_set_next_event(unsigned long delta,\n\t\t\t\t struct clock_event_device *evt)\n{\n\tu32 cmp_hi, cmp_lo;\n\tu64 next;\n\n\tsysctr_timer_enable(false);\n\n\tnext = sysctr_read_counter();\n\n\tnext += delta;\n\n\tcmp_hi = (next >> 32) & 0x00fffff;\n\tcmp_lo = next & 0xffffffff;\n\n\twritel_relaxed(cmp_hi, sys_ctr_base + CMPCV_HI);\n\twritel_relaxed(cmp_lo, sys_ctr_base + CMPCV_LO);\n\n\tsysctr_timer_enable(true);\n\n\treturn 0;\n}\n\nstatic int sysctr_set_state_oneshot(struct clock_event_device *evt)\n{\n\treturn 0;\n}\n\nstatic int sysctr_set_state_shutdown(struct clock_event_device *evt)\n{\n\tsysctr_timer_enable(false);\n\n\treturn 0;\n}\n\nstatic irqreturn_t sysctr_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tsysctr_irq_acknowledge();\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct timer_of to_sysctr = {\n\t.flags = TIMER_OF_IRQ | TIMER_OF_CLOCK | TIMER_OF_BASE,\n\t.clkevt = {\n\t\t.name\t\t\t= \"i.MX system counter timer\",\n\t\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t\t\tCLOCK_EVT_FEAT_DYNIRQ,\n\t\t.set_state_oneshot\t= sysctr_set_state_oneshot,\n\t\t.set_next_event\t\t= sysctr_set_next_event,\n\t\t.set_state_shutdown\t= sysctr_set_state_shutdown,\n\t\t.rating\t\t\t= 200,\n\t},\n\t.of_irq = {\n\t\t.handler\t\t= sysctr_timer_interrupt,\n\t\t.flags\t\t\t= IRQF_TIMER,\n\t},\n\t.of_clk = {\n\t\t.name = \"per\",\n\t},\n};\n\nstatic void __init sysctr_clockevent_init(void)\n{\n\tto_sysctr.clkevt.cpumask = cpu_possible_mask;\n\n\tclockevents_config_and_register(&to_sysctr.clkevt,\n\t\t\t\t\ttimer_of_rate(&to_sysctr),\n\t\t\t\t\t0xff, 0x7fffffff);\n}\n\nstatic int __init sysctr_timer_init(struct device_node *np)\n{\n\tint ret = 0;\n\n\tret = timer_of_init(np, &to_sysctr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!of_property_read_bool(np, \"nxp,no-divider\")) {\n\t\t \n\t\tto_sysctr.of_clk.rate /= SYS_CTR_CLK_DIV;\n\t}\n\n\tsys_ctr_base = timer_of_base(&to_sysctr);\n\tcmpcr = readl(sys_ctr_base + CMPCR);\n\tcmpcr &= ~SYS_CTR_EN;\n\n\tsysctr_clockevent_init();\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(sysctr_timer, \"nxp,sysctr-timer\", sysctr_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}