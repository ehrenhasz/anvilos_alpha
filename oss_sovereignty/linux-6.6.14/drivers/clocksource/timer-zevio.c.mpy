{
  "module_name": "timer-zevio.c",
  "hash_id": "2a3a12296acbe1ff709129963d3845f6d380b0b7007464ab61c5a4ab51a4d96f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-zevio.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/cpumask.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#define IO_CURRENT_VAL\t0x00\n#define IO_DIVIDER\t0x04\n#define IO_CONTROL\t0x08\n\n#define IO_TIMER1\t0x00\n#define IO_TIMER2\t0x0C\n\n#define IO_MATCH_BEGIN\t0x18\n#define IO_MATCH(x)\t(IO_MATCH_BEGIN + ((x) << 2))\n\n#define IO_INTR_STS\t0x00\n#define IO_INTR_ACK\t0x00\n#define IO_INTR_MSK\t0x04\n\n#define CNTL_STOP_TIMER\t(1 << 4)\n#define CNTL_RUN_TIMER\t(0 << 4)\n\n#define CNTL_INC\t(1 << 3)\n#define CNTL_DEC\t(0 << 3)\n\n#define CNTL_TOZERO\t0\n#define CNTL_MATCH(x)\t((x) + 1)\n#define CNTL_FOREVER\t7\n\n \n#define TIMER_MATCH\t0\n\n#define TIMER_INTR_MSK\t(1 << (TIMER_MATCH))\n#define TIMER_INTR_ALL\t0x3F\n\nstruct zevio_timer {\n\tvoid __iomem *base;\n\tvoid __iomem *timer1, *timer2;\n\tvoid __iomem *interrupt_regs;\n\n\tstruct clk *clk;\n\tstruct clock_event_device clkevt;\n\n\tchar clocksource_name[64];\n\tchar clockevent_name[64];\n};\n\nstatic int zevio_timer_set_event(unsigned long delta,\n\t\t\t\t struct clock_event_device *dev)\n{\n\tstruct zevio_timer *timer = container_of(dev, struct zevio_timer,\n\t\t\t\t\t\t clkevt);\n\n\twritel(delta, timer->timer1 + IO_CURRENT_VAL);\n\twritel(CNTL_RUN_TIMER | CNTL_DEC | CNTL_MATCH(TIMER_MATCH),\n\t\t\ttimer->timer1 + IO_CONTROL);\n\n\treturn 0;\n}\n\nstatic int zevio_timer_shutdown(struct clock_event_device *dev)\n{\n\tstruct zevio_timer *timer = container_of(dev, struct zevio_timer,\n\t\t\t\t\t\t clkevt);\n\n\t \n\twritel(0, timer->interrupt_regs + IO_INTR_MSK);\n\twritel(TIMER_INTR_ALL, timer->interrupt_regs + IO_INTR_ACK);\n\t \n\twritel(CNTL_STOP_TIMER, timer->timer1 + IO_CONTROL);\n\treturn 0;\n}\n\nstatic int zevio_timer_set_oneshot(struct clock_event_device *dev)\n{\n\tstruct zevio_timer *timer = container_of(dev, struct zevio_timer,\n\t\t\t\t\t\t clkevt);\n\n\t \n\twritel(TIMER_INTR_MSK, timer->interrupt_regs + IO_INTR_MSK);\n\twritel(TIMER_INTR_ALL, timer->interrupt_regs + IO_INTR_ACK);\n\treturn 0;\n}\n\nstatic irqreturn_t zevio_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct zevio_timer *timer = dev_id;\n\tu32 intr;\n\n\tintr = readl(timer->interrupt_regs + IO_INTR_ACK);\n\tif (!(intr & TIMER_INTR_MSK))\n\t\treturn IRQ_NONE;\n\n\twritel(TIMER_INTR_MSK, timer->interrupt_regs + IO_INTR_ACK);\n\twritel(CNTL_STOP_TIMER, timer->timer1 + IO_CONTROL);\n\n\tif (timer->clkevt.event_handler)\n\t\ttimer->clkevt.event_handler(&timer->clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init zevio_timer_add(struct device_node *node)\n{\n\tstruct zevio_timer *timer;\n\tstruct resource res;\n\tint irqnr, ret;\n\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer)\n\t\treturn -ENOMEM;\n\n\ttimer->base = of_iomap(node, 0);\n\tif (!timer->base) {\n\t\tret = -EINVAL;\n\t\tgoto error_free;\n\t}\n\ttimer->timer1 = timer->base + IO_TIMER1;\n\ttimer->timer2 = timer->base + IO_TIMER2;\n\n\ttimer->clk = of_clk_get(node, 0);\n\tif (IS_ERR(timer->clk)) {\n\t\tret = PTR_ERR(timer->clk);\n\t\tpr_err(\"Timer clock not found! (error %d)\\n\", ret);\n\t\tgoto error_unmap;\n\t}\n\n\ttimer->interrupt_regs = of_iomap(node, 1);\n\tirqnr = irq_of_parse_and_map(node, 0);\n\n\tof_address_to_resource(node, 0, &res);\n\tscnprintf(timer->clocksource_name, sizeof(timer->clocksource_name),\n\t\t\t\"%llx.%pOFn_clocksource\",\n\t\t\t(unsigned long long)res.start, node);\n\n\tscnprintf(timer->clockevent_name, sizeof(timer->clockevent_name),\n\t\t\t\"%llx.%pOFn_clockevent\",\n\t\t\t(unsigned long long)res.start, node);\n\n\tif (timer->interrupt_regs && irqnr) {\n\t\ttimer->clkevt.name\t\t= timer->clockevent_name;\n\t\ttimer->clkevt.set_next_event\t= zevio_timer_set_event;\n\t\ttimer->clkevt.set_state_shutdown = zevio_timer_shutdown;\n\t\ttimer->clkevt.set_state_oneshot = zevio_timer_set_oneshot;\n\t\ttimer->clkevt.tick_resume\t= zevio_timer_set_oneshot;\n\t\ttimer->clkevt.rating\t\t= 200;\n\t\ttimer->clkevt.cpumask\t\t= cpu_possible_mask;\n\t\ttimer->clkevt.features\t\t= CLOCK_EVT_FEAT_ONESHOT;\n\t\ttimer->clkevt.irq\t\t= irqnr;\n\n\t\twritel(CNTL_STOP_TIMER, timer->timer1 + IO_CONTROL);\n\t\twritel(0, timer->timer1 + IO_DIVIDER);\n\n\t\t \n\t\twritel(0, timer->interrupt_regs + IO_INTR_MSK);\n\t\twritel(TIMER_INTR_ALL, timer->interrupt_regs + IO_INTR_ACK);\n\n\t\t \n\t\twritel(0, timer->base + IO_MATCH(TIMER_MATCH));\n\n\t\tif (request_irq(irqnr, zevio_timer_interrupt,\n\t\t\t\tIRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t\ttimer->clockevent_name, timer)) {\n\t\t\tpr_err(\"%s: request_irq() failed\\n\",\n\t\t\t       timer->clockevent_name);\n\t\t}\n\n\t\tclockevents_config_and_register(&timer->clkevt,\n\t\t\t\tclk_get_rate(timer->clk), 0x0001, 0xffff);\n\t\tpr_info(\"Added %s as clockevent\\n\", timer->clockevent_name);\n\t}\n\n\twritel(CNTL_STOP_TIMER, timer->timer2 + IO_CONTROL);\n\twritel(0, timer->timer2 + IO_CURRENT_VAL);\n\twritel(0, timer->timer2 + IO_DIVIDER);\n\twritel(CNTL_RUN_TIMER | CNTL_FOREVER | CNTL_INC,\n\t\t\ttimer->timer2 + IO_CONTROL);\n\n\tclocksource_mmio_init(timer->timer2 + IO_CURRENT_VAL,\n\t\t\ttimer->clocksource_name,\n\t\t\tclk_get_rate(timer->clk),\n\t\t\t200, 16,\n\t\t\tclocksource_mmio_readw_up);\n\n\tpr_info(\"Added %s as clocksource\\n\", timer->clocksource_name);\n\n\treturn 0;\nerror_unmap:\n\tiounmap(timer->base);\nerror_free:\n\tkfree(timer);\n\treturn ret;\n}\n\nstatic int __init zevio_timer_init(struct device_node *node)\n{\n\treturn zevio_timer_add(node);\n}\n\nTIMER_OF_DECLARE(zevio_timer, \"lsi,zevio-timer\", zevio_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}