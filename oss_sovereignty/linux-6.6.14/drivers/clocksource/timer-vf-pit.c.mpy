{
  "module_name": "timer-vf-pit.c",
  "hash_id": "619d78b98f4709a15b95b6ec3d538fb5a70323d0f28d4cab4f732d1ba070239e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-vf-pit.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/clockchips.h>\n#include <linux/clk.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n \n#define PITMCR\t\t0x00\n#define PIT0_OFFSET\t0x100\n#define PITn_OFFSET(n)\t(PIT0_OFFSET + 0x10 * (n))\n#define PITLDVAL\t0x00\n#define PITCVAL\t\t0x04\n#define PITTCTRL\t0x08\n#define PITTFLG\t\t0x0c\n\n#define PITMCR_MDIS\t(0x1 << 1)\n\n#define PITTCTRL_TEN\t(0x1 << 0)\n#define PITTCTRL_TIE\t(0x1 << 1)\n#define PITCTRL_CHN\t(0x1 << 2)\n\n#define PITTFLG_TIF\t0x1\n\nstatic void __iomem *clksrc_base;\nstatic void __iomem *clkevt_base;\nstatic unsigned long cycle_per_jiffy;\n\nstatic inline void pit_timer_enable(void)\n{\n\t__raw_writel(PITTCTRL_TEN | PITTCTRL_TIE, clkevt_base + PITTCTRL);\n}\n\nstatic inline void pit_timer_disable(void)\n{\n\t__raw_writel(0, clkevt_base + PITTCTRL);\n}\n\nstatic inline void pit_irq_acknowledge(void)\n{\n\t__raw_writel(PITTFLG_TIF, clkevt_base + PITTFLG);\n}\n\nstatic u64 notrace pit_read_sched_clock(void)\n{\n\treturn ~__raw_readl(clksrc_base + PITCVAL);\n}\n\nstatic int __init pit_clocksource_init(unsigned long rate)\n{\n\t \n\t__raw_writel(0, clksrc_base + PITTCTRL);\n\t__raw_writel(~0UL, clksrc_base + PITLDVAL);\n\t__raw_writel(PITTCTRL_TEN, clksrc_base + PITTCTRL);\n\n\tsched_clock_register(pit_read_sched_clock, 32, rate);\n\treturn clocksource_mmio_init(clksrc_base + PITCVAL, \"vf-pit\", rate,\n\t\t\t300, 32, clocksource_mmio_readl_down);\n}\n\nstatic int pit_set_next_event(unsigned long delta,\n\t\t\t\tstruct clock_event_device *unused)\n{\n\t \n\tpit_timer_disable();\n\t__raw_writel(delta - 1, clkevt_base + PITLDVAL);\n\tpit_timer_enable();\n\n\treturn 0;\n}\n\nstatic int pit_shutdown(struct clock_event_device *evt)\n{\n\tpit_timer_disable();\n\treturn 0;\n}\n\nstatic int pit_set_periodic(struct clock_event_device *evt)\n{\n\tpit_set_next_event(cycle_per_jiffy, evt);\n\treturn 0;\n}\n\nstatic irqreturn_t pit_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tpit_irq_acknowledge();\n\n\t \n\tif (likely(clockevent_state_oneshot(evt)))\n\t\tpit_timer_disable();\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct clock_event_device clockevent_pit = {\n\t.name\t\t= \"VF pit timer\",\n\t.features\t= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_shutdown = pit_shutdown,\n\t.set_state_periodic = pit_set_periodic,\n\t.set_next_event\t= pit_set_next_event,\n\t.rating\t\t= 300,\n};\n\nstatic int __init pit_clockevent_init(unsigned long rate, int irq)\n{\n\t__raw_writel(0, clkevt_base + PITTCTRL);\n\t__raw_writel(PITTFLG_TIF, clkevt_base + PITTFLG);\n\n\tBUG_ON(request_irq(irq, pit_timer_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t   \"VF pit timer\", &clockevent_pit));\n\n\tclockevent_pit.cpumask = cpumask_of(0);\n\tclockevent_pit.irq = irq;\n\t \n\tclockevents_config_and_register(&clockevent_pit, rate, 2, 0xffffffff);\n\n\treturn 0;\n}\n\nstatic int __init pit_timer_init(struct device_node *np)\n{\n\tstruct clk *pit_clk;\n\tvoid __iomem *timer_base;\n\tunsigned long clk_rate;\n\tint irq, ret;\n\n\ttimer_base = of_iomap(np, 0);\n\tif (!timer_base) {\n\t\tpr_err(\"Failed to iomap\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tclksrc_base = timer_base + PITn_OFFSET(2);\n\tclkevt_base = timer_base + PITn_OFFSET(3);\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0)\n\t\treturn -EINVAL;\n\n\tpit_clk = of_clk_get(np, 0);\n\tif (IS_ERR(pit_clk))\n\t\treturn PTR_ERR(pit_clk);\n\n\tret = clk_prepare_enable(pit_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_rate = clk_get_rate(pit_clk);\n\tcycle_per_jiffy = clk_rate / (HZ);\n\n\t \n\t__raw_writel(~PITMCR_MDIS, timer_base + PITMCR);\n\n\tret = pit_clocksource_init(clk_rate);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pit_clockevent_init(clk_rate, irq);\n}\nTIMER_OF_DECLARE(vf610, \"fsl,vf610-pit\", pit_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}