{
  "module_name": "samsung_pwm_timer.c",
  "hash_id": "6b52f62eef8e46de28eb5db779b8c9d1e19109eb137da7f406318b9465bf14d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/samsung_pwm_timer.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sched_clock.h>\n\n#include <clocksource/samsung_pwm.h>\n\n \n\n#define REG_TCFG0\t\t\t0x00\n#define REG_TCFG1\t\t\t0x04\n#define REG_TCON\t\t\t0x08\n#define REG_TINT_CSTAT\t\t\t0x44\n\n#define REG_TCNTB(chan)\t\t\t(0x0c + 12 * (chan))\n#define REG_TCMPB(chan)\t\t\t(0x10 + 12 * (chan))\n\n#define TCFG0_PRESCALER_MASK\t\t0xff\n#define TCFG0_PRESCALER1_SHIFT\t\t8\n\n#define TCFG1_SHIFT(x)\t\t\t((x) * 4)\n#define TCFG1_MUX_MASK\t\t\t0xf\n\n \n#define TCON_START(chan)\t\t(1 << (4 * (chan) + 0))\n#define TCON_MANUALUPDATE(chan)\t\t(1 << (4 * (chan) + 1))\n#define TCON_INVERT(chan)\t\t(1 << (4 * (chan) + 2))\n#define _TCON_AUTORELOAD(chan)\t\t(1 << (4 * (chan) + 3))\n#define _TCON_AUTORELOAD4(chan)\t\t(1 << (4 * (chan) + 2))\n#define TCON_AUTORELOAD(chan)\t\t\\\n\t((chan < 5) ? _TCON_AUTORELOAD(chan) : _TCON_AUTORELOAD4(chan))\n\nDEFINE_SPINLOCK(samsung_pwm_lock);\nEXPORT_SYMBOL(samsung_pwm_lock);\n\nstruct samsung_pwm_clocksource {\n\tvoid __iomem *base;\n\tconst void __iomem *source_reg;\n\tunsigned int irq[SAMSUNG_PWM_NUM];\n\tstruct samsung_pwm_variant variant;\n\n\tstruct clk *timerclk;\n\n\tunsigned int event_id;\n\tunsigned int source_id;\n\tunsigned int tcnt_max;\n\tunsigned int tscaler_div;\n\tunsigned int tdiv;\n\n\tunsigned long clock_count_per_tick;\n};\n\nstatic struct samsung_pwm_clocksource pwm;\n\nstatic void samsung_timer_set_prescale(unsigned int channel, u16 prescale)\n{\n\tunsigned long flags;\n\tu8 shift = 0;\n\tu32 reg;\n\n\tif (channel >= 2)\n\t\tshift = TCFG0_PRESCALER1_SHIFT;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\treg = readl(pwm.base + REG_TCFG0);\n\treg &= ~(TCFG0_PRESCALER_MASK << shift);\n\treg |= (prescale - 1) << shift;\n\twritel(reg, pwm.base + REG_TCFG0);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic void samsung_timer_set_divisor(unsigned int channel, u8 divisor)\n{\n\tu8 shift = TCFG1_SHIFT(channel);\n\tunsigned long flags;\n\tu32 reg;\n\tu8 bits;\n\n\tbits = (fls(divisor) - 1) - pwm.variant.div_base;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\treg = readl(pwm.base + REG_TCFG1);\n\treg &= ~(TCFG1_MUX_MASK << shift);\n\treg |= bits << shift;\n\twritel(reg, pwm.base + REG_TCFG1);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic void samsung_time_stop(unsigned int channel)\n{\n\tunsigned long tcon;\n\tunsigned long flags;\n\n\tif (channel > 0)\n\t\t++channel;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl_relaxed(pwm.base + REG_TCON);\n\ttcon &= ~TCON_START(channel);\n\twritel_relaxed(tcon, pwm.base + REG_TCON);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic void samsung_time_setup(unsigned int channel, unsigned long tcnt)\n{\n\tunsigned long tcon;\n\tunsigned long flags;\n\tunsigned int tcon_chan = channel;\n\n\tif (tcon_chan > 0)\n\t\t++tcon_chan;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl_relaxed(pwm.base + REG_TCON);\n\n\ttcon &= ~(TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan));\n\ttcon |= TCON_MANUALUPDATE(tcon_chan);\n\n\twritel_relaxed(tcnt, pwm.base + REG_TCNTB(channel));\n\twritel_relaxed(tcnt, pwm.base + REG_TCMPB(channel));\n\twritel_relaxed(tcon, pwm.base + REG_TCON);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic void samsung_time_start(unsigned int channel, bool periodic)\n{\n\tunsigned long tcon;\n\tunsigned long flags;\n\n\tif (channel > 0)\n\t\t++channel;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl_relaxed(pwm.base + REG_TCON);\n\n\ttcon &= ~TCON_MANUALUPDATE(channel);\n\ttcon |= TCON_START(channel);\n\n\tif (periodic)\n\t\ttcon |= TCON_AUTORELOAD(channel);\n\telse\n\t\ttcon &= ~TCON_AUTORELOAD(channel);\n\n\twritel_relaxed(tcon, pwm.base + REG_TCON);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic int samsung_set_next_event(unsigned long cycles,\n\t\t\t\t  struct clock_event_device *evt)\n{\n\t \n\tif (!cycles)\n\t\tcycles = 1;\n\n\tsamsung_time_setup(pwm.event_id, cycles);\n\tsamsung_time_start(pwm.event_id, false);\n\n\treturn 0;\n}\n\nstatic int samsung_shutdown(struct clock_event_device *evt)\n{\n\tsamsung_time_stop(pwm.event_id);\n\treturn 0;\n}\n\nstatic int samsung_set_periodic(struct clock_event_device *evt)\n{\n\tsamsung_time_stop(pwm.event_id);\n\tsamsung_time_setup(pwm.event_id, pwm.clock_count_per_tick - 1);\n\tsamsung_time_start(pwm.event_id, true);\n\treturn 0;\n}\n\nstatic void samsung_clockevent_resume(struct clock_event_device *cev)\n{\n\tsamsung_timer_set_prescale(pwm.event_id, pwm.tscaler_div);\n\tsamsung_timer_set_divisor(pwm.event_id, pwm.tdiv);\n\n\tif (pwm.variant.has_tint_cstat) {\n\t\tu32 mask = (1 << pwm.event_id);\n\n\t\twritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\n\t}\n}\n\nstatic struct clock_event_device time_event_device = {\n\t.name\t\t\t= \"samsung_event_timer\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 200,\n\t.set_next_event\t\t= samsung_set_next_event,\n\t.set_state_shutdown\t= samsung_shutdown,\n\t.set_state_periodic\t= samsung_set_periodic,\n\t.set_state_oneshot\t= samsung_shutdown,\n\t.tick_resume\t\t= samsung_shutdown,\n\t.resume\t\t\t= samsung_clockevent_resume,\n};\n\nstatic irqreturn_t samsung_clock_event_isr(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tif (pwm.variant.has_tint_cstat) {\n\t\tu32 mask = (1 << pwm.event_id);\n\n\t\twritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\n\t}\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void __init samsung_clockevent_init(void)\n{\n\tunsigned long pclk;\n\tunsigned long clock_rate;\n\tunsigned int irq_number;\n\n\tpclk = clk_get_rate(pwm.timerclk);\n\n\tsamsung_timer_set_prescale(pwm.event_id, pwm.tscaler_div);\n\tsamsung_timer_set_divisor(pwm.event_id, pwm.tdiv);\n\n\tclock_rate = pclk / (pwm.tscaler_div * pwm.tdiv);\n\tpwm.clock_count_per_tick = clock_rate / HZ;\n\n\ttime_event_device.cpumask = cpumask_of(0);\n\tclockevents_config_and_register(&time_event_device,\n\t\t\t\t\tclock_rate, 1, pwm.tcnt_max);\n\n\tirq_number = pwm.irq[pwm.event_id];\n\tif (request_irq(irq_number, samsung_clock_event_isr,\n\t\t\tIRQF_TIMER | IRQF_IRQPOLL, \"samsung_time_irq\",\n\t\t\t&time_event_device))\n\t\tpr_err(\"%s: request_irq() failed\\n\", \"samsung_time_irq\");\n\n\tif (pwm.variant.has_tint_cstat) {\n\t\tu32 mask = (1 << pwm.event_id);\n\n\t\twritel(mask | (mask << 5), pwm.base + REG_TINT_CSTAT);\n\t}\n}\n\nstatic void samsung_clocksource_suspend(struct clocksource *cs)\n{\n\tsamsung_time_stop(pwm.source_id);\n}\n\nstatic void samsung_clocksource_resume(struct clocksource *cs)\n{\n\tsamsung_timer_set_prescale(pwm.source_id, pwm.tscaler_div);\n\tsamsung_timer_set_divisor(pwm.source_id, pwm.tdiv);\n\n\tsamsung_time_setup(pwm.source_id, pwm.tcnt_max);\n\tsamsung_time_start(pwm.source_id, true);\n}\n\nstatic u64 notrace samsung_clocksource_read(struct clocksource *c)\n{\n\treturn ~readl_relaxed(pwm.source_reg);\n}\n\nstatic struct clocksource samsung_clocksource = {\n\t.name\t\t= \"samsung_clocksource_timer\",\n\t.rating\t\t= 250,\n\t.read\t\t= samsung_clocksource_read,\n\t.suspend\t= samsung_clocksource_suspend,\n\t.resume\t\t= samsung_clocksource_resume,\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\n \nstatic u64 notrace samsung_read_sched_clock(void)\n{\n\treturn samsung_clocksource_read(NULL);\n}\n\nstatic int __init samsung_clocksource_init(void)\n{\n\tunsigned long pclk;\n\tunsigned long clock_rate;\n\n\tpclk = clk_get_rate(pwm.timerclk);\n\n\tsamsung_timer_set_prescale(pwm.source_id, pwm.tscaler_div);\n\tsamsung_timer_set_divisor(pwm.source_id, pwm.tdiv);\n\n\tclock_rate = pclk / (pwm.tscaler_div * pwm.tdiv);\n\n\tsamsung_time_setup(pwm.source_id, pwm.tcnt_max);\n\tsamsung_time_start(pwm.source_id, true);\n\n\tif (pwm.source_id == 4)\n\t\tpwm.source_reg = pwm.base + 0x40;\n\telse\n\t\tpwm.source_reg = pwm.base + pwm.source_id * 0x0c + 0x14;\n\n\tsched_clock_register(samsung_read_sched_clock,\n\t\t\t     pwm.variant.bits, clock_rate);\n\n\tsamsung_clocksource.mask = CLOCKSOURCE_MASK(pwm.variant.bits);\n\treturn clocksource_register_hz(&samsung_clocksource, clock_rate);\n}\n\nstatic void __init samsung_timer_resources(void)\n{\n\tclk_prepare_enable(pwm.timerclk);\n\n\tpwm.tcnt_max = (1UL << pwm.variant.bits) - 1;\n\tif (pwm.variant.bits == 16) {\n\t\tpwm.tscaler_div = 25;\n\t\tpwm.tdiv = 2;\n\t} else {\n\t\tpwm.tscaler_div = 2;\n\t\tpwm.tdiv = 1;\n\t}\n}\n\n \nstatic int __init _samsung_pwm_clocksource_init(void)\n{\n\tu8 mask;\n\tint channel;\n\n\tmask = ~pwm.variant.output_mask & ((1 << SAMSUNG_PWM_NUM) - 1);\n\tchannel = fls(mask) - 1;\n\tif (channel < 0) {\n\t\tpr_crit(\"failed to find PWM channel for clocksource\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpwm.source_id = channel;\n\n\tmask &= ~(1 << channel);\n\tchannel = fls(mask) - 1;\n\tif (channel < 0) {\n\t\tpr_crit(\"failed to find PWM channel for clock event\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpwm.event_id = channel;\n\n\tsamsung_timer_resources();\n\tsamsung_clockevent_init();\n\n\treturn samsung_clocksource_init();\n}\n\nvoid __init samsung_pwm_clocksource_init(void __iomem *base,\n\t\t\t\t\t unsigned int *irqs,\n\t\t\t\t\t const struct samsung_pwm_variant *variant)\n{\n\tpwm.base = base;\n\tmemcpy(&pwm.variant, variant, sizeof(pwm.variant));\n\tmemcpy(pwm.irq, irqs, SAMSUNG_PWM_NUM * sizeof(*irqs));\n\n\tpwm.timerclk = clk_get(NULL, \"timers\");\n\tif (IS_ERR(pwm.timerclk))\n\t\tpanic(\"failed to get timers clock for timer\");\n\n\t_samsung_pwm_clocksource_init();\n}\n\n#ifdef CONFIG_TIMER_OF\nstatic int __init samsung_pwm_alloc(struct device_node *np,\n\t\t\t\t    const struct samsung_pwm_variant *variant)\n{\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tu32 val;\n\tint i, ret;\n\n\tmemcpy(&pwm.variant, variant, sizeof(pwm.variant));\n\tfor (i = 0; i < SAMSUNG_PWM_NUM; ++i)\n\t\tpwm.irq[i] = irq_of_parse_and_map(np, i);\n\n\tof_property_for_each_u32(np, \"samsung,pwm-outputs\", prop, cur, val) {\n\t\tif (val >= SAMSUNG_PWM_NUM) {\n\t\t\tpr_warn(\"%s: invalid channel index in samsung,pwm-outputs property\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\t\tpwm.variant.output_mask |= 1 << val;\n\t}\n\n\tpwm.base = of_iomap(np, 0);\n\tif (!pwm.base) {\n\t\tpr_err(\"%s: failed to map PWM registers\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tpwm.timerclk = of_clk_get_by_name(np, \"timers\");\n\tif (IS_ERR(pwm.timerclk)) {\n\t\tpr_crit(\"failed to get timers clock for timer\\n\");\n\t\tret = PTR_ERR(pwm.timerclk);\n\t\tgoto err_clk;\n\t}\n\n\tret = _samsung_pwm_clocksource_init();\n\tif (ret)\n\t\tgoto err_clocksource;\n\n\treturn 0;\n\nerr_clocksource:\n\tclk_put(pwm.timerclk);\n\tpwm.timerclk = NULL;\nerr_clk:\n\tiounmap(pwm.base);\n\tpwm.base = NULL;\n\n\treturn ret;\n}\n\nstatic const struct samsung_pwm_variant s3c24xx_variant = {\n\t.bits\t\t= 16,\n\t.div_base\t= 1,\n\t.has_tint_cstat\t= false,\n\t.tclk_mask\t= (1 << 4),\n};\n\nstatic int __init s3c2410_pwm_clocksource_init(struct device_node *np)\n{\n\treturn samsung_pwm_alloc(np, &s3c24xx_variant);\n}\nTIMER_OF_DECLARE(s3c2410_pwm, \"samsung,s3c2410-pwm\", s3c2410_pwm_clocksource_init);\n\nstatic const struct samsung_pwm_variant s3c64xx_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= (1 << 7) | (1 << 6) | (1 << 5),\n};\n\nstatic int __init s3c64xx_pwm_clocksource_init(struct device_node *np)\n{\n\treturn samsung_pwm_alloc(np, &s3c64xx_variant);\n}\nTIMER_OF_DECLARE(s3c6400_pwm, \"samsung,s3c6400-pwm\", s3c64xx_pwm_clocksource_init);\n\nstatic const struct samsung_pwm_variant s5p64x0_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= 0,\n};\n\nstatic int __init s5p64x0_pwm_clocksource_init(struct device_node *np)\n{\n\treturn samsung_pwm_alloc(np, &s5p64x0_variant);\n}\nTIMER_OF_DECLARE(s5p6440_pwm, \"samsung,s5p6440-pwm\", s5p64x0_pwm_clocksource_init);\n\nstatic const struct samsung_pwm_variant s5p_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= (1 << 5),\n};\n\nstatic int __init s5p_pwm_clocksource_init(struct device_node *np)\n{\n\treturn samsung_pwm_alloc(np, &s5p_variant);\n}\nTIMER_OF_DECLARE(s5pc100_pwm, \"samsung,s5pc100-pwm\", s5p_pwm_clocksource_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}