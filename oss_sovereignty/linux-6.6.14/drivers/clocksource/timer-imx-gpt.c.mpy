{
  "module_name": "timer-imx-gpt.c",
  "hash_id": "43d99d0d978cd60470d1576115b9a0c7a43269b3b7dd25fdd47cebc3ee74185a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-imx-gpt.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/clockchips.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n \nenum imx_gpt_type {\n\tGPT_TYPE_IMX1,\t\t \n\tGPT_TYPE_IMX21,\t\t \n\tGPT_TYPE_IMX31,\t\t \n\tGPT_TYPE_IMX6DL,\t \n};\n\n \n#define MXC_TCTL\t\t0x00\n#define MXC_TCTL_TEN\t\t(1 << 0)  \n#define MXC_TPRER\t\t0x04\n\n \n#define MX1_2_TCTL_CLK_PCLK1\t(1 << 1)\n#define MX1_2_TCTL_IRQEN\t(1 << 4)\n#define MX1_2_TCTL_FRR\t\t(1 << 8)\n#define MX1_2_TCMP\t\t0x08\n#define MX1_2_TCN\t\t0x10\n#define MX1_2_TSTAT\t\t0x14\n\n \n#define MX2_TSTAT_CAPT\t\t(1 << 1)\n#define MX2_TSTAT_COMP\t\t(1 << 0)\n\n \n#define V2_TCTL_WAITEN\t\t(1 << 3)  \n#define V2_TCTL_CLK_IPG\t\t(1 << 6)\n#define V2_TCTL_CLK_PER\t\t(2 << 6)\n#define V2_TCTL_CLK_OSC_DIV8\t(5 << 6)\n#define V2_TCTL_FRR\t\t(1 << 9)\n#define V2_TCTL_24MEN\t\t(1 << 10)\n#define V2_TPRER_PRE24M\t\t12\n#define V2_IR\t\t\t0x0c\n#define V2_TSTAT\t\t0x08\n#define V2_TSTAT_OF1\t\t(1 << 0)\n#define V2_TCN\t\t\t0x24\n#define V2_TCMP\t\t\t0x10\n\n#define V2_TIMER_RATE_OSC_DIV8\t3000000\n\nstruct imx_timer {\n\tenum imx_gpt_type type;\n\tvoid __iomem *base;\n\tint irq;\n\tstruct clk *clk_per;\n\tstruct clk *clk_ipg;\n\tconst struct imx_gpt_data *gpt;\n\tstruct clock_event_device ced;\n};\n\nstruct imx_gpt_data {\n\tint reg_tstat;\n\tint reg_tcn;\n\tint reg_tcmp;\n\tvoid (*gpt_setup_tctl)(struct imx_timer *imxtm);\n\tvoid (*gpt_irq_enable)(struct imx_timer *imxtm);\n\tvoid (*gpt_irq_disable)(struct imx_timer *imxtm);\n\tvoid (*gpt_irq_acknowledge)(struct imx_timer *imxtm);\n\tint (*set_next_event)(unsigned long evt,\n\t\t\t      struct clock_event_device *ced);\n};\n\nstatic inline struct imx_timer *to_imx_timer(struct clock_event_device *ced)\n{\n\treturn container_of(ced, struct imx_timer, ced);\n}\n\nstatic void imx1_gpt_irq_disable(struct imx_timer *imxtm)\n{\n\tunsigned int tmp;\n\n\ttmp = readl_relaxed(imxtm->base + MXC_TCTL);\n\twritel_relaxed(tmp & ~MX1_2_TCTL_IRQEN, imxtm->base + MXC_TCTL);\n}\n\nstatic void imx31_gpt_irq_disable(struct imx_timer *imxtm)\n{\n\twritel_relaxed(0, imxtm->base + V2_IR);\n}\n\nstatic void imx1_gpt_irq_enable(struct imx_timer *imxtm)\n{\n\tunsigned int tmp;\n\n\ttmp = readl_relaxed(imxtm->base + MXC_TCTL);\n\twritel_relaxed(tmp | MX1_2_TCTL_IRQEN, imxtm->base + MXC_TCTL);\n}\n\nstatic void imx31_gpt_irq_enable(struct imx_timer *imxtm)\n{\n\twritel_relaxed(1<<0, imxtm->base + V2_IR);\n}\n\nstatic void imx1_gpt_irq_acknowledge(struct imx_timer *imxtm)\n{\n\twritel_relaxed(0, imxtm->base + MX1_2_TSTAT);\n}\n\nstatic void imx21_gpt_irq_acknowledge(struct imx_timer *imxtm)\n{\n\twritel_relaxed(MX2_TSTAT_CAPT | MX2_TSTAT_COMP,\n\t\t\t\timxtm->base + MX1_2_TSTAT);\n}\n\nstatic void imx31_gpt_irq_acknowledge(struct imx_timer *imxtm)\n{\n\twritel_relaxed(V2_TSTAT_OF1, imxtm->base + V2_TSTAT);\n}\n\nstatic void __iomem *sched_clock_reg;\n\nstatic u64 notrace mxc_read_sched_clock(void)\n{\n\treturn sched_clock_reg ? readl_relaxed(sched_clock_reg) : 0;\n}\n\n#if defined(CONFIG_ARM)\nstatic struct delay_timer imx_delay_timer;\n\nstatic unsigned long imx_read_current_timer(void)\n{\n\treturn readl_relaxed(sched_clock_reg);\n}\n#endif\n\nstatic int __init mxc_clocksource_init(struct imx_timer *imxtm)\n{\n\tunsigned int c = clk_get_rate(imxtm->clk_per);\n\tvoid __iomem *reg = imxtm->base + imxtm->gpt->reg_tcn;\n\n#if defined(CONFIG_ARM)\n\timx_delay_timer.read_current_timer = &imx_read_current_timer;\n\timx_delay_timer.freq = c;\n\tregister_current_timer_delay(&imx_delay_timer);\n#endif\n\n\tsched_clock_reg = reg;\n\n\tsched_clock_register(mxc_read_sched_clock, 32, c);\n\treturn clocksource_mmio_init(reg, \"mxc_timer1\", c, 200, 32,\n\t\t\tclocksource_mmio_readl_up);\n}\n\n \n\nstatic int mx1_2_set_next_event(unsigned long evt,\n\t\t\t      struct clock_event_device *ced)\n{\n\tstruct imx_timer *imxtm = to_imx_timer(ced);\n\tunsigned long tcmp;\n\n\ttcmp = readl_relaxed(imxtm->base + MX1_2_TCN) + evt;\n\n\twritel_relaxed(tcmp, imxtm->base + MX1_2_TCMP);\n\n\treturn (int)(tcmp - readl_relaxed(imxtm->base + MX1_2_TCN)) < 0 ?\n\t\t\t\t-ETIME : 0;\n}\n\nstatic int v2_set_next_event(unsigned long evt,\n\t\t\t      struct clock_event_device *ced)\n{\n\tstruct imx_timer *imxtm = to_imx_timer(ced);\n\tunsigned long tcmp;\n\n\ttcmp = readl_relaxed(imxtm->base + V2_TCN) + evt;\n\n\twritel_relaxed(tcmp, imxtm->base + V2_TCMP);\n\n\treturn evt < 0x7fffffff &&\n\t\t(int)(tcmp - readl_relaxed(imxtm->base + V2_TCN)) < 0 ?\n\t\t\t\t-ETIME : 0;\n}\n\nstatic int mxc_shutdown(struct clock_event_device *ced)\n{\n\tstruct imx_timer *imxtm = to_imx_timer(ced);\n\tu32 tcn;\n\n\t \n\timxtm->gpt->gpt_irq_disable(imxtm);\n\n\ttcn = readl_relaxed(imxtm->base + imxtm->gpt->reg_tcn);\n\t \n\twritel_relaxed(tcn - 3, imxtm->base + imxtm->gpt->reg_tcmp);\n\n\t \n\timxtm->gpt->gpt_irq_acknowledge(imxtm);\n\n#ifdef DEBUG\n\tprintk(KERN_INFO \"%s: changing mode\\n\", __func__);\n#endif  \n\n\treturn 0;\n}\n\nstatic int mxc_set_oneshot(struct clock_event_device *ced)\n{\n\tstruct imx_timer *imxtm = to_imx_timer(ced);\n\n\t \n\timxtm->gpt->gpt_irq_disable(imxtm);\n\n\tif (!clockevent_state_oneshot(ced)) {\n\t\tu32 tcn = readl_relaxed(imxtm->base + imxtm->gpt->reg_tcn);\n\t\t \n\t\twritel_relaxed(tcn - 3, imxtm->base + imxtm->gpt->reg_tcmp);\n\n\t\t \n\t\timxtm->gpt->gpt_irq_acknowledge(imxtm);\n\t}\n\n#ifdef DEBUG\n\tprintk(KERN_INFO \"%s: changing mode\\n\", __func__);\n#endif  \n\n\t \n\timxtm->gpt->gpt_irq_enable(imxtm);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *ced = dev_id;\n\tstruct imx_timer *imxtm = to_imx_timer(ced);\n\tuint32_t tstat;\n\n\ttstat = readl_relaxed(imxtm->base + imxtm->gpt->reg_tstat);\n\n\timxtm->gpt->gpt_irq_acknowledge(imxtm);\n\n\tced->event_handler(ced);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init mxc_clockevent_init(struct imx_timer *imxtm)\n{\n\tstruct clock_event_device *ced = &imxtm->ced;\n\n\tced->name = \"mxc_timer1\";\n\tced->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_DYNIRQ;\n\tced->set_state_shutdown = mxc_shutdown;\n\tced->set_state_oneshot = mxc_set_oneshot;\n\tced->tick_resume = mxc_shutdown;\n\tced->set_next_event = imxtm->gpt->set_next_event;\n\tced->rating = 200;\n\tced->cpumask = cpumask_of(0);\n\tced->irq = imxtm->irq;\n\tclockevents_config_and_register(ced, clk_get_rate(imxtm->clk_per),\n\t\t\t\t\t0xff, 0xfffffffe);\n\n\treturn request_irq(imxtm->irq, mxc_timer_interrupt,\n\t\t\t   IRQF_TIMER | IRQF_IRQPOLL, \"i.MX Timer Tick\", ced);\n}\n\nstatic void imx1_gpt_setup_tctl(struct imx_timer *imxtm)\n{\n\tu32 tctl_val;\n\n\ttctl_val = MX1_2_TCTL_FRR | MX1_2_TCTL_CLK_PCLK1 | MXC_TCTL_TEN;\n\twritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\n}\n\nstatic void imx31_gpt_setup_tctl(struct imx_timer *imxtm)\n{\n\tu32 tctl_val;\n\n\ttctl_val = V2_TCTL_FRR | V2_TCTL_WAITEN | MXC_TCTL_TEN;\n\tif (clk_get_rate(imxtm->clk_per) == V2_TIMER_RATE_OSC_DIV8)\n\t\ttctl_val |= V2_TCTL_CLK_OSC_DIV8;\n\telse\n\t\ttctl_val |= V2_TCTL_CLK_PER;\n\n\twritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\n}\n\nstatic void imx6dl_gpt_setup_tctl(struct imx_timer *imxtm)\n{\n\tu32 tctl_val;\n\n\ttctl_val = V2_TCTL_FRR | V2_TCTL_WAITEN | MXC_TCTL_TEN;\n\tif (clk_get_rate(imxtm->clk_per) == V2_TIMER_RATE_OSC_DIV8) {\n\t\ttctl_val |= V2_TCTL_CLK_OSC_DIV8;\n\t\t \n\t\twritel_relaxed(7 << V2_TPRER_PRE24M, imxtm->base + MXC_TPRER);\n\t\ttctl_val |= V2_TCTL_24MEN;\n\t} else {\n\t\ttctl_val |= V2_TCTL_CLK_PER;\n\t}\n\n\twritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\n}\n\nstatic const struct imx_gpt_data imx1_gpt_data = {\n\t.reg_tstat = MX1_2_TSTAT,\n\t.reg_tcn = MX1_2_TCN,\n\t.reg_tcmp = MX1_2_TCMP,\n\t.gpt_irq_enable = imx1_gpt_irq_enable,\n\t.gpt_irq_disable = imx1_gpt_irq_disable,\n\t.gpt_irq_acknowledge = imx1_gpt_irq_acknowledge,\n\t.gpt_setup_tctl = imx1_gpt_setup_tctl,\n\t.set_next_event = mx1_2_set_next_event,\n};\n\nstatic const struct imx_gpt_data imx21_gpt_data = {\n\t.reg_tstat = MX1_2_TSTAT,\n\t.reg_tcn = MX1_2_TCN,\n\t.reg_tcmp = MX1_2_TCMP,\n\t.gpt_irq_enable = imx1_gpt_irq_enable,\n\t.gpt_irq_disable = imx1_gpt_irq_disable,\n\t.gpt_irq_acknowledge = imx21_gpt_irq_acknowledge,\n\t.gpt_setup_tctl = imx1_gpt_setup_tctl,\n\t.set_next_event = mx1_2_set_next_event,\n};\n\nstatic const struct imx_gpt_data imx31_gpt_data = {\n\t.reg_tstat = V2_TSTAT,\n\t.reg_tcn = V2_TCN,\n\t.reg_tcmp = V2_TCMP,\n\t.gpt_irq_enable = imx31_gpt_irq_enable,\n\t.gpt_irq_disable = imx31_gpt_irq_disable,\n\t.gpt_irq_acknowledge = imx31_gpt_irq_acknowledge,\n\t.gpt_setup_tctl = imx31_gpt_setup_tctl,\n\t.set_next_event = v2_set_next_event,\n};\n\nstatic const struct imx_gpt_data imx6dl_gpt_data = {\n\t.reg_tstat = V2_TSTAT,\n\t.reg_tcn = V2_TCN,\n\t.reg_tcmp = V2_TCMP,\n\t.gpt_irq_enable = imx31_gpt_irq_enable,\n\t.gpt_irq_disable = imx31_gpt_irq_disable,\n\t.gpt_irq_acknowledge = imx31_gpt_irq_acknowledge,\n\t.gpt_setup_tctl = imx6dl_gpt_setup_tctl,\n\t.set_next_event = v2_set_next_event,\n};\n\nstatic int __init _mxc_timer_init(struct imx_timer *imxtm)\n{\n\tint ret;\n\n\tswitch (imxtm->type) {\n\tcase GPT_TYPE_IMX1:\n\t\timxtm->gpt = &imx1_gpt_data;\n\t\tbreak;\n\tcase GPT_TYPE_IMX21:\n\t\timxtm->gpt = &imx21_gpt_data;\n\t\tbreak;\n\tcase GPT_TYPE_IMX31:\n\t\timxtm->gpt = &imx31_gpt_data;\n\t\tbreak;\n\tcase GPT_TYPE_IMX6DL:\n\t\timxtm->gpt = &imx6dl_gpt_data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(imxtm->clk_per)) {\n\t\tpr_err(\"i.MX timer: unable to get clk\\n\");\n\t\treturn PTR_ERR(imxtm->clk_per);\n\t}\n\n\tif (!IS_ERR(imxtm->clk_ipg))\n\t\tclk_prepare_enable(imxtm->clk_ipg);\n\n\tclk_prepare_enable(imxtm->clk_per);\n\n\t \n\n\twritel_relaxed(0, imxtm->base + MXC_TCTL);\n\twritel_relaxed(0, imxtm->base + MXC_TPRER);  \n\n\timxtm->gpt->gpt_setup_tctl(imxtm);\n\n\t \n\tret = mxc_clocksource_init(imxtm);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mxc_clockevent_init(imxtm);\n}\n\nstatic int __init mxc_timer_init_dt(struct device_node *np,  enum imx_gpt_type type)\n{\n\tstruct imx_timer *imxtm;\n\tstatic int initialized;\n\tint ret;\n\n\t \n\tif (initialized)\n\t\treturn 0;\n\n\timxtm = kzalloc(sizeof(*imxtm), GFP_KERNEL);\n\tif (!imxtm)\n\t\treturn -ENOMEM;\n\n\timxtm->base = of_iomap(np, 0);\n\tif (!imxtm->base) {\n\t\tret = -ENXIO;\n\t\tgoto err_kfree;\n\t}\n\n\timxtm->irq = irq_of_parse_and_map(np, 0);\n\tif (imxtm->irq <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_kfree;\n\t}\n\n\timxtm->clk_ipg = of_clk_get_by_name(np, \"ipg\");\n\n\t \n\timxtm->clk_per = of_clk_get_by_name(np, \"osc_per\");\n\tif (IS_ERR(imxtm->clk_per))\n\t\timxtm->clk_per = of_clk_get_by_name(np, \"per\");\n\n\timxtm->type = type;\n\n\tret = _mxc_timer_init(imxtm);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tinitialized = 1;\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(imxtm);\n\treturn ret;\n}\n\nstatic int __init imx1_timer_init_dt(struct device_node *np)\n{\n\treturn mxc_timer_init_dt(np, GPT_TYPE_IMX1);\n}\n\nstatic int __init imx21_timer_init_dt(struct device_node *np)\n{\n\treturn mxc_timer_init_dt(np, GPT_TYPE_IMX21);\n}\n\nstatic int __init imx31_timer_init_dt(struct device_node *np)\n{\n\tenum imx_gpt_type type = GPT_TYPE_IMX31;\n\n\t \n\tif (of_machine_is_compatible(\"fsl,imx6dl\"))\n\t\ttype = GPT_TYPE_IMX6DL;\n\n\treturn mxc_timer_init_dt(np, type);\n}\n\nstatic int __init imx6dl_timer_init_dt(struct device_node *np)\n{\n\treturn mxc_timer_init_dt(np, GPT_TYPE_IMX6DL);\n}\n\nTIMER_OF_DECLARE(imx1_timer, \"fsl,imx1-gpt\", imx1_timer_init_dt);\nTIMER_OF_DECLARE(imx21_timer, \"fsl,imx21-gpt\", imx21_timer_init_dt);\nTIMER_OF_DECLARE(imx27_timer, \"fsl,imx27-gpt\", imx21_timer_init_dt);\nTIMER_OF_DECLARE(imx31_timer, \"fsl,imx31-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx25_timer, \"fsl,imx25-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx50_timer, \"fsl,imx50-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx51_timer, \"fsl,imx51-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx53_timer, \"fsl,imx53-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx6q_timer, \"fsl,imx6q-gpt\", imx31_timer_init_dt);\nTIMER_OF_DECLARE(imx6dl_timer, \"fsl,imx6dl-gpt\", imx6dl_timer_init_dt);\nTIMER_OF_DECLARE(imx6sl_timer, \"fsl,imx6sl-gpt\", imx6dl_timer_init_dt);\nTIMER_OF_DECLARE(imx6sx_timer, \"fsl,imx6sx-gpt\", imx6dl_timer_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}