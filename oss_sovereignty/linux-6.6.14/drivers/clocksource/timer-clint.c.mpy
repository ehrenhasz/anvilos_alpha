{
  "module_name": "timer-clint.c",
  "hash_id": "589090e00b105ef12728009a1ca211ca083e99285d53f1ac2b00c884f0f050a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-clint.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"clint: \" fmt\n#include <linux/bitops.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/sched_clock.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n#include <linux/smp.h>\n#include <linux/timex.h>\n\n#ifndef CONFIG_RISCV_M_MODE\n#include <asm/clint.h>\n#endif\n\n#define CLINT_IPI_OFF\t\t0\n#define CLINT_TIMER_CMP_OFF\t0x4000\n#define CLINT_TIMER_VAL_OFF\t0xbff8\n\n \nstatic u32 __iomem *clint_ipi_base;\nstatic unsigned int clint_ipi_irq;\nstatic u64 __iomem *clint_timer_cmp;\nstatic u64 __iomem *clint_timer_val;\nstatic unsigned long clint_timer_freq;\nstatic unsigned int clint_timer_irq;\n\n#ifdef CONFIG_RISCV_M_MODE\nu64 __iomem *clint_time_val;\nEXPORT_SYMBOL(clint_time_val);\n#endif\n\n#ifdef CONFIG_SMP\nstatic void clint_send_ipi(unsigned int cpu)\n{\n\twritel(1, clint_ipi_base + cpuid_to_hartid_map(cpu));\n}\n\nstatic void clint_clear_ipi(void)\n{\n\twritel(0, clint_ipi_base + cpuid_to_hartid_map(smp_processor_id()));\n}\n\nstatic void clint_ipi_interrupt(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\tclint_clear_ipi();\n\tipi_mux_process();\n\n\tchained_irq_exit(chip, desc);\n}\n#endif\n\n#ifdef CONFIG_64BIT\n#define clint_get_cycles()\treadq_relaxed(clint_timer_val)\n#else\n#define clint_get_cycles()\treadl_relaxed(clint_timer_val)\n#define clint_get_cycles_hi()\treadl_relaxed(((u32 *)clint_timer_val) + 1)\n#endif\n\n#ifdef CONFIG_64BIT\nstatic u64 notrace clint_get_cycles64(void)\n{\n\treturn clint_get_cycles();\n}\n#else  \nstatic u64 notrace clint_get_cycles64(void)\n{\n\tu32 hi, lo;\n\n\tdo {\n\t\thi = clint_get_cycles_hi();\n\t\tlo = clint_get_cycles();\n\t} while (hi != clint_get_cycles_hi());\n\n\treturn ((u64)hi << 32) | lo;\n}\n#endif  \n\nstatic u64 clint_rdtime(struct clocksource *cs)\n{\n\treturn clint_get_cycles64();\n}\n\nstatic struct clocksource clint_clocksource = {\n\t.name\t\t= \"clint_clocksource\",\n\t.rating\t\t= 300,\n\t.mask\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.read\t\t= clint_rdtime,\n};\n\nstatic int clint_clock_next_event(unsigned long delta,\n\t\t\t\t   struct clock_event_device *ce)\n{\n\tvoid __iomem *r = clint_timer_cmp +\n\t\t\t  cpuid_to_hartid_map(smp_processor_id());\n\n\tcsr_set(CSR_IE, IE_TIE);\n\twriteq_relaxed(clint_get_cycles64() + delta, r);\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(struct clock_event_device, clint_clock_event) = {\n\t.name\t\t= \"clint_clockevent\",\n\t.features\t= CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t= 100,\n\t.set_next_event\t= clint_clock_next_event,\n};\n\nstatic int clint_timer_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *ce = per_cpu_ptr(&clint_clock_event, cpu);\n\n\tce->cpumask = cpumask_of(cpu);\n\tclockevents_config_and_register(ce, clint_timer_freq, 100, 0x7fffffff);\n\n\tenable_percpu_irq(clint_timer_irq,\n\t\t\t  irq_get_trigger_type(clint_timer_irq));\n\tenable_percpu_irq(clint_ipi_irq,\n\t\t\t  irq_get_trigger_type(clint_ipi_irq));\n\treturn 0;\n}\n\nstatic int clint_timer_dying_cpu(unsigned int cpu)\n{\n\tdisable_percpu_irq(clint_timer_irq);\n\t \n\treturn 0;\n}\n\nstatic irqreturn_t clint_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evdev = this_cpu_ptr(&clint_clock_event);\n\n\tcsr_clear(CSR_IE, IE_TIE);\n\tevdev->event_handler(evdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init clint_timer_init_dt(struct device_node *np)\n{\n\tint rc;\n\tu32 i, nr_irqs;\n\tvoid __iomem *base;\n\tstruct of_phandle_args oirq;\n\n\t \n\tnr_irqs = of_irq_count(np);\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (of_irq_parse_one(np, i, &oirq)) {\n\t\t\tpr_err(\"%pOFP: failed to parse irq %d.\\n\", np, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((oirq.args_count != 1) ||\n\t\t    (oirq.args[0] != RV_IRQ_TIMER &&\n\t\t     oirq.args[0] != RV_IRQ_SOFT)) {\n\t\t\tpr_err(\"%pOFP: invalid irq %d (hwirq %d)\\n\",\n\t\t\t       np, i, oirq.args[0]);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (!clint_ipi_irq &&\n\t\t    oirq.args[0] == RV_IRQ_SOFT &&\n\t\t    irq_find_host(oirq.np))\n\t\t\tclint_ipi_irq = irq_of_parse_and_map(np, i);\n\n\t\t \n\t\tif (!clint_timer_irq &&\n\t\t    oirq.args[0] == RV_IRQ_TIMER &&\n\t\t    irq_find_host(oirq.np))\n\t\t\tclint_timer_irq = irq_of_parse_and_map(np, i);\n\t}\n\n\t \n\tif (!clint_ipi_irq || !clint_timer_irq) {\n\t\tpr_err(\"%pOFP: ipi/timer irq not found\\n\", np);\n\t\treturn -ENODEV;\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"%pOFP: could not map registers\\n\", np);\n\t\treturn -ENODEV;\n\t}\n\n\tclint_ipi_base = base + CLINT_IPI_OFF;\n\tclint_timer_cmp = base + CLINT_TIMER_CMP_OFF;\n\tclint_timer_val = base + CLINT_TIMER_VAL_OFF;\n\tclint_timer_freq = riscv_timebase;\n\n#ifdef CONFIG_RISCV_M_MODE\n\t \n\tclint_time_val = clint_timer_val;\n#endif\n\n\tpr_info(\"%pOFP: timer running at %ld Hz\\n\", np, clint_timer_freq);\n\n\trc = clocksource_register_hz(&clint_clocksource, clint_timer_freq);\n\tif (rc) {\n\t\tpr_err(\"%pOFP: clocksource register failed [%d]\\n\", np, rc);\n\t\tgoto fail_iounmap;\n\t}\n\n\tsched_clock_register(clint_get_cycles64, 64, clint_timer_freq);\n\n\trc = request_percpu_irq(clint_timer_irq, clint_timer_interrupt,\n\t\t\t\t \"clint-timer\", &clint_clock_event);\n\tif (rc) {\n\t\tpr_err(\"registering percpu irq failed [%d]\\n\", rc);\n\t\tgoto fail_iounmap;\n\t}\n\n#ifdef CONFIG_SMP\n\trc = ipi_mux_create(BITS_PER_BYTE, clint_send_ipi);\n\tif (rc <= 0) {\n\t\tpr_err(\"unable to create muxed IPIs\\n\");\n\t\trc = (rc < 0) ? rc : -ENODEV;\n\t\tgoto fail_free_irq;\n\t}\n\n\tirq_set_chained_handler(clint_ipi_irq, clint_ipi_interrupt);\n\triscv_ipi_set_virq_range(rc, BITS_PER_BYTE, true);\n\tclint_clear_ipi();\n#endif\n\n\trc = cpuhp_setup_state(CPUHP_AP_CLINT_TIMER_STARTING,\n\t\t\t\t\"clockevents/clint/timer:starting\",\n\t\t\t\tclint_timer_starting_cpu,\n\t\t\t\tclint_timer_dying_cpu);\n\tif (rc) {\n\t\tpr_err(\"%pOFP: cpuhp setup state failed [%d]\\n\", np, rc);\n\t\tgoto fail_free_irq;\n\t}\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_percpu_irq(clint_timer_irq, &clint_clock_event);\nfail_iounmap:\n\tiounmap(base);\n\treturn rc;\n}\n\nTIMER_OF_DECLARE(clint_timer, \"riscv,clint0\", clint_timer_init_dt);\nTIMER_OF_DECLARE(clint_timer1, \"sifive,clint0\", clint_timer_init_dt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}