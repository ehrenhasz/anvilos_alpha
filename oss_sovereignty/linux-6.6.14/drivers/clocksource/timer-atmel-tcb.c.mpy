{
  "module_name": "timer-atmel-tcb.c",
  "hash_id": "397d83b4af261efd76c0e76c92e8a97c4d6a7d358778d86efb3aedaf7e909ab9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-atmel-tcb.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n#include <linux/syscore_ops.h>\n#include <soc/at91/atmel_tcb.h>\n\n\n \n\nstatic void __iomem *tcaddr;\nstatic struct\n{\n\tu32 cmr;\n\tu32 imr;\n\tu32 rc;\n\tbool clken;\n} tcb_cache[3];\nstatic u32 bmr_cache;\n\nstatic const u8 atmel_tcb_divisors[] = { 2, 8, 32, 128 };\n\nstatic u64 tc_get_cycles(struct clocksource *cs)\n{\n\tunsigned long\tflags;\n\tu32\t\tlower, upper;\n\n\traw_local_irq_save(flags);\n\tdo {\n\t\tupper = readl_relaxed(tcaddr + ATMEL_TC_REG(1, CV));\n\t\tlower = readl_relaxed(tcaddr + ATMEL_TC_REG(0, CV));\n\t} while (upper != readl_relaxed(tcaddr + ATMEL_TC_REG(1, CV)));\n\n\traw_local_irq_restore(flags);\n\treturn (upper << 16) | lower;\n}\n\nstatic u64 tc_get_cycles32(struct clocksource *cs)\n{\n\treturn readl_relaxed(tcaddr + ATMEL_TC_REG(0, CV));\n}\n\nstatic void tc_clksrc_suspend(struct clocksource *cs)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tcb_cache); i++) {\n\t\ttcb_cache[i].cmr = readl(tcaddr + ATMEL_TC_REG(i, CMR));\n\t\ttcb_cache[i].imr = readl(tcaddr + ATMEL_TC_REG(i, IMR));\n\t\ttcb_cache[i].rc = readl(tcaddr + ATMEL_TC_REG(i, RC));\n\t\ttcb_cache[i].clken = !!(readl(tcaddr + ATMEL_TC_REG(i, SR)) &\n\t\t\t\t\tATMEL_TC_CLKSTA);\n\t}\n\n\tbmr_cache = readl(tcaddr + ATMEL_TC_BMR);\n}\n\nstatic void tc_clksrc_resume(struct clocksource *cs)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tcb_cache); i++) {\n\t\t \n\t\twritel(tcb_cache[i].cmr, tcaddr + ATMEL_TC_REG(i, CMR));\n\t\twritel(tcb_cache[i].rc, tcaddr + ATMEL_TC_REG(i, RC));\n\t\twritel(0, tcaddr + ATMEL_TC_REG(i, RA));\n\t\twritel(0, tcaddr + ATMEL_TC_REG(i, RB));\n\t\t \n\t\twritel(0xff, tcaddr + ATMEL_TC_REG(i, IDR));\n\t\t \n\t\twritel(tcb_cache[i].imr, tcaddr + ATMEL_TC_REG(i, IER));\n\t\t \n\t\tif (tcb_cache[i].clken)\n\t\t\twritel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(i, CCR));\n\t}\n\n\t \n\twritel(bmr_cache, tcaddr + ATMEL_TC_BMR);\n\t \n\twritel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);\n}\n\nstatic struct clocksource clksrc = {\n\t.rating         = 200,\n\t.read           = tc_get_cycles,\n\t.mask           = CLOCKSOURCE_MASK(32),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.suspend\t= tc_clksrc_suspend,\n\t.resume\t\t= tc_clksrc_resume,\n};\n\nstatic u64 notrace tc_sched_clock_read(void)\n{\n\treturn tc_get_cycles(&clksrc);\n}\n\nstatic u64 notrace tc_sched_clock_read32(void)\n{\n\treturn tc_get_cycles32(&clksrc);\n}\n\nstatic struct delay_timer tc_delay_timer;\n\nstatic unsigned long tc_delay_timer_read(void)\n{\n\treturn tc_get_cycles(&clksrc);\n}\n\nstatic unsigned long notrace tc_delay_timer_read32(void)\n{\n\treturn tc_get_cycles32(&clksrc);\n}\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\nstruct tc_clkevt_device {\n\tstruct clock_event_device\tclkevt;\n\tstruct clk\t\t\t*clk;\n\tu32\t\t\t\trate;\n\tvoid __iomem\t\t\t*regs;\n};\n\nstatic struct tc_clkevt_device *to_tc_clkevt(struct clock_event_device *clkevt)\n{\n\treturn container_of(clkevt, struct tc_clkevt_device, clkevt);\n}\n\nstatic u32 timer_clock;\n\nstatic int tc_shutdown(struct clock_event_device *d)\n{\n\tstruct tc_clkevt_device *tcd = to_tc_clkevt(d);\n\tvoid __iomem\t\t*regs = tcd->regs;\n\n\twritel(0xff, regs + ATMEL_TC_REG(2, IDR));\n\twritel(ATMEL_TC_CLKDIS, regs + ATMEL_TC_REG(2, CCR));\n\tif (!clockevent_state_detached(d))\n\t\tclk_disable(tcd->clk);\n\n\treturn 0;\n}\n\nstatic int tc_set_oneshot(struct clock_event_device *d)\n{\n\tstruct tc_clkevt_device *tcd = to_tc_clkevt(d);\n\tvoid __iomem\t\t*regs = tcd->regs;\n\n\tif (clockevent_state_oneshot(d) || clockevent_state_periodic(d))\n\t\ttc_shutdown(d);\n\n\tclk_enable(tcd->clk);\n\n\t \n\twritel(timer_clock | ATMEL_TC_CPCSTOP | ATMEL_TC_WAVE |\n\t\t     ATMEL_TC_WAVESEL_UP_AUTO, regs + ATMEL_TC_REG(2, CMR));\n\twritel(ATMEL_TC_CPCS, regs + ATMEL_TC_REG(2, IER));\n\n\t \n\treturn 0;\n}\n\nstatic int tc_set_periodic(struct clock_event_device *d)\n{\n\tstruct tc_clkevt_device *tcd = to_tc_clkevt(d);\n\tvoid __iomem\t\t*regs = tcd->regs;\n\n\tif (clockevent_state_oneshot(d) || clockevent_state_periodic(d))\n\t\ttc_shutdown(d);\n\n\t \n\tclk_enable(tcd->clk);\n\n\t \n\twritel(timer_clock | ATMEL_TC_WAVE | ATMEL_TC_WAVESEL_UP_AUTO,\n\t\t     regs + ATMEL_TC_REG(2, CMR));\n\twritel((tcd->rate + HZ / 2) / HZ, tcaddr + ATMEL_TC_REG(2, RC));\n\n\t \n\twritel(ATMEL_TC_CPCS, regs + ATMEL_TC_REG(2, IER));\n\n\t \n\twritel(ATMEL_TC_CLKEN | ATMEL_TC_SWTRG, regs +\n\t\t     ATMEL_TC_REG(2, CCR));\n\treturn 0;\n}\n\nstatic int tc_next_event(unsigned long delta, struct clock_event_device *d)\n{\n\twritel_relaxed(delta, tcaddr + ATMEL_TC_REG(2, RC));\n\n\t \n\twritel_relaxed(ATMEL_TC_CLKEN | ATMEL_TC_SWTRG,\n\t\t\ttcaddr + ATMEL_TC_REG(2, CCR));\n\treturn 0;\n}\n\nstatic struct tc_clkevt_device clkevt = {\n\t.clkevt\t= {\n\t\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t\t \n\t\t.rating\t\t\t= 125,\n\t\t.set_next_event\t\t= tc_next_event,\n\t\t.set_state_shutdown\t= tc_shutdown,\n\t\t.set_state_periodic\t= tc_set_periodic,\n\t\t.set_state_oneshot\t= tc_set_oneshot,\n\t},\n};\n\nstatic irqreturn_t ch2_irq(int irq, void *handle)\n{\n\tstruct tc_clkevt_device\t*dev = handle;\n\tunsigned int\t\tsr;\n\n\tsr = readl_relaxed(dev->regs + ATMEL_TC_REG(2, SR));\n\tif (sr & ATMEL_TC_CPCS) {\n\t\tdev->clkevt.event_handler(&dev->clkevt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int __init setup_clkevents(struct atmel_tc *tc, int divisor_idx)\n{\n\tint ret;\n\tstruct clk *t2_clk = tc->clk[2];\n\tint irq = tc->irq[2];\n\tint bits = tc->tcb_config->counter_width;\n\n\t \n\tret = clk_prepare_enable(t2_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tclkevt.regs = tc->regs;\n\tclkevt.clk = t2_clk;\n\n\tif (bits == 32) {\n\t\ttimer_clock = divisor_idx;\n\t\tclkevt.rate = clk_get_rate(t2_clk) / atmel_tcb_divisors[divisor_idx];\n\t} else {\n\t\tret = clk_prepare_enable(tc->slow_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(t2_clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tclkevt.rate = clk_get_rate(tc->slow_clk);\n\t\ttimer_clock = ATMEL_TC_TIMER_CLOCK5;\n\t}\n\n\tclk_disable(t2_clk);\n\n\tclkevt.clkevt.cpumask = cpumask_of(0);\n\n\tret = request_irq(irq, ch2_irq, IRQF_TIMER, \"tc_clkevt\", &clkevt);\n\tif (ret) {\n\t\tclk_unprepare(t2_clk);\n\t\tif (bits != 32)\n\t\t\tclk_disable_unprepare(tc->slow_clk);\n\t\treturn ret;\n\t}\n\n\tclockevents_config_and_register(&clkevt.clkevt, clkevt.rate, 1, BIT(bits) - 1);\n\n\treturn ret;\n}\n\n#else  \n\nstatic int __init setup_clkevents(struct atmel_tc *tc, int divisor_idx)\n{\n\t \n\treturn 0;\n}\n\n#endif\n\nstatic void __init tcb_setup_dual_chan(struct atmel_tc *tc, int mck_divisor_idx)\n{\n\t \n\twritel(mck_divisor_idx\t\t\t \n\t\t\t| ATMEL_TC_WAVE\n\t\t\t| ATMEL_TC_WAVESEL_UP\t\t \n\t\t\t| ATMEL_TC_ASWTRG_SET\t\t \n\t\t\t| ATMEL_TC_ACPA_SET\t\t \n\t\t\t| ATMEL_TC_ACPC_CLEAR,\t\t \n\t\t\ttcaddr + ATMEL_TC_REG(0, CMR));\n\twritel(0x0000, tcaddr + ATMEL_TC_REG(0, RA));\n\twritel(0x8000, tcaddr + ATMEL_TC_REG(0, RC));\n\twritel(0xff, tcaddr + ATMEL_TC_REG(0, IDR));\t \n\twritel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(0, CCR));\n\n\t \n\twritel(ATMEL_TC_XC1\t\t\t \n\t\t\t| ATMEL_TC_WAVE\n\t\t\t| ATMEL_TC_WAVESEL_UP,\t\t \n\t\t\ttcaddr + ATMEL_TC_REG(1, CMR));\n\twritel(0xff, tcaddr + ATMEL_TC_REG(1, IDR));\t \n\twritel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(1, CCR));\n\n\t \n\twritel(ATMEL_TC_TC1XC1S_TIOA0, tcaddr + ATMEL_TC_BMR);\n\t \n\twritel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);\n}\n\nstatic void __init tcb_setup_single_chan(struct atmel_tc *tc, int mck_divisor_idx)\n{\n\t \n\twritel(mck_divisor_idx\t\t\t \n\t\t\t| ATMEL_TC_WAVE\n\t\t\t| ATMEL_TC_WAVESEL_UP,\t\t \n\t\t\ttcaddr + ATMEL_TC_REG(0, CMR));\n\twritel(0xff, tcaddr + ATMEL_TC_REG(0, IDR));\t \n\twritel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(0, CCR));\n\n\t \n\twritel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);\n}\n\nstatic struct atmel_tcb_config tcb_rm9200_config = {\n\t.counter_width = 16,\n};\n\nstatic struct atmel_tcb_config tcb_sam9x5_config = {\n\t.counter_width = 32,\n};\n\nstatic struct atmel_tcb_config tcb_sama5d2_config = {\n\t.counter_width = 32,\n\t.has_gclk = 1,\n};\n\nstatic const struct of_device_id atmel_tcb_of_match[] = {\n\t{ .compatible = \"atmel,at91rm9200-tcb\", .data = &tcb_rm9200_config, },\n\t{ .compatible = \"atmel,at91sam9x5-tcb\", .data = &tcb_sam9x5_config, },\n\t{ .compatible = \"atmel,sama5d2-tcb\", .data = &tcb_sama5d2_config, },\n\t{   }\n};\n\nstatic int __init tcb_clksrc_init(struct device_node *node)\n{\n\tstruct atmel_tc tc;\n\tstruct clk *t0_clk;\n\tconst struct of_device_id *match;\n\tu64 (*tc_sched_clock)(void);\n\tu32 rate, divided_rate = 0;\n\tint best_divisor_idx = -1;\n\tint bits;\n\tint i;\n\tint ret;\n\n\t \n\tif (tcaddr)\n\t\treturn 0;\n\n\ttc.regs = of_iomap(node->parent, 0);\n\tif (!tc.regs)\n\t\treturn -ENXIO;\n\n\tt0_clk = of_clk_get_by_name(node->parent, \"t0_clk\");\n\tif (IS_ERR(t0_clk))\n\t\treturn PTR_ERR(t0_clk);\n\n\ttc.slow_clk = of_clk_get_by_name(node->parent, \"slow_clk\");\n\tif (IS_ERR(tc.slow_clk))\n\t\treturn PTR_ERR(tc.slow_clk);\n\n\ttc.clk[0] = t0_clk;\n\ttc.clk[1] = of_clk_get_by_name(node->parent, \"t1_clk\");\n\tif (IS_ERR(tc.clk[1]))\n\t\ttc.clk[1] = t0_clk;\n\ttc.clk[2] = of_clk_get_by_name(node->parent, \"t2_clk\");\n\tif (IS_ERR(tc.clk[2]))\n\t\ttc.clk[2] = t0_clk;\n\n\ttc.irq[2] = of_irq_get(node->parent, 2);\n\tif (tc.irq[2] <= 0) {\n\t\ttc.irq[2] = of_irq_get(node->parent, 0);\n\t\tif (tc.irq[2] <= 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmatch = of_match_node(atmel_tcb_of_match, node->parent);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\ttc.tcb_config = match->data;\n\tbits = tc.tcb_config->counter_width;\n\n\tfor (i = 0; i < ARRAY_SIZE(tc.irq); i++)\n\t\twritel(ATMEL_TC_ALL_IRQ, tc.regs + ATMEL_TC_REG(i, IDR));\n\n\tret = clk_prepare_enable(t0_clk);\n\tif (ret) {\n\t\tpr_debug(\"can't enable T0 clk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\trate = (u32) clk_get_rate(t0_clk);\n\ti = 0;\n\tif (tc.tcb_config->has_gclk)\n\t\ti = 1;\n\tfor (; i < ARRAY_SIZE(atmel_tcb_divisors); i++) {\n\t\tunsigned divisor = atmel_tcb_divisors[i];\n\t\tunsigned tmp;\n\n\t\ttmp = rate / divisor;\n\t\tpr_debug(\"TC: %u / %-3u [%d] --> %u\\n\", rate, divisor, i, tmp);\n\t\tif ((best_divisor_idx >= 0) && (tmp < 5 * 1000 * 1000))\n\t\t\tbreak;\n\t\tdivided_rate = tmp;\n\t\tbest_divisor_idx = i;\n\t}\n\n\tclksrc.name = kbasename(node->parent->full_name);\n\tclkevt.clkevt.name = kbasename(node->parent->full_name);\n\tpr_debug(\"%s at %d.%03d MHz\\n\", clksrc.name, divided_rate / 1000000,\n\t\t\t((divided_rate % 1000000) + 500) / 1000);\n\n\ttcaddr = tc.regs;\n\n\tif (bits == 32) {\n\t\t \n\t\tclksrc.read = tc_get_cycles32;\n\t\t \n\t\ttcb_setup_single_chan(&tc, best_divisor_idx);\n\t\ttc_sched_clock = tc_sched_clock_read32;\n\t\ttc_delay_timer.read_current_timer = tc_delay_timer_read32;\n\t} else {\n\t\t \n\t\tret = clk_prepare_enable(tc.clk[1]);\n\t\tif (ret) {\n\t\t\tpr_debug(\"can't enable T1 clk\\n\");\n\t\t\tgoto err_disable_t0;\n\t\t}\n\t\t \n\t\ttcb_setup_dual_chan(&tc, best_divisor_idx);\n\t\ttc_sched_clock = tc_sched_clock_read;\n\t\ttc_delay_timer.read_current_timer = tc_delay_timer_read;\n\t}\n\n\t \n\tret = clocksource_register_hz(&clksrc, divided_rate);\n\tif (ret)\n\t\tgoto err_disable_t1;\n\n\t \n\tret = setup_clkevents(&tc, best_divisor_idx);\n\tif (ret)\n\t\tgoto err_unregister_clksrc;\n\n\tsched_clock_register(tc_sched_clock, 32, divided_rate);\n\n\ttc_delay_timer.freq = divided_rate;\n\tregister_current_timer_delay(&tc_delay_timer);\n\n\treturn 0;\n\nerr_unregister_clksrc:\n\tclocksource_unregister(&clksrc);\n\nerr_disable_t1:\n\tif (bits != 32)\n\t\tclk_disable_unprepare(tc.clk[1]);\n\nerr_disable_t0:\n\tclk_disable_unprepare(t0_clk);\n\n\ttcaddr = NULL;\n\n\treturn ret;\n}\nTIMER_OF_DECLARE(atmel_tcb_clksrc, \"atmel,tcb-timer\", tcb_clksrc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}