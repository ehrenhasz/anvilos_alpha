{
  "module_name": "dw_apb_timer_of.c",
  "hash_id": "1625d8049105ac9b16b87a83e139b39a2d880b5f43608a769abfbe43a8086b7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/dw_apb_timer_of.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/dw_apb_timer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/sched_clock.h>\n\nstatic int __init timer_get_base_and_rate(struct device_node *np,\n\t\t\t\t    void __iomem **base, u32 *rate)\n{\n\tstruct clk *timer_clk;\n\tstruct clk *pclk;\n\tstruct reset_control *rstc;\n\tint ret;\n\n\t*base = of_iomap(np, 0);\n\n\tif (!*base)\n\t\tpanic(\"Unable to map regs for %pOFn\", np);\n\n\t \n\trstc = of_reset_control_get(np, NULL);\n\tif (!IS_ERR(rstc)) {\n\t\treset_control_assert(rstc);\n\t\treset_control_deassert(rstc);\n\t}\n\n\t \n\tpclk = of_clk_get_by_name(np, \"pclk\");\n\tif (!IS_ERR(pclk))\n\t\tif (clk_prepare_enable(pclk))\n\t\t\tpr_warn(\"pclk for %pOFn is present, but could not be activated\\n\",\n\t\t\t\tnp);\n\n\tif (!of_property_read_u32(np, \"clock-freq\", rate) ||\n\t    !of_property_read_u32(np, \"clock-frequency\", rate))\n\t\treturn 0;\n\n\ttimer_clk = of_clk_get_by_name(np, \"timer\");\n\tif (IS_ERR(timer_clk)) {\n\t\tret = PTR_ERR(timer_clk);\n\t\tgoto out_pclk_disable;\n\t}\n\n\tret = clk_prepare_enable(timer_clk);\n\tif (ret)\n\t\tgoto out_timer_clk_put;\n\n\t*rate = clk_get_rate(timer_clk);\n\tif (!(*rate)) {\n\t\tret = -EINVAL;\n\t\tgoto out_timer_clk_disable;\n\t}\n\n\treturn 0;\n\nout_timer_clk_disable:\n\tclk_disable_unprepare(timer_clk);\nout_timer_clk_put:\n\tclk_put(timer_clk);\nout_pclk_disable:\n\tif (!IS_ERR(pclk)) {\n\t\tclk_disable_unprepare(pclk);\n\t\tclk_put(pclk);\n\t}\n\tiounmap(*base);\n\treturn ret;\n}\n\nstatic int __init add_clockevent(struct device_node *event_timer)\n{\n\tvoid __iomem *iobase;\n\tstruct dw_apb_clock_event_device *ced;\n\tu32 irq, rate;\n\tint ret = 0;\n\n\tirq = irq_of_parse_and_map(event_timer, 0);\n\tif (irq == 0)\n\t\tpanic(\"No IRQ for clock event timer\");\n\n\tret = timer_get_base_and_rate(event_timer, &iobase, &rate);\n\tif (ret)\n\t\treturn ret;\n\n\tced = dw_apb_clockevent_init(-1, event_timer->name, 300, iobase, irq,\n\t\t\t\t     rate);\n\tif (!ced)\n\t\treturn -EINVAL;\n\n\tdw_apb_clockevent_register(ced);\n\n\treturn 0;\n}\n\nstatic void __iomem *sched_io_base;\nstatic u32 sched_rate;\n\nstatic int __init add_clocksource(struct device_node *source_timer)\n{\n\tvoid __iomem *iobase;\n\tstruct dw_apb_clocksource *cs;\n\tu32 rate;\n\tint ret;\n\n\tret = timer_get_base_and_rate(source_timer, &iobase, &rate);\n\tif (ret)\n\t\treturn ret;\n\n\tcs = dw_apb_clocksource_init(300, source_timer->name, iobase, rate);\n\tif (!cs)\n\t\treturn -EINVAL;\n\n\tdw_apb_clocksource_start(cs);\n\tdw_apb_clocksource_register(cs);\n\n\t \n\tsched_io_base = iobase + 0x04;\n\tsched_rate = rate;\n\n\treturn 0;\n}\n\nstatic u64 notrace read_sched_clock(void)\n{\n\treturn ~readl_relaxed(sched_io_base);\n}\n\nstatic const struct of_device_id sptimer_ids[] __initconst = {\n\t{ .compatible = \"picochip,pc3x2-rtc\" },\n\t{   },\n};\n\nstatic void __init init_sched_clock(void)\n{\n\tstruct device_node *sched_timer;\n\n\tsched_timer = of_find_matching_node(NULL, sptimer_ids);\n\tif (sched_timer) {\n\t\ttimer_get_base_and_rate(sched_timer, &sched_io_base,\n\t\t\t\t\t&sched_rate);\n\t\tof_node_put(sched_timer);\n\t}\n\n\tsched_clock_register(read_sched_clock, 32, sched_rate);\n}\n\n#ifdef CONFIG_ARM\nstatic unsigned long dw_apb_delay_timer_read(void)\n{\n\treturn ~readl_relaxed(sched_io_base);\n}\n\nstatic struct delay_timer dw_apb_delay_timer = {\n\t.read_current_timer\t= dw_apb_delay_timer_read,\n};\n#endif\n\nstatic int num_called;\nstatic int __init dw_apb_timer_init(struct device_node *timer)\n{\n\tint ret = 0;\n\n\tswitch (num_called) {\n\tcase 1:\n\t\tpr_debug(\"%s: found clocksource timer\\n\", __func__);\n\t\tret = add_clocksource(timer);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tinit_sched_clock();\n#ifdef CONFIG_ARM\n\t\tdw_apb_delay_timer.freq = sched_rate;\n\t\tregister_current_timer_delay(&dw_apb_delay_timer);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: found clockevent timer\\n\", __func__);\n\t\tret = add_clockevent(timer);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tnum_called++;\n\n\treturn 0;\n}\nTIMER_OF_DECLARE(pc3x2_timer, \"picochip,pc3x2-timer\", dw_apb_timer_init);\nTIMER_OF_DECLARE(apb_timer_osc, \"snps,dw-apb-timer-osc\", dw_apb_timer_init);\nTIMER_OF_DECLARE(apb_timer_sp, \"snps,dw-apb-timer-sp\", dw_apb_timer_init);\nTIMER_OF_DECLARE(apb_timer, \"snps,dw-apb-timer\", dw_apb_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}