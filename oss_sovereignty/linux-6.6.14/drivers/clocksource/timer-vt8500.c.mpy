{
  "module_name": "timer-vt8500.c",
  "hash_id": "083faab0db13765c22685cc3277168e6c46b8531c40a39a267246a1097d62b2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-vt8500.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/delay.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#define VT8500_TIMER_OFFSET\t0x0100\n#define VT8500_TIMER_HZ\t\t3000000\n#define TIMER_MATCH_VAL\t\t0x0000\n#define TIMER_COUNT_VAL\t\t0x0010\n#define TIMER_STATUS_VAL\t0x0014\n#define TIMER_IER_VAL\t\t0x001c\t\t \n#define TIMER_CTRL_VAL\t\t0x0020\n#define TIMER_AS_VAL\t\t0x0024\t\t \n#define TIMER_COUNT_R_ACTIVE\t(1 << 5)\t \n#define TIMER_COUNT_W_ACTIVE\t(1 << 4)\t \n#define TIMER_MATCH_W_ACTIVE\t(1 << 0)\t \n\n#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)\n\n#define MIN_OSCR_DELTA\t\t16\n\nstatic void __iomem *regbase;\n\nstatic u64 vt8500_timer_read(struct clocksource *cs)\n{\n\tint loops = msecs_to_loops(10);\n\twritel(3, regbase + TIMER_CTRL_VAL);\n\twhile ((readl((regbase + TIMER_AS_VAL)) & TIMER_COUNT_R_ACTIVE)\n\t\t\t\t\t\t&& --loops)\n\t\tcpu_relax();\n\treturn readl(regbase + TIMER_COUNT_VAL);\n}\n\nstatic struct clocksource clocksource = {\n\t.name           = \"vt8500_timer\",\n\t.rating         = 200,\n\t.read           = vt8500_timer_read,\n\t.mask           = CLOCKSOURCE_MASK(32),\n\t.flags          = CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int vt8500_timer_set_next_event(unsigned long cycles,\n\t\t\t\t    struct clock_event_device *evt)\n{\n\tint loops = msecs_to_loops(10);\n\tu64 alarm = clocksource.read(&clocksource) + cycles;\n\twhile ((readl(regbase + TIMER_AS_VAL) & TIMER_MATCH_W_ACTIVE)\n\t\t\t\t\t\t&& --loops)\n\t\tcpu_relax();\n\twritel((unsigned long)alarm, regbase + TIMER_MATCH_VAL);\n\n\tif ((signed)(alarm - clocksource.read(&clocksource)) <= MIN_OSCR_DELTA)\n\t\treturn -ETIME;\n\n\twritel(1, regbase + TIMER_IER_VAL);\n\n\treturn 0;\n}\n\nstatic int vt8500_shutdown(struct clock_event_device *evt)\n{\n\twritel(readl(regbase + TIMER_CTRL_VAL) | 1, regbase + TIMER_CTRL_VAL);\n\twritel(0, regbase + TIMER_IER_VAL);\n\treturn 0;\n}\n\nstatic struct clock_event_device clockevent = {\n\t.name\t\t\t= \"vt8500_timer\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 200,\n\t.set_next_event\t\t= vt8500_timer_set_next_event,\n\t.set_state_shutdown\t= vt8500_shutdown,\n\t.set_state_oneshot\t= vt8500_shutdown,\n};\n\nstatic irqreturn_t vt8500_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\twritel(0xf, regbase + TIMER_STATUS_VAL);\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init vt8500_timer_init(struct device_node *np)\n{\n\tint timer_irq, ret;\n\n\tregbase = of_iomap(np, 0);\n\tif (!regbase) {\n\t\tpr_err(\"%s: Missing iobase description in Device Tree\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\treturn -ENXIO;\n\t}\n\n\ttimer_irq = irq_of_parse_and_map(np, 0);\n\tif (!timer_irq) {\n\t\tpr_err(\"%s: Missing irq description in Device Tree\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(1, regbase + TIMER_CTRL_VAL);\n\twritel(0xf, regbase + TIMER_STATUS_VAL);\n\twritel(~0, regbase + TIMER_MATCH_VAL);\n\n\tret = clocksource_register_hz(&clocksource, VT8500_TIMER_HZ);\n\tif (ret) {\n\t\tpr_err(\"%s: clocksource_register failed for %s\\n\",\n\t\t       __func__, clocksource.name);\n\t\treturn ret;\n\t}\n\n\tclockevent.cpumask = cpumask_of(0);\n\n\tret = request_irq(timer_irq, vt8500_timer_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL, \"vt8500_timer\",\n\t\t\t  &clockevent);\n\tif (ret) {\n\t\tpr_err(\"%s: setup_irq failed for %s\\n\", __func__,\n\t\t\t\t\t\t\tclockevent.name);\n\t\treturn ret;\n\t}\n\n\tclockevents_config_and_register(&clockevent, VT8500_TIMER_HZ,\n\t\t\t\t\tMIN_OSCR_DELTA * 2, 0xf0000000);\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(vt8500, \"via,vt8500-timer\", vt8500_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}