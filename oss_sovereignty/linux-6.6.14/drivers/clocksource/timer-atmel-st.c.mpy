{
  "module_name": "timer-atmel-st.c",
  "hash_id": "63c19399d2f34a9fe43cda49764fc6d9e372c2e9e5c2e3a825b5216064e6c448",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-atmel-st.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/export.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/atmel-st.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n\nstatic unsigned long last_crtr;\nstatic u32 irqmask;\nstatic struct clock_event_device clkevt;\nstatic struct regmap *regmap_st;\nstatic int timer_latch;\n\n \nstatic inline unsigned long read_CRTR(void)\n{\n\tunsigned int x1, x2;\n\n\tregmap_read(regmap_st, AT91_ST_CRTR, &x1);\n\tdo {\n\t\tregmap_read(regmap_st, AT91_ST_CRTR, &x2);\n\t\tif (x1 == x2)\n\t\t\tbreak;\n\t\tx1 = x2;\n\t} while (1);\n\treturn x1;\n}\n\n \nstatic irqreturn_t at91rm9200_timer_interrupt(int irq, void *dev_id)\n{\n\tu32 sr;\n\n\tregmap_read(regmap_st, AT91_ST_SR, &sr);\n\tsr &= irqmask;\n\n\t \n\tWARN_ON_ONCE(!irqs_disabled());\n\n\t \n\tif (sr & AT91_ST_ALMS) {\n\t\tclkevt.event_handler(&clkevt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (sr & AT91_ST_PITS) {\n\t\tu32\tcrtr = read_CRTR();\n\n\t\twhile (((crtr - last_crtr) & AT91_ST_CRTV) >= timer_latch) {\n\t\t\tlast_crtr += timer_latch;\n\t\t\tclkevt.event_handler(&clkevt);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\treturn IRQ_NONE;\n}\n\nstatic u64 read_clk32k(struct clocksource *cs)\n{\n\treturn read_CRTR();\n}\n\nstatic struct clocksource clk32k = {\n\t.name\t\t= \"32k_counter\",\n\t.rating\t\t= 150,\n\t.read\t\t= read_clk32k,\n\t.mask\t\t= CLOCKSOURCE_MASK(20),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic void clkdev32k_disable_and_flush_irq(void)\n{\n\tunsigned int val;\n\n\t \n\tregmap_write(regmap_st, AT91_ST_IDR, AT91_ST_PITS | AT91_ST_ALMS);\n\tregmap_read(regmap_st, AT91_ST_SR, &val);\n\tlast_crtr = read_CRTR();\n}\n\nstatic int clkevt32k_shutdown(struct clock_event_device *evt)\n{\n\tclkdev32k_disable_and_flush_irq();\n\tirqmask = 0;\n\tregmap_write(regmap_st, AT91_ST_IER, irqmask);\n\treturn 0;\n}\n\nstatic int clkevt32k_set_oneshot(struct clock_event_device *dev)\n{\n\tclkdev32k_disable_and_flush_irq();\n\n\t \n\tirqmask = AT91_ST_ALMS;\n\tregmap_write(regmap_st, AT91_ST_RTAR, last_crtr);\n\tregmap_write(regmap_st, AT91_ST_IER, irqmask);\n\treturn 0;\n}\n\nstatic int clkevt32k_set_periodic(struct clock_event_device *dev)\n{\n\tclkdev32k_disable_and_flush_irq();\n\n\t \n\tirqmask = AT91_ST_PITS;\n\tregmap_write(regmap_st, AT91_ST_PIMR, timer_latch);\n\tregmap_write(regmap_st, AT91_ST_IER, irqmask);\n\treturn 0;\n}\n\nstatic int\nclkevt32k_next_event(unsigned long delta, struct clock_event_device *dev)\n{\n\tu32\t\talm;\n\tunsigned int\tval;\n\n\tBUG_ON(delta < 2);\n\n\t \n\talm = read_CRTR();\n\n\t \n\tregmap_write(regmap_st, AT91_ST_RTAR, alm);\n\tregmap_read(regmap_st, AT91_ST_SR, &val);\n\n\t \n\talm += delta;\n\tregmap_write(regmap_st, AT91_ST_RTAR, alm);\n\n\treturn 0;\n}\n\nstatic struct clock_event_device clkevt = {\n\t.name\t\t\t= \"at91_tick\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.rating\t\t\t= 150,\n\t.set_next_event\t\t= clkevt32k_next_event,\n\t.set_state_shutdown\t= clkevt32k_shutdown,\n\t.set_state_periodic\t= clkevt32k_set_periodic,\n\t.set_state_oneshot\t= clkevt32k_set_oneshot,\n\t.tick_resume\t\t= clkevt32k_shutdown,\n};\n\n \nstatic int __init atmel_st_timer_init(struct device_node *node)\n{\n\tstruct clk *sclk;\n\tunsigned int sclk_rate, val;\n\tint irq, ret;\n\n\tregmap_st = syscon_node_to_regmap(node);\n\tif (IS_ERR(regmap_st)) {\n\t\tpr_err(\"Unable to get regmap\\n\");\n\t\treturn PTR_ERR(regmap_st);\n\t}\n\n\t \n\tregmap_write(regmap_st, AT91_ST_IDR,\n\t\tAT91_ST_PITS | AT91_ST_WDOVF | AT91_ST_RTTINC | AT91_ST_ALMS);\n\tregmap_read(regmap_st, AT91_ST_SR, &val);\n\n\t \n\tirq  = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tpr_err(\"Unable to get IRQ from DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = request_irq(irq, at91rm9200_timer_interrupt,\n\t\t\t  IRQF_SHARED | IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t  \"at91_tick\", regmap_st);\n\tif (ret) {\n\t\tpr_err(\"Unable to setup IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tsclk = of_clk_get(node, 0);\n\tif (IS_ERR(sclk)) {\n\t\tpr_err(\"Unable to get slow clock\\n\");\n\t\treturn PTR_ERR(sclk);\n\t}\n\n\tret = clk_prepare_enable(sclk);\n\tif (ret) {\n\t\tpr_err(\"Could not enable slow clock\\n\");\n\t\treturn ret;\n\t}\n\n\tsclk_rate = clk_get_rate(sclk);\n\tif (!sclk_rate) {\n\t\tpr_err(\"Invalid slow clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttimer_latch = (sclk_rate + HZ / 2) / HZ;\n\n\t \n\tregmap_write(regmap_st, AT91_ST_RTMR, 1);\n\n\t \n\tclkevt.cpumask = cpumask_of(0);\n\tclockevents_config_and_register(&clkevt, sclk_rate,\n\t\t\t\t\t2, AT91_ST_ALMV);\n\n\t \n\treturn clocksource_register_hz(&clk32k, sclk_rate);\n}\nTIMER_OF_DECLARE(atmel_st_timer, \"atmel,at91rm9200-st\",\n\t\t       atmel_st_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}