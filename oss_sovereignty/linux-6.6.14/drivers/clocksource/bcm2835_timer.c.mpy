{
  "module_name": "bcm2835_timer.c",
  "hash_id": "8ce1d5e1f8378f4816cd907daf9d8623810e1adb5abb6cb59af06a40dc3b5967",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/bcm2835_timer.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sched_clock.h>\n\n#include <asm/irq.h>\n\n#define REG_CONTROL\t0x00\n#define REG_COUNTER_LO\t0x04\n#define REG_COUNTER_HI\t0x08\n#define REG_COMPARE(n)\t(0x0c + (n) * 4)\n#define MAX_TIMER\t3\n#define DEFAULT_TIMER\t3\n\nstruct bcm2835_timer {\n\tvoid __iomem *control;\n\tvoid __iomem *compare;\n\tint match_mask;\n\tstruct clock_event_device evt;\n};\n\nstatic void __iomem *system_clock __read_mostly;\n\nstatic u64 notrace bcm2835_sched_read(void)\n{\n\treturn readl_relaxed(system_clock);\n}\n\nstatic int bcm2835_time_set_next_event(unsigned long event,\n\tstruct clock_event_device *evt_dev)\n{\n\tstruct bcm2835_timer *timer = container_of(evt_dev,\n\t\tstruct bcm2835_timer, evt);\n\twritel_relaxed(readl_relaxed(system_clock) + event,\n\t\ttimer->compare);\n\treturn 0;\n}\n\nstatic irqreturn_t bcm2835_time_interrupt(int irq, void *dev_id)\n{\n\tstruct bcm2835_timer *timer = dev_id;\n\tvoid (*event_handler)(struct clock_event_device *);\n\tif (readl_relaxed(timer->control) & timer->match_mask) {\n\t\twritel_relaxed(timer->match_mask, timer->control);\n\n\t\tevent_handler = READ_ONCE(timer->evt.event_handler);\n\t\tif (event_handler)\n\t\t\tevent_handler(&timer->evt);\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic int __init bcm2835_timer_init(struct device_node *node)\n{\n\tvoid __iomem *base;\n\tu32 freq;\n\tint irq, ret;\n\tstruct bcm2835_timer *timer;\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\tpr_err(\"Can't remap registers\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = of_property_read_u32(node, \"clock-frequency\", &freq);\n\tif (ret) {\n\t\tpr_err(\"Can't read clock-frequency\\n\");\n\t\tgoto err_iounmap;\n\t}\n\n\tsystem_clock = base + REG_COUNTER_LO;\n\tsched_clock_register(bcm2835_sched_read, 32, freq);\n\n\tclocksource_mmio_init(base + REG_COUNTER_LO, node->name,\n\t\tfreq, 300, 32, clocksource_mmio_readl_up);\n\n\tirq = irq_of_parse_and_map(node, DEFAULT_TIMER);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't parse IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_iounmap;\n\t}\n\n\ttimer = kzalloc(sizeof(*timer), GFP_KERNEL);\n\tif (!timer) {\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\ttimer->control = base + REG_CONTROL;\n\ttimer->compare = base + REG_COMPARE(DEFAULT_TIMER);\n\ttimer->match_mask = BIT(DEFAULT_TIMER);\n\ttimer->evt.name = node->name;\n\ttimer->evt.rating = 300;\n\ttimer->evt.features = CLOCK_EVT_FEAT_ONESHOT;\n\ttimer->evt.set_next_event = bcm2835_time_set_next_event;\n\ttimer->evt.cpumask = cpumask_of(0);\n\n\tret = request_irq(irq, bcm2835_time_interrupt, IRQF_TIMER | IRQF_SHARED,\n\t\t\t  node->name, timer);\n\tif (ret) {\n\t\tpr_err(\"Can't set up timer IRQ\\n\");\n\t\tgoto err_timer_free;\n\t}\n\n\tclockevents_config_and_register(&timer->evt, freq, 0xf, 0xffffffff);\n\n\tpr_info(\"bcm2835: system timer (irq = %d)\\n\", irq);\n\n\treturn 0;\n\nerr_timer_free:\n\tkfree(timer);\n\nerr_iounmap:\n\tiounmap(base);\n\treturn ret;\n}\nTIMER_OF_DECLARE(bcm2835, \"brcm,bcm2835-system-timer\",\n\t\t\tbcm2835_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}