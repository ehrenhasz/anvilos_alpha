{
  "module_name": "timer-qcom.c",
  "hash_id": "3427c95a451fd7053f8013134dfbe848d8c4ad6a50359c4da6d6a1538a48181d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-qcom.c",
  "human_readable_source": "\n \n\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#include <asm/delay.h>\n\n#define TIMER_MATCH_VAL\t\t\t0x0000\n#define TIMER_COUNT_VAL\t\t\t0x0004\n#define TIMER_ENABLE\t\t\t0x0008\n#define TIMER_ENABLE_CLR_ON_MATCH_EN\tBIT(1)\n#define TIMER_ENABLE_EN\t\t\tBIT(0)\n#define TIMER_CLEAR\t\t\t0x000C\n#define DGT_CLK_CTL\t\t\t0x10\n#define DGT_CLK_CTL_DIV_4\t\t0x3\n#define TIMER_STS_GPT0_CLR_PEND\t\tBIT(10)\n\n#define GPT_HZ 32768\n\nstatic void __iomem *event_base;\nstatic void __iomem *sts_base;\n\nstatic irqreturn_t msm_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\t \n\tif (clockevent_state_oneshot(evt)) {\n\t\tu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\n\t\tctrl &= ~TIMER_ENABLE_EN;\n\t\twritel_relaxed(ctrl, event_base + TIMER_ENABLE);\n\t}\n\tevt->event_handler(evt);\n\treturn IRQ_HANDLED;\n}\n\nstatic int msm_timer_set_next_event(unsigned long cycles,\n\t\t\t\t    struct clock_event_device *evt)\n{\n\tu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\n\n\tctrl &= ~TIMER_ENABLE_EN;\n\twritel_relaxed(ctrl, event_base + TIMER_ENABLE);\n\n\twritel_relaxed(ctrl, event_base + TIMER_CLEAR);\n\twritel_relaxed(cycles, event_base + TIMER_MATCH_VAL);\n\n\tif (sts_base)\n\t\twhile (readl_relaxed(sts_base) & TIMER_STS_GPT0_CLR_PEND)\n\t\t\tcpu_relax();\n\n\twritel_relaxed(ctrl | TIMER_ENABLE_EN, event_base + TIMER_ENABLE);\n\treturn 0;\n}\n\nstatic int msm_timer_shutdown(struct clock_event_device *evt)\n{\n\tu32 ctrl;\n\n\tctrl = readl_relaxed(event_base + TIMER_ENABLE);\n\tctrl &= ~(TIMER_ENABLE_EN | TIMER_ENABLE_CLR_ON_MATCH_EN);\n\twritel_relaxed(ctrl, event_base + TIMER_ENABLE);\n\treturn 0;\n}\n\nstatic struct clock_event_device __percpu *msm_evt;\n\nstatic void __iomem *source_base;\n\nstatic notrace u64 msm_read_timer_count(struct clocksource *cs)\n{\n\treturn readl_relaxed(source_base + TIMER_COUNT_VAL);\n}\n\nstatic struct clocksource msm_clocksource = {\n\t.name\t= \"dg_timer\",\n\t.rating\t= 300,\n\t.read\t= msm_read_timer_count,\n\t.mask\t= CLOCKSOURCE_MASK(32),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int msm_timer_irq;\nstatic int msm_timer_has_ppi;\n\nstatic int msm_local_timer_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);\n\tint err;\n\n\tevt->irq = msm_timer_irq;\n\tevt->name = \"msm_timer\";\n\tevt->features = CLOCK_EVT_FEAT_ONESHOT;\n\tevt->rating = 200;\n\tevt->set_state_shutdown = msm_timer_shutdown;\n\tevt->set_state_oneshot = msm_timer_shutdown;\n\tevt->tick_resume = msm_timer_shutdown;\n\tevt->set_next_event = msm_timer_set_next_event;\n\tevt->cpumask = cpumask_of(cpu);\n\n\tclockevents_config_and_register(evt, GPT_HZ, 4, 0xffffffff);\n\n\tif (msm_timer_has_ppi) {\n\t\tenable_percpu_irq(evt->irq, IRQ_TYPE_EDGE_RISING);\n\t} else {\n\t\terr = request_irq(evt->irq, msm_timer_interrupt,\n\t\t\t\tIRQF_TIMER | IRQF_NOBALANCING |\n\t\t\t\tIRQF_TRIGGER_RISING, \"gp_timer\", evt);\n\t\tif (err)\n\t\t\tpr_err(\"request_irq failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int msm_local_timer_dying_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);\n\n\tevt->set_state_shutdown(evt);\n\tdisable_percpu_irq(evt->irq);\n\treturn 0;\n}\n\nstatic u64 notrace msm_sched_clock_read(void)\n{\n\treturn msm_clocksource.read(&msm_clocksource);\n}\n\nstatic unsigned long msm_read_current_timer(void)\n{\n\treturn msm_clocksource.read(&msm_clocksource);\n}\n\nstatic struct delay_timer msm_delay_timer = {\n\t.read_current_timer = msm_read_current_timer,\n};\n\nstatic int __init msm_timer_init(u32 dgt_hz, int sched_bits, int irq,\n\t\t\t\t  bool percpu)\n{\n\tstruct clocksource *cs = &msm_clocksource;\n\tint res = 0;\n\n\tmsm_timer_irq = irq;\n\tmsm_timer_has_ppi = percpu;\n\n\tmsm_evt = alloc_percpu(struct clock_event_device);\n\tif (!msm_evt) {\n\t\tpr_err(\"memory allocation failed for clockevents\\n\");\n\t\tgoto err;\n\t}\n\n\tif (percpu)\n\t\tres = request_percpu_irq(irq, msm_timer_interrupt,\n\t\t\t\t\t \"gp_timer\", msm_evt);\n\n\tif (res) {\n\t\tpr_err(\"request_percpu_irq failed\\n\");\n\t} else {\n\t\t \n\t\tres = cpuhp_setup_state(CPUHP_AP_QCOM_TIMER_STARTING,\n\t\t\t\t\t\"clockevents/qcom/timer:starting\",\n\t\t\t\t\tmsm_local_timer_starting_cpu,\n\t\t\t\t\tmsm_local_timer_dying_cpu);\n\t\tif (res) {\n\t\t\tfree_percpu_irq(irq, msm_evt);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\twritel_relaxed(TIMER_ENABLE_EN, source_base + TIMER_ENABLE);\n\tres = clocksource_register_hz(cs, dgt_hz);\n\tif (res)\n\t\tpr_err(\"clocksource_register failed\\n\");\n\tsched_clock_register(msm_sched_clock_read, sched_bits, dgt_hz);\n\tmsm_delay_timer.freq = dgt_hz;\n\tregister_current_timer_delay(&msm_delay_timer);\n\n\treturn res;\n}\n\nstatic int __init msm_dt_timer_init(struct device_node *np)\n{\n\tu32 freq;\n\tint irq, ret;\n\tstruct resource res;\n\tu32 percpu_offset;\n\tvoid __iomem *base;\n\tvoid __iomem *cpu0_base;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_err(\"Failed to map event base\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tirq = irq_of_parse_and_map(np, 1);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"cpu-offset\", &percpu_offset))\n\t\tpercpu_offset = 0;\n\n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret) {\n\t\tpr_err(\"Failed to parse DGT resource\\n\");\n\t\treturn ret;\n\t}\n\n\tcpu0_base = ioremap(res.start + percpu_offset, resource_size(&res));\n\tif (!cpu0_base) {\n\t\tpr_err(\"Failed to map source base\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &freq)) {\n\t\tpr_err(\"Unknown frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tevent_base = base + 0x4;\n\tsts_base = base + 0x88;\n\tsource_base = cpu0_base + 0x24;\n\tfreq /= 4;\n\twritel_relaxed(DGT_CLK_CTL_DIV_4, source_base + DGT_CLK_CTL);\n\n\treturn msm_timer_init(freq, 32, irq, !!percpu_offset);\n}\nTIMER_OF_DECLARE(kpss_timer, \"qcom,kpss-timer\", msm_dt_timer_init);\nTIMER_OF_DECLARE(scss_timer, \"qcom,scss-timer\", msm_dt_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}