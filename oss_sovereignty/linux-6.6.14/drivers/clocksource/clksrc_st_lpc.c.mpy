{
  "module_name": "clksrc_st_lpc.c",
  "hash_id": "964dc717e8070eb61a1adf566227c75bf71420c0153e5a9f6ed337aa5fd985af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/clksrc_st_lpc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/of_address.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/mfd/st-lpc.h>\n\n \n#define LPC_LPT_LSB_OFF\t\t0x400\n#define LPC_LPT_MSB_OFF\t\t0x404\n#define LPC_LPT_START_OFF\t0x408\n\nstatic struct st_clksrc_ddata {\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*base;\n} ddata;\n\nstatic void __init st_clksrc_reset(void)\n{\n\twritel_relaxed(0, ddata.base + LPC_LPT_START_OFF);\n\twritel_relaxed(0, ddata.base + LPC_LPT_MSB_OFF);\n\twritel_relaxed(0, ddata.base + LPC_LPT_LSB_OFF);\n\twritel_relaxed(1, ddata.base + LPC_LPT_START_OFF);\n}\n\nstatic u64 notrace st_clksrc_sched_clock_read(void)\n{\n\treturn (u64)readl_relaxed(ddata.base + LPC_LPT_LSB_OFF);\n}\n\nstatic int __init st_clksrc_init(void)\n{\n\tunsigned long rate;\n\tint ret;\n\n\tst_clksrc_reset();\n\n\trate = clk_get_rate(ddata.clk);\n\n\tsched_clock_register(st_clksrc_sched_clock_read, 32, rate);\n\n\tret = clocksource_mmio_init(ddata.base + LPC_LPT_LSB_OFF,\n\t\t\t\t    \"clksrc-st-lpc\", rate, 300, 32,\n\t\t\t\t    clocksource_mmio_readl_up);\n\tif (ret) {\n\t\tpr_err(\"clksrc-st-lpc: Failed to register clocksource\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init st_clksrc_setup_clk(struct device_node *np)\n{\n\tstruct clk *clk;\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"clksrc-st-lpc: Failed to get LPC clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tif (clk_prepare_enable(clk)) {\n\t\tpr_err(\"clksrc-st-lpc: Failed to enable LPC clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!clk_get_rate(clk)) {\n\t\tpr_err(\"clksrc-st-lpc: Failed to get LPC clock rate\\n\");\n\t\tclk_disable_unprepare(clk);\n\t\treturn -EINVAL;\n\t}\n\n\tddata.clk = clk;\n\n\treturn 0;\n}\n\nstatic int __init st_clksrc_of_register(struct device_node *np)\n{\n\tint ret;\n\tuint32_t mode;\n\n\tret = of_property_read_u32(np, \"st,lpc-mode\", &mode);\n\tif (ret) {\n\t\tpr_err(\"clksrc-st-lpc: An LPC mode must be provided\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (mode != ST_LPC_MODE_CLKSRC)\n\t\treturn 0;\n\n\tddata.base = of_iomap(np, 0);\n\tif (!ddata.base) {\n\t\tpr_err(\"clksrc-st-lpc: Unable to map iomem\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = st_clksrc_setup_clk(np);\n\tif (ret) {\n\t\tiounmap(ddata.base);\n\t\treturn ret;\n\t}\n\n\tret = st_clksrc_init();\n\tif (ret) {\n\t\tclk_disable_unprepare(ddata.clk);\n\t\tclk_put(ddata.clk);\n\t\tiounmap(ddata.base);\n\t\treturn ret;\n\t}\n\n\tpr_info(\"clksrc-st-lpc: clocksource initialised - running @ %luHz\\n\",\n\t\tclk_get_rate(ddata.clk));\n\n\treturn ret;\n}\nTIMER_OF_DECLARE(ddata, \"st,stih407-lpc\", st_clksrc_of_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}