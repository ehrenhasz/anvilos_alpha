{
  "module_name": "arc_timer.c",
  "hash_id": "47e685397f6c42ae59fc6c3276dd885bc2a7d79b367ff23d657cd14bdd74c454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/arc_timer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/cpu.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n\n#include <soc/arc/timers.h>\n#include <soc/arc/mcip.h>\n\n\nstatic unsigned long arc_timer_freq;\n\nstatic int noinline arc_get_timer_clk(struct device_node *node)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"timer missing clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"Couldn't enable parent clk\\n\");\n\t\treturn ret;\n\t}\n\n\tarc_timer_freq = clk_get_rate(clk);\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_ARC_TIMERS_64BIT\n\nstatic u64 arc_read_gfrc(struct clocksource *cs)\n{\n\tunsigned long flags;\n\tu32 l, h;\n\n\t \n\tlocal_irq_save(flags);\n\n\t__mcip_cmd(CMD_GFRC_READ_LO, 0);\n\tl = read_aux_reg(ARC_REG_MCIP_READBACK);\n\n\t__mcip_cmd(CMD_GFRC_READ_HI, 0);\n\th = read_aux_reg(ARC_REG_MCIP_READBACK);\n\n\tlocal_irq_restore(flags);\n\n\treturn (((u64)h) << 32) | l;\n}\n\nstatic notrace u64 arc_gfrc_clock_read(void)\n{\n\treturn arc_read_gfrc(NULL);\n}\n\nstatic struct clocksource arc_counter_gfrc = {\n\t.name   = \"ARConnect GFRC\",\n\t.rating = 400,\n\t.read   = arc_read_gfrc,\n\t.mask   = CLOCKSOURCE_MASK(64),\n\t.flags  = CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int __init arc_cs_setup_gfrc(struct device_node *node)\n{\n\tstruct mcip_bcr mp;\n\tint ret;\n\n\tREAD_BCR(ARC_REG_MCIP_BCR, mp);\n\tif (!mp.gfrc) {\n\t\tpr_warn(\"Global-64-bit-Ctr clocksource not detected\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = arc_get_timer_clk(node);\n\tif (ret)\n\t\treturn ret;\n\n\tsched_clock_register(arc_gfrc_clock_read, 64, arc_timer_freq);\n\n\treturn clocksource_register_hz(&arc_counter_gfrc, arc_timer_freq);\n}\nTIMER_OF_DECLARE(arc_gfrc, \"snps,archs-timer-gfrc\", arc_cs_setup_gfrc);\n\n#define AUX_RTC_CTRL\t0x103\n#define AUX_RTC_LOW\t0x104\n#define AUX_RTC_HIGH\t0x105\n\nstatic u64 arc_read_rtc(struct clocksource *cs)\n{\n\tunsigned long status;\n\tu32 l, h;\n\n\t \n\tdo {\n\t\tl = read_aux_reg(AUX_RTC_LOW);\n\t\th = read_aux_reg(AUX_RTC_HIGH);\n\t\tstatus = read_aux_reg(AUX_RTC_CTRL);\n\t} while (!(status & BIT(31)));\n\n\treturn (((u64)h) << 32) | l;\n}\n\nstatic notrace u64 arc_rtc_clock_read(void)\n{\n\treturn arc_read_rtc(NULL);\n}\n\nstatic struct clocksource arc_counter_rtc = {\n\t.name   = \"ARCv2 RTC\",\n\t.rating = 350,\n\t.read   = arc_read_rtc,\n\t.mask   = CLOCKSOURCE_MASK(64),\n\t.flags  = CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int __init arc_cs_setup_rtc(struct device_node *node)\n{\n\tstruct bcr_timer timer;\n\tint ret;\n\n\tREAD_BCR(ARC_REG_TIMERS_BCR, timer);\n\tif (!timer.rtc) {\n\t\tpr_warn(\"Local-64-bit-Ctr clocksource not detected\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_SMP)) {\n\t\tpr_warn(\"Local-64-bit-Ctr not usable in SMP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = arc_get_timer_clk(node);\n\tif (ret)\n\t\treturn ret;\n\n\twrite_aux_reg(AUX_RTC_CTRL, 1);\n\n\tsched_clock_register(arc_rtc_clock_read, 64, arc_timer_freq);\n\n\treturn clocksource_register_hz(&arc_counter_rtc, arc_timer_freq);\n}\nTIMER_OF_DECLARE(arc_rtc, \"snps,archs-timer-rtc\", arc_cs_setup_rtc);\n\n#endif\n\n \n\nstatic u64 arc_read_timer1(struct clocksource *cs)\n{\n\treturn (u64) read_aux_reg(ARC_REG_TIMER1_CNT);\n}\n\nstatic notrace u64 arc_timer1_clock_read(void)\n{\n\treturn arc_read_timer1(NULL);\n}\n\nstatic struct clocksource arc_counter_timer1 = {\n\t.name   = \"ARC Timer1\",\n\t.rating = 300,\n\t.read   = arc_read_timer1,\n\t.mask   = CLOCKSOURCE_MASK(32),\n\t.flags  = CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\nstatic int __init arc_cs_setup_timer1(struct device_node *node)\n{\n\tint ret;\n\n\t \n\tif (IS_ENABLED(CONFIG_SMP))\n\t\treturn -EINVAL;\n\n\tret = arc_get_timer_clk(node);\n\tif (ret)\n\t\treturn ret;\n\n\twrite_aux_reg(ARC_REG_TIMER1_LIMIT, ARC_TIMERN_MAX);\n\twrite_aux_reg(ARC_REG_TIMER1_CNT, 0);\n\twrite_aux_reg(ARC_REG_TIMER1_CTRL, ARC_TIMER_CTRL_NH);\n\n\tsched_clock_register(arc_timer1_clock_read, 32, arc_timer_freq);\n\n\treturn clocksource_register_hz(&arc_counter_timer1, arc_timer_freq);\n}\n\n \n\nstatic int arc_timer_irq;\n\n \nstatic void arc_timer_event_setup(unsigned int cycles)\n{\n\twrite_aux_reg(ARC_REG_TIMER0_LIMIT, cycles);\n\twrite_aux_reg(ARC_REG_TIMER0_CNT, 0);\t \n\n\twrite_aux_reg(ARC_REG_TIMER0_CTRL, ARC_TIMER_CTRL_IE | ARC_TIMER_CTRL_NH);\n}\n\n\nstatic int arc_clkevent_set_next_event(unsigned long delta,\n\t\t\t\t       struct clock_event_device *dev)\n{\n\tarc_timer_event_setup(delta);\n\treturn 0;\n}\n\nstatic int arc_clkevent_set_periodic(struct clock_event_device *dev)\n{\n\t \n\tarc_timer_event_setup(arc_timer_freq / HZ);\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(struct clock_event_device, arc_clockevent_device) = {\n\t.name\t\t\t= \"ARC Timer0\",\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_PERIODIC,\n\t.rating\t\t\t= 300,\n\t.set_next_event\t\t= arc_clkevent_set_next_event,\n\t.set_state_periodic\t= arc_clkevent_set_periodic,\n};\n\nstatic irqreturn_t timer_irq_handler(int irq, void *dev_id)\n{\n\t \n\tstruct clock_event_device *evt = this_cpu_ptr(&arc_clockevent_device);\n\tint irq_reenable = clockevent_state_periodic(evt);\n\n\t \n\twrite_aux_reg(ARC_REG_TIMER0_CTRL, irq_reenable | ARC_TIMER_CTRL_NH);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int arc_timer_starting_cpu(unsigned int cpu)\n{\n\tstruct clock_event_device *evt = this_cpu_ptr(&arc_clockevent_device);\n\n\tevt->cpumask = cpumask_of(smp_processor_id());\n\n\tclockevents_config_and_register(evt, arc_timer_freq, 0, ARC_TIMERN_MAX);\n\tenable_percpu_irq(arc_timer_irq, 0);\n\treturn 0;\n}\n\nstatic int arc_timer_dying_cpu(unsigned int cpu)\n{\n\tdisable_percpu_irq(arc_timer_irq);\n\treturn 0;\n}\n\n \nstatic int __init arc_clockevent_setup(struct device_node *node)\n{\n\tstruct clock_event_device *evt = this_cpu_ptr(&arc_clockevent_device);\n\tint ret;\n\n\tarc_timer_irq = irq_of_parse_and_map(node, 0);\n\tif (arc_timer_irq <= 0) {\n\t\tpr_err(\"clockevent: missing irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = arc_get_timer_clk(node);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = request_percpu_irq(arc_timer_irq, timer_irq_handler,\n\t\t\t\t \"Timer0 (per-cpu-tick)\", evt);\n\tif (ret) {\n\t\tpr_err(\"clockevent: unable to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ARC_TIMER_STARTING,\n\t\t\t\t\"clockevents/arc/timer:starting\",\n\t\t\t\tarc_timer_starting_cpu,\n\t\t\t\tarc_timer_dying_cpu);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup hotplug state\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int __init arc_of_timer_init(struct device_node *np)\n{\n\tstatic int init_count = 0;\n\tint ret;\n\n\tif (!init_count) {\n\t\tinit_count = 1;\n\t\tret = arc_clockevent_setup(np);\n\t} else {\n\t\tret = arc_cs_setup_timer1(np);\n\t}\n\n\treturn ret;\n}\nTIMER_OF_DECLARE(arc_clkevt, \"snps,arc-timer\", arc_of_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}