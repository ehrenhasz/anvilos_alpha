{
  "module_name": "timer-integrator-ap.c",
  "hash_id": "d62db3add283b1c37cc1f56b818c1654f37fdbcfe74a3572f6092307dcb3c541",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-integrator-ap.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clocksource.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/sched_clock.h>\n\n#include \"timer-sp.h\"\n\nstatic void __iomem * sched_clk_base;\n\nstatic u64 notrace integrator_read_sched_clock(void)\n{\n\treturn -readl(sched_clk_base + TIMER_VALUE);\n}\n\nstatic int __init integrator_clocksource_init(unsigned long inrate,\n\t\t\t\t\t      void __iomem *base)\n{\n\tu32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;\n\tunsigned long rate = inrate;\n\tint ret;\n\n\tif (rate >= 1500000) {\n\t\trate /= 16;\n\t\tctrl |= TIMER_CTRL_DIV16;\n\t}\n\n\twritel(0xffff, base + TIMER_LOAD);\n\twritel(ctrl, base + TIMER_CTRL);\n\n\tret = clocksource_mmio_init(base + TIMER_VALUE, \"timer2\",\n\t\t\t\t    rate, 200, 16, clocksource_mmio_readl_down);\n\tif (ret)\n\t\treturn ret;\n\n\tsched_clk_base = base;\n\tsched_clock_register(integrator_read_sched_clock, 16, rate);\n\n\treturn 0;\n}\n\nstatic unsigned long timer_reload;\nstatic void __iomem * clkevt_base;\n\n \nstatic irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\t \n\twritel(1, clkevt_base + TIMER_INTCLR);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int clkevt_shutdown(struct clock_event_device *evt)\n{\n\tu32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;\n\n\t \n\twritel(ctrl, clkevt_base + TIMER_CTRL);\n\treturn 0;\n}\n\nstatic int clkevt_set_oneshot(struct clock_event_device *evt)\n{\n\tu32 ctrl = readl(clkevt_base + TIMER_CTRL) &\n\t\t   ~(TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC);\n\n\t \n\twritel(ctrl, clkevt_base + TIMER_CTRL);\n\treturn 0;\n}\n\nstatic int clkevt_set_periodic(struct clock_event_device *evt)\n{\n\tu32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;\n\n\t \n\twritel(ctrl, clkevt_base + TIMER_CTRL);\n\n\t \n\twritel(timer_reload, clkevt_base + TIMER_LOAD);\n\tctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\n\twritel(ctrl, clkevt_base + TIMER_CTRL);\n\treturn 0;\n}\n\nstatic int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)\n{\n\tunsigned long ctrl = readl(clkevt_base + TIMER_CTRL);\n\n\twritel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\n\twritel(next, clkevt_base + TIMER_LOAD);\n\twritel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic struct clock_event_device integrator_clockevent = {\n\t.name\t\t\t= \"timer1\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_shutdown\t= clkevt_shutdown,\n\t.set_state_periodic\t= clkevt_set_periodic,\n\t.set_state_oneshot\t= clkevt_set_oneshot,\n\t.tick_resume\t\t= clkevt_shutdown,\n\t.set_next_event\t\t= clkevt_set_next_event,\n\t.rating\t\t\t= 300,\n};\n\nstatic int integrator_clockevent_init(unsigned long inrate,\n\t\t\t\t      void __iomem *base, int irq)\n{\n\tunsigned long rate = inrate;\n\tunsigned int ctrl = 0;\n\tint ret;\n\n\tclkevt_base = base;\n\t \n\tif (rate > 0x100000 * HZ) {\n\t\trate /= 256;\n\t\tctrl |= TIMER_CTRL_DIV256;\n\t} else if (rate > 0x10000 * HZ) {\n\t\trate /= 16;\n\t\tctrl |= TIMER_CTRL_DIV16;\n\t}\n\ttimer_reload = rate / HZ;\n\twritel(ctrl, clkevt_base + TIMER_CTRL);\n\n\tret = request_irq(irq, integrator_timer_interrupt,\n\t\t\t  IRQF_TIMER | IRQF_IRQPOLL, \"timer\",\n\t\t\t  &integrator_clockevent);\n\tif (ret)\n\t\treturn ret;\n\n\tclockevents_config_and_register(&integrator_clockevent,\n\t\t\t\t\trate,\n\t\t\t\t\t1,\n\t\t\t\t\t0xffffU);\n\treturn 0;\n}\n\nstatic int __init integrator_ap_timer_init_of(struct device_node *node)\n{\n\tconst char *path;\n\tvoid __iomem *base;\n\tint err;\n\tint irq;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tstruct device_node *alias_node;\n\n\tbase = of_io_request_and_map(node, 0, \"integrator-timer\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = of_clk_get(node, 0);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"No clock for %pOFn\\n\", node);\n\t\treturn PTR_ERR(clk);\n\t}\n\tclk_prepare_enable(clk);\n\trate = clk_get_rate(clk);\n\twritel(0, base + TIMER_CTRL);\n\n\terr = of_property_read_string(of_aliases,\n\t\t\t\t\"arm,timer-primary\", &path);\n\tif (err) {\n\t\tpr_warn(\"Failed to read property\\n\");\n\t\treturn err;\n\t}\n\n\talias_node = of_find_node_by_path(path);\n\n\t \n\tof_node_put(alias_node);\n\n\tif (node == alias_node)\n\t\t \n\t\treturn integrator_clocksource_init(rate, base);\n\n\terr = of_property_read_string(of_aliases,\n\t\t\t\t\"arm,timer-secondary\", &path);\n\tif (err) {\n\t\tpr_warn(\"Failed to read property\\n\");\n\t\treturn err;\n\t}\n\n\talias_node = of_find_node_by_path(path);\n\n\tof_node_put(alias_node);\n\n\tif (node == alias_node) {\n\t\t \n\t\tirq = irq_of_parse_and_map(node, 0);\n\t\treturn integrator_clockevent_init(rate, base, irq);\n\t}\n\n\tpr_info(\"Timer @%p unused\\n\", base);\n\tclk_disable_unprepare(clk);\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(integrator_ap_timer, \"arm,integrator-timer\",\n\t\t       integrator_ap_timer_init_of);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}