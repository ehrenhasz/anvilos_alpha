{
  "module_name": "timer-msc313e.c",
  "hash_id": "b12cd6ea0a8f64ca7ca15ebd222fce2b3c2ddc308153a0a8a6ee939228eb9739",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-msc313e.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqreturn.h>\n#include <linux/sched_clock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#ifdef CONFIG_ARM\n#include <linux/delay.h>\n#endif\n\n#include \"timer-of.h\"\n\n#define TIMER_NAME \"msc313e_timer\"\n\n#define MSC313E_REG_CTRL\t\t0x00\n#define MSC313E_REG_CTRL_TIMER_EN\tBIT(0)\n#define MSC313E_REG_CTRL_TIMER_TRIG\tBIT(1)\n#define MSC313E_REG_CTRL_TIMER_INT_EN\tBIT(8)\n#define MSC313E_REG_TIMER_MAX_LOW\t0x08\n#define MSC313E_REG_TIMER_MAX_HIGH\t0x0c\n#define MSC313E_REG_COUNTER_LOW\t\t0x10\n#define MSC313E_REG_COUNTER_HIGH\t0x14\n#define MSC313E_REG_TIMER_DIVIDE\t0x18\n\n#define MSC313E_CLK_DIVIDER\t\t9\n#define TIMER_SYNC_TICKS\t\t3\n\n#ifdef CONFIG_ARM\nstruct msc313e_delay {\n\tvoid __iomem *base;\n\tstruct delay_timer delay;\n};\nstatic struct msc313e_delay msc313e_delay;\n#endif\n\nstatic void __iomem *msc313e_clksrc;\n\nstatic void msc313e_timer_stop(void __iomem *base)\n{\n\twritew(0, base + MSC313E_REG_CTRL);\n}\n\nstatic void msc313e_timer_start(void __iomem *base, bool periodic)\n{\n\tu16 reg;\n\n\treg = readw(base + MSC313E_REG_CTRL);\n\tif (periodic)\n\t\treg |= MSC313E_REG_CTRL_TIMER_EN;\n\telse\n\t\treg |= MSC313E_REG_CTRL_TIMER_TRIG;\n\twritew(reg | MSC313E_REG_CTRL_TIMER_INT_EN, base + MSC313E_REG_CTRL);\n}\n\nstatic void msc313e_timer_setup(void __iomem *base, unsigned long delay)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twritew(delay >> 16, base + MSC313E_REG_TIMER_MAX_HIGH);\n\twritew(delay & 0xffff, base + MSC313E_REG_TIMER_MAX_LOW);\n\tlocal_irq_restore(flags);\n}\n\nstatic unsigned long msc313e_timer_current_value(void __iomem *base)\n{\n\tunsigned long flags;\n\tu16 l, h;\n\n\tlocal_irq_save(flags);\n\tl = readw(base + MSC313E_REG_COUNTER_LOW);\n\th = readw(base + MSC313E_REG_COUNTER_HIGH);\n\tlocal_irq_restore(flags);\n\n\treturn (((u32)h) << 16 | l);\n}\n\nstatic int msc313e_timer_clkevt_shutdown(struct clock_event_device *evt)\n{\n\tstruct timer_of *timer = to_timer_of(evt);\n\n\tmsc313e_timer_stop(timer_of_base(timer));\n\n\treturn 0;\n}\n\nstatic int msc313e_timer_clkevt_set_oneshot(struct clock_event_device *evt)\n{\n\tstruct timer_of *timer = to_timer_of(evt);\n\n\tmsc313e_timer_stop(timer_of_base(timer));\n\tmsc313e_timer_start(timer_of_base(timer), false);\n\n\treturn 0;\n}\n\nstatic int msc313e_timer_clkevt_set_periodic(struct clock_event_device *evt)\n{\n\tstruct timer_of *timer = to_timer_of(evt);\n\n\tmsc313e_timer_stop(timer_of_base(timer));\n\tmsc313e_timer_setup(timer_of_base(timer), timer_of_period(timer));\n\tmsc313e_timer_start(timer_of_base(timer), true);\n\n\treturn 0;\n}\n\nstatic int msc313e_timer_clkevt_next_event(unsigned long evt, struct clock_event_device *clkevt)\n{\n\tstruct timer_of *timer = to_timer_of(clkevt);\n\n\tmsc313e_timer_stop(timer_of_base(timer));\n\tmsc313e_timer_setup(timer_of_base(timer), evt);\n\tmsc313e_timer_start(timer_of_base(timer), false);\n\n\treturn 0;\n}\n\nstatic irqreturn_t msc313e_timer_clkevt_irq(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u64 msc313e_timer_clksrc_read(struct clocksource *cs)\n{\n\treturn msc313e_timer_current_value(msc313e_clksrc) & cs->mask;\n}\n\n#ifdef CONFIG_ARM\nstatic unsigned long msc313e_read_delay_timer_read(void)\n{\n\treturn msc313e_timer_current_value(msc313e_delay.base);\n}\n#endif\n\nstatic u64 msc313e_timer_sched_clock_read(void)\n{\n\treturn msc313e_timer_current_value(msc313e_clksrc);\n}\n\nstatic struct clock_event_device msc313e_clkevt = {\n\t.name = TIMER_NAME,\n\t.rating = 300,\n\t.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_shutdown = msc313e_timer_clkevt_shutdown,\n\t.set_state_periodic = msc313e_timer_clkevt_set_periodic,\n\t.set_state_oneshot = msc313e_timer_clkevt_set_oneshot,\n\t.tick_resume = msc313e_timer_clkevt_shutdown,\n\t.set_next_event = msc313e_timer_clkevt_next_event,\n};\n\nstatic int __init msc313e_clkevt_init(struct device_node *np)\n{\n\tint ret;\n\tstruct timer_of *to;\n\n\tto = kzalloc(sizeof(*to), GFP_KERNEL);\n\tif (!to)\n\t\treturn -ENOMEM;\n\n\tto->flags = TIMER_OF_IRQ | TIMER_OF_CLOCK | TIMER_OF_BASE;\n\tto->of_irq.handler = msc313e_timer_clkevt_irq;\n\tret = timer_of_init(np, to);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_device_is_compatible(np, \"sstar,ssd20xd-timer\")) {\n\t\tto->of_clk.rate = clk_get_rate(to->of_clk.clk) / MSC313E_CLK_DIVIDER;\n\t\tto->of_clk.period = DIV_ROUND_UP(to->of_clk.rate, HZ);\n\t\twritew(MSC313E_CLK_DIVIDER - 1, timer_of_base(to) + MSC313E_REG_TIMER_DIVIDE);\n\t}\n\n\tmsc313e_clkevt.cpumask = cpu_possible_mask;\n\tmsc313e_clkevt.irq = to->of_irq.irq;\n\tto->clkevt = msc313e_clkevt;\n\n\tclockevents_config_and_register(&to->clkevt, timer_of_rate(to),\n\t\t\t\t\tTIMER_SYNC_TICKS, 0xffffffff);\n\treturn 0;\n}\n\nstatic int __init msc313e_clksrc_init(struct device_node *np)\n{\n\tstruct timer_of to = { 0 };\n\tint ret;\n\tu16 reg;\n\n\tto.flags = TIMER_OF_BASE | TIMER_OF_CLOCK;\n\tret = timer_of_init(np, &to);\n\tif (ret)\n\t\treturn ret;\n\n\tmsc313e_clksrc = timer_of_base(&to);\n\treg = readw(msc313e_clksrc + MSC313E_REG_CTRL);\n\treg |= MSC313E_REG_CTRL_TIMER_EN;\n\twritew(reg, msc313e_clksrc + MSC313E_REG_CTRL);\n\n#ifdef CONFIG_ARM\n\tmsc313e_delay.base = timer_of_base(&to);\n\tmsc313e_delay.delay.read_current_timer = msc313e_read_delay_timer_read;\n\tmsc313e_delay.delay.freq = timer_of_rate(&to);\n\n\tregister_current_timer_delay(&msc313e_delay.delay);\n#endif\n\n\tsched_clock_register(msc313e_timer_sched_clock_read, 32, timer_of_rate(&to));\n\treturn clocksource_mmio_init(timer_of_base(&to), TIMER_NAME, timer_of_rate(&to), 300, 32,\n\t\t\t\t     msc313e_timer_clksrc_read);\n}\n\nstatic int __init msc313e_timer_init(struct device_node *np)\n{\n\tint ret = 0;\n\tstatic int num_called;\n\n\tswitch (num_called) {\n\tcase 0:\n\t\tret = msc313e_clksrc_init(np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\tret = msc313e_clkevt_init(np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tnum_called++;\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(msc313, \"mstar,msc313e-timer\", msc313e_timer_init);\nTIMER_OF_DECLARE(ssd20xd, \"sstar,ssd20xd-timer\", msc313e_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}