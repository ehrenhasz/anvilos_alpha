{
  "module_name": "hyperv_timer.c",
  "hash_id": "14d6709479167ed4f87239f1b164fb3738557d632c325b2296337c12385220a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/hyperv_timer.c",
  "human_readable_source": "\n\n \n\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/sched_clock.h>\n#include <linux/mm.h>\n#include <linux/cpuhotplug.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/acpi.h>\n#include <linux/hyperv.h>\n#include <clocksource/hyperv_timer.h>\n#include <asm/hyperv-tlfs.h>\n#include <asm/mshyperv.h>\n\nstatic struct clock_event_device __percpu *hv_clock_event;\nstatic u64 hv_sched_clock_offset __ro_after_init;\n\n \nstatic bool direct_mode_enabled;\n\nstatic int stimer0_irq = -1;\nstatic int stimer0_message_sint;\nstatic __maybe_unused DEFINE_PER_CPU(long, stimer0_evt);\n\n \nvoid hv_stimer0_isr(void)\n{\n\tstruct clock_event_device *ce;\n\n\tce = this_cpu_ptr(hv_clock_event);\n\tce->event_handler(ce);\n}\nEXPORT_SYMBOL_GPL(hv_stimer0_isr);\n\n \nstatic irqreturn_t __maybe_unused hv_stimer0_percpu_isr(int irq, void *dev_id)\n{\n\thv_stimer0_isr();\n\treturn IRQ_HANDLED;\n}\n\nstatic int hv_ce_set_next_event(unsigned long delta,\n\t\t\t\tstruct clock_event_device *evt)\n{\n\tu64 current_tick;\n\n\tcurrent_tick = hv_read_reference_counter();\n\tcurrent_tick += delta;\n\thv_set_register(HV_REGISTER_STIMER0_COUNT, current_tick);\n\treturn 0;\n}\n\nstatic int hv_ce_shutdown(struct clock_event_device *evt)\n{\n\thv_set_register(HV_REGISTER_STIMER0_COUNT, 0);\n\thv_set_register(HV_REGISTER_STIMER0_CONFIG, 0);\n\tif (direct_mode_enabled && stimer0_irq >= 0)\n\t\tdisable_percpu_irq(stimer0_irq);\n\n\treturn 0;\n}\n\nstatic int hv_ce_set_oneshot(struct clock_event_device *evt)\n{\n\tunion hv_stimer_config timer_cfg;\n\n\ttimer_cfg.as_uint64 = 0;\n\ttimer_cfg.enable = 1;\n\ttimer_cfg.auto_enable = 1;\n\tif (direct_mode_enabled) {\n\t\t \n\t\ttimer_cfg.direct_mode = 1;\n\t\ttimer_cfg.apic_vector = HYPERV_STIMER0_VECTOR;\n\t\tif (stimer0_irq >= 0)\n\t\t\tenable_percpu_irq(stimer0_irq, IRQ_TYPE_NONE);\n\t} else {\n\t\t \n\t\ttimer_cfg.direct_mode = 0;\n\t\ttimer_cfg.sintx = stimer0_message_sint;\n\t}\n\thv_set_register(HV_REGISTER_STIMER0_CONFIG, timer_cfg.as_uint64);\n\treturn 0;\n}\n\n \nstatic int hv_stimer_init(unsigned int cpu)\n{\n\tstruct clock_event_device *ce;\n\n\tif (!hv_clock_event)\n\t\treturn 0;\n\n\tce = per_cpu_ptr(hv_clock_event, cpu);\n\tce->name = \"Hyper-V clockevent\";\n\tce->features = CLOCK_EVT_FEAT_ONESHOT;\n\tce->cpumask = cpumask_of(cpu);\n\tce->rating = 1000;\n\tce->set_state_shutdown = hv_ce_shutdown;\n\tce->set_state_oneshot = hv_ce_set_oneshot;\n\tce->set_next_event = hv_ce_set_next_event;\n\n\tclockevents_config_and_register(ce,\n\t\t\t\t\tHV_CLOCK_HZ,\n\t\t\t\t\tHV_MIN_DELTA_TICKS,\n\t\t\t\t\tHV_MAX_MAX_DELTA_TICKS);\n\treturn 0;\n}\n\n \nint hv_stimer_cleanup(unsigned int cpu)\n{\n\tstruct clock_event_device *ce;\n\n\tif (!hv_clock_event)\n\t\treturn 0;\n\n\t \n\tce = per_cpu_ptr(hv_clock_event, cpu);\n\tif (direct_mode_enabled)\n\t\thv_ce_shutdown(ce);\n\telse\n\t\tclockevents_unbind_device(ce, cpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hv_stimer_cleanup);\n\n \nvoid __weak hv_setup_stimer0_handler(void (*handler)(void))\n{\n};\n\nvoid __weak hv_remove_stimer0_handler(void)\n{\n};\n\n#ifdef CONFIG_ACPI\n \nstatic int hv_setup_stimer0_irq(void)\n{\n\tint ret;\n\n\tret = acpi_register_gsi(NULL, HYPERV_STIMER0_VECTOR,\n\t\t\tACPI_EDGE_SENSITIVE, ACPI_ACTIVE_HIGH);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register Hyper-V stimer0 GSI. Error %d\", ret);\n\t\treturn ret;\n\t}\n\tstimer0_irq = ret;\n\n\tret = request_percpu_irq(stimer0_irq, hv_stimer0_percpu_isr,\n\t\t\"Hyper-V stimer0\", &stimer0_evt);\n\tif (ret) {\n\t\tpr_err(\"Can't request Hyper-V stimer0 IRQ %d. Error %d\",\n\t\t\tstimer0_irq, ret);\n\t\tacpi_unregister_gsi(stimer0_irq);\n\t\tstimer0_irq = -1;\n\t}\n\treturn ret;\n}\n\nstatic void hv_remove_stimer0_irq(void)\n{\n\tif (stimer0_irq == -1) {\n\t\thv_remove_stimer0_handler();\n\t} else {\n\t\tfree_percpu_irq(stimer0_irq, &stimer0_evt);\n\t\tacpi_unregister_gsi(stimer0_irq);\n\t\tstimer0_irq = -1;\n\t}\n}\n#else\nstatic int hv_setup_stimer0_irq(void)\n{\n\treturn 0;\n}\n\nstatic void hv_remove_stimer0_irq(void)\n{\n}\n#endif\n\n \nint hv_stimer_alloc(bool have_percpu_irqs)\n{\n\tint ret;\n\n\t \n\tif (!(ms_hyperv.features & HV_MSR_SYNTIMER_AVAILABLE))\n\t\treturn -EINVAL;\n\n\thv_clock_event = alloc_percpu(struct clock_event_device);\n\tif (!hv_clock_event)\n\t\treturn -ENOMEM;\n\n\tdirect_mode_enabled = ms_hyperv.misc_features &\n\t\t\tHV_STIMER_DIRECT_MODE_AVAILABLE;\n\n\t \n\tif (!direct_mode_enabled)\n\t\treturn 0;\n\n\tif (have_percpu_irqs) {\n\t\tret = hv_setup_stimer0_irq();\n\t\tif (ret)\n\t\t\tgoto free_clock_event;\n\t} else {\n\t\thv_setup_stimer0_handler(hv_stimer0_isr);\n\t}\n\n\t \n\tret = cpuhp_setup_state(CPUHP_AP_HYPERV_TIMER_STARTING,\n\t\t\t\"clockevents/hyperv/stimer:starting\",\n\t\t\thv_stimer_init, hv_stimer_cleanup);\n\tif (ret < 0) {\n\t\thv_remove_stimer0_irq();\n\t\tgoto free_clock_event;\n\t}\n\treturn ret;\n\nfree_clock_event:\n\tfree_percpu(hv_clock_event);\n\thv_clock_event = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hv_stimer_alloc);\n\n \nvoid hv_stimer_legacy_init(unsigned int cpu, int sint)\n{\n\tif (direct_mode_enabled)\n\t\treturn;\n\n\t \n\tstimer0_message_sint = sint;\n\t(void)hv_stimer_init(cpu);\n}\nEXPORT_SYMBOL_GPL(hv_stimer_legacy_init);\n\n \nvoid hv_stimer_legacy_cleanup(unsigned int cpu)\n{\n\tif (direct_mode_enabled)\n\t\treturn;\n\t(void)hv_stimer_cleanup(cpu);\n}\nEXPORT_SYMBOL_GPL(hv_stimer_legacy_cleanup);\n\n \nvoid hv_stimer_global_cleanup(void)\n{\n\tint\tcpu;\n\n\t \n\tfor_each_present_cpu(cpu) {\n\t\thv_stimer_legacy_cleanup(cpu);\n\t}\n\n\tif (!hv_clock_event)\n\t\treturn;\n\n\tif (direct_mode_enabled) {\n\t\tcpuhp_remove_state(CPUHP_AP_HYPERV_TIMER_STARTING);\n\t\thv_remove_stimer0_irq();\n\t\tstimer0_irq = -1;\n\t}\n\tfree_percpu(hv_clock_event);\n\thv_clock_event = NULL;\n\n}\nEXPORT_SYMBOL_GPL(hv_stimer_global_cleanup);\n\nstatic __always_inline u64 read_hv_clock_msr(void)\n{\n\t \n\treturn hv_raw_get_register(HV_REGISTER_TIME_REF_COUNT);\n}\n\n \n\nstatic union {\n\tstruct ms_hyperv_tsc_page page;\n\tu8 reserved[PAGE_SIZE];\n} tsc_pg __bss_decrypted __aligned(PAGE_SIZE);\n\nstatic struct ms_hyperv_tsc_page *tsc_page = &tsc_pg.page;\nstatic unsigned long tsc_pfn;\n\nunsigned long hv_get_tsc_pfn(void)\n{\n\treturn tsc_pfn;\n}\nEXPORT_SYMBOL_GPL(hv_get_tsc_pfn);\n\nstruct ms_hyperv_tsc_page *hv_get_tsc_page(void)\n{\n\treturn tsc_page;\n}\nEXPORT_SYMBOL_GPL(hv_get_tsc_page);\n\nstatic __always_inline u64 read_hv_clock_tsc(void)\n{\n\tu64 cur_tsc, time;\n\n\t \n\tif (!hv_read_tsc_page_tsc(tsc_page, &cur_tsc, &time))\n\t\ttime = read_hv_clock_msr();\n\n\treturn time;\n}\n\nstatic u64 notrace read_hv_clock_tsc_cs(struct clocksource *arg)\n{\n\treturn read_hv_clock_tsc();\n}\n\nstatic u64 noinstr read_hv_sched_clock_tsc(void)\n{\n\treturn (read_hv_clock_tsc() - hv_sched_clock_offset) *\n\t\t(NSEC_PER_SEC / HV_CLOCK_HZ);\n}\n\nstatic void suspend_hv_clock_tsc(struct clocksource *arg)\n{\n\tunion hv_reference_tsc_msr tsc_msr;\n\n\t \n\ttsc_msr.as_uint64 = hv_get_register(HV_REGISTER_REFERENCE_TSC);\n\ttsc_msr.enable = 0;\n\thv_set_register(HV_REGISTER_REFERENCE_TSC, tsc_msr.as_uint64);\n}\n\n\nstatic void resume_hv_clock_tsc(struct clocksource *arg)\n{\n\tunion hv_reference_tsc_msr tsc_msr;\n\n\t \n\ttsc_msr.as_uint64 = hv_get_register(HV_REGISTER_REFERENCE_TSC);\n\ttsc_msr.enable = 1;\n\ttsc_msr.pfn = tsc_pfn;\n\thv_set_register(HV_REGISTER_REFERENCE_TSC, tsc_msr.as_uint64);\n}\n\n#ifdef HAVE_VDSO_CLOCKMODE_HVCLOCK\nstatic int hv_cs_enable(struct clocksource *cs)\n{\n\tvclocks_set_used(VDSO_CLOCKMODE_HVCLOCK);\n\treturn 0;\n}\n#endif\n\nstatic struct clocksource hyperv_cs_tsc = {\n\t.name\t= \"hyperv_clocksource_tsc_page\",\n\t.rating\t= 500,\n\t.read\t= read_hv_clock_tsc_cs,\n\t.mask\t= CLOCKSOURCE_MASK(64),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n\t.suspend= suspend_hv_clock_tsc,\n\t.resume\t= resume_hv_clock_tsc,\n#ifdef HAVE_VDSO_CLOCKMODE_HVCLOCK\n\t.enable = hv_cs_enable,\n\t.vdso_clock_mode = VDSO_CLOCKMODE_HVCLOCK,\n#else\n\t.vdso_clock_mode = VDSO_CLOCKMODE_NONE,\n#endif\n};\n\nstatic u64 notrace read_hv_clock_msr_cs(struct clocksource *arg)\n{\n\treturn read_hv_clock_msr();\n}\n\nstatic struct clocksource hyperv_cs_msr = {\n\t.name\t= \"hyperv_clocksource_msr\",\n\t.rating\t= 495,\n\t.read\t= read_hv_clock_msr_cs,\n\t.mask\t= CLOCKSOURCE_MASK(64),\n\t.flags\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\n\n \n#ifdef CONFIG_GENERIC_SCHED_CLOCK\nstatic __always_inline void hv_setup_sched_clock(void *sched_clock)\n{\n\t \n\tsched_clock_register(sched_clock, 64, NSEC_PER_SEC);\n}\n#elif defined CONFIG_PARAVIRT\nstatic __always_inline void hv_setup_sched_clock(void *sched_clock)\n{\n\t \n\tparavirt_set_sched_clock(sched_clock);\n}\n#else  \nstatic __always_inline void hv_setup_sched_clock(void *sched_clock) {}\n#endif  \n\nstatic void __init hv_init_tsc_clocksource(void)\n{\n\tunion hv_reference_tsc_msr tsc_msr;\n\n\t \n\tif (ms_hyperv.features & HV_ACCESS_TSC_INVARIANT) {\n\t\thyperv_cs_tsc.rating = 250;\n\t\thyperv_cs_msr.rating = 245;\n\t}\n\n\tif (!(ms_hyperv.features & HV_MSR_REFERENCE_TSC_AVAILABLE))\n\t\treturn;\n\n\thv_read_reference_counter = read_hv_clock_tsc;\n\n\t \n\ttsc_msr.as_uint64 = hv_get_register(HV_REGISTER_REFERENCE_TSC);\n\tif (hv_root_partition)\n\t\ttsc_pfn = tsc_msr.pfn;\n\telse\n\t\ttsc_pfn = HVPFN_DOWN(virt_to_phys(tsc_page));\n\ttsc_msr.enable = 1;\n\ttsc_msr.pfn = tsc_pfn;\n\thv_set_register(HV_REGISTER_REFERENCE_TSC, tsc_msr.as_uint64);\n\n\tclocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);\n\n\t \n\tif (!(ms_hyperv.features & HV_ACCESS_TSC_INVARIANT)) {\n\t\thv_sched_clock_offset = hv_read_reference_counter();\n\t\thv_setup_sched_clock(read_hv_sched_clock_tsc);\n\t}\n}\n\nvoid __init hv_init_clocksource(void)\n{\n\t \n\thv_init_tsc_clocksource();\n\n\tif (ms_hyperv.features & HV_MSR_TIME_REF_COUNT_AVAILABLE)\n\t\tclocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);\n}\n\nvoid __init hv_remap_tsc_clocksource(void)\n{\n\tif (!(ms_hyperv.features & HV_MSR_REFERENCE_TSC_AVAILABLE))\n\t\treturn;\n\n\tif (!hv_root_partition) {\n\t\tWARN(1, \"%s: attempt to remap TSC page in guest partition\\n\",\n\t\t     __func__);\n\t\treturn;\n\t}\n\n\ttsc_page = memremap(tsc_pfn << HV_HYP_PAGE_SHIFT, sizeof(tsc_pg),\n\t\t\t    MEMREMAP_WB);\n\tif (!tsc_page)\n\t\tpr_err(\"Failed to remap Hyper-V TSC page.\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}