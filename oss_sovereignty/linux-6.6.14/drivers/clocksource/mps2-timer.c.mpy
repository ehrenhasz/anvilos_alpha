{
  "module_name": "mps2-timer.c",
  "hash_id": "8ced1ebcc3b0e895e81978f6a8cdc4243414568d44324e72f9e4a43653869089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/mps2-timer.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n\n#define TIMER_CTRL\t\t0x0\n#define TIMER_CTRL_ENABLE\tBIT(0)\n#define TIMER_CTRL_IE\t\tBIT(3)\n\n#define TIMER_VALUE\t\t0x4\n#define TIMER_RELOAD\t\t0x8\n#define TIMER_INT\t\t0xc\n\nstruct clockevent_mps2 {\n\tvoid __iomem *reg;\n\tu32 clock_count_per_tick;\n\tstruct clock_event_device clkevt;\n};\n\nstatic void __iomem *sched_clock_base;\n\nstatic u64 notrace mps2_sched_read(void)\n{\n\treturn ~readl_relaxed(sched_clock_base + TIMER_VALUE);\n}\n\nstatic inline struct clockevent_mps2 *to_mps2_clkevt(struct clock_event_device *c)\n{\n\treturn container_of(c, struct clockevent_mps2, clkevt);\n}\n\nstatic void clockevent_mps2_writel(u32 val, struct clock_event_device *c, u32 offset)\n{\n\twritel_relaxed(val, to_mps2_clkevt(c)->reg + offset);\n}\n\nstatic int mps2_timer_shutdown(struct clock_event_device *ce)\n{\n\tclockevent_mps2_writel(0, ce, TIMER_RELOAD);\n\tclockevent_mps2_writel(0, ce, TIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic int mps2_timer_set_next_event(unsigned long next, struct clock_event_device *ce)\n{\n\tclockevent_mps2_writel(next, ce, TIMER_VALUE);\n\tclockevent_mps2_writel(TIMER_CTRL_IE | TIMER_CTRL_ENABLE, ce, TIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic int mps2_timer_set_periodic(struct clock_event_device *ce)\n{\n\tu32 clock_count_per_tick = to_mps2_clkevt(ce)->clock_count_per_tick;\n\n\tclockevent_mps2_writel(clock_count_per_tick, ce, TIMER_RELOAD);\n\tclockevent_mps2_writel(clock_count_per_tick, ce, TIMER_VALUE);\n\tclockevent_mps2_writel(TIMER_CTRL_IE | TIMER_CTRL_ENABLE, ce, TIMER_CTRL);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mps2_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct clockevent_mps2 *ce = dev_id;\n\tu32 status = readl_relaxed(ce->reg + TIMER_INT);\n\n\tif (!status) {\n\t\tpr_warn(\"spurious interrupt\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\twritel_relaxed(1, ce->reg + TIMER_INT);\n\n\tce->clkevt.event_handler(&ce->clkevt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init mps2_clockevent_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\tstruct clk *clk = NULL;\n\tstruct clockevent_mps2 *ce;\n\tu32 rate;\n\tint irq, ret;\n\tconst char *name = \"mps2-clkevt\";\n\n\tret = of_property_read_u32(np, \"clock-frequency\", &rate);\n\tif (ret) {\n\t\tclk = of_clk_get(np, 0);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tpr_err(\"failed to get clock for clockevent: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to enable clock for clockevent: %d\\n\", ret);\n\t\t\tgoto out_clk_put;\n\t\t}\n\n\t\trate = clk_get_rate(clk);\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tpr_err(\"failed to map register for clockevent: %d\\n\", ret);\n\t\tgoto out_clk_disable;\n\t}\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tret = -ENOENT;\n\t\tpr_err(\"failed to get irq for clockevent: %d\\n\", ret);\n\t\tgoto out_iounmap;\n\t}\n\n\tce = kzalloc(sizeof(*ce), GFP_KERNEL);\n\tif (!ce) {\n\t\tret = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\tce->reg = base;\n\tce->clock_count_per_tick = DIV_ROUND_CLOSEST(rate, HZ);\n\tce->clkevt.irq = irq;\n\tce->clkevt.name = name;\n\tce->clkevt.rating = 200;\n\tce->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\tce->clkevt.cpumask = cpu_possible_mask;\n\tce->clkevt.set_state_shutdown\t= mps2_timer_shutdown;\n\tce->clkevt.set_state_periodic\t= mps2_timer_set_periodic;\n\tce->clkevt.set_state_oneshot\t= mps2_timer_shutdown;\n\tce->clkevt.set_next_event\t= mps2_timer_set_next_event;\n\n\t \n\twritel_relaxed(0, base + TIMER_CTRL);\n\n\tret = request_irq(irq, mps2_timer_interrupt, IRQF_TIMER, name, ce);\n\tif (ret) {\n\t\tpr_err(\"failed to request irq for clockevent: %d\\n\", ret);\n\t\tgoto out_kfree;\n\t}\n\n\tclockevents_config_and_register(&ce->clkevt, rate, 0xf, 0xffffffff);\n\n\treturn 0;\n\nout_kfree:\n\tkfree(ce);\nout_iounmap:\n\tiounmap(base);\nout_clk_disable:\n\t \n\tclk_disable_unprepare(clk);\nout_clk_put:\n\tclk_put(clk);\nout:\n\treturn ret;\n}\n\nstatic int __init mps2_clocksource_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\tstruct clk *clk = NULL;\n\tu32 rate;\n\tint ret;\n\tconst char *name = \"mps2-clksrc\";\n\n\tret = of_property_read_u32(np, \"clock-frequency\", &rate);\n\tif (ret) {\n\t\tclk = of_clk_get(np, 0);\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tpr_err(\"failed to get clock for clocksource: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to enable clock for clocksource: %d\\n\", ret);\n\t\t\tgoto out_clk_put;\n\t\t}\n\n\t\trate = clk_get_rate(clk);\n\t}\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tpr_err(\"failed to map register for clocksource: %d\\n\", ret);\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\twritel_relaxed(0, base + TIMER_CTRL);\n\n\t \n\twritel_relaxed(0xffffffff, base + TIMER_VALUE);\n\twritel_relaxed(0xffffffff, base + TIMER_RELOAD);\n\n\twritel_relaxed(TIMER_CTRL_ENABLE, base + TIMER_CTRL);\n\n\tret = clocksource_mmio_init(base + TIMER_VALUE, name,\n\t\t\t\t    rate, 200, 32,\n\t\t\t\t    clocksource_mmio_readl_down);\n\tif (ret) {\n\t\tpr_err(\"failed to init clocksource: %d\\n\", ret);\n\t\tgoto out_iounmap;\n\t}\n\n\tsched_clock_base = base;\n\tsched_clock_register(mps2_sched_read, 32, rate);\n\n\treturn 0;\n\nout_iounmap:\n\tiounmap(base);\nout_clk_disable:\n\t \n\tclk_disable_unprepare(clk);\nout_clk_put:\n\tclk_put(clk);\nout:\n\treturn ret;\n}\n\nstatic int __init mps2_timer_init(struct device_node *np)\n{\n\tstatic int has_clocksource, has_clockevent;\n\tint ret;\n\n\tif (!has_clocksource) {\n\t\tret = mps2_clocksource_init(np);\n\t\tif (!ret) {\n\t\t\thas_clocksource = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!has_clockevent) {\n\t\tret = mps2_clockevent_init(np);\n\t\tif (!ret) {\n\t\t\thas_clockevent = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nTIMER_OF_DECLARE(mps2_timer, \"arm,mps2-timer\", mps2_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}