{
  "module_name": "timer-fsl-ftm.c",
  "hash_id": "f81fe75a03c8a02ade852b31bc4fbca34660f25ae46b574c6b3d2989f7dfcee0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-fsl-ftm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include <linux/fsl/ftm.h>\n\n#define FTM_SC_CLK(c)\t((c) << FTM_SC_CLK_MASK_SHIFT)\n\nstruct ftm_clock_device {\n\tvoid __iomem *clksrc_base;\n\tvoid __iomem *clkevt_base;\n\tunsigned long periodic_cyc;\n\tunsigned long ps;\n\tbool big_endian;\n};\n\nstatic struct ftm_clock_device *priv;\n\nstatic inline u32 ftm_readl(void __iomem *addr)\n{\n\tif (priv->big_endian)\n\t\treturn ioread32be(addr);\n\telse\n\t\treturn ioread32(addr);\n}\n\nstatic inline void ftm_writel(u32 val, void __iomem *addr)\n{\n\tif (priv->big_endian)\n\t\tiowrite32be(val, addr);\n\telse\n\t\tiowrite32(val, addr);\n}\n\nstatic inline void ftm_counter_enable(void __iomem *base)\n{\n\tu32 val;\n\n\t \n\tval = ftm_readl(base + FTM_SC);\n\tval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\n\tval |= priv->ps | FTM_SC_CLK(1);\n\tftm_writel(val, base + FTM_SC);\n}\n\nstatic inline void ftm_counter_disable(void __iomem *base)\n{\n\tu32 val;\n\n\t \n\tval = ftm_readl(base + FTM_SC);\n\tval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\n\tftm_writel(val, base + FTM_SC);\n}\n\nstatic inline void ftm_irq_acknowledge(void __iomem *base)\n{\n\tu32 val;\n\n\tval = ftm_readl(base + FTM_SC);\n\tval &= ~FTM_SC_TOF;\n\tftm_writel(val, base + FTM_SC);\n}\n\nstatic inline void ftm_irq_enable(void __iomem *base)\n{\n\tu32 val;\n\n\tval = ftm_readl(base + FTM_SC);\n\tval |= FTM_SC_TOIE;\n\tftm_writel(val, base + FTM_SC);\n}\n\nstatic inline void ftm_irq_disable(void __iomem *base)\n{\n\tu32 val;\n\n\tval = ftm_readl(base + FTM_SC);\n\tval &= ~FTM_SC_TOIE;\n\tftm_writel(val, base + FTM_SC);\n}\n\nstatic inline void ftm_reset_counter(void __iomem *base)\n{\n\t \n\tftm_writel(0x00, base + FTM_CNT);\n}\n\nstatic u64 notrace ftm_read_sched_clock(void)\n{\n\treturn ftm_readl(priv->clksrc_base + FTM_CNT);\n}\n\nstatic int ftm_set_next_event(unsigned long delta,\n\t\t\t\tstruct clock_event_device *unused)\n{\n\t \n\tftm_counter_disable(priv->clkevt_base);\n\n\t \n\tftm_reset_counter(priv->clkevt_base);\n\n\t \n\tftm_writel(delta - 1, priv->clkevt_base + FTM_MOD);\n\n\tftm_counter_enable(priv->clkevt_base);\n\n\tftm_irq_enable(priv->clkevt_base);\n\n\treturn 0;\n}\n\nstatic int ftm_set_oneshot(struct clock_event_device *evt)\n{\n\tftm_counter_disable(priv->clkevt_base);\n\treturn 0;\n}\n\nstatic int ftm_set_periodic(struct clock_event_device *evt)\n{\n\tftm_set_next_event(priv->periodic_cyc, evt);\n\treturn 0;\n}\n\nstatic irqreturn_t ftm_evt_interrupt(int irq, void *dev_id)\n{\n\tstruct clock_event_device *evt = dev_id;\n\n\tftm_irq_acknowledge(priv->clkevt_base);\n\n\tif (likely(clockevent_state_oneshot(evt))) {\n\t\tftm_irq_disable(priv->clkevt_base);\n\t\tftm_counter_disable(priv->clkevt_base);\n\t}\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct clock_event_device ftm_clockevent = {\n\t.name\t\t\t= \"Freescale ftm timer\",\n\t.features\t\t= CLOCK_EVT_FEAT_PERIODIC |\n\t\t\t\t  CLOCK_EVT_FEAT_ONESHOT,\n\t.set_state_periodic\t= ftm_set_periodic,\n\t.set_state_oneshot\t= ftm_set_oneshot,\n\t.set_next_event\t\t= ftm_set_next_event,\n\t.rating\t\t\t= 300,\n};\n\nstatic int __init ftm_clockevent_init(unsigned long freq, int irq)\n{\n\tint err;\n\n\tftm_writel(0x00, priv->clkevt_base + FTM_CNTIN);\n\tftm_writel(~0u, priv->clkevt_base + FTM_MOD);\n\n\tftm_reset_counter(priv->clkevt_base);\n\n\terr = request_irq(irq, ftm_evt_interrupt, IRQF_TIMER | IRQF_IRQPOLL,\n\t\t\t  \"Freescale ftm timer\", &ftm_clockevent);\n\tif (err) {\n\t\tpr_err(\"ftm: setup irq failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tftm_clockevent.cpumask = cpumask_of(0);\n\tftm_clockevent.irq = irq;\n\n\tclockevents_config_and_register(&ftm_clockevent,\n\t\t\t\t\tfreq / (1 << priv->ps),\n\t\t\t\t\t1, 0xffff);\n\n\tftm_counter_enable(priv->clkevt_base);\n\n\treturn 0;\n}\n\nstatic int __init ftm_clocksource_init(unsigned long freq)\n{\n\tint err;\n\n\tftm_writel(0x00, priv->clksrc_base + FTM_CNTIN);\n\tftm_writel(~0u, priv->clksrc_base + FTM_MOD);\n\n\tftm_reset_counter(priv->clksrc_base);\n\n\tsched_clock_register(ftm_read_sched_clock, 16, freq / (1 << priv->ps));\n\terr = clocksource_mmio_init(priv->clksrc_base + FTM_CNT, \"fsl-ftm\",\n\t\t\t\t    freq / (1 << priv->ps), 300, 16,\n\t\t\t\t    clocksource_mmio_readl_up);\n\tif (err) {\n\t\tpr_err(\"ftm: init clock source mmio failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tftm_counter_enable(priv->clksrc_base);\n\n\treturn 0;\n}\n\nstatic int __init __ftm_clk_init(struct device_node *np, char *cnt_name,\n\t\t\t\t char *ftm_name)\n{\n\tstruct clk *clk;\n\tint err;\n\n\tclk = of_clk_get_by_name(np, cnt_name);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"ftm: Cannot get \\\"%s\\\": %ld\\n\", cnt_name, PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tpr_err(\"ftm: clock failed to prepare+enable \\\"%s\\\": %d\\n\",\n\t\t\tcnt_name, err);\n\t\treturn err;\n\t}\n\n\tclk = of_clk_get_by_name(np, ftm_name);\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"ftm: Cannot get \\\"%s\\\": %ld\\n\", ftm_name, PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\terr = clk_prepare_enable(clk);\n\tif (err)\n\t\tpr_err(\"ftm: clock failed to prepare+enable \\\"%s\\\": %d\\n\",\n\t\t\tftm_name, err);\n\n\treturn clk_get_rate(clk);\n}\n\nstatic unsigned long __init ftm_clk_init(struct device_node *np)\n{\n\tlong freq;\n\n\tfreq = __ftm_clk_init(np, \"ftm-evt-counter-en\", \"ftm-evt\");\n\tif (freq <= 0)\n\t\treturn 0;\n\n\tfreq = __ftm_clk_init(np, \"ftm-src-counter-en\", \"ftm-src\");\n\tif (freq <= 0)\n\t\treturn 0;\n\n\treturn freq;\n}\n\nstatic int __init ftm_calc_closest_round_cyc(unsigned long freq)\n{\n\tpriv->ps = 0;\n\n\t \n\tdo {\n\t\tpriv->periodic_cyc = DIV_ROUND_CLOSEST(freq,\n\t\t\t\t\t\tHZ * (1 << priv->ps++));\n\t} while (priv->periodic_cyc > 0xFFFF);\n\n\tif (priv->ps > FTM_PS_MAX) {\n\t\tpr_err(\"ftm: the prescaler is %lu > %d\\n\",\n\t\t\t\tpriv->ps, FTM_PS_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init ftm_timer_init(struct device_node *np)\n{\n\tunsigned long freq;\n\tint ret, irq;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = -ENXIO;\n\tpriv->clkevt_base = of_iomap(np, 0);\n\tif (!priv->clkevt_base) {\n\t\tpr_err(\"ftm: unable to map event timer registers\\n\");\n\t\tgoto err_clkevt;\n\t}\n\n\tpriv->clksrc_base = of_iomap(np, 1);\n\tif (!priv->clksrc_base) {\n\t\tpr_err(\"ftm: unable to map source timer registers\\n\");\n\t\tgoto err_clksrc;\n\t}\n\n\tret = -EINVAL;\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"ftm: unable to get IRQ from DT, %d\\n\", irq);\n\t\tgoto err;\n\t}\n\n\tpriv->big_endian = of_property_read_bool(np, \"big-endian\");\n\n\tfreq = ftm_clk_init(np);\n\tif (!freq)\n\t\tgoto err;\n\n\tret = ftm_calc_closest_round_cyc(freq);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ftm_clocksource_init(freq);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ftm_clockevent_init(freq, irq);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tiounmap(priv->clksrc_base);\nerr_clksrc:\n\tiounmap(priv->clkevt_base);\nerr_clkevt:\n\tkfree(priv);\n\treturn ret;\n}\nTIMER_OF_DECLARE(flextimer, \"fsl,ftm-timer\", ftm_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}