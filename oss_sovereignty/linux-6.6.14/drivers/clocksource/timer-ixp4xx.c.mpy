{
  "module_name": "timer-ixp4xx.c",
  "hash_id": "0b667419765f22b888b7863c109ab40324f184d63f528184bfd7de3519d029dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/clocksource/timer-ixp4xx.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/clockchips.h>\n#include <linux/clocksource.h>\n#include <linux/sched_clock.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n \n#define IXP4XX_OSTS_OFFSET\t0x00   \n#define IXP4XX_OST1_OFFSET\t0x04   \n#define IXP4XX_OSRT1_OFFSET\t0x08   \n#define IXP4XX_OST2_OFFSET\t0x0C   \n#define IXP4XX_OSRT2_OFFSET\t0x10   \n#define IXP4XX_OSST_OFFSET\t0x20   \n\n \n#define IXP4XX_OST_ENABLE\t\t0x00000001\n#define IXP4XX_OST_ONE_SHOT\t\t0x00000002\n \n#define IXP4XX_OST_RELOAD_MASK\t\t0x00000003\n#define IXP4XX_OST_DISABLED\t\t0x00000000\n#define IXP4XX_OSST_TIMER_1_PEND\t0x00000001\n#define IXP4XX_OSST_TIMER_2_PEND\t0x00000002\n#define IXP4XX_OSST_TIMER_TS_PEND\t0x00000004\n \n\nstruct ixp4xx_timer {\n\tvoid __iomem *base;\n\tu32 latch;\n\tstruct clock_event_device clkevt;\n#ifdef CONFIG_ARM\n\tstruct delay_timer delay_timer;\n#endif\n};\n\n \nstatic struct ixp4xx_timer *local_ixp4xx_timer;\n\nstatic inline struct ixp4xx_timer *\nto_ixp4xx_timer(struct clock_event_device *evt)\n{\n\treturn container_of(evt, struct ixp4xx_timer, clkevt);\n}\n\nstatic unsigned long ixp4xx_read_timer(void)\n{\n\treturn __raw_readl(local_ixp4xx_timer->base + IXP4XX_OSTS_OFFSET);\n}\n\nstatic u64 notrace ixp4xx_read_sched_clock(void)\n{\n\treturn ixp4xx_read_timer();\n}\n\nstatic u64 ixp4xx_clocksource_read(struct clocksource *c)\n{\n\treturn ixp4xx_read_timer();\n}\n\nstatic irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)\n{\n\tstruct ixp4xx_timer *tmr = dev_id;\n\tstruct clock_event_device *evt = &tmr->clkevt;\n\n\t \n\t__raw_writel(IXP4XX_OSST_TIMER_1_PEND,\n\t\t     tmr->base + IXP4XX_OSST_OFFSET);\n\n\tevt->event_handler(evt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ixp4xx_set_next_event(unsigned long cycles,\n\t\t\t\t struct clock_event_device *evt)\n{\n\tstruct ixp4xx_timer *tmr = to_ixp4xx_timer(evt);\n\tu32 val;\n\n\tval = __raw_readl(tmr->base + IXP4XX_OSRT1_OFFSET);\n\t \n\tval &= IXP4XX_OST_RELOAD_MASK;\n\t__raw_writel((cycles & ~IXP4XX_OST_RELOAD_MASK) | val,\n\t\t     tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_shutdown(struct clock_event_device *evt)\n{\n\tstruct ixp4xx_timer *tmr = to_ixp4xx_timer(evt);\n\tu32 val;\n\n\tval = __raw_readl(tmr->base + IXP4XX_OSRT1_OFFSET);\n\tval &= ~IXP4XX_OST_ENABLE;\n\t__raw_writel(val, tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_set_oneshot(struct clock_event_device *evt)\n{\n\tstruct ixp4xx_timer *tmr = to_ixp4xx_timer(evt);\n\n\t__raw_writel(IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT,\n\t\t     tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_set_periodic(struct clock_event_device *evt)\n{\n\tstruct ixp4xx_timer *tmr = to_ixp4xx_timer(evt);\n\tu32 val;\n\n\tval = tmr->latch & ~IXP4XX_OST_RELOAD_MASK;\n\tval |= IXP4XX_OST_ENABLE;\n\t__raw_writel(val, tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_resume(struct clock_event_device *evt)\n{\n\tstruct ixp4xx_timer *tmr = to_ixp4xx_timer(evt);\n\tu32 val;\n\n\tval = __raw_readl(tmr->base + IXP4XX_OSRT1_OFFSET);\n\tval |= IXP4XX_OST_ENABLE;\n\t__raw_writel(val, tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic __init int ixp4xx_timer_register(void __iomem *base,\n\t\t\t\t\tint timer_irq,\n\t\t\t\t\tunsigned int timer_freq)\n{\n\tstruct ixp4xx_timer *tmr;\n\tint ret;\n\n\ttmr = kzalloc(sizeof(*tmr), GFP_KERNEL);\n\tif (!tmr)\n\t\treturn -ENOMEM;\n\ttmr->base = base;\n\n\t \n\ttmr->latch = DIV_ROUND_CLOSEST(timer_freq,\n\t\t\t\t       (IXP4XX_OST_RELOAD_MASK + 1) * HZ)\n\t\t* (IXP4XX_OST_RELOAD_MASK + 1);\n\n\tlocal_ixp4xx_timer = tmr;\n\n\t \n\t__raw_writel(0, tmr->base + IXP4XX_OSRT1_OFFSET);\n\n\t \n\t__raw_writel(IXP4XX_OSST_TIMER_1_PEND,\n\t\t     tmr->base + IXP4XX_OSST_OFFSET);\n\n\t \n\t__raw_writel(0, tmr->base + IXP4XX_OSTS_OFFSET);\n\n\tclocksource_mmio_init(NULL, \"OSTS\", timer_freq, 200, 32,\n\t\t\t      ixp4xx_clocksource_read);\n\n\ttmr->clkevt.name = \"ixp4xx timer1\";\n\ttmr->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\n\ttmr->clkevt.rating = 200;\n\ttmr->clkevt.set_state_shutdown = ixp4xx_shutdown;\n\ttmr->clkevt.set_state_periodic = ixp4xx_set_periodic;\n\ttmr->clkevt.set_state_oneshot = ixp4xx_set_oneshot;\n\ttmr->clkevt.tick_resume = ixp4xx_resume;\n\ttmr->clkevt.set_next_event = ixp4xx_set_next_event;\n\ttmr->clkevt.cpumask = cpumask_of(0);\n\ttmr->clkevt.irq = timer_irq;\n\tret = request_irq(timer_irq, ixp4xx_timer_interrupt,\n\t\t\t  IRQF_TIMER, \"IXP4XX-TIMER1\", tmr);\n\tif (ret) {\n\t\tpr_crit(\"no timer IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\tclockevents_config_and_register(&tmr->clkevt, timer_freq,\n\t\t\t\t\t0xf, 0xfffffffe);\n\n\tsched_clock_register(ixp4xx_read_sched_clock, 32, timer_freq);\n\n#ifdef CONFIG_ARM\n\t \n\ttmr->delay_timer.read_current_timer = ixp4xx_read_timer;\n\ttmr->delay_timer.freq = timer_freq;\n\tregister_current_timer_delay(&tmr->delay_timer);\n#endif\n\n\treturn 0;\n}\n\nstatic struct platform_device ixp4xx_watchdog_device = {\n\t.name = \"ixp4xx-watchdog\",\n\t.id = -1,\n};\n\n \nstatic int ixp4xx_timer_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tixp4xx_watchdog_device.dev.platform_data = local_ixp4xx_timer->base;\n\tixp4xx_watchdog_device.dev.parent = dev;\n\treturn platform_device_register(&ixp4xx_watchdog_device);\n}\n\nstatic const struct of_device_id ixp4xx_timer_dt_id[] = {\n\t{ .compatible = \"intel,ixp4xx-timer\", },\n\t{   },\n};\n\nstatic struct platform_driver ixp4xx_timer_driver = {\n\t.probe  = ixp4xx_timer_probe,\n\t.driver = {\n\t\t.name = \"ixp4xx-timer\",\n\t\t.of_match_table = ixp4xx_timer_dt_id,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(ixp4xx_timer_driver);\n\nstatic __init int ixp4xx_of_timer_init(struct device_node *np)\n{\n\tvoid __iomem *base;\n\tint irq;\n\tint ret;\n\n\tbase = of_iomap(np, 0);\n\tif (!base) {\n\t\tpr_crit(\"IXP4xx: can't remap timer\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (irq <= 0) {\n\t\tpr_err(\"Can't parse IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unmap;\n\t}\n\n\t \n\tret = ixp4xx_timer_register(base, irq, 66666000);\n\tif (ret)\n\t\tgoto out_unmap;\n\treturn 0;\n\nout_unmap:\n\tiounmap(base);\n\treturn ret;\n}\nTIMER_OF_DECLARE(ixp4xx, \"intel,ixp4xx-timer\", ixp4xx_of_timer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}