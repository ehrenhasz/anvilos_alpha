{
  "module_name": "icm.c",
  "hash_id": "e1f4615b9ca66d627683ed056255548a09f686e04a23e8d4be6bb9245c6ddfa4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/icm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"ctl.h\"\n#include \"nhi_regs.h\"\n#include \"tb.h\"\n\n#define PCIE2CIO_CMD\t\t\t0x30\n#define PCIE2CIO_CMD_TIMEOUT\t\tBIT(31)\n#define PCIE2CIO_CMD_START\t\tBIT(30)\n#define PCIE2CIO_CMD_WRITE\t\tBIT(21)\n#define PCIE2CIO_CMD_CS_MASK\t\tGENMASK(20, 19)\n#define PCIE2CIO_CMD_CS_SHIFT\t\t19\n#define PCIE2CIO_CMD_PORT_MASK\t\tGENMASK(18, 13)\n#define PCIE2CIO_CMD_PORT_SHIFT\t\t13\n\n#define PCIE2CIO_WRDATA\t\t\t0x34\n#define PCIE2CIO_RDDATA\t\t\t0x38\n\n#define PHY_PORT_CS1\t\t\t0x37\n#define PHY_PORT_CS1_LINK_DISABLE\tBIT(14)\n#define PHY_PORT_CS1_LINK_STATE_MASK\tGENMASK(29, 26)\n#define PHY_PORT_CS1_LINK_STATE_SHIFT\t26\n\n#define ICM_TIMEOUT\t\t\t5000\t \n#define ICM_RETRIES\t\t\t3\n#define ICM_APPROVE_TIMEOUT\t\t10000\t \n#define ICM_MAX_LINK\t\t\t4\n\nstatic bool start_icm;\nmodule_param(start_icm, bool, 0444);\nMODULE_PARM_DESC(start_icm, \"start ICM firmware if it is not running (default: false)\");\n\n \nstruct usb4_switch_nvm_auth {\n\tstruct icm_usb4_switch_op_response reply;\n\tstruct icm_usb4_switch_op request;\n\tstruct icm *icm;\n};\n\n \nstruct icm {\n\tstruct mutex request_lock;\n\tstruct delayed_work rescan_work;\n\tstruct pci_dev *upstream_port;\n\tint vnd_cap;\n\tbool safe_mode;\n\tsize_t max_boot_acl;\n\tbool rpm;\n\tbool can_upgrade_nvm;\n\tu8 proto_version;\n\tstruct usb4_switch_nvm_auth *last_nvm_auth;\n\tbool veto;\n\tbool (*is_supported)(struct tb *tb);\n\tint (*cio_reset)(struct tb *tb);\n\tint (*get_mode)(struct tb *tb);\n\tint (*get_route)(struct tb *tb, u8 link, u8 depth, u64 *route);\n\tvoid (*save_devices)(struct tb *tb);\n\tint (*driver_ready)(struct tb *tb,\n\t\t\t    enum tb_security_level *security_level,\n\t\t\t    u8 *proto_version, size_t *nboot_acl, bool *rpm);\n\tvoid (*set_uuid)(struct tb *tb);\n\tvoid (*device_connected)(struct tb *tb,\n\t\t\t\t const struct icm_pkg_header *hdr);\n\tvoid (*device_disconnected)(struct tb *tb,\n\t\t\t\t    const struct icm_pkg_header *hdr);\n\tvoid (*xdomain_connected)(struct tb *tb,\n\t\t\t\t  const struct icm_pkg_header *hdr);\n\tvoid (*xdomain_disconnected)(struct tb *tb,\n\t\t\t\t     const struct icm_pkg_header *hdr);\n\tvoid (*rtd3_veto)(struct tb *tb, const struct icm_pkg_header *hdr);\n};\n\nstruct icm_notification {\n\tstruct work_struct work;\n\tstruct icm_pkg_header *pkg;\n\tstruct tb *tb;\n};\n\nstruct ep_name_entry {\n\tu8 len;\n\tu8 type;\n\tu8 data[];\n};\n\n#define EP_NAME_INTEL_VSS\t0x10\n\n \nstruct intel_vss {\n\tu16 vendor;\n\tu16 model;\n\tu8 mc;\n\tu8 flags;\n\tu16 pci_devid;\n\tu32 nvm_version;\n};\n\n#define INTEL_VSS_FLAGS_RTD3\tBIT(0)\n\nstatic const struct intel_vss *parse_intel_vss(const void *ep_name, size_t size)\n{\n\tconst void *end = ep_name + size;\n\n\twhile (ep_name < end) {\n\t\tconst struct ep_name_entry *ep = ep_name;\n\n\t\tif (!ep->len)\n\t\t\tbreak;\n\t\tif (ep_name + ep->len > end)\n\t\t\tbreak;\n\n\t\tif (ep->type == EP_NAME_INTEL_VSS)\n\t\t\treturn (const struct intel_vss *)ep->data;\n\n\t\tep_name += ep->len;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool intel_vss_is_rtd3(const void *ep_name, size_t size)\n{\n\tconst struct intel_vss *vss;\n\n\tvss = parse_intel_vss(ep_name, size);\n\tif (vss)\n\t\treturn !!(vss->flags & INTEL_VSS_FLAGS_RTD3);\n\n\treturn false;\n}\n\nstatic inline struct tb *icm_to_tb(struct icm *icm)\n{\n\treturn ((void *)icm - sizeof(struct tb));\n}\n\nstatic inline u8 phy_port_from_route(u64 route, u8 depth)\n{\n\tu8 link;\n\n\tlink = depth ? route >> ((depth - 1) * 8) : route;\n\treturn tb_phy_port_from_link(link);\n}\n\nstatic inline u8 dual_link_from_link(u8 link)\n{\n\treturn link ? ((link - 1) ^ 0x01) + 1 : 0;\n}\n\nstatic inline u64 get_route(u32 route_hi, u32 route_lo)\n{\n\treturn (u64)route_hi << 32 | route_lo;\n}\n\nstatic inline u64 get_parent_route(u64 route)\n{\n\tint depth = tb_route_length(route);\n\treturn depth ? route & ~(0xffULL << (depth - 1) * TB_ROUTE_SHIFT) : 0;\n}\n\nstatic int pci2cio_wait_completion(struct icm *icm, unsigned long timeout_msec)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(timeout_msec);\n\tu32 cmd;\n\n\tdo {\n\t\tpci_read_config_dword(icm->upstream_port,\n\t\t\t\t      icm->vnd_cap + PCIE2CIO_CMD, &cmd);\n\t\tif (!(cmd & PCIE2CIO_CMD_START)) {\n\t\t\tif (cmd & PCIE2CIO_CMD_TIMEOUT)\n\t\t\t\tbreak;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmsleep(50);\n\t} while (time_before(jiffies, end));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int pcie2cio_read(struct icm *icm, enum tb_cfg_space cs,\n\t\t\t unsigned int port, unsigned int index, u32 *data)\n{\n\tstruct pci_dev *pdev = icm->upstream_port;\n\tint ret, vnd_cap = icm->vnd_cap;\n\tu32 cmd;\n\n\tcmd = index;\n\tcmd |= (port << PCIE2CIO_CMD_PORT_SHIFT) & PCIE2CIO_CMD_PORT_MASK;\n\tcmd |= (cs << PCIE2CIO_CMD_CS_SHIFT) & PCIE2CIO_CMD_CS_MASK;\n\tcmd |= PCIE2CIO_CMD_START;\n\tpci_write_config_dword(pdev, vnd_cap + PCIE2CIO_CMD, cmd);\n\n\tret = pci2cio_wait_completion(icm, 5000);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_read_config_dword(pdev, vnd_cap + PCIE2CIO_RDDATA, data);\n\treturn 0;\n}\n\nstatic int pcie2cio_write(struct icm *icm, enum tb_cfg_space cs,\n\t\t\t  unsigned int port, unsigned int index, u32 data)\n{\n\tstruct pci_dev *pdev = icm->upstream_port;\n\tint vnd_cap = icm->vnd_cap;\n\tu32 cmd;\n\n\tpci_write_config_dword(pdev, vnd_cap + PCIE2CIO_WRDATA, data);\n\n\tcmd = index;\n\tcmd |= (port << PCIE2CIO_CMD_PORT_SHIFT) & PCIE2CIO_CMD_PORT_MASK;\n\tcmd |= (cs << PCIE2CIO_CMD_CS_SHIFT) & PCIE2CIO_CMD_CS_MASK;\n\tcmd |= PCIE2CIO_CMD_WRITE | PCIE2CIO_CMD_START;\n\tpci_write_config_dword(pdev, vnd_cap + PCIE2CIO_CMD, cmd);\n\n\treturn pci2cio_wait_completion(icm, 5000);\n}\n\nstatic bool icm_match(const struct tb_cfg_request *req,\n\t\t      const struct ctl_pkg *pkg)\n{\n\tconst struct icm_pkg_header *res_hdr = pkg->buffer;\n\tconst struct icm_pkg_header *req_hdr = req->request;\n\n\tif (pkg->frame.eof != req->response_type)\n\t\treturn false;\n\tif (res_hdr->code != req_hdr->code)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool icm_copy(struct tb_cfg_request *req, const struct ctl_pkg *pkg)\n{\n\tconst struct icm_pkg_header *hdr = pkg->buffer;\n\n\tif (hdr->packet_id < req->npackets) {\n\t\tsize_t offset = hdr->packet_id * req->response_size;\n\n\t\tmemcpy(req->response + offset, pkg->buffer, req->response_size);\n\t}\n\n\treturn hdr->packet_id == hdr->total_packets - 1;\n}\n\nstatic int icm_request(struct tb *tb, const void *request, size_t request_size,\n\t\t       void *response, size_t response_size, size_t npackets,\n\t\t       int retries, unsigned int timeout_msec)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tdo {\n\t\tstruct tb_cfg_request *req;\n\t\tstruct tb_cfg_result res;\n\n\t\treq = tb_cfg_request_alloc();\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\n\t\treq->match = icm_match;\n\t\treq->copy = icm_copy;\n\t\treq->request = request;\n\t\treq->request_size = request_size;\n\t\treq->request_type = TB_CFG_PKG_ICM_CMD;\n\t\treq->response = response;\n\t\treq->npackets = npackets;\n\t\treq->response_size = response_size;\n\t\treq->response_type = TB_CFG_PKG_ICM_RESP;\n\n\t\tmutex_lock(&icm->request_lock);\n\t\tres = tb_cfg_request_sync(tb->ctl, req, timeout_msec);\n\t\tmutex_unlock(&icm->request_lock);\n\n\t\ttb_cfg_request_put(req);\n\n\t\tif (res.err != -ETIMEDOUT)\n\t\t\treturn res.err == 1 ? -EIO : res.err;\n\n\t\tusleep_range(20, 50);\n\t} while (retries--);\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void icm_postpone_rescan(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tif (delayed_work_pending(&icm->rescan_work))\n\t\tmod_delayed_work(tb->wq, &icm->rescan_work,\n\t\t\t\t msecs_to_jiffies(500));\n}\n\nstatic void icm_veto_begin(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tif (!icm->veto) {\n\t\ticm->veto = true;\n\t\t \n\t\tpm_runtime_get(&tb->dev);\n\t}\n}\n\nstatic void icm_veto_end(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tif (icm->veto) {\n\t\ticm->veto = false;\n\t\t \n\t\tpm_runtime_mark_last_busy(&tb->dev);\n\t\tpm_runtime_put_autosuspend(&tb->dev);\n\t}\n}\n\nstatic bool icm_firmware_running(const struct tb_nhi *nhi)\n{\n\tu32 val;\n\n\tval = ioread32(nhi->iobase + REG_FW_STS);\n\treturn !!(val & REG_FW_STS_ICM_EN);\n}\n\nstatic bool icm_fr_is_supported(struct tb *tb)\n{\n\treturn !x86_apple_machine;\n}\n\nstatic inline int icm_fr_get_switch_index(u32 port)\n{\n\tint index;\n\n\tif ((port & ICM_PORT_TYPE_MASK) != TB_TYPE_PORT)\n\t\treturn 0;\n\n\tindex = port >> ICM_PORT_INDEX_SHIFT;\n\treturn index != 0xff ? index : 0;\n}\n\nstatic int icm_fr_get_route(struct tb *tb, u8 link, u8 depth, u64 *route)\n{\n\tstruct icm_fr_pkg_get_topology_response *switches, *sw;\n\tstruct icm_fr_pkg_get_topology request = {\n\t\t.hdr = { .code = ICM_GET_TOPOLOGY },\n\t};\n\tsize_t npackets = ICM_GET_TOPOLOGY_PACKETS;\n\tint ret, index;\n\tu8 i;\n\n\tswitches = kcalloc(npackets, sizeof(*switches), GFP_KERNEL);\n\tif (!switches)\n\t\treturn -ENOMEM;\n\n\tret = icm_request(tb, &request, sizeof(request), switches,\n\t\t\t  sizeof(*switches), npackets, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\tgoto err_free;\n\n\tsw = &switches[0];\n\tindex = icm_fr_get_switch_index(sw->ports[link]);\n\tif (!index) {\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tsw = &switches[index];\n\tfor (i = 1; i < depth; i++) {\n\t\tunsigned int j;\n\n\t\tif (!(sw->first_data & ICM_SWITCH_USED)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(sw->ports); j++) {\n\t\t\tindex = icm_fr_get_switch_index(sw->ports[j]);\n\t\t\tif (index > sw->switch_index) {\n\t\t\t\tsw = &switches[index];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t*route = get_route(sw->route_hi, sw->route_lo);\n\nerr_free:\n\tkfree(switches);\n\treturn ret;\n}\n\nstatic void icm_fr_save_devices(struct tb *tb)\n{\n\tnhi_mailbox_cmd(tb->nhi, NHI_MAILBOX_SAVE_DEVS, 0);\n}\n\nstatic int\nicm_fr_driver_ready(struct tb *tb, enum tb_security_level *security_level,\n\t\t    u8 *proto_version, size_t *nboot_acl, bool *rpm)\n{\n\tstruct icm_fr_pkg_driver_ready_response reply;\n\tstruct icm_pkg_driver_ready request = {\n\t\t.hdr.code = ICM_DRIVER_READY,\n\t};\n\tint ret;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (security_level)\n\t\t*security_level = reply.security_level & ICM_FR_SLEVEL_MASK;\n\n\treturn 0;\n}\n\nstatic int icm_fr_approve_switch(struct tb *tb, struct tb_switch *sw)\n{\n\tstruct icm_fr_pkg_approve_device request;\n\tstruct icm_fr_pkg_approve_device reply;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_APPROVE_DEVICE;\n\trequest.connection_id = sw->connection_id;\n\trequest.connection_key = sw->connection_key;\n\n\tmemset(&reply, 0, sizeof(reply));\n\t \n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_APPROVE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR) {\n\t\ttb_warn(tb, \"PCIe tunnel creation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int icm_fr_add_switch_key(struct tb *tb, struct tb_switch *sw)\n{\n\tstruct icm_fr_pkg_add_device_key request;\n\tstruct icm_fr_pkg_add_device_key_response reply;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_ADD_DEVICE_KEY;\n\trequest.connection_id = sw->connection_id;\n\trequest.connection_key = sw->connection_key;\n\tmemcpy(request.key, sw->key, TB_SWITCH_KEY_SIZE);\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR) {\n\t\ttb_warn(tb, \"Adding key to switch failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int icm_fr_challenge_switch_key(struct tb *tb, struct tb_switch *sw,\n\t\t\t\t       const u8 *challenge, u8 *response)\n{\n\tstruct icm_fr_pkg_challenge_device request;\n\tstruct icm_fr_pkg_challenge_device_response reply;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_CHALLENGE_DEVICE;\n\trequest.connection_id = sw->connection_id;\n\trequest.connection_key = sw->connection_key;\n\tmemcpy(request.challenge, challenge, TB_SWITCH_KEY_SIZE);\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EKEYREJECTED;\n\tif (reply.hdr.flags & ICM_FLAGS_NO_KEY)\n\t\treturn -ENOKEY;\n\n\tmemcpy(response, reply.response, TB_SWITCH_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic int icm_fr_approve_xdomain_paths(struct tb *tb, struct tb_xdomain *xd,\n\t\t\t\t\tint transmit_path, int transmit_ring,\n\t\t\t\t\tint receive_path, int receive_ring)\n{\n\tstruct icm_fr_pkg_approve_xdomain_response reply;\n\tstruct icm_fr_pkg_approve_xdomain request;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.hdr.code = ICM_APPROVE_XDOMAIN;\n\trequest.link_info = xd->depth << ICM_LINK_INFO_DEPTH_SHIFT | xd->link;\n\tmemcpy(&request.remote_uuid, xd->remote_uuid, sizeof(*xd->remote_uuid));\n\n\trequest.transmit_path = transmit_path;\n\trequest.transmit_ring = transmit_ring;\n\trequest.receive_path = receive_path;\n\trequest.receive_ring = receive_ring;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int icm_fr_disconnect_xdomain_paths(struct tb *tb, struct tb_xdomain *xd,\n\t\t\t\t\t   int transmit_path, int transmit_ring,\n\t\t\t\t\t   int receive_path, int receive_ring)\n{\n\tu8 phy_port;\n\tu8 cmd;\n\n\tphy_port = tb_phy_port_from_link(xd->link);\n\tif (phy_port == 0)\n\t\tcmd = NHI_MAILBOX_DISCONNECT_PA;\n\telse\n\t\tcmd = NHI_MAILBOX_DISCONNECT_PB;\n\n\tnhi_mailbox_cmd(tb->nhi, cmd, 1);\n\tusleep_range(10, 50);\n\tnhi_mailbox_cmd(tb->nhi, cmd, 2);\n\treturn 0;\n}\n\nstatic struct tb_switch *alloc_switch(struct tb_switch *parent_sw, u64 route,\n\t\t\t\t      const uuid_t *uuid)\n{\n\tstruct tb *tb = parent_sw->tb;\n\tstruct tb_switch *sw;\n\n\tsw = tb_switch_alloc(tb, &parent_sw->dev, route);\n\tif (IS_ERR(sw)) {\n\t\ttb_warn(tb, \"failed to allocate switch at %llx\\n\", route);\n\t\treturn sw;\n\t}\n\n\tsw->uuid = kmemdup(uuid, sizeof(*uuid), GFP_KERNEL);\n\tif (!sw->uuid) {\n\t\ttb_switch_put(sw);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit_completion(&sw->rpm_complete);\n\treturn sw;\n}\n\nstatic int add_switch(struct tb_switch *parent_sw, struct tb_switch *sw)\n{\n\tu64 route = tb_route(sw);\n\tint ret;\n\n\t \n\ttb_port_at(route, parent_sw)->remote = tb_upstream_port(sw);\n\ttb_upstream_port(sw)->remote = tb_port_at(route, parent_sw);\n\n\tret = tb_switch_add(sw);\n\tif (ret)\n\t\ttb_port_at(tb_route(sw), parent_sw)->remote = NULL;\n\n\treturn ret;\n}\n\nstatic void update_switch(struct tb_switch *sw, u64 route, u8 connection_id,\n\t\t\t  u8 connection_key, u8 link, u8 depth, bool boot)\n{\n\tstruct tb_switch *parent_sw = tb_switch_parent(sw);\n\n\t \n\ttb_switch_downstream_port(sw)->remote = NULL;\n\t \n\ttb_port_at(route, parent_sw)->remote = tb_upstream_port(sw);\n\n\t \n\tsw->config.route_hi = upper_32_bits(route);\n\tsw->config.route_lo = lower_32_bits(route);\n\tsw->connection_id = connection_id;\n\tsw->connection_key = connection_key;\n\tsw->link = link;\n\tsw->depth = depth;\n\tsw->boot = boot;\n\n\t \n\tsw->is_unplugged = false;\n\n\t \n\tcomplete(&sw->rpm_complete);\n}\n\nstatic void remove_switch(struct tb_switch *sw)\n{\n\ttb_switch_downstream_port(sw)->remote = NULL;\n\ttb_switch_remove(sw);\n}\n\nstatic void add_xdomain(struct tb_switch *sw, u64 route,\n\t\t\tconst uuid_t *local_uuid, const uuid_t *remote_uuid,\n\t\t\tu8 link, u8 depth)\n{\n\tstruct tb_xdomain *xd;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\txd = tb_xdomain_alloc(sw->tb, &sw->dev, route, local_uuid, remote_uuid);\n\tif (!xd)\n\t\tgoto out;\n\n\txd->link = link;\n\txd->depth = depth;\n\n\ttb_port_at(route, sw)->xdomain = xd;\n\n\ttb_xdomain_add(xd);\n\nout:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n}\n\nstatic void update_xdomain(struct tb_xdomain *xd, u64 route, u8 link)\n{\n\txd->link = link;\n\txd->route = route;\n\txd->is_unplugged = false;\n}\n\nstatic void remove_xdomain(struct tb_xdomain *xd)\n{\n\tstruct tb_switch *sw;\n\n\tsw = tb_to_switch(xd->dev.parent);\n\ttb_port_at(xd->route, sw)->xdomain = NULL;\n\ttb_xdomain_remove(xd);\n}\n\nstatic void\nicm_fr_device_connected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_fr_event_device_connected *pkg =\n\t\t(const struct icm_fr_event_device_connected *)hdr;\n\tenum tb_security_level security_level;\n\tstruct tb_switch *sw, *parent_sw;\n\tbool boot, dual_lane, speed_gen3;\n\tstruct icm *icm = tb_priv(tb);\n\tbool authorized = false;\n\tstruct tb_xdomain *xd;\n\tu8 link, depth;\n\tu64 route;\n\tint ret;\n\n\ticm_postpone_rescan(tb);\n\n\tlink = pkg->link_info & ICM_LINK_INFO_LINK_MASK;\n\tdepth = (pkg->link_info & ICM_LINK_INFO_DEPTH_MASK) >>\n\t\tICM_LINK_INFO_DEPTH_SHIFT;\n\tauthorized = pkg->link_info & ICM_LINK_INFO_APPROVED;\n\tsecurity_level = (pkg->hdr.flags & ICM_FLAGS_SLEVEL_MASK) >>\n\t\t\t ICM_FLAGS_SLEVEL_SHIFT;\n\tboot = pkg->link_info & ICM_LINK_INFO_BOOT;\n\tdual_lane = pkg->hdr.flags & ICM_FLAGS_DUAL_LANE;\n\tspeed_gen3 = pkg->hdr.flags & ICM_FLAGS_SPEED_GEN3;\n\n\tif (pkg->link_info & ICM_LINK_INFO_REJECTED) {\n\t\ttb_info(tb, \"switch at %u.%u was rejected by ICM firmware because topology limit exceeded\\n\",\n\t\t\tlink, depth);\n\t\treturn;\n\t}\n\n\tsw = tb_switch_find_by_uuid(tb, &pkg->ep_uuid);\n\tif (sw) {\n\t\tu8 phy_port, sw_phy_port;\n\n\t\tsw_phy_port = tb_phy_port_from_link(sw->link);\n\t\tphy_port = tb_phy_port_from_link(link);\n\n\t\t \n\t\tif (sw->depth == depth && sw_phy_port == phy_port &&\n\t\t    !!sw->authorized == authorized) {\n\t\t\t \n\t\t\tif (sw->link != link) {\n\t\t\t\tret = icm->get_route(tb, link, depth, &route);\n\t\t\t\tif (ret) {\n\t\t\t\t\ttb_err(tb, \"failed to update route string for switch at %u.%u\\n\",\n\t\t\t\t\t       link, depth);\n\t\t\t\t\ttb_switch_put(sw);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\troute = tb_route(sw);\n\t\t\t}\n\n\t\t\tupdate_switch(sw, route, pkg->connection_id,\n\t\t\t\t      pkg->connection_key, link, depth, boot);\n\t\t\ttb_switch_put(sw);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\t \n\tsw = tb_switch_find_by_link_depth(tb, link, depth);\n\tif (!sw) {\n\t\tu8 dual_link;\n\n\t\tdual_link = dual_link_from_link(link);\n\t\tif (dual_link)\n\t\t\tsw = tb_switch_find_by_link_depth(tb, dual_link, depth);\n\t}\n\tif (sw) {\n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\t \n\txd = tb_xdomain_find_by_link_depth(tb, link, depth);\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\tparent_sw = tb_switch_find_by_link_depth(tb, link, depth - 1);\n\tif (!parent_sw) {\n\t\ttb_err(tb, \"failed to find parent switch for %u.%u\\n\",\n\t\t       link, depth);\n\t\treturn;\n\t}\n\n\tret = icm->get_route(tb, link, depth, &route);\n\tif (ret) {\n\t\ttb_err(tb, \"failed to find route string for switch at %u.%u\\n\",\n\t\t       link, depth);\n\t\ttb_switch_put(parent_sw);\n\t\treturn;\n\t}\n\n\tpm_runtime_get_sync(&parent_sw->dev);\n\n\tsw = alloc_switch(parent_sw, route, &pkg->ep_uuid);\n\tif (!IS_ERR(sw)) {\n\t\tsw->connection_id = pkg->connection_id;\n\t\tsw->connection_key = pkg->connection_key;\n\t\tsw->link = link;\n\t\tsw->depth = depth;\n\t\tsw->authorized = authorized;\n\t\tsw->security_level = security_level;\n\t\tsw->boot = boot;\n\t\tsw->link_speed = speed_gen3 ? 20 : 10;\n\t\tsw->link_width = dual_lane ? TB_LINK_WIDTH_DUAL :\n\t\t\t\t\t     TB_LINK_WIDTH_SINGLE;\n\t\tsw->rpm = intel_vss_is_rtd3(pkg->ep_name, sizeof(pkg->ep_name));\n\n\t\tif (add_switch(parent_sw, sw))\n\t\t\ttb_switch_put(sw);\n\t}\n\n\tpm_runtime_mark_last_busy(&parent_sw->dev);\n\tpm_runtime_put_autosuspend(&parent_sw->dev);\n\n\ttb_switch_put(parent_sw);\n}\n\nstatic void\nicm_fr_device_disconnected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_fr_event_device_disconnected *pkg =\n\t\t(const struct icm_fr_event_device_disconnected *)hdr;\n\tstruct tb_switch *sw;\n\tu8 link, depth;\n\n\tlink = pkg->link_info & ICM_LINK_INFO_LINK_MASK;\n\tdepth = (pkg->link_info & ICM_LINK_INFO_DEPTH_MASK) >>\n\t\tICM_LINK_INFO_DEPTH_SHIFT;\n\n\tif (link > ICM_MAX_LINK || depth > TB_SWITCH_MAX_DEPTH) {\n\t\ttb_warn(tb, \"invalid topology %u.%u, ignoring\\n\", link, depth);\n\t\treturn;\n\t}\n\n\tsw = tb_switch_find_by_link_depth(tb, link, depth);\n\tif (!sw) {\n\t\ttb_warn(tb, \"no switch exists at %u.%u, ignoring\\n\", link,\n\t\t\tdepth);\n\t\treturn;\n\t}\n\n\tpm_runtime_get_sync(sw->dev.parent);\n\n\tremove_switch(sw);\n\n\tpm_runtime_mark_last_busy(sw->dev.parent);\n\tpm_runtime_put_autosuspend(sw->dev.parent);\n\n\ttb_switch_put(sw);\n}\n\nstatic void\nicm_fr_xdomain_connected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_fr_event_xdomain_connected *pkg =\n\t\t(const struct icm_fr_event_xdomain_connected *)hdr;\n\tstruct tb_xdomain *xd;\n\tstruct tb_switch *sw;\n\tu8 link, depth;\n\tu64 route;\n\n\tlink = pkg->link_info & ICM_LINK_INFO_LINK_MASK;\n\tdepth = (pkg->link_info & ICM_LINK_INFO_DEPTH_MASK) >>\n\t\tICM_LINK_INFO_DEPTH_SHIFT;\n\n\tif (link > ICM_MAX_LINK || depth > TB_SWITCH_MAX_DEPTH) {\n\t\ttb_warn(tb, \"invalid topology %u.%u, ignoring\\n\", link, depth);\n\t\treturn;\n\t}\n\n\troute = get_route(pkg->local_route_hi, pkg->local_route_lo);\n\n\txd = tb_xdomain_find_by_uuid(tb, &pkg->remote_uuid);\n\tif (xd) {\n\t\tu8 xd_phy_port, phy_port;\n\n\t\txd_phy_port = phy_port_from_route(xd->route, xd->depth);\n\t\tphy_port = phy_port_from_route(route, depth);\n\n\t\tif (xd->depth == depth && xd_phy_port == phy_port) {\n\t\t\tupdate_xdomain(xd, route, link);\n\t\t\ttb_xdomain_put(xd);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\t \n\txd = tb_xdomain_find_by_link_depth(tb, link, depth);\n\tif (!xd) {\n\t\tu8 dual_link;\n\n\t\tdual_link = dual_link_from_link(link);\n\t\tif (dual_link)\n\t\t\txd = tb_xdomain_find_by_link_depth(tb, dual_link,\n\t\t\t\t\t\t\t   depth);\n\t}\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\t \n\tsw = tb_switch_find_by_route(tb, route);\n\tif (sw) {\n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\tsw = tb_switch_find_by_link_depth(tb, link, depth);\n\tif (!sw) {\n\t\ttb_warn(tb, \"no switch exists at %u.%u, ignoring\\n\", link,\n\t\t\tdepth);\n\t\treturn;\n\t}\n\n\tadd_xdomain(sw, route, &pkg->local_uuid, &pkg->remote_uuid, link,\n\t\t    depth);\n\ttb_switch_put(sw);\n}\n\nstatic void\nicm_fr_xdomain_disconnected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_fr_event_xdomain_disconnected *pkg =\n\t\t(const struct icm_fr_event_xdomain_disconnected *)hdr;\n\tstruct tb_xdomain *xd;\n\n\t \n\txd = tb_xdomain_find_by_uuid(tb, &pkg->remote_uuid);\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n}\n\nstatic int icm_tr_cio_reset(struct tb *tb)\n{\n\treturn pcie2cio_write(tb_priv(tb), TB_CFG_SWITCH, 0, 0x777, BIT(1));\n}\n\nstatic int\nicm_tr_driver_ready(struct tb *tb, enum tb_security_level *security_level,\n\t\t    u8 *proto_version, size_t *nboot_acl, bool *rpm)\n{\n\tstruct icm_tr_pkg_driver_ready_response reply;\n\tstruct icm_pkg_driver_ready request = {\n\t\t.hdr.code = ICM_DRIVER_READY,\n\t};\n\tint ret;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, 10, 2000);\n\tif (ret)\n\t\treturn ret;\n\n\tif (security_level)\n\t\t*security_level = reply.info & ICM_TR_INFO_SLEVEL_MASK;\n\tif (proto_version)\n\t\t*proto_version = (reply.info & ICM_TR_INFO_PROTO_VERSION_MASK) >>\n\t\t\t\tICM_TR_INFO_PROTO_VERSION_SHIFT;\n\tif (nboot_acl)\n\t\t*nboot_acl = (reply.info & ICM_TR_INFO_BOOT_ACL_MASK) >>\n\t\t\t\tICM_TR_INFO_BOOT_ACL_SHIFT;\n\tif (rpm)\n\t\t*rpm = !!(reply.hdr.flags & ICM_TR_FLAGS_RTD3);\n\n\treturn 0;\n}\n\nstatic int icm_tr_approve_switch(struct tb *tb, struct tb_switch *sw)\n{\n\tstruct icm_tr_pkg_approve_device request;\n\tstruct icm_tr_pkg_approve_device reply;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_APPROVE_DEVICE;\n\trequest.route_lo = sw->config.route_lo;\n\trequest.route_hi = sw->config.route_hi;\n\trequest.connection_id = sw->connection_id;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_APPROVE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR) {\n\t\ttb_warn(tb, \"PCIe tunnel creation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int icm_tr_add_switch_key(struct tb *tb, struct tb_switch *sw)\n{\n\tstruct icm_tr_pkg_add_device_key_response reply;\n\tstruct icm_tr_pkg_add_device_key request;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_ADD_DEVICE_KEY;\n\trequest.route_lo = sw->config.route_lo;\n\trequest.route_hi = sw->config.route_hi;\n\trequest.connection_id = sw->connection_id;\n\tmemcpy(request.key, sw->key, TB_SWITCH_KEY_SIZE);\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR) {\n\t\ttb_warn(tb, \"Adding key to switch failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int icm_tr_challenge_switch_key(struct tb *tb, struct tb_switch *sw,\n\t\t\t\t       const u8 *challenge, u8 *response)\n{\n\tstruct icm_tr_pkg_challenge_device_response reply;\n\tstruct icm_tr_pkg_challenge_device request;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemcpy(&request.ep_uuid, sw->uuid, sizeof(request.ep_uuid));\n\trequest.hdr.code = ICM_CHALLENGE_DEVICE;\n\trequest.route_lo = sw->config.route_lo;\n\trequest.route_hi = sw->config.route_hi;\n\trequest.connection_id = sw->connection_id;\n\tmemcpy(request.challenge, challenge, TB_SWITCH_KEY_SIZE);\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EKEYREJECTED;\n\tif (reply.hdr.flags & ICM_FLAGS_NO_KEY)\n\t\treturn -ENOKEY;\n\n\tmemcpy(response, reply.response, TB_SWITCH_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic int icm_tr_approve_xdomain_paths(struct tb *tb, struct tb_xdomain *xd,\n\t\t\t\t\tint transmit_path, int transmit_ring,\n\t\t\t\t\tint receive_path, int receive_ring)\n{\n\tstruct icm_tr_pkg_approve_xdomain_response reply;\n\tstruct icm_tr_pkg_approve_xdomain request;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.hdr.code = ICM_APPROVE_XDOMAIN;\n\trequest.route_hi = upper_32_bits(xd->route);\n\trequest.route_lo = lower_32_bits(xd->route);\n\trequest.transmit_path = transmit_path;\n\trequest.transmit_ring = transmit_ring;\n\trequest.receive_path = receive_path;\n\trequest.receive_ring = receive_ring;\n\tmemcpy(&request.remote_uuid, xd->remote_uuid, sizeof(*xd->remote_uuid));\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int icm_tr_xdomain_tear_down(struct tb *tb, struct tb_xdomain *xd,\n\t\t\t\t    int stage)\n{\n\tstruct icm_tr_pkg_disconnect_xdomain_response reply;\n\tstruct icm_tr_pkg_disconnect_xdomain request;\n\tint ret;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.hdr.code = ICM_DISCONNECT_XDOMAIN;\n\trequest.stage = stage;\n\trequest.route_hi = upper_32_bits(xd->route);\n\trequest.route_lo = lower_32_bits(xd->route);\n\tmemcpy(&request.remote_uuid, xd->remote_uuid, sizeof(*xd->remote_uuid));\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int icm_tr_disconnect_xdomain_paths(struct tb *tb, struct tb_xdomain *xd,\n\t\t\t\t\t   int transmit_path, int transmit_ring,\n\t\t\t\t\t   int receive_path, int receive_ring)\n{\n\tint ret;\n\n\tret = icm_tr_xdomain_tear_down(tb, xd, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10, 50);\n\treturn icm_tr_xdomain_tear_down(tb, xd, 2);\n}\n\nstatic void\n__icm_tr_device_connected(struct tb *tb, const struct icm_pkg_header *hdr,\n\t\t\t  bool force_rtd3)\n{\n\tconst struct icm_tr_event_device_connected *pkg =\n\t\t(const struct icm_tr_event_device_connected *)hdr;\n\tbool authorized, boot, dual_lane, speed_gen3;\n\tenum tb_security_level security_level;\n\tstruct tb_switch *sw, *parent_sw;\n\tstruct tb_xdomain *xd;\n\tu64 route;\n\n\ticm_postpone_rescan(tb);\n\n\t \n\tif (pkg->hdr.packet_id)\n\t\treturn;\n\n\troute = get_route(pkg->route_hi, pkg->route_lo);\n\tauthorized = pkg->link_info & ICM_LINK_INFO_APPROVED;\n\tsecurity_level = (pkg->hdr.flags & ICM_FLAGS_SLEVEL_MASK) >>\n\t\t\t ICM_FLAGS_SLEVEL_SHIFT;\n\tboot = pkg->link_info & ICM_LINK_INFO_BOOT;\n\tdual_lane = pkg->hdr.flags & ICM_FLAGS_DUAL_LANE;\n\tspeed_gen3 = pkg->hdr.flags & ICM_FLAGS_SPEED_GEN3;\n\n\tif (pkg->link_info & ICM_LINK_INFO_REJECTED) {\n\t\ttb_info(tb, \"switch at %llx was rejected by ICM firmware because topology limit exceeded\\n\",\n\t\t\troute);\n\t\treturn;\n\t}\n\n\tsw = tb_switch_find_by_uuid(tb, &pkg->ep_uuid);\n\tif (sw) {\n\t\t \n\t\tif (tb_route(sw) == route && !!sw->authorized == authorized) {\n\t\t\tupdate_switch(sw, route, pkg->connection_id, 0, 0, 0,\n\t\t\t\t      boot);\n\t\t\ttb_switch_put(sw);\n\t\t\treturn;\n\t\t}\n\n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\t \n\tsw = tb_switch_find_by_route(tb, route);\n\tif (sw) {\n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\t \n\txd = tb_xdomain_find_by_route(tb, route);\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\tparent_sw = tb_switch_find_by_route(tb, get_parent_route(route));\n\tif (!parent_sw) {\n\t\ttb_err(tb, \"failed to find parent switch for %llx\\n\", route);\n\t\treturn;\n\t}\n\n\tpm_runtime_get_sync(&parent_sw->dev);\n\n\tsw = alloc_switch(parent_sw, route, &pkg->ep_uuid);\n\tif (!IS_ERR(sw)) {\n\t\tsw->connection_id = pkg->connection_id;\n\t\tsw->authorized = authorized;\n\t\tsw->security_level = security_level;\n\t\tsw->boot = boot;\n\t\tsw->link_speed = speed_gen3 ? 20 : 10;\n\t\tsw->link_width = dual_lane ? TB_LINK_WIDTH_DUAL :\n\t\t\t\t\t     TB_LINK_WIDTH_SINGLE;\n\t\tsw->rpm = force_rtd3;\n\t\tif (!sw->rpm)\n\t\t\tsw->rpm = intel_vss_is_rtd3(pkg->ep_name,\n\t\t\t\t\t\t    sizeof(pkg->ep_name));\n\n\t\tif (add_switch(parent_sw, sw))\n\t\t\ttb_switch_put(sw);\n\t}\n\n\tpm_runtime_mark_last_busy(&parent_sw->dev);\n\tpm_runtime_put_autosuspend(&parent_sw->dev);\n\n\ttb_switch_put(parent_sw);\n}\n\nstatic void\nicm_tr_device_connected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\t__icm_tr_device_connected(tb, hdr, false);\n}\n\nstatic void\nicm_tr_device_disconnected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_tr_event_device_disconnected *pkg =\n\t\t(const struct icm_tr_event_device_disconnected *)hdr;\n\tstruct tb_switch *sw;\n\tu64 route;\n\n\troute = get_route(pkg->route_hi, pkg->route_lo);\n\n\tsw = tb_switch_find_by_route(tb, route);\n\tif (!sw) {\n\t\ttb_warn(tb, \"no switch exists at %llx, ignoring\\n\", route);\n\t\treturn;\n\t}\n\tpm_runtime_get_sync(sw->dev.parent);\n\n\tremove_switch(sw);\n\n\tpm_runtime_mark_last_busy(sw->dev.parent);\n\tpm_runtime_put_autosuspend(sw->dev.parent);\n\n\ttb_switch_put(sw);\n}\n\nstatic void\nicm_tr_xdomain_connected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_tr_event_xdomain_connected *pkg =\n\t\t(const struct icm_tr_event_xdomain_connected *)hdr;\n\tstruct tb_xdomain *xd;\n\tstruct tb_switch *sw;\n\tu64 route;\n\n\tif (!tb->root_switch)\n\t\treturn;\n\n\troute = get_route(pkg->local_route_hi, pkg->local_route_lo);\n\n\txd = tb_xdomain_find_by_uuid(tb, &pkg->remote_uuid);\n\tif (xd) {\n\t\tif (xd->route == route) {\n\t\t\tupdate_xdomain(xd, route, 0);\n\t\t\ttb_xdomain_put(xd);\n\t\t\treturn;\n\t\t}\n\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\t \n\txd = tb_xdomain_find_by_route(tb, route);\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n\n\t \n\tsw = tb_switch_find_by_route(tb, route);\n\tif (sw) {\n\t\tremove_switch(sw);\n\t\ttb_switch_put(sw);\n\t}\n\n\tsw = tb_switch_find_by_route(tb, get_parent_route(route));\n\tif (!sw) {\n\t\ttb_warn(tb, \"no switch exists at %llx, ignoring\\n\", route);\n\t\treturn;\n\t}\n\n\tadd_xdomain(sw, route, &pkg->local_uuid, &pkg->remote_uuid, 0, 0);\n\ttb_switch_put(sw);\n}\n\nstatic void\nicm_tr_xdomain_disconnected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_tr_event_xdomain_disconnected *pkg =\n\t\t(const struct icm_tr_event_xdomain_disconnected *)hdr;\n\tstruct tb_xdomain *xd;\n\tu64 route;\n\n\troute = get_route(pkg->route_hi, pkg->route_lo);\n\n\txd = tb_xdomain_find_by_route(tb, route);\n\tif (xd) {\n\t\tremove_xdomain(xd);\n\t\ttb_xdomain_put(xd);\n\t}\n}\n\nstatic struct pci_dev *get_upstream_port(struct pci_dev *pdev)\n{\n\tstruct pci_dev *parent;\n\n\tparent = pci_upstream_bridge(pdev);\n\twhile (parent) {\n\t\tif (!pci_is_pcie(parent))\n\t\t\treturn NULL;\n\t\tif (pci_pcie_type(parent) == PCI_EXP_TYPE_UPSTREAM)\n\t\t\tbreak;\n\t\tparent = pci_upstream_bridge(parent);\n\t}\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tswitch (parent->device) {\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_LP_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_BRIDGE:\n\tcase PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_BRIDGE:\n\t\treturn parent;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool icm_ar_is_supported(struct tb *tb)\n{\n\tstruct pci_dev *upstream_port;\n\tstruct icm *icm = tb_priv(tb);\n\n\t \n\tif (icm_firmware_running(tb->nhi))\n\t\treturn true;\n\tif (!start_icm)\n\t\treturn false;\n\n\t \n\tupstream_port = get_upstream_port(tb->nhi->pdev);\n\tif (upstream_port) {\n\t\tint cap;\n\n\t\tcap = pci_find_ext_capability(upstream_port,\n\t\t\t\t\t      PCI_EXT_CAP_ID_VNDR);\n\t\tif (cap > 0) {\n\t\t\ticm->upstream_port = upstream_port;\n\t\t\ticm->vnd_cap = cap;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int icm_ar_cio_reset(struct tb *tb)\n{\n\treturn pcie2cio_write(tb_priv(tb), TB_CFG_SWITCH, 0, 0x50, BIT(9));\n}\n\nstatic int icm_ar_get_mode(struct tb *tb)\n{\n\tstruct tb_nhi *nhi = tb->nhi;\n\tint retries = 60;\n\tu32 val;\n\n\tdo {\n\t\tval = ioread32(nhi->iobase + REG_FW_STS);\n\t\tif (val & REG_FW_STS_NVM_AUTH_DONE)\n\t\t\tbreak;\n\t\tmsleep(50);\n\t} while (--retries);\n\n\tif (!retries) {\n\t\tdev_err(&nhi->pdev->dev, \"ICM firmware not authenticated\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn nhi_mailbox_mode(nhi);\n}\n\nstatic int\nicm_ar_driver_ready(struct tb *tb, enum tb_security_level *security_level,\n\t\t    u8 *proto_version, size_t *nboot_acl, bool *rpm)\n{\n\tstruct icm_ar_pkg_driver_ready_response reply;\n\tstruct icm_pkg_driver_ready request = {\n\t\t.hdr.code = ICM_DRIVER_READY,\n\t};\n\tint ret;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (security_level)\n\t\t*security_level = reply.info & ICM_AR_INFO_SLEVEL_MASK;\n\tif (nboot_acl && (reply.info & ICM_AR_INFO_BOOT_ACL_SUPPORTED))\n\t\t*nboot_acl = (reply.info & ICM_AR_INFO_BOOT_ACL_MASK) >>\n\t\t\t\tICM_AR_INFO_BOOT_ACL_SHIFT;\n\tif (rpm)\n\t\t*rpm = !!(reply.hdr.flags & ICM_AR_FLAGS_RTD3);\n\n\treturn 0;\n}\n\nstatic int icm_ar_get_route(struct tb *tb, u8 link, u8 depth, u64 *route)\n{\n\tstruct icm_ar_pkg_get_route_response reply;\n\tstruct icm_ar_pkg_get_route request = {\n\t\t.hdr = { .code = ICM_GET_ROUTE },\n\t\t.link_info = depth << ICM_LINK_INFO_DEPTH_SHIFT | link,\n\t};\n\tint ret;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\t*route = get_route(reply.route_hi, reply.route_lo);\n\treturn 0;\n}\n\nstatic int icm_ar_get_boot_acl(struct tb *tb, uuid_t *uuids, size_t nuuids)\n{\n\tstruct icm_ar_pkg_preboot_acl_response reply;\n\tstruct icm_ar_pkg_preboot_acl request = {\n\t\t.hdr = { .code = ICM_PREBOOT_ACL },\n\t};\n\tint ret, i;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < nuuids; i++) {\n\t\tu32 *uuid = (u32 *)&uuids[i];\n\n\t\tuuid[0] = reply.acl[i].uuid_lo;\n\t\tuuid[1] = reply.acl[i].uuid_hi;\n\n\t\tif (uuid[0] == 0xffffffff && uuid[1] == 0xffffffff) {\n\t\t\t \n\t\t\tuuid[0] = 0;\n\t\t\tuuid[1] = 0;\n\t\t} else if (uuid[0] != 0 || uuid[1] != 0) {\n\t\t\t \n\t\t\tuuid[2] = 0xffffffff;\n\t\t\tuuid[3] = 0xffffffff;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int icm_ar_set_boot_acl(struct tb *tb, const uuid_t *uuids,\n\t\t\t       size_t nuuids)\n{\n\tstruct icm_ar_pkg_preboot_acl_response reply;\n\tstruct icm_ar_pkg_preboot_acl request = {\n\t\t.hdr = {\n\t\t\t.code = ICM_PREBOOT_ACL,\n\t\t\t.flags = ICM_FLAGS_WRITE,\n\t\t},\n\t};\n\tint ret, i;\n\n\tfor (i = 0; i < nuuids; i++) {\n\t\tconst u32 *uuid = (const u32 *)&uuids[i];\n\n\t\tif (uuid_is_null(&uuids[i])) {\n\t\t\t \n\t\t\trequest.acl[i].uuid_lo = 0xffffffff;\n\t\t\trequest.acl[i].uuid_hi = 0xffffffff;\n\t\t} else {\n\t\t\t \n\t\t\tif (uuid[2] != 0xffffffff || uuid[3] != 0xffffffff)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trequest.acl[i].uuid_lo = uuid[0];\n\t\t\trequest.acl[i].uuid_hi = uuid[1];\n\t\t}\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nicm_icl_driver_ready(struct tb *tb, enum tb_security_level *security_level,\n\t\t     u8 *proto_version, size_t *nboot_acl, bool *rpm)\n{\n\tstruct icm_tr_pkg_driver_ready_response reply;\n\tstruct icm_pkg_driver_ready request = {\n\t\t.hdr.code = ICM_DRIVER_READY,\n\t};\n\tint ret;\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, 20000);\n\tif (ret)\n\t\treturn ret;\n\n\tif (proto_version)\n\t\t*proto_version = (reply.info & ICM_TR_INFO_PROTO_VERSION_MASK) >>\n\t\t\t\tICM_TR_INFO_PROTO_VERSION_SHIFT;\n\n\t \n\tif (rpm)\n\t\t*rpm = true;\n\n\treturn 0;\n}\n\nstatic void icm_icl_set_uuid(struct tb *tb)\n{\n\tstruct tb_nhi *nhi = tb->nhi;\n\tu32 uuid[4];\n\n\tpci_read_config_dword(nhi->pdev, VS_CAP_10, &uuid[0]);\n\tpci_read_config_dword(nhi->pdev, VS_CAP_11, &uuid[1]);\n\tuuid[2] = 0xffffffff;\n\tuuid[3] = 0xffffffff;\n\n\ttb->root_switch->uuid = kmemdup(uuid, sizeof(uuid), GFP_KERNEL);\n}\n\nstatic void\nicm_icl_device_connected(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\t__icm_tr_device_connected(tb, hdr, true);\n}\n\nstatic void icm_icl_rtd3_veto(struct tb *tb, const struct icm_pkg_header *hdr)\n{\n\tconst struct icm_icl_event_rtd3_veto *pkg =\n\t\t(const struct icm_icl_event_rtd3_veto *)hdr;\n\n\ttb_dbg(tb, \"ICM rtd3 veto=0x%08x\\n\", pkg->veto_reason);\n\n\tif (pkg->veto_reason)\n\t\ticm_veto_begin(tb);\n\telse\n\t\ticm_veto_end(tb);\n}\n\nstatic bool icm_tgl_is_supported(struct tb *tb)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(10);\n\n\tdo {\n\t\tu32 val;\n\n\t\tval = ioread32(tb->nhi->iobase + REG_FW_STS);\n\t\tif (val & REG_FW_STS_NVM_AUTH_DONE)\n\t\t\treturn true;\n\t\tusleep_range(100, 500);\n\t} while (time_before(jiffies, end));\n\n\treturn false;\n}\n\nstatic void icm_handle_notification(struct work_struct *work)\n{\n\tstruct icm_notification *n = container_of(work, typeof(*n), work);\n\tstruct tb *tb = n->tb;\n\tstruct icm *icm = tb_priv(tb);\n\n\tmutex_lock(&tb->lock);\n\n\t \n\tif (tb->root_switch) {\n\t\tswitch (n->pkg->code) {\n\t\tcase ICM_EVENT_DEVICE_CONNECTED:\n\t\t\ticm->device_connected(tb, n->pkg);\n\t\t\tbreak;\n\t\tcase ICM_EVENT_DEVICE_DISCONNECTED:\n\t\t\ticm->device_disconnected(tb, n->pkg);\n\t\t\tbreak;\n\t\tcase ICM_EVENT_XDOMAIN_CONNECTED:\n\t\t\tif (tb_is_xdomain_enabled())\n\t\t\t\ticm->xdomain_connected(tb, n->pkg);\n\t\t\tbreak;\n\t\tcase ICM_EVENT_XDOMAIN_DISCONNECTED:\n\t\t\tif (tb_is_xdomain_enabled())\n\t\t\t\ticm->xdomain_disconnected(tb, n->pkg);\n\t\t\tbreak;\n\t\tcase ICM_EVENT_RTD3_VETO:\n\t\t\ticm->rtd3_veto(tb, n->pkg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tb->lock);\n\n\tkfree(n->pkg);\n\tkfree(n);\n}\n\nstatic void icm_handle_event(struct tb *tb, enum tb_cfg_pkg_type type,\n\t\t\t     const void *buf, size_t size)\n{\n\tstruct icm_notification *n;\n\n\tn = kmalloc(sizeof(*n), GFP_KERNEL);\n\tif (!n)\n\t\treturn;\n\n\tn->pkg = kmemdup(buf, size, GFP_KERNEL);\n\tif (!n->pkg) {\n\t\tkfree(n);\n\t\treturn;\n\t}\n\n\tINIT_WORK(&n->work, icm_handle_notification);\n\tn->tb = tb;\n\n\tqueue_work(tb->wq, &n->work);\n}\n\nstatic int\n__icm_driver_ready(struct tb *tb, enum tb_security_level *security_level,\n\t\t   u8 *proto_version, size_t *nboot_acl, bool *rpm)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tunsigned int retries = 50;\n\tint ret;\n\n\tret = icm->driver_ready(tb, security_level, proto_version, nboot_acl,\n\t\t\t\trpm);\n\tif (ret) {\n\t\ttb_err(tb, \"failed to send driver ready to ICM\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdo {\n\t\tstruct tb_cfg_result res;\n\t\tu32 tmp;\n\n\t\tres = tb_cfg_read_raw(tb->ctl, &tmp, 0, 0, TB_CFG_SWITCH,\n\t\t\t\t      0, 1, 100);\n\t\tif (!res.err)\n\t\t\treturn 0;\n\n\t\tmsleep(50);\n\t} while (--retries);\n\n\ttb_err(tb, \"failed to read root switch config space, giving up\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int icm_firmware_reset(struct tb *tb, struct tb_nhi *nhi)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tu32 val;\n\n\tif (!icm->upstream_port)\n\t\treturn -ENODEV;\n\n\t \n\tval = ioread32(nhi->iobase + REG_FW_STS);\n\tval |= REG_FW_STS_CIO_RESET_REQ;\n\tiowrite32(val, nhi->iobase + REG_FW_STS);\n\n\t \n\tval = ioread32(nhi->iobase + REG_FW_STS);\n\tval |= REG_FW_STS_ICM_EN_INVERT;\n\tval |= REG_FW_STS_ICM_EN_CPU;\n\tiowrite32(val, nhi->iobase + REG_FW_STS);\n\n\t \n\treturn icm->cio_reset(tb);\n}\n\nstatic int icm_firmware_start(struct tb *tb, struct tb_nhi *nhi)\n{\n\tunsigned int retries = 10;\n\tint ret;\n\tu32 val;\n\n\t \n\tif (icm_firmware_running(nhi))\n\t\treturn 0;\n\n\tdev_dbg(&nhi->pdev->dev, \"starting ICM firmware\\n\");\n\n\tret = icm_firmware_reset(tb, nhi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\t \n\t\tval = ioread32(nhi->iobase + REG_FW_STS);\n\t\tif (val & REG_FW_STS_NVM_AUTH_DONE)\n\t\t\treturn 0;\n\n\t\tmsleep(300);\n\t} while (--retries);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int icm_reset_phy_port(struct tb *tb, int phy_port)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tu32 state0, state1;\n\tint port0, port1;\n\tu32 val0, val1;\n\tint ret;\n\n\tif (!icm->upstream_port)\n\t\treturn 0;\n\n\tif (phy_port) {\n\t\tport0 = 3;\n\t\tport1 = 4;\n\t} else {\n\t\tport0 = 1;\n\t\tport1 = 2;\n\t}\n\n\t \n\tret = pcie2cio_read(icm, TB_CFG_PORT, port0, PHY_PORT_CS1, &val0);\n\tif (ret)\n\t\treturn ret;\n\tret = pcie2cio_read(icm, TB_CFG_PORT, port1, PHY_PORT_CS1, &val1);\n\tif (ret)\n\t\treturn ret;\n\n\tstate0 = val0 & PHY_PORT_CS1_LINK_STATE_MASK;\n\tstate0 >>= PHY_PORT_CS1_LINK_STATE_SHIFT;\n\tstate1 = val1 & PHY_PORT_CS1_LINK_STATE_MASK;\n\tstate1 >>= PHY_PORT_CS1_LINK_STATE_SHIFT;\n\n\t \n\tif (state0 != TB_PORT_UP || state1 != TB_PORT_UP)\n\t\treturn 0;\n\n\tval0 |= PHY_PORT_CS1_LINK_DISABLE;\n\tret = pcie2cio_write(icm, TB_CFG_PORT, port0, PHY_PORT_CS1, val0);\n\tif (ret)\n\t\treturn ret;\n\n\tval1 |= PHY_PORT_CS1_LINK_DISABLE;\n\tret = pcie2cio_write(icm, TB_CFG_PORT, port1, PHY_PORT_CS1, val1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(10, 100);\n\n\tret = pcie2cio_read(icm, TB_CFG_PORT, port0, PHY_PORT_CS1, &val0);\n\tif (ret)\n\t\treturn ret;\n\tret = pcie2cio_read(icm, TB_CFG_PORT, port1, PHY_PORT_CS1, &val1);\n\tif (ret)\n\t\treturn ret;\n\n\tval0 &= ~PHY_PORT_CS1_LINK_DISABLE;\n\tret = pcie2cio_write(icm, TB_CFG_PORT, port0, PHY_PORT_CS1, val0);\n\tif (ret)\n\t\treturn ret;\n\n\tval1 &= ~PHY_PORT_CS1_LINK_DISABLE;\n\treturn pcie2cio_write(icm, TB_CFG_PORT, port1, PHY_PORT_CS1, val1);\n}\n\nstatic int icm_firmware_init(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tstruct tb_nhi *nhi = tb->nhi;\n\tint ret;\n\n\tret = icm_firmware_start(tb, nhi);\n\tif (ret) {\n\t\tdev_err(&nhi->pdev->dev, \"could not start ICM firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tif (icm->get_mode) {\n\t\tret = icm->get_mode(tb);\n\n\t\tswitch (ret) {\n\t\tcase NHI_FW_SAFE_MODE:\n\t\t\ticm->safe_mode = true;\n\t\t\tbreak;\n\n\t\tcase NHI_FW_CM_MODE:\n\t\t\t \n\t\t\tnhi_mailbox_cmd(nhi, NHI_MAILBOX_ALLOW_ALL_DEVS, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\ttb_err(tb, \"ICM firmware is in wrong mode: %u\\n\", ret);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tret = icm_reset_phy_port(tb, 0);\n\tif (ret)\n\t\tdev_warn(&nhi->pdev->dev, \"failed to reset links on port0\\n\");\n\tret = icm_reset_phy_port(tb, 1);\n\tif (ret)\n\t\tdev_warn(&nhi->pdev->dev, \"failed to reset links on port1\\n\");\n\n\treturn 0;\n}\n\nstatic int icm_driver_ready(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tint ret;\n\n\tret = icm_firmware_init(tb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (icm->safe_mode) {\n\t\ttb_info(tb, \"Thunderbolt host controller is in safe mode.\\n\");\n\t\ttb_info(tb, \"You need to update NVM firmware of the controller before it can be used.\\n\");\n\t\ttb_info(tb, \"For latest updates check https://thunderbolttechnology.net/updates.\\n\");\n\t\treturn 0;\n\t}\n\n\tret = __icm_driver_ready(tb, &tb->security_level, &icm->proto_version,\n\t\t\t\t &tb->nboot_acl, &icm->rpm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (tb->nboot_acl > icm->max_boot_acl)\n\t\ttb->nboot_acl = 0;\n\n\tif (icm->proto_version >= 3)\n\t\ttb_dbg(tb, \"USB4 proxy operations supported\\n\");\n\n\treturn 0;\n}\n\nstatic int icm_suspend(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tif (icm->save_devices)\n\t\ticm->save_devices(tb);\n\n\tnhi_mailbox_cmd(tb->nhi, NHI_MAILBOX_DRV_UNLOADS, 0);\n\treturn 0;\n}\n\n \nstatic void icm_unplug_children(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\n\tif (tb_route(sw))\n\t\tsw->is_unplugged = true;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (port->xdomain)\n\t\t\tport->xdomain->is_unplugged = true;\n\t\telse if (tb_port_has_remote(port))\n\t\t\ticm_unplug_children(port->remote->sw);\n\t}\n}\n\nstatic int complete_rpm(struct device *dev, void *data)\n{\n\tstruct tb_switch *sw = tb_to_switch(dev);\n\n\tif (sw)\n\t\tcomplete(&sw->rpm_complete);\n\treturn 0;\n}\n\nstatic void remove_unplugged_switch(struct tb_switch *sw)\n{\n\tstruct device *parent = get_device(sw->dev.parent);\n\n\tpm_runtime_get_sync(parent);\n\n\t \n\tcomplete_rpm(&sw->dev, NULL);\n\tbus_for_each_dev(&tb_bus_type, &sw->dev, NULL, complete_rpm);\n\ttb_switch_remove(sw);\n\n\tpm_runtime_mark_last_busy(parent);\n\tpm_runtime_put_autosuspend(parent);\n\n\tput_device(parent);\n}\n\nstatic void icm_free_unplugged_children(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (port->xdomain && port->xdomain->is_unplugged) {\n\t\t\ttb_xdomain_remove(port->xdomain);\n\t\t\tport->xdomain = NULL;\n\t\t} else if (tb_port_has_remote(port)) {\n\t\t\tif (port->remote->sw->is_unplugged) {\n\t\t\t\tremove_unplugged_switch(port->remote->sw);\n\t\t\t\tport->remote = NULL;\n\t\t\t} else {\n\t\t\t\ticm_free_unplugged_children(port->remote->sw);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void icm_rescan_work(struct work_struct *work)\n{\n\tstruct icm *icm = container_of(work, struct icm, rescan_work.work);\n\tstruct tb *tb = icm_to_tb(icm);\n\n\tmutex_lock(&tb->lock);\n\tif (tb->root_switch)\n\t\ticm_free_unplugged_children(tb->root_switch);\n\tmutex_unlock(&tb->lock);\n}\n\nstatic void icm_complete(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tif (tb->nhi->going_away)\n\t\treturn;\n\n\t \n\ticm_veto_end(tb);\n\ticm_unplug_children(tb->root_switch);\n\n\t \n\t__icm_driver_ready(tb, NULL, NULL, NULL, NULL);\n\n\t \n\tqueue_delayed_work(tb->wq, &icm->rescan_work, msecs_to_jiffies(500));\n}\n\nstatic int icm_runtime_suspend(struct tb *tb)\n{\n\tnhi_mailbox_cmd(tb->nhi, NHI_MAILBOX_DRV_UNLOADS, 0);\n\treturn 0;\n}\n\nstatic int icm_runtime_suspend_switch(struct tb_switch *sw)\n{\n\tif (tb_route(sw))\n\t\treinit_completion(&sw->rpm_complete);\n\treturn 0;\n}\n\nstatic int icm_runtime_resume_switch(struct tb_switch *sw)\n{\n\tif (tb_route(sw)) {\n\t\tif (!wait_for_completion_timeout(&sw->rpm_complete,\n\t\t\t\t\t\t msecs_to_jiffies(500))) {\n\t\t\tdev_dbg(&sw->dev, \"runtime resuming timed out\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int icm_runtime_resume(struct tb *tb)\n{\n\t \n\ticm_complete(tb);\n\treturn 0;\n}\n\nstatic int icm_start(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\tint ret;\n\n\tif (icm->safe_mode)\n\t\ttb->root_switch = tb_switch_alloc_safe_mode(tb, &tb->dev, 0);\n\telse\n\t\ttb->root_switch = tb_switch_alloc(tb, &tb->dev, 0);\n\tif (IS_ERR(tb->root_switch))\n\t\treturn PTR_ERR(tb->root_switch);\n\n\ttb->root_switch->no_nvm_upgrade = !icm->can_upgrade_nvm;\n\ttb->root_switch->rpm = icm->rpm;\n\n\tif (icm->set_uuid)\n\t\ticm->set_uuid(tb);\n\n\tret = tb_switch_add(tb->root_switch);\n\tif (ret) {\n\t\ttb_switch_put(tb->root_switch);\n\t\ttb->root_switch = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void icm_stop(struct tb *tb)\n{\n\tstruct icm *icm = tb_priv(tb);\n\n\tcancel_delayed_work(&icm->rescan_work);\n\ttb_switch_remove(tb->root_switch);\n\ttb->root_switch = NULL;\n\tnhi_mailbox_cmd(tb->nhi, NHI_MAILBOX_DRV_UNLOADS, 0);\n\tkfree(icm->last_nvm_auth);\n\ticm->last_nvm_auth = NULL;\n}\n\nstatic int icm_disconnect_pcie_paths(struct tb *tb)\n{\n\treturn nhi_mailbox_cmd(tb->nhi, NHI_MAILBOX_DISCONNECT_PCIE_PATHS, 0);\n}\n\nstatic void icm_usb4_switch_nvm_auth_complete(void *data)\n{\n\tstruct usb4_switch_nvm_auth *auth = data;\n\tstruct icm *icm = auth->icm;\n\tstruct tb *tb = icm_to_tb(icm);\n\n\ttb_dbg(tb, \"NVM_AUTH response for %llx flags %#x status %#x\\n\",\n\t       get_route(auth->reply.route_hi, auth->reply.route_lo),\n\t       auth->reply.hdr.flags, auth->reply.status);\n\n\tmutex_lock(&tb->lock);\n\tif (WARN_ON(icm->last_nvm_auth))\n\t\tkfree(icm->last_nvm_auth);\n\ticm->last_nvm_auth = auth;\n\tmutex_unlock(&tb->lock);\n}\n\nstatic int icm_usb4_switch_nvm_authenticate(struct tb *tb, u64 route)\n{\n\tstruct usb4_switch_nvm_auth *auth;\n\tstruct icm *icm = tb_priv(tb);\n\tstruct tb_cfg_request *req;\n\tint ret;\n\n\tauth = kzalloc(sizeof(*auth), GFP_KERNEL);\n\tif (!auth)\n\t\treturn -ENOMEM;\n\n\tauth->icm = icm;\n\tauth->request.hdr.code = ICM_USB4_SWITCH_OP;\n\tauth->request.route_hi = upper_32_bits(route);\n\tauth->request.route_lo = lower_32_bits(route);\n\tauth->request.opcode = USB4_SWITCH_OP_NVM_AUTH;\n\n\treq = tb_cfg_request_alloc();\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_auth;\n\t}\n\n\treq->match = icm_match;\n\treq->copy = icm_copy;\n\treq->request = &auth->request;\n\treq->request_size = sizeof(auth->request);\n\treq->request_type = TB_CFG_PKG_ICM_CMD;\n\treq->response = &auth->reply;\n\treq->npackets = 1;\n\treq->response_size = sizeof(auth->reply);\n\treq->response_type = TB_CFG_PKG_ICM_RESP;\n\n\ttb_dbg(tb, \"NVM_AUTH request for %llx\\n\", route);\n\n\tmutex_lock(&icm->request_lock);\n\tret = tb_cfg_request(tb->ctl, req, icm_usb4_switch_nvm_auth_complete,\n\t\t\t     auth);\n\tmutex_unlock(&icm->request_lock);\n\n\ttb_cfg_request_put(req);\n\tif (ret)\n\t\tgoto err_free_auth;\n\treturn 0;\n\nerr_free_auth:\n\tkfree(auth);\n\treturn ret;\n}\n\nstatic int icm_usb4_switch_op(struct tb_switch *sw, u16 opcode, u32 *metadata,\n\t\t\t      u8 *status, const void *tx_data, size_t tx_data_len,\n\t\t\t      void *rx_data, size_t rx_data_len)\n{\n\tstruct icm_usb4_switch_op_response reply;\n\tstruct icm_usb4_switch_op request;\n\tstruct tb *tb = sw->tb;\n\tstruct icm *icm = tb_priv(tb);\n\tu64 route = tb_route(sw);\n\tint ret;\n\n\t \n\tif (icm->proto_version < 3)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (opcode == USB4_SWITCH_OP_NVM_AUTH)\n\t\treturn icm_usb4_switch_nvm_authenticate(tb, route);\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.hdr.code = ICM_USB4_SWITCH_OP;\n\trequest.route_hi = upper_32_bits(route);\n\trequest.route_lo = lower_32_bits(route);\n\trequest.opcode = opcode;\n\tif (metadata)\n\t\trequest.metadata = *metadata;\n\n\tif (tx_data_len) {\n\t\trequest.data_len_valid |= ICM_USB4_SWITCH_DATA_VALID;\n\t\tif (tx_data_len < ARRAY_SIZE(request.data))\n\t\t\trequest.data_len_valid =\n\t\t\t\ttx_data_len & ICM_USB4_SWITCH_DATA_LEN_MASK;\n\t\tmemcpy(request.data, tx_data, tx_data_len * sizeof(u32));\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\tret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),\n\t\t\t  1, ICM_RETRIES, ICM_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\treturn -EIO;\n\n\tif (status)\n\t\t*status = reply.status;\n\n\tif (metadata)\n\t\t*metadata = reply.metadata;\n\n\tif (rx_data_len)\n\t\tmemcpy(rx_data, reply.data, rx_data_len * sizeof(u32));\n\n\treturn 0;\n}\n\nstatic int icm_usb4_switch_nvm_authenticate_status(struct tb_switch *sw,\n\t\t\t\t\t\t   u32 *status)\n{\n\tstruct usb4_switch_nvm_auth *auth;\n\tstruct tb *tb = sw->tb;\n\tstruct icm *icm = tb_priv(tb);\n\tint ret = 0;\n\n\tif (icm->proto_version < 3)\n\t\treturn -EOPNOTSUPP;\n\n\tauth = icm->last_nvm_auth;\n\ticm->last_nvm_auth = NULL;\n\n\tif (auth && auth->reply.route_hi == sw->config.route_hi &&\n\t    auth->reply.route_lo == sw->config.route_lo) {\n\t\ttb_dbg(tb, \"NVM_AUTH found for %llx flags %#x status %#x\\n\",\n\t\t       tb_route(sw), auth->reply.hdr.flags, auth->reply.status);\n\t\tif (auth->reply.hdr.flags & ICM_FLAGS_ERROR)\n\t\t\tret = -EIO;\n\t\telse\n\t\t\t*status = auth->reply.status;\n\t} else {\n\t\t*status = 0;\n\t}\n\n\tkfree(auth);\n\treturn ret;\n}\n\n \nstatic const struct tb_cm_ops icm_fr_ops = {\n\t.driver_ready = icm_driver_ready,\n\t.start = icm_start,\n\t.stop = icm_stop,\n\t.suspend = icm_suspend,\n\t.complete = icm_complete,\n\t.handle_event = icm_handle_event,\n\t.approve_switch = icm_fr_approve_switch,\n\t.add_switch_key = icm_fr_add_switch_key,\n\t.challenge_switch_key = icm_fr_challenge_switch_key,\n\t.disconnect_pcie_paths = icm_disconnect_pcie_paths,\n\t.approve_xdomain_paths = icm_fr_approve_xdomain_paths,\n\t.disconnect_xdomain_paths = icm_fr_disconnect_xdomain_paths,\n};\n\n \nstatic const struct tb_cm_ops icm_ar_ops = {\n\t.driver_ready = icm_driver_ready,\n\t.start = icm_start,\n\t.stop = icm_stop,\n\t.suspend = icm_suspend,\n\t.complete = icm_complete,\n\t.runtime_suspend = icm_runtime_suspend,\n\t.runtime_resume = icm_runtime_resume,\n\t.runtime_suspend_switch = icm_runtime_suspend_switch,\n\t.runtime_resume_switch = icm_runtime_resume_switch,\n\t.handle_event = icm_handle_event,\n\t.get_boot_acl = icm_ar_get_boot_acl,\n\t.set_boot_acl = icm_ar_set_boot_acl,\n\t.approve_switch = icm_fr_approve_switch,\n\t.add_switch_key = icm_fr_add_switch_key,\n\t.challenge_switch_key = icm_fr_challenge_switch_key,\n\t.disconnect_pcie_paths = icm_disconnect_pcie_paths,\n\t.approve_xdomain_paths = icm_fr_approve_xdomain_paths,\n\t.disconnect_xdomain_paths = icm_fr_disconnect_xdomain_paths,\n};\n\n \nstatic const struct tb_cm_ops icm_tr_ops = {\n\t.driver_ready = icm_driver_ready,\n\t.start = icm_start,\n\t.stop = icm_stop,\n\t.suspend = icm_suspend,\n\t.complete = icm_complete,\n\t.runtime_suspend = icm_runtime_suspend,\n\t.runtime_resume = icm_runtime_resume,\n\t.runtime_suspend_switch = icm_runtime_suspend_switch,\n\t.runtime_resume_switch = icm_runtime_resume_switch,\n\t.handle_event = icm_handle_event,\n\t.get_boot_acl = icm_ar_get_boot_acl,\n\t.set_boot_acl = icm_ar_set_boot_acl,\n\t.approve_switch = icm_tr_approve_switch,\n\t.add_switch_key = icm_tr_add_switch_key,\n\t.challenge_switch_key = icm_tr_challenge_switch_key,\n\t.disconnect_pcie_paths = icm_disconnect_pcie_paths,\n\t.approve_xdomain_paths = icm_tr_approve_xdomain_paths,\n\t.disconnect_xdomain_paths = icm_tr_disconnect_xdomain_paths,\n\t.usb4_switch_op = icm_usb4_switch_op,\n\t.usb4_switch_nvm_authenticate_status =\n\t\ticm_usb4_switch_nvm_authenticate_status,\n};\n\n \nstatic const struct tb_cm_ops icm_icl_ops = {\n\t.driver_ready = icm_driver_ready,\n\t.start = icm_start,\n\t.stop = icm_stop,\n\t.complete = icm_complete,\n\t.runtime_suspend = icm_runtime_suspend,\n\t.runtime_resume = icm_runtime_resume,\n\t.handle_event = icm_handle_event,\n\t.approve_xdomain_paths = icm_tr_approve_xdomain_paths,\n\t.disconnect_xdomain_paths = icm_tr_disconnect_xdomain_paths,\n\t.usb4_switch_op = icm_usb4_switch_op,\n\t.usb4_switch_nvm_authenticate_status =\n\t\ticm_usb4_switch_nvm_authenticate_status,\n};\n\nstruct tb *icm_probe(struct tb_nhi *nhi)\n{\n\tstruct icm *icm;\n\tstruct tb *tb;\n\n\ttb = tb_domain_alloc(nhi, ICM_TIMEOUT, sizeof(struct icm));\n\tif (!tb)\n\t\treturn NULL;\n\n\ticm = tb_priv(tb);\n\tINIT_DELAYED_WORK(&icm->rescan_work, icm_rescan_work);\n\tmutex_init(&icm->request_lock);\n\n\tswitch (nhi->pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI:\n\t\ticm->can_upgrade_nvm = true;\n\t\ticm->is_supported = icm_fr_is_supported;\n\t\ticm->get_route = icm_fr_get_route;\n\t\ticm->save_devices = icm_fr_save_devices;\n\t\ticm->driver_ready = icm_fr_driver_ready;\n\t\ticm->device_connected = icm_fr_device_connected;\n\t\ticm->device_disconnected = icm_fr_device_disconnected;\n\t\ticm->xdomain_connected = icm_fr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_fr_xdomain_disconnected;\n\t\ttb->cm_ops = &icm_fr_ops;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_LP_NHI:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_NHI:\n\t\ticm->max_boot_acl = ICM_AR_PREBOOT_ACL_ENTRIES;\n\t\t \n\t\ticm->can_upgrade_nvm = !x86_apple_machine;\n\t\ticm->is_supported = icm_ar_is_supported;\n\t\ticm->cio_reset = icm_ar_cio_reset;\n\t\ticm->get_mode = icm_ar_get_mode;\n\t\ticm->get_route = icm_ar_get_route;\n\t\ticm->save_devices = icm_fr_save_devices;\n\t\ticm->driver_ready = icm_ar_driver_ready;\n\t\ticm->device_connected = icm_fr_device_connected;\n\t\ticm->device_disconnected = icm_fr_device_disconnected;\n\t\ticm->xdomain_connected = icm_fr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_fr_xdomain_disconnected;\n\t\ttb->cm_ops = &icm_ar_ops;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_NHI:\n\t\ticm->max_boot_acl = ICM_AR_PREBOOT_ACL_ENTRIES;\n\t\ticm->can_upgrade_nvm = !x86_apple_machine;\n\t\ticm->is_supported = icm_ar_is_supported;\n\t\ticm->cio_reset = icm_tr_cio_reset;\n\t\ticm->get_mode = icm_ar_get_mode;\n\t\ticm->driver_ready = icm_tr_driver_ready;\n\t\ticm->device_connected = icm_tr_device_connected;\n\t\ticm->device_disconnected = icm_tr_device_disconnected;\n\t\ticm->xdomain_connected = icm_tr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_tr_xdomain_disconnected;\n\t\ttb->cm_ops = &icm_tr_ops;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_ICL_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_ICL_NHI1:\n\t\ticm->is_supported = icm_fr_is_supported;\n\t\ticm->driver_ready = icm_icl_driver_ready;\n\t\ticm->set_uuid = icm_icl_set_uuid;\n\t\ticm->device_connected = icm_icl_device_connected;\n\t\ticm->device_disconnected = icm_tr_device_disconnected;\n\t\ticm->xdomain_connected = icm_tr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_tr_xdomain_disconnected;\n\t\ticm->rtd3_veto = icm_icl_rtd3_veto;\n\t\ttb->cm_ops = &icm_icl_ops;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_TGL_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_TGL_NHI1:\n\tcase PCI_DEVICE_ID_INTEL_TGL_H_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_TGL_H_NHI1:\n\tcase PCI_DEVICE_ID_INTEL_ADL_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_ADL_NHI1:\n\tcase PCI_DEVICE_ID_INTEL_RPL_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_RPL_NHI1:\n\tcase PCI_DEVICE_ID_INTEL_MTL_M_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_MTL_P_NHI0:\n\tcase PCI_DEVICE_ID_INTEL_MTL_P_NHI1:\n\t\ticm->is_supported = icm_tgl_is_supported;\n\t\ticm->driver_ready = icm_icl_driver_ready;\n\t\ticm->set_uuid = icm_icl_set_uuid;\n\t\ticm->device_connected = icm_icl_device_connected;\n\t\ticm->device_disconnected = icm_tr_device_disconnected;\n\t\ticm->xdomain_connected = icm_tr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_tr_xdomain_disconnected;\n\t\ticm->rtd3_veto = icm_icl_rtd3_veto;\n\t\ttb->cm_ops = &icm_icl_ops;\n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_INTEL_MAPLE_RIDGE_2C_NHI:\n\tcase PCI_DEVICE_ID_INTEL_MAPLE_RIDGE_4C_NHI:\n\t\ticm->is_supported = icm_tgl_is_supported;\n\t\ticm->get_mode = icm_ar_get_mode;\n\t\ticm->driver_ready = icm_tr_driver_ready;\n\t\ticm->device_connected = icm_tr_device_connected;\n\t\ticm->device_disconnected = icm_tr_device_disconnected;\n\t\ticm->xdomain_connected = icm_tr_xdomain_connected;\n\t\ticm->xdomain_disconnected = icm_tr_xdomain_disconnected;\n\t\ttb->cm_ops = &icm_tr_ops;\n\t\tbreak;\n\t}\n\n\tif (!icm->is_supported || !icm->is_supported(tb)) {\n\t\tdev_dbg(&nhi->pdev->dev, \"ICM not supported on this controller\\n\");\n\t\ttb_domain_put(tb);\n\t\treturn NULL;\n\t}\n\n\ttb_dbg(tb, \"using firmware connection manager\\n\");\n\n\treturn tb;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}