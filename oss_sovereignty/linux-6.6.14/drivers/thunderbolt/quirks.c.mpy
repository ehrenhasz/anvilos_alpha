{
  "module_name": "quirks.c",
  "hash_id": "367671a6656aae87b375adfd947105027340ad436093d9daf92032c035b5e7e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/quirks.c",
  "human_readable_source": "\n \n\n#include \"tb.h\"\n\nstatic void quirk_force_power_link(struct tb_switch *sw)\n{\n\tsw->quirks |= QUIRK_FORCE_POWER_LINK_CONTROLLER;\n\ttb_sw_dbg(sw, \"forcing power to link controller\\n\");\n}\n\nstatic void quirk_dp_credit_allocation(struct tb_switch *sw)\n{\n\tif (sw->credit_allocation && sw->min_dp_main_credits == 56) {\n\t\tsw->min_dp_main_credits = 18;\n\t\ttb_sw_dbg(sw, \"quirked DP main: %u\\n\", sw->min_dp_main_credits);\n\t}\n}\n\nstatic void quirk_clx_disable(struct tb_switch *sw)\n{\n\tsw->quirks |= QUIRK_NO_CLX;\n\ttb_sw_dbg(sw, \"disabling CL states\\n\");\n}\n\nstatic void quirk_usb3_maximum_bandwidth(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\n\tif (tb_switch_is_icm(sw))\n\t\treturn;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (!tb_port_is_usb3_down(port))\n\t\t\tcontinue;\n\t\tport->max_bw = 16376;\n\t\ttb_port_dbg(port, \"USB3 maximum bandwidth limited to %u Mb/s\\n\",\n\t\t\t    port->max_bw);\n\t}\n}\n\nstruct tb_quirk {\n\tu16 hw_vendor_id;\n\tu16 hw_device_id;\n\tu16 vendor;\n\tu16 device;\n\tvoid (*hook)(struct tb_switch *sw);\n};\n\nstatic const struct tb_quirk tb_quirks[] = {\n\t \n\t{ 0x0000, 0x0000, 0x00d4, 0xb070, quirk_force_power_link },\n\t{ 0x0000, 0x0000, 0x00d4, 0xb071, quirk_force_power_link },\n\t \n\t{ 0x8087, 0x0b26, 0x0000, 0x0000, quirk_dp_credit_allocation },\n\t \n\t{ 0x8087, PCI_DEVICE_ID_INTEL_ADL_NHI0, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_ADL_NHI1, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_RPL_NHI0, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_RPL_NHI1, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_MTL_M_NHI0, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_MTL_P_NHI0, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_MTL_P_NHI1, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_BARLOW_RIDGE_HOST_80G_NHI, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_BARLOW_RIDGE_HOST_40G_NHI, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_BARLOW_RIDGE_HUB_80G_BRIDGE, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t{ 0x8087, PCI_DEVICE_ID_INTEL_BARLOW_RIDGE_HUB_40G_BRIDGE, 0x0000, 0x0000,\n\t\t  quirk_usb3_maximum_bandwidth },\n\t \n\t{ 0x0438, 0x0208, 0x0000, 0x0000, quirk_clx_disable },\n\t{ 0x0438, 0x0209, 0x0000, 0x0000, quirk_clx_disable },\n\t{ 0x0438, 0x020a, 0x0000, 0x0000, quirk_clx_disable },\n\t{ 0x0438, 0x020b, 0x0000, 0x0000, quirk_clx_disable },\n};\n\n \nvoid tb_check_quirks(struct tb_switch *sw)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tb_quirks); i++) {\n\t\tconst struct tb_quirk *q = &tb_quirks[i];\n\n\t\tif (q->hw_vendor_id && q->hw_vendor_id != sw->config.vendor_id)\n\t\t\tcontinue;\n\t\tif (q->hw_device_id && q->hw_device_id != sw->config.device_id)\n\t\t\tcontinue;\n\t\tif (q->vendor && q->vendor != sw->vendor)\n\t\t\tcontinue;\n\t\tif (q->device && q->device != sw->device)\n\t\t\tcontinue;\n\n\t\ttb_sw_dbg(sw, \"running %ps\\n\", q->hook);\n\t\tq->hook(sw);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}