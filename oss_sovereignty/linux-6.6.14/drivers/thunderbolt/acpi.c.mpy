{
  "module_name": "acpi.c",
  "hash_id": "b38b011f4d44ebebe87dc5eed0e022833ae805559f6f887f10441da79d58f536",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/pm_runtime.h>\n\n#include \"tb.h\"\n\nstatic acpi_status tb_acpi_add_link(acpi_handle handle, u32 level, void *data,\n\t\t\t\t    void **ret)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tstruct fwnode_handle *fwnode;\n\tstruct tb_nhi *nhi = data;\n\tstruct pci_dev *pdev;\n\tstruct device *dev;\n\n\tif (!adev)\n\t\treturn AE_OK;\n\n\tfwnode = fwnode_find_reference(acpi_fwnode_handle(adev), \"usb4-host-interface\", 0);\n\tif (IS_ERR(fwnode))\n\t\treturn AE_OK;\n\n\t \n\tif (dev_fwnode(&nhi->pdev->dev) != fwnode)\n\t\tgoto out_put;\n\n\t \n\tdo {\n\t\tdev = acpi_get_first_physical_node(adev);\n\t\tif (dev)\n\t\t\tbreak;\n\n\t\tadev = acpi_dev_parent(adev);\n\t} while (adev);\n\n\t \n\twhile (dev && !dev_is_pci(dev))\n\t\tdev = dev->parent;\n\n\tif (!dev)\n\t\tgoto out_put;\n\n\t \n\tpdev = to_pci_dev(dev);\n\tif (pdev->class == PCI_CLASS_SERIAL_USB_XHCI ||\n\t    (pci_is_pcie(pdev) &&\n\t\t(pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t\t pci_pcie_type(pdev) == PCI_EXP_TYPE_DOWNSTREAM))) {\n\t\tconst struct device_link *link;\n\n\t\t \n\t\tpm_runtime_get_sync(&pdev->dev);\n\n\t\tlink = device_link_add(&pdev->dev, &nhi->pdev->dev,\n\t\t\t\t       DL_FLAG_AUTOREMOVE_SUPPLIER |\n\t\t\t\t       DL_FLAG_RPM_ACTIVE |\n\t\t\t\t       DL_FLAG_PM_RUNTIME);\n\t\tif (link) {\n\t\t\tdev_dbg(&nhi->pdev->dev, \"created link from %s\\n\",\n\t\t\t\tdev_name(&pdev->dev));\n\t\t\t*(bool *)ret = true;\n\t\t} else {\n\t\t\tdev_warn(&nhi->pdev->dev, \"device link creation from %s failed\\n\",\n\t\t\t\t dev_name(&pdev->dev));\n\t\t}\n\n\t\tpm_runtime_put(&pdev->dev);\n\t}\n\nout_put:\n\tfwnode_handle_put(fwnode);\n\treturn AE_OK;\n}\n\n \nbool tb_acpi_add_links(struct tb_nhi *nhi)\n{\n\tacpi_status status;\n\tbool ret = false;\n\n\tif (!has_acpi_companion(&nhi->pdev->dev))\n\t\treturn false;\n\n\t \n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, 32,\n\t\t\t\t     tb_acpi_add_link, NULL, nhi, (void **)&ret);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(&nhi->pdev->dev, \"failed to enumerate tunneled ports\\n\");\n\t\treturn false;\n\t}\n\n\treturn ret;\n}\n\n \nbool tb_acpi_is_native(void)\n{\n\treturn osc_sb_native_usb4_support_confirmed &&\n\t       osc_sb_native_usb4_control;\n}\n\n \nbool tb_acpi_may_tunnel_usb3(void)\n{\n\tif (tb_acpi_is_native())\n\t\treturn osc_sb_native_usb4_control & OSC_USB_USB3_TUNNELING;\n\treturn true;\n}\n\n \nbool tb_acpi_may_tunnel_dp(void)\n{\n\tif (tb_acpi_is_native())\n\t\treturn osc_sb_native_usb4_control & OSC_USB_DP_TUNNELING;\n\treturn true;\n}\n\n \nbool tb_acpi_may_tunnel_pcie(void)\n{\n\tif (tb_acpi_is_native())\n\t\treturn osc_sb_native_usb4_control & OSC_USB_PCIE_TUNNELING;\n\treturn true;\n}\n\n \nbool tb_acpi_is_xdomain_allowed(void)\n{\n\tif (tb_acpi_is_native())\n\t\treturn osc_sb_native_usb4_control & OSC_USB_XDOMAIN;\n\treturn true;\n}\n\n \nstatic const guid_t retimer_dsm_guid =\n\tGUID_INIT(0xe0053122, 0x795b, 0x4122,\n\t\t  0x8a, 0x5e, 0x57, 0xbe, 0x1d, 0x26, 0xac, 0xb3);\n\n#define RETIMER_DSM_QUERY_ONLINE_STATE\t1\n#define RETIMER_DSM_SET_ONLINE_STATE\t2\n\nstatic int tb_acpi_retimer_set_power(struct tb_port *port, bool power)\n{\n\tstruct usb4_port *usb4 = port->usb4;\n\tunion acpi_object argv4[2];\n\tstruct acpi_device *adev;\n\tunion acpi_object *obj;\n\tint ret;\n\n\tif (!usb4->can_offline)\n\t\treturn 0;\n\n\tadev = ACPI_COMPANION(&usb4->dev);\n\tif (WARN_ON(!adev))\n\t\treturn 0;\n\n\t \n\tobj = acpi_evaluate_dsm_typed(adev->handle, &retimer_dsm_guid, 1,\n\t\t\t\t      RETIMER_DSM_QUERY_ONLINE_STATE, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\ttb_port_warn(port, \"ACPI: query online _DSM failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = obj->integer.value;\n\tACPI_FREE(obj);\n\n\tif (power == ret)\n\t\treturn 0;\n\n\ttb_port_dbg(port, \"ACPI: calling _DSM to power %s retimers\\n\",\n\t\t    power ? \"on\" : \"off\");\n\n\targv4[0].type = ACPI_TYPE_PACKAGE;\n\targv4[0].package.count = 1;\n\targv4[0].package.elements = &argv4[1];\n\targv4[1].integer.type = ACPI_TYPE_INTEGER;\n\targv4[1].integer.value = power;\n\n\tobj = acpi_evaluate_dsm_typed(adev->handle, &retimer_dsm_guid, 1,\n\t\t\t\t      RETIMER_DSM_SET_ONLINE_STATE, argv4,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\ttb_port_warn(port,\n\t\t\t     \"ACPI: set online state _DSM evaluation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = obj->integer.value;\n\tACPI_FREE(obj);\n\n\tif (ret >= 0) {\n\t\tif (power)\n\t\t\treturn ret == 1 ? 0 : -EBUSY;\n\t\treturn 0;\n\t}\n\n\ttb_port_warn(port, \"ACPI: set online state _DSM failed with error %d\\n\", ret);\n\treturn -EIO;\n}\n\n \nint tb_acpi_power_on_retimers(struct tb_port *port)\n{\n\treturn tb_acpi_retimer_set_power(port, true);\n}\n\n \nint tb_acpi_power_off_retimers(struct tb_port *port)\n{\n\treturn tb_acpi_retimer_set_power(port, false);\n}\n\nstatic bool tb_acpi_bus_match(struct device *dev)\n{\n\treturn tb_is_switch(dev) || tb_is_usb4_port_device(dev);\n}\n\nstatic struct acpi_device *tb_acpi_switch_find_companion(struct tb_switch *sw)\n{\n\tstruct tb_switch *parent_sw = tb_switch_parent(sw);\n\tstruct acpi_device *adev = NULL;\n\n\t \n\tif (parent_sw) {\n\t\tstruct tb_port *port = tb_switch_downstream_port(sw);\n\t\tstruct acpi_device *port_adev;\n\n\t\tport_adev = acpi_find_child_by_adr(ACPI_COMPANION(&parent_sw->dev),\n\t\t\t\t\t\t   port->port);\n\t\tif (port_adev)\n\t\t\tadev = acpi_find_child_device(port_adev, 0, false);\n\t} else {\n\t\tstruct tb_nhi *nhi = sw->tb->nhi;\n\t\tstruct acpi_device *parent_adev;\n\n\t\tparent_adev = ACPI_COMPANION(&nhi->pdev->dev);\n\t\tif (parent_adev)\n\t\t\tadev = acpi_find_child_device(parent_adev, 0, false);\n\t}\n\n\treturn adev;\n}\n\nstatic struct acpi_device *tb_acpi_find_companion(struct device *dev)\n{\n\t \n\tif (tb_is_switch(dev))\n\t\treturn tb_acpi_switch_find_companion(tb_to_switch(dev));\n\tif (tb_is_usb4_port_device(dev))\n\t\treturn acpi_find_child_by_adr(ACPI_COMPANION(dev->parent),\n\t\t\t\t\t      tb_to_usb4_port_device(dev)->port->port);\n\treturn NULL;\n}\n\nstatic void tb_acpi_setup(struct device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\n\tif (!adev || !usb4)\n\t\treturn;\n\n\tif (acpi_check_dsm(adev->handle, &retimer_dsm_guid, 1,\n\t\t\t   BIT(RETIMER_DSM_QUERY_ONLINE_STATE) |\n\t\t\t   BIT(RETIMER_DSM_SET_ONLINE_STATE)))\n\t\tusb4->can_offline = true;\n}\n\nstatic struct acpi_bus_type tb_acpi_bus = {\n\t.name = \"thunderbolt\",\n\t.match = tb_acpi_bus_match,\n\t.find_companion = tb_acpi_find_companion,\n\t.setup = tb_acpi_setup,\n};\n\nint tb_acpi_init(void)\n{\n\treturn register_acpi_bus_type(&tb_acpi_bus);\n}\n\nvoid tb_acpi_exit(void)\n{\n\tunregister_acpi_bus_type(&tb_acpi_bus);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}