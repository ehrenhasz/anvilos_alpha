{
  "module_name": "property.c",
  "hash_id": "f0e0b9feac9bbda31e3c6d9e961e5526592ebd949c2f8d83518f3a41ff9cf878",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/property.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uuid.h>\n#include <linux/thunderbolt.h>\n\nstruct tb_property_entry {\n\tu32 key_hi;\n\tu32 key_lo;\n\tu16 length;\n\tu8 reserved;\n\tu8 type;\n\tu32 value;\n};\n\nstruct tb_property_rootdir_entry {\n\tu32 magic;\n\tu32 length;\n\tstruct tb_property_entry entries[];\n};\n\nstruct tb_property_dir_entry {\n\tu32 uuid[4];\n\tstruct tb_property_entry entries[];\n};\n\n#define TB_PROPERTY_ROOTDIR_MAGIC\t0x55584401\n\nstatic struct tb_property_dir *__tb_property_parse_dir(const u32 *block,\n\tsize_t block_len, unsigned int dir_offset, size_t dir_len,\n\tbool is_root);\n\nstatic inline void parse_dwdata(void *dst, const void *src, size_t dwords)\n{\n\tbe32_to_cpu_array(dst, src, dwords);\n}\n\nstatic inline void format_dwdata(void *dst, const void *src, size_t dwords)\n{\n\tcpu_to_be32_array(dst, src, dwords);\n}\n\nstatic bool tb_property_entry_valid(const struct tb_property_entry *entry,\n\t\t\t\t  size_t block_len)\n{\n\tswitch (entry->type) {\n\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\tcase TB_PROPERTY_TYPE_DATA:\n\tcase TB_PROPERTY_TYPE_TEXT:\n\t\tif (entry->length > block_len)\n\t\t\treturn false;\n\t\tif (entry->value + entry->length > block_len)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_VALUE:\n\t\tif (entry->length != 1)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool tb_property_key_valid(const char *key)\n{\n\treturn key && strlen(key) <= TB_PROPERTY_KEY_SIZE;\n}\n\nstatic struct tb_property *\ntb_property_alloc(const char *key, enum tb_property_type type)\n{\n\tstruct tb_property *property;\n\n\tproperty = kzalloc(sizeof(*property), GFP_KERNEL);\n\tif (!property)\n\t\treturn NULL;\n\n\tstrcpy(property->key, key);\n\tproperty->type = type;\n\tINIT_LIST_HEAD(&property->list);\n\n\treturn property;\n}\n\nstatic struct tb_property *tb_property_parse(const u32 *block, size_t block_len,\n\t\t\t\t\tconst struct tb_property_entry *entry)\n{\n\tchar key[TB_PROPERTY_KEY_SIZE + 1];\n\tstruct tb_property *property;\n\tstruct tb_property_dir *dir;\n\n\tif (!tb_property_entry_valid(entry, block_len))\n\t\treturn NULL;\n\n\tparse_dwdata(key, entry, 2);\n\tkey[TB_PROPERTY_KEY_SIZE] = '\\0';\n\n\tproperty = tb_property_alloc(key, entry->type);\n\tif (!property)\n\t\treturn NULL;\n\n\tproperty->length = entry->length;\n\n\tswitch (property->type) {\n\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\t\tdir = __tb_property_parse_dir(block, block_len, entry->value,\n\t\t\t\t\t      entry->length, false);\n\t\tif (!dir) {\n\t\t\tkfree(property);\n\t\t\treturn NULL;\n\t\t}\n\t\tproperty->value.dir = dir;\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_DATA:\n\t\tproperty->value.data = kcalloc(property->length, sizeof(u32),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!property->value.data) {\n\t\t\tkfree(property);\n\t\t\treturn NULL;\n\t\t}\n\t\tparse_dwdata(property->value.data, block + entry->value,\n\t\t\t     entry->length);\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_TEXT:\n\t\tproperty->value.text = kcalloc(property->length, sizeof(u32),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!property->value.text) {\n\t\t\tkfree(property);\n\t\t\treturn NULL;\n\t\t}\n\t\tparse_dwdata(property->value.text, block + entry->value,\n\t\t\t     entry->length);\n\t\t \n\t\tproperty->value.text[property->length * 4 - 1] = '\\0';\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_VALUE:\n\t\tproperty->value.immediate = entry->value;\n\t\tbreak;\n\n\tdefault:\n\t\tproperty->type = TB_PROPERTY_TYPE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn property;\n}\n\nstatic struct tb_property_dir *__tb_property_parse_dir(const u32 *block,\n\tsize_t block_len, unsigned int dir_offset, size_t dir_len, bool is_root)\n{\n\tconst struct tb_property_entry *entries;\n\tsize_t i, content_len, nentries;\n\tunsigned int content_offset;\n\tstruct tb_property_dir *dir;\n\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\treturn NULL;\n\n\tif (is_root) {\n\t\tcontent_offset = dir_offset + 2;\n\t\tcontent_len = dir_len;\n\t} else {\n\t\tdir->uuid = kmemdup(&block[dir_offset], sizeof(*dir->uuid),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!dir->uuid) {\n\t\t\ttb_property_free_dir(dir);\n\t\t\treturn NULL;\n\t\t}\n\t\tcontent_offset = dir_offset + 4;\n\t\tcontent_len = dir_len - 4;  \n\t}\n\n\tentries = (const struct tb_property_entry *)&block[content_offset];\n\tnentries = content_len / (sizeof(*entries) / 4);\n\n\tINIT_LIST_HEAD(&dir->properties);\n\n\tfor (i = 0; i < nentries; i++) {\n\t\tstruct tb_property *property;\n\n\t\tproperty = tb_property_parse(block, block_len, &entries[i]);\n\t\tif (!property) {\n\t\t\ttb_property_free_dir(dir);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlist_add_tail(&property->list, &dir->properties);\n\t}\n\n\treturn dir;\n}\n\n \nstruct tb_property_dir *tb_property_parse_dir(const u32 *block,\n\t\t\t\t\t      size_t block_len)\n{\n\tconst struct tb_property_rootdir_entry *rootdir =\n\t\t(const struct tb_property_rootdir_entry *)block;\n\n\tif (rootdir->magic != TB_PROPERTY_ROOTDIR_MAGIC)\n\t\treturn NULL;\n\tif (rootdir->length > block_len)\n\t\treturn NULL;\n\n\treturn __tb_property_parse_dir(block, block_len, 0, rootdir->length,\n\t\t\t\t       true);\n}\n\n \nstruct tb_property_dir *tb_property_create_dir(const uuid_t *uuid)\n{\n\tstruct tb_property_dir *dir;\n\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dir->properties);\n\tif (uuid) {\n\t\tdir->uuid = kmemdup(uuid, sizeof(*dir->uuid), GFP_KERNEL);\n\t\tif (!dir->uuid) {\n\t\t\tkfree(dir);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn dir;\n}\nEXPORT_SYMBOL_GPL(tb_property_create_dir);\n\nstatic void tb_property_free(struct tb_property *property)\n{\n\tswitch (property->type) {\n\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\t\ttb_property_free_dir(property->value.dir);\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_DATA:\n\t\tkfree(property->value.data);\n\t\tbreak;\n\n\tcase TB_PROPERTY_TYPE_TEXT:\n\t\tkfree(property->value.text);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(property);\n}\n\n \nvoid tb_property_free_dir(struct tb_property_dir *dir)\n{\n\tstruct tb_property *property, *tmp;\n\n\tif (!dir)\n\t\treturn;\n\n\tlist_for_each_entry_safe(property, tmp, &dir->properties, list) {\n\t\tlist_del(&property->list);\n\t\ttb_property_free(property);\n\t}\n\tkfree(dir->uuid);\n\tkfree(dir);\n}\nEXPORT_SYMBOL_GPL(tb_property_free_dir);\n\nstatic size_t tb_property_dir_length(const struct tb_property_dir *dir,\n\t\t\t\t     bool recurse, size_t *data_len)\n{\n\tconst struct tb_property *property;\n\tsize_t len = 0;\n\n\tif (dir->uuid)\n\t\tlen += sizeof(*dir->uuid) / 4;\n\telse\n\t\tlen += sizeof(struct tb_property_rootdir_entry) / 4;\n\n\tlist_for_each_entry(property, &dir->properties, list) {\n\t\tlen += sizeof(struct tb_property_entry) / 4;\n\n\t\tswitch (property->type) {\n\t\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\t\t\tif (recurse) {\n\t\t\t\tlen += tb_property_dir_length(\n\t\t\t\t\tproperty->value.dir, recurse, data_len);\n\t\t\t}\n\t\t\t \n\t\t\tif (data_len)\n\t\t\t\t*data_len += 1;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_DATA:\n\t\tcase TB_PROPERTY_TYPE_TEXT:\n\t\t\tif (data_len)\n\t\t\t\t*data_len += property->length;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t __tb_property_format_dir(const struct tb_property_dir *dir,\n\tu32 *block, unsigned int start_offset, size_t block_len)\n{\n\tunsigned int data_offset, dir_end;\n\tconst struct tb_property *property;\n\tstruct tb_property_entry *entry;\n\tsize_t dir_len, data_len = 0;\n\tint ret;\n\n\t \n\tdir_len = tb_property_dir_length(dir, false, &data_len);\n\tdata_offset = start_offset + dir_len;\n\tdir_end = start_offset + data_len + dir_len;\n\n\tif (data_offset > dir_end)\n\t\treturn -EINVAL;\n\tif (dir_end > block_len)\n\t\treturn -EINVAL;\n\n\t \n\tif (dir->uuid) {\n\t\tstruct tb_property_dir_entry *pe;\n\n\t\tpe = (struct tb_property_dir_entry *)&block[start_offset];\n\t\tmemcpy(pe->uuid, dir->uuid, sizeof(pe->uuid));\n\t\tentry = pe->entries;\n\t} else {\n\t\tstruct tb_property_rootdir_entry *re;\n\n\t\tre = (struct tb_property_rootdir_entry *)&block[start_offset];\n\t\tre->magic = TB_PROPERTY_ROOTDIR_MAGIC;\n\t\tre->length = dir_len - sizeof(*re) / 4;\n\t\tentry = re->entries;\n\t}\n\n\tlist_for_each_entry(property, &dir->properties, list) {\n\t\tconst struct tb_property_dir *child;\n\n\t\tformat_dwdata(entry, property->key, 2);\n\t\tentry->type = property->type;\n\n\t\tswitch (property->type) {\n\t\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\t\t\tchild = property->value.dir;\n\t\t\tret = __tb_property_format_dir(child, block, dir_end,\n\t\t\t\t\t\t       block_len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tentry->length = tb_property_dir_length(child, false,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tentry->value = dir_end;\n\t\t\tdir_end = ret;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_DATA:\n\t\t\tformat_dwdata(&block[data_offset], property->value.data,\n\t\t\t\t      property->length);\n\t\t\tentry->length = property->length;\n\t\t\tentry->value = data_offset;\n\t\t\tdata_offset += entry->length;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_TEXT:\n\t\t\tformat_dwdata(&block[data_offset], property->value.text,\n\t\t\t\t      property->length);\n\t\t\tentry->length = property->length;\n\t\t\tentry->value = data_offset;\n\t\t\tdata_offset += entry->length;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_VALUE:\n\t\t\tentry->length = property->length;\n\t\t\tentry->value = property->value.immediate;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tentry++;\n\t}\n\n\treturn dir_end;\n}\n\n \nssize_t tb_property_format_dir(const struct tb_property_dir *dir, u32 *block,\n\t\t\t       size_t block_len)\n{\n\tssize_t ret;\n\n\tif (!block) {\n\t\tsize_t dir_len, data_len = 0;\n\n\t\tdir_len = tb_property_dir_length(dir, true, &data_len);\n\t\treturn dir_len + data_len;\n\t}\n\n\tret = __tb_property_format_dir(dir, block, 0, block_len);\n\treturn ret < 0 ? ret : 0;\n}\n\n \nstruct tb_property_dir *tb_property_copy_dir(const struct tb_property_dir *dir)\n{\n\tstruct tb_property *property, *p = NULL;\n\tstruct tb_property_dir *d;\n\n\tif (!dir)\n\t\treturn NULL;\n\n\td = tb_property_create_dir(dir->uuid);\n\tif (!d)\n\t\treturn NULL;\n\n\tlist_for_each_entry(property, &dir->properties, list) {\n\t\tstruct tb_property *p;\n\n\t\tp = tb_property_alloc(property->key, property->type);\n\t\tif (!p)\n\t\t\tgoto err_free;\n\n\t\tp->length = property->length;\n\n\t\tswitch (property->type) {\n\t\tcase TB_PROPERTY_TYPE_DIRECTORY:\n\t\t\tp->value.dir = tb_property_copy_dir(property->value.dir);\n\t\t\tif (!p->value.dir)\n\t\t\t\tgoto err_free;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_DATA:\n\t\t\tp->value.data = kmemdup(property->value.data,\n\t\t\t\t\t\tproperty->length * 4,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!p->value.data)\n\t\t\t\tgoto err_free;\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_TEXT:\n\t\t\tp->value.text = kzalloc(p->length * 4, GFP_KERNEL);\n\t\t\tif (!p->value.text)\n\t\t\t\tgoto err_free;\n\t\t\tstrcpy(p->value.text, property->value.text);\n\t\t\tbreak;\n\n\t\tcase TB_PROPERTY_TYPE_VALUE:\n\t\t\tp->value.immediate = property->value.immediate;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&p->list, &d->properties);\n\t}\n\n\treturn d;\n\nerr_free:\n\tkfree(p);\n\ttb_property_free_dir(d);\n\n\treturn NULL;\n}\n\n \nint tb_property_add_immediate(struct tb_property_dir *parent, const char *key,\n\t\t\t      u32 value)\n{\n\tstruct tb_property *property;\n\n\tif (!tb_property_key_valid(key))\n\t\treturn -EINVAL;\n\n\tproperty = tb_property_alloc(key, TB_PROPERTY_TYPE_VALUE);\n\tif (!property)\n\t\treturn -ENOMEM;\n\n\tproperty->length = 1;\n\tproperty->value.immediate = value;\n\n\tlist_add_tail(&property->list, &parent->properties);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tb_property_add_immediate);\n\n \nint tb_property_add_data(struct tb_property_dir *parent, const char *key,\n\t\t\t const void *buf, size_t buflen)\n{\n\t \n\tsize_t size = round_up(buflen, 4);\n\tstruct tb_property *property;\n\n\tif (!tb_property_key_valid(key))\n\t\treturn -EINVAL;\n\n\tproperty = tb_property_alloc(key, TB_PROPERTY_TYPE_DATA);\n\tif (!property)\n\t\treturn -ENOMEM;\n\n\tproperty->length = size / 4;\n\tproperty->value.data = kzalloc(size, GFP_KERNEL);\n\tif (!property->value.data) {\n\t\tkfree(property);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(property->value.data, buf, buflen);\n\n\tlist_add_tail(&property->list, &parent->properties);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tb_property_add_data);\n\n \nint tb_property_add_text(struct tb_property_dir *parent, const char *key,\n\t\t\t const char *text)\n{\n\t \n\tsize_t size = round_up(strlen(text) + 1, 4);\n\tstruct tb_property *property;\n\n\tif (!tb_property_key_valid(key))\n\t\treturn -EINVAL;\n\n\tproperty = tb_property_alloc(key, TB_PROPERTY_TYPE_TEXT);\n\tif (!property)\n\t\treturn -ENOMEM;\n\n\tproperty->length = size / 4;\n\tproperty->value.text = kzalloc(size, GFP_KERNEL);\n\tif (!property->value.text) {\n\t\tkfree(property);\n\t\treturn -ENOMEM;\n\t}\n\n\tstrcpy(property->value.text, text);\n\n\tlist_add_tail(&property->list, &parent->properties);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tb_property_add_text);\n\n \nint tb_property_add_dir(struct tb_property_dir *parent, const char *key,\n\t\t\tstruct tb_property_dir *dir)\n{\n\tstruct tb_property *property;\n\n\tif (!tb_property_key_valid(key))\n\t\treturn -EINVAL;\n\n\tproperty = tb_property_alloc(key, TB_PROPERTY_TYPE_DIRECTORY);\n\tif (!property)\n\t\treturn -ENOMEM;\n\n\tproperty->value.dir = dir;\n\n\tlist_add_tail(&property->list, &parent->properties);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tb_property_add_dir);\n\n \nvoid tb_property_remove(struct tb_property *property)\n{\n\tlist_del(&property->list);\n\tkfree(property);\n}\nEXPORT_SYMBOL_GPL(tb_property_remove);\n\n \nstruct tb_property *tb_property_find(struct tb_property_dir *dir,\n\tconst char *key, enum tb_property_type type)\n{\n\tstruct tb_property *property;\n\n\tlist_for_each_entry(property, &dir->properties, list) {\n\t\tif (property->type == type && !strcmp(property->key, key))\n\t\t\treturn property;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tb_property_find);\n\n \nstruct tb_property *tb_property_get_next(struct tb_property_dir *dir,\n\t\t\t\t\t struct tb_property *prev)\n{\n\tif (prev) {\n\t\tif (list_is_last(&prev->list, &dir->properties))\n\t\t\treturn NULL;\n\t\treturn list_next_entry(prev, list);\n\t}\n\treturn list_first_entry_or_null(&dir->properties, struct tb_property,\n\t\t\t\t\tlist);\n}\nEXPORT_SYMBOL_GPL(tb_property_get_next);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}