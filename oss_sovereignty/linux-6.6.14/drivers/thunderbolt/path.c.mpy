{
  "module_name": "path.c",
  "hash_id": "b0824f7fcb06266738179cfe2b7fb9b9f8493e1e913eefc6c4a5bc598eb1397e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/path.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/ktime.h>\n\n#include \"tb.h\"\n\nstatic void tb_dump_hop(const struct tb_path_hop *hop, const struct tb_regs_hop *regs)\n{\n\tconst struct tb_port *port = hop->in_port;\n\n\ttb_port_dbg(port, \" In HopID: %d => Out port: %d Out HopID: %d\\n\",\n\t\t    hop->in_hop_index, regs->out_port, regs->next_hop);\n\ttb_port_dbg(port, \"  Weight: %d Priority: %d Credits: %d Drop: %d\\n\",\n\t\t    regs->weight, regs->priority,\n\t\t    regs->initial_credits, regs->drop_packages);\n\ttb_port_dbg(port, \"   Counter enabled: %d Counter index: %d\\n\",\n\t\t    regs->counter_enable, regs->counter);\n\ttb_port_dbg(port, \"  Flow Control (In/Eg): %d/%d Shared Buffer (In/Eg): %d/%d\\n\",\n\t\t    regs->ingress_fc, regs->egress_fc,\n\t\t    regs->ingress_shared_buffer, regs->egress_shared_buffer);\n\ttb_port_dbg(port, \"  Unknown1: %#x Unknown2: %#x Unknown3: %#x\\n\",\n\t\t    regs->unknown1, regs->unknown2, regs->unknown3);\n}\n\nstatic struct tb_port *tb_path_find_dst_port(struct tb_port *src, int src_hopid,\n\t\t\t\t\t     int dst_hopid)\n{\n\tstruct tb_port *port, *out_port = NULL;\n\tstruct tb_regs_hop hop;\n\tstruct tb_switch *sw;\n\tint i, ret, hopid;\n\n\thopid = src_hopid;\n\tport = src;\n\n\tfor (i = 0; port && i < TB_PATH_MAX_HOPS; i++) {\n\t\tsw = port->sw;\n\n\t\tret = tb_port_read(port, &hop, TB_CFG_HOPS, 2 * hopid, 2);\n\t\tif (ret) {\n\t\t\ttb_port_warn(port, \"failed to read path at %d\\n\", hopid);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!hop.enable)\n\t\t\treturn NULL;\n\n\t\tout_port = &sw->ports[hop.out_port];\n\t\thopid = hop.next_hop;\n\t\tport = out_port->remote;\n\t}\n\n\treturn out_port && hopid == dst_hopid ? out_port : NULL;\n}\n\nstatic int tb_path_find_src_hopid(struct tb_port *src,\n\tconst struct tb_port *dst, int dst_hopid)\n{\n\tstruct tb_port *out;\n\tint i;\n\n\tfor (i = TB_PATH_MIN_HOPID; i <= src->config.max_in_hop_id; i++) {\n\t\tout = tb_path_find_dst_port(src, i, dst_hopid);\n\t\tif (out == dst)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\n \nstruct tb_path *tb_path_discover(struct tb_port *src, int src_hopid,\n\t\t\t\t struct tb_port *dst, int dst_hopid,\n\t\t\t\t struct tb_port **last, const char *name,\n\t\t\t\t bool alloc_hopid)\n{\n\tstruct tb_port *out_port;\n\tstruct tb_regs_hop hop;\n\tstruct tb_path *path;\n\tstruct tb_switch *sw;\n\tstruct tb_port *p;\n\tsize_t num_hops;\n\tint ret, i, h;\n\n\tif (src_hopid < 0 && dst) {\n\t\t \n\t\tsrc_hopid = tb_path_find_src_hopid(src, dst, dst_hopid);\n\t\tif (!src_hopid)\n\t\t\treturn NULL;\n\t}\n\n\tp = src;\n\th = src_hopid;\n\tnum_hops = 0;\n\n\tfor (i = 0; p && i < TB_PATH_MAX_HOPS; i++) {\n\t\tsw = p->sw;\n\n\t\tret = tb_port_read(p, &hop, TB_CFG_HOPS, 2 * h, 2);\n\t\tif (ret) {\n\t\t\ttb_port_warn(p, \"failed to read path at %d\\n\", h);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (!hop.enable)\n\t\t\tbreak;\n\n\t\tout_port = &sw->ports[hop.out_port];\n\t\tif (last)\n\t\t\t*last = out_port;\n\n\t\th = hop.next_hop;\n\t\tp = out_port->remote;\n\t\tnum_hops++;\n\t}\n\n\tpath = kzalloc(sizeof(*path), GFP_KERNEL);\n\tif (!path)\n\t\treturn NULL;\n\n\tpath->name = name;\n\tpath->tb = src->sw->tb;\n\tpath->path_length = num_hops;\n\tpath->activated = true;\n\tpath->alloc_hopid = alloc_hopid;\n\n\tpath->hops = kcalloc(num_hops, sizeof(*path->hops), GFP_KERNEL);\n\tif (!path->hops) {\n\t\tkfree(path);\n\t\treturn NULL;\n\t}\n\n\ttb_dbg(path->tb, \"discovering %s path starting from %llx:%u\\n\",\n\t       path->name, tb_route(src->sw), src->port);\n\n\tp = src;\n\th = src_hopid;\n\n\tfor (i = 0; i < num_hops; i++) {\n\t\tint next_hop;\n\n\t\tsw = p->sw;\n\n\t\tret = tb_port_read(p, &hop, TB_CFG_HOPS, 2 * h, 2);\n\t\tif (ret) {\n\t\t\ttb_port_warn(p, \"failed to read path at %d\\n\", h);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (alloc_hopid && tb_port_alloc_in_hopid(p, h, h) < 0)\n\t\t\tgoto err;\n\n\t\tout_port = &sw->ports[hop.out_port];\n\t\tnext_hop = hop.next_hop;\n\n\t\tif (alloc_hopid &&\n\t\t    tb_port_alloc_out_hopid(out_port, next_hop, next_hop) < 0) {\n\t\t\ttb_port_release_in_hopid(p, h);\n\t\t\tgoto err;\n\t\t}\n\n\t\tpath->hops[i].in_port = p;\n\t\tpath->hops[i].in_hop_index = h;\n\t\tpath->hops[i].in_counter_index = -1;\n\t\tpath->hops[i].out_port = out_port;\n\t\tpath->hops[i].next_hop_index = next_hop;\n\n\t\ttb_dump_hop(&path->hops[i], &hop);\n\n\t\th = next_hop;\n\t\tp = out_port->remote;\n\t}\n\n\ttb_dbg(path->tb, \"path discovery complete\\n\");\n\treturn path;\n\nerr:\n\ttb_port_warn(src, \"failed to discover path starting at HopID %d\\n\",\n\t\t     src_hopid);\n\ttb_path_free(path);\n\treturn NULL;\n}\n\n \nstruct tb_path *tb_path_alloc(struct tb *tb, struct tb_port *src, int src_hopid,\n\t\t\t      struct tb_port *dst, int dst_hopid, int link_nr,\n\t\t\t      const char *name)\n{\n\tstruct tb_port *in_port, *out_port, *first_port, *last_port;\n\tint in_hopid, out_hopid;\n\tstruct tb_path *path;\n\tsize_t num_hops;\n\tint i, ret;\n\n\tpath = kzalloc(sizeof(*path), GFP_KERNEL);\n\tif (!path)\n\t\treturn NULL;\n\n\tfirst_port = last_port = NULL;\n\ti = 0;\n\ttb_for_each_port_on_path(src, dst, in_port) {\n\t\tif (!first_port)\n\t\t\tfirst_port = in_port;\n\t\tlast_port = in_port;\n\t\ti++;\n\t}\n\n\t \n\tif (first_port != src || last_port != dst) {\n\t\tkfree(path);\n\t\treturn NULL;\n\t}\n\n\t \n\tnum_hops = i / 2;\n\n\tpath->hops = kcalloc(num_hops, sizeof(*path->hops), GFP_KERNEL);\n\tif (!path->hops) {\n\t\tkfree(path);\n\t\treturn NULL;\n\t}\n\n\tpath->alloc_hopid = true;\n\n\tin_hopid = src_hopid;\n\tout_port = NULL;\n\n\tfor (i = 0; i < num_hops; i++) {\n\t\tin_port = tb_next_port_on_path(src, dst, out_port);\n\t\tif (!in_port)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (!in_port->bonded && in_port->dual_link_port &&\n\t\t    in_port->link_nr != link_nr)\n\t\t\tin_port = in_port->dual_link_port;\n\n\t\tret = tb_port_alloc_in_hopid(in_port, in_hopid, in_hopid);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tin_hopid = ret;\n\n\t\tout_port = tb_next_port_on_path(src, dst, in_port);\n\t\tif (!out_port)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (out_port->dual_link_port) {\n\t\t\tif (!in_port->bonded && out_port->bonded &&\n\t\t\t    out_port->link_nr) {\n\t\t\t\t \n\t\t\t\tout_port = out_port->dual_link_port;\n\t\t\t} else if (!out_port->bonded &&\n\t\t\t\t   out_port->link_nr != link_nr) {\n\t\t\t\t \n\t\t\t\tout_port = out_port->dual_link_port;\n\t\t\t}\n\t\t}\n\n\t\tif (i == num_hops - 1)\n\t\t\tret = tb_port_alloc_out_hopid(out_port, dst_hopid,\n\t\t\t\t\t\t      dst_hopid);\n\t\telse\n\t\t\tret = tb_port_alloc_out_hopid(out_port, -1, -1);\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tout_hopid = ret;\n\n\t\tpath->hops[i].in_hop_index = in_hopid;\n\t\tpath->hops[i].in_port = in_port;\n\t\tpath->hops[i].in_counter_index = -1;\n\t\tpath->hops[i].out_port = out_port;\n\t\tpath->hops[i].next_hop_index = out_hopid;\n\n\t\tin_hopid = out_hopid;\n\t}\n\n\tpath->tb = tb;\n\tpath->path_length = num_hops;\n\tpath->name = name;\n\n\treturn path;\n\nerr:\n\ttb_path_free(path);\n\treturn NULL;\n}\n\n \nvoid tb_path_free(struct tb_path *path)\n{\n\tif (path->alloc_hopid) {\n\t\tint i;\n\n\t\tfor (i = 0; i < path->path_length; i++) {\n\t\t\tconst struct tb_path_hop *hop = &path->hops[i];\n\n\t\t\tif (hop->in_port)\n\t\t\t\ttb_port_release_in_hopid(hop->in_port,\n\t\t\t\t\t\t\t hop->in_hop_index);\n\t\t\tif (hop->out_port)\n\t\t\t\ttb_port_release_out_hopid(hop->out_port,\n\t\t\t\t\t\t\t  hop->next_hop_index);\n\t\t}\n\t}\n\n\tkfree(path->hops);\n\tkfree(path);\n}\n\nstatic void __tb_path_deallocate_nfc(struct tb_path *path, int first_hop)\n{\n\tint i, res;\n\tfor (i = first_hop; i < path->path_length; i++) {\n\t\tres = tb_port_add_nfc_credits(path->hops[i].in_port,\n\t\t\t\t\t      -path->hops[i].nfc_credits);\n\t\tif (res)\n\t\t\ttb_port_warn(path->hops[i].in_port,\n\t\t\t\t     \"nfc credits deallocation failed for hop %d\\n\",\n\t\t\t\t     i);\n\t}\n}\n\nstatic int __tb_path_deactivate_hop(struct tb_port *port, int hop_index,\n\t\t\t\t    bool clear_fc)\n{\n\tstruct tb_regs_hop hop;\n\tktime_t timeout;\n\tint ret;\n\n\t \n\tret = tb_port_read(port, &hop, TB_CFG_HOPS, 2 * hop_index, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!hop.enable)\n\t\treturn 0;\n\n\thop.enable = 0;\n\n\tret = tb_port_write(port, &hop, TB_CFG_HOPS, 2 * hop_index, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 500);\n\tdo {\n\t\tret = tb_port_read(port, &hop, TB_CFG_HOPS, 2 * hop_index, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!hop.pending) {\n\t\t\tif (clear_fc) {\n\t\t\t\t \n\t\t\t\tif (!tb_switch_is_usb4(port->sw)) {\n\t\t\t\t\thop.ingress_fc = 0;\n\t\t\t\t\thop.ingress_shared_buffer = 0;\n\t\t\t\t}\n\t\t\t\thop.egress_fc = 0;\n\t\t\t\thop.egress_shared_buffer = 0;\n\n\t\t\t\treturn tb_port_write(port, &hop, TB_CFG_HOPS,\n\t\t\t\t\t\t     2 * hop_index, 2);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(10, 20);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void __tb_path_deactivate_hops(struct tb_path *path, int first_hop)\n{\n\tint i, res;\n\n\tfor (i = first_hop; i < path->path_length; i++) {\n\t\tres = __tb_path_deactivate_hop(path->hops[i].in_port,\n\t\t\t\t\t       path->hops[i].in_hop_index,\n\t\t\t\t\t       path->clear_fc);\n\t\tif (res && res != -ENODEV)\n\t\t\ttb_port_warn(path->hops[i].in_port,\n\t\t\t\t     \"hop deactivation failed for hop %d, index %d\\n\",\n\t\t\t\t     i, path->hops[i].in_hop_index);\n\t}\n}\n\nvoid tb_path_deactivate(struct tb_path *path)\n{\n\tif (!path->activated) {\n\t\ttb_WARN(path->tb, \"trying to deactivate an inactive path\\n\");\n\t\treturn;\n\t}\n\ttb_dbg(path->tb,\n\t       \"deactivating %s path from %llx:%u to %llx:%u\\n\",\n\t       path->name, tb_route(path->hops[0].in_port->sw),\n\t       path->hops[0].in_port->port,\n\t       tb_route(path->hops[path->path_length - 1].out_port->sw),\n\t       path->hops[path->path_length - 1].out_port->port);\n\t__tb_path_deactivate_hops(path, 0);\n\t__tb_path_deallocate_nfc(path, 0);\n\tpath->activated = false;\n}\n\n \nint tb_path_activate(struct tb_path *path)\n{\n\tint i, res;\n\tenum tb_path_port out_mask, in_mask;\n\tif (path->activated) {\n\t\ttb_WARN(path->tb, \"trying to activate already activated path\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttb_dbg(path->tb,\n\t       \"activating %s path from %llx:%u to %llx:%u\\n\",\n\t       path->name, tb_route(path->hops[0].in_port->sw),\n\t       path->hops[0].in_port->port,\n\t       tb_route(path->hops[path->path_length - 1].out_port->sw),\n\t       path->hops[path->path_length - 1].out_port->port);\n\n\t \n\tfor (i = path->path_length - 1; i >= 0; i--) {\n\t\tif (path->hops[i].in_counter_index == -1)\n\t\t\tcontinue;\n\t\tres = tb_port_clear_counter(path->hops[i].in_port,\n\t\t\t\t\t    path->hops[i].in_counter_index);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\t \n\tfor (i = path->path_length - 1; i >= 0; i--) {\n\t\tres = tb_port_add_nfc_credits(path->hops[i].in_port,\n\t\t\t\t\t      path->hops[i].nfc_credits);\n\t\tif (res) {\n\t\t\t__tb_path_deallocate_nfc(path, i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tfor (i = path->path_length - 1; i >= 0; i--) {\n\t\tstruct tb_regs_hop hop = { 0 };\n\n\t\t \n\t\t__tb_path_deactivate_hop(path->hops[i].in_port,\n\t\t\t\tpath->hops[i].in_hop_index, path->clear_fc);\n\n\t\t \n\t\thop.next_hop = path->hops[i].next_hop_index;\n\t\thop.out_port = path->hops[i].out_port->port;\n\t\thop.initial_credits = path->hops[i].initial_credits;\n\t\thop.unknown1 = 0;\n\t\thop.enable = 1;\n\n\t\t \n\t\tout_mask = (i == path->path_length - 1) ?\n\t\t\t\tTB_PATH_DESTINATION : TB_PATH_INTERNAL;\n\t\tin_mask = (i == 0) ? TB_PATH_SOURCE : TB_PATH_INTERNAL;\n\t\thop.weight = path->weight;\n\t\thop.unknown2 = 0;\n\t\thop.priority = path->priority;\n\t\thop.drop_packages = path->drop_packages;\n\t\thop.counter = path->hops[i].in_counter_index;\n\t\thop.counter_enable = path->hops[i].in_counter_index != -1;\n\t\thop.ingress_fc = path->ingress_fc_enable & in_mask;\n\t\thop.egress_fc = path->egress_fc_enable & out_mask;\n\t\thop.ingress_shared_buffer = path->ingress_shared_buffer\n\t\t\t\t\t    & in_mask;\n\t\thop.egress_shared_buffer = path->egress_shared_buffer\n\t\t\t\t\t    & out_mask;\n\t\thop.unknown3 = 0;\n\n\t\ttb_port_dbg(path->hops[i].in_port, \"Writing hop %d\\n\", i);\n\t\ttb_dump_hop(&path->hops[i], &hop);\n\t\tres = tb_port_write(path->hops[i].in_port, &hop, TB_CFG_HOPS,\n\t\t\t\t    2 * path->hops[i].in_hop_index, 2);\n\t\tif (res) {\n\t\t\t__tb_path_deactivate_hops(path, i);\n\t\t\t__tb_path_deallocate_nfc(path, 0);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tpath->activated = true;\n\ttb_dbg(path->tb, \"path activation complete\\n\");\n\treturn 0;\nerr:\n\ttb_WARN(path->tb, \"path activation failed\\n\");\n\treturn res;\n}\n\n \nbool tb_path_is_invalid(struct tb_path *path)\n{\n\tint i = 0;\n\tfor (i = 0; i < path->path_length; i++) {\n\t\tif (path->hops[i].in_port->sw->is_unplugged)\n\t\t\treturn true;\n\t\tif (path->hops[i].out_port->sw->is_unplugged)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nbool tb_path_port_on_path(const struct tb_path *path, const struct tb_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < path->path_length; i++) {\n\t\tif (path->hops[i].in_port == port ||\n\t\t    path->hops[i].out_port == port)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}