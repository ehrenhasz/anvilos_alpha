{
  "module_name": "usb4.c",
  "hash_id": "bfeea134b3c2cf503e7adef34ee1f1efaa500be2db76b3003587a29ea143c264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/usb4.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/units.h>\n\n#include \"sb_regs.h\"\n#include \"tb.h\"\n\n#define USB4_DATA_RETRIES\t\t3\n#define USB4_DATA_DWORDS\t\t16\n\nenum usb4_sb_target {\n\tUSB4_SB_TARGET_ROUTER,\n\tUSB4_SB_TARGET_PARTNER,\n\tUSB4_SB_TARGET_RETIMER,\n};\n\n#define USB4_NVM_READ_OFFSET_MASK\tGENMASK(23, 2)\n#define USB4_NVM_READ_OFFSET_SHIFT\t2\n#define USB4_NVM_READ_LENGTH_MASK\tGENMASK(27, 24)\n#define USB4_NVM_READ_LENGTH_SHIFT\t24\n\n#define USB4_NVM_SET_OFFSET_MASK\tUSB4_NVM_READ_OFFSET_MASK\n#define USB4_NVM_SET_OFFSET_SHIFT\tUSB4_NVM_READ_OFFSET_SHIFT\n\n#define USB4_DROM_ADDRESS_MASK\t\tGENMASK(14, 2)\n#define USB4_DROM_ADDRESS_SHIFT\t\t2\n#define USB4_DROM_SIZE_MASK\t\tGENMASK(19, 15)\n#define USB4_DROM_SIZE_SHIFT\t\t15\n\n#define USB4_NVM_SECTOR_SIZE_MASK\tGENMASK(23, 0)\n\n#define USB4_BA_LENGTH_MASK\t\tGENMASK(7, 0)\n#define USB4_BA_INDEX_MASK\t\tGENMASK(15, 0)\n\nenum usb4_ba_index {\n\tUSB4_BA_MAX_USB3 = 0x1,\n\tUSB4_BA_MIN_DP_AUX = 0x2,\n\tUSB4_BA_MIN_DP_MAIN = 0x3,\n\tUSB4_BA_MAX_PCIE = 0x4,\n\tUSB4_BA_MAX_HI = 0x5,\n};\n\n#define USB4_BA_VALUE_MASK\t\tGENMASK(31, 16)\n#define USB4_BA_VALUE_SHIFT\t\t16\n\nstatic int usb4_native_switch_op(struct tb_switch *sw, u16 opcode,\n\t\t\t\t u32 *metadata, u8 *status,\n\t\t\t\t const void *tx_data, size_t tx_dwords,\n\t\t\t\t void *rx_data, size_t rx_dwords)\n{\n\tu32 val;\n\tint ret;\n\n\tif (metadata) {\n\t\tret = tb_sw_write(sw, metadata, TB_CFG_SWITCH, ROUTER_CS_25, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (tx_dwords) {\n\t\tret = tb_sw_write(sw, tx_data, TB_CFG_SWITCH, ROUTER_CS_9,\n\t\t\t\t  tx_dwords);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tval = opcode | ROUTER_CS_26_OV;\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH, ROUTER_CS_26, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_switch_wait_for_bit(sw, ROUTER_CS_26, ROUTER_CS_26_OV, 0, 500);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_26, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & ROUTER_CS_26_ONS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (status)\n\t\t*status = (val & ROUTER_CS_26_STATUS_MASK) >>\n\t\t\tROUTER_CS_26_STATUS_SHIFT;\n\n\tif (metadata) {\n\t\tret = tb_sw_read(sw, metadata, TB_CFG_SWITCH, ROUTER_CS_25, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (rx_dwords) {\n\t\tret = tb_sw_read(sw, rx_data, TB_CFG_SWITCH, ROUTER_CS_9,\n\t\t\t\t rx_dwords);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __usb4_switch_op(struct tb_switch *sw, u16 opcode, u32 *metadata,\n\t\t\t    u8 *status, const void *tx_data, size_t tx_dwords,\n\t\t\t    void *rx_data, size_t rx_dwords)\n{\n\tconst struct tb_cm_ops *cm_ops = sw->tb->cm_ops;\n\n\tif (tx_dwords > USB4_DATA_DWORDS || rx_dwords > USB4_DATA_DWORDS)\n\t\treturn -EINVAL;\n\n\t \n\tif (cm_ops->usb4_switch_op) {\n\t\tint ret;\n\n\t\tret = cm_ops->usb4_switch_op(sw, opcode, metadata, status,\n\t\t\t\t\t     tx_data, tx_dwords, rx_data,\n\t\t\t\t\t     rx_dwords);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\n\t\t \n\t}\n\n\treturn usb4_native_switch_op(sw, opcode, metadata, status, tx_data,\n\t\t\t\t     tx_dwords, rx_data, rx_dwords);\n}\n\nstatic inline int usb4_switch_op(struct tb_switch *sw, u16 opcode,\n\t\t\t\t u32 *metadata, u8 *status)\n{\n\treturn __usb4_switch_op(sw, opcode, metadata, status, NULL, 0, NULL, 0);\n}\n\nstatic inline int usb4_switch_op_data(struct tb_switch *sw, u16 opcode,\n\t\t\t\t      u32 *metadata, u8 *status,\n\t\t\t\t      const void *tx_data, size_t tx_dwords,\n\t\t\t\t      void *rx_data, size_t rx_dwords)\n{\n\treturn __usb4_switch_op(sw, opcode, metadata, status, tx_data,\n\t\t\t\ttx_dwords, rx_data, rx_dwords);\n}\n\nstatic void usb4_switch_check_wakes(struct tb_switch *sw)\n{\n\tbool wakeup_usb4 = false;\n\tstruct usb4_port *usb4;\n\tstruct tb_port *port;\n\tbool wakeup = false;\n\tu32 val;\n\n\tif (!device_may_wakeup(&sw->dev))\n\t\treturn;\n\n\tif (tb_route(sw)) {\n\t\tif (tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_6, 1))\n\t\t\treturn;\n\n\t\ttb_sw_dbg(sw, \"PCIe wake: %s, USB3 wake: %s\\n\",\n\t\t\t  (val & ROUTER_CS_6_WOPS) ? \"yes\" : \"no\",\n\t\t\t  (val & ROUTER_CS_6_WOUS) ? \"yes\" : \"no\");\n\n\t\twakeup = val & (ROUTER_CS_6_WOPS | ROUTER_CS_6_WOUS);\n\t}\n\n\t \n\ttb_switch_for_each_port(sw, port) {\n\t\tif (!port->cap_usb4)\n\t\t\tcontinue;\n\n\t\tif (tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t\t port->cap_usb4 + PORT_CS_18, 1))\n\t\t\tbreak;\n\n\t\ttb_port_dbg(port, \"USB4 wake: %s, connection wake: %s, disconnection wake: %s\\n\",\n\t\t\t    (val & PORT_CS_18_WOU4S) ? \"yes\" : \"no\",\n\t\t\t    (val & PORT_CS_18_WOCS) ? \"yes\" : \"no\",\n\t\t\t    (val & PORT_CS_18_WODS) ? \"yes\" : \"no\");\n\n\t\twakeup_usb4 = val & (PORT_CS_18_WOU4S | PORT_CS_18_WOCS |\n\t\t\t\t     PORT_CS_18_WODS);\n\n\t\tusb4 = port->usb4;\n\t\tif (device_may_wakeup(&usb4->dev) && wakeup_usb4)\n\t\t\tpm_wakeup_event(&usb4->dev, 0);\n\n\t\twakeup |= wakeup_usb4;\n\t}\n\n\tif (wakeup)\n\t\tpm_wakeup_event(&sw->dev, 0);\n}\n\nstatic bool link_is_usb4(struct tb_port *port)\n{\n\tu32 val;\n\n\tif (!port->cap_usb4)\n\t\treturn false;\n\n\tif (tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t port->cap_usb4 + PORT_CS_18, 1))\n\t\treturn false;\n\n\treturn !(val & PORT_CS_18_TCM);\n}\n\n \nint usb4_switch_setup(struct tb_switch *sw)\n{\n\tstruct tb_switch *parent = tb_switch_parent(sw);\n\tstruct tb_port *down;\n\tbool tbt3, xhci;\n\tu32 val = 0;\n\tint ret;\n\n\tusb4_switch_check_wakes(sw);\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_6, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdown = tb_switch_downstream_port(sw);\n\tsw->link_usb4 = link_is_usb4(down);\n\ttb_sw_dbg(sw, \"link: %s\\n\", sw->link_usb4 ? \"USB4\" : \"TBT\");\n\n\txhci = val & ROUTER_CS_6_HCI;\n\ttbt3 = !(val & ROUTER_CS_6_TNS);\n\n\ttb_sw_dbg(sw, \"TBT3 support: %s, xHCI: %s\\n\",\n\t\t  tbt3 ? \"yes\" : \"no\", xhci ? \"yes\" : \"no\");\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb_acpi_may_tunnel_usb3() && sw->link_usb4 &&\n\t    tb_switch_find_port(parent, TB_TYPE_USB3_DOWN)) {\n\t\tval |= ROUTER_CS_5_UTO;\n\t\txhci = false;\n\t}\n\n\t \n\tif (tb_acpi_may_tunnel_pcie() &&\n\t    tb_switch_find_port(parent, TB_TYPE_PCIE_DOWN)) {\n\t\tval |= ROUTER_CS_5_PTO;\n\t\t \n\t\tif (xhci)\n\t\t\tval |= ROUTER_CS_5_HCO;\n\t}\n\n\t \n\tval |= ROUTER_CS_5_C3S;\n\n\treturn tb_sw_write(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n}\n\n \nint usb4_switch_configuration_valid(struct tb_switch *sw)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= ROUTER_CS_5_CV;\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_switch_wait_for_bit(sw, ROUTER_CS_6, ROUTER_CS_6_CR,\n\t\t\t\t      ROUTER_CS_6_CR, 50);\n}\n\n \nint usb4_switch_read_uid(struct tb_switch *sw, u64 *uid)\n{\n\treturn tb_sw_read(sw, uid, TB_CFG_SWITCH, ROUTER_CS_7, 2);\n}\n\nstatic int usb4_switch_drom_read_block(void *data,\n\t\t\t\t       unsigned int dwaddress, void *buf,\n\t\t\t\t       size_t dwords)\n{\n\tstruct tb_switch *sw = data;\n\tu8 status = 0;\n\tu32 metadata;\n\tint ret;\n\n\tmetadata = (dwords << USB4_DROM_SIZE_SHIFT) & USB4_DROM_SIZE_MASK;\n\tmetadata |= (dwaddress << USB4_DROM_ADDRESS_SHIFT) &\n\t\tUSB4_DROM_ADDRESS_MASK;\n\n\tret = usb4_switch_op_data(sw, USB4_SWITCH_OP_DROM_READ, &metadata,\n\t\t\t\t  &status, NULL, 0, buf, dwords);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EIO : 0;\n}\n\n \nint usb4_switch_drom_read(struct tb_switch *sw, unsigned int address, void *buf,\n\t\t\t  size_t size)\n{\n\treturn tb_nvm_read_data(address, buf, size, USB4_DATA_RETRIES,\n\t\t\t\tusb4_switch_drom_read_block, sw);\n}\n\n \nbool usb4_switch_lane_bonding_possible(struct tb_switch *sw)\n{\n\tstruct tb_port *up;\n\tint ret;\n\tu32 val;\n\n\tup = tb_upstream_port(sw);\n\tret = tb_port_read(up, &val, TB_CFG_PORT, up->cap_usb4 + PORT_CS_18, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & PORT_CS_18_BE);\n}\n\n \nint usb4_switch_set_wake(struct tb_switch *sw, unsigned int flags)\n{\n\tstruct usb4_port *usb4;\n\tstruct tb_port *port;\n\tu64 route = tb_route(sw);\n\tu32 val;\n\tint ret;\n\n\t \n\ttb_switch_for_each_port(sw, port) {\n\t\tif (!tb_port_is_null(port))\n\t\t\tcontinue;\n\t\tif (!route && tb_is_upstream_port(port))\n\t\t\tcontinue;\n\t\tif (!port->cap_usb4)\n\t\t\tcontinue;\n\n\t\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t\t   port->cap_usb4 + PORT_CS_19, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= ~(PORT_CS_19_WOC | PORT_CS_19_WOD | PORT_CS_19_WOU4);\n\n\t\tif (tb_is_upstream_port(port)) {\n\t\t\tval |= PORT_CS_19_WOU4;\n\t\t} else {\n\t\t\tbool configured = val & PORT_CS_19_PC;\n\t\t\tusb4 = port->usb4;\n\n\t\t\tif (((flags & TB_WAKE_ON_CONNECT) |\n\t\t\t      device_may_wakeup(&usb4->dev)) && !configured)\n\t\t\t\tval |= PORT_CS_19_WOC;\n\t\t\tif (((flags & TB_WAKE_ON_DISCONNECT) |\n\t\t\t      device_may_wakeup(&usb4->dev)) && configured)\n\t\t\t\tval |= PORT_CS_19_WOD;\n\t\t\tif ((flags & TB_WAKE_ON_USB4) && configured)\n\t\t\t\tval |= PORT_CS_19_WOU4;\n\t\t}\n\n\t\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t\t    port->cap_usb4 + PORT_CS_19, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (route) {\n\t\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= ~(ROUTER_CS_5_WOP | ROUTER_CS_5_WOU | ROUTER_CS_5_WOD);\n\t\tif (flags & TB_WAKE_ON_USB3)\n\t\t\tval |= ROUTER_CS_5_WOU;\n\t\tif (flags & TB_WAKE_ON_PCIE)\n\t\t\tval |= ROUTER_CS_5_WOP;\n\t\tif (flags & TB_WAKE_ON_DP)\n\t\t\tval |= ROUTER_CS_5_WOD;\n\n\t\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint usb4_switch_set_sleep(struct tb_switch *sw)\n{\n\tint ret;\n\tu32 val;\n\n\t \n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= ROUTER_CS_5_SLP;\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH, ROUTER_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_switch_wait_for_bit(sw, ROUTER_CS_6, ROUTER_CS_6_SLPR,\n\t\t\t\t      ROUTER_CS_6_SLPR, 500);\n}\n\n \nint usb4_switch_nvm_sector_size(struct tb_switch *sw)\n{\n\tu32 metadata;\n\tu8 status;\n\tint ret;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_NVM_SECTOR_SIZE, &metadata,\n\t\t\t     &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status)\n\t\treturn status == 0x2 ? -EOPNOTSUPP : -EIO;\n\n\treturn metadata & USB4_NVM_SECTOR_SIZE_MASK;\n}\n\nstatic int usb4_switch_nvm_read_block(void *data,\n\tunsigned int dwaddress, void *buf, size_t dwords)\n{\n\tstruct tb_switch *sw = data;\n\tu8 status = 0;\n\tu32 metadata;\n\tint ret;\n\n\tmetadata = (dwords << USB4_NVM_READ_LENGTH_SHIFT) &\n\t\t   USB4_NVM_READ_LENGTH_MASK;\n\tmetadata |= (dwaddress << USB4_NVM_READ_OFFSET_SHIFT) &\n\t\t   USB4_NVM_READ_OFFSET_MASK;\n\n\tret = usb4_switch_op_data(sw, USB4_SWITCH_OP_NVM_READ, &metadata,\n\t\t\t\t  &status, NULL, 0, buf, dwords);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EIO : 0;\n}\n\n \nint usb4_switch_nvm_read(struct tb_switch *sw, unsigned int address, void *buf,\n\t\t\t size_t size)\n{\n\treturn tb_nvm_read_data(address, buf, size, USB4_DATA_RETRIES,\n\t\t\t\tusb4_switch_nvm_read_block, sw);\n}\n\n \nint usb4_switch_nvm_set_offset(struct tb_switch *sw, unsigned int address)\n{\n\tu32 metadata, dwaddress;\n\tu8 status = 0;\n\tint ret;\n\n\tdwaddress = address / 4;\n\tmetadata = (dwaddress << USB4_NVM_SET_OFFSET_SHIFT) &\n\t\t   USB4_NVM_SET_OFFSET_MASK;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_NVM_SET_OFFSET, &metadata,\n\t\t\t     &status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EIO : 0;\n}\n\nstatic int usb4_switch_nvm_write_next_block(void *data, unsigned int dwaddress,\n\t\t\t\t\t    const void *buf, size_t dwords)\n{\n\tstruct tb_switch *sw = data;\n\tu8 status;\n\tint ret;\n\n\tret = usb4_switch_op_data(sw, USB4_SWITCH_OP_NVM_WRITE, NULL, &status,\n\t\t\t\t  buf, dwords, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EIO : 0;\n}\n\n \nint usb4_switch_nvm_write(struct tb_switch *sw, unsigned int address,\n\t\t\t  const void *buf, size_t size)\n{\n\tint ret;\n\n\tret = usb4_switch_nvm_set_offset(sw, address);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_nvm_write_data(address, buf, size, USB4_DATA_RETRIES,\n\t\t\t\t usb4_switch_nvm_write_next_block, sw);\n}\n\n \nint usb4_switch_nvm_authenticate(struct tb_switch *sw)\n{\n\tint ret;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_NVM_AUTH, NULL, NULL);\n\tswitch (ret) {\n\t \n\tcase -EACCES:\n\tcase -ENOTCONN:\n\tcase -ETIMEDOUT:\n\t\treturn 0;\n\n\tdefault:\n\t\treturn ret;\n\t}\n}\n\n \nint usb4_switch_nvm_authenticate_status(struct tb_switch *sw, u32 *status)\n{\n\tconst struct tb_cm_ops *cm_ops = sw->tb->cm_ops;\n\tu16 opcode;\n\tu32 val;\n\tint ret;\n\n\tif (cm_ops->usb4_switch_nvm_authenticate_status) {\n\t\tret = cm_ops->usb4_switch_nvm_authenticate_status(sw, status);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, ROUTER_CS_26, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\topcode = val & ROUTER_CS_26_OPCODE_MASK;\n\tif (opcode == USB4_SWITCH_OP_NVM_AUTH) {\n\t\tif (val & ROUTER_CS_26_OV)\n\t\t\treturn -EBUSY;\n\t\tif (val & ROUTER_CS_26_ONS)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*status = (val & ROUTER_CS_26_STATUS_MASK) >>\n\t\t\tROUTER_CS_26_STATUS_SHIFT;\n\t} else {\n\t\t*status = 0;\n\t}\n\n\treturn 0;\n}\n\n \nint usb4_switch_credits_init(struct tb_switch *sw)\n{\n\tint max_usb3, min_dp_aux, min_dp_main, max_pcie, max_dma;\n\tint ret, length, i, nports;\n\tconst struct tb_port *port;\n\tu32 data[USB4_DATA_DWORDS];\n\tu32 metadata = 0;\n\tu8 status = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tret = usb4_switch_op_data(sw, USB4_SWITCH_OP_BUFFER_ALLOC, &metadata,\n\t\t\t\t  &status, NULL, 0, data, ARRAY_SIZE(data));\n\tif (ret)\n\t\treturn ret;\n\tif (status)\n\t\treturn -EIO;\n\n\tlength = metadata & USB4_BA_LENGTH_MASK;\n\tif (WARN_ON(length > ARRAY_SIZE(data)))\n\t\treturn -EMSGSIZE;\n\n\tmax_usb3 = -1;\n\tmin_dp_aux = -1;\n\tmin_dp_main = -1;\n\tmax_pcie = -1;\n\tmax_dma = -1;\n\n\ttb_sw_dbg(sw, \"credit allocation parameters:\\n\");\n\n\tfor (i = 0; i < length; i++) {\n\t\tu16 index, value;\n\n\t\tindex = data[i] & USB4_BA_INDEX_MASK;\n\t\tvalue = (data[i] & USB4_BA_VALUE_MASK) >> USB4_BA_VALUE_SHIFT;\n\n\t\tswitch (index) {\n\t\tcase USB4_BA_MAX_USB3:\n\t\t\ttb_sw_dbg(sw, \" USB3: %u\\n\", value);\n\t\t\tmax_usb3 = value;\n\t\t\tbreak;\n\t\tcase USB4_BA_MIN_DP_AUX:\n\t\t\ttb_sw_dbg(sw, \" DP AUX: %u\\n\", value);\n\t\t\tmin_dp_aux = value;\n\t\t\tbreak;\n\t\tcase USB4_BA_MIN_DP_MAIN:\n\t\t\ttb_sw_dbg(sw, \" DP main: %u\\n\", value);\n\t\t\tmin_dp_main = value;\n\t\t\tbreak;\n\t\tcase USB4_BA_MAX_PCIE:\n\t\t\ttb_sw_dbg(sw, \" PCIe: %u\\n\", value);\n\t\t\tmax_pcie = value;\n\t\t\tbreak;\n\t\tcase USB4_BA_MAX_HI:\n\t\t\ttb_sw_dbg(sw, \" DMA: %u\\n\", value);\n\t\t\tmax_dma = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttb_sw_dbg(sw, \" unknown credit allocation index %#x, skipping\\n\",\n\t\t\t\t  index);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (!tb_route(sw) && max_dma < 0) {\n\t\ttb_sw_warn(sw, \"host router is missing baMaxHI\\n\");\n\t\tgoto err_invalid;\n\t}\n\n\tnports = 0;\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (tb_port_is_null(port))\n\t\t\tnports++;\n\t}\n\n\t \n\tif (nports > 2 && (min_dp_aux < 0 || min_dp_main < 0)) {\n\t\ttb_sw_warn(sw, \"multiple USB4 ports require baMinDPaux/baMinDPmain\\n\");\n\t\tgoto err_invalid;\n\t}\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (tb_port_is_dpout(port) && min_dp_main < 0) {\n\t\t\ttb_sw_warn(sw, \"missing baMinDPmain\");\n\t\t\tgoto err_invalid;\n\t\t}\n\t\tif ((tb_port_is_dpin(port) || tb_port_is_dpout(port)) &&\n\t\t    min_dp_aux < 0) {\n\t\t\ttb_sw_warn(sw, \"missing baMinDPaux\");\n\t\t\tgoto err_invalid;\n\t\t}\n\t\tif ((tb_port_is_usb3_down(port) || tb_port_is_usb3_up(port)) &&\n\t\t    max_usb3 < 0) {\n\t\t\ttb_sw_warn(sw, \"missing baMaxUSB3\");\n\t\t\tgoto err_invalid;\n\t\t}\n\t\tif ((tb_port_is_pcie_down(port) || tb_port_is_pcie_up(port)) &&\n\t\t    max_pcie < 0) {\n\t\t\ttb_sw_warn(sw, \"missing baMaxPCIe\");\n\t\t\tgoto err_invalid;\n\t\t}\n\t}\n\n\t \n\tsw->credit_allocation = true;\n\tif (max_usb3 > 0)\n\t\tsw->max_usb3_credits = max_usb3;\n\tif (min_dp_aux > 0)\n\t\tsw->min_dp_aux_credits = min_dp_aux;\n\tif (min_dp_main > 0)\n\t\tsw->min_dp_main_credits = min_dp_main;\n\tif (max_pcie > 0)\n\t\tsw->max_pcie_credits = max_pcie;\n\tif (max_dma > 0)\n\t\tsw->max_dma_credits = max_dma;\n\n\treturn 0;\n\nerr_invalid:\n\treturn -EINVAL;\n}\n\n \nbool usb4_switch_query_dp_resource(struct tb_switch *sw, struct tb_port *in)\n{\n\tu32 metadata = in->port;\n\tu8 status;\n\tint ret;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_QUERY_DP_RESOURCE, &metadata,\n\t\t\t     &status);\n\t \n\tif (ret == -EOPNOTSUPP)\n\t\treturn true;\n\tif (ret)\n\t\treturn false;\n\n\treturn !status;\n}\n\n \nint usb4_switch_alloc_dp_resource(struct tb_switch *sw, struct tb_port *in)\n{\n\tu32 metadata = in->port;\n\tu8 status;\n\tint ret;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_ALLOC_DP_RESOURCE, &metadata,\n\t\t\t     &status);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EBUSY : 0;\n}\n\n \nint usb4_switch_dealloc_dp_resource(struct tb_switch *sw, struct tb_port *in)\n{\n\tu32 metadata = in->port;\n\tu8 status;\n\tint ret;\n\n\tret = usb4_switch_op(sw, USB4_SWITCH_OP_DEALLOC_DP_RESOURCE, &metadata,\n\t\t\t     &status);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\treturn status ? -EIO : 0;\n}\n\nstatic int usb4_port_idx(const struct tb_switch *sw, const struct tb_port *port)\n{\n\tstruct tb_port *p;\n\tint usb4_idx = 0;\n\n\t \n\ttb_switch_for_each_port(sw, p) {\n\t\tif (!tb_port_is_null(p))\n\t\t\tcontinue;\n\t\tif (tb_is_upstream_port(p))\n\t\t\tcontinue;\n\t\tif (!p->link_nr) {\n\t\t\tif (p == port)\n\t\t\t\tbreak;\n\t\t\tusb4_idx++;\n\t\t}\n\t}\n\n\treturn usb4_idx;\n}\n\n \nstruct tb_port *usb4_switch_map_pcie_down(struct tb_switch *sw,\n\t\t\t\t\t  const struct tb_port *port)\n{\n\tint usb4_idx = usb4_port_idx(sw, port);\n\tstruct tb_port *p;\n\tint pcie_idx = 0;\n\n\t \n\ttb_switch_for_each_port(sw, p) {\n\t\tif (!tb_port_is_pcie_down(p))\n\t\t\tcontinue;\n\n\t\tif (pcie_idx == usb4_idx)\n\t\t\treturn p;\n\n\t\tpcie_idx++;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct tb_port *usb4_switch_map_usb3_down(struct tb_switch *sw,\n\t\t\t\t\t  const struct tb_port *port)\n{\n\tint usb4_idx = usb4_port_idx(sw, port);\n\tstruct tb_port *p;\n\tint usb_idx = 0;\n\n\t \n\ttb_switch_for_each_port(sw, p) {\n\t\tif (!tb_port_is_usb3_down(p))\n\t\t\tcontinue;\n\n\t\tif (usb_idx == usb4_idx)\n\t\t\treturn p;\n\n\t\tusb_idx++;\n\t}\n\n\treturn NULL;\n}\n\n \nint usb4_switch_add_ports(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\n\tif (tb_switch_is_icm(sw) || !tb_switch_is_usb4(sw))\n\t\treturn 0;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tstruct usb4_port *usb4;\n\n\t\tif (!tb_port_is_null(port))\n\t\t\tcontinue;\n\t\tif (!port->cap_usb4)\n\t\t\tcontinue;\n\n\t\tusb4 = usb4_port_device_add(port);\n\t\tif (IS_ERR(usb4)) {\n\t\t\tusb4_switch_remove_ports(sw);\n\t\t\treturn PTR_ERR(usb4);\n\t\t}\n\n\t\tport->usb4 = usb4;\n\t}\n\n\treturn 0;\n}\n\n \nvoid usb4_switch_remove_ports(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tif (port->usb4) {\n\t\t\tusb4_port_device_remove(port->usb4);\n\t\t\tport->usb4 = NULL;\n\t\t}\n\t}\n}\n\n \nint usb4_port_unlock(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT, ADP_CS_4, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_CS_4_LCK;\n\treturn tb_port_write(port, &val, TB_CFG_PORT, ADP_CS_4, 1);\n}\n\n \nint usb4_port_hotplug_enable(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT, ADP_CS_5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_CS_5_DHP;\n\treturn tb_port_write(port, &val, TB_CFG_PORT, ADP_CS_5, 1);\n}\n\nstatic int usb4_port_set_configured(struct tb_port *port, bool configured)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!port->cap_usb4)\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_usb4 + PORT_CS_19, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (configured)\n\t\tval |= PORT_CS_19_PC;\n\telse\n\t\tval &= ~PORT_CS_19_PC;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_usb4 + PORT_CS_19, 1);\n}\n\n \nint usb4_port_configure(struct tb_port *port)\n{\n\treturn usb4_port_set_configured(port, true);\n}\n\n \nvoid usb4_port_unconfigure(struct tb_port *port)\n{\n\tusb4_port_set_configured(port, false);\n}\n\nstatic int usb4_set_xdomain_configured(struct tb_port *port, bool configured)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!port->cap_usb4)\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_usb4 + PORT_CS_19, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (configured)\n\t\tval |= PORT_CS_19_PID;\n\telse\n\t\tval &= ~PORT_CS_19_PID;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_usb4 + PORT_CS_19, 1);\n}\n\n \nint usb4_port_configure_xdomain(struct tb_port *port, struct tb_xdomain *xd)\n{\n\txd->link_usb4 = link_is_usb4(port);\n\treturn usb4_set_xdomain_configured(port, true);\n}\n\n \nvoid usb4_port_unconfigure_xdomain(struct tb_port *port)\n{\n\tusb4_set_xdomain_configured(port, false);\n}\n\nstatic int usb4_port_wait_for_bit(struct tb_port *port, u32 offset, u32 bit,\n\t\t\t\t  u32 value, int timeout_msec)\n{\n\tktime_t timeout = ktime_add_ms(ktime_get(), timeout_msec);\n\n\tdo {\n\t\tu32 val;\n\t\tint ret;\n\n\t\tret = tb_port_read(port, &val, TB_CFG_PORT, offset, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((val & bit) == value)\n\t\t\treturn 0;\n\n\t\tusleep_range(50, 100);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int usb4_port_read_data(struct tb_port *port, void *data, size_t dwords)\n{\n\tif (dwords > USB4_DATA_DWORDS)\n\t\treturn -EINVAL;\n\n\treturn tb_port_read(port, data, TB_CFG_PORT, port->cap_usb4 + PORT_CS_2,\n\t\t\t    dwords);\n}\n\nstatic int usb4_port_write_data(struct tb_port *port, const void *data,\n\t\t\t\tsize_t dwords)\n{\n\tif (dwords > USB4_DATA_DWORDS)\n\t\treturn -EINVAL;\n\n\treturn tb_port_write(port, data, TB_CFG_PORT, port->cap_usb4 + PORT_CS_2,\n\t\t\t     dwords);\n}\n\nstatic int usb4_port_sb_read(struct tb_port *port, enum usb4_sb_target target,\n\t\t\t     u8 index, u8 reg, void *buf, u8 size)\n{\n\tsize_t dwords = DIV_ROUND_UP(size, 4);\n\tint ret;\n\tu32 val;\n\n\tif (!port->cap_usb4)\n\t\treturn -EINVAL;\n\n\tval = reg;\n\tval |= size << PORT_CS_1_LENGTH_SHIFT;\n\tval |= (target << PORT_CS_1_TARGET_SHIFT) & PORT_CS_1_TARGET_MASK;\n\tif (target == USB4_SB_TARGET_RETIMER)\n\t\tval |= (index << PORT_CS_1_RETIMER_INDEX_SHIFT);\n\tval |= PORT_CS_1_PND;\n\n\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_usb4 + PORT_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_wait_for_bit(port, port->cap_usb4 + PORT_CS_1,\n\t\t\t\t     PORT_CS_1_PND, 0, 500);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_usb4 + PORT_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & PORT_CS_1_NR)\n\t\treturn -ENODEV;\n\tif (val & PORT_CS_1_RC)\n\t\treturn -EIO;\n\n\treturn buf ? usb4_port_read_data(port, buf, dwords) : 0;\n}\n\nstatic int usb4_port_sb_write(struct tb_port *port, enum usb4_sb_target target,\n\t\t\t      u8 index, u8 reg, const void *buf, u8 size)\n{\n\tsize_t dwords = DIV_ROUND_UP(size, 4);\n\tint ret;\n\tu32 val;\n\n\tif (!port->cap_usb4)\n\t\treturn -EINVAL;\n\n\tif (buf) {\n\t\tret = usb4_port_write_data(port, buf, dwords);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tval = reg;\n\tval |= size << PORT_CS_1_LENGTH_SHIFT;\n\tval |= PORT_CS_1_WNR_WRITE;\n\tval |= (target << PORT_CS_1_TARGET_SHIFT) & PORT_CS_1_TARGET_MASK;\n\tif (target == USB4_SB_TARGET_RETIMER)\n\t\tval |= (index << PORT_CS_1_RETIMER_INDEX_SHIFT);\n\tval |= PORT_CS_1_PND;\n\n\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_usb4 + PORT_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_wait_for_bit(port, port->cap_usb4 + PORT_CS_1,\n\t\t\t\t     PORT_CS_1_PND, 0, 500);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_usb4 + PORT_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & PORT_CS_1_NR)\n\t\treturn -ENODEV;\n\tif (val & PORT_CS_1_RC)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int usb4_port_sb_opcode_err_to_errno(u32 val)\n{\n\tswitch (val) {\n\tcase 0:\n\t\treturn 0;\n\tcase USB4_SB_OPCODE_ERR:\n\t\treturn -EAGAIN;\n\tcase USB4_SB_OPCODE_ONS:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int usb4_port_sb_op(struct tb_port *port, enum usb4_sb_target target,\n\t\t\t   u8 index, enum usb4_sb_opcode opcode, int timeout_msec)\n{\n\tktime_t timeout;\n\tu32 val;\n\tint ret;\n\n\tval = opcode;\n\tret = usb4_port_sb_write(port, target, index, USB4_SB_OPCODE, &val,\n\t\t\t\t sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = ktime_add_ms(ktime_get(), timeout_msec);\n\n\tdo {\n\t\t \n\t\tret = usb4_port_sb_read(port, target, index, USB4_SB_OPCODE,\n\t\t\t\t\t&val, sizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val != opcode)\n\t\t\treturn usb4_port_sb_opcode_err_to_errno(val);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int usb4_port_set_router_offline(struct tb_port *port, bool offline)\n{\n\tu32 val = !offline;\n\tint ret;\n\n\tret = usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t  USB4_SB_METADATA, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tval = USB4_SB_OPCODE_ROUTER_OFFLINE;\n\treturn usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t  USB4_SB_OPCODE, &val, sizeof(val));\n}\n\n \nint usb4_port_router_offline(struct tb_port *port)\n{\n\treturn usb4_port_set_router_offline(port, true);\n}\n\n \nint usb4_port_router_online(struct tb_port *port)\n{\n\treturn usb4_port_set_router_offline(port, false);\n}\n\n \nint usb4_port_enumerate_retimers(struct tb_port *port)\n{\n\tu32 val;\n\n\tval = USB4_SB_OPCODE_ENUMERATE_RETIMERS;\n\treturn usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t  USB4_SB_OPCODE, &val, sizeof(val));\n}\n\n \nbool usb4_port_clx_supported(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_usb4 + PORT_CS_18, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & PORT_CS_18_CPS);\n}\n\n \nint usb4_port_margining_caps(struct tb_port *port, u32 *caps)\n{\n\tint ret;\n\n\tret = usb4_port_sb_op(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t      USB4_SB_OPCODE_READ_LANE_MARGINING_CAP, 500);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_sb_read(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t USB4_SB_DATA, caps, sizeof(*caps) * 2);\n}\n\n \nint usb4_port_hw_margin(struct tb_port *port, unsigned int lanes,\n\t\t\tunsigned int ber_level, bool timing, bool right_high,\n\t\t\tu32 *results)\n{\n\tu32 val;\n\tint ret;\n\n\tval = lanes;\n\tif (timing)\n\t\tval |= USB4_MARGIN_HW_TIME;\n\tif (right_high)\n\t\tval |= USB4_MARGIN_HW_RH;\n\tif (ber_level)\n\t\tval |= (ber_level << USB4_MARGIN_HW_BER_SHIFT) &\n\t\t\tUSB4_MARGIN_HW_BER_MASK;\n\n\tret = usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t USB4_SB_METADATA, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_sb_op(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t      USB4_SB_OPCODE_RUN_HW_LANE_MARGINING, 2500);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_sb_read(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t USB4_SB_DATA, results, sizeof(*results) * 2);\n}\n\n \nint usb4_port_sw_margin(struct tb_port *port, unsigned int lanes, bool timing,\n\t\t\tbool right_high, u32 counter)\n{\n\tu32 val;\n\tint ret;\n\n\tval = lanes;\n\tif (timing)\n\t\tval |= USB4_MARGIN_SW_TIME;\n\tif (right_high)\n\t\tval |= USB4_MARGIN_SW_RH;\n\tval |= (counter << USB4_MARGIN_SW_COUNTER_SHIFT) &\n\t\tUSB4_MARGIN_SW_COUNTER_MASK;\n\n\tret = usb4_port_sb_write(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t USB4_SB_METADATA, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_sb_op(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t       USB4_SB_OPCODE_RUN_SW_LANE_MARGINING, 2500);\n}\n\n \nint usb4_port_sw_margin_errors(struct tb_port *port, u32 *errors)\n{\n\tint ret;\n\n\tret = usb4_port_sb_op(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t      USB4_SB_OPCODE_READ_SW_MARGIN_ERR, 150);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_sb_read(port, USB4_SB_TARGET_ROUTER, 0,\n\t\t\t\t USB4_SB_METADATA, errors, sizeof(*errors));\n}\n\nstatic inline int usb4_port_retimer_op(struct tb_port *port, u8 index,\n\t\t\t\t       enum usb4_sb_opcode opcode,\n\t\t\t\t       int timeout_msec)\n{\n\treturn usb4_port_sb_op(port, USB4_SB_TARGET_RETIMER, index, opcode,\n\t\t\t       timeout_msec);\n}\n\n \nint usb4_port_retimer_set_inbound_sbtx(struct tb_port *port, u8 index)\n{\n\tint ret;\n\n\tret = usb4_port_retimer_op(port, index, USB4_SB_OPCODE_SET_INBOUND_SBTX,\n\t\t\t\t   500);\n\n\tif (ret != -ENODEV)\n\t\treturn ret;\n\n\t \n\treturn usb4_port_retimer_op(port, index, USB4_SB_OPCODE_SET_INBOUND_SBTX,\n\t\t\t\t    500);\n}\n\n \nint usb4_port_retimer_unset_inbound_sbtx(struct tb_port *port, u8 index)\n{\n\treturn usb4_port_retimer_op(port, index,\n\t\t\t\t    USB4_SB_OPCODE_UNSET_INBOUND_SBTX, 500);\n}\n\n \nint usb4_port_retimer_read(struct tb_port *port, u8 index, u8 reg, void *buf,\n\t\t\t   u8 size)\n{\n\treturn usb4_port_sb_read(port, USB4_SB_TARGET_RETIMER, index, reg, buf,\n\t\t\t\t size);\n}\n\n \nint usb4_port_retimer_write(struct tb_port *port, u8 index, u8 reg,\n\t\t\t    const void *buf, u8 size)\n{\n\treturn usb4_port_sb_write(port, USB4_SB_TARGET_RETIMER, index, reg, buf,\n\t\t\t\t  size);\n}\n\n \nint usb4_port_retimer_is_last(struct tb_port *port, u8 index)\n{\n\tu32 metadata;\n\tint ret;\n\n\tret = usb4_port_retimer_op(port, index, USB4_SB_OPCODE_QUERY_LAST_RETIMER,\n\t\t\t\t   500);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_retimer_read(port, index, USB4_SB_METADATA, &metadata,\n\t\t\t\t     sizeof(metadata));\n\treturn ret ? ret : metadata & 1;\n}\n\n \nint usb4_port_retimer_nvm_sector_size(struct tb_port *port, u8 index)\n{\n\tu32 metadata;\n\tint ret;\n\n\tret = usb4_port_retimer_op(port, index, USB4_SB_OPCODE_GET_NVM_SECTOR_SIZE,\n\t\t\t\t   500);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_retimer_read(port, index, USB4_SB_METADATA, &metadata,\n\t\t\t\t     sizeof(metadata));\n\treturn ret ? ret : metadata & USB4_NVM_SECTOR_SIZE_MASK;\n}\n\n \nint usb4_port_retimer_nvm_set_offset(struct tb_port *port, u8 index,\n\t\t\t\t     unsigned int address)\n{\n\tu32 metadata, dwaddress;\n\tint ret;\n\n\tdwaddress = address / 4;\n\tmetadata = (dwaddress << USB4_NVM_SET_OFFSET_SHIFT) &\n\t\t  USB4_NVM_SET_OFFSET_MASK;\n\n\tret = usb4_port_retimer_write(port, index, USB4_SB_METADATA, &metadata,\n\t\t\t\t      sizeof(metadata));\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_retimer_op(port, index, USB4_SB_OPCODE_NVM_SET_OFFSET,\n\t\t\t\t    500);\n}\n\nstruct retimer_info {\n\tstruct tb_port *port;\n\tu8 index;\n};\n\nstatic int usb4_port_retimer_nvm_write_next_block(void *data,\n\tunsigned int dwaddress, const void *buf, size_t dwords)\n\n{\n\tconst struct retimer_info *info = data;\n\tstruct tb_port *port = info->port;\n\tu8 index = info->index;\n\tint ret;\n\n\tret = usb4_port_retimer_write(port, index, USB4_SB_DATA,\n\t\t\t\t      buf, dwords * 4);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_retimer_op(port, index,\n\t\t\tUSB4_SB_OPCODE_NVM_BLOCK_WRITE, 1000);\n}\n\n \nint usb4_port_retimer_nvm_write(struct tb_port *port, u8 index, unsigned int address,\n\t\t\t\tconst void *buf, size_t size)\n{\n\tstruct retimer_info info = { .port = port, .index = index };\n\tint ret;\n\n\tret = usb4_port_retimer_nvm_set_offset(port, index, address);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_nvm_write_data(address, buf, size, USB4_DATA_RETRIES,\n\t\t\t\t usb4_port_retimer_nvm_write_next_block, &info);\n}\n\n \nint usb4_port_retimer_nvm_authenticate(struct tb_port *port, u8 index)\n{\n\tu32 val;\n\n\t \n\tval = USB4_SB_OPCODE_NVM_AUTH_WRITE;\n\treturn usb4_port_sb_write(port, USB4_SB_TARGET_RETIMER, index,\n\t\t\t\t  USB4_SB_OPCODE, &val, sizeof(val));\n}\n\n \nint usb4_port_retimer_nvm_authenticate_status(struct tb_port *port, u8 index,\n\t\t\t\t\t      u32 *status)\n{\n\tu32 metadata, val;\n\tint ret;\n\n\tret = usb4_port_retimer_read(port, index, USB4_SB_OPCODE, &val,\n\t\t\t\t     sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_sb_opcode_err_to_errno(val);\n\tswitch (ret) {\n\tcase 0:\n\t\t*status = 0;\n\t\treturn 0;\n\n\tcase -EAGAIN:\n\t\tret = usb4_port_retimer_read(port, index, USB4_SB_METADATA,\n\t\t\t\t\t     &metadata, sizeof(metadata));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*status = metadata & USB4_SB_METADATA_NVM_AUTH_WRITE_MASK;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn ret;\n\t}\n}\n\nstatic int usb4_port_retimer_nvm_read_block(void *data, unsigned int dwaddress,\n\t\t\t\t\t    void *buf, size_t dwords)\n{\n\tconst struct retimer_info *info = data;\n\tstruct tb_port *port = info->port;\n\tu8 index = info->index;\n\tu32 metadata;\n\tint ret;\n\n\tmetadata = dwaddress << USB4_NVM_READ_OFFSET_SHIFT;\n\tif (dwords < USB4_DATA_DWORDS)\n\t\tmetadata |= dwords << USB4_NVM_READ_LENGTH_SHIFT;\n\n\tret = usb4_port_retimer_write(port, index, USB4_SB_METADATA, &metadata,\n\t\t\t\t      sizeof(metadata));\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_retimer_op(port, index, USB4_SB_OPCODE_NVM_READ, 500);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_port_retimer_read(port, index, USB4_SB_DATA, buf,\n\t\t\t\t      dwords * 4);\n}\n\n \nint usb4_port_retimer_nvm_read(struct tb_port *port, u8 index,\n\t\t\t       unsigned int address, void *buf, size_t size)\n{\n\tstruct retimer_info info = { .port = port, .index = index };\n\n\treturn tb_nvm_read_data(address, buf, size, USB4_DATA_RETRIES,\n\t\t\t\tusb4_port_retimer_nvm_read_block, &info);\n}\n\nstatic inline unsigned int\nusb4_usb3_port_max_bandwidth(const struct tb_port *port, unsigned int bw)\n{\n\t \n\tif (port->max_bw)\n\t\treturn min(bw, port->max_bw);\n\treturn bw;\n}\n\n \nint usb4_usb3_port_max_link_rate(struct tb_port *port)\n{\n\tint ret, lr;\n\tu32 val;\n\n\tif (!tb_port_is_usb3_down(port) && !tb_port_is_usb3_up(port))\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_4, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tlr = (val & ADP_USB3_CS_4_MSLR_MASK) >> ADP_USB3_CS_4_MSLR_SHIFT;\n\tret = lr == ADP_USB3_CS_4_MSLR_20G ? 20000 : 10000;\n\n\treturn usb4_usb3_port_max_bandwidth(port, ret);\n}\n\n \nint usb4_usb3_port_actual_link_rate(struct tb_port *port)\n{\n\tint ret, lr;\n\tu32 val;\n\n\tif (!tb_port_is_usb3_down(port) && !tb_port_is_usb3_up(port))\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_4, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & ADP_USB3_CS_4_ULV))\n\t\treturn 0;\n\n\tlr = val & ADP_USB3_CS_4_ALR_MASK;\n\tret = lr == ADP_USB3_CS_4_ALR_20G ? 20000 : 10000;\n\n\treturn usb4_usb3_port_max_bandwidth(port, ret);\n}\n\nstatic int usb4_usb3_port_cm_request(struct tb_port *port, bool request)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!tb_port_is_usb3_down(port))\n\t\treturn -EINVAL;\n\tif (tb_route(port->sw))\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (request)\n\t\tval |= ADP_USB3_CS_2_CMR;\n\telse\n\t\tval &= ~ADP_USB3_CS_2_CMR;\n\n\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_adap + ADP_USB3_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval &= ADP_USB3_CS_2_CMR;\n\treturn usb4_port_wait_for_bit(port, port->cap_adap + ADP_USB3_CS_1,\n\t\t\t\t      ADP_USB3_CS_1_HCA, val, 1500);\n}\n\nstatic inline int usb4_usb3_port_set_cm_request(struct tb_port *port)\n{\n\treturn usb4_usb3_port_cm_request(port, true);\n}\n\nstatic inline int usb4_usb3_port_clear_cm_request(struct tb_port *port)\n{\n\treturn usb4_usb3_port_cm_request(port, false);\n}\n\nstatic unsigned int usb3_bw_to_mbps(u32 bw, u8 scale)\n{\n\tunsigned long uframes;\n\n\tuframes = bw * 512UL << scale;\n\treturn DIV_ROUND_CLOSEST(uframes * 8000, MEGA);\n}\n\nstatic u32 mbps_to_usb3_bw(unsigned int mbps, u8 scale)\n{\n\tunsigned long uframes;\n\n\t \n\tuframes = ((unsigned long)mbps * MEGA) / 8000;\n\treturn DIV_ROUND_UP(uframes, 512UL << scale);\n}\n\nstatic int usb4_usb3_port_read_allocated_bandwidth(struct tb_port *port,\n\t\t\t\t\t\t   int *upstream_bw,\n\t\t\t\t\t\t   int *downstream_bw)\n{\n\tu32 val, bw, scale;\n\tint ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_read(port, &scale, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_3, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tscale &= ADP_USB3_CS_3_SCALE_MASK;\n\n\tbw = val & ADP_USB3_CS_2_AUBW_MASK;\n\t*upstream_bw = usb3_bw_to_mbps(bw, scale);\n\n\tbw = (val & ADP_USB3_CS_2_ADBW_MASK) >> ADP_USB3_CS_2_ADBW_SHIFT;\n\t*downstream_bw = usb3_bw_to_mbps(bw, scale);\n\n\treturn 0;\n}\n\n \nint usb4_usb3_port_allocated_bandwidth(struct tb_port *port, int *upstream_bw,\n\t\t\t\t       int *downstream_bw)\n{\n\tint ret;\n\n\tret = usb4_usb3_port_set_cm_request(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_usb3_port_read_allocated_bandwidth(port, upstream_bw,\n\t\t\t\t\t\t      downstream_bw);\n\tusb4_usb3_port_clear_cm_request(port);\n\n\treturn ret;\n}\n\nstatic int usb4_usb3_port_read_consumed_bandwidth(struct tb_port *port,\n\t\t\t\t\t\t  int *upstream_bw,\n\t\t\t\t\t\t  int *downstream_bw)\n{\n\tu32 val, bw, scale;\n\tint ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_read(port, &scale, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_3, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tscale &= ADP_USB3_CS_3_SCALE_MASK;\n\n\tbw = val & ADP_USB3_CS_1_CUBW_MASK;\n\t*upstream_bw = usb3_bw_to_mbps(bw, scale);\n\n\tbw = (val & ADP_USB3_CS_1_CDBW_MASK) >> ADP_USB3_CS_1_CDBW_SHIFT;\n\t*downstream_bw = usb3_bw_to_mbps(bw, scale);\n\n\treturn 0;\n}\n\nstatic int usb4_usb3_port_write_allocated_bandwidth(struct tb_port *port,\n\t\t\t\t\t\t    int upstream_bw,\n\t\t\t\t\t\t    int downstream_bw)\n{\n\tu32 val, ubw, dbw, scale;\n\tint ret, max_bw;\n\n\t \n\tscale = 0;\n\tmax_bw = max(upstream_bw, downstream_bw);\n\twhile (scale < 64) {\n\t\tif (mbps_to_usb3_bw(max_bw, scale) < 4096)\n\t\t\tbreak;\n\t\tscale++;\n\t}\n\n\tif (WARN_ON(scale >= 64))\n\t\treturn -EINVAL;\n\n\tret = tb_port_write(port, &scale, TB_CFG_PORT,\n\t\t\t    port->cap_adap + ADP_USB3_CS_3, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tubw = mbps_to_usb3_bw(upstream_bw, scale);\n\tdbw = mbps_to_usb3_bw(downstream_bw, scale);\n\n\ttb_port_dbg(port, \"scaled bandwidth %u/%u, scale %u\\n\", ubw, dbw, scale);\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_USB3_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~(ADP_USB3_CS_2_AUBW_MASK | ADP_USB3_CS_2_ADBW_MASK);\n\tval |= dbw << ADP_USB3_CS_2_ADBW_SHIFT;\n\tval |= ubw;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_USB3_CS_2, 1);\n}\n\n \nint usb4_usb3_port_allocate_bandwidth(struct tb_port *port, int *upstream_bw,\n\t\t\t\t      int *downstream_bw)\n{\n\tint ret, consumed_up, consumed_down, allocate_up, allocate_down;\n\n\tret = usb4_usb3_port_set_cm_request(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_usb3_port_read_consumed_bandwidth(port, &consumed_up,\n\t\t\t\t\t\t     &consumed_down);\n\tif (ret)\n\t\tgoto err_request;\n\n\t \n\tallocate_up = max(*upstream_bw, consumed_up);\n\tallocate_down = max(*downstream_bw, consumed_down);\n\n\tret = usb4_usb3_port_write_allocated_bandwidth(port, allocate_up,\n\t\t\t\t\t\t       allocate_down);\n\tif (ret)\n\t\tgoto err_request;\n\n\t*upstream_bw = allocate_up;\n\t*downstream_bw = allocate_down;\n\nerr_request:\n\tusb4_usb3_port_clear_cm_request(port);\n\treturn ret;\n}\n\n \nint usb4_usb3_port_release_bandwidth(struct tb_port *port, int *upstream_bw,\n\t\t\t\t     int *downstream_bw)\n{\n\tint ret, consumed_up, consumed_down;\n\n\tret = usb4_usb3_port_set_cm_request(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_usb3_port_read_consumed_bandwidth(port, &consumed_up,\n\t\t\t\t\t\t     &consumed_down);\n\tif (ret)\n\t\tgoto err_request;\n\n\t \n\tif (consumed_up < 1000)\n\t\tconsumed_up = 1000;\n\tif (consumed_down < 1000)\n\t\tconsumed_down = 1000;\n\n\tret = usb4_usb3_port_write_allocated_bandwidth(port, consumed_up,\n\t\t\t\t\t\t       consumed_down);\n\tif (ret)\n\t\tgoto err_request;\n\n\t*upstream_bw = consumed_up;\n\t*downstream_bw = consumed_down;\n\nerr_request:\n\tusb4_usb3_port_clear_cm_request(port);\n\treturn ret;\n}\n\nstatic bool is_usb4_dpin(const struct tb_port *port)\n{\n\tif (!tb_port_is_dpin(port))\n\t\treturn false;\n\tif (!tb_switch_is_usb4(port->sw))\n\t\treturn false;\n\treturn true;\n}\n\n \nint usb4_dp_port_set_cm_id(struct tb_port *port, int cm_id)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_CM_ID_MASK;\n\tval |= cm_id << ADP_DP_CS_2_CM_ID_SHIFT;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nbool usb4_dp_port_bandwidth_mode_supported(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn false;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + DP_LOCAL_CAP, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & DP_COMMON_CAP_BW_MODE);\n}\n\n \nbool usb4_dp_port_bandwidth_mode_enabled(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn false;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_8, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & ADP_DP_CS_8_DPME);\n}\n\n \nint usb4_dp_port_set_cm_bandwidth_mode_supported(struct tb_port *port,\n\t\t\t\t\t\t bool supported)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (supported)\n\t\tval |= ADP_DP_CS_2_CMMS;\n\telse\n\t\tval &= ~ADP_DP_CS_2_CMMS;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_group_id(struct tb_port *port)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val & ADP_DP_CS_2_GROUP_ID_MASK) >> ADP_DP_CS_2_GROUP_ID_SHIFT;\n}\n\n \nint usb4_dp_port_set_group_id(struct tb_port *port, int group_id)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_GROUP_ID_MASK;\n\tval |= group_id << ADP_DP_CS_2_GROUP_ID_SHIFT;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_nrd(struct tb_port *port, int *rate, int *lanes)\n{\n\tu32 val, tmp;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = (val & ADP_DP_CS_2_NRD_MLR_MASK) >> ADP_DP_CS_2_NRD_MLR_SHIFT;\n\tswitch (tmp) {\n\tcase DP_COMMON_CAP_RATE_RBR:\n\t\t*rate = 1620;\n\t\tbreak;\n\tcase DP_COMMON_CAP_RATE_HBR:\n\t\t*rate = 2700;\n\t\tbreak;\n\tcase DP_COMMON_CAP_RATE_HBR2:\n\t\t*rate = 5400;\n\t\tbreak;\n\tcase DP_COMMON_CAP_RATE_HBR3:\n\t\t*rate = 8100;\n\t\tbreak;\n\t}\n\n\ttmp = val & ADP_DP_CS_2_NRD_MLC_MASK;\n\tswitch (tmp) {\n\tcase DP_COMMON_CAP_1_LANE:\n\t\t*lanes = 1;\n\t\tbreak;\n\tcase DP_COMMON_CAP_2_LANES:\n\t\t*lanes = 2;\n\t\tbreak;\n\tcase DP_COMMON_CAP_4_LANES:\n\t\t*lanes = 4;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint usb4_dp_port_set_nrd(struct tb_port *port, int rate, int lanes)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_NRD_MLR_MASK;\n\n\tswitch (rate) {\n\tcase 1620:\n\t\tbreak;\n\tcase 2700:\n\t\tval |= (DP_COMMON_CAP_RATE_HBR << ADP_DP_CS_2_NRD_MLR_SHIFT)\n\t\t\t& ADP_DP_CS_2_NRD_MLR_MASK;\n\t\tbreak;\n\tcase 5400:\n\t\tval |= (DP_COMMON_CAP_RATE_HBR2 << ADP_DP_CS_2_NRD_MLR_SHIFT)\n\t\t\t& ADP_DP_CS_2_NRD_MLR_MASK;\n\t\tbreak;\n\tcase 8100:\n\t\tval |= (DP_COMMON_CAP_RATE_HBR3 << ADP_DP_CS_2_NRD_MLR_SHIFT)\n\t\t\t& ADP_DP_CS_2_NRD_MLR_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval &= ~ADP_DP_CS_2_NRD_MLC_MASK;\n\n\tswitch (lanes) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tval |= DP_COMMON_CAP_2_LANES;\n\t\tbreak;\n\tcase 4:\n\t\tval |= DP_COMMON_CAP_4_LANES;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_granularity(struct tb_port *port)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ADP_DP_CS_2_GR_MASK;\n\tval >>= ADP_DP_CS_2_GR_SHIFT;\n\n\tswitch (val) {\n\tcase ADP_DP_CS_2_GR_0_25G:\n\t\treturn 250;\n\tcase ADP_DP_CS_2_GR_0_5G:\n\t\treturn 500;\n\tcase ADP_DP_CS_2_GR_1G:\n\t\treturn 1000;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint usb4_dp_port_set_granularity(struct tb_port *port, int granularity)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_GR_MASK;\n\n\tswitch (granularity) {\n\tcase 250:\n\t\tval |= ADP_DP_CS_2_GR_0_25G << ADP_DP_CS_2_GR_SHIFT;\n\t\tbreak;\n\tcase 500:\n\t\tval |= ADP_DP_CS_2_GR_0_5G << ADP_DP_CS_2_GR_SHIFT;\n\t\tbreak;\n\tcase 1000:\n\t\tval |= ADP_DP_CS_2_GR_1G << ADP_DP_CS_2_GR_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_set_estimated_bandwidth(struct tb_port *port, int bw)\n{\n\tu32 val, granularity;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = usb4_dp_port_granularity(port);\n\tif (ret < 0)\n\t\treturn ret;\n\tgranularity = ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_ESTIMATED_BW_MASK;\n\tval |= (bw / granularity) << ADP_DP_CS_2_ESTIMATED_BW_SHIFT;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_allocated_bandwidth(struct tb_port *port)\n{\n\tu32 val, granularity;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = usb4_dp_port_granularity(port);\n\tif (ret < 0)\n\t\treturn ret;\n\tgranularity = ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + DP_STATUS, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= DP_STATUS_ALLOCATED_BW_MASK;\n\tval >>= DP_STATUS_ALLOCATED_BW_SHIFT;\n\n\treturn val * granularity;\n}\n\nstatic int __usb4_dp_port_set_cm_ack(struct tb_port *port, bool ack)\n{\n\tu32 val;\n\tint ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ack)\n\t\tval |= ADP_DP_CS_2_CA;\n\telse\n\t\tval &= ~ADP_DP_CS_2_CA;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\nstatic inline int usb4_dp_port_set_cm_ack(struct tb_port *port)\n{\n\treturn __usb4_dp_port_set_cm_ack(port, true);\n}\n\nstatic int usb4_dp_port_wait_and_clear_cm_ack(struct tb_port *port,\n\t\t\t\t\t      int timeout_msec)\n{\n\tktime_t end;\n\tu32 val;\n\tint ret;\n\n\tret = __usb4_dp_port_set_cm_ack(port, false);\n\tif (ret)\n\t\treturn ret;\n\n\tend = ktime_add_ms(ktime_get(), timeout_msec);\n\tdo {\n\t\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t\t   port->cap_adap + ADP_DP_CS_8, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(val & ADP_DP_CS_8_DR))\n\t\t\tbreak;\n\n\t\tusleep_range(50, 100);\n\t} while (ktime_before(ktime_get(), end));\n\n\tif (val & ADP_DP_CS_8_DR)\n\t\treturn -ETIMEDOUT;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~ADP_DP_CS_2_CA;\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_DP_CS_2, 1);\n}\n\n \nint usb4_dp_port_allocate_bandwidth(struct tb_port *port, int bw)\n{\n\tu32 val, granularity;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = usb4_dp_port_granularity(port);\n\tif (ret < 0)\n\t\treturn ret;\n\tgranularity = ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + DP_STATUS, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~DP_STATUS_ALLOCATED_BW_MASK;\n\tval |= (bw / granularity) << DP_STATUS_ALLOCATED_BW_SHIFT;\n\n\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_adap + DP_STATUS, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_dp_port_set_cm_ack(port);\n\tif (ret)\n\t\treturn ret;\n\n\treturn usb4_dp_port_wait_and_clear_cm_ack(port, 500);\n}\n\n \nint usb4_dp_port_requested_bandwidth(struct tb_port *port)\n{\n\tu32 val, granularity;\n\tint ret;\n\n\tif (!is_usb4_dpin(port))\n\t\treturn -EOPNOTSUPP;\n\n\tret = usb4_dp_port_granularity(port);\n\tif (ret < 0)\n\t\treturn ret;\n\tgranularity = ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_DP_CS_8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & ADP_DP_CS_8_DR))\n\t\treturn -ENODATA;\n\n\treturn (val & ADP_DP_CS_8_REQUESTED_BW_MASK) * granularity;\n}\n\n \nint usb4_pci_port_set_ext_encapsulation(struct tb_port *port, bool enable)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!tb_port_is_pcie_up(port) && !tb_port_is_pcie_down(port))\n\t\treturn -EINVAL;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_adap + ADP_PCIE_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tval |= ADP_PCIE_CS_1_EE;\n\telse\n\t\tval &= ~ADP_PCIE_CS_1_EE;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_adap + ADP_PCIE_CS_1, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}