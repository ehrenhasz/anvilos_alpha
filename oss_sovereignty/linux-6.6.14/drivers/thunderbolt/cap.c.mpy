{
  "module_name": "cap.c",
  "hash_id": "fe2f6ac13340cc650236e2841605f311763ef2f95391c4cde3fe9a2969bd7a70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/cap.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#include \"tb.h\"\n\n#define CAP_OFFSET_MAX\t\t0xff\n#define VSE_CAP_OFFSET_MAX\t0xffff\n#define TMU_ACCESS_EN\t\tBIT(20)\n\nstatic int tb_port_enable_tmu(struct tb_port *port, bool enable)\n{\n\tstruct tb_switch *sw = port->sw;\n\tu32 value, offset;\n\tint ret;\n\n\t \n\tif (tb_switch_is_light_ridge(sw))\n\t\toffset = 0x26;\n\telse if (tb_switch_is_eagle_ridge(sw))\n\t\toffset = 0x2a;\n\telse\n\t\treturn 0;\n\n\tret = tb_sw_read(sw, &value, TB_CFG_SWITCH, offset, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tvalue |= TMU_ACCESS_EN;\n\telse\n\t\tvalue &= ~TMU_ACCESS_EN;\n\n\treturn tb_sw_write(sw, &value, TB_CFG_SWITCH, offset, 1);\n}\n\nstatic void tb_port_dummy_read(struct tb_port *port)\n{\n\t \n\tif (tb_switch_is_light_ridge(port->sw)) {\n\t\tu32 dummy;\n\n\t\ttb_port_read(port, &dummy, TB_CFG_PORT, 0, 1);\n\t}\n}\n\n \nint tb_port_next_cap(struct tb_port *port, unsigned int offset)\n{\n\tstruct tb_cap_any header;\n\tint ret;\n\n\tif (!offset)\n\t\treturn port->config.first_cap_offset;\n\n\tret = tb_port_read(port, &header, TB_CFG_PORT, offset, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn header.basic.next;\n}\n\nstatic int __tb_port_find_cap(struct tb_port *port, enum tb_port_cap cap)\n{\n\tint offset = 0;\n\n\tdo {\n\t\tstruct tb_cap_any header;\n\t\tint ret;\n\n\t\toffset = tb_port_next_cap(port, offset);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\n\t\tret = tb_port_read(port, &header, TB_CFG_PORT, offset, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (header.basic.cap == cap)\n\t\t\treturn offset;\n\t} while (offset > 0);\n\n\treturn -ENOENT;\n}\n\n \nint tb_port_find_cap(struct tb_port *port, enum tb_port_cap cap)\n{\n\tint ret;\n\n\tret = tb_port_enable_tmu(port, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __tb_port_find_cap(port, cap);\n\n\ttb_port_dummy_read(port);\n\ttb_port_enable_tmu(port, false);\n\n\treturn ret;\n}\n\n \nint tb_switch_next_cap(struct tb_switch *sw, unsigned int offset)\n{\n\tstruct tb_cap_any header;\n\tint ret;\n\n\tif (!offset)\n\t\treturn sw->config.first_cap_offset;\n\n\tret = tb_sw_read(sw, &header, TB_CFG_SWITCH, offset, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (header.basic.cap) {\n\tcase TB_SWITCH_CAP_TMU:\n\t\tret = header.basic.next;\n\t\tbreak;\n\n\tcase TB_SWITCH_CAP_VSE:\n\t\tif (!header.extended_short.length)\n\t\t\tret = header.extended_long.next;\n\t\telse\n\t\t\tret = header.extended_short.next;\n\t\tbreak;\n\n\tdefault:\n\t\ttb_sw_dbg(sw, \"unknown capability %#x at %#x\\n\",\n\t\t\t  header.basic.cap, offset);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret >= VSE_CAP_OFFSET_MAX ? 0 : ret;\n}\n\n \nint tb_switch_find_cap(struct tb_switch *sw, enum tb_switch_cap cap)\n{\n\tint offset = 0;\n\n\tdo {\n\t\tstruct tb_cap_any header;\n\t\tint ret;\n\n\t\toffset = tb_switch_next_cap(sw, offset);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\n\t\tret = tb_sw_read(sw, &header, TB_CFG_SWITCH, offset, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (header.basic.cap == cap)\n\t\t\treturn offset;\n\t} while (offset);\n\n\treturn -ENOENT;\n}\n\n \nint tb_switch_find_vse_cap(struct tb_switch *sw, enum tb_switch_vse_cap vsec)\n{\n\tint offset = 0;\n\n\tdo {\n\t\tstruct tb_cap_any header;\n\t\tint ret;\n\n\t\toffset = tb_switch_next_cap(sw, offset);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\n\t\tret = tb_sw_read(sw, &header, TB_CFG_SWITCH, offset, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (header.extended_short.cap == TB_SWITCH_CAP_VSE &&\n\t\t    header.extended_short.vsec_id == vsec)\n\t\t\treturn offset;\n\t} while (offset);\n\n\treturn -ENOENT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}