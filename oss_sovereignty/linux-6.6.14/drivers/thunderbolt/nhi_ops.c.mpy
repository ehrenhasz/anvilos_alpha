{
  "module_name": "nhi_ops.c",
  "hash_id": "17bb3162a20e034f03bcf752cba40edb3720bd2f5a9b8223cd1106f50aa11a34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/nhi_ops.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/suspend.h>\n\n#include \"nhi.h\"\n#include \"nhi_regs.h\"\n#include \"tb.h\"\n\n \n\n#define ICL_LC_MAILBOX_TIMEOUT\t500  \n\nstatic int check_for_device(struct device *dev, void *data)\n{\n\treturn tb_is_switch(dev);\n}\n\nstatic bool icl_nhi_is_device_connected(struct tb_nhi *nhi)\n{\n\tstruct tb *tb = pci_get_drvdata(nhi->pdev);\n\tint ret;\n\n\tret = device_for_each_child(&tb->root_switch->dev, NULL,\n\t\t\t\t    check_for_device);\n\treturn ret > 0;\n}\n\nstatic int icl_nhi_force_power(struct tb_nhi *nhi, bool power)\n{\n\tu32 vs_cap;\n\n\t \n\tpci_read_config_dword(nhi->pdev, VS_CAP_22, &vs_cap);\n\tif (power) {\n\t\tvs_cap &= ~VS_CAP_22_DMA_DELAY_MASK;\n\t\tvs_cap |= 0x22 << VS_CAP_22_DMA_DELAY_SHIFT;\n\t\tvs_cap |= VS_CAP_22_FORCE_POWER;\n\t} else {\n\t\tvs_cap &= ~VS_CAP_22_FORCE_POWER;\n\t}\n\tpci_write_config_dword(nhi->pdev, VS_CAP_22, vs_cap);\n\n\tif (power) {\n\t\tunsigned int retries = 350;\n\t\tu32 val;\n\n\t\t \n\t\tdo {\n\t\t\tpci_read_config_dword(nhi->pdev, VS_CAP_9, &val);\n\t\t\tif (val & VS_CAP_9_FW_READY)\n\t\t\t\treturn 0;\n\t\t\tusleep_range(3000, 3100);\n\t\t} while (--retries);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void icl_nhi_lc_mailbox_cmd(struct tb_nhi *nhi, enum icl_lc_mailbox_cmd cmd)\n{\n\tu32 data;\n\n\tdata = (cmd << VS_CAP_19_CMD_SHIFT) & VS_CAP_19_CMD_MASK;\n\tpci_write_config_dword(nhi->pdev, VS_CAP_19, data | VS_CAP_19_VALID);\n}\n\nstatic int icl_nhi_lc_mailbox_cmd_complete(struct tb_nhi *nhi, int timeout)\n{\n\tunsigned long end;\n\tu32 data;\n\n\tif (!timeout)\n\t\tgoto clear;\n\n\tend = jiffies + msecs_to_jiffies(timeout);\n\tdo {\n\t\tpci_read_config_dword(nhi->pdev, VS_CAP_18, &data);\n\t\tif (data & VS_CAP_18_DONE)\n\t\t\tgoto clear;\n\t\tusleep_range(1000, 1100);\n\t} while (time_before(jiffies, end));\n\n\treturn -ETIMEDOUT;\n\nclear:\n\t \n\tpci_write_config_dword(nhi->pdev, VS_CAP_19, 0);\n\treturn 0;\n}\n\nstatic void icl_nhi_set_ltr(struct tb_nhi *nhi)\n{\n\tu32 max_ltr, ltr;\n\n\tpci_read_config_dword(nhi->pdev, VS_CAP_16, &max_ltr);\n\tmax_ltr &= 0xffff;\n\t \n\tltr = max_ltr << 16 | max_ltr;\n\tpci_write_config_dword(nhi->pdev, VS_CAP_15, ltr);\n}\n\nstatic int icl_nhi_suspend(struct tb_nhi *nhi)\n{\n\tstruct tb *tb = pci_get_drvdata(nhi->pdev);\n\tint ret;\n\n\tif (icl_nhi_is_device_connected(nhi))\n\t\treturn 0;\n\n\tif (tb_switch_is_icm(tb->root_switch)) {\n\t\t \n\t\ticl_nhi_lc_mailbox_cmd(nhi, ICL_LC_PREPARE_FOR_RESET);\n\t\tret = icl_nhi_lc_mailbox_cmd_complete(nhi, ICL_LC_MAILBOX_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn icl_nhi_force_power(nhi, false);\n}\n\nstatic int icl_nhi_suspend_noirq(struct tb_nhi *nhi, bool wakeup)\n{\n\tstruct tb *tb = pci_get_drvdata(nhi->pdev);\n\tenum icl_lc_mailbox_cmd cmd;\n\n\tif (!pm_suspend_via_firmware())\n\t\treturn icl_nhi_suspend(nhi);\n\n\tif (!tb_switch_is_icm(tb->root_switch))\n\t\treturn 0;\n\n\tcmd = wakeup ? ICL_LC_GO2SX : ICL_LC_GO2SX_NO_WAKE;\n\ticl_nhi_lc_mailbox_cmd(nhi, cmd);\n\treturn icl_nhi_lc_mailbox_cmd_complete(nhi, ICL_LC_MAILBOX_TIMEOUT);\n}\n\nstatic int icl_nhi_resume(struct tb_nhi *nhi)\n{\n\tint ret;\n\n\tret = icl_nhi_force_power(nhi, true);\n\tif (ret)\n\t\treturn ret;\n\n\ticl_nhi_set_ltr(nhi);\n\treturn 0;\n}\n\nstatic void icl_nhi_shutdown(struct tb_nhi *nhi)\n{\n\ticl_nhi_force_power(nhi, false);\n}\n\nconst struct tb_nhi_ops icl_nhi_ops = {\n\t.init = icl_nhi_resume,\n\t.suspend_noirq = icl_nhi_suspend_noirq,\n\t.resume_noirq = icl_nhi_resume,\n\t.runtime_suspend = icl_nhi_suspend,\n\t.runtime_resume = icl_nhi_resume,\n\t.shutdown = icl_nhi_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}