{
  "module_name": "clx.c",
  "hash_id": "687f6fcdaf518072a474faba2331d361f4e610bdad9ddc20232940a2dbb8faa3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/clx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include \"tb.h\"\n\nstatic bool clx_enabled = true;\nmodule_param_named(clx, clx_enabled, bool, 0444);\nMODULE_PARM_DESC(clx, \"allow low power states on the high-speed lanes (default: true)\");\n\nstatic const char *clx_name(unsigned int clx)\n{\n\tswitch (clx) {\n\tcase TB_CL0S | TB_CL1 | TB_CL2:\n\t\treturn \"CL0s/CL1/CL2\";\n\tcase TB_CL1 | TB_CL2:\n\t\treturn \"CL1/CL2\";\n\tcase TB_CL0S | TB_CL2:\n\t\treturn \"CL0s/CL2\";\n\tcase TB_CL0S | TB_CL1:\n\t\treturn \"CL0s/CL1\";\n\tcase TB_CL0S:\n\t\treturn \"CL0s\";\n\tcase 0:\n\t\treturn \"disabled\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int tb_port_pm_secondary_set(struct tb_port *port, bool secondary)\n{\n\tu32 phy;\n\tint ret;\n\n\tret = tb_port_read(port, &phy, TB_CFG_PORT,\n\t\t\t   port->cap_phy + LANE_ADP_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (secondary)\n\t\tphy |= LANE_ADP_CS_1_PMS;\n\telse\n\t\tphy &= ~LANE_ADP_CS_1_PMS;\n\n\treturn tb_port_write(port, &phy, TB_CFG_PORT,\n\t\t\t     port->cap_phy + LANE_ADP_CS_1, 1);\n}\n\nstatic int tb_port_pm_secondary_enable(struct tb_port *port)\n{\n\treturn tb_port_pm_secondary_set(port, true);\n}\n\nstatic int tb_port_pm_secondary_disable(struct tb_port *port)\n{\n\treturn tb_port_pm_secondary_set(port, false);\n}\n\n \nstatic bool tb_port_clx_supported(struct tb_port *port, unsigned int clx)\n{\n\tu32 val, mask = 0;\n\tbool ret;\n\n\t \n\tif (!port->bonded && port->dual_link_port)\n\t\treturn false;\n\n\t \n\tif (port->xdomain)\n\t\treturn false;\n\n\tif (tb_switch_is_usb4(port->sw)) {\n\t\tif (!usb4_port_clx_supported(port))\n\t\t\treturn false;\n\t} else if (!tb_lc_is_clx_supported(port)) {\n\t\treturn false;\n\t}\n\n\tif (clx & TB_CL0S)\n\t\tmask |= LANE_ADP_CS_0_CL0S_SUPPORT;\n\tif (clx & TB_CL1)\n\t\tmask |= LANE_ADP_CS_0_CL1_SUPPORT;\n\tif (clx & TB_CL2)\n\t\tmask |= LANE_ADP_CS_0_CL2_SUPPORT;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_phy + LANE_ADP_CS_0, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & mask);\n}\n\nstatic int tb_port_clx_set(struct tb_port *port, unsigned int clx, bool enable)\n{\n\tu32 phy, mask = 0;\n\tint ret;\n\n\tif (clx & TB_CL0S)\n\t\tmask |= LANE_ADP_CS_1_CL0S_ENABLE;\n\tif (clx & TB_CL1)\n\t\tmask |= LANE_ADP_CS_1_CL1_ENABLE;\n\tif (clx & TB_CL2)\n\t\tmask |= LANE_ADP_CS_1_CL2_ENABLE;\n\n\tif (!mask)\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_read(port, &phy, TB_CFG_PORT,\n\t\t\t   port->cap_phy + LANE_ADP_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tphy |= mask;\n\telse\n\t\tphy &= ~mask;\n\n\treturn tb_port_write(port, &phy, TB_CFG_PORT,\n\t\t\t     port->cap_phy + LANE_ADP_CS_1, 1);\n}\n\nstatic int tb_port_clx_disable(struct tb_port *port, unsigned int clx)\n{\n\treturn tb_port_clx_set(port, clx, false);\n}\n\nstatic int tb_port_clx_enable(struct tb_port *port, unsigned int clx)\n{\n\treturn tb_port_clx_set(port, clx, true);\n}\n\nstatic int tb_port_clx(struct tb_port *port)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!tb_port_clx_supported(port, TB_CL0S | TB_CL1 | TB_CL2))\n\t\treturn 0;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_phy + LANE_ADP_CS_1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & LANE_ADP_CS_1_CL0S_ENABLE)\n\t\tret |= TB_CL0S;\n\tif (val & LANE_ADP_CS_1_CL1_ENABLE)\n\t\tret |= TB_CL1;\n\tif (val & LANE_ADP_CS_1_CL2_ENABLE)\n\t\tret |= TB_CL2;\n\n\treturn ret;\n}\n\n \nbool tb_port_clx_is_enabled(struct tb_port *port, unsigned int clx)\n{\n\treturn !!(tb_port_clx(port) & clx);\n}\n\n \nint tb_switch_clx_init(struct tb_switch *sw)\n{\n\tstruct tb_port *up, *down;\n\tunsigned int clx, tmp;\n\n\tif (tb_switch_is_icm(sw))\n\t\treturn 0;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tif (!tb_switch_clx_is_supported(sw))\n\t\treturn 0;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\tclx = tb_port_clx(up);\n\ttmp = tb_port_clx(down);\n\tif (clx != tmp)\n\t\ttb_sw_warn(sw, \"CLx: inconsistent configuration %#x != %#x\\n\",\n\t\t\t   clx, tmp);\n\n\ttb_sw_dbg(sw, \"CLx: current mode: %s\\n\", clx_name(clx));\n\n\tsw->clx = clx;\n\treturn 0;\n}\n\nstatic int tb_switch_pm_secondary_resolve(struct tb_switch *sw)\n{\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\tret = tb_port_pm_secondary_enable(up);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_port_pm_secondary_disable(down);\n}\n\nstatic int tb_switch_mask_clx_objections(struct tb_switch *sw)\n{\n\tint up_port = sw->config.upstream_port_number;\n\tu32 offset, val[2], mask_obj, unmask_obj;\n\tint ret, i;\n\n\t \n\tif (!tb_switch_is_titan_ridge(sw))\n\t\treturn 0;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\t \n\tif (up_port == 1) {\n\t\tmask_obj = TB_LOW_PWR_C0_PORT_B_MASK;\n\t\tunmask_obj = TB_LOW_PWR_C1_PORT_A_MASK;\n\t\toffset = TB_LOW_PWR_C1_CL1;\n\t} else {\n\t\tmask_obj = TB_LOW_PWR_C1_PORT_A_MASK;\n\t\tunmask_obj = TB_LOW_PWR_C0_PORT_B_MASK;\n\t\toffset = TB_LOW_PWR_C3_CL1;\n\t}\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->cap_lp + offset, ARRAY_SIZE(val));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(val); i++) {\n\t\tval[i] |= mask_obj;\n\t\tval[i] &= ~unmask_obj;\n\t}\n\n\treturn tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t   sw->cap_lp + offset, ARRAY_SIZE(val));\n}\n\n \nbool tb_switch_clx_is_supported(const struct tb_switch *sw)\n{\n\tif (!clx_enabled)\n\t\treturn false;\n\n\tif (sw->quirks & QUIRK_NO_CLX)\n\t\treturn false;\n\n\t \n\tif (tb_switch_is_tiger_lake(sw))\n\t\treturn false;\n\n\treturn tb_switch_is_usb4(sw) || tb_switch_is_titan_ridge(sw);\n}\n\nstatic bool validate_mask(unsigned int clx)\n{\n\t \n\tif (clx & TB_CL1)\n\t\treturn (clx & TB_CL0S) == TB_CL0S;\n\treturn true;\n}\n\n \nint tb_switch_clx_enable(struct tb_switch *sw, unsigned int clx)\n{\n\tbool up_clx_support, down_clx_support;\n\tstruct tb_switch *parent_sw;\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tif (!clx || sw->clx == clx)\n\t\treturn 0;\n\n\tif (!validate_mask(clx))\n\t\treturn -EINVAL;\n\n\tparent_sw = tb_switch_parent(sw);\n\tif (!parent_sw)\n\t\treturn 0;\n\n\tif (!tb_switch_clx_is_supported(parent_sw) ||\n\t    !tb_switch_clx_is_supported(sw))\n\t\treturn 0;\n\n\t \n\tif ((clx & TB_CL2) &&\n\t    (usb4_switch_version(parent_sw) < 2 ||\n\t     usb4_switch_version(sw) < 2))\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_switch_pm_secondary_resolve(sw);\n\tif (ret)\n\t\treturn ret;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\tup_clx_support = tb_port_clx_supported(up, clx);\n\tdown_clx_support = tb_port_clx_supported(down, clx);\n\n\ttb_port_dbg(up, \"CLx: %s %ssupported\\n\", clx_name(clx),\n\t\t    up_clx_support ? \"\" : \"not \");\n\ttb_port_dbg(down, \"CLx: %s %ssupported\\n\", clx_name(clx),\n\t\t    down_clx_support ? \"\" : \"not \");\n\n\tif (!up_clx_support || !down_clx_support)\n\t\treturn -EOPNOTSUPP;\n\n\tret = tb_port_clx_enable(up, clx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_clx_enable(down, clx);\n\tif (ret) {\n\t\ttb_port_clx_disable(up, clx);\n\t\treturn ret;\n\t}\n\n\tret = tb_switch_mask_clx_objections(sw);\n\tif (ret) {\n\t\ttb_port_clx_disable(up, clx);\n\t\ttb_port_clx_disable(down, clx);\n\t\treturn ret;\n\t}\n\n\tsw->clx |= clx;\n\n\ttb_sw_dbg(sw, \"CLx: %s enabled\\n\", clx_name(clx));\n\treturn 0;\n}\n\n \nint tb_switch_clx_disable(struct tb_switch *sw)\n{\n\tunsigned int clx = sw->clx;\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tif (!tb_switch_clx_is_supported(sw))\n\t\treturn 0;\n\n\tif (!clx)\n\t\treturn 0;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\tret = tb_port_clx_disable(up, clx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_clx_disable(down, clx);\n\tif (ret)\n\t\treturn ret;\n\n\tsw->clx = 0;\n\n\ttb_sw_dbg(sw, \"CLx: %s disabled\\n\", clx_name(clx));\n\treturn clx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}