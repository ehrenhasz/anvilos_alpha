{
  "module_name": "ctl.h",
  "hash_id": "afaaa93aa82b0d21165efeaab48a5c0bd4a3fa4fb4a8659f92bf838106e9bf75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/ctl.h",
  "human_readable_source": " \n \n\n#ifndef _TB_CFG\n#define _TB_CFG\n\n#include <linux/kref.h>\n#include <linux/thunderbolt.h>\n\n#include \"nhi.h\"\n#include \"tb_msgs.h\"\n\n \nstruct tb_ctl;\n\ntypedef bool (*event_cb)(void *data, enum tb_cfg_pkg_type type,\n\t\t\t const void *buf, size_t size);\n\nstruct tb_ctl *tb_ctl_alloc(struct tb_nhi *nhi, int timeout_msec, event_cb cb,\n\t\t\t    void *cb_data);\nvoid tb_ctl_start(struct tb_ctl *ctl);\nvoid tb_ctl_stop(struct tb_ctl *ctl);\nvoid tb_ctl_free(struct tb_ctl *ctl);\n\n \n\nstruct tb_cfg_result {\n\tu64 response_route;\n\tu32 response_port;  \n\tint err;  \n\tenum tb_cfg_error tb_error;  \n};\n\nstruct ctl_pkg {\n\tstruct tb_ctl *ctl;\n\tvoid *buffer;\n\tstruct ring_frame frame;\n};\n\n \nstruct tb_cfg_request {\n\tstruct kref kref;\n\tstruct tb_ctl *ctl;\n\tconst void *request;\n\tsize_t request_size;\n\tenum tb_cfg_pkg_type request_type;\n\tvoid *response;\n\tsize_t response_size;\n\tenum tb_cfg_pkg_type response_type;\n\tsize_t npackets;\n\tbool (*match)(const struct tb_cfg_request *req,\n\t\t      const struct ctl_pkg *pkg);\n\tbool (*copy)(struct tb_cfg_request *req, const struct ctl_pkg *pkg);\n\tvoid (*callback)(void *callback_data);\n\tvoid *callback_data;\n\tunsigned long flags;\n\tstruct work_struct work;\n\tstruct tb_cfg_result result;\n\tstruct list_head list;\n};\n\n#define TB_CFG_REQUEST_ACTIVE\t\t0\n#define TB_CFG_REQUEST_CANCELED\t\t1\n\nstruct tb_cfg_request *tb_cfg_request_alloc(void);\nvoid tb_cfg_request_get(struct tb_cfg_request *req);\nvoid tb_cfg_request_put(struct tb_cfg_request *req);\nint tb_cfg_request(struct tb_ctl *ctl, struct tb_cfg_request *req,\n\t\t   void (*callback)(void *), void *callback_data);\nvoid tb_cfg_request_cancel(struct tb_cfg_request *req, int err);\nstruct tb_cfg_result tb_cfg_request_sync(struct tb_ctl *ctl,\n\t\t\tstruct tb_cfg_request *req, int timeout_msec);\n\nstatic inline u64 tb_cfg_get_route(const struct tb_cfg_header *header)\n{\n\treturn (u64) header->route_hi << 32 | header->route_lo;\n}\n\nstatic inline struct tb_cfg_header tb_cfg_make_header(u64 route)\n{\n\tstruct tb_cfg_header header = {\n\t\t.route_hi = route >> 32,\n\t\t.route_lo = route,\n\t};\n\t \n\tWARN_ON(tb_cfg_get_route(&header) != route);\n\treturn header;\n}\n\nint tb_cfg_ack_notification(struct tb_ctl *ctl, u64 route,\n\t\t\t    const struct cfg_error_pkg *error);\nint tb_cfg_ack_plug(struct tb_ctl *ctl, u64 route, u32 port, bool unplug);\nstruct tb_cfg_result tb_cfg_reset(struct tb_ctl *ctl, u64 route);\nstruct tb_cfg_result tb_cfg_read_raw(struct tb_ctl *ctl, void *buffer,\n\t\t\t\t     u64 route, u32 port,\n\t\t\t\t     enum tb_cfg_space space, u32 offset,\n\t\t\t\t     u32 length, int timeout_msec);\nstruct tb_cfg_result tb_cfg_write_raw(struct tb_ctl *ctl, const void *buffer,\n\t\t\t\t      u64 route, u32 port,\n\t\t\t\t      enum tb_cfg_space space, u32 offset,\n\t\t\t\t      u32 length, int timeout_msec);\nint tb_cfg_read(struct tb_ctl *ctl, void *buffer, u64 route, u32 port,\n\t\tenum tb_cfg_space space, u32 offset, u32 length);\nint tb_cfg_write(struct tb_ctl *ctl, const void *buffer, u64 route, u32 port,\n\t\t enum tb_cfg_space space, u32 offset, u32 length);\nint tb_cfg_get_upstream_port(struct tb_ctl *ctl, u64 route);\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}