{
  "module_name": "dma_test.c",
  "hash_id": "6e755a35fa06c46ce08ae34f990059b047119a204485632c3bf2b26b31e015ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/dma_test.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/sizes.h>\n#include <linux/thunderbolt.h>\n\n#define DMA_TEST_TX_RING_SIZE\t\t64\n#define DMA_TEST_RX_RING_SIZE\t\t256\n#define DMA_TEST_FRAME_SIZE\t\tSZ_4K\n#define DMA_TEST_DATA_PATTERN\t\t0x0123456789abcdefLL\n#define DMA_TEST_MAX_PACKETS\t\t1000\n\nenum dma_test_frame_pdf {\n\tDMA_TEST_PDF_FRAME_START = 1,\n\tDMA_TEST_PDF_FRAME_END,\n};\n\nstruct dma_test_frame {\n\tstruct dma_test *dma_test;\n\tvoid *data;\n\tstruct ring_frame frame;\n};\n\nenum dma_test_test_error {\n\tDMA_TEST_NO_ERROR,\n\tDMA_TEST_INTERRUPTED,\n\tDMA_TEST_BUFFER_ERROR,\n\tDMA_TEST_DMA_ERROR,\n\tDMA_TEST_CONFIG_ERROR,\n\tDMA_TEST_SPEED_ERROR,\n\tDMA_TEST_WIDTH_ERROR,\n\tDMA_TEST_BONDING_ERROR,\n\tDMA_TEST_PACKET_ERROR,\n};\n\nstatic const char * const dma_test_error_names[] = {\n\t[DMA_TEST_NO_ERROR] = \"no errors\",\n\t[DMA_TEST_INTERRUPTED] = \"interrupted by signal\",\n\t[DMA_TEST_BUFFER_ERROR] = \"no memory for packet buffers\",\n\t[DMA_TEST_DMA_ERROR] = \"DMA ring setup failed\",\n\t[DMA_TEST_CONFIG_ERROR] = \"configuration is not valid\",\n\t[DMA_TEST_SPEED_ERROR] = \"unexpected link speed\",\n\t[DMA_TEST_WIDTH_ERROR] = \"unexpected link width\",\n\t[DMA_TEST_BONDING_ERROR] = \"lane bonding configuration error\",\n\t[DMA_TEST_PACKET_ERROR] = \"packet check failed\",\n};\n\nenum dma_test_result {\n\tDMA_TEST_NOT_RUN,\n\tDMA_TEST_SUCCESS,\n\tDMA_TEST_FAIL,\n};\n\nstatic const char * const dma_test_result_names[] = {\n\t[DMA_TEST_NOT_RUN] = \"not run\",\n\t[DMA_TEST_SUCCESS] = \"success\",\n\t[DMA_TEST_FAIL] = \"failed\",\n};\n\n \nstruct dma_test {\n\tconst struct tb_service *svc;\n\tstruct tb_xdomain *xd;\n\tstruct tb_ring *rx_ring;\n\tint rx_hopid;\n\tstruct tb_ring *tx_ring;\n\tint tx_hopid;\n\tunsigned int packets_to_send;\n\tunsigned int packets_to_receive;\n\tunsigned int packets_sent;\n\tunsigned int packets_received;\n\tunsigned int link_speed;\n\tunsigned int link_width;\n\tunsigned int crc_errors;\n\tunsigned int buffer_overflow_errors;\n\tenum dma_test_result result;\n\tenum dma_test_test_error error_code;\n\tstruct completion complete;\n\tstruct mutex lock;\n\tstruct dentry *debugfs_dir;\n};\n\n \nstatic const uuid_t dma_test_dir_uuid =\n\tUUID_INIT(0x3188cd10, 0x6523, 0x4a5a,\n\t\t  0xa6, 0x82, 0xfd, 0xca, 0x07, 0xa2, 0x48, 0xd8);\n\nstatic struct tb_property_dir *dma_test_dir;\nstatic void *dma_test_pattern;\n\nstatic void dma_test_free_rings(struct dma_test *dt)\n{\n\tif (dt->rx_ring) {\n\t\ttb_xdomain_release_in_hopid(dt->xd, dt->rx_hopid);\n\t\ttb_ring_free(dt->rx_ring);\n\t\tdt->rx_ring = NULL;\n\t}\n\tif (dt->tx_ring) {\n\t\ttb_xdomain_release_out_hopid(dt->xd, dt->tx_hopid);\n\t\ttb_ring_free(dt->tx_ring);\n\t\tdt->tx_ring = NULL;\n\t}\n}\n\nstatic int dma_test_start_rings(struct dma_test *dt)\n{\n\tunsigned int flags = RING_FLAG_FRAME;\n\tstruct tb_xdomain *xd = dt->xd;\n\tint ret, e2e_tx_hop = 0;\n\tstruct tb_ring *ring;\n\n\t \n\tif (dt->packets_to_send && dt->packets_to_receive)\n\t\tflags |= RING_FLAG_E2E;\n\n\tif (dt->packets_to_send) {\n\t\tring = tb_ring_alloc_tx(xd->tb->nhi, -1, DMA_TEST_TX_RING_SIZE,\n\t\t\t\t\tflags);\n\t\tif (!ring)\n\t\t\treturn -ENOMEM;\n\n\t\tdt->tx_ring = ring;\n\t\te2e_tx_hop = ring->hop;\n\n\t\tret = tb_xdomain_alloc_out_hopid(xd, -1);\n\t\tif (ret < 0) {\n\t\t\tdma_test_free_rings(dt);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdt->tx_hopid = ret;\n\t}\n\n\tif (dt->packets_to_receive) {\n\t\tu16 sof_mask, eof_mask;\n\n\t\tsof_mask = BIT(DMA_TEST_PDF_FRAME_START);\n\t\teof_mask = BIT(DMA_TEST_PDF_FRAME_END);\n\n\t\tring = tb_ring_alloc_rx(xd->tb->nhi, -1, DMA_TEST_RX_RING_SIZE,\n\t\t\t\t\tflags, e2e_tx_hop, sof_mask, eof_mask,\n\t\t\t\t\tNULL, NULL);\n\t\tif (!ring) {\n\t\t\tdma_test_free_rings(dt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdt->rx_ring = ring;\n\n\t\tret = tb_xdomain_alloc_in_hopid(xd, -1);\n\t\tif (ret < 0) {\n\t\t\tdma_test_free_rings(dt);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdt->rx_hopid = ret;\n\t}\n\n\tret = tb_xdomain_enable_paths(dt->xd, dt->tx_hopid,\n\t\t\t\t      dt->tx_ring ? dt->tx_ring->hop : -1,\n\t\t\t\t      dt->rx_hopid,\n\t\t\t\t      dt->rx_ring ? dt->rx_ring->hop : -1);\n\tif (ret) {\n\t\tdma_test_free_rings(dt);\n\t\treturn ret;\n\t}\n\n\tif (dt->tx_ring)\n\t\ttb_ring_start(dt->tx_ring);\n\tif (dt->rx_ring)\n\t\ttb_ring_start(dt->rx_ring);\n\n\treturn 0;\n}\n\nstatic void dma_test_stop_rings(struct dma_test *dt)\n{\n\tint ret;\n\n\tif (dt->rx_ring)\n\t\ttb_ring_stop(dt->rx_ring);\n\tif (dt->tx_ring)\n\t\ttb_ring_stop(dt->tx_ring);\n\n\tret = tb_xdomain_disable_paths(dt->xd, dt->tx_hopid,\n\t\t\t\t       dt->tx_ring ? dt->tx_ring->hop : -1,\n\t\t\t\t       dt->rx_hopid,\n\t\t\t\t       dt->rx_ring ? dt->rx_ring->hop : -1);\n\tif (ret)\n\t\tdev_warn(&dt->svc->dev, \"failed to disable DMA paths\\n\");\n\n\tdma_test_free_rings(dt);\n}\n\nstatic void dma_test_rx_callback(struct tb_ring *ring, struct ring_frame *frame,\n\t\t\t\t bool canceled)\n{\n\tstruct dma_test_frame *tf = container_of(frame, typeof(*tf), frame);\n\tstruct dma_test *dt = tf->dma_test;\n\tstruct device *dma_dev = tb_ring_dma_device(dt->rx_ring);\n\n\tdma_unmap_single(dma_dev, tf->frame.buffer_phy, DMA_TEST_FRAME_SIZE,\n\t\t\t DMA_FROM_DEVICE);\n\tkfree(tf->data);\n\n\tif (canceled) {\n\t\tkfree(tf);\n\t\treturn;\n\t}\n\n\tdt->packets_received++;\n\tdev_dbg(&dt->svc->dev, \"packet %u/%u received\\n\", dt->packets_received,\n\t\tdt->packets_to_receive);\n\n\tif (tf->frame.flags & RING_DESC_CRC_ERROR)\n\t\tdt->crc_errors++;\n\tif (tf->frame.flags & RING_DESC_BUFFER_OVERRUN)\n\t\tdt->buffer_overflow_errors++;\n\n\tkfree(tf);\n\n\tif (dt->packets_received == dt->packets_to_receive)\n\t\tcomplete(&dt->complete);\n}\n\nstatic int dma_test_submit_rx(struct dma_test *dt, size_t npackets)\n{\n\tstruct device *dma_dev = tb_ring_dma_device(dt->rx_ring);\n\tint i;\n\n\tfor (i = 0; i < npackets; i++) {\n\t\tstruct dma_test_frame *tf;\n\t\tdma_addr_t dma_addr;\n\n\t\ttf = kzalloc(sizeof(*tf), GFP_KERNEL);\n\t\tif (!tf)\n\t\t\treturn -ENOMEM;\n\n\t\ttf->data = kzalloc(DMA_TEST_FRAME_SIZE, GFP_KERNEL);\n\t\tif (!tf->data) {\n\t\t\tkfree(tf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdma_addr = dma_map_single(dma_dev, tf->data, DMA_TEST_FRAME_SIZE,\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dma_dev, dma_addr)) {\n\t\t\tkfree(tf->data);\n\t\t\tkfree(tf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttf->frame.buffer_phy = dma_addr;\n\t\ttf->frame.callback = dma_test_rx_callback;\n\t\ttf->dma_test = dt;\n\t\tINIT_LIST_HEAD(&tf->frame.list);\n\n\t\ttb_ring_rx(dt->rx_ring, &tf->frame);\n\t}\n\n\treturn 0;\n}\n\nstatic void dma_test_tx_callback(struct tb_ring *ring, struct ring_frame *frame,\n\t\t\t\t bool canceled)\n{\n\tstruct dma_test_frame *tf = container_of(frame, typeof(*tf), frame);\n\tstruct dma_test *dt = tf->dma_test;\n\tstruct device *dma_dev = tb_ring_dma_device(dt->tx_ring);\n\n\tdma_unmap_single(dma_dev, tf->frame.buffer_phy, DMA_TEST_FRAME_SIZE,\n\t\t\t DMA_TO_DEVICE);\n\tkfree(tf->data);\n\tkfree(tf);\n}\n\nstatic int dma_test_submit_tx(struct dma_test *dt, size_t npackets)\n{\n\tstruct device *dma_dev = tb_ring_dma_device(dt->tx_ring);\n\tint i;\n\n\tfor (i = 0; i < npackets; i++) {\n\t\tstruct dma_test_frame *tf;\n\t\tdma_addr_t dma_addr;\n\n\t\ttf = kzalloc(sizeof(*tf), GFP_KERNEL);\n\t\tif (!tf)\n\t\t\treturn -ENOMEM;\n\n\t\ttf->frame.size = 0;  \n\t\ttf->dma_test = dt;\n\n\t\ttf->data = kmemdup(dma_test_pattern, DMA_TEST_FRAME_SIZE, GFP_KERNEL);\n\t\tif (!tf->data) {\n\t\t\tkfree(tf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdma_addr = dma_map_single(dma_dev, tf->data, DMA_TEST_FRAME_SIZE,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dma_dev, dma_addr)) {\n\t\t\tkfree(tf->data);\n\t\t\tkfree(tf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttf->frame.buffer_phy = dma_addr;\n\t\ttf->frame.callback = dma_test_tx_callback;\n\t\ttf->frame.sof = DMA_TEST_PDF_FRAME_START;\n\t\ttf->frame.eof = DMA_TEST_PDF_FRAME_END;\n\t\tINIT_LIST_HEAD(&tf->frame.list);\n\n\t\tdt->packets_sent++;\n\t\tdev_dbg(&dt->svc->dev, \"packet %u/%u sent\\n\", dt->packets_sent,\n\t\t\tdt->packets_to_send);\n\n\t\ttb_ring_tx(dt->tx_ring, &tf->frame);\n\t}\n\n\treturn 0;\n}\n\n#define DMA_TEST_DEBUGFS_ATTR(__fops, __get, __validate, __set)\t\\\nstatic int __fops ## _show(void *data, u64 *val)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct tb_service *svc = data;\t\t\t\t\\\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\t\\\n\tint ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tret = mutex_lock_interruptible(&dt->lock);\t\t\\\n\tif (ret)\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\\\n\t__get(dt, val);\t\t\t\t\t\t\\\n\tmutex_unlock(&dt->lock);\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int __fops ## _store(void *data, u64 val)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct tb_service *svc = data;\t\t\t\t\\\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\t\\\n\tint ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tret = __validate(val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\\\n\tret = mutex_lock_interruptible(&dt->lock);\t\t\\\n\tif (ret)\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\\\n\t__set(dt, val);\t\t\t\t\t\t\\\n\tmutex_unlock(&dt->lock);\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nDEFINE_DEBUGFS_ATTRIBUTE(__fops ## _fops, __fops ## _show,\t\\\n\t\t\t __fops ## _store, \"%llu\\n\")\n\nstatic void lanes_get(const struct dma_test *dt, u64 *val)\n{\n\t*val = dt->link_width;\n}\n\nstatic int lanes_validate(u64 val)\n{\n\treturn val > 2 ? -EINVAL : 0;\n}\n\nstatic void lanes_set(struct dma_test *dt, u64 val)\n{\n\tdt->link_width = val;\n}\nDMA_TEST_DEBUGFS_ATTR(lanes, lanes_get, lanes_validate, lanes_set);\n\nstatic void speed_get(const struct dma_test *dt, u64 *val)\n{\n\t*val = dt->link_speed;\n}\n\nstatic int speed_validate(u64 val)\n{\n\tswitch (val) {\n\tcase 40:\n\tcase 20:\n\tcase 10:\n\tcase 0:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void speed_set(struct dma_test *dt, u64 val)\n{\n\tdt->link_speed = val;\n}\nDMA_TEST_DEBUGFS_ATTR(speed, speed_get, speed_validate, speed_set);\n\nstatic void packets_to_receive_get(const struct dma_test *dt, u64 *val)\n{\n\t*val = dt->packets_to_receive;\n}\n\nstatic int packets_to_receive_validate(u64 val)\n{\n\treturn val > DMA_TEST_MAX_PACKETS ? -EINVAL : 0;\n}\n\nstatic void packets_to_receive_set(struct dma_test *dt, u64 val)\n{\n\tdt->packets_to_receive = val;\n}\nDMA_TEST_DEBUGFS_ATTR(packets_to_receive, packets_to_receive_get,\n\t\t      packets_to_receive_validate, packets_to_receive_set);\n\nstatic void packets_to_send_get(const struct dma_test *dt, u64 *val)\n{\n\t*val = dt->packets_to_send;\n}\n\nstatic int packets_to_send_validate(u64 val)\n{\n\treturn val > DMA_TEST_MAX_PACKETS ? -EINVAL : 0;\n}\n\nstatic void packets_to_send_set(struct dma_test *dt, u64 val)\n{\n\tdt->packets_to_send = val;\n}\nDMA_TEST_DEBUGFS_ATTR(packets_to_send, packets_to_send_get,\n\t\t      packets_to_send_validate, packets_to_send_set);\n\nstatic int dma_test_set_bonding(struct dma_test *dt)\n{\n\tswitch (dt->link_width) {\n\tcase 2:\n\t\treturn tb_xdomain_lane_bonding_enable(dt->xd);\n\tcase 1:\n\t\ttb_xdomain_lane_bonding_disable(dt->xd);\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic bool dma_test_validate_config(struct dma_test *dt)\n{\n\tif (!dt->packets_to_send && !dt->packets_to_receive)\n\t\treturn false;\n\tif (dt->packets_to_send && dt->packets_to_receive &&\n\t    dt->packets_to_send != dt->packets_to_receive)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void dma_test_check_errors(struct dma_test *dt, int ret)\n{\n\tif (!dt->error_code) {\n\t\tif (dt->link_speed && dt->xd->link_speed != dt->link_speed) {\n\t\t\tdt->error_code = DMA_TEST_SPEED_ERROR;\n\t\t} else if (dt->link_width) {\n\t\t\tconst struct tb_xdomain *xd = dt->xd;\n\n\t\t\tif ((dt->link_width == 1 && xd->link_width != TB_LINK_WIDTH_SINGLE) ||\n\t\t\t    (dt->link_width == 2 && xd->link_width < TB_LINK_WIDTH_DUAL))\n\t\t\t\tdt->error_code = DMA_TEST_WIDTH_ERROR;\n\t\t} else if (dt->packets_to_send != dt->packets_sent ||\n\t\t\t dt->packets_to_receive != dt->packets_received ||\n\t\t\t dt->crc_errors || dt->buffer_overflow_errors) {\n\t\t\tdt->error_code = DMA_TEST_PACKET_ERROR;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdt->result = DMA_TEST_FAIL;\n}\n\nstatic int test_store(void *data, u64 val)\n{\n\tstruct tb_service *svc = data;\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\n\tint ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&dt->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tdt->packets_sent = 0;\n\tdt->packets_received = 0;\n\tdt->crc_errors = 0;\n\tdt->buffer_overflow_errors = 0;\n\tdt->result = DMA_TEST_SUCCESS;\n\tdt->error_code = DMA_TEST_NO_ERROR;\n\n\tdev_dbg(&svc->dev, \"DMA test starting\\n\");\n\tif (dt->link_speed)\n\t\tdev_dbg(&svc->dev, \"link_speed: %u Gb/s\\n\", dt->link_speed);\n\tif (dt->link_width)\n\t\tdev_dbg(&svc->dev, \"link_width: %u\\n\", dt->link_width);\n\tdev_dbg(&svc->dev, \"packets_to_send: %u\\n\", dt->packets_to_send);\n\tdev_dbg(&svc->dev, \"packets_to_receive: %u\\n\", dt->packets_to_receive);\n\n\tif (!dma_test_validate_config(dt)) {\n\t\tdev_err(&svc->dev, \"invalid test configuration\\n\");\n\t\tdt->error_code = DMA_TEST_CONFIG_ERROR;\n\t\tgoto out_unlock;\n\t}\n\n\tret = dma_test_set_bonding(dt);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to set lanes\\n\");\n\t\tdt->error_code = DMA_TEST_BONDING_ERROR;\n\t\tgoto out_unlock;\n\t}\n\n\tret = dma_test_start_rings(dt);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to enable DMA rings\\n\");\n\t\tdt->error_code = DMA_TEST_DMA_ERROR;\n\t\tgoto out_unlock;\n\t}\n\n\tif (dt->packets_to_receive) {\n\t\treinit_completion(&dt->complete);\n\t\tret = dma_test_submit_rx(dt, dt->packets_to_receive);\n\t\tif (ret) {\n\t\t\tdev_err(&svc->dev, \"failed to submit receive buffers\\n\");\n\t\t\tdt->error_code = DMA_TEST_BUFFER_ERROR;\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\n\tif (dt->packets_to_send) {\n\t\tret = dma_test_submit_tx(dt, dt->packets_to_send);\n\t\tif (ret) {\n\t\t\tdev_err(&svc->dev, \"failed to submit transmit buffers\\n\");\n\t\t\tdt->error_code = DMA_TEST_BUFFER_ERROR;\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\n\tif (dt->packets_to_receive) {\n\t\tret = wait_for_completion_interruptible(&dt->complete);\n\t\tif (ret) {\n\t\t\tdt->error_code = DMA_TEST_INTERRUPTED;\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\nout_stop:\n\tdma_test_stop_rings(dt);\nout_unlock:\n\tdma_test_check_errors(dt, ret);\n\tmutex_unlock(&dt->lock);\n\n\tdev_dbg(&svc->dev, \"DMA test %s\\n\", dma_test_result_names[dt->result]);\n\treturn ret;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(test_fops, NULL, test_store, \"%llu\\n\");\n\nstatic int status_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_service *svc = s->private;\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&dt->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(s, \"result: %s\\n\", dma_test_result_names[dt->result]);\n\tif (dt->result == DMA_TEST_NOT_RUN)\n\t\tgoto out_unlock;\n\n\tseq_printf(s, \"packets received: %u\\n\", dt->packets_received);\n\tseq_printf(s, \"packets sent: %u\\n\", dt->packets_sent);\n\tseq_printf(s, \"CRC errors: %u\\n\", dt->crc_errors);\n\tseq_printf(s, \"buffer overflow errors: %u\\n\",\n\t\t   dt->buffer_overflow_errors);\n\tseq_printf(s, \"error: %s\\n\", dma_test_error_names[dt->error_code]);\n\nout_unlock:\n\tmutex_unlock(&dt->lock);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(status);\n\nstatic void dma_test_debugfs_init(struct tb_service *svc)\n{\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\n\n\tdt->debugfs_dir = debugfs_create_dir(\"dma_test\", svc->debugfs_dir);\n\n\tdebugfs_create_file(\"lanes\", 0600, dt->debugfs_dir, svc, &lanes_fops);\n\tdebugfs_create_file(\"speed\", 0600, dt->debugfs_dir, svc, &speed_fops);\n\tdebugfs_create_file(\"packets_to_receive\", 0600, dt->debugfs_dir, svc,\n\t\t\t    &packets_to_receive_fops);\n\tdebugfs_create_file(\"packets_to_send\", 0600, dt->debugfs_dir, svc,\n\t\t\t    &packets_to_send_fops);\n\tdebugfs_create_file(\"status\", 0400, dt->debugfs_dir, svc, &status_fops);\n\tdebugfs_create_file(\"test\", 0200, dt->debugfs_dir, svc, &test_fops);\n}\n\nstatic int dma_test_probe(struct tb_service *svc, const struct tb_service_id *id)\n{\n\tstruct tb_xdomain *xd = tb_service_parent(svc);\n\tstruct dma_test *dt;\n\n\tdt = devm_kzalloc(&svc->dev, sizeof(*dt), GFP_KERNEL);\n\tif (!dt)\n\t\treturn -ENOMEM;\n\n\tdt->svc = svc;\n\tdt->xd = xd;\n\tmutex_init(&dt->lock);\n\tinit_completion(&dt->complete);\n\n\ttb_service_set_drvdata(svc, dt);\n\tdma_test_debugfs_init(svc);\n\n\treturn 0;\n}\n\nstatic void dma_test_remove(struct tb_service *svc)\n{\n\tstruct dma_test *dt = tb_service_get_drvdata(svc);\n\n\tmutex_lock(&dt->lock);\n\tdebugfs_remove_recursive(dt->debugfs_dir);\n\tmutex_unlock(&dt->lock);\n}\n\nstatic int __maybe_unused dma_test_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int __maybe_unused dma_test_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dma_test_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dma_test_suspend, dma_test_resume)\n};\n\nstatic const struct tb_service_id dma_test_ids[] = {\n\t{ TB_SERVICE(\"dma_test\", 1) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(tbsvc, dma_test_ids);\n\nstatic struct tb_service_driver dma_test_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"thunderbolt_dma_test\",\n\t\t.pm = &dma_test_pm_ops,\n\t},\n\t.probe = dma_test_probe,\n\t.remove = dma_test_remove,\n\t.id_table = dma_test_ids,\n};\n\nstatic int __init dma_test_init(void)\n{\n\tu64 data_value = DMA_TEST_DATA_PATTERN;\n\tint i, ret;\n\n\tdma_test_pattern = kmalloc(DMA_TEST_FRAME_SIZE, GFP_KERNEL);\n\tif (!dma_test_pattern)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <\tDMA_TEST_FRAME_SIZE / sizeof(data_value); i++)\n\t\t((u32 *)dma_test_pattern)[i] = data_value++;\n\n\tdma_test_dir = tb_property_create_dir(&dma_test_dir_uuid);\n\tif (!dma_test_dir) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pattern;\n\t}\n\n\ttb_property_add_immediate(dma_test_dir, \"prtcid\", 1);\n\ttb_property_add_immediate(dma_test_dir, \"prtcvers\", 1);\n\ttb_property_add_immediate(dma_test_dir, \"prtcrevs\", 0);\n\ttb_property_add_immediate(dma_test_dir, \"prtcstns\", 0);\n\n\tret = tb_register_property_dir(\"dma_test\", dma_test_dir);\n\tif (ret)\n\t\tgoto err_free_dir;\n\n\tret = tb_register_service_driver(&dma_test_driver);\n\tif (ret)\n\t\tgoto err_unregister_dir;\n\n\treturn 0;\n\nerr_unregister_dir:\n\ttb_unregister_property_dir(\"dma_test\", dma_test_dir);\nerr_free_dir:\n\ttb_property_free_dir(dma_test_dir);\nerr_free_pattern:\n\tkfree(dma_test_pattern);\n\n\treturn ret;\n}\nmodule_init(dma_test_init);\n\nstatic void __exit dma_test_exit(void)\n{\n\ttb_unregister_service_driver(&dma_test_driver);\n\ttb_unregister_property_dir(\"dma_test\", dma_test_dir);\n\ttb_property_free_dir(dma_test_dir);\n\tkfree(dma_test_pattern);\n}\nmodule_exit(dma_test_exit);\n\nMODULE_AUTHOR(\"Isaac Hazan <isaac.hazan@intel.com>\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Thunderbolt/USB4 DMA traffic test driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}