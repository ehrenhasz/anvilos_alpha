{
  "module_name": "tmu.c",
  "hash_id": "1e504f2501710de185b9bf7d3ba544bd26709537d0df5b8ca3223b871cc43eb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/tmu.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"tb.h\"\n\nstatic const unsigned int tmu_rates[] = {\n\t[TB_SWITCH_TMU_MODE_OFF] = 0,\n\t[TB_SWITCH_TMU_MODE_LOWRES] = 1000,\n\t[TB_SWITCH_TMU_MODE_HIFI_UNI] = 16,\n\t[TB_SWITCH_TMU_MODE_HIFI_BI] = 16,\n\t[TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI] = 16,\n};\n\nstatic const struct {\n\tunsigned int freq_meas_window;\n\tunsigned int avg_const;\n\tunsigned int delta_avg_const;\n\tunsigned int repl_timeout;\n\tunsigned int repl_threshold;\n\tunsigned int repl_n;\n\tunsigned int dirswitch_n;\n} tmu_params[] = {\n\t[TB_SWITCH_TMU_MODE_OFF] = { },\n\t[TB_SWITCH_TMU_MODE_LOWRES] = { 30, 4, },\n\t[TB_SWITCH_TMU_MODE_HIFI_UNI] = { 800, 8, },\n\t[TB_SWITCH_TMU_MODE_HIFI_BI] = { 800, 8, },\n\t[TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI] = {\n\t\t800, 4, 0, 3125, 25, 128, 255,\n\t},\n};\n\nstatic const char *tmu_mode_name(enum tb_switch_tmu_mode mode)\n{\n\tswitch (mode) {\n\tcase TB_SWITCH_TMU_MODE_OFF:\n\t\treturn \"off\";\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\t\treturn \"uni-directional, LowRes\";\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\treturn \"uni-directional, HiFi\";\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\treturn \"bi-directional, HiFi\";\n\tcase TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI:\n\t\treturn \"enhanced uni-directional, MedRes\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic bool tb_switch_tmu_enhanced_is_supported(const struct tb_switch *sw)\n{\n\treturn usb4_switch_version(sw) > 1;\n}\n\nstatic int tb_switch_set_tmu_mode_params(struct tb_switch *sw,\n\t\t\t\t\t enum tb_switch_tmu_mode mode)\n{\n\tu32 freq, avg, val;\n\tint ret;\n\n\tfreq = tmu_params[mode].freq_meas_window;\n\tavg = tmu_params[mode].avg_const;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_RTR_CS_0_FREQ_WIND_MASK;\n\tval |= FIELD_PREP(TMU_RTR_CS_0_FREQ_WIND_MASK, freq);\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t  sw->tmu.cap + TMU_RTR_CS_0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_15, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_RTR_CS_15_FREQ_AVG_MASK &\n\t\t~TMU_RTR_CS_15_DELAY_AVG_MASK &\n\t\t~TMU_RTR_CS_15_OFFSET_AVG_MASK &\n\t\t~TMU_RTR_CS_15_ERROR_AVG_MASK;\n\tval |=  FIELD_PREP(TMU_RTR_CS_15_FREQ_AVG_MASK, avg) |\n\t\tFIELD_PREP(TMU_RTR_CS_15_DELAY_AVG_MASK, avg) |\n\t\tFIELD_PREP(TMU_RTR_CS_15_OFFSET_AVG_MASK, avg) |\n\t\tFIELD_PREP(TMU_RTR_CS_15_ERROR_AVG_MASK, avg);\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_15, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb_switch_tmu_enhanced_is_supported(sw)) {\n\t\tu32 delta_avg = tmu_params[mode].delta_avg_const;\n\n\t\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t\t sw->tmu.cap + TMU_RTR_CS_18, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= ~TMU_RTR_CS_18_DELTA_AVG_CONST_MASK;\n\t\tval |= FIELD_PREP(TMU_RTR_CS_18_DELTA_AVG_CONST_MASK, delta_avg);\n\n\t\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t\t  sw->tmu.cap + TMU_RTR_CS_18, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic bool tb_switch_tmu_ucap_is_supported(struct tb_switch *sw)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_0, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & TMU_RTR_CS_0_UCAP);\n}\n\nstatic int tb_switch_tmu_rate_read(struct tb_switch *sw)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_3, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval >>= TMU_RTR_CS_3_TS_PACKET_INTERVAL_SHIFT;\n\treturn val;\n}\n\nstatic int tb_switch_tmu_rate_write(struct tb_switch *sw, int rate)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->tmu.cap + TMU_RTR_CS_3, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_RTR_CS_3_TS_PACKET_INTERVAL_MASK;\n\tval |= rate << TMU_RTR_CS_3_TS_PACKET_INTERVAL_SHIFT;\n\n\treturn tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t   sw->tmu.cap + TMU_RTR_CS_3, 1);\n}\n\nstatic int tb_port_tmu_write(struct tb_port *port, u8 offset, u32 mask,\n\t\t\t     u32 value)\n{\n\tu32 data;\n\tint ret;\n\n\tret = tb_port_read(port, &data, TB_CFG_PORT, port->cap_tmu + offset, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdata &= ~mask;\n\tdata |= value;\n\n\treturn tb_port_write(port, &data, TB_CFG_PORT,\n\t\t\t     port->cap_tmu + offset, 1);\n}\n\nstatic int tb_port_tmu_set_unidirectional(struct tb_port *port,\n\t\t\t\t\t  bool unidirectional)\n{\n\tu32 val;\n\n\tif (!port->sw->tmu.has_ucap)\n\t\treturn 0;\n\n\tval = unidirectional ? TMU_ADP_CS_3_UDM : 0;\n\treturn tb_port_tmu_write(port, TMU_ADP_CS_3, TMU_ADP_CS_3_UDM, val);\n}\n\nstatic inline int tb_port_tmu_unidirectional_disable(struct tb_port *port)\n{\n\treturn tb_port_tmu_set_unidirectional(port, false);\n}\n\nstatic inline int tb_port_tmu_unidirectional_enable(struct tb_port *port)\n{\n\treturn tb_port_tmu_set_unidirectional(port, true);\n}\n\nstatic bool tb_port_tmu_is_unidirectional(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_3, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn val & TMU_ADP_CS_3_UDM;\n}\n\nstatic bool tb_port_tmu_is_enhanced(struct tb_port *port)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_8, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn val & TMU_ADP_CS_8_EUDM;\n}\n\n \nstatic int tb_port_tmu_enhanced_enable(struct tb_port *port, bool enable)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!tb_switch_tmu_enhanced_is_supported(port->sw))\n\t\treturn 0;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tval |= TMU_ADP_CS_8_EUDM;\n\telse\n\t\tval &= ~TMU_ADP_CS_8_EUDM;\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_tmu + TMU_ADP_CS_8, 1);\n}\n\nstatic int tb_port_set_tmu_mode_params(struct tb_port *port,\n\t\t\t\t       enum tb_switch_tmu_mode mode)\n{\n\tu32 repl_timeout, repl_threshold, repl_n, dirswitch_n, val;\n\tint ret;\n\n\trepl_timeout = tmu_params[mode].repl_timeout;\n\trepl_threshold = tmu_params[mode].repl_threshold;\n\trepl_n = tmu_params[mode].repl_n;\n\tdirswitch_n = tmu_params[mode].dirswitch_n;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_ADP_CS_8_REPL_TIMEOUT_MASK;\n\tval &= ~TMU_ADP_CS_8_REPL_THRESHOLD_MASK;\n\tval |= FIELD_PREP(TMU_ADP_CS_8_REPL_TIMEOUT_MASK, repl_timeout);\n\tval |= FIELD_PREP(TMU_ADP_CS_8_REPL_THRESHOLD_MASK, repl_threshold);\n\n\tret = tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t    port->cap_tmu + TMU_ADP_CS_8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_9, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_ADP_CS_9_REPL_N_MASK;\n\tval &= ~TMU_ADP_CS_9_DIRSWITCH_N_MASK;\n\tval |= FIELD_PREP(TMU_ADP_CS_9_REPL_N_MASK, repl_n);\n\tval |= FIELD_PREP(TMU_ADP_CS_9_DIRSWITCH_N_MASK, dirswitch_n);\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_tmu + TMU_ADP_CS_9, 1);\n}\n\n \nstatic int tb_port_tmu_rate_write(struct tb_port *port, int rate)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!tb_switch_tmu_enhanced_is_supported(port->sw))\n\t\treturn 0;\n\n\tret = tb_port_read(port, &val, TB_CFG_PORT,\n\t\t\t   port->cap_tmu + TMU_ADP_CS_9, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TMU_ADP_CS_9_ADP_TS_INTERVAL_MASK;\n\tval |= FIELD_PREP(TMU_ADP_CS_9_ADP_TS_INTERVAL_MASK, rate);\n\n\treturn tb_port_write(port, &val, TB_CFG_PORT,\n\t\t\t     port->cap_tmu + TMU_ADP_CS_9, 1);\n}\n\nstatic int tb_port_tmu_time_sync(struct tb_port *port, bool time_sync)\n{\n\tu32 val = time_sync ? TMU_ADP_CS_6_DTS : 0;\n\n\treturn tb_port_tmu_write(port, TMU_ADP_CS_6, TMU_ADP_CS_6_DTS, val);\n}\n\nstatic int tb_port_tmu_time_sync_disable(struct tb_port *port)\n{\n\treturn tb_port_tmu_time_sync(port, true);\n}\n\nstatic int tb_port_tmu_time_sync_enable(struct tb_port *port)\n{\n\treturn tb_port_tmu_time_sync(port, false);\n}\n\nstatic int tb_switch_tmu_set_time_disruption(struct tb_switch *sw, bool set)\n{\n\tu32 val, offset, bit;\n\tint ret;\n\n\tif (tb_switch_is_usb4(sw)) {\n\t\toffset = sw->tmu.cap + TMU_RTR_CS_0;\n\t\tbit = TMU_RTR_CS_0_TD;\n\t} else {\n\t\toffset = sw->cap_vsec_tmu + TB_TIME_VSEC_3_CS_26;\n\t\tbit = TB_TIME_VSEC_3_CS_26_TD;\n\t}\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, offset, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\n\treturn tb_sw_write(sw, &val, TB_CFG_SWITCH, offset, 1);\n}\n\nstatic int tmu_mode_init(struct tb_switch *sw)\n{\n\tbool enhanced, ucap;\n\tint ret, rate;\n\n\tucap = tb_switch_tmu_ucap_is_supported(sw);\n\tif (ucap)\n\t\ttb_sw_dbg(sw, \"TMU: supports uni-directional mode\\n\");\n\tenhanced = tb_switch_tmu_enhanced_is_supported(sw);\n\tif (enhanced)\n\t\ttb_sw_dbg(sw, \"TMU: supports enhanced uni-directional mode\\n\");\n\n\tret = tb_switch_tmu_rate_read(sw);\n\tif (ret < 0)\n\t\treturn ret;\n\trate = ret;\n\n\t \n\tsw->tmu.mode = TB_SWITCH_TMU_MODE_OFF;\n\n\tif (tb_route(sw)) {\n\t\tstruct tb_port *up = tb_upstream_port(sw);\n\n\t\tif (enhanced && tb_port_tmu_is_enhanced(up)) {\n\t\t\tsw->tmu.mode = TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI;\n\t\t} else if (ucap && tb_port_tmu_is_unidirectional(up)) {\n\t\t\tif (tmu_rates[TB_SWITCH_TMU_MODE_LOWRES] == rate)\n\t\t\t\tsw->tmu.mode = TB_SWITCH_TMU_MODE_LOWRES;\n\t\t\telse if (tmu_rates[TB_SWITCH_TMU_MODE_HIFI_UNI] == rate)\n\t\t\t\tsw->tmu.mode = TB_SWITCH_TMU_MODE_HIFI_UNI;\n\t\t} else if (rate) {\n\t\t\tsw->tmu.mode = TB_SWITCH_TMU_MODE_HIFI_BI;\n\t\t}\n\t} else if (rate) {\n\t\tsw->tmu.mode = TB_SWITCH_TMU_MODE_HIFI_BI;\n\t}\n\n\t \n\tsw->tmu.mode_request = sw->tmu.mode;\n\tsw->tmu.has_ucap = ucap;\n\n\treturn 0;\n}\n\n \nint tb_switch_tmu_init(struct tb_switch *sw)\n{\n\tstruct tb_port *port;\n\tint ret;\n\n\tif (tb_switch_is_icm(sw))\n\t\treturn 0;\n\n\tret = tb_switch_find_cap(sw, TB_SWITCH_CAP_TMU);\n\tif (ret > 0)\n\t\tsw->tmu.cap = ret;\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tint cap;\n\n\t\tcap = tb_port_find_cap(port, TB_PORT_CAP_TIME1);\n\t\tif (cap > 0)\n\t\t\tport->cap_tmu = cap;\n\t}\n\n\tret = tmu_mode_init(sw);\n\tif (ret)\n\t\treturn ret;\n\n\ttb_sw_dbg(sw, \"TMU: current mode: %s\\n\", tmu_mode_name(sw->tmu.mode));\n\treturn 0;\n}\n\n \nint tb_switch_tmu_post_time(struct tb_switch *sw)\n{\n\tunsigned int post_time_high_offset, post_time_high = 0;\n\tunsigned int post_local_time_offset, post_time_offset;\n\tstruct tb_switch *root_switch = sw->tb->root_switch;\n\tu64 hi, mid, lo, local_time, post_time;\n\tint i, ret, retries = 100;\n\tu32 gm_local_time[3];\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tif (!tb_switch_is_usb4(sw))\n\t\treturn 0;\n\n\t \n\tif (!root_switch->tmu.cap)\n\t\treturn 0;\n\n\tret = tb_sw_read(root_switch, gm_local_time, TB_CFG_SWITCH,\n\t\t\t root_switch->tmu.cap + TMU_RTR_CS_1,\n\t\t\t ARRAY_SIZE(gm_local_time));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(gm_local_time); i++)\n\t\ttb_sw_dbg(root_switch, \"TMU: local_time[%d]=0x%08x\\n\", i,\n\t\t\t  gm_local_time[i]);\n\n\t \n\thi = gm_local_time[2] & TMU_RTR_CS_3_LOCAL_TIME_NS_MASK;\n\tmid = gm_local_time[1];\n\tlo = (gm_local_time[0] & TMU_RTR_CS_1_LOCAL_TIME_NS_MASK) >>\n\t\tTMU_RTR_CS_1_LOCAL_TIME_NS_SHIFT;\n\tlocal_time = hi << 48 | mid << 16 | lo;\n\n\t \n\tret = tb_switch_tmu_set_time_disruption(sw, true);\n\tif (ret)\n\t\treturn ret;\n\n\tpost_local_time_offset = sw->tmu.cap + TMU_RTR_CS_22;\n\tpost_time_offset = sw->tmu.cap + TMU_RTR_CS_24;\n\tpost_time_high_offset = sw->tmu.cap + TMU_RTR_CS_25;\n\n\t \n\tret = tb_sw_write(sw, &local_time, TB_CFG_SWITCH,\n\t\t\t  post_local_time_offset, 2);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tpost_time = 0xffffffff00000001ULL;\n\n\tret = tb_sw_write(sw, &post_time, TB_CFG_SWITCH, post_time_offset, 2);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_sw_write(sw, &post_time_high, TB_CFG_SWITCH,\n\t\t\t  post_time_high_offset, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdo {\n\t\tusleep_range(5, 10);\n\t\tret = tb_sw_read(sw, &post_time, TB_CFG_SWITCH,\n\t\t\t\t post_time_offset, 2);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} while (--retries && post_time);\n\n\tif (!retries) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\ttb_sw_dbg(sw, \"TMU: updated local time to %#llx\\n\", local_time);\n\nout:\n\ttb_switch_tmu_set_time_disruption(sw, false);\n\treturn ret;\n}\n\nstatic int disable_enhanced(struct tb_port *up, struct tb_port *down)\n{\n\tint ret;\n\n\t \n\ttb_port_tmu_rate_write(up, 0);\n\ttb_port_tmu_enhanced_enable(up, false);\n\n\tret = tb_port_tmu_rate_write(down, 0);\n\tif (ret)\n\t\treturn ret;\n\treturn tb_port_tmu_enhanced_enable(down, false);\n}\n\n \nint tb_switch_tmu_disable(struct tb_switch *sw)\n{\n\t \n\tif (sw->tmu.mode == TB_SWITCH_TMU_MODE_OFF)\n\t\treturn 0;\n\n\tif (tb_route(sw)) {\n\t\tstruct tb_port *down, *up;\n\t\tint ret;\n\n\t\tdown = tb_switch_downstream_port(sw);\n\t\tup = tb_upstream_port(sw);\n\t\t \n\t\tret = tb_switch_tmu_rate_write(sw, tmu_rates[TB_SWITCH_TMU_MODE_OFF]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttb_port_tmu_time_sync_disable(up);\n\t\tret = tb_port_tmu_time_sync_disable(down);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (sw->tmu.mode) {\n\t\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\t\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\t\t \n\t\t\ttb_port_tmu_unidirectional_disable(up);\n\t\t\tret = tb_port_tmu_unidirectional_disable(down);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI:\n\t\t\tret = disable_enhanced(up, down);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttb_switch_tmu_rate_write(sw, tmu_rates[TB_SWITCH_TMU_MODE_OFF]);\n\t}\n\n\tsw->tmu.mode = TB_SWITCH_TMU_MODE_OFF;\n\n\ttb_sw_dbg(sw, \"TMU: disabled\\n\");\n\treturn 0;\n}\n\n \nstatic void tb_switch_tmu_off(struct tb_switch *sw)\n{\n\tunsigned int rate = tmu_rates[TB_SWITCH_TMU_MODE_OFF];\n\tstruct tb_port *down, *up;\n\n\tdown = tb_switch_downstream_port(sw);\n\tup = tb_upstream_port(sw);\n\t \n\ttb_port_tmu_time_sync_disable(down);\n\ttb_port_tmu_time_sync_disable(up);\n\n\tswitch (sw->tmu.mode_request) {\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\ttb_switch_tmu_rate_write(tb_switch_parent(sw), rate);\n\t\tbreak;\n\tcase TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI:\n\t\tdisable_enhanced(up, down);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ttb_switch_tmu_rate_write(sw, rate);\n\n\ttb_switch_set_tmu_mode_params(sw, sw->tmu.mode);\n\ttb_port_tmu_unidirectional_disable(down);\n\ttb_port_tmu_unidirectional_disable(up);\n}\n\n \nstatic int tb_switch_tmu_enable_bidirectional(struct tb_switch *sw)\n{\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\tret = tb_port_tmu_unidirectional_disable(up);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_tmu_unidirectional_disable(down);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_switch_tmu_rate_write(sw, tmu_rates[TB_SWITCH_TMU_MODE_HIFI_BI]);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_time_sync_enable(up);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_time_sync_enable(down);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\ttb_switch_tmu_off(sw);\n\treturn ret;\n}\n\n \nstatic int tb_switch_tmu_disable_objections(struct tb_switch *sw)\n{\n\tstruct tb_port *up = tb_upstream_port(sw);\n\tu32 val;\n\tint ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->cap_vsec_tmu + TB_TIME_VSEC_3_CS_9, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~TB_TIME_VSEC_3_CS_9_TMU_OBJ_MASK;\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t  sw->cap_vsec_tmu + TB_TIME_VSEC_3_CS_9, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_port_tmu_write(up, TMU_ADP_CS_6,\n\t\t\t\t TMU_ADP_CS_6_DISABLE_TMU_OBJ_MASK,\n\t\t\t\t TMU_ADP_CS_6_DISABLE_TMU_OBJ_CL1 |\n\t\t\t\t TMU_ADP_CS_6_DISABLE_TMU_OBJ_CL2);\n}\n\n \nstatic int tb_switch_tmu_enable_unidirectional(struct tb_switch *sw)\n{\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\tret = tb_switch_tmu_rate_write(tb_switch_parent(sw),\n\t\t\t\t       tmu_rates[sw->tmu.mode_request]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_switch_set_tmu_mode_params(sw, sw->tmu.mode_request);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_port_tmu_unidirectional_enable(up);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_time_sync_enable(up);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_unidirectional_enable(down);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_time_sync_enable(down);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\ttb_switch_tmu_off(sw);\n\treturn ret;\n}\n\n \nstatic int tb_switch_tmu_enable_enhanced(struct tb_switch *sw)\n{\n\tunsigned int rate = tmu_rates[sw->tmu.mode_request];\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\t \n\tret = tb_switch_set_tmu_mode_params(sw, sw->tmu.mode_request);\n\tif (ret)\n\t\treturn ret;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\tret = tb_port_set_tmu_mode_params(up, sw->tmu.mode_request);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_rate_write(up, rate);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_enhanced_enable(up, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_set_tmu_mode_params(down, sw->tmu.mode_request);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_rate_write(down, rate);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_enhanced_enable(down, true);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\ttb_switch_tmu_off(sw);\n\treturn ret;\n}\n\nstatic void tb_switch_tmu_change_mode_prev(struct tb_switch *sw)\n{\n\tunsigned int rate = tmu_rates[sw->tmu.mode];\n\tstruct tb_port *down, *up;\n\n\tdown = tb_switch_downstream_port(sw);\n\tup = tb_upstream_port(sw);\n\t \n\tswitch (sw->tmu.mode) {\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\ttb_port_tmu_set_unidirectional(down, true);\n\t\ttb_switch_tmu_rate_write(tb_switch_parent(sw), rate);\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\ttb_port_tmu_set_unidirectional(down, false);\n\t\ttb_switch_tmu_rate_write(sw, rate);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttb_switch_set_tmu_mode_params(sw, sw->tmu.mode);\n\n\tswitch (sw->tmu.mode) {\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\ttb_port_tmu_set_unidirectional(up, true);\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\ttb_port_tmu_set_unidirectional(up, false);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int tb_switch_tmu_change_mode(struct tb_switch *sw)\n{\n\tunsigned int rate = tmu_rates[sw->tmu.mode_request];\n\tstruct tb_port *up, *down;\n\tint ret;\n\n\tup = tb_upstream_port(sw);\n\tdown = tb_switch_downstream_port(sw);\n\n\t \n\tswitch (sw->tmu.mode_request) {\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\tret = tb_port_tmu_set_unidirectional(down, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = tb_switch_tmu_rate_write(tb_switch_parent(sw), rate);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\tret = tb_port_tmu_set_unidirectional(down, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = tb_switch_tmu_rate_write(sw, rate);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tret = tb_switch_set_tmu_mode_params(sw, sw->tmu.mode_request);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (sw->tmu.mode_request) {\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\tret = tb_port_tmu_set_unidirectional(up, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\tret = tb_port_tmu_set_unidirectional(up, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tret = tb_port_tmu_time_sync_enable(down);\n\tif (ret)\n\t\tgoto out;\n\n\tret = tb_port_tmu_time_sync_enable(up);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\ttb_switch_tmu_change_mode_prev(sw);\n\treturn ret;\n}\n\n \nint tb_switch_tmu_enable(struct tb_switch *sw)\n{\n\tint ret;\n\n\tif (tb_switch_tmu_is_enabled(sw))\n\t\treturn 0;\n\n\tif (tb_switch_is_titan_ridge(sw) &&\n\t    (sw->tmu.mode_request == TB_SWITCH_TMU_MODE_LOWRES ||\n\t     sw->tmu.mode_request == TB_SWITCH_TMU_MODE_HIFI_UNI)) {\n\t\tret = tb_switch_tmu_disable_objections(sw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = tb_switch_tmu_set_time_disruption(sw, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb_route(sw)) {\n\t\t \n\t\tif (sw->tmu.mode == TB_SWITCH_TMU_MODE_OFF) {\n\t\t\tswitch (sw->tmu.mode_request) {\n\t\t\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\t\t\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\t\t\tret = tb_switch_tmu_enable_unidirectional(sw);\n\t\t\t\tbreak;\n\n\t\t\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\t\t\tret = tb_switch_tmu_enable_bidirectional(sw);\n\t\t\t\tbreak;\n\t\t\tcase TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI:\n\t\t\t\tret = tb_switch_tmu_enable_enhanced(sw);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (sw->tmu.mode == TB_SWITCH_TMU_MODE_LOWRES ||\n\t\t\t   sw->tmu.mode == TB_SWITCH_TMU_MODE_HIFI_UNI ||\n\t\t\t   sw->tmu.mode == TB_SWITCH_TMU_MODE_HIFI_BI) {\n\t\t\tret = tb_switch_tmu_change_mode(sw);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tret = tb_switch_tmu_rate_write(sw, tmu_rates[sw->tmu.mode_request]);\n\t}\n\n\tif (ret) {\n\t\ttb_sw_warn(sw, \"TMU: failed to enable mode %s: %d\\n\",\n\t\t\t   tmu_mode_name(sw->tmu.mode_request), ret);\n\t} else {\n\t\tsw->tmu.mode = sw->tmu.mode_request;\n\t\ttb_sw_dbg(sw, \"TMU: mode set to: %s\\n\", tmu_mode_name(sw->tmu.mode));\n\t}\n\n\treturn tb_switch_tmu_set_time_disruption(sw, false);\n}\n\n \nint tb_switch_tmu_configure(struct tb_switch *sw, enum tb_switch_tmu_mode mode)\n{\n\tswitch (mode) {\n\tcase TB_SWITCH_TMU_MODE_OFF:\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_LOWRES:\n\tcase TB_SWITCH_TMU_MODE_HIFI_UNI:\n\t\tif (!sw->tmu.has_ucap)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_HIFI_BI:\n\t\tbreak;\n\n\tcase TB_SWITCH_TMU_MODE_MEDRES_ENHANCED_UNI: {\n\t\tconst struct tb_switch *parent_sw = tb_switch_parent(sw);\n\n\t\tif (!parent_sw || !tb_switch_tmu_enhanced_is_supported(parent_sw))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!tb_switch_tmu_enhanced_is_supported(sw))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\ttb_sw_warn(sw, \"TMU: unsupported mode %u\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sw->tmu.mode_request != mode) {\n\t\ttb_sw_dbg(sw, \"TMU: mode change %s -> %s requested\\n\",\n\t\t\t  tmu_mode_name(sw->tmu.mode), tmu_mode_name(mode));\n\t\tsw->tmu.mode_request = mode;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}