{
  "module_name": "eeprom.c",
  "hash_id": "1a70dd508b0efff6714ff5457afb12a9956975783d6c58edd2254c687ad8e910",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include \"tb.h\"\n\n \nstatic int tb_eeprom_ctl_write(struct tb_switch *sw, struct tb_eeprom_ctl *ctl)\n{\n\treturn tb_sw_write(sw, ctl, TB_CFG_SWITCH, sw->cap_plug_events + ROUTER_CS_4, 1);\n}\n\n \nstatic int tb_eeprom_ctl_read(struct tb_switch *sw, struct tb_eeprom_ctl *ctl)\n{\n\treturn tb_sw_read(sw, ctl, TB_CFG_SWITCH, sw->cap_plug_events + ROUTER_CS_4, 1);\n}\n\nenum tb_eeprom_transfer {\n\tTB_EEPROM_IN,\n\tTB_EEPROM_OUT,\n};\n\n \nstatic int tb_eeprom_active(struct tb_switch *sw, bool enable)\n{\n\tstruct tb_eeprom_ctl ctl;\n\tint res = tb_eeprom_ctl_read(sw, &ctl);\n\tif (res)\n\t\treturn res;\n\tif (enable) {\n\t\tctl.bit_banging_enable = 1;\n\t\tres = tb_eeprom_ctl_write(sw, &ctl);\n\t\tif (res)\n\t\t\treturn res;\n\t\tctl.fl_cs = 0;\n\t\treturn tb_eeprom_ctl_write(sw, &ctl);\n\t} else {\n\t\tctl.fl_cs = 1;\n\t\tres = tb_eeprom_ctl_write(sw, &ctl);\n\t\tif (res)\n\t\t\treturn res;\n\t\tctl.bit_banging_enable = 0;\n\t\treturn tb_eeprom_ctl_write(sw, &ctl);\n\t}\n}\n\n \nstatic int tb_eeprom_transfer(struct tb_switch *sw, struct tb_eeprom_ctl *ctl,\n\t\t\t      enum tb_eeprom_transfer direction)\n{\n\tint res;\n\tif (direction == TB_EEPROM_OUT) {\n\t\tres = tb_eeprom_ctl_write(sw, ctl);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\tctl->fl_sk = 1;\n\tres = tb_eeprom_ctl_write(sw, ctl);\n\tif (res)\n\t\treturn res;\n\tif (direction == TB_EEPROM_IN) {\n\t\tres = tb_eeprom_ctl_read(sw, ctl);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\tctl->fl_sk = 0;\n\treturn tb_eeprom_ctl_write(sw, ctl);\n}\n\n \nstatic int tb_eeprom_out(struct tb_switch *sw, u8 val)\n{\n\tstruct tb_eeprom_ctl ctl;\n\tint i;\n\tint res = tb_eeprom_ctl_read(sw, &ctl);\n\tif (res)\n\t\treturn res;\n\tfor (i = 0; i < 8; i++) {\n\t\tctl.fl_di = val & 0x80;\n\t\tres = tb_eeprom_transfer(sw, &ctl, TB_EEPROM_OUT);\n\t\tif (res)\n\t\t\treturn res;\n\t\tval <<= 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int tb_eeprom_in(struct tb_switch *sw, u8 *val)\n{\n\tstruct tb_eeprom_ctl ctl;\n\tint i;\n\tint res = tb_eeprom_ctl_read(sw, &ctl);\n\tif (res)\n\t\treturn res;\n\t*val = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\t*val <<= 1;\n\t\tres = tb_eeprom_transfer(sw, &ctl, TB_EEPROM_IN);\n\t\tif (res)\n\t\t\treturn res;\n\t\t*val |= ctl.fl_do;\n\t}\n\treturn 0;\n}\n\n \nstatic int tb_eeprom_get_drom_offset(struct tb_switch *sw, u16 *offset)\n{\n\tstruct tb_cap_plug_events cap;\n\tint res;\n\n\tif (!sw->cap_plug_events) {\n\t\ttb_sw_warn(sw, \"no TB_CAP_PLUG_EVENTS, cannot read eeprom\\n\");\n\t\treturn -ENODEV;\n\t}\n\tres = tb_sw_read(sw, &cap, TB_CFG_SWITCH, sw->cap_plug_events,\n\t\t\t     sizeof(cap) / 4);\n\tif (res)\n\t\treturn res;\n\n\tif (!cap.eeprom_ctl.present || cap.eeprom_ctl.not_present) {\n\t\ttb_sw_warn(sw, \"no NVM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cap.drom_offset > 0xffff) {\n\t\ttb_sw_warn(sw, \"drom offset is larger than 0xffff: %#x\\n\",\n\t\t\t\tcap.drom_offset);\n\t\treturn -ENXIO;\n\t}\n\t*offset = cap.drom_offset;\n\treturn 0;\n}\n\n \nstatic int tb_eeprom_read_n(struct tb_switch *sw, u16 offset, u8 *val,\n\t\tsize_t count)\n{\n\tu16 drom_offset;\n\tint i, res;\n\n\tres = tb_eeprom_get_drom_offset(sw, &drom_offset);\n\tif (res)\n\t\treturn res;\n\n\toffset += drom_offset;\n\n\tres = tb_eeprom_active(sw, true);\n\tif (res)\n\t\treturn res;\n\tres = tb_eeprom_out(sw, 3);\n\tif (res)\n\t\treturn res;\n\tres = tb_eeprom_out(sw, offset >> 8);\n\tif (res)\n\t\treturn res;\n\tres = tb_eeprom_out(sw, offset);\n\tif (res)\n\t\treturn res;\n\tfor (i = 0; i < count; i++) {\n\t\tres = tb_eeprom_in(sw, val + i);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn tb_eeprom_active(sw, false);\n}\n\nstatic u8 tb_crc8(u8 *data, int len)\n{\n\tint i, j;\n\tu8 val = 0xff;\n\tfor (i = 0; i < len; i++) {\n\t\tval ^= data[i];\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tval = (val << 1) ^ ((val & 0x80) ? 7 : 0);\n\t}\n\treturn val;\n}\n\nstatic u32 tb_crc32(void *data, size_t len)\n{\n\treturn ~__crc32c_le(~0, data, len);\n}\n\n#define TB_DROM_DATA_START\t\t13\n#define TB_DROM_HEADER_SIZE\t\t22\n#define USB4_DROM_HEADER_SIZE\t\t16\n\nstruct tb_drom_header {\n\t \n\tu8 uid_crc8;  \n\t \n\tu64 uid;\n\t \n\tu32 data_crc32;  \n\t \n\tu8 device_rom_revision;  \n\tu16 data_len:12;\n\tu8 reserved:4;\n\t \n\tu16 vendor_id;\n\tu16 model_id;\n\tu8 model_rev;\n\tu8 eeprom_rev;\n} __packed;\n\nenum tb_drom_entry_type {\n\t \n\tTB_DROM_ENTRY_GENERIC = 0U,\n\tTB_DROM_ENTRY_PORT,\n};\n\nstruct tb_drom_entry_header {\n\tu8 len;\n\tu8 index:6;\n\tbool port_disabled:1;  \n\tenum tb_drom_entry_type type:1;\n} __packed;\n\nstruct tb_drom_entry_generic {\n\tstruct tb_drom_entry_header header;\n\tu8 data[];\n} __packed;\n\nstruct tb_drom_entry_port {\n\t \n\tstruct tb_drom_entry_header header;\n\t \n\tu8 dual_link_port_rid:4;\n\tu8 link_nr:1;\n\tu8 unknown1:2;\n\tbool has_dual_link_port:1;\n\n\t \n\tu8 dual_link_port_nr:6;\n\tu8 unknown2:2;\n\n\t \n\tu8 micro2:4;\n\tu8 micro1:4;\n\tu8 micro3;\n\n\t \n\tu8 peer_port_rid:4;\n\tu8 unknown3:3;\n\tbool has_peer_port:1;\n\tu8 peer_port_nr:6;\n\tu8 unknown4:2;\n} __packed;\n\n \nstruct tb_drom_entry_desc {\n\tstruct tb_drom_entry_header header;\n\tu16 bcdUSBSpec;\n\tu16 idVendor;\n\tu16 idProduct;\n\tu16 bcdProductFWRevision;\n\tu32 TID;\n\tu8 productHWRevision;\n};\n\n \nint tb_drom_read_uid_only(struct tb_switch *sw, u64 *uid)\n{\n\tu8 data[9];\n\tu8 crc;\n\tint res;\n\n\t \n\tres = tb_eeprom_read_n(sw, 0, data, 9);\n\tif (res)\n\t\treturn res;\n\n\tcrc = tb_crc8(data + 1, 8);\n\tif (crc != data[0]) {\n\t\ttb_sw_warn(sw, \"uid crc8 mismatch (expected: %#x, got: %#x)\\n\",\n\t\t\t\tdata[0], crc);\n\t\treturn -EIO;\n\t}\n\n\t*uid = *(u64 *)(data+1);\n\treturn 0;\n}\n\nstatic int tb_drom_parse_entry_generic(struct tb_switch *sw,\n\t\tstruct tb_drom_entry_header *header)\n{\n\tconst struct tb_drom_entry_generic *entry =\n\t\t(const struct tb_drom_entry_generic *)header;\n\n\tswitch (header->index) {\n\tcase 1:\n\t\t \n\t\tsw->vendor_name = kstrndup(entry->data,\n\t\t\theader->len - sizeof(*header), GFP_KERNEL);\n\t\tif (!sw->vendor_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\n\tcase 2:\n\t\tsw->device_name = kstrndup(entry->data,\n\t\t\theader->len - sizeof(*header), GFP_KERNEL);\n\t\tif (!sw->device_name)\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase 9: {\n\t\tconst struct tb_drom_entry_desc *desc =\n\t\t\t(const struct tb_drom_entry_desc *)entry;\n\n\t\tif (!sw->vendor && !sw->device) {\n\t\t\tsw->vendor = desc->idVendor;\n\t\t\tsw->device = desc->idProduct;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tb_drom_parse_entry_port(struct tb_switch *sw,\n\t\t\t\t    struct tb_drom_entry_header *header)\n{\n\tstruct tb_port *port;\n\tint res;\n\tenum tb_port_type type;\n\n\t \n\tif (header->index > sw->config.max_port_number) {\n\t\tdev_info_once(&sw->dev, \"ignoring unnecessary extra entries in DROM\\n\");\n\t\treturn 0;\n\t}\n\n\tport = &sw->ports[header->index];\n\tport->disabled = header->port_disabled;\n\tif (port->disabled)\n\t\treturn 0;\n\n\tres = tb_port_read(port, &type, TB_CFG_PORT, 2, 1);\n\tif (res)\n\t\treturn res;\n\ttype &= 0xffffff;\n\n\tif (type == TB_TYPE_PORT) {\n\t\tstruct tb_drom_entry_port *entry = (void *) header;\n\t\tif (header->len != sizeof(*entry)) {\n\t\t\ttb_sw_warn(sw,\n\t\t\t\t\"port entry has size %#x (expected %#zx)\\n\",\n\t\t\t\theader->len, sizeof(struct tb_drom_entry_port));\n\t\t\treturn -EIO;\n\t\t}\n\t\tport->link_nr = entry->link_nr;\n\t\tif (entry->has_dual_link_port)\n\t\t\tport->dual_link_port =\n\t\t\t\t&port->sw->ports[entry->dual_link_port_nr];\n\t}\n\treturn 0;\n}\n\n \nstatic int tb_drom_parse_entries(struct tb_switch *sw, size_t header_size)\n{\n\tstruct tb_drom_header *header = (void *) sw->drom;\n\tu16 pos = header_size;\n\tu16 drom_size = header->data_len + TB_DROM_DATA_START;\n\tint res;\n\n\twhile (pos < drom_size) {\n\t\tstruct tb_drom_entry_header *entry = (void *) (sw->drom + pos);\n\t\tif (pos + 1 == drom_size || pos + entry->len > drom_size\n\t\t\t\t|| !entry->len) {\n\t\t\ttb_sw_warn(sw, \"DROM buffer overrun\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tswitch (entry->type) {\n\t\tcase TB_DROM_ENTRY_GENERIC:\n\t\t\tres = tb_drom_parse_entry_generic(sw, entry);\n\t\t\tbreak;\n\t\tcase TB_DROM_ENTRY_PORT:\n\t\t\tres = tb_drom_parse_entry_port(sw, entry);\n\t\t\tbreak;\n\t\t}\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tpos += entry->len;\n\t}\n\treturn 0;\n}\n\n \nstatic int tb_drom_copy_efi(struct tb_switch *sw, u16 *size)\n{\n\tstruct device *dev = &sw->tb->nhi->pdev->dev;\n\tint len, res;\n\n\tlen = device_property_count_u8(dev, \"ThunderboltDROM\");\n\tif (len < 0 || len < sizeof(struct tb_drom_header))\n\t\treturn -EINVAL;\n\n\tsw->drom = kmalloc(len, GFP_KERNEL);\n\tif (!sw->drom)\n\t\treturn -ENOMEM;\n\n\tres = device_property_read_u8_array(dev, \"ThunderboltDROM\", sw->drom,\n\t\t\t\t\t\t\t\t\tlen);\n\tif (res)\n\t\tgoto err;\n\n\t*size = ((struct tb_drom_header *)sw->drom)->data_len +\n\t\t\t\t\t\t\t  TB_DROM_DATA_START;\n\tif (*size > len)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tkfree(sw->drom);\n\tsw->drom = NULL;\n\treturn -EINVAL;\n}\n\nstatic int tb_drom_copy_nvm(struct tb_switch *sw, u16 *size)\n{\n\tu16 drom_offset;\n\tint ret;\n\n\tif (!sw->dma_port)\n\t\treturn -ENODEV;\n\n\tret = tb_eeprom_get_drom_offset(sw, &drom_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!drom_offset)\n\t\treturn -ENODEV;\n\n\tret = dma_port_flash_read(sw->dma_port, drom_offset + 14, size,\n\t\t\t\t  sizeof(*size));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*size += 1 + 8 + 4;\n\tsw->drom = kzalloc(*size, GFP_KERNEL);\n\tif (!sw->drom)\n\t\treturn -ENOMEM;\n\n\tret = dma_port_flash_read(sw->dma_port, drom_offset, sw->drom, *size);\n\tif (ret)\n\t\tgoto err_free;\n\n\t \n\ttb_drom_read_uid_only(sw, &sw->uid);\n\treturn 0;\n\nerr_free:\n\tkfree(sw->drom);\n\tsw->drom = NULL;\n\treturn ret;\n}\n\nstatic int usb4_copy_drom(struct tb_switch *sw, u16 *size)\n{\n\tint ret;\n\n\tret = usb4_switch_drom_read(sw, 14, size, sizeof(*size));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*size += 1 + 8 + 4;\n\tsw->drom = kzalloc(*size, GFP_KERNEL);\n\tif (!sw->drom)\n\t\treturn -ENOMEM;\n\n\tret = usb4_switch_drom_read(sw, 0, sw->drom, *size);\n\tif (ret) {\n\t\tkfree(sw->drom);\n\t\tsw->drom = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int tb_drom_bit_bang(struct tb_switch *sw, u16 *size)\n{\n\tint ret;\n\n\tret = tb_eeprom_read_n(sw, 14, (u8 *)size, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*size &= 0x3ff;\n\t*size += TB_DROM_DATA_START;\n\n\ttb_sw_dbg(sw, \"reading DROM (length: %#x)\\n\", *size);\n\tif (*size < sizeof(struct tb_drom_header)) {\n\t\ttb_sw_warn(sw, \"DROM too small, aborting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsw->drom = kzalloc(*size, GFP_KERNEL);\n\tif (!sw->drom)\n\t\treturn -ENOMEM;\n\n\tret = tb_eeprom_read_n(sw, 0, sw->drom, *size);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tkfree(sw->drom);\n\tsw->drom = NULL;\n\treturn ret;\n}\n\nstatic int tb_drom_parse_v1(struct tb_switch *sw)\n{\n\tconst struct tb_drom_header *header =\n\t\t(const struct tb_drom_header *)sw->drom;\n\tu32 crc;\n\n\tcrc = tb_crc8((u8 *) &header->uid, 8);\n\tif (crc != header->uid_crc8) {\n\t\ttb_sw_warn(sw,\n\t\t\t\"DROM UID CRC8 mismatch (expected: %#x, got: %#x)\\n\",\n\t\t\theader->uid_crc8, crc);\n\t\treturn -EIO;\n\t}\n\tif (!sw->uid)\n\t\tsw->uid = header->uid;\n\tsw->vendor = header->vendor_id;\n\tsw->device = header->model_id;\n\n\tcrc = tb_crc32(sw->drom + TB_DROM_DATA_START, header->data_len);\n\tif (crc != header->data_crc32) {\n\t\ttb_sw_warn(sw,\n\t\t\t\"DROM data CRC32 mismatch (expected: %#x, got: %#x), continuing\\n\",\n\t\t\theader->data_crc32, crc);\n\t}\n\n\treturn tb_drom_parse_entries(sw, TB_DROM_HEADER_SIZE);\n}\n\nstatic int usb4_drom_parse(struct tb_switch *sw)\n{\n\tconst struct tb_drom_header *header =\n\t\t(const struct tb_drom_header *)sw->drom;\n\tu32 crc;\n\n\tcrc = tb_crc32(sw->drom + TB_DROM_DATA_START, header->data_len);\n\tif (crc != header->data_crc32) {\n\t\ttb_sw_warn(sw,\n\t\t\t   \"DROM data CRC32 mismatch (expected: %#x, got: %#x), continuing\\n\",\n\t\t\t   header->data_crc32, crc);\n\t}\n\n\treturn tb_drom_parse_entries(sw, USB4_DROM_HEADER_SIZE);\n}\n\nstatic int tb_drom_parse(struct tb_switch *sw, u16 size)\n{\n\tconst struct tb_drom_header *header = (const void *)sw->drom;\n\tint ret;\n\n\tif (header->data_len + TB_DROM_DATA_START != size) {\n\t\ttb_sw_warn(sw, \"DROM size mismatch\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\ttb_sw_dbg(sw, \"DROM version: %d\\n\", header->device_rom_revision);\n\n\tswitch (header->device_rom_revision) {\n\tcase 3:\n\t\tret = usb4_drom_parse(sw);\n\t\tbreak;\n\tdefault:\n\t\ttb_sw_warn(sw, \"DROM device_rom_revision %#x unknown\\n\",\n\t\t\t   header->device_rom_revision);\n\t\tfallthrough;\n\tcase 1:\n\t\tret = tb_drom_parse_v1(sw);\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\ttb_sw_warn(sw, \"parsing DROM failed\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree(sw->drom);\n\tsw->drom = NULL;\n\n\treturn ret;\n}\n\nstatic int tb_drom_host_read(struct tb_switch *sw)\n{\n\tu16 size;\n\n\tif (tb_switch_is_usb4(sw)) {\n\t\tusb4_switch_read_uid(sw, &sw->uid);\n\t\tif (!usb4_copy_drom(sw, &size))\n\t\t\treturn tb_drom_parse(sw, size);\n\t} else {\n\t\tif (!tb_drom_copy_efi(sw, &size))\n\t\t\treturn tb_drom_parse(sw, size);\n\n\t\tif (!tb_drom_copy_nvm(sw, &size))\n\t\t\treturn tb_drom_parse(sw, size);\n\n\t\ttb_drom_read_uid_only(sw, &sw->uid);\n\t}\n\n\treturn 0;\n}\n\nstatic int tb_drom_device_read(struct tb_switch *sw)\n{\n\tu16 size;\n\tint ret;\n\n\tif (tb_switch_is_usb4(sw)) {\n\t\tusb4_switch_read_uid(sw, &sw->uid);\n\t\tret = usb4_copy_drom(sw, &size);\n\t} else {\n\t\tret = tb_drom_bit_bang(sw, &size);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn tb_drom_parse(sw, size);\n}\n\n \nint tb_drom_read(struct tb_switch *sw)\n{\n\tif (sw->drom)\n\t\treturn 0;\n\n\tif (!tb_route(sw))\n\t\treturn tb_drom_host_read(sw);\n\treturn tb_drom_device_read(sw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}