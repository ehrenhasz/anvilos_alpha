{
  "module_name": "usb4_port.c",
  "hash_id": "64fc31cf3724fcf020bac3bda3e4e6cfc6e98f17a3e481f29e6e4148810e741a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/usb4_port.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/component.h>\n#include <linux/property.h>\n\n#include \"tb.h\"\n\nstatic int connector_bind(struct device *dev, struct device *connector, void *data)\n{\n\tint ret;\n\n\tret = sysfs_create_link(&dev->kobj, &connector->kobj, \"connector\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_link(&connector->kobj, &dev->kobj, dev_name(dev));\n\tif (ret)\n\t\tsysfs_remove_link(&dev->kobj, \"connector\");\n\n\treturn ret;\n}\n\nstatic void connector_unbind(struct device *dev, struct device *connector, void *data)\n{\n\tsysfs_remove_link(&connector->kobj, dev_name(dev));\n\tsysfs_remove_link(&dev->kobj, \"connector\");\n}\n\nstatic const struct component_ops connector_ops = {\n\t.bind = connector_bind,\n\t.unbind = connector_unbind,\n};\n\nstatic ssize_t link_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\tstruct tb_port *port = usb4->port;\n\tstruct tb *tb = port->sw->tb;\n\tconst char *link;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (tb_is_upstream_port(port))\n\t\tlink = port->sw->link_usb4 ? \"usb4\" : \"tbt\";\n\telse if (tb_port_has_remote(port))\n\t\tlink = port->remote->sw->link_usb4 ? \"usb4\" : \"tbt\";\n\telse if (port->xdomain)\n\t\tlink = port->xdomain->link_usb4 ? \"usb4\" : \"tbt\";\n\telse\n\t\tlink = \"none\";\n\n\tmutex_unlock(&tb->lock);\n\n\treturn sysfs_emit(buf, \"%s\\n\", link);\n}\nstatic DEVICE_ATTR_RO(link);\n\nstatic struct attribute *common_attrs[] = {\n\t&dev_attr_link.attr,\n\tNULL\n};\n\nstatic const struct attribute_group common_group = {\n\t.attrs = common_attrs,\n};\n\nstatic int usb4_port_offline(struct usb4_port *usb4)\n{\n\tstruct tb_port *port = usb4->port;\n\tint ret;\n\n\tret = tb_acpi_power_on_retimers(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb4_port_router_offline(port);\n\tif (ret) {\n\t\ttb_acpi_power_off_retimers(port);\n\t\treturn ret;\n\t}\n\n\tret = tb_retimer_scan(port, false);\n\tif (ret) {\n\t\tusb4_port_router_online(port);\n\t\ttb_acpi_power_off_retimers(port);\n\t}\n\n\treturn ret;\n}\n\nstatic void usb4_port_online(struct usb4_port *usb4)\n{\n\tstruct tb_port *port = usb4->port;\n\n\tusb4_port_router_online(port);\n\ttb_acpi_power_off_retimers(port);\n}\n\nstatic ssize_t offline_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", usb4->offline);\n}\n\nstatic ssize_t offline_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\tstruct tb_port *port = usb4->port;\n\tstruct tb *tb = port->sw->tb;\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(&usb4->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm;\n\t}\n\n\tif (val == usb4->offline)\n\t\tgoto out_unlock;\n\n\t \n\tif (tb_port_has_remote(port)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tif (val) {\n\t\tret = usb4_port_offline(usb4);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tusb4_port_online(usb4);\n\t\ttb_retimer_remove_all(port);\n\t}\n\n\tusb4->offline = val;\n\ttb_port_dbg(port, \"%s offline mode\\n\", val ? \"enter\" : \"exit\");\n\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm:\n\tpm_runtime_mark_last_busy(&usb4->dev);\n\tpm_runtime_put_autosuspend(&usb4->dev);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(offline);\n\nstatic ssize_t rescan_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\tstruct tb_port *port = usb4->port;\n\tstruct tb *tb = port->sw->tb;\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tpm_runtime_get_sync(&usb4->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm;\n\t}\n\n\t \n\tif (!usb4->offline) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\ttb_retimer_remove_all(port);\n\tret = tb_retimer_scan(port, true);\n\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm:\n\tpm_runtime_mark_last_busy(&usb4->dev);\n\tpm_runtime_put_autosuspend(&usb4->dev);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_WO(rescan);\n\nstatic struct attribute *service_attrs[] = {\n\t&dev_attr_offline.attr,\n\t&dev_attr_rescan.attr,\n\tNULL\n};\n\nstatic umode_t service_attr_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb4_port *usb4 = tb_to_usb4_port_device(dev);\n\n\t \n\treturn usb4->can_offline ? attr->mode : 0;\n}\n\nstatic const struct attribute_group service_group = {\n\t.attrs = service_attrs,\n\t.is_visible = service_attr_is_visible,\n};\n\nstatic const struct attribute_group *usb4_port_device_groups[] = {\n\t&common_group,\n\t&service_group,\n\tNULL\n};\n\nstatic void usb4_port_device_release(struct device *dev)\n{\n\tstruct usb4_port *usb4 = container_of(dev, struct usb4_port, dev);\n\n\tkfree(usb4);\n}\n\nstruct device_type usb4_port_device_type = {\n\t.name = \"usb4_port\",\n\t.groups = usb4_port_device_groups,\n\t.release = usb4_port_device_release,\n};\n\n \nstruct usb4_port *usb4_port_device_add(struct tb_port *port)\n{\n\tstruct usb4_port *usb4;\n\tint ret;\n\n\tusb4 = kzalloc(sizeof(*usb4), GFP_KERNEL);\n\tif (!usb4)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tusb4->port = port;\n\tusb4->dev.type = &usb4_port_device_type;\n\tusb4->dev.parent = &port->sw->dev;\n\tdev_set_name(&usb4->dev, \"usb4_port%d\", port->port);\n\n\tret = device_register(&usb4->dev);\n\tif (ret) {\n\t\tput_device(&usb4->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (dev_fwnode(&usb4->dev)) {\n\t\tret = component_add(&usb4->dev, &connector_ops);\n\t\tif (ret) {\n\t\t\tdev_err(&usb4->dev, \"failed to add component\\n\");\n\t\t\tdevice_unregister(&usb4->dev);\n\t\t}\n\t}\n\n\tif (!tb_is_upstream_port(port))\n\t\tdevice_set_wakeup_capable(&usb4->dev, true);\n\n\tpm_runtime_no_callbacks(&usb4->dev);\n\tpm_runtime_set_active(&usb4->dev);\n\tpm_runtime_enable(&usb4->dev);\n\tpm_runtime_set_autosuspend_delay(&usb4->dev, TB_AUTOSUSPEND_DELAY);\n\tpm_runtime_mark_last_busy(&usb4->dev);\n\tpm_runtime_use_autosuspend(&usb4->dev);\n\n\treturn usb4;\n}\n\n \nvoid usb4_port_device_remove(struct usb4_port *usb4)\n{\n\tif (dev_fwnode(&usb4->dev))\n\t\tcomponent_del(&usb4->dev, &connector_ops);\n\tdevice_unregister(&usb4->dev);\n}\n\n \nint usb4_port_device_resume(struct usb4_port *usb4)\n{\n\treturn usb4->offline ? usb4_port_offline(usb4) : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}