{
  "module_name": "lc.c",
  "hash_id": "ec03fdae2e71f577c1bf431a3dcf3ab482a8683f1110f3fa36c04e927c0b9699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/lc.c",
  "human_readable_source": "\n \n\n#include \"tb.h\"\n\n \nint tb_lc_read_uuid(struct tb_switch *sw, u32 *uuid)\n{\n\tif (!sw->cap_lc)\n\t\treturn -EINVAL;\n\treturn tb_sw_read(sw, uuid, TB_CFG_SWITCH, sw->cap_lc + TB_LC_FUSE, 4);\n}\n\nstatic int read_lc_desc(struct tb_switch *sw, u32 *desc)\n{\n\tif (!sw->cap_lc)\n\t\treturn -EINVAL;\n\treturn tb_sw_read(sw, desc, TB_CFG_SWITCH, sw->cap_lc + TB_LC_DESC, 1);\n}\n\nstatic int find_port_lc_cap(struct tb_port *port)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint start, phys, ret, size;\n\tu32 desc;\n\n\tret = read_lc_desc(sw, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstart = (desc & TB_LC_DESC_SIZE_MASK) >> TB_LC_DESC_SIZE_SHIFT;\n\tsize = (desc & TB_LC_DESC_PORT_SIZE_MASK) >> TB_LC_DESC_PORT_SIZE_SHIFT;\n\tphys = tb_phy_port_from_link(port->port);\n\n\treturn sw->cap_lc + start + phys * size;\n}\n\nstatic int tb_lc_set_port_configured(struct tb_port *port, bool configured)\n{\n\tbool upstream = tb_is_upstream_port(port);\n\tstruct tb_switch *sw = port->sw;\n\tu32 ctrl, lane;\n\tint cap, ret;\n\n\tif (sw->generation < 2)\n\t\treturn 0;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn cap;\n\n\tret = tb_sw_read(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (port->port % 2)\n\t\tlane = TB_LC_SX_CTRL_L1C;\n\telse\n\t\tlane = TB_LC_SX_CTRL_L2C;\n\n\tif (configured) {\n\t\tctrl |= lane;\n\t\tif (upstream)\n\t\t\tctrl |= TB_LC_SX_CTRL_UPSTREAM;\n\t} else {\n\t\tctrl &= ~lane;\n\t\tif (upstream)\n\t\t\tctrl &= ~TB_LC_SX_CTRL_UPSTREAM;\n\t}\n\n\treturn tb_sw_write(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n}\n\n \nint tb_lc_configure_port(struct tb_port *port)\n{\n\treturn tb_lc_set_port_configured(port, true);\n}\n\n \nvoid tb_lc_unconfigure_port(struct tb_port *port)\n{\n\ttb_lc_set_port_configured(port, false);\n}\n\nstatic int tb_lc_set_xdomain_configured(struct tb_port *port, bool configure)\n{\n\tstruct tb_switch *sw = port->sw;\n\tu32 ctrl, lane;\n\tint cap, ret;\n\n\tif (sw->generation < 2)\n\t\treturn 0;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn cap;\n\n\tret = tb_sw_read(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (port->port % 2)\n\t\tlane = TB_LC_SX_CTRL_L1D;\n\telse\n\t\tlane = TB_LC_SX_CTRL_L2D;\n\n\tif (configure)\n\t\tctrl |= lane;\n\telse\n\t\tctrl &= ~lane;\n\n\treturn tb_sw_write(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n}\n\n \nint tb_lc_configure_xdomain(struct tb_port *port)\n{\n\treturn tb_lc_set_xdomain_configured(port, true);\n}\n\n \nvoid tb_lc_unconfigure_xdomain(struct tb_port *port)\n{\n\ttb_lc_set_xdomain_configured(port, false);\n}\n\n \nint tb_lc_start_lane_initialization(struct tb_port *port)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint ret, cap;\n\tu32 ctrl;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tif (sw->generation < 2)\n\t\treturn 0;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn cap;\n\n\tret = tb_sw_read(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl |= TB_LC_SX_CTRL_SLI;\n\n\treturn tb_sw_write(sw, &ctrl, TB_CFG_SWITCH, cap + TB_LC_SX_CTRL, 1);\n}\n\n \nbool tb_lc_is_clx_supported(struct tb_port *port)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint cap, ret;\n\tu32 val;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn false;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, cap + TB_LC_LINK_ATTR, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & TB_LC_LINK_ATTR_CPS);\n}\n\n \nbool tb_lc_is_usb_plugged(struct tb_port *port)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint cap, ret;\n\tu32 val;\n\n\tif (sw->generation != 3)\n\t\treturn false;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn false;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, cap + TB_LC_CS_42, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & TB_LC_CS_42_USB_PLUGGED);\n}\n\n \nbool tb_lc_is_xhci_connected(struct tb_port *port)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint cap, ret;\n\tu32 val;\n\n\tif (sw->generation != 3)\n\t\treturn false;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn false;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, cap + TB_LC_LINK_REQ, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & TB_LC_LINK_REQ_XHCI_CONNECT);\n}\n\nstatic int __tb_lc_xhci_connect(struct tb_port *port, bool connect)\n{\n\tstruct tb_switch *sw = port->sw;\n\tint cap, ret;\n\tu32 val;\n\n\tif (sw->generation != 3)\n\t\treturn -EINVAL;\n\n\tcap = find_port_lc_cap(port);\n\tif (cap < 0)\n\t\treturn cap;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, cap + TB_LC_LINK_REQ, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (connect)\n\t\tval |= TB_LC_LINK_REQ_XHCI_CONNECT;\n\telse\n\t\tval &= ~TB_LC_LINK_REQ_XHCI_CONNECT;\n\n\treturn tb_sw_write(sw, &val, TB_CFG_SWITCH, cap + TB_LC_LINK_REQ, 1);\n}\n\n \nint tb_lc_xhci_connect(struct tb_port *port)\n{\n\tint ret;\n\n\tret = __tb_lc_xhci_connect(port, true);\n\tif (ret)\n\t\treturn ret;\n\n\ttb_port_dbg(port, \"xHCI connected\\n\");\n\treturn 0;\n}\n\n \nvoid tb_lc_xhci_disconnect(struct tb_port *port)\n{\n\t__tb_lc_xhci_connect(port, false);\n\ttb_port_dbg(port, \"xHCI disconnected\\n\");\n}\n\nstatic int tb_lc_set_wake_one(struct tb_switch *sw, unsigned int offset,\n\t\t\t      unsigned int flags)\n{\n\tu32 ctrl;\n\tint ret;\n\n\t \n\tret = tb_sw_read(sw, &ctrl, TB_CFG_SWITCH,\n\t\t\t offset + TB_LC_SX_CTRL, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl &= ~(TB_LC_SX_CTRL_WOC | TB_LC_SX_CTRL_WOD | TB_LC_SX_CTRL_WODPC |\n\t\t  TB_LC_SX_CTRL_WODPD | TB_LC_SX_CTRL_WOP | TB_LC_SX_CTRL_WOU4);\n\n\tif (flags & TB_WAKE_ON_CONNECT)\n\t\tctrl |= TB_LC_SX_CTRL_WOC | TB_LC_SX_CTRL_WOD;\n\tif (flags & TB_WAKE_ON_USB4)\n\t\tctrl |= TB_LC_SX_CTRL_WOU4;\n\tif (flags & TB_WAKE_ON_PCIE)\n\t\tctrl |= TB_LC_SX_CTRL_WOP;\n\tif (flags & TB_WAKE_ON_DP)\n\t\tctrl |= TB_LC_SX_CTRL_WODPC | TB_LC_SX_CTRL_WODPD;\n\n\treturn tb_sw_write(sw, &ctrl, TB_CFG_SWITCH, offset + TB_LC_SX_CTRL, 1);\n}\n\n \nint tb_lc_set_wake(struct tb_switch *sw, unsigned int flags)\n{\n\tint start, size, nlc, ret, i;\n\tu32 desc;\n\n\tif (sw->generation < 2)\n\t\treturn 0;\n\n\tif (!tb_route(sw))\n\t\treturn 0;\n\n\tret = read_lc_desc(sw, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnlc = desc & TB_LC_DESC_NLC_MASK;\n\tstart = (desc & TB_LC_DESC_SIZE_MASK) >> TB_LC_DESC_SIZE_SHIFT;\n\tsize = (desc & TB_LC_DESC_PORT_SIZE_MASK) >> TB_LC_DESC_PORT_SIZE_SHIFT;\n\n\t \n\tfor (i = 0; i < nlc; i++) {\n\t\tunsigned int offset = sw->cap_lc + start + i * size;\n\n\t\tret = tb_lc_set_wake_one(sw, offset, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint tb_lc_set_sleep(struct tb_switch *sw)\n{\n\tint start, size, nlc, ret, i;\n\tu32 desc;\n\n\tif (sw->generation < 2)\n\t\treturn 0;\n\n\tret = read_lc_desc(sw, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnlc = desc & TB_LC_DESC_NLC_MASK;\n\tstart = (desc & TB_LC_DESC_SIZE_MASK) >> TB_LC_DESC_SIZE_SHIFT;\n\tsize = (desc & TB_LC_DESC_PORT_SIZE_MASK) >> TB_LC_DESC_PORT_SIZE_SHIFT;\n\n\t \n\tfor (i = 0; i < nlc; i++) {\n\t\tunsigned int offset = sw->cap_lc + start + i * size;\n\t\tu32 ctrl;\n\n\t\tret = tb_sw_read(sw, &ctrl, TB_CFG_SWITCH,\n\t\t\t\t offset + TB_LC_SX_CTRL, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tctrl |= TB_LC_SX_CTRL_SLP;\n\t\tret = tb_sw_write(sw, &ctrl, TB_CFG_SWITCH,\n\t\t\t\t  offset + TB_LC_SX_CTRL, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nbool tb_lc_lane_bonding_possible(struct tb_switch *sw)\n{\n\tstruct tb_port *up;\n\tint cap, ret;\n\tu32 val;\n\n\tif (sw->generation < 2)\n\t\treturn false;\n\n\tup = tb_upstream_port(sw);\n\tcap = find_port_lc_cap(up);\n\tif (cap < 0)\n\t\treturn false;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH, cap + TB_LC_PORT_ATTR, 1);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(val & TB_LC_PORT_ATTR_BE);\n}\n\nstatic int tb_lc_dp_sink_from_port(const struct tb_switch *sw,\n\t\t\t\t   struct tb_port *in)\n{\n\tstruct tb_port *port;\n\n\t \n\ttb_switch_for_each_port(sw, port) {\n\t\tif (tb_port_is_dpin(port))\n\t\t\treturn in != port;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tb_lc_dp_sink_available(struct tb_switch *sw, int sink)\n{\n\tu32 val, alloc;\n\tint ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->cap_lc + TB_LC_SNK_ALLOCATION, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!sink) {\n\t\talloc = val & TB_LC_SNK_ALLOCATION_SNK0_MASK;\n\t\tif (!alloc || alloc == TB_LC_SNK_ALLOCATION_SNK0_CM)\n\t\t\treturn 0;\n\t} else {\n\t\talloc = (val & TB_LC_SNK_ALLOCATION_SNK1_MASK) >>\n\t\t\tTB_LC_SNK_ALLOCATION_SNK1_SHIFT;\n\t\tif (!alloc || alloc == TB_LC_SNK_ALLOCATION_SNK1_CM)\n\t\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}\n\n \nbool tb_lc_dp_sink_query(struct tb_switch *sw, struct tb_port *in)\n{\n\tint sink;\n\n\t \n\tif (sw->generation < 3)\n\t\treturn true;\n\n\tsink = tb_lc_dp_sink_from_port(sw, in);\n\tif (sink < 0)\n\t\treturn false;\n\n\treturn !tb_lc_dp_sink_available(sw, sink);\n}\n\n \nint tb_lc_dp_sink_alloc(struct tb_switch *sw, struct tb_port *in)\n{\n\tint ret, sink;\n\tu32 val;\n\n\tif (sw->generation < 3)\n\t\treturn 0;\n\n\tsink = tb_lc_dp_sink_from_port(sw, in);\n\tif (sink < 0)\n\t\treturn sink;\n\n\tret = tb_lc_dp_sink_available(sw, sink);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->cap_lc + TB_LC_SNK_ALLOCATION, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sink) {\n\t\tval &= ~TB_LC_SNK_ALLOCATION_SNK0_MASK;\n\t\tval |= TB_LC_SNK_ALLOCATION_SNK0_CM;\n\t} else {\n\t\tval &= ~TB_LC_SNK_ALLOCATION_SNK1_MASK;\n\t\tval |= TB_LC_SNK_ALLOCATION_SNK1_CM <<\n\t\t\tTB_LC_SNK_ALLOCATION_SNK1_SHIFT;\n\t}\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t  sw->cap_lc + TB_LC_SNK_ALLOCATION, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\ttb_port_dbg(in, \"sink %d allocated\\n\", sink);\n\treturn 0;\n}\n\n \nint tb_lc_dp_sink_dealloc(struct tb_switch *sw, struct tb_port *in)\n{\n\tint ret, sink;\n\tu32 val;\n\n\tif (sw->generation < 3)\n\t\treturn 0;\n\n\tsink = tb_lc_dp_sink_from_port(sw, in);\n\tif (sink < 0)\n\t\treturn sink;\n\n\t \n\tret = tb_lc_dp_sink_available(sw, sink);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tb_sw_read(sw, &val, TB_CFG_SWITCH,\n\t\t\t sw->cap_lc + TB_LC_SNK_ALLOCATION, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sink)\n\t\tval &= ~TB_LC_SNK_ALLOCATION_SNK0_MASK;\n\telse\n\t\tval &= ~TB_LC_SNK_ALLOCATION_SNK1_MASK;\n\n\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH,\n\t\t\t  sw->cap_lc + TB_LC_SNK_ALLOCATION, 1);\n\tif (ret)\n\t\treturn ret;\n\n\ttb_port_dbg(in, \"sink %d de-allocated\\n\", sink);\n\treturn 0;\n}\n\n \nint tb_lc_force_power(struct tb_switch *sw)\n{\n\tu32 in = 0xffff;\n\n\treturn tb_sw_write(sw, &in, TB_CFG_SWITCH, TB_LC_POWER, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}