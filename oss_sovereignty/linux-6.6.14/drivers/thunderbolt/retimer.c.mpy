{
  "module_name": "retimer.c",
  "hash_id": "7764d1badd10c56a6d023c6530eaa1db42b5e06d7ef198e7e178257a640ffddb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/retimer.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched/signal.h>\n\n#include \"sb_regs.h\"\n#include \"tb.h\"\n\n#define TB_MAX_RETIMER_INDEX\t6\n\n \nint tb_retimer_nvm_read(struct tb_retimer *rt, unsigned int address, void *buf,\n\t\t\tsize_t size)\n{\n\treturn usb4_port_retimer_nvm_read(rt->port, rt->index, address, buf, size);\n}\n\nstatic int nvm_read(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct tb_nvm *nvm = priv;\n\tstruct tb_retimer *rt = tb_to_retimer(nvm->dev);\n\tint ret;\n\n\tpm_runtime_get_sync(&rt->dev);\n\n\tif (!mutex_trylock(&rt->tb->lock)) {\n\t\tret = restart_syscall();\n\t\tgoto out;\n\t}\n\n\tret = tb_retimer_nvm_read(rt, offset, val, bytes);\n\tmutex_unlock(&rt->tb->lock);\n\nout:\n\tpm_runtime_mark_last_busy(&rt->dev);\n\tpm_runtime_put_autosuspend(&rt->dev);\n\n\treturn ret;\n}\n\nstatic int nvm_write(void *priv, unsigned int offset, void *val, size_t bytes)\n{\n\tstruct tb_nvm *nvm = priv;\n\tstruct tb_retimer *rt = tb_to_retimer(nvm->dev);\n\tint ret = 0;\n\n\tif (!mutex_trylock(&rt->tb->lock))\n\t\treturn restart_syscall();\n\n\tret = tb_nvm_write_buf(nvm, offset, val, bytes);\n\tmutex_unlock(&rt->tb->lock);\n\n\treturn ret;\n}\n\nstatic int tb_retimer_nvm_add(struct tb_retimer *rt)\n{\n\tstruct tb_nvm *nvm;\n\tint ret;\n\n\tnvm = tb_nvm_alloc(&rt->dev);\n\tif (IS_ERR(nvm)) {\n\t\tret = PTR_ERR(nvm) == -EOPNOTSUPP ? 0 : PTR_ERR(nvm);\n\t\tgoto err_nvm;\n\t}\n\n\tret = tb_nvm_read_version(nvm);\n\tif (ret)\n\t\tgoto err_nvm;\n\n\tret = tb_nvm_add_active(nvm, nvm_read);\n\tif (ret)\n\t\tgoto err_nvm;\n\n\tret = tb_nvm_add_non_active(nvm, nvm_write);\n\tif (ret)\n\t\tgoto err_nvm;\n\n\trt->nvm = nvm;\n\treturn 0;\n\nerr_nvm:\n\tdev_dbg(&rt->dev, \"NVM upgrade disabled\\n\");\n\tif (!IS_ERR(nvm))\n\t\ttb_nvm_free(nvm);\n\n\treturn ret;\n}\n\nstatic int tb_retimer_nvm_validate_and_write(struct tb_retimer *rt)\n{\n\tunsigned int image_size;\n\tconst u8 *buf;\n\tint ret;\n\n\tret = tb_nvm_validate(rt->nvm);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf = rt->nvm->buf_data_start;\n\timage_size = rt->nvm->buf_data_size;\n\n\tret = usb4_port_retimer_nvm_write(rt->port, rt->index, 0, buf,\n\t\t\t\t\t image_size);\n\tif (ret)\n\t\treturn ret;\n\n\trt->nvm->flushed = true;\n\treturn 0;\n}\n\nstatic int tb_retimer_nvm_authenticate(struct tb_retimer *rt, bool auth_only)\n{\n\tu32 status;\n\tint ret;\n\n\tif (auth_only) {\n\t\tret = usb4_port_retimer_nvm_set_offset(rt->port, rt->index, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = usb4_port_retimer_nvm_authenticate(rt->port, rt->index);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(100, 150);\n\n\t \n\tret = usb4_port_retimer_nvm_authenticate_status(rt->port, rt->index,\n\t\t\t\t\t\t\t&status);\n\tif (!ret) {\n\t\trt->auth_status = status;\n\t\treturn status ? -EINVAL : 0;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t device_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\n\treturn sysfs_emit(buf, \"%#x\\n\", rt->device);\n}\nstatic DEVICE_ATTR_RO(device);\n\nstatic ssize_t nvm_authenticate_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\tint ret;\n\n\tif (!mutex_trylock(&rt->tb->lock))\n\t\treturn restart_syscall();\n\n\tif (!rt->nvm)\n\t\tret = -EAGAIN;\n\telse if (rt->no_nvm_upgrade)\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tret = sysfs_emit(buf, \"%#x\\n\", rt->auth_status);\n\n\tmutex_unlock(&rt->tb->lock);\n\n\treturn ret;\n}\n\nstatic void tb_retimer_nvm_authenticate_status(struct tb_port *port, u32 *status)\n{\n\tint i;\n\n\ttb_port_dbg(port, \"reading NVM authentication status of retimers\\n\");\n\n\t \n\tfor (i = 1; i <= TB_MAX_RETIMER_INDEX; i++)\n\t\tusb4_port_retimer_nvm_authenticate_status(port, i, &status[i]);\n}\n\nstatic void tb_retimer_set_inbound_sbtx(struct tb_port *port)\n{\n\tint i;\n\n\t \n\tif (!usb4_port_device_is_offline(port->usb4))\n\t\treturn;\n\n\ttb_port_dbg(port, \"enabling sideband transactions\\n\");\n\n\tfor (i = 1; i <= TB_MAX_RETIMER_INDEX; i++)\n\t\tusb4_port_retimer_set_inbound_sbtx(port, i);\n}\n\nstatic void tb_retimer_unset_inbound_sbtx(struct tb_port *port)\n{\n\tint i;\n\n\t \n\tif (usb4_port_device_is_offline(port->usb4))\n\t\treturn;\n\n\ttb_port_dbg(port, \"disabling sideband transactions\\n\");\n\n\tfor (i = TB_MAX_RETIMER_INDEX; i >= 1; i--)\n\t\tusb4_port_retimer_unset_inbound_sbtx(port, i);\n}\n\nstatic ssize_t nvm_authenticate_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\tint val, ret;\n\n\tpm_runtime_get_sync(&rt->dev);\n\n\tif (!mutex_trylock(&rt->tb->lock)) {\n\t\tret = restart_syscall();\n\t\tgoto exit_rpm;\n\t}\n\n\tif (!rt->nvm) {\n\t\tret = -EAGAIN;\n\t\tgoto exit_unlock;\n\t}\n\n\tret = kstrtoint(buf, 10, &val);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\t \n\trt->auth_status = 0;\n\n\tif (val) {\n\t\t \n\t\ttb_retimer_set_inbound_sbtx(rt->port);\n\t\tif (val == AUTHENTICATE_ONLY) {\n\t\t\tret = tb_retimer_nvm_authenticate(rt, true);\n\t\t} else {\n\t\t\tif (!rt->nvm->flushed) {\n\t\t\t\tif (!rt->nvm->buf) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto exit_unlock;\n\t\t\t\t}\n\n\t\t\t\tret = tb_retimer_nvm_validate_and_write(rt);\n\t\t\t\tif (ret || val == WRITE_ONLY)\n\t\t\t\t\tgoto exit_unlock;\n\t\t\t}\n\t\t\tif (val == WRITE_AND_AUTHENTICATE)\n\t\t\t\tret = tb_retimer_nvm_authenticate(rt, false);\n\t\t}\n\t}\n\nexit_unlock:\n\tif (ret || val == WRITE_ONLY)\n\t\ttb_retimer_unset_inbound_sbtx(rt->port);\n\tmutex_unlock(&rt->tb->lock);\nexit_rpm:\n\tpm_runtime_mark_last_busy(&rt->dev);\n\tpm_runtime_put_autosuspend(&rt->dev);\n\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(nvm_authenticate);\n\nstatic ssize_t nvm_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\tint ret;\n\n\tif (!mutex_trylock(&rt->tb->lock))\n\t\treturn restart_syscall();\n\n\tif (!rt->nvm)\n\t\tret = -EAGAIN;\n\telse\n\t\tret = sysfs_emit(buf, \"%x.%x\\n\", rt->nvm->major, rt->nvm->minor);\n\n\tmutex_unlock(&rt->tb->lock);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(nvm_version);\n\nstatic ssize_t vendor_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\n\treturn sysfs_emit(buf, \"%#x\\n\", rt->vendor);\n}\nstatic DEVICE_ATTR_RO(vendor);\n\nstatic struct attribute *retimer_attrs[] = {\n\t&dev_attr_device.attr,\n\t&dev_attr_nvm_authenticate.attr,\n\t&dev_attr_nvm_version.attr,\n\t&dev_attr_vendor.attr,\n\tNULL\n};\n\nstatic const struct attribute_group retimer_group = {\n\t.attrs = retimer_attrs,\n};\n\nstatic const struct attribute_group *retimer_groups[] = {\n\t&retimer_group,\n\tNULL\n};\n\nstatic void tb_retimer_release(struct device *dev)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\n\tkfree(rt);\n}\n\nstruct device_type tb_retimer_type = {\n\t.name = \"thunderbolt_retimer\",\n\t.groups = retimer_groups,\n\t.release = tb_retimer_release,\n};\n\nstatic int tb_retimer_add(struct tb_port *port, u8 index, u32 auth_status)\n{\n\tstruct tb_retimer *rt;\n\tu32 vendor, device;\n\tint ret;\n\n\tret = usb4_port_retimer_read(port, index, USB4_SB_VENDOR_ID, &vendor,\n\t\t\t\t     sizeof(vendor));\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\ttb_port_warn(port, \"failed read retimer VendorId: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = usb4_port_retimer_read(port, index, USB4_SB_PRODUCT_ID, &device,\n\t\t\t\t     sizeof(device));\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\ttb_port_warn(port, \"failed read retimer ProductId: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = usb4_port_retimer_nvm_sector_size(port, index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\tif (!rt)\n\t\treturn -ENOMEM;\n\n\trt->index = index;\n\trt->vendor = vendor;\n\trt->device = device;\n\trt->auth_status = auth_status;\n\trt->port = port;\n\trt->tb = port->sw->tb;\n\n\trt->dev.parent = &port->usb4->dev;\n\trt->dev.bus = &tb_bus_type;\n\trt->dev.type = &tb_retimer_type;\n\tdev_set_name(&rt->dev, \"%s:%u.%u\", dev_name(&port->sw->dev),\n\t\t     port->port, index);\n\n\tret = device_register(&rt->dev);\n\tif (ret) {\n\t\tdev_err(&rt->dev, \"failed to register retimer: %d\\n\", ret);\n\t\tput_device(&rt->dev);\n\t\treturn ret;\n\t}\n\n\tret = tb_retimer_nvm_add(rt);\n\tif (ret) {\n\t\tdev_err(&rt->dev, \"failed to add NVM devices: %d\\n\", ret);\n\t\tdevice_unregister(&rt->dev);\n\t\treturn ret;\n\t}\n\n\tdev_info(&rt->dev, \"new retimer found, vendor=%#x device=%#x\\n\",\n\t\t rt->vendor, rt->device);\n\n\tpm_runtime_no_callbacks(&rt->dev);\n\tpm_runtime_set_active(&rt->dev);\n\tpm_runtime_enable(&rt->dev);\n\tpm_runtime_set_autosuspend_delay(&rt->dev, TB_AUTOSUSPEND_DELAY);\n\tpm_runtime_mark_last_busy(&rt->dev);\n\tpm_runtime_use_autosuspend(&rt->dev);\n\n\treturn 0;\n}\n\nstatic void tb_retimer_remove(struct tb_retimer *rt)\n{\n\tdev_info(&rt->dev, \"retimer disconnected\\n\");\n\ttb_nvm_free(rt->nvm);\n\tdevice_unregister(&rt->dev);\n}\n\nstruct tb_retimer_lookup {\n\tconst struct tb_port *port;\n\tu8 index;\n};\n\nstatic int retimer_match(struct device *dev, void *data)\n{\n\tconst struct tb_retimer_lookup *lookup = data;\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\n\treturn rt && rt->port == lookup->port && rt->index == lookup->index;\n}\n\nstatic struct tb_retimer *tb_port_find_retimer(struct tb_port *port, u8 index)\n{\n\tstruct tb_retimer_lookup lookup = { .port = port, .index = index };\n\tstruct device *dev;\n\n\tdev = device_find_child(&port->usb4->dev, &lookup, retimer_match);\n\tif (dev)\n\t\treturn tb_to_retimer(dev);\n\n\treturn NULL;\n}\n\n \nint tb_retimer_scan(struct tb_port *port, bool add)\n{\n\tu32 status[TB_MAX_RETIMER_INDEX + 1] = {};\n\tint ret, i, last_idx = 0;\n\n\t \n\tret = usb4_port_enumerate_retimers(port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttb_retimer_nvm_authenticate_status(port, status);\n\n\t \n\ttb_retimer_set_inbound_sbtx(port);\n\n\tfor (i = 1; i <= TB_MAX_RETIMER_INDEX; i++) {\n\t\t \n\t\tret = usb4_port_retimer_is_last(port, i);\n\t\tif (ret > 0)\n\t\t\tlast_idx = i;\n\t\telse if (ret < 0)\n\t\t\tbreak;\n\t}\n\n\ttb_retimer_unset_inbound_sbtx(port);\n\n\tif (!last_idx)\n\t\treturn 0;\n\n\t \n\tret = 0;\n\tfor (i = 1; i <= last_idx; i++) {\n\t\tstruct tb_retimer *rt;\n\n\t\trt = tb_port_find_retimer(port, i);\n\t\tif (rt) {\n\t\t\tput_device(&rt->dev);\n\t\t} else if (add) {\n\t\t\tret = tb_retimer_add(port, i, status[i]);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int remove_retimer(struct device *dev, void *data)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(dev);\n\tstruct tb_port *port = data;\n\n\tif (rt && rt->port == port)\n\t\ttb_retimer_remove(rt);\n\treturn 0;\n}\n\n \nvoid tb_retimer_remove_all(struct tb_port *port)\n{\n\tstruct usb4_port *usb4;\n\n\tusb4 = port->usb4;\n\tif (usb4)\n\t\tdevice_for_each_child_reverse(&usb4->dev, port,\n\t\t\t\t\t      remove_retimer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}