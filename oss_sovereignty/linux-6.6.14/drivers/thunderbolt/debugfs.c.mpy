{
  "module_name": "debugfs.c",
  "hash_id": "22039abec55ce69c7bb32478fc630e0e7fe83cb949e96117ad7361fc6aeee88b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n#include <linux/uaccess.h>\n\n#include \"tb.h\"\n#include \"sb_regs.h\"\n\n#define PORT_CAP_V1_PCIE_LEN\t1\n#define PORT_CAP_V2_PCIE_LEN\t2\n#define PORT_CAP_POWER_LEN\t2\n#define PORT_CAP_LANE_LEN\t3\n#define PORT_CAP_USB3_LEN\t5\n#define PORT_CAP_DP_V1_LEN\t9\n#define PORT_CAP_DP_V2_LEN\t14\n#define PORT_CAP_TMU_V1_LEN\t8\n#define PORT_CAP_TMU_V2_LEN\t10\n#define PORT_CAP_BASIC_LEN\t9\n#define PORT_CAP_USB4_LEN\t20\n\n#define SWITCH_CAP_TMU_LEN\t26\n#define SWITCH_CAP_BASIC_LEN\t27\n\n#define PATH_LEN\t\t2\n\n#define COUNTER_SET_LEN\t\t3\n\n#define DEBUGFS_ATTR(__space, __write)\t\t\t\t\t\\\nstatic int __space ## _open(struct inode *inode, struct file *file)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn single_open(file, __space ## _show, inode->i_private);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations __space ## _fops = {\t\t\\\n\t.owner = THIS_MODULE,\t\t\t\t\t\t\\\n\t.open = __space ## _open,\t\t\t\t\t\\\n\t.release = single_release,\t\t\t\t\t\\\n\t.read  = seq_read,\t\t\t\t\t\t\\\n\t.write = __write,\t\t\t\t\t\t\\\n\t.llseek = seq_lseek,\t\t\t\t\t\t\\\n}\n\n#define DEBUGFS_ATTR_RO(__space)\t\t\t\t\t\\\n\tDEBUGFS_ATTR(__space, NULL)\n\n#define DEBUGFS_ATTR_RW(__space)\t\t\t\t\t\\\n\tDEBUGFS_ATTR(__space, __space ## _write)\n\nstatic struct dentry *tb_debugfs_root;\n\nstatic void *validate_and_copy_from_user(const void __user *user_buf,\n\t\t\t\t\t size_t *count)\n{\n\tsize_t nbytes;\n\tvoid *buf;\n\n\tif (!*count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!access_ok(user_buf, *count))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tbuf = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnbytes = min_t(size_t, *count, PAGE_SIZE);\n\tif (copy_from_user(buf, user_buf, nbytes)) {\n\t\tfree_page((unsigned long)buf);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\t*count = nbytes;\n\treturn buf;\n}\n\nstatic bool parse_line(char **line, u32 *offs, u32 *val, int short_fmt_len,\n\t\t       int long_fmt_len)\n{\n\tchar *token;\n\tu32 v[5];\n\tint ret;\n\n\ttoken = strsep(line, \"\\n\");\n\tif (!token)\n\t\treturn false;\n\n\t \n\tret = sscanf(token, \"%i %i %i %i %i\", &v[0], &v[1], &v[2], &v[3], &v[4]);\n\t \n\tif (ret == short_fmt_len) {\n\t\t*offs = v[0];\n\t\t*val = v[short_fmt_len - 1];\n\t\treturn true;\n\t} else if (ret == long_fmt_len) {\n\t\t*offs = v[0];\n\t\t*val = v[long_fmt_len - 1];\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#if IS_ENABLED(CONFIG_USB4_DEBUGFS_WRITE)\nstatic ssize_t regs_write(struct tb_switch *sw, struct tb_port *port,\n\t\t\t  const char __user *user_buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct tb *tb = sw->tb;\n\tchar *line, *buf;\n\tu32 val, offset;\n\tint ret = 0;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tline = buf;\n\twhile (parse_line(&line, &offset, &val, 2, 5)) {\n\t\tif (port)\n\t\t\tret = tb_port_write(port, &val, TB_CFG_PORT, offset, 1);\n\t\telse\n\t\t\tret = tb_sw_write(sw, &val, TB_CFG_SWITCH, offset, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\tfree_page((unsigned long)buf);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t port_regs_write(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\n\treturn regs_write(port->sw, port, user_buf, count, ppos);\n}\n\nstatic ssize_t switch_regs_write(struct file *file, const char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_switch *sw = s->private;\n\n\treturn regs_write(sw, NULL, user_buf, count, ppos);\n}\n#define DEBUGFS_MODE\t\t0600\n#else\n#define port_regs_write\t\tNULL\n#define switch_regs_write\tNULL\n#define DEBUGFS_MODE\t\t0400\n#endif\n\n#if IS_ENABLED(CONFIG_USB4_DEBUGFS_MARGINING)\n \nstruct tb_margining {\n\tu32 caps[2];\n\tu32 results[2];\n\tunsigned int lanes;\n\tunsigned int min_ber_level;\n\tunsigned int max_ber_level;\n\tunsigned int ber_level;\n\tunsigned int voltage_steps;\n\tunsigned int max_voltage_offset;\n\tunsigned int time_steps;\n\tunsigned int max_time_offset;\n\tbool software;\n\tbool time;\n\tbool right_high;\n};\n\nstatic bool supports_software(const struct usb4_port *usb4)\n{\n\treturn usb4->margining->caps[0] & USB4_MARGIN_CAP_0_MODES_SW;\n}\n\nstatic bool supports_hardware(const struct usb4_port *usb4)\n{\n\treturn usb4->margining->caps[0] & USB4_MARGIN_CAP_0_MODES_HW;\n}\n\nstatic bool both_lanes(const struct usb4_port *usb4)\n{\n\treturn usb4->margining->caps[0] & USB4_MARGIN_CAP_0_2_LANES;\n}\n\nstatic unsigned int independent_voltage_margins(const struct usb4_port *usb4)\n{\n\treturn (usb4->margining->caps[0] & USB4_MARGIN_CAP_0_VOLTAGE_INDP_MASK) >>\n\t\tUSB4_MARGIN_CAP_0_VOLTAGE_INDP_SHIFT;\n}\n\nstatic bool supports_time(const struct usb4_port *usb4)\n{\n\treturn usb4->margining->caps[0] & USB4_MARGIN_CAP_0_TIME;\n}\n\n \nstatic unsigned int independent_time_margins(const struct usb4_port *usb4)\n{\n\treturn (usb4->margining->caps[1] & USB4_MARGIN_CAP_1_TIME_INDP_MASK) >>\n\t\tUSB4_MARGIN_CAP_1_TIME_INDP_SHIFT;\n}\n\nstatic ssize_t\nmargining_ber_level_write(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tunsigned int val;\n\tint ret = 0;\n\tchar *buf;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (usb4->margining->software) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf)) {\n\t\tret = PTR_ERR(buf);\n\t\tgoto out_unlock;\n\t}\n\n\tbuf[count - 1] = '\\0';\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (val < usb4->margining->min_ber_level ||\n\t    val > usb4->margining->max_ber_level) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tusb4->margining->ber_level = val;\n\nout_free:\n\tfree_page((unsigned long)buf);\nout_unlock:\n\tmutex_unlock(&tb->lock);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic void ber_level_show(struct seq_file *s, unsigned int val)\n{\n\tif (val % 2)\n\t\tseq_printf(s, \"3 * 1e%d (%u)\\n\", -12 + (val + 1) / 2, val);\n\telse\n\t\tseq_printf(s, \"1e%d (%u)\\n\", -12 + val / 2, val);\n}\n\nstatic int margining_ber_level_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\n\tif (usb4->margining->software)\n\t\treturn -EINVAL;\n\tber_level_show(s, usb4->margining->ber_level);\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_ber_level);\n\nstatic int margining_caps_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tu32 cap0, cap1;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tcap0 = usb4->margining->caps[0];\n\tseq_printf(s, \"0x%08x\\n\", cap0);\n\tcap1 = usb4->margining->caps[1];\n\tseq_printf(s, \"0x%08x\\n\", cap1);\n\n\tseq_printf(s, \"# software margining: %s\\n\",\n\t\t   supports_software(usb4) ? \"yes\" : \"no\");\n\tif (supports_hardware(usb4)) {\n\t\tseq_puts(s, \"# hardware margining: yes\\n\");\n\t\tseq_puts(s, \"# minimum BER level contour: \");\n\t\tber_level_show(s, usb4->margining->min_ber_level);\n\t\tseq_puts(s, \"# maximum BER level contour: \");\n\t\tber_level_show(s, usb4->margining->max_ber_level);\n\t} else {\n\t\tseq_puts(s, \"# hardware margining: no\\n\");\n\t}\n\n\tseq_printf(s, \"# both lanes simultaneously: %s\\n\",\n\t\t  both_lanes(usb4) ? \"yes\" : \"no\");\n\tseq_printf(s, \"# voltage margin steps: %u\\n\",\n\t\t   usb4->margining->voltage_steps);\n\tseq_printf(s, \"# maximum voltage offset: %u mV\\n\",\n\t\t   usb4->margining->max_voltage_offset);\n\n\tswitch (independent_voltage_margins(usb4)) {\n\tcase USB4_MARGIN_CAP_0_VOLTAGE_MIN:\n\t\tseq_puts(s, \"# returns minimum between high and low voltage margins\\n\");\n\t\tbreak;\n\tcase USB4_MARGIN_CAP_0_VOLTAGE_HL:\n\t\tseq_puts(s, \"# returns high or low voltage margin\\n\");\n\t\tbreak;\n\tcase USB4_MARGIN_CAP_0_VOLTAGE_BOTH:\n\t\tseq_puts(s, \"# returns both high and low margins\\n\");\n\t\tbreak;\n\t}\n\n\tif (supports_time(usb4)) {\n\t\tseq_puts(s, \"# time margining: yes\\n\");\n\t\tseq_printf(s, \"# time margining is destructive: %s\\n\",\n\t\t\t   cap1 & USB4_MARGIN_CAP_1_TIME_DESTR ? \"yes\" : \"no\");\n\n\t\tswitch (independent_time_margins(usb4)) {\n\t\tcase USB4_MARGIN_CAP_1_TIME_MIN:\n\t\t\tseq_puts(s, \"# returns minimum between left and right time margins\\n\");\n\t\t\tbreak;\n\t\tcase USB4_MARGIN_CAP_1_TIME_LR:\n\t\t\tseq_puts(s, \"# returns left or right margin\\n\");\n\t\t\tbreak;\n\t\tcase USB4_MARGIN_CAP_1_TIME_BOTH:\n\t\t\tseq_puts(s, \"# returns both left and right margins\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_printf(s, \"# time margin steps: %u\\n\",\n\t\t\t   usb4->margining->time_steps);\n\t\tseq_printf(s, \"# maximum time offset: %u mUI\\n\",\n\t\t\t   usb4->margining->max_time_offset);\n\t} else {\n\t\tseq_puts(s, \"# time margining: no\\n\");\n\t}\n\n\tmutex_unlock(&tb->lock);\n\treturn 0;\n}\nDEBUGFS_ATTR_RO(margining_caps);\n\nstatic ssize_t\nmargining_lanes_write(struct file *file, const char __user *user_buf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tint ret = 0;\n\tchar *buf;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tbuf[count - 1] = '\\0';\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(buf, \"0\")) {\n\t\tusb4->margining->lanes = 0;\n\t} else if (!strcmp(buf, \"1\")) {\n\t\tusb4->margining->lanes = 1;\n\t} else if (!strcmp(buf, \"all\")) {\n\t\t \n\t\tif (both_lanes(usb4))\n\t\t\tusb4->margining->lanes = 7;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout_free:\n\tfree_page((unsigned long)buf);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int margining_lanes_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tunsigned int lanes;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tlanes = usb4->margining->lanes;\n\tif (both_lanes(usb4)) {\n\t\tif (!lanes)\n\t\t\tseq_puts(s, \"[0] 1 all\\n\");\n\t\telse if (lanes == 1)\n\t\t\tseq_puts(s, \"0 [1] all\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"0 1 [all]\\n\");\n\t} else {\n\t\tif (!lanes)\n\t\t\tseq_puts(s, \"[0] 1\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"0 [1]\\n\");\n\t}\n\n\tmutex_unlock(&tb->lock);\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_lanes);\n\nstatic ssize_t margining_mode_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tint ret = 0;\n\tchar *buf;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tbuf[count - 1] = '\\0';\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(buf, \"software\")) {\n\t\tif (supports_software(usb4))\n\t\t\tusb4->margining->software = true;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else if (!strcmp(buf, \"hardware\")) {\n\t\tif (supports_hardware(usb4))\n\t\t\tusb4->margining->software = false;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout_free:\n\tfree_page((unsigned long)buf);\n\treturn ret ? ret : count;\n}\n\nstatic int margining_mode_show(struct seq_file *s, void *not_used)\n{\n\tconst struct tb_port *port = s->private;\n\tconst struct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tconst char *space = \"\";\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (supports_software(usb4)) {\n\t\tif (usb4->margining->software)\n\t\t\tseq_puts(s, \"[software]\");\n\t\telse\n\t\t\tseq_puts(s, \"software\");\n\t\tspace = \" \";\n\t}\n\tif (supports_hardware(usb4)) {\n\t\tif (usb4->margining->software)\n\t\t\tseq_printf(s, \"%shardware\", space);\n\t\telse\n\t\t\tseq_printf(s, \"%s[hardware]\", space);\n\t}\n\n\tmutex_unlock(&tb->lock);\n\n\tseq_puts(s, \"\\n\");\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_mode);\n\nstatic int margining_run_write(void *data, u64 val)\n{\n\tstruct tb_port *port = data;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb_switch *sw = port->sw;\n\tstruct tb_margining *margining;\n\tstruct tb_switch *down_sw;\n\tstruct tb *tb = sw->tb;\n\tint ret, clx;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm_put;\n\t}\n\n\tif (tb_is_upstream_port(port))\n\t\tdown_sw = sw;\n\telse if (port->remote)\n\t\tdown_sw = port->remote->sw;\n\telse\n\t\tdown_sw = NULL;\n\n\tif (down_sw) {\n\t\t \n\t\tret = tb_switch_clx_disable(down_sw);\n\t\tif (ret < 0) {\n\t\t\ttb_sw_warn(down_sw, \"failed to disable CL states\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tclx = ret;\n\t}\n\n\tmargining = usb4->margining;\n\n\tif (margining->software) {\n\t\ttb_port_dbg(port, \"running software %s lane margining for lanes %u\\n\",\n\t\t\t    margining->time ? \"time\" : \"voltage\", margining->lanes);\n\t\tret = usb4_port_sw_margin(port, margining->lanes, margining->time,\n\t\t\t\t\t  margining->right_high,\n\t\t\t\t\t  USB4_MARGIN_SW_COUNTER_CLEAR);\n\t\tif (ret)\n\t\t\tgoto out_clx;\n\n\t\tret = usb4_port_sw_margin_errors(port, &margining->results[0]);\n\t} else {\n\t\ttb_port_dbg(port, \"running hardware %s lane margining for lanes %u\\n\",\n\t\t\t    margining->time ? \"time\" : \"voltage\", margining->lanes);\n\t\t \n\t\tmargining->results[0] = 0;\n\t\tmargining->results[1] = 0;\n\t\tret = usb4_port_hw_margin(port, margining->lanes,\n\t\t\t\t\t  margining->ber_level, margining->time,\n\t\t\t\t\t  margining->right_high, margining->results);\n\t}\n\nout_clx:\n\tif (down_sw)\n\t\ttb_switch_clx_enable(down_sw, clx);\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm_put:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\n\treturn ret;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(margining_run_fops, NULL, margining_run_write,\n\t\t\t \"%llu\\n\");\n\nstatic ssize_t margining_results_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tusb4->margining->results[0] = 0;\n\tusb4->margining->results[1] = 0;\n\n\tmutex_unlock(&tb->lock);\n\treturn count;\n}\n\nstatic void voltage_margin_show(struct seq_file *s,\n\t\t\t\tconst struct tb_margining *margining, u8 val)\n{\n\tunsigned int tmp, voltage;\n\n\ttmp = val & USB4_MARGIN_HW_RES_1_MARGIN_MASK;\n\tvoltage = tmp * margining->max_voltage_offset / margining->voltage_steps;\n\tseq_printf(s, \"%u mV (%u)\", voltage, tmp);\n\tif (val & USB4_MARGIN_HW_RES_1_EXCEEDS)\n\t\tseq_puts(s, \" exceeds maximum\");\n\tseq_puts(s, \"\\n\");\n}\n\nstatic void time_margin_show(struct seq_file *s,\n\t\t\t     const struct tb_margining *margining, u8 val)\n{\n\tunsigned int tmp, interval;\n\n\ttmp = val & USB4_MARGIN_HW_RES_1_MARGIN_MASK;\n\tinterval = tmp * margining->max_time_offset / margining->time_steps;\n\tseq_printf(s, \"%u mUI (%u)\", interval, tmp);\n\tif (val & USB4_MARGIN_HW_RES_1_EXCEEDS)\n\t\tseq_puts(s, \" exceeds maximum\");\n\tseq_puts(s, \"\\n\");\n}\n\nstatic int margining_results_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb_margining *margining;\n\tstruct tb *tb = port->sw->tb;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tmargining = usb4->margining;\n\t \n\tseq_printf(s, \"0x%08x\\n\", margining->results[0]);\n\t \n\tif (!margining->software) {\n\t\tunsigned int val;\n\n\t\tseq_printf(s, \"0x%08x\\n\", margining->results[1]);\n\n\t\tif (margining->time) {\n\t\t\tif (!margining->lanes || margining->lanes == 7) {\n\t\t\t\tval = margining->results[1];\n\t\t\t\tseq_puts(s, \"# lane 0 right time margin: \");\n\t\t\t\ttime_margin_show(s, margining, val);\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L0_LL_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 0 left time margin: \");\n\t\t\t\ttime_margin_show(s, margining, val);\n\t\t\t}\n\t\t\tif (margining->lanes == 1 || margining->lanes == 7) {\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L1_RH_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 1 right time margin: \");\n\t\t\t\ttime_margin_show(s, margining, val);\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L1_LL_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 1 left time margin: \");\n\t\t\t\ttime_margin_show(s, margining, val);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!margining->lanes || margining->lanes == 7) {\n\t\t\t\tval = margining->results[1];\n\t\t\t\tseq_puts(s, \"# lane 0 high voltage margin: \");\n\t\t\t\tvoltage_margin_show(s, margining, val);\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L0_LL_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 0 low voltage margin: \");\n\t\t\t\tvoltage_margin_show(s, margining, val);\n\t\t\t}\n\t\t\tif (margining->lanes == 1 || margining->lanes == 7) {\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L1_RH_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 1 high voltage margin: \");\n\t\t\t\tvoltage_margin_show(s, margining, val);\n\t\t\t\tval = margining->results[1] >>\n\t\t\t\t\tUSB4_MARGIN_HW_RES_1_L1_LL_MARGIN_SHIFT;\n\t\t\t\tseq_puts(s, \"# lane 1 low voltage margin: \");\n\t\t\t\tvoltage_margin_show(s, margining, val);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&tb->lock);\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_results);\n\nstatic ssize_t margining_test_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tint ret = 0;\n\tchar *buf;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tbuf[count - 1] = '\\0';\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(buf, \"time\") && supports_time(usb4))\n\t\tusb4->margining->time = true;\n\telse if (!strcmp(buf, \"voltage\"))\n\t\tusb4->margining->time = false;\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&tb->lock);\n\nout_free:\n\tfree_page((unsigned long)buf);\n\treturn ret ? ret : count;\n}\n\nstatic int margining_test_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (supports_time(usb4)) {\n\t\tif (usb4->margining->time)\n\t\t\tseq_puts(s, \"voltage [time]\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"[voltage] time\\n\");\n\t} else {\n\t\tseq_puts(s, \"[voltage]\\n\");\n\t}\n\n\tmutex_unlock(&tb->lock);\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_test);\n\nstatic ssize_t margining_margin_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\tint ret = 0;\n\tchar *buf;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tbuf[count - 1] = '\\0';\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_free;\n\t}\n\n\tif (usb4->margining->time) {\n\t\tif (!strcmp(buf, \"left\"))\n\t\t\tusb4->margining->right_high = false;\n\t\telse if (!strcmp(buf, \"right\"))\n\t\t\tusb4->margining->right_high = true;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else {\n\t\tif (!strcmp(buf, \"low\"))\n\t\t\tusb4->margining->right_high = false;\n\t\telse if (!strcmp(buf, \"high\"))\n\t\t\tusb4->margining->right_high = true;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout_free:\n\tfree_page((unsigned long)buf);\n\treturn ret ? ret : count;\n}\n\nstatic int margining_margin_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct usb4_port *usb4 = port->usb4;\n\tstruct tb *tb = port->sw->tb;\n\n\tif (mutex_lock_interruptible(&tb->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (usb4->margining->time) {\n\t\tif (usb4->margining->right_high)\n\t\t\tseq_puts(s, \"left [right]\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"[left] right\\n\");\n\t} else {\n\t\tif (usb4->margining->right_high)\n\t\t\tseq_puts(s, \"low [high]\\n\");\n\t\telse\n\t\t\tseq_puts(s, \"[low] high\\n\");\n\t}\n\n\tmutex_unlock(&tb->lock);\n\treturn 0;\n}\nDEBUGFS_ATTR_RW(margining_margin);\n\nstatic void margining_port_init(struct tb_port *port)\n{\n\tstruct tb_margining *margining;\n\tstruct dentry *dir, *parent;\n\tstruct usb4_port *usb4;\n\tchar dir_name[10];\n\tunsigned int val;\n\tint ret;\n\n\tusb4 = port->usb4;\n\tif (!usb4)\n\t\treturn;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"port%d\", port->port);\n\tparent = debugfs_lookup(dir_name, port->sw->debugfs_dir);\n\n\tmargining = kzalloc(sizeof(*margining), GFP_KERNEL);\n\tif (!margining)\n\t\treturn;\n\n\tret = usb4_port_margining_caps(port, margining->caps);\n\tif (ret) {\n\t\tkfree(margining);\n\t\treturn;\n\t}\n\n\tusb4->margining = margining;\n\n\t \n\tif (supports_software(usb4))\n\t\tmargining->software = true;\n\n\tval = (margining->caps[0] & USB4_MARGIN_CAP_0_VOLTAGE_STEPS_MASK) >>\n\t\tUSB4_MARGIN_CAP_0_VOLTAGE_STEPS_SHIFT;\n\tmargining->voltage_steps = val;\n\tval = (margining->caps[0] & USB4_MARGIN_CAP_0_MAX_VOLTAGE_OFFSET_MASK) >>\n\t\tUSB4_MARGIN_CAP_0_MAX_VOLTAGE_OFFSET_SHIFT;\n\tmargining->max_voltage_offset = 74 + val * 2;\n\n\tif (supports_time(usb4)) {\n\t\tval = (margining->caps[1] & USB4_MARGIN_CAP_1_TIME_STEPS_MASK) >>\n\t\t\tUSB4_MARGIN_CAP_1_TIME_STEPS_SHIFT;\n\t\tmargining->time_steps = val;\n\t\tval = (margining->caps[1] & USB4_MARGIN_CAP_1_TIME_OFFSET_MASK) >>\n\t\t\tUSB4_MARGIN_CAP_1_TIME_OFFSET_SHIFT;\n\t\t \n\t\tmargining->max_time_offset = 200 + 10 * val;\n\t}\n\n\tdir = debugfs_create_dir(\"margining\", parent);\n\tif (supports_hardware(usb4)) {\n\t\tval = (margining->caps[1] & USB4_MARGIN_CAP_1_MIN_BER_MASK) >>\n\t\t\tUSB4_MARGIN_CAP_1_MIN_BER_SHIFT;\n\t\tmargining->min_ber_level = val;\n\t\tval = (margining->caps[1] & USB4_MARGIN_CAP_1_MAX_BER_MASK) >>\n\t\t\tUSB4_MARGIN_CAP_1_MAX_BER_SHIFT;\n\t\tmargining->max_ber_level = val;\n\n\t\t \n\t\tmargining->ber_level = margining->min_ber_level;\n\n\t\tdebugfs_create_file(\"ber_level_contour\", 0400, dir, port,\n\t\t\t\t    &margining_ber_level_fops);\n\t}\n\tdebugfs_create_file(\"caps\", 0400, dir, port, &margining_caps_fops);\n\tdebugfs_create_file(\"lanes\", 0600, dir, port, &margining_lanes_fops);\n\tdebugfs_create_file(\"mode\", 0600, dir, port, &margining_mode_fops);\n\tdebugfs_create_file(\"run\", 0600, dir, port, &margining_run_fops);\n\tdebugfs_create_file(\"results\", 0600, dir, port, &margining_results_fops);\n\tdebugfs_create_file(\"test\", 0600, dir, port, &margining_test_fops);\n\tif (independent_voltage_margins(usb4) ||\n\t    (supports_time(usb4) && independent_time_margins(usb4)))\n\t\tdebugfs_create_file(\"margin\", 0600, dir, port, &margining_margin_fops);\n}\n\nstatic void margining_port_remove(struct tb_port *port)\n{\n\tstruct dentry *parent;\n\tchar dir_name[10];\n\n\tif (!port->usb4)\n\t\treturn;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"port%d\", port->port);\n\tparent = debugfs_lookup(dir_name, port->sw->debugfs_dir);\n\tif (parent)\n\t\tdebugfs_lookup_and_remove(\"margining\", parent);\n\n\tkfree(port->usb4->margining);\n\tport->usb4->margining = NULL;\n}\n\nstatic void margining_switch_init(struct tb_switch *sw)\n{\n\tstruct tb_port *upstream, *downstream;\n\tstruct tb_switch *parent_sw;\n\tu64 route = tb_route(sw);\n\n\tif (!route)\n\t\treturn;\n\n\tupstream = tb_upstream_port(sw);\n\tparent_sw = tb_switch_parent(sw);\n\tdownstream = tb_port_at(route, parent_sw);\n\n\tmargining_port_init(downstream);\n\tmargining_port_init(upstream);\n}\n\nstatic void margining_switch_remove(struct tb_switch *sw)\n{\n\tstruct tb_port *upstream, *downstream;\n\tstruct tb_switch *parent_sw;\n\tu64 route = tb_route(sw);\n\n\tif (!route)\n\t\treturn;\n\n\tupstream = tb_upstream_port(sw);\n\tparent_sw = tb_switch_parent(sw);\n\tdownstream = tb_port_at(route, parent_sw);\n\n\tmargining_port_remove(upstream);\n\tmargining_port_remove(downstream);\n}\n\nstatic void margining_xdomain_init(struct tb_xdomain *xd)\n{\n\tstruct tb_switch *parent_sw;\n\tstruct tb_port *downstream;\n\n\tparent_sw = tb_xdomain_parent(xd);\n\tdownstream = tb_port_at(xd->route, parent_sw);\n\n\tmargining_port_init(downstream);\n}\n\nstatic void margining_xdomain_remove(struct tb_xdomain *xd)\n{\n\tstruct tb_switch *parent_sw;\n\tstruct tb_port *downstream;\n\n\tparent_sw = tb_xdomain_parent(xd);\n\tdownstream = tb_port_at(xd->route, parent_sw);\n\tmargining_port_remove(downstream);\n}\n#else\nstatic inline void margining_switch_init(struct tb_switch *sw) { }\nstatic inline void margining_switch_remove(struct tb_switch *sw) { }\nstatic inline void margining_xdomain_init(struct tb_xdomain *xd) { }\nstatic inline void margining_xdomain_remove(struct tb_xdomain *xd) { }\n#endif\n\nstatic int port_clear_all_counters(struct tb_port *port)\n{\n\tu32 *buf;\n\tint ret;\n\n\tbuf = kcalloc(COUNTER_SET_LEN * port->config.max_counters, sizeof(u32),\n\t\t      GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = tb_port_write(port, buf, TB_CFG_COUNTERS, 0,\n\t\t\t    COUNTER_SET_LEN * port->config.max_counters);\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic ssize_t counters_write(struct file *file, const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct tb_port *port = s->private;\n\tstruct tb_switch *sw = port->sw;\n\tstruct tb *tb = port->sw->tb;\n\tchar *buf;\n\tint ret;\n\n\tbuf = validate_and_copy_from_user(user_buf, &count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\n\t \n\tif (buf[0] == '\\n') {\n\t\tret = port_clear_all_counters(port);\n\t} else  {\n\t\tchar *line = buf;\n\t\tu32 val, offset;\n\n\t\tret = -EINVAL;\n\t\twhile (parse_line(&line, &offset, &val, 1, 4)) {\n\t\t\tret = tb_port_write(port, &val, TB_CFG_COUNTERS,\n\t\t\t\t\t    offset, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\tfree_page((unsigned long)buf);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic void cap_show_by_dw(struct seq_file *s, struct tb_switch *sw,\n\t\t\t   struct tb_port *port, unsigned int cap,\n\t\t\t   unsigned int offset, u8 cap_id, u8 vsec_id,\n\t\t\t   int dwords)\n{\n\tint i, ret;\n\tu32 data;\n\n\tfor (i = 0; i < dwords; i++) {\n\t\tif (port)\n\t\t\tret = tb_port_read(port, &data, TB_CFG_PORT, cap + offset + i, 1);\n\t\telse\n\t\t\tret = tb_sw_read(sw, &data, TB_CFG_SWITCH, cap + offset + i, 1);\n\t\tif (ret) {\n\t\t\tseq_printf(s, \"0x%04x <not accessible>\\n\", cap + offset + i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(s, \"0x%04x %4d 0x%02x 0x%02x 0x%08x\\n\", cap + offset + i,\n\t\t\t   offset + i, cap_id, vsec_id, data);\n\t}\n}\n\nstatic void cap_show(struct seq_file *s, struct tb_switch *sw,\n\t\t     struct tb_port *port, unsigned int cap, u8 cap_id,\n\t\t     u8 vsec_id, int length)\n{\n\tint ret, offset = 0;\n\n\twhile (length > 0) {\n\t\tint i, dwords = min(length, TB_MAX_CONFIG_RW_LENGTH);\n\t\tu32 data[TB_MAX_CONFIG_RW_LENGTH];\n\n\t\tif (port)\n\t\t\tret = tb_port_read(port, data, TB_CFG_PORT, cap + offset,\n\t\t\t\t\t   dwords);\n\t\telse\n\t\t\tret = tb_sw_read(sw, data, TB_CFG_SWITCH, cap + offset, dwords);\n\t\tif (ret) {\n\t\t\tcap_show_by_dw(s, sw, port, cap, offset, cap_id, vsec_id, length);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < dwords; i++) {\n\t\t\tseq_printf(s, \"0x%04x %4d 0x%02x 0x%02x 0x%08x\\n\",\n\t\t\t\t   cap + offset + i, offset + i,\n\t\t\t\t   cap_id, vsec_id, data[i]);\n\t\t}\n\n\t\tlength -= dwords;\n\t\toffset += dwords;\n\t}\n}\n\nstatic void port_cap_show(struct tb_port *port, struct seq_file *s,\n\t\t\t  unsigned int cap)\n{\n\tstruct tb_cap_any header;\n\tu8 vsec_id = 0;\n\tsize_t length;\n\tint ret;\n\n\tret = tb_port_read(port, &header, TB_CFG_PORT, cap, 1);\n\tif (ret) {\n\t\tseq_printf(s, \"0x%04x <capability read failed>\\n\", cap);\n\t\treturn;\n\t}\n\n\tswitch (header.basic.cap) {\n\tcase TB_PORT_CAP_PHY:\n\t\tlength = PORT_CAP_LANE_LEN;\n\t\tbreak;\n\n\tcase TB_PORT_CAP_TIME1:\n\t\tif (usb4_switch_version(port->sw) < 2)\n\t\t\tlength = PORT_CAP_TMU_V1_LEN;\n\t\telse\n\t\t\tlength = PORT_CAP_TMU_V2_LEN;\n\t\tbreak;\n\n\tcase TB_PORT_CAP_POWER:\n\t\tlength = PORT_CAP_POWER_LEN;\n\t\tbreak;\n\n\tcase TB_PORT_CAP_ADAP:\n\t\tif (tb_port_is_pcie_down(port) || tb_port_is_pcie_up(port)) {\n\t\t\tif (usb4_switch_version(port->sw) < 2)\n\t\t\t\tlength = PORT_CAP_V1_PCIE_LEN;\n\t\t\telse\n\t\t\t\tlength = PORT_CAP_V2_PCIE_LEN;\n\t\t} else if (tb_port_is_dpin(port)) {\n\t\t\tif (usb4_switch_version(port->sw) < 2)\n\t\t\t\tlength = PORT_CAP_DP_V1_LEN;\n\t\t\telse\n\t\t\t\tlength = PORT_CAP_DP_V2_LEN;\n\t\t} else if (tb_port_is_dpout(port)) {\n\t\t\tlength = PORT_CAP_DP_V1_LEN;\n\t\t} else if (tb_port_is_usb3_down(port) ||\n\t\t\t   tb_port_is_usb3_up(port)) {\n\t\t\tlength = PORT_CAP_USB3_LEN;\n\t\t} else {\n\t\t\tseq_printf(s, \"0x%04x <unsupported capability 0x%02x>\\n\",\n\t\t\t\t   cap, header.basic.cap);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase TB_PORT_CAP_VSE:\n\t\tif (!header.extended_short.length) {\n\t\t\tret = tb_port_read(port, (u32 *)&header + 1, TB_CFG_PORT,\n\t\t\t\t\t   cap + 1, 1);\n\t\t\tif (ret) {\n\t\t\t\tseq_printf(s, \"0x%04x <capability read failed>\\n\",\n\t\t\t\t\t   cap + 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlength = header.extended_long.length;\n\t\t\tvsec_id = header.extended_short.vsec_id;\n\t\t} else {\n\t\t\tlength = header.extended_short.length;\n\t\t\tvsec_id = header.extended_short.vsec_id;\n\t\t}\n\t\tbreak;\n\n\tcase TB_PORT_CAP_USB4:\n\t\tlength = PORT_CAP_USB4_LEN;\n\t\tbreak;\n\n\tdefault:\n\t\tseq_printf(s, \"0x%04x <unsupported capability 0x%02x>\\n\",\n\t\t\t   cap, header.basic.cap);\n\t\treturn;\n\t}\n\n\tcap_show(s, NULL, port, cap, header.basic.cap, vsec_id, length);\n}\n\nstatic void port_caps_show(struct tb_port *port, struct seq_file *s)\n{\n\tint cap;\n\n\tcap = tb_port_next_cap(port, 0);\n\twhile (cap > 0) {\n\t\tport_cap_show(port, s, cap);\n\t\tcap = tb_port_next_cap(port, cap);\n\t}\n}\n\nstatic int port_basic_regs_show(struct tb_port *port, struct seq_file *s)\n{\n\tu32 data[PORT_CAP_BASIC_LEN];\n\tint ret, i;\n\n\tret = tb_port_read(port, data, TB_CFG_PORT, 0, ARRAY_SIZE(data));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tseq_printf(s, \"0x%04x %4d 0x00 0x00 0x%08x\\n\", i, i, data[i]);\n\n\treturn 0;\n}\n\nstatic int port_regs_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct tb_switch *sw = port->sw;\n\tstruct tb *tb = sw->tb;\n\tint ret;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm_put;\n\t}\n\n\tseq_puts(s, \"# offset relative_offset cap_id vs_cap_id value\\n\");\n\n\tret = port_basic_regs_show(port, s);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tport_caps_show(port, s);\n\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm_put:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\n\treturn ret;\n}\nDEBUGFS_ATTR_RW(port_regs);\n\nstatic void switch_cap_show(struct tb_switch *sw, struct seq_file *s,\n\t\t\t    unsigned int cap)\n{\n\tstruct tb_cap_any header;\n\tint ret, length;\n\tu8 vsec_id = 0;\n\n\tret = tb_sw_read(sw, &header, TB_CFG_SWITCH, cap, 1);\n\tif (ret) {\n\t\tseq_printf(s, \"0x%04x <capability read failed>\\n\", cap);\n\t\treturn;\n\t}\n\n\tif (header.basic.cap == TB_SWITCH_CAP_VSE) {\n\t\tif (!header.extended_short.length) {\n\t\t\tret = tb_sw_read(sw, (u32 *)&header + 1, TB_CFG_SWITCH,\n\t\t\t\t\t cap + 1, 1);\n\t\t\tif (ret) {\n\t\t\t\tseq_printf(s, \"0x%04x <capability read failed>\\n\",\n\t\t\t\t\t   cap + 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlength = header.extended_long.length;\n\t\t} else {\n\t\t\tlength = header.extended_short.length;\n\t\t}\n\t\tvsec_id = header.extended_short.vsec_id;\n\t} else {\n\t\tif (header.basic.cap == TB_SWITCH_CAP_TMU) {\n\t\t\tlength = SWITCH_CAP_TMU_LEN;\n\t\t} else  {\n\t\t\tseq_printf(s, \"0x%04x <unknown capability 0x%02x>\\n\",\n\t\t\t\t   cap, header.basic.cap);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcap_show(s, sw, NULL, cap, header.basic.cap, vsec_id, length);\n}\n\nstatic void switch_caps_show(struct tb_switch *sw, struct seq_file *s)\n{\n\tint cap;\n\n\tcap = tb_switch_next_cap(sw, 0);\n\twhile (cap > 0) {\n\t\tswitch_cap_show(sw, s, cap);\n\t\tcap = tb_switch_next_cap(sw, cap);\n\t}\n}\n\nstatic int switch_basic_regs_show(struct tb_switch *sw, struct seq_file *s)\n{\n\tu32 data[SWITCH_CAP_BASIC_LEN];\n\tsize_t dwords;\n\tint ret, i;\n\n\t \n\tif (tb_switch_is_usb4(sw))\n\t\tdwords = ARRAY_SIZE(data);\n\telse\n\t\tdwords = 7;\n\n\tret = tb_sw_read(sw, data, TB_CFG_SWITCH, 0, dwords);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < dwords; i++)\n\t\tseq_printf(s, \"0x%04x %4d 0x00 0x00 0x%08x\\n\", i, i, data[i]);\n\n\treturn 0;\n}\n\nstatic int switch_regs_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_switch *sw = s->private;\n\tstruct tb *tb = sw->tb;\n\tint ret;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm_put;\n\t}\n\n\tseq_puts(s, \"# offset relative_offset cap_id vs_cap_id value\\n\");\n\n\tret = switch_basic_regs_show(sw, s);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tswitch_caps_show(sw, s);\n\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm_put:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\n\treturn ret;\n}\nDEBUGFS_ATTR_RW(switch_regs);\n\nstatic int path_show_one(struct tb_port *port, struct seq_file *s, int hopid)\n{\n\tu32 data[PATH_LEN];\n\tint ret, i;\n\n\tret = tb_port_read(port, data, TB_CFG_HOPS, hopid * PATH_LEN,\n\t\t\t   ARRAY_SIZE(data));\n\tif (ret) {\n\t\tseq_printf(s, \"0x%04x <not accessible>\\n\", hopid * PATH_LEN);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\tseq_printf(s, \"0x%04x %4d 0x%02x 0x%08x\\n\",\n\t\t\t   hopid * PATH_LEN + i, i, hopid, data[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int path_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct tb_switch *sw = port->sw;\n\tstruct tb *tb = sw->tb;\n\tint start, i, ret = 0;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_rpm_put;\n\t}\n\n\tseq_puts(s, \"# offset relative_offset in_hop_id value\\n\");\n\n\t \n\tif (tb_port_is_null(port) || tb_port_is_nhi(port)) {\n\t\tret = path_show_one(port, s, 0);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tstart = tb_port_is_nhi(port) ? 1 : TB_PATH_MIN_HOPID;\n\n\tfor (i = start; i <= port->config.max_in_hop_id; i++) {\n\t\tret = path_show_one(port, s, i);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\tmutex_unlock(&tb->lock);\nout_rpm_put:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\n\treturn ret;\n}\nDEBUGFS_ATTR_RO(path);\n\nstatic int counter_set_regs_show(struct tb_port *port, struct seq_file *s,\n\t\t\t\t int counter)\n{\n\tu32 data[COUNTER_SET_LEN];\n\tint ret, i;\n\n\tret = tb_port_read(port, data, TB_CFG_COUNTERS,\n\t\t\t   counter * COUNTER_SET_LEN, ARRAY_SIZE(data));\n\tif (ret) {\n\t\tseq_printf(s, \"0x%04x <not accessible>\\n\",\n\t\t\t   counter * COUNTER_SET_LEN);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\tseq_printf(s, \"0x%04x %4d 0x%02x 0x%08x\\n\",\n\t\t\t   counter * COUNTER_SET_LEN + i, i, counter, data[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int counters_show(struct seq_file *s, void *not_used)\n{\n\tstruct tb_port *port = s->private;\n\tstruct tb_switch *sw = port->sw;\n\tstruct tb *tb = sw->tb;\n\tint i, ret = 0;\n\n\tpm_runtime_get_sync(&sw->dev);\n\n\tif (mutex_lock_interruptible(&tb->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\n\tseq_puts(s, \"# offset relative_offset counter_id value\\n\");\n\n\tfor (i = 0; i < port->config.max_counters; i++) {\n\t\tret = counter_set_regs_show(port, s, i);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&tb->lock);\n\nout:\n\tpm_runtime_mark_last_busy(&sw->dev);\n\tpm_runtime_put_autosuspend(&sw->dev);\n\n\treturn ret;\n}\nDEBUGFS_ATTR_RW(counters);\n\n \nvoid tb_switch_debugfs_init(struct tb_switch *sw)\n{\n\tstruct dentry *debugfs_dir;\n\tstruct tb_port *port;\n\n\tdebugfs_dir = debugfs_create_dir(dev_name(&sw->dev), tb_debugfs_root);\n\tsw->debugfs_dir = debugfs_dir;\n\tdebugfs_create_file(\"regs\", DEBUGFS_MODE, debugfs_dir, sw,\n\t\t\t    &switch_regs_fops);\n\n\ttb_switch_for_each_port(sw, port) {\n\t\tstruct dentry *debugfs_dir;\n\t\tchar dir_name[10];\n\n\t\tif (port->disabled)\n\t\t\tcontinue;\n\t\tif (port->config.type == TB_TYPE_INACTIVE)\n\t\t\tcontinue;\n\n\t\tsnprintf(dir_name, sizeof(dir_name), \"port%d\", port->port);\n\t\tdebugfs_dir = debugfs_create_dir(dir_name, sw->debugfs_dir);\n\t\tdebugfs_create_file(\"regs\", DEBUGFS_MODE, debugfs_dir,\n\t\t\t\t    port, &port_regs_fops);\n\t\tdebugfs_create_file(\"path\", 0400, debugfs_dir, port,\n\t\t\t\t    &path_fops);\n\t\tif (port->config.counters_support)\n\t\t\tdebugfs_create_file(\"counters\", 0600, debugfs_dir, port,\n\t\t\t\t\t    &counters_fops);\n\t}\n\n\tmargining_switch_init(sw);\n}\n\n \nvoid tb_switch_debugfs_remove(struct tb_switch *sw)\n{\n\tmargining_switch_remove(sw);\n\tdebugfs_remove_recursive(sw->debugfs_dir);\n}\n\nvoid tb_xdomain_debugfs_init(struct tb_xdomain *xd)\n{\n\tmargining_xdomain_init(xd);\n}\n\nvoid tb_xdomain_debugfs_remove(struct tb_xdomain *xd)\n{\n\tmargining_xdomain_remove(xd);\n}\n\n \nvoid tb_service_debugfs_init(struct tb_service *svc)\n{\n\tsvc->debugfs_dir = debugfs_create_dir(dev_name(&svc->dev),\n\t\t\t\t\t      tb_debugfs_root);\n}\n\n \nvoid tb_service_debugfs_remove(struct tb_service *svc)\n{\n\tdebugfs_remove_recursive(svc->debugfs_dir);\n\tsvc->debugfs_dir = NULL;\n}\n\nvoid tb_debugfs_init(void)\n{\n\ttb_debugfs_root = debugfs_create_dir(\"thunderbolt\", NULL);\n}\n\nvoid tb_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(tb_debugfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}