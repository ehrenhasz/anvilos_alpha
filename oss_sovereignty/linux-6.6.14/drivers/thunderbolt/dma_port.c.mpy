{
  "module_name": "dma_port.c",
  "hash_id": "f7009942eba3dca37bc8c9fc1282f859e0035a5c2d2320a58bdd390a5132d9b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/dma_port.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"dma_port.h\"\n#include \"tb_regs.h\"\n\n#define DMA_PORT_CAP\t\t\t0x3e\n\n#define MAIL_DATA\t\t\t1\n#define MAIL_DATA_DWORDS\t\t16\n\n#define MAIL_IN\t\t\t\t17\n#define MAIL_IN_CMD_SHIFT\t\t28\n#define MAIL_IN_CMD_MASK\t\tGENMASK(31, 28)\n#define MAIL_IN_CMD_FLASH_WRITE\t\t0x0\n#define MAIL_IN_CMD_FLASH_UPDATE_AUTH\t0x1\n#define MAIL_IN_CMD_FLASH_READ\t\t0x2\n#define MAIL_IN_CMD_POWER_CYCLE\t\t0x4\n#define MAIL_IN_DWORDS_SHIFT\t\t24\n#define MAIL_IN_DWORDS_MASK\t\tGENMASK(27, 24)\n#define MAIL_IN_ADDRESS_SHIFT\t\t2\n#define MAIL_IN_ADDRESS_MASK\t\tGENMASK(23, 2)\n#define MAIL_IN_CSS\t\t\tBIT(1)\n#define MAIL_IN_OP_REQUEST\t\tBIT(0)\n\n#define MAIL_OUT\t\t\t18\n#define MAIL_OUT_STATUS_RESPONSE\tBIT(29)\n#define MAIL_OUT_STATUS_CMD_SHIFT\t4\n#define MAIL_OUT_STATUS_CMD_MASK\tGENMASK(7, 4)\n#define MAIL_OUT_STATUS_MASK\t\tGENMASK(3, 0)\n#define MAIL_OUT_STATUS_COMPLETED\t0\n#define MAIL_OUT_STATUS_ERR_AUTH\t1\n#define MAIL_OUT_STATUS_ERR_ACCESS\t2\n\n#define DMA_PORT_TIMEOUT\t\t5000  \n#define DMA_PORT_RETRIES\t\t3\n\n \nstruct tb_dma_port {\n\tstruct tb_switch *sw;\n\tu8 port;\n\tu32 base;\n\tu8 *buf;\n};\n\n \nstatic bool dma_port_match(const struct tb_cfg_request *req,\n\t\t\t   const struct ctl_pkg *pkg)\n{\n\tu64 route = tb_cfg_get_route(pkg->buffer) & ~BIT_ULL(63);\n\n\tif (pkg->frame.eof == TB_CFG_PKG_ERROR)\n\t\treturn true;\n\tif (pkg->frame.eof != req->response_type)\n\t\treturn false;\n\tif (route != tb_cfg_get_route(req->request))\n\t\treturn false;\n\tif (pkg->frame.size != req->response_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool dma_port_copy(struct tb_cfg_request *req, const struct ctl_pkg *pkg)\n{\n\tmemcpy(req->response, pkg->buffer, req->response_size);\n\treturn true;\n}\n\nstatic int dma_port_read(struct tb_ctl *ctl, void *buffer, u64 route,\n\t\t\t u32 port, u32 offset, u32 length, int timeout_msec)\n{\n\tstruct cfg_read_pkg request = {\n\t\t.header = tb_cfg_make_header(route),\n\t\t.addr = {\n\t\t\t.seq = 1,\n\t\t\t.port = port,\n\t\t\t.space = TB_CFG_PORT,\n\t\t\t.offset = offset,\n\t\t\t.length = length,\n\t\t},\n\t};\n\tstruct tb_cfg_request *req;\n\tstruct cfg_write_pkg reply;\n\tstruct tb_cfg_result res;\n\n\treq = tb_cfg_request_alloc();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->match = dma_port_match;\n\treq->copy = dma_port_copy;\n\treq->request = &request;\n\treq->request_size = sizeof(request);\n\treq->request_type = TB_CFG_PKG_READ;\n\treq->response = &reply;\n\treq->response_size = 12 + 4 * length;\n\treq->response_type = TB_CFG_PKG_READ;\n\n\tres = tb_cfg_request_sync(ctl, req, timeout_msec);\n\n\ttb_cfg_request_put(req);\n\n\tif (res.err)\n\t\treturn res.err;\n\n\tmemcpy(buffer, &reply.data, 4 * length);\n\treturn 0;\n}\n\nstatic int dma_port_write(struct tb_ctl *ctl, const void *buffer, u64 route,\n\t\t\t  u32 port, u32 offset, u32 length, int timeout_msec)\n{\n\tstruct cfg_write_pkg request = {\n\t\t.header = tb_cfg_make_header(route),\n\t\t.addr = {\n\t\t\t.seq = 1,\n\t\t\t.port = port,\n\t\t\t.space = TB_CFG_PORT,\n\t\t\t.offset = offset,\n\t\t\t.length = length,\n\t\t},\n\t};\n\tstruct tb_cfg_request *req;\n\tstruct cfg_read_pkg reply;\n\tstruct tb_cfg_result res;\n\n\tmemcpy(&request.data, buffer, length * 4);\n\n\treq = tb_cfg_request_alloc();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->match = dma_port_match;\n\treq->copy = dma_port_copy;\n\treq->request = &request;\n\treq->request_size = 12 + 4 * length;\n\treq->request_type = TB_CFG_PKG_WRITE;\n\treq->response = &reply;\n\treq->response_size = sizeof(reply);\n\treq->response_type = TB_CFG_PKG_WRITE;\n\n\tres = tb_cfg_request_sync(ctl, req, timeout_msec);\n\n\ttb_cfg_request_put(req);\n\n\treturn res.err;\n}\n\nstatic int dma_find_port(struct tb_switch *sw)\n{\n\tstatic const int ports[] = { 3, 5, 7 };\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ports); i++) {\n\t\tu32 type;\n\t\tint ret;\n\n\t\tret = dma_port_read(sw->tb->ctl, &type, tb_route(sw), ports[i],\n\t\t\t\t    2, 1, DMA_PORT_TIMEOUT);\n\t\tif (!ret && (type & 0xffffff) == TB_TYPE_NHI)\n\t\t\treturn ports[i];\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstruct tb_dma_port *dma_port_alloc(struct tb_switch *sw)\n{\n\tstruct tb_dma_port *dma;\n\tint port;\n\n\tport = dma_find_port(sw);\n\tif (port < 0)\n\t\treturn NULL;\n\n\tdma = kzalloc(sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn NULL;\n\n\tdma->buf = kmalloc_array(MAIL_DATA_DWORDS, sizeof(u32), GFP_KERNEL);\n\tif (!dma->buf) {\n\t\tkfree(dma);\n\t\treturn NULL;\n\t}\n\n\tdma->sw = sw;\n\tdma->port = port;\n\tdma->base = DMA_PORT_CAP;\n\n\treturn dma;\n}\n\n \nvoid dma_port_free(struct tb_dma_port *dma)\n{\n\tif (dma) {\n\t\tkfree(dma->buf);\n\t\tkfree(dma);\n\t}\n}\n\nstatic int dma_port_wait_for_completion(struct tb_dma_port *dma,\n\t\t\t\t\tunsigned int timeout)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(timeout);\n\tstruct tb_switch *sw = dma->sw;\n\n\tdo {\n\t\tint ret;\n\t\tu32 in;\n\n\t\tret = dma_port_read(sw->tb->ctl, &in, tb_route(sw), dma->port,\n\t\t\t\t    dma->base + MAIL_IN, 1, 50);\n\t\tif (ret) {\n\t\t\tif (ret != -ETIMEDOUT)\n\t\t\t\treturn ret;\n\t\t} else if (!(in & MAIL_IN_OP_REQUEST)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(50, 100);\n\t} while (time_before(jiffies, end));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int status_to_errno(u32 status)\n{\n\tswitch (status & MAIL_OUT_STATUS_MASK) {\n\tcase MAIL_OUT_STATUS_COMPLETED:\n\t\treturn 0;\n\tcase MAIL_OUT_STATUS_ERR_AUTH:\n\t\treturn -EINVAL;\n\tcase MAIL_OUT_STATUS_ERR_ACCESS:\n\t\treturn -EACCES;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int dma_port_request(struct tb_dma_port *dma, u32 in,\n\t\t\t    unsigned int timeout)\n{\n\tstruct tb_switch *sw = dma->sw;\n\tu32 out;\n\tint ret;\n\n\tret = dma_port_write(sw->tb->ctl, &in, tb_route(sw), dma->port,\n\t\t\t     dma->base + MAIL_IN, 1, DMA_PORT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_port_wait_for_completion(dma, timeout);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_port_read(sw->tb->ctl, &out, tb_route(sw), dma->port,\n\t\t\t    dma->base + MAIL_OUT, 1, DMA_PORT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status_to_errno(out);\n}\n\nstatic int dma_port_flash_read_block(void *data, unsigned int dwaddress,\n\t\t\t\t     void *buf, size_t dwords)\n{\n\tstruct tb_dma_port *dma = data;\n\tstruct tb_switch *sw = dma->sw;\n\tint ret;\n\tu32 in;\n\n\tin = MAIL_IN_CMD_FLASH_READ << MAIL_IN_CMD_SHIFT;\n\tif (dwords < MAIL_DATA_DWORDS)\n\t\tin |= (dwords << MAIL_IN_DWORDS_SHIFT) & MAIL_IN_DWORDS_MASK;\n\tin |= (dwaddress << MAIL_IN_ADDRESS_SHIFT) & MAIL_IN_ADDRESS_MASK;\n\tin |= MAIL_IN_OP_REQUEST;\n\n\tret = dma_port_request(dma, in, DMA_PORT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dma_port_read(sw->tb->ctl, buf, tb_route(sw), dma->port,\n\t\t\t     dma->base + MAIL_DATA, dwords, DMA_PORT_TIMEOUT);\n}\n\nstatic int dma_port_flash_write_block(void *data, unsigned int dwaddress,\n\t\t\t\t      const void *buf, size_t dwords)\n{\n\tstruct tb_dma_port *dma = data;\n\tstruct tb_switch *sw = dma->sw;\n\tint ret;\n\tu32 in;\n\n\t \n\tret = dma_port_write(sw->tb->ctl, buf, tb_route(sw), dma->port,\n\t\t\t    dma->base + MAIL_DATA, dwords, DMA_PORT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tin = MAIL_IN_CMD_FLASH_WRITE << MAIL_IN_CMD_SHIFT;\n\n\t \n\tif (dwaddress >= DMA_PORT_CSS_ADDRESS)\n\t\tin |= MAIL_IN_CSS;\n\n\tin |= ((dwords - 1) << MAIL_IN_DWORDS_SHIFT) & MAIL_IN_DWORDS_MASK;\n\tin |= (dwaddress << MAIL_IN_ADDRESS_SHIFT) & MAIL_IN_ADDRESS_MASK;\n\tin |= MAIL_IN_OP_REQUEST;\n\n\treturn dma_port_request(dma, in, DMA_PORT_TIMEOUT);\n}\n\n \nint dma_port_flash_read(struct tb_dma_port *dma, unsigned int address,\n\t\t\tvoid *buf, size_t size)\n{\n\treturn tb_nvm_read_data(address, buf, size, DMA_PORT_RETRIES,\n\t\t\t\tdma_port_flash_read_block, dma);\n}\n\n \nint dma_port_flash_write(struct tb_dma_port *dma, unsigned int address,\n\t\t\t const void *buf, size_t size)\n{\n\tif (address >= DMA_PORT_CSS_ADDRESS && size > DMA_PORT_CSS_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\treturn tb_nvm_write_data(address, buf, size, DMA_PORT_RETRIES,\n\t\t\t\t dma_port_flash_write_block, dma);\n}\n\n \nint dma_port_flash_update_auth(struct tb_dma_port *dma)\n{\n\tu32 in;\n\n\tin = MAIL_IN_CMD_FLASH_UPDATE_AUTH << MAIL_IN_CMD_SHIFT;\n\tin |= MAIL_IN_OP_REQUEST;\n\n\treturn dma_port_request(dma, in, 150);\n}\n\n \nint dma_port_flash_update_auth_status(struct tb_dma_port *dma, u32 *status)\n{\n\tstruct tb_switch *sw = dma->sw;\n\tu32 out, cmd;\n\tint ret;\n\n\tret = dma_port_read(sw->tb->ctl, &out, tb_route(sw), dma->port,\n\t\t\t    dma->base + MAIL_OUT, 1, DMA_PORT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcmd = (out & MAIL_OUT_STATUS_CMD_MASK) >> MAIL_OUT_STATUS_CMD_SHIFT;\n\tif (cmd == MAIL_IN_CMD_FLASH_UPDATE_AUTH) {\n\t\tif (status)\n\t\t\t*status = out & MAIL_OUT_STATUS_MASK;\n\n\t\t \n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint dma_port_power_cycle(struct tb_dma_port *dma)\n{\n\tu32 in;\n\n\tin = MAIL_IN_CMD_POWER_CYCLE << MAIL_IN_CMD_SHIFT;\n\tin |= MAIL_IN_OP_REQUEST;\n\n\treturn dma_port_request(dma, in, 150);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}