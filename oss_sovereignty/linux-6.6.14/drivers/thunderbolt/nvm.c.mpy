{
  "module_name": "nvm.c",
  "hash_id": "fe68e558cd2b26156e54f98c214e38c375275cafabacbe52d36d8942952721a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thunderbolt/nvm.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include \"tb.h\"\n\n#define NVM_MIN_SIZE\t\tSZ_32K\n#define NVM_MAX_SIZE\t\tSZ_1M\n#define NVM_DATA_DWORDS\t\t16\n\n \n#define INTEL_NVM_DEVID\t\t\t0x05\n#define INTEL_NVM_VERSION\t\t0x08\n#define INTEL_NVM_CSS\t\t\t0x10\n#define INTEL_NVM_FLASH_SIZE\t\t0x45\n\n \n#define ASMEDIA_NVM_DATE\t\t0x1c\n#define ASMEDIA_NVM_VERSION\t\t0x28\n\nstatic DEFINE_IDA(nvm_ida);\n\n \nstruct tb_nvm_vendor_ops {\n\tint (*read_version)(struct tb_nvm *nvm);\n\tint (*validate)(struct tb_nvm *nvm);\n\tint (*write_headers)(struct tb_nvm *nvm);\n};\n\n \nstruct tb_nvm_vendor {\n\tu16 vendor;\n\tconst struct tb_nvm_vendor_ops *vops;\n};\n\nstatic int intel_switch_nvm_version(struct tb_nvm *nvm)\n{\n\tstruct tb_switch *sw = tb_to_switch(nvm->dev);\n\tu32 val, nvm_size, hdr_size;\n\tint ret;\n\n\t \n\tif (sw->safe_mode)\n\t\treturn 0;\n\n\tret = tb_switch_nvm_read(sw, INTEL_NVM_FLASH_SIZE, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\thdr_size = sw->generation < 3 ? SZ_8K : SZ_16K;\n\tnvm_size = (SZ_1M << (val & 7)) / 8;\n\tnvm_size = (nvm_size - hdr_size) / 2;\n\n\tret = tb_switch_nvm_read(sw, INTEL_NVM_VERSION, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tnvm->major = (val >> 16) & 0xff;\n\tnvm->minor = (val >> 8) & 0xff;\n\tnvm->active_size = nvm_size;\n\n\treturn 0;\n}\n\nstatic int intel_switch_nvm_validate(struct tb_nvm *nvm)\n{\n\tstruct tb_switch *sw = tb_to_switch(nvm->dev);\n\tunsigned int image_size, hdr_size;\n\tu16 ds_size, device_id;\n\tu8 *buf = nvm->buf;\n\n\timage_size = nvm->buf_data_size;\n\n\t \n\thdr_size = (*(u32 *)buf) & 0xffffff;\n\tif (hdr_size + INTEL_NVM_DEVID + 2 >= image_size)\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ALIGNED(hdr_size, SZ_4K))\n\t\treturn -EINVAL;\n\n\t \n\tds_size = *(u16 *)(buf + hdr_size);\n\tif (ds_size >= image_size)\n\t\treturn -EINVAL;\n\n\tif (sw->safe_mode)\n\t\treturn 0;\n\n\t \n\tdevice_id = *(u16 *)(buf + hdr_size + INTEL_NVM_DEVID);\n\tif (device_id != sw->config.device_id)\n\t\treturn -EINVAL;\n\n\t \n\tnvm->buf_data_start = buf + hdr_size;\n\tnvm->buf_data_size = image_size - hdr_size;\n\n\treturn 0;\n}\n\nstatic int intel_switch_nvm_write_headers(struct tb_nvm *nvm)\n{\n\tstruct tb_switch *sw = tb_to_switch(nvm->dev);\n\n\tif (sw->generation < 3) {\n\t\tint ret;\n\n\t\t \n\t\tret = dma_port_flash_write(sw->dma_port,\n\t\t\tDMA_PORT_CSS_ADDRESS, nvm->buf + INTEL_NVM_CSS,\n\t\t\tDMA_PORT_CSS_MAX_SIZE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tb_nvm_vendor_ops intel_switch_nvm_ops = {\n\t.read_version = intel_switch_nvm_version,\n\t.validate = intel_switch_nvm_validate,\n\t.write_headers = intel_switch_nvm_write_headers,\n};\n\nstatic int asmedia_switch_nvm_version(struct tb_nvm *nvm)\n{\n\tstruct tb_switch *sw = tb_to_switch(nvm->dev);\n\tu32 val;\n\tint ret;\n\n\tret = tb_switch_nvm_read(sw, ASMEDIA_NVM_VERSION, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tnvm->major = (val << 16) & 0xff0000;\n\tnvm->major |= val & 0x00ff00;\n\tnvm->major |= (val >> 16) & 0x0000ff;\n\n\tret = tb_switch_nvm_read(sw, ASMEDIA_NVM_DATE, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tnvm->minor = (val << 16) & 0xff0000;\n\tnvm->minor |= val & 0x00ff00;\n\tnvm->minor |= (val >> 16) & 0x0000ff;\n\n\t \n\tnvm->active_size = SZ_512K;\n\n\treturn 0;\n}\n\nstatic const struct tb_nvm_vendor_ops asmedia_switch_nvm_ops = {\n\t.read_version = asmedia_switch_nvm_version,\n};\n\n \nstatic const struct tb_nvm_vendor switch_nvm_vendors[] = {\n\t{ 0x174c, &asmedia_switch_nvm_ops },\n\t{ PCI_VENDOR_ID_INTEL, &intel_switch_nvm_ops },\n\t{ 0x8087, &intel_switch_nvm_ops },\n};\n\nstatic int intel_retimer_nvm_version(struct tb_nvm *nvm)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(nvm->dev);\n\tu32 val, nvm_size;\n\tint ret;\n\n\tret = tb_retimer_nvm_read(rt, INTEL_NVM_VERSION, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tnvm->major = (val >> 16) & 0xff;\n\tnvm->minor = (val >> 8) & 0xff;\n\n\tret = tb_retimer_nvm_read(rt, INTEL_NVM_FLASH_SIZE, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tnvm_size = (SZ_1M << (val & 7)) / 8;\n\tnvm_size = (nvm_size - SZ_16K) / 2;\n\tnvm->active_size = nvm_size;\n\n\treturn 0;\n}\n\nstatic int intel_retimer_nvm_validate(struct tb_nvm *nvm)\n{\n\tstruct tb_retimer *rt = tb_to_retimer(nvm->dev);\n\tunsigned int image_size, hdr_size;\n\tu8 *buf = nvm->buf;\n\tu16 ds_size, device;\n\n\timage_size = nvm->buf_data_size;\n\n\t \n\thdr_size = (*(u32 *)buf) & 0xffffff;\n\tif (hdr_size + INTEL_NVM_DEVID + 2 >= image_size)\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ALIGNED(hdr_size, SZ_4K))\n\t\treturn -EINVAL;\n\n\t \n\tds_size = *(u16 *)(buf + hdr_size);\n\tif (ds_size >= image_size)\n\t\treturn -EINVAL;\n\n\t \n\tdevice = *(u16 *)(buf + hdr_size + INTEL_NVM_DEVID);\n\tif (device != rt->device)\n\t\treturn -EINVAL;\n\n\t \n\tnvm->buf_data_start = buf + hdr_size;\n\tnvm->buf_data_size = image_size - hdr_size;\n\n\treturn 0;\n}\n\nstatic const struct tb_nvm_vendor_ops intel_retimer_nvm_ops = {\n\t.read_version = intel_retimer_nvm_version,\n\t.validate = intel_retimer_nvm_validate,\n};\n\n \nstatic const struct tb_nvm_vendor retimer_nvm_vendors[] = {\n\t{ 0x8087, &intel_retimer_nvm_ops },\n};\n\n \nstruct tb_nvm *tb_nvm_alloc(struct device *dev)\n{\n\tconst struct tb_nvm_vendor_ops *vops = NULL;\n\tstruct tb_nvm *nvm;\n\tint ret, i;\n\n\tif (tb_is_switch(dev)) {\n\t\tconst struct tb_switch *sw = tb_to_switch(dev);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(switch_nvm_vendors); i++) {\n\t\t\tconst struct tb_nvm_vendor *v = &switch_nvm_vendors[i];\n\n\t\t\tif (v->vendor == sw->config.vendor_id) {\n\t\t\t\tvops = v->vops;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!vops) {\n\t\t\ttb_sw_dbg(sw, \"router NVM format of vendor %#x unknown\\n\",\n\t\t\t\t  sw->config.vendor_id);\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t} else if (tb_is_retimer(dev)) {\n\t\tconst struct tb_retimer *rt = tb_to_retimer(dev);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(retimer_nvm_vendors); i++) {\n\t\t\tconst struct tb_nvm_vendor *v = &retimer_nvm_vendors[i];\n\n\t\t\tif (v->vendor == rt->vendor) {\n\t\t\t\tvops = v->vops;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!vops) {\n\t\t\tdev_dbg(dev, \"retimer NVM format of vendor %#x unknown\\n\",\n\t\t\t\trt->vendor);\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t} else {\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tnvm = kzalloc(sizeof(*nvm), GFP_KERNEL);\n\tif (!nvm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_simple_get(&nvm_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(nvm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tnvm->id = ret;\n\tnvm->dev = dev;\n\tnvm->vops = vops;\n\n\treturn nvm;\n}\n\n \nint tb_nvm_read_version(struct tb_nvm *nvm)\n{\n\tconst struct tb_nvm_vendor_ops *vops = nvm->vops;\n\n\tif (vops && vops->read_version)\n\t\treturn vops->read_version(nvm);\n\n\treturn -EOPNOTSUPP;\n}\n\n \nint tb_nvm_validate(struct tb_nvm *nvm)\n{\n\tconst struct tb_nvm_vendor_ops *vops = nvm->vops;\n\tunsigned int image_size;\n\tu8 *buf = nvm->buf;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\tif (!vops)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\timage_size = nvm->buf_data_size;\n\tif (image_size < NVM_MIN_SIZE || image_size > NVM_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tnvm->buf_data_start = buf;\n\n\treturn vops->validate ? vops->validate(nvm) : 0;\n}\n\n \nint tb_nvm_write_headers(struct tb_nvm *nvm)\n{\n\tconst struct tb_nvm_vendor_ops *vops = nvm->vops;\n\n\treturn vops->write_headers ? vops->write_headers(nvm) : 0;\n}\n\n \nint tb_nvm_add_active(struct tb_nvm *nvm, nvmem_reg_read_t reg_read)\n{\n\tstruct nvmem_config config;\n\tstruct nvmem_device *nvmem;\n\n\tmemset(&config, 0, sizeof(config));\n\n\tconfig.name = \"nvm_active\";\n\tconfig.reg_read = reg_read;\n\tconfig.read_only = true;\n\tconfig.id = nvm->id;\n\tconfig.stride = 4;\n\tconfig.word_size = 4;\n\tconfig.size = nvm->active_size;\n\tconfig.dev = nvm->dev;\n\tconfig.owner = THIS_MODULE;\n\tconfig.priv = nvm;\n\n\tnvmem = nvmem_register(&config);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\tnvm->active = nvmem;\n\treturn 0;\n}\n\n \nint tb_nvm_write_buf(struct tb_nvm *nvm, unsigned int offset, void *val,\n\t\t     size_t bytes)\n{\n\tif (!nvm->buf) {\n\t\tnvm->buf = vmalloc(NVM_MAX_SIZE);\n\t\tif (!nvm->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnvm->flushed = false;\n\tnvm->buf_data_size = offset + bytes;\n\tmemcpy(nvm->buf + offset, val, bytes);\n\treturn 0;\n}\n\n \nint tb_nvm_add_non_active(struct tb_nvm *nvm, nvmem_reg_write_t reg_write)\n{\n\tstruct nvmem_config config;\n\tstruct nvmem_device *nvmem;\n\n\tmemset(&config, 0, sizeof(config));\n\n\tconfig.name = \"nvm_non_active\";\n\tconfig.reg_write = reg_write;\n\tconfig.root_only = true;\n\tconfig.id = nvm->id;\n\tconfig.stride = 4;\n\tconfig.word_size = 4;\n\tconfig.size = NVM_MAX_SIZE;\n\tconfig.dev = nvm->dev;\n\tconfig.owner = THIS_MODULE;\n\tconfig.priv = nvm;\n\n\tnvmem = nvmem_register(&config);\n\tif (IS_ERR(nvmem))\n\t\treturn PTR_ERR(nvmem);\n\n\tnvm->non_active = nvmem;\n\treturn 0;\n}\n\n \nvoid tb_nvm_free(struct tb_nvm *nvm)\n{\n\tif (nvm) {\n\t\tnvmem_unregister(nvm->non_active);\n\t\tnvmem_unregister(nvm->active);\n\t\tvfree(nvm->buf);\n\t\tida_simple_remove(&nvm_ida, nvm->id);\n\t}\n\tkfree(nvm);\n}\n\n \nint tb_nvm_read_data(unsigned int address, void *buf, size_t size,\n\t\t     unsigned int retries, read_block_fn read_block,\n\t\t     void *read_block_data)\n{\n\tdo {\n\t\tunsigned int dwaddress, dwords, offset;\n\t\tu8 data[NVM_DATA_DWORDS * 4];\n\t\tsize_t nbytes;\n\t\tint ret;\n\n\t\toffset = address & 3;\n\t\tnbytes = min_t(size_t, size + offset, NVM_DATA_DWORDS * 4);\n\n\t\tdwaddress = address / 4;\n\t\tdwords = ALIGN(nbytes, 4) / 4;\n\n\t\tret = read_block(read_block_data, dwaddress, data, dwords);\n\t\tif (ret) {\n\t\t\tif (ret != -ENODEV && retries--)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\t}\n\n\t\tnbytes -= offset;\n\t\tmemcpy(buf, data + offset, nbytes);\n\n\t\tsize -= nbytes;\n\t\taddress += nbytes;\n\t\tbuf += nbytes;\n\t} while (size > 0);\n\n\treturn 0;\n}\n\n \nint tb_nvm_write_data(unsigned int address, const void *buf, size_t size,\n\t\t      unsigned int retries, write_block_fn write_block,\n\t\t      void *write_block_data)\n{\n\tdo {\n\t\tunsigned int offset, dwaddress;\n\t\tu8 data[NVM_DATA_DWORDS * 4];\n\t\tsize_t nbytes;\n\t\tint ret;\n\n\t\toffset = address & 3;\n\t\tnbytes = min_t(u32, size + offset, NVM_DATA_DWORDS * 4);\n\n\t\tmemcpy(data + offset, buf, nbytes);\n\n\t\tdwaddress = address / 4;\n\t\tret = write_block(write_block_data, dwaddress, data, nbytes / 4);\n\t\tif (ret) {\n\t\t\tif (ret == -ETIMEDOUT) {\n\t\t\t\tif (retries--)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tsize -= nbytes;\n\t\taddress += nbytes;\n\t\tbuf += nbytes;\n\t} while (size > 0);\n\n\treturn 0;\n}\n\nvoid tb_nvm_exit(void)\n{\n\tida_destroy(&nvm_ida);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}