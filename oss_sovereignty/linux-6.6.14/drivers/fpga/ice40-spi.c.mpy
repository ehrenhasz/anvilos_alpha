{
  "module_name": "ice40-spi.c",
  "hash_id": "90306a268d75b94e5de0c69b663f2d25b58f1c9e0d29d2352047ebe29243ceb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/ice40-spi.c",
  "human_readable_source": "\n \n\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/spi/spi.h>\n#include <linux/stringify.h>\n\n#define ICE40_SPI_MAX_SPEED 25000000  \n#define ICE40_SPI_MIN_SPEED 1000000  \n\n#define ICE40_SPI_RESET_DELAY 1  \n#define ICE40_SPI_HOUSEKEEPING_DELAY 1200  \n\n#define ICE40_SPI_NUM_ACTIVATION_BYTES DIV_ROUND_UP(49, 8)\n\nstruct ice40_fpga_priv {\n\tstruct spi_device *dev;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *cdone;\n};\n\nstatic enum fpga_mgr_states ice40_fpga_ops_state(struct fpga_manager *mgr)\n{\n\tstruct ice40_fpga_priv *priv = mgr->priv;\n\n\treturn gpiod_get_value(priv->cdone) ? FPGA_MGR_STATE_OPERATING :\n\t\tFPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic int ice40_fpga_ops_write_init(struct fpga_manager *mgr,\n\t\t\t\t     struct fpga_image_info *info,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ice40_fpga_priv *priv = mgr->priv;\n\tstruct spi_device *dev = priv->dev;\n\tstruct spi_message message;\n\tstruct spi_transfer assert_cs_then_reset_delay = {\n\t\t.cs_change   = 1,\n\t\t.delay = {\n\t\t\t.value = ICE40_SPI_RESET_DELAY,\n\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t}\n\t};\n\tstruct spi_transfer housekeeping_delay_then_release_cs = {\n\t\t.delay = {\n\t\t\t.value = ICE40_SPI_HOUSEKEEPING_DELAY,\n\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t}\n\t};\n\tint ret;\n\n\tif ((info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Partial reconfiguration is not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tspi_bus_lock(dev->master);\n\n\tgpiod_set_value(priv->reset, 1);\n\n\tspi_message_init(&message);\n\tspi_message_add_tail(&assert_cs_then_reset_delay, &message);\n\tret = spi_sync_locked(dev, &message);\n\n\t \n\tgpiod_set_value(priv->reset, 0);\n\n\t \n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tif (gpiod_get_value(priv->cdone)) {\n\t\tdev_err(&dev->dev, \"Device reset failed, CDONE is asserted\\n\");\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tspi_message_init(&message);\n\tspi_message_add_tail(&housekeeping_delay_then_release_cs, &message);\n\tret = spi_sync_locked(dev, &message);\n\nfail:\n\tspi_bus_unlock(dev->master);\n\n\treturn ret;\n}\n\nstatic int ice40_fpga_ops_write(struct fpga_manager *mgr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ice40_fpga_priv *priv = mgr->priv;\n\n\treturn spi_write(priv->dev, buf, count);\n}\n\nstatic int ice40_fpga_ops_write_complete(struct fpga_manager *mgr,\n\t\t\t\t\t struct fpga_image_info *info)\n{\n\tstruct ice40_fpga_priv *priv = mgr->priv;\n\tstruct spi_device *dev = priv->dev;\n\tconst u8 padding[ICE40_SPI_NUM_ACTIVATION_BYTES] = {0};\n\n\t \n\tif (!gpiod_get_value(priv->cdone)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"CDONE was not asserted after firmware transfer\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\treturn spi_write(dev, padding, sizeof(padding));\n}\n\nstatic const struct fpga_manager_ops ice40_fpga_ops = {\n\t.state = ice40_fpga_ops_state,\n\t.write_init = ice40_fpga_ops_write_init,\n\t.write = ice40_fpga_ops_write,\n\t.write_complete = ice40_fpga_ops_write_complete,\n};\n\nstatic int ice40_fpga_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct ice40_fpga_priv *priv;\n\tstruct fpga_manager *mgr;\n\tint ret;\n\n\tpriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = spi;\n\n\t \n\tif (spi->max_speed_hz > ICE40_SPI_MAX_SPEED) {\n\t\tdev_err(dev, \"SPI speed is too high, maximum speed is \"\n\t\t\t__stringify(ICE40_SPI_MAX_SPEED) \"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (spi->max_speed_hz < ICE40_SPI_MIN_SPEED) {\n\t\tdev_err(dev, \"SPI speed is too low, minimum speed is \"\n\t\t\t__stringify(ICE40_SPI_MIN_SPEED) \"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (spi->mode & SPI_CPHA) {\n\t\tdev_err(dev, \"Bad SPI mode, CPHA not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->cdone = devm_gpiod_get(dev, \"cdone\", GPIOD_IN);\n\tif (IS_ERR(priv->cdone)) {\n\t\tret = PTR_ERR(priv->cdone);\n\t\tdev_err(dev, \"Failed to get CDONE GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset)) {\n\t\tret = PTR_ERR(priv->reset);\n\t\tdev_err(dev, \"Failed to get CRESET_B GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmgr = devm_fpga_mgr_register(dev, \"Lattice iCE40 FPGA Manager\",\n\t\t\t\t     &ice40_fpga_ops, priv);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\nstatic const struct of_device_id ice40_fpga_of_match[] = {\n\t{ .compatible = \"lattice,ice40-fpga-mgr\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ice40_fpga_of_match);\n\nstatic const struct spi_device_id ice40_fpga_spi_ids[] = {\n\t{ .name = \"ice40-fpga-mgr\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, ice40_fpga_spi_ids);\n\nstatic struct spi_driver ice40_fpga_driver = {\n\t.probe = ice40_fpga_probe,\n\t.driver = {\n\t\t.name = \"ice40spi\",\n\t\t.of_match_table = of_match_ptr(ice40_fpga_of_match),\n\t},\n\t.id_table = ice40_fpga_spi_ids,\n};\n\nmodule_spi_driver(ice40_fpga_driver);\n\nMODULE_AUTHOR(\"Joel Holdsworth <joel@airwebreathe.org.uk>\");\nMODULE_DESCRIPTION(\"Lattice iCE40 FPGA Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}