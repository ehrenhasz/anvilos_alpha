{
  "module_name": "fpga-mgr.c",
  "hash_id": "fc1e8914696e879bc57eb51825cac46e283a39723bf8ce3c0fd6e1a52d4947bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/fpga-mgr.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n\nstatic DEFINE_IDA(fpga_mgr_ida);\nstatic const struct class fpga_mgr_class;\n\nstruct fpga_mgr_devres {\n\tstruct fpga_manager *mgr;\n};\n\nstatic inline void fpga_mgr_fpga_remove(struct fpga_manager *mgr)\n{\n\tif (mgr->mops->fpga_remove)\n\t\tmgr->mops->fpga_remove(mgr);\n}\n\nstatic inline enum fpga_mgr_states fpga_mgr_state(struct fpga_manager *mgr)\n{\n\tif (mgr->mops->state)\n\t\treturn  mgr->mops->state(mgr);\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic inline u64 fpga_mgr_status(struct fpga_manager *mgr)\n{\n\tif (mgr->mops->status)\n\t\treturn mgr->mops->status(mgr);\n\treturn 0;\n}\n\nstatic inline int fpga_mgr_write(struct fpga_manager *mgr, const char *buf, size_t count)\n{\n\tif (mgr->mops->write)\n\t\treturn  mgr->mops->write(mgr, buf, count);\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic inline int fpga_mgr_write_complete(struct fpga_manager *mgr,\n\t\t\t\t\t  struct fpga_image_info *info)\n{\n\tint ret = 0;\n\n\tmgr->state = FPGA_MGR_STATE_WRITE_COMPLETE;\n\tif (mgr->mops->write_complete)\n\t\tret = mgr->mops->write_complete(mgr, info);\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error after writing image data to FPGA\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_WRITE_COMPLETE_ERR;\n\t\treturn ret;\n\t}\n\tmgr->state = FPGA_MGR_STATE_OPERATING;\n\n\treturn 0;\n}\n\nstatic inline int fpga_mgr_parse_header(struct fpga_manager *mgr,\n\t\t\t\t\tstruct fpga_image_info *info,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tif (mgr->mops->parse_header)\n\t\treturn mgr->mops->parse_header(mgr, info, buf, count);\n\treturn 0;\n}\n\nstatic inline int fpga_mgr_write_init(struct fpga_manager *mgr,\n\t\t\t\t      struct fpga_image_info *info,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tif (mgr->mops->write_init)\n\t\treturn  mgr->mops->write_init(mgr, info, buf, count);\n\treturn 0;\n}\n\nstatic inline int fpga_mgr_write_sg(struct fpga_manager *mgr,\n\t\t\t\t    struct sg_table *sgt)\n{\n\tif (mgr->mops->write_sg)\n\t\treturn  mgr->mops->write_sg(mgr, sgt);\n\treturn -EOPNOTSUPP;\n}\n\n \nstruct fpga_image_info *fpga_image_info_alloc(struct device *dev)\n{\n\tstruct fpga_image_info *info;\n\n\tget_device(dev);\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\n\tinfo->dev = dev;\n\n\treturn info;\n}\nEXPORT_SYMBOL_GPL(fpga_image_info_alloc);\n\n \nvoid fpga_image_info_free(struct fpga_image_info *info)\n{\n\tstruct device *dev;\n\n\tif (!info)\n\t\treturn;\n\n\tdev = info->dev;\n\tif (info->firmware_name)\n\t\tdevm_kfree(dev, info->firmware_name);\n\n\tdevm_kfree(dev, info);\n\tput_device(dev);\n}\nEXPORT_SYMBOL_GPL(fpga_image_info_free);\n\n \nstatic int fpga_mgr_parse_header_mapped(struct fpga_manager *mgr,\n\t\t\t\t\tstruct fpga_image_info *info,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret;\n\n\tmgr->state = FPGA_MGR_STATE_PARSE_HEADER;\n\tret = fpga_mgr_parse_header(mgr, info, buf, count);\n\n\tif (info->header_size + info->data_size > count) {\n\t\tdev_err(&mgr->dev, \"Bitstream data outruns FPGA image\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error while parsing FPGA image header\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_PARSE_HEADER_ERR;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int fpga_mgr_parse_header_sg_first(struct fpga_manager *mgr,\n\t\t\t\t\t  struct fpga_image_info *info,\n\t\t\t\t\t  struct sg_table *sgt)\n{\n\tstruct sg_mapping_iter miter;\n\tint ret;\n\n\tmgr->state = FPGA_MGR_STATE_PARSE_HEADER;\n\n\tsg_miter_start(&miter, sgt->sgl, sgt->nents, SG_MITER_FROM_SG);\n\tif (sg_miter_next(&miter) &&\n\t    miter.length >= info->header_size)\n\t\tret = fpga_mgr_parse_header(mgr, info, miter.addr, miter.length);\n\telse\n\t\tret = -EAGAIN;\n\tsg_miter_stop(&miter);\n\n\tif (ret && ret != -EAGAIN) {\n\t\tdev_err(&mgr->dev, \"Error while parsing FPGA image header\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_PARSE_HEADER_ERR;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void *fpga_mgr_parse_header_sg(struct fpga_manager *mgr,\n\t\t\t\t      struct fpga_image_info *info,\n\t\t\t\t      struct sg_table *sgt, size_t *ret_size)\n{\n\tsize_t len, new_header_size, header_size = 0;\n\tchar *new_buf, *buf = NULL;\n\tint ret;\n\n\tdo {\n\t\tnew_header_size = info->header_size;\n\t\tif (new_header_size <= header_size) {\n\t\t\tdev_err(&mgr->dev, \"Requested invalid header size\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_buf = krealloc(buf, new_header_size, GFP_KERNEL);\n\t\tif (!new_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = new_buf;\n\n\t\tlen = sg_pcopy_to_buffer(sgt->sgl, sgt->nents,\n\t\t\t\t\t buf + header_size,\n\t\t\t\t\t new_header_size - header_size,\n\t\t\t\t\t header_size);\n\t\tif (len != new_header_size - header_size) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\theader_size = new_header_size;\n\t\tret = fpga_mgr_parse_header(mgr, info, buf, header_size);\n\t} while (ret == -EAGAIN);\n\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error while parsing FPGA image header\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_PARSE_HEADER_ERR;\n\t\tkfree(buf);\n\t\tbuf = ERR_PTR(ret);\n\t}\n\n\t*ret_size = header_size;\n\n\treturn buf;\n}\n\n \nstatic int fpga_mgr_write_init_buf(struct fpga_manager *mgr,\n\t\t\t\t   struct fpga_image_info *info,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tsize_t header_size = info->header_size;\n\tint ret;\n\n\tmgr->state = FPGA_MGR_STATE_WRITE_INIT;\n\n\tif (header_size > count)\n\t\tret = -EINVAL;\n\telse if (!header_size)\n\t\tret = fpga_mgr_write_init(mgr, info, NULL, 0);\n\telse\n\t\tret = fpga_mgr_write_init(mgr, info, buf, count);\n\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error preparing FPGA for writing\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_WRITE_INIT_ERR;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fpga_mgr_prepare_sg(struct fpga_manager *mgr,\n\t\t\t       struct fpga_image_info *info,\n\t\t\t       struct sg_table *sgt)\n{\n\tstruct sg_mapping_iter miter;\n\tsize_t len;\n\tchar *buf;\n\tint ret;\n\n\t \n\tif (!mgr->mops->initial_header_size && !mgr->mops->parse_header)\n\t\treturn fpga_mgr_write_init_buf(mgr, info, NULL, 0);\n\n\t \n\tret = fpga_mgr_parse_header_sg_first(mgr, info, sgt);\n\t \n\tif (!ret) {\n\t\tsg_miter_start(&miter, sgt->sgl, sgt->nents, SG_MITER_FROM_SG);\n\t\tif (sg_miter_next(&miter)) {\n\t\t\tret = fpga_mgr_write_init_buf(mgr, info, miter.addr,\n\t\t\t\t\t\t      miter.length);\n\t\t\tsg_miter_stop(&miter);\n\t\t\treturn ret;\n\t\t}\n\t\tsg_miter_stop(&miter);\n\t \n\t} else if (ret != -EAGAIN) {\n\t\treturn ret;\n\t}\n\n\t \n\tbuf = fpga_mgr_parse_header_sg(mgr, info, sgt, &len);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = fpga_mgr_write_init_buf(mgr, info, buf, len);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\n \nstatic int fpga_mgr_buf_load_sg(struct fpga_manager *mgr,\n\t\t\t\tstruct fpga_image_info *info,\n\t\t\t\tstruct sg_table *sgt)\n{\n\tint ret;\n\n\tret = fpga_mgr_prepare_sg(mgr, info, sgt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmgr->state = FPGA_MGR_STATE_WRITE;\n\tif (mgr->mops->write_sg) {\n\t\tret = fpga_mgr_write_sg(mgr, sgt);\n\t} else {\n\t\tsize_t length, count = 0, data_size = info->data_size;\n\t\tstruct sg_mapping_iter miter;\n\n\t\tsg_miter_start(&miter, sgt->sgl, sgt->nents, SG_MITER_FROM_SG);\n\n\t\tif (mgr->mops->skip_header &&\n\t\t    !sg_miter_skip(&miter, info->header_size)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twhile (sg_miter_next(&miter)) {\n\t\t\tif (data_size)\n\t\t\t\tlength = min(miter.length, data_size - count);\n\t\t\telse\n\t\t\t\tlength = miter.length;\n\n\t\t\tret = fpga_mgr_write(mgr, miter.addr, length);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcount += length;\n\t\t\tif (data_size && count >= data_size)\n\t\t\t\tbreak;\n\t\t}\n\t\tsg_miter_stop(&miter);\n\t}\n\nout:\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error while writing image data to FPGA\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_WRITE_ERR;\n\t\treturn ret;\n\t}\n\n\treturn fpga_mgr_write_complete(mgr, info);\n}\n\nstatic int fpga_mgr_buf_load_mapped(struct fpga_manager *mgr,\n\t\t\t\t    struct fpga_image_info *info,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\n\tret = fpga_mgr_parse_header_mapped(mgr, info, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fpga_mgr_write_init_buf(mgr, info, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mgr->mops->skip_header) {\n\t\tbuf += info->header_size;\n\t\tcount -= info->header_size;\n\t}\n\n\tif (info->data_size)\n\t\tcount = info->data_size;\n\n\t \n\tmgr->state = FPGA_MGR_STATE_WRITE;\n\tret = fpga_mgr_write(mgr, buf, count);\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"Error while writing image data to FPGA\\n\");\n\t\tmgr->state = FPGA_MGR_STATE_WRITE_ERR;\n\t\treturn ret;\n\t}\n\n\treturn fpga_mgr_write_complete(mgr, info);\n}\n\n \nstatic int fpga_mgr_buf_load(struct fpga_manager *mgr,\n\t\t\t     struct fpga_image_info *info,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct page **pages;\n\tstruct sg_table sgt;\n\tconst void *p;\n\tint nr_pages;\n\tint index;\n\tint rc;\n\n\t \n\tif (mgr->mops->write)\n\t\treturn fpga_mgr_buf_load_mapped(mgr, info, buf, count);\n\n\t \n\tnr_pages = DIV_ROUND_UP((unsigned long)buf + count, PAGE_SIZE) -\n\t\t   (unsigned long)buf / PAGE_SIZE;\n\tpages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tp = buf - offset_in_page(buf);\n\tfor (index = 0; index < nr_pages; index++) {\n\t\tif (is_vmalloc_addr(p))\n\t\t\tpages[index] = vmalloc_to_page(p);\n\t\telse\n\t\t\tpages[index] = kmap_to_page((void *)p);\n\t\tif (!pages[index]) {\n\t\t\tkfree(pages);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tp += PAGE_SIZE;\n\t}\n\n\t \n\trc = sg_alloc_table_from_pages(&sgt, pages, index, offset_in_page(buf),\n\t\t\t\t       count, GFP_KERNEL);\n\tkfree(pages);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fpga_mgr_buf_load_sg(mgr, info, &sgt);\n\tsg_free_table(&sgt);\n\n\treturn rc;\n}\n\n \nstatic int fpga_mgr_firmware_load(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info,\n\t\t\t\t  const char *image_name)\n{\n\tstruct device *dev = &mgr->dev;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tdev_info(dev, \"writing %s to %s\\n\", image_name, mgr->name);\n\n\tmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ;\n\n\tret = request_firmware(&fw, image_name, dev);\n\tif (ret) {\n\t\tmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ_ERR;\n\t\tdev_err(dev, \"Error requesting firmware %s\\n\", image_name);\n\t\treturn ret;\n\t}\n\n\tret = fpga_mgr_buf_load(mgr, info, fw->data, fw->size);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\n \nint fpga_mgr_load(struct fpga_manager *mgr, struct fpga_image_info *info)\n{\n\tinfo->header_size = mgr->mops->initial_header_size;\n\n\tif (info->sgt)\n\t\treturn fpga_mgr_buf_load_sg(mgr, info, info->sgt);\n\tif (info->buf && info->count)\n\t\treturn fpga_mgr_buf_load(mgr, info, info->buf, info->count);\n\tif (info->firmware_name)\n\t\treturn fpga_mgr_firmware_load(mgr, info, info->firmware_name);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_load);\n\nstatic const char * const state_str[] = {\n\t[FPGA_MGR_STATE_UNKNOWN] =\t\t\"unknown\",\n\t[FPGA_MGR_STATE_POWER_OFF] =\t\t\"power off\",\n\t[FPGA_MGR_STATE_POWER_UP] =\t\t\"power up\",\n\t[FPGA_MGR_STATE_RESET] =\t\t\"reset\",\n\n\t \n\t[FPGA_MGR_STATE_FIRMWARE_REQ] =\t\t\"firmware request\",\n\t[FPGA_MGR_STATE_FIRMWARE_REQ_ERR] =\t\"firmware request error\",\n\n\t \n\t[FPGA_MGR_STATE_PARSE_HEADER] =\t\t\"parse header\",\n\t[FPGA_MGR_STATE_PARSE_HEADER_ERR] =\t\"parse header error\",\n\n\t \n\t[FPGA_MGR_STATE_WRITE_INIT] =\t\t\"write init\",\n\t[FPGA_MGR_STATE_WRITE_INIT_ERR] =\t\"write init error\",\n\n\t \n\t[FPGA_MGR_STATE_WRITE] =\t\t\"write\",\n\t[FPGA_MGR_STATE_WRITE_ERR] =\t\t\"write error\",\n\n\t \n\t[FPGA_MGR_STATE_WRITE_COMPLETE] =\t\"write complete\",\n\t[FPGA_MGR_STATE_WRITE_COMPLETE_ERR] =\t\"write complete error\",\n\n\t \n\t[FPGA_MGR_STATE_OPERATING] =\t\t\"operating\",\n};\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_manager *mgr = to_fpga_manager(dev);\n\n\treturn sprintf(buf, \"%s\\n\", mgr->name);\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_manager *mgr = to_fpga_manager(dev);\n\n\treturn sprintf(buf, \"%s\\n\", state_str[mgr->state]);\n}\n\nstatic ssize_t status_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_manager *mgr = to_fpga_manager(dev);\n\tu64 status;\n\tint len = 0;\n\n\tstatus = fpga_mgr_status(mgr);\n\n\tif (status & FPGA_MGR_STATUS_OPERATION_ERR)\n\t\tlen += sprintf(buf + len, \"reconfig operation error\\n\");\n\tif (status & FPGA_MGR_STATUS_CRC_ERR)\n\t\tlen += sprintf(buf + len, \"reconfig CRC error\\n\");\n\tif (status & FPGA_MGR_STATUS_INCOMPATIBLE_IMAGE_ERR)\n\t\tlen += sprintf(buf + len, \"reconfig incompatible image\\n\");\n\tif (status & FPGA_MGR_STATUS_IP_PROTOCOL_ERR)\n\t\tlen += sprintf(buf + len, \"reconfig IP protocol error\\n\");\n\tif (status & FPGA_MGR_STATUS_FIFO_OVERFLOW_ERR)\n\t\tlen += sprintf(buf + len, \"reconfig fifo overflow error\\n\");\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(name);\nstatic DEVICE_ATTR_RO(state);\nstatic DEVICE_ATTR_RO(status);\n\nstatic struct attribute *fpga_mgr_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_status.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(fpga_mgr);\n\nstatic struct fpga_manager *__fpga_mgr_get(struct device *dev)\n{\n\tstruct fpga_manager *mgr;\n\n\tmgr = to_fpga_manager(dev);\n\n\tif (!try_module_get(dev->parent->driver->owner))\n\t\tgoto err_dev;\n\n\treturn mgr;\n\nerr_dev:\n\tput_device(dev);\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int fpga_mgr_dev_match(struct device *dev, const void *data)\n{\n\treturn dev->parent == data;\n}\n\n \nstruct fpga_manager *fpga_mgr_get(struct device *dev)\n{\n\tstruct device *mgr_dev = class_find_device(&fpga_mgr_class, NULL, dev,\n\t\t\t\t\t\t   fpga_mgr_dev_match);\n\tif (!mgr_dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn __fpga_mgr_get(mgr_dev);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_get);\n\n \nstruct fpga_manager *of_fpga_mgr_get(struct device_node *node)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_of_node(&fpga_mgr_class, node);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn __fpga_mgr_get(dev);\n}\nEXPORT_SYMBOL_GPL(of_fpga_mgr_get);\n\n \nvoid fpga_mgr_put(struct fpga_manager *mgr)\n{\n\tmodule_put(mgr->dev.parent->driver->owner);\n\tput_device(&mgr->dev);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_put);\n\n \nint fpga_mgr_lock(struct fpga_manager *mgr)\n{\n\tif (!mutex_trylock(&mgr->ref_mutex)) {\n\t\tdev_err(&mgr->dev, \"FPGA manager is in use.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_lock);\n\n \nvoid fpga_mgr_unlock(struct fpga_manager *mgr)\n{\n\tmutex_unlock(&mgr->ref_mutex);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_unlock);\n\n \nstruct fpga_manager *\nfpga_mgr_register_full(struct device *parent, const struct fpga_manager_info *info)\n{\n\tconst struct fpga_manager_ops *mops = info->mops;\n\tstruct fpga_manager *mgr;\n\tint id, ret;\n\n\tif (!mops) {\n\t\tdev_err(parent, \"Attempt to register without fpga_manager_ops\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!info->name || !strlen(info->name)) {\n\t\tdev_err(parent, \"Attempt to register with no name!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\n\tif (!mgr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_alloc(&fpga_mgr_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tret = id;\n\t\tgoto error_kfree;\n\t}\n\n\tmutex_init(&mgr->ref_mutex);\n\n\tmgr->name = info->name;\n\tmgr->mops = info->mops;\n\tmgr->priv = info->priv;\n\tmgr->compat_id = info->compat_id;\n\n\tmgr->dev.class = &fpga_mgr_class;\n\tmgr->dev.groups = mops->groups;\n\tmgr->dev.parent = parent;\n\tmgr->dev.of_node = parent->of_node;\n\tmgr->dev.id = id;\n\n\tret = dev_set_name(&mgr->dev, \"fpga%d\", id);\n\tif (ret)\n\t\tgoto error_device;\n\n\t \n\tmgr->state = fpga_mgr_state(mgr);\n\n\tret = device_register(&mgr->dev);\n\tif (ret) {\n\t\tput_device(&mgr->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mgr;\n\nerror_device:\n\tida_free(&fpga_mgr_ida, id);\nerror_kfree:\n\tkfree(mgr);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_register_full);\n\n \nstruct fpga_manager *\nfpga_mgr_register(struct device *parent, const char *name,\n\t\t  const struct fpga_manager_ops *mops, void *priv)\n{\n\tstruct fpga_manager_info info = { 0 };\n\n\tinfo.name = name;\n\tinfo.mops = mops;\n\tinfo.priv = priv;\n\n\treturn fpga_mgr_register_full(parent, &info);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_register);\n\n \nvoid fpga_mgr_unregister(struct fpga_manager *mgr)\n{\n\tdev_info(&mgr->dev, \"%s %s\\n\", __func__, mgr->name);\n\n\t \n\tfpga_mgr_fpga_remove(mgr);\n\n\tdevice_unregister(&mgr->dev);\n}\nEXPORT_SYMBOL_GPL(fpga_mgr_unregister);\n\nstatic void devm_fpga_mgr_unregister(struct device *dev, void *res)\n{\n\tstruct fpga_mgr_devres *dr = res;\n\n\tfpga_mgr_unregister(dr->mgr);\n}\n\n \nstruct fpga_manager *\ndevm_fpga_mgr_register_full(struct device *parent, const struct fpga_manager_info *info)\n{\n\tstruct fpga_mgr_devres *dr;\n\tstruct fpga_manager *mgr;\n\n\tdr = devres_alloc(devm_fpga_mgr_unregister, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmgr = fpga_mgr_register_full(parent, info);\n\tif (IS_ERR(mgr)) {\n\t\tdevres_free(dr);\n\t\treturn mgr;\n\t}\n\n\tdr->mgr = mgr;\n\tdevres_add(parent, dr);\n\n\treturn mgr;\n}\nEXPORT_SYMBOL_GPL(devm_fpga_mgr_register_full);\n\n \nstruct fpga_manager *\ndevm_fpga_mgr_register(struct device *parent, const char *name,\n\t\t       const struct fpga_manager_ops *mops, void *priv)\n{\n\tstruct fpga_manager_info info = { 0 };\n\n\tinfo.name = name;\n\tinfo.mops = mops;\n\tinfo.priv = priv;\n\n\treturn devm_fpga_mgr_register_full(parent, &info);\n}\nEXPORT_SYMBOL_GPL(devm_fpga_mgr_register);\n\nstatic void fpga_mgr_dev_release(struct device *dev)\n{\n\tstruct fpga_manager *mgr = to_fpga_manager(dev);\n\n\tida_free(&fpga_mgr_ida, mgr->dev.id);\n\tkfree(mgr);\n}\n\nstatic const struct class fpga_mgr_class = {\n\t.name = \"fpga_manager\",\n\t.dev_groups = fpga_mgr_groups,\n\t.dev_release = fpga_mgr_dev_release,\n};\n\nstatic int __init fpga_mgr_class_init(void)\n{\n\tpr_info(\"FPGA manager framework\\n\");\n\n\treturn class_register(&fpga_mgr_class);\n}\n\nstatic void __exit fpga_mgr_class_exit(void)\n{\n\tclass_unregister(&fpga_mgr_class);\n\tida_destroy(&fpga_mgr_ida);\n}\n\nMODULE_AUTHOR(\"Alan Tull <atull@kernel.org>\");\nMODULE_DESCRIPTION(\"FPGA manager framework\");\nMODULE_LICENSE(\"GPL v2\");\n\nsubsys_initcall(fpga_mgr_class_init);\nmodule_exit(fpga_mgr_class_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}