{
  "module_name": "fpga-bridge.c",
  "hash_id": "67607b3179442e789f5b959aa64be84c5c1a29d7c9fd2e8e9612ce99841d7272",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/fpga-bridge.c",
  "human_readable_source": "\n \n#include <linux/fpga/fpga-bridge.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstatic DEFINE_IDA(fpga_bridge_ida);\nstatic const struct class fpga_bridge_class;\n\n \nstatic DEFINE_SPINLOCK(bridge_list_lock);\n\n \nint fpga_bridge_enable(struct fpga_bridge *bridge)\n{\n\tdev_dbg(&bridge->dev, \"enable\\n\");\n\n\tif (bridge->br_ops && bridge->br_ops->enable_set)\n\t\treturn bridge->br_ops->enable_set(bridge, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_enable);\n\n \nint fpga_bridge_disable(struct fpga_bridge *bridge)\n{\n\tdev_dbg(&bridge->dev, \"disable\\n\");\n\n\tif (bridge->br_ops && bridge->br_ops->enable_set)\n\t\treturn bridge->br_ops->enable_set(bridge, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_disable);\n\nstatic struct fpga_bridge *__fpga_bridge_get(struct device *dev,\n\t\t\t\t\t     struct fpga_image_info *info)\n{\n\tstruct fpga_bridge *bridge;\n\tint ret = -ENODEV;\n\n\tbridge = to_fpga_bridge(dev);\n\n\tbridge->info = info;\n\n\tif (!mutex_trylock(&bridge->mutex)) {\n\t\tret = -EBUSY;\n\t\tgoto err_dev;\n\t}\n\n\tif (!try_module_get(dev->parent->driver->owner))\n\t\tgoto err_ll_mod;\n\n\tdev_dbg(&bridge->dev, \"get\\n\");\n\n\treturn bridge;\n\nerr_ll_mod:\n\tmutex_unlock(&bridge->mutex);\nerr_dev:\n\tput_device(dev);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct fpga_bridge *of_fpga_bridge_get(struct device_node *np,\n\t\t\t\t       struct fpga_image_info *info)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_of_node(&fpga_bridge_class, np);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn __fpga_bridge_get(dev, info);\n}\nEXPORT_SYMBOL_GPL(of_fpga_bridge_get);\n\nstatic int fpga_bridge_dev_match(struct device *dev, const void *data)\n{\n\treturn dev->parent == data;\n}\n\n \nstruct fpga_bridge *fpga_bridge_get(struct device *dev,\n\t\t\t\t    struct fpga_image_info *info)\n{\n\tstruct device *bridge_dev;\n\n\tbridge_dev = class_find_device(&fpga_bridge_class, NULL, dev,\n\t\t\t\t       fpga_bridge_dev_match);\n\tif (!bridge_dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn __fpga_bridge_get(bridge_dev, info);\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_get);\n\n \nvoid fpga_bridge_put(struct fpga_bridge *bridge)\n{\n\tdev_dbg(&bridge->dev, \"put\\n\");\n\n\tbridge->info = NULL;\n\tmodule_put(bridge->dev.parent->driver->owner);\n\tmutex_unlock(&bridge->mutex);\n\tput_device(&bridge->dev);\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_put);\n\n \nint fpga_bridges_enable(struct list_head *bridge_list)\n{\n\tstruct fpga_bridge *bridge;\n\tint ret;\n\n\tlist_for_each_entry(bridge, bridge_list, node) {\n\t\tret = fpga_bridge_enable(bridge);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_bridges_enable);\n\n \nint fpga_bridges_disable(struct list_head *bridge_list)\n{\n\tstruct fpga_bridge *bridge;\n\tint ret;\n\n\tlist_for_each_entry(bridge, bridge_list, node) {\n\t\tret = fpga_bridge_disable(bridge);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_bridges_disable);\n\n \nvoid fpga_bridges_put(struct list_head *bridge_list)\n{\n\tstruct fpga_bridge *bridge, *next;\n\tunsigned long flags;\n\n\tlist_for_each_entry_safe(bridge, next, bridge_list, node) {\n\t\tfpga_bridge_put(bridge);\n\n\t\tspin_lock_irqsave(&bridge_list_lock, flags);\n\t\tlist_del(&bridge->node);\n\t\tspin_unlock_irqrestore(&bridge_list_lock, flags);\n\t}\n}\nEXPORT_SYMBOL_GPL(fpga_bridges_put);\n\n \nint of_fpga_bridge_get_to_list(struct device_node *np,\n\t\t\t       struct fpga_image_info *info,\n\t\t\t       struct list_head *bridge_list)\n{\n\tstruct fpga_bridge *bridge;\n\tunsigned long flags;\n\n\tbridge = of_fpga_bridge_get(np, info);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\tspin_lock_irqsave(&bridge_list_lock, flags);\n\tlist_add(&bridge->node, bridge_list);\n\tspin_unlock_irqrestore(&bridge_list_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_fpga_bridge_get_to_list);\n\n \nint fpga_bridge_get_to_list(struct device *dev,\n\t\t\t    struct fpga_image_info *info,\n\t\t\t    struct list_head *bridge_list)\n{\n\tstruct fpga_bridge *bridge;\n\tunsigned long flags;\n\n\tbridge = fpga_bridge_get(dev, info);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\tspin_lock_irqsave(&bridge_list_lock, flags);\n\tlist_add(&bridge->node, bridge_list);\n\tspin_unlock_irqrestore(&bridge_list_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_get_to_list);\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_bridge *bridge = to_fpga_bridge(dev);\n\n\treturn sprintf(buf, \"%s\\n\", bridge->name);\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_bridge *bridge = to_fpga_bridge(dev);\n\tint state = 1;\n\n\tif (bridge->br_ops && bridge->br_ops->enable_show) {\n\t\tstate = bridge->br_ops->enable_show(bridge);\n\t\tif (state < 0)\n\t\t\treturn state;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", state ? \"enabled\" : \"disabled\");\n}\n\nstatic DEVICE_ATTR_RO(name);\nstatic DEVICE_ATTR_RO(state);\n\nstatic struct attribute *fpga_bridge_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_state.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(fpga_bridge);\n\n \nstruct fpga_bridge *\nfpga_bridge_register(struct device *parent, const char *name,\n\t\t     const struct fpga_bridge_ops *br_ops,\n\t\t     void *priv)\n{\n\tstruct fpga_bridge *bridge;\n\tint id, ret;\n\n\tif (!br_ops) {\n\t\tdev_err(parent, \"Attempt to register without fpga_bridge_ops\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!name || !strlen(name)) {\n\t\tdev_err(parent, \"Attempt to register with no name!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_alloc(&fpga_bridge_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tret = id;\n\t\tgoto error_kfree;\n\t}\n\n\tmutex_init(&bridge->mutex);\n\tINIT_LIST_HEAD(&bridge->node);\n\n\tbridge->name = name;\n\tbridge->br_ops = br_ops;\n\tbridge->priv = priv;\n\n\tbridge->dev.groups = br_ops->groups;\n\tbridge->dev.class = &fpga_bridge_class;\n\tbridge->dev.parent = parent;\n\tbridge->dev.of_node = parent->of_node;\n\tbridge->dev.id = id;\n\n\tret = dev_set_name(&bridge->dev, \"br%d\", id);\n\tif (ret)\n\t\tgoto error_device;\n\n\tret = device_register(&bridge->dev);\n\tif (ret) {\n\t\tput_device(&bridge->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tof_platform_populate(bridge->dev.of_node, NULL, NULL, &bridge->dev);\n\n\treturn bridge;\n\nerror_device:\n\tida_free(&fpga_bridge_ida, id);\nerror_kfree:\n\tkfree(bridge);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_register);\n\n \nvoid fpga_bridge_unregister(struct fpga_bridge *bridge)\n{\n\t \n\tif (bridge->br_ops && bridge->br_ops->fpga_bridge_remove)\n\t\tbridge->br_ops->fpga_bridge_remove(bridge);\n\n\tdevice_unregister(&bridge->dev);\n}\nEXPORT_SYMBOL_GPL(fpga_bridge_unregister);\n\nstatic void fpga_bridge_dev_release(struct device *dev)\n{\n\tstruct fpga_bridge *bridge = to_fpga_bridge(dev);\n\n\tida_free(&fpga_bridge_ida, bridge->dev.id);\n\tkfree(bridge);\n}\n\nstatic const struct class fpga_bridge_class = {\n\t.name = \"fpga_bridge\",\n\t.dev_groups = fpga_bridge_groups,\n\t.dev_release = fpga_bridge_dev_release,\n};\n\nstatic int __init fpga_bridge_dev_init(void)\n{\n\treturn class_register(&fpga_bridge_class);\n}\n\nstatic void __exit fpga_bridge_dev_exit(void)\n{\n\tclass_unregister(&fpga_bridge_class);\n\tida_destroy(&fpga_bridge_ida);\n}\n\nMODULE_DESCRIPTION(\"FPGA Bridge Driver\");\nMODULE_AUTHOR(\"Alan Tull <atull@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n\nsubsys_initcall(fpga_bridge_dev_init);\nmodule_exit(fpga_bridge_dev_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}