{
  "module_name": "machxo2-spi.c",
  "hash_id": "9fd2aa82cba0f590536f194fe436ea28481e3096c90bfffb68bdc0e5d3c87bcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/machxo2-spi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n \n#define IDCODE_PUB\t\t{0xe0, 0x00, 0x00, 0x00}\n#define ISC_ENABLE\t\t{0xc6, 0x08, 0x00, 0x00}\n#define ISC_ERASE\t\t{0x0e, 0x04, 0x00, 0x00}\n#define ISC_PROGRAMDONE\t\t{0x5e, 0x00, 0x00, 0x00}\n#define LSC_INITADDRESS\t\t{0x46, 0x00, 0x00, 0x00}\n#define LSC_PROGINCRNV\t\t{0x70, 0x00, 0x00, 0x01}\n#define LSC_READ_STATUS\t\t{0x3c, 0x00, 0x00, 0x00}\n#define LSC_REFRESH\t\t{0x79, 0x00, 0x00, 0x00}\n\n \n#define MACHXO2_MAX_SPEED\t\t66000000\n\n#define MACHXO2_LOW_DELAY_USEC\t\t5\n#define MACHXO2_HIGH_DELAY_USEC\t\t200\n#define MACHXO2_REFRESH_USEC\t\t4800\n#define MACHXO2_MAX_BUSY_LOOP\t\t128\n#define MACHXO2_MAX_REFRESH_LOOP\t16\n\n#define MACHXO2_PAGE_SIZE\t\t16\n#define MACHXO2_BUF_SIZE\t\t(MACHXO2_PAGE_SIZE + 4)\n\n \n#define BUSY\t12\n#define DONE\t8\n#define DVER\t27\n#define ENAB\t9\n#define ERRBITS\t23\n#define ERRMASK\t7\n#define FAIL\t13\n\n#define ENOERR\t0  \n#define EID\t1\n#define ECMD\t2\n#define ECRC\t3\n#define EPREAM\t4  \n#define EABRT\t5  \n#define EOVERFL\t6  \n#define ESDMEOF\t7  \n\nstatic inline u8 get_err(unsigned long *status)\n{\n\treturn (*status >> ERRBITS) & ERRMASK;\n}\n\nstatic int get_status(struct spi_device *spi, unsigned long *status)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer rx, tx;\n\tstatic const u8 cmd[] = LSC_READ_STATUS;\n\tint ret;\n\n\tmemset(&rx, 0, sizeof(rx));\n\tmemset(&tx, 0, sizeof(tx));\n\ttx.tx_buf = cmd;\n\ttx.len = sizeof(cmd);\n\trx.rx_buf = status;\n\trx.len = 4;\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&tx, &msg);\n\tspi_message_add_tail(&rx, &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\t*status = be32_to_cpu(*status);\n\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic const char *get_err_string(u8 err)\n{\n\tswitch (err) {\n\tcase ENOERR:\treturn \"No Error\";\n\tcase EID:\treturn \"ID ERR\";\n\tcase ECMD:\treturn \"CMD ERR\";\n\tcase ECRC:\treturn \"CRC ERR\";\n\tcase EPREAM:\treturn \"Preamble ERR\";\n\tcase EABRT:\treturn \"Abort ERR\";\n\tcase EOVERFL:\treturn \"Overflow ERR\";\n\tcase ESDMEOF:\treturn \"SDM EOF\";\n\t}\n\n\treturn \"Default switch case\";\n}\n#endif\n\nstatic void dump_status_reg(unsigned long *status)\n{\n#ifdef DEBUG\n\tpr_debug(\"machxo2 status: 0x%08lX - done=%d, cfgena=%d, busy=%d, fail=%d, devver=%d, err=%s\\n\",\n\t\t *status, test_bit(DONE, status), test_bit(ENAB, status),\n\t\t test_bit(BUSY, status), test_bit(FAIL, status),\n\t\t test_bit(DVER, status), get_err_string(get_err(status)));\n#endif\n}\n\nstatic int wait_until_not_busy(struct spi_device *spi)\n{\n\tunsigned long status;\n\tint ret, loop = 0;\n\n\tdo {\n\t\tret = get_status(spi, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (++loop >= MACHXO2_MAX_BUSY_LOOP)\n\t\t\treturn -EBUSY;\n\t} while (test_bit(BUSY, &status));\n\n\treturn 0;\n}\n\nstatic int machxo2_cleanup(struct fpga_manager *mgr)\n{\n\tstruct spi_device *spi = mgr->priv;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx[2];\n\tstatic const u8 erase[] = ISC_ERASE;\n\tstatic const u8 refresh[] = LSC_REFRESH;\n\tint ret;\n\n\tmemset(tx, 0, sizeof(tx));\n\tspi_message_init(&msg);\n\ttx[0].tx_buf = &erase;\n\ttx[0].len = sizeof(erase);\n\tspi_message_add_tail(&tx[0], &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = wait_until_not_busy(spi);\n\tif (ret)\n\t\tgoto fail;\n\n\tspi_message_init(&msg);\n\ttx[1].tx_buf = &refresh;\n\ttx[1].len = sizeof(refresh);\n\ttx[1].delay.value = MACHXO2_REFRESH_USEC;\n\ttx[1].delay.unit = SPI_DELAY_UNIT_USECS;\n\tspi_message_add_tail(&tx[1], &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdev_err(&mgr->dev, \"Cleanup failed\\n\");\n\n\treturn ret;\n}\n\nstatic enum fpga_mgr_states machxo2_spi_state(struct fpga_manager *mgr)\n{\n\tstruct spi_device *spi = mgr->priv;\n\tunsigned long status;\n\n\tget_status(spi, &status);\n\tif (!test_bit(BUSY, &status) && test_bit(DONE, &status) &&\n\t    get_err(&status) == ENOERR)\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic int machxo2_write_init(struct fpga_manager *mgr,\n\t\t\t      struct fpga_image_info *info,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct spi_device *spi = mgr->priv;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx[3];\n\tstatic const u8 enable[] = ISC_ENABLE;\n\tstatic const u8 erase[] = ISC_ERASE;\n\tstatic const u8 initaddr[] = LSC_INITADDRESS;\n\tunsigned long status;\n\tint ret;\n\n\tif ((info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\tdev_err(&mgr->dev,\n\t\t\t\"Partial reconfiguration is not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\tmemset(tx, 0, sizeof(tx));\n\tspi_message_init(&msg);\n\ttx[0].tx_buf = &enable;\n\ttx[0].len = sizeof(enable);\n\ttx[0].delay.value = MACHXO2_LOW_DELAY_USEC;\n\ttx[0].delay.unit = SPI_DELAY_UNIT_USECS;\n\tspi_message_add_tail(&tx[0], &msg);\n\n\ttx[1].tx_buf = &erase;\n\ttx[1].len = sizeof(erase);\n\tspi_message_add_tail(&tx[1], &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = wait_until_not_busy(spi);\n\tif (ret)\n\t\tgoto fail;\n\n\tget_status(spi, &status);\n\tif (test_bit(FAIL, &status)) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\tdump_status_reg(&status);\n\n\tspi_message_init(&msg);\n\ttx[2].tx_buf = &initaddr;\n\ttx[2].len = sizeof(initaddr);\n\tspi_message_add_tail(&tx[2], &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\n\treturn 0;\nfail:\n\tdev_err(&mgr->dev, \"Error during FPGA init.\\n\");\n\n\treturn ret;\n}\n\nstatic int machxo2_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t size_t count)\n{\n\tstruct spi_device *spi = mgr->priv;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx;\n\tstatic const u8 progincr[] = LSC_PROGINCRNV;\n\tu8 payload[MACHXO2_BUF_SIZE];\n\tunsigned long status;\n\tint i, ret;\n\n\tif (count % MACHXO2_PAGE_SIZE != 0) {\n\t\tdev_err(&mgr->dev, \"Malformed payload.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\tmemcpy(payload, &progincr, sizeof(progincr));\n\tfor (i = 0; i < count; i += MACHXO2_PAGE_SIZE) {\n\t\tmemcpy(&payload[sizeof(progincr)], &buf[i], MACHXO2_PAGE_SIZE);\n\t\tmemset(&tx, 0, sizeof(tx));\n\t\tspi_message_init(&msg);\n\t\ttx.tx_buf = payload;\n\t\ttx.len = MACHXO2_BUF_SIZE;\n\t\ttx.delay.value = MACHXO2_HIGH_DELAY_USEC;\n\t\ttx.delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tspi_message_add_tail(&tx, &msg);\n\t\tret = spi_sync(spi, &msg);\n\t\tif (ret) {\n\t\t\tdev_err(&mgr->dev, \"Error loading the bitstream.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\n\treturn 0;\n}\n\nstatic int machxo2_write_complete(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info)\n{\n\tstruct spi_device *spi = mgr->priv;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx[2];\n\tstatic const u8 progdone[] = ISC_PROGRAMDONE;\n\tstatic const u8 refresh[] = LSC_REFRESH;\n\tunsigned long status;\n\tint ret, refreshloop = 0;\n\n\tmemset(tx, 0, sizeof(tx));\n\tspi_message_init(&msg);\n\ttx[0].tx_buf = &progdone;\n\ttx[0].len = sizeof(progdone);\n\tspi_message_add_tail(&tx[0], &msg);\n\tret = spi_sync(spi, &msg);\n\tif (ret)\n\t\tgoto fail;\n\tret = wait_until_not_busy(spi);\n\tif (ret)\n\t\tgoto fail;\n\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\tif (!test_bit(DONE, &status)) {\n\t\tmachxo2_cleanup(mgr);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tdo {\n\t\tspi_message_init(&msg);\n\t\ttx[1].tx_buf = &refresh;\n\t\ttx[1].len = sizeof(refresh);\n\t\ttx[1].delay.value = MACHXO2_REFRESH_USEC;\n\t\ttx[1].delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tspi_message_add_tail(&tx[1], &msg);\n\t\tret = spi_sync(spi, &msg);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tget_status(spi, &status);\n\t\tdump_status_reg(&status);\n\t\tif (!test_bit(BUSY, &status) && test_bit(DONE, &status) &&\n\t\t    get_err(&status) == ENOERR)\n\t\t\tbreak;\n\t\tif (++refreshloop == MACHXO2_MAX_REFRESH_LOOP) {\n\t\t\tmachxo2_cleanup(mgr);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t} while (1);\n\n\tget_status(spi, &status);\n\tdump_status_reg(&status);\n\n\treturn 0;\nfail:\n\tdev_err(&mgr->dev, \"Refresh failed.\\n\");\n\n\treturn ret;\n}\n\nstatic const struct fpga_manager_ops machxo2_ops = {\n\t.state = machxo2_spi_state,\n\t.write_init = machxo2_write_init,\n\t.write = machxo2_write,\n\t.write_complete = machxo2_write_complete,\n};\n\nstatic int machxo2_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct fpga_manager *mgr;\n\n\tif (spi->max_speed_hz > MACHXO2_MAX_SPEED) {\n\t\tdev_err(dev, \"Speed is too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmgr = devm_fpga_mgr_register(dev, \"Lattice MachXO2 SPI FPGA Manager\",\n\t\t\t\t     &machxo2_ops, spi);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_match[] = {\n\t{ .compatible = \"lattice,machxo2-slave-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_match);\n#endif\n\nstatic const struct spi_device_id lattice_ids[] = {\n\t{ \"machxo2-slave-spi\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, lattice_ids);\n\nstatic struct spi_driver machxo2_spi_driver = {\n\t.driver = {\n\t\t.name = \"machxo2-slave-spi\",\n\t\t.of_match_table = of_match_ptr(of_match),\n\t},\n\t.probe = machxo2_spi_probe,\n\t.id_table = lattice_ids,\n};\n\nmodule_spi_driver(machxo2_spi_driver)\n\nMODULE_AUTHOR(\"Paolo Pisati <p.pisati@gmail.com>\");\nMODULE_DESCRIPTION(\"Load Lattice FPGA firmware over SPI\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}