{
  "module_name": "dfl-afu-dma-region.c",
  "hash_id": "4fac71551866b25fb0c50c83f1b60817df3d69653832b614821c070aa8894b0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-afu-dma-region.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n\n#include \"dfl-afu.h\"\n\nvoid afu_dma_region_init(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\n\tafu->dma_regions = RB_ROOT;\n}\n\n \nstatic int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,\n\t\t\t     struct dfl_afu_dma_region *region)\n{\n\tint npages = region->length >> PAGE_SHIFT;\n\tstruct device *dev = &pdata->dev->dev;\n\tint ret, pinned;\n\n\tret = account_locked_vm(current->mm, npages, true);\n\tif (ret)\n\t\treturn ret;\n\n\tregion->pages = kcalloc(npages, sizeof(struct page *), GFP_KERNEL);\n\tif (!region->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock_vm;\n\t}\n\n\tpinned = pin_user_pages_fast(region->user_addr, npages, FOLL_WRITE,\n\t\t\t\t     region->pages);\n\tif (pinned < 0) {\n\t\tret = pinned;\n\t\tgoto free_pages;\n\t} else if (pinned != npages) {\n\t\tret = -EFAULT;\n\t\tgoto unpin_pages;\n\t}\n\n\tdev_dbg(dev, \"%d pages pinned\\n\", pinned);\n\n\treturn 0;\n\nunpin_pages:\n\tunpin_user_pages(region->pages, pinned);\nfree_pages:\n\tkfree(region->pages);\nunlock_vm:\n\taccount_locked_vm(current->mm, npages, false);\n\treturn ret;\n}\n\n \nstatic void afu_dma_unpin_pages(struct dfl_feature_platform_data *pdata,\n\t\t\t\tstruct dfl_afu_dma_region *region)\n{\n\tlong npages = region->length >> PAGE_SHIFT;\n\tstruct device *dev = &pdata->dev->dev;\n\n\tunpin_user_pages(region->pages, npages);\n\tkfree(region->pages);\n\taccount_locked_vm(current->mm, npages, false);\n\n\tdev_dbg(dev, \"%ld pages unpinned\\n\", npages);\n}\n\n \nstatic bool afu_dma_check_continuous_pages(struct dfl_afu_dma_region *region)\n{\n\tint npages = region->length >> PAGE_SHIFT;\n\tint i;\n\n\tfor (i = 0; i < npages - 1; i++)\n\t\tif (page_to_pfn(region->pages[i]) + 1 !=\n\t\t\t\tpage_to_pfn(region->pages[i + 1]))\n\t\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool dma_region_check_iova(struct dfl_afu_dma_region *region,\n\t\t\t\t  u64 iova, u64 size)\n{\n\tif (!size && region->iova != iova)\n\t\treturn false;\n\n\treturn (region->iova <= iova) &&\n\t\t(region->length + region->iova >= iova + size);\n}\n\n \nstatic int afu_dma_region_add(struct dfl_feature_platform_data *pdata,\n\t\t\t      struct dfl_afu_dma_region *region)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\tstruct rb_node **new, *parent = NULL;\n\n\tdev_dbg(&pdata->dev->dev, \"add region (iova = %llx)\\n\",\n\t\t(unsigned long long)region->iova);\n\n\tnew = &afu->dma_regions.rb_node;\n\n\twhile (*new) {\n\t\tstruct dfl_afu_dma_region *this;\n\n\t\tthis = container_of(*new, struct dfl_afu_dma_region, node);\n\n\t\tparent = *new;\n\n\t\tif (dma_region_check_iova(this, region->iova, region->length))\n\t\t\treturn -EEXIST;\n\n\t\tif (region->iova < this->iova)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (region->iova > this->iova)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&region->node, parent, new);\n\trb_insert_color(&region->node, &afu->dma_regions);\n\n\treturn 0;\n}\n\n \nstatic void afu_dma_region_remove(struct dfl_feature_platform_data *pdata,\n\t\t\t\t  struct dfl_afu_dma_region *region)\n{\n\tstruct dfl_afu *afu;\n\n\tdev_dbg(&pdata->dev->dev, \"del region (iova = %llx)\\n\",\n\t\t(unsigned long long)region->iova);\n\n\tafu = dfl_fpga_pdata_get_private(pdata);\n\trb_erase(&region->node, &afu->dma_regions);\n}\n\n \nvoid afu_dma_region_destroy(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\tstruct rb_node *node = rb_first(&afu->dma_regions);\n\tstruct dfl_afu_dma_region *region;\n\n\twhile (node) {\n\t\tregion = container_of(node, struct dfl_afu_dma_region, node);\n\n\t\tdev_dbg(&pdata->dev->dev, \"del region (iova = %llx)\\n\",\n\t\t\t(unsigned long long)region->iova);\n\n\t\trb_erase(node, &afu->dma_regions);\n\n\t\tif (region->iova)\n\t\t\tdma_unmap_page(dfl_fpga_pdata_to_parent(pdata),\n\t\t\t\t       region->iova, region->length,\n\t\t\t\t       DMA_BIDIRECTIONAL);\n\n\t\tif (region->pages)\n\t\t\tafu_dma_unpin_pages(pdata, region);\n\n\t\tnode = rb_next(node);\n\t\tkfree(region);\n\t}\n}\n\n \nstruct dfl_afu_dma_region *\nafu_dma_region_find(struct dfl_feature_platform_data *pdata, u64 iova, u64 size)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\tstruct rb_node *node = afu->dma_regions.rb_node;\n\tstruct device *dev = &pdata->dev->dev;\n\n\twhile (node) {\n\t\tstruct dfl_afu_dma_region *region;\n\n\t\tregion = container_of(node, struct dfl_afu_dma_region, node);\n\n\t\tif (dma_region_check_iova(region, iova, size)) {\n\t\t\tdev_dbg(dev, \"find region (iova = %llx)\\n\",\n\t\t\t\t(unsigned long long)region->iova);\n\t\t\treturn region;\n\t\t}\n\n\t\tif (iova < region->iova)\n\t\t\tnode = node->rb_left;\n\t\telse if (iova > region->iova)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\t \n\t\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"region with iova %llx and size %llx is not found\\n\",\n\t\t(unsigned long long)iova, (unsigned long long)size);\n\n\treturn NULL;\n}\n\n \nstatic struct dfl_afu_dma_region *\nafu_dma_region_find_iova(struct dfl_feature_platform_data *pdata, u64 iova)\n{\n\treturn afu_dma_region_find(pdata, iova, 0);\n}\n\n \nint afu_dma_map_region(struct dfl_feature_platform_data *pdata,\n\t\t       u64 user_addr, u64 length, u64 *iova)\n{\n\tstruct dfl_afu_dma_region *region;\n\tint ret;\n\n\t \n\tif (!PAGE_ALIGNED(user_addr) || !PAGE_ALIGNED(length) || !length)\n\t\treturn -EINVAL;\n\n\t \n\tif (user_addr + length < user_addr)\n\t\treturn -EINVAL;\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->user_addr = user_addr;\n\tregion->length = length;\n\n\t \n\tret = afu_dma_pin_pages(pdata, region);\n\tif (ret) {\n\t\tdev_err(&pdata->dev->dev, \"failed to pin memory region\\n\");\n\t\tgoto free_region;\n\t}\n\n\t \n\tif (!afu_dma_check_continuous_pages(region)) {\n\t\tdev_err(&pdata->dev->dev, \"pages are not continuous\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unpin_pages;\n\t}\n\n\t \n\tregion->iova = dma_map_page(dfl_fpga_pdata_to_parent(pdata),\n\t\t\t\t    region->pages[0], 0,\n\t\t\t\t    region->length,\n\t\t\t\t    DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dfl_fpga_pdata_to_parent(pdata), region->iova)) {\n\t\tdev_err(&pdata->dev->dev, \"failed to map for dma\\n\");\n\t\tret = -EFAULT;\n\t\tgoto unpin_pages;\n\t}\n\n\t*iova = region->iova;\n\n\tmutex_lock(&pdata->lock);\n\tret = afu_dma_region_add(pdata, region);\n\tmutex_unlock(&pdata->lock);\n\tif (ret) {\n\t\tdev_err(&pdata->dev->dev, \"failed to add dma region\\n\");\n\t\tgoto unmap_dma;\n\t}\n\n\treturn 0;\n\nunmap_dma:\n\tdma_unmap_page(dfl_fpga_pdata_to_parent(pdata),\n\t\t       region->iova, region->length, DMA_BIDIRECTIONAL);\nunpin_pages:\n\tafu_dma_unpin_pages(pdata, region);\nfree_region:\n\tkfree(region);\n\treturn ret;\n}\n\n \nint afu_dma_unmap_region(struct dfl_feature_platform_data *pdata, u64 iova)\n{\n\tstruct dfl_afu_dma_region *region;\n\n\tmutex_lock(&pdata->lock);\n\tregion = afu_dma_region_find_iova(pdata, iova);\n\tif (!region) {\n\t\tmutex_unlock(&pdata->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (region->in_use) {\n\t\tmutex_unlock(&pdata->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tafu_dma_region_remove(pdata, region);\n\tmutex_unlock(&pdata->lock);\n\n\tdma_unmap_page(dfl_fpga_pdata_to_parent(pdata),\n\t\t       region->iova, region->length, DMA_BIDIRECTIONAL);\n\tafu_dma_unpin_pages(pdata, region);\n\tkfree(region);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}