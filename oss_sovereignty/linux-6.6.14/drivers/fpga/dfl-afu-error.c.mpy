{
  "module_name": "dfl-afu-error.c",
  "hash_id": "ab248bf91b38e250d99a9979d00fae57de9cb79d952b866ee0ee84a94bf9d964",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-afu-error.c",
  "human_readable_source": "\n \n\n#include <linux/fpga-dfl.h>\n#include <linux/uaccess.h>\n\n#include \"dfl-afu.h\"\n\n#define PORT_ERROR_MASK\t\t0x8\n#define PORT_ERROR\t\t0x10\n#define PORT_FIRST_ERROR\t0x18\n#define PORT_MALFORMED_REQ0\t0x20\n#define PORT_MALFORMED_REQ1\t0x28\n\n#define ERROR_MASK\t\tGENMASK_ULL(63, 0)\n\n \nstatic void __afu_port_err_mask(struct device *dev, bool mask)\n{\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);\n\n\twriteq(mask ? ERROR_MASK : 0, base + PORT_ERROR_MASK);\n}\n\nstatic void afu_port_err_mask(struct device *dev, bool mask)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\n\tmutex_lock(&pdata->lock);\n\t__afu_port_err_mask(dev, mask);\n\tmutex_unlock(&pdata->lock);\n}\n\n \nstatic int afu_port_err_clear(struct device *dev, u64 err)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tvoid __iomem *base_err, *base_hdr;\n\tint enable_ret = 0, ret = -EBUSY;\n\tu64 v;\n\n\tbase_err = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);\n\tbase_hdr = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\n\t \n\n\t \n\tv = readq(base_hdr + PORT_HDR_STS);\n\tif (FIELD_GET(PORT_STS_PWR_STATE, v) == PORT_STS_PWR_STATE_AP6) {\n\t\tdev_err(dev, \"Could not clear errors, device in AP6 state.\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = __afu_port_disable(pdev);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\t__afu_port_err_mask(dev, true);\n\n\t \n\tv = readq(base_err + PORT_ERROR);\n\n\tif (v == err) {\n\t\twriteq(v, base_err + PORT_ERROR);\n\n\t\tv = readq(base_err + PORT_FIRST_ERROR);\n\t\twriteq(v, base_err + PORT_FIRST_ERROR);\n\t} else {\n\t\tdev_warn(dev, \"%s: received 0x%llx, expected 0x%llx\\n\",\n\t\t\t __func__, v, err);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\t__afu_port_err_mask(dev, false);\n\n\t \n\tenable_ret = __afu_port_enable(pdev);\n\ndone:\n\tmutex_unlock(&pdata->lock);\n\treturn enable_ret ? enable_ret : ret;\n}\n\nstatic ssize_t errors_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 error;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);\n\n\tmutex_lock(&pdata->lock);\n\terror = readq(base + PORT_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)error);\n}\n\nstatic ssize_t errors_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buff, size_t count)\n{\n\tu64 value;\n\tint ret;\n\n\tif (kstrtou64(buff, 0, &value))\n\t\treturn -EINVAL;\n\n\tret = afu_port_err_clear(dev, value);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(errors);\n\nstatic ssize_t first_error_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 error;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);\n\n\tmutex_lock(&pdata->lock);\n\terror = readq(base + PORT_FIRST_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)error);\n}\nstatic DEVICE_ATTR_RO(first_error);\n\nstatic ssize_t first_malformed_req_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 req0, req1;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);\n\n\tmutex_lock(&pdata->lock);\n\treq0 = readq(base + PORT_MALFORMED_REQ0);\n\treq1 = readq(base + PORT_MALFORMED_REQ1);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%016llx%016llx\\n\",\n\t\t       (unsigned long long)req1, (unsigned long long)req0);\n}\nstatic DEVICE_ATTR_RO(first_malformed_req);\n\nstatic struct attribute *port_err_attrs[] = {\n\t&dev_attr_errors.attr,\n\t&dev_attr_first_error.attr,\n\t&dev_attr_first_malformed_req.attr,\n\tNULL,\n};\n\nstatic umode_t port_err_attrs_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\t \n\tif (!dfl_get_feature_by_id(dev, PORT_FEATURE_ID_ERROR))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nconst struct attribute_group port_err_group = {\n\t.name       = \"errors\",\n\t.attrs      = port_err_attrs,\n\t.is_visible = port_err_attrs_visible,\n};\n\nstatic int port_err_init(struct platform_device *pdev,\n\t\t\t struct dfl_feature *feature)\n{\n\tafu_port_err_mask(&pdev->dev, false);\n\n\treturn 0;\n}\n\nstatic void port_err_uinit(struct platform_device *pdev,\n\t\t\t   struct dfl_feature *feature)\n{\n\tafu_port_err_mask(&pdev->dev, true);\n}\n\nstatic long\nport_err_ioctl(struct platform_device *pdev, struct dfl_feature *feature,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase DFL_FPGA_PORT_ERR_GET_IRQ_NUM:\n\t\treturn dfl_feature_ioctl_get_num_irqs(pdev, feature, arg);\n\tcase DFL_FPGA_PORT_ERR_SET_IRQ:\n\t\treturn dfl_feature_ioctl_set_irq(pdev, feature, arg);\n\tdefault:\n\t\tdev_dbg(&pdev->dev, \"%x cmd not handled\", cmd);\n\t\treturn -ENODEV;\n\t}\n}\n\nconst struct dfl_feature_id port_err_id_table[] = {\n\t{.id = PORT_FEATURE_ID_ERROR,},\n\t{0,}\n};\n\nconst struct dfl_feature_ops port_err_ops = {\n\t.init = port_err_init,\n\t.uinit = port_err_uinit,\n\t.ioctl = port_err_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}