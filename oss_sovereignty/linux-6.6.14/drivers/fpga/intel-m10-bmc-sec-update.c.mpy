{
  "module_name": "intel-m10-bmc-sec-update.c",
  "hash_id": "d23e9895d11bd47c346963864832c22e8453fca24dccaebbef81fd0713aa1248",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/intel-m10-bmc-sec-update.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/mfd/intel-m10-bmc.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nstruct m10bmc_sec;\n\nstruct m10bmc_sec_ops {\n\tint (*rsu_status)(struct m10bmc_sec *sec);\n};\n\nstruct m10bmc_sec {\n\tstruct device *dev;\n\tstruct intel_m10bmc *m10bmc;\n\tstruct fw_upload *fwl;\n\tchar *fw_name;\n\tu32 fw_name_id;\n\tbool cancel_request;\n\tconst struct m10bmc_sec_ops *ops;\n};\n\nstatic DEFINE_XARRAY_ALLOC(fw_upload_xa);\n\n \n#define REH_SHA256_SIZE\t\t32\n#define REH_SHA384_SIZE\t\t48\n#define REH_MAGIC\t\tGENMASK(15, 0)\n#define REH_SHA_NUM_BYTES\tGENMASK(31, 16)\n\nstatic int m10bmc_sec_write(struct m10bmc_sec *sec, const u8 *buf, u32 offset, u32 size)\n{\n\tstruct intel_m10bmc *m10bmc = sec->m10bmc;\n\tunsigned int stride = regmap_get_reg_stride(m10bmc->regmap);\n\tu32 write_count = size / stride;\n\tu32 leftover_offset = write_count * stride;\n\tu32 leftover_size = size - leftover_offset;\n\tu32 leftover_tmp = 0;\n\tint ret;\n\n\tif (sec->m10bmc->flash_bulk_ops)\n\t\treturn sec->m10bmc->flash_bulk_ops->write(m10bmc, buf, offset, size);\n\n\tif (WARN_ON_ONCE(stride > sizeof(leftover_tmp)))\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_write(m10bmc->regmap, M10BMC_STAGING_BASE + offset,\n\t\t\t\tbuf + offset, write_count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (leftover_size) {\n\t\tmemcpy(&leftover_tmp, buf + leftover_offset, leftover_size);\n\t\tret = regmap_write(m10bmc->regmap, M10BMC_STAGING_BASE + offset + leftover_offset,\n\t\t\t\t   leftover_tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int m10bmc_sec_read(struct m10bmc_sec *sec, u8 *buf, u32 addr, u32 size)\n{\n\tstruct intel_m10bmc *m10bmc = sec->m10bmc;\n\tunsigned int stride = regmap_get_reg_stride(m10bmc->regmap);\n\tu32 read_count = size / stride;\n\tu32 leftover_offset = read_count * stride;\n\tu32 leftover_size = size - leftover_offset;\n\tu32 leftover_tmp;\n\tint ret;\n\n\tif (sec->m10bmc->flash_bulk_ops)\n\t\treturn sec->m10bmc->flash_bulk_ops->read(m10bmc, buf, addr, size);\n\n\tif (WARN_ON_ONCE(stride > sizeof(leftover_tmp)))\n\t\treturn -EINVAL;\n\n\tret = regmap_bulk_read(m10bmc->regmap, addr, buf, read_count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (leftover_size) {\n\t\tret = regmap_read(m10bmc->regmap, addr + leftover_offset, &leftover_tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(buf + leftover_offset, &leftover_tmp, leftover_size);\n\t}\n\n\treturn 0;\n}\n\n\nstatic ssize_t\nshow_root_entry_hash(struct device *dev, u32 exp_magic,\n\t\t     u32 prog_addr, u32 reh_addr, char *buf)\n{\n\tstruct m10bmc_sec *sec = dev_get_drvdata(dev);\n\tint sha_num_bytes, i, ret, cnt = 0;\n\tu8 hash[REH_SHA384_SIZE];\n\tu32 magic;\n\n\tret = m10bmc_sec_read(sec, (u8 *)&magic, prog_addr, sizeof(magic));\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(REH_MAGIC, magic) != exp_magic)\n\t\treturn sysfs_emit(buf, \"hash not programmed\\n\");\n\n\tsha_num_bytes = FIELD_GET(REH_SHA_NUM_BYTES, magic) / 8;\n\tif (sha_num_bytes != REH_SHA256_SIZE &&\n\t    sha_num_bytes != REH_SHA384_SIZE) {\n\t\tdev_err(sec->dev, \"%s bad sha num bytes %d\\n\", __func__,\n\t\t\tsha_num_bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tret = m10bmc_sec_read(sec, hash, reh_addr, sha_num_bytes);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read root entry hash\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < sha_num_bytes; i++)\n\t\tcnt += sprintf(buf + cnt, \"%02x\", hash[i]);\n\tcnt += sprintf(buf + cnt, \"\\n\");\n\n\treturn cnt;\n}\n\n#define DEVICE_ATTR_SEC_REH_RO(_name)\t\t\t\t\t\t\\\nstatic ssize_t _name##_root_entry_hash_show(struct device *dev, \\\n\t\t\t\t\t    struct device_attribute *attr, \\\n\t\t\t\t\t    char *buf) \\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct m10bmc_sec *sec = dev_get_drvdata(dev);\t\t\t\t\\\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn show_root_entry_hash(dev, csr_map->_name##_magic,\t\t\\\n\t\t\t\t    csr_map->_name##_prog_addr,\t\t\t\\\n\t\t\t\t    csr_map->_name##_reh_addr,\t\t\t\\\n\t\t\t\t    buf);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name##_root_entry_hash)\n\nDEVICE_ATTR_SEC_REH_RO(bmc);\nDEVICE_ATTR_SEC_REH_RO(sr);\nDEVICE_ATTR_SEC_REH_RO(pr);\n\n#define CSK_BIT_LEN\t\t128U\n#define CSK_32ARRAY_SIZE\tDIV_ROUND_UP(CSK_BIT_LEN, 32)\n\nstatic ssize_t\nshow_canceled_csk(struct device *dev, u32 addr, char *buf)\n{\n\tunsigned int i, size = CSK_32ARRAY_SIZE * sizeof(u32);\n\tstruct m10bmc_sec *sec = dev_get_drvdata(dev);\n\tDECLARE_BITMAP(csk_map, CSK_BIT_LEN);\n\t__le32 csk_le32[CSK_32ARRAY_SIZE];\n\tu32 csk32[CSK_32ARRAY_SIZE];\n\tint ret;\n\n\tret = m10bmc_sec_read(sec, (u8 *)&csk_le32, addr, size);\n\tif (ret) {\n\t\tdev_err(sec->dev, \"failed to read CSK vector\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < CSK_32ARRAY_SIZE; i++)\n\t\tcsk32[i] = le32_to_cpu(((csk_le32[i])));\n\n\tbitmap_from_arr32(csk_map, csk32, CSK_BIT_LEN);\n\tbitmap_complement(csk_map, csk_map, CSK_BIT_LEN);\n\treturn bitmap_print_to_pagebuf(1, buf, csk_map, CSK_BIT_LEN);\n}\n\n#define DEVICE_ATTR_SEC_CSK_RO(_name)\t\t\t\t\t\t\\\nstatic ssize_t _name##_canceled_csks_show(struct device *dev, \\\n\t\t\t\t\t  struct device_attribute *attr, \\\n\t\t\t\t\t  char *buf) \\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct m10bmc_sec *sec = dev_get_drvdata(dev);\t\t\t\t\\\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn show_canceled_csk(dev,\t\t\t\t\t\t\\\n\t\t\t\t csr_map->_name##_prog_addr + CSK_VEC_OFFSET,\t\\\n\t\t\t\t buf);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name##_canceled_csks)\n\n#define CSK_VEC_OFFSET 0x34\n\nDEVICE_ATTR_SEC_CSK_RO(bmc);\nDEVICE_ATTR_SEC_CSK_RO(sr);\nDEVICE_ATTR_SEC_CSK_RO(pr);\n\n#define FLASH_COUNT_SIZE 4096\t \n\nstatic ssize_t flash_count_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct m10bmc_sec *sec = dev_get_drvdata(dev);\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tunsigned int num_bits;\n\tu8 *flash_buf;\n\tint cnt, ret;\n\n\tnum_bits = FLASH_COUNT_SIZE * 8;\n\n\tflash_buf = kmalloc(FLASH_COUNT_SIZE, GFP_KERNEL);\n\tif (!flash_buf)\n\t\treturn -ENOMEM;\n\n\tret = m10bmc_sec_read(sec, flash_buf, csr_map->rsu_update_counter,\n\t\t\t      FLASH_COUNT_SIZE);\n\tif (ret) {\n\t\tdev_err(sec->dev, \"failed to read flash count\\n\");\n\t\tgoto exit_free;\n\t}\n\tcnt = num_bits - bitmap_weight((unsigned long *)flash_buf, num_bits);\n\nexit_free:\n\tkfree(flash_buf);\n\n\treturn ret ? : sysfs_emit(buf, \"%u\\n\", cnt);\n}\nstatic DEVICE_ATTR_RO(flash_count);\n\nstatic struct attribute *m10bmc_security_attrs[] = {\n\t&dev_attr_flash_count.attr,\n\t&dev_attr_bmc_root_entry_hash.attr,\n\t&dev_attr_sr_root_entry_hash.attr,\n\t&dev_attr_pr_root_entry_hash.attr,\n\t&dev_attr_sr_canceled_csks.attr,\n\t&dev_attr_pr_canceled_csks.attr,\n\t&dev_attr_bmc_canceled_csks.attr,\n\tNULL,\n};\n\nstatic struct attribute_group m10bmc_security_attr_group = {\n\t.name = \"security\",\n\t.attrs = m10bmc_security_attrs,\n};\n\nstatic const struct attribute_group *m10bmc_sec_attr_groups[] = {\n\t&m10bmc_security_attr_group,\n\tNULL,\n};\n\nstatic void log_error_regs(struct m10bmc_sec *sec, u32 doorbell)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 auth_result;\n\n\tdev_err(sec->dev, \"Doorbell: 0x%08x\\n\", doorbell);\n\n\tif (!m10bmc_sys_read(sec->m10bmc, csr_map->auth_result, &auth_result))\n\t\tdev_err(sec->dev, \"RSU auth result: 0x%08x\\n\", auth_result);\n}\n\nstatic int m10bmc_sec_n3000_rsu_status(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 doorbell;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, &doorbell);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(DRBL_RSU_STATUS, doorbell);\n}\n\nstatic int m10bmc_sec_n6000_rsu_status(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 auth_result;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->auth_result, &auth_result);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(AUTH_RESULT_RSU_STATUS, auth_result);\n}\n\nstatic bool rsu_status_ok(u32 status)\n{\n\treturn (status == RSU_STAT_NORMAL ||\n\t\tstatus == RSU_STAT_NIOS_OK ||\n\t\tstatus == RSU_STAT_USER_OK ||\n\t\tstatus == RSU_STAT_FACTORY_OK);\n}\n\nstatic bool rsu_progress_done(u32 progress)\n{\n\treturn (progress == RSU_PROG_IDLE ||\n\t\tprogress == RSU_PROG_RSU_DONE);\n}\n\nstatic bool rsu_progress_busy(u32 progress)\n{\n\treturn (progress == RSU_PROG_AUTHENTICATING ||\n\t\tprogress == RSU_PROG_COPYING ||\n\t\tprogress == RSU_PROG_UPDATE_CANCEL ||\n\t\tprogress == RSU_PROG_PROGRAM_KEY_HASH);\n}\n\nstatic int m10bmc_sec_progress_status(struct m10bmc_sec *sec, u32 *doorbell_reg,\n\t\t\t\t      u32 *progress, u32 *status)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, doorbell_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sec->ops->rsu_status(sec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*status = ret;\n\t*progress = rsu_prog(*doorbell_reg);\n\n\treturn 0;\n}\n\nstatic enum fw_upload_err rsu_check_idle(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 doorbell;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, &doorbell);\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\tif (!rsu_progress_done(rsu_prog(doorbell))) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_BUSY;\n\t}\n\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic inline bool rsu_start_done(u32 doorbell_reg, u32 progress, u32 status)\n{\n\tif (doorbell_reg & DRBL_RSU_REQUEST)\n\t\treturn false;\n\n\tif (status == RSU_STAT_ERASE_FAIL || status == RSU_STAT_WEAROUT)\n\t\treturn true;\n\n\tif (!rsu_progress_done(progress))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic enum fw_upload_err rsu_update_init(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 doorbell_reg, progress, status;\n\tint ret, err;\n\n\tret = m10bmc_sys_update_bits(sec->m10bmc, csr_map->doorbell,\n\t\t\t\t     DRBL_RSU_REQUEST | DRBL_HOST_STATUS,\n\t\t\t\t     DRBL_RSU_REQUEST |\n\t\t\t\t     FIELD_PREP(DRBL_HOST_STATUS,\n\t\t\t\t\t\tHOST_STATUS_IDLE));\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\tret = read_poll_timeout(m10bmc_sec_progress_status, err,\n\t\t\t\terr < 0 || rsu_start_done(doorbell_reg, progress, status),\n\t\t\t\tNIOS_HANDSHAKE_INTERVAL_US,\n\t\t\t\tNIOS_HANDSHAKE_TIMEOUT_US,\n\t\t\t\tfalse,\n\t\t\t\tsec, &doorbell_reg, &progress, &status);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tlog_error_regs(sec, doorbell_reg);\n\t\treturn FW_UPLOAD_ERR_TIMEOUT;\n\t} else if (err) {\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\t}\n\n\tif (status == RSU_STAT_WEAROUT) {\n\t\tdev_warn(sec->dev, \"Excessive flash update count detected\\n\");\n\t\treturn FW_UPLOAD_ERR_WEAROUT;\n\t} else if (status == RSU_STAT_ERASE_FAIL) {\n\t\tlog_error_regs(sec, doorbell_reg);\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\t}\n\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic enum fw_upload_err rsu_prog_ready(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tunsigned long poll_timeout;\n\tu32 doorbell, progress;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, &doorbell);\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\tpoll_timeout = jiffies + msecs_to_jiffies(RSU_PREP_TIMEOUT_MS);\n\twhile (rsu_prog(doorbell) == RSU_PROG_PREPARE) {\n\t\tmsleep(RSU_PREP_INTERVAL_MS);\n\t\tif (time_after(jiffies, poll_timeout))\n\t\t\tbreak;\n\n\t\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, &doorbell);\n\t\tif (ret)\n\t\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\t}\n\n\tprogress = rsu_prog(doorbell);\n\tif (progress == RSU_PROG_PREPARE) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_TIMEOUT;\n\t} else if (progress != RSU_PROG_READY) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\t}\n\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic enum fw_upload_err rsu_send_data(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 doorbell_reg, status;\n\tint ret;\n\n\tret = m10bmc_sys_update_bits(sec->m10bmc, csr_map->doorbell,\n\t\t\t\t     DRBL_HOST_STATUS,\n\t\t\t\t     FIELD_PREP(DRBL_HOST_STATUS,\n\t\t\t\t\t\tHOST_STATUS_WRITE_DONE));\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\tret = regmap_read_poll_timeout(sec->m10bmc->regmap,\n\t\t\t\t       csr_map->base + csr_map->doorbell,\n\t\t\t\t       doorbell_reg,\n\t\t\t\t       rsu_prog(doorbell_reg) != RSU_PROG_READY,\n\t\t\t\t       NIOS_HANDSHAKE_INTERVAL_US,\n\t\t\t\t       NIOS_HANDSHAKE_TIMEOUT_US);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tlog_error_regs(sec, doorbell_reg);\n\t\treturn FW_UPLOAD_ERR_TIMEOUT;\n\t} else if (ret) {\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\t}\n\n\tret = sec->ops->rsu_status(sec);\n\tif (ret < 0)\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\tstatus = ret;\n\n\tif (!rsu_status_ok(status)) {\n\t\tlog_error_regs(sec, doorbell_reg);\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\t}\n\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic int rsu_check_complete(struct m10bmc_sec *sec, u32 *doorbell_reg)\n{\n\tu32 progress, status;\n\n\tif (m10bmc_sec_progress_status(sec, doorbell_reg, &progress, &status))\n\t\treturn -EIO;\n\n\tif (!rsu_status_ok(status))\n\t\treturn -EINVAL;\n\n\tif (rsu_progress_done(progress))\n\t\treturn 0;\n\n\tif (rsu_progress_busy(progress))\n\t\treturn -EAGAIN;\n\n\treturn -EINVAL;\n}\n\nstatic enum fw_upload_err rsu_cancel(struct m10bmc_sec *sec)\n{\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tu32 doorbell;\n\tint ret;\n\n\tret = m10bmc_sys_read(sec->m10bmc, csr_map->doorbell, &doorbell);\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\tif (rsu_prog(doorbell) != RSU_PROG_READY)\n\t\treturn FW_UPLOAD_ERR_BUSY;\n\n\tret = m10bmc_sys_update_bits(sec->m10bmc, csr_map->doorbell,\n\t\t\t\t     DRBL_HOST_STATUS,\n\t\t\t\t     FIELD_PREP(DRBL_HOST_STATUS,\n\t\t\t\t\t\tHOST_STATUS_ABORT_RSU));\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\treturn FW_UPLOAD_ERR_CANCELED;\n}\n\nstatic enum fw_upload_err m10bmc_sec_prepare(struct fw_upload *fwl,\n\t\t\t\t\t     const u8 *data, u32 size)\n{\n\tstruct m10bmc_sec *sec = fwl->dd_handle;\n\tu32 ret;\n\n\tsec->cancel_request = false;\n\n\tif (!size || size > M10BMC_STAGING_SIZE)\n\t\treturn FW_UPLOAD_ERR_INVALID_SIZE;\n\n\tif (sec->m10bmc->flash_bulk_ops)\n\t\tif (sec->m10bmc->flash_bulk_ops->lock_write(sec->m10bmc))\n\t\t\treturn FW_UPLOAD_ERR_BUSY;\n\n\tret = rsu_check_idle(sec);\n\tif (ret != FW_UPLOAD_ERR_NONE)\n\t\tgoto unlock_flash;\n\n\tm10bmc_fw_state_set(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE_PREPARE);\n\n\tret = rsu_update_init(sec);\n\tif (ret != FW_UPLOAD_ERR_NONE)\n\t\tgoto fw_state_exit;\n\n\tret = rsu_prog_ready(sec);\n\tif (ret != FW_UPLOAD_ERR_NONE)\n\t\tgoto fw_state_exit;\n\n\tif (sec->cancel_request) {\n\t\tret = rsu_cancel(sec);\n\t\tgoto fw_state_exit;\n\t}\n\n\tm10bmc_fw_state_set(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE_WRITE);\n\n\treturn FW_UPLOAD_ERR_NONE;\n\nfw_state_exit:\n\tm10bmc_fw_state_set(sec->m10bmc, M10BMC_FW_STATE_NORMAL);\n\nunlock_flash:\n\tif (sec->m10bmc->flash_bulk_ops)\n\t\tsec->m10bmc->flash_bulk_ops->unlock_write(sec->m10bmc);\n\treturn ret;\n}\n\n#define WRITE_BLOCK_SIZE 0x4000\t \n\nstatic enum fw_upload_err m10bmc_sec_fw_write(struct fw_upload *fwl, const u8 *data,\n\t\t\t\t\t      u32 offset, u32 size, u32 *written)\n{\n\tstruct m10bmc_sec *sec = fwl->dd_handle;\n\tconst struct m10bmc_csr_map *csr_map = sec->m10bmc->info->csr_map;\n\tstruct intel_m10bmc *m10bmc = sec->m10bmc;\n\tu32 blk_size, doorbell;\n\tint ret;\n\n\tif (sec->cancel_request)\n\t\treturn rsu_cancel(sec);\n\n\tret = m10bmc_sys_read(m10bmc, csr_map->doorbell, &doorbell);\n\tif (ret) {\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\t} else if (rsu_prog(doorbell) != RSU_PROG_READY) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\t}\n\n\tWARN_ON_ONCE(WRITE_BLOCK_SIZE % regmap_get_reg_stride(m10bmc->regmap));\n\tblk_size = min_t(u32, WRITE_BLOCK_SIZE, size);\n\tret = m10bmc_sec_write(sec, data, offset, blk_size);\n\tif (ret)\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\n\t*written = blk_size;\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic enum fw_upload_err m10bmc_sec_poll_complete(struct fw_upload *fwl)\n{\n\tstruct m10bmc_sec *sec = fwl->dd_handle;\n\tunsigned long poll_timeout;\n\tu32 doorbell, result;\n\tint ret;\n\n\tif (sec->cancel_request)\n\t\treturn rsu_cancel(sec);\n\n\tm10bmc_fw_state_set(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE_PROGRAM);\n\n\tresult = rsu_send_data(sec);\n\tif (result != FW_UPLOAD_ERR_NONE)\n\t\treturn result;\n\n\tpoll_timeout = jiffies + msecs_to_jiffies(RSU_COMPLETE_TIMEOUT_MS);\n\tdo {\n\t\tmsleep(RSU_COMPLETE_INTERVAL_MS);\n\t\tret = rsu_check_complete(sec, &doorbell);\n\t} while (ret == -EAGAIN && !time_after(jiffies, poll_timeout));\n\n\tif (ret == -EAGAIN) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_TIMEOUT;\n\t} else if (ret == -EIO) {\n\t\treturn FW_UPLOAD_ERR_RW_ERROR;\n\t} else if (ret) {\n\t\tlog_error_regs(sec, doorbell);\n\t\treturn FW_UPLOAD_ERR_HW_ERROR;\n\t}\n\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\n \nstatic void m10bmc_sec_cancel(struct fw_upload *fwl)\n{\n\tstruct m10bmc_sec *sec = fwl->dd_handle;\n\n\tsec->cancel_request = true;\n}\n\nstatic void m10bmc_sec_cleanup(struct fw_upload *fwl)\n{\n\tstruct m10bmc_sec *sec = fwl->dd_handle;\n\n\t(void)rsu_cancel(sec);\n\n\tm10bmc_fw_state_set(sec->m10bmc, M10BMC_FW_STATE_NORMAL);\n\n\tif (sec->m10bmc->flash_bulk_ops)\n\t\tsec->m10bmc->flash_bulk_ops->unlock_write(sec->m10bmc);\n}\n\nstatic const struct fw_upload_ops m10bmc_ops = {\n\t.prepare = m10bmc_sec_prepare,\n\t.write = m10bmc_sec_fw_write,\n\t.poll_complete = m10bmc_sec_poll_complete,\n\t.cancel = m10bmc_sec_cancel,\n\t.cleanup = m10bmc_sec_cleanup,\n};\n\nstatic const struct m10bmc_sec_ops m10sec_n3000_ops = {\n\t.rsu_status = m10bmc_sec_n3000_rsu_status,\n};\n\nstatic const struct m10bmc_sec_ops m10sec_n6000_ops = {\n\t.rsu_status = m10bmc_sec_n6000_rsu_status,\n};\n\n#define SEC_UPDATE_LEN_MAX 32\nstatic int m10bmc_sec_probe(struct platform_device *pdev)\n{\n\tchar buf[SEC_UPDATE_LEN_MAX];\n\tstruct m10bmc_sec *sec;\n\tstruct fw_upload *fwl;\n\tunsigned int len;\n\tint  ret;\n\n\tsec = devm_kzalloc(&pdev->dev, sizeof(*sec), GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\n\tsec->dev = &pdev->dev;\n\tsec->m10bmc = dev_get_drvdata(pdev->dev.parent);\n\tsec->ops = (struct m10bmc_sec_ops *)platform_get_device_id(pdev)->driver_data;\n\tdev_set_drvdata(&pdev->dev, sec);\n\n\tret = xa_alloc(&fw_upload_xa, &sec->fw_name_id, sec,\n\t\t       xa_limit_32b, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = scnprintf(buf, SEC_UPDATE_LEN_MAX, \"secure-update%d\",\n\t\t\tsec->fw_name_id);\n\tsec->fw_name = kmemdup_nul(buf, len, GFP_KERNEL);\n\tif (!sec->fw_name) {\n\t\tret = -ENOMEM;\n\t\tgoto fw_name_fail;\n\t}\n\n\tfwl = firmware_upload_register(THIS_MODULE, sec->dev, sec->fw_name,\n\t\t\t\t       &m10bmc_ops, sec);\n\tif (IS_ERR(fwl)) {\n\t\tdev_err(sec->dev, \"Firmware Upload driver failed to start\\n\");\n\t\tret = PTR_ERR(fwl);\n\t\tgoto fw_uploader_fail;\n\t}\n\n\tsec->fwl = fwl;\n\treturn 0;\n\nfw_uploader_fail:\n\tkfree(sec->fw_name);\nfw_name_fail:\n\txa_erase(&fw_upload_xa, sec->fw_name_id);\n\treturn ret;\n}\n\nstatic int m10bmc_sec_remove(struct platform_device *pdev)\n{\n\tstruct m10bmc_sec *sec = dev_get_drvdata(&pdev->dev);\n\n\tfirmware_upload_unregister(sec->fwl);\n\tkfree(sec->fw_name);\n\txa_erase(&fw_upload_xa, sec->fw_name_id);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id intel_m10bmc_sec_ids[] = {\n\t{\n\t\t.name = \"n3000bmc-sec-update\",\n\t\t.driver_data = (kernel_ulong_t)&m10sec_n3000_ops,\n\t},\n\t{\n\t\t.name = \"d5005bmc-sec-update\",\n\t\t.driver_data = (kernel_ulong_t)&m10sec_n3000_ops,\n\t},\n\t{\n\t\t.name = \"n6000bmc-sec-update\",\n\t\t.driver_data = (kernel_ulong_t)&m10sec_n6000_ops,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, intel_m10bmc_sec_ids);\n\nstatic struct platform_driver intel_m10bmc_sec_driver = {\n\t.probe = m10bmc_sec_probe,\n\t.remove = m10bmc_sec_remove,\n\t.driver = {\n\t\t.name = \"intel-m10bmc-sec-update\",\n\t\t.dev_groups = m10bmc_sec_attr_groups,\n\t},\n\t.id_table = intel_m10bmc_sec_ids,\n};\nmodule_platform_driver(intel_m10bmc_sec_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_DESCRIPTION(\"Intel MAX10 BMC Secure Update\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(INTEL_M10_BMC_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}