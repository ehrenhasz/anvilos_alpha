{
  "module_name": "xilinx-spi.c",
  "hash_id": "d1c9b9d2a7f62f0cf596baba880282accadf3e82c316bc4383c0d481c8ec6a20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/xilinx-spi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/sizes.h>\n\nstruct xilinx_spi_conf {\n\tstruct spi_device *spi;\n\tstruct gpio_desc *prog_b;\n\tstruct gpio_desc *init_b;\n\tstruct gpio_desc *done;\n};\n\nstatic int get_done_gpio(struct fpga_manager *mgr)\n{\n\tstruct xilinx_spi_conf *conf = mgr->priv;\n\tint ret;\n\n\tret = gpiod_get_value(conf->done);\n\n\tif (ret < 0)\n\t\tdev_err(&mgr->dev, \"Error reading DONE (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic enum fpga_mgr_states xilinx_spi_state(struct fpga_manager *mgr)\n{\n\tif (!get_done_gpio(mgr))\n\t\treturn FPGA_MGR_STATE_RESET;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\n \nstatic int wait_for_init_b(struct fpga_manager *mgr, int value,\n\t\t\t   unsigned long alt_udelay)\n{\n\tstruct xilinx_spi_conf *conf = mgr->priv;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\tif (conf->init_b) {\n\t\twhile (time_before(jiffies, timeout)) {\n\t\t\tint ret = gpiod_get_value(conf->init_b);\n\n\t\t\tif (ret == value)\n\t\t\t\treturn 0;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&mgr->dev, \"Error reading INIT_B (%d)\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tusleep_range(100, 400);\n\t\t}\n\n\t\tdev_err(&mgr->dev, \"Timeout waiting for INIT_B to %s\\n\",\n\t\t\tvalue ? \"assert\" : \"deassert\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tudelay(alt_udelay);\n\n\treturn 0;\n}\n\nstatic int xilinx_spi_write_init(struct fpga_manager *mgr,\n\t\t\t\t struct fpga_image_info *info,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct xilinx_spi_conf *conf = mgr->priv;\n\tint err;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(&mgr->dev, \"Partial reconfiguration not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpiod_set_value(conf->prog_b, 1);\n\n\terr = wait_for_init_b(mgr, 1, 1);  \n\tif (err) {\n\t\tgpiod_set_value(conf->prog_b, 0);\n\t\treturn err;\n\t}\n\n\tgpiod_set_value(conf->prog_b, 0);\n\n\terr = wait_for_init_b(mgr, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (get_done_gpio(mgr)) {\n\t\tdev_err(&mgr->dev, \"Unexpected DONE pin state...\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tusleep_range(7500, 7600);\n\treturn 0;\n}\n\nstatic int xilinx_spi_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct xilinx_spi_conf *conf = mgr->priv;\n\tconst char *fw_data = buf;\n\tconst char *fw_data_end = fw_data + count;\n\n\twhile (fw_data < fw_data_end) {\n\t\tsize_t remaining, stride;\n\t\tint ret;\n\n\t\tremaining = fw_data_end - fw_data;\n\t\tstride = min_t(size_t, remaining, SZ_4K);\n\n\t\tret = spi_write(conf->spi, fw_data, stride);\n\t\tif (ret) {\n\t\t\tdev_err(&mgr->dev, \"SPI error in firmware write: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tfw_data += stride;\n\t}\n\n\treturn 0;\n}\n\nstatic int xilinx_spi_apply_cclk_cycles(struct xilinx_spi_conf *conf)\n{\n\tstruct spi_device *spi = conf->spi;\n\tconst u8 din_data[1] = { 0xff };\n\tint ret;\n\n\tret = spi_write(conf->spi, din_data, sizeof(din_data));\n\tif (ret)\n\t\tdev_err(&spi->dev, \"applying CCLK cycles failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int xilinx_spi_write_complete(struct fpga_manager *mgr,\n\t\t\t\t     struct fpga_image_info *info)\n{\n\tstruct xilinx_spi_conf *conf = mgr->priv;\n\tunsigned long timeout = jiffies + usecs_to_jiffies(info->config_complete_timeout_us);\n\tbool expired = false;\n\tint done;\n\tint ret;\n\n\t \n\twhile (!expired) {\n\t\texpired = time_after(jiffies, timeout);\n\n\t\tdone = get_done_gpio(mgr);\n\t\tif (done < 0)\n\t\t\treturn done;\n\n\t\tret = xilinx_spi_apply_cclk_cycles(conf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (done)\n\t\t\treturn 0;\n\t}\n\n\tif (conf->init_b) {\n\t\tret = gpiod_get_value(conf->init_b);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(&mgr->dev, \"Error reading INIT_B (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_err(&mgr->dev,\n\t\t\tret ? \"CRC error or invalid device\\n\"\n\t\t\t: \"Missing sync word or incomplete bitstream\\n\");\n\t} else {\n\t\tdev_err(&mgr->dev, \"Timeout after config data transfer\\n\");\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct fpga_manager_ops xilinx_spi_ops = {\n\t.state = xilinx_spi_state,\n\t.write_init = xilinx_spi_write_init,\n\t.write = xilinx_spi_write,\n\t.write_complete = xilinx_spi_write_complete,\n};\n\nstatic int xilinx_spi_probe(struct spi_device *spi)\n{\n\tstruct xilinx_spi_conf *conf;\n\tstruct fpga_manager *mgr;\n\n\tconf = devm_kzalloc(&spi->dev, sizeof(*conf), GFP_KERNEL);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\n\tconf->spi = spi;\n\n\t \n\tconf->prog_b = devm_gpiod_get(&spi->dev, \"prog_b\", GPIOD_OUT_LOW);\n\tif (IS_ERR(conf->prog_b))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(conf->prog_b),\n\t\t\t\t     \"Failed to get PROGRAM_B gpio\\n\");\n\n\tconf->init_b = devm_gpiod_get_optional(&spi->dev, \"init-b\", GPIOD_IN);\n\tif (IS_ERR(conf->init_b))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(conf->init_b),\n\t\t\t\t     \"Failed to get INIT_B gpio\\n\");\n\n\tconf->done = devm_gpiod_get(&spi->dev, \"done\", GPIOD_IN);\n\tif (IS_ERR(conf->done))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(conf->done),\n\t\t\t\t     \"Failed to get DONE gpio\\n\");\n\n\tmgr = devm_fpga_mgr_register(&spi->dev,\n\t\t\t\t     \"Xilinx Slave Serial FPGA Manager\",\n\t\t\t\t     &xilinx_spi_ops, conf);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id xlnx_spi_of_match[] = {\n\t{ .compatible = \"xlnx,fpga-slave-serial\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, xlnx_spi_of_match);\n#endif\n\nstatic struct spi_driver xilinx_slave_spi_driver = {\n\t.driver = {\n\t\t.name = \"xlnx-slave-spi\",\n\t\t.of_match_table = of_match_ptr(xlnx_spi_of_match),\n\t},\n\t.probe = xilinx_spi_probe,\n};\n\nmodule_spi_driver(xilinx_slave_spi_driver)\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Anatolij Gustschin <agust@denx.de>\");\nMODULE_DESCRIPTION(\"Load Xilinx FPGA firmware over SPI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}