{
  "module_name": "lattice-sysconfig.c",
  "hash_id": "57361d2b228ff8b7bad7d850748fb4d9044a7f0a47228d06ef014dacb90336ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/lattice-sysconfig.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n\n#include \"lattice-sysconfig.h\"\n\nstatic int sysconfig_cmd_write(struct sysconfig_priv *priv, const void *buf,\n\t\t\t       size_t buf_len)\n{\n\treturn priv->command_transfer(priv, buf, buf_len, NULL, 0);\n}\n\nstatic int sysconfig_cmd_read(struct sysconfig_priv *priv, const void *tx_buf,\n\t\t\t      size_t tx_len, void *rx_buf, size_t rx_len)\n{\n\treturn priv->command_transfer(priv, tx_buf, tx_len, rx_buf, rx_len);\n}\n\nstatic int sysconfig_read_busy(struct sysconfig_priv *priv)\n{\n\tconst u8 lsc_check_busy[] = SYSCONFIG_LSC_CHECK_BUSY;\n\tu8 busy;\n\tint ret;\n\n\tret = sysconfig_cmd_read(priv, lsc_check_busy, sizeof(lsc_check_busy),\n\t\t\t\t &busy, sizeof(busy));\n\n\treturn ret ? : busy;\n}\n\nstatic int sysconfig_poll_busy(struct sysconfig_priv *priv)\n{\n\tint ret, busy;\n\n\tret = read_poll_timeout(sysconfig_read_busy, busy, busy <= 0,\n\t\t\t\tSYSCONFIG_POLL_INTERVAL_US,\n\t\t\t\tSYSCONFIG_POLL_BUSY_TIMEOUT_US, false, priv);\n\n\treturn ret ? : busy;\n}\n\nstatic int sysconfig_read_status(struct sysconfig_priv *priv, u32 *status)\n{\n\tconst u8 lsc_read_status[] = SYSCONFIG_LSC_READ_STATUS;\n\t__be32 device_status;\n\tint ret;\n\n\tret = sysconfig_cmd_read(priv, lsc_read_status, sizeof(lsc_read_status),\n\t\t\t\t &device_status, sizeof(device_status));\n\tif (ret)\n\t\treturn ret;\n\n\t*status = be32_to_cpu(device_status);\n\n\treturn 0;\n}\n\nstatic int sysconfig_poll_status(struct sysconfig_priv *priv, u32 *status)\n{\n\tint ret = sysconfig_poll_busy(priv);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysconfig_read_status(priv, status);\n}\n\nstatic int sysconfig_poll_gpio(struct gpio_desc *gpio, bool is_active)\n{\n\tint ret, val;\n\n\tret = read_poll_timeout(gpiod_get_value, val,\n\t\t\t\tval < 0 || !!val == is_active,\n\t\t\t\tSYSCONFIG_POLL_INTERVAL_US,\n\t\t\t\tSYSCONFIG_POLL_GPIO_TIMEOUT_US, false, gpio);\n\n\tif (val < 0)\n\t\treturn val;\n\n\treturn ret;\n}\n\nstatic int sysconfig_gpio_refresh(struct sysconfig_priv *priv)\n{\n\tstruct gpio_desc *program = priv->program;\n\tstruct gpio_desc *init = priv->init;\n\tstruct gpio_desc *done = priv->done;\n\tint ret;\n\n\t \n\tgpiod_set_value(program, 1);\n\n\tret = sysconfig_poll_gpio(init, true);\n\tif (!ret)\n\t\tret = sysconfig_poll_gpio(done, false);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpiod_set_value(program, 0);\n\n\treturn sysconfig_poll_gpio(init, false);\n}\n\nstatic int sysconfig_lsc_refresh(struct sysconfig_priv *priv)\n{\n\tstatic const u8 lsc_refresh[] = SYSCONFIG_LSC_REFRESH;\n\tint ret;\n\n\tret = sysconfig_cmd_write(priv, lsc_refresh, sizeof(lsc_refresh));\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(4000, 8000);\n\n\treturn 0;\n}\n\nstatic int sysconfig_refresh(struct sysconfig_priv *priv)\n{\n\tstruct gpio_desc *program = priv->program;\n\tstruct gpio_desc *init = priv->init;\n\tstruct gpio_desc *done = priv->done;\n\n\tif (program && init && done)\n\t\treturn sysconfig_gpio_refresh(priv);\n\n\treturn sysconfig_lsc_refresh(priv);\n}\n\nstatic int sysconfig_isc_enable(struct sysconfig_priv *priv)\n{\n\tu8 isc_enable[] = SYSCONFIG_ISC_ENABLE;\n\tu32 status;\n\tint ret;\n\n\tret = sysconfig_cmd_write(priv, isc_enable, sizeof(isc_enable));\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysconfig_poll_status(priv, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & SYSCONFIG_STATUS_FAIL)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sysconfig_isc_erase(struct sysconfig_priv *priv)\n{\n\tu8 isc_erase[] = SYSCONFIG_ISC_ERASE;\n\tu32 status;\n\tint ret;\n\n\tret = sysconfig_cmd_write(priv, isc_erase, sizeof(isc_erase));\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysconfig_poll_status(priv, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & SYSCONFIG_STATUS_FAIL)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sysconfig_isc_init(struct sysconfig_priv *priv)\n{\n\tint ret = sysconfig_isc_enable(priv);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysconfig_isc_erase(priv);\n}\n\nstatic int sysconfig_lsc_init_addr(struct sysconfig_priv *priv)\n{\n\tconst u8 lsc_init_addr[] = SYSCONFIG_LSC_INIT_ADDR;\n\n\treturn sysconfig_cmd_write(priv, lsc_init_addr, sizeof(lsc_init_addr));\n}\n\nstatic int sysconfig_burst_write_init(struct sysconfig_priv *priv)\n{\n\treturn priv->bitstream_burst_write_init(priv);\n}\n\nstatic int sysconfig_burst_write_complete(struct sysconfig_priv *priv)\n{\n\treturn priv->bitstream_burst_write_complete(priv);\n}\n\nstatic int sysconfig_bitstream_burst_write(struct sysconfig_priv *priv,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tint ret = priv->bitstream_burst_write(priv, buf, count);\n\n\tif (ret)\n\t\tsysconfig_burst_write_complete(priv);\n\n\treturn ret;\n}\n\nstatic int sysconfig_isc_disable(struct sysconfig_priv *priv)\n{\n\tconst u8 isc_disable[] = SYSCONFIG_ISC_DISABLE;\n\n\treturn sysconfig_cmd_write(priv, isc_disable, sizeof(isc_disable));\n}\n\nstatic void sysconfig_cleanup(struct sysconfig_priv *priv)\n{\n\tsysconfig_isc_erase(priv);\n\tsysconfig_refresh(priv);\n}\n\nstatic int sysconfig_isc_finish(struct sysconfig_priv *priv)\n{\n\tstruct gpio_desc *done_gpio = priv->done;\n\tu32 status;\n\tint ret;\n\n\tif (done_gpio) {\n\t\tret = sysconfig_isc_disable(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn sysconfig_poll_gpio(done_gpio, true);\n\t}\n\n\tret = sysconfig_poll_status(priv, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((status & SYSCONFIG_STATUS_DONE) &&\n\t    !(status & SYSCONFIG_STATUS_BUSY) &&\n\t    !(status & SYSCONFIG_STATUS_ERR))\n\t\treturn sysconfig_isc_disable(priv);\n\n\treturn -EFAULT;\n}\n\nstatic enum fpga_mgr_states sysconfig_ops_state(struct fpga_manager *mgr)\n{\n\tstruct sysconfig_priv *priv = mgr->priv;\n\tstruct gpio_desc *done = priv->done;\n\tu32 status;\n\tint ret;\n\n\tif (done && (gpiod_get_value(done) > 0))\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\tret = sysconfig_read_status(priv, &status);\n\tif (!ret && (status & SYSCONFIG_STATUS_DONE))\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic int sysconfig_ops_write_init(struct fpga_manager *mgr,\n\t\t\t\t    struct fpga_image_info *info,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct sysconfig_priv *priv = mgr->priv;\n\tstruct device *dev = &mgr->dev;\n\tint ret;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(dev, \"Partial reconfiguration is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tret = sysconfig_refresh(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to go to program mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sysconfig_isc_init(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to go to ISC mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sysconfig_lsc_init_addr(priv);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to initialize the Address Shift Register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sysconfig_burst_write_init(priv);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to prepare for bitstream burst write\\n\");\n\n\treturn ret;\n}\n\nstatic int sysconfig_ops_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t       size_t count)\n{\n\treturn sysconfig_bitstream_burst_write(mgr->priv, buf, count);\n}\n\nstatic int sysconfig_ops_write_complete(struct fpga_manager *mgr,\n\t\t\t\t\tstruct fpga_image_info *info)\n{\n\tstruct sysconfig_priv *priv = mgr->priv;\n\tstruct device *dev = &mgr->dev;\n\tint ret;\n\n\tret = sysconfig_burst_write_complete(priv);\n\tif (!ret)\n\t\tret = sysconfig_poll_busy(priv);\n\n\tif (ret) {\n\t\tdev_err(dev, \"Error while waiting bitstream write to finish\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = sysconfig_isc_finish(priv);\n\nfail:\n\tif (ret)\n\t\tsysconfig_cleanup(priv);\n\n\treturn ret;\n}\n\nstatic const struct fpga_manager_ops sysconfig_fpga_mgr_ops = {\n\t.state = sysconfig_ops_state,\n\t.write_init = sysconfig_ops_write_init,\n\t.write = sysconfig_ops_write,\n\t.write_complete = sysconfig_ops_write_complete,\n};\n\nint sysconfig_probe(struct sysconfig_priv *priv)\n{\n\tstruct gpio_desc *program, *init, *done;\n\tstruct device *dev = priv->dev;\n\tstruct fpga_manager *mgr;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!priv->command_transfer ||\n\t    !priv->bitstream_burst_write_init ||\n\t    !priv->bitstream_burst_write ||\n\t    !priv->bitstream_burst_write_complete) {\n\t\tdev_err(dev, \"Essential callback is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprogram = devm_gpiod_get_optional(dev, \"program\", GPIOD_OUT_LOW);\n\tif (IS_ERR(program))\n\t\treturn dev_err_probe(dev, PTR_ERR(program),\n\t\t\t\t     \"Failed to get PROGRAM GPIO\\n\");\n\n\tinit = devm_gpiod_get_optional(dev, \"init\", GPIOD_IN);\n\tif (IS_ERR(init))\n\t\treturn dev_err_probe(dev, PTR_ERR(init),\n\t\t\t\t     \"Failed to get INIT GPIO\\n\");\n\n\tdone = devm_gpiod_get_optional(dev, \"done\", GPIOD_IN);\n\tif (IS_ERR(done))\n\t\treturn dev_err_probe(dev, PTR_ERR(done),\n\t\t\t\t     \"Failed to get DONE GPIO\\n\");\n\n\tpriv->program = program;\n\tpriv->init = init;\n\tpriv->done = done;\n\n\tmgr = devm_fpga_mgr_register(dev, \"Lattice sysCONFIG FPGA Manager\",\n\t\t\t\t     &sysconfig_fpga_mgr_ops, priv);\n\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\nEXPORT_SYMBOL(sysconfig_probe);\n\nMODULE_DESCRIPTION(\"Lattice sysCONFIG FPGA Manager Core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}