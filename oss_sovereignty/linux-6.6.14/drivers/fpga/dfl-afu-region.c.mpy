{
  "module_name": "dfl-afu-region.c",
  "hash_id": "d67b53830648f2fd33801db272613be6b633992cfdd24d2000ea7aec406abcdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-afu-region.c",
  "human_readable_source": "\n \n#include \"dfl-afu.h\"\n\n \nvoid afu_mmio_region_init(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\n\tINIT_LIST_HEAD(&afu->regions);\n}\n\n#define for_each_region(region, afu)\t\\\n\tlist_for_each_entry((region), &(afu)->regions, node)\n\nstatic struct dfl_afu_mmio_region *get_region_by_index(struct dfl_afu *afu,\n\t\t\t\t\t\t       u32 region_index)\n{\n\tstruct dfl_afu_mmio_region *region;\n\n\tfor_each_region(region, afu)\n\t\tif (region->index == region_index)\n\t\t\treturn region;\n\n\treturn NULL;\n}\n\n \nint afu_mmio_region_add(struct dfl_feature_platform_data *pdata,\n\t\t\tu32 region_index, u64 region_size, u64 phys, u32 flags)\n{\n\tstruct dfl_afu_mmio_region *region;\n\tstruct dfl_afu *afu;\n\tint ret = 0;\n\n\tregion = devm_kzalloc(&pdata->dev->dev, sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->index = region_index;\n\tregion->size = region_size;\n\tregion->phys = phys;\n\tregion->flags = flags;\n\n\tmutex_lock(&pdata->lock);\n\n\tafu = dfl_fpga_pdata_get_private(pdata);\n\n\t \n\tif (get_region_by_index(afu, region_index)) {\n\t\tmutex_unlock(&pdata->lock);\n\t\tret = -EEXIST;\n\t\tgoto exit;\n\t}\n\n\tregion_size = PAGE_ALIGN(region_size);\n\tregion->offset = afu->region_cur_offset;\n\tlist_add(&region->node, &afu->regions);\n\n\tafu->region_cur_offset += region_size;\n\tafu->num_regions++;\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n\nexit:\n\tdevm_kfree(&pdata->dev->dev, region);\n\treturn ret;\n}\n\n \nvoid afu_mmio_region_destroy(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);\n\tstruct dfl_afu_mmio_region *tmp, *region;\n\n\tlist_for_each_entry_safe(region, tmp, &afu->regions, node)\n\t\tdevm_kfree(&pdata->dev->dev, region);\n}\n\n \nint afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,\n\t\t\t\t u32 region_index,\n\t\t\t\t struct dfl_afu_mmio_region *pregion)\n{\n\tstruct dfl_afu_mmio_region *region;\n\tstruct dfl_afu *afu;\n\tint ret = 0;\n\n\tmutex_lock(&pdata->lock);\n\tafu = dfl_fpga_pdata_get_private(pdata);\n\tregion = get_region_by_index(afu, region_index);\n\tif (!region) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\t*pregion = *region;\nexit:\n\tmutex_unlock(&pdata->lock);\n\treturn ret;\n}\n\n \nint afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,\n\t\t\t\t  u64 offset, u64 size,\n\t\t\t\t  struct dfl_afu_mmio_region *pregion)\n{\n\tstruct dfl_afu_mmio_region *region;\n\tstruct dfl_afu *afu;\n\tint ret = 0;\n\n\tmutex_lock(&pdata->lock);\n\tafu = dfl_fpga_pdata_get_private(pdata);\n\tfor_each_region(region, afu)\n\t\tif (region->offset <= offset &&\n\t\t    region->offset + region->size >= offset + size) {\n\t\t\t*pregion = *region;\n\t\t\tgoto exit;\n\t\t}\n\tret = -EINVAL;\nexit:\n\tmutex_unlock(&pdata->lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}