{
  "module_name": "socfpga-a10.c",
  "hash_id": "7c359ebafa8cb48491c4126ad7514b06633ae173dab8f1a7d540fd887760e35f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/socfpga-a10.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n\n#define A10_FPGAMGR_DCLKCNT_OFST\t\t\t\t0x08\n#define A10_FPGAMGR_DCLKSTAT_OFST\t\t\t\t0x0c\n#define A10_FPGAMGR_IMGCFG_CTL_00_OFST\t\t\t\t0x70\n#define A10_FPGAMGR_IMGCFG_CTL_01_OFST\t\t\t\t0x74\n#define A10_FPGAMGR_IMGCFG_CTL_02_OFST\t\t\t\t0x78\n#define A10_FPGAMGR_IMGCFG_STAT_OFST\t\t\t\t0x80\n\n#define A10_FPGAMGR_DCLKSTAT_DCLKDONE\t\t\t\tBIT(0)\n\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NCONFIG\t\tBIT(0)\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NSTATUS\t\tBIT(1)\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_CONDONE\t\tBIT(2)\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_NCONFIG\t\t\tBIT(8)\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_NSTATUS_OE\t\tBIT(16)\n#define A10_FPGAMGR_IMGCFG_CTL_00_S2F_CONDONE_OE\t\tBIT(24)\n\n#define A10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG\t\tBIT(0)\n#define A10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST\t\tBIT(16)\n#define A10_FPGAMGR_IMGCFG_CTL_01_S2F_NCE\t\t\tBIT(24)\n\n#define A10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL\t\t\tBIT(0)\n#define A10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_MASK\t\t(BIT(16) | BIT(17))\n#define A10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_SHIFT\t\t\t16\n#define A10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH\t\t\tBIT(24)\n#define A10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH_SHIFT\t\t24\n\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_CRC_ERROR\t\t\tBIT(0)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_EARLY_USERMODE\t\tBIT(1)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_USERMODE\t\t\tBIT(2)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN\t\t\tBIT(4)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_CONDONE_PIN\t\t\tBIT(6)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_PR_READY\t\t\tBIT(9)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_PR_DONE\t\t\tBIT(10)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_PR_ERROR\t\t\tBIT(11)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_NCONFIG_PIN\t\t\tBIT(12)\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_MASK\t(BIT(16) | BIT(17) | BIT(18))\n#define A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_SHIFT\t\t        16\n\n \n#define CDRATIO_x1\t\t\t\t\t\t0x0\n#define CDRATIO_x2\t\t\t\t\t\t0x1\n#define CDRATIO_x4\t\t\t\t\t\t0x2\n#define CDRATIO_x8\t\t\t\t\t\t0x3\n\n \n#define CFGWDTH_32\t\t\t\t\t\t1\n#define CFGWDTH_16\t\t\t\t\t\t0\n\n \nstruct a10_fpga_priv {\n\tstruct regmap *regmap;\n\tvoid __iomem *fpga_data_addr;\n\tstruct clk *clk;\n};\n\nstatic bool socfpga_a10_fpga_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase A10_FPGAMGR_DCLKCNT_OFST:\n\tcase A10_FPGAMGR_DCLKSTAT_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_00_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_01_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_02_OFST:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool socfpga_a10_fpga_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase A10_FPGAMGR_DCLKCNT_OFST:\n\tcase A10_FPGAMGR_DCLKSTAT_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_00_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_01_OFST:\n\tcase A10_FPGAMGR_IMGCFG_CTL_02_OFST:\n\tcase A10_FPGAMGR_IMGCFG_STAT_OFST:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config socfpga_a10_fpga_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.writeable_reg = socfpga_a10_fpga_writeable_reg,\n\t.readable_reg = socfpga_a10_fpga_readable_reg,\n\t.max_register = A10_FPGAMGR_IMGCFG_STAT_OFST,\n\t.cache_type = REGCACHE_NONE,\n};\n\n \nstatic void socfpga_a10_fpga_set_cfg_width(struct a10_fpga_priv *priv,\n\t\t\t\t\t   int width)\n{\n\twidth <<= A10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH_SHIFT;\n\n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH, width);\n}\n\nstatic void socfpga_a10_fpga_generate_dclks(struct a10_fpga_priv *priv,\n\t\t\t\t\t    u32 count)\n{\n\tu32 val;\n\n\t \n\tregmap_write(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST,\n\t\t     A10_FPGAMGR_DCLKSTAT_DCLKDONE);\n\n\t \n\tregmap_write(priv->regmap, A10_FPGAMGR_DCLKCNT_OFST, count);\n\n\t \n\tregmap_read_poll_timeout(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST, val,\n\t\t\t\t val, 1, 100);\n\n\t \n\tregmap_write(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST,\n\t\t     A10_FPGAMGR_DCLKSTAT_DCLKDONE);\n}\n\n#define RBF_ENCRYPTION_MODE_OFFSET\t\t69\n#define RBF_DECOMPRESS_OFFSET\t\t\t229\n\nstatic int socfpga_a10_fpga_encrypted(u32 *buf32, size_t buf32_size)\n{\n\tif (buf32_size < RBF_ENCRYPTION_MODE_OFFSET + 1)\n\t\treturn -EINVAL;\n\n\t \n\treturn ((buf32[RBF_ENCRYPTION_MODE_OFFSET] >> 2) & 3) != 0;\n}\n\nstatic int socfpga_a10_fpga_compressed(u32 *buf32, size_t buf32_size)\n{\n\tif (buf32_size < RBF_DECOMPRESS_OFFSET + 1)\n\t\treturn -EINVAL;\n\n\t \n\treturn !((buf32[RBF_DECOMPRESS_OFFSET] >> 1) & 1);\n}\n\nstatic unsigned int socfpga_a10_fpga_get_cd_ratio(unsigned int cfg_width,\n\t\t\t\t\t\t  bool encrypt, bool compress)\n{\n\tunsigned int cd_ratio;\n\n\t \n\tif (!compress && !encrypt)\n\t\treturn CDRATIO_x1;\n\n\tif (compress)\n\t\tcd_ratio = CDRATIO_x4;\n\telse\n\t\tcd_ratio = CDRATIO_x2;\n\n\t \n\tif (cfg_width == CFGWDTH_32)\n\t\tcd_ratio += 1;\n\n\treturn cd_ratio;\n}\n\nstatic int socfpga_a10_fpga_set_cdratio(struct fpga_manager *mgr,\n\t\t\t\t\tunsigned int cfg_width,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\tunsigned int cd_ratio;\n\tint encrypt, compress;\n\n\tencrypt = socfpga_a10_fpga_encrypted((u32 *)buf, count / 4);\n\tif (encrypt < 0)\n\t\treturn -EINVAL;\n\n\tcompress = socfpga_a10_fpga_compressed((u32 *)buf, count / 4);\n\tif (compress < 0)\n\t\treturn -EINVAL;\n\n\tcd_ratio = socfpga_a10_fpga_get_cd_ratio(cfg_width, encrypt, compress);\n\n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_MASK,\n\t\t\t   cd_ratio << A10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_SHIFT);\n\n\treturn 0;\n}\n\nstatic u32 socfpga_a10_fpga_read_stat(struct a10_fpga_priv *priv)\n{\n\tu32 val;\n\n\tregmap_read(priv->regmap, A10_FPGAMGR_IMGCFG_STAT_OFST, &val);\n\n\treturn val;\n}\n\nstatic int socfpga_a10_fpga_wait_for_pr_ready(struct a10_fpga_priv *priv)\n{\n\tu32 reg, i;\n\n\tfor (i = 0; i < 10 ; i++) {\n\t\treg = socfpga_a10_fpga_read_stat(priv);\n\n\t\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_ERROR)\n\t\t\treturn -EINVAL;\n\n\t\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_READY)\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int socfpga_a10_fpga_wait_for_pr_done(struct a10_fpga_priv *priv)\n{\n\tu32 reg, i;\n\n\tfor (i = 0; i < 10 ; i++) {\n\t\treg = socfpga_a10_fpga_read_stat(priv);\n\n\t\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_ERROR)\n\t\t\treturn -EINVAL;\n\n\t\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_DONE)\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int socfpga_a10_fpga_write_init(struct fpga_manager *mgr,\n\t\t\t\t       struct fpga_image_info *info,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\tunsigned int cfg_width;\n\tu32 msel, stat, mask;\n\tint ret;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG)\n\t\tcfg_width = CFGWDTH_16;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tmsel = socfpga_a10_fpga_read_stat(priv);\n\tmsel &= A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_MASK;\n\tmsel >>= A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_SHIFT;\n\tif ((msel != 0) && (msel != 1)) {\n\t\tdev_dbg(&mgr->dev, \"Fail: invalid msel=%d\\n\", msel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstat = socfpga_a10_fpga_read_stat(priv);\n\tmask = A10_FPGAMGR_IMGCFG_STAT_F2S_NCONFIG_PIN |\n\t       A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN;\n\tif ((stat & mask) != mask)\n\t\treturn -EINVAL;\n\n\t \n\tsocfpga_a10_fpga_set_cfg_width(priv, cfg_width);\n\n\t \n\tret = socfpga_a10_fpga_set_cdratio(mgr, cfg_width, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t     A10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL);\n\n\t \n\tregmap_write(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_00_OFST,\n\t\t     A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NCONFIG |\n\t\t     A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NSTATUS |\n\t\t     A10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_CONDONE |\n\t\t     A10_FPGAMGR_IMGCFG_CTL_00_S2F_NCONFIG);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG, 0);\n\n\t \n\tsocfpga_a10_fpga_generate_dclks(priv, 256);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST);\n\n\t \n\tsocfpga_a10_fpga_generate_dclks(priv, 0x7ff);\n\n\t \n\treturn socfpga_a10_fpga_wait_for_pr_ready(priv);\n}\n\n \nstatic int socfpga_a10_fpga_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\tu32 *buffer_32 = (u32 *)buf;\n\tsize_t i = 0;\n\n\tif (count <= 0)\n\t\treturn -EINVAL;\n\n\t \n\twhile (count >= sizeof(u32)) {\n\t\twritel(buffer_32[i++], priv->fpga_data_addr);\n\t\tcount -= sizeof(u32);\n\t}\n\n\t \n\tswitch (count) {\n\tcase 3:\n\t\twritel(buffer_32[i++] & 0x00ffffff, priv->fpga_data_addr);\n\t\tbreak;\n\tcase 2:\n\t\twritel(buffer_32[i++] & 0x0000ffff, priv->fpga_data_addr);\n\t\tbreak;\n\tcase 1:\n\t\twritel(buffer_32[i++] & 0x000000ff, priv->fpga_data_addr);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int socfpga_a10_fpga_write_complete(struct fpga_manager *mgr,\n\t\t\t\t\t   struct fpga_image_info *info)\n{\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = socfpga_a10_fpga_wait_for_pr_done(priv);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST, 0);\n\n\t \n\tsocfpga_a10_fpga_generate_dclks(priv, 256);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL, 0);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_NCE,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_NCE);\n\n\t \n\tregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG,\n\t\t\t   A10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = socfpga_a10_fpga_read_stat(priv);\n\n\tif (((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_USERMODE) == 0) ||\n\t    ((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_CONDONE_PIN) == 0) ||\n\t    ((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN) == 0)) {\n\t\tdev_dbg(&mgr->dev,\n\t\t\t\"Timeout in final check. Status=%08xf\\n\", reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic enum fpga_mgr_states socfpga_a10_fpga_state(struct fpga_manager *mgr)\n{\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\tu32 reg = socfpga_a10_fpga_read_stat(priv);\n\n\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_USERMODE)\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_READY)\n\t\treturn FPGA_MGR_STATE_WRITE;\n\n\tif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_CRC_ERROR)\n\t\treturn FPGA_MGR_STATE_WRITE_COMPLETE_ERR;\n\n\tif ((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN) == 0)\n\t\treturn FPGA_MGR_STATE_RESET;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic const struct fpga_manager_ops socfpga_a10_fpga_mgr_ops = {\n\t.initial_header_size = (RBF_DECOMPRESS_OFFSET + 1) * 4,\n\t.state = socfpga_a10_fpga_state,\n\t.write_init = socfpga_a10_fpga_write_init,\n\t.write = socfpga_a10_fpga_write,\n\t.write_complete = socfpga_a10_fpga_write_complete,\n};\n\nstatic int socfpga_a10_fpga_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct a10_fpga_priv *priv;\n\tvoid __iomem *reg_base;\n\tstruct fpga_manager *mgr;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\treg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\t \n\tpriv->fpga_data_addr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->fpga_data_addr))\n\t\treturn PTR_ERR(priv->fpga_data_addr);\n\n\t \n\tpriv->regmap = devm_regmap_init_mmio(dev, reg_base,\n\t\t\t\t\t     &socfpga_a10_fpga_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn -ENODEV;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"no clock specified\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable clock\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmgr = fpga_mgr_register(dev, \"SoCFPGA Arria10 FPGA Manager\",\n\t\t\t\t&socfpga_a10_fpga_mgr_ops, priv);\n\tif (IS_ERR(mgr)) {\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn PTR_ERR(mgr);\n\t}\n\n\tplatform_set_drvdata(pdev, mgr);\n\n\treturn 0;\n}\n\nstatic int socfpga_a10_fpga_remove(struct platform_device *pdev)\n{\n\tstruct fpga_manager *mgr = platform_get_drvdata(pdev);\n\tstruct a10_fpga_priv *priv = mgr->priv;\n\n\tfpga_mgr_unregister(mgr);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id socfpga_a10_fpga_of_match[] = {\n\t{ .compatible = \"altr,socfpga-a10-fpga-mgr\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, socfpga_a10_fpga_of_match);\n\nstatic struct platform_driver socfpga_a10_fpga_driver = {\n\t.probe = socfpga_a10_fpga_probe,\n\t.remove = socfpga_a10_fpga_remove,\n\t.driver = {\n\t\t.name\t= \"socfpga_a10_fpga_manager\",\n\t\t.of_match_table = socfpga_a10_fpga_of_match,\n\t},\n};\n\nmodule_platform_driver(socfpga_a10_fpga_driver);\n\nMODULE_AUTHOR(\"Alan Tull <atull@opensource.altera.com>\");\nMODULE_DESCRIPTION(\"SoCFPGA Arria10 FPGA Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}