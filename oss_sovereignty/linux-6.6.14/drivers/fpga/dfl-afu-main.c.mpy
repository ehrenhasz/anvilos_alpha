{
  "module_name": "dfl-afu-main.c",
  "hash_id": "c88359bb17279ea7ea0747bf05be8bd3dfa774c021826749b8768f736a3b249a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-afu-main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/fpga-dfl.h>\n\n#include \"dfl-afu.h\"\n\n#define RST_POLL_INVL 10  \n#define RST_POLL_TIMEOUT 1000  \n\n \nint __afu_port_enable(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tWARN_ON(!pdata->disable_count);\n\n\tif (--pdata->disable_count != 0)\n\t\treturn 0;\n\n\tbase = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);\n\n\t \n\tv = readq(base + PORT_HDR_CTRL);\n\tv &= ~PORT_CTRL_SFTRST;\n\twriteq(v, base + PORT_HDR_CTRL);\n\n\t \n\tif (readq_poll_timeout(base + PORT_HDR_CTRL, v,\n\t\t\t       !(v & PORT_CTRL_SFTRST_ACK),\n\t\t\t       RST_POLL_INVL, RST_POLL_TIMEOUT)) {\n\t\tdev_err(&pdev->dev, \"timeout, failure to enable device\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nint __afu_port_disable(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tif (pdata->disable_count++ != 0)\n\t\treturn 0;\n\n\tbase = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);\n\n\t \n\tv = readq(base + PORT_HDR_CTRL);\n\tv |= PORT_CTRL_SFTRST;\n\twriteq(v, base + PORT_HDR_CTRL);\n\n\t \n\tif (readq_poll_timeout(base + PORT_HDR_CTRL, v,\n\t\t\t       v & PORT_CTRL_SFTRST_ACK,\n\t\t\t       RST_POLL_INVL, RST_POLL_TIMEOUT)) {\n\t\tdev_err(&pdev->dev, \"timeout, failure to disable device\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __port_reset(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = __afu_port_disable(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __afu_port_enable(pdev);\n}\n\nstatic int port_reset(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint ret;\n\n\tmutex_lock(&pdata->lock);\n\tret = __port_reset(pdev);\n\tmutex_unlock(&pdata->lock);\n\n\treturn ret;\n}\n\nstatic int port_get_id(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);\n\n\treturn FIELD_GET(PORT_CAP_PORT_NUM, readq(base + PORT_HDR_CAP));\n}\n\nstatic ssize_t\nid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tint id = port_get_id(to_platform_device(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", id);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic ssize_t\nltr_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + PORT_HDR_CTRL);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"%x\\n\", (u8)FIELD_GET(PORT_CTRL_LATENCY, v));\n}\n\nstatic ssize_t\nltr_store(struct device *dev, struct device_attribute *attr,\n\t  const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tbool ltr;\n\tu64 v;\n\n\tif (kstrtobool(buf, &ltr))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + PORT_HDR_CTRL);\n\tv &= ~PORT_CTRL_LATENCY;\n\tv |= FIELD_PREP(PORT_CTRL_LATENCY, ltr ? 1 : 0);\n\twriteq(v, base + PORT_HDR_CTRL);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ltr);\n\nstatic ssize_t\nap1_event_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + PORT_HDR_STS);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"%x\\n\", (u8)FIELD_GET(PORT_STS_AP1_EVT, v));\n}\n\nstatic ssize_t\nap1_event_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tbool clear;\n\n\tif (kstrtobool(buf, &clear) || !clear)\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(PORT_STS_AP1_EVT, base + PORT_HDR_STS);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ap1_event);\n\nstatic ssize_t\nap2_event_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + PORT_HDR_STS);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"%x\\n\", (u8)FIELD_GET(PORT_STS_AP2_EVT, v));\n}\n\nstatic ssize_t\nap2_event_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tbool clear;\n\n\tif (kstrtobool(buf, &clear) || !clear)\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(PORT_STS_AP2_EVT, base + PORT_HDR_STS);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ap2_event);\n\nstatic ssize_t\npower_state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + PORT_HDR_STS);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%x\\n\", (u8)FIELD_GET(PORT_STS_PWR_STATE, v));\n}\nstatic DEVICE_ATTR_RO(power_state);\n\nstatic ssize_t\nuserclk_freqcmd_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tu64 userclk_freq_cmd;\n\tvoid __iomem *base;\n\n\tif (kstrtou64(buf, 0, &userclk_freq_cmd))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(userclk_freq_cmd, base + PORT_HDR_USRCLK_CMD0);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(userclk_freqcmd);\n\nstatic ssize_t\nuserclk_freqcntrcmd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tu64 userclk_freqcntr_cmd;\n\tvoid __iomem *base;\n\n\tif (kstrtou64(buf, 0, &userclk_freqcntr_cmd))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(userclk_freqcntr_cmd, base + PORT_HDR_USRCLK_CMD1);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(userclk_freqcntrcmd);\n\nstatic ssize_t\nuserclk_freqsts_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tu64 userclk_freqsts;\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tuserclk_freqsts = readq(base + PORT_HDR_USRCLK_STS0);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)userclk_freqsts);\n}\nstatic DEVICE_ATTR_RO(userclk_freqsts);\n\nstatic ssize_t\nuserclk_freqcntrsts_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tu64 userclk_freqcntrsts;\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tuserclk_freqcntrsts = readq(base + PORT_HDR_USRCLK_STS1);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\",\n\t\t       (unsigned long long)userclk_freqcntrsts);\n}\nstatic DEVICE_ATTR_RO(userclk_freqcntrsts);\n\nstatic struct attribute *port_hdr_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_ltr.attr,\n\t&dev_attr_ap1_event.attr,\n\t&dev_attr_ap2_event.attr,\n\t&dev_attr_power_state.attr,\n\t&dev_attr_userclk_freqcmd.attr,\n\t&dev_attr_userclk_freqcntrcmd.attr,\n\t&dev_attr_userclk_freqsts.attr,\n\t&dev_attr_userclk_freqcntrsts.attr,\n\tNULL,\n};\n\nstatic umode_t port_hdr_attrs_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tumode_t mode = attr->mode;\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);\n\n\tif (dfl_feature_revision(base) > 0) {\n\t\t \n\t\tif (attr == &dev_attr_userclk_freqcmd.attr ||\n\t\t    attr == &dev_attr_userclk_freqcntrcmd.attr ||\n\t\t    attr == &dev_attr_userclk_freqsts.attr ||\n\t\t    attr == &dev_attr_userclk_freqcntrsts.attr)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group port_hdr_group = {\n\t.attrs      = port_hdr_attrs,\n\t.is_visible = port_hdr_attrs_visible,\n};\n\nstatic int port_hdr_init(struct platform_device *pdev,\n\t\t\t struct dfl_feature *feature)\n{\n\tport_reset(pdev);\n\n\treturn 0;\n}\n\nstatic long\nport_hdr_ioctl(struct platform_device *pdev, struct dfl_feature *feature,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase DFL_FPGA_PORT_RESET:\n\t\tif (!arg)\n\t\t\tret = port_reset(pdev);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&pdev->dev, \"%x cmd not handled\", cmd);\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dfl_feature_id port_hdr_id_table[] = {\n\t{.id = PORT_FEATURE_ID_HEADER,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops port_hdr_ops = {\n\t.init = port_hdr_init,\n\t.ioctl = port_hdr_ioctl,\n};\n\nstatic ssize_t\nafu_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 guidl, guidh;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_AFU);\n\n\tmutex_lock(&pdata->lock);\n\tif (pdata->disable_count) {\n\t\tmutex_unlock(&pdata->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tguidl = readq(base + GUID_L);\n\tguidh = readq(base + GUID_H);\n\tmutex_unlock(&pdata->lock);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%016llx%016llx\\n\", guidh, guidl);\n}\nstatic DEVICE_ATTR_RO(afu_id);\n\nstatic struct attribute *port_afu_attrs[] = {\n\t&dev_attr_afu_id.attr,\n\tNULL\n};\n\nstatic umode_t port_afu_attrs_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\t \n\tif (!dfl_get_feature_by_id(dev, PORT_FEATURE_ID_AFU))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group port_afu_group = {\n\t.attrs      = port_afu_attrs,\n\t.is_visible = port_afu_attrs_visible,\n};\n\nstatic int port_afu_init(struct platform_device *pdev,\n\t\t\t struct dfl_feature *feature)\n{\n\tstruct resource *res = &pdev->resource[feature->resource_index];\n\n\treturn afu_mmio_region_add(dev_get_platdata(&pdev->dev),\n\t\t\t\t   DFL_PORT_REGION_INDEX_AFU,\n\t\t\t\t   resource_size(res), res->start,\n\t\t\t\t   DFL_PORT_REGION_MMAP | DFL_PORT_REGION_READ |\n\t\t\t\t   DFL_PORT_REGION_WRITE);\n}\n\nstatic const struct dfl_feature_id port_afu_id_table[] = {\n\t{.id = PORT_FEATURE_ID_AFU,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops port_afu_ops = {\n\t.init = port_afu_init,\n};\n\nstatic int port_stp_init(struct platform_device *pdev,\n\t\t\t struct dfl_feature *feature)\n{\n\tstruct resource *res = &pdev->resource[feature->resource_index];\n\n\treturn afu_mmio_region_add(dev_get_platdata(&pdev->dev),\n\t\t\t\t   DFL_PORT_REGION_INDEX_STP,\n\t\t\t\t   resource_size(res), res->start,\n\t\t\t\t   DFL_PORT_REGION_MMAP | DFL_PORT_REGION_READ |\n\t\t\t\t   DFL_PORT_REGION_WRITE);\n}\n\nstatic const struct dfl_feature_id port_stp_id_table[] = {\n\t{.id = PORT_FEATURE_ID_STP,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops port_stp_ops = {\n\t.init = port_stp_init,\n};\n\nstatic long\nport_uint_ioctl(struct platform_device *pdev, struct dfl_feature *feature,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase DFL_FPGA_PORT_UINT_GET_IRQ_NUM:\n\t\treturn dfl_feature_ioctl_get_num_irqs(pdev, feature, arg);\n\tcase DFL_FPGA_PORT_UINT_SET_IRQ:\n\t\treturn dfl_feature_ioctl_set_irq(pdev, feature, arg);\n\tdefault:\n\t\tdev_dbg(&pdev->dev, \"%x cmd not handled\", cmd);\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic const struct dfl_feature_id port_uint_id_table[] = {\n\t{.id = PORT_FEATURE_ID_UINT,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops port_uint_ops = {\n\t.ioctl = port_uint_ioctl,\n};\n\nstatic struct dfl_feature_driver port_feature_drvs[] = {\n\t{\n\t\t.id_table = port_hdr_id_table,\n\t\t.ops = &port_hdr_ops,\n\t},\n\t{\n\t\t.id_table = port_afu_id_table,\n\t\t.ops = &port_afu_ops,\n\t},\n\t{\n\t\t.id_table = port_err_id_table,\n\t\t.ops = &port_err_ops,\n\t},\n\t{\n\t\t.id_table = port_stp_id_table,\n\t\t.ops = &port_stp_ops,\n\t},\n\t{\n\t\t.id_table = port_uint_id_table,\n\t\t.ops = &port_uint_ops,\n\t},\n\t{\n\t\t.ops = NULL,\n\t}\n};\n\nstatic int afu_open(struct inode *inode, struct file *filp)\n{\n\tstruct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);\n\tstruct dfl_feature_platform_data *pdata;\n\tint ret;\n\n\tpdata = dev_get_platdata(&fdev->dev);\n\tif (WARN_ON(!pdata))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&pdata->lock);\n\tret = dfl_feature_dev_use_begin(pdata, filp->f_flags & O_EXCL);\n\tif (!ret) {\n\t\tdev_dbg(&fdev->dev, \"Device File Opened %d Times\\n\",\n\t\t\tdfl_feature_dev_use_count(pdata));\n\t\tfilp->private_data = fdev;\n\t}\n\tmutex_unlock(&pdata->lock);\n\n\treturn ret;\n}\n\nstatic int afu_release(struct inode *inode, struct file *filp)\n{\n\tstruct platform_device *pdev = filp->private_data;\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct dfl_feature *feature;\n\n\tdev_dbg(&pdev->dev, \"Device File Release\\n\");\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\tdfl_feature_dev_use_end(pdata);\n\n\tif (!dfl_feature_dev_use_count(pdata)) {\n\t\tdfl_fpga_dev_for_each_feature(pdata, feature)\n\t\t\tdfl_fpga_set_irq_triggers(feature, 0,\n\t\t\t\t\t\t  feature->nr_irqs, NULL);\n\t\t__port_reset(pdev);\n\t\tafu_dma_region_destroy(pdata);\n\t}\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n}\n\nstatic long afu_ioctl_check_extension(struct dfl_feature_platform_data *pdata,\n\t\t\t\t      unsigned long arg)\n{\n\t \n\treturn 0;\n}\n\nstatic long\nafu_ioctl_get_info(struct dfl_feature_platform_data *pdata, void __user *arg)\n{\n\tstruct dfl_fpga_port_info info;\n\tstruct dfl_afu *afu;\n\tunsigned long minsz;\n\n\tminsz = offsetofend(struct dfl_fpga_port_info, num_umsgs);\n\n\tif (copy_from_user(&info, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (info.argsz < minsz)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pdata->lock);\n\tafu = dfl_fpga_pdata_get_private(pdata);\n\tinfo.flags = 0;\n\tinfo.num_regions = afu->num_regions;\n\tinfo.num_umsgs = afu->num_umsgs;\n\tmutex_unlock(&pdata->lock);\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long afu_ioctl_get_region_info(struct dfl_feature_platform_data *pdata,\n\t\t\t\t      void __user *arg)\n{\n\tstruct dfl_fpga_port_region_info rinfo;\n\tstruct dfl_afu_mmio_region region;\n\tunsigned long minsz;\n\tlong ret;\n\n\tminsz = offsetofend(struct dfl_fpga_port_region_info, offset);\n\n\tif (copy_from_user(&rinfo, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (rinfo.argsz < minsz || rinfo.padding)\n\t\treturn -EINVAL;\n\n\tret = afu_mmio_region_get_by_index(pdata, rinfo.index, &region);\n\tif (ret)\n\t\treturn ret;\n\n\trinfo.flags = region.flags;\n\trinfo.size = region.size;\n\trinfo.offset = region.offset;\n\n\tif (copy_to_user(arg, &rinfo, sizeof(rinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long\nafu_ioctl_dma_map(struct dfl_feature_platform_data *pdata, void __user *arg)\n{\n\tstruct dfl_fpga_port_dma_map map;\n\tunsigned long minsz;\n\tlong ret;\n\n\tminsz = offsetofend(struct dfl_fpga_port_dma_map, iova);\n\n\tif (copy_from_user(&map, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (map.argsz < minsz || map.flags)\n\t\treturn -EINVAL;\n\n\tret = afu_dma_map_region(pdata, map.user_addr, map.length, &map.iova);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &map, sizeof(map))) {\n\t\tafu_dma_unmap_region(pdata, map.iova);\n\t\treturn -EFAULT;\n\t}\n\n\tdev_dbg(&pdata->dev->dev, \"dma map: ua=%llx, len=%llx, iova=%llx\\n\",\n\t\t(unsigned long long)map.user_addr,\n\t\t(unsigned long long)map.length,\n\t\t(unsigned long long)map.iova);\n\n\treturn 0;\n}\n\nstatic long\nafu_ioctl_dma_unmap(struct dfl_feature_platform_data *pdata, void __user *arg)\n{\n\tstruct dfl_fpga_port_dma_unmap unmap;\n\tunsigned long minsz;\n\n\tminsz = offsetofend(struct dfl_fpga_port_dma_unmap, iova);\n\n\tif (copy_from_user(&unmap, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (unmap.argsz < minsz || unmap.flags)\n\t\treturn -EINVAL;\n\n\treturn afu_dma_unmap_region(pdata, unmap.iova);\n}\n\nstatic long afu_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct platform_device *pdev = filp->private_data;\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct dfl_feature *f;\n\tlong ret;\n\n\tdev_dbg(&pdev->dev, \"%s cmd 0x%x\\n\", __func__, cmd);\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\tswitch (cmd) {\n\tcase DFL_FPGA_GET_API_VERSION:\n\t\treturn DFL_FPGA_API_VERSION;\n\tcase DFL_FPGA_CHECK_EXTENSION:\n\t\treturn afu_ioctl_check_extension(pdata, arg);\n\tcase DFL_FPGA_PORT_GET_INFO:\n\t\treturn afu_ioctl_get_info(pdata, (void __user *)arg);\n\tcase DFL_FPGA_PORT_GET_REGION_INFO:\n\t\treturn afu_ioctl_get_region_info(pdata, (void __user *)arg);\n\tcase DFL_FPGA_PORT_DMA_MAP:\n\t\treturn afu_ioctl_dma_map(pdata, (void __user *)arg);\n\tcase DFL_FPGA_PORT_DMA_UNMAP:\n\t\treturn afu_ioctl_dma_unmap(pdata, (void __user *)arg);\n\tdefault:\n\t\t \n\t\tdfl_fpga_dev_for_each_feature(pdata, f)\n\t\t\tif (f->ops && f->ops->ioctl) {\n\t\t\t\tret = f->ops->ioctl(pdev, f, cmd, arg);\n\t\t\t\tif (ret != -ENODEV)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct vm_operations_struct afu_vma_ops = {\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t.access = generic_access_phys,\n#endif\n};\n\nstatic int afu_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct platform_device *pdev = filp->private_data;\n\tstruct dfl_feature_platform_data *pdata;\n\tu64 size = vma->vm_end - vma->vm_start;\n\tstruct dfl_afu_mmio_region region;\n\tu64 offset;\n\tint ret;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\toffset = vma->vm_pgoff << PAGE_SHIFT;\n\tret = afu_mmio_region_get_by_offset(pdata, offset, size, &region);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(region.flags & DFL_PORT_REGION_MMAP))\n\t\treturn -EINVAL;\n\n\tif ((vma->vm_flags & VM_READ) && !(region.flags & DFL_PORT_REGION_READ))\n\t\treturn -EPERM;\n\n\tif ((vma->vm_flags & VM_WRITE) &&\n\t    !(region.flags & DFL_PORT_REGION_WRITE))\n\t\treturn -EPERM;\n\n\t \n\tvma->vm_ops = &afu_vma_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t(region.phys + (offset - region.offset)) >> PAGE_SHIFT,\n\t\t\tsize, vma->vm_page_prot);\n}\n\nstatic const struct file_operations afu_fops = {\n\t.owner = THIS_MODULE,\n\t.open = afu_open,\n\t.release = afu_release,\n\t.unlocked_ioctl = afu_ioctl,\n\t.mmap = afu_mmap,\n};\n\nstatic int afu_dev_init(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_afu *afu;\n\n\tafu = devm_kzalloc(&pdev->dev, sizeof(*afu), GFP_KERNEL);\n\tif (!afu)\n\t\treturn -ENOMEM;\n\n\tafu->pdata = pdata;\n\n\tmutex_lock(&pdata->lock);\n\tdfl_fpga_pdata_set_private(pdata, afu);\n\tafu_mmio_region_init(pdata);\n\tafu_dma_region_init(pdata);\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n}\n\nstatic int afu_dev_destroy(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\tafu_mmio_region_destroy(pdata);\n\tafu_dma_region_destroy(pdata);\n\tdfl_fpga_pdata_set_private(pdata, NULL);\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n}\n\nstatic int port_enable_set(struct platform_device *pdev, bool enable)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint ret;\n\n\tmutex_lock(&pdata->lock);\n\tif (enable)\n\t\tret = __afu_port_enable(pdev);\n\telse\n\t\tret = __afu_port_disable(pdev);\n\tmutex_unlock(&pdata->lock);\n\n\treturn ret;\n}\n\nstatic struct dfl_fpga_port_ops afu_port_ops = {\n\t.name = DFL_FPGA_FEATURE_DEV_PORT,\n\t.owner = THIS_MODULE,\n\t.get_id = port_get_id,\n\t.enable_set = port_enable_set,\n};\n\nstatic int afu_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tret = afu_dev_init(pdev);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = dfl_fpga_dev_feature_init(pdev, port_feature_drvs);\n\tif (ret)\n\t\tgoto dev_destroy;\n\n\tret = dfl_fpga_dev_ops_register(pdev, &afu_fops, THIS_MODULE);\n\tif (ret) {\n\t\tdfl_fpga_dev_feature_uinit(pdev);\n\t\tgoto dev_destroy;\n\t}\n\n\treturn 0;\n\ndev_destroy:\n\tafu_dev_destroy(pdev);\nexit:\n\treturn ret;\n}\n\nstatic int afu_remove(struct platform_device *pdev)\n{\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tdfl_fpga_dev_ops_unregister(pdev);\n\tdfl_fpga_dev_feature_uinit(pdev);\n\tafu_dev_destroy(pdev);\n\n\treturn 0;\n}\n\nstatic const struct attribute_group *afu_dev_groups[] = {\n\t&port_hdr_group,\n\t&port_afu_group,\n\t&port_err_group,\n\tNULL\n};\n\nstatic struct platform_driver afu_driver = {\n\t.driver\t= {\n\t\t.name\t    = DFL_FPGA_FEATURE_DEV_PORT,\n\t\t.dev_groups = afu_dev_groups,\n\t},\n\t.probe   = afu_probe,\n\t.remove  = afu_remove,\n};\n\nstatic int __init afu_init(void)\n{\n\tint ret;\n\n\tdfl_fpga_port_ops_add(&afu_port_ops);\n\n\tret = platform_driver_register(&afu_driver);\n\tif (ret)\n\t\tdfl_fpga_port_ops_del(&afu_port_ops);\n\n\treturn ret;\n}\n\nstatic void __exit afu_exit(void)\n{\n\tplatform_driver_unregister(&afu_driver);\n\n\tdfl_fpga_port_ops_del(&afu_port_ops);\n}\n\nmodule_init(afu_init);\nmodule_exit(afu_exit);\n\nMODULE_DESCRIPTION(\"FPGA Accelerated Function Unit driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dfl-port\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}