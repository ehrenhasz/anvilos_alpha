{
  "module_name": "altera-fpga2sdram.c",
  "hash_id": "f8d0f0069ce23f36a43d67aeef17dad441a1ae3b6eece4ce02b95690da84dd63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-fpga2sdram.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fpga/fpga-bridge.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define ALT_SDR_CTL_FPGAPORTRST_OFST\t\t0x80\n#define ALT_SDR_CTL_FPGAPORTRST_PORTRSTN_MSK\t0x00003fff\n#define ALT_SDR_CTL_FPGAPORTRST_RD_SHIFT\t0\n#define ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT\t4\n#define ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT\t8\n\n \n#define SYSMGR_ISWGRP_HANDOFF3          (0x8C)\n\n#define F2S_BRIDGE_NAME \"fpga2sdram\"\n\nstruct alt_fpga2sdram_data {\n\tstruct device *dev;\n\tstruct regmap *sdrctl;\n\tint mask;\n};\n\nstatic int alt_fpga2sdram_enable_show(struct fpga_bridge *bridge)\n{\n\tstruct alt_fpga2sdram_data *priv = bridge->priv;\n\tint value;\n\n\tregmap_read(priv->sdrctl, ALT_SDR_CTL_FPGAPORTRST_OFST, &value);\n\n\treturn (value & priv->mask) == priv->mask;\n}\n\nstatic inline int _alt_fpga2sdram_enable_set(struct alt_fpga2sdram_data *priv,\n\t\t\t\t\t     bool enable)\n{\n\treturn regmap_update_bits(priv->sdrctl, ALT_SDR_CTL_FPGAPORTRST_OFST,\n\t\t\t\t  priv->mask, enable ? priv->mask : 0);\n}\n\nstatic int alt_fpga2sdram_enable_set(struct fpga_bridge *bridge, bool enable)\n{\n\treturn _alt_fpga2sdram_enable_set(bridge->priv, enable);\n}\n\nstruct prop_map {\n\tchar *prop_name;\n\tu32 *prop_value;\n\tu32 prop_max;\n};\n\nstatic const struct fpga_bridge_ops altera_fpga2sdram_br_ops = {\n\t.enable_set = alt_fpga2sdram_enable_set,\n\t.enable_show = alt_fpga2sdram_enable_show,\n};\n\nstatic const struct of_device_id altera_fpga_of_match[] = {\n\t{ .compatible = \"altr,socfpga-fpga2sdram-bridge\" },\n\t{},\n};\n\nstatic int alt_fpga_bridge_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct alt_fpga2sdram_data *priv;\n\tstruct fpga_bridge *br;\n\tu32 enable;\n\tstruct regmap *sysmgr;\n\tint ret = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->sdrctl = syscon_regmap_lookup_by_compatible(\"altr,sdr-ctl\");\n\tif (IS_ERR(priv->sdrctl)) {\n\t\tdev_err(dev, \"regmap for altr,sdr-ctl lookup failed.\\n\");\n\t\treturn PTR_ERR(priv->sdrctl);\n\t}\n\n\tsysmgr = syscon_regmap_lookup_by_compatible(\"altr,sys-mgr\");\n\tif (IS_ERR(sysmgr)) {\n\t\tdev_err(dev, \"regmap for altr,sys-mgr lookup failed.\\n\");\n\t\treturn PTR_ERR(sysmgr);\n\t}\n\n\t \n\tregmap_read(sysmgr, SYSMGR_ISWGRP_HANDOFF3, &priv->mask);\n\n\tbr = fpga_bridge_register(dev, F2S_BRIDGE_NAME,\n\t\t\t\t  &altera_fpga2sdram_br_ops, priv);\n\tif (IS_ERR(br))\n\t\treturn PTR_ERR(br);\n\n\tplatform_set_drvdata(pdev, br);\n\n\tdev_info(dev, \"driver initialized with handoff %08x\\n\", priv->mask);\n\n\tif (!of_property_read_u32(dev->of_node, \"bridge-enable\", &enable)) {\n\t\tif (enable > 1) {\n\t\t\tdev_warn(dev, \"invalid bridge-enable %u > 1\\n\", enable);\n\t\t} else {\n\t\t\tdev_info(dev, \"%s bridge\\n\",\n\t\t\t\t (enable ? \"enabling\" : \"disabling\"));\n\t\t\tret = _alt_fpga2sdram_enable_set(priv, enable);\n\t\t\tif (ret) {\n\t\t\t\tfpga_bridge_unregister(br);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int alt_fpga_bridge_remove(struct platform_device *pdev)\n{\n\tstruct fpga_bridge *br = platform_get_drvdata(pdev);\n\n\tfpga_bridge_unregister(br);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(of, altera_fpga_of_match);\n\nstatic struct platform_driver altera_fpga_driver = {\n\t.probe = alt_fpga_bridge_probe,\n\t.remove = alt_fpga_bridge_remove,\n\t.driver = {\n\t\t.name\t= \"altera_fpga2sdram_bridge\",\n\t\t.of_match_table = of_match_ptr(altera_fpga_of_match),\n\t},\n};\n\nmodule_platform_driver(altera_fpga_driver);\n\nMODULE_DESCRIPTION(\"Altera SoCFPGA FPGA to SDRAM Bridge\");\nMODULE_AUTHOR(\"Alan Tull <atull@opensource.altera.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}