{
  "module_name": "altera-ps-spi.c",
  "hash_id": "f8474621b04e0d0aa12edf04a761e3e344cfc927568f279b4dcee6dd49a1269c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-ps-spi.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/of_device.h>\n#include <linux/spi/spi.h>\n#include <linux/sizes.h>\n\nenum altera_ps_devtype {\n\tCYCLONE5,\n\tARRIA10,\n};\n\nstruct altera_ps_data {\n\tenum altera_ps_devtype devtype;\n\tint status_wait_min_us;\n\tint status_wait_max_us;\n\tint t_cfg_us;\n\tint t_st2ck_us;\n};\n\nstruct altera_ps_conf {\n\tstruct gpio_desc *config;\n\tstruct gpio_desc *confd;\n\tstruct gpio_desc *status;\n\tstruct spi_device *spi;\n\tconst struct altera_ps_data *data;\n\tu32 info_flags;\n\tchar mgr_name[64];\n};\n\n \nstatic struct altera_ps_data c5_data = {\n\t \n\t.devtype = CYCLONE5,\n\t.status_wait_min_us = 268,\n\t.status_wait_max_us = 1506,\n\t.t_cfg_us = 2,\n\t.t_st2ck_us = 2,\n};\n\nstatic struct altera_ps_data a10_data = {\n\t.devtype = ARRIA10,\n\t.status_wait_min_us = 268,   \n\t.status_wait_max_us = 3000,  \n\t.t_cfg_us = 2,     \n\t.t_st2ck_us = 10,  \n};\n\n \nstatic const struct altera_ps_data *altera_ps_data_map[] = {\n\t&c5_data,\n\t&a10_data,\n};\n\nstatic const struct of_device_id of_ef_match[] = {\n\t{ .compatible = \"altr,fpga-passive-serial\", .data = &c5_data },\n\t{ .compatible = \"altr,fpga-arria10-passive-serial\", .data = &a10_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_ef_match);\n\nstatic enum fpga_mgr_states altera_ps_state(struct fpga_manager *mgr)\n{\n\tstruct altera_ps_conf *conf = mgr->priv;\n\n\tif (gpiod_get_value_cansleep(conf->status))\n\t\treturn FPGA_MGR_STATE_RESET;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic inline void altera_ps_delay(int delay_us)\n{\n\tif (delay_us > 10)\n\t\tusleep_range(delay_us, delay_us + 5);\n\telse\n\t\tudelay(delay_us);\n}\n\nstatic int altera_ps_write_init(struct fpga_manager *mgr,\n\t\t\t\tstruct fpga_image_info *info,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct altera_ps_conf *conf = mgr->priv;\n\tint min, max, waits;\n\tint i;\n\n\tconf->info_flags = info->flags;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(&mgr->dev, \"Partial reconfiguration not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpiod_set_value_cansleep(conf->config, 1);\n\n\t \n\taltera_ps_delay(conf->data->t_cfg_us);\n\n\tif (!gpiod_get_value_cansleep(conf->status)) {\n\t\tdev_err(&mgr->dev, \"Status pin failed to show a reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\tgpiod_set_value_cansleep(conf->config, 0);\n\n\tmin = conf->data->status_wait_min_us;\n\tmax = conf->data->status_wait_max_us;\n\twaits = max / min;\n\tif (max % min)\n\t\twaits++;\n\n\t \n\tfor (i = 0; i < waits; i++) {\n\t\tusleep_range(min, min + 10);\n\t\tif (!gpiod_get_value_cansleep(conf->status)) {\n\t\t\t \n\t\t\taltera_ps_delay(conf->data->t_st2ck_us);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&mgr->dev, \"Status pin not ready.\\n\");\n\treturn -EIO;\n}\n\nstatic void rev_buf(char *buf, size_t len)\n{\n\tu32 *fw32 = (u32 *)buf;\n\tsize_t extra_bytes = (len & 0x03);\n\tconst u32 *fw_end = (u32 *)(buf + len - extra_bytes);\n\n\t \n\twhile (fw32 < fw_end) {\n\t\t*fw32 = bitrev8x4(*fw32);\n\t\tfw32++;\n\t}\n\n\tif (extra_bytes) {\n\t\tbuf = (char *)fw_end;\n\t\twhile (extra_bytes) {\n\t\t\t*buf = bitrev8(*buf);\n\t\t\tbuf++;\n\t\t\textra_bytes--;\n\t\t}\n\t}\n}\n\nstatic int altera_ps_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t   size_t count)\n{\n\tstruct altera_ps_conf *conf = mgr->priv;\n\tconst char *fw_data = buf;\n\tconst char *fw_data_end = fw_data + count;\n\n\twhile (fw_data < fw_data_end) {\n\t\tint ret;\n\t\tsize_t stride = min_t(size_t, fw_data_end - fw_data, SZ_4K);\n\n\t\tif (!(conf->info_flags & FPGA_MGR_BITSTREAM_LSB_FIRST))\n\t\t\trev_buf((char *)fw_data, stride);\n\n\t\tret = spi_write(conf->spi, fw_data, stride);\n\t\tif (ret) {\n\t\t\tdev_err(&mgr->dev, \"spi error in firmware write: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tfw_data += stride;\n\t}\n\n\treturn 0;\n}\n\nstatic int altera_ps_write_complete(struct fpga_manager *mgr,\n\t\t\t\t    struct fpga_image_info *info)\n{\n\tstruct altera_ps_conf *conf = mgr->priv;\n\tstatic const char dummy[] = {0};\n\tint ret;\n\n\tif (gpiod_get_value_cansleep(conf->status)) {\n\t\tdev_err(&mgr->dev, \"Error during configuration.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (conf->confd) {\n\t\tif (!gpiod_get_raw_value_cansleep(conf->confd)) {\n\t\t\tdev_err(&mgr->dev, \"CONF_DONE is inactive!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tret = spi_write(conf->spi, dummy, 1);\n\tif (ret) {\n\t\tdev_err(&mgr->dev, \"spi error during end sequence: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fpga_manager_ops altera_ps_ops = {\n\t.state = altera_ps_state,\n\t.write_init = altera_ps_write_init,\n\t.write = altera_ps_write,\n\t.write_complete = altera_ps_write_complete,\n};\n\nstatic const struct altera_ps_data *id_to_data(const struct spi_device_id *id)\n{\n\tkernel_ulong_t devtype = id->driver_data;\n\tconst struct altera_ps_data *data;\n\n\t \n\tif (devtype >= ARRAY_SIZE(altera_ps_data_map))\n\t\treturn NULL;\n\n\tdata = altera_ps_data_map[devtype];\n\tif (!data || data->devtype != devtype)\n\t\treturn NULL;\n\n\treturn data;\n}\n\nstatic int altera_ps_probe(struct spi_device *spi)\n{\n\tstruct altera_ps_conf *conf;\n\tconst struct of_device_id *of_id;\n\tstruct fpga_manager *mgr;\n\n\tconf = devm_kzalloc(&spi->dev, sizeof(*conf), GFP_KERNEL);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\n\tif (spi->dev.of_node) {\n\t\tof_id = of_match_device(of_ef_match, &spi->dev);\n\t\tif (!of_id)\n\t\t\treturn -ENODEV;\n\t\tconf->data = of_id->data;\n\t} else {\n\t\tconf->data = id_to_data(spi_get_device_id(spi));\n\t\tif (!conf->data)\n\t\t\treturn -ENODEV;\n\t}\n\n\tconf->spi = spi;\n\tconf->config = devm_gpiod_get(&spi->dev, \"nconfig\", GPIOD_OUT_LOW);\n\tif (IS_ERR(conf->config)) {\n\t\tdev_err(&spi->dev, \"Failed to get config gpio: %ld\\n\",\n\t\t\tPTR_ERR(conf->config));\n\t\treturn PTR_ERR(conf->config);\n\t}\n\n\tconf->status = devm_gpiod_get(&spi->dev, \"nstat\", GPIOD_IN);\n\tif (IS_ERR(conf->status)) {\n\t\tdev_err(&spi->dev, \"Failed to get status gpio: %ld\\n\",\n\t\t\tPTR_ERR(conf->status));\n\t\treturn PTR_ERR(conf->status);\n\t}\n\n\tconf->confd = devm_gpiod_get_optional(&spi->dev, \"confd\", GPIOD_IN);\n\tif (IS_ERR(conf->confd)) {\n\t\tdev_err(&spi->dev, \"Failed to get confd gpio: %ld\\n\",\n\t\t\tPTR_ERR(conf->confd));\n\t\treturn PTR_ERR(conf->confd);\n\t} else if (!conf->confd) {\n\t\tdev_warn(&spi->dev, \"Not using confd gpio\");\n\t}\n\n\t \n\tsnprintf(conf->mgr_name, sizeof(conf->mgr_name), \"%s %s\",\n\t\t dev_driver_string(&spi->dev), dev_name(&spi->dev));\n\n\tmgr = devm_fpga_mgr_register(&spi->dev, conf->mgr_name,\n\t\t\t\t     &altera_ps_ops, conf);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\nstatic const struct spi_device_id altera_ps_spi_ids[] = {\n\t{ \"cyclone-ps-spi\", CYCLONE5 },\n\t{ \"fpga-passive-serial\", CYCLONE5 },\n\t{ \"fpga-arria10-passive-serial\", ARRIA10 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, altera_ps_spi_ids);\n\nstatic struct spi_driver altera_ps_driver = {\n\t.driver = {\n\t\t.name = \"altera-ps-spi\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = of_match_ptr(of_ef_match),\n\t},\n\t.id_table = altera_ps_spi_ids,\n\t.probe = altera_ps_probe,\n};\n\nmodule_spi_driver(altera_ps_driver)\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Joshua Clayton <stillcompiling@gmail.com>\");\nMODULE_DESCRIPTION(\"Module to load Altera FPGA firmware over SPI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}