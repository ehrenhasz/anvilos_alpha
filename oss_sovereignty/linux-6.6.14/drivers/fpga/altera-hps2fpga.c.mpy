{
  "module_name": "altera-hps2fpga.c",
  "hash_id": "659d3409041e7c2bd8d4e8148b65d76ab3babf6f590ddfd97128b5451d294614",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-hps2fpga.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/fpga/fpga-bridge.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#define ALT_L3_REMAP_OFST\t\t\t0x0\n#define ALT_L3_REMAP_MPUZERO_MSK\t\t0x00000001\n#define ALT_L3_REMAP_H2F_MSK\t\t\t0x00000008\n#define ALT_L3_REMAP_LWH2F_MSK\t\t\t0x00000010\n\n#define HPS2FPGA_BRIDGE_NAME\t\t\t\"hps2fpga\"\n#define LWHPS2FPGA_BRIDGE_NAME\t\t\t\"lwhps2fpga\"\n#define FPGA2HPS_BRIDGE_NAME\t\t\t\"fpga2hps\"\n\nstruct altera_hps2fpga_data {\n\tconst char *name;\n\tstruct reset_control *bridge_reset;\n\tstruct regmap *l3reg;\n\tunsigned int remap_mask;\n\tstruct clk *clk;\n};\n\nstatic int alt_hps2fpga_enable_show(struct fpga_bridge *bridge)\n{\n\tstruct altera_hps2fpga_data *priv = bridge->priv;\n\n\treturn reset_control_status(priv->bridge_reset);\n}\n\n \nstatic unsigned int l3_remap_shadow;\nstatic DEFINE_SPINLOCK(l3_remap_lock);\n\nstatic int _alt_hps2fpga_enable_set(struct altera_hps2fpga_data *priv,\n\t\t\t\t    bool enable)\n{\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (enable)\n\t\tret = reset_control_deassert(priv->bridge_reset);\n\telse\n\t\tret = reset_control_assert(priv->bridge_reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->remap_mask) {\n\t\tspin_lock_irqsave(&l3_remap_lock, flags);\n\t\tl3_remap_shadow |= ALT_L3_REMAP_MPUZERO_MSK;\n\n\t\tif (enable)\n\t\t\tl3_remap_shadow |= priv->remap_mask;\n\t\telse\n\t\t\tl3_remap_shadow &= ~priv->remap_mask;\n\n\t\tret = regmap_write(priv->l3reg, ALT_L3_REMAP_OFST,\n\t\t\t\t   l3_remap_shadow);\n\t\tspin_unlock_irqrestore(&l3_remap_lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int alt_hps2fpga_enable_set(struct fpga_bridge *bridge, bool enable)\n{\n\treturn _alt_hps2fpga_enable_set(bridge->priv, enable);\n}\n\nstatic const struct fpga_bridge_ops altera_hps2fpga_br_ops = {\n\t.enable_set = alt_hps2fpga_enable_set,\n\t.enable_show = alt_hps2fpga_enable_show,\n};\n\nstatic struct altera_hps2fpga_data hps2fpga_data  = {\n\t.name = HPS2FPGA_BRIDGE_NAME,\n\t.remap_mask = ALT_L3_REMAP_H2F_MSK,\n};\n\nstatic struct altera_hps2fpga_data lwhps2fpga_data  = {\n\t.name = LWHPS2FPGA_BRIDGE_NAME,\n\t.remap_mask = ALT_L3_REMAP_LWH2F_MSK,\n};\n\nstatic struct altera_hps2fpga_data fpga2hps_data  = {\n\t.name = FPGA2HPS_BRIDGE_NAME,\n};\n\nstatic const struct of_device_id altera_fpga_of_match[] = {\n\t{ .compatible = \"altr,socfpga-hps2fpga-bridge\",\n\t  .data = &hps2fpga_data },\n\t{ .compatible = \"altr,socfpga-lwhps2fpga-bridge\",\n\t  .data = &lwhps2fpga_data },\n\t{ .compatible = \"altr,socfpga-fpga2hps-bridge\",\n\t  .data = &fpga2hps_data },\n\t{},\n};\n\nstatic int alt_fpga_bridge_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct altera_hps2fpga_data *priv;\n\tconst struct of_device_id *of_id;\n\tstruct fpga_bridge *br;\n\tu32 enable;\n\tint ret;\n\n\tof_id = of_match_device(altera_fpga_of_match, dev);\n\tif (!of_id) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = (struct altera_hps2fpga_data *)of_id->data;\n\n\tpriv->bridge_reset = of_reset_control_get_exclusive_by_index(dev->of_node,\n\t\t\t\t\t\t\t\t     0);\n\tif (IS_ERR(priv->bridge_reset)) {\n\t\tdev_err(dev, \"Could not get %s reset control\\n\", priv->name);\n\t\treturn PTR_ERR(priv->bridge_reset);\n\t}\n\n\tif (priv->remap_mask) {\n\t\tpriv->l3reg = syscon_regmap_lookup_by_compatible(\"altr,l3regs\");\n\t\tif (IS_ERR(priv->l3reg)) {\n\t\t\tdev_err(dev, \"regmap for altr,l3regs lookup failed\\n\");\n\t\t\treturn PTR_ERR(priv->l3reg);\n\t\t}\n\t}\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"no clock specified\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable clock\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"bridge-enable\", &enable)) {\n\t\tif (enable > 1) {\n\t\t\tdev_warn(dev, \"invalid bridge-enable %u > 1\\n\", enable);\n\t\t} else {\n\t\t\tdev_info(dev, \"%s bridge\\n\",\n\t\t\t\t (enable ? \"enabling\" : \"disabling\"));\n\n\t\t\tret = _alt_hps2fpga_enable_set(priv, enable);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tbr = fpga_bridge_register(dev, priv->name,\n\t\t\t\t  &altera_hps2fpga_br_ops, priv);\n\tif (IS_ERR(br)) {\n\t\tret = PTR_ERR(br);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, br);\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int alt_fpga_bridge_remove(struct platform_device *pdev)\n{\n\tstruct fpga_bridge *bridge = platform_get_drvdata(pdev);\n\tstruct altera_hps2fpga_data *priv = bridge->priv;\n\n\tfpga_bridge_unregister(bridge);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(of, altera_fpga_of_match);\n\nstatic struct platform_driver alt_fpga_bridge_driver = {\n\t.probe = alt_fpga_bridge_probe,\n\t.remove = alt_fpga_bridge_remove,\n\t.driver = {\n\t\t.name\t= \"altera_hps2fpga_bridge\",\n\t\t.of_match_table = of_match_ptr(altera_fpga_of_match),\n\t},\n};\n\nmodule_platform_driver(alt_fpga_bridge_driver);\n\nMODULE_DESCRIPTION(\"Altera SoCFPGA HPS to FPGA Bridge\");\nMODULE_AUTHOR(\"Alan Tull <atull@opensource.altera.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}