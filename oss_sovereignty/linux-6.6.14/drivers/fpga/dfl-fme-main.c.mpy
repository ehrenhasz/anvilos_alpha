{
  "module_name": "dfl-fme-main.c",
  "hash_id": "ac816c2e48d0c961684155d9c75096e06b7f265302d84515c147ab9fc2fef6fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-fme-main.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/units.h>\n#include <linux/fpga-dfl.h>\n\n#include \"dfl.h\"\n#include \"dfl-fme.h\"\n\nstatic ssize_t ports_num_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_CAP);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t (unsigned int)FIELD_GET(FME_CAP_NUM_PORTS, v));\n}\nstatic DEVICE_ATTR_RO(ports_num);\n\n \nstatic ssize_t bitstream_id_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_BITSTREAM_ID);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\", (unsigned long long)v);\n}\nstatic DEVICE_ATTR_RO(bitstream_id);\n\n \nstatic ssize_t bitstream_metadata_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_BITSTREAM_MD);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\", (unsigned long long)v);\n}\nstatic DEVICE_ATTR_RO(bitstream_metadata);\n\nstatic ssize_t cache_size_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_CAP);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)FIELD_GET(FME_CAP_CACHE_SIZE, v));\n}\nstatic DEVICE_ATTR_RO(cache_size);\n\nstatic ssize_t fabric_version_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_CAP);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)FIELD_GET(FME_CAP_FABRIC_VERID, v));\n}\nstatic DEVICE_ATTR_RO(fabric_version);\n\nstatic ssize_t socket_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_CAP);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)FIELD_GET(FME_CAP_SOCKET_ID, v));\n}\nstatic DEVICE_ATTR_RO(socket_id);\n\nstatic struct attribute *fme_hdr_attrs[] = {\n\t&dev_attr_ports_num.attr,\n\t&dev_attr_bitstream_id.attr,\n\t&dev_attr_bitstream_metadata.attr,\n\t&dev_attr_cache_size.attr,\n\t&dev_attr_fabric_version.attr,\n\t&dev_attr_socket_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group fme_hdr_group = {\n\t.attrs = fme_hdr_attrs,\n};\n\nstatic long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,\n\t\t\t\t       unsigned long arg)\n{\n\tstruct dfl_fpga_cdev *cdev = pdata->dfl_cdev;\n\tint port_id;\n\n\tif (get_user(port_id, (int __user *)arg))\n\t\treturn -EFAULT;\n\n\treturn dfl_fpga_cdev_release_port(cdev, port_id);\n}\n\nstatic long fme_hdr_ioctl_assign_port(struct dfl_feature_platform_data *pdata,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct dfl_fpga_cdev *cdev = pdata->dfl_cdev;\n\tint port_id;\n\n\tif (get_user(port_id, (int __user *)arg))\n\t\treturn -EFAULT;\n\n\treturn dfl_fpga_cdev_assign_port(cdev, port_id);\n}\n\nstatic long fme_hdr_ioctl(struct platform_device *pdev,\n\t\t\t  struct dfl_feature *feature,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tswitch (cmd) {\n\tcase DFL_FPGA_FME_PORT_RELEASE:\n\t\treturn fme_hdr_ioctl_release_port(pdata, arg);\n\tcase DFL_FPGA_FME_PORT_ASSIGN:\n\t\treturn fme_hdr_ioctl_assign_port(pdata, arg);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic const struct dfl_feature_id fme_hdr_id_table[] = {\n\t{.id = FME_FEATURE_ID_HEADER,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops fme_hdr_ops = {\n\t.ioctl = fme_hdr_ioctl,\n};\n\n#define FME_THERM_THRESHOLD\t0x8\n#define TEMP_THRESHOLD1\t\tGENMASK_ULL(6, 0)\n#define TEMP_THRESHOLD1_EN\tBIT_ULL(7)\n#define TEMP_THRESHOLD2\t\tGENMASK_ULL(14, 8)\n#define TEMP_THRESHOLD2_EN\tBIT_ULL(15)\n#define TRIP_THRESHOLD\t\tGENMASK_ULL(30, 24)\n#define TEMP_THRESHOLD1_STATUS\tBIT_ULL(32)\t\t \n#define TEMP_THRESHOLD2_STATUS\tBIT_ULL(33)\t\t \n \n#define TEMP_THRESHOLD1_POLICY\tBIT_ULL(44)\n\n#define FME_THERM_RDSENSOR_FMT1\t0x10\n#define FPGA_TEMPERATURE\tGENMASK_ULL(6, 0)\n\n#define FME_THERM_CAP\t\t0x20\n#define THERM_NO_THROTTLE\tBIT_ULL(0)\n\n#define MD_PRE_DEG\n\nstatic bool fme_thermal_throttle_support(void __iomem *base)\n{\n\tu64 v = readq(base + FME_THERM_CAP);\n\n\treturn FIELD_GET(THERM_NO_THROTTLE, v) ? false : true;\n}\n\nstatic umode_t thermal_hwmon_attrs_visible(const void *drvdata,\n\t\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t\t   u32 attr, int channel)\n{\n\tconst struct dfl_feature *feature = drvdata;\n\n\t \n\tif (attr == hwmon_temp_input)\n\t\treturn 0444;\n\n\treturn fme_thermal_throttle_support(feature->ioaddr) ? 0444 : 0;\n}\n\nstatic int thermal_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long *val)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu64 v;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tv = readq(feature->ioaddr + FME_THERM_RDSENSOR_FMT1);\n\t\t*val = (long)(FIELD_GET(FPGA_TEMPERATURE, v) * MILLI);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\t\t*val = (long)(FIELD_GET(TEMP_THRESHOLD1, v) * MILLI);\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\t\t*val = (long)(FIELD_GET(TEMP_THRESHOLD2, v) * MILLI);\n\t\tbreak;\n\tcase hwmon_temp_emergency:\n\t\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\t\t*val = (long)(FIELD_GET(TRIP_THRESHOLD, v) * MILLI);\n\t\tbreak;\n\tcase hwmon_temp_max_alarm:\n\t\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\t\t*val = (long)FIELD_GET(TEMP_THRESHOLD1_STATUS, v);\n\t\tbreak;\n\tcase hwmon_temp_crit_alarm:\n\t\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\t\t*val = (long)FIELD_GET(TEMP_THRESHOLD2_STATUS, v);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops thermal_hwmon_ops = {\n\t.is_visible = thermal_hwmon_attrs_visible,\n\t.read = thermal_hwmon_read,\n};\n\nstatic const struct hwmon_channel_info * const thermal_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_EMERGENCY |\n\t\t\t\t HWMON_T_MAX   | HWMON_T_MAX_ALARM |\n\t\t\t\t HWMON_T_CRIT  | HWMON_T_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info thermal_hwmon_chip_info = {\n\t.ops = &thermal_hwmon_ops,\n\t.info = thermal_hwmon_info,\n};\n\nstatic ssize_t temp1_max_policy_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu64 v;\n\n\tv = readq(feature->ioaddr + FME_THERM_THRESHOLD);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)FIELD_GET(TEMP_THRESHOLD1_POLICY, v));\n}\n\nstatic DEVICE_ATTR_RO(temp1_max_policy);\n\nstatic struct attribute *thermal_extra_attrs[] = {\n\t&dev_attr_temp1_max_policy.attr,\n\tNULL,\n};\n\nstatic umode_t thermal_extra_attrs_visible(struct kobject *kobj,\n\t\t\t\t\t   struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\n\treturn fme_thermal_throttle_support(feature->ioaddr) ? attr->mode : 0;\n}\n\nstatic const struct attribute_group thermal_extra_group = {\n\t.attrs\t\t= thermal_extra_attrs,\n\t.is_visible\t= thermal_extra_attrs_visible,\n};\n__ATTRIBUTE_GROUPS(thermal_extra);\n\nstatic int fme_thermal_mgmt_init(struct platform_device *pdev,\n\t\t\t\t struct dfl_feature *feature)\n{\n\tstruct device *hwmon;\n\n\t \n\thwmon = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t     \"dfl_fme_thermal\", feature,\n\t\t\t\t\t\t     &thermal_hwmon_chip_info,\n\t\t\t\t\t\t     thermal_extra_groups);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(&pdev->dev, \"Fail to register thermal hwmon\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dfl_feature_id fme_thermal_mgmt_id_table[] = {\n\t{.id = FME_FEATURE_ID_THERMAL_MGMT,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops fme_thermal_mgmt_ops = {\n\t.init = fme_thermal_mgmt_init,\n};\n\n#define FME_PWR_STATUS\t\t0x8\n#define FME_LATENCY_TOLERANCE\tBIT_ULL(18)\n#define PWR_CONSUMED\t\tGENMASK_ULL(17, 0)\n\n#define FME_PWR_THRESHOLD\t0x10\n#define PWR_THRESHOLD1\t\tGENMASK_ULL(6, 0)\t \n#define PWR_THRESHOLD2\t\tGENMASK_ULL(14, 8)\t \n#define PWR_THRESHOLD_MAX\t0x7f\t\t\t \n#define PWR_THRESHOLD1_STATUS\tBIT_ULL(16)\n#define PWR_THRESHOLD2_STATUS\tBIT_ULL(17)\n\n#define FME_PWR_XEON_LIMIT\t0x18\n#define XEON_PWR_LIMIT\t\tGENMASK_ULL(14, 0)\t \n#define XEON_PWR_EN\t\tBIT_ULL(15)\n#define FME_PWR_FPGA_LIMIT\t0x20\n#define FPGA_PWR_LIMIT\t\tGENMASK_ULL(14, 0)\t \n#define FPGA_PWR_EN\t\tBIT_ULL(15)\n\nstatic int power_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t    u32 attr, int channel, long *val)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu64 v;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\tv = readq(feature->ioaddr + FME_PWR_STATUS);\n\t\t*val = (long)(FIELD_GET(PWR_CONSUMED, v) * MICRO);\n\t\tbreak;\n\tcase hwmon_power_max:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\t*val = (long)(FIELD_GET(PWR_THRESHOLD1, v) * MICRO);\n\t\tbreak;\n\tcase hwmon_power_crit:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\t*val = (long)(FIELD_GET(PWR_THRESHOLD2, v) * MICRO);\n\t\tbreak;\n\tcase hwmon_power_max_alarm:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\t*val = (long)FIELD_GET(PWR_THRESHOLD1_STATUS, v);\n\t\tbreak;\n\tcase hwmon_power_crit_alarm:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\t*val = (long)FIELD_GET(PWR_THRESHOLD2_STATUS, v);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int power_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long val)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev->parent);\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tint ret = 0;\n\tu64 v;\n\n\tval = clamp_val(val / MICRO, 0, PWR_THRESHOLD_MAX);\n\n\tmutex_lock(&pdata->lock);\n\n\tswitch (attr) {\n\tcase hwmon_power_max:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\tv &= ~PWR_THRESHOLD1;\n\t\tv |= FIELD_PREP(PWR_THRESHOLD1, val);\n\t\twriteq(v, feature->ioaddr + FME_PWR_THRESHOLD);\n\t\tbreak;\n\tcase hwmon_power_crit:\n\t\tv = readq(feature->ioaddr + FME_PWR_THRESHOLD);\n\t\tv &= ~PWR_THRESHOLD2;\n\t\tv |= FIELD_PREP(PWR_THRESHOLD2, val);\n\t\twriteq(v, feature->ioaddr + FME_PWR_THRESHOLD);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&pdata->lock);\n\n\treturn ret;\n}\n\nstatic umode_t power_hwmon_attrs_visible(const void *drvdata,\n\t\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t\t u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\tcase hwmon_power_max_alarm:\n\tcase hwmon_power_crit_alarm:\n\t\treturn 0444;\n\tcase hwmon_power_max:\n\tcase hwmon_power_crit:\n\t\treturn 0644;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops power_hwmon_ops = {\n\t.is_visible = power_hwmon_attrs_visible,\n\t.read = power_hwmon_read,\n\t.write = power_hwmon_write,\n};\n\nstatic const struct hwmon_channel_info * const power_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(power, HWMON_P_INPUT |\n\t\t\t\t  HWMON_P_MAX   | HWMON_P_MAX_ALARM |\n\t\t\t\t  HWMON_P_CRIT  | HWMON_P_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info power_hwmon_chip_info = {\n\t.ops = &power_hwmon_ops,\n\t.info = power_hwmon_info,\n};\n\nstatic ssize_t power1_xeon_limit_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu16 xeon_limit = 0;\n\tu64 v;\n\n\tv = readq(feature->ioaddr + FME_PWR_XEON_LIMIT);\n\n\tif (FIELD_GET(XEON_PWR_EN, v))\n\t\txeon_limit = FIELD_GET(XEON_PWR_LIMIT, v);\n\n\treturn sprintf(buf, \"%u\\n\", xeon_limit * 100000);\n}\n\nstatic ssize_t power1_fpga_limit_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu16 fpga_limit = 0;\n\tu64 v;\n\n\tv = readq(feature->ioaddr + FME_PWR_FPGA_LIMIT);\n\n\tif (FIELD_GET(FPGA_PWR_EN, v))\n\t\tfpga_limit = FIELD_GET(FPGA_PWR_LIMIT, v);\n\n\treturn sprintf(buf, \"%u\\n\", fpga_limit * 100000);\n}\n\nstatic ssize_t power1_ltr_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature *feature = dev_get_drvdata(dev);\n\tu64 v;\n\n\tv = readq(feature->ioaddr + FME_PWR_STATUS);\n\n\treturn sprintf(buf, \"%u\\n\",\n\t\t       (unsigned int)FIELD_GET(FME_LATENCY_TOLERANCE, v));\n}\n\nstatic DEVICE_ATTR_RO(power1_xeon_limit);\nstatic DEVICE_ATTR_RO(power1_fpga_limit);\nstatic DEVICE_ATTR_RO(power1_ltr);\n\nstatic struct attribute *power_extra_attrs[] = {\n\t&dev_attr_power1_xeon_limit.attr,\n\t&dev_attr_power1_fpga_limit.attr,\n\t&dev_attr_power1_ltr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(power_extra);\n\nstatic int fme_power_mgmt_init(struct platform_device *pdev,\n\t\t\t       struct dfl_feature *feature)\n{\n\tstruct device *hwmon;\n\n\thwmon = devm_hwmon_device_register_with_info(&pdev->dev,\n\t\t\t\t\t\t     \"dfl_fme_power\", feature,\n\t\t\t\t\t\t     &power_hwmon_chip_info,\n\t\t\t\t\t\t     power_extra_groups);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(&pdev->dev, \"Fail to register power hwmon\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dfl_feature_id fme_power_mgmt_id_table[] = {\n\t{.id = FME_FEATURE_ID_POWER_MGMT,},\n\t{0,}\n};\n\nstatic const struct dfl_feature_ops fme_power_mgmt_ops = {\n\t.init = fme_power_mgmt_init,\n};\n\nstatic struct dfl_feature_driver fme_feature_drvs[] = {\n\t{\n\t\t.id_table = fme_hdr_id_table,\n\t\t.ops = &fme_hdr_ops,\n\t},\n\t{\n\t\t.id_table = fme_pr_mgmt_id_table,\n\t\t.ops = &fme_pr_mgmt_ops,\n\t},\n\t{\n\t\t.id_table = fme_global_err_id_table,\n\t\t.ops = &fme_global_err_ops,\n\t},\n\t{\n\t\t.id_table = fme_thermal_mgmt_id_table,\n\t\t.ops = &fme_thermal_mgmt_ops,\n\t},\n\t{\n\t\t.id_table = fme_power_mgmt_id_table,\n\t\t.ops = &fme_power_mgmt_ops,\n\t},\n\t{\n\t\t.id_table = fme_perf_id_table,\n\t\t.ops = &fme_perf_ops,\n\t},\n\t{\n\t\t.ops = NULL,\n\t},\n};\n\nstatic long fme_ioctl_check_extension(struct dfl_feature_platform_data *pdata,\n\t\t\t\t      unsigned long arg)\n{\n\t \n\treturn 0;\n}\n\nstatic int fme_open(struct inode *inode, struct file *filp)\n{\n\tstruct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&fdev->dev);\n\tint ret;\n\n\tif (WARN_ON(!pdata))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&pdata->lock);\n\tret = dfl_feature_dev_use_begin(pdata, filp->f_flags & O_EXCL);\n\tif (!ret) {\n\t\tdev_dbg(&fdev->dev, \"Device File Opened %d Times\\n\",\n\t\t\tdfl_feature_dev_use_count(pdata));\n\t\tfilp->private_data = pdata;\n\t}\n\tmutex_unlock(&pdata->lock);\n\n\treturn ret;\n}\n\nstatic int fme_release(struct inode *inode, struct file *filp)\n{\n\tstruct dfl_feature_platform_data *pdata = filp->private_data;\n\tstruct platform_device *pdev = pdata->dev;\n\tstruct dfl_feature *feature;\n\n\tdev_dbg(&pdev->dev, \"Device File Release\\n\");\n\n\tmutex_lock(&pdata->lock);\n\tdfl_feature_dev_use_end(pdata);\n\n\tif (!dfl_feature_dev_use_count(pdata))\n\t\tdfl_fpga_dev_for_each_feature(pdata, feature)\n\t\t\tdfl_fpga_set_irq_triggers(feature, 0,\n\t\t\t\t\t\t  feature->nr_irqs, NULL);\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n}\n\nstatic long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct dfl_feature_platform_data *pdata = filp->private_data;\n\tstruct platform_device *pdev = pdata->dev;\n\tstruct dfl_feature *f;\n\tlong ret;\n\n\tdev_dbg(&pdev->dev, \"%s cmd 0x%x\\n\", __func__, cmd);\n\n\tswitch (cmd) {\n\tcase DFL_FPGA_GET_API_VERSION:\n\t\treturn DFL_FPGA_API_VERSION;\n\tcase DFL_FPGA_CHECK_EXTENSION:\n\t\treturn fme_ioctl_check_extension(pdata, arg);\n\tdefault:\n\t\t \n\t\tdfl_fpga_dev_for_each_feature(pdata, f) {\n\t\t\tif (f->ops && f->ops->ioctl) {\n\t\t\t\tret = f->ops->ioctl(pdev, f, cmd, arg);\n\t\t\t\tif (ret != -ENODEV)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fme_dev_init(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_fme *fme;\n\n\tfme = devm_kzalloc(&pdev->dev, sizeof(*fme), GFP_KERNEL);\n\tif (!fme)\n\t\treturn -ENOMEM;\n\n\tfme->pdata = pdata;\n\n\tmutex_lock(&pdata->lock);\n\tdfl_fpga_pdata_set_private(pdata, fme);\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n}\n\nstatic void fme_dev_destroy(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\tdfl_fpga_pdata_set_private(pdata, NULL);\n\tmutex_unlock(&pdata->lock);\n}\n\nstatic const struct file_operations fme_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fme_open,\n\t.release\t= fme_release,\n\t.unlocked_ioctl = fme_ioctl,\n};\n\nstatic int fme_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = fme_dev_init(pdev);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = dfl_fpga_dev_feature_init(pdev, fme_feature_drvs);\n\tif (ret)\n\t\tgoto dev_destroy;\n\n\tret = dfl_fpga_dev_ops_register(pdev, &fme_fops, THIS_MODULE);\n\tif (ret)\n\t\tgoto feature_uinit;\n\n\treturn 0;\n\nfeature_uinit:\n\tdfl_fpga_dev_feature_uinit(pdev);\ndev_destroy:\n\tfme_dev_destroy(pdev);\nexit:\n\treturn ret;\n}\n\nstatic int fme_remove(struct platform_device *pdev)\n{\n\tdfl_fpga_dev_ops_unregister(pdev);\n\tdfl_fpga_dev_feature_uinit(pdev);\n\tfme_dev_destroy(pdev);\n\n\treturn 0;\n}\n\nstatic const struct attribute_group *fme_dev_groups[] = {\n\t&fme_hdr_group,\n\t&fme_global_err_group,\n\tNULL\n};\n\nstatic struct platform_driver fme_driver = {\n\t.driver\t= {\n\t\t.name       = DFL_FPGA_FEATURE_DEV_FME,\n\t\t.dev_groups = fme_dev_groups,\n\t},\n\t.probe   = fme_probe,\n\t.remove  = fme_remove,\n};\n\nmodule_platform_driver(fme_driver);\n\nMODULE_DESCRIPTION(\"FPGA Management Engine driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dfl-fme\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}