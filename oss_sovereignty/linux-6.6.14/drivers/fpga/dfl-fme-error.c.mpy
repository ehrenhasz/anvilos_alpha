{
  "module_name": "dfl-fme-error.c",
  "hash_id": "dbd72bb29b45aa67beee702c70e1543ed8962eb14389b56b3467f0ad119e9242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-fme-error.c",
  "human_readable_source": "\n \n\n#include <linux/fpga-dfl.h>\n#include <linux/uaccess.h>\n\n#include \"dfl.h\"\n#include \"dfl-fme.h\"\n\n#define FME_ERROR_MASK\t\t0x8\n#define FME_ERROR\t\t0x10\n#define MBP_ERROR\t\tBIT_ULL(6)\n#define PCIE0_ERROR_MASK\t0x18\n#define PCIE0_ERROR\t\t0x20\n#define PCIE1_ERROR_MASK\t0x28\n#define PCIE1_ERROR\t\t0x30\n#define FME_FIRST_ERROR\t\t0x38\n#define FME_NEXT_ERROR\t\t0x40\n#define RAS_NONFAT_ERROR_MASK\t0x48\n#define RAS_NONFAT_ERROR\t0x50\n#define RAS_CATFAT_ERROR_MASK\t0x58\n#define RAS_CATFAT_ERROR\t0x60\n#define RAS_ERROR_INJECT\t0x68\n#define INJECT_ERROR_MASK\tGENMASK_ULL(2, 0)\n\n#define ERROR_MASK\t\tGENMASK_ULL(63, 0)\n\nstatic ssize_t pcie0_errors_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 value;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tvalue = readq(base + PCIE0_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)value);\n}\n\nstatic ssize_t pcie0_errors_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tint ret = 0;\n\tu64 v, val;\n\n\tif (kstrtou64(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(GENMASK_ULL(63, 0), base + PCIE0_ERROR_MASK);\n\n\tv = readq(base + PCIE0_ERROR);\n\tif (val == v)\n\t\twriteq(v, base + PCIE0_ERROR);\n\telse\n\t\tret = -EINVAL;\n\n\twriteq(0ULL, base + PCIE0_ERROR_MASK);\n\tmutex_unlock(&pdata->lock);\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(pcie0_errors);\n\nstatic ssize_t pcie1_errors_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 value;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tvalue = readq(base + PCIE1_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)value);\n}\n\nstatic ssize_t pcie1_errors_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tint ret = 0;\n\tu64 v, val;\n\n\tif (kstrtou64(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(GENMASK_ULL(63, 0), base + PCIE1_ERROR_MASK);\n\n\tv = readq(base + PCIE1_ERROR);\n\tif (val == v)\n\t\twriteq(v, base + PCIE1_ERROR);\n\telse\n\t\tret = -EINVAL;\n\n\twriteq(0ULL, base + PCIE1_ERROR_MASK);\n\tmutex_unlock(&pdata->lock);\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(pcie1_errors);\n\nstatic ssize_t nonfatal_errors_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\treturn sprintf(buf, \"0x%llx\\n\",\n\t\t       (unsigned long long)readq(base + RAS_NONFAT_ERROR));\n}\nstatic DEVICE_ATTR_RO(nonfatal_errors);\n\nstatic ssize_t catfatal_errors_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\treturn sprintf(buf, \"0x%llx\\n\",\n\t\t       (unsigned long long)readq(base + RAS_CATFAT_ERROR));\n}\nstatic DEVICE_ATTR_RO(catfatal_errors);\n\nstatic ssize_t inject_errors_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + RAS_ERROR_INJECT);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\",\n\t\t       (unsigned long long)FIELD_GET(INJECT_ERROR_MASK, v));\n}\n\nstatic ssize_t inject_errors_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu8 inject_error;\n\tu64 v;\n\n\tif (kstrtou8(buf, 0, &inject_error))\n\t\treturn -EINVAL;\n\n\tif (inject_error & ~INJECT_ERROR_MASK)\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tv = readq(base + RAS_ERROR_INJECT);\n\tv &= ~INJECT_ERROR_MASK;\n\tv |= FIELD_PREP(INJECT_ERROR_MASK, inject_error);\n\twriteq(v, base + RAS_ERROR_INJECT);\n\tmutex_unlock(&pdata->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(inject_errors);\n\nstatic ssize_t fme_errors_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 value;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tvalue = readq(base + FME_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)value);\n}\n\nstatic ssize_t fme_errors_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 v, val;\n\tint ret = 0;\n\n\tif (kstrtou64(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\twriteq(GENMASK_ULL(63, 0), base + FME_ERROR_MASK);\n\n\tv = readq(base + FME_ERROR);\n\tif (val == v)\n\t\twriteq(v, base + FME_ERROR);\n\telse\n\t\tret = -EINVAL;\n\n\t \n\twriteq(dfl_feature_revision(base) ? 0ULL : MBP_ERROR,\n\t       base + FME_ERROR_MASK);\n\tmutex_unlock(&pdata->lock);\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(fme_errors);\n\nstatic ssize_t first_error_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 value;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tvalue = readq(base + FME_FIRST_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)value);\n}\nstatic DEVICE_ATTR_RO(first_error);\n\nstatic ssize_t next_error_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\tu64 value;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\tvalue = readq(base + FME_NEXT_ERROR);\n\tmutex_unlock(&pdata->lock);\n\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)value);\n}\nstatic DEVICE_ATTR_RO(next_error);\n\nstatic struct attribute *fme_global_err_attrs[] = {\n\t&dev_attr_pcie0_errors.attr,\n\t&dev_attr_pcie1_errors.attr,\n\t&dev_attr_nonfatal_errors.attr,\n\t&dev_attr_catfatal_errors.attr,\n\t&dev_attr_inject_errors.attr,\n\t&dev_attr_fme_errors.attr,\n\t&dev_attr_first_error.attr,\n\t&dev_attr_next_error.attr,\n\tNULL,\n};\n\nstatic umode_t fme_global_err_attrs_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\t \n\tif (!dfl_get_feature_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nconst struct attribute_group fme_global_err_group = {\n\t.name       = \"errors\",\n\t.attrs      = fme_global_err_attrs,\n\t.is_visible = fme_global_err_attrs_visible,\n};\n\nstatic void fme_err_mask(struct device *dev, bool mask)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tvoid __iomem *base;\n\n\tbase = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);\n\n\tmutex_lock(&pdata->lock);\n\n\t \n\tif (dfl_feature_revision(base))\n\t\twriteq(mask ? ERROR_MASK : 0, base + FME_ERROR_MASK);\n\telse\n\t\twriteq(mask ? ERROR_MASK : MBP_ERROR, base + FME_ERROR_MASK);\n\n\twriteq(mask ? ERROR_MASK : 0, base + PCIE0_ERROR_MASK);\n\twriteq(mask ? ERROR_MASK : 0, base + PCIE1_ERROR_MASK);\n\twriteq(mask ? ERROR_MASK : 0, base + RAS_NONFAT_ERROR_MASK);\n\twriteq(mask ? ERROR_MASK : 0, base + RAS_CATFAT_ERROR_MASK);\n\n\tmutex_unlock(&pdata->lock);\n}\n\nstatic int fme_global_err_init(struct platform_device *pdev,\n\t\t\t       struct dfl_feature *feature)\n{\n\tfme_err_mask(&pdev->dev, false);\n\n\treturn 0;\n}\n\nstatic void fme_global_err_uinit(struct platform_device *pdev,\n\t\t\t\t struct dfl_feature *feature)\n{\n\tfme_err_mask(&pdev->dev, true);\n}\n\nstatic long\nfme_global_error_ioctl(struct platform_device *pdev,\n\t\t       struct dfl_feature *feature,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase DFL_FPGA_FME_ERR_GET_IRQ_NUM:\n\t\treturn dfl_feature_ioctl_get_num_irqs(pdev, feature, arg);\n\tcase DFL_FPGA_FME_ERR_SET_IRQ:\n\t\treturn dfl_feature_ioctl_set_irq(pdev, feature, arg);\n\tdefault:\n\t\tdev_dbg(&pdev->dev, \"%x cmd not handled\", cmd);\n\t\treturn -ENODEV;\n\t}\n}\n\nconst struct dfl_feature_id fme_global_err_id_table[] = {\n\t{.id = FME_FEATURE_ID_GLOBAL_ERR,},\n\t{0,}\n};\n\nconst struct dfl_feature_ops fme_global_err_ops = {\n\t.init = fme_global_err_init,\n\t.uinit = fme_global_err_uinit,\n\t.ioctl = fme_global_error_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}