{
  "module_name": "dfl-fme-mgr.c",
  "hash_id": "2cc1ec6d7064556a00cf40c434c3b39f973ad102c2f2070045f0bab6da6001f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-fme-mgr.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/fpga/fpga-mgr.h>\n\n#include \"dfl-fme-pr.h\"\n\n \n#define FME_PR_DFH\t\t0x0\n#define FME_PR_CTRL\t\t0x8\n#define FME_PR_STS\t\t0x10\n#define FME_PR_DATA\t\t0x18\n#define FME_PR_ERR\t\t0x20\n#define FME_PR_INTFC_ID_L\t0xA8\n#define FME_PR_INTFC_ID_H\t0xB0\n\n \n#define FME_PR_CTRL_PR_RST\tBIT_ULL(0)   \n#define FME_PR_CTRL_PR_RSTACK\tBIT_ULL(4)   \n#define FME_PR_CTRL_PR_RGN_ID\tGENMASK_ULL(9, 7)        \n#define FME_PR_CTRL_PR_START\tBIT_ULL(12)  \n#define FME_PR_CTRL_PR_COMPLETE\tBIT_ULL(13)  \n\n \n \n#define FME_PR_STS_PR_CREDIT\tGENMASK_ULL(8, 0)\n#define FME_PR_STS_PR_STS\tBIT_ULL(16)  \n#define FME_PR_STS_PR_STS_IDLE\t0\n#define FME_PR_STS_PR_CTRLR_STS\tGENMASK_ULL(22, 20)      \n#define FME_PR_STS_PR_HOST_STS\tGENMASK_ULL(27, 24)      \n\n \n \n#define FME_PR_DATA_PR_DATA_RAW\tGENMASK_ULL(32, 0)\n\n \n \n#define FME_PR_ERR_OPERATION_ERR\tBIT_ULL(0)\n \n#define FME_PR_ERR_CRC_ERR\t\tBIT_ULL(1)\n \n#define FME_PR_ERR_INCOMPATIBLE_BS\tBIT_ULL(2)\n \n#define FME_PR_ERR_PROTOCOL_ERR\t\tBIT_ULL(3)\n \n#define FME_PR_ERR_FIFO_OVERFLOW\tBIT_ULL(4)\n\n#define PR_WAIT_TIMEOUT   8000000\n#define PR_HOST_STATUS_IDLE\t0\n\nstruct fme_mgr_priv {\n\tvoid __iomem *ioaddr;\n\tu64 pr_error;\n};\n\nstatic u64 pr_error_to_mgr_status(u64 err)\n{\n\tu64 status = 0;\n\n\tif (err & FME_PR_ERR_OPERATION_ERR)\n\t\tstatus |= FPGA_MGR_STATUS_OPERATION_ERR;\n\tif (err & FME_PR_ERR_CRC_ERR)\n\t\tstatus |= FPGA_MGR_STATUS_CRC_ERR;\n\tif (err & FME_PR_ERR_INCOMPATIBLE_BS)\n\t\tstatus |= FPGA_MGR_STATUS_INCOMPATIBLE_IMAGE_ERR;\n\tif (err & FME_PR_ERR_PROTOCOL_ERR)\n\t\tstatus |= FPGA_MGR_STATUS_IP_PROTOCOL_ERR;\n\tif (err & FME_PR_ERR_FIFO_OVERFLOW)\n\t\tstatus |= FPGA_MGR_STATUS_FIFO_OVERFLOW_ERR;\n\n\treturn status;\n}\n\nstatic u64 fme_mgr_pr_error_handle(void __iomem *fme_pr)\n{\n\tu64 pr_status, pr_error;\n\n\tpr_status = readq(fme_pr + FME_PR_STS);\n\tif (!(pr_status & FME_PR_STS_PR_STS))\n\t\treturn 0;\n\n\tpr_error = readq(fme_pr + FME_PR_ERR);\n\twriteq(pr_error, fme_pr + FME_PR_ERR);\n\n\treturn pr_error;\n}\n\nstatic int fme_mgr_write_init(struct fpga_manager *mgr,\n\t\t\t      struct fpga_image_info *info,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct device *dev = &mgr->dev;\n\tstruct fme_mgr_priv *priv = mgr->priv;\n\tvoid __iomem *fme_pr = priv->ioaddr;\n\tu64 pr_ctrl, pr_status;\n\n\tif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\tdev_err(dev, \"only supports partial reconfiguration.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"resetting PR before initiated PR\\n\");\n\n\tpr_ctrl = readq(fme_pr + FME_PR_CTRL);\n\tpr_ctrl |= FME_PR_CTRL_PR_RST;\n\twriteq(pr_ctrl, fme_pr + FME_PR_CTRL);\n\n\tif (readq_poll_timeout(fme_pr + FME_PR_CTRL, pr_ctrl,\n\t\t\t       pr_ctrl & FME_PR_CTRL_PR_RSTACK, 1,\n\t\t\t       PR_WAIT_TIMEOUT)) {\n\t\tdev_err(dev, \"PR Reset ACK timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tpr_ctrl = readq(fme_pr + FME_PR_CTRL);\n\tpr_ctrl &= ~FME_PR_CTRL_PR_RST;\n\twriteq(pr_ctrl, fme_pr + FME_PR_CTRL);\n\n\tdev_dbg(dev,\n\t\t\"waiting for PR resource in HW to be initialized and ready\\n\");\n\n\tif (readq_poll_timeout(fme_pr + FME_PR_STS, pr_status,\n\t\t\t       (pr_status & FME_PR_STS_PR_STS) ==\n\t\t\t       FME_PR_STS_PR_STS_IDLE, 1, PR_WAIT_TIMEOUT)) {\n\t\tdev_err(dev, \"PR Status timeout\\n\");\n\t\tpriv->pr_error = fme_mgr_pr_error_handle(fme_pr);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"check and clear previous PR error\\n\");\n\tpriv->pr_error = fme_mgr_pr_error_handle(fme_pr);\n\tif (priv->pr_error)\n\t\tdev_dbg(dev, \"previous PR error detected %llx\\n\",\n\t\t\t(unsigned long long)priv->pr_error);\n\n\tdev_dbg(dev, \"set PR port ID\\n\");\n\n\tpr_ctrl = readq(fme_pr + FME_PR_CTRL);\n\tpr_ctrl &= ~FME_PR_CTRL_PR_RGN_ID;\n\tpr_ctrl |= FIELD_PREP(FME_PR_CTRL_PR_RGN_ID, info->region_id);\n\twriteq(pr_ctrl, fme_pr + FME_PR_CTRL);\n\n\treturn 0;\n}\n\nstatic int fme_mgr_write(struct fpga_manager *mgr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct device *dev = &mgr->dev;\n\tstruct fme_mgr_priv *priv = mgr->priv;\n\tvoid __iomem *fme_pr = priv->ioaddr;\n\tu64 pr_ctrl, pr_status, pr_data;\n\tint delay = 0, pr_credit, i = 0;\n\n\tdev_dbg(dev, \"start request\\n\");\n\n\tpr_ctrl = readq(fme_pr + FME_PR_CTRL);\n\tpr_ctrl |= FME_PR_CTRL_PR_START;\n\twriteq(pr_ctrl, fme_pr + FME_PR_CTRL);\n\n\tdev_dbg(dev, \"pushing data from bitstream to HW\\n\");\n\n\t \n\tpr_status = readq(fme_pr + FME_PR_STS);\n\tpr_credit = FIELD_GET(FME_PR_STS_PR_CREDIT, pr_status);\n\n\twhile (count > 0) {\n\t\twhile (pr_credit <= 1) {\n\t\t\tif (delay++ > PR_WAIT_TIMEOUT) {\n\t\t\t\tdev_err(dev, \"PR_CREDIT timeout\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tudelay(1);\n\n\t\t\tpr_status = readq(fme_pr + FME_PR_STS);\n\t\t\tpr_credit = FIELD_GET(FME_PR_STS_PR_CREDIT, pr_status);\n\t\t}\n\n\t\tif (count < 4) {\n\t\t\tdev_err(dev, \"Invalid PR bitstream size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpr_data = 0;\n\t\tpr_data |= FIELD_PREP(FME_PR_DATA_PR_DATA_RAW,\n\t\t\t\t      *(((u32 *)buf) + i));\n\t\twriteq(pr_data, fme_pr + FME_PR_DATA);\n\t\tcount -= 4;\n\t\tpr_credit--;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int fme_mgr_write_complete(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info)\n{\n\tstruct device *dev = &mgr->dev;\n\tstruct fme_mgr_priv *priv = mgr->priv;\n\tvoid __iomem *fme_pr = priv->ioaddr;\n\tu64 pr_ctrl;\n\n\tpr_ctrl = readq(fme_pr + FME_PR_CTRL);\n\tpr_ctrl |= FME_PR_CTRL_PR_COMPLETE;\n\twriteq(pr_ctrl, fme_pr + FME_PR_CTRL);\n\n\tdev_dbg(dev, \"green bitstream push complete\\n\");\n\tdev_dbg(dev, \"waiting for HW to release PR resource\\n\");\n\n\tif (readq_poll_timeout(fme_pr + FME_PR_CTRL, pr_ctrl,\n\t\t\t       !(pr_ctrl & FME_PR_CTRL_PR_START), 1,\n\t\t\t       PR_WAIT_TIMEOUT)) {\n\t\tdev_err(dev, \"PR Completion ACK timeout.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"PR operation complete, checking status\\n\");\n\tpriv->pr_error = fme_mgr_pr_error_handle(fme_pr);\n\tif (priv->pr_error) {\n\t\tdev_dbg(dev, \"PR error detected %llx\\n\",\n\t\t\t(unsigned long long)priv->pr_error);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"PR done successfully\\n\");\n\n\treturn 0;\n}\n\nstatic u64 fme_mgr_status(struct fpga_manager *mgr)\n{\n\tstruct fme_mgr_priv *priv = mgr->priv;\n\n\treturn pr_error_to_mgr_status(priv->pr_error);\n}\n\nstatic const struct fpga_manager_ops fme_mgr_ops = {\n\t.write_init = fme_mgr_write_init,\n\t.write = fme_mgr_write,\n\t.write_complete = fme_mgr_write_complete,\n\t.status = fme_mgr_status,\n};\n\nstatic void fme_mgr_get_compat_id(void __iomem *fme_pr,\n\t\t\t\t  struct fpga_compat_id *id)\n{\n\tid->id_l = readq(fme_pr + FME_PR_INTFC_ID_L);\n\tid->id_h = readq(fme_pr + FME_PR_INTFC_ID_H);\n}\n\nstatic int fme_mgr_probe(struct platform_device *pdev)\n{\n\tstruct dfl_fme_mgr_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct fpga_manager_info info = { 0 };\n\tstruct device *dev = &pdev->dev;\n\tstruct fme_mgr_priv *priv;\n\tstruct fpga_manager *mgr;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (pdata->ioaddr)\n\t\tpriv->ioaddr = pdata->ioaddr;\n\n\tif (!priv->ioaddr) {\n\t\tpriv->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(priv->ioaddr))\n\t\t\treturn PTR_ERR(priv->ioaddr);\n\t}\n\n\tinfo.name = \"DFL FME FPGA Manager\";\n\tinfo.mops = &fme_mgr_ops;\n\tinfo.priv = priv;\n\tinfo.compat_id = devm_kzalloc(dev, sizeof(*info.compat_id), GFP_KERNEL);\n\tif (!info.compat_id)\n\t\treturn -ENOMEM;\n\n\tfme_mgr_get_compat_id(priv->ioaddr, info.compat_id);\n\tmgr = devm_fpga_mgr_register_full(dev, &info);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\nstatic struct platform_driver fme_mgr_driver = {\n\t.driver\t= {\n\t\t.name    = DFL_FPGA_FME_MGR,\n\t},\n\t.probe   = fme_mgr_probe,\n};\n\nmodule_platform_driver(fme_mgr_driver);\n\nMODULE_DESCRIPTION(\"FPGA Manager for DFL FPGA Management Engine\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dfl-fme-mgr\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}