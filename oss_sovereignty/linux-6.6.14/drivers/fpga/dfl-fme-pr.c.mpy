{
  "module_name": "dfl-fme-pr.c",
  "hash_id": "d2fc82e51d25cdf92b22cbc12eaf0ddebb6e6ca4afeb04c6e8ab0f81343b3f3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-fme-pr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/fpga/fpga-bridge.h>\n#include <linux/fpga/fpga-region.h>\n#include <linux/fpga-dfl.h>\n\n#include \"dfl.h\"\n#include \"dfl-fme.h\"\n#include \"dfl-fme-pr.h\"\n\nstatic struct dfl_fme_region *\ndfl_fme_region_find_by_port_id(struct dfl_fme *fme, int port_id)\n{\n\tstruct dfl_fme_region *fme_region;\n\n\tlist_for_each_entry(fme_region, &fme->region_list, node)\n\t\tif (fme_region->port_id == port_id)\n\t\t\treturn fme_region;\n\n\treturn NULL;\n}\n\nstatic int dfl_fme_region_match(struct device *dev, const void *data)\n{\n\treturn dev->parent == data;\n}\n\nstatic struct fpga_region *dfl_fme_region_find(struct dfl_fme *fme, int port_id)\n{\n\tstruct dfl_fme_region *fme_region;\n\tstruct fpga_region *region;\n\n\tfme_region = dfl_fme_region_find_by_port_id(fme, port_id);\n\tif (!fme_region)\n\t\treturn NULL;\n\n\tregion = fpga_region_class_find(NULL, &fme_region->region->dev,\n\t\t\t\t\tdfl_fme_region_match);\n\tif (!region)\n\t\treturn NULL;\n\n\treturn region;\n}\n\nstatic int fme_pr(struct platform_device *pdev, unsigned long arg)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tvoid __user *argp = (void __user *)arg;\n\tstruct dfl_fpga_fme_port_pr port_pr;\n\tstruct fpga_image_info *info;\n\tstruct fpga_region *region;\n\tvoid __iomem *fme_hdr;\n\tstruct dfl_fme *fme;\n\tunsigned long minsz;\n\tvoid *buf = NULL;\n\tsize_t length;\n\tint ret = 0;\n\tu64 v;\n\n\tminsz = offsetofend(struct dfl_fpga_fme_port_pr, buffer_address);\n\n\tif (copy_from_user(&port_pr, argp, minsz))\n\t\treturn -EFAULT;\n\n\tif (port_pr.argsz < minsz || port_pr.flags)\n\t\treturn -EINVAL;\n\n\t \n\tfme_hdr = dfl_get_feature_ioaddr_by_id(&pdev->dev,\n\t\t\t\t\t       FME_FEATURE_ID_HEADER);\n\n\t \n\tv = readq(fme_hdr + FME_HDR_CAP);\n\tif (port_pr.port_id >= FIELD_GET(FME_CAP_NUM_PORTS, v)) {\n\t\tdev_dbg(&pdev->dev, \"port number more than maximum\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlength = ALIGN(port_pr.buffer_size, 4);\n\n\tbuf = vmalloc(length);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf,\n\t\t\t   (void __user *)(unsigned long)port_pr.buffer_address,\n\t\t\t   port_pr.buffer_size)) {\n\t\tret = -EFAULT;\n\t\tgoto free_exit;\n\t}\n\n\t \n\tinfo = fpga_image_info_alloc(&pdev->dev);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto free_exit;\n\t}\n\n\tinfo->flags |= FPGA_MGR_PARTIAL_RECONFIG;\n\n\tmutex_lock(&pdata->lock);\n\tfme = dfl_fpga_pdata_get_private(pdata);\n\t \n\tif (!fme) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_exit;\n\t}\n\n\tregion = dfl_fme_region_find(fme, port_pr.port_id);\n\tif (!region) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_exit;\n\t}\n\n\tfpga_image_info_free(region->info);\n\n\tinfo->buf = buf;\n\tinfo->count = length;\n\tinfo->region_id = port_pr.port_id;\n\tregion->info = info;\n\n\tret = fpga_region_program_fpga(region);\n\n\t \n\tif (region->get_bridges)\n\t\tfpga_bridges_put(&region->bridge_list);\n\n\tput_device(&region->dev);\nunlock_exit:\n\tmutex_unlock(&pdata->lock);\nfree_exit:\n\tvfree(buf);\n\treturn ret;\n}\n\n \nstatic struct platform_device *\ndfl_fme_create_mgr(struct dfl_feature_platform_data *pdata,\n\t\t   struct dfl_feature *feature)\n{\n\tstruct platform_device *mgr, *fme = pdata->dev;\n\tstruct dfl_fme_mgr_pdata mgr_pdata;\n\tint ret = -ENOMEM;\n\n\tif (!feature->ioaddr)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmgr_pdata.ioaddr = feature->ioaddr;\n\n\t \n\tmgr = platform_device_alloc(DFL_FPGA_FME_MGR, fme->id);\n\tif (!mgr)\n\t\treturn ERR_PTR(ret);\n\n\tmgr->dev.parent = &fme->dev;\n\n\tret = platform_device_add_data(mgr, &mgr_pdata, sizeof(mgr_pdata));\n\tif (ret)\n\t\tgoto create_mgr_err;\n\n\tret = platform_device_add(mgr);\n\tif (ret)\n\t\tgoto create_mgr_err;\n\n\treturn mgr;\n\ncreate_mgr_err:\n\tplatform_device_put(mgr);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void dfl_fme_destroy_mgr(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);\n\n\tplatform_device_unregister(priv->mgr);\n}\n\n \nstatic struct dfl_fme_bridge *\ndfl_fme_create_bridge(struct dfl_feature_platform_data *pdata, int port_id)\n{\n\tstruct device *dev = &pdata->dev->dev;\n\tstruct dfl_fme_br_pdata br_pdata;\n\tstruct dfl_fme_bridge *fme_br;\n\tint ret = -ENOMEM;\n\n\tfme_br = devm_kzalloc(dev, sizeof(*fme_br), GFP_KERNEL);\n\tif (!fme_br)\n\t\treturn ERR_PTR(ret);\n\n\tbr_pdata.cdev = pdata->dfl_cdev;\n\tbr_pdata.port_id = port_id;\n\n\tfme_br->br = platform_device_alloc(DFL_FPGA_FME_BRIDGE,\n\t\t\t\t\t   PLATFORM_DEVID_AUTO);\n\tif (!fme_br->br)\n\t\treturn ERR_PTR(ret);\n\n\tfme_br->br->dev.parent = dev;\n\n\tret = platform_device_add_data(fme_br->br, &br_pdata, sizeof(br_pdata));\n\tif (ret)\n\t\tgoto create_br_err;\n\n\tret = platform_device_add(fme_br->br);\n\tif (ret)\n\t\tgoto create_br_err;\n\n\treturn fme_br;\n\ncreate_br_err:\n\tplatform_device_put(fme_br->br);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void dfl_fme_destroy_bridge(struct dfl_fme_bridge *fme_br)\n{\n\tplatform_device_unregister(fme_br->br);\n}\n\n \nstatic void dfl_fme_destroy_bridges(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);\n\tstruct dfl_fme_bridge *fbridge, *tmp;\n\n\tlist_for_each_entry_safe(fbridge, tmp, &priv->bridge_list, node) {\n\t\tlist_del(&fbridge->node);\n\t\tdfl_fme_destroy_bridge(fbridge);\n\t}\n}\n\n \nstatic struct dfl_fme_region *\ndfl_fme_create_region(struct dfl_feature_platform_data *pdata,\n\t\t      struct platform_device *mgr,\n\t\t      struct platform_device *br, int port_id)\n{\n\tstruct dfl_fme_region_pdata region_pdata;\n\tstruct device *dev = &pdata->dev->dev;\n\tstruct dfl_fme_region *fme_region;\n\tint ret = -ENOMEM;\n\n\tfme_region = devm_kzalloc(dev, sizeof(*fme_region), GFP_KERNEL);\n\tif (!fme_region)\n\t\treturn ERR_PTR(ret);\n\n\tregion_pdata.mgr = mgr;\n\tregion_pdata.br = br;\n\n\t \n\tfme_region->region = platform_device_alloc(DFL_FPGA_FME_REGION, br->id);\n\tif (!fme_region->region)\n\t\treturn ERR_PTR(ret);\n\n\tfme_region->region->dev.parent = dev;\n\n\tret = platform_device_add_data(fme_region->region, &region_pdata,\n\t\t\t\t       sizeof(region_pdata));\n\tif (ret)\n\t\tgoto create_region_err;\n\n\tret = platform_device_add(fme_region->region);\n\tif (ret)\n\t\tgoto create_region_err;\n\n\tfme_region->port_id = port_id;\n\n\treturn fme_region;\n\ncreate_region_err:\n\tplatform_device_put(fme_region->region);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void dfl_fme_destroy_region(struct dfl_fme_region *fme_region)\n{\n\tplatform_device_unregister(fme_region->region);\n}\n\n \nstatic void dfl_fme_destroy_regions(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);\n\tstruct dfl_fme_region *fme_region, *tmp;\n\n\tlist_for_each_entry_safe(fme_region, tmp, &priv->region_list, node) {\n\t\tlist_del(&fme_region->node);\n\t\tdfl_fme_destroy_region(fme_region);\n\t}\n}\n\nstatic int pr_mgmt_init(struct platform_device *pdev,\n\t\t\tstruct dfl_feature *feature)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_fme_region *fme_region;\n\tstruct dfl_fme_bridge *fme_br;\n\tstruct platform_device *mgr;\n\tstruct dfl_fme *priv;\n\tvoid __iomem *fme_hdr;\n\tint ret = -ENODEV, i = 0;\n\tu64 fme_cap, port_offset;\n\n\tfme_hdr = dfl_get_feature_ioaddr_by_id(&pdev->dev,\n\t\t\t\t\t       FME_FEATURE_ID_HEADER);\n\n\tmutex_lock(&pdata->lock);\n\tpriv = dfl_fpga_pdata_get_private(pdata);\n\n\t \n\tINIT_LIST_HEAD(&priv->region_list);\n\tINIT_LIST_HEAD(&priv->bridge_list);\n\n\t \n\tmgr = dfl_fme_create_mgr(pdata, feature);\n\tif (IS_ERR(mgr)) {\n\t\tdev_err(&pdev->dev, \"fail to create fpga mgr pdev\\n\");\n\t\tgoto unlock;\n\t}\n\n\tpriv->mgr = mgr;\n\n\t \n\tfme_cap = readq(fme_hdr + FME_HDR_CAP);\n\tfor (; i < FIELD_GET(FME_CAP_NUM_PORTS, fme_cap); i++) {\n\t\tport_offset = readq(fme_hdr + FME_HDR_PORT_OFST(i));\n\t\tif (!(port_offset & FME_PORT_OFST_IMP))\n\t\t\tcontinue;\n\n\t\t \n\t\tfme_br = dfl_fme_create_bridge(pdata, i);\n\t\tif (IS_ERR(fme_br)) {\n\t\t\tret = PTR_ERR(fme_br);\n\t\t\tgoto destroy_region;\n\t\t}\n\n\t\tlist_add(&fme_br->node, &priv->bridge_list);\n\n\t\t \n\t\tfme_region = dfl_fme_create_region(pdata, mgr,\n\t\t\t\t\t\t   fme_br->br, i);\n\t\tif (IS_ERR(fme_region)) {\n\t\t\tret = PTR_ERR(fme_region);\n\t\t\tgoto destroy_region;\n\t\t}\n\n\t\tlist_add(&fme_region->node, &priv->region_list);\n\t}\n\tmutex_unlock(&pdata->lock);\n\n\treturn 0;\n\ndestroy_region:\n\tdfl_fme_destroy_regions(pdata);\n\tdfl_fme_destroy_bridges(pdata);\n\tdfl_fme_destroy_mgr(pdata);\nunlock:\n\tmutex_unlock(&pdata->lock);\n\treturn ret;\n}\n\nstatic void pr_mgmt_uinit(struct platform_device *pdev,\n\t\t\t  struct dfl_feature *feature)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\n\tdfl_fme_destroy_regions(pdata);\n\tdfl_fme_destroy_bridges(pdata);\n\tdfl_fme_destroy_mgr(pdata);\n\tmutex_unlock(&pdata->lock);\n}\n\nstatic long fme_pr_ioctl(struct platform_device *pdev,\n\t\t\t struct dfl_feature *feature,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase DFL_FPGA_FME_PORT_PR:\n\t\tret = fme_pr(pdev, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nconst struct dfl_feature_id fme_pr_mgmt_id_table[] = {\n\t{.id = FME_FEATURE_ID_PR_MGMT,},\n\t{0}\n};\n\nconst struct dfl_feature_ops fme_pr_mgmt_ops = {\n\t.init = pr_mgmt_init,\n\t.uinit = pr_mgmt_uinit,\n\t.ioctl = fme_pr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}