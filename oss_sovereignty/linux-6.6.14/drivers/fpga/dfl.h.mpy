{
  "module_name": "dfl.h",
  "hash_id": "4176fab2b72a0f461d2b1a43b2c2a9691bf6449c487b26661e0eca6089dd232d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl.h",
  "human_readable_source": " \n \n\n#ifndef __FPGA_DFL_H\n#define __FPGA_DFL_H\n\n#include <linux/bitfield.h>\n#include <linux/cdev.h>\n#include <linux/delay.h>\n#include <linux/eventfd.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/fpga/fpga-region.h>\n\n \n#define MAX_DFL_FPGA_PORT_NUM 4\n \n#define MAX_DFL_FEATURE_DEV_NUM    (MAX_DFL_FPGA_PORT_NUM + 1)\n\n \n#define FEATURE_ID_FIU_HEADER\t\t0xfe\n#define FEATURE_ID_AFU\t\t\t0xff\n\n#define FME_FEATURE_ID_HEADER\t\tFEATURE_ID_FIU_HEADER\n#define FME_FEATURE_ID_THERMAL_MGMT\t0x1\n#define FME_FEATURE_ID_POWER_MGMT\t0x2\n#define FME_FEATURE_ID_GLOBAL_IPERF\t0x3\n#define FME_FEATURE_ID_GLOBAL_ERR\t0x4\n#define FME_FEATURE_ID_PR_MGMT\t\t0x5\n#define FME_FEATURE_ID_HSSI\t\t0x6\n#define FME_FEATURE_ID_GLOBAL_DPERF\t0x7\n\n#define PORT_FEATURE_ID_HEADER\t\tFEATURE_ID_FIU_HEADER\n#define PORT_FEATURE_ID_AFU\t\tFEATURE_ID_AFU\n#define PORT_FEATURE_ID_ERROR\t\t0x10\n#define PORT_FEATURE_ID_UMSG\t\t0x11\n#define PORT_FEATURE_ID_UINT\t\t0x12\n#define PORT_FEATURE_ID_STP\t\t0x13\n\n \n#define DFH\t\t\t0x0\n#define GUID_L\t\t\t0x8\n#define GUID_H\t\t\t0x10\n#define NEXT_AFU\t\t0x18\n\n#define DFH_SIZE\t\t0x8\n\n \n#define DFH_ID\t\t\tGENMASK_ULL(11, 0)\t \n#define DFH_ID_FIU_FME\t\t0\n#define DFH_ID_FIU_PORT\t\t1\n#define DFH_REVISION\t\tGENMASK_ULL(15, 12)\t \n#define DFH_NEXT_HDR_OFST\tGENMASK_ULL(39, 16)\t \n#define DFH_EOL\t\t\tBIT_ULL(40)\t\t \n#define DFH_VERSION\t\tGENMASK_ULL(59, 52)\t \n#define DFH_TYPE\t\tGENMASK_ULL(63, 60)\t \n#define DFH_TYPE_AFU\t\t1\n#define DFH_TYPE_PRIVATE\t3\n#define DFH_TYPE_FIU\t\t4\n\n \n#define DFHv1_CSR_ADDR\t\t0x18   \n#define DFHv1_CSR_SIZE_GRP\t0x20   \n#define DFHv1_PARAM_HDR\t\t0x28   \n\n \n#define DFHv1_CSR_ADDR_REL\tBIT_ULL(0)\n\n \n#define DFHv1_CSR_ADDR_MASK       GENMASK_ULL(63, 1)   \n\n \n#define DFHv1_CSR_SIZE_GRP_INSTANCE_ID\tGENMASK_ULL(15, 0)\t \n#define DFHv1_CSR_SIZE_GRP_GROUPING_ID\tGENMASK_ULL(30, 16)\t \n#define DFHv1_CSR_SIZE_GRP_HAS_PARAMS\tBIT_ULL(31)\t\t \n#define DFHv1_CSR_SIZE_GRP_SIZE\t\tGENMASK_ULL(63, 32)\t \n\n \n#define DFHv1_PARAM_HDR_ID\t\tGENMASK_ULL(15, 0)  \n#define DFHv1_PARAM_HDR_VER\t\tGENMASK_ULL(31, 16)  \n#define DFHv1_PARAM_HDR_NEXT_OFFSET\tGENMASK_ULL(63, 35)  \n#define DFHv1_PARAM_HDR_NEXT_EOP\tBIT_ULL(32)\n#define DFHv1_PARAM_DATA\t\t0x08   \n\n#define DFHv1_PARAM_ID_MSI_X\t\t0x1\n#define DFHv1_PARAM_MSI_X_NUMV\t\tGENMASK_ULL(63, 32)\n#define DFHv1_PARAM_MSI_X_STARTV\tGENMASK_ULL(31, 0)\n\n \n#define NEXT_AFU_NEXT_DFH_OFST\tGENMASK_ULL(23, 0)\t \n\n \n#define FME_HDR_DFH\t\tDFH\n#define FME_HDR_GUID_L\t\tGUID_L\n#define FME_HDR_GUID_H\t\tGUID_H\n#define FME_HDR_NEXT_AFU\tNEXT_AFU\n#define FME_HDR_CAP\t\t0x30\n#define FME_HDR_PORT_OFST(n)\t(0x38 + ((n) * 0x8))\n#define FME_PORT_OFST_BAR_SKIP\t7\n#define FME_HDR_BITSTREAM_ID\t0x60\n#define FME_HDR_BITSTREAM_MD\t0x68\n\n \n#define FME_CAP_FABRIC_VERID\tGENMASK_ULL(7, 0)\t \n#define FME_CAP_SOCKET_ID\tBIT_ULL(8)\t\t \n#define FME_CAP_PCIE0_LINK_AVL\tBIT_ULL(12)\t\t \n#define FME_CAP_PCIE1_LINK_AVL\tBIT_ULL(13)\t\t \n#define FME_CAP_COHR_LINK_AVL\tBIT_ULL(14)\t\t \n#define FME_CAP_IOMMU_AVL\tBIT_ULL(16)\t\t \n#define FME_CAP_NUM_PORTS\tGENMASK_ULL(19, 17)\t \n#define FME_CAP_ADDR_WIDTH\tGENMASK_ULL(29, 24)\t \n#define FME_CAP_CACHE_SIZE\tGENMASK_ULL(43, 32)\t \n#define FME_CAP_CACHE_ASSOC\tGENMASK_ULL(47, 44)\t \n\n \n \n#define FME_PORT_OFST_DFH_OFST\tGENMASK_ULL(23, 0)\n \n#define FME_PORT_OFST_BAR_ID\tGENMASK_ULL(34, 32)\n \n#define FME_PORT_OFST_ACC_CTRL\tBIT_ULL(55)\n#define FME_PORT_OFST_ACC_PF\t0\n#define FME_PORT_OFST_ACC_VF\t1\n#define FME_PORT_OFST_IMP\tBIT_ULL(60)\n\n \n#define FME_ERROR_CAP\t\t0x70\n\n \n#define FME_ERROR_CAP_SUPP_INT\tBIT_ULL(0)\t\t \n#define FME_ERROR_CAP_INT_VECT\tGENMASK_ULL(12, 1)\t \n\n \n#define PORT_HDR_DFH\t\tDFH\n#define PORT_HDR_GUID_L\t\tGUID_L\n#define PORT_HDR_GUID_H\t\tGUID_H\n#define PORT_HDR_NEXT_AFU\tNEXT_AFU\n#define PORT_HDR_CAP\t\t0x30\n#define PORT_HDR_CTRL\t\t0x38\n#define PORT_HDR_STS\t\t0x40\n#define PORT_HDR_USRCLK_CMD0\t0x50\n#define PORT_HDR_USRCLK_CMD1\t0x58\n#define PORT_HDR_USRCLK_STS0\t0x60\n#define PORT_HDR_USRCLK_STS1\t0x68\n\n \n#define PORT_CAP_PORT_NUM\tGENMASK_ULL(1, 0)\t \n#define PORT_CAP_MMIO_SIZE\tGENMASK_ULL(23, 8)\t \n#define PORT_CAP_SUPP_INT_NUM\tGENMASK_ULL(35, 32)\t \n\n \n#define PORT_CTRL_SFTRST\tBIT_ULL(0)\t\t \n \n#define PORT_CTRL_LATENCY\tBIT_ULL(2)\n#define PORT_CTRL_SFTRST_ACK\tBIT_ULL(4)\t\t \n\n \n#define PORT_STS_AP2_EVT\tBIT_ULL(13)\t\t \n#define PORT_STS_AP1_EVT\tBIT_ULL(12)\t\t \n#define PORT_STS_PWR_STATE\tGENMASK_ULL(11, 8)\t \n#define PORT_STS_PWR_STATE_NORM 0\n#define PORT_STS_PWR_STATE_AP1\t1\t\t\t \n#define PORT_STS_PWR_STATE_AP2\t2\t\t\t \n#define PORT_STS_PWR_STATE_AP6\t6\t\t\t \n\n \n#define PORT_ERROR_CAP\t\t0x38\n\n \n#define PORT_ERROR_CAP_SUPP_INT\tBIT_ULL(0)\t\t \n#define PORT_ERROR_CAP_INT_VECT\tGENMASK_ULL(12, 1)\t \n\n \n#define PORT_UINT_CAP\t\t0x8\n\n \n#define PORT_UINT_CAP_INT_NUM\tGENMASK_ULL(11, 0)\t \n#define PORT_UINT_CAP_FST_VECT\tGENMASK_ULL(23, 12)\t \n\n \nstruct dfl_fpga_port_ops {\n\tconst char *name;\n\tstruct module *owner;\n\tstruct list_head node;\n\tint (*get_id)(struct platform_device *pdev);\n\tint (*enable_set)(struct platform_device *pdev, bool enable);\n};\n\nvoid dfl_fpga_port_ops_add(struct dfl_fpga_port_ops *ops);\nvoid dfl_fpga_port_ops_del(struct dfl_fpga_port_ops *ops);\nstruct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev);\nvoid dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops);\nint dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id);\n\n \nstruct dfl_feature_id {\n\tu16 id;\n};\n\n \nstruct dfl_feature_driver {\n\tconst struct dfl_feature_id *id_table;\n\tconst struct dfl_feature_ops *ops;\n};\n\n \nstruct dfl_feature_irq_ctx {\n\tint irq;\n\tstruct eventfd_ctx *trigger;\n\tchar *name;\n};\n\n \nstruct dfl_feature {\n\tstruct platform_device *dev;\n\tu16 id;\n\tu8 revision;\n\tint resource_index;\n\tvoid __iomem *ioaddr;\n\tstruct dfl_feature_irq_ctx *irq_ctx;\n\tunsigned int nr_irqs;\n\tconst struct dfl_feature_ops *ops;\n\tstruct dfl_device *ddev;\n\tvoid *priv;\n\tu8 dfh_version;\n\tunsigned int param_size;\n\tvoid *params;\n};\n\n#define FEATURE_DEV_ID_UNUSED\t(-1)\n\n \nstruct dfl_feature_platform_data {\n\tstruct list_head node;\n\tstruct mutex lock;\n\tstruct cdev cdev;\n\tstruct platform_device *dev;\n\tstruct dfl_fpga_cdev *dfl_cdev;\n\tint id;\n\tunsigned int disable_count;\n\tbool excl_open;\n\tint open_count;\n\tvoid *private;\n\tint num;\n\tstruct dfl_feature features[];\n};\n\nstatic inline\nint dfl_feature_dev_use_begin(struct dfl_feature_platform_data *pdata,\n\t\t\t      bool excl)\n{\n\tif (pdata->excl_open)\n\t\treturn -EBUSY;\n\n\tif (excl) {\n\t\tif (pdata->open_count)\n\t\t\treturn -EBUSY;\n\n\t\tpdata->excl_open = true;\n\t}\n\tpdata->open_count++;\n\n\treturn 0;\n}\n\nstatic inline\nvoid dfl_feature_dev_use_end(struct dfl_feature_platform_data *pdata)\n{\n\tpdata->excl_open = false;\n\n\tif (WARN_ON(pdata->open_count <= 0))\n\t\treturn;\n\n\tpdata->open_count--;\n}\n\nstatic inline\nint dfl_feature_dev_use_count(struct dfl_feature_platform_data *pdata)\n{\n\treturn pdata->open_count;\n}\n\nstatic inline\nvoid dfl_fpga_pdata_set_private(struct dfl_feature_platform_data *pdata,\n\t\t\t\tvoid *private)\n{\n\tpdata->private = private;\n}\n\nstatic inline\nvoid *dfl_fpga_pdata_get_private(struct dfl_feature_platform_data *pdata)\n{\n\treturn pdata->private;\n}\n\nstruct dfl_feature_ops {\n\tint (*init)(struct platform_device *pdev, struct dfl_feature *feature);\n\tvoid (*uinit)(struct platform_device *pdev,\n\t\t      struct dfl_feature *feature);\n\tlong (*ioctl)(struct platform_device *pdev, struct dfl_feature *feature,\n\t\t      unsigned int cmd, unsigned long arg);\n};\n\n#define DFL_FPGA_FEATURE_DEV_FME\t\t\"dfl-fme\"\n#define DFL_FPGA_FEATURE_DEV_PORT\t\t\"dfl-port\"\n\nvoid dfl_fpga_dev_feature_uinit(struct platform_device *pdev);\nint dfl_fpga_dev_feature_init(struct platform_device *pdev,\n\t\t\t      struct dfl_feature_driver *feature_drvs);\n\nint dfl_fpga_dev_ops_register(struct platform_device *pdev,\n\t\t\t      const struct file_operations *fops,\n\t\t\t      struct module *owner);\nvoid dfl_fpga_dev_ops_unregister(struct platform_device *pdev);\n\nstatic inline\nstruct platform_device *dfl_fpga_inode_to_feature_dev(struct inode *inode)\n{\n\tstruct dfl_feature_platform_data *pdata;\n\n\tpdata = container_of(inode->i_cdev, struct dfl_feature_platform_data,\n\t\t\t     cdev);\n\treturn pdata->dev;\n}\n\n#define dfl_fpga_dev_for_each_feature(pdata, feature)\t\t\t    \\\n\tfor ((feature) = (pdata)->features;\t\t\t\t    \\\n\t   (feature) < (pdata)->features + (pdata)->num; (feature)++)\n\nstatic inline\nstruct dfl_feature *dfl_get_feature_by_id(struct device *dev, u16 id)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(dev);\n\tstruct dfl_feature *feature;\n\n\tdfl_fpga_dev_for_each_feature(pdata, feature)\n\t\tif (feature->id == id)\n\t\t\treturn feature;\n\n\treturn NULL;\n}\n\nstatic inline\nvoid __iomem *dfl_get_feature_ioaddr_by_id(struct device *dev, u16 id)\n{\n\tstruct dfl_feature *feature = dfl_get_feature_by_id(dev, id);\n\n\tif (feature && feature->ioaddr)\n\t\treturn feature->ioaddr;\n\n\tWARN_ON(1);\n\treturn NULL;\n}\n\nstatic inline bool is_dfl_feature_present(struct device *dev, u16 id)\n{\n\treturn !!dfl_get_feature_ioaddr_by_id(dev, id);\n}\n\nstatic inline\nstruct device *dfl_fpga_pdata_to_parent(struct dfl_feature_platform_data *pdata)\n{\n\treturn pdata->dev->dev.parent->parent;\n}\n\nstatic inline bool dfl_feature_is_fme(void __iomem *base)\n{\n\tu64 v = readq(base + DFH);\n\n\treturn (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&\n\t\t(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_FME);\n}\n\nstatic inline bool dfl_feature_is_port(void __iomem *base)\n{\n\tu64 v = readq(base + DFH);\n\n\treturn (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&\n\t\t(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_PORT);\n}\n\nstatic inline u8 dfl_feature_revision(void __iomem *base)\n{\n\treturn (u8)FIELD_GET(DFH_REVISION, readq(base + DFH));\n}\n\n \nstruct dfl_fpga_enum_info {\n\tstruct device *dev;\n\tstruct list_head dfls;\n\tunsigned int nr_irqs;\n\tint *irq_table;\n};\n\n \nstruct dfl_fpga_enum_dfl {\n\tresource_size_t start;\n\tresource_size_t len;\n\tstruct list_head node;\n};\n\nstruct dfl_fpga_enum_info *dfl_fpga_enum_info_alloc(struct device *dev);\nint dfl_fpga_enum_info_add_dfl(struct dfl_fpga_enum_info *info,\n\t\t\t       resource_size_t start, resource_size_t len);\nint dfl_fpga_enum_info_add_irq(struct dfl_fpga_enum_info *info,\n\t\t\t       unsigned int nr_irqs, int *irq_table);\nvoid dfl_fpga_enum_info_free(struct dfl_fpga_enum_info *info);\n\n \nstruct dfl_fpga_cdev {\n\tstruct device *parent;\n\tstruct fpga_region *region;\n\tstruct device *fme_dev;\n\tstruct mutex lock;\n\tstruct list_head port_dev_list;\n\tint released_port_num;\n};\n\nstruct dfl_fpga_cdev *\ndfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info);\nvoid dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev);\n\n \nstruct platform_device *\n__dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,\n\t\t\t  int (*match)(struct platform_device *, void *));\n\nstatic inline struct platform_device *\ndfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,\n\t\t\tint (*match)(struct platform_device *, void *))\n{\n\tstruct platform_device *pdev;\n\n\tmutex_lock(&cdev->lock);\n\tpdev = __dfl_fpga_cdev_find_port(cdev, data, match);\n\tmutex_unlock(&cdev->lock);\n\n\treturn pdev;\n}\n\nint dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id);\nint dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id);\nvoid dfl_fpga_cdev_config_ports_pf(struct dfl_fpga_cdev *cdev);\nint dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vf);\nint dfl_fpga_set_irq_triggers(struct dfl_feature *feature, unsigned int start,\n\t\t\t      unsigned int count, int32_t *fds);\nlong dfl_feature_ioctl_get_num_irqs(struct platform_device *pdev,\n\t\t\t\t    struct dfl_feature *feature,\n\t\t\t\t    unsigned long arg);\nlong dfl_feature_ioctl_set_irq(struct platform_device *pdev,\n\t\t\t       struct dfl_feature *feature,\n\t\t\t       unsigned long arg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}