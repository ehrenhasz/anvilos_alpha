{
  "module_name": "of-fpga-region.c",
  "hash_id": "feca899306761e4f9d3474cf22cdf6a2e92aa724da1c22f08a08cd24b2b2aeb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/of-fpga-region.c",
  "human_readable_source": "\n \n#include <linux/fpga/fpga-bridge.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/fpga/fpga-region.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstatic const struct of_device_id fpga_region_of_match[] = {\n\t{ .compatible = \"fpga-region\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fpga_region_of_match);\n\n \nstatic struct fpga_region *of_fpga_region_find(struct device_node *np)\n{\n\treturn fpga_region_class_find(NULL, np, device_match_of_node);\n}\n\n \nstatic struct fpga_manager *of_fpga_region_get_mgr(struct device_node *np)\n{\n\tstruct device_node  *mgr_node;\n\tstruct fpga_manager *mgr;\n\n\tof_node_get(np);\n\twhile (np) {\n\t\tif (of_device_is_compatible(np, \"fpga-region\")) {\n\t\t\tmgr_node = of_parse_phandle(np, \"fpga-mgr\", 0);\n\t\t\tif (mgr_node) {\n\t\t\t\tmgr = of_fpga_mgr_get(mgr_node);\n\t\t\t\tof_node_put(mgr_node);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn mgr;\n\t\t\t}\n\t\t}\n\t\tnp = of_get_next_parent(np);\n\t}\n\tof_node_put(np);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic int of_fpga_region_get_bridges(struct fpga_region *region)\n{\n\tstruct device *dev = &region->dev;\n\tstruct device_node *region_np = dev->of_node;\n\tstruct fpga_image_info *info = region->info;\n\tstruct device_node *br, *np, *parent_br = NULL;\n\tint i, ret;\n\n\t \n\tret = of_fpga_bridge_get_to_list(region_np->parent, info,\n\t\t\t\t\t &region->bridge_list);\n\n\t \n\tif (ret == -EBUSY)\n\t\treturn ret;\n\n\t \n\tif (!ret)\n\t\tparent_br = region_np->parent;\n\n\t \n\tbr = of_parse_phandle(info->overlay, \"fpga-bridges\", 0);\n\tif (br) {\n\t\tof_node_put(br);\n\t\tnp = info->overlay;\n\t} else {\n\t\tnp = region_np;\n\t}\n\n\tfor (i = 0; ; i++) {\n\t\tbr = of_parse_phandle(np, \"fpga-bridges\", i);\n\t\tif (!br)\n\t\t\tbreak;\n\n\t\t \n\t\tif (br == parent_br) {\n\t\t\tof_node_put(br);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = of_fpga_bridge_get_to_list(br, info,\n\t\t\t\t\t\t &region->bridge_list);\n\t\tof_node_put(br);\n\n\t\t \n\t\tif (ret == -EBUSY) {\n\t\t\tfpga_bridges_put(&region->bridge_list);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int child_regions_with_firmware(struct device_node *overlay)\n{\n\tstruct device_node *child_region;\n\tconst char *child_firmware_name;\n\tint ret = 0;\n\n\tof_node_get(overlay);\n\n\tchild_region = of_find_matching_node(overlay, fpga_region_of_match);\n\twhile (child_region) {\n\t\tif (!of_property_read_string(child_region, \"firmware-name\",\n\t\t\t\t\t     &child_firmware_name)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tchild_region = of_find_matching_node(child_region,\n\t\t\t\t\t\t     fpga_region_of_match);\n\t}\n\n\tof_node_put(child_region);\n\n\tif (ret)\n\t\tpr_err(\"firmware-name not allowed in child FPGA region: %pOF\",\n\t\t       child_region);\n\n\treturn ret;\n}\n\n \nstatic struct fpga_image_info *\nof_fpga_region_parse_ov(struct fpga_region *region,\n\t\t\tstruct device_node *overlay)\n{\n\tstruct device *dev = &region->dev;\n\tstruct fpga_image_info *info;\n\tconst char *firmware_name;\n\tint ret;\n\n\tif (region->info) {\n\t\tdev_err(dev, \"Region already has overlay applied.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tret = child_regions_with_firmware(overlay);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinfo = fpga_image_info_alloc(dev);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->overlay = overlay;\n\n\t \n\tif (of_property_read_bool(overlay, \"partial-fpga-config\"))\n\t\tinfo->flags |= FPGA_MGR_PARTIAL_RECONFIG;\n\n\tif (of_property_read_bool(overlay, \"external-fpga-config\"))\n\t\tinfo->flags |= FPGA_MGR_EXTERNAL_CONFIG;\n\n\tif (of_property_read_bool(overlay, \"encrypted-fpga-config\"))\n\t\tinfo->flags |= FPGA_MGR_ENCRYPTED_BITSTREAM;\n\n\tif (!of_property_read_string(overlay, \"firmware-name\",\n\t\t\t\t     &firmware_name)) {\n\t\tinfo->firmware_name = devm_kstrdup(dev, firmware_name,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!info->firmware_name)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tof_property_read_u32(overlay, \"region-unfreeze-timeout-us\",\n\t\t\t     &info->enable_timeout_us);\n\n\tof_property_read_u32(overlay, \"region-freeze-timeout-us\",\n\t\t\t     &info->disable_timeout_us);\n\n\tof_property_read_u32(overlay, \"config-complete-timeout-us\",\n\t\t\t     &info->config_complete_timeout_us);\n\n\t \n\tif (!info->firmware_name) {\n\t\tret = 0;\n\t\tgoto ret_no_info;\n\t}\n\n\t \n\tif (info->flags & FPGA_MGR_EXTERNAL_CONFIG) {\n\t\tdev_err(dev, \"error: specified firmware and external-fpga-config\");\n\t\tret = -EINVAL;\n\t\tgoto ret_no_info;\n\t}\n\n\treturn info;\nret_no_info:\n\tfpga_image_info_free(info);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int of_fpga_region_notify_pre_apply(struct fpga_region *region,\n\t\t\t\t\t   struct of_overlay_notify_data *nd)\n{\n\tstruct device *dev = &region->dev;\n\tstruct fpga_image_info *info;\n\tint ret;\n\n\tinfo = of_fpga_region_parse_ov(region, nd->overlay);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\t \n\tif (!info)\n\t\treturn 0;\n\n\tif (region->info) {\n\t\tdev_err(dev, \"Region already has overlay applied.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregion->info = info;\n\tret = fpga_region_program_fpga(region);\n\tif (ret) {\n\t\t \n\t\tfpga_image_info_free(info);\n\t\tregion->info = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void of_fpga_region_notify_post_remove(struct fpga_region *region,\n\t\t\t\t\t      struct of_overlay_notify_data *nd)\n{\n\tfpga_bridges_disable(&region->bridge_list);\n\tfpga_bridges_put(&region->bridge_list);\n\tfpga_image_info_free(region->info);\n\tregion->info = NULL;\n}\n\n \nstatic int of_fpga_region_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *arg)\n{\n\tstruct of_overlay_notify_data *nd = arg;\n\tstruct fpga_region *region;\n\tint ret;\n\n\tswitch (action) {\n\tcase OF_OVERLAY_PRE_APPLY:\n\t\tpr_debug(\"%s OF_OVERLAY_PRE_APPLY\\n\", __func__);\n\t\tbreak;\n\tcase OF_OVERLAY_POST_APPLY:\n\t\tpr_debug(\"%s OF_OVERLAY_POST_APPLY\\n\", __func__);\n\t\treturn NOTIFY_OK;        \n\tcase OF_OVERLAY_PRE_REMOVE:\n\t\tpr_debug(\"%s OF_OVERLAY_PRE_REMOVE\\n\", __func__);\n\t\treturn NOTIFY_OK;        \n\tcase OF_OVERLAY_POST_REMOVE:\n\t\tpr_debug(\"%s OF_OVERLAY_POST_REMOVE\\n\", __func__);\n\t\tbreak;\n\tdefault:\t\t\t \n\t\treturn NOTIFY_OK;\n\t}\n\n\tregion = of_fpga_region_find(nd->target);\n\tif (!region)\n\t\treturn NOTIFY_OK;\n\n\tret = 0;\n\tswitch (action) {\n\tcase OF_OVERLAY_PRE_APPLY:\n\t\tret = of_fpga_region_notify_pre_apply(region, nd);\n\t\tbreak;\n\n\tcase OF_OVERLAY_POST_REMOVE:\n\t\tof_fpga_region_notify_post_remove(region, nd);\n\t\tbreak;\n\t}\n\n\tput_device(&region->dev);\n\n\tif (ret)\n\t\treturn notifier_from_errno(ret);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block fpga_region_of_nb = {\n\t.notifier_call = of_fpga_region_notify,\n};\n\nstatic int of_fpga_region_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct fpga_region *region;\n\tstruct fpga_manager *mgr;\n\tint ret;\n\n\t \n\tmgr = of_fpga_region_get_mgr(np);\n\tif (IS_ERR(mgr))\n\t\treturn -EPROBE_DEFER;\n\n\tregion = fpga_region_register(dev, mgr, of_fpga_region_get_bridges);\n\tif (IS_ERR(region)) {\n\t\tret = PTR_ERR(region);\n\t\tgoto eprobe_mgr_put;\n\t}\n\n\tof_platform_populate(np, fpga_region_of_match, NULL, &region->dev);\n\tplatform_set_drvdata(pdev, region);\n\n\tdev_info(dev, \"FPGA Region probed\\n\");\n\n\treturn 0;\n\neprobe_mgr_put:\n\tfpga_mgr_put(mgr);\n\treturn ret;\n}\n\nstatic int of_fpga_region_remove(struct platform_device *pdev)\n{\n\tstruct fpga_region *region = platform_get_drvdata(pdev);\n\tstruct fpga_manager *mgr = region->mgr;\n\n\tfpga_region_unregister(region);\n\tfpga_mgr_put(mgr);\n\n\treturn 0;\n}\n\nstatic struct platform_driver of_fpga_region_driver = {\n\t.probe = of_fpga_region_probe,\n\t.remove = of_fpga_region_remove,\n\t.driver = {\n\t\t.name\t= \"of-fpga-region\",\n\t\t.of_match_table = of_match_ptr(fpga_region_of_match),\n\t},\n};\n\n \nstatic int __init of_fpga_region_init(void)\n{\n\tint ret;\n\n\tret = of_overlay_notifier_register(&fpga_region_of_nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&of_fpga_region_driver);\n\tif (ret)\n\t\tgoto err_plat;\n\n\treturn 0;\n\nerr_plat:\n\tof_overlay_notifier_unregister(&fpga_region_of_nb);\n\treturn ret;\n}\n\nstatic void __exit of_fpga_region_exit(void)\n{\n\tplatform_driver_unregister(&of_fpga_region_driver);\n\tof_overlay_notifier_unregister(&fpga_region_of_nb);\n}\n\nsubsys_initcall(of_fpga_region_init);\nmodule_exit(of_fpga_region_exit);\n\nMODULE_DESCRIPTION(\"FPGA Region\");\nMODULE_AUTHOR(\"Alan Tull <atull@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}