{
  "module_name": "dfl-n3000-nios.c",
  "hash_id": "fc7f0f4a2045e5f65b3ccb588b1b90e7279ff3ad73392ab07a3d341946d2bf6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-n3000-nios.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/dfl.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/stddef.h>\n#include <linux/spi/altera.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n\n \n#define N3000_NS_PARAM\t\t\t\t0x8\n#define N3000_NS_PARAM_SHIFT_MODE_MSK\t\tBIT_ULL(1)\n#define N3000_NS_PARAM_SHIFT_MODE_MSB\t\t0\n#define N3000_NS_PARAM_SHIFT_MODE_LSB\t\t1\n#define N3000_NS_PARAM_DATA_WIDTH\t\tGENMASK_ULL(7, 2)\n#define N3000_NS_PARAM_NUM_CS\t\t\tGENMASK_ULL(13, 8)\n#define N3000_NS_PARAM_CLK_POL\t\t\tBIT_ULL(14)\n#define N3000_NS_PARAM_CLK_PHASE\t\tBIT_ULL(15)\n#define N3000_NS_PARAM_PERIPHERAL_ID\t\tGENMASK_ULL(47, 32)\n\n#define N3000_NS_CTRL\t\t\t\t0x10\n#define N3000_NS_CTRL_WR_DATA\t\t\tGENMASK_ULL(31, 0)\n#define N3000_NS_CTRL_ADDR\t\t\tGENMASK_ULL(44, 32)\n#define N3000_NS_CTRL_CMD_MSK\t\t\tGENMASK_ULL(63, 62)\n#define N3000_NS_CTRL_CMD_NOP\t\t\t0\n#define N3000_NS_CTRL_CMD_RD\t\t\t1\n#define N3000_NS_CTRL_CMD_WR\t\t\t2\n\n#define N3000_NS_STAT\t\t\t\t0x18\n#define N3000_NS_STAT_RD_DATA\t\t\tGENMASK_ULL(31, 0)\n#define N3000_NS_STAT_RW_VAL\t\t\tBIT_ULL(32)\n\n \n#define N3000_NIOS_INIT\t\t\t\t0x1000\n#define N3000_NIOS_INIT_DONE\t\t\tBIT(0)\n#define N3000_NIOS_INIT_START\t\t\tBIT(1)\n \n#define N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK\tGENMASK(9, 8)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK\tGENMASK(11, 10)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK\tGENMASK(13, 12)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK\tGENMASK(15, 14)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK\tGENMASK(17, 16)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK\tGENMASK(19, 18)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK\tGENMASK(21, 20)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK\tGENMASK(23, 22)\n#define N3000_NIOS_INIT_REQ_FEC_MODE_NO\t\t0x0\n#define N3000_NIOS_INIT_REQ_FEC_MODE_KR\t\t0x1\n#define N3000_NIOS_INIT_REQ_FEC_MODE_RS\t\t0x2\n\n#define N3000_NIOS_FW_VERSION\t\t\t0x1004\n#define N3000_NIOS_FW_VERSION_PATCH\t\tGENMASK(23, 20)\n#define N3000_NIOS_FW_VERSION_MINOR\t\tGENMASK(27, 24)\n#define N3000_NIOS_FW_VERSION_MAJOR\t\tGENMASK(31, 28)\n\n \n#define N3000_NIOS_PKVL_A_MODE_STS\t\t0x1020\n#define N3000_NIOS_PKVL_B_MODE_STS\t\t0x1024\n#define N3000_NIOS_PKVL_MODE_STS_GROUP_MSK\tGENMASK(15, 8)\n#define N3000_NIOS_PKVL_MODE_STS_GROUP_OK\t0x0\n#define N3000_NIOS_PKVL_MODE_STS_ID_MSK\t\tGENMASK(7, 0)\n \n#define N3000_NIOS_PKVL_MODE_ID_RESET\t\t0x0\n#define N3000_NIOS_PKVL_MODE_ID_4X10G\t\t0x1\n#define N3000_NIOS_PKVL_MODE_ID_4X25G\t\t0x2\n#define N3000_NIOS_PKVL_MODE_ID_2X25G\t\t0x3\n#define N3000_NIOS_PKVL_MODE_ID_2X25G_2X10G\t0x4\n#define N3000_NIOS_PKVL_MODE_ID_1X25G\t\t0x5\n\n#define N3000_NIOS_REGBUS_RETRY_COUNT\t\t10000\t \n\n#define N3000_NIOS_INIT_TIMEOUT\t\t\t10000000\t \n#define N3000_NIOS_INIT_TIME_INTV\t\t100000\t\t \n\n#define N3000_NIOS_INIT_REQ_FEC_MODE_MSK_ALL\t\\\n\t(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK |\t\\\n\t N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK)\n\n#define N3000_NIOS_INIT_REQ_FEC_MODE_NO_ALL\t\t\t\\\n\t(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_NO))\n\n#define N3000_NIOS_INIT_REQ_FEC_MODE_KR_ALL\t\t\t\\\n\t(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_KR))\n\n#define N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL\t\t\t\\\n\t(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |\t\t\\\n\t FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,\t\\\n\t\t    N3000_NIOS_INIT_REQ_FEC_MODE_RS))\n\nstruct n3000_nios {\n\tvoid __iomem *base;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct platform_device *altera_spi;\n};\n\nstatic ssize_t nios_fw_version_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct n3000_nios *nn = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%x.%x.%x\\n\",\n\t\t\t  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val),\n\t\t\t  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_MINOR, val),\n\t\t\t  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_PATCH, val));\n}\nstatic DEVICE_ATTR_RO(nios_fw_version);\n\n#define IS_MODE_STATUS_OK(mode_stat)\t\t\t\t\t\\\n\t(FIELD_GET(N3000_NIOS_PKVL_MODE_STS_GROUP_MSK, (mode_stat)) ==\t\\\n\t N3000_NIOS_PKVL_MODE_STS_GROUP_OK)\n\n#define IS_RETIMER_FEC_SUPPORTED(retimer_mode)\t\t\t\\\n\t((retimer_mode) != N3000_NIOS_PKVL_MODE_ID_RESET &&\t\\\n\t (retimer_mode) != N3000_NIOS_PKVL_MODE_ID_4X10G)\n\nstatic int get_retimer_mode(struct n3000_nios *nn, unsigned int mode_stat_reg,\n\t\t\t    unsigned int *retimer_mode)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(nn->regmap, mode_stat_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_MODE_STATUS_OK(val))\n\t\treturn -EFAULT;\n\n\t*retimer_mode = FIELD_GET(N3000_NIOS_PKVL_MODE_STS_ID_MSK, val);\n\n\treturn 0;\n}\n\nstatic ssize_t retimer_A_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct n3000_nios *nn = dev_get_drvdata(dev);\n\tunsigned int mode;\n\tint ret;\n\n\tret = get_retimer_mode(nn, N3000_NIOS_PKVL_A_MODE_STS, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", mode);\n}\nstatic DEVICE_ATTR_RO(retimer_A_mode);\n\nstatic ssize_t retimer_B_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct n3000_nios *nn = dev_get_drvdata(dev);\n\tunsigned int mode;\n\tint ret;\n\n\tret = get_retimer_mode(nn, N3000_NIOS_PKVL_B_MODE_STS, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", mode);\n}\nstatic DEVICE_ATTR_RO(retimer_B_mode);\n\nstatic ssize_t fec_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tunsigned int val, retimer_a_mode, retimer_b_mode, fec_modes;\n\tstruct n3000_nios *nn = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val) < 3)\n\t\treturn sysfs_emit(buf, \"not supported\\n\");\n\n\t \n\tret = get_retimer_mode(nn, N3000_NIOS_PKVL_A_MODE_STS, &retimer_a_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_retimer_mode(nn, N3000_NIOS_PKVL_B_MODE_STS, &retimer_b_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_RETIMER_FEC_SUPPORTED(retimer_a_mode) &&\n\t    !IS_RETIMER_FEC_SUPPORTED(retimer_b_mode))\n\t\treturn sysfs_emit(buf, \"not supported\\n\");\n\n\t \n\tret = regmap_read(nn->regmap, N3000_NIOS_INIT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfec_modes = (val & N3000_NIOS_INIT_REQ_FEC_MODE_MSK_ALL);\n\tif (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_NO_ALL)\n\t\treturn sysfs_emit(buf, \"no\\n\");\n\telse if (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_KR_ALL)\n\t\treturn sysfs_emit(buf, \"kr\\n\");\n\telse if (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL)\n\t\treturn sysfs_emit(buf, \"rs\\n\");\n\n\treturn -EFAULT;\n}\nstatic DEVICE_ATTR_RO(fec_mode);\n\nstatic struct attribute *n3000_nios_attrs[] = {\n\t&dev_attr_nios_fw_version.attr,\n\t&dev_attr_retimer_A_mode.attr,\n\t&dev_attr_retimer_B_mode.attr,\n\t&dev_attr_fec_mode.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(n3000_nios);\n\nstatic int n3000_nios_init_done_check(struct n3000_nios *nn)\n{\n\tunsigned int val, state_a, state_b;\n\tstruct device *dev = nn->dev;\n\tint ret, ret2;\n\n\t \n\n\tret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val == 0) {\n\t\tdev_err(dev, \"Nios version reg = 0x%x, skip INIT_DONE check, but the retimer may be uninitialized\\n\",\n\t\t\tval);\n\t\treturn 0;\n\t}\n\n\tif (FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val) >= 3) {\n\t\t \n\t\tret = regmap_read(nn->regmap, N3000_NIOS_INIT, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (val & (N3000_NIOS_INIT_DONE | N3000_NIOS_INIT_START))\n\t\t\tgoto nios_init_done;\n\n\t\t \n\t\tval = N3000_NIOS_INIT_START;\n\n\t\t \n\t\tval |= N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL;\n\n\t\tret = regmap_write(nn->regmap, N3000_NIOS_INIT, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\nnios_init_done:\n\t \n\tret = regmap_read_poll_timeout(nn->regmap, N3000_NIOS_INIT, val,\n\t\t\t\t       val & N3000_NIOS_INIT_DONE,\n\t\t\t\t       N3000_NIOS_INIT_TIME_INTV,\n\t\t\t\t       N3000_NIOS_INIT_TIMEOUT);\n\tif (ret)\n\t\tdev_err(dev, \"NIOS_INIT_DONE %s\\n\",\n\t\t\t(ret == -ETIMEDOUT) ? \"timed out\" : \"check error\");\n\n\tret2 = regmap_read(nn->regmap, N3000_NIOS_PKVL_A_MODE_STS, &state_a);\n\tif (ret2)\n\t\treturn ret2;\n\n\tret2 = regmap_read(nn->regmap, N3000_NIOS_PKVL_B_MODE_STS, &state_b);\n\tif (ret2)\n\t\treturn ret2;\n\n\tif (!ret) {\n\t\t \n\t\tif (IS_MODE_STATUS_OK(state_a) && IS_MODE_STATUS_OK(state_b))\n\t\t\treturn 0;\n\n\t\t \n\t\tdev_err(dev, \"NIOS_INIT_DONE OK, but err on retimer init\\n\");\n\t}\n\n\tdev_err(nn->dev, \"PKVL_A_MODE_STS 0x%x\\n\", state_a);\n\tdev_err(nn->dev, \"PKVL_B_MODE_STS 0x%x\\n\", state_b);\n\n\treturn ret;\n}\n\nstatic struct spi_board_info m10_n3000_info = {\n\t.modalias = \"m10-n3000\",\n\t.max_speed_hz = 12500000,\n\t.bus_num = 0,\n\t.chip_select = 0,\n};\n\nstatic int create_altera_spi_controller(struct n3000_nios *nn)\n{\n\tstruct altera_spi_platform_data pdata = { 0 };\n\tstruct platform_device_info pdevinfo = { 0 };\n\tvoid __iomem *base = nn->base;\n\tu64 v;\n\n\tv = readq(base + N3000_NS_PARAM);\n\n\tpdata.mode_bits = SPI_CS_HIGH;\n\tif (FIELD_GET(N3000_NS_PARAM_CLK_POL, v))\n\t\tpdata.mode_bits |= SPI_CPOL;\n\tif (FIELD_GET(N3000_NS_PARAM_CLK_PHASE, v))\n\t\tpdata.mode_bits |= SPI_CPHA;\n\n\tpdata.num_chipselect = FIELD_GET(N3000_NS_PARAM_NUM_CS, v);\n\tpdata.bits_per_word_mask =\n\t\tSPI_BPW_RANGE_MASK(1, FIELD_GET(N3000_NS_PARAM_DATA_WIDTH, v));\n\n\tpdata.num_devices = 1;\n\tpdata.devices = &m10_n3000_info;\n\n\tdev_dbg(nn->dev, \"%s cs %u bpm 0x%x mode 0x%x\\n\", __func__,\n\t\tpdata.num_chipselect, pdata.bits_per_word_mask,\n\t\tpdata.mode_bits);\n\n\tpdevinfo.name = \"subdev_spi_altera\";\n\tpdevinfo.id = PLATFORM_DEVID_AUTO;\n\tpdevinfo.parent = nn->dev;\n\tpdevinfo.data = &pdata;\n\tpdevinfo.size_data = sizeof(pdata);\n\n\tnn->altera_spi = platform_device_register_full(&pdevinfo);\n\treturn PTR_ERR_OR_ZERO(nn->altera_spi);\n}\n\nstatic void destroy_altera_spi_controller(struct n3000_nios *nn)\n{\n\tplatform_device_unregister(nn->altera_spi);\n}\n\nstatic int n3000_nios_poll_stat_timeout(void __iomem *base, u64 *v)\n{\n\tint loops;\n\n\t \n\tfor (loops = N3000_NIOS_REGBUS_RETRY_COUNT; loops > 0 ; loops--) {\n\t\t*v = readq(base + N3000_NS_STAT);\n\t\tif (*v & N3000_NS_STAT_RW_VAL)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\n\treturn (loops > 0) ? 0 : -ETIMEDOUT;\n}\n\nstatic int n3000_nios_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct n3000_nios *nn = context;\n\tu64 v;\n\tint ret;\n\n\tv = FIELD_PREP(N3000_NS_CTRL_CMD_MSK, N3000_NS_CTRL_CMD_WR) |\n\t    FIELD_PREP(N3000_NS_CTRL_ADDR, reg) |\n\t    FIELD_PREP(N3000_NS_CTRL_WR_DATA, val);\n\twriteq(v, nn->base + N3000_NS_CTRL);\n\n\tret = n3000_nios_poll_stat_timeout(nn->base, &v);\n\tif (ret)\n\t\tdev_err(nn->dev, \"fail to write reg 0x%x val 0x%x: %d\\n\",\n\t\t\treg, val, ret);\n\n\treturn ret;\n}\n\nstatic int n3000_nios_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct n3000_nios *nn = context;\n\tu64 v;\n\tint ret;\n\n\tv = FIELD_PREP(N3000_NS_CTRL_CMD_MSK, N3000_NS_CTRL_CMD_RD) |\n\t    FIELD_PREP(N3000_NS_CTRL_ADDR, reg);\n\twriteq(v, nn->base + N3000_NS_CTRL);\n\n\tret = n3000_nios_poll_stat_timeout(nn->base, &v);\n\tif (ret)\n\t\tdev_err(nn->dev, \"fail to read reg 0x%x: %d\\n\", reg, ret);\n\telse\n\t\t*val = FIELD_GET(N3000_NS_STAT_RD_DATA, v);\n\n\treturn ret;\n}\n\nstatic const struct regmap_config n3000_nios_regbus_cfg = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n\n\t.reg_write = n3000_nios_reg_write,\n\t.reg_read = n3000_nios_reg_read,\n};\n\nstatic int n3000_nios_probe(struct dfl_device *ddev)\n{\n\tstruct device *dev = &ddev->dev;\n\tstruct n3000_nios *nn;\n\tint ret;\n\n\tnn = devm_kzalloc(dev, sizeof(*nn), GFP_KERNEL);\n\tif (!nn)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&ddev->dev, nn);\n\n\tnn->dev = dev;\n\n\tnn->base = devm_ioremap_resource(&ddev->dev, &ddev->mmio_res);\n\tif (IS_ERR(nn->base))\n\t\treturn PTR_ERR(nn->base);\n\n\tnn->regmap = devm_regmap_init(dev, NULL, nn, &n3000_nios_regbus_cfg);\n\tif (IS_ERR(nn->regmap))\n\t\treturn PTR_ERR(nn->regmap);\n\n\tret = n3000_nios_init_done_check(nn);\n\tif (ret)\n\t\treturn ret;\n\n\tret = create_altera_spi_controller(nn);\n\tif (ret)\n\t\tdev_err(dev, \"altera spi controller create failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void n3000_nios_remove(struct dfl_device *ddev)\n{\n\tstruct n3000_nios *nn = dev_get_drvdata(&ddev->dev);\n\n\tdestroy_altera_spi_controller(nn);\n}\n\n#define FME_FEATURE_ID_N3000_NIOS\t0xd\n\nstatic const struct dfl_device_id n3000_nios_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_N3000_NIOS },\n\t{ }\n};\nMODULE_DEVICE_TABLE(dfl, n3000_nios_ids);\n\nstatic struct dfl_driver n3000_nios_driver = {\n\t.drv\t= {\n\t\t.name       = \"dfl-n3000-nios\",\n\t\t.dev_groups = n3000_nios_groups,\n\t},\n\t.id_table = n3000_nios_ids,\n\t.probe   = n3000_nios_probe,\n\t.remove  = n3000_nios_remove,\n};\n\nmodule_dfl_driver(n3000_nios_driver);\n\nMODULE_DESCRIPTION(\"Driver for Nios private feature on Intel PAC N3000\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}