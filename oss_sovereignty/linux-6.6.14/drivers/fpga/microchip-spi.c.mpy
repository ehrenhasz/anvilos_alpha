{
  "module_name": "microchip-spi.c",
  "hash_id": "4d8cb186b4c894a2e9af47e7fed1da42fe2482b2032dd4b2bcb5c3bce5245cae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/microchip-spi.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n#define\tMPF_SPI_ISC_ENABLE\t0x0B\n#define\tMPF_SPI_ISC_DISABLE\t0x0C\n#define\tMPF_SPI_READ_STATUS\t0x00\n#define\tMPF_SPI_READ_DATA\t0x01\n#define\tMPF_SPI_FRAME_INIT\t0xAE\n#define\tMPF_SPI_FRAME\t\t0xEE\n#define\tMPF_SPI_PRG_MODE\t0x01\n#define\tMPF_SPI_RELEASE\t\t0x23\n\n#define\tMPF_SPI_FRAME_SIZE\t16\n\n#define\tMPF_HEADER_SIZE_OFFSET\t24\n#define\tMPF_DATA_SIZE_OFFSET\t55\n\n#define\tMPF_LOOKUP_TABLE_RECORD_SIZE\t\t9\n#define\tMPF_LOOKUP_TABLE_BLOCK_ID_OFFSET\t0\n#define\tMPF_LOOKUP_TABLE_BLOCK_START_OFFSET\t1\n\n#define\tMPF_COMPONENTS_SIZE_ID\t5\n#define\tMPF_BITSTREAM_ID\t8\n\n#define\tMPF_BITS_PER_COMPONENT_SIZE\t22\n\n#define\tMPF_STATUS_POLL_TIMEOUT\t\t(2 * USEC_PER_SEC)\n#define\tMPF_STATUS_BUSY\t\t\tBIT(0)\n#define\tMPF_STATUS_READY\t\tBIT(1)\n#define\tMPF_STATUS_SPI_VIOLATION\tBIT(2)\n#define\tMPF_STATUS_SPI_ERROR\t\tBIT(3)\n\nstruct mpf_priv {\n\tstruct spi_device *spi;\n\tbool program_mode;\n\tu8 tx __aligned(ARCH_KMALLOC_MINALIGN);\n\tu8 rx;\n};\n\nstatic int mpf_read_status(struct mpf_priv *priv)\n{\n\t \n\tstruct spi_transfer xfers[2] = {\n\t\t{\n\t\t\t.tx_buf = &priv->tx,\n\t\t\t.rx_buf = &priv->rx,\n\t\t\t.len = 1,\n\t\t\t.cs_change = 1,\n\t\t}, {\n\t\t\t.tx_buf = &priv->tx,\n\t\t\t.rx_buf = &priv->rx,\n\t\t\t.len = 1,\n\t\t},\n\t};\n\tu8 status;\n\tint ret;\n\n\tpriv->tx = MPF_SPI_READ_STATUS;\n\n\tret = spi_sync_transfer(priv->spi, xfers, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = priv->rx;\n\n\tif ((status & MPF_STATUS_SPI_VIOLATION) ||\n\t    (status & MPF_STATUS_SPI_ERROR))\n\t\treturn -EIO;\n\n\treturn status;\n}\n\nstatic enum fpga_mgr_states mpf_ops_state(struct fpga_manager *mgr)\n{\n\tstruct mpf_priv *priv = mgr->priv;\n\tbool program_mode;\n\tint status;\n\n\tprogram_mode = priv->program_mode;\n\tstatus = mpf_read_status(priv);\n\n\tif (!program_mode && !status)\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic int mpf_ops_parse_header(struct fpga_manager *mgr,\n\t\t\t\tstruct fpga_image_info *info,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tsize_t component_size_byte_num, component_size_byte_off,\n\t       components_size_start, bitstream_start,\n\t       block_id_offset, block_start_offset;\n\tu8 header_size, blocks_num, block_id;\n\tu32 block_start, component_size;\n\tu16 components_num, i;\n\n\tif (!buf) {\n\t\tdev_err(&mgr->dev, \"Image buffer is not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\theader_size = *(buf + MPF_HEADER_SIZE_OFFSET);\n\tif (header_size > count) {\n\t\tinfo->header_size = header_size;\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tblocks_num = *(buf + header_size - 1);\n\tblock_id_offset = header_size + MPF_LOOKUP_TABLE_BLOCK_ID_OFFSET;\n\tblock_start_offset = header_size + MPF_LOOKUP_TABLE_BLOCK_START_OFFSET;\n\n\theader_size += blocks_num * MPF_LOOKUP_TABLE_RECORD_SIZE;\n\tif (header_size > count) {\n\t\tinfo->header_size = header_size;\n\t\treturn -EAGAIN;\n\t}\n\n\tcomponents_size_start = 0;\n\tbitstream_start = 0;\n\n\twhile (blocks_num--) {\n\t\tblock_id = *(buf + block_id_offset);\n\t\tblock_start = get_unaligned_le32(buf + block_start_offset);\n\n\t\tswitch (block_id) {\n\t\tcase MPF_BITSTREAM_ID:\n\t\t\tbitstream_start = block_start;\n\t\t\tinfo->header_size = block_start;\n\t\t\tif (block_start > count)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tbreak;\n\t\tcase MPF_COMPONENTS_SIZE_ID:\n\t\t\tcomponents_size_start = block_start;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bitstream_start && components_size_start)\n\t\t\tbreak;\n\n\t\tblock_id_offset += MPF_LOOKUP_TABLE_RECORD_SIZE;\n\t\tblock_start_offset += MPF_LOOKUP_TABLE_RECORD_SIZE;\n\t}\n\n\tif (!bitstream_start || !components_size_start) {\n\t\tdev_err(&mgr->dev, \"Failed to parse header look-up table\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tcomponents_num = get_unaligned_le16(buf + MPF_DATA_SIZE_OFFSET);\n\n\tfor (i = 0; i < components_num; i++) {\n\t\tcomponent_size_byte_num =\n\t\t\t(i * MPF_BITS_PER_COMPONENT_SIZE) / BITS_PER_BYTE;\n\t\tcomponent_size_byte_off =\n\t\t\t(i * MPF_BITS_PER_COMPONENT_SIZE) % BITS_PER_BYTE;\n\n\t\tcomponent_size = get_unaligned_le32(buf +\n\t\t\t\t\t\t    components_size_start +\n\t\t\t\t\t\t    component_size_byte_num);\n\t\tcomponent_size >>= component_size_byte_off;\n\t\tcomponent_size &= GENMASK(MPF_BITS_PER_COMPONENT_SIZE - 1, 0);\n\n\t\tinfo->data_size += component_size * MPF_SPI_FRAME_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int mpf_poll_status(struct mpf_priv *priv, u8 mask)\n{\n\tint ret, status;\n\n\t \n\tret = read_poll_timeout(mpf_read_status, status,\n\t\t\t\t(status < 0) ||\n\t\t\t\t((status & (MPF_STATUS_BUSY | mask)) == mask),\n\t\t\t\t0, MPF_STATUS_POLL_TIMEOUT, false, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn status;\n}\n\nstatic int mpf_spi_write(struct mpf_priv *priv, const void *buf, size_t buf_size)\n{\n\tint status = mpf_poll_status(priv, 0);\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn spi_write_then_read(priv->spi, buf, buf_size, NULL, 0);\n}\n\nstatic int mpf_spi_write_then_read(struct mpf_priv *priv,\n\t\t\t\t   const void *txbuf, size_t txbuf_size,\n\t\t\t\t   void *rxbuf, size_t rxbuf_size)\n{\n\tconst u8 read_command[] = { MPF_SPI_READ_DATA };\n\tint ret;\n\n\tret = mpf_spi_write(priv, txbuf, txbuf_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mpf_poll_status(priv, MPF_STATUS_READY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn spi_write_then_read(priv->spi, read_command, sizeof(read_command),\n\t\t\t\t   rxbuf, rxbuf_size);\n}\n\nstatic int mpf_ops_write_init(struct fpga_manager *mgr,\n\t\t\t      struct fpga_image_info *info, const char *buf,\n\t\t\t      size_t count)\n{\n\tconst u8 program_mode[] = { MPF_SPI_FRAME_INIT, MPF_SPI_PRG_MODE };\n\tconst u8 isc_en_command[] = { MPF_SPI_ISC_ENABLE };\n\tstruct mpf_priv *priv = mgr->priv;\n\tstruct device *dev = &mgr->dev;\n\tu32 isc_ret = 0;\n\tint ret;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(dev, \"Partial reconfiguration is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = mpf_spi_write_then_read(priv, isc_en_command, sizeof(isc_en_command),\n\t\t\t\t      &isc_ret, sizeof(isc_ret));\n\tif (ret || isc_ret) {\n\t\tdev_err(dev, \"Failed to enable ISC: spi_ret %d, isc_ret %u\\n\",\n\t\t\tret, isc_ret);\n\t\treturn -EFAULT;\n\t}\n\n\tret = mpf_spi_write(priv, program_mode, sizeof(program_mode));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enter program mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->program_mode = true;\n\n\treturn 0;\n}\n\nstatic int mpf_spi_frame_write(struct mpf_priv *priv, const char *buf)\n{\n\tstruct spi_transfer xfers[2] = {\n\t\t{\n\t\t\t.tx_buf = &priv->tx,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.tx_buf = buf,\n\t\t\t.len = MPF_SPI_FRAME_SIZE,\n\t\t},\n\t};\n\tint ret;\n\n\tret = mpf_poll_status(priv, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->tx = MPF_SPI_FRAME;\n\n\treturn spi_sync_transfer(priv->spi, xfers, ARRAY_SIZE(xfers));\n}\n\nstatic int mpf_ops_write(struct fpga_manager *mgr, const char *buf, size_t count)\n{\n\tstruct mpf_priv *priv = mgr->priv;\n\tstruct device *dev = &mgr->dev;\n\tint ret, i;\n\n\tif (count % MPF_SPI_FRAME_SIZE) {\n\t\tdev_err(dev, \"Bitstream size is not a multiple of %d\\n\",\n\t\t\tMPF_SPI_FRAME_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < count / MPF_SPI_FRAME_SIZE; i++) {\n\t\tret = mpf_spi_frame_write(priv, buf + i * MPF_SPI_FRAME_SIZE);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to write bitstream frame %d/%zu\\n\",\n\t\t\t\ti, count / MPF_SPI_FRAME_SIZE);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpf_ops_write_complete(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info)\n{\n\tconst u8 isc_dis_command[] = { MPF_SPI_ISC_DISABLE };\n\tconst u8 release_command[] = { MPF_SPI_RELEASE };\n\tstruct mpf_priv *priv = mgr->priv;\n\tstruct device *dev = &mgr->dev;\n\tint ret;\n\n\tret = mpf_spi_write(priv, isc_dis_command, sizeof(isc_dis_command));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to disable ISC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tret = mpf_spi_write(priv, release_command, sizeof(release_command));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to exit program mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->program_mode = false;\n\n\treturn 0;\n}\n\nstatic const struct fpga_manager_ops mpf_ops = {\n\t.state = mpf_ops_state,\n\t.initial_header_size = 71,\n\t.skip_header = true,\n\t.parse_header = mpf_ops_parse_header,\n\t.write_init = mpf_ops_write_init,\n\t.write = mpf_ops_write,\n\t.write_complete = mpf_ops_write_complete,\n};\n\nstatic int mpf_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct fpga_manager *mgr;\n\tstruct mpf_priv *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->spi = spi;\n\n\tmgr = devm_fpga_mgr_register(dev, \"Microchip Polarfire SPI FPGA Manager\",\n\t\t\t\t     &mpf_ops, priv);\n\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\nstatic const struct spi_device_id mpf_spi_ids[] = {\n\t{ .name = \"mpf-spi-fpga-mgr\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, mpf_spi_ids);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id mpf_of_ids[] = {\n\t{ .compatible = \"microchip,mpf-spi-fpga-mgr\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpf_of_ids);\n#endif  \n\nstatic struct spi_driver mpf_driver = {\n\t.probe = mpf_probe,\n\t.id_table = mpf_spi_ids,\n\t.driver = {\n\t\t.name = \"microchip_mpf_spi_fpga_mgr\",\n\t\t.of_match_table = of_match_ptr(mpf_of_ids),\n\t},\n};\n\nmodule_spi_driver(mpf_driver);\n\nMODULE_DESCRIPTION(\"Microchip Polarfire SPI FPGA Manager\");\nMODULE_AUTHOR(\"Ivan Bornyakov <i.bornyakov@metrotek.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}