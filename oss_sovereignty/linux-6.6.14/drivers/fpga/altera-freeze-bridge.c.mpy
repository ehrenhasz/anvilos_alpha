{
  "module_name": "altera-freeze-bridge.c",
  "hash_id": "bbabf687b3035d67d10ea9d974c9a35e91d67b3f92a2bca2eaf393685efe2779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-freeze-bridge.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/fpga/fpga-bridge.h>\n\n#define FREEZE_CSR_STATUS_OFFSET\t\t0\n#define FREEZE_CSR_CTRL_OFFSET\t\t\t4\n#define FREEZE_CSR_ILLEGAL_REQ_OFFSET\t\t8\n#define FREEZE_CSR_REG_VERSION\t\t\t12\n\n#define FREEZE_CSR_SUPPORTED_VERSION\t\t2\n#define FREEZE_CSR_OFFICIAL_VERSION\t\t0xad000003\n\n#define FREEZE_CSR_STATUS_FREEZE_REQ_DONE\tBIT(0)\n#define FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE\tBIT(1)\n\n#define FREEZE_CSR_CTRL_FREEZE_REQ\t\tBIT(0)\n#define FREEZE_CSR_CTRL_RESET_REQ\t\tBIT(1)\n#define FREEZE_CSR_CTRL_UNFREEZE_REQ\t\tBIT(2)\n\n#define FREEZE_BRIDGE_NAME\t\t\t\"freeze\"\n\nstruct altera_freeze_br_data {\n\tstruct device *dev;\n\tvoid __iomem *base_addr;\n\tbool enable;\n};\n\n \nstatic int altera_freeze_br_req_ack(struct altera_freeze_br_data *priv,\n\t\t\t\t    u32 timeout, u32 req_ack)\n{\n\tstruct device *dev = priv->dev;\n\tvoid __iomem *csr_illegal_req_addr = priv->base_addr +\n\t\t\t\t\t     FREEZE_CSR_ILLEGAL_REQ_OFFSET;\n\tu32 status, illegal, ctrl;\n\tint ret = -ETIMEDOUT;\n\n\tdo {\n\t\tillegal = readl(csr_illegal_req_addr);\n\t\tif (illegal) {\n\t\t\tdev_err(dev, \"illegal request detected 0x%x\", illegal);\n\n\t\t\twritel(1, csr_illegal_req_addr);\n\n\t\t\tillegal = readl(csr_illegal_req_addr);\n\t\t\tif (illegal)\n\t\t\t\tdev_err(dev, \"illegal request not cleared 0x%x\",\n\t\t\t\t\tillegal);\n\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\n\t\tdev_dbg(dev, \"%s %x %x\\n\", __func__, status, req_ack);\n\t\tstatus &= req_ack;\n\t\tif (status) {\n\t\t\tctrl = readl(priv->base_addr + FREEZE_CSR_CTRL_OFFSET);\n\t\t\tdev_dbg(dev, \"%s request %x acknowledged %x %x\\n\",\n\t\t\t\t__func__, req_ack, status, ctrl);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(1);\n\t} while (timeout--);\n\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(dev, \"%s timeout waiting for 0x%x\\n\",\n\t\t\t__func__, req_ack);\n\n\treturn ret;\n}\n\nstatic int altera_freeze_br_do_freeze(struct altera_freeze_br_data *priv,\n\t\t\t\t      u32 timeout)\n{\n\tstruct device *dev = priv->dev;\n\tvoid __iomem *csr_ctrl_addr = priv->base_addr +\n\t\t\t\t      FREEZE_CSR_CTRL_OFFSET;\n\tu32 status;\n\tint ret;\n\n\tstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\n\n\tdev_dbg(dev, \"%s %d %d\\n\", __func__, status, readl(csr_ctrl_addr));\n\n\tif (status & FREEZE_CSR_STATUS_FREEZE_REQ_DONE) {\n\t\tdev_dbg(dev, \"%s bridge already disabled %d\\n\",\n\t\t\t__func__, status);\n\t\treturn 0;\n\t} else if (!(status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE)) {\n\t\tdev_err(dev, \"%s bridge not enabled %d\\n\", __func__, status);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(FREEZE_CSR_CTRL_FREEZE_REQ, csr_ctrl_addr);\n\n\tret = altera_freeze_br_req_ack(priv, timeout,\n\t\t\t\t       FREEZE_CSR_STATUS_FREEZE_REQ_DONE);\n\n\tif (ret)\n\t\twritel(0, csr_ctrl_addr);\n\telse\n\t\twritel(FREEZE_CSR_CTRL_RESET_REQ, csr_ctrl_addr);\n\n\treturn ret;\n}\n\nstatic int altera_freeze_br_do_unfreeze(struct altera_freeze_br_data *priv,\n\t\t\t\t\tu32 timeout)\n{\n\tstruct device *dev = priv->dev;\n\tvoid __iomem *csr_ctrl_addr = priv->base_addr +\n\t\t\t\t      FREEZE_CSR_CTRL_OFFSET;\n\tu32 status;\n\tint ret;\n\n\twritel(0, csr_ctrl_addr);\n\n\tstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\n\n\tdev_dbg(dev, \"%s %d %d\\n\", __func__, status, readl(csr_ctrl_addr));\n\n\tif (status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE) {\n\t\tdev_dbg(dev, \"%s bridge already enabled %d\\n\",\n\t\t\t__func__, status);\n\t\treturn 0;\n\t} else if (!(status & FREEZE_CSR_STATUS_FREEZE_REQ_DONE)) {\n\t\tdev_err(dev, \"%s bridge not frozen %d\\n\", __func__, status);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(FREEZE_CSR_CTRL_UNFREEZE_REQ, csr_ctrl_addr);\n\n\tret = altera_freeze_br_req_ack(priv, timeout,\n\t\t\t\t       FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE);\n\n\tstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\n\n\tdev_dbg(dev, \"%s %d %d\\n\", __func__, status, readl(csr_ctrl_addr));\n\n\twritel(0, csr_ctrl_addr);\n\n\treturn ret;\n}\n\n \nstatic int altera_freeze_br_enable_set(struct fpga_bridge *bridge,\n\t\t\t\t       bool enable)\n{\n\tstruct altera_freeze_br_data *priv = bridge->priv;\n\tstruct fpga_image_info *info = bridge->info;\n\tu32 timeout = 0;\n\tint ret;\n\n\tif (enable) {\n\t\tif (info)\n\t\t\ttimeout = info->enable_timeout_us;\n\n\t\tret = altera_freeze_br_do_unfreeze(bridge->priv, timeout);\n\t} else {\n\t\tif (info)\n\t\t\ttimeout = info->disable_timeout_us;\n\n\t\tret = altera_freeze_br_do_freeze(bridge->priv, timeout);\n\t}\n\n\tif (!ret)\n\t\tpriv->enable = enable;\n\n\treturn ret;\n}\n\nstatic int altera_freeze_br_enable_show(struct fpga_bridge *bridge)\n{\n\tstruct altera_freeze_br_data *priv = bridge->priv;\n\n\treturn priv->enable;\n}\n\nstatic const struct fpga_bridge_ops altera_freeze_br_br_ops = {\n\t.enable_set = altera_freeze_br_enable_set,\n\t.enable_show = altera_freeze_br_enable_show,\n};\n\nstatic const struct of_device_id altera_freeze_br_of_match[] = {\n\t{ .compatible = \"altr,freeze-bridge-controller\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_freeze_br_of_match);\n\nstatic int altera_freeze_br_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tvoid __iomem *base_addr;\n\tstruct altera_freeze_br_data *priv;\n\tstruct fpga_bridge *br;\n\tu32 status, revision;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tbase_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base_addr))\n\t\treturn PTR_ERR(base_addr);\n\n\trevision = readl(base_addr + FREEZE_CSR_REG_VERSION);\n\tif ((revision != FREEZE_CSR_SUPPORTED_VERSION) &&\n\t    (revision != FREEZE_CSR_OFFICIAL_VERSION)) {\n\t\tdev_err(dev,\n\t\t\t\"%s unexpected revision 0x%x != 0x%x != 0x%x\\n\",\n\t\t\t__func__, revision, FREEZE_CSR_SUPPORTED_VERSION,\n\t\t\tFREEZE_CSR_OFFICIAL_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tstatus = readl(base_addr + FREEZE_CSR_STATUS_OFFSET);\n\tif (status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE)\n\t\tpriv->enable = 1;\n\n\tpriv->base_addr = base_addr;\n\n\tbr = fpga_bridge_register(dev, FREEZE_BRIDGE_NAME,\n\t\t\t\t  &altera_freeze_br_br_ops, priv);\n\tif (IS_ERR(br))\n\t\treturn PTR_ERR(br);\n\n\tplatform_set_drvdata(pdev, br);\n\n\treturn 0;\n}\n\nstatic int altera_freeze_br_remove(struct platform_device *pdev)\n{\n\tstruct fpga_bridge *br = platform_get_drvdata(pdev);\n\n\tfpga_bridge_unregister(br);\n\n\treturn 0;\n}\n\nstatic struct platform_driver altera_freeze_br_driver = {\n\t.probe = altera_freeze_br_probe,\n\t.remove = altera_freeze_br_remove,\n\t.driver = {\n\t\t.name\t= \"altera_freeze_br\",\n\t\t.of_match_table = altera_freeze_br_of_match,\n\t},\n};\n\nmodule_platform_driver(altera_freeze_br_driver);\n\nMODULE_DESCRIPTION(\"Altera Freeze Bridge\");\nMODULE_AUTHOR(\"Alan Tull <atull@opensource.altera.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}