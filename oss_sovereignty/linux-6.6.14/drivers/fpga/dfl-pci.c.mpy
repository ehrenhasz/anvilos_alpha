{
  "module_name": "dfl-pci.c",
  "hash_id": "93528ebfd2804821710335f2655f760da3b2a25211a008eeadb4724f199ef592",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl-pci.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\n#include \"dfl.h\"\n\n#define DRV_VERSION\t\"0.8\"\n#define DRV_NAME\t\"dfl-pci\"\n\n#define PCI_VSEC_ID_INTEL_DFLS 0x43\n\n#define PCI_VNDR_DFLS_CNT 0x8\n#define PCI_VNDR_DFLS_RES 0xc\n\n#define PCI_VNDR_DFLS_RES_BAR_MASK GENMASK(2, 0)\n#define PCI_VNDR_DFLS_RES_OFF_MASK GENMASK(31, 3)\n\nstruct cci_drvdata {\n\tstruct dfl_fpga_cdev *cdev;\t \n};\n\nstatic void __iomem *cci_pci_ioremap_bar0(struct pci_dev *pcidev)\n{\n\tif (pcim_iomap_regions(pcidev, BIT(0), DRV_NAME))\n\t\treturn NULL;\n\n\treturn pcim_iomap_table(pcidev)[0];\n}\n\nstatic int cci_pci_alloc_irq(struct pci_dev *pcidev)\n{\n\tint ret, nvec = pci_msix_vec_count(pcidev);\n\n\tif (nvec <= 0) {\n\t\tdev_dbg(&pcidev->dev, \"fpga interrupt not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tret = pci_alloc_irq_vectors(pcidev, nvec, nvec, PCI_IRQ_MSIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nvec;\n}\n\nstatic void cci_pci_free_irq(struct pci_dev *pcidev)\n{\n\tpci_free_irq_vectors(pcidev);\n}\n\n \n#define PCIE_DEVICE_ID_PF_INT_5_X\t\t0xBCBD\n#define PCIE_DEVICE_ID_PF_INT_6_X\t\t0xBCC0\n#define PCIE_DEVICE_ID_PF_DSC_1_X\t\t0x09C4\n#define PCIE_DEVICE_ID_INTEL_PAC_N3000\t\t0x0B30\n#define PCIE_DEVICE_ID_INTEL_PAC_D5005\t\t0x0B2B\n#define PCIE_DEVICE_ID_SILICOM_PAC_N5010\t0x1000\n#define PCIE_DEVICE_ID_SILICOM_PAC_N5011\t0x1001\n#define PCIE_DEVICE_ID_INTEL_DFL\t\t0xbcce\n \n#define PCIE_SUBDEVICE_ID_INTEL_N6000\t\t0x1770\n#define PCIE_SUBDEVICE_ID_INTEL_N6001\t\t0x1771\n#define PCIE_SUBDEVICE_ID_INTEL_C6100\t\t0x17d4\n\n \n#define PCIE_DEVICE_ID_VF_INT_5_X\t\t0xBCBF\n#define PCIE_DEVICE_ID_VF_INT_6_X\t\t0xBCC1\n#define PCIE_DEVICE_ID_VF_DSC_1_X\t\t0x09C5\n#define PCIE_DEVICE_ID_INTEL_PAC_D5005_VF\t0x0B2C\n#define PCIE_DEVICE_ID_INTEL_DFL_VF\t\t0xbccf\n\nstatic struct pci_device_id cci_pcie_id_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_PF_INT_5_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_VF_INT_5_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_PF_INT_6_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_VF_INT_6_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_PF_DSC_1_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_VF_DSC_1_X),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_N3000),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005_VF),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5010),},\n\t{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5011),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_N6000),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL_VF,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_N6000),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_N6001),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL_VF,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_N6001),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_C6100),},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_DFL_VF,\n\t\t\tPCI_VENDOR_ID_INTEL, PCIE_SUBDEVICE_ID_INTEL_C6100),},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, cci_pcie_id_tbl);\n\nstatic int cci_init_drvdata(struct pci_dev *pcidev)\n{\n\tstruct cci_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&pcidev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pcidev, drvdata);\n\n\treturn 0;\n}\n\nstatic void cci_remove_feature_devs(struct pci_dev *pcidev)\n{\n\tstruct cci_drvdata *drvdata = pci_get_drvdata(pcidev);\n\n\t \n\tdfl_fpga_feature_devs_remove(drvdata->cdev);\n\tcci_pci_free_irq(pcidev);\n}\n\nstatic int *cci_pci_create_irq_table(struct pci_dev *pcidev, unsigned int nvec)\n{\n\tunsigned int i;\n\tint *table;\n\n\ttable = kcalloc(nvec, sizeof(int), GFP_KERNEL);\n\tif (!table)\n\t\treturn table;\n\n\tfor (i = 0; i < nvec; i++)\n\t\ttable[i] = pci_irq_vector(pcidev, i);\n\n\treturn table;\n}\n\nstatic int find_dfls_by_vsec(struct pci_dev *pcidev, struct dfl_fpga_enum_info *info)\n{\n\tu32 bir, offset, dfl_cnt, dfl_res;\n\tint dfl_res_off, i, bars, voff;\n\tresource_size_t start, len;\n\n\tvoff = pci_find_vsec_capability(pcidev, PCI_VENDOR_ID_INTEL,\n\t\t\t\t\tPCI_VSEC_ID_INTEL_DFLS);\n\tif (!voff) {\n\t\tdev_dbg(&pcidev->dev, \"%s no DFL VSEC found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tdfl_cnt = 0;\n\tpci_read_config_dword(pcidev, voff + PCI_VNDR_DFLS_CNT, &dfl_cnt);\n\tif (dfl_cnt > PCI_STD_NUM_BARS) {\n\t\tdev_err(&pcidev->dev, \"%s too many DFLs %d > %d\\n\",\n\t\t\t__func__, dfl_cnt, PCI_STD_NUM_BARS);\n\t\treturn -EINVAL;\n\t}\n\n\tdfl_res_off = voff + PCI_VNDR_DFLS_RES;\n\tif (dfl_res_off + (dfl_cnt * sizeof(u32)) > PCI_CFG_SPACE_EXP_SIZE) {\n\t\tdev_err(&pcidev->dev, \"%s DFL VSEC too big for PCIe config space\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, bars = 0; i < dfl_cnt; i++, dfl_res_off += sizeof(u32)) {\n\t\tdfl_res = GENMASK(31, 0);\n\t\tpci_read_config_dword(pcidev, dfl_res_off, &dfl_res);\n\n\t\tbir = dfl_res & PCI_VNDR_DFLS_RES_BAR_MASK;\n\t\tif (bir >= PCI_STD_NUM_BARS) {\n\t\t\tdev_err(&pcidev->dev, \"%s bad bir number %d\\n\",\n\t\t\t\t__func__, bir);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bars & BIT(bir)) {\n\t\t\tdev_err(&pcidev->dev, \"%s DFL for BAR %d already specified\\n\",\n\t\t\t\t__func__, bir);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbars |= BIT(bir);\n\n\t\tlen = pci_resource_len(pcidev, bir);\n\t\toffset = dfl_res & PCI_VNDR_DFLS_RES_OFF_MASK;\n\t\tif (offset >= len) {\n\t\t\tdev_err(&pcidev->dev, \"%s bad offset %u >= %pa\\n\",\n\t\t\t\t__func__, offset, &len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(&pcidev->dev, \"%s BAR %d offset 0x%x\\n\", __func__, bir, offset);\n\n\t\tlen -= offset;\n\n\t\tstart = pci_resource_start(pcidev, bir) + offset;\n\n\t\tdfl_fpga_enum_info_add_dfl(info, start, len);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int find_dfls_by_default(struct pci_dev *pcidev,\n\t\t\t\tstruct dfl_fpga_enum_info *info)\n{\n\tint port_num, bar, i, ret = 0;\n\tresource_size_t start, len;\n\tvoid __iomem *base;\n\tu32 offset;\n\tu64 v;\n\n\t \n\tbase = cci_pci_ioremap_bar0(pcidev);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\t \n\tif (dfl_feature_is_fme(base)) {\n\t\tstart = pci_resource_start(pcidev, 0);\n\t\tlen = pci_resource_len(pcidev, 0);\n\n\t\tdfl_fpga_enum_info_add_dfl(info, start, len);\n\n\t\t \n\t\tv = readq(base + FME_HDR_CAP);\n\t\tport_num = FIELD_GET(FME_CAP_NUM_PORTS, v);\n\n\t\tWARN_ON(port_num > MAX_DFL_FPGA_PORT_NUM);\n\n\t\tfor (i = 0; i < port_num; i++) {\n\t\t\tv = readq(base + FME_HDR_PORT_OFST(i));\n\n\t\t\t \n\t\t\tif (!(v & FME_PORT_OFST_IMP))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tbar = FIELD_GET(FME_PORT_OFST_BAR_ID, v);\n\t\t\toffset = FIELD_GET(FME_PORT_OFST_DFH_OFST, v);\n\t\t\tif (bar == FME_PORT_OFST_BAR_SKIP) {\n\t\t\t\tcontinue;\n\t\t\t} else if (bar >= PCI_STD_NUM_BARS) {\n\t\t\t\tdev_err(&pcidev->dev, \"bad BAR %d for port %d\\n\",\n\t\t\t\t\tbar, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstart = pci_resource_start(pcidev, bar) + offset;\n\t\t\tlen = pci_resource_len(pcidev, bar) - offset;\n\n\t\t\tdfl_fpga_enum_info_add_dfl(info, start, len);\n\t\t}\n\t} else if (dfl_feature_is_port(base)) {\n\t\tstart = pci_resource_start(pcidev, 0);\n\t\tlen = pci_resource_len(pcidev, 0);\n\n\t\tdfl_fpga_enum_info_add_dfl(info, start, len);\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\n\t \n\tpcim_iounmap_regions(pcidev, BIT(0));\n\n\treturn ret;\n}\n\n \nstatic int cci_enumerate_feature_devs(struct pci_dev *pcidev)\n{\n\tstruct cci_drvdata *drvdata = pci_get_drvdata(pcidev);\n\tstruct dfl_fpga_enum_info *info;\n\tstruct dfl_fpga_cdev *cdev;\n\tint nvec, ret = 0;\n\tint *irq_table;\n\n\t \n\tinfo = dfl_fpga_enum_info_alloc(&pcidev->dev);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\tnvec = cci_pci_alloc_irq(pcidev);\n\tif (nvec < 0) {\n\t\tdev_err(&pcidev->dev, \"Fail to alloc irq %d.\\n\", nvec);\n\t\tret = nvec;\n\t\tgoto enum_info_free_exit;\n\t} else if (nvec) {\n\t\tirq_table = cci_pci_create_irq_table(pcidev, nvec);\n\t\tif (!irq_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto irq_free_exit;\n\t\t}\n\n\t\tret = dfl_fpga_enum_info_add_irq(info, nvec, irq_table);\n\t\tkfree(irq_table);\n\t\tif (ret)\n\t\t\tgoto irq_free_exit;\n\t}\n\n\tret = find_dfls_by_vsec(pcidev, info);\n\tif (ret == -ENODEV)\n\t\tret = find_dfls_by_default(pcidev, info);\n\n\tif (ret)\n\t\tgoto irq_free_exit;\n\n\t \n\tcdev = dfl_fpga_feature_devs_enumerate(info);\n\tif (IS_ERR(cdev)) {\n\t\tdev_err(&pcidev->dev, \"Enumeration failure\\n\");\n\t\tret = PTR_ERR(cdev);\n\t\tgoto irq_free_exit;\n\t}\n\n\tdrvdata->cdev = cdev;\n\nirq_free_exit:\n\tif (ret)\n\t\tcci_pci_free_irq(pcidev);\nenum_info_free_exit:\n\tdfl_fpga_enum_info_free(info);\n\n\treturn ret;\n}\n\nstatic\nint cci_pci_probe(struct pci_dev *pcidev, const struct pci_device_id *pcidevid)\n{\n\tint ret;\n\n\tret = pcim_enable_device(pcidev);\n\tif (ret < 0) {\n\t\tdev_err(&pcidev->dev, \"Failed to enable device %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pcidev);\n\n\tret = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\tret = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pcidev->dev, \"No suitable DMA support available.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cci_init_drvdata(pcidev);\n\tif (ret) {\n\t\tdev_err(&pcidev->dev, \"Fail to init drvdata %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cci_enumerate_feature_devs(pcidev);\n\tif (ret) {\n\t\tdev_err(&pcidev->dev, \"enumeration failure %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cci_pci_sriov_configure(struct pci_dev *pcidev, int num_vfs)\n{\n\tstruct cci_drvdata *drvdata = pci_get_drvdata(pcidev);\n\tstruct dfl_fpga_cdev *cdev = drvdata->cdev;\n\n\tif (!num_vfs) {\n\t\t \n\t\tpci_disable_sriov(pcidev);\n\n\t\tdfl_fpga_cdev_config_ports_pf(cdev);\n\n\t} else {\n\t\tint ret;\n\n\t\t \n\t\tret = dfl_fpga_cdev_config_ports_vf(cdev, num_vfs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pci_enable_sriov(pcidev, num_vfs);\n\t\tif (ret) {\n\t\t\tdfl_fpga_cdev_config_ports_pf(cdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn num_vfs;\n}\n\nstatic void cci_pci_remove(struct pci_dev *pcidev)\n{\n\tif (dev_is_pf(&pcidev->dev))\n\t\tcci_pci_sriov_configure(pcidev, 0);\n\n\tcci_remove_feature_devs(pcidev);\n}\n\nstatic struct pci_driver cci_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = cci_pcie_id_tbl,\n\t.probe = cci_pci_probe,\n\t.remove = cci_pci_remove,\n\t.sriov_configure = cci_pci_sriov_configure,\n};\n\nmodule_pci_driver(cci_pci_driver);\n\nMODULE_DESCRIPTION(\"FPGA DFL PCIe Device Driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}