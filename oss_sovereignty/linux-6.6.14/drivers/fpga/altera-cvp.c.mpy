{
  "module_name": "altera-cvp.c",
  "hash_id": "6e656d2ea849d032751ccc5227a8b81b1b9607e5d462174112a17958a66f2632",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-cvp.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/sizes.h>\n\n#define CVP_BAR\t\t0\t \n#define CVP_DUMMY_WR\t244\t \n#define TIMEOUT_US\t2000\t \n\n \n#define VSE_PCIE_EXT_CAP_ID\t\t0x0\n#define VSE_PCIE_EXT_CAP_ID_VAL\t\t0x000b\t \n\n#define VSE_CVP_STATUS\t\t\t0x1c\t \n#define VSE_CVP_STATUS_CFG_RDY\t\tBIT(18)\t \n#define VSE_CVP_STATUS_CFG_ERR\t\tBIT(19)\t \n#define VSE_CVP_STATUS_CVP_EN\t\tBIT(20)\t \n#define VSE_CVP_STATUS_USERMODE\t\tBIT(21)\t \n#define VSE_CVP_STATUS_CFG_DONE\t\tBIT(23)\t \n#define VSE_CVP_STATUS_PLD_CLK_IN_USE\tBIT(24)\t \n\n#define VSE_CVP_MODE_CTRL\t\t0x20\t \n#define VSE_CVP_MODE_CTRL_CVP_MODE\tBIT(0)\t \n#define VSE_CVP_MODE_CTRL_HIP_CLK_SEL\tBIT(1)  \n#define VSE_CVP_MODE_CTRL_NUMCLKS_OFF\t8\t \n#define VSE_CVP_MODE_CTRL_NUMCLKS_MASK\tGENMASK(15, 8)\n\n#define VSE_CVP_DATA\t\t\t0x28\t \n#define VSE_CVP_PROG_CTRL\t\t0x2c\t \n#define VSE_CVP_PROG_CTRL_CONFIG\tBIT(0)\n#define VSE_CVP_PROG_CTRL_START_XFER\tBIT(1)\n#define VSE_CVP_PROG_CTRL_MASK\t\tGENMASK(1, 0)\n\n#define VSE_UNCOR_ERR_STATUS\t\t0x34\t \n#define VSE_UNCOR_ERR_CVP_CFG_ERR\tBIT(5)\t \n\n#define V1_VSEC_OFFSET\t\t\t0x200\t \n \n#define VSE_CVP_TX_CREDITS\t\t0x49\t \n\n#define V2_CREDIT_TIMEOUT_US\t\t20000\n#define V2_CHECK_CREDIT_US\t\t10\n#define V2_POLL_TIMEOUT_US\t\t1000000\n#define V2_USER_TIMEOUT_US\t\t500000\n\n#define V1_POLL_TIMEOUT_US\t\t10\n\n#define DRV_NAME\t\t\"altera-cvp\"\n#define ALTERA_CVP_MGR_NAME\t\"Altera CvP FPGA Manager\"\n\n \n#define ALTERA_CVP_V1_SIZE\t4\n#define ALTERA_CVP_V2_SIZE\t4096\n\n \nstatic bool altera_cvp_chkcfg;\n\nstruct cvp_priv;\n\nstruct altera_cvp_conf {\n\tstruct fpga_manager\t*mgr;\n\tstruct pci_dev\t\t*pci_dev;\n\tvoid __iomem\t\t*map;\n\tvoid\t\t\t(*write_data)(struct altera_cvp_conf *conf,\n\t\t\t\t\t      u32 data);\n\tchar\t\t\tmgr_name[64];\n\tu8\t\t\tnumclks;\n\tu32\t\t\tsent_packets;\n\tu32\t\t\tvsec_offset;\n\tconst struct cvp_priv\t*priv;\n};\n\nstruct cvp_priv {\n\tvoid\t(*switch_clk)(struct altera_cvp_conf *conf);\n\tint\t(*clear_state)(struct altera_cvp_conf *conf);\n\tint\t(*wait_credit)(struct fpga_manager *mgr, u32 blocks);\n\tsize_t\tblock_size;\n\tint\tpoll_time_us;\n\tint\tuser_time_us;\n};\n\nstatic int altera_read_config_byte(struct altera_cvp_conf *conf,\n\t\t\t\t   int where, u8 *val)\n{\n\treturn pci_read_config_byte(conf->pci_dev, conf->vsec_offset + where,\n\t\t\t\t    val);\n}\n\nstatic int altera_read_config_dword(struct altera_cvp_conf *conf,\n\t\t\t\t    int where, u32 *val)\n{\n\treturn pci_read_config_dword(conf->pci_dev, conf->vsec_offset + where,\n\t\t\t\t     val);\n}\n\nstatic int altera_write_config_dword(struct altera_cvp_conf *conf,\n\t\t\t\t     int where, u32 val)\n{\n\treturn pci_write_config_dword(conf->pci_dev, conf->vsec_offset + where,\n\t\t\t\t      val);\n}\n\nstatic enum fpga_mgr_states altera_cvp_state(struct fpga_manager *mgr)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tu32 status;\n\n\taltera_read_config_dword(conf, VSE_CVP_STATUS, &status);\n\n\tif (status & VSE_CVP_STATUS_CFG_DONE)\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\tif (status & VSE_CVP_STATUS_CVP_EN)\n\t\treturn FPGA_MGR_STATE_POWER_UP;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic void altera_cvp_write_data_iomem(struct altera_cvp_conf *conf, u32 val)\n{\n\twritel(val, conf->map);\n}\n\nstatic void altera_cvp_write_data_config(struct altera_cvp_conf *conf, u32 val)\n{\n\tpci_write_config_dword(conf->pci_dev, conf->vsec_offset + VSE_CVP_DATA,\n\t\t\t       val);\n}\n\n \nstatic void altera_cvp_dummy_write(struct altera_cvp_conf *conf)\n{\n\tunsigned int i;\n\tu32 val;\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);\n\tval &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;\n\tval |= 1 << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;\n\taltera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);\n\n\tfor (i = 0; i < CVP_DUMMY_WR; i++)\n\t\tconf->write_data(conf, 0);  \n}\n\nstatic int altera_cvp_wait_status(struct altera_cvp_conf *conf, u32 status_mask,\n\t\t\t\t  u32 status_val, int timeout_us)\n{\n\tunsigned int retries;\n\tu32 val;\n\n\tretries = timeout_us / 10;\n\tif (timeout_us % 10)\n\t\tretries++;\n\n\tdo {\n\t\taltera_read_config_dword(conf, VSE_CVP_STATUS, &val);\n\t\tif ((val & status_mask) == status_val)\n\t\t\treturn 0;\n\n\t\t \n\t\tusleep_range(10, 11);\n\t} while (--retries);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int altera_cvp_chk_error(struct fpga_manager *mgr, size_t bytes)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = altera_read_config_dword(conf, VSE_CVP_STATUS, &val);\n\tif (ret || (val & VSE_CVP_STATUS_CFG_ERR)) {\n\t\tdev_err(&mgr->dev, \"CVP_CONFIG_ERROR after %zu bytes!\\n\",\n\t\t\tbytes);\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int altera_cvp_v2_clear_state(struct altera_cvp_conf *conf)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tret = altera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);\n\tif (ret) {\n\t\tdev_err(&conf->pci_dev->dev,\n\t\t\t\"Error reading CVP Program Control Register\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= ~VSE_CVP_PROG_CTRL_MASK;\n\tret = altera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);\n\tif (ret) {\n\t\tdev_err(&conf->pci_dev->dev,\n\t\t\t\"Error writing CVP Program Control Register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0,\n\t\t\t\t      conf->priv->poll_time_us);\n}\n\nstatic int altera_cvp_v2_wait_for_credit(struct fpga_manager *mgr,\n\t\t\t\t\t u32 blocks)\n{\n\tu32 timeout = V2_CREDIT_TIMEOUT_US / V2_CHECK_CREDIT_US;\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tint ret;\n\tu8 val;\n\n\tdo {\n\t\tret = altera_read_config_byte(conf, VSE_CVP_TX_CREDITS, &val);\n\t\tif (ret) {\n\t\t\tdev_err(&conf->pci_dev->dev,\n\t\t\t\t\"Error reading CVP Credit Register\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (val - (u8)conf->sent_packets)\n\t\t\treturn 0;\n\n\t\tret = altera_cvp_chk_error(mgr, blocks * ALTERA_CVP_V2_SIZE);\n\t\tif (ret) {\n\t\t\tdev_err(&conf->pci_dev->dev,\n\t\t\t\t\"CE Bit error credit reg[0x%x]:sent[0x%x]\\n\",\n\t\t\t\tval, conf->sent_packets);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t \n\t\tusleep_range(V2_CHECK_CREDIT_US, V2_CHECK_CREDIT_US + 1);\n\t} while (timeout--);\n\n\tdev_err(&conf->pci_dev->dev, \"Timeout waiting for credit\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int altera_cvp_send_block(struct altera_cvp_conf *conf,\n\t\t\t\t const u32 *data, size_t len)\n{\n\tu32 mask, words = len / sizeof(u32);\n\tint i, remainder;\n\n\tfor (i = 0; i < words; i++)\n\t\tconf->write_data(conf, *data++);\n\n\t \n\tremainder = len % sizeof(u32);\n\tif (remainder) {\n\t\tmask = BIT(remainder * 8) - 1;\n\t\tif (mask)\n\t\t\tconf->write_data(conf, *data & mask);\n\t}\n\n\treturn 0;\n}\n\nstatic int altera_cvp_teardown(struct fpga_manager *mgr,\n\t\t\t       struct fpga_image_info *info)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tint ret;\n\tu32 val;\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);\n\tval &= ~VSE_CVP_PROG_CTRL_START_XFER;\n\taltera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);\n\n\t \n\tval &= ~VSE_CVP_PROG_CTRL_CONFIG;\n\taltera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);\n\n\t \n\tif (conf->priv->switch_clk)\n\t\tconf->priv->switch_clk(conf);\n\n\t \n\tret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY, 0,\n\t\t\t\t     conf->priv->poll_time_us);\n\tif (ret)\n\t\tdev_err(&mgr->dev, \"CFG_RDY == 0 timeout\\n\");\n\n\treturn ret;\n}\n\nstatic int altera_cvp_write_init(struct fpga_manager *mgr,\n\t\t\t\t struct fpga_image_info *info,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tu32 iflags, val;\n\tint ret;\n\n\tiflags = info ? info->flags : 0;\n\n\tif (iflags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(&mgr->dev, \"Partial reconfiguration not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (iflags & FPGA_MGR_COMPRESSED_BITSTREAM)\n\t\tconf->numclks = 8;  \n\telse if (iflags & FPGA_MGR_ENCRYPTED_BITSTREAM)\n\t\tconf->numclks = 4;  \n\telse\n\t\tconf->numclks = 1;  \n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_STATUS, &val);\n\tif (!(val & VSE_CVP_STATUS_CVP_EN)) {\n\t\tdev_err(&mgr->dev, \"CVP mode off: 0x%04x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tif (val & VSE_CVP_STATUS_CFG_RDY) {\n\t\tdev_warn(&mgr->dev, \"CvP already started, tear down first\\n\");\n\t\tret = altera_cvp_teardown(mgr, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\t \n\taltera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);\n\tval |= VSE_CVP_MODE_CTRL_HIP_CLK_SEL;\n\taltera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);\n\tval |= VSE_CVP_MODE_CTRL_CVP_MODE;\n\taltera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);\n\n\t \n\tif (conf->priv->switch_clk)\n\t\tconf->priv->switch_clk(conf);\n\n\tif (conf->priv->clear_state) {\n\t\tret = conf->priv->clear_state(conf);\n\t\tif (ret) {\n\t\t\tdev_err(&mgr->dev, \"Problem clearing out state\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tconf->sent_packets = 0;\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);\n\t \n\tval |= VSE_CVP_PROG_CTRL_CONFIG;\n\taltera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);\n\n\t \n\tret = altera_cvp_wait_status(conf, VSE_CVP_STATUS_CFG_RDY,\n\t\t\t\t     VSE_CVP_STATUS_CFG_RDY,\n\t\t\t\t     conf->priv->poll_time_us);\n\tif (ret) {\n\t\tdev_warn(&mgr->dev, \"CFG_RDY == 1 timeout\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (conf->priv->switch_clk)\n\t\tconf->priv->switch_clk(conf);\n\n\tif (altera_cvp_chkcfg) {\n\t\tret = altera_cvp_chk_error(mgr, 0);\n\t\tif (ret) {\n\t\t\tdev_warn(&mgr->dev, \"CFG_RDY == 1 timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_PROG_CTRL, &val);\n\tval |= VSE_CVP_PROG_CTRL_START_XFER;\n\taltera_write_config_dword(conf, VSE_CVP_PROG_CTRL, val);\n\n\t \n\tif (conf->priv->switch_clk) {\n\t\taltera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);\n\t\tval &= ~VSE_CVP_MODE_CTRL_NUMCLKS_MASK;\n\t\tval |= conf->numclks << VSE_CVP_MODE_CTRL_NUMCLKS_OFF;\n\t\taltera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);\n\t}\n\treturn 0;\n}\n\nstatic int altera_cvp_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tsize_t done, remaining, len;\n\tconst u32 *data;\n\tint status = 0;\n\n\t \n\tdata = (u32 *)buf;\n\tremaining = count;\n\tdone = 0;\n\n\twhile (remaining) {\n\t\t \n\t\tif (conf->priv->wait_credit) {\n\t\t\tstatus = conf->priv->wait_credit(mgr, done);\n\t\t\tif (status) {\n\t\t\t\tdev_err(&conf->pci_dev->dev,\n\t\t\t\t\t\"Wait Credit ERR: 0x%x\\n\", status);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tlen = min(conf->priv->block_size, remaining);\n\t\taltera_cvp_send_block(conf, data, len);\n\t\tdata += len / sizeof(u32);\n\t\tdone += len;\n\t\tremaining -= len;\n\t\tconf->sent_packets++;\n\n\t\t \n\t\tif (altera_cvp_chkcfg && !(done % SZ_4K)) {\n\t\t\tstatus = altera_cvp_chk_error(mgr, done);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (altera_cvp_chkcfg)\n\t\tstatus = altera_cvp_chk_error(mgr, count);\n\n\treturn status;\n}\n\nstatic int altera_cvp_write_complete(struct fpga_manager *mgr,\n\t\t\t\t     struct fpga_image_info *info)\n{\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tu32 mask, val;\n\tint ret;\n\n\tret = altera_cvp_teardown(mgr, info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\taltera_read_config_dword(conf, VSE_UNCOR_ERR_STATUS, &val);\n\tif (val & VSE_UNCOR_ERR_CVP_CFG_ERR) {\n\t\tdev_err(&mgr->dev, \"detected CVP_CONFIG_ERROR_LATCHED!\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\taltera_read_config_dword(conf, VSE_CVP_MODE_CTRL, &val);\n\tval &= ~VSE_CVP_MODE_CTRL_HIP_CLK_SEL;\n\tval &= ~VSE_CVP_MODE_CTRL_CVP_MODE;\n\taltera_write_config_dword(conf, VSE_CVP_MODE_CTRL, val);\n\n\t \n\tmask = VSE_CVP_STATUS_PLD_CLK_IN_USE | VSE_CVP_STATUS_USERMODE;\n\tret = altera_cvp_wait_status(conf, mask, mask,\n\t\t\t\t     conf->priv->user_time_us);\n\tif (ret)\n\t\tdev_err(&mgr->dev, \"PLD_CLK_IN_USE|USERMODE timeout\\n\");\n\n\treturn ret;\n}\n\nstatic const struct fpga_manager_ops altera_cvp_ops = {\n\t.state\t\t= altera_cvp_state,\n\t.write_init\t= altera_cvp_write_init,\n\t.write\t\t= altera_cvp_write,\n\t.write_complete\t= altera_cvp_write_complete,\n};\n\nstatic const struct cvp_priv cvp_priv_v1 = {\n\t.switch_clk\t= altera_cvp_dummy_write,\n\t.block_size\t= ALTERA_CVP_V1_SIZE,\n\t.poll_time_us\t= V1_POLL_TIMEOUT_US,\n\t.user_time_us\t= TIMEOUT_US,\n};\n\nstatic const struct cvp_priv cvp_priv_v2 = {\n\t.clear_state\t= altera_cvp_v2_clear_state,\n\t.wait_credit\t= altera_cvp_v2_wait_for_credit,\n\t.block_size\t= ALTERA_CVP_V2_SIZE,\n\t.poll_time_us\t= V2_POLL_TIMEOUT_US,\n\t.user_time_us\t= V2_USER_TIMEOUT_US,\n};\n\nstatic ssize_t chkcfg_show(struct device_driver *dev, char *buf)\n{\n\treturn snprintf(buf, 3, \"%d\\n\", altera_cvp_chkcfg);\n}\n\nstatic ssize_t chkcfg_store(struct device_driver *drv, const char *buf,\n\t\t\t    size_t count)\n{\n\tint ret;\n\n\tret = kstrtobool(buf, &altera_cvp_chkcfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DRIVER_ATTR_RW(chkcfg);\n\nstatic int altera_cvp_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *dev_id);\nstatic void altera_cvp_remove(struct pci_dev *pdev);\n\nstatic struct pci_device_id altera_cvp_id_tbl[] = {\n\t{ PCI_VDEVICE(ALTERA, PCI_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, altera_cvp_id_tbl);\n\nstatic struct pci_driver altera_cvp_driver = {\n\t.name   = DRV_NAME,\n\t.id_table = altera_cvp_id_tbl,\n\t.probe  = altera_cvp_probe,\n\t.remove = altera_cvp_remove,\n};\n\nstatic int altera_cvp_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *dev_id)\n{\n\tstruct altera_cvp_conf *conf;\n\tstruct fpga_manager *mgr;\n\tint ret, offset;\n\tu16 cmd, val;\n\tu32 regval;\n\n\t \n\toffset = pci_find_next_ext_capability(pdev, 0, PCI_EXT_CAP_ID_VNDR);\n\tif (!offset) {\n\t\tdev_err(&pdev->dev, \"No Vendor Specific Offset.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpci_read_config_word(pdev, offset + VSE_PCIE_EXT_CAP_ID, &val);\n\tif (val != VSE_PCIE_EXT_CAP_ID_VAL) {\n\t\tdev_err(&pdev->dev, \"Wrong EXT_CAP_ID value 0x%x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_dword(pdev, offset + VSE_CVP_STATUS, &regval);\n\tif (!(regval & VSE_CVP_STATUS_CVP_EN)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"CVP is disabled for this device: CVP_STATUS Reg 0x%x\\n\",\n\t\t\tregval);\n\t\treturn -ENODEV;\n\t}\n\n\tconf = devm_kzalloc(&pdev->dev, sizeof(*conf), GFP_KERNEL);\n\tif (!conf)\n\t\treturn -ENOMEM;\n\n\tconf->vsec_offset = offset;\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (!(cmd & PCI_COMMAND_MEMORY)) {\n\t\tcmd |= PCI_COMMAND_MEMORY;\n\t\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\t}\n\n\tret = pci_request_region(pdev, CVP_BAR, \"CVP\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Requesting CVP BAR region failed\\n\");\n\t\tgoto err_disable;\n\t}\n\n\tconf->pci_dev = pdev;\n\tconf->write_data = altera_cvp_write_data_iomem;\n\n\tif (conf->vsec_offset == V1_VSEC_OFFSET)\n\t\tconf->priv = &cvp_priv_v1;\n\telse\n\t\tconf->priv = &cvp_priv_v2;\n\n\tconf->map = pci_iomap(pdev, CVP_BAR, 0);\n\tif (!conf->map) {\n\t\tdev_warn(&pdev->dev, \"Mapping CVP BAR failed\\n\");\n\t\tconf->write_data = altera_cvp_write_data_config;\n\t}\n\n\tsnprintf(conf->mgr_name, sizeof(conf->mgr_name), \"%s @%s\",\n\t\t ALTERA_CVP_MGR_NAME, pci_name(pdev));\n\n\tmgr = fpga_mgr_register(&pdev->dev, conf->mgr_name,\n\t\t\t\t&altera_cvp_ops, conf);\n\tif (IS_ERR(mgr)) {\n\t\tret = PTR_ERR(mgr);\n\t\tgoto err_unmap;\n\t}\n\n\tpci_set_drvdata(pdev, mgr);\n\n\treturn 0;\n\nerr_unmap:\n\tif (conf->map)\n\t\tpci_iounmap(pdev, conf->map);\n\tpci_release_region(pdev, CVP_BAR);\nerr_disable:\n\tcmd &= ~PCI_COMMAND_MEMORY;\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\treturn ret;\n}\n\nstatic void altera_cvp_remove(struct pci_dev *pdev)\n{\n\tstruct fpga_manager *mgr = pci_get_drvdata(pdev);\n\tstruct altera_cvp_conf *conf = mgr->priv;\n\tu16 cmd;\n\n\tfpga_mgr_unregister(mgr);\n\tif (conf->map)\n\t\tpci_iounmap(pdev, conf->map);\n\tpci_release_region(pdev, CVP_BAR);\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tcmd &= ~PCI_COMMAND_MEMORY;\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n}\n\nstatic int __init altera_cvp_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&altera_cvp_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&altera_cvp_driver.driver,\n\t\t\t\t &driver_attr_chkcfg);\n\tif (ret)\n\t\tpr_warn(\"Can't create sysfs chkcfg file\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit altera_cvp_exit(void)\n{\n\tdriver_remove_file(&altera_cvp_driver.driver, &driver_attr_chkcfg);\n\tpci_unregister_driver(&altera_cvp_driver);\n}\n\nmodule_init(altera_cvp_init);\nmodule_exit(altera_cvp_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Anatolij Gustschin <agust@denx.de>\");\nMODULE_DESCRIPTION(\"Module to load Altera FPGA over CvP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}