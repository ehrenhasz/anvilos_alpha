{
  "module_name": "altera-pr-ip-core.c",
  "hash_id": "de1db77c898b6e5415fd0ea64c20257a878fb447902398493cdf3cd89ad1bc21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/altera-pr-ip-core.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/fpga/altera-pr-ip-core.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/module.h>\n\n#define ALT_PR_DATA_OFST\t\t0x00\n#define ALT_PR_CSR_OFST\t\t\t0x04\n\n#define ALT_PR_CSR_PR_START\t\tBIT(0)\n#define ALT_PR_CSR_STATUS_SFT\t\t2\n#define ALT_PR_CSR_STATUS_MSK\t\t(7 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_NRESET\t(0 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_PR_ERR\t(1 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_CRC_ERR\t(2 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_BAD_BITS\t(3 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_PR_IN_PROG\t(4 << ALT_PR_CSR_STATUS_SFT)\n#define ALT_PR_CSR_STATUS_PR_SUCCESS\t(5 << ALT_PR_CSR_STATUS_SFT)\n\nstruct alt_pr_priv {\n\tvoid __iomem *reg_base;\n};\n\nstatic enum fpga_mgr_states alt_pr_fpga_state(struct fpga_manager *mgr)\n{\n\tstruct alt_pr_priv *priv = mgr->priv;\n\tconst char *err = \"unknown\";\n\tenum fpga_mgr_states ret = FPGA_MGR_STATE_UNKNOWN;\n\tu32 val;\n\n\tval = readl(priv->reg_base + ALT_PR_CSR_OFST);\n\n\tval &= ALT_PR_CSR_STATUS_MSK;\n\n\tswitch (val) {\n\tcase ALT_PR_CSR_STATUS_NRESET:\n\t\treturn FPGA_MGR_STATE_RESET;\n\n\tcase ALT_PR_CSR_STATUS_PR_ERR:\n\t\terr = \"pr error\";\n\t\tret = FPGA_MGR_STATE_WRITE_ERR;\n\t\tbreak;\n\n\tcase ALT_PR_CSR_STATUS_CRC_ERR:\n\t\terr = \"crc error\";\n\t\tret = FPGA_MGR_STATE_WRITE_ERR;\n\t\tbreak;\n\n\tcase ALT_PR_CSR_STATUS_BAD_BITS:\n\t\terr = \"bad bits\";\n\t\tret = FPGA_MGR_STATE_WRITE_ERR;\n\t\tbreak;\n\n\tcase ALT_PR_CSR_STATUS_PR_IN_PROG:\n\t\treturn FPGA_MGR_STATE_WRITE;\n\n\tcase ALT_PR_CSR_STATUS_PR_SUCCESS:\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_err(&mgr->dev, \"encountered error code %d (%s) in %s()\\n\",\n\t\tval, err, __func__);\n\treturn ret;\n}\n\nstatic int alt_pr_fpga_write_init(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct alt_pr_priv *priv = mgr->priv;\n\tu32 val;\n\n\tif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\tdev_err(&mgr->dev, \"%s Partial Reconfiguration flag not set\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(priv->reg_base + ALT_PR_CSR_OFST);\n\n\tif (val & ALT_PR_CSR_PR_START) {\n\t\tdev_err(&mgr->dev,\n\t\t\t\"%s Partial Reconfiguration already started\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(val | ALT_PR_CSR_PR_START, priv->reg_base + ALT_PR_CSR_OFST);\n\n\treturn 0;\n}\n\nstatic int alt_pr_fpga_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct alt_pr_priv *priv = mgr->priv;\n\tu32 *buffer_32 = (u32 *)buf;\n\tsize_t i = 0;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\t \n\twhile (count >= sizeof(u32)) {\n\t\twritel(buffer_32[i++], priv->reg_base);\n\t\tcount -= sizeof(u32);\n\t}\n\n\t \n\tswitch (count) {\n\tcase 3:\n\t\twritel(buffer_32[i++] & 0x00ffffff, priv->reg_base);\n\t\tbreak;\n\tcase 2:\n\t\twritel(buffer_32[i++] & 0x0000ffff, priv->reg_base);\n\t\tbreak;\n\tcase 1:\n\t\twritel(buffer_32[i++] & 0x000000ff, priv->reg_base);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EFAULT;\n\t}\n\n\tif (alt_pr_fpga_state(mgr) == FPGA_MGR_STATE_WRITE_ERR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int alt_pr_fpga_write_complete(struct fpga_manager *mgr,\n\t\t\t\t      struct fpga_image_info *info)\n{\n\tu32 i = 0;\n\n\tdo {\n\t\tswitch (alt_pr_fpga_state(mgr)) {\n\t\tcase FPGA_MGR_STATE_WRITE_ERR:\n\t\t\treturn -EIO;\n\n\t\tcase FPGA_MGR_STATE_OPERATING:\n\t\t\tdev_info(&mgr->dev,\n\t\t\t\t \"successful partial reconfiguration\\n\");\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t} while (info->config_complete_timeout_us > i++);\n\n\tdev_err(&mgr->dev, \"timed out waiting for write to complete\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic const struct fpga_manager_ops alt_pr_ops = {\n\t.state = alt_pr_fpga_state,\n\t.write_init = alt_pr_fpga_write_init,\n\t.write = alt_pr_fpga_write,\n\t.write_complete = alt_pr_fpga_write_complete,\n};\n\nint alt_pr_register(struct device *dev, void __iomem *reg_base)\n{\n\tstruct alt_pr_priv *priv;\n\tstruct fpga_manager *mgr;\n\tu32 val;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg_base = reg_base;\n\n\tval = readl(priv->reg_base + ALT_PR_CSR_OFST);\n\n\tdev_dbg(dev, \"%s status=%d start=%d\\n\", __func__,\n\t\t(val & ALT_PR_CSR_STATUS_MSK) >> ALT_PR_CSR_STATUS_SFT,\n\t\t(int)(val & ALT_PR_CSR_PR_START));\n\n\tmgr = devm_fpga_mgr_register(dev, dev_name(dev), &alt_pr_ops, priv);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\nEXPORT_SYMBOL_GPL(alt_pr_register);\n\nMODULE_AUTHOR(\"Matthew Gerlach <matthew.gerlach@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Altera Partial Reconfiguration IP Core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}