{
  "module_name": "socfpga.c",
  "hash_id": "60ab729d2195e558b9e5f1ccb9dccdf7717f4f5c500ea59e0dbadcd275cb2203",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/socfpga.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/pm.h>\n\n \n#define SOCFPGA_FPGMGR_STAT_OFST\t\t\t\t0x0\n#define SOCFPGA_FPGMGR_CTL_OFST\t\t\t\t\t0x4\n#define SOCFPGA_FPGMGR_DCLKCNT_OFST\t\t\t\t0x8\n#define SOCFPGA_FPGMGR_DCLKSTAT_OFST\t\t\t\t0xc\n#define SOCFPGA_FPGMGR_GPIO_INTEN_OFST\t\t\t\t0x830\n#define SOCFPGA_FPGMGR_GPIO_INTMSK_OFST\t\t\t\t0x834\n#define SOCFPGA_FPGMGR_GPIO_INTTYPE_LEVEL_OFST\t\t\t0x838\n#define SOCFPGA_FPGMGR_GPIO_INT_POL_OFST\t\t\t0x83c\n#define SOCFPGA_FPGMGR_GPIO_INTSTAT_OFST\t\t\t0x840\n#define SOCFPGA_FPGMGR_GPIO_RAW_INTSTAT_OFST\t\t\t0x844\n#define SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST\t\t\t0x84c\n#define SOCFPGA_FPGMGR_GPIO_EXT_PORTA_OFST\t\t\t0x850\n\n \n \n#define SOCFPGA_FPGMGR_STAT_POWER_UP\t\t\t\t0x0  \n#define SOCFPGA_FPGMGR_STAT_RESET\t\t\t\t0x1\n#define SOCFPGA_FPGMGR_STAT_CFG\t\t\t\t\t0x2\n#define SOCFPGA_FPGMGR_STAT_INIT\t\t\t\t0x3\n#define SOCFPGA_FPGMGR_STAT_USER_MODE\t\t\t\t0x4\n#define SOCFPGA_FPGMGR_STAT_UNKNOWN\t\t\t\t0x5\n#define SOCFPGA_FPGMGR_STAT_STATE_MASK\t\t\t\t0x7\n \n#define SOCFPGA_FPGMGR_STAT_POWER_OFF\t\t\t\t0x0\n\n#define MSEL_PP16_FAST_NOAES_NODC\t\t\t\t0x0\n#define MSEL_PP16_FAST_AES_NODC\t\t\t\t\t0x1\n#define MSEL_PP16_FAST_AESOPT_DC\t\t\t\t0x2\n#define MSEL_PP16_SLOW_NOAES_NODC\t\t\t\t0x4\n#define MSEL_PP16_SLOW_AES_NODC\t\t\t\t\t0x5\n#define MSEL_PP16_SLOW_AESOPT_DC\t\t\t\t0x6\n#define MSEL_PP32_FAST_NOAES_NODC\t\t\t\t0x8\n#define MSEL_PP32_FAST_AES_NODC\t\t\t\t\t0x9\n#define MSEL_PP32_FAST_AESOPT_DC\t\t\t\t0xa\n#define MSEL_PP32_SLOW_NOAES_NODC\t\t\t\t0xc\n#define MSEL_PP32_SLOW_AES_NODC\t\t\t\t\t0xd\n#define MSEL_PP32_SLOW_AESOPT_DC\t\t\t\t0xe\n#define SOCFPGA_FPGMGR_STAT_MSEL_MASK\t\t\t\t0x000000f8\n#define SOCFPGA_FPGMGR_STAT_MSEL_SHIFT\t\t\t\t3\n\n \n#define SOCFPGA_FPGMGR_CTL_EN\t\t\t\t\t0x00000001\n#define SOCFPGA_FPGMGR_CTL_NCE\t\t\t\t\t0x00000002\n#define SOCFPGA_FPGMGR_CTL_NCFGPULL\t\t\t\t0x00000004\n\n#define CDRATIO_X1\t\t\t\t\t\t0x00000000\n#define CDRATIO_X2\t\t\t\t\t\t0x00000040\n#define CDRATIO_X4\t\t\t\t\t\t0x00000080\n#define CDRATIO_X8\t\t\t\t\t\t0x000000c0\n#define SOCFPGA_FPGMGR_CTL_CDRATIO_MASK\t\t\t\t0x000000c0\n\n#define SOCFPGA_FPGMGR_CTL_AXICFGEN\t\t\t\t0x00000100\n\n#define CFGWDTH_16\t\t\t\t\t\t0x00000000\n#define CFGWDTH_32\t\t\t\t\t\t0x00000200\n#define SOCFPGA_FPGMGR_CTL_CFGWDTH_MASK\t\t\t\t0x00000200\n\n \n#define SOCFPGA_FPGMGR_DCLKSTAT_DCNTDONE_E_DONE\t\t\t0x1\n\n \n#define SOCFPGA_FPGMGR_MON_NSTATUS\t\t\t\t0x0001\n#define SOCFPGA_FPGMGR_MON_CONF_DONE\t\t\t\t0x0002\n#define SOCFPGA_FPGMGR_MON_INIT_DONE\t\t\t\t0x0004\n#define SOCFPGA_FPGMGR_MON_CRC_ERROR\t\t\t\t0x0008\n#define SOCFPGA_FPGMGR_MON_CVP_CONF_DONE\t\t\t0x0010\n#define SOCFPGA_FPGMGR_MON_PR_READY\t\t\t\t0x0020\n#define SOCFPGA_FPGMGR_MON_PR_ERROR\t\t\t\t0x0040\n#define SOCFPGA_FPGMGR_MON_PR_DONE\t\t\t\t0x0080\n#define SOCFPGA_FPGMGR_MON_NCONFIG_PIN\t\t\t\t0x0100\n#define SOCFPGA_FPGMGR_MON_NSTATUS_PIN\t\t\t\t0x0200\n#define SOCFPGA_FPGMGR_MON_CONF_DONE_PIN\t\t\t0x0400\n#define SOCFPGA_FPGMGR_MON_FPGA_POWER_ON\t\t\t0x0800\n#define SOCFPGA_FPGMGR_MON_STATUS_MASK\t\t\t\t0x0fff\n\n#define SOCFPGA_FPGMGR_NUM_SUPPLIES 3\n#define SOCFPGA_RESUME_TIMEOUT 3\n\n \nstatic const char *supply_names[SOCFPGA_FPGMGR_NUM_SUPPLIES] __maybe_unused = {\n\t\"FPGA-1.5V\",\n\t\"FPGA-1.1V\",\n\t\"FPGA-2.5V\",\n};\n\nstruct socfpga_fpga_priv {\n\tvoid __iomem *fpga_base_addr;\n\tvoid __iomem *fpga_data_addr;\n\tstruct completion status_complete;\n\tint irq;\n};\n\nstruct cfgmgr_mode {\n\t \n\tu32 ctrl;\n\n\t \n\tbool valid;\n};\n\n \nstatic struct cfgmgr_mode cfgmgr_modes[] = {\n\t[MSEL_PP16_FAST_NOAES_NODC] = { CFGWDTH_16 | CDRATIO_X1, 1 },\n\t[MSEL_PP16_FAST_AES_NODC] =   { CFGWDTH_16 | CDRATIO_X2, 1 },\n\t[MSEL_PP16_FAST_AESOPT_DC] =  { CFGWDTH_16 | CDRATIO_X4, 1 },\n\t[MSEL_PP16_SLOW_NOAES_NODC] = { CFGWDTH_16 | CDRATIO_X1, 1 },\n\t[MSEL_PP16_SLOW_AES_NODC] =   { CFGWDTH_16 | CDRATIO_X2, 1 },\n\t[MSEL_PP16_SLOW_AESOPT_DC] =  { CFGWDTH_16 | CDRATIO_X4, 1 },\n\t[MSEL_PP32_FAST_NOAES_NODC] = { CFGWDTH_32 | CDRATIO_X1, 1 },\n\t[MSEL_PP32_FAST_AES_NODC] =   { CFGWDTH_32 | CDRATIO_X4, 1 },\n\t[MSEL_PP32_FAST_AESOPT_DC] =  { CFGWDTH_32 | CDRATIO_X8, 1 },\n\t[MSEL_PP32_SLOW_NOAES_NODC] = { CFGWDTH_32 | CDRATIO_X1, 1 },\n\t[MSEL_PP32_SLOW_AES_NODC] =   { CFGWDTH_32 | CDRATIO_X4, 1 },\n\t[MSEL_PP32_SLOW_AESOPT_DC] =  { CFGWDTH_32 | CDRATIO_X8, 1 },\n};\n\nstatic u32 socfpga_fpga_readl(struct socfpga_fpga_priv *priv, u32 reg_offset)\n{\n\treturn readl(priv->fpga_base_addr + reg_offset);\n}\n\nstatic void socfpga_fpga_writel(struct socfpga_fpga_priv *priv, u32 reg_offset,\n\t\t\t\tu32 value)\n{\n\twritel(value, priv->fpga_base_addr + reg_offset);\n}\n\nstatic u32 socfpga_fpga_raw_readl(struct socfpga_fpga_priv *priv,\n\t\t\t\t  u32 reg_offset)\n{\n\treturn __raw_readl(priv->fpga_base_addr + reg_offset);\n}\n\nstatic void socfpga_fpga_raw_writel(struct socfpga_fpga_priv *priv,\n\t\t\t\t    u32 reg_offset, u32 value)\n{\n\t__raw_writel(value, priv->fpga_base_addr + reg_offset);\n}\n\nstatic void socfpga_fpga_data_writel(struct socfpga_fpga_priv *priv, u32 value)\n{\n\twritel(value, priv->fpga_data_addr);\n}\n\nstatic inline void socfpga_fpga_set_bitsl(struct socfpga_fpga_priv *priv,\n\t\t\t\t\t  u32 offset, u32 bits)\n{\n\tu32 val;\n\n\tval = socfpga_fpga_readl(priv, offset);\n\tval |= bits;\n\tsocfpga_fpga_writel(priv, offset, val);\n}\n\nstatic inline void socfpga_fpga_clr_bitsl(struct socfpga_fpga_priv *priv,\n\t\t\t\t\t  u32 offset, u32 bits)\n{\n\tu32 val;\n\n\tval = socfpga_fpga_readl(priv, offset);\n\tval &= ~bits;\n\tsocfpga_fpga_writel(priv, offset, val);\n}\n\nstatic u32 socfpga_fpga_mon_status_get(struct socfpga_fpga_priv *priv)\n{\n\treturn socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_GPIO_EXT_PORTA_OFST) &\n\t\tSOCFPGA_FPGMGR_MON_STATUS_MASK;\n}\n\nstatic u32 socfpga_fpga_state_get(struct socfpga_fpga_priv *priv)\n{\n\tu32 status = socfpga_fpga_mon_status_get(priv);\n\n\tif ((status & SOCFPGA_FPGMGR_MON_FPGA_POWER_ON) == 0)\n\t\treturn SOCFPGA_FPGMGR_STAT_POWER_OFF;\n\n\treturn socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_STAT_OFST) &\n\t\tSOCFPGA_FPGMGR_STAT_STATE_MASK;\n}\n\nstatic void socfpga_fpga_clear_done_status(struct socfpga_fpga_priv *priv)\n{\n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST,\n\t\t\t    SOCFPGA_FPGMGR_DCLKSTAT_DCNTDONE_E_DONE);\n}\n\n \nstatic int socfpga_fpga_dclk_set_and_wait_clear(struct socfpga_fpga_priv *priv,\n\t\t\t\t\t\tu32 count)\n{\n\tint timeout = 2;\n\tu32 done;\n\n\t \n\tif (socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST))\n\t\tsocfpga_fpga_clear_done_status(priv);\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_DCLKCNT_OFST, count);\n\n\t \n\tdo {\n\t\tdone = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST);\n\t\tif (done == SOCFPGA_FPGMGR_DCLKSTAT_DCNTDONE_E_DONE) {\n\t\t\tsocfpga_fpga_clear_done_status(priv);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t} while (timeout--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int socfpga_fpga_wait_for_state(struct socfpga_fpga_priv *priv,\n\t\t\t\t       u32 state)\n{\n\tint timeout = 2;\n\n\t \n\tdo {\n\t\tif ((socfpga_fpga_state_get(priv) & state) != 0)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t} while (timeout--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void socfpga_fpga_enable_irqs(struct socfpga_fpga_priv *priv, u32 irqs)\n{\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTTYPE_LEVEL_OFST, 0);\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INT_POL_OFST, irqs);\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST, irqs);\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTMSK_OFST, 0);\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTEN_OFST, irqs);\n}\n\nstatic void socfpga_fpga_disable_irqs(struct socfpga_fpga_priv *priv)\n{\n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTEN_OFST, 0);\n}\n\nstatic irqreturn_t socfpga_fpga_isr(int irq, void *dev_id)\n{\n\tstruct socfpga_fpga_priv *priv = dev_id;\n\tu32 irqs, st;\n\tbool conf_done, nstatus;\n\n\t \n\tirqs = socfpga_fpga_raw_readl(priv, SOCFPGA_FPGMGR_GPIO_INTSTAT_OFST);\n\n\tsocfpga_fpga_raw_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST, irqs);\n\n\tst = socfpga_fpga_raw_readl(priv, SOCFPGA_FPGMGR_GPIO_EXT_PORTA_OFST);\n\tconf_done = (st & SOCFPGA_FPGMGR_MON_CONF_DONE) != 0;\n\tnstatus = (st & SOCFPGA_FPGMGR_MON_NSTATUS) != 0;\n\n\t \n\tif (conf_done && nstatus) {\n\t\t \n\t\tsocfpga_fpga_raw_writel(priv,\n\t\t\t\t\tSOCFPGA_FPGMGR_GPIO_INTEN_OFST, 0);\n\t\tcomplete(&priv->status_complete);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int socfpga_fpga_wait_for_config_done(struct socfpga_fpga_priv *priv)\n{\n\tint timeout, ret = 0;\n\n\tsocfpga_fpga_disable_irqs(priv);\n\tinit_completion(&priv->status_complete);\n\tsocfpga_fpga_enable_irqs(priv, SOCFPGA_FPGMGR_MON_CONF_DONE);\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t&priv->status_complete,\n\t\t\t\t\t\tmsecs_to_jiffies(10));\n\tif (timeout == 0)\n\t\tret = -ETIMEDOUT;\n\n\tsocfpga_fpga_disable_irqs(priv);\n\treturn ret;\n}\n\nstatic int socfpga_fpga_cfg_mode_get(struct socfpga_fpga_priv *priv)\n{\n\tu32 msel;\n\n\tmsel = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_STAT_OFST);\n\tmsel &= SOCFPGA_FPGMGR_STAT_MSEL_MASK;\n\tmsel >>= SOCFPGA_FPGMGR_STAT_MSEL_SHIFT;\n\n\t \n\tif ((msel >= ARRAY_SIZE(cfgmgr_modes)) || !cfgmgr_modes[msel].valid)\n\t\treturn -EINVAL;\n\n\treturn msel;\n}\n\nstatic int socfpga_fpga_cfg_mode_set(struct socfpga_fpga_priv *priv)\n{\n\tu32 ctrl_reg;\n\tint mode;\n\n\t \n\tmode = socfpga_fpga_cfg_mode_get(priv);\n\tif (mode < 0)\n\t\treturn mode;\n\n\t \n\tctrl_reg = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_CTL_OFST);\n\tctrl_reg &= ~SOCFPGA_FPGMGR_CTL_CDRATIO_MASK;\n\tctrl_reg &= ~SOCFPGA_FPGMGR_CTL_CFGWDTH_MASK;\n\tctrl_reg |= cfgmgr_modes[mode].ctrl;\n\n\t \n\tctrl_reg &= ~SOCFPGA_FPGMGR_CTL_NCE;\n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\n\n\treturn 0;\n}\n\nstatic int socfpga_fpga_reset(struct fpga_manager *mgr)\n{\n\tstruct socfpga_fpga_priv *priv = mgr->priv;\n\tu32 ctrl_reg, status;\n\tint ret;\n\n\t \n\tret = socfpga_fpga_cfg_mode_set(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsocfpga_fpga_set_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\n\t\t\t       SOCFPGA_FPGMGR_CTL_EN);\n\n\t \n\tctrl_reg = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_CTL_OFST);\n\tctrl_reg |= SOCFPGA_FPGMGR_CTL_NCFGPULL;\n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\n\n\t \n\tstatus = socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_RESET);\n\n\t \n\tctrl_reg &= ~SOCFPGA_FPGMGR_CTL_NCFGPULL;\n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\n\n\t \n\tif (status)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int socfpga_fpga_ops_configure_init(struct fpga_manager *mgr,\n\t\t\t\t\t   struct fpga_image_info *info,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct socfpga_fpga_priv *priv = mgr->priv;\n\tint ret;\n\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_err(&mgr->dev, \"Partial reconfiguration not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = socfpga_fpga_reset(mgr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_CFG))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST,\n\t\t\t    SOCFPGA_FPGMGR_MON_NSTATUS);\n\n\t \n\tsocfpga_fpga_set_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\n\t\t\t       SOCFPGA_FPGMGR_CTL_AXICFGEN);\n\n\treturn 0;\n}\n\n \nstatic int socfpga_fpga_ops_configure_write(struct fpga_manager *mgr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct socfpga_fpga_priv *priv = mgr->priv;\n\tu32 *buffer_32 = (u32 *)buf;\n\tsize_t i = 0;\n\n\tif (count <= 0)\n\t\treturn -EINVAL;\n\n\t \n\twhile (count >= sizeof(u32)) {\n\t\tsocfpga_fpga_data_writel(priv, buffer_32[i++]);\n\t\tcount -= sizeof(u32);\n\t}\n\n\t \n\tswitch (count) {\n\tcase 3:\n\t\tsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x00ffffff);\n\t\tbreak;\n\tcase 2:\n\t\tsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x0000ffff);\n\t\tbreak;\n\tcase 1:\n\t\tsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x000000ff);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int socfpga_fpga_ops_configure_complete(struct fpga_manager *mgr,\n\t\t\t\t\t       struct fpga_image_info *info)\n{\n\tstruct socfpga_fpga_priv *priv = mgr->priv;\n\tu32 status;\n\n\t \n\tstatus = socfpga_fpga_wait_for_config_done(priv);\n\tif (status)\n\t\treturn status;\n\n\t \n\tsocfpga_fpga_clr_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\n\t\t\t       SOCFPGA_FPGMGR_CTL_AXICFGEN);\n\n\t \n\tif (socfpga_fpga_dclk_set_and_wait_clear(priv, 4))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif (socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_USER_MODE))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tsocfpga_fpga_clr_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\n\t\t\t       SOCFPGA_FPGMGR_CTL_EN);\n\n\treturn 0;\n}\n\n \nstatic const enum fpga_mgr_states socfpga_state_to_framework_state[] = {\n\t[SOCFPGA_FPGMGR_STAT_POWER_OFF] = FPGA_MGR_STATE_POWER_OFF,\n\t[SOCFPGA_FPGMGR_STAT_RESET] = FPGA_MGR_STATE_RESET,\n\t[SOCFPGA_FPGMGR_STAT_CFG] = FPGA_MGR_STATE_WRITE_INIT,\n\t[SOCFPGA_FPGMGR_STAT_INIT] = FPGA_MGR_STATE_WRITE_INIT,\n\t[SOCFPGA_FPGMGR_STAT_USER_MODE] = FPGA_MGR_STATE_OPERATING,\n\t[SOCFPGA_FPGMGR_STAT_UNKNOWN] = FPGA_MGR_STATE_UNKNOWN,\n};\n\nstatic enum fpga_mgr_states socfpga_fpga_ops_state(struct fpga_manager *mgr)\n{\n\tstruct socfpga_fpga_priv *priv = mgr->priv;\n\tenum fpga_mgr_states ret;\n\tu32 state;\n\n\tstate = socfpga_fpga_state_get(priv);\n\n\tif (state < ARRAY_SIZE(socfpga_state_to_framework_state))\n\t\tret = socfpga_state_to_framework_state[state];\n\telse\n\t\tret = FPGA_MGR_STATE_UNKNOWN;\n\n\treturn ret;\n}\n\nstatic const struct fpga_manager_ops socfpga_fpga_ops = {\n\t.state = socfpga_fpga_ops_state,\n\t.write_init = socfpga_fpga_ops_configure_init,\n\t.write = socfpga_fpga_ops_configure_write,\n\t.write_complete = socfpga_fpga_ops_configure_complete,\n};\n\nstatic int socfpga_fpga_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct socfpga_fpga_priv *priv;\n\tstruct fpga_manager *mgr;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->fpga_base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->fpga_base_addr))\n\t\treturn PTR_ERR(priv->fpga_base_addr);\n\n\tpriv->fpga_data_addr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->fpga_data_addr))\n\t\treturn PTR_ERR(priv->fpga_data_addr);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tret = devm_request_irq(dev, priv->irq, socfpga_fpga_isr, 0,\n\t\t\t       dev_name(dev), priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmgr = devm_fpga_mgr_register(dev, \"Altera SOCFPGA FPGA Manager\",\n\t\t\t\t     &socfpga_fpga_ops, priv);\n\treturn PTR_ERR_OR_ZERO(mgr);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id socfpga_fpga_of_match[] = {\n\t{ .compatible = \"altr,socfpga-fpga-mgr\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, socfpga_fpga_of_match);\n#endif\n\nstatic struct platform_driver socfpga_fpga_driver = {\n\t.probe = socfpga_fpga_probe,\n\t.driver = {\n\t\t.name\t= \"socfpga_fpga_manager\",\n\t\t.of_match_table = of_match_ptr(socfpga_fpga_of_match),\n\t},\n};\n\nmodule_platform_driver(socfpga_fpga_driver);\n\nMODULE_AUTHOR(\"Alan Tull <atull@opensource.altera.com>\");\nMODULE_DESCRIPTION(\"Altera SOCFPGA FPGA Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}