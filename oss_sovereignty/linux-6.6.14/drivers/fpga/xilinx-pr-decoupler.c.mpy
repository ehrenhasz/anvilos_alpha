{
  "module_name": "xilinx-pr-decoupler.c",
  "hash_id": "902b68ac14b8ccdc1191402b55ba5eb4e94c31104fafd6d9b1e3640a836a9175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/xilinx-pr-decoupler.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of_device.h>\n#include <linux/module.h>\n#include <linux/fpga/fpga-bridge.h>\n\n#define CTRL_CMD_DECOUPLE\tBIT(0)\n#define CTRL_CMD_COUPLE\t\t0\n#define CTRL_OFFSET\t\t0\n\nstruct xlnx_config_data {\n\tconst char *name;\n};\n\nstruct xlnx_pr_decoupler_data {\n\tconst struct xlnx_config_data *ipconfig;\n\tvoid __iomem *io_base;\n\tstruct clk *clk;\n};\n\nstatic inline void xlnx_pr_decoupler_write(struct xlnx_pr_decoupler_data *d,\n\t\t\t\t\t   u32 offset, u32 val)\n{\n\twritel(val, d->io_base + offset);\n}\n\nstatic inline u32 xlnx_pr_decouple_read(const struct xlnx_pr_decoupler_data *d,\n\t\t\t\t\tu32 offset)\n{\n\treturn readl(d->io_base + offset);\n}\n\nstatic int xlnx_pr_decoupler_enable_set(struct fpga_bridge *bridge, bool enable)\n{\n\tint err;\n\tstruct xlnx_pr_decoupler_data *priv = bridge->priv;\n\n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\tif (enable)\n\t\txlnx_pr_decoupler_write(priv, CTRL_OFFSET, CTRL_CMD_COUPLE);\n\telse\n\t\txlnx_pr_decoupler_write(priv, CTRL_OFFSET, CTRL_CMD_DECOUPLE);\n\n\tclk_disable(priv->clk);\n\n\treturn 0;\n}\n\nstatic int xlnx_pr_decoupler_enable_show(struct fpga_bridge *bridge)\n{\n\tconst struct xlnx_pr_decoupler_data *priv = bridge->priv;\n\tu32 status;\n\tint err;\n\n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\tstatus = xlnx_pr_decouple_read(priv, CTRL_OFFSET);\n\n\tclk_disable(priv->clk);\n\n\treturn !status;\n}\n\nstatic const struct fpga_bridge_ops xlnx_pr_decoupler_br_ops = {\n\t.enable_set = xlnx_pr_decoupler_enable_set,\n\t.enable_show = xlnx_pr_decoupler_enable_show,\n};\n\n#ifdef CONFIG_OF\nstatic const struct xlnx_config_data decoupler_config = {\n\t.name = \"Xilinx PR Decoupler\",\n};\n\nstatic const struct xlnx_config_data shutdown_config = {\n\t.name = \"Xilinx DFX AXI Shutdown Manager\",\n};\n\nstatic const struct of_device_id xlnx_pr_decoupler_of_match[] = {\n\t{ .compatible = \"xlnx,pr-decoupler-1.00\", .data = &decoupler_config },\n\t{ .compatible = \"xlnx,pr-decoupler\", .data = &decoupler_config },\n\t{ .compatible = \"xlnx,dfx-axi-shutdown-manager-1.00\",\n\t\t\t\t\t.data = &shutdown_config },\n\t{ .compatible = \"xlnx,dfx-axi-shutdown-manager\",\n\t\t\t\t\t.data = &shutdown_config },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xlnx_pr_decoupler_of_match);\n#endif\n\nstatic int xlnx_pr_decoupler_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct xlnx_pr_decoupler_data *priv;\n\tstruct fpga_bridge *br;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (np) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(xlnx_pr_decoupler_of_match, np);\n\t\tif (match && match->data)\n\t\t\tpriv->ipconfig = match->data;\n\t}\n\n\tpriv->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->io_base))\n\t\treturn PTR_ERR(priv->io_base);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, \"aclk\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"input clock not found\\n\");\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\tclk_disable(priv->clk);\n\n\tbr = fpga_bridge_register(&pdev->dev, priv->ipconfig->name,\n\t\t\t\t  &xlnx_pr_decoupler_br_ops, priv);\n\tif (IS_ERR(br)) {\n\t\terr = PTR_ERR(br);\n\t\tdev_err(&pdev->dev, \"unable to register %s\",\n\t\t\tpriv->ipconfig->name);\n\t\tgoto err_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, br);\n\n\treturn 0;\n\nerr_clk:\n\tclk_unprepare(priv->clk);\n\n\treturn err;\n}\n\nstatic int xlnx_pr_decoupler_remove(struct platform_device *pdev)\n{\n\tstruct fpga_bridge *bridge = platform_get_drvdata(pdev);\n\tstruct xlnx_pr_decoupler_data *p = bridge->priv;\n\n\tfpga_bridge_unregister(bridge);\n\n\tclk_unprepare(p->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver xlnx_pr_decoupler_driver = {\n\t.probe = xlnx_pr_decoupler_probe,\n\t.remove = xlnx_pr_decoupler_remove,\n\t.driver = {\n\t\t.name = \"xlnx_pr_decoupler\",\n\t\t.of_match_table = of_match_ptr(xlnx_pr_decoupler_of_match),\n\t},\n};\n\nmodule_platform_driver(xlnx_pr_decoupler_driver);\n\nMODULE_DESCRIPTION(\"Xilinx Partial Reconfiguration Decoupler\");\nMODULE_AUTHOR(\"Moritz Fischer <mdf@kernel.org>\");\nMODULE_AUTHOR(\"Michal Simek <michal.simek@xilinx.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}