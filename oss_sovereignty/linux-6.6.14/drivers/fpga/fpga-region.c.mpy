{
  "module_name": "fpga-region.c",
  "hash_id": "75b7018b3241f08a5f4e17d1b0ee0fa54c37660c10f45afa39fce277036f9ce8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/fpga-region.c",
  "human_readable_source": "\n \n#include <linux/fpga/fpga-bridge.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/fpga/fpga-region.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\nstatic DEFINE_IDA(fpga_region_ida);\nstatic const struct class fpga_region_class;\n\nstruct fpga_region *\nfpga_region_class_find(struct device *start, const void *data,\n\t\t       int (*match)(struct device *, const void *))\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(&fpga_region_class, start, data, match);\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_fpga_region(dev);\n}\nEXPORT_SYMBOL_GPL(fpga_region_class_find);\n\n \nstatic struct fpga_region *fpga_region_get(struct fpga_region *region)\n{\n\tstruct device *dev = &region->dev;\n\n\tif (!mutex_trylock(&region->mutex)) {\n\t\tdev_dbg(dev, \"%s: FPGA Region already in use\\n\", __func__);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tget_device(dev);\n\tif (!try_module_get(dev->parent->driver->owner)) {\n\t\tput_device(dev);\n\t\tmutex_unlock(&region->mutex);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tdev_dbg(dev, \"get\\n\");\n\n\treturn region;\n}\n\n \nstatic void fpga_region_put(struct fpga_region *region)\n{\n\tstruct device *dev = &region->dev;\n\n\tdev_dbg(dev, \"put\\n\");\n\n\tmodule_put(dev->parent->driver->owner);\n\tput_device(dev);\n\tmutex_unlock(&region->mutex);\n}\n\n \nint fpga_region_program_fpga(struct fpga_region *region)\n{\n\tstruct device *dev = &region->dev;\n\tstruct fpga_image_info *info = region->info;\n\tint ret;\n\n\tregion = fpga_region_get(region);\n\tif (IS_ERR(region)) {\n\t\tdev_err(dev, \"failed to get FPGA region\\n\");\n\t\treturn PTR_ERR(region);\n\t}\n\n\tret = fpga_mgr_lock(region->mgr);\n\tif (ret) {\n\t\tdev_err(dev, \"FPGA manager is busy\\n\");\n\t\tgoto err_put_region;\n\t}\n\n\t \n\tif (region->get_bridges) {\n\t\tret = region->get_bridges(region);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to get fpga region bridges\\n\");\n\t\t\tgoto err_unlock_mgr;\n\t\t}\n\t}\n\n\tret = fpga_bridges_disable(&region->bridge_list);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to disable bridges\\n\");\n\t\tgoto err_put_br;\n\t}\n\n\tret = fpga_mgr_load(region->mgr, info);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to load FPGA image\\n\");\n\t\tgoto err_put_br;\n\t}\n\n\tret = fpga_bridges_enable(&region->bridge_list);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable region bridges\\n\");\n\t\tgoto err_put_br;\n\t}\n\n\tfpga_mgr_unlock(region->mgr);\n\tfpga_region_put(region);\n\n\treturn 0;\n\nerr_put_br:\n\tif (region->get_bridges)\n\t\tfpga_bridges_put(&region->bridge_list);\nerr_unlock_mgr:\n\tfpga_mgr_unlock(region->mgr);\nerr_put_region:\n\tfpga_region_put(region);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fpga_region_program_fpga);\n\nstatic ssize_t compat_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct fpga_region *region = to_fpga_region(dev);\n\n\tif (!region->compat_id)\n\t\treturn -ENOENT;\n\n\treturn sprintf(buf, \"%016llx%016llx\\n\",\n\t\t       (unsigned long long)region->compat_id->id_h,\n\t\t       (unsigned long long)region->compat_id->id_l);\n}\n\nstatic DEVICE_ATTR_RO(compat_id);\n\nstatic struct attribute *fpga_region_attrs[] = {\n\t&dev_attr_compat_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(fpga_region);\n\n \nstruct fpga_region *\nfpga_region_register_full(struct device *parent, const struct fpga_region_info *info)\n{\n\tstruct fpga_region *region;\n\tint id, ret = 0;\n\n\tif (!info) {\n\t\tdev_err(parent,\n\t\t\t\"Attempt to register without required info structure\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_alloc(&fpga_region_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tret = id;\n\t\tgoto err_free;\n\t}\n\n\tregion->mgr = info->mgr;\n\tregion->compat_id = info->compat_id;\n\tregion->priv = info->priv;\n\tregion->get_bridges = info->get_bridges;\n\n\tmutex_init(&region->mutex);\n\tINIT_LIST_HEAD(&region->bridge_list);\n\n\tregion->dev.class = &fpga_region_class;\n\tregion->dev.parent = parent;\n\tregion->dev.of_node = parent->of_node;\n\tregion->dev.id = id;\n\n\tret = dev_set_name(&region->dev, \"region%d\", id);\n\tif (ret)\n\t\tgoto err_remove;\n\n\tret = device_register(&region->dev);\n\tif (ret) {\n\t\tput_device(&region->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn region;\n\nerr_remove:\n\tida_free(&fpga_region_ida, id);\nerr_free:\n\tkfree(region);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(fpga_region_register_full);\n\n \nstruct fpga_region *\nfpga_region_register(struct device *parent, struct fpga_manager *mgr,\n\t\t     int (*get_bridges)(struct fpga_region *))\n{\n\tstruct fpga_region_info info = { 0 };\n\n\tinfo.mgr = mgr;\n\tinfo.get_bridges = get_bridges;\n\n\treturn fpga_region_register_full(parent, &info);\n}\nEXPORT_SYMBOL_GPL(fpga_region_register);\n\n \nvoid fpga_region_unregister(struct fpga_region *region)\n{\n\tdevice_unregister(&region->dev);\n}\nEXPORT_SYMBOL_GPL(fpga_region_unregister);\n\nstatic void fpga_region_dev_release(struct device *dev)\n{\n\tstruct fpga_region *region = to_fpga_region(dev);\n\n\tida_free(&fpga_region_ida, region->dev.id);\n\tkfree(region);\n}\n\nstatic const struct class fpga_region_class = {\n\t.name = \"fpga_region\",\n\t.dev_groups = fpga_region_groups,\n\t.dev_release = fpga_region_dev_release,\n};\n\n \nstatic int __init fpga_region_init(void)\n{\n\treturn class_register(&fpga_region_class);\n}\n\nstatic void __exit fpga_region_exit(void)\n{\n\tclass_unregister(&fpga_region_class);\n\tida_destroy(&fpga_region_ida);\n}\n\nsubsys_initcall(fpga_region_init);\nmodule_exit(fpga_region_exit);\n\nMODULE_DESCRIPTION(\"FPGA Region\");\nMODULE_AUTHOR(\"Alan Tull <atull@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}