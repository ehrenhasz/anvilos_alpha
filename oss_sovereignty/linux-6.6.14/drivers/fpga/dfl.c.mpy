{
  "module_name": "dfl.c",
  "hash_id": "0116756ff149b5e7131422692e1e3f578d5b0f74e25c0078208cdb9be873320f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/dfl.c",
  "human_readable_source": "\n \n#include <linux/dfl.h>\n#include <linux/fpga-dfl.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/uaccess.h>\n\n#include \"dfl.h\"\n\nstatic DEFINE_MUTEX(dfl_id_mutex);\n\n \nenum dfl_fpga_devt_type {\n\tDFL_FPGA_DEVT_FME,\n\tDFL_FPGA_DEVT_PORT,\n\tDFL_FPGA_DEVT_MAX,\n};\n\nstatic struct lock_class_key dfl_pdata_keys[DFL_ID_MAX];\n\nstatic const char *dfl_pdata_key_strings[DFL_ID_MAX] = {\n\t\"dfl-fme-pdata\",\n\t\"dfl-port-pdata\",\n};\n\n \nstruct dfl_dev_info {\n\tconst char *name;\n\tu16 dfh_id;\n\tstruct idr id;\n\tenum dfl_fpga_devt_type devt_type;\n};\n\n \nstatic struct dfl_dev_info dfl_devs[] = {\n\t{.name = DFL_FPGA_FEATURE_DEV_FME, .dfh_id = DFH_ID_FIU_FME,\n\t .devt_type = DFL_FPGA_DEVT_FME},\n\t{.name = DFL_FPGA_FEATURE_DEV_PORT, .dfh_id = DFH_ID_FIU_PORT,\n\t .devt_type = DFL_FPGA_DEVT_PORT},\n};\n\n \nstruct dfl_chardev_info {\n\tconst char *name;\n\tdev_t devt;\n};\n\n \nstatic struct dfl_chardev_info dfl_chrdevs[] = {\n\t{.name = DFL_FPGA_FEATURE_DEV_FME},\n\t{.name = DFL_FPGA_FEATURE_DEV_PORT},\n};\n\nstatic void dfl_ids_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dfl_devs); i++)\n\t\tidr_init(&dfl_devs[i].id);\n}\n\nstatic void dfl_ids_destroy(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dfl_devs); i++)\n\t\tidr_destroy(&dfl_devs[i].id);\n}\n\nstatic int dfl_id_alloc(enum dfl_id_type type, struct device *dev)\n{\n\tint id;\n\n\tWARN_ON(type >= DFL_ID_MAX);\n\tmutex_lock(&dfl_id_mutex);\n\tid = idr_alloc(&dfl_devs[type].id, dev, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&dfl_id_mutex);\n\n\treturn id;\n}\n\nstatic void dfl_id_free(enum dfl_id_type type, int id)\n{\n\tWARN_ON(type >= DFL_ID_MAX);\n\tmutex_lock(&dfl_id_mutex);\n\tidr_remove(&dfl_devs[type].id, id);\n\tmutex_unlock(&dfl_id_mutex);\n}\n\nstatic enum dfl_id_type feature_dev_id_type(struct platform_device *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dfl_devs); i++)\n\t\tif (!strcmp(dfl_devs[i].name, pdev->name))\n\t\t\treturn i;\n\n\treturn DFL_ID_MAX;\n}\n\nstatic enum dfl_id_type dfh_id_to_type(u16 id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dfl_devs); i++)\n\t\tif (dfl_devs[i].dfh_id == id)\n\t\t\treturn i;\n\n\treturn DFL_ID_MAX;\n}\n\n \n\nstatic DEFINE_MUTEX(dfl_port_ops_mutex);\nstatic LIST_HEAD(dfl_port_ops_list);\n\n \nstruct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev)\n{\n\tstruct dfl_fpga_port_ops *ops = NULL;\n\n\tmutex_lock(&dfl_port_ops_mutex);\n\tif (list_empty(&dfl_port_ops_list))\n\t\tgoto done;\n\n\tlist_for_each_entry(ops, &dfl_port_ops_list, node) {\n\t\t \n\t\tif (!strcmp(pdev->name, ops->name)) {\n\t\t\tif (!try_module_get(ops->owner))\n\t\t\t\tops = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tops = NULL;\ndone:\n\tmutex_unlock(&dfl_port_ops_mutex);\n\treturn ops;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_port_ops_get);\n\n \nvoid dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops)\n{\n\tif (ops && ops->owner)\n\t\tmodule_put(ops->owner);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_port_ops_put);\n\n \nvoid dfl_fpga_port_ops_add(struct dfl_fpga_port_ops *ops)\n{\n\tmutex_lock(&dfl_port_ops_mutex);\n\tlist_add_tail(&ops->node, &dfl_port_ops_list);\n\tmutex_unlock(&dfl_port_ops_mutex);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_port_ops_add);\n\n \nvoid dfl_fpga_port_ops_del(struct dfl_fpga_port_ops *ops)\n{\n\tmutex_lock(&dfl_port_ops_mutex);\n\tlist_del(&ops->node);\n\tmutex_unlock(&dfl_port_ops_mutex);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_port_ops_del);\n\n \nint dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_fpga_port_ops *port_ops;\n\n\tif (pdata->id != FEATURE_DEV_ID_UNUSED)\n\t\treturn pdata->id == *(int *)pport_id;\n\n\tport_ops = dfl_fpga_port_ops_get(pdev);\n\tif (!port_ops || !port_ops->get_id)\n\t\treturn 0;\n\n\tpdata->id = port_ops->get_id(pdev);\n\tdfl_fpga_port_ops_put(port_ops);\n\n\treturn pdata->id == *(int *)pport_id;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_check_port_id);\n\nstatic DEFINE_IDA(dfl_device_ida);\n\nstatic const struct dfl_device_id *\ndfl_match_one_device(const struct dfl_device_id *id, struct dfl_device *ddev)\n{\n\tif (id->type == ddev->type && id->feature_id == ddev->feature_id)\n\t\treturn id;\n\n\treturn NULL;\n}\n\nstatic int dfl_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\tstruct dfl_driver *ddrv = to_dfl_drv(drv);\n\tconst struct dfl_device_id *id_entry;\n\n\tid_entry = ddrv->id_table;\n\tif (id_entry) {\n\t\twhile (id_entry->feature_id) {\n\t\t\tif (dfl_match_one_device(id_entry, ddev)) {\n\t\t\t\tddev->id_entry = id_entry;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tid_entry++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dfl_bus_probe(struct device *dev)\n{\n\tstruct dfl_driver *ddrv = to_dfl_drv(dev->driver);\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\n\treturn ddrv->probe(ddev);\n}\n\nstatic void dfl_bus_remove(struct device *dev)\n{\n\tstruct dfl_driver *ddrv = to_dfl_drv(dev->driver);\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\n\tif (ddrv->remove)\n\t\tddrv->remove(ddev);\n}\n\nstatic int dfl_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct dfl_device *ddev = to_dfl_dev(dev);\n\n\treturn add_uevent_var(env, \"MODALIAS=dfl:t%04Xf%04X\",\n\t\t\t      ddev->type, ddev->feature_id);\n}\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\n\treturn sprintf(buf, \"0x%x\\n\", ddev->type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t\nfeature_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\n\treturn sprintf(buf, \"0x%x\\n\", ddev->feature_id);\n}\nstatic DEVICE_ATTR_RO(feature_id);\n\nstatic struct attribute *dfl_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_feature_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dfl_dev);\n\nstatic struct bus_type dfl_bus_type = {\n\t.name\t\t= \"dfl\",\n\t.match\t\t= dfl_bus_match,\n\t.probe\t\t= dfl_bus_probe,\n\t.remove\t\t= dfl_bus_remove,\n\t.uevent\t\t= dfl_bus_uevent,\n\t.dev_groups\t= dfl_dev_groups,\n};\n\nstatic void release_dfl_dev(struct device *dev)\n{\n\tstruct dfl_device *ddev = to_dfl_dev(dev);\n\n\tif (ddev->mmio_res.parent)\n\t\trelease_resource(&ddev->mmio_res);\n\n\tkfree(ddev->params);\n\n\tida_free(&dfl_device_ida, ddev->id);\n\tkfree(ddev->irqs);\n\tkfree(ddev);\n}\n\nstatic struct dfl_device *\ndfl_dev_add(struct dfl_feature_platform_data *pdata,\n\t    struct dfl_feature *feature)\n{\n\tstruct platform_device *pdev = pdata->dev;\n\tstruct resource *parent_res;\n\tstruct dfl_device *ddev;\n\tint id, i, ret;\n\n\tddev = kzalloc(sizeof(*ddev), GFP_KERNEL);\n\tif (!ddev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_alloc(&dfl_device_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"unable to get id\\n\");\n\t\tkfree(ddev);\n\t\treturn ERR_PTR(id);\n\t}\n\n\t \n\tdevice_initialize(&ddev->dev);\n\tddev->dev.parent = &pdev->dev;\n\tddev->dev.bus = &dfl_bus_type;\n\tddev->dev.release = release_dfl_dev;\n\tddev->id = id;\n\tret = dev_set_name(&ddev->dev, \"dfl_dev.%d\", id);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tddev->type = feature_dev_id_type(pdev);\n\tddev->feature_id = feature->id;\n\tddev->revision = feature->revision;\n\tddev->dfh_version = feature->dfh_version;\n\tddev->cdev = pdata->dfl_cdev;\n\tif (feature->param_size) {\n\t\tddev->params = kmemdup(feature->params, feature->param_size, GFP_KERNEL);\n\t\tif (!ddev->params) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_dev;\n\t\t}\n\t\tddev->param_size = feature->param_size;\n\t}\n\n\t \n\tparent_res = &pdev->resource[feature->resource_index];\n\tddev->mmio_res.flags = IORESOURCE_MEM;\n\tddev->mmio_res.start = parent_res->start;\n\tddev->mmio_res.end = parent_res->end;\n\tddev->mmio_res.name = dev_name(&ddev->dev);\n\tret = insert_resource(parent_res, &ddev->mmio_res);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s failed to claim resource: %pR\\n\",\n\t\t\tdev_name(&ddev->dev), &ddev->mmio_res);\n\t\tgoto put_dev;\n\t}\n\n\t \n\tif (feature->nr_irqs) {\n\t\tddev->irqs = kcalloc(feature->nr_irqs,\n\t\t\t\t     sizeof(*ddev->irqs), GFP_KERNEL);\n\t\tif (!ddev->irqs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_dev;\n\t\t}\n\n\t\tfor (i = 0; i < feature->nr_irqs; i++)\n\t\t\tddev->irqs[i] = feature->irq_ctx[i].irq;\n\n\t\tddev->num_irqs = feature->nr_irqs;\n\t}\n\n\tret = device_add(&ddev->dev);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tdev_dbg(&pdev->dev, \"add dfl_dev: %s\\n\", dev_name(&ddev->dev));\n\treturn ddev;\n\nput_dev:\n\t \n\tput_device(&ddev->dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic void dfl_devs_remove(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_feature *feature;\n\n\tdfl_fpga_dev_for_each_feature(pdata, feature) {\n\t\tif (feature->ddev) {\n\t\t\tdevice_unregister(&feature->ddev->dev);\n\t\t\tfeature->ddev = NULL;\n\t\t}\n\t}\n}\n\nstatic int dfl_devs_add(struct dfl_feature_platform_data *pdata)\n{\n\tstruct dfl_feature *feature;\n\tstruct dfl_device *ddev;\n\tint ret;\n\n\tdfl_fpga_dev_for_each_feature(pdata, feature) {\n\t\tif (feature->ioaddr)\n\t\t\tcontinue;\n\n\t\tif (feature->ddev) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\tddev = dfl_dev_add(pdata, feature);\n\t\tif (IS_ERR(ddev)) {\n\t\t\tret = PTR_ERR(ddev);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfeature->ddev = ddev;\n\t}\n\n\treturn 0;\n\nerr:\n\tdfl_devs_remove(pdata);\n\treturn ret;\n}\n\nint __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner)\n{\n\tif (!dfl_drv || !dfl_drv->probe || !dfl_drv->id_table)\n\t\treturn -EINVAL;\n\n\tdfl_drv->drv.owner = owner;\n\tdfl_drv->drv.bus = &dfl_bus_type;\n\n\treturn driver_register(&dfl_drv->drv);\n}\nEXPORT_SYMBOL(__dfl_driver_register);\n\nvoid dfl_driver_unregister(struct dfl_driver *dfl_drv)\n{\n\tdriver_unregister(&dfl_drv->drv);\n}\nEXPORT_SYMBOL(dfl_driver_unregister);\n\n#define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)\n\n \nvoid dfl_fpga_dev_feature_uinit(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_feature *feature;\n\n\tdfl_devs_remove(pdata);\n\n\tdfl_fpga_dev_for_each_feature(pdata, feature) {\n\t\tif (feature->ops) {\n\t\t\tif (feature->ops->uinit)\n\t\t\t\tfeature->ops->uinit(pdev, feature);\n\t\t\tfeature->ops = NULL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_dev_feature_uinit);\n\nstatic int dfl_feature_instance_init(struct platform_device *pdev,\n\t\t\t\t     struct dfl_feature_platform_data *pdata,\n\t\t\t\t     struct dfl_feature *feature,\n\t\t\t\t     struct dfl_feature_driver *drv)\n{\n\tvoid __iomem *base;\n\tint ret = 0;\n\n\tif (!is_header_feature(feature)) {\n\t\tbase = devm_platform_ioremap_resource(pdev,\n\t\t\t\t\t\t      feature->resource_index);\n\t\tif (IS_ERR(base)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"ioremap failed for feature 0x%x!\\n\",\n\t\t\t\tfeature->id);\n\t\t\treturn PTR_ERR(base);\n\t\t}\n\n\t\tfeature->ioaddr = base;\n\t}\n\n\tif (drv->ops->init) {\n\t\tret = drv->ops->init(pdev, feature);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfeature->ops = drv->ops;\n\n\treturn ret;\n}\n\nstatic bool dfl_feature_drv_match(struct dfl_feature *feature,\n\t\t\t\t  struct dfl_feature_driver *driver)\n{\n\tconst struct dfl_feature_id *ids = driver->id_table;\n\n\tif (ids) {\n\t\twhile (ids->id) {\n\t\t\tif (ids->id == feature->id)\n\t\t\t\treturn true;\n\t\t\tids++;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nint dfl_fpga_dev_feature_init(struct platform_device *pdev,\n\t\t\t      struct dfl_feature_driver *feature_drvs)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_feature_driver *drv = feature_drvs;\n\tstruct dfl_feature *feature;\n\tint ret;\n\n\twhile (drv->ops) {\n\t\tdfl_fpga_dev_for_each_feature(pdata, feature) {\n\t\t\tif (dfl_feature_drv_match(feature, drv)) {\n\t\t\t\tret = dfl_feature_instance_init(pdev, pdata,\n\t\t\t\t\t\t\t\tfeature, drv);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tdrv++;\n\t}\n\n\tret = dfl_devs_add(pdata);\n\tif (ret)\n\t\tgoto exit;\n\n\treturn 0;\nexit:\n\tdfl_fpga_dev_feature_uinit(pdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_dev_feature_init);\n\nstatic void dfl_chardev_uinit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DFL_FPGA_DEVT_MAX; i++)\n\t\tif (MAJOR(dfl_chrdevs[i].devt)) {\n\t\t\tunregister_chrdev_region(dfl_chrdevs[i].devt,\n\t\t\t\t\t\t MINORMASK + 1);\n\t\t\tdfl_chrdevs[i].devt = MKDEV(0, 0);\n\t\t}\n}\n\nstatic int dfl_chardev_init(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < DFL_FPGA_DEVT_MAX; i++) {\n\t\tret = alloc_chrdev_region(&dfl_chrdevs[i].devt, 0,\n\t\t\t\t\t  MINORMASK + 1, dfl_chrdevs[i].name);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\treturn 0;\n\nexit:\n\tdfl_chardev_uinit();\n\treturn ret;\n}\n\nstatic dev_t dfl_get_devt(enum dfl_fpga_devt_type type, int id)\n{\n\tif (type >= DFL_FPGA_DEVT_MAX)\n\t\treturn 0;\n\n\treturn MKDEV(MAJOR(dfl_chrdevs[type].devt), id);\n}\n\n \nint dfl_fpga_dev_ops_register(struct platform_device *pdev,\n\t\t\t      const struct file_operations *fops,\n\t\t\t      struct module *owner)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tcdev_init(&pdata->cdev, fops);\n\tpdata->cdev.owner = owner;\n\n\t \n\tpdata->cdev.kobj.parent = &pdev->dev.kobj;\n\n\treturn cdev_add(&pdata->cdev, pdev->dev.devt, 1);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_dev_ops_register);\n\n \nvoid dfl_fpga_dev_ops_unregister(struct platform_device *pdev)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tcdev_del(&pdata->cdev);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_dev_ops_unregister);\n\n \nstruct build_feature_devs_info {\n\tstruct device *dev;\n\tstruct dfl_fpga_cdev *cdev;\n\tunsigned int nr_irqs;\n\tint *irq_table;\n\n\tstruct platform_device *feature_dev;\n\tvoid __iomem *ioaddr;\n\tresource_size_t start;\n\tresource_size_t len;\n\tstruct list_head sub_features;\n\tint feature_num;\n};\n\n \nstruct dfl_feature_info {\n\tu16 fid;\n\tu8 revision;\n\tu8 dfh_version;\n\tstruct resource mmio_res;\n\tvoid __iomem *ioaddr;\n\tstruct list_head node;\n\tunsigned int irq_base;\n\tunsigned int nr_irqs;\n\tunsigned int param_size;\n\tu64 params[];\n};\n\nstatic void dfl_fpga_cdev_add_port_dev(struct dfl_fpga_cdev *cdev,\n\t\t\t\t       struct platform_device *port)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&port->dev);\n\n\tmutex_lock(&cdev->lock);\n\tlist_add(&pdata->node, &cdev->port_dev_list);\n\tget_device(&pdata->dev->dev);\n\tmutex_unlock(&cdev->lock);\n}\n\n \nstatic int build_info_commit_dev(struct build_feature_devs_info *binfo)\n{\n\tstruct platform_device *fdev = binfo->feature_dev;\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct dfl_feature_info *finfo, *p;\n\tenum dfl_id_type type;\n\tint ret, index = 0, res_idx = 0;\n\n\ttype = feature_dev_id_type(fdev);\n\tif (WARN_ON_ONCE(type >= DFL_ID_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tpdata = kzalloc(struct_size(pdata, features, binfo->feature_num), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->dev = fdev;\n\tpdata->num = binfo->feature_num;\n\tpdata->dfl_cdev = binfo->cdev;\n\tpdata->id = FEATURE_DEV_ID_UNUSED;\n\tmutex_init(&pdata->lock);\n\tlockdep_set_class_and_name(&pdata->lock, &dfl_pdata_keys[type],\n\t\t\t\t   dfl_pdata_key_strings[type]);\n\n\t \n\tWARN_ON(pdata->disable_count);\n\n\tfdev->dev.platform_data = pdata;\n\n\t \n\tfdev->num_resources = binfo->feature_num;\n\tfdev->resource = kcalloc(binfo->feature_num, sizeof(*fdev->resource),\n\t\t\t\t GFP_KERNEL);\n\tif (!fdev->resource)\n\t\treturn -ENOMEM;\n\n\t \n\tlist_for_each_entry_safe(finfo, p, &binfo->sub_features, node) {\n\t\tstruct dfl_feature *feature = &pdata->features[index++];\n\t\tstruct dfl_feature_irq_ctx *ctx;\n\t\tunsigned int i;\n\n\t\t \n\t\tfeature->dev = fdev;\n\t\tfeature->id = finfo->fid;\n\t\tfeature->revision = finfo->revision;\n\t\tfeature->dfh_version = finfo->dfh_version;\n\n\t\tif (finfo->param_size) {\n\t\t\tfeature->params = devm_kmemdup(binfo->dev,\n\t\t\t\t\t\t       finfo->params, finfo->param_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!feature->params)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tfeature->param_size = finfo->param_size;\n\t\t}\n\t\t \n\t\tif (is_header_feature(feature)) {\n\t\t\tfeature->resource_index = -1;\n\t\t\tfeature->ioaddr =\n\t\t\t\tdevm_ioremap_resource(binfo->dev,\n\t\t\t\t\t\t      &finfo->mmio_res);\n\t\t\tif (IS_ERR(feature->ioaddr))\n\t\t\t\treturn PTR_ERR(feature->ioaddr);\n\t\t} else {\n\t\t\tfeature->resource_index = res_idx;\n\t\t\tfdev->resource[res_idx++] = finfo->mmio_res;\n\t\t}\n\n\t\tif (finfo->nr_irqs) {\n\t\t\tctx = devm_kcalloc(binfo->dev, finfo->nr_irqs,\n\t\t\t\t\t   sizeof(*ctx), GFP_KERNEL);\n\t\t\tif (!ctx)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tfor (i = 0; i < finfo->nr_irqs; i++)\n\t\t\t\tctx[i].irq =\n\t\t\t\t\tbinfo->irq_table[finfo->irq_base + i];\n\n\t\t\tfeature->irq_ctx = ctx;\n\t\t\tfeature->nr_irqs = finfo->nr_irqs;\n\t\t}\n\n\t\tlist_del(&finfo->node);\n\t\tkfree(finfo);\n\t}\n\n\tret = platform_device_add(binfo->feature_dev);\n\tif (!ret) {\n\t\tif (type == PORT_ID)\n\t\t\tdfl_fpga_cdev_add_port_dev(binfo->cdev,\n\t\t\t\t\t\t   binfo->feature_dev);\n\t\telse\n\t\t\tbinfo->cdev->fme_dev =\n\t\t\t\t\tget_device(&binfo->feature_dev->dev);\n\t\t \n\t\tbinfo->feature_dev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbuild_info_create_dev(struct build_feature_devs_info *binfo,\n\t\t      enum dfl_id_type type)\n{\n\tstruct platform_device *fdev;\n\n\tif (type >= DFL_ID_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tfdev = platform_device_alloc(dfl_devs[type].name, -ENODEV);\n\tif (!fdev)\n\t\treturn -ENOMEM;\n\n\tbinfo->feature_dev = fdev;\n\tbinfo->feature_num = 0;\n\n\tINIT_LIST_HEAD(&binfo->sub_features);\n\n\tfdev->id = dfl_id_alloc(type, &fdev->dev);\n\tif (fdev->id < 0)\n\t\treturn fdev->id;\n\n\tfdev->dev.parent = &binfo->cdev->region->dev;\n\tfdev->dev.devt = dfl_get_devt(dfl_devs[type].devt_type, fdev->id);\n\n\treturn 0;\n}\n\nstatic void build_info_free(struct build_feature_devs_info *binfo)\n{\n\tstruct dfl_feature_info *finfo, *p;\n\n\t \n\tif (binfo->feature_dev && binfo->feature_dev->id >= 0) {\n\t\tdfl_id_free(feature_dev_id_type(binfo->feature_dev),\n\t\t\t    binfo->feature_dev->id);\n\n\t\tlist_for_each_entry_safe(finfo, p, &binfo->sub_features, node) {\n\t\t\tlist_del(&finfo->node);\n\t\t\tkfree(finfo);\n\t\t}\n\t}\n\n\tplatform_device_put(binfo->feature_dev);\n\n\tdevm_kfree(binfo->dev, binfo);\n}\n\nstatic inline u32 feature_size(u64 value)\n{\n\tu32 ofst = FIELD_GET(DFH_NEXT_HDR_OFST, value);\n\t \n\treturn ofst ? ofst : 4096;\n}\n\nstatic u16 feature_id(u64 value)\n{\n\tu16 id = FIELD_GET(DFH_ID, value);\n\tu8 type = FIELD_GET(DFH_TYPE, value);\n\n\tif (type == DFH_TYPE_FIU)\n\t\treturn FEATURE_ID_FIU_HEADER;\n\telse if (type == DFH_TYPE_PRIVATE)\n\t\treturn id;\n\telse if (type == DFH_TYPE_AFU)\n\t\treturn FEATURE_ID_AFU;\n\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic u64 *find_param(u64 *params, resource_size_t max, int param_id)\n{\n\tu64 *end = params + max / sizeof(u64);\n\tu64 v, next;\n\n\twhile (params < end) {\n\t\tv = *params;\n\t\tif (param_id == FIELD_GET(DFHv1_PARAM_HDR_ID, v))\n\t\t\treturn params;\n\n\t\tif (FIELD_GET(DFHv1_PARAM_HDR_NEXT_EOP, v))\n\t\t\tbreak;\n\n\t\tnext = FIELD_GET(DFHv1_PARAM_HDR_NEXT_OFFSET, v);\n\t\tparams += next;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid *dfh_find_param(struct dfl_device *dfl_dev, int param_id, size_t *psize)\n{\n\tu64 *phdr = find_param(dfl_dev->params, dfl_dev->param_size, param_id);\n\n\tif (!phdr)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (psize)\n\t\t*psize = (FIELD_GET(DFHv1_PARAM_HDR_NEXT_OFFSET, *phdr) - 1) * sizeof(u64);\n\n\treturn phdr + 1;\n}\nEXPORT_SYMBOL_GPL(dfh_find_param);\n\nstatic int parse_feature_irqs(struct build_feature_devs_info *binfo,\n\t\t\t      resource_size_t ofst, struct dfl_feature_info *finfo)\n{\n\tvoid __iomem *base = binfo->ioaddr + ofst;\n\tunsigned int i, ibase, inr = 0;\n\tvoid *params = finfo->params;\n\tenum dfl_id_type type;\n\tu16 fid = finfo->fid;\n\tint virq;\n\tu64 *p;\n\tu64 v;\n\n\tswitch (finfo->dfh_version) {\n\tcase 0:\n\t\t \n\t\ttype = feature_dev_id_type(binfo->feature_dev);\n\t\tif (type == PORT_ID) {\n\t\t\tswitch (fid) {\n\t\t\tcase PORT_FEATURE_ID_UINT:\n\t\t\t\tv = readq(base + PORT_UINT_CAP);\n\t\t\t\tibase = FIELD_GET(PORT_UINT_CAP_FST_VECT, v);\n\t\t\t\tinr = FIELD_GET(PORT_UINT_CAP_INT_NUM, v);\n\t\t\t\tbreak;\n\t\t\tcase PORT_FEATURE_ID_ERROR:\n\t\t\t\tv = readq(base + PORT_ERROR_CAP);\n\t\t\t\tibase = FIELD_GET(PORT_ERROR_CAP_INT_VECT, v);\n\t\t\t\tinr = FIELD_GET(PORT_ERROR_CAP_SUPP_INT, v);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (type == FME_ID) {\n\t\t\tswitch (fid) {\n\t\t\tcase FME_FEATURE_ID_GLOBAL_ERR:\n\t\t\t\tv = readq(base + FME_ERROR_CAP);\n\t\t\t\tibase = FIELD_GET(FME_ERROR_CAP_INT_VECT, v);\n\t\t\t\tinr = FIELD_GET(FME_ERROR_CAP_SUPP_INT, v);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tp = find_param(params, finfo->param_size, DFHv1_PARAM_ID_MSI_X);\n\t\tif (!p)\n\t\t\tbreak;\n\n\t\tp++;\n\t\tibase = FIELD_GET(DFHv1_PARAM_MSI_X_STARTV, *p);\n\t\tinr = FIELD_GET(DFHv1_PARAM_MSI_X_NUMV, *p);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(binfo->dev, \"unexpected DFH version %d\\n\", finfo->dfh_version);\n\t\tbreak;\n\t}\n\n\tif (!inr) {\n\t\tfinfo->irq_base = 0;\n\t\tfinfo->nr_irqs = 0;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(binfo->dev, \"feature: 0x%x, irq_base: %u, nr_irqs: %u\\n\",\n\t\tfid, ibase, inr);\n\n\tif (ibase + inr > binfo->nr_irqs) {\n\t\tdev_err(binfo->dev,\n\t\t\t\"Invalid interrupt number in feature 0x%x\\n\", fid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < inr; i++) {\n\t\tvirq = binfo->irq_table[ibase + i];\n\t\tif (virq < 0 || virq > NR_IRQS) {\n\t\t\tdev_err(binfo->dev,\n\t\t\t\t\"Invalid irq table entry for feature 0x%x\\n\",\n\t\t\t\tfid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfinfo->irq_base = ibase;\n\tfinfo->nr_irqs = inr;\n\n\treturn 0;\n}\n\nstatic int dfh_get_param_size(void __iomem *dfh_base, resource_size_t max)\n{\n\tint size = 0;\n\tu64 v, next;\n\n\tif (!FIELD_GET(DFHv1_CSR_SIZE_GRP_HAS_PARAMS,\n\t\t       readq(dfh_base + DFHv1_CSR_SIZE_GRP)))\n\t\treturn 0;\n\n\twhile (size + DFHv1_PARAM_HDR < max) {\n\t\tv = readq(dfh_base + DFHv1_PARAM_HDR + size);\n\n\t\tnext = FIELD_GET(DFHv1_PARAM_HDR_NEXT_OFFSET, v);\n\t\tif (!next)\n\t\t\treturn -EINVAL;\n\n\t\tsize += next * sizeof(u64);\n\n\t\tif (FIELD_GET(DFHv1_PARAM_HDR_NEXT_EOP, v))\n\t\t\treturn size;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int\ncreate_feature_instance(struct build_feature_devs_info *binfo,\n\t\t\tresource_size_t ofst, resource_size_t size, u16 fid)\n{\n\tstruct dfl_feature_info *finfo;\n\tresource_size_t start, end;\n\tint dfh_psize = 0;\n\tu8 revision = 0;\n\tu64 v, addr_off;\n\tu8 dfh_ver = 0;\n\tint ret;\n\n\tif (fid != FEATURE_ID_AFU) {\n\t\tv = readq(binfo->ioaddr + ofst);\n\t\trevision = FIELD_GET(DFH_REVISION, v);\n\t\tdfh_ver = FIELD_GET(DFH_VERSION, v);\n\t\t \n\t\tsize = size ? size : feature_size(v);\n\t\tfid = fid ? fid : feature_id(v);\n\t\tif (dfh_ver == 1) {\n\t\t\tdfh_psize = dfh_get_param_size(binfo->ioaddr + ofst, size);\n\t\t\tif (dfh_psize < 0) {\n\t\t\t\tdev_err(binfo->dev,\n\t\t\t\t\t\"failed to read size of DFHv1 parameters %d\\n\",\n\t\t\t\t\tdfh_psize);\n\t\t\t\treturn dfh_psize;\n\t\t\t}\n\t\t\tdev_dbg(binfo->dev, \"dfhv1_psize %d\\n\", dfh_psize);\n\t\t}\n\t}\n\n\tif (binfo->len - ofst < size)\n\t\treturn -EINVAL;\n\n\tfinfo = kzalloc(struct_size(finfo, params, dfh_psize / sizeof(u64)), GFP_KERNEL);\n\tif (!finfo)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(finfo->params, binfo->ioaddr + ofst + DFHv1_PARAM_HDR, dfh_psize);\n\tfinfo->param_size = dfh_psize;\n\n\tfinfo->fid = fid;\n\tfinfo->revision = revision;\n\tfinfo->dfh_version = dfh_ver;\n\tif (dfh_ver == 1) {\n\t\tv = readq(binfo->ioaddr + ofst + DFHv1_CSR_ADDR);\n\t\taddr_off = FIELD_GET(DFHv1_CSR_ADDR_MASK, v);\n\t\tif (FIELD_GET(DFHv1_CSR_ADDR_REL, v))\n\t\t\tstart = addr_off << 1;\n\t\telse\n\t\t\tstart = binfo->start + ofst + addr_off;\n\n\t\tv = readq(binfo->ioaddr + ofst + DFHv1_CSR_SIZE_GRP);\n\t\tend = start + FIELD_GET(DFHv1_CSR_SIZE_GRP_SIZE, v) - 1;\n\t} else {\n\t\tstart = binfo->start + ofst;\n\t\tend = start + size - 1;\n\t}\n\tfinfo->mmio_res.flags = IORESOURCE_MEM;\n\tfinfo->mmio_res.start = start;\n\tfinfo->mmio_res.end = end;\n\n\tret = parse_feature_irqs(binfo, ofst, finfo);\n\tif (ret) {\n\t\tkfree(finfo);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&finfo->node, &binfo->sub_features);\n\tbinfo->feature_num++;\n\n\treturn 0;\n}\n\nstatic int parse_feature_port_afu(struct build_feature_devs_info *binfo,\n\t\t\t\t  resource_size_t ofst)\n{\n\tu64 v = readq(binfo->ioaddr + PORT_HDR_CAP);\n\tu32 size = FIELD_GET(PORT_CAP_MMIO_SIZE, v) << 10;\n\n\tWARN_ON(!size);\n\n\treturn create_feature_instance(binfo, ofst, size, FEATURE_ID_AFU);\n}\n\n#define is_feature_dev_detected(binfo) (!!(binfo)->feature_dev)\n\nstatic int parse_feature_afu(struct build_feature_devs_info *binfo,\n\t\t\t     resource_size_t ofst)\n{\n\tif (!is_feature_dev_detected(binfo)) {\n\t\tdev_err(binfo->dev, \"this AFU does not belong to any FIU.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (feature_dev_id_type(binfo->feature_dev)) {\n\tcase PORT_ID:\n\t\treturn parse_feature_port_afu(binfo, ofst);\n\tdefault:\n\t\tdev_info(binfo->dev, \"AFU belonging to FIU %s is not supported yet.\\n\",\n\t\t\t binfo->feature_dev->name);\n\t}\n\n\treturn 0;\n}\n\nstatic int build_info_prepare(struct build_feature_devs_info *binfo,\n\t\t\t      resource_size_t start, resource_size_t len)\n{\n\tstruct device *dev = binfo->dev;\n\tvoid __iomem *ioaddr;\n\n\tif (!devm_request_mem_region(dev, start, len, dev_name(dev))) {\n\t\tdev_err(dev, \"request region fail, start:%pa, len:%pa\\n\",\n\t\t\t&start, &len);\n\t\treturn -EBUSY;\n\t}\n\n\tioaddr = devm_ioremap(dev, start, len);\n\tif (!ioaddr) {\n\t\tdev_err(dev, \"ioremap region fail, start:%pa, len:%pa\\n\",\n\t\t\t&start, &len);\n\t\treturn -ENOMEM;\n\t}\n\n\tbinfo->start = start;\n\tbinfo->len = len;\n\tbinfo->ioaddr = ioaddr;\n\n\treturn 0;\n}\n\nstatic void build_info_complete(struct build_feature_devs_info *binfo)\n{\n\tdevm_iounmap(binfo->dev, binfo->ioaddr);\n\tdevm_release_mem_region(binfo->dev, binfo->start, binfo->len);\n}\n\nstatic int parse_feature_fiu(struct build_feature_devs_info *binfo,\n\t\t\t     resource_size_t ofst)\n{\n\tint ret = 0;\n\tu32 offset;\n\tu16 id;\n\tu64 v;\n\n\tif (is_feature_dev_detected(binfo)) {\n\t\tbuild_info_complete(binfo);\n\n\t\tret = build_info_commit_dev(binfo);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = build_info_prepare(binfo, binfo->start + ofst,\n\t\t\t\t\t binfo->len - ofst);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tv = readq(binfo->ioaddr + DFH);\n\tid = FIELD_GET(DFH_ID, v);\n\n\t \n\tret = build_info_create_dev(binfo, dfh_id_to_type(id));\n\tif (ret)\n\t\treturn ret;\n\n\tret = create_feature_instance(binfo, 0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\tv = readq(binfo->ioaddr + NEXT_AFU);\n\n\toffset = FIELD_GET(NEXT_AFU_NEXT_DFH_OFST, v);\n\tif (offset)\n\t\treturn parse_feature_afu(binfo, offset);\n\n\tdev_dbg(binfo->dev, \"No AFUs detected on FIU %d\\n\", id);\n\n\treturn ret;\n}\n\nstatic int parse_feature_private(struct build_feature_devs_info *binfo,\n\t\t\t\t resource_size_t ofst)\n{\n\tif (!is_feature_dev_detected(binfo)) {\n\t\tdev_err(binfo->dev, \"the private feature 0x%x does not belong to any AFU.\\n\",\n\t\t\tfeature_id(readq(binfo->ioaddr + ofst)));\n\t\treturn -EINVAL;\n\t}\n\n\treturn create_feature_instance(binfo, ofst, 0, 0);\n}\n\n \nstatic int parse_feature(struct build_feature_devs_info *binfo,\n\t\t\t resource_size_t ofst)\n{\n\tu64 v;\n\tu32 type;\n\n\tv = readq(binfo->ioaddr + ofst + DFH);\n\ttype = FIELD_GET(DFH_TYPE, v);\n\n\tswitch (type) {\n\tcase DFH_TYPE_AFU:\n\t\treturn parse_feature_afu(binfo, ofst);\n\tcase DFH_TYPE_PRIVATE:\n\t\treturn parse_feature_private(binfo, ofst);\n\tcase DFH_TYPE_FIU:\n\t\treturn parse_feature_fiu(binfo, ofst);\n\tdefault:\n\t\tdev_info(binfo->dev,\n\t\t\t \"Feature Type %x is not supported.\\n\", type);\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_feature_list(struct build_feature_devs_info *binfo,\n\t\t\t      resource_size_t start, resource_size_t len)\n{\n\tresource_size_t end = start + len;\n\tint ret = 0;\n\tu32 ofst = 0;\n\tu64 v;\n\n\tret = build_info_prepare(binfo, start, len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (; start < end; start += ofst) {\n\t\tif (end - start < DFH_SIZE) {\n\t\t\tdev_err(binfo->dev, \"The region is too small to contain a feature.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = parse_feature(binfo, start - binfo->start);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tv = readq(binfo->ioaddr + start - binfo->start + DFH);\n\t\tofst = FIELD_GET(DFH_NEXT_HDR_OFST, v);\n\n\t\t \n\t\tif ((v & DFH_EOL) || !ofst)\n\t\t\tbreak;\n\t}\n\n\t \n\tbuild_info_complete(binfo);\n\n\tif (is_feature_dev_detected(binfo))\n\t\tret = build_info_commit_dev(binfo);\n\n\treturn ret;\n}\n\nstruct dfl_fpga_enum_info *dfl_fpga_enum_info_alloc(struct device *dev)\n{\n\tstruct dfl_fpga_enum_info *info;\n\n\tget_device(dev);\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\n\tinfo->dev = dev;\n\tINIT_LIST_HEAD(&info->dfls);\n\n\treturn info;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_enum_info_alloc);\n\nvoid dfl_fpga_enum_info_free(struct dfl_fpga_enum_info *info)\n{\n\tstruct dfl_fpga_enum_dfl *tmp, *dfl;\n\tstruct device *dev;\n\n\tif (!info)\n\t\treturn;\n\n\tdev = info->dev;\n\n\t \n\tlist_for_each_entry_safe(dfl, tmp, &info->dfls, node) {\n\t\tlist_del(&dfl->node);\n\t\tdevm_kfree(dev, dfl);\n\t}\n\n\t \n\tif (info->irq_table)\n\t\tdevm_kfree(dev, info->irq_table);\n\n\tdevm_kfree(dev, info);\n\tput_device(dev);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_enum_info_free);\n\n \nint dfl_fpga_enum_info_add_dfl(struct dfl_fpga_enum_info *info,\n\t\t\t       resource_size_t start, resource_size_t len)\n{\n\tstruct dfl_fpga_enum_dfl *dfl;\n\n\tdfl = devm_kzalloc(info->dev, sizeof(*dfl), GFP_KERNEL);\n\tif (!dfl)\n\t\treturn -ENOMEM;\n\n\tdfl->start = start;\n\tdfl->len = len;\n\n\tlist_add_tail(&dfl->node, &info->dfls);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_enum_info_add_dfl);\n\n \nint dfl_fpga_enum_info_add_irq(struct dfl_fpga_enum_info *info,\n\t\t\t       unsigned int nr_irqs, int *irq_table)\n{\n\tif (!nr_irqs || !irq_table)\n\t\treturn -EINVAL;\n\n\tif (info->irq_table)\n\t\treturn -EEXIST;\n\n\tinfo->irq_table = devm_kmemdup(info->dev, irq_table,\n\t\t\t\t       sizeof(int) * nr_irqs, GFP_KERNEL);\n\tif (!info->irq_table)\n\t\treturn -ENOMEM;\n\n\tinfo->nr_irqs = nr_irqs;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_enum_info_add_irq);\n\nstatic int remove_feature_dev(struct device *dev, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tenum dfl_id_type type = feature_dev_id_type(pdev);\n\tint id = pdev->id;\n\n\tplatform_device_unregister(pdev);\n\n\tdfl_id_free(type, id);\n\n\treturn 0;\n}\n\nstatic void remove_feature_devs(struct dfl_fpga_cdev *cdev)\n{\n\tdevice_for_each_child(&cdev->region->dev, NULL, remove_feature_dev);\n}\n\n \nstruct dfl_fpga_cdev *\ndfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info)\n{\n\tstruct build_feature_devs_info *binfo;\n\tstruct dfl_fpga_enum_dfl *dfl;\n\tstruct dfl_fpga_cdev *cdev;\n\tint ret = 0;\n\n\tif (!info->dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcdev = devm_kzalloc(info->dev, sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcdev->parent = info->dev;\n\tmutex_init(&cdev->lock);\n\tINIT_LIST_HEAD(&cdev->port_dev_list);\n\n\tcdev->region = fpga_region_register(info->dev, NULL, NULL);\n\tif (IS_ERR(cdev->region)) {\n\t\tret = PTR_ERR(cdev->region);\n\t\tgoto free_cdev_exit;\n\t}\n\n\t \n\tbinfo = devm_kzalloc(info->dev, sizeof(*binfo), GFP_KERNEL);\n\tif (!binfo) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_region_exit;\n\t}\n\n\tbinfo->dev = info->dev;\n\tbinfo->cdev = cdev;\n\n\tbinfo->nr_irqs = info->nr_irqs;\n\tif (info->nr_irqs)\n\t\tbinfo->irq_table = info->irq_table;\n\n\t \n\tlist_for_each_entry(dfl, &info->dfls, node) {\n\t\tret = parse_feature_list(binfo, dfl->start, dfl->len);\n\t\tif (ret) {\n\t\t\tremove_feature_devs(cdev);\n\t\t\tbuild_info_free(binfo);\n\t\t\tgoto unregister_region_exit;\n\t\t}\n\t}\n\n\tbuild_info_free(binfo);\n\n\treturn cdev;\n\nunregister_region_exit:\n\tfpga_region_unregister(cdev->region);\nfree_cdev_exit:\n\tdevm_kfree(info->dev, cdev);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_feature_devs_enumerate);\n\n \nvoid dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev)\n{\n\tstruct dfl_feature_platform_data *pdata, *ptmp;\n\n\tmutex_lock(&cdev->lock);\n\tif (cdev->fme_dev)\n\t\tput_device(cdev->fme_dev);\n\n\tlist_for_each_entry_safe(pdata, ptmp, &cdev->port_dev_list, node) {\n\t\tstruct platform_device *port_dev = pdata->dev;\n\n\t\t \n\t\tif (!device_is_registered(&port_dev->dev)) {\n\t\t\tdfl_id_free(feature_dev_id_type(port_dev),\n\t\t\t\t    port_dev->id);\n\t\t\tplatform_device_put(port_dev);\n\t\t}\n\n\t\tlist_del(&pdata->node);\n\t\tput_device(&port_dev->dev);\n\t}\n\tmutex_unlock(&cdev->lock);\n\n\tremove_feature_devs(cdev);\n\n\tfpga_region_unregister(cdev->region);\n\tdevm_kfree(cdev->parent, cdev);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_feature_devs_remove);\n\n \nstruct platform_device *\n__dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,\n\t\t\t  int (*match)(struct platform_device *, void *))\n{\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct platform_device *port_dev;\n\n\tlist_for_each_entry(pdata, &cdev->port_dev_list, node) {\n\t\tport_dev = pdata->dev;\n\n\t\tif (match(port_dev, data) && get_device(&port_dev->dev))\n\t\t\treturn port_dev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__dfl_fpga_cdev_find_port);\n\nstatic int __init dfl_fpga_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&dfl_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tdfl_ids_init();\n\n\tret = dfl_chardev_init();\n\tif (ret) {\n\t\tdfl_ids_destroy();\n\t\tbus_unregister(&dfl_bus_type);\n\t}\n\n\treturn ret;\n}\n\n \nint dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id)\n{\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct platform_device *port_pdev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&cdev->lock);\n\tport_pdev = __dfl_fpga_cdev_find_port(cdev, &port_id,\n\t\t\t\t\t      dfl_fpga_check_port_id);\n\tif (!port_pdev)\n\t\tgoto unlock_exit;\n\n\tif (!device_is_registered(&port_pdev->dev)) {\n\t\tret = -EBUSY;\n\t\tgoto put_dev_exit;\n\t}\n\n\tpdata = dev_get_platdata(&port_pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\tret = dfl_feature_dev_use_begin(pdata, true);\n\tmutex_unlock(&pdata->lock);\n\tif (ret)\n\t\tgoto put_dev_exit;\n\n\tplatform_device_del(port_pdev);\n\tcdev->released_port_num++;\nput_dev_exit:\n\tput_device(&port_pdev->dev);\nunlock_exit:\n\tmutex_unlock(&cdev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_cdev_release_port);\n\n \nint dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id)\n{\n\tstruct dfl_feature_platform_data *pdata;\n\tstruct platform_device *port_pdev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&cdev->lock);\n\tport_pdev = __dfl_fpga_cdev_find_port(cdev, &port_id,\n\t\t\t\t\t      dfl_fpga_check_port_id);\n\tif (!port_pdev)\n\t\tgoto unlock_exit;\n\n\tif (device_is_registered(&port_pdev->dev)) {\n\t\tret = -EBUSY;\n\t\tgoto put_dev_exit;\n\t}\n\n\tret = platform_device_add(port_pdev);\n\tif (ret)\n\t\tgoto put_dev_exit;\n\n\tpdata = dev_get_platdata(&port_pdev->dev);\n\n\tmutex_lock(&pdata->lock);\n\tdfl_feature_dev_use_end(pdata);\n\tmutex_unlock(&pdata->lock);\n\n\tcdev->released_port_num--;\nput_dev_exit:\n\tput_device(&port_pdev->dev);\nunlock_exit:\n\tmutex_unlock(&cdev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_cdev_assign_port);\n\nstatic void config_port_access_mode(struct device *fme_dev, int port_id,\n\t\t\t\t    bool is_vf)\n{\n\tvoid __iomem *base;\n\tu64 v;\n\n\tbase = dfl_get_feature_ioaddr_by_id(fme_dev, FME_FEATURE_ID_HEADER);\n\n\tv = readq(base + FME_HDR_PORT_OFST(port_id));\n\n\tv &= ~FME_PORT_OFST_ACC_CTRL;\n\tv |= FIELD_PREP(FME_PORT_OFST_ACC_CTRL,\n\t\t\tis_vf ? FME_PORT_OFST_ACC_VF : FME_PORT_OFST_ACC_PF);\n\n\twriteq(v, base + FME_HDR_PORT_OFST(port_id));\n}\n\n#define config_port_vf_mode(dev, id) config_port_access_mode(dev, id, true)\n#define config_port_pf_mode(dev, id) config_port_access_mode(dev, id, false)\n\n \nvoid dfl_fpga_cdev_config_ports_pf(struct dfl_fpga_cdev *cdev)\n{\n\tstruct dfl_feature_platform_data *pdata;\n\n\tmutex_lock(&cdev->lock);\n\tlist_for_each_entry(pdata, &cdev->port_dev_list, node) {\n\t\tif (device_is_registered(&pdata->dev->dev))\n\t\t\tcontinue;\n\n\t\tconfig_port_pf_mode(cdev->fme_dev, pdata->id);\n\t}\n\tmutex_unlock(&cdev->lock);\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_cdev_config_ports_pf);\n\n \nint dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vfs)\n{\n\tstruct dfl_feature_platform_data *pdata;\n\tint ret = 0;\n\n\tmutex_lock(&cdev->lock);\n\t \n\tif (cdev->released_port_num != num_vfs) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tlist_for_each_entry(pdata, &cdev->port_dev_list, node) {\n\t\tif (device_is_registered(&pdata->dev->dev))\n\t\t\tcontinue;\n\n\t\tconfig_port_vf_mode(cdev->fme_dev, pdata->id);\n\t}\ndone:\n\tmutex_unlock(&cdev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_cdev_config_ports_vf);\n\nstatic irqreturn_t dfl_irq_handler(int irq, void *arg)\n{\n\tstruct eventfd_ctx *trigger = arg;\n\n\teventfd_signal(trigger, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic int do_set_irq_trigger(struct dfl_feature *feature, unsigned int idx,\n\t\t\t      int fd)\n{\n\tstruct platform_device *pdev = feature->dev;\n\tstruct eventfd_ctx *trigger;\n\tint irq, ret;\n\n\tirq = feature->irq_ctx[idx].irq;\n\n\tif (feature->irq_ctx[idx].trigger) {\n\t\tfree_irq(irq, feature->irq_ctx[idx].trigger);\n\t\tkfree(feature->irq_ctx[idx].name);\n\t\teventfd_ctx_put(feature->irq_ctx[idx].trigger);\n\t\tfeature->irq_ctx[idx].trigger = NULL;\n\t}\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tfeature->irq_ctx[idx].name =\n\t\tkasprintf(GFP_KERNEL, \"fpga-irq[%u](%s-%x)\", idx,\n\t\t\t  dev_name(&pdev->dev), feature->id);\n\tif (!feature->irq_ctx[idx].name)\n\t\treturn -ENOMEM;\n\n\ttrigger = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(trigger)) {\n\t\tret = PTR_ERR(trigger);\n\t\tgoto free_name;\n\t}\n\n\tret = request_irq(irq, dfl_irq_handler, 0,\n\t\t\t  feature->irq_ctx[idx].name, trigger);\n\tif (!ret) {\n\t\tfeature->irq_ctx[idx].trigger = trigger;\n\t\treturn ret;\n\t}\n\n\teventfd_ctx_put(trigger);\nfree_name:\n\tkfree(feature->irq_ctx[idx].name);\n\n\treturn ret;\n}\n\n \nint dfl_fpga_set_irq_triggers(struct dfl_feature *feature, unsigned int start,\n\t\t\t      unsigned int count, int32_t *fds)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tif (unlikely(start + count < start))\n\t\treturn -EINVAL;\n\n\t \n\tif (start + count > feature->nr_irqs)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint fd = fds ? fds[i] : -1;\n\n\t\tret = do_set_irq_trigger(feature, start + i, fd);\n\t\tif (ret) {\n\t\t\twhile (i--)\n\t\t\t\tdo_set_irq_trigger(feature, start + i, -1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_fpga_set_irq_triggers);\n\n \nlong dfl_feature_ioctl_get_num_irqs(struct platform_device *pdev,\n\t\t\t\t    struct dfl_feature *feature,\n\t\t\t\t    unsigned long arg)\n{\n\treturn put_user(feature->nr_irqs, (__u32 __user *)arg);\n}\nEXPORT_SYMBOL_GPL(dfl_feature_ioctl_get_num_irqs);\n\n \nlong dfl_feature_ioctl_set_irq(struct platform_device *pdev,\n\t\t\t       struct dfl_feature *feature,\n\t\t\t       unsigned long arg)\n{\n\tstruct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dfl_fpga_irq_set hdr;\n\ts32 *fds;\n\tlong ret;\n\n\tif (!feature->nr_irqs)\n\t\treturn -ENOENT;\n\n\tif (copy_from_user(&hdr, (void __user *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (!hdr.count || (hdr.start + hdr.count > feature->nr_irqs) ||\n\t    (hdr.start + hdr.count < hdr.start))\n\t\treturn -EINVAL;\n\n\tfds = memdup_user((void __user *)(arg + sizeof(hdr)),\n\t\t\t  array_size(hdr.count, sizeof(s32)));\n\tif (IS_ERR(fds))\n\t\treturn PTR_ERR(fds);\n\n\tmutex_lock(&pdata->lock);\n\tret = dfl_fpga_set_irq_triggers(feature, hdr.start, hdr.count, fds);\n\tmutex_unlock(&pdata->lock);\n\n\tkfree(fds);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dfl_feature_ioctl_set_irq);\n\nstatic void __exit dfl_fpga_exit(void)\n{\n\tdfl_chardev_uinit();\n\tdfl_ids_destroy();\n\tbus_unregister(&dfl_bus_type);\n}\n\nmodule_init(dfl_fpga_init);\nmodule_exit(dfl_fpga_exit);\n\nMODULE_DESCRIPTION(\"FPGA Device Feature List (DFL) Support\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}