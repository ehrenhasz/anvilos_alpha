{
  "module_name": "zynq-fpga.c",
  "hash_id": "6a6fe81184bfa006c53fa799854922e9b37350bde954543f5e589196e0f2c395",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/zynq-fpga.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/string.h>\n#include <linux/scatterlist.h>\n\n \n\n \n#define SLCR_FPGA_RST_CTRL_OFFSET\t0x240\n \n#define SLCR_LVL_SHFTR_EN_OFFSET\t0x900\n\n \n\n \n#define CTRL_OFFSET\t\t\t0x00\n \n#define LOCK_OFFSET\t\t\t0x04\n \n#define INT_STS_OFFSET\t\t\t0x0c\n \n#define INT_MASK_OFFSET\t\t\t0x10\n \n#define STATUS_OFFSET\t\t\t0x14\n \n#define DMA_SRC_ADDR_OFFSET\t\t0x18\n \n#define DMA_DST_ADDR_OFFSET\t\t0x1c\n \n#define DMA_SRC_LEN_OFFSET\t\t0x20\n \n#define DMA_DEST_LEN_OFFSET\t\t0x24\n \n#define UNLOCK_OFFSET\t\t\t0x34\n \n#define MCTRL_OFFSET\t\t\t0x80\n\n \n\n \n#define CTRL_PCFG_PROG_B_MASK\t\tBIT(30)\n \n#define CTRL_PCAP_PR_MASK\t\tBIT(27)\n \n#define CTRL_PCAP_MODE_MASK\t\tBIT(26)\n \n#define CTRL_PCAP_RATE_EN_MASK\t\tBIT(25)\n \n#define CTRL_SEC_EN_MASK\t\tBIT(7)\n\n \n \n#define MCTRL_PCAP_LPBK_MASK\t\tBIT(4)\n\n \n\n \n#define STATUS_DMA_Q_F\t\t\tBIT(31)\n#define STATUS_DMA_Q_E\t\t\tBIT(30)\n#define STATUS_PCFG_INIT_MASK\t\tBIT(4)\n\n \n \n#define IXR_DMA_DONE_MASK\t\tBIT(13)\n \n#define IXR_D_P_DONE_MASK\t\tBIT(12)\n  \n#define IXR_PCFG_DONE_MASK\t\tBIT(2)\n#define IXR_ERROR_FLAGS_MASK\t\t0x00F0C860\n#define IXR_ALL_MASK\t\t\t0xF8F7F87F\n\n \n\n \n#define DMA_INVALID_ADDRESS\t\tGENMASK(31, 0)\n \n#define UNLOCK_MASK\t\t\t0x757bdf0d\n \n#define INIT_POLL_TIMEOUT\t\t2500000\n \n#define INIT_POLL_DELAY\t\t\t20\n \n#define DMA_SRC_LAST_TRANSFER\t\t1\n \n#define DMA_TIMEOUT_MS\t\t\t5000\n\n \n \n#define LVL_SHFTR_DISABLE_ALL_MASK\t0x0\n \n#define LVL_SHFTR_ENABLE_PS_TO_PL\t0xa\n \n#define LVL_SHFTR_ENABLE_PL_TO_PS\t0xf\n \n#define FPGA_RST_ALL_MASK\t\t0xf\n \n#define FPGA_RST_NONE_MASK\t\t0x0\n\nstruct zynq_fpga_priv {\n\tint irq;\n\tstruct clk *clk;\n\n\tvoid __iomem *io_base;\n\tstruct regmap *slcr;\n\n\tspinlock_t dma_lock;\n\tunsigned int dma_elm;\n\tunsigned int dma_nelms;\n\tstruct scatterlist *cur_sg;\n\n\tstruct completion dma_done;\n};\n\nstatic inline void zynq_fpga_write(struct zynq_fpga_priv *priv, u32 offset,\n\t\t\t\t   u32 val)\n{\n\twritel(val, priv->io_base + offset);\n}\n\nstatic inline u32 zynq_fpga_read(const struct zynq_fpga_priv *priv,\n\t\t\t\t u32 offset)\n{\n\treturn readl(priv->io_base + offset);\n}\n\n#define zynq_fpga_poll_timeout(priv, addr, val, cond, sleep_us, timeout_us) \\\n\treadl_poll_timeout(priv->io_base + addr, val, cond, sleep_us, \\\n\t\t\t   timeout_us)\n\n \nstatic inline void zynq_fpga_set_irq(struct zynq_fpga_priv *priv, u32 enable)\n{\n\tzynq_fpga_write(priv, INT_MASK_OFFSET, ~enable);\n}\n\n \nstatic void zynq_step_dma(struct zynq_fpga_priv *priv)\n{\n\tu32 addr;\n\tu32 len;\n\tbool first;\n\n\tfirst = priv->dma_elm == 0;\n\twhile (priv->cur_sg) {\n\t\t \n\t\tif (zynq_fpga_read(priv, STATUS_OFFSET) & STATUS_DMA_Q_F)\n\t\t\tbreak;\n\n\t\taddr = sg_dma_address(priv->cur_sg);\n\t\tlen = sg_dma_len(priv->cur_sg);\n\t\tif (priv->dma_elm + 1 == priv->dma_nelms) {\n\t\t\t \n\t\t\taddr |= DMA_SRC_LAST_TRANSFER;\n\t\t\tpriv->cur_sg = NULL;\n\t\t} else {\n\t\t\tpriv->cur_sg = sg_next(priv->cur_sg);\n\t\t\tpriv->dma_elm++;\n\t\t}\n\n\t\tzynq_fpga_write(priv, DMA_SRC_ADDR_OFFSET, addr);\n\t\tzynq_fpga_write(priv, DMA_DST_ADDR_OFFSET, DMA_INVALID_ADDRESS);\n\t\tzynq_fpga_write(priv, DMA_SRC_LEN_OFFSET, len / 4);\n\t\tzynq_fpga_write(priv, DMA_DEST_LEN_OFFSET, 0);\n\t}\n\n\t \n\tif (first && priv->cur_sg) {\n\t\tzynq_fpga_set_irq(priv,\n\t\t\t\t  IXR_DMA_DONE_MASK | IXR_ERROR_FLAGS_MASK);\n\t} else if (!priv->cur_sg) {\n\t\t \n\t\tzynq_fpga_set_irq(priv,\n\t\t\t\t  IXR_D_P_DONE_MASK | IXR_ERROR_FLAGS_MASK);\n\t}\n}\n\nstatic irqreturn_t zynq_fpga_isr(int irq, void *data)\n{\n\tstruct zynq_fpga_priv *priv = data;\n\tu32 intr_status;\n\n\t \n\tspin_lock(&priv->dma_lock);\n\tintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\n\tif (!(intr_status & IXR_ERROR_FLAGS_MASK) &&\n\t    (intr_status & IXR_DMA_DONE_MASK) && priv->cur_sg) {\n\t\tzynq_fpga_write(priv, INT_STS_OFFSET, IXR_DMA_DONE_MASK);\n\t\tzynq_step_dma(priv);\n\t\tspin_unlock(&priv->dma_lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\tspin_unlock(&priv->dma_lock);\n\n\tzynq_fpga_set_irq(priv, 0);\n\tcomplete(&priv->dma_done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic bool zynq_fpga_has_sync(const u8 *buf, size_t count)\n{\n\tfor (; count >= 4; buf += 4, count -= 4)\n\t\tif (buf[0] == 0x66 && buf[1] == 0x55 && buf[2] == 0x99 &&\n\t\t    buf[3] == 0xaa)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int zynq_fpga_ops_write_init(struct fpga_manager *mgr,\n\t\t\t\t    struct fpga_image_info *info,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct zynq_fpga_priv *priv;\n\tu32 ctrl, status;\n\tint err;\n\n\tpriv = mgr->priv;\n\n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (info->flags & FPGA_MGR_ENCRYPTED_BITSTREAM) {\n\t\tctrl = zynq_fpga_read(priv, CTRL_OFFSET);\n\t\tif (!(ctrl & CTRL_SEC_EN_MASK)) {\n\t\t\tdev_err(&mgr->dev,\n\t\t\t\t\"System not secure, can't use encrypted bitstreams\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\tif (!zynq_fpga_has_sync(buf, count)) {\n\t\t\tdev_err(&mgr->dev,\n\t\t\t\t\"Invalid bitstream, could not find a sync word. Bitstream must be a byte swapped .bin file\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t \n\t\tregmap_write(priv->slcr, SLCR_FPGA_RST_CTRL_OFFSET,\n\t\t\t     FPGA_RST_ALL_MASK);\n\n\t\t \n\t\tregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\n\t\t\t     LVL_SHFTR_DISABLE_ALL_MASK);\n\t\t \n\t\tregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\n\t\t\t     LVL_SHFTR_ENABLE_PS_TO_PL);\n\n\t\t \n\t\tctrl = zynq_fpga_read(priv, CTRL_OFFSET);\n\t\tctrl |= CTRL_PCFG_PROG_B_MASK;\n\n\t\tzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\n\n\t\terr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\n\t\t\t\t\t     status & STATUS_PCFG_INIT_MASK,\n\t\t\t\t\t     INIT_POLL_DELAY,\n\t\t\t\t\t     INIT_POLL_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->dev, \"Timeout waiting for PCFG_INIT\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tctrl = zynq_fpga_read(priv, CTRL_OFFSET);\n\t\tctrl &= ~CTRL_PCFG_PROG_B_MASK;\n\n\t\tzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\n\n\t\terr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\n\t\t\t\t\t     !(status & STATUS_PCFG_INIT_MASK),\n\t\t\t\t\t     INIT_POLL_DELAY,\n\t\t\t\t\t     INIT_POLL_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->dev, \"Timeout waiting for !PCFG_INIT\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tctrl = zynq_fpga_read(priv, CTRL_OFFSET);\n\t\tctrl |= CTRL_PCFG_PROG_B_MASK;\n\n\t\tzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\n\n\t\terr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\n\t\t\t\t\t     status & STATUS_PCFG_INIT_MASK,\n\t\t\t\t\t     INIT_POLL_DELAY,\n\t\t\t\t\t     INIT_POLL_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->dev, \"Timeout waiting for PCFG_INIT\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tctrl = zynq_fpga_read(priv, CTRL_OFFSET);\n\tif (info->flags & FPGA_MGR_ENCRYPTED_BITSTREAM)\n\t\tzynq_fpga_write(priv, CTRL_OFFSET,\n\t\t\t\t(CTRL_PCAP_PR_MASK | CTRL_PCAP_MODE_MASK\n\t\t\t\t | CTRL_PCAP_RATE_EN_MASK | ctrl));\n\telse\n\t\tzynq_fpga_write(priv, CTRL_OFFSET,\n\t\t\t\t(CTRL_PCAP_PR_MASK | CTRL_PCAP_MODE_MASK\n\t\t\t\t | ctrl));\n\n\n\t \n\tstatus = zynq_fpga_read(priv, STATUS_OFFSET);\n\tif ((status & STATUS_DMA_Q_F) ||\n\t    (status & STATUS_DMA_Q_E) != STATUS_DMA_Q_E) {\n\t\tdev_err(&mgr->dev, \"DMA command queue not right\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out_err;\n\t}\n\n\t \n\tctrl = zynq_fpga_read(priv, MCTRL_OFFSET);\n\tzynq_fpga_write(priv, MCTRL_OFFSET, (~MCTRL_PCAP_LPBK_MASK & ctrl));\n\n\tclk_disable(priv->clk);\n\n\treturn 0;\n\nout_err:\n\tclk_disable(priv->clk);\n\n\treturn err;\n}\n\nstatic int zynq_fpga_ops_write(struct fpga_manager *mgr, struct sg_table *sgt)\n{\n\tstruct zynq_fpga_priv *priv;\n\tconst char *why;\n\tint err;\n\tu32 intr_status;\n\tunsigned long timeout;\n\tunsigned long flags;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tpriv = mgr->priv;\n\n\t \n\tfor_each_sg(sgt->sgl, sg, sgt->nents, i) {\n\t\tif ((sg->offset % 8) || (sg->length % 4)) {\n\t\t\tdev_err(&mgr->dev,\n\t\t\t    \"Invalid bitstream, chunks must be aligned\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpriv->dma_nelms =\n\t    dma_map_sg(mgr->dev.parent, sgt->sgl, sgt->nents, DMA_TO_DEVICE);\n\tif (priv->dma_nelms == 0) {\n\t\tdev_err(&mgr->dev, \"Unable to DMA map (TO_DEVICE)\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\tgoto out_free;\n\n\tzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\n\treinit_completion(&priv->dma_done);\n\n\t \n\tspin_lock_irqsave(&priv->dma_lock, flags);\n\tpriv->dma_elm = 0;\n\tpriv->cur_sg = sgt->sgl;\n\tzynq_step_dma(priv);\n\tspin_unlock_irqrestore(&priv->dma_lock, flags);\n\n\ttimeout = wait_for_completion_timeout(&priv->dma_done,\n\t\t\t\t\t      msecs_to_jiffies(DMA_TIMEOUT_MS));\n\n\tspin_lock_irqsave(&priv->dma_lock, flags);\n\tzynq_fpga_set_irq(priv, 0);\n\tpriv->cur_sg = NULL;\n\tspin_unlock_irqrestore(&priv->dma_lock, flags);\n\n\tintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\n\tzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\n\n\t \n\n\tif (intr_status & IXR_ERROR_FLAGS_MASK) {\n\t\twhy = \"DMA reported error\";\n\t\terr = -EIO;\n\t\tgoto out_report;\n\t}\n\n\tif (priv->cur_sg ||\n\t    !((intr_status & IXR_D_P_DONE_MASK) == IXR_D_P_DONE_MASK)) {\n\t\tif (timeout == 0)\n\t\t\twhy = \"DMA timed out\";\n\t\telse\n\t\t\twhy = \"DMA did not complete\";\n\t\terr = -EIO;\n\t\tgoto out_report;\n\t}\n\n\terr = 0;\n\tgoto out_clk;\n\nout_report:\n\tdev_err(&mgr->dev,\n\t\t\"%s: INT_STS:0x%x CTRL:0x%x LOCK:0x%x INT_MASK:0x%x STATUS:0x%x MCTRL:0x%x\\n\",\n\t\twhy,\n\t\tintr_status,\n\t\tzynq_fpga_read(priv, CTRL_OFFSET),\n\t\tzynq_fpga_read(priv, LOCK_OFFSET),\n\t\tzynq_fpga_read(priv, INT_MASK_OFFSET),\n\t\tzynq_fpga_read(priv, STATUS_OFFSET),\n\t\tzynq_fpga_read(priv, MCTRL_OFFSET));\n\nout_clk:\n\tclk_disable(priv->clk);\n\nout_free:\n\tdma_unmap_sg(mgr->dev.parent, sgt->sgl, sgt->nents, DMA_TO_DEVICE);\n\treturn err;\n}\n\nstatic int zynq_fpga_ops_write_complete(struct fpga_manager *mgr,\n\t\t\t\t\tstruct fpga_image_info *info)\n{\n\tstruct zynq_fpga_priv *priv = mgr->priv;\n\tint err;\n\tu32 intr_status;\n\n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\terr = zynq_fpga_poll_timeout(priv, INT_STS_OFFSET, intr_status,\n\t\t\t\t     intr_status & IXR_PCFG_DONE_MASK,\n\t\t\t\t     INIT_POLL_DELAY,\n\t\t\t\t     INIT_POLL_TIMEOUT);\n\n\t \n\tzynq_fpga_write(priv, CTRL_OFFSET,\n\t\t\tzynq_fpga_read(priv, CTRL_OFFSET) & ~CTRL_PCAP_PR_MASK);\n\n\tclk_disable(priv->clk);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\n\t\t \n\t\tregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\n\t\t\t     LVL_SHFTR_ENABLE_PL_TO_PS);\n\n\t\t \n\t\tregmap_write(priv->slcr, SLCR_FPGA_RST_CTRL_OFFSET,\n\t\t\t     FPGA_RST_NONE_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic enum fpga_mgr_states zynq_fpga_ops_state(struct fpga_manager *mgr)\n{\n\tint err;\n\tu32 intr_status;\n\tstruct zynq_fpga_priv *priv;\n\n\tpriv = mgr->priv;\n\n\terr = clk_enable(priv->clk);\n\tif (err)\n\t\treturn FPGA_MGR_STATE_UNKNOWN;\n\n\tintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\n\tclk_disable(priv->clk);\n\n\tif (intr_status & IXR_PCFG_DONE_MASK)\n\t\treturn FPGA_MGR_STATE_OPERATING;\n\n\treturn FPGA_MGR_STATE_UNKNOWN;\n}\n\nstatic const struct fpga_manager_ops zynq_fpga_ops = {\n\t.initial_header_size = 128,\n\t.state = zynq_fpga_ops_state,\n\t.write_init = zynq_fpga_ops_write_init,\n\t.write_sg = zynq_fpga_ops_write,\n\t.write_complete = zynq_fpga_ops_write_complete,\n};\n\nstatic int zynq_fpga_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct zynq_fpga_priv *priv;\n\tstruct fpga_manager *mgr;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&priv->dma_lock);\n\n\tpriv->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->io_base))\n\t\treturn PTR_ERR(priv->io_base);\n\n\tpriv->slcr = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\"syscon\");\n\tif (IS_ERR(priv->slcr)) {\n\t\tdev_err(dev, \"unable to get zynq-slcr regmap\\n\");\n\t\treturn PTR_ERR(priv->slcr);\n\t}\n\n\tinit_completion(&priv->dma_done);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tpriv->clk = devm_clk_get(dev, \"ref_clk\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"input clock not found\\n\");\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tzynq_fpga_write(priv, UNLOCK_OFFSET, UNLOCK_MASK);\n\n\tzynq_fpga_set_irq(priv, 0);\n\tzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\n\terr = devm_request_irq(dev, priv->irq, zynq_fpga_isr, 0, dev_name(dev),\n\t\t\t       priv);\n\tif (err) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn err;\n\t}\n\n\tclk_disable(priv->clk);\n\n\tmgr = fpga_mgr_register(dev, \"Xilinx Zynq FPGA Manager\",\n\t\t\t\t&zynq_fpga_ops, priv);\n\tif (IS_ERR(mgr)) {\n\t\tdev_err(dev, \"unable to register FPGA manager\\n\");\n\t\tclk_unprepare(priv->clk);\n\t\treturn PTR_ERR(mgr);\n\t}\n\n\tplatform_set_drvdata(pdev, mgr);\n\n\treturn 0;\n}\n\nstatic int zynq_fpga_remove(struct platform_device *pdev)\n{\n\tstruct zynq_fpga_priv *priv;\n\tstruct fpga_manager *mgr;\n\n\tmgr = platform_get_drvdata(pdev);\n\tpriv = mgr->priv;\n\n\tfpga_mgr_unregister(mgr);\n\n\tclk_unprepare(priv->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id zynq_fpga_of_match[] = {\n\t{ .compatible = \"xlnx,zynq-devcfg-1.0\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, zynq_fpga_of_match);\n#endif\n\nstatic struct platform_driver zynq_fpga_driver = {\n\t.probe = zynq_fpga_probe,\n\t.remove = zynq_fpga_remove,\n\t.driver = {\n\t\t.name = \"zynq_fpga_manager\",\n\t\t.of_match_table = of_match_ptr(zynq_fpga_of_match),\n\t},\n};\n\nmodule_platform_driver(zynq_fpga_driver);\n\nMODULE_AUTHOR(\"Moritz Fischer <moritz.fischer@ettus.com>\");\nMODULE_AUTHOR(\"Michal Simek <michal.simek@xilinx.com>\");\nMODULE_DESCRIPTION(\"Xilinx Zynq FPGA Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}