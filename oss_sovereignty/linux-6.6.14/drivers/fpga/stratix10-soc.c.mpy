{
  "module_name": "stratix10-soc.c",
  "hash_id": "0014ebd656fb5b6ad1e4637b7aa842d3d3f46b50defa391076f526c555aa2678",
  "original_prompt": "Ingested from linux-6.6.14/drivers/fpga/stratix10-soc.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/fpga/fpga-mgr.h>\n#include <linux/firmware/intel/stratix10-svc-client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n \n#define NUM_SVC_BUFS\t4\n#define SVC_BUF_SIZE\tSZ_512K\n\n \n#define SVC_BUF_LOCK\t0\n\n#define S10_BUFFER_TIMEOUT (msecs_to_jiffies(SVC_RECONFIG_BUFFER_TIMEOUT_MS))\n#define S10_RECONFIG_TIMEOUT (msecs_to_jiffies(SVC_RECONFIG_REQUEST_TIMEOUT_MS))\n\n \nstruct s10_svc_buf {\n\tchar *buf;\n\tunsigned long lock;\n};\n\nstruct s10_priv {\n\tstruct stratix10_svc_chan *chan;\n\tstruct stratix10_svc_client client;\n\tstruct completion status_return_completion;\n\tstruct s10_svc_buf svc_bufs[NUM_SVC_BUFS];\n\tunsigned long status;\n};\n\nstatic int s10_svc_send_msg(struct s10_priv *priv,\n\t\t\t    enum stratix10_svc_command_code command,\n\t\t\t    void *payload, u32 payload_length)\n{\n\tstruct stratix10_svc_chan *chan = priv->chan;\n\tstruct device *dev = priv->client.dev;\n\tstruct stratix10_svc_client_msg msg;\n\tint ret;\n\n\tdev_dbg(dev, \"%s cmd=%d payload=%p length=%d\\n\",\n\t\t__func__, command, payload, payload_length);\n\n\tmsg.command = command;\n\tmsg.payload = payload;\n\tmsg.payload_length = payload_length;\n\n\tret = stratix10_svc_send(chan, &msg);\n\tdev_dbg(dev, \"stratix10_svc_send returned status %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic bool s10_free_buffers(struct fpga_manager *mgr)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tuint num_free = 0;\n\tuint i;\n\n\tfor (i = 0; i < NUM_SVC_BUFS; i++) {\n\t\tif (!priv->svc_bufs[i].buf) {\n\t\t\tnum_free++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!test_and_set_bit_lock(SVC_BUF_LOCK,\n\t\t\t\t\t   &priv->svc_bufs[i].lock)) {\n\t\t\tstratix10_svc_free_memory(priv->chan,\n\t\t\t\t\t\t  priv->svc_bufs[i].buf);\n\t\t\tpriv->svc_bufs[i].buf = NULL;\n\t\t\tnum_free++;\n\t\t}\n\t}\n\n\treturn num_free == NUM_SVC_BUFS;\n}\n\n \nstatic uint s10_free_buffer_count(struct fpga_manager *mgr)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tuint num_free = 0;\n\tuint i;\n\n\tfor (i = 0; i < NUM_SVC_BUFS; i++)\n\t\tif (!priv->svc_bufs[i].buf)\n\t\t\tnum_free++;\n\n\treturn num_free;\n}\n\n \nstatic void s10_unlock_bufs(struct s10_priv *priv, void *kaddr)\n{\n\tuint i;\n\n\tif (!kaddr)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_SVC_BUFS; i++)\n\t\tif (priv->svc_bufs[i].buf == kaddr) {\n\t\t\tclear_bit_unlock(SVC_BUF_LOCK,\n\t\t\t\t\t &priv->svc_bufs[i].lock);\n\t\t\treturn;\n\t\t}\n\n\tWARN(1, \"Unknown buffer returned from service layer %p\\n\", kaddr);\n}\n\n \nstatic void s10_receive_callback(struct stratix10_svc_client *client,\n\t\t\t\t struct stratix10_svc_cb_data *data)\n{\n\tstruct s10_priv *priv = client->priv;\n\tu32 status;\n\tint i;\n\n\tWARN_ONCE(!data, \"%s: stratix10_svc_rc_data = NULL\", __func__);\n\n\tstatus = data->status;\n\n\t \n\tfor (i = 0; i <= SVC_STATUS_ERROR; i++)\n\t\tif (status & (1 << i))\n\t\t\tset_bit(i, &priv->status);\n\n\tif (status & BIT(SVC_STATUS_BUFFER_DONE)) {\n\t\ts10_unlock_bufs(priv, data->kaddr1);\n\t\ts10_unlock_bufs(priv, data->kaddr2);\n\t\ts10_unlock_bufs(priv, data->kaddr3);\n\t}\n\n\tcomplete(&priv->status_return_completion);\n}\n\n \nstatic int s10_ops_write_init(struct fpga_manager *mgr,\n\t\t\t      struct fpga_image_info *info,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tstruct device *dev = priv->client.dev;\n\tstruct stratix10_svc_command_config_type ctype;\n\tchar *kbuf;\n\tuint i;\n\tint ret;\n\n\tctype.flags = 0;\n\tif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\n\t\tdev_dbg(dev, \"Requesting partial reconfiguration.\\n\");\n\t\tctype.flags |= BIT(COMMAND_RECONFIG_FLAG_PARTIAL);\n\t} else {\n\t\tdev_dbg(dev, \"Requesting full reconfiguration.\\n\");\n\t}\n\n\treinit_completion(&priv->status_return_completion);\n\tret = s10_svc_send_msg(priv, COMMAND_RECONFIG,\n\t\t\t       &ctype, sizeof(ctype));\n\tif (ret < 0)\n\t\tgoto init_done;\n\n\tret = wait_for_completion_timeout(\n\t\t&priv->status_return_completion, S10_RECONFIG_TIMEOUT);\n\tif (!ret) {\n\t\tdev_err(dev, \"timeout waiting for RECONFIG_REQUEST\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto init_done;\n\t}\n\n\tret = 0;\n\tif (!test_and_clear_bit(SVC_STATUS_OK, &priv->status)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto init_done;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_SVC_BUFS; i++) {\n\t\tkbuf = stratix10_svc_allocate_memory(priv->chan, SVC_BUF_SIZE);\n\t\tif (IS_ERR(kbuf)) {\n\t\t\ts10_free_buffers(mgr);\n\t\t\tret = PTR_ERR(kbuf);\n\t\t\tgoto init_done;\n\t\t}\n\n\t\tpriv->svc_bufs[i].buf = kbuf;\n\t\tpriv->svc_bufs[i].lock = 0;\n\t}\n\ninit_done:\n\tstratix10_svc_done(priv->chan);\n\treturn ret;\n}\n\n \nstatic int s10_send_buf(struct fpga_manager *mgr, const char *buf, size_t count)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tstruct device *dev = priv->client.dev;\n\tvoid *svc_buf;\n\tsize_t xfer_sz;\n\tint ret;\n\tuint i;\n\n\t \n\tfor (i = 0; i < NUM_SVC_BUFS; i++)\n\t\tif (!test_and_set_bit_lock(SVC_BUF_LOCK,\n\t\t\t\t\t   &priv->svc_bufs[i].lock))\n\t\t\tbreak;\n\n\tif (i == NUM_SVC_BUFS)\n\t\treturn -ENOBUFS;\n\n\txfer_sz = count < SVC_BUF_SIZE ? count : SVC_BUF_SIZE;\n\n\tsvc_buf = priv->svc_bufs[i].buf;\n\tmemcpy(svc_buf, buf, xfer_sz);\n\tret = s10_svc_send_msg(priv, COMMAND_RECONFIG_DATA_SUBMIT,\n\t\t\t       svc_buf, xfer_sz);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"Error while sending data to service layer (%d)\", ret);\n\t\tclear_bit_unlock(SVC_BUF_LOCK, &priv->svc_bufs[i].lock);\n\t\treturn ret;\n\t}\n\n\treturn xfer_sz;\n}\n\n \nstatic int s10_ops_write(struct fpga_manager *mgr, const char *buf,\n\t\t\t size_t count)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tstruct device *dev = priv->client.dev;\n\tlong wait_status;\n\tint sent = 0;\n\tint ret = 0;\n\n\t \n\twhile (count > 0 || s10_free_buffer_count(mgr) != NUM_SVC_BUFS) {\n\t\treinit_completion(&priv->status_return_completion);\n\n\t\tif (count > 0) {\n\t\t\tsent = s10_send_buf(mgr, buf, count);\n\t\t\tif (sent < 0)\n\t\t\t\tcontinue;\n\n\t\t\tcount -= sent;\n\t\t\tbuf += sent;\n\t\t} else {\n\t\t\tif (s10_free_buffers(mgr))\n\t\t\t\treturn 0;\n\n\t\t\tret = s10_svc_send_msg(\n\t\t\t\tpriv, COMMAND_RECONFIG_DATA_CLAIM,\n\t\t\t\tNULL, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\twait_status = 1;  \n\t\tif (!priv->status)\n\t\t\twait_status = wait_for_completion_timeout(\n\t\t\t\t&priv->status_return_completion,\n\t\t\t\tS10_BUFFER_TIMEOUT);\n\n\t\tif (test_and_clear_bit(SVC_STATUS_BUFFER_DONE, &priv->status) ||\n\t\t    test_and_clear_bit(SVC_STATUS_BUFFER_SUBMITTED,\n\t\t\t\t       &priv->status)) {\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(SVC_STATUS_ERROR, &priv->status)) {\n\t\t\tdev_err(dev, \"ERROR - giving up - SVC_STATUS_ERROR\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wait_status) {\n\t\t\tdev_err(dev, \"timeout waiting for svc layer buffers\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s10_free_buffers(mgr))\n\t\tdev_err(dev, \"%s not all buffers were freed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int s10_ops_write_complete(struct fpga_manager *mgr,\n\t\t\t\t  struct fpga_image_info *info)\n{\n\tstruct s10_priv *priv = mgr->priv;\n\tstruct device *dev = priv->client.dev;\n\tunsigned long timeout;\n\tint ret;\n\n\ttimeout = usecs_to_jiffies(info->config_complete_timeout_us);\n\n\tdo {\n\t\treinit_completion(&priv->status_return_completion);\n\n\t\tret = s10_svc_send_msg(priv, COMMAND_RECONFIG_STATUS, NULL, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = wait_for_completion_timeout(\n\t\t\t&priv->status_return_completion, timeout);\n\t\tif (!ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"timeout waiting for RECONFIG_COMPLETED\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\ttimeout = ret;\n\t\tret = 0;\n\n\t\tif (test_and_clear_bit(SVC_STATUS_COMPLETED, &priv->status))\n\t\t\tbreak;\n\n\t\tif (test_and_clear_bit(SVC_STATUS_ERROR, &priv->status)) {\n\t\t\tdev_err(dev, \"ERROR - giving up - SVC_STATUS_ERROR\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tstratix10_svc_done(priv->chan);\n\n\treturn ret;\n}\n\nstatic const struct fpga_manager_ops s10_ops = {\n\t.write_init = s10_ops_write_init,\n\t.write = s10_ops_write,\n\t.write_complete = s10_ops_write_complete,\n};\n\nstatic int s10_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct s10_priv *priv;\n\tstruct fpga_manager *mgr;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client.dev = dev;\n\tpriv->client.receive_cb = s10_receive_callback;\n\tpriv->client.priv = priv;\n\n\tpriv->chan = stratix10_svc_request_channel_byname(&priv->client,\n\t\t\t\t\t\t\t  SVC_CLIENT_FPGA);\n\tif (IS_ERR(priv->chan)) {\n\t\tdev_err(dev, \"couldn't get service channel (%s)\\n\",\n\t\t\tSVC_CLIENT_FPGA);\n\t\treturn PTR_ERR(priv->chan);\n\t}\n\n\tinit_completion(&priv->status_return_completion);\n\n\tmgr = fpga_mgr_register(dev, \"Stratix10 SOC FPGA Manager\",\n\t\t\t\t&s10_ops, priv);\n\tif (IS_ERR(mgr)) {\n\t\tdev_err(dev, \"unable to register FPGA manager\\n\");\n\t\tret = PTR_ERR(mgr);\n\t\tgoto probe_err;\n\t}\n\n\tplatform_set_drvdata(pdev, mgr);\n\treturn 0;\n\nprobe_err:\n\tstratix10_svc_free_channel(priv->chan);\n\treturn ret;\n}\n\nstatic int s10_remove(struct platform_device *pdev)\n{\n\tstruct fpga_manager *mgr = platform_get_drvdata(pdev);\n\tstruct s10_priv *priv = mgr->priv;\n\n\tfpga_mgr_unregister(mgr);\n\tstratix10_svc_free_channel(priv->chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id s10_of_match[] = {\n\t{.compatible = \"intel,stratix10-soc-fpga-mgr\"},\n\t{.compatible = \"intel,agilex-soc-fpga-mgr\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, s10_of_match);\n\nstatic struct platform_driver s10_driver = {\n\t.probe = s10_probe,\n\t.remove = s10_remove,\n\t.driver = {\n\t\t.name\t= \"Stratix10 SoC FPGA manager\",\n\t\t.of_match_table = of_match_ptr(s10_of_match),\n\t},\n};\n\nstatic int __init s10_init(void)\n{\n\tstruct device_node *fw_np;\n\tstruct device_node *np;\n\tint ret;\n\n\tfw_np = of_find_node_by_name(NULL, \"svc\");\n\tif (!fw_np)\n\t\treturn -ENODEV;\n\n\tof_node_get(fw_np);\n\tnp = of_find_matching_node(fw_np, s10_of_match);\n\tif (!np) {\n\t\tof_node_put(fw_np);\n\t\treturn -ENODEV;\n\t}\n\n\tof_node_put(np);\n\tret = of_platform_populate(fw_np, s10_of_match, NULL, NULL);\n\tof_node_put(fw_np);\n\tif (ret)\n\t\treturn ret;\n\n\treturn platform_driver_register(&s10_driver);\n}\n\nstatic void __exit s10_exit(void)\n{\n\treturn platform_driver_unregister(&s10_driver);\n}\n\nmodule_init(s10_init);\nmodule_exit(s10_exit);\n\nMODULE_AUTHOR(\"Alan Tull <atull@kernel.org>\");\nMODULE_DESCRIPTION(\"Intel Stratix 10 SOC FPGA Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}