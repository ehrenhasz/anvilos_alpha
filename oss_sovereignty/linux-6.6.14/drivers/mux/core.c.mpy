{
  "module_name": "core.c",
  "hash_id": "ec4d3c2ec8097a6177afa11bb54e8ae701b51b53a9d08ba9827a75d9d98424b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mux/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"mux-core: \" fmt\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mux/consumer.h>\n#include <linux/mux/driver.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n \n#define MUX_CACHE_UNKNOWN MUX_IDLE_AS_IS\n\n \nstruct mux_state {\n\tstruct mux_control *mux;\n\tunsigned int state;\n};\n\nstatic struct class mux_class = {\n\t.name = \"mux\",\n};\n\nstatic DEFINE_IDA(mux_ida);\n\nstatic int __init mux_init(void)\n{\n\tida_init(&mux_ida);\n\treturn class_register(&mux_class);\n}\n\nstatic void __exit mux_exit(void)\n{\n\tclass_unregister(&mux_class);\n\tida_destroy(&mux_ida);\n}\n\nstatic void mux_chip_release(struct device *dev)\n{\n\tstruct mux_chip *mux_chip = to_mux_chip(dev);\n\n\tida_simple_remove(&mux_ida, mux_chip->id);\n\tkfree(mux_chip);\n}\n\nstatic const struct device_type mux_type = {\n\t.name = \"mux-chip\",\n\t.release = mux_chip_release,\n};\n\n \nstruct mux_chip *mux_chip_alloc(struct device *dev,\n\t\t\t\tunsigned int controllers, size_t sizeof_priv)\n{\n\tstruct mux_chip *mux_chip;\n\tint i;\n\n\tif (WARN_ON(!dev || !controllers))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmux_chip = kzalloc(sizeof(*mux_chip) +\n\t\t\t   controllers * sizeof(*mux_chip->mux) +\n\t\t\t   sizeof_priv, GFP_KERNEL);\n\tif (!mux_chip)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux_chip->mux = (struct mux_control *)(mux_chip + 1);\n\tmux_chip->dev.class = &mux_class;\n\tmux_chip->dev.type = &mux_type;\n\tmux_chip->dev.parent = dev;\n\tmux_chip->dev.of_node = dev->of_node;\n\tdev_set_drvdata(&mux_chip->dev, mux_chip);\n\n\tmux_chip->id = ida_simple_get(&mux_ida, 0, 0, GFP_KERNEL);\n\tif (mux_chip->id < 0) {\n\t\tint err = mux_chip->id;\n\n\t\tpr_err(\"muxchipX failed to get a device id\\n\");\n\t\tkfree(mux_chip);\n\t\treturn ERR_PTR(err);\n\t}\n\tdev_set_name(&mux_chip->dev, \"muxchip%d\", mux_chip->id);\n\n\tmux_chip->controllers = controllers;\n\tfor (i = 0; i < controllers; ++i) {\n\t\tstruct mux_control *mux = &mux_chip->mux[i];\n\n\t\tmux->chip = mux_chip;\n\t\tsema_init(&mux->lock, 1);\n\t\tmux->cached_state = MUX_CACHE_UNKNOWN;\n\t\tmux->idle_state = MUX_IDLE_AS_IS;\n\t\tmux->last_change = ktime_get();\n\t}\n\n\tdevice_initialize(&mux_chip->dev);\n\n\treturn mux_chip;\n}\nEXPORT_SYMBOL_GPL(mux_chip_alloc);\n\nstatic int mux_control_set(struct mux_control *mux, int state)\n{\n\tint ret = mux->chip->ops->set(mux, state);\n\n\tmux->cached_state = ret < 0 ? MUX_CACHE_UNKNOWN : state;\n\tif (ret >= 0)\n\t\tmux->last_change = ktime_get();\n\n\treturn ret;\n}\n\n \nint mux_chip_register(struct mux_chip *mux_chip)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < mux_chip->controllers; ++i) {\n\t\tstruct mux_control *mux = &mux_chip->mux[i];\n\n\t\tif (mux->idle_state == mux->cached_state)\n\t\t\tcontinue;\n\n\t\tret = mux_control_set(mux, mux->idle_state);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&mux_chip->dev, \"unable to set idle state\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = device_add(&mux_chip->dev);\n\tif (ret < 0)\n\t\tdev_err(&mux_chip->dev,\n\t\t\t\"device_add failed in %s: %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mux_chip_register);\n\n \nvoid mux_chip_unregister(struct mux_chip *mux_chip)\n{\n\tdevice_del(&mux_chip->dev);\n}\nEXPORT_SYMBOL_GPL(mux_chip_unregister);\n\n \nvoid mux_chip_free(struct mux_chip *mux_chip)\n{\n\tif (!mux_chip)\n\t\treturn;\n\n\tput_device(&mux_chip->dev);\n}\nEXPORT_SYMBOL_GPL(mux_chip_free);\n\nstatic void devm_mux_chip_release(struct device *dev, void *res)\n{\n\tstruct mux_chip *mux_chip = *(struct mux_chip **)res;\n\n\tmux_chip_free(mux_chip);\n}\n\n \nstruct mux_chip *devm_mux_chip_alloc(struct device *dev,\n\t\t\t\t     unsigned int controllers,\n\t\t\t\t     size_t sizeof_priv)\n{\n\tstruct mux_chip **ptr, *mux_chip;\n\n\tptr = devres_alloc(devm_mux_chip_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux_chip = mux_chip_alloc(dev, controllers, sizeof_priv);\n\tif (IS_ERR(mux_chip)) {\n\t\tdevres_free(ptr);\n\t\treturn mux_chip;\n\t}\n\n\t*ptr = mux_chip;\n\tdevres_add(dev, ptr);\n\n\treturn mux_chip;\n}\nEXPORT_SYMBOL_GPL(devm_mux_chip_alloc);\n\nstatic void devm_mux_chip_reg_release(struct device *dev, void *res)\n{\n\tstruct mux_chip *mux_chip = *(struct mux_chip **)res;\n\n\tmux_chip_unregister(mux_chip);\n}\n\n \nint devm_mux_chip_register(struct device *dev,\n\t\t\t   struct mux_chip *mux_chip)\n{\n\tstruct mux_chip **ptr;\n\tint res;\n\n\tptr = devres_alloc(devm_mux_chip_reg_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tres = mux_chip_register(mux_chip);\n\tif (res) {\n\t\tdevres_free(ptr);\n\t\treturn res;\n\t}\n\n\t*ptr = mux_chip;\n\tdevres_add(dev, ptr);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(devm_mux_chip_register);\n\n \nunsigned int mux_control_states(struct mux_control *mux)\n{\n\treturn mux->states;\n}\nEXPORT_SYMBOL_GPL(mux_control_states);\n\n \nstatic int __mux_control_select(struct mux_control *mux, int state)\n{\n\tint ret;\n\n\tif (WARN_ON(state < 0 || state >= mux->states))\n\t\treturn -EINVAL;\n\n\tif (mux->cached_state == state)\n\t\treturn 0;\n\n\tret = mux_control_set(mux, state);\n\tif (ret >= 0)\n\t\treturn 0;\n\n\t \n\tif (mux->idle_state != MUX_IDLE_AS_IS)\n\t\tmux_control_set(mux, mux->idle_state);\n\n\treturn ret;\n}\n\nstatic void mux_control_delay(struct mux_control *mux, unsigned int delay_us)\n{\n\tktime_t delayend;\n\ts64 remaining;\n\n\tif (!delay_us)\n\t\treturn;\n\n\tdelayend = ktime_add_us(mux->last_change, delay_us);\n\tremaining = ktime_us_delta(delayend, ktime_get());\n\tif (remaining > 0)\n\t\tfsleep(remaining);\n}\n\n \nint mux_control_select_delay(struct mux_control *mux, unsigned int state,\n\t\t\t     unsigned int delay_us)\n{\n\tint ret;\n\n\tret = down_killable(&mux->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __mux_control_select(mux, state);\n\tif (ret >= 0)\n\t\tmux_control_delay(mux, delay_us);\n\n\tif (ret < 0)\n\t\tup(&mux->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mux_control_select_delay);\n\n \nint mux_state_select_delay(struct mux_state *mstate, unsigned int delay_us)\n{\n\treturn mux_control_select_delay(mstate->mux, mstate->state, delay_us);\n}\nEXPORT_SYMBOL_GPL(mux_state_select_delay);\n\n \nint mux_control_try_select_delay(struct mux_control *mux, unsigned int state,\n\t\t\t\t unsigned int delay_us)\n{\n\tint ret;\n\n\tif (down_trylock(&mux->lock))\n\t\treturn -EBUSY;\n\n\tret = __mux_control_select(mux, state);\n\tif (ret >= 0)\n\t\tmux_control_delay(mux, delay_us);\n\n\tif (ret < 0)\n\t\tup(&mux->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mux_control_try_select_delay);\n\n \nint mux_state_try_select_delay(struct mux_state *mstate, unsigned int delay_us)\n{\n\treturn mux_control_try_select_delay(mstate->mux, mstate->state, delay_us);\n}\nEXPORT_SYMBOL_GPL(mux_state_try_select_delay);\n\n \nint mux_control_deselect(struct mux_control *mux)\n{\n\tint ret = 0;\n\n\tif (mux->idle_state != MUX_IDLE_AS_IS &&\n\t    mux->idle_state != mux->cached_state)\n\t\tret = mux_control_set(mux, mux->idle_state);\n\n\tup(&mux->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mux_control_deselect);\n\n \nint mux_state_deselect(struct mux_state *mstate)\n{\n\treturn mux_control_deselect(mstate->mux);\n}\nEXPORT_SYMBOL_GPL(mux_state_deselect);\n\n \nstatic struct mux_chip *of_find_mux_chip_by_node(struct device_node *np)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_of_node(&mux_class, np);\n\n\treturn dev ? to_mux_chip(dev) : NULL;\n}\n\n \nstatic struct mux_control *mux_get(struct device *dev, const char *mux_name,\n\t\t\t\t   unsigned int *state)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct mux_chip *mux_chip;\n\tunsigned int controller;\n\tint index = 0;\n\tint ret;\n\n\tif (mux_name) {\n\t\tif (state)\n\t\t\tindex = of_property_match_string(np, \"mux-state-names\",\n\t\t\t\t\t\t\t mux_name);\n\t\telse\n\t\t\tindex = of_property_match_string(np, \"mux-control-names\",\n\t\t\t\t\t\t\t mux_name);\n\t\tif (index < 0) {\n\t\t\tdev_err(dev, \"mux controller '%s' not found\\n\",\n\t\t\t\tmux_name);\n\t\t\treturn ERR_PTR(index);\n\t\t}\n\t}\n\n\tif (state)\n\t\tret = of_parse_phandle_with_args(np,\n\t\t\t\t\t\t \"mux-states\", \"#mux-state-cells\",\n\t\t\t\t\t\t index, &args);\n\telse\n\t\tret = of_parse_phandle_with_args(np,\n\t\t\t\t\t\t \"mux-controls\", \"#mux-control-cells\",\n\t\t\t\t\t\t index, &args);\n\tif (ret) {\n\t\tdev_err(dev, \"%pOF: failed to get mux-%s %s(%i)\\n\",\n\t\t\tnp, state ? \"state\" : \"control\", mux_name ?: \"\", index);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmux_chip = of_find_mux_chip_by_node(args.np);\n\tof_node_put(args.np);\n\tif (!mux_chip)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tcontroller = 0;\n\tif (state) {\n\t\tif (args.args_count > 2 || args.args_count == 0 ||\n\t\t    (args.args_count < 2 && mux_chip->controllers > 1)) {\n\t\t\tdev_err(dev, \"%pOF: wrong #mux-state-cells for %pOF\\n\",\n\t\t\t\tnp, args.np);\n\t\t\tput_device(&mux_chip->dev);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (args.args_count == 2) {\n\t\t\tcontroller = args.args[0];\n\t\t\t*state = args.args[1];\n\t\t} else {\n\t\t\t*state = args.args[0];\n\t\t}\n\n\t} else {\n\t\tif (args.args_count > 1 ||\n\t\t    (!args.args_count && mux_chip->controllers > 1)) {\n\t\t\tdev_err(dev, \"%pOF: wrong #mux-control-cells for %pOF\\n\",\n\t\t\t\tnp, args.np);\n\t\t\tput_device(&mux_chip->dev);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tif (args.args_count)\n\t\t\tcontroller = args.args[0];\n\t}\n\n\tif (controller >= mux_chip->controllers) {\n\t\tdev_err(dev, \"%pOF: bad mux controller %u specified in %pOF\\n\",\n\t\t\tnp, controller, args.np);\n\t\tput_device(&mux_chip->dev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &mux_chip->mux[controller];\n}\n\n \nstruct mux_control *mux_control_get(struct device *dev, const char *mux_name)\n{\n\treturn mux_get(dev, mux_name, NULL);\n}\nEXPORT_SYMBOL_GPL(mux_control_get);\n\n \nvoid mux_control_put(struct mux_control *mux)\n{\n\tput_device(&mux->chip->dev);\n}\nEXPORT_SYMBOL_GPL(mux_control_put);\n\nstatic void devm_mux_control_release(struct device *dev, void *res)\n{\n\tstruct mux_control *mux = *(struct mux_control **)res;\n\n\tmux_control_put(mux);\n}\n\n \nstruct mux_control *devm_mux_control_get(struct device *dev,\n\t\t\t\t\t const char *mux_name)\n{\n\tstruct mux_control **ptr, *mux;\n\n\tptr = devres_alloc(devm_mux_control_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux = mux_control_get(dev, mux_name);\n\tif (IS_ERR(mux)) {\n\t\tdevres_free(ptr);\n\t\treturn mux;\n\t}\n\n\t*ptr = mux;\n\tdevres_add(dev, ptr);\n\n\treturn mux;\n}\nEXPORT_SYMBOL_GPL(devm_mux_control_get);\n\n \nstatic struct mux_state *mux_state_get(struct device *dev, const char *mux_name)\n{\n\tstruct mux_state *mstate;\n\n\tmstate = kzalloc(sizeof(*mstate), GFP_KERNEL);\n\tif (!mstate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmstate->mux = mux_get(dev, mux_name, &mstate->state);\n\tif (IS_ERR(mstate->mux)) {\n\t\tint err = PTR_ERR(mstate->mux);\n\n\t\tkfree(mstate);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn mstate;\n}\n\n \nstatic void mux_state_put(struct mux_state *mstate)\n{\n\tmux_control_put(mstate->mux);\n\tkfree(mstate);\n}\n\nstatic void devm_mux_state_release(struct device *dev, void *res)\n{\n\tstruct mux_state *mstate = *(struct mux_state **)res;\n\n\tmux_state_put(mstate);\n}\n\n \nstruct mux_state *devm_mux_state_get(struct device *dev,\n\t\t\t\t     const char *mux_name)\n{\n\tstruct mux_state **ptr, *mstate;\n\n\tptr = devres_alloc(devm_mux_state_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmstate = mux_state_get(dev, mux_name);\n\tif (IS_ERR(mstate)) {\n\t\tdevres_free(ptr);\n\t\treturn mstate;\n\t}\n\n\t*ptr = mstate;\n\tdevres_add(dev, ptr);\n\n\treturn mstate;\n}\nEXPORT_SYMBOL_GPL(devm_mux_state_get);\n\n \nsubsys_initcall(mux_init);\nmodule_exit(mux_exit);\n\nMODULE_DESCRIPTION(\"Multiplexer subsystem\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}