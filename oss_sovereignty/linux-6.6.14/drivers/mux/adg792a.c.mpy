{
  "module_name": "adg792a.c",
  "hash_id": "4b7552040fd56776d80c954309f641ce89f7405742146183f61e41e0f8b70c00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mux/adg792a.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mux/driver.h>\n#include <linux/property.h>\n\n#define ADG792A_LDSW\t\tBIT(0)\n#define ADG792A_RESETB\t\tBIT(1)\n#define ADG792A_DISABLE(mux)\t(0x50 | (mux))\n#define ADG792A_DISABLE_ALL\t(0x5f)\n#define ADG792A_MUX(mux, state)\t(0xc0 | (((mux) + 1) << 2) | (state))\n#define ADG792A_MUX_ALL(state)\t(0xc0 | (state))\n\nstatic int adg792a_write_cmd(struct i2c_client *i2c, u8 cmd, int reset)\n{\n\tu8 data = ADG792A_RESETB | ADG792A_LDSW;\n\n\t \n\tif (reset)\n\t\tdata &= ~ADG792A_RESETB;\n\n\treturn i2c_smbus_write_byte_data(i2c, cmd, data);\n}\n\nstatic int adg792a_set(struct mux_control *mux, int state)\n{\n\tstruct i2c_client *i2c = to_i2c_client(mux->chip->dev.parent);\n\tu8 cmd;\n\n\tif (mux->chip->controllers == 1) {\n\t\t \n\t\tif (state == MUX_IDLE_DISCONNECT)\n\t\t\tcmd = ADG792A_DISABLE_ALL;\n\t\telse\n\t\t\tcmd = ADG792A_MUX_ALL(state);\n\t} else {\n\t\tunsigned int controller = mux_control_get_index(mux);\n\n\t\tif (state == MUX_IDLE_DISCONNECT)\n\t\t\tcmd = ADG792A_DISABLE(controller);\n\t\telse\n\t\t\tcmd = ADG792A_MUX(controller, state);\n\t}\n\n\treturn adg792a_write_cmd(i2c, cmd, 0);\n}\n\nstatic const struct mux_control_ops adg792a_ops = {\n\t.set = adg792a_set,\n};\n\nstatic int adg792a_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct mux_chip *mux_chip;\n\ts32 idle_state[3];\n\tu32 cells;\n\tint ret;\n\tint i;\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(dev, \"#mux-control-cells\", &cells);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (cells >= 2)\n\t\treturn -EINVAL;\n\n\tmux_chip = devm_mux_chip_alloc(dev, cells ? 3 : 1, 0);\n\tif (IS_ERR(mux_chip))\n\t\treturn PTR_ERR(mux_chip);\n\n\tmux_chip->ops = &adg792a_ops;\n\n\tret = adg792a_write_cmd(i2c, ADG792A_DISABLE_ALL, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_property_read_u32_array(dev, \"idle-state\",\n\t\t\t\t\t     (u32 *)idle_state,\n\t\t\t\t\t     mux_chip->controllers);\n\tif (ret < 0) {\n\t\tidle_state[0] = MUX_IDLE_AS_IS;\n\t\tidle_state[1] = MUX_IDLE_AS_IS;\n\t\tidle_state[2] = MUX_IDLE_AS_IS;\n\t}\n\n\tfor (i = 0; i < mux_chip->controllers; ++i) {\n\t\tstruct mux_control *mux = &mux_chip->mux[i];\n\n\t\tmux->states = 4;\n\n\t\tswitch (idle_state[i]) {\n\t\tcase MUX_IDLE_DISCONNECT:\n\t\tcase MUX_IDLE_AS_IS:\n\t\tcase 0 ... 4:\n\t\t\tmux->idle_state = idle_state[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid idle-state %d\\n\", idle_state[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = devm_mux_chip_register(dev, mux_chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cells)\n\t\tdev_info(dev, \"3x single pole quadruple throw muxes registered\\n\");\n\telse\n\t\tdev_info(dev, \"triple pole quadruple throw mux registered\\n\");\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id adg792a_id[] = {\n\t{ .name = \"adg792a\", },\n\t{ .name = \"adg792g\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adg792a_id);\n\nstatic const struct of_device_id adg792a_of_match[] = {\n\t{ .compatible = \"adi,adg792a\", },\n\t{ .compatible = \"adi,adg792g\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adg792a_of_match);\n\nstatic struct i2c_driver adg792a_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"adg792a\",\n\t\t.of_match_table = of_match_ptr(adg792a_of_match),\n\t},\n\t.probe\t\t= adg792a_probe,\n\t.id_table\t= adg792a_id,\n};\nmodule_i2c_driver(adg792a_driver);\n\nMODULE_DESCRIPTION(\"Analog Devices ADG792A/G Triple 4:1 mux driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}