{
  "module_name": "mmio.c",
  "hash_id": "381fcfca557eeef69f2db4cc0a91f93d780db49832e171ff5bb6464f5b76eaba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mux/mmio.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mux/driver.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\nstatic int mux_mmio_set(struct mux_control *mux, int state)\n{\n\tstruct regmap_field **fields = mux_chip_priv(mux->chip);\n\n\treturn regmap_field_write(fields[mux_control_get_index(mux)], state);\n}\n\nstatic const struct mux_control_ops mux_mmio_ops = {\n\t.set = mux_mmio_set,\n};\n\nstatic const struct of_device_id mux_mmio_dt_ids[] = {\n\t{ .compatible = \"mmio-mux\", },\n\t{ .compatible = \"reg-mux\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mux_mmio_dt_ids);\n\nstatic int mux_mmio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap_field **fields;\n\tstruct mux_chip *mux_chip;\n\tstruct regmap *regmap;\n\tint num_fields;\n\tint ret;\n\tint i;\n\n\tif (of_device_is_compatible(np, \"mmio-mux\"))\n\t\tregmap = syscon_node_to_regmap(np->parent);\n\telse\n\t\tregmap = dev_get_regmap(dev->parent, NULL) ?: ERR_PTR(-ENODEV);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"failed to get regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_count_u32_elems(np, \"mux-reg-masks\");\n\tif (ret == 0 || ret % 2)\n\t\tret = -EINVAL;\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mux-reg-masks property missing or invalid: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tnum_fields = ret / 2;\n\n\tmux_chip = devm_mux_chip_alloc(dev, num_fields, num_fields *\n\t\t\t\t       sizeof(*fields));\n\tif (IS_ERR(mux_chip))\n\t\treturn PTR_ERR(mux_chip);\n\n\tfields = mux_chip_priv(mux_chip);\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tstruct mux_control *mux = &mux_chip->mux[i];\n\t\tstruct reg_field field;\n\t\ts32 idle_state = MUX_IDLE_AS_IS;\n\t\tu32 reg, mask;\n\t\tint bits;\n\n\t\tret = of_property_read_u32_index(np, \"mux-reg-masks\",\n\t\t\t\t\t\t 2 * i, &reg);\n\t\tif (!ret)\n\t\t\tret = of_property_read_u32_index(np, \"mux-reg-masks\",\n\t\t\t\t\t\t\t 2 * i + 1, &mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"bitfield %d: failed to read mux-reg-masks property: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfield.reg = reg;\n\t\tfield.msb = fls(mask) - 1;\n\t\tfield.lsb = ffs(mask) - 1;\n\n\t\tif (mask != GENMASK(field.msb, field.lsb)) {\n\t\t\tdev_err(dev, \"bitfield %d: invalid mask 0x%x\\n\",\n\t\t\t\ti, mask);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfields[i] = devm_regmap_field_alloc(dev, regmap, field);\n\t\tif (IS_ERR(fields[i])) {\n\t\t\tret = PTR_ERR(fields[i]);\n\t\t\tdev_err(dev, \"bitfield %d: failed allocate: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbits = 1 + field.msb - field.lsb;\n\t\tmux->states = 1 << bits;\n\n\t\tof_property_read_u32_index(np, \"idle-states\", i,\n\t\t\t\t\t   (u32 *)&idle_state);\n\t\tif (idle_state != MUX_IDLE_AS_IS) {\n\t\t\tif (idle_state < 0 || idle_state >= mux->states) {\n\t\t\t\tdev_err(dev, \"bitfield: %d: out of range idle state %d\\n\",\n\t\t\t\t\ti, idle_state);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmux->idle_state = idle_state;\n\t\t}\n\t}\n\n\tmux_chip->ops = &mux_mmio_ops;\n\n\treturn devm_mux_chip_register(dev, mux_chip);\n}\n\nstatic struct platform_driver mux_mmio_driver = {\n\t.driver = {\n\t\t.name = \"mmio-mux\",\n\t\t.of_match_table\t= mux_mmio_dt_ids,\n\t},\n\t.probe = mux_mmio_probe,\n};\nmodule_platform_driver(mux_mmio_driver);\n\nMODULE_DESCRIPTION(\"MMIO register bitfield-controlled multiplexer driver\");\nMODULE_AUTHOR(\"Philipp Zabel <p.zabel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}