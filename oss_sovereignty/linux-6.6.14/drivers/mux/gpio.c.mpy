{
  "module_name": "gpio.c",
  "hash_id": "7391aff729279a2c7382be552ed2baeef4c774840a01e3f8e624811b17ae0de5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mux/gpio.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mux/driver.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\nstruct mux_gpio {\n\tstruct gpio_descs *gpios;\n};\n\nstatic int mux_gpio_set(struct mux_control *mux, int state)\n{\n\tstruct mux_gpio *mux_gpio = mux_chip_priv(mux->chip);\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(state));\n\tu32 value = state;\n\n\tbitmap_from_arr32(values, &value, BITS_PER_TYPE(value));\n\n\tgpiod_set_array_value_cansleep(mux_gpio->gpios->ndescs,\n\t\t\t\t       mux_gpio->gpios->desc,\n\t\t\t\t       mux_gpio->gpios->info, values);\n\n\treturn 0;\n}\n\nstatic const struct mux_control_ops mux_gpio_ops = {\n\t.set = mux_gpio_set,\n};\n\nstatic const struct of_device_id mux_gpio_dt_ids[] = {\n\t{ .compatible = \"gpio-mux\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mux_gpio_dt_ids);\n\nstatic int mux_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mux_chip *mux_chip;\n\tstruct mux_gpio *mux_gpio;\n\tint pins;\n\ts32 idle_state;\n\tint ret;\n\n\tpins = gpiod_count(dev, \"mux\");\n\tif (pins < 0)\n\t\treturn pins;\n\n\tmux_chip = devm_mux_chip_alloc(dev, 1, sizeof(*mux_gpio));\n\tif (IS_ERR(mux_chip))\n\t\treturn PTR_ERR(mux_chip);\n\n\tmux_gpio = mux_chip_priv(mux_chip);\n\tmux_chip->ops = &mux_gpio_ops;\n\n\tmux_gpio->gpios = devm_gpiod_get_array(dev, \"mux\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mux_gpio->gpios))\n\t\treturn dev_err_probe(dev, PTR_ERR(mux_gpio->gpios),\n\t\t\t\t     \"failed to get gpios\\n\");\n\tWARN_ON(pins != mux_gpio->gpios->ndescs);\n\tmux_chip->mux->states = BIT(pins);\n\n\tret = device_property_read_u32(dev, \"idle-state\", (u32 *)&idle_state);\n\tif (ret >= 0 && idle_state != MUX_IDLE_AS_IS) {\n\t\tif (idle_state < 0 || idle_state >= mux_chip->mux->states) {\n\t\t\tdev_err(dev, \"invalid idle-state %u\\n\", idle_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmux_chip->mux->idle_state = idle_state;\n\t}\n\n\tret = devm_mux_chip_register(dev, mux_chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"%u-way mux-controller registered\\n\",\n\t\t mux_chip->mux->states);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mux_gpio_driver = {\n\t.driver = {\n\t\t.name = \"gpio-mux\",\n\t\t.of_match_table\t= mux_gpio_dt_ids,\n\t},\n\t.probe = mux_gpio_probe,\n};\nmodule_platform_driver(mux_gpio_driver);\n\nMODULE_DESCRIPTION(\"GPIO-controlled multiplexer driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}