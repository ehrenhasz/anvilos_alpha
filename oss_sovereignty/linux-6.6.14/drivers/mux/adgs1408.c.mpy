{
  "module_name": "adgs1408.c",
  "hash_id": "7053205f878ce3f48d4c4c238788dd12a9cc6e05ffef184f71ffbde2065189aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mux/adgs1408.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mux/driver.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n#define ADGS1408_SW_DATA       (0x01)\n#define ADGS1408_REG_READ(reg) ((reg) | 0x80)\n#define ADGS1408_DISABLE       (0x00)\n#define ADGS1408_MUX(state)    (((state) << 1) | 1)\n\nenum adgs1408_chip_id {\n\tADGS1408 = 1,\n\tADGS1409,\n};\n\nstatic int adgs1408_spi_reg_write(struct spi_device *spi,\n\t\t\t\t  u8 reg_addr, u8 reg_data)\n{\n\tu8 tx_buf[2];\n\n\ttx_buf[0] = reg_addr;\n\ttx_buf[1] = reg_data;\n\n\treturn spi_write_then_read(spi, tx_buf, sizeof(tx_buf), NULL, 0);\n}\n\nstatic int adgs1408_set(struct mux_control *mux, int state)\n{\n\tstruct spi_device *spi = to_spi_device(mux->chip->dev.parent);\n\tu8 reg;\n\n\tif (state == MUX_IDLE_DISCONNECT)\n\t\treg = ADGS1408_DISABLE;\n\telse\n\t\treg = ADGS1408_MUX(state);\n\n\treturn adgs1408_spi_reg_write(spi, ADGS1408_SW_DATA, reg);\n}\n\nstatic const struct mux_control_ops adgs1408_ops = {\n\t.set = adgs1408_set,\n};\n\nstatic int adgs1408_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tenum adgs1408_chip_id chip_id;\n\tstruct mux_chip *mux_chip;\n\tstruct mux_control *mux;\n\ts32 idle_state;\n\tint ret;\n\n\tchip_id = (enum adgs1408_chip_id)device_get_match_data(dev);\n\tif (!chip_id)\n\t\tchip_id = spi_get_device_id(spi)->driver_data;\n\n\tmux_chip = devm_mux_chip_alloc(dev, 1, 0);\n\tif (IS_ERR(mux_chip))\n\t\treturn PTR_ERR(mux_chip);\n\n\tmux_chip->ops = &adgs1408_ops;\n\n\tret = adgs1408_spi_reg_write(spi, ADGS1408_SW_DATA, ADGS1408_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_property_read_u32(dev, \"idle-state\", (u32 *)&idle_state);\n\tif (ret < 0)\n\t\tidle_state = MUX_IDLE_AS_IS;\n\n\tmux = mux_chip->mux;\n\n\tif (chip_id == ADGS1408)\n\t\tmux->states = 8;\n\telse\n\t\tmux->states = 4;\n\n\tswitch (idle_state) {\n\tcase MUX_IDLE_DISCONNECT:\n\tcase MUX_IDLE_AS_IS:\n\tcase 0 ... 7:\n\t\t \n\t\tif (idle_state < mux->states) {\n\t\t\tmux->idle_state = idle_state;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(dev, \"invalid idle-state %d\\n\", idle_state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn devm_mux_chip_register(dev, mux_chip);\n}\n\nstatic const struct spi_device_id adgs1408_spi_id[] = {\n\t{ \"adgs1408\", ADGS1408 },\n\t{ \"adgs1409\", ADGS1409 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adgs1408_spi_id);\n\nstatic const struct of_device_id adgs1408_of_match[] = {\n\t{ .compatible = \"adi,adgs1408\", .data = (void *)ADGS1408, },\n\t{ .compatible = \"adi,adgs1409\", .data = (void *)ADGS1409, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adgs1408_of_match);\n\nstatic struct spi_driver adgs1408_driver = {\n\t.driver = {\n\t\t.name = \"adgs1408\",\n\t\t.of_match_table = adgs1408_of_match,\n\t},\n\t.probe = adgs1408_probe,\n\t.id_table = adgs1408_spi_id,\n};\nmodule_spi_driver(adgs1408_driver);\n\nMODULE_AUTHOR(\"Mircea Caprioru <mircea.caprioru@analog.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADGS1408 MUX driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}