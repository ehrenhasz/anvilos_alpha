{
  "module_name": "module.c",
  "hash_id": "d86100ae565afc0062c502adbfe97567dba1df14514d913380bb6446f5c9af5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/module.c",
  "human_readable_source": "\n \n\n#include <linux/greybus.h>\n#include \"greybus_trace.h\"\n\nstatic ssize_t eject_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t len)\n{\n\tstruct gb_module *module = to_gb_module(dev);\n\tstruct gb_interface *intf;\n\tsize_t i;\n\tlong val;\n\tint ret;\n\n\tret = kstrtol(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn len;\n\n\tfor (i = 0; i < module->num_interfaces; ++i) {\n\t\tintf = module->interfaces[i];\n\n\t\tmutex_lock(&intf->mutex);\n\t\t \n\t\tintf->ejected = true;\n\t\tgb_interface_disable(intf);\n\t\tgb_interface_deactivate(intf);\n\t\tmutex_unlock(&intf->mutex);\n\t}\n\n\t \n\tret = gb_svc_intf_eject(module->hd->svc, module->module_id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_WO(eject);\n\nstatic ssize_t module_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct gb_module *module = to_gb_module(dev);\n\n\treturn sprintf(buf, \"%u\\n\", module->module_id);\n}\nstatic DEVICE_ATTR_RO(module_id);\n\nstatic ssize_t num_interfaces_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gb_module *module = to_gb_module(dev);\n\n\treturn sprintf(buf, \"%zu\\n\", module->num_interfaces);\n}\nstatic DEVICE_ATTR_RO(num_interfaces);\n\nstatic struct attribute *module_attrs[] = {\n\t&dev_attr_eject.attr,\n\t&dev_attr_module_id.attr,\n\t&dev_attr_num_interfaces.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(module);\n\nstatic void gb_module_release(struct device *dev)\n{\n\tstruct gb_module *module = to_gb_module(dev);\n\n\ttrace_gb_module_release(module);\n\n\tkfree(module);\n}\n\nstruct device_type greybus_module_type = {\n\t.name\t\t= \"greybus_module\",\n\t.release\t= gb_module_release,\n};\n\nstruct gb_module *gb_module_create(struct gb_host_device *hd, u8 module_id,\n\t\t\t\t   size_t num_interfaces)\n{\n\tstruct gb_interface *intf;\n\tstruct gb_module *module;\n\tint i;\n\n\tmodule = kzalloc(struct_size(module, interfaces, num_interfaces),\n\t\t\t GFP_KERNEL);\n\tif (!module)\n\t\treturn NULL;\n\n\tmodule->hd = hd;\n\tmodule->module_id = module_id;\n\tmodule->num_interfaces = num_interfaces;\n\n\tmodule->dev.parent = &hd->dev;\n\tmodule->dev.bus = &greybus_bus_type;\n\tmodule->dev.type = &greybus_module_type;\n\tmodule->dev.groups = module_groups;\n\tmodule->dev.dma_mask = hd->dev.dma_mask;\n\tdevice_initialize(&module->dev);\n\tdev_set_name(&module->dev, \"%d-%u\", hd->bus_id, module_id);\n\n\ttrace_gb_module_create(module);\n\n\tfor (i = 0; i < num_interfaces; ++i) {\n\t\tintf = gb_interface_create(module, module_id + i);\n\t\tif (!intf) {\n\t\t\tdev_err(&module->dev, \"failed to create interface %u\\n\",\n\t\t\t\tmodule_id + i);\n\t\t\tgoto err_put_interfaces;\n\t\t}\n\t\tmodule->interfaces[i] = intf;\n\t}\n\n\treturn module;\n\nerr_put_interfaces:\n\tfor (--i; i >= 0; --i)\n\t\tgb_interface_put(module->interfaces[i]);\n\n\tput_device(&module->dev);\n\n\treturn NULL;\n}\n\n \nstatic void gb_module_register_interface(struct gb_interface *intf)\n{\n\tstruct gb_module *module = intf->module;\n\tu8 intf_id = intf->interface_id;\n\tint ret;\n\n\tmutex_lock(&intf->mutex);\n\n\tret = gb_interface_activate(intf);\n\tif (ret) {\n\t\tif (intf->type != GB_INTERFACE_TYPE_DUMMY) {\n\t\t\tdev_err(&module->dev,\n\t\t\t\t\"failed to activate interface %u: %d\\n\",\n\t\t\t\tintf_id, ret);\n\t\t}\n\n\t\tgb_interface_add(intf);\n\t\tgoto err_unlock;\n\t}\n\n\tret = gb_interface_add(intf);\n\tif (ret)\n\t\tgoto err_interface_deactivate;\n\n\tret = gb_interface_enable(intf);\n\tif (ret) {\n\t\tdev_err(&module->dev, \"failed to enable interface %u: %d\\n\",\n\t\t\tintf_id, ret);\n\t\tgoto err_interface_deactivate;\n\t}\n\n\tmutex_unlock(&intf->mutex);\n\n\treturn;\n\nerr_interface_deactivate:\n\tgb_interface_deactivate(intf);\nerr_unlock:\n\tmutex_unlock(&intf->mutex);\n}\n\nstatic void gb_module_deregister_interface(struct gb_interface *intf)\n{\n\t \n\tif (intf->module->disconnected)\n\t\tintf->disconnected = true;\n\n\tmutex_lock(&intf->mutex);\n\tintf->removed = true;\n\tgb_interface_disable(intf);\n\tgb_interface_deactivate(intf);\n\tmutex_unlock(&intf->mutex);\n\n\tgb_interface_del(intf);\n}\n\n \nint gb_module_add(struct gb_module *module)\n{\n\tsize_t i;\n\tint ret;\n\n\tret = device_add(&module->dev);\n\tif (ret) {\n\t\tdev_err(&module->dev, \"failed to register module: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttrace_gb_module_add(module);\n\n\tfor (i = 0; i < module->num_interfaces; ++i)\n\t\tgb_module_register_interface(module->interfaces[i]);\n\n\treturn 0;\n}\n\n \nvoid gb_module_del(struct gb_module *module)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < module->num_interfaces; ++i)\n\t\tgb_module_deregister_interface(module->interfaces[i]);\n\n\ttrace_gb_module_del(module);\n\n\tdevice_del(&module->dev);\n}\n\nvoid gb_module_put(struct gb_module *module)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < module->num_interfaces; ++i)\n\t\tgb_interface_put(module->interfaces[i]);\n\n\tput_device(&module->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}