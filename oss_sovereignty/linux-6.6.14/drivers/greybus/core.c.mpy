{
  "module_name": "core.c",
  "hash_id": "ff3f848d8da114946f0cb53e45048f13e76b30dbb0b53dffd1ac822ef56551bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define CREATE_TRACE_POINTS\n#include <linux/greybus.h>\n#include \"greybus_trace.h\"\n\n#define GB_BUNDLE_AUTOSUSPEND_MS\t3000\n\n \nstatic bool nogreybus;\n#ifdef MODULE\nmodule_param(nogreybus, bool, 0444);\n#else\ncore_param(nogreybus, nogreybus, bool, 0444);\n#endif\nint greybus_disabled(void)\n{\n\treturn nogreybus;\n}\nEXPORT_SYMBOL_GPL(greybus_disabled);\n\nstatic bool greybus_match_one_id(struct gb_bundle *bundle,\n\t\t\t\t const struct greybus_bundle_id *id)\n{\n\tif ((id->match_flags & GREYBUS_ID_MATCH_VENDOR) &&\n\t    (id->vendor != bundle->intf->vendor_id))\n\t\treturn false;\n\n\tif ((id->match_flags & GREYBUS_ID_MATCH_PRODUCT) &&\n\t    (id->product != bundle->intf->product_id))\n\t\treturn false;\n\n\tif ((id->match_flags & GREYBUS_ID_MATCH_CLASS) &&\n\t    (id->class != bundle->class))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct greybus_bundle_id *\ngreybus_match_id(struct gb_bundle *bundle, const struct greybus_bundle_id *id)\n{\n\tif (!id)\n\t\treturn NULL;\n\n\tfor (; id->vendor || id->product || id->class || id->driver_info;\n\t\t\t\t\t\t\t\t\tid++) {\n\t\tif (greybus_match_one_id(bundle, id))\n\t\t\treturn id;\n\t}\n\n\treturn NULL;\n}\n\nstatic int greybus_match_device(struct device *dev, struct device_driver *drv)\n{\n\tstruct greybus_driver *driver = to_greybus_driver(drv);\n\tstruct gb_bundle *bundle;\n\tconst struct greybus_bundle_id *id;\n\n\tif (!is_gb_bundle(dev))\n\t\treturn 0;\n\n\tbundle = to_gb_bundle(dev);\n\n\tid = greybus_match_id(bundle, driver->id_table);\n\tif (id)\n\t\treturn 1;\n\t \n\treturn 0;\n}\n\nstatic int greybus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct gb_host_device *hd;\n\tconst struct gb_module *module = NULL;\n\tconst struct gb_interface *intf = NULL;\n\tconst struct gb_control *control = NULL;\n\tconst struct gb_bundle *bundle = NULL;\n\tconst struct gb_svc *svc = NULL;\n\n\tif (is_gb_host_device(dev)) {\n\t\thd = to_gb_host_device(dev);\n\t} else if (is_gb_module(dev)) {\n\t\tmodule = to_gb_module(dev);\n\t\thd = module->hd;\n\t} else if (is_gb_interface(dev)) {\n\t\tintf = to_gb_interface(dev);\n\t\tmodule = intf->module;\n\t\thd = intf->hd;\n\t} else if (is_gb_control(dev)) {\n\t\tcontrol = to_gb_control(dev);\n\t\tintf = control->intf;\n\t\tmodule = intf->module;\n\t\thd = intf->hd;\n\t} else if (is_gb_bundle(dev)) {\n\t\tbundle = to_gb_bundle(dev);\n\t\tintf = bundle->intf;\n\t\tmodule = intf->module;\n\t\thd = intf->hd;\n\t} else if (is_gb_svc(dev)) {\n\t\tsvc = to_gb_svc(dev);\n\t\thd = svc->hd;\n\t} else {\n\t\tdev_WARN(dev, \"uevent for unknown greybus device \\\"type\\\"!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (add_uevent_var(env, \"BUS=%u\", hd->bus_id))\n\t\treturn -ENOMEM;\n\n\tif (module) {\n\t\tif (add_uevent_var(env, \"MODULE=%u\", module->module_id))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (intf) {\n\t\tif (add_uevent_var(env, \"INTERFACE=%u\", intf->interface_id))\n\t\t\treturn -ENOMEM;\n\t\tif (add_uevent_var(env, \"GREYBUS_ID=%08x/%08x\",\n\t\t\t\t   intf->vendor_id, intf->product_id))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (bundle) {\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\tif (add_uevent_var(env, \"BUNDLE=%u\", bundle->id))\n\t\t\treturn -ENOMEM;\n\t\tif (add_uevent_var(env, \"BUNDLE_CLASS=%02x\", bundle->class))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void greybus_shutdown(struct device *dev)\n{\n\tif (is_gb_host_device(dev)) {\n\t\tstruct gb_host_device *hd;\n\n\t\thd = to_gb_host_device(dev);\n\t\tgb_hd_shutdown(hd);\n\t}\n}\n\nstruct bus_type greybus_bus_type = {\n\t.name =\t\t\"greybus\",\n\t.match =\tgreybus_match_device,\n\t.uevent =\tgreybus_uevent,\n\t.shutdown =\tgreybus_shutdown,\n};\n\nstatic int greybus_probe(struct device *dev)\n{\n\tstruct greybus_driver *driver = to_greybus_driver(dev->driver);\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tconst struct greybus_bundle_id *id;\n\tint retval;\n\n\t \n\tid = greybus_match_id(bundle, driver->id_table);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tretval = pm_runtime_get_sync(&bundle->intf->dev);\n\tif (retval < 0) {\n\t\tpm_runtime_put_noidle(&bundle->intf->dev);\n\t\treturn retval;\n\t}\n\n\tretval = gb_control_bundle_activate(bundle->intf->control, bundle->id);\n\tif (retval) {\n\t\tpm_runtime_put(&bundle->intf->dev);\n\t\treturn retval;\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, GB_BUNDLE_AUTOSUSPEND_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tretval = driver->probe(bundle, id);\n\tif (retval) {\n\t\t \n\t\tWARN_ON(!list_empty(&bundle->connections));\n\n\t\tgb_control_bundle_deactivate(bundle->intf->control, bundle->id);\n\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_put_noidle(dev);\n\t\tpm_runtime_dont_use_autosuspend(dev);\n\t\tpm_runtime_put(&bundle->intf->dev);\n\n\t\treturn retval;\n\t}\n\n\tpm_runtime_put(&bundle->intf->dev);\n\n\treturn 0;\n}\n\nstatic int greybus_remove(struct device *dev)\n{\n\tstruct greybus_driver *driver = to_greybus_driver(dev->driver);\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tstruct gb_connection *connection;\n\tint retval;\n\n\tretval = pm_runtime_get_sync(dev);\n\tif (retval < 0)\n\t\tdev_err(dev, \"failed to resume bundle: %d\\n\", retval);\n\n\t \n\tlist_for_each_entry(connection, &bundle->connections, bundle_links) {\n\t\tif (gb_connection_is_offloaded(connection))\n\t\t\tcontinue;\n\n\t\tif (bundle->intf->disconnected)\n\t\t\tgb_connection_disable_forced(connection);\n\t\telse\n\t\t\tgb_connection_disable_rx(connection);\n\t}\n\n\tdriver->disconnect(bundle);\n\n\t \n\tWARN_ON(!list_empty(&bundle->connections));\n\n\tif (!bundle->intf->disconnected)\n\t\tgb_control_bundle_deactivate(bundle->intf->control, bundle->id);\n\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_put_noidle(dev);\n\n\treturn 0;\n}\n\nint greybus_register_driver(struct greybus_driver *driver, struct module *owner,\n\t\t\t    const char *mod_name)\n{\n\tint retval;\n\n\tif (greybus_disabled())\n\t\treturn -ENODEV;\n\n\tdriver->driver.bus = &greybus_bus_type;\n\tdriver->driver.name = driver->name;\n\tdriver->driver.probe = greybus_probe;\n\tdriver->driver.remove = greybus_remove;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\n\tretval = driver_register(&driver->driver);\n\tif (retval)\n\t\treturn retval;\n\n\tpr_info(\"registered new driver %s\\n\", driver->name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(greybus_register_driver);\n\nvoid greybus_deregister_driver(struct greybus_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(greybus_deregister_driver);\n\nstatic int __init gb_init(void)\n{\n\tint retval;\n\n\tif (greybus_disabled())\n\t\treturn -ENODEV;\n\n\tBUILD_BUG_ON(CPORT_ID_MAX >= (long)CPORT_ID_BAD);\n\n\tgb_debugfs_init();\n\n\tretval = bus_register(&greybus_bus_type);\n\tif (retval) {\n\t\tpr_err(\"bus_register failed (%d)\\n\", retval);\n\t\tgoto error_bus;\n\t}\n\n\tretval = gb_hd_init();\n\tif (retval) {\n\t\tpr_err(\"gb_hd_init failed (%d)\\n\", retval);\n\t\tgoto error_hd;\n\t}\n\n\tretval = gb_operation_init();\n\tif (retval) {\n\t\tpr_err(\"gb_operation_init failed (%d)\\n\", retval);\n\t\tgoto error_operation;\n\t}\n\treturn 0;\t \n\nerror_operation:\n\tgb_hd_exit();\nerror_hd:\n\tbus_unregister(&greybus_bus_type);\nerror_bus:\n\tgb_debugfs_cleanup();\n\n\treturn retval;\n}\nmodule_init(gb_init);\n\nstatic void __exit gb_exit(void)\n{\n\tgb_operation_exit();\n\tgb_hd_exit();\n\tbus_unregister(&greybus_bus_type);\n\tgb_debugfs_cleanup();\n\ttracepoint_synchronize_unregister();\n}\nmodule_exit(gb_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Greg Kroah-Hartman <gregkh@linuxfoundation.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}