{
  "module_name": "interface.c",
  "hash_id": "efa2e29d9b2030df5e8026ff179d0fd05abe05c7b09bb6e23012a864f5c48ebc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/interface.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/greybus.h>\n\n#include \"greybus_trace.h\"\n\n#define GB_INTERFACE_MODE_SWITCH_TIMEOUT\t2000\n\n#define GB_INTERFACE_DEVICE_ID_BAD\t0xff\n\n#define GB_INTERFACE_AUTOSUSPEND_MS\t\t\t3000\n\n \n#define GB_INTERFACE_SUSPEND_HIBERNATE_DELAY_MS\t\t\t20\n\n \n#define DME_SELECTOR_INDEX_NULL\t\t0\n\n \n \n#define DME_T_TST_SRC_INCREMENT\t\t0x4083\n\n#define DME_DDBL1_MANUFACTURERID\t0x5003\n#define DME_DDBL1_PRODUCTID\t\t0x5004\n\n#define DME_TOSHIBA_GMP_VID\t\t0x6000\n#define DME_TOSHIBA_GMP_PID\t\t0x6001\n#define DME_TOSHIBA_GMP_SN0\t\t0x6002\n#define DME_TOSHIBA_GMP_SN1\t\t0x6003\n#define DME_TOSHIBA_GMP_INIT_STATUS\t0x6101\n\n \n#define TOSHIBA_DMID\t\t\t0x0126\n#define TOSHIBA_ES2_BRIDGE_DPID\t\t0x1000\n#define TOSHIBA_ES3_APBRIDGE_DPID\t0x1001\n#define TOSHIBA_ES3_GBPHY_DPID\t0x1002\n\nstatic int gb_interface_hibernate_link(struct gb_interface *intf);\nstatic int gb_interface_refclk_set(struct gb_interface *intf, bool enable);\n\nstatic int gb_interface_dme_attr_get(struct gb_interface *intf,\n\t\t\t\t     u16 attr, u32 *val)\n{\n\treturn gb_svc_dme_peer_get(intf->hd->svc, intf->interface_id,\n\t\t\t\t\tattr, DME_SELECTOR_INDEX_NULL, val);\n}\n\nstatic int gb_interface_read_ara_dme(struct gb_interface *intf)\n{\n\tu32 sn0, sn1;\n\tint ret;\n\n\t \n\tif (intf->ddbl1_manufacturer_id != TOSHIBA_DMID) {\n\t\tdev_err(&intf->dev, \"unknown manufacturer %08x\\n\",\n\t\t\tintf->ddbl1_manufacturer_id);\n\t\treturn -ENODEV;\n\t}\n\n\tret = gb_interface_dme_attr_get(intf, DME_TOSHIBA_GMP_VID,\n\t\t\t\t\t&intf->vendor_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_dme_attr_get(intf, DME_TOSHIBA_GMP_PID,\n\t\t\t\t\t&intf->product_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_dme_attr_get(intf, DME_TOSHIBA_GMP_SN0, &sn0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_dme_attr_get(intf, DME_TOSHIBA_GMP_SN1, &sn1);\n\tif (ret)\n\t\treturn ret;\n\n\tintf->serial_number = (u64)sn1 << 32 | sn0;\n\n\treturn 0;\n}\n\nstatic int gb_interface_read_dme(struct gb_interface *intf)\n{\n\tint ret;\n\n\t \n\tif (intf->dme_read)\n\t\treturn 0;\n\n\tret = gb_interface_dme_attr_get(intf, DME_DDBL1_MANUFACTURERID,\n\t\t\t\t\t&intf->ddbl1_manufacturer_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_dme_attr_get(intf, DME_DDBL1_PRODUCTID,\n\t\t\t\t\t&intf->ddbl1_product_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (intf->ddbl1_manufacturer_id == TOSHIBA_DMID &&\n\t    intf->ddbl1_product_id == TOSHIBA_ES2_BRIDGE_DPID) {\n\t\tintf->quirks |= GB_INTERFACE_QUIRK_NO_GMP_IDS;\n\t\tintf->quirks |= GB_INTERFACE_QUIRK_NO_INIT_STATUS;\n\t}\n\n\tret = gb_interface_read_ara_dme(intf);\n\tif (ret)\n\t\treturn ret;\n\n\tintf->dme_read = true;\n\n\treturn 0;\n}\n\nstatic int gb_interface_route_create(struct gb_interface *intf)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\tu8 intf_id = intf->interface_id;\n\tu8 device_id;\n\tint ret;\n\n\t \n\tret = ida_simple_get(&svc->device_id_map,\n\t\t\t     GB_SVC_DEVICE_ID_MIN, GB_SVC_DEVICE_ID_MAX + 1,\n\t\t\t     GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"failed to allocate device id: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdevice_id = ret;\n\n\tret = gb_svc_intf_device_id(svc, intf_id, device_id);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to set device id %u: %d\\n\",\n\t\t\tdevice_id, ret);\n\t\tgoto err_ida_remove;\n\t}\n\n\t \n\tret = gb_svc_route_create(svc, svc->ap_intf_id, GB_SVC_DEVICE_ID_AP,\n\t\t\t\t  intf_id, device_id);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to create route: %d\\n\", ret);\n\t\tgoto err_svc_id_free;\n\t}\n\n\tintf->device_id = device_id;\n\n\treturn 0;\n\nerr_svc_id_free:\n\t \nerr_ida_remove:\n\tida_simple_remove(&svc->device_id_map, device_id);\n\n\treturn ret;\n}\n\nstatic void gb_interface_route_destroy(struct gb_interface *intf)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\n\tif (intf->device_id == GB_INTERFACE_DEVICE_ID_BAD)\n\t\treturn;\n\n\tgb_svc_route_destroy(svc, svc->ap_intf_id, intf->interface_id);\n\tida_simple_remove(&svc->device_id_map, intf->device_id);\n\tintf->device_id = GB_INTERFACE_DEVICE_ID_BAD;\n}\n\n \nstatic int gb_interface_legacy_mode_switch(struct gb_interface *intf)\n{\n\tint ret;\n\n\tdev_info(&intf->dev, \"legacy mode switch detected\\n\");\n\n\t \n\tintf->disconnected = true;\n\tgb_interface_disable(intf);\n\tintf->disconnected = false;\n\n\tret = gb_interface_enable(intf);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to re-enable interface: %d\\n\", ret);\n\t\tgb_interface_deactivate(intf);\n\t}\n\n\treturn ret;\n}\n\nvoid gb_interface_mailbox_event(struct gb_interface *intf, u16 result,\n\t\t\t\tu32 mailbox)\n{\n\tmutex_lock(&intf->mutex);\n\n\tif (result) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"mailbox event with UniPro error: 0x%04x\\n\",\n\t\t\t result);\n\t\tgoto err_disable;\n\t}\n\n\tif (mailbox != GB_SVC_INTF_MAILBOX_GREYBUS) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"mailbox event with unexpected value: 0x%08x\\n\",\n\t\t\t mailbox);\n\t\tgoto err_disable;\n\t}\n\n\tif (intf->quirks & GB_INTERFACE_QUIRK_LEGACY_MODE_SWITCH) {\n\t\tgb_interface_legacy_mode_switch(intf);\n\t\tgoto out_unlock;\n\t}\n\n\tif (!intf->mode_switch) {\n\t\tdev_warn(&intf->dev, \"unexpected mailbox event: 0x%08x\\n\",\n\t\t\t mailbox);\n\t\tgoto err_disable;\n\t}\n\n\tdev_info(&intf->dev, \"mode switch detected\\n\");\n\n\tcomplete(&intf->mode_switch_completion);\n\nout_unlock:\n\tmutex_unlock(&intf->mutex);\n\n\treturn;\n\nerr_disable:\n\tgb_interface_disable(intf);\n\tgb_interface_deactivate(intf);\n\tmutex_unlock(&intf->mutex);\n}\n\nstatic void gb_interface_mode_switch_work(struct work_struct *work)\n{\n\tstruct gb_interface *intf;\n\tstruct gb_control *control;\n\tunsigned long timeout;\n\tint ret;\n\n\tintf = container_of(work, struct gb_interface, mode_switch_work);\n\n\tmutex_lock(&intf->mutex);\n\t \n\tif (!intf->enabled) {\n\t\tdev_dbg(&intf->dev, \"mode switch aborted\\n\");\n\t\tintf->mode_switch = false;\n\t\tmutex_unlock(&intf->mutex);\n\t\tgoto out_interface_put;\n\t}\n\n\t \n\tcontrol = gb_control_get(intf->control);\n\tgb_control_mode_switch_prepare(control);\n\tgb_interface_disable(intf);\n\tmutex_unlock(&intf->mutex);\n\n\ttimeout = msecs_to_jiffies(GB_INTERFACE_MODE_SWITCH_TIMEOUT);\n\tret = wait_for_completion_interruptible_timeout(\n\t\t\t&intf->mode_switch_completion, timeout);\n\n\t \n\tgb_control_mode_switch_complete(control);\n\tgb_control_put(control);\n\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"mode switch interrupted\\n\");\n\t\tgoto err_deactivate;\n\t} else if (ret == 0) {\n\t\tdev_err(&intf->dev, \"mode switch timed out\\n\");\n\t\tgoto err_deactivate;\n\t}\n\n\t \n\tmutex_lock(&intf->mutex);\n\tintf->mode_switch = false;\n\tif (intf->active) {\n\t\tret = gb_interface_enable(intf);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev, \"failed to re-enable interface: %d\\n\",\n\t\t\t\tret);\n\t\t\tgb_interface_deactivate(intf);\n\t\t}\n\t}\n\tmutex_unlock(&intf->mutex);\n\nout_interface_put:\n\tgb_interface_put(intf);\n\n\treturn;\n\nerr_deactivate:\n\tmutex_lock(&intf->mutex);\n\tintf->mode_switch = false;\n\tgb_interface_deactivate(intf);\n\tmutex_unlock(&intf->mutex);\n\n\tgb_interface_put(intf);\n}\n\nint gb_interface_request_mode_switch(struct gb_interface *intf)\n{\n\tint ret = 0;\n\n\tmutex_lock(&intf->mutex);\n\tif (intf->mode_switch) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tintf->mode_switch = true;\n\treinit_completion(&intf->mode_switch_completion);\n\n\t \n\tget_device(&intf->dev);\n\n\tif (!queue_work(system_long_wq, &intf->mode_switch_work)) {\n\t\tput_device(&intf->dev);\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&intf->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gb_interface_request_mode_switch);\n\n \nstatic int gb_interface_read_and_clear_init_status(struct gb_interface *intf)\n{\n\tstruct gb_host_device *hd = intf->hd;\n\tunsigned long bootrom_quirks;\n\tunsigned long s2l_quirks;\n\tint ret;\n\tu32 value;\n\tu16 attr;\n\tu8 init_status;\n\n\t \n\tif (intf->quirks & GB_INTERFACE_QUIRK_NO_INIT_STATUS)\n\t\tattr = DME_T_TST_SRC_INCREMENT;\n\telse\n\t\tattr = DME_TOSHIBA_GMP_INIT_STATUS;\n\n\tret = gb_svc_dme_peer_get(hd->svc, intf->interface_id, attr,\n\t\t\t\t  DME_SELECTOR_INDEX_NULL, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!value) {\n\t\tdev_err(&intf->dev, \"invalid init status\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (intf->quirks & GB_INTERFACE_QUIRK_NO_INIT_STATUS)\n\t\tinit_status = value & 0xff;\n\telse\n\t\tinit_status = value >> 24;\n\n\t \n\tbootrom_quirks = GB_INTERFACE_QUIRK_NO_CPORT_FEATURES |\n\t\t\t\tGB_INTERFACE_QUIRK_FORCED_DISABLE |\n\t\t\t\tGB_INTERFACE_QUIRK_LEGACY_MODE_SWITCH |\n\t\t\t\tGB_INTERFACE_QUIRK_NO_BUNDLE_ACTIVATE;\n\n\ts2l_quirks = GB_INTERFACE_QUIRK_NO_PM;\n\n\tswitch (init_status) {\n\tcase GB_INIT_BOOTROM_UNIPRO_BOOT_STARTED:\n\tcase GB_INIT_BOOTROM_FALLBACK_UNIPRO_BOOT_STARTED:\n\t\tintf->quirks |= bootrom_quirks;\n\t\tbreak;\n\tcase GB_INIT_S2_LOADER_BOOT_STARTED:\n\t\t \n\t\tintf->quirks &= ~bootrom_quirks;\n\t\tintf->quirks |= s2l_quirks;\n\t\tbreak;\n\tdefault:\n\t\tintf->quirks &= ~bootrom_quirks;\n\t\tintf->quirks &= ~s2l_quirks;\n\t}\n\n\t \n\treturn gb_svc_dme_peer_set(hd->svc, intf->interface_id, attr,\n\t\t\t\t   DME_SELECTOR_INDEX_NULL, 0);\n}\n\n \n#define gb_interface_attr(field, type)\t\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gb_interface *intf = to_gb_interface(dev);\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, type\"\\n\", intf->field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\ngb_interface_attr(ddbl1_manufacturer_id, \"0x%08x\");\ngb_interface_attr(ddbl1_product_id, \"0x%08x\");\ngb_interface_attr(interface_id, \"%u\");\ngb_interface_attr(vendor_id, \"0x%08x\");\ngb_interface_attr(product_id, \"0x%08x\");\ngb_interface_attr(serial_number, \"0x%016llx\");\n\nstatic ssize_t voltage_now_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tint ret;\n\tu32 measurement;\n\n\tret = gb_svc_pwrmon_intf_sample_get(intf->hd->svc, intf->interface_id,\n\t\t\t\t\t    GB_SVC_PWRMON_TYPE_VOL,\n\t\t\t\t\t    &measurement);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to get voltage sample (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", measurement);\n}\nstatic DEVICE_ATTR_RO(voltage_now);\n\nstatic ssize_t current_now_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tint ret;\n\tu32 measurement;\n\n\tret = gb_svc_pwrmon_intf_sample_get(intf->hd->svc, intf->interface_id,\n\t\t\t\t\t    GB_SVC_PWRMON_TYPE_CURR,\n\t\t\t\t\t    &measurement);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to get current sample (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", measurement);\n}\nstatic DEVICE_ATTR_RO(current_now);\n\nstatic ssize_t power_now_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tint ret;\n\tu32 measurement;\n\n\tret = gb_svc_pwrmon_intf_sample_get(intf->hd->svc, intf->interface_id,\n\t\t\t\t\t    GB_SVC_PWRMON_TYPE_PWR,\n\t\t\t\t\t    &measurement);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to get power sample (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", measurement);\n}\nstatic DEVICE_ATTR_RO(power_now);\n\nstatic ssize_t power_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\tif (intf->active)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"on\\n\");\n\telse\n\t\treturn scnprintf(buf, PAGE_SIZE, \"off\\n\");\n}\n\nstatic ssize_t power_state_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tbool activate;\n\tint ret = 0;\n\n\tif (kstrtobool(buf, &activate))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intf->mutex);\n\n\tif (activate == intf->active)\n\t\tgoto unlock;\n\n\tif (activate) {\n\t\tret = gb_interface_activate(intf);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"failed to activate interface: %d\\n\", ret);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = gb_interface_enable(intf);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"failed to enable interface: %d\\n\", ret);\n\t\t\tgb_interface_deactivate(intf);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tgb_interface_disable(intf);\n\t\tgb_interface_deactivate(intf);\n\t}\n\nunlock:\n\tmutex_unlock(&intf->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(power_state);\n\nstatic const char *gb_interface_type_string(struct gb_interface *intf)\n{\n\tstatic const char * const types[] = {\n\t\t[GB_INTERFACE_TYPE_INVALID] = \"invalid\",\n\t\t[GB_INTERFACE_TYPE_UNKNOWN] = \"unknown\",\n\t\t[GB_INTERFACE_TYPE_DUMMY] = \"dummy\",\n\t\t[GB_INTERFACE_TYPE_UNIPRO] = \"unipro\",\n\t\t[GB_INTERFACE_TYPE_GREYBUS] = \"greybus\",\n\t};\n\n\treturn types[intf->type];\n}\n\nstatic ssize_t interface_type_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gb_interface_type_string(intf));\n}\nstatic DEVICE_ATTR_RO(interface_type);\n\nstatic struct attribute *interface_unipro_attrs[] = {\n\t&dev_attr_ddbl1_manufacturer_id.attr,\n\t&dev_attr_ddbl1_product_id.attr,\n\tNULL\n};\n\nstatic struct attribute *interface_greybus_attrs[] = {\n\t&dev_attr_vendor_id.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_serial_number.attr,\n\tNULL\n};\n\nstatic struct attribute *interface_power_attrs[] = {\n\t&dev_attr_voltage_now.attr,\n\t&dev_attr_current_now.attr,\n\t&dev_attr_power_now.attr,\n\t&dev_attr_power_state.attr,\n\tNULL\n};\n\nstatic struct attribute *interface_common_attrs[] = {\n\t&dev_attr_interface_id.attr,\n\t&dev_attr_interface_type.attr,\n\tNULL\n};\n\nstatic umode_t interface_unipro_is_visible(struct kobject *kobj,\n\t\t\t\t\t   struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\tswitch (intf->type) {\n\tcase GB_INTERFACE_TYPE_UNIPRO:\n\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\treturn attr->mode;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t interface_greybus_is_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\tswitch (intf->type) {\n\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\treturn attr->mode;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t interface_power_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\tswitch (intf->type) {\n\tcase GB_INTERFACE_TYPE_UNIPRO:\n\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\treturn attr->mode;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct attribute_group interface_unipro_group = {\n\t.is_visible\t= interface_unipro_is_visible,\n\t.attrs\t\t= interface_unipro_attrs,\n};\n\nstatic const struct attribute_group interface_greybus_group = {\n\t.is_visible\t= interface_greybus_is_visible,\n\t.attrs\t\t= interface_greybus_attrs,\n};\n\nstatic const struct attribute_group interface_power_group = {\n\t.is_visible\t= interface_power_is_visible,\n\t.attrs\t\t= interface_power_attrs,\n};\n\nstatic const struct attribute_group interface_common_group = {\n\t.attrs\t\t= interface_common_attrs,\n};\n\nstatic const struct attribute_group *interface_groups[] = {\n\t&interface_unipro_group,\n\t&interface_greybus_group,\n\t&interface_power_group,\n\t&interface_common_group,\n\tNULL\n};\n\nstatic void gb_interface_release(struct device *dev)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\ttrace_gb_interface_release(intf);\n\n\tkfree(intf);\n}\n\n#ifdef CONFIG_PM\nstatic int gb_interface_suspend(struct device *dev)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tint ret;\n\n\tret = gb_control_interface_suspend_prepare(intf->control);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_control_suspend(intf->control);\n\tif (ret)\n\t\tgoto err_hibernate_abort;\n\n\tret = gb_interface_hibernate_link(intf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(GB_INTERFACE_SUSPEND_HIBERNATE_DELAY_MS);\n\n\tret = gb_interface_refclk_set(intf, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n\nerr_hibernate_abort:\n\tgb_control_interface_hibernate_abort(intf->control);\n\n\treturn ret;\n}\n\nstatic int gb_interface_resume(struct device *dev)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\tstruct gb_svc *svc = intf->hd->svc;\n\tint ret;\n\n\tret = gb_interface_refclk_set(intf, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_svc_intf_resume(svc, intf->interface_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_control_resume(intf->control);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int gb_interface_runtime_idle(struct device *dev)\n{\n\tpm_runtime_mark_last_busy(dev);\n\tpm_request_autosuspend(dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops gb_interface_pm_ops = {\n\tSET_RUNTIME_PM_OPS(gb_interface_suspend, gb_interface_resume,\n\t\t\t   gb_interface_runtime_idle)\n};\n\nstruct device_type greybus_interface_type = {\n\t.name =\t\t\"greybus_interface\",\n\t.release =\tgb_interface_release,\n\t.pm =\t\t&gb_interface_pm_ops,\n};\n\n \nstruct gb_interface *gb_interface_create(struct gb_module *module,\n\t\t\t\t\t u8 interface_id)\n{\n\tstruct gb_host_device *hd = module->hd;\n\tstruct gb_interface *intf;\n\n\tintf = kzalloc(sizeof(*intf), GFP_KERNEL);\n\tif (!intf)\n\t\treturn NULL;\n\n\tintf->hd = hd;\t\t \n\tintf->module = module;\n\tintf->interface_id = interface_id;\n\tINIT_LIST_HEAD(&intf->bundles);\n\tINIT_LIST_HEAD(&intf->manifest_descs);\n\tmutex_init(&intf->mutex);\n\tINIT_WORK(&intf->mode_switch_work, gb_interface_mode_switch_work);\n\tinit_completion(&intf->mode_switch_completion);\n\n\t \n\tintf->device_id = GB_INTERFACE_DEVICE_ID_BAD;\n\n\tintf->dev.parent = &module->dev;\n\tintf->dev.bus = &greybus_bus_type;\n\tintf->dev.type = &greybus_interface_type;\n\tintf->dev.groups = interface_groups;\n\tintf->dev.dma_mask = module->dev.dma_mask;\n\tdevice_initialize(&intf->dev);\n\tdev_set_name(&intf->dev, \"%s.%u\", dev_name(&module->dev),\n\t\t     interface_id);\n\n\tpm_runtime_set_autosuspend_delay(&intf->dev,\n\t\t\t\t\t GB_INTERFACE_AUTOSUSPEND_MS);\n\n\ttrace_gb_interface_create(intf);\n\n\treturn intf;\n}\n\nstatic int gb_interface_vsys_set(struct gb_interface *intf, bool enable)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"%s - %d\\n\", __func__, enable);\n\n\tret = gb_svc_intf_vsys_set(svc, intf->interface_id, enable);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to set v_sys: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_interface_refclk_set(struct gb_interface *intf, bool enable)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"%s - %d\\n\", __func__, enable);\n\n\tret = gb_svc_intf_refclk_set(svc, intf->interface_id, enable);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to set refclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_interface_unipro_set(struct gb_interface *intf, bool enable)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"%s - %d\\n\", __func__, enable);\n\n\tret = gb_svc_intf_unipro_set(svc, intf->interface_id, enable);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to set UniPro: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_interface_activate_operation(struct gb_interface *intf,\n\t\t\t\t\t   enum gb_interface_type *intf_type)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\tu8 type;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\tret = gb_svc_intf_activate(svc, intf->interface_id, &type);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to activate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (type) {\n\tcase GB_SVC_INTF_TYPE_DUMMY:\n\t\t*intf_type = GB_INTERFACE_TYPE_DUMMY;\n\t\t \n\t\treturn -ENODEV;\n\tcase GB_SVC_INTF_TYPE_UNIPRO:\n\t\t*intf_type = GB_INTERFACE_TYPE_UNIPRO;\n\t\tdev_err(&intf->dev, \"interface type UniPro not supported\\n\");\n\t\t \n\t\treturn -ENODEV;\n\tcase GB_SVC_INTF_TYPE_GREYBUS:\n\t\t*intf_type = GB_INTERFACE_TYPE_GREYBUS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&intf->dev, \"unknown interface type: %u\\n\", type);\n\t\t*intf_type = GB_INTERFACE_TYPE_UNKNOWN;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_interface_hibernate_link(struct gb_interface *intf)\n{\n\tstruct gb_svc *svc = intf->hd->svc;\n\n\treturn gb_svc_intf_set_power_mode_hibernate(svc, intf->interface_id);\n}\n\nstatic int _gb_interface_activate(struct gb_interface *intf,\n\t\t\t\t  enum gb_interface_type *type)\n{\n\tint ret;\n\n\t*type = GB_INTERFACE_TYPE_UNKNOWN;\n\n\tif (intf->ejected || intf->removed)\n\t\treturn -ENODEV;\n\n\tret = gb_interface_vsys_set(intf, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_interface_refclk_set(intf, true);\n\tif (ret)\n\t\tgoto err_vsys_disable;\n\n\tret = gb_interface_unipro_set(intf, true);\n\tif (ret)\n\t\tgoto err_refclk_disable;\n\n\tret = gb_interface_activate_operation(intf, type);\n\tif (ret) {\n\t\tswitch (*type) {\n\t\tcase GB_INTERFACE_TYPE_UNIPRO:\n\t\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\t\tgoto err_hibernate_link;\n\t\tdefault:\n\t\t\tgoto err_unipro_disable;\n\t\t}\n\t}\n\n\tret = gb_interface_read_dme(intf);\n\tif (ret)\n\t\tgoto err_hibernate_link;\n\n\tret = gb_interface_route_create(intf);\n\tif (ret)\n\t\tgoto err_hibernate_link;\n\n\tintf->active = true;\n\n\ttrace_gb_interface_activate(intf);\n\n\treturn 0;\n\nerr_hibernate_link:\n\tgb_interface_hibernate_link(intf);\nerr_unipro_disable:\n\tgb_interface_unipro_set(intf, false);\nerr_refclk_disable:\n\tgb_interface_refclk_set(intf, false);\nerr_vsys_disable:\n\tgb_interface_vsys_set(intf, false);\n\n\treturn ret;\n}\n\n \nstatic int _gb_interface_activate_es3_hack(struct gb_interface *intf,\n\t\t\t\t\t   enum gb_interface_type *type)\n{\n\tint retries = 3;\n\tint ret;\n\n\twhile (retries--) {\n\t\tret = _gb_interface_activate(intf, type);\n\t\tif (ret == -ENODEV && *type == GB_INTERFACE_TYPE_UNIPRO)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint gb_interface_activate(struct gb_interface *intf)\n{\n\tenum gb_interface_type type;\n\tint ret;\n\n\tswitch (intf->type) {\n\tcase GB_INTERFACE_TYPE_INVALID:\n\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\tret = _gb_interface_activate_es3_hack(intf, &type);\n\t\tbreak;\n\tdefault:\n\t\tret = _gb_interface_activate(intf, &type);\n\t}\n\n\t \n\tif (intf->type != GB_INTERFACE_TYPE_INVALID) {\n\t\tif (type != intf->type) {\n\t\t\tdev_err(&intf->dev, \"failed to detect interface type\\n\");\n\n\t\t\tif (!ret)\n\t\t\t\tgb_interface_deactivate(intf);\n\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tintf->type = type;\n\t}\n\n\treturn ret;\n}\n\n \nvoid gb_interface_deactivate(struct gb_interface *intf)\n{\n\tif (!intf->active)\n\t\treturn;\n\n\ttrace_gb_interface_deactivate(intf);\n\n\t \n\tif (intf->mode_switch)\n\t\tcomplete(&intf->mode_switch_completion);\n\n\tgb_interface_route_destroy(intf);\n\tgb_interface_hibernate_link(intf);\n\tgb_interface_unipro_set(intf, false);\n\tgb_interface_refclk_set(intf, false);\n\tgb_interface_vsys_set(intf, false);\n\n\tintf->active = false;\n}\n\n \nint gb_interface_enable(struct gb_interface *intf)\n{\n\tstruct gb_control *control;\n\tstruct gb_bundle *bundle, *tmp;\n\tint ret, size;\n\tvoid *manifest;\n\n\tret = gb_interface_read_and_clear_init_status(intf);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to clear init status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcontrol = gb_control_create(intf);\n\tif (IS_ERR(control)) {\n\t\tdev_err(&intf->dev, \"failed to create control device: %ld\\n\",\n\t\t\tPTR_ERR(control));\n\t\treturn PTR_ERR(control);\n\t}\n\tintf->control = control;\n\n\tret = gb_control_enable(intf->control);\n\tif (ret)\n\t\tgoto err_put_control;\n\n\t \n\tsize = gb_control_get_manifest_size_operation(intf);\n\tif (size <= 0) {\n\t\tdev_err(&intf->dev, \"failed to get manifest size: %d\\n\", size);\n\n\t\tif (size)\n\t\t\tret = size;\n\t\telse\n\t\t\tret =  -EINVAL;\n\n\t\tgoto err_disable_control;\n\t}\n\n\tmanifest = kmalloc(size, GFP_KERNEL);\n\tif (!manifest) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_control;\n\t}\n\n\t \n\tret = gb_control_get_manifest_operation(intf, manifest, size);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to get manifest: %d\\n\", ret);\n\t\tgoto err_free_manifest;\n\t}\n\n\t \n\tif (!gb_manifest_parse(intf, manifest, size)) {\n\t\tdev_err(&intf->dev, \"failed to parse manifest\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_destroy_bundles;\n\t}\n\n\tret = gb_control_get_bundle_versions(intf->control);\n\tif (ret)\n\t\tgoto err_destroy_bundles;\n\n\t \n\tret = gb_control_add(intf->control);\n\tif (ret)\n\t\tgoto err_destroy_bundles;\n\n\tpm_runtime_use_autosuspend(&intf->dev);\n\tpm_runtime_get_noresume(&intf->dev);\n\tpm_runtime_set_active(&intf->dev);\n\tpm_runtime_enable(&intf->dev);\n\n\tlist_for_each_entry_safe_reverse(bundle, tmp, &intf->bundles, links) {\n\t\tret = gb_bundle_add(bundle);\n\t\tif (ret) {\n\t\t\tgb_bundle_destroy(bundle);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tkfree(manifest);\n\n\tintf->enabled = true;\n\n\tpm_runtime_put(&intf->dev);\n\n\ttrace_gb_interface_enable(intf);\n\n\treturn 0;\n\nerr_destroy_bundles:\n\tlist_for_each_entry_safe(bundle, tmp, &intf->bundles, links)\n\t\tgb_bundle_destroy(bundle);\nerr_free_manifest:\n\tkfree(manifest);\nerr_disable_control:\n\tgb_control_disable(intf->control);\nerr_put_control:\n\tgb_control_put(intf->control);\n\tintf->control = NULL;\n\n\treturn ret;\n}\n\n \nvoid gb_interface_disable(struct gb_interface *intf)\n{\n\tstruct gb_bundle *bundle;\n\tstruct gb_bundle *next;\n\n\tif (!intf->enabled)\n\t\treturn;\n\n\ttrace_gb_interface_disable(intf);\n\n\tpm_runtime_get_sync(&intf->dev);\n\n\t \n\tif (intf->quirks & GB_INTERFACE_QUIRK_FORCED_DISABLE)\n\t\tintf->disconnected = true;\n\n\tlist_for_each_entry_safe(bundle, next, &intf->bundles, links)\n\t\tgb_bundle_destroy(bundle);\n\n\tif (!intf->mode_switch && !intf->disconnected)\n\t\tgb_control_interface_deactivate_prepare(intf->control);\n\n\tgb_control_del(intf->control);\n\tgb_control_disable(intf->control);\n\tgb_control_put(intf->control);\n\tintf->control = NULL;\n\n\tintf->enabled = false;\n\n\tpm_runtime_disable(&intf->dev);\n\tpm_runtime_set_suspended(&intf->dev);\n\tpm_runtime_dont_use_autosuspend(&intf->dev);\n\tpm_runtime_put_noidle(&intf->dev);\n}\n\n \nint gb_interface_add(struct gb_interface *intf)\n{\n\tint ret;\n\n\tret = device_add(&intf->dev);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"failed to register interface: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttrace_gb_interface_add(intf);\n\n\tdev_info(&intf->dev, \"Interface added (%s)\\n\",\n\t\t gb_interface_type_string(intf));\n\n\tswitch (intf->type) {\n\tcase GB_INTERFACE_TYPE_GREYBUS:\n\t\tdev_info(&intf->dev, \"GMP VID=0x%08x, PID=0x%08x\\n\",\n\t\t\t intf->vendor_id, intf->product_id);\n\t\tfallthrough;\n\tcase GB_INTERFACE_TYPE_UNIPRO:\n\t\tdev_info(&intf->dev, \"DDBL1 Manufacturer=0x%08x, Product=0x%08x\\n\",\n\t\t\t intf->ddbl1_manufacturer_id,\n\t\t\t intf->ddbl1_product_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nvoid gb_interface_del(struct gb_interface *intf)\n{\n\tif (device_is_registered(&intf->dev)) {\n\t\ttrace_gb_interface_del(intf);\n\n\t\tdevice_del(&intf->dev);\n\t\tdev_info(&intf->dev, \"Interface removed\\n\");\n\t}\n}\n\nvoid gb_interface_put(struct gb_interface *intf)\n{\n\tput_device(&intf->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}