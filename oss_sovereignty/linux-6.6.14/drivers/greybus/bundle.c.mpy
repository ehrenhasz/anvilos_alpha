{
  "module_name": "bundle.c",
  "hash_id": "d0bf0e9ff0388d0f0e5ebfab3914d7508be55ac7a75684fafbb6e6ee1e0c0f5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/bundle.c",
  "human_readable_source": "\n \n\n#include <linux/greybus.h>\n#include \"greybus_trace.h\"\n\nstatic ssize_t bundle_class_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\n\treturn sprintf(buf, \"0x%02x\\n\", bundle->class);\n}\nstatic DEVICE_ATTR_RO(bundle_class);\n\nstatic ssize_t bundle_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\n\treturn sprintf(buf, \"%u\\n\", bundle->id);\n}\nstatic DEVICE_ATTR_RO(bundle_id);\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\n\tif (!bundle->state)\n\t\treturn sprintf(buf, \"\\n\");\n\n\treturn sprintf(buf, \"%s\\n\", bundle->state);\n}\n\nstatic ssize_t state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t size)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\n\tkfree(bundle->state);\n\tbundle->state = kstrdup(buf, GFP_KERNEL);\n\tif (!bundle->state)\n\t\treturn -ENOMEM;\n\n\t \n\tsysfs_notify(&bundle->dev.kobj, NULL, \"state\");\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(state);\n\nstatic struct attribute *bundle_attrs[] = {\n\t&dev_attr_bundle_class.attr,\n\t&dev_attr_bundle_id.attr,\n\t&dev_attr_state.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(bundle);\n\nstatic struct gb_bundle *gb_bundle_find(struct gb_interface *intf,\n\t\t\t\t\tu8 bundle_id)\n{\n\tstruct gb_bundle *bundle;\n\n\tlist_for_each_entry(bundle, &intf->bundles, links) {\n\t\tif (bundle->id == bundle_id)\n\t\t\treturn bundle;\n\t}\n\n\treturn NULL;\n}\n\nstatic void gb_bundle_release(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\n\ttrace_gb_bundle_release(bundle);\n\n\tkfree(bundle->state);\n\tkfree(bundle->cport_desc);\n\tkfree(bundle);\n}\n\n#ifdef CONFIG_PM\nstatic void gb_bundle_disable_all_connections(struct gb_bundle *bundle)\n{\n\tstruct gb_connection *connection;\n\n\tlist_for_each_entry(connection, &bundle->connections, bundle_links)\n\t\tgb_connection_disable(connection);\n}\n\nstatic void gb_bundle_enable_all_connections(struct gb_bundle *bundle)\n{\n\tstruct gb_connection *connection;\n\n\tlist_for_each_entry(connection, &bundle->connections, bundle_links)\n\t\tgb_connection_enable(connection);\n}\n\nstatic int gb_bundle_suspend(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tconst struct dev_pm_ops *pm = dev->driver->pm;\n\tint ret;\n\n\tif (pm && pm->runtime_suspend) {\n\t\tret = pm->runtime_suspend(&bundle->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tgb_bundle_disable_all_connections(bundle);\n\t}\n\n\tret = gb_control_bundle_suspend(bundle->intf->control, bundle->id);\n\tif (ret) {\n\t\tif (pm && pm->runtime_resume)\n\t\t\tret = pm->runtime_resume(dev);\n\t\telse\n\t\t\tgb_bundle_enable_all_connections(bundle);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_bundle_resume(struct device *dev)\n{\n\tstruct gb_bundle *bundle = to_gb_bundle(dev);\n\tconst struct dev_pm_ops *pm = dev->driver->pm;\n\tint ret;\n\n\tret = gb_control_bundle_resume(bundle->intf->control, bundle->id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pm && pm->runtime_resume) {\n\t\tret = pm->runtime_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tgb_bundle_enable_all_connections(bundle);\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_bundle_idle(struct device *dev)\n{\n\tpm_runtime_mark_last_busy(dev);\n\tpm_request_autosuspend(dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops gb_bundle_pm_ops = {\n\tSET_RUNTIME_PM_OPS(gb_bundle_suspend, gb_bundle_resume, gb_bundle_idle)\n};\n\nstruct device_type greybus_bundle_type = {\n\t.name =\t\t\"greybus_bundle\",\n\t.release =\tgb_bundle_release,\n\t.pm =\t\t&gb_bundle_pm_ops,\n};\n\n \nstruct gb_bundle *gb_bundle_create(struct gb_interface *intf, u8 bundle_id,\n\t\t\t\t   u8 class)\n{\n\tstruct gb_bundle *bundle;\n\n\tif (bundle_id == BUNDLE_ID_NONE) {\n\t\tdev_err(&intf->dev, \"can't use bundle id %u\\n\", bundle_id);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (gb_bundle_find(intf, bundle_id)) {\n\t\tdev_err(&intf->dev, \"duplicate bundle id %u\\n\", bundle_id);\n\t\treturn NULL;\n\t}\n\n\tbundle = kzalloc(sizeof(*bundle), GFP_KERNEL);\n\tif (!bundle)\n\t\treturn NULL;\n\n\tbundle->intf = intf;\n\tbundle->id = bundle_id;\n\tbundle->class = class;\n\tINIT_LIST_HEAD(&bundle->connections);\n\n\tbundle->dev.parent = &intf->dev;\n\tbundle->dev.bus = &greybus_bus_type;\n\tbundle->dev.type = &greybus_bundle_type;\n\tbundle->dev.groups = bundle_groups;\n\tbundle->dev.dma_mask = intf->dev.dma_mask;\n\tdevice_initialize(&bundle->dev);\n\tdev_set_name(&bundle->dev, \"%s.%d\", dev_name(&intf->dev), bundle_id);\n\n\tlist_add(&bundle->links, &intf->bundles);\n\n\ttrace_gb_bundle_create(bundle);\n\n\treturn bundle;\n}\n\nint gb_bundle_add(struct gb_bundle *bundle)\n{\n\tint ret;\n\n\tret = device_add(&bundle->dev);\n\tif (ret) {\n\t\tdev_err(&bundle->dev, \"failed to register bundle: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttrace_gb_bundle_add(bundle);\n\n\treturn 0;\n}\n\n \nvoid gb_bundle_destroy(struct gb_bundle *bundle)\n{\n\ttrace_gb_bundle_destroy(bundle);\n\n\tif (device_is_registered(&bundle->dev))\n\t\tdevice_del(&bundle->dev);\n\n\tlist_del(&bundle->links);\n\n\tput_device(&bundle->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}