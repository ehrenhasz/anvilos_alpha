{
  "module_name": "control.c",
  "hash_id": "b0e6b59aa457dca78c8ac133c589c30dc835e7ca5de80dc17a421a1b3bffd51b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/control.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n\n \n#define GB_CONTROL_VERSION_MAJOR\t0\n#define GB_CONTROL_VERSION_MINOR\t1\n\nstatic int gb_control_get_version(struct gb_control *control)\n{\n\tstruct gb_interface *intf = control->connection->intf;\n\tstruct gb_control_version_request request;\n\tstruct gb_control_version_response response;\n\tint ret;\n\n\trequest.major = GB_CONTROL_VERSION_MAJOR;\n\trequest.minor = GB_CONTROL_VERSION_MINOR;\n\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_VERSION,\n\t\t\t\t&request, sizeof(request), &response,\n\t\t\t\tsizeof(response));\n\tif (ret) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"failed to get control-protocol version: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.major > request.major) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"unsupported major control-protocol version (%u > %u)\\n\",\n\t\t\tresponse.major, request.major);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tcontrol->protocol_major = response.major;\n\tcontrol->protocol_minor = response.minor;\n\n\tdev_dbg(&intf->dev, \"%s - %u.%u\\n\", __func__, response.major,\n\t\tresponse.minor);\n\n\treturn 0;\n}\n\nstatic int gb_control_get_bundle_version(struct gb_control *control,\n\t\t\t\t\t struct gb_bundle *bundle)\n{\n\tstruct gb_interface *intf = control->connection->intf;\n\tstruct gb_control_bundle_version_request request;\n\tstruct gb_control_bundle_version_response response;\n\tint ret;\n\n\trequest.bundle_id = bundle->id;\n\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_BUNDLE_VERSION,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"failed to get bundle %u class version: %d\\n\",\n\t\t\tbundle->id, ret);\n\t\treturn ret;\n\t}\n\n\tbundle->class_major = response.major;\n\tbundle->class_minor = response.minor;\n\n\tdev_dbg(&intf->dev, \"%s - %u: %u.%u\\n\", __func__, bundle->id,\n\t\tresponse.major, response.minor);\n\n\treturn 0;\n}\n\nint gb_control_get_bundle_versions(struct gb_control *control)\n{\n\tstruct gb_interface *intf = control->connection->intf;\n\tstruct gb_bundle *bundle;\n\tint ret;\n\n\tif (!control->has_bundle_version)\n\t\treturn 0;\n\n\tlist_for_each_entry(bundle, &intf->bundles, links) {\n\t\tret = gb_control_get_bundle_version(control, bundle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint gb_control_get_manifest_size_operation(struct gb_interface *intf)\n{\n\tstruct gb_control_get_manifest_size_response response;\n\tstruct gb_connection *connection = intf->control->connection;\n\tint ret;\n\n\tret = gb_operation_sync(connection, GB_CONTROL_TYPE_GET_MANIFEST_SIZE,\n\t\t\t\tNULL, 0, &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&connection->intf->dev,\n\t\t\t\"failed to get manifest size: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn le16_to_cpu(response.size);\n}\n\n \nint gb_control_get_manifest_operation(struct gb_interface *intf, void *manifest,\n\t\t\t\t      size_t size)\n{\n\tstruct gb_connection *connection = intf->control->connection;\n\n\treturn gb_operation_sync(connection, GB_CONTROL_TYPE_GET_MANIFEST,\n\t\t\t\tNULL, 0, manifest, size);\n}\n\nint gb_control_connected_operation(struct gb_control *control, u16 cport_id)\n{\n\tstruct gb_control_connected_request request;\n\n\trequest.cport_id = cpu_to_le16(cport_id);\n\treturn gb_operation_sync(control->connection, GB_CONTROL_TYPE_CONNECTED,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nint gb_control_disconnected_operation(struct gb_control *control, u16 cport_id)\n{\n\tstruct gb_control_disconnected_request request;\n\n\trequest.cport_id = cpu_to_le16(cport_id);\n\treturn gb_operation_sync(control->connection,\n\t\t\t\t GB_CONTROL_TYPE_DISCONNECTED, &request,\n\t\t\t\t sizeof(request), NULL, 0);\n}\n\nint gb_control_disconnecting_operation(struct gb_control *control,\n\t\t\t\t       u16 cport_id)\n{\n\tstruct gb_control_disconnecting_request *request;\n\tstruct gb_operation *operation;\n\tint ret;\n\n\toperation = gb_operation_create_core(control->connection,\n\t\t\t\t\t     GB_CONTROL_TYPE_DISCONNECTING,\n\t\t\t\t\t     sizeof(*request), 0, 0,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\trequest = operation->request->payload;\n\trequest->cport_id = cpu_to_le16(cport_id);\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret) {\n\t\tdev_err(&control->dev, \"failed to send disconnecting: %d\\n\",\n\t\t\tret);\n\t}\n\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nint gb_control_mode_switch_operation(struct gb_control *control)\n{\n\tstruct gb_operation *operation;\n\tint ret;\n\n\toperation = gb_operation_create_core(control->connection,\n\t\t\t\t\t     GB_CONTROL_TYPE_MODE_SWITCH,\n\t\t\t\t\t     0, 0,\n\t\t\t\t\t     GB_OPERATION_FLAG_UNIDIRECTIONAL,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\tret = gb_operation_request_send_sync(operation);\n\tif (ret)\n\t\tdev_err(&control->dev, \"failed to send mode switch: %d\\n\", ret);\n\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int gb_control_bundle_pm_status_map(u8 status)\n{\n\tswitch (status) {\n\tcase GB_CONTROL_BUNDLE_PM_INVAL:\n\t\treturn -EINVAL;\n\tcase GB_CONTROL_BUNDLE_PM_BUSY:\n\t\treturn -EBUSY;\n\tcase GB_CONTROL_BUNDLE_PM_NA:\n\t\treturn -ENOMSG;\n\tcase GB_CONTROL_BUNDLE_PM_FAIL:\n\tdefault:\n\t\treturn -EREMOTEIO;\n\t}\n}\n\nint gb_control_bundle_suspend(struct gb_control *control, u8 bundle_id)\n{\n\tstruct gb_control_bundle_pm_request request;\n\tstruct gb_control_bundle_pm_response response;\n\tint ret;\n\n\trequest.bundle_id = bundle_id;\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_BUNDLE_SUSPEND, &request,\n\t\t\t\tsizeof(request), &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev, \"failed to send bundle %u suspend: %d\\n\",\n\t\t\tbundle_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\n\t\tdev_err(&control->dev, \"failed to suspend bundle %u: %d\\n\",\n\t\t\tbundle_id, response.status);\n\t\treturn gb_control_bundle_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nint gb_control_bundle_resume(struct gb_control *control, u8 bundle_id)\n{\n\tstruct gb_control_bundle_pm_request request;\n\tstruct gb_control_bundle_pm_response response;\n\tint ret;\n\n\trequest.bundle_id = bundle_id;\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_BUNDLE_RESUME, &request,\n\t\t\t\tsizeof(request), &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev, \"failed to send bundle %u resume: %d\\n\",\n\t\t\tbundle_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\n\t\tdev_err(&control->dev, \"failed to resume bundle %u: %d\\n\",\n\t\t\tbundle_id, response.status);\n\t\treturn gb_control_bundle_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nint gb_control_bundle_deactivate(struct gb_control *control, u8 bundle_id)\n{\n\tstruct gb_control_bundle_pm_request request;\n\tstruct gb_control_bundle_pm_response response;\n\tint ret;\n\n\trequest.bundle_id = bundle_id;\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_BUNDLE_DEACTIVATE, &request,\n\t\t\t\tsizeof(request), &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev,\n\t\t\t\"failed to send bundle %u deactivate: %d\\n\", bundle_id,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\n\t\tdev_err(&control->dev, \"failed to deactivate bundle %u: %d\\n\",\n\t\t\tbundle_id, response.status);\n\t\treturn gb_control_bundle_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nint gb_control_bundle_activate(struct gb_control *control, u8 bundle_id)\n{\n\tstruct gb_control_bundle_pm_request request;\n\tstruct gb_control_bundle_pm_response response;\n\tint ret;\n\n\tif (!control->has_bundle_activate)\n\t\treturn 0;\n\n\trequest.bundle_id = bundle_id;\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_BUNDLE_ACTIVATE, &request,\n\t\t\t\tsizeof(request), &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev,\n\t\t\t\"failed to send bundle %u activate: %d\\n\", bundle_id,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\n\t\tdev_err(&control->dev, \"failed to activate bundle %u: %d\\n\",\n\t\t\tbundle_id, response.status);\n\t\treturn gb_control_bundle_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_control_interface_pm_status_map(u8 status)\n{\n\tswitch (status) {\n\tcase GB_CONTROL_INTF_PM_BUSY:\n\t\treturn -EBUSY;\n\tcase GB_CONTROL_INTF_PM_NA:\n\t\treturn -ENOMSG;\n\tdefault:\n\t\treturn -EREMOTEIO;\n\t}\n}\n\nint gb_control_interface_suspend_prepare(struct gb_control *control)\n{\n\tstruct gb_control_intf_pm_response response;\n\tint ret;\n\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_INTF_SUSPEND_PREPARE, NULL, 0,\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev,\n\t\t\t\"failed to send interface suspend prepare: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_INTF_PM_OK) {\n\t\tdev_err(&control->dev, \"interface error while preparing suspend: %d\\n\",\n\t\t\tresponse.status);\n\t\treturn gb_control_interface_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nint gb_control_interface_deactivate_prepare(struct gb_control *control)\n{\n\tstruct gb_control_intf_pm_response response;\n\tint ret;\n\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_INTF_DEACTIVATE_PREPARE, NULL,\n\t\t\t\t0, &response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev, \"failed to send interface deactivate prepare: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_INTF_PM_OK) {\n\t\tdev_err(&control->dev, \"interface error while preparing deactivate: %d\\n\",\n\t\t\tresponse.status);\n\t\treturn gb_control_interface_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nint gb_control_interface_hibernate_abort(struct gb_control *control)\n{\n\tstruct gb_control_intf_pm_response response;\n\tint ret;\n\n\tret = gb_operation_sync(control->connection,\n\t\t\t\tGB_CONTROL_TYPE_INTF_HIBERNATE_ABORT, NULL, 0,\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&control->dev,\n\t\t\t\"failed to send interface aborting hibernate: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_CONTROL_INTF_PM_OK) {\n\t\tdev_err(&control->dev, \"interface error while aborting hibernate: %d\\n\",\n\t\t\tresponse.status);\n\t\treturn gb_control_interface_pm_status_map(response.status);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t vendor_string_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct gb_control *control = to_gb_control(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", control->vendor_string);\n}\nstatic DEVICE_ATTR_RO(vendor_string);\n\nstatic ssize_t product_string_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gb_control *control = to_gb_control(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", control->product_string);\n}\nstatic DEVICE_ATTR_RO(product_string);\n\nstatic struct attribute *control_attrs[] = {\n\t&dev_attr_vendor_string.attr,\n\t&dev_attr_product_string.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(control);\n\nstatic void gb_control_release(struct device *dev)\n{\n\tstruct gb_control *control = to_gb_control(dev);\n\n\tgb_connection_destroy(control->connection);\n\n\tkfree(control->vendor_string);\n\tkfree(control->product_string);\n\n\tkfree(control);\n}\n\nstruct device_type greybus_control_type = {\n\t.name =\t\t\"greybus_control\",\n\t.release =\tgb_control_release,\n};\n\nstruct gb_control *gb_control_create(struct gb_interface *intf)\n{\n\tstruct gb_connection *connection;\n\tstruct gb_control *control;\n\n\tcontrol = kzalloc(sizeof(*control), GFP_KERNEL);\n\tif (!control)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcontrol->intf = intf;\n\n\tconnection = gb_connection_create_control(intf);\n\tif (IS_ERR(connection)) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"failed to create control connection: %ld\\n\",\n\t\t\tPTR_ERR(connection));\n\t\tkfree(control);\n\t\treturn ERR_CAST(connection);\n\t}\n\n\tcontrol->connection = connection;\n\n\tcontrol->dev.parent = &intf->dev;\n\tcontrol->dev.bus = &greybus_bus_type;\n\tcontrol->dev.type = &greybus_control_type;\n\tcontrol->dev.groups = control_groups;\n\tcontrol->dev.dma_mask = intf->dev.dma_mask;\n\tdevice_initialize(&control->dev);\n\tdev_set_name(&control->dev, \"%s.ctrl\", dev_name(&intf->dev));\n\n\tgb_connection_set_data(control->connection, control);\n\n\treturn control;\n}\n\nint gb_control_enable(struct gb_control *control)\n{\n\tint ret;\n\n\tdev_dbg(&control->connection->intf->dev, \"%s\\n\", __func__);\n\n\tret = gb_connection_enable_tx(control->connection);\n\tif (ret) {\n\t\tdev_err(&control->connection->intf->dev,\n\t\t\t\"failed to enable control connection: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = gb_control_get_version(control);\n\tif (ret)\n\t\tgoto err_disable_connection;\n\n\tif (control->protocol_major > 0 || control->protocol_minor > 1)\n\t\tcontrol->has_bundle_version = true;\n\n\t \n\tif (!(control->intf->quirks & GB_INTERFACE_QUIRK_NO_BUNDLE_ACTIVATE))\n\t\tcontrol->has_bundle_activate = true;\n\n\treturn 0;\n\nerr_disable_connection:\n\tgb_connection_disable(control->connection);\n\n\treturn ret;\n}\n\nvoid gb_control_disable(struct gb_control *control)\n{\n\tdev_dbg(&control->connection->intf->dev, \"%s\\n\", __func__);\n\n\tif (control->intf->disconnected)\n\t\tgb_connection_disable_forced(control->connection);\n\telse\n\t\tgb_connection_disable(control->connection);\n}\n\nint gb_control_suspend(struct gb_control *control)\n{\n\tgb_connection_disable(control->connection);\n\n\treturn 0;\n}\n\nint gb_control_resume(struct gb_control *control)\n{\n\tint ret;\n\n\tret = gb_connection_enable_tx(control->connection);\n\tif (ret) {\n\t\tdev_err(&control->connection->intf->dev,\n\t\t\t\"failed to enable control connection: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint gb_control_add(struct gb_control *control)\n{\n\tint ret;\n\n\tret = device_add(&control->dev);\n\tif (ret) {\n\t\tdev_err(&control->dev,\n\t\t\t\"failed to register control device: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid gb_control_del(struct gb_control *control)\n{\n\tif (device_is_registered(&control->dev))\n\t\tdevice_del(&control->dev);\n}\n\nstruct gb_control *gb_control_get(struct gb_control *control)\n{\n\tget_device(&control->dev);\n\n\treturn control;\n}\n\nvoid gb_control_put(struct gb_control *control)\n{\n\tput_device(&control->dev);\n}\n\nvoid gb_control_mode_switch_prepare(struct gb_control *control)\n{\n\tgb_connection_mode_switch_prepare(control->connection);\n}\n\nvoid gb_control_mode_switch_complete(struct gb_control *control)\n{\n\tgb_connection_mode_switch_complete(control->connection);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}