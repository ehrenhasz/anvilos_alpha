{
  "module_name": "manifest.c",
  "hash_id": "ff2aba8a43bca90303c41728fddba420549e740f5d5202975a9830c3021b43ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/manifest.c",
  "human_readable_source": "\n \n\n#include <linux/greybus.h>\n\nstatic const char *get_descriptor_type_string(u8 type)\n{\n\tswitch (type) {\n\tcase GREYBUS_TYPE_INVALID:\n\t\treturn \"invalid\";\n\tcase GREYBUS_TYPE_STRING:\n\t\treturn \"string\";\n\tcase GREYBUS_TYPE_INTERFACE:\n\t\treturn \"interface\";\n\tcase GREYBUS_TYPE_CPORT:\n\t\treturn \"cport\";\n\tcase GREYBUS_TYPE_BUNDLE:\n\t\treturn \"bundle\";\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstruct manifest_desc {\n\tstruct list_head\t\tlinks;\n\n\tsize_t\t\t\t\tsize;\n\tvoid\t\t\t\t*data;\n\tenum greybus_descriptor_type\ttype;\n};\n\nstatic void release_manifest_descriptor(struct manifest_desc *descriptor)\n{\n\tlist_del(&descriptor->links);\n\tkfree(descriptor);\n}\n\nstatic void release_manifest_descriptors(struct gb_interface *intf)\n{\n\tstruct manifest_desc *descriptor;\n\tstruct manifest_desc *next;\n\n\tlist_for_each_entry_safe(descriptor, next, &intf->manifest_descs, links)\n\t\trelease_manifest_descriptor(descriptor);\n}\n\nstatic void release_cport_descriptors(struct list_head *head, u8 bundle_id)\n{\n\tstruct manifest_desc *desc, *tmp;\n\tstruct greybus_descriptor_cport *desc_cport;\n\n\tlist_for_each_entry_safe(desc, tmp, head, links) {\n\t\tdesc_cport = desc->data;\n\n\t\tif (desc->type != GREYBUS_TYPE_CPORT)\n\t\t\tcontinue;\n\n\t\tif (desc_cport->bundle == bundle_id)\n\t\t\trelease_manifest_descriptor(desc);\n\t}\n}\n\nstatic struct manifest_desc *get_next_bundle_desc(struct gb_interface *intf)\n{\n\tstruct manifest_desc *descriptor;\n\tstruct manifest_desc *next;\n\n\tlist_for_each_entry_safe(descriptor, next, &intf->manifest_descs, links)\n\t\tif (descriptor->type == GREYBUS_TYPE_BUNDLE)\n\t\t\treturn descriptor;\n\n\treturn NULL;\n}\n\n \nstatic int identify_descriptor(struct gb_interface *intf,\n\t\t\t       struct greybus_descriptor *desc, size_t size)\n{\n\tstruct greybus_descriptor_header *desc_header = &desc->header;\n\tstruct manifest_desc *descriptor;\n\tsize_t desc_size;\n\tsize_t expected_size;\n\n\tif (size < sizeof(*desc_header)) {\n\t\tdev_err(&intf->dev, \"manifest too small (%zu < %zu)\\n\", size,\n\t\t\tsizeof(*desc_header));\n\t\treturn -EINVAL;\t\t \n\t}\n\n\tdesc_size = le16_to_cpu(desc_header->size);\n\tif (desc_size > size) {\n\t\tdev_err(&intf->dev, \"descriptor too big (%zu > %zu)\\n\",\n\t\t\tdesc_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\texpected_size = sizeof(*desc_header);\n\n\tswitch (desc_header->type) {\n\tcase GREYBUS_TYPE_STRING:\n\t\texpected_size += sizeof(struct greybus_descriptor_string);\n\t\texpected_size += desc->string.length;\n\n\t\t \n\t\texpected_size = ALIGN(expected_size, 4);\n\t\tbreak;\n\tcase GREYBUS_TYPE_INTERFACE:\n\t\texpected_size += sizeof(struct greybus_descriptor_interface);\n\t\tbreak;\n\tcase GREYBUS_TYPE_BUNDLE:\n\t\texpected_size += sizeof(struct greybus_descriptor_bundle);\n\t\tbreak;\n\tcase GREYBUS_TYPE_CPORT:\n\t\texpected_size += sizeof(struct greybus_descriptor_cport);\n\t\tbreak;\n\tcase GREYBUS_TYPE_INVALID:\n\tdefault:\n\t\tdev_err(&intf->dev, \"invalid descriptor type (%u)\\n\",\n\t\t\tdesc_header->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc_size < expected_size) {\n\t\tdev_err(&intf->dev, \"%s descriptor too small (%zu < %zu)\\n\",\n\t\t\tget_descriptor_type_string(desc_header->type),\n\t\t\tdesc_size, expected_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (desc_size > expected_size) {\n\t\tdev_warn(&intf->dev, \"%s descriptor size mismatch (want %zu got %zu)\\n\",\n\t\t\t get_descriptor_type_string(desc_header->type),\n\t\t\t expected_size, desc_size);\n\t}\n\n\tdescriptor = kzalloc(sizeof(*descriptor), GFP_KERNEL);\n\tif (!descriptor)\n\t\treturn -ENOMEM;\n\n\tdescriptor->size = desc_size;\n\tdescriptor->data = (char *)desc + sizeof(*desc_header);\n\tdescriptor->type = desc_header->type;\n\tlist_add_tail(&descriptor->links, &intf->manifest_descs);\n\n\t \n\n\treturn desc_size;\n}\n\n \nstatic char *gb_string_get(struct gb_interface *intf, u8 string_id)\n{\n\tstruct greybus_descriptor_string *desc_string;\n\tstruct manifest_desc *descriptor;\n\tbool found = false;\n\tchar *string;\n\n\t \n\tif (!string_id)\n\t\treturn NULL;\n\n\tlist_for_each_entry(descriptor, &intf->manifest_descs, links) {\n\t\tif (descriptor->type != GREYBUS_TYPE_STRING)\n\t\t\tcontinue;\n\n\t\tdesc_string = descriptor->data;\n\t\tif (desc_string->id == string_id) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\tstring = kmemdup(&desc_string->string, desc_string->length + 1,\n\t\t\t GFP_KERNEL);\n\tif (!string)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstring[desc_string->length] = '\\0';\n\n\t \n\trelease_manifest_descriptor(descriptor);\n\n\treturn string;\n}\n\n \nstatic u32 gb_manifest_parse_cports(struct gb_bundle *bundle)\n{\n\tstruct gb_interface *intf = bundle->intf;\n\tstruct greybus_descriptor_cport *desc_cport;\n\tstruct manifest_desc *desc, *next, *tmp;\n\tLIST_HEAD(list);\n\tu8 bundle_id = bundle->id;\n\tu16 cport_id;\n\tu32 count = 0;\n\tint i;\n\n\t \n\tlist_for_each_entry_safe(desc, next, &intf->manifest_descs, links) {\n\t\tif (desc->type != GREYBUS_TYPE_CPORT)\n\t\t\tcontinue;\n\n\t\tdesc_cport = desc->data;\n\t\tif (desc_cport->bundle != bundle_id)\n\t\t\tcontinue;\n\n\t\tcport_id = le16_to_cpu(desc_cport->id);\n\t\tif (cport_id > CPORT_ID_MAX)\n\t\t\tgoto exit;\n\n\t\t \n\t\tif (cport_id == GB_CONTROL_CPORT_ID) {\n\t\t\tdev_err(&bundle->dev, \"invalid cport id found (%02u)\\n\",\n\t\t\t\tcport_id);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(tmp, &list, links) {\n\t\t\tdesc_cport = tmp->data;\n\t\t\tif (cport_id == le16_to_cpu(desc_cport->id)) {\n\t\t\t\tdev_err(&bundle->dev,\n\t\t\t\t\t\"duplicate CPort %u found\\n\", cport_id);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tlist_move_tail(&desc->links, &list);\n\t\tcount++;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tbundle->cport_desc = kcalloc(count, sizeof(*bundle->cport_desc),\n\t\t\t\t     GFP_KERNEL);\n\tif (!bundle->cport_desc)\n\t\tgoto exit;\n\n\tbundle->num_cports = count;\n\n\ti = 0;\n\tlist_for_each_entry_safe(desc, next, &list, links) {\n\t\tdesc_cport = desc->data;\n\t\tmemcpy(&bundle->cport_desc[i++], desc_cport,\n\t\t       sizeof(*desc_cport));\n\n\t\t \n\t\trelease_manifest_descriptor(desc);\n\t}\n\n\treturn count;\nexit:\n\trelease_cport_descriptors(&list, bundle_id);\n\t \n\trelease_cport_descriptors(&intf->manifest_descs, bundle_id);\n\n\treturn 0;\t \n}\n\n \nstatic u32 gb_manifest_parse_bundles(struct gb_interface *intf)\n{\n\tstruct manifest_desc *desc;\n\tstruct gb_bundle *bundle;\n\tstruct gb_bundle *bundle_next;\n\tu32 count = 0;\n\tu8 bundle_id;\n\tu8 class;\n\n\twhile ((desc = get_next_bundle_desc(intf))) {\n\t\tstruct greybus_descriptor_bundle *desc_bundle;\n\n\t\t \n\t\tdesc_bundle = desc->data;\n\t\tbundle_id = desc_bundle->id;\n\t\tclass = desc_bundle->class;\n\n\t\t \n\t\trelease_manifest_descriptor(desc);\n\n\t\t \n\t\tif (bundle_id == GB_CONTROL_BUNDLE_ID) {\n\t\t\tdev_dbg(&intf->dev, \"%s - ignoring control bundle\\n\",\n\t\t\t\t__func__);\n\t\t\trelease_cport_descriptors(&intf->manifest_descs,\n\t\t\t\t\t\t  bundle_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (class == GREYBUS_CLASS_CONTROL) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"bundle %u cannot use control class\\n\",\n\t\t\t\tbundle_id);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tbundle = gb_bundle_create(intf, bundle_id, class);\n\t\tif (!bundle)\n\t\t\tgoto cleanup;\n\n\t\t \n\t\tif (!gb_manifest_parse_cports(bundle)) {\n\t\t\tgb_bundle_destroy(bundle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\ncleanup:\n\t \n\tlist_for_each_entry_safe(bundle, bundle_next, &intf->bundles, links) {\n\t\tgb_bundle_destroy(bundle);\n\t\tcount--;\n\t}\n\treturn 0;\t \n}\n\nstatic bool gb_manifest_parse_interface(struct gb_interface *intf,\n\t\t\t\t\tstruct manifest_desc *interface_desc)\n{\n\tstruct greybus_descriptor_interface *desc_intf = interface_desc->data;\n\tstruct gb_control *control = intf->control;\n\tchar *str;\n\n\t \n\tstr = gb_string_get(intf, desc_intf->vendor_stringid);\n\tif (IS_ERR(str))\n\t\treturn false;\n\tcontrol->vendor_string = str;\n\n\tstr = gb_string_get(intf, desc_intf->product_stringid);\n\tif (IS_ERR(str))\n\t\tgoto out_free_vendor_string;\n\tcontrol->product_string = str;\n\n\t \n\tintf->features = desc_intf->features;\n\n\t \n\trelease_manifest_descriptor(interface_desc);\n\n\t \n\tif (!gb_manifest_parse_bundles(intf)) {\n\t\tdev_err(&intf->dev, \"manifest bundle descriptors not valid\\n\");\n\t\tgoto out_err;\n\t}\n\n\treturn true;\nout_err:\n\tkfree(control->product_string);\n\tcontrol->product_string = NULL;\nout_free_vendor_string:\n\tkfree(control->vendor_string);\n\tcontrol->vendor_string = NULL;\n\n\treturn false;\n}\n\n \nbool gb_manifest_parse(struct gb_interface *intf, void *data, size_t size)\n{\n\tstruct greybus_manifest *manifest;\n\tstruct greybus_manifest_header *header;\n\tstruct greybus_descriptor *desc;\n\tstruct manifest_desc *descriptor;\n\tstruct manifest_desc *interface_desc = NULL;\n\tu16 manifest_size;\n\tu32 found = 0;\n\tbool result;\n\n\t \n\tif (WARN_ON(!list_empty(&intf->manifest_descs)))\n\t\treturn false;\n\n\t \n\tif (size < sizeof(*header)) {\n\t\tdev_err(&intf->dev, \"short manifest (%zu < %zu)\\n\",\n\t\t\tsize, sizeof(*header));\n\t\treturn false;\n\t}\n\n\t \n\tmanifest = data;\n\theader = &manifest->header;\n\tmanifest_size = le16_to_cpu(header->size);\n\tif (manifest_size != size) {\n\t\tdev_err(&intf->dev, \"manifest size mismatch (%zu != %u)\\n\",\n\t\t\tsize, manifest_size);\n\t\treturn false;\n\t}\n\n\t \n\tif (header->version_major > GREYBUS_VERSION_MAJOR) {\n\t\tdev_err(&intf->dev, \"manifest version too new (%u.%u > %u.%u)\\n\",\n\t\t\theader->version_major, header->version_minor,\n\t\t\tGREYBUS_VERSION_MAJOR, GREYBUS_VERSION_MINOR);\n\t\treturn false;\n\t}\n\n\t \n\tdesc = manifest->descriptors;\n\tsize -= sizeof(*header);\n\twhile (size) {\n\t\tint desc_size;\n\n\t\tdesc_size = identify_descriptor(intf, desc, size);\n\t\tif (desc_size < 0) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tdesc = (struct greybus_descriptor *)((char *)desc + desc_size);\n\t\tsize -= desc_size;\n\t}\n\n\t \n\tlist_for_each_entry(descriptor, &intf->manifest_descs, links) {\n\t\tif (descriptor->type == GREYBUS_TYPE_INTERFACE)\n\t\t\tif (!found++)\n\t\t\t\tinterface_desc = descriptor;\n\t}\n\tif (found != 1) {\n\t\tdev_err(&intf->dev, \"manifest must have 1 interface descriptor (%u found)\\n\",\n\t\t\tfound);\n\t\tresult = false;\n\t\tgoto out;\n\t}\n\n\t \n\tresult = gb_manifest_parse_interface(intf, interface_desc);\n\n\t \n\tif (result && !list_empty(&intf->manifest_descs))\n\t\tdev_info(&intf->dev, \"excess descriptors in interface manifest\\n\");\nout:\n\trelease_manifest_descriptors(intf);\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}