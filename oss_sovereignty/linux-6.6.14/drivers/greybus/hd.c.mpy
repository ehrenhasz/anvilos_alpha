{
  "module_name": "hd.c",
  "hash_id": "eb9df8e44b61b98b30cfeedf0ad70a47f176c8f864209fdd5711c687555c4cdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/hd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/greybus.h>\n\n#include \"greybus_trace.h\"\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_hd_create);\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_hd_release);\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_hd_add);\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_hd_del);\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_hd_in);\nEXPORT_TRACEPOINT_SYMBOL_GPL(gb_message_submit);\n\nstatic struct ida gb_hd_bus_id_map;\n\nint gb_hd_output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,\n\t\t bool async)\n{\n\tif (!hd || !hd->driver || !hd->driver->output)\n\t\treturn -EINVAL;\n\treturn hd->driver->output(hd, req, size, cmd, async);\n}\nEXPORT_SYMBOL_GPL(gb_hd_output);\n\nstatic ssize_t bus_id_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gb_host_device *hd = to_gb_host_device(dev);\n\n\treturn sprintf(buf, \"%d\\n\", hd->bus_id);\n}\nstatic DEVICE_ATTR_RO(bus_id);\n\nstatic struct attribute *bus_attrs[] = {\n\t&dev_attr_bus_id.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(bus);\n\nint gb_hd_cport_reserve(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct ida *id_map = &hd->cport_id_map;\n\tint ret;\n\n\tret = ida_simple_get(id_map, cport_id, cport_id + 1, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(&hd->dev, \"failed to reserve cport %u\\n\", cport_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gb_hd_cport_reserve);\n\nvoid gb_hd_cport_release_reserved(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct ida *id_map = &hd->cport_id_map;\n\n\tida_simple_remove(id_map, cport_id);\n}\nEXPORT_SYMBOL_GPL(gb_hd_cport_release_reserved);\n\n \nint gb_hd_cport_allocate(struct gb_host_device *hd, int cport_id,\n\t\t\t unsigned long flags)\n{\n\tstruct ida *id_map = &hd->cport_id_map;\n\tint ida_start, ida_end;\n\n\tif (hd->driver->cport_allocate)\n\t\treturn hd->driver->cport_allocate(hd, cport_id, flags);\n\n\tif (cport_id < 0) {\n\t\tida_start = 0;\n\t\tida_end = hd->num_cports;\n\t} else if (cport_id < hd->num_cports) {\n\t\tida_start = cport_id;\n\t\tida_end = cport_id + 1;\n\t} else {\n\t\tdev_err(&hd->dev, \"cport %d not available\\n\", cport_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ida_simple_get(id_map, ida_start, ida_end, GFP_KERNEL);\n}\n\n \nvoid gb_hd_cport_release(struct gb_host_device *hd, u16 cport_id)\n{\n\tif (hd->driver->cport_release) {\n\t\thd->driver->cport_release(hd, cport_id);\n\t\treturn;\n\t}\n\n\tida_simple_remove(&hd->cport_id_map, cport_id);\n}\n\nstatic void gb_hd_release(struct device *dev)\n{\n\tstruct gb_host_device *hd = to_gb_host_device(dev);\n\n\ttrace_gb_hd_release(hd);\n\n\tif (hd->svc)\n\t\tgb_svc_put(hd->svc);\n\tida_simple_remove(&gb_hd_bus_id_map, hd->bus_id);\n\tida_destroy(&hd->cport_id_map);\n\tkfree(hd);\n}\n\nstruct device_type greybus_hd_type = {\n\t.name\t\t= \"greybus_host_device\",\n\t.release\t= gb_hd_release,\n};\n\nstruct gb_host_device *gb_hd_create(struct gb_hd_driver *driver,\n\t\t\t\t    struct device *parent,\n\t\t\t\t    size_t buffer_size_max,\n\t\t\t\t    size_t num_cports)\n{\n\tstruct gb_host_device *hd;\n\tint ret;\n\n\t \n\tif ((!driver->message_send) || (!driver->message_cancel)) {\n\t\tdev_err(parent, \"mandatory hd-callbacks missing\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (buffer_size_max < GB_OPERATION_MESSAGE_SIZE_MIN) {\n\t\tdev_err(parent, \"greybus host-device buffers too small\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (num_cports == 0 || num_cports > CPORT_ID_MAX + 1) {\n\t\tdev_err(parent, \"Invalid number of CPorts: %zu\\n\", num_cports);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (buffer_size_max > GB_OPERATION_MESSAGE_SIZE_MAX) {\n\t\tdev_warn(parent, \"limiting buffer size to %u\\n\",\n\t\t\t GB_OPERATION_MESSAGE_SIZE_MAX);\n\t\tbuffer_size_max = GB_OPERATION_MESSAGE_SIZE_MAX;\n\t}\n\n\thd = kzalloc(sizeof(*hd) + driver->hd_priv_size, GFP_KERNEL);\n\tif (!hd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_simple_get(&gb_hd_bus_id_map, 1, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(hd);\n\t\treturn ERR_PTR(ret);\n\t}\n\thd->bus_id = ret;\n\n\thd->driver = driver;\n\tINIT_LIST_HEAD(&hd->modules);\n\tINIT_LIST_HEAD(&hd->connections);\n\tida_init(&hd->cport_id_map);\n\thd->buffer_size_max = buffer_size_max;\n\thd->num_cports = num_cports;\n\n\thd->dev.parent = parent;\n\thd->dev.bus = &greybus_bus_type;\n\thd->dev.type = &greybus_hd_type;\n\thd->dev.groups = bus_groups;\n\thd->dev.dma_mask = hd->dev.parent->dma_mask;\n\tdevice_initialize(&hd->dev);\n\tdev_set_name(&hd->dev, \"greybus%d\", hd->bus_id);\n\n\ttrace_gb_hd_create(hd);\n\n\thd->svc = gb_svc_create(hd);\n\tif (!hd->svc) {\n\t\tdev_err(&hd->dev, \"failed to create svc\\n\");\n\t\tput_device(&hd->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn hd;\n}\nEXPORT_SYMBOL_GPL(gb_hd_create);\n\nint gb_hd_add(struct gb_host_device *hd)\n{\n\tint ret;\n\n\tret = device_add(&hd->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_svc_add(hd->svc);\n\tif (ret) {\n\t\tdevice_del(&hd->dev);\n\t\treturn ret;\n\t}\n\n\ttrace_gb_hd_add(hd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gb_hd_add);\n\nvoid gb_hd_del(struct gb_host_device *hd)\n{\n\ttrace_gb_hd_del(hd);\n\n\t \n\tgb_svc_del(hd->svc);\n\n\tdevice_del(&hd->dev);\n}\nEXPORT_SYMBOL_GPL(gb_hd_del);\n\nvoid gb_hd_shutdown(struct gb_host_device *hd)\n{\n\tgb_svc_del(hd->svc);\n}\nEXPORT_SYMBOL_GPL(gb_hd_shutdown);\n\nvoid gb_hd_put(struct gb_host_device *hd)\n{\n\tput_device(&hd->dev);\n}\nEXPORT_SYMBOL_GPL(gb_hd_put);\n\nint __init gb_hd_init(void)\n{\n\tida_init(&gb_hd_bus_id_map);\n\n\treturn 0;\n}\n\nvoid gb_hd_exit(void)\n{\n\tida_destroy(&gb_hd_bus_id_map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}