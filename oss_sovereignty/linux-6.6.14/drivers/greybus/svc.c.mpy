{
  "module_name": "svc.c",
  "hash_id": "09bbddd0cd325933618793c2da4c4035aa102313fccf10324666757275c7ce47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/svc.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/kstrtox.h>\n#include <linux/workqueue.h>\n#include <linux/greybus.h>\n\n#define SVC_INTF_EJECT_TIMEOUT\t\t9000\n#define SVC_INTF_ACTIVATE_TIMEOUT\t6000\n#define SVC_INTF_RESUME_TIMEOUT\t\t3000\n\nstruct gb_svc_deferred_request {\n\tstruct work_struct work;\n\tstruct gb_operation *operation;\n};\n\nstatic int gb_svc_queue_deferred_request(struct gb_operation *operation);\n\nstatic ssize_t endo_id_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\treturn sprintf(buf, \"0x%04x\\n\", svc->endo_id);\n}\nstatic DEVICE_ATTR_RO(endo_id);\n\nstatic ssize_t ap_intf_id_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\treturn sprintf(buf, \"%u\\n\", svc->ap_intf_id);\n}\nstatic DEVICE_ATTR_RO(ap_intf_id);\n\n\n\n\n\n\nstatic ssize_t intf_eject_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\tunsigned short intf_id;\n\tint ret;\n\n\tret = kstrtou16(buf, 10, &intf_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_warn(dev, \"Forcibly trying to eject interface %d\\n\", intf_id);\n\n\tret = gb_svc_intf_eject(svc, intf_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_WO(intf_eject);\n\nstatic ssize_t watchdog_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       gb_svc_watchdog_enabled(svc) ? \"enabled\" : \"disabled\");\n}\n\nstatic ssize_t watchdog_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t len)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\tint retval;\n\tbool user_request;\n\n\tretval = kstrtobool(buf, &user_request);\n\tif (retval)\n\t\treturn retval;\n\n\tif (user_request)\n\t\tretval = gb_svc_watchdog_enable(svc);\n\telse\n\t\tretval = gb_svc_watchdog_disable(svc);\n\tif (retval)\n\t\treturn retval;\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(watchdog);\n\nstatic ssize_t watchdog_action_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\tif (svc->action == GB_SVC_WATCHDOG_BITE_PANIC_KERNEL)\n\t\treturn sprintf(buf, \"panic\\n\");\n\telse if (svc->action == GB_SVC_WATCHDOG_BITE_RESET_UNIPRO)\n\t\treturn sprintf(buf, \"reset\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t watchdog_action_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\tif (sysfs_streq(buf, \"panic\"))\n\t\tsvc->action = GB_SVC_WATCHDOG_BITE_PANIC_KERNEL;\n\telse if (sysfs_streq(buf, \"reset\"))\n\t\tsvc->action = GB_SVC_WATCHDOG_BITE_RESET_UNIPRO;\n\telse\n\t\treturn -EINVAL;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(watchdog_action);\n\nstatic int gb_svc_pwrmon_rail_count_get(struct gb_svc *svc, u8 *value)\n{\n\tstruct gb_svc_pwrmon_rail_count_get_response response;\n\tint ret;\n\n\tret = gb_operation_sync(svc->connection,\n\t\t\t\tGB_SVC_TYPE_PWRMON_RAIL_COUNT_GET, NULL, 0,\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get rail count: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*value = response.rail_count;\n\n\treturn 0;\n}\n\nstatic int gb_svc_pwrmon_rail_names_get(struct gb_svc *svc,\n\t\tstruct gb_svc_pwrmon_rail_names_get_response *response,\n\t\tsize_t bufsize)\n{\n\tint ret;\n\n\tret = gb_operation_sync(svc->connection,\n\t\t\t\tGB_SVC_TYPE_PWRMON_RAIL_NAMES_GET, NULL, 0,\n\t\t\t\tresponse, bufsize);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get rail names: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (response->status != GB_SVC_OP_SUCCESS) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"SVC error while getting rail names: %u\\n\",\n\t\t\tresponse->status);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_svc_pwrmon_sample_get(struct gb_svc *svc, u8 rail_id,\n\t\t\t\t    u8 measurement_type, u32 *value)\n{\n\tstruct gb_svc_pwrmon_sample_get_request request;\n\tstruct gb_svc_pwrmon_sample_get_response response;\n\tint ret;\n\n\trequest.rail_id = rail_id;\n\trequest.measurement_type = measurement_type;\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_PWRMON_SAMPLE_GET,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get rail sample: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (response.result) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"UniPro error while getting rail power sample (%d %d): %d\\n\",\n\t\t\trail_id, measurement_type, response.result);\n\t\tswitch (response.result) {\n\t\tcase GB_SVC_PWRMON_GET_SAMPLE_INVAL:\n\t\t\treturn -EINVAL;\n\t\tcase GB_SVC_PWRMON_GET_SAMPLE_NOSUPP:\n\t\t\treturn -ENOMSG;\n\t\tdefault:\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\n\t*value = le32_to_cpu(response.measurement);\n\n\treturn 0;\n}\n\nint gb_svc_pwrmon_intf_sample_get(struct gb_svc *svc, u8 intf_id,\n\t\t\t\t  u8 measurement_type, u32 *value)\n{\n\tstruct gb_svc_pwrmon_intf_sample_get_request request;\n\tstruct gb_svc_pwrmon_intf_sample_get_response response;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\trequest.measurement_type = measurement_type;\n\n\tret = gb_operation_sync(svc->connection,\n\t\t\t\tGB_SVC_TYPE_PWRMON_INTF_SAMPLE_GET,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get intf sample: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (response.result) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"UniPro error while getting intf power sample (%d %d): %d\\n\",\n\t\t\tintf_id, measurement_type, response.result);\n\t\tswitch (response.result) {\n\t\tcase GB_SVC_PWRMON_GET_SAMPLE_INVAL:\n\t\t\treturn -EINVAL;\n\t\tcase GB_SVC_PWRMON_GET_SAMPLE_NOSUPP:\n\t\t\treturn -ENOMSG;\n\t\tdefault:\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\n\t*value = le32_to_cpu(response.measurement);\n\n\treturn 0;\n}\n\nstatic struct attribute *svc_attrs[] = {\n\t&dev_attr_endo_id.attr,\n\t&dev_attr_ap_intf_id.attr,\n\t&dev_attr_intf_eject.attr,\n\t&dev_attr_watchdog.attr,\n\t&dev_attr_watchdog_action.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(svc);\n\nint gb_svc_intf_device_id(struct gb_svc *svc, u8 intf_id, u8 device_id)\n{\n\tstruct gb_svc_intf_device_id_request request;\n\n\trequest.intf_id = intf_id;\n\trequest.device_id = device_id;\n\n\treturn gb_operation_sync(svc->connection, GB_SVC_TYPE_INTF_DEVICE_ID,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nint gb_svc_intf_eject(struct gb_svc *svc, u8 intf_id)\n{\n\tstruct gb_svc_intf_eject_request request;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\n\t \n\tret = gb_operation_sync_timeout(svc->connection,\n\t\t\t\t\tGB_SVC_TYPE_INTF_EJECT, &request,\n\t\t\t\t\tsizeof(request), NULL, 0,\n\t\t\t\t\tSVC_INTF_EJECT_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to eject interface %u\\n\", intf_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint gb_svc_intf_vsys_set(struct gb_svc *svc, u8 intf_id, bool enable)\n{\n\tstruct gb_svc_intf_vsys_request request;\n\tstruct gb_svc_intf_vsys_response response;\n\tint type, ret;\n\n\trequest.intf_id = intf_id;\n\n\tif (enable)\n\t\ttype = GB_SVC_TYPE_INTF_VSYS_ENABLE;\n\telse\n\t\ttype = GB_SVC_TYPE_INTF_VSYS_DISABLE;\n\n\tret = gb_operation_sync(svc->connection, type,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (response.result_code != GB_SVC_INTF_VSYS_OK)\n\t\treturn -EREMOTEIO;\n\treturn 0;\n}\n\nint gb_svc_intf_refclk_set(struct gb_svc *svc, u8 intf_id, bool enable)\n{\n\tstruct gb_svc_intf_refclk_request request;\n\tstruct gb_svc_intf_refclk_response response;\n\tint type, ret;\n\n\trequest.intf_id = intf_id;\n\n\tif (enable)\n\t\ttype = GB_SVC_TYPE_INTF_REFCLK_ENABLE;\n\telse\n\t\ttype = GB_SVC_TYPE_INTF_REFCLK_DISABLE;\n\n\tret = gb_operation_sync(svc->connection, type,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (response.result_code != GB_SVC_INTF_REFCLK_OK)\n\t\treturn -EREMOTEIO;\n\treturn 0;\n}\n\nint gb_svc_intf_unipro_set(struct gb_svc *svc, u8 intf_id, bool enable)\n{\n\tstruct gb_svc_intf_unipro_request request;\n\tstruct gb_svc_intf_unipro_response response;\n\tint type, ret;\n\n\trequest.intf_id = intf_id;\n\n\tif (enable)\n\t\ttype = GB_SVC_TYPE_INTF_UNIPRO_ENABLE;\n\telse\n\t\ttype = GB_SVC_TYPE_INTF_UNIPRO_DISABLE;\n\n\tret = gb_operation_sync(svc->connection, type,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (response.result_code != GB_SVC_INTF_UNIPRO_OK)\n\t\treturn -EREMOTEIO;\n\treturn 0;\n}\n\nint gb_svc_intf_activate(struct gb_svc *svc, u8 intf_id, u8 *intf_type)\n{\n\tstruct gb_svc_intf_activate_request request;\n\tstruct gb_svc_intf_activate_response response;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\n\tret = gb_operation_sync_timeout(svc->connection,\n\t\t\t\t\tGB_SVC_TYPE_INTF_ACTIVATE,\n\t\t\t\t\t&request, sizeof(request),\n\t\t\t\t\t&response, sizeof(response),\n\t\t\t\t\tSVC_INTF_ACTIVATE_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (response.status != GB_SVC_OP_SUCCESS) {\n\t\tdev_err(&svc->dev, \"failed to activate interface %u: %u\\n\",\n\t\t\tintf_id, response.status);\n\t\treturn -EREMOTEIO;\n\t}\n\n\t*intf_type = response.intf_type;\n\n\treturn 0;\n}\n\nint gb_svc_intf_resume(struct gb_svc *svc, u8 intf_id)\n{\n\tstruct gb_svc_intf_resume_request request;\n\tstruct gb_svc_intf_resume_response response;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\n\tret = gb_operation_sync_timeout(svc->connection,\n\t\t\t\t\tGB_SVC_TYPE_INTF_RESUME,\n\t\t\t\t\t&request, sizeof(request),\n\t\t\t\t\t&response, sizeof(response),\n\t\t\t\t\tSVC_INTF_RESUME_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&svc->dev, \"failed to send interface resume %u: %d\\n\",\n\t\t\tintf_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (response.status != GB_SVC_OP_SUCCESS) {\n\t\tdev_err(&svc->dev, \"failed to resume interface %u: %u\\n\",\n\t\t\tintf_id, response.status);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nint gb_svc_dme_peer_get(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,\n\t\t\tu32 *value)\n{\n\tstruct gb_svc_dme_peer_get_request request;\n\tstruct gb_svc_dme_peer_get_response response;\n\tu16 result;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\trequest.attr = cpu_to_le16(attr);\n\trequest.selector = cpu_to_le16(selector);\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_DME_PEER_GET,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get DME attribute (%u 0x%04x %u): %d\\n\",\n\t\t\tintf_id, attr, selector, ret);\n\t\treturn ret;\n\t}\n\n\tresult = le16_to_cpu(response.result_code);\n\tif (result) {\n\t\tdev_err(&svc->dev, \"UniPro error while getting DME attribute (%u 0x%04x %u): %u\\n\",\n\t\t\tintf_id, attr, selector, result);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (value)\n\t\t*value = le32_to_cpu(response.attr_value);\n\n\treturn 0;\n}\n\nint gb_svc_dme_peer_set(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,\n\t\t\tu32 value)\n{\n\tstruct gb_svc_dme_peer_set_request request;\n\tstruct gb_svc_dme_peer_set_response response;\n\tu16 result;\n\tint ret;\n\n\trequest.intf_id = intf_id;\n\trequest.attr = cpu_to_le16(attr);\n\trequest.selector = cpu_to_le16(selector);\n\trequest.value = cpu_to_le32(value);\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_DME_PEER_SET,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to set DME attribute (%u 0x%04x %u %u): %d\\n\",\n\t\t\tintf_id, attr, selector, value, ret);\n\t\treturn ret;\n\t}\n\n\tresult = le16_to_cpu(response.result_code);\n\tif (result) {\n\t\tdev_err(&svc->dev, \"UniPro error while setting DME attribute (%u 0x%04x %u %u): %u\\n\",\n\t\t\tintf_id, attr, selector, value, result);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nint gb_svc_connection_create(struct gb_svc *svc,\n\t\t\t     u8 intf1_id, u16 cport1_id,\n\t\t\t     u8 intf2_id, u16 cport2_id,\n\t\t\t     u8 cport_flags)\n{\n\tstruct gb_svc_conn_create_request request;\n\n\trequest.intf1_id = intf1_id;\n\trequest.cport1_id = cpu_to_le16(cport1_id);\n\trequest.intf2_id = intf2_id;\n\trequest.cport2_id = cpu_to_le16(cport2_id);\n\trequest.tc = 0;\t\t \n\trequest.flags = cport_flags;\n\n\treturn gb_operation_sync(svc->connection, GB_SVC_TYPE_CONN_CREATE,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\nvoid gb_svc_connection_destroy(struct gb_svc *svc, u8 intf1_id, u16 cport1_id,\n\t\t\t       u8 intf2_id, u16 cport2_id)\n{\n\tstruct gb_svc_conn_destroy_request request;\n\tstruct gb_connection *connection = svc->connection;\n\tint ret;\n\n\trequest.intf1_id = intf1_id;\n\trequest.cport1_id = cpu_to_le16(cport1_id);\n\trequest.intf2_id = intf2_id;\n\trequest.cport2_id = cpu_to_le16(cport2_id);\n\n\tret = gb_operation_sync(connection, GB_SVC_TYPE_CONN_DESTROY,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to destroy connection (%u:%u %u:%u): %d\\n\",\n\t\t\tintf1_id, cport1_id, intf2_id, cport2_id, ret);\n\t}\n}\n\n \nint gb_svc_route_create(struct gb_svc *svc, u8 intf1_id, u8 dev1_id,\n\t\t\tu8 intf2_id, u8 dev2_id)\n{\n\tstruct gb_svc_route_create_request request;\n\n\trequest.intf1_id = intf1_id;\n\trequest.dev1_id = dev1_id;\n\trequest.intf2_id = intf2_id;\n\trequest.dev2_id = dev2_id;\n\n\treturn gb_operation_sync(svc->connection, GB_SVC_TYPE_ROUTE_CREATE,\n\t\t\t\t &request, sizeof(request), NULL, 0);\n}\n\n \nvoid gb_svc_route_destroy(struct gb_svc *svc, u8 intf1_id, u8 intf2_id)\n{\n\tstruct gb_svc_route_destroy_request request;\n\tint ret;\n\n\trequest.intf1_id = intf1_id;\n\trequest.intf2_id = intf2_id;\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_ROUTE_DESTROY,\n\t\t\t\t&request, sizeof(request), NULL, 0);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to destroy route (%u %u): %d\\n\",\n\t\t\tintf1_id, intf2_id, ret);\n\t}\n}\n\nint gb_svc_intf_set_power_mode(struct gb_svc *svc, u8 intf_id, u8 hs_series,\n\t\t\t       u8 tx_mode, u8 tx_gear, u8 tx_nlanes,\n\t\t\t       u8 tx_amplitude, u8 tx_hs_equalizer,\n\t\t\t       u8 rx_mode, u8 rx_gear, u8 rx_nlanes,\n\t\t\t       u8 flags, u32 quirks,\n\t\t\t       struct gb_svc_l2_timer_cfg *local,\n\t\t\t       struct gb_svc_l2_timer_cfg *remote)\n{\n\tstruct gb_svc_intf_set_pwrm_request request;\n\tstruct gb_svc_intf_set_pwrm_response response;\n\tint ret;\n\tu16 result_code;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.intf_id = intf_id;\n\trequest.hs_series = hs_series;\n\trequest.tx_mode = tx_mode;\n\trequest.tx_gear = tx_gear;\n\trequest.tx_nlanes = tx_nlanes;\n\trequest.tx_amplitude = tx_amplitude;\n\trequest.tx_hs_equalizer = tx_hs_equalizer;\n\trequest.rx_mode = rx_mode;\n\trequest.rx_gear = rx_gear;\n\trequest.rx_nlanes = rx_nlanes;\n\trequest.flags = flags;\n\trequest.quirks = cpu_to_le32(quirks);\n\tif (local)\n\t\trequest.local_l2timerdata = *local;\n\tif (remote)\n\t\trequest.remote_l2timerdata = *remote;\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_INTF_SET_PWRM,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresult_code = response.result_code;\n\tif (result_code != GB_SVC_SETPWRM_PWR_LOCAL) {\n\t\tdev_err(&svc->dev, \"set power mode = %d\\n\", result_code);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gb_svc_intf_set_power_mode);\n\nint gb_svc_intf_set_power_mode_hibernate(struct gb_svc *svc, u8 intf_id)\n{\n\tstruct gb_svc_intf_set_pwrm_request request;\n\tstruct gb_svc_intf_set_pwrm_response response;\n\tint ret;\n\tu16 result_code;\n\n\tmemset(&request, 0, sizeof(request));\n\n\trequest.intf_id = intf_id;\n\trequest.hs_series = GB_SVC_UNIPRO_HS_SERIES_A;\n\trequest.tx_mode = GB_SVC_UNIPRO_HIBERNATE_MODE;\n\trequest.rx_mode = GB_SVC_UNIPRO_HIBERNATE_MODE;\n\n\tret = gb_operation_sync(svc->connection, GB_SVC_TYPE_INTF_SET_PWRM,\n\t\t\t\t&request, sizeof(request),\n\t\t\t\t&response, sizeof(response));\n\tif (ret < 0) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"failed to send set power mode operation to interface %u: %d\\n\",\n\t\t\tintf_id, ret);\n\t\treturn ret;\n\t}\n\n\tresult_code = response.result_code;\n\tif (result_code != GB_SVC_SETPWRM_PWR_OK) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"failed to hibernate the link for interface %u: %u\\n\",\n\t\t\tintf_id, result_code);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint gb_svc_ping(struct gb_svc *svc)\n{\n\treturn gb_operation_sync_timeout(svc->connection, GB_SVC_TYPE_PING,\n\t\t\t\t\t NULL, 0, NULL, 0,\n\t\t\t\t\t GB_OPERATION_TIMEOUT_DEFAULT * 2);\n}\n\nstatic int gb_svc_version_request(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_svc_version_request *request;\n\tstruct gb_svc_version_response *response;\n\n\tif (op->request->payload_size < sizeof(*request)) {\n\t\tdev_err(&svc->dev, \"short version request (%zu < %zu)\\n\",\n\t\t\top->request->payload_size,\n\t\t\tsizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\tif (request->major > GB_SVC_VERSION_MAJOR) {\n\t\tdev_warn(&svc->dev, \"unsupported major version (%u > %u)\\n\",\n\t\t\t request->major, GB_SVC_VERSION_MAJOR);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tsvc->protocol_major = request->major;\n\tsvc->protocol_minor = request->minor;\n\n\tif (!gb_operation_response_alloc(op, sizeof(*response), GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tresponse = op->response->payload;\n\tresponse->major = svc->protocol_major;\n\tresponse->minor = svc->protocol_minor;\n\n\treturn 0;\n}\n\nstatic ssize_t pwr_debugfs_voltage_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t len, loff_t *offset)\n{\n\tstruct svc_debugfs_pwrmon_rail *pwrmon_rails =\n\t\tfile_inode(file)->i_private;\n\tstruct gb_svc *svc = pwrmon_rails->svc;\n\tint ret, desc;\n\tu32 value;\n\tchar buff[16];\n\n\tret = gb_svc_pwrmon_sample_get(svc, pwrmon_rails->id,\n\t\t\t\t       GB_SVC_PWRMON_TYPE_VOL, &value);\n\tif (ret) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"failed to get voltage sample %u: %d\\n\",\n\t\t\tpwrmon_rails->id, ret);\n\t\treturn ret;\n\t}\n\n\tdesc = scnprintf(buff, sizeof(buff), \"%u\\n\", value);\n\n\treturn simple_read_from_buffer(buf, len, offset, buff, desc);\n}\n\nstatic ssize_t pwr_debugfs_current_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t len, loff_t *offset)\n{\n\tstruct svc_debugfs_pwrmon_rail *pwrmon_rails =\n\t\tfile_inode(file)->i_private;\n\tstruct gb_svc *svc = pwrmon_rails->svc;\n\tint ret, desc;\n\tu32 value;\n\tchar buff[16];\n\n\tret = gb_svc_pwrmon_sample_get(svc, pwrmon_rails->id,\n\t\t\t\t       GB_SVC_PWRMON_TYPE_CURR, &value);\n\tif (ret) {\n\t\tdev_err(&svc->dev,\n\t\t\t\"failed to get current sample %u: %d\\n\",\n\t\t\tpwrmon_rails->id, ret);\n\t\treturn ret;\n\t}\n\n\tdesc = scnprintf(buff, sizeof(buff), \"%u\\n\", value);\n\n\treturn simple_read_from_buffer(buf, len, offset, buff, desc);\n}\n\nstatic ssize_t pwr_debugfs_power_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *offset)\n{\n\tstruct svc_debugfs_pwrmon_rail *pwrmon_rails =\n\t\tfile_inode(file)->i_private;\n\tstruct gb_svc *svc = pwrmon_rails->svc;\n\tint ret, desc;\n\tu32 value;\n\tchar buff[16];\n\n\tret = gb_svc_pwrmon_sample_get(svc, pwrmon_rails->id,\n\t\t\t\t       GB_SVC_PWRMON_TYPE_PWR, &value);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to get power sample %u: %d\\n\",\n\t\t\tpwrmon_rails->id, ret);\n\t\treturn ret;\n\t}\n\n\tdesc = scnprintf(buff, sizeof(buff), \"%u\\n\", value);\n\n\treturn simple_read_from_buffer(buf, len, offset, buff, desc);\n}\n\nstatic const struct file_operations pwrmon_debugfs_voltage_fops = {\n\t.read\t\t= pwr_debugfs_voltage_read,\n};\n\nstatic const struct file_operations pwrmon_debugfs_current_fops = {\n\t.read\t\t= pwr_debugfs_current_read,\n};\n\nstatic const struct file_operations pwrmon_debugfs_power_fops = {\n\t.read\t\t= pwr_debugfs_power_read,\n};\n\nstatic void gb_svc_pwrmon_debugfs_init(struct gb_svc *svc)\n{\n\tint i;\n\tsize_t bufsize;\n\tstruct dentry *dent;\n\tstruct gb_svc_pwrmon_rail_names_get_response *rail_names;\n\tu8 rail_count;\n\n\tdent = debugfs_create_dir(\"pwrmon\", svc->debugfs_dentry);\n\tif (IS_ERR_OR_NULL(dent))\n\t\treturn;\n\n\tif (gb_svc_pwrmon_rail_count_get(svc, &rail_count))\n\t\tgoto err_pwrmon_debugfs;\n\n\tif (!rail_count || rail_count > GB_SVC_PWRMON_MAX_RAIL_COUNT)\n\t\tgoto err_pwrmon_debugfs;\n\n\tbufsize = sizeof(*rail_names) +\n\t\tGB_SVC_PWRMON_RAIL_NAME_BUFSIZE * rail_count;\n\n\trail_names = kzalloc(bufsize, GFP_KERNEL);\n\tif (!rail_names)\n\t\tgoto err_pwrmon_debugfs;\n\n\tsvc->pwrmon_rails = kcalloc(rail_count, sizeof(*svc->pwrmon_rails),\n\t\t\t\t    GFP_KERNEL);\n\tif (!svc->pwrmon_rails)\n\t\tgoto err_pwrmon_debugfs_free;\n\n\tif (gb_svc_pwrmon_rail_names_get(svc, rail_names, bufsize))\n\t\tgoto err_pwrmon_debugfs_free;\n\n\tfor (i = 0; i < rail_count; i++) {\n\t\tstruct dentry *dir;\n\t\tstruct svc_debugfs_pwrmon_rail *rail = &svc->pwrmon_rails[i];\n\t\tchar fname[GB_SVC_PWRMON_RAIL_NAME_BUFSIZE];\n\n\t\tsnprintf(fname, sizeof(fname), \"%s\",\n\t\t\t (char *)&rail_names->name[i]);\n\n\t\trail->id = i;\n\t\trail->svc = svc;\n\n\t\tdir = debugfs_create_dir(fname, dent);\n\t\tdebugfs_create_file(\"voltage_now\", 0444, dir, rail,\n\t\t\t\t    &pwrmon_debugfs_voltage_fops);\n\t\tdebugfs_create_file(\"current_now\", 0444, dir, rail,\n\t\t\t\t    &pwrmon_debugfs_current_fops);\n\t\tdebugfs_create_file(\"power_now\", 0444, dir, rail,\n\t\t\t\t    &pwrmon_debugfs_power_fops);\n\t}\n\n\tkfree(rail_names);\n\treturn;\n\nerr_pwrmon_debugfs_free:\n\tkfree(rail_names);\n\tkfree(svc->pwrmon_rails);\n\tsvc->pwrmon_rails = NULL;\n\nerr_pwrmon_debugfs:\n\tdebugfs_remove(dent);\n}\n\nstatic void gb_svc_debugfs_init(struct gb_svc *svc)\n{\n\tsvc->debugfs_dentry = debugfs_create_dir(dev_name(&svc->dev),\n\t\t\t\t\t\t gb_debugfs_get());\n\tgb_svc_pwrmon_debugfs_init(svc);\n}\n\nstatic void gb_svc_debugfs_exit(struct gb_svc *svc)\n{\n\tdebugfs_remove_recursive(svc->debugfs_dentry);\n\tkfree(svc->pwrmon_rails);\n\tsvc->pwrmon_rails = NULL;\n}\n\nstatic int gb_svc_hello(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_svc_hello_request *hello_request;\n\tint ret;\n\n\tif (op->request->payload_size < sizeof(*hello_request)) {\n\t\tdev_warn(&svc->dev, \"short hello request (%zu < %zu)\\n\",\n\t\t\t op->request->payload_size,\n\t\t\t sizeof(*hello_request));\n\t\treturn -EINVAL;\n\t}\n\n\thello_request = op->request->payload;\n\tsvc->endo_id = le16_to_cpu(hello_request->endo_id);\n\tsvc->ap_intf_id = hello_request->interface_id;\n\n\tret = device_add(&svc->dev);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to register svc device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gb_svc_watchdog_create(svc);\n\tif (ret) {\n\t\tdev_err(&svc->dev, \"failed to create watchdog: %d\\n\", ret);\n\t\tgoto err_deregister_svc;\n\t}\n\n\t \n\tret = gb_svc_queue_deferred_request(op);\n\tif (ret)\n\t\tgoto err_destroy_watchdog;\n\n\tgb_svc_debugfs_init(svc);\n\n\treturn 0;\n\nerr_destroy_watchdog:\n\tgb_svc_watchdog_destroy(svc);\nerr_deregister_svc:\n\tdevice_del(&svc->dev);\n\n\treturn ret;\n}\n\nstatic struct gb_interface *gb_svc_interface_lookup(struct gb_svc *svc,\n\t\t\t\t\t\t    u8 intf_id)\n{\n\tstruct gb_host_device *hd = svc->hd;\n\tstruct gb_module *module;\n\tsize_t num_interfaces;\n\tu8 module_id;\n\n\tlist_for_each_entry(module, &hd->modules, hd_node) {\n\t\tmodule_id = module->module_id;\n\t\tnum_interfaces = module->num_interfaces;\n\n\t\tif (intf_id >= module_id &&\n\t\t    intf_id < module_id + num_interfaces) {\n\t\t\treturn module->interfaces[intf_id - module_id];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct gb_module *gb_svc_module_lookup(struct gb_svc *svc, u8 module_id)\n{\n\tstruct gb_host_device *hd = svc->hd;\n\tstruct gb_module *module;\n\n\tlist_for_each_entry(module, &hd->modules, hd_node) {\n\t\tif (module->module_id == module_id)\n\t\t\treturn module;\n\t}\n\n\treturn NULL;\n}\n\nstatic void gb_svc_process_hello_deferred(struct gb_operation *operation)\n{\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tint ret;\n\n\t \n\tret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,\n\t\t\t\t\t GB_SVC_UNIPRO_HS_SERIES_A,\n\t\t\t\t\t GB_SVC_UNIPRO_SLOW_AUTO_MODE,\n\t\t\t\t\t 2, 1,\n\t\t\t\t\t GB_SVC_SMALL_AMPLITUDE,\n\t\t\t\t\t GB_SVC_NO_DE_EMPHASIS,\n\t\t\t\t\t GB_SVC_UNIPRO_SLOW_AUTO_MODE,\n\t\t\t\t\t 2, 1,\n\t\t\t\t\t 0, 0,\n\t\t\t\t\t NULL, NULL);\n\n\tif (ret)\n\t\tdev_warn(&svc->dev,\n\t\t\t \"power mode change failed on AP to switch link: %d\\n\",\n\t\t\t ret);\n}\n\nstatic void gb_svc_process_module_inserted(struct gb_operation *operation)\n{\n\tstruct gb_svc_module_inserted_request *request;\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_host_device *hd = svc->hd;\n\tstruct gb_module *module;\n\tsize_t num_interfaces;\n\tu8 module_id;\n\tu16 flags;\n\tint ret;\n\n\t \n\trequest = operation->request->payload;\n\tmodule_id = request->primary_intf_id;\n\tnum_interfaces = request->intf_count;\n\tflags = le16_to_cpu(request->flags);\n\n\tdev_dbg(&svc->dev, \"%s - id = %u, num_interfaces = %zu, flags = 0x%04x\\n\",\n\t\t__func__, module_id, num_interfaces, flags);\n\n\tif (flags & GB_SVC_MODULE_INSERTED_FLAG_NO_PRIMARY) {\n\t\tdev_warn(&svc->dev, \"no primary interface detected on module %u\\n\",\n\t\t\t module_id);\n\t}\n\n\tmodule = gb_svc_module_lookup(svc, module_id);\n\tif (module) {\n\t\tdev_warn(&svc->dev, \"unexpected module-inserted event %u\\n\",\n\t\t\t module_id);\n\t\treturn;\n\t}\n\n\tmodule = gb_module_create(hd, module_id, num_interfaces);\n\tif (!module) {\n\t\tdev_err(&svc->dev, \"failed to create module\\n\");\n\t\treturn;\n\t}\n\n\tret = gb_module_add(module);\n\tif (ret) {\n\t\tgb_module_put(module);\n\t\treturn;\n\t}\n\n\tlist_add(&module->hd_node, &hd->modules);\n}\n\nstatic void gb_svc_process_module_removed(struct gb_operation *operation)\n{\n\tstruct gb_svc_module_removed_request *request;\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_module *module;\n\tu8 module_id;\n\n\t \n\trequest = operation->request->payload;\n\tmodule_id = request->primary_intf_id;\n\n\tdev_dbg(&svc->dev, \"%s - id = %u\\n\", __func__, module_id);\n\n\tmodule = gb_svc_module_lookup(svc, module_id);\n\tif (!module) {\n\t\tdev_warn(&svc->dev, \"unexpected module-removed event %u\\n\",\n\t\t\t module_id);\n\t\treturn;\n\t}\n\n\tmodule->disconnected = true;\n\n\tgb_module_del(module);\n\tlist_del(&module->hd_node);\n\tgb_module_put(module);\n}\n\nstatic void gb_svc_process_intf_oops(struct gb_operation *operation)\n{\n\tstruct gb_svc_intf_oops_request *request;\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_interface *intf;\n\tu8 intf_id;\n\tu8 reason;\n\n\t \n\trequest = operation->request->payload;\n\tintf_id = request->intf_id;\n\treason = request->reason;\n\n\tintf = gb_svc_interface_lookup(svc, intf_id);\n\tif (!intf) {\n\t\tdev_warn(&svc->dev, \"unexpected interface-oops event %u\\n\",\n\t\t\t intf_id);\n\t\treturn;\n\t}\n\n\tdev_info(&svc->dev, \"Deactivating interface %u, interface oops reason = %u\\n\",\n\t\t intf_id, reason);\n\n\tmutex_lock(&intf->mutex);\n\tintf->disconnected = true;\n\tgb_interface_disable(intf);\n\tgb_interface_deactivate(intf);\n\tmutex_unlock(&intf->mutex);\n}\n\nstatic void gb_svc_process_intf_mailbox_event(struct gb_operation *operation)\n{\n\tstruct gb_svc_intf_mailbox_event_request *request;\n\tstruct gb_connection *connection = operation->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tstruct gb_interface *intf;\n\tu8 intf_id;\n\tu16 result_code;\n\tu32 mailbox;\n\n\t \n\trequest = operation->request->payload;\n\tintf_id = request->intf_id;\n\tresult_code = le16_to_cpu(request->result_code);\n\tmailbox = le32_to_cpu(request->mailbox);\n\n\tdev_dbg(&svc->dev, \"%s - id = %u, result = 0x%04x, mailbox = 0x%08x\\n\",\n\t\t__func__, intf_id, result_code, mailbox);\n\n\tintf = gb_svc_interface_lookup(svc, intf_id);\n\tif (!intf) {\n\t\tdev_warn(&svc->dev, \"unexpected mailbox event %u\\n\", intf_id);\n\t\treturn;\n\t}\n\n\tgb_interface_mailbox_event(intf, result_code, mailbox);\n}\n\nstatic void gb_svc_process_deferred_request(struct work_struct *work)\n{\n\tstruct gb_svc_deferred_request *dr;\n\tstruct gb_operation *operation;\n\tstruct gb_svc *svc;\n\tu8 type;\n\n\tdr = container_of(work, struct gb_svc_deferred_request, work);\n\toperation = dr->operation;\n\tsvc = gb_connection_get_data(operation->connection);\n\ttype = operation->request->header->type;\n\n\tswitch (type) {\n\tcase GB_SVC_TYPE_SVC_HELLO:\n\t\tgb_svc_process_hello_deferred(operation);\n\t\tbreak;\n\tcase GB_SVC_TYPE_MODULE_INSERTED:\n\t\tgb_svc_process_module_inserted(operation);\n\t\tbreak;\n\tcase GB_SVC_TYPE_MODULE_REMOVED:\n\t\tgb_svc_process_module_removed(operation);\n\t\tbreak;\n\tcase GB_SVC_TYPE_INTF_MAILBOX_EVENT:\n\t\tgb_svc_process_intf_mailbox_event(operation);\n\t\tbreak;\n\tcase GB_SVC_TYPE_INTF_OOPS:\n\t\tgb_svc_process_intf_oops(operation);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&svc->dev, \"bad deferred request type: 0x%02x\\n\", type);\n\t}\n\n\tgb_operation_put(operation);\n\tkfree(dr);\n}\n\nstatic int gb_svc_queue_deferred_request(struct gb_operation *operation)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(operation->connection);\n\tstruct gb_svc_deferred_request *dr;\n\n\tdr = kmalloc(sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tgb_operation_get(operation);\n\n\tdr->operation = operation;\n\tINIT_WORK(&dr->work, gb_svc_process_deferred_request);\n\n\tqueue_work(svc->wq, &dr->work);\n\n\treturn 0;\n}\n\nstatic int gb_svc_intf_reset_recv(struct gb_operation *op)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(op->connection);\n\tstruct gb_message *request = op->request;\n\tstruct gb_svc_intf_reset_request *reset;\n\n\tif (request->payload_size < sizeof(*reset)) {\n\t\tdev_warn(&svc->dev, \"short reset request received (%zu < %zu)\\n\",\n\t\t\t request->payload_size, sizeof(*reset));\n\t\treturn -EINVAL;\n\t}\n\treset = request->payload;\n\n\t \n\n\treturn 0;\n}\n\nstatic int gb_svc_module_inserted_recv(struct gb_operation *op)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(op->connection);\n\tstruct gb_svc_module_inserted_request *request;\n\n\tif (op->request->payload_size < sizeof(*request)) {\n\t\tdev_warn(&svc->dev, \"short module-inserted request received (%zu < %zu)\\n\",\n\t\t\t op->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\tdev_dbg(&svc->dev, \"%s - id = %u\\n\", __func__,\n\t\trequest->primary_intf_id);\n\n\treturn gb_svc_queue_deferred_request(op);\n}\n\nstatic int gb_svc_module_removed_recv(struct gb_operation *op)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(op->connection);\n\tstruct gb_svc_module_removed_request *request;\n\n\tif (op->request->payload_size < sizeof(*request)) {\n\t\tdev_warn(&svc->dev, \"short module-removed request received (%zu < %zu)\\n\",\n\t\t\t op->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\tdev_dbg(&svc->dev, \"%s - id = %u\\n\", __func__,\n\t\trequest->primary_intf_id);\n\n\treturn gb_svc_queue_deferred_request(op);\n}\n\nstatic int gb_svc_intf_oops_recv(struct gb_operation *op)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(op->connection);\n\tstruct gb_svc_intf_oops_request *request;\n\n\tif (op->request->payload_size < sizeof(*request)) {\n\t\tdev_warn(&svc->dev, \"short intf-oops request received (%zu < %zu)\\n\",\n\t\t\t op->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\treturn gb_svc_queue_deferred_request(op);\n}\n\nstatic int gb_svc_intf_mailbox_event_recv(struct gb_operation *op)\n{\n\tstruct gb_svc *svc = gb_connection_get_data(op->connection);\n\tstruct gb_svc_intf_mailbox_event_request *request;\n\n\tif (op->request->payload_size < sizeof(*request)) {\n\t\tdev_warn(&svc->dev, \"short mailbox request received (%zu < %zu)\\n\",\n\t\t\t op->request->payload_size, sizeof(*request));\n\t\treturn -EINVAL;\n\t}\n\n\trequest = op->request->payload;\n\n\tdev_dbg(&svc->dev, \"%s - id = %u\\n\", __func__, request->intf_id);\n\n\treturn gb_svc_queue_deferred_request(op);\n}\n\nstatic int gb_svc_request_handler(struct gb_operation *op)\n{\n\tstruct gb_connection *connection = op->connection;\n\tstruct gb_svc *svc = gb_connection_get_data(connection);\n\tu8 type = op->type;\n\tint ret = 0;\n\n\t \n\tswitch (type) {\n\tcase GB_SVC_TYPE_PROTOCOL_VERSION:\n\t\tif (svc->state != GB_SVC_STATE_RESET)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase GB_SVC_TYPE_SVC_HELLO:\n\t\tif (svc->state != GB_SVC_STATE_PROTOCOL_VERSION)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tif (svc->state != GB_SVC_STATE_SVC_HELLO)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_warn(&svc->dev, \"unexpected request 0x%02x received (state %u)\\n\",\n\t\t\t type, svc->state);\n\t\treturn ret;\n\t}\n\n\tswitch (type) {\n\tcase GB_SVC_TYPE_PROTOCOL_VERSION:\n\t\tret = gb_svc_version_request(op);\n\t\tif (!ret)\n\t\t\tsvc->state = GB_SVC_STATE_PROTOCOL_VERSION;\n\t\treturn ret;\n\tcase GB_SVC_TYPE_SVC_HELLO:\n\t\tret = gb_svc_hello(op);\n\t\tif (!ret)\n\t\t\tsvc->state = GB_SVC_STATE_SVC_HELLO;\n\t\treturn ret;\n\tcase GB_SVC_TYPE_INTF_RESET:\n\t\treturn gb_svc_intf_reset_recv(op);\n\tcase GB_SVC_TYPE_MODULE_INSERTED:\n\t\treturn gb_svc_module_inserted_recv(op);\n\tcase GB_SVC_TYPE_MODULE_REMOVED:\n\t\treturn gb_svc_module_removed_recv(op);\n\tcase GB_SVC_TYPE_INTF_MAILBOX_EVENT:\n\t\treturn gb_svc_intf_mailbox_event_recv(op);\n\tcase GB_SVC_TYPE_INTF_OOPS:\n\t\treturn gb_svc_intf_oops_recv(op);\n\tdefault:\n\t\tdev_warn(&svc->dev, \"unsupported request 0x%02x\\n\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void gb_svc_release(struct device *dev)\n{\n\tstruct gb_svc *svc = to_gb_svc(dev);\n\n\tif (svc->connection)\n\t\tgb_connection_destroy(svc->connection);\n\tida_destroy(&svc->device_id_map);\n\tdestroy_workqueue(svc->wq);\n\tkfree(svc);\n}\n\nstruct device_type greybus_svc_type = {\n\t.name\t\t= \"greybus_svc\",\n\t.release\t= gb_svc_release,\n};\n\nstruct gb_svc *gb_svc_create(struct gb_host_device *hd)\n{\n\tstruct gb_svc *svc;\n\n\tsvc = kzalloc(sizeof(*svc), GFP_KERNEL);\n\tif (!svc)\n\t\treturn NULL;\n\n\tsvc->wq = alloc_ordered_workqueue(\"%s:svc\", 0, dev_name(&hd->dev));\n\tif (!svc->wq) {\n\t\tkfree(svc);\n\t\treturn NULL;\n\t}\n\n\tsvc->dev.parent = &hd->dev;\n\tsvc->dev.bus = &greybus_bus_type;\n\tsvc->dev.type = &greybus_svc_type;\n\tsvc->dev.groups = svc_groups;\n\tsvc->dev.dma_mask = svc->dev.parent->dma_mask;\n\tdevice_initialize(&svc->dev);\n\n\tdev_set_name(&svc->dev, \"%d-svc\", hd->bus_id);\n\n\tida_init(&svc->device_id_map);\n\tsvc->state = GB_SVC_STATE_RESET;\n\tsvc->hd = hd;\n\n\tsvc->connection = gb_connection_create_static(hd, GB_SVC_CPORT_ID,\n\t\t\t\t\t\t      gb_svc_request_handler);\n\tif (IS_ERR(svc->connection)) {\n\t\tdev_err(&svc->dev, \"failed to create connection: %ld\\n\",\n\t\t\tPTR_ERR(svc->connection));\n\t\tgoto err_put_device;\n\t}\n\n\tgb_connection_set_data(svc->connection, svc);\n\n\treturn svc;\n\nerr_put_device:\n\tput_device(&svc->dev);\n\treturn NULL;\n}\n\nint gb_svc_add(struct gb_svc *svc)\n{\n\tint ret;\n\n\t \n\tret = gb_connection_enable(svc->connection);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void gb_svc_remove_modules(struct gb_svc *svc)\n{\n\tstruct gb_host_device *hd = svc->hd;\n\tstruct gb_module *module, *tmp;\n\n\tlist_for_each_entry_safe(module, tmp, &hd->modules, hd_node) {\n\t\tgb_module_del(module);\n\t\tlist_del(&module->hd_node);\n\t\tgb_module_put(module);\n\t}\n}\n\nvoid gb_svc_del(struct gb_svc *svc)\n{\n\tgb_connection_disable_rx(svc->connection);\n\n\t \n\tif (device_is_registered(&svc->dev)) {\n\t\tgb_svc_debugfs_exit(svc);\n\t\tgb_svc_watchdog_destroy(svc);\n\t\tdevice_del(&svc->dev);\n\t}\n\n\tflush_workqueue(svc->wq);\n\n\tgb_svc_remove_modules(svc);\n\n\tgb_connection_disable(svc->connection);\n}\n\nvoid gb_svc_put(struct gb_svc *svc)\n{\n\tput_device(&svc->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}