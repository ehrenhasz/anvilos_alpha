{
  "module_name": "es2.c",
  "hash_id": "87414dc5a2fe1fb1b578a4e8affb038892630c7bd744a1bf86f456acc5807702",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/es2.c",
  "human_readable_source": "\n \n#include <linux/kthread.h>\n#include <linux/sizes.h>\n#include <linux/usb.h>\n#include <linux/kfifo.h>\n#include <linux/debugfs.h>\n#include <linux/list.h>\n#include <linux/greybus.h>\n#include <asm/unaligned.h>\n\n#include \"arpc.h\"\n#include \"greybus_trace.h\"\n\n\n \n#define ES2_USB_CTRL_TIMEOUT\t500\n\n \n#define ES2_ARPC_CPORT_TIMEOUT\t500\n\n \n#define ES2_CPORT_CDSI0\t\t16\n#define ES2_CPORT_CDSI1\t\t17\n\n \n#define ES2_GBUF_MSG_SIZE_MAX\t2048\n\n \n#define ARPC_OUT_SIZE_MAX\tU16_MAX\n#define ARPC_IN_SIZE_MAX\t128\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x18d1, 0x1eaf) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n#define APB1_LOG_SIZE\t\tSZ_16K\n\n \n#define NUM_CPORT_IN_URB\t4\n\n \n#define NUM_CPORT_OUT_URB\t8\n\n \n#define NUM_ARPC_IN_URB\t\t2\n\n \nstruct es2_cport_in {\n\t__u8 endpoint;\n\tstruct urb *urb[NUM_CPORT_IN_URB];\n\tu8 *buffer[NUM_CPORT_IN_URB];\n};\n\n \nstruct es2_ap_dev {\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *usb_intf;\n\tstruct gb_host_device *hd;\n\n\tstruct es2_cport_in cport_in;\n\t__u8 cport_out_endpoint;\n\tstruct urb *cport_out_urb[NUM_CPORT_OUT_URB];\n\tbool cport_out_urb_busy[NUM_CPORT_OUT_URB];\n\tbool cport_out_urb_cancelled[NUM_CPORT_OUT_URB];\n\tspinlock_t cport_out_urb_lock;\n\n\tbool cdsi1_in_use;\n\n\tstruct task_struct *apb_log_task;\n\tstruct dentry *apb_log_dentry;\n\tstruct dentry *apb_log_enable_dentry;\n\tDECLARE_KFIFO(apb_log_fifo, char, APB1_LOG_SIZE);\n\n\t__u8 arpc_endpoint_in;\n\tstruct urb *arpc_urb[NUM_ARPC_IN_URB];\n\tu8 *arpc_buffer[NUM_ARPC_IN_URB];\n\n\tint arpc_id_cycle;\n\tspinlock_t arpc_lock;\n\tstruct list_head arpcs;\n};\n\nstruct arpc {\n\tstruct list_head list;\n\tstruct arpc_request_message *req;\n\tstruct arpc_response_message *resp;\n\tstruct completion response_received;\n\tbool active;\n};\n\nstatic inline struct es2_ap_dev *hd_to_es2(struct gb_host_device *hd)\n{\n\treturn (struct es2_ap_dev *)&hd->hd_priv;\n}\n\nstatic void cport_out_callback(struct urb *urb);\nstatic void usb_log_enable(struct es2_ap_dev *es2);\nstatic void usb_log_disable(struct es2_ap_dev *es2);\nstatic int arpc_sync(struct es2_ap_dev *es2, u8 type, void *payload,\n\t\t     size_t size, int *result, unsigned int timeout);\n\nstatic int output_sync(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)\n{\n\tstruct usb_device *udev = es2->usb_dev;\n\tu8 *data;\n\tint retval;\n\n\tdata = kmemdup(req, size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t cmd,\n\t\t\t\t USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_INTERFACE,\n\t\t\t\t 0, 0, data, size, ES2_USB_CTRL_TIMEOUT);\n\tif (retval < 0)\n\t\tdev_err(&udev->dev, \"%s: return error %d\\n\", __func__, retval);\n\telse\n\t\tretval = 0;\n\n\tkfree(data);\n\treturn retval;\n}\n\nstatic void ap_urb_complete(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *dr = urb->context;\n\n\tkfree(dr);\n\tusb_free_urb(urb);\n}\n\nstatic int output_async(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)\n{\n\tstruct usb_device *udev = es2->usb_dev;\n\tstruct urb *urb;\n\tstruct usb_ctrlrequest *dr;\n\tu8 *buf;\n\tint retval;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tdr = kmalloc(sizeof(*dr) + size, GFP_ATOMIC);\n\tif (!dr) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf = (u8 *)dr + sizeof(*dr);\n\tmemcpy(buf, req, size);\n\n\tdr->bRequest = cmd;\n\tdr->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;\n\tdr->wValue = 0;\n\tdr->wIndex = 0;\n\tdr->wLength = cpu_to_le16(size);\n\n\tusb_fill_control_urb(urb, udev, usb_sndctrlpipe(udev, 0),\n\t\t\t     (unsigned char *)dr, buf, size,\n\t\t\t     ap_urb_complete, dr);\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tusb_free_urb(urb);\n\t\tkfree(dr);\n\t}\n\treturn retval;\n}\n\nstatic int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,\n\t\t  bool async)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\n\tif (async)\n\t\treturn output_async(es2, req, size, cmd);\n\n\treturn output_sync(es2, req, size, cmd);\n}\n\nstatic int es2_cport_in_enable(struct es2_ap_dev *es2,\n\t\t\t       struct es2_cport_in *cport_in)\n{\n\tstruct urb *urb;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\n\t\turb = cport_in->urb[i];\n\n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(&es2->usb_dev->dev,\n\t\t\t\t\"failed to submit in-urb: %d\\n\", ret);\n\t\t\tgoto err_kill_urbs;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_kill_urbs:\n\tfor (--i; i >= 0; --i) {\n\t\turb = cport_in->urb[i];\n\t\tusb_kill_urb(urb);\n\t}\n\n\treturn ret;\n}\n\nstatic void es2_cport_in_disable(struct es2_ap_dev *es2,\n\t\t\t\t struct es2_cport_in *cport_in)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\n\t\turb = cport_in->urb[i];\n\t\tusb_kill_urb(urb);\n\t}\n}\n\nstatic int es2_arpc_in_enable(struct es2_ap_dev *es2)\n{\n\tstruct urb *urb;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\n\t\turb = es2->arpc_urb[i];\n\n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(&es2->usb_dev->dev,\n\t\t\t\t\"failed to submit arpc in-urb: %d\\n\", ret);\n\t\t\tgoto err_kill_urbs;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_kill_urbs:\n\tfor (--i; i >= 0; --i) {\n\t\turb = es2->arpc_urb[i];\n\t\tusb_kill_urb(urb);\n\t}\n\n\treturn ret;\n}\n\nstatic void es2_arpc_in_disable(struct es2_ap_dev *es2)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\n\t\turb = es2->arpc_urb[i];\n\t\tusb_kill_urb(urb);\n\t}\n}\n\nstatic struct urb *next_free_urb(struct es2_ap_dev *es2, gfp_t gfp_mask)\n{\n\tstruct urb *urb = NULL;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\n\n\t \n\tfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\n\t\tif (!es2->cport_out_urb_busy[i] &&\n\t\t    !es2->cport_out_urb_cancelled[i]) {\n\t\t\tes2->cport_out_urb_busy[i] = true;\n\t\t\turb = es2->cport_out_urb[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\n\tif (urb)\n\t\treturn urb;\n\n\t \n\tdev_dbg(&es2->usb_dev->dev,\n\t\t\"No free CPort OUT urbs, having to dynamically allocate one!\\n\");\n\treturn usb_alloc_urb(0, gfp_mask);\n}\n\nstatic void free_urb(struct es2_ap_dev *es2, struct urb *urb)\n{\n\tunsigned long flags;\n\tint i;\n\t \n\tspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\n\tfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\n\t\tif (urb == es2->cport_out_urb[i]) {\n\t\t\tes2->cport_out_urb_busy[i] = false;\n\t\t\turb = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\n\n\t \n\tusb_free_urb(urb);\n}\n\n \nstatic void\ngb_message_cport_pack(struct gb_operation_msg_hdr *header, u16 cport_id)\n{\n\theader->pad[0] = cport_id;\n}\n\n \nstatic void gb_message_cport_clear(struct gb_operation_msg_hdr *header)\n{\n\theader->pad[0] = 0;\n}\n\n \nstatic u16 gb_message_cport_unpack(struct gb_operation_msg_hdr *header)\n{\n\tu16 cport_id = header->pad[0];\n\n\tgb_message_cport_clear(header);\n\n\treturn cport_id;\n}\n\n \nstatic int message_send(struct gb_host_device *hd, u16 cport_id,\n\t\t\tstruct gb_message *message, gfp_t gfp_mask)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct usb_device *udev = es2->usb_dev;\n\tsize_t buffer_size;\n\tint retval;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\t \n\tif (!cport_id_valid(hd, cport_id)) {\n\t\tdev_err(&udev->dev, \"invalid cport %u\\n\", cport_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\turb = next_free_urb(es2, gfp_mask);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\n\tmessage->hcpriv = urb;\n\tspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\n\n\t \n\tgb_message_cport_pack(message->header, cport_id);\n\n\tbuffer_size = sizeof(*message->header) + message->payload_size;\n\n\tusb_fill_bulk_urb(urb, udev,\n\t\t\t  usb_sndbulkpipe(udev,\n\t\t\t\t\t  es2->cport_out_endpoint),\n\t\t\t  message->buffer, buffer_size,\n\t\t\t  cport_out_callback, message);\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\ttrace_gb_message_submit(message);\n\n\tretval = usb_submit_urb(urb, gfp_mask);\n\tif (retval) {\n\t\tdev_err(&udev->dev, \"failed to submit out-urb: %d\\n\", retval);\n\n\t\tspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\n\t\tmessage->hcpriv = NULL;\n\t\tspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\n\n\t\tfree_urb(es2, urb);\n\t\tgb_message_cport_clear(message->header);\n\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void message_cancel(struct gb_message *message)\n{\n\tstruct gb_host_device *hd = message->operation->connection->hd;\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct urb *urb;\n\tint i;\n\n\tmight_sleep();\n\n\tspin_lock_irq(&es2->cport_out_urb_lock);\n\turb = message->hcpriv;\n\n\t \n\tusb_get_urb(urb);\n\n\t \n\tfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\n\t\tif (urb == es2->cport_out_urb[i]) {\n\t\t\tes2->cport_out_urb_cancelled[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&es2->cport_out_urb_lock);\n\n\tusb_kill_urb(urb);\n\n\tif (i < NUM_CPORT_OUT_URB) {\n\t\tspin_lock_irq(&es2->cport_out_urb_lock);\n\t\tes2->cport_out_urb_cancelled[i] = false;\n\t\tspin_unlock_irq(&es2->cport_out_urb_lock);\n\t}\n\n\tusb_free_urb(urb);\n}\n\nstatic int es2_cport_allocate(struct gb_host_device *hd, int cport_id,\n\t\t\t      unsigned long flags)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct ida *id_map = &hd->cport_id_map;\n\tint ida_start, ida_end;\n\n\tswitch (cport_id) {\n\tcase ES2_CPORT_CDSI0:\n\tcase ES2_CPORT_CDSI1:\n\t\tdev_err(&hd->dev, \"cport %d not available\\n\", cport_id);\n\t\treturn -EBUSY;\n\t}\n\n\tif (flags & GB_CONNECTION_FLAG_OFFLOADED &&\n\t    flags & GB_CONNECTION_FLAG_CDSI1) {\n\t\tif (es2->cdsi1_in_use) {\n\t\t\tdev_err(&hd->dev, \"CDSI1 already in use\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tes2->cdsi1_in_use = true;\n\n\t\treturn ES2_CPORT_CDSI1;\n\t}\n\n\tif (cport_id < 0) {\n\t\tida_start = 0;\n\t\tida_end = hd->num_cports;\n\t} else if (cport_id < hd->num_cports) {\n\t\tida_start = cport_id;\n\t\tida_end = cport_id + 1;\n\t} else {\n\t\tdev_err(&hd->dev, \"cport %d not available\\n\", cport_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ida_simple_get(id_map, ida_start, ida_end, GFP_KERNEL);\n}\n\nstatic void es2_cport_release(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\n\tswitch (cport_id) {\n\tcase ES2_CPORT_CDSI1:\n\t\tes2->cdsi1_in_use = false;\n\t\treturn;\n\t}\n\n\tida_simple_remove(&hd->cport_id_map, cport_id);\n}\n\nstatic int cport_enable(struct gb_host_device *hd, u16 cport_id,\n\t\t\tunsigned long flags)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct usb_device *udev = es2->usb_dev;\n\tstruct gb_apb_request_cport_flags *req;\n\tu32 connection_flags;\n\tint ret;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tconnection_flags = 0;\n\tif (flags & GB_CONNECTION_FLAG_CONTROL)\n\t\tconnection_flags |= GB_APB_CPORT_FLAG_CONTROL;\n\tif (flags & GB_CONNECTION_FLAG_HIGH_PRIO)\n\t\tconnection_flags |= GB_APB_CPORT_FLAG_HIGH_PRIO;\n\n\treq->flags = cpu_to_le32(connection_flags);\n\n\tdev_dbg(&hd->dev, \"%s - cport = %u, flags = %02x\\n\", __func__,\n\t\tcport_id, connection_flags);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      GB_APB_REQUEST_CPORT_FLAGS,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_INTERFACE, cport_id, 0,\n\t\t\t      req, sizeof(*req), ES2_USB_CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev, \"failed to set cport flags for port %d\\n\",\n\t\t\tcport_id);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic int es2_cport_connected(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_connected_req req;\n\tint ret;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_CONNECTED, &req, sizeof(req),\n\t\t\tNULL, ES2_ARPC_CPORT_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set connected state for cport %u: %d\\n\",\n\t\t\tcport_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int es2_cport_flush(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_flush_req req;\n\tint ret;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_FLUSH, &req, sizeof(req),\n\t\t\tNULL, ES2_ARPC_CPORT_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to flush cport %u: %d\\n\", cport_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,\n\t\t\t      u8 phase, unsigned int timeout)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_shutdown_req req;\n\tint result;\n\tint ret;\n\n\tif (timeout > U16_MAX)\n\t\treturn -EINVAL;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\treq.timeout = cpu_to_le16(timeout);\n\treq.phase = phase;\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_SHUTDOWN, &req, sizeof(req),\n\t\t\t&result, ES2_ARPC_CPORT_TIMEOUT + timeout);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to send shutdown over cport %u: %d (%d)\\n\",\n\t\t\tcport_id, ret, result);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,\n\t\t\t     size_t peer_space, unsigned int timeout)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_quiesce_req req;\n\tint result;\n\tint ret;\n\n\tif (peer_space > U16_MAX)\n\t\treturn -EINVAL;\n\n\tif (timeout > U16_MAX)\n\t\treturn -EINVAL;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\treq.peer_space = cpu_to_le16(peer_space);\n\treq.timeout = cpu_to_le16(timeout);\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_QUIESCE, &req, sizeof(req),\n\t\t\t&result, ES2_ARPC_CPORT_TIMEOUT + timeout);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to quiesce cport %u: %d (%d)\\n\",\n\t\t\tcport_id, ret, result);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int es2_cport_clear(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct device *dev = &es2->usb_dev->dev;\n\tstruct arpc_cport_clear_req req;\n\tint ret;\n\n\treq.cport_id = cpu_to_le16(cport_id);\n\tret = arpc_sync(es2, ARPC_TYPE_CPORT_CLEAR, &req, sizeof(req),\n\t\t\tNULL, ES2_ARPC_CPORT_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to clear cport %u: %d\\n\", cport_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int latency_tag_enable(struct gb_host_device *hd, u16 cport_id)\n{\n\tint retval;\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct usb_device *udev = es2->usb_dev;\n\n\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t GB_APB_REQUEST_LATENCY_TAG_EN,\n\t\t\t\t USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_INTERFACE, cport_id, 0, NULL,\n\t\t\t\t 0, ES2_USB_CTRL_TIMEOUT);\n\n\tif (retval < 0)\n\t\tdev_err(&udev->dev, \"Cannot enable latency tag for cport %d\\n\",\n\t\t\tcport_id);\n\treturn retval;\n}\n\nstatic int latency_tag_disable(struct gb_host_device *hd, u16 cport_id)\n{\n\tint retval;\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tstruct usb_device *udev = es2->usb_dev;\n\n\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t GB_APB_REQUEST_LATENCY_TAG_DIS,\n\t\t\t\t USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_INTERFACE, cport_id, 0, NULL,\n\t\t\t\t 0, ES2_USB_CTRL_TIMEOUT);\n\n\tif (retval < 0)\n\t\tdev_err(&udev->dev, \"Cannot disable latency tag for cport %d\\n\",\n\t\t\tcport_id);\n\treturn retval;\n}\n\nstatic struct gb_hd_driver es2_driver = {\n\t.hd_priv_size\t\t\t= sizeof(struct es2_ap_dev),\n\t.message_send\t\t\t= message_send,\n\t.message_cancel\t\t\t= message_cancel,\n\t.cport_allocate\t\t\t= es2_cport_allocate,\n\t.cport_release\t\t\t= es2_cport_release,\n\t.cport_enable\t\t\t= cport_enable,\n\t.cport_connected\t\t= es2_cport_connected,\n\t.cport_flush\t\t\t= es2_cport_flush,\n\t.cport_shutdown\t\t\t= es2_cport_shutdown,\n\t.cport_quiesce\t\t\t= es2_cport_quiesce,\n\t.cport_clear\t\t\t= es2_cport_clear,\n\t.latency_tag_enable\t\t= latency_tag_enable,\n\t.latency_tag_disable\t\t= latency_tag_disable,\n\t.output\t\t\t\t= output,\n};\n\n \nstatic int check_urb_status(struct urb *urb)\n{\n\tstruct device *dev = &urb->dev->dev;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase -EOVERFLOW:\n\t\tdev_err(dev, \"%s: overflow actual length is %d\\n\",\n\t\t\t__func__, urb->actual_length);\n\t\tfallthrough;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EILSEQ:\n\tcase -EPROTO:\n\t\t \n\t\treturn status;\n\t}\n\tdev_err(dev, \"%s: unknown status %d\\n\", __func__, status);\n\n\treturn -EAGAIN;\n}\n\nstatic void es2_destroy(struct es2_ap_dev *es2)\n{\n\tstruct usb_device *udev;\n\tstruct urb *urb;\n\tint i;\n\n\tdebugfs_remove(es2->apb_log_enable_dentry);\n\tusb_log_disable(es2);\n\n\t \n\tfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\n\t\turb = es2->cport_out_urb[i];\n\t\tusb_kill_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tes2->cport_out_urb[i] = NULL;\n\t\tes2->cport_out_urb_busy[i] = false;\t \n\t}\n\n\tfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\n\t\tusb_free_urb(es2->arpc_urb[i]);\n\t\tkfree(es2->arpc_buffer[i]);\n\t\tes2->arpc_buffer[i] = NULL;\n\t}\n\n\tfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\n\t\tusb_free_urb(es2->cport_in.urb[i]);\n\t\tkfree(es2->cport_in.buffer[i]);\n\t\tes2->cport_in.buffer[i] = NULL;\n\t}\n\n\t \n\tgb_hd_cport_release_reserved(es2->hd, ES2_CPORT_CDSI1);\n\tgb_hd_cport_release_reserved(es2->hd, ES2_CPORT_CDSI0);\n\n\tudev = es2->usb_dev;\n\tgb_hd_put(es2->hd);\n\n\tusb_put_dev(udev);\n}\n\nstatic void cport_in_callback(struct urb *urb)\n{\n\tstruct gb_host_device *hd = urb->context;\n\tstruct device *dev = &urb->dev->dev;\n\tstruct gb_operation_msg_hdr *header;\n\tint status = check_urb_status(urb);\n\tint retval;\n\tu16 cport_id;\n\n\tif (status) {\n\t\tif ((status == -EAGAIN) || (status == -EPROTO))\n\t\t\tgoto exit;\n\n\t\t \n\t\tif (status == -ENOENT || status == -ESHUTDOWN)\n\t\t\treturn;\n\n\t\tdev_err(dev, \"urb cport in error %d (dropped)\\n\", status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length < sizeof(*header)) {\n\t\tdev_err(dev, \"short message received\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\theader = urb->transfer_buffer;\n\tcport_id = gb_message_cport_unpack(header);\n\n\tif (cport_id_valid(hd, cport_id)) {\n\t\tgreybus_data_rcvd(hd, cport_id, urb->transfer_buffer,\n\t\t\t\t  urb->actual_length);\n\t} else {\n\t\tdev_err(dev, \"invalid cport id %u received\\n\", cport_id);\n\t}\nexit:\n\t \n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"failed to resubmit in-urb: %d\\n\", retval);\n}\n\nstatic void cport_out_callback(struct urb *urb)\n{\n\tstruct gb_message *message = urb->context;\n\tstruct gb_host_device *hd = message->operation->connection->hd;\n\tstruct es2_ap_dev *es2 = hd_to_es2(hd);\n\tint status = check_urb_status(urb);\n\tunsigned long flags;\n\n\tgb_message_cport_clear(message->header);\n\n\tspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\n\tmessage->hcpriv = NULL;\n\tspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\n\n\t \n\tgreybus_message_sent(hd, message, status);\n\n\tfree_urb(es2, urb);\n}\n\nstatic struct arpc *arpc_alloc(void *payload, u16 size, u8 type)\n{\n\tstruct arpc *rpc;\n\n\tif (size + sizeof(*rpc->req) > ARPC_OUT_SIZE_MAX)\n\t\treturn NULL;\n\n\trpc = kzalloc(sizeof(*rpc), GFP_KERNEL);\n\tif (!rpc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rpc->list);\n\trpc->req = kzalloc(sizeof(*rpc->req) + size, GFP_KERNEL);\n\tif (!rpc->req)\n\t\tgoto err_free_rpc;\n\n\trpc->resp = kzalloc(sizeof(*rpc->resp), GFP_KERNEL);\n\tif (!rpc->resp)\n\t\tgoto err_free_req;\n\n\trpc->req->type = type;\n\trpc->req->size = cpu_to_le16(sizeof(*rpc->req) + size);\n\tmemcpy(rpc->req->data, payload, size);\n\n\tinit_completion(&rpc->response_received);\n\n\treturn rpc;\n\nerr_free_req:\n\tkfree(rpc->req);\nerr_free_rpc:\n\tkfree(rpc);\n\n\treturn NULL;\n}\n\nstatic void arpc_free(struct arpc *rpc)\n{\n\tkfree(rpc->req);\n\tkfree(rpc->resp);\n\tkfree(rpc);\n}\n\nstatic struct arpc *arpc_find(struct es2_ap_dev *es2, __le16 id)\n{\n\tstruct arpc *rpc;\n\n\tlist_for_each_entry(rpc, &es2->arpcs, list) {\n\t\tif (rpc->req->id == id)\n\t\t\treturn rpc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void arpc_add(struct es2_ap_dev *es2, struct arpc *rpc)\n{\n\trpc->active = true;\n\trpc->req->id = cpu_to_le16(es2->arpc_id_cycle++);\n\tlist_add_tail(&rpc->list, &es2->arpcs);\n}\n\nstatic void arpc_del(struct es2_ap_dev *es2, struct arpc *rpc)\n{\n\tif (rpc->active) {\n\t\trpc->active = false;\n\t\tlist_del(&rpc->list);\n\t}\n}\n\nstatic int arpc_send(struct es2_ap_dev *es2, struct arpc *rpc, int timeout)\n{\n\tstruct usb_device *udev = es2->usb_dev;\n\tint retval;\n\n\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t GB_APB_REQUEST_ARPC_RUN,\n\t\t\t\t USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_INTERFACE,\n\t\t\t\t 0, 0,\n\t\t\t\t rpc->req, le16_to_cpu(rpc->req->size),\n\t\t\t\t ES2_USB_CTRL_TIMEOUT);\n\tif (retval < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"failed to send ARPC request %d: %d\\n\",\n\t\t\trpc->req->type, retval);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int arpc_sync(struct es2_ap_dev *es2, u8 type, void *payload,\n\t\t     size_t size, int *result, unsigned int timeout)\n{\n\tstruct arpc *rpc;\n\tunsigned long flags;\n\tint retval;\n\n\tif (result)\n\t\t*result = 0;\n\n\trpc = arpc_alloc(payload, size, type);\n\tif (!rpc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&es2->arpc_lock, flags);\n\tarpc_add(es2, rpc);\n\tspin_unlock_irqrestore(&es2->arpc_lock, flags);\n\n\tretval = arpc_send(es2, rpc, timeout);\n\tif (retval)\n\t\tgoto out_arpc_del;\n\n\tretval = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t&rpc->response_received,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout));\n\tif (retval <= 0) {\n\t\tif (!retval)\n\t\t\tretval = -ETIMEDOUT;\n\t\tgoto out_arpc_del;\n\t}\n\n\tif (rpc->resp->result) {\n\t\tretval = -EREMOTEIO;\n\t\tif (result)\n\t\t\t*result = rpc->resp->result;\n\t} else {\n\t\tretval = 0;\n\t}\n\nout_arpc_del:\n\tspin_lock_irqsave(&es2->arpc_lock, flags);\n\tarpc_del(es2, rpc);\n\tspin_unlock_irqrestore(&es2->arpc_lock, flags);\n\tarpc_free(rpc);\n\n\tif (retval < 0 && retval != -EREMOTEIO) {\n\t\tdev_err(&es2->usb_dev->dev,\n\t\t\t\"failed to execute ARPC: %d\\n\", retval);\n\t}\n\n\treturn retval;\n}\n\nstatic void arpc_in_callback(struct urb *urb)\n{\n\tstruct es2_ap_dev *es2 = urb->context;\n\tstruct device *dev = &urb->dev->dev;\n\tint status = check_urb_status(urb);\n\tstruct arpc *rpc;\n\tstruct arpc_response_message *resp;\n\tunsigned long flags;\n\tint retval;\n\n\tif (status) {\n\t\tif ((status == -EAGAIN) || (status == -EPROTO))\n\t\t\tgoto exit;\n\n\t\t \n\t\tif (status == -ENOENT || status == -ESHUTDOWN)\n\t\t\treturn;\n\n\t\tdev_err(dev, \"arpc in-urb error %d (dropped)\\n\", status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length < sizeof(*resp)) {\n\t\tdev_err(dev, \"short aprc response received\\n\");\n\t\tgoto exit;\n\t}\n\n\tresp = urb->transfer_buffer;\n\tspin_lock_irqsave(&es2->arpc_lock, flags);\n\trpc = arpc_find(es2, resp->id);\n\tif (!rpc) {\n\t\tdev_err(dev, \"invalid arpc response id received: %u\\n\",\n\t\t\tle16_to_cpu(resp->id));\n\t\tspin_unlock_irqrestore(&es2->arpc_lock, flags);\n\t\tgoto exit;\n\t}\n\n\tarpc_del(es2, rpc);\n\tmemcpy(rpc->resp, resp, sizeof(*resp));\n\tcomplete(&rpc->response_received);\n\tspin_unlock_irqrestore(&es2->arpc_lock, flags);\n\nexit:\n\t \n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"failed to resubmit arpc in-urb: %d\\n\", retval);\n}\n\n#define APB1_LOG_MSG_SIZE\t64\nstatic void apb_log_get(struct es2_ap_dev *es2, char *buf)\n{\n\tint retval;\n\n\tdo {\n\t\tretval = usb_control_msg(es2->usb_dev,\n\t\t\t\t\t usb_rcvctrlpipe(es2->usb_dev, 0),\n\t\t\t\t\t GB_APB_REQUEST_LOG,\n\t\t\t\t\t USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t\t USB_RECIP_INTERFACE,\n\t\t\t\t\t 0x00, 0x00,\n\t\t\t\t\t buf,\n\t\t\t\t\t APB1_LOG_MSG_SIZE,\n\t\t\t\t\t ES2_USB_CTRL_TIMEOUT);\n\t\tif (retval > 0)\n\t\t\tkfifo_in(&es2->apb_log_fifo, buf, retval);\n\t} while (retval > 0);\n}\n\nstatic int apb_log_poll(void *data)\n{\n\tstruct es2_ap_dev *es2 = data;\n\tchar *buf;\n\n\tbuf = kmalloc(APB1_LOG_MSG_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (!kthread_should_stop()) {\n\t\tmsleep(1000);\n\t\tapb_log_get(es2, buf);\n\t}\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic ssize_t apb_log_read(struct file *f, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct es2_ap_dev *es2 = file_inode(f)->i_private;\n\tssize_t ret;\n\tsize_t copied;\n\tchar *tmp_buf;\n\n\tif (count > APB1_LOG_SIZE)\n\t\tcount = APB1_LOG_SIZE;\n\n\ttmp_buf = kmalloc(count, GFP_KERNEL);\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\n\tcopied = kfifo_out(&es2->apb_log_fifo, tmp_buf, count);\n\tret = simple_read_from_buffer(buf, count, ppos, tmp_buf, copied);\n\n\tkfree(tmp_buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations apb_log_fops = {\n\t.read\t= apb_log_read,\n};\n\nstatic void usb_log_enable(struct es2_ap_dev *es2)\n{\n\tif (!IS_ERR_OR_NULL(es2->apb_log_task))\n\t\treturn;\n\n\t \n\tes2->apb_log_task = kthread_run(apb_log_poll, es2, \"apb_log\");\n\tif (IS_ERR(es2->apb_log_task))\n\t\treturn;\n\t \n\tes2->apb_log_dentry = debugfs_create_file(\"apb_log\", 0444,\n\t\t\t\t\t\t  gb_debugfs_get(), es2,\n\t\t\t\t\t\t  &apb_log_fops);\n}\n\nstatic void usb_log_disable(struct es2_ap_dev *es2)\n{\n\tif (IS_ERR_OR_NULL(es2->apb_log_task))\n\t\treturn;\n\n\tdebugfs_remove(es2->apb_log_dentry);\n\tes2->apb_log_dentry = NULL;\n\n\tkthread_stop(es2->apb_log_task);\n\tes2->apb_log_task = NULL;\n}\n\nstatic ssize_t apb_log_enable_read(struct file *f, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct es2_ap_dev *es2 = file_inode(f)->i_private;\n\tint enable = !IS_ERR_OR_NULL(es2->apb_log_task);\n\tchar tmp_buf[3];\n\n\tsprintf(tmp_buf, \"%d\\n\", enable);\n\treturn simple_read_from_buffer(buf, count, ppos, tmp_buf, 2);\n}\n\nstatic ssize_t apb_log_enable_write(struct file *f, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tint enable;\n\tssize_t retval;\n\tstruct es2_ap_dev *es2 = file_inode(f)->i_private;\n\n\tretval = kstrtoint_from_user(buf, count, 10, &enable);\n\tif (retval)\n\t\treturn retval;\n\n\tif (enable)\n\t\tusb_log_enable(es2);\n\telse\n\t\tusb_log_disable(es2);\n\n\treturn count;\n}\n\nstatic const struct file_operations apb_log_enable_fops = {\n\t.read\t= apb_log_enable_read,\n\t.write\t= apb_log_enable_write,\n};\n\nstatic int apb_get_cport_count(struct usb_device *udev)\n{\n\tint retval;\n\t__le16 *cport_count;\n\n\tcport_count = kzalloc(sizeof(*cport_count), GFP_KERNEL);\n\tif (!cport_count)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t GB_APB_REQUEST_CPORT_COUNT,\n\t\t\t\t USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_INTERFACE, 0, 0, cport_count,\n\t\t\t\t sizeof(*cport_count), ES2_USB_CTRL_TIMEOUT);\n\tif (retval != sizeof(*cport_count)) {\n\t\tdev_err(&udev->dev, \"Cannot retrieve CPort count: %d\\n\",\n\t\t\tretval);\n\n\t\tif (retval >= 0)\n\t\t\tretval = -EIO;\n\n\t\tgoto out;\n\t}\n\n\tretval = le16_to_cpu(*cport_count);\n\n\t \n\tif (retval > U8_MAX) {\n\t\tretval = U8_MAX;\n\t\tdev_warn(&udev->dev, \"Limiting number of CPorts to U8_MAX\\n\");\n\t}\n\nout:\n\tkfree(cport_count);\n\treturn retval;\n}\n\n \nstatic int ap_probe(struct usb_interface *interface,\n\t\t    const struct usb_device_id *id)\n{\n\tstruct es2_ap_dev *es2;\n\tstruct gb_host_device *hd;\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\t__u8 ep_addr;\n\tint retval;\n\tint i;\n\tint num_cports;\n\tbool bulk_out_found = false;\n\tbool bulk_in_found = false;\n\tbool arpc_in_found = false;\n\n\tudev = usb_get_dev(interface_to_usbdev(interface));\n\n\tnum_cports = apb_get_cport_count(udev);\n\tif (num_cports < 0) {\n\t\tusb_put_dev(udev);\n\t\tdev_err(&udev->dev, \"Cannot retrieve CPort count: %d\\n\",\n\t\t\tnum_cports);\n\t\treturn num_cports;\n\t}\n\n\thd = gb_hd_create(&es2_driver, &udev->dev, ES2_GBUF_MSG_SIZE_MAX,\n\t\t\t  num_cports);\n\tif (IS_ERR(hd)) {\n\t\tusb_put_dev(udev);\n\t\treturn PTR_ERR(hd);\n\t}\n\n\tes2 = hd_to_es2(hd);\n\tes2->hd = hd;\n\tes2->usb_intf = interface;\n\tes2->usb_dev = udev;\n\tspin_lock_init(&es2->cport_out_urb_lock);\n\tINIT_KFIFO(es2->apb_log_fifo);\n\tusb_set_intfdata(interface, es2);\n\n\t \n\tretval = gb_hd_cport_reserve(hd, ES2_CPORT_CDSI0);\n\tif (retval)\n\t\tgoto error;\n\tretval = gb_hd_cport_reserve(hd, ES2_CPORT_CDSI1);\n\tif (retval)\n\t\tgoto error;\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tep_addr = endpoint->bEndpointAddress;\n\n\t\tif (usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\tif (!bulk_in_found) {\n\t\t\t\tes2->cport_in.endpoint = ep_addr;\n\t\t\t\tbulk_in_found = true;\n\t\t\t} else if (!arpc_in_found) {\n\t\t\t\tes2->arpc_endpoint_in = ep_addr;\n\t\t\t\tarpc_in_found = true;\n\t\t\t} else {\n\t\t\t\tdev_warn(&udev->dev,\n\t\t\t\t\t \"Unused bulk IN endpoint found: 0x%02x\\n\",\n\t\t\t\t\t ep_addr);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (usb_endpoint_is_bulk_out(endpoint)) {\n\t\t\tif (!bulk_out_found) {\n\t\t\t\tes2->cport_out_endpoint = ep_addr;\n\t\t\t\tbulk_out_found = true;\n\t\t\t} else {\n\t\t\t\tdev_warn(&udev->dev,\n\t\t\t\t\t \"Unused bulk OUT endpoint found: 0x%02x\\n\",\n\t\t\t\t\t ep_addr);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdev_warn(&udev->dev,\n\t\t\t \"Unknown endpoint type found, address 0x%02x\\n\",\n\t\t\t ep_addr);\n\t}\n\tif (!bulk_in_found || !arpc_in_found || !bulk_out_found) {\n\t\tdev_err(&udev->dev, \"Not enough endpoints found in device, aborting!\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\n\t\tstruct urb *urb;\n\t\tu8 *buffer;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tes2->cport_in.urb[i] = urb;\n\n\t\tbuffer = kmalloc(ES2_GBUF_MSG_SIZE_MAX, GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, udev,\n\t\t\t\t  usb_rcvbulkpipe(udev, es2->cport_in.endpoint),\n\t\t\t\t  buffer, ES2_GBUF_MSG_SIZE_MAX,\n\t\t\t\t  cport_in_callback, hd);\n\n\t\tes2->cport_in.buffer[i] = buffer;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\n\t\tstruct urb *urb;\n\t\tu8 *buffer;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tes2->arpc_urb[i] = urb;\n\n\t\tbuffer = kmalloc(ARPC_IN_SIZE_MAX, GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, udev,\n\t\t\t\t  usb_rcvbulkpipe(udev,\n\t\t\t\t\t\t  es2->arpc_endpoint_in),\n\t\t\t\t  buffer, ARPC_IN_SIZE_MAX,\n\t\t\t\t  arpc_in_callback, es2);\n\n\t\tes2->arpc_buffer[i] = buffer;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\n\t\tstruct urb *urb;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tes2->cport_out_urb[i] = urb;\n\t\tes2->cport_out_urb_busy[i] = false;\t \n\t}\n\n\t \n\tes2->apb_log_enable_dentry = debugfs_create_file(\"apb_log_enable\",\n\t\t\t\t\t\t\t 0644,\n\t\t\t\t\t\t\t gb_debugfs_get(), es2,\n\t\t\t\t\t\t\t &apb_log_enable_fops);\n\n\tINIT_LIST_HEAD(&es2->arpcs);\n\tspin_lock_init(&es2->arpc_lock);\n\n\tretval = es2_arpc_in_enable(es2);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = gb_hd_add(hd);\n\tif (retval)\n\t\tgoto err_disable_arpc_in;\n\n\tretval = es2_cport_in_enable(es2, &es2->cport_in);\n\tif (retval)\n\t\tgoto err_hd_del;\n\n\treturn 0;\n\nerr_hd_del:\n\tgb_hd_del(hd);\nerr_disable_arpc_in:\n\tes2_arpc_in_disable(es2);\nerror:\n\tes2_destroy(es2);\n\n\treturn retval;\n}\n\nstatic void ap_disconnect(struct usb_interface *interface)\n{\n\tstruct es2_ap_dev *es2 = usb_get_intfdata(interface);\n\n\tgb_hd_del(es2->hd);\n\n\tes2_cport_in_disable(es2, &es2->cport_in);\n\tes2_arpc_in_disable(es2);\n\n\tes2_destroy(es2);\n}\n\nstatic struct usb_driver es2_ap_driver = {\n\t.name =\t\t\"es2_ap_driver\",\n\t.probe =\tap_probe,\n\t.disconnect =\tap_disconnect,\n\t.id_table =\tid_table,\n\t.soft_unbind =\t1,\n};\n\nmodule_usb_driver(es2_ap_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Greg Kroah-Hartman <gregkh@linuxfoundation.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}