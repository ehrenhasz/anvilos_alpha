{
  "module_name": "connection.c",
  "hash_id": "45203366de0c5f49e05beaf0705ebf227c4b02c98cb5ab354ee5701348f2c2bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/greybus/connection.c",
  "human_readable_source": "\n \n\n#include <linux/workqueue.h>\n#include <linux/greybus.h>\n\n#include \"greybus_trace.h\"\n\n#define GB_CONNECTION_CPORT_QUIESCE_TIMEOUT\t1000\n\nstatic void gb_connection_kref_release(struct kref *kref);\n\nstatic DEFINE_SPINLOCK(gb_connections_lock);\nstatic DEFINE_MUTEX(gb_connection_mutex);\n\n \nstatic bool gb_connection_cport_in_use(struct gb_interface *intf, u16 cport_id)\n{\n\tstruct gb_host_device *hd = intf->hd;\n\tstruct gb_connection *connection;\n\n\tlist_for_each_entry(connection, &hd->connections, hd_links) {\n\t\tif (connection->intf == intf &&\n\t\t    connection->intf_cport_id == cport_id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void gb_connection_get(struct gb_connection *connection)\n{\n\tkref_get(&connection->kref);\n\n\ttrace_gb_connection_get(connection);\n}\n\nstatic void gb_connection_put(struct gb_connection *connection)\n{\n\ttrace_gb_connection_put(connection);\n\n\tkref_put(&connection->kref, gb_connection_kref_release);\n}\n\n \nstatic struct gb_connection *\ngb_connection_hd_find(struct gb_host_device *hd, u16 cport_id)\n{\n\tstruct gb_connection *connection;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gb_connections_lock, flags);\n\tlist_for_each_entry(connection, &hd->connections, hd_links)\n\t\tif (connection->hd_cport_id == cport_id) {\n\t\t\tgb_connection_get(connection);\n\t\t\tgoto found;\n\t\t}\n\tconnection = NULL;\nfound:\n\tspin_unlock_irqrestore(&gb_connections_lock, flags);\n\n\treturn connection;\n}\n\n \nvoid greybus_data_rcvd(struct gb_host_device *hd, u16 cport_id,\n\t\t       u8 *data, size_t length)\n{\n\tstruct gb_connection *connection;\n\n\ttrace_gb_hd_in(hd);\n\n\tconnection = gb_connection_hd_find(hd, cport_id);\n\tif (!connection) {\n\t\tdev_err(&hd->dev,\n\t\t\t\"nonexistent connection (%zu bytes dropped)\\n\", length);\n\t\treturn;\n\t}\n\tgb_connection_recv(connection, data, length);\n\tgb_connection_put(connection);\n}\nEXPORT_SYMBOL_GPL(greybus_data_rcvd);\n\nstatic void gb_connection_kref_release(struct kref *kref)\n{\n\tstruct gb_connection *connection;\n\n\tconnection = container_of(kref, struct gb_connection, kref);\n\n\ttrace_gb_connection_release(connection);\n\n\tkfree(connection);\n}\n\nstatic void gb_connection_init_name(struct gb_connection *connection)\n{\n\tu16 hd_cport_id = connection->hd_cport_id;\n\tu16 cport_id = 0;\n\tu8 intf_id = 0;\n\n\tif (connection->intf) {\n\t\tintf_id = connection->intf->interface_id;\n\t\tcport_id = connection->intf_cport_id;\n\t}\n\n\tsnprintf(connection->name, sizeof(connection->name),\n\t\t \"%u/%u:%u\", hd_cport_id, intf_id, cport_id);\n}\n\n \nstatic struct gb_connection *\n_gb_connection_create(struct gb_host_device *hd, int hd_cport_id,\n\t\t      struct gb_interface *intf,\n\t\t      struct gb_bundle *bundle, int cport_id,\n\t\t      gb_request_handler_t handler,\n\t\t      unsigned long flags)\n{\n\tstruct gb_connection *connection;\n\tint ret;\n\n\tmutex_lock(&gb_connection_mutex);\n\n\tif (intf && gb_connection_cport_in_use(intf, cport_id)) {\n\t\tdev_err(&intf->dev, \"cport %u already in use\\n\", cport_id);\n\t\tret = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tret = gb_hd_cport_allocate(hd, hd_cport_id, flags);\n\tif (ret < 0) {\n\t\tdev_err(&hd->dev, \"failed to allocate cport: %d\\n\", ret);\n\t\tgoto err_unlock;\n\t}\n\thd_cport_id = ret;\n\n\tconnection = kzalloc(sizeof(*connection), GFP_KERNEL);\n\tif (!connection) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hd_cport_release;\n\t}\n\n\tconnection->hd_cport_id = hd_cport_id;\n\tconnection->intf_cport_id = cport_id;\n\tconnection->hd = hd;\n\tconnection->intf = intf;\n\tconnection->bundle = bundle;\n\tconnection->handler = handler;\n\tconnection->flags = flags;\n\tif (intf && (intf->quirks & GB_INTERFACE_QUIRK_NO_CPORT_FEATURES))\n\t\tconnection->flags |= GB_CONNECTION_FLAG_NO_FLOWCTRL;\n\tconnection->state = GB_CONNECTION_STATE_DISABLED;\n\n\tatomic_set(&connection->op_cycle, 0);\n\tmutex_init(&connection->mutex);\n\tspin_lock_init(&connection->lock);\n\tINIT_LIST_HEAD(&connection->operations);\n\n\tconnection->wq = alloc_ordered_workqueue(\"%s:%d\", 0, dev_name(&hd->dev),\n\t\t\t\t\t\t hd_cport_id);\n\tif (!connection->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_connection;\n\t}\n\n\tkref_init(&connection->kref);\n\n\tgb_connection_init_name(connection);\n\n\tspin_lock_irq(&gb_connections_lock);\n\tlist_add(&connection->hd_links, &hd->connections);\n\n\tif (bundle)\n\t\tlist_add(&connection->bundle_links, &bundle->connections);\n\telse\n\t\tINIT_LIST_HEAD(&connection->bundle_links);\n\n\tspin_unlock_irq(&gb_connections_lock);\n\n\tmutex_unlock(&gb_connection_mutex);\n\n\ttrace_gb_connection_create(connection);\n\n\treturn connection;\n\nerr_free_connection:\n\tkfree(connection);\nerr_hd_cport_release:\n\tgb_hd_cport_release(hd, hd_cport_id);\nerr_unlock:\n\tmutex_unlock(&gb_connection_mutex);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct gb_connection *\ngb_connection_create_static(struct gb_host_device *hd, u16 hd_cport_id,\n\t\t\t    gb_request_handler_t handler)\n{\n\treturn _gb_connection_create(hd, hd_cport_id, NULL, NULL, 0, handler,\n\t\t\t\t     GB_CONNECTION_FLAG_HIGH_PRIO);\n}\n\nstruct gb_connection *\ngb_connection_create_control(struct gb_interface *intf)\n{\n\treturn _gb_connection_create(intf->hd, -1, intf, NULL, 0, NULL,\n\t\t\t\t     GB_CONNECTION_FLAG_CONTROL |\n\t\t\t\t     GB_CONNECTION_FLAG_HIGH_PRIO);\n}\n\nstruct gb_connection *\ngb_connection_create(struct gb_bundle *bundle, u16 cport_id,\n\t\t     gb_request_handler_t handler)\n{\n\tstruct gb_interface *intf = bundle->intf;\n\n\treturn _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,\n\t\t\t\t     handler, 0);\n}\nEXPORT_SYMBOL_GPL(gb_connection_create);\n\nstruct gb_connection *\ngb_connection_create_flags(struct gb_bundle *bundle, u16 cport_id,\n\t\t\t   gb_request_handler_t handler,\n\t\t\t   unsigned long flags)\n{\n\tstruct gb_interface *intf = bundle->intf;\n\n\tif (WARN_ON_ONCE(flags & GB_CONNECTION_FLAG_CORE_MASK))\n\t\tflags &= ~GB_CONNECTION_FLAG_CORE_MASK;\n\n\treturn _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,\n\t\t\t\t     handler, flags);\n}\nEXPORT_SYMBOL_GPL(gb_connection_create_flags);\n\nstruct gb_connection *\ngb_connection_create_offloaded(struct gb_bundle *bundle, u16 cport_id,\n\t\t\t       unsigned long flags)\n{\n\tflags |= GB_CONNECTION_FLAG_OFFLOADED;\n\n\treturn gb_connection_create_flags(bundle, cport_id, NULL, flags);\n}\nEXPORT_SYMBOL_GPL(gb_connection_create_offloaded);\n\nstatic int gb_connection_hd_cport_enable(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->cport_enable)\n\t\treturn 0;\n\n\tret = hd->driver->cport_enable(hd, connection->hd_cport_id,\n\t\t\t\t       connection->flags);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to enable host cport: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void gb_connection_hd_cport_disable(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->cport_disable)\n\t\treturn;\n\n\tret = hd->driver->cport_disable(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to disable host cport: %d\\n\",\n\t\t\tconnection->name, ret);\n\t}\n}\n\nstatic int gb_connection_hd_cport_connected(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->cport_connected)\n\t\treturn 0;\n\n\tret = hd->driver->cport_connected(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to set connected state: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_connection_hd_cport_flush(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->cport_flush)\n\t\treturn 0;\n\n\tret = hd->driver->cport_flush(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to flush host cport: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_connection_hd_cport_quiesce(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tsize_t peer_space;\n\tint ret;\n\n\tif (!hd->driver->cport_quiesce)\n\t\treturn 0;\n\n\tpeer_space = sizeof(struct gb_operation_msg_hdr) +\n\t\t\tsizeof(struct gb_cport_shutdown_request);\n\n\tif (connection->mode_switch)\n\t\tpeer_space += sizeof(struct gb_operation_msg_hdr);\n\n\tret = hd->driver->cport_quiesce(hd, connection->hd_cport_id,\n\t\t\t\t\tpeer_space,\n\t\t\t\t\tGB_CONNECTION_CPORT_QUIESCE_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to quiesce host cport: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gb_connection_hd_cport_clear(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->cport_clear)\n\t\treturn 0;\n\n\tret = hd->driver->cport_clear(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to clear host cport: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ngb_connection_svc_connection_create(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tstruct gb_interface *intf;\n\tu8 cport_flags;\n\tint ret;\n\n\tif (gb_connection_is_static(connection))\n\t\treturn 0;\n\n\tintf = connection->intf;\n\n\t \n\tcport_flags = GB_SVC_CPORT_FLAG_CSV_N;\n\tif (gb_connection_flow_control_disabled(connection)) {\n\t\tcport_flags |= GB_SVC_CPORT_FLAG_CSD_N;\n\t} else if (gb_connection_e2efc_enabled(connection)) {\n\t\tcport_flags |= GB_SVC_CPORT_FLAG_CSD_N |\n\t\t\t\tGB_SVC_CPORT_FLAG_E2EFC;\n\t}\n\n\tret = gb_svc_connection_create(hd->svc,\n\t\t\t\t       hd->svc->ap_intf_id,\n\t\t\t\t       connection->hd_cport_id,\n\t\t\t\t       intf->interface_id,\n\t\t\t\t       connection->intf_cport_id,\n\t\t\t\t       cport_flags);\n\tif (ret) {\n\t\tdev_err(&connection->hd->dev,\n\t\t\t\"%s: failed to create svc connection: %d\\n\",\n\t\t\tconnection->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\ngb_connection_svc_connection_destroy(struct gb_connection *connection)\n{\n\tif (gb_connection_is_static(connection))\n\t\treturn;\n\n\tgb_svc_connection_destroy(connection->hd->svc,\n\t\t\t\t  connection->hd->svc->ap_intf_id,\n\t\t\t\t  connection->hd_cport_id,\n\t\t\t\t  connection->intf->interface_id,\n\t\t\t\t  connection->intf_cport_id);\n}\n\n \nstatic int gb_connection_control_connected(struct gb_connection *connection)\n{\n\tstruct gb_control *control;\n\tu16 cport_id = connection->intf_cport_id;\n\tint ret;\n\n\tif (gb_connection_is_static(connection))\n\t\treturn 0;\n\n\tif (gb_connection_is_control(connection))\n\t\treturn 0;\n\n\tcontrol = connection->intf->control;\n\n\tret = gb_control_connected_operation(control, cport_id);\n\tif (ret) {\n\t\tdev_err(&connection->bundle->dev,\n\t\t\t\"failed to connect cport: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\ngb_connection_control_disconnecting(struct gb_connection *connection)\n{\n\tstruct gb_control *control;\n\tu16 cport_id = connection->intf_cport_id;\n\tint ret;\n\n\tif (gb_connection_is_static(connection))\n\t\treturn;\n\n\tcontrol = connection->intf->control;\n\n\tret = gb_control_disconnecting_operation(control, cport_id);\n\tif (ret) {\n\t\tdev_err(&connection->hd->dev,\n\t\t\t\"%s: failed to send disconnecting: %d\\n\",\n\t\t\tconnection->name, ret);\n\t}\n}\n\nstatic void\ngb_connection_control_disconnected(struct gb_connection *connection)\n{\n\tstruct gb_control *control;\n\tu16 cport_id = connection->intf_cport_id;\n\tint ret;\n\n\tif (gb_connection_is_static(connection))\n\t\treturn;\n\n\tcontrol = connection->intf->control;\n\n\tif (gb_connection_is_control(connection)) {\n\t\tif (connection->mode_switch) {\n\t\t\tret = gb_control_mode_switch_operation(control);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tret = gb_control_disconnected_operation(control, cport_id);\n\tif (ret) {\n\t\tdev_warn(&connection->bundle->dev,\n\t\t\t \"failed to disconnect cport: %d\\n\", ret);\n\t}\n}\n\nstatic int gb_connection_shutdown_operation(struct gb_connection *connection,\n\t\t\t\t\t    u8 phase)\n{\n\tstruct gb_cport_shutdown_request *req;\n\tstruct gb_operation *operation;\n\tint ret;\n\n\toperation = gb_operation_create_core(connection,\n\t\t\t\t\t     GB_REQUEST_TYPE_CPORT_SHUTDOWN,\n\t\t\t\t\t     sizeof(*req), 0, 0,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!operation)\n\t\treturn -ENOMEM;\n\n\treq = operation->request->payload;\n\treq->phase = phase;\n\n\tret = gb_operation_request_send_sync(operation);\n\n\tgb_operation_put(operation);\n\n\treturn ret;\n}\n\nstatic int gb_connection_cport_shutdown(struct gb_connection *connection,\n\t\t\t\t\tu8 phase)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tconst struct gb_hd_driver *drv = hd->driver;\n\tint ret;\n\n\tif (gb_connection_is_static(connection))\n\t\treturn 0;\n\n\tif (gb_connection_is_offloaded(connection)) {\n\t\tif (!drv->cport_shutdown)\n\t\t\treturn 0;\n\n\t\tret = drv->cport_shutdown(hd, connection->hd_cport_id, phase,\n\t\t\t\t\t  GB_OPERATION_TIMEOUT_DEFAULT);\n\t} else {\n\t\tret = gb_connection_shutdown_operation(connection, phase);\n\t}\n\n\tif (ret) {\n\t\tdev_err(&hd->dev, \"%s: failed to send cport shutdown (phase %d): %d\\n\",\n\t\t\tconnection->name, phase, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngb_connection_cport_shutdown_phase_1(struct gb_connection *connection)\n{\n\treturn gb_connection_cport_shutdown(connection, 1);\n}\n\nstatic int\ngb_connection_cport_shutdown_phase_2(struct gb_connection *connection)\n{\n\treturn gb_connection_cport_shutdown(connection, 2);\n}\n\n \nstatic void gb_connection_cancel_operations(struct gb_connection *connection,\n\t\t\t\t\t    int errno)\n\t__must_hold(&connection->lock)\n{\n\tstruct gb_operation *operation;\n\n\twhile (!list_empty(&connection->operations)) {\n\t\toperation = list_last_entry(&connection->operations,\n\t\t\t\t\t    struct gb_operation, links);\n\t\tgb_operation_get(operation);\n\t\tspin_unlock_irq(&connection->lock);\n\n\t\tif (gb_operation_is_incoming(operation))\n\t\t\tgb_operation_cancel_incoming(operation, errno);\n\t\telse\n\t\t\tgb_operation_cancel(operation, errno);\n\n\t\tgb_operation_put(operation);\n\n\t\tspin_lock_irq(&connection->lock);\n\t}\n}\n\n \nstatic void\ngb_connection_flush_incoming_operations(struct gb_connection *connection,\n\t\t\t\t\tint errno)\n\t__must_hold(&connection->lock)\n{\n\tstruct gb_operation *operation;\n\tbool incoming;\n\n\twhile (!list_empty(&connection->operations)) {\n\t\tincoming = false;\n\t\tlist_for_each_entry(operation, &connection->operations,\n\t\t\t\t    links) {\n\t\t\tif (gb_operation_is_incoming(operation)) {\n\t\t\t\tgb_operation_get(operation);\n\t\t\t\tincoming = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!incoming)\n\t\t\tbreak;\n\n\t\tspin_unlock_irq(&connection->lock);\n\n\t\t \n\t\tgb_operation_cancel_incoming(operation, errno);\n\t\tgb_operation_put(operation);\n\n\t\tspin_lock_irq(&connection->lock);\n\t}\n}\n\n \nstatic int _gb_connection_enable(struct gb_connection *connection, bool rx)\n{\n\tint ret;\n\n\t \n\tif (connection->state == GB_CONNECTION_STATE_ENABLED_TX) {\n\t\tif (!(connection->handler && rx))\n\t\t\treturn 0;\n\n\t\tspin_lock_irq(&connection->lock);\n\t\tconnection->state = GB_CONNECTION_STATE_ENABLED;\n\t\tspin_unlock_irq(&connection->lock);\n\n\t\treturn 0;\n\t}\n\n\tret = gb_connection_hd_cport_enable(connection);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gb_connection_svc_connection_create(connection);\n\tif (ret)\n\t\tgoto err_hd_cport_clear;\n\n\tret = gb_connection_hd_cport_connected(connection);\n\tif (ret)\n\t\tgoto err_svc_connection_destroy;\n\n\tspin_lock_irq(&connection->lock);\n\tif (connection->handler && rx)\n\t\tconnection->state = GB_CONNECTION_STATE_ENABLED;\n\telse\n\t\tconnection->state = GB_CONNECTION_STATE_ENABLED_TX;\n\tspin_unlock_irq(&connection->lock);\n\n\tret = gb_connection_control_connected(connection);\n\tif (ret)\n\t\tgoto err_control_disconnecting;\n\n\treturn 0;\n\nerr_control_disconnecting:\n\tspin_lock_irq(&connection->lock);\n\tconnection->state = GB_CONNECTION_STATE_DISCONNECTING;\n\tgb_connection_cancel_operations(connection, -ESHUTDOWN);\n\tspin_unlock_irq(&connection->lock);\n\n\t \n\tgb_connection_hd_cport_flush(connection);\n\n\tgb_connection_control_disconnecting(connection);\n\tgb_connection_cport_shutdown_phase_1(connection);\n\tgb_connection_hd_cport_quiesce(connection);\n\tgb_connection_cport_shutdown_phase_2(connection);\n\tgb_connection_control_disconnected(connection);\n\tconnection->state = GB_CONNECTION_STATE_DISABLED;\nerr_svc_connection_destroy:\n\tgb_connection_svc_connection_destroy(connection);\nerr_hd_cport_clear:\n\tgb_connection_hd_cport_clear(connection);\n\n\tgb_connection_hd_cport_disable(connection);\n\n\treturn ret;\n}\n\nint gb_connection_enable(struct gb_connection *connection)\n{\n\tint ret = 0;\n\n\tmutex_lock(&connection->mutex);\n\n\tif (connection->state == GB_CONNECTION_STATE_ENABLED)\n\t\tgoto out_unlock;\n\n\tret = _gb_connection_enable(connection, true);\n\tif (!ret)\n\t\ttrace_gb_connection_enable(connection);\n\nout_unlock:\n\tmutex_unlock(&connection->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gb_connection_enable);\n\nint gb_connection_enable_tx(struct gb_connection *connection)\n{\n\tint ret = 0;\n\n\tmutex_lock(&connection->mutex);\n\n\tif (connection->state == GB_CONNECTION_STATE_ENABLED) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (connection->state == GB_CONNECTION_STATE_ENABLED_TX)\n\t\tgoto out_unlock;\n\n\tret = _gb_connection_enable(connection, false);\n\tif (!ret)\n\t\ttrace_gb_connection_enable(connection);\n\nout_unlock:\n\tmutex_unlock(&connection->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gb_connection_enable_tx);\n\nvoid gb_connection_disable_rx(struct gb_connection *connection)\n{\n\tmutex_lock(&connection->mutex);\n\n\tspin_lock_irq(&connection->lock);\n\tif (connection->state != GB_CONNECTION_STATE_ENABLED) {\n\t\tspin_unlock_irq(&connection->lock);\n\t\tgoto out_unlock;\n\t}\n\tconnection->state = GB_CONNECTION_STATE_ENABLED_TX;\n\tgb_connection_flush_incoming_operations(connection, -ESHUTDOWN);\n\tspin_unlock_irq(&connection->lock);\n\n\ttrace_gb_connection_disable(connection);\n\nout_unlock:\n\tmutex_unlock(&connection->mutex);\n}\nEXPORT_SYMBOL_GPL(gb_connection_disable_rx);\n\nvoid gb_connection_mode_switch_prepare(struct gb_connection *connection)\n{\n\tconnection->mode_switch = true;\n}\n\nvoid gb_connection_mode_switch_complete(struct gb_connection *connection)\n{\n\tgb_connection_svc_connection_destroy(connection);\n\tgb_connection_hd_cport_clear(connection);\n\n\tgb_connection_hd_cport_disable(connection);\n\n\tconnection->mode_switch = false;\n}\n\nvoid gb_connection_disable(struct gb_connection *connection)\n{\n\tmutex_lock(&connection->mutex);\n\n\tif (connection->state == GB_CONNECTION_STATE_DISABLED)\n\t\tgoto out_unlock;\n\n\ttrace_gb_connection_disable(connection);\n\n\tspin_lock_irq(&connection->lock);\n\tconnection->state = GB_CONNECTION_STATE_DISCONNECTING;\n\tgb_connection_cancel_operations(connection, -ESHUTDOWN);\n\tspin_unlock_irq(&connection->lock);\n\n\tgb_connection_hd_cport_flush(connection);\n\n\tgb_connection_control_disconnecting(connection);\n\tgb_connection_cport_shutdown_phase_1(connection);\n\tgb_connection_hd_cport_quiesce(connection);\n\tgb_connection_cport_shutdown_phase_2(connection);\n\tgb_connection_control_disconnected(connection);\n\n\tconnection->state = GB_CONNECTION_STATE_DISABLED;\n\n\t \n\tif (!connection->mode_switch) {\n\t\tgb_connection_svc_connection_destroy(connection);\n\t\tgb_connection_hd_cport_clear(connection);\n\n\t\tgb_connection_hd_cport_disable(connection);\n\t}\n\nout_unlock:\n\tmutex_unlock(&connection->mutex);\n}\nEXPORT_SYMBOL_GPL(gb_connection_disable);\n\n \nvoid gb_connection_disable_forced(struct gb_connection *connection)\n{\n\tmutex_lock(&connection->mutex);\n\n\tif (connection->state == GB_CONNECTION_STATE_DISABLED)\n\t\tgoto out_unlock;\n\n\ttrace_gb_connection_disable(connection);\n\n\tspin_lock_irq(&connection->lock);\n\tconnection->state = GB_CONNECTION_STATE_DISABLED;\n\tgb_connection_cancel_operations(connection, -ESHUTDOWN);\n\tspin_unlock_irq(&connection->lock);\n\n\tgb_connection_hd_cport_flush(connection);\n\n\tgb_connection_svc_connection_destroy(connection);\n\tgb_connection_hd_cport_clear(connection);\n\n\tgb_connection_hd_cport_disable(connection);\nout_unlock:\n\tmutex_unlock(&connection->mutex);\n}\nEXPORT_SYMBOL_GPL(gb_connection_disable_forced);\n\n \nvoid gb_connection_destroy(struct gb_connection *connection)\n{\n\tif (!connection)\n\t\treturn;\n\n\tif (WARN_ON(connection->state != GB_CONNECTION_STATE_DISABLED))\n\t\tgb_connection_disable(connection);\n\n\tmutex_lock(&gb_connection_mutex);\n\n\tspin_lock_irq(&gb_connections_lock);\n\tlist_del(&connection->bundle_links);\n\tlist_del(&connection->hd_links);\n\tspin_unlock_irq(&gb_connections_lock);\n\n\tdestroy_workqueue(connection->wq);\n\n\tgb_hd_cport_release(connection->hd, connection->hd_cport_id);\n\tconnection->hd_cport_id = CPORT_ID_BAD;\n\n\tmutex_unlock(&gb_connection_mutex);\n\n\tgb_connection_put(connection);\n}\nEXPORT_SYMBOL_GPL(gb_connection_destroy);\n\nvoid gb_connection_latency_tag_enable(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->latency_tag_enable)\n\t\treturn;\n\n\tret = hd->driver->latency_tag_enable(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&connection->hd->dev,\n\t\t\t\"%s: failed to enable latency tag: %d\\n\",\n\t\t\tconnection->name, ret);\n\t}\n}\nEXPORT_SYMBOL_GPL(gb_connection_latency_tag_enable);\n\nvoid gb_connection_latency_tag_disable(struct gb_connection *connection)\n{\n\tstruct gb_host_device *hd = connection->hd;\n\tint ret;\n\n\tif (!hd->driver->latency_tag_disable)\n\t\treturn;\n\n\tret = hd->driver->latency_tag_disable(hd, connection->hd_cport_id);\n\tif (ret) {\n\t\tdev_err(&connection->hd->dev,\n\t\t\t\"%s: failed to disable latency tag: %d\\n\",\n\t\t\tconnection->name, ret);\n\t}\n}\nEXPORT_SYMBOL_GPL(gb_connection_latency_tag_disable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}