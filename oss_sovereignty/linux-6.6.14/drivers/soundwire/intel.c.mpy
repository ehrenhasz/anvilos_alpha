{
  "module_name": "intel.c",
  "hash_id": "20e43b98f0006863ec42fab1c769337d325c4bf9079709b6c99434bd15d45034",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/intel.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_intel.h>\n#include \"cadence_master.h\"\n#include \"bus.h\"\n#include \"intel.h\"\n\nstatic int intel_wait_bit(void __iomem *base, int offset, u32 mask, u32 target)\n{\n\tint timeout = 10;\n\tu32 reg_read;\n\n\tdo {\n\t\treg_read = readl(base + offset);\n\t\tif ((reg_read & mask) == target)\n\t\t\treturn 0;\n\n\t\ttimeout--;\n\t\tusleep_range(50, 100);\n\t} while (timeout != 0);\n\n\treturn -EAGAIN;\n}\n\nstatic int intel_clear_bit(void __iomem *base, int offset, u32 value, u32 mask)\n{\n\twritel(value, base + offset);\n\treturn intel_wait_bit(base, offset, mask, 0);\n}\n\nstatic int intel_set_bit(void __iomem *base, int offset, u32 value, u32 mask)\n{\n\twritel(value, base + offset);\n\treturn intel_wait_bit(base, offset, mask, mask);\n}\n\n \n#ifdef CONFIG_DEBUG_FS\n\n#define RD_BUF (2 * PAGE_SIZE)\n\nstatic ssize_t intel_sprintf(void __iomem *mem, bool l,\n\t\t\t     char *buf, size_t pos, unsigned int reg)\n{\n\tint value;\n\n\tif (l)\n\t\tvalue = intel_readl(mem, reg);\n\telse\n\t\tvalue = intel_readw(mem, reg);\n\n\treturn scnprintf(buf + pos, RD_BUF - pos, \"%4x\\t%4x\\n\", reg, value);\n}\n\nstatic int intel_reg_show(struct seq_file *s_file, void *data)\n{\n\tstruct sdw_intel *sdw = s_file->private;\n\tvoid __iomem *s = sdw->link_res->shim;\n\tvoid __iomem *a = sdw->link_res->alh;\n\tchar *buf;\n\tssize_t ret;\n\tint i, j;\n\tunsigned int links, reg;\n\n\tbuf = kzalloc(RD_BUF, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlinks = intel_readl(s, SDW_SHIM_LCAP) & SDW_SHIM_LCAP_LCOUNT_MASK;\n\n\tret = scnprintf(buf, RD_BUF, \"Register  Value\\n\");\n\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\nShim\\n\");\n\n\tfor (i = 0; i < links; i++) {\n\t\treg = SDW_SHIM_LCAP + i * 4;\n\t\tret += intel_sprintf(s, true, buf, ret, reg);\n\t}\n\n\tfor (i = 0; i < links; i++) {\n\t\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\nLink%d\\n\", i);\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTLSCAP(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTLS0CM(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTLS1CM(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTLS2CM(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTLS3CM(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_PCMSCAP(i));\n\n\t\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\n PCMSyCH registers\\n\");\n\n\t\t \n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tret += intel_sprintf(s, false, buf, ret,\n\t\t\t\t\tSDW_SHIM_PCMSYCHM(i, j));\n\t\t\tret += intel_sprintf(s, false, buf, ret,\n\t\t\t\t\tSDW_SHIM_PCMSYCHC(i, j));\n\t\t}\n\t\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\n IOCTL, CTMCTL\\n\");\n\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_IOCTL(i));\n\t\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_CTMCTL(i));\n\t}\n\n\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\nWake registers\\n\");\n\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_WAKEEN);\n\tret += intel_sprintf(s, false, buf, ret, SDW_SHIM_WAKESTS);\n\n\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\nALH STRMzCFG\\n\");\n\tfor (i = 0; i < SDW_ALH_NUM_STREAMS; i++)\n\t\tret += intel_sprintf(a, true, buf, ret, SDW_ALH_STRMZCFG(i));\n\n\tseq_printf(s_file, \"%s\", buf);\n\tkfree(buf);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(intel_reg);\n\nstatic int intel_set_m_datamode(void *data, u64 value)\n{\n\tstruct sdw_intel *sdw = data;\n\tstruct sdw_bus *bus = &sdw->cdns.bus;\n\n\tif (value > SDW_PORT_DATA_MODE_STATIC_1)\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tbus->params.m_data_mode = value;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(intel_set_m_datamode_fops, NULL,\n\t\t\t intel_set_m_datamode, \"%llu\\n\");\n\nstatic int intel_set_s_datamode(void *data, u64 value)\n{\n\tstruct sdw_intel *sdw = data;\n\tstruct sdw_bus *bus = &sdw->cdns.bus;\n\n\tif (value > SDW_PORT_DATA_MODE_STATIC_1)\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tbus->params.s_data_mode = value;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(intel_set_s_datamode_fops, NULL,\n\t\t\t intel_set_s_datamode, \"%llu\\n\");\n\nstatic void intel_debugfs_init(struct sdw_intel *sdw)\n{\n\tstruct dentry *root = sdw->cdns.bus.debugfs;\n\n\tif (!root)\n\t\treturn;\n\n\tsdw->debugfs = debugfs_create_dir(\"intel-sdw\", root);\n\n\tdebugfs_create_file(\"intel-registers\", 0400, sdw->debugfs, sdw,\n\t\t\t    &intel_reg_fops);\n\n\tdebugfs_create_file(\"intel-m-datamode\", 0200, sdw->debugfs, sdw,\n\t\t\t    &intel_set_m_datamode_fops);\n\n\tdebugfs_create_file(\"intel-s-datamode\", 0200, sdw->debugfs, sdw,\n\t\t\t    &intel_set_s_datamode_fops);\n\n\tsdw_cdns_debugfs_init(&sdw->cdns, sdw->debugfs);\n}\n\nstatic void intel_debugfs_exit(struct sdw_intel *sdw)\n{\n\tdebugfs_remove_recursive(sdw->debugfs);\n}\n#else\nstatic void intel_debugfs_init(struct sdw_intel *sdw) {}\nstatic void intel_debugfs_exit(struct sdw_intel *sdw) {}\n#endif  \n\n \n \nstatic void intel_shim_glue_to_master_ip(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tu16 ioctl;\n\n\t \n\tioctl = intel_readw(shim,  SDW_SHIM_IOCTL(link_id));\n\n\tioctl &= ~(SDW_SHIM_IOCTL_DOE);\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl &= ~(SDW_SHIM_IOCTL_DO);\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl |= (SDW_SHIM_IOCTL_MIF);\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl &= ~(SDW_SHIM_IOCTL_BKE);\n\tioctl &= ~(SDW_SHIM_IOCTL_COE);\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\t \n}\n\n \nstatic void intel_shim_master_ip_to_glue(struct sdw_intel *sdw)\n{\n\tunsigned int link_id = sdw->instance;\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tu16 ioctl;\n\n\t \n\tioctl = intel_readw(shim, SDW_SHIM_IOCTL(link_id));\n\tioctl |= SDW_SHIM_IOCTL_BKE;\n\tioctl |= SDW_SHIM_IOCTL_COE;\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl &= ~(SDW_SHIM_IOCTL_MIF);\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\t \n}\n\n \nstatic void intel_shim_init(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tu16 ioctl = 0, act;\n\n\t \n\tioctl |= SDW_SHIM_IOCTL_BKE;\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl |= SDW_SHIM_IOCTL_WPDD;\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl |= SDW_SHIM_IOCTL_DO;\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tioctl |= SDW_SHIM_IOCTL_DOE;\n\tintel_writew(shim, SDW_SHIM_IOCTL(link_id), ioctl);\n\tusleep_range(10, 15);\n\n\tintel_shim_glue_to_master_ip(sdw);\n\n\tact = intel_readw(shim, SDW_SHIM_CTMCTL(link_id));\n\tu16p_replace_bits(&act, 0x1, SDW_SHIM_CTMCTL_DOAIS);\n\tact |= SDW_SHIM_CTMCTL_DACTQE;\n\tact |= SDW_SHIM_CTMCTL_DODS;\n\tintel_writew(shim, SDW_SHIM_CTMCTL(link_id), act);\n\tusleep_range(10, 15);\n}\n\nstatic int intel_shim_check_wake(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim;\n\tu16 wake_sts;\n\n\tshim = sdw->link_res->shim;\n\twake_sts = intel_readw(shim, SDW_SHIM_WAKESTS);\n\n\treturn wake_sts & BIT(sdw->instance);\n}\n\nstatic void intel_shim_wake(struct sdw_intel *sdw, bool wake_enable)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tu16 wake_en, wake_sts;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\twake_en = intel_readw(shim, SDW_SHIM_WAKEEN);\n\n\tif (wake_enable) {\n\t\t \n\t\twake_en |= (SDW_SHIM_WAKEEN_ENABLE << link_id);\n\t\tintel_writew(shim, SDW_SHIM_WAKEEN, wake_en);\n\t} else {\n\t\t \n\t\twake_en &= ~(SDW_SHIM_WAKEEN_ENABLE << link_id);\n\t\tintel_writew(shim, SDW_SHIM_WAKEEN, wake_en);\n\n\t\t \n\t\twake_sts = intel_readw(shim, SDW_SHIM_WAKESTS);\n\t\twake_sts |= (SDW_SHIM_WAKESTS_STATUS << link_id);\n\t\tintel_writew(shim, SDW_SHIM_WAKESTS, wake_sts);\n\t}\n\tmutex_unlock(sdw->link_res->shim_lock);\n}\n\nstatic bool intel_check_cmdsync_unlocked(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tint sync_reg;\n\n\tsync_reg = intel_readl(shim, SDW_SHIM_SYNC);\n\treturn !!(sync_reg & SDW_SHIM_SYNC_CMDSYNC_MASK);\n}\n\nstatic int intel_link_power_up(struct sdw_intel *sdw)\n{\n\tunsigned int link_id = sdw->instance;\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tu32 *shim_mask = sdw->link_res->shim_mask;\n\tstruct sdw_bus *bus = &sdw->cdns.bus;\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tu32 spa_mask, cpa_mask;\n\tu32 link_control;\n\tint ret = 0;\n\tu32 syncprd;\n\tu32 sync_reg;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\t \n\tif (prop->mclk_freq % 6000000)\n\t\tsyncprd = SDW_SHIM_SYNC_SYNCPRD_VAL_38_4;\n\telse\n\t\tsyncprd = SDW_SHIM_SYNC_SYNCPRD_VAL_24;\n\n\tif (!*shim_mask) {\n\t\tdev_dbg(sdw->cdns.dev, \"powering up all links\\n\");\n\n\t\t \n\t\tdev_dbg(sdw->cdns.dev,\n\t\t\t\"first link up, programming SYNCPRD\\n\");\n\n\t\t \n\t\tsync_reg = intel_readl(shim, SDW_SHIM_SYNC);\n\t\tu32p_replace_bits(&sync_reg, syncprd, SDW_SHIM_SYNC_SYNCPRD);\n\n\t\t \n\t\tsync_reg |= SDW_SHIM_SYNC_SYNCCPU;\n\t\tintel_writel(shim, SDW_SHIM_SYNC, sync_reg);\n\n\t\t \n\t\tlink_control = intel_readl(shim, SDW_SHIM_LCTL);\n\n\t\t \n\t\tspa_mask = FIELD_PREP(SDW_SHIM_LCTL_SPA_MASK, sdw->link_res->link_mask);\n\t\tcpa_mask = FIELD_PREP(SDW_SHIM_LCTL_CPA_MASK, sdw->link_res->link_mask);\n\n\t\tlink_control |=  spa_mask;\n\n\t\tret = intel_set_bit(shim, SDW_SHIM_LCTL, link_control, cpa_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdw->cdns.dev, \"Failed to power up link: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = intel_wait_bit(shim, SDW_SHIM_SYNC,\n\t\t\t\t     SDW_SHIM_SYNC_SYNCCPU, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdw->cdns.dev,\n\t\t\t\t\"Failed to set SHIM_SYNC: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*shim_mask |= BIT(link_id);\n\n\tsdw->cdns.link_up = true;\n\n\tintel_shim_init(sdw);\n\nout:\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\nstatic int intel_link_power_down(struct sdw_intel *sdw)\n{\n\tu32 link_control, spa_mask, cpa_mask;\n\tunsigned int link_id = sdw->instance;\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tu32 *shim_mask = sdw->link_res->shim_mask;\n\tint ret = 0;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\tif (!(*shim_mask & BIT(link_id)))\n\t\tdev_err(sdw->cdns.dev,\n\t\t\t\"%s: Unbalanced power-up/down calls\\n\", __func__);\n\n\tsdw->cdns.link_up = false;\n\n\tintel_shim_master_ip_to_glue(sdw);\n\n\t*shim_mask &= ~BIT(link_id);\n\n\tif (!*shim_mask) {\n\n\t\tdev_dbg(sdw->cdns.dev, \"powering down all links\\n\");\n\n\t\t \n\t\tlink_control = intel_readl(shim, SDW_SHIM_LCTL);\n\n\t\t \n\t\tspa_mask = FIELD_PREP(SDW_SHIM_LCTL_SPA_MASK, ~sdw->link_res->link_mask);\n\t\tcpa_mask = FIELD_PREP(SDW_SHIM_LCTL_CPA_MASK, sdw->link_res->link_mask);\n\n\t\tlink_control &=  spa_mask;\n\n\t\tret = intel_clear_bit(shim, SDW_SHIM_LCTL, link_control, cpa_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdw->cdns.dev, \"%s: could not power down link\\n\", __func__);\n\n\t\t\t \n\t\t}\n\t}\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\nstatic void intel_shim_sync_arm(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tu32 sync_reg;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\t \n\tsync_reg = intel_readl(shim, SDW_SHIM_SYNC);\n\tsync_reg |= (SDW_SHIM_SYNC_CMDSYNC << sdw->instance);\n\tintel_writel(shim, SDW_SHIM_SYNC, sync_reg);\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n}\n\nstatic int intel_shim_sync_go_unlocked(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tu32 sync_reg;\n\n\t \n\tsync_reg = intel_readl(shim, SDW_SHIM_SYNC);\n\n\t \n\tsync_reg |= SDW_SHIM_SYNC_SYNCGO;\n\n\tintel_writel(shim, SDW_SHIM_SYNC, sync_reg);\n\n\treturn 0;\n}\n\nstatic int intel_shim_sync_go(struct sdw_intel *sdw)\n{\n\tint ret;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\tret = intel_shim_sync_go_unlocked(sdw);\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\n \nstatic void intel_pdi_init(struct sdw_intel *sdw,\n\t\t\t   struct sdw_cdns_stream_config *config)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tint pcm_cap;\n\n\t \n\tpcm_cap = intel_readw(shim, SDW_SHIM_PCMSCAP(link_id));\n\n\tconfig->pcm_bd = FIELD_GET(SDW_SHIM_PCMSCAP_BSS, pcm_cap);\n\tconfig->pcm_in = FIELD_GET(SDW_SHIM_PCMSCAP_ISS, pcm_cap);\n\tconfig->pcm_out = FIELD_GET(SDW_SHIM_PCMSCAP_OSS, pcm_cap);\n\n\tdev_dbg(sdw->cdns.dev, \"PCM cap bd:%d in:%d out:%d\\n\",\n\t\tconfig->pcm_bd, config->pcm_in, config->pcm_out);\n}\n\nstatic int\nintel_pdi_get_ch_cap(struct sdw_intel *sdw, unsigned int pdi_num)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tint count;\n\n\tcount = intel_readw(shim, SDW_SHIM_PCMSYCHC(link_id, pdi_num));\n\n\t \n\tif (pdi_num == 2)\n\t\tcount = 7;\n\n\t \n\tcount++;\n\n\treturn count;\n}\n\nstatic int intel_pdi_get_ch_update(struct sdw_intel *sdw,\n\t\t\t\t   struct sdw_cdns_pdi *pdi,\n\t\t\t\t   unsigned int num_pdi,\n\t\t\t\t   unsigned int *num_ch)\n{\n\tint i, ch_count = 0;\n\n\tfor (i = 0; i < num_pdi; i++) {\n\t\tpdi->ch_count = intel_pdi_get_ch_cap(sdw, pdi->num);\n\t\tch_count += pdi->ch_count;\n\t\tpdi++;\n\t}\n\n\t*num_ch = ch_count;\n\treturn 0;\n}\n\nstatic int intel_pdi_stream_ch_update(struct sdw_intel *sdw,\n\t\t\t\t      struct sdw_cdns_streams *stream)\n{\n\tintel_pdi_get_ch_update(sdw, stream->bd, stream->num_bd,\n\t\t\t\t&stream->num_ch_bd);\n\n\tintel_pdi_get_ch_update(sdw, stream->in, stream->num_in,\n\t\t\t\t&stream->num_ch_in);\n\n\tintel_pdi_get_ch_update(sdw, stream->out, stream->num_out,\n\t\t\t\t&stream->num_ch_out);\n\n\treturn 0;\n}\n\nstatic void\nintel_pdi_shim_configure(struct sdw_intel *sdw, struct sdw_cdns_pdi *pdi)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tunsigned int link_id = sdw->instance;\n\tint pdi_conf = 0;\n\n\t \n\tpdi->intel_alh_id = (link_id * 16) + pdi->num + 3;\n\tif (pdi->num >= 2)\n\t\tpdi->intel_alh_id += 2;\n\n\t \n\tif (pdi->type != SDW_STREAM_PCM)\n\t\treturn;\n\n\tif (pdi->dir == SDW_DATA_DIR_RX)\n\t\tpdi_conf |= SDW_SHIM_PCMSYCM_DIR;\n\telse\n\t\tpdi_conf &= ~(SDW_SHIM_PCMSYCM_DIR);\n\n\tu32p_replace_bits(&pdi_conf, pdi->intel_alh_id, SDW_SHIM_PCMSYCM_STREAM);\n\tu32p_replace_bits(&pdi_conf, pdi->l_ch_num, SDW_SHIM_PCMSYCM_LCHN);\n\tu32p_replace_bits(&pdi_conf, pdi->h_ch_num, SDW_SHIM_PCMSYCM_HCHN);\n\n\tintel_writew(shim, SDW_SHIM_PCMSYCHM(link_id, pdi->num), pdi_conf);\n}\n\nstatic void\nintel_pdi_alh_configure(struct sdw_intel *sdw, struct sdw_cdns_pdi *pdi)\n{\n\tvoid __iomem *alh = sdw->link_res->alh;\n\tunsigned int link_id = sdw->instance;\n\tunsigned int conf;\n\n\t \n\tpdi->intel_alh_id = (link_id * 16) + pdi->num + 3;\n\tif (pdi->num >= 2)\n\t\tpdi->intel_alh_id += 2;\n\n\t \n\tconf = intel_readl(alh, SDW_ALH_STRMZCFG(pdi->intel_alh_id));\n\n\tu32p_replace_bits(&conf, SDW_ALH_STRMZCFG_DMAT_VAL, SDW_ALH_STRMZCFG_DMAT);\n\tu32p_replace_bits(&conf, pdi->ch_count - 1, SDW_ALH_STRMZCFG_CHN);\n\n\tintel_writel(alh, SDW_ALH_STRMZCFG(pdi->intel_alh_id), conf);\n}\n\nstatic int intel_params_stream(struct sdw_intel *sdw,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai,\n\t\t\t       struct snd_pcm_hw_params *hw_params,\n\t\t\t       int link_id, int alh_stream_id)\n{\n\tstruct sdw_intel_link_res *res = sdw->link_res;\n\tstruct sdw_intel_stream_params_data params_data;\n\n\tparams_data.substream = substream;\n\tparams_data.dai = dai;\n\tparams_data.hw_params = hw_params;\n\tparams_data.link_id = link_id;\n\tparams_data.alh_stream_id = alh_stream_id;\n\n\tif (res->ops && res->ops->params_stream && res->dev)\n\t\treturn res->ops->params_stream(res->dev,\n\t\t\t\t\t       &params_data);\n\treturn -EIO;\n}\n\n \n\nstatic int intel_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tstruct sdw_cdns_pdi *pdi;\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_port_config *pconfig;\n\tint ch, dir;\n\tint ret;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\tch = params_channels(params);\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tdir = SDW_DATA_DIR_RX;\n\telse\n\t\tdir = SDW_DATA_DIR_TX;\n\n\tpdi = sdw_cdns_alloc_pdi(cdns, &cdns->pcm, ch, dir, dai->id);\n\n\tif (!pdi) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tintel_pdi_shim_configure(sdw, pdi);\n\tintel_pdi_alh_configure(sdw, pdi);\n\tsdw_cdns_config_stream(cdns, ch, dir, pdi);\n\n\t \n\tdai_runtime->paused = false;\n\tdai_runtime->suspended = false;\n\tdai_runtime->pdi = pdi;\n\n\t \n\tret = intel_params_stream(sdw, substream, dai, params,\n\t\t\t\t  sdw->instance,\n\t\t\t\t  pdi->intel_alh_id);\n\tif (ret)\n\t\tgoto error;\n\n\tsconfig.direction = dir;\n\tsconfig.ch_count = ch;\n\tsconfig.frame_rate = params_rate(params);\n\tsconfig.type = dai_runtime->stream_type;\n\n\tsconfig.bps = snd_pcm_format_width(params_format(params));\n\n\t \n\tpconfig = kzalloc(sizeof(*pconfig), GFP_KERNEL);\n\tif (!pconfig) {\n\t\tret =  -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpconfig->num = pdi->num;\n\tpconfig->ch_mask = (1 << ch) - 1;\n\n\tret = sdw_stream_add_master(&cdns->bus, &sconfig,\n\t\t\t\t    pconfig, 1, dai_runtime->stream);\n\tif (ret)\n\t\tdev_err(cdns->dev, \"add master to stream failed:%d\\n\", ret);\n\n\tkfree(pconfig);\nerror:\n\treturn ret;\n}\n\nstatic int intel_prepare(struct snd_pcm_substream *substream,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ch, dir;\n\tint ret = 0;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime) {\n\t\tdev_err(dai->dev, \"failed to get dai runtime in %s\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tif (dai_runtime->suspended) {\n\t\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\t\tstruct snd_pcm_hw_params *hw_params;\n\n\t\thw_params = &rtd->dpcm[substream->stream].hw_params;\n\n\t\tdai_runtime->suspended = false;\n\n\t\t \n\n\t\t \n\t\tch = params_channels(hw_params);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tdir = SDW_DATA_DIR_RX;\n\t\telse\n\t\t\tdir = SDW_DATA_DIR_TX;\n\n\t\tintel_pdi_shim_configure(sdw, dai_runtime->pdi);\n\t\tintel_pdi_alh_configure(sdw, dai_runtime->pdi);\n\t\tsdw_cdns_config_stream(cdns, ch, dir, dai_runtime->pdi);\n\n\t\t \n\t\tret = intel_params_stream(sdw, substream, dai,\n\t\t\t\t\t  hw_params,\n\t\t\t\t\t  sdw->instance,\n\t\t\t\t\t  dai_runtime->pdi->intel_alh_id);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nintel_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ret;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\t \n\tret = sdw_stream_remove_master(&cdns->bus, dai_runtime->stream);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"remove master from stream %s failed: %d\\n\",\n\t\t\tdai_runtime->stream->name, ret);\n\t\treturn ret;\n\t}\n\n\tdai_runtime->pdi = NULL;\n\n\treturn 0;\n}\n\nstatic int intel_pcm_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t    void *stream, int direction)\n{\n\treturn cdns_set_sdw_stream(dai, stream, direction);\n}\n\nstatic void *intel_get_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t  int direction)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn dai_runtime->stream;\n}\n\nstatic int intel_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ret = 0;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime) {\n\t\tdev_err(dai->dev, \"failed to get dai runtime in %s\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\n\t\t \n\n\t\tdai_runtime->suspended = true;\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdai_runtime->paused = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdai_runtime->paused = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int intel_component_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\n\t \n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int intel_component_dais_suspend(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai;\n\n\t \n\tfor_each_component_dais(component, dai) {\n\t\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\t\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\n\t\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\n\t\tif (!dai_runtime)\n\t\t\tcontinue;\n\n\t\tif (dai_runtime->suspended)\n\t\t\tcontinue;\n\n\t\tif (dai_runtime->paused)\n\t\t\tdai_runtime->suspended = true;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops intel_pcm_dai_ops = {\n\t.hw_params = intel_hw_params,\n\t.prepare = intel_prepare,\n\t.hw_free = intel_hw_free,\n\t.trigger = intel_trigger,\n\t.set_stream = intel_pcm_set_sdw_stream,\n\t.get_stream = intel_get_sdw_stream,\n};\n\nstatic const struct snd_soc_component_driver dai_component = {\n\t.name\t\t\t= \"soundwire\",\n\t.probe\t\t\t= intel_component_probe,\n\t.suspend\t\t= intel_component_dais_suspend,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int intel_create_dai(struct sdw_cdns *cdns,\n\t\t\t    struct snd_soc_dai_driver *dais,\n\t\t\t    enum intel_pdi_type type,\n\t\t\t    u32 num, u32 off, u32 max_ch)\n{\n\tint i;\n\n\tif (num == 0)\n\t\treturn 0;\n\n\tfor (i = off; i < (off + num); i++) {\n\t\tdais[i].name = devm_kasprintf(cdns->dev, GFP_KERNEL,\n\t\t\t\t\t      \"SDW%d Pin%d\",\n\t\t\t\t\t      cdns->instance, i);\n\t\tif (!dais[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (type == INTEL_PDI_BD || type == INTEL_PDI_OUT) {\n\t\t\tdais[i].playback.channels_min = 1;\n\t\t\tdais[i].playback.channels_max = max_ch;\n\t\t}\n\n\t\tif (type == INTEL_PDI_BD || type == INTEL_PDI_IN) {\n\t\t\tdais[i].capture.channels_min = 1;\n\t\t\tdais[i].capture.channels_max = max_ch;\n\t\t}\n\n\t\tdais[i].ops = &intel_pcm_dai_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_register_dai(struct sdw_intel *sdw)\n{\n\tstruct sdw_cdns_dai_runtime **dai_runtime_array;\n\tstruct sdw_cdns_stream_config config;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_cdns_streams *stream;\n\tstruct snd_soc_dai_driver *dais;\n\tint num_dai, ret, off = 0;\n\n\t \n\tintel_pdi_init(sdw, &config);\n\tret = sdw_cdns_pdi_init(cdns, config);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_pdi_stream_ch_update(sdw, &sdw->cdns.pcm);\n\n\t \n\tnum_dai = cdns->pcm.num_pdi;\n\n\tdai_runtime_array = devm_kcalloc(cdns->dev, num_dai,\n\t\t\t\t\t sizeof(struct sdw_cdns_dai_runtime *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!dai_runtime_array)\n\t\treturn -ENOMEM;\n\tcdns->dai_runtime_array = dai_runtime_array;\n\n\tdais = devm_kcalloc(cdns->dev, num_dai, sizeof(*dais), GFP_KERNEL);\n\tif (!dais)\n\t\treturn -ENOMEM;\n\n\t \n\tstream = &cdns->pcm;\n\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_IN, cdns->pcm.num_in,\n\t\t\t       off, stream->num_ch_in);\n\tif (ret)\n\t\treturn ret;\n\n\toff += cdns->pcm.num_in;\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_OUT, cdns->pcm.num_out,\n\t\t\t       off, stream->num_ch_out);\n\tif (ret)\n\t\treturn ret;\n\n\toff += cdns->pcm.num_out;\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_BD, cdns->pcm.num_bd,\n\t\t\t       off, stream->num_ch_bd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(cdns->dev, &dai_component,\n\t\t\t\t\t       dais, num_dai);\n}\n\n\nconst struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops = {\n\t.debugfs_init = intel_debugfs_init,\n\t.debugfs_exit = intel_debugfs_exit,\n\n\t.register_dai = intel_register_dai,\n\n\t.check_clock_stop = intel_check_clock_stop,\n\t.start_bus = intel_start_bus,\n\t.start_bus_after_reset = intel_start_bus_after_reset,\n\t.start_bus_after_clock_stop = intel_start_bus_after_clock_stop,\n\t.stop_bus = intel_stop_bus,\n\n\t.link_power_up = intel_link_power_up,\n\t.link_power_down = intel_link_power_down,\n\n\t.shim_check_wake = intel_shim_check_wake,\n\t.shim_wake = intel_shim_wake,\n\n\t.pre_bank_switch = intel_pre_bank_switch,\n\t.post_bank_switch = intel_post_bank_switch,\n\n\t.sync_arm = intel_shim_sync_arm,\n\t.sync_go_unlocked = intel_shim_sync_go_unlocked,\n\t.sync_go = intel_shim_sync_go,\n\t.sync_check_cmdsync_unlocked = intel_check_cmdsync_unlocked,\n};\nEXPORT_SYMBOL_NS(sdw_intel_cnl_hw_ops, SOUNDWIRE_INTEL);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}