{
  "module_name": "generic_bandwidth_allocation.c",
  "hash_id": "6d2fbc85da799a0b830d6af76d7c27ab58a53431e477eca031d546d85f4e9b1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/generic_bandwidth_allocation.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/soundwire/sdw.h>\n#include \"bus.h\"\n\n#define SDW_STRM_RATE_GROUPING\t\t1\n\nstruct sdw_group_params {\n\tunsigned int rate;\n\tint full_bw;\n\tint payload_bw;\n\tint hwidth;\n};\n\nstruct sdw_group {\n\tunsigned int count;\n\tunsigned int max_size;\n\tunsigned int *rates;\n};\n\nvoid sdw_compute_slave_ports(struct sdw_master_runtime *m_rt,\n\t\t\t     struct sdw_transport_data *t_data)\n{\n\tstruct sdw_slave_runtime *s_rt = NULL;\n\tstruct sdw_port_runtime *p_rt;\n\tint port_bo, sample_int;\n\tunsigned int rate, bps, ch = 0;\n\tunsigned int slave_total_ch;\n\tstruct sdw_bus_params *b_params = &m_rt->bus->params;\n\n\tport_bo = t_data->block_offset;\n\n\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\trate = m_rt->stream->params.rate;\n\t\tbps = m_rt->stream->params.bps;\n\t\tsample_int = (m_rt->bus->params.curr_dr_freq / rate);\n\t\tslave_total_ch = 0;\n\n\t\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t\tch = hweight32(p_rt->ch_mask);\n\n\t\t\tsdw_fill_xport_params(&p_rt->transport_params,\n\t\t\t\t\t      p_rt->num, false,\n\t\t\t\t\t      SDW_BLK_GRP_CNT_1,\n\t\t\t\t\t      sample_int, port_bo, port_bo >> 8,\n\t\t\t\t\t      t_data->hstart,\n\t\t\t\t\t      t_data->hstop,\n\t\t\t\t\t      SDW_BLK_PKG_PER_PORT, 0x0);\n\n\t\t\tsdw_fill_port_params(&p_rt->port_params,\n\t\t\t\t\t     p_rt->num, bps,\n\t\t\t\t\t     SDW_PORT_FLOW_MODE_ISOCH,\n\t\t\t\t\t     b_params->s_data_mode);\n\n\t\t\tport_bo += bps * ch;\n\t\t\tslave_total_ch += ch;\n\t\t}\n\n\t\tif (m_rt->direction == SDW_DATA_DIR_TX &&\n\t\t    m_rt->ch_count == slave_total_ch) {\n\t\t\t \n\t\t\tport_bo = t_data->block_offset;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(sdw_compute_slave_ports);\n\nstatic void sdw_compute_master_ports(struct sdw_master_runtime *m_rt,\n\t\t\t\t     struct sdw_group_params *params,\n\t\t\t\t     int port_bo, int hstop)\n{\n\tstruct sdw_transport_data t_data = {0};\n\tstruct sdw_port_runtime *p_rt;\n\tstruct sdw_bus *bus = m_rt->bus;\n\tstruct sdw_bus_params *b_params = &bus->params;\n\tint sample_int, hstart = 0;\n\tunsigned int rate, bps, ch;\n\n\trate = m_rt->stream->params.rate;\n\tbps = m_rt->stream->params.bps;\n\tch = m_rt->ch_count;\n\tsample_int = (bus->params.curr_dr_freq / rate);\n\n\tif (rate != params->rate)\n\t\treturn;\n\n\tt_data.hstop = hstop;\n\thstart = hstop - params->hwidth + 1;\n\tt_data.hstart = hstart;\n\n\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\n\t\tsdw_fill_xport_params(&p_rt->transport_params, p_rt->num,\n\t\t\t\t      false, SDW_BLK_GRP_CNT_1, sample_int,\n\t\t\t\t      port_bo, port_bo >> 8, hstart, hstop,\n\t\t\t\t      SDW_BLK_PKG_PER_PORT, 0x0);\n\n\t\tsdw_fill_port_params(&p_rt->port_params,\n\t\t\t\t     p_rt->num, bps,\n\t\t\t\t     SDW_PORT_FLOW_MODE_ISOCH,\n\t\t\t\t     b_params->m_data_mode);\n\n\t\t \n\t\tif (!(p_rt == list_first_entry(&m_rt->port_list,\n\t\t\t\t\t       struct sdw_port_runtime,\n\t\t\t\t\t       port_node))) {\n\t\t\tport_bo += bps * ch;\n\t\t\tcontinue;\n\t\t}\n\n\t\tt_data.hstart = hstart;\n\t\tt_data.hstop = hstop;\n\t\tt_data.block_offset = port_bo;\n\t\tt_data.sub_block_offset = 0;\n\t\tport_bo += bps * ch;\n\t}\n\n\tsdw_compute_slave_ports(m_rt, &t_data);\n}\n\nstatic void _sdw_compute_port_params(struct sdw_bus *bus,\n\t\t\t\t     struct sdw_group_params *params, int count)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tint hstop = bus->params.col - 1;\n\tint port_bo, i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tport_bo = 1;\n\n\t\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\t\t\tsdw_compute_master_ports(m_rt, &params[i], port_bo, hstop);\n\n\t\t\tport_bo += m_rt->ch_count * m_rt->stream->params.bps;\n\t\t}\n\n\t\thstop = hstop - params[i].hwidth;\n\t}\n}\n\nstatic int sdw_compute_group_params(struct sdw_bus *bus,\n\t\t\t\t    struct sdw_group_params *params,\n\t\t\t\t    int *rates, int count)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tint sel_col = bus->params.col;\n\tunsigned int rate, bps, ch;\n\tint i, column_needed = 0;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tparams[i].rate = rates[i];\n\t\tparams[i].full_bw = bus->params.curr_dr_freq / params[i].rate;\n\t}\n\n\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\t\trate = m_rt->stream->params.rate;\n\t\tbps = m_rt->stream->params.bps;\n\t\tch = m_rt->ch_count;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (rate == params[i].rate)\n\t\t\t\tparams[i].payload_bw += bps * ch;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tparams[i].hwidth = (sel_col *\n\t\t\tparams[i].payload_bw + params[i].full_bw - 1) /\n\t\t\tparams[i].full_bw;\n\n\t\tcolumn_needed += params[i].hwidth;\n\t}\n\n\tif (column_needed > sel_col - 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sdw_add_element_group_count(struct sdw_group *group,\n\t\t\t\t       unsigned int rate)\n{\n\tint num = group->count;\n\tint i;\n\n\tfor (i = 0; i <= num; i++) {\n\t\tif (rate == group->rates[i])\n\t\t\tbreak;\n\n\t\tif (i != num)\n\t\t\tcontinue;\n\n\t\tif (group->count >= group->max_size) {\n\t\t\tunsigned int *rates;\n\n\t\t\tgroup->max_size += 1;\n\t\t\trates = krealloc(group->rates,\n\t\t\t\t\t (sizeof(int) * group->max_size),\n\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!rates)\n\t\t\t\treturn -ENOMEM;\n\t\t\tgroup->rates = rates;\n\t\t}\n\n\t\tgroup->rates[group->count++] = rate;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdw_get_group_count(struct sdw_bus *bus,\n\t\t\t       struct sdw_group *group)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tunsigned int rate;\n\tint ret = 0;\n\n\tgroup->count = 0;\n\tgroup->max_size = SDW_STRM_RATE_GROUPING;\n\tgroup->rates = kcalloc(group->max_size, sizeof(int), GFP_KERNEL);\n\tif (!group->rates)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\t\trate = m_rt->stream->params.rate;\n\t\tif (m_rt == list_first_entry(&bus->m_rt_list,\n\t\t\t\t\t     struct sdw_master_runtime,\n\t\t\t\t\t     bus_node)) {\n\t\t\tgroup->rates[group->count++] = rate;\n\n\t\t} else {\n\t\t\tret = sdw_add_element_group_count(group, rate);\n\t\t\tif (ret < 0) {\n\t\t\t\tkfree(group->rates);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sdw_compute_port_params(struct sdw_bus *bus)\n{\n\tstruct sdw_group_params *params = NULL;\n\tstruct sdw_group group;\n\tint ret;\n\n\tret = sdw_get_group_count(bus, &group);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (group.count == 0)\n\t\tgoto out;\n\n\tparams = kcalloc(group.count, sizeof(*params), GFP_KERNEL);\n\tif (!params) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tret = sdw_compute_group_params(bus, params,\n\t\t\t\t       &group.rates[0], group.count);\n\tif (ret < 0)\n\t\tgoto free_params;\n\n\t_sdw_compute_port_params(bus, params, group.count);\n\nfree_params:\n\tkfree(params);\nout:\n\tkfree(group.rates);\n\n\treturn ret;\n}\n\nstatic int sdw_select_row_col(struct sdw_bus *bus, int clk_freq)\n{\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tint frame_int, frame_freq;\n\tint r, c;\n\n\tfor (c = 0; c < SDW_FRAME_COLS; c++) {\n\t\tfor (r = 0; r < SDW_FRAME_ROWS; r++) {\n\t\t\tif (sdw_rows[r] != prop->default_row ||\n\t\t\t    sdw_cols[c] != prop->default_col)\n\t\t\t\tcontinue;\n\n\t\t\tframe_int = sdw_rows[r] * sdw_cols[c];\n\t\t\tframe_freq = clk_freq / frame_int;\n\n\t\t\tif ((clk_freq - (frame_freq * SDW_FRAME_CTRL_BITS)) <\n\t\t\t    bus->params.bandwidth)\n\t\t\t\tcontinue;\n\n\t\t\tbus->params.row = sdw_rows[r];\n\t\t\tbus->params.col = sdw_cols[c];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int sdw_compute_bus_params(struct sdw_bus *bus)\n{\n\tunsigned int max_dr_freq, curr_dr_freq = 0;\n\tstruct sdw_master_prop *mstr_prop = &bus->prop;\n\tint i, clk_values, ret;\n\tbool is_gear = false;\n\tu32 *clk_buf;\n\n\tif (mstr_prop->num_clk_gears) {\n\t\tclk_values = mstr_prop->num_clk_gears;\n\t\tclk_buf = mstr_prop->clk_gears;\n\t\tis_gear = true;\n\t} else if (mstr_prop->num_clk_freq) {\n\t\tclk_values = mstr_prop->num_clk_freq;\n\t\tclk_buf = mstr_prop->clk_freq;\n\t} else {\n\t\tclk_values = 1;\n\t\tclk_buf = NULL;\n\t}\n\n\tmax_dr_freq = mstr_prop->max_clk_freq * SDW_DOUBLE_RATE_FACTOR;\n\n\tfor (i = 0; i < clk_values; i++) {\n\t\tif (!clk_buf)\n\t\t\tcurr_dr_freq = max_dr_freq;\n\t\telse\n\t\t\tcurr_dr_freq = (is_gear) ?\n\t\t\t\t(max_dr_freq >>  clk_buf[i]) :\n\t\t\t\tclk_buf[i] * SDW_DOUBLE_RATE_FACTOR;\n\n\t\tif (curr_dr_freq <= bus->params.bandwidth)\n\t\t\tcontinue;\n\n\t\tbreak;\n\n\t\t \n\t}\n\n\tif (i == clk_values) {\n\t\tdev_err(bus->dev, \"%s: could not find clock value for bandwidth %d\\n\",\n\t\t\t__func__, bus->params.bandwidth);\n\t\treturn -EINVAL;\n\t}\n\n\tret = sdw_select_row_col(bus, curr_dr_freq);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"%s: could not find frame configuration for bus dr_freq %d\\n\",\n\t\t\t__func__, curr_dr_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tbus->params.curr_dr_freq = curr_dr_freq;\n\treturn 0;\n}\n\n \nint sdw_compute_params(struct sdw_bus *bus)\n{\n\tint ret;\n\n\t \n\tret = sdw_compute_bus_params(bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = sdw_compute_port_params(bus);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"Compute transport params failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_compute_params);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"SoundWire Generic Bandwidth Allocation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}