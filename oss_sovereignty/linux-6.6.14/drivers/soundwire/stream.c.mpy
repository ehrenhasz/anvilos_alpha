{
  "module_name": "stream.c",
  "hash_id": "27e460fec19b7dcc64f1b44846bf64e8e320f9bb0afc549ceda2a748bbf9541a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/stream.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <sound/soc.h>\n#include \"bus.h\"\n\n \nint sdw_rows[SDW_FRAME_ROWS] = {48, 50, 60, 64, 75, 80, 125, 147,\n\t\t\t96, 100, 120, 128, 150, 160, 250, 0,\n\t\t\t192, 200, 240, 256, 72, 144, 90, 180};\nEXPORT_SYMBOL(sdw_rows);\n\nint sdw_cols[SDW_FRAME_COLS] = {2, 4, 6, 8, 10, 12, 14, 16};\nEXPORT_SYMBOL(sdw_cols);\n\nint sdw_find_col_index(int col)\n{\n\tint i;\n\n\tfor (i = 0; i < SDW_FRAME_COLS; i++) {\n\t\tif (sdw_cols[i] == col)\n\t\t\treturn i;\n\t}\n\n\tpr_warn(\"Requested column not found, selecting lowest column no: 2\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_find_col_index);\n\nint sdw_find_row_index(int row)\n{\n\tint i;\n\n\tfor (i = 0; i < SDW_FRAME_ROWS; i++) {\n\t\tif (sdw_rows[i] == row)\n\t\t\treturn i;\n\t}\n\n\tpr_warn(\"Requested row not found, selecting lowest row no: 48\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_find_row_index);\n\nstatic int _sdw_program_slave_port_params(struct sdw_bus *bus,\n\t\t\t\t\t  struct sdw_slave *slave,\n\t\t\t\t\t  struct sdw_transport_params *t_params,\n\t\t\t\t\t  enum sdw_dpn_type type)\n{\n\tu32 addr1, addr2, addr3, addr4;\n\tint ret;\n\tu16 wbuf;\n\n\tif (bus->params.next_bank) {\n\t\taddr1 = SDW_DPN_OFFSETCTRL2_B1(t_params->port_num);\n\t\taddr2 = SDW_DPN_BLOCKCTRL3_B1(t_params->port_num);\n\t\taddr3 = SDW_DPN_SAMPLECTRL2_B1(t_params->port_num);\n\t\taddr4 = SDW_DPN_HCTRL_B1(t_params->port_num);\n\t} else {\n\t\taddr1 = SDW_DPN_OFFSETCTRL2_B0(t_params->port_num);\n\t\taddr2 = SDW_DPN_BLOCKCTRL3_B0(t_params->port_num);\n\t\taddr3 = SDW_DPN_SAMPLECTRL2_B0(t_params->port_num);\n\t\taddr4 = SDW_DPN_HCTRL_B0(t_params->port_num);\n\t}\n\n\t \n\tret = sdw_write_no_pm(slave, addr1, t_params->offset2);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"DPN_OffsetCtrl2 register write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sdw_write_no_pm(slave, addr2, t_params->blk_pkg_mode);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"DPN_BlockCtrl3 register write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (type != SDW_DPN_FULL)\n\t\treturn ret;\n\n\t \n\twbuf = FIELD_GET(SDW_DPN_SAMPLECTRL_HIGH, t_params->sample_interval - 1);\n\n\tret = sdw_write_no_pm(slave, addr3, wbuf);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"DPN_SampleCtrl2 register write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twbuf = FIELD_PREP(SDW_DPN_HCTRL_HSTART, t_params->hstart);\n\twbuf |= FIELD_PREP(SDW_DPN_HCTRL_HSTOP, t_params->hstop);\n\n\tret = sdw_write_no_pm(slave, addr4, wbuf);\n\tif (ret < 0)\n\t\tdev_err(bus->dev, \"DPN_HCtrl register write failed\\n\");\n\n\treturn ret;\n}\n\nstatic int sdw_program_slave_port_params(struct sdw_bus *bus,\n\t\t\t\t\t struct sdw_slave_runtime *s_rt,\n\t\t\t\t\t struct sdw_port_runtime *p_rt)\n{\n\tstruct sdw_transport_params *t_params = &p_rt->transport_params;\n\tstruct sdw_port_params *p_params = &p_rt->port_params;\n\tstruct sdw_slave_prop *slave_prop = &s_rt->slave->prop;\n\tu32 addr1, addr2, addr3, addr4, addr5, addr6;\n\tstruct sdw_dpn_prop *dpn_prop;\n\tint ret;\n\tu8 wbuf;\n\n\tif (s_rt->slave->is_mockup_device)\n\t\treturn 0;\n\n\tdpn_prop = sdw_get_slave_dpn_prop(s_rt->slave,\n\t\t\t\t\t  s_rt->direction,\n\t\t\t\t\t  t_params->port_num);\n\tif (!dpn_prop)\n\t\treturn -EINVAL;\n\n\taddr1 = SDW_DPN_PORTCTRL(t_params->port_num);\n\taddr2 = SDW_DPN_BLOCKCTRL1(t_params->port_num);\n\n\tif (bus->params.next_bank) {\n\t\taddr3 = SDW_DPN_SAMPLECTRL1_B1(t_params->port_num);\n\t\taddr4 = SDW_DPN_OFFSETCTRL1_B1(t_params->port_num);\n\t\taddr5 = SDW_DPN_BLOCKCTRL2_B1(t_params->port_num);\n\t\taddr6 = SDW_DPN_LANECTRL_B1(t_params->port_num);\n\n\t} else {\n\t\taddr3 = SDW_DPN_SAMPLECTRL1_B0(t_params->port_num);\n\t\taddr4 = SDW_DPN_OFFSETCTRL1_B0(t_params->port_num);\n\t\taddr5 = SDW_DPN_BLOCKCTRL2_B0(t_params->port_num);\n\t\taddr6 = SDW_DPN_LANECTRL_B0(t_params->port_num);\n\t}\n\n\t \n\twbuf = FIELD_PREP(SDW_DPN_PORTCTRL_DATAMODE, p_params->data_mode);\n\twbuf |= FIELD_PREP(SDW_DPN_PORTCTRL_FLOWMODE, p_params->flow_mode);\n\n\tret = sdw_update_no_pm(s_rt->slave, addr1, 0xF, wbuf);\n\tif (ret < 0) {\n\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\"DPN_PortCtrl register write failed for port %d\\n\",\n\t\t\tt_params->port_num);\n\t\treturn ret;\n\t}\n\n\tif (!dpn_prop->read_only_wordlength) {\n\t\t \n\t\tret = sdw_write_no_pm(s_rt->slave, addr2, (p_params->bps - 1));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"DPN_BlockCtrl1 register write failed for port %d\\n\",\n\t\t\t\tt_params->port_num);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\twbuf = (t_params->sample_interval - 1) & SDW_DPN_SAMPLECTRL_LOW;\n\tret = sdw_write_no_pm(s_rt->slave, addr3, wbuf);\n\tif (ret < 0) {\n\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\"DPN_SampleCtrl1 register write failed for port %d\\n\",\n\t\t\tt_params->port_num);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sdw_write_no_pm(s_rt->slave, addr4, t_params->offset1);\n\tif (ret < 0) {\n\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\"DPN_OffsetCtrl1 register write failed for port %d\\n\",\n\t\t\tt_params->port_num);\n\t\treturn ret;\n\t}\n\n\t \n\tif (t_params->blk_grp_ctrl_valid) {\n\t\tret = sdw_write_no_pm(s_rt->slave, addr5, t_params->blk_grp_ctrl);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"DPN_BlockCtrl2 reg write failed for port %d\\n\",\n\t\t\t\tt_params->port_num);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (slave_prop->lane_control_support) {\n\t\tret = sdw_write_no_pm(s_rt->slave, addr6, t_params->lane_ctrl);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"DPN_LaneCtrl register write failed for port %d\\n\",\n\t\t\t\tt_params->port_num);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dpn_prop->type != SDW_DPN_SIMPLE) {\n\t\tret = _sdw_program_slave_port_params(bus, s_rt->slave,\n\t\t\t\t\t\t     t_params, dpn_prop->type);\n\t\tif (ret < 0)\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"Transport reg write failed for port: %d\\n\",\n\t\t\t\tt_params->port_num);\n\t}\n\n\treturn ret;\n}\n\nstatic int sdw_program_master_port_params(struct sdw_bus *bus,\n\t\t\t\t\t  struct sdw_port_runtime *p_rt)\n{\n\tint ret;\n\n\t \n\tret = bus->port_ops->dpn_set_port_transport_params(bus,\n\t\t\t\t\t&p_rt->transport_params,\n\t\t\t\t\tbus->params.next_bank);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bus->port_ops->dpn_set_port_params(bus,\n\t\t\t\t\t\t  &p_rt->port_params,\n\t\t\t\t\t\t  bus->params.next_bank);\n}\n\n \nstatic int sdw_program_port_params(struct sdw_master_runtime *m_rt)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_bus *bus = m_rt->bus;\n\tstruct sdw_port_runtime *p_rt;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t\tret = sdw_program_slave_port_params(bus, s_rt, p_rt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\t\tret = sdw_program_master_port_params(bus, p_rt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sdw_enable_disable_slave_ports(struct sdw_bus *bus,\n\t\t\t\t\t  struct sdw_slave_runtime *s_rt,\n\t\t\t\t\t  struct sdw_port_runtime *p_rt,\n\t\t\t\t\t  bool en)\n{\n\tstruct sdw_transport_params *t_params = &p_rt->transport_params;\n\tu32 addr;\n\tint ret;\n\n\tif (bus->params.next_bank)\n\t\taddr = SDW_DPN_CHANNELEN_B1(p_rt->num);\n\telse\n\t\taddr = SDW_DPN_CHANNELEN_B0(p_rt->num);\n\n\t \n\tif (en)\n\t\tret = sdw_write_no_pm(s_rt->slave, addr, p_rt->ch_mask);\n\telse\n\t\tret = sdw_write_no_pm(s_rt->slave, addr, 0x0);\n\n\tif (ret < 0)\n\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\"Slave chn_en reg write failed:%d port:%d\\n\",\n\t\t\tret, t_params->port_num);\n\n\treturn ret;\n}\n\nstatic int sdw_enable_disable_master_ports(struct sdw_master_runtime *m_rt,\n\t\t\t\t\t   struct sdw_port_runtime *p_rt,\n\t\t\t\t\t   bool en)\n{\n\tstruct sdw_transport_params *t_params = &p_rt->transport_params;\n\tstruct sdw_bus *bus = m_rt->bus;\n\tstruct sdw_enable_ch enable_ch;\n\tint ret;\n\n\tenable_ch.port_num = p_rt->num;\n\tenable_ch.ch_mask = p_rt->ch_mask;\n\tenable_ch.enable = en;\n\n\t \n\tif (bus->port_ops->dpn_port_enable_ch) {\n\t\tret = bus->port_ops->dpn_port_enable_ch(bus,\n\t\t\t\t\t\t\t&enable_ch,\n\t\t\t\t\t\t\tbus->params.next_bank);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Master chn_en write failed:%d port:%d\\n\",\n\t\t\t\tret, t_params->port_num);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_err(bus->dev,\n\t\t\t\"dpn_port_enable_ch not supported, %s failed\\n\",\n\t\t\ten ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sdw_enable_disable_ports(struct sdw_master_runtime *m_rt, bool en)\n{\n\tstruct sdw_port_runtime *s_port, *m_port;\n\tstruct sdw_slave_runtime *s_rt;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\tlist_for_each_entry(s_port, &s_rt->port_list, port_node) {\n\t\t\tret = sdw_enable_disable_slave_ports(m_rt->bus, s_rt,\n\t\t\t\t\t\t\t     s_port, en);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(m_port, &m_rt->port_list, port_node) {\n\t\tret = sdw_enable_disable_master_ports(m_rt, m_port, en);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdw_do_port_prep(struct sdw_slave_runtime *s_rt,\n\t\t\t    struct sdw_prepare_ch prep_ch,\n\t\t\t    enum sdw_port_prep_ops cmd)\n{\n\tint ret = 0;\n\tstruct sdw_slave *slave = s_rt->slave;\n\n\tmutex_lock(&slave->sdw_dev_lock);\n\n\tif (slave->probed) {\n\t\tstruct device *dev = &slave->dev;\n\t\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\t\tif (drv->ops && drv->ops->port_prep) {\n\t\t\tret = drv->ops->port_prep(slave, &prep_ch, cmd);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(dev, \"Slave Port Prep cmd %d failed: %d\\n\",\n\t\t\t\t\tcmd, ret);\n\t\t}\n\t}\n\n\tmutex_unlock(&slave->sdw_dev_lock);\n\n\treturn ret;\n}\n\nstatic int sdw_prep_deprep_slave_ports(struct sdw_bus *bus,\n\t\t\t\t       struct sdw_slave_runtime *s_rt,\n\t\t\t\t       struct sdw_port_runtime *p_rt,\n\t\t\t\t       bool prep)\n{\n\tstruct completion *port_ready;\n\tstruct sdw_dpn_prop *dpn_prop;\n\tstruct sdw_prepare_ch prep_ch;\n\tbool intr = false;\n\tint ret = 0, val;\n\tu32 addr;\n\n\tprep_ch.num = p_rt->num;\n\tprep_ch.ch_mask = p_rt->ch_mask;\n\n\tdpn_prop = sdw_get_slave_dpn_prop(s_rt->slave,\n\t\t\t\t\t  s_rt->direction,\n\t\t\t\t\t  prep_ch.num);\n\tif (!dpn_prop) {\n\t\tdev_err(bus->dev,\n\t\t\t\"Slave Port:%d properties not found\\n\", prep_ch.num);\n\t\treturn -EINVAL;\n\t}\n\n\tprep_ch.prepare = prep;\n\n\tprep_ch.bank = bus->params.next_bank;\n\n\tif (dpn_prop->imp_def_interrupts || !dpn_prop->simple_ch_prep_sm ||\n\t    bus->params.s_data_mode != SDW_PORT_DATA_MODE_NORMAL)\n\t\tintr = true;\n\n\t \n\tif (prep && intr) {\n\t\tret = sdw_configure_dpn_intr(s_rt->slave, p_rt->num, prep,\n\t\t\t\t\t     dpn_prop->imp_def_interrupts);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsdw_do_port_prep(s_rt, prep_ch, prep ? SDW_OPS_PORT_PRE_PREP : SDW_OPS_PORT_PRE_DEPREP);\n\n\t \n\tif (!dpn_prop->simple_ch_prep_sm) {\n\t\taddr = SDW_DPN_PREPARECTRL(p_rt->num);\n\n\t\tif (prep)\n\t\t\tret = sdw_write_no_pm(s_rt->slave, addr, p_rt->ch_mask);\n\t\telse\n\t\t\tret = sdw_write_no_pm(s_rt->slave, addr, 0x0);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"Slave prep_ctrl reg write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tport_ready = &s_rt->slave->port_ready[prep_ch.num];\n\t\twait_for_completion_timeout(port_ready,\n\t\t\tmsecs_to_jiffies(dpn_prop->ch_prep_timeout));\n\n\t\tval = sdw_read_no_pm(s_rt->slave, SDW_DPN_PREPARESTATUS(p_rt->num));\n\t\tif ((val < 0) || (val & p_rt->ch_mask)) {\n\t\t\tret = (val < 0) ? val : -ETIMEDOUT;\n\t\t\tdev_err(&s_rt->slave->dev,\n\t\t\t\t\"Chn prep failed for port %d: %d\\n\", prep_ch.num, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tsdw_do_port_prep(s_rt, prep_ch, prep ? SDW_OPS_PORT_POST_PREP : SDW_OPS_PORT_POST_DEPREP);\n\n\t \n\tif (!prep && intr)\n\t\tret = sdw_configure_dpn_intr(s_rt->slave, p_rt->num, prep,\n\t\t\t\t\t     dpn_prop->imp_def_interrupts);\n\n\treturn ret;\n}\n\nstatic int sdw_prep_deprep_master_ports(struct sdw_master_runtime *m_rt,\n\t\t\t\t\tstruct sdw_port_runtime *p_rt,\n\t\t\t\t\tbool prep)\n{\n\tstruct sdw_transport_params *t_params = &p_rt->transport_params;\n\tstruct sdw_bus *bus = m_rt->bus;\n\tconst struct sdw_master_port_ops *ops = bus->port_ops;\n\tstruct sdw_prepare_ch prep_ch;\n\tint ret = 0;\n\n\tprep_ch.num = p_rt->num;\n\tprep_ch.ch_mask = p_rt->ch_mask;\n\tprep_ch.prepare = prep;  \n\tprep_ch.bank = bus->params.next_bank;\n\n\t \n\tif (ops->dpn_port_prep) {\n\t\tret = ops->dpn_port_prep(bus, &prep_ch);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Port prepare failed for port:%d\\n\",\n\t\t\t\tt_params->port_num);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sdw_prep_deprep_ports(struct sdw_master_runtime *m_rt, bool prep)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_port_runtime *p_rt;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t\tret = sdw_prep_deprep_slave_ports(m_rt->bus, s_rt,\n\t\t\t\t\t\t\t  p_rt, prep);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\t\tret = sdw_prep_deprep_master_ports(m_rt, p_rt, prep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sdw_notify_config(struct sdw_master_runtime *m_rt)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_bus *bus = m_rt->bus;\n\tstruct sdw_slave *slave;\n\tint ret;\n\n\tif (bus->ops->set_bus_conf) {\n\t\tret = bus->ops->set_bus_conf(bus, &bus->params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\tslave = s_rt->slave;\n\n\t\tmutex_lock(&slave->sdw_dev_lock);\n\n\t\tif (slave->probed) {\n\t\t\tstruct device *dev = &slave->dev;\n\t\t\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\t\t\tif (drv->ops && drv->ops->bus_config) {\n\t\t\t\tret = drv->ops->bus_config(slave, &bus->params);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dev, \"Notify Slave: %d failed\\n\",\n\t\t\t\t\t\tslave->dev_num);\n\t\t\t\t\tmutex_unlock(&slave->sdw_dev_lock);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&slave->sdw_dev_lock);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sdw_program_params(struct sdw_bus *bus, bool prepare)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tint ret = 0;\n\n\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\n\t\t \n\t\tif (!prepare &&\n\t\t    m_rt->stream->state == SDW_STREAM_CONFIGURED)\n\t\t\tcontinue;\n\n\t\tret = sdw_program_port_params(m_rt);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Program transport params failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_notify_config(m_rt);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Notify bus config failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (m_rt->stream->state != SDW_STREAM_ENABLED)\n\t\t\tcontinue;\n\n\t\tret = sdw_enable_disable_ports(m_rt, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Enable channel failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sdw_bank_switch(struct sdw_bus *bus, int m_rt_count)\n{\n\tint col_index, row_index;\n\tbool multi_link;\n\tstruct sdw_msg *wr_msg;\n\tu8 *wbuf;\n\tint ret;\n\tu16 addr;\n\n\twr_msg = kzalloc(sizeof(*wr_msg), GFP_KERNEL);\n\tif (!wr_msg)\n\t\treturn -ENOMEM;\n\n\twbuf = kzalloc(sizeof(*wbuf), GFP_KERNEL);\n\tif (!wbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_1;\n\t}\n\n\t \n\tcol_index = sdw_find_col_index(bus->params.col);\n\trow_index = sdw_find_row_index(bus->params.row);\n\twbuf[0] = col_index | (row_index << 3);\n\n\tif (bus->params.next_bank)\n\t\taddr = SDW_SCP_FRAMECTRL_B1;\n\telse\n\t\taddr = SDW_SCP_FRAMECTRL_B0;\n\n\tsdw_fill_msg(wr_msg, NULL, addr, 1, SDW_BROADCAST_DEV_NUM,\n\t\t     SDW_MSG_FLAG_WRITE, wbuf);\n\twr_msg->ssp_sync = true;\n\n\t \n\tmulti_link = bus->multi_link && (m_rt_count >= bus->hw_sync_min_links);\n\n\tif (multi_link)\n\t\tret = sdw_transfer_defer(bus, wr_msg);\n\telse\n\t\tret = sdw_transfer(bus, wr_msg);\n\n\tif (ret < 0 && ret != -ENODATA) {\n\t\tdev_err(bus->dev, \"Slave frame_ctrl reg write failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!multi_link) {\n\t\tkfree(wbuf);\n\t\tkfree(wr_msg);\n\t\tbus->defer_msg.msg = NULL;\n\t\tbus->params.curr_bank = !bus->params.curr_bank;\n\t\tbus->params.next_bank = !bus->params.next_bank;\n\t}\n\n\treturn 0;\n\nerror:\n\tkfree(wbuf);\nerror_1:\n\tkfree(wr_msg);\n\tbus->defer_msg.msg = NULL;\n\treturn ret;\n}\n\n \nstatic int sdw_ml_sync_bank_switch(struct sdw_bus *bus, bool multi_link)\n{\n\tunsigned long time_left;\n\n\tif (!multi_link)\n\t\treturn 0;\n\n\t \n\ttime_left = wait_for_completion_timeout(&bus->defer_msg.complete,\n\t\t\t\t\t\tbus->bank_switch_timeout);\n\n\tif (!time_left) {\n\t\tdev_err(bus->dev, \"Controller Timed out on bank switch\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tbus->params.curr_bank = !bus->params.curr_bank;\n\tbus->params.next_bank = !bus->params.next_bank;\n\n\tif (bus->defer_msg.msg) {\n\t\tkfree(bus->defer_msg.msg->buf);\n\t\tkfree(bus->defer_msg.msg);\n\t\tbus->defer_msg.msg = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_bank_switch(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tconst struct sdw_master_ops *ops;\n\tstruct sdw_bus *bus;\n\tbool multi_link = false;\n\tint m_rt_count;\n\tint ret = 0;\n\n\tm_rt_count = stream->m_rt_count;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\tops = bus->ops;\n\n\t\tif (bus->multi_link && m_rt_count >= bus->hw_sync_min_links) {\n\t\t\tmulti_link = true;\n\t\t\tmutex_lock(&bus->msg_lock);\n\t\t}\n\n\t\t \n\t\tif (ops->pre_bank_switch) {\n\t\t\tret = ops->pre_bank_switch(bus);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bus->dev,\n\t\t\t\t\t\"Pre bank switch op failed: %d\\n\", ret);\n\t\t\t\tgoto msg_unlock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = sdw_bank_switch(bus, m_rt_count);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Bank switch failed: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\tops = bus->ops;\n\n\t\t \n\t\tif (ops->post_bank_switch) {\n\t\t\tret = ops->post_bank_switch(bus);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bus->dev,\n\t\t\t\t\t\"Post bank switch op failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else if (multi_link) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Post bank switch ops not implemented\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (!bus->bank_switch_timeout)\n\t\t\tbus->bank_switch_timeout = DEFAULT_BANK_SWITCH_TIMEOUT;\n\n\t\t \n\t\tret = sdw_ml_sync_bank_switch(bus, multi_link);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"multi link bank switch failed: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (multi_link)\n\t\t\tmutex_unlock(&bus->msg_lock);\n\t}\n\n\treturn ret;\n\nerror:\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\tif (bus->defer_msg.msg) {\n\t\t\tkfree(bus->defer_msg.msg->buf);\n\t\t\tkfree(bus->defer_msg.msg);\n\t\t\tbus->defer_msg.msg = NULL;\n\t\t}\n\t}\n\nmsg_unlock:\n\n\tif (multi_link) {\n\t\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\t\tbus = m_rt->bus;\n\t\t\tif (mutex_is_locked(&bus->msg_lock))\n\t\t\t\tmutex_unlock(&bus->msg_lock);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct sdw_port_runtime *sdw_port_alloc(struct list_head *port_list)\n{\n\tstruct sdw_port_runtime *p_rt;\n\n\tp_rt = kzalloc(sizeof(*p_rt), GFP_KERNEL);\n\tif (!p_rt)\n\t\treturn NULL;\n\n\tlist_add_tail(&p_rt->port_node, port_list);\n\n\treturn p_rt;\n}\n\nstatic int sdw_port_config(struct sdw_port_runtime *p_rt,\n\t\t\t   struct sdw_port_config *port_config,\n\t\t\t   int port_index)\n{\n\tp_rt->ch_mask = port_config[port_index].ch_mask;\n\tp_rt->num = port_config[port_index].num;\n\n\t \n\n\treturn 0;\n}\n\nstatic void sdw_port_free(struct sdw_port_runtime *p_rt)\n{\n\tlist_del(&p_rt->port_node);\n\tkfree(p_rt);\n}\n\nstatic bool sdw_slave_port_allocated(struct sdw_slave_runtime *s_rt)\n{\n\treturn !list_empty(&s_rt->port_list);\n}\n\nstatic void sdw_slave_port_free(struct sdw_slave *slave,\n\t\t\t\tstruct sdw_stream_runtime *stream)\n{\n\tstruct sdw_port_runtime *p_rt, *_p_rt;\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_slave_runtime *s_rt;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\t\tif (s_rt->slave != slave)\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry_safe(p_rt, _p_rt,\n\t\t\t\t\t\t &s_rt->port_list, port_node) {\n\t\t\t\tsdw_port_free(p_rt);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int sdw_slave_port_alloc(struct sdw_slave *slave,\n\t\t\t\tstruct sdw_slave_runtime *s_rt,\n\t\t\t\tunsigned int num_config)\n{\n\tstruct sdw_port_runtime *p_rt;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_config; i++) {\n\t\tp_rt = sdw_port_alloc(&s_rt->port_list);\n\t\tif (!p_rt)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdw_slave_port_is_valid_range(struct device *dev, int num)\n{\n\tif (!SDW_VALID_PORT_RANGE(num)) {\n\t\tdev_err(dev, \"SoundWire: Invalid port number :%d\\n\", num);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdw_slave_port_config(struct sdw_slave *slave,\n\t\t\t\t struct sdw_slave_runtime *s_rt,\n\t\t\t\t struct sdw_port_config *port_config)\n{\n\tstruct sdw_port_runtime *p_rt;\n\tint ret;\n\tint i;\n\n\ti = 0;\n\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t \n\t\tret = sdw_slave_port_is_valid_range(&slave->dev, port_config[i].num);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = sdw_port_config(p_rt, port_config, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic bool sdw_master_port_allocated(struct sdw_master_runtime *m_rt)\n{\n\treturn !list_empty(&m_rt->port_list);\n}\n\nstatic void sdw_master_port_free(struct sdw_master_runtime *m_rt)\n{\n\tstruct sdw_port_runtime *p_rt, *_p_rt;\n\n\tlist_for_each_entry_safe(p_rt, _p_rt, &m_rt->port_list, port_node) {\n\t\tsdw_port_free(p_rt);\n\t}\n}\n\nstatic int sdw_master_port_alloc(struct sdw_master_runtime *m_rt,\n\t\t\t\t unsigned int num_ports)\n{\n\tstruct sdw_port_runtime *p_rt;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_ports; i++) {\n\t\tp_rt = sdw_port_alloc(&m_rt->port_list);\n\t\tif (!p_rt)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdw_master_port_config(struct sdw_master_runtime *m_rt,\n\t\t\t\t  struct sdw_port_config *port_config)\n{\n\tstruct sdw_port_runtime *p_rt;\n\tint ret;\n\tint i;\n\n\ti = 0;\n\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\t\tret = sdw_port_config(p_rt, port_config, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct sdw_slave_runtime\n*sdw_slave_rt_alloc(struct sdw_slave *slave,\n\t\t    struct sdw_master_runtime *m_rt)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\n\ts_rt = kzalloc(sizeof(*s_rt), GFP_KERNEL);\n\tif (!s_rt)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s_rt->port_list);\n\ts_rt->slave = slave;\n\n\tlist_add_tail(&s_rt->m_rt_node, &m_rt->slave_rt_list);\n\n\treturn s_rt;\n}\n\n \nstatic int sdw_slave_rt_config(struct sdw_slave_runtime *s_rt,\n\t\t\t       struct sdw_stream_config *stream_config)\n{\n\ts_rt->ch_count = stream_config->ch_count;\n\ts_rt->direction = stream_config->direction;\n\n\treturn 0;\n}\n\nstatic struct sdw_slave_runtime *sdw_slave_rt_find(struct sdw_slave *slave,\n\t\t\t\t\t\t   struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_slave_runtime *s_rt, *_s_rt;\n\tstruct sdw_master_runtime *m_rt;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\t \n\t\tlist_for_each_entry_safe(s_rt, _s_rt,\n\t\t\t\t\t &m_rt->slave_rt_list, m_rt_node) {\n\t\t\tif (s_rt->slave == slave)\n\t\t\t\treturn s_rt;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void sdw_slave_rt_free(struct sdw_slave *slave,\n\t\t\t      struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\n\ts_rt = sdw_slave_rt_find(slave, stream);\n\tif (s_rt) {\n\t\tlist_del(&s_rt->m_rt_node);\n\t\tkfree(s_rt);\n\t}\n}\n\nstatic struct sdw_master_runtime\n*sdw_master_rt_find(struct sdw_bus *bus,\n\t\t    struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tif (m_rt->bus == bus)\n\t\t\treturn m_rt;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct sdw_master_runtime\n*sdw_master_rt_alloc(struct sdw_bus *bus,\n\t\t     struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt, *walk_m_rt;\n\tstruct list_head *insert_after;\n\n\tm_rt = kzalloc(sizeof(*m_rt), GFP_KERNEL);\n\tif (!m_rt)\n\t\treturn NULL;\n\n\t \n\tINIT_LIST_HEAD(&m_rt->port_list);\n\tINIT_LIST_HEAD(&m_rt->slave_rt_list);\n\n\t \n\tinsert_after = &stream->master_list;\n\tlist_for_each_entry_reverse(walk_m_rt, &stream->master_list, stream_node) {\n\t\tif (walk_m_rt->bus->id < bus->id) {\n\t\t\tinsert_after = &walk_m_rt->stream_node;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlist_add(&m_rt->stream_node, insert_after);\n\n\tlist_add_tail(&m_rt->bus_node, &bus->m_rt_list);\n\n\tm_rt->bus = bus;\n\tm_rt->stream = stream;\n\n\treturn m_rt;\n}\n\n \n\nstatic int sdw_master_rt_config(struct sdw_master_runtime *m_rt,\n\t\t\t\tstruct sdw_stream_config *stream_config)\n{\n\tm_rt->ch_count = stream_config->ch_count;\n\tm_rt->direction = stream_config->direction;\n\n\treturn 0;\n}\n\n \nstatic void sdw_master_rt_free(struct sdw_master_runtime *m_rt,\n\t\t\t       struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_slave_runtime *s_rt, *_s_rt;\n\n\tlist_for_each_entry_safe(s_rt, _s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\tsdw_slave_port_free(s_rt->slave, stream);\n\t\tsdw_slave_rt_free(s_rt->slave, stream);\n\t}\n\n\tlist_del(&m_rt->stream_node);\n\tlist_del(&m_rt->bus_node);\n\tkfree(m_rt);\n}\n\n \nstatic int sdw_config_stream(struct device *dev,\n\t\t\t     struct sdw_stream_runtime *stream,\n\t\t\t     struct sdw_stream_config *stream_config,\n\t\t\t     bool is_slave)\n{\n\t \n\tif (stream->params.rate &&\n\t    stream->params.rate != stream_config->frame_rate) {\n\t\tdev_err(dev, \"rate not matching, stream:%s\\n\", stream->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (stream->params.bps &&\n\t    stream->params.bps != stream_config->bps) {\n\t\tdev_err(dev, \"bps not matching, stream:%s\\n\", stream->name);\n\t\treturn -EINVAL;\n\t}\n\n\tstream->type = stream_config->type;\n\tstream->params.rate = stream_config->frame_rate;\n\tstream->params.bps = stream_config->bps;\n\n\t \n\tif (is_slave)\n\t\tstream->params.ch_count += stream_config->ch_count;\n\n\treturn 0;\n}\n\n \nstruct sdw_dpn_prop *sdw_get_slave_dpn_prop(struct sdw_slave *slave,\n\t\t\t\t\t    enum sdw_data_direction direction,\n\t\t\t\t\t    unsigned int port_num)\n{\n\tstruct sdw_dpn_prop *dpn_prop;\n\tu8 num_ports;\n\tint i;\n\n\tif (direction == SDW_DATA_DIR_TX) {\n\t\tnum_ports = hweight32(slave->prop.source_ports);\n\t\tdpn_prop = slave->prop.src_dpn_prop;\n\t} else {\n\t\tnum_ports = hweight32(slave->prop.sink_ports);\n\t\tdpn_prop = slave->prop.sink_dpn_prop;\n\t}\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tif (dpn_prop[i].num == port_num)\n\t\t\treturn &dpn_prop[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void sdw_acquire_bus_lock(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_bus *bus;\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\n\t\tmutex_lock(&bus->bus_lock);\n\t}\n}\n\n \nstatic void sdw_release_bus_lock(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_bus *bus;\n\n\t \n\tlist_for_each_entry_reverse(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\tmutex_unlock(&bus->bus_lock);\n\t}\n}\n\nstatic int _sdw_prepare_stream(struct sdw_stream_runtime *stream,\n\t\t\t       bool update_params)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_bus *bus;\n\tstruct sdw_master_prop *prop;\n\tstruct sdw_bus_params params;\n\tint ret;\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\tprop = &bus->prop;\n\t\tmemcpy(&params, &bus->params, sizeof(params));\n\n\t\t \n\t\tif ((prop->max_clk_freq % stream->params.rate) != 0) {\n\t\t\tdev_err(bus->dev, \"Async mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (update_params) {\n\t\t\t \n\t\t\t \n\t\t\tbus->params.bandwidth += m_rt->stream->params.rate *\n\t\t\t\tm_rt->ch_count * m_rt->stream->params.bps;\n\n\t\t\t \n\t\t\tif (bus->compute_params) {\n\t\t\t\tret = bus->compute_params(bus);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(bus->dev, \"Compute params failed: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\tgoto restore_params;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = sdw_program_params(bus, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Program params failed: %d\\n\", ret);\n\t\t\tgoto restore_params;\n\t\t}\n\t}\n\n\tret = do_bank_switch(stream);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: do_bank_switch failed: %d\\n\", __func__, ret);\n\t\tgoto restore_params;\n\t}\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\n\t\t \n\t\tret = sdw_prep_deprep_ports(m_rt, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Prepare port(s) failed ret = %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstream->state = SDW_STREAM_PREPARED;\n\n\treturn ret;\n\nrestore_params:\n\tmemcpy(&bus->params, &params, sizeof(params));\n\treturn ret;\n}\n\n \nint sdw_prepare_stream(struct sdw_stream_runtime *stream)\n{\n\tbool update_params = true;\n\tint ret;\n\n\tif (!stream) {\n\t\tpr_err(\"SoundWire: Handle not found for stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdw_acquire_bus_lock(stream);\n\n\tif (stream->state == SDW_STREAM_PREPARED) {\n\t\tret = 0;\n\t\tgoto state_err;\n\t}\n\n\tif (stream->state != SDW_STREAM_CONFIGURED &&\n\t    stream->state != SDW_STREAM_DEPREPARED &&\n\t    stream->state != SDW_STREAM_DISABLED) {\n\t\tpr_err(\"%s: %s: inconsistent state state %d\\n\",\n\t\t       __func__, stream->name, stream->state);\n\t\tret = -EINVAL;\n\t\tgoto state_err;\n\t}\n\n\t \n\tif (stream->state == SDW_STREAM_DISABLED)\n\t\tupdate_params = false;\n\n\tret = _sdw_prepare_stream(stream, update_params);\n\nstate_err:\n\tsdw_release_bus_lock(stream);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_prepare_stream);\n\nstatic int _sdw_enable_stream(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_bus *bus;\n\tint ret;\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\n\t\t \n\t\tret = sdw_program_params(bus, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"%s: Program params failed: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = sdw_enable_disable_ports(m_rt, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Enable port(s) failed ret: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = do_bank_switch(stream);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: do_bank_switch failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tstream->state = SDW_STREAM_ENABLED;\n\treturn 0;\n}\n\n \nint sdw_enable_stream(struct sdw_stream_runtime *stream)\n{\n\tint ret;\n\n\tif (!stream) {\n\t\tpr_err(\"SoundWire: Handle not found for stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdw_acquire_bus_lock(stream);\n\n\tif (stream->state == SDW_STREAM_ENABLED) {\n\t\tret = 0;\n\t\tgoto state_err;\n\t}\n\n\tif (stream->state != SDW_STREAM_PREPARED &&\n\t    stream->state != SDW_STREAM_DISABLED) {\n\t\tpr_err(\"%s: %s: inconsistent state state %d\\n\",\n\t\t       __func__, stream->name, stream->state);\n\t\tret = -EINVAL;\n\t\tgoto state_err;\n\t}\n\n\tret = _sdw_enable_stream(stream);\n\nstate_err:\n\tsdw_release_bus_lock(stream);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_enable_stream);\n\nstatic int _sdw_disable_stream(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tint ret;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tstruct sdw_bus *bus = m_rt->bus;\n\n\t\t \n\t\tret = sdw_enable_disable_ports(m_rt, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Disable port(s) failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tstream->state = SDW_STREAM_DISABLED;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tstruct sdw_bus *bus = m_rt->bus;\n\n\t\t \n\t\tret = sdw_program_params(bus, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"%s: Program params failed: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = do_bank_switch(stream);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: do_bank_switch failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tstruct sdw_bus *bus = m_rt->bus;\n\n\t\t \n\t\tret = sdw_enable_disable_ports(m_rt, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"Disable port(s) failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint sdw_disable_stream(struct sdw_stream_runtime *stream)\n{\n\tint ret;\n\n\tif (!stream) {\n\t\tpr_err(\"SoundWire: Handle not found for stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdw_acquire_bus_lock(stream);\n\n\tif (stream->state == SDW_STREAM_DISABLED) {\n\t\tret = 0;\n\t\tgoto state_err;\n\t}\n\n\tif (stream->state != SDW_STREAM_ENABLED) {\n\t\tpr_err(\"%s: %s: inconsistent state state %d\\n\",\n\t\t       __func__, stream->name, stream->state);\n\t\tret = -EINVAL;\n\t\tgoto state_err;\n\t}\n\n\tret = _sdw_disable_stream(stream);\n\nstate_err:\n\tsdw_release_bus_lock(stream);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_disable_stream);\n\nstatic int _sdw_deprepare_stream(struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_bus *bus;\n\tint ret = 0;\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tbus = m_rt->bus;\n\t\t \n\t\tret = sdw_prep_deprep_ports(m_rt, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"De-prepare port(s) failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tbus->params.bandwidth -= m_rt->stream->params.rate *\n\t\t\tm_rt->ch_count * m_rt->stream->params.bps;\n\n\t\t \n\t\tif (bus->compute_params) {\n\t\t\tret = bus->compute_params(bus);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bus->dev, \"Compute params failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = sdw_program_params(bus, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"%s: Program params failed: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstream->state = SDW_STREAM_DEPREPARED;\n\treturn do_bank_switch(stream);\n}\n\n \nint sdw_deprepare_stream(struct sdw_stream_runtime *stream)\n{\n\tint ret;\n\n\tif (!stream) {\n\t\tpr_err(\"SoundWire: Handle not found for stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdw_acquire_bus_lock(stream);\n\n\tif (stream->state == SDW_STREAM_DEPREPARED) {\n\t\tret = 0;\n\t\tgoto state_err;\n\t}\n\n\tif (stream->state != SDW_STREAM_PREPARED &&\n\t    stream->state != SDW_STREAM_DISABLED) {\n\t\tpr_err(\"%s: %s: inconsistent state state %d\\n\",\n\t\t       __func__, stream->name, stream->state);\n\t\tret = -EINVAL;\n\t\tgoto state_err;\n\t}\n\n\tret = _sdw_deprepare_stream(stream);\n\nstate_err:\n\tsdw_release_bus_lock(stream);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_deprepare_stream);\n\nstatic int set_stream(struct snd_pcm_substream *substream,\n\t\t      struct sdw_stream_runtime *sdw_stream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *dai;\n\tint ret = 0;\n\tint i;\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tret = snd_soc_dai_set_stream(dai, sdw_stream, substream->stream);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->dev, \"failed to set stream pointer on dai %s\\n\", dai->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstruct sdw_stream_runtime *sdw_alloc_stream(const char *stream_name)\n{\n\tstruct sdw_stream_runtime *stream;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn NULL;\n\n\tstream->name = stream_name;\n\tINIT_LIST_HEAD(&stream->master_list);\n\tstream->state = SDW_STREAM_ALLOCATED;\n\tstream->m_rt_count = 0;\n\n\treturn stream;\n}\nEXPORT_SYMBOL(sdw_alloc_stream);\n\n \nint sdw_startup_stream(void *sdw_substream)\n{\n\tstruct snd_pcm_substream *substream = sdw_substream;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tchar *name;\n\tint ret;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tname = kasprintf(GFP_KERNEL, \"%s-Playback\", substream->name);\n\telse\n\t\tname = kasprintf(GFP_KERNEL, \"%s-Capture\", substream->name);\n\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tsdw_stream = sdw_alloc_stream(name);\n\tif (!sdw_stream) {\n\t\tdev_err(rtd->dev, \"alloc stream failed for substream DAI %s\\n\", substream->name);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = set_stream(substream, sdw_stream);\n\tif (ret < 0)\n\t\tgoto release_stream;\n\treturn 0;\n\nrelease_stream:\n\tsdw_release_stream(sdw_stream);\n\tset_stream(substream, NULL);\nerror:\n\tkfree(name);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_startup_stream);\n\n \nvoid sdw_shutdown_stream(void *sdw_substream)\n{\n\tstruct snd_pcm_substream *substream = sdw_substream;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tstruct snd_soc_dai *dai;\n\n\t \n\tdai = asoc_rtd_to_cpu(rtd, 0);\n\n\tsdw_stream = snd_soc_dai_get_stream(dai, substream->stream);\n\n\tif (IS_ERR(sdw_stream)) {\n\t\tdev_err(rtd->dev, \"no stream found for DAI %s\\n\", dai->name);\n\t\treturn;\n\t}\n\n\t \n\tkfree(sdw_stream->name);\n\tsdw_release_stream(sdw_stream);\n\n\t \n\tset_stream(substream, NULL);\n}\nEXPORT_SYMBOL(sdw_shutdown_stream);\n\n \nvoid sdw_release_stream(struct sdw_stream_runtime *stream)\n{\n\tkfree(stream);\n}\nEXPORT_SYMBOL(sdw_release_stream);\n\n \nint sdw_stream_add_master(struct sdw_bus *bus,\n\t\t\t  struct sdw_stream_config *stream_config,\n\t\t\t  struct sdw_port_config *port_config,\n\t\t\t  unsigned int num_ports,\n\t\t\t  struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tbool alloc_master_rt = false;\n\tint ret;\n\n\tmutex_lock(&bus->bus_lock);\n\n\t \n\tif (!bus->multi_link && stream->m_rt_count > 0) {\n\t\tdev_err(bus->dev,\n\t\t\t\"Multilink not supported, link %d\\n\", bus->link_id);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tm_rt = sdw_master_rt_find(bus, stream);\n\tif (!m_rt) {\n\t\tm_rt = sdw_master_rt_alloc(bus, stream);\n\t\tif (!m_rt) {\n\t\t\tdev_err(bus->dev, \"%s: Master runtime alloc failed for stream:%s\\n\",\n\t\t\t\t__func__, stream->name);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\talloc_master_rt = true;\n\t}\n\n\tif (!sdw_master_port_allocated(m_rt)) {\n\t\tret = sdw_master_port_alloc(m_rt, num_ports);\n\t\tif (ret)\n\t\t\tgoto alloc_error;\n\n\t\tstream->m_rt_count++;\n\t}\n\n\tret = sdw_master_rt_config(m_rt, stream_config);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = sdw_config_stream(bus->dev, stream, stream_config, false);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = sdw_master_port_config(m_rt, port_config);\n\n\tgoto unlock;\n\nalloc_error:\n\t \n\tif (alloc_master_rt)\n\t\tsdw_master_rt_free(m_rt, stream);\nunlock:\n\tmutex_unlock(&bus->bus_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_stream_add_master);\n\n \nint sdw_stream_remove_master(struct sdw_bus *bus,\n\t\t\t     struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt, *_m_rt;\n\n\tmutex_lock(&bus->bus_lock);\n\n\tlist_for_each_entry_safe(m_rt, _m_rt,\n\t\t\t\t &stream->master_list, stream_node) {\n\t\tif (m_rt->bus != bus)\n\t\t\tcontinue;\n\n\t\tsdw_master_port_free(m_rt);\n\t\tsdw_master_rt_free(m_rt, stream);\n\t\tstream->m_rt_count--;\n\t}\n\n\tif (list_empty(&stream->master_list))\n\t\tstream->state = SDW_STREAM_RELEASED;\n\n\tmutex_unlock(&bus->bus_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_stream_remove_master);\n\n \nint sdw_stream_add_slave(struct sdw_slave *slave,\n\t\t\t struct sdw_stream_config *stream_config,\n\t\t\t struct sdw_port_config *port_config,\n\t\t\t unsigned int num_ports,\n\t\t\t struct sdw_stream_runtime *stream)\n{\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_master_runtime *m_rt;\n\tbool alloc_master_rt = false;\n\tbool alloc_slave_rt = false;\n\n\tint ret;\n\n\tmutex_lock(&slave->bus->bus_lock);\n\n\t \n\tm_rt = sdw_master_rt_find(slave->bus, stream);\n\tif (!m_rt) {\n\t\t \n\t\tm_rt = sdw_master_rt_alloc(slave->bus, stream);\n\t\tif (!m_rt) {\n\t\t\tdev_err(&slave->dev, \"%s: Master runtime alloc failed for stream:%s\\n\",\n\t\t\t\t__func__, stream->name);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\talloc_master_rt = true;\n\t}\n\n\ts_rt = sdw_slave_rt_find(slave, stream);\n\tif (!s_rt) {\n\t\ts_rt = sdw_slave_rt_alloc(slave, m_rt);\n\t\tif (!s_rt) {\n\t\t\tdev_err(&slave->dev, \"Slave runtime alloc failed for stream:%s\\n\",\n\t\t\t\tstream->name);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto alloc_error;\n\t\t}\n\n\t\talloc_slave_rt = true;\n\t}\n\n\tif (!sdw_slave_port_allocated(s_rt)) {\n\t\tret = sdw_slave_port_alloc(slave, s_rt, num_ports);\n\t\tif (ret)\n\t\t\tgoto alloc_error;\n\t}\n\n\tret =  sdw_master_rt_config(m_rt, stream_config);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = sdw_slave_rt_config(s_rt, stream_config);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = sdw_config_stream(&slave->dev, stream, stream_config, true);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = sdw_slave_port_config(slave, s_rt, port_config);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tstream->state = SDW_STREAM_CONFIGURED;\n\tgoto unlock;\n\nalloc_error:\n\t \n\tif (alloc_master_rt)\n\t\tsdw_master_rt_free(m_rt, stream);\n\telse if (alloc_slave_rt)\n\t\tsdw_slave_rt_free(slave, stream);\nunlock:\n\tmutex_unlock(&slave->bus->bus_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_stream_add_slave);\n\n \nint sdw_stream_remove_slave(struct sdw_slave *slave,\n\t\t\t    struct sdw_stream_runtime *stream)\n{\n\tmutex_lock(&slave->bus->bus_lock);\n\n\tsdw_slave_port_free(slave, stream);\n\tsdw_slave_rt_free(slave, stream);\n\n\tmutex_unlock(&slave->bus->bus_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_stream_remove_slave);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}