{
  "module_name": "intel_ace2x.c",
  "hash_id": "12aef4f5b713953b8067586372ca3990ec862e9f8f4c689aefb2b2d34ff3c939",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/intel_ace2x.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_intel.h>\n#include <sound/pcm_params.h>\n#include <sound/hda-mlink.h>\n#include \"cadence_master.h\"\n#include \"bus.h\"\n#include \"intel.h\"\n\n \n\nstatic void intel_shim_vs_init(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim_vs = sdw->link_res->shim_vs;\n\tu16 act;\n\n\tact = intel_readw(shim_vs, SDW_SHIM2_INTEL_VS_ACTMCTL);\n\tu16p_replace_bits(&act, 0x1, SDW_SHIM2_INTEL_VS_ACTMCTL_DOAIS);\n\tact |= SDW_SHIM2_INTEL_VS_ACTMCTL_DACTQE;\n\tact |=  SDW_SHIM2_INTEL_VS_ACTMCTL_DODS;\n\tintel_writew(shim_vs, SDW_SHIM2_INTEL_VS_ACTMCTL, act);\n\tusleep_range(10, 15);\n}\n\nstatic int intel_shim_check_wake(struct sdw_intel *sdw)\n{\n\tvoid __iomem *shim_vs;\n\tu16 wake_sts;\n\n\tshim_vs = sdw->link_res->shim_vs;\n\twake_sts = intel_readw(shim_vs, SDW_SHIM2_INTEL_VS_WAKESTS);\n\n\treturn wake_sts & SDW_SHIM2_INTEL_VS_WAKEEN_PWS;\n}\n\nstatic void intel_shim_wake(struct sdw_intel *sdw, bool wake_enable)\n{\n\tvoid __iomem *shim_vs = sdw->link_res->shim_vs;\n\tu16 wake_en;\n\tu16 wake_sts;\n\n\twake_en = intel_readw(shim_vs, SDW_SHIM2_INTEL_VS_WAKEEN);\n\n\tif (wake_enable) {\n\t\t \n\t\twake_en |= SDW_SHIM2_INTEL_VS_WAKEEN_PWE;\n\t\tintel_writew(shim_vs, SDW_SHIM2_INTEL_VS_WAKEEN, wake_en);\n\t} else {\n\t\t \n\t\twake_en &= ~SDW_SHIM2_INTEL_VS_WAKEEN_PWE;\n\t\tintel_writew(shim_vs, SDW_SHIM2_INTEL_VS_WAKEEN, wake_en);\n\n\t\t \n\t\twake_sts = intel_readw(shim_vs, SDW_SHIM2_INTEL_VS_WAKESTS);\n\t\twake_sts |= SDW_SHIM2_INTEL_VS_WAKEEN_PWS;\n\t\tintel_writew(shim_vs, SDW_SHIM2_INTEL_VS_WAKESTS, wake_sts);\n\t}\n}\n\nstatic int intel_link_power_up(struct sdw_intel *sdw)\n{\n\tstruct sdw_bus *bus = &sdw->cdns.bus;\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tu32 *shim_mask = sdw->link_res->shim_mask;\n\tunsigned int link_id = sdw->instance;\n\tu32 syncprd;\n\tint ret;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\tif (!*shim_mask) {\n\t\t \n\t\tdev_dbg(sdw->cdns.dev, \"first link up, programming SYNCPRD\\n\");\n\n\t\tif (prop->mclk_freq % 6000000)\n\t\t\tsyncprd = SDW_SHIM_SYNC_SYNCPRD_VAL_38_4;\n\t\telse\n\t\t\tsyncprd = SDW_SHIM_SYNC_SYNCPRD_VAL_24;\n\n\t\tret =  hdac_bus_eml_sdw_set_syncprd_unlocked(sdw->link_res->hbus, syncprd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdw->cdns.dev, \"%s: hdac_bus_eml_sdw_set_syncprd failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = hdac_bus_eml_sdw_power_up_unlocked(sdw->link_res->hbus, link_id);\n\tif (ret < 0) {\n\t\tdev_err(sdw->cdns.dev, \"%s: hdac_bus_eml_sdw_power_up failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tif (!*shim_mask) {\n\t\t \n\t\tret =  hdac_bus_eml_sdw_wait_syncpu_unlocked(sdw->link_res->hbus);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdw->cdns.dev, \"%s: hdac_bus_eml_sdw_wait_syncpu failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*shim_mask |= BIT(link_id);\n\n\tsdw->cdns.link_up = true;\n\n\tintel_shim_vs_init(sdw);\n\nout:\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\nstatic int intel_link_power_down(struct sdw_intel *sdw)\n{\n\tu32 *shim_mask = sdw->link_res->shim_mask;\n\tunsigned int link_id = sdw->instance;\n\tint ret;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\tsdw->cdns.link_up = false;\n\n\t*shim_mask &= ~BIT(link_id);\n\n\tret = hdac_bus_eml_sdw_power_down_unlocked(sdw->link_res->hbus, link_id);\n\tif (ret < 0) {\n\t\tdev_err(sdw->cdns.dev, \"%s: hdac_bus_eml_sdw_power_down failed: %d\\n\",\n\t\t\t__func__, ret);\n\n\t\t \n\t}\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\nstatic void intel_sync_arm(struct sdw_intel *sdw)\n{\n\tunsigned int link_id = sdw->instance;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\thdac_bus_eml_sdw_sync_arm_unlocked(sdw->link_res->hbus, link_id);\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n}\n\nstatic int intel_sync_go_unlocked(struct sdw_intel *sdw)\n{\n\tint ret;\n\n\tret = hdac_bus_eml_sdw_sync_go_unlocked(sdw->link_res->hbus);\n\tif (ret < 0)\n\t\tdev_err(sdw->cdns.dev, \"%s: SyncGO clear failed: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int intel_sync_go(struct sdw_intel *sdw)\n{\n\tint ret;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\tret = intel_sync_go_unlocked(sdw);\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\treturn ret;\n}\n\nstatic bool intel_check_cmdsync_unlocked(struct sdw_intel *sdw)\n{\n\treturn hdac_bus_eml_sdw_check_cmdsync_unlocked(sdw->link_res->hbus);\n}\n\n \nstatic int intel_params_stream(struct sdw_intel *sdw,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai,\n\t\t\t       struct snd_pcm_hw_params *hw_params,\n\t\t\t       int link_id, int alh_stream_id)\n{\n\tstruct sdw_intel_link_res *res = sdw->link_res;\n\tstruct sdw_intel_stream_params_data params_data;\n\n\tparams_data.substream = substream;\n\tparams_data.dai = dai;\n\tparams_data.hw_params = hw_params;\n\tparams_data.link_id = link_id;\n\tparams_data.alh_stream_id = alh_stream_id;\n\n\tif (res->ops && res->ops->params_stream && res->dev)\n\t\treturn res->ops->params_stream(res->dev,\n\t\t\t\t\t       &params_data);\n\treturn -EIO;\n}\n\nstatic int intel_free_stream(struct sdw_intel *sdw,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai,\n\t\t\t     int link_id)\n\n{\n\tstruct sdw_intel_link_res *res = sdw->link_res;\n\tstruct sdw_intel_stream_free_data free_data;\n\n\tfree_data.substream = substream;\n\tfree_data.dai = dai;\n\tfree_data.link_id = link_id;\n\n\tif (res->ops && res->ops->free_stream && res->dev)\n\t\treturn res->ops->free_stream(res->dev,\n\t\t\t\t\t     &free_data);\n\n\treturn 0;\n}\n\n \nstatic int intel_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tstruct sdw_cdns_pdi *pdi;\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_port_config *pconfig;\n\tint ch, dir;\n\tint ret;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\tch = params_channels(params);\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tdir = SDW_DATA_DIR_RX;\n\telse\n\t\tdir = SDW_DATA_DIR_TX;\n\n\tpdi = sdw_cdns_alloc_pdi(cdns, &cdns->pcm, ch, dir, dai->id);\n\n\tif (!pdi) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\n\tsdw_cdns_config_stream(cdns, ch, dir, pdi);\n\n\t \n\tdai_runtime->paused = false;\n\tdai_runtime->suspended = false;\n\tdai_runtime->pdi = pdi;\n\n\t \n\tret = intel_params_stream(sdw, substream, dai, params,\n\t\t\t\t  sdw->instance,\n\t\t\t\t  pdi->intel_alh_id);\n\tif (ret)\n\t\tgoto error;\n\n\tsconfig.direction = dir;\n\tsconfig.ch_count = ch;\n\tsconfig.frame_rate = params_rate(params);\n\tsconfig.type = dai_runtime->stream_type;\n\n\tsconfig.bps = snd_pcm_format_width(params_format(params));\n\n\t \n\tpconfig = kzalloc(sizeof(*pconfig), GFP_KERNEL);\n\tif (!pconfig) {\n\t\tret =  -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpconfig->num = pdi->num;\n\tpconfig->ch_mask = (1 << ch) - 1;\n\n\tret = sdw_stream_add_master(&cdns->bus, &sconfig,\n\t\t\t\t    pconfig, 1, dai_runtime->stream);\n\tif (ret)\n\t\tdev_err(cdns->dev, \"add master to stream failed:%d\\n\", ret);\n\n\tkfree(pconfig);\nerror:\n\treturn ret;\n}\n\nstatic int intel_prepare(struct snd_pcm_substream *substream,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ch, dir;\n\tint ret = 0;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime) {\n\t\tdev_err(dai->dev, \"failed to get dai runtime in %s\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tif (dai_runtime->suspended) {\n\t\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\t\tstruct snd_pcm_hw_params *hw_params;\n\n\t\thw_params = &rtd->dpcm[substream->stream].hw_params;\n\n\t\tdai_runtime->suspended = false;\n\n\t\t \n\n\t\t \n\t\tch = params_channels(hw_params);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tdir = SDW_DATA_DIR_RX;\n\t\telse\n\t\t\tdir = SDW_DATA_DIR_TX;\n\n\t\t \n\n\t\tsdw_cdns_config_stream(cdns, ch, dir, dai_runtime->pdi);\n\n\t\t \n\t\tret = intel_params_stream(sdw, substream, dai,\n\t\t\t\t\t  hw_params,\n\t\t\t\t\t  sdw->instance,\n\t\t\t\t\t  dai_runtime->pdi->intel_alh_id);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nintel_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ret;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\t \n\tret = sdw_stream_remove_master(&cdns->bus, dai_runtime->stream);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"remove master from stream %s failed: %d\\n\",\n\t\t\tdai_runtime->stream->name, ret);\n\t\treturn ret;\n\t}\n\n\tret = intel_free_stream(sdw, substream, dai, sdw->instance);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"intel_free_stream: failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdai_runtime->pdi = NULL;\n\n\treturn 0;\n}\n\nstatic int intel_pcm_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t    void *stream, int direction)\n{\n\treturn cdns_set_sdw_stream(dai, stream, direction);\n}\n\nstatic void *intel_get_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t  int direction)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn dai_runtime->stream;\n}\n\nstatic int intel_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_intel_link_res *res = sdw->link_res;\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\tint ret = 0;\n\n\t \n\tif (res->ops && res->ops->trigger) {\n\t\tret = res->ops->trigger(substream, cmd, dai);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\tif (!dai_runtime) {\n\t\tdev_err(dai->dev, \"failed to get dai runtime in %s\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\n\t\t \n\n\t\tdai_runtime->suspended = true;\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdai_runtime->paused = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdai_runtime->paused = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops intel_pcm_dai_ops = {\n\t.hw_params = intel_hw_params,\n\t.prepare = intel_prepare,\n\t.hw_free = intel_hw_free,\n\t.trigger = intel_trigger,\n\t.set_stream = intel_pcm_set_sdw_stream,\n\t.get_stream = intel_get_sdw_stream,\n};\n\nstatic const struct snd_soc_component_driver dai_component = {\n\t.name\t\t\t= \"soundwire\",\n};\n\n \nstatic void intel_pdi_init(struct sdw_intel *sdw,\n\t\t\t   struct sdw_cdns_stream_config *config)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\tint pcm_cap;\n\n\t \n\tpcm_cap = intel_readw(shim, SDW_SHIM2_PCMSCAP);\n\n\tconfig->pcm_bd = FIELD_GET(SDW_SHIM2_PCMSCAP_BSS, pcm_cap);\n\tconfig->pcm_in = FIELD_GET(SDW_SHIM2_PCMSCAP_ISS, pcm_cap);\n\tconfig->pcm_out = FIELD_GET(SDW_SHIM2_PCMSCAP_ISS, pcm_cap);\n\n\tdev_dbg(sdw->cdns.dev, \"PCM cap bd:%d in:%d out:%d\\n\",\n\t\tconfig->pcm_bd, config->pcm_in, config->pcm_out);\n}\n\nstatic int\nintel_pdi_get_ch_cap(struct sdw_intel *sdw, unsigned int pdi_num)\n{\n\tvoid __iomem *shim = sdw->link_res->shim;\n\n\t \n\treturn intel_readw(shim, SDW_SHIM2_PCMSYCHC(pdi_num)) + 1;\n}\n\nstatic void intel_pdi_get_ch_update(struct sdw_intel *sdw,\n\t\t\t\t    struct sdw_cdns_pdi *pdi,\n\t\t\t\t    unsigned int num_pdi,\n\t\t\t\t    unsigned int *num_ch)\n{\n\tint ch_count = 0;\n\tint i;\n\n\tfor (i = 0; i < num_pdi; i++) {\n\t\tpdi->ch_count = intel_pdi_get_ch_cap(sdw, pdi->num);\n\t\tch_count += pdi->ch_count;\n\t\tpdi++;\n\t}\n\n\t*num_ch = ch_count;\n}\n\nstatic void intel_pdi_stream_ch_update(struct sdw_intel *sdw,\n\t\t\t\t       struct sdw_cdns_streams *stream)\n{\n\tintel_pdi_get_ch_update(sdw, stream->bd, stream->num_bd,\n\t\t\t\t&stream->num_ch_bd);\n\n\tintel_pdi_get_ch_update(sdw, stream->in, stream->num_in,\n\t\t\t\t&stream->num_ch_in);\n\n\tintel_pdi_get_ch_update(sdw, stream->out, stream->num_out,\n\t\t\t\t&stream->num_ch_out);\n}\n\nstatic int intel_create_dai(struct sdw_cdns *cdns,\n\t\t\t    struct snd_soc_dai_driver *dais,\n\t\t\t    enum intel_pdi_type type,\n\t\t\t    u32 num, u32 off, u32 max_ch)\n{\n\tint i;\n\n\tif (!num)\n\t\treturn 0;\n\n\tfor (i = off; i < (off + num); i++) {\n\t\tdais[i].name = devm_kasprintf(cdns->dev, GFP_KERNEL,\n\t\t\t\t\t      \"SDW%d Pin%d\",\n\t\t\t\t\t      cdns->instance, i);\n\t\tif (!dais[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (type == INTEL_PDI_BD || type == INTEL_PDI_OUT) {\n\t\t\tdais[i].playback.channels_min = 1;\n\t\t\tdais[i].playback.channels_max = max_ch;\n\t\t}\n\n\t\tif (type == INTEL_PDI_BD || type == INTEL_PDI_IN) {\n\t\t\tdais[i].capture.channels_min = 1;\n\t\t\tdais[i].capture.channels_max = max_ch;\n\t\t}\n\n\t\tdais[i].ops = &intel_pcm_dai_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_register_dai(struct sdw_intel *sdw)\n{\n\tstruct sdw_cdns_dai_runtime **dai_runtime_array;\n\tstruct sdw_cdns_stream_config config;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_cdns_streams *stream;\n\tstruct snd_soc_dai_driver *dais;\n\tint num_dai;\n\tint ret;\n\tint off = 0;\n\n\t \n\tintel_pdi_init(sdw, &config);\n\tret = sdw_cdns_pdi_init(cdns, config);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_pdi_stream_ch_update(sdw, &sdw->cdns.pcm);\n\n\t \n\tnum_dai = cdns->pcm.num_pdi;\n\n\tdai_runtime_array = devm_kcalloc(cdns->dev, num_dai,\n\t\t\t\t\t sizeof(struct sdw_cdns_dai_runtime *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!dai_runtime_array)\n\t\treturn -ENOMEM;\n\tcdns->dai_runtime_array = dai_runtime_array;\n\n\tdais = devm_kcalloc(cdns->dev, num_dai, sizeof(*dais), GFP_KERNEL);\n\tif (!dais)\n\t\treturn -ENOMEM;\n\n\t \n\tstream = &cdns->pcm;\n\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_IN, cdns->pcm.num_in,\n\t\t\t       off, stream->num_ch_in);\n\tif (ret)\n\t\treturn ret;\n\n\toff += cdns->pcm.num_in;\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_OUT, cdns->pcm.num_out,\n\t\t\t       off, stream->num_ch_out);\n\tif (ret)\n\t\treturn ret;\n\n\toff += cdns->pcm.num_out;\n\tret = intel_create_dai(cdns, dais, INTEL_PDI_BD, cdns->pcm.num_bd,\n\t\t\t       off, stream->num_ch_bd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(cdns->dev, &dai_component,\n\t\t\t\t\t       dais, num_dai);\n}\n\nstatic void intel_program_sdi(struct sdw_intel *sdw, int dev_num)\n{\n\tint ret;\n\n\tret = hdac_bus_eml_sdw_set_lsdiid(sdw->link_res->hbus, sdw->instance, dev_num);\n\tif (ret < 0)\n\t\tdev_err(sdw->cdns.dev, \"%s: could not set lsdiid for link %d %d\\n\",\n\t\t\t__func__, sdw->instance, dev_num);\n}\n\nconst struct sdw_intel_hw_ops sdw_intel_lnl_hw_ops = {\n\t.debugfs_init = intel_ace2x_debugfs_init,\n\t.debugfs_exit = intel_ace2x_debugfs_exit,\n\n\t.register_dai = intel_register_dai,\n\n\t.check_clock_stop = intel_check_clock_stop,\n\t.start_bus = intel_start_bus,\n\t.start_bus_after_reset = intel_start_bus_after_reset,\n\t.start_bus_after_clock_stop = intel_start_bus_after_clock_stop,\n\t.stop_bus = intel_stop_bus,\n\n\t.link_power_up = intel_link_power_up,\n\t.link_power_down = intel_link_power_down,\n\n\t.shim_check_wake = intel_shim_check_wake,\n\t.shim_wake = intel_shim_wake,\n\n\t.pre_bank_switch = intel_pre_bank_switch,\n\t.post_bank_switch = intel_post_bank_switch,\n\n\t.sync_arm = intel_sync_arm,\n\t.sync_go_unlocked = intel_sync_go_unlocked,\n\t.sync_go = intel_sync_go,\n\t.sync_check_cmdsync_unlocked = intel_check_cmdsync_unlocked,\n\n\t.program_sdi = intel_program_sdi,\n};\nEXPORT_SYMBOL_NS(sdw_intel_lnl_hw_ops, SOUNDWIRE_INTEL);\n\nMODULE_IMPORT_NS(SND_SOC_SOF_HDA_MLINK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}