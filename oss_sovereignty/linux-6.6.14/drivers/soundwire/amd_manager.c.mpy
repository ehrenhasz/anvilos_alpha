{
  "module_name": "amd_manager.c",
  "hash_id": "120505ea6af400fcf6f034a1088a0ecdc39fbfa2f4b794d4ce33e756f70fcf42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/amd_manager.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/pm_runtime.h>\n#include <linux/wait.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"bus.h\"\n#include \"amd_manager.h\"\n\n#define DRV_NAME \"amd_sdw_manager\"\n\n#define to_amd_sdw(b)\tcontainer_of(b, struct amd_sdw_manager, bus)\n\nstatic void amd_enable_sdw_pads(struct amd_sdw_manager *amd_manager)\n{\n\tu32 sw_pad_pulldown_val;\n\tu32 val;\n\n\tmutex_lock(amd_manager->acp_sdw_lock);\n\tval = readl(amd_manager->acp_mmio + ACP_SW_PAD_KEEPER_EN);\n\tval |= amd_manager->reg_mask->sw_pad_enable_mask;\n\twritel(val, amd_manager->acp_mmio + ACP_SW_PAD_KEEPER_EN);\n\tusleep_range(1000, 1500);\n\n\tsw_pad_pulldown_val = readl(amd_manager->acp_mmio + ACP_PAD_PULLDOWN_CTRL);\n\tsw_pad_pulldown_val &= amd_manager->reg_mask->sw_pad_pulldown_mask;\n\twritel(sw_pad_pulldown_val, amd_manager->acp_mmio + ACP_PAD_PULLDOWN_CTRL);\n\tmutex_unlock(amd_manager->acp_sdw_lock);\n}\n\nstatic int amd_init_sdw_manager(struct amd_sdw_manager *amd_manager)\n{\n\tu32 val;\n\tint ret;\n\n\twritel(AMD_SDW_ENABLE, amd_manager->mmio + ACP_SW_EN);\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_EN_STATUS, val, val, ACP_DELAY_US,\n\t\t\t\t AMD_SDW_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(AMD_SDW_BUS_RESET_REQ, amd_manager->mmio + ACP_SW_BUS_RESET_CTRL);\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_BUS_RESET_CTRL, val,\n\t\t\t\t (val & AMD_SDW_BUS_RESET_DONE), ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(AMD_SDW_BUS_RESET_CLEAR_REQ, amd_manager->mmio + ACP_SW_BUS_RESET_CTRL);\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_BUS_RESET_CTRL, val, !val,\n\t\t\t\t ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(amd_manager->dev, \"Failed to reset SoundWire manager instance%d\\n\",\n\t\t\tamd_manager->instance);\n\t\treturn ret;\n\t}\n\n\twritel(AMD_SDW_DISABLE, amd_manager->mmio + ACP_SW_EN);\n\treturn readl_poll_timeout(amd_manager->mmio + ACP_SW_EN_STATUS, val, !val, ACP_DELAY_US,\n\t\t\t\t  AMD_SDW_TIMEOUT);\n}\n\nstatic int amd_enable_sdw_manager(struct amd_sdw_manager *amd_manager)\n{\n\tu32 val;\n\n\twritel(AMD_SDW_ENABLE, amd_manager->mmio + ACP_SW_EN);\n\treturn readl_poll_timeout(amd_manager->mmio + ACP_SW_EN_STATUS, val, val, ACP_DELAY_US,\n\t\t\t\t  AMD_SDW_TIMEOUT);\n}\n\nstatic int amd_disable_sdw_manager(struct amd_sdw_manager *amd_manager)\n{\n\tu32 val;\n\n\twritel(AMD_SDW_DISABLE, amd_manager->mmio + ACP_SW_EN);\n\t \n\tval = readl(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\tif (val)\n\t\treturn 0;\n\treturn readl_poll_timeout(amd_manager->mmio + ACP_SW_EN_STATUS, val, !val, ACP_DELAY_US,\n\t\t\t\t  AMD_SDW_TIMEOUT);\n}\n\nstatic void amd_enable_sdw_interrupts(struct amd_sdw_manager *amd_manager)\n{\n\tstruct sdw_manager_reg_mask *reg_mask = amd_manager->reg_mask;\n\tu32 val;\n\n\tmutex_lock(amd_manager->acp_sdw_lock);\n\tval = readl(amd_manager->acp_mmio + ACP_EXTERNAL_INTR_CNTL(amd_manager->instance));\n\tval |= reg_mask->acp_sdw_intr_mask;\n\twritel(val, amd_manager->acp_mmio + ACP_EXTERNAL_INTR_CNTL(amd_manager->instance));\n\tmutex_unlock(amd_manager->acp_sdw_lock);\n\n\twritel(AMD_SDW_IRQ_MASK_0TO7, amd_manager->mmio +\n\t\t       ACP_SW_STATE_CHANGE_STATUS_MASK_0TO7);\n\twritel(AMD_SDW_IRQ_MASK_8TO11, amd_manager->mmio +\n\t\t       ACP_SW_STATE_CHANGE_STATUS_MASK_8TO11);\n\twritel(AMD_SDW_IRQ_ERROR_MASK, amd_manager->mmio + ACP_SW_ERROR_INTR_MASK);\n}\n\nstatic void amd_disable_sdw_interrupts(struct amd_sdw_manager *amd_manager)\n{\n\tstruct sdw_manager_reg_mask *reg_mask = amd_manager->reg_mask;\n\tu32 val;\n\n\tmutex_lock(amd_manager->acp_sdw_lock);\n\tval = readl(amd_manager->acp_mmio + ACP_EXTERNAL_INTR_CNTL(amd_manager->instance));\n\tval &= ~reg_mask->acp_sdw_intr_mask;\n\twritel(val, amd_manager->acp_mmio + ACP_EXTERNAL_INTR_CNTL(amd_manager->instance));\n\tmutex_unlock(amd_manager->acp_sdw_lock);\n\n\twritel(0x00, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_MASK_0TO7);\n\twritel(0x00, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_MASK_8TO11);\n\twritel(0x00, amd_manager->mmio + ACP_SW_ERROR_INTR_MASK);\n}\n\nstatic int amd_deinit_sdw_manager(struct amd_sdw_manager *amd_manager)\n{\n\tamd_disable_sdw_interrupts(amd_manager);\n\treturn amd_disable_sdw_manager(amd_manager);\n}\n\nstatic void amd_sdw_set_frameshape(struct amd_sdw_manager *amd_manager)\n{\n\tu32 frame_size;\n\n\tframe_size = (amd_manager->rows_index << 3) | amd_manager->cols_index;\n\twritel(frame_size, amd_manager->mmio + ACP_SW_FRAMESIZE);\n}\n\nstatic void amd_sdw_ctl_word_prep(u32 *lower_word, u32 *upper_word, struct sdw_msg *msg,\n\t\t\t\t  int cmd_offset)\n{\n\tu32 upper_data;\n\tu32 lower_data = 0;\n\tu16 addr;\n\tu8 upper_addr, lower_addr;\n\tu8 data = 0;\n\n\taddr = msg->addr + cmd_offset;\n\tupper_addr = (addr & 0xFF00) >> 8;\n\tlower_addr = addr & 0xFF;\n\n\tif (msg->flags == SDW_MSG_FLAG_WRITE)\n\t\tdata = msg->buf[cmd_offset];\n\n\tupper_data = FIELD_PREP(AMD_SDW_MCP_CMD_DEV_ADDR, msg->dev_num);\n\tupper_data |= FIELD_PREP(AMD_SDW_MCP_CMD_COMMAND, msg->flags + 2);\n\tupper_data |= FIELD_PREP(AMD_SDW_MCP_CMD_REG_ADDR_HIGH, upper_addr);\n\tlower_data |= FIELD_PREP(AMD_SDW_MCP_CMD_REG_ADDR_LOW, lower_addr);\n\tlower_data |= FIELD_PREP(AMD_SDW_MCP_CMD_REG_DATA, data);\n\n\t*upper_word = upper_data;\n\t*lower_word = lower_data;\n}\n\nstatic u64 amd_sdw_send_cmd_get_resp(struct amd_sdw_manager *amd_manager, u32 lower_data,\n\t\t\t\t     u32 upper_data)\n{\n\tu64 resp;\n\tu32 lower_resp, upper_resp;\n\tu32 sts;\n\tint ret;\n\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_IMM_CMD_STS, sts,\n\t\t\t\t !(sts & AMD_SDW_IMM_CMD_BUSY), ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(amd_manager->dev, \"SDW%x previous cmd status clear failed\\n\",\n\t\t\tamd_manager->instance);\n\t\treturn ret;\n\t}\n\n\tif (sts & AMD_SDW_IMM_RES_VALID) {\n\t\tdev_err(amd_manager->dev, \"SDW%x manager is in bad state\\n\", amd_manager->instance);\n\t\twritel(0x00, amd_manager->mmio + ACP_SW_IMM_CMD_STS);\n\t}\n\twritel(upper_data, amd_manager->mmio + ACP_SW_IMM_CMD_UPPER_WORD);\n\twritel(lower_data, amd_manager->mmio + ACP_SW_IMM_CMD_LOWER_QWORD);\n\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_IMM_CMD_STS, sts,\n\t\t\t\t (sts & AMD_SDW_IMM_RES_VALID), ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(amd_manager->dev, \"SDW%x cmd response timeout occurred\\n\",\n\t\t\tamd_manager->instance);\n\t\treturn ret;\n\t}\n\tupper_resp = readl(amd_manager->mmio + ACP_SW_IMM_RESP_UPPER_WORD);\n\tlower_resp = readl(amd_manager->mmio + ACP_SW_IMM_RESP_LOWER_QWORD);\n\n\twritel(AMD_SDW_IMM_RES_VALID, amd_manager->mmio + ACP_SW_IMM_CMD_STS);\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_IMM_CMD_STS, sts,\n\t\t\t\t !(sts & AMD_SDW_IMM_RES_VALID), ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(amd_manager->dev, \"SDW%x cmd status retry failed\\n\",\n\t\t\tamd_manager->instance);\n\t\treturn ret;\n\t}\n\tresp = upper_resp;\n\tresp = (resp << 32) | lower_resp;\n\treturn resp;\n}\n\nstatic enum sdw_command_response\namd_program_scp_addr(struct amd_sdw_manager *amd_manager, struct sdw_msg *msg)\n{\n\tstruct sdw_msg scp_msg = {0};\n\tu64 response_buf[2] = {0};\n\tu32 upper_data = 0, lower_data = 0;\n\tint index;\n\n\tscp_msg.dev_num = msg->dev_num;\n\tscp_msg.addr = SDW_SCP_ADDRPAGE1;\n\tscp_msg.buf = &msg->addr_page1;\n\tscp_msg.flags = SDW_MSG_FLAG_WRITE;\n\tamd_sdw_ctl_word_prep(&lower_data, &upper_data, &scp_msg, 0);\n\tresponse_buf[0] = amd_sdw_send_cmd_get_resp(amd_manager, lower_data, upper_data);\n\tscp_msg.addr = SDW_SCP_ADDRPAGE2;\n\tscp_msg.buf = &msg->addr_page2;\n\tamd_sdw_ctl_word_prep(&lower_data, &upper_data, &scp_msg, 0);\n\tresponse_buf[1] = amd_sdw_send_cmd_get_resp(amd_manager, lower_data, upper_data);\n\n\tfor (index = 0; index < 2; index++) {\n\t\tif (response_buf[index] == -ETIMEDOUT) {\n\t\t\tdev_err_ratelimited(amd_manager->dev,\n\t\t\t\t\t    \"SCP_addrpage command timeout for Slave %d\\n\",\n\t\t\t\t\t    msg->dev_num);\n\t\t\treturn SDW_CMD_TIMEOUT;\n\t\t} else if (!(response_buf[index] & AMD_SDW_MCP_RESP_ACK)) {\n\t\t\tif (response_buf[index] & AMD_SDW_MCP_RESP_NACK) {\n\t\t\t\tdev_err_ratelimited(amd_manager->dev,\n\t\t\t\t\t\t    \"SCP_addrpage NACKed for Slave %d\\n\",\n\t\t\t\t\t\t    msg->dev_num);\n\t\t\t\treturn SDW_CMD_FAIL;\n\t\t\t}\n\t\t\tdev_dbg_ratelimited(amd_manager->dev, \"SCP_addrpage ignored for Slave %d\\n\",\n\t\t\t\t\t    msg->dev_num);\n\t\t\treturn SDW_CMD_IGNORED;\n\t\t}\n\t}\n\treturn SDW_CMD_OK;\n}\n\nstatic int amd_prep_msg(struct amd_sdw_manager *amd_manager, struct sdw_msg *msg)\n{\n\tint ret;\n\n\tif (msg->page) {\n\t\tret = amd_program_scp_addr(amd_manager, msg);\n\t\tif (ret) {\n\t\t\tmsg->len = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tswitch (msg->flags) {\n\tcase SDW_MSG_FLAG_READ:\n\tcase SDW_MSG_FLAG_WRITE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(amd_manager->dev, \"Invalid msg cmd: %d\\n\", msg->flags);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum sdw_command_response amd_sdw_fill_msg_resp(struct amd_sdw_manager *amd_manager,\n\t\t\t\t\t\t       struct sdw_msg *msg, u64 response,\n\t\t\t\t\t\t       int offset)\n{\n\tif (response & AMD_SDW_MCP_RESP_ACK) {\n\t\tif (msg->flags == SDW_MSG_FLAG_READ)\n\t\t\tmsg->buf[offset] = FIELD_GET(AMD_SDW_MCP_RESP_RDATA, response);\n\t} else {\n\t\tif (response == -ETIMEDOUT) {\n\t\t\tdev_err_ratelimited(amd_manager->dev, \"command timeout for Slave %d\\n\",\n\t\t\t\t\t    msg->dev_num);\n\t\t\treturn SDW_CMD_TIMEOUT;\n\t\t} else if (response & AMD_SDW_MCP_RESP_NACK) {\n\t\t\tdev_err_ratelimited(amd_manager->dev,\n\t\t\t\t\t    \"command response NACK received for Slave %d\\n\",\n\t\t\t\t\t    msg->dev_num);\n\t\t\treturn SDW_CMD_FAIL;\n\t\t}\n\t\tdev_err_ratelimited(amd_manager->dev, \"command is ignored for Slave %d\\n\",\n\t\t\t\t    msg->dev_num);\n\t\treturn SDW_CMD_IGNORED;\n\t}\n\treturn SDW_CMD_OK;\n}\n\nstatic unsigned int _amd_sdw_xfer_msg(struct amd_sdw_manager *amd_manager, struct sdw_msg *msg,\n\t\t\t\t      int cmd_offset)\n{\n\tu64 response;\n\tu32 upper_data = 0, lower_data = 0;\n\n\tamd_sdw_ctl_word_prep(&lower_data, &upper_data, msg, cmd_offset);\n\tresponse = amd_sdw_send_cmd_get_resp(amd_manager, lower_data, upper_data);\n\treturn amd_sdw_fill_msg_resp(amd_manager, msg, response, cmd_offset);\n}\n\nstatic enum sdw_command_response amd_sdw_xfer_msg(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tint ret, i;\n\n\tret = amd_prep_msg(amd_manager, msg);\n\tif (ret)\n\t\treturn SDW_CMD_FAIL_OTHER;\n\tfor (i = 0; i < msg->len; i++) {\n\t\tret = _amd_sdw_xfer_msg(amd_manager, msg, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn SDW_CMD_OK;\n}\n\nstatic void amd_sdw_fill_slave_status(struct amd_sdw_manager *amd_manager, u16 index, u32 status)\n{\n\tswitch (status) {\n\tcase SDW_SLAVE_ATTACHED:\n\tcase SDW_SLAVE_UNATTACHED:\n\tcase SDW_SLAVE_ALERT:\n\t\tamd_manager->status[index] = status;\n\t\tbreak;\n\tdefault:\n\t\tamd_manager->status[index] = SDW_SLAVE_RESERVED;\n\t\tbreak;\n\t}\n}\n\nstatic void amd_sdw_process_ping_status(u64 response, struct amd_sdw_manager *amd_manager)\n{\n\tu64 slave_stat;\n\tu32 val;\n\tu16 dev_index;\n\n\t \n\tslave_stat = FIELD_GET(AMD_SDW_MCP_SLAVE_STAT_0_3, response);\n\tslave_stat |= FIELD_GET(AMD_SDW_MCP_SLAVE_STAT_4_11, response) << 8;\n\tdev_dbg(amd_manager->dev, \"slave_stat:0x%llx\\n\", slave_stat);\n\tfor (dev_index = 0; dev_index <= SDW_MAX_DEVICES; ++dev_index) {\n\t\tval = (slave_stat >> (dev_index * 2)) & AMD_SDW_MCP_SLAVE_STATUS_MASK;\n\t\tdev_dbg(amd_manager->dev, \"val:0x%x\\n\", val);\n\t\tamd_sdw_fill_slave_status(amd_manager, dev_index, val);\n\t}\n}\n\nstatic void amd_sdw_read_and_process_ping_status(struct amd_sdw_manager *amd_manager)\n{\n\tu64 response;\n\n\tmutex_lock(&amd_manager->bus.msg_lock);\n\tresponse = amd_sdw_send_cmd_get_resp(amd_manager, 0, 0);\n\tmutex_unlock(&amd_manager->bus.msg_lock);\n\tamd_sdw_process_ping_status(response, amd_manager);\n}\n\nstatic u32 amd_sdw_read_ping_status(struct sdw_bus *bus)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tu64 response;\n\tu32 slave_stat;\n\n\tresponse = amd_sdw_send_cmd_get_resp(amd_manager, 0, 0);\n\t \n\tslave_stat = FIELD_GET(AMD_SDW_MCP_SLAVE_STAT_0_3, response);\n\tslave_stat |= FIELD_GET(AMD_SDW_MCP_SLAVE_STAT_4_11, response) << 8;\n\tdev_dbg(amd_manager->dev, \"slave_stat:0x%x\\n\", slave_stat);\n\treturn slave_stat;\n}\n\nstatic int amd_sdw_compute_params(struct sdw_bus *bus)\n{\n\tstruct sdw_transport_data t_data = {0};\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_port_runtime *p_rt;\n\tstruct sdw_bus_params *b_params = &bus->params;\n\tint port_bo, hstart, hstop, sample_int;\n\tunsigned int rate, bps;\n\n\tport_bo = 0;\n\thstart = 1;\n\thstop = bus->params.col - 1;\n\tt_data.hstop = hstop;\n\tt_data.hstart = hstart;\n\n\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\t\trate = m_rt->stream->params.rate;\n\t\tbps = m_rt->stream->params.bps;\n\t\tsample_int = (bus->params.curr_dr_freq / rate);\n\t\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\t\t\tport_bo = (p_rt->num * 64) + 1;\n\t\t\tdev_dbg(bus->dev, \"p_rt->num=%d hstart=%d hstop=%d port_bo=%d\\n\",\n\t\t\t\tp_rt->num, hstart, hstop, port_bo);\n\t\t\tsdw_fill_xport_params(&p_rt->transport_params, p_rt->num,\n\t\t\t\t\t      false, SDW_BLK_GRP_CNT_1, sample_int,\n\t\t\t\t\t      port_bo, port_bo >> 8, hstart, hstop,\n\t\t\t\t\t      SDW_BLK_PKG_PER_PORT, 0x0);\n\n\t\t\tsdw_fill_port_params(&p_rt->port_params,\n\t\t\t\t\t     p_rt->num, bps,\n\t\t\t\t\t     SDW_PORT_FLOW_MODE_ISOCH,\n\t\t\t\t\t     b_params->m_data_mode);\n\t\t\tt_data.hstart = hstart;\n\t\t\tt_data.hstop = hstop;\n\t\t\tt_data.block_offset = port_bo;\n\t\t\tt_data.sub_block_offset = 0;\n\t\t}\n\t\tsdw_compute_slave_ports(m_rt, &t_data);\n\t}\n\treturn 0;\n}\n\nstatic int amd_sdw_port_params(struct sdw_bus *bus, struct sdw_port_params *p_params,\n\t\t\t       unsigned int bank)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tu32 frame_fmt_reg, dpn_frame_fmt;\n\n\tdev_dbg(amd_manager->dev, \"p_params->num:0x%x\\n\", p_params->num);\n\tswitch (amd_manager->instance) {\n\tcase ACP_SDW0:\n\t\tframe_fmt_reg = sdw0_manager_dp_reg[p_params->num].frame_fmt_reg;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tframe_fmt_reg = sdw1_manager_dp_reg[p_params->num].frame_fmt_reg;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdpn_frame_fmt = readl(amd_manager->mmio + frame_fmt_reg);\n\tu32p_replace_bits(&dpn_frame_fmt, p_params->flow_mode, AMD_DPN_FRAME_FMT_PFM);\n\tu32p_replace_bits(&dpn_frame_fmt, p_params->data_mode, AMD_DPN_FRAME_FMT_PDM);\n\tu32p_replace_bits(&dpn_frame_fmt, p_params->bps - 1, AMD_DPN_FRAME_FMT_WORD_LEN);\n\twritel(dpn_frame_fmt, amd_manager->mmio + frame_fmt_reg);\n\treturn 0;\n}\n\nstatic int amd_sdw_transport_params(struct sdw_bus *bus,\n\t\t\t\t    struct sdw_transport_params *params,\n\t\t\t\t    enum sdw_reg_bank bank)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tu32 dpn_frame_fmt;\n\tu32 dpn_sampleinterval;\n\tu32 dpn_hctrl;\n\tu32 dpn_offsetctrl;\n\tu32 dpn_lanectrl;\n\tu32 frame_fmt_reg, sample_int_reg, hctrl_dp0_reg;\n\tu32 offset_reg, lane_ctrl_ch_en_reg;\n\n\tswitch (amd_manager->instance) {\n\tcase ACP_SDW0:\n\t\tframe_fmt_reg = sdw0_manager_dp_reg[params->port_num].frame_fmt_reg;\n\t\tsample_int_reg = sdw0_manager_dp_reg[params->port_num].sample_int_reg;\n\t\thctrl_dp0_reg = sdw0_manager_dp_reg[params->port_num].hctrl_dp0_reg;\n\t\toffset_reg = sdw0_manager_dp_reg[params->port_num].offset_reg;\n\t\tlane_ctrl_ch_en_reg = sdw0_manager_dp_reg[params->port_num].lane_ctrl_ch_en_reg;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tframe_fmt_reg = sdw1_manager_dp_reg[params->port_num].frame_fmt_reg;\n\t\tsample_int_reg = sdw1_manager_dp_reg[params->port_num].sample_int_reg;\n\t\thctrl_dp0_reg = sdw1_manager_dp_reg[params->port_num].hctrl_dp0_reg;\n\t\toffset_reg = sdw1_manager_dp_reg[params->port_num].offset_reg;\n\t\tlane_ctrl_ch_en_reg = sdw1_manager_dp_reg[params->port_num].lane_ctrl_ch_en_reg;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(AMD_SDW_SSP_COUNTER_VAL, amd_manager->mmio + ACP_SW_SSP_COUNTER);\n\n\tdpn_frame_fmt = readl(amd_manager->mmio + frame_fmt_reg);\n\tu32p_replace_bits(&dpn_frame_fmt, params->blk_pkg_mode, AMD_DPN_FRAME_FMT_BLK_PKG_MODE);\n\tu32p_replace_bits(&dpn_frame_fmt, params->blk_grp_ctrl, AMD_DPN_FRAME_FMT_BLK_GRP_CTRL);\n\tu32p_replace_bits(&dpn_frame_fmt, SDW_STREAM_PCM, AMD_DPN_FRAME_FMT_PCM_OR_PDM);\n\twritel(dpn_frame_fmt, amd_manager->mmio + frame_fmt_reg);\n\n\tdpn_sampleinterval = params->sample_interval - 1;\n\twritel(dpn_sampleinterval, amd_manager->mmio + sample_int_reg);\n\n\tdpn_hctrl = FIELD_PREP(AMD_DPN_HCTRL_HSTOP, params->hstop);\n\tdpn_hctrl |= FIELD_PREP(AMD_DPN_HCTRL_HSTART, params->hstart);\n\twritel(dpn_hctrl, amd_manager->mmio + hctrl_dp0_reg);\n\n\tdpn_offsetctrl = FIELD_PREP(AMD_DPN_OFFSET_CTRL_1, params->offset1);\n\tdpn_offsetctrl |= FIELD_PREP(AMD_DPN_OFFSET_CTRL_2, params->offset2);\n\twritel(dpn_offsetctrl, amd_manager->mmio + offset_reg);\n\n\t \n\tdpn_lanectrl = readl(amd_manager->mmio + lane_ctrl_ch_en_reg);\n\tu32p_replace_bits(&dpn_lanectrl, params->lane_ctrl, AMD_DPN_CH_EN_LCTRL);\n\twritel(dpn_lanectrl, amd_manager->mmio + lane_ctrl_ch_en_reg);\n\treturn 0;\n}\n\nstatic int amd_sdw_port_enable(struct sdw_bus *bus,\n\t\t\t       struct sdw_enable_ch *enable_ch,\n\t\t\t       unsigned int bank)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tu32 dpn_ch_enable;\n\tu32 lane_ctrl_ch_en_reg;\n\n\tswitch (amd_manager->instance) {\n\tcase ACP_SDW0:\n\t\tlane_ctrl_ch_en_reg = sdw0_manager_dp_reg[enable_ch->port_num].lane_ctrl_ch_en_reg;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tlane_ctrl_ch_en_reg = sdw1_manager_dp_reg[enable_ch->port_num].lane_ctrl_ch_en_reg;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdpn_ch_enable = readl(amd_manager->mmio + lane_ctrl_ch_en_reg);\n\tu32p_replace_bits(&dpn_ch_enable, enable_ch->ch_mask, AMD_DPN_CH_EN_CHMASK);\n\tif (enable_ch->enable)\n\t\twritel(dpn_ch_enable, amd_manager->mmio + lane_ctrl_ch_en_reg);\n\telse\n\t\twritel(0, amd_manager->mmio + lane_ctrl_ch_en_reg);\n\treturn 0;\n}\n\nstatic int sdw_master_read_amd_prop(struct sdw_bus *bus)\n{\n\tstruct amd_sdw_manager *amd_manager = to_amd_sdw(bus);\n\tstruct fwnode_handle *link;\n\tstruct sdw_master_prop *prop;\n\tu32 quirk_mask = 0;\n\tu32 wake_en_mask = 0;\n\tu32 power_mode_mask = 0;\n\tchar name[32];\n\n\tprop = &bus->prop;\n\t \n\tsnprintf(name, sizeof(name), \"mipi-sdw-link-%d-subproperties\", bus->link_id);\n\tlink = device_get_named_child_node(bus->dev, name);\n\tif (!link) {\n\t\tdev_err(bus->dev, \"Manager node %s not found\\n\", name);\n\t\treturn -EIO;\n\t}\n\tfwnode_property_read_u32(link, \"amd-sdw-enable\", &quirk_mask);\n\tif (!(quirk_mask & AMD_SDW_QUIRK_MASK_BUS_ENABLE))\n\t\tprop->hw_disabled = true;\n\tprop->quirks = SDW_MASTER_QUIRKS_CLEAR_INITIAL_CLASH |\n\t\t       SDW_MASTER_QUIRKS_CLEAR_INITIAL_PARITY;\n\n\tfwnode_property_read_u32(link, \"amd-sdw-wakeup-enable\", &wake_en_mask);\n\tamd_manager->wake_en_mask = wake_en_mask;\n\tfwnode_property_read_u32(link, \"amd-sdw-power-mode\", &power_mode_mask);\n\tamd_manager->power_mode_mask = power_mode_mask;\n\treturn 0;\n}\n\nstatic int amd_prop_read(struct sdw_bus *bus)\n{\n\tsdw_master_read_prop(bus);\n\tsdw_master_read_amd_prop(bus);\n\treturn 0;\n}\n\nstatic const struct sdw_master_port_ops amd_sdw_port_ops = {\n\t.dpn_set_port_params = amd_sdw_port_params,\n\t.dpn_set_port_transport_params = amd_sdw_transport_params,\n\t.dpn_port_enable_ch = amd_sdw_port_enable,\n};\n\nstatic const struct sdw_master_ops amd_sdw_ops = {\n\t.read_prop = amd_prop_read,\n\t.xfer_msg = amd_sdw_xfer_msg,\n\t.read_ping_status = amd_sdw_read_ping_status,\n};\n\nstatic int amd_sdw_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct amd_sdw_manager *amd_manager = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_amd_dai_runtime *dai_runtime;\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_port_config *pconfig;\n\tint ch, dir;\n\tint ret;\n\n\tdai_runtime = amd_manager->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\tch = params_channels(params);\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tdir = SDW_DATA_DIR_RX;\n\telse\n\t\tdir = SDW_DATA_DIR_TX;\n\tdev_dbg(amd_manager->dev, \"dir:%d dai->id:0x%x\\n\", dir, dai->id);\n\n\tsconfig.direction = dir;\n\tsconfig.ch_count = ch;\n\tsconfig.frame_rate = params_rate(params);\n\tsconfig.type = dai_runtime->stream_type;\n\n\tsconfig.bps = snd_pcm_format_width(params_format(params));\n\n\t \n\tpconfig = kzalloc(sizeof(*pconfig), GFP_KERNEL);\n\tif (!pconfig) {\n\t\tret =  -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpconfig->num = dai->id;\n\tpconfig->ch_mask = (1 << ch) - 1;\n\tret = sdw_stream_add_master(&amd_manager->bus, &sconfig,\n\t\t\t\t    pconfig, 1, dai_runtime->stream);\n\tif (ret)\n\t\tdev_err(amd_manager->dev, \"add manager to stream failed:%d\\n\", ret);\n\n\tkfree(pconfig);\nerror:\n\treturn ret;\n}\n\nstatic int amd_sdw_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct amd_sdw_manager *amd_manager = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_amd_dai_runtime *dai_runtime;\n\tint ret;\n\n\tdai_runtime = amd_manager->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn -EIO;\n\n\tret = sdw_stream_remove_master(&amd_manager->bus, dai_runtime->stream);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"remove manager from stream %s failed: %d\\n\",\n\t\t\tdai_runtime->stream->name, ret);\n\treturn ret;\n}\n\nstatic int amd_set_sdw_stream(struct snd_soc_dai *dai, void *stream, int direction)\n{\n\tstruct amd_sdw_manager *amd_manager = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_amd_dai_runtime *dai_runtime;\n\n\tdai_runtime = amd_manager->dai_runtime_array[dai->id];\n\tif (stream) {\n\t\t \n\t\tif (dai_runtime) {\n\t\t\tdev_err(dai->dev, \"dai_runtime already allocated for dai %s\\n\",\tdai->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tdai_runtime = kzalloc(sizeof(*dai_runtime), GFP_KERNEL);\n\t\tif (!dai_runtime)\n\t\t\treturn -ENOMEM;\n\n\t\tdai_runtime->stream_type = SDW_STREAM_PCM;\n\t\tdai_runtime->bus = &amd_manager->bus;\n\t\tdai_runtime->stream = stream;\n\t\tamd_manager->dai_runtime_array[dai->id] = dai_runtime;\n\t} else {\n\t\t \n\t\tif (!dai_runtime) {\n\t\t\tdev_err(dai->dev, \"dai_runtime not allocated for dai %s\\n\", dai->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tkfree(dai_runtime);\n\t\tamd_manager->dai_runtime_array[dai->id] = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int amd_pcm_set_sdw_stream(struct snd_soc_dai *dai, void *stream, int direction)\n{\n\treturn amd_set_sdw_stream(dai, stream, direction);\n}\n\nstatic void *amd_get_sdw_stream(struct snd_soc_dai *dai, int direction)\n{\n\tstruct amd_sdw_manager *amd_manager = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_amd_dai_runtime *dai_runtime;\n\n\tdai_runtime = amd_manager->dai_runtime_array[dai->id];\n\tif (!dai_runtime)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn dai_runtime->stream;\n}\n\nstatic const struct snd_soc_dai_ops amd_sdw_dai_ops = {\n\t.hw_params = amd_sdw_hw_params,\n\t.hw_free = amd_sdw_hw_free,\n\t.set_stream = amd_pcm_set_sdw_stream,\n\t.get_stream = amd_get_sdw_stream,\n};\n\nstatic const struct snd_soc_component_driver amd_sdw_dai_component = {\n\t.name = \"soundwire\",\n};\n\nstatic int amd_sdw_register_dais(struct amd_sdw_manager *amd_manager)\n{\n\tstruct sdw_amd_dai_runtime **dai_runtime_array;\n\tstruct snd_soc_dai_driver *dais;\n\tstruct snd_soc_pcm_stream *stream;\n\tstruct device *dev;\n\tint i, num_dais;\n\n\tdev = amd_manager->dev;\n\tnum_dais = amd_manager->num_dout_ports + amd_manager->num_din_ports;\n\tdais = devm_kcalloc(dev, num_dais, sizeof(*dais), GFP_KERNEL);\n\tif (!dais)\n\t\treturn -ENOMEM;\n\n\tdai_runtime_array = devm_kcalloc(dev, num_dais,\n\t\t\t\t\t sizeof(struct sdw_amd_dai_runtime *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!dai_runtime_array)\n\t\treturn -ENOMEM;\n\tamd_manager->dai_runtime_array = dai_runtime_array;\n\tfor (i = 0; i < num_dais; i++) {\n\t\tdais[i].name = devm_kasprintf(dev, GFP_KERNEL, \"SDW%d Pin%d\", amd_manager->instance,\n\t\t\t\t\t      i);\n\t\tif (!dais[i].name)\n\t\t\treturn -ENOMEM;\n\t\tif (i < amd_manager->num_dout_ports)\n\t\t\tstream = &dais[i].playback;\n\t\telse\n\t\t\tstream = &dais[i].capture;\n\n\t\tstream->channels_min = 2;\n\t\tstream->channels_max = 2;\n\t\tstream->rates = SNDRV_PCM_RATE_48000;\n\t\tstream->formats = SNDRV_PCM_FMTBIT_S16_LE;\n\n\t\tdais[i].ops = &amd_sdw_dai_ops;\n\t\tdais[i].id = i;\n\t}\n\n\treturn devm_snd_soc_register_component(dev, &amd_sdw_dai_component,\n\t\t\t\t\t       dais, num_dais);\n}\n\nstatic void amd_sdw_update_slave_status_work(struct work_struct *work)\n{\n\tstruct amd_sdw_manager *amd_manager =\n\t\tcontainer_of(work, struct amd_sdw_manager, amd_sdw_work);\n\tint retry_count = 0;\n\n\tif (amd_manager->status[0] == SDW_SLAVE_ATTACHED) {\n\t\twritel(0, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_MASK_0TO7);\n\t\twritel(0, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_MASK_8TO11);\n\t}\n\nupdate_status:\n\tsdw_handle_slave_status(&amd_manager->bus, amd_manager->status);\n\t \n\tif (amd_manager->status[0] == SDW_SLAVE_ATTACHED) {\n\t\tif (retry_count++ < SDW_MAX_DEVICES) {\n\t\t\twritel(AMD_SDW_IRQ_MASK_0TO7, amd_manager->mmio +\n\t\t\t       ACP_SW_STATE_CHANGE_STATUS_MASK_0TO7);\n\t\t\twritel(AMD_SDW_IRQ_MASK_8TO11, amd_manager->mmio +\n\t\t\t       ACP_SW_STATE_CHANGE_STATUS_MASK_8TO11);\n\t\t\tamd_sdw_read_and_process_ping_status(amd_manager);\n\t\t\tgoto update_status;\n\t\t} else {\n\t\t\tdev_err_ratelimited(amd_manager->dev,\n\t\t\t\t\t    \"Device0 detected after %d iterations\\n\",\n\t\t\t\t\t    retry_count);\n\t\t}\n\t}\n}\n\nstatic void amd_sdw_update_slave_status(u32 status_change_0to7, u32 status_change_8to11,\n\t\t\t\t\tstruct amd_sdw_manager *amd_manager)\n{\n\tu64 slave_stat;\n\tu32 val;\n\tint dev_index;\n\n\tif (status_change_0to7 == AMD_SDW_SLAVE_0_ATTACHED)\n\t\tmemset(amd_manager->status, 0, sizeof(amd_manager->status));\n\tslave_stat = status_change_0to7;\n\tslave_stat |= FIELD_GET(AMD_SDW_MCP_SLAVE_STATUS_8TO_11, status_change_8to11) << 32;\n\tdev_dbg(amd_manager->dev, \"status_change_0to7:0x%x status_change_8to11:0x%x\\n\",\n\t\tstatus_change_0to7, status_change_8to11);\n\tif (slave_stat) {\n\t\tfor (dev_index = 0; dev_index <= SDW_MAX_DEVICES; ++dev_index) {\n\t\t\tif (slave_stat & AMD_SDW_MCP_SLAVE_STATUS_VALID_MASK(dev_index)) {\n\t\t\t\tval = (slave_stat >> AMD_SDW_MCP_SLAVE_STAT_SHIFT_MASK(dev_index)) &\n\t\t\t\t      AMD_SDW_MCP_SLAVE_STATUS_MASK;\n\t\t\t\tamd_sdw_fill_slave_status(amd_manager, dev_index, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void amd_sdw_process_wake_event(struct amd_sdw_manager *amd_manager)\n{\n\tpm_request_resume(amd_manager->dev);\n\twritel(0x00, amd_manager->acp_mmio + ACP_SW_WAKE_EN(amd_manager->instance));\n\twritel(0x00, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_8TO11);\n}\n\nstatic void amd_sdw_irq_thread(struct work_struct *work)\n{\n\tstruct amd_sdw_manager *amd_manager =\n\t\t\tcontainer_of(work, struct amd_sdw_manager, amd_sdw_irq_thread);\n\tu32 status_change_8to11;\n\tu32 status_change_0to7;\n\n\tstatus_change_8to11 = readl(amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_8TO11);\n\tstatus_change_0to7 = readl(amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_0TO7);\n\tdev_dbg(amd_manager->dev, \"[SDW%d] SDW INT: 0to7=0x%x, 8to11=0x%x\\n\",\n\t\tamd_manager->instance, status_change_0to7, status_change_8to11);\n\tif (status_change_8to11 & AMD_SDW_WAKE_STAT_MASK)\n\t\treturn amd_sdw_process_wake_event(amd_manager);\n\n\tif (status_change_8to11 & AMD_SDW_PREQ_INTR_STAT) {\n\t\tamd_sdw_read_and_process_ping_status(amd_manager);\n\t} else {\n\t\t \n\t\tamd_sdw_update_slave_status(status_change_0to7, status_change_8to11, amd_manager);\n\t}\n\tif (status_change_8to11 || status_change_0to7)\n\t\tschedule_work(&amd_manager->amd_sdw_work);\n\twritel(0x00, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_8TO11);\n\twritel(0x00, amd_manager->mmio + ACP_SW_STATE_CHANGE_STATUS_0TO7);\n}\n\nstatic void amd_sdw_probe_work(struct work_struct *work)\n{\n\tstruct amd_sdw_manager *amd_manager = container_of(work, struct amd_sdw_manager,\n\t\t\t\t\t\t\t   probe_work);\n\tstruct sdw_master_prop *prop;\n\tint ret;\n\n\tprop = &amd_manager->bus.prop;\n\tif (!prop->hw_disabled) {\n\t\tamd_enable_sdw_pads(amd_manager);\n\t\tret = amd_init_sdw_manager(amd_manager);\n\t\tif (ret)\n\t\t\treturn;\n\t\tamd_enable_sdw_interrupts(amd_manager);\n\t\tret = amd_enable_sdw_manager(amd_manager);\n\t\tif (ret)\n\t\t\treturn;\n\t\tamd_sdw_set_frameshape(amd_manager);\n\t}\n\t \n\tpm_runtime_set_autosuspend_delay(amd_manager->dev, AMD_SDW_MASTER_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(amd_manager->dev);\n\tpm_runtime_mark_last_busy(amd_manager->dev);\n\tpm_runtime_set_active(amd_manager->dev);\n\tpm_runtime_enable(amd_manager->dev);\n}\n\nstatic int amd_sdw_manager_probe(struct platform_device *pdev)\n{\n\tconst struct acp_sdw_pdata *pdata = pdev->dev.platform_data;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdw_master_prop *prop;\n\tstruct sdw_bus_params *params;\n\tstruct amd_sdw_manager *amd_manager;\n\tint ret;\n\n\tamd_manager = devm_kzalloc(dev, sizeof(struct amd_sdw_manager), GFP_KERNEL);\n\tif (!amd_manager)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tamd_manager->acp_mmio = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!amd_manager->acp_mmio) {\n\t\tdev_err(dev, \"mmio not found\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tamd_manager->instance = pdata->instance;\n\tamd_manager->mmio = amd_manager->acp_mmio +\n\t\t\t    (amd_manager->instance * SDW_MANAGER_REG_OFFSET);\n\tamd_manager->acp_sdw_lock = pdata->acp_sdw_lock;\n\tamd_manager->cols_index = sdw_find_col_index(AMD_SDW_DEFAULT_COLUMNS);\n\tamd_manager->rows_index = sdw_find_row_index(AMD_SDW_DEFAULT_ROWS);\n\tamd_manager->dev = dev;\n\tamd_manager->bus.ops = &amd_sdw_ops;\n\tamd_manager->bus.port_ops = &amd_sdw_port_ops;\n\tamd_manager->bus.compute_params = &amd_sdw_compute_params;\n\tamd_manager->bus.clk_stop_timeout = 200;\n\tamd_manager->bus.link_id = amd_manager->instance;\n\n\tswitch (amd_manager->instance) {\n\tcase ACP_SDW0:\n\t\tamd_manager->num_dout_ports = AMD_SDW0_MAX_TX_PORTS;\n\t\tamd_manager->num_din_ports = AMD_SDW0_MAX_RX_PORTS;\n\t\tbreak;\n\tcase ACP_SDW1:\n\t\tamd_manager->num_dout_ports = AMD_SDW1_MAX_TX_PORTS;\n\t\tamd_manager->num_din_ports = AMD_SDW1_MAX_RX_PORTS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tamd_manager->reg_mask = &sdw_manager_reg_mask_array[amd_manager->instance];\n\tparams = &amd_manager->bus.params;\n\tparams->max_dr_freq = AMD_SDW_DEFAULT_CLK_FREQ * 2;\n\tparams->curr_dr_freq = AMD_SDW_DEFAULT_CLK_FREQ * 2;\n\tparams->col = AMD_SDW_DEFAULT_COLUMNS;\n\tparams->row = AMD_SDW_DEFAULT_ROWS;\n\tprop = &amd_manager->bus.prop;\n\tprop->clk_freq = &amd_sdw_freq_tbl[0];\n\tprop->mclk_freq = AMD_SDW_BUS_BASE_FREQ;\n\n\tret = sdw_bus_master_add(&amd_manager->bus, dev, dev->fwnode);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register SoundWire manager(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = amd_sdw_register_dais(amd_manager);\n\tif (ret) {\n\t\tdev_err(dev, \"CPU DAI registration failed\\n\");\n\t\tsdw_bus_master_delete(&amd_manager->bus);\n\t\treturn ret;\n\t}\n\tdev_set_drvdata(dev, amd_manager);\n\tINIT_WORK(&amd_manager->amd_sdw_irq_thread, amd_sdw_irq_thread);\n\tINIT_WORK(&amd_manager->amd_sdw_work, amd_sdw_update_slave_status_work);\n\tINIT_WORK(&amd_manager->probe_work, amd_sdw_probe_work);\n\t \n\tschedule_work(&amd_manager->probe_work);\n\treturn 0;\n}\n\nstatic void amd_sdw_manager_remove(struct platform_device *pdev)\n{\n\tstruct amd_sdw_manager *amd_manager = dev_get_drvdata(&pdev->dev);\n\tint ret;\n\n\tpm_runtime_disable(&pdev->dev);\n\tcancel_work_sync(&amd_manager->probe_work);\n\tamd_disable_sdw_interrupts(amd_manager);\n\tsdw_bus_master_delete(&amd_manager->bus);\n\tret = amd_disable_sdw_manager(amd_manager);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to disable device (%pe)\\n\", ERR_PTR(ret));\n}\n\nstatic int amd_sdw_clock_stop(struct amd_sdw_manager *amd_manager)\n{\n\tu32 val;\n\tint ret;\n\n\tret = sdw_bus_prep_clk_stop(&amd_manager->bus);\n\tif (ret < 0 && ret != -ENODATA) {\n\t\tdev_err(amd_manager->dev, \"prepare clock stop failed %d\", ret);\n\t\treturn 0;\n\t}\n\tret = sdw_bus_clk_stop(&amd_manager->bus);\n\tif (ret < 0 && ret != -ENODATA) {\n\t\tdev_err(amd_manager->dev, \"bus clock stop failed %d\", ret);\n\t\treturn 0;\n\t}\n\n\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL, val,\n\t\t\t\t (val & AMD_SDW_CLK_STOP_DONE), ACP_DELAY_US, AMD_SDW_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(amd_manager->dev, \"SDW%x clock stop failed\\n\", amd_manager->instance);\n\t\treturn 0;\n\t}\n\n\tamd_manager->clk_stopped = true;\n\tif (amd_manager->wake_en_mask)\n\t\twritel(0x01, amd_manager->acp_mmio + ACP_SW_WAKE_EN(amd_manager->instance));\n\n\tdev_dbg(amd_manager->dev, \"SDW%x clock stop successful\\n\", amd_manager->instance);\n\treturn 0;\n}\n\nstatic int amd_sdw_clock_stop_exit(struct amd_sdw_manager *amd_manager)\n{\n\tint ret;\n\tu32 val;\n\n\tif (amd_manager->clk_stopped) {\n\t\tval = readl(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\tval |= AMD_SDW_CLK_RESUME_REQ;\n\t\twritel(val, amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL, val,\n\t\t\t\t\t (val & AMD_SDW_CLK_RESUME_DONE), ACP_DELAY_US,\n\t\t\t\t\t AMD_SDW_TIMEOUT);\n\t\tif (val & AMD_SDW_CLK_RESUME_DONE) {\n\t\t\twritel(0, amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\t\tret = sdw_bus_exit_clk_stop(&amd_manager->bus);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(amd_manager->dev, \"bus failed to exit clock stop %d\\n\",\n\t\t\t\t\tret);\n\t\t\tamd_manager->clk_stopped = false;\n\t\t}\n\t}\n\tif (amd_manager->clk_stopped) {\n\t\tdev_err(amd_manager->dev, \"SDW%x clock stop exit failed\\n\", amd_manager->instance);\n\t\treturn 0;\n\t}\n\tdev_dbg(amd_manager->dev, \"SDW%x clock stop exit successful\\n\", amd_manager->instance);\n\treturn 0;\n}\n\nstatic int amd_resume_child_device(struct device *dev, void *data)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tint ret;\n\n\tif (!slave->probed) {\n\t\tdev_dbg(dev, \"skipping device, no probed driver\\n\");\n\t\treturn 0;\n\t}\n\tif (!slave->dev_num_sticky) {\n\t\tdev_dbg(dev, \"skipping device, never detected on bus\\n\");\n\t\treturn 0;\n\t}\n\tret = pm_request_resume(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_request_resume failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused amd_pm_prepare(struct device *dev)\n{\n\tstruct amd_sdw_manager *amd_manager = dev_get_drvdata(dev);\n\tstruct sdw_bus *bus = &amd_manager->bus;\n\tint ret;\n\n\tif (bus->prop.hw_disabled) {\n\t\tdev_dbg(bus->dev, \"SoundWire manager %d is disabled, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\t \n\tif (amd_manager->power_mode_mask & AMD_SDW_CLK_STOP_MODE) {\n\t\tret = pm_request_resume(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"pm_request_resume failed: %d\\n\", ret);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tret = device_for_each_child(bus->dev, NULL, amd_resume_child_device);\n\tif (ret < 0)\n\t\tdev_err(dev, \"amd_resume_child_device failed: %d\\n\", ret);\n\treturn 0;\n}\n\nstatic int __maybe_unused amd_suspend(struct device *dev)\n{\n\tstruct amd_sdw_manager *amd_manager = dev_get_drvdata(dev);\n\tstruct sdw_bus *bus = &amd_manager->bus;\n\tint ret;\n\n\tif (bus->prop.hw_disabled) {\n\t\tdev_dbg(bus->dev, \"SoundWire manager %d is disabled, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tif (amd_manager->power_mode_mask & AMD_SDW_CLK_STOP_MODE) {\n\t\treturn amd_sdw_clock_stop(amd_manager);\n\t} else if (amd_manager->power_mode_mask & AMD_SDW_POWER_OFF_MODE) {\n\t\t \n\t\tret = amd_sdw_clock_stop(amd_manager);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn amd_deinit_sdw_manager(amd_manager);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused amd_suspend_runtime(struct device *dev)\n{\n\tstruct amd_sdw_manager *amd_manager = dev_get_drvdata(dev);\n\tstruct sdw_bus *bus = &amd_manager->bus;\n\tint ret;\n\n\tif (bus->prop.hw_disabled) {\n\t\tdev_dbg(bus->dev, \"SoundWire manager %d is disabled,\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\tif (amd_manager->power_mode_mask & AMD_SDW_CLK_STOP_MODE) {\n\t\treturn amd_sdw_clock_stop(amd_manager);\n\t} else if (amd_manager->power_mode_mask & AMD_SDW_POWER_OFF_MODE) {\n\t\tret = amd_sdw_clock_stop(amd_manager);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn amd_deinit_sdw_manager(amd_manager);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused amd_resume_runtime(struct device *dev)\n{\n\tstruct amd_sdw_manager *amd_manager = dev_get_drvdata(dev);\n\tstruct sdw_bus *bus = &amd_manager->bus;\n\tint ret;\n\tu32 val;\n\n\tif (bus->prop.hw_disabled) {\n\t\tdev_dbg(bus->dev, \"SoundWire manager %d is disabled, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tif (amd_manager->power_mode_mask & AMD_SDW_CLK_STOP_MODE) {\n\t\treturn amd_sdw_clock_stop_exit(amd_manager);\n\t} else if (amd_manager->power_mode_mask & AMD_SDW_POWER_OFF_MODE) {\n\t\tval = readl(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\tif (val) {\n\t\t\tval |= AMD_SDW_CLK_RESUME_REQ;\n\t\t\twritel(val, amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\t\tret = readl_poll_timeout(amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL, val,\n\t\t\t\t\t\t (val & AMD_SDW_CLK_RESUME_DONE), ACP_DELAY_US,\n\t\t\t\t\t\t AMD_SDW_TIMEOUT);\n\t\t\tif (val & AMD_SDW_CLK_RESUME_DONE) {\n\t\t\t\twritel(0, amd_manager->mmio + ACP_SW_CLK_RESUME_CTRL);\n\t\t\t\tamd_manager->clk_stopped = false;\n\t\t\t}\n\t\t}\n\t\tsdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);\n\t\tamd_init_sdw_manager(amd_manager);\n\t\tamd_enable_sdw_interrupts(amd_manager);\n\t\tret = amd_enable_sdw_manager(amd_manager);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tamd_sdw_set_frameshape(amd_manager);\n\t}\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops amd_pm = {\n\t.prepare = amd_pm_prepare,\n\tSET_SYSTEM_SLEEP_PM_OPS(amd_suspend, amd_resume_runtime)\n\tSET_RUNTIME_PM_OPS(amd_suspend_runtime, amd_resume_runtime, NULL)\n};\n\nstatic struct platform_driver amd_sdw_driver = {\n\t.probe\t= &amd_sdw_manager_probe,\n\t.remove_new = &amd_sdw_manager_remove,\n\t.driver = {\n\t\t.name\t= \"amd_sdw_manager\",\n\t\t.pm = &amd_pm,\n\t}\n};\nmodule_platform_driver(amd_sdw_driver);\n\nMODULE_AUTHOR(\"Vijendar.Mukunda@amd.com\");\nMODULE_DESCRIPTION(\"AMD SoundWire driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}