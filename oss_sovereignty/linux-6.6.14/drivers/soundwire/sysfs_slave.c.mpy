{
  "module_name": "sysfs_slave.c",
  "hash_id": "44c771fb433d66fc6ec40a2054c18c7812f923c2af3d39b9fbd1d64aebdc8c81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/sysfs_slave.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include \"bus.h\"\n#include \"sysfs_local.h\"\n\n \n\n \n\n#define sdw_slave_attr(field, format_string)\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t    char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\t\t\\\n\treturn sprintf(buf, format_string, slave->prop.field);\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nsdw_slave_attr(mipi_revision, \"0x%x\\n\");\nsdw_slave_attr(wake_capable, \"%d\\n\");\nsdw_slave_attr(test_mode_capable, \"%d\\n\");\nsdw_slave_attr(clk_stop_mode1, \"%d\\n\");\nsdw_slave_attr(simple_clk_stop_capable, \"%d\\n\");\nsdw_slave_attr(clk_stop_timeout, \"%d\\n\");\nsdw_slave_attr(ch_prep_timeout, \"%d\\n\");\nsdw_slave_attr(reset_behave, \"%d\\n\");\nsdw_slave_attr(high_PHY_capable, \"%d\\n\");\nsdw_slave_attr(paging_support, \"%d\\n\");\nsdw_slave_attr(bank_delay_support, \"%d\\n\");\nsdw_slave_attr(p15_behave, \"%d\\n\");\nsdw_slave_attr(master_count, \"%d\\n\");\nsdw_slave_attr(source_ports, \"0x%x\\n\");\nsdw_slave_attr(sink_ports, \"0x%x\\n\");\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\n\treturn sdw_slave_modalias(slave, buf, 256);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *slave_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(slave);\n\nstatic struct attribute *slave_dev_attrs[] = {\n\t&dev_attr_mipi_revision.attr,\n\t&dev_attr_wake_capable.attr,\n\t&dev_attr_test_mode_capable.attr,\n\t&dev_attr_clk_stop_mode1.attr,\n\t&dev_attr_simple_clk_stop_capable.attr,\n\t&dev_attr_clk_stop_timeout.attr,\n\t&dev_attr_ch_prep_timeout.attr,\n\t&dev_attr_reset_behave.attr,\n\t&dev_attr_high_PHY_capable.attr,\n\t&dev_attr_paging_support.attr,\n\t&dev_attr_bank_delay_support.attr,\n\t&dev_attr_p15_behave.attr,\n\t&dev_attr_master_count.attr,\n\t&dev_attr_source_ports.attr,\n\t&dev_attr_sink_ports.attr,\n\tNULL,\n};\n\n \nstatic const struct attribute_group sdw_slave_dev_attr_group = {\n\t.attrs\t= slave_dev_attrs,\n\t.name = \"dev-properties\",\n};\n\n \n\n#define sdw_dp0_attr(field, format_string)\t\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr,\t\t\\\n\t\t\t    char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\t\t\t\\\n\treturn sprintf(buf, format_string, slave->prop.dp0_prop->field);\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nsdw_dp0_attr(max_word, \"%d\\n\");\nsdw_dp0_attr(min_word, \"%d\\n\");\nsdw_dp0_attr(BRA_flow_controlled, \"%d\\n\");\nsdw_dp0_attr(simple_ch_prep_sm, \"%d\\n\");\nsdw_dp0_attr(imp_def_interrupts, \"0x%x\\n\");\n\nstatic ssize_t words_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tssize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < slave->prop.dp0_prop->num_words; i++)\n\t\tsize += sprintf(buf + size, \"%d \",\n\t\t\t\tslave->prop.dp0_prop->words[i]);\n\tsize += sprintf(buf + size, \"\\n\");\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RO(words);\n\nstatic struct attribute *dp0_attrs[] = {\n\t&dev_attr_max_word.attr,\n\t&dev_attr_min_word.attr,\n\t&dev_attr_words.attr,\n\t&dev_attr_BRA_flow_controlled.attr,\n\t&dev_attr_simple_ch_prep_sm.attr,\n\t&dev_attr_imp_def_interrupts.attr,\n\tNULL,\n};\n\n \nstatic const struct attribute_group dp0_group = {\n\t.attrs = dp0_attrs,\n\t.name = \"dp0\",\n};\n\nint sdw_slave_sysfs_init(struct sdw_slave *slave)\n{\n\tint ret;\n\n\tret = devm_device_add_groups(&slave->dev, slave_groups);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_device_add_group(&slave->dev, &sdw_slave_dev_attr_group);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (slave->prop.dp0_prop) {\n\t\tret = devm_device_add_group(&slave->dev, &dp0_group);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (slave->prop.source_ports || slave->prop.sink_ports) {\n\t\tret = sdw_slave_sysfs_dpn_init(slave);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const char *const slave_status[] = {\n\t[SDW_SLAVE_UNATTACHED] =  \"UNATTACHED\",\n\t[SDW_SLAVE_ATTACHED] = \"Attached\",\n\t[SDW_SLAVE_ALERT] = \"Alert\",\n\t[SDW_SLAVE_RESERVED] = \"RESERVED\",\n};\n\nstatic ssize_t status_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\n\treturn sprintf(buf, \"%s\\n\", slave_status[slave->status]);\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t device_number_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\n\tif (slave->status == SDW_SLAVE_UNATTACHED)\n\t\treturn sprintf(buf, \"%s\", \"N/A\");\n\telse\n\t\treturn sprintf(buf, \"%d\", slave->dev_num);\n}\nstatic DEVICE_ATTR_RO(device_number);\n\nstatic struct attribute *slave_status_attrs[] = {\n\t&dev_attr_status.attr,\n\t&dev_attr_device_number.attr,\n\tNULL,\n};\n\n \nstatic const struct attribute_group sdw_slave_status_attr_group = {\n\t.attrs\t= slave_status_attrs,\n};\n\nconst struct attribute_group *sdw_slave_status_attr_groups[] = {\n\t&sdw_slave_status_attr_group,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}