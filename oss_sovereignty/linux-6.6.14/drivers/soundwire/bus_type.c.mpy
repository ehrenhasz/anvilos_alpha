{
  "module_name": "bus_type.c",
  "hash_id": "e02b599fdd909475821f45fca9edfb8f3126d9bf10abee1b21759b798795f324",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/bus_type.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_domain.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include \"bus.h\"\n#include \"irq.h\"\n#include \"sysfs_local.h\"\n\n \nstatic const struct sdw_device_id *\nsdw_get_device_id(struct sdw_slave *slave, struct sdw_driver *drv)\n{\n\tconst struct sdw_device_id *id;\n\n\tfor (id = drv->id_table; id && id->mfg_id; id++)\n\t\tif (slave->id.mfg_id == id->mfg_id &&\n\t\t    slave->id.part_id == id->part_id  &&\n\t\t    (!id->sdw_version ||\n\t\t     slave->id.sdw_version == id->sdw_version) &&\n\t\t    (!id->class_id ||\n\t\t     slave->id.class_id == id->class_id))\n\t\t\treturn id;\n\n\treturn NULL;\n}\n\nstatic int sdw_bus_match(struct device *dev, struct device_driver *ddrv)\n{\n\tstruct sdw_slave *slave;\n\tstruct sdw_driver *drv;\n\tint ret = 0;\n\n\tif (is_sdw_slave(dev)) {\n\t\tslave = dev_to_sdw_dev(dev);\n\t\tdrv = drv_to_sdw_driver(ddrv);\n\n\t\tret = !!sdw_get_device_id(slave, drv);\n\t}\n\treturn ret;\n}\n\nint sdw_slave_modalias(const struct sdw_slave *slave, char *buf, size_t size)\n{\n\t \n\n\treturn snprintf(buf, size, \"sdw:m%04Xp%04Xv%02Xc%02X\\n\",\n\t\t\tslave->id.mfg_id, slave->id.part_id,\n\t\t\tslave->id.sdw_version, slave->id.class_id);\n}\n\nint sdw_slave_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tchar modalias[32];\n\n\tsdw_slave_modalias(slave, modalias, sizeof(modalias));\n\n\tif (add_uevent_var(env, \"MODALIAS=%s\", modalias))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct bus_type sdw_bus_type = {\n\t.name = \"soundwire\",\n\t.match = sdw_bus_match,\n};\nEXPORT_SYMBOL_GPL(sdw_bus_type);\n\nstatic int sdw_drv_probe(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\tconst struct sdw_device_id *id;\n\tconst char *name;\n\tint ret;\n\n\t \n\tif (!dev->fwnode)\n\t\treturn -ENODEV;\n\n\tif (!IS_ENABLED(CONFIG_ACPI) && !dev->of_node)\n\t\treturn -ENODEV;\n\n\tid = sdw_get_device_id(slave, drv);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tret = dev_pm_domain_attach(dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drv->probe(slave, id);\n\tif (ret) {\n\t\tname = drv->name;\n\t\tif (!name)\n\t\t\tname = drv->driver.name;\n\n\t\tdev_err(dev, \"Probe of %s failed: %d\\n\", name, ret);\n\t\tdev_pm_domain_detach(dev, false);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&slave->sdw_dev_lock);\n\n\t \n\tif (drv->ops && drv->ops->read_prop)\n\t\tdrv->ops->read_prop(slave);\n\n\tif (slave->prop.use_domain_irq)\n\t\tsdw_irq_create_mapping(slave);\n\n\t \n\tret = sdw_slave_sysfs_init(slave);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"Slave sysfs init failed:%d\\n\", ret);\n\n\t \n\tif (slave->prop.clk_stop_timeout == 0)\n\t\tslave->prop.clk_stop_timeout = 300;\n\n\tslave->bus->clk_stop_timeout = max_t(u32, slave->bus->clk_stop_timeout,\n\t\t\t\t\t     slave->prop.clk_stop_timeout);\n\n\tslave->probed = true;\n\n\t \n\tif (drv->ops && drv->ops->update_status) {\n\t\tret = drv->ops->update_status(slave, slave->status);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"%s: update_status failed with status %d\\n\", __func__, ret);\n\t}\n\n\tmutex_unlock(&slave->sdw_dev_lock);\n\n\tdev_dbg(dev, \"probe complete\\n\");\n\n\treturn 0;\n}\n\nstatic int sdw_drv_remove(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\tint ret = 0;\n\n\tmutex_lock(&slave->sdw_dev_lock);\n\n\tslave->probed = false;\n\n\tif (slave->prop.use_domain_irq)\n\t\tsdw_irq_dispose_mapping(slave);\n\n\tmutex_unlock(&slave->sdw_dev_lock);\n\n\tif (drv->remove)\n\t\tret = drv->remove(slave);\n\n\tdev_pm_domain_detach(dev, false);\n\n\treturn ret;\n}\n\nstatic void sdw_drv_shutdown(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(slave);\n}\n\n \nint __sdw_register_driver(struct sdw_driver *drv, struct module *owner)\n{\n\tconst char *name;\n\n\tdrv->driver.bus = &sdw_bus_type;\n\n\tif (!drv->probe) {\n\t\tname = drv->name;\n\t\tif (!name)\n\t\t\tname = drv->driver.name;\n\n\t\tpr_err(\"driver %s didn't provide SDW probe routine\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tdrv->driver.owner = owner;\n\tdrv->driver.probe = sdw_drv_probe;\n\tdrv->driver.remove = sdw_drv_remove;\n\tdrv->driver.shutdown = sdw_drv_shutdown;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__sdw_register_driver);\n\n \nvoid sdw_unregister_driver(struct sdw_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(sdw_unregister_driver);\n\nstatic int __init sdw_bus_init(void)\n{\n\tsdw_debugfs_init();\n\treturn bus_register(&sdw_bus_type);\n}\n\nstatic void __exit sdw_bus_exit(void)\n{\n\tsdw_debugfs_exit();\n\tbus_unregister(&sdw_bus_type);\n}\n\npostcore_initcall(sdw_bus_init);\nmodule_exit(sdw_bus_exit);\n\nMODULE_DESCRIPTION(\"SoundWire bus\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}