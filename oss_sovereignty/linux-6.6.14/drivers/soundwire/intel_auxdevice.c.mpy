{
  "module_name": "intel_auxdevice.c",
  "hash_id": "3039f375c08ae2bab44cc8b4a88fbd0c1d68fefbfe69a767b9e309a07c95f777",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/intel_auxdevice.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/auxiliary_bus.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_intel.h>\n#include \"cadence_master.h\"\n#include \"bus.h\"\n#include \"intel.h\"\n#include \"intel_auxdevice.h\"\n\n#define INTEL_MASTER_SUSPEND_DELAY_MS\t3000\n\n \n\n#define SDW_INTEL_MASTER_DISABLE_PM_RUNTIME\t\tBIT(0)\n#define SDW_INTEL_MASTER_DISABLE_CLOCK_STOP\t\tBIT(1)\n#define SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE\tBIT(2)\n#define SDW_INTEL_MASTER_DISABLE_MULTI_LINK\t\tBIT(3)\n\nstatic int md_flags;\nmodule_param_named(sdw_md_flags, md_flags, int, 0444);\nMODULE_PARM_DESC(sdw_md_flags, \"SoundWire Intel Master device flags (0x0 all off)\");\n\nstruct wake_capable_part {\n\tconst u16 mfg_id;\n\tconst u16 part_id;\n};\n\nstatic struct wake_capable_part wake_capable_list[] = {\n\t{0x025d, 0x5682},\n\t{0x025d, 0x700},\n\t{0x025d, 0x711},\n\t{0x025d, 0x1712},\n\t{0x025d, 0x1713},\n\t{0x025d, 0x1716},\n\t{0x025d, 0x1717},\n\t{0x025d, 0x712},\n\t{0x025d, 0x713},\n\t{0x025d, 0x714},\n\t{0x025d, 0x715},\n\t{0x025d, 0x716},\n\t{0x025d, 0x717},\n\t{0x025d, 0x722},\n};\n\nstatic bool is_wake_capable(struct sdw_slave *slave)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wake_capable_list); i++)\n\t\tif (slave->id.part_id == wake_capable_list[i].part_id &&\n\t\t    slave->id.mfg_id == wake_capable_list[i].mfg_id)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int generic_pre_bank_switch(struct sdw_bus *bus)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\n\treturn sdw->link_res->hw_ops->pre_bank_switch(sdw);\n}\n\nstatic int generic_post_bank_switch(struct sdw_bus *bus)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\n\treturn sdw->link_res->hw_ops->post_bank_switch(sdw);\n}\n\nstatic void generic_new_peripheral_assigned(struct sdw_bus *bus,\n\t\t\t\t\t    struct sdw_slave *slave,\n\t\t\t\t\t    int dev_num)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tint dev_num_min;\n\tint dev_num_max;\n\tbool wake_capable = slave->prop.wake_capable || is_wake_capable(slave);\n\n\tif (wake_capable) {\n\t\tdev_num_min = SDW_INTEL_DEV_NUM_IDA_MIN;\n\t\tdev_num_max = SDW_MAX_DEVICES;\n\t} else {\n\t\tdev_num_min = 1;\n\t\tdev_num_max = SDW_INTEL_DEV_NUM_IDA_MIN - 1;\n\t}\n\n\t \n\tif (dev_num < dev_num_min || dev_num > dev_num_max)  {\n\t\tdev_err(bus->dev, \"%s: invalid dev_num %d, wake supported %d\\n\",\n\t\t\t__func__, dev_num, slave->prop.wake_capable);\n\t\treturn;\n\t}\n\n\tif (sdw->link_res->hw_ops->program_sdi && wake_capable)\n\t\tsdw->link_res->hw_ops->program_sdi(sdw, dev_num);\n}\n\nstatic int sdw_master_read_intel_prop(struct sdw_bus *bus)\n{\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tstruct fwnode_handle *link;\n\tchar name[32];\n\tu32 quirk_mask;\n\n\t \n\tsnprintf(name, sizeof(name),\n\t\t \"mipi-sdw-link-%d-subproperties\", bus->link_id);\n\n\tlink = device_get_named_child_node(bus->dev, name);\n\tif (!link) {\n\t\tdev_err(bus->dev, \"Master node %s not found\\n\", name);\n\t\treturn -EIO;\n\t}\n\n\tfwnode_property_read_u32(link,\n\t\t\t\t \"intel-sdw-ip-clock\",\n\t\t\t\t &prop->mclk_freq);\n\n\t \n\tprop->mclk_freq /= 2;\n\n\tfwnode_property_read_u32(link,\n\t\t\t\t \"intel-quirk-mask\",\n\t\t\t\t &quirk_mask);\n\n\tif (quirk_mask & SDW_INTEL_QUIRK_MASK_BUS_DISABLE)\n\t\tprop->hw_disabled = true;\n\n\tprop->quirks = SDW_MASTER_QUIRKS_CLEAR_INITIAL_CLASH |\n\t\tSDW_MASTER_QUIRKS_CLEAR_INITIAL_PARITY;\n\n\treturn 0;\n}\n\nstatic int intel_prop_read(struct sdw_bus *bus)\n{\n\t \n\tsdw_master_read_prop(bus);\n\n\t \n\tsdw_master_read_intel_prop(bus);\n\n\treturn 0;\n}\n\nstatic DEFINE_IDA(intel_peripheral_ida);\n\nstatic int intel_get_device_num_ida(struct sdw_bus *bus, struct sdw_slave *slave)\n{\n\tint bit;\n\n\tif (slave->prop.wake_capable || is_wake_capable(slave))\n\t\treturn ida_alloc_range(&intel_peripheral_ida,\n\t\t\t\t       SDW_INTEL_DEV_NUM_IDA_MIN, SDW_MAX_DEVICES,\n\t\t\t\t       GFP_KERNEL);\n\n\tbit = find_first_zero_bit(slave->bus->assigned, SDW_MAX_DEVICES);\n\tif (bit == SDW_MAX_DEVICES)\n\t\treturn -ENODEV;\n\n\treturn bit;\n}\n\nstatic void intel_put_device_num_ida(struct sdw_bus *bus, struct sdw_slave *slave)\n{\n\tif (slave->prop.wake_capable || is_wake_capable(slave))\n\t\tida_free(&intel_peripheral_ida, slave->dev_num);\n}\n\nstatic struct sdw_master_ops sdw_intel_ops = {\n\t.read_prop = intel_prop_read,\n\t.override_adr = sdw_dmi_override_adr,\n\t.xfer_msg = cdns_xfer_msg,\n\t.xfer_msg_defer = cdns_xfer_msg_defer,\n\t.set_bus_conf = cdns_bus_conf,\n\t.pre_bank_switch = generic_pre_bank_switch,\n\t.post_bank_switch = generic_post_bank_switch,\n\t.read_ping_status = cdns_read_ping_status,\n\t.get_device_num =  intel_get_device_num_ida,\n\t.put_device_num = intel_put_device_num_ida,\n\t.new_peripheral_assigned = generic_new_peripheral_assigned,\n};\n\n \nstatic int intel_link_probe(struct auxiliary_device *auxdev,\n\t\t\t    const struct auxiliary_device_id *aux_dev_id)\n\n{\n\tstruct device *dev = &auxdev->dev;\n\tstruct sdw_intel_link_dev *ldev = auxiliary_dev_to_sdw_intel_link_dev(auxdev);\n\tstruct sdw_intel *sdw;\n\tstruct sdw_cdns *cdns;\n\tstruct sdw_bus *bus;\n\tint ret;\n\n\tsdw = devm_kzalloc(dev, sizeof(*sdw), GFP_KERNEL);\n\tif (!sdw)\n\t\treturn -ENOMEM;\n\n\tcdns = &sdw->cdns;\n\tbus = &cdns->bus;\n\n\tsdw->instance = auxdev->id;\n\tsdw->link_res = &ldev->link_res;\n\tcdns->dev = dev;\n\tcdns->registers = sdw->link_res->registers;\n\tcdns->ip_offset = sdw->link_res->ip_offset;\n\tcdns->instance = sdw->instance;\n\tcdns->msg_count = 0;\n\n\tbus->link_id = auxdev->id;\n\tbus->clk_stop_timeout = 1;\n\n\tsdw_cdns_probe(cdns);\n\n\t \n\tbus->ops = &sdw_intel_ops;\n\n\t \n\tauxiliary_set_drvdata(auxdev, cdns);\n\n\t \n\tsdw->cdns.bus.compute_params = sdw_compute_params;\n\n\t \n\tdev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND);\n\n\tret = sdw_bus_master_add(bus, dev, dev->fwnode);\n\tif (ret) {\n\t\tdev_err(dev, \"sdw_bus_master_add fail: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (bus->prop.hw_disabled)\n\t\tdev_info(dev,\n\t\t\t \"SoundWire master %d is disabled, will be ignored\\n\",\n\t\t\t bus->link_id);\n\t \n\tbus->prop.err_threshold = 0;\n\n\treturn 0;\n}\n\nint intel_link_startup(struct auxiliary_device *auxdev)\n{\n\tstruct device *dev = &auxdev->dev;\n\tstruct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tint link_flags;\n\tbool multi_link;\n\tu32 clock_stop_quirks;\n\tint ret;\n\n\tif (bus->prop.hw_disabled) {\n\t\tdev_info(dev,\n\t\t\t \"SoundWire master %d is disabled, ignoring\\n\",\n\t\t\t sdw->instance);\n\t\treturn 0;\n\t}\n\n\tlink_flags = md_flags >> (bus->link_id * 8);\n\tmulti_link = !(link_flags & SDW_INTEL_MASTER_DISABLE_MULTI_LINK);\n\tif (!multi_link) {\n\t\tdev_dbg(dev, \"Multi-link is disabled\\n\");\n\t} else {\n\t\t \n\t\tbus->hw_sync_min_links = 1;\n\t}\n\tbus->multi_link = multi_link;\n\n\t \n\tret = sdw_intel_link_power_up(sdw);\n\tif (ret)\n\t\tgoto err_init;\n\n\t \n\tret = sdw_intel_register_dai(sdw);\n\tif (ret) {\n\t\tdev_err(dev, \"DAI registration failed: %d\\n\", ret);\n\t\tgoto err_power_up;\n\t}\n\n\tsdw_intel_debugfs_init(sdw);\n\n\t \n\tif (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME)) {\n\t\tpm_runtime_set_autosuspend_delay(dev,\n\t\t\t\t\t\t INTEL_MASTER_SUSPEND_DELAY_MS);\n\t\tpm_runtime_use_autosuspend(dev);\n\t\tpm_runtime_mark_last_busy(dev);\n\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\n\t\tpm_runtime_resume(bus->dev);\n\t}\n\n\t \n\tret = sdw_intel_start_bus(sdw);\n\tif (ret) {\n\t\tdev_err(dev, \"bus start failed: %d\\n\", ret);\n\t\tgoto err_pm_runtime;\n\t}\n\n\tclock_stop_quirks = sdw->link_res->clock_stop_quirks;\n\tif (clock_stop_quirks & SDW_INTEL_CLK_STOP_NOT_ALLOWED) {\n\t\t \n\t\tpm_runtime_get_noresume(dev);\n\t}\n\n\t \n\tif (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE)) {\n\t\tpm_runtime_mark_last_busy(bus->dev);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_idle(dev);\n\t}\n\n\tsdw->startup_done = true;\n\treturn 0;\n\nerr_pm_runtime:\n\tif (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME))\n\t\tpm_runtime_disable(dev);\nerr_power_up:\n\tsdw_intel_link_power_down(sdw);\nerr_init:\n\treturn ret;\n}\n\nstatic void intel_link_remove(struct auxiliary_device *auxdev)\n{\n\tstruct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\n\t \n\tif (!bus->prop.hw_disabled) {\n\t\tsdw_intel_debugfs_exit(sdw);\n\t\tsdw_cdns_enable_interrupt(cdns, false);\n\t}\n\tsdw_bus_master_delete(bus);\n}\n\nint intel_link_process_wakeen_event(struct auxiliary_device *auxdev)\n{\n\tstruct device *dev = &auxdev->dev;\n\tstruct sdw_intel *sdw;\n\tstruct sdw_bus *bus;\n\n\tsdw = auxiliary_get_drvdata(auxdev);\n\tbus = &sdw->cdns.bus;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tif (!sdw_intel_shim_check_wake(sdw))\n\t\treturn 0;\n\n\t \n\tsdw_intel_shim_wake(sdw, false);\n\n\t \n\tpm_request_resume(dev);\n\n\treturn 0;\n}\n\n \n\nstatic int intel_resume_child_device(struct device *dev, void *data)\n{\n\tint ret;\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\n\tif (!slave->probed) {\n\t\tdev_dbg(dev, \"skipping device, no probed driver\\n\");\n\t\treturn 0;\n\t}\n\tif (!slave->dev_num_sticky) {\n\t\tdev_dbg(dev, \"skipping device, never detected on bus\\n\");\n\t\treturn 0;\n\t}\n\n\tret = pm_request_resume(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: pm_request_resume failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_pm_prepare(struct device *dev)\n{\n\tstruct sdw_cdns *cdns = dev_get_drvdata(dev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tu32 clock_stop_quirks;\n\tint ret;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tclock_stop_quirks = sdw->link_res->clock_stop_quirks;\n\n\tif (pm_runtime_suspended(dev) &&\n\t    pm_runtime_suspended(dev->parent) &&\n\t    ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||\n\t     !clock_stop_quirks)) {\n\t\t \n\n\t\t \n\n\t\t \n\t\tret = pm_request_resume(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: pm_request_resume failed: %d\\n\", __func__, ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret = device_for_each_child(bus->dev, NULL, intel_resume_child_device);\n\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"%s: intel_resume_child_device failed: %d\\n\", __func__, ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_suspend(struct device *dev)\n{\n\tstruct sdw_cdns *cdns = dev_get_drvdata(dev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tu32 clock_stop_quirks;\n\tint ret;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tdev_dbg(dev, \"pm_runtime status: suspended\\n\");\n\n\t\tclock_stop_quirks = sdw->link_res->clock_stop_quirks;\n\n\t\tif ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||\n\t\t    !clock_stop_quirks) {\n\n\t\t\tif (pm_runtime_suspended(dev->parent)) {\n\t\t\t\t \n\t\t\t\tdev_err(dev, \"%s: invalid config: parent is suspended\\n\", __func__);\n\t\t\t} else {\n\t\t\t\tsdw_intel_shim_wake(sdw, false);\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret = sdw_intel_stop_bus(sdw, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: cannot stop bus: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_suspend_runtime(struct device *dev)\n{\n\tstruct sdw_cdns *cdns = dev_get_drvdata(dev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tu32 clock_stop_quirks;\n\tint ret;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tclock_stop_quirks = sdw->link_res->clock_stop_quirks;\n\n\tif (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {\n\t\tret = sdw_intel_stop_bus(sdw, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot stop bus during teardown: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET || !clock_stop_quirks) {\n\t\tret = sdw_intel_stop_bus(sdw, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot stop bus during clock_stop: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"%s clock_stop_quirks %x unsupported\\n\",\n\t\t\t__func__, clock_stop_quirks);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused intel_resume(struct device *dev)\n{\n\tstruct sdw_cdns *cdns = dev_get_drvdata(dev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tint link_flags;\n\tint ret;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\tlink_flags = md_flags >> (bus->link_id * 8);\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tdev_dbg(dev, \"pm_runtime status was suspended, forcing active\\n\");\n\n\t\t \n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_enable(dev);\n\n\t\tpm_runtime_resume(bus->dev);\n\n\t\tlink_flags = md_flags >> (bus->link_id * 8);\n\n\t\tif (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE))\n\t\t\tpm_runtime_idle(dev);\n\t}\n\n\tret = sdw_intel_link_power_up(sdw);\n\tif (ret) {\n\t\tdev_err(dev, \"%s failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);\n\n\tret = sdw_intel_start_bus(sdw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot start bus during resume\\n\");\n\t\tsdw_intel_link_power_down(sdw);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_mark_last_busy(bus->dev);\n\tpm_runtime_mark_last_busy(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_resume_runtime(struct device *dev)\n{\n\tstruct sdw_cdns *cdns = dev_get_drvdata(dev);\n\tstruct sdw_intel *sdw = cdns_to_intel(cdns);\n\tstruct sdw_bus *bus = &cdns->bus;\n\tu32 clock_stop_quirks;\n\tint ret;\n\n\tif (bus->prop.hw_disabled || !sdw->startup_done) {\n\t\tdev_dbg(dev, \"SoundWire master %d is disabled or not-started, ignoring\\n\",\n\t\t\tbus->link_id);\n\t\treturn 0;\n\t}\n\n\t \n\tsdw_intel_shim_wake(sdw, false);\n\n\tclock_stop_quirks = sdw->link_res->clock_stop_quirks;\n\n\tif (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {\n\t\tret = sdw_intel_link_power_up(sdw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: power_up failed after teardown: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tsdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);\n\n\t\tret = sdw_intel_start_bus(sdw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot start bus after teardown: %d\\n\", __func__, ret);\n\t\t\tsdw_intel_link_power_down(sdw);\n\t\t\treturn ret;\n\t\t}\n\n\t} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) {\n\t\tret = sdw_intel_link_power_up(sdw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: power_up failed after bus reset: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_intel_start_bus_after_reset(sdw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot start bus after reset: %d\\n\", __func__, ret);\n\t\t\tsdw_intel_link_power_down(sdw);\n\t\t\treturn ret;\n\t\t}\n\t} else if (!clock_stop_quirks) {\n\n\t\tsdw_intel_check_clock_stop(sdw);\n\n\t\tret = sdw_intel_link_power_up(sdw);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: power_up failed: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_intel_start_bus_after_clock_stop(sdw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot start bus after clock stop: %d\\n\", __func__, ret);\n\t\t\tsdw_intel_link_power_down(sdw);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"%s: clock_stop_quirks %x unsupported\\n\",\n\t\t\t__func__, clock_stop_quirks);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops intel_pm = {\n\t.prepare = intel_pm_prepare,\n\tSET_SYSTEM_SLEEP_PM_OPS(intel_suspend, intel_resume)\n\tSET_RUNTIME_PM_OPS(intel_suspend_runtime, intel_resume_runtime, NULL)\n};\n\nstatic const struct auxiliary_device_id intel_link_id_table[] = {\n\t{ .name = \"soundwire_intel.link\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, intel_link_id_table);\n\nstatic struct auxiliary_driver sdw_intel_drv = {\n\t.probe = intel_link_probe,\n\t.remove = intel_link_remove,\n\t.driver = {\n\t\t \n\t\t.pm = &intel_pm,\n\t},\n\t.id_table = intel_link_id_table\n};\nmodule_auxiliary_driver(sdw_intel_drv);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Intel Soundwire Link Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}