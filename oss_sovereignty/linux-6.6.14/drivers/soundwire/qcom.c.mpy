{
  "module_name": "qcom.c",
  "hash_id": "7ae9801776c2904358dbe018bfed03a6099dffb4dd2a916649cacb2ec82121c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/qcom.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/slimbus.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"bus.h\"\n\n#define SWRM_COMP_SW_RESET\t\t\t\t\t0x008\n#define SWRM_COMP_STATUS\t\t\t\t\t0x014\n#define SWRM_LINK_MANAGER_EE\t\t\t\t\t0x018\n#define SWRM_EE_CPU\t\t\t\t\t\t1\n#define SWRM_FRM_GEN_ENABLED\t\t\t\t\tBIT(0)\n#define SWRM_VERSION_1_3_0\t\t\t\t\t0x01030000\n#define SWRM_VERSION_1_5_1\t\t\t\t\t0x01050001\n#define SWRM_VERSION_1_7_0\t\t\t\t\t0x01070000\n#define SWRM_VERSION_2_0_0\t\t\t\t\t0x02000000\n#define SWRM_COMP_HW_VERSION\t\t\t\t\t0x00\n#define SWRM_COMP_CFG_ADDR\t\t\t\t\t0x04\n#define SWRM_COMP_CFG_IRQ_LEVEL_OR_PULSE_MSK\t\t\tBIT(1)\n#define SWRM_COMP_CFG_ENABLE_MSK\t\t\t\tBIT(0)\n#define SWRM_COMP_PARAMS\t\t\t\t\t0x100\n#define SWRM_COMP_PARAMS_WR_FIFO_DEPTH\t\t\t\tGENMASK(14, 10)\n#define SWRM_COMP_PARAMS_RD_FIFO_DEPTH\t\t\t\tGENMASK(19, 15)\n#define SWRM_COMP_PARAMS_DOUT_PORTS_MASK\t\t\tGENMASK(4, 0)\n#define SWRM_COMP_PARAMS_DIN_PORTS_MASK\t\t\t\tGENMASK(9, 5)\n#define SWRM_COMP_MASTER_ID\t\t\t\t\t0x104\n#define SWRM_V1_3_INTERRUPT_STATUS\t\t\t\t0x200\n#define SWRM_V2_0_INTERRUPT_STATUS\t\t\t\t0x5000\n#define SWRM_INTERRUPT_STATUS_RMSK\t\t\t\tGENMASK(16, 0)\n#define SWRM_INTERRUPT_STATUS_SLAVE_PEND_IRQ\t\t\tBIT(0)\n#define SWRM_INTERRUPT_STATUS_NEW_SLAVE_ATTACHED\t\tBIT(1)\n#define SWRM_INTERRUPT_STATUS_CHANGE_ENUM_SLAVE_STATUS\t\tBIT(2)\n#define SWRM_INTERRUPT_STATUS_MASTER_CLASH_DET\t\t\tBIT(3)\n#define SWRM_INTERRUPT_STATUS_RD_FIFO_OVERFLOW\t\t\tBIT(4)\n#define SWRM_INTERRUPT_STATUS_RD_FIFO_UNDERFLOW\t\t\tBIT(5)\n#define SWRM_INTERRUPT_STATUS_WR_CMD_FIFO_OVERFLOW\t\tBIT(6)\n#define SWRM_INTERRUPT_STATUS_CMD_ERROR\t\t\t\tBIT(7)\n#define SWRM_INTERRUPT_STATUS_DOUT_PORT_COLLISION\t\tBIT(8)\n#define SWRM_INTERRUPT_STATUS_READ_EN_RD_VALID_MISMATCH\t\tBIT(9)\n#define SWRM_INTERRUPT_STATUS_SPECIAL_CMD_ID_FINISHED\t\tBIT(10)\n#define SWRM_INTERRUPT_STATUS_AUTO_ENUM_FAILED\t\t\tBIT(11)\n#define SWRM_INTERRUPT_STATUS_AUTO_ENUM_TABLE_IS_FULL\t\tBIT(12)\n#define SWRM_INTERRUPT_STATUS_BUS_RESET_FINISHED_V2\t\tBIT(13)\n#define SWRM_INTERRUPT_STATUS_CLK_STOP_FINISHED_V2\t\tBIT(14)\n#define SWRM_INTERRUPT_STATUS_EXT_CLK_STOP_WAKEUP\t\tBIT(16)\n#define SWRM_INTERRUPT_MAX\t\t\t\t\t17\n#define SWRM_V1_3_INTERRUPT_MASK_ADDR\t\t\t\t0x204\n#define SWRM_V1_3_INTERRUPT_CLEAR\t\t\t\t0x208\n#define SWRM_V2_0_INTERRUPT_CLEAR\t\t\t\t0x5008\n#define SWRM_V1_3_INTERRUPT_CPU_EN\t\t\t\t0x210\n#define SWRM_V2_0_INTERRUPT_CPU_EN\t\t\t\t0x5004\n#define SWRM_V1_3_CMD_FIFO_WR_CMD\t\t\t\t0x300\n#define SWRM_V2_0_CMD_FIFO_WR_CMD\t\t\t\t0x5020\n#define SWRM_V1_3_CMD_FIFO_RD_CMD\t\t\t\t0x304\n#define SWRM_V2_0_CMD_FIFO_RD_CMD\t\t\t\t0x5024\n#define SWRM_CMD_FIFO_CMD\t\t\t\t\t0x308\n#define SWRM_CMD_FIFO_FLUSH\t\t\t\t\t0x1\n#define SWRM_V1_3_CMD_FIFO_STATUS\t\t\t\t0x30C\n#define SWRM_V2_0_CMD_FIFO_STATUS\t\t\t\t0x5050\n#define SWRM_RD_CMD_FIFO_CNT_MASK\t\t\t\tGENMASK(20, 16)\n#define SWRM_WR_CMD_FIFO_CNT_MASK\t\t\t\tGENMASK(12, 8)\n#define SWRM_CMD_FIFO_CFG_ADDR\t\t\t\t\t0x314\n#define SWRM_CONTINUE_EXEC_ON_CMD_IGNORE\t\t\tBIT(31)\n#define SWRM_RD_WR_CMD_RETRIES\t\t\t\t\t0x7\n#define SWRM_V1_3_CMD_FIFO_RD_FIFO_ADDR\t\t\t\t0x318\n#define SWRM_V2_0_CMD_FIFO_RD_FIFO_ADDR\t\t\t\t0x5040\n#define SWRM_RD_FIFO_CMD_ID_MASK\t\t\t\tGENMASK(11, 8)\n#define SWRM_ENUMERATOR_CFG_ADDR\t\t\t\t0x500\n#define SWRM_ENUMERATOR_SLAVE_DEV_ID_1(m)\t\t(0x530 + 0x8 * (m))\n#define SWRM_ENUMERATOR_SLAVE_DEV_ID_2(m)\t\t(0x534 + 0x8 * (m))\n#define SWRM_MCP_FRAME_CTRL_BANK_ADDR(m)\t\t(0x101C + 0x40 * (m))\n#define SWRM_MCP_FRAME_CTRL_BANK_COL_CTRL_BMSK\t\t\tGENMASK(2, 0)\n#define SWRM_MCP_FRAME_CTRL_BANK_ROW_CTRL_BMSK\t\t\tGENMASK(7, 3)\n#define SWRM_MCP_BUS_CTRL\t\t\t\t\t0x1044\n#define SWRM_MCP_BUS_CLK_START\t\t\t\t\tBIT(1)\n#define SWRM_MCP_CFG_ADDR\t\t\t\t\t0x1048\n#define SWRM_MCP_CFG_MAX_NUM_OF_CMD_NO_PINGS_BMSK\t\tGENMASK(21, 17)\n#define SWRM_DEF_CMD_NO_PINGS\t\t\t\t\t0x1f\n#define SWRM_MCP_STATUS\t\t\t\t\t\t0x104C\n#define SWRM_MCP_STATUS_BANK_NUM_MASK\t\t\t\tBIT(0)\n#define SWRM_MCP_SLV_STATUS\t\t\t\t\t0x1090\n#define SWRM_MCP_SLV_STATUS_MASK\t\t\t\tGENMASK(1, 0)\n#define SWRM_MCP_SLV_STATUS_SZ\t\t\t\t\t2\n#define SWRM_DP_PORT_CTRL_BANK(n, m)\t(0x1124 + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DP_PORT_CTRL_2_BANK(n, m)\t(0x1128 + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DP_BLOCK_CTRL_1(n)\t\t(0x112C + 0x100 * (n - 1))\n#define SWRM_DP_BLOCK_CTRL2_BANK(n, m)\t(0x1130 + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DP_PORT_HCTRL_BANK(n, m)\t(0x1134 + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DP_BLOCK_CTRL3_BANK(n, m)\t(0x1138 + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DP_SAMPLECTRL2_BANK(n, m)\t(0x113C + 0x100 * (n - 1) + 0x40 * m)\n#define SWRM_DIN_DPn_PCM_PORT_CTRL(n)\t(0x1054 + 0x100 * (n - 1))\n#define SWR_V1_3_MSTR_MAX_REG_ADDR\t\t\t\t0x1740\n#define SWR_V2_0_MSTR_MAX_REG_ADDR\t\t\t\t0x50ac\n\n#define SWRM_V2_0_CLK_CTRL\t\t\t\t\t0x5060\n#define SWRM_V2_0_CLK_CTRL_CLK_START\t\t\t\tBIT(0)\n#define SWRM_V2_0_LINK_STATUS\t\t\t\t\t0x5064\n\n#define SWRM_DP_PORT_CTRL_EN_CHAN_SHFT\t\t\t\t0x18\n#define SWRM_DP_PORT_CTRL_OFFSET2_SHFT\t\t\t\t0x10\n#define SWRM_DP_PORT_CTRL_OFFSET1_SHFT\t\t\t\t0x08\n#define SWRM_AHB_BRIDGE_WR_DATA_0\t\t\t\t0xc85\n#define SWRM_AHB_BRIDGE_WR_ADDR_0\t\t\t\t0xc89\n#define SWRM_AHB_BRIDGE_RD_ADDR_0\t\t\t\t0xc8d\n#define SWRM_AHB_BRIDGE_RD_DATA_0\t\t\t\t0xc91\n\n#define SWRM_REG_VAL_PACK(data, dev, id, reg)\t\\\n\t\t\t((reg) | ((id) << 16) | ((dev) << 20) | ((data) << 24))\n\n#define MAX_FREQ_NUM\t\t\t\t\t\t1\n#define TIMEOUT_MS\t\t\t\t\t\t100\n#define QCOM_SWRM_MAX_RD_LEN\t\t\t\t\t0x1\n#define QCOM_SDW_MAX_PORTS\t\t\t\t\t14\n#define DEFAULT_CLK_FREQ\t\t\t\t\t9600000\n#define SWRM_MAX_DAIS\t\t\t\t\t\t0xF\n#define SWR_INVALID_PARAM\t\t\t\t\t0xFF\n#define SWR_HSTOP_MAX_VAL\t\t\t\t\t0xF\n#define SWR_HSTART_MIN_VAL\t\t\t\t\t0x0\n#define SWR_BROADCAST_CMD_ID\t\t\t\t\t0x0F\n#define SWR_MAX_CMD_ID\t\t\t\t\t\t14\n#define MAX_FIFO_RD_RETRY\t\t\t\t\t3\n#define SWR_OVERFLOW_RETRY_COUNT\t\t\t\t30\n#define SWRM_LINK_STATUS_RETRY_CNT\t\t\t\t100\n\nenum {\n\tMASTER_ID_WSA = 1,\n\tMASTER_ID_RX,\n\tMASTER_ID_TX\n};\n\nstruct qcom_swrm_port_config {\n\tu16 si;\n\tu8 off1;\n\tu8 off2;\n\tu8 bp_mode;\n\tu8 hstart;\n\tu8 hstop;\n\tu8 word_length;\n\tu8 blk_group_count;\n\tu8 lane_control;\n};\n\n \nenum {\n\tSWRM_REG_FRAME_GEN_ENABLED,\n\tSWRM_REG_INTERRUPT_STATUS,\n\tSWRM_REG_INTERRUPT_MASK_ADDR,\n\tSWRM_REG_INTERRUPT_CLEAR,\n\tSWRM_REG_INTERRUPT_CPU_EN,\n\tSWRM_REG_CMD_FIFO_WR_CMD,\n\tSWRM_REG_CMD_FIFO_RD_CMD,\n\tSWRM_REG_CMD_FIFO_STATUS,\n\tSWRM_REG_CMD_FIFO_RD_FIFO_ADDR,\n};\n\nstruct qcom_swrm_ctrl {\n\tstruct sdw_bus bus;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tu32 max_reg;\n\tconst unsigned int *reg_layout;\n\tvoid __iomem *mmio;\n\tstruct reset_control *audio_cgcr;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs;\n#endif\n\tstruct completion broadcast;\n\tstruct completion enumeration;\n\t \n\tstruct mutex port_lock;\n\tstruct clk *hclk;\n\tint irq;\n\tunsigned int version;\n\tint wake_irq;\n\tint num_din_ports;\n\tint num_dout_ports;\n\tint cols_index;\n\tint rows_index;\n\tunsigned long dout_port_mask;\n\tunsigned long din_port_mask;\n\tu32 intr_mask;\n\tu8 rcmd_id;\n\tu8 wcmd_id;\n\t \n\tstruct qcom_swrm_port_config pconfig[QCOM_SDW_MAX_PORTS + 1];\n\tstruct sdw_stream_runtime *sruntime[SWRM_MAX_DAIS];\n\tenum sdw_slave_status status[SDW_MAX_DEVICES + 1];\n\tint (*reg_read)(struct qcom_swrm_ctrl *ctrl, int reg, u32 *val);\n\tint (*reg_write)(struct qcom_swrm_ctrl *ctrl, int reg, int val);\n\tu32 slave_status;\n\tu32 wr_fifo_depth;\n\tu32 rd_fifo_depth;\n\tbool clock_stop_not_supported;\n};\n\nstruct qcom_swrm_data {\n\tu32 default_cols;\n\tu32 default_rows;\n\tbool sw_clk_gate_required;\n\tu32 max_reg;\n\tconst unsigned int *reg_layout;\n};\n\nstatic const unsigned int swrm_v1_3_reg_layout[] = {\n\t[SWRM_REG_FRAME_GEN_ENABLED] = SWRM_COMP_STATUS,\n\t[SWRM_REG_INTERRUPT_STATUS] = SWRM_V1_3_INTERRUPT_STATUS,\n\t[SWRM_REG_INTERRUPT_MASK_ADDR] = SWRM_V1_3_INTERRUPT_MASK_ADDR,\n\t[SWRM_REG_INTERRUPT_CLEAR] = SWRM_V1_3_INTERRUPT_CLEAR,\n\t[SWRM_REG_INTERRUPT_CPU_EN] = SWRM_V1_3_INTERRUPT_CPU_EN,\n\t[SWRM_REG_CMD_FIFO_WR_CMD] = SWRM_V1_3_CMD_FIFO_WR_CMD,\n\t[SWRM_REG_CMD_FIFO_RD_CMD] = SWRM_V1_3_CMD_FIFO_RD_CMD,\n\t[SWRM_REG_CMD_FIFO_STATUS] = SWRM_V1_3_CMD_FIFO_STATUS,\n\t[SWRM_REG_CMD_FIFO_RD_FIFO_ADDR] = SWRM_V1_3_CMD_FIFO_RD_FIFO_ADDR,\n};\n\nstatic const struct qcom_swrm_data swrm_v1_3_data = {\n\t.default_rows = 48,\n\t.default_cols = 16,\n\t.max_reg = SWR_V1_3_MSTR_MAX_REG_ADDR,\n\t.reg_layout = swrm_v1_3_reg_layout,\n};\n\nstatic const struct qcom_swrm_data swrm_v1_5_data = {\n\t.default_rows = 50,\n\t.default_cols = 16,\n\t.max_reg = SWR_V1_3_MSTR_MAX_REG_ADDR,\n\t.reg_layout = swrm_v1_3_reg_layout,\n};\n\nstatic const struct qcom_swrm_data swrm_v1_6_data = {\n\t.default_rows = 50,\n\t.default_cols = 16,\n\t.sw_clk_gate_required = true,\n\t.max_reg = SWR_V1_3_MSTR_MAX_REG_ADDR,\n\t.reg_layout = swrm_v1_3_reg_layout,\n};\n\nstatic const unsigned int swrm_v2_0_reg_layout[] = {\n\t[SWRM_REG_FRAME_GEN_ENABLED] = SWRM_V2_0_LINK_STATUS,\n\t[SWRM_REG_INTERRUPT_STATUS] = SWRM_V2_0_INTERRUPT_STATUS,\n\t[SWRM_REG_INTERRUPT_MASK_ADDR] = 0,  \n\t[SWRM_REG_INTERRUPT_CLEAR] = SWRM_V2_0_INTERRUPT_CLEAR,\n\t[SWRM_REG_INTERRUPT_CPU_EN] = SWRM_V2_0_INTERRUPT_CPU_EN,\n\t[SWRM_REG_CMD_FIFO_WR_CMD] = SWRM_V2_0_CMD_FIFO_WR_CMD,\n\t[SWRM_REG_CMD_FIFO_RD_CMD] = SWRM_V2_0_CMD_FIFO_RD_CMD,\n\t[SWRM_REG_CMD_FIFO_STATUS] = SWRM_V2_0_CMD_FIFO_STATUS,\n\t[SWRM_REG_CMD_FIFO_RD_FIFO_ADDR] = SWRM_V2_0_CMD_FIFO_RD_FIFO_ADDR,\n};\n\nstatic const struct qcom_swrm_data swrm_v2_0_data = {\n\t.default_rows = 50,\n\t.default_cols = 16,\n\t.sw_clk_gate_required = true,\n\t.max_reg = SWR_V2_0_MSTR_MAX_REG_ADDR,\n\t.reg_layout = swrm_v2_0_reg_layout,\n};\n\n#define to_qcom_sdw(b)\tcontainer_of(b, struct qcom_swrm_ctrl, bus)\n\nstatic int qcom_swrm_ahb_reg_read(struct qcom_swrm_ctrl *ctrl, int reg,\n\t\t\t\t  u32 *val)\n{\n\tstruct regmap *wcd_regmap = ctrl->regmap;\n\tint ret;\n\n\t \n\tret = regmap_bulk_write(wcd_regmap, SWRM_AHB_BRIDGE_RD_ADDR_0,\n\t\t\t  (u8 *)&reg, 4);\n\tif (ret < 0)\n\t\treturn SDW_CMD_FAIL;\n\n\tret = regmap_bulk_read(wcd_regmap, SWRM_AHB_BRIDGE_RD_DATA_0,\n\t\t\t       val, 4);\n\tif (ret < 0)\n\t\treturn SDW_CMD_FAIL;\n\n\treturn SDW_CMD_OK;\n}\n\nstatic int qcom_swrm_ahb_reg_write(struct qcom_swrm_ctrl *ctrl,\n\t\t\t\t   int reg, int val)\n{\n\tstruct regmap *wcd_regmap = ctrl->regmap;\n\tint ret;\n\t \n\tret = regmap_bulk_write(wcd_regmap, SWRM_AHB_BRIDGE_WR_DATA_0,\n\t\t\t  (u8 *)&val, 4);\n\tif (ret)\n\t\treturn SDW_CMD_FAIL;\n\n\t \n\tret = regmap_bulk_write(wcd_regmap, SWRM_AHB_BRIDGE_WR_ADDR_0,\n\t\t\t  (u8 *)&reg, 4);\n\tif (ret)\n\t\treturn SDW_CMD_FAIL;\n\n\treturn SDW_CMD_OK;\n}\n\nstatic int qcom_swrm_cpu_reg_read(struct qcom_swrm_ctrl *ctrl, int reg,\n\t\t\t\t  u32 *val)\n{\n\t*val = readl(ctrl->mmio + reg);\n\treturn SDW_CMD_OK;\n}\n\nstatic int qcom_swrm_cpu_reg_write(struct qcom_swrm_ctrl *ctrl, int reg,\n\t\t\t\t   int val)\n{\n\twritel(val, ctrl->mmio + reg);\n\treturn SDW_CMD_OK;\n}\n\nstatic u32 swrm_get_packed_reg_val(u8 *cmd_id, u8 cmd_data,\n\t\t\t\t   u8 dev_addr, u16 reg_addr)\n{\n\tu32 val;\n\tu8 id = *cmd_id;\n\n\tif (id != SWR_BROADCAST_CMD_ID) {\n\t\tif (id < SWR_MAX_CMD_ID)\n\t\t\tid += 1;\n\t\telse\n\t\t\tid = 0;\n\t\t*cmd_id = id;\n\t}\n\tval = SWRM_REG_VAL_PACK(cmd_data, dev_addr, id, reg_addr);\n\n\treturn val;\n}\n\nstatic int swrm_wait_for_rd_fifo_avail(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 fifo_outstanding_data, value;\n\tint fifo_retry_count = SWR_OVERFLOW_RETRY_COUNT;\n\n\tdo {\n\t\t \n\t\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t       &value);\n\t\tfifo_outstanding_data = FIELD_GET(SWRM_RD_CMD_FIFO_CNT_MASK, value);\n\n\t\t \n\t\tif (fifo_outstanding_data > 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(500, 510);\n\t} while (fifo_retry_count--);\n\n\tif (fifo_outstanding_data == 0) {\n\t\tdev_err_ratelimited(ctrl->dev, \"%s err read underflow\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int swrm_wait_for_wr_fifo_avail(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 fifo_outstanding_cmds, value;\n\tint fifo_retry_count = SWR_OVERFLOW_RETRY_COUNT;\n\n\tdo {\n\t\t \n\t\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t       &value);\n\t\tfifo_outstanding_cmds = FIELD_GET(SWRM_WR_CMD_FIFO_CNT_MASK, value);\n\n\t\t \n\t\tif (fifo_outstanding_cmds < ctrl->wr_fifo_depth)\n\t\t\treturn 0;\n\n\t\tusleep_range(500, 510);\n\t} while (fifo_retry_count--);\n\n\tif (fifo_outstanding_cmds == ctrl->wr_fifo_depth) {\n\t\tdev_err_ratelimited(ctrl->dev, \"%s err write overflow\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool swrm_wait_for_wr_fifo_done(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 fifo_outstanding_cmds, value;\n\tint fifo_retry_count = SWR_OVERFLOW_RETRY_COUNT;\n\n\t \n\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS], &value);\n\tfifo_outstanding_cmds = FIELD_GET(SWRM_WR_CMD_FIFO_CNT_MASK, value);\n\n\tif (fifo_outstanding_cmds) {\n\t\twhile (fifo_retry_count) {\n\t\t\tusleep_range(500, 510);\n\t\t\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS], &value);\n\t\t\tfifo_outstanding_cmds = FIELD_GET(SWRM_WR_CMD_FIFO_CNT_MASK, value);\n\t\t\tfifo_retry_count--;\n\t\t\tif (fifo_outstanding_cmds == 0)\n\t\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn true;\n\t}\n\n\n\treturn false;\n}\n\nstatic int qcom_swrm_cmd_fifo_wr_cmd(struct qcom_swrm_ctrl *ctrl, u8 cmd_data,\n\t\t\t\t     u8 dev_addr, u16 reg_addr)\n{\n\n\tu32 val;\n\tint ret = 0;\n\tu8 cmd_id = 0x0;\n\n\tif (dev_addr == SDW_BROADCAST_DEV_NUM) {\n\t\tcmd_id = SWR_BROADCAST_CMD_ID;\n\t\tval = swrm_get_packed_reg_val(&cmd_id, cmd_data,\n\t\t\t\t\t      dev_addr, reg_addr);\n\t} else {\n\t\tval = swrm_get_packed_reg_val(&ctrl->wcmd_id, cmd_data,\n\t\t\t\t\t      dev_addr, reg_addr);\n\t}\n\n\tif (swrm_wait_for_wr_fifo_avail(ctrl))\n\t\treturn SDW_CMD_FAIL_OTHER;\n\n\tif (cmd_id == SWR_BROADCAST_CMD_ID)\n\t\treinit_completion(&ctrl->broadcast);\n\n\t \n\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_WR_CMD], val);\n\n\tif (ctrl->version <= SWRM_VERSION_1_3_0)\n\t\tusleep_range(150, 155);\n\n\tif (cmd_id == SWR_BROADCAST_CMD_ID) {\n\t\tswrm_wait_for_wr_fifo_done(ctrl);\n\t\t \n\t\tret = wait_for_completion_timeout(&ctrl->broadcast,\n\t\t\t\t\t\t  msecs_to_jiffies(TIMEOUT_MS));\n\t\tif (!ret)\n\t\t\tret = SDW_CMD_IGNORED;\n\t\telse\n\t\t\tret = SDW_CMD_OK;\n\n\t} else {\n\t\tret = SDW_CMD_OK;\n\t}\n\treturn ret;\n}\n\nstatic int qcom_swrm_cmd_fifo_rd_cmd(struct qcom_swrm_ctrl *ctrl,\n\t\t\t\t     u8 dev_addr, u16 reg_addr,\n\t\t\t\t     u32 len, u8 *rval)\n{\n\tu32 cmd_data, cmd_id, val, retry_attempt = 0;\n\n\tval = swrm_get_packed_reg_val(&ctrl->rcmd_id, len, dev_addr, reg_addr);\n\n\t \n\tswrm_wait_for_wr_fifo_avail(ctrl);\n\n\t \n\tusleep_range(100, 105);\n\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_RD_CMD], val);\n\t \n\tusleep_range(250, 255);\n\n\tif (swrm_wait_for_rd_fifo_avail(ctrl))\n\t\treturn SDW_CMD_FAIL_OTHER;\n\n\tdo {\n\t\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_CMD_FIFO_RD_FIFO_ADDR],\n\t\t\t       &cmd_data);\n\t\trval[0] = cmd_data & 0xFF;\n\t\tcmd_id = FIELD_GET(SWRM_RD_FIFO_CMD_ID_MASK, cmd_data);\n\n\t\tif (cmd_id != ctrl->rcmd_id) {\n\t\t\tif (retry_attempt < (MAX_FIFO_RD_RETRY - 1)) {\n\t\t\t\t \n\t\t\t\tusleep_range(500, 505);\n\t\t\t\tctrl->reg_write(ctrl, SWRM_CMD_FIFO_CMD,\n\t\t\t\t\t\tSWRM_CMD_FIFO_FLUSH);\n\t\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\t\tctrl->reg_layout[SWRM_REG_CMD_FIFO_RD_CMD],\n\t\t\t\t\t\tval);\n\t\t\t}\n\t\t\tretry_attempt++;\n\t\t} else {\n\t\t\treturn SDW_CMD_OK;\n\t\t}\n\n\t} while (retry_attempt < MAX_FIFO_RD_RETRY);\n\n\tdev_err(ctrl->dev, \"failed to read fifo: reg: 0x%x, rcmd_id: 0x%x,\\\n\t\tdev_num: 0x%x, cmd_data: 0x%x\\n\",\n\t\treg_addr, ctrl->rcmd_id, dev_addr, cmd_data);\n\n\treturn SDW_CMD_IGNORED;\n}\n\nstatic int qcom_swrm_get_alert_slave_dev_num(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 val, status;\n\tint dev_num;\n\n\tctrl->reg_read(ctrl, SWRM_MCP_SLV_STATUS, &val);\n\n\tfor (dev_num = 1; dev_num <= SDW_MAX_DEVICES; dev_num++) {\n\t\tstatus = (val >> (dev_num * SWRM_MCP_SLV_STATUS_SZ));\n\n\t\tif ((status & SWRM_MCP_SLV_STATUS_MASK) == SDW_SLAVE_ALERT) {\n\t\t\tctrl->status[dev_num] = status & SWRM_MCP_SLV_STATUS_MASK;\n\t\t\treturn dev_num;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void qcom_swrm_get_device_status(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 val;\n\tint i;\n\n\tctrl->reg_read(ctrl, SWRM_MCP_SLV_STATUS, &val);\n\tctrl->slave_status = val;\n\n\tfor (i = 1; i <= SDW_MAX_DEVICES; i++) {\n\t\tu32 s;\n\n\t\ts = (val >> (i * 2));\n\t\ts &= SWRM_MCP_SLV_STATUS_MASK;\n\t\tctrl->status[i] = s;\n\t}\n}\n\nstatic void qcom_swrm_set_slave_dev_num(struct sdw_bus *bus,\n\t\t\t\t\tstruct sdw_slave *slave, int devnum)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tu32 status;\n\n\tctrl->reg_read(ctrl, SWRM_MCP_SLV_STATUS, &status);\n\tstatus = (status >> (devnum * SWRM_MCP_SLV_STATUS_SZ));\n\tstatus &= SWRM_MCP_SLV_STATUS_MASK;\n\n\tif (status == SDW_SLAVE_ATTACHED) {\n\t\tif (slave)\n\t\t\tslave->dev_num = devnum;\n\t\tmutex_lock(&bus->bus_lock);\n\t\tset_bit(devnum, bus->assigned);\n\t\tmutex_unlock(&bus->bus_lock);\n\t}\n}\n\nstatic int qcom_swrm_enumerate(struct sdw_bus *bus)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tstruct sdw_slave *slave, *_s;\n\tstruct sdw_slave_id id;\n\tu32 val1, val2;\n\tbool found;\n\tu64 addr;\n\tint i;\n\tchar *buf1 = (char *)&val1, *buf2 = (char *)&val2;\n\n\tfor (i = 1; i <= SDW_MAX_DEVICES; i++) {\n\t\t/* do not continue if the status is Not Present  */\n\t\tif (!ctrl->status[i])\n\t\t\tcontinue;\n\n\t\t/*SCP_Devid5 - Devid 4*/\n\t\tctrl->reg_read(ctrl, SWRM_ENUMERATOR_SLAVE_DEV_ID_1(i), &val1);\n\n\t\t/*SCP_Devid3 - DevId 2 Devid 1 Devid 0*/\n\t\tctrl->reg_read(ctrl, SWRM_ENUMERATOR_SLAVE_DEV_ID_2(i), &val2);\n\n\t\tif (!val1 && !val2)\n\t\t\tbreak;\n\n\t\taddr = buf2[1] | (buf2[0] << 8) | (buf1[3] << 16) |\n\t\t\t((u64)buf1[2] << 24) | ((u64)buf1[1] << 32) |\n\t\t\t((u64)buf1[0] << 40);\n\n\t\tsdw_extract_slave_id(bus, addr, &id);\n\t\tfound = false;\n\t\tctrl->clock_stop_not_supported = false;\n\t\t/* Now compare with entries */\n\t\tlist_for_each_entry_safe(slave, _s, &bus->slaves, node) {\n\t\t\tif (sdw_compare_devid(slave, id) == 0) {\n\t\t\t\tqcom_swrm_set_slave_dev_num(bus, slave, i);\n\t\t\t\tif (slave->prop.clk_stop_mode1)\n\t\t\t\t\tctrl->clock_stop_not_supported = true;\n\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tqcom_swrm_set_slave_dev_num(bus, NULL, i);\n\t\t\tsdw_slave_add(bus, &id, NULL);\n\t\t}\n\t}\n\n\tcomplete(&ctrl->enumeration);\n\treturn 0;\n}\n\nstatic irqreturn_t qcom_swrm_wake_irq_handler(int irq, void *dev_id)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_id;\n\tint ret;\n\n\tret = pm_runtime_get_sync(ctrl->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t    \"pm_runtime_get_sync failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tpm_runtime_put_noidle(ctrl->dev);\n\t\treturn ret;\n\t}\n\n\tif (ctrl->wake_irq > 0) {\n\t\tif (!irqd_irq_disabled(irq_get_irq_data(ctrl->wake_irq)))\n\t\t\tdisable_irq_nosync(ctrl->wake_irq);\n\t}\n\n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qcom_swrm_irq_handler(int irq, void *dev_id)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_id;\n\tu32 value, intr_sts, intr_sts_masked, slave_status;\n\tu32 i;\n\tint devnum;\n\tint ret = IRQ_HANDLED;\n\tclk_prepare_enable(ctrl->hclk);\n\n\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_STATUS],\n\t\t       &intr_sts);\n\tintr_sts_masked = intr_sts & ctrl->intr_mask;\n\n\tdo {\n\t\tfor (i = 0; i < SWRM_INTERRUPT_MAX; i++) {\n\t\t\tvalue = intr_sts_masked & BIT(i);\n\t\t\tif (!value)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (value) {\n\t\t\tcase SWRM_INTERRUPT_STATUS_SLAVE_PEND_IRQ:\n\t\t\t\tdevnum = qcom_swrm_get_alert_slave_dev_num(ctrl);\n\t\t\t\tif (devnum < 0) {\n\t\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t    \"no slave alert found.spurious interrupt\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tsdw_handle_slave_status(&ctrl->bus, ctrl->status);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_NEW_SLAVE_ATTACHED:\n\t\t\tcase SWRM_INTERRUPT_STATUS_CHANGE_ENUM_SLAVE_STATUS:\n\t\t\t\tdev_dbg_ratelimited(ctrl->dev, \"SWR new slave attached\\n\");\n\t\t\t\tctrl->reg_read(ctrl, SWRM_MCP_SLV_STATUS, &slave_status);\n\t\t\t\tif (ctrl->slave_status == slave_status) {\n\t\t\t\t\tdev_dbg(ctrl->dev, \"Slave status not changed %x\\n\",\n\t\t\t\t\t\tslave_status);\n\t\t\t\t} else {\n\t\t\t\t\tqcom_swrm_get_device_status(ctrl);\n\t\t\t\t\tqcom_swrm_enumerate(&ctrl->bus);\n\t\t\t\t\tsdw_handle_slave_status(&ctrl->bus, ctrl->status);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_MASTER_CLASH_DET:\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\t\"%s: SWR bus clsh detected\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tctrl->intr_mask &= ~SWRM_INTERRUPT_STATUS_MASTER_CLASH_DET;\n\t\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\t\tctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\t\t\tctrl->intr_mask);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_RD_FIFO_OVERFLOW:\n\t\t\t\tctrl->reg_read(ctrl,\n\t\t\t\t\t       ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t\t\t       &value);\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\"%s: SWR read FIFO overflow fifo status 0x%x\\n\",\n\t\t\t\t\t__func__, value);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_RD_FIFO_UNDERFLOW:\n\t\t\t\tctrl->reg_read(ctrl,\n\t\t\t\t\t       ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t\t\t       &value);\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\"%s: SWR read FIFO underflow fifo status 0x%x\\n\",\n\t\t\t\t\t__func__, value);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_WR_CMD_FIFO_OVERFLOW:\n\t\t\t\tctrl->reg_read(ctrl,\n\t\t\t\t\t       ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t\t\t       &value);\n\t\t\t\tdev_err(ctrl->dev,\n\t\t\t\t\t\"%s: SWR write FIFO overflow fifo status %x\\n\",\n\t\t\t\t\t__func__, value);\n\t\t\t\tctrl->reg_write(ctrl, SWRM_CMD_FIFO_CMD, 0x1);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_CMD_ERROR:\n\t\t\t\tctrl->reg_read(ctrl,\n\t\t\t\t\t       ctrl->reg_layout[SWRM_REG_CMD_FIFO_STATUS],\n\t\t\t\t\t       &value);\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\"%s: SWR CMD error, fifo status 0x%x, flushing fifo\\n\",\n\t\t\t\t\t__func__, value);\n\t\t\t\tctrl->reg_write(ctrl, SWRM_CMD_FIFO_CMD, 0x1);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_DOUT_PORT_COLLISION:\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\t\"%s: SWR Port collision detected\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\tctrl->intr_mask &= ~SWRM_INTERRUPT_STATUS_DOUT_PORT_COLLISION;\n\t\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\t\tctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\t\t\tctrl->intr_mask);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_READ_EN_RD_VALID_MISMATCH:\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\"%s: SWR read enable valid mismatch\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tctrl->intr_mask &=\n\t\t\t\t\t~SWRM_INTERRUPT_STATUS_READ_EN_RD_VALID_MISMATCH;\n\t\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\t\tctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\t\t\tctrl->intr_mask);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_SPECIAL_CMD_ID_FINISHED:\n\t\t\t\tcomplete(&ctrl->broadcast);\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_BUS_RESET_FINISHED_V2:\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_CLK_STOP_FINISHED_V2:\n\t\t\t\tbreak;\n\t\t\tcase SWRM_INTERRUPT_STATUS_EXT_CLK_STOP_WAKEUP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t\t\t\"%s: SWR unknown interrupt value: %d\\n\",\n\t\t\t\t\t\t__func__, value);\n\t\t\t\tret = IRQ_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CLEAR],\n\t\t\t\tintr_sts);\n\t\tctrl->reg_read(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_STATUS],\n\t\t\t       &intr_sts);\n\t\tintr_sts_masked = intr_sts & ctrl->intr_mask;\n\t} while (intr_sts_masked);\n\n\tclk_disable_unprepare(ctrl->hclk);\n\treturn ret;\n}\n\nstatic bool swrm_wait_for_frame_gen_enabled(struct qcom_swrm_ctrl *ctrl)\n{\n\tint retry = SWRM_LINK_STATUS_RETRY_CNT;\n\tint comp_sts;\n\n\tdo {\n\t\tctrl->reg_read(ctrl, SWRM_COMP_STATUS, &comp_sts);\n\n\t\tif (comp_sts & SWRM_FRM_GEN_ENABLED)\n\t\t\treturn true;\n\n\t\tusleep_range(500, 510);\n\t} while (retry--);\n\n\tdev_err(ctrl->dev, \"%s: link status not %s\\n\", __func__,\n\t\tcomp_sts & SWRM_FRM_GEN_ENABLED ? \"connected\" : \"disconnected\");\n\n\treturn false;\n}\n\nstatic int qcom_swrm_init(struct qcom_swrm_ctrl *ctrl)\n{\n\tu32 val;\n\n\t/* Clear Rows and Cols */\n\tval = FIELD_PREP(SWRM_MCP_FRAME_CTRL_BANK_ROW_CTRL_BMSK, ctrl->rows_index);\n\tval |= FIELD_PREP(SWRM_MCP_FRAME_CTRL_BANK_COL_CTRL_BMSK, ctrl->cols_index);\n\n\treset_control_reset(ctrl->audio_cgcr);\n\n\tctrl->reg_write(ctrl, SWRM_MCP_FRAME_CTRL_BANK_ADDR(0), val);\n\n\t/* Enable Auto enumeration */\n\tctrl->reg_write(ctrl, SWRM_ENUMERATOR_CFG_ADDR, 1);\n\n\tctrl->intr_mask = SWRM_INTERRUPT_STATUS_RMSK;\n\t/* Mask soundwire interrupts */\n\tif (ctrl->version < SWRM_VERSION_2_0_0)\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_MASK_ADDR],\n\t\t\t\tSWRM_INTERRUPT_STATUS_RMSK);\n\n\t/* Configure No pings */\n\tctrl->reg_read(ctrl, SWRM_MCP_CFG_ADDR, &val);\n\tu32p_replace_bits(&val, SWRM_DEF_CMD_NO_PINGS, SWRM_MCP_CFG_MAX_NUM_OF_CMD_NO_PINGS_BMSK);\n\tctrl->reg_write(ctrl, SWRM_MCP_CFG_ADDR, val);\n\n\tif (ctrl->version == SWRM_VERSION_1_7_0) {\n\t\tctrl->reg_write(ctrl, SWRM_LINK_MANAGER_EE, SWRM_EE_CPU);\n\t\tctrl->reg_write(ctrl, SWRM_MCP_BUS_CTRL,\n\t\t\t\tSWRM_MCP_BUS_CLK_START << SWRM_EE_CPU);\n\t} else if (ctrl->version >= SWRM_VERSION_2_0_0) {\n\t\tctrl->reg_write(ctrl, SWRM_LINK_MANAGER_EE, SWRM_EE_CPU);\n\t\tctrl->reg_write(ctrl, SWRM_V2_0_CLK_CTRL,\n\t\t\t\tSWRM_V2_0_CLK_CTRL_CLK_START);\n\t} else {\n\t\tctrl->reg_write(ctrl, SWRM_MCP_BUS_CTRL, SWRM_MCP_BUS_CLK_START);\n\t}\n\n\t/* Configure number of retries of a read/write cmd */\n\tif (ctrl->version >= SWRM_VERSION_1_5_1) {\n\t\tctrl->reg_write(ctrl, SWRM_CMD_FIFO_CFG_ADDR,\n\t\t\t\tSWRM_RD_WR_CMD_RETRIES |\n\t\t\t\tSWRM_CONTINUE_EXEC_ON_CMD_IGNORE);\n\t} else {\n\t\tctrl->reg_write(ctrl, SWRM_CMD_FIFO_CFG_ADDR,\n\t\t\t\tSWRM_RD_WR_CMD_RETRIES);\n\t}\n\n\t/* COMP Enable */\n\tctrl->reg_write(ctrl, SWRM_COMP_CFG_ADDR, SWRM_COMP_CFG_ENABLE_MSK);\n\n\t/* Set IRQ to PULSE */\n\tctrl->reg_write(ctrl, SWRM_COMP_CFG_ADDR,\n\t\t\tSWRM_COMP_CFG_IRQ_LEVEL_OR_PULSE_MSK);\n\n\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CLEAR],\n\t\t\t0xFFFFFFFF);\n\n\t/* enable CPU IRQs */\n\tif (ctrl->mmio) {\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\tSWRM_INTERRUPT_STATUS_RMSK);\n\t}\n\n\t/* Set IRQ to PULSE */\n\tctrl->reg_write(ctrl, SWRM_COMP_CFG_ADDR,\n\t\t\tSWRM_COMP_CFG_IRQ_LEVEL_OR_PULSE_MSK |\n\t\t\tSWRM_COMP_CFG_ENABLE_MSK);\n\n\tswrm_wait_for_frame_gen_enabled(ctrl);\n\tctrl->slave_status = 0;\n\tctrl->reg_read(ctrl, SWRM_COMP_PARAMS, &val);\n\tctrl->rd_fifo_depth = FIELD_GET(SWRM_COMP_PARAMS_RD_FIFO_DEPTH, val);\n\tctrl->wr_fifo_depth = FIELD_GET(SWRM_COMP_PARAMS_WR_FIFO_DEPTH, val);\n\n\treturn 0;\n}\n\nstatic enum sdw_command_response qcom_swrm_xfer_msg(struct sdw_bus *bus,\n\t\t\t\t\t\t    struct sdw_msg *msg)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tint ret, i, len;\n\n\tif (msg->flags == SDW_MSG_FLAG_READ) {\n\t\tfor (i = 0; i < msg->len;) {\n\t\t\tif ((msg->len - i) < QCOM_SWRM_MAX_RD_LEN)\n\t\t\t\tlen = msg->len - i;\n\t\t\telse\n\t\t\t\tlen = QCOM_SWRM_MAX_RD_LEN;\n\n\t\t\tret = qcom_swrm_cmd_fifo_rd_cmd(ctrl, msg->dev_num,\n\t\t\t\t\t\t\tmsg->addr + i, len,\n\t\t\t\t\t\t       &msg->buf[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ti = i + len;\n\t\t}\n\t} else if (msg->flags == SDW_MSG_FLAG_WRITE) {\n\t\tfor (i = 0; i < msg->len; i++) {\n\t\t\tret = qcom_swrm_cmd_fifo_wr_cmd(ctrl, msg->buf[i],\n\t\t\t\t\t\t\tmsg->dev_num,\n\t\t\t\t\t\t       msg->addr + i);\n\t\t\tif (ret)\n\t\t\t\treturn SDW_CMD_IGNORED;\n\t\t}\n\t}\n\n\treturn SDW_CMD_OK;\n}\n\nstatic int qcom_swrm_pre_bank_switch(struct sdw_bus *bus)\n{\n\tu32 reg = SWRM_MCP_FRAME_CTRL_BANK_ADDR(bus->params.next_bank);\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tu32 val;\n\n\tctrl->reg_read(ctrl, reg, &val);\n\n\tu32p_replace_bits(&val, ctrl->cols_index, SWRM_MCP_FRAME_CTRL_BANK_COL_CTRL_BMSK);\n\tu32p_replace_bits(&val, ctrl->rows_index, SWRM_MCP_FRAME_CTRL_BANK_ROW_CTRL_BMSK);\n\n\treturn ctrl->reg_write(ctrl, reg, val);\n}\n\nstatic int qcom_swrm_port_params(struct sdw_bus *bus,\n\t\t\t\t struct sdw_port_params *p_params,\n\t\t\t\t unsigned int bank)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\n\treturn ctrl->reg_write(ctrl, SWRM_DP_BLOCK_CTRL_1(p_params->num),\n\t\t\t       p_params->bps - 1);\n\n}\n\nstatic int qcom_swrm_transport_params(struct sdw_bus *bus,\n\t\t\t\t      struct sdw_transport_params *params,\n\t\t\t\t      enum sdw_reg_bank bank)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tstruct qcom_swrm_port_config *pcfg;\n\tu32 value;\n\tint reg = SWRM_DP_PORT_CTRL_BANK((params->port_num), bank);\n\tint ret;\n\n\tpcfg = &ctrl->pconfig[params->port_num];\n\n\tvalue = pcfg->off1 << SWRM_DP_PORT_CTRL_OFFSET1_SHFT;\n\tvalue |= pcfg->off2 << SWRM_DP_PORT_CTRL_OFFSET2_SHFT;\n\tvalue |= pcfg->si & 0xff;\n\n\tret = ctrl->reg_write(ctrl, reg, value);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pcfg->si > 0xff) {\n\t\tvalue = (pcfg->si >> 8) & 0xff;\n\t\treg = SWRM_DP_SAMPLECTRL2_BANK(params->port_num, bank);\n\t\tret = ctrl->reg_write(ctrl, reg, value);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (pcfg->lane_control != SWR_INVALID_PARAM) {\n\t\treg = SWRM_DP_PORT_CTRL_2_BANK(params->port_num, bank);\n\t\tvalue = pcfg->lane_control;\n\t\tret = ctrl->reg_write(ctrl, reg, value);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (pcfg->blk_group_count != SWR_INVALID_PARAM) {\n\t\treg = SWRM_DP_BLOCK_CTRL2_BANK(params->port_num, bank);\n\t\tvalue = pcfg->blk_group_count;\n\t\tret = ctrl->reg_write(ctrl, reg, value);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (pcfg->hstart != SWR_INVALID_PARAM\n\t\t\t&& pcfg->hstop != SWR_INVALID_PARAM) {\n\t\treg = SWRM_DP_PORT_HCTRL_BANK(params->port_num, bank);\n\t\tvalue = (pcfg->hstop << 4) | pcfg->hstart;\n\t\tret = ctrl->reg_write(ctrl, reg, value);\n\t} else {\n\t\treg = SWRM_DP_PORT_HCTRL_BANK(params->port_num, bank);\n\t\tvalue = (SWR_HSTOP_MAX_VAL << 4) | SWR_HSTART_MIN_VAL;\n\t\tret = ctrl->reg_write(ctrl, reg, value);\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\tif (pcfg->bp_mode != SWR_INVALID_PARAM) {\n\t\treg = SWRM_DP_BLOCK_CTRL3_BANK(params->port_num, bank);\n\t\tret = ctrl->reg_write(ctrl, reg, pcfg->bp_mode);\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic int qcom_swrm_port_enable(struct sdw_bus *bus,\n\t\t\t\t struct sdw_enable_ch *enable_ch,\n\t\t\t\t unsigned int bank)\n{\n\tu32 reg = SWRM_DP_PORT_CTRL_BANK(enable_ch->port_num, bank);\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tu32 val;\n\n\tctrl->reg_read(ctrl, reg, &val);\n\n\tif (enable_ch->enable)\n\t\tval |= (enable_ch->ch_mask << SWRM_DP_PORT_CTRL_EN_CHAN_SHFT);\n\telse\n\t\tval &= ~(0xff << SWRM_DP_PORT_CTRL_EN_CHAN_SHFT);\n\n\treturn ctrl->reg_write(ctrl, reg, val);\n}\n\nstatic const struct sdw_master_port_ops qcom_swrm_port_ops = {\n\t.dpn_set_port_params = qcom_swrm_port_params,\n\t.dpn_set_port_transport_params = qcom_swrm_transport_params,\n\t.dpn_port_enable_ch = qcom_swrm_port_enable,\n};\n\nstatic const struct sdw_master_ops qcom_swrm_ops = {\n\t.xfer_msg = qcom_swrm_xfer_msg,\n\t.pre_bank_switch = qcom_swrm_pre_bank_switch,\n};\n\nstatic int qcom_swrm_compute_params(struct sdw_bus *bus)\n{\n\tstruct qcom_swrm_ctrl *ctrl = to_qcom_sdw(bus);\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_port_runtime *p_rt;\n\tstruct qcom_swrm_port_config *pcfg;\n\tstruct sdw_slave *slave;\n\tunsigned int m_port;\n\tint i = 1;\n\n\tlist_for_each_entry(m_rt, &bus->m_rt_list, bus_node) {\n\t\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node) {\n\t\t\tpcfg = &ctrl->pconfig[p_rt->num];\n\t\t\tp_rt->transport_params.port_num = p_rt->num;\n\t\t\tif (pcfg->word_length != SWR_INVALID_PARAM) {\n\t\t\t\tsdw_fill_port_params(&p_rt->port_params,\n\t\t\t\t\t     p_rt->num,  pcfg->word_length + 1,\n\t\t\t\t\t     SDW_PORT_FLOW_MODE_ISOCH,\n\t\t\t\t\t     SDW_PORT_DATA_MODE_NORMAL);\n\t\t\t}\n\n\t\t}\n\n\t\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\t\tslave = s_rt->slave;\n\t\t\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t\t\tm_port = slave->m_port_map[p_rt->num];\n\t\t\t\t/* port config starts at offset 0 so -1 from actual port number */\n\t\t\t\tif (m_port)\n\t\t\t\t\tpcfg = &ctrl->pconfig[m_port];\n\t\t\t\telse\n\t\t\t\t\tpcfg = &ctrl->pconfig[i];\n\t\t\t\tp_rt->transport_params.port_num = p_rt->num;\n\t\t\t\tp_rt->transport_params.sample_interval =\n\t\t\t\t\tpcfg->si + 1;\n\t\t\t\tp_rt->transport_params.offset1 = pcfg->off1;\n\t\t\t\tp_rt->transport_params.offset2 = pcfg->off2;\n\t\t\t\tp_rt->transport_params.blk_pkg_mode = pcfg->bp_mode;\n\t\t\t\tp_rt->transport_params.blk_grp_ctrl = pcfg->blk_group_count;\n\n\t\t\t\tp_rt->transport_params.hstart = pcfg->hstart;\n\t\t\t\tp_rt->transport_params.hstop = pcfg->hstop;\n\t\t\t\tp_rt->transport_params.lane_ctrl = pcfg->lane_control;\n\t\t\t\tif (pcfg->word_length != SWR_INVALID_PARAM) {\n\t\t\t\t\tsdw_fill_port_params(&p_rt->port_params,\n\t\t\t\t\t\t     p_rt->num,\n\t\t\t\t\t\t     pcfg->word_length + 1,\n\t\t\t\t\t\t     SDW_PORT_FLOW_MODE_ISOCH,\n\t\t\t\t\t\t     SDW_PORT_DATA_MODE_NORMAL);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 qcom_swrm_freq_tbl[MAX_FREQ_NUM] = {\n\tDEFAULT_CLK_FREQ,\n};\n\nstatic void qcom_swrm_stream_free_ports(struct qcom_swrm_ctrl *ctrl,\n\t\t\t\t\tstruct sdw_stream_runtime *stream)\n{\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_port_runtime *p_rt;\n\tunsigned long *port_mask;\n\n\tmutex_lock(&ctrl->port_lock);\n\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tif (m_rt->direction == SDW_DATA_DIR_RX)\n\t\t\tport_mask = &ctrl->dout_port_mask;\n\t\telse\n\t\t\tport_mask = &ctrl->din_port_mask;\n\n\t\tlist_for_each_entry(p_rt, &m_rt->port_list, port_node)\n\t\t\tclear_bit(p_rt->num, port_mask);\n\t}\n\n\tmutex_unlock(&ctrl->port_lock);\n}\n\nstatic int qcom_swrm_stream_alloc_ports(struct qcom_swrm_ctrl *ctrl,\n\t\t\t\t\tstruct sdw_stream_runtime *stream,\n\t\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t\t       int direction)\n{\n\tstruct sdw_port_config pconfig[QCOM_SDW_MAX_PORTS];\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_master_runtime *m_rt;\n\tstruct sdw_slave_runtime *s_rt;\n\tstruct sdw_port_runtime *p_rt;\n\tstruct sdw_slave *slave;\n\tunsigned long *port_mask;\n\tint i, maxport, pn, nports = 0, ret = 0;\n\tunsigned int m_port;\n\n\tmutex_lock(&ctrl->port_lock);\n\tlist_for_each_entry(m_rt, &stream->master_list, stream_node) {\n\t\tif (m_rt->direction == SDW_DATA_DIR_RX) {\n\t\t\tmaxport = ctrl->num_dout_ports;\n\t\t\tport_mask = &ctrl->dout_port_mask;\n\t\t} else {\n\t\t\tmaxport = ctrl->num_din_ports;\n\t\t\tport_mask = &ctrl->din_port_mask;\n\t\t}\n\n\t\tlist_for_each_entry(s_rt, &m_rt->slave_rt_list, m_rt_node) {\n\t\t\tslave = s_rt->slave;\n\t\t\tlist_for_each_entry(p_rt, &s_rt->port_list, port_node) {\n\t\t\t\tm_port = slave->m_port_map[p_rt->num];\n\t\t\t\t/* Port numbers start from 1 - 14*/\n\t\t\t\tif (m_port)\n\t\t\t\t\tpn = m_port;\n\t\t\t\telse\n\t\t\t\t\tpn = find_first_zero_bit(port_mask, maxport);\n\n\t\t\t\tif (pn > maxport) {\n\t\t\t\t\tdev_err(ctrl->dev, \"All ports busy\\n\");\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tset_bit(pn, port_mask);\n\t\t\t\tpconfig[nports].num = pn;\n\t\t\t\tpconfig[nports].ch_mask = p_rt->ch_mask;\n\t\t\t\tnports++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (direction == SNDRV_PCM_STREAM_CAPTURE)\n\t\tsconfig.direction = SDW_DATA_DIR_TX;\n\telse\n\t\tsconfig.direction = SDW_DATA_DIR_RX;\n\n\t/* hw parameters wil be ignored as we only support PDM */\n\tsconfig.ch_count = 1;\n\tsconfig.frame_rate = params_rate(params);\n\tsconfig.type = stream->type;\n\tsconfig.bps = 1;\n\tsdw_stream_add_master(&ctrl->bus, &sconfig, pconfig,\n\t\t\t      nports, stream);\nerr:\n\tif (ret) {\n\t\tfor (i = 0; i < nports; i++)\n\t\t\tclear_bit(pconfig[i].num, port_mask);\n\t}\n\n\tmutex_unlock(&ctrl->port_lock);\n\n\treturn ret;\n}\n\nstatic int qcom_swrm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\tstruct sdw_stream_runtime *sruntime = ctrl->sruntime[dai->id];\n\tint ret;\n\n\tret = qcom_swrm_stream_alloc_ports(ctrl, sruntime, params,\n\t\t\t\t\t   substream->stream);\n\tif (ret)\n\t\tqcom_swrm_stream_free_ports(ctrl, sruntime);\n\n\treturn ret;\n}\n\nstatic int qcom_swrm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\tstruct sdw_stream_runtime *sruntime = ctrl->sruntime[dai->id];\n\n\tqcom_swrm_stream_free_ports(ctrl, sruntime);\n\tsdw_stream_remove_master(&ctrl->bus, sruntime);\n\n\treturn 0;\n}\n\nstatic int qcom_swrm_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t    void *stream, int direction)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\n\tctrl->sruntime[dai->id] = stream;\n\n\treturn 0;\n}\n\nstatic void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\n\treturn ctrl->sruntime[dai->id];\n}\n\nstatic int qcom_swrm_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sdw_stream_runtime *sruntime;\n\tstruct snd_soc_dai *codec_dai;\n\tint ret, i;\n\n\tret = pm_runtime_get_sync(ctrl->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t    \"pm_runtime_get_sync failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tpm_runtime_put_noidle(ctrl->dev);\n\t\treturn ret;\n\t}\n\n\tsruntime = sdw_alloc_stream(dai->name);\n\tif (!sruntime) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tctrl->sruntime[dai->id] = sruntime;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_stream(codec_dai, sruntime,\n\t\t\t\t\t     substream->stream);\n\t\tif (ret < 0 && ret != -ENOTSUPP) {\n\t\t\tdev_err(dai->dev, \"Failed to set sdw stream on %s\\n\",\n\t\t\t\tcodec_dai->name);\n\t\t\tgoto err_set_stream;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_set_stream:\n\tsdw_release_stream(sruntime);\nerr_alloc:\n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n\n\treturn ret;\n}\n\nstatic void qcom_swrm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);\n\n\tswrm_wait_for_wr_fifo_done(ctrl);\n\tsdw_release_stream(ctrl->sruntime[dai->id]);\n\tctrl->sruntime[dai->id] = NULL;\n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n\n}\n\nstatic const struct snd_soc_dai_ops qcom_swrm_pdm_dai_ops = {\n\t.hw_params = qcom_swrm_hw_params,\n\t.hw_free = qcom_swrm_hw_free,\n\t.startup = qcom_swrm_startup,\n\t.shutdown = qcom_swrm_shutdown,\n\t.set_stream = qcom_swrm_set_sdw_stream,\n\t.get_stream = qcom_swrm_get_sdw_stream,\n};\n\nstatic const struct snd_soc_component_driver qcom_swrm_dai_component = {\n\t.name = \"soundwire\",\n};\n\nstatic int qcom_swrm_register_dais(struct qcom_swrm_ctrl *ctrl)\n{\n\tint num_dais = ctrl->num_dout_ports + ctrl->num_din_ports;\n\tstruct snd_soc_dai_driver *dais;\n\tstruct snd_soc_pcm_stream *stream;\n\tstruct device *dev = ctrl->dev;\n\tint i;\n\n\t/* PDM dais are only tested for now */\n\tdais = devm_kcalloc(dev, num_dais, sizeof(*dais), GFP_KERNEL);\n\tif (!dais)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_dais; i++) {\n\t\tdais[i].name = devm_kasprintf(dev, GFP_KERNEL, \"SDW Pin%d\", i);\n\t\tif (!dais[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i < ctrl->num_dout_ports)\n\t\t\tstream = &dais[i].playback;\n\t\telse\n\t\t\tstream = &dais[i].capture;\n\n\t\tstream->channels_min = 1;\n\t\tstream->channels_max = 1;\n\t\tstream->rates = SNDRV_PCM_RATE_48000;\n\t\tstream->formats = SNDRV_PCM_FMTBIT_S16_LE;\n\n\t\tdais[i].ops = &qcom_swrm_pdm_dai_ops;\n\t\tdais[i].id = i;\n\t}\n\n\treturn devm_snd_soc_register_component(ctrl->dev,\n\t\t\t\t\t\t&qcom_swrm_dai_component,\n\t\t\t\t\t\tdais, num_dais);\n}\n\nstatic int qcom_swrm_get_port_config(struct qcom_swrm_ctrl *ctrl)\n{\n\tstruct device_node *np = ctrl->dev->of_node;\n\tu8 off1[QCOM_SDW_MAX_PORTS];\n\tu8 off2[QCOM_SDW_MAX_PORTS];\n\tu16 si[QCOM_SDW_MAX_PORTS];\n\tu8 bp_mode[QCOM_SDW_MAX_PORTS] = { 0, };\n\tu8 hstart[QCOM_SDW_MAX_PORTS];\n\tu8 hstop[QCOM_SDW_MAX_PORTS];\n\tu8 word_length[QCOM_SDW_MAX_PORTS];\n\tu8 blk_group_count[QCOM_SDW_MAX_PORTS];\n\tu8 lane_control[QCOM_SDW_MAX_PORTS];\n\tint i, ret, nports, val;\n\tbool si_16 = false;\n\n\tctrl->reg_read(ctrl, SWRM_COMP_PARAMS, &val);\n\n\tctrl->num_dout_ports = FIELD_GET(SWRM_COMP_PARAMS_DOUT_PORTS_MASK, val);\n\tctrl->num_din_ports = FIELD_GET(SWRM_COMP_PARAMS_DIN_PORTS_MASK, val);\n\n\tret = of_property_read_u32(np, \"qcom,din-ports\", &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > ctrl->num_din_ports)\n\t\treturn -EINVAL;\n\n\tctrl->num_din_ports = val;\n\n\tret = of_property_read_u32(np, \"qcom,dout-ports\", &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > ctrl->num_dout_ports)\n\t\treturn -EINVAL;\n\n\tctrl->num_dout_ports = val;\n\n\tnports = ctrl->num_dout_ports + ctrl->num_din_ports;\n\tif (nports > QCOM_SDW_MAX_PORTS)\n\t\treturn -EINVAL;\n\n\t/* Valid port numbers are from 1-14, so mask out port 0 explicitly */\n\tset_bit(0, &ctrl->dout_port_mask);\n\tset_bit(0, &ctrl->din_port_mask);\n\n\tret = of_property_read_u8_array(np, \"qcom,ports-offset1\",\n\t\t\t\t\toff1, nports);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u8_array(np, \"qcom,ports-offset2\",\n\t\t\t\t\toff2, nports);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u8_array(np, \"qcom,ports-sinterval-low\",\n\t\t\t\t\t(u8 *)si, nports);\n\tif (ret) {\n\t\tret = of_property_read_u16_array(np, \"qcom,ports-sinterval\",\n\t\t\t\t\t\t si, nports);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsi_16 = true;\n\t}\n\n\tret = of_property_read_u8_array(np, \"qcom,ports-block-pack-mode\",\n\t\t\t\t\tbp_mode, nports);\n\tif (ret) {\n\t\tif (ctrl->version <= SWRM_VERSION_1_3_0)\n\t\t\tmemset(bp_mode, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\t\telse\n\t\t\treturn ret;\n\t}\n\n\tmemset(hstart, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\tof_property_read_u8_array(np, \"qcom,ports-hstart\", hstart, nports);\n\n\tmemset(hstop, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\tof_property_read_u8_array(np, \"qcom,ports-hstop\", hstop, nports);\n\n\tmemset(word_length, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\tof_property_read_u8_array(np, \"qcom,ports-word-length\", word_length, nports);\n\n\tmemset(blk_group_count, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\tof_property_read_u8_array(np, \"qcom,ports-block-group-count\", blk_group_count, nports);\n\n\tmemset(lane_control, SWR_INVALID_PARAM, QCOM_SDW_MAX_PORTS);\n\tof_property_read_u8_array(np, \"qcom,ports-lane-control\", lane_control, nports);\n\n\tfor (i = 0; i < nports; i++) {\n\t\t/* Valid port number range is from 1-14 */\n\t\tif (si_16)\n\t\t\tctrl->pconfig[i + 1].si = si[i];\n\t\telse\n\t\t\tctrl->pconfig[i + 1].si = ((u8 *)si)[i];\n\t\tctrl->pconfig[i + 1].off1 = off1[i];\n\t\tctrl->pconfig[i + 1].off2 = off2[i];\n\t\tctrl->pconfig[i + 1].bp_mode = bp_mode[i];\n\t\tctrl->pconfig[i + 1].hstart = hstart[i];\n\t\tctrl->pconfig[i + 1].hstop = hstop[i];\n\t\tctrl->pconfig[i + 1].word_length = word_length[i];\n\t\tctrl->pconfig[i + 1].blk_group_count = blk_group_count[i];\n\t\tctrl->pconfig[i + 1].lane_control = lane_control[i];\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int swrm_reg_show(struct seq_file *s_file, void *data)\n{\n\tstruct qcom_swrm_ctrl *ctrl = s_file->private;\n\tint reg, reg_val, ret;\n\n\tret = pm_runtime_get_sync(ctrl->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\t    \"pm_runtime_get_sync failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tpm_runtime_put_noidle(ctrl->dev);\n\t\treturn ret;\n\t}\n\n\tfor (reg = 0; reg <= ctrl->max_reg; reg += 4) {\n\t\tctrl->reg_read(ctrl, reg, &reg_val);\n\t\tseq_printf(s_file, \"0x%.3x: 0x%.2x\\n\", reg, reg_val);\n\t}\n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(swrm_reg);\n#endif\n\nstatic int qcom_swrm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sdw_master_prop *prop;\n\tstruct sdw_bus_params *params;\n\tstruct qcom_swrm_ctrl *ctrl;\n\tconst struct qcom_swrm_data *data;\n\tint ret;\n\tu32 val;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tdata = of_device_get_match_data(dev);\n\tctrl->max_reg = data->max_reg;\n\tctrl->reg_layout = data->reg_layout;\n\tctrl->rows_index = sdw_find_row_index(data->default_rows);\n\tctrl->cols_index = sdw_find_col_index(data->default_cols);\n#if IS_REACHABLE(CONFIG_SLIMBUS)\n\tif (dev->parent->bus == &slimbus_bus) {\n#else\n\tif (false) {\n#endif\n\t\tctrl->reg_read = qcom_swrm_ahb_reg_read;\n\t\tctrl->reg_write = qcom_swrm_ahb_reg_write;\n\t\tctrl->regmap = dev_get_regmap(dev->parent, NULL);\n\t\tif (!ctrl->regmap)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tctrl->reg_read = qcom_swrm_cpu_reg_read;\n\t\tctrl->reg_write = qcom_swrm_cpu_reg_write;\n\t\tctrl->mmio = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(ctrl->mmio))\n\t\t\treturn PTR_ERR(ctrl->mmio);\n\t}\n\n\tif (data->sw_clk_gate_required) {\n\t\tctrl->audio_cgcr = devm_reset_control_get_optional_exclusive(dev, \"swr_audio_cgcr\");\n\t\tif (IS_ERR(ctrl->audio_cgcr)) {\n\t\t\tdev_err(dev, \"Failed to get cgcr reset ctrl required for SW gating\\n\");\n\t\t\tret = PTR_ERR(ctrl->audio_cgcr);\n\t\t\tgoto err_init;\n\t\t}\n\t}\n\n\tctrl->irq = of_irq_get(dev->of_node, 0);\n\tif (ctrl->irq < 0) {\n\t\tret = ctrl->irq;\n\t\tgoto err_init;\n\t}\n\n\tctrl->hclk = devm_clk_get(dev, \"iface\");\n\tif (IS_ERR(ctrl->hclk)) {\n\t\tret = PTR_ERR(ctrl->hclk);\n\t\tgoto err_init;\n\t}\n\n\tclk_prepare_enable(ctrl->hclk);\n\n\tctrl->dev = dev;\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\tmutex_init(&ctrl->port_lock);\n\tinit_completion(&ctrl->broadcast);\n\tinit_completion(&ctrl->enumeration);\n\n\tctrl->bus.ops = &qcom_swrm_ops;\n\tctrl->bus.port_ops = &qcom_swrm_port_ops;\n\tctrl->bus.compute_params = &qcom_swrm_compute_params;\n\tctrl->bus.clk_stop_timeout = 300;\n\n\tret = qcom_swrm_get_port_config(ctrl);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tparams = &ctrl->bus.params;\n\tparams->max_dr_freq = DEFAULT_CLK_FREQ;\n\tparams->curr_dr_freq = DEFAULT_CLK_FREQ;\n\tparams->col = data->default_cols;\n\tparams->row = data->default_rows;\n\tctrl->reg_read(ctrl, SWRM_MCP_STATUS, &val);\n\tparams->curr_bank = val & SWRM_MCP_STATUS_BANK_NUM_MASK;\n\tparams->next_bank = !params->curr_bank;\n\n\tprop = &ctrl->bus.prop;\n\tprop->max_clk_freq = DEFAULT_CLK_FREQ;\n\tprop->num_clk_gears = 0;\n\tprop->num_clk_freq = MAX_FREQ_NUM;\n\tprop->clk_freq = &qcom_swrm_freq_tbl[0];\n\tprop->default_col = data->default_cols;\n\tprop->default_row = data->default_rows;\n\n\tctrl->reg_read(ctrl, SWRM_COMP_HW_VERSION, &ctrl->version);\n\n\tret = devm_request_threaded_irq(dev, ctrl->irq, NULL,\n\t\t\t\t\tqcom_swrm_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"soundwire\", ctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request soundwire irq\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tctrl->wake_irq = of_irq_get(dev->of_node, 1);\n\tif (ctrl->wake_irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, ctrl->wake_irq, NULL,\n\t\t\t\t\t\tqcom_swrm_wake_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\t\"swr_wake_irq\", ctrl);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request soundwire wake irq\\n\");\n\t\t\tgoto err_init;\n\t\t}\n\t}\n\n\tret = sdw_bus_master_add(&ctrl->bus, dev, dev->fwnode);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register Soundwire controller (%d)\\n\",\n\t\t\tret);\n\t\tgoto err_clk;\n\t}\n\n\tqcom_swrm_init(ctrl);\n\twait_for_completion_timeout(&ctrl->enumeration,\n\t\t\t\t    msecs_to_jiffies(TIMEOUT_MS));\n\tret = qcom_swrm_register_dais(ctrl);\n\tif (ret)\n\t\tgoto err_master_add;\n\n\tdev_info(dev, \"Qualcomm Soundwire controller v%x.%x.%x Registered\\n\",\n\t\t (ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,\n\t\t ctrl->version & 0xffff);\n\n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n#ifdef CONFIG_DEBUG_FS\n\tctrl->debugfs = debugfs_create_dir(\"qualcomm-sdw\", ctrl->bus.debugfs);\n\tdebugfs_create_file(\"qualcomm-registers\", 0400, ctrl->debugfs, ctrl,\n\t\t\t    &swrm_reg_fops);\n#endif\n\n\treturn 0;\n\nerr_master_add:\n\tsdw_bus_master_delete(&ctrl->bus);\nerr_clk:\n\tclk_disable_unprepare(ctrl->hclk);\nerr_init:\n\treturn ret;\n}\n\nstatic int qcom_swrm_remove(struct platform_device *pdev)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(&pdev->dev);\n\n\tsdw_bus_master_delete(&ctrl->bus);\n\tclk_disable_unprepare(ctrl->hclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused swrm_runtime_resume(struct device *dev)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (ctrl->wake_irq > 0) {\n\t\tif (!irqd_irq_disabled(irq_get_irq_data(ctrl->wake_irq)))\n\t\t\tdisable_irq_nosync(ctrl->wake_irq);\n\t}\n\n\tclk_prepare_enable(ctrl->hclk);\n\n\tif (ctrl->clock_stop_not_supported) {\n\t\treinit_completion(&ctrl->enumeration);\n\t\tctrl->reg_write(ctrl, SWRM_COMP_SW_RESET, 0x01);\n\t\tusleep_range(100, 105);\n\n\t\tqcom_swrm_init(ctrl);\n\n\t\tusleep_range(100, 105);\n\t\tif (!swrm_wait_for_frame_gen_enabled(ctrl))\n\t\t\tdev_err(ctrl->dev, \"link failed to connect\\n\");\n\n\t\t/* wait for hw enumeration to complete */\n\t\twait_for_completion_timeout(&ctrl->enumeration,\n\t\t\t\t\t    msecs_to_jiffies(TIMEOUT_MS));\n\t\tqcom_swrm_get_device_status(ctrl);\n\t\tsdw_handle_slave_status(&ctrl->bus, ctrl->status);\n\t} else {\n\t\treset_control_reset(ctrl->audio_cgcr);\n\n\t\tif (ctrl->version == SWRM_VERSION_1_7_0) {\n\t\t\tctrl->reg_write(ctrl, SWRM_LINK_MANAGER_EE, SWRM_EE_CPU);\n\t\t\tctrl->reg_write(ctrl, SWRM_MCP_BUS_CTRL,\n\t\t\t\t\tSWRM_MCP_BUS_CLK_START << SWRM_EE_CPU);\n\t\t} else if (ctrl->version >= SWRM_VERSION_2_0_0) {\n\t\t\tctrl->reg_write(ctrl, SWRM_LINK_MANAGER_EE, SWRM_EE_CPU);\n\t\t\tctrl->reg_write(ctrl, SWRM_V2_0_CLK_CTRL,\n\t\t\t\t\tSWRM_V2_0_CLK_CTRL_CLK_START);\n\t\t} else {\n\t\t\tctrl->reg_write(ctrl, SWRM_MCP_BUS_CTRL, SWRM_MCP_BUS_CLK_START);\n\t\t}\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CLEAR],\n\t\t\tSWRM_INTERRUPT_STATUS_MASTER_CLASH_DET);\n\n\t\tctrl->intr_mask |= SWRM_INTERRUPT_STATUS_MASTER_CLASH_DET;\n\t\tif (ctrl->version < SWRM_VERSION_2_0_0)\n\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\tctrl->reg_layout[SWRM_REG_INTERRUPT_MASK_ADDR],\n\t\t\t\t\tctrl->intr_mask);\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\tctrl->intr_mask);\n\n\t\tusleep_range(100, 105);\n\t\tif (!swrm_wait_for_frame_gen_enabled(ctrl))\n\t\t\tdev_err(ctrl->dev, \"link failed to connect\\n\");\n\n\t\tret = sdw_bus_exit_clk_stop(&ctrl->bus);\n\t\tif (ret < 0)\n\t\t\tdev_err(ctrl->dev, \"bus failed to exit clock stop %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused swrm_runtime_suspend(struct device *dev)\n{\n\tstruct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dev);\n\tint ret;\n\n\tswrm_wait_for_wr_fifo_done(ctrl);\n\tif (!ctrl->clock_stop_not_supported) {\n\t\t/* Mask bus clash interrupt */\n\t\tctrl->intr_mask &= ~SWRM_INTERRUPT_STATUS_MASTER_CLASH_DET;\n\t\tif (ctrl->version < SWRM_VERSION_2_0_0)\n\t\t\tctrl->reg_write(ctrl,\n\t\t\t\t\tctrl->reg_layout[SWRM_REG_INTERRUPT_MASK_ADDR],\n\t\t\t\t\tctrl->intr_mask);\n\t\tctrl->reg_write(ctrl, ctrl->reg_layout[SWRM_REG_INTERRUPT_CPU_EN],\n\t\t\t\tctrl->intr_mask);\n\t\t/* Prepare slaves for clock stop */\n\t\tret = sdw_bus_prep_clk_stop(&ctrl->bus);\n\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\tdev_err(dev, \"prepare clock stop failed %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_bus_clk_stop(&ctrl->bus);\n\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\tdev_err(dev, \"bus clock stop failed %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclk_disable_unprepare(ctrl->hclk);\n\n\tusleep_range(300, 305);\n\n\tif (ctrl->wake_irq > 0) {\n\t\tif (irqd_irq_disabled(irq_get_irq_data(ctrl->wake_irq)))\n\t\t\tenable_irq(ctrl->wake_irq);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops swrm_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(swrm_runtime_suspend, swrm_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id qcom_swrm_of_match[] = {\n\t{ .compatible = \"qcom,soundwire-v1.3.0\", .data = &swrm_v1_3_data },\n\t{ .compatible = \"qcom,soundwire-v1.5.1\", .data = &swrm_v1_5_data },\n\t{ .compatible = \"qcom,soundwire-v1.6.0\", .data = &swrm_v1_6_data },\n\t{ .compatible = \"qcom,soundwire-v1.7.0\", .data = &swrm_v1_5_data },\n\t{ .compatible = \"qcom,soundwire-v2.0.0\", .data = &swrm_v2_0_data },\n\t{/* sentinel */},\n};\n\nMODULE_DEVICE_TABLE(of, qcom_swrm_of_match);\n\nstatic struct platform_driver qcom_swrm_driver = {\n\t.probe\t= &qcom_swrm_probe,\n\t.remove = &qcom_swrm_remove,\n\t.driver = {\n\t\t.name\t= \"qcom-soundwire\",\n\t\t.of_match_table = qcom_swrm_of_match,\n\t\t.pm = &swrm_dev_pm_ops,\n\t}\n};\nmodule_platform_driver(qcom_swrm_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm soundwire driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}