{
  "module_name": "intel_bus_common.c",
  "hash_id": "f5bab2faa217296ee2b4682741c22f91cccc10737c2267e36ddb1ebe314201ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/intel_bus_common.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_intel.h>\n#include \"cadence_master.h\"\n#include \"bus.h\"\n#include \"intel.h\"\n\nint intel_start_bus(struct sdw_intel *sdw)\n{\n\tstruct device *dev = sdw->cdns.dev;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_bus *bus = &cdns->bus;\n\tint ret;\n\n\t \n\tif (bus->multi_link)\n\t\tsdw_intel_sync_arm(sdw);\n\n\tret = sdw_cdns_init(cdns);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to initialize Cadence IP: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tsdw_cdns_config_update(cdns);\n\n\tif (bus->multi_link) {\n\t\tret = sdw_intel_sync_go(sdw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: sync go failed: %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sdw_cdns_config_update_set_wait(cdns);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: CONFIG_UPDATE BIT still set\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = sdw_cdns_exit_reset(cdns);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to exit bus reset sequence: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = sdw_cdns_enable_interrupt(cdns, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: cannot enable interrupts: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tsdw_cdns_check_self_clearing_bits(cdns, __func__,\n\t\t\t\t\t  true, INTEL_MASTER_RESET_ITERATIONS);\n\n\treturn 0;\n}\n\nint intel_start_bus_after_reset(struct sdw_intel *sdw)\n{\n\tstruct device *dev = sdw->cdns.dev;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_bus *bus = &cdns->bus;\n\tbool clock_stop0;\n\tint status;\n\tint ret;\n\n\t \n\tclock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);\n\n\tif (!clock_stop0) {\n\n\t\t \n\n\t\tstatus = SDW_UNATTACH_REQUEST_MASTER_RESET;\n\t\tsdw_clear_slave_status(bus, status);\n\n\t\t \n\t\tif (bus->multi_link)\n\t\t\tsdw_intel_sync_arm(sdw);\n\n\t\t \n\t\tsdw_cdns_init(&sdw->cdns);\n\n\t} else {\n\t\tret = sdw_cdns_enable_interrupt(cdns, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"cannot enable interrupts during resume\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sdw_cdns_clock_restart(cdns, !clock_stop0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to restart clock during resume\\n\");\n\t\tif (!clock_stop0)\n\t\t\tsdw_cdns_enable_interrupt(cdns, false);\n\t\treturn ret;\n\t}\n\n\tif (!clock_stop0) {\n\t\tsdw_cdns_config_update(cdns);\n\n\t\tif (bus->multi_link) {\n\t\t\tret = sdw_intel_sync_go(sdw);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdw->cdns.dev, \"sync go failed during resume\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = sdw_cdns_config_update_set_wait(cdns);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: CONFIG_UPDATE BIT still set\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_cdns_exit_reset(cdns);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"unable to exit bus reset sequence during resume\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_cdns_enable_interrupt(cdns, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"cannot enable interrupts during resume\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\tsdw_cdns_check_self_clearing_bits(cdns, __func__, true, INTEL_MASTER_RESET_ITERATIONS);\n\n\treturn 0;\n}\n\nvoid intel_check_clock_stop(struct sdw_intel *sdw)\n{\n\tstruct device *dev = sdw->cdns.dev;\n\tbool clock_stop0;\n\n\tclock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);\n\tif (!clock_stop0)\n\t\tdev_err(dev, \"%s: invalid configuration, clock was not stopped\\n\", __func__);\n}\n\nint intel_start_bus_after_clock_stop(struct sdw_intel *sdw)\n{\n\tstruct device *dev = sdw->cdns.dev;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tint ret;\n\n\tret = sdw_cdns_clock_restart(cdns, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: unable to restart clock: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = sdw_cdns_enable_interrupt(cdns, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: cannot enable interrupts: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tsdw_cdns_check_self_clearing_bits(cdns, __func__, true, INTEL_MASTER_RESET_ITERATIONS);\n\n\treturn 0;\n}\n\nint intel_stop_bus(struct sdw_intel *sdw, bool clock_stop)\n{\n\tstruct device *dev = sdw->cdns.dev;\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tbool wake_enable = false;\n\tint ret;\n\n\tif (clock_stop) {\n\t\tret = sdw_cdns_clock_stop(cdns, true);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"%s: cannot stop clock: %d\\n\", __func__, ret);\n\t\telse\n\t\t\twake_enable = true;\n\t}\n\n\tret = sdw_cdns_enable_interrupt(cdns, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: cannot disable interrupts: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = sdw_intel_link_power_down(sdw);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: Link power down failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tsdw_intel_shim_wake(sdw, wake_enable);\n\n\treturn 0;\n}\n\n \n\nint intel_pre_bank_switch(struct sdw_intel *sdw)\n{\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_bus *bus = &cdns->bus;\n\n\t \n\tif (!bus->multi_link)\n\t\treturn 0;\n\n\tsdw_intel_sync_arm(sdw);\n\n\treturn 0;\n}\n\nint intel_post_bank_switch(struct sdw_intel *sdw)\n{\n\tstruct sdw_cdns *cdns = &sdw->cdns;\n\tstruct sdw_bus *bus = &cdns->bus;\n\tint ret = 0;\n\n\t \n\tif (!bus->multi_link)\n\t\treturn 0;\n\n\tmutex_lock(sdw->link_res->shim_lock);\n\n\t \n\tif (sdw_intel_sync_check_cmdsync_unlocked(sdw))\n\t\tret = sdw_intel_sync_go_unlocked(sdw);\n\n\tmutex_unlock(sdw->link_res->shim_lock);\n\n\tif (ret < 0)\n\t\tdev_err(sdw->cdns.dev, \"Post bank switch failed: %d\\n\", ret);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}