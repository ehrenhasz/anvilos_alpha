{
  "module_name": "bus.c",
  "hash_id": "d14471636fdfec98de92d83ed808b15c9d72b6b339aa1c1011b6db7bc354e5eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/bus.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include \"bus.h\"\n#include \"irq.h\"\n#include \"sysfs_local.h\"\n\nstatic DEFINE_IDA(sdw_bus_ida);\n\nstatic int sdw_get_id(struct sdw_bus *bus)\n{\n\tint rc = ida_alloc(&sdw_bus_ida, GFP_KERNEL);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tbus->id = rc;\n\treturn 0;\n}\n\n \nint sdw_bus_master_add(struct sdw_bus *bus, struct device *parent,\n\t\t       struct fwnode_handle *fwnode)\n{\n\tstruct sdw_master_prop *prop = NULL;\n\tint ret;\n\n\tif (!parent) {\n\t\tpr_err(\"SoundWire parent device is not set\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = sdw_get_id(bus);\n\tif (ret < 0) {\n\t\tdev_err(parent, \"Failed to get bus id\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sdw_master_device_add(bus, parent, fwnode);\n\tif (ret < 0) {\n\t\tdev_err(parent, \"Failed to add master device at link %d\\n\",\n\t\t\tbus->link_id);\n\t\treturn ret;\n\t}\n\n\tif (!bus->ops) {\n\t\tdev_err(bus->dev, \"SoundWire Bus ops are not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bus->compute_params) {\n\t\tdev_err(bus->dev,\n\t\t\t\"Bandwidth allocation not configured, compute_params no set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlockdep_register_key(&bus->msg_lock_key);\n\t__mutex_init(&bus->msg_lock, \"msg_lock\", &bus->msg_lock_key);\n\n\tlockdep_register_key(&bus->bus_lock_key);\n\t__mutex_init(&bus->bus_lock, \"bus_lock\", &bus->bus_lock_key);\n\n\tINIT_LIST_HEAD(&bus->slaves);\n\tINIT_LIST_HEAD(&bus->m_rt_list);\n\n\t \n\tbus->multi_link = false;\n\tif (bus->ops->read_prop) {\n\t\tret = bus->ops->read_prop(bus);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Bus read properties failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsdw_bus_debugfs_init(bus);\n\n\t \n\n\t \n\t*bus->assigned = ~GENMASK(SDW_BROADCAST_DEV_NUM, SDW_ENUM_DEV_NUM);\n\n\t \n\tset_bit(SDW_ENUM_DEV_NUM, bus->assigned);\n\tset_bit(SDW_BROADCAST_DEV_NUM, bus->assigned);\n\n\t \n\tset_bit(SDW_GROUP12_DEV_NUM, bus->assigned);\n\tset_bit(SDW_GROUP13_DEV_NUM, bus->assigned);\n\tset_bit(SDW_MASTER_DEV_NUM, bus->assigned);\n\n\t \n\tif (IS_ENABLED(CONFIG_ACPI) && ACPI_HANDLE(bus->dev))\n\t\tret = sdw_acpi_find_slaves(bus);\n\telse if (IS_ENABLED(CONFIG_OF) && bus->dev->of_node)\n\t\tret = sdw_of_find_slaves(bus);\n\telse\n\t\tret = -ENOTSUPP;  \n\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"Finding slaves failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tprop = &bus->prop;\n\tbus->params.max_dr_freq = prop->max_clk_freq * SDW_DOUBLE_RATE_FACTOR;\n\tbus->params.curr_dr_freq = bus->params.max_dr_freq;\n\tbus->params.curr_bank = SDW_BANK0;\n\tbus->params.next_bank = SDW_BANK1;\n\n\tret = sdw_irq_create(bus, fwnode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_bus_master_add);\n\nstatic int sdw_delete_slave(struct device *dev, void *data)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct sdw_bus *bus = slave->bus;\n\n\tpm_runtime_disable(dev);\n\n\tsdw_slave_debugfs_exit(slave);\n\n\tmutex_lock(&bus->bus_lock);\n\n\tif (slave->dev_num) {  \n\t\tclear_bit(slave->dev_num, bus->assigned);\n\t\tif (bus->ops && bus->ops->put_device_num)\n\t\t\tbus->ops->put_device_num(bus, slave);\n\t}\n\tlist_del_init(&slave->node);\n\tmutex_unlock(&bus->bus_lock);\n\n\tdevice_unregister(dev);\n\treturn 0;\n}\n\n \nvoid sdw_bus_master_delete(struct sdw_bus *bus)\n{\n\tdevice_for_each_child(bus->dev, NULL, sdw_delete_slave);\n\n\tsdw_irq_delete(bus);\n\n\tsdw_master_device_del(bus);\n\n\tsdw_bus_debugfs_exit(bus);\n\tlockdep_unregister_key(&bus->bus_lock_key);\n\tlockdep_unregister_key(&bus->msg_lock_key);\n\tida_free(&sdw_bus_ida, bus->id);\n}\nEXPORT_SYMBOL(sdw_bus_master_delete);\n\n \n\nstatic inline int find_response_code(enum sdw_command_response resp)\n{\n\tswitch (resp) {\n\tcase SDW_CMD_OK:\n\t\treturn 0;\n\n\tcase SDW_CMD_IGNORED:\n\t\treturn -ENODATA;\n\n\tcase SDW_CMD_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic inline int do_transfer(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tint retry = bus->prop.err_threshold;\n\tenum sdw_command_response resp;\n\tint ret = 0, i;\n\n\tfor (i = 0; i <= retry; i++) {\n\t\tresp = bus->ops->xfer_msg(bus, msg);\n\t\tret = find_response_code(resp);\n\n\t\t \n\t\tif (ret == 0 || ret == -ENODATA)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int do_transfer_defer(struct sdw_bus *bus,\n\t\t\t\t    struct sdw_msg *msg)\n{\n\tstruct sdw_defer *defer = &bus->defer_msg;\n\tint retry = bus->prop.err_threshold;\n\tenum sdw_command_response resp;\n\tint ret = 0, i;\n\n\tdefer->msg = msg;\n\tdefer->length = msg->len;\n\tinit_completion(&defer->complete);\n\n\tfor (i = 0; i <= retry; i++) {\n\t\tresp = bus->ops->xfer_msg_defer(bus);\n\t\tret = find_response_code(resp);\n\t\t \n\t\tif (ret == 0 || ret == -ENODATA)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sdw_transfer_unlocked(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tint ret;\n\n\tret = do_transfer(bus, msg);\n\tif (ret != 0 && ret != -ENODATA)\n\t\tdev_err(bus->dev, \"trf on Slave %d failed:%d %s addr %x count %d\\n\",\n\t\t\tmsg->dev_num, ret,\n\t\t\t(msg->flags & SDW_MSG_FLAG_WRITE) ? \"write\" : \"read\",\n\t\t\tmsg->addr, msg->len);\n\n\treturn ret;\n}\n\n \nint sdw_transfer(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tint ret;\n\n\tmutex_lock(&bus->msg_lock);\n\n\tret = sdw_transfer_unlocked(bus, msg);\n\n\tmutex_unlock(&bus->msg_lock);\n\n\treturn ret;\n}\n\n \nvoid sdw_show_ping_status(struct sdw_bus *bus, bool sync_delay)\n{\n\tu32 status;\n\n\tif (!bus->ops->read_ping_status)\n\t\treturn;\n\n\t \n\tif (sync_delay)\n\t\tusleep_range(10000, 15000);\n\n\tmutex_lock(&bus->msg_lock);\n\n\tstatus = bus->ops->read_ping_status(bus);\n\n\tmutex_unlock(&bus->msg_lock);\n\n\tif (!status)\n\t\tdev_warn(bus->dev, \"%s: no peripherals attached\\n\", __func__);\n\telse\n\t\tdev_dbg(bus->dev, \"PING status: %#x\\n\", status);\n}\nEXPORT_SYMBOL(sdw_show_ping_status);\n\n \nint sdw_transfer_defer(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tint ret;\n\n\tif (!bus->ops->xfer_msg_defer)\n\t\treturn -ENOTSUPP;\n\n\tret = do_transfer_defer(bus, msg);\n\tif (ret != 0 && ret != -ENODATA)\n\t\tdev_err(bus->dev, \"Defer trf on Slave %d failed:%d\\n\",\n\t\t\tmsg->dev_num, ret);\n\n\treturn ret;\n}\n\nint sdw_fill_msg(struct sdw_msg *msg, struct sdw_slave *slave,\n\t\t u32 addr, size_t count, u16 dev_num, u8 flags, u8 *buf)\n{\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->addr = addr;  \n\tmsg->len = count;\n\tmsg->dev_num = dev_num;\n\tmsg->flags = flags;\n\tmsg->buf = buf;\n\n\tif (addr < SDW_REG_NO_PAGE)  \n\t\treturn 0;\n\n\tif (addr >= SDW_REG_MAX) {  \n\t\tpr_err(\"SDW: Invalid address %x passed\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (addr < SDW_REG_OPTIONAL_PAGE) {  \n\t\tif (slave && !slave->prop.paging_support)\n\t\t\treturn 0;\n\t\t \n\t}\n\n\t \n\tif (dev_num == SDW_ENUM_DEV_NUM || dev_num == SDW_BROADCAST_DEV_NUM) {\n\t\tpr_err(\"SDW: Invalid device for paging :%d\\n\", dev_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!slave) {\n\t\tpr_err(\"SDW: No slave for paging addr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!slave->prop.paging_support) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"address %x needs paging but no support\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg->addr_page1 = FIELD_GET(SDW_SCP_ADDRPAGE1_MASK, addr);\n\tmsg->addr_page2 = FIELD_GET(SDW_SCP_ADDRPAGE2_MASK, addr);\n\tmsg->addr |= BIT(15);\n\tmsg->page = true;\n\n\treturn 0;\n}\n\n \n\nstatic int sdw_ntransfer_no_pm(struct sdw_slave *slave, u32 addr, u8 flags,\n\t\t\t       size_t count, u8 *val)\n{\n\tstruct sdw_msg msg;\n\tsize_t size;\n\tint ret;\n\n\twhile (count) {\n\t\t\n\t\tsize = min_t(size_t, count, (SDW_REGADDR + 1) - (addr & SDW_REGADDR));\n\n\t\tret = sdw_fill_msg(&msg, slave, addr, size, slave->dev_num, flags, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = sdw_transfer(slave->bus, &msg);\n\t\tif (ret < 0 && !slave->is_mockup_device)\n\t\t\treturn ret;\n\n\t\taddr += size;\n\t\tval += size;\n\t\tcount -= size;\n\t}\n\n\treturn 0;\n}\n\n \nint sdw_nread_no_pm(struct sdw_slave *slave, u32 addr, size_t count, u8 *val)\n{\n\treturn sdw_ntransfer_no_pm(slave, addr, SDW_MSG_FLAG_READ, count, val);\n}\nEXPORT_SYMBOL(sdw_nread_no_pm);\n\n \nint sdw_nwrite_no_pm(struct sdw_slave *slave, u32 addr, size_t count, const u8 *val)\n{\n\treturn sdw_ntransfer_no_pm(slave, addr, SDW_MSG_FLAG_WRITE, count, (u8 *)val);\n}\nEXPORT_SYMBOL(sdw_nwrite_no_pm);\n\n \nint sdw_write_no_pm(struct sdw_slave *slave, u32 addr, u8 value)\n{\n\treturn sdw_nwrite_no_pm(slave, addr, 1, &value);\n}\nEXPORT_SYMBOL(sdw_write_no_pm);\n\nstatic int\nsdw_bread_no_pm(struct sdw_bus *bus, u16 dev_num, u32 addr)\n{\n\tstruct sdw_msg msg;\n\tu8 buf;\n\tint ret;\n\n\tret = sdw_fill_msg(&msg, NULL, addr, 1, dev_num,\n\t\t\t   SDW_MSG_FLAG_READ, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sdw_transfer(bus, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf;\n}\n\nstatic int\nsdw_bwrite_no_pm(struct sdw_bus *bus, u16 dev_num, u32 addr, u8 value)\n{\n\tstruct sdw_msg msg;\n\tint ret;\n\n\tret = sdw_fill_msg(&msg, NULL, addr, 1, dev_num,\n\t\t\t   SDW_MSG_FLAG_WRITE, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sdw_transfer(bus, &msg);\n}\n\nint sdw_bread_no_pm_unlocked(struct sdw_bus *bus, u16 dev_num, u32 addr)\n{\n\tstruct sdw_msg msg;\n\tu8 buf;\n\tint ret;\n\n\tret = sdw_fill_msg(&msg, NULL, addr, 1, dev_num,\n\t\t\t   SDW_MSG_FLAG_READ, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sdw_transfer_unlocked(bus, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf;\n}\nEXPORT_SYMBOL(sdw_bread_no_pm_unlocked);\n\nint sdw_bwrite_no_pm_unlocked(struct sdw_bus *bus, u16 dev_num, u32 addr, u8 value)\n{\n\tstruct sdw_msg msg;\n\tint ret;\n\n\tret = sdw_fill_msg(&msg, NULL, addr, 1, dev_num,\n\t\t\t   SDW_MSG_FLAG_WRITE, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sdw_transfer_unlocked(bus, &msg);\n}\nEXPORT_SYMBOL(sdw_bwrite_no_pm_unlocked);\n\n \nint sdw_read_no_pm(struct sdw_slave *slave, u32 addr)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = sdw_nread_no_pm(slave, addr, 1, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn buf;\n}\nEXPORT_SYMBOL(sdw_read_no_pm);\n\nint sdw_update_no_pm(struct sdw_slave *slave, u32 addr, u8 mask, u8 val)\n{\n\tint tmp;\n\n\ttmp = sdw_read_no_pm(slave, addr);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\ttmp = (tmp & ~mask) | val;\n\treturn sdw_write_no_pm(slave, addr, tmp);\n}\nEXPORT_SYMBOL(sdw_update_no_pm);\n\n \nint sdw_update(struct sdw_slave *slave, u32 addr, u8 mask, u8 val)\n{\n\tint tmp;\n\n\ttmp = sdw_read(slave, addr);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\ttmp = (tmp & ~mask) | val;\n\treturn sdw_write(slave, addr, tmp);\n}\nEXPORT_SYMBOL(sdw_update);\n\n \nint sdw_nread(struct sdw_slave *slave, u32 addr, size_t count, u8 *val)\n{\n\tint ret;\n\n\tret = pm_runtime_get_sync(&slave->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_noidle(&slave->dev);\n\t\treturn ret;\n\t}\n\n\tret = sdw_nread_no_pm(slave, addr, count, val);\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put(&slave->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_nread);\n\n \nint sdw_nwrite(struct sdw_slave *slave, u32 addr, size_t count, const u8 *val)\n{\n\tint ret;\n\n\tret = pm_runtime_get_sync(&slave->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_noidle(&slave->dev);\n\t\treturn ret;\n\t}\n\n\tret = sdw_nwrite_no_pm(slave, addr, count, val);\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put(&slave->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_nwrite);\n\n \nint sdw_read(struct sdw_slave *slave, u32 addr)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = sdw_nread(slave, addr, 1, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf;\n}\nEXPORT_SYMBOL(sdw_read);\n\n \nint sdw_write(struct sdw_slave *slave, u32 addr, u8 value)\n{\n\treturn sdw_nwrite(slave, addr, 1, &value);\n}\nEXPORT_SYMBOL(sdw_write);\n\n \n\n \nstatic struct sdw_slave *sdw_get_slave(struct sdw_bus *bus, int i)\n{\n\tstruct sdw_slave *slave;\n\n\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\tif (slave->dev_num == i)\n\t\t\treturn slave;\n\t}\n\n\treturn NULL;\n}\n\nint sdw_compare_devid(struct sdw_slave *slave, struct sdw_slave_id id)\n{\n\tif (slave->id.mfg_id != id.mfg_id ||\n\t    slave->id.part_id != id.part_id ||\n\t    slave->id.class_id != id.class_id ||\n\t    (slave->id.unique_id != SDW_IGNORED_UNIQUE_ID &&\n\t     slave->id.unique_id != id.unique_id))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_compare_devid);\n\n \nstatic int sdw_get_device_num(struct sdw_slave *slave)\n{\n\tstruct sdw_bus *bus = slave->bus;\n\tint bit;\n\n\tif (bus->ops && bus->ops->get_device_num) {\n\t\tbit = bus->ops->get_device_num(bus, slave);\n\t\tif (bit < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tbit = find_first_zero_bit(bus->assigned, SDW_MAX_DEVICES);\n\t\tif (bit == SDW_MAX_DEVICES) {\n\t\t\tbit = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tset_bit(bit, bus->assigned);\n\nerr:\n\treturn bit;\n}\n\nstatic int sdw_assign_device_num(struct sdw_slave *slave)\n{\n\tstruct sdw_bus *bus = slave->bus;\n\tint ret, dev_num;\n\tbool new_device = false;\n\n\t \n\tif (!slave->dev_num) {\n\t\tif (!slave->dev_num_sticky) {\n\t\t\tmutex_lock(&slave->bus->bus_lock);\n\t\t\tdev_num = sdw_get_device_num(slave);\n\t\t\tmutex_unlock(&slave->bus->bus_lock);\n\t\t\tif (dev_num < 0) {\n\t\t\t\tdev_err(bus->dev, \"Get dev_num failed: %d\\n\",\n\t\t\t\t\tdev_num);\n\t\t\t\treturn dev_num;\n\t\t\t}\n\t\t\tslave->dev_num = dev_num;\n\t\t\tslave->dev_num_sticky = dev_num;\n\t\t\tnew_device = true;\n\t\t} else {\n\t\t\tslave->dev_num = slave->dev_num_sticky;\n\t\t}\n\t}\n\n\tif (!new_device)\n\t\tdev_dbg(bus->dev,\n\t\t\t\"Slave already registered, reusing dev_num:%d\\n\",\n\t\t\tslave->dev_num);\n\n\t \n\tdev_num = slave->dev_num;\n\tslave->dev_num = 0;\n\n\tret = sdw_write_no_pm(slave, SDW_SCP_DEVNUMBER, dev_num);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"Program device_num %d failed: %d\\n\",\n\t\t\tdev_num, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tslave->dev_num = slave->dev_num_sticky;\n\n\tif (bus->ops && bus->ops->new_peripheral_assigned)\n\t\tbus->ops->new_peripheral_assigned(bus, slave, dev_num);\n\n\treturn 0;\n}\n\nvoid sdw_extract_slave_id(struct sdw_bus *bus,\n\t\t\t  u64 addr, struct sdw_slave_id *id)\n{\n\tdev_dbg(bus->dev, \"SDW Slave Addr: %llx\\n\", addr);\n\n\tid->sdw_version = SDW_VERSION(addr);\n\tid->unique_id = SDW_UNIQUE_ID(addr);\n\tid->mfg_id = SDW_MFG_ID(addr);\n\tid->part_id = SDW_PART_ID(addr);\n\tid->class_id = SDW_CLASS_ID(addr);\n\n\tdev_dbg(bus->dev,\n\t\t\"SDW Slave class_id 0x%02x, mfg_id 0x%04x, part_id 0x%04x, unique_id 0x%x, version 0x%x\\n\",\n\t\tid->class_id, id->mfg_id, id->part_id, id->unique_id, id->sdw_version);\n}\nEXPORT_SYMBOL(sdw_extract_slave_id);\n\nstatic int sdw_program_device_num(struct sdw_bus *bus, bool *programmed)\n{\n\tu8 buf[SDW_NUM_DEV_ID_REGISTERS] = {0};\n\tstruct sdw_slave *slave, *_s;\n\tstruct sdw_slave_id id;\n\tstruct sdw_msg msg;\n\tbool found;\n\tint count = 0, ret;\n\tu64 addr;\n\n\t*programmed = false;\n\n\t \n\tret = sdw_fill_msg(&msg, NULL, SDW_SCP_DEVID_0,\n\t\t\t   SDW_NUM_DEV_ID_REGISTERS, 0, SDW_MSG_FLAG_READ, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdo {\n\t\tret = sdw_transfer(bus, &msg);\n\t\tif (ret == -ENODATA) {  \n\t\t\tdev_dbg(bus->dev, \"No more devices to enumerate\\n\");\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(bus->dev, \"DEVID read fail:%d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\taddr = buf[5] | (buf[4] << 8) | (buf[3] << 16) |\n\t\t\t((u64)buf[2] << 24) | ((u64)buf[1] << 32) |\n\t\t\t((u64)buf[0] << 40);\n\n\t\tsdw_extract_slave_id(bus, addr, &id);\n\n\t\tfound = false;\n\t\t \n\t\tlist_for_each_entry_safe(slave, _s, &bus->slaves, node) {\n\t\t\tif (sdw_compare_devid(slave, id) == 0) {\n\t\t\t\tfound = true;\n\n\t\t\t\t \n\t\t\t\tif (slave->status != SDW_SLAVE_UNATTACHED)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t \n\t\t\t\tret = sdw_assign_device_num(slave);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(bus->dev,\n\t\t\t\t\t\t\"Assign dev_num failed:%d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t*programmed = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\t \n\n\t\t\t \n\t\t\tsdw_slave_add(bus, &id, NULL);\n\n\t\t\tdev_err(bus->dev, \"Slave Entry not found\\n\");\n\t\t}\n\n\t\tcount++;\n\n\t\t \n\n\t} while (ret == 0 && count < (SDW_MAX_DEVICES * 2));\n\n\treturn ret;\n}\n\nstatic void sdw_modify_slave_status(struct sdw_slave *slave,\n\t\t\t\t    enum sdw_slave_status status)\n{\n\tstruct sdw_bus *bus = slave->bus;\n\n\tmutex_lock(&bus->bus_lock);\n\n\tdev_vdbg(bus->dev,\n\t\t \"changing status slave %d status %d new status %d\\n\",\n\t\t slave->dev_num, slave->status, status);\n\n\tif (status == SDW_SLAVE_UNATTACHED) {\n\t\tdev_dbg(&slave->dev,\n\t\t\t\"initializing enumeration and init completion for Slave %d\\n\",\n\t\t\tslave->dev_num);\n\n\t\treinit_completion(&slave->enumeration_complete);\n\t\treinit_completion(&slave->initialization_complete);\n\n\t} else if ((status == SDW_SLAVE_ATTACHED) &&\n\t\t   (slave->status == SDW_SLAVE_UNATTACHED)) {\n\t\tdev_dbg(&slave->dev,\n\t\t\t\"signaling enumeration completion for Slave %d\\n\",\n\t\t\tslave->dev_num);\n\n\t\tcomplete_all(&slave->enumeration_complete);\n\t}\n\tslave->status = status;\n\tmutex_unlock(&bus->bus_lock);\n}\n\nstatic int sdw_slave_clk_stop_callback(struct sdw_slave *slave,\n\t\t\t\t       enum sdw_clk_stop_mode mode,\n\t\t\t\t       enum sdw_clk_stop_type type)\n{\n\tint ret = 0;\n\n\tmutex_lock(&slave->sdw_dev_lock);\n\n\tif (slave->probed)  {\n\t\tstruct device *dev = &slave->dev;\n\t\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\t\tif (drv->ops && drv->ops->clk_stop)\n\t\t\tret = drv->ops->clk_stop(slave, mode, type);\n\t}\n\n\tmutex_unlock(&slave->sdw_dev_lock);\n\n\treturn ret;\n}\n\nstatic int sdw_slave_clk_stop_prepare(struct sdw_slave *slave,\n\t\t\t\t      enum sdw_clk_stop_mode mode,\n\t\t\t\t      bool prepare)\n{\n\tbool wake_en;\n\tu32 val = 0;\n\tint ret;\n\n\twake_en = slave->prop.wake_capable;\n\n\tif (prepare) {\n\t\tval = SDW_SCP_SYSTEMCTRL_CLK_STP_PREP;\n\n\t\tif (mode == SDW_CLK_STOP_MODE1)\n\t\t\tval |= SDW_SCP_SYSTEMCTRL_CLK_STP_MODE1;\n\n\t\tif (wake_en)\n\t\t\tval |= SDW_SCP_SYSTEMCTRL_WAKE_UP_EN;\n\t} else {\n\t\tret = sdw_read_no_pm(slave, SDW_SCP_SYSTEMCTRL);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENODATA)\n\t\t\t\tdev_err(&slave->dev, \"SDW_SCP_SYSTEMCTRL read failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tval = ret;\n\t\tval &= ~(SDW_SCP_SYSTEMCTRL_CLK_STP_PREP);\n\t}\n\n\tret = sdw_write_no_pm(slave, SDW_SCP_SYSTEMCTRL, val);\n\n\tif (ret < 0 && ret != -ENODATA)\n\t\tdev_err(&slave->dev, \"SDW_SCP_SYSTEMCTRL write failed:%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int sdw_bus_wait_for_clk_prep_deprep(struct sdw_bus *bus, u16 dev_num)\n{\n\tint retry = bus->clk_stop_timeout;\n\tint val;\n\n\tdo {\n\t\tval = sdw_bread_no_pm(bus, dev_num, SDW_SCP_STAT);\n\t\tif (val < 0) {\n\t\t\tif (val != -ENODATA)\n\t\t\t\tdev_err(bus->dev, \"SDW_SCP_STAT bread failed:%d\\n\", val);\n\t\t\treturn val;\n\t\t}\n\t\tval &= SDW_SCP_STAT_CLK_STP_NF;\n\t\tif (!val) {\n\t\t\tdev_dbg(bus->dev, \"clock stop prep/de-prep done slave:%d\\n\",\n\t\t\t\tdev_num);\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t\tretry--;\n\t} while (retry);\n\n\tdev_err(bus->dev, \"clock stop prep/de-prep failed slave:%d\\n\",\n\t\tdev_num);\n\n\treturn -ETIMEDOUT;\n}\n\n \nint sdw_bus_prep_clk_stop(struct sdw_bus *bus)\n{\n\tbool simple_clk_stop = true;\n\tstruct sdw_slave *slave;\n\tbool is_slave = false;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\tif (!slave->dev_num)\n\t\t\tcontinue;\n\n\t\tif (slave->status != SDW_SLAVE_ATTACHED &&\n\t\t    slave->status != SDW_SLAVE_ALERT)\n\t\t\tcontinue;\n\n\t\t \n\t\tis_slave = true;\n\n\t\tret = sdw_slave_clk_stop_callback(slave,\n\t\t\t\t\t\t  SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t  SDW_CLK_PRE_PREPARE);\n\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\tdev_err(&slave->dev, \"clock stop pre-prepare cb failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!slave->prop.simple_clk_stop_capable) {\n\t\t\tsimple_clk_stop = false;\n\n\t\t\tret = sdw_slave_clk_stop_prepare(slave,\n\t\t\t\t\t\t\t SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t\t true);\n\t\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\t\tdev_err(&slave->dev, \"clock stop prepare failed:%d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!is_slave)\n\t\treturn 0;\n\n\t \n\tif (!simple_clk_stop) {\n\t\tret = sdw_bus_wait_for_clk_prep_deprep(bus,\n\t\t\t\t\t\t       SDW_BROADCAST_DEV_NUM);\n\t\t \n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\tif (!slave->dev_num)\n\t\t\tcontinue;\n\n\t\tif (slave->status != SDW_SLAVE_ATTACHED &&\n\t\t    slave->status != SDW_SLAVE_ALERT)\n\t\t\tcontinue;\n\n\t\tret = sdw_slave_clk_stop_callback(slave,\n\t\t\t\t\t\t  SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t  SDW_CLK_POST_PREPARE);\n\n\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\tdev_err(&slave->dev, \"clock stop post-prepare cb failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_bus_prep_clk_stop);\n\n \nint sdw_bus_clk_stop(struct sdw_bus *bus)\n{\n\tint ret;\n\n\t \n\tret = sdw_bwrite_no_pm(bus, SDW_BROADCAST_DEV_NUM,\n\t\t\t       SDW_SCP_CTRL, SDW_SCP_CTRL_CLK_STP_NOW);\n\tif (ret < 0) {\n\t\tif (ret != -ENODATA)\n\t\t\tdev_err(bus->dev, \"ClockStopNow Broadcast msg failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_bus_clk_stop);\n\n \nint sdw_bus_exit_clk_stop(struct sdw_bus *bus)\n{\n\tbool simple_clk_stop = true;\n\tstruct sdw_slave *slave;\n\tbool is_slave = false;\n\tint ret;\n\n\t \n\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\tif (!slave->dev_num)\n\t\t\tcontinue;\n\n\t\tif (slave->status != SDW_SLAVE_ATTACHED &&\n\t\t    slave->status != SDW_SLAVE_ALERT)\n\t\t\tcontinue;\n\n\t\t \n\t\tis_slave = true;\n\n\t\tret = sdw_slave_clk_stop_callback(slave, SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t  SDW_CLK_PRE_DEPREPARE);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&slave->dev, \"clock stop pre-deprepare cb failed:%d\\n\", ret);\n\n\t\t \n\t\tif (!slave->prop.simple_clk_stop_capable) {\n\t\t\tsimple_clk_stop = false;\n\n\t\t\tret = sdw_slave_clk_stop_prepare(slave, SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t\t false);\n\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(&slave->dev, \"clock stop deprepare failed:%d\\n\", ret);\n\t\t}\n\t}\n\n\t \n\tif (!is_slave)\n\t\treturn 0;\n\n\t \n\tif (!simple_clk_stop) {\n\t\tret = sdw_bus_wait_for_clk_prep_deprep(bus, SDW_BROADCAST_DEV_NUM);\n\t\tif (ret < 0)\n\t\t\tdev_warn(bus->dev, \"clock stop deprepare wait failed:%d\\n\", ret);\n\t}\n\n\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\tif (!slave->dev_num)\n\t\t\tcontinue;\n\n\t\tif (slave->status != SDW_SLAVE_ATTACHED &&\n\t\t    slave->status != SDW_SLAVE_ALERT)\n\t\t\tcontinue;\n\n\t\tret = sdw_slave_clk_stop_callback(slave, SDW_CLK_STOP_MODE0,\n\t\t\t\t\t\t  SDW_CLK_POST_DEPREPARE);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&slave->dev, \"clock stop post-deprepare cb failed:%d\\n\", ret);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_bus_exit_clk_stop);\n\nint sdw_configure_dpn_intr(struct sdw_slave *slave,\n\t\t\t   int port, bool enable, int mask)\n{\n\tu32 addr;\n\tint ret;\n\tu8 val = 0;\n\n\tif (slave->bus->params.s_data_mode != SDW_PORT_DATA_MODE_NORMAL) {\n\t\tdev_dbg(&slave->dev, \"TEST FAIL interrupt %s\\n\",\n\t\t\tenable ? \"on\" : \"off\");\n\t\tmask |= SDW_DPN_INT_TEST_FAIL;\n\t}\n\n\taddr = SDW_DPN_INTMASK(port);\n\n\t \n\tif (enable) {\n\t\tval |= mask;\n\t\tval |= SDW_DPN_INT_PORT_READY;\n\t} else {\n\t\tval &= ~(mask);\n\t\tval &= ~SDW_DPN_INT_PORT_READY;\n\t}\n\n\tret = sdw_update_no_pm(slave, addr, (mask | SDW_DPN_INT_PORT_READY), val);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_DPN_INTMASK write failed:%d\\n\", val);\n\n\treturn ret;\n}\n\nstatic int sdw_slave_set_frequency(struct sdw_slave *slave)\n{\n\tu32 mclk_freq = slave->bus->prop.mclk_freq;\n\tu32 curr_freq = slave->bus->params.curr_dr_freq >> 1;\n\tunsigned int scale;\n\tu8 scale_index;\n\tu8 base;\n\tint ret;\n\n\t \n\tif (!slave->id.class_id && !slave->prop.clock_reg_supported)\n\t\treturn 0;\n\n\tif (!mclk_freq) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"no bus MCLK, cannot set SDW_SCP_BUS_CLOCK_BASE\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(19200000 % mclk_freq)) {\n\t\tmclk_freq = 19200000;\n\t\tbase = SDW_SCP_BASE_CLOCK_19200000_HZ;\n\t} else if (!(24000000 % mclk_freq)) {\n\t\tmclk_freq = 24000000;\n\t\tbase = SDW_SCP_BASE_CLOCK_24000000_HZ;\n\t} else if (!(24576000 % mclk_freq)) {\n\t\tmclk_freq = 24576000;\n\t\tbase = SDW_SCP_BASE_CLOCK_24576000_HZ;\n\t} else if (!(22579200 % mclk_freq)) {\n\t\tmclk_freq = 22579200;\n\t\tbase = SDW_SCP_BASE_CLOCK_22579200_HZ;\n\t} else if (!(32000000 % mclk_freq)) {\n\t\tmclk_freq = 32000000;\n\t\tbase = SDW_SCP_BASE_CLOCK_32000000_HZ;\n\t} else {\n\t\tdev_err(&slave->dev,\n\t\t\t\"Unsupported clock base, mclk %d\\n\",\n\t\t\tmclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mclk_freq % curr_freq) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"mclk %d is not multiple of bus curr_freq %d\\n\",\n\t\t\tmclk_freq, curr_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tscale = mclk_freq / curr_freq;\n\n\t \n\tscale_index = ilog2(scale);\n\n\tif (BIT(scale_index) != scale || scale_index > 6) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"No match found for scale %d, bus mclk %d curr_freq %d\\n\",\n\t\t\tscale, mclk_freq, curr_freq);\n\t\treturn -EINVAL;\n\t}\n\tscale_index++;\n\n\tret = sdw_write_no_pm(slave, SDW_SCP_BUS_CLOCK_BASE, base);\n\tif (ret < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_BUS_CLOCK_BASE write failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sdw_write_no_pm(slave, SDW_SCP_BUSCLOCK_SCALE_B0, scale_index);\n\tif (ret < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_BUSCLOCK_SCALE_B0 write failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = sdw_write_no_pm(slave, SDW_SCP_BUSCLOCK_SCALE_B1, scale_index);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_BUSCLOCK_SCALE_B1 write failed:%d\\n\", ret);\n\n\tdev_dbg(&slave->dev,\n\t\t\"Configured bus base %d, scale %d, mclk %d, curr_freq %d\\n\",\n\t\tbase, scale_index, mclk_freq, curr_freq);\n\n\treturn ret;\n}\n\nstatic int sdw_initialize_slave(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint status;\n\tint ret;\n\tu8 val;\n\n\tret = sdw_slave_set_frequency(slave);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (slave->bus->prop.quirks & SDW_MASTER_QUIRKS_CLEAR_INITIAL_CLASH) {\n\t\t \n\t\tstatus = sdw_read_no_pm(slave, SDW_SCP_INT1);\n\t\tif (status < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_SCP_INT1 (BUS_CLASH) read failed:%d\\n\", status);\n\t\t\treturn status;\n\t\t}\n\t\tif (status & SDW_SCP_INT1_BUS_CLASH) {\n\t\t\tdev_warn(&slave->dev, \"Bus clash detected before INT mask is enabled\\n\");\n\t\t\tret = sdw_write_no_pm(slave, SDW_SCP_INT1, SDW_SCP_INT1_BUS_CLASH);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&slave->dev,\n\t\t\t\t\t\"SDW_SCP_INT1 (BUS_CLASH) write failed:%d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif ((slave->bus->prop.quirks & SDW_MASTER_QUIRKS_CLEAR_INITIAL_PARITY) &&\n\t    !(slave->prop.quirks & SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY)) {\n\t\t \n\t\tstatus = sdw_read_no_pm(slave, SDW_SCP_INT1);\n\t\tif (status < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_SCP_INT1 (PARITY) read failed:%d\\n\", status);\n\t\t\treturn status;\n\t\t}\n\t\tif (status & SDW_SCP_INT1_PARITY) {\n\t\t\tdev_warn(&slave->dev, \"PARITY error detected before INT mask is enabled\\n\");\n\t\t\tret = sdw_write_no_pm(slave, SDW_SCP_INT1, SDW_SCP_INT1_PARITY);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&slave->dev,\n\t\t\t\t\t\"SDW_SCP_INT1 (PARITY) write failed:%d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tval = slave->prop.scp_int1_mask;\n\n\t \n\tret = sdw_update_no_pm(slave, SDW_SCP_INTMASK1, val, val);\n\tif (ret < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_INTMASK1 write failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!slave->prop.dp0_prop)\n\t\treturn 0;\n\n\t \n\tval = prop->dp0_prop->imp_def_interrupts;\n\tval |= SDW_DP0_INT_PORT_READY | SDW_DP0_INT_BRA_FAILURE;\n\n\tret = sdw_update_no_pm(slave, SDW_DP0_INTMASK, val, val);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_DP0_INTMASK read failed:%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int sdw_handle_dp0_interrupt(struct sdw_slave *slave, u8 *slave_status)\n{\n\tu8 clear, impl_int_mask;\n\tint status, status2, ret, count = 0;\n\n\tstatus = sdw_read_no_pm(slave, SDW_DP0_INT);\n\tif (status < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_DP0_INT read failed:%d\\n\", status);\n\t\treturn status;\n\t}\n\n\tdo {\n\t\tclear = status & ~SDW_DP0_INTERRUPTS;\n\n\t\tif (status & SDW_DP0_INT_TEST_FAIL) {\n\t\t\tdev_err(&slave->dev, \"Test fail for port 0\\n\");\n\t\t\tclear |= SDW_DP0_INT_TEST_FAIL;\n\t\t}\n\n\t\t \n\n\t\tif (status & SDW_DP0_INT_PORT_READY) {\n\t\t\tcomplete(&slave->port_ready[0]);\n\t\t\tclear |= SDW_DP0_INT_PORT_READY;\n\t\t}\n\n\t\tif (status & SDW_DP0_INT_BRA_FAILURE) {\n\t\t\tdev_err(&slave->dev, \"BRA failed\\n\");\n\t\t\tclear |= SDW_DP0_INT_BRA_FAILURE;\n\t\t}\n\n\t\timpl_int_mask = SDW_DP0_INT_IMPDEF1 |\n\t\t\tSDW_DP0_INT_IMPDEF2 | SDW_DP0_INT_IMPDEF3;\n\n\t\tif (status & impl_int_mask) {\n\t\t\tclear |= impl_int_mask;\n\t\t\t*slave_status = clear;\n\t\t}\n\n\t\t \n\t\tret = sdw_write_no_pm(slave, SDW_DP0_INT, clear);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_DP0_INT write failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstatus2 = sdw_read_no_pm(slave, SDW_DP0_INT);\n\t\tif (status2 < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_DP0_INT read failed:%d\\n\", status2);\n\t\t\treturn status2;\n\t\t}\n\t\t \n\t\tstatus &= status2;\n\n\t\tcount++;\n\n\t\t \n\t} while ((status & SDW_DP0_INTERRUPTS) && (count < SDW_READ_INTR_CLEAR_RETRY));\n\n\tif (count == SDW_READ_INTR_CLEAR_RETRY)\n\t\tdev_warn(&slave->dev, \"Reached MAX_RETRY on DP0 read\\n\");\n\n\treturn ret;\n}\n\nstatic int sdw_handle_port_interrupt(struct sdw_slave *slave,\n\t\t\t\t     int port, u8 *slave_status)\n{\n\tu8 clear, impl_int_mask;\n\tint status, status2, ret, count = 0;\n\tu32 addr;\n\n\tif (port == 0)\n\t\treturn sdw_handle_dp0_interrupt(slave, slave_status);\n\n\taddr = SDW_DPN_INT(port);\n\tstatus = sdw_read_no_pm(slave, addr);\n\tif (status < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_DPN_INT read failed:%d\\n\", status);\n\n\t\treturn status;\n\t}\n\n\tdo {\n\t\tclear = status & ~SDW_DPN_INTERRUPTS;\n\n\t\tif (status & SDW_DPN_INT_TEST_FAIL) {\n\t\t\tdev_err(&slave->dev, \"Test fail for port:%d\\n\", port);\n\t\t\tclear |= SDW_DPN_INT_TEST_FAIL;\n\t\t}\n\n\t\t \n\t\tif (status & SDW_DPN_INT_PORT_READY) {\n\t\t\tcomplete(&slave->port_ready[port]);\n\t\t\tclear |= SDW_DPN_INT_PORT_READY;\n\t\t}\n\n\t\timpl_int_mask = SDW_DPN_INT_IMPDEF1 |\n\t\t\tSDW_DPN_INT_IMPDEF2 | SDW_DPN_INT_IMPDEF3;\n\n\t\tif (status & impl_int_mask) {\n\t\t\tclear |= impl_int_mask;\n\t\t\t*slave_status = clear;\n\t\t}\n\n\t\t \n\t\tret = sdw_write_no_pm(slave, addr, clear);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_DPN_INT write failed:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstatus2 = sdw_read_no_pm(slave, addr);\n\t\tif (status2 < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_DPN_INT read failed:%d\\n\", status2);\n\t\t\treturn status2;\n\t\t}\n\t\t \n\t\tstatus &= status2;\n\n\t\tcount++;\n\n\t\t \n\t} while ((status & SDW_DPN_INTERRUPTS) && (count < SDW_READ_INTR_CLEAR_RETRY));\n\n\tif (count == SDW_READ_INTR_CLEAR_RETRY)\n\t\tdev_warn(&slave->dev, \"Reached MAX_RETRY on port read\");\n\n\treturn ret;\n}\n\nstatic int sdw_handle_slave_alerts(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_intr_status slave_intr;\n\tu8 clear = 0, bit, port_status[15] = {0};\n\tint port_num, stat, ret, count = 0;\n\tunsigned long port;\n\tbool slave_notify;\n\tu8 sdca_cascade = 0;\n\tu8 buf, buf2[2];\n\tbool parity_check;\n\tbool parity_quirk;\n\n\tsdw_modify_slave_status(slave, SDW_SLAVE_ALERT);\n\n\tret = pm_runtime_get_sync(&slave->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err(&slave->dev, \"Failed to resume device: %d\\n\", ret);\n\t\tpm_runtime_put_noidle(&slave->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sdw_read_no_pm(slave, SDW_SCP_INT1);\n\tif (ret < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_INT1 read failed:%d\\n\", ret);\n\t\tgoto io_err;\n\t}\n\tbuf = ret;\n\n\tret = sdw_nread_no_pm(slave, SDW_SCP_INTSTAT2, 2, buf2);\n\tif (ret < 0) {\n\t\tdev_err(&slave->dev,\n\t\t\t\"SDW_SCP_INT2/3 read failed:%d\\n\", ret);\n\t\tgoto io_err;\n\t}\n\n\tif (slave->id.class_id) {\n\t\tret = sdw_read_no_pm(slave, SDW_DP0_INT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_DP0_INT read failed:%d\\n\", ret);\n\t\t\tgoto io_err;\n\t\t}\n\t\tsdca_cascade = ret & SDW_DP0_SDCA_CASCADE;\n\t}\n\n\tdo {\n\t\tslave_notify = false;\n\n\t\t \n\t\tif (buf & SDW_SCP_INT1_PARITY) {\n\t\t\tparity_check = slave->prop.scp_int1_mask & SDW_SCP_INT1_PARITY;\n\t\t\tparity_quirk = !slave->first_interrupt_done &&\n\t\t\t\t(slave->prop.quirks & SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY);\n\n\t\t\tif (parity_check && !parity_quirk)\n\t\t\t\tdev_err(&slave->dev, \"Parity error detected\\n\");\n\t\t\tclear |= SDW_SCP_INT1_PARITY;\n\t\t}\n\n\t\tif (buf & SDW_SCP_INT1_BUS_CLASH) {\n\t\t\tif (slave->prop.scp_int1_mask & SDW_SCP_INT1_BUS_CLASH)\n\t\t\t\tdev_err(&slave->dev, \"Bus clash detected\\n\");\n\t\t\tclear |= SDW_SCP_INT1_BUS_CLASH;\n\t\t}\n\n\t\t \n\n\t\tif (buf & SDW_SCP_INT1_IMPL_DEF) {\n\t\t\tif (slave->prop.scp_int1_mask & SDW_SCP_INT1_IMPL_DEF) {\n\t\t\t\tdev_dbg(&slave->dev, \"Slave impl defined interrupt\\n\");\n\t\t\t\tslave_notify = true;\n\t\t\t}\n\t\t\tclear |= SDW_SCP_INT1_IMPL_DEF;\n\t\t}\n\n\t\t \n\t\tif (sdca_cascade)\n\t\t\tslave_notify = true;\n\n\t\t \n\t\tport = buf & SDW_SCP_INT1_PORT0_3;\n\n\t\t \n\t\tport = FIELD_GET(SDW_SCP_INT1_PORT0_3, port);\n\t\tfor_each_set_bit(bit, &port, 8) {\n\t\t\tsdw_handle_port_interrupt(slave, bit,\n\t\t\t\t\t\t  &port_status[bit]);\n\t\t}\n\n\t\t \n\t\tif (buf & SDW_SCP_INT1_SCP2_CASCADE) {\n\t\t\tport = buf2[0] & SDW_SCP_INTSTAT2_PORT4_10;\n\t\t\tfor_each_set_bit(bit, &port, 8) {\n\t\t\t\t \n\t\t\t\tport_num = bit + 4;\n\t\t\t\tsdw_handle_port_interrupt(slave,\n\t\t\t\t\t\tport_num,\n\t\t\t\t\t\t&port_status[port_num]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (buf2[0] & SDW_SCP_INTSTAT2_SCP3_CASCADE) {\n\t\t\tport = buf2[1] & SDW_SCP_INTSTAT3_PORT11_14;\n\t\t\tfor_each_set_bit(bit, &port, 8) {\n\t\t\t\t \n\t\t\t\tport_num = bit + 11;\n\t\t\t\tsdw_handle_port_interrupt(slave,\n\t\t\t\t\t\tport_num,\n\t\t\t\t\t\t&port_status[port_num]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (slave_notify) {\n\t\t\tmutex_lock(&slave->sdw_dev_lock);\n\n\t\t\tif (slave->probed) {\n\t\t\t\tstruct device *dev = &slave->dev;\n\t\t\t\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\t\t\t\tif (slave->prop.use_domain_irq && slave->irq)\n\t\t\t\t\thandle_nested_irq(slave->irq);\n\n\t\t\t\tif (drv->ops && drv->ops->interrupt_callback) {\n\t\t\t\t\tslave_intr.sdca_cascade = sdca_cascade;\n\t\t\t\t\tslave_intr.control_port = clear;\n\t\t\t\t\tmemcpy(slave_intr.port, &port_status,\n\t\t\t\t\t       sizeof(slave_intr.port));\n\n\t\t\t\t\tdrv->ops->interrupt_callback(slave, &slave_intr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmutex_unlock(&slave->sdw_dev_lock);\n\t\t}\n\n\t\t \n\t\tret = sdw_write_no_pm(slave, SDW_SCP_INT1, clear);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_SCP_INT1 write failed:%d\\n\", ret);\n\t\t\tgoto io_err;\n\t\t}\n\n\t\t \n\t\tslave->first_interrupt_done = true;\n\n\t\t \n\t\tret = sdw_read_no_pm(slave, SDW_SCP_INT1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_SCP_INT1 recheck read failed:%d\\n\", ret);\n\t\t\tgoto io_err;\n\t\t}\n\t\tbuf = ret;\n\n\t\tret = sdw_nread_no_pm(slave, SDW_SCP_INTSTAT2, 2, buf2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"SDW_SCP_INT2/3 recheck read failed:%d\\n\", ret);\n\t\t\tgoto io_err;\n\t\t}\n\n\t\tif (slave->id.class_id) {\n\t\t\tret = sdw_read_no_pm(slave, SDW_DP0_INT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&slave->dev,\n\t\t\t\t\t\"SDW_DP0_INT recheck read failed:%d\\n\", ret);\n\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tsdca_cascade = ret & SDW_DP0_SDCA_CASCADE;\n\t\t}\n\n\t\t \n\t\tstat = buf || buf2[0] || buf2[1] || sdca_cascade;\n\n\t\t \n\t\tcount++;\n\n\t\t \n\t} while (stat != 0 && count < SDW_READ_INTR_CLEAR_RETRY);\n\n\tif (count == SDW_READ_INTR_CLEAR_RETRY)\n\t\tdev_warn(&slave->dev, \"Reached MAX_RETRY on alert read\\n\");\n\nio_err:\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\treturn ret;\n}\n\nstatic int sdw_update_slave_status(struct sdw_slave *slave,\n\t\t\t\t   enum sdw_slave_status status)\n{\n\tint ret = 0;\n\n\tmutex_lock(&slave->sdw_dev_lock);\n\n\tif (slave->probed) {\n\t\tstruct device *dev = &slave->dev;\n\t\tstruct sdw_driver *drv = drv_to_sdw_driver(dev->driver);\n\n\t\tif (drv->ops && drv->ops->update_status)\n\t\t\tret = drv->ops->update_status(slave, status);\n\t}\n\n\tmutex_unlock(&slave->sdw_dev_lock);\n\n\treturn ret;\n}\n\n \nint sdw_handle_slave_status(struct sdw_bus *bus,\n\t\t\t    enum sdw_slave_status status[])\n{\n\tenum sdw_slave_status prev_status;\n\tstruct sdw_slave *slave;\n\tbool attached_initializing, id_programmed;\n\tint i, ret = 0;\n\n\t \n\tfor (i = 1; i <= SDW_MAX_DEVICES; i++) {\n\t\tmutex_lock(&bus->bus_lock);\n\t\tif (test_bit(i, bus->assigned) == false) {\n\t\t\tmutex_unlock(&bus->bus_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&bus->bus_lock);\n\n\t\tslave = sdw_get_slave(bus, i);\n\t\tif (!slave)\n\t\t\tcontinue;\n\n\t\tif (status[i] == SDW_SLAVE_UNATTACHED &&\n\t\t    slave->status != SDW_SLAVE_UNATTACHED) {\n\t\t\tdev_warn(&slave->dev, \"Slave %d state check1: UNATTACHED, status was %d\\n\",\n\t\t\t\t i, slave->status);\n\t\t\tsdw_modify_slave_status(slave, SDW_SLAVE_UNATTACHED);\n\n\t\t\t \n\t\t\tret = sdw_update_slave_status(slave, status[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(&slave->dev, \"Update Slave status failed:%d\\n\", ret);\n\t\t}\n\t}\n\n\tif (status[0] == SDW_SLAVE_ATTACHED) {\n\t\tdev_dbg(bus->dev, \"Slave attached, programming device number\\n\");\n\n\t\t \n\t\tsdw_program_device_num(bus, &id_programmed);\n\t\tif (id_programmed)\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 1; i <= SDW_MAX_DEVICES; i++) {\n\t\tmutex_lock(&bus->bus_lock);\n\t\tif (test_bit(i, bus->assigned) == false) {\n\t\t\tmutex_unlock(&bus->bus_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&bus->bus_lock);\n\n\t\tslave = sdw_get_slave(bus, i);\n\t\tif (!slave)\n\t\t\tcontinue;\n\n\t\tattached_initializing = false;\n\n\t\tswitch (status[i]) {\n\t\tcase SDW_SLAVE_UNATTACHED:\n\t\t\tif (slave->status == SDW_SLAVE_UNATTACHED)\n\t\t\t\tbreak;\n\n\t\t\tdev_warn(&slave->dev, \"Slave %d state check2: UNATTACHED, status was %d\\n\",\n\t\t\t\t i, slave->status);\n\n\t\t\tsdw_modify_slave_status(slave, SDW_SLAVE_UNATTACHED);\n\t\t\tbreak;\n\n\t\tcase SDW_SLAVE_ALERT:\n\t\t\tret = sdw_handle_slave_alerts(slave);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&slave->dev,\n\t\t\t\t\t\"Slave %d alert handling failed: %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t\tbreak;\n\n\t\tcase SDW_SLAVE_ATTACHED:\n\t\t\tif (slave->status == SDW_SLAVE_ATTACHED)\n\t\t\t\tbreak;\n\n\t\t\tprev_status = slave->status;\n\t\t\tsdw_modify_slave_status(slave, SDW_SLAVE_ATTACHED);\n\n\t\t\tif (prev_status == SDW_SLAVE_ALERT)\n\t\t\t\tbreak;\n\n\t\t\tattached_initializing = true;\n\n\t\t\tret = sdw_initialize_slave(slave);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&slave->dev,\n\t\t\t\t\t\"Slave %d initialization failed: %d\\n\",\n\t\t\t\t\ti, ret);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&slave->dev, \"Invalid slave %d status:%d\\n\",\n\t\t\t\ti, status[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = sdw_update_slave_status(slave, status[i]);\n\t\tif (ret < 0)\n\t\t\tdev_err(&slave->dev,\n\t\t\t\t\"Update Slave status failed:%d\\n\", ret);\n\t\tif (attached_initializing) {\n\t\t\tdev_dbg(&slave->dev,\n\t\t\t\t\"signaling initialization completion for Slave %d\\n\",\n\t\t\t\tslave->dev_num);\n\n\t\t\tcomplete_all(&slave->initialization_complete);\n\n\t\t\t \n\t\t\tpm_request_resume(&slave->dev);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_handle_slave_status);\n\nvoid sdw_clear_slave_status(struct sdw_bus *bus, u32 request)\n{\n\tstruct sdw_slave *slave;\n\tint i;\n\n\t \n\tfor (i = 1; i <= SDW_MAX_DEVICES; i++) {\n\t\tmutex_lock(&bus->bus_lock);\n\t\tif (test_bit(i, bus->assigned) == false) {\n\t\t\tmutex_unlock(&bus->bus_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&bus->bus_lock);\n\n\t\tslave = sdw_get_slave(bus, i);\n\t\tif (!slave)\n\t\t\tcontinue;\n\n\t\tif (slave->status != SDW_SLAVE_UNATTACHED) {\n\t\t\tsdw_modify_slave_status(slave, SDW_SLAVE_UNATTACHED);\n\t\t\tslave->first_interrupt_done = false;\n\t\t\tsdw_update_slave_status(slave, SDW_SLAVE_UNATTACHED);\n\t\t}\n\n\t\t \n\t\tslave->unattach_request = request;\n\t}\n}\nEXPORT_SYMBOL(sdw_clear_slave_status);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}