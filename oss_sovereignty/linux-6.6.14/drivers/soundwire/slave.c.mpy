{
  "module_name": "slave.c",
  "hash_id": "8caa2dbc1ba582a5affe39d5a9ccfe3a2c1be2f930c36a940f19be1ca9262a25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/slave.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include \"bus.h\"\n#include \"sysfs_local.h\"\n\nstatic void sdw_slave_release(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\n\tmutex_destroy(&slave->sdw_dev_lock);\n\tkfree(slave);\n}\n\nstruct device_type sdw_slave_type = {\n\t.name =\t\t\"sdw_slave\",\n\t.release =\tsdw_slave_release,\n\t.uevent =\tsdw_slave_uevent,\n};\n\nint sdw_slave_add(struct sdw_bus *bus,\n\t\t  struct sdw_slave_id *id, struct fwnode_handle *fwnode)\n{\n\tstruct sdw_slave *slave;\n\tint ret;\n\tint i;\n\n\tslave = kzalloc(sizeof(*slave), GFP_KERNEL);\n\tif (!slave)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&slave->id, id, sizeof(*id));\n\tslave->dev.parent = bus->dev;\n\tslave->dev.fwnode = fwnode;\n\n\tif (id->unique_id == SDW_IGNORED_UNIQUE_ID) {\n\t\t \n\t\tdev_set_name(&slave->dev, \"sdw:%01x:%04x:%04x:%02x\",\n\t\t\t     bus->link_id, id->mfg_id, id->part_id,\n\t\t\t     id->class_id);\n\t} else {\n\t\t \n\t\tdev_set_name(&slave->dev, \"sdw:%01x:%04x:%04x:%02x:%01x\",\n\t\t\t     bus->link_id, id->mfg_id, id->part_id,\n\t\t\t     id->class_id, id->unique_id);\n\t}\n\n\tslave->dev.bus = &sdw_bus_type;\n\tslave->dev.of_node = of_node_get(to_of_node(fwnode));\n\tslave->dev.type = &sdw_slave_type;\n\tslave->dev.groups = sdw_slave_status_attr_groups;\n\tslave->bus = bus;\n\tslave->status = SDW_SLAVE_UNATTACHED;\n\tinit_completion(&slave->enumeration_complete);\n\tinit_completion(&slave->initialization_complete);\n\tslave->dev_num = 0;\n\tslave->probed = false;\n\tslave->first_interrupt_done = false;\n\tmutex_init(&slave->sdw_dev_lock);\n\n\tfor (i = 0; i < SDW_MAX_PORTS; i++)\n\t\tinit_completion(&slave->port_ready[i]);\n\n\tmutex_lock(&bus->bus_lock);\n\tlist_add_tail(&slave->node, &bus->slaves);\n\tmutex_unlock(&bus->bus_lock);\n\n\tret = device_register(&slave->dev);\n\tif (ret) {\n\t\tdev_err(bus->dev, \"Failed to add slave: ret %d\\n\", ret);\n\n\t\t \n\t\tmutex_lock(&bus->bus_lock);\n\t\tlist_del(&slave->node);\n\t\tmutex_unlock(&bus->bus_lock);\n\t\tput_device(&slave->dev);\n\n\t\treturn ret;\n\t}\n\tsdw_slave_debugfs_init(slave);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_slave_add);\n\n#if IS_ENABLED(CONFIG_ACPI)\n\nstatic bool find_slave(struct sdw_bus *bus,\n\t\t       struct acpi_device *adev,\n\t\t       struct sdw_slave_id *id)\n{\n\tu64 addr;\n\tunsigned int link_id;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(adev->handle,\n\t\t\t\t       METHOD_NAME__ADR, NULL, &addr);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(bus->dev, \"_ADR resolution failed: %x\\n\",\n\t\t\tstatus);\n\t\treturn false;\n\t}\n\n\tif (bus->ops->override_adr)\n\t\taddr = bus->ops->override_adr(bus, addr);\n\n\tif (!addr)\n\t\treturn false;\n\n\t \n\tlink_id = SDW_DISCO_LINK_ID(addr);\n\n\t \n\tif (link_id != bus->link_id)\n\t\treturn false;\n\n\tsdw_extract_slave_id(bus, addr, id);\n\n\treturn true;\n}\n\nstruct sdw_acpi_child_walk_data {\n\tstruct sdw_bus *bus;\n\tstruct acpi_device *adev;\n\tstruct sdw_slave_id id;\n\tbool ignore_unique_id;\n};\n\nstatic int sdw_acpi_check_duplicate(struct acpi_device *adev, void *data)\n{\n\tstruct sdw_acpi_child_walk_data *cwd = data;\n\tstruct sdw_bus *bus = cwd->bus;\n\tstruct sdw_slave_id id;\n\n\tif (adev == cwd->adev)\n\t\treturn 0;\n\n\tif (!find_slave(bus, adev, &id))\n\t\treturn 0;\n\n\tif (cwd->id.sdw_version != id.sdw_version || cwd->id.mfg_id != id.mfg_id ||\n\t    cwd->id.part_id != id.part_id || cwd->id.class_id != id.class_id)\n\t\treturn 0;\n\n\tif (cwd->id.unique_id != id.unique_id) {\n\t\tdev_dbg(bus->dev,\n\t\t\t\"Valid unique IDs 0x%x 0x%x for Slave mfg_id 0x%04x, part_id 0x%04x\\n\",\n\t\t\tcwd->id.unique_id, id.unique_id, cwd->id.mfg_id,\n\t\t\tcwd->id.part_id);\n\t\tcwd->ignore_unique_id = false;\n\t\treturn 0;\n\t}\n\n\tdev_err(bus->dev,\n\t\t\"Invalid unique IDs 0x%x 0x%x for Slave mfg_id 0x%04x, part_id 0x%04x\\n\",\n\t\tcwd->id.unique_id, id.unique_id, cwd->id.mfg_id, cwd->id.part_id);\n\treturn -ENODEV;\n}\n\nstatic int sdw_acpi_find_one(struct acpi_device *adev, void *data)\n{\n\tstruct sdw_bus *bus = data;\n\tstruct sdw_acpi_child_walk_data cwd = {\n\t\t.bus = bus,\n\t\t.adev = adev,\n\t\t.ignore_unique_id = true,\n\t};\n\tint ret;\n\n\tif (!find_slave(bus, adev, &cwd.id))\n\t\treturn 0;\n\n\t \n\tret = acpi_dev_for_each_child(ACPI_COMPANION(bus->dev),\n\t\t\t\t      sdw_acpi_check_duplicate, &cwd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cwd.ignore_unique_id)\n\t\tcwd.id.unique_id = SDW_IGNORED_UNIQUE_ID;\n\n\t \n\tsdw_slave_add(bus, &cwd.id, acpi_fwnode_handle(adev));\n\treturn 0;\n}\n\n \nint sdw_acpi_find_slaves(struct sdw_bus *bus)\n{\n\tstruct acpi_device *parent;\n\n\tparent = ACPI_COMPANION(bus->dev);\n\tif (!parent) {\n\t\tdev_err(bus->dev, \"Can't find parent for acpi bind\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn acpi_dev_for_each_child(parent, sdw_acpi_find_one, bus);\n}\n\n#endif\n\n \nint sdw_of_find_slaves(struct sdw_bus *bus)\n{\n\tstruct device *dev = bus->dev;\n\tstruct device_node *node;\n\n\tfor_each_child_of_node(bus->dev->of_node, node) {\n\t\tint link_id, ret, len;\n\t\tunsigned int sdw_version;\n\t\tconst char *compat = NULL;\n\t\tstruct sdw_slave_id id;\n\t\tconst __be32 *addr;\n\n\t\tcompat = of_get_property(node, \"compatible\", NULL);\n\t\tif (!compat)\n\t\t\tcontinue;\n\n\t\tret = sscanf(compat, \"sdw%01x%04hx%04hx%02hhx\", &sdw_version,\n\t\t\t     &id.mfg_id, &id.part_id, &id.class_id);\n\n\t\tif (ret != 4) {\n\t\t\tdev_err(dev, \"Invalid compatible string found %s\\n\",\n\t\t\t\tcompat);\n\t\t\tcontinue;\n\t\t}\n\n\t\taddr = of_get_property(node, \"reg\", &len);\n\t\tif (!addr || (len < 2 * sizeof(u32))) {\n\t\t\tdev_err(dev, \"Invalid Link and Instance ID\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlink_id = be32_to_cpup(addr++);\n\t\tid.unique_id = be32_to_cpup(addr);\n\t\tid.sdw_version = sdw_version;\n\n\t\t \n\t\tif (link_id != bus->link_id)\n\t\t\tcontinue;\n\n\t\tsdw_slave_add(bus, &id, of_fwnode_handle(node));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}