{
  "module_name": "intel_init.c",
  "hash_id": "3ff975271630fac4710cb16c648317b62beae1554fc15ff4029e620219e7460f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/intel_init.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/auxiliary_bus.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_intel.h>\n#include \"cadence_master.h\"\n#include \"intel.h\"\n#include \"intel_auxdevice.h\"\n\nstatic void intel_link_dev_release(struct device *dev)\n{\n\tstruct auxiliary_device *auxdev = to_auxiliary_dev(dev);\n\tstruct sdw_intel_link_dev *ldev = auxiliary_dev_to_sdw_intel_link_dev(auxdev);\n\n\tkfree(ldev);\n}\n\n \nstatic struct sdw_intel_link_dev *intel_link_dev_register(struct sdw_intel_res *res,\n\t\t\t\t\t\t\t  struct sdw_intel_ctx *ctx,\n\t\t\t\t\t\t\t  struct fwnode_handle *fwnode,\n\t\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t\t  int link_id)\n{\n\tstruct sdw_intel_link_dev *ldev;\n\tstruct sdw_intel_link_res *link;\n\tstruct auxiliary_device *auxdev;\n\tint ret;\n\n\tldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tauxdev = &ldev->auxdev;\n\tauxdev->name = name;\n\tauxdev->dev.parent = res->parent;\n\tauxdev->dev.fwnode = fwnode;\n\tauxdev->dev.release = intel_link_dev_release;\n\n\t \n\tauxdev->id = link_id;\n\n\t \n\tctx->ldev[link_id] = ldev;\n\n\t \n\tlink = &ldev->link_res;\n\tlink->hw_ops = res->hw_ops;\n\tlink->mmio_base = res->mmio_base;\n\tif (!res->ext) {\n\t\tlink->registers = res->mmio_base + SDW_LINK_BASE\n\t\t\t+ (SDW_LINK_SIZE * link_id);\n\t\tlink->ip_offset = 0;\n\t\tlink->shim = res->mmio_base + res->shim_base;\n\t\tlink->alh = res->mmio_base + res->alh_base;\n\t\tlink->shim_lock = &ctx->shim_lock;\n\t} else {\n\t\tlink->registers = res->mmio_base + SDW_IP_BASE(link_id);\n\t\tlink->ip_offset = SDW_CADENCE_MCP_IP_OFFSET;\n\t\tlink->shim = res->mmio_base +  SDW_SHIM2_GENERIC_BASE(link_id);\n\t\tlink->shim_vs = res->mmio_base + SDW_SHIM2_VS_BASE(link_id);\n\t\tlink->shim_lock = res->eml_lock;\n\t}\n\n\tlink->ops = res->ops;\n\tlink->dev = res->dev;\n\n\tlink->clock_stop_quirks = res->clock_stop_quirks;\n\tlink->shim_mask = &ctx->shim_mask;\n\tlink->link_mask = ctx->link_mask;\n\n\tlink->hbus = res->hbus;\n\n\t \n\tret = auxiliary_device_init(auxdev);\n\tif (ret < 0) {\n\t\tdev_err(res->parent, \"failed to initialize link dev %s link_id %d\\n\",\n\t\t\tname, link_id);\n\t\tkfree(ldev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = auxiliary_device_add(&ldev->auxdev);\n\tif (ret < 0) {\n\t\tdev_err(res->parent, \"failed to add link dev %s link_id %d\\n\",\n\t\t\tldev->auxdev.name, link_id);\n\t\t \n\t\tauxiliary_device_uninit(&ldev->auxdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ldev;\n}\n\nstatic void intel_link_dev_unregister(struct sdw_intel_link_dev *ldev)\n{\n\tauxiliary_device_delete(&ldev->auxdev);\n\tauxiliary_device_uninit(&ldev->auxdev);\n}\n\nstatic int sdw_intel_cleanup(struct sdw_intel_ctx *ctx)\n{\n\tstruct sdw_intel_link_dev *ldev;\n\tu32 link_mask;\n\tint i;\n\n\tlink_mask = ctx->link_mask;\n\n\tfor (i = 0; i < ctx->count; i++) {\n\t\tif (!(link_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tldev = ctx->ldev[i];\n\n\t\tpm_runtime_disable(&ldev->auxdev.dev);\n\t\tif (!ldev->link_res.clock_stop_quirks)\n\t\t\tpm_runtime_put_noidle(ldev->link_res.dev);\n\n\t\tintel_link_dev_unregister(ldev);\n\t}\n\n\treturn 0;\n}\n\nirqreturn_t sdw_intel_thread(int irq, void *dev_id)\n{\n\tstruct sdw_intel_ctx *ctx = dev_id;\n\tstruct sdw_intel_link_res *link;\n\n\tlist_for_each_entry(link, &ctx->link_list, list)\n\t\tsdw_cdns_irq(irq, link->cdns);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_NS(sdw_intel_thread, SOUNDWIRE_INTEL_INIT);\n\nstatic struct sdw_intel_ctx\n*sdw_intel_probe_controller(struct sdw_intel_res *res)\n{\n\tstruct sdw_intel_link_res *link;\n\tstruct sdw_intel_link_dev *ldev;\n\tstruct sdw_intel_ctx *ctx;\n\tstruct acpi_device *adev;\n\tstruct sdw_slave *slave;\n\tstruct list_head *node;\n\tstruct sdw_bus *bus;\n\tu32 link_mask;\n\tint num_slaves = 0;\n\tint count;\n\tint i;\n\n\tif (!res)\n\t\treturn NULL;\n\n\tadev = acpi_fetch_acpi_dev(res->handle);\n\tif (!adev)\n\t\treturn NULL;\n\n\tif (!res->count)\n\t\treturn NULL;\n\n\tcount = res->count;\n\tdev_dbg(&adev->dev, \"Creating %d SDW Link devices\\n\", count);\n\n\t \n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->count = count;\n\n\t \n\tctx->ldev = kcalloc(ctx->count, sizeof(*ctx->ldev), GFP_KERNEL);\n\tif (!ctx->ldev) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tctx->mmio_base = res->mmio_base;\n\tctx->shim_base = res->shim_base;\n\tctx->alh_base = res->alh_base;\n\tctx->link_mask = res->link_mask;\n\tctx->handle = res->handle;\n\tmutex_init(&ctx->shim_lock);\n\n\tlink_mask = ctx->link_mask;\n\n\tINIT_LIST_HEAD(&ctx->link_list);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!(link_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tldev = intel_link_dev_register(res,\n\t\t\t\t\t       ctx,\n\t\t\t\t\t       acpi_fwnode_handle(adev),\n\t\t\t\t\t       \"link\",\n\t\t\t\t\t       i);\n\t\tif (IS_ERR(ldev))\n\t\t\tgoto err;\n\n\t\tlink = &ldev->link_res;\n\t\tlink->cdns = auxiliary_get_drvdata(&ldev->auxdev);\n\n\t\tif (!link->cdns) {\n\t\t\tdev_err(&adev->dev, \"failed to get link->cdns\\n\");\n\t\t\t \n\t\t\ti++;\n\t\t\tgoto err;\n\t\t}\n\t\tlist_add_tail(&link->list, &ctx->link_list);\n\t\tbus = &link->cdns->bus;\n\t\t \n\t\tlist_for_each(node, &bus->slaves)\n\t\t\tnum_slaves++;\n\t}\n\n\tctx->ids = kcalloc(num_slaves, sizeof(*ctx->ids), GFP_KERNEL);\n\tif (!ctx->ids)\n\t\tgoto err;\n\n\tctx->num_slaves = num_slaves;\n\ti = 0;\n\tlist_for_each_entry(link, &ctx->link_list, list) {\n\t\tbus = &link->cdns->bus;\n\t\tlist_for_each_entry(slave, &bus->slaves, node) {\n\t\t\tctx->ids[i].id = slave->id;\n\t\t\tctx->ids[i].link_id = bus->link_id;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn ctx;\n\nerr:\n\twhile (i--) {\n\t\tif (!(link_mask & BIT(i)))\n\t\t\tcontinue;\n\t\tldev = ctx->ldev[i];\n\t\tintel_link_dev_unregister(ldev);\n\t}\n\tkfree(ctx->ldev);\n\tkfree(ctx);\n\treturn NULL;\n}\n\nstatic int\nsdw_intel_startup_controller(struct sdw_intel_ctx *ctx)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(ctx->handle);\n\tstruct sdw_intel_link_dev *ldev;\n\tu32 link_mask;\n\tint i;\n\n\tif (!adev)\n\t\treturn -EINVAL;\n\n\tif (!ctx->ldev)\n\t\treturn -EINVAL;\n\n\tlink_mask = ctx->link_mask;\n\n\t \n\tfor (i = 0; i < ctx->count; i++) {\n\t\tif (!(link_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tldev = ctx->ldev[i];\n\n\t\tintel_link_startup(&ldev->auxdev);\n\n\t\tif (!ldev->link_res.clock_stop_quirks) {\n\t\t\t \n\t\t\tpm_runtime_get_noresume(ldev->link_res.dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstruct sdw_intel_ctx\n*sdw_intel_probe(struct sdw_intel_res *res)\n{\n\treturn sdw_intel_probe_controller(res);\n}\nEXPORT_SYMBOL_NS(sdw_intel_probe, SOUNDWIRE_INTEL_INIT);\n\n \nint sdw_intel_startup(struct sdw_intel_ctx *ctx)\n{\n\treturn sdw_intel_startup_controller(ctx);\n}\nEXPORT_SYMBOL_NS(sdw_intel_startup, SOUNDWIRE_INTEL_INIT);\n \nvoid sdw_intel_exit(struct sdw_intel_ctx *ctx)\n{\n\tsdw_intel_cleanup(ctx);\n\tkfree(ctx->ids);\n\tkfree(ctx->ldev);\n\tkfree(ctx);\n}\nEXPORT_SYMBOL_NS(sdw_intel_exit, SOUNDWIRE_INTEL_INIT);\n\nvoid sdw_intel_process_wakeen_event(struct sdw_intel_ctx *ctx)\n{\n\tstruct sdw_intel_link_dev *ldev;\n\tu32 link_mask;\n\tint i;\n\n\tif (!ctx->ldev)\n\t\treturn;\n\n\tlink_mask = ctx->link_mask;\n\n\t \n\tfor (i = 0; i < ctx->count; i++) {\n\t\tif (!(link_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tldev = ctx->ldev[i];\n\n\t\tintel_link_process_wakeen_event(&ldev->auxdev);\n\t}\n}\nEXPORT_SYMBOL_NS(sdw_intel_process_wakeen_event, SOUNDWIRE_INTEL_INIT);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Intel Soundwire Init Library\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}