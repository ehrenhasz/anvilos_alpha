{
  "module_name": "cadence_master.c",
  "hash_id": "1a17b820e323d1555cd81b49b5467f519c5ca13108735f360691f534e55d534a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/soundwire/cadence_master.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <linux/workqueue.h>\n#include \"bus.h\"\n#include \"cadence_master.h\"\n\nstatic int interrupt_mask;\nmodule_param_named(cnds_mcp_int_mask, interrupt_mask, int, 0444);\nMODULE_PARM_DESC(cdns_mcp_int_mask, \"Cadence MCP IntMask\");\n\n#define CDNS_MCP_CONFIG\t\t\t\t0x0\n#define CDNS_MCP_CONFIG_BUS_REL\t\t\tBIT(6)\n\n#define CDNS_IP_MCP_CONFIG\t\t\t0x0  \n\n#define CDNS_IP_MCP_CONFIG_MCMD_RETRY\t\tGENMASK(27, 24)\n#define CDNS_IP_MCP_CONFIG_MPREQ_DELAY\t\tGENMASK(20, 16)\n#define CDNS_IP_MCP_CONFIG_MMASTER\t\tBIT(7)\n#define CDNS_IP_MCP_CONFIG_SNIFFER\t\tBIT(5)\n#define CDNS_IP_MCP_CONFIG_CMD\t\t\tBIT(3)\n#define CDNS_IP_MCP_CONFIG_OP\t\t\tGENMASK(2, 0)\n#define CDNS_IP_MCP_CONFIG_OP_NORMAL\t\t0\n\n#define CDNS_MCP_CONTROL\t\t\t0x4\n\n#define CDNS_MCP_CONTROL_CMD_RST\t\tBIT(7)\n#define CDNS_MCP_CONTROL_SOFT_RST\t\tBIT(6)\n#define CDNS_MCP_CONTROL_HW_RST\t\t\tBIT(4)\n#define CDNS_MCP_CONTROL_CLK_STOP_CLR\t\tBIT(2)\n\n#define CDNS_IP_MCP_CONTROL\t\t\t0x4   \n\n#define CDNS_IP_MCP_CONTROL_RST_DELAY\t\tGENMASK(10, 8)\n#define CDNS_IP_MCP_CONTROL_SW_RST\t\tBIT(5)\n#define CDNS_IP_MCP_CONTROL_CLK_PAUSE\t\tBIT(3)\n#define CDNS_IP_MCP_CONTROL_CMD_ACCEPT\t\tBIT(1)\n#define CDNS_IP_MCP_CONTROL_BLOCK_WAKEUP\tBIT(0)\n\n#define CDNS_IP_MCP_CMDCTRL\t\t\t0x8  \n\n#define CDNS_IP_MCP_CMDCTRL_INSERT_PARITY_ERR\tBIT(2)\n\n#define CDNS_MCP_SSPSTAT\t\t\t0xC\n#define CDNS_MCP_FRAME_SHAPE\t\t\t0x10\n#define CDNS_MCP_FRAME_SHAPE_INIT\t\t0x14\n#define CDNS_MCP_FRAME_SHAPE_COL_MASK\t\tGENMASK(2, 0)\n#define CDNS_MCP_FRAME_SHAPE_ROW_MASK\t\tGENMASK(7, 3)\n\n#define CDNS_MCP_CONFIG_UPDATE\t\t\t0x18\n#define CDNS_MCP_CONFIG_UPDATE_BIT\t\tBIT(0)\n\n#define CDNS_MCP_PHYCTRL\t\t\t0x1C\n#define CDNS_MCP_SSP_CTRL0\t\t\t0x20\n#define CDNS_MCP_SSP_CTRL1\t\t\t0x28\n#define CDNS_MCP_CLK_CTRL0\t\t\t0x30\n#define CDNS_MCP_CLK_CTRL1\t\t\t0x38\n#define CDNS_MCP_CLK_MCLKD_MASK\t\tGENMASK(7, 0)\n\n#define CDNS_MCP_STAT\t\t\t\t0x40\n\n#define CDNS_MCP_STAT_ACTIVE_BANK\t\tBIT(20)\n#define CDNS_MCP_STAT_CLK_STOP\t\t\tBIT(16)\n\n#define CDNS_MCP_INTSTAT\t\t\t0x44\n#define CDNS_MCP_INTMASK\t\t\t0x48\n\n#define CDNS_MCP_INT_IRQ\t\t\tBIT(31)\n#define CDNS_MCP_INT_RESERVED1\t\t\tGENMASK(30, 17)\n#define CDNS_MCP_INT_WAKEUP\t\t\tBIT(16)\n#define CDNS_MCP_INT_SLAVE_RSVD\t\t\tBIT(15)\n#define CDNS_MCP_INT_SLAVE_ALERT\t\tBIT(14)\n#define CDNS_MCP_INT_SLAVE_ATTACH\t\tBIT(13)\n#define CDNS_MCP_INT_SLAVE_NATTACH\t\tBIT(12)\n#define CDNS_MCP_INT_SLAVE_MASK\t\t\tGENMASK(15, 12)\n#define CDNS_MCP_INT_DPINT\t\t\tBIT(11)\n#define CDNS_MCP_INT_CTRL_CLASH\t\t\tBIT(10)\n#define CDNS_MCP_INT_DATA_CLASH\t\t\tBIT(9)\n#define CDNS_MCP_INT_PARITY\t\t\tBIT(8)\n#define CDNS_MCP_INT_CMD_ERR\t\t\tBIT(7)\n#define CDNS_MCP_INT_RESERVED2\t\t\tGENMASK(6, 4)\n#define CDNS_MCP_INT_RX_NE\t\t\tBIT(3)\n#define CDNS_MCP_INT_RX_WL\t\t\tBIT(2)\n#define CDNS_MCP_INT_TXE\t\t\tBIT(1)\n#define CDNS_MCP_INT_TXF\t\t\tBIT(0)\n#define CDNS_MCP_INT_RESERVED (CDNS_MCP_INT_RESERVED1 | CDNS_MCP_INT_RESERVED2)\n\n#define CDNS_MCP_INTSET\t\t\t\t0x4C\n\n#define CDNS_MCP_SLAVE_STAT\t\t\t0x50\n#define CDNS_MCP_SLAVE_STAT_MASK\t\tGENMASK(1, 0)\n\n#define CDNS_MCP_SLAVE_INTSTAT0\t\t\t0x54\n#define CDNS_MCP_SLAVE_INTSTAT1\t\t\t0x58\n#define CDNS_MCP_SLAVE_INTSTAT_NPRESENT\t\tBIT(0)\n#define CDNS_MCP_SLAVE_INTSTAT_ATTACHED\t\tBIT(1)\n#define CDNS_MCP_SLAVE_INTSTAT_ALERT\t\tBIT(2)\n#define CDNS_MCP_SLAVE_INTSTAT_RESERVED\t\tBIT(3)\n#define CDNS_MCP_SLAVE_STATUS_BITS\t\tGENMASK(3, 0)\n#define CDNS_MCP_SLAVE_STATUS_NUM\t\t4\n\n#define CDNS_MCP_SLAVE_INTMASK0\t\t\t0x5C\n#define CDNS_MCP_SLAVE_INTMASK1\t\t\t0x60\n\n#define CDNS_MCP_SLAVE_INTMASK0_MASK\t\tGENMASK(31, 0)\n#define CDNS_MCP_SLAVE_INTMASK1_MASK\t\tGENMASK(15, 0)\n\n#define CDNS_MCP_PORT_INTSTAT\t\t\t0x64\n#define CDNS_MCP_PDI_STAT\t\t\t0x6C\n\n#define CDNS_MCP_FIFOLEVEL\t\t\t0x78\n#define CDNS_MCP_FIFOSTAT\t\t\t0x7C\n#define CDNS_MCP_RX_FIFO_AVAIL\t\t\tGENMASK(5, 0)\n\n#define CDNS_IP_MCP_CMD_BASE\t\t\t0x80  \n#define CDNS_IP_MCP_RESP_BASE\t\t\t0x80  \n \n#define CDNS_MCP_CMD_LEN\t\t\t8\n#define CDNS_MCP_CMD_WORD_LEN\t\t\t0x4\n\n#define CDNS_MCP_CMD_SSP_TAG\t\t\tBIT(31)\n#define CDNS_MCP_CMD_COMMAND\t\t\tGENMASK(30, 28)\n#define CDNS_MCP_CMD_DEV_ADDR\t\t\tGENMASK(27, 24)\n#define CDNS_MCP_CMD_REG_ADDR\t\t\tGENMASK(23, 8)\n#define CDNS_MCP_CMD_REG_DATA\t\t\tGENMASK(7, 0)\n\n#define CDNS_MCP_CMD_READ\t\t\t2\n#define CDNS_MCP_CMD_WRITE\t\t\t3\n\n#define CDNS_MCP_RESP_RDATA\t\t\tGENMASK(15, 8)\n#define CDNS_MCP_RESP_ACK\t\t\tBIT(0)\n#define CDNS_MCP_RESP_NACK\t\t\tBIT(1)\n\n#define CDNS_DP_SIZE\t\t\t\t128\n\n#define CDNS_DPN_B0_CONFIG(n)\t\t\t(0x100 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B0_CH_EN(n)\t\t\t(0x104 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B0_SAMPLE_CTRL(n)\t\t(0x108 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B0_OFFSET_CTRL(n)\t\t(0x10C + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B0_HCTRL(n)\t\t\t(0x110 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B0_ASYNC_CTRL(n)\t\t(0x114 + CDNS_DP_SIZE * (n))\n\n#define CDNS_DPN_B1_CONFIG(n)\t\t\t(0x118 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B1_CH_EN(n)\t\t\t(0x11C + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B1_SAMPLE_CTRL(n)\t\t(0x120 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B1_OFFSET_CTRL(n)\t\t(0x124 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B1_HCTRL(n)\t\t\t(0x128 + CDNS_DP_SIZE * (n))\n#define CDNS_DPN_B1_ASYNC_CTRL(n)\t\t(0x12C + CDNS_DP_SIZE * (n))\n\n#define CDNS_DPN_CONFIG_BPM\t\t\tBIT(18)\n#define CDNS_DPN_CONFIG_BGC\t\t\tGENMASK(17, 16)\n#define CDNS_DPN_CONFIG_WL\t\t\tGENMASK(12, 8)\n#define CDNS_DPN_CONFIG_PORT_DAT\t\tGENMASK(3, 2)\n#define CDNS_DPN_CONFIG_PORT_FLOW\t\tGENMASK(1, 0)\n\n#define CDNS_DPN_SAMPLE_CTRL_SI\t\t\tGENMASK(15, 0)\n\n#define CDNS_DPN_OFFSET_CTRL_1\t\t\tGENMASK(7, 0)\n#define CDNS_DPN_OFFSET_CTRL_2\t\t\tGENMASK(15, 8)\n\n#define CDNS_DPN_HCTRL_HSTOP\t\t\tGENMASK(3, 0)\n#define CDNS_DPN_HCTRL_HSTART\t\t\tGENMASK(7, 4)\n#define CDNS_DPN_HCTRL_LCTRL\t\t\tGENMASK(10, 8)\n\n#define CDNS_PORTCTRL\t\t\t\t0x130\n#define CDNS_PORTCTRL_TEST_FAILED\t\tBIT(1)\n#define CDNS_PORTCTRL_DIRN\t\t\tBIT(7)\n#define CDNS_PORTCTRL_BANK_INVERT\t\tBIT(8)\n\n#define CDNS_PORT_OFFSET\t\t\t0x80\n\n#define CDNS_PDI_CONFIG(n)\t\t\t(0x1100 + (n) * 16)\n\n#define CDNS_PDI_CONFIG_SOFT_RESET\t\tBIT(24)\n#define CDNS_PDI_CONFIG_CHANNEL\t\t\tGENMASK(15, 8)\n#define CDNS_PDI_CONFIG_PORT\t\t\tGENMASK(4, 0)\n\n \n#define CDNS_TX_TIMEOUT\t\t\t\t500\n\n#define CDNS_SCP_RX_FIFOLEVEL\t\t\t0x2\n\n \nstatic inline u32 cdns_readl(struct sdw_cdns *cdns, int offset)\n{\n\treturn readl(cdns->registers + offset);\n}\n\nstatic inline void cdns_writel(struct sdw_cdns *cdns, int offset, u32 value)\n{\n\twritel(value, cdns->registers + offset);\n}\n\nstatic inline u32 cdns_ip_readl(struct sdw_cdns *cdns, int offset)\n{\n\treturn cdns_readl(cdns, cdns->ip_offset + offset);\n}\n\nstatic inline void cdns_ip_writel(struct sdw_cdns *cdns, int offset, u32 value)\n{\n\treturn cdns_writel(cdns, cdns->ip_offset + offset, value);\n}\n\nstatic inline void cdns_updatel(struct sdw_cdns *cdns,\n\t\t\t\tint offset, u32 mask, u32 val)\n{\n\tu32 tmp;\n\n\ttmp = cdns_readl(cdns, offset);\n\ttmp = (tmp & ~mask) | val;\n\tcdns_writel(cdns, offset, tmp);\n}\n\nstatic inline void cdns_ip_updatel(struct sdw_cdns *cdns,\n\t\t\t\t   int offset, u32 mask, u32 val)\n{\n\tcdns_updatel(cdns, cdns->ip_offset + offset, mask, val);\n}\n\nstatic int cdns_set_wait(struct sdw_cdns *cdns, int offset, u32 mask, u32 value)\n{\n\tint timeout = 10;\n\tu32 reg_read;\n\n\t \n\tdo {\n\t\treg_read = readl(cdns->registers + offset);\n\t\tif ((reg_read & mask) == value)\n\t\t\treturn 0;\n\n\t\ttimeout--;\n\t\tusleep_range(50, 100);\n\t} while (timeout != 0);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cdns_clear_bit(struct sdw_cdns *cdns, int offset, u32 value)\n{\n\twritel(value, cdns->registers + offset);\n\n\t \n\treturn cdns_set_wait(cdns, offset, value, 0);\n}\n\n \nstatic int cdns_config_update(struct sdw_cdns *cdns)\n{\n\tint ret;\n\n\tif (sdw_cdns_is_clock_stop(cdns)) {\n\t\tdev_err(cdns->dev, \"Cannot program MCP_CONFIG_UPDATE in ClockStopMode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = cdns_clear_bit(cdns, CDNS_MCP_CONFIG_UPDATE,\n\t\t\t     CDNS_MCP_CONFIG_UPDATE_BIT);\n\tif (ret < 0)\n\t\tdev_err(cdns->dev, \"Config update timedout\\n\");\n\n\treturn ret;\n}\n\n \nvoid sdw_cdns_config_update(struct sdw_cdns *cdns)\n{\n\t \n\tcdns_writel(cdns, CDNS_MCP_CONFIG_UPDATE, CDNS_MCP_CONFIG_UPDATE_BIT);\n}\nEXPORT_SYMBOL(sdw_cdns_config_update);\n\n \nint sdw_cdns_config_update_set_wait(struct sdw_cdns *cdns)\n{\n\t \n\treturn cdns_set_wait(cdns, CDNS_MCP_CONFIG_UPDATE,\n\t\t\t     CDNS_MCP_CONFIG_UPDATE_BIT, 0);\n}\nEXPORT_SYMBOL(sdw_cdns_config_update_set_wait);\n\n \n#ifdef CONFIG_DEBUG_FS\n\n#define RD_BUF (2 * PAGE_SIZE)\n\nstatic ssize_t cdns_sprintf(struct sdw_cdns *cdns,\n\t\t\t    char *buf, size_t pos, unsigned int reg)\n{\n\treturn scnprintf(buf + pos, RD_BUF - pos,\n\t\t\t \"%4x\\t%8x\\n\", reg, cdns_readl(cdns, reg));\n}\n\nstatic int cdns_reg_show(struct seq_file *s, void *data)\n{\n\tstruct sdw_cdns *cdns = s->private;\n\tchar *buf;\n\tssize_t ret;\n\tint num_ports;\n\tint i, j;\n\n\tbuf = kzalloc(RD_BUF, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = scnprintf(buf, RD_BUF, \"Register  Value\\n\");\n\tret += scnprintf(buf + ret, RD_BUF - ret, \"\\nMCP Registers\\n\");\n\t \n\tfor (i = CDNS_MCP_CONFIG; i <= CDNS_MCP_PHYCTRL; i += sizeof(u32))\n\t\tret += cdns_sprintf(cdns, buf, ret, i);\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nStatus & Intr Registers\\n\");\n\t \n\tfor (i = CDNS_MCP_STAT; i <=  CDNS_MCP_FIFOSTAT; i += sizeof(u32))\n\t\tret += cdns_sprintf(cdns, buf, ret, i);\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nSSP & Clk ctrl Registers\\n\");\n\tret += cdns_sprintf(cdns, buf, ret, CDNS_MCP_SSP_CTRL0);\n\tret += cdns_sprintf(cdns, buf, ret, CDNS_MCP_SSP_CTRL1);\n\tret += cdns_sprintf(cdns, buf, ret, CDNS_MCP_CLK_CTRL0);\n\tret += cdns_sprintf(cdns, buf, ret, CDNS_MCP_CLK_CTRL1);\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nDPn B0 Registers\\n\");\n\n\tnum_ports = cdns->num_ports;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t\t \"\\nDP-%d\\n\", i);\n\t\tfor (j = CDNS_DPN_B0_CONFIG(i);\n\t\t     j < CDNS_DPN_B0_ASYNC_CTRL(i); j += sizeof(u32))\n\t\t\tret += cdns_sprintf(cdns, buf, ret, j);\n\t}\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nDPn B1 Registers\\n\");\n\tfor (i = 0; i < num_ports; i++) {\n\t\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t\t \"\\nDP-%d\\n\", i);\n\n\t\tfor (j = CDNS_DPN_B1_CONFIG(i);\n\t\t     j < CDNS_DPN_B1_ASYNC_CTRL(i); j += sizeof(u32))\n\t\t\tret += cdns_sprintf(cdns, buf, ret, j);\n\t}\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nDPn Control Registers\\n\");\n\tfor (i = 0; i < num_ports; i++)\n\t\tret += cdns_sprintf(cdns, buf, ret,\n\t\t\t\tCDNS_PORTCTRL + i * CDNS_PORT_OFFSET);\n\n\tret += scnprintf(buf + ret, RD_BUF - ret,\n\t\t\t \"\\nPDIn Config Registers\\n\");\n\n\t \n\tfor (i = 0; i < num_ports; i++)\n\t\tret += cdns_sprintf(cdns, buf, ret, CDNS_PDI_CONFIG(i));\n\n\tseq_printf(s, \"%s\", buf);\n\tkfree(buf);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cdns_reg);\n\nstatic int cdns_hw_reset(void *data, u64 value)\n{\n\tstruct sdw_cdns *cdns = data;\n\tint ret;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tret = sdw_cdns_exit_reset(cdns);\n\n\tdev_dbg(cdns->dev, \"link hw_reset done: %d\\n\", ret);\n\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(cdns_hw_reset_fops, NULL, cdns_hw_reset, \"%llu\\n\");\n\nstatic int cdns_parity_error_injection(void *data, u64 value)\n{\n\tstruct sdw_cdns *cdns = data;\n\tstruct sdw_bus *bus;\n\tint ret;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\tbus = &cdns->bus;\n\n\t \n\tret = pm_runtime_resume_and_get(bus->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(cdns->dev,\n\t\t\t\t    \"pm_runtime_resume_and_get failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(200);\n\n\t \n\tmutex_lock(&bus->bus_lock);\n\n\t \n\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CMDCTRL,\n\t\t\tCDNS_IP_MCP_CMDCTRL_INSERT_PARITY_ERR,\n\t\t\tCDNS_IP_MCP_CMDCTRL_INSERT_PARITY_ERR);\n\n\t \n\tret = cdns_clear_bit(cdns, CDNS_MCP_CONFIG_UPDATE, CDNS_MCP_CONFIG_UPDATE_BIT);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tret = sdw_bread_no_pm_unlocked(&cdns->bus, 0xf, SDW_SCP_DEVID_0);\n\tdev_info(cdns->dev, \"parity error injection, read: %d\\n\", ret);\n\n\t \n\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CMDCTRL,\n\t\t\tCDNS_IP_MCP_CMDCTRL_INSERT_PARITY_ERR,\n\t\t\t0);\n\n\t \n\tret = cdns_clear_bit(cdns, CDNS_MCP_CONFIG_UPDATE, CDNS_MCP_CONFIG_UPDATE_BIT);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\nunlock:\n\t \n\tmutex_unlock(&bus->bus_lock);\n\n\t \n\tpm_runtime_mark_last_busy(bus->dev);\n\tpm_runtime_put_autosuspend(bus->dev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(cdns_parity_error_fops, NULL,\n\t\t\t cdns_parity_error_injection, \"%llu\\n\");\n\nstatic int cdns_set_pdi_loopback_source(void *data, u64 value)\n{\n\tstruct sdw_cdns *cdns = data;\n\tunsigned int pdi_out_num = cdns->pcm.num_bd + cdns->pcm.num_out;\n\n\tif (value > pdi_out_num)\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tcdns->pdi_loopback_source = value;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cdns_pdi_loopback_source_fops, NULL, cdns_set_pdi_loopback_source, \"%llu\\n\");\n\nstatic int cdns_set_pdi_loopback_target(void *data, u64 value)\n{\n\tstruct sdw_cdns *cdns = data;\n\tunsigned int pdi_in_num = cdns->pcm.num_bd + cdns->pcm.num_in;\n\n\tif (value > pdi_in_num)\n\t\treturn -EINVAL;\n\n\t \n\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\n\tcdns->pdi_loopback_target = value;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(cdns_pdi_loopback_target_fops, NULL, cdns_set_pdi_loopback_target, \"%llu\\n\");\n\n \nvoid sdw_cdns_debugfs_init(struct sdw_cdns *cdns, struct dentry *root)\n{\n\tdebugfs_create_file(\"cdns-registers\", 0400, root, cdns, &cdns_reg_fops);\n\n\tdebugfs_create_file(\"cdns-hw-reset\", 0200, root, cdns,\n\t\t\t    &cdns_hw_reset_fops);\n\n\tdebugfs_create_file(\"cdns-parity-error-injection\", 0200, root, cdns,\n\t\t\t    &cdns_parity_error_fops);\n\n\tcdns->pdi_loopback_source = -1;\n\tcdns->pdi_loopback_target = -1;\n\n\tdebugfs_create_file(\"cdns-pdi-loopback-source\", 0200, root, cdns,\n\t\t\t    &cdns_pdi_loopback_source_fops);\n\n\tdebugfs_create_file(\"cdns-pdi-loopback-target\", 0200, root, cdns,\n\t\t\t    &cdns_pdi_loopback_target_fops);\n\n}\nEXPORT_SYMBOL_GPL(sdw_cdns_debugfs_init);\n\n#endif  \n\n \nstatic enum sdw_command_response\ncdns_fill_msg_resp(struct sdw_cdns *cdns,\n\t\t   struct sdw_msg *msg, int count, int offset)\n{\n\tint nack = 0, no_ack = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (!(cdns->response_buf[i] & CDNS_MCP_RESP_ACK)) {\n\t\t\tno_ack = 1;\n\t\t\tdev_vdbg(cdns->dev, \"Msg Ack not received, cmd %d\\n\", i);\n\t\t}\n\t\tif (cdns->response_buf[i] & CDNS_MCP_RESP_NACK) {\n\t\t\tnack = 1;\n\t\t\tdev_err_ratelimited(cdns->dev, \"Msg NACK received, cmd %d\\n\", i);\n\t\t}\n\t}\n\n\tif (nack) {\n\t\tdev_err_ratelimited(cdns->dev, \"Msg NACKed for Slave %d\\n\", msg->dev_num);\n\t\treturn SDW_CMD_FAIL;\n\t}\n\n\tif (no_ack) {\n\t\tdev_dbg_ratelimited(cdns->dev, \"Msg ignored for Slave %d\\n\", msg->dev_num);\n\t\treturn SDW_CMD_IGNORED;\n\t}\n\n\tif (msg->flags == SDW_MSG_FLAG_READ) {\n\t\t \n\t\tfor (i = 0; i < count; i++)\n\t\t\tmsg->buf[i + offset] = FIELD_GET(CDNS_MCP_RESP_RDATA,\n\t\t\t\t\t\t\t cdns->response_buf[i]);\n\t}\n\n\treturn SDW_CMD_OK;\n}\n\nstatic void cdns_read_response(struct sdw_cdns *cdns)\n{\n\tu32 num_resp, cmd_base;\n\tint i;\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(cdns->response_buf) < CDNS_MCP_CMD_LEN + 2);\n\n\tnum_resp = cdns_readl(cdns, CDNS_MCP_FIFOSTAT);\n\tnum_resp &= CDNS_MCP_RX_FIFO_AVAIL;\n\tif (num_resp > ARRAY_SIZE(cdns->response_buf)) {\n\t\tdev_warn(cdns->dev, \"RX AVAIL %d too long\\n\", num_resp);\n\t\tnum_resp = ARRAY_SIZE(cdns->response_buf);\n\t}\n\n\tcmd_base = CDNS_IP_MCP_CMD_BASE;\n\n\tfor (i = 0; i < num_resp; i++) {\n\t\tcdns->response_buf[i] = cdns_ip_readl(cdns, cmd_base);\n\t\tcmd_base += CDNS_MCP_CMD_WORD_LEN;\n\t}\n}\n\nstatic enum sdw_command_response\n_cdns_xfer_msg(struct sdw_cdns *cdns, struct sdw_msg *msg, int cmd,\n\t       int offset, int count, bool defer)\n{\n\tunsigned long time;\n\tu32 base, i, data;\n\tu16 addr;\n\n\t \n\tif (cdns->msg_count != count) {\n\t\tcdns_writel(cdns, CDNS_MCP_FIFOLEVEL, count);\n\t\tcdns->msg_count = count;\n\t}\n\n\tbase = CDNS_IP_MCP_CMD_BASE;\n\taddr = msg->addr + offset;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata = FIELD_PREP(CDNS_MCP_CMD_DEV_ADDR, msg->dev_num);\n\t\tdata |= FIELD_PREP(CDNS_MCP_CMD_COMMAND, cmd);\n\t\tdata |= FIELD_PREP(CDNS_MCP_CMD_REG_ADDR, addr);\n\t\taddr++;\n\n\t\tif (msg->flags == SDW_MSG_FLAG_WRITE)\n\t\t\tdata |= msg->buf[i + offset];\n\n\t\tdata |= FIELD_PREP(CDNS_MCP_CMD_SSP_TAG, msg->ssp_sync);\n\t\tcdns_ip_writel(cdns, base, data);\n\t\tbase += CDNS_MCP_CMD_WORD_LEN;\n\t}\n\n\tif (defer)\n\t\treturn SDW_CMD_OK;\n\n\t \n\ttime = wait_for_completion_timeout(&cdns->tx_complete,\n\t\t\t\t\t   msecs_to_jiffies(CDNS_TX_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(cdns->dev, \"IO transfer timed out, cmd %d device %d addr %x len %d\\n\",\n\t\t\tcmd, msg->dev_num, msg->addr, msg->len);\n\t\tmsg->len = 0;\n\n\t\t \n\t\tcdns_read_response(cdns);\n\n\t\treturn SDW_CMD_TIMEOUT;\n\t}\n\n\treturn cdns_fill_msg_resp(cdns, msg, count, offset);\n}\n\nstatic enum sdw_command_response\ncdns_program_scp_addr(struct sdw_cdns *cdns, struct sdw_msg *msg)\n{\n\tint nack = 0, no_ack = 0;\n\tunsigned long time;\n\tu32 data[2], base;\n\tint i;\n\n\t \n\tif (cdns->msg_count != CDNS_SCP_RX_FIFOLEVEL) {\n\t\tcdns_writel(cdns, CDNS_MCP_FIFOLEVEL, CDNS_SCP_RX_FIFOLEVEL);\n\t\tcdns->msg_count = CDNS_SCP_RX_FIFOLEVEL;\n\t}\n\n\tdata[0] = FIELD_PREP(CDNS_MCP_CMD_DEV_ADDR, msg->dev_num);\n\tdata[0] |= FIELD_PREP(CDNS_MCP_CMD_COMMAND, 0x3);\n\tdata[1] = data[0];\n\n\tdata[0] |= FIELD_PREP(CDNS_MCP_CMD_REG_ADDR, SDW_SCP_ADDRPAGE1);\n\tdata[1] |= FIELD_PREP(CDNS_MCP_CMD_REG_ADDR, SDW_SCP_ADDRPAGE2);\n\n\tdata[0] |= msg->addr_page1;\n\tdata[1] |= msg->addr_page2;\n\n\tbase = CDNS_IP_MCP_CMD_BASE;\n\tcdns_ip_writel(cdns, base, data[0]);\n\tbase += CDNS_MCP_CMD_WORD_LEN;\n\tcdns_ip_writel(cdns, base, data[1]);\n\n\ttime = wait_for_completion_timeout(&cdns->tx_complete,\n\t\t\t\t\t   msecs_to_jiffies(CDNS_TX_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(cdns->dev, \"SCP Msg trf timed out\\n\");\n\t\tmsg->len = 0;\n\t\treturn SDW_CMD_TIMEOUT;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (!(cdns->response_buf[i] & CDNS_MCP_RESP_ACK)) {\n\t\t\tno_ack = 1;\n\t\t\tdev_err(cdns->dev, \"Program SCP Ack not received\\n\");\n\t\t\tif (cdns->response_buf[i] & CDNS_MCP_RESP_NACK) {\n\t\t\t\tnack = 1;\n\t\t\t\tdev_err(cdns->dev, \"Program SCP NACK received\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (nack) {\n\t\tdev_err_ratelimited(cdns->dev,\n\t\t\t\t    \"SCP_addrpage NACKed for Slave %d\\n\", msg->dev_num);\n\t\treturn SDW_CMD_FAIL;\n\t}\n\n\tif (no_ack) {\n\t\tdev_dbg_ratelimited(cdns->dev,\n\t\t\t\t    \"SCP_addrpage ignored for Slave %d\\n\", msg->dev_num);\n\t\treturn SDW_CMD_IGNORED;\n\t}\n\n\treturn SDW_CMD_OK;\n}\n\nstatic int cdns_prep_msg(struct sdw_cdns *cdns, struct sdw_msg *msg, int *cmd)\n{\n\tint ret;\n\n\tif (msg->page) {\n\t\tret = cdns_program_scp_addr(cdns, msg);\n\t\tif (ret) {\n\t\t\tmsg->len = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tswitch (msg->flags) {\n\tcase SDW_MSG_FLAG_READ:\n\t\t*cmd = CDNS_MCP_CMD_READ;\n\t\tbreak;\n\n\tcase SDW_MSG_FLAG_WRITE:\n\t\t*cmd = CDNS_MCP_CMD_WRITE;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(cdns->dev, \"Invalid msg cmd: %d\\n\", msg->flags);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nenum sdw_command_response\ncdns_xfer_msg(struct sdw_bus *bus, struct sdw_msg *msg)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tint cmd = 0, ret, i;\n\n\tret = cdns_prep_msg(cdns, msg, &cmd);\n\tif (ret)\n\t\treturn SDW_CMD_FAIL_OTHER;\n\n\tfor (i = 0; i < msg->len / CDNS_MCP_CMD_LEN; i++) {\n\t\tret = _cdns_xfer_msg(cdns, msg, cmd, i * CDNS_MCP_CMD_LEN,\n\t\t\t\t     CDNS_MCP_CMD_LEN, false);\n\t\tif (ret != SDW_CMD_OK)\n\t\t\treturn ret;\n\t}\n\n\tif (!(msg->len % CDNS_MCP_CMD_LEN))\n\t\treturn SDW_CMD_OK;\n\n\treturn _cdns_xfer_msg(cdns, msg, cmd, i * CDNS_MCP_CMD_LEN,\n\t\t\t      msg->len % CDNS_MCP_CMD_LEN, false);\n}\nEXPORT_SYMBOL(cdns_xfer_msg);\n\nenum sdw_command_response\ncdns_xfer_msg_defer(struct sdw_bus *bus)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tstruct sdw_defer *defer = &bus->defer_msg;\n\tstruct sdw_msg *msg = defer->msg;\n\tint cmd = 0, ret;\n\n\t \n\tif (msg->len > 1)\n\t\treturn -ENOTSUPP;\n\n\tret = cdns_prep_msg(cdns, msg, &cmd);\n\tif (ret)\n\t\treturn SDW_CMD_FAIL_OTHER;\n\n\treturn _cdns_xfer_msg(cdns, msg, cmd, 0, msg->len, true);\n}\nEXPORT_SYMBOL(cdns_xfer_msg_defer);\n\nu32 cdns_read_ping_status(struct sdw_bus *bus)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\n\treturn cdns_readl(cdns, CDNS_MCP_SLAVE_STAT);\n}\nEXPORT_SYMBOL(cdns_read_ping_status);\n\n \n\nstatic int cdns_update_slave_status(struct sdw_cdns *cdns,\n\t\t\t\t    u64 slave_intstat)\n{\n\tenum sdw_slave_status status[SDW_MAX_DEVICES + 1];\n\tbool is_slave = false;\n\tu32 mask;\n\tu32 val;\n\tint i, set_status;\n\n\tmemset(status, 0, sizeof(status));\n\n\tfor (i = 0; i <= SDW_MAX_DEVICES; i++) {\n\t\tmask = (slave_intstat >> (i * CDNS_MCP_SLAVE_STATUS_NUM)) &\n\t\t\tCDNS_MCP_SLAVE_STATUS_BITS;\n\n\t\tset_status = 0;\n\n\t\tif (mask) {\n\t\t\tis_slave = true;\n\n\t\t\tif (mask & CDNS_MCP_SLAVE_INTSTAT_RESERVED) {\n\t\t\t\tstatus[i] = SDW_SLAVE_RESERVED;\n\t\t\t\tset_status++;\n\t\t\t}\n\n\t\t\tif (mask & CDNS_MCP_SLAVE_INTSTAT_ATTACHED) {\n\t\t\t\tstatus[i] = SDW_SLAVE_ATTACHED;\n\t\t\t\tset_status++;\n\t\t\t}\n\n\t\t\tif (mask & CDNS_MCP_SLAVE_INTSTAT_ALERT) {\n\t\t\t\tstatus[i] = SDW_SLAVE_ALERT;\n\t\t\t\tset_status++;\n\t\t\t}\n\n\t\t\tif (mask & CDNS_MCP_SLAVE_INTSTAT_NPRESENT) {\n\t\t\t\tstatus[i] = SDW_SLAVE_UNATTACHED;\n\t\t\t\tset_status++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (set_status != 1) {\n\t\t\tval = cdns_readl(cdns, CDNS_MCP_SLAVE_STAT);\n\t\t\tval >>= (i * 2);\n\n\t\t\tswitch (val & 0x3) {\n\t\t\tcase 0:\n\t\t\t\tstatus[i] = SDW_SLAVE_UNATTACHED;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tstatus[i] = SDW_SLAVE_ATTACHED;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstatus[i] = SDW_SLAVE_ALERT;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\tstatus[i] = SDW_SLAVE_RESERVED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_slave)\n\t\treturn sdw_handle_slave_status(&cdns->bus, status);\n\n\treturn 0;\n}\n\n \nirqreturn_t sdw_cdns_irq(int irq, void *dev_id)\n{\n\tstruct sdw_cdns *cdns = dev_id;\n\tu32 int_status;\n\n\t \n\tif (!cdns->link_up)\n\t\treturn IRQ_NONE;\n\n\tint_status = cdns_readl(cdns, CDNS_MCP_INTSTAT);\n\n\t \n\tif (int_status & CDNS_MCP_INT_RESERVED)\n\t\treturn IRQ_NONE;\n\n\tif (!(int_status & CDNS_MCP_INT_IRQ))\n\t\treturn IRQ_NONE;\n\n\tif (int_status & CDNS_MCP_INT_RX_WL) {\n\t\tstruct sdw_bus *bus = &cdns->bus;\n\t\tstruct sdw_defer *defer = &bus->defer_msg;\n\n\t\tcdns_read_response(cdns);\n\n\t\tif (defer && defer->msg) {\n\t\t\tcdns_fill_msg_resp(cdns, defer->msg,\n\t\t\t\t\t   defer->length, 0);\n\t\t\tcomplete(&defer->complete);\n\t\t} else {\n\t\t\tcomplete(&cdns->tx_complete);\n\t\t}\n\t}\n\n\tif (int_status & CDNS_MCP_INT_PARITY) {\n\t\t \n\t\tdev_err_ratelimited(cdns->dev, \"Parity error\\n\");\n\t}\n\n\tif (int_status & CDNS_MCP_INT_CTRL_CLASH) {\n\t\t \n\t\tdev_err_ratelimited(cdns->dev, \"Bus clash for control word\\n\");\n\t}\n\n\tif (int_status & CDNS_MCP_INT_DATA_CLASH) {\n\t\t \n\t\tdev_err_ratelimited(cdns->dev, \"Bus clash for data word\\n\");\n\t}\n\n\tif (cdns->bus.params.m_data_mode != SDW_PORT_DATA_MODE_NORMAL &&\n\t    int_status & CDNS_MCP_INT_DPINT) {\n\t\tu32 port_intstat;\n\n\t\t \n\t\tport_intstat = cdns_readl(cdns, CDNS_MCP_PORT_INTSTAT);\n\t\tdev_err_ratelimited(cdns->dev, \"DP interrupt: PortIntStat %8x\\n\",\n\t\t\t\t    port_intstat);\n\n\t\t \n\t\tcdns_writel(cdns, CDNS_MCP_PORT_INTSTAT, port_intstat);\n\t}\n\n\tif (int_status & CDNS_MCP_INT_SLAVE_MASK) {\n\t\t \n\t\tcdns_updatel(cdns, CDNS_MCP_INTMASK,\n\t\t\t     CDNS_MCP_INT_SLAVE_MASK, 0);\n\n\t\tint_status &= ~CDNS_MCP_INT_SLAVE_MASK;\n\n\t\t \n\t\tif (cdns->interrupt_enabled)\n\t\t\tschedule_work(&cdns->work);\n\t}\n\n\tcdns_writel(cdns, CDNS_MCP_INTSTAT, int_status);\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(sdw_cdns_irq);\n\n \nstatic void cdns_update_slave_status_work(struct work_struct *work)\n{\n\tstruct sdw_cdns *cdns =\n\t\tcontainer_of(work, struct sdw_cdns, work);\n\tu32 slave0, slave1;\n\tu64 slave_intstat;\n\tu32 device0_status;\n\tint retry_count = 0;\n\n\t \n\tcdns_writel(cdns, CDNS_MCP_INTSTAT, CDNS_MCP_INT_SLAVE_MASK);\n\n\tslave0 = cdns_readl(cdns, CDNS_MCP_SLAVE_INTSTAT0);\n\tslave1 = cdns_readl(cdns, CDNS_MCP_SLAVE_INTSTAT1);\n\n\t \n\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTSTAT0, slave0);\n\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTSTAT1, slave1);\n\n\t \n\tslave_intstat = ((u64)slave1 << 32) | slave0;\n\n\tdev_dbg_ratelimited(cdns->dev, \"Slave status change: 0x%llx\\n\", slave_intstat);\n\nupdate_status:\n\tcdns_update_slave_status(cdns, slave_intstat);\n\n\t \n\n\tdevice0_status = cdns_readl(cdns, CDNS_MCP_SLAVE_STAT);\n\tdevice0_status &= 3;\n\n\tif (device0_status == SDW_SLAVE_ATTACHED) {\n\t\tif (retry_count++ < SDW_MAX_DEVICES) {\n\t\t\tdev_dbg_ratelimited(cdns->dev,\n\t\t\t\t\t    \"Device0 detected after clearing status, iteration %d\\n\",\n\t\t\t\t\t    retry_count);\n\t\t\tslave_intstat = CDNS_MCP_SLAVE_INTSTAT_ATTACHED;\n\t\t\tgoto update_status;\n\t\t} else {\n\t\t\tdev_err_ratelimited(cdns->dev,\n\t\t\t\t\t    \"Device0 detected after %d iterations\\n\",\n\t\t\t\t\t    retry_count);\n\t\t}\n\t}\n\n\t \n\tcdns_updatel(cdns, CDNS_MCP_INTMASK,\n\t\t     CDNS_MCP_INT_SLAVE_MASK, CDNS_MCP_INT_SLAVE_MASK);\n\n}\n\n \nvoid sdw_cdns_check_self_clearing_bits(struct sdw_cdns *cdns, const char *string,\n\t\t\t\t       bool initial_delay, int reset_iterations)\n{\n\tu32 ip_mcp_control;\n\tu32 mcp_control;\n\tu32 mcp_config_update;\n\tint i;\n\n\tif (initial_delay)\n\t\tusleep_range(1000, 1500);\n\n\tip_mcp_control = cdns_ip_readl(cdns, CDNS_IP_MCP_CONTROL);\n\n\t \n\tif (ip_mcp_control & CDNS_IP_MCP_CONTROL_SW_RST)\n\t\tdev_err(cdns->dev, \"%s failed: IP_MCP_CONTROL_SW_RST is not cleared\\n\", string);\n\n\tmcp_control = cdns_readl(cdns, CDNS_MCP_CONTROL);\n\n\t \n\tif (mcp_control & CDNS_MCP_CONTROL_CMD_RST)\n\t\tdev_err(cdns->dev, \"%s failed: MCP_CONTROL_CMD_RST is not cleared\\n\", string);\n\tif (mcp_control & CDNS_MCP_CONTROL_SOFT_RST)\n\t\tdev_err(cdns->dev, \"%s failed: MCP_CONTROL_SOFT_RST is not cleared\\n\", string);\n\tif (mcp_control & CDNS_MCP_CONTROL_CLK_STOP_CLR)\n\t\tdev_err(cdns->dev, \"%s failed: MCP_CONTROL_CLK_STOP_CLR is not cleared\\n\", string);\n\n\tmcp_config_update = cdns_readl(cdns, CDNS_MCP_CONFIG_UPDATE);\n\tif (mcp_config_update & CDNS_MCP_CONFIG_UPDATE_BIT)\n\t\tdev_err(cdns->dev, \"%s failed: MCP_CONFIG_UPDATE_BIT is not cleared\\n\", string);\n\n\ti = 0;\n\twhile (mcp_control & CDNS_MCP_CONTROL_HW_RST) {\n\t\tif (i == reset_iterations) {\n\t\t\tdev_err(cdns->dev, \"%s failed: MCP_CONTROL_HW_RST is not cleared\\n\", string);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(cdns->dev, \"%s: MCP_CONTROL_HW_RST is not cleared at iteration %d\\n\", string, i);\n\t\ti++;\n\n\t\tusleep_range(1000, 1500);\n\t\tmcp_control = cdns_readl(cdns, CDNS_MCP_CONTROL);\n\t}\n\n}\nEXPORT_SYMBOL(sdw_cdns_check_self_clearing_bits);\n\n \n\n \nint sdw_cdns_exit_reset(struct sdw_cdns *cdns)\n{\n\t \n\n\t \n\tcdns_updatel(cdns, CDNS_MCP_CONTROL,\n\t\t     CDNS_MCP_CONTROL_HW_RST,\n\t\t     CDNS_MCP_CONTROL_HW_RST);\n\n\t \n\treturn cdns_config_update(cdns);\n}\nEXPORT_SYMBOL(sdw_cdns_exit_reset);\n\n \nstatic void cdns_enable_slave_interrupts(struct sdw_cdns *cdns, bool state)\n{\n\tu32 mask;\n\n\tmask = cdns_readl(cdns, CDNS_MCP_INTMASK);\n\tif (state)\n\t\tmask |= CDNS_MCP_INT_SLAVE_MASK;\n\telse\n\t\tmask &= ~CDNS_MCP_INT_SLAVE_MASK;\n\n\tcdns_writel(cdns, CDNS_MCP_INTMASK, mask);\n}\n\n \nint sdw_cdns_enable_interrupt(struct sdw_cdns *cdns, bool state)\n{\n\tu32 slave_intmask0 = 0;\n\tu32 slave_intmask1 = 0;\n\tu32 mask = 0;\n\n\tif (!state)\n\t\tgoto update_masks;\n\n\tslave_intmask0 = CDNS_MCP_SLAVE_INTMASK0_MASK;\n\tslave_intmask1 = CDNS_MCP_SLAVE_INTMASK1_MASK;\n\n\t \n\tmask = CDNS_MCP_INT_SLAVE_MASK;\n\n\t \n\tmask |= CDNS_MCP_INT_CTRL_CLASH | CDNS_MCP_INT_DATA_CLASH |\n\t\tCDNS_MCP_INT_PARITY;\n\n\t \n\tif (cdns->bus.params.m_data_mode != SDW_PORT_DATA_MODE_NORMAL)\n\t\tmask |= CDNS_MCP_INT_DPINT;\n\n\t \n\tmask |= CDNS_MCP_INT_RX_WL;\n\n\t \n\tmask |= CDNS_MCP_INT_IRQ;\n\n\tif (interrupt_mask)  \n\t\tmask = interrupt_mask;\n\nupdate_masks:\n\t \n\tif (state) {\n\t\tu32 slave_state;\n\n\t\tslave_state = cdns_readl(cdns, CDNS_MCP_SLAVE_INTSTAT0);\n\t\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTSTAT0, slave_state);\n\t\tslave_state = cdns_readl(cdns, CDNS_MCP_SLAVE_INTSTAT1);\n\t\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTSTAT1, slave_state);\n\t}\n\tcdns->interrupt_enabled = state;\n\n\t \n\tif (!state)\n\t\tcancel_work_sync(&cdns->work);\n\n\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTMASK0, slave_intmask0);\n\tcdns_writel(cdns, CDNS_MCP_SLAVE_INTMASK1, slave_intmask1);\n\tcdns_writel(cdns, CDNS_MCP_INTMASK, mask);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_cdns_enable_interrupt);\n\nstatic int cdns_allocate_pdi(struct sdw_cdns *cdns,\n\t\t\t     struct sdw_cdns_pdi **stream,\n\t\t\t     u32 num, u32 pdi_offset)\n{\n\tstruct sdw_cdns_pdi *pdi;\n\tint i;\n\n\tif (!num)\n\t\treturn 0;\n\n\tpdi = devm_kcalloc(cdns->dev, num, sizeof(*pdi), GFP_KERNEL);\n\tif (!pdi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tpdi[i].num = i + pdi_offset;\n\t}\n\n\t*stream = pdi;\n\treturn 0;\n}\n\n \nint sdw_cdns_pdi_init(struct sdw_cdns *cdns,\n\t\t      struct sdw_cdns_stream_config config)\n{\n\tstruct sdw_cdns_streams *stream;\n\tint offset;\n\tint ret;\n\n\tcdns->pcm.num_bd = config.pcm_bd;\n\tcdns->pcm.num_in = config.pcm_in;\n\tcdns->pcm.num_out = config.pcm_out;\n\n\t \n\tstream = &cdns->pcm;\n\n\t \n\toffset = 0;\n\n\tret = cdns_allocate_pdi(cdns, &stream->bd,\n\t\t\t\tstream->num_bd, offset);\n\tif (ret)\n\t\treturn ret;\n\n\toffset += stream->num_bd;\n\n\tret = cdns_allocate_pdi(cdns, &stream->in,\n\t\t\t\tstream->num_in, offset);\n\tif (ret)\n\t\treturn ret;\n\n\toffset += stream->num_in;\n\n\tret = cdns_allocate_pdi(cdns, &stream->out,\n\t\t\t\tstream->num_out, offset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstream->num_pdi = stream->num_bd + stream->num_in + stream->num_out;\n\tcdns->num_ports = stream->num_pdi;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_cdns_pdi_init);\n\nstatic u32 cdns_set_initial_frame_shape(int n_rows, int n_cols)\n{\n\tu32 val;\n\tint c;\n\tint r;\n\n\tr = sdw_find_row_index(n_rows);\n\tc = sdw_find_col_index(n_cols);\n\n\tval = FIELD_PREP(CDNS_MCP_FRAME_SHAPE_ROW_MASK, r);\n\tval |= FIELD_PREP(CDNS_MCP_FRAME_SHAPE_COL_MASK, c);\n\n\treturn val;\n}\n\nstatic void cdns_init_clock_ctrl(struct sdw_cdns *cdns)\n{\n\tstruct sdw_bus *bus = &cdns->bus;\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tu32 val;\n\tu32 ssp_interval;\n\tint divider;\n\n\t \n\tdivider\t= (prop->mclk_freq / prop->max_clk_freq) - 1;\n\n\tcdns_updatel(cdns, CDNS_MCP_CLK_CTRL0,\n\t\t     CDNS_MCP_CLK_MCLKD_MASK, divider);\n\tcdns_updatel(cdns, CDNS_MCP_CLK_CTRL1,\n\t\t     CDNS_MCP_CLK_MCLKD_MASK, divider);\n\n\t \n\tval = cdns_set_initial_frame_shape(prop->default_row,\n\t\t\t\t\t   prop->default_col);\n\tcdns_writel(cdns, CDNS_MCP_FRAME_SHAPE_INIT, val);\n\n\t \n\tssp_interval = prop->default_frame_rate / SDW_CADENCE_GSYNC_HZ;\n\tcdns_writel(cdns, CDNS_MCP_SSP_CTRL0, ssp_interval);\n\tcdns_writel(cdns, CDNS_MCP_SSP_CTRL1, ssp_interval);\n}\n\n \nint sdw_cdns_init(struct sdw_cdns *cdns)\n{\n\tu32 val;\n\n\tcdns_init_clock_ctrl(cdns);\n\n\tsdw_cdns_check_self_clearing_bits(cdns, __func__, false, 0);\n\n\t \n\tcdns->msg_count = cdns_readl(cdns, CDNS_MCP_FIFOLEVEL);\n\n\t \n\tcdns_updatel(cdns, CDNS_MCP_CONTROL, CDNS_MCP_CONTROL_CMD_RST,\n\t\t     CDNS_MCP_CONTROL_CMD_RST);\n\n\t \n\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CONTROL, CDNS_IP_MCP_CONTROL_CMD_ACCEPT,\n\t\t\tCDNS_IP_MCP_CONTROL_CMD_ACCEPT);\n\n\t \n\tval = cdns_readl(cdns, CDNS_MCP_CONFIG);\n\n\t \n\tval &= ~CDNS_MCP_CONFIG_BUS_REL;\n\n\tcdns_writel(cdns, CDNS_MCP_CONFIG, val);\n\n\t \n\tval = cdns_ip_readl(cdns, CDNS_IP_MCP_CONFIG);\n\n\t \n\tval &= ~CDNS_IP_MCP_CONFIG_OP;\n\tval |= CDNS_IP_MCP_CONFIG_OP_NORMAL;\n\n\t \n\tval &= ~CDNS_IP_MCP_CONFIG_CMD;\n\n\t \n\tval &= ~CDNS_IP_MCP_CONFIG_SNIFFER;\n\n\tif (cdns->bus.multi_link)\n\t\t \n\t\tval |= CDNS_IP_MCP_CONFIG_MMASTER;\n\n\t \n\n\t \n\n\tcdns_ip_writel(cdns, CDNS_IP_MCP_CONFIG, val);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_cdns_init);\n\nint cdns_bus_conf(struct sdw_bus *bus, struct sdw_bus_params *params)\n{\n\tstruct sdw_master_prop *prop = &bus->prop;\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tint mcp_clkctrl_off;\n\tint divider;\n\n\tif (!params->curr_dr_freq) {\n\t\tdev_err(cdns->dev, \"NULL curr_dr_freq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdivider\t= prop->mclk_freq * SDW_DOUBLE_RATE_FACTOR /\n\t\tparams->curr_dr_freq;\n\tdivider--;  \n\n\tif (params->next_bank)\n\t\tmcp_clkctrl_off = CDNS_MCP_CLK_CTRL1;\n\telse\n\t\tmcp_clkctrl_off = CDNS_MCP_CLK_CTRL0;\n\n\tcdns_updatel(cdns, mcp_clkctrl_off, CDNS_MCP_CLK_MCLKD_MASK, divider);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cdns_bus_conf);\n\nstatic int cdns_port_params(struct sdw_bus *bus,\n\t\t\t    struct sdw_port_params *p_params, unsigned int bank)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tint dpn_config_off_source;\n\tint dpn_config_off_target;\n\tint target_num = p_params->num;\n\tint source_num = p_params->num;\n\tbool override = false;\n\tint dpn_config;\n\n\tif (target_num == cdns->pdi_loopback_target &&\n\t    cdns->pdi_loopback_source != -1) {\n\t\tsource_num = cdns->pdi_loopback_source;\n\t\toverride = true;\n\t}\n\n\tif (bank) {\n\t\tdpn_config_off_source = CDNS_DPN_B1_CONFIG(source_num);\n\t\tdpn_config_off_target = CDNS_DPN_B1_CONFIG(target_num);\n\t} else {\n\t\tdpn_config_off_source = CDNS_DPN_B0_CONFIG(source_num);\n\t\tdpn_config_off_target = CDNS_DPN_B0_CONFIG(target_num);\n\t}\n\n\tdpn_config = cdns_readl(cdns, dpn_config_off_source);\n\n\t \n\tif (!override) {\n\t\tu32p_replace_bits(&dpn_config, p_params->bps - 1, CDNS_DPN_CONFIG_WL);\n\t\tu32p_replace_bits(&dpn_config, p_params->flow_mode, CDNS_DPN_CONFIG_PORT_FLOW);\n\t\tu32p_replace_bits(&dpn_config, p_params->data_mode, CDNS_DPN_CONFIG_PORT_DAT);\n\t}\n\n\tcdns_writel(cdns, dpn_config_off_target, dpn_config);\n\n\treturn 0;\n}\n\nstatic int cdns_transport_params(struct sdw_bus *bus,\n\t\t\t\t struct sdw_transport_params *t_params,\n\t\t\t\t enum sdw_reg_bank bank)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tint dpn_config;\n\tint dpn_config_off_source;\n\tint dpn_config_off_target;\n\tint dpn_hctrl;\n\tint dpn_hctrl_off_source;\n\tint dpn_hctrl_off_target;\n\tint dpn_offsetctrl;\n\tint dpn_offsetctrl_off_source;\n\tint dpn_offsetctrl_off_target;\n\tint dpn_samplectrl;\n\tint dpn_samplectrl_off_source;\n\tint dpn_samplectrl_off_target;\n\tint source_num = t_params->port_num;\n\tint target_num = t_params->port_num;\n\tbool override = false;\n\n\tif (target_num == cdns->pdi_loopback_target &&\n\t    cdns->pdi_loopback_source != -1) {\n\t\tsource_num = cdns->pdi_loopback_source;\n\t\toverride = true;\n\t}\n\n\t \n\n\tif (bank) {\n\t\tdpn_config_off_source = CDNS_DPN_B1_CONFIG(source_num);\n\t\tdpn_hctrl_off_source = CDNS_DPN_B1_HCTRL(source_num);\n\t\tdpn_offsetctrl_off_source = CDNS_DPN_B1_OFFSET_CTRL(source_num);\n\t\tdpn_samplectrl_off_source = CDNS_DPN_B1_SAMPLE_CTRL(source_num);\n\n\t\tdpn_config_off_target = CDNS_DPN_B1_CONFIG(target_num);\n\t\tdpn_hctrl_off_target = CDNS_DPN_B1_HCTRL(target_num);\n\t\tdpn_offsetctrl_off_target = CDNS_DPN_B1_OFFSET_CTRL(target_num);\n\t\tdpn_samplectrl_off_target = CDNS_DPN_B1_SAMPLE_CTRL(target_num);\n\n\t} else {\n\t\tdpn_config_off_source = CDNS_DPN_B0_CONFIG(source_num);\n\t\tdpn_hctrl_off_source = CDNS_DPN_B0_HCTRL(source_num);\n\t\tdpn_offsetctrl_off_source = CDNS_DPN_B0_OFFSET_CTRL(source_num);\n\t\tdpn_samplectrl_off_source = CDNS_DPN_B0_SAMPLE_CTRL(source_num);\n\n\t\tdpn_config_off_target = CDNS_DPN_B0_CONFIG(target_num);\n\t\tdpn_hctrl_off_target = CDNS_DPN_B0_HCTRL(target_num);\n\t\tdpn_offsetctrl_off_target = CDNS_DPN_B0_OFFSET_CTRL(target_num);\n\t\tdpn_samplectrl_off_target = CDNS_DPN_B0_SAMPLE_CTRL(target_num);\n\t}\n\n\tdpn_config = cdns_readl(cdns, dpn_config_off_source);\n\tif (!override) {\n\t\tu32p_replace_bits(&dpn_config, t_params->blk_grp_ctrl, CDNS_DPN_CONFIG_BGC);\n\t\tu32p_replace_bits(&dpn_config, t_params->blk_pkg_mode, CDNS_DPN_CONFIG_BPM);\n\t}\n\tcdns_writel(cdns, dpn_config_off_target, dpn_config);\n\n\tif (!override) {\n\t\tdpn_offsetctrl = 0;\n\t\tu32p_replace_bits(&dpn_offsetctrl, t_params->offset1, CDNS_DPN_OFFSET_CTRL_1);\n\t\tu32p_replace_bits(&dpn_offsetctrl, t_params->offset2, CDNS_DPN_OFFSET_CTRL_2);\n\t} else {\n\t\tdpn_offsetctrl = cdns_readl(cdns, dpn_offsetctrl_off_source);\n\t}\n\tcdns_writel(cdns, dpn_offsetctrl_off_target,  dpn_offsetctrl);\n\n\tif (!override) {\n\t\tdpn_hctrl = 0;\n\t\tu32p_replace_bits(&dpn_hctrl, t_params->hstart, CDNS_DPN_HCTRL_HSTART);\n\t\tu32p_replace_bits(&dpn_hctrl, t_params->hstop, CDNS_DPN_HCTRL_HSTOP);\n\t\tu32p_replace_bits(&dpn_hctrl, t_params->lane_ctrl, CDNS_DPN_HCTRL_LCTRL);\n\t} else {\n\t\tdpn_hctrl = cdns_readl(cdns, dpn_hctrl_off_source);\n\t}\n\tcdns_writel(cdns, dpn_hctrl_off_target, dpn_hctrl);\n\n\tif (!override)\n\t\tdpn_samplectrl = t_params->sample_interval - 1;\n\telse\n\t\tdpn_samplectrl = cdns_readl(cdns, dpn_samplectrl_off_source);\n\tcdns_writel(cdns, dpn_samplectrl_off_target, dpn_samplectrl);\n\n\treturn 0;\n}\n\nstatic int cdns_port_enable(struct sdw_bus *bus,\n\t\t\t    struct sdw_enable_ch *enable_ch, unsigned int bank)\n{\n\tstruct sdw_cdns *cdns = bus_to_cdns(bus);\n\tint dpn_chnen_off, ch_mask;\n\n\tif (bank)\n\t\tdpn_chnen_off = CDNS_DPN_B1_CH_EN(enable_ch->port_num);\n\telse\n\t\tdpn_chnen_off = CDNS_DPN_B0_CH_EN(enable_ch->port_num);\n\n\tch_mask = enable_ch->ch_mask * enable_ch->enable;\n\tcdns_writel(cdns, dpn_chnen_off, ch_mask);\n\n\treturn 0;\n}\n\nstatic const struct sdw_master_port_ops cdns_port_ops = {\n\t.dpn_set_port_params = cdns_port_params,\n\t.dpn_set_port_transport_params = cdns_transport_params,\n\t.dpn_port_enable_ch = cdns_port_enable,\n};\n\n \nbool sdw_cdns_is_clock_stop(struct sdw_cdns *cdns)\n{\n\treturn !!(cdns_readl(cdns, CDNS_MCP_STAT) & CDNS_MCP_STAT_CLK_STOP);\n}\nEXPORT_SYMBOL(sdw_cdns_is_clock_stop);\n\n \nint sdw_cdns_clock_stop(struct sdw_cdns *cdns, bool block_wake)\n{\n\tbool slave_present = false;\n\tstruct sdw_slave *slave;\n\tint ret;\n\n\tsdw_cdns_check_self_clearing_bits(cdns, __func__, false, 0);\n\n\t \n\tif (sdw_cdns_is_clock_stop(cdns)) {\n\t\tdev_dbg(cdns->dev, \"Clock is already stopped\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tcdns_enable_slave_interrupts(cdns, false);\n\n\t \n\tif (block_wake)\n\t\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CONTROL,\n\t\t\t\tCDNS_IP_MCP_CONTROL_BLOCK_WAKEUP,\n\t\t\t\tCDNS_IP_MCP_CONTROL_BLOCK_WAKEUP);\n\n\tlist_for_each_entry(slave, &cdns->bus.slaves, node) {\n\t\tif (slave->status == SDW_SLAVE_ATTACHED ||\n\t\t    slave->status == SDW_SLAVE_ALERT) {\n\t\t\tslave_present = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tret = cdns_config_update(cdns);\n\tif (ret < 0) {\n\t\tdev_err(cdns->dev, \"%s: config_update failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tif (slave_present) {\n\t\tret = sdw_bus_prep_clk_stop(&cdns->bus);\n\t\tif (ret < 0 && ret != -ENODATA) {\n\t\t\tdev_err(cdns->dev, \"prepare clock stop failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = sdw_bus_clk_stop(&cdns->bus);\n\tif (ret < 0 && slave_present && ret != -ENODATA) {\n\t\tdev_err(cdns->dev, \"bus clock stop failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cdns_set_wait(cdns, CDNS_MCP_STAT,\n\t\t\t    CDNS_MCP_STAT_CLK_STOP,\n\t\t\t    CDNS_MCP_STAT_CLK_STOP);\n\tif (ret < 0)\n\t\tdev_err(cdns->dev, \"Clock stop failed %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_cdns_clock_stop);\n\n \nint sdw_cdns_clock_restart(struct sdw_cdns *cdns, bool bus_reset)\n{\n\tint ret;\n\n\t \n\tcdns_enable_slave_interrupts(cdns, true);\n\n\tret = cdns_clear_bit(cdns, CDNS_MCP_CONTROL,\n\t\t\t     CDNS_MCP_CONTROL_CLK_STOP_CLR);\n\tif (ret < 0) {\n\t\tdev_err(cdns->dev, \"Couldn't exit from clock stop\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cdns_set_wait(cdns, CDNS_MCP_STAT, CDNS_MCP_STAT_CLK_STOP, 0);\n\tif (ret < 0) {\n\t\tdev_err(cdns->dev, \"clock stop exit failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CONTROL,\n\t\t\tCDNS_IP_MCP_CONTROL_BLOCK_WAKEUP, 0);\n\n\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CONTROL, CDNS_IP_MCP_CONTROL_CMD_ACCEPT,\n\t\t\tCDNS_IP_MCP_CONTROL_CMD_ACCEPT);\n\n\tif (!bus_reset) {\n\n\t\t \n\t\tcdns_ip_updatel(cdns, CDNS_IP_MCP_CONFIG,\n\t\t\t\tCDNS_IP_MCP_CONFIG_OP,\n\t\t\t\tCDNS_IP_MCP_CONFIG_OP_NORMAL);\n\n\t\tret = cdns_config_update(cdns);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cdns->dev, \"%s: config_update failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sdw_bus_exit_clk_stop(&cdns->bus);\n\t\tif (ret < 0)\n\t\t\tdev_err(cdns->dev, \"bus failed to exit clock stop %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sdw_cdns_clock_restart);\n\n \nint sdw_cdns_probe(struct sdw_cdns *cdns)\n{\n\tinit_completion(&cdns->tx_complete);\n\tcdns->bus.port_ops = &cdns_port_ops;\n\n\tINIT_WORK(&cdns->work, cdns_update_slave_status_work);\n\treturn 0;\n}\nEXPORT_SYMBOL(sdw_cdns_probe);\n\nint cdns_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\tvoid *stream, int direction)\n{\n\tstruct sdw_cdns *cdns = snd_soc_dai_get_drvdata(dai);\n\tstruct sdw_cdns_dai_runtime *dai_runtime;\n\n\tdai_runtime = cdns->dai_runtime_array[dai->id];\n\n\tif (stream) {\n\t\t \n\t\tif (dai_runtime) {\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"dai_runtime already allocated for dai %s\\n\",\n\t\t\t\tdai->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tdai_runtime = kzalloc(sizeof(*dai_runtime), GFP_KERNEL);\n\t\tif (!dai_runtime)\n\t\t\treturn -ENOMEM;\n\n\t\tdai_runtime->stream_type = SDW_STREAM_PCM;\n\n\t\tdai_runtime->bus = &cdns->bus;\n\t\tdai_runtime->link_id = cdns->instance;\n\n\t\tdai_runtime->stream = stream;\n\t\tdai_runtime->direction = direction;\n\n\t\tcdns->dai_runtime_array[dai->id] = dai_runtime;\n\t} else {\n\t\t \n\t\tif (!dai_runtime) {\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"dai_runtime not allocated for dai %s\\n\",\n\t\t\t\tdai->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tkfree(dai_runtime);\n\t\tcdns->dai_runtime_array[dai->id] = NULL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(cdns_set_sdw_stream);\n\n \nstatic struct sdw_cdns_pdi *cdns_find_pdi(struct sdw_cdns *cdns,\n\t\t\t\t\t  unsigned int offset,\n\t\t\t\t\t  unsigned int num,\n\t\t\t\t\t  struct sdw_cdns_pdi *pdi,\n\t\t\t\t\t  int dai_id)\n{\n\tint i;\n\n\tfor (i = offset; i < offset + num; i++)\n\t\tif (pdi[i].num == dai_id)\n\t\t\treturn &pdi[i];\n\n\treturn NULL;\n}\n\n \nvoid sdw_cdns_config_stream(struct sdw_cdns *cdns,\n\t\t\t    u32 ch, u32 dir, struct sdw_cdns_pdi *pdi)\n{\n\tu32 offset, val = 0;\n\n\tif (dir == SDW_DATA_DIR_RX) {\n\t\tval = CDNS_PORTCTRL_DIRN;\n\n\t\tif (cdns->bus.params.m_data_mode != SDW_PORT_DATA_MODE_NORMAL)\n\t\t\tval |= CDNS_PORTCTRL_TEST_FAILED;\n\t}\n\toffset = CDNS_PORTCTRL + pdi->num * CDNS_PORT_OFFSET;\n\tcdns_updatel(cdns, offset,\n\t\t     CDNS_PORTCTRL_DIRN | CDNS_PORTCTRL_TEST_FAILED,\n\t\t     val);\n\n\tval = pdi->num;\n\tval |= CDNS_PDI_CONFIG_SOFT_RESET;\n\tval |= FIELD_PREP(CDNS_PDI_CONFIG_CHANNEL, (1 << ch) - 1);\n\tcdns_writel(cdns, CDNS_PDI_CONFIG(pdi->num), val);\n}\nEXPORT_SYMBOL(sdw_cdns_config_stream);\n\n \nstruct sdw_cdns_pdi *sdw_cdns_alloc_pdi(struct sdw_cdns *cdns,\n\t\t\t\t\tstruct sdw_cdns_streams *stream,\n\t\t\t\t\tu32 ch, u32 dir, int dai_id)\n{\n\tstruct sdw_cdns_pdi *pdi = NULL;\n\n\tif (dir == SDW_DATA_DIR_RX)\n\t\tpdi = cdns_find_pdi(cdns, 0, stream->num_in, stream->in,\n\t\t\t\t    dai_id);\n\telse\n\t\tpdi = cdns_find_pdi(cdns, 0, stream->num_out, stream->out,\n\t\t\t\t    dai_id);\n\n\t \n\tif (!pdi)\n\t\tpdi = cdns_find_pdi(cdns, 2, stream->num_bd, stream->bd,\n\t\t\t\t    dai_id);\n\n\tif (pdi) {\n\t\tpdi->l_ch_num = 0;\n\t\tpdi->h_ch_num = ch - 1;\n\t\tpdi->dir = dir;\n\t\tpdi->ch_count = ch;\n\t}\n\n\treturn pdi;\n}\nEXPORT_SYMBOL(sdw_cdns_alloc_pdi);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Cadence Soundwire Library\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}