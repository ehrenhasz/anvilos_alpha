{
  "module_name": "optee.c",
  "hash_id": "a49d5f682cff1ee600b4610dd1e70876b741d9775f1f9e3e7e99723227d5ad6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/optee.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/uuid.h>\n#include <uapi/linux/tee.h>\n\n#include \"common.h\"\n\n#define SCMI_OPTEE_MAX_MSG_SIZE\t\t128\n\nenum scmi_optee_pta_cmd {\n\t \n\tPTA_SCMI_CMD_CAPABILITIES = 0,\n\n\t \n\tPTA_SCMI_CMD_PROCESS_SMT_CHANNEL = 1,\n\n\t \n\tPTA_SCMI_CMD_PROCESS_SMT_CHANNEL_MESSAGE = 2,\n\n\t \n\tPTA_SCMI_CMD_GET_CHANNEL = 3,\n\n\t \n\tPTA_SCMI_CMD_PROCESS_MSG_CHANNEL = 4,\n};\n\n \n#define PTA_SCMI_CAPS_NONE\t\t0\n#define PTA_SCMI_CAPS_SMT_HEADER\tBIT(0)\n#define PTA_SCMI_CAPS_MSG_HEADER\tBIT(1)\n#define PTA_SCMI_CAPS_MASK\t\t(PTA_SCMI_CAPS_SMT_HEADER | \\\n\t\t\t\t\t PTA_SCMI_CAPS_MSG_HEADER)\n\n \nstruct scmi_optee_channel {\n\tu32 channel_id;\n\tu32 tee_session;\n\tu32 caps;\n\tu32 rx_len;\n\tstruct mutex mu;\n\tstruct scmi_chan_info *cinfo;\n\tunion {\n\t\tstruct scmi_shared_mem __iomem *shmem;\n\t\tstruct scmi_msg_payld *msg;\n\t} req;\n\tstruct tee_shm *tee_shm;\n\tstruct list_head link;\n};\n\n \nstruct scmi_optee_agent {\n\tstruct device *dev;\n\tstruct tee_context *tee_ctx;\n\tu32 caps;\n\tstruct mutex mu;\n\tstruct list_head channel_list;\n};\n\n \nstatic struct scmi_optee_agent *scmi_optee_private;\n\n \nstatic int scmi_optee_init(void);\n\n \nstatic int open_session(struct scmi_optee_agent *agent, u32 *tee_session)\n{\n\tstruct device *dev = agent->dev;\n\tstruct tee_client_device *scmi_pta = to_tee_client_device(dev);\n\tstruct tee_ioctl_open_session_arg arg = { };\n\tint ret;\n\n\tmemcpy(arg.uuid, scmi_pta->id.uuid.b, TEE_IOCTL_UUID_LEN);\n\targ.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;\n\n\tret = tee_client_open_session(agent->tee_ctx, &arg, NULL);\n\tif (ret < 0 || arg.ret) {\n\t\tdev_err(dev, \"Can't open tee session: %d / %#x\\n\", ret, arg.ret);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*tee_session = arg.session;\n\n\treturn 0;\n}\n\nstatic void close_session(struct scmi_optee_agent *agent, u32 tee_session)\n{\n\ttee_client_close_session(agent->tee_ctx, tee_session);\n}\n\nstatic int get_capabilities(struct scmi_optee_agent *agent)\n{\n\tstruct tee_ioctl_invoke_arg arg = { };\n\tstruct tee_param param[1] = { };\n\tu32 caps;\n\tu32 tee_session;\n\tint ret;\n\n\tret = open_session(agent, &tee_session);\n\tif (ret)\n\t\treturn ret;\n\n\targ.func = PTA_SCMI_CMD_CAPABILITIES;\n\targ.session = tee_session;\n\targ.num_params = 1;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;\n\n\tret = tee_client_invoke_func(agent->tee_ctx, &arg, param);\n\n\tclose_session(agent, tee_session);\n\n\tif (ret < 0 || arg.ret) {\n\t\tdev_err(agent->dev, \"Can't get capabilities: %d / %#x\\n\", ret, arg.ret);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcaps = param[0].u.value.a;\n\n\tif (!(caps & (PTA_SCMI_CAPS_SMT_HEADER | PTA_SCMI_CAPS_MSG_HEADER))) {\n\t\tdev_err(agent->dev, \"OP-TEE SCMI PTA doesn't support SMT and MSG\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tagent->caps = caps;\n\n\treturn 0;\n}\n\nstatic int get_channel(struct scmi_optee_channel *channel)\n{\n\tstruct device *dev = scmi_optee_private->dev;\n\tstruct tee_ioctl_invoke_arg arg = { };\n\tstruct tee_param param[1] = { };\n\tunsigned int caps = 0;\n\tint ret;\n\n\tif (channel->tee_shm)\n\t\tcaps = PTA_SCMI_CAPS_MSG_HEADER;\n\telse\n\t\tcaps = PTA_SCMI_CAPS_SMT_HEADER;\n\n\targ.func = PTA_SCMI_CMD_GET_CHANNEL;\n\targ.session = channel->tee_session;\n\targ.num_params = 1;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;\n\tparam[0].u.value.a = channel->channel_id;\n\tparam[0].u.value.b = caps;\n\n\tret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);\n\n\tif (ret || arg.ret) {\n\t\tdev_err(dev, \"Can't get channel with caps %#x: %d / %#x\\n\", caps, ret, arg.ret);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tchannel->channel_id = param[0].u.value.a;\n\tchannel->caps = caps;\n\n\treturn 0;\n}\n\nstatic int invoke_process_smt_channel(struct scmi_optee_channel *channel)\n{\n\tstruct tee_ioctl_invoke_arg arg = {\n\t\t.func = PTA_SCMI_CMD_PROCESS_SMT_CHANNEL,\n\t\t.session = channel->tee_session,\n\t\t.num_params = 1,\n\t};\n\tstruct tee_param param[1] = { };\n\tint ret;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;\n\tparam[0].u.value.a = channel->channel_id;\n\n\tret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);\n\tif (ret < 0 || arg.ret) {\n\t\tdev_err(scmi_optee_private->dev, \"Can't invoke channel %u: %d / %#x\\n\",\n\t\t\tchannel->channel_id, ret, arg.ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int invoke_process_msg_channel(struct scmi_optee_channel *channel, size_t msg_size)\n{\n\tstruct tee_ioctl_invoke_arg arg = {\n\t\t.func = PTA_SCMI_CMD_PROCESS_MSG_CHANNEL,\n\t\t.session = channel->tee_session,\n\t\t.num_params = 3,\n\t};\n\tstruct tee_param param[3] = { };\n\tint ret;\n\n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;\n\tparam[0].u.value.a = channel->channel_id;\n\n\tparam[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;\n\tparam[1].u.memref.shm = channel->tee_shm;\n\tparam[1].u.memref.size = msg_size;\n\n\tparam[2].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;\n\tparam[2].u.memref.shm = channel->tee_shm;\n\tparam[2].u.memref.size = SCMI_OPTEE_MAX_MSG_SIZE;\n\n\tret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);\n\tif (ret < 0 || arg.ret) {\n\t\tdev_err(scmi_optee_private->dev, \"Can't invoke channel %u: %d / %#x\\n\",\n\t\t\tchannel->channel_id, ret, arg.ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\tchannel->rx_len = param[2].u.memref.size;\n\n\treturn 0;\n}\n\nstatic int scmi_optee_link_supplier(struct device *dev)\n{\n\tif (!scmi_optee_private) {\n\t\tif (scmi_optee_init())\n\t\t\tdev_dbg(dev, \"Optee bus not yet ready\\n\");\n\n\t\t \n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (!device_link_add(dev, scmi_optee_private->dev, DL_FLAG_AUTOREMOVE_CONSUMER)) {\n\t\tdev_err(dev, \"Adding link to supplier optee device failed\\n\");\n\t\treturn -ECANCELED;\n\t}\n\n\treturn 0;\n}\n\nstatic bool scmi_optee_chan_available(struct device_node *of_node, int idx)\n{\n\tu32 channel_id;\n\n\treturn !of_property_read_u32_index(of_node, \"linaro,optee-channel-id\",\n\t\t\t\t\t   idx, &channel_id);\n}\n\nstatic void scmi_optee_clear_channel(struct scmi_chan_info *cinfo)\n{\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\n\tif (!channel->tee_shm)\n\t\tshmem_clear_channel(channel->req.shmem);\n}\n\nstatic int setup_dynamic_shmem(struct device *dev, struct scmi_optee_channel *channel)\n{\n\tconst size_t msg_size = SCMI_OPTEE_MAX_MSG_SIZE;\n\tvoid *shbuf;\n\n\tchannel->tee_shm = tee_shm_alloc_kernel_buf(scmi_optee_private->tee_ctx, msg_size);\n\tif (IS_ERR(channel->tee_shm)) {\n\t\tdev_err(channel->cinfo->dev, \"shmem allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tshbuf = tee_shm_get_va(channel->tee_shm, 0);\n\tmemset(shbuf, 0, msg_size);\n\tchannel->req.msg = shbuf;\n\tchannel->rx_len = msg_size;\n\n\treturn 0;\n}\n\nstatic int setup_static_shmem(struct device *dev, struct scmi_chan_info *cinfo,\n\t\t\t      struct scmi_optee_channel *channel)\n{\n\tstruct device_node *np;\n\tresource_size_t size;\n\tstruct resource res;\n\tint ret;\n\n\tnp = of_parse_phandle(cinfo->dev->of_node, \"shmem\", 0);\n\tif (!of_device_is_compatible(np, \"arm,scmi-shmem\")) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get SCMI Tx shared memory\\n\");\n\t\tgoto out;\n\t}\n\n\tsize = resource_size(&res);\n\n\tchannel->req.shmem = devm_ioremap(dev, res.start, size);\n\tif (!channel->req.shmem) {\n\t\tdev_err(dev, \"Failed to ioremap SCMI Tx shared memory\\n\");\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tof_node_put(np);\n\n\treturn ret;\n}\n\nstatic int setup_shmem(struct device *dev, struct scmi_chan_info *cinfo,\n\t\t       struct scmi_optee_channel *channel)\n{\n\tif (of_property_present(cinfo->dev->of_node, \"shmem\"))\n\t\treturn setup_static_shmem(dev, cinfo, channel);\n\telse\n\t\treturn setup_dynamic_shmem(dev, channel);\n}\n\nstatic int scmi_optee_chan_setup(struct scmi_chan_info *cinfo, struct device *dev, bool tx)\n{\n\tstruct scmi_optee_channel *channel;\n\tuint32_t channel_id;\n\tint ret;\n\n\tif (!tx)\n\t\treturn -ENODEV;\n\n\tchannel = devm_kzalloc(dev, sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_index(cinfo->dev->of_node, \"linaro,optee-channel-id\",\n\t\t\t\t\t 0, &channel_id);\n\tif (ret)\n\t\treturn ret;\n\n\tcinfo->transport_info = channel;\n\tchannel->cinfo = cinfo;\n\tchannel->channel_id = channel_id;\n\tmutex_init(&channel->mu);\n\n\tret = setup_shmem(dev, cinfo, channel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = open_session(scmi_optee_private, &channel->tee_session);\n\tif (ret)\n\t\tgoto err_free_shm;\n\n\tret = get_channel(channel);\n\tif (ret)\n\t\tgoto err_close_sess;\n\n\t \n\tcinfo->no_completion_irq = true;\n\n\tmutex_lock(&scmi_optee_private->mu);\n\tlist_add(&channel->link, &scmi_optee_private->channel_list);\n\tmutex_unlock(&scmi_optee_private->mu);\n\n\treturn 0;\n\nerr_close_sess:\n\tclose_session(scmi_optee_private, channel->tee_session);\nerr_free_shm:\n\tif (channel->tee_shm)\n\t\ttee_shm_free(channel->tee_shm);\n\n\treturn ret;\n}\n\nstatic int scmi_optee_chan_free(int id, void *p, void *data)\n{\n\tstruct scmi_chan_info *cinfo = p;\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\n\tmutex_lock(&scmi_optee_private->mu);\n\tlist_del(&channel->link);\n\tmutex_unlock(&scmi_optee_private->mu);\n\n\tclose_session(scmi_optee_private, channel->tee_session);\n\n\tif (channel->tee_shm) {\n\t\ttee_shm_free(channel->tee_shm);\n\t\tchannel->tee_shm = NULL;\n\t}\n\n\tcinfo->transport_info = NULL;\n\tchannel->cinfo = NULL;\n\n\treturn 0;\n}\n\nstatic int scmi_optee_send_message(struct scmi_chan_info *cinfo,\n\t\t\t\t   struct scmi_xfer *xfer)\n{\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\tint ret;\n\n\tmutex_lock(&channel->mu);\n\n\tif (channel->tee_shm) {\n\t\tmsg_tx_prepare(channel->req.msg, xfer);\n\t\tret = invoke_process_msg_channel(channel, msg_command_size(xfer));\n\t} else {\n\t\tshmem_tx_prepare(channel->req.shmem, xfer, cinfo);\n\t\tret = invoke_process_smt_channel(channel);\n\t}\n\n\tif (ret)\n\t\tmutex_unlock(&channel->mu);\n\n\treturn ret;\n}\n\nstatic void scmi_optee_fetch_response(struct scmi_chan_info *cinfo,\n\t\t\t\t      struct scmi_xfer *xfer)\n{\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\n\tif (channel->tee_shm)\n\t\tmsg_fetch_response(channel->req.msg, channel->rx_len, xfer);\n\telse\n\t\tshmem_fetch_response(channel->req.shmem, xfer);\n}\n\nstatic void scmi_optee_mark_txdone(struct scmi_chan_info *cinfo, int ret,\n\t\t\t\t   struct scmi_xfer *__unused)\n{\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\n\tmutex_unlock(&channel->mu);\n}\n\nstatic struct scmi_transport_ops scmi_optee_ops = {\n\t.link_supplier = scmi_optee_link_supplier,\n\t.chan_available = scmi_optee_chan_available,\n\t.chan_setup = scmi_optee_chan_setup,\n\t.chan_free = scmi_optee_chan_free,\n\t.send_message = scmi_optee_send_message,\n\t.mark_txdone = scmi_optee_mark_txdone,\n\t.fetch_response = scmi_optee_fetch_response,\n\t.clear_channel = scmi_optee_clear_channel,\n};\n\nstatic int scmi_optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\treturn ver->impl_id == TEE_IMPL_ID_OPTEE;\n}\n\nstatic int scmi_optee_service_probe(struct device *dev)\n{\n\tstruct scmi_optee_agent *agent;\n\tstruct tee_context *tee_ctx;\n\tint ret;\n\n\t \n\tif (scmi_optee_private) {\n\t\tdev_err(dev, \"An SCMI OP-TEE device was already initialized: only one allowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\ttee_ctx = tee_client_open_context(NULL, scmi_optee_ctx_match, NULL, NULL);\n\tif (IS_ERR(tee_ctx))\n\t\treturn -ENODEV;\n\n\tagent = devm_kzalloc(dev, sizeof(*agent), GFP_KERNEL);\n\tif (!agent) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tagent->dev = dev;\n\tagent->tee_ctx = tee_ctx;\n\tINIT_LIST_HEAD(&agent->channel_list);\n\tmutex_init(&agent->mu);\n\n\tret = get_capabilities(agent);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tsmp_mb();\n\tscmi_optee_private = agent;\n\n\treturn 0;\n\nerr:\n\ttee_client_close_context(tee_ctx);\n\n\treturn ret;\n}\n\nstatic int scmi_optee_service_remove(struct device *dev)\n{\n\tstruct scmi_optee_agent *agent = scmi_optee_private;\n\n\tif (!scmi_optee_private)\n\t\treturn -EINVAL;\n\n\tif (!list_empty(&scmi_optee_private->channel_list))\n\t\treturn -EBUSY;\n\n\t \n\tsmp_store_mb(scmi_optee_private, NULL);\n\n\ttee_client_close_context(agent->tee_ctx);\n\n\treturn 0;\n}\n\nstatic const struct tee_client_device_id scmi_optee_service_id[] = {\n\t{\n\t\tUUID_INIT(0xa8cfe406, 0xd4f5, 0x4a2e,\n\t\t\t  0x9f, 0x8d, 0xa2, 0x5d, 0xc7, 0x54, 0xc0, 0x99)\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(tee, scmi_optee_service_id);\n\nstatic struct tee_client_driver scmi_optee_driver = {\n\t.id_table\t= scmi_optee_service_id,\n\t.driver\t\t= {\n\t\t.name = \"scmi-optee\",\n\t\t.bus = &tee_bus_type,\n\t\t.probe = scmi_optee_service_probe,\n\t\t.remove = scmi_optee_service_remove,\n\t},\n};\n\nstatic int scmi_optee_init(void)\n{\n\treturn driver_register(&scmi_optee_driver.driver);\n}\n\nstatic void scmi_optee_exit(void)\n{\n\tif (scmi_optee_private)\n\t\tdriver_unregister(&scmi_optee_driver.driver);\n}\n\nconst struct scmi_desc scmi_optee_desc = {\n\t.transport_exit = scmi_optee_exit,\n\t.ops = &scmi_optee_ops,\n\t.max_rx_timeout_ms = 30,\n\t.max_msg = 20,\n\t.max_msg_size = SCMI_OPTEE_MAX_MSG_SIZE,\n\t.sync_cmds_completed_on_ret = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}