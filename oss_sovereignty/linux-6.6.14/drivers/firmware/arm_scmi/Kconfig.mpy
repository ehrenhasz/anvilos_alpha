{
  "module_name": "Kconfig",
  "hash_id": "adade7c610562968ed8ba72e20d82f356d332532c9542ee2e3b5b4aa81306a64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"ARM System Control and Management Interface Protocol\"\n\nconfig ARM_SCMI_PROTOCOL\n\ttristate \"ARM System Control and Management Interface (SCMI) Message Protocol\"\n\tdepends on ARM || ARM64 || COMPILE_TEST\n\thelp\n\t  ARM System Control and Management Interface (SCMI) protocol is a\n\t  set of operating system-independent software interfaces that are\n\t  used in system management. SCMI is extensible and currently provides\n\t  interfaces for: Discovery and self-description of the interfaces\n\t  it supports, Power domain management which is the ability to place\n\t  a given device or domain into the various power-saving states that\n\t  it supports, Performance management which is the ability to control\n\t  the performance of a domain that is composed of compute engines\n\t  such as application processors and other accelerators, Clock\n\t  management which is the ability to set and inquire rates on platform\n\t  managed clocks and Sensor management which is the ability to read\n\t  sensor data, and be notified of sensor value.\n\n\t  This protocol library provides interface for all the client drivers\n\t  making use of the features offered by the SCMI.\n\nif ARM_SCMI_PROTOCOL\n\nconfig ARM_SCMI_NEED_DEBUGFS\n\tbool\n\thelp\n\t  This declares whether at least one SCMI facility is configured\n\t  which needs debugfs support. When selected causess the creation\n\t  of a common SCMI debugfs root directory.\n\nconfig ARM_SCMI_RAW_MODE_SUPPORT\n\tbool \"Enable support for SCMI Raw transmission mode\"\n\tdepends on DEBUG_FS\n\tselect ARM_SCMI_NEED_DEBUGFS\n\thelp\n\t  Enable support for SCMI Raw transmission mode.\n\n\t  If enabled allows the direct injection and snooping of SCMI bare\n\t  messages through a dedicated debugfs interface.\n\t  It is meant to be used by SCMI compliance/testing suites.\n\n\t  When enabled regular SCMI drivers interactions are inhibited in\n\t  order to avoid unexpected interactions with the SCMI Raw message\n\t  flow. If unsure say N.\n\nconfig ARM_SCMI_RAW_MODE_SUPPORT_COEX\n\tbool \"Allow SCMI Raw mode coexistence with normal SCMI stack\"\n\tdepends on ARM_SCMI_RAW_MODE_SUPPORT\n\thelp\n\t  Allow SCMI Raw transmission mode to coexist with normal SCMI stack.\n\n\t  This will allow regular SCMI drivers to register with the core and\n\t  operate normally, thing which could make an SCMI test suite using the\n\t  SCMI Raw mode support unreliable. If unsure, say N.\n\nconfig ARM_SCMI_HAVE_TRANSPORT\n\tbool\n\thelp\n\t  This declares whether at least one SCMI transport has been configured.\n\t  Used to trigger a build bug when trying to build SCMI without any\n\t  configured transport.\n\nconfig ARM_SCMI_HAVE_SHMEM\n\tbool\n\thelp\n\t  This declares whether a shared memory based transport for SCMI is\n\t  available.\n\nconfig ARM_SCMI_HAVE_MSG\n\tbool\n\thelp\n\t  This declares whether a message passing based transport for SCMI is\n\t  available.\n\nconfig ARM_SCMI_TRANSPORT_MAILBOX\n\tbool \"SCMI transport based on Mailbox\"\n\tdepends on MAILBOX\n\tselect ARM_SCMI_HAVE_TRANSPORT\n\tselect ARM_SCMI_HAVE_SHMEM\n\tdefault y\n\thelp\n\t  Enable mailbox based transport for SCMI.\n\n\t  If you want the ARM SCMI PROTOCOL stack to include support for a\n\t  transport based on mailboxes, answer Y.\n\nconfig ARM_SCMI_TRANSPORT_OPTEE\n\tbool \"SCMI transport based on OP-TEE service\"\n\tdepends on OPTEE=y || OPTEE=ARM_SCMI_PROTOCOL\n\tselect ARM_SCMI_HAVE_TRANSPORT\n\tselect ARM_SCMI_HAVE_SHMEM\n\tselect ARM_SCMI_HAVE_MSG\n\tdefault y\n\thelp\n\t  This enables the OP-TEE service based transport for SCMI.\n\n\t  If you want the ARM SCMI PROTOCOL stack to include support for a\n\t  transport based on OP-TEE SCMI service, answer Y.\n\nconfig ARM_SCMI_TRANSPORT_SMC\n\tbool \"SCMI transport based on SMC\"\n\tdepends on HAVE_ARM_SMCCC_DISCOVERY\n\tselect ARM_SCMI_HAVE_TRANSPORT\n\tselect ARM_SCMI_HAVE_SHMEM\n\tdefault y\n\thelp\n\t  Enable SMC based transport for SCMI.\n\n\t  If you want the ARM SCMI PROTOCOL stack to include support for a\n\t  transport based on SMC, answer Y.\n\nconfig ARM_SCMI_TRANSPORT_SMC_ATOMIC_ENABLE\n\tbool \"Enable atomic mode support for SCMI SMC transport\"\n\tdepends on ARM_SCMI_TRANSPORT_SMC\n\thelp\n\t  Enable support of atomic operation for SCMI SMC based transport.\n\n\t  If you want the SCMI SMC based transport to operate in atomic\n\t  mode, avoiding any kind of sleeping behaviour for selected\n\t  transactions on the TX path, answer Y.\n\t  Enabling atomic mode operations allows any SCMI driver using this\n\t  transport to optionally ask for atomic SCMI transactions and operate\n\t  in atomic context too, at the price of using a number of busy-waiting\n\t  primitives all over instead. If unsure say N.\n\nconfig ARM_SCMI_TRANSPORT_VIRTIO\n\tbool \"SCMI transport based on VirtIO\"\n\tdepends on VIRTIO=y || VIRTIO=ARM_SCMI_PROTOCOL\n\tselect ARM_SCMI_HAVE_TRANSPORT\n\tselect ARM_SCMI_HAVE_MSG\n\thelp\n\t  This enables the virtio based transport for SCMI.\n\n\t  If you want the ARM SCMI PROTOCOL stack to include support for a\n\t  transport based on VirtIO, answer Y.\n\nconfig ARM_SCMI_TRANSPORT_VIRTIO_VERSION1_COMPLIANCE\n\tbool \"SCMI VirtIO transport Version 1 compliance\"\n\tdepends on ARM_SCMI_TRANSPORT_VIRTIO\n\tdefault y\n\thelp\n\t  This enforces strict compliance with VirtIO Version 1 specification.\n\n\t  If you want the ARM SCMI VirtIO transport layer to refuse to work\n\t  with Legacy VirtIO backends and instead support only VirtIO Version 1\n\t  devices (or above), answer Y.\n\n\t  If you want instead to support also old Legacy VirtIO backends (like\n\t  the ones implemented by kvmtool) and let the core Kernel VirtIO layer\n\t  take care of the needed conversions, say N.\n\nconfig ARM_SCMI_TRANSPORT_VIRTIO_ATOMIC_ENABLE\n\tbool \"Enable atomic mode for SCMI VirtIO transport\"\n\tdepends on ARM_SCMI_TRANSPORT_VIRTIO\n\thelp\n\t  Enable support of atomic operation for SCMI VirtIO based transport.\n\n\t  If you want the SCMI VirtIO based transport to operate in atomic\n\t  mode, avoiding any kind of sleeping behaviour for selected\n\t  transactions on the TX path, answer Y.\n\n\t  Enabling atomic mode operations allows any SCMI driver using this\n\t  transport to optionally ask for atomic SCMI transactions and operate\n\t  in atomic context too, at the price of using a number of busy-waiting\n\t  primitives all over instead. If unsure say N.\n\nendif #ARM_SCMI_PROTOCOL\n\nconfig ARM_SCMI_POWER_DOMAIN\n\ttristate \"SCMI power domain driver\"\n\tdepends on ARM_SCMI_PROTOCOL || (COMPILE_TEST && OF)\n\tdefault y\n\tselect PM_GENERIC_DOMAINS if PM\n\thelp\n\t  This enables support for the SCMI power domains which can be\n\t  enabled or disabled via the SCP firmware\n\n\t  This driver can also be built as a module.  If so, the module\n\t  will be called scmi_pm_domain. Note this may needed early in boot\n\t  before rootfs may be available.\n\nconfig ARM_SCMI_POWER_CONTROL\n\ttristate \"SCMI system power control driver\"\n\tdepends on ARM_SCMI_PROTOCOL || (COMPILE_TEST && OF)\n\thelp\n\t  This enables System Power control logic which binds system shutdown or\n\t  reboot actions to SCMI System Power notifications generated by SCP\n\t  firmware.\n\n\t  This driver can also be built as a module.  If so, the module will be\n\t  called scmi_power_control. Note this may needed early in boot to catch\n\t  early shutdown/reboot SCMI requests.\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}