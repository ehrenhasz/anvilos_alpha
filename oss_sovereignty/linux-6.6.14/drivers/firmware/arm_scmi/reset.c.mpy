{
  "module_name": "reset.c",
  "hash_id": "82f314a67345629eebe9710ab6a7f30adfb3dd7a0c9eadbfdc81f921ecbd0914",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/reset.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications RESET - \" fmt\n\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\nenum scmi_reset_protocol_cmd {\n\tRESET_DOMAIN_ATTRIBUTES = 0x3,\n\tRESET = 0x4,\n\tRESET_NOTIFY = 0x5,\n\tRESET_DOMAIN_NAME_GET = 0x6,\n};\n\n#define NUM_RESET_DOMAIN_MASK\t0xffff\n#define RESET_NOTIFY_ENABLE\tBIT(0)\n\nstruct scmi_msg_resp_reset_domain_attributes {\n\t__le32 attributes;\n#define SUPPORTS_ASYNC_RESET(x)\t\t((x) & BIT(31))\n#define SUPPORTS_NOTIFY_RESET(x)\t((x) & BIT(30))\n#define SUPPORTS_EXTENDED_NAMES(x)\t((x) & BIT(29))\n\t__le32 latency;\n\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n};\n\nstruct scmi_msg_reset_domain_reset {\n\t__le32 domain_id;\n\t__le32 flags;\n#define AUTONOMOUS_RESET\tBIT(0)\n#define EXPLICIT_RESET_ASSERT\tBIT(1)\n#define ASYNCHRONOUS_RESET\tBIT(2)\n\t__le32 reset_state;\n#define ARCH_COLD_RESET\t\t0\n};\n\nstruct scmi_msg_reset_notify {\n\t__le32 id;\n\t__le32 event_control;\n#define RESET_TP_NOTIFY_ALL\tBIT(0)\n};\n\nstruct scmi_reset_issued_notify_payld {\n\t__le32 agent_id;\n\t__le32 domain_id;\n\t__le32 reset_state;\n};\n\nstruct reset_dom_info {\n\tbool async_reset;\n\tbool reset_notify;\n\tu32 latency_us;\n\tchar name[SCMI_MAX_STR_SIZE];\n};\n\nstruct scmi_reset_info {\n\tu32 version;\n\tint num_domains;\n\tstruct reset_dom_info *dom_info;\n};\n\nstatic int scmi_reset_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t     struct scmi_reset_info *pi)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tu32 attr;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES,\n\t\t\t\t      0, sizeof(attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tattr = get_unaligned_le32(t->rx.buf);\n\t\tpi->num_domains = attr & NUM_RESET_DOMAIN_MASK;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int\nscmi_reset_domain_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain, struct reset_dom_info *dom_info,\n\t\t\t\t u32 version)\n{\n\tint ret;\n\tu32 attributes;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_reset_domain_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, RESET_DOMAIN_ATTRIBUTES,\n\t\t\t\t      sizeof(domain), sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain, t->tx.buf);\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tattributes = le32_to_cpu(attr->attributes);\n\n\t\tdom_info->async_reset = SUPPORTS_ASYNC_RESET(attributes);\n\t\tdom_info->reset_notify = SUPPORTS_NOTIFY_RESET(attributes);\n\t\tdom_info->latency_us = le32_to_cpu(attr->latency);\n\t\tif (dom_info->latency_us == U32_MAX)\n\t\t\tdom_info->latency_us = 0;\n\t\tstrscpy(dom_info->name, attr->name, SCMI_SHORT_NAME_MAX_SIZE);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\n\t \n\tif (!ret && PROTOCOL_REV_MAJOR(version) >= 0x3 &&\n\t    SUPPORTS_EXTENDED_NAMES(attributes))\n\t\tph->hops->extended_name_get(ph, RESET_DOMAIN_NAME_GET, domain,\n\t\t\t\t\t    dom_info->name, SCMI_MAX_STR_SIZE);\n\n\treturn ret;\n}\n\nstatic int scmi_reset_num_domains_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct scmi_reset_info *pi = ph->get_priv(ph);\n\n\treturn pi->num_domains;\n}\n\nstatic const char *\nscmi_reset_name_get(const struct scmi_protocol_handle *ph, u32 domain)\n{\n\tstruct scmi_reset_info *pi = ph->get_priv(ph);\n\n\tstruct reset_dom_info *dom = pi->dom_info + domain;\n\n\treturn dom->name;\n}\n\nstatic int scmi_reset_latency_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u32 domain)\n{\n\tstruct scmi_reset_info *pi = ph->get_priv(ph);\n\tstruct reset_dom_info *dom = pi->dom_info + domain;\n\n\treturn dom->latency_us;\n}\n\nstatic int scmi_domain_reset(const struct scmi_protocol_handle *ph, u32 domain,\n\t\t\t     u32 flags, u32 state)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_reset_domain_reset *dom;\n\tstruct scmi_reset_info *pi = ph->get_priv(ph);\n\tstruct reset_dom_info *rdom;\n\n\tif (domain >= pi->num_domains)\n\t\treturn -EINVAL;\n\n\trdom = pi->dom_info + domain;\n\tif (rdom->async_reset && flags & AUTONOMOUS_RESET)\n\t\tflags |= ASYNCHRONOUS_RESET;\n\n\tret = ph->xops->xfer_get_init(ph, RESET, sizeof(*dom), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tdom = t->tx.buf;\n\tdom->domain_id = cpu_to_le32(domain);\n\tdom->flags = cpu_to_le32(flags);\n\tdom->reset_state = cpu_to_le32(state);\n\n\tif (flags & ASYNCHRONOUS_RESET)\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\telse\n\t\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_reset_domain_reset(const struct scmi_protocol_handle *ph,\n\t\t\t\t   u32 domain)\n{\n\treturn scmi_domain_reset(ph, domain, AUTONOMOUS_RESET,\n\t\t\t\t ARCH_COLD_RESET);\n}\n\nstatic int\nscmi_reset_domain_assert(const struct scmi_protocol_handle *ph, u32 domain)\n{\n\treturn scmi_domain_reset(ph, domain, EXPLICIT_RESET_ASSERT,\n\t\t\t\t ARCH_COLD_RESET);\n}\n\nstatic int\nscmi_reset_domain_deassert(const struct scmi_protocol_handle *ph, u32 domain)\n{\n\treturn scmi_domain_reset(ph, domain, 0, ARCH_COLD_RESET);\n}\n\nstatic const struct scmi_reset_proto_ops reset_proto_ops = {\n\t.num_domains_get = scmi_reset_num_domains_get,\n\t.name_get = scmi_reset_name_get,\n\t.latency_get = scmi_reset_latency_get,\n\t.reset = scmi_reset_domain_reset,\n\t.assert = scmi_reset_domain_assert,\n\t.deassert = scmi_reset_domain_deassert,\n};\n\nstatic int scmi_reset_notify(const struct scmi_protocol_handle *ph,\n\t\t\t     u32 domain_id, bool enable)\n{\n\tint ret;\n\tu32 evt_cntl = enable ? RESET_TP_NOTIFY_ALL : 0;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_reset_notify *cfg;\n\n\tret = ph->xops->xfer_get_init(ph, RESET_NOTIFY, sizeof(*cfg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = t->tx.buf;\n\tcfg->id = cpu_to_le32(domain_id);\n\tcfg->event_control = cpu_to_le32(evt_cntl);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_reset_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret;\n\n\tret = scmi_reset_notify(ph, src_id, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLED - evt[%X] dom[%d] - ret:%d\\n\",\n\t\t\t evt_id, src_id, ret);\n\n\treturn ret;\n}\n\nstatic void *\nscmi_reset_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t      u8 evt_id, ktime_t timestamp,\n\t\t\t      const void *payld, size_t payld_sz,\n\t\t\t      void *report, u32 *src_id)\n{\n\tconst struct scmi_reset_issued_notify_payld *p = payld;\n\tstruct scmi_reset_issued_report *r = report;\n\n\tif (evt_id != SCMI_EVENT_RESET_ISSUED || sizeof(*p) != payld_sz)\n\t\treturn NULL;\n\n\tr->timestamp = timestamp;\n\tr->agent_id = le32_to_cpu(p->agent_id);\n\tr->domain_id = le32_to_cpu(p->domain_id);\n\tr->reset_state = le32_to_cpu(p->reset_state);\n\t*src_id = r->domain_id;\n\n\treturn r;\n}\n\nstatic int scmi_reset_get_num_sources(const struct scmi_protocol_handle *ph)\n{\n\tstruct scmi_reset_info *pinfo = ph->get_priv(ph);\n\n\tif (!pinfo)\n\t\treturn -EINVAL;\n\n\treturn pinfo->num_domains;\n}\n\nstatic const struct scmi_event reset_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_RESET_ISSUED,\n\t\t.max_payld_sz = sizeof(struct scmi_reset_issued_notify_payld),\n\t\t.max_report_sz = sizeof(struct scmi_reset_issued_report),\n\t},\n};\n\nstatic const struct scmi_event_ops reset_event_ops = {\n\t.get_num_sources = scmi_reset_get_num_sources,\n\t.set_notify_enabled = scmi_reset_set_notify_enabled,\n\t.fill_custom_report = scmi_reset_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events reset_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &reset_event_ops,\n\t.evts = reset_events,\n\t.num_events = ARRAY_SIZE(reset_events),\n};\n\nstatic int scmi_reset_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint domain, ret;\n\tu32 version;\n\tstruct scmi_reset_info *pinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Reset Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tpinfo = devm_kzalloc(ph->dev, sizeof(*pinfo), GFP_KERNEL);\n\tif (!pinfo)\n\t\treturn -ENOMEM;\n\n\tret = scmi_reset_attributes_get(ph, pinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tpinfo->dom_info = devm_kcalloc(ph->dev, pinfo->num_domains,\n\t\t\t\t       sizeof(*pinfo->dom_info), GFP_KERNEL);\n\tif (!pinfo->dom_info)\n\t\treturn -ENOMEM;\n\n\tfor (domain = 0; domain < pinfo->num_domains; domain++) {\n\t\tstruct reset_dom_info *dom = pinfo->dom_info + domain;\n\n\t\tscmi_reset_domain_attributes_get(ph, domain, dom, version);\n\t}\n\n\tpinfo->version = version;\n\treturn ph->set_priv(ph, pinfo);\n}\n\nstatic const struct scmi_protocol scmi_reset = {\n\t.id = SCMI_PROTOCOL_RESET,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_reset_protocol_init,\n\t.ops = &reset_proto_ops,\n\t.events = &reset_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(reset, scmi_reset)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}