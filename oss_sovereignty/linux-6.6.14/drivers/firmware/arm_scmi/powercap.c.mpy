{
  "module_name": "powercap.c",
  "hash_id": "203fa595d57d307d7088eafea0b8ba5643b672f2d71aa013c06cb05b3c674747",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/powercap.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications POWERCAP - \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include <trace/events/scmi.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\nenum scmi_powercap_protocol_cmd {\n\tPOWERCAP_DOMAIN_ATTRIBUTES = 0x3,\n\tPOWERCAP_CAP_GET = 0x4,\n\tPOWERCAP_CAP_SET = 0x5,\n\tPOWERCAP_PAI_GET = 0x6,\n\tPOWERCAP_PAI_SET = 0x7,\n\tPOWERCAP_DOMAIN_NAME_GET = 0x8,\n\tPOWERCAP_MEASUREMENTS_GET = 0x9,\n\tPOWERCAP_CAP_NOTIFY = 0xa,\n\tPOWERCAP_MEASUREMENTS_NOTIFY = 0xb,\n\tPOWERCAP_DESCRIBE_FASTCHANNEL = 0xc,\n};\n\nenum {\n\tPOWERCAP_FC_CAP,\n\tPOWERCAP_FC_PAI,\n\tPOWERCAP_FC_MAX,\n};\n\nstruct scmi_msg_resp_powercap_domain_attributes {\n\t__le32 attributes;\n#define SUPPORTS_POWERCAP_CAP_CHANGE_NOTIFY(x)\t\t((x) & BIT(31))\n#define SUPPORTS_POWERCAP_MEASUREMENTS_CHANGE_NOTIFY(x)\t((x) & BIT(30))\n#define SUPPORTS_ASYNC_POWERCAP_CAP_SET(x)\t\t((x) & BIT(29))\n#define SUPPORTS_EXTENDED_NAMES(x)\t\t\t((x) & BIT(28))\n#define SUPPORTS_POWERCAP_CAP_CONFIGURATION(x)\t\t((x) & BIT(27))\n#define SUPPORTS_POWERCAP_MONITORING(x)\t\t\t((x) & BIT(26))\n#define SUPPORTS_POWERCAP_PAI_CONFIGURATION(x)\t\t((x) & BIT(25))\n#define SUPPORTS_POWERCAP_FASTCHANNELS(x)\t\t((x) & BIT(22))\n#define POWERCAP_POWER_UNIT(x)\t\t\t\t\\\n\t\t(FIELD_GET(GENMASK(24, 23), (x)))\n#define\tSUPPORTS_POWER_UNITS_MW(x)\t\t\t\\\n\t\t(POWERCAP_POWER_UNIT(x) == 0x2)\n#define\tSUPPORTS_POWER_UNITS_UW(x)\t\t\t\\\n\t\t(POWERCAP_POWER_UNIT(x) == 0x1)\n\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n\t__le32 min_pai;\n\t__le32 max_pai;\n\t__le32 pai_step;\n\t__le32 min_power_cap;\n\t__le32 max_power_cap;\n\t__le32 power_cap_step;\n\t__le32 sustainable_power;\n\t__le32 accuracy;\n\t__le32 parent_id;\n};\n\nstruct scmi_msg_powercap_set_cap_or_pai {\n\t__le32 domain;\n\t__le32 flags;\n#define CAP_SET_ASYNC\t\tBIT(1)\n#define CAP_SET_IGNORE_DRESP\tBIT(0)\n\t__le32 value;\n};\n\nstruct scmi_msg_resp_powercap_cap_set_complete {\n\t__le32 domain;\n\t__le32 power_cap;\n};\n\nstruct scmi_msg_resp_powercap_meas_get {\n\t__le32 power;\n\t__le32 pai;\n};\n\nstruct scmi_msg_powercap_notify_cap {\n\t__le32 domain;\n\t__le32 notify_enable;\n};\n\nstruct scmi_msg_powercap_notify_thresh {\n\t__le32 domain;\n\t__le32 notify_enable;\n\t__le32 power_thresh_low;\n\t__le32 power_thresh_high;\n};\n\nstruct scmi_powercap_cap_changed_notify_payld {\n\t__le32 agent_id;\n\t__le32 domain_id;\n\t__le32 power_cap;\n\t__le32 pai;\n};\n\nstruct scmi_powercap_meas_changed_notify_payld {\n\t__le32 agent_id;\n\t__le32 domain_id;\n\t__le32 power;\n};\n\nstruct scmi_powercap_state {\n\tbool enabled;\n\tu32 last_pcap;\n\tbool meas_notif_enabled;\n\tu64 thresholds;\n#define THRESH_LOW(p, id)\t\t\t\t\\\n\t(lower_32_bits((p)->states[(id)].thresholds))\n#define THRESH_HIGH(p, id)\t\t\t\t\\\n\t(upper_32_bits((p)->states[(id)].thresholds))\n};\n\nstruct powercap_info {\n\tu32 version;\n\tint num_domains;\n\tstruct scmi_powercap_state *states;\n\tstruct scmi_powercap_info *powercaps;\n};\n\nstatic enum scmi_powercap_protocol_cmd evt_2_cmd[] = {\n\tPOWERCAP_CAP_NOTIFY,\n\tPOWERCAP_MEASUREMENTS_NOTIFY,\n};\n\nstatic int scmi_powercap_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain, int message_id, bool enable);\n\nstatic int\nscmi_powercap_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t     struct powercap_info *pi)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES, 0,\n\t\t\t\t      sizeof(u32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tu32 attributes;\n\n\t\tattributes = get_unaligned_le32(t->rx.buf);\n\t\tpi->num_domains = FIELD_GET(GENMASK(15, 0), attributes);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic inline int\nscmi_powercap_validate(unsigned int min_val, unsigned int max_val,\n\t\t       unsigned int step_val, bool configurable)\n{\n\tif (!min_val || !max_val)\n\t\treturn -EPROTO;\n\n\tif ((configurable && min_val == max_val) ||\n\t    (!configurable && min_val != max_val))\n\t\treturn -EPROTO;\n\n\tif (min_val != max_val && !step_val)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic int\nscmi_powercap_domain_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t    struct powercap_info *pinfo, u32 domain)\n{\n\tint ret;\n\tu32 flags;\n\tstruct scmi_xfer *t;\n\tstruct scmi_powercap_info *dom_info = pinfo->powercaps + domain;\n\tstruct scmi_msg_resp_powercap_domain_attributes *resp;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_DOMAIN_ATTRIBUTES,\n\t\t\t\t      sizeof(domain), sizeof(*resp), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain, t->tx.buf);\n\tresp = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tflags = le32_to_cpu(resp->attributes);\n\n\t\tdom_info->id = domain;\n\t\tdom_info->notify_powercap_cap_change =\n\t\t\tSUPPORTS_POWERCAP_CAP_CHANGE_NOTIFY(flags);\n\t\tdom_info->notify_powercap_measurement_change =\n\t\t\tSUPPORTS_POWERCAP_MEASUREMENTS_CHANGE_NOTIFY(flags);\n\t\tdom_info->async_powercap_cap_set =\n\t\t\tSUPPORTS_ASYNC_POWERCAP_CAP_SET(flags);\n\t\tdom_info->powercap_cap_config =\n\t\t\tSUPPORTS_POWERCAP_CAP_CONFIGURATION(flags);\n\t\tdom_info->powercap_monitoring =\n\t\t\tSUPPORTS_POWERCAP_MONITORING(flags);\n\t\tdom_info->powercap_pai_config =\n\t\t\tSUPPORTS_POWERCAP_PAI_CONFIGURATION(flags);\n\t\tdom_info->powercap_scale_mw =\n\t\t\tSUPPORTS_POWER_UNITS_MW(flags);\n\t\tdom_info->powercap_scale_uw =\n\t\t\tSUPPORTS_POWER_UNITS_UW(flags);\n\t\tdom_info->fastchannels =\n\t\t\tSUPPORTS_POWERCAP_FASTCHANNELS(flags);\n\n\t\tstrscpy(dom_info->name, resp->name, SCMI_SHORT_NAME_MAX_SIZE);\n\n\t\tdom_info->min_pai = le32_to_cpu(resp->min_pai);\n\t\tdom_info->max_pai = le32_to_cpu(resp->max_pai);\n\t\tdom_info->pai_step = le32_to_cpu(resp->pai_step);\n\t\tret = scmi_powercap_validate(dom_info->min_pai,\n\t\t\t\t\t     dom_info->max_pai,\n\t\t\t\t\t     dom_info->pai_step,\n\t\t\t\t\t     dom_info->powercap_pai_config);\n\t\tif (ret) {\n\t\t\tdev_err(ph->dev,\n\t\t\t\t\"Platform reported inconsistent PAI config for domain %d - %s\\n\",\n\t\t\t\tdom_info->id, dom_info->name);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tdom_info->min_power_cap = le32_to_cpu(resp->min_power_cap);\n\t\tdom_info->max_power_cap = le32_to_cpu(resp->max_power_cap);\n\t\tdom_info->power_cap_step = le32_to_cpu(resp->power_cap_step);\n\t\tret = scmi_powercap_validate(dom_info->min_power_cap,\n\t\t\t\t\t     dom_info->max_power_cap,\n\t\t\t\t\t     dom_info->power_cap_step,\n\t\t\t\t\t     dom_info->powercap_cap_config);\n\t\tif (ret) {\n\t\t\tdev_err(ph->dev,\n\t\t\t\t\"Platform reported inconsistent CAP config for domain %d - %s\\n\",\n\t\t\t\tdom_info->id, dom_info->name);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tdom_info->sustainable_power =\n\t\t\tle32_to_cpu(resp->sustainable_power);\n\t\tdom_info->accuracy = le32_to_cpu(resp->accuracy);\n\n\t\tdom_info->parent_id = le32_to_cpu(resp->parent_id);\n\t\tif (dom_info->parent_id != SCMI_POWERCAP_ROOT_ZONE_ID &&\n\t\t    (dom_info->parent_id >= pinfo->num_domains ||\n\t\t     dom_info->parent_id == dom_info->id)) {\n\t\t\tdev_err(ph->dev,\n\t\t\t\t\"Platform reported inconsistent parent ID for domain %d - %s\\n\",\n\t\t\t\tdom_info->id, dom_info->name);\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\n\nclean:\n\tph->xops->xfer_put(ph, t);\n\n\t \n\tif (!ret && SUPPORTS_EXTENDED_NAMES(flags))\n\t\tph->hops->extended_name_get(ph, POWERCAP_DOMAIN_NAME_GET,\n\t\t\t\t\t    domain, dom_info->name,\n\t\t\t\t\t    SCMI_MAX_STR_SIZE);\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_num_domains_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\treturn pi->num_domains;\n}\n\nstatic const struct scmi_powercap_info *\nscmi_powercap_dom_info_get(const struct scmi_protocol_handle *ph, u32 domain_id)\n{\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (domain_id >= pi->num_domains)\n\t\treturn NULL;\n\n\treturn pi->powercaps + domain_id;\n}\n\nstatic int scmi_powercap_xfer_cap_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t      u32 domain_id, u32 *power_cap)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_CAP_GET, sizeof(u32),\n\t\t\t\t      sizeof(u32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain_id, t->tx.buf);\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\t*power_cap = get_unaligned_le32(t->rx.buf);\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\nstatic int __scmi_powercap_cap_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t   const struct scmi_powercap_info *dom,\n\t\t\t\t   u32 *power_cap)\n{\n\tif (dom->fc_info && dom->fc_info[POWERCAP_FC_CAP].get_addr) {\n\t\t*power_cap = ioread32(dom->fc_info[POWERCAP_FC_CAP].get_addr);\n\t\ttrace_scmi_fc_call(SCMI_PROTOCOL_POWERCAP, POWERCAP_CAP_GET,\n\t\t\t\t   dom->id, *power_cap, 0);\n\t\treturn 0;\n\t}\n\n\treturn scmi_powercap_xfer_cap_get(ph, dom->id, power_cap);\n}\n\nstatic int scmi_powercap_cap_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain_id, u32 *power_cap)\n{\n\tconst struct scmi_powercap_info *dom;\n\n\tif (!power_cap)\n\t\treturn -EINVAL;\n\n\tdom = scmi_powercap_dom_info_get(ph, domain_id);\n\tif (!dom)\n\t\treturn -EINVAL;\n\n\treturn __scmi_powercap_cap_get(ph, dom, power_cap);\n}\n\nstatic int scmi_powercap_xfer_cap_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t      const struct scmi_powercap_info *pc,\n\t\t\t\t      u32 power_cap, bool ignore_dresp)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_powercap_set_cap_or_pai *msg;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_CAP_SET,\n\t\t\t\t      sizeof(*msg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg = t->tx.buf;\n\tmsg->domain = cpu_to_le32(pc->id);\n\tmsg->flags =\n\t\tcpu_to_le32(FIELD_PREP(CAP_SET_ASYNC, !!pc->async_powercap_cap_set) |\n\t\t\t    FIELD_PREP(CAP_SET_IGNORE_DRESP, !!ignore_dresp));\n\tmsg->value = cpu_to_le32(power_cap);\n\n\tif (!pc->async_powercap_cap_set || ignore_dresp) {\n\t\tret = ph->xops->do_xfer(ph, t);\n\t} else {\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\t\tif (!ret) {\n\t\t\tstruct scmi_msg_resp_powercap_cap_set_complete *resp;\n\n\t\t\tresp = t->rx.buf;\n\t\t\tif (le32_to_cpu(resp->domain) == pc->id)\n\t\t\t\tdev_dbg(ph->dev,\n\t\t\t\t\t\"Powercap ID %d CAP set async to %u\\n\",\n\t\t\t\t\tpc->id,\n\t\t\t\t\tget_unaligned_le32(&resp->power_cap));\n\t\t\telse\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int __scmi_powercap_cap_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t   struct powercap_info *pi, u32 domain_id,\n\t\t\t\t   u32 power_cap, bool ignore_dresp)\n{\n\tint ret = -EINVAL;\n\tconst struct scmi_powercap_info *pc;\n\n\tpc = scmi_powercap_dom_info_get(ph, domain_id);\n\tif (!pc || !pc->powercap_cap_config)\n\t\treturn ret;\n\n\tif (power_cap &&\n\t    (power_cap < pc->min_power_cap || power_cap > pc->max_power_cap))\n\t\treturn ret;\n\n\tif (pc->fc_info && pc->fc_info[POWERCAP_FC_CAP].set_addr) {\n\t\tstruct scmi_fc_info *fci = &pc->fc_info[POWERCAP_FC_CAP];\n\n\t\tiowrite32(power_cap, fci->set_addr);\n\t\tph->hops->fastchannel_db_ring(fci->set_db);\n\t\ttrace_scmi_fc_call(SCMI_PROTOCOL_POWERCAP, POWERCAP_CAP_SET,\n\t\t\t\t   domain_id, power_cap, 0);\n\t\tret = 0;\n\t} else {\n\t\tret = scmi_powercap_xfer_cap_set(ph, pc, power_cap,\n\t\t\t\t\t\t ignore_dresp);\n\t}\n\n\t \n\tif (PROTOCOL_REV_MAJOR(pi->version) >= 0x2 && !ret && power_cap)\n\t\tpi->states[domain_id].last_pcap = power_cap;\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_cap_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain_id, u32 power_cap,\n\t\t\t\t bool ignore_dresp)\n{\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\t \n\tif (!power_cap)\n\t\treturn -EINVAL;\n\n\t \n\tif (PROTOCOL_REV_MAJOR(pi->version) >= 0x2 &&\n\t    !pi->states[domain_id].enabled) {\n\t\tpi->states[domain_id].last_pcap = power_cap;\n\t\treturn 0;\n\t}\n\n\treturn __scmi_powercap_cap_set(ph, pi, domain_id,\n\t\t\t\t       power_cap, ignore_dresp);\n}\n\nstatic int scmi_powercap_xfer_pai_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t      u32 domain_id, u32 *pai)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_PAI_GET, sizeof(u32),\n\t\t\t\t      sizeof(u32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain_id, t->tx.buf);\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\t*pai = get_unaligned_le32(t->rx.buf);\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_pai_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain_id, u32 *pai)\n{\n\tstruct scmi_powercap_info *dom;\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (!pai || domain_id >= pi->num_domains)\n\t\treturn -EINVAL;\n\n\tdom = pi->powercaps + domain_id;\n\tif (dom->fc_info && dom->fc_info[POWERCAP_FC_PAI].get_addr) {\n\t\t*pai = ioread32(dom->fc_info[POWERCAP_FC_PAI].get_addr);\n\t\ttrace_scmi_fc_call(SCMI_PROTOCOL_POWERCAP, POWERCAP_PAI_GET,\n\t\t\t\t   domain_id, *pai, 0);\n\t\treturn 0;\n\t}\n\n\treturn scmi_powercap_xfer_pai_get(ph, domain_id, pai);\n}\n\nstatic int scmi_powercap_xfer_pai_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t      u32 domain_id, u32 pai)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_powercap_set_cap_or_pai *msg;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_PAI_SET,\n\t\t\t\t      sizeof(*msg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg = t->tx.buf;\n\tmsg->domain = cpu_to_le32(domain_id);\n\tmsg->flags = cpu_to_le32(0);\n\tmsg->value = cpu_to_le32(pai);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_powercap_pai_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain_id, u32 pai)\n{\n\tconst struct scmi_powercap_info *pc;\n\n\tpc = scmi_powercap_dom_info_get(ph, domain_id);\n\tif (!pc || !pc->powercap_pai_config || !pai ||\n\t    pai < pc->min_pai || pai > pc->max_pai)\n\t\treturn -EINVAL;\n\n\tif (pc->fc_info && pc->fc_info[POWERCAP_FC_PAI].set_addr) {\n\t\tstruct scmi_fc_info *fci = &pc->fc_info[POWERCAP_FC_PAI];\n\n\t\ttrace_scmi_fc_call(SCMI_PROTOCOL_POWERCAP, POWERCAP_PAI_SET,\n\t\t\t\t   domain_id, pai, 0);\n\t\tiowrite32(pai, fci->set_addr);\n\t\tph->hops->fastchannel_db_ring(fci->set_db);\n\t\treturn 0;\n\t}\n\n\treturn scmi_powercap_xfer_pai_set(ph, domain_id, pai);\n}\n\nstatic int scmi_powercap_measurements_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u32 domain_id, u32 *average_power,\n\t\t\t\t\t  u32 *pai)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_powercap_meas_get *resp;\n\tconst struct scmi_powercap_info *pc;\n\n\tpc = scmi_powercap_dom_info_get(ph, domain_id);\n\tif (!pc || !pc->powercap_monitoring || !pai || !average_power)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, POWERCAP_MEASUREMENTS_GET,\n\t\t\t\t      sizeof(u32), sizeof(*resp), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tresp = t->rx.buf;\n\tput_unaligned_le32(domain_id, t->tx.buf);\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\t*average_power = le32_to_cpu(resp->power);\n\t\t*pai = le32_to_cpu(resp->pai);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int\nscmi_powercap_measurements_threshold_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u32 domain_id, u32 *power_thresh_low,\n\t\t\t\t\t u32 *power_thresh_high)\n{\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (!power_thresh_low || !power_thresh_high ||\n\t    domain_id >= pi->num_domains)\n\t\treturn -EINVAL;\n\n\t*power_thresh_low =  THRESH_LOW(pi, domain_id);\n\t*power_thresh_high = THRESH_HIGH(pi, domain_id);\n\n\treturn 0;\n}\n\nstatic int\nscmi_powercap_measurements_threshold_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u32 domain_id, u32 power_thresh_low,\n\t\t\t\t\t u32 power_thresh_high)\n{\n\tint ret = 0;\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (domain_id >= pi->num_domains ||\n\t    power_thresh_low > power_thresh_high)\n\t\treturn -EINVAL;\n\n\t \n\tif (THRESH_LOW(pi, domain_id) == power_thresh_low &&\n\t    THRESH_HIGH(pi, domain_id) == power_thresh_high)\n\t\treturn ret;\n\n\tpi->states[domain_id].thresholds =\n\t\t(FIELD_PREP(GENMASK_ULL(31, 0), power_thresh_low) |\n\t\t FIELD_PREP(GENMASK_ULL(63, 32), power_thresh_high));\n\n\t \n\tif (pi->states[domain_id].meas_notif_enabled)\n\t\tret = scmi_powercap_notify(ph, domain_id,\n\t\t\t\t\t   POWERCAP_MEASUREMENTS_NOTIFY,\n\t\t\t\t\t   true);\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_cap_enable_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tu32 domain_id, bool enable)\n{\n\tint ret;\n\tu32 power_cap;\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (PROTOCOL_REV_MAJOR(pi->version) < 0x2)\n\t\treturn -EINVAL;\n\n\tif (enable == pi->states[domain_id].enabled)\n\t\treturn 0;\n\n\tif (enable) {\n\t\t \n\t\tif (!pi->states[domain_id].last_pcap)\n\t\t\treturn -EINVAL;\n\n\t\tret = __scmi_powercap_cap_set(ph, pi, domain_id,\n\t\t\t\t\t      pi->states[domain_id].last_pcap,\n\t\t\t\t\t      true);\n\t} else {\n\t\tret = __scmi_powercap_cap_set(ph, pi, domain_id, 0, true);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = scmi_powercap_cap_get(ph, domain_id, &power_cap);\n\tif (!ret)\n\t\tpi->states[domain_id].enabled = !!power_cap;\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_cap_enable_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tu32 domain_id, bool *enable)\n{\n\tint ret;\n\tu32 power_cap;\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\t*enable = true;\n\tif (PROTOCOL_REV_MAJOR(pi->version) < 0x2)\n\t\treturn 0;\n\n\t \n\tret = scmi_powercap_cap_get(ph, domain_id, &power_cap);\n\tif (!ret)\n\t\t*enable = !!power_cap;\n\n\t \n\tpi->states[domain_id].enabled = *enable;\n\n\treturn 0;\n}\n\nstatic const struct scmi_powercap_proto_ops powercap_proto_ops = {\n\t.num_domains_get = scmi_powercap_num_domains_get,\n\t.info_get = scmi_powercap_dom_info_get,\n\t.cap_get = scmi_powercap_cap_get,\n\t.cap_set = scmi_powercap_cap_set,\n\t.cap_enable_set = scmi_powercap_cap_enable_set,\n\t.cap_enable_get = scmi_powercap_cap_enable_get,\n\t.pai_get = scmi_powercap_pai_get,\n\t.pai_set = scmi_powercap_pai_set,\n\t.measurements_get = scmi_powercap_measurements_get,\n\t.measurements_threshold_set = scmi_powercap_measurements_threshold_set,\n\t.measurements_threshold_get = scmi_powercap_measurements_threshold_get,\n};\n\nstatic void scmi_powercap_domain_init_fc(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u32 domain, struct scmi_fc_info **p_fc)\n{\n\tstruct scmi_fc_info *fc;\n\n\tfc = devm_kcalloc(ph->dev, POWERCAP_FC_MAX, sizeof(*fc), GFP_KERNEL);\n\tif (!fc)\n\t\treturn;\n\n\tph->hops->fastchannel_init(ph, POWERCAP_DESCRIBE_FASTCHANNEL,\n\t\t\t\t   POWERCAP_CAP_SET, 4, domain,\n\t\t\t\t   &fc[POWERCAP_FC_CAP].set_addr,\n\t\t\t\t   &fc[POWERCAP_FC_CAP].set_db);\n\n\tph->hops->fastchannel_init(ph, POWERCAP_DESCRIBE_FASTCHANNEL,\n\t\t\t\t   POWERCAP_CAP_GET, 4, domain,\n\t\t\t\t   &fc[POWERCAP_FC_CAP].get_addr, NULL);\n\n\tph->hops->fastchannel_init(ph, POWERCAP_DESCRIBE_FASTCHANNEL,\n\t\t\t\t   POWERCAP_PAI_SET, 4, domain,\n\t\t\t\t   &fc[POWERCAP_FC_PAI].set_addr,\n\t\t\t\t   &fc[POWERCAP_FC_PAI].set_db);\n\n\tph->hops->fastchannel_init(ph, POWERCAP_DESCRIBE_FASTCHANNEL,\n\t\t\t\t   POWERCAP_PAI_GET, 4, domain,\n\t\t\t\t   &fc[POWERCAP_FC_PAI].get_addr, NULL);\n\n\t*p_fc = fc;\n}\n\nstatic int scmi_powercap_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain, int message_id, bool enable)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tswitch (message_id) {\n\tcase POWERCAP_CAP_NOTIFY:\n\t{\n\t\tstruct scmi_msg_powercap_notify_cap *notify;\n\n\t\tret = ph->xops->xfer_get_init(ph, message_id,\n\t\t\t\t\t      sizeof(*notify), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnotify = t->tx.buf;\n\t\tnotify->domain = cpu_to_le32(domain);\n\t\tnotify->notify_enable = cpu_to_le32(enable ? BIT(0) : 0);\n\t\tbreak;\n\t}\n\tcase POWERCAP_MEASUREMENTS_NOTIFY:\n\t{\n\t\tu32 low, high;\n\t\tstruct scmi_msg_powercap_notify_thresh *notify;\n\n\t\t \n\t\tret = scmi_powercap_measurements_threshold_get(ph, domain,\n\t\t\t\t\t\t\t       &low, &high);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (enable && !low && !high) {\n\t\t\tdev_err(ph->dev,\n\t\t\t\t\"Invalid Measurements Notify thresholds: %u/%u\\n\",\n\t\t\t\tlow, high);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = ph->xops->xfer_get_init(ph, message_id,\n\t\t\t\t\t      sizeof(*notify), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnotify = t->tx.buf;\n\t\tnotify->domain = cpu_to_le32(domain);\n\t\tnotify->notify_enable = cpu_to_le32(enable ? BIT(0) : 0);\n\t\tnotify->power_thresh_low = cpu_to_le32(low);\n\t\tnotify->power_thresh_high = cpu_to_le32(high);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int\nscmi_powercap_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret, cmd_id;\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (evt_id >= ARRAY_SIZE(evt_2_cmd) || src_id >= pi->num_domains)\n\t\treturn -EINVAL;\n\n\tcmd_id = evt_2_cmd[evt_id];\n\tret = scmi_powercap_notify(ph, src_id, cmd_id, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLED - evt[%X] dom[%d] - ret:%d\\n\",\n\t\t\t evt_id, src_id, ret);\n\telse if (cmd_id == POWERCAP_MEASUREMENTS_NOTIFY)\n\t\t \n\t\tpi->states[src_id].meas_notif_enabled = enable;\n\n\treturn ret;\n}\n\nstatic void *\nscmi_powercap_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t\t u8 evt_id, ktime_t timestamp,\n\t\t\t\t const void *payld, size_t payld_sz,\n\t\t\t\t void *report, u32 *src_id)\n{\n\tvoid *rep = NULL;\n\n\tswitch (evt_id) {\n\tcase SCMI_EVENT_POWERCAP_CAP_CHANGED:\n\t{\n\t\tconst struct scmi_powercap_cap_changed_notify_payld *p = payld;\n\t\tstruct scmi_powercap_cap_changed_report *r = report;\n\n\t\tif (sizeof(*p) != payld_sz)\n\t\t\tbreak;\n\n\t\tr->timestamp = timestamp;\n\t\tr->agent_id = le32_to_cpu(p->agent_id);\n\t\tr->domain_id = le32_to_cpu(p->domain_id);\n\t\tr->power_cap = le32_to_cpu(p->power_cap);\n\t\tr->pai = le32_to_cpu(p->pai);\n\t\t*src_id = r->domain_id;\n\t\trep = r;\n\t\tbreak;\n\t}\n\tcase SCMI_EVENT_POWERCAP_MEASUREMENTS_CHANGED:\n\t{\n\t\tconst struct scmi_powercap_meas_changed_notify_payld *p = payld;\n\t\tstruct scmi_powercap_meas_changed_report *r = report;\n\n\t\tif (sizeof(*p) != payld_sz)\n\t\t\tbreak;\n\n\t\tr->timestamp = timestamp;\n\t\tr->agent_id = le32_to_cpu(p->agent_id);\n\t\tr->domain_id = le32_to_cpu(p->domain_id);\n\t\tr->power = le32_to_cpu(p->power);\n\t\t*src_id = r->domain_id;\n\t\trep = r;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rep;\n}\n\nstatic int\nscmi_powercap_get_num_sources(const struct scmi_protocol_handle *ph)\n{\n\tstruct powercap_info *pi = ph->get_priv(ph);\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\treturn pi->num_domains;\n}\n\nstatic const struct scmi_event powercap_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_POWERCAP_CAP_CHANGED,\n\t\t.max_payld_sz =\n\t\t\tsizeof(struct scmi_powercap_cap_changed_notify_payld),\n\t\t.max_report_sz =\n\t\t\tsizeof(struct scmi_powercap_cap_changed_report),\n\t},\n\t{\n\t\t.id = SCMI_EVENT_POWERCAP_MEASUREMENTS_CHANGED,\n\t\t.max_payld_sz =\n\t\t\tsizeof(struct scmi_powercap_meas_changed_notify_payld),\n\t\t.max_report_sz =\n\t\t\tsizeof(struct scmi_powercap_meas_changed_report),\n\t},\n};\n\nstatic const struct scmi_event_ops powercap_event_ops = {\n\t.get_num_sources = scmi_powercap_get_num_sources,\n\t.set_notify_enabled = scmi_powercap_set_notify_enabled,\n\t.fill_custom_report = scmi_powercap_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events powercap_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &powercap_event_ops,\n\t.evts = powercap_events,\n\t.num_events = ARRAY_SIZE(powercap_events),\n};\n\nstatic int\nscmi_powercap_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint domain, ret;\n\tu32 version;\n\tstruct powercap_info *pinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Powercap Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tpinfo = devm_kzalloc(ph->dev, sizeof(*pinfo), GFP_KERNEL);\n\tif (!pinfo)\n\t\treturn -ENOMEM;\n\n\tret = scmi_powercap_attributes_get(ph, pinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tpinfo->powercaps = devm_kcalloc(ph->dev, pinfo->num_domains,\n\t\t\t\t\tsizeof(*pinfo->powercaps),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pinfo->powercaps)\n\t\treturn -ENOMEM;\n\n\tpinfo->states = devm_kcalloc(ph->dev, pinfo->num_domains,\n\t\t\t\t     sizeof(*pinfo->states), GFP_KERNEL);\n\tif (!pinfo->states)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (domain = 0; domain < pinfo->num_domains; domain++) {\n\t\tret = scmi_powercap_domain_attributes_get(ph, pinfo, domain);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pinfo->powercaps[domain].fastchannels)\n\t\t\tscmi_powercap_domain_init_fc(ph, domain,\n\t\t\t\t\t\t     &pinfo->powercaps[domain].fc_info);\n\n\t\t \n\t\tif (PROTOCOL_REV_MAJOR(version) >= 0x2) {\n\t\t\tret = __scmi_powercap_cap_get(ph,\n\t\t\t\t\t\t      &pinfo->powercaps[domain],\n\t\t\t\t\t\t      &pinfo->states[domain].last_pcap);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tpinfo->states[domain].enabled =\n\t\t\t\t!!pinfo->states[domain].last_pcap;\n\t\t}\n\t}\n\n\tpinfo->version = version;\n\treturn ph->set_priv(ph, pinfo);\n}\n\nstatic const struct scmi_protocol scmi_powercap = {\n\t.id = SCMI_PROTOCOL_POWERCAP,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_powercap_protocol_init,\n\t.ops = &powercap_proto_ops,\n\t.events = &powercap_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(powercap, scmi_powercap)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}