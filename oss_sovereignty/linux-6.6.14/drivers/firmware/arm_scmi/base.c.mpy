{
  "module_name": "base.c",
  "hash_id": "71034fcb0da015c69714e67590f4d4f31559bcfa689b20fda29e4618bde7326a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/base.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications BASE - \" fmt\n\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"common.h\"\n#include \"notify.h\"\n\n#define SCMI_BASE_NUM_SOURCES\t\t1\n#define SCMI_BASE_MAX_CMD_ERR_COUNT\t1024\n\nenum scmi_base_protocol_cmd {\n\tBASE_DISCOVER_VENDOR = 0x3,\n\tBASE_DISCOVER_SUB_VENDOR = 0x4,\n\tBASE_DISCOVER_IMPLEMENT_VERSION = 0x5,\n\tBASE_DISCOVER_LIST_PROTOCOLS = 0x6,\n\tBASE_DISCOVER_AGENT = 0x7,\n\tBASE_NOTIFY_ERRORS = 0x8,\n\tBASE_SET_DEVICE_PERMISSIONS = 0x9,\n\tBASE_SET_PROTOCOL_PERMISSIONS = 0xa,\n\tBASE_RESET_AGENT_CONFIGURATION = 0xb,\n};\n\nstruct scmi_msg_resp_base_attributes {\n\tu8 num_protocols;\n\tu8 num_agents;\n\t__le16 reserved;\n};\n\nstruct scmi_msg_resp_base_discover_agent {\n\t__le32 agent_id;\n\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n};\n\n\nstruct scmi_msg_base_error_notify {\n\t__le32 event_control;\n#define BASE_TP_NOTIFY_ALL\tBIT(0)\n};\n\nstruct scmi_base_error_notify_payld {\n\t__le32 agent_id;\n\t__le32 error_status;\n#define IS_FATAL_ERROR(x)\t((x) & BIT(31))\n#define ERROR_CMD_COUNT(x)\tFIELD_GET(GENMASK(9, 0), (x))\n\t__le64 msg_reports[SCMI_BASE_MAX_CMD_ERR_COUNT];\n};\n\n \nstatic int scmi_base_attributes_get(const struct scmi_protocol_handle *ph)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_base_attributes *attr_info;\n\tstruct scmi_revision_info *rev = ph->get_priv(ph);\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES,\n\t\t\t\t      0, sizeof(*attr_info), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tattr_info = t->rx.buf;\n\t\trev->num_protocols = attr_info->num_protocols;\n\t\trev->num_agents = attr_info->num_agents;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\n \nstatic int\nscmi_base_vendor_id_get(const struct scmi_protocol_handle *ph, bool sub_vendor)\n{\n\tu8 cmd;\n\tint ret, size;\n\tchar *vendor_id;\n\tstruct scmi_xfer *t;\n\tstruct scmi_revision_info *rev = ph->get_priv(ph);\n\n\n\tif (sub_vendor) {\n\t\tcmd = BASE_DISCOVER_SUB_VENDOR;\n\t\tvendor_id = rev->sub_vendor_id;\n\t\tsize = ARRAY_SIZE(rev->sub_vendor_id);\n\t} else {\n\t\tcmd = BASE_DISCOVER_VENDOR;\n\t\tvendor_id = rev->vendor_id;\n\t\tsize = ARRAY_SIZE(rev->vendor_id);\n\t}\n\n\tret = ph->xops->xfer_get_init(ph, cmd, 0, size, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\tstrscpy(vendor_id, t->rx.buf, size);\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\n \nstatic int\nscmi_base_implementation_version_get(const struct scmi_protocol_handle *ph)\n{\n\tint ret;\n\t__le32 *impl_ver;\n\tstruct scmi_xfer *t;\n\tstruct scmi_revision_info *rev = ph->get_priv(ph);\n\n\tret = ph->xops->xfer_get_init(ph, BASE_DISCOVER_IMPLEMENT_VERSION,\n\t\t\t\t      0, sizeof(*impl_ver), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\timpl_ver = t->rx.buf;\n\t\trev->impl_ver = le32_to_cpu(*impl_ver);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\n \nstatic int\nscmi_base_implementation_list_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u8 *protocols_imp)\n{\n\tu8 *list;\n\tint ret, loop;\n\tstruct scmi_xfer *t;\n\t__le32 *num_skip, *num_ret;\n\tu32 tot_num_ret = 0, loop_num_ret;\n\tstruct device *dev = ph->dev;\n\tstruct scmi_revision_info *rev = ph->get_priv(ph);\n\n\tret = ph->xops->xfer_get_init(ph, BASE_DISCOVER_LIST_PROTOCOLS,\n\t\t\t\t      sizeof(*num_skip), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tnum_skip = t->tx.buf;\n\tnum_ret = t->rx.buf;\n\tlist = t->rx.buf + sizeof(*num_ret);\n\n\tdo {\n\t\tsize_t real_list_sz;\n\t\tu32 calc_list_sz;\n\n\t\t \n\t\t*num_skip = cpu_to_le32(tot_num_ret);\n\n\t\tret = ph->xops->do_xfer(ph, t);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tloop_num_ret = le32_to_cpu(*num_ret);\n\t\tif (!loop_num_ret)\n\t\t\tbreak;\n\n\t\tif (loop_num_ret > rev->num_protocols - tot_num_ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"No. Returned protocols > Total protocols.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (t->rx.len < (sizeof(u32) * 2)) {\n\t\t\tdev_err(dev, \"Truncated reply - rx.len:%zd\\n\",\n\t\t\t\tt->rx.len);\n\t\t\tret = -EPROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\treal_list_sz = t->rx.len - sizeof(u32);\n\t\tcalc_list_sz = (1 + (loop_num_ret - 1) / sizeof(u32)) *\n\t\t\t\tsizeof(u32);\n\t\tif (calc_list_sz != real_list_sz) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Malformed reply - real_sz:%zd  calc_sz:%u  (loop_num_ret:%d)\\n\",\n\t\t\t\t real_list_sz, calc_list_sz, loop_num_ret);\n\t\t\t \n\t\t\tif (calc_list_sz > real_list_sz) {\n\t\t\t\tret = -EPROTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (loop = 0; loop < loop_num_ret; loop++)\n\t\t\tprotocols_imp[tot_num_ret + loop] = *(list + loop);\n\n\t\ttot_num_ret += loop_num_ret;\n\n\t\tph->xops->reset_rx_to_maxsz(ph, t);\n\t} while (tot_num_ret < rev->num_protocols);\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\n \nstatic int scmi_base_discover_agent_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tint id, char *name)\n{\n\tint ret;\n\tstruct scmi_msg_resp_base_discover_agent *agent_info;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, BASE_DISCOVER_AGENT,\n\t\t\t\t      sizeof(__le32), sizeof(*agent_info), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(id, t->tx.buf);\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tagent_info = t->rx.buf;\n\t\tstrscpy(name, agent_info->name, SCMI_SHORT_NAME_MAX_SIZE);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\n\treturn ret;\n}\n\nstatic int scmi_base_error_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\t  bool enable)\n{\n\tint ret;\n\tu32 evt_cntl = enable ? BASE_TP_NOTIFY_ALL : 0;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_base_error_notify *cfg;\n\n\tret = ph->xops->xfer_get_init(ph, BASE_NOTIFY_ERRORS,\n\t\t\t\t      sizeof(*cfg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = t->tx.buf;\n\tcfg->event_control = cpu_to_le32(evt_cntl);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_base_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tu8 evt_id, u32 src_id, bool enable)\n{\n\tint ret;\n\n\tret = scmi_base_error_notify(ph, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLED - evt[%X] ret:%d\\n\", evt_id, ret);\n\n\treturn ret;\n}\n\nstatic void *scmi_base_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u8 evt_id, ktime_t timestamp,\n\t\t\t\t\t  const void *payld, size_t payld_sz,\n\t\t\t\t\t  void *report, u32 *src_id)\n{\n\tint i;\n\tconst struct scmi_base_error_notify_payld *p = payld;\n\tstruct scmi_base_error_report *r = report;\n\n\t \n\tif (evt_id != SCMI_EVENT_BASE_ERROR_EVENT || sizeof(*p) < payld_sz)\n\t\treturn NULL;\n\n\tr->timestamp = timestamp;\n\tr->agent_id = le32_to_cpu(p->agent_id);\n\tr->fatal = IS_FATAL_ERROR(le32_to_cpu(p->error_status));\n\tr->cmd_count = ERROR_CMD_COUNT(le32_to_cpu(p->error_status));\n\tfor (i = 0; i < r->cmd_count; i++)\n\t\tr->reports[i] = le64_to_cpu(p->msg_reports[i]);\n\t*src_id = 0;\n\n\treturn r;\n}\n\nstatic const struct scmi_event base_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_BASE_ERROR_EVENT,\n\t\t.max_payld_sz = sizeof(struct scmi_base_error_notify_payld),\n\t\t.max_report_sz = sizeof(struct scmi_base_error_report) +\n\t\t\t\t  SCMI_BASE_MAX_CMD_ERR_COUNT * sizeof(u64),\n\t},\n};\n\nstatic const struct scmi_event_ops base_event_ops = {\n\t.set_notify_enabled = scmi_base_set_notify_enabled,\n\t.fill_custom_report = scmi_base_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events base_protocol_events = {\n\t.queue_sz = 4 * SCMI_PROTO_QUEUE_SZ,\n\t.ops = &base_event_ops,\n\t.evts = base_events,\n\t.num_events = ARRAY_SIZE(base_events),\n\t.num_sources = SCMI_BASE_NUM_SOURCES,\n};\n\nstatic int scmi_base_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint id, ret;\n\tu8 *prot_imp;\n\tu32 version;\n\tchar name[SCMI_SHORT_NAME_MAX_SIZE];\n\tstruct device *dev = ph->dev;\n\tstruct scmi_revision_info *rev = scmi_revision_area_get(ph);\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\trev->major_ver = PROTOCOL_REV_MAJOR(version),\n\trev->minor_ver = PROTOCOL_REV_MINOR(version);\n\tph->set_priv(ph, rev);\n\n\tret = scmi_base_attributes_get(ph);\n\tif (ret)\n\t\treturn ret;\n\n\tprot_imp = devm_kcalloc(dev, rev->num_protocols, sizeof(u8),\n\t\t\t\tGFP_KERNEL);\n\tif (!prot_imp)\n\t\treturn -ENOMEM;\n\n\tscmi_base_vendor_id_get(ph, false);\n\tscmi_base_vendor_id_get(ph, true);\n\tscmi_base_implementation_version_get(ph);\n\tscmi_base_implementation_list_get(ph, prot_imp);\n\n\tscmi_setup_protocol_implemented(ph, prot_imp);\n\n\tdev_info(dev, \"SCMI Protocol v%d.%d '%s:%s' Firmware version 0x%x\\n\",\n\t\t rev->major_ver, rev->minor_ver, rev->vendor_id,\n\t\t rev->sub_vendor_id, rev->impl_ver);\n\tdev_dbg(dev, \"Found %d protocol(s) %d agent(s)\\n\", rev->num_protocols,\n\t\trev->num_agents);\n\n\tfor (id = 0; id < rev->num_agents; id++) {\n\t\tscmi_base_discover_agent_get(ph, id, name);\n\t\tdev_dbg(dev, \"Agent %d: %s\\n\", id, name);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct scmi_protocol scmi_base = {\n\t.id = SCMI_PROTOCOL_BASE,\n\t.owner = NULL,\n\t.instance_init = &scmi_base_protocol_init,\n\t.ops = NULL,\n\t.events = &base_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(base, scmi_base)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}