{
  "module_name": "smc.c",
  "hash_id": "145d851681750b5da7061d84e6de3789f1b2f00194d14942141576cde67fa6e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/smc.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/atomic.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/processor.h>\n#include <linux/slab.h>\n\n#include \"common.h\"\n\n \n\n#define SHMEM_SIZE (SZ_4K)\n#define SHMEM_SHIFT 12\n#define SHMEM_PAGE(x) (_UL((x) >> SHMEM_SHIFT))\n#define SHMEM_OFFSET(x) ((x) & (SHMEM_SIZE - 1))\n\n \n\nstruct scmi_smc {\n\tint irq;\n\tstruct scmi_chan_info *cinfo;\n\tstruct scmi_shared_mem __iomem *shmem;\n\t \n\tstruct mutex shmem_lock;\n#define INFLIGHT_NONE\tMSG_TOKEN_MAX\n\tatomic_t inflight;\n\tu32 func_id;\n\tu32 param_page;\n\tu32 param_offset;\n};\n\nstatic irqreturn_t smc_msg_done_isr(int irq, void *data)\n{\n\tstruct scmi_smc *scmi_info = data;\n\n\tscmi_rx_callback(scmi_info->cinfo,\n\t\t\t shmem_read_header(scmi_info->shmem), NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool smc_chan_available(struct device_node *of_node, int idx)\n{\n\tstruct device_node *np = of_parse_phandle(of_node, \"shmem\", 0);\n\tif (!np)\n\t\treturn false;\n\n\tof_node_put(np);\n\treturn true;\n}\n\nstatic inline void smc_channel_lock_init(struct scmi_smc *scmi_info)\n{\n\tif (IS_ENABLED(CONFIG_ARM_SCMI_TRANSPORT_SMC_ATOMIC_ENABLE))\n\t\tatomic_set(&scmi_info->inflight, INFLIGHT_NONE);\n\telse\n\t\tmutex_init(&scmi_info->shmem_lock);\n}\n\nstatic bool smc_xfer_inflight(struct scmi_xfer *xfer, atomic_t *inflight)\n{\n\tint ret;\n\n\tret = atomic_cmpxchg(inflight, INFLIGHT_NONE, xfer->hdr.seq);\n\n\treturn ret == INFLIGHT_NONE;\n}\n\nstatic inline void\nsmc_channel_lock_acquire(struct scmi_smc *scmi_info,\n\t\t\t struct scmi_xfer *xfer __maybe_unused)\n{\n\tif (IS_ENABLED(CONFIG_ARM_SCMI_TRANSPORT_SMC_ATOMIC_ENABLE))\n\t\tspin_until_cond(smc_xfer_inflight(xfer, &scmi_info->inflight));\n\telse\n\t\tmutex_lock(&scmi_info->shmem_lock);\n}\n\nstatic inline void smc_channel_lock_release(struct scmi_smc *scmi_info)\n{\n\tif (IS_ENABLED(CONFIG_ARM_SCMI_TRANSPORT_SMC_ATOMIC_ENABLE))\n\t\tatomic_set(&scmi_info->inflight, INFLIGHT_NONE);\n\telse\n\t\tmutex_unlock(&scmi_info->shmem_lock);\n}\n\nstatic int smc_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,\n\t\t\t  bool tx)\n{\n\tstruct device *cdev = cinfo->dev;\n\tstruct scmi_smc *scmi_info;\n\tresource_size_t size;\n\tstruct resource res;\n\tstruct device_node *np;\n\tu32 func_id;\n\tint ret;\n\n\tif (!tx)\n\t\treturn -ENODEV;\n\n\tscmi_info = devm_kzalloc(dev, sizeof(*scmi_info), GFP_KERNEL);\n\tif (!scmi_info)\n\t\treturn -ENOMEM;\n\n\tnp = of_parse_phandle(cdev->of_node, \"shmem\", 0);\n\tif (!of_device_is_compatible(np, \"arm,scmi-shmem\")) {\n\t\tof_node_put(np);\n\t\treturn -ENXIO;\n\t}\n\n\tret = of_address_to_resource(np, 0, &res);\n\tof_node_put(np);\n\tif (ret) {\n\t\tdev_err(cdev, \"failed to get SCMI Tx shared memory\\n\");\n\t\treturn ret;\n\t}\n\n\tsize = resource_size(&res);\n\tscmi_info->shmem = devm_ioremap(dev, res.start, size);\n\tif (!scmi_info->shmem) {\n\t\tdev_err(dev, \"failed to ioremap SCMI Tx shared memory\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"arm,smc-id\", &func_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (of_device_is_compatible(dev->of_node, \"arm,scmi-smc-param\")) {\n\t\tscmi_info->param_page = SHMEM_PAGE(res.start);\n\t\tscmi_info->param_offset = SHMEM_OFFSET(res.start);\n\t}\n\t \n\tscmi_info->irq = of_irq_get_byname(cdev->of_node, \"a2p\");\n\tif (scmi_info->irq > 0) {\n\t\tret = request_irq(scmi_info->irq, smc_msg_done_isr,\n\t\t\t\t  IRQF_NO_SUSPEND, dev_name(dev), scmi_info);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to setup SCMI smc irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tcinfo->no_completion_irq = true;\n\t}\n\n\tscmi_info->func_id = func_id;\n\tscmi_info->cinfo = cinfo;\n\tsmc_channel_lock_init(scmi_info);\n\tcinfo->transport_info = scmi_info;\n\n\treturn 0;\n}\n\nstatic int smc_chan_free(int id, void *p, void *data)\n{\n\tstruct scmi_chan_info *cinfo = p;\n\tstruct scmi_smc *scmi_info = cinfo->transport_info;\n\n\t \n\tif (scmi_info->irq > 0)\n\t\tfree_irq(scmi_info->irq, scmi_info);\n\n\tcinfo->transport_info = NULL;\n\tscmi_info->cinfo = NULL;\n\n\treturn 0;\n}\n\nstatic int smc_send_message(struct scmi_chan_info *cinfo,\n\t\t\t    struct scmi_xfer *xfer)\n{\n\tstruct scmi_smc *scmi_info = cinfo->transport_info;\n\tstruct arm_smccc_res res;\n\tunsigned long page = scmi_info->param_page;\n\tunsigned long offset = scmi_info->param_offset;\n\n\t \n\tsmc_channel_lock_acquire(scmi_info, xfer);\n\n\tshmem_tx_prepare(scmi_info->shmem, xfer, cinfo);\n\n\tarm_smccc_1_1_invoke(scmi_info->func_id, page, offset, 0, 0, 0, 0, 0,\n\t\t\t     &res);\n\n\t \n\tif (res.a0) {\n\t\tsmc_channel_lock_release(scmi_info);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void smc_fetch_response(struct scmi_chan_info *cinfo,\n\t\t\t       struct scmi_xfer *xfer)\n{\n\tstruct scmi_smc *scmi_info = cinfo->transport_info;\n\n\tshmem_fetch_response(scmi_info->shmem, xfer);\n}\n\nstatic void smc_mark_txdone(struct scmi_chan_info *cinfo, int ret,\n\t\t\t    struct scmi_xfer *__unused)\n{\n\tstruct scmi_smc *scmi_info = cinfo->transport_info;\n\n\tsmc_channel_lock_release(scmi_info);\n}\n\nstatic const struct scmi_transport_ops scmi_smc_ops = {\n\t.chan_available = smc_chan_available,\n\t.chan_setup = smc_chan_setup,\n\t.chan_free = smc_chan_free,\n\t.send_message = smc_send_message,\n\t.mark_txdone = smc_mark_txdone,\n\t.fetch_response = smc_fetch_response,\n};\n\nconst struct scmi_desc scmi_smc_desc = {\n\t.ops = &scmi_smc_ops,\n\t.max_rx_timeout_ms = 30,\n\t.max_msg = 20,\n\t.max_msg_size = 128,\n\t \n\t.sync_cmds_completed_on_ret = true,\n\t.atomic_enabled = IS_ENABLED(CONFIG_ARM_SCMI_TRANSPORT_SMC_ATOMIC_ENABLE),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}