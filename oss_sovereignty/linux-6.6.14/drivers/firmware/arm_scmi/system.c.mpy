{
  "module_name": "system.c",
  "hash_id": "f4214ca26745002bc9f2923ffe688d207d25cd6d22bb0ab5bd93cacedea29186",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/system.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications SYSTEM - \" fmt\n\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\n#define SCMI_SYSTEM_NUM_SOURCES\t\t1\n\nenum scmi_system_protocol_cmd {\n\tSYSTEM_POWER_STATE_NOTIFY = 0x5,\n};\n\nstruct scmi_system_power_state_notify {\n\t__le32 notify_enable;\n};\n\nstruct scmi_system_power_state_notifier_payld {\n\t__le32 agent_id;\n\t__le32 flags;\n\t__le32 system_state;\n\t__le32 timeout;\n};\n\nstruct scmi_system_info {\n\tu32 version;\n\tbool graceful_timeout_supported;\n};\n\nstatic int scmi_system_request_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\t      bool enable)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_system_power_state_notify *notify;\n\n\tret = ph->xops->xfer_get_init(ph, SYSTEM_POWER_STATE_NOTIFY,\n\t\t\t\t      sizeof(*notify), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tnotify = t->tx.buf;\n\tnotify->notify_enable = enable ? cpu_to_le32(BIT(0)) : 0;\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_system_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret;\n\n\tret = scmi_system_request_notify(ph, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLE - evt[%X] - ret:%d\\n\", evt_id, ret);\n\n\treturn ret;\n}\n\nstatic void *\nscmi_system_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t       u8 evt_id, ktime_t timestamp,\n\t\t\t       const void *payld, size_t payld_sz,\n\t\t\t       void *report, u32 *src_id)\n{\n\tsize_t expected_sz;\n\tconst struct scmi_system_power_state_notifier_payld *p = payld;\n\tstruct scmi_system_power_state_notifier_report *r = report;\n\tstruct scmi_system_info *pinfo = ph->get_priv(ph);\n\n\texpected_sz = pinfo->graceful_timeout_supported ?\n\t\t\tsizeof(*p) : sizeof(*p) - sizeof(__le32);\n\tif (evt_id != SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER ||\n\t    payld_sz != expected_sz)\n\t\treturn NULL;\n\n\tr->timestamp = timestamp;\n\tr->agent_id = le32_to_cpu(p->agent_id);\n\tr->flags = le32_to_cpu(p->flags);\n\tr->system_state = le32_to_cpu(p->system_state);\n\tif (pinfo->graceful_timeout_supported &&\n\t    r->system_state == SCMI_SYSTEM_SHUTDOWN &&\n\t    SCMI_SYSPOWER_IS_REQUEST_GRACEFUL(r->flags))\n\t\tr->timeout = le32_to_cpu(p->timeout);\n\telse\n\t\tr->timeout = 0x00;\n\t*src_id = 0;\n\n\treturn r;\n}\n\nstatic const struct scmi_event system_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER,\n\t\t.max_payld_sz =\n\t\t\tsizeof(struct scmi_system_power_state_notifier_payld),\n\t\t.max_report_sz =\n\t\t\tsizeof(struct scmi_system_power_state_notifier_report),\n\t},\n};\n\nstatic const struct scmi_event_ops system_event_ops = {\n\t.set_notify_enabled = scmi_system_set_notify_enabled,\n\t.fill_custom_report = scmi_system_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events system_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &system_event_ops,\n\t.evts = system_events,\n\t.num_events = ARRAY_SIZE(system_events),\n\t.num_sources = SCMI_SYSTEM_NUM_SOURCES,\n};\n\nstatic int scmi_system_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint ret;\n\tu32 version;\n\tstruct scmi_system_info *pinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"System Power Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tpinfo = devm_kzalloc(ph->dev, sizeof(*pinfo), GFP_KERNEL);\n\tif (!pinfo)\n\t\treturn -ENOMEM;\n\n\tpinfo->version = version;\n\tif (PROTOCOL_REV_MAJOR(pinfo->version) >= 0x2)\n\t\tpinfo->graceful_timeout_supported = true;\n\n\treturn ph->set_priv(ph, pinfo);\n}\n\nstatic const struct scmi_protocol scmi_system = {\n\t.id = SCMI_PROTOCOL_SYSTEM,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_system_protocol_init,\n\t.ops = NULL,\n\t.events = &system_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(system, scmi_system)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}