{
  "module_name": "bus.c",
  "hash_id": "2476a315a4a14f7ca01175a1d2bc1329c3ef763e78c19b557aa08be297ca0d23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#include \"common.h\"\n\nBLOCKING_NOTIFIER_HEAD(scmi_requested_devices_nh);\nEXPORT_SYMBOL_GPL(scmi_requested_devices_nh);\n\nstatic DEFINE_IDA(scmi_bus_id);\n\nstatic DEFINE_IDR(scmi_requested_devices);\n \nstatic DEFINE_MUTEX(scmi_requested_devices_mtx);\n\nstruct scmi_requested_dev {\n\tconst struct scmi_device_id *id_table;\n\tstruct list_head node;\n};\n\n \nstatic atomic_t scmi_syspower_registered = ATOMIC_INIT(0);\n\n \nstatic int scmi_protocol_device_request(const struct scmi_device_id *id_table)\n{\n\tint ret = 0;\n\tunsigned int id = 0;\n\tstruct list_head *head, *phead = NULL;\n\tstruct scmi_requested_dev *rdev;\n\n\tpr_debug(\"Requesting SCMI device (%s) for protocol %x\\n\",\n\t\t id_table->name, id_table->protocol_id);\n\n\tif (IS_ENABLED(CONFIG_ARM_SCMI_RAW_MODE_SUPPORT) &&\n\t    !IS_ENABLED(CONFIG_ARM_SCMI_RAW_MODE_SUPPORT_COEX)) {\n\t\tpr_warn(\"SCMI Raw mode active. Rejecting '%s'/0x%02X\\n\",\n\t\t\tid_table->name, id_table->protocol_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&scmi_requested_devices_mtx);\n\tidr_for_each_entry(&scmi_requested_devices, head, id) {\n\t\tif (!phead) {\n\t\t\t \n\t\t\trdev = list_first_entry(head, struct scmi_requested_dev,\n\t\t\t\t\t\tnode);\n\t\t\tif (rdev->id_table->protocol_id ==\n\t\t\t    id_table->protocol_id)\n\t\t\t\tphead = head;\n\t\t}\n\t\tlist_for_each_entry(rdev, head, node) {\n\t\t\tif (!strcmp(rdev->id_table->name, id_table->name)) {\n\t\t\t\tpr_err(\"Ignoring duplicate request [%d] %s\\n\",\n\t\t\t\t       rdev->id_table->protocol_id,\n\t\t\t\t       rdev->id_table->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\n\tif (!rdev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdev->id_table = id_table;\n\n\t \n\tif (!phead) {\n\t\tphead = kzalloc(sizeof(*phead), GFP_KERNEL);\n\t\tif (!phead) {\n\t\t\tkfree(rdev);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(phead);\n\n\t\tret = idr_alloc(&scmi_requested_devices, (void *)phead,\n\t\t\t\tid_table->protocol_id,\n\t\t\t\tid_table->protocol_id + 1, GFP_KERNEL);\n\t\tif (ret != id_table->protocol_id) {\n\t\t\tpr_err(\"Failed to save SCMI device - ret:%d\\n\", ret);\n\t\t\tkfree(rdev);\n\t\t\tkfree(phead);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\t}\n\tlist_add(&rdev->node, phead);\n\nout:\n\tmutex_unlock(&scmi_requested_devices_mtx);\n\n\tif (!ret)\n\t\tblocking_notifier_call_chain(&scmi_requested_devices_nh,\n\t\t\t\t\t     SCMI_BUS_NOTIFY_DEVICE_REQUEST,\n\t\t\t\t\t     (void *)rdev->id_table);\n\n\treturn ret;\n}\n\n \nstatic void scmi_protocol_device_unrequest(const struct scmi_device_id *id_table)\n{\n\tstruct list_head *phead;\n\n\tpr_debug(\"Unrequesting SCMI device (%s) for protocol %x\\n\",\n\t\t id_table->name, id_table->protocol_id);\n\n\tmutex_lock(&scmi_requested_devices_mtx);\n\tphead = idr_find(&scmi_requested_devices, id_table->protocol_id);\n\tif (phead) {\n\t\tstruct scmi_requested_dev *victim, *tmp;\n\n\t\tlist_for_each_entry_safe(victim, tmp, phead, node) {\n\t\t\tif (!strcmp(victim->id_table->name, id_table->name)) {\n\t\t\t\tlist_del(&victim->node);\n\n\t\t\t\tmutex_unlock(&scmi_requested_devices_mtx);\n\t\t\t\tblocking_notifier_call_chain(&scmi_requested_devices_nh,\n\t\t\t\t\t\t\t     SCMI_BUS_NOTIFY_DEVICE_UNREQUEST,\n\t\t\t\t\t\t\t     (void *)victim->id_table);\n\t\t\t\tkfree(victim);\n\t\t\t\tmutex_lock(&scmi_requested_devices_mtx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (list_empty(phead)) {\n\t\t\tidr_remove(&scmi_requested_devices,\n\t\t\t\t   id_table->protocol_id);\n\t\t\tkfree(phead);\n\t\t}\n\t}\n\tmutex_unlock(&scmi_requested_devices_mtx);\n}\n\nstatic const struct scmi_device_id *\nscmi_dev_match_id(struct scmi_device *scmi_dev, struct scmi_driver *scmi_drv)\n{\n\tconst struct scmi_device_id *id = scmi_drv->id_table;\n\n\tif (!id)\n\t\treturn NULL;\n\n\tfor (; id->protocol_id; id++)\n\t\tif (id->protocol_id == scmi_dev->protocol_id) {\n\t\t\tif (!id->name)\n\t\t\t\treturn id;\n\t\t\telse if (!strcmp(id->name, scmi_dev->name))\n\t\t\t\treturn id;\n\t\t}\n\n\treturn NULL;\n}\n\nstatic int scmi_dev_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct scmi_driver *scmi_drv = to_scmi_driver(drv);\n\tstruct scmi_device *scmi_dev = to_scmi_dev(dev);\n\tconst struct scmi_device_id *id;\n\n\tid = scmi_dev_match_id(scmi_dev, scmi_drv);\n\tif (id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int scmi_match_by_id_table(struct device *dev, void *data)\n{\n\tstruct scmi_device *sdev = to_scmi_dev(dev);\n\tstruct scmi_device_id *id_table = data;\n\n\treturn sdev->protocol_id == id_table->protocol_id &&\n\t\t(id_table->name && !strcmp(sdev->name, id_table->name));\n}\n\nstatic struct scmi_device *scmi_child_dev_find(struct device *parent,\n\t\t\t\t\t       int prot_id, const char *name)\n{\n\tstruct scmi_device_id id_table;\n\tstruct device *dev;\n\n\tid_table.protocol_id = prot_id;\n\tid_table.name = name;\n\n\tdev = device_find_child(parent, &id_table, scmi_match_by_id_table);\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_scmi_dev(dev);\n}\n\nstatic int scmi_dev_probe(struct device *dev)\n{\n\tstruct scmi_driver *scmi_drv = to_scmi_driver(dev->driver);\n\tstruct scmi_device *scmi_dev = to_scmi_dev(dev);\n\n\tif (!scmi_dev->handle)\n\t\treturn -EPROBE_DEFER;\n\n\treturn scmi_drv->probe(scmi_dev);\n}\n\nstatic void scmi_dev_remove(struct device *dev)\n{\n\tstruct scmi_driver *scmi_drv = to_scmi_driver(dev->driver);\n\tstruct scmi_device *scmi_dev = to_scmi_dev(dev);\n\n\tif (scmi_drv->remove)\n\t\tscmi_drv->remove(scmi_dev);\n}\n\nstruct bus_type scmi_bus_type = {\n\t.name =\t\"scmi_protocol\",\n\t.match = scmi_dev_match,\n\t.probe = scmi_dev_probe,\n\t.remove = scmi_dev_remove,\n};\nEXPORT_SYMBOL_GPL(scmi_bus_type);\n\nint scmi_driver_register(struct scmi_driver *driver, struct module *owner,\n\t\t\t const char *mod_name)\n{\n\tint retval;\n\n\tif (!driver->probe)\n\t\treturn -EINVAL;\n\n\tretval = scmi_protocol_device_request(driver->id_table);\n\tif (retval)\n\t\treturn retval;\n\n\tdriver->driver.bus = &scmi_bus_type;\n\tdriver->driver.name = driver->name;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\n\tretval = driver_register(&driver->driver);\n\tif (!retval)\n\t\tpr_debug(\"Registered new scmi driver %s\\n\", driver->name);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(scmi_driver_register);\n\nvoid scmi_driver_unregister(struct scmi_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n\tscmi_protocol_device_unrequest(driver->id_table);\n}\nEXPORT_SYMBOL_GPL(scmi_driver_unregister);\n\nstatic void scmi_device_release(struct device *dev)\n{\n\tkfree(to_scmi_dev(dev));\n}\n\nstatic void __scmi_device_destroy(struct scmi_device *scmi_dev)\n{\n\tpr_debug(\"(%s) Destroying SCMI device '%s' for protocol 0x%x (%s)\\n\",\n\t\t of_node_full_name(scmi_dev->dev.parent->of_node),\n\t\t dev_name(&scmi_dev->dev), scmi_dev->protocol_id,\n\t\t scmi_dev->name);\n\n\tif (scmi_dev->protocol_id == SCMI_PROTOCOL_SYSTEM)\n\t\tatomic_set(&scmi_syspower_registered, 0);\n\n\tkfree_const(scmi_dev->name);\n\tida_free(&scmi_bus_id, scmi_dev->id);\n\tdevice_unregister(&scmi_dev->dev);\n}\n\nstatic struct scmi_device *\n__scmi_device_create(struct device_node *np, struct device *parent,\n\t\t     int protocol, const char *name)\n{\n\tint id, retval;\n\tstruct scmi_device *scmi_dev;\n\n\t \n\tscmi_dev = scmi_child_dev_find(parent, protocol, name);\n\tif (scmi_dev)\n\t\treturn scmi_dev;\n\n\t \n\tif (protocol == SCMI_PROTOCOL_SYSTEM &&\n\t    atomic_cmpxchg(&scmi_syspower_registered, 0, 1)) {\n\t\tdev_warn(parent,\n\t\t\t \"SCMI SystemPower protocol device must be unique !\\n\");\n\t\treturn NULL;\n\t}\n\n\tscmi_dev = kzalloc(sizeof(*scmi_dev), GFP_KERNEL);\n\tif (!scmi_dev)\n\t\treturn NULL;\n\n\tscmi_dev->name = kstrdup_const(name ?: \"unknown\", GFP_KERNEL);\n\tif (!scmi_dev->name) {\n\t\tkfree(scmi_dev);\n\t\treturn NULL;\n\t}\n\n\tid = ida_alloc_min(&scmi_bus_id, 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tkfree_const(scmi_dev->name);\n\t\tkfree(scmi_dev);\n\t\treturn NULL;\n\t}\n\n\tscmi_dev->id = id;\n\tscmi_dev->protocol_id = protocol;\n\tscmi_dev->dev.parent = parent;\n\tdevice_set_node(&scmi_dev->dev, of_fwnode_handle(np));\n\tscmi_dev->dev.bus = &scmi_bus_type;\n\tscmi_dev->dev.release = scmi_device_release;\n\tdev_set_name(&scmi_dev->dev, \"scmi_dev.%d\", id);\n\n\tretval = device_register(&scmi_dev->dev);\n\tif (retval)\n\t\tgoto put_dev;\n\n\tpr_debug(\"(%s) Created SCMI device '%s' for protocol 0x%x (%s)\\n\",\n\t\t of_node_full_name(parent->of_node),\n\t\t dev_name(&scmi_dev->dev), protocol, name);\n\n\treturn scmi_dev;\nput_dev:\n\tkfree_const(scmi_dev->name);\n\tput_device(&scmi_dev->dev);\n\tida_free(&scmi_bus_id, id);\n\treturn NULL;\n}\n\n \nstruct scmi_device *scmi_device_create(struct device_node *np,\n\t\t\t\t       struct device *parent, int protocol,\n\t\t\t\t       const char *name)\n{\n\tstruct list_head *phead;\n\tstruct scmi_requested_dev *rdev;\n\tstruct scmi_device *scmi_dev = NULL;\n\n\tif (name)\n\t\treturn __scmi_device_create(np, parent, protocol, name);\n\n\tmutex_lock(&scmi_requested_devices_mtx);\n\tphead = idr_find(&scmi_requested_devices, protocol);\n\t \n\tif (!phead) {\n\t\tmutex_unlock(&scmi_requested_devices_mtx);\n\t\treturn NULL;\n\t}\n\n\t \n\tlist_for_each_entry(rdev, phead, node) {\n\t\tstruct scmi_device *sdev;\n\n\t\tsdev = __scmi_device_create(np, parent,\n\t\t\t\t\t    rdev->id_table->protocol_id,\n\t\t\t\t\t    rdev->id_table->name);\n\t\t \n\t\tif (sdev)\n\t\t\tscmi_dev = sdev;\n\t\telse\n\t\t\tpr_err(\"(%s) Failed to create device for protocol 0x%x (%s)\\n\",\n\t\t\t       of_node_full_name(parent->of_node),\n\t\t\t       rdev->id_table->protocol_id,\n\t\t\t       rdev->id_table->name);\n\t}\n\tmutex_unlock(&scmi_requested_devices_mtx);\n\n\treturn scmi_dev;\n}\nEXPORT_SYMBOL_GPL(scmi_device_create);\n\nvoid scmi_device_destroy(struct device *parent, int protocol, const char *name)\n{\n\tstruct scmi_device *scmi_dev;\n\n\tscmi_dev = scmi_child_dev_find(parent, protocol, name);\n\tif (scmi_dev)\n\t\t__scmi_device_destroy(scmi_dev);\n}\nEXPORT_SYMBOL_GPL(scmi_device_destroy);\n\nstatic int __scmi_devices_unregister(struct device *dev, void *data)\n{\n\tstruct scmi_device *scmi_dev = to_scmi_dev(dev);\n\n\t__scmi_device_destroy(scmi_dev);\n\treturn 0;\n}\n\nstatic void scmi_devices_unregister(void)\n{\n\tbus_for_each_dev(&scmi_bus_type, NULL, NULL, __scmi_devices_unregister);\n}\n\nstatic int __init scmi_bus_init(void)\n{\n\tint retval;\n\n\tretval = bus_register(&scmi_bus_type);\n\tif (retval)\n\t\tpr_err(\"SCMI protocol bus register failed (%d)\\n\", retval);\n\n\tpr_info(\"SCMI protocol bus registered\\n\");\n\n\treturn retval;\n}\nsubsys_initcall(scmi_bus_init);\n\nstatic void __exit scmi_bus_exit(void)\n{\n\t \n\tscmi_devices_unregister();\n\tbus_unregister(&scmi_bus_type);\n\tida_destroy(&scmi_bus_id);\n}\nmodule_exit(scmi_bus_exit);\n\nMODULE_ALIAS(\"scmi-core\");\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI protocol bus\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}