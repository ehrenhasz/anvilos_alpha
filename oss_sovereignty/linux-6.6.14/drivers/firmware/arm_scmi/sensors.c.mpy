{
  "module_name": "sensors.c",
  "hash_id": "84904360580d32f813115740ce5354a9370d8a381bf4125cbda713962cb99a0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/sensors.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications SENSOR - \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\n#define SCMI_MAX_NUM_SENSOR_AXIS\t63\n#define\tSCMIv2_SENSOR_PROTOCOL\t\t0x10000\n\nenum scmi_sensor_protocol_cmd {\n\tSENSOR_DESCRIPTION_GET = 0x3,\n\tSENSOR_TRIP_POINT_NOTIFY = 0x4,\n\tSENSOR_TRIP_POINT_CONFIG = 0x5,\n\tSENSOR_READING_GET = 0x6,\n\tSENSOR_AXIS_DESCRIPTION_GET = 0x7,\n\tSENSOR_LIST_UPDATE_INTERVALS = 0x8,\n\tSENSOR_CONFIG_GET = 0x9,\n\tSENSOR_CONFIG_SET = 0xA,\n\tSENSOR_CONTINUOUS_UPDATE_NOTIFY = 0xB,\n\tSENSOR_NAME_GET = 0xC,\n\tSENSOR_AXIS_NAME_GET = 0xD,\n};\n\nstruct scmi_msg_resp_sensor_attributes {\n\t__le16 num_sensors;\n\tu8 max_requests;\n\tu8 reserved;\n\t__le32 reg_addr_low;\n\t__le32 reg_addr_high;\n\t__le32 reg_size;\n};\n\n \n#define SUPPORTS_UPDATE_NOTIFY(x)\tFIELD_GET(BIT(30), (x))\n#define SENSOR_TSTAMP_EXP(x)\t\tFIELD_GET(GENMASK(14, 10), (x))\n#define SUPPORTS_TIMESTAMP(x)\t\tFIELD_GET(BIT(9), (x))\n#define SUPPORTS_EXTEND_ATTRS(x)\tFIELD_GET(BIT(8), (x))\n\n \n#define SENSOR_UPDATE_BASE(x)\t\tFIELD_GET(GENMASK(31, 27), (x))\n#define SENSOR_UPDATE_SCALE(x)\t\tFIELD_GET(GENMASK(26, 22), (x))\n\n \n#define SENSOR_AXIS_NUMBER(x)\t\tFIELD_GET(GENMASK(21, 16), (x))\n#define SUPPORTS_AXIS(x)\t\tFIELD_GET(BIT(8), (x))\n\n \n#define SENSOR_RES(x)\t\t\tFIELD_GET(GENMASK(26, 0), (x))\n#define SENSOR_RES_EXP(x)\t\tFIELD_GET(GENMASK(31, 27), (x))\n\nstruct scmi_msg_resp_attrs {\n\t__le32 min_range_low;\n\t__le32 min_range_high;\n\t__le32 max_range_low;\n\t__le32 max_range_high;\n};\n\nstruct scmi_msg_sensor_description {\n\t__le32 desc_index;\n};\n\nstruct scmi_msg_resp_sensor_description {\n\t__le16 num_returned;\n\t__le16 num_remaining;\n\tstruct scmi_sensor_descriptor {\n\t\t__le32 id;\n\t\t__le32 attributes_low;\n \n#define SUPPORTS_ASYNC_READ(x)\t\tFIELD_GET(BIT(31), (x))\n#define SUPPORTS_EXTENDED_NAMES(x)\tFIELD_GET(BIT(29), (x))\n#define NUM_TRIP_POINTS(x)\t\tFIELD_GET(GENMASK(7, 0), (x))\n\t\t__le32 attributes_high;\n \n#define SENSOR_SCALE(x)\t\t\tFIELD_GET(GENMASK(15, 11), (x))\n#define SENSOR_SCALE_SIGN\t\tBIT(4)\n#define SENSOR_SCALE_EXTEND\t\tGENMASK(31, 5)\n#define SENSOR_TYPE(x)\t\t\tFIELD_GET(GENMASK(7, 0), (x))\n\t\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n\t\t \n\t\t__le32 power;\n\t\t__le32 resolution;\n\t\tstruct scmi_msg_resp_attrs scalar_attrs;\n\t} desc[];\n};\n\n \n#define SCMI_MSG_RESP_SENS_DESCR_BASE_SZ\t28\n\n \n#define\tS32_EXT(v)\t\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint __v = (v);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (__v & SENSOR_SCALE_SIGN)\t\t\t\t\\\n\t\t\t__v |= SENSOR_SCALE_EXTEND;\t\t\t\\\n\t\t__v;\t\t\t\t\t\t\t\\\n\t})\n\nstruct scmi_msg_sensor_axis_description_get {\n\t__le32 id;\n\t__le32 axis_desc_index;\n};\n\nstruct scmi_msg_resp_sensor_axis_description {\n\t__le32 num_axis_flags;\n#define NUM_AXIS_RETURNED(x)\t\tFIELD_GET(GENMASK(5, 0), (x))\n#define NUM_AXIS_REMAINING(x)\t\tFIELD_GET(GENMASK(31, 26), (x))\n\tstruct scmi_axis_descriptor {\n\t\t__le32 id;\n\t\t__le32 attributes_low;\n#define SUPPORTS_EXTENDED_AXIS_NAMES(x)\tFIELD_GET(BIT(9), (x))\n\t\t__le32 attributes_high;\n\t\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n\t\t__le32 resolution;\n\t\tstruct scmi_msg_resp_attrs attrs;\n\t} desc[];\n};\n\nstruct scmi_msg_resp_sensor_axis_names_description {\n\t__le32 num_axis_flags;\n\tstruct scmi_sensor_axis_name_descriptor {\n\t\t__le32 axis_id;\n\t\tu8 name[SCMI_MAX_STR_SIZE];\n\t} desc[];\n};\n\n \n#define SCMI_MSG_RESP_AXIS_DESCR_BASE_SZ\t28\n\nstruct scmi_msg_sensor_list_update_intervals {\n\t__le32 id;\n\t__le32 index;\n};\n\nstruct scmi_msg_resp_sensor_list_update_intervals {\n\t__le32 num_intervals_flags;\n#define NUM_INTERVALS_RETURNED(x)\tFIELD_GET(GENMASK(11, 0), (x))\n#define SEGMENTED_INTVL_FORMAT(x)\tFIELD_GET(BIT(12), (x))\n#define NUM_INTERVALS_REMAINING(x)\tFIELD_GET(GENMASK(31, 16), (x))\n\t__le32 intervals[];\n};\n\nstruct scmi_msg_sensor_request_notify {\n\t__le32 id;\n\t__le32 event_control;\n#define SENSOR_NOTIFY_ALL\tBIT(0)\n};\n\nstruct scmi_msg_set_sensor_trip_point {\n\t__le32 id;\n\t__le32 event_control;\n#define SENSOR_TP_EVENT_MASK\t(0x3)\n#define SENSOR_TP_DISABLED\t0x0\n#define SENSOR_TP_POSITIVE\t0x1\n#define SENSOR_TP_NEGATIVE\t0x2\n#define SENSOR_TP_BOTH\t\t0x3\n#define SENSOR_TP_ID(x)\t\t(((x) & 0xff) << 4)\n\t__le32 value_low;\n\t__le32 value_high;\n};\n\nstruct scmi_msg_sensor_config_set {\n\t__le32 id;\n\t__le32 sensor_config;\n};\n\nstruct scmi_msg_sensor_reading_get {\n\t__le32 id;\n\t__le32 flags;\n#define SENSOR_READ_ASYNC\tBIT(0)\n};\n\nstruct scmi_resp_sensor_reading_complete {\n\t__le32 id;\n\t__le32 readings_low;\n\t__le32 readings_high;\n};\n\nstruct scmi_sensor_reading_resp {\n\t__le32 sensor_value_low;\n\t__le32 sensor_value_high;\n\t__le32 timestamp_low;\n\t__le32 timestamp_high;\n};\n\nstruct scmi_resp_sensor_reading_complete_v3 {\n\t__le32 id;\n\tstruct scmi_sensor_reading_resp readings[];\n};\n\nstruct scmi_sensor_trip_notify_payld {\n\t__le32 agent_id;\n\t__le32 sensor_id;\n\t__le32 trip_point_desc;\n};\n\nstruct scmi_sensor_update_notify_payld {\n\t__le32 agent_id;\n\t__le32 sensor_id;\n\tstruct scmi_sensor_reading_resp readings[];\n};\n\nstruct sensors_info {\n\tu32 version;\n\tint num_sensors;\n\tint max_requests;\n\tu64 reg_addr;\n\tu32 reg_size;\n\tstruct scmi_sensor_info *sensors;\n};\n\nstatic int scmi_sensor_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t      struct sensors_info *si)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_sensor_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES,\n\t\t\t\t      0, sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tsi->num_sensors = le16_to_cpu(attr->num_sensors);\n\t\tsi->max_requests = attr->max_requests;\n\t\tsi->reg_addr = le32_to_cpu(attr->reg_addr_low) |\n\t\t\t\t(u64)le32_to_cpu(attr->reg_addr_high) << 32;\n\t\tsi->reg_size = le32_to_cpu(attr->reg_size);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic inline void scmi_parse_range_attrs(struct scmi_range_attrs *out,\n\t\t\t\t\t  const struct scmi_msg_resp_attrs *in)\n{\n\tout->min_range = get_unaligned_le64((void *)&in->min_range_low);\n\tout->max_range = get_unaligned_le64((void *)&in->max_range_low);\n}\n\nstruct scmi_sens_ipriv {\n\tvoid *priv;\n\tstruct device *dev;\n};\n\nstatic void iter_intervals_prepare_message(void *message,\n\t\t\t\t\t   unsigned int desc_index,\n\t\t\t\t\t   const void *p)\n{\n\tstruct scmi_msg_sensor_list_update_intervals *msg = message;\n\tconst struct scmi_sensor_info *s;\n\n\ts = ((const struct scmi_sens_ipriv *)p)->priv;\n\t \n\tmsg->id = cpu_to_le32(s->id);\n\tmsg->index = cpu_to_le32(desc_index);\n}\n\nstatic int iter_intervals_update_state(struct scmi_iterator_state *st,\n\t\t\t\t       const void *response, void *p)\n{\n\tu32 flags;\n\tstruct scmi_sensor_info *s = ((struct scmi_sens_ipriv *)p)->priv;\n\tstruct device *dev = ((struct scmi_sens_ipriv *)p)->dev;\n\tconst struct scmi_msg_resp_sensor_list_update_intervals *r = response;\n\n\tflags = le32_to_cpu(r->num_intervals_flags);\n\tst->num_returned = NUM_INTERVALS_RETURNED(flags);\n\tst->num_remaining = NUM_INTERVALS_REMAINING(flags);\n\n\t \n\tif (!st->max_resources) {\n\t\ts->intervals.segmented = SEGMENTED_INTVL_FORMAT(flags);\n\t\ts->intervals.count = st->num_returned + st->num_remaining;\n\t\t \n\t\tif (s->intervals.segmented &&\n\t\t    (st->num_remaining || st->num_returned != 3)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Sensor ID:%d advertises an invalid segmented interval (%d)\\n\",\n\t\t\t\ts->id, s->intervals.count);\n\t\t\ts->intervals.segmented = false;\n\t\t\ts->intervals.count = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (s->intervals.count >= SCMI_MAX_PREALLOC_POOL) {\n\t\t\ts->intervals.desc =\n\t\t\t\tdevm_kcalloc(dev,\n\t\t\t\t\t     s->intervals.count,\n\t\t\t\t\t     sizeof(*s->intervals.desc),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!s->intervals.desc) {\n\t\t\t\ts->intervals.segmented = false;\n\t\t\t\ts->intervals.count = 0;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tst->max_resources = s->intervals.count;\n\t}\n\n\treturn 0;\n}\n\nstatic int\niter_intervals_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\tconst void *response,\n\t\t\t\tstruct scmi_iterator_state *st, void *p)\n{\n\tconst struct scmi_msg_resp_sensor_list_update_intervals *r = response;\n\tstruct scmi_sensor_info *s = ((struct scmi_sens_ipriv *)p)->priv;\n\n\ts->intervals.desc[st->desc_index + st->loop_idx] =\n\t\tle32_to_cpu(r->intervals[st->loop_idx]);\n\n\treturn 0;\n}\n\nstatic int scmi_sensor_update_intervals(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tstruct scmi_sensor_info *s)\n{\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_intervals_prepare_message,\n\t\t.update_state = iter_intervals_update_state,\n\t\t.process_response = iter_intervals_process_response,\n\t};\n\tstruct scmi_sens_ipriv upriv = {\n\t\t.priv = s,\n\t\t.dev = ph->dev,\n\t};\n\n\titer = ph->hops->iter_response_init(ph, &ops, s->intervals.count,\n\t\t\t\t\t    SENSOR_LIST_UPDATE_INTERVALS,\n\t\t\t\t\t    sizeof(struct scmi_msg_sensor_list_update_intervals),\n\t\t\t\t\t    &upriv);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\treturn ph->hops->iter_response_run(iter);\n}\n\nstruct scmi_apriv {\n\tbool any_axes_support_extended_names;\n\tstruct scmi_sensor_info *s;\n};\n\nstatic void iter_axes_desc_prepare_message(void *message,\n\t\t\t\t\t   const unsigned int desc_index,\n\t\t\t\t\t   const void *priv)\n{\n\tstruct scmi_msg_sensor_axis_description_get *msg = message;\n\tconst struct scmi_apriv *apriv = priv;\n\n\t \n\tmsg->id = cpu_to_le32(apriv->s->id);\n\tmsg->axis_desc_index = cpu_to_le32(desc_index);\n}\n\nstatic int\niter_axes_desc_update_state(struct scmi_iterator_state *st,\n\t\t\t    const void *response, void *priv)\n{\n\tu32 flags;\n\tconst struct scmi_msg_resp_sensor_axis_description *r = response;\n\n\tflags = le32_to_cpu(r->num_axis_flags);\n\tst->num_returned = NUM_AXIS_RETURNED(flags);\n\tst->num_remaining = NUM_AXIS_REMAINING(flags);\n\tst->priv = (void *)&r->desc[0];\n\n\treturn 0;\n}\n\nstatic int\niter_axes_desc_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\tconst void *response,\n\t\t\t\tstruct scmi_iterator_state *st, void *priv)\n{\n\tu32 attrh, attrl;\n\tstruct scmi_sensor_axis_info *a;\n\tsize_t dsize = SCMI_MSG_RESP_AXIS_DESCR_BASE_SZ;\n\tstruct scmi_apriv *apriv = priv;\n\tconst struct scmi_axis_descriptor *adesc = st->priv;\n\n\tattrl = le32_to_cpu(adesc->attributes_low);\n\tif (SUPPORTS_EXTENDED_AXIS_NAMES(attrl))\n\t\tapriv->any_axes_support_extended_names = true;\n\n\ta = &apriv->s->axis[st->desc_index + st->loop_idx];\n\ta->id = le32_to_cpu(adesc->id);\n\ta->extended_attrs = SUPPORTS_EXTEND_ATTRS(attrl);\n\n\tattrh = le32_to_cpu(adesc->attributes_high);\n\ta->scale = S32_EXT(SENSOR_SCALE(attrh));\n\ta->type = SENSOR_TYPE(attrh);\n\tstrscpy(a->name, adesc->name, SCMI_SHORT_NAME_MAX_SIZE);\n\n\tif (a->extended_attrs) {\n\t\tunsigned int ares = le32_to_cpu(adesc->resolution);\n\n\t\ta->resolution = SENSOR_RES(ares);\n\t\ta->exponent = S32_EXT(SENSOR_RES_EXP(ares));\n\t\tdsize += sizeof(adesc->resolution);\n\n\t\tscmi_parse_range_attrs(&a->attrs, &adesc->attrs);\n\t\tdsize += sizeof(adesc->attrs);\n\t}\n\tst->priv = ((u8 *)adesc + dsize);\n\n\treturn 0;\n}\n\nstatic int\niter_axes_extended_name_update_state(struct scmi_iterator_state *st,\n\t\t\t\t     const void *response, void *priv)\n{\n\tu32 flags;\n\tconst struct scmi_msg_resp_sensor_axis_names_description *r = response;\n\n\tflags = le32_to_cpu(r->num_axis_flags);\n\tst->num_returned = NUM_AXIS_RETURNED(flags);\n\tst->num_remaining = NUM_AXIS_REMAINING(flags);\n\tst->priv = (void *)&r->desc[0];\n\n\treturn 0;\n}\n\nstatic int\niter_axes_extended_name_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t const void *response,\n\t\t\t\t\t struct scmi_iterator_state *st,\n\t\t\t\t\t void *priv)\n{\n\tstruct scmi_sensor_axis_info *a;\n\tconst struct scmi_apriv *apriv = priv;\n\tstruct scmi_sensor_axis_name_descriptor *adesc = st->priv;\n\tu32 axis_id = le32_to_cpu(adesc->axis_id);\n\n\tif (axis_id >= st->max_resources)\n\t\treturn -EPROTO;\n\n\t \n\ta = &apriv->s->axis[axis_id];\n\tstrscpy(a->name, adesc->name, SCMI_MAX_STR_SIZE);\n\tst->priv = ++adesc;\n\n\treturn 0;\n}\n\nstatic int\nscmi_sensor_axis_extended_names_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t    struct scmi_sensor_info *s)\n{\n\tint ret;\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_axes_desc_prepare_message,\n\t\t.update_state = iter_axes_extended_name_update_state,\n\t\t.process_response = iter_axes_extended_name_process_response,\n\t};\n\tstruct scmi_apriv apriv = {\n\t\t.any_axes_support_extended_names = false,\n\t\t.s = s,\n\t};\n\n\titer = ph->hops->iter_response_init(ph, &ops, s->num_axis,\n\t\t\t\t\t    SENSOR_AXIS_NAME_GET,\n\t\t\t\t\t    sizeof(struct scmi_msg_sensor_axis_description_get),\n\t\t\t\t\t    &apriv);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\t \n\tret = ph->hops->iter_response_run(iter);\n\tif (ret)\n\t\tdev_warn(ph->dev,\n\t\t\t \"Failed to get axes extended names for %s (ret:%d).\\n\",\n\t\t\t s->name, ret);\n\n\treturn 0;\n}\n\nstatic int scmi_sensor_axis_description(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tstruct scmi_sensor_info *s,\n\t\t\t\t\tu32 version)\n{\n\tint ret;\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_axes_desc_prepare_message,\n\t\t.update_state = iter_axes_desc_update_state,\n\t\t.process_response = iter_axes_desc_process_response,\n\t};\n\tstruct scmi_apriv apriv = {\n\t\t.any_axes_support_extended_names = false,\n\t\t.s = s,\n\t};\n\n\ts->axis = devm_kcalloc(ph->dev, s->num_axis,\n\t\t\t       sizeof(*s->axis), GFP_KERNEL);\n\tif (!s->axis)\n\t\treturn -ENOMEM;\n\n\titer = ph->hops->iter_response_init(ph, &ops, s->num_axis,\n\t\t\t\t\t    SENSOR_AXIS_DESCRIPTION_GET,\n\t\t\t\t\t    sizeof(struct scmi_msg_sensor_axis_description_get),\n\t\t\t\t\t    &apriv);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\tret = ph->hops->iter_response_run(iter);\n\tif (ret)\n\t\treturn ret;\n\n\tif (PROTOCOL_REV_MAJOR(version) >= 0x3 &&\n\t    apriv.any_axes_support_extended_names)\n\t\tret = scmi_sensor_axis_extended_names_get(ph, s);\n\n\treturn ret;\n}\n\nstatic void iter_sens_descr_prepare_message(void *message,\n\t\t\t\t\t    unsigned int desc_index,\n\t\t\t\t\t    const void *priv)\n{\n\tstruct scmi_msg_sensor_description *msg = message;\n\n\tmsg->desc_index = cpu_to_le32(desc_index);\n}\n\nstatic int iter_sens_descr_update_state(struct scmi_iterator_state *st,\n\t\t\t\t\tconst void *response, void *priv)\n{\n\tconst struct scmi_msg_resp_sensor_description *r = response;\n\n\tst->num_returned = le16_to_cpu(r->num_returned);\n\tst->num_remaining = le16_to_cpu(r->num_remaining);\n\tst->priv = (void *)&r->desc[0];\n\n\treturn 0;\n}\n\nstatic int\niter_sens_descr_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\t const void *response,\n\t\t\t\t struct scmi_iterator_state *st, void *priv)\n\n{\n\tint ret = 0;\n\tu32 attrh, attrl;\n\tsize_t dsize = SCMI_MSG_RESP_SENS_DESCR_BASE_SZ;\n\tstruct scmi_sensor_info *s;\n\tstruct sensors_info *si = priv;\n\tconst struct scmi_sensor_descriptor *sdesc = st->priv;\n\n\ts = &si->sensors[st->desc_index + st->loop_idx];\n\ts->id = le32_to_cpu(sdesc->id);\n\n\tattrl = le32_to_cpu(sdesc->attributes_low);\n\t \n\ts->async = SUPPORTS_ASYNC_READ(attrl);\n\ts->num_trip_points = NUM_TRIP_POINTS(attrl);\n\t \n\ts->update = SUPPORTS_UPDATE_NOTIFY(attrl);\n\ts->timestamped = SUPPORTS_TIMESTAMP(attrl);\n\tif (s->timestamped)\n\t\ts->tstamp_scale = S32_EXT(SENSOR_TSTAMP_EXP(attrl));\n\ts->extended_scalar_attrs = SUPPORTS_EXTEND_ATTRS(attrl);\n\n\tattrh = le32_to_cpu(sdesc->attributes_high);\n\t \n\ts->scale = S32_EXT(SENSOR_SCALE(attrh));\n\ts->type = SENSOR_TYPE(attrh);\n\t \n\ts->intervals.desc = s->intervals.prealloc_pool;\n\tif (si->version == SCMIv2_SENSOR_PROTOCOL) {\n\t\ts->intervals.segmented = false;\n\t\ts->intervals.count = 1;\n\t\t \n\t\ts->intervals.desc[0] = (SENSOR_UPDATE_BASE(attrh) << 5) |\n\t\t\t\t\tSENSOR_UPDATE_SCALE(attrh);\n\t} else {\n\t\t \n\t\tif (scmi_sensor_update_intervals(ph, s))\n\t\t\tdev_dbg(ph->dev,\n\t\t\t\t\"Update Intervals not available for sensor ID:%d\\n\",\n\t\t\t\ts->id);\n\t}\n\t \n\ts->num_axis = min_t(unsigned int,\n\t\t\t    SUPPORTS_AXIS(attrh) ?\n\t\t\t    SENSOR_AXIS_NUMBER(attrh) : 0,\n\t\t\t    SCMI_MAX_NUM_SENSOR_AXIS);\n\tstrscpy(s->name, sdesc->name, SCMI_SHORT_NAME_MAX_SIZE);\n\n\t \n\tif (PROTOCOL_REV_MAJOR(si->version) >= 0x3 &&\n\t    SUPPORTS_EXTENDED_NAMES(attrl))\n\t\tph->hops->extended_name_get(ph, SENSOR_NAME_GET, s->id,\n\t\t\t\t\t    s->name, SCMI_MAX_STR_SIZE);\n\n\tif (s->extended_scalar_attrs) {\n\t\ts->sensor_power = le32_to_cpu(sdesc->power);\n\t\tdsize += sizeof(sdesc->power);\n\n\t\t \n\t\tif (s->num_axis == 0) {\n\t\t\tunsigned int sres = le32_to_cpu(sdesc->resolution);\n\n\t\t\ts->resolution = SENSOR_RES(sres);\n\t\t\ts->exponent = S32_EXT(SENSOR_RES_EXP(sres));\n\t\t\tdsize += sizeof(sdesc->resolution);\n\n\t\t\tscmi_parse_range_attrs(&s->scalar_attrs,\n\t\t\t\t\t       &sdesc->scalar_attrs);\n\t\t\tdsize += sizeof(sdesc->scalar_attrs);\n\t\t}\n\t}\n\n\tif (s->num_axis > 0)\n\t\tret = scmi_sensor_axis_description(ph, s, si->version);\n\n\tst->priv = ((u8 *)sdesc + dsize);\n\n\treturn ret;\n}\n\nstatic int scmi_sensor_description_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t       struct sensors_info *si)\n{\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_sens_descr_prepare_message,\n\t\t.update_state = iter_sens_descr_update_state,\n\t\t.process_response = iter_sens_descr_process_response,\n\t};\n\n\titer = ph->hops->iter_response_init(ph, &ops, si->num_sensors,\n\t\t\t\t\t    SENSOR_DESCRIPTION_GET,\n\t\t\t\t\t    sizeof(__le32), si);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\treturn ph->hops->iter_response_run(iter);\n}\n\nstatic inline int\nscmi_sensor_request_notify(const struct scmi_protocol_handle *ph, u32 sensor_id,\n\t\t\t   u8 message_id, bool enable)\n{\n\tint ret;\n\tu32 evt_cntl = enable ? SENSOR_NOTIFY_ALL : 0;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_sensor_request_notify *cfg;\n\n\tret = ph->xops->xfer_get_init(ph, message_id, sizeof(*cfg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = t->tx.buf;\n\tcfg->id = cpu_to_le32(sensor_id);\n\tcfg->event_control = cpu_to_le32(evt_cntl);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_sensor_trip_point_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u32 sensor_id, bool enable)\n{\n\treturn scmi_sensor_request_notify(ph, sensor_id,\n\t\t\t\t\t  SENSOR_TRIP_POINT_NOTIFY,\n\t\t\t\t\t  enable);\n}\n\nstatic int\nscmi_sensor_continuous_update_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\t     u32 sensor_id, bool enable)\n{\n\treturn scmi_sensor_request_notify(ph, sensor_id,\n\t\t\t\t\t  SENSOR_CONTINUOUS_UPDATE_NOTIFY,\n\t\t\t\t\t  enable);\n}\n\nstatic int\nscmi_sensor_trip_point_config(const struct scmi_protocol_handle *ph,\n\t\t\t      u32 sensor_id, u8 trip_id, u64 trip_value)\n{\n\tint ret;\n\tu32 evt_cntl = SENSOR_TP_BOTH;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_set_sensor_trip_point *trip;\n\n\tret = ph->xops->xfer_get_init(ph, SENSOR_TRIP_POINT_CONFIG,\n\t\t\t\t      sizeof(*trip), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\ttrip = t->tx.buf;\n\ttrip->id = cpu_to_le32(sensor_id);\n\ttrip->event_control = cpu_to_le32(evt_cntl | SENSOR_TP_ID(trip_id));\n\ttrip->value_low = cpu_to_le32(trip_value & 0xffffffff);\n\ttrip->value_high = cpu_to_le32(trip_value >> 32);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_sensor_config_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u32 sensor_id, u32 *sensor_config)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\tif (sensor_id >= si->num_sensors)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, SENSOR_CONFIG_GET,\n\t\t\t\t      sizeof(__le32), sizeof(__le32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(sensor_id, t->tx.buf);\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tstruct scmi_sensor_info *s = si->sensors + sensor_id;\n\n\t\t*sensor_config = get_unaligned_le64(t->rx.buf);\n\t\ts->sensor_config = *sensor_config;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_sensor_config_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u32 sensor_id, u32 sensor_config)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_sensor_config_set *msg;\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\tif (sensor_id >= si->num_sensors)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, SENSOR_CONFIG_SET,\n\t\t\t\t      sizeof(*msg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg = t->tx.buf;\n\tmsg->id = cpu_to_le32(sensor_id);\n\tmsg->sensor_config = cpu_to_le32(sensor_config);\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tstruct scmi_sensor_info *s = si->sensors + sensor_id;\n\n\t\ts->sensor_config = sensor_config;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\n \nstatic int scmi_sensor_reading_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t   u32 sensor_id, u64 *value)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_sensor_reading_get *sensor;\n\tstruct scmi_sensor_info *s;\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\tif (sensor_id >= si->num_sensors)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, SENSOR_READING_GET,\n\t\t\t\t      sizeof(*sensor), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor = t->tx.buf;\n\tsensor->id = cpu_to_le32(sensor_id);\n\ts = si->sensors + sensor_id;\n\tif (s->async) {\n\t\tsensor->flags = cpu_to_le32(SENSOR_READ_ASYNC);\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\t\tif (!ret) {\n\t\t\tstruct scmi_resp_sensor_reading_complete *resp;\n\n\t\t\tresp = t->rx.buf;\n\t\t\tif (le32_to_cpu(resp->id) == sensor_id)\n\t\t\t\t*value =\n\t\t\t\t\tget_unaligned_le64(&resp->readings_low);\n\t\t\telse\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t} else {\n\t\tsensor->flags = cpu_to_le32(0);\n\t\tret = ph->xops->do_xfer(ph, t);\n\t\tif (!ret)\n\t\t\t*value = get_unaligned_le64(t->rx.buf);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic inline void\nscmi_parse_sensor_readings(struct scmi_sensor_reading *out,\n\t\t\t   const struct scmi_sensor_reading_resp *in)\n{\n\tout->value = get_unaligned_le64((void *)&in->sensor_value_low);\n\tout->timestamp = get_unaligned_le64((void *)&in->timestamp_low);\n}\n\n \nstatic int\nscmi_sensor_reading_get_timestamped(const struct scmi_protocol_handle *ph,\n\t\t\t\t    u32 sensor_id, u8 count,\n\t\t\t\t    struct scmi_sensor_reading *readings)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_sensor_reading_get *sensor;\n\tstruct scmi_sensor_info *s;\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\tif (sensor_id >= si->num_sensors)\n\t\treturn -EINVAL;\n\n\ts = si->sensors + sensor_id;\n\tif (!count || !readings ||\n\t    (!s->num_axis && count > 1) || (s->num_axis && count > s->num_axis))\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, SENSOR_READING_GET,\n\t\t\t\t      sizeof(*sensor), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor = t->tx.buf;\n\tsensor->id = cpu_to_le32(sensor_id);\n\tif (s->async) {\n\t\tsensor->flags = cpu_to_le32(SENSOR_READ_ASYNC);\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\t\tif (!ret) {\n\t\t\tint i;\n\t\t\tstruct scmi_resp_sensor_reading_complete_v3 *resp;\n\n\t\t\tresp = t->rx.buf;\n\t\t\t \n\t\t\tif (le32_to_cpu(resp->id) == sensor_id)\n\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t\tscmi_parse_sensor_readings(&readings[i],\n\t\t\t\t\t\t\t\t   &resp->readings[i]);\n\t\t\telse\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t} else {\n\t\tsensor->flags = cpu_to_le32(0);\n\t\tret = ph->xops->do_xfer(ph, t);\n\t\tif (!ret) {\n\t\t\tint i;\n\t\t\tstruct scmi_sensor_reading_resp *resp_readings;\n\n\t\t\tresp_readings = t->rx.buf;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tscmi_parse_sensor_readings(&readings[i],\n\t\t\t\t\t\t\t   &resp_readings[i]);\n\t\t}\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic const struct scmi_sensor_info *\nscmi_sensor_info_get(const struct scmi_protocol_handle *ph, u32 sensor_id)\n{\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\tif (sensor_id >= si->num_sensors)\n\t\treturn NULL;\n\n\treturn si->sensors + sensor_id;\n}\n\nstatic int scmi_sensor_count_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\treturn si->num_sensors;\n}\n\nstatic const struct scmi_sensor_proto_ops sensor_proto_ops = {\n\t.count_get = scmi_sensor_count_get,\n\t.info_get = scmi_sensor_info_get,\n\t.trip_point_config = scmi_sensor_trip_point_config,\n\t.reading_get = scmi_sensor_reading_get,\n\t.reading_get_timestamped = scmi_sensor_reading_get_timestamped,\n\t.config_get = scmi_sensor_config_get,\n\t.config_set = scmi_sensor_config_set,\n};\n\nstatic int scmi_sensor_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t  u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret;\n\n\tswitch (evt_id) {\n\tcase SCMI_EVENT_SENSOR_TRIP_POINT_EVENT:\n\t\tret = scmi_sensor_trip_point_notify(ph, src_id, enable);\n\t\tbreak;\n\tcase SCMI_EVENT_SENSOR_UPDATE:\n\t\tret = scmi_sensor_continuous_update_notify(ph, src_id, enable);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLED - evt[%X] dom[%d] - ret:%d\\n\",\n\t\t\t evt_id, src_id, ret);\n\n\treturn ret;\n}\n\nstatic void *\nscmi_sensor_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t       u8 evt_id, ktime_t timestamp,\n\t\t\t       const void *payld, size_t payld_sz,\n\t\t\t       void *report, u32 *src_id)\n{\n\tvoid *rep = NULL;\n\n\tswitch (evt_id) {\n\tcase SCMI_EVENT_SENSOR_TRIP_POINT_EVENT:\n\t{\n\t\tconst struct scmi_sensor_trip_notify_payld *p = payld;\n\t\tstruct scmi_sensor_trip_point_report *r = report;\n\n\t\tif (sizeof(*p) != payld_sz)\n\t\t\tbreak;\n\n\t\tr->timestamp = timestamp;\n\t\tr->agent_id = le32_to_cpu(p->agent_id);\n\t\tr->sensor_id = le32_to_cpu(p->sensor_id);\n\t\tr->trip_point_desc = le32_to_cpu(p->trip_point_desc);\n\t\t*src_id = r->sensor_id;\n\t\trep = r;\n\t\tbreak;\n\t}\n\tcase SCMI_EVENT_SENSOR_UPDATE:\n\t{\n\t\tint i;\n\t\tstruct scmi_sensor_info *s;\n\t\tconst struct scmi_sensor_update_notify_payld *p = payld;\n\t\tstruct scmi_sensor_update_report *r = report;\n\t\tstruct sensors_info *sinfo = ph->get_priv(ph);\n\n\t\t \n\t\tr->sensor_id = le32_to_cpu(p->sensor_id);\n\t\tif (r->sensor_id >= sinfo->num_sensors)\n\t\t\tbreak;\n\t\tr->timestamp = timestamp;\n\t\tr->agent_id = le32_to_cpu(p->agent_id);\n\t\ts = &sinfo->sensors[r->sensor_id];\n\t\t \n\t\tr->readings_count = s->num_axis ?: 1;\n\t\tfor (i = 0; i < r->readings_count; i++)\n\t\t\tscmi_parse_sensor_readings(&r->readings[i],\n\t\t\t\t\t\t   &p->readings[i]);\n\t\t*src_id = r->sensor_id;\n\t\trep = r;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rep;\n}\n\nstatic int scmi_sensor_get_num_sources(const struct scmi_protocol_handle *ph)\n{\n\tstruct sensors_info *si = ph->get_priv(ph);\n\n\treturn si->num_sensors;\n}\n\nstatic const struct scmi_event sensor_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_SENSOR_TRIP_POINT_EVENT,\n\t\t.max_payld_sz = sizeof(struct scmi_sensor_trip_notify_payld),\n\t\t.max_report_sz = sizeof(struct scmi_sensor_trip_point_report),\n\t},\n\t{\n\t\t.id = SCMI_EVENT_SENSOR_UPDATE,\n\t\t.max_payld_sz =\n\t\t\tsizeof(struct scmi_sensor_update_notify_payld) +\n\t\t\t SCMI_MAX_NUM_SENSOR_AXIS *\n\t\t\t sizeof(struct scmi_sensor_reading_resp),\n\t\t.max_report_sz = sizeof(struct scmi_sensor_update_report) +\n\t\t\t\t  SCMI_MAX_NUM_SENSOR_AXIS *\n\t\t\t\t  sizeof(struct scmi_sensor_reading),\n\t},\n};\n\nstatic const struct scmi_event_ops sensor_event_ops = {\n\t.get_num_sources = scmi_sensor_get_num_sources,\n\t.set_notify_enabled = scmi_sensor_set_notify_enabled,\n\t.fill_custom_report = scmi_sensor_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events sensor_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &sensor_event_ops,\n\t.evts = sensor_events,\n\t.num_events = ARRAY_SIZE(sensor_events),\n};\n\nstatic int scmi_sensors_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tu32 version;\n\tint ret;\n\tstruct sensors_info *sinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Sensor Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tsinfo = devm_kzalloc(ph->dev, sizeof(*sinfo), GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn -ENOMEM;\n\tsinfo->version = version;\n\n\tret = scmi_sensor_attributes_get(ph, sinfo);\n\tif (ret)\n\t\treturn ret;\n\tsinfo->sensors = devm_kcalloc(ph->dev, sinfo->num_sensors,\n\t\t\t\t      sizeof(*sinfo->sensors), GFP_KERNEL);\n\tif (!sinfo->sensors)\n\t\treturn -ENOMEM;\n\n\tret = scmi_sensor_description_get(ph, sinfo);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ph->set_priv(ph, sinfo);\n}\n\nstatic const struct scmi_protocol scmi_sensors = {\n\t.id = SCMI_PROTOCOL_SENSOR,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_sensors_protocol_init,\n\t.ops = &sensor_proto_ops,\n\t.events = &sensor_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(sensors, scmi_sensors)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}