{
  "module_name": "voltage.c",
  "hash_id": "d0cfa621e0f0f9744d393dfd395e3c29412e7abd4ccd5b685243e9caad86ea05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/voltage.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"protocols.h\"\n\n#define VOLTAGE_DOMS_NUM_MASK\t\tGENMASK(15, 0)\n#define REMAINING_LEVELS_MASK\t\tGENMASK(31, 16)\n#define RETURNED_LEVELS_MASK\t\tGENMASK(11, 0)\n\nenum scmi_voltage_protocol_cmd {\n\tVOLTAGE_DOMAIN_ATTRIBUTES = 0x3,\n\tVOLTAGE_DESCRIBE_LEVELS = 0x4,\n\tVOLTAGE_CONFIG_SET = 0x5,\n\tVOLTAGE_CONFIG_GET = 0x6,\n\tVOLTAGE_LEVEL_SET = 0x7,\n\tVOLTAGE_LEVEL_GET = 0x8,\n\tVOLTAGE_DOMAIN_NAME_GET = 0x09,\n};\n\n#define NUM_VOLTAGE_DOMAINS(x)\t((u16)(FIELD_GET(VOLTAGE_DOMS_NUM_MASK, (x))))\n\nstruct scmi_msg_resp_domain_attributes {\n\t__le32 attr;\n#define SUPPORTS_ASYNC_LEVEL_SET(x)\t((x) & BIT(31))\n#define SUPPORTS_EXTENDED_NAMES(x)\t((x) & BIT(30))\n\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n};\n\nstruct scmi_msg_cmd_describe_levels {\n\t__le32 domain_id;\n\t__le32 level_index;\n};\n\nstruct scmi_msg_resp_describe_levels {\n\t__le32 flags;\n#define NUM_REMAINING_LEVELS(f)\t((u16)(FIELD_GET(REMAINING_LEVELS_MASK, (f))))\n#define NUM_RETURNED_LEVELS(f)\t((u16)(FIELD_GET(RETURNED_LEVELS_MASK, (f))))\n#define SUPPORTS_SEGMENTED_LEVELS(f)\t((f) & BIT(12))\n\t__le32 voltage[];\n};\n\nstruct scmi_msg_cmd_config_set {\n\t__le32 domain_id;\n\t__le32 config;\n};\n\nstruct scmi_msg_cmd_level_set {\n\t__le32 domain_id;\n\t__le32 flags;\n\t__le32 voltage_level;\n};\n\nstruct scmi_resp_voltage_level_set_complete {\n\t__le32 domain_id;\n\t__le32 voltage_level;\n};\n\nstruct voltage_info {\n\tunsigned int version;\n\tunsigned int num_domains;\n\tstruct scmi_voltage_info *domains;\n};\n\nstatic int scmi_protocol_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tstruct voltage_info *vinfo)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES, 0,\n\t\t\t\t      sizeof(__le32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\tvinfo->num_domains =\n\t\t\tNUM_VOLTAGE_DOMAINS(get_unaligned_le32(t->rx.buf));\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_init_voltage_levels(struct device *dev,\n\t\t\t\t    struct scmi_voltage_info *v,\n\t\t\t\t    u32 num_returned, u32 num_remaining,\n\t\t\t\t    bool segmented)\n{\n\tu32 num_levels;\n\n\tnum_levels = num_returned + num_remaining;\n\t \n\tif (!num_levels ||\n\t    (segmented && (num_remaining || num_returned != 3))) {\n\t\tdev_err(dev,\n\t\t\t\"Invalid level descriptor(%d/%d/%d) for voltage dom %d\\n\",\n\t\t\tnum_levels, num_returned, num_remaining, v->id);\n\t\treturn -EINVAL;\n\t}\n\n\tv->levels_uv = devm_kcalloc(dev, num_levels, sizeof(u32), GFP_KERNEL);\n\tif (!v->levels_uv)\n\t\treturn -ENOMEM;\n\n\tv->num_levels = num_levels;\n\tv->segmented = segmented;\n\n\treturn 0;\n}\n\nstruct scmi_volt_ipriv {\n\tstruct device *dev;\n\tstruct scmi_voltage_info *v;\n};\n\nstatic void iter_volt_levels_prepare_message(void *message,\n\t\t\t\t\t     unsigned int desc_index,\n\t\t\t\t\t     const void *priv)\n{\n\tstruct scmi_msg_cmd_describe_levels *msg = message;\n\tconst struct scmi_volt_ipriv *p = priv;\n\n\tmsg->domain_id = cpu_to_le32(p->v->id);\n\tmsg->level_index = cpu_to_le32(desc_index);\n}\n\nstatic int iter_volt_levels_update_state(struct scmi_iterator_state *st,\n\t\t\t\t\t const void *response, void *priv)\n{\n\tint ret = 0;\n\tu32 flags;\n\tconst struct scmi_msg_resp_describe_levels *r = response;\n\tstruct scmi_volt_ipriv *p = priv;\n\n\tflags = le32_to_cpu(r->flags);\n\tst->num_returned = NUM_RETURNED_LEVELS(flags);\n\tst->num_remaining = NUM_REMAINING_LEVELS(flags);\n\n\t \n\tif (!p->v->num_levels) {\n\t\tret = scmi_init_voltage_levels(p->dev, p->v, st->num_returned,\n\t\t\t\t\t       st->num_remaining,\n\t\t\t\t\t      SUPPORTS_SEGMENTED_LEVELS(flags));\n\t\tif (!ret)\n\t\t\tst->max_resources = p->v->num_levels;\n\t}\n\n\treturn ret;\n}\n\nstatic int\niter_volt_levels_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\t  const void *response,\n\t\t\t\t  struct scmi_iterator_state *st, void *priv)\n{\n\ts32 val;\n\tconst struct scmi_msg_resp_describe_levels *r = response;\n\tstruct scmi_volt_ipriv *p = priv;\n\n\tval = (s32)le32_to_cpu(r->voltage[st->loop_idx]);\n\tp->v->levels_uv[st->desc_index + st->loop_idx] = val;\n\tif (val < 0)\n\t\tp->v->negative_volts_allowed = true;\n\n\treturn 0;\n}\n\nstatic int scmi_voltage_levels_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t   struct scmi_voltage_info *v)\n{\n\tint ret;\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_volt_levels_prepare_message,\n\t\t.update_state = iter_volt_levels_update_state,\n\t\t.process_response = iter_volt_levels_process_response,\n\t};\n\tstruct scmi_volt_ipriv vpriv = {\n\t\t.dev = ph->dev,\n\t\t.v = v,\n\t};\n\n\titer = ph->hops->iter_response_init(ph, &ops, v->num_levels,\n\t\t\t\t\t    VOLTAGE_DESCRIBE_LEVELS,\n\t\t\t\t\t    sizeof(struct scmi_msg_cmd_describe_levels),\n\t\t\t\t\t    &vpriv);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\tret = ph->hops->iter_response_run(iter);\n\tif (ret) {\n\t\tv->num_levels = 0;\n\t\tdevm_kfree(ph->dev, v->levels_uv);\n\t}\n\n\treturn ret;\n}\n\nstatic int scmi_voltage_descriptors_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t\tstruct voltage_info *vinfo)\n{\n\tint ret, dom;\n\tstruct scmi_xfer *td;\n\tstruct scmi_msg_resp_domain_attributes *resp_dom;\n\n\tret = ph->xops->xfer_get_init(ph, VOLTAGE_DOMAIN_ATTRIBUTES,\n\t\t\t\t      sizeof(__le32), sizeof(*resp_dom), &td);\n\tif (ret)\n\t\treturn ret;\n\tresp_dom = td->rx.buf;\n\n\tfor (dom = 0; dom < vinfo->num_domains; dom++) {\n\t\tu32 attributes;\n\t\tstruct scmi_voltage_info *v;\n\n\t\t \n\t\tput_unaligned_le32(dom, td->tx.buf);\n\t\t \n\t\tif (ph->xops->do_xfer(ph, td))\n\t\t\tcontinue;\n\n\t\tv = vinfo->domains + dom;\n\t\tv->id = dom;\n\t\tattributes = le32_to_cpu(resp_dom->attr);\n\t\tstrscpy(v->name, resp_dom->name, SCMI_SHORT_NAME_MAX_SIZE);\n\n\t\t \n\t\tif (PROTOCOL_REV_MAJOR(vinfo->version) >= 0x2) {\n\t\t\tif (SUPPORTS_EXTENDED_NAMES(attributes))\n\t\t\t\tph->hops->extended_name_get(ph,\n\t\t\t\t\t\t\tVOLTAGE_DOMAIN_NAME_GET,\n\t\t\t\t\t\t\tv->id, v->name,\n\t\t\t\t\t\t\tSCMI_MAX_STR_SIZE);\n\t\t\tif (SUPPORTS_ASYNC_LEVEL_SET(attributes))\n\t\t\t\tv->async_level_set = true;\n\t\t}\n\n\t\t \n\t\tscmi_voltage_levels_get(ph, v);\n\t}\n\n\tph->xops->xfer_put(ph, td);\n\n\treturn ret;\n}\n\nstatic int __scmi_voltage_get_u32(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u8 cmd_id, u32 domain_id, u32 *value)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct voltage_info *vinfo = ph->get_priv(ph);\n\n\tif (domain_id >= vinfo->num_domains)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, cmd_id, sizeof(__le32), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain_id, t->tx.buf);\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\t*value = get_unaligned_le32(t->rx.buf);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_voltage_config_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t   u32 domain_id, u32 config)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct voltage_info *vinfo = ph->get_priv(ph);\n\tstruct scmi_msg_cmd_config_set *cmd;\n\n\tif (domain_id >= vinfo->num_domains)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, VOLTAGE_CONFIG_SET,\n\t\t\t\t     sizeof(*cmd), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = t->tx.buf;\n\tcmd->domain_id = cpu_to_le32(domain_id);\n\tcmd->config = cpu_to_le32(config & GENMASK(3, 0));\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_voltage_config_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t   u32 domain_id, u32 *config)\n{\n\treturn __scmi_voltage_get_u32(ph, VOLTAGE_CONFIG_GET,\n\t\t\t\t      domain_id, config);\n}\n\nstatic int scmi_voltage_level_set(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u32 domain_id,\n\t\t\t\t  enum scmi_voltage_level_mode mode,\n\t\t\t\t  s32 volt_uV)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct voltage_info *vinfo = ph->get_priv(ph);\n\tstruct scmi_msg_cmd_level_set *cmd;\n\tstruct scmi_voltage_info *v;\n\n\tif (domain_id >= vinfo->num_domains)\n\t\treturn -EINVAL;\n\n\tret = ph->xops->xfer_get_init(ph, VOLTAGE_LEVEL_SET,\n\t\t\t\t      sizeof(*cmd), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tv = vinfo->domains + domain_id;\n\n\tcmd = t->tx.buf;\n\tcmd->domain_id = cpu_to_le32(domain_id);\n\tcmd->voltage_level = cpu_to_le32(volt_uV);\n\n\tif (!v->async_level_set || mode != SCMI_VOLTAGE_LEVEL_SET_AUTO) {\n\t\tcmd->flags = cpu_to_le32(0x0);\n\t\tret = ph->xops->do_xfer(ph, t);\n\t} else {\n\t\tcmd->flags = cpu_to_le32(0x1);\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\t\tif (!ret) {\n\t\t\tstruct scmi_resp_voltage_level_set_complete *resp;\n\n\t\t\tresp = t->rx.buf;\n\t\t\tif (le32_to_cpu(resp->domain_id) == domain_id)\n\t\t\t\tdev_dbg(ph->dev,\n\t\t\t\t\t\"Voltage domain %d set async to %d\\n\",\n\t\t\t\t\tv->id,\n\t\t\t\t\tle32_to_cpu(resp->voltage_level));\n\t\t\telse\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_voltage_level_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t  u32 domain_id, s32 *volt_uV)\n{\n\treturn __scmi_voltage_get_u32(ph, VOLTAGE_LEVEL_GET,\n\t\t\t\t      domain_id, (u32 *)volt_uV);\n}\n\nstatic const struct scmi_voltage_info * __must_check\nscmi_voltage_info_get(const struct scmi_protocol_handle *ph, u32 domain_id)\n{\n\tstruct voltage_info *vinfo = ph->get_priv(ph);\n\n\tif (domain_id >= vinfo->num_domains ||\n\t    !vinfo->domains[domain_id].num_levels)\n\t\treturn NULL;\n\n\treturn vinfo->domains + domain_id;\n}\n\nstatic int scmi_voltage_domains_num_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct voltage_info *vinfo = ph->get_priv(ph);\n\n\treturn vinfo->num_domains;\n}\n\nstatic struct scmi_voltage_proto_ops voltage_proto_ops = {\n\t.num_domains_get = scmi_voltage_domains_num_get,\n\t.info_get = scmi_voltage_info_get,\n\t.config_set = scmi_voltage_config_set,\n\t.config_get = scmi_voltage_config_get,\n\t.level_set = scmi_voltage_level_set,\n\t.level_get = scmi_voltage_level_get,\n};\n\nstatic int scmi_voltage_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint ret;\n\tu32 version;\n\tstruct voltage_info *vinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Voltage Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tvinfo = devm_kzalloc(ph->dev, sizeof(*vinfo), GFP_KERNEL);\n\tif (!vinfo)\n\t\treturn -ENOMEM;\n\tvinfo->version = version;\n\n\tret = scmi_protocol_attributes_get(ph, vinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vinfo->num_domains) {\n\t\tvinfo->domains = devm_kcalloc(ph->dev, vinfo->num_domains,\n\t\t\t\t\t      sizeof(*vinfo->domains),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!vinfo->domains)\n\t\t\treturn -ENOMEM;\n\t\tret = scmi_voltage_descriptors_get(ph, vinfo);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_warn(ph->dev, \"No Voltage domains found.\\n\");\n\t}\n\n\treturn ph->set_priv(ph, vinfo);\n}\n\nstatic const struct scmi_protocol scmi_voltage = {\n\t.id = SCMI_PROTOCOL_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_voltage_protocol_init,\n\t.ops = &voltage_proto_ops,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(voltage, scmi_voltage)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}