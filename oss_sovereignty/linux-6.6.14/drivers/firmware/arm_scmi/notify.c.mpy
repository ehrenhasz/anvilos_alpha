{
  "module_name": "notify.c",
  "hash_id": "b28df13ae13ae431e646b83fa3b83a9cd06609ba52dff46c8ed54e90006fd9a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/notify.c",
  "human_readable_source": "\n \n \n\n#define dev_fmt(fmt) \"SCMI Notifications - \" fmt\n#define pr_fmt(fmt) \"SCMI Notifications - \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/bug.h>\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/hashtable.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/kfifo.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/refcount.h>\n#include <linux/scmi_protocol.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include \"common.h\"\n#include \"notify.h\"\n\n#define SCMI_MAX_PROTO\t\t256\n\n#define PROTO_ID_MASK\t\tGENMASK(31, 24)\n#define EVT_ID_MASK\t\tGENMASK(23, 16)\n#define SRC_ID_MASK\t\tGENMASK(15, 0)\n\n \n#define MAKE_HASH_KEY(p, e, s)\t\t\t\\\n\t(FIELD_PREP(PROTO_ID_MASK, (p)) |\t\\\n\t   FIELD_PREP(EVT_ID_MASK, (e)) |\t\\\n\t   FIELD_PREP(SRC_ID_MASK, (s)))\n\n#define MAKE_ALL_SRCS_KEY(p, e)\t\tMAKE_HASH_KEY((p), (e), SRC_ID_MASK)\n\n \n#define KEY_FIND(__ht, __obj, __k)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\ttypeof(__k) k_ = __k;\t\t\t\t\t\\\n\ttypeof(__obj) obj_;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\thash_for_each_possible((__ht), obj_, hash, k_)\t\t\\\n\t\tif (obj_->key == k_)\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t__obj = obj_;\t\t\t\t\t\t\\\n})\n\n#define KEY_XTRACT_PROTO_ID(key)\tFIELD_GET(PROTO_ID_MASK, (key))\n#define KEY_XTRACT_EVT_ID(key)\t\tFIELD_GET(EVT_ID_MASK, (key))\n#define KEY_XTRACT_SRC_ID(key)\t\tFIELD_GET(SRC_ID_MASK, (key))\n\n \n#define SCMI_GET_PROTO(__ni, __pid)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(__ni) ni_ = __ni;\t\t\t\t\t\\\n\tstruct scmi_registered_events_desc *__pd = NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ni_)\t\t\t\t\t\t\t\\\n\t\t__pd = READ_ONCE(ni_->registered_protocols[(__pid)]);\t\\\n\t__pd;\t\t\t\t\t\t\t\t\\\n})\n\n#define SCMI_GET_REVT_FROM_PD(__pd, __eid)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(__pd) pd_ = __pd;\t\t\t\t\t\\\n\ttypeof(__eid) eid_ = __eid;\t\t\t\t\t\\\n\tstruct scmi_registered_event *__revt = NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (pd_ && eid_ < pd_->num_events)\t\t\t\t\\\n\t\t__revt = READ_ONCE(pd_->registered_events[eid_]);\t\\\n\t__revt;\t\t\t\t\t\t\t\t\\\n})\n\n#define SCMI_GET_REVT(__ni, __pid, __eid)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct scmi_registered_event *__revt;\t\t\t\t\\\n\tstruct scmi_registered_events_desc *__pd;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__pd = SCMI_GET_PROTO((__ni), (__pid));\t\t\t\t\\\n\t__revt = SCMI_GET_REVT_FROM_PD(__pd, (__eid));\t\t\t\\\n\t__revt;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define REVT_NOTIFY_SET_STATUS(revt, eid, sid, state)\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\ttypeof(revt) r = revt;\t\t\t\t\t\\\n\tr->proto->ops->set_notify_enabled(r->proto->ph,\t\t\\\n\t\t\t\t\t(eid), (sid), (state));\t\\\n})\n\n#define REVT_NOTIFY_ENABLE(revt, eid, sid)\t\t\t\\\n\tREVT_NOTIFY_SET_STATUS((revt), (eid), (sid), true)\n\n#define REVT_NOTIFY_DISABLE(revt, eid, sid)\t\t\t\\\n\tREVT_NOTIFY_SET_STATUS((revt), (eid), (sid), false)\n\n#define REVT_FILL_REPORT(revt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\ttypeof(revt) r = revt;\t\t\t\t\t\\\n\tr->proto->ops->fill_custom_report(r->proto->ph,\t\t\\\n\t\t\t\t\t  __VA_ARGS__);\t\t\\\n})\n\n#define SCMI_PENDING_HASH_SZ\t\t4\n#define SCMI_REGISTERED_HASH_SZ\t\t6\n\nstruct scmi_registered_events_desc;\n\n \nstruct scmi_notify_instance {\n\tvoid\t\t\t*gid;\n\tstruct scmi_handle\t*handle;\n\tstruct work_struct\tinit_work;\n\tstruct workqueue_struct\t*notify_wq;\n\t \n\tstruct mutex\t\tpending_mtx;\n\tstruct scmi_registered_events_desc\t**registered_protocols;\n\tDECLARE_HASHTABLE(pending_events_handlers, SCMI_PENDING_HASH_SZ);\n};\n\n \nstruct events_queue {\n\tsize_t\t\t\tsz;\n\tstruct kfifo\t\tkfifo;\n\tstruct work_struct\tnotify_work;\n\tstruct workqueue_struct\t*wq;\n};\n\n \nstruct scmi_event_header {\n\tktime_t timestamp;\n\tsize_t payld_sz;\n\tunsigned char evt_id;\n\tunsigned char payld[];\n};\n\nstruct scmi_registered_event;\n\n \nstruct scmi_registered_events_desc {\n\tu8\t\t\t\tid;\n\tconst struct scmi_event_ops\t*ops;\n\tstruct events_queue\t\tequeue;\n\tstruct scmi_notify_instance\t*ni;\n\tstruct scmi_event_header\t*eh;\n\tsize_t\t\t\t\teh_sz;\n\tvoid\t\t\t\t*in_flight;\n\tint\t\t\t\tnum_events;\n\tstruct scmi_registered_event\t**registered_events;\n\t \n\tstruct mutex\t\t\tregistered_mtx;\n\tconst struct scmi_protocol_handle\t*ph;\n\tDECLARE_HASHTABLE(registered_events_handlers, SCMI_REGISTERED_HASH_SZ);\n};\n\n \nstruct scmi_registered_event {\n\tstruct scmi_registered_events_desc *proto;\n\tconst struct scmi_event\t*evt;\n\tvoid\t\t*report;\n\tu32\t\tnum_sources;\n\trefcount_t\t*sources;\n\t \n\tstruct mutex\tsources_mtx;\n};\n\n \nstruct scmi_event_handler {\n\tu32\t\t\t\tkey;\n\trefcount_t\t\t\tusers;\n\tstruct scmi_registered_event\t*r_evt;\n\tstruct blocking_notifier_head\tchain;\n\tstruct hlist_node\t\thash;\n\tbool\t\t\t\tenabled;\n};\n\n#define IS_HNDL_PENDING(hndl)\t(!(hndl)->r_evt)\n\nstatic struct scmi_event_handler *\nscmi_get_active_handler(struct scmi_notify_instance *ni, u32 evt_key);\nstatic void scmi_put_active_handler(struct scmi_notify_instance *ni,\n\t\t\t\t    struct scmi_event_handler *hndl);\nstatic bool scmi_put_handler_unlocked(struct scmi_notify_instance *ni,\n\t\t\t\t      struct scmi_event_handler *hndl);\n\n \nstatic inline void\nscmi_lookup_and_call_event_chain(struct scmi_notify_instance *ni,\n\t\t\t\t u32 evt_key, void *report)\n{\n\tint ret;\n\tstruct scmi_event_handler *hndl;\n\n\t \n\thndl = scmi_get_active_handler(ni, evt_key);\n\tif (!hndl)\n\t\treturn;\n\n\tret = blocking_notifier_call_chain(&hndl->chain,\n\t\t\t\t\t   KEY_XTRACT_EVT_ID(evt_key),\n\t\t\t\t\t   report);\n\t \n\tWARN_ON_ONCE(ret & NOTIFY_STOP_MASK);\n\n\tscmi_put_active_handler(ni, hndl);\n}\n\n \nstatic inline struct scmi_registered_event *\nscmi_process_event_header(struct events_queue *eq,\n\t\t\t  struct scmi_registered_events_desc *pd)\n{\n\tunsigned int outs;\n\tstruct scmi_registered_event *r_evt;\n\n\touts = kfifo_out(&eq->kfifo, pd->eh,\n\t\t\t sizeof(struct scmi_event_header));\n\tif (!outs)\n\t\treturn NULL;\n\tif (outs != sizeof(struct scmi_event_header)) {\n\t\tdev_err(pd->ni->handle->dev, \"corrupted EVT header. Flush.\\n\");\n\t\tkfifo_reset_out(&eq->kfifo);\n\t\treturn NULL;\n\t}\n\n\tr_evt = SCMI_GET_REVT_FROM_PD(pd, pd->eh->evt_id);\n\tif (!r_evt)\n\t\tr_evt = ERR_PTR(-EINVAL);\n\n\treturn r_evt;\n}\n\n \nstatic inline bool\nscmi_process_event_payload(struct events_queue *eq,\n\t\t\t   struct scmi_registered_events_desc *pd,\n\t\t\t   struct scmi_registered_event *r_evt)\n{\n\tu32 src_id, key;\n\tunsigned int outs;\n\tvoid *report = NULL;\n\n\touts = kfifo_out(&eq->kfifo, pd->eh->payld, pd->eh->payld_sz);\n\tif (!outs)\n\t\treturn false;\n\n\t \n\tpd->in_flight = NULL;\n\n\tif (outs != pd->eh->payld_sz) {\n\t\tdev_err(pd->ni->handle->dev, \"corrupted EVT Payload. Flush.\\n\");\n\t\tkfifo_reset_out(&eq->kfifo);\n\t\treturn false;\n\t}\n\n\tif (IS_ERR(r_evt)) {\n\t\tdev_warn(pd->ni->handle->dev,\n\t\t\t \"SKIP UNKNOWN EVT - proto:%X  evt:%d\\n\",\n\t\t\t pd->id, pd->eh->evt_id);\n\t\treturn true;\n\t}\n\n\treport = REVT_FILL_REPORT(r_evt, pd->eh->evt_id, pd->eh->timestamp,\n\t\t\t\t  pd->eh->payld, pd->eh->payld_sz,\n\t\t\t\t  r_evt->report, &src_id);\n\tif (!report) {\n\t\tdev_err(pd->ni->handle->dev,\n\t\t\t\"report not available - proto:%X  evt:%d\\n\",\n\t\t\tpd->id, pd->eh->evt_id);\n\t\treturn true;\n\t}\n\n\t \n\tkey = MAKE_ALL_SRCS_KEY(pd->id, pd->eh->evt_id);\n\tscmi_lookup_and_call_event_chain(pd->ni, key, report);\n\n\t \n\tkey = MAKE_HASH_KEY(pd->id, pd->eh->evt_id, src_id);\n\tscmi_lookup_and_call_event_chain(pd->ni, key, report);\n\n\treturn true;\n}\n\n \nstatic void scmi_events_dispatcher(struct work_struct *work)\n{\n\tstruct events_queue *eq;\n\tstruct scmi_registered_events_desc *pd;\n\tstruct scmi_registered_event *r_evt;\n\n\teq = container_of(work, struct events_queue, notify_work);\n\tpd = container_of(eq, struct scmi_registered_events_desc, equeue);\n\t \n\tdo {\n\t\tif (!pd->in_flight) {\n\t\t\tr_evt = scmi_process_event_header(eq, pd);\n\t\t\tif (!r_evt)\n\t\t\t\tbreak;\n\t\t\tpd->in_flight = r_evt;\n\t\t} else {\n\t\t\tr_evt = pd->in_flight;\n\t\t}\n\t} while (scmi_process_event_payload(eq, pd, r_evt));\n}\n\n \nint scmi_notify(const struct scmi_handle *handle, u8 proto_id, u8 evt_id,\n\t\tconst void *buf, size_t len, ktime_t ts)\n{\n\tstruct scmi_registered_event *r_evt;\n\tstruct scmi_event_header eh;\n\tstruct scmi_notify_instance *ni;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn 0;\n\n\tr_evt = SCMI_GET_REVT(ni, proto_id, evt_id);\n\tif (!r_evt)\n\t\treturn -EINVAL;\n\n\tif (len > r_evt->evt->max_payld_sz) {\n\t\tdev_err(handle->dev, \"discard badly sized message\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (kfifo_avail(&r_evt->proto->equeue.kfifo) < sizeof(eh) + len) {\n\t\tdev_warn(handle->dev,\n\t\t\t \"queue full, dropping proto_id:%d  evt_id:%d  ts:%lld\\n\",\n\t\t\t proto_id, evt_id, ktime_to_ns(ts));\n\t\treturn -ENOMEM;\n\t}\n\n\teh.timestamp = ts;\n\teh.evt_id = evt_id;\n\teh.payld_sz = len;\n\t \n\tkfifo_in(&r_evt->proto->equeue.kfifo, &eh, sizeof(eh));\n\tkfifo_in(&r_evt->proto->equeue.kfifo, buf, len);\n\t \n\tqueue_work(r_evt->proto->equeue.wq,\n\t\t   &r_evt->proto->equeue.notify_work);\n\n\treturn 0;\n}\n\n \nstatic void scmi_kfifo_free(void *kfifo)\n{\n\tkfifo_free((struct kfifo *)kfifo);\n}\n\n \nstatic int scmi_initialize_events_queue(struct scmi_notify_instance *ni,\n\t\t\t\t\tstruct events_queue *equeue, size_t sz)\n{\n\tint ret;\n\n\tif (kfifo_alloc(&equeue->kfifo, sz, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\t \n\tequeue->sz = kfifo_size(&equeue->kfifo);\n\n\tret = devm_add_action_or_reset(ni->handle->dev, scmi_kfifo_free,\n\t\t\t\t       &equeue->kfifo);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&equeue->notify_work, scmi_events_dispatcher);\n\tequeue->wq = ni->notify_wq;\n\n\treturn ret;\n}\n\n \nstatic struct scmi_registered_events_desc *\nscmi_allocate_registered_events_desc(struct scmi_notify_instance *ni,\n\t\t\t\t     u8 proto_id, size_t queue_sz, size_t eh_sz,\n\t\t\t\t     int num_events,\n\t\t\t\t     const struct scmi_event_ops *ops)\n{\n\tint ret;\n\tstruct scmi_registered_events_desc *pd;\n\n\t \n\tsmp_rmb();\n\tif (WARN_ON(ni->registered_protocols[proto_id]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpd = devm_kzalloc(ni->handle->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpd->id = proto_id;\n\tpd->ops = ops;\n\tpd->ni = ni;\n\n\tret = scmi_initialize_events_queue(ni, &pd->equeue, queue_sz);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tpd->eh = devm_kzalloc(ni->handle->dev, eh_sz, GFP_KERNEL);\n\tif (!pd->eh)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpd->eh_sz = eh_sz;\n\n\tpd->registered_events = devm_kcalloc(ni->handle->dev, num_events,\n\t\t\t\t\t     sizeof(char *), GFP_KERNEL);\n\tif (!pd->registered_events)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpd->num_events = num_events;\n\n\t \n\tmutex_init(&pd->registered_mtx);\n\thash_init(pd->registered_events_handlers);\n\n\treturn pd;\n}\n\n \nint scmi_register_protocol_events(const struct scmi_handle *handle, u8 proto_id,\n\t\t\t\t  const struct scmi_protocol_handle *ph,\n\t\t\t\t  const struct scmi_protocol_events *ee)\n{\n\tint i;\n\tunsigned int num_sources;\n\tsize_t payld_sz = 0;\n\tstruct scmi_registered_events_desc *pd;\n\tstruct scmi_notify_instance *ni;\n\tconst struct scmi_event *evt;\n\n\tif (!ee || !ee->ops || !ee->evts || !ph ||\n\t    (!ee->num_sources && !ee->ops->get_num_sources))\n\t\treturn -EINVAL;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ee->num_sources) {\n\t\tnum_sources = ee->num_sources;\n\t} else {\n\t\tint nsrc = ee->ops->get_num_sources(ph);\n\n\t\tif (nsrc <= 0)\n\t\t\treturn -EINVAL;\n\t\tnum_sources = nsrc;\n\t}\n\n\tevt = ee->evts;\n\tfor (i = 0; i < ee->num_events; i++)\n\t\tpayld_sz = max_t(size_t, payld_sz, evt[i].max_payld_sz);\n\tpayld_sz += sizeof(struct scmi_event_header);\n\n\tpd = scmi_allocate_registered_events_desc(ni, proto_id, ee->queue_sz,\n\t\t\t\t\t\t  payld_sz, ee->num_events,\n\t\t\t\t\t\t  ee->ops);\n\tif (IS_ERR(pd))\n\t\treturn PTR_ERR(pd);\n\n\tpd->ph = ph;\n\tfor (i = 0; i < ee->num_events; i++, evt++) {\n\t\tstruct scmi_registered_event *r_evt;\n\n\t\tr_evt = devm_kzalloc(ni->handle->dev, sizeof(*r_evt),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!r_evt)\n\t\t\treturn -ENOMEM;\n\t\tr_evt->proto = pd;\n\t\tr_evt->evt = evt;\n\n\t\tr_evt->sources = devm_kcalloc(ni->handle->dev, num_sources,\n\t\t\t\t\t      sizeof(refcount_t), GFP_KERNEL);\n\t\tif (!r_evt->sources)\n\t\t\treturn -ENOMEM;\n\t\tr_evt->num_sources = num_sources;\n\t\tmutex_init(&r_evt->sources_mtx);\n\n\t\tr_evt->report = devm_kzalloc(ni->handle->dev,\n\t\t\t\t\t     evt->max_report_sz, GFP_KERNEL);\n\t\tif (!r_evt->report)\n\t\t\treturn -ENOMEM;\n\n\t\tpd->registered_events[i] = r_evt;\n\t\t \n\t\tsmp_wmb();\n\t\tdev_dbg(handle->dev, \"registered event - %lX\\n\",\n\t\t\tMAKE_ALL_SRCS_KEY(r_evt->proto->id, r_evt->evt->id));\n\t}\n\n\t \n\tni->registered_protocols[proto_id] = pd;\n\t \n\tsmp_wmb();\n\n\t \n\tschedule_work(&ni->init_work);\n\n\treturn 0;\n}\n\n \nvoid scmi_deregister_protocol_events(const struct scmi_handle *handle,\n\t\t\t\t     u8 proto_id)\n{\n\tstruct scmi_notify_instance *ni;\n\tstruct scmi_registered_events_desc *pd;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn;\n\n\tpd = ni->registered_protocols[proto_id];\n\tif (!pd)\n\t\treturn;\n\n\tni->registered_protocols[proto_id] = NULL;\n\t \n\tsmp_wmb();\n\n\tcancel_work_sync(&pd->equeue.notify_work);\n}\n\n \nstatic struct scmi_event_handler *\nscmi_allocate_event_handler(struct scmi_notify_instance *ni, u32 evt_key)\n{\n\tstruct scmi_event_handler *hndl;\n\n\thndl = kzalloc(sizeof(*hndl), GFP_KERNEL);\n\tif (!hndl)\n\t\treturn NULL;\n\thndl->key = evt_key;\n\tBLOCKING_INIT_NOTIFIER_HEAD(&hndl->chain);\n\trefcount_set(&hndl->users, 1);\n\t \n\thash_add(ni->pending_events_handlers, &hndl->hash, hndl->key);\n\n\treturn hndl;\n}\n\n \nstatic void scmi_free_event_handler(struct scmi_event_handler *hndl)\n{\n\thash_del(&hndl->hash);\n\tkfree(hndl);\n}\n\n \nstatic inline int scmi_bind_event_handler(struct scmi_notify_instance *ni,\n\t\t\t\t\t  struct scmi_event_handler *hndl)\n{\n\tstruct scmi_registered_event *r_evt;\n\n\tr_evt = SCMI_GET_REVT(ni, KEY_XTRACT_PROTO_ID(hndl->key),\n\t\t\t      KEY_XTRACT_EVT_ID(hndl->key));\n\tif (!r_evt)\n\t\treturn -EINVAL;\n\n\t \n\thash_del(&hndl->hash);\n\t \n\tscmi_protocol_acquire(ni->handle, KEY_XTRACT_PROTO_ID(hndl->key));\n\thndl->r_evt = r_evt;\n\n\tmutex_lock(&r_evt->proto->registered_mtx);\n\thash_add(r_evt->proto->registered_events_handlers,\n\t\t &hndl->hash, hndl->key);\n\tmutex_unlock(&r_evt->proto->registered_mtx);\n\n\treturn 0;\n}\n\n \nstatic inline int scmi_valid_pending_handler(struct scmi_notify_instance *ni,\n\t\t\t\t\t     struct scmi_event_handler *hndl)\n{\n\tstruct scmi_registered_events_desc *pd;\n\n\tif (!IS_HNDL_PENDING(hndl))\n\t\treturn -EINVAL;\n\n\tpd = SCMI_GET_PROTO(ni, KEY_XTRACT_PROTO_ID(hndl->key));\n\tif (pd)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int scmi_register_event_handler(struct scmi_notify_instance *ni,\n\t\t\t\t       struct scmi_event_handler *hndl)\n{\n\tint ret;\n\n\tret = scmi_bind_event_handler(ni, hndl);\n\tif (!ret) {\n\t\tdev_dbg(ni->handle->dev, \"registered NEW handler - key:%X\\n\",\n\t\t\thndl->key);\n\t} else {\n\t\tret = scmi_valid_pending_handler(ni, hndl);\n\t\tif (!ret)\n\t\t\tdev_dbg(ni->handle->dev,\n\t\t\t\t\"registered PENDING handler - key:%X\\n\",\n\t\t\t\thndl->key);\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline struct scmi_event_handler *\n__scmi_event_handler_get_ops(struct scmi_notify_instance *ni,\n\t\t\t     u32 evt_key, bool create)\n{\n\tstruct scmi_registered_event *r_evt;\n\tstruct scmi_event_handler *hndl = NULL;\n\n\tr_evt = SCMI_GET_REVT(ni, KEY_XTRACT_PROTO_ID(evt_key),\n\t\t\t      KEY_XTRACT_EVT_ID(evt_key));\n\n\tmutex_lock(&ni->pending_mtx);\n\t \n\tif (r_evt) {\n\t\tmutex_lock(&r_evt->proto->registered_mtx);\n\t\thndl = KEY_FIND(r_evt->proto->registered_events_handlers,\n\t\t\t\thndl, evt_key);\n\t\tif (hndl)\n\t\t\trefcount_inc(&hndl->users);\n\t\tmutex_unlock(&r_evt->proto->registered_mtx);\n\t}\n\n\t \n\tif (!hndl) {\n\t\thndl = KEY_FIND(ni->pending_events_handlers, hndl, evt_key);\n\t\tif (hndl)\n\t\t\trefcount_inc(&hndl->users);\n\t}\n\n\t \n\tif (!hndl && create) {\n\t\thndl = scmi_allocate_event_handler(ni, evt_key);\n\t\tif (hndl && scmi_register_event_handler(ni, hndl)) {\n\t\t\tdev_dbg(ni->handle->dev,\n\t\t\t\t\"purging UNKNOWN handler - key:%X\\n\",\n\t\t\t\thndl->key);\n\t\t\t \n\t\t\tscmi_put_handler_unlocked(ni, hndl);\n\t\t\thndl = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&ni->pending_mtx);\n\n\treturn hndl;\n}\n\nstatic struct scmi_event_handler *\nscmi_get_handler(struct scmi_notify_instance *ni, u32 evt_key)\n{\n\treturn __scmi_event_handler_get_ops(ni, evt_key, false);\n}\n\nstatic struct scmi_event_handler *\nscmi_get_or_create_handler(struct scmi_notify_instance *ni, u32 evt_key)\n{\n\treturn __scmi_event_handler_get_ops(ni, evt_key, true);\n}\n\n \nstatic struct scmi_event_handler *\nscmi_get_active_handler(struct scmi_notify_instance *ni, u32 evt_key)\n{\n\tstruct scmi_registered_event *r_evt;\n\tstruct scmi_event_handler *hndl = NULL;\n\n\tr_evt = SCMI_GET_REVT(ni, KEY_XTRACT_PROTO_ID(evt_key),\n\t\t\t      KEY_XTRACT_EVT_ID(evt_key));\n\tif (r_evt) {\n\t\tmutex_lock(&r_evt->proto->registered_mtx);\n\t\thndl = KEY_FIND(r_evt->proto->registered_events_handlers,\n\t\t\t\thndl, evt_key);\n\t\tif (hndl)\n\t\t\trefcount_inc(&hndl->users);\n\t\tmutex_unlock(&r_evt->proto->registered_mtx);\n\t}\n\n\treturn hndl;\n}\n\n \nstatic inline int __scmi_enable_evt(struct scmi_registered_event *r_evt,\n\t\t\t\t    u32 src_id, bool enable)\n{\n\tint retvals = 0;\n\tu32 num_sources;\n\trefcount_t *sid;\n\n\tif (src_id == SRC_ID_MASK) {\n\t\tsrc_id = 0;\n\t\tnum_sources = r_evt->num_sources;\n\t} else if (src_id < r_evt->num_sources) {\n\t\tnum_sources = 1;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&r_evt->sources_mtx);\n\tif (enable) {\n\t\tfor (; num_sources; src_id++, num_sources--) {\n\t\t\tint ret = 0;\n\n\t\t\tsid = &r_evt->sources[src_id];\n\t\t\tif (refcount_read(sid) == 0) {\n\t\t\t\tret = REVT_NOTIFY_ENABLE(r_evt, r_evt->evt->id,\n\t\t\t\t\t\t\t src_id);\n\t\t\t\tif (!ret)\n\t\t\t\t\trefcount_set(sid, 1);\n\t\t\t} else {\n\t\t\t\trefcount_inc(sid);\n\t\t\t}\n\t\t\tretvals += !ret;\n\t\t}\n\t} else {\n\t\tfor (; num_sources; src_id++, num_sources--) {\n\t\t\tsid = &r_evt->sources[src_id];\n\t\t\tif (refcount_dec_and_test(sid))\n\t\t\t\tREVT_NOTIFY_DISABLE(r_evt,\n\t\t\t\t\t\t    r_evt->evt->id, src_id);\n\t\t}\n\t\tretvals = 1;\n\t}\n\tmutex_unlock(&r_evt->sources_mtx);\n\n\treturn retvals ? 0 : -EINVAL;\n}\n\nstatic int scmi_enable_events(struct scmi_event_handler *hndl)\n{\n\tint ret = 0;\n\n\tif (!hndl->enabled) {\n\t\tret = __scmi_enable_evt(hndl->r_evt,\n\t\t\t\t\tKEY_XTRACT_SRC_ID(hndl->key), true);\n\t\tif (!ret)\n\t\t\thndl->enabled = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int scmi_disable_events(struct scmi_event_handler *hndl)\n{\n\tint ret = 0;\n\n\tif (hndl->enabled) {\n\t\tret = __scmi_enable_evt(hndl->r_evt,\n\t\t\t\t\tKEY_XTRACT_SRC_ID(hndl->key), false);\n\t\tif (!ret)\n\t\t\thndl->enabled = false;\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool scmi_put_handler_unlocked(struct scmi_notify_instance *ni,\n\t\t\t\t      struct scmi_event_handler *hndl)\n{\n\tbool freed = false;\n\n\tif (refcount_dec_and_test(&hndl->users)) {\n\t\tif (!IS_HNDL_PENDING(hndl))\n\t\t\tscmi_disable_events(hndl);\n\t\tscmi_free_event_handler(hndl);\n\t\tfreed = true;\n\t}\n\n\treturn freed;\n}\n\nstatic void scmi_put_handler(struct scmi_notify_instance *ni,\n\t\t\t     struct scmi_event_handler *hndl)\n{\n\tbool freed;\n\tu8 protocol_id;\n\tstruct scmi_registered_event *r_evt = hndl->r_evt;\n\n\tmutex_lock(&ni->pending_mtx);\n\tif (r_evt) {\n\t\tprotocol_id = r_evt->proto->id;\n\t\tmutex_lock(&r_evt->proto->registered_mtx);\n\t}\n\n\tfreed = scmi_put_handler_unlocked(ni, hndl);\n\n\tif (r_evt) {\n\t\tmutex_unlock(&r_evt->proto->registered_mtx);\n\t\t \n\t\tif (freed)\n\t\t\tscmi_protocol_release(ni->handle, protocol_id);\n\t}\n\tmutex_unlock(&ni->pending_mtx);\n}\n\nstatic void scmi_put_active_handler(struct scmi_notify_instance *ni,\n\t\t\t\t    struct scmi_event_handler *hndl)\n{\n\tbool freed;\n\tstruct scmi_registered_event *r_evt = hndl->r_evt;\n\tu8 protocol_id = r_evt->proto->id;\n\n\tmutex_lock(&r_evt->proto->registered_mtx);\n\tfreed = scmi_put_handler_unlocked(ni, hndl);\n\tmutex_unlock(&r_evt->proto->registered_mtx);\n\tif (freed)\n\t\tscmi_protocol_release(ni->handle, protocol_id);\n}\n\n \nstatic int scmi_event_handler_enable_events(struct scmi_event_handler *hndl)\n{\n\tif (scmi_enable_events(hndl)) {\n\t\tpr_err(\"Failed to ENABLE events for key:%X !\\n\", hndl->key);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int scmi_notifier_register(const struct scmi_handle *handle,\n\t\t\t\t  u8 proto_id, u8 evt_id, const u32 *src_id,\n\t\t\t\t  struct notifier_block *nb)\n{\n\tint ret = 0;\n\tu32 evt_key;\n\tstruct scmi_event_handler *hndl;\n\tstruct scmi_notify_instance *ni;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn -ENODEV;\n\n\tevt_key = MAKE_HASH_KEY(proto_id, evt_id,\n\t\t\t\tsrc_id ? *src_id : SRC_ID_MASK);\n\thndl = scmi_get_or_create_handler(ni, evt_key);\n\tif (!hndl)\n\t\treturn -EINVAL;\n\n\tblocking_notifier_chain_register(&hndl->chain, nb);\n\n\t \n\tif (!IS_HNDL_PENDING(hndl)) {\n\t\tret = scmi_event_handler_enable_events(hndl);\n\t\tif (ret)\n\t\t\tscmi_put_handler(ni, hndl);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int scmi_notifier_unregister(const struct scmi_handle *handle,\n\t\t\t\t    u8 proto_id, u8 evt_id, const u32 *src_id,\n\t\t\t\t    struct notifier_block *nb)\n{\n\tu32 evt_key;\n\tstruct scmi_event_handler *hndl;\n\tstruct scmi_notify_instance *ni;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn -ENODEV;\n\n\tevt_key = MAKE_HASH_KEY(proto_id, evt_id,\n\t\t\t\tsrc_id ? *src_id : SRC_ID_MASK);\n\thndl = scmi_get_handler(ni, evt_key);\n\tif (!hndl)\n\t\treturn -EINVAL;\n\n\t \n\tblocking_notifier_chain_unregister(&hndl->chain, nb);\n\tscmi_put_handler(ni, hndl);\n\n\t \n\tscmi_put_handler(ni, hndl);\n\n\treturn 0;\n}\n\nstruct scmi_notifier_devres {\n\tconst struct scmi_handle *handle;\n\tu8 proto_id;\n\tu8 evt_id;\n\tu32 __src_id;\n\tu32 *src_id;\n\tstruct notifier_block *nb;\n};\n\nstatic void scmi_devm_release_notifier(struct device *dev, void *res)\n{\n\tstruct scmi_notifier_devres *dres = res;\n\n\tscmi_notifier_unregister(dres->handle, dres->proto_id, dres->evt_id,\n\t\t\t\t dres->src_id, dres->nb);\n}\n\n \nstatic int scmi_devm_notifier_register(struct scmi_device *sdev,\n\t\t\t\t       u8 proto_id, u8 evt_id,\n\t\t\t\t       const u32 *src_id,\n\t\t\t\t       struct notifier_block *nb)\n{\n\tint ret;\n\tstruct scmi_notifier_devres *dres;\n\n\tdres = devres_alloc(scmi_devm_release_notifier,\n\t\t\t    sizeof(*dres), GFP_KERNEL);\n\tif (!dres)\n\t\treturn -ENOMEM;\n\n\tret = scmi_notifier_register(sdev->handle, proto_id,\n\t\t\t\t     evt_id, src_id, nb);\n\tif (ret) {\n\t\tdevres_free(dres);\n\t\treturn ret;\n\t}\n\n\tdres->handle = sdev->handle;\n\tdres->proto_id = proto_id;\n\tdres->evt_id = evt_id;\n\tdres->nb = nb;\n\tif (src_id) {\n\t\tdres->__src_id = *src_id;\n\t\tdres->src_id = &dres->__src_id;\n\t} else {\n\t\tdres->src_id = NULL;\n\t}\n\tdevres_add(&sdev->dev, dres);\n\n\treturn ret;\n}\n\nstatic int scmi_devm_notifier_match(struct device *dev, void *res, void *data)\n{\n\tstruct scmi_notifier_devres *dres = res;\n\tstruct scmi_notifier_devres *xres = data;\n\n\tif (WARN_ON(!dres || !xres))\n\t\treturn 0;\n\n\treturn dres->proto_id == xres->proto_id &&\n\t\tdres->evt_id == xres->evt_id &&\n\t\tdres->nb == xres->nb &&\n\t\t((!dres->src_id && !xres->src_id) ||\n\t\t  (dres->src_id && xres->src_id &&\n\t\t   dres->__src_id == xres->__src_id));\n}\n\n \nstatic int scmi_devm_notifier_unregister(struct scmi_device *sdev,\n\t\t\t\t\t u8 proto_id, u8 evt_id,\n\t\t\t\t\t const u32 *src_id,\n\t\t\t\t\t struct notifier_block *nb)\n{\n\tint ret;\n\tstruct scmi_notifier_devres dres;\n\n\tdres.handle = sdev->handle;\n\tdres.proto_id = proto_id;\n\tdres.evt_id = evt_id;\n\tif (src_id) {\n\t\tdres.__src_id = *src_id;\n\t\tdres.src_id = &dres.__src_id;\n\t} else {\n\t\tdres.src_id = NULL;\n\t}\n\n\tret = devres_release(&sdev->dev, scmi_devm_release_notifier,\n\t\t\t     scmi_devm_notifier_match, &dres);\n\n\tWARN_ON(ret);\n\n\treturn ret;\n}\n\n \nstatic void scmi_protocols_late_init(struct work_struct *work)\n{\n\tint bkt;\n\tstruct scmi_event_handler *hndl;\n\tstruct scmi_notify_instance *ni;\n\tstruct hlist_node *tmp;\n\n\tni = container_of(work, struct scmi_notify_instance, init_work);\n\n\t \n\tsmp_rmb();\n\n\tmutex_lock(&ni->pending_mtx);\n\thash_for_each_safe(ni->pending_events_handlers, bkt, tmp, hndl, hash) {\n\t\tint ret;\n\n\t\tret = scmi_bind_event_handler(ni, hndl);\n\t\tif (!ret) {\n\t\t\tdev_dbg(ni->handle->dev,\n\t\t\t\t\"finalized PENDING handler - key:%X\\n\",\n\t\t\t\thndl->key);\n\t\t\tret = scmi_event_handler_enable_events(hndl);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(ni->handle->dev,\n\t\t\t\t\t\"purging INVALID handler - key:%X\\n\",\n\t\t\t\t\thndl->key);\n\t\t\t\tscmi_put_active_handler(ni, hndl);\n\t\t\t}\n\t\t} else {\n\t\t\tret = scmi_valid_pending_handler(ni, hndl);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(ni->handle->dev,\n\t\t\t\t\t\"purging PENDING handler - key:%X\\n\",\n\t\t\t\t\thndl->key);\n\t\t\t\t \n\t\t\t\tscmi_put_handler_unlocked(ni, hndl);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->pending_mtx);\n}\n\n \nstatic const struct scmi_notify_ops notify_ops = {\n\t.devm_event_notifier_register = scmi_devm_notifier_register,\n\t.devm_event_notifier_unregister = scmi_devm_notifier_unregister,\n\t.event_notifier_register = scmi_notifier_register,\n\t.event_notifier_unregister = scmi_notifier_unregister,\n};\n\n \nint scmi_notification_init(struct scmi_handle *handle)\n{\n\tvoid *gid;\n\tstruct scmi_notify_instance *ni;\n\n\tgid = devres_open_group(handle->dev, NULL, GFP_KERNEL);\n\tif (!gid)\n\t\treturn -ENOMEM;\n\n\tni = devm_kzalloc(handle->dev, sizeof(*ni), GFP_KERNEL);\n\tif (!ni)\n\t\tgoto err;\n\n\tni->gid = gid;\n\tni->handle = handle;\n\n\tni->registered_protocols = devm_kcalloc(handle->dev, SCMI_MAX_PROTO,\n\t\t\t\t\t\tsizeof(char *), GFP_KERNEL);\n\tif (!ni->registered_protocols)\n\t\tgoto err;\n\n\tni->notify_wq = alloc_workqueue(dev_name(handle->dev),\n\t\t\t\t\tWQ_UNBOUND | WQ_FREEZABLE | WQ_SYSFS,\n\t\t\t\t\t0);\n\tif (!ni->notify_wq)\n\t\tgoto err;\n\n\tmutex_init(&ni->pending_mtx);\n\thash_init(ni->pending_events_handlers);\n\n\tINIT_WORK(&ni->init_work, scmi_protocols_late_init);\n\n\tscmi_notification_instance_data_set(handle, ni);\n\thandle->notify_ops = &notify_ops;\n\t \n\tsmp_wmb();\n\n\tdev_info(handle->dev, \"Core Enabled.\\n\");\n\n\tdevres_close_group(handle->dev, ni->gid);\n\n\treturn 0;\n\nerr:\n\tdev_warn(handle->dev, \"Initialization Failed.\\n\");\n\tdevres_release_group(handle->dev, gid);\n\treturn -ENOMEM;\n}\n\n \nvoid scmi_notification_exit(struct scmi_handle *handle)\n{\n\tstruct scmi_notify_instance *ni;\n\n\tni = scmi_notification_instance_data_get(handle);\n\tif (!ni)\n\t\treturn;\n\tscmi_notification_instance_data_set(handle, NULL);\n\n\t \n\tdestroy_workqueue(ni->notify_wq);\n\n\tdevres_release_group(ni->handle->dev, ni->gid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}