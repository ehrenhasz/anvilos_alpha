{
  "module_name": "mailbox.c",
  "hash_id": "bdb13c231662ac5287575f19516bfefceace6ecdee6f0a68c1c2be75eb7badba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/mailbox_client.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n\n#include \"common.h\"\n\n \nstruct scmi_mailbox {\n\tstruct mbox_client cl;\n\tstruct mbox_chan *chan;\n\tstruct mbox_chan *chan_receiver;\n\tstruct scmi_chan_info *cinfo;\n\tstruct scmi_shared_mem __iomem *shmem;\n};\n\n#define client_to_scmi_mailbox(c) container_of(c, struct scmi_mailbox, cl)\n\nstatic void tx_prepare(struct mbox_client *cl, void *m)\n{\n\tstruct scmi_mailbox *smbox = client_to_scmi_mailbox(cl);\n\n\tshmem_tx_prepare(smbox->shmem, m, smbox->cinfo);\n}\n\nstatic void rx_callback(struct mbox_client *cl, void *m)\n{\n\tstruct scmi_mailbox *smbox = client_to_scmi_mailbox(cl);\n\n\tscmi_rx_callback(smbox->cinfo, shmem_read_header(smbox->shmem), NULL);\n}\n\nstatic bool mailbox_chan_available(struct device_node *of_node, int idx)\n{\n\tint num_mb;\n\n\t \n\tnum_mb = of_count_phandle_with_args(of_node, \"mboxes\", \"#mbox-cells\");\n\tif (num_mb == 3 && idx == 1)\n\t\tidx = 2;\n\n\treturn !of_parse_phandle_with_args(of_node, \"mboxes\",\n\t\t\t\t\t   \"#mbox-cells\", idx, NULL);\n}\n\n \nstatic int mailbox_chan_validate(struct device *cdev,\n\t\t\t\t int *a2p_rx_chan, int *p2a_chan)\n{\n\tint num_mb, num_sh, ret = 0;\n\tstruct device_node *np = cdev->of_node;\n\n\tnum_mb = of_count_phandle_with_args(np, \"mboxes\", \"#mbox-cells\");\n\tnum_sh = of_count_phandle_with_args(np, \"shmem\", NULL);\n\tdev_dbg(cdev, \"Found %d mboxes and %d shmems !\\n\", num_mb, num_sh);\n\n\t \n\tif (num_mb <= 0 || num_sh <= 0 || num_sh > 2 || num_mb > 3 ||\n\t    (num_mb == 1 && num_sh != 1) || (num_mb == 3 && num_sh != 2)) {\n\t\tdev_warn(cdev,\n\t\t\t \"Invalid channel descriptor for '%s' - mbs:%d  shm:%d\\n\",\n\t\t\t of_node_full_name(np), num_mb, num_sh);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (num_sh > 1) {\n\t\tstruct device_node *np_tx, *np_rx;\n\n\t\tnp_tx = of_parse_phandle(np, \"shmem\", 0);\n\t\tnp_rx = of_parse_phandle(np, \"shmem\", 1);\n\t\tif (!np_tx || !np_rx || np_tx == np_rx) {\n\t\t\tdev_warn(cdev, \"Invalid shmem descriptor for '%s'\\n\",\n\t\t\t\t of_node_full_name(np));\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tof_node_put(np_tx);\n\t\tof_node_put(np_rx);\n\t}\n\n\t \n\tif (!ret) {\n\t\tswitch (num_mb) {\n\t\tcase 1:\n\t\t\t*a2p_rx_chan = 0;\n\t\t\t*p2a_chan = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (num_sh == 2) {\n\t\t\t\t*a2p_rx_chan = 0;\n\t\t\t\t*p2a_chan = 1;\n\t\t\t} else {\n\t\t\t\t*a2p_rx_chan = 1;\n\t\t\t\t*p2a_chan = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*a2p_rx_chan = 1;\n\t\t\t*p2a_chan = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int mailbox_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,\n\t\t\t      bool tx)\n{\n\tconst char *desc = tx ? \"Tx\" : \"Rx\";\n\tstruct device *cdev = cinfo->dev;\n\tstruct scmi_mailbox *smbox;\n\tstruct device_node *shmem;\n\tint ret, a2p_rx_chan, p2a_chan, idx = tx ? 0 : 1;\n\tstruct mbox_client *cl;\n\tresource_size_t size;\n\tstruct resource res;\n\n\tret = mailbox_chan_validate(cdev, &a2p_rx_chan, &p2a_chan);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tx && !p2a_chan)\n\t\treturn -ENODEV;\n\n\tsmbox = devm_kzalloc(dev, sizeof(*smbox), GFP_KERNEL);\n\tif (!smbox)\n\t\treturn -ENOMEM;\n\n\tshmem = of_parse_phandle(cdev->of_node, \"shmem\", idx);\n\tif (!of_device_is_compatible(shmem, \"arm,scmi-shmem\")) {\n\t\tof_node_put(shmem);\n\t\treturn -ENXIO;\n\t}\n\n\tret = of_address_to_resource(shmem, 0, &res);\n\tof_node_put(shmem);\n\tif (ret) {\n\t\tdev_err(cdev, \"failed to get SCMI %s shared memory\\n\", desc);\n\t\treturn ret;\n\t}\n\n\tsize = resource_size(&res);\n\tsmbox->shmem = devm_ioremap(dev, res.start, size);\n\tif (!smbox->shmem) {\n\t\tdev_err(dev, \"failed to ioremap SCMI %s shared memory\\n\", desc);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tcl = &smbox->cl;\n\tcl->dev = cdev;\n\tcl->tx_prepare = tx ? tx_prepare : NULL;\n\tcl->rx_callback = rx_callback;\n\tcl->tx_block = false;\n\tcl->knows_txdone = tx;\n\n\tsmbox->chan = mbox_request_channel(cl, tx ? 0 : p2a_chan);\n\tif (IS_ERR(smbox->chan)) {\n\t\tret = PTR_ERR(smbox->chan);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(cdev,\n\t\t\t\t\"failed to request SCMI %s mailbox\\n\", desc);\n\t\treturn ret;\n\t}\n\n\t \n\tif (tx && a2p_rx_chan) {\n\t\tsmbox->chan_receiver = mbox_request_channel(cl, a2p_rx_chan);\n\t\tif (IS_ERR(smbox->chan_receiver)) {\n\t\t\tret = PTR_ERR(smbox->chan_receiver);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(cdev, \"failed to request SCMI Tx Receiver mailbox\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcinfo->transport_info = smbox;\n\tsmbox->cinfo = cinfo;\n\n\treturn 0;\n}\n\nstatic int mailbox_chan_free(int id, void *p, void *data)\n{\n\tstruct scmi_chan_info *cinfo = p;\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\tif (smbox && !IS_ERR(smbox->chan)) {\n\t\tmbox_free_channel(smbox->chan);\n\t\tmbox_free_channel(smbox->chan_receiver);\n\t\tcinfo->transport_info = NULL;\n\t\tsmbox->chan = NULL;\n\t\tsmbox->chan_receiver = NULL;\n\t\tsmbox->cinfo = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mailbox_send_message(struct scmi_chan_info *cinfo,\n\t\t\t\tstruct scmi_xfer *xfer)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\tint ret;\n\n\tret = mbox_send_message(smbox->chan, xfer);\n\n\t \n\tif (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void mailbox_mark_txdone(struct scmi_chan_info *cinfo, int ret,\n\t\t\t\tstruct scmi_xfer *__unused)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\t \n\tmbox_client_txdone(smbox->chan, ret);\n}\n\nstatic void mailbox_fetch_response(struct scmi_chan_info *cinfo,\n\t\t\t\t   struct scmi_xfer *xfer)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\tshmem_fetch_response(smbox->shmem, xfer);\n}\n\nstatic void mailbox_fetch_notification(struct scmi_chan_info *cinfo,\n\t\t\t\t       size_t max_len, struct scmi_xfer *xfer)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\tshmem_fetch_notification(smbox->shmem, max_len, xfer);\n}\n\nstatic void mailbox_clear_channel(struct scmi_chan_info *cinfo)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\tshmem_clear_channel(smbox->shmem);\n}\n\nstatic bool\nmailbox_poll_done(struct scmi_chan_info *cinfo, struct scmi_xfer *xfer)\n{\n\tstruct scmi_mailbox *smbox = cinfo->transport_info;\n\n\treturn shmem_poll_done(smbox->shmem, xfer);\n}\n\nstatic const struct scmi_transport_ops scmi_mailbox_ops = {\n\t.chan_available = mailbox_chan_available,\n\t.chan_setup = mailbox_chan_setup,\n\t.chan_free = mailbox_chan_free,\n\t.send_message = mailbox_send_message,\n\t.mark_txdone = mailbox_mark_txdone,\n\t.fetch_response = mailbox_fetch_response,\n\t.fetch_notification = mailbox_fetch_notification,\n\t.clear_channel = mailbox_clear_channel,\n\t.poll_done = mailbox_poll_done,\n};\n\nconst struct scmi_desc scmi_mailbox_desc = {\n\t.ops = &scmi_mailbox_ops,\n\t.max_rx_timeout_ms = 30,  \n\t.max_msg = 20,  \n\t.max_msg_size = 128,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}