{
  "module_name": "shmem.c",
  "hash_id": "8407d2b1fb0c6f5db3a6a885e734f5944c09c53014ba794e2d184ec44289aa32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/shmem.c",
  "human_readable_source": "\n \n\n#include <linux/ktime.h>\n#include <linux/io.h>\n#include <linux/processor.h>\n#include <linux/types.h>\n\n#include <asm-generic/bug.h>\n\n#include \"common.h\"\n\n \nstruct scmi_shared_mem {\n\t__le32 reserved;\n\t__le32 channel_status;\n#define SCMI_SHMEM_CHAN_STAT_CHANNEL_ERROR\tBIT(1)\n#define SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE\tBIT(0)\n\t__le32 reserved1[2];\n\t__le32 flags;\n#define SCMI_SHMEM_FLAG_INTR_ENABLED\tBIT(0)\n\t__le32 length;\n\t__le32 msg_header;\n\tu8 msg_payload[];\n};\n\nvoid shmem_tx_prepare(struct scmi_shared_mem __iomem *shmem,\n\t\t      struct scmi_xfer *xfer, struct scmi_chan_info *cinfo)\n{\n\tktime_t stop;\n\n\t \n\tstop = ktime_add_ms(ktime_get(), 2 * cinfo->rx_timeout_ms);\n\tspin_until_cond((ioread32(&shmem->channel_status) &\n\t\t\t SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE) ||\n\t\t\t ktime_after(ktime_get(), stop));\n\tif (!(ioread32(&shmem->channel_status) &\n\t      SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE)) {\n\t\tWARN_ON_ONCE(1);\n\t\tdev_err(cinfo->dev,\n\t\t\t\"Timeout waiting for a free TX channel !\\n\");\n\t\treturn;\n\t}\n\n\t \n\tiowrite32(0x0, &shmem->channel_status);\n\tiowrite32(xfer->hdr.poll_completion ? 0 : SCMI_SHMEM_FLAG_INTR_ENABLED,\n\t\t  &shmem->flags);\n\tiowrite32(sizeof(shmem->msg_header) + xfer->tx.len, &shmem->length);\n\tiowrite32(pack_scmi_header(&xfer->hdr), &shmem->msg_header);\n\tif (xfer->tx.buf)\n\t\tmemcpy_toio(shmem->msg_payload, xfer->tx.buf, xfer->tx.len);\n}\n\nu32 shmem_read_header(struct scmi_shared_mem __iomem *shmem)\n{\n\treturn ioread32(&shmem->msg_header);\n}\n\nvoid shmem_fetch_response(struct scmi_shared_mem __iomem *shmem,\n\t\t\t  struct scmi_xfer *xfer)\n{\n\tsize_t len = ioread32(&shmem->length);\n\n\txfer->hdr.status = ioread32(shmem->msg_payload);\n\t \n\txfer->rx.len = min_t(size_t, xfer->rx.len, len > 8 ? len - 8 : 0);\n\n\t \n\tmemcpy_fromio(xfer->rx.buf, shmem->msg_payload + 4, xfer->rx.len);\n}\n\nvoid shmem_fetch_notification(struct scmi_shared_mem __iomem *shmem,\n\t\t\t      size_t max_len, struct scmi_xfer *xfer)\n{\n\tsize_t len = ioread32(&shmem->length);\n\n\t \n\txfer->rx.len = min_t(size_t, max_len, len > 4 ? len - 4 : 0);\n\n\t \n\tmemcpy_fromio(xfer->rx.buf, shmem->msg_payload, xfer->rx.len);\n}\n\nvoid shmem_clear_channel(struct scmi_shared_mem __iomem *shmem)\n{\n\tiowrite32(SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE, &shmem->channel_status);\n}\n\nbool shmem_poll_done(struct scmi_shared_mem __iomem *shmem,\n\t\t     struct scmi_xfer *xfer)\n{\n\tu16 xfer_id;\n\n\txfer_id = MSG_XTRACT_TOKEN(ioread32(&shmem->msg_header));\n\n\tif (xfer->hdr.seq != xfer_id)\n\t\treturn false;\n\n\treturn ioread32(&shmem->channel_status) &\n\t\t(SCMI_SHMEM_CHAN_STAT_CHANNEL_ERROR |\n\t\t SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}