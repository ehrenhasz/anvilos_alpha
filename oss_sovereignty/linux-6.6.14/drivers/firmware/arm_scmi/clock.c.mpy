{
  "module_name": "clock.c",
  "hash_id": "ad427bbc2cf261af3e60b1bb0fb10f9b4a8f04b3cf164d82bb1c78ba307572f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/clock.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/limits.h>\n#include <linux/sort.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\nenum scmi_clock_protocol_cmd {\n\tCLOCK_ATTRIBUTES = 0x3,\n\tCLOCK_DESCRIBE_RATES = 0x4,\n\tCLOCK_RATE_SET = 0x5,\n\tCLOCK_RATE_GET = 0x6,\n\tCLOCK_CONFIG_SET = 0x7,\n\tCLOCK_NAME_GET = 0x8,\n\tCLOCK_RATE_NOTIFY = 0x9,\n\tCLOCK_RATE_CHANGE_REQUESTED_NOTIFY = 0xA,\n};\n\nstruct scmi_msg_resp_clock_protocol_attributes {\n\t__le16 num_clocks;\n\tu8 max_async_req;\n\tu8 reserved;\n};\n\nstruct scmi_msg_resp_clock_attributes {\n\t__le32 attributes;\n#define\tCLOCK_ENABLE\tBIT(0)\n#define SUPPORTS_RATE_CHANGED_NOTIF(x)\t\t((x) & BIT(31))\n#define SUPPORTS_RATE_CHANGE_REQUESTED_NOTIF(x)\t((x) & BIT(30))\n#define SUPPORTS_EXTENDED_NAMES(x)\t\t((x) & BIT(29))\n\tu8 name[SCMI_SHORT_NAME_MAX_SIZE];\n\t__le32 clock_enable_latency;\n};\n\nstruct scmi_clock_set_config {\n\t__le32 id;\n\t__le32 attributes;\n};\n\nstruct scmi_msg_clock_describe_rates {\n\t__le32 id;\n\t__le32 rate_index;\n};\n\nstruct scmi_msg_resp_clock_describe_rates {\n\t__le32 num_rates_flags;\n#define NUM_RETURNED(x)\t\t((x) & 0xfff)\n#define RATE_DISCRETE(x)\t!((x) & BIT(12))\n#define NUM_REMAINING(x)\t((x) >> 16)\n\tstruct {\n\t\t__le32 value_low;\n\t\t__le32 value_high;\n\t} rate[];\n#define RATE_TO_U64(X)\t\t\\\n({\t\t\t\t\\\n\ttypeof(X) x = (X);\t\\\n\tle32_to_cpu((x).value_low) | (u64)le32_to_cpu((x).value_high) << 32; \\\n})\n};\n\nstruct scmi_clock_set_rate {\n\t__le32 flags;\n#define CLOCK_SET_ASYNC\t\tBIT(0)\n#define CLOCK_SET_IGNORE_RESP\tBIT(1)\n#define CLOCK_SET_ROUND_UP\tBIT(2)\n#define CLOCK_SET_ROUND_AUTO\tBIT(3)\n\t__le32 id;\n\t__le32 value_low;\n\t__le32 value_high;\n};\n\nstruct scmi_msg_resp_set_rate_complete {\n\t__le32 id;\n\t__le32 rate_low;\n\t__le32 rate_high;\n};\n\nstruct scmi_msg_clock_rate_notify {\n\t__le32 clk_id;\n\t__le32 notify_enable;\n};\n\nstruct scmi_clock_rate_notify_payld {\n\t__le32 agent_id;\n\t__le32 clock_id;\n\t__le32 rate_low;\n\t__le32 rate_high;\n};\n\nstruct clock_info {\n\tu32 version;\n\tint num_clocks;\n\tint max_async_req;\n\tatomic_t cur_async_req;\n\tstruct scmi_clock_info *clk;\n};\n\nstatic enum scmi_clock_protocol_cmd evt_2_cmd[] = {\n\tCLOCK_RATE_NOTIFY,\n\tCLOCK_RATE_CHANGE_REQUESTED_NOTIFY,\n};\n\nstatic int\nscmi_clock_protocol_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t   struct clock_info *ci)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_clock_protocol_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES,\n\t\t\t\t      0, sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tci->num_clocks = le16_to_cpu(attr->num_clocks);\n\t\tci->max_async_req = attr->max_async_req;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_clock_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t     u32 clk_id, struct scmi_clock_info *clk,\n\t\t\t\t     u32 version)\n{\n\tint ret;\n\tu32 attributes;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_clock_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, CLOCK_ATTRIBUTES,\n\t\t\t\t      sizeof(clk_id), sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(clk_id, t->tx.buf);\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tu32 latency = 0;\n\t\tattributes = le32_to_cpu(attr->attributes);\n\t\tstrscpy(clk->name, attr->name, SCMI_SHORT_NAME_MAX_SIZE);\n\t\t \n\t\tif (PROTOCOL_REV_MAJOR(version) >= 0x2)\n\t\t\tlatency = le32_to_cpu(attr->clock_enable_latency);\n\t\tclk->enable_latency = latency ? : U32_MAX;\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\n\t \n\tif (!ret && PROTOCOL_REV_MAJOR(version) >= 0x2) {\n\t\tif (SUPPORTS_EXTENDED_NAMES(attributes))\n\t\t\tph->hops->extended_name_get(ph, CLOCK_NAME_GET, clk_id,\n\t\t\t\t\t\t    clk->name,\n\t\t\t\t\t\t    SCMI_MAX_STR_SIZE);\n\n\t\tif (SUPPORTS_RATE_CHANGED_NOTIF(attributes))\n\t\t\tclk->rate_changed_notifications = true;\n\t\tif (SUPPORTS_RATE_CHANGE_REQUESTED_NOTIF(attributes))\n\t\t\tclk->rate_change_requested_notifications = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int rate_cmp_func(const void *_r1, const void *_r2)\n{\n\tconst u64 *r1 = _r1, *r2 = _r2;\n\n\tif (*r1 < *r2)\n\t\treturn -1;\n\telse if (*r1 == *r2)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstruct scmi_clk_ipriv {\n\tstruct device *dev;\n\tu32 clk_id;\n\tstruct scmi_clock_info *clk;\n};\n\nstatic void iter_clk_describe_prepare_message(void *message,\n\t\t\t\t\t      const unsigned int desc_index,\n\t\t\t\t\t      const void *priv)\n{\n\tstruct scmi_msg_clock_describe_rates *msg = message;\n\tconst struct scmi_clk_ipriv *p = priv;\n\n\tmsg->id = cpu_to_le32(p->clk_id);\n\t \n\tmsg->rate_index = cpu_to_le32(desc_index);\n}\n\nstatic int\niter_clk_describe_update_state(struct scmi_iterator_state *st,\n\t\t\t       const void *response, void *priv)\n{\n\tu32 flags;\n\tstruct scmi_clk_ipriv *p = priv;\n\tconst struct scmi_msg_resp_clock_describe_rates *r = response;\n\n\tflags = le32_to_cpu(r->num_rates_flags);\n\tst->num_remaining = NUM_REMAINING(flags);\n\tst->num_returned = NUM_RETURNED(flags);\n\tp->clk->rate_discrete = RATE_DISCRETE(flags);\n\n\t \n\tif (!p->clk->rate_discrete &&\n\t    (st->num_returned != 3 || st->num_remaining != 0)) {\n\t\tdev_warn(p->dev,\n\t\t\t \"Out-of-spec CLOCK_DESCRIBE_RATES reply for %s - returned:%d remaining:%d rx_len:%zd\\n\",\n\t\t\t p->clk->name, st->num_returned, st->num_remaining,\n\t\t\t st->rx_len);\n\n\t\t \n\t\tif (st->num_returned != 3 && st->num_remaining == 0 &&\n\t\t    st->rx_len == sizeof(*r) + sizeof(__le32) * 2 * 3) {\n\t\t\tst->num_returned = 3;\n\t\t\tst->num_remaining = 0;\n\t\t} else {\n\t\t\tdev_err(p->dev,\n\t\t\t\t\"Cannot fix out-of-spec reply !\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\niter_clk_describe_process_response(const struct scmi_protocol_handle *ph,\n\t\t\t\t   const void *response,\n\t\t\t\t   struct scmi_iterator_state *st, void *priv)\n{\n\tint ret = 0;\n\tstruct scmi_clk_ipriv *p = priv;\n\tconst struct scmi_msg_resp_clock_describe_rates *r = response;\n\n\tif (!p->clk->rate_discrete) {\n\t\tswitch (st->desc_index + st->loop_idx) {\n\t\tcase 0:\n\t\t\tp->clk->range.min_rate = RATE_TO_U64(r->rate[0]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tp->clk->range.max_rate = RATE_TO_U64(r->rate[1]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp->clk->range.step_size = RATE_TO_U64(r->rate[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tu64 *rate = &p->clk->list.rates[st->desc_index + st->loop_idx];\n\n\t\t*rate = RATE_TO_U64(r->rate[st->loop_idx]);\n\t\tp->clk->list.num_rates++;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nscmi_clock_describe_rates_get(const struct scmi_protocol_handle *ph, u32 clk_id,\n\t\t\t      struct scmi_clock_info *clk)\n{\n\tint ret;\n\tvoid *iter;\n\tstruct scmi_iterator_ops ops = {\n\t\t.prepare_message = iter_clk_describe_prepare_message,\n\t\t.update_state = iter_clk_describe_update_state,\n\t\t.process_response = iter_clk_describe_process_response,\n\t};\n\tstruct scmi_clk_ipriv cpriv = {\n\t\t.clk_id = clk_id,\n\t\t.clk = clk,\n\t\t.dev = ph->dev,\n\t};\n\n\titer = ph->hops->iter_response_init(ph, &ops, SCMI_MAX_NUM_RATES,\n\t\t\t\t\t    CLOCK_DESCRIBE_RATES,\n\t\t\t\t\t    sizeof(struct scmi_msg_clock_describe_rates),\n\t\t\t\t\t    &cpriv);\n\tif (IS_ERR(iter))\n\t\treturn PTR_ERR(iter);\n\n\tret = ph->hops->iter_response_run(iter);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!clk->rate_discrete) {\n\t\tdev_dbg(ph->dev, \"Min %llu Max %llu Step %llu Hz\\n\",\n\t\t\tclk->range.min_rate, clk->range.max_rate,\n\t\t\tclk->range.step_size);\n\t} else if (clk->list.num_rates) {\n\t\tsort(clk->list.rates, clk->list.num_rates,\n\t\t     sizeof(clk->list.rates[0]), rate_cmp_func, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nscmi_clock_rate_get(const struct scmi_protocol_handle *ph,\n\t\t    u32 clk_id, u64 *value)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, CLOCK_RATE_GET,\n\t\t\t\t      sizeof(__le32), sizeof(u64), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(clk_id, t->tx.buf);\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\t*value = get_unaligned_le64(t->rx.buf);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_clock_rate_set(const struct scmi_protocol_handle *ph,\n\t\t\t       u32 clk_id, u64 rate)\n{\n\tint ret;\n\tu32 flags = 0;\n\tstruct scmi_xfer *t;\n\tstruct scmi_clock_set_rate *cfg;\n\tstruct clock_info *ci = ph->get_priv(ph);\n\n\tret = ph->xops->xfer_get_init(ph, CLOCK_RATE_SET, sizeof(*cfg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ci->max_async_req &&\n\t    atomic_inc_return(&ci->cur_async_req) < ci->max_async_req)\n\t\tflags |= CLOCK_SET_ASYNC;\n\n\tcfg = t->tx.buf;\n\tcfg->flags = cpu_to_le32(flags);\n\tcfg->id = cpu_to_le32(clk_id);\n\tcfg->value_low = cpu_to_le32(rate & 0xffffffff);\n\tcfg->value_high = cpu_to_le32(rate >> 32);\n\n\tif (flags & CLOCK_SET_ASYNC) {\n\t\tret = ph->xops->do_xfer_with_response(ph, t);\n\t\tif (!ret) {\n\t\t\tstruct scmi_msg_resp_set_rate_complete *resp;\n\n\t\t\tresp = t->rx.buf;\n\t\t\tif (le32_to_cpu(resp->id) == clk_id)\n\t\t\t\tdev_dbg(ph->dev,\n\t\t\t\t\t\"Clk ID %d set async to %llu\\n\", clk_id,\n\t\t\t\t\tget_unaligned_le64(&resp->rate_low));\n\t\t\telse\n\t\t\t\tret = -EPROTO;\n\t\t}\n\t} else {\n\t\tret = ph->xops->do_xfer(ph, t);\n\t}\n\n\tif (ci->max_async_req)\n\t\tatomic_dec(&ci->cur_async_req);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int\nscmi_clock_config_set(const struct scmi_protocol_handle *ph, u32 clk_id,\n\t\t      u32 config, bool atomic)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_clock_set_config *cfg;\n\n\tret = ph->xops->xfer_get_init(ph, CLOCK_CONFIG_SET,\n\t\t\t\t      sizeof(*cfg), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tt->hdr.poll_completion = atomic;\n\n\tcfg = t->tx.buf;\n\tcfg->id = cpu_to_le32(clk_id);\n\tcfg->attributes = cpu_to_le32(config);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_clock_enable(const struct scmi_protocol_handle *ph, u32 clk_id)\n{\n\treturn scmi_clock_config_set(ph, clk_id, CLOCK_ENABLE, false);\n}\n\nstatic int scmi_clock_disable(const struct scmi_protocol_handle *ph, u32 clk_id)\n{\n\treturn scmi_clock_config_set(ph, clk_id, 0, false);\n}\n\nstatic int scmi_clock_enable_atomic(const struct scmi_protocol_handle *ph,\n\t\t\t\t    u32 clk_id)\n{\n\treturn scmi_clock_config_set(ph, clk_id, CLOCK_ENABLE, true);\n}\n\nstatic int scmi_clock_disable_atomic(const struct scmi_protocol_handle *ph,\n\t\t\t\t     u32 clk_id)\n{\n\treturn scmi_clock_config_set(ph, clk_id, 0, true);\n}\n\nstatic int scmi_clock_count_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct clock_info *ci = ph->get_priv(ph);\n\n\treturn ci->num_clocks;\n}\n\nstatic const struct scmi_clock_info *\nscmi_clock_info_get(const struct scmi_protocol_handle *ph, u32 clk_id)\n{\n\tstruct scmi_clock_info *clk;\n\tstruct clock_info *ci = ph->get_priv(ph);\n\n\tif (clk_id >= ci->num_clocks)\n\t\treturn NULL;\n\n\tclk = ci->clk + clk_id;\n\tif (!clk->name[0])\n\t\treturn NULL;\n\n\treturn clk;\n}\n\nstatic const struct scmi_clk_proto_ops clk_proto_ops = {\n\t.count_get = scmi_clock_count_get,\n\t.info_get = scmi_clock_info_get,\n\t.rate_get = scmi_clock_rate_get,\n\t.rate_set = scmi_clock_rate_set,\n\t.enable = scmi_clock_enable,\n\t.disable = scmi_clock_disable,\n\t.enable_atomic = scmi_clock_enable_atomic,\n\t.disable_atomic = scmi_clock_disable_atomic,\n};\n\nstatic int scmi_clk_rate_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 clk_id, int message_id, bool enable)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_clock_rate_notify *notify;\n\n\tret = ph->xops->xfer_get_init(ph, message_id, sizeof(*notify), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tnotify = t->tx.buf;\n\tnotify->clk_id = cpu_to_le32(clk_id);\n\tnotify->notify_enable = enable ? cpu_to_le32(BIT(0)) : 0;\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_clk_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t       u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret, cmd_id;\n\n\tif (evt_id >= ARRAY_SIZE(evt_2_cmd))\n\t\treturn -EINVAL;\n\n\tcmd_id = evt_2_cmd[evt_id];\n\tret = scmi_clk_rate_notify(ph, src_id, cmd_id, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLED - evt[%X] dom[%d] - ret:%d\\n\",\n\t\t\t evt_id, src_id, ret);\n\n\treturn ret;\n}\n\nstatic void *scmi_clk_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u8 evt_id, ktime_t timestamp,\n\t\t\t\t\t const void *payld, size_t payld_sz,\n\t\t\t\t\t void *report, u32 *src_id)\n{\n\tconst struct scmi_clock_rate_notify_payld *p = payld;\n\tstruct scmi_clock_rate_notif_report *r = report;\n\n\tif (sizeof(*p) != payld_sz ||\n\t    (evt_id != SCMI_EVENT_CLOCK_RATE_CHANGED &&\n\t     evt_id != SCMI_EVENT_CLOCK_RATE_CHANGE_REQUESTED))\n\t\treturn NULL;\n\n\tr->timestamp = timestamp;\n\tr->agent_id = le32_to_cpu(p->agent_id);\n\tr->clock_id = le32_to_cpu(p->clock_id);\n\tr->rate = get_unaligned_le64(&p->rate_low);\n\t*src_id = r->clock_id;\n\n\treturn r;\n}\n\nstatic int scmi_clk_get_num_sources(const struct scmi_protocol_handle *ph)\n{\n\tstruct clock_info *ci = ph->get_priv(ph);\n\n\tif (!ci)\n\t\treturn -EINVAL;\n\n\treturn ci->num_clocks;\n}\n\nstatic const struct scmi_event clk_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_CLOCK_RATE_CHANGED,\n\t\t.max_payld_sz = sizeof(struct scmi_clock_rate_notify_payld),\n\t\t.max_report_sz = sizeof(struct scmi_clock_rate_notif_report),\n\t},\n\t{\n\t\t.id = SCMI_EVENT_CLOCK_RATE_CHANGE_REQUESTED,\n\t\t.max_payld_sz = sizeof(struct scmi_clock_rate_notify_payld),\n\t\t.max_report_sz = sizeof(struct scmi_clock_rate_notif_report),\n\t},\n};\n\nstatic const struct scmi_event_ops clk_event_ops = {\n\t.get_num_sources = scmi_clk_get_num_sources,\n\t.set_notify_enabled = scmi_clk_set_notify_enabled,\n\t.fill_custom_report = scmi_clk_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events clk_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &clk_event_ops,\n\t.evts = clk_events,\n\t.num_events = ARRAY_SIZE(clk_events),\n};\n\nstatic int scmi_clock_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tu32 version;\n\tint clkid, ret;\n\tstruct clock_info *cinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Clock Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tcinfo = devm_kzalloc(ph->dev, sizeof(*cinfo), GFP_KERNEL);\n\tif (!cinfo)\n\t\treturn -ENOMEM;\n\n\tret = scmi_clock_protocol_attributes_get(ph, cinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tcinfo->clk = devm_kcalloc(ph->dev, cinfo->num_clocks,\n\t\t\t\t  sizeof(*cinfo->clk), GFP_KERNEL);\n\tif (!cinfo->clk)\n\t\treturn -ENOMEM;\n\n\tfor (clkid = 0; clkid < cinfo->num_clocks; clkid++) {\n\t\tstruct scmi_clock_info *clk = cinfo->clk + clkid;\n\n\t\tret = scmi_clock_attributes_get(ph, clkid, clk, version);\n\t\tif (!ret)\n\t\t\tscmi_clock_describe_rates_get(ph, clkid, clk);\n\t}\n\n\tcinfo->version = version;\n\treturn ph->set_priv(ph, cinfo);\n}\n\nstatic const struct scmi_protocol scmi_clock = {\n\t.id = SCMI_PROTOCOL_CLOCK,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_clock_protocol_init,\n\t.ops = &clk_proto_ops,\n\t.events = &clk_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(clock, scmi_clock)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}