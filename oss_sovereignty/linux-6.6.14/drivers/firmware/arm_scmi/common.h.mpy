{
  "module_name": "common.h",
  "hash_id": "f69bc43365e0e641d34c4b0d4cd814ef751e176066ef7e43765863b4df9b5689",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/common.h",
  "human_readable_source": " \n \n#ifndef _SCMI_COMMON_H\n#define _SCMI_COMMON_H\n\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/refcount.h>\n#include <linux/scmi_protocol.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <asm/unaligned.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\n#define SCMI_MAX_CHANNELS\t\t256\n\n#define SCMI_MAX_RESPONSE_TIMEOUT\t(2 * MSEC_PER_SEC)\n\nenum scmi_error_codes {\n\tSCMI_SUCCESS = 0,\t \n\tSCMI_ERR_SUPPORT = -1,\t \n\tSCMI_ERR_PARAMS = -2,\t \n\tSCMI_ERR_ACCESS = -3,\t \n\tSCMI_ERR_ENTRY = -4,\t \n\tSCMI_ERR_RANGE = -5,\t \n\tSCMI_ERR_BUSY = -6,\t \n\tSCMI_ERR_COMMS = -7,\t \n\tSCMI_ERR_GENERIC = -8,\t \n\tSCMI_ERR_HARDWARE = -9,\t \n\tSCMI_ERR_PROTOCOL = -10, \n};\n\nstatic const int scmi_linux_errmap[] = {\n\t \n\t0,\t\t\t \n\t-EOPNOTSUPP,\t\t \n\t-EINVAL,\t\t \n\t-EACCES,\t\t \n\t-ENOENT,\t\t \n\t-ERANGE,\t\t \n\t-EBUSY,\t\t\t \n\t-ECOMM,\t\t\t \n\t-EIO,\t\t\t \n\t-EREMOTEIO,\t\t \n\t-EPROTO,\t\t \n};\n\nstatic inline int scmi_to_linux_errno(int errno)\n{\n\tint err_idx = -errno;\n\n\tif (err_idx >= SCMI_SUCCESS && err_idx < ARRAY_SIZE(scmi_linux_errmap))\n\t\treturn scmi_linux_errmap[err_idx];\n\treturn -EIO;\n}\n\n#define MSG_ID_MASK\t\tGENMASK(7, 0)\n#define MSG_XTRACT_ID(hdr)\tFIELD_GET(MSG_ID_MASK, (hdr))\n#define MSG_TYPE_MASK\t\tGENMASK(9, 8)\n#define MSG_XTRACT_TYPE(hdr)\tFIELD_GET(MSG_TYPE_MASK, (hdr))\n#define MSG_TYPE_COMMAND\t0\n#define MSG_TYPE_DELAYED_RESP\t2\n#define MSG_TYPE_NOTIFICATION\t3\n#define MSG_PROTOCOL_ID_MASK\tGENMASK(17, 10)\n#define MSG_XTRACT_PROT_ID(hdr)\tFIELD_GET(MSG_PROTOCOL_ID_MASK, (hdr))\n#define MSG_TOKEN_ID_MASK\tGENMASK(27, 18)\n#define MSG_XTRACT_TOKEN(hdr)\tFIELD_GET(MSG_TOKEN_ID_MASK, (hdr))\n#define MSG_TOKEN_MAX\t\t(MSG_XTRACT_TOKEN(MSG_TOKEN_ID_MASK) + 1)\n\n \n#define SCMI_PENDING_XFERS_HT_ORDER_SZ\t\t9\n\n \nstatic inline u32 pack_scmi_header(struct scmi_msg_hdr *hdr)\n{\n\treturn FIELD_PREP(MSG_ID_MASK, hdr->id) |\n\t\tFIELD_PREP(MSG_TYPE_MASK, hdr->type) |\n\t\tFIELD_PREP(MSG_TOKEN_ID_MASK, hdr->seq) |\n\t\tFIELD_PREP(MSG_PROTOCOL_ID_MASK, hdr->protocol_id);\n}\n\n \nstatic inline void unpack_scmi_header(u32 msg_hdr, struct scmi_msg_hdr *hdr)\n{\n\thdr->id = MSG_XTRACT_ID(msg_hdr);\n\thdr->protocol_id = MSG_XTRACT_PROT_ID(msg_hdr);\n\thdr->type = MSG_XTRACT_TYPE(msg_hdr);\n}\n\n \n#define XFER_FIND(__ht, __k)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\ttypeof(__k) k_ = __k;\t\t\t\t\t\\\n\tstruct scmi_xfer *xfer_ = NULL;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\thash_for_each_possible((__ht), xfer_, node, k_)\t\t\\\n\t\tif (xfer_->hdr.seq == k_)\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\txfer_;\t\t\t\t\t\t\t\\\n})\n\nstruct scmi_revision_info *\nscmi_revision_area_get(const struct scmi_protocol_handle *ph);\nvoid scmi_setup_protocol_implemented(const struct scmi_protocol_handle *ph,\n\t\t\t\t     u8 *prot_imp);\n\nextern struct bus_type scmi_bus_type;\n\n#define SCMI_BUS_NOTIFY_DEVICE_REQUEST\t\t0\n#define SCMI_BUS_NOTIFY_DEVICE_UNREQUEST\t1\nextern struct blocking_notifier_head scmi_requested_devices_nh;\n\nstruct scmi_device *scmi_device_create(struct device_node *np,\n\t\t\t\t       struct device *parent, int protocol,\n\t\t\t\t       const char *name);\nvoid scmi_device_destroy(struct device *parent, int protocol, const char *name);\n\nint scmi_protocol_acquire(const struct scmi_handle *handle, u8 protocol_id);\nvoid scmi_protocol_release(const struct scmi_handle *handle, u8 protocol_id);\n\n \n \nstruct scmi_chan_info {\n\tint id;\n\tstruct device *dev;\n\tunsigned int rx_timeout_ms;\n\tstruct scmi_handle *handle;\n\tbool no_completion_irq;\n\tvoid *transport_info;\n};\n\n \nstruct scmi_transport_ops {\n\tint (*link_supplier)(struct device *dev);\n\tbool (*chan_available)(struct device_node *of_node, int idx);\n\tint (*chan_setup)(struct scmi_chan_info *cinfo, struct device *dev,\n\t\t\t  bool tx);\n\tint (*chan_free)(int id, void *p, void *data);\n\tunsigned int (*get_max_msg)(struct scmi_chan_info *base_cinfo);\n\tint (*send_message)(struct scmi_chan_info *cinfo,\n\t\t\t    struct scmi_xfer *xfer);\n\tvoid (*mark_txdone)(struct scmi_chan_info *cinfo, int ret,\n\t\t\t    struct scmi_xfer *xfer);\n\tvoid (*fetch_response)(struct scmi_chan_info *cinfo,\n\t\t\t       struct scmi_xfer *xfer);\n\tvoid (*fetch_notification)(struct scmi_chan_info *cinfo,\n\t\t\t\t   size_t max_len, struct scmi_xfer *xfer);\n\tvoid (*clear_channel)(struct scmi_chan_info *cinfo);\n\tbool (*poll_done)(struct scmi_chan_info *cinfo, struct scmi_xfer *xfer);\n};\n\n \nstruct scmi_desc {\n\tint (*transport_init)(void);\n\tvoid (*transport_exit)(void);\n\tconst struct scmi_transport_ops *ops;\n\tint max_rx_timeout_ms;\n\tint max_msg;\n\tint max_msg_size;\n\tconst bool force_polling;\n\tconst bool sync_cmds_completed_on_ret;\n\tconst bool atomic_enabled;\n};\n\nstatic inline bool is_polling_required(struct scmi_chan_info *cinfo,\n\t\t\t\t       const struct scmi_desc *desc)\n{\n\treturn cinfo->no_completion_irq || desc->force_polling;\n}\n\nstatic inline bool is_transport_polling_capable(const struct scmi_desc *desc)\n{\n\treturn desc->ops->poll_done || desc->sync_cmds_completed_on_ret;\n}\n\nstatic inline bool is_polling_enabled(struct scmi_chan_info *cinfo,\n\t\t\t\t      const struct scmi_desc *desc)\n{\n\treturn is_polling_required(cinfo, desc) &&\n\t\tis_transport_polling_capable(desc);\n}\n\nvoid scmi_xfer_raw_put(const struct scmi_handle *handle,\n\t\t       struct scmi_xfer *xfer);\nstruct scmi_xfer *scmi_xfer_raw_get(const struct scmi_handle *handle);\nstruct scmi_chan_info *\nscmi_xfer_raw_channel_get(const struct scmi_handle *handle, u8 protocol_id);\n\nint scmi_xfer_raw_inflight_register(const struct scmi_handle *handle,\n\t\t\t\t    struct scmi_xfer *xfer);\n\nint scmi_xfer_raw_wait_for_message_response(struct scmi_chan_info *cinfo,\n\t\t\t\t\t    struct scmi_xfer *xfer,\n\t\t\t\t\t    unsigned int timeout_ms);\n#ifdef CONFIG_ARM_SCMI_TRANSPORT_MAILBOX\nextern const struct scmi_desc scmi_mailbox_desc;\n#endif\n#ifdef CONFIG_ARM_SCMI_TRANSPORT_SMC\nextern const struct scmi_desc scmi_smc_desc;\n#endif\n#ifdef CONFIG_ARM_SCMI_TRANSPORT_VIRTIO\nextern const struct scmi_desc scmi_virtio_desc;\n#endif\n#ifdef CONFIG_ARM_SCMI_TRANSPORT_OPTEE\nextern const struct scmi_desc scmi_optee_desc;\n#endif\n\nvoid scmi_rx_callback(struct scmi_chan_info *cinfo, u32 msg_hdr, void *priv);\n\n \nstruct scmi_shared_mem;\n\nvoid shmem_tx_prepare(struct scmi_shared_mem __iomem *shmem,\n\t\t      struct scmi_xfer *xfer, struct scmi_chan_info *cinfo);\nu32 shmem_read_header(struct scmi_shared_mem __iomem *shmem);\nvoid shmem_fetch_response(struct scmi_shared_mem __iomem *shmem,\n\t\t\t  struct scmi_xfer *xfer);\nvoid shmem_fetch_notification(struct scmi_shared_mem __iomem *shmem,\n\t\t\t      size_t max_len, struct scmi_xfer *xfer);\nvoid shmem_clear_channel(struct scmi_shared_mem __iomem *shmem);\nbool shmem_poll_done(struct scmi_shared_mem __iomem *shmem,\n\t\t     struct scmi_xfer *xfer);\n\n \nstruct scmi_msg_payld;\n\n \n#define SCMI_MSG_MAX_PROT_OVERHEAD (2 * sizeof(__le32))\n\nsize_t msg_response_size(struct scmi_xfer *xfer);\nsize_t msg_command_size(struct scmi_xfer *xfer);\nvoid msg_tx_prepare(struct scmi_msg_payld *msg, struct scmi_xfer *xfer);\nu32 msg_read_header(struct scmi_msg_payld *msg);\nvoid msg_fetch_response(struct scmi_msg_payld *msg, size_t len,\n\t\t\tstruct scmi_xfer *xfer);\nvoid msg_fetch_notification(struct scmi_msg_payld *msg, size_t len,\n\t\t\t    size_t max_len, struct scmi_xfer *xfer);\n\nvoid scmi_notification_instance_data_set(const struct scmi_handle *handle,\n\t\t\t\t\t void *priv);\nvoid *scmi_notification_instance_data_get(const struct scmi_handle *handle);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}