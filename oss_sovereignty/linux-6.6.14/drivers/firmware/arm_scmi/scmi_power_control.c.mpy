{
  "module_name": "scmi_power_control.c",
  "hash_id": "759bf125a105da9b9278eace42064855f89d164af820f82c4ccf3b951f8a526b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/scmi_power_control.c",
  "human_readable_source": "\n \n \n\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/printk.h>\n#include <linux/reboot.h>\n#include <linux/scmi_protocol.h>\n#include <linux/slab.h>\n#include <linux/time64.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#ifndef MODULE\n#include <linux/fs.h>\n#endif\n\nenum scmi_syspower_state {\n\tSCMI_SYSPOWER_IDLE,\n\tSCMI_SYSPOWER_IN_PROGRESS,\n\tSCMI_SYSPOWER_REBOOTING\n};\n\n \nstruct scmi_syspower_conf {\n\tstruct device *dev;\n\tenum scmi_syspower_state state;\n\t \n\tstruct mutex state_mtx;\n\tenum scmi_system_events required_transition;\n\n\tstruct notifier_block userspace_nb;\n\tstruct notifier_block reboot_nb;\n\n\tstruct delayed_work forceful_work;\n};\n\n#define userspace_nb_to_sconf(x)\t\\\n\tcontainer_of(x, struct scmi_syspower_conf, userspace_nb)\n\n#define reboot_nb_to_sconf(x)\t\t\\\n\tcontainer_of(x, struct scmi_syspower_conf, reboot_nb)\n\n#define dwork_to_sconf(x)\t\t\\\n\tcontainer_of(x, struct scmi_syspower_conf, forceful_work)\n\n \nstatic int scmi_reboot_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long reason, void *__unused)\n{\n\tstruct scmi_syspower_conf *sc = reboot_nb_to_sconf(nb);\n\n\tmutex_lock(&sc->state_mtx);\n\tswitch (reason) {\n\tcase SYS_HALT:\n\tcase SYS_POWER_OFF:\n\t\tif (sc->required_transition == SCMI_SYSTEM_SHUTDOWN)\n\t\t\tsc->state = SCMI_SYSPOWER_REBOOTING;\n\t\tbreak;\n\tcase SYS_RESTART:\n\t\tif (sc->required_transition == SCMI_SYSTEM_COLDRESET ||\n\t\t    sc->required_transition == SCMI_SYSTEM_WARMRESET)\n\t\t\tsc->state = SCMI_SYSPOWER_REBOOTING;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->state == SCMI_SYSPOWER_REBOOTING) {\n\t\tdev_dbg(sc->dev, \"Reboot in progress...cancel delayed work.\\n\");\n\t\tcancel_delayed_work_sync(&sc->forceful_work);\n\t}\n\tmutex_unlock(&sc->state_mtx);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic inline void\nscmi_request_forceful_transition(struct scmi_syspower_conf *sc)\n{\n\tdev_dbg(sc->dev, \"Serving forceful request:%d\\n\",\n\t\tsc->required_transition);\n\n#ifndef MODULE\n\temergency_sync();\n#endif\n\tswitch (sc->required_transition) {\n\tcase SCMI_SYSTEM_SHUTDOWN:\n\t\tkernel_power_off();\n\t\tbreak;\n\tcase SCMI_SYSTEM_COLDRESET:\n\tcase SCMI_SYSTEM_WARMRESET:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void scmi_forceful_work_func(struct work_struct *work)\n{\n\tstruct scmi_syspower_conf *sc;\n\tstruct delayed_work *dwork;\n\n\tif (system_state > SYSTEM_RUNNING)\n\t\treturn;\n\n\tdwork = to_delayed_work(work);\n\tsc = dwork_to_sconf(dwork);\n\n\tdev_dbg(sc->dev, \"Graceful request timed out...forcing !\\n\");\n\tmutex_lock(&sc->state_mtx);\n\t \n\tunregister_reboot_notifier(&sc->reboot_nb);\n\tif (sc->state == SCMI_SYSPOWER_IN_PROGRESS)\n\t\tscmi_request_forceful_transition(sc);\n\tmutex_unlock(&sc->state_mtx);\n}\n\n \nstatic void scmi_request_graceful_transition(struct scmi_syspower_conf *sc,\n\t\t\t\t\t     unsigned int timeout_ms)\n{\n\tunsigned int adj_timeout_ms = 0;\n\n\tif (timeout_ms) {\n\t\tint ret;\n\n\t\tsc->reboot_nb.notifier_call = &scmi_reboot_notifier;\n\t\tret = register_reboot_notifier(&sc->reboot_nb);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tadj_timeout_ms = mult_frac(timeout_ms, 3, 4);\n\t\t\tINIT_DELAYED_WORK(&sc->forceful_work,\n\t\t\t\t\t  scmi_forceful_work_func);\n\t\t\tschedule_delayed_work(&sc->forceful_work,\n\t\t\t\t\t      msecs_to_jiffies(adj_timeout_ms));\n\t\t} else {\n\t\t\t \n\t\t\tdev_warn(sc->dev,\n\t\t\t\t \"Cannot register reboot notifier !\\n\");\n\t\t}\n\t}\n\n\tdev_dbg(sc->dev,\n\t\t\"Serving graceful req:%d (timeout_ms:%u  adj_timeout_ms:%u)\\n\",\n\t\tsc->required_transition, timeout_ms, adj_timeout_ms);\n\n\tswitch (sc->required_transition) {\n\tcase SCMI_SYSTEM_SHUTDOWN:\n\t\t \n\t\torderly_poweroff(true);\n\t\tbreak;\n\tcase SCMI_SYSTEM_COLDRESET:\n\tcase SCMI_SYSTEM_WARMRESET:\n\t\torderly_reboot();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int scmi_userspace_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *data)\n{\n\tstruct scmi_system_power_state_notifier_report *er = data;\n\tstruct scmi_syspower_conf *sc = userspace_nb_to_sconf(nb);\n\n\tif (er->system_state >= SCMI_SYSTEM_POWERUP) {\n\t\tdev_err(sc->dev, \"Ignoring unsupported system_state: 0x%X\\n\",\n\t\t\ter->system_state);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (!SCMI_SYSPOWER_IS_REQUEST_GRACEFUL(er->flags)) {\n\t\tdev_err(sc->dev, \"Ignoring forceful notification.\\n\");\n\t\treturn NOTIFY_DONE;\n\t}\n\n\t \n\tif (system_state > SYSTEM_RUNNING)\n\t\treturn NOTIFY_DONE;\n\tmutex_lock(&sc->state_mtx);\n\tif (sc->state != SCMI_SYSPOWER_IDLE) {\n\t\tdev_dbg(sc->dev,\n\t\t\t\"Transition already in progress...ignore.\\n\");\n\t\tmutex_unlock(&sc->state_mtx);\n\t\treturn NOTIFY_DONE;\n\t}\n\tsc->state = SCMI_SYSPOWER_IN_PROGRESS;\n\tmutex_unlock(&sc->state_mtx);\n\n\tsc->required_transition = er->system_state;\n\n\t \n\tdev_info(sc->dev, \"Serving shutdown/reboot request: %d\\n\",\n\t\t sc->required_transition);\n\n\tscmi_request_graceful_transition(sc, er->timeout);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int scmi_syspower_probe(struct scmi_device *sdev)\n{\n\tint ret;\n\tstruct scmi_syspower_conf *sc;\n\tstruct scmi_handle *handle = sdev->handle;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tret = handle->devm_protocol_acquire(sdev, SCMI_PROTOCOL_SYSTEM);\n\tif (ret)\n\t\treturn ret;\n\n\tsc = devm_kzalloc(&sdev->dev, sizeof(*sc), GFP_KERNEL);\n\tif (!sc)\n\t\treturn -ENOMEM;\n\n\tsc->state = SCMI_SYSPOWER_IDLE;\n\tmutex_init(&sc->state_mtx);\n\tsc->required_transition = SCMI_SYSTEM_MAX;\n\tsc->userspace_nb.notifier_call = &scmi_userspace_notifier;\n\tsc->dev = &sdev->dev;\n\n\treturn handle->notify_ops->devm_event_notifier_register(sdev,\n\t\t\t\t\t\t\t   SCMI_PROTOCOL_SYSTEM,\n\t\t\t\t\t SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER,\n\t\t\t\t\t\t       NULL, &sc->userspace_nb);\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_SYSTEM, \"syspower\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_system_power_driver = {\n\t.name = \"scmi-system-power\",\n\t.probe = scmi_syspower_probe,\n\t.id_table = scmi_id_table,\n};\nmodule_scmi_driver(scmi_system_power_driver);\n\nMODULE_AUTHOR(\"Cristian Marussi <cristian.marussi@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI SystemPower Control driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}