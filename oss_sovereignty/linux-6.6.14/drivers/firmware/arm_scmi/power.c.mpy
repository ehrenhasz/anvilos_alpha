{
  "module_name": "power.c",
  "hash_id": "da0b0445ab500cebb92c1d9b72057c76bd241b2a58f863aa0f902a154330596a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scmi/power.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"SCMI Notifications POWER - \" fmt\n\n#include <linux/module.h>\n#include <linux/scmi_protocol.h>\n\n#include \"protocols.h\"\n#include \"notify.h\"\n\nenum scmi_power_protocol_cmd {\n\tPOWER_DOMAIN_ATTRIBUTES = 0x3,\n\tPOWER_STATE_SET = 0x4,\n\tPOWER_STATE_GET = 0x5,\n\tPOWER_STATE_NOTIFY = 0x6,\n\tPOWER_DOMAIN_NAME_GET = 0x8,\n};\n\nstruct scmi_msg_resp_power_attributes {\n\t__le16 num_domains;\n\t__le16 reserved;\n\t__le32 stats_addr_low;\n\t__le32 stats_addr_high;\n\t__le32 stats_size;\n};\n\nstruct scmi_msg_resp_power_domain_attributes {\n\t__le32 flags;\n#define SUPPORTS_STATE_SET_NOTIFY(x)\t((x) & BIT(31))\n#define SUPPORTS_STATE_SET_ASYNC(x)\t((x) & BIT(30))\n#define SUPPORTS_STATE_SET_SYNC(x)\t((x) & BIT(29))\n#define SUPPORTS_EXTENDED_NAMES(x)\t((x) & BIT(27))\n\t    u8 name[SCMI_SHORT_NAME_MAX_SIZE];\n};\n\nstruct scmi_power_set_state {\n\t__le32 flags;\n#define STATE_SET_ASYNC\t\tBIT(0)\n\t__le32 domain;\n\t__le32 state;\n};\n\nstruct scmi_power_state_notify {\n\t__le32 domain;\n\t__le32 notify_enable;\n};\n\nstruct scmi_power_state_notify_payld {\n\t__le32 agent_id;\n\t__le32 domain_id;\n\t__le32 power_state;\n};\n\nstruct power_dom_info {\n\tbool state_set_sync;\n\tbool state_set_async;\n\tbool state_set_notify;\n\tchar name[SCMI_MAX_STR_SIZE];\n};\n\nstruct scmi_power_info {\n\tu32 version;\n\tint num_domains;\n\tu64 stats_addr;\n\tu32 stats_size;\n\tstruct power_dom_info *dom_info;\n};\n\nstatic int scmi_power_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t     struct scmi_power_info *pi)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_power_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, PROTOCOL_ATTRIBUTES,\n\t\t\t\t      0, sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tpi->num_domains = le16_to_cpu(attr->num_domains);\n\t\tpi->stats_addr = le32_to_cpu(attr->stats_addr_low) |\n\t\t\t\t(u64)le32_to_cpu(attr->stats_addr_high) << 32;\n\t\tpi->stats_size = le32_to_cpu(attr->stats_size);\n\t}\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int\nscmi_power_domain_attributes_get(const struct scmi_protocol_handle *ph,\n\t\t\t\t u32 domain, struct power_dom_info *dom_info,\n\t\t\t\t u32 version)\n{\n\tint ret;\n\tu32 flags;\n\tstruct scmi_xfer *t;\n\tstruct scmi_msg_resp_power_domain_attributes *attr;\n\n\tret = ph->xops->xfer_get_init(ph, POWER_DOMAIN_ATTRIBUTES,\n\t\t\t\t      sizeof(domain), sizeof(*attr), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain, t->tx.buf);\n\tattr = t->rx.buf;\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret) {\n\t\tflags = le32_to_cpu(attr->flags);\n\n\t\tdom_info->state_set_notify = SUPPORTS_STATE_SET_NOTIFY(flags);\n\t\tdom_info->state_set_async = SUPPORTS_STATE_SET_ASYNC(flags);\n\t\tdom_info->state_set_sync = SUPPORTS_STATE_SET_SYNC(flags);\n\t\tstrscpy(dom_info->name, attr->name, SCMI_SHORT_NAME_MAX_SIZE);\n\t}\n\tph->xops->xfer_put(ph, t);\n\n\t \n\tif (!ret && PROTOCOL_REV_MAJOR(version) >= 0x3 &&\n\t    SUPPORTS_EXTENDED_NAMES(flags)) {\n\t\tph->hops->extended_name_get(ph, POWER_DOMAIN_NAME_GET,\n\t\t\t\t\t    domain, dom_info->name,\n\t\t\t\t\t    SCMI_MAX_STR_SIZE);\n\t}\n\n\treturn ret;\n}\n\nstatic int scmi_power_state_set(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain, u32 state)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_power_set_state *st;\n\n\tret = ph->xops->xfer_get_init(ph, POWER_STATE_SET, sizeof(*st), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tst = t->tx.buf;\n\tst->flags = cpu_to_le32(0);\n\tst->domain = cpu_to_le32(domain);\n\tst->state = cpu_to_le32(state);\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_power_state_get(const struct scmi_protocol_handle *ph,\n\t\t\t\tu32 domain, u32 *state)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\n\tret = ph->xops->xfer_get_init(ph, POWER_STATE_GET, sizeof(u32), sizeof(u32), &t);\n\tif (ret)\n\t\treturn ret;\n\n\tput_unaligned_le32(domain, t->tx.buf);\n\n\tret = ph->xops->do_xfer(ph, t);\n\tif (!ret)\n\t\t*state = get_unaligned_le32(t->rx.buf);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_power_num_domains_get(const struct scmi_protocol_handle *ph)\n{\n\tstruct scmi_power_info *pi = ph->get_priv(ph);\n\n\treturn pi->num_domains;\n}\n\nstatic const char *\nscmi_power_name_get(const struct scmi_protocol_handle *ph,\n\t\t    u32 domain)\n{\n\tstruct scmi_power_info *pi = ph->get_priv(ph);\n\tstruct power_dom_info *dom = pi->dom_info + domain;\n\n\treturn dom->name;\n}\n\nstatic const struct scmi_power_proto_ops power_proto_ops = {\n\t.num_domains_get = scmi_power_num_domains_get,\n\t.name_get = scmi_power_name_get,\n\t.state_set = scmi_power_state_set,\n\t.state_get = scmi_power_state_get,\n};\n\nstatic int scmi_power_request_notify(const struct scmi_protocol_handle *ph,\n\t\t\t\t     u32 domain, bool enable)\n{\n\tint ret;\n\tstruct scmi_xfer *t;\n\tstruct scmi_power_state_notify *notify;\n\n\tret = ph->xops->xfer_get_init(ph, POWER_STATE_NOTIFY,\n\t\t\t\t      sizeof(*notify), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tnotify = t->tx.buf;\n\tnotify->domain = cpu_to_le32(domain);\n\tnotify->notify_enable = enable ? cpu_to_le32(BIT(0)) : 0;\n\n\tret = ph->xops->do_xfer(ph, t);\n\n\tph->xops->xfer_put(ph, t);\n\treturn ret;\n}\n\nstatic int scmi_power_set_notify_enabled(const struct scmi_protocol_handle *ph,\n\t\t\t\t\t u8 evt_id, u32 src_id, bool enable)\n{\n\tint ret;\n\n\tret = scmi_power_request_notify(ph, src_id, enable);\n\tif (ret)\n\t\tpr_debug(\"FAIL_ENABLE - evt[%X] dom[%d] - ret:%d\\n\",\n\t\t\t evt_id, src_id, ret);\n\n\treturn ret;\n}\n\nstatic void *\nscmi_power_fill_custom_report(const struct scmi_protocol_handle *ph,\n\t\t\t      u8 evt_id, ktime_t timestamp,\n\t\t\t      const void *payld, size_t payld_sz,\n\t\t\t      void *report, u32 *src_id)\n{\n\tconst struct scmi_power_state_notify_payld *p = payld;\n\tstruct scmi_power_state_changed_report *r = report;\n\n\tif (evt_id != SCMI_EVENT_POWER_STATE_CHANGED || sizeof(*p) != payld_sz)\n\t\treturn NULL;\n\n\tr->timestamp = timestamp;\n\tr->agent_id = le32_to_cpu(p->agent_id);\n\tr->domain_id = le32_to_cpu(p->domain_id);\n\tr->power_state = le32_to_cpu(p->power_state);\n\t*src_id = r->domain_id;\n\n\treturn r;\n}\n\nstatic int scmi_power_get_num_sources(const struct scmi_protocol_handle *ph)\n{\n\tstruct scmi_power_info *pinfo = ph->get_priv(ph);\n\n\tif (!pinfo)\n\t\treturn -EINVAL;\n\n\treturn pinfo->num_domains;\n}\n\nstatic const struct scmi_event power_events[] = {\n\t{\n\t\t.id = SCMI_EVENT_POWER_STATE_CHANGED,\n\t\t.max_payld_sz = sizeof(struct scmi_power_state_notify_payld),\n\t\t.max_report_sz =\n\t\t\tsizeof(struct scmi_power_state_changed_report),\n\t},\n};\n\nstatic const struct scmi_event_ops power_event_ops = {\n\t.get_num_sources = scmi_power_get_num_sources,\n\t.set_notify_enabled = scmi_power_set_notify_enabled,\n\t.fill_custom_report = scmi_power_fill_custom_report,\n};\n\nstatic const struct scmi_protocol_events power_protocol_events = {\n\t.queue_sz = SCMI_PROTO_QUEUE_SZ,\n\t.ops = &power_event_ops,\n\t.evts = power_events,\n\t.num_events = ARRAY_SIZE(power_events),\n};\n\nstatic int scmi_power_protocol_init(const struct scmi_protocol_handle *ph)\n{\n\tint domain, ret;\n\tu32 version;\n\tstruct scmi_power_info *pinfo;\n\n\tret = ph->xops->version_get(ph, &version);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ph->dev, \"Power Version %d.%d\\n\",\n\t\tPROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));\n\n\tpinfo = devm_kzalloc(ph->dev, sizeof(*pinfo), GFP_KERNEL);\n\tif (!pinfo)\n\t\treturn -ENOMEM;\n\n\tret = scmi_power_attributes_get(ph, pinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tpinfo->dom_info = devm_kcalloc(ph->dev, pinfo->num_domains,\n\t\t\t\t       sizeof(*pinfo->dom_info), GFP_KERNEL);\n\tif (!pinfo->dom_info)\n\t\treturn -ENOMEM;\n\n\tfor (domain = 0; domain < pinfo->num_domains; domain++) {\n\t\tstruct power_dom_info *dom = pinfo->dom_info + domain;\n\n\t\tscmi_power_domain_attributes_get(ph, domain, dom, version);\n\t}\n\n\tpinfo->version = version;\n\n\treturn ph->set_priv(ph, pinfo);\n}\n\nstatic const struct scmi_protocol scmi_power = {\n\t.id = SCMI_PROTOCOL_POWER,\n\t.owner = THIS_MODULE,\n\t.instance_init = &scmi_power_protocol_init,\n\t.ops = &power_proto_ops,\n\t.events = &power_protocol_events,\n};\n\nDEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(power, scmi_power)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}