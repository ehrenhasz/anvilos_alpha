{
  "module_name": "qcom_scm.c",
  "hash_id": "0cff46a80e90a9650d9414d482dd74e24d23a534eb06b427c3f78c862ebeca98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/qcom_scm.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/dma-mapping.h>\n#include <linux/interconnect.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/clk.h>\n#include <linux/reset-controller.h>\n#include <linux/arm-smccc.h>\n\n#include \"qcom_scm.h\"\n\nstatic bool download_mode = IS_ENABLED(CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT);\nmodule_param(download_mode, bool, 0);\n\nstruct qcom_scm {\n\tstruct device *dev;\n\tstruct clk *core_clk;\n\tstruct clk *iface_clk;\n\tstruct clk *bus_clk;\n\tstruct icc_path *path;\n\tstruct completion waitq_comp;\n\tstruct reset_controller_dev reset;\n\n\t \n\tstruct mutex scm_bw_lock;\n\tint scm_vote_count;\n\n\tu64 dload_mode_addr;\n};\n\nstruct qcom_scm_current_perm_info {\n\t__le32 vmid;\n\t__le32 perm;\n\t__le64 ctx;\n\t__le32 ctx_size;\n\t__le32 unused;\n};\n\nstruct qcom_scm_mem_map_info {\n\t__le64 mem_addr;\n\t__le64 mem_size;\n};\n\n \nstatic const u8 qcom_scm_cpu_cold_bits[QCOM_SCM_BOOT_MAX_CPUS] = {\n\t0, BIT(0), BIT(3), BIT(5)\n};\nstatic const u8 qcom_scm_cpu_warm_bits[QCOM_SCM_BOOT_MAX_CPUS] = {\n\tBIT(2), BIT(1), BIT(4), BIT(6)\n};\n\n#define QCOM_SMC_WAITQ_FLAG_WAKE_ONE\tBIT(0)\n#define QCOM_SMC_WAITQ_FLAG_WAKE_ALL\tBIT(1)\n\nstatic const char * const qcom_scm_convention_names[] = {\n\t[SMC_CONVENTION_UNKNOWN] = \"unknown\",\n\t[SMC_CONVENTION_ARM_32] = \"smc arm 32\",\n\t[SMC_CONVENTION_ARM_64] = \"smc arm 64\",\n\t[SMC_CONVENTION_LEGACY] = \"smc legacy\",\n};\n\nstatic struct qcom_scm *__scm;\n\nstatic int qcom_scm_clk_enable(void)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(__scm->core_clk);\n\tif (ret)\n\t\tgoto bail;\n\n\tret = clk_prepare_enable(__scm->iface_clk);\n\tif (ret)\n\t\tgoto disable_core;\n\n\tret = clk_prepare_enable(__scm->bus_clk);\n\tif (ret)\n\t\tgoto disable_iface;\n\n\treturn 0;\n\ndisable_iface:\n\tclk_disable_unprepare(__scm->iface_clk);\ndisable_core:\n\tclk_disable_unprepare(__scm->core_clk);\nbail:\n\treturn ret;\n}\n\nstatic void qcom_scm_clk_disable(void)\n{\n\tclk_disable_unprepare(__scm->core_clk);\n\tclk_disable_unprepare(__scm->iface_clk);\n\tclk_disable_unprepare(__scm->bus_clk);\n}\n\nstatic int qcom_scm_bw_enable(void)\n{\n\tint ret = 0;\n\n\tif (!__scm->path)\n\t\treturn 0;\n\n\tif (IS_ERR(__scm->path))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&__scm->scm_bw_lock);\n\tif (!__scm->scm_vote_count) {\n\t\tret = icc_set_bw(__scm->path, 0, UINT_MAX);\n\t\tif (ret < 0) {\n\t\t\tdev_err(__scm->dev, \"failed to set bandwidth request\\n\");\n\t\t\tgoto err_bw;\n\t\t}\n\t}\n\t__scm->scm_vote_count++;\nerr_bw:\n\tmutex_unlock(&__scm->scm_bw_lock);\n\n\treturn ret;\n}\n\nstatic void qcom_scm_bw_disable(void)\n{\n\tif (IS_ERR_OR_NULL(__scm->path))\n\t\treturn;\n\n\tmutex_lock(&__scm->scm_bw_lock);\n\tif (__scm->scm_vote_count-- == 1)\n\t\ticc_set_bw(__scm->path, 0, 0);\n\tmutex_unlock(&__scm->scm_bw_lock);\n}\n\nenum qcom_scm_convention qcom_scm_convention = SMC_CONVENTION_UNKNOWN;\nstatic DEFINE_SPINLOCK(scm_query_lock);\n\nstatic enum qcom_scm_convention __get_convention(void)\n{\n\tunsigned long flags;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_INFO,\n\t\t.cmd = QCOM_SCM_INFO_IS_CALL_AVAIL,\n\t\t.args[0] = SCM_SMC_FNID(QCOM_SCM_SVC_INFO,\n\t\t\t\t\t   QCOM_SCM_INFO_IS_CALL_AVAIL) |\n\t\t\t   (ARM_SMCCC_OWNER_SIP << ARM_SMCCC_OWNER_SHIFT),\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tenum qcom_scm_convention probed_convention;\n\tint ret;\n\tbool forced = false;\n\n\tif (likely(qcom_scm_convention != SMC_CONVENTION_UNKNOWN))\n\t\treturn qcom_scm_convention;\n\n\t \n#if IS_ENABLED(CONFIG_ARM64)\n\t \n\tprobed_convention = SMC_CONVENTION_ARM_64;\n\tret = __scm_smc_call(NULL, &desc, probed_convention, &res, true);\n\tif (!ret && res.result[0] == 1)\n\t\tgoto found;\n\n\t \n\tif (of_device_is_compatible(__scm ? __scm->dev->of_node : NULL, \"qcom,scm-sc7180\")) {\n\t\tforced = true;\n\t\tgoto found;\n\t}\n#endif\n\n\tprobed_convention = SMC_CONVENTION_ARM_32;\n\tret = __scm_smc_call(NULL, &desc, probed_convention, &res, true);\n\tif (!ret && res.result[0] == 1)\n\t\tgoto found;\n\n\tprobed_convention = SMC_CONVENTION_LEGACY;\nfound:\n\tspin_lock_irqsave(&scm_query_lock, flags);\n\tif (probed_convention != qcom_scm_convention) {\n\t\tqcom_scm_convention = probed_convention;\n\t\tpr_info(\"qcom_scm: convention: %s%s\\n\",\n\t\t\tqcom_scm_convention_names[qcom_scm_convention],\n\t\t\tforced ? \" (forced)\" : \"\");\n\t}\n\tspin_unlock_irqrestore(&scm_query_lock, flags);\n\n\treturn qcom_scm_convention;\n}\n\n \nstatic int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,\n\t\t\t struct qcom_scm_res *res)\n{\n\tmight_sleep();\n\tswitch (__get_convention()) {\n\tcase SMC_CONVENTION_ARM_32:\n\tcase SMC_CONVENTION_ARM_64:\n\t\treturn scm_smc_call(dev, desc, res, false);\n\tcase SMC_CONVENTION_LEGACY:\n\t\treturn scm_legacy_call(dev, desc, res);\n\tdefault:\n\t\tpr_err(\"Unknown current SCM calling convention.\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int qcom_scm_call_atomic(struct device *dev,\n\t\t\t\tconst struct qcom_scm_desc *desc,\n\t\t\t\tstruct qcom_scm_res *res)\n{\n\tswitch (__get_convention()) {\n\tcase SMC_CONVENTION_ARM_32:\n\tcase SMC_CONVENTION_ARM_64:\n\t\treturn scm_smc_call(dev, desc, res, true);\n\tcase SMC_CONVENTION_LEGACY:\n\t\treturn scm_legacy_call_atomic(dev, desc, res);\n\tdefault:\n\t\tpr_err(\"Unknown current SCM calling convention.\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,\n\t\t\t\t\t u32 cmd_id)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_INFO,\n\t\t.cmd = QCOM_SCM_INFO_IS_CALL_AVAIL,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tdesc.arginfo = QCOM_SCM_ARGS(1);\n\tswitch (__get_convention()) {\n\tcase SMC_CONVENTION_ARM_32:\n\tcase SMC_CONVENTION_ARM_64:\n\t\tdesc.args[0] = SCM_SMC_FNID(svc_id, cmd_id) |\n\t\t\t\t(ARM_SMCCC_OWNER_SIP << ARM_SMCCC_OWNER_SHIFT);\n\t\tbreak;\n\tcase SMC_CONVENTION_LEGACY:\n\t\tdesc.args[0] = SCM_LEGACY_FNID(svc_id, cmd_id);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown SMC convention being used\\n\");\n\t\treturn false;\n\t}\n\n\tret = qcom_scm_call(dev, &desc, &res);\n\n\treturn ret ? false : !!res.result[0];\n}\n\nstatic int qcom_scm_set_boot_addr(void *entry, const u8 *cpu_bits)\n{\n\tint cpu;\n\tunsigned int flags = 0;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_BOOT,\n\t\t.cmd = QCOM_SCM_BOOT_SET_ADDR,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (cpu >= QCOM_SCM_BOOT_MAX_CPUS)\n\t\t\treturn -EINVAL;\n\t\tflags |= cpu_bits[cpu];\n\t}\n\n\tdesc.args[0] = flags;\n\tdesc.args[1] = virt_to_phys(entry);\n\n\treturn qcom_scm_call_atomic(__scm ? __scm->dev : NULL, &desc, NULL);\n}\n\nstatic int qcom_scm_set_boot_addr_mc(void *entry, unsigned int flags)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_BOOT,\n\t\t.cmd = QCOM_SCM_BOOT_SET_ADDR_MC,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t\t.arginfo = QCOM_SCM_ARGS(6),\n\t\t.args = {\n\t\t\tvirt_to_phys(entry),\n\t\t\t \n\t\t\t~0ULL, ~0ULL, ~0ULL, ~0ULL,\n\t\t\tflags,\n\t\t},\n\t};\n\n\t \n\tif (!__scm || __get_convention() == SMC_CONVENTION_LEGACY)\n\t\treturn -EOPNOTSUPP;\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\n\n \nint qcom_scm_set_warm_boot_addr(void *entry)\n{\n\tif (qcom_scm_set_boot_addr_mc(entry, QCOM_SCM_BOOT_MC_FLAG_WARMBOOT))\n\t\t \n\t\treturn qcom_scm_set_boot_addr(entry, qcom_scm_cpu_warm_bits);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_set_warm_boot_addr);\n\n \nint qcom_scm_set_cold_boot_addr(void *entry)\n{\n\tif (qcom_scm_set_boot_addr_mc(entry, QCOM_SCM_BOOT_MC_FLAG_COLDBOOT))\n\t\t \n\t\treturn qcom_scm_set_boot_addr(entry, qcom_scm_cpu_cold_bits);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_set_cold_boot_addr);\n\n \nvoid qcom_scm_cpu_power_down(u32 flags)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_BOOT,\n\t\t.cmd = QCOM_SCM_BOOT_TERMINATE_PC,\n\t\t.args[0] = flags & QCOM_SCM_FLUSH_FLAG_MASK,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\tqcom_scm_call_atomic(__scm ? __scm->dev : NULL, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_cpu_power_down);\n\nint qcom_scm_set_remote_state(u32 state, u32 id)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_BOOT,\n\t\t.cmd = QCOM_SCM_BOOT_SET_REMOTE_STATE,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = state,\n\t\t.args[1] = id,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tint ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_set_remote_state);\n\nstatic int __qcom_scm_set_dload_mode(struct device *dev, bool enable)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_BOOT,\n\t\t.cmd = QCOM_SCM_BOOT_SET_DLOAD_MODE,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = QCOM_SCM_BOOT_SET_DLOAD_MODE,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\tdesc.args[1] = enable ? QCOM_SCM_BOOT_SET_DLOAD_MODE : 0;\n\n\treturn qcom_scm_call_atomic(__scm->dev, &desc, NULL);\n}\n\nstatic void qcom_scm_set_download_mode(bool enable)\n{\n\tbool avail;\n\tint ret = 0;\n\n\tavail = __qcom_scm_is_call_available(__scm->dev,\n\t\t\t\t\t     QCOM_SCM_SVC_BOOT,\n\t\t\t\t\t     QCOM_SCM_BOOT_SET_DLOAD_MODE);\n\tif (avail) {\n\t\tret = __qcom_scm_set_dload_mode(__scm->dev, enable);\n\t} else if (__scm->dload_mode_addr) {\n\t\tret = qcom_scm_io_writel(__scm->dload_mode_addr,\n\t\t\t\tenable ? QCOM_SCM_BOOT_SET_DLOAD_MODE : 0);\n\t} else {\n\t\tdev_err(__scm->dev,\n\t\t\t\"No available mechanism for setting download mode\\n\");\n\t}\n\n\tif (ret)\n\t\tdev_err(__scm->dev, \"failed to set download mode: %d\\n\", ret);\n}\n\n \nint qcom_scm_pas_init_image(u32 peripheral, const void *metadata, size_t size,\n\t\t\t    struct qcom_scm_pas_metadata *ctx)\n{\n\tdma_addr_t mdata_phys;\n\tvoid *mdata_buf;\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_INIT_IMAGE,\n\t\t.arginfo = QCOM_SCM_ARGS(2, QCOM_SCM_VAL, QCOM_SCM_RW),\n\t\t.args[0] = peripheral,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\t \n\tmdata_buf = dma_alloc_coherent(__scm->dev, size, &mdata_phys,\n\t\t\t\t       GFP_KERNEL);\n\tif (!mdata_buf) {\n\t\tdev_err(__scm->dev, \"Allocation of metadata buffer failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(mdata_buf, metadata, size);\n\n\tret = qcom_scm_clk_enable();\n\tif (ret)\n\t\tgoto out;\n\n\tret = qcom_scm_bw_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tdesc.args[1] = mdata_phys;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\tqcom_scm_bw_disable();\n\tqcom_scm_clk_disable();\n\nout:\n\tif (ret < 0 || !ctx) {\n\t\tdma_free_coherent(__scm->dev, size, mdata_buf, mdata_phys);\n\t} else if (ctx) {\n\t\tctx->ptr = mdata_buf;\n\t\tctx->phys = mdata_phys;\n\t\tctx->size = size;\n\t}\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_init_image);\n\n \nvoid qcom_scm_pas_metadata_release(struct qcom_scm_pas_metadata *ctx)\n{\n\tif (!ctx->ptr)\n\t\treturn;\n\n\tdma_free_coherent(__scm->dev, ctx->size, ctx->ptr, ctx->phys);\n\n\tctx->ptr = NULL;\n\tctx->phys = 0;\n\tctx->size = 0;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_metadata_release);\n\n \nint qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr, phys_addr_t size)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_MEM_SETUP,\n\t\t.arginfo = QCOM_SCM_ARGS(3),\n\t\t.args[0] = peripheral,\n\t\t.args[1] = addr,\n\t\t.args[2] = size,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tret = qcom_scm_clk_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_bw_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\tqcom_scm_bw_disable();\n\tqcom_scm_clk_disable();\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_mem_setup);\n\n \nint qcom_scm_pas_auth_and_reset(u32 peripheral)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_AUTH_AND_RESET,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = peripheral,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tret = qcom_scm_clk_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_bw_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\tqcom_scm_bw_disable();\n\tqcom_scm_clk_disable();\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_auth_and_reset);\n\n \nint qcom_scm_pas_shutdown(u32 peripheral)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_SHUTDOWN,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = peripheral,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tret = qcom_scm_clk_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_bw_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\tqcom_scm_bw_disable();\n\tqcom_scm_clk_disable();\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_shutdown);\n\n \nbool qcom_scm_pas_supported(u32 peripheral)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_IS_SUPPORTED,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = peripheral,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tif (!__qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_PIL,\n\t\t\t\t\t  QCOM_SCM_PIL_PAS_IS_SUPPORTED))\n\t\treturn false;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\treturn ret ? false : !!res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_pas_supported);\n\nstatic int __qcom_scm_pas_mss_reset(struct device *dev, bool reset)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_PIL,\n\t\t.cmd = QCOM_SCM_PIL_PAS_MSS_RESET,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = reset,\n\t\t.args[1] = 0,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tint ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\treturn ret ? : res.result[0];\n}\n\nstatic int qcom_scm_pas_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t     unsigned long idx)\n{\n\tif (idx != 0)\n\t\treturn -EINVAL;\n\n\treturn __qcom_scm_pas_mss_reset(__scm->dev, 1);\n}\n\nstatic int qcom_scm_pas_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t       unsigned long idx)\n{\n\tif (idx != 0)\n\t\treturn -EINVAL;\n\n\treturn __qcom_scm_pas_mss_reset(__scm->dev, 0);\n}\n\nstatic const struct reset_control_ops qcom_scm_pas_reset_ops = {\n\t.assert = qcom_scm_pas_reset_assert,\n\t.deassert = qcom_scm_pas_reset_deassert,\n};\n\nint qcom_scm_io_readl(phys_addr_t addr, unsigned int *val)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_IO,\n\t\t.cmd = QCOM_SCM_IO_READ,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = addr,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tint ret;\n\n\n\tret = qcom_scm_call_atomic(__scm->dev, &desc, &res);\n\tif (ret >= 0)\n\t\t*val = res.result[0];\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_io_readl);\n\nint qcom_scm_io_writel(phys_addr_t addr, unsigned int val)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_IO,\n\t\t.cmd = QCOM_SCM_IO_WRITE,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = addr,\n\t\t.args[1] = val,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\treturn qcom_scm_call_atomic(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_io_writel);\n\n \nbool qcom_scm_restore_sec_cfg_available(void)\n{\n\treturn __qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_MP,\n\t\t\t\t\t    QCOM_SCM_MP_RESTORE_SEC_CFG);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_restore_sec_cfg_available);\n\nint qcom_scm_restore_sec_cfg(u32 device_id, u32 spare)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_RESTORE_SEC_CFG,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = device_id,\n\t\t.args[1] = spare,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tint ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_restore_sec_cfg);\n\nint qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_IOMMU_SECURE_PTBL_SIZE,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = spare,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\tint ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\tif (size)\n\t\t*size = res.result[0];\n\n\treturn ret ? : res.result[1];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_iommu_secure_ptbl_size);\n\nint qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_IOMMU_SECURE_PTBL_INIT,\n\t\t.arginfo = QCOM_SCM_ARGS(3, QCOM_SCM_RW, QCOM_SCM_VAL,\n\t\t\t\t\t QCOM_SCM_VAL),\n\t\t.args[0] = addr,\n\t\t.args[1] = size,\n\t\t.args[2] = spare,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tint ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, NULL);\n\n\t \n\tif (ret == -EPERM)\n\t\tret = 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_iommu_secure_ptbl_init);\n\nint qcom_scm_iommu_set_cp_pool_size(u32 spare, u32 size)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_IOMMU_SET_CP_POOL_SIZE,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = size,\n\t\t.args[1] = spare,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_iommu_set_cp_pool_size);\n\nint qcom_scm_mem_protect_video_var(u32 cp_start, u32 cp_size,\n\t\t\t\t   u32 cp_nonpixel_start,\n\t\t\t\t   u32 cp_nonpixel_size)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_VIDEO_VAR,\n\t\t.arginfo = QCOM_SCM_ARGS(4, QCOM_SCM_VAL, QCOM_SCM_VAL,\n\t\t\t\t\t QCOM_SCM_VAL, QCOM_SCM_VAL),\n\t\t.args[0] = cp_start,\n\t\t.args[1] = cp_size,\n\t\t.args[2] = cp_nonpixel_start,\n\t\t.args[3] = cp_nonpixel_size,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\n\treturn ret ? : res.result[0];\n}\nEXPORT_SYMBOL_GPL(qcom_scm_mem_protect_video_var);\n\nstatic int __qcom_scm_assign_mem(struct device *dev, phys_addr_t mem_region,\n\t\t\t\t size_t mem_sz, phys_addr_t src, size_t src_sz,\n\t\t\t\t phys_addr_t dest, size_t dest_sz)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_MP,\n\t\t.cmd = QCOM_SCM_MP_ASSIGN,\n\t\t.arginfo = QCOM_SCM_ARGS(7, QCOM_SCM_RO, QCOM_SCM_VAL,\n\t\t\t\t\t QCOM_SCM_RO, QCOM_SCM_VAL, QCOM_SCM_RO,\n\t\t\t\t\t QCOM_SCM_VAL, QCOM_SCM_VAL),\n\t\t.args[0] = mem_region,\n\t\t.args[1] = mem_sz,\n\t\t.args[2] = src,\n\t\t.args[3] = src_sz,\n\t\t.args[4] = dest,\n\t\t.args[5] = dest_sz,\n\t\t.args[6] = 0,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tret = qcom_scm_call(dev, &desc, &res);\n\n\treturn ret ? : res.result[0];\n}\n\n \nint qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,\n\t\t\tu64 *srcvm,\n\t\t\tconst struct qcom_scm_vmperm *newvm,\n\t\t\tunsigned int dest_cnt)\n{\n\tstruct qcom_scm_current_perm_info *destvm;\n\tstruct qcom_scm_mem_map_info *mem_to_map;\n\tphys_addr_t mem_to_map_phys;\n\tphys_addr_t dest_phys;\n\tdma_addr_t ptr_phys;\n\tsize_t mem_to_map_sz;\n\tsize_t dest_sz;\n\tsize_t src_sz;\n\tsize_t ptr_sz;\n\tint next_vm;\n\t__le32 *src;\n\tvoid *ptr;\n\tint ret, i, b;\n\tu64 srcvm_bits = *srcvm;\n\n\tsrc_sz = hweight64(srcvm_bits) * sizeof(*src);\n\tmem_to_map_sz = sizeof(*mem_to_map);\n\tdest_sz = dest_cnt * sizeof(*destvm);\n\tptr_sz = ALIGN(src_sz, SZ_64) + ALIGN(mem_to_map_sz, SZ_64) +\n\t\t\tALIGN(dest_sz, SZ_64);\n\n\tptr = dma_alloc_coherent(__scm->dev, ptr_sz, &ptr_phys, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t \n\tsrc = ptr;\n\ti = 0;\n\tfor (b = 0; b < BITS_PER_TYPE(u64); b++) {\n\t\tif (srcvm_bits & BIT(b))\n\t\t\tsrc[i++] = cpu_to_le32(b);\n\t}\n\n\t \n\tmem_to_map = ptr + ALIGN(src_sz, SZ_64);\n\tmem_to_map_phys = ptr_phys + ALIGN(src_sz, SZ_64);\n\tmem_to_map->mem_addr = cpu_to_le64(mem_addr);\n\tmem_to_map->mem_size = cpu_to_le64(mem_sz);\n\n\tnext_vm = 0;\n\t \n\tdestvm = ptr + ALIGN(mem_to_map_sz, SZ_64) + ALIGN(src_sz, SZ_64);\n\tdest_phys = ptr_phys + ALIGN(mem_to_map_sz, SZ_64) + ALIGN(src_sz, SZ_64);\n\tfor (i = 0; i < dest_cnt; i++, destvm++, newvm++) {\n\t\tdestvm->vmid = cpu_to_le32(newvm->vmid);\n\t\tdestvm->perm = cpu_to_le32(newvm->perm);\n\t\tdestvm->ctx = 0;\n\t\tdestvm->ctx_size = 0;\n\t\tnext_vm |= BIT(newvm->vmid);\n\t}\n\n\tret = __qcom_scm_assign_mem(__scm->dev, mem_to_map_phys, mem_to_map_sz,\n\t\t\t\t    ptr_phys, src_sz, dest_phys, dest_sz);\n\tdma_free_coherent(__scm->dev, ptr_sz, ptr, ptr_phys);\n\tif (ret) {\n\t\tdev_err(__scm->dev,\n\t\t\t\"Assign memory protection call failed %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t*srcvm = next_vm;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_assign_mem);\n\n \nbool qcom_scm_ocmem_lock_available(void)\n{\n\treturn __qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_OCMEM,\n\t\t\t\t\t    QCOM_SCM_OCMEM_LOCK_CMD);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ocmem_lock_available);\n\n \nint qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset, u32 size,\n\t\t\tu32 mode)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_OCMEM,\n\t\t.cmd = QCOM_SCM_OCMEM_LOCK_CMD,\n\t\t.args[0] = id,\n\t\t.args[1] = offset,\n\t\t.args[2] = size,\n\t\t.args[3] = mode,\n\t\t.arginfo = QCOM_SCM_ARGS(4),\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ocmem_lock);\n\n \nint qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset, u32 size)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_OCMEM,\n\t\t.cmd = QCOM_SCM_OCMEM_UNLOCK_CMD,\n\t\t.args[0] = id,\n\t\t.args[1] = offset,\n\t\t.args[2] = size,\n\t\t.arginfo = QCOM_SCM_ARGS(3),\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ocmem_unlock);\n\n \nbool qcom_scm_ice_available(void)\n{\n\treturn __qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_ES,\n\t\t\t\t\t    QCOM_SCM_ES_INVALIDATE_ICE_KEY) &&\n\t\t__qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_ES,\n\t\t\t\t\t     QCOM_SCM_ES_CONFIG_SET_ICE_KEY);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ice_available);\n\n \nint qcom_scm_ice_invalidate_key(u32 index)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_ES,\n\t\t.cmd = QCOM_SCM_ES_INVALIDATE_ICE_KEY,\n\t\t.arginfo = QCOM_SCM_ARGS(1),\n\t\t.args[0] = index,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ice_invalidate_key);\n\n \nint qcom_scm_ice_set_key(u32 index, const u8 *key, u32 key_size,\n\t\t\t enum qcom_scm_ice_cipher cipher, u32 data_unit_size)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_ES,\n\t\t.cmd = QCOM_SCM_ES_CONFIG_SET_ICE_KEY,\n\t\t.arginfo = QCOM_SCM_ARGS(5, QCOM_SCM_VAL, QCOM_SCM_RW,\n\t\t\t\t\t QCOM_SCM_VAL, QCOM_SCM_VAL,\n\t\t\t\t\t QCOM_SCM_VAL),\n\t\t.args[0] = index,\n\t\t.args[2] = key_size,\n\t\t.args[3] = cipher,\n\t\t.args[4] = data_unit_size,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tvoid *keybuf;\n\tdma_addr_t key_phys;\n\tint ret;\n\n\t \n\n\tkeybuf = dma_alloc_coherent(__scm->dev, key_size, &key_phys,\n\t\t\t\t    GFP_KERNEL);\n\tif (!keybuf)\n\t\treturn -ENOMEM;\n\tmemcpy(keybuf, key, key_size);\n\tdesc.args[1] = key_phys;\n\n\tret = qcom_scm_call(__scm->dev, &desc, NULL);\n\n\tmemzero_explicit(keybuf, key_size);\n\n\tdma_free_coherent(__scm->dev, key_size, keybuf, key_phys);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_ice_set_key);\n\n \nbool qcom_scm_hdcp_available(void)\n{\n\tbool avail;\n\tint ret = qcom_scm_clk_enable();\n\n\tif (ret)\n\t\treturn ret;\n\n\tavail = __qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_HDCP,\n\t\t\t\t\t\tQCOM_SCM_HDCP_INVOKE);\n\n\tqcom_scm_clk_disable();\n\n\treturn avail;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_hdcp_available);\n\n \nint qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt, u32 *resp)\n{\n\tint ret;\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_HDCP,\n\t\t.cmd = QCOM_SCM_HDCP_INVOKE,\n\t\t.arginfo = QCOM_SCM_ARGS(10),\n\t\t.args = {\n\t\t\treq[0].addr,\n\t\t\treq[0].val,\n\t\t\treq[1].addr,\n\t\t\treq[1].val,\n\t\t\treq[2].addr,\n\t\t\treq[2].val,\n\t\t\treq[3].addr,\n\t\t\treq[3].val,\n\t\t\treq[4].addr,\n\t\t\treq[4].val\n\t\t},\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\tstruct qcom_scm_res res;\n\n\tif (req_cnt > QCOM_SCM_HDCP_MAX_REQ_CNT)\n\t\treturn -ERANGE;\n\n\tret = qcom_scm_clk_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_scm_call(__scm->dev, &desc, &res);\n\t*resp = res.result[0];\n\n\tqcom_scm_clk_disable();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_hdcp_req);\n\nint qcom_scm_iommu_set_pt_format(u32 sec_id, u32 ctx_num, u32 pt_fmt)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_SMMU_PROGRAM,\n\t\t.cmd = QCOM_SCM_SMMU_PT_FORMAT,\n\t\t.arginfo = QCOM_SCM_ARGS(3),\n\t\t.args[0] = sec_id,\n\t\t.args[1] = ctx_num,\n\t\t.args[2] = pt_fmt,  \n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_iommu_set_pt_format);\n\nint qcom_scm_qsmmu500_wait_safe_toggle(bool en)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_SMMU_PROGRAM,\n\t\t.cmd = QCOM_SCM_SMMU_CONFIG_ERRATA1,\n\t\t.arginfo = QCOM_SCM_ARGS(2),\n\t\t.args[0] = QCOM_SCM_SMMU_CONFIG_ERRATA1_CLIENT_ALL,\n\t\t.args[1] = en,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\n\treturn qcom_scm_call_atomic(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_qsmmu500_wait_safe_toggle);\n\nbool qcom_scm_lmh_dcvsh_available(void)\n{\n\treturn __qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_LMH, QCOM_SCM_LMH_LIMIT_DCVSH);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_lmh_dcvsh_available);\n\nint qcom_scm_lmh_profile_change(u32 profile_id)\n{\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_LMH,\n\t\t.cmd = QCOM_SCM_LMH_LIMIT_PROFILE_CHANGE,\n\t\t.arginfo = QCOM_SCM_ARGS(1, QCOM_SCM_VAL),\n\t\t.args[0] = profile_id,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\treturn qcom_scm_call(__scm->dev, &desc, NULL);\n}\nEXPORT_SYMBOL_GPL(qcom_scm_lmh_profile_change);\n\nint qcom_scm_lmh_dcvsh(u32 payload_fn, u32 payload_reg, u32 payload_val,\n\t\t       u64 limit_node, u32 node_id, u64 version)\n{\n\tdma_addr_t payload_phys;\n\tu32 *payload_buf;\n\tint ret, payload_size = 5 * sizeof(u32);\n\n\tstruct qcom_scm_desc desc = {\n\t\t.svc = QCOM_SCM_SVC_LMH,\n\t\t.cmd = QCOM_SCM_LMH_LIMIT_DCVSH,\n\t\t.arginfo = QCOM_SCM_ARGS(5, QCOM_SCM_RO, QCOM_SCM_VAL, QCOM_SCM_VAL,\n\t\t\t\t\tQCOM_SCM_VAL, QCOM_SCM_VAL),\n\t\t.args[1] = payload_size,\n\t\t.args[2] = limit_node,\n\t\t.args[3] = node_id,\n\t\t.args[4] = version,\n\t\t.owner = ARM_SMCCC_OWNER_SIP,\n\t};\n\n\tpayload_buf = dma_alloc_coherent(__scm->dev, payload_size, &payload_phys, GFP_KERNEL);\n\tif (!payload_buf)\n\t\treturn -ENOMEM;\n\n\tpayload_buf[0] = payload_fn;\n\tpayload_buf[1] = 0;\n\tpayload_buf[2] = payload_reg;\n\tpayload_buf[3] = 1;\n\tpayload_buf[4] = payload_val;\n\n\tdesc.args[0] = payload_phys;\n\n\tret = qcom_scm_call(__scm->dev, &desc, NULL);\n\n\tdma_free_coherent(__scm->dev, payload_size, payload_buf, payload_phys);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_lmh_dcvsh);\n\nstatic int qcom_scm_find_dload_address(struct device *dev, u64 *addr)\n{\n\tstruct device_node *tcsr;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource res;\n\tu32 offset;\n\tint ret;\n\n\ttcsr = of_parse_phandle(np, \"qcom,dload-mode\", 0);\n\tif (!tcsr)\n\t\treturn 0;\n\n\tret = of_address_to_resource(tcsr, 0, &res);\n\tof_node_put(tcsr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32_index(np, \"qcom,dload-mode\", 1, &offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*addr = res.start + offset;\n\n\treturn 0;\n}\n\n \nbool qcom_scm_is_available(void)\n{\n\treturn !!__scm;\n}\nEXPORT_SYMBOL_GPL(qcom_scm_is_available);\n\nstatic int qcom_scm_assert_valid_wq_ctx(u32 wq_ctx)\n{\n\t \n\tif (wq_ctx != 0) {\n\t\tdev_err(__scm->dev, \"Firmware unexpectedly passed non-zero wq_ctx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint qcom_scm_wait_for_wq_completion(u32 wq_ctx)\n{\n\tint ret;\n\n\tret = qcom_scm_assert_valid_wq_ctx(wq_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&__scm->waitq_comp);\n\n\treturn 0;\n}\n\nstatic int qcom_scm_waitq_wakeup(struct qcom_scm *scm, unsigned int wq_ctx)\n{\n\tint ret;\n\n\tret = qcom_scm_assert_valid_wq_ctx(wq_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tcomplete(&__scm->waitq_comp);\n\n\treturn 0;\n}\n\nstatic irqreturn_t qcom_scm_irq_handler(int irq, void *data)\n{\n\tint ret;\n\tstruct qcom_scm *scm = data;\n\tu32 wq_ctx, flags, more_pending = 0;\n\n\tdo {\n\t\tret = scm_get_wq_ctx(&wq_ctx, &flags, &more_pending);\n\t\tif (ret) {\n\t\t\tdev_err(scm->dev, \"GET_WQ_CTX SMC call failed: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (flags != QCOM_SMC_WAITQ_FLAG_WAKE_ONE &&\n\t\t    flags != QCOM_SMC_WAITQ_FLAG_WAKE_ALL) {\n\t\t\tdev_err(scm->dev, \"Invalid flags found for wq_ctx: %u\\n\", flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qcom_scm_waitq_wakeup(scm, wq_ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} while (more_pending);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_scm_probe(struct platform_device *pdev)\n{\n\tstruct qcom_scm *scm;\n\tint irq, ret;\n\n\tscm = devm_kzalloc(&pdev->dev, sizeof(*scm), GFP_KERNEL);\n\tif (!scm)\n\t\treturn -ENOMEM;\n\n\tret = qcom_scm_find_dload_address(&pdev->dev, &scm->dload_mode_addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&scm->scm_bw_lock);\n\n\tscm->path = devm_of_icc_get(&pdev->dev, NULL);\n\tif (IS_ERR(scm->path))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(scm->path),\n\t\t\t\t     \"failed to acquire interconnect path\\n\");\n\n\tscm->core_clk = devm_clk_get_optional(&pdev->dev, \"core\");\n\tif (IS_ERR(scm->core_clk))\n\t\treturn PTR_ERR(scm->core_clk);\n\n\tscm->iface_clk = devm_clk_get_optional(&pdev->dev, \"iface\");\n\tif (IS_ERR(scm->iface_clk))\n\t\treturn PTR_ERR(scm->iface_clk);\n\n\tscm->bus_clk = devm_clk_get_optional(&pdev->dev, \"bus\");\n\tif (IS_ERR(scm->bus_clk))\n\t\treturn PTR_ERR(scm->bus_clk);\n\n\tscm->reset.ops = &qcom_scm_pas_reset_ops;\n\tscm->reset.nr_resets = 1;\n\tscm->reset.of_node = pdev->dev.of_node;\n\tret = devm_reset_controller_register(&pdev->dev, &scm->reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_set_rate(scm->core_clk, INT_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t__scm = scm;\n\t__scm->dev = &pdev->dev;\n\n\tinit_completion(&__scm->waitq_comp);\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0) {\n\t\tif (irq != -ENXIO)\n\t\t\treturn irq;\n\t} else {\n\t\tret = devm_request_threaded_irq(__scm->dev, irq, NULL, qcom_scm_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, \"qcom-scm\", __scm);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(scm->dev, ret, \"Failed to request qcom-scm irq\\n\");\n\t}\n\n\t__get_convention();\n\n\t \n\tif (download_mode)\n\t\tqcom_scm_set_download_mode(true);\n\n\treturn 0;\n}\n\nstatic void qcom_scm_shutdown(struct platform_device *pdev)\n{\n\t \n\tqcom_scm_set_download_mode(false);\n}\n\nstatic const struct of_device_id qcom_scm_dt_match[] = {\n\t{ .compatible = \"qcom,scm\" },\n\n\t \n\t{ .compatible = \"qcom,scm-apq8064\" },\n\t{ .compatible = \"qcom,scm-apq8084\" },\n\t{ .compatible = \"qcom,scm-ipq4019\" },\n\t{ .compatible = \"qcom,scm-msm8953\" },\n\t{ .compatible = \"qcom,scm-msm8974\" },\n\t{ .compatible = \"qcom,scm-msm8996\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_scm_dt_match);\n\nstatic struct platform_driver qcom_scm_driver = {\n\t.driver = {\n\t\t.name\t= \"qcom_scm\",\n\t\t.of_match_table = qcom_scm_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = qcom_scm_probe,\n\t.shutdown = qcom_scm_shutdown,\n};\n\nstatic int __init qcom_scm_init(void)\n{\n\treturn platform_driver_register(&qcom_scm_driver);\n}\nsubsys_initcall(qcom_scm_init);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. SCM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}