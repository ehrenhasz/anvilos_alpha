{
  "module_name": "qemu_fw_cfg.c",
  "hash_id": "73e6860995a8cd1354f1ffc95c18626c29b954a5e9a667363d9d5a6a054ec930",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/qemu_fw_cfg.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <uapi/linux/qemu_fw_cfg.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/crash_core.h>\n\nMODULE_AUTHOR(\"Gabriel L. Somlo <somlo@cmu.edu>\");\nMODULE_DESCRIPTION(\"QEMU fw_cfg sysfs support\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic u32 fw_cfg_rev;\n\n \nstatic bool fw_cfg_is_mmio;\nstatic phys_addr_t fw_cfg_p_base;\nstatic resource_size_t fw_cfg_p_size;\nstatic void __iomem *fw_cfg_dev_base;\nstatic void __iomem *fw_cfg_reg_ctrl;\nstatic void __iomem *fw_cfg_reg_data;\nstatic void __iomem *fw_cfg_reg_dma;\n\n \nstatic DEFINE_MUTEX(fw_cfg_dev_lock);\n\n \nstatic void fw_cfg_sel_endianness(u16 key)\n{\n\tif (fw_cfg_is_mmio)\n\t\tiowrite16be(key, fw_cfg_reg_ctrl);\n\telse\n\t\tiowrite16(key, fw_cfg_reg_ctrl);\n}\n\n#ifdef CONFIG_CRASH_CORE\nstatic inline bool fw_cfg_dma_enabled(void)\n{\n\treturn (fw_cfg_rev & FW_CFG_VERSION_DMA) && fw_cfg_reg_dma;\n}\n\n \nstatic void fw_cfg_wait_for_control(struct fw_cfg_dma_access *d)\n{\n\tfor (;;) {\n\t\tu32 ctrl = be32_to_cpu(READ_ONCE(d->control));\n\n\t\t \n\t\trmb();\n\t\tif ((ctrl & ~FW_CFG_DMA_CTL_ERROR) == 0)\n\t\t\treturn;\n\n\t\tcpu_relax();\n\t}\n}\n\nstatic ssize_t fw_cfg_dma_transfer(void *address, u32 length, u32 control)\n{\n\tphys_addr_t dma;\n\tstruct fw_cfg_dma_access *d = NULL;\n\tssize_t ret = length;\n\n\td = kmalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t \n\t*d = (struct fw_cfg_dma_access) {\n\t\t.address = cpu_to_be64(address ? virt_to_phys(address) : 0),\n\t\t.length = cpu_to_be32(length),\n\t\t.control = cpu_to_be32(control)\n\t};\n\n\tdma = virt_to_phys(d);\n\n\tiowrite32be((u64)dma >> 32, fw_cfg_reg_dma);\n\t \n\twmb();\n\tiowrite32be(dma, fw_cfg_reg_dma + 4);\n\n\tfw_cfg_wait_for_control(d);\n\n\tif (be32_to_cpu(READ_ONCE(d->control)) & FW_CFG_DMA_CTL_ERROR) {\n\t\tret = -EIO;\n\t}\n\nend:\n\tkfree(d);\n\n\treturn ret;\n}\n#endif\n\n \nstatic ssize_t fw_cfg_read_blob(u16 key,\n\t\t\t\tvoid *buf, loff_t pos, size_t count)\n{\n\tu32 glk = -1U;\n\tacpi_status status;\n\n\t \n\tstatus = acpi_acquire_global_lock(ACPI_WAIT_FOREVER, &glk);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_CONFIGURED) {\n\t\t \n\t\tWARN(1, \"fw_cfg_read_blob: Failed to lock ACPI!\\n\");\n\t\tmemset(buf, 0, count);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fw_cfg_dev_lock);\n\tfw_cfg_sel_endianness(key);\n\twhile (pos-- > 0)\n\t\tioread8(fw_cfg_reg_data);\n\tioread8_rep(fw_cfg_reg_data, buf, count);\n\tmutex_unlock(&fw_cfg_dev_lock);\n\n\tacpi_release_global_lock(glk);\n\treturn count;\n}\n\n#ifdef CONFIG_CRASH_CORE\n \nstatic ssize_t fw_cfg_write_blob(u16 key,\n\t\t\t\t void *buf, loff_t pos, size_t count)\n{\n\tu32 glk = -1U;\n\tacpi_status status;\n\tssize_t ret = count;\n\n\t \n\tstatus = acpi_acquire_global_lock(ACPI_WAIT_FOREVER, &glk);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_CONFIGURED) {\n\t\t \n\t\tWARN(1, \"%s: Failed to lock ACPI!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fw_cfg_dev_lock);\n\tif (pos == 0) {\n\t\tret = fw_cfg_dma_transfer(buf, count, key << 16\n\t\t\t\t\t  | FW_CFG_DMA_CTL_SELECT\n\t\t\t\t\t  | FW_CFG_DMA_CTL_WRITE);\n\t} else {\n\t\tfw_cfg_sel_endianness(key);\n\t\tret = fw_cfg_dma_transfer(NULL, pos, FW_CFG_DMA_CTL_SKIP);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tret = fw_cfg_dma_transfer(buf, count, FW_CFG_DMA_CTL_WRITE);\n\t}\n\nend:\n\tmutex_unlock(&fw_cfg_dev_lock);\n\n\tacpi_release_global_lock(glk);\n\n\treturn ret;\n}\n#endif  \n\n \nstatic void fw_cfg_io_cleanup(void)\n{\n\tif (fw_cfg_is_mmio) {\n\t\tiounmap(fw_cfg_dev_base);\n\t\trelease_mem_region(fw_cfg_p_base, fw_cfg_p_size);\n\t} else {\n\t\tioport_unmap(fw_cfg_dev_base);\n\t\trelease_region(fw_cfg_p_base, fw_cfg_p_size);\n\t}\n}\n\n \n#if !(defined(FW_CFG_CTRL_OFF) && defined(FW_CFG_DATA_OFF))\n# if (defined(CONFIG_ARM) || defined(CONFIG_ARM64))\n#  define FW_CFG_CTRL_OFF 0x08\n#  define FW_CFG_DATA_OFF 0x00\n#  define FW_CFG_DMA_OFF 0x10\n# elif defined(CONFIG_PARISC)\t \n#  define FW_CFG_CTRL_OFF 0x00\n#  define FW_CFG_DATA_OFF 0x04\n# elif (defined(CONFIG_PPC_PMAC) || defined(CONFIG_SPARC32))  \n#  define FW_CFG_CTRL_OFF 0x00\n#  define FW_CFG_DATA_OFF 0x02\n# elif (defined(CONFIG_X86) || defined(CONFIG_SPARC64))  \n#  define FW_CFG_CTRL_OFF 0x00\n#  define FW_CFG_DATA_OFF 0x01\n#  define FW_CFG_DMA_OFF 0x04\n# else\n#  error \"QEMU FW_CFG not available on this architecture!\"\n# endif\n#endif\n\n \nstatic int fw_cfg_do_platform_probe(struct platform_device *pdev)\n{\n\tchar sig[FW_CFG_SIG_SIZE];\n\tstruct resource *range, *ctrl, *data, *dma;\n\n\t \n\tfw_cfg_is_mmio = false;\n\trange = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!range) {\n\t\tfw_cfg_is_mmio = true;\n\t\trange = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!range)\n\t\t\treturn -EINVAL;\n\t}\n\tfw_cfg_p_base = range->start;\n\tfw_cfg_p_size = resource_size(range);\n\n\tif (fw_cfg_is_mmio) {\n\t\tif (!request_mem_region(fw_cfg_p_base,\n\t\t\t\t\tfw_cfg_p_size, \"fw_cfg_mem\"))\n\t\t\treturn -EBUSY;\n\t\tfw_cfg_dev_base = ioremap(fw_cfg_p_base, fw_cfg_p_size);\n\t\tif (!fw_cfg_dev_base) {\n\t\t\trelease_mem_region(fw_cfg_p_base, fw_cfg_p_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (!request_region(fw_cfg_p_base,\n\t\t\t\t    fw_cfg_p_size, \"fw_cfg_io\"))\n\t\t\treturn -EBUSY;\n\t\tfw_cfg_dev_base = ioport_map(fw_cfg_p_base, fw_cfg_p_size);\n\t\tif (!fw_cfg_dev_base) {\n\t\t\trelease_region(fw_cfg_p_base, fw_cfg_p_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t \n\tctrl = platform_get_resource_byname(pdev, IORESOURCE_REG, \"ctrl\");\n\tdata = platform_get_resource_byname(pdev, IORESOURCE_REG, \"data\");\n\tdma = platform_get_resource_byname(pdev, IORESOURCE_REG, \"dma\");\n\tif (ctrl && data) {\n\t\tfw_cfg_reg_ctrl = fw_cfg_dev_base + ctrl->start;\n\t\tfw_cfg_reg_data = fw_cfg_dev_base + data->start;\n\t} else {\n\t\t \n\t\tfw_cfg_reg_ctrl = fw_cfg_dev_base + FW_CFG_CTRL_OFF;\n\t\tfw_cfg_reg_data = fw_cfg_dev_base + FW_CFG_DATA_OFF;\n\t}\n\n\tif (dma)\n\t\tfw_cfg_reg_dma = fw_cfg_dev_base + dma->start;\n#ifdef FW_CFG_DMA_OFF\n\telse\n\t\tfw_cfg_reg_dma = fw_cfg_dev_base + FW_CFG_DMA_OFF;\n#endif\n\n\t \n\tif (fw_cfg_read_blob(FW_CFG_SIGNATURE, sig,\n\t\t\t\t0, FW_CFG_SIG_SIZE) < 0 ||\n\t\tmemcmp(sig, \"QEMU\", FW_CFG_SIG_SIZE) != 0) {\n\t\tfw_cfg_io_cleanup();\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t fw_cfg_showrev(struct kobject *k, struct kobj_attribute *a,\n\t\t\t      char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", fw_cfg_rev);\n}\n\nstatic const struct kobj_attribute fw_cfg_rev_attr = {\n\t.attr = { .name = \"rev\", .mode = S_IRUSR },\n\t.show = fw_cfg_showrev,\n};\n\n \nstruct fw_cfg_sysfs_entry {\n\tstruct kobject kobj;\n\tu32 size;\n\tu16 select;\n\tchar name[FW_CFG_MAX_FILE_PATH];\n\tstruct list_head list;\n};\n\n#ifdef CONFIG_CRASH_CORE\nstatic ssize_t fw_cfg_write_vmcoreinfo(const struct fw_cfg_file *f)\n{\n\tstatic struct fw_cfg_vmcoreinfo *data;\n\tssize_t ret;\n\n\tdata = kmalloc(sizeof(struct fw_cfg_vmcoreinfo), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t*data = (struct fw_cfg_vmcoreinfo) {\n\t\t.guest_format = cpu_to_le16(FW_CFG_VMCOREINFO_FORMAT_ELF),\n\t\t.size = cpu_to_le32(VMCOREINFO_NOTE_SIZE),\n\t\t.paddr = cpu_to_le64(paddr_vmcoreinfo_note())\n\t};\n\t \n\tret = fw_cfg_write_blob(be16_to_cpu(f->select), data,\n\t\t\t\t0, sizeof(struct fw_cfg_vmcoreinfo));\n\n\tkfree(data);\n\treturn ret;\n}\n#endif  \n\n \nstatic inline struct fw_cfg_sysfs_entry *to_entry(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct fw_cfg_sysfs_entry, kobj);\n}\n\n \nstruct fw_cfg_sysfs_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct fw_cfg_sysfs_entry *entry, char *buf);\n};\n\n \nstatic inline struct fw_cfg_sysfs_attribute *to_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct fw_cfg_sysfs_attribute, attr);\n}\n\n \nstatic LIST_HEAD(fw_cfg_entry_cache);\n\n \nstatic DEFINE_SPINLOCK(fw_cfg_cache_lock);\n\nstatic inline void fw_cfg_sysfs_cache_enlist(struct fw_cfg_sysfs_entry *entry)\n{\n\tspin_lock(&fw_cfg_cache_lock);\n\tlist_add_tail(&entry->list, &fw_cfg_entry_cache);\n\tspin_unlock(&fw_cfg_cache_lock);\n}\n\nstatic inline void fw_cfg_sysfs_cache_delist(struct fw_cfg_sysfs_entry *entry)\n{\n\tspin_lock(&fw_cfg_cache_lock);\n\tlist_del(&entry->list);\n\tspin_unlock(&fw_cfg_cache_lock);\n}\n\nstatic void fw_cfg_sysfs_cache_cleanup(void)\n{\n\tstruct fw_cfg_sysfs_entry *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &fw_cfg_entry_cache, list) {\n\t\tfw_cfg_sysfs_cache_delist(entry);\n\t\tkobject_del(&entry->kobj);\n\t\tkobject_put(&entry->kobj);\n\t}\n}\n\n \n\n#define FW_CFG_SYSFS_ATTR(_attr) \\\nstruct fw_cfg_sysfs_attribute fw_cfg_sysfs_attr_##_attr = { \\\n\t.attr = { .name = __stringify(_attr), .mode = S_IRUSR }, \\\n\t.show = fw_cfg_sysfs_show_##_attr, \\\n}\n\nstatic ssize_t fw_cfg_sysfs_show_size(struct fw_cfg_sysfs_entry *e, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", e->size);\n}\n\nstatic ssize_t fw_cfg_sysfs_show_key(struct fw_cfg_sysfs_entry *e, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", e->select);\n}\n\nstatic ssize_t fw_cfg_sysfs_show_name(struct fw_cfg_sysfs_entry *e, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", e->name);\n}\n\nstatic FW_CFG_SYSFS_ATTR(size);\nstatic FW_CFG_SYSFS_ATTR(key);\nstatic FW_CFG_SYSFS_ATTR(name);\n\nstatic struct attribute *fw_cfg_sysfs_entry_attrs[] = {\n\t&fw_cfg_sysfs_attr_size.attr,\n\t&fw_cfg_sysfs_attr_key.attr,\n\t&fw_cfg_sysfs_attr_name.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(fw_cfg_sysfs_entry);\n\n \nstatic ssize_t fw_cfg_sysfs_attr_show(struct kobject *kobj, struct attribute *a,\n\t\t\t\t      char *buf)\n{\n\tstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\n\tstruct fw_cfg_sysfs_attribute *attr = to_attr(a);\n\n\treturn attr->show(entry, buf);\n}\n\nstatic const struct sysfs_ops fw_cfg_sysfs_attr_ops = {\n\t.show = fw_cfg_sysfs_attr_show,\n};\n\n \nstatic void fw_cfg_sysfs_release_entry(struct kobject *kobj)\n{\n\tstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\n\n\tkfree(entry);\n}\n\n \nstatic struct kobj_type fw_cfg_sysfs_entry_ktype = {\n\t.default_groups = fw_cfg_sysfs_entry_groups,\n\t.sysfs_ops = &fw_cfg_sysfs_attr_ops,\n\t.release = fw_cfg_sysfs_release_entry,\n};\n\n \nstatic ssize_t fw_cfg_sysfs_read_raw(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *bin_attr,\n\t\t\t\t     char *buf, loff_t pos, size_t count)\n{\n\tstruct fw_cfg_sysfs_entry *entry = to_entry(kobj);\n\n\tif (pos > entry->size)\n\t\treturn -EINVAL;\n\n\tif (count > entry->size - pos)\n\t\tcount = entry->size - pos;\n\n\treturn fw_cfg_read_blob(entry->select, buf, pos, count);\n}\n\nstatic struct bin_attribute fw_cfg_sysfs_attr_raw = {\n\t.attr = { .name = \"raw\", .mode = S_IRUSR },\n\t.read = fw_cfg_sysfs_read_raw,\n};\n\n \nstatic int fw_cfg_build_symlink(struct kset *dir,\n\t\t\t\tstruct kobject *target, const char *name)\n{\n\tint ret;\n\tstruct kset *subdir;\n\tstruct kobject *ko;\n\tchar *name_copy, *p, *tok;\n\n\tif (!dir || !target || !name || !*name)\n\t\treturn -EINVAL;\n\n\t \n\tname_copy = p = kstrdup(name, GFP_KERNEL);\n\tif (!name_copy)\n\t\treturn -ENOMEM;\n\n\t \n\twhile ((tok = strsep(&p, \"/\")) && *tok) {\n\n\t\t \n\t\tif (!p || !*p) {\n\t\t\tret = sysfs_create_link(&dir->kobj, target, tok);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tko = kset_find_obj(dir, tok);\n\t\tif (ko) {\n\t\t\t \n\t\t\tkobject_put(ko);\n\n\t\t\t \n\t\t\tif (ko->ktype != dir->kobj.ktype) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tdir = to_kset(ko);\n\t\t} else {\n\t\t\t \n\t\t\tsubdir = kzalloc(sizeof(struct kset), GFP_KERNEL);\n\t\t\tif (!subdir) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsubdir->kobj.kset = dir;\n\t\t\tsubdir->kobj.ktype = dir->kobj.ktype;\n\t\t\tret = kobject_set_name(&subdir->kobj, \"%s\", tok);\n\t\t\tif (ret) {\n\t\t\t\tkfree(subdir);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = kset_register(subdir);\n\t\t\tif (ret) {\n\t\t\t\tkfree(subdir);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tdir = subdir;\n\t\t}\n\t}\n\n\t \n\tkfree(name_copy);\n\treturn ret;\n}\n\n \nstatic void fw_cfg_kset_unregister_recursive(struct kset *kset)\n{\n\tstruct kobject *k, *next;\n\n\tlist_for_each_entry_safe(k, next, &kset->list, entry)\n\t\t \n\t\tif (k->ktype == kset->kobj.ktype)\n\t\t\tfw_cfg_kset_unregister_recursive(to_kset(k));\n\n\t \n\tkset_unregister(kset);\n}\n\n \nstatic struct kobject *fw_cfg_top_ko;\nstatic struct kobject *fw_cfg_sel_ko;\nstatic struct kset *fw_cfg_fname_kset;\n\n \nstatic int fw_cfg_register_file(const struct fw_cfg_file *f)\n{\n\tint err;\n\tstruct fw_cfg_sysfs_entry *entry;\n\n#ifdef CONFIG_CRASH_CORE\n\tif (fw_cfg_dma_enabled() &&\n\t\tstrcmp(f->name, FW_CFG_VMCOREINFO_FILENAME) == 0 &&\n\t\t!is_kdump_kernel()) {\n\t\tif (fw_cfg_write_vmcoreinfo(f) < 0)\n\t\t\tpr_warn(\"fw_cfg: failed to write vmcoreinfo\");\n\t}\n#endif\n\n\t \n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t \n\tentry->size = be32_to_cpu(f->size);\n\tentry->select = be16_to_cpu(f->select);\n\tstrscpy(entry->name, f->name, FW_CFG_MAX_FILE_PATH);\n\n\t \n\terr = kobject_init_and_add(&entry->kobj, &fw_cfg_sysfs_entry_ktype,\n\t\t\t\t   fw_cfg_sel_ko, \"%d\", entry->select);\n\tif (err)\n\t\tgoto err_put_entry;\n\n\t \n\terr = sysfs_create_bin_file(&entry->kobj, &fw_cfg_sysfs_attr_raw);\n\tif (err)\n\t\tgoto err_del_entry;\n\n\t \n\tfw_cfg_build_symlink(fw_cfg_fname_kset, &entry->kobj, entry->name);\n\n\t \n\tfw_cfg_sysfs_cache_enlist(entry);\n\treturn 0;\n\nerr_del_entry:\n\tkobject_del(&entry->kobj);\nerr_put_entry:\n\tkobject_put(&entry->kobj);\n\treturn err;\n}\n\n \nstatic int fw_cfg_register_dir_entries(void)\n{\n\tint ret = 0;\n\t__be32 files_count;\n\tu32 count, i;\n\tstruct fw_cfg_file *dir;\n\tsize_t dir_size;\n\n\tret = fw_cfg_read_blob(FW_CFG_FILE_DIR, &files_count,\n\t\t\t0, sizeof(files_count));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount = be32_to_cpu(files_count);\n\tdir_size = count * sizeof(struct fw_cfg_file);\n\n\tdir = kmalloc(dir_size, GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tret = fw_cfg_read_blob(FW_CFG_FILE_DIR, dir,\n\t\t\tsizeof(files_count), dir_size);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = fw_cfg_register_file(&dir[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nend:\n\tkfree(dir);\n\treturn ret;\n}\n\n \nstatic inline void fw_cfg_kobj_cleanup(struct kobject *kobj)\n{\n\tkobject_del(kobj);\n\tkobject_put(kobj);\n}\n\nstatic int fw_cfg_sysfs_probe(struct platform_device *pdev)\n{\n\tint err;\n\t__le32 rev;\n\n\t \n\tif (fw_cfg_sel_ko)\n\t\treturn -EBUSY;\n\n\t \n\terr = -ENOMEM;\n\tfw_cfg_sel_ko = kobject_create_and_add(\"by_key\", fw_cfg_top_ko);\n\tif (!fw_cfg_sel_ko)\n\t\tgoto err_sel;\n\tfw_cfg_fname_kset = kset_create_and_add(\"by_name\", NULL, fw_cfg_top_ko);\n\tif (!fw_cfg_fname_kset)\n\t\tgoto err_name;\n\n\t \n\terr = fw_cfg_do_platform_probe(pdev);\n\tif (err)\n\t\tgoto err_probe;\n\n\t \n\terr = fw_cfg_read_blob(FW_CFG_ID, &rev, 0, sizeof(rev));\n\tif (err < 0)\n\t\tgoto err_probe;\n\n\tfw_cfg_rev = le32_to_cpu(rev);\n\terr = sysfs_create_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);\n\tif (err)\n\t\tgoto err_rev;\n\n\t \n\terr = fw_cfg_register_dir_entries();\n\tif (err)\n\t\tgoto err_dir;\n\n\t \n\tpr_debug(\"fw_cfg: loaded.\\n\");\n\treturn 0;\n\nerr_dir:\n\tfw_cfg_sysfs_cache_cleanup();\n\tsysfs_remove_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);\nerr_rev:\n\tfw_cfg_io_cleanup();\nerr_probe:\n\tfw_cfg_kset_unregister_recursive(fw_cfg_fname_kset);\nerr_name:\n\tfw_cfg_kobj_cleanup(fw_cfg_sel_ko);\nerr_sel:\n\treturn err;\n}\n\nstatic int fw_cfg_sysfs_remove(struct platform_device *pdev)\n{\n\tpr_debug(\"fw_cfg: unloading.\\n\");\n\tfw_cfg_sysfs_cache_cleanup();\n\tsysfs_remove_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);\n\tfw_cfg_io_cleanup();\n\tfw_cfg_kset_unregister_recursive(fw_cfg_fname_kset);\n\tfw_cfg_kobj_cleanup(fw_cfg_sel_ko);\n\treturn 0;\n}\n\nstatic const struct of_device_id fw_cfg_sysfs_mmio_match[] = {\n\t{ .compatible = \"qemu,fw-cfg-mmio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fw_cfg_sysfs_mmio_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id fw_cfg_sysfs_acpi_match[] = {\n\t{ FW_CFG_ACPI_DEVICE_ID, },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, fw_cfg_sysfs_acpi_match);\n#endif\n\nstatic struct platform_driver fw_cfg_sysfs_driver = {\n\t.probe = fw_cfg_sysfs_probe,\n\t.remove = fw_cfg_sysfs_remove,\n\t.driver = {\n\t\t.name = \"fw_cfg\",\n\t\t.of_match_table = fw_cfg_sysfs_mmio_match,\n\t\t.acpi_match_table = ACPI_PTR(fw_cfg_sysfs_acpi_match),\n\t},\n};\n\n#ifdef CONFIG_FW_CFG_SYSFS_CMDLINE\n\nstatic struct platform_device *fw_cfg_cmdline_dev;\n\n \n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n#define __PHYS_ADDR_PREFIX \"ll\"\n#else\n#define __PHYS_ADDR_PREFIX \"\"\n#endif\n\n \n#define PH_ADDR_SCAN_FMT \"@%\" __PHYS_ADDR_PREFIX \"i%n\" \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"i\" \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"i%n\" \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"i%n\"\n\n#define PH_ADDR_PR_1_FMT \"0x%\" __PHYS_ADDR_PREFIX \"x@\" \\\n\t\t\t \"0x%\" __PHYS_ADDR_PREFIX \"x\"\n\n#define PH_ADDR_PR_3_FMT PH_ADDR_PR_1_FMT \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"u\" \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"u\"\n\n#define PH_ADDR_PR_4_FMT PH_ADDR_PR_3_FMT \\\n\t\t\t \":%\" __PHYS_ADDR_PREFIX \"u\"\n\nstatic int fw_cfg_cmdline_set(const char *arg, const struct kernel_param *kp)\n{\n\tstruct resource res[4] = {};\n\tchar *str;\n\tphys_addr_t base;\n\tresource_size_t size, ctrl_off, data_off, dma_off;\n\tint processed, consumed = 0;\n\n\t \n\tif (fw_cfg_cmdline_dev) {\n\t\t \n\t\tplatform_device_unregister(fw_cfg_cmdline_dev);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsize = memparse(arg, &str);\n\n\t \n\tprocessed = sscanf(str, PH_ADDR_SCAN_FMT,\n\t\t\t   &base, &consumed,\n\t\t\t   &ctrl_off, &data_off, &consumed,\n\t\t\t   &dma_off, &consumed);\n\n\t \n\tif (str[consumed] ||\n\t    (processed != 1 && processed != 3 && processed != 4))\n\t\treturn -EINVAL;\n\n\tres[0].start = base;\n\tres[0].end = base + size - 1;\n\tres[0].flags = !strcmp(kp->name, \"mmio\") ? IORESOURCE_MEM :\n\t\t\t\t\t\t   IORESOURCE_IO;\n\n\t \n\tif (processed > 1) {\n\t\tres[1].name = \"ctrl\";\n\t\tres[1].start = ctrl_off;\n\t\tres[1].flags = IORESOURCE_REG;\n\t\tres[2].name = \"data\";\n\t\tres[2].start = data_off;\n\t\tres[2].flags = IORESOURCE_REG;\n\t}\n\tif (processed > 3) {\n\t\tres[3].name = \"dma\";\n\t\tres[3].start = dma_off;\n\t\tres[3].flags = IORESOURCE_REG;\n\t}\n\n\t \n\tfw_cfg_cmdline_dev = platform_device_register_simple(\"fw_cfg\",\n\t\t\t\t\tPLATFORM_DEVID_NONE, res, processed);\n\n\treturn PTR_ERR_OR_ZERO(fw_cfg_cmdline_dev);\n}\n\nstatic int fw_cfg_cmdline_get(char *buf, const struct kernel_param *kp)\n{\n\t \n\tif (!fw_cfg_cmdline_dev ||\n\t    (!strcmp(kp->name, \"mmio\") ^\n\t     (fw_cfg_cmdline_dev->resource[0].flags == IORESOURCE_MEM)))\n\t\treturn 0;\n\n\tswitch (fw_cfg_cmdline_dev->num_resources) {\n\tcase 1:\n\t\treturn snprintf(buf, PAGE_SIZE, PH_ADDR_PR_1_FMT,\n\t\t\t\tresource_size(&fw_cfg_cmdline_dev->resource[0]),\n\t\t\t\tfw_cfg_cmdline_dev->resource[0].start);\n\tcase 3:\n\t\treturn snprintf(buf, PAGE_SIZE, PH_ADDR_PR_3_FMT,\n\t\t\t\tresource_size(&fw_cfg_cmdline_dev->resource[0]),\n\t\t\t\tfw_cfg_cmdline_dev->resource[0].start,\n\t\t\t\tfw_cfg_cmdline_dev->resource[1].start,\n\t\t\t\tfw_cfg_cmdline_dev->resource[2].start);\n\tcase 4:\n\t\treturn snprintf(buf, PAGE_SIZE, PH_ADDR_PR_4_FMT,\n\t\t\t\tresource_size(&fw_cfg_cmdline_dev->resource[0]),\n\t\t\t\tfw_cfg_cmdline_dev->resource[0].start,\n\t\t\t\tfw_cfg_cmdline_dev->resource[1].start,\n\t\t\t\tfw_cfg_cmdline_dev->resource[2].start,\n\t\t\t\tfw_cfg_cmdline_dev->resource[3].start);\n\t}\n\n\t \n\tWARN(1, \"Unexpected number of resources: %d\\n\",\n\t\tfw_cfg_cmdline_dev->num_resources);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops fw_cfg_cmdline_param_ops = {\n\t.set = fw_cfg_cmdline_set,\n\t.get = fw_cfg_cmdline_get,\n};\n\ndevice_param_cb(ioport, &fw_cfg_cmdline_param_ops, NULL, S_IRUSR);\ndevice_param_cb(mmio, &fw_cfg_cmdline_param_ops, NULL, S_IRUSR);\n\n#endif  \n\nstatic int __init fw_cfg_sysfs_init(void)\n{\n\tint ret;\n\n\t \n\tfw_cfg_top_ko = kobject_create_and_add(\"qemu_fw_cfg\", firmware_kobj);\n\tif (!fw_cfg_top_ko)\n\t\treturn -ENOMEM;\n\n\tret = platform_driver_register(&fw_cfg_sysfs_driver);\n\tif (ret)\n\t\tfw_cfg_kobj_cleanup(fw_cfg_top_ko);\n\n\treturn ret;\n}\n\nstatic void __exit fw_cfg_sysfs_exit(void)\n{\n\tplatform_driver_unregister(&fw_cfg_sysfs_driver);\n\n#ifdef CONFIG_FW_CFG_SYSFS_CMDLINE\n\tplatform_device_unregister(fw_cfg_cmdline_dev);\n#endif\n\n\t \n\tfw_cfg_kobj_cleanup(fw_cfg_top_ko);\n}\n\nmodule_init(fw_cfg_sysfs_init);\nmodule_exit(fw_cfg_sysfs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}