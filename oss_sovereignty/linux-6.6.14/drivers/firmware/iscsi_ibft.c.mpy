{
  "module_name": "iscsi_ibft.c",
  "hash_id": "084516466527a2b495265be9a7bd18b4f45987242b7620295a6755f3aac5c6bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/iscsi_ibft.c",
  "human_readable_source": "\n \n\n\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/iscsi_ibft.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/iscsi_boot_sysfs.h>\n\n#define IBFT_ISCSI_VERSION \"0.5.0\"\n#define IBFT_ISCSI_DATE \"2010-Feb-25\"\n\nMODULE_AUTHOR(\"Peter Jones <pjones@redhat.com> and \"\n\t      \"Konrad Rzeszutek <ketuzsezr@darnok.org>\");\nMODULE_DESCRIPTION(\"sysfs interface to BIOS iBFT information\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(IBFT_ISCSI_VERSION);\n\nstatic struct acpi_table_ibft *ibft_addr;\n\nstruct ibft_hdr {\n\tu8 id;\n\tu8 version;\n\tu16 length;\n\tu8 index;\n\tu8 flags;\n} __attribute__((__packed__));\n\nstruct ibft_control {\n\tstruct ibft_hdr hdr;\n\tu16 extensions;\n\tu16 initiator_off;\n\tu16 nic0_off;\n\tu16 tgt0_off;\n\tu16 nic1_off;\n\tu16 tgt1_off;\n\tu16 expansion[];\n} __attribute__((__packed__));\n\nstruct ibft_initiator {\n\tstruct ibft_hdr hdr;\n\tchar isns_server[16];\n\tchar slp_server[16];\n\tchar pri_radius_server[16];\n\tchar sec_radius_server[16];\n\tu16 initiator_name_len;\n\tu16 initiator_name_off;\n} __attribute__((__packed__));\n\nstruct ibft_nic {\n\tstruct ibft_hdr hdr;\n\tchar ip_addr[16];\n\tu8 subnet_mask_prefix;\n\tu8 origin;\n\tchar gateway[16];\n\tchar primary_dns[16];\n\tchar secondary_dns[16];\n\tchar dhcp[16];\n\tu16 vlan;\n\tchar mac[6];\n\tu16 pci_bdf;\n\tu16 hostname_len;\n\tu16 hostname_off;\n} __attribute__((__packed__));\n\nstruct ibft_tgt {\n\tstruct ibft_hdr hdr;\n\tchar ip_addr[16];\n\tu16 port;\n\tchar lun[8];\n\tu8 chap_type;\n\tu8 nic_assoc;\n\tu16 tgt_name_len;\n\tu16 tgt_name_off;\n\tu16 chap_name_len;\n\tu16 chap_name_off;\n\tu16 chap_secret_len;\n\tu16 chap_secret_off;\n\tu16 rev_chap_name_len;\n\tu16 rev_chap_name_off;\n\tu16 rev_chap_secret_len;\n\tu16 rev_chap_secret_off;\n} __attribute__((__packed__));\n\n \nenum ibft_id {\n\tid_reserved = 0,  \n\tid_control = 1,  \n\tid_initiator = 2,\n\tid_nic = 3,\n\tid_target = 4,\n\tid_extensions = 5,  \n\tid_end_marker,\n};\n\n \n\nstruct ibft_kobject {\n\tstruct acpi_table_ibft *header;\n\tunion {\n\t\tstruct ibft_initiator *initiator;\n\t\tstruct ibft_nic *nic;\n\t\tstruct ibft_tgt *tgt;\n\t\tstruct ibft_hdr *hdr;\n\t};\n};\n\nstatic struct iscsi_boot_kset *boot_kset;\n\n \nstatic const char nulls[16];\n\n \nstatic const char mapped_nulls[16] = { 0x00, 0x00, 0x00, 0x00,\n                                       0x00, 0x00, 0x00, 0x00,\n                                       0x00, 0x00, 0xff, 0xff,\n                                       0x00, 0x00, 0x00, 0x00 };\n\nstatic int address_not_null(u8 *ip)\n{\n\treturn (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));\n}\n\n \nstatic ssize_t sprintf_ipaddr(char *buf, u8 *ip)\n{\n\tchar *str = buf;\n\n\tif (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0 &&\n\t    ip[4] == 0 && ip[5] == 0 && ip[6] == 0 && ip[7] == 0 &&\n\t    ip[8] == 0 && ip[9] == 0 && ip[10] == 0xff && ip[11] == 0xff) {\n\t\t \n\t\tstr += sprintf(buf, \"%pI4\", ip + 12);\n\t} else {\n\t\t \n\t\tstr += sprintf(str, \"%pI6\", ip);\n\t}\n\tstr += sprintf(str, \"\\n\");\n\treturn str - buf;\n}\n\nstatic ssize_t sprintf_string(char *str, int len, char *buf)\n{\n\treturn sprintf(str, \"%.*s\\n\", len, buf);\n}\n\n \nstatic int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)\n{\n\tif (hdr->id != id) {\n\t\tprintk(KERN_ERR \"iBFT error: We expected the %s \" \\\n\t\t\t\t\"field header.id to have %d but \" \\\n\t\t\t\t\"found %d instead!\\n\", t, id, hdr->id);\n\t\treturn -ENODEV;\n\t}\n\tif (length && hdr->length != length) {\n\t\tprintk(KERN_ERR \"iBFT error: We expected the %s \" \\\n\t\t\t\t\"field header.length to have %d but \" \\\n\t\t\t\t\"found %d instead!\\n\", t, length, hdr->length);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_initiator *initiator = entry->initiator;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\n\tif (!initiator)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INDEX:\n\t\tstr += sprintf(str, \"%d\\n\", initiator->hdr.index);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_FLAGS:\n\t\tstr += sprintf(str, \"%d\\n\", initiator->hdr.flags);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_ISNS_SERVER:\n\t\tstr += sprintf_ipaddr(str, initiator->isns_server);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_SLP_SERVER:\n\t\tstr += sprintf_ipaddr(str, initiator->slp_server);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_PRI_RADIUS_SERVER:\n\t\tstr += sprintf_ipaddr(str, initiator->pri_radius_server);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_SEC_RADIUS_SERVER:\n\t\tstr += sprintf_ipaddr(str, initiator->sec_radius_server);\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\tstr += sprintf_string(str, initiator->initiator_name_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      initiator->initiator_name_off);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn str - buf;\n}\n\nstatic ssize_t ibft_attr_show_nic(void *data, int type, char *buf)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\t__be32 val;\n\n\tif (!nic)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\tstr += sprintf(str, \"%d\\n\", nic->hdr.index);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\tstr += sprintf(str, \"%d\\n\", nic->hdr.flags);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_IP_ADDR:\n\t\tstr += sprintf_ipaddr(str, nic->ip_addr);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_SUBNET_MASK:\n\t\tval = cpu_to_be32(~((1 << (32-nic->subnet_mask_prefix))-1));\n\t\tstr += sprintf(str, \"%pI4\", &val);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_PREFIX_LEN:\n\t\tstr += sprintf(str, \"%d\\n\", nic->subnet_mask_prefix);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_ORIGIN:\n\t\tstr += sprintf(str, \"%d\\n\", nic->origin);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_GATEWAY:\n\t\tstr += sprintf_ipaddr(str, nic->gateway);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_PRIMARY_DNS:\n\t\tstr += sprintf_ipaddr(str, nic->primary_dns);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_SECONDARY_DNS:\n\t\tstr += sprintf_ipaddr(str, nic->secondary_dns);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_DHCP:\n\t\tstr += sprintf_ipaddr(str, nic->dhcp);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_VLAN:\n\t\tstr += sprintf(str, \"%d\\n\", nic->vlan);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\tstr += sprintf(str, \"%pM\\n\", nic->mac);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_HOSTNAME:\n\t\tstr += sprintf_string(str, nic->hostname_len,\n\t\t\t\t      (char *)ibft_loc + nic->hostname_off);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn str - buf;\n};\n\nstatic ssize_t ibft_attr_show_target(void *data, int type, char *buf)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_tgt *tgt = entry->tgt;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\tint i;\n\n\tif (!tgt)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_INDEX:\n\t\tstr += sprintf(str, \"%d\\n\", tgt->hdr.index);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\tstr += sprintf(str, \"%d\\n\", tgt->hdr.flags);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\t\tstr += sprintf_ipaddr(str, tgt->ip_addr);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_PORT:\n\t\tstr += sprintf(str, \"%d\\n\", tgt->port);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_LUN:\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tstr += sprintf(str, \"%x\", (u8)tgt->lun[i]);\n\t\tstr += sprintf(str, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\t\tstr += sprintf(str, \"%d\\n\", tgt->nic_assoc);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_TYPE:\n\t\tstr += sprintf(str, \"%d\\n\", tgt->chap_type);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\tstr += sprintf_string(str, tgt->tgt_name_len,\n\t\t\t\t      (char *)ibft_loc + tgt->tgt_name_off);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\t\tstr += sprintf_string(str, tgt->chap_name_len,\n\t\t\t\t      (char *)ibft_loc + tgt->chap_name_off);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\tstr += sprintf_string(str, tgt->chap_secret_len,\n\t\t\t\t      (char *)ibft_loc + tgt->chap_secret_off);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\t\tstr += sprintf_string(str, tgt->rev_chap_name_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      tgt->rev_chap_name_off);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\tstr += sprintf_string(str, tgt->rev_chap_secret_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      tgt->rev_chap_secret_off);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn str - buf;\n}\n\nstatic ssize_t ibft_attr_show_acpitbl(void *data, int type, char *buf)\n{\n\tstruct ibft_kobject *entry = data;\n\tchar *str = buf;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ACPITBL_SIGNATURE:\n\t\tstr += sprintf_string(str, ACPI_NAMESEG_SIZE,\n\t\t\t\t      entry->header->header.signature);\n\t\tbreak;\n\tcase ISCSI_BOOT_ACPITBL_OEM_ID:\n\t\tstr += sprintf_string(str, ACPI_OEM_ID_SIZE,\n\t\t\t\t      entry->header->header.oem_id);\n\t\tbreak;\n\tcase ISCSI_BOOT_ACPITBL_OEM_TABLE_ID:\n\t\tstr += sprintf_string(str, ACPI_OEM_TABLE_ID_SIZE,\n\t\t\t\t      entry->header->header.oem_table_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn str - buf;\n}\n\nstatic int __init ibft_check_device(void)\n{\n\tint len;\n\tu8 *pos;\n\tu8 csum = 0;\n\n\tlen = ibft_addr->header.length;\n\n\t \n\tif (ibft_addr->header.revision != 1) {\n\t\tprintk(KERN_ERR \"iBFT module supports only revision 1, \" \\\n\t\t\t\t\"while this is %d.\\n\",\n\t\t\t\tibft_addr->header.revision);\n\t\treturn -ENOENT;\n\t}\n\tfor (pos = (u8 *)ibft_addr; pos < (u8 *)ibft_addr + len; pos++)\n\t\tcsum += *pos;\n\n\tif (csum) {\n\t\tprintk(KERN_ERR \"iBFT has incorrect checksum (0x%x)!\\n\", csum);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic umode_t ibft_check_nic_for(void *data, int type)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_INDEX:\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_IP_ADDR:\n\t\tif (address_not_null(nic->ip_addr))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_PREFIX_LEN:\n\tcase ISCSI_BOOT_ETH_SUBNET_MASK:\n\t\tif (nic->subnet_mask_prefix)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_ORIGIN:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_GATEWAY:\n\t\tif (address_not_null(nic->gateway))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_PRIMARY_DNS:\n\t\tif (address_not_null(nic->primary_dns))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_SECONDARY_DNS:\n\t\tif (address_not_null(nic->secondary_dns))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_DHCP:\n\t\tif (address_not_null(nic->dhcp))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_VLAN:\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_HOSTNAME:\n\t\tif (nic->hostname_off)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic umode_t __init ibft_check_tgt_for(void *data, int type)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_tgt *tgt = entry->tgt;\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_INDEX:\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\tcase ISCSI_BOOT_TGT_PORT:\n\tcase ISCSI_BOOT_TGT_LUN:\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\tcase ISCSI_BOOT_TGT_CHAP_TYPE:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\tif (tgt->tgt_name_len)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\tif (tgt->chap_name_len)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\tif (tgt->rev_chap_name_len)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic umode_t __init ibft_check_initiator_for(void *data, int type)\n{\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_initiator *init = entry->initiator;\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INDEX:\n\tcase ISCSI_BOOT_INI_FLAGS:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_ISNS_SERVER:\n\t\tif (address_not_null(init->isns_server))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_SLP_SERVER:\n\t\tif (address_not_null(init->slp_server))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_PRI_RADIUS_SERVER:\n\t\tif (address_not_null(init->pri_radius_server))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_SEC_RADIUS_SERVER:\n\t\tif (address_not_null(init->sec_radius_server))\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\tif (init->initiator_name_len)\n\t\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic umode_t __init ibft_check_acpitbl_for(void *data, int type)\n{\n\n\tumode_t rc = 0;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ACPITBL_SIGNATURE:\n\tcase ISCSI_BOOT_ACPITBL_OEM_ID:\n\tcase ISCSI_BOOT_ACPITBL_OEM_TABLE_ID:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic void ibft_kobj_release(void *data)\n{\n\tkfree(data);\n}\n\n \nstatic int __init ibft_create_kobject(struct acpi_table_ibft *header,\n\t\t\t\t      struct ibft_hdr *hdr)\n{\n\tstruct iscsi_boot_kobj *boot_kobj = NULL;\n\tstruct ibft_kobject *ibft_kobj = NULL;\n\tstruct ibft_nic *nic = (struct ibft_nic *)hdr;\n\tstruct pci_dev *pci_dev;\n\tint rc = 0;\n\n\tibft_kobj = kzalloc(sizeof(*ibft_kobj), GFP_KERNEL);\n\tif (!ibft_kobj)\n\t\treturn -ENOMEM;\n\n\tibft_kobj->header = header;\n\tibft_kobj->hdr = hdr;\n\n\tswitch (hdr->id) {\n\tcase id_initiator:\n\t\trc = ibft_verify_hdr(\"initiator\", hdr, id_initiator,\n\t\t\t\t     sizeof(*ibft_kobj->initiator));\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tboot_kobj = iscsi_boot_create_initiator(boot_kset, hdr->index,\n\t\t\t\t\t\tibft_kobj,\n\t\t\t\t\t\tibft_attr_show_initiator,\n\t\t\t\t\t\tibft_check_initiator_for,\n\t\t\t\t\t\tibft_kobj_release);\n\t\tif (!boot_kobj) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_ibft_obj;\n\t\t}\n\t\tbreak;\n\tcase id_nic:\n\t\trc = ibft_verify_hdr(\"ethernet\", hdr, id_nic,\n\t\t\t\t     sizeof(*ibft_kobj->nic));\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tboot_kobj = iscsi_boot_create_ethernet(boot_kset, hdr->index,\n\t\t\t\t\t\t       ibft_kobj,\n\t\t\t\t\t\t       ibft_attr_show_nic,\n\t\t\t\t\t\t       ibft_check_nic_for,\n\t\t\t\t\t\t       ibft_kobj_release);\n\t\tif (!boot_kobj) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_ibft_obj;\n\t\t}\n\t\tbreak;\n\tcase id_target:\n\t\trc = ibft_verify_hdr(\"target\", hdr, id_target,\n\t\t\t\t     sizeof(*ibft_kobj->tgt));\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tboot_kobj = iscsi_boot_create_target(boot_kset, hdr->index,\n\t\t\t\t\t\t     ibft_kobj,\n\t\t\t\t\t\t     ibft_attr_show_target,\n\t\t\t\t\t\t     ibft_check_tgt_for,\n\t\t\t\t\t\t     ibft_kobj_release);\n\t\tif (!boot_kobj) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_ibft_obj;\n\t\t}\n\t\tbreak;\n\tcase id_reserved:\n\tcase id_control:\n\tcase id_extensions:\n\t\t \n\t\trc = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"iBFT has unknown structure type (%d). \" \\\n\t\t\t\t\"Report this bug to %.6s!\\n\", hdr->id,\n\t\t\t\theader->header.oem_id);\n\t\trc = 1;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\t \n\t\trc = 0;\n\t\tgoto free_ibft_obj;\n\t}\n\n\tif (hdr->id == id_nic) {\n\t\t \n\t\tpci_dev = pci_get_domain_bus_and_slot(0,\n\t\t\t\t\t\t(nic->pci_bdf & 0xff00) >> 8,\n\t\t\t\t\t\t(nic->pci_bdf & 0xff));\n\t\tif (pci_dev) {\n\t\t\trc = sysfs_create_link(&boot_kobj->kobj,\n\t\t\t\t\t       &pci_dev->dev.kobj, \"device\");\n\t\t\tpci_dev_put(pci_dev);\n\t\t}\n\t}\n\treturn 0;\n\nfree_ibft_obj:\n\tkfree(ibft_kobj);\n\treturn rc;\n}\n\n \nstatic int __init ibft_register_kobjects(struct acpi_table_ibft *header)\n{\n\tstruct ibft_control *control = NULL;\n\tstruct iscsi_boot_kobj *boot_kobj;\n\tstruct ibft_kobject *ibft_kobj;\n\tvoid *ptr, *end;\n\tint rc = 0;\n\tu16 offset;\n\tu16 eot_offset;\n\n\tcontrol = (void *)header + sizeof(*header);\n\tend = (void *)control + control->hdr.length;\n\teot_offset = (void *)header + header->header.length - (void *)control;\n\trc = ibft_verify_hdr(\"control\", (struct ibft_hdr *)control, id_control, 0);\n\n\t \n\trc |= ((control->hdr.index) ? -ENODEV : 0);\n\trc |= ((control->hdr.length < sizeof(*control)) ? -ENODEV : 0);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"iBFT error: Control header is invalid!\\n\");\n\t\treturn rc;\n\t}\n\tfor (ptr = &control->initiator_off; ptr + sizeof(u16) <= end; ptr += sizeof(u16)) {\n\t\toffset = *(u16 *)ptr;\n\t\tif (offset && offset < header->header.length &&\n\t\t\t\t\t\toffset < eot_offset) {\n\t\t\trc = ibft_create_kobject(header,\n\t\t\t\t\t\t (void *)header + offset);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\tibft_kobj = kzalloc(sizeof(*ibft_kobj), GFP_KERNEL);\n\tif (!ibft_kobj)\n\t\treturn -ENOMEM;\n\n\tibft_kobj->header = header;\n\tibft_kobj->hdr = NULL;  \n\n\tboot_kobj = iscsi_boot_create_acpitbl(boot_kset, 0,\n\t\t\t\t\tibft_kobj,\n\t\t\t\t\tibft_attr_show_acpitbl,\n\t\t\t\t\tibft_check_acpitbl_for,\n\t\t\t\t\tibft_kobj_release);\n\tif (!boot_kobj)  {\n\t\tkfree(ibft_kobj);\n\t\trc = -ENOMEM;\n\t}\n\n\treturn rc;\n}\n\nstatic void ibft_unregister(void)\n{\n\tstruct iscsi_boot_kobj *boot_kobj, *tmp_kobj;\n\tstruct ibft_kobject *ibft_kobj;\n\n\tlist_for_each_entry_safe(boot_kobj, tmp_kobj,\n\t\t\t\t &boot_kset->kobj_list, list) {\n\t\tibft_kobj = boot_kobj->data;\n\t\tif (ibft_kobj->hdr && ibft_kobj->hdr->id == id_nic)\n\t\t\tsysfs_remove_link(&boot_kobj->kobj, \"device\");\n\t};\n}\n\nstatic void ibft_cleanup(void)\n{\n\tif (boot_kset) {\n\t\tibft_unregister();\n\t\tiscsi_boot_destroy_kset(boot_kset);\n\t}\n}\n\nstatic void __exit ibft_exit(void)\n{\n\tibft_cleanup();\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct {\n\tchar *sign;\n} ibft_signs[] = {\n\t \n\t{ ACPI_SIG_IBFT },\n\t{ \"iBFT\" },\n\t{ \"BIFT\" },\t \n};\n\nstatic void __init acpi_find_ibft_region(void)\n{\n\tint i;\n\tstruct acpi_table_header *table = NULL;\n\n\tif (acpi_disabled)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibft_signs) && !ibft_addr; i++) {\n\t\tacpi_get_table(ibft_signs[i].sign, 0, &table);\n\t\tibft_addr = (struct acpi_table_ibft *)table;\n\t}\n}\n#else\nstatic void __init acpi_find_ibft_region(void)\n{\n}\n#endif\n#ifdef CONFIG_ISCSI_IBFT_FIND\nstatic int __init acpi_find_isa_region(void)\n{\n\tif (ibft_phys_addr) {\n\t\tibft_addr = isa_bus_to_virt(ibft_phys_addr);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n#else\nstatic int __init acpi_find_isa_region(void)\n{\n\treturn -ENODEV;\n}\n#endif\n \nstatic int __init ibft_init(void)\n{\n\tint rc = 0;\n\n\t \n\tif (acpi_find_isa_region())\n\t\tacpi_find_ibft_region();\n\n\tif (ibft_addr) {\n\t\tpr_info(\"iBFT detected.\\n\");\n\n\t\trc = ibft_check_device();\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tboot_kset = iscsi_boot_create_kset(\"ibft\");\n\t\tif (!boot_kset)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\trc = ibft_register_kobjects(ibft_addr);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\t} else\n\t\tprintk(KERN_INFO \"No iBFT detected.\\n\");\n\n\treturn 0;\n\nout_free:\n\tibft_cleanup();\n\treturn rc;\n}\n\nmodule_init(ibft_init);\nmodule_exit(ibft_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}