{
  "module_name": "qcom_scm-legacy.c",
  "hash_id": "07fbdba38bff0bea9aac05b079db9d9110faccd8e58211349d3a85570544b9b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/qcom_scm-legacy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/arm-smccc.h>\n#include <linux/dma-mapping.h>\n\n#include \"qcom_scm.h\"\n\nstatic DEFINE_MUTEX(qcom_scm_lock);\n\n\n \nstruct arm_smccc_args {\n\tunsigned long args[8];\n};\n\n\n \nstruct scm_legacy_command {\n\t__le32 len;\n\t__le32 buf_offset;\n\t__le32 resp_hdr_offset;\n\t__le32 id;\n\t__le32 buf[];\n};\n\n \nstruct scm_legacy_response {\n\t__le32 len;\n\t__le32 buf_offset;\n\t__le32 is_complete;\n};\n\n \nstatic inline struct scm_legacy_response *scm_legacy_command_to_response(\n\t\tconst struct scm_legacy_command *cmd)\n{\n\treturn (void *)cmd + le32_to_cpu(cmd->resp_hdr_offset);\n}\n\n \nstatic inline void *scm_legacy_get_command_buffer(\n\t\tconst struct scm_legacy_command *cmd)\n{\n\treturn (void *)cmd->buf;\n}\n\n \nstatic inline void *scm_legacy_get_response_buffer(\n\t\tconst struct scm_legacy_response *rsp)\n{\n\treturn (void *)rsp + le32_to_cpu(rsp->buf_offset);\n}\n\nstatic void __scm_legacy_do(const struct arm_smccc_args *smc,\n\t\t\t    struct arm_smccc_res *res)\n{\n\tdo {\n\t\tarm_smccc_smc(smc->args[0], smc->args[1], smc->args[2],\n\t\t\t      smc->args[3], smc->args[4], smc->args[5],\n\t\t\t      smc->args[6], smc->args[7], res);\n\t} while (res->a0 == QCOM_SCM_INTERRUPTED);\n}\n\n \nint scm_legacy_call(struct device *dev, const struct qcom_scm_desc *desc,\n\t\t    struct qcom_scm_res *res)\n{\n\tu8 arglen = desc->arginfo & 0xf;\n\tint ret = 0, context_id;\n\tunsigned int i;\n\tstruct scm_legacy_command *cmd;\n\tstruct scm_legacy_response *rsp;\n\tstruct arm_smccc_args smc = {0};\n\tstruct arm_smccc_res smc_res;\n\tconst size_t cmd_len = arglen * sizeof(__le32);\n\tconst size_t resp_len = MAX_QCOM_SCM_RETS * sizeof(__le32);\n\tsize_t alloc_len = sizeof(*cmd) + cmd_len + sizeof(*rsp) + resp_len;\n\tdma_addr_t cmd_phys;\n\t__le32 *arg_buf;\n\tconst __le32 *res_buf;\n\n\tcmd = kzalloc(PAGE_ALIGN(alloc_len), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = cpu_to_le32(alloc_len);\n\tcmd->buf_offset = cpu_to_le32(sizeof(*cmd));\n\tcmd->resp_hdr_offset = cpu_to_le32(sizeof(*cmd) + cmd_len);\n\tcmd->id = cpu_to_le32(SCM_LEGACY_FNID(desc->svc, desc->cmd));\n\n\targ_buf = scm_legacy_get_command_buffer(cmd);\n\tfor (i = 0; i < arglen; i++)\n\t\targ_buf[i] = cpu_to_le32(desc->args[i]);\n\n\trsp = scm_legacy_command_to_response(cmd);\n\n\tcmd_phys = dma_map_single(dev, cmd, alloc_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, cmd_phys)) {\n\t\tkfree(cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmc.args[0] = 1;\n\tsmc.args[1] = (unsigned long)&context_id;\n\tsmc.args[2] = cmd_phys;\n\n\tmutex_lock(&qcom_scm_lock);\n\t__scm_legacy_do(&smc, &smc_res);\n\tif (smc_res.a0)\n\t\tret = qcom_scm_remap_error(smc_res.a0);\n\tmutex_unlock(&qcom_scm_lock);\n\tif (ret)\n\t\tgoto out;\n\n\tdo {\n\t\tdma_sync_single_for_cpu(dev, cmd_phys + sizeof(*cmd) + cmd_len,\n\t\t\t\t\tsizeof(*rsp), DMA_FROM_DEVICE);\n\t} while (!rsp->is_complete);\n\n\tdma_sync_single_for_cpu(dev, cmd_phys + sizeof(*cmd) + cmd_len +\n\t\t\t\tle32_to_cpu(rsp->buf_offset),\n\t\t\t\tresp_len, DMA_FROM_DEVICE);\n\n\tif (res) {\n\t\tres_buf = scm_legacy_get_response_buffer(rsp);\n\t\tfor (i = 0; i < MAX_QCOM_SCM_RETS; i++)\n\t\t\tres->result[i] = le32_to_cpu(res_buf[i]);\n\t}\nout:\n\tdma_unmap_single(dev, cmd_phys, alloc_len, DMA_TO_DEVICE);\n\tkfree(cmd);\n\treturn ret;\n}\n\n#define SCM_LEGACY_ATOMIC_N_REG_ARGS\t5\n#define SCM_LEGACY_ATOMIC_FIRST_REG_IDX\t2\n#define SCM_LEGACY_CLASS_REGISTER\t\t(0x2 << 8)\n#define SCM_LEGACY_MASK_IRQS\t\tBIT(5)\n#define SCM_LEGACY_ATOMIC_ID(svc, cmd, n) \\\n\t\t\t\t((SCM_LEGACY_FNID(svc, cmd) << 12) | \\\n\t\t\t\tSCM_LEGACY_CLASS_REGISTER | \\\n\t\t\t\tSCM_LEGACY_MASK_IRQS | \\\n\t\t\t\t(n & 0xf))\n\n \nint scm_legacy_call_atomic(struct device *unused,\n\t\t\t   const struct qcom_scm_desc *desc,\n\t\t\t   struct qcom_scm_res *res)\n{\n\tint context_id;\n\tstruct arm_smccc_res smc_res;\n\tsize_t arglen = desc->arginfo & 0xf;\n\n\tBUG_ON(arglen > SCM_LEGACY_ATOMIC_N_REG_ARGS);\n\n\tarm_smccc_smc(SCM_LEGACY_ATOMIC_ID(desc->svc, desc->cmd, arglen),\n\t\t      (unsigned long)&context_id,\n\t\t      desc->args[0], desc->args[1], desc->args[2],\n\t\t      desc->args[3], desc->args[4], 0, &smc_res);\n\n\tif (res) {\n\t\tres->result[0] = smc_res.a1;\n\t\tres->result[1] = smc_res.a2;\n\t\tres->result[2] = smc_res.a3;\n\t}\n\n\treturn smc_res.a0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}