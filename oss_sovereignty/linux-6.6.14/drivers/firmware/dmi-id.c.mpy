{
  "module_name": "dmi-id.c",
  "hash_id": "0a20bb6672d1df2027bafe385bc05d993ab7c65fab9b4fff90995eef336e0615",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/dmi-id.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\nstruct dmi_device_attribute{\n\tstruct device_attribute dev_attr;\n\tint field;\n};\n#define to_dmi_dev_attr(_dev_attr) \\\n\tcontainer_of(_dev_attr, struct dmi_device_attribute, dev_attr)\n\nstatic ssize_t sys_dmi_field_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *page)\n{\n\tint field = to_dmi_dev_attr(attr)->field;\n\tssize_t len;\n\tlen = scnprintf(page, PAGE_SIZE, \"%s\\n\", dmi_get_system_info(field));\n\tpage[len-1] = '\\n';\n\treturn len;\n}\n\n#define DMI_ATTR(_name, _mode, _show, _field)\t\t\t\\\n\t{ .dev_attr = __ATTR(_name, _mode, _show, NULL),\t\\\n\t  .field = _field }\n\n#define DEFINE_DMI_ATTR_WITH_SHOW(_name, _mode, _field)\t\t\\\nstatic struct dmi_device_attribute sys_dmi_##_name##_attr =\t\\\n\tDMI_ATTR(_name, _mode, sys_dmi_field_show, _field);\n\nDEFINE_DMI_ATTR_WITH_SHOW(bios_vendor,\t\t0444, DMI_BIOS_VENDOR);\nDEFINE_DMI_ATTR_WITH_SHOW(bios_version,\t\t0444, DMI_BIOS_VERSION);\nDEFINE_DMI_ATTR_WITH_SHOW(bios_date,\t\t0444, DMI_BIOS_DATE);\nDEFINE_DMI_ATTR_WITH_SHOW(sys_vendor,\t\t0444, DMI_SYS_VENDOR);\nDEFINE_DMI_ATTR_WITH_SHOW(bios_release,\t\t0444, DMI_BIOS_RELEASE);\nDEFINE_DMI_ATTR_WITH_SHOW(ec_firmware_release,\t0444, DMI_EC_FIRMWARE_RELEASE);\nDEFINE_DMI_ATTR_WITH_SHOW(product_name,\t\t0444, DMI_PRODUCT_NAME);\nDEFINE_DMI_ATTR_WITH_SHOW(product_version,\t0444, DMI_PRODUCT_VERSION);\nDEFINE_DMI_ATTR_WITH_SHOW(product_serial,\t0400, DMI_PRODUCT_SERIAL);\nDEFINE_DMI_ATTR_WITH_SHOW(product_uuid,\t\t0400, DMI_PRODUCT_UUID);\nDEFINE_DMI_ATTR_WITH_SHOW(product_sku,\t\t0444, DMI_PRODUCT_SKU);\nDEFINE_DMI_ATTR_WITH_SHOW(product_family,\t0444, DMI_PRODUCT_FAMILY);\nDEFINE_DMI_ATTR_WITH_SHOW(board_vendor,\t\t0444, DMI_BOARD_VENDOR);\nDEFINE_DMI_ATTR_WITH_SHOW(board_name,\t\t0444, DMI_BOARD_NAME);\nDEFINE_DMI_ATTR_WITH_SHOW(board_version,\t0444, DMI_BOARD_VERSION);\nDEFINE_DMI_ATTR_WITH_SHOW(board_serial,\t\t0400, DMI_BOARD_SERIAL);\nDEFINE_DMI_ATTR_WITH_SHOW(board_asset_tag,\t0444, DMI_BOARD_ASSET_TAG);\nDEFINE_DMI_ATTR_WITH_SHOW(chassis_vendor,\t0444, DMI_CHASSIS_VENDOR);\nDEFINE_DMI_ATTR_WITH_SHOW(chassis_type,\t\t0444, DMI_CHASSIS_TYPE);\nDEFINE_DMI_ATTR_WITH_SHOW(chassis_version,\t0444, DMI_CHASSIS_VERSION);\nDEFINE_DMI_ATTR_WITH_SHOW(chassis_serial,\t0400, DMI_CHASSIS_SERIAL);\nDEFINE_DMI_ATTR_WITH_SHOW(chassis_asset_tag,\t0444, DMI_CHASSIS_ASSET_TAG);\n\nstatic void ascii_filter(char *d, const char *s)\n{\n\t \n\tfor (; *s; s++)\n\t\tif (*s > ' ' && *s < 127 && *s != ':')\n\t\t\t*(d++) = *s;\n\n\t*d = 0;\n}\n\nstatic ssize_t get_modalias(char *buffer, size_t buffer_size)\n{\n\t \n\tstatic const struct mafield {\n\t\tconst char *prefix;\n\t\tint field;\n\t} fields[] = {\n\t\t{ \"bvn\", DMI_BIOS_VENDOR },\n\t\t{ \"bvr\", DMI_BIOS_VERSION },\n\t\t{ \"bd\",  DMI_BIOS_DATE },\n\t\t{ \"br\",  DMI_BIOS_RELEASE },\n\t\t{ \"efr\", DMI_EC_FIRMWARE_RELEASE },\n\t\t{ \"svn\", DMI_SYS_VENDOR },\n\t\t{ \"pn\",  DMI_PRODUCT_NAME },\n\t\t{ \"pvr\", DMI_PRODUCT_VERSION },\n\t\t{ \"rvn\", DMI_BOARD_VENDOR },\n\t\t{ \"rn\",  DMI_BOARD_NAME },\n\t\t{ \"rvr\", DMI_BOARD_VERSION },\n\t\t{ \"cvn\", DMI_CHASSIS_VENDOR },\n\t\t{ \"ct\",  DMI_CHASSIS_TYPE },\n\t\t{ \"cvr\", DMI_CHASSIS_VERSION },\n\t\t{ \"sku\", DMI_PRODUCT_SKU },\n\t\t{ NULL,  DMI_NONE }\n\t};\n\n\tssize_t l, left;\n\tchar *p;\n\tconst struct mafield *f;\n\n\tstrcpy(buffer, \"dmi\");\n\tp = buffer + 3; left = buffer_size - 4;\n\n\tfor (f = fields; f->prefix && left > 0; f++) {\n\t\tconst char *c;\n\t\tchar *t;\n\n\t\tc = dmi_get_system_info(f->field);\n\t\tif (!c)\n\t\t\tcontinue;\n\n\t\tt = kmalloc(strlen(c) + 1, GFP_KERNEL);\n\t\tif (!t)\n\t\t\tbreak;\n\t\tascii_filter(t, c);\n\t\tl = scnprintf(p, left, \":%s%s\", f->prefix, t);\n\t\tkfree(t);\n\n\t\tp += l;\n\t\tleft -= l;\n\t}\n\n\tp[0] = ':';\n\tp[1] = 0;\n\n\treturn p - buffer + 1;\n}\n\nstatic ssize_t sys_dmi_modalias_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *page)\n{\n\tssize_t r;\n\tr = get_modalias(page, PAGE_SIZE-1);\n\tpage[r] = '\\n';\n\tpage[r+1] = 0;\n\treturn r+1;\n}\n\nstatic struct device_attribute sys_dmi_modalias_attr =\n\t__ATTR(modalias, 0444, sys_dmi_modalias_show, NULL);\n\nstatic struct attribute *sys_dmi_attributes[DMI_STRING_MAX+2];\n\nstatic struct attribute_group sys_dmi_attribute_group = {\n\t.attrs = sys_dmi_attributes,\n};\n\nstatic const struct attribute_group* sys_dmi_attribute_groups[] = {\n\t&sys_dmi_attribute_group,\n\tNULL\n};\n\nstatic int dmi_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tssize_t len;\n\n\tif (add_uevent_var(env, \"MODALIAS=\"))\n\t\treturn -ENOMEM;\n\tlen = get_modalias(&env->buf[env->buflen - 1],\n\t\t\t   sizeof(env->buf) - env->buflen);\n\tif (len >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\tenv->buflen += len;\n\treturn 0;\n}\n\nstatic struct class dmi_class = {\n\t.name = \"dmi\",\n\t.dev_release = (void(*)(struct device *)) kfree,\n\t.dev_uevent = dmi_dev_uevent,\n};\n\nstatic struct device *dmi_dev;\n\n \n\n#define ADD_DMI_ATTR(_name, _field) \\\n\tif (dmi_get_system_info(_field)) \\\n\t\tsys_dmi_attributes[i++] = &sys_dmi_##_name##_attr.dev_attr.attr;\n\n \nstatic void __init dmi_id_init_attr_table(void)\n{\n\tint i;\n\n\t \n\ti = 0;\n\tADD_DMI_ATTR(bios_vendor,       DMI_BIOS_VENDOR);\n\tADD_DMI_ATTR(bios_version,      DMI_BIOS_VERSION);\n\tADD_DMI_ATTR(bios_date,         DMI_BIOS_DATE);\n\tADD_DMI_ATTR(bios_release,      DMI_BIOS_RELEASE);\n\tADD_DMI_ATTR(ec_firmware_release, DMI_EC_FIRMWARE_RELEASE);\n\tADD_DMI_ATTR(sys_vendor,        DMI_SYS_VENDOR);\n\tADD_DMI_ATTR(product_name,      DMI_PRODUCT_NAME);\n\tADD_DMI_ATTR(product_version,   DMI_PRODUCT_VERSION);\n\tADD_DMI_ATTR(product_serial,    DMI_PRODUCT_SERIAL);\n\tADD_DMI_ATTR(product_uuid,      DMI_PRODUCT_UUID);\n\tADD_DMI_ATTR(product_family,    DMI_PRODUCT_FAMILY);\n\tADD_DMI_ATTR(product_sku,       DMI_PRODUCT_SKU);\n\tADD_DMI_ATTR(board_vendor,      DMI_BOARD_VENDOR);\n\tADD_DMI_ATTR(board_name,        DMI_BOARD_NAME);\n\tADD_DMI_ATTR(board_version,     DMI_BOARD_VERSION);\n\tADD_DMI_ATTR(board_serial,      DMI_BOARD_SERIAL);\n\tADD_DMI_ATTR(board_asset_tag,   DMI_BOARD_ASSET_TAG);\n\tADD_DMI_ATTR(chassis_vendor,    DMI_CHASSIS_VENDOR);\n\tADD_DMI_ATTR(chassis_type,      DMI_CHASSIS_TYPE);\n\tADD_DMI_ATTR(chassis_version,   DMI_CHASSIS_VERSION);\n\tADD_DMI_ATTR(chassis_serial,    DMI_CHASSIS_SERIAL);\n\tADD_DMI_ATTR(chassis_asset_tag, DMI_CHASSIS_ASSET_TAG);\n\tsys_dmi_attributes[i++] = &sys_dmi_modalias_attr.attr;\n}\n\nstatic int __init dmi_id_init(void)\n{\n\tint ret;\n\n\tif (!dmi_available)\n\t\treturn -ENODEV;\n\n\tdmi_id_init_attr_table();\n\n\tret = class_register(&dmi_class);\n\tif (ret)\n\t\treturn ret;\n\n\tdmi_dev = kzalloc(sizeof(*dmi_dev), GFP_KERNEL);\n\tif (!dmi_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_class_unregister;\n\t}\n\n\tdmi_dev->class = &dmi_class;\n\tdev_set_name(dmi_dev, \"id\");\n\tdmi_dev->groups = sys_dmi_attribute_groups;\n\n\tret = device_register(dmi_dev);\n\tif (ret)\n\t\tgoto fail_put_dmi_dev;\n\n\treturn 0;\n\nfail_put_dmi_dev:\n\tput_device(dmi_dev);\n\nfail_class_unregister:\n\tclass_unregister(&dmi_class);\n\n\treturn ret;\n}\n\narch_initcall(dmi_id_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}