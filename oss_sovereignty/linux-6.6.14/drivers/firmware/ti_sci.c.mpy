{
  "module_name": "ti_sci.c",
  "hash_id": "2c07d8730e6a26808fbe3cdcf92bc03b54f8b1f14f8dfaab191f74025c2029f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/ti_sci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/bitmap.h>\n#include <linux/debugfs.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n#include <linux/soc/ti/ti-msgmgr.h>\n#include <linux/soc/ti/ti_sci_protocol.h>\n#include <linux/reboot.h>\n\n#include \"ti_sci.h\"\n\n \nstatic LIST_HEAD(ti_sci_list);\n \nstatic DEFINE_MUTEX(ti_sci_list_mutex);\n\n \nstruct ti_sci_xfer {\n\tstruct ti_msgmgr_message tx_message;\n\tu8 rx_len;\n\tu8 *xfer_buf;\n\tstruct completion done;\n};\n\n \nstruct ti_sci_xfers_info {\n\tstruct semaphore sem_xfer_count;\n\tstruct ti_sci_xfer *xfer_block;\n\tunsigned long *xfer_alloc_table;\n\t \n\tspinlock_t xfer_lock;\n};\n\n \nstruct ti_sci_desc {\n\tu8 default_host_id;\n\tint max_rx_timeout_ms;\n\tint max_msgs;\n\tint max_msg_size;\n};\n\n \nstruct ti_sci_info {\n\tstruct device *dev;\n\tstruct notifier_block nb;\n\tconst struct ti_sci_desc *desc;\n\tstruct dentry *d;\n\tvoid __iomem *debug_region;\n\tchar *debug_buffer;\n\tsize_t debug_region_size;\n\tstruct ti_sci_handle handle;\n\tstruct mbox_client cl;\n\tstruct mbox_chan *chan_tx;\n\tstruct mbox_chan *chan_rx;\n\tstruct ti_sci_xfers_info minfo;\n\tstruct list_head node;\n\tu8 host_id;\n\t \n\tint users;\n};\n\n#define cl_to_ti_sci_info(c)\tcontainer_of(c, struct ti_sci_info, cl)\n#define handle_to_ti_sci_info(h) container_of(h, struct ti_sci_info, handle)\n#define reboot_to_ti_sci_info(n) container_of(n, struct ti_sci_info, nb)\n\n#ifdef CONFIG_DEBUG_FS\n\n \nstatic int ti_sci_debug_show(struct seq_file *s, void *unused)\n{\n\tstruct ti_sci_info *info = s->private;\n\n\tmemcpy_fromio(info->debug_buffer, info->debug_region,\n\t\t      info->debug_region_size);\n\t \n\tseq_puts(s, info->debug_buffer);\n\treturn 0;\n}\n\n \nDEFINE_SHOW_ATTRIBUTE(ti_sci_debug);\n\n \nstatic int ti_sci_debugfs_create(struct platform_device *pdev,\n\t\t\t\t struct ti_sci_info *info)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tchar debug_name[50];\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"debug_messages\");\n\tinfo->debug_region = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(info->debug_region))\n\t\treturn 0;\n\tinfo->debug_region_size = resource_size(res);\n\n\tinfo->debug_buffer = devm_kcalloc(dev, info->debug_region_size + 1,\n\t\t\t\t\t  sizeof(char), GFP_KERNEL);\n\tif (!info->debug_buffer)\n\t\treturn -ENOMEM;\n\t \n\tinfo->debug_buffer[info->debug_region_size] = 0;\n\n\tsnprintf(debug_name, sizeof(debug_name), \"ti_sci_debug@%s\",\n\t\t dev_name(dev));\n\tinfo->d = debugfs_create_file(debug_name, 0444, NULL, info,\n\t\t\t\t      &ti_sci_debug_fops);\n\tif (IS_ERR(info->d))\n\t\treturn PTR_ERR(info->d);\n\n\tdev_dbg(dev, \"Debug region => %p, size = %zu bytes, resource: %pr\\n\",\n\t\tinfo->debug_region, info->debug_region_size, res);\n\treturn 0;\n}\n\n#else  \nstatic inline int ti_sci_debugfs_create(struct platform_device *dev,\n\t\t\t\t\tstruct ti_sci_info *info)\n{\n\treturn 0;\n}\n\nstatic inline void ti_sci_debugfs_destroy(struct platform_device *dev,\n\t\t\t\t\t  struct ti_sci_info *info)\n{\n}\n#endif  \n\n \nstatic inline void ti_sci_dump_header_dbg(struct device *dev,\n\t\t\t\t\t  struct ti_sci_msg_hdr *hdr)\n{\n\tdev_dbg(dev, \"MSGHDR:type=0x%04x host=0x%02x seq=0x%02x flags=0x%08x\\n\",\n\t\thdr->type, hdr->host, hdr->seq, hdr->flags);\n}\n\n \nstatic void ti_sci_rx_callback(struct mbox_client *cl, void *m)\n{\n\tstruct ti_sci_info *info = cl_to_ti_sci_info(cl);\n\tstruct device *dev = info->dev;\n\tstruct ti_sci_xfers_info *minfo = &info->minfo;\n\tstruct ti_msgmgr_message *mbox_msg = m;\n\tstruct ti_sci_msg_hdr *hdr = (struct ti_sci_msg_hdr *)mbox_msg->buf;\n\tstruct ti_sci_xfer *xfer;\n\tu8 xfer_id;\n\n\txfer_id = hdr->seq;\n\n\t \n\tif (!test_bit(xfer_id, minfo->xfer_alloc_table)) {\n\t\tdev_err(dev, \"Message for %d is not expected!\\n\", xfer_id);\n\t\treturn;\n\t}\n\n\txfer = &minfo->xfer_block[xfer_id];\n\n\t \n\tif (mbox_msg->len > info->desc->max_msg_size) {\n\t\tdev_err(dev, \"Unable to handle %zu xfer(max %d)\\n\",\n\t\t\tmbox_msg->len, info->desc->max_msg_size);\n\t\tti_sci_dump_header_dbg(dev, hdr);\n\t\treturn;\n\t}\n\tif (mbox_msg->len < xfer->rx_len) {\n\t\tdev_err(dev, \"Recv xfer %zu < expected %d length\\n\",\n\t\t\tmbox_msg->len, xfer->rx_len);\n\t\tti_sci_dump_header_dbg(dev, hdr);\n\t\treturn;\n\t}\n\n\tti_sci_dump_header_dbg(dev, hdr);\n\t \n\tmemcpy(xfer->xfer_buf, mbox_msg->buf, xfer->rx_len);\n\tcomplete(&xfer->done);\n}\n\n \nstatic struct ti_sci_xfer *ti_sci_get_one_xfer(struct ti_sci_info *info,\n\t\t\t\t\t       u16 msg_type, u32 msg_flags,\n\t\t\t\t\t       size_t tx_message_size,\n\t\t\t\t\t       size_t rx_message_size)\n{\n\tstruct ti_sci_xfers_info *minfo = &info->minfo;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_msg_hdr *hdr;\n\tunsigned long flags;\n\tunsigned long bit_pos;\n\tu8 xfer_id;\n\tint ret;\n\tint timeout;\n\n\t \n\tif (rx_message_size > info->desc->max_msg_size ||\n\t    tx_message_size > info->desc->max_msg_size ||\n\t    rx_message_size < sizeof(*hdr) || tx_message_size < sizeof(*hdr))\n\t\treturn ERR_PTR(-ERANGE);\n\n\t \n\ttimeout = msecs_to_jiffies(info->desc->max_rx_timeout_ms) * 5;\n\tret = down_timeout(&minfo->sem_xfer_count, timeout);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tspin_lock_irqsave(&minfo->xfer_lock, flags);\n\tbit_pos = find_first_zero_bit(minfo->xfer_alloc_table,\n\t\t\t\t      info->desc->max_msgs);\n\tset_bit(bit_pos, minfo->xfer_alloc_table);\n\tspin_unlock_irqrestore(&minfo->xfer_lock, flags);\n\n\t \n\txfer_id = (u8)bit_pos;\n\n\txfer = &minfo->xfer_block[xfer_id];\n\n\thdr = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\txfer->tx_message.len = tx_message_size;\n\txfer->tx_message.chan_rx = info->chan_rx;\n\txfer->tx_message.timeout_rx_ms = info->desc->max_rx_timeout_ms;\n\txfer->rx_len = (u8)rx_message_size;\n\n\treinit_completion(&xfer->done);\n\n\thdr->seq = xfer_id;\n\thdr->type = msg_type;\n\thdr->host = info->host_id;\n\thdr->flags = msg_flags;\n\n\treturn xfer;\n}\n\n \nstatic void ti_sci_put_one_xfer(struct ti_sci_xfers_info *minfo,\n\t\t\t\tstruct ti_sci_xfer *xfer)\n{\n\tunsigned long flags;\n\tstruct ti_sci_msg_hdr *hdr;\n\tu8 xfer_id;\n\n\thdr = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\txfer_id = hdr->seq;\n\n\t \n\tspin_lock_irqsave(&minfo->xfer_lock, flags);\n\tclear_bit(xfer_id, minfo->xfer_alloc_table);\n\tspin_unlock_irqrestore(&minfo->xfer_lock, flags);\n\n\t \n\tup(&minfo->sem_xfer_count);\n}\n\n \nstatic inline int ti_sci_do_xfer(struct ti_sci_info *info,\n\t\t\t\t struct ti_sci_xfer *xfer)\n{\n\tint ret;\n\tint timeout;\n\tstruct device *dev = info->dev;\n\tbool done_state = true;\n\n\tret = mbox_send_message(info->chan_tx, &xfer->tx_message);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = 0;\n\n\tif (system_state <= SYSTEM_RUNNING) {\n\t\t \n\t\ttimeout = msecs_to_jiffies(info->desc->max_rx_timeout_ms);\n\t\tif (!wait_for_completion_timeout(&xfer->done, timeout))\n\t\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t \n\t\tret = read_poll_timeout_atomic(try_wait_for_completion, done_state,\n\t\t\t\t\t       done_state, 1,\n\t\t\t\t\t       info->desc->max_rx_timeout_ms * 1000,\n\t\t\t\t\t       false, &xfer->done);\n\t}\n\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(dev, \"Mbox timedout in resp(caller: %pS)\\n\",\n\t\t\t(void *)_RET_IP_);\n\n\t \n\tmbox_client_txdone(info->chan_tx, ret);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_revision(struct ti_sci_info *info)\n{\n\tstruct device *dev = info->dev;\n\tstruct ti_sci_handle *handle = &info->handle;\n\tstruct ti_sci_version_info *ver = &handle->version;\n\tstruct ti_sci_msg_resp_version *rev_info;\n\tstruct ti_sci_xfer *xfer;\n\tint ret;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_VERSION,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(struct ti_sci_msg_hdr),\n\t\t\t\t   sizeof(*rev_info));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trev_info = (struct ti_sci_msg_resp_version *)xfer->xfer_buf;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tver->abi_major = rev_info->abi_major;\n\tver->abi_minor = rev_info->abi_minor;\n\tver->firmware_revision = rev_info->firmware_revision;\n\tstrncpy(ver->firmware_description, rev_info->firmware_description,\n\t\tsizeof(ver->firmware_description));\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\treturn ret;\n}\n\n \nstatic inline bool ti_sci_is_response_ack(void *r)\n{\n\tstruct ti_sci_msg_hdr *hdr = r;\n\n\treturn hdr->flags & TI_SCI_FLAG_RESP_GENERIC_ACK ? true : false;\n}\n\n \nstatic int ti_sci_set_device_state(const struct ti_sci_handle *handle,\n\t\t\t\t   u32 id, u32 flags, u8 state)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_set_device_state *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_DEVICE_STATE,\n\t\t\t\t   flags | TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_device_state *)xfer->xfer_buf;\n\treq->id = id;\n\treq->state = state;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_get_device_state(const struct ti_sci_handle *handle,\n\t\t\t\t   u32 id,  u32 *clcnt,  u32 *resets,\n\t\t\t\t    u8 *p_state,  u8 *c_state)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_get_device_state *req;\n\tstruct ti_sci_msg_resp_get_device_state *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tif (!clcnt && !resets && !p_state && !c_state)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_DEVICE_STATE,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_device_state *)xfer->xfer_buf;\n\treq->id = id;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_device_state *)xfer->xfer_buf;\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (clcnt)\n\t\t*clcnt = resp->context_loss_count;\n\tif (resets)\n\t\t*resets = resp->resets;\n\tif (p_state)\n\t\t*p_state = resp->programmed_state;\n\tif (c_state)\n\t\t*c_state = resp->current_state;\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_device(const struct ti_sci_handle *handle, u32 id)\n{\n\treturn ti_sci_set_device_state(handle, id, 0,\n\t\t\t\t       MSG_DEVICE_SW_STATE_ON);\n}\n\n \nstatic int ti_sci_cmd_get_device_exclusive(const struct ti_sci_handle *handle,\n\t\t\t\t\t   u32 id)\n{\n\treturn ti_sci_set_device_state(handle, id,\n\t\t\t\t       MSG_FLAG_DEVICE_EXCLUSIVE,\n\t\t\t\t       MSG_DEVICE_SW_STATE_ON);\n}\n\n \nstatic int ti_sci_cmd_idle_device(const struct ti_sci_handle *handle, u32 id)\n{\n\treturn ti_sci_set_device_state(handle, id, 0,\n\t\t\t\t       MSG_DEVICE_SW_STATE_RETENTION);\n}\n\n \nstatic int ti_sci_cmd_idle_device_exclusive(const struct ti_sci_handle *handle,\n\t\t\t\t\t    u32 id)\n{\n\treturn ti_sci_set_device_state(handle, id,\n\t\t\t\t       MSG_FLAG_DEVICE_EXCLUSIVE,\n\t\t\t\t       MSG_DEVICE_SW_STATE_RETENTION);\n}\n\n \nstatic int ti_sci_cmd_put_device(const struct ti_sci_handle *handle, u32 id)\n{\n\treturn ti_sci_set_device_state(handle, id,\n\t\t\t\t       0, MSG_DEVICE_SW_STATE_AUTO_OFF);\n}\n\n \nstatic int ti_sci_cmd_dev_is_valid(const struct ti_sci_handle *handle, u32 id)\n{\n\tu8 unused;\n\n\t \n\treturn ti_sci_get_device_state(handle, id, NULL, NULL, NULL, &unused);\n}\n\n \nstatic int ti_sci_cmd_dev_get_clcnt(const struct ti_sci_handle *handle, u32 id,\n\t\t\t\t    u32 *count)\n{\n\treturn ti_sci_get_device_state(handle, id, count, NULL, NULL, NULL);\n}\n\n \nstatic int ti_sci_cmd_dev_is_idle(const struct ti_sci_handle *handle, u32 id,\n\t\t\t\t  bool *r_state)\n{\n\tint ret;\n\tu8 state;\n\n\tif (!r_state)\n\t\treturn -EINVAL;\n\n\tret = ti_sci_get_device_state(handle, id, NULL, NULL, &state, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t*r_state = (state == MSG_DEVICE_SW_STATE_RETENTION);\n\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_dev_is_stop(const struct ti_sci_handle *handle, u32 id,\n\t\t\t\t  bool *r_state,  bool *curr_state)\n{\n\tint ret;\n\tu8 p_state, c_state;\n\n\tif (!r_state && !curr_state)\n\t\treturn -EINVAL;\n\n\tret =\n\t    ti_sci_get_device_state(handle, id, NULL, NULL, &p_state, &c_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (r_state)\n\t\t*r_state = (p_state == MSG_DEVICE_SW_STATE_AUTO_OFF);\n\tif (curr_state)\n\t\t*curr_state = (c_state == MSG_DEVICE_HW_STATE_OFF);\n\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_dev_is_on(const struct ti_sci_handle *handle, u32 id,\n\t\t\t\tbool *r_state,  bool *curr_state)\n{\n\tint ret;\n\tu8 p_state, c_state;\n\n\tif (!r_state && !curr_state)\n\t\treturn -EINVAL;\n\n\tret =\n\t    ti_sci_get_device_state(handle, id, NULL, NULL, &p_state, &c_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (r_state)\n\t\t*r_state = (p_state == MSG_DEVICE_SW_STATE_ON);\n\tif (curr_state)\n\t\t*curr_state = (c_state == MSG_DEVICE_HW_STATE_ON);\n\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_dev_is_trans(const struct ti_sci_handle *handle, u32 id,\n\t\t\t\t   bool *curr_state)\n{\n\tint ret;\n\tu8 state;\n\n\tif (!curr_state)\n\t\treturn -EINVAL;\n\n\tret = ti_sci_get_device_state(handle, id, NULL, NULL, NULL, &state);\n\tif (ret)\n\t\treturn ret;\n\n\t*curr_state = (state == MSG_DEVICE_HW_STATE_TRANS);\n\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_set_device_resets(const struct ti_sci_handle *handle,\n\t\t\t\t\tu32 id, u32 reset_state)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_set_device_resets *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_DEVICE_RESETS,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_device_resets *)xfer->xfer_buf;\n\treq->id = id;\n\treq->resets = reset_state;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_device_resets(const struct ti_sci_handle *handle,\n\t\t\t\t\tu32 id, u32 *reset_state)\n{\n\treturn ti_sci_get_device_state(handle, id, NULL, reset_state, NULL,\n\t\t\t\t       NULL);\n}\n\n \nstatic int ti_sci_set_clock_state(const struct ti_sci_handle *handle,\n\t\t\t\t  u32 dev_id, u32 clk_id,\n\t\t\t\t  u32 flags, u8 state)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_set_clock_state *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_STATE,\n\t\t\t\t   flags | TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_clock_state *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\treq->request_state = state;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_clock_state(const struct ti_sci_handle *handle,\n\t\t\t\t      u32 dev_id, u32 clk_id,\n\t\t\t\t      u8 *programmed_state, u8 *current_state)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_get_clock_state *req;\n\tstruct ti_sci_msg_resp_get_clock_state *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tif (!programmed_state && !current_state)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_STATE,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_clock_state *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_clock_state *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (programmed_state)\n\t\t*programmed_state = resp->programmed_state;\n\tif (current_state)\n\t\t*current_state = resp->current_state;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_clock(const struct ti_sci_handle *handle, u32 dev_id,\n\t\t\t\tu32 clk_id, bool needs_ssc,\n\t\t\t\tbool can_change_freq, bool enable_input_term)\n{\n\tu32 flags = 0;\n\n\tflags |= needs_ssc ? MSG_FLAG_CLOCK_ALLOW_SSC : 0;\n\tflags |= can_change_freq ? MSG_FLAG_CLOCK_ALLOW_FREQ_CHANGE : 0;\n\tflags |= enable_input_term ? MSG_FLAG_CLOCK_INPUT_TERM : 0;\n\n\treturn ti_sci_set_clock_state(handle, dev_id, clk_id, flags,\n\t\t\t\t      MSG_CLOCK_SW_STATE_REQ);\n}\n\n \nstatic int ti_sci_cmd_idle_clock(const struct ti_sci_handle *handle,\n\t\t\t\t u32 dev_id, u32 clk_id)\n{\n\treturn ti_sci_set_clock_state(handle, dev_id, clk_id,\n\t\t\t\t      MSG_FLAG_CLOCK_ALLOW_FREQ_CHANGE,\n\t\t\t\t      MSG_CLOCK_SW_STATE_UNREQ);\n}\n\n \nstatic int ti_sci_cmd_put_clock(const struct ti_sci_handle *handle,\n\t\t\t\tu32 dev_id, u32 clk_id)\n{\n\treturn ti_sci_set_clock_state(handle, dev_id, clk_id,\n\t\t\t\t      MSG_FLAG_CLOCK_ALLOW_FREQ_CHANGE,\n\t\t\t\t      MSG_CLOCK_SW_STATE_AUTO);\n}\n\n \nstatic int ti_sci_cmd_clk_is_auto(const struct ti_sci_handle *handle,\n\t\t\t\t  u32 dev_id, u32 clk_id, bool *req_state)\n{\n\tu8 state = 0;\n\tint ret;\n\n\tif (!req_state)\n\t\treturn -EINVAL;\n\n\tret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id, &state, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t*req_state = (state == MSG_CLOCK_SW_STATE_AUTO);\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_clk_is_on(const struct ti_sci_handle *handle, u32 dev_id,\n\t\t\t\tu32 clk_id, bool *req_state, bool *curr_state)\n{\n\tu8 c_state = 0, r_state = 0;\n\tint ret;\n\n\tif (!req_state && !curr_state)\n\t\treturn -EINVAL;\n\n\tret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id,\n\t\t\t\t\t &r_state, &c_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req_state)\n\t\t*req_state = (r_state == MSG_CLOCK_SW_STATE_REQ);\n\tif (curr_state)\n\t\t*curr_state = (c_state == MSG_CLOCK_HW_STATE_READY);\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_clk_is_off(const struct ti_sci_handle *handle, u32 dev_id,\n\t\t\t\t u32 clk_id, bool *req_state, bool *curr_state)\n{\n\tu8 c_state = 0, r_state = 0;\n\tint ret;\n\n\tif (!req_state && !curr_state)\n\t\treturn -EINVAL;\n\n\tret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id,\n\t\t\t\t\t &r_state, &c_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (req_state)\n\t\t*req_state = (r_state == MSG_CLOCK_SW_STATE_UNREQ);\n\tif (curr_state)\n\t\t*curr_state = (c_state == MSG_CLOCK_HW_STATE_NOT_READY);\n\treturn 0;\n}\n\n \nstatic int ti_sci_cmd_clk_set_parent(const struct ti_sci_handle *handle,\n\t\t\t\t     u32 dev_id, u32 clk_id, u32 parent_id)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_set_clock_parent *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_PARENT,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_clock_parent *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\tif (parent_id < 255) {\n\t\treq->parent_id = parent_id;\n\t} else {\n\t\treq->parent_id = 255;\n\t\treq->parent_id_32 = parent_id;\n\t}\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_clk_get_parent(const struct ti_sci_handle *handle,\n\t\t\t\t     u32 dev_id, u32 clk_id, u32 *parent_id)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_get_clock_parent *req;\n\tstruct ti_sci_msg_resp_get_clock_parent *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle || !parent_id)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_PARENT,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_clock_parent *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_clock_parent *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t} else {\n\t\tif (resp->parent_id < 255)\n\t\t\t*parent_id = resp->parent_id;\n\t\telse\n\t\t\t*parent_id = resp->parent_id_32;\n\t}\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_clk_get_num_parents(const struct ti_sci_handle *handle,\n\t\t\t\t\t  u32 dev_id, u32 clk_id,\n\t\t\t\t\t  u32 *num_parents)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_get_clock_num_parents *req;\n\tstruct ti_sci_msg_resp_get_clock_num_parents *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle || !num_parents)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_NUM_CLOCK_PARENTS,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_clock_num_parents *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_clock_num_parents *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t} else {\n\t\tif (resp->num_parents < 255)\n\t\t\t*num_parents = resp->num_parents;\n\t\telse\n\t\t\t*num_parents = resp->num_parents_32;\n\t}\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_clk_get_match_freq(const struct ti_sci_handle *handle,\n\t\t\t\t\t u32 dev_id, u32 clk_id, u64 min_freq,\n\t\t\t\t\t u64 target_freq, u64 max_freq,\n\t\t\t\t\t u64 *match_freq)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_query_clock_freq *req;\n\tstruct ti_sci_msg_resp_query_clock_freq *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle || !match_freq)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_QUERY_CLOCK_FREQ,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_query_clock_freq *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\treq->min_freq_hz = min_freq;\n\treq->target_freq_hz = target_freq;\n\treq->max_freq_hz = max_freq;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_query_clock_freq *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp))\n\t\tret = -ENODEV;\n\telse\n\t\t*match_freq = resp->freq_hz;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_clk_set_freq(const struct ti_sci_handle *handle,\n\t\t\t\t   u32 dev_id, u32 clk_id, u64 min_freq,\n\t\t\t\t   u64 target_freq, u64 max_freq)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_set_clock_freq *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_FREQ,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_clock_freq *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\treq->min_freq_hz = min_freq;\n\treq->target_freq_hz = target_freq;\n\treq->max_freq_hz = max_freq;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_clk_get_freq(const struct ti_sci_handle *handle,\n\t\t\t\t   u32 dev_id, u32 clk_id, u64 *freq)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_get_clock_freq *req;\n\tstruct ti_sci_msg_resp_get_clock_freq *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle || !freq)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_FREQ,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_clock_freq *)xfer->xfer_buf;\n\treq->dev_id = dev_id;\n\tif (clk_id < 255) {\n\t\treq->clk_id = clk_id;\n\t} else {\n\t\treq->clk_id = 255;\n\t\treq->clk_id_32 = clk_id;\n\t}\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_clock_freq *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp))\n\t\tret = -ENODEV;\n\telse\n\t\t*freq = resp->freq_hz;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\nstatic int ti_sci_cmd_core_reboot(const struct ti_sci_handle *handle)\n{\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_msg_req_reboot *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SYS_RESET,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_reboot *)xfer->xfer_buf;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp))\n\t\tret = -ENODEV;\n\telse\n\t\tret = 0;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_get_resource_range(const struct ti_sci_handle *handle,\n\t\t\t\t     u32 dev_id, u8 subtype, u8 s_host,\n\t\t\t\t     struct ti_sci_resource_desc *desc)\n{\n\tstruct ti_sci_msg_resp_get_resource_range *resp;\n\tstruct ti_sci_msg_req_get_resource_range *req;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle || !desc)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_RESOURCE_RANGE,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treq = (struct ti_sci_msg_req_get_resource_range *)xfer->xfer_buf;\n\treq->secondary_host = s_host;\n\treq->type = dev_id & MSG_RM_RESOURCE_TYPE_MASK;\n\treq->subtype = subtype & MSG_RM_RESOURCE_SUBTYPE_MASK;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_resource_range *)xfer->xfer_buf;\n\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t} else if (!resp->range_num && !resp->range_num_sec) {\n\t\t \n\t\tret = -ENODEV;\n\t} else {\n\t\tdesc->start = resp->range_start;\n\t\tdesc->num = resp->range_num;\n\t\tdesc->start_sec = resp->range_start_sec;\n\t\tdesc->num_sec = resp->range_num_sec;\n\t}\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_get_resource_range(const struct ti_sci_handle *handle,\n\t\t\t\t\t u32 dev_id, u8 subtype,\n\t\t\t\t\t struct ti_sci_resource_desc *desc)\n{\n\treturn ti_sci_get_resource_range(handle, dev_id, subtype,\n\t\t\t\t\t TI_SCI_IRQ_SECONDARY_HOST_INVALID,\n\t\t\t\t\t desc);\n}\n\n \nstatic\nint ti_sci_cmd_get_resource_range_from_shost(const struct ti_sci_handle *handle,\n\t\t\t\t\t     u32 dev_id, u8 subtype, u8 s_host,\n\t\t\t\t\t     struct ti_sci_resource_desc *desc)\n{\n\treturn ti_sci_get_resource_range(handle, dev_id, subtype, s_host, desc);\n}\n\n \nstatic int ti_sci_manage_irq(const struct ti_sci_handle *handle,\n\t\t\t     u32 valid_params, u16 src_id, u16 src_index,\n\t\t\t     u16 dst_id, u16 dst_host_irq, u16 ia_id, u16 vint,\n\t\t\t     u16 global_event, u8 vint_status_bit, u8 s_host,\n\t\t\t     u16 type)\n{\n\tstruct ti_sci_msg_req_manage_irq *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, type, TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_manage_irq *)xfer->xfer_buf;\n\treq->valid_params = valid_params;\n\treq->src_id = src_id;\n\treq->src_index = src_index;\n\treq->dst_id = dst_id;\n\treq->dst_host_irq = dst_host_irq;\n\treq->ia_id = ia_id;\n\treq->vint = vint;\n\treq->global_event = global_event;\n\treq->vint_status_bit = vint_status_bit;\n\treq->secondary_host = s_host;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_set_irq(const struct ti_sci_handle *handle, u32 valid_params,\n\t\t\t  u16 src_id, u16 src_index, u16 dst_id,\n\t\t\t  u16 dst_host_irq, u16 ia_id, u16 vint,\n\t\t\t  u16 global_event, u8 vint_status_bit, u8 s_host)\n{\n\tpr_debug(\"%s: IRQ set with valid_params = 0x%x from src = %d, index = %d, to dst = %d, irq = %d,via ia_id = %d, vint = %d, global event = %d,status_bit = %d\\n\",\n\t\t __func__, valid_params, src_id, src_index,\n\t\t dst_id, dst_host_irq, ia_id, vint, global_event,\n\t\t vint_status_bit);\n\n\treturn ti_sci_manage_irq(handle, valid_params, src_id, src_index,\n\t\t\t\t dst_id, dst_host_irq, ia_id, vint,\n\t\t\t\t global_event, vint_status_bit, s_host,\n\t\t\t\t TI_SCI_MSG_SET_IRQ);\n}\n\n \nstatic int ti_sci_free_irq(const struct ti_sci_handle *handle, u32 valid_params,\n\t\t\t   u16 src_id, u16 src_index, u16 dst_id,\n\t\t\t   u16 dst_host_irq, u16 ia_id, u16 vint,\n\t\t\t   u16 global_event, u8 vint_status_bit, u8 s_host)\n{\n\tpr_debug(\"%s: IRQ release with valid_params = 0x%x from src = %d, index = %d, to dst = %d, irq = %d,via ia_id = %d, vint = %d, global event = %d,status_bit = %d\\n\",\n\t\t __func__, valid_params, src_id, src_index,\n\t\t dst_id, dst_host_irq, ia_id, vint, global_event,\n\t\t vint_status_bit);\n\n\treturn ti_sci_manage_irq(handle, valid_params, src_id, src_index,\n\t\t\t\t dst_id, dst_host_irq, ia_id, vint,\n\t\t\t\t global_event, vint_status_bit, s_host,\n\t\t\t\t TI_SCI_MSG_FREE_IRQ);\n}\n\n \nstatic int ti_sci_cmd_set_irq(const struct ti_sci_handle *handle, u16 src_id,\n\t\t\t      u16 src_index, u16 dst_id, u16 dst_host_irq)\n{\n\tu32 valid_params = MSG_FLAG_DST_ID_VALID | MSG_FLAG_DST_HOST_IRQ_VALID;\n\n\treturn ti_sci_set_irq(handle, valid_params, src_id, src_index, dst_id,\n\t\t\t      dst_host_irq, 0, 0, 0, 0, 0);\n}\n\n \nstatic int ti_sci_cmd_set_event_map(const struct ti_sci_handle *handle,\n\t\t\t\t    u16 src_id, u16 src_index, u16 ia_id,\n\t\t\t\t    u16 vint, u16 global_event,\n\t\t\t\t    u8 vint_status_bit)\n{\n\tu32 valid_params = MSG_FLAG_IA_ID_VALID | MSG_FLAG_VINT_VALID |\n\t\t\t   MSG_FLAG_GLB_EVNT_VALID |\n\t\t\t   MSG_FLAG_VINT_STS_BIT_VALID;\n\n\treturn ti_sci_set_irq(handle, valid_params, src_id, src_index, 0, 0,\n\t\t\t      ia_id, vint, global_event, vint_status_bit, 0);\n}\n\n \nstatic int ti_sci_cmd_free_irq(const struct ti_sci_handle *handle, u16 src_id,\n\t\t\t       u16 src_index, u16 dst_id, u16 dst_host_irq)\n{\n\tu32 valid_params = MSG_FLAG_DST_ID_VALID | MSG_FLAG_DST_HOST_IRQ_VALID;\n\n\treturn ti_sci_free_irq(handle, valid_params, src_id, src_index, dst_id,\n\t\t\t       dst_host_irq, 0, 0, 0, 0, 0);\n}\n\n \nstatic int ti_sci_cmd_free_event_map(const struct ti_sci_handle *handle,\n\t\t\t\t     u16 src_id, u16 src_index, u16 ia_id,\n\t\t\t\t     u16 vint, u16 global_event,\n\t\t\t\t     u8 vint_status_bit)\n{\n\tu32 valid_params = MSG_FLAG_IA_ID_VALID |\n\t\t\t   MSG_FLAG_VINT_VALID | MSG_FLAG_GLB_EVNT_VALID |\n\t\t\t   MSG_FLAG_VINT_STS_BIT_VALID;\n\n\treturn ti_sci_free_irq(handle, valid_params, src_id, src_index, 0, 0,\n\t\t\t       ia_id, vint, global_event, vint_status_bit, 0);\n}\n\n \nstatic int ti_sci_cmd_rm_ring_cfg(const struct ti_sci_handle *handle,\n\t\t\t\t  const struct ti_sci_msg_rm_ring_cfg *params)\n{\n\tstruct ti_sci_msg_rm_ring_cfg_req *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(handle))\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_RM_RING_CFG,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"RM_RA:Message config failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_rm_ring_cfg_req *)xfer->xfer_buf;\n\treq->valid_params = params->valid_params;\n\treq->nav_id = params->nav_id;\n\treq->index = params->index;\n\treq->addr_lo = params->addr_lo;\n\treq->addr_hi = params->addr_hi;\n\treq->count = params->count;\n\treq->mode = params->mode;\n\treq->size = params->size;\n\treq->order_id = params->order_id;\n\treq->virtid = params->virtid;\n\treq->asel = params->asel;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"RM_RA:Mbox config send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\tdev_dbg(dev, \"RM_RA:config ring %u ret:%d\\n\", params->index, ret);\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_rm_psil_pair(const struct ti_sci_handle *handle,\n\t\t\t\t   u32 nav_id, u32 src_thread, u32 dst_thread)\n{\n\tstruct ti_sci_msg_psil_pair *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_RM_PSIL_PAIR,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"RM_PSIL:Message reconfig failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_psil_pair *)xfer->xfer_buf;\n\treq->nav_id = nav_id;\n\treq->src_thread = src_thread;\n\treq->dst_thread = dst_thread;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"RM_PSIL:Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_rm_psil_unpair(const struct ti_sci_handle *handle,\n\t\t\t\t     u32 nav_id, u32 src_thread, u32 dst_thread)\n{\n\tstruct ti_sci_msg_psil_unpair *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_RM_PSIL_UNPAIR,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"RM_PSIL:Message reconfig failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_psil_unpair *)xfer->xfer_buf;\n\treq->nav_id = nav_id;\n\treq->src_thread = src_thread;\n\treq->dst_thread = dst_thread;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"RM_PSIL:Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_rm_udmap_tx_ch_cfg(const struct ti_sci_handle *handle,\n\t\t\tconst struct ti_sci_msg_rm_udmap_tx_ch_cfg *params)\n{\n\tstruct ti_sci_msg_rm_udmap_tx_ch_cfg_req *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(handle))\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TISCI_MSG_RM_UDMAP_TX_CH_CFG,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message TX_CH_CFG alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_rm_udmap_tx_ch_cfg_req *)xfer->xfer_buf;\n\treq->valid_params = params->valid_params;\n\treq->nav_id = params->nav_id;\n\treq->index = params->index;\n\treq->tx_pause_on_err = params->tx_pause_on_err;\n\treq->tx_filt_einfo = params->tx_filt_einfo;\n\treq->tx_filt_pswords = params->tx_filt_pswords;\n\treq->tx_atype = params->tx_atype;\n\treq->tx_chan_type = params->tx_chan_type;\n\treq->tx_supr_tdpkt = params->tx_supr_tdpkt;\n\treq->tx_fetch_size = params->tx_fetch_size;\n\treq->tx_credit_count = params->tx_credit_count;\n\treq->txcq_qnum = params->txcq_qnum;\n\treq->tx_priority = params->tx_priority;\n\treq->tx_qos = params->tx_qos;\n\treq->tx_orderid = params->tx_orderid;\n\treq->fdepth = params->fdepth;\n\treq->tx_sched_priority = params->tx_sched_priority;\n\treq->tx_burst_size = params->tx_burst_size;\n\treq->tx_tdtype = params->tx_tdtype;\n\treq->extended_ch_type = params->extended_ch_type;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send TX_CH_CFG fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\tdev_dbg(dev, \"TX_CH_CFG: chn %u ret:%u\\n\", params->index, ret);\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_rm_udmap_rx_ch_cfg(const struct ti_sci_handle *handle,\n\t\t\tconst struct ti_sci_msg_rm_udmap_rx_ch_cfg *params)\n{\n\tstruct ti_sci_msg_rm_udmap_rx_ch_cfg_req *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(handle))\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TISCI_MSG_RM_UDMAP_RX_CH_CFG,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message RX_CH_CFG alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_rm_udmap_rx_ch_cfg_req *)xfer->xfer_buf;\n\treq->valid_params = params->valid_params;\n\treq->nav_id = params->nav_id;\n\treq->index = params->index;\n\treq->rx_fetch_size = params->rx_fetch_size;\n\treq->rxcq_qnum = params->rxcq_qnum;\n\treq->rx_priority = params->rx_priority;\n\treq->rx_qos = params->rx_qos;\n\treq->rx_orderid = params->rx_orderid;\n\treq->rx_sched_priority = params->rx_sched_priority;\n\treq->flowid_start = params->flowid_start;\n\treq->flowid_cnt = params->flowid_cnt;\n\treq->rx_pause_on_err = params->rx_pause_on_err;\n\treq->rx_atype = params->rx_atype;\n\treq->rx_chan_type = params->rx_chan_type;\n\treq->rx_ignore_short = params->rx_ignore_short;\n\treq->rx_ignore_long = params->rx_ignore_long;\n\treq->rx_burst_size = params->rx_burst_size;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send RX_CH_CFG fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\tdev_dbg(dev, \"RX_CH_CFG: chn %u ret:%d\\n\", params->index, ret);\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_rm_udmap_rx_flow_cfg(const struct ti_sci_handle *handle,\n\t\t\tconst struct ti_sci_msg_rm_udmap_flow_cfg *params)\n{\n\tstruct ti_sci_msg_rm_udmap_flow_cfg_req *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(handle))\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TISCI_MSG_RM_UDMAP_FLOW_CFG,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"RX_FL_CFG: Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_rm_udmap_flow_cfg_req *)xfer->xfer_buf;\n\treq->valid_params = params->valid_params;\n\treq->nav_id = params->nav_id;\n\treq->flow_index = params->flow_index;\n\treq->rx_einfo_present = params->rx_einfo_present;\n\treq->rx_psinfo_present = params->rx_psinfo_present;\n\treq->rx_error_handling = params->rx_error_handling;\n\treq->rx_desc_type = params->rx_desc_type;\n\treq->rx_sop_offset = params->rx_sop_offset;\n\treq->rx_dest_qnum = params->rx_dest_qnum;\n\treq->rx_src_tag_hi = params->rx_src_tag_hi;\n\treq->rx_src_tag_lo = params->rx_src_tag_lo;\n\treq->rx_dest_tag_hi = params->rx_dest_tag_hi;\n\treq->rx_dest_tag_lo = params->rx_dest_tag_lo;\n\treq->rx_src_tag_hi_sel = params->rx_src_tag_hi_sel;\n\treq->rx_src_tag_lo_sel = params->rx_src_tag_lo_sel;\n\treq->rx_dest_tag_hi_sel = params->rx_dest_tag_hi_sel;\n\treq->rx_dest_tag_lo_sel = params->rx_dest_tag_lo_sel;\n\treq->rx_fdq0_sz0_qnum = params->rx_fdq0_sz0_qnum;\n\treq->rx_fdq1_qnum = params->rx_fdq1_qnum;\n\treq->rx_fdq2_qnum = params->rx_fdq2_qnum;\n\treq->rx_fdq3_qnum = params->rx_fdq3_qnum;\n\treq->rx_ps_location = params->rx_ps_location;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"RX_FL_CFG: Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\n\tret = ti_sci_is_response_ack(resp) ? 0 : -EINVAL;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\tdev_dbg(info->dev, \"RX_FL_CFG: %u ret:%d\\n\", params->flow_index, ret);\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_request(const struct ti_sci_handle *handle,\n\t\t\t\t   u8 proc_id)\n{\n\tstruct ti_sci_msg_req_proc_request *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_PROC_REQUEST,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_proc_request *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_release(const struct ti_sci_handle *handle,\n\t\t\t\t   u8 proc_id)\n{\n\tstruct ti_sci_msg_req_proc_release *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_PROC_RELEASE,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_proc_release *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_handover(const struct ti_sci_handle *handle,\n\t\t\t\t    u8 proc_id, u8 host_id)\n{\n\tstruct ti_sci_msg_req_proc_handover *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_PROC_HANDOVER,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_proc_handover *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\treq->host_id = host_id;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_set_config(const struct ti_sci_handle *handle,\n\t\t\t\t      u8 proc_id, u64 bootvector,\n\t\t\t\t      u32 config_flags_set,\n\t\t\t\t      u32 config_flags_clear)\n{\n\tstruct ti_sci_msg_req_set_config *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CONFIG,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_config *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\treq->bootvector_low = bootvector & TI_SCI_ADDR_LOW_MASK;\n\treq->bootvector_high = (bootvector & TI_SCI_ADDR_HIGH_MASK) >>\n\t\t\t\tTI_SCI_ADDR_HIGH_SHIFT;\n\treq->config_flags_set = config_flags_set;\n\treq->config_flags_clear = config_flags_clear;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_set_control(const struct ti_sci_handle *handle,\n\t\t\t\t       u8 proc_id, u32 control_flags_set,\n\t\t\t\t       u32 control_flags_clear)\n{\n\tstruct ti_sci_msg_req_set_ctrl *req;\n\tstruct ti_sci_msg_hdr *resp;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CTRL,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_set_ctrl *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\treq->control_flags_set = control_flags_set;\n\treq->control_flags_clear = control_flags_clear;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\n\n\tret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic int ti_sci_cmd_proc_get_status(const struct ti_sci_handle *handle,\n\t\t\t\t      u8 proc_id, u64 *bv, u32 *cfg_flags,\n\t\t\t\t      u32 *ctrl_flags, u32 *sts_flags)\n{\n\tstruct ti_sci_msg_resp_get_status *resp;\n\tstruct ti_sci_msg_req_get_status *req;\n\tstruct ti_sci_info *info;\n\tstruct ti_sci_xfer *xfer;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tdev = info->dev;\n\n\txfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_STATUS,\n\t\t\t\t   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\n\t\t\t\t   sizeof(*req), sizeof(*resp));\n\tif (IS_ERR(xfer)) {\n\t\tret = PTR_ERR(xfer);\n\t\tdev_err(dev, \"Message alloc failed(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\treq = (struct ti_sci_msg_req_get_status *)xfer->xfer_buf;\n\treq->processor_id = proc_id;\n\n\tret = ti_sci_do_xfer(info, xfer);\n\tif (ret) {\n\t\tdev_err(dev, \"Mbox send fail %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tresp = (struct ti_sci_msg_resp_get_status *)xfer->tx_message.buf;\n\n\tif (!ti_sci_is_response_ack(resp)) {\n\t\tret = -ENODEV;\n\t} else {\n\t\t*bv = (resp->bootvector_low & TI_SCI_ADDR_LOW_MASK) |\n\t\t      (((u64)resp->bootvector_high << TI_SCI_ADDR_HIGH_SHIFT) &\n\t\t       TI_SCI_ADDR_HIGH_MASK);\n\t\t*cfg_flags = resp->config_flags;\n\t\t*ctrl_flags = resp->control_flags;\n\t\t*sts_flags = resp->status_flags;\n\t}\n\nfail:\n\tti_sci_put_one_xfer(&info->minfo, xfer);\n\n\treturn ret;\n}\n\n \nstatic void ti_sci_setup_ops(struct ti_sci_info *info)\n{\n\tstruct ti_sci_ops *ops = &info->handle.ops;\n\tstruct ti_sci_core_ops *core_ops = &ops->core_ops;\n\tstruct ti_sci_dev_ops *dops = &ops->dev_ops;\n\tstruct ti_sci_clk_ops *cops = &ops->clk_ops;\n\tstruct ti_sci_rm_core_ops *rm_core_ops = &ops->rm_core_ops;\n\tstruct ti_sci_rm_irq_ops *iops = &ops->rm_irq_ops;\n\tstruct ti_sci_rm_ringacc_ops *rops = &ops->rm_ring_ops;\n\tstruct ti_sci_rm_psil_ops *psilops = &ops->rm_psil_ops;\n\tstruct ti_sci_rm_udmap_ops *udmap_ops = &ops->rm_udmap_ops;\n\tstruct ti_sci_proc_ops *pops = &ops->proc_ops;\n\n\tcore_ops->reboot_device = ti_sci_cmd_core_reboot;\n\n\tdops->get_device = ti_sci_cmd_get_device;\n\tdops->get_device_exclusive = ti_sci_cmd_get_device_exclusive;\n\tdops->idle_device = ti_sci_cmd_idle_device;\n\tdops->idle_device_exclusive = ti_sci_cmd_idle_device_exclusive;\n\tdops->put_device = ti_sci_cmd_put_device;\n\n\tdops->is_valid = ti_sci_cmd_dev_is_valid;\n\tdops->get_context_loss_count = ti_sci_cmd_dev_get_clcnt;\n\tdops->is_idle = ti_sci_cmd_dev_is_idle;\n\tdops->is_stop = ti_sci_cmd_dev_is_stop;\n\tdops->is_on = ti_sci_cmd_dev_is_on;\n\tdops->is_transitioning = ti_sci_cmd_dev_is_trans;\n\tdops->set_device_resets = ti_sci_cmd_set_device_resets;\n\tdops->get_device_resets = ti_sci_cmd_get_device_resets;\n\n\tcops->get_clock = ti_sci_cmd_get_clock;\n\tcops->idle_clock = ti_sci_cmd_idle_clock;\n\tcops->put_clock = ti_sci_cmd_put_clock;\n\tcops->is_auto = ti_sci_cmd_clk_is_auto;\n\tcops->is_on = ti_sci_cmd_clk_is_on;\n\tcops->is_off = ti_sci_cmd_clk_is_off;\n\n\tcops->set_parent = ti_sci_cmd_clk_set_parent;\n\tcops->get_parent = ti_sci_cmd_clk_get_parent;\n\tcops->get_num_parents = ti_sci_cmd_clk_get_num_parents;\n\n\tcops->get_best_match_freq = ti_sci_cmd_clk_get_match_freq;\n\tcops->set_freq = ti_sci_cmd_clk_set_freq;\n\tcops->get_freq = ti_sci_cmd_clk_get_freq;\n\n\trm_core_ops->get_range = ti_sci_cmd_get_resource_range;\n\trm_core_ops->get_range_from_shost =\n\t\t\t\tti_sci_cmd_get_resource_range_from_shost;\n\n\tiops->set_irq = ti_sci_cmd_set_irq;\n\tiops->set_event_map = ti_sci_cmd_set_event_map;\n\tiops->free_irq = ti_sci_cmd_free_irq;\n\tiops->free_event_map = ti_sci_cmd_free_event_map;\n\n\trops->set_cfg = ti_sci_cmd_rm_ring_cfg;\n\n\tpsilops->pair = ti_sci_cmd_rm_psil_pair;\n\tpsilops->unpair = ti_sci_cmd_rm_psil_unpair;\n\n\tudmap_ops->tx_ch_cfg = ti_sci_cmd_rm_udmap_tx_ch_cfg;\n\tudmap_ops->rx_ch_cfg = ti_sci_cmd_rm_udmap_rx_ch_cfg;\n\tudmap_ops->rx_flow_cfg = ti_sci_cmd_rm_udmap_rx_flow_cfg;\n\n\tpops->request = ti_sci_cmd_proc_request;\n\tpops->release = ti_sci_cmd_proc_release;\n\tpops->handover = ti_sci_cmd_proc_handover;\n\tpops->set_config = ti_sci_cmd_proc_set_config;\n\tpops->set_control = ti_sci_cmd_proc_set_control;\n\tpops->get_status = ti_sci_cmd_proc_get_status;\n}\n\n \nconst struct ti_sci_handle *ti_sci_get_handle(struct device *dev)\n{\n\tstruct device_node *ti_sci_np;\n\tstruct list_head *p;\n\tstruct ti_sci_handle *handle = NULL;\n\tstruct ti_sci_info *info;\n\n\tif (!dev) {\n\t\tpr_err(\"I need a device pointer\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tti_sci_np = of_get_parent(dev->of_node);\n\tif (!ti_sci_np) {\n\t\tdev_err(dev, \"No OF information\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmutex_lock(&ti_sci_list_mutex);\n\tlist_for_each(p, &ti_sci_list) {\n\t\tinfo = list_entry(p, struct ti_sci_info, node);\n\t\tif (ti_sci_np == info->dev->of_node) {\n\t\t\thandle = &info->handle;\n\t\t\tinfo->users++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ti_sci_list_mutex);\n\tof_node_put(ti_sci_np);\n\n\tif (!handle)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn handle;\n}\nEXPORT_SYMBOL_GPL(ti_sci_get_handle);\n\n \nint ti_sci_put_handle(const struct ti_sci_handle *handle)\n{\n\tstruct ti_sci_info *info;\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tinfo = handle_to_ti_sci_info(handle);\n\tmutex_lock(&ti_sci_list_mutex);\n\tif (!WARN_ON(!info->users))\n\t\tinfo->users--;\n\tmutex_unlock(&ti_sci_list_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ti_sci_put_handle);\n\nstatic void devm_ti_sci_release(struct device *dev, void *res)\n{\n\tconst struct ti_sci_handle **ptr = res;\n\tconst struct ti_sci_handle *handle = *ptr;\n\tint ret;\n\n\tret = ti_sci_put_handle(handle);\n\tif (ret)\n\t\tdev_err(dev, \"failed to put handle %d\\n\", ret);\n}\n\n \nconst struct ti_sci_handle *devm_ti_sci_get_handle(struct device *dev)\n{\n\tconst struct ti_sci_handle **ptr;\n\tconst struct ti_sci_handle *handle;\n\n\tptr = devres_alloc(devm_ti_sci_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\thandle = ti_sci_get_handle(dev);\n\n\tif (!IS_ERR(handle)) {\n\t\t*ptr = handle;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn handle;\n}\nEXPORT_SYMBOL_GPL(devm_ti_sci_get_handle);\n\n \nconst struct ti_sci_handle *ti_sci_get_by_phandle(struct device_node *np,\n\t\t\t\t\t\t  const char *property)\n{\n\tstruct ti_sci_handle *handle = NULL;\n\tstruct device_node *ti_sci_np;\n\tstruct ti_sci_info *info;\n\tstruct list_head *p;\n\n\tif (!np) {\n\t\tpr_err(\"I need a device pointer\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tti_sci_np = of_parse_phandle(np, property, 0);\n\tif (!ti_sci_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&ti_sci_list_mutex);\n\tlist_for_each(p, &ti_sci_list) {\n\t\tinfo = list_entry(p, struct ti_sci_info, node);\n\t\tif (ti_sci_np == info->dev->of_node) {\n\t\t\thandle = &info->handle;\n\t\t\tinfo->users++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ti_sci_list_mutex);\n\tof_node_put(ti_sci_np);\n\n\tif (!handle)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn handle;\n}\nEXPORT_SYMBOL_GPL(ti_sci_get_by_phandle);\n\n \nconst struct ti_sci_handle *devm_ti_sci_get_by_phandle(struct device *dev,\n\t\t\t\t\t\t       const char *property)\n{\n\tconst struct ti_sci_handle *handle;\n\tconst struct ti_sci_handle **ptr;\n\n\tptr = devres_alloc(devm_ti_sci_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\thandle = ti_sci_get_by_phandle(dev_of_node(dev), property);\n\n\tif (!IS_ERR(handle)) {\n\t\t*ptr = handle;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn handle;\n}\nEXPORT_SYMBOL_GPL(devm_ti_sci_get_by_phandle);\n\n \nu16 ti_sci_get_free_resource(struct ti_sci_resource *res)\n{\n\tunsigned long flags;\n\tu16 set, free_bit;\n\n\traw_spin_lock_irqsave(&res->lock, flags);\n\tfor (set = 0; set < res->sets; set++) {\n\t\tstruct ti_sci_resource_desc *desc = &res->desc[set];\n\t\tint res_count = desc->num + desc->num_sec;\n\n\t\tfree_bit = find_first_zero_bit(desc->res_map, res_count);\n\t\tif (free_bit != res_count) {\n\t\t\t__set_bit(free_bit, desc->res_map);\n\t\t\traw_spin_unlock_irqrestore(&res->lock, flags);\n\n\t\t\tif (desc->num && free_bit < desc->num)\n\t\t\t\treturn desc->start + free_bit;\n\t\t\telse\n\t\t\t\treturn desc->start_sec + free_bit;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&res->lock, flags);\n\n\treturn TI_SCI_RESOURCE_NULL;\n}\nEXPORT_SYMBOL_GPL(ti_sci_get_free_resource);\n\n \nvoid ti_sci_release_resource(struct ti_sci_resource *res, u16 id)\n{\n\tunsigned long flags;\n\tu16 set;\n\n\traw_spin_lock_irqsave(&res->lock, flags);\n\tfor (set = 0; set < res->sets; set++) {\n\t\tstruct ti_sci_resource_desc *desc = &res->desc[set];\n\n\t\tif (desc->num && desc->start <= id &&\n\t\t    (desc->start + desc->num) > id)\n\t\t\t__clear_bit(id - desc->start, desc->res_map);\n\t\telse if (desc->num_sec && desc->start_sec <= id &&\n\t\t\t (desc->start_sec + desc->num_sec) > id)\n\t\t\t__clear_bit(id - desc->start_sec, desc->res_map);\n\t}\n\traw_spin_unlock_irqrestore(&res->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ti_sci_release_resource);\n\n \nu32 ti_sci_get_num_resources(struct ti_sci_resource *res)\n{\n\tu32 set, count = 0;\n\n\tfor (set = 0; set < res->sets; set++)\n\t\tcount += res->desc[set].num + res->desc[set].num_sec;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(ti_sci_get_num_resources);\n\n \nstatic struct ti_sci_resource *\ndevm_ti_sci_get_resource_sets(const struct ti_sci_handle *handle,\n\t\t\t      struct device *dev, u32 dev_id, u32 *sub_types,\n\t\t\t      u32 sets)\n{\n\tstruct ti_sci_resource *res;\n\tbool valid_set = false;\n\tint i, ret, res_count;\n\n\tres = devm_kzalloc(dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres->sets = sets;\n\tres->desc = devm_kcalloc(dev, res->sets, sizeof(*res->desc),\n\t\t\t\t GFP_KERNEL);\n\tif (!res->desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < res->sets; i++) {\n\t\tret = handle->ops.rm_core_ops.get_range(handle, dev_id,\n\t\t\t\t\t\t\tsub_types[i],\n\t\t\t\t\t\t\t&res->desc[i]);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"dev = %d subtype %d not allocated for this host\\n\",\n\t\t\t\tdev_id, sub_types[i]);\n\t\t\tmemset(&res->desc[i], 0, sizeof(res->desc[i]));\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(dev, \"dev/sub_type: %d/%d, start/num: %d/%d | %d/%d\\n\",\n\t\t\tdev_id, sub_types[i], res->desc[i].start,\n\t\t\tres->desc[i].num, res->desc[i].start_sec,\n\t\t\tres->desc[i].num_sec);\n\n\t\tvalid_set = true;\n\t\tres_count = res->desc[i].num + res->desc[i].num_sec;\n\t\tres->desc[i].res_map = devm_bitmap_zalloc(dev, res_count,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!res->desc[i].res_map)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\traw_spin_lock_init(&res->lock);\n\n\tif (valid_set)\n\t\treturn res;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstruct ti_sci_resource *\ndevm_ti_sci_get_of_resource(const struct ti_sci_handle *handle,\n\t\t\t    struct device *dev, u32 dev_id, char *of_prop)\n{\n\tstruct ti_sci_resource *res;\n\tu32 *sub_types;\n\tint sets;\n\n\tsets = of_property_count_elems_of_size(dev_of_node(dev), of_prop,\n\t\t\t\t\t       sizeof(u32));\n\tif (sets < 0) {\n\t\tdev_err(dev, \"%s resource type ids not available\\n\", of_prop);\n\t\treturn ERR_PTR(sets);\n\t}\n\n\tsub_types = kcalloc(sets, sizeof(*sub_types), GFP_KERNEL);\n\tif (!sub_types)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_property_read_u32_array(dev_of_node(dev), of_prop, sub_types, sets);\n\tres = devm_ti_sci_get_resource_sets(handle, dev, dev_id, sub_types,\n\t\t\t\t\t    sets);\n\n\tkfree(sub_types);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(devm_ti_sci_get_of_resource);\n\n \nstruct ti_sci_resource *\ndevm_ti_sci_get_resource(const struct ti_sci_handle *handle, struct device *dev,\n\t\t\t u32 dev_id, u32 sub_type)\n{\n\treturn devm_ti_sci_get_resource_sets(handle, dev, dev_id, &sub_type, 1);\n}\nEXPORT_SYMBOL_GPL(devm_ti_sci_get_resource);\n\nstatic int tisci_reboot_handler(struct notifier_block *nb, unsigned long mode,\n\t\t\t\tvoid *cmd)\n{\n\tstruct ti_sci_info *info = reboot_to_ti_sci_info(nb);\n\tconst struct ti_sci_handle *handle = &info->handle;\n\n\tti_sci_cmd_core_reboot(handle);\n\n\t \n\treturn NOTIFY_BAD;\n}\n\n \nstatic const struct ti_sci_desc ti_sci_pmmc_k2g_desc = {\n\t.default_host_id = 2,\n\t \n\t.max_rx_timeout_ms = 1000,\n\t \n\t.max_msgs = 20,\n\t.max_msg_size = 64,\n};\n\n \nstatic const struct ti_sci_desc ti_sci_pmmc_am654_desc = {\n\t.default_host_id = 12,\n\t \n\t.max_rx_timeout_ms = 10000,\n\t \n\t.max_msgs = 20,\n\t.max_msg_size = 60,\n};\n\nstatic const struct of_device_id ti_sci_of_match[] = {\n\t{.compatible = \"ti,k2g-sci\", .data = &ti_sci_pmmc_k2g_desc},\n\t{.compatible = \"ti,am654-sci\", .data = &ti_sci_pmmc_am654_desc},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_sci_of_match);\n\nstatic int ti_sci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tconst struct ti_sci_desc *desc;\n\tstruct ti_sci_xfer *xfer;\n\tstruct ti_sci_info *info = NULL;\n\tstruct ti_sci_xfers_info *minfo;\n\tstruct mbox_client *cl;\n\tint ret = -EINVAL;\n\tint i;\n\tint reboot = 0;\n\tu32 h_id;\n\n\tof_id = of_match_device(ti_sci_of_match, dev);\n\tif (!of_id) {\n\t\tdev_err(dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdesc = of_id->data;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->desc = desc;\n\tret = of_property_read_u32(dev->of_node, \"ti,host-id\", &h_id);\n\t \n\tif (ret < 0) {\n\t\tinfo->host_id = info->desc->default_host_id;\n\t} else {\n\t\tif (!h_id) {\n\t\t\tdev_warn(dev, \"Host ID 0 is reserved for firmware\\n\");\n\t\t\tinfo->host_id = info->desc->default_host_id;\n\t\t} else {\n\t\t\tinfo->host_id = h_id;\n\t\t}\n\t}\n\n\treboot = of_property_read_bool(dev->of_node,\n\t\t\t\t       \"ti,system-reboot-controller\");\n\tINIT_LIST_HEAD(&info->node);\n\tminfo = &info->minfo;\n\n\t \n\tif (WARN_ON(desc->max_msgs >=\n\t\t    1 << 8 * sizeof(((struct ti_sci_msg_hdr *)0)->seq)))\n\t\treturn -EINVAL;\n\n\tminfo->xfer_block = devm_kcalloc(dev,\n\t\t\t\t\t desc->max_msgs,\n\t\t\t\t\t sizeof(*minfo->xfer_block),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!minfo->xfer_block)\n\t\treturn -ENOMEM;\n\n\tminfo->xfer_alloc_table = devm_bitmap_zalloc(dev,\n\t\t\t\t\t\t     desc->max_msgs,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (!minfo->xfer_alloc_table)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, xfer = minfo->xfer_block; i < desc->max_msgs; i++, xfer++) {\n\t\txfer->xfer_buf = devm_kcalloc(dev, 1, desc->max_msg_size,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!xfer->xfer_buf)\n\t\t\treturn -ENOMEM;\n\n\t\txfer->tx_message.buf = xfer->xfer_buf;\n\t\tinit_completion(&xfer->done);\n\t}\n\n\tret = ti_sci_debugfs_create(pdev, info);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to create debug file\\n\");\n\n\tplatform_set_drvdata(pdev, info);\n\n\tcl = &info->cl;\n\tcl->dev = dev;\n\tcl->tx_block = false;\n\tcl->rx_callback = ti_sci_rx_callback;\n\tcl->knows_txdone = true;\n\n\tspin_lock_init(&minfo->xfer_lock);\n\tsema_init(&minfo->sem_xfer_count, desc->max_msgs);\n\n\tinfo->chan_rx = mbox_request_channel_byname(cl, \"rx\");\n\tif (IS_ERR(info->chan_rx)) {\n\t\tret = PTR_ERR(info->chan_rx);\n\t\tgoto out;\n\t}\n\n\tinfo->chan_tx = mbox_request_channel_byname(cl, \"tx\");\n\tif (IS_ERR(info->chan_tx)) {\n\t\tret = PTR_ERR(info->chan_tx);\n\t\tgoto out;\n\t}\n\tret = ti_sci_cmd_get_revision(info);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to communicate with TISCI(%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tti_sci_setup_ops(info);\n\n\tif (reboot) {\n\t\tinfo->nb.notifier_call = tisci_reboot_handler;\n\t\tinfo->nb.priority = 128;\n\n\t\tret = register_restart_handler(&info->nb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"reboot registration fail(%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_info(dev, \"ABI: %d.%d (firmware rev 0x%04x '%s')\\n\",\n\t\t info->handle.version.abi_major, info->handle.version.abi_minor,\n\t\t info->handle.version.firmware_revision,\n\t\t info->handle.version.firmware_description);\n\n\tmutex_lock(&ti_sci_list_mutex);\n\tlist_add_tail(&info->node, &ti_sci_list);\n\tmutex_unlock(&ti_sci_list_mutex);\n\n\treturn of_platform_populate(dev->of_node, NULL, NULL, dev);\nout:\n\tif (!IS_ERR(info->chan_tx))\n\t\tmbox_free_channel(info->chan_tx);\n\tif (!IS_ERR(info->chan_rx))\n\t\tmbox_free_channel(info->chan_rx);\n\tdebugfs_remove(info->d);\n\treturn ret;\n}\n\nstatic struct platform_driver ti_sci_driver = {\n\t.probe = ti_sci_probe,\n\t.driver = {\n\t\t   .name = \"ti-sci\",\n\t\t   .of_match_table = of_match_ptr(ti_sci_of_match),\n\t\t   .suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(ti_sci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI System Control Interface(SCI) driver\");\nMODULE_AUTHOR(\"Nishanth Menon\");\nMODULE_ALIAS(\"platform:ti-sci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}