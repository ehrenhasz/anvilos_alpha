{
  "module_name": "dmi_scan.c",
  "hash_id": "3c2a5d978923da5e319f86edcc7cf01efe295f9bc887f2ebe9ca9871eaf3f49b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/dmi_scan.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/memblock.h>\n#include <linux/random.h>\n#include <asm/dmi.h>\n#include <asm/unaligned.h>\n\n#ifndef SMBIOS_ENTRY_POINT_SCAN_START\n#define SMBIOS_ENTRY_POINT_SCAN_START 0xF0000\n#endif\n\nstruct kobject *dmi_kobj;\nEXPORT_SYMBOL_GPL(dmi_kobj);\n\n \nstatic const char dmi_empty_string[] = \"\";\n\nstatic u32 dmi_ver __initdata;\nstatic u32 dmi_len;\nstatic u16 dmi_num;\nstatic u8 smbios_entry_point[32];\nstatic int smbios_entry_point_size;\n\n \nstatic char dmi_ids_string[128] __initdata;\n\nstatic struct dmi_memdev_info {\n\tconst char *device;\n\tconst char *bank;\n\tu64 size;\t\t \n\tu16 handle;\n\tu8 type;\t\t \n} *dmi_memdev;\nstatic int dmi_memdev_nr;\n\nstatic const char * __init dmi_string_nosave(const struct dmi_header *dm, u8 s)\n{\n\tconst u8 *bp = ((u8 *) dm) + dm->length;\n\tconst u8 *nsp;\n\n\tif (s) {\n\t\twhile (--s > 0 && *bp)\n\t\t\tbp += strlen(bp) + 1;\n\n\t\t \n\t\tnsp = bp;\n\t\twhile (*nsp == ' ')\n\t\t\tnsp++;\n\t\tif (*nsp != '\\0')\n\t\t\treturn bp;\n\t}\n\n\treturn dmi_empty_string;\n}\n\nstatic const char * __init dmi_string(const struct dmi_header *dm, u8 s)\n{\n\tconst char *bp = dmi_string_nosave(dm, s);\n\tchar *str;\n\tsize_t len;\n\n\tif (bp == dmi_empty_string)\n\t\treturn dmi_empty_string;\n\n\tlen = strlen(bp) + 1;\n\tstr = dmi_alloc(len);\n\tif (str != NULL)\n\t\tstrcpy(str, bp);\n\n\treturn str;\n}\n\n \nstatic void dmi_decode_table(u8 *buf,\n\t\t\t     void (*decode)(const struct dmi_header *, void *),\n\t\t\t     void *private_data)\n{\n\tu8 *data = buf;\n\tint i = 0;\n\n\t \n\twhile ((!dmi_num || i < dmi_num) &&\n\t       (data - buf + sizeof(struct dmi_header)) <= dmi_len) {\n\t\tconst struct dmi_header *dm = (const struct dmi_header *)data;\n\n\t\t \n\t\tdata += dm->length;\n\t\twhile ((data - buf < dmi_len - 1) && (data[0] || data[1]))\n\t\t\tdata++;\n\t\tif (data - buf < dmi_len - 1)\n\t\t\tdecode(dm, private_data);\n\n\t\tdata += 2;\n\t\ti++;\n\n\t\t \n\t\tif (!dmi_num && dm->type == DMI_ENTRY_END_OF_TABLE)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (dmi_len > data - buf)\n\t\tdmi_len = data - buf;\n}\n\nstatic phys_addr_t dmi_base;\n\nstatic int __init dmi_walk_early(void (*decode)(const struct dmi_header *,\n\t\tvoid *))\n{\n\tu8 *buf;\n\tu32 orig_dmi_len = dmi_len;\n\n\tbuf = dmi_early_remap(dmi_base, orig_dmi_len);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tdmi_decode_table(buf, decode, NULL);\n\n\tadd_device_randomness(buf, dmi_len);\n\n\tdmi_early_unmap(buf, orig_dmi_len);\n\treturn 0;\n}\n\nstatic int __init dmi_checksum(const u8 *buf, u8 len)\n{\n\tu8 sum = 0;\n\tint a;\n\n\tfor (a = 0; a < len; a++)\n\t\tsum += buf[a];\n\n\treturn sum == 0;\n}\n\nstatic const char *dmi_ident[DMI_STRING_MAX];\nstatic LIST_HEAD(dmi_devices);\nint dmi_available;\nEXPORT_SYMBOL_GPL(dmi_available);\n\n \nstatic void __init dmi_save_ident(const struct dmi_header *dm, int slot,\n\t\tint string)\n{\n\tconst char *d = (const char *) dm;\n\tconst char *p;\n\n\tif (dmi_ident[slot] || dm->length <= string)\n\t\treturn;\n\n\tp = dmi_string(dm, d[string]);\n\tif (p == NULL)\n\t\treturn;\n\n\tdmi_ident[slot] = p;\n}\n\nstatic void __init dmi_save_release(const struct dmi_header *dm, int slot,\n\t\tint index)\n{\n\tconst u8 *minor, *major;\n\tchar *s;\n\n\t \n\tif (dmi_ident[slot] || dm->length < index)\n\t\treturn;\n\n\tminor = (u8 *) dm + index;\n\tmajor = (u8 *) dm + index - 1;\n\n\t \n\tif (*major == 0xFF && *minor == 0xFF)\n\t\treturn;\n\n\ts = dmi_alloc(8);\n\tif (!s)\n\t\treturn;\n\n\tsprintf(s, \"%u.%u\", *major, *minor);\n\n\tdmi_ident[slot] = s;\n}\n\nstatic void __init dmi_save_uuid(const struct dmi_header *dm, int slot,\n\t\tint index)\n{\n\tconst u8 *d;\n\tchar *s;\n\tint is_ff = 1, is_00 = 1, i;\n\n\tif (dmi_ident[slot] || dm->length < index + 16)\n\t\treturn;\n\n\td = (u8 *) dm + index;\n\tfor (i = 0; i < 16 && (is_ff || is_00); i++) {\n\t\tif (d[i] != 0x00)\n\t\t\tis_00 = 0;\n\t\tif (d[i] != 0xFF)\n\t\t\tis_ff = 0;\n\t}\n\n\tif (is_ff || is_00)\n\t\treturn;\n\n\ts = dmi_alloc(16*2+4+1);\n\tif (!s)\n\t\treturn;\n\n\t \n\tif (dmi_ver >= 0x020600)\n\t\tsprintf(s, \"%pUl\", d);\n\telse\n\t\tsprintf(s, \"%pUb\", d);\n\n\tdmi_ident[slot] = s;\n}\n\nstatic void __init dmi_save_type(const struct dmi_header *dm, int slot,\n\t\tint index)\n{\n\tconst u8 *d;\n\tchar *s;\n\n\tif (dmi_ident[slot] || dm->length <= index)\n\t\treturn;\n\n\ts = dmi_alloc(4);\n\tif (!s)\n\t\treturn;\n\n\td = (u8 *) dm + index;\n\tsprintf(s, \"%u\", *d & 0x7F);\n\tdmi_ident[slot] = s;\n}\n\nstatic void __init dmi_save_one_device(int type, const char *name)\n{\n\tstruct dmi_device *dev;\n\n\t \n\tif (dmi_find_device(type, name, NULL))\n\t\treturn;\n\n\tdev = dmi_alloc(sizeof(*dev) + strlen(name) + 1);\n\tif (!dev)\n\t\treturn;\n\n\tdev->type = type;\n\tstrcpy((char *)(dev + 1), name);\n\tdev->name = (char *)(dev + 1);\n\tdev->device_data = NULL;\n\tlist_add(&dev->list, &dmi_devices);\n}\n\nstatic void __init dmi_save_devices(const struct dmi_header *dm)\n{\n\tint i, count = (dm->length - sizeof(struct dmi_header)) / 2;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst char *d = (char *)(dm + 1) + (i * 2);\n\n\t\t \n\t\tif ((*d & 0x80) == 0)\n\t\t\tcontinue;\n\n\t\tdmi_save_one_device(*d & 0x7f, dmi_string_nosave(dm, *(d + 1)));\n\t}\n}\n\nstatic void __init dmi_save_oem_strings_devices(const struct dmi_header *dm)\n{\n\tint i, count;\n\tstruct dmi_device *dev;\n\n\tif (dm->length < 0x05)\n\t\treturn;\n\n\tcount = *(u8 *)(dm + 1);\n\tfor (i = 1; i <= count; i++) {\n\t\tconst char *devname = dmi_string(dm, i);\n\n\t\tif (devname == dmi_empty_string)\n\t\t\tcontinue;\n\n\t\tdev = dmi_alloc(sizeof(*dev));\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tdev->type = DMI_DEV_TYPE_OEM_STRING;\n\t\tdev->name = devname;\n\t\tdev->device_data = NULL;\n\n\t\tlist_add(&dev->list, &dmi_devices);\n\t}\n}\n\nstatic void __init dmi_save_ipmi_device(const struct dmi_header *dm)\n{\n\tstruct dmi_device *dev;\n\tvoid *data;\n\n\tdata = dmi_alloc(dm->length);\n\tif (data == NULL)\n\t\treturn;\n\n\tmemcpy(data, dm, dm->length);\n\n\tdev = dmi_alloc(sizeof(*dev));\n\tif (!dev)\n\t\treturn;\n\n\tdev->type = DMI_DEV_TYPE_IPMI;\n\tdev->name = \"IPMI controller\";\n\tdev->device_data = data;\n\n\tlist_add_tail(&dev->list, &dmi_devices);\n}\n\nstatic void __init dmi_save_dev_pciaddr(int instance, int segment, int bus,\n\t\t\t\t\tint devfn, const char *name, int type)\n{\n\tstruct dmi_dev_onboard *dev;\n\n\t \n\tif (type == DMI_DEV_TYPE_DEV_SLOT &&\n\t    segment == 0xFFFF && bus == 0xFF && devfn == 0xFF)\n\t\treturn;\n\n\tdev = dmi_alloc(sizeof(*dev) + strlen(name) + 1);\n\tif (!dev)\n\t\treturn;\n\n\tdev->instance = instance;\n\tdev->segment = segment;\n\tdev->bus = bus;\n\tdev->devfn = devfn;\n\n\tstrcpy((char *)&dev[1], name);\n\tdev->dev.type = type;\n\tdev->dev.name = (char *)&dev[1];\n\tdev->dev.device_data = dev;\n\n\tlist_add(&dev->dev.list, &dmi_devices);\n}\n\nstatic void __init dmi_save_extended_devices(const struct dmi_header *dm)\n{\n\tconst char *name;\n\tconst u8 *d = (u8 *)dm;\n\n\tif (dm->length < 0x0B)\n\t\treturn;\n\n\t \n\tif ((d[0x5] & 0x80) == 0)\n\t\treturn;\n\n\tname = dmi_string_nosave(dm, d[0x4]);\n\tdmi_save_dev_pciaddr(d[0x6], *(u16 *)(d + 0x7), d[0x9], d[0xA], name,\n\t\t\t     DMI_DEV_TYPE_DEV_ONBOARD);\n\tdmi_save_one_device(d[0x5] & 0x7f, name);\n}\n\nstatic void __init dmi_save_system_slot(const struct dmi_header *dm)\n{\n\tconst u8 *d = (u8 *)dm;\n\n\t \n\tif (dm->length < 0x11)\n\t\treturn;\n\tdmi_save_dev_pciaddr(*(u16 *)(d + 0x9), *(u16 *)(d + 0xD), d[0xF],\n\t\t\t     d[0x10], dmi_string_nosave(dm, d[0x4]),\n\t\t\t     DMI_DEV_TYPE_DEV_SLOT);\n}\n\nstatic void __init count_mem_devices(const struct dmi_header *dm, void *v)\n{\n\tif (dm->type != DMI_ENTRY_MEM_DEVICE)\n\t\treturn;\n\tdmi_memdev_nr++;\n}\n\nstatic void __init save_mem_devices(const struct dmi_header *dm, void *v)\n{\n\tconst char *d = (const char *)dm;\n\tstatic int nr;\n\tu64 bytes;\n\tu16 size;\n\n\tif (dm->type != DMI_ENTRY_MEM_DEVICE || dm->length < 0x13)\n\t\treturn;\n\tif (nr >= dmi_memdev_nr) {\n\t\tpr_warn(FW_BUG \"Too many DIMM entries in SMBIOS table\\n\");\n\t\treturn;\n\t}\n\tdmi_memdev[nr].handle = get_unaligned(&dm->handle);\n\tdmi_memdev[nr].device = dmi_string(dm, d[0x10]);\n\tdmi_memdev[nr].bank = dmi_string(dm, d[0x11]);\n\tdmi_memdev[nr].type = d[0x12];\n\n\tsize = get_unaligned((u16 *)&d[0xC]);\n\tif (size == 0)\n\t\tbytes = 0;\n\telse if (size == 0xffff)\n\t\tbytes = ~0ull;\n\telse if (size & 0x8000)\n\t\tbytes = (u64)(size & 0x7fff) << 10;\n\telse if (size != 0x7fff || dm->length < 0x20)\n\t\tbytes = (u64)size << 20;\n\telse\n\t\tbytes = (u64)get_unaligned((u32 *)&d[0x1C]) << 20;\n\n\tdmi_memdev[nr].size = bytes;\n\tnr++;\n}\n\nstatic void __init dmi_memdev_walk(void)\n{\n\tif (dmi_walk_early(count_mem_devices) == 0 && dmi_memdev_nr) {\n\t\tdmi_memdev = dmi_alloc(sizeof(*dmi_memdev) * dmi_memdev_nr);\n\t\tif (dmi_memdev)\n\t\t\tdmi_walk_early(save_mem_devices);\n\t}\n}\n\n \nstatic void __init dmi_decode(const struct dmi_header *dm, void *dummy)\n{\n\tswitch (dm->type) {\n\tcase 0:\t\t \n\t\tdmi_save_ident(dm, DMI_BIOS_VENDOR, 4);\n\t\tdmi_save_ident(dm, DMI_BIOS_VERSION, 5);\n\t\tdmi_save_ident(dm, DMI_BIOS_DATE, 8);\n\t\tdmi_save_release(dm, DMI_BIOS_RELEASE, 21);\n\t\tdmi_save_release(dm, DMI_EC_FIRMWARE_RELEASE, 23);\n\t\tbreak;\n\tcase 1:\t\t \n\t\tdmi_save_ident(dm, DMI_SYS_VENDOR, 4);\n\t\tdmi_save_ident(dm, DMI_PRODUCT_NAME, 5);\n\t\tdmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);\n\t\tdmi_save_ident(dm, DMI_PRODUCT_SERIAL, 7);\n\t\tdmi_save_uuid(dm, DMI_PRODUCT_UUID, 8);\n\t\tdmi_save_ident(dm, DMI_PRODUCT_SKU, 25);\n\t\tdmi_save_ident(dm, DMI_PRODUCT_FAMILY, 26);\n\t\tbreak;\n\tcase 2:\t\t \n\t\tdmi_save_ident(dm, DMI_BOARD_VENDOR, 4);\n\t\tdmi_save_ident(dm, DMI_BOARD_NAME, 5);\n\t\tdmi_save_ident(dm, DMI_BOARD_VERSION, 6);\n\t\tdmi_save_ident(dm, DMI_BOARD_SERIAL, 7);\n\t\tdmi_save_ident(dm, DMI_BOARD_ASSET_TAG, 8);\n\t\tbreak;\n\tcase 3:\t\t \n\t\tdmi_save_ident(dm, DMI_CHASSIS_VENDOR, 4);\n\t\tdmi_save_type(dm, DMI_CHASSIS_TYPE, 5);\n\t\tdmi_save_ident(dm, DMI_CHASSIS_VERSION, 6);\n\t\tdmi_save_ident(dm, DMI_CHASSIS_SERIAL, 7);\n\t\tdmi_save_ident(dm, DMI_CHASSIS_ASSET_TAG, 8);\n\t\tbreak;\n\tcase 9:\t\t \n\t\tdmi_save_system_slot(dm);\n\t\tbreak;\n\tcase 10:\t \n\t\tdmi_save_devices(dm);\n\t\tbreak;\n\tcase 11:\t \n\t\tdmi_save_oem_strings_devices(dm);\n\t\tbreak;\n\tcase 38:\t \n\t\tdmi_save_ipmi_device(dm);\n\t\tbreak;\n\tcase 41:\t \n\t\tdmi_save_extended_devices(dm);\n\t}\n}\n\nstatic int __init print_filtered(char *buf, size_t len, const char *info)\n{\n\tint c = 0;\n\tconst char *p;\n\n\tif (!info)\n\t\treturn c;\n\n\tfor (p = info; *p; p++)\n\t\tif (isprint(*p))\n\t\t\tc += scnprintf(buf + c, len - c, \"%c\", *p);\n\t\telse\n\t\t\tc += scnprintf(buf + c, len - c, \"\\\\x%02x\", *p & 0xff);\n\treturn c;\n}\n\nstatic void __init dmi_format_ids(char *buf, size_t len)\n{\n\tint c = 0;\n\tconst char *board;\t \n\n\tc += print_filtered(buf + c, len - c,\n\t\t\t    dmi_get_system_info(DMI_SYS_VENDOR));\n\tc += scnprintf(buf + c, len - c, \" \");\n\tc += print_filtered(buf + c, len - c,\n\t\t\t    dmi_get_system_info(DMI_PRODUCT_NAME));\n\n\tboard = dmi_get_system_info(DMI_BOARD_NAME);\n\tif (board) {\n\t\tc += scnprintf(buf + c, len - c, \"/\");\n\t\tc += print_filtered(buf + c, len - c, board);\n\t}\n\tc += scnprintf(buf + c, len - c, \", BIOS \");\n\tc += print_filtered(buf + c, len - c,\n\t\t\t    dmi_get_system_info(DMI_BIOS_VERSION));\n\tc += scnprintf(buf + c, len - c, \" \");\n\tc += print_filtered(buf + c, len - c,\n\t\t\t    dmi_get_system_info(DMI_BIOS_DATE));\n}\n\n \nstatic int __init dmi_present(const u8 *buf)\n{\n\tu32 smbios_ver;\n\n\t \n\tif (memcmp(buf, \"_SM_\", 4) == 0 &&\n\t    buf[5] >= 30 && buf[5] <= 32 &&\n\t    dmi_checksum(buf, buf[5])) {\n\t\tsmbios_ver = get_unaligned_be16(buf + 6);\n\t\tsmbios_entry_point_size = buf[5];\n\t\tmemcpy(smbios_entry_point, buf, smbios_entry_point_size);\n\n\t\t \n\t\tswitch (smbios_ver) {\n\t\tcase 0x021F:\n\t\tcase 0x0221:\n\t\t\tpr_debug(\"SMBIOS version fixup (2.%d->2.%d)\\n\",\n\t\t\t\t smbios_ver & 0xFF, 3);\n\t\t\tsmbios_ver = 0x0203;\n\t\t\tbreak;\n\t\tcase 0x0233:\n\t\t\tpr_debug(\"SMBIOS version fixup (2.%d->2.%d)\\n\", 51, 6);\n\t\t\tsmbios_ver = 0x0206;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsmbios_ver = 0;\n\t}\n\n\tbuf += 16;\n\n\tif (memcmp(buf, \"_DMI_\", 5) == 0 && dmi_checksum(buf, 15)) {\n\t\tif (smbios_ver)\n\t\t\tdmi_ver = smbios_ver;\n\t\telse\n\t\t\tdmi_ver = (buf[14] & 0xF0) << 4 | (buf[14] & 0x0F);\n\t\tdmi_ver <<= 8;\n\t\tdmi_num = get_unaligned_le16(buf + 12);\n\t\tdmi_len = get_unaligned_le16(buf + 6);\n\t\tdmi_base = get_unaligned_le32(buf + 8);\n\n\t\tif (dmi_walk_early(dmi_decode) == 0) {\n\t\t\tif (smbios_ver) {\n\t\t\t\tpr_info(\"SMBIOS %d.%d present.\\n\",\n\t\t\t\t\tdmi_ver >> 16, (dmi_ver >> 8) & 0xFF);\n\t\t\t} else {\n\t\t\t\tsmbios_entry_point_size = 15;\n\t\t\t\tmemcpy(smbios_entry_point, buf,\n\t\t\t\t       smbios_entry_point_size);\n\t\t\t\tpr_info(\"Legacy DMI %d.%d present.\\n\",\n\t\t\t\t\tdmi_ver >> 16, (dmi_ver >> 8) & 0xFF);\n\t\t\t}\n\t\t\tdmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));\n\t\t\tpr_info(\"DMI: %s\\n\", dmi_ids_string);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \nstatic int __init dmi_smbios3_present(const u8 *buf)\n{\n\tif (memcmp(buf, \"_SM3_\", 5) == 0 &&\n\t    buf[6] >= 24 && buf[6] <= 32 &&\n\t    dmi_checksum(buf, buf[6])) {\n\t\tdmi_ver = get_unaligned_be24(buf + 7);\n\t\tdmi_num = 0;\t\t\t \n\t\tdmi_len = get_unaligned_le32(buf + 12);\n\t\tdmi_base = get_unaligned_le64(buf + 16);\n\t\tsmbios_entry_point_size = buf[6];\n\t\tmemcpy(smbios_entry_point, buf, smbios_entry_point_size);\n\n\t\tif (dmi_walk_early(dmi_decode) == 0) {\n\t\t\tpr_info(\"SMBIOS %d.%d.%d present.\\n\",\n\t\t\t\tdmi_ver >> 16, (dmi_ver >> 8) & 0xFF,\n\t\t\t\tdmi_ver & 0xFF);\n\t\t\tdmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));\n\t\t\tpr_info(\"DMI: %s\\n\", dmi_ids_string);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void __init dmi_scan_machine(void)\n{\n\tchar __iomem *p, *q;\n\tchar buf[32];\n\n\tif (efi_enabled(EFI_CONFIG_TABLES)) {\n\t\t \n\t\tif (efi.smbios3 != EFI_INVALID_TABLE_ADDR) {\n\t\t\tp = dmi_early_remap(efi.smbios3, 32);\n\t\t\tif (p == NULL)\n\t\t\t\tgoto error;\n\t\t\tmemcpy_fromio(buf, p, 32);\n\t\t\tdmi_early_unmap(p, 32);\n\n\t\t\tif (!dmi_smbios3_present(buf)) {\n\t\t\t\tdmi_available = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (efi.smbios == EFI_INVALID_TABLE_ADDR)\n\t\t\tgoto error;\n\n\t\t \n\t\tp = dmi_early_remap(efi.smbios, 32);\n\t\tif (p == NULL)\n\t\t\tgoto error;\n\t\tmemcpy_fromio(buf, p, 32);\n\t\tdmi_early_unmap(p, 32);\n\n\t\tif (!dmi_present(buf)) {\n\t\t\tdmi_available = 1;\n\t\t\treturn;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK)) {\n\t\tp = dmi_early_remap(SMBIOS_ENTRY_POINT_SCAN_START, 0x10000);\n\t\tif (p == NULL)\n\t\t\tgoto error;\n\n\t\t \n\t\tmemcpy_fromio(buf, p, 16);\n\t\tfor (q = p + 16; q < p + 0x10000; q += 16) {\n\t\t\tmemcpy_fromio(buf + 16, q, 16);\n\t\t\tif (!dmi_smbios3_present(buf)) {\n\t\t\t\tdmi_available = 1;\n\t\t\t\tdmi_early_unmap(p, 0x10000);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(buf, buf + 16, 16);\n\t\t}\n\n\t\t \n\t\tmemset(buf, 0, 16);\n\t\tfor (q = p; q < p + 0x10000; q += 16) {\n\t\t\tmemcpy_fromio(buf + 16, q, 16);\n\t\t\tif (!dmi_present(buf)) {\n\t\t\t\tdmi_available = 1;\n\t\t\t\tdmi_early_unmap(p, 0x10000);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(buf, buf + 16, 16);\n\t\t}\n\t\tdmi_early_unmap(p, 0x10000);\n\t}\n error:\n\tpr_info(\"DMI not present or invalid.\\n\");\n}\n\nstatic ssize_t raw_table_read(struct file *file, struct kobject *kobj,\n\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t      loff_t pos, size_t count)\n{\n\tmemcpy(buf, attr->private + pos, count);\n\treturn count;\n}\n\nstatic BIN_ATTR(smbios_entry_point, S_IRUSR, raw_table_read, NULL, 0);\nstatic BIN_ATTR(DMI, S_IRUSR, raw_table_read, NULL, 0);\n\nstatic int __init dmi_init(void)\n{\n\tstruct kobject *tables_kobj;\n\tu8 *dmi_table;\n\tint ret = -ENOMEM;\n\n\tif (!dmi_available)\n\t\treturn 0;\n\n\t \n\tdmi_kobj = kobject_create_and_add(\"dmi\", firmware_kobj);\n\tif (!dmi_kobj)\n\t\tgoto err;\n\n\ttables_kobj = kobject_create_and_add(\"tables\", dmi_kobj);\n\tif (!tables_kobj)\n\t\tgoto err;\n\n\tdmi_table = dmi_remap(dmi_base, dmi_len);\n\tif (!dmi_table)\n\t\tgoto err_tables;\n\n\tbin_attr_smbios_entry_point.size = smbios_entry_point_size;\n\tbin_attr_smbios_entry_point.private = smbios_entry_point;\n\tret = sysfs_create_bin_file(tables_kobj, &bin_attr_smbios_entry_point);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\tbin_attr_DMI.size = dmi_len;\n\tbin_attr_DMI.private = dmi_table;\n\tret = sysfs_create_bin_file(tables_kobj, &bin_attr_DMI);\n\tif (!ret)\n\t\treturn 0;\n\n\tsysfs_remove_bin_file(tables_kobj,\n\t\t\t      &bin_attr_smbios_entry_point);\n err_unmap:\n\tdmi_unmap(dmi_table);\n err_tables:\n\tkobject_del(tables_kobj);\n\tkobject_put(tables_kobj);\n err:\n\tpr_err(\"dmi: Firmware registration failed.\\n\");\n\n\treturn ret;\n}\nsubsys_initcall(dmi_init);\n\n \nvoid __init dmi_setup(void)\n{\n\tdmi_scan_machine();\n\tif (!dmi_available)\n\t\treturn;\n\n\tdmi_memdev_walk();\n\tdump_stack_set_arch_desc(\"%s\", dmi_ids_string);\n}\n\n \nstatic bool dmi_matches(const struct dmi_system_id *dmi)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dmi->matches); i++) {\n\t\tint s = dmi->matches[i].slot;\n\t\tif (s == DMI_NONE)\n\t\t\tbreak;\n\t\tif (s == DMI_OEM_STRING) {\n\t\t\t \n\t\t\tconst struct dmi_device *valid;\n\n\t\t\tvalid = dmi_find_device(DMI_DEV_TYPE_OEM_STRING,\n\t\t\t\t\t\tdmi->matches[i].substr, NULL);\n\t\t\tif (valid)\n\t\t\t\tcontinue;\n\t\t} else if (dmi_ident[s]) {\n\t\t\tif (dmi->matches[i].exact_match) {\n\t\t\t\tif (!strcmp(dmi_ident[s],\n\t\t\t\t\t    dmi->matches[i].substr))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (strstr(dmi_ident[s],\n\t\t\t\t\t   dmi->matches[i].substr))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool dmi_is_end_of_table(const struct dmi_system_id *dmi)\n{\n\treturn dmi->matches[0].slot == DMI_NONE;\n}\n\n \nint dmi_check_system(const struct dmi_system_id *list)\n{\n\tint count = 0;\n\tconst struct dmi_system_id *d;\n\n\tfor (d = list; !dmi_is_end_of_table(d); d++)\n\t\tif (dmi_matches(d)) {\n\t\t\tcount++;\n\t\t\tif (d->callback && d->callback(d))\n\t\t\t\tbreak;\n\t\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(dmi_check_system);\n\n \nconst struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list)\n{\n\tconst struct dmi_system_id *d;\n\n\tfor (d = list; !dmi_is_end_of_table(d); d++)\n\t\tif (dmi_matches(d))\n\t\t\treturn d;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(dmi_first_match);\n\n \nconst char *dmi_get_system_info(int field)\n{\n\treturn dmi_ident[field];\n}\nEXPORT_SYMBOL(dmi_get_system_info);\n\n \nint dmi_name_in_serial(const char *str)\n{\n\tint f = DMI_PRODUCT_SERIAL;\n\tif (dmi_ident[f] && strstr(dmi_ident[f], str))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint dmi_name_in_vendors(const char *str)\n{\n\tstatic int fields[] = { DMI_SYS_VENDOR, DMI_BOARD_VENDOR, DMI_NONE };\n\tint i;\n\tfor (i = 0; fields[i] != DMI_NONE; i++) {\n\t\tint f = fields[i];\n\t\tif (dmi_ident[f] && strstr(dmi_ident[f], str))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dmi_name_in_vendors);\n\n \nconst struct dmi_device *dmi_find_device(int type, const char *name,\n\t\t\t\t    const struct dmi_device *from)\n{\n\tconst struct list_head *head = from ? &from->list : &dmi_devices;\n\tstruct list_head *d;\n\n\tfor (d = head->next; d != &dmi_devices; d = d->next) {\n\t\tconst struct dmi_device *dev =\n\t\t\tlist_entry(d, struct dmi_device, list);\n\n\t\tif (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&\n\t\t    ((name == NULL) || (strcmp(dev->name, name) == 0)))\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(dmi_find_device);\n\n \nbool dmi_get_date(int field, int *yearp, int *monthp, int *dayp)\n{\n\tint year = 0, month = 0, day = 0;\n\tbool exists;\n\tconst char *s, *y;\n\tchar *e;\n\n\ts = dmi_get_system_info(field);\n\texists = s;\n\tif (!exists)\n\t\tgoto out;\n\n\t \n\ty = strrchr(s, '/');\n\tif (!y)\n\t\tgoto out;\n\n\ty++;\n\tyear = simple_strtoul(y, &e, 10);\n\tif (y != e && year < 100) {\t \n\t\tyear += 1900;\n\t\tif (year < 1996)\t \n\t\t\tyear += 100;\n\t}\n\tif (year > 9999)\t\t \n\t\tyear = 0;\n\n\t \n\tmonth = simple_strtoul(s, &e, 10);\n\tif (s == e || *e != '/' || !month || month > 12) {\n\t\tmonth = 0;\n\t\tgoto out;\n\t}\n\n\ts = e + 1;\n\tday = simple_strtoul(s, &e, 10);\n\tif (s == y || s == e || *e != '/' || day > 31)\n\t\tday = 0;\nout:\n\tif (yearp)\n\t\t*yearp = year;\n\tif (monthp)\n\t\t*monthp = month;\n\tif (dayp)\n\t\t*dayp = day;\n\treturn exists;\n}\nEXPORT_SYMBOL(dmi_get_date);\n\n \nint dmi_get_bios_year(void)\n{\n\tbool exists;\n\tint year;\n\n\texists = dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL);\n\tif (!exists)\n\t\treturn -ENODATA;\n\n\treturn year ? year : -ERANGE;\n}\nEXPORT_SYMBOL(dmi_get_bios_year);\n\n \nint dmi_walk(void (*decode)(const struct dmi_header *, void *),\n\t     void *private_data)\n{\n\tu8 *buf;\n\n\tif (!dmi_available)\n\t\treturn -ENXIO;\n\n\tbuf = dmi_remap(dmi_base, dmi_len);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tdmi_decode_table(buf, decode, private_data);\n\n\tdmi_unmap(buf);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dmi_walk);\n\n \nbool dmi_match(enum dmi_field f, const char *str)\n{\n\tconst char *info = dmi_get_system_info(f);\n\n\tif (info == NULL || str == NULL)\n\t\treturn info == str;\n\n\treturn !strcmp(info, str);\n}\nEXPORT_SYMBOL_GPL(dmi_match);\n\nvoid dmi_memdev_name(u16 handle, const char **bank, const char **device)\n{\n\tint n;\n\n\tif (dmi_memdev == NULL)\n\t\treturn;\n\n\tfor (n = 0; n < dmi_memdev_nr; n++) {\n\t\tif (handle == dmi_memdev[n].handle) {\n\t\t\t*bank = dmi_memdev[n].bank;\n\t\t\t*device = dmi_memdev[n].device;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(dmi_memdev_name);\n\nu64 dmi_memdev_size(u16 handle)\n{\n\tint n;\n\n\tif (dmi_memdev) {\n\t\tfor (n = 0; n < dmi_memdev_nr; n++) {\n\t\t\tif (handle == dmi_memdev[n].handle)\n\t\t\t\treturn dmi_memdev[n].size;\n\t\t}\n\t}\n\treturn ~0ull;\n}\nEXPORT_SYMBOL_GPL(dmi_memdev_size);\n\n \nu8 dmi_memdev_type(u16 handle)\n{\n\tint n;\n\n\tif (dmi_memdev) {\n\t\tfor (n = 0; n < dmi_memdev_nr; n++) {\n\t\t\tif (handle == dmi_memdev[n].handle)\n\t\t\t\treturn dmi_memdev[n].type;\n\t\t}\n\t}\n\treturn 0x0;\t \n}\nEXPORT_SYMBOL_GPL(dmi_memdev_type);\n\n \nu16 dmi_memdev_handle(int slot)\n{\n\tif (dmi_memdev && slot >= 0 && slot < dmi_memdev_nr)\n\t\treturn dmi_memdev[slot].handle;\n\n\treturn 0xffff;\t \n}\nEXPORT_SYMBOL_GPL(dmi_memdev_handle);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}