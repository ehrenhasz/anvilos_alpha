{
  "module_name": "bpmp-tegra210.c",
  "hash_id": "f22809ba75eca2b6fff03d1143c696ba8b6fcc08262580f00e83ab3be32c3b55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/tegra/bpmp-tegra210.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <soc/tegra/bpmp.h>\n\n#include \"bpmp-private.h\"\n\n#define TRIGGER_OFFSET\t\t0x000\n#define RESULT_OFFSET(id)\t(0xc00 + id * 4)\n#define TRIGGER_ID_SHIFT\t16\n#define TRIGGER_CMD_GET\t\t4\n\n#define STA_OFFSET\t\t0\n#define SET_OFFSET\t\t4\n#define CLR_OFFSET\t\t8\n\n#define CH_MASK(ch)\t(0x3 << ((ch) * 2))\n#define SL_SIGL(ch)\t(0x0 << ((ch) * 2))\n#define SL_QUED(ch)\t(0x1 << ((ch) * 2))\n#define MA_FREE(ch)\t(0x2 << ((ch) * 2))\n#define MA_ACKD(ch)\t(0x3 << ((ch) * 2))\n\nstruct tegra210_bpmp {\n\tvoid __iomem *atomics;\n\tvoid __iomem *arb_sema;\n\tstruct irq_data *tx_irq_data;\n};\n\nstatic u32 bpmp_channel_status(struct tegra_bpmp *bpmp, unsigned int index)\n{\n\tstruct tegra210_bpmp *priv = bpmp->priv;\n\n\treturn __raw_readl(priv->arb_sema + STA_OFFSET) & CH_MASK(index);\n}\n\nstatic bool tegra210_bpmp_is_response_ready(struct tegra_bpmp_channel *channel)\n{\n\tunsigned int index = channel->index;\n\n\treturn bpmp_channel_status(channel->bpmp, index) == MA_ACKD(index);\n}\n\nstatic bool tegra210_bpmp_is_request_ready(struct tegra_bpmp_channel *channel)\n{\n\tunsigned int index = channel->index;\n\n\treturn bpmp_channel_status(channel->bpmp, index) == SL_SIGL(index);\n}\n\nstatic bool\ntegra210_bpmp_is_request_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tunsigned int index = channel->index;\n\n\treturn bpmp_channel_status(channel->bpmp, index) == MA_FREE(index);\n}\n\nstatic bool\ntegra210_bpmp_is_response_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tunsigned int index = channel->index;\n\n\treturn bpmp_channel_status(channel->bpmp, index) == SL_QUED(index);\n}\n\nstatic int tegra210_bpmp_post_request(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra210_bpmp *priv = channel->bpmp->priv;\n\n\t__raw_writel(CH_MASK(channel->index), priv->arb_sema + CLR_OFFSET);\n\n\treturn 0;\n}\n\nstatic int tegra210_bpmp_post_response(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra210_bpmp *priv = channel->bpmp->priv;\n\n\t__raw_writel(MA_ACKD(channel->index), priv->arb_sema + SET_OFFSET);\n\n\treturn 0;\n}\n\nstatic int tegra210_bpmp_ack_response(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra210_bpmp *priv = channel->bpmp->priv;\n\n\t__raw_writel(MA_ACKD(channel->index) ^ MA_FREE(channel->index),\n\t\t     priv->arb_sema + CLR_OFFSET);\n\n\treturn 0;\n}\n\nstatic int tegra210_bpmp_ack_request(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra210_bpmp *priv = channel->bpmp->priv;\n\n\t__raw_writel(SL_QUED(channel->index), priv->arb_sema + SET_OFFSET);\n\n\treturn 0;\n}\n\nstatic int tegra210_bpmp_ring_doorbell(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra210_bpmp *priv = bpmp->priv;\n\tstruct irq_data *irq_data = priv->tx_irq_data;\n\n\t \n\tif (irq_data->chip->irq_retrigger)\n\t\treturn irq_data->chip->irq_retrigger(irq_data);\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t rx_irq(int irq, void *data)\n{\n\tstruct tegra_bpmp *bpmp = data;\n\n\ttegra_bpmp_handle_rx(bpmp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra210_bpmp_channel_init(struct tegra_bpmp_channel *channel,\n\t\t\t\t      struct tegra_bpmp *bpmp,\n\t\t\t\t      unsigned int index)\n{\n\tstruct tegra210_bpmp *priv = bpmp->priv;\n\tvoid __iomem *p;\n\tu32 address;\n\n\t \n\twritel(index << TRIGGER_ID_SHIFT | TRIGGER_CMD_GET,\n\t       priv->atomics + TRIGGER_OFFSET);\n\taddress = readl(priv->atomics + RESULT_OFFSET(index));\n\n\tp = devm_ioremap(bpmp->dev, address, 0x80);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tiosys_map_set_vaddr_iomem(&channel->ib, p);\n\tiosys_map_set_vaddr_iomem(&channel->ob, p);\n\n\tchannel->index = index;\n\tinit_completion(&channel->completion);\n\tchannel->bpmp = bpmp;\n\n\treturn 0;\n}\n\nstatic int tegra210_bpmp_init(struct tegra_bpmp *bpmp)\n{\n\tstruct platform_device *pdev = to_platform_device(bpmp->dev);\n\tstruct tegra210_bpmp *priv;\n\tunsigned int i;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbpmp->priv = priv;\n\n\tpriv->atomics = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->atomics))\n\t\treturn PTR_ERR(priv->atomics);\n\n\tpriv->arb_sema = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->arb_sema))\n\t\treturn PTR_ERR(priv->arb_sema);\n\n\terr = tegra210_bpmp_channel_init(bpmp->tx_channel, bpmp,\n\t\t\t\t\t bpmp->soc->channels.cpu_tx.offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra210_bpmp_channel_init(bpmp->rx_channel, bpmp,\n\t\t\t\t\t bpmp->soc->channels.cpu_rx.offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < bpmp->threaded.count; i++) {\n\t\tunsigned int index = bpmp->soc->channels.thread.offset + i;\n\n\t\terr = tegra210_bpmp_channel_init(&bpmp->threaded_channels[i],\n\t\t\t\t\t\t bpmp, index);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = platform_get_irq_byname(pdev, \"tx\");\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->tx_irq_data = irq_get_irq_data(err);\n\tif (!priv->tx_irq_data) {\n\t\tdev_err(&pdev->dev, \"failed to get IRQ data for TX IRQ\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = platform_get_irq_byname(pdev, \"rx\");\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_irq(&pdev->dev, err, rx_irq,\n\t\t\t       IRQF_NO_SUSPEND, dev_name(&pdev->dev), bpmp);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nconst struct tegra_bpmp_ops tegra210_bpmp_ops = {\n\t.init = tegra210_bpmp_init,\n\t.is_response_ready = tegra210_bpmp_is_response_ready,\n\t.is_request_ready = tegra210_bpmp_is_request_ready,\n\t.ack_response = tegra210_bpmp_ack_response,\n\t.ack_request = tegra210_bpmp_ack_request,\n\t.is_response_channel_free = tegra210_bpmp_is_response_channel_free,\n\t.is_request_channel_free = tegra210_bpmp_is_request_channel_free,\n\t.post_response = tegra210_bpmp_post_response,\n\t.post_request = tegra210_bpmp_post_request,\n\t.ring_doorbell = tegra210_bpmp_ring_doorbell,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}