{
  "module_name": "bpmp.c",
  "hash_id": "0edb4c2dde3d71934b56284d3f60a08fb95333995c51640345d2166cca9d25ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/tegra/bpmp.c",
  "human_readable_source": "\n \n\n#include <linux/clk/tegra.h>\n#include <linux/genalloc.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/semaphore.h>\n#include <linux/sched/clock.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n#include <soc/tegra/ivc.h>\n\n#include \"bpmp-private.h\"\n\n#define MSG_ACK\t\tBIT(0)\n#define MSG_RING\tBIT(1)\n#define TAG_SZ\t\t32\n\nstatic inline struct tegra_bpmp *\nmbox_client_to_bpmp(struct mbox_client *client)\n{\n\treturn container_of(client, struct tegra_bpmp, mbox.client);\n}\n\nstatic inline const struct tegra_bpmp_ops *\nchannel_to_ops(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra_bpmp *bpmp = channel->bpmp;\n\n\treturn bpmp->soc->ops;\n}\n\nstruct tegra_bpmp *tegra_bpmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct tegra_bpmp *bpmp;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(dev->of_node, \"nvidia,bpmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tbpmp = ERR_PTR(-ENODEV);\n\t\tgoto put;\n\t}\n\n\tbpmp = platform_get_drvdata(pdev);\n\tif (!bpmp) {\n\t\tbpmp = ERR_PTR(-EPROBE_DEFER);\n\t\tput_device(&pdev->dev);\n\t\tgoto put;\n\t}\n\nput:\n\tof_node_put(np);\n\treturn bpmp;\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_get);\n\nvoid tegra_bpmp_put(struct tegra_bpmp *bpmp)\n{\n\tif (bpmp)\n\t\tput_device(bpmp->dev);\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_put);\n\nstatic int\ntegra_bpmp_channel_get_thread_index(struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra_bpmp *bpmp = channel->bpmp;\n\tunsigned int count;\n\tint index;\n\n\tcount = bpmp->soc->channels.thread.count;\n\n\tindex = channel - channel->bpmp->threaded_channels;\n\tif (index < 0 || index >= count)\n\t\treturn -EINVAL;\n\n\treturn index;\n}\n\nstatic bool tegra_bpmp_message_valid(const struct tegra_bpmp_message *msg)\n{\n\treturn (msg->tx.size <= MSG_DATA_MIN_SZ) &&\n\t       (msg->rx.size <= MSG_DATA_MIN_SZ) &&\n\t       (msg->tx.size == 0 || msg->tx.data) &&\n\t       (msg->rx.size == 0 || msg->rx.data);\n}\n\nstatic bool tegra_bpmp_is_response_ready(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->is_response_ready(channel);\n}\n\nstatic bool tegra_bpmp_is_request_ready(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->is_request_ready(channel);\n}\n\nstatic int tegra_bpmp_wait_response(struct tegra_bpmp_channel *channel)\n{\n\tunsigned long timeout = channel->bpmp->soc->channels.cpu_tx.timeout;\n\tktime_t end;\n\n\tend = ktime_add_us(ktime_get(), timeout);\n\n\tdo {\n\t\tif (tegra_bpmp_is_response_ready(channel))\n\t\t\treturn 0;\n\t} while (ktime_before(ktime_get(), end));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_bpmp_ack_response(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->ack_response(channel);\n}\n\nstatic int tegra_bpmp_ack_request(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->ack_request(channel);\n}\n\nstatic bool\ntegra_bpmp_is_request_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->is_request_channel_free(channel);\n}\n\nstatic bool\ntegra_bpmp_is_response_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->is_response_channel_free(channel);\n}\n\nstatic int\ntegra_bpmp_wait_request_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tunsigned long timeout = channel->bpmp->soc->channels.cpu_tx.timeout;\n\tktime_t start, now;\n\n\tstart = ns_to_ktime(local_clock());\n\n\tdo {\n\t\tif (tegra_bpmp_is_request_channel_free(channel))\n\t\t\treturn 0;\n\n\t\tnow = ns_to_ktime(local_clock());\n\t} while (ktime_us_delta(now, start) < timeout);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int tegra_bpmp_post_request(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->post_request(channel);\n}\n\nstatic int tegra_bpmp_post_response(struct tegra_bpmp_channel *channel)\n{\n\tconst struct tegra_bpmp_ops *ops = channel_to_ops(channel);\n\n\treturn ops->post_response(channel);\n}\n\nstatic int tegra_bpmp_ring_doorbell(struct tegra_bpmp *bpmp)\n{\n\treturn bpmp->soc->ops->ring_doorbell(bpmp);\n}\n\nstatic ssize_t __tegra_bpmp_channel_read(struct tegra_bpmp_channel *channel,\n\t\t\t\t\t void *data, size_t size, int *ret)\n{\n\tint err;\n\n\tif (data && size > 0)\n\t\ttegra_bpmp_mb_read(data, &channel->ib, size);\n\n\terr = tegra_bpmp_ack_response(channel);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ret = tegra_bpmp_mb_read_field(&channel->ib, code);\n\n\treturn 0;\n}\n\nstatic ssize_t tegra_bpmp_channel_read(struct tegra_bpmp_channel *channel,\n\t\t\t\t       void *data, size_t size, int *ret)\n{\n\tstruct tegra_bpmp *bpmp = channel->bpmp;\n\tunsigned long flags;\n\tssize_t err;\n\tint index;\n\n\tindex = tegra_bpmp_channel_get_thread_index(channel);\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto unlock;\n\t}\n\n\tspin_lock_irqsave(&bpmp->lock, flags);\n\terr = __tegra_bpmp_channel_read(channel, data, size, ret);\n\tclear_bit(index, bpmp->threaded.allocated);\n\tspin_unlock_irqrestore(&bpmp->lock, flags);\n\nunlock:\n\tup(&bpmp->threaded.lock);\n\n\treturn err;\n}\n\nstatic ssize_t __tegra_bpmp_channel_write(struct tegra_bpmp_channel *channel,\n\t\t\t\t\t  unsigned int mrq, unsigned long flags,\n\t\t\t\t\t  const void *data, size_t size)\n{\n\ttegra_bpmp_mb_write_field(&channel->ob, code, mrq);\n\ttegra_bpmp_mb_write_field(&channel->ob, flags, flags);\n\n\tif (data && size > 0)\n\t\ttegra_bpmp_mb_write(&channel->ob, data, size);\n\n\treturn tegra_bpmp_post_request(channel);\n}\n\nstatic struct tegra_bpmp_channel *\ntegra_bpmp_write_threaded(struct tegra_bpmp *bpmp, unsigned int mrq,\n\t\t\t  const void *data, size_t size)\n{\n\tunsigned long timeout = bpmp->soc->channels.thread.timeout;\n\tunsigned int count = bpmp->soc->channels.thread.count;\n\tstruct tegra_bpmp_channel *channel;\n\tunsigned long flags;\n\tunsigned int index;\n\tint err;\n\n\terr = down_timeout(&bpmp->threaded.lock, usecs_to_jiffies(timeout));\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tspin_lock_irqsave(&bpmp->lock, flags);\n\n\tindex = find_first_zero_bit(bpmp->threaded.allocated, count);\n\tif (index == count) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tchannel = &bpmp->threaded_channels[index];\n\n\tif (!tegra_bpmp_is_request_channel_free(channel)) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tset_bit(index, bpmp->threaded.allocated);\n\n\terr = __tegra_bpmp_channel_write(channel, mrq, MSG_ACK | MSG_RING,\n\t\t\t\t\t data, size);\n\tif (err < 0)\n\t\tgoto clear_allocated;\n\n\tset_bit(index, bpmp->threaded.busy);\n\n\tspin_unlock_irqrestore(&bpmp->lock, flags);\n\treturn channel;\n\nclear_allocated:\n\tclear_bit(index, bpmp->threaded.allocated);\nunlock:\n\tspin_unlock_irqrestore(&bpmp->lock, flags);\n\tup(&bpmp->threaded.lock);\n\n\treturn ERR_PTR(err);\n}\n\nstatic ssize_t tegra_bpmp_channel_write(struct tegra_bpmp_channel *channel,\n\t\t\t\t\tunsigned int mrq, unsigned long flags,\n\t\t\t\t\tconst void *data, size_t size)\n{\n\tint err;\n\n\terr = tegra_bpmp_wait_request_channel_free(channel);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn __tegra_bpmp_channel_write(channel, mrq, flags, data, size);\n}\n\nstatic int __maybe_unused tegra_bpmp_resume(struct device *dev);\n\nint tegra_bpmp_transfer_atomic(struct tegra_bpmp *bpmp,\n\t\t\t       struct tegra_bpmp_message *msg)\n{\n\tstruct tegra_bpmp_channel *channel;\n\tint err;\n\n\tif (WARN_ON(!irqs_disabled()))\n\t\treturn -EPERM;\n\n\tif (!tegra_bpmp_message_valid(msg))\n\t\treturn -EINVAL;\n\n\tif (bpmp->suspended) {\n\t\t \n\t\tif (msg->flags & TEGRA_BPMP_MESSAGE_RESET)\n\t\t\ttegra_bpmp_resume(bpmp->dev);\n\t\telse\n\t\t\treturn -EAGAIN;\n\t}\n\n\tchannel = bpmp->tx_channel;\n\n\tspin_lock(&bpmp->atomic_tx_lock);\n\n\terr = tegra_bpmp_channel_write(channel, msg->mrq, MSG_ACK,\n\t\t\t\t       msg->tx.data, msg->tx.size);\n\tif (err < 0) {\n\t\tspin_unlock(&bpmp->atomic_tx_lock);\n\t\treturn err;\n\t}\n\n\tspin_unlock(&bpmp->atomic_tx_lock);\n\n\terr = tegra_bpmp_ring_doorbell(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_bpmp_wait_response(channel);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn __tegra_bpmp_channel_read(channel, msg->rx.data, msg->rx.size,\n\t\t\t\t\t &msg->rx.ret);\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_transfer_atomic);\n\nint tegra_bpmp_transfer(struct tegra_bpmp *bpmp,\n\t\t\tstruct tegra_bpmp_message *msg)\n{\n\tstruct tegra_bpmp_channel *channel;\n\tunsigned long timeout;\n\tint err;\n\n\tif (WARN_ON(irqs_disabled()))\n\t\treturn -EPERM;\n\n\tif (!tegra_bpmp_message_valid(msg))\n\t\treturn -EINVAL;\n\n\tif (bpmp->suspended) {\n\t\t \n\t\tif (msg->flags & TEGRA_BPMP_MESSAGE_RESET)\n\t\t\ttegra_bpmp_resume(bpmp->dev);\n\t\telse\n\t\t\treturn -EAGAIN;\n\t}\n\n\tchannel = tegra_bpmp_write_threaded(bpmp, msg->mrq, msg->tx.data,\n\t\t\t\t\t    msg->tx.size);\n\tif (IS_ERR(channel))\n\t\treturn PTR_ERR(channel);\n\n\terr = tegra_bpmp_ring_doorbell(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\ttimeout = usecs_to_jiffies(bpmp->soc->channels.thread.timeout);\n\n\terr = wait_for_completion_timeout(&channel->completion, timeout);\n\tif (err == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn tegra_bpmp_channel_read(channel, msg->rx.data, msg->rx.size,\n\t\t\t\t       &msg->rx.ret);\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_transfer);\n\nstatic struct tegra_bpmp_mrq *tegra_bpmp_find_mrq(struct tegra_bpmp *bpmp,\n\t\t\t\t\t\t  unsigned int mrq)\n{\n\tstruct tegra_bpmp_mrq *entry;\n\n\tlist_for_each_entry(entry, &bpmp->mrqs, list)\n\t\tif (entry->mrq == mrq)\n\t\t\treturn entry;\n\n\treturn NULL;\n}\n\nvoid tegra_bpmp_mrq_return(struct tegra_bpmp_channel *channel, int code,\n\t\t\t   const void *data, size_t size)\n{\n\tunsigned long flags = tegra_bpmp_mb_read_field(&channel->ib, flags);\n\tstruct tegra_bpmp *bpmp = channel->bpmp;\n\tint err;\n\n\tif (WARN_ON(size > MSG_DATA_MIN_SZ))\n\t\treturn;\n\n\terr = tegra_bpmp_ack_request(channel);\n\tif (WARN_ON(err < 0))\n\t\treturn;\n\n\tif ((flags & MSG_ACK) == 0)\n\t\treturn;\n\n\tif (WARN_ON(!tegra_bpmp_is_response_channel_free(channel)))\n\t\treturn;\n\n\ttegra_bpmp_mb_write_field(&channel->ob, code, code);\n\n\tif (data && size > 0)\n\t\ttegra_bpmp_mb_write(&channel->ob, data, size);\n\n\terr = tegra_bpmp_post_response(channel);\n\tif (WARN_ON(err < 0))\n\t\treturn;\n\n\tif (flags & MSG_RING) {\n\t\terr = tegra_bpmp_ring_doorbell(bpmp);\n\t\tif (WARN_ON(err < 0))\n\t\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_mrq_return);\n\nstatic void tegra_bpmp_handle_mrq(struct tegra_bpmp *bpmp,\n\t\t\t\t  unsigned int mrq,\n\t\t\t\t  struct tegra_bpmp_channel *channel)\n{\n\tstruct tegra_bpmp_mrq *entry;\n\tu32 zero = 0;\n\n\tspin_lock(&bpmp->lock);\n\n\tentry = tegra_bpmp_find_mrq(bpmp, mrq);\n\tif (!entry) {\n\t\tspin_unlock(&bpmp->lock);\n\t\ttegra_bpmp_mrq_return(channel, -EINVAL, &zero, sizeof(zero));\n\t\treturn;\n\t}\n\n\tentry->handler(mrq, channel, entry->data);\n\n\tspin_unlock(&bpmp->lock);\n}\n\nint tegra_bpmp_request_mrq(struct tegra_bpmp *bpmp, unsigned int mrq,\n\t\t\t   tegra_bpmp_mrq_handler_t handler, void *data)\n{\n\tstruct tegra_bpmp_mrq *entry;\n\tunsigned long flags;\n\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tentry = devm_kzalloc(bpmp->dev, sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&bpmp->lock, flags);\n\n\tentry->mrq = mrq;\n\tentry->handler = handler;\n\tentry->data = data;\n\tlist_add(&entry->list, &bpmp->mrqs);\n\n\tspin_unlock_irqrestore(&bpmp->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_request_mrq);\n\nvoid tegra_bpmp_free_mrq(struct tegra_bpmp *bpmp, unsigned int mrq, void *data)\n{\n\tstruct tegra_bpmp_mrq *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bpmp->lock, flags);\n\n\tentry = tegra_bpmp_find_mrq(bpmp, mrq);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tlist_del(&entry->list);\n\tdevm_kfree(bpmp->dev, entry);\n\nunlock:\n\tspin_unlock_irqrestore(&bpmp->lock, flags);\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_free_mrq);\n\nbool tegra_bpmp_mrq_is_supported(struct tegra_bpmp *bpmp, unsigned int mrq)\n{\n\tstruct mrq_query_abi_request req = { .mrq = mrq };\n\tstruct mrq_query_abi_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_QUERY_ABI,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tint err;\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err || msg.rx.ret)\n\t\treturn false;\n\n\treturn resp.status == 0;\n}\nEXPORT_SYMBOL_GPL(tegra_bpmp_mrq_is_supported);\n\nstatic void tegra_bpmp_mrq_handle_ping(unsigned int mrq,\n\t\t\t\t       struct tegra_bpmp_channel *channel,\n\t\t\t\t       void *data)\n{\n\tstruct mrq_ping_request request;\n\tstruct mrq_ping_response response;\n\n\ttegra_bpmp_mb_read(&request, &channel->ib, sizeof(request));\n\n\tmemset(&response, 0, sizeof(response));\n\tresponse.reply = request.challenge << 1;\n\n\ttegra_bpmp_mrq_return(channel, 0, &response, sizeof(response));\n}\n\nstatic int tegra_bpmp_ping(struct tegra_bpmp *bpmp)\n{\n\tstruct mrq_ping_response response;\n\tstruct mrq_ping_request request;\n\tstruct tegra_bpmp_message msg;\n\tunsigned long flags;\n\tktime_t start, end;\n\tint err;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.challenge = 1;\n\n\tmemset(&response, 0, sizeof(response));\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_PING;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\tlocal_irq_save(flags);\n\tstart = ktime_get();\n\terr = tegra_bpmp_transfer_atomic(bpmp, &msg);\n\tend = ktime_get();\n\tlocal_irq_restore(flags);\n\n\tif (!err)\n\t\tdev_dbg(bpmp->dev,\n\t\t\t\"ping ok: challenge: %u, response: %u, time: %lld\\n\",\n\t\t\trequest.challenge, response.reply,\n\t\t\tktime_to_us(ktime_sub(end, start)));\n\n\treturn err;\n}\n\n \nstatic int tegra_bpmp_get_firmware_tag_old(struct tegra_bpmp *bpmp, char *tag,\n\t\t\t\t\t   size_t size)\n{\n\tstruct mrq_query_tag_request request;\n\tstruct tegra_bpmp_message msg;\n\tunsigned long flags;\n\tdma_addr_t phys;\n\tvoid *virt;\n\tint err;\n\n\tif (size != TAG_SZ)\n\t\treturn -EINVAL;\n\n\tvirt = dma_alloc_coherent(bpmp->dev, TAG_SZ, &phys,\n\t\t\t\t  GFP_KERNEL | GFP_DMA32);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.addr = phys;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_QUERY_TAG;\n\tmsg.tx.data = &request;\n\tmsg.tx.size = sizeof(request);\n\n\tlocal_irq_save(flags);\n\terr = tegra_bpmp_transfer_atomic(bpmp, &msg);\n\tlocal_irq_restore(flags);\n\n\tif (err == 0)\n\t\tmemcpy(tag, virt, TAG_SZ);\n\n\tdma_free_coherent(bpmp->dev, TAG_SZ, virt, phys);\n\n\treturn err;\n}\n\nstatic int tegra_bpmp_get_firmware_tag(struct tegra_bpmp *bpmp, char *tag,\n\t\t\t\t       size_t size)\n{\n\tif (tegra_bpmp_mrq_is_supported(bpmp, MRQ_QUERY_FW_TAG)) {\n\t\tstruct mrq_query_fw_tag_response resp;\n\t\tstruct tegra_bpmp_message msg = {\n\t\t\t.mrq = MRQ_QUERY_FW_TAG,\n\t\t\t.rx = {\n\t\t\t\t.data = &resp,\n\t\t\t\t.size = sizeof(resp),\n\t\t\t},\n\t\t};\n\t\tint err;\n\n\t\tif (size != sizeof(resp.tag))\n\t\t\treturn -EINVAL;\n\n\t\terr = tegra_bpmp_transfer(bpmp, &msg);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (msg.rx.ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(tag, resp.tag, sizeof(resp.tag));\n\t\treturn 0;\n\t}\n\n\treturn tegra_bpmp_get_firmware_tag_old(bpmp, tag, size);\n}\n\nstatic void tegra_bpmp_channel_signal(struct tegra_bpmp_channel *channel)\n{\n\tunsigned long flags = tegra_bpmp_mb_read_field(&channel->ob, flags);\n\n\tif ((flags & MSG_RING) == 0)\n\t\treturn;\n\n\tcomplete(&channel->completion);\n}\n\nvoid tegra_bpmp_handle_rx(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra_bpmp_channel *channel;\n\tunsigned int i, count;\n\tunsigned long *busy;\n\n\tchannel = bpmp->rx_channel;\n\tcount = bpmp->soc->channels.thread.count;\n\tbusy = bpmp->threaded.busy;\n\n\tif (tegra_bpmp_is_request_ready(channel)) {\n\t\tunsigned int mrq = tegra_bpmp_mb_read_field(&channel->ib, code);\n\n\t\ttegra_bpmp_handle_mrq(bpmp, mrq, channel);\n\t}\n\n\tspin_lock(&bpmp->lock);\n\n\tfor_each_set_bit(i, busy, count) {\n\t\tstruct tegra_bpmp_channel *channel;\n\n\t\tchannel = &bpmp->threaded_channels[i];\n\n\t\tif (tegra_bpmp_is_response_ready(channel)) {\n\t\t\ttegra_bpmp_channel_signal(channel);\n\t\t\tclear_bit(i, busy);\n\t\t}\n\t}\n\n\tspin_unlock(&bpmp->lock);\n}\n\nstatic int tegra_bpmp_probe(struct platform_device *pdev)\n{\n\tstruct tegra_bpmp *bpmp;\n\tchar tag[TAG_SZ];\n\tsize_t size;\n\tint err;\n\n\tbpmp = devm_kzalloc(&pdev->dev, sizeof(*bpmp), GFP_KERNEL);\n\tif (!bpmp)\n\t\treturn -ENOMEM;\n\n\tbpmp->soc = of_device_get_match_data(&pdev->dev);\n\tbpmp->dev = &pdev->dev;\n\n\tINIT_LIST_HEAD(&bpmp->mrqs);\n\tspin_lock_init(&bpmp->lock);\n\n\tbpmp->threaded.count = bpmp->soc->channels.thread.count;\n\tsema_init(&bpmp->threaded.lock, bpmp->threaded.count);\n\n\tsize = BITS_TO_LONGS(bpmp->threaded.count) * sizeof(long);\n\n\tbpmp->threaded.allocated = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (!bpmp->threaded.allocated)\n\t\treturn -ENOMEM;\n\n\tbpmp->threaded.busy = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (!bpmp->threaded.busy)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&bpmp->atomic_tx_lock);\n\tbpmp->tx_channel = devm_kzalloc(&pdev->dev, sizeof(*bpmp->tx_channel),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!bpmp->tx_channel)\n\t\treturn -ENOMEM;\n\n\tbpmp->rx_channel = devm_kzalloc(&pdev->dev, sizeof(*bpmp->rx_channel),\n\t                                GFP_KERNEL);\n\tif (!bpmp->rx_channel)\n\t\treturn -ENOMEM;\n\n\tbpmp->threaded_channels = devm_kcalloc(&pdev->dev, bpmp->threaded.count,\n\t\t\t\t\t       sizeof(*bpmp->threaded_channels),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!bpmp->threaded_channels)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, bpmp);\n\n\terr = bpmp->soc->ops->init(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra_bpmp_request_mrq(bpmp, MRQ_PING,\n\t\t\t\t     tegra_bpmp_mrq_handle_ping, bpmp);\n\tif (err < 0)\n\t\tgoto deinit;\n\n\terr = tegra_bpmp_ping(bpmp);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to ping BPMP: %d\\n\", err);\n\t\tgoto free_mrq;\n\t}\n\n\terr = tegra_bpmp_get_firmware_tag(bpmp, tag, sizeof(tag));\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get firmware tag: %d\\n\", err);\n\t\tgoto free_mrq;\n\t}\n\n\tdev_info(&pdev->dev, \"firmware: %.*s\\n\", (int)sizeof(tag), tag);\n\n\terr = of_platform_default_populate(pdev->dev.of_node, NULL, &pdev->dev);\n\tif (err < 0)\n\t\tgoto free_mrq;\n\n\tif (of_property_present(pdev->dev.of_node, \"#clock-cells\")) {\n\t\terr = tegra_bpmp_init_clocks(bpmp);\n\t\tif (err < 0)\n\t\t\tgoto free_mrq;\n\t}\n\n\tif (of_property_present(pdev->dev.of_node, \"#reset-cells\")) {\n\t\terr = tegra_bpmp_init_resets(bpmp);\n\t\tif (err < 0)\n\t\t\tgoto free_mrq;\n\t}\n\n\tif (of_property_present(pdev->dev.of_node, \"#power-domain-cells\")) {\n\t\terr = tegra_bpmp_init_powergates(bpmp);\n\t\tif (err < 0)\n\t\t\tgoto free_mrq;\n\t}\n\n\terr = tegra_bpmp_init_debugfs(bpmp);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"debugfs initialization failed: %d\\n\", err);\n\n\treturn 0;\n\nfree_mrq:\n\ttegra_bpmp_free_mrq(bpmp, MRQ_PING, bpmp);\ndeinit:\n\tif (bpmp->soc->ops->deinit)\n\t\tbpmp->soc->ops->deinit(bpmp);\n\n\treturn err;\n}\n\nstatic int __maybe_unused tegra_bpmp_suspend(struct device *dev)\n{\n\tstruct tegra_bpmp *bpmp = dev_get_drvdata(dev);\n\n\tbpmp->suspended = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_bpmp_resume(struct device *dev)\n{\n\tstruct tegra_bpmp *bpmp = dev_get_drvdata(dev);\n\n\tbpmp->suspended = false;\n\n\tif (bpmp->soc->ops->resume)\n\t\treturn bpmp->soc->ops->resume(bpmp);\n\telse\n\t\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_bpmp_pm_ops = {\n\t.suspend_noirq = tegra_bpmp_suspend,\n\t.resume_noirq = tegra_bpmp_resume,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_186_SOC) || \\\n    IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \\\n    IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)\nstatic const struct tegra_bpmp_soc tegra186_soc = {\n\t.channels = {\n\t\t.cpu_tx = {\n\t\t\t.offset = 3,\n\t\t\t.timeout = 60 * USEC_PER_SEC,\n\t\t},\n\t\t.thread = {\n\t\t\t.offset = 0,\n\t\t\t.count = 3,\n\t\t\t.timeout = 600 * USEC_PER_SEC,\n\t\t},\n\t\t.cpu_rx = {\n\t\t\t.offset = 13,\n\t\t\t.timeout = 0,\n\t\t},\n\t},\n\t.ops = &tegra186_bpmp_ops,\n\t.num_resets = 193,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\nstatic const struct tegra_bpmp_soc tegra210_soc = {\n\t.channels = {\n\t\t.cpu_tx = {\n\t\t\t.offset = 0,\n\t\t\t.count = 1,\n\t\t\t.timeout = 60 * USEC_PER_SEC,\n\t\t},\n\t\t.thread = {\n\t\t\t.offset = 4,\n\t\t\t.count = 1,\n\t\t\t.timeout = 600 * USEC_PER_SEC,\n\t\t},\n\t\t.cpu_rx = {\n\t\t\t.offset = 8,\n\t\t\t.count = 1,\n\t\t\t.timeout = 0,\n\t\t},\n\t},\n\t.ops = &tegra210_bpmp_ops,\n};\n#endif\n\nstatic const struct of_device_id tegra_bpmp_match[] = {\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_186_SOC) || \\\n    IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \\\n    IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)\n\t{ .compatible = \"nvidia,tegra186-bpmp\", .data = &tegra186_soc },\n#endif\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\n\t{ .compatible = \"nvidia,tegra210-bpmp\", .data = &tegra210_soc },\n#endif\n\t{ }\n};\n\nstatic struct platform_driver tegra_bpmp_driver = {\n\t.driver = {\n\t\t.name = \"tegra-bpmp\",\n\t\t.of_match_table = tegra_bpmp_match,\n\t\t.pm = &tegra_bpmp_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = tegra_bpmp_probe,\n};\nbuiltin_platform_driver(tegra_bpmp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}