{
  "module_name": "ivc.c",
  "hash_id": "bfc04db0eafde8777f6dcb2c6d81b466422b45b924d88efa962392819dc3272e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/tegra/ivc.c",
  "human_readable_source": "\n \n\n#include <soc/tegra/ivc.h>\n\n#define TEGRA_IVC_ALIGN 64\n\n \nenum tegra_ivc_state {\n\t \n\tTEGRA_IVC_STATE_ESTABLISHED = 0,\n\n\t \n\tTEGRA_IVC_STATE_SYNC,\n\n\t \n\tTEGRA_IVC_STATE_ACK\n};\n\n \nstruct tegra_ivc_header {\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tu32 count;\n\t\t\tu32 state;\n\t\t};\n\n\t\tu8 pad[TEGRA_IVC_ALIGN];\n\t} tx;\n\n\tunion {\n\t\t \n\t\tu32 count;\n\t\tu8 pad[TEGRA_IVC_ALIGN];\n\t} rx;\n};\n\n#define tegra_ivc_header_read_field(hdr, field) \\\n\tiosys_map_rd_field(hdr, 0, struct tegra_ivc_header, field)\n\n#define tegra_ivc_header_write_field(hdr, field, value) \\\n\tiosys_map_wr_field(hdr, 0, struct tegra_ivc_header, field, value)\n\nstatic inline void tegra_ivc_invalidate(struct tegra_ivc *ivc, dma_addr_t phys)\n{\n\tif (!ivc->peer)\n\t\treturn;\n\n\tdma_sync_single_for_cpu(ivc->peer, phys, TEGRA_IVC_ALIGN,\n\t\t\t\tDMA_FROM_DEVICE);\n}\n\nstatic inline void tegra_ivc_flush(struct tegra_ivc *ivc, dma_addr_t phys)\n{\n\tif (!ivc->peer)\n\t\treturn;\n\n\tdma_sync_single_for_device(ivc->peer, phys, TEGRA_IVC_ALIGN,\n\t\t\t\t   DMA_TO_DEVICE);\n}\n\nstatic inline bool tegra_ivc_empty(struct tegra_ivc *ivc, struct iosys_map *map)\n{\n\t \n\tu32 tx = tegra_ivc_header_read_field(map, tx.count);\n\tu32 rx = tegra_ivc_header_read_field(map, rx.count);\n\n\t \n\tif (tx - rx > ivc->num_frames)\n\t\treturn true;\n\n\treturn tx == rx;\n}\n\nstatic inline bool tegra_ivc_full(struct tegra_ivc *ivc, struct iosys_map *map)\n{\n\tu32 tx = tegra_ivc_header_read_field(map, tx.count);\n\tu32 rx = tegra_ivc_header_read_field(map, rx.count);\n\n\t \n\treturn tx - rx >= ivc->num_frames;\n}\n\nstatic inline u32 tegra_ivc_available(struct tegra_ivc *ivc, struct iosys_map *map)\n{\n\tu32 tx = tegra_ivc_header_read_field(map, tx.count);\n\tu32 rx = tegra_ivc_header_read_field(map, rx.count);\n\n\t \n\treturn tx - rx;\n}\n\nstatic inline void tegra_ivc_advance_tx(struct tegra_ivc *ivc)\n{\n\tunsigned int count = tegra_ivc_header_read_field(&ivc->tx.map, tx.count);\n\n\ttegra_ivc_header_write_field(&ivc->tx.map, tx.count, count + 1);\n\n\tif (ivc->tx.position == ivc->num_frames - 1)\n\t\tivc->tx.position = 0;\n\telse\n\t\tivc->tx.position++;\n}\n\nstatic inline void tegra_ivc_advance_rx(struct tegra_ivc *ivc)\n{\n\tunsigned int count = tegra_ivc_header_read_field(&ivc->rx.map, rx.count);\n\n\ttegra_ivc_header_write_field(&ivc->rx.map, rx.count, count + 1);\n\n\tif (ivc->rx.position == ivc->num_frames - 1)\n\t\tivc->rx.position = 0;\n\telse\n\t\tivc->rx.position++;\n}\n\nstatic inline int tegra_ivc_check_read(struct tegra_ivc *ivc)\n{\n\tunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\n\tunsigned int state;\n\n\t \n\tstate = tegra_ivc_header_read_field(&ivc->tx.map, tx.state);\n\tif (state != TEGRA_IVC_STATE_ESTABLISHED)\n\t\treturn -ECONNRESET;\n\n\t \n\tif (!tegra_ivc_empty(ivc, &ivc->rx.map))\n\t\treturn 0;\n\n\ttegra_ivc_invalidate(ivc, ivc->rx.phys + offset);\n\n\tif (tegra_ivc_empty(ivc, &ivc->rx.map))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic inline int tegra_ivc_check_write(struct tegra_ivc *ivc)\n{\n\tunsigned int offset = offsetof(struct tegra_ivc_header, rx.count);\n\tunsigned int state;\n\n\tstate = tegra_ivc_header_read_field(&ivc->tx.map, tx.state);\n\tif (state != TEGRA_IVC_STATE_ESTABLISHED)\n\t\treturn -ECONNRESET;\n\n\tif (!tegra_ivc_full(ivc, &ivc->tx.map))\n\t\treturn 0;\n\n\ttegra_ivc_invalidate(ivc, ivc->tx.phys + offset);\n\n\tif (tegra_ivc_full(ivc, &ivc->tx.map))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic int tegra_ivc_frame_virt(struct tegra_ivc *ivc, const struct iosys_map *header,\n\t\t\t\tunsigned int frame, struct iosys_map *map)\n{\n\tsize_t offset = sizeof(struct tegra_ivc_header) + ivc->frame_size * frame;\n\n\tif (WARN_ON(frame >= ivc->num_frames))\n\t\treturn -EINVAL;\n\n\t*map = IOSYS_MAP_INIT_OFFSET(header, offset);\n\n\treturn 0;\n}\n\nstatic inline dma_addr_t tegra_ivc_frame_phys(struct tegra_ivc *ivc,\n\t\t\t\t\t      dma_addr_t phys,\n\t\t\t\t\t      unsigned int frame)\n{\n\tunsigned long offset;\n\n\toffset = sizeof(struct tegra_ivc_header) + ivc->frame_size * frame;\n\n\treturn phys + offset;\n}\n\nstatic inline void tegra_ivc_invalidate_frame(struct tegra_ivc *ivc,\n\t\t\t\t\t      dma_addr_t phys,\n\t\t\t\t\t      unsigned int frame,\n\t\t\t\t\t      unsigned int offset,\n\t\t\t\t\t      size_t size)\n{\n\tif (!ivc->peer || WARN_ON(frame >= ivc->num_frames))\n\t\treturn;\n\n\tphys = tegra_ivc_frame_phys(ivc, phys, frame) + offset;\n\n\tdma_sync_single_for_cpu(ivc->peer, phys, size, DMA_FROM_DEVICE);\n}\n\nstatic inline void tegra_ivc_flush_frame(struct tegra_ivc *ivc,\n\t\t\t\t\t dma_addr_t phys,\n\t\t\t\t\t unsigned int frame,\n\t\t\t\t\t unsigned int offset,\n\t\t\t\t\t size_t size)\n{\n\tif (!ivc->peer || WARN_ON(frame >= ivc->num_frames))\n\t\treturn;\n\n\tphys = tegra_ivc_frame_phys(ivc, phys, frame) + offset;\n\n\tdma_sync_single_for_device(ivc->peer, phys, size, DMA_TO_DEVICE);\n}\n\n \nint tegra_ivc_read_get_next_frame(struct tegra_ivc *ivc, struct iosys_map *map)\n{\n\tint err;\n\n\tif (WARN_ON(ivc == NULL))\n\t\treturn -EINVAL;\n\n\terr = tegra_ivc_check_read(ivc);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsmp_rmb();\n\n\ttegra_ivc_invalidate_frame(ivc, ivc->rx.phys, ivc->rx.position, 0,\n\t\t\t\t   ivc->frame_size);\n\n\treturn tegra_ivc_frame_virt(ivc, &ivc->rx.map, ivc->rx.position, map);\n}\nEXPORT_SYMBOL(tegra_ivc_read_get_next_frame);\n\nint tegra_ivc_read_advance(struct tegra_ivc *ivc)\n{\n\tunsigned int rx = offsetof(struct tegra_ivc_header, rx.count);\n\tunsigned int tx = offsetof(struct tegra_ivc_header, tx.count);\n\tint err;\n\n\t \n\terr = tegra_ivc_check_read(ivc);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra_ivc_advance_rx(ivc);\n\n\ttegra_ivc_flush(ivc, ivc->rx.phys + rx);\n\n\t \n\tsmp_mb();\n\n\t \n\ttegra_ivc_invalidate(ivc, ivc->rx.phys + tx);\n\n\tif (tegra_ivc_available(ivc, &ivc->rx.map) == ivc->num_frames - 1)\n\t\tivc->notify(ivc, ivc->notify_data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_ivc_read_advance);\n\n \nint tegra_ivc_write_get_next_frame(struct tegra_ivc *ivc, struct iosys_map *map)\n{\n\tint err;\n\n\terr = tegra_ivc_check_write(ivc);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn tegra_ivc_frame_virt(ivc, &ivc->tx.map, ivc->tx.position, map);\n}\nEXPORT_SYMBOL(tegra_ivc_write_get_next_frame);\n\n \nint tegra_ivc_write_advance(struct tegra_ivc *ivc)\n{\n\tunsigned int tx = offsetof(struct tegra_ivc_header, tx.count);\n\tunsigned int rx = offsetof(struct tegra_ivc_header, rx.count);\n\tint err;\n\n\terr = tegra_ivc_check_write(ivc);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra_ivc_flush_frame(ivc, ivc->tx.phys, ivc->tx.position, 0,\n\t\t\t      ivc->frame_size);\n\n\t \n\tsmp_wmb();\n\n\ttegra_ivc_advance_tx(ivc);\n\ttegra_ivc_flush(ivc, ivc->tx.phys + tx);\n\n\t \n\tsmp_mb();\n\n\t \n\ttegra_ivc_invalidate(ivc, ivc->tx.phys + rx);\n\n\tif (tegra_ivc_available(ivc, &ivc->tx.map) == 1)\n\t\tivc->notify(ivc, ivc->notify_data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_ivc_write_advance);\n\nvoid tegra_ivc_reset(struct tegra_ivc *ivc)\n{\n\tunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\n\n\ttegra_ivc_header_write_field(&ivc->tx.map, tx.state, TEGRA_IVC_STATE_SYNC);\n\ttegra_ivc_flush(ivc, ivc->tx.phys + offset);\n\tivc->notify(ivc, ivc->notify_data);\n}\nEXPORT_SYMBOL(tegra_ivc_reset);\n\n \n\nint tegra_ivc_notified(struct tegra_ivc *ivc)\n{\n\tunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\n\tenum tegra_ivc_state rx_state, tx_state;\n\n\t \n\ttegra_ivc_invalidate(ivc, ivc->rx.phys + offset);\n\trx_state = tegra_ivc_header_read_field(&ivc->rx.map, tx.state);\n\ttx_state = tegra_ivc_header_read_field(&ivc->tx.map, tx.state);\n\n\tif (rx_state == TEGRA_IVC_STATE_SYNC) {\n\t\toffset = offsetof(struct tegra_ivc_header, tx.count);\n\n\t\t \n\t\tsmp_rmb();\n\n\t\t \n\t\ttegra_ivc_header_write_field(&ivc->tx.map, tx.count, 0);\n\t\ttegra_ivc_header_write_field(&ivc->rx.map, rx.count, 0);\n\n\t\tivc->tx.position = 0;\n\t\tivc->rx.position = 0;\n\n\t\t \n\t\tsmp_wmb();\n\n\t\t \n\t\ttegra_ivc_header_write_field(&ivc->tx.map, tx.state, TEGRA_IVC_STATE_ACK);\n\t\ttegra_ivc_flush(ivc, ivc->tx.phys + offset);\n\n\t\t \n\t\tivc->notify(ivc, ivc->notify_data);\n\n\t} else if (tx_state == TEGRA_IVC_STATE_SYNC &&\n\t\t   rx_state == TEGRA_IVC_STATE_ACK) {\n\t\toffset = offsetof(struct tegra_ivc_header, tx.count);\n\n\t\t \n\t\tsmp_rmb();\n\n\t\t \n\t\ttegra_ivc_header_write_field(&ivc->tx.map, tx.count, 0);\n\t\ttegra_ivc_header_write_field(&ivc->rx.map, rx.count, 0);\n\n\t\tivc->tx.position = 0;\n\t\tivc->rx.position = 0;\n\n\t\t \n\t\tsmp_wmb();\n\n\t\t \n\t\ttegra_ivc_header_write_field(&ivc->tx.map, tx.state, TEGRA_IVC_STATE_ESTABLISHED);\n\t\ttegra_ivc_flush(ivc, ivc->tx.phys + offset);\n\n\t\t \n\t\tivc->notify(ivc, ivc->notify_data);\n\n\t} else if (tx_state == TEGRA_IVC_STATE_ACK) {\n\t\toffset = offsetof(struct tegra_ivc_header, tx.count);\n\n\t\t \n\t\tsmp_rmb();\n\n\t\t \n\t\ttegra_ivc_header_write_field(&ivc->tx.map, tx.state, TEGRA_IVC_STATE_ESTABLISHED);\n\t\ttegra_ivc_flush(ivc, ivc->tx.phys + offset);\n\n\t\t \n\t\tivc->notify(ivc, ivc->notify_data);\n\n\t} else {\n\t\t \n\t}\n\n\tif (tx_state != TEGRA_IVC_STATE_ESTABLISHED)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_ivc_notified);\n\nsize_t tegra_ivc_align(size_t size)\n{\n\treturn ALIGN(size, TEGRA_IVC_ALIGN);\n}\nEXPORT_SYMBOL(tegra_ivc_align);\n\nunsigned tegra_ivc_total_queue_size(unsigned queue_size)\n{\n\tif (!IS_ALIGNED(queue_size, TEGRA_IVC_ALIGN)) {\n\t\tpr_err(\"%s: queue_size (%u) must be %u-byte aligned\\n\",\n\t\t       __func__, queue_size, TEGRA_IVC_ALIGN);\n\t\treturn 0;\n\t}\n\n\treturn queue_size + sizeof(struct tegra_ivc_header);\n}\nEXPORT_SYMBOL(tegra_ivc_total_queue_size);\n\nstatic int tegra_ivc_check_params(unsigned long rx, unsigned long tx,\n\t\t\t\t  unsigned int num_frames, size_t frame_size)\n{\n\tBUILD_BUG_ON(!IS_ALIGNED(offsetof(struct tegra_ivc_header, tx.count),\n\t\t\t\t TEGRA_IVC_ALIGN));\n\tBUILD_BUG_ON(!IS_ALIGNED(offsetof(struct tegra_ivc_header, rx.count),\n\t\t\t\t TEGRA_IVC_ALIGN));\n\tBUILD_BUG_ON(!IS_ALIGNED(sizeof(struct tegra_ivc_header),\n\t\t\t\t TEGRA_IVC_ALIGN));\n\n\tif ((uint64_t)num_frames * (uint64_t)frame_size >= 0x100000000UL) {\n\t\tpr_err(\"num_frames * frame_size overflows\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ALIGNED(frame_size, TEGRA_IVC_ALIGN)) {\n\t\tpr_err(\"frame size not adequately aligned: %zu\\n\", frame_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!IS_ALIGNED(rx, TEGRA_IVC_ALIGN)) {\n\t\tpr_err(\"IVC channel start not aligned: %#lx\\n\", rx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ALIGNED(tx, TEGRA_IVC_ALIGN)) {\n\t\tpr_err(\"IVC channel start not aligned: %#lx\\n\", tx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rx < tx) {\n\t\tif (rx + frame_size * num_frames > tx) {\n\t\t\tpr_err(\"queue regions overlap: %#lx + %zx > %#lx\\n\",\n\t\t\t       rx, frame_size * num_frames, tx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (tx + frame_size * num_frames > rx) {\n\t\t\tpr_err(\"queue regions overlap: %#lx + %zx > %#lx\\n\",\n\t\t\t       tx, frame_size * num_frames, rx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void iosys_map_copy(struct iosys_map *dst, const struct iosys_map *src)\n{\n\t*dst = *src;\n}\n\nstatic inline unsigned long iosys_map_get_address(const struct iosys_map *map)\n{\n\tif (map->is_iomem)\n\t\treturn (unsigned long)map->vaddr_iomem;\n\n\treturn (unsigned long)map->vaddr;\n}\n\nstatic inline void *iosys_map_get_vaddr(const struct iosys_map *map)\n{\n\tif (WARN_ON(map->is_iomem))\n\t\treturn NULL;\n\n\treturn map->vaddr;\n}\n\nint tegra_ivc_init(struct tegra_ivc *ivc, struct device *peer, const struct iosys_map *rx,\n\t\t   dma_addr_t rx_phys, const struct iosys_map *tx, dma_addr_t tx_phys,\n\t\t   unsigned int num_frames, size_t frame_size,\n\t\t   void (*notify)(struct tegra_ivc *ivc, void *data),\n\t\t   void *data)\n{\n\tsize_t queue_size;\n\tint err;\n\n\tif (WARN_ON(!ivc || !notify))\n\t\treturn -EINVAL;\n\n\t \n\tif (frame_size > INT_MAX)\n\t\treturn -E2BIG;\n\n\terr = tegra_ivc_check_params(iosys_map_get_address(rx), iosys_map_get_address(tx),\n\t\t\t\t     num_frames, frame_size);\n\tif (err < 0)\n\t\treturn err;\n\n\tqueue_size = tegra_ivc_total_queue_size(num_frames * frame_size);\n\n\tif (peer) {\n\t\tivc->rx.phys = dma_map_single(peer, iosys_map_get_vaddr(rx), queue_size,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(peer, ivc->rx.phys))\n\t\t\treturn -ENOMEM;\n\n\t\tivc->tx.phys = dma_map_single(peer, iosys_map_get_vaddr(tx), queue_size,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(peer, ivc->tx.phys)) {\n\t\t\tdma_unmap_single(peer, ivc->rx.phys, queue_size,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tivc->rx.phys = rx_phys;\n\t\tivc->tx.phys = tx_phys;\n\t}\n\n\tiosys_map_copy(&ivc->rx.map, rx);\n\tiosys_map_copy(&ivc->tx.map, tx);\n\tivc->peer = peer;\n\tivc->notify = notify;\n\tivc->notify_data = data;\n\tivc->frame_size = frame_size;\n\tivc->num_frames = num_frames;\n\n\t \n\tivc->tx.position = 0;\n\tivc->rx.position = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_ivc_init);\n\nvoid tegra_ivc_cleanup(struct tegra_ivc *ivc)\n{\n\tif (ivc->peer) {\n\t\tsize_t size = tegra_ivc_total_queue_size(ivc->num_frames *\n\t\t\t\t\t\t\t ivc->frame_size);\n\n\t\tdma_unmap_single(ivc->peer, ivc->rx.phys, size,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tdma_unmap_single(ivc->peer, ivc->tx.phys, size,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t}\n}\nEXPORT_SYMBOL(tegra_ivc_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}