{
  "module_name": "bpmp-debugfs.c",
  "hash_id": "9d095bf4969473a047456f53768b3259e37dd31ab3ecec9337772a0932a982b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/tegra/bpmp-debugfs.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\nstatic DEFINE_MUTEX(bpmp_debug_lock);\n\nstruct seqbuf {\n\tchar *buf;\n\tsize_t pos;\n\tsize_t size;\n};\n\nstatic void seqbuf_init(struct seqbuf *seqbuf, void *buf, size_t size)\n{\n\tseqbuf->buf = buf;\n\tseqbuf->size = size;\n\tseqbuf->pos = 0;\n}\n\nstatic size_t seqbuf_avail(struct seqbuf *seqbuf)\n{\n\treturn seqbuf->pos < seqbuf->size ? seqbuf->size - seqbuf->pos : 0;\n}\n\nstatic size_t seqbuf_status(struct seqbuf *seqbuf)\n{\n\treturn seqbuf->pos <= seqbuf->size ? 0 : -EOVERFLOW;\n}\n\nstatic int seqbuf_eof(struct seqbuf *seqbuf)\n{\n\treturn seqbuf->pos >= seqbuf->size;\n}\n\nstatic int seqbuf_read(struct seqbuf *seqbuf, void *buf, size_t nbyte)\n{\n\tnbyte = min(nbyte, seqbuf_avail(seqbuf));\n\tmemcpy(buf, seqbuf->buf + seqbuf->pos, nbyte);\n\tseqbuf->pos += nbyte;\n\treturn seqbuf_status(seqbuf);\n}\n\nstatic int seqbuf_read_u32(struct seqbuf *seqbuf, u32 *v)\n{\n\treturn seqbuf_read(seqbuf, v, 4);\n}\n\nstatic int seqbuf_read_str(struct seqbuf *seqbuf, const char **str)\n{\n\t*str = seqbuf->buf + seqbuf->pos;\n\tseqbuf->pos += strnlen(*str, seqbuf_avail(seqbuf));\n\tseqbuf->pos++;\n\treturn seqbuf_status(seqbuf);\n}\n\nstatic void seqbuf_seek(struct seqbuf *seqbuf, ssize_t offset)\n{\n\tseqbuf->pos += offset;\n}\n\n \nstatic const char *get_filename(struct tegra_bpmp *bpmp,\n\t\t\t\tconst struct file *file, char *buf, int size)\n{\n\tconst char *root_path, *filename = NULL;\n\tchar *root_path_buf;\n\tsize_t root_len;\n\tsize_t root_path_buf_len = 512;\n\n\troot_path_buf = kzalloc(root_path_buf_len, GFP_KERNEL);\n\tif (!root_path_buf)\n\t\tgoto out;\n\n\troot_path = dentry_path(bpmp->debugfs_mirror, root_path_buf,\n\t\t\t\troot_path_buf_len);\n\tif (IS_ERR(root_path))\n\t\tgoto out;\n\n\troot_len = strlen(root_path);\n\n\tfilename = dentry_path(file->f_path.dentry, buf, size);\n\tif (IS_ERR(filename)) {\n\t\tfilename = NULL;\n\t\tgoto out;\n\t}\n\n\tif (strlen(filename) < root_len || strncmp(filename, root_path, root_len)) {\n\t\tfilename = NULL;\n\t\tgoto out;\n\t}\n\n\tfilename += root_len;\n\nout:\n\tkfree(root_path_buf);\n\treturn filename;\n}\n\nstatic int mrq_debug_open(struct tegra_bpmp *bpmp, const char *name,\n\t\t\t  u32 *fd, u32 *len, bool write)\n{\n\tstruct mrq_debug_request req = {\n\t\t.cmd = write ? CMD_DEBUG_OPEN_WO : CMD_DEBUG_OPEN_RO,\n\t};\n\tstruct mrq_debug_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUG,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tssize_t sz_name;\n\tint err = 0;\n\n\tsz_name = strscpy(req.fop.name, name, sizeof(req.fop.name));\n\tif (sz_name < 0) {\n\t\tpr_err(\"File name too large: %s\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\t*len = resp.fop.datalen;\n\t*fd = resp.fop.fd;\n\n\treturn 0;\n}\n\nstatic int mrq_debug_close(struct tegra_bpmp *bpmp, u32 fd)\n{\n\tstruct mrq_debug_request req = {\n\t\t.cmd = CMD_DEBUG_CLOSE,\n\t\t.frd = {\n\t\t\t.fd = fd,\n\t\t},\n\t};\n\tstruct mrq_debug_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUG,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tint err = 0;\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mrq_debug_read(struct tegra_bpmp *bpmp, const char *name,\n\t\t\t  char *data, size_t sz_data, u32 *nbytes)\n{\n\tstruct mrq_debug_request req = {\n\t\t.cmd = CMD_DEBUG_READ,\n\t};\n\tstruct mrq_debug_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUG,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tu32 fd = 0, len = 0;\n\tint remaining, err, close_err;\n\n\tmutex_lock(&bpmp_debug_lock);\n\terr = mrq_debug_open(bpmp, name, &fd, &len, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (len > sz_data) {\n\t\terr = -EFBIG;\n\t\tgoto close;\n\t}\n\n\treq.frd.fd = fd;\n\tremaining = len;\n\n\twhile (remaining > 0) {\n\t\terr = tegra_bpmp_transfer(bpmp, &msg);\n\t\tif (err < 0) {\n\t\t\tgoto close;\n\t\t} else if (msg.rx.ret < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto close;\n\t\t}\n\n\t\tif (resp.frd.readlen > remaining) {\n\t\t\tpr_err(\"%s: read data length invalid\\n\", __func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto close;\n\t\t}\n\n\t\tmemcpy(data, resp.frd.data, resp.frd.readlen);\n\t\tdata += resp.frd.readlen;\n\t\tremaining -= resp.frd.readlen;\n\t}\n\n\t*nbytes = len;\n\nclose:\n\tclose_err = mrq_debug_close(bpmp, fd);\n\tif (!err)\n\t\terr = close_err;\nout:\n\tmutex_unlock(&bpmp_debug_lock);\n\treturn err;\n}\n\nstatic int mrq_debug_write(struct tegra_bpmp *bpmp, const char *name,\n\t\t\t   uint8_t *data, size_t sz_data)\n{\n\tstruct mrq_debug_request req = {\n\t\t.cmd = CMD_DEBUG_WRITE\n\t};\n\tstruct mrq_debug_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUG,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tu32 fd = 0, len = 0;\n\tsize_t remaining;\n\tint err;\n\n\tmutex_lock(&bpmp_debug_lock);\n\terr = mrq_debug_open(bpmp, name, &fd, &len, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif (sz_data > len) {\n\t\terr = -EINVAL;\n\t\tgoto close;\n\t}\n\n\treq.fwr.fd = fd;\n\tremaining = sz_data;\n\n\twhile (remaining > 0) {\n\t\tlen = min(remaining, sizeof(req.fwr.data));\n\t\tmemcpy(req.fwr.data, data, len);\n\t\treq.fwr.datalen = len;\n\n\t\terr = tegra_bpmp_transfer(bpmp, &msg);\n\t\tif (err < 0) {\n\t\t\tgoto close;\n\t\t} else if (msg.rx.ret < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto close;\n\t\t}\n\n\t\tdata += req.fwr.datalen;\n\t\tremaining -= req.fwr.datalen;\n\t}\n\nclose:\n\terr = mrq_debug_close(bpmp, fd);\nout:\n\tmutex_unlock(&bpmp_debug_lock);\n\treturn err;\n}\n\nstatic int bpmp_debug_show(struct seq_file *m, void *p)\n{\n\tstruct file *file = m->private;\n\tstruct inode *inode = file_inode(file);\n\tstruct tegra_bpmp *bpmp = inode->i_private;\n\tchar fnamebuf[256];\n\tconst char *filename;\n\tstruct mrq_debug_request req = {\n\t\t.cmd = CMD_DEBUG_READ,\n\t};\n\tstruct mrq_debug_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUG,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tu32 fd = 0, len = 0;\n\tint remaining, err, close_err;\n\n\tfilename = get_filename(bpmp, file, fnamebuf, sizeof(fnamebuf));\n\tif (!filename)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&bpmp_debug_lock);\n\terr = mrq_debug_open(bpmp, filename, &fd, &len, 0);\n\tif (err)\n\t\tgoto out;\n\n\treq.frd.fd = fd;\n\tremaining = len;\n\n\twhile (remaining > 0) {\n\t\terr = tegra_bpmp_transfer(bpmp, &msg);\n\t\tif (err < 0) {\n\t\t\tgoto close;\n\t\t} else if (msg.rx.ret < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto close;\n\t\t}\n\n\t\tif (resp.frd.readlen > remaining) {\n\t\t\tpr_err(\"%s: read data length invalid\\n\", __func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto close;\n\t\t}\n\n\t\tseq_write(m, resp.frd.data, resp.frd.readlen);\n\t\tremaining -= resp.frd.readlen;\n\t}\n\nclose:\n\tclose_err = mrq_debug_close(bpmp, fd);\n\tif (!err)\n\t\terr = close_err;\nout:\n\tmutex_unlock(&bpmp_debug_lock);\n\treturn err;\n}\n\nstatic ssize_t bpmp_debug_store(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct tegra_bpmp *bpmp = inode->i_private;\n\tchar *databuf = NULL;\n\tchar fnamebuf[256];\n\tconst char *filename;\n\tssize_t err;\n\n\tfilename = get_filename(bpmp, file, fnamebuf, sizeof(fnamebuf));\n\tif (!filename)\n\t\treturn -ENOENT;\n\n\tdatabuf = memdup_user(buf, count);\n\tif (IS_ERR(databuf))\n\t\treturn PTR_ERR(databuf);\n\n\terr = mrq_debug_write(bpmp, filename, databuf, count);\n\tkfree(databuf);\n\n\treturn err ?: count;\n}\n\nstatic int bpmp_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_size(file, bpmp_debug_show, file, SZ_256K);\n}\n\nstatic const struct file_operations bpmp_debug_fops = {\n\t.open\t\t= bpmp_debug_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= bpmp_debug_store,\n\t.release\t= single_release,\n};\n\nstatic int bpmp_populate_debugfs_inband(struct tegra_bpmp *bpmp,\n\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\tchar *ppath)\n{\n\tconst size_t pathlen = SZ_256;\n\tconst size_t bufsize = SZ_16K;\n\tstruct dentry *dentry;\n\tu32 dsize, attrs = 0;\n\tstruct seqbuf seqbuf;\n\tchar *buf, *pathbuf;\n\tconst char *name;\n\tint err = 0;\n\n\tif (!bpmp || !parent || !ppath)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpathbuf = kzalloc(pathlen, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = mrq_debug_read(bpmp, ppath, buf, bufsize, &dsize);\n\tif (err)\n\t\tgoto out;\n\n\tseqbuf_init(&seqbuf, buf, dsize);\n\n\twhile (!seqbuf_eof(&seqbuf)) {\n\t\terr = seqbuf_read_u32(&seqbuf, &attrs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = seqbuf_read_str(&seqbuf, &name);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tif (attrs & DEBUGFS_S_ISDIR) {\n\t\t\tsize_t len;\n\n\t\t\tdentry = debugfs_create_dir(name, parent);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlen = snprintf(pathbuf, pathlen, \"%s%s/\", ppath, name);\n\t\t\tif (len >= pathlen) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = bpmp_populate_debugfs_inband(bpmp, dentry,\n\t\t\t\t\t\t\t   pathbuf);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tumode_t mode;\n\n\t\t\tmode = attrs & DEBUGFS_S_IRUSR ? 0400 : 0;\n\t\t\tmode |= attrs & DEBUGFS_S_IWUSR ? 0200 : 0;\n\t\t\tdentry = debugfs_create_file(name, mode, parent, bpmp,\n\t\t\t\t\t\t     &bpmp_debug_fops);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(pathbuf);\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int mrq_debugfs_read(struct tegra_bpmp *bpmp,\n\t\t\t    dma_addr_t name, size_t sz_name,\n\t\t\t    dma_addr_t data, size_t sz_data,\n\t\t\t    size_t *nbytes)\n{\n\tstruct mrq_debugfs_request req = {\n\t\t.cmd = CMD_DEBUGFS_READ,\n\t\t.fop = {\n\t\t\t.fnameaddr = (u32)name,\n\t\t\t.fnamelen = (u32)sz_name,\n\t\t\t.dataaddr = (u32)data,\n\t\t\t.datalen = (u32)sz_data,\n\t\t},\n\t};\n\tstruct mrq_debugfs_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUGFS,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tint err;\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\t*nbytes = (size_t)resp.fop.nbytes;\n\n\treturn 0;\n}\n\nstatic int mrq_debugfs_write(struct tegra_bpmp *bpmp,\n\t\t\t     dma_addr_t name, size_t sz_name,\n\t\t\t     dma_addr_t data, size_t sz_data)\n{\n\tconst struct mrq_debugfs_request req = {\n\t\t.cmd = CMD_DEBUGFS_WRITE,\n\t\t.fop = {\n\t\t\t.fnameaddr = (u32)name,\n\t\t\t.fnamelen = (u32)sz_name,\n\t\t\t.dataaddr = (u32)data,\n\t\t\t.datalen = (u32)sz_data,\n\t\t},\n\t};\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUGFS,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t};\n\n\treturn tegra_bpmp_transfer(bpmp, &msg);\n}\n\nstatic int mrq_debugfs_dumpdir(struct tegra_bpmp *bpmp, dma_addr_t addr,\n\t\t\t       size_t size, size_t *nbytes)\n{\n\tconst struct mrq_debugfs_request req = {\n\t\t.cmd = CMD_DEBUGFS_DUMPDIR,\n\t\t.dumpdir = {\n\t\t\t.dataaddr = (u32)addr,\n\t\t\t.datalen = (u32)size,\n\t\t},\n\t};\n\tstruct mrq_debugfs_response resp;\n\tstruct tegra_bpmp_message msg = {\n\t\t.mrq = MRQ_DEBUGFS,\n\t\t.tx = {\n\t\t\t.data = &req,\n\t\t\t.size = sizeof(req),\n\t\t},\n\t\t.rx = {\n\t\t\t.data = &resp,\n\t\t\t.size = sizeof(resp),\n\t\t},\n\t};\n\tint err;\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err < 0)\n\t\treturn err;\n\telse if (msg.rx.ret < 0)\n\t\treturn -EINVAL;\n\n\t*nbytes = (size_t)resp.dumpdir.nbytes;\n\n\treturn 0;\n}\n\nstatic int debugfs_show(struct seq_file *m, void *p)\n{\n\tstruct file *file = m->private;\n\tstruct inode *inode = file_inode(file);\n\tstruct tegra_bpmp *bpmp = inode->i_private;\n\tconst size_t datasize = m->size;\n\tconst size_t namesize = SZ_256;\n\tvoid *datavirt, *namevirt;\n\tdma_addr_t dataphys, namephys;\n\tchar buf[256];\n\tconst char *filename;\n\tsize_t len, nbytes;\n\tint err;\n\n\tfilename = get_filename(bpmp, file, buf, sizeof(buf));\n\tif (!filename)\n\t\treturn -ENOENT;\n\n\tnamevirt = dma_alloc_coherent(bpmp->dev, namesize, &namephys,\n\t\t\t\t      GFP_KERNEL | GFP_DMA32);\n\tif (!namevirt)\n\t\treturn -ENOMEM;\n\n\tdatavirt = dma_alloc_coherent(bpmp->dev, datasize, &dataphys,\n\t\t\t\t      GFP_KERNEL | GFP_DMA32);\n\tif (!datavirt) {\n\t\terr = -ENOMEM;\n\t\tgoto free_namebuf;\n\t}\n\n\tlen = strlen(filename);\n\tstrncpy(namevirt, filename, namesize);\n\n\terr = mrq_debugfs_read(bpmp, namephys, len, dataphys, datasize,\n\t\t\t       &nbytes);\n\n\tif (!err)\n\t\tseq_write(m, datavirt, nbytes);\n\n\tdma_free_coherent(bpmp->dev, datasize, datavirt, dataphys);\nfree_namebuf:\n\tdma_free_coherent(bpmp->dev, namesize, namevirt, namephys);\n\n\treturn err;\n}\n\nstatic int debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_size(file, debugfs_show, file, SZ_128K);\n}\n\nstatic ssize_t debugfs_store(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct tegra_bpmp *bpmp = inode->i_private;\n\tconst size_t datasize = count;\n\tconst size_t namesize = SZ_256;\n\tvoid *datavirt, *namevirt;\n\tdma_addr_t dataphys, namephys;\n\tchar fnamebuf[256];\n\tconst char *filename;\n\tsize_t len;\n\tint err;\n\n\tfilename = get_filename(bpmp, file, fnamebuf, sizeof(fnamebuf));\n\tif (!filename)\n\t\treturn -ENOENT;\n\n\tnamevirt = dma_alloc_coherent(bpmp->dev, namesize, &namephys,\n\t\t\t\t      GFP_KERNEL | GFP_DMA32);\n\tif (!namevirt)\n\t\treturn -ENOMEM;\n\n\tdatavirt = dma_alloc_coherent(bpmp->dev, datasize, &dataphys,\n\t\t\t\t      GFP_KERNEL | GFP_DMA32);\n\tif (!datavirt) {\n\t\terr = -ENOMEM;\n\t\tgoto free_namebuf;\n\t}\n\n\tlen = strlen(filename);\n\tstrncpy(namevirt, filename, namesize);\n\n\tif (copy_from_user(datavirt, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto free_databuf;\n\t}\n\n\terr = mrq_debugfs_write(bpmp, namephys, len, dataphys,\n\t\t\t\tcount);\n\nfree_databuf:\n\tdma_free_coherent(bpmp->dev, datasize, datavirt, dataphys);\nfree_namebuf:\n\tdma_free_coherent(bpmp->dev, namesize, namevirt, namephys);\n\n\treturn err ?: count;\n}\n\nstatic const struct file_operations debugfs_fops = {\n\t.open\t\t= debugfs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= debugfs_store,\n\t.release\t= single_release,\n};\n\nstatic int bpmp_populate_dir(struct tegra_bpmp *bpmp, struct seqbuf *seqbuf,\n\t\t\t     struct dentry *parent, u32 depth)\n{\n\tint err;\n\tu32 d, t;\n\tconst char *name;\n\tstruct dentry *dentry;\n\n\twhile (!seqbuf_eof(seqbuf)) {\n\t\terr = seqbuf_read_u32(seqbuf, &d);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (d < depth) {\n\t\t\tseqbuf_seek(seqbuf, -4);\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (d != depth) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\n\t\terr = seqbuf_read_u32(seqbuf, &t);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = seqbuf_read_str(seqbuf, &name);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (t & DEBUGFS_S_ISDIR) {\n\t\t\tdentry = debugfs_create_dir(name, parent);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn -ENOMEM;\n\t\t\terr = bpmp_populate_dir(bpmp, seqbuf, dentry, depth+1);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tumode_t mode;\n\n\t\t\tmode = t & DEBUGFS_S_IRUSR ? S_IRUSR : 0;\n\t\t\tmode |= t & DEBUGFS_S_IWUSR ? S_IWUSR : 0;\n\t\t\tdentry = debugfs_create_file(name, mode,\n\t\t\t\t\t\t     parent, bpmp,\n\t\t\t\t\t\t     &debugfs_fops);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bpmp_populate_debugfs_shmem(struct tegra_bpmp *bpmp)\n{\n\tstruct seqbuf seqbuf;\n\tconst size_t sz = SZ_512K;\n\tdma_addr_t phys;\n\tsize_t nbytes;\n\tvoid *virt;\n\tint err;\n\n\tvirt = dma_alloc_coherent(bpmp->dev, sz, &phys,\n\t\t\t\t  GFP_KERNEL | GFP_DMA32);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\terr = mrq_debugfs_dumpdir(bpmp, phys, sz, &nbytes);\n\tif (err < 0) {\n\t\tgoto free;\n\t} else if (nbytes > sz) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tseqbuf_init(&seqbuf, virt, nbytes);\n\terr = bpmp_populate_dir(bpmp, &seqbuf, bpmp->debugfs_mirror, 0);\nfree:\n\tdma_free_coherent(bpmp->dev, sz, virt, phys);\n\n\treturn err;\n}\n\nint tegra_bpmp_init_debugfs(struct tegra_bpmp *bpmp)\n{\n\tstruct dentry *root;\n\tbool inband;\n\tint err;\n\n\tinband = tegra_bpmp_mrq_is_supported(bpmp, MRQ_DEBUG);\n\n\tif (!inband && !tegra_bpmp_mrq_is_supported(bpmp, MRQ_DEBUGFS))\n\t\treturn 0;\n\n\troot = debugfs_create_dir(\"bpmp\", NULL);\n\tif (IS_ERR(root))\n\t\treturn -ENOMEM;\n\n\tbpmp->debugfs_mirror = debugfs_create_dir(\"debug\", root);\n\tif (IS_ERR(bpmp->debugfs_mirror)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (inband)\n\t\terr = bpmp_populate_debugfs_inband(bpmp, bpmp->debugfs_mirror,\n\t\t\t\t\t\t   \"/\");\n\telse\n\t\terr = bpmp_populate_debugfs_shmem(bpmp);\n\nout:\n\tif (err < 0)\n\t\tdebugfs_remove_recursive(root);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}