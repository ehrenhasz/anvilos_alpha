{
  "module_name": "bpmp-tegra186.c",
  "hash_id": "6dc9cc02691d61105b5bf68cfda872e4b908f2a5ac6f7ed9e0a606bf0c397299",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/tegra/bpmp-tegra186.c",
  "human_readable_source": "\n \n\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n#include <soc/tegra/ivc.h>\n\n#include \"bpmp-private.h\"\n\nstruct tegra186_bpmp {\n\tstruct tegra_bpmp *parent;\n\n\tstruct {\n\t\tstruct gen_pool *pool;\n\t\tunion {\n\t\t\tvoid __iomem *sram;\n\t\t\tvoid *dram;\n\t\t};\n\t\tdma_addr_t phys;\n\t} tx, rx;\n\n\tstruct {\n\t\tstruct mbox_client client;\n\t\tstruct mbox_chan *channel;\n\t} mbox;\n};\n\nstatic inline struct tegra_bpmp *\nmbox_client_to_bpmp(struct mbox_client *client)\n{\n\tstruct tegra186_bpmp *priv;\n\n\tpriv = container_of(client, struct tegra186_bpmp, mbox.client);\n\n\treturn priv->parent;\n}\n\nstatic bool tegra186_bpmp_is_message_ready(struct tegra_bpmp_channel *channel)\n{\n\tint err;\n\n\terr = tegra_ivc_read_get_next_frame(channel->ivc, &channel->ib);\n\tif (err) {\n\t\tiosys_map_clear(&channel->ib);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool tegra186_bpmp_is_channel_free(struct tegra_bpmp_channel *channel)\n{\n\tint err;\n\n\terr = tegra_ivc_write_get_next_frame(channel->ivc, &channel->ob);\n\tif (err) {\n\t\tiosys_map_clear(&channel->ob);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int tegra186_bpmp_ack_message(struct tegra_bpmp_channel *channel)\n{\n\treturn tegra_ivc_read_advance(channel->ivc);\n}\n\nstatic int tegra186_bpmp_post_message(struct tegra_bpmp_channel *channel)\n{\n\treturn tegra_ivc_write_advance(channel->ivc);\n}\n\nstatic int tegra186_bpmp_ring_doorbell(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\tint err;\n\n\terr = mbox_send_message(priv->mbox.channel, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tmbox_client_txdone(priv->mbox.channel, 0);\n\n\treturn 0;\n}\n\nstatic void tegra186_bpmp_ivc_notify(struct tegra_ivc *ivc, void *data)\n{\n\tstruct tegra_bpmp *bpmp = data;\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\n\tif (WARN_ON(priv->mbox.channel == NULL))\n\t\treturn;\n\n\ttegra186_bpmp_ring_doorbell(bpmp);\n}\n\nstatic int tegra186_bpmp_channel_init(struct tegra_bpmp_channel *channel,\n\t\t\t\t      struct tegra_bpmp *bpmp,\n\t\t\t\t      unsigned int index)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\tsize_t message_size, queue_size;\n\tstruct iosys_map rx, tx;\n\tunsigned int offset;\n\tint err;\n\n\tchannel->ivc = devm_kzalloc(bpmp->dev, sizeof(*channel->ivc),\n\t\t\t\t    GFP_KERNEL);\n\tif (!channel->ivc)\n\t\treturn -ENOMEM;\n\n\tmessage_size = tegra_ivc_align(MSG_MIN_SZ);\n\tqueue_size = tegra_ivc_total_queue_size(message_size);\n\toffset = queue_size * index;\n\n\tif (priv->rx.pool) {\n\t\tiosys_map_set_vaddr_iomem(&rx, priv->rx.sram + offset);\n\t\tiosys_map_set_vaddr_iomem(&tx, priv->tx.sram + offset);\n\t} else {\n\t\tiosys_map_set_vaddr(&rx, priv->rx.dram + offset);\n\t\tiosys_map_set_vaddr(&tx, priv->tx.dram + offset);\n\t}\n\n\terr = tegra_ivc_init(channel->ivc, NULL, &rx, priv->rx.phys + offset, &tx,\n\t\t\t     priv->tx.phys + offset, 1, message_size, tegra186_bpmp_ivc_notify,\n\t\t\t     bpmp);\n\tif (err < 0) {\n\t\tdev_err(bpmp->dev, \"failed to setup IVC for channel %u: %d\\n\",\n\t\t\tindex, err);\n\t\treturn err;\n\t}\n\n\tinit_completion(&channel->completion);\n\tchannel->bpmp = bpmp;\n\n\treturn 0;\n}\n\nstatic void tegra186_bpmp_channel_reset(struct tegra_bpmp_channel *channel)\n{\n\t \n\ttegra_ivc_reset(channel->ivc);\n\n\t \n\twhile (tegra_ivc_notified(channel->ivc))\n\t\t;\n}\n\nstatic void tegra186_bpmp_channel_cleanup(struct tegra_bpmp_channel *channel)\n{\n\ttegra_ivc_cleanup(channel->ivc);\n}\n\nstatic void mbox_handle_rx(struct mbox_client *client, void *data)\n{\n\tstruct tegra_bpmp *bpmp = mbox_client_to_bpmp(client);\n\n\ttegra_bpmp_handle_rx(bpmp);\n}\n\nstatic void tegra186_bpmp_teardown_channels(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < bpmp->threaded.count; i++) {\n\t\tif (!bpmp->threaded_channels[i].bpmp)\n\t\t\tcontinue;\n\n\t\ttegra186_bpmp_channel_cleanup(&bpmp->threaded_channels[i]);\n\t}\n\n\ttegra186_bpmp_channel_cleanup(bpmp->rx_channel);\n\ttegra186_bpmp_channel_cleanup(bpmp->tx_channel);\n\n\tif (priv->tx.pool) {\n\t\tgen_pool_free(priv->tx.pool, (unsigned long)priv->tx.sram, 4096);\n\t\tgen_pool_free(priv->rx.pool, (unsigned long)priv->rx.sram, 4096);\n\t}\n}\n\nstatic int tegra186_bpmp_dram_init(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\tstruct device_node *np;\n\tstruct resource res;\n\tsize_t size;\n\tint err;\n\n\tnp = of_parse_phandle(bpmp->dev->of_node, \"memory-region\", 0);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\terr = of_address_to_resource(np, 0, &res);\n\tif (err < 0) {\n\t\tdev_warn(bpmp->dev, \"failed to parse memory region: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tsize = resource_size(&res);\n\n\tif (size < SZ_8K) {\n\t\tdev_warn(bpmp->dev, \"DRAM region must be larger than 8 KiB\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->tx.phys = res.start;\n\tpriv->rx.phys = res.start + SZ_4K;\n\n\tpriv->tx.dram = devm_memremap(bpmp->dev, priv->tx.phys, size,\n\t\t\t\t      MEMREMAP_WC);\n\tif (IS_ERR(priv->tx.dram)) {\n\t\terr = PTR_ERR(priv->tx.dram);\n\t\tdev_warn(bpmp->dev, \"failed to map DRAM region: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->rx.dram = priv->tx.dram + SZ_4K;\n\n\treturn 0;\n}\n\nstatic int tegra186_bpmp_sram_init(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\tint err;\n\n\tpriv->tx.pool = of_gen_pool_get(bpmp->dev->of_node, \"shmem\", 0);\n\tif (!priv->tx.pool) {\n\t\tdev_err(bpmp->dev, \"TX shmem pool not found\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tpriv->tx.sram = (void __iomem *)gen_pool_dma_alloc(priv->tx.pool, 4096,\n\t\t\t\t\t\t\t   &priv->tx.phys);\n\tif (!priv->tx.sram) {\n\t\tdev_err(bpmp->dev, \"failed to allocate from TX pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->rx.pool = of_gen_pool_get(bpmp->dev->of_node, \"shmem\", 1);\n\tif (!priv->rx.pool) {\n\t\tdev_err(bpmp->dev, \"RX shmem pool not found\\n\");\n\t\terr = -EPROBE_DEFER;\n\t\tgoto free_tx;\n\t}\n\n\tpriv->rx.sram = (void __iomem *)gen_pool_dma_alloc(priv->rx.pool, 4096,\n\t\t\t\t\t\t\t   &priv->rx.phys);\n\tif (!priv->rx.sram) {\n\t\tdev_err(bpmp->dev, \"failed to allocate from RX pool\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_tx;\n\t}\n\n\treturn 0;\n\nfree_tx:\n\tgen_pool_free(priv->tx.pool, (unsigned long)priv->tx.sram, 4096);\n\n\treturn err;\n}\n\nstatic int tegra186_bpmp_setup_channels(struct tegra_bpmp *bpmp)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = tegra186_bpmp_dram_init(bpmp);\n\tif (err == -ENODEV) {\n\t\terr = tegra186_bpmp_sram_init(bpmp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = tegra186_bpmp_channel_init(bpmp->tx_channel, bpmp,\n\t\t\t\t\t bpmp->soc->channels.cpu_tx.offset);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = tegra186_bpmp_channel_init(bpmp->rx_channel, bpmp,\n\t\t\t\t\t bpmp->soc->channels.cpu_rx.offset);\n\tif (err < 0) {\n\t\ttegra186_bpmp_channel_cleanup(bpmp->tx_channel);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < bpmp->threaded.count; i++) {\n\t\tunsigned int index = bpmp->soc->channels.thread.offset + i;\n\n\t\terr = tegra186_bpmp_channel_init(&bpmp->threaded_channels[i],\n\t\t\t\t\t\t bpmp, index);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tif (err < 0)\n\t\ttegra186_bpmp_teardown_channels(bpmp);\n\n\treturn err;\n}\n\nstatic void tegra186_bpmp_reset_channels(struct tegra_bpmp *bpmp)\n{\n\tunsigned int i;\n\n\t \n\ttegra186_bpmp_channel_reset(bpmp->tx_channel);\n\ttegra186_bpmp_channel_reset(bpmp->rx_channel);\n\n\tfor (i = 0; i < bpmp->threaded.count; i++)\n\t\ttegra186_bpmp_channel_reset(&bpmp->threaded_channels[i]);\n}\n\nstatic int tegra186_bpmp_init(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(bpmp->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->parent = bpmp;\n\tbpmp->priv = priv;\n\n\terr = tegra186_bpmp_setup_channels(bpmp);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpriv->mbox.client.dev = bpmp->dev;\n\tpriv->mbox.client.rx_callback = mbox_handle_rx;\n\tpriv->mbox.client.tx_block = false;\n\tpriv->mbox.client.knows_txdone = false;\n\n\tpriv->mbox.channel = mbox_request_channel(&priv->mbox.client, 0);\n\tif (IS_ERR(priv->mbox.channel)) {\n\t\terr = PTR_ERR(priv->mbox.channel);\n\t\tdev_err(bpmp->dev, \"failed to get HSP mailbox: %d\\n\", err);\n\t\ttegra186_bpmp_teardown_channels(bpmp);\n\t\treturn err;\n\t}\n\n\ttegra186_bpmp_reset_channels(bpmp);\n\n\treturn 0;\n}\n\nstatic void tegra186_bpmp_deinit(struct tegra_bpmp *bpmp)\n{\n\tstruct tegra186_bpmp *priv = bpmp->priv;\n\n\tmbox_free_channel(priv->mbox.channel);\n\n\ttegra186_bpmp_teardown_channels(bpmp);\n}\n\nstatic int tegra186_bpmp_resume(struct tegra_bpmp *bpmp)\n{\n\ttegra186_bpmp_reset_channels(bpmp);\n\n\treturn 0;\n}\n\nconst struct tegra_bpmp_ops tegra186_bpmp_ops = {\n\t.init = tegra186_bpmp_init,\n\t.deinit = tegra186_bpmp_deinit,\n\t.is_response_ready = tegra186_bpmp_is_message_ready,\n\t.is_request_ready = tegra186_bpmp_is_message_ready,\n\t.ack_response = tegra186_bpmp_ack_message,\n\t.ack_request = tegra186_bpmp_ack_message,\n\t.is_response_channel_free = tegra186_bpmp_is_channel_free,\n\t.is_request_channel_free = tegra186_bpmp_is_channel_free,\n\t.post_response = tegra186_bpmp_post_message,\n\t.post_request = tegra186_bpmp_post_message,\n\t.ring_doorbell = tegra186_bpmp_ring_doorbell,\n\t.resume = tegra186_bpmp_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}