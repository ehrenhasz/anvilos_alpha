{
  "module_name": "unaccepted_memory.c",
  "hash_id": "0d50e80b303993dc2e81592a6408baf634e166d74f1f5dd514421e4ca2913a4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/unaccepted_memory.c",
  "human_readable_source": "\n\n#include <linux/efi.h>\n#include <linux/memblock.h>\n#include <linux/spinlock.h>\n#include <asm/unaccepted_memory.h>\n\n \nstatic DEFINE_SPINLOCK(unaccepted_memory_lock);\n\nstruct accept_range {\n\tstruct list_head list;\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstatic LIST_HEAD(accepting_list);\n\n \nvoid accept_memory(phys_addr_t start, phys_addr_t end)\n{\n\tstruct efi_unaccepted_memory *unaccepted;\n\tunsigned long range_start, range_end;\n\tstruct accept_range range, *entry;\n\tunsigned long flags;\n\tu64 unit_size;\n\n\tunaccepted = efi_get_unaccepted_table();\n\tif (!unaccepted)\n\t\treturn;\n\n\tunit_size = unaccepted->unit_size;\n\n\t \n\tif (start < unaccepted->phys_base)\n\t\tstart = unaccepted->phys_base;\n\tif (end < unaccepted->phys_base)\n\t\treturn;\n\n\t \n\tstart -= unaccepted->phys_base;\n\tend -= unaccepted->phys_base;\n\n\t \n\tif (!(end % unit_size))\n\t\tend += unit_size;\n\n\t \n\tif (end > unaccepted->size * unit_size * BITS_PER_BYTE)\n\t\tend = unaccepted->size * unit_size * BITS_PER_BYTE;\n\n\trange.start = start / unit_size;\n\trange.end = DIV_ROUND_UP(end, unit_size);\nretry:\n\tspin_lock_irqsave(&unaccepted_memory_lock, flags);\n\n\t \n\tlist_for_each_entry(entry, &accepting_list, list) {\n\t\tif (entry->end <= range.start)\n\t\t\tcontinue;\n\t\tif (entry->start >= range.end)\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_unlock_irqrestore(&unaccepted_memory_lock, flags);\n\t\tgoto retry;\n\t}\n\n\t \n\tlist_add(&range.list, &accepting_list);\n\n\trange_start = range.start;\n\tfor_each_set_bitrange_from(range_start, range_end, unaccepted->bitmap,\n\t\t\t\t   range.end) {\n\t\tunsigned long phys_start, phys_end;\n\t\tunsigned long len = range_end - range_start;\n\n\t\tphys_start = range_start * unit_size + unaccepted->phys_base;\n\t\tphys_end = range_end * unit_size + unaccepted->phys_base;\n\n\t\t \n\t\tspin_unlock(&unaccepted_memory_lock);\n\n\t\tarch_accept_memory(phys_start, phys_end);\n\n\t\tspin_lock(&unaccepted_memory_lock);\n\t\tbitmap_clear(unaccepted->bitmap, range_start, len);\n\t}\n\n\tlist_del(&range.list);\n\tspin_unlock_irqrestore(&unaccepted_memory_lock, flags);\n}\n\nbool range_contains_unaccepted_memory(phys_addr_t start, phys_addr_t end)\n{\n\tstruct efi_unaccepted_memory *unaccepted;\n\tunsigned long flags;\n\tbool ret = false;\n\tu64 unit_size;\n\n\tunaccepted = efi_get_unaccepted_table();\n\tif (!unaccepted)\n\t\treturn false;\n\n\tunit_size = unaccepted->unit_size;\n\n\t \n\tif (start < unaccepted->phys_base)\n\t\tstart = unaccepted->phys_base;\n\tif (end < unaccepted->phys_base)\n\t\treturn false;\n\n\t \n\tstart -= unaccepted->phys_base;\n\tend -= unaccepted->phys_base;\n\n\t \n\tif (!(end % unit_size))\n\t\tend += unit_size;\n\n\t \n\tif (end > unaccepted->size * unit_size * BITS_PER_BYTE)\n\t\tend = unaccepted->size * unit_size * BITS_PER_BYTE;\n\n\tspin_lock_irqsave(&unaccepted_memory_lock, flags);\n\twhile (start < end) {\n\t\tif (test_bit(start / unit_size, unaccepted->bitmap)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tstart += unit_size;\n\t}\n\tspin_unlock_irqrestore(&unaccepted_memory_lock, flags);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}