{
  "module_name": "mokvar-table.c",
  "hash_id": "728b42db635e9a132297a447ff2e5846d5dceef6604781f719a75ce64ca85821",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/mokvar-table.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"mokvar: \" fmt\n\n#include <linux/capability.h>\n#include <linux/efi.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <asm/early_ioremap.h>\n\n \nstatic size_t efi_mokvar_table_size;\n\n \nstatic struct efi_mokvar_table_entry *efi_mokvar_table_va;\n\n \nstruct efi_mokvar_sysfs_attr {\n\tstruct bin_attribute bin_attr;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(efi_mokvar_sysfs_list);\nstatic struct kobject *mokvar_kobj;\n\n \nvoid __init efi_mokvar_table_init(void)\n{\n\tefi_memory_desc_t md;\n\tvoid *va = NULL;\n\tunsigned long cur_offset = 0;\n\tunsigned long offset_limit;\n\tunsigned long map_size = 0;\n\tunsigned long map_size_needed = 0;\n\tunsigned long size;\n\tstruct efi_mokvar_table_entry *mokvar_entry;\n\tint err;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn;\n\n\tif (efi.mokvar_table == EFI_INVALID_TABLE_ADDR)\n\t\treturn;\n\t \n\terr = efi_mem_desc_lookup(efi.mokvar_table, &md);\n\tif (err) {\n\t\tpr_warn(\"EFI MOKvar config table is not within the EFI memory map\\n\");\n\t\treturn;\n\t}\n\n\toffset_limit = efi_mem_desc_end(&md) - efi.mokvar_table;\n\n\t \n\terr = -EINVAL;\n\twhile (cur_offset + sizeof(*mokvar_entry) <= offset_limit) {\n\t\tmokvar_entry = va + cur_offset;\n\t\tmap_size_needed = cur_offset + sizeof(*mokvar_entry);\n\t\tif (map_size_needed > map_size) {\n\t\t\tif (va)\n\t\t\t\tearly_memunmap(va, map_size);\n\t\t\t \n\t\t\tmap_size = min(map_size_needed + 2*EFI_PAGE_SIZE,\n\t\t\t\t       offset_limit);\n\t\t\tva = early_memremap(efi.mokvar_table, map_size);\n\t\t\tif (!va) {\n\t\t\t\tpr_err(\"Failed to map EFI MOKvar config table pa=0x%lx, size=%lu.\\n\",\n\t\t\t\t       efi.mokvar_table, map_size);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmokvar_entry = va + cur_offset;\n\t\t}\n\n\t\t \n\t\tif (mokvar_entry->name[0] == '\\0') {\n\t\t\tif (mokvar_entry->data_size != 0)\n\t\t\t\tbreak;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsize = strnlen(mokvar_entry->name,\n\t\t\t       sizeof(mokvar_entry->name));\n\t\tif (size >= sizeof(mokvar_entry->name))\n\t\t\tbreak;\n\n\t\t \n\t\tcur_offset = map_size_needed + mokvar_entry->data_size;\n\t}\n\n\tif (va)\n\t\tearly_memunmap(va, map_size);\n\tif (err) {\n\t\tpr_err(\"EFI MOKvar config table is not valid\\n\");\n\t\treturn;\n\t}\n\n\tif (md.type == EFI_BOOT_SERVICES_DATA)\n\t\tefi_mem_reserve(efi.mokvar_table, map_size_needed);\n\n\tefi_mokvar_table_size = map_size_needed;\n}\n\n \nstruct efi_mokvar_table_entry *efi_mokvar_entry_next(\n\t\t\tstruct efi_mokvar_table_entry **mokvar_entry)\n{\n\tstruct efi_mokvar_table_entry *mokvar_cur;\n\tstruct efi_mokvar_table_entry *mokvar_next;\n\tsize_t size_cur;\n\n\tmokvar_cur = *mokvar_entry;\n\t*mokvar_entry = NULL;\n\n\tif (efi_mokvar_table_va == NULL)\n\t\treturn NULL;\n\n\tif (mokvar_cur == NULL) {\n\t\tmokvar_next = efi_mokvar_table_va;\n\t} else {\n\t\tif (mokvar_cur->name[0] == '\\0')\n\t\t\treturn NULL;\n\t\tsize_cur = sizeof(*mokvar_cur) + mokvar_cur->data_size;\n\t\tmokvar_next = (void *)mokvar_cur + size_cur;\n\t}\n\n\tif (mokvar_next->name[0] == '\\0')\n\t\treturn NULL;\n\n\t*mokvar_entry = mokvar_next;\n\treturn mokvar_next;\n}\n\n \nstruct efi_mokvar_table_entry *efi_mokvar_entry_find(const char *name)\n{\n\tstruct efi_mokvar_table_entry *mokvar_entry = NULL;\n\n\twhile (efi_mokvar_entry_next(&mokvar_entry)) {\n\t\tif (!strncmp(name, mokvar_entry->name,\n\t\t\t     sizeof(mokvar_entry->name)))\n\t\t\treturn mokvar_entry;\n\t}\n\treturn NULL;\n}\n\n \nstatic ssize_t efi_mokvar_sysfs_read(struct file *file, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t loff_t off, size_t count)\n{\n\tstruct efi_mokvar_table_entry *mokvar_entry = bin_attr->private;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tif (off >= mokvar_entry->data_size)\n\t\treturn 0;\n\tif (count >  mokvar_entry->data_size - off)\n\t\tcount = mokvar_entry->data_size - off;\n\n\tmemcpy(buf, mokvar_entry->data + off, count);\n\treturn count;\n}\n\n \nstatic int __init efi_mokvar_sysfs_init(void)\n{\n\tvoid *config_va;\n\tstruct efi_mokvar_table_entry *mokvar_entry = NULL;\n\tstruct efi_mokvar_sysfs_attr *mokvar_sysfs = NULL;\n\tint err = 0;\n\n\tif (efi_mokvar_table_size == 0)\n\t\treturn -ENOENT;\n\n\tconfig_va = memremap(efi.mokvar_table, efi_mokvar_table_size,\n\t\t\t     MEMREMAP_WB);\n\tif (!config_va) {\n\t\tpr_err(\"Failed to map EFI MOKvar config table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tefi_mokvar_table_va = config_va;\n\n\tmokvar_kobj = kobject_create_and_add(\"mok-variables\", efi_kobj);\n\tif (!mokvar_kobj) {\n\t\tpr_err(\"Failed to create EFI mok-variables sysfs entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (efi_mokvar_entry_next(&mokvar_entry)) {\n\t\tmokvar_sysfs = kzalloc(sizeof(*mokvar_sysfs), GFP_KERNEL);\n\t\tif (!mokvar_sysfs) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tsysfs_bin_attr_init(&mokvar_sysfs->bin_attr);\n\t\tmokvar_sysfs->bin_attr.private = mokvar_entry;\n\t\tmokvar_sysfs->bin_attr.attr.name = mokvar_entry->name;\n\t\tmokvar_sysfs->bin_attr.attr.mode = 0400;\n\t\tmokvar_sysfs->bin_attr.size = mokvar_entry->data_size;\n\t\tmokvar_sysfs->bin_attr.read = efi_mokvar_sysfs_read;\n\n\t\terr = sysfs_create_bin_file(mokvar_kobj,\n\t\t\t\t\t   &mokvar_sysfs->bin_attr);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tlist_add_tail(&mokvar_sysfs->node, &efi_mokvar_sysfs_list);\n\t}\n\n\tif (err) {\n\t\tpr_err(\"Failed to create some EFI mok-variables sysfs entries\\n\");\n\t\tkfree(mokvar_sysfs);\n\t}\n\treturn err;\n}\nfs_initcall(efi_mokvar_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}