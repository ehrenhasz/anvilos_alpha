{
  "module_name": "efi-pstore.c",
  "hash_id": "1e6d7901cf977ea976beb96e0cf09af1048fd01417964de5965c6edd4ea54d03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/efi-pstore.c",
  "human_readable_source": "\n\n#include <linux/efi.h>\n#include <linux/module.h>\n#include <linux/pstore.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n\nMODULE_IMPORT_NS(EFIVAR);\n\n#define DUMP_NAME_LEN 66\n\nstatic unsigned int record_size = 1024;\nmodule_param(record_size, uint, 0444);\nMODULE_PARM_DESC(record_size, \"size of each pstore UEFI var (in bytes, min/default=1024)\");\n\nstatic bool efivars_pstore_disable =\n\tIS_ENABLED(CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE);\n\nmodule_param_named(pstore_disable, efivars_pstore_disable, bool, 0644);\n\n#define PSTORE_EFI_ATTRIBUTES \\\n\t(EFI_VARIABLE_NON_VOLATILE | \\\n\t EFI_VARIABLE_BOOTSERVICE_ACCESS | \\\n\t EFI_VARIABLE_RUNTIME_ACCESS)\n\nstatic int efi_pstore_open(struct pstore_info *psi)\n{\n\tint err;\n\n\terr = efivar_lock();\n\tif (err)\n\t\treturn err;\n\n\tpsi->data = kzalloc(record_size, GFP_KERNEL);\n\tif (!psi->data)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int efi_pstore_close(struct pstore_info *psi)\n{\n\tefivar_unlock();\n\tkfree(psi->data);\n\treturn 0;\n}\n\nstatic inline u64 generic_id(u64 timestamp, unsigned int part, int count)\n{\n\treturn (timestamp * 100 + part) * 1000 + count;\n}\n\nstatic int efi_pstore_read_func(struct pstore_record *record,\n\t\t\t\tefi_char16_t *varname)\n{\n\tunsigned long wlen, size = record_size;\n\tchar name[DUMP_NAME_LEN], data_type;\n\tefi_status_t status;\n\tint cnt;\n\tunsigned int part;\n\tu64 time;\n\n\tucs2_as_utf8(name, varname, DUMP_NAME_LEN);\n\n\tif (sscanf(name, \"dump-type%u-%u-%d-%llu-%c\",\n\t\t   &record->type, &part, &cnt, &time, &data_type) == 5) {\n\t\trecord->id = generic_id(time, part, cnt);\n\t\trecord->part = part;\n\t\trecord->count = cnt;\n\t\trecord->time.tv_sec = time;\n\t\trecord->time.tv_nsec = 0;\n\t\tif (data_type == 'C')\n\t\t\trecord->compressed = true;\n\t\telse\n\t\t\trecord->compressed = false;\n\t\trecord->ecc_notice_size = 0;\n\t} else if (sscanf(name, \"dump-type%u-%u-%d-%llu\",\n\t\t   &record->type, &part, &cnt, &time) == 4) {\n\t\trecord->id = generic_id(time, part, cnt);\n\t\trecord->part = part;\n\t\trecord->count = cnt;\n\t\trecord->time.tv_sec = time;\n\t\trecord->time.tv_nsec = 0;\n\t\trecord->compressed = false;\n\t\trecord->ecc_notice_size = 0;\n\t} else if (sscanf(name, \"dump-type%u-%u-%llu\",\n\t\t\t  &record->type, &part, &time) == 3) {\n\t\t \n\t\trecord->id = generic_id(time, part, 0);\n\t\trecord->part = part;\n\t\trecord->count = 0;\n\t\trecord->time.tv_sec = time;\n\t\trecord->time.tv_nsec = 0;\n\t\trecord->compressed = false;\n\t\trecord->ecc_notice_size = 0;\n\t} else\n\t\treturn 0;\n\n\trecord->buf = kmalloc(size, GFP_KERNEL);\n\tif (!record->buf)\n\t\treturn -ENOMEM;\n\n\tstatus = efivar_get_variable(varname, &LINUX_EFI_CRASH_GUID, NULL,\n\t\t\t\t     &size, record->buf);\n\tif (status != EFI_SUCCESS) {\n\t\tkfree(record->buf);\n\t\treturn -EIO;\n\t}\n\n\t \n\twlen = (ucs2_strnlen(varname, DUMP_NAME_LEN) + 1) * sizeof(efi_char16_t);\n\trecord->priv = kmemdup(varname, wlen, GFP_KERNEL);\n\tif (!record->priv) {\n\t\tkfree(record->buf);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t efi_pstore_read(struct pstore_record *record)\n{\n\tefi_char16_t *varname = record->psi->data;\n\tefi_guid_t guid = LINUX_EFI_CRASH_GUID;\n\tunsigned long varname_size;\n\tefi_status_t status;\n\n\tfor (;;) {\n\t\tvarname_size = 1024;\n\n\t\t \n\t\tstatus = efivar_get_next_variable(&varname_size, varname, &guid);\n\t\tif (status == EFI_NOT_FOUND)\n\t\t\treturn 0;\n\n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (efi_guidcmp(guid, LINUX_EFI_CRASH_GUID))\n\t\t\tcontinue;\n\n\t\treturn efi_pstore_read_func(record, varname);\n\t}\n}\n\nstatic int efi_pstore_write(struct pstore_record *record)\n{\n\tchar name[DUMP_NAME_LEN];\n\tefi_char16_t efi_name[DUMP_NAME_LEN];\n\tefi_status_t status;\n\tint i;\n\n\trecord->id = generic_id(record->time.tv_sec, record->part,\n\t\t\t\trecord->count);\n\n\t \n\tmemset(name, 0, sizeof(name));\n\n\tsnprintf(name, sizeof(name), \"dump-type%u-%u-%d-%lld-%c\",\n\t\t record->type, record->part, record->count,\n\t\t (long long)record->time.tv_sec,\n\t\t record->compressed ? 'C' : 'D');\n\n\tfor (i = 0; i < DUMP_NAME_LEN; i++)\n\t\tefi_name[i] = name[i];\n\n\tif (efivar_trylock())\n\t\treturn -EBUSY;\n\tstatus = efivar_set_variable_locked(efi_name, &LINUX_EFI_CRASH_GUID,\n\t\t\t\t\t    PSTORE_EFI_ATTRIBUTES,\n\t\t\t\t\t    record->size, record->psi->buf,\n\t\t\t\t\t    true);\n\tefivar_unlock();\n\treturn status == EFI_SUCCESS ? 0 : -EIO;\n};\n\nstatic int efi_pstore_erase(struct pstore_record *record)\n{\n\tefi_status_t status;\n\n\tstatus = efivar_set_variable(record->priv, &LINUX_EFI_CRASH_GUID,\n\t\t\t\t     PSTORE_EFI_ATTRIBUTES, 0, NULL);\n\n\tif (status != EFI_SUCCESS && status != EFI_NOT_FOUND)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic struct pstore_info efi_pstore_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= KBUILD_MODNAME,\n\t.flags\t\t= PSTORE_FLAGS_DMESG,\n\t.open\t\t= efi_pstore_open,\n\t.close\t\t= efi_pstore_close,\n\t.read\t\t= efi_pstore_read,\n\t.write\t\t= efi_pstore_write,\n\t.erase\t\t= efi_pstore_erase,\n};\n\nstatic __init int efivars_pstore_init(void)\n{\n\tif (!efivar_supports_writes())\n\t\treturn 0;\n\n\tif (efivars_pstore_disable)\n\t\treturn 0;\n\n\t \n\tif (record_size < 1024)\n\t\trecord_size = 1024;\n\n\tefi_pstore_info.buf = kmalloc(record_size, GFP_KERNEL);\n\tif (!efi_pstore_info.buf)\n\t\treturn -ENOMEM;\n\n\tefi_pstore_info.bufsize = record_size;\n\n\tif (pstore_register(&efi_pstore_info)) {\n\t\tkfree(efi_pstore_info.buf);\n\t\tefi_pstore_info.buf = NULL;\n\t\tefi_pstore_info.bufsize = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic __exit void efivars_pstore_exit(void)\n{\n\tif (!efi_pstore_info.bufsize)\n\t\treturn;\n\n\tpstore_unregister(&efi_pstore_info);\n\tkfree(efi_pstore_info.buf);\n\tefi_pstore_info.buf = NULL;\n\tefi_pstore_info.bufsize = 0;\n}\n\nmodule_init(efivars_pstore_init);\nmodule_exit(efivars_pstore_exit);\n\nMODULE_DESCRIPTION(\"EFI variable backend for pstore\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:efivars\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}