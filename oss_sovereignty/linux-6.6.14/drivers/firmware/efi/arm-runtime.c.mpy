{
  "module_name": "arm-runtime.c",
  "hash_id": "4b8fa541cd7eb6cbb6584b989af0bdebce495eb09284ffa801998dda9007b7a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/arm-runtime.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/io.h>\n#include <linux/memblock.h>\n#include <linux/mm_types.h>\n#include <linux/preempt.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/pgtable.h>\n\n#include <asm/cacheflush.h>\n#include <asm/efi.h>\n#include <asm/mmu.h>\n#include <asm/pgalloc.h>\n\n#if defined(CONFIG_PTDUMP_DEBUGFS) || defined(CONFIG_ARM_PTDUMP_DEBUGFS)\n#include <asm/ptdump.h>\n\nstatic struct ptdump_info efi_ptdump_info = {\n\t.mm\t\t= &efi_mm,\n\t.markers\t= (struct addr_marker[]){\n\t\t{ 0,\t\t\t\t\"UEFI runtime start\" },\n\t\t{ EFI_RUNTIME_MAP_END,\t\t\"UEFI runtime end\" },\n\t\t{ -1,\t\t\t\tNULL }\n\t},\n\t.base_addr\t= 0,\n};\n\nstatic int __init ptdump_init(void)\n{\n\tif (efi_enabled(EFI_RUNTIME_SERVICES))\n\t\tptdump_debugfs_register(&efi_ptdump_info, \"efi_page_tables\");\n\n\treturn 0;\n}\ndevice_initcall(ptdump_init);\n\n#endif\n\nstatic bool __init efi_virtmap_init(void)\n{\n\tefi_memory_desc_t *md;\n\n\tefi_mm.pgd = pgd_alloc(&efi_mm);\n\tmm_init_cpumask(&efi_mm);\n\tinit_new_context(NULL, &efi_mm);\n\n\tfor_each_efi_memory_desc(md) {\n\t\tphys_addr_t phys = md->phys_addr;\n\t\tint ret;\n\n\t\tif (!(md->attribute & EFI_MEMORY_RUNTIME))\n\t\t\tcontinue;\n\t\tif (md->virt_addr == U64_MAX)\n\t\t\treturn false;\n\n\t\tret = efi_create_mapping(&efi_mm, md);\n\t\tif (ret) {\n\t\t\tpr_warn(\"  EFI remap %pa: failed to create mapping (%d)\\n\",\n\t\t\t\t&phys, ret);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (efi_memattr_apply_permissions(&efi_mm, efi_set_mapping_permissions))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int __init arm_enable_runtime_services(void)\n{\n\tu64 mapsize;\n\n\tif (!efi_enabled(EFI_BOOT)) {\n\t\tpr_info(\"EFI services will not be available.\\n\");\n\t\treturn 0;\n\t}\n\n\tefi_memmap_unmap();\n\n\tmapsize = efi.memmap.desc_size * efi.memmap.nr_map;\n\n\tif (efi_memmap_init_late(efi.memmap.phys_map, mapsize)) {\n\t\tpr_err(\"Failed to remap EFI memory map\\n\");\n\t\treturn 0;\n\t}\n\n\tif (efi_soft_reserve_enabled()) {\n\t\tefi_memory_desc_t *md;\n\n\t\tfor_each_efi_memory_desc(md) {\n\t\t\tint md_size = md->num_pages << EFI_PAGE_SHIFT;\n\t\t\tstruct resource *res;\n\n\t\t\tif (!(md->attribute & EFI_MEMORY_SP))\n\t\t\t\tcontinue;\n\n\t\t\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\t\t\tif (WARN_ON(!res))\n\t\t\t\tbreak;\n\n\t\t\tres->start\t= md->phys_addr;\n\t\t\tres->end\t= md->phys_addr + md_size - 1;\n\t\t\tres->name\t= \"Soft Reserved\";\n\t\t\tres->flags\t= IORESOURCE_MEM;\n\t\t\tres->desc\t= IORES_DESC_SOFT_RESERVED;\n\n\t\t\tinsert_resource(&iomem_resource, res);\n\t\t}\n\t}\n\n\tif (efi_runtime_disabled()) {\n\t\tpr_info(\"EFI runtime services will be disabled.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (efi_enabled(EFI_RUNTIME_SERVICES)) {\n\t\tpr_info(\"EFI runtime services access via paravirt.\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_info(\"Remapping and enabling EFI services.\\n\");\n\n\tif (!efi_virtmap_init()) {\n\t\tpr_err(\"UEFI virtual mapping missing or invalid -- runtime services will not be available\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tefi_native_runtime_setup();\n\tset_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\n\treturn 0;\n}\nearly_initcall(arm_enable_runtime_services);\n\nvoid efi_virtmap_load(void)\n{\n\tpreempt_disable();\n\tefi_set_pgd(&efi_mm);\n}\n\nvoid efi_virtmap_unload(void)\n{\n\tefi_set_pgd(current->active_mm);\n\tpreempt_enable();\n}\n\n\nstatic int __init arm_dmi_init(void)\n{\n\t \n\tdmi_setup();\n\treturn 0;\n}\ncore_initcall(arm_dmi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}