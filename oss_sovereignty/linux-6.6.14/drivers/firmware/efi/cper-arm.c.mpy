{
  "module_name": "cper-arm.c",
  "hash_id": "38ccc6b787af73a295313fc43f905f6b859c9eafc98853a92ba7af52f481e198",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/cper-arm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/cper.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/printk.h>\n#include <linux/bcd.h>\n#include <acpi/ghes.h>\n#include <ras/ras_event.h>\n\nstatic const char * const arm_reg_ctx_strs[] = {\n\t\"AArch32 general purpose registers\",\n\t\"AArch32 EL1 context registers\",\n\t\"AArch32 EL2 context registers\",\n\t\"AArch32 secure context registers\",\n\t\"AArch64 general purpose registers\",\n\t\"AArch64 EL1 context registers\",\n\t\"AArch64 EL2 context registers\",\n\t\"AArch64 EL3 context registers\",\n\t\"Misc. system register structure\",\n};\n\nstatic const char * const arm_err_trans_type_strs[] = {\n\t\"Instruction\",\n\t\"Data Access\",\n\t\"Generic\",\n};\n\nstatic const char * const arm_bus_err_op_strs[] = {\n\t\"Generic error (type cannot be determined)\",\n\t\"Generic read (type of instruction or data request cannot be determined)\",\n\t\"Generic write (type of instruction of data request cannot be determined)\",\n\t\"Data read\",\n\t\"Data write\",\n\t\"Instruction fetch\",\n\t\"Prefetch\",\n};\n\nstatic const char * const arm_cache_err_op_strs[] = {\n\t\"Generic error (type cannot be determined)\",\n\t\"Generic read (type of instruction or data request cannot be determined)\",\n\t\"Generic write (type of instruction of data request cannot be determined)\",\n\t\"Data read\",\n\t\"Data write\",\n\t\"Instruction fetch\",\n\t\"Prefetch\",\n\t\"Eviction\",\n\t\"Snooping (processor initiated a cache snoop that resulted in an error)\",\n\t\"Snooped (processor raised a cache error caused by another processor or device snooping its cache)\",\n\t\"Management\",\n};\n\nstatic const char * const arm_tlb_err_op_strs[] = {\n\t\"Generic error (type cannot be determined)\",\n\t\"Generic read (type of instruction or data request cannot be determined)\",\n\t\"Generic write (type of instruction of data request cannot be determined)\",\n\t\"Data read\",\n\t\"Data write\",\n\t\"Instruction fetch\",\n\t\"Prefetch\",\n\t\"Local management operation (processor initiated a TLB management operation that resulted in an error)\",\n\t\"External management operation (processor raised a TLB error caused by another processor or device broadcasting TLB operations)\",\n};\n\nstatic const char * const arm_bus_err_part_type_strs[] = {\n\t\"Local processor originated request\",\n\t\"Local processor responded to request\",\n\t\"Local processor observed\",\n\t\"Generic\",\n};\n\nstatic const char * const arm_bus_err_addr_space_strs[] = {\n\t\"External Memory Access\",\n\t\"Internal Memory Access\",\n\t\"Unknown\",\n\t\"Device Memory Access\",\n};\n\nstatic void cper_print_arm_err_info(const char *pfx, u32 type,\n\t\t\t\t    u64 error_info)\n{\n\tu8 trans_type, op_type, level, participation_type, address_space;\n\tu16 mem_attributes;\n\tbool proc_context_corrupt, corrected, precise_pc, restartable_pc;\n\tbool time_out, access_mode;\n\n\t \n\tif (type > CPER_ARM_MAX_TYPE)\n\t\treturn;\n\n\t \n\tif (type == CPER_ARM_VENDOR_ERROR)\n\t\treturn;\n\n\tif (error_info & CPER_ARM_ERR_VALID_TRANSACTION_TYPE) {\n\t\ttrans_type = ((error_info >> CPER_ARM_ERR_TRANSACTION_SHIFT)\n\t\t\t      & CPER_ARM_ERR_TRANSACTION_MASK);\n\t\tif (trans_type < ARRAY_SIZE(arm_err_trans_type_strs)) {\n\t\t\tprintk(\"%stransaction type: %s\\n\", pfx,\n\t\t\t       arm_err_trans_type_strs[trans_type]);\n\t\t}\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_OPERATION_TYPE) {\n\t\top_type = ((error_info >> CPER_ARM_ERR_OPERATION_SHIFT)\n\t\t\t   & CPER_ARM_ERR_OPERATION_MASK);\n\t\tswitch (type) {\n\t\tcase CPER_ARM_CACHE_ERROR:\n\t\t\tif (op_type < ARRAY_SIZE(arm_cache_err_op_strs)) {\n\t\t\t\tprintk(\"%soperation type: %s\\n\", pfx,\n\t\t\t\t       arm_cache_err_op_strs[op_type]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CPER_ARM_TLB_ERROR:\n\t\t\tif (op_type < ARRAY_SIZE(arm_tlb_err_op_strs)) {\n\t\t\t\tprintk(\"%soperation type: %s\\n\", pfx,\n\t\t\t\t       arm_tlb_err_op_strs[op_type]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CPER_ARM_BUS_ERROR:\n\t\t\tif (op_type < ARRAY_SIZE(arm_bus_err_op_strs)) {\n\t\t\t\tprintk(\"%soperation type: %s\\n\", pfx,\n\t\t\t\t       arm_bus_err_op_strs[op_type]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_LEVEL) {\n\t\tlevel = ((error_info >> CPER_ARM_ERR_LEVEL_SHIFT)\n\t\t\t & CPER_ARM_ERR_LEVEL_MASK);\n\t\tswitch (type) {\n\t\tcase CPER_ARM_CACHE_ERROR:\n\t\t\tprintk(\"%scache level: %d\\n\", pfx, level);\n\t\t\tbreak;\n\t\tcase CPER_ARM_TLB_ERROR:\n\t\t\tprintk(\"%sTLB level: %d\\n\", pfx, level);\n\t\t\tbreak;\n\t\tcase CPER_ARM_BUS_ERROR:\n\t\t\tprintk(\"%saffinity level at which the bus error occurred: %d\\n\",\n\t\t\t       pfx, level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_PROC_CONTEXT_CORRUPT) {\n\t\tproc_context_corrupt = ((error_info >> CPER_ARM_ERR_PC_CORRUPT_SHIFT)\n\t\t\t\t\t& CPER_ARM_ERR_PC_CORRUPT_MASK);\n\t\tif (proc_context_corrupt)\n\t\t\tprintk(\"%sprocessor context corrupted\\n\", pfx);\n\t\telse\n\t\t\tprintk(\"%sprocessor context not corrupted\\n\", pfx);\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_CORRECTED) {\n\t\tcorrected = ((error_info >> CPER_ARM_ERR_CORRECTED_SHIFT)\n\t\t\t     & CPER_ARM_ERR_CORRECTED_MASK);\n\t\tif (corrected)\n\t\t\tprintk(\"%sthe error has been corrected\\n\", pfx);\n\t\telse\n\t\t\tprintk(\"%sthe error has not been corrected\\n\", pfx);\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_PRECISE_PC) {\n\t\tprecise_pc = ((error_info >> CPER_ARM_ERR_PRECISE_PC_SHIFT)\n\t\t\t      & CPER_ARM_ERR_PRECISE_PC_MASK);\n\t\tif (precise_pc)\n\t\t\tprintk(\"%sPC is precise\\n\", pfx);\n\t\telse\n\t\t\tprintk(\"%sPC is imprecise\\n\", pfx);\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_RESTARTABLE_PC) {\n\t\trestartable_pc = ((error_info >> CPER_ARM_ERR_RESTARTABLE_PC_SHIFT)\n\t\t\t\t  & CPER_ARM_ERR_RESTARTABLE_PC_MASK);\n\t\tif (restartable_pc)\n\t\t\tprintk(\"%sProgram execution can be restarted reliably at the PC associated with the error.\\n\", pfx);\n\t}\n\n\t \n\tif (type != CPER_ARM_BUS_ERROR)\n\t\treturn;\n\n\tif (error_info & CPER_ARM_ERR_VALID_PARTICIPATION_TYPE) {\n\t\tparticipation_type = ((error_info >> CPER_ARM_ERR_PARTICIPATION_TYPE_SHIFT)\n\t\t\t\t      & CPER_ARM_ERR_PARTICIPATION_TYPE_MASK);\n\t\tif (participation_type < ARRAY_SIZE(arm_bus_err_part_type_strs)) {\n\t\t\tprintk(\"%sparticipation type: %s\\n\", pfx,\n\t\t\t       arm_bus_err_part_type_strs[participation_type]);\n\t\t}\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_TIME_OUT) {\n\t\ttime_out = ((error_info >> CPER_ARM_ERR_TIME_OUT_SHIFT)\n\t\t\t    & CPER_ARM_ERR_TIME_OUT_MASK);\n\t\tif (time_out)\n\t\t\tprintk(\"%srequest timed out\\n\", pfx);\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_ADDRESS_SPACE) {\n\t\taddress_space = ((error_info >> CPER_ARM_ERR_ADDRESS_SPACE_SHIFT)\n\t\t\t\t & CPER_ARM_ERR_ADDRESS_SPACE_MASK);\n\t\tif (address_space < ARRAY_SIZE(arm_bus_err_addr_space_strs)) {\n\t\t\tprintk(\"%saddress space: %s\\n\", pfx,\n\t\t\t       arm_bus_err_addr_space_strs[address_space]);\n\t\t}\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_MEM_ATTRIBUTES) {\n\t\tmem_attributes = ((error_info >> CPER_ARM_ERR_MEM_ATTRIBUTES_SHIFT)\n\t\t\t\t  & CPER_ARM_ERR_MEM_ATTRIBUTES_MASK);\n\t\tprintk(\"%smemory access attributes:0x%x\\n\", pfx, mem_attributes);\n\t}\n\n\tif (error_info & CPER_ARM_ERR_VALID_ACCESS_MODE) {\n\t\taccess_mode = ((error_info >> CPER_ARM_ERR_ACCESS_MODE_SHIFT)\n\t\t\t       & CPER_ARM_ERR_ACCESS_MODE_MASK);\n\t\tif (access_mode)\n\t\t\tprintk(\"%saccess mode: normal\\n\", pfx);\n\t\telse\n\t\t\tprintk(\"%saccess mode: secure\\n\", pfx);\n\t}\n}\n\nvoid cper_print_proc_arm(const char *pfx,\n\t\t\t const struct cper_sec_proc_arm *proc)\n{\n\tint i, len, max_ctx_type;\n\tstruct cper_arm_err_info *err_info;\n\tstruct cper_arm_ctx_info *ctx_info;\n\tchar newpfx[64], infopfx[64];\n\n\tprintk(\"%sMIDR: 0x%016llx\\n\", pfx, proc->midr);\n\n\tlen = proc->section_length - (sizeof(*proc) +\n\t\tproc->err_info_num * (sizeof(*err_info)));\n\tif (len < 0) {\n\t\tprintk(\"%ssection length: %d\\n\", pfx, proc->section_length);\n\t\tprintk(\"%ssection length is too small\\n\", pfx);\n\t\tprintk(\"%sfirmware-generated error record is incorrect\\n\", pfx);\n\t\tprintk(\"%sERR_INFO_NUM is %d\\n\", pfx, proc->err_info_num);\n\t\treturn;\n\t}\n\n\tif (proc->validation_bits & CPER_ARM_VALID_MPIDR)\n\t\tprintk(\"%sMultiprocessor Affinity Register (MPIDR): 0x%016llx\\n\",\n\t\t\tpfx, proc->mpidr);\n\n\tif (proc->validation_bits & CPER_ARM_VALID_AFFINITY_LEVEL)\n\t\tprintk(\"%serror affinity level: %d\\n\", pfx,\n\t\t\tproc->affinity_level);\n\n\tif (proc->validation_bits & CPER_ARM_VALID_RUNNING_STATE) {\n\t\tprintk(\"%srunning state: 0x%x\\n\", pfx, proc->running_state);\n\t\tprintk(\"%sPower State Coordination Interface state: %d\\n\",\n\t\t\tpfx, proc->psci_state);\n\t}\n\n\tsnprintf(newpfx, sizeof(newpfx), \"%s \", pfx);\n\n\terr_info = (struct cper_arm_err_info *)(proc + 1);\n\tfor (i = 0; i < proc->err_info_num; i++) {\n\t\tprintk(\"%sError info structure %d:\\n\", pfx, i);\n\n\t\tprintk(\"%snum errors: %d\\n\", pfx, err_info->multiple_error + 1);\n\n\t\tif (err_info->validation_bits & CPER_ARM_INFO_VALID_FLAGS) {\n\t\t\tif (err_info->flags & CPER_ARM_INFO_FLAGS_FIRST)\n\t\t\t\tprintk(\"%sfirst error captured\\n\", newpfx);\n\t\t\tif (err_info->flags & CPER_ARM_INFO_FLAGS_LAST)\n\t\t\t\tprintk(\"%slast error captured\\n\", newpfx);\n\t\t\tif (err_info->flags & CPER_ARM_INFO_FLAGS_PROPAGATED)\n\t\t\t\tprintk(\"%spropagated error captured\\n\",\n\t\t\t\t       newpfx);\n\t\t\tif (err_info->flags & CPER_ARM_INFO_FLAGS_OVERFLOW)\n\t\t\t\tprintk(\"%soverflow occurred, error info is incomplete\\n\",\n\t\t\t\t       newpfx);\n\t\t}\n\n\t\tprintk(\"%serror_type: %d, %s\\n\", newpfx, err_info->type,\n\t\t\terr_info->type < ARRAY_SIZE(cper_proc_error_type_strs) ?\n\t\t\tcper_proc_error_type_strs[err_info->type] : \"unknown\");\n\t\tif (err_info->validation_bits & CPER_ARM_INFO_VALID_ERR_INFO) {\n\t\t\tprintk(\"%serror_info: 0x%016llx\\n\", newpfx,\n\t\t\t       err_info->error_info);\n\t\t\tsnprintf(infopfx, sizeof(infopfx), \"%s \", newpfx);\n\t\t\tcper_print_arm_err_info(infopfx, err_info->type,\n\t\t\t\t\t\terr_info->error_info);\n\t\t}\n\t\tif (err_info->validation_bits & CPER_ARM_INFO_VALID_VIRT_ADDR)\n\t\t\tprintk(\"%svirtual fault address: 0x%016llx\\n\",\n\t\t\t\tnewpfx, err_info->virt_fault_addr);\n\t\tif (err_info->validation_bits & CPER_ARM_INFO_VALID_PHYSICAL_ADDR)\n\t\t\tprintk(\"%sphysical fault address: 0x%016llx\\n\",\n\t\t\t\tnewpfx, err_info->physical_fault_addr);\n\t\terr_info += 1;\n\t}\n\n\tctx_info = (struct cper_arm_ctx_info *)err_info;\n\tmax_ctx_type = ARRAY_SIZE(arm_reg_ctx_strs) - 1;\n\tfor (i = 0; i < proc->context_info_num; i++) {\n\t\tint size = sizeof(*ctx_info) + ctx_info->size;\n\n\t\tprintk(\"%sContext info structure %d:\\n\", pfx, i);\n\t\tif (len < size) {\n\t\t\tprintk(\"%ssection length is too small\\n\", newpfx);\n\t\t\tprintk(\"%sfirmware-generated error record is incorrect\\n\", pfx);\n\t\t\treturn;\n\t\t}\n\t\tif (ctx_info->type > max_ctx_type) {\n\t\t\tprintk(\"%sInvalid context type: %d (max: %d)\\n\",\n\t\t\t\tnewpfx, ctx_info->type, max_ctx_type);\n\t\t\treturn;\n\t\t}\n\t\tprintk(\"%sregister context type: %s\\n\", newpfx,\n\t\t\tarm_reg_ctx_strs[ctx_info->type]);\n\t\tprint_hex_dump(newpfx, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t\t\t(ctx_info + 1), ctx_info->size, 0);\n\t\tlen -= size;\n\t\tctx_info = (struct cper_arm_ctx_info *)((long)ctx_info + size);\n\t}\n\n\tif (len > 0) {\n\t\tprintk(\"%sVendor specific error info has %u bytes:\\n\", pfx,\n\t\t       len);\n\t\tprint_hex_dump(newpfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, ctx_info,\n\t\t\t\tlen, true);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}