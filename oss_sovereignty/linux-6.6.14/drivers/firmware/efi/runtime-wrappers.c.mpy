{
  "module_name": "runtime-wrappers.c",
  "hash_id": "9db96608dea2aa5c788122742283fb32fb7878b3a9bd78fffb40a89fe00d1442",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/runtime-wrappers.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"efi: \" fmt\n\n#include <linux/bug.h>\n#include <linux/efi.h>\n#include <linux/irqflags.h>\n#include <linux/mutex.h>\n#include <linux/semaphore.h>\n#include <linux/stringify.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n\n#include <asm/efi.h>\n\n \n#define efi_call_virt(f, args...)   \\\n\tarch_efi_call_virt(efi.runtime, f, args)\n\nunion efi_rts_args {\n\tstruct {\n\t\tefi_time_t \t*time;\n\t\tefi_time_cap_t\t*capabilities;\n\t} GET_TIME;\n\n\tstruct {\n\t\tefi_time_t\t*time;\n\t} SET_TIME;\n\n\tstruct {\n\t\tefi_bool_t\t*enabled;\n\t\tefi_bool_t\t*pending;\n\t\tefi_time_t\t*time;\n\t} GET_WAKEUP_TIME;\n\n\tstruct {\n\t\tefi_bool_t\tenable;\n\t\tefi_time_t\t*time;\n\t} SET_WAKEUP_TIME;\n\n\tstruct {\n\t\tefi_char16_t\t*name;\n\t\tefi_guid_t\t*vendor;\n\t\tu32\t\t*attr;\n\t\tunsigned long\t*data_size;\n\t\tvoid\t\t*data;\n\t} GET_VARIABLE;\n\n\tstruct {\n\t\tunsigned long\t*name_size;\n\t\tefi_char16_t\t*name;\n\t\tefi_guid_t \t*vendor;\n\t} GET_NEXT_VARIABLE;\n\n\tstruct {\n\t\tefi_char16_t\t*name;\n\t\tefi_guid_t\t*vendor;\n\t\tu32\t\tattr;\n\t\tunsigned long\tdata_size;\n\t\tvoid\t\t*data;\n\t} SET_VARIABLE;\n\n\tstruct {\n\t\tu32\t\tattr;\n\t\tu64\t\t*storage_space;\n\t\tu64\t\t*remaining_space;\n\t\tu64\t\t*max_variable_size;\n\t} QUERY_VARIABLE_INFO;\n\n\tstruct {\n\t\tu32\t\t*high_count;\n\t} GET_NEXT_HIGH_MONO_COUNT;\n\n\tstruct {\n\t\tefi_capsule_header_t **capsules;\n\t\tunsigned long\tcount;\n\t\tunsigned long\tsg_list;\n\t} UPDATE_CAPSULE;\n\n\tstruct {\n\t\tefi_capsule_header_t **capsules;\n\t\tunsigned long\tcount;\n\t\tu64\t\t*max_size;\n\t\tint\t\t*reset_type;\n\t} QUERY_CAPSULE_CAPS;\n\n\tstruct {\n\t\tefi_status_t\t(__efiapi *acpi_prm_handler)(u64, void *);\n\t\tu64\t\tparam_buffer_addr;\n\t\tvoid\t\t*context;\n\t} ACPI_PRM_HANDLER;\n};\n\nstruct efi_runtime_work efi_rts_work;\n\n \n#define efi_queue_work(_rts, _args...)\t\t\t\t\t\\\n\t__efi_queue_work(EFI_ ## _rts,\t\t\t\t\t\\\n\t\t\t &(union efi_rts_args){ ._rts = { _args }})\n\n#ifndef arch_efi_save_flags\n#define arch_efi_save_flags(state_flags)\tlocal_save_flags(state_flags)\n#define arch_efi_restore_flags(state_flags)\tlocal_irq_restore(state_flags)\n#endif\n\nunsigned long efi_call_virt_save_flags(void)\n{\n\tunsigned long flags;\n\n\tarch_efi_save_flags(flags);\n\treturn flags;\n}\n\nvoid efi_call_virt_check_flags(unsigned long flags, const void *caller)\n{\n\tunsigned long cur_flags, mismatch;\n\n\tcur_flags = efi_call_virt_save_flags();\n\n\tmismatch = flags ^ cur_flags;\n\tif (!WARN_ON_ONCE(mismatch & ARCH_EFI_IRQ_FLAGS_MASK))\n\t\treturn;\n\n\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_NOW_UNRELIABLE);\n\tpr_err_ratelimited(FW_BUG \"IRQ flags corrupted (0x%08lx=>0x%08lx) by EFI call from %pS\\n\",\n\t\t\t   flags, cur_flags, caller ?: __builtin_return_address(0));\n\tarch_efi_restore_flags(flags);\n}\n\n \nstatic DEFINE_SEMAPHORE(efi_runtime_lock, 1);\n\n \n#ifdef CONFIG_X86_UV\nextern struct semaphore __efi_uv_runtime_lock __alias(efi_runtime_lock);\n#endif\n\n \nstatic void efi_call_rts(struct work_struct *work)\n{\n\tconst union efi_rts_args *args = efi_rts_work.args;\n\tefi_status_t status = EFI_NOT_FOUND;\n\tunsigned long flags;\n\n\tarch_efi_call_virt_setup();\n\tflags = efi_call_virt_save_flags();\n\n\tswitch (efi_rts_work.efi_rts_id) {\n\tcase EFI_GET_TIME:\n\t\tstatus = efi_call_virt(get_time,\n\t\t\t\t       args->GET_TIME.time,\n\t\t\t\t       args->GET_TIME.capabilities);\n\t\tbreak;\n\tcase EFI_SET_TIME:\n\t\tstatus = efi_call_virt(set_time,\n\t\t\t\t       args->SET_TIME.time);\n\t\tbreak;\n\tcase EFI_GET_WAKEUP_TIME:\n\t\tstatus = efi_call_virt(get_wakeup_time,\n\t\t\t\t       args->GET_WAKEUP_TIME.enabled,\n\t\t\t\t       args->GET_WAKEUP_TIME.pending,\n\t\t\t\t       args->GET_WAKEUP_TIME.time);\n\t\tbreak;\n\tcase EFI_SET_WAKEUP_TIME:\n\t\tstatus = efi_call_virt(set_wakeup_time,\n\t\t\t\t       args->SET_WAKEUP_TIME.enable,\n\t\t\t\t       args->SET_WAKEUP_TIME.time);\n\t\tbreak;\n\tcase EFI_GET_VARIABLE:\n\t\tstatus = efi_call_virt(get_variable,\n\t\t\t\t       args->GET_VARIABLE.name,\n\t\t\t\t       args->GET_VARIABLE.vendor,\n\t\t\t\t       args->GET_VARIABLE.attr,\n\t\t\t\t       args->GET_VARIABLE.data_size,\n\t\t\t\t       args->GET_VARIABLE.data);\n\t\tbreak;\n\tcase EFI_GET_NEXT_VARIABLE:\n\t\tstatus = efi_call_virt(get_next_variable,\n\t\t\t\t       args->GET_NEXT_VARIABLE.name_size,\n\t\t\t\t       args->GET_NEXT_VARIABLE.name,\n\t\t\t\t       args->GET_NEXT_VARIABLE.vendor);\n\t\tbreak;\n\tcase EFI_SET_VARIABLE:\n\t\tstatus = efi_call_virt(set_variable,\n\t\t\t\t       args->SET_VARIABLE.name,\n\t\t\t\t       args->SET_VARIABLE.vendor,\n\t\t\t\t       args->SET_VARIABLE.attr,\n\t\t\t\t       args->SET_VARIABLE.data_size,\n\t\t\t\t       args->SET_VARIABLE.data);\n\t\tbreak;\n\tcase EFI_QUERY_VARIABLE_INFO:\n\t\tstatus = efi_call_virt(query_variable_info,\n\t\t\t\t       args->QUERY_VARIABLE_INFO.attr,\n\t\t\t\t       args->QUERY_VARIABLE_INFO.storage_space,\n\t\t\t\t       args->QUERY_VARIABLE_INFO.remaining_space,\n\t\t\t\t       args->QUERY_VARIABLE_INFO.max_variable_size);\n\t\tbreak;\n\tcase EFI_GET_NEXT_HIGH_MONO_COUNT:\n\t\tstatus = efi_call_virt(get_next_high_mono_count,\n\t\t\t\t       args->GET_NEXT_HIGH_MONO_COUNT.high_count);\n\t\tbreak;\n\tcase EFI_UPDATE_CAPSULE:\n\t\tstatus = efi_call_virt(update_capsule,\n\t\t\t\t       args->UPDATE_CAPSULE.capsules,\n\t\t\t\t       args->UPDATE_CAPSULE.count,\n\t\t\t\t       args->UPDATE_CAPSULE.sg_list);\n\t\tbreak;\n\tcase EFI_QUERY_CAPSULE_CAPS:\n\t\tstatus = efi_call_virt(query_capsule_caps,\n\t\t\t\t       args->QUERY_CAPSULE_CAPS.capsules,\n\t\t\t\t       args->QUERY_CAPSULE_CAPS.count,\n\t\t\t\t       args->QUERY_CAPSULE_CAPS.max_size,\n\t\t\t\t       args->QUERY_CAPSULE_CAPS.reset_type);\n\t\tbreak;\n\tcase EFI_ACPI_PRM_HANDLER:\n#ifdef CONFIG_ACPI_PRMT\n\t\tstatus = arch_efi_call_virt(args, ACPI_PRM_HANDLER.acpi_prm_handler,\n\t\t\t\t\t    args->ACPI_PRM_HANDLER.param_buffer_addr,\n\t\t\t\t\t    args->ACPI_PRM_HANDLER.context);\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\tpr_err(\"Requested executing invalid EFI Runtime Service.\\n\");\n\t}\n\n\tefi_call_virt_check_flags(flags, efi_rts_work.caller);\n\tarch_efi_call_virt_teardown();\n\n\tefi_rts_work.status = status;\n\tcomplete(&efi_rts_work.efi_rts_comp);\n}\n\nstatic efi_status_t __efi_queue_work(enum efi_rts_ids id,\n\t\t\t\t     union efi_rts_args *args)\n{\n\tefi_rts_work.efi_rts_id = id;\n\tefi_rts_work.args = args;\n\tefi_rts_work.caller = __builtin_return_address(0);\n\tefi_rts_work.status = EFI_ABORTED;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES)) {\n\t\tpr_warn_once(\"EFI Runtime Services are disabled!\\n\");\n\t\tefi_rts_work.status = EFI_DEVICE_ERROR;\n\t\tgoto exit;\n\t}\n\n\tinit_completion(&efi_rts_work.efi_rts_comp);\n\tINIT_WORK(&efi_rts_work.work, efi_call_rts);\n\n\t \n\tif (queue_work(efi_rts_wq, &efi_rts_work.work))\n\t\twait_for_completion(&efi_rts_work.efi_rts_comp);\n\telse\n\t\tpr_err(\"Failed to queue work to efi_rts_wq.\\n\");\n\n\tWARN_ON_ONCE(efi_rts_work.status == EFI_ABORTED);\nexit:\n\tefi_rts_work.efi_rts_id = EFI_NONE;\n\treturn efi_rts_work.status;\n}\n\nstatic efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(GET_TIME, tm, tc);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_set_time(efi_time_t *tm)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(SET_TIME, tm);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,\n\t\t\t\t\t     efi_bool_t *pending,\n\t\t\t\t\t     efi_time_t *tm)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(GET_WAKEUP_TIME, enabled, pending, tm);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(SET_WAKEUP_TIME, enabled, tm);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_get_variable(efi_char16_t *name,\n\t\t\t\t\t  efi_guid_t *vendor,\n\t\t\t\t\t  u32 *attr,\n\t\t\t\t\t  unsigned long *data_size,\n\t\t\t\t\t  void *data)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(GET_VARIABLE, name, vendor, attr, data_size,\n\t\t\t\tdata);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_get_next_variable(unsigned long *name_size,\n\t\t\t\t\t       efi_char16_t *name,\n\t\t\t\t\t       efi_guid_t *vendor)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(GET_NEXT_VARIABLE, name_size, name, vendor);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_set_variable(efi_char16_t *name,\n\t\t\t\t\t  efi_guid_t *vendor,\n\t\t\t\t\t  u32 attr,\n\t\t\t\t\t  unsigned long data_size,\n\t\t\t\t\t  void *data)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(SET_VARIABLE, name, vendor, attr, data_size,\n\t\t\t\tdata);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t\nvirt_efi_set_variable_nb(efi_char16_t *name, efi_guid_t *vendor, u32 attr,\n\t\t\t unsigned long data_size, void *data)\n{\n\tefi_status_t status;\n\n\tif (down_trylock(&efi_runtime_lock))\n\t\treturn EFI_NOT_READY;\n\n\tstatus = efi_call_virt_pointer(efi.runtime, set_variable, name, vendor,\n\t\t\t\t       attr, data_size, data);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\n\nstatic efi_status_t virt_efi_query_variable_info(u32 attr,\n\t\t\t\t\t\t u64 *storage_space,\n\t\t\t\t\t\t u64 *remaining_space,\n\t\t\t\t\t\t u64 *max_variable_size)\n{\n\tefi_status_t status;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(QUERY_VARIABLE_INFO, attr, storage_space,\n\t\t\t\tremaining_space, max_variable_size);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t\nvirt_efi_query_variable_info_nb(u32 attr, u64 *storage_space,\n\t\t\t\tu64 *remaining_space, u64 *max_variable_size)\n{\n\tefi_status_t status;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (down_trylock(&efi_runtime_lock))\n\t\treturn EFI_NOT_READY;\n\n\tstatus = efi_call_virt_pointer(efi.runtime, query_variable_info, attr,\n\t\t\t\t       storage_space, remaining_space,\n\t\t\t\t       max_variable_size);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_get_next_high_mono_count(u32 *count)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(GET_NEXT_HIGH_MONO_COUNT, count);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic void virt_efi_reset_system(int reset_type,\n\t\t\t\t  efi_status_t status,\n\t\t\t\t  unsigned long data_size,\n\t\t\t\t  efi_char16_t *data)\n{\n\tif (down_trylock(&efi_runtime_lock)) {\n\t\tpr_warn(\"failed to invoke the reset_system() runtime service:\\n\"\n\t\t\t\"could not get exclusive access to the firmware\\n\");\n\t\treturn;\n\t}\n\n\tarch_efi_call_virt_setup();\n\tefi_rts_work.efi_rts_id = EFI_RESET_SYSTEM;\n\tarch_efi_call_virt(efi.runtime, reset_system, reset_type, status,\n\t\t\t   data_size, data);\n\tarch_efi_call_virt_teardown();\n\n\tup(&efi_runtime_lock);\n}\n\nstatic efi_status_t virt_efi_update_capsule(efi_capsule_header_t **capsules,\n\t\t\t\t\t    unsigned long count,\n\t\t\t\t\t    unsigned long sg_list)\n{\n\tefi_status_t status;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(UPDATE_CAPSULE, capsules, count, sg_list);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nstatic efi_status_t virt_efi_query_capsule_caps(efi_capsule_header_t **capsules,\n\t\t\t\t\t\tunsigned long count,\n\t\t\t\t\t\tu64 *max_size,\n\t\t\t\t\t\tint *reset_type)\n{\n\tefi_status_t status;\n\n\tif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\n\t\treturn EFI_UNSUPPORTED;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(QUERY_CAPSULE_CAPS, capsules, count,\n\t\t\t\tmax_size, reset_type);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\nvoid __init efi_native_runtime_setup(void)\n{\n\tefi.get_time\t\t\t    = virt_efi_get_time;\n\tefi.set_time\t\t\t    = virt_efi_set_time;\n\tefi.get_wakeup_time\t\t    = virt_efi_get_wakeup_time;\n\tefi.set_wakeup_time\t\t    = virt_efi_set_wakeup_time;\n\tefi.get_variable\t\t    = virt_efi_get_variable;\n\tefi.get_next_variable\t\t    = virt_efi_get_next_variable;\n\tefi.set_variable\t\t    = virt_efi_set_variable;\n\tefi.set_variable_nonblocking\t    = virt_efi_set_variable_nb;\n\tefi.get_next_high_mono_count\t    = virt_efi_get_next_high_mono_count;\n\tefi.reset_system \t\t    = virt_efi_reset_system;\n\tefi.query_variable_info\t\t    = virt_efi_query_variable_info;\n\tefi.query_variable_info_nonblocking = virt_efi_query_variable_info_nb;\n\tefi.update_capsule\t\t    = virt_efi_update_capsule;\n\tefi.query_capsule_caps\t\t    = virt_efi_query_capsule_caps;\n}\n\n#ifdef CONFIG_ACPI_PRMT\n\nefi_status_t\nefi_call_acpi_prm_handler(efi_status_t (__efiapi *handler_addr)(u64, void *),\n\t\t\t  u64 param_buffer_addr, void *context)\n{\n\tefi_status_t status;\n\n\tif (down_interruptible(&efi_runtime_lock))\n\t\treturn EFI_ABORTED;\n\tstatus = efi_queue_work(ACPI_PRM_HANDLER, handler_addr,\n\t\t\t\tparam_buffer_addr, context);\n\tup(&efi_runtime_lock);\n\treturn status;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}