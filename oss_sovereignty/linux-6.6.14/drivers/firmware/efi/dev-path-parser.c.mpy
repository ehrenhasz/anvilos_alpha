{
  "module_name": "dev-path-parser.c",
  "hash_id": "2cfd290e8d336f4aabd6e52ab9e01db141ac0a8d9267a102fc4d2c8c7e39cec5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/dev-path-parser.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/efi.h>\n#include <linux/pci.h>\n\nstatic long __init parse_acpi_path(const struct efi_dev_path *node,\n\t\t\t\t   struct device *parent, struct device **child)\n{\n\tstruct acpi_device *adev;\n\tstruct device *phys_dev;\n\tchar hid[ACPI_ID_LEN];\n\tu64 uid;\n\tint ret;\n\n\tif (node->header.length != 12)\n\t\treturn -EINVAL;\n\n\tsprintf(hid, \"%c%c%c%04X\",\n\t\t'A' + ((node->acpi.hid >> 10) & 0x1f) - 1,\n\t\t'A' + ((node->acpi.hid >>  5) & 0x1f) - 1,\n\t\t'A' + ((node->acpi.hid >>  0) & 0x1f) - 1,\n\t\t\tnode->acpi.hid >> 16);\n\n\tfor_each_acpi_dev_match(adev, hid, NULL, -1) {\n\t\tret = acpi_dev_uid_to_integer(adev, &uid);\n\t\tif (ret == 0 && node->acpi.uid == uid)\n\t\t\tbreak;\n\t\tif (ret == -ENODATA && node->acpi.uid == 0)\n\t\t\tbreak;\n\t}\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tphys_dev = acpi_get_first_physical_node(adev);\n\tif (phys_dev) {\n\t\t*child = get_device(phys_dev);\n\t\tacpi_dev_put(adev);\n\t} else\n\t\t*child = &adev->dev;\n\n\treturn 0;\n}\n\nstatic int __init match_pci_dev(struct device *dev, void *data)\n{\n\tunsigned int devfn = *(unsigned int *)data;\n\n\treturn dev_is_pci(dev) && to_pci_dev(dev)->devfn == devfn;\n}\n\nstatic long __init parse_pci_path(const struct efi_dev_path *node,\n\t\t\t\t  struct device *parent, struct device **child)\n{\n\tunsigned int devfn;\n\n\tif (node->header.length != 6)\n\t\treturn -EINVAL;\n\tif (!parent)\n\t\treturn -EINVAL;\n\n\tdevfn = PCI_DEVFN(node->pci.dev, node->pci.fn);\n\n\t*child = device_find_child(parent, &devfn, match_pci_dev);\n\tif (!*child)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \n\nstatic long __init parse_end_path(const struct efi_dev_path *node,\n\t\t\t\t  struct device *parent, struct device **child)\n{\n\tif (node->header.length != 4)\n\t\treturn -EINVAL;\n\tif (node->header.sub_type != EFI_DEV_END_INSTANCE &&\n\t    node->header.sub_type != EFI_DEV_END_ENTIRE)\n\t\treturn -EINVAL;\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\t*child = get_device(parent);\n\treturn node->header.sub_type;\n}\n\n \nstruct device * __init efi_get_device_by_path(const struct efi_dev_path **node,\n\t\t\t\t\t      size_t *len)\n{\n\tstruct device *parent = NULL, *child;\n\tlong ret = 0;\n\n\tif (!*len)\n\t\treturn NULL;\n\n\twhile (!ret) {\n\t\tif (*len < 4 || *len < (*node)->header.length)\n\t\t\tret = -EINVAL;\n\t\telse if ((*node)->header.type\t\t== EFI_DEV_ACPI &&\n\t\t\t (*node)->header.sub_type\t== EFI_DEV_BASIC_ACPI)\n\t\t\tret = parse_acpi_path(*node, parent, &child);\n\t\telse if ((*node)->header.type\t\t== EFI_DEV_HW &&\n\t\t\t (*node)->header.sub_type\t== EFI_DEV_PCI)\n\t\t\tret = parse_pci_path(*node, parent, &child);\n\t\telse if (((*node)->header.type\t\t== EFI_DEV_END_PATH ||\n\t\t\t  (*node)->header.type\t\t== EFI_DEV_END_PATH2))\n\t\t\tret = parse_end_path(*node, parent, &child);\n\t\telse\n\t\t\tret = -ENOTSUPP;\n\n\t\tput_device(parent);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tparent = child;\n\t\t*node  = (void *)*node + (*node)->header.length;\n\t\t*len  -= (*node)->header.length;\n\t}\n\n\tif (ret == EFI_DEV_END_ENTIRE)\n\t\t*len = 0;\n\n\treturn child;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}