{
  "module_name": "earlycon.c",
  "hash_id": "669869516d29bb5a850f724c483b6094ec4cd247fa509a4dc6e82131075546a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/earlycon.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/efi.h>\n#include <linux/font.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/serial_core.h>\n#include <linux/screen_info.h>\n#include <linux/string.h>\n\n#include <asm/early_ioremap.h>\n\nstatic const struct console *earlycon_console __initdata;\nstatic const struct font_desc *font;\nstatic u16 cur_line_y, max_line_y;\nstatic u32 efi_x_array[1024];\nstatic u32 efi_x, efi_y;\nstatic u64 fb_base;\nstatic bool fb_wb;\nstatic void *efi_fb;\n\n \nstatic int __init efi_earlycon_remap_fb(void)\n{\n\t \n\tif (!earlycon_console || !console_is_registered(earlycon_console))\n\t\treturn 0;\n\n\tefi_fb = memremap(fb_base, screen_info.lfb_size,\n\t\t\t  fb_wb ? MEMREMAP_WB : MEMREMAP_WC);\n\n\treturn efi_fb ? 0 : -ENOMEM;\n}\nearly_initcall(efi_earlycon_remap_fb);\n\nstatic int __init efi_earlycon_unmap_fb(void)\n{\n\t \n\tif (efi_fb && !console_is_registered(earlycon_console))\n\t\tmemunmap(efi_fb);\n\treturn 0;\n}\nlate_initcall(efi_earlycon_unmap_fb);\n\nstatic __ref void *efi_earlycon_map(unsigned long start, unsigned long len)\n{\n\tpgprot_t fb_prot;\n\n\tif (efi_fb)\n\t\treturn efi_fb + start;\n\n\tfb_prot = fb_wb ? PAGE_KERNEL : pgprot_writecombine(PAGE_KERNEL);\n\treturn early_memremap_prot(fb_base + start, len, pgprot_val(fb_prot));\n}\n\nstatic __ref void efi_earlycon_unmap(void *addr, unsigned long len)\n{\n\tif (efi_fb)\n\t\treturn;\n\n\tearly_memunmap(addr, len);\n}\n\nstatic void efi_earlycon_clear_scanline(unsigned int y)\n{\n\tunsigned long *dst;\n\tu16 len;\n\n\tlen = screen_info.lfb_linelength;\n\tdst = efi_earlycon_map(y*len, len);\n\tif (!dst)\n\t\treturn;\n\n\tmemset(dst, 0, len);\n\tefi_earlycon_unmap(dst, len);\n}\n\nstatic void efi_earlycon_scroll_up(void)\n{\n\tunsigned long *dst, *src;\n\tu16 maxlen = 0;\n\tu16 len;\n\tu32 i, height;\n\n\t \n\tfor (i = 0; i < max_line_y; i++) {\n\t\tif (efi_x_array[i] > maxlen)\n\t\t\tmaxlen = efi_x_array[i];\n\t}\n\tmaxlen *= 4;\n\n\tlen = screen_info.lfb_linelength;\n\theight = screen_info.lfb_height;\n\n\tfor (i = 0; i < height - font->height; i++) {\n\t\tdst = efi_earlycon_map(i*len, len);\n\t\tif (!dst)\n\t\t\treturn;\n\n\t\tsrc = efi_earlycon_map((i + font->height) * len, len);\n\t\tif (!src) {\n\t\t\tefi_earlycon_unmap(dst, len);\n\t\t\treturn;\n\t\t}\n\n\t\tmemmove(dst, src, maxlen);\n\n\t\tefi_earlycon_unmap(src, len);\n\t\tefi_earlycon_unmap(dst, len);\n\t}\n}\n\nstatic void efi_earlycon_write_char(u32 *dst, unsigned char c, unsigned int h)\n{\n\tconst u32 color_black = 0x00000000;\n\tconst u32 color_white = 0x00ffffff;\n\tconst u8 *src;\n\tint m, n, bytes;\n\tu8 x;\n\n\tbytes = BITS_TO_BYTES(font->width);\n\tsrc = font->data + c * font->height * bytes + h * bytes;\n\n\tfor (m = 0; m < font->width; m++) {\n\t\tn = m % 8;\n\t\tx = *(src + m / 8);\n\t\tif ((x >> (7 - n)) & 1)\n\t\t\t*dst = color_white;\n\t\telse\n\t\t\t*dst = color_black;\n\t\tdst++;\n\t}\n}\n\nstatic void\nefi_earlycon_write(struct console *con, const char *str, unsigned int num)\n{\n\tstruct screen_info *si;\n\tu32 cur_efi_x = efi_x;\n\tunsigned int len;\n\tconst char *s;\n\tvoid *dst;\n\n\tsi = &screen_info;\n\tlen = si->lfb_linelength;\n\n\twhile (num) {\n\t\tunsigned int linemax = (si->lfb_width - efi_x) / font->width;\n\t\tunsigned int h, count;\n\n\t\tcount = strnchrnul(str, num, '\\n') - str;\n\t\tif (count > linemax)\n\t\t\tcount = linemax;\n\n\t\tfor (h = 0; h < font->height; h++) {\n\t\t\tunsigned int n, x;\n\n\t\t\tdst = efi_earlycon_map((efi_y + h) * len, len);\n\t\t\tif (!dst)\n\t\t\t\treturn;\n\n\t\t\ts = str;\n\t\t\tn = count;\n\t\t\tx = efi_x;\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tefi_earlycon_write_char(dst + x*4, *s, h);\n\t\t\t\tx += font->width;\n\t\t\t\ts++;\n\t\t\t}\n\n\t\t\tefi_earlycon_unmap(dst, len);\n\t\t}\n\n\t\tnum -= count;\n\t\tefi_x += count * font->width;\n\t\tstr += count;\n\n\t\tif (num > 0 && *s == '\\n') {\n\t\t\tcur_efi_x = efi_x;\n\t\t\tefi_x = 0;\n\t\t\tefi_y += font->height;\n\t\t\tstr++;\n\t\t\tnum--;\n\t\t}\n\n\t\tif (efi_x + font->width > si->lfb_width) {\n\t\t\tcur_efi_x = efi_x;\n\t\t\tefi_x = 0;\n\t\t\tefi_y += font->height;\n\t\t}\n\n\t\tif (efi_y + font->height > si->lfb_height) {\n\t\t\tu32 i;\n\n\t\t\tefi_x_array[cur_line_y] = cur_efi_x;\n\t\t\tcur_line_y = (cur_line_y + 1) % max_line_y;\n\n\t\t\tefi_y -= font->height;\n\t\t\tefi_earlycon_scroll_up();\n\n\t\t\tfor (i = 0; i < font->height; i++)\n\t\t\t\tefi_earlycon_clear_scanline(efi_y + i);\n\t\t}\n\t}\n}\n\nstatic bool __initdata fb_probed;\n\nvoid __init efi_earlycon_reprobe(void)\n{\n\tif (fb_probed)\n\t\tsetup_earlycon(\"efifb\");\n}\n\nstatic int __init efi_earlycon_setup(struct earlycon_device *device,\n\t\t\t\t     const char *opt)\n{\n\tstruct screen_info *si;\n\tu16 xres, yres;\n\tu32 i;\n\n\tfb_wb = opt && !strcmp(opt, \"ram\");\n\n\tif (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI) {\n\t\tfb_probed = true;\n\t\treturn -ENODEV;\n\t}\n\n\tfb_base = screen_info.lfb_base;\n\tif (screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE)\n\t\tfb_base |= (u64)screen_info.ext_lfb_base << 32;\n\n\tsi = &screen_info;\n\txres = si->lfb_width;\n\tyres = si->lfb_height;\n\n\t \n\tif (si->lfb_depth != 32)\n\t\treturn -ENODEV;\n\n\tfont = get_default_font(xres, yres, -1, -1);\n\tif (!font)\n\t\treturn -ENODEV;\n\n\t \n\tmemset32(efi_x_array, rounddown(xres, font->width), ARRAY_SIZE(efi_x_array));\n\tefi_y = rounddown(yres, font->height);\n\n\t \n\tmax_line_y = efi_y / font->height + 1;\n\tcur_line_y = 0;\n\n\tefi_y -= font->height;\n\tfor (i = 0; i < (yres - efi_y) / font->height; i++)\n\t\tefi_earlycon_scroll_up();\n\n\tdevice->con->write = efi_earlycon_write;\n\tearlycon_console = device->con;\n\treturn 0;\n}\nEARLYCON_DECLARE(efifb, efi_earlycon_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}