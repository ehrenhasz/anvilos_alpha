{
  "module_name": "fdtparams.c",
  "hash_id": "9f4b293b2a1a2efe4a8ab8229a1b0273e2b4fbac4896f9039e1d7b9e2e079999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/fdtparams.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/efi.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n\n#include <asm/unaligned.h>\n\nenum {\n\tSYSTAB,\n\tMMBASE,\n\tMMSIZE,\n\tDCSIZE,\n\tDCVERS,\n\n\tPARAMCOUNT\n};\n\nstatic __initconst const char name[][22] = {\n\t[SYSTAB] = \"System Table         \",\n\t[MMBASE] = \"MemMap Address       \",\n\t[MMSIZE] = \"MemMap Size          \",\n\t[DCSIZE] = \"MemMap Desc. Size    \",\n\t[DCVERS] = \"MemMap Desc. Version \",\n};\n\nstatic __initconst const struct {\n\tconst char\tpath[17];\n\tu8\t\tparavirt;\n\tconst char\tparams[PARAMCOUNT][26];\n} dt_params[] = {\n\t{\n#ifdef CONFIG_XEN    \n\t\t.path = \"/hypervisor/uefi\",\n\t\t.paravirt = 1,\n\t\t.params = {\n\t\t\t[SYSTAB] = \"xen,uefi-system-table\",\n\t\t\t[MMBASE] = \"xen,uefi-mmap-start\",\n\t\t\t[MMSIZE] = \"xen,uefi-mmap-size\",\n\t\t\t[DCSIZE] = \"xen,uefi-mmap-desc-size\",\n\t\t\t[DCVERS] = \"xen,uefi-mmap-desc-ver\",\n\t\t}\n\t}, {\n#endif\n\t\t.path = \"/chosen\",\n\t\t.params = {\t\n\t\t\t[SYSTAB] = \"linux,uefi-system-table\",\n\t\t\t[MMBASE] = \"linux,uefi-mmap-start\",\n\t\t\t[MMSIZE] = \"linux,uefi-mmap-size\",\n\t\t\t[DCSIZE] = \"linux,uefi-mmap-desc-size\",\n\t\t\t[DCVERS] = \"linux,uefi-mmap-desc-ver\",\n\t\t}\n\t}\n};\n\nstatic int __init efi_get_fdt_prop(const void *fdt, int node, const char *pname,\n\t\t\t\t   const char *rname, void *var, int size)\n{\n\tconst void *prop;\n\tint len;\n\tu64 val;\n\n\tprop = fdt_getprop(fdt, node, pname, &len);\n\tif (!prop)\n\t\treturn 1;\n\n\tval = (len == 4) ? (u64)be32_to_cpup(prop) : get_unaligned_be64(prop);\n\n\tif (size == 8)\n\t\t*(u64 *)var = val;\n\telse\n\t\t*(u32 *)var = (val < U32_MAX) ? val : U32_MAX; \n\n\tif (efi_enabled(EFI_DBG))\n\t\tpr_info(\"  %s: 0x%0*llx\\n\", rname, size * 2, val);\n\n\treturn 0;\n}\n\nu64 __init efi_get_fdt_params(struct efi_memory_map_data *mm)\n{\n\tconst void *fdt = initial_boot_params;\n\tunsigned long systab;\n\tint i, j, node;\n\tstruct {\n\t\tvoid\t*var;\n\t\tint\tsize;\n\t} target[] = {\n\t\t[SYSTAB] = { &systab,\t\tsizeof(systab) },\n\t\t[MMBASE] = { &mm->phys_map,\tsizeof(mm->phys_map) },\n\t\t[MMSIZE] = { &mm->size,\t\tsizeof(mm->size) },\n\t\t[DCSIZE] = { &mm->desc_size,\tsizeof(mm->desc_size) },\n\t\t[DCVERS] = { &mm->desc_version,\tsizeof(mm->desc_version) },\n\t};\n\n\tBUILD_BUG_ON(ARRAY_SIZE(target) != ARRAY_SIZE(name));\n\tBUILD_BUG_ON(ARRAY_SIZE(target) != ARRAY_SIZE(dt_params[0].params));\n\n\tif (!fdt)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(dt_params); i++) {\n\t\tnode = fdt_path_offset(fdt, dt_params[i].path);\n\t\tif (node < 0)\n\t\t\tcontinue;\n\n\t\tif (efi_enabled(EFI_DBG))\n\t\t\tpr_info(\"Getting UEFI parameters from %s in DT:\\n\",\n\t\t\t\tdt_params[i].path);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(target); j++) {\n\t\t\tconst char *pname = dt_params[i].params[j];\n\n\t\t\tif (!efi_get_fdt_prop(fdt, node, pname, name[j],\n\t\t\t\t\t      target[j].var, target[j].size))\n\t\t\t\tcontinue;\n\t\t\tif (!j)\n\t\t\t\tgoto notfound;\n\t\t\tpr_err(\"Can't find property '%s' in DT!\\n\", pname);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dt_params[i].paravirt)\n\t\t\tset_bit(EFI_PARAVIRT, &efi.flags);\n\t\treturn systab;\n\t}\nnotfound:\n\tpr_info(\"UEFI not found.\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}