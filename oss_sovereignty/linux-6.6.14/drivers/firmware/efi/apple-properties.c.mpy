{
  "module_name": "apple-properties.c",
  "hash_id": "bef673992b171355809a352269c36ce8dc3a1a5b7c5655cddad044682a72a085",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/apple-properties.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"apple-properties: \" fmt\n\n#include <linux/memblock.h>\n#include <linux/efi.h>\n#include <linux/io.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/ucs2_string.h>\n#include <asm/setup.h>\n\nstatic bool dump_properties __initdata;\n\nstatic int __init dump_properties_enable(char *arg)\n{\n\tdump_properties = true;\n\treturn 1;\n}\n\n__setup(\"dump_apple_properties\", dump_properties_enable);\n\nstruct dev_header {\n\tu32 len;\n\tu32 prop_count;\n\tstruct efi_dev_path path[];\n\t \n};\n\nstruct properties_header {\n\tu32 len;\n\tu32 version;\n\tu32 dev_count;\n\tstruct dev_header dev_header[];\n};\n\nstatic void __init unmarshal_key_value_pairs(struct dev_header *dev_header,\n\t\t\t\t\t     struct device *dev, const void *ptr,\n\t\t\t\t\t     struct property_entry entry[])\n{\n\tint i;\n\n\tfor (i = 0; i < dev_header->prop_count; i++) {\n\t\tint remaining = dev_header->len - (ptr - (void *)dev_header);\n\t\tu32 key_len, val_len, entry_len;\n\t\tconst u8 *entry_data;\n\t\tchar *key;\n\n\t\tif (sizeof(key_len) > remaining)\n\t\t\tbreak;\n\n\t\tkey_len = *(typeof(key_len) *)ptr;\n\t\tif (key_len + sizeof(val_len) > remaining ||\n\t\t    key_len < sizeof(key_len) + sizeof(efi_char16_t) ||\n\t\t    *(efi_char16_t *)(ptr + sizeof(key_len)) == 0) {\n\t\t\tdev_err(dev, \"invalid property name len at %#zx\\n\",\n\t\t\t\tptr - (void *)dev_header);\n\t\t\tbreak;\n\t\t}\n\n\t\tval_len = *(typeof(val_len) *)(ptr + key_len);\n\t\tif (key_len + val_len > remaining ||\n\t\t    val_len < sizeof(val_len)) {\n\t\t\tdev_err(dev, \"invalid property val len at %#zx\\n\",\n\t\t\t\tptr - (void *)dev_header + key_len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tkey = kzalloc((key_len - sizeof(key_len)) * 4 + 1, GFP_KERNEL);\n\t\tif (!key) {\n\t\t\tdev_err(dev, \"cannot allocate property name\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tucs2_as_utf8(key, ptr + sizeof(key_len),\n\t\t\t     key_len - sizeof(key_len));\n\n\t\tentry_data = ptr + key_len + sizeof(val_len);\n\t\tentry_len = val_len - sizeof(val_len);\n\t\tif (entry_len)\n\t\t\tentry[i] = PROPERTY_ENTRY_U8_ARRAY_LEN(key, entry_data,\n\t\t\t\t\t\t\t       entry_len);\n\t\telse\n\t\t\tentry[i] = PROPERTY_ENTRY_BOOL(key);\n\n\t\tif (dump_properties) {\n\t\t\tdev_info(dev, \"property: %s\\n\", key);\n\t\t\tprint_hex_dump(KERN_INFO, pr_fmt(), DUMP_PREFIX_OFFSET,\n\t\t\t\t16, 1, entry_data, entry_len, true);\n\t\t}\n\n\t\tptr += key_len + val_len;\n\t}\n\n\tif (i != dev_header->prop_count) {\n\t\tdev_err(dev, \"got %d device properties, expected %u\\n\", i,\n\t\t\tdev_header->prop_count);\n\t\tprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\n\t\t\t16, 1, dev_header, dev_header->len, true);\n\t\treturn;\n\t}\n\n\tdev_info(dev, \"assigning %d device properties\\n\", i);\n}\n\nstatic int __init unmarshal_devices(struct properties_header *properties)\n{\n\tsize_t offset = offsetof(struct properties_header, dev_header[0]);\n\n\twhile (offset + sizeof(struct dev_header) < properties->len) {\n\t\tstruct dev_header *dev_header = (void *)properties + offset;\n\t\tstruct property_entry *entry = NULL;\n\t\tconst struct efi_dev_path *ptr;\n\t\tstruct device *dev;\n\t\tsize_t len;\n\t\tint ret, i;\n\n\t\tif (offset + dev_header->len > properties->len ||\n\t\t    dev_header->len <= sizeof(*dev_header)) {\n\t\t\tpr_err(\"invalid len in dev_header at %#zx\\n\", offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tptr = dev_header->path;\n\t\tlen = dev_header->len - sizeof(*dev_header);\n\n\t\tdev = efi_get_device_by_path(&ptr, &len);\n\t\tif (IS_ERR(dev)) {\n\t\t\tpr_err(\"device path parse error %ld at %#zx:\\n\",\n\t\t\t       PTR_ERR(dev), (void *)ptr - (void *)dev_header);\n\t\t\tprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, dev_header, dev_header->len, true);\n\t\t\tdev = NULL;\n\t\t\tgoto skip_device;\n\t\t}\n\n\t\tentry = kcalloc(dev_header->prop_count + 1, sizeof(*entry),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tdev_err(dev, \"cannot allocate properties\\n\");\n\t\t\tgoto skip_device;\n\t\t}\n\n\t\tunmarshal_key_value_pairs(dev_header, dev, ptr, entry);\n\t\tif (!entry[0].name)\n\t\t\tgoto skip_device;\n\n\t\tret = device_create_managed_software_node(dev, entry, NULL);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"error %d assigning properties\\n\", ret);\n\n\t\tfor (i = 0; entry[i].name; i++)\n\t\t\tkfree(entry[i].name);\n\nskip_device:\n\t\tkfree(entry);\n\t\tput_device(dev);\n\t\toffset += dev_header->len;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init map_properties(void)\n{\n\tstruct properties_header *properties;\n\tstruct setup_data *data;\n\tu32 data_len;\n\tu64 pa_data;\n\tint ret;\n\n\tif (!x86_apple_machine)\n\t\treturn 0;\n\n\tpa_data = boot_params.hdr.setup_data;\n\twhile (pa_data) {\n\t\tdata = memremap(pa_data, sizeof(*data), MEMREMAP_WB);\n\t\tif (!data) {\n\t\t\tpr_err(\"cannot map setup_data header\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (data->type != SETUP_APPLE_PROPERTIES) {\n\t\t\tpa_data = data->next;\n\t\t\tmemunmap(data);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata_len = data->len;\n\t\tmemunmap(data);\n\n\t\tdata = memremap(pa_data, sizeof(*data) + data_len, MEMREMAP_WB);\n\t\tif (!data) {\n\t\t\tpr_err(\"cannot map setup_data payload\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tproperties = (struct properties_header *)data->data;\n\t\tif (properties->version != 1) {\n\t\t\tpr_err(\"unsupported version:\\n\");\n\t\t\tprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, properties, data_len, true);\n\t\t\tret = -ENOTSUPP;\n\t\t} else if (properties->len != data_len) {\n\t\t\tpr_err(\"length mismatch, expected %u\\n\", data_len);\n\t\t\tprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, properties, data_len, true);\n\t\t\tret = -EINVAL;\n\t\t} else\n\t\t\tret = unmarshal_devices(properties);\n\n\t\t \n\t\tdata->len = 0;\n\t\tmemunmap(data);\n\t\tmemblock_free_late(pa_data + sizeof(*data), data_len);\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nfs_initcall(map_properties);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}