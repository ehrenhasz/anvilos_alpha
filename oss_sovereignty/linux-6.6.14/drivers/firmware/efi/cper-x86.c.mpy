{
  "module_name": "cper-x86.c",
  "hash_id": "9307cacdf2e8d109cab39cac6858984896920c18e8a254b8f65362136d062306",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/cper-x86.c",
  "human_readable_source": "\n\n\n#include <linux/cper.h>\n#include <linux/acpi.h>\n\n \n#define VALID_LAPIC_ID\t\t\tBIT_ULL(0)\n#define VALID_CPUID_INFO\t\tBIT_ULL(1)\n#define VALID_PROC_ERR_INFO_NUM(bits)\t(((bits) & GENMASK_ULL(7, 2)) >> 2)\n#define VALID_PROC_CXT_INFO_NUM(bits)\t(((bits) & GENMASK_ULL(13, 8)) >> 8)\n\n#define INFO_ERR_STRUCT_TYPE_CACHE\t\t\t\t\t\\\n\tGUID_INIT(0xA55701F5, 0xE3EF, 0x43DE, 0xAC, 0x72, 0x24, 0x9B,\t\\\n\t\t  0x57, 0x3F, 0xAD, 0x2C)\n#define INFO_ERR_STRUCT_TYPE_TLB\t\t\t\t\t\\\n\tGUID_INIT(0xFC06B535, 0x5E1F, 0x4562, 0x9F, 0x25, 0x0A, 0x3B,\t\\\n\t\t  0x9A, 0xDB, 0x63, 0xC3)\n#define INFO_ERR_STRUCT_TYPE_BUS\t\t\t\t\t\\\n\tGUID_INIT(0x1CF3F8B3, 0xC5B1, 0x49a2, 0xAA, 0x59, 0x5E, 0xEF,\t\\\n\t\t  0x92, 0xFF, 0xA6, 0x3C)\n#define INFO_ERR_STRUCT_TYPE_MS\t\t\t\t\t\t\\\n\tGUID_INIT(0x48AB7F57, 0xDC34, 0x4f6c, 0xA7, 0xD3, 0xB0, 0xB5,\t\\\n\t\t  0xB0, 0xA7, 0x43, 0x14)\n\n#define INFO_VALID_CHECK_INFO\t\tBIT_ULL(0)\n#define INFO_VALID_TARGET_ID\t\tBIT_ULL(1)\n#define INFO_VALID_REQUESTOR_ID\t\tBIT_ULL(2)\n#define INFO_VALID_RESPONDER_ID\t\tBIT_ULL(3)\n#define INFO_VALID_IP\t\t\tBIT_ULL(4)\n\n#define CHECK_VALID_TRANS_TYPE\t\tBIT_ULL(0)\n#define CHECK_VALID_OPERATION\t\tBIT_ULL(1)\n#define CHECK_VALID_LEVEL\t\tBIT_ULL(2)\n#define CHECK_VALID_PCC\t\t\tBIT_ULL(3)\n#define CHECK_VALID_UNCORRECTED\t\tBIT_ULL(4)\n#define CHECK_VALID_PRECISE_IP\t\tBIT_ULL(5)\n#define CHECK_VALID_RESTARTABLE_IP\tBIT_ULL(6)\n#define CHECK_VALID_OVERFLOW\t\tBIT_ULL(7)\n\n#define CHECK_VALID_BUS_PART_TYPE\tBIT_ULL(8)\n#define CHECK_VALID_BUS_TIME_OUT\tBIT_ULL(9)\n#define CHECK_VALID_BUS_ADDR_SPACE\tBIT_ULL(10)\n\n#define CHECK_VALID_BITS(check)\t\t(((check) & GENMASK_ULL(15, 0)))\n#define CHECK_TRANS_TYPE(check)\t\t(((check) & GENMASK_ULL(17, 16)) >> 16)\n#define CHECK_OPERATION(check)\t\t(((check) & GENMASK_ULL(21, 18)) >> 18)\n#define CHECK_LEVEL(check)\t\t(((check) & GENMASK_ULL(24, 22)) >> 22)\n#define CHECK_PCC\t\t\tBIT_ULL(25)\n#define CHECK_UNCORRECTED\t\tBIT_ULL(26)\n#define CHECK_PRECISE_IP\t\tBIT_ULL(27)\n#define CHECK_RESTARTABLE_IP\t\tBIT_ULL(28)\n#define CHECK_OVERFLOW\t\t\tBIT_ULL(29)\n\n#define CHECK_BUS_PART_TYPE(check)\t(((check) & GENMASK_ULL(31, 30)) >> 30)\n#define CHECK_BUS_TIME_OUT\t\tBIT_ULL(32)\n#define CHECK_BUS_ADDR_SPACE(check)\t(((check) & GENMASK_ULL(34, 33)) >> 33)\n\n#define CHECK_VALID_MS_ERR_TYPE\t\tBIT_ULL(0)\n#define CHECK_VALID_MS_PCC\t\tBIT_ULL(1)\n#define CHECK_VALID_MS_UNCORRECTED\tBIT_ULL(2)\n#define CHECK_VALID_MS_PRECISE_IP\tBIT_ULL(3)\n#define CHECK_VALID_MS_RESTARTABLE_IP\tBIT_ULL(4)\n#define CHECK_VALID_MS_OVERFLOW\t\tBIT_ULL(5)\n\n#define CHECK_MS_ERR_TYPE(check)\t(((check) & GENMASK_ULL(18, 16)) >> 16)\n#define CHECK_MS_PCC\t\t\tBIT_ULL(19)\n#define CHECK_MS_UNCORRECTED\t\tBIT_ULL(20)\n#define CHECK_MS_PRECISE_IP\t\tBIT_ULL(21)\n#define CHECK_MS_RESTARTABLE_IP\t\tBIT_ULL(22)\n#define CHECK_MS_OVERFLOW\t\tBIT_ULL(23)\n\n#define CTX_TYPE_MSR\t\t\t1\n#define CTX_TYPE_MMREG\t\t\t7\n\nenum err_types {\n\tERR_TYPE_CACHE = 0,\n\tERR_TYPE_TLB,\n\tERR_TYPE_BUS,\n\tERR_TYPE_MS,\n\tN_ERR_TYPES\n};\n\nstatic enum err_types cper_get_err_type(const guid_t *err_type)\n{\n\tif (guid_equal(err_type, &INFO_ERR_STRUCT_TYPE_CACHE))\n\t\treturn ERR_TYPE_CACHE;\n\telse if (guid_equal(err_type, &INFO_ERR_STRUCT_TYPE_TLB))\n\t\treturn ERR_TYPE_TLB;\n\telse if (guid_equal(err_type, &INFO_ERR_STRUCT_TYPE_BUS))\n\t\treturn ERR_TYPE_BUS;\n\telse if (guid_equal(err_type, &INFO_ERR_STRUCT_TYPE_MS))\n\t\treturn ERR_TYPE_MS;\n\telse\n\t\treturn N_ERR_TYPES;\n}\n\nstatic const char * const ia_check_trans_type_strs[] = {\n\t\"Instruction\",\n\t\"Data Access\",\n\t\"Generic\",\n};\n\nstatic const char * const ia_check_op_strs[] = {\n\t\"generic error\",\n\t\"generic read\",\n\t\"generic write\",\n\t\"data read\",\n\t\"data write\",\n\t\"instruction fetch\",\n\t\"prefetch\",\n\t\"eviction\",\n\t\"snoop\",\n};\n\nstatic const char * const ia_check_bus_part_type_strs[] = {\n\t\"Local Processor originated request\",\n\t\"Local Processor responded to request\",\n\t\"Local Processor observed\",\n\t\"Generic\",\n};\n\nstatic const char * const ia_check_bus_addr_space_strs[] = {\n\t\"Memory Access\",\n\t\"Reserved\",\n\t\"I/O\",\n\t\"Other Transaction\",\n};\n\nstatic const char * const ia_check_ms_error_type_strs[] = {\n\t\"No Error\",\n\t\"Unclassified\",\n\t\"Microcode ROM Parity Error\",\n\t\"External Error\",\n\t\"FRC Error\",\n\t\"Internal Unclassified\",\n};\n\nstatic const char * const ia_reg_ctx_strs[] = {\n\t\"Unclassified Data\",\n\t\"MSR Registers (Machine Check and other MSRs)\",\n\t\"32-bit Mode Execution Context\",\n\t\"64-bit Mode Execution Context\",\n\t\"FXSAVE Context\",\n\t\"32-bit Mode Debug Registers (DR0-DR7)\",\n\t\"64-bit Mode Debug Registers (DR0-DR7)\",\n\t\"Memory Mapped Registers\",\n};\n\nstatic inline void print_bool(char *str, const char *pfx, u64 check, u64 bit)\n{\n\tprintk(\"%s%s: %s\\n\", pfx, str, (check & bit) ? \"true\" : \"false\");\n}\n\nstatic void print_err_info_ms(const char *pfx, u16 validation_bits, u64 check)\n{\n\tif (validation_bits & CHECK_VALID_MS_ERR_TYPE) {\n\t\tu8 err_type = CHECK_MS_ERR_TYPE(check);\n\n\t\tprintk(\"%sError Type: %u, %s\\n\", pfx, err_type,\n\t\t       err_type < ARRAY_SIZE(ia_check_ms_error_type_strs) ?\n\t\t       ia_check_ms_error_type_strs[err_type] : \"unknown\");\n\t}\n\n\tif (validation_bits & CHECK_VALID_MS_PCC)\n\t\tprint_bool(\"Processor Context Corrupt\", pfx, check, CHECK_MS_PCC);\n\n\tif (validation_bits & CHECK_VALID_MS_UNCORRECTED)\n\t\tprint_bool(\"Uncorrected\", pfx, check, CHECK_MS_UNCORRECTED);\n\n\tif (validation_bits & CHECK_VALID_MS_PRECISE_IP)\n\t\tprint_bool(\"Precise IP\", pfx, check, CHECK_MS_PRECISE_IP);\n\n\tif (validation_bits & CHECK_VALID_MS_RESTARTABLE_IP)\n\t\tprint_bool(\"Restartable IP\", pfx, check, CHECK_MS_RESTARTABLE_IP);\n\n\tif (validation_bits & CHECK_VALID_MS_OVERFLOW)\n\t\tprint_bool(\"Overflow\", pfx, check, CHECK_MS_OVERFLOW);\n}\n\nstatic void print_err_info(const char *pfx, u8 err_type, u64 check)\n{\n\tu16 validation_bits = CHECK_VALID_BITS(check);\n\n\t \n\tif (err_type == ERR_TYPE_MS)\n\t\treturn print_err_info_ms(pfx, validation_bits, check);\n\n\tif (validation_bits & CHECK_VALID_TRANS_TYPE) {\n\t\tu8 trans_type = CHECK_TRANS_TYPE(check);\n\n\t\tprintk(\"%sTransaction Type: %u, %s\\n\", pfx, trans_type,\n\t\t       trans_type < ARRAY_SIZE(ia_check_trans_type_strs) ?\n\t\t       ia_check_trans_type_strs[trans_type] : \"unknown\");\n\t}\n\n\tif (validation_bits & CHECK_VALID_OPERATION) {\n\t\tu8 op = CHECK_OPERATION(check);\n\n\t\t \n\t\tu8 max_ops = (err_type == ERR_TYPE_CACHE) ? 9 : 7;\n\n\t\tprintk(\"%sOperation: %u, %s\\n\", pfx, op,\n\t\t       op < max_ops ? ia_check_op_strs[op] : \"unknown\");\n\t}\n\n\tif (validation_bits & CHECK_VALID_LEVEL)\n\t\tprintk(\"%sLevel: %llu\\n\", pfx, CHECK_LEVEL(check));\n\n\tif (validation_bits & CHECK_VALID_PCC)\n\t\tprint_bool(\"Processor Context Corrupt\", pfx, check, CHECK_PCC);\n\n\tif (validation_bits & CHECK_VALID_UNCORRECTED)\n\t\tprint_bool(\"Uncorrected\", pfx, check, CHECK_UNCORRECTED);\n\n\tif (validation_bits & CHECK_VALID_PRECISE_IP)\n\t\tprint_bool(\"Precise IP\", pfx, check, CHECK_PRECISE_IP);\n\n\tif (validation_bits & CHECK_VALID_RESTARTABLE_IP)\n\t\tprint_bool(\"Restartable IP\", pfx, check, CHECK_RESTARTABLE_IP);\n\n\tif (validation_bits & CHECK_VALID_OVERFLOW)\n\t\tprint_bool(\"Overflow\", pfx, check, CHECK_OVERFLOW);\n\n\tif (err_type != ERR_TYPE_BUS)\n\t\treturn;\n\n\tif (validation_bits & CHECK_VALID_BUS_PART_TYPE) {\n\t\tu8 part_type = CHECK_BUS_PART_TYPE(check);\n\n\t\tprintk(\"%sParticipation Type: %u, %s\\n\", pfx, part_type,\n\t\t       part_type < ARRAY_SIZE(ia_check_bus_part_type_strs) ?\n\t\t       ia_check_bus_part_type_strs[part_type] : \"unknown\");\n\t}\n\n\tif (validation_bits & CHECK_VALID_BUS_TIME_OUT)\n\t\tprint_bool(\"Time Out\", pfx, check, CHECK_BUS_TIME_OUT);\n\n\tif (validation_bits & CHECK_VALID_BUS_ADDR_SPACE) {\n\t\tu8 addr_space = CHECK_BUS_ADDR_SPACE(check);\n\n\t\tprintk(\"%sAddress Space: %u, %s\\n\", pfx, addr_space,\n\t\t       addr_space < ARRAY_SIZE(ia_check_bus_addr_space_strs) ?\n\t\t       ia_check_bus_addr_space_strs[addr_space] : \"unknown\");\n\t}\n}\n\nvoid cper_print_proc_ia(const char *pfx, const struct cper_sec_proc_ia *proc)\n{\n\tint i;\n\tstruct cper_ia_err_info *err_info;\n\tstruct cper_ia_proc_ctx *ctx_info;\n\tchar newpfx[64], infopfx[64];\n\tu8 err_type;\n\n\tif (proc->validation_bits & VALID_LAPIC_ID)\n\t\tprintk(\"%sLocal APIC_ID: 0x%llx\\n\", pfx, proc->lapic_id);\n\n\tif (proc->validation_bits & VALID_CPUID_INFO) {\n\t\tprintk(\"%sCPUID Info:\\n\", pfx);\n\t\tprint_hex_dump(pfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, proc->cpuid,\n\t\t\t       sizeof(proc->cpuid), 0);\n\t}\n\n\tsnprintf(newpfx, sizeof(newpfx), \"%s \", pfx);\n\n\terr_info = (struct cper_ia_err_info *)(proc + 1);\n\tfor (i = 0; i < VALID_PROC_ERR_INFO_NUM(proc->validation_bits); i++) {\n\t\tprintk(\"%sError Information Structure %d:\\n\", pfx, i);\n\n\t\terr_type = cper_get_err_type(&err_info->err_type);\n\t\tprintk(\"%sError Structure Type: %s\\n\", newpfx,\n\t\t       err_type < ARRAY_SIZE(cper_proc_error_type_strs) ?\n\t\t       cper_proc_error_type_strs[err_type] : \"unknown\");\n\n\t\tif (err_type >= N_ERR_TYPES) {\n\t\t\tprintk(\"%sError Structure Type: %pUl\\n\", newpfx,\n\t\t\t       &err_info->err_type);\n\t\t}\n\n\t\tif (err_info->validation_bits & INFO_VALID_CHECK_INFO) {\n\t\t\tprintk(\"%sCheck Information: 0x%016llx\\n\", newpfx,\n\t\t\t       err_info->check_info);\n\n\t\t\tif (err_type < N_ERR_TYPES) {\n\t\t\t\tsnprintf(infopfx, sizeof(infopfx), \"%s \",\n\t\t\t\t\t newpfx);\n\n\t\t\t\tprint_err_info(infopfx, err_type,\n\t\t\t\t\t       err_info->check_info);\n\t\t\t}\n\t\t}\n\n\t\tif (err_info->validation_bits & INFO_VALID_TARGET_ID) {\n\t\t\tprintk(\"%sTarget Identifier: 0x%016llx\\n\",\n\t\t\t       newpfx, err_info->target_id);\n\t\t}\n\n\t\tif (err_info->validation_bits & INFO_VALID_REQUESTOR_ID) {\n\t\t\tprintk(\"%sRequestor Identifier: 0x%016llx\\n\",\n\t\t\t       newpfx, err_info->requestor_id);\n\t\t}\n\n\t\tif (err_info->validation_bits & INFO_VALID_RESPONDER_ID) {\n\t\t\tprintk(\"%sResponder Identifier: 0x%016llx\\n\",\n\t\t\t       newpfx, err_info->responder_id);\n\t\t}\n\n\t\tif (err_info->validation_bits & INFO_VALID_IP) {\n\t\t\tprintk(\"%sInstruction Pointer: 0x%016llx\\n\",\n\t\t\t       newpfx, err_info->ip);\n\t\t}\n\n\t\terr_info++;\n\t}\n\n\tctx_info = (struct cper_ia_proc_ctx *)err_info;\n\tfor (i = 0; i < VALID_PROC_CXT_INFO_NUM(proc->validation_bits); i++) {\n\t\tint size = sizeof(*ctx_info) + ctx_info->reg_arr_size;\n\t\tint groupsize = 4;\n\n\t\tprintk(\"%sContext Information Structure %d:\\n\", pfx, i);\n\n\t\tprintk(\"%sRegister Context Type: %s\\n\", newpfx,\n\t\t       ctx_info->reg_ctx_type < ARRAY_SIZE(ia_reg_ctx_strs) ?\n\t\t       ia_reg_ctx_strs[ctx_info->reg_ctx_type] : \"unknown\");\n\n\t\tprintk(\"%sRegister Array Size: 0x%04x\\n\", newpfx,\n\t\t       ctx_info->reg_arr_size);\n\n\t\tif (ctx_info->reg_ctx_type == CTX_TYPE_MSR) {\n\t\t\tgroupsize = 8;  \n\t\t\tprintk(\"%sMSR Address: 0x%08x\\n\", newpfx,\n\t\t\t       ctx_info->msr_addr);\n\t\t}\n\n\t\tif (ctx_info->reg_ctx_type == CTX_TYPE_MMREG) {\n\t\t\tprintk(\"%sMM Register Address: 0x%016llx\\n\", newpfx,\n\t\t\t       ctx_info->mm_reg_addr);\n\t\t}\n\n\t\tif (ctx_info->reg_ctx_type != CTX_TYPE_MSR ||\n\t\t    arch_apei_report_x86_error(ctx_info, proc->lapic_id)) {\n\t\t\tprintk(\"%sRegister Array:\\n\", newpfx);\n\t\t\tprint_hex_dump(newpfx, \"\", DUMP_PREFIX_OFFSET, 16,\n\t\t\t\t       groupsize, (ctx_info + 1),\n\t\t\t\t       ctx_info->reg_arr_size, 0);\n\t\t}\n\n\t\tctx_info = (struct cper_ia_proc_ctx *)((long)ctx_info + size);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}