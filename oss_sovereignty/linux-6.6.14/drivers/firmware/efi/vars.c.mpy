{
  "module_name": "vars.c",
  "hash_id": "68ea4a9afb09afa4a57afb6f16ad3921c1522420650a9e72625a2ca2c59aa4c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/vars.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"efivars: \" fmt\n\n#include <linux/types.h>\n#include <linux/sizes.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/smp.h>\n#include <linux/efi.h>\n#include <linux/ucs2_string.h>\n\n \nstatic struct efivars *__efivars;\n\nstatic DEFINE_SEMAPHORE(efivars_lock, 1);\n\nstatic efi_status_t check_var_size(bool nonblocking, u32 attributes,\n\t\t\t\t   unsigned long size)\n{\n\tconst struct efivar_operations *fops;\n\tefi_status_t status;\n\n\tfops = __efivars->ops;\n\n\tif (!fops->query_variable_store)\n\t\tstatus = EFI_UNSUPPORTED;\n\telse\n\t\tstatus = fops->query_variable_store(attributes, size,\n\t\t\t\t\t\t    nonblocking);\n\tif (status == EFI_UNSUPPORTED)\n\t\treturn (size <= SZ_64K) ? EFI_SUCCESS : EFI_OUT_OF_RESOURCES;\n\treturn status;\n}\n\n \nbool efivar_is_available(void)\n{\n\treturn __efivars != NULL;\n}\nEXPORT_SYMBOL_GPL(efivar_is_available);\n\n \nint efivars_register(struct efivars *efivars,\n\t\t     const struct efivar_operations *ops)\n{\n\tint rv;\n\n\tif (down_interruptible(&efivars_lock))\n\t\treturn -EINTR;\n\n\tif (__efivars) {\n\t\tpr_warn(\"efivars already registered\\n\");\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tefivars->ops = ops;\n\n\t__efivars = efivars;\n\n\tpr_info(\"Registered efivars operations\\n\");\n\trv = 0;\nout:\n\tup(&efivars_lock);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(efivars_register);\n\n \nint efivars_unregister(struct efivars *efivars)\n{\n\tint rv;\n\n\tif (down_interruptible(&efivars_lock))\n\t\treturn -EINTR;\n\n\tif (!__efivars) {\n\t\tpr_err(\"efivars not registered\\n\");\n\t\trv = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (__efivars != efivars) {\n\t\trv = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpr_info(\"Unregistered efivars operations\\n\");\n\t__efivars = NULL;\n\n\trv = 0;\nout:\n\tup(&efivars_lock);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(efivars_unregister);\n\nbool efivar_supports_writes(void)\n{\n\treturn __efivars && __efivars->ops->set_variable;\n}\nEXPORT_SYMBOL_GPL(efivar_supports_writes);\n\n \nint efivar_lock(void)\n{\n\tif (down_interruptible(&efivars_lock))\n\t\treturn -EINTR;\n\tif (!__efivars->ops) {\n\t\tup(&efivars_lock);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(efivar_lock, EFIVAR);\n\n \nint efivar_trylock(void)\n{\n\tif (down_trylock(&efivars_lock))\n\t\t return -EBUSY;\n\tif (!__efivars->ops) {\n\t\tup(&efivars_lock);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(efivar_trylock, EFIVAR);\n\n \nvoid efivar_unlock(void)\n{\n\tup(&efivars_lock);\n}\nEXPORT_SYMBOL_NS_GPL(efivar_unlock, EFIVAR);\n\n \nefi_status_t efivar_get_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t u32 *attr, unsigned long *size, void *data)\n{\n\treturn __efivars->ops->get_variable(name, vendor, attr, size, data);\n}\nEXPORT_SYMBOL_NS_GPL(efivar_get_variable, EFIVAR);\n\n \nefi_status_t efivar_get_next_variable(unsigned long *name_size,\n\t\t\t\t      efi_char16_t *name, efi_guid_t *vendor)\n{\n\treturn __efivars->ops->get_next_variable(name_size, name, vendor);\n}\nEXPORT_SYMBOL_NS_GPL(efivar_get_next_variable, EFIVAR);\n\n \nefi_status_t efivar_set_variable_locked(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t\tu32 attr, unsigned long data_size,\n\t\t\t\t\tvoid *data, bool nonblocking)\n{\n\tefi_set_variable_t *setvar;\n\tefi_status_t status;\n\n\tif (data_size > 0) {\n\t\tstatus = check_var_size(nonblocking, attr,\n\t\t\t\t\tdata_size + ucs2_strsize(name, 1024));\n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn status;\n\t}\n\n\t \n\tsetvar = __efivars->ops->set_variable_nonblocking;\n\tif (!setvar || !nonblocking)\n\t\t setvar = __efivars->ops->set_variable;\n\n\treturn setvar(name, vendor, attr, data_size, data);\n}\nEXPORT_SYMBOL_NS_GPL(efivar_set_variable_locked, EFIVAR);\n\n \nefi_status_t efivar_set_variable(efi_char16_t *name, efi_guid_t *vendor,\n\t\t\t\t u32 attr, unsigned long data_size, void *data)\n{\n\tefi_status_t status;\n\n\tif (efivar_lock())\n\t\treturn EFI_ABORTED;\n\n\tstatus = efivar_set_variable_locked(name, vendor, attr, data_size,\n\t\t\t\t\t    data, false);\n\tefivar_unlock();\n\treturn status;\n}\nEXPORT_SYMBOL_NS_GPL(efivar_set_variable, EFIVAR);\n\nefi_status_t efivar_query_variable_info(u32 attr,\n\t\t\t\t\tu64 *storage_space,\n\t\t\t\t\tu64 *remaining_space,\n\t\t\t\t\tu64 *max_variable_size)\n{\n\tif (!__efivars->ops->query_variable_info)\n\t\treturn EFI_UNSUPPORTED;\n\treturn __efivars->ops->query_variable_info(attr, storage_space,\n\t\t\tremaining_space, max_variable_size);\n}\nEXPORT_SYMBOL_NS_GPL(efivar_query_variable_info, EFIVAR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}