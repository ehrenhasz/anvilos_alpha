{
  "module_name": "embedded-firmware.c",
  "hash_id": "24d19adb0148515792e62532707258b5343f9fe15a1968324bab97b1c97e4970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/embedded-firmware.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/efi_embedded_fw.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n#include <crypto/sha2.h>\n\n \nLIST_HEAD(efi_embedded_fw_list);\nEXPORT_SYMBOL_NS_GPL(efi_embedded_fw_list, TEST_FIRMWARE);\nbool efi_embedded_fw_checked;\nEXPORT_SYMBOL_NS_GPL(efi_embedded_fw_checked, TEST_FIRMWARE);\n\nstatic const struct dmi_system_id * const embedded_fw_table[] = {\n#ifdef CONFIG_TOUCHSCREEN_DMI\n\ttouchscreen_dmi_table,\n#endif\n\tNULL\n};\n\n \nstatic int __init efi_check_md_for_embedded_firmware(\n\tefi_memory_desc_t *md, const struct efi_embedded_fw_desc *desc)\n{\n\tstruct efi_embedded_fw *fw;\n\tu8 hash[32];\n\tu64 i, size;\n\tu8 *map;\n\n\tsize = md->num_pages << EFI_PAGE_SHIFT;\n\tmap = memremap(md->phys_addr, size, MEMREMAP_WB);\n\tif (!map) {\n\t\tpr_err(\"Error mapping EFI mem at %#llx\\n\", md->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; (i + desc->length) <= size; i += 8) {\n\t\tif (memcmp(map + i, desc->prefix, EFI_EMBEDDED_FW_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tsha256(map + i, desc->length, hash);\n\t\tif (memcmp(hash, desc->sha256, 32) == 0)\n\t\t\tbreak;\n\t}\n\tif ((i + desc->length) > size) {\n\t\tmemunmap(map);\n\t\treturn -ENOENT;\n\t}\n\n\tpr_info(\"Found EFI embedded fw '%s'\\n\", desc->name);\n\n\tfw = kmalloc(sizeof(*fw), GFP_KERNEL);\n\tif (!fw) {\n\t\tmemunmap(map);\n\t\treturn -ENOMEM;\n\t}\n\n\tfw->data = kmemdup(map + i, desc->length, GFP_KERNEL);\n\tmemunmap(map);\n\tif (!fw->data) {\n\t\tkfree(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tfw->name = desc->name;\n\tfw->length = desc->length;\n\tlist_add(&fw->list, &efi_embedded_fw_list);\n\n\treturn 0;\n}\n\nvoid __init efi_check_for_embedded_firmwares(void)\n{\n\tconst struct efi_embedded_fw_desc *fw_desc;\n\tconst struct dmi_system_id *dmi_id;\n\tefi_memory_desc_t *md;\n\tint i, r;\n\n\tfor (i = 0; embedded_fw_table[i]; i++) {\n\t\tdmi_id = dmi_first_match(embedded_fw_table[i]);\n\t\tif (!dmi_id)\n\t\t\tcontinue;\n\n\t\tfw_desc = dmi_id->driver_data;\n\n\t\t \n\t\tif (!fw_desc->name)\n\t\t\tcontinue;\n\n\t\tfor_each_efi_memory_desc(md) {\n\t\t\tif (md->type != EFI_BOOT_SERVICES_CODE)\n\t\t\t\tcontinue;\n\n\t\t\tr = efi_check_md_for_embedded_firmware(md, fw_desc);\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tefi_embedded_fw_checked = true;\n}\n\nint efi_get_embedded_fw(const char *name, const u8 **data, size_t *size)\n{\n\tstruct efi_embedded_fw *iter, *fw = NULL;\n\n\tif (!efi_embedded_fw_checked) {\n\t\tpr_warn(\"Warning %s called while we did not check for embedded fw\\n\",\n\t\t\t__func__);\n\t\treturn -ENOENT;\n\t}\n\n\tlist_for_each_entry(iter, &efi_embedded_fw_list, list) {\n\t\tif (strcmp(name, iter->name) == 0) {\n\t\t\tfw = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!fw)\n\t\treturn -ENOENT;\n\n\t*data = fw->data;\n\t*size = fw->length;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(efi_get_embedded_fw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}