{
  "module_name": "Kconfig",
  "hash_id": "d6b67dc28f8e5f893a8fd2ed795a407b5c0c152077068c50f24e84ef6f86abc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"EFI (Extensible Firmware Interface) Support\"\n\tdepends on EFI\n\nconfig EFI_ESRT\n\tbool\n\tdepends on EFI && !IA64\n\tdefault y\n\nconfig EFI_VARS_PSTORE\n\ttristate \"Register efivars backend for pstore\"\n\tdepends on PSTORE\n\tselect UCS2_STRING\n\tdefault y\n\thelp\n\t  Say Y here to enable use efivars as a backend to pstore. This\n\t  will allow writing console messages, crash dumps, or anything\n\t  else supported by pstore to EFI variables.\n\nconfig EFI_VARS_PSTORE_DEFAULT_DISABLE\n\tbool \"Disable using efivars as a pstore backend by default\"\n\tdepends on EFI_VARS_PSTORE\n\tdefault n\n\thelp\n\t  Saying Y here will disable the use of efivars as a storage\n\t  backend for pstore by default. This setting can be overridden\n\t  using the efivars module's pstore_disable parameter.\n\nconfig EFI_SOFT_RESERVE\n\tbool \"Reserve EFI Specific Purpose Memory\"\n\tdepends on EFI && EFI_STUB && ACPI_HMAT\n\tdefault ACPI_HMAT\n\thelp\n\t  On systems that have mixed performance classes of memory EFI\n\t  may indicate specific purpose memory with an attribute (See\n\t  EFI_MEMORY_SP in UEFI 2.8). A memory range tagged with this\n\t  attribute may have unique performance characteristics compared\n\t  to the system's general purpose \"System RAM\" pool. On the\n\t  expectation that such memory has application specific usage,\n\t  and its base EFI memory type is \"conventional\" answer Y to\n\t  arrange for the kernel to reserve it as a \"Soft Reserved\"\n\t  resource, and set aside for direct-access (device-dax) by\n\t  default. The memory range can later be optionally assigned to\n\t  the page allocator by system administrator policy via the\n\t  device-dax kmem facility. Say N to have the kernel treat this\n\t  memory as \"System RAM\" by default.\n\n\t  If unsure, say Y.\n\nconfig EFI_DXE_MEM_ATTRIBUTES\n\tbool \"Adjust memory attributes in EFISTUB\"\n\tdepends on EFI && EFI_STUB && X86\n\tdefault y\n\thelp\n\t  UEFI specification does not guarantee all memory to be\n\t  accessible for both write and execute as the kernel expects\n\t  it to be.\n\t  Use DXE services to check and alter memory protection\n\t  attributes during boot via EFISTUB to ensure that memory\n\t  ranges used by the kernel are writable and executable.\n\nconfig EFI_PARAMS_FROM_FDT\n\tbool\n\thelp\n\t  Select this config option from the architecture Kconfig if\n\t  the EFI runtime support gets system table address, memory\n          map address, and other parameters from the device tree.\n\nconfig EFI_RUNTIME_WRAPPERS\n\tbool\n\nconfig EFI_GENERIC_STUB\n\tbool\n\nconfig EFI_ZBOOT\n\tbool \"Enable the generic EFI decompressor\"\n\tdepends on EFI_GENERIC_STUB && !ARM\n\tselect HAVE_KERNEL_GZIP\n\tselect HAVE_KERNEL_LZ4\n\tselect HAVE_KERNEL_LZMA\n\tselect HAVE_KERNEL_LZO\n\tselect HAVE_KERNEL_XZ\n\tselect HAVE_KERNEL_ZSTD\n\thelp\n\t  Create the bootable image as an EFI application that carries the\n\t  actual kernel image in compressed form, and decompresses it into\n\t  memory before executing it via LoadImage/StartImage EFI boot service\n\t  calls. For compatibility with non-EFI loaders, the payload can be\n\t  decompressed and executed by the loader as well, provided that the\n\t  loader implements the decompression algorithm and that non-EFI boot\n\t  is supported by the encapsulated image. (The compression algorithm\n\t  used is described in the zboot image header)\n\nconfig EFI_ARMSTUB_DTB_LOADER\n\tbool \"Enable the DTB loader\"\n\tdepends on EFI_GENERIC_STUB && !RISCV && !LOONGARCH\n\tdefault y\n\thelp\n\t  Select this config option to add support for the dtb= command\n\t  line parameter, allowing a device tree blob to be loaded into\n\t  memory from the EFI System Partition by the stub.\n\n\t  If the device tree is provided by the platform or by\n\t  the bootloader this option may not be needed.\n\t  But, for various development reasons and to maintain existing\n\t  functionality for bootloaders that do not have such support\n\t  this option is necessary.\n\nconfig EFI_BOOTLOADER_CONTROL\n\ttristate \"EFI Bootloader Control\"\n\tselect UCS2_STRING\n\tdefault n\n\thelp\n\t  This module installs a reboot hook, such that if reboot() is\n\t  invoked with a string argument NNN, \"NNN\" is copied to the\n\t  \"LoaderEntryOneShot\" EFI variable, to be read by the\n\t  bootloader. If the string matches one of the boot labels\n\t  defined in its configuration, the bootloader will boot once\n\t  to that label. The \"LoaderEntryRebootReason\" EFI variable is\n\t  set with the reboot reason: \"reboot\" or \"shutdown\". The\n\t  bootloader reads this reboot reason and takes particular\n\t  action according to its policy.\n\nconfig EFI_CAPSULE_LOADER\n\ttristate \"EFI capsule loader\"\n\tdepends on EFI && !IA64\n\thelp\n\t  This option exposes a loader interface \"/dev/efi_capsule_loader\" for\n\t  users to load EFI capsules. This driver requires working runtime\n\t  capsule support in the firmware, which many OEMs do not provide.\n\n\t  Most users should say N.\n\nconfig EFI_CAPSULE_QUIRK_QUARK_CSH\n\tbool \"Add support for Quark capsules with non-standard headers\"\n\tdepends on X86 && !64BIT\n\tselect EFI_CAPSULE_LOADER\n\tdefault y\n\thelp\n\t  Add support for processing Quark X1000 EFI capsules, whose header\n\t  layout deviates from the layout mandated by the UEFI specification.\n\nconfig EFI_TEST\n\ttristate \"EFI Runtime Service Tests Support\"\n\tdepends on EFI\n\tdefault n\n\thelp\n\t  This driver uses the efi.<service> function pointers directly instead\n\t  of going through the efivar API, because it is not trying to test the\n\t  kernel subsystem, just for testing the UEFI runtime service\n\t  interfaces which are provided by the firmware. This driver is used\n\t  by the Firmware Test Suite (FWTS) for testing the UEFI runtime\n\t  interfaces readiness of the firmware.\n\t  Details for FWTS are available from:\n\t  <https://wiki.ubuntu.com/FirmwareTestSuite>\n\n\t  Say Y here to enable the runtime services support via /dev/efi_test.\n\t  If unsure, say N.\n\nconfig EFI_DEV_PATH_PARSER\n\tbool\n\nconfig APPLE_PROPERTIES\n\tbool \"Apple Device Properties\"\n\tdepends on EFI_STUB && X86\n\tselect EFI_DEV_PATH_PARSER\n\tselect UCS2_STRING\n\thelp\n\t  Retrieve properties from EFI on Apple Macs and assign them to\n\t  devices, allowing for improved support of Apple hardware.\n\t  Properties that would otherwise be missing include the\n\t  Thunderbolt Device ROM and GPU configuration data.\n\n\t  If unsure, say Y if you have a Mac.  Otherwise N.\n\nconfig RESET_ATTACK_MITIGATION\n\tbool \"Reset memory attack mitigation\"\n\tdepends on EFI_STUB\n\thelp\n\t  Request that the firmware clear the contents of RAM after a reboot\n\t  using the TCG Platform Reset Attack Mitigation specification. This\n\t  protects against an attacker forcibly rebooting the system while it\n\t  still contains secrets in RAM, booting another OS and extracting the\n\t  secrets. This should only be enabled when userland is configured to\n\t  clear the MemoryOverwriteRequest flag on clean shutdown after secrets\n\t  have been evicted, since otherwise it will trigger even on clean\n\t  reboots.\n\nconfig EFI_RCI2_TABLE\n\tbool \"EFI Runtime Configuration Interface Table Version 2 Support\"\n\tdepends on X86 || COMPILE_TEST\n\thelp\n\t  Displays the content of the Runtime Configuration Interface\n\t  Table version 2 on Dell EMC PowerEdge systems as a binary\n\t  attribute 'rci2' under /sys/firmware/efi/tables directory.\n\n\t  RCI2 table contains BIOS HII in XML format and is used to populate\n\t  BIOS setup page in Dell EMC OpenManage Server Administrator tool.\n\t  The BIOS setup page contains BIOS tokens which can be configured.\n\n\t  Say Y here for Dell EMC PowerEdge systems.\n\nconfig EFI_DISABLE_PCI_DMA\n       bool \"Clear Busmaster bit on PCI bridges during ExitBootServices()\"\n       help\n\t  Disable the busmaster bit in the control register on all PCI bridges\n\t  while calling ExitBootServices() and passing control to the runtime\n\t  kernel. System firmware may configure the IOMMU to prevent malicious\n\t  PCI devices from being able to attack the OS via DMA. However, since\n\t  firmware can't guarantee that the OS is IOMMU-aware, it will tear\n\t  down IOMMU configuration when ExitBootServices() is called. This\n\t  leaves a window between where a hostile device could still cause\n\t  damage before Linux configures the IOMMU again.\n\n\t  If you say Y here, the EFI stub will clear the busmaster bit on all\n\t  PCI bridges before ExitBootServices() is called. This will prevent\n\t  any malicious PCI devices from being able to perform DMA until the\n\t  kernel reenables busmastering after configuring the IOMMU.\n\n\t  This option will cause failures with some poorly behaved hardware\n\t  and should not be enabled without testing. The kernel commandline\n\t  options \"efi=disable_early_pci_dma\" or \"efi=no_disable_early_pci_dma\"\n\t  may be used to override this option.\n\nconfig EFI_EARLYCON\n\tdef_bool y\n\tdepends on SERIAL_EARLYCON && !ARM && !IA64\n\tselect FONT_SUPPORT\n\tselect ARCH_USE_MEMREMAP_PROT\n\nconfig EFI_CUSTOM_SSDT_OVERLAYS\n\tbool \"Load custom ACPI SSDT overlay from an EFI variable\"\n\tdepends on ACPI\n\tdefault ACPI_TABLE_UPGRADE\n\thelp\n\t  Allow loading of an ACPI SSDT overlay from an EFI variable specified\n\t  by a kernel command line option.\n\n\t  See Documentation/admin-guide/acpi/ssdt-overlays.rst for more\n\t  information.\n\nconfig EFI_DISABLE_RUNTIME\n\tbool \"Disable EFI runtime services support by default\"\n\tdefault y if PREEMPT_RT\n\thelp\n\t  Allow to disable the EFI runtime services support by default. This can\n\t  already be achieved by using the efi=noruntime option, but it could be\n\t  useful to have this default without any kernel command line parameter.\n\n\t  The EFI runtime services are disabled by default when PREEMPT_RT is\n\t  enabled, because measurements have shown that some EFI functions calls\n\t  might take too much time to complete, causing large latencies which is\n\t  an issue for Real-Time kernels.\n\n\t  This default can be overridden by using the efi=runtime option.\n\nconfig EFI_COCO_SECRET\n\tbool \"EFI Confidential Computing Secret Area Support\"\n\thelp\n\t  Confidential Computing platforms (such as AMD SEV) allow the\n\t  Guest Owner to securely inject secrets during guest VM launch.\n\t  The secrets are placed in a designated EFI reserved memory area.\n\n\t  In order to use the secrets in the kernel, the location of the secret\n\t  area (as published in the EFI config table) must be kept.\n\n\t  If you say Y here, the address of the EFI secret area will be kept\n\t  for usage inside the kernel.  This will allow the\n\t  virt/coco/efi_secret module to access the secrets, which in turn\n\t  allows userspace programs to access the injected secrets.\n\nconfig UNACCEPTED_MEMORY\n\tbool\n\tdepends on EFI_STUB\n\thelp\n\t   Some Virtual Machine platforms, such as Intel TDX, require\n\t   some memory to be \"accepted\" by the guest before it can be used.\n\t   This mechanism helps prevent malicious hosts from making changes\n\t   to guest memory.\n\n\t   UEFI specification v2.9 introduced EFI_UNACCEPTED_MEMORY memory type.\n\n\t   This option adds support for unaccepted memory and makes such memory\n\t   usable by the kernel.\n\nconfig EFI_EMBEDDED_FIRMWARE\n\tbool\n\tselect CRYPTO_LIB_SHA256\n\nendmenu\n\nconfig UEFI_CPER\n\tbool\n\nconfig UEFI_CPER_ARM\n\tbool\n\tdepends on UEFI_CPER && ( ARM || ARM64 )\n\tdefault y\n\nconfig UEFI_CPER_X86\n\tbool\n\tdepends on UEFI_CPER && X86\n\tdefault y\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}