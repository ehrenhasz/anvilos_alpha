{
  "module_name": "capsule.c",
  "hash_id": "89309a8f12d258a243db3090500d0a56aac71d7ac17e780f2df0ee7d6682fbdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/capsule.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/efi.h>\n#include <linux/vmalloc.h>\n#include <asm/efi.h>\n#include <asm/io.h>\n\ntypedef struct {\n\tu64 length;\n\tu64 data;\n} efi_capsule_block_desc_t;\n\nstatic bool capsule_pending;\nstatic bool stop_capsules;\nstatic int efi_reset_type = -1;\n\n \nstatic DEFINE_MUTEX(capsule_mutex);\n\n \nbool efi_capsule_pending(int *reset_type)\n{\n\tif (!capsule_pending)\n\t\treturn false;\n\n\tif (reset_type)\n\t\t*reset_type = efi_reset_type;\n\n\treturn true;\n}\n\n \n#define EFI_CAPSULE_SUPPORTED_FLAG_MASK\t\t\t\\\n\t(EFI_CAPSULE_PERSIST_ACROSS_RESET | EFI_CAPSULE_POPULATE_SYSTEM_TABLE)\n\n \nint efi_capsule_supported(efi_guid_t guid, u32 flags, size_t size, int *reset)\n{\n\tefi_capsule_header_t capsule;\n\tefi_capsule_header_t *cap_list[] = { &capsule };\n\tefi_status_t status;\n\tu64 max_size;\n\n\tif (flags & ~EFI_CAPSULE_SUPPORTED_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tcapsule.headersize = capsule.imagesize = sizeof(capsule);\n\tmemcpy(&capsule.guid, &guid, sizeof(efi_guid_t));\n\tcapsule.flags = flags;\n\n\tstatus = efi.query_capsule_caps(cap_list, 1, &max_size, reset);\n\tif (status != EFI_SUCCESS)\n\t\treturn efi_status_to_err(status);\n\n\tif (size > max_size)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(efi_capsule_supported);\n\n \n#define SGLIST_PER_PAGE\t((PAGE_SIZE / sizeof(efi_capsule_block_desc_t)) - 1)\n\n \nstatic inline unsigned int sg_pages_num(unsigned int count)\n{\n\treturn DIV_ROUND_UP(count, SGLIST_PER_PAGE);\n}\n\n \nstatic int\nefi_capsule_update_locked(efi_capsule_header_t *capsule,\n\t\t\t  struct page **sg_pages, int reset)\n{\n\tefi_physical_addr_t sglist_phys;\n\tefi_status_t status;\n\n\tlockdep_assert_held(&capsule_mutex);\n\n\t \n\tif (efi_reset_type >= 0 && efi_reset_type != reset) {\n\t\tpr_err(\"Conflicting capsule reset type %d (%d).\\n\",\n\t\t       reset, efi_reset_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(stop_capsules)) {\n\t\tpr_warn(\"Capsule update raced with reboot, aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsglist_phys = page_to_phys(sg_pages[0]);\n\n\tstatus = efi.update_capsule(&capsule, 1, sglist_phys);\n\tif (status == EFI_SUCCESS) {\n\t\tcapsule_pending = true;\n\t\tefi_reset_type = reset;\n\t}\n\n\treturn efi_status_to_err(status);\n}\n\n \nint efi_capsule_update(efi_capsule_header_t *capsule, phys_addr_t *pages)\n{\n\tu32 imagesize = capsule->imagesize;\n\tefi_guid_t guid = capsule->guid;\n\tunsigned int count, sg_count;\n\tu32 flags = capsule->flags;\n\tstruct page **sg_pages;\n\tint rv, reset_type;\n\tint i, j;\n\n\trv = efi_capsule_supported(guid, flags, imagesize, &reset_type);\n\tif (rv)\n\t\treturn rv;\n\n\tcount = DIV_ROUND_UP(imagesize, PAGE_SIZE);\n\tsg_count = sg_pages_num(count);\n\n\tsg_pages = kcalloc(sg_count, sizeof(*sg_pages), GFP_KERNEL);\n\tif (!sg_pages)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < sg_count; i++) {\n\t\tsg_pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!sg_pages[i]) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < sg_count; i++) {\n\t\tefi_capsule_block_desc_t *sglist;\n\n\t\tsglist = kmap_atomic(sg_pages[i]);\n\n\t\tfor (j = 0; j < SGLIST_PER_PAGE && count > 0; j++) {\n\t\t\tu64 sz = min_t(u64, imagesize,\n\t\t\t\t       PAGE_SIZE - (u64)*pages % PAGE_SIZE);\n\n\t\t\tsglist[j].length = sz;\n\t\t\tsglist[j].data = *pages++;\n\n\t\t\timagesize -= sz;\n\t\t\tcount--;\n\t\t}\n\n\t\t \n\t\tsglist[j].length = 0;\n\n\t\tif (i + 1 == sg_count)\n\t\t\tsglist[j].data = 0;\n\t\telse\n\t\t\tsglist[j].data = page_to_phys(sg_pages[i + 1]);\n\n#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)\n\t\t \n\t\tefi_capsule_flush_cache_range(sglist, PAGE_SIZE);\n#endif\n\t\tkunmap_atomic(sglist);\n\t}\n\n\tmutex_lock(&capsule_mutex);\n\trv = efi_capsule_update_locked(capsule, sg_pages, reset_type);\n\tmutex_unlock(&capsule_mutex);\n\nout:\n\tfor (i = 0; rv && i < sg_count; i++) {\n\t\tif (sg_pages[i])\n\t\t\t__free_page(sg_pages[i]);\n\t}\n\n\tkfree(sg_pages);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(efi_capsule_update);\n\nstatic int capsule_reboot_notify(struct notifier_block *nb, unsigned long event, void *cmd)\n{\n\tmutex_lock(&capsule_mutex);\n\tstop_capsules = true;\n\tmutex_unlock(&capsule_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block capsule_reboot_nb = {\n\t.notifier_call = capsule_reboot_notify,\n};\n\nstatic int __init capsule_reboot_register(void)\n{\n\treturn register_reboot_notifier(&capsule_reboot_nb);\n}\ncore_initcall(capsule_reboot_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}