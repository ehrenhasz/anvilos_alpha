{
  "module_name": "cper_cxl.c",
  "hash_id": "f404fb1e523c17f36977dcdd66cbad26b6ab4130ccaa001f5678c4bce751a3e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/cper_cxl.c",
  "human_readable_source": "\n \n\n#include <linux/cper.h>\n#include \"cper_cxl.h\"\n\n#define PROT_ERR_VALID_AGENT_TYPE\t\tBIT_ULL(0)\n#define PROT_ERR_VALID_AGENT_ADDRESS\t\tBIT_ULL(1)\n#define PROT_ERR_VALID_DEVICE_ID\t\tBIT_ULL(2)\n#define PROT_ERR_VALID_SERIAL_NUMBER\t\tBIT_ULL(3)\n#define PROT_ERR_VALID_CAPABILITY\t\tBIT_ULL(4)\n#define PROT_ERR_VALID_DVSEC\t\t\tBIT_ULL(5)\n#define PROT_ERR_VALID_ERROR_LOG\t\tBIT_ULL(6)\n\n \nstruct cxl_ras_capability_regs {\n\tu32 uncor_status;\n\tu32 uncor_mask;\n\tu32 uncor_severity;\n\tu32 cor_status;\n\tu32 cor_mask;\n\tu32 cap_control;\n\tu32 header_log[16];\n};\n\nstatic const char * const prot_err_agent_type_strs[] = {\n\t\"Restricted CXL Device\",\n\t\"Restricted CXL Host Downstream Port\",\n\t\"CXL Device\",\n\t\"CXL Logical Device\",\n\t\"CXL Fabric Manager managed Logical Device\",\n\t\"CXL Root Port\",\n\t\"CXL Downstream Switch Port\",\n\t\"CXL Upstream Switch Port\",\n};\n\n \nenum {\n\tRCD,\t \n\tRCH_DP,\t \n\tDEVICE,\t \n\tLD,\t \n\tFMLD,\t \n\tRP,\t \n\tDSP,\t \n\tUSP,\t \n};\n\nvoid cper_print_prot_err(const char *pfx, const struct cper_sec_prot_err *prot_err)\n{\n\tif (prot_err->valid_bits & PROT_ERR_VALID_AGENT_TYPE)\n\t\tpr_info(\"%s agent_type: %d, %s\\n\", pfx, prot_err->agent_type,\n\t\t\tprot_err->agent_type < ARRAY_SIZE(prot_err_agent_type_strs)\n\t\t\t? prot_err_agent_type_strs[prot_err->agent_type]\n\t\t\t: \"unknown\");\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_AGENT_ADDRESS) {\n\t\tswitch (prot_err->agent_type) {\n\t\t \n\t\tcase RCD:\n\t\tcase DEVICE:\n\t\tcase LD:\n\t\tcase FMLD:\n\t\tcase RP:\n\t\tcase DSP:\n\t\tcase USP:\n\t\t\tpr_info(\"%s agent_address: %04x:%02x:%02x.%x\\n\",\n\t\t\t\tpfx, prot_err->agent_addr.segment,\n\t\t\t\tprot_err->agent_addr.bus,\n\t\t\t\tprot_err->agent_addr.device,\n\t\t\t\tprot_err->agent_addr.function);\n\t\t\tbreak;\n\t\tcase RCH_DP:\n\t\t\tpr_info(\"%s rcrb_base_address: 0x%016llx\\n\", pfx,\n\t\t\t\tprot_err->agent_addr.rcrb_base_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_DEVICE_ID) {\n\t\tconst __u8 *class_code;\n\n\t\tswitch (prot_err->agent_type) {\n\t\tcase RCD:\n\t\tcase DEVICE:\n\t\tcase LD:\n\t\tcase FMLD:\n\t\tcase RP:\n\t\tcase DSP:\n\t\tcase USP:\n\t\t\tpr_info(\"%s slot: %d\\n\", pfx,\n\t\t\t\tprot_err->device_id.slot >> CPER_PCIE_SLOT_SHIFT);\n\t\t\tpr_info(\"%s vendor_id: 0x%04x, device_id: 0x%04x\\n\",\n\t\t\t\tpfx, prot_err->device_id.vendor_id,\n\t\t\t\tprot_err->device_id.device_id);\n\t\t\tpr_info(\"%s sub_vendor_id: 0x%04x, sub_device_id: 0x%04x\\n\",\n\t\t\t\tpfx, prot_err->device_id.subsystem_vendor_id,\n\t\t\t\tprot_err->device_id.subsystem_id);\n\t\t\tclass_code = prot_err->device_id.class_code;\n\t\t\tpr_info(\"%s class_code: %02x%02x\\n\", pfx,\n\t\t\t\tclass_code[1], class_code[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_SERIAL_NUMBER) {\n\t\tswitch (prot_err->agent_type) {\n\t\tcase RCD:\n\t\tcase DEVICE:\n\t\tcase LD:\n\t\tcase FMLD:\n\t\t\tpr_info(\"%s lower_dw: 0x%08x, upper_dw: 0x%08x\\n\", pfx,\n\t\t\t\tprot_err->dev_serial_num.lower_dw,\n\t\t\t\tprot_err->dev_serial_num.upper_dw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_CAPABILITY) {\n\t\tswitch (prot_err->agent_type) {\n\t\tcase RCD:\n\t\tcase DEVICE:\n\t\tcase LD:\n\t\tcase FMLD:\n\t\tcase RP:\n\t\tcase DSP:\n\t\tcase USP:\n\t\t\tprint_hex_dump(pfx, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t\t\t       prot_err->capability,\n\t\t\t\t       sizeof(prot_err->capability), 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_DVSEC) {\n\t\tpr_info(\"%s DVSEC length: 0x%04x\\n\", pfx, prot_err->dvsec_len);\n\n\t\tpr_info(\"%s CXL DVSEC:\\n\", pfx);\n\t\tprint_hex_dump(pfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, (prot_err + 1),\n\t\t\t       prot_err->dvsec_len, 0);\n\t}\n\n\tif (prot_err->valid_bits & PROT_ERR_VALID_ERROR_LOG) {\n\t\tsize_t size = sizeof(*prot_err) + prot_err->dvsec_len;\n\t\tstruct cxl_ras_capability_regs *cxl_ras;\n\n\t\tpr_info(\"%s Error log length: 0x%04x\\n\", pfx, prot_err->err_len);\n\n\t\tpr_info(\"%s CXL Error Log:\\n\", pfx);\n\t\tcxl_ras = (struct cxl_ras_capability_regs *)((long)prot_err + size);\n\t\tpr_info(\"%s cxl_ras_uncor_status: 0x%08x\", pfx,\n\t\t\tcxl_ras->uncor_status);\n\t\tpr_info(\"%s cxl_ras_uncor_mask: 0x%08x\\n\", pfx,\n\t\t\tcxl_ras->uncor_mask);\n\t\tpr_info(\"%s cxl_ras_uncor_severity: 0x%08x\\n\", pfx,\n\t\t\tcxl_ras->uncor_severity);\n\t\tpr_info(\"%s cxl_ras_cor_status: 0x%08x\", pfx,\n\t\t\tcxl_ras->cor_status);\n\t\tpr_info(\"%s cxl_ras_cor_mask: 0x%08x\\n\", pfx,\n\t\t\tcxl_ras->cor_mask);\n\t\tpr_info(\"%s cap_control: 0x%08x\\n\", pfx,\n\t\t\tcxl_ras->cap_control);\n\t\tpr_info(\"%s Header Log Registers:\\n\", pfx);\n\t\tprint_hex_dump(pfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, cxl_ras->header_log,\n\t\t\t       sizeof(cxl_ras->header_log), 0);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}