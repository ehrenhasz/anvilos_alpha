{
  "module_name": "randomalloc.c",
  "hash_id": "1745afc5613f742cc1ef1fbad6044f1145122c01bbfec139b6b21500067a71af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/randomalloc.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/log2.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\n \nstatic unsigned long get_entry_num_slots(efi_memory_desc_t *md,\n\t\t\t\t\t unsigned long size,\n\t\t\t\t\t unsigned long align_shift,\n\t\t\t\t\t u64 alloc_limit)\n{\n\tunsigned long align = 1UL << align_shift;\n\tu64 first_slot, last_slot, region_end;\n\n\tif (md->type != EFI_CONVENTIONAL_MEMORY)\n\t\treturn 0;\n\n\tif (efi_soft_reserve_enabled() &&\n\t    (md->attribute & EFI_MEMORY_SP))\n\t\treturn 0;\n\n\tregion_end = min(md->phys_addr + md->num_pages * EFI_PAGE_SIZE - 1,\n\t\t\t alloc_limit);\n\tif (region_end < size)\n\t\treturn 0;\n\n\tfirst_slot = round_up(md->phys_addr, align);\n\tlast_slot = round_down(region_end - size + 1, align);\n\n\tif (first_slot > last_slot)\n\t\treturn 0;\n\n\treturn ((unsigned long)(last_slot - first_slot) >> align_shift) + 1;\n}\n\n \n#define MD_NUM_SLOTS(md)\t((md)->virt_addr)\n\nefi_status_t efi_random_alloc(unsigned long size,\n\t\t\t      unsigned long align,\n\t\t\t      unsigned long *addr,\n\t\t\t      unsigned long random_seed,\n\t\t\t      int memory_type,\n\t\t\t      unsigned long alloc_limit)\n{\n\tunsigned long total_slots = 0, target_slot;\n\tunsigned long total_mirrored_slots = 0;\n\tstruct efi_boot_memmap *map;\n\tefi_status_t status;\n\tint map_offset;\n\n\tstatus = efi_get_memory_map(&map, false);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tif (align < EFI_ALLOC_ALIGN)\n\t\talign = EFI_ALLOC_ALIGN;\n\n\tsize = round_up(size, EFI_ALLOC_ALIGN);\n\n\t \n\tfor (map_offset = 0; map_offset < map->map_size; map_offset += map->desc_size) {\n\t\tefi_memory_desc_t *md = (void *)map->map + map_offset;\n\t\tunsigned long slots;\n\n\t\tslots = get_entry_num_slots(md, size, ilog2(align), alloc_limit);\n\t\tMD_NUM_SLOTS(md) = slots;\n\t\ttotal_slots += slots;\n\t\tif (md->attribute & EFI_MEMORY_MORE_RELIABLE)\n\t\t\ttotal_mirrored_slots += slots;\n\t}\n\n\t \n\tif (total_mirrored_slots > 0)\n\t\ttotal_slots = total_mirrored_slots;\n\n\t \n\ttarget_slot = (total_slots * (u64)(random_seed & U32_MAX)) >> 32;\n\n\t \n\tstatus = EFI_OUT_OF_RESOURCES;\n\tfor (map_offset = 0; map_offset < map->map_size; map_offset += map->desc_size) {\n\t\tefi_memory_desc_t *md = (void *)map->map + map_offset;\n\t\tefi_physical_addr_t target;\n\t\tunsigned long pages;\n\n\t\tif (total_mirrored_slots > 0 &&\n\t\t    !(md->attribute & EFI_MEMORY_MORE_RELIABLE))\n\t\t\tcontinue;\n\n\t\tif (target_slot >= MD_NUM_SLOTS(md)) {\n\t\t\ttarget_slot -= MD_NUM_SLOTS(md);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget = round_up(md->phys_addr, align) + target_slot * align;\n\t\tpages = size / EFI_PAGE_SIZE;\n\n\t\tstatus = efi_bs_call(allocate_pages, EFI_ALLOCATE_ADDRESS,\n\t\t\t\t     memory_type, pages, &target);\n\t\tif (status == EFI_SUCCESS)\n\t\t\t*addr = target;\n\t\tbreak;\n\t}\n\n\tefi_bs_call(free_pool, map);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}