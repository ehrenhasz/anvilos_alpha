{
  "module_name": "arm32-stub.c",
  "hash_id": "ac8f78b67a99a915a6b9f60e4fa02e78a6e0eda32c35174ff351a78ac61020f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/arm32-stub.c",
  "human_readable_source": "\n \n#include <linux/efi.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\nstatic efi_guid_t cpu_state_guid = LINUX_EFI_ARM_CPU_STATE_TABLE_GUID;\n\nstruct efi_arm_entry_state *efi_entry_state;\n\nstatic void get_cpu_state(u32 *cpsr, u32 *sctlr)\n{\n\tasm(\"mrs %0, cpsr\" : \"=r\"(*cpsr));\n\tif ((*cpsr & MODE_MASK) == HYP_MODE)\n\t\tasm(\"mrc p15, 4, %0, c1, c0, 0\" : \"=r\"(*sctlr));\n\telse\n\t\tasm(\"mrc p15, 0, %0, c1, c0, 0\" : \"=r\"(*sctlr));\n}\n\nefi_status_t check_platform_features(void)\n{\n\tefi_status_t status;\n\tu32 cpsr, sctlr;\n\tint block;\n\n\tget_cpu_state(&cpsr, &sctlr);\n\n\tefi_info(\"Entering in %s mode with MMU %sabled\\n\",\n\t\t ((cpsr & MODE_MASK) == HYP_MODE) ? \"HYP\" : \"SVC\",\n\t\t (sctlr & 1) ? \"en\" : \"dis\");\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA,\n\t\t\t     sizeof(*efi_entry_state),\n\t\t\t     (void **)&efi_entry_state);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"allocate_pool() failed\\n\");\n\t\treturn status;\n\t}\n\n\tefi_entry_state->cpsr_before_ebs = cpsr;\n\tefi_entry_state->sctlr_before_ebs = sctlr;\n\n\tstatus = efi_bs_call(install_configuration_table, &cpu_state_guid,\n\t\t\t     efi_entry_state);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"install_configuration_table() failed\\n\");\n\t\tgoto free_state;\n\t}\n\n\t \n\tif (!IS_ENABLED(CONFIG_ARM_LPAE))\n\t\treturn EFI_SUCCESS;\n\n\t \n\tblock = cpuid_feature_extract(CPUID_EXT_MMFR0, 0);\n\tif (block < 5) {\n\t\tefi_err(\"This LPAE kernel is not supported by your CPU\\n\");\n\t\tstatus = EFI_UNSUPPORTED;\n\t\tgoto drop_table;\n\t}\n\treturn EFI_SUCCESS;\n\ndrop_table:\n\tefi_bs_call(install_configuration_table, &cpu_state_guid, NULL);\nfree_state:\n\tefi_bs_call(free_pool, efi_entry_state);\n\treturn status;\n}\n\nvoid efi_handle_post_ebs_state(void)\n{\n\tget_cpu_state(&efi_entry_state->cpsr_after_ebs,\n\t\t      &efi_entry_state->sctlr_after_ebs);\n}\n\nefi_status_t handle_kernel_image(unsigned long *image_addr,\n\t\t\t\t unsigned long *image_size,\n\t\t\t\t unsigned long *reserve_addr,\n\t\t\t\t unsigned long *reserve_size,\n\t\t\t\t efi_loaded_image_t *image,\n\t\t\t\t efi_handle_t image_handle)\n{\n\tconst int slack = TEXT_OFFSET - 5 * PAGE_SIZE;\n\tint alloc_size = MAX_UNCOMP_KERNEL_SIZE + EFI_PHYS_ALIGN;\n\tunsigned long alloc_base, kernel_base;\n\tefi_status_t status;\n\n\t \n\tstatus = efi_low_alloc_above(alloc_size, EFI_PAGE_SIZE, &alloc_base, 0x0);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Unable to allocate memory for uncompressed kernel.\\n\");\n\t\treturn status;\n\t}\n\n\tif ((alloc_base % EFI_PHYS_ALIGN) > slack) {\n\t\t \n\t\tkernel_base = round_up(alloc_base, EFI_PHYS_ALIGN);\n\t\tefi_info(\"Free memory starts at 0x%lx, setting kernel_base to 0x%lx\\n\",\n\t\t\t alloc_base, kernel_base);\n\t} else {\n\t\tkernel_base = round_down(alloc_base, EFI_PHYS_ALIGN);\n\t}\n\n\t*reserve_addr = kernel_base + slack;\n\t*reserve_size = MAX_UNCOMP_KERNEL_SIZE;\n\n\t \n\tif (*reserve_addr > alloc_base) {\n\t\tefi_bs_call(free_pages, alloc_base,\n\t\t\t    (*reserve_addr - alloc_base) / EFI_PAGE_SIZE);\n\t\talloc_size -= *reserve_addr - alloc_base;\n\t}\n\tefi_bs_call(free_pages, *reserve_addr + MAX_UNCOMP_KERNEL_SIZE,\n\t\t    (alloc_size - MAX_UNCOMP_KERNEL_SIZE) / EFI_PAGE_SIZE);\n\n\t*image_addr = kernel_base + TEXT_OFFSET;\n\t*image_size = 0;\n\n\tefi_debug(\"image addr == 0x%lx, reserve_addr == 0x%lx\\n\",\n\t\t  *image_addr, *reserve_addr);\n\n\treturn EFI_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}